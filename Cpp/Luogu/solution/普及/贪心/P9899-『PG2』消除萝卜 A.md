# 『PG2』消除萝卜 A

## 题目描述

有 $2\times n$ 的两行萝卜，萝卜分白萝卜和红萝卜，我们使用 $a_{i,j}=0/1$ 来表示第 $j$ 行第 $i$ 个萝卜是白萝卜还是红萝卜。

你每次可以花 $1$ 的代价，选定一个有萝卜的位置，并将这个萝卜所在的由同种颜色萝卜所构成的四连通极大连通块的萝卜全部拿走，然后一个在第二行的萝卜如果其对应的第一行的位置没有萝卜，就会掉落至第一行。

请问拿走所有萝卜的最小代价是多少。

## 说明/提示

对于所有测试点 $a_{i,j}\in \{0,1\}$，$1\leq n\leq 5\times 10^6$。

**本题使用捆绑测试**

$\sf subtask \ 1: n\leq1 \ \ \ \ \ \ \ \ \ \ \ \ \ 10pts$   
$\sf subtask \ 2: n\leq10 \ \ \ \ \ \ \ \ \ \ \ 20pts $   
$\sf subtask \ 3: n\leq100 \ \ \ \ \ \ \ \ \ 15 pts$   
$\sf subtask \ 4: n\leq5000 \ \ \ \ \ \ \ 15 pts$   
$\sf subtask \ 5: n\leq500000 \ \ \ 20pts$   
$\sf subtask \ 6: n\leq5000000 \ 20pts$   

## 样例 #1

### 输入

```
3
0 1 0
1 0 1```

### 输出

```
4```

## 样例 #2

### 输入

```
6
1 0 1 0 0 1
1 1 0 1 0 1```

### 输出

```
5```

## 样例 #3

### 输入

```
10
0 0 1 1 1 1 1 1 0 0 
0 1 1 0 1 0 0 0 0 1 
```

### 输出

```
5```

## 样例 #4

### 输入

```
10
0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0```

### 输出

```
11```

## 样例 #5

### 输入

```
10
1 0 1 1 1 0 0 1 0 1
0 0 0 1 0 1 0 1 1 0```

### 输出

```
8```

# 题解

## 作者：SSqwq_ (赞：11)

## 题意

消除星星，但是版面只有两行。求最少操作次数。

## 分析

考虑简单贪心。

容易发现，所有位于第二行的萝卜位置相当于已经固定，因此选定一种颜色的萝卜，将第二行所有该种颜色的萝卜消除。

之后处理一次萝卜下落事件，再将第一行剩余的刚才选定颜色的萝卜消除。

然后场上只剩下另一种颜色的萝卜了，直接消完就做完了。

## 正确性证明

考虑消除一个连通块的萝卜的贡献有两种：

- 消除了一些萝卜。

- **使得原本在上方的萝卜落下**。

一个 trival 的观察：若要产生第二种贡献，必须保证该连通块中至少一个萝卜在第二行。

所以从第二行选定颜色起消是正确的，并可能使得另一种颜色的萝卜下落造成原本不相连的连通块变为同一个连通块，从而减少消萝卜次数。

**下面证明不产生第二种贡献的情况是不优的。**

对于任意处于第一行的萝卜，下落后场上该种颜色萝卜的连通块一定是不增的。

因为由于只有两种颜色，其左右两边与其同种颜色的萝卜必然会与其一同下落（因为第二行对应位置必然同时在一次操作中被消除）。

于是证毕。

## Code

深搜会爆空间。

代码使用广搜，选定先消除的颜色为 1。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5000001][4],ans,p; // p 代表当前颜色
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
struct F{
	int x,y;
};
queue<F> qu;
void bfs(int sx,int sy){
	F q;
	q.x=sx,q.y=sy;
	qu.push(q);
	while(!qu.empty()){
		q=qu.front();
		qu.pop();
		int x=q.x,y=q.y;
		for(int i=0;i<4;++i){
			int nx=x+dx[i],ny=y+dy[i];
			if(nx<1||nx>n||ny<1||ny>2||a[nx][ny]!=p)continue;
			a[nx][ny]=2;
			q.x=nx,q.y=ny;
			qu.push(q);
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i][1];
	}
	for(int i=1;i<=n;++i){
		cin>>a[i][2];
	}
	for(int i=1;i<=n;++i){
		if(a[i][2]==1){
			a[i][2]=2;
			p=1;
			bfs(i,2);
			ans++;
		}
	}
	for(int i=1;i<=n;++i){
		if(a[i][2]==2){
			swap(a[i][1],a[i][2]);
		}
	}
	for(int i=1;i<=n;++i){
		if(a[i][1]==1){
			a[i][1]=2;
			p=1;
			bfs(i,1);
			ans++;
		}
	}
	for(int i=1;i<=n;++i){
		if(a[i][2]==0){
			a[i][2]=2;
			p=0;
			bfs(i,2);
			ans++;
		}
	}
	cout<<ans<<"\n";
	return 0;
}
```


---

## 作者：HasNoName (赞：8)

#### 题目大意：

两行数字，仅为 $0$ 和 $1$。

每次消除和一个点四面连通的块，下面没有数字的话就把上面的数字下落，问最少要多少次才能消除所有数字。

#### 思路：


比如

```
0 1 0 1 0 1 0 1 0 1  
1 0 1 0 1 0 1 0 1 0
```

先花 $10$ 次清空所有的 $0$，再用 $1$ 次把 $1$ 消除。  
共 $11$ 次。

因为只有两行，所以先把一类消除之后在消除另一类一定可一的到最优解。  
因为如果下面消除后上面等于下面，会把上面消除；  
消除一类后另一类不相连，则原来另一类也一定不相连。

#### 实现：

用搜索的到一类的连通块，把一类删除，删掉后用 $-1$ 表示。如果下面有 $-1$ 把下面和上面交换。

#### 代码：
```cpp
#include<iostream>
using namespace std;
int a[4][5000005];
void dfs(int x,int y)//使用 DFS 搜索
{
	int c=a[x][y];//记录原值
	a[x][y]=-1;//销掉
	if(c==a[x+1][y])dfs(x+1,y);//上下左右是否可连通
	if(c==a[x][y+1])dfs(x,y+1);
	if(c==a[x-1][y])dfs(x-1,y);
	if(c==a[x][y-1])dfs(x,y-1);
	if(x==2)swap(a[2][y],a[1][y]);//下面有空位，如果空位和空位交换也不会错
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);//如果不加，最后一个 subtask 会 T 
    		//(https://www.luogu.com.cn/record/138125746)
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[1][i];
		a[0][i]=-1;//把边界设为 -1 可以在搜索时不判断边界
	}
	for(int i=1;i<=n;i++)
	{
		cin>>a[2][i];
		a[3][i]=-1;
	}
	a[1][0]=-1;
	a[2][0]=-1;
	a[1][n+1]=-1;
	a[2][n+1]=-1;
	int num=0;//最少次数
	for(int i=1;i<=n;i++)
	{
		if(a[1][i]==0)//还有在上方没有销掉的0
		{
			dfs(1,i);
			num++;//块数加1
		}
		if(a[2][i]==0)
		{
			dfs(2,i);
			num++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(a[1][i]==1)//还有在上方没有销掉的1
		{
			dfs(1,i);
			num++;
		}
		if(a[2][i]==1)
		{
			dfs(2,i);
			num++;
		}
	}
	cout<<num<<'\n';
	return 0;
}
```
赛时记录：[AC](https://www.luogu.com.cn/record/138034707)。


---

## 作者：huangzhixia (赞：2)

**[题目传送门](https://www.luogu.com.cn/problem/P9899)**

## 题意

可以自己先看看，有点像消消乐。

有两行数，每行有 $n$ 个数，要么是 $0$，要么是 $1$。现在我们可以选择一个点，把它四面连通的点给消掉。如果消掉后有的点下面是空的，也就是 $0$，我们就让上面的点掉到下面来。

## 思路

这里我用的是~~无脑~~简单的方法**递推**。

先设置好最初的样子，设 $f_1$ 为 $a_{i,1} = a_{i,2}$ 再加 $1$，为什么呢？我们用的 $f$ 数组，比如说 $f_i$ 指的就是前 $i$ 个数它需要用多少代价才能消光。那 $f_1$ 就肯定是 $(a_{i,1} = a_{i,2})+1$ 了。

根据题意，我们有 $a_{i,1}$ 表示第一行第 $i$ 列，$a_{i,2}$ 表示第二行第 $i$ 列。

递推的核心思想就是**如何通过前面问题的解求出后面问题的解**。

这是我们就要分几种情况讨论了，如下：

- 当 $a_{i,1} \ne a_{i-1,1}$ 并且 $a_{i,2} \ne a_{i-1,2}$ 时，$f_i = f_{i-1} -1$。

- 当 $a_{i,1} \ne a_{i,2}$ 或者 $a_{i,1} \ne a_{i,2}$ 并且 $a_{i,1} \ne a_{i-1,1}$时，也是 $f_i = f_{i-1} -1$。

- 当 $a_{i,1} = a_{i,2} = a_{i-1,1}$ 时，$f_i=f_{i-1}$。

- 当 $a_{i,1} = a_{i,2} = a_{i-1,2}$ 时，$f_i=f_{i-1}$。

- 当 $a_{i,1} = a_{i-1,1}$ 并且 $a_{i,2} = a_{i-1,2}$ 时，$f_i = f_{i-1}$。

## Code:

```cpp
#include <bits/stdc++.h>
#define hh; puts("");
using namespace std;

int n, a[10000001], b[10000001], f = 1;

int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++)
		scanf("%d", &b[i]);
	if (a[1] != b[1]) f += 1;
	for (int i = 2; i <= n; i++){
		if ((a[i] != a[i - 1] && b[i] != b[i - 1]) ||
		((a[i] != a[i - 1] || b[i] != b[i - 1]) && a[i] != b[i]))
			f += 1;
		//其他的情况是直接赋值上一个f，就不用写。 
	}
	printf("%d\n", f);
	hh;
} 
```


---

## 作者：Tjaweiof (赞：1)

# P9899 题解
[题目传送门](https://www.luogu.com.cn/problem/P9899)

思路：贪心，先把所有 `0` 消完，再把 `1` 消掉。定义两个数组，一个存这一列的 `0` 与前面的是否连通，另一个存这一列是否有 `1`。如果这一列的 `0` 宇前面的连通，则可以一起消掉。消除 `1` 的时候，因为 `1` 都会掉落，所以如果连续几列都有 `1`，那么可以一起消除。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[5000001], b[5000001], ans;
bool x[5000001], lian[5000001];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> a[i];
		if (!a[i] && i != 1){
			if (!a[i - 1]){
				lian[i] = true;
			}
		}
		if (a[i]){
			x[i] = true;
		}
	}
	for (int i = 1; i <= n; i++){
		cin >> b[i];
		if (!b[i] && i != 1){
			if (!b[i - 1]){
				lian[i] = true;
			}
		}
		if (b[i]){
			x[i] = true;
		}
	}
	if (!a[1] || !b[1]){
		ans++;
	}
	if (x[1]){
		ans++;
	}
	for (int i = 2; i <= n; i++){
		if (!lian[i] && (!a[i] || !b[i])){
			ans++;
		}
		if (x[i] && !x[i - 1]){
			ans++;
		}
	}
	cout << ans;
	return 0;
}

```

---

## 作者：Kevin911 (赞：1)

## 思路
根据贪心的思路，可以想到先消一种再消第二种时可以出现更多的“连消”。

所以假设先消完第二层所有的一，再消完第一层剩下的一，最后消掉所有的二。

根据思路，就可以很轻松的打出来了，而消的过程一般是用 bfs 实现的（假设消完
的位置都是二），模拟下落时只需要把第二层翻上第一层即可。

具体细节详见代码。

```cpp
#pragma GCC ("Ofast")
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
const int maxn=5e6+10;
int n,ans;
int a[maxn][3],p;
int fx[]={0,1,0,-1};
int fy[]={1,0,-1,0};
queue<pii> q;
void bfs(int sx,int sy)
{
	a[sx][sy]=2;
	q.push({sx,sy});
	while(!q.empty())
	{
		int x=q.front().first,y=q.front().second;
		q.pop();
		for(int i=0;i<4;i++)
		{
			int xx=x+fx[i],yy=y+fy[i];
			if(!(xx>0&&xx<=n&&yy>=1&&yy<=2&&a[xx][yy]==p)) continue;
			a[xx][yy]=2;
			q.push({xx,yy});
		}
	}
}
signed main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i][1]);
	for(int i=1;i<=n;i++) scanf("%d",&a[i][2]);
	for(int i=1;i<=n;i++)
		if(a[i][2]==1)
		{
			p=1;
			bfs(i,2);
			ans++;
		}
	for(int i=1;i<=n;i++)
		if(a[i][2]==2) swap(a[i][1],a[i][2]);
	for(int i=1;i<=n;i++)
		if(a[i][1]==1)
		{
			p=1;
			bfs(i,1);
			ans++;
		}
	for(int i=1;i<=n;i++)
		if(a[i][2]==0)
		{
			p=0;
			bfs(i,2);
			ans++;
		}
	printf("%d",ans);
}
```


---

## 作者：gaomingyang101011 (赞：0)

### 题目大意：

就和消星星一样，只不过下来的萝卜不会向左移动，颜色也只有两种。求最少几步能将全部的消除干净。

### 思路：

因为是贪心，所以我们首先就可以想到将其中一种颜色先消除干净，然后消除另一种颜色，事实上这就是最简便的方法。我们可以先搜索一遍，用深搜将第一种颜色全部消除并标记，然后再将第二种颜色消除，最后输出就好啦。

### 代码：

```cpp
#include<iostream> 
using namespace std;
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
const int N=1e7*6;
int n,a[4][N];
int ans;
bool vis[4][N];
void dfs(int x,int y,int s){
	vis[x][y]=1;
	for(int i=0;i<4;i++)
		if(a[x+dx[i]][y+dy[i]]==s&&vis[x+dx[i]][y+dy[i]]==0){
			vis[x+dx[i]][y+dy[i]]=1;
			dfs(x+dx[i],y+dy[i],s);
		}
}
// 将一个颜色所联通的相同颜色都消除 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d",&a[1][i]),a[1][i]++;
	for(int i=1;i<=n;i++) scanf("%d",&a[2][i]),a[2][i]++;
	// 这里必须要用 scanf，不然会超时
	for(int i=1;i<=n;i++){
		if(a[1][i]==1&&vis[1][i]==0)
			dfs(1,i,a[1][i]),ans++;
		else if(a[2][i]==1&&vis[2][i]==0)
			dfs(2,i,a[2][i]),ans++;
		if(vis[2][i]==1) swap(a[2][i],a[1][i]),swap(vis[2][i],vis[1][i]);
	}
	// 将第一种颜色都消除，第二种颜色落下来 
	for(int i=1;i<=n;i++){
		if(vis[1][i]==0)
			dfs(1,i,a[1][i]),ans++;
		else if(vis[2][i]==0)
			dfs(2,i,a[2][i]),ans++;
	}
	// 消除第二种颜色 
	cout<<ans;
	return 0;
}
```

---

## 作者：LionBlaze (赞：0)

这题看大家都用搜索，其实可以用递推。

### 表示

$f_i$ 表示消除掉前 $i$ 列需要的最小代价。

$a_i$ 表示第一行第 $i$ 列的数字，$b_i$ 表示第二行第 $i$ 列的数字。

### $f_i$ 与什么有直接关系

首先，$f_i$ 肯定和 $a_i, b_i$ 和 $f_{i-1}$ 有关，并且还和 $a_{i-1}, b_{i-1}$ 有关，因为要看是否相连。

是不是还和其他的有关呢？没有。当 $a_{i-1}$ 或 $b_{i-1}$ 和 $i-2$ 列的数字相连，那么可以看成一个整体，$i-2$ 列相当于没有。如果不相连，则没有联系。

综上，$f_i$ 和且只和 $a_i, b_i, a_{i-1}, b_{i-1}, f_{i-1}$ 有关。

### $f_1$

很明显，当 $a_1=b_1$ 时，$f_1=1$，否则，$f_1 = 1$。

### $f_i , i \ne 1$

首先，如果第一行都相同，第二行也都相同，那么 $f_i = f_{i-1}$，消除 $i-1$ 列的时候顺便消了 $i$ 列。

然后，如果有一行都相同，另一行不相同，也就是三个数字相同，一个不相同，那么也分两种情况：

第一种，不相同的数字在第 $i$ 列，$f_i = f_{i-1}+1$，需要多消除一个数。

第二种：不相同的数字在第 $i-1$ 列，$f_i = f_{i-1}$，消除第 $i-1$ 列的时候已经消完了。

最后，两行都不相同，也有两种情况：

第一种，两列一样。很明显，需要 $+1$。

第二种，两列也都不一样，这个没那么好推，可以举个例子：

$$ \begin{matrix}
1 & 0 \\
0 & 1
\end{matrix} $$

其实如果把 $0, 1$ 互换，那么这两种情况就是两行，两列都不相同的所有情况。

消除方法：先消除右下角，再消除左下角，最后消除所有的 $0$，三步。

如果只有第 $i-1$ 列：很明显，两步。多了一步，所以要 $+1$。

### 综上，$f_i$
| 条件 | 值 |
| :-----------: | :-----------: |
| $a_{i-1} = a_i$ 且 $b_{i-1} = b_i$ | $f_i = f_{i-1}$ |
| $a_{i-1} \ne a_i$ 且 $b_{i-1} \ne b_i$ 且 $a_i \ne b_i$ | $f_i = f_{i-1}+1$ |
| $a_{i-1} \ne a_i$ 且 $b_{i-1} \ne b_i$ 且 $a_i = b_i$ | $f_i = f_{i-1}$ |
| $(a_{i-1} \ne a_i$ 或 $b_{i-1} = b_i)$ 且 $a_i \ne b_i$ | $f_i = f_{i-1}+1$ |
| $(a_{i-1} \ne a_i$ 或 $b_{i-1} = b_i)$ 且 $a_{i-1} \ne b_{i-1}$ | $f_i = f_{i-1}$ |

### 大家喜闻乐见的代码

```cpp
#include <cstdio>

using namespace std;

int f[5000005], one[50000005], two[50000005];

int main()
{
    int n;
    //scanf("%d", &n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d", one + i);
    }
    one[0] = two[0] = -1;
    for(int i=1;i<=n;i++)
    {
        scanf("%d", two + i);
        if(i == 1) f[i] = 1+(one[i] != two[i]);
        else f[i] = f[i-1]+
        	(one[i-1] != one[i] && two[i-1] != two[i] || 
           one[i-1] == two[i-1] && one[i] != two[i]); //bool->int
    }
    printf("%d\n", f[n]);
    return 0;
}
```

---

## 作者：ZBH_123 (赞：0)

## 题目分析
通过读题可以发现，当第一行的萝卜不被消除时，它们的位置不会改变。因此，我们可以选定一种萝卜的颜色，先把第一行的这种颜色的萝卜全部消除，再使第二行对应位置的萝卜掉落下来，这样就可以使另外一种颜色原本不连通的区域变为连通。接着再将第二行残余的选定颜色的萝卜消除，最后就消除非选定颜色的萝卜。
**AC code：**
```cpp
#include<iostream>
#include<cstdio> 
#include<queue>
using namespace std;
const int maxn=5e6;
int n,a[5][maxn+5],ans,l[4]={0,1,0,-1},r[4]={1,0,-1,0};
struct node{
	int x,y;
};
queue<node>q;
void bfs(int sx,int sy,int p){
	q.push((node){sx,sy});
	a[sx][sy]=2;
	while(!q.empty()){
		node tmp=q.front();
		int x=tmp.x,y=tmp.y;
		q.pop();
		for(int i=0;i<4;i++){
			int xx=x+l[i],yy=y+r[i];
			if(xx<1||yy<1||xx>2||yy>n||a[xx][yy]!=p){
				continue;
			}
			a[xx][yy]=2;
			q.push((node){xx,yy});
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=2;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		if(a[2][i]==1){
			bfs(2,i,1);
			ans++;
		}
	}
	for(int i=1;i<=n;i++){
		if(a[2][i]==2){
			a[2][i]=a[1][i];
		}
	}
	for(int i=1;i<=n;i++){
		if(a[1][i]==1){
			bfs(1,i,1);
			ans++;
		}
	}
	for(int i=1;i<=n;i++){
		if(a[2][i]==0){
			bfs(2,i,0);
			ans++;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：mango2011 (赞：0)

其实这题不会深搜广搜宽搜爆搜等各种“搜”的选手也可以通过呢！~~比如说我。~~

令 $dp[i]$ 表示到第 $i$ 列所需要的最少步骤。答案明显是 $dp[n]$。$dp[1]$ 很简单，如果第一列两萝卜是同一种，那么就是 $1$，否则为 $2$。到了每一步，我们可以先令 $dp[i]=dp[i-1]$，接下来考虑什么情况下 $dp[i]$ 要 $+1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ydw8c7vg.png)

看似玄学，实则科学。上述过程一点都不难，只是要细心和一点点运气啦。为了防止抄袭，写一份好笑的示意代码（连伪代码都不算）

```cpp
头文件
使用标准命名空间
定义一个宏=5e6+10
快读
{
    
}
定义 dp数组[maxn]
定义 存萝卜数组[maxn][3]
主函数生命
{
    定义 萝卜总列数和循环变量
    输入 萝卜总列数
    循环 循环变量1 1~萝卜总列数
    {
        循环 循环变量2 1~2
        {
            输入 存萝卜数组[循环变量1][循环变量2]
        }
    }
    特判 dp数组[1]
    循环 循环变量1 2~萝卜总列数
    {
        判一堆
        {
            dp数组[循环变量1]++
        }
    }
    输出 dp数组[萝卜总列数]
    华丽结尾
}
```


---

## 作者：sbno333 (赞：0)

这是一道递推的题，或者说可以用类似方法去想。

这种~~一看就不会做的题~~都可以累死这么想。

我们设 $f_i$ 表示前 $i$ 列的最优解。

显然，$f_1=[a_{i,1}=a_{i,2}]+1$。

接着思考转移。

对于 $a_{i,1}=a_{i,2}=a_{i-1,1}$ 或者 $a_{i,1}=a_{i,2}=a_{i-1,2}$ 或者 $a_{i,1}=a_{i-1,1},a_{i,2}=a_{i-1,2}$ 的情况，显然，此时 $f_i=f_{i-1}$。

对于 $a_{i,1}\not=a_{i-1,1},a_{i,2}\not=a_{i-1,2}$，此时 $f_i=f_{i-1}+1$。

对于 $a_{i,1}\not=a_{i,2},a_{i,2}\not=a_{i-1,2}$ 或者 $a_{i,1}\not=a_{i,2},a_{i,1}\not=a_{i-1,1}$ 此时仍然 $f_i=f_{i-1}+1$。

由于定义 $f$ 会提高代码复杂度，因此，可以用一个变量时刻存储 $f_i$ 的值，对于 $f_i=f_{i-1}$，变量自增 $1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[10000009];
bool b[10000009];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	int ans;
	ans=1;
	if(a[1]!=b[1]){
		ans++;
	}
	for(int i=2;i<=n;i++){
		if((a[i]!=a[i-1]&&b[i]!=b[i-1])||((a[i]!=a[i-1]||b[i]!=b[i-1])&&a[i]!=b[i])){
			ans++;
		}
	}
	cout<<ans;
	return 0;
} 
```

---


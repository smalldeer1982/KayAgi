# 『PG2』消除萝卜 B

## 题目描述

有 $n\times 2$ 的两列萝卜，萝卜分白萝卜和红萝卜，我们使用 $a_{i,j}=0/1$ 来表示第 $i$ 行第 $j$ 个萝卜是白萝卜还是红萝卜。

你每次可以花 $1$ 的代价，选定一个有萝卜的位置，并将这个萝卜所在的由同种颜色萝卜所构成的四连通极大连通块的萝卜全部拿走，然后一个在第 $i$ 行的萝卜如果其对应的第 $i-1$ 行的位置没有萝卜，就会掉落至第 $i-1$ 行。

同时你也可以花初始为 $0$ 的代价，选定 $k=1/2$ 而将第 $k$ 列的所有萝卜上移（$a_{i,k}\to a_{i+1,k}$），并将一个红萝卜即 $1$ 放在第一行第 $k$ 个（$1\to a_{1,k}$），此后这个操作代价 $+1$。 

请问拿走所有萝卜的最小代价是多少。

## 说明/提示

对于所有测试点 $a_{i,j}\in \{0,1\}$，$1\leq n\leq 5\times 10^6$，保证 $a_{i,1}\neq a_{i,2}$。

**本题使用捆绑测试**  
$\sf subtask \ 1: n\leq10 \ \ \ \ \ \ \ \ \ \ \ 30pts $   
$\sf subtask \ 2: n\leq100 \ \ \ \ \ \ \ \ \ 20 pts$   
$\sf subtask \ 3: n\leq5000 \ \ \ \ \ \ \ 20 pts$   
$\sf subtask \ 4: n\leq5000000 \ 30pts$   



## 样例 #1

### 输入

```
4
0 1
0 1
0 1
0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6
1 0
1 0
0 1
0 1
1 0
1 0```

### 输出

```
3```

# 题解

## 作者：GONGX (赞：5)

# 题意简述
有 $n\times2$ 的两列萝卜，且分为白萝卜和红萝卜。你每次可以进行以下两种操作：
1. 花 $1$ 的代价，选一个有萝卜的位置，将这个萝卜所在的由同种颜色萝卜构成的四连通极大连通块的萝卜全部拿走。若在第 $i-1$ 行有一个没有萝卜的空位，则第 $i$ 行的萝卜就会掉落至第 $i-1$ 行。
2. 同时你也可以花初始为 $0$ 的代价，选定 $k$ 而将第 $k$ 列的所有萝卜上移，并将一个红萝卜即 $1$ 放在第一行第 $k$ 个，此后这个操作代价 $+1$。

求拿走所有萝卜的最小代价。
# 解题思路
题目中有一个重要的提示，即保证 $a_{i,1}\ne a_{i,2}$，那么操作次数通过一列即可判断。首先任选一列 $k$ 统计 $a_{i,k}\ne a_{i-1,k}$ 的数量，记为 $t$，令 $a_{1,k}\ne a_{0,k}$。然后很容易即可推出 $answer=\lceil\frac{t}{2}\rceil+1$，时间复杂度为 $O(n)$。
# 友情提示
1. 由于本题数据较强，对于 c++ 语言，以 $O(n)$ 的时间复杂度纯用 ```cin``` 输入都难以通过，所以可以尝试使用快读输入。
快读模板如下：
```cpp
int read(){
	int ret=0;bool sgn=false;int ch=getchar();
	while(!isdigit(ch))sgn|=ch=='-',ch=getchar();//isdigit()为判断字符是否为数字的函数
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return sgn?-ret:ret;//三目运算符
}
```
2. 使用 ```inline``` 可以将函数定义为内联函数，有效地优化函数，感兴趣的读者可以自行上网查阅
# 代码展示
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){//定义为内联函数
	bool k=0;char c=getchar();//由于k只有一位，所以用bool类型存即可 
	while(!isdigit(c))c=getchar();//k不可能为负数 
	while(isdigit(c))k=c^'0',c=getchar();//k不可能进位(c^'0'等同于c-'0')
	return k;
}int n,ans=1;
bool a[5000005];//只需任存一列即可 
int main(){
	scanf("%d",&n),a[0]=read(),read();//第二个read()用来过滤第二列数据
	for(int i=1;i<n;i++)a[i]=read(),read(),ans+=a[i]!=a[i-1];//若a[i]!=a[i-1],则ans++ 
	printf("%d",1+(ans+1>>1));//输出答案(同printf("%d",1+(int)ceil(1.0*ans/2));)
return 0;
}
```

---

## 作者：abc1234shi (赞：3)

有 $2$ 列萝卜，我们只需要管其中一列就好了。我们要判断第 $i$ 项和它前面那一项是否相等，用数组变量都行，如果用的是变量记得更新数据。如果不相等就加 $1$；最后输出 $(cnt + 1) \div 2 + 1$ 就行了。
           
    #include<bits/stdc++.h>
    using namespace std;
    int n,b,c,e,f,cnt;
    int main()
    {
        cin>>n;
        e=2;
        for(int i=1;i<=n;i++)
	     {
          scanf("%d%d",&b,&c);//注意输入用scanf不然会超时。
          if(b!=e) cnt++;
          e=b;
         }
	     cout<<(cnt+1)/2+1;
     }

---

## 作者：Mo20 (赞：3)

验题人题解，对于题面样例出锅感到抱歉，虽然验的时候题面数据是另一组（

诈骗题，注意到关键信息 $a_{i,1} \neq a_{i,2}$，容易想到将所有连续的相同萝卜组成合并，即
```
01
01
10
10
01
01
```
可以合并为
```
01
10
01
```
这样操作过后答案只和 $n$ 有关。考虑一下题目中将某一列上推的操作本质是什么，每次代价 `+1`，乍一看好像是限制操作次数最多不超过 $\sqrt{n}$ 次，但实际上也是诈骗的一部分！这个操作的实质是将两个上下相接的四连通块错位，使得其相连。

形象化来说
```
01
10
01
```
变为
```
11
00
11
0
```
后，原本错开的 `0` 和 `1` 被并为 `1` 组，这放在原图上是这样的。

```
11
01
00
10
11
01
0
```
合并的功能体现在 `01` 与 `10` 交接处形成的三角形连通块。

那么对于这个操作的次数，首先他肯定只会作用于两列中的一列，其次两次操作并不能保证联通更多连通块，这多出的贡献也不如直接进行消除。因为都是 `01 10` 没有构造能使得错位两次能联通的块错位一次会更劣。

那么如何统计答案？错位后只需对一种颜色单独消除，最后另一种颜色全部下落消除，答案为 $\frac{(n+1)}{2}+1$。

```cpp
#include<bits/stdc++.h>
inline int read()
{
     int x=0;int f=1;char c=getchar();
     for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
     for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
     return ~f?x:-x;
}
using namespace std;
int main()
{
	int n;
	cin>>n;int ans=n;int last=-1;
	for(int i=1,x;i<=n;i++)
	{
		x=read();x=read();
		if(~last) ans-=(last==x);
		last=x;
	}
	cout<<((ans+1)>>1)+1<<endl;
	return 0;
}
```

---

## 作者：2023gdgz01 (赞：2)

由于题目保证同一行的萝卜不同色，所以只需考虑任意一列的萝卜即可。上移操作代价是上升的，而且消萝卜比加萝卜更优，所以我们考虑只用一次上移操作。可构造出：先在第一列进行上移操作，然后依次消除即可。令第一列的连通块数量为 $x$，则最后答案为 $\lceil\frac{x
+1}{2}\rceil+1$。

代码如下：

```cpp
#include <cstdio>

int n, ans, a[5000005][2];

int main() {
	scanf("%d", &n);
	a[0][0] = 2;
	for (register int i = 1; i <= n; ++i) {
		scanf("%d%d", &a[i][0], &a[i][1]);
		ans += (a[i][0] != a[i - 1][0]);
	}
	printf("%d", (ans + 1 >> 1) + 1);
	return 0;
}
```

时间复杂度为 $O(n)$。[AC 链接](https://www.luogu.com.cn/record/173900738)

---

## 作者：abc1856896 (赞：1)

~~感觉像玩宾果消消乐？~~

# 题目大意

有 $n\times 2$ 的两列萝卜，萝卜分白萝卜和红萝卜，我们使用 $a_{i,j}=0/1$ 来表示第 $i$ 行第 $j$ 个萝卜是白萝卜还是红萝卜。

有两种操作

1. 每次可以花 $1$ 的代价，选定一个有萝卜的位置，并将这个萝卜所在的由同种颜色萝卜所构成的四连通极大连通块的萝卜全部拿走，然后一个在第 $i$ 行的萝卜如果其对应的第 $i-1$ 行的位置没有萝卜，就会掉落至第 $i-1$ 行。

2. 你也可以花初始为 $0$ 的代价，选 $k=1/2$ 而将第 $k$ 列的所有萝卜上移，并将一个红萝卜即 $1$ 放在第一行第 $k$ 个（$1\to a_{1,k}$），此后这个操作代价 $+1$。 

求拿走所有萝卜的最小代价。

# 思路

## 法一：暴搜

每一次可以直接选择在左边加红萝卜、消一块和在右边加红萝卜。

时间复杂度 $O(3^n)$

## 法二：优化一点

可以推断出先把整一种颜色全部消完不可能是假的。

为减少我们消完整一种颜色的代价，我们可以在最下面提前放好萝卜。所以我们暴力枚举放多少个即可。 

时间复杂度 $O(n^3)$

## 法三：优化亿点

我们可以在最下面左边放一个红萝卜或右边放一个红萝卜，接着将中间的萝卜直接依次消除就可以了。

我们设 $x$ 为左边萝卜连通块个数，$ans$ 就是 $\frac{1}{2}(x+1)+1$

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n , a[5000005] [5],ans;
void solve(){
    for(int i = 1 ; i <= n ; i++){
        if(a[i][1] != a[i-1][1]) ans++;
    }
	printf("%d", ( ans + 1 ) / 2 + 1);
}
int main(){
    scanf("%d", & n);
    a[0] [1] = 2;
    for(int i = 1 ; i <= n ; i++){
        scanf("%d%d",& a[i] [1],& a[i] [2]);
    }
    solve();
    return 0;
}
```


---

## 作者：封禁用户 (赞：1)

大家好，这是本蒟蒻发的第一篇题解。

[题目传送阵](https://www.luogu.com.cn/problem/P9900)

思路

在最下面左边放一个红萝卜或右边放一个红萝卜，接着将中间的萝卜直接依次消除就可以了。

只需对一种颜色单独消除，最后另一种颜色全部下落消除，所以若联通块有 $x$ 个，则答案为 $\lceil(x+1)\div2\rceil+1$。

code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5000010],ans;
int main(){
    cin>>n;
    memset(a,-1,sizeof(a));
    for(int i=1;i<=n;i++)cin>>a[i]>>a[i];
	for(int i=1;i<=n;i++)
        if(a[i]!=a[i-1])
		    ans++;
	cout<<(ans+1)/2+1;
    return 0;
}
```
如果此题解对你有帮助，那就点个赞再走吧。

---

## 作者：rc_Taurus (赞：1)

大家好，我是 rc_Wechis。

[题目传送门](https://www.luogu.com.cn/problem/P9900)

# solution

## 思考

眨眼一看此题如此困难，但是只要冷静下来仔细分析，还是可以找到一些线索的。

（1）若一个萝贝下面没有萝贝，它会一掉到底。

（2）可以上移萝贝，但是这个方法代价太大，我们尽量不用。

（3）可以添加萝贝，但是必须得上移。

我们发现如果出现以下情况：

|0|1|
|:-:|:-:|
|0|1|
|1|0|


那么无论我们拿掉底层的哪个萝贝，我们都不能在第一时间使用联通块消除大量萝贝。但是，只要我们在它的右下角放一个 $0$ （大家可以自己画一下图）就可以就可以一次性消掉许多。

而且由于题目十分良心，每一行只有两列，而且元素互不相同，也就是说只要你在最底下放一个萝贝就一定会有元素个数 $≥2$ 的联通块。

记初始数据的联通块个数为 `res`，加上放的一个萝贝，加上 $1$ 个代价可以消 $2$ 个，即 $\div 2$，最后加上放萝贝的代价 $1$,得出结果 $\frac{(res+1)}{2}+1$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6+5;
int res,n,a[N];
int main(){
	cin>>n;
	memset(a,-1,sizeof a);
	for(int i=1;i<=n;i++)cin>>a[i]>>a[i];
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1])res++;
	}
	cout<<((res+1)>>1)+1<<endl;
	return 0;
}
```

---

好了，这次就先到这里。

---

## 作者：Very_Smart_Honet (赞：1)

## 思路

我们很容易能发现，如果不去加红胡萝卜，那么就无法用最少的步数去消除。

所以我们要先在最下面加红胡萝卜，这样才能从在下面一点一点的很快消除，直到消完为止。

则易得式子为：$ans=(n+1)\div2+1$。

### 解释一下式子

- 总行数 $+1$ 加的是多加的一个红胡萝卜。

- $\div2$ 是因为一个代价可以消两个。

- 最后再加一个代价 $1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[5000005][5],ans;
int main()
{
    scanf("%d",&n);
    a[0][1]=2;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a[i][1],&a[i][2]);
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i][1]!=a[i-1][1]) ans++;
    }
	printf("%d",(ans+1)/2+1);
    return 0;
}
```

点个赞再走吧！

---

## 作者：wyc0607 (赞：0)

算法：数学结论推导题

不难发现，如果要尽可能快的消除萝卜，就必须要放红萝卜，然后一点点地消除，直到消完。

易推得 $$ans= \frac {(tp+1)}{2} + 1$$ 。

解释一下：$tp$ 即为两列中联通块个数。

上代码！


```cpp
#include<bits/stdc++.h>
#define IAKIOI ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//好习惯。 
using namespace std;
int n,b,tp=0;//tp 即为联通块个数，其他的看题。 
main(){
	IAKIOI
    cin>>n;
    int b,c,e=3;//b 为第一列目前的萝卜，c 为第二列目前的萝卜。 
    for(int i=1;i<=n;i++){
    	cin>>b>>c;
    	if(b!=e) tp++;//如果此时的萝卜种类不为上一个的种类，则联通块++。
    	e=b;
    }
     cout<<(tp+1)/2+1;//根据公式。
 }
```

---

## 作者：王逸辰 (赞：0)

# P9900 『PG2』消除萝卜 B 题解
## 思路
首先，题目中有两个很重要的点。
- 只有两列。
- 每一行中的两个元素各不相同。

有了这两个条件，这道题就很好解了。

当然，题目中除了消还给出了一个方法，但它的代价是上升的。

所以，不难发现，只用一次方法二是最优的（因为在代价相同的情况下，消元素比加元素更优）。

因为每一行中的两个元素各不相同，所以我们只需看一边即可。

具体看代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[5000005][3],n,ans,k;
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    a[0][1]=2;
    for(int i=1;i<=n;i++){
        cin>>a[i][1]>>a[i][2];
        if(a[i][1]!=a[i-1][1])
            ans++;
    }
    cout<<(ans+1)/2+1;
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

在最下面左边放一个红萝卜或右边放一个红萝卜，接着将中间的萝卜直接依次消除就可以了。

只需对一种颜色单独消除，最后另一种颜色全部下落消除，所以若联通块有 $x$ 个，则答案为 $\frac{x+1}{2}+1$。

代码在这：
```
#include<bits/stdc++.h>
using namespace std;
int n,a[5000010],ans;
int main(){
    cin>>n;
    memset(a,-1,sizeof(a));
    for(int i=1;i<=n;i++)cin>>a[i]>>a[i];
	for(int i=1;i<=n;i++)
        if(a[i]!=a[i-1])
		    ans++;
	cout<<(ans+1)/2+1;
    return 0;
}

```

---


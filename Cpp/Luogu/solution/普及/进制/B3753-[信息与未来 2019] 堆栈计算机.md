# [信息与未来 2019] 堆栈计算机

## 题目描述

有一种新型的堆栈计算机，计算机的内存是一个初始为空的数列，计算机支持三种操作：
- $\tt 1$ - 将整数 $1$ 放入数列的尾部。任意时刻都可执行此操作。
- $\tt dup$ - 将数列尾部的数字复制一份，放入数列尾部。只有数列非空时才能执行此操作。
- $\tt add$ - 取出（并删除）数列尾部的两个数字，相加后放回数列的尾部。只有数列中至少有两个数字时才能执行此操作。

给定一个正整数，你需要输出一个长度不超过 $200$ 的程序（操作的序列），它在执行结束后，恰好得到一个长度为 $1$ 的数列，并且数列中的数字恰好为 $n$。下图展示了一个最终得到 $8$ 的程序。

![](https://cdn.luogu.com.cn/upload/image_hosting/unim6xbj.png)



## 说明/提示

对于 $60\%$ 的测试数据，有 $1\le n\le10^4$。

对于 $100\%$ 的测试数据，有 $1\le n\le10^9$。
> 本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
8```

### 输出

```
1
1
add
dup
add
dup
add```

# 题解

## 作者：WsW_ (赞：13)

### 思路一   

我们需要使栈中所有元素之和为 $n$，再全部加起来即可。  
最简单的方法是直接往栈中放 $n$ 个 $1$，似乎一个点都过不了。  
为了使操作次数尽可能少，我们需要最大化单次的收益。收益指让栈中的元素之和增加了多少。  
* 操作 $\mathtt{1}$，收益为 $1$。
* 操作 $\mathtt{dup}$，收益为 $top$。
* 操作 $\mathtt{add}$，收益为 $0$。

第一次操作一定是操作 $\mathtt{1}$，因为此时栈中还没有数字。
如果之后我们重复依次执行操作 $\mathtt{dup}$ 和 $\mathtt{add}$，那么执行 $2x$ 次操作后，栈中的数字变成了 $2^x$。 

将 $n$ 拆成二进制，再按照上述方法制作二进制下 $n$ 的每一位的数字即可。  

能够获得 $60\%$ 的分数。

### 代码和[提交记录](https://www.luogu.com.cn/record/126264746)
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
int n;
bool f=1;
void make(int x){
	puts("1");
	while((x>>1)>0){
		x>>=1;
		puts("dup");
		puts("add");
	}
}

int main(){
	scanf("%d",&n);
	while(n){
		make(lowbit(n));
		if(f)f=0;
		else puts("add");
		n-=lowbit(n);
	}
	return 0;
}
```


---
### 思路二
先看一个例子。  

输入：
```
6
```
我们的代码会从 $1$ 开始制作 $2$，再从 $1$ 开始制作 $4$，最终加起来得到结果。  

如果我们将制作出的 $2$ 进行 $\mathtt{dup}$，再在复制的 $2$ 的基础上制作 $4$，那么就可以省去一部分步骤。  
这时我突然想到了[快速幂](https://www.luogu.com.cn/problem/P1226)的思想。我们一个变量记录栈顶元素，不停地对其进行 $\mathtt{dup}$ 和 $\mathtt{add}$，如果二进制的 $n$ 在这一位是 $1$，那就把它额外复制一遍留着，最终把所有保留的加起来即可。

### 代码和[提交记录](https://www.luogu.com.cn/record/126266317)
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
int n;
int x=1;
int cnt=-1;
bool f=1;

int main(){
	scanf("%d",&n);
	puts("1");
	while(x<n){
		cnt+=bool(x&n);//记录一下最终要加几个数
		if(x&n)puts("dup");//赋值保存下来
		n-=n&x;//将这一位变为0
		x<<=1;
		if(x<=n)puts("dup\nadd");//继续增长
	}
	while((cnt--)>=0)puts("add");
	return 0;
}
```

---

## 作者：xiaoshumiao (赞：3)

其实没有 WsW 大佬所说的那么复杂。

看到这道题的设置，我们不难想到递归处理。定义函数 `solve(n)` 为输出一个输出 $n$ 的程序的函数。

- 当 $n=1$ 时，直接输出 $1$。

- 否则，先 `solve(n>>1)` 一下，使得栈内有一个 $\lfloor{\dfrac{n}{2}}\rfloor$，然后 `dup` 一下 `add` 一下，栈内就有一个 $2 \times \lfloor{\dfrac{n}{2}}\rfloor$ 了。如果 $n$ 是奇数需要加一个 $1$ 随后再 `add` 一下，就能得到 $n$ 了。

因为最多递归调用 $\log n$ 即 $29$ 层，极端情况下需要输出约 $4 \times 29 =116$ 行，题目的限制绰绰有余。（实测当 $n=2^{29}-1$时会输出 $113$ 行。）

实现起来很简单。
```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(int n) {
    if(n==1) return cout<<"1\n",void();
    else solve(n>>1),cout<<"dup\nadd\n";
    if(n&1) cout<<"1\nadd\n";
}
int main() {
    ios::sync_with_stdio(false),cin.tie(nullptr);
    int n; cin>>n,solve(n);
    return 0;
}
```

---


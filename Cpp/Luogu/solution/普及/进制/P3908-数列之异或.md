# 数列之异或

## 题目描述

求$1 \bigoplus 2 \bigoplus\cdots\bigoplus N$ 的值。

$A \bigoplus B$ 即$A$ , $B$ 按位异或。


## 说明/提示

• 对于50% 的数据，$1 \le N \le 10^6$；

• 对于100% 的数据，$1 \le N \le 10^{18}$。


## 样例 #1

### 输入

```
3```

### 输出

```
0```

# 题解

## 作者：Treeloveswater (赞：66)

乱逛的时候看到了这题  
随手推了一下，就A了。  
为啥要结论？我来说一种非常严谨的做法。
并且是O(1)的。  
题目要求 1^2^...^n，我们强制使得n为奇数 ，就是说如果n是偶数，我们就让n=n+1,然后让答案最后再异或n即可。  
我们现在考虑一个奇数A，它的二进制形式是：ABCD1  
A-1一定是偶数，其形式一定是 ABCD0  
也就是说 A^(A-1)=000001
所以我们发现，除了最右边那一位，其他位都是0！  
也就是说，我们现在只需要统计有多少个奇数即可！
那么就很简单了。代码如下。  
  
  ```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
int main(){
	ll ans=0;
	scanf("%lld",&n);
	if(!(n&1)) n++,ans=n;
	ll num=(n+1ll)/2ll;
	if(num&1) ans^=1;
	cout<<ans;
}
```



---

## 作者：封禁用户 (赞：21)

码了半个小时数位dp后还在疑惑这题为啥才是个黄牌……看了楼下的题解顿时想跳楼……居然还能$O(1)$……

好了我就来个数位dp做法吧，就是我们用数位dp搞出1~n中每位的1的个数，为奇数则答案的那一位赋1（因为异或了偶数次1相当于啥都没干），这是数位dp的经典套路，就是设$dp[i][j]$为$0……2^i-1$的数，有多少个在j位上有1，转移分情况：①如果j比最高位还高，那就直接为0，②如果j为最高位，那就说明这些数里后一半都有j位是1，直接是$2^j$，③否则就把i去掉最高位，拆成两个i-1位的部分，因为最高位和j并不相关，所以这两个部分答案相同，直接为$dp[i-1][j]×2$。把这个dp数组搞出来后，我们对n进行按位递归处理，先取n的最高位，不妨设为k，那就直接从dp中找0~$2^k-1$的答案，然后递归到最高位以下的部分。还要注意递归的边界问题（这个不太好倒清楚）。复杂度$O(log^2n)$。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define p 1000003
#define int long long
using namespace std;
int f[64][64];
int ywy=1;
int hsh[1000005];
unsigned char bv[64][64];
int dp(int len,int bit){//记搜实现的数位dp
	if(len==0)return(0);
	if(bv[len][bit])return(f[len][bit]);
	bv[len][bit]=1;
	if((ywy<<len)<=(ywy<<bit))return(f[len][bit]=0);
	if((ywy<<len)==(ywy<<(bit+1)))return(f[len][bit]=(ywy<<bit));
	return(f[len][bit]=dp(len-1,bit)<<1);
}
int getnum(int num,int bit){//递归n的每一位
	if(num==0)return(0);
	if(num<(ywy<<bit))return(0);
	if(num>=(ywy<<bit)&&num<(ywy<<(bit+1)))return(num-(ywy<<bit)+1);
	int tmp=num;
	while(tmp!=(tmp&-tmp))tmp-=(tmp&-tmp);
	int bitof=hsh[tmp%p];
	//printf("dp(%d,%d)=%d\n",bitof-1,bit,dp(bitof-1,bit));
	return(dp(bitof,bit)+getnum(num-tmp,bit));
}
signed main(){
	int n;cin>>n;int ans=0;
	for(register int i=0;i<=62;i++){
		hsh[(ywy<<i)%p]=i;//这里用了个小技巧，为了快速取到最高位对应的位数，我直接用哈希记录
	}
	for(register int i=0;i<=62;i++){
		int cjr=getnum(n,i);
		if(cjr&1)ans+=(ywy<<i);//为奇数就把这位加入答案
	}cout<<ans<<endl;
	return(0);
}
```

---

## 作者：说好不哭 (赞：13)

# 题解 P3908 【数列之异或】
## 先讲一下打表法：
### 看到这个题目和范围，我们就会想到绝对有log级别的数位dp做法，可能有O（1）级别的数论做法。太菜了，不会数位dp，所以就开始乱搞。依次算出n=1-20的答案后就成功找到了规律。
### 规律太脑残不想说，直接贴代码吧。

```cpp

if (n%4==0) printf("%lld",n);
if (n%4==3) printf("%lld",0ll);
if (n%4==1) printf("%lld",1ll);
if (n%4==2) printf("%lld",n+1ll);

```
## 但是因为这不是考试，所以我认为还需要想到正解。
### 可设数列为 1,2,3,4,...,n-1,n。
### 1.n为奇数，所以可设n的二进制形式为 ABCD1, n-1的二进制形式为ABCD0，此刻，可得出，n^(n-1)=1；然后对于数列中前面的所有数，便可以拆分为若干个1异或，所以这种情况便转化为求若干个1异或的值
### 2.n为偶数，可以把序列拆为前n-1个奇数的异或值，再把这个值异或n即可，而对于前n-1个奇数的异或值，求法与（1）相同。

## 以下代码：
```cpp

#include <bits/stdc++.h>
using namespace std;
long long n,ans;
int main(){
scanf("%lld",&n);
if (n&1)
	{ 
	ans=(n-1>>1)+1;
    ans&=1;
	}
else 
	{
	ans=(n-1-1>>1)+1;
	ans&=1;	
	ans^=n;    
	}
printf("%lld\n",ans);
return 0;	
}


```


---

## 作者：Ofnoname (赞：9)

本来是为了练习复杂位运算找到此题的，不过似乎与位运算没有太大关系。

### 我们可以发现$2n$和$2n-1$两个整数的二进制表示只有最后一位不同，根据“相同为0，不同为1的原则”，可以得到$(2n)xor(2n-1)=1,n∈Z$的结论。

### 又因为$1$ $ xor $ $1=0$，那么$(4n-3)xor(4n-2)xor(4n-1)xor(4n)=1$ $xor$ $1=0$。 我们可以得到结论：只要是4的倍数，答案都是0！！！

### 如果不是4的倍数应该怎么办呢？这个我想了半天，最后发现只要找到小于N的4的倍数然后顺势下推就好了，这有点类似于分段打表，对分段打表不熟的同学可以去做[P1662 数7](https://www.luogu.org/problemnew/show/P1662)。

### 至此本题已经完美解决，代码如下：
```
#include <bits/stdc++.h>
using namespace std;

long long ans,N;

int main()
{
	scanf("%lld",&N);
	ans=N>>2<<2;
    //找到最近的4的倍数
	for (long long i=(N>>2<<2)+1; i<=N; i++)
		ans^=i;//最多只有下推3次
	printf("%lld",ans);
	return 0;
}
```

## 提醒：记得全开long long不然会有各种问题出现。

---

## 作者：CR_Raphael (赞：7)

当我看完楼上上那位的O(1)做法……小的真是弱啊

这题有很多做法，楼上有O(log n\*log n)的dp，有O(1)的结论，%%%，都TQL！

我的做法是O(log n)的：

对于每一位，1和0是周期出现的，我们写一写后三位：

```cpp
1：001
2：010
3：011
4：100
5：101
6：110 
7：111
8：000
```

发现周期都是10，0110，00011110的，很麻烦。

我们可以在统计01个数时在前面加个0

```cpp
0：000
1：001
2：010
3：011
4：100
5：101
6：110 
7：111
8：000
```
周期形如01，0011，00001111，我们就可以每位O(1)地算出其1和0的个数，多少个0亦或都是0，不管，每两个1亦或成0，不管。所以若1的个数为奇数，答案的这位就该是1.

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int maxn = 18;

int main() {
	long long int n;
	long long int t, s1, s0;
	long long int ans;
	
	scanf("%lld", &n);
	
	ans=0;
	for(t=1; t <= n; t=t<<1) {
		s0= ((n+1)/(t<<1))*t + min(t, (n+1)%(t<<1)) - 1;
		s1= n-s0;
		
		if((s1 % 2) == 1) {
			ans+=t;
		}
	}
	
	printf("%lld\n", ans);
	
	return 0;
}

```

还有就是结论法了：

上O(1)代码:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main() {
	long long int n;
	
	scanf("%lld", &n);
	
	if(n%4 == 1) printf("%lld\n", 1);
	if(n%4 == 2) printf("%lld\n", n+1);
	if(n%4 == 3) printf("%lld\n", 0);
	if(n%4 == 0) printf("%lld\n", n);
	
	return 0;
}
```

证明1：

注意到对于……00，……01，……10，……11 亦或为0，

也就是说，每四个亦或为0，不管，把剩下的亦或即可。


证明2：

每两个分一组：……0，……1 亦或为1

也就是说，每两个亦或为1，剩下一个和前面亦或出来1的个数%2再亦或即可。

用原数%4可以包含所有情况。

完结撒花~

---

## 作者：dragonarcher (赞：6)

[更好的阅读体验请点这里](https://www.dragon-archer.me/articles/63.html)
# 这道题是纯数论题
我们先手算$n =$ $1$~$8$，
即可得答案仅与$n$%$4$的值相关

### 上代码
```cpp
	#include <iostream>
	using namespace std;
	
	int main()
	{
		long long n;
		cin >> n;
		switch(n % 4)
		{
			case 0:
				cout << n;
				break; //注意不要漏掉 break
			case 1:
				cout << 1;
				break;
			case 2:
				cout << n + 1;
				break;
			case 3:
				cout << 0;
				break;
			default:
				break;
		}
		return 0;
	}
	
```


---

## 作者：Peter_Z (赞：6)

首先，由于n最大可达到10^18（这里的^表示幂），所以可以确定两点：

1.数据需要用unsigned long long

2.不能模拟（废话）

由于看不懂上一篇代码是什么意思，就写了个简化版（更容易懂）：

//注：把几个地方挖空了，想抄的同学自己想里面是什么

```cpp
#include<iostream>
#include<stdlib.h>
using namespace std;
typedef unsigned long long ull;
ull cal(ull n) {        //计算从1～n累计异或值 
    if(n%4==0)    return n; 
    if(n%4==2)    return n+1;
    if(              )    return 1;
    if(              )      return 0;
}
int main() {
    ull n,ans;        //n-题目给出的末项 
    cin>>n;
    ans=cal(n);        //计算结果 
    cout<<ans;
    return 0;
}
```

---

## 作者：wanghanjun (赞：5)

我做这道题的时候把前7个数的二进制码写出来了   
如下：
```
1 ： 0 0 1     
2 ： 0 1 0      
3 ： 0 1 1
4 ： 1 0 0
5 ： 1 0 1
6 ： 1 1 0
7 ： 1 1 1
```
如果单看后两位，可以发现去掉前三个以外以00,01,10,11循环;

又可以发现前三个恰好是01,10,11;

所以我们考虑把0加上，因为任何数异或0还得那个数;

于是变成了这样：
```
0 ： 0 0 0
1 ： 0 0 1     
2 ： 0 1 0      
3 ： 0 1 1
4 ： 1 0 0
5 ： 1 0 1
6 ： 1 1 0
7 ： 1 1 1
```
于是就发现了循环，每位上1的个数就可以用O(1)的效率求出来了;

判断方法：除了最后一位，其他位上的每一个循环节上都有偶数个1，循环节后也好判断1的数量;

所以把每位都枚举一下就可以了，效率O(logn);


代码如下：
```
#include <iostream>
using namespace std;

typedef long long ll;
ll f(ll a){
    if(a<0) return 0;
    //小于0则返回0
    else return a;
    //否则返回a
}//求循环节后面的序列的个数要用到

int main(){
    ll a,k=1,ans=0;
    cin>>a;
    a+=1;//保留0
    if((a/2)%2==1) ans++;
    //特判最后一位
    while(k<=a*2){
        k*=2;
        ll x=f(a%(k*2)-k);
        ans=x%2*k+ans;
    }
    cout<<ans<<endl;
    return 0;
}
```


------------

那有没有更快的方法呢？答案是有的。

如果仔细观察，不难发现：
对于任何n，(4*n)^(4*n+1)^(4*n+2)^(4*n+3)=0;

所以枚举一下n模4的余数即可;

代码如下：
```
#include <iostream>
using namespace std;

typedef long long ll;
ll a;

int main(){
    cin>>a;
    if(a%4==0) cout<<a<<endl;
    if(a%4==1) cout<<'1'<<endl;
    if(a%4==2) cout<<a+1<<endl;
    if(a%4==3) cout<<'0'<<endl;
    return 0;
    //不用解释了吧
}
```


---

## 作者：ghj1222 (赞：5)

因为我比较懒，所以我们令$xor!$表示题中要求的东西。

首先打表找规律，比如对于前31个数：

```
dec bin  xor!
00 00000 00000
01 00001 00001
02 00010 00011
03 00011 00000
04 00100 00100
05 00101 00001
06 00110 00111
07 00111 00000
08 01000 01000
09 01001 00001
10 01010 01011
11 01011 00000
12 01100 01100
13 01101 00001
14 01110 01111
15 01111 00000
16 10000 10000
17 10001 00001
18 10010 10011
19 10011 00000
20 10100 10100
21 10101 00001
22 10110 10111
23 10111 00000
24 11000 11000
25 11001 00001
26 11010 11011
27 11011 00000
28 11100 11100
29 11101 00001
30 11110 11111
31 11111 00000
```

我们可以发现，对于x，有：

如果  $(x+1)\equiv 0\ (mod\ 4)$ ，那么他的 $xor!$ 一定是0

如果 $x\equiv 0\ (mod\ 4)$ ，那么他的 $xor!$ 一定是他自己

（别的依次类推？）

所以我们只需要从输入的那个N向下累xor到i%4==0即可

于是代码就很简单了

还有就是：十年OI一场空，不开long long见祖宗

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    long long a;
    cin>>a;
    long long ans=0;
    while((a+1)%4!=0)
    {
        ans=ans^a;
        a--;
    }
    cout<<ans<<endl;
    return 0;
}
```
他的正确性可以证明？试一试。。。


已知 $a\equiv 0\ (mod\ 4)$~~我咋不直接写4|a啊~~，求证 $(a)\bigoplus (a+1)\bigoplus(a+2)\bigoplus(a+3)=0$

证明，由于a能被4整除，由题意可知，a的二进制为y00，a+1的为y01，a+2的为y10，a+3的为y11，异或之后变为0。(其中y为一段01序列)~~//懒得写公式符号了~~

证毕~(写完了才发现原来这么简单。。)

---

## 作者：Do_Right (赞：4)

emmmmmm，这个题目让人忍不住打表写;
打出来的表，上面的大佬们都写出来了。【我打满了一张科作业纸。。。。】

时间复杂度为O(1)【快准狠】;

如果不知道异或，~~百度一下，你就知道~~

上代码，简单粗暴，开下long long比较保险【我是没有尝试过不开long long提交，为了一遍过，不作】
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib> 
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
	long long n;
    cin>>n;
    if(n%4==1) cout<<1;
    if(n%4==2) cout<<n+1;
    if(n%4==3) cout<<0;
    if(n%4==0) cout<<n;//暴搜挂着机，打表出省一
	return 0;
}
```

---

## 作者：盖矣斌峥 (赞：4)


当x为奇数时，x可以表示一个以1结尾的二进制数，而x-1转成二进制除了结尾为0以外，其他数位与x相同，所以x^x-1=1

然后记录一下1~n中有多少对(x,x-1)，得到所有数对的异或结果

也就是将(2,3),(4,5),(6,7).......(n-1,n)//这里n是奇数 进行配对，求出它们的异或总和（很多个1异或，奇数个为1，偶数个为0）

------------


```
   ans=ans%2; //计算出所有数对的异或结果
```
------------

然后再特殊处理1，如果是偶数，还需要处理n，将ans与它们异或得到最后的答案

```
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
	long long n,ans;
	cin>>n;
	if(n%2==1)
	{
		ans=(n-1)/2;
		ans=ans%2;
		ans=ans^1;
	}
	else {
		ans=n/2-1;
		ans=ans%2;
		ans=ans^1;
		ans=ans^n;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：henry_y (赞：3)

好久没写简单题的sol了...

这题首先有一个快捷做法

我们直接打出n<=100时的表

![](https://cdn.luogu.com.cn/upload/pic/46426.png) 

会发现对于4的倍数，xor的和都等于它本身，于是求出小于n的最小倍数，往上随便推几步就好了

复杂度$O(4)$

接下来我们尝试着不严谨地来证明这道题

列出0,1,2,3的二进制
```
0:000
1:001
2:010
3:011
```
他们的xor和为0，所以说到4的xor和为他本身，又因为二进制是逢2进1的，所以在后面的数也是一样的...

于是就套用上面的结论就行

~~（这证明完全不严谨）~~

```
#include <bits/stdc++.h>

#define int long long

signed main() {
	int n, sum = 0;
	scanf("%lld", &n);
	/*
	for(int i = 1; i <= n; i ++) {
		sum ^= i;
		printf("i = %d xor sum = %d\n", i, sum);
	}
	*/
	int k = n / 4 * 4, ans = k;
	while(k < n) {
		++k ;
		ans ^= k;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：VenusM1nT (赞：3)

刚开始看到这题目，我选择再次mengbi……


然而鉴于被数论的题目摧残得太多，于是就不由得想到一种方法：


##找规律


诞生了以下程序：

```cpp
#include<cstdio>
int n,sum=1;
int main()
{
    scanf("%d",&n);
    for(int i=2;i<=n;i++) sum=sum ^ i;
    printf("%d",sum);
    return 0;
}
```
当然这个程序肯定是不能A题的，但我们可以找规律


打出一张表：

```cpp
1 1
2 3
3 0
4 4 
5 1 
6 7 
7 0 
8 8 
9 1 
10 11 
11 0 
12 12 
... 
```
这都找不出规律那我就真无话可说了=-=


当然要注意用long long


具体见代码

```cpp
#include<cstdio>
long long n,sum=1;
int main()
{
    scanf("%d",&n);//读入n 
    if(n%4==0) printf("%d",n);
    else if(n%4==1) printf("%d",1);
    else if(n%4==2) printf("%d",n+1);
    else if(n%4==3) printf("%d",0);
    //输出四种情况的解 
    return 0;//结束 
}
```

---

## 作者：Kaizyn (赞：2)

手玩数据寻找规律

从**0**开始发现每四个可以抵消掉

0~3 抵消

4~7 抵消

8~11 抵消

...

~~别问我这么找到的~~

因此只要四个四个一组考虑最后多出来的几个

还不需要特判

**一行搞定**

```cpp
for(int i = 0; i < (n+1)%4; ++i) ans ^= n-i;
```

---

```cpp
#include <iostream>
using namespace std;
long long n, ans;

int main()
{
	cin >> n;
	for(int i = 0; i < (n+1)%4; ++i)
		ans ^= n-i;
	cout << ans << endl;
	return 0;
}
```

---


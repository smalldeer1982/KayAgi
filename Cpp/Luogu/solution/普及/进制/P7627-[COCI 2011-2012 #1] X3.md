# [COCI 2011/2012 #1] X3

## 题目描述

给定一个长度为 $N$ 的序列 $A_1,A_2,...,A_N$，求序列元素两两异或的总和。

## 说明/提示

#### 【样例 2 解释】

$A_1 ⊕ A_2 = 4$，$A_1 ⊕ A_3 = 2$，$A_2 ⊕ A_3 = 6$，$4 + 2 + 6 = 12$，因此答案为 $12$。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 10^6$，$1 \le A_i \le 10^6$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $110$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #1](https://hsin.hr/coci/archive/2011_2012/contest1_tasks.pdf)** ___T3 X3___。

## 样例 #1

### 输入

```
2
19
10```

### 输出

```
25```

## 样例 #2

### 输入

```
3
7
3
5```

### 输出

```
12```

## 样例 #3

### 输入

```
5
9
13
1
9
6```

### 输出

```
84```

# 题解

## 作者：I_like_magic (赞：16)

这题其实不难

但如果用暴力，肯定过不了

所以我们得想另一种办法

我们发现，只有 $1$ 异或 $0$ 的值为 $1$

例如： 

$1$ , $0$ , $1$ 两两异或的和为 2

其实就是每个 $0$ 与每一个 $1$ 异或时，$sum$ 要加 $1$

所以，我们只要把每一位的 $0$ 和 $1$ 的数量都统计出来，再进行运算，就可以快速得出 $sum$

$AC\hspace{0.2cm}Code$

```cpp
#include<bits/stdc++.h>//万能头文件
#define int long long//记得开 long long
using namespace std;
int n,cnt[100],sum;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		int a,j=1;
		scanf("%lld",&a);
		while(a){
			cnt[j]+=a%2;//统计每一位 1 的个数
			j++;
			a/=2;
		}
	}
	for(int i=1;i<=30;i++){
		sum+=cnt[i]*(n-cnt[i])*(1<<(i-1));//算出每一位的异或值
	}
	printf("%lld",sum);
	return 0;//完美收尾
}
```

---

## 作者：sid_shi1 (赞：9)

题目：[P7627 [COCI2011-2012#1] X3](https://www.luogu.com.cn/problem/P7627)

思路：

本题要求两两的异或和，打暴力是肯定不行的，只能得 $44$ 分。

首先，我们考虑一个数转成二进制后每个位的操作，我们知道异或的运算： $0$ 和 $1$ 异或得 $1$ ， $1$ 和 $1$ 或者 $0$ 和 $0$ 异或得 $0$ 。那么，怎么求多个 $0$ 和 $1$ 的两两异或和呢？

举个例子： $0$ ， $1$ ， $0$ 三个数，两两异或和应该是， $0$ 异或 $1$ 加上 $0$ 异或 $0$ 再加上 $1$ 异或 $0$ 。我们发现，每个 $0$ 和一个 $1$ 进行异或 $sum$ 就要加 $1$ ，也就是说每一个 $0$ 都会使 $sum$ 加上 $1$ 的个数（因为 $0$ 要和 $1$ 的个数个 $1$ 异或）。我们设有 $x$ 个 $1$ ，那么 $sum$ 就等于 $0$ 的个数乘 $1$ 的个数，也就是 $sum=(n-x) \times x$ 。

做法：

我们将原数组的每个元素都转换为二进制，并用一个数组记录二进制中每一位 $1$ 的个数。然后一个循环，将二进制每一位的两两异或和都算出来，再转成十进制加起来就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[21]={0},sum=0;//记得开long long
int main() {
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		long long x;
		int j=0;
		scanf("%lld",&x);
		while(x>0){//将x转成二进制，得到每一位
			if(x%2==1) a[j]++;//二进制中第j位的个数加一
			x/=2;
			j++;
		}
	}
	for(int i=0;i<=20;i++) sum+=a[i]*(n-a[i])*(1<<i);//总和加上每一位的两两异或和
	printf("%lld",sum);
	return 0;
}
```


---

## 作者：xxasmcd (赞：5)

#### 题目：[P7627 [COCI2011-2012#1] X3](https://www.luogu.com.cn/problem/P7627)

思路:


我想出来的解是把输入的 n 个数拆成二进制，每一位分开，将 n 个数二进制的每一位取出统计 1 和 0 的个数，因为是异或操作，所以每一个 0 异或每一个 1 都会产生一个 1 的贡献值，再把每一位的总贡献值乘以对应的二进制数值加和就是结果。

本题的加和值可能会爆 int，最终统计和的变量需要设 long long 类型。

#### 代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000001],o[31];
long long ans=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    o[0]=1;//初始化二次幂值
    for(int i=1;i<31;i++)
    {
        o[i]=o[i-1]*2;//求二次幂
    }
    for(int i=0;i<31;i++)//最多有31位，实际可能达不到
    {
        int x=0;
        for(int j=1;j<=n;j++)//将n个数逐一枚举，拆开
        {
            if(a[j]&1)//统计个数
            {
                x++;
            }
            a[j]>>=1;
        }
        ans+=1LL*x*(n-x)*o[i];//计算当前位的总贡献
    }
    cout<<ans;
    return 0;
}

```



---

## 作者：seac_blue (赞：4)

题目：[[COCI2011-2012#1] X3](https://www.luogu.com.cn/problem/P7627)

题意：给定一个长为 $N$ 的序列 $A_1,A_2,\cdots A_N$，求序列元素两两异或的总和。

- $1\le N\le 10^6$
- $1\le A_i\le 10^6$

### 思路

因为**位运算在二进制表示下不进位**，所以考虑将 $A_i$ 转化为二进制。之后每一位分开处理即可。

显而易见地，有 $0\oplus 0=1\oplus 1=0,\quad0\oplus 1=1\oplus 0=1$

所以我们设 $N$ 个数的二进制表示中，在第 $i$ 位下为 $0$ 的数有 $a_i$ 个，那么在这一位下，为 $1$ 的数有 $(N-a_i)$ 个。

因为这 $N$ 个数是两两配对的关系，所以根据乘法原理，两两配对得到的结果为 $1$ 的组合有 $a_i(N-a_i)$ 种，再乘上 $2^i$，各位相加即可。

### 代码

以下是删去头文件后的代码。

```cpp
using namespace std;

#define re register
typedef long long ll;

inline ll read(){
	char c=getchar();ll d=0,f=1;
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){d=(d<<3)+(d<<1)+(c^48);c=getchar();}
	return d*f;
}

const ll MAXLOGA=20;

ll n,ans;
ll a[MAXLOGA];

int main(){
	n=read();
	for(re ll i=1;i<=n;++i){
		ll x=read(),ptr=0;
		while(x){
			if(x&1){++a[ptr];}
			x>>=1;++ptr;
		}
	}
	
	for(re ll i=0,base=1;i<MAXLOGA;++i,base<<=1){
		ans+=base*a[i]*(n-a[i]);
	}
	
	printf("%lld\n",ans);
	return 0;
}
```

### 拓展

实际上，我们还可以对这道题作一个拓展。

设需要异或的数字不是 $2$ 个，而是 $k\ (k<N)$ 个时，求它们的异或和之和。

思路依然相同：将十进制转化为二进制，对于每一位进行分析。但是这一次，需要分析的情况就很多了。

先画出 $k=3$ 时，$s_1,s_2,s_3\in\{0,1\}$ 在不同的取值下，$s_1\oplus s_2\oplus s_3$ 的值。

| $s_1$ | $s_2$ | $s_3$ | $s_1\oplus s_2\oplus s_3$ |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | $0$ | $0$ |
| $0$ | $0$ | $1$ | $1$ |
| $0$ | $1$ | $0$ | $1$ |
| $0$ | $1$ | $1$ | $0$ |
| $1$ | $0$ | $0$ | $1$ |
| $1$ | $0$ | $1$ | $0$ |
| $1$ | $1$ | $0$ | $0$ |
| $1$ | $1$ | $1$ | $1$ |

可以发现，**当 $s_1,s_2,s_3$ 恰好有奇数个数的值为 $1$** 时，异或和为 $1$。

同理，对于 $k$ 个数，当 $s_1,s_2,\cdots,s_k$ 恰好有奇数个数的值为 $1$ 时，异或和为 $1$。

同样设 $N$ 个数的二进制表示中，在第 $i$ 位下为 $0$ 的数有 $a_i$ 个，为 $1$ 的数有 $(N-a_i)$ 个。

则这一位下的结果就是在满足

$$\left\{
\begin{aligned}
 p \equiv 1 \ (\text{mod}\ 2)\\
 1\le p\le \min(k,N-a_i)\\
 1\le N-p\le \min(k,a_i)
\end{aligned}
\right.$$

时，

$$\text{C}\,_{N-a_i}^{p}\times \text{C}\,_{a_i}^{N-p}$$

值之和。

最后再把各位相加，即可得到结果。

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7627)

题意不多说了。

### 前提

异或的运算法则可以看[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fromtitle=%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97&fromid=720417&fr=aladdin)。

二进制转十进制可以看[这里](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6/393152)。

乘法原理可以看[这里](https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86/7538447)。

### 思路

暴力是肯定不能过的，这里不多阐述。

首先我们可以把每一个 $A_i$ 都转成二进制，然后从低位到高位一位一位的去异或，将结果转成十进制求和。



我们不难的发现只有 $1\oplus0$ 对答案有贡献，设 $1$ 的个数为 $x$，利用乘法原理我们可知道答案为：
$(n-x) \times x$。

因为 $(n-x) \times x$ 是二进制不进位的数字，所以还要把它转成十进制求和。

剩下的看代码就行了。

### 贴贴代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[1100086],ans,x,b,k=1;
int main(){
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)
		scanf("%lld",&a[i]); /*输入*/
	for(ll i=1;i<=20;i++){ /* log2(10^6) 约等于 20*/
		for(ll j=1;j<=n;j++)
			if(a[j]&k) //当前这个位的值是否等于 1 
				b++; //1 的个数加 1 
		ans+=(k*b*(n-b)); //乘法原理 
		k*=2,b=0;//下一位 
	}
	printf("%lld",ans);
	return 0;
} 
```


---

## 作者：Karl_Aurora (赞：1)

**[~~无耻地推销个人博客 qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p7627)**

**[题目传送门](https://www.luogu.com.cn/problem/P7627)**

------------

## 题意

给定 $ N $ 个正整数，求其两两异或的结果之和。

## 解法


对于 $ 10 ^ {6} $ 的数据，显然暴力求和会 T 的连炸都不剩，考虑到从取数和计算上基本不存在将 $ O ( n ^ {2} ) $ 的枚举进行优化的可能，故转移思路从二进制上入手。

因为异或是按位计算，各位相互独立，所以我们对其中一位进行分析。

>
> Q： 对于某一位的每一次异或运算，在什么时候会对和做出贡献？
>
> A： 当然是在这一位的运算结果为 $ 1 $ 的时候（废话， $ 0 \times a = 0 $ ）。
>
> Q： 那么是什么时候呢？
>
> A： 两数在这一位上不同的时候。
>

由于我们要讨论这一位的贡献时，显然只需要统计贡献次数即可，所以我们只需要统计所有的正整数中在这一位上不同的数对共有多少对。

又因为对于每个数的每一位只有 $ 0 $ 和 $ 1 $ 两种可能，所以显然对数等于 $ 0 $ 的个数乘上 $ 1 $ 的个数。

同时对于从低往高第 $ i $ 位上的每次结果为 $ 1 $ 的异或，其对答案的贡献为 $ 2 ^ {i - 1} $ ，故对贡献求和得到的最终答案应为

$ \Sigma 2 ^ {i - 1} n _ {i, 0} n _ {i, 1} $，只需要在输入时统计一下每一位上的情况数即可。

最后代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int X = 0; bool f = false; char ch = getchar();
	while (ch > '9' || ch < '0') {f |= ch == '-'; ch = getchar();}
	while (ch <= '9' && ch >= '0') {X = (X << 3) + (X << 1) + (ch ^ 48); ch = getchar();}
	return f ? -X : X;
}
inline void write(int X)
{
	if (X == 0) {putchar('0'); return;}
	if (X < 0) {putchar('-'); X = -X;}
	static char num[41]; static short cnt = 0;
	while (X) {num[++cnt] = (X % 10) ^ 48; X /= 10;}
	while (cnt) putchar(num[cnt--]);
	return;
}
int n, a, ans;
int bit[31][2];
signed main()
{
//	freopen("x3.in", "r", stdin);
//	freopen("x3.out", "w", stdout);
	n = read();
	for (int i = 1; i <= n; ++i)
	{
		a = read();
		for (int j = 1; j <= 30; ++j, a >>= 1) ++bit[j][a & 1];
	}
//	for (int i = 1; i <= 30; ++i) cerr << bit[i][0] << " " << bit[i][1] << endl;
	for (int i = 1; i <= 30; ++i) ans += (bit[i][0] * bit[i][1]) << (i - 1);
	write(ans);
	return 0;
}
```
~~```#define int long long```是个坏习惯，这里是考场上应急写的，好孩子们不要学哦（大雾~~

至此，愉快 AC，完结撒花 0v0

---

## 作者：fls233666 (赞：1)

看到这题，一个显然的暴力是在读入每个数字后 $O(n)$ 对之前读入的每个数字做一遍异或并求和。总的时间复杂度是 $O(n^2)$ 的，在 $1 \le n \le 10^6$ 的情况下显然无法通过。我们需要总复杂度为 $O(n)$ 的更快的做法。

我们注意到，**我们只需要知道最后的和，并不需要把每个数字都两两进行异或。** 于是我们考虑，当一个新的数字输入后，它与前面的每个数字异或，对最终答案的贡献有多少。

我们知道异或是按位进行的。那么一个新输入的数字与之前的数字做异或运算，只需要知道**之前输入的数每一位上有几个是 $1$ 有几个是 $0$。**
通过这些信息，我们就可以计算每一位异或的结果，进而得出每个输入的数对答案的贡献。

那么我们可以开一个数组 $dig(i,0/1)$ 表示第 $i$ 位上为 $0/1$ 的数字有几个。把每个输入的数字转成二进制数，统计了每一位的异或结果记入答案后把每一位的数加到 $dig$ 对应的部分上即可。

那么此题思路到这就结束了，下面是代码：

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define rgt register int
using namespace std;

const int mxn = 1e6+6;
const int mxdig = 20;

int n,tmp_dig[22];
ll w[22],ans,dig[22][2];

int main(){
	w[0]=1;
	for(rgt i=1;i<=20;i++)
		w[i]=(w[i-1]<<1);  //第i位对答案的贡献为 2^i，预处理
        
	scanf("%d",&n);
	for(rgt num,i=1;i<=n;i++){
		scanf("%d",&num);
		for(rgt j=0;j<=mxdig;j++){
			tmp_dig[j]=(num&1);
			num>>=1;
		}  //输入的数字转化为二进制数
        
		for(rgt j=0;j<=mxdig;j++){
			ans+=dig[j][tmp_dig[j]^1]*w[j];
			dig[j][tmp_dig[j]]++;
		}  //计算答案并放入 dig 数组中
	}
	printf("%lld",ans);  //得到答案
	return 0;
}
```


---

## 作者：yuqihao (赞：0)

# P7627 [COCI2011-2012#1] X3 题解

## 题目大意

给定一个长度为 $n$ 的序列 $A_1$,$A_2$,...,$A_N$，求序列元素两两异或的总和。

## 思路

首先我们要了解**异或**（$⊕$）这个运算。

异或（$⊕$）运算就是对两个二进制数的每一位进行异或，如果两个数这一位**相同**，异或结果就为 $0$，不同就为 $1$。

如

```cpp
13^8
 13 0001101 
^ 8 0001000
= 5 0000101
```

所以 $n$ 个数中第 $i$ 位上每一对 $0$ 和 $1$ 都能造成 $1\times2^{i}$ 的贡献，我们设这一位上有 $x$ 个 $1$，则有 $n-x$ 个 $0$，而每个 $1$ 和 $n-x$ 个 $0$ 都能造成贡献，所以 $ans=ans+x\times(n-x)\times2^i$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,x,a[25],ans;//不开long long见祖宗
int main(){ 
	cin>>n;
	for(long long i=1;i<=n;i++){
		cin>>x;
		long long j=0;
		while(x){//将x转为二进制
			if(x&1)a[j]++;//第j位1的个数加一
			x/=2;
			j++;
		}
	}
	for(long long i=0;i<=20;i++)ans+=a[i]*(n-a[i])*(1<<i);//加上第i位的异或和
	cout<<ans;
	return 0;
}
```



---

## 作者：lhc_0506 (赞：0)

蒟蒻的第二篇题解

## 题意

挺 water 的，应该都看得懂

给你 $n$ 个数，让你求这 $n$ 个数每两个数异或的结果的和

例如：

$n=3$

$a_1=1$,$a_2=2$,$a_3=3$

这时，我们答案就是 $a_1\oplus a_2+a_2\oplus a_3+a_1\oplus a_3=6$

## 思路

这道题我们最先想到暴力，但数据范围明显不允许我们这样做

本来这就是一道关于二进制的题，那我们能不能用最原生态的方法——二进制来做呢

答案是可以的

首先我们要知道异或的原理：$0\oplus 1=1,1\oplus 1=0,0\oplus 0=1$

所以，我们其实只用算 0 和 1 的组合，00 和 11 都一边去吧！

我们先算出每一位上有几个 1，再把每一位的异或出的1的个数，乘以对应的二进制数值加和就是结果

AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10001],sum,b;
long long sqrt(long long q) {
	if(!q)
		return 1ll;
	else
		return (1ll<<q);
}
int main() {
	scanf("%lld",&n);
	for(long long i=1ll,x; i<=n; i++) {
		scanf("%lld",&x),b=0ll;
		while(x)//转二进制
			if(x&1)//如果是1就加一下个数
				a[b]++,x>>=1ll,b++;
			else
				x>>=1ll,b++;
	}
	for(long long i=0; i<=20; i++)
		sum+=a[i]*(n-a[i])*sqrt(i);
	printf("%lld",sum);
}
```

---

## 作者：QcpyWcpyQ (赞：0)

- 思路：

题目让我们求的是两两之间的异或和。

首先考虑暴力。这很容易想到，但是时间复杂度是 $O(n^2)$，肯定会超时。

考虑如何优化，从异或的定义入手：将一个十进制数转化为二进制进行运算，然后将结果转化为十进制数。

在同一位中，每有一个 $0$ 和一个 $1$ 就会对答案有贡献。因此先将每个数转化为二进制，之后统计每个数每一位 $1$ 的数量，假设有 $x$ 个，那么 $0$ 的数量就是 $(n-x)$ 个。

- 根据加乘原理，$sum=\sum\limits_{i=0}^m a_i\times(n-a_i)\times 2^i$。其中 $a_i$ 为第 $(i+1)$ 位 $1$ 的数量，$m$ 为转化为二进制数后的最大位数。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int N=1e6+5;
int n,a[N];
ll sum;

inline int read(){
	int s=0,f=1;char ch=getchar();
	while(ch<'0' or ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' and ch<='9'){s=(s<<1)+(s<<3)+(ch^48);ch=getchar();}
	return f*s;
}

inline void write(ll num){
	if(num<0)putchar('-'),num=-num;
	if(num>9)write(num/10);
	putchar(num%10+48);
}

int main(){
    n=read();
    for(int i=1,wei,num;i<=n;i++){
        num=read(),wei=0;
        while(num){
            if(num%2==1)
                a[wei]++;
            wei++;
            num/=2;
        }
    }
    for(int i=0;i<=20;i++)
        sum+=(ll)a[i]*(n-a[i])*(1<<i);
    write(sum);
    return 0;
}
```


---

## 作者：az__eg (赞：0)

大水题。

先考虑如果使用暴力的话，我们直接求出每次异或后的结果并相加。但是 $n$ 最大等于 $10^5$，显然是无法接受的。

让我们来思考一下异或的性质：对于两个数的二进制进行操作，当两数的第 $i$ 位相同时，则生成的数的第 $i$ 位为 $0$，否则为生成的数的第 $i$ 位为 $1$，如果位数不够用 $0$ 替代。

我们可以求出每个 $a_i$ 的二进制在第 $j$ 位时 $0$ 和 $1$ 的数量，然后再将 $a_i$ 再求一遍二进制即可。

代码：


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long a[1000001];
long long ws1[1000001];//第j位0的个数
long long ws0[1000001];//第j位1的个数
long long zcc[1000001];
long long n;
long long mx;
long long ans;
signed main()
{
	long long i,j;
	scanf("%lld",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	for(i=1;i<=n;i++)
	{
		long long zc = a[i];
		long long cnt = 0;
		while(cnt!=28)
		{
			if(zc%2==0)
			{
				ws0[cnt]++;
			}
			else
			{
				ws1[cnt]++;
			}
			zc/=2;
			cnt++;
			//存储每一位1和0的数量
		}
		mx = (mx,cnt);
	}
	
	long long ans = 0;
	for(i=1;i<=n;i++)
	{
		long long dq=1;
		long long zc = a[i];
		long long cnt = 0;
		while(cnt!=28)
		{
			zcc[cnt]=zc%2;
			zc/=2;
			cnt++;
		}
		for(j=0;j<=mx;j++)
		{
			if(zcc[j]==0)
			{
				ans+=dq*ws1[j];
			}
			else
			{
				ans+=dq*ws0[j];
			}
			dq*=2;
			//求和
		}
	}
	printf("%lld",ans/2);
}
```

---

## 作者：bryce (赞：0)

### [题目链接](https://www.luogu.com.cn/problem/P7627)

这道题显然不能直接用暴力，接下来就需要用一些简单的推论。

首先要知道异或是怎么运算的（绝大多数人应该都知道）1 异或 0 得 1，1 异或 1 或者 0 异或 0 得 0，异或在 c++ 中的符号是 ^。

所以只有 1 异或 0 对答案有贡献，因此我们可以统计第 $i$ 位的 n 个数上的 1 的个数（假如有 $x$ 个），那么 0 的个数就是 $(n - x)$，接着利用乘法原理将他们相乘再乘以位权即可得到其贡献值。
## Code

```cpp
#include<iostream>

using namespace std;

int a[1000001], x1[21];

int main(){
	int n, k = 1;
	long long ans = 0;	//会超出 int
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> a[i];
	}
	for (int i = 0; i <= 20; i++){	//枚举每一位，最多就 20 位
		for (int j = 1; j <= n; j++){	//枚举 n 个数
			if (a[j] & k){	//判断这个数字的第 i 位是否为一
				x1[i]++;
			}
		}
		ans += 1ll * k * x1[i] * (n - x1[i]);	//利用乘法原理将他们相乘再乘以位权
		k *= 2;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：cyhyyds (赞：0)

## 思路：
显然，我们需要将每一位二进制下的 $1$ 的个数处理出来。

而对于第 $i$ 位，设 $1$ 的个数为 $c$，则为 $0$ 的个数为 $n-c$。

那么，该位贡献的答案就是 $c×(n-c)×2^i$。

因为对于每一个 $1$，找到一个 $0$ 与其配对，答案就会增加 $1$。

也就是说，第 $i$ 位的贡献就是 $1$ 和 $0$ 组成的配对的个数乘以 $2^i$。

而按照乘法原理，组成的配对的个数就是 $c×(n-c)$。

## 核心代码：
```
for (int i = 0; i <= 22; i ++) {
	ans += (n - popc[i]) * popc[i] * (1 << i);
    
    //popc[i]存储第i位的1的总数。
}
```


---


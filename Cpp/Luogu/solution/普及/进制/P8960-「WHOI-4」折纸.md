# 「WHOI-4」折纸

## 题目背景

吉尼斯记录：一张纸（如果接近 $4$ 公里的卫生纸可以算作一张纸）最多可以对折 $13$ 次。小 X 吹牛说打破了这个记录，但是吹太大了。

## 题目描述

小 X 向吉尼斯世界纪录组织申请了这个记录，但是他正好隔离在家，无法证明。他只好允许他们问 $t$ 个问题，确认他确实打破了记录。

他们每个问题可以要求小 X 把一张纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。对折全部是从上方翻。**接下来将会展开，展开后纸片在原位，只是保留了折痕。看看自己是否实现了这一点。**

他们想要知道，从左往右数第 $k$ 个折痕是峰折（向上突起的折痕）还是谷折（向下凹陷的折痕）。如果该询问的答案是峰折，输出 `Up`；否则输出 `Down`。请你帮帮可怜的小 X。

峰折，谷折的图示见样例解释。

## 说明/提示

**样例解释**

样例 #1 解释：

动态地址：[here](https://img-blog.csdnimg.cn/c68f2ba917504417b109eb1606f4a3a5.gif)。不知道为什么洛谷显示不了了。

![](https://cdn.luogu.com.cn/upload/image_hosting/wguzrqz6.png)

由于技术原因，动图帧数略低。

样例 #2 请手动模拟。

**数据范围**

**本题采用捆绑测试。**

- Subtask 1（$20$ pts）：$t=10$，$1\le n\le5$；
- Subtask 2（$80$ pts）：$t=10^5$。

对于 $100\%$ 的数据，有 $1\le t\le 10^5$，$1\le n\le60$，$1\le k<2^n$。

## 样例 #1

### 输入

```
7
3 1
010
3 2
010
3 3
010
3 4
010
3 5
010
3 6
010
3 7
010```

### 输出

```
Down
Up
Up
Down
Down
Down
Up```

## 样例 #2

### 输入

```
7
3 1
011
3 2
011
3 3
011
3 4
011
3 5
011
3 6
011
3 7
011```

### 输出

```
Down
Up
Up
Down
Down
Down
Up
```

## 样例 #3

### 输入

```
2
13 114
1101101111010
13 514
1101101111010```

### 输出

```
Up
Up```

# 题解

## 作者：JuRuoOIer (赞：4)

# 题解 P8960 「WHOI-4」A 折纸

### Part1 题意

[原题传送门](https://www.luogu.com.cn/problem/P8960)

把纸按照一个给定 $01$ 串 $s$ 的规则折叠，求第 $k$ 个折痕的凸起方向。

$10\le t \le 10^5,1\le n \le 60,1\le k \le 2^n$。

### Part2 思路

我们可以一次一次地探索规律。

第一次很显然会有一个谷折，无论左右（不信你拿张纸试试）。

接着我拿一张纸向左折了三次，结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/r85q2eur.png)

仔细观察：

![](https://cdn.luogu.com.cn/upload/image_hosting/6950hk6o.png)

- 可以发现，第 $i$ 次折叠会产生 $2^{i-1}$ 个折痕，**分别位于之前的 $2^{i-1}-1$ 个折痕之间**（包括两边）**的 $2^{i-1}$ 个空当处**。

- 还有，**与中间折痕**（也就是第一次折出来的）**距离相等的两个折痕凸起方向相反。**

- 将四个黄色箭头连起来可以发现：第 $1$ 个和第 $3$ 个、第 $2$ 个和第 $4$ 个相同。如果折更多次，可以发现**同一次折出的所有折痕中，第奇数个折痕凸起方向都相同，第偶数个折痕凸起方向都相同。**

现在就差确定方向了，是吗？

- 刚才我往左折了三次，串 $s$ 应为 `111`，而每一次（除了第一次）折出的折痕都是第奇数个为谷，第偶数个为峰。
- 如果我们把 $s$ 变成 `000`，结果应该与上面相反：第奇数个均为峰，第偶数个均为谷。
- 如果你拿一张纸折一下的话，可以发现最后一次**对折的方向对结果没有影响**（都是那一道折痕有啥影响啊）。
- 于是我们猜测结论：第 $k$ 次对折折出的折痕凸起方向与 $s_{k-1}$ 有关，**当 $s_{k-1}=0$ 时，第奇数个均为峰，第偶数个均为谷；否则第奇数个均为谷，第偶数个均为峰**。代入样例也是对的。

但我们怎么知道这是这一次折出的第几个折痕呢？没关系，继续找规律。

还是这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6950hk6o.png)

上面已经涉及一堆 $2$ 的幂了，我们就尝试把折痕的编号变成二进制试试吧。

```
(k = 第 k 次折出来的
001(3
010(2
011(3
100(1
101(3
110(2
111(3
```

把第一、二、三次的分别放一起：

```
(1
100
(2
010
110
(3
001
011
101
111
```

很明显，第一次折出来的二进制最后一个 $1$ 是左数第 $1$ 位，第二次折出来的最后一个 $1$ 都是左数第 $2$ 位，第三次折出来的最后一个 $1$ 都是左数第 $3$ 位。然后我们就只需要用 $\text{O}(\log n)$ 的复杂度把编号变成二进制找就好啦！

### Part3 代码

注意我这里没有转二进制，是直接从 $2^{60}$ 开始一个个减找最后一位。

注释比较粗略，但涉及的内容均可以在 Part2 找到。

```cpp
#include<iostream>
#include<string>
#define ll long long
#define ull unsigned long long
#define lf double
#define ld long double
using namespace std;
ll t,n,k;
string s;
ll f(ll x){//求二进制位最后一个 1 的位置，据此可得这个折痕是第几次对折而来的 
	for(ll i=61;i>=0;i--){
		if(x>=(1ll<<i)){
			x-=(1ll<<i);
		} 
		if(x==0){
			return i;
		}
	}
}
ll g(ll x,ll fx){//求是这一次里产生的第奇数个还是第偶数个折痕 
	ll tmp=0;
	for(ll i=61;i>=0;i--){
		if(x>=(1ll<<i)){
			x-=(1ll<<i);
			tmp+=(1ll<<(i-fx));
		} 
	}
	return (tmp/2+1)%2;
}
string out[2]={"Up","Down"};//压缩代码(doge) 
int main(){
	cin>>t;
	while(t--){
		cin>>n>>k>>s;
		if(k==(1ll<<n)/2){//第一次很显然是谷折 
			cout<<"Down\n";
		}
		else{
			if(s[s.length()-2-f(k)]=='0'){//这里规律见思路部分 
				cout<<out[!g(k,f(k))];
			}
			else{
				cout<<out[g(k,f(k))];
			}
			cout<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Moon_Traveller (赞：4)

[传送门](https://www.luogu.com.cn/problem/P8960)

首先，我们通过动手模拟可以得出：**折 $n$ 次时，折痕数为 $(2^n - 1)$。**

我们先来模拟一下每次折后的结果（设谷为 0，峰为 1）：

当 $n = 3, s = \tt{010}$ 时:

```latex
1 2 3 4 5 6 7 // 这一行表示折痕位置

第一次折：
      0      
第二次折：
  1       0
第三次折：
0   1   0   1
所有折痕：
0 1 1 0 0 0 1
```

当 $n = 3, s = \tt{011}$ 时:

```latex
1 2 3 4 5 6 7

第一次折：
      0
第二次折：
  1       0
第三次折：
0   1   0   1
所有折痕：
0 1 1 0 0 0 1
```

多试几组数据之后，我们可以粗略得出一个结论：**折痕与 $s$ 的最后一位无关**。

那么，我们可以猜测：**第 $i$ 次折，折痕的朝向与 $s_{i-1}$ 有关。**

再次观察上面模拟的结果，可以发现，折痕的得出过程类似于一个二叉树。第 $i$ 层的节点（$i$ 从 $1$ 开始），左子树与 $s_{i-1}$ 相反，右子树与 $s_{i-1}$ 相同。

也就是说，最后的结论只与前一次折的方向有关。具体的实现方法可以用二分，每次折叠后把结果存储起来，最后得出的结果就是最终结果。

代码：

```cpp
#include <iostream>
#include <cmath> // pow() 函数要用到这个
using namespace std;

long long T;
long long n, k;
char s[65];
bool b[65];
bool flag; // true => Up, false => Down

int main()
{
    cin >> T;
    for(int t = 0; t < T; t++)
    {
        cin >> n >> k;
        for(long long i = 1; i <= n; i++)
        {
            cin >> s[i];
            b[i] = (s[i] == '1'); // 将字符串存成bool型数组，方便比较
        }
        long long l = 1, r = pow(2, n) - 1; // 二分的初始左右边界
        long long i = 1;
        flag = false; // 第一道折痕一定是谷折
        while(l <= r) // 从第二次折开始遍历
        {
            i++; // 第i-1次折叠
            long long mid = (l + r) >> 1;
            /*
            上面那句相当于：
            long long mid = (l + r) / 2;
            */
            if(k < mid) // 处理左半部分
            {
                r = mid - 1;
                flag = !b[i - 1];
            }
            else if(k > mid) // 处理右半部分
            {
                l = mid + 1;
                flag = b[i - 1];
            }
            else // 如果 (k == mid) 说明到达了目标位置，可以输出了
            {
                cout << (flag ? "Up" : "Down");
                /*
                上面那句可以替换成：
                if(flag)
                {
                    cout << "Up";
                }
                else
                {
                    cout << "Down";
                }
                */
                cout << endl; // 别忘了换行
                break;
            }
        } 
    }
    return 0;
}
```

---

## 作者：ztntonny (赞：2)

## 题意

把纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，若 $s_i=0$，将纸从左到右对折；若 $s_i=1$，将纸从右到左对折。求从左往右数第 $k$ 个折痕是峰折还是谷折

## 思路

我看到后第一反应就是与正负有关，并递归求解。

考虑当折叠一个纸片的时候，从上面看折痕会发生什么变化：

![](https://cdn.luogu.com.cn/upload/image_hosting/vu517xwg.png)

##### 其中 $1$ 代表着峰折，$0$ 代表着谷折，红色粗体字代表着折痕被取反了。

那么不难发现**折痕形式变化**：

- 在向左翻折的时候，若我们要求的折痕在对折位置左侧，则**不变**；若在右侧，则**取反**。
- 在向右翻折的时候，若我们要求的折痕在对折位置左侧，则**取反**；若在右侧，则**不变**。

再考虑对折后的**位置变化**，以对折后的纸条最左侧的折痕为 $1$，设之前位置 $pos$，之前长度 $len$：

- 在向左翻折的时候，若我们要求的折痕在对折位置左侧，则**变成** $pos$；若在右侧，则**变成** $len-pos$。
- 在向右翻折的时候，若我们要求的折痕在对折位置左侧，则**变成** $\frac{len}{2}-pos$；若在右侧，则**变成** $pos-\frac{len}{2}$。

还要注意一点，就是**当折痕来到了纸条的两边之后，它的折痕就不会被改变**，所以在这个折痕到达了两边以后就可以**停止程序并返回**现在的正负值。

---

完成所需推导，具体操作就是进行递归模拟折叠过程，其中取反操作即 $\times (-1)$，在返回 $1$ 时就是峰折，$-1$ 就是谷折。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll t , n , cmp , op[105] , k , chat[105];
char x;
ll fnd( ll pos , ll lev , ll opp )
{
	if ( pos == chat[lev - 1] || pos == 0 )	return -opp;
	if ( op[n - lev + 1] )
	{
		if ( pos > chat[lev - 1] )	return fnd( chat[lev] - pos , lev - 1 , -opp );
		else	return fnd( pos , lev - 1 , opp );
	}
	else
	{
		if ( pos < chat[lev - 1] )	return fnd( chat[lev - 1] - pos , lev - 1 , -opp );
		else	return fnd( pos - chat[lev - 1] , lev - 1 , opp );
	}
}
int main()
{
	chat[0] = 1;
	for ( int i = 1; i <= 62; i++ )	chat[i] = chat[i - 1] * 2;
	cin >> t;
	while ( t-- )
	{
		cin >> n >> k;
		for ( int i = 1; i <= n; i++ )	cin >> x , op[i] = x == '1';
		if ( fnd( k , n , 1 ) > 0 )	cout << "Up\n";
		else	cout << "Down\n";
	}
    return 0;
}
```

---

## 作者：zfx_VeXl6 (赞：2)

不难发现，$s_n$ 不会影响最终的结果，进而可以推广到 $s_i$ 不会影响第 $i$ 次折叠后的结果。可以证明第 $i$ 次折叠产生的折痕是峰还是谷只与 $s_{i-1}$ 有关。

考虑第 $i-1$ 次折叠产生的折痕和第 $i$ 次折叠产生的折痕的关系，可以发现，第 $i$ 次折叠产生的折痕数恰好是第 $i-1$ 次折叠产生的折痕数的 $2$ 倍，而且对于每个第 $i-1$ 次折叠产生的折痕，都有 $2$ 个第 $i$ 次折叠产生的折痕与之对应，且恰好分布在该折痕的两侧（以下记为折痕 `l` 和折痕 `r`）。

探究 $s_{i-1}$ 对折痕 `l` 和 `r` 的影响，可以发现：若 $s_{i-1}$ 是 `0`，那么折痕 `l` 和 `r` 分别是峰和谷，若 $s_{i-1}$ 是 `1`，那么折痕 `l` 和 `r` 分别是谷和峰。

现在的问题就转化成对于输入的 $n$ 和 $k$，第 $k$ 次折痕是第几次折叠产生的折痕，以及第 $k$ 次折痕位于上次折叠产生的折痕的左侧还是右侧。

考虑二分，边二分边统计折叠的次数，不难发现之前二分的次数就是折叠的次数。二分时，若 $k<mid$，那么 $k$ 位于左侧，反之亦然。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
LL t, n, k, p, l, r, d;         //要开long long
string s;
int main() {
    cin >> t;
    while (t--) {
        cin >> n >> k >> s;
        p = 0;                  //代表当前的折痕是峰还是谷，峰1谷0，因为第1次折叠产生的折痕是谷，所以初始化为0
        l = 1;
        r = (1LL << n) - 1;
        d = 0;                  //代表当前折叠的次数，但是string的下标从0开始
        while (l <= r) {
            LL mid = (l + r) >> 1;
            if (mid == k) {       //找到了，输出答案
                cout << (p ? "Up\n" : "Down\n");
                break;
            }
            if (k < mid) {        //k<mid，在左侧
                if (s[d] - '0')   //等同于s[d]=='1'
                    p = 0;
                else
                    p = 1;
                d++;
                r = mid - 1;
            }
            else {                //k>mid，在右侧
                if (s[d] - '0')
                    p = 1;
                else
                    p = 0;
                d++;
                l = mid + 1;
            }
        }
    }
    return 0;
}
```

---

## 作者：InterN_NOT_FOUND (赞：1)

首先我们通过自己折纸可以发现这样几个性质：
- 位于正中间的折痕必是谷折。
- 第 $i$ 次折叠会新增 $2^{i-1}$ 条折痕，若这次折叠是从左向右对折，则新增的折痕从左向右依次是峰折、谷折、峰折、谷折 $\cdots$ ，反之亦然。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kqmyzu17.png)

过程和其它情况可以想象一下或自己找个纸折一折。

于是这道题就可以转变成判断这一条折痕在第几次折叠时出现，是新增的第几条折痕即可。

code:

```cpp
#include<bits/stdc++.h>
#define int long long

inline bool isnum(char ch){return ch>='0'&&ch<='9';}
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isnum(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isnum(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

using namespace std;

const int N = 6e1 + 10;

int _2[70] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,
			  33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,
			  137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,
			  70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992,
			  18014398509481984,36028797018963968,72057594037927936,144115188075855872,288230376151711744,576460752303423488,1152921504606846976};
//记录2的次幂来优化时间复杂度			  

int t = read(), a[N];
char s[N];

signed main()
{
	while (t --) {
		int n = read(), k = read();
		
		scanf("%s", s + 1);
		
		int cnt = 0, m = _2[n - 1];
		bool flag;
		
		for (int i = n - 2; m != k; --i) {//判断这条折痕在第几次折叠时出现
			if (m > k) {
				m -= _2[i];
				flag = 0;
			} else {
				m += _2[i];
				flag = 1;
			}
			
			cnt ++;
		}
		//flag = 0说明是新增的第奇数条折痕，反之亦然
		if (cnt == 0) printf("Down\n");//首条折痕必为谷折
		else if ((s[cnt] == '0' && !flag) || (s[cnt] == '1' && flag)) printf("Up\n");//从左向右折新增的第奇数条折痕为峰折，从右向左折新增的第偶数条折痕为峰折
		else printf("Down\n");
	}
	return 0;
}

// ypa!
```

---

## 作者：qfpjm (赞：1)

- 强烈建议用手模拟过程。

- 赛时想了半天，写的时候还出了问题，不过感觉是一道不错的思维题。

# 题解

- 由于 $2^{60}-1$ 不可能用数组开下，因为每一次折叠会把每个部分分成两半，所以我们可以用一种类似于二分方式得到 $k$ 位置的答案。

- 显然，当前操作只会对下一次操作产生影响，但我们可以先把影响处理好。这就需要我们找规律的能力了，经过模拟我们发现，如果当前的操作是 $1$，那么如果 $k$ 后一半，那么这个位置刚好与当前位置相反，$0$ 则是类似的规律。

- 代码比较好写，这里就不放了。

---

## 作者：escapist404 (赞：0)

# P8960 「WHOI-4」A 折纸 题解

## 前面的话

这是一道有趣的模拟题。笔者赛后补题时发现了这个奇怪的做法，因此写出了这篇题解。题解可能比较长，但都是为了严谨地表达做法，请多包含；如有错误，感谢指出。

## 题意简述

* $T$ 次询问，给定整数 $n,k$ 和一个长为 $n$ 的 $\text{01}$ 串 $s$。

* 每次询问，将一张纸按照给定 $\text{01}$ 串的规则对折 $n$ 次。对于第 $i$ 次折叠：

    - 如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；

    - 如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。
    
    - 对折全部是从上方翻。

* 将纸展开，保留折痕。对于从左往右数第 $k$ 条折痕，若向上突起，输出 `Up`；否则输出 `Down`。

* $10 \le t \le 10^5$，$1 \le n \le 60$，$1\le k < 2^n$。

## 样例模拟

转变一下思考的方向，以样例一为例子，我们先来做一次模拟。

由于 $n$ 次对折必然会产生 $2^n - 1$ 条折痕，不妨先自左向右对折痕编号（从 $1$ 开始，即下图中颜色较浅的灰线）。

特别地，为叙述方便，纸条最左边为折痕 $0$，纸条最右边为折痕 $2^n$（即下图中颜色最深的两条黑线）。

![图 1](https://cdn.luogu.com.cn/upload/image_hosting/xjlc0fr7.png)

假设 $k = 3$，我们有：

1. $s_0 = 0$，将纸从左到右对折，使左边对齐右边。显然图上的中线（即这次对折应产生的折痕）为 $4$，由于 $3 < 4$，对折后，编号比 $4$ 大折痕所在的部分不再影响答案计算，直接将其撕去；编号比 $4$ 小的折痕所在的部分此时被翻转倒置，标有数字的一面朝下；

![图 2](https://cdn.luogu.com.cn/upload/image_hosting/4fz3exum.png)

2. $s_1 = 1$，将纸从右到左对折，使右边对齐左边。显然图上的中线（即这次对折应产生的折痕）为 $2$，由于 $3 > 2$，对折后，编号比 $2$ 小的折痕所在的部分不再影响答案计算，直接将其撕去；编号比 $2$ 大的折痕所在的部分此时不动，标有数字的一面仍朝下；

![图 3](https://cdn.luogu.com.cn/upload/image_hosting/50tkk1l9.png)

3. $s_2 = 0$，将纸从左到右对折，使左边对齐右边。显然图上的中线（即这次对折应产生的折痕）为 $3$，此次对折使得 $3$ 处**在展开前**有一条向下突起的折痕。由于每次对折折到的位置均不相同，且无论此次对折的规则为 $0$ 或为 $1$，这次对折应产生的折痕，**在展开纸条以前**，都可看作一条突起方向向下的折痕，**故某一个位置的折痕方向，只和这个位置恰当作折痕来进行对折（即位于这个位置的折痕恰好产生）时，它所在的纸条部分的朝向（向上或向下）有关**。回到这个例子，此时突起方向向下的折痕 $3$ 所在的部分朝下，所以翻转为朝向上时，折痕 $3$ 的突起方向变为向上突起。

据此，从左向右第 $3$ 条折痕向上突起，输出 `UP`。

## 分析归纳

我们从上面这个例子能够发现，只要我们能够判定第 $k$ 条折痕恰好被折（即这条折痕恰好产生）的时候，所在部分的纸面朝向是向上，或是向下，这个问题便迎刃而解。

对于撕去冗余部分的做法，这部分的情况和答案毫无关联，可以果断丢弃。每次处理都舍弃区间的一半，形似二分。

同时纸面的朝向，与以前若干次对折有一定关系，具体体现为：

* 某次对折所形成的折痕，其编号与 $k$ 的大小关系；

* 这次对折对应的 $s_i$；

* 这次对折前的纸面朝向。

在笔者对一张草稿纸进行若干次蹂躏以后，我们归纳如下：

记某次对折前，纸条上编号最小为 $l$，编号最大为 $r$，则中线为 $mid = \dfrac{l + r}{2}$，初始时，令 $l = 0$，$r = 2 ^ n$，做法如下：

* 当某次对折前的纸面朝向上方时（**可以理解为编号从左向右递增**）;

    * 若 $s_i = 0$，**将纸从左到右对折，使左边对齐右边**；
    
        * 若 $k$ 小于此时的中线的编号，即 $k < mid$，$k$ 所在的部分被翻折，**对折后这部分的朝向改变**。撕去冗余部分，令 $r \gets mid$；

        * 若 $k$ 大于此时的中线的编号，即 $k > mid$，$k$ 所在的部分未翻折，**对折后这部分的朝向不变**。撕去冗余部分，令 $l \gets mid$；

    * 若 $s_i = 1$，**将纸从右到左对折，使右边对齐左边**；

        * 若 $k$ 小于此时的中线的编号，即 $k < mid$，$k$ 所在的部分未翻折，**对折后这部分的朝向不变**。撕去冗余部分，令 $r \gets mid$；

        * 若 $k$ 大于此时的中线的编号，即 $k > mid$，$k$ 所在的部分被翻折，**对折后这部分的朝向改变**。撕去冗余部分，令 $l \gets mid$；

* 当某次对折前的纸面朝向下方时（**可以理解为编号从左向右递减**）;

  情况同理，直接归纳。

    * 若 $s_i = 0$；
        * $k < mid$，**朝向不变**。令 $r \gets mid$；
        * $k > mid$，**朝向改变**。令 $l \gets mid$；
    * 若 $s_i = 1$；
        * $k < mid$，**朝向改变**。令 $r \gets mid$；
        * $k > mid$，**朝向不变**。令 $l \gets mid$；

对于边界情况，纸面朝向上方时恰被折叠（$k = mid$），则折痕向下突起；反之，为向上突起。

## 程序实现

多个嵌套语句过于繁杂，考虑寻求简化的表达。

形式化地，记 $f$ 代表纸面朝向，向下为 $1$，向上为 $0$。每次要改变纸面朝向时，可以直接令 $f \gets f \space \textup{xor} \space 1$；记 $t$ 代表 $k$ 和 $mid$ 的大小关系，$k$ 较小时为 $1$，反之为 $0$。

当 $f = 0$ 时，要求 $t = 1,s_i = 0$ 或 $t = 0, s_i = 1$，即 $f \space \textup{xor} \space t \space \textup{xor} \space s_i = 1$ 时要改变 $f$；当 $f = 1$ 时，要求 $t = 0,s_i = 0$ 或 $t = 1, s_i = 1$，即 $f \space \textup{xor} \space t \space \textup{xor} \space s_i = 1$ 时要改变 $f$。

这样，我们摒弃了分类讨论，采用异或来直接实现代码，更为方便。

最坏时间复杂度 $\mathcal{O}(T \cdot \log 2^n)$ 近似为 $\mathcal{O}(T \cdot n)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, T;
unsigned long long k, l, r, mid;
string s;
bool f;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> T;
    while(T--)
    {
        cin >> n >> k;
        cin >> s;
        l = 0, r = (1ll << n);
        f = 0;
        for(int i = 0; i < n; i++)
        {
            mid = (l + r) >> 1;
            if(k == mid)
            {
                if(f)
                    cout << "Up" << endl;
                else
                    cout << "Down" << endl;
                break;
            }
            if(f ^ (k < mid) ^ (s[i] == '1'))
                f ^= 1;
            else
                ;
            if(k > mid)
                l = mid;
            else
                r = mid;
        }
    }
    return 0;
}
```

## 后面的话

这篇题解到这里就结束了。我们从样例的模拟中发现了决定突起方向的几个因素，再对这些因素进行分类讨论，最后用逻辑运算进行简化，从而解决本题。如有勘误，敬请指出。

---

## 作者：LincW (赞：0)

在一张平整的纸上折叠后出现的显然是谷折。

一个折痕被翻过去之后，谷折变为峰折，峰折变为谷折。

用变量 $u$ 表示折痕 $k$ 的状态，$1$ 表示谷折，$0$ 表示峰折。

所以每次折痕 $k$ 被翻过去的时候只是将 $u$ 置为 $\lnot u$ 。

设折完后，折痕把纸条分成 $\mathrm{len}$ 块，这样就有了一个简易的位置系统：将左侧有 $x$ 块的折痕的位置称为 $x$。

考虑模拟折叠过程，维护折痕 $k$ 的位置 $\mathrm{pos}$、最终状态 $u$ 和纸条长度 $\mathrm{len}$。

这里最终状态一词指：如果现在停止遍历串 $s$ （停止折叠操作），仅在折痕 $k$ 的位置上折一道，最后展开后折痕 $k$ 是峰折还是谷折。

因为在未折叠的纸上折叠后出现的是谷折，所以 $u$ 应初始化为 $1$。

纸条最初长度显然是 $2^n$，所以 $\mathrm{len}$ 应初始化为 $2^n$。

$\mathrm{pos}$ 显然应初始化为 $k$ 。

然后开始遍历串 $s$。

对于 $s_i$：

无论 $s_i$ 是从左向右折还是从右向左折，如果 $\frac{\mathrm{len}}2=\mathrm{pos}$，那么结束遍历，因为 $\frac{\mathrm{len}}2$ 显然是这次折叠的折痕位置，也就是说折痕 $k$ 已经被折叠，当前的最终状态 $u$ 即为答案。

剩下的情况分为两种： $s_i=0$ 或 $s_i=1$。这里以前者为例，后者类似。

如果 $\mathrm{pos}<\frac{\mathrm{len}}2$ ，因为从左向右折时（$s_i=0$）翻过去的部分是 $[1,\frac{\mathrm{len}}2)$，所以 $u$ 置为 $\lnot u$。

更新位置：因为折叠后相应的位置是关于折痕轴对称的，所以新的 $\mathrm{pos}\gets |\frac{\mathrm{len}}2-\mathrm{pos}|$

最后更新 $\mathrm{len}$：每次折叠时纸条长度减少至原先的一半 $\mathrm{len} \gets \frac{\mathrm{len}}2$

最后放 AC 代码：

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#include<climits>
#include<cstdio>
#define endl '\n'
#ifdef ONLINE_JUDGE
#define debug(a) ;
#endif
#ifndef ONLINE_JUDGE
#define debug(a) cout<<"Line: "<<__LINE__<<" Function: "<<__FUNCTION__<<" "<<#a<<"="<<(a)<<endl;
#endif
using namespace std;
typedef long long ll;
ll read()
{
	ll res=0;
	int flag=1;
	char c=0;
	while((c>'9' || c<'0') && c!='-')
	{
		c=getchar();
	}
	if(c=='-')
	{
		flag=-1;
		c=getchar();
	}
	while(c<='9' && c>='0')
	{
		res*=10;
		res+=(ll)(c-'0');
		c=getchar();
	}
	return res*flag;
}
ll t,n,k;
string s;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n>>k>>s;
		bool u=1;
		ll pos=k;
		ll len=1;
		for(int i=1;i<=n;++i)
		{
			len*=2;
		}
		for(int i=0;i<s.length();++i)
		{
			if(len/2==pos) break;
			if(s[i]=='0')
			{
				if(pos<len/2) u=!u;
				pos=abs(len/2-pos);
			}
			else
			{
				if(pos>len/2) u=!u;
				pos=len/2-abs(len/2-pos);
			}
			len/=2;
		}
		cout<<(u?"Down":"Up")<<endl;
	}
	return 0;
}
```


---


# [中山市赛 2024/科大国创杯小学组 2023] 六形棋/海克斯

## 题目背景

本题题面为 2024 年中山市赛版本，在输出格式上与 2023 年安徽省科大国创杯小学组略有区别。

## 题目描述

Jimmy 和 Chen 在下一种奇怪的棋，叫做六形棋。

棋盘由 $N \times N$ 个六边形格子构成，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ir3oamly.png)

当棋盘上的两个六边形格子有一条边重合的时候，我们称两个格子是互相连通的。将从上往下第 $i$ 行、从左到右第 $j$ 个格子称为 $(i, j)$。对于一个不在边界上的格子 $(i, j)$，它和 $(i, j + 1)$，$(i, j - 1)$，$(i + 1, j)$，$(i + 1, j - 1)$，$(i - 1, j)$，$(i - 1, j + 1)$ 这 $6$ 个格子互相连通，而边界上的格子只与上述格子中未出界的格子互相连通。

六形棋的游戏规则如下：两人轮流下棋，Jimmy 先手，Jimmy 每次选一个空的格子下一个红色棋子，接下来 Chen 每次选一个空的格子下一个蓝色棋子，依次类推。如果最后 Jimmy 将上下两条红色的边界用红色棋子连通了，那么 Jimmy 胜；相反，如果 Chen 将左右两条蓝色边界用蓝色棋子连通了，那么 Chen 胜。

接下来给出若干个六形棋的棋盘，请你判断每一局是 Jimmy 胜，还是 Chen 胜，还是目前未分出胜负（容易证明，不可能两人都达到获胜条件）。

## 说明/提示

### 样例解释

在第一个棋盘中，不存在将上下边界连通的红色棋子序列，也不存在将左右边界连通蓝色棋子序列，故目前未分出胜负。

在第二个棋盘中，上下两个边界由 $(1, 3),(2, 3),(3, 3),(4, 3)$ 这些红色棋子连通了，所以 Jimmy 获胜了。

在第三个棋盘中，左右两个边界由 $(3, 1),(2, 2),(1, 3),(1, 4)$ 这些蓝色棋子连通了，所以 Chen 获胜了。

### 数据范围

- 对于 $20\%$ 的数据，保证 $1 \leq N \leq 3$。
- 对于另外 $40\%$ 的数据，保证给出的棋局已经分出胜负。
- 对于 $100\%$ 的数据，保证 $1 \leq T \leq 10$，$1 \leq N \leq 100$。

## 样例 #1

### 输入

```
3
4
0 1 0 -1
0 -1 1 0
-1 -1 1 0
0 0 1 0
4
0 1 1 -1
0 -1 1 0
-1 -1 1 0
0 0 1 0
4
0 1 -1 -1
0 -1 1 1
-1 -1 1 0
0 0 1 0```

### 输出

```
yet
Jimmy
Chen```

# 题解

## 作者：MingDynasty_xiaohao2 (赞：5)

## 这道题很简单其实就是 BFS 模版题。

### 这道题和普通五子棋的区别：

1. 这道题的方向可以变化（但要确保是往指定方向），而普通五子棋方向无法变化。
2. 这道题获胜要求也不一样，Jimmy 将上下两条红色的边界用红色棋子连通了，那么 Jimmy 胜；如果 Chen 将左右两条蓝色边界用蓝色棋子连通了，那么 Chen 胜。

## 解题思路：
可以定义两个广度优先搜索。

一个用来判断行是否连接。
一个用来判断列是否连接。

再加判断来最后输出即可 AC。

**建议：** 可以使用方向数组（~~谁都知道~~）。  
**注意**（~~作者也是错了 n 次~~）**：**  
1. 标记数组清零。  
2. 用于 BFS 的队列记得清空。  

~~此题就不再给代码了，因为实在和模版太像了。~~

---

## 作者：tanruiqing (赞：3)

### 题目大意：

给你一个面积为 $n^2$ 的矩阵、且只有 $-1,0,1$ 构成。让你求有没有从左边界到右边界或者从上边界到下边界的**连通块**，如果从左边界到右边界的有，就输出 `Jimmy`，如果有从上边界到下边界的，就输出 `Chen`，否则输出无解 `yet`。

### 解题思路：

这道题我们可以遍历第一行，如果有一个数字为 $1$，就 BFS 一遍，看是不是可以联通到第 $n$ 行，能就可以直接输出 `Jimmy`。如果没有符合要求的，就遍历第一列，如果有一个数字为 $-1$，就 BFS 一遍，看是不是可以联通到第 $n$ 列，能就可以直接输出 `Chen`。如果以上两种情况都没有的话，就输出 `yet`。

### 注意事项：

- BFS 的 vis 数组记得归零。
- BFS 的队列记得全部弹出（我就在这里卡了一天 555）。

### AC 代码：

[AC记录](https://www.luogu.com.cn/record/205141411)。

```cpp
/*
* name:tanruiqing
*/
#include<bits/stdc++.h>
// #define int long long
using namespace std;
const int id[10][10] = {{0,0},{0,1},{0,-1},{1,0},{1,-1},{-1,0},{-1,1}};
//方向数组。
int n,m;
int ch[1005][1005]; 
//ch是棋盘，vis是BFS时的标记数组。
bool vis[1005][1005];
struct node{
	int x,y;
};
queue<node> q;
//队列。

bool bfs(int x,int y){
    while(!q.empty())q.pop();//必须清零，不然从下一次开始的时候，如果队列里面还有数但是从这里走不到那里，BFS就会去续下去。
	q.push({x,y});
	vis[x][y] = 1;
	while(!q.empty()){
		int x = q.front().x,y = q.front().y;
		q.pop();
		if(x == n){//如果可以到达第n行。
			return true;//返回true。
		}
		for(int i = 1 ; i <= 6 ; i++){
			int dx = x + id[i][0];
			int dy = y + id[i][1];
			if(dx > 0 && dx <= n && dy > 0 && dy <= m && vis[dx][dy] == 0 && ch[dx][dy] == 1){
				vis[dx][dy] = 1;
				q.push({dx,dy});//枚举6给方向，如果可以，就加入队列。
			}
		}
	}
	return false;//否则不可以达到，就返回false。
}

bool bfs2(int x,int y){//和上面几乎一样。
    while(!q.empty())q.pop();
	q.push({x,y});
	vis[x][y] = 1;
	while(!q.empty()){
		int x = q.front().x,y = q.front().y;
		q.pop();
		if(y == n){
			return true;
		}
		for(int i = 1 ; i <= 6 ; i++){
			int dx = x + id[i][0];
			int dy = y + id[i][1];
			if(dx > 0 && dx <= n && dy > 0 && dy <= m && vis[dx][dy] == 0 && ch[dx][dy] == -1){
				vis[dx][dy] = 1;
				q.push({dx,dy});
			}
		}
	}
	return false;
}

int main(){
	int t;
	cin >> t;
	while(t--){
		bool x = 1;//判断有没有解的变量。
		cin >> n;m = n;//这里因为题目给的是n*n的矩阵，但是因为我写n*m的矩阵BFS题写多了，所以就用m=n，以防写错。
		for(int i = 1 ; i <= n ; i++){
			for(int j = 1 ; j <= m ; j++){
				cin >> ch[i][j];
			}
		}
    //输入。
      for(int i = 1 ; i <= n ; i++){
			if(ch[1][i] == 1){//遍历第一行。
				memset(vis , 0 , sizeof vis);//记得清零。
				if(bfs(1,i) == 1){
					cout << "Jimmy\n";//如果可以达到，就输出。
					x = 0;
					break;
				}
			}
		}
		if(x == 1){//如果还没有解。
			for(int i = 1 ; i <= n ; i++){
				if(ch[i][1] == -1){
					memset(vis , 0 , sizeof vis);
					if(bfs2(i,1) == 1){//道理同上。
						cout << "Chen\n";
						x = 0;
						break;
					}
				}
			}
		}
		if(x){//无解情况，输出yet。
			cout << "yet\n";
		}
	}
	return 0;
}
```

---

## 作者：_lxc__ (赞：2)

很典的宽搜。

定义两个宽搜，分别判断两个人是否获胜，如果都没获胜则输出 `yet`。

BFS 过程：

* 遍历行，看是否能联通到第 $n$ 行（判断先手是否胜利）。

* 遍历列，看是否能联通到第 $n$ 列（判断后手是否胜利）。

其实 BFS 和模板没什么区别，无非就是要判断当前格子为 $1$ 或 $-1$ 即可。

可得时间复杂度不会超过 $O(T\times N^2)$。

这题还有两个坑点：

* 标记数组清零。

* 用于 BFS 的队列记得清空。

---

## 作者：AnotherDream (赞：2)

# [B4186](https://www.luogu.com.cn/problem/B4186) 题解
## 题意简述
给你一个 $n\times n$ 的矩阵，判断有没有从上到下或从左到右的连通块。
## 思路
注意到 $N\leq100$，直接暴力搜索。

对于每一个等于 $1$ 的最左端的点和每一个等于 $-1$ 的最上端的点进行搜索，判断是否连通。
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int T,n,a[N][N],vis[N][N];
bool flg;
int dx[]={0,0,0,1,1,-1,-1},dy[]={0,1,-1,0,-1,0,1};
void dfs1(int x,int y) {
	vis[x][y]=1;
	if(x==n) {
		flg=1;//到达下边界
		return;
	}
	for(int i=1;i<=6;i++) {
		int nx=x+dx[i],ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=n) {
			if(!vis[nx][ny]) {
				if(a[nx][ny]==1) dfs1(nx,ny);
			}
		}
	}
}
void dfs2(int x,int y) {
	vis[x][y]=1;
	if(y==n) {//到达右边界
		flg=1;
		return;
	}
	for(int i=1;i<=6;i++) {
		int nx=x+dx[i],ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=n) {
			if(!vis[nx][ny]) {
				if(a[nx][ny]==-1) dfs2(nx,ny);
			}
		}
	}
}
inline void solve() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=n;j++) {
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++) {
		if(a[1][i]==1) {
			memset(vis,0,sizeof(vis));//清空vis
			flg=0;
			dfs1(1,i);
			if(flg) {
				cout<<"Jimmy\n";
				return;
			}
		} 
	} 
	for(int i=1;i<=n;i++) {
		if(a[i][1]==-1) {
			memset(vis,0,sizeof(vis));//清空vis
			flg=0;
			dfs2(i,1);
			if(flg) {
				cout<<"Chen\n";
				return;
			}
		} 
	} 
	cout<<"yet\n"; 
	return; 
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>T;
	while(T--) { 
		solve();
	}
	return 0;
} 
```

---

## 作者：All_Wrong_Answer (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4186)

## 题目大意：

给出一个 $N \times N$ 的六形棋的局面，判断是否有一方获胜，六形棋的规则可以参考原体面。

## 思路：

由于 $N$ 和 $T$ 都比较小，所以考虑暴力判断某一方是否获胜。

先通过 ```vector``` 记录出发点上的棋子，再进行 BFS，看看是否能联通。

由于这是一个二维的棋盘，所以考虑使用二元组 ```pair<int,int>``` 进行储存，使用 ```make_pair()``` 函数进行处理，用 ```first``` 访问二元组第一个元素，```second``` 访问二元组第二个元素。

注意一些细节和小技巧：

- 本题多测，```vector``` 记得清空。
- 函数中的布尔类型需要初始化。
- 可以打表出前进的方向。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
int x;
int m[105][105];
vector<pair<int,int> >cs1;
vector<pair<int,int> >cs2;
int db[7][3]={{0,0,0},{0,0,1},{0,1,0},{0,0,-1},{0,-1,0},{0,1,-1},{0,-1,1}};//打表 
bool checker1(){
	bool f[105][105];
	for(int i=1;i<=100;i++){
		for(int j=1;j<=100;j++){
			f[i][j]=false;
		}
	} //初始化
	queue<pair<int,int> >q;
	for(int i=0;i<cs1.size();i++){
		q.push(cs1[i]);
	}
	while(!q.empty()){
		int mqx=q.front().first;
		int mqy=q.front().second;
		q.pop();
		if(mqx==x) return true;
		if(f[mqx][mqy]==true) continue;
		f[mqx][mqy]=true;
		for(int i=1;i<=6;i++){
			int u1=mqx+db[i][1];
			int u2=mqy+db[i][2];
			if(u1>0&&u2>0&&u1<=x&&u2<=x){
				if(m[u1][u2]==1) q.push(make_pair(u1,u2));
			} 
		}
	}//BFS
	return false;
}
bool checker2(){
	bool f[105][105];
	for(int i=1;i<=100;i++){
		for(int j=1;j<=100;j++){
			f[i][j]=false;
		}
	} //初始化 
	queue<pair<int,int> >q;
	for(int i=0;i<cs2.size();i++){
		q.push(cs2[i]);
	}
	while(!q.empty()){
		int mqx=q.front().first;
		int mqy=q.front().second;
		q.pop();
		if(mqy==x) return true;
		if(f[mqx][mqy]==true) continue;
		f[mqx][mqy]=true;
		for(int i=1;i<=6;i++){
			int u1=mqx+db[i][1];
			int u2=mqy+db[i][2];
			if(u1>0&&u2>0&&u1<=x&&u2<=x){
				if(m[u1][u2]==-1) q.push(make_pair(u1,u2));
			} 
		}
	}//BFS
	return false;
}
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>x;
		cs1.clear();
		cs2.clear();//多测清空 
		for(int j=1;j<=x;j++){
			for(int k=1;k<=x;k++){
				scanf("%d",&m[j][k]);
				if(j==1&&m[j][k]==1) cs1.push_back(make_pair(j,k));
				if(k==1&&m[j][k]==-1) cs2.push_back(make_pair(j,k));
			}
		}
		if(checker1()==true) cout<<"Jimmy\n";
		else if(checker2()==true) cout<<"Chen\n";
		else cout<<"yet\n";
	}
	return 0;
}

```
[通过记录](https://www.luogu.com.cn/record/207652970)

---

## 作者：Charged_Charge (赞：1)

# 洛谷 B4186
## 题意说明
这是一道连通块的 BFS，比较接近模板题。题目的具体意思就是：给定一个矩阵，判断谁能先把自己所对应的两个底边连接起来。
### 代码实现思路：
打两个广搜，第一个搜索第一个人的任务，第二个搜索第二个人的任务，最后把搜索结果进行判断即可。
### 代码实现细节：
- 因为是第一个人先手，所以，定义一个函数，如果第一个人能完成任务，就不必再搜第二个人的任务了。
- 因为和一个六边形相邻的六边形最多有六个，所以，方向数组要有六个元素。
- 每一次搜索都要在内部定义队列，并在下一次搜索前清空标记数组。
#### AC 代码与 AC 记录：
[代码在这里](https://www.luogu.com.cn/article/zzktdjx9)

[记录在这里](https://www.luogu.com.cn/record/219472423)

---

## 作者：jur10n (赞：1)

## Background

算法：广度优先搜索。

几乎是广搜模板题，没有任何别的什么处理。

至于题目的六边形设定，直接把六个边对应的邻点当做可以扩展的位置，然后**当做矩形做**即可。

## Solution

1. 先存图，然后依次遍历第一行、第一列，若找到对应人的棋子，就以这个起点开始广搜。

2. 广搜扩展时，若当前格子为自己的棋子，那么可以更新，入队；否则当做障碍，不可更新，跳过。

3. 对于每个从队列里面取出的点，直接看是否到了对应的边界，若到了直接返回结果即可，因为题中说了结果唯一。

## Code

细节可以看代码。

由于范围不大，直接写临时变量，省的忘记清空。

扩展中的坐标加减情况写常量数组。

```cpp
#include<bits/stdc++.h>
#define N 105
using namespace std;

class Quick_IO
{
  public:
	template<typename T>
	void read(T &r)
	{
		T x = 0, f = 1;
		char ch = getchar();
		while (ch < '0' || ch > '9')
		{
			if (ch == '-') f = -1;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
		r = x * f;
	}
	template<typename T, typename... Args>
	void read(T &tmp, Args &... tmps)
	{
		read(tmp);
		read(tmps...);
	}
} io;

const int mx[7] = {0, 0, 0, 1, 1, -1, -1};
const int my[7] = {0, 1, -1, 0, -1, 0, 1};
int G[N][N];
int T, n;
struct node
{
	int x, y;
};

bool INRANGE(int x, int y)
{
	return (x >= 1 && y >= 1 && x <= n && y <= n);
}

bool BFS(int sx, int sy, bool is_Jimmy)	//起始位置，是否是吉米
{
	bool vis[N][N] = {};	//由于范围不大，直接写临时变量，省的清空
	queue<node> Q;
	Q.push({sx, sy});
	vis[sx][sy] = 1;	//标记走过

	while (Q.size())	//BFS
	{
		int ux = Q.front().x, uy = Q.front().y;
		Q.pop();

		if (is_Jimmy && ux == n) return 1;	//检查是否到终点
		if (!is_Jimmy && uy == n) return 1;

		for (int i = 1, vx, vy; i <= 6; i++)
		{
			vx = ux + mx[i], vy = uy + my[i];
			if (!vis[vx][vy] && G[vx][vy] == (is_Jimmy ? 1 : -1) && INRANGE(vx, vy))
			{
				vis[vx][vy] = 1;
				Q.push({vx, vy});
			}
		}
	}
	return 0;
}

string Solve()	//每一轮的处理
{
	for (int i = 1; i <= n; i++)
	{
		if (G[1][i] == 1) if (BFS(1, i, 1)) return "Jimmy";
		if (G[i][1] == -1) if (BFS(i, 1, 0)) return "Chen";
	}
	return "yet";
}

signed main()
{
	io.read(T);
	while (T--)
	{
		memset(G, 0, sizeof G);	//多测清空
		io.read(n);
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) io.read(G[i][j]);
		cout << Solve() << "\n";
	}
}
```

---

## 作者：TJB_LHY (赞：0)

## 形象化题意

给定一个 $N\times N$ 的正方形矩阵 $A$，其中 $A_{i,j}$ 有三种情况：$1$，$-1$，$0$。且 $A_{i,j}$ 与 $A_{i-1,j}$、$A_{i-1,j+1}$、$A_{i,j-1}$、$A_{i,j-1}$、$A_{i+1,j-1}$、$A_{i+1,j}$ 相邻（出界的不算）。若有一串值为 $1$ 的 $A_{i,j}$ 相邻，且触碰上下边界，则输出： Jimmy； 反之若有一串值为 $-1$ 的 $A_{i,j}$ 相邻，且触碰左右边界，则输出： Chen；否则输出 yet。~~出题人的思想我们不懂。~~

# 思路

一道广搜~~模板~~题。先看数据范围：$1\le T\le 10$，$1\le N\le 100$。很小，~~应该不难~~，可以直接暴力做。本蒟蒻在这里提供思路：因为题目中说明

> …… 请你判断每一局是 Jimmy 胜，还是 Chen 胜，还是目前未分出胜负（容易证明，不可能两人都达到获胜条件）。

所以我们判定一人获胜后即可退出。我们先将上边线上的数字 $1$ 入队进行广搜，搜到下边线时输出 **Jimmy**；反之，先将左边线上的数字 $-1$ 入队进行广搜，搜到右边线时输出 **Chen**；否则输出 **yet**（人名首字母大写！！！）。本题难点在于对细节的处理，大家需要多注意！！！

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
struct xy{
    int x,y;
}u,v;
int n,a[105][105];
int dx[6]={1,0,-1,1,-1,0};
int dy[6]={-1,-1,0,0,1,1};//细节1：方向数组与以往不同
bool check(xy v){
    if(v.x<1)return 0;
    if(v.y<1)return 0;
    if(v.x>n)return 0;
    if(v.y>n)return 0;
    return 1;
}//判断是否出界
bool vis[105][105];//标记
string bfs(){
    queue<xy>Q;
    memset(vis,0,sizeof vis);//细节2：多测要清空
    for(int i=1;i<=n;i++)if(a[1][i]==1){
        Q.push({1,i});//入队
        vis[1][i]=1;
    }
    while(Q.size()){
        u=Q.front();
        if(u.x==n)return "Jimmy\n";//返回
        Q.pop();
        for(int i=0;i<6;i++){
            v={u.x+dx[i],u.y+dy[i]};
            if(!check(v))continue;
            if(vis[v.x][v.y] || a[v.x][v.y]!=1)continue;//走法不合法，踢掉
            vis[v.x][v.y]=1;
            Q.push(v);
        }
    }
    for(int i=1;i<=n;i++)if(a[i][1]==-1){
        Q.push({i,1});
        vis[i][1]=1;
    }//同上
    while(Q.size()){
        u=Q.front();
        if(u.y==n)return "Chen\n";//细节3：左右边界和上下边界不一样
        Q.pop();
        for(int i=0;i<6;i++){
            v={u.x+dx[i],u.y+dy[i]};
            if(!check(v))continue;
            if(vis[v.x][v.y] || a[v.x][v.y]!=-1)continue;
            vis[v.x][v.y]=1;
            Q.push(v);
        }
    }
    return "yet\n";//返回
}
int main() {
    int t;
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>a[i][j];//输入
        cout<<bfs();//输出
    }
	return 0;
}
```

完结撒花！求通过！

---

## 作者：PDAFX (赞：0)

## 前言

本人参加了中山市赛，[T6](https://www.luogu.com.cn/problem/B4187) 当时考场上不会写链式前向星，本想骗暴力，结果爆零，[T5](https://www.luogu.com.cn/problem/B4186) 场切。

## 题解

给你一个六边形构成的矩阵，求连通块。

看数据范围，$T\le10$，$n\le100$，直接上 BFS 没问题。

注意点：

1\. 注意有六个方向，不要漏。

2\. 从边角开始爆搜，由于方向较多，所以建议方向数组。

3\. 多测不清空，爆零两行泪。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[100001][3],T,n,a[1001][1001],h,t,vis[1001][1001],flag,dx[7]={0,0,0,1,1,-1,-1},dy[7]={0,1,-1,0,-1,0,1};
int bfs(int x,int y)
{
	h=1,t=1;
	memset(vis,0,sizeof(vis));
	memset(q,0,sizeof(q));
	q[h][1]=x;
	q[h][2]=y;
	int tx,ty;
	if(x==0)
	{
		tx=n+1;
		ty=-1;
	}
	if(x==n+1)
	{
		tx=0;
		ty=-1;
	}
	if(y==0)	
	{
		ty=n+1;
		tx=-1;
	}
	if(y==n+1)
	{
		ty=0;
		tx=-1;
	}
	vis[x][y]=1;
	while(h<=t)
	{
		for(int i=1;i<=6;i++)
		{
			int xx=q[h][1]+dx[i];
			int yy=q[h][2]+dy[i];
			if(tx==0||tx==n+1)
			{
				if(xx>=0&&xx<=n+1&&yy>=0&&yy<=n+1&&a[xx][yy]==1&&!vis[xx][yy])
				{
					t++;
					q[t][1]=xx;
					q[t][2]=yy;
					vis[xx][yy]=1;
					if(xx==tx)
					{
						return 1;
					}
				}
			}
			if(ty==0||ty==n+1)
			{
				if(xx>=0&&xx<=n+1&&yy>=0&&yy<=n+1&&a[xx][yy]==-1&&!vis[xx][yy])
				{
					t++;
					q[t][1]=xx;
					q[t][2]=yy;
					vis[xx][yy]=1;
					if(yy==ty)
					{
						return 1;
					}
				}
			}
		}
		h++;
	}
	return 0;
}
int main()
{
	cin>>T;
	while(T--)
	{
		memset(a,0,sizeof(a));
		flag=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				cin>>a[i][j];
			}
		}
		for(int i=0;i<=n+1;i++)
		{
			a[0][i]=1;
			if(bfs(0,i)&&!flag)
			{
				cout<<"Jimmy"<<endl;
				flag=1;
			}
		}
		for(int i=0;i<=n+1;i++)
		{
			a[n+1][i]=1;
			if(bfs(n+1,i)&&!flag)
			{
				cout<<"Jimmy"<<endl;
				flag=1;
			}
		}
		for(int i=0;i<=n+1;i++)
		{
			a[i][0]=-1;
			if(bfs(i,0)&&!flag)
			{
				cout<<"Chen"<<endl;
				flag=1;
			}
		}
		for(int i=0;i<=n+1;i++)
		{
			a[i][n+1]=-1;
			if(bfs(i,n+1)&&!flag)
			{
				cout<<"Chen"<<endl;
				flag=1;
			}
		}
		if(!flag)
		{
			cout<<"yet"<<endl;
		}
	}
}
```

---

## 作者：ylzpl (赞：0)

这题很水，但是我看了老半天才看出了点什么。  
前言：这题的题解咋互相抄啊，都是 $2$ 个搜索函数，一个就可以了啊，只需要增加人物名即可，方便判断是否符合要求。

解题思路：
- 首先，我们需要确定思路方向。我们看到这种数据规模较小，就应该确定时间复杂度，大概可以是双重循环。那么，细看题目，我们就可以确定本题是一个搜索路径题，且要求最短路径，那么，我们考虑广度优先搜索。
- 题目让我们干啥？题目会给我们一盘棋，看当前第一人是否获胜，第二个人是否获胜。
- 然后，我们需要确定的是起点以及终点。那么，我们来看图：![https://cdn.luogu.com.cn/upload/image_hosting/ir3oamly.png](https://cdn.luogu.com.cn/upload/image_hosting/ir3oamly.png)
只有第一个人联通上下两行且先联通，他才获胜。所以我们只需要考虑搜第一行。为啥捏？这里我们详细解释：首先第一个人的胜利条件是第一行后第 $n$ 行联通。那么，我们只要找到路径。所以我们的目标就是找到路径，和起点没有太大关系，甚至可以从中间往两边搜索。接下来是终点。对于第一个人而言，我们只需要从第 $1$ 行走到第 $n$ 行即可。对于第二个人，我们需要从第 $1$ 列走到第 $n$ 列即可。注意：行和列是不一样的。

确定了这些，我们解下来的重点就是如何搜索。
- 可以往哪些地方搜。首先，我们不能越界，我们可以做的是从 $(i,j)$ 走到 $(i, j + 1)$，$(i, j - 1)$，$(i + 1, j)$，$(i + 1, j - 1)$，$(i - 1, j)$，$(i - 1, j + 1)$。所以，根据 $i,j$ 两个数的变化情况，我们可以得出方向数组，按照顺序搜这几个点。
- 搜的条件是什么。对于你要走到的点 $(x,y)$。首先他不能越界且没走过。其次，他得有自己的棋，不然你搜了也没有，又不是你的棋。
- 结束条件。如果是第一个人在搜索，我们只需要看 $x=n$ 即可，对于第二个人，我们需要看的是 $y=n$。
- 我们尽量采用广度优先搜索，因为它省时间。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=105;
struct node{
	int x,y;
};
int T;
int a[maxn][maxn];
bool vis[maxn][maxn];
int dx[]={0,0,1,1,-1,-1};
int dy[]={1,-1,0,-1,0,1};
int n;
void solve(){
	for(int i=1;i<maxn;i++){
		for(int j=1;j<maxn;j++){
			vis[i][j]=false;
		}
	}
	return ;
}
bool check(int x,int y){
	if(x<1||x>n||y<1||y>n){
		return true;
	}
	if(vis[x][y]){
		return true;
	}
	return false;
} 
bool bfs(int posx,int posy,string name){//name是名字，看是哪一个人，不同人的终点和走到的点的要求不同
	solve(); //多测不清空，爆0两行泪
	vis[posx][posy]=true;
	queue<node>q;
	q.push({posx,posy});
	while(!q.empty()){
		node t=q.front();
		q.pop();
		if(name=="Jimmy"&&t.x==n){
			return true;
		}
		if(name=="Chen"&&t.y==n){
			return true;
		}
		for(int i=0;i<6;i++){
      //计算需要走到的格子
			int nx=dx[i]+t.x;
			int ny=dy[i]+t.y;
			if(check(nx,ny)){//如果这个格子不合法（上述），就跳过
				continue;
			}
//走到的格子必须与你的棋子的颜色相同
			bool flag=false;
			if(name=="Jimmy"){
				if(a[nx][ny]==1){
					flag=true;
				}
			}
			if(name=="Chen"){
				if(a[nx][ny]==-1){
					flag=true;
				}
			}
			if(flag==false){
				continue;
			}
			vis[nx][ny]=true;
			q.push({nx,ny});
		}
	}
	return false;
} 
void work(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			vis[i][j]=false;
		}
	}
	for(int i=1;i<=n;i++){//搜索第1行
		if(a[1][i]==1){
			if(bfs(1,i,"Jimmy")==false){
				continue;
			}
			cout<<"Jimmy\n";
			return ;
		}
	}
	for(int i=1;i<=n;i++){//搜索第一列
		if(a[i][1]==-1){
			if(bfs(i,1,"Chen")==false){
				continue;
			}
			cout<<"Chen\n";
			return ;
		}
	}
	cout<<"yet\n";//未分出胜负
	return ;
}
signed main(){
	cin>>T;
	while(T--){
		work();
	}
	return 0;
} 
```
本篇题解是目前最详细的一篇，如果其它的题解看不懂，可以看这一篇，本篇制作不易，希望能给大家帮助。

---

## 作者：Hog_Dawa_IOI (赞：0)

作为去年的场内选手，本人在本题获得了 $80$ 分（还是 $60$ 分）的好成绩。那时候的我连绿题都无法场切（现在也是）。    

题意：一个“六形棋”的棋盘，小 A 和小 B 在上面下棋。小 A 先下一步棋，棋子为红色（用 $1$ 表示），接着小 B 下一步棋，棋子为蓝色（用 $-1$ 表示）。如果小 A 用红色棋子把上下两条边连通，则小 A 赢；如果小 B 用蓝色棋子把左右两条边连通，则小 A 赢；现在给你这个棋盘的状态（空格用 $0$ 表示），问现在是小 A 赢了，还是小 B 赢了，还是没有人赢。    

一个简单的 BFS，按照题意模拟即可。    
由于有两种情况（上下连通和左右连通），我们跑两次 BFS。    
就和在普通棋盘上 BFS 一样，从一个点 $(i,j)$ 可以走到 $(i,j+1),(i,j−1),(i+1,j),(i+1,j−1),(i−1,j),(i−1,j+1) $。    
需要注意起点，在第一行的每一个颜色为 $1$ 的点都可以成为起点，同时只要到达最后一行就可以认为上下已经连通；判断左右连通时同理。     
由于路径要横跨（竖跨）整个棋盘，所以不可能同时出现上下、左右都连通的情况，否则它们必定会有一个交点，而这个交点我们就不知道是什么颜色，产生矛盾。

**有一个特殊情况：当棋盘大小为 $1$ 的时候，在中间放了一枚棋子，那么上下左右都会被连通。这个在某些写法下是需要特判的。**    
~~本人就是在这个地方没特判挂了 $20$ 分。~~    
```cpp
#include<stdio.h>
int t,n,s[105][105];
int que[10005][3],l,r,f[105][105];
int fx[10][2]={{0,1},{0,-1},{1,0},{1,-1},{-1,0},{-1,1}};
int main()
{
    scanf("%d",&t);while(t--)
    {
        scanf("%d",&n),l=r=0;for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++) scanf("%d",&s[i][j]),f[i][j]=0;
        if(n==1)
        {
        	if(s[1][1]==1) printf("Jimmy\n");
        	else if(s[1][1]==-1) printf("Chen\n");
        	else printf("yet\n");continue;
		}
        for(int i=1;i<=n;i++) if(s[1][i]==1)
		que[++r][1]=1,que[r][2]=i,f[1][i]=1;
        bool ff=0;while(l<r)
        {
            l++;for(int i=0;i<6;i++)
            {
                int xx=que[l][1]+fx[i][0],yy=que[l][2]+fx[i][1];
                if(xx<1||xx>n||yy<1||yy>n) continue;
                if(f[xx][yy]||s[xx][yy]!=1) continue;
                f[xx][yy]=1,que[++r][1]=xx,que[r][2]=yy;
                if(xx==n){printf("Jimmy\n"),ff=1;break;}
            }if(ff) break;
        }if(ff) continue;l=r=0;
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) f[i][j]=0;
		for(int i=1;i<=n;i++) if(s[i][1]==-1)
		que[++r][1]=i,que[r][2]=1,f[i][1]=1;
        while(l<r)
        {
            l++;for(int i=0;i<6;i++)
            {
                int xx=que[l][1]+fx[i][0],yy=que[l][2]+fx[i][1];
                if(xx<1||xx>n||yy<1||yy>n) continue;
                if(f[xx][yy]||s[xx][yy]!=-1) continue;
                f[xx][yy]=1,que[++r][1]=xx,que[r][2]=yy;
                if(yy==n){printf("Chen\n"),ff=1;break;}
            }if(ff) break;
        }if(!ff) printf("yet\n");
    }
}
```

---

## 作者：CSPAKhehe (赞：0)

## 题意

给你一个 $$n$$ $\times$ $$n$$ 的矩阵，如果 Jimmy 已经从第一行走到了第 $$n$$ 行则输出 Jimmy，如果 Chen 已经从第一列走到了第 $$n$$ 列则输出 Chen，如果都不成立则输出 yet。

## 思路

我们会发现这题和迷宫很像，思路也差不多，
和迷宫的区别就是：~~迷宫是判断这个点能不能走，这题是判断是否使我们想要的颜色。~~ 

**其实就是 BFS 的例题**

此外两个题的共同点都是要判断这条路有没有走过。

## 代码


```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[110][110],q[10010][3];  //q队列 
int tx,ty,head,tail,t,n,f[110][110]; //f标记 
int fx[6]={0,0,1,1,-1,-1};
int fy[6]={1,-1,0,-1,0,1};
bool check(int x,int y){
	if(x>=1&&x<=n&&y>=1&&y<=n) return 1;
	else return 0;
} 
bool bfs_ke(int x,int y){
	head=1,tail=1;
    memset(f,0,sizeof(f));//初始化
    q[1][0]=x,q[1][1]=y;
    while(head<=tail){
        for(int j=0;j<6;j++){
            tx=q[head][0]+fx[j];
            ty=q[head][1]+fy[j];
            if(check(tx,ty)&&a[tx][ty]==1&&f[tx][ty]==0) {//满足条件           
                f[tx][ty]=1;
                tail++;
                q[tail][0]=tx;
                q[tail][1]=ty;
                if(tx==n){//如果到最后一行                
                    return true;
                }
            }
        }
        head++;
    }
    return false;
} 
bool bfs_do(int x,int y){
	head=1,tail=1;
    memset(f,0,sizeof(f));//初始化
    q[1][0]=x,q[1][1]=y;
    while(head<=tail){
        for(int j=0;j<6;j++){
            tx=q[head][0]+fx[j];
            ty=q[head][1]+fy[j];
            if(check(tx,ty)&&a[tx][ty]==-1&&f[tx][ty]==0){//满足条件            
                f[tx][ty]=1;
                tail++;
                q[tail][0]=tx;
                q[tail][1]=ty;
                if(ty==n){//如果到最后一列                
                    return true;
                }
            }
        }
        head++;
    }
    return false;
} 
int main(){
	cin>>t;
    while(t--){
        cin>>n;
        int flag=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                cin>>a[i][j];
            }
        if(n==1){   //只有一个格子做下特判        
            if(a[1][1]==1)cout<<"Jimmy";
            else if(a[1][1]==0)cout<<"yet";
            else cout<<"Chen";
            cout<<endl;
            continue;
        }
        //左右连通
        for(int i=1;i<=n;i++){
            if(a[i][1]==-1){
                if(bfs_do(i,1)){
                    cout<<"Chen";
                    flag=1;
                    break;
                }
            }
        }
        if(!flag){          
		    //上下连通  
            for(int j=1;j<=n;j++){
                if(a[1][j]==1){
                    if(bfs_ke(1,j)){
                        cout<<"Jimmy";
                        flag=1;
                        break;
                    }
                }
            }
        }
        if(!flag){
            cout<<"yet";
        }
        cout<<"\n";
    }
	return 0;
}
```

**九十多行的代码...**

---

## 作者：Tdr1017 (赞：0)

## 题意

给你一个 $$n$$ $\times$ $$n$$ 的矩阵，如果 Jimmy 已经从第一行走到了第 $$n$$ 行则输出 Jimmy，如果 Chen 已经从第一列走到了第 $$n$$ 列则输出 Chen，如果都不成立则输出 yet。

## 思路

我们会发现这题和迷宫很像，思路也差不多，但这个要有两个 dfs 函数，因为小可可和小多都要判断一次。
和迷宫的区别就是：迷宫是判断这个点能不能走，这题是判断是否使我们想要的颜色。

此外两个题的共同点都是要判断这条路有没有走过。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[6]={0,0,1,1,-1,-1};
int dy[6]={1,-1,0,-1,0,1};
bool f[105][105];
int a[105][105],n;
bool flag; 
void dfs1(int x,int y){
	if(a[x][y]!=1) return;
    if(x==n){
        if(a[x][y]==1) flag=1;
        return;
    }
	for(int i=0;i<6;i++){
		if(flag==1) break;
		x=x+dx[i];y=y+dy[i];
		if(f[x][y]==0&&a[x][y]==1&&x>=1&&x<=n&&y>=1&&y<=n){
			f[x][y]=1;
			dfs1(x,y);
		}
		x=x-dx[i];
		y=y-dy[i];
	}
}
void dfs2(int x,int y){
	if(a[x][y]!=-1) return;
    if(y==n){
        if(a[x][y]==-1) flag=1;
        return ;
    }
	for(int i=0;i<6;i++){
		if(flag==1) break;
		x=x+dx[i];
		y=y+dy[i];
		if(f[x][y]==0&&a[x][y]==-1){
			f[x][y]=1;
			dfs2(x,y);
		}
		x=x-dx[i];
		y=y-dy[i];
	}
}
int main(){
	int t; 
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				scanf("%d",&a[i][j]);
			}
		}
		flag=0;
		memset(f,0,sizeof(f));
		for(int i=1;i<=n;i++){
			dfs1(1,i);
			if(flag==1){
				cout<<"Jimmy"<<endl;
				break;
			}
		}
		if(flag==1) continue;
		memset(f,0,sizeof(f));
			for(int i=1;i<=n;i++){
				dfs2(i,1);
				if(flag==1){
					cout<<"Chen"<<endl; 
					break;
				}
			}
		if(flag==0) cout<<"yet"<<endl;
	}
	return 0;
}
```

**代码有点长...**

---

## 作者：haobao123456 (赞：0)

我写代码花了 $2$ 个小时，调试花了 $1$ 个小时 QWQ ......
# 思路：
可以用两个 BFS 来解决，当然，我们得需要六个方向数组，自己手推一下即可，然后分别表示判断 Jimmy 和 Chen，分别搜索上下边界和左右边界，然后最后用 mp 数组表示这一行（或这一列）有没有遍历过，最后判断左右边界和上下边界的 mp 是否都是 $1$ 即可。注意：Jimmy 是判断上下边界，Chen 是判断左边边界！！！
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
#define x first
#define y second
const int mod=1e9+7;
const int N=1e2+50;
#define endl '\n'
#define int ll
#define IO ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
int t;
int n;
bool flag=false;
int a[N][N]={};
bool vis_x[N][N]={};
bool vis_y[N][N]={};
bool mp_x[N]={};
bool mp_y[N]={};
int dx[]={0,0,1,1,-1,-1}; //方向数组。
int dy[]={1,-1,0,-1,0,1};
bool check(int op){ //判断上下边界（或左右边界）是否全都覆盖。
	if(op==1){
		for(int i=1;i<=n;i++){
			if(mp_x[i]==0){
				return false;
			}
		}
		return true;
	}else{
		for(int i=1;i<=n;i++){
			if(mp_y[i]==0){
				return false;
			}
		}
		return true;
	}
} 
void bfs_x(int x,int y){ //判断 Jimmy。
	queue<PII> q;
	q.push({x,y});
	vis_x[x][y]=1;
	mp_x[x]=1;
	while(!q.empty()){
		PII u=q.front();
		q.pop();
		for(int i=0;i<6;i++){
			int tx=u.x+dx[i];
			int ty=u.y+dy[i];
			if(tx>=1&&tx<=n&&ty>=1&&ty<=n){
				if(a[tx][ty]==1){
					if(!vis_x[tx][ty]){
						vis_x[tx][ty]=1;
						mp_x[tx]=1;
						q.push({tx,ty});
					}
				}
			}
		}
	}
	if(check(1)){
		flag=true;
	}
}
void bfs_y(int x,int y){ //判断 Chen。
	queue<PII> q;
	q.push({x,y});
	vis_y[x][y]=1;
	mp_y[y]=1;
	while(!q.empty()){
		PII u=q.front();
		q.pop();
		for(int i=0;i<6;i++){
			int tx=u.x+dx[i];
			int ty=u.y+dy[i];
			if(tx>=1&&tx<=n&&ty>=1&&ty<=n){
				if(a[tx][ty]==-1){
					if(!vis_y[tx][ty]){
						vis_y[tx][ty]=1;
						mp_y[ty]=1;
						q.push({tx,ty});
					}
				} 
			}
		}
	}
	if(check(2)){
		flag=true;
	}
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	IO;
	cin>>t;
	while(t--){
		cin>>n;
		flag=false; 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>a[i][j];
				vis_x[i][j]=0;
				vis_y[i][j]=0;
				mp_y[j]=0;
				mp_x[j]=0;
			}
		}
		//上下判断_Jimmy
		for(int i=1;i<=n;i++){ //i表示列 
			if(a[1][i]==1){
				bfs_x(1,i);
				if(flag){
					break;
				}
			} 
		} 
		if(flag){ //判断
			cout<<"Jimmy"<<endl; //直接输出，题目保证不可能两人都达到获胜条件。
		}else{
			//左右判断_Chen 
			for(int i=1;i<=n;i++){ //i表示行
				if(a[i][1]==-1){
					bfs_y(i,1);
					if(flag){
						break;
					}
				}
			}
			if(flag){
				cout<<"Chen"<<endl;
			}else{
				cout<<"yet"<<endl;
			}
		}
	}
	return 0;
}
```

---

## 作者：Charles_with_wkc (赞：0)

# 题意：
给你一个 $n \times n$ 的矩阵，如果 Jimmy 已经从第一行走到了第 $n$ 行则输出 `Jimmy`，如果 Chen 已经从第一列走到了第 $n$ 列则输出 `Chen`，如果都不成立则输出 `yet`。
# 思路：
这题本质就是一个连通块问题，但是本题的方向数组有 $6$ 个。先遍历第 $1$ 行，有 $1$ 就 BFS，再遍历第 $1$ 列，有 $-1$ 就 BFS。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N=105;
int a[N][N];
int t,n;
int dx[6]={0,0,1,1,-1,-1};
int dy[6]={1,-1,0,-1,0,1};
bool vis[N][N];
bool f;
struct node{
	int x,y;
};
bool bfs(int x,int y,int d){
	memset(vis,0,sizeof(vis));
	queue<node>q;
	q.push(node{x,y});
	vis[x][y]=1;
	while(!q.empty()){
		node u=q.front();
		q.pop();
		if((d==-1&&u.y==n)||(d==1&&u.x==n)) return 1;
		for(int i=0;i<6;i++){
			int bx=u.x+dx[i],by=u.y+dy[i];
			if(vis[bx][by]||bx<1||by<1||bx>n||by>n||a[bx][by]!=d) continue;
			vis[bx][by]=1;
			q.push(node{bx,by});
		} 
	}
	return 0;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) cin>>a[i][j];
		f=0;
		for(int i=1;i<=n;i++){
			if(a[1][i]==1&&bfs(1,i,1)){
				cout<<"Jimmy"<<endl;
				f=1;
				break;
			}
			//(1,i)存在1,那么判断Jimmy是否联通 
		}
		if(f==1) continue;
		for(int i=1;i<=n;i++){
			if(a[i][1]==-1&&bfs(i,1,-1)){
				cout<<"Chen"<<endl;
				f=1;
				break;
			}
			//(i,1)存在-1,那么判断Chen是否联通 
		}
		if(f==1) continue;
		cout<<"yet"<<endl;
	}
	return 0;
} 
```

---

## 作者：yihang2011 (赞：0)

# [题解：B4186 [中山市赛 2024/科大国创杯小学组 2023] 六形棋/海克斯](https://www.luogu.com.cn/problem/B4186)

思路都是 BFS，但是没必要写两个 BFS 来对应 Jimmy 和 Chen，函数就是用来重复调用的。

判断 Jimmy 时遍历第一行，如果值为 1 那么开始 BFS，到达第 $n$ 行就是 Jimmy 胜出；

判断 Chen 时遍历第一列，如果值为 -1 开始 BFS，
到达第 $n$ 列就是 Chen 胜出；

如果两轮判断都未能输出，那么输出 `yet` 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
bool vis[110][110];
vector<pair<int, int>> d = {make_pair(0, 1), make_pair(0, -1), make_pair(1, 0), make_pair(1, -1), make_pair(-1, 0), make_pair(-1, 1)};
int a[110][110];

bool bfs(int sx, int sy, bool who) {
    // who 变量用于对应人，值为 false 时对应 Jimmy，true 时对应 Chen
    queue<pair<int, int>> q;
    q.push(make_pair(sx, sy));
    vis[sx][sy] = true;
    while (!q.empty()) {
        int x = q.front().first, y = q.front().second;
        q.pop();
        if (!who && x == n) {
            return true;
        }
        if (who && y == n) {
            return true;
        }
        for (auto [dx, dy] : d) {
            int nx = x + dx, ny = y + dy;
            if (nx < 1 || nx > n || ny < 1 || ny > n || vis[nx][ny] || a[nx][ny] != a[sx][sy]) {
                continue ;
            }
            q.push(make_pair(nx, ny));
            vis[nx][ny] = true;
        }
    }
    return false;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        memset(vis, false, sizeof vis);
        cin >> n;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                cin >> a[i][j];
            }
        }
        bool flag = false;
        for (int j = 1; j <= n; j++) {
            if (a[1][j] == 1 && bfs(1, j, 0)) {
                cout << "Jimmy" << endl;
                flag = true;
                break ;
            }
        }
        if (flag) {
            continue ;
        }
        for (int i = 1; i <= n; i++) {
            if (a[i][1] == -1 && bfs(i, 1, 1)) {
                cout << "Chen" << endl;
                flag = true;
                break ;
            }
        }
        if (flag) {
            continue ;
        }
        cout << "yet" << endl;
    }
    return 0;
}
```

---


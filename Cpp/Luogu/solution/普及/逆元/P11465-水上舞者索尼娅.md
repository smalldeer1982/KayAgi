# 水上舞者索尼娅

## 题目背景

2024 年 12 月 18 日，《炉石传说》31.2.2 补丁上线，水上舞者索尼娅遭到削弱。现在，在这道题目中，你打开时空之门，回到了水索被削弱前的时候。

![](https://cdn.luogu.com.cn/upload/image_hosting/8et35uji.png)

## 题目描述

你的场上有 $k$ 个【水上舞者索尼娅】，你的手牌中有 $1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $n$ 根）】，你有无尽的法力值，你的手牌数量没有上限。

在你的场上有 $k$ 个【水上舞者索尼娅】的情况下：

当你使用 $1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $x$ 根）】时，你将得到：
- $k$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $x$ 根）】。
- $1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $x-1$ 根）】。（若 $x=1$，则不会得到）

当你使用 $1$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $x$ 根）】时，你将得到：
- $1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $x-1$ 根）】。（若 $x=1$，则不会得到）

你一共可以使用多少次【一串香蕉】？

由于答案可能很大，你只需求出答案对 $10^9+7$ 取模的余数。

## 说明/提示

$1\le T\le10^5$， $1\le n,k\le10^9$。

**【样例解释】**

对于第 $1$ 组数据：

场上有 $2$ 个【水上舞者索尼娅】，初始手牌中有 $1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $2$ 根）】。

使用：$1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $2$ 根）】。\
手牌：
- $2$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $2$ 根）】。
- $1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $1$ 根）】。

使用：$2$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $2$ 根）】。\
手牌：
- $3$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $1$ 根）】。

使用：$3$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $1$ 根）】。\
手牌：
- $6$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $1$ 根）】。

使用：$6$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $1$ 根）】。\
手牌：
- 空

共使用 $1+2+3+6=12$ 张【一串香蕉】。

## 样例 #1

### 输入

```
3
2 2
3 1
12 34
```

### 输出

```
12
14
178629506
```

# 题解

## 作者：CraaazyShep (赞：13)

[P11465 水上舞者索尼娅](https://www.luogu.com.cn/problem/P11465)

提供一个考场上想出的，不使用快速幂和乘法逆元的倍增做法。

### 推导

方便起见我们称【一串香蕉（还剩 $x$ 根）】为 $x$ 级牌。

首先观察一下每张 $x$ 级牌使用后会发生什么：

![](https://cdn.luogu.com.cn/upload/image_hosting/wcdnu3q5.png)

上图中黑色圆圈代表消耗为 $1$，白色圆圈代表消耗为 $0$。

观察到我们如果打出一张消耗为 $1$ 的 $x$ 级牌后，继续再把产生的消耗为 $0$ 的牌打光，过程中总计：

- 打出了 $k+1$ 次牌。
- （$x>1$ 时）最终产生 $k+1$ 张 $x-1$ 级牌。

我们把“将所有的消耗为 $1$ 的 $x$ 级牌转化为消耗为 $1$ 的 $x-1$ 级牌”称作一轮操作。

如果想要打光手中所有的牌，需要进行 $n$ 轮这样的操作。第 $i$ 轮操作中，初始手中会有 $(k+1)^{i-1}$ 张牌，每张牌都会产生 $k+1$ 次出牌，也就是说第 $i$ 轮操作最终产生总计 $(k+1)^i$ 次出牌。

那么显然的，答案就是：$\sum \limits_{i=1}^{n} (k+1)^i$。

### 实现

方便起见我们令 $m=k+1$，我们可以把求和的每一项都写成 $m$ 的 $2$ 的幂数次幂相乘的形式，我们以前 $8$ 项为例：

- $m^1,m^2,m^1m^2,m^4,m^1m^4,m^2m^4,m^1m^2m^4,m^8\dots$

将每项像这样分解开之后，我们可以发现第 $5$ 到 $8$ 项可以再作整理：

$\begin{aligned} m^1m^4+m^2m^4+m^1m^2m^4+m^8 &= (m^1+m^2+m^1m^2+m^4)m^4\\ &= m^4\cdot\sum \limits_{i=1}^{4} m^i \end{aligned}$

这启发了我们，当 $n=2^p$ 时有：

$\begin{aligned} \sum \limits_{i=1}^{2^p} m^i &= \sum \limits_{i=1}^{2^{p-1}} m^i + m^{2^{p-1}+1} + m^{2^{p-1}+2} + \cdots + m^{2^p}\\ &= \sum \limits_{i=1}^{2^{p-1}} m^i + m^{2^{p-1}}(m^1 + m^2 + \cdots + m^{2^{p-1}})\\ &= \sum \limits_{i=1}^{2^{p-1}} m^i + m^{2^{p-1}} \cdot \sum \limits_{i=1}^{2^{p-1}} m^i\end{aligned}$

于是我们可以使用倍增的思路来求出所有 $n$ 可以表示为 $2^p$ 时的结果。

当 $n=2^p$ 时，我们可以通过 $\sum \limits_{i=1}^{2^{p+1}} m^i = \sum \limits_{i=1}^{2^p} m^i + m^{2^p} \cdot \sum \limits_{i=1}^{2^p} m^i$ 来将 $n$ 倍增至 $2^{p+1}$。

如果 $n$ 不能表示为上述形式，则需要继续递归求解。

我们假设遇到了 $2^p < n < 2^{p+1}$ 的情况，可以列出式子：

$\begin{aligned} \sum \limits_{i=1}^{n} m^i &=  \sum \limits_{i=1}^{2^p} m^i + m^{2^p+1} +  m^{2^p+2} + \cdots + m^n\\ &= \sum \limits_{i=1}^{2^p} m^i + m^{2^p}(m^1 + m^2 + \cdots + m^{n-2^p})\\ &= \sum \limits_{i=1}^{2^p} m^i + m^{2^p} \cdot \sum \limits_{i=1}^{n-2^p} m^i \end{aligned}$

所以我们可以继续递归求出 $\sum \limits_{i=1}^{n-2^p} m^i$，再将其乘上 $m^{2^p}$ 加入答案即可。

像这样每次递归消掉一个最大的 $2^p$，最终即可得到答案。

时间复杂度为 $\mathcal{O}(T (\log n)^2)$。

### 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define ll long long
const int mo=1e9+7;
ll t,n,k;
int calc(ll m,ll n){
    ll re=m,tot=1;   // re 为返回值，tot 标记求和到第几项。 
    ll mt=m;         // mt 为目前为止最大的 m 的 2 的幂数次幂。 
    while(tot*2<=n){
        re=(re+re*mt)%mo;
        tot*=2;
        mt=(mt*mt)%mo;
    }
    if(tot==n)return re;
    int rre=calc(m,n-tot);
    return (re+rre*mt)%mo;
}
void solve(){
    cin>>n>>k;
    ll m=k+1;
    ll ans=calc(m,n);
    cout<<ans<<endl;
    return;
}
int main(){
    cin>>t;
    while(t--){
        solve();
    }
    return 0;
}
```


### 后日谈
这个做法在比赛当晚的讲评环节收获了出题人的不点名表扬，感到非常荣幸。~~实际上真的是因为我忘打印快速幂板子还不会乘法逆元才憋出来的。~~

---

## 作者：封禁用户 (赞：5)

$k$ 很大，要么倍增要么规律。

为了方便，记【水上舞者索尼娅】为 $A$ 牌，法力值消耗为 $1$ 的【一串香蕉（还剩 $x$ 根）】为 $B_x$ 牌，消耗为 $0$ 的为 $C_x$ 牌。

先用一张 $B_n$ 牌，会发现得到了：

- $k$ 张 $C_n$ 牌。

- $1$ 张 $B_{n - 1}$ 牌。

用了 $1$ 次【一串香蕉】。

发现第二种可以递归，所以再把 $k$ 张 $C_n$ 用掉，得到：

- $k$ 张 $B_{n - 1}$ 牌。

用了 $k$ 次【一串香蕉】。

于是，$1$ 张 $B_n$ 牌使用 $k + 1$ 次【一串香蕉】能得到 $k + 1$ 张 $B_{n - 1}$ 牌。

所以答案即为首项为 $k + 1$，比为 $k + 1$ 的 $n$ 项等比数列和。

套上公式就行了。

---

## 作者：Falashiro (赞：4)

设 $f_{i,j}$ 为初始只有一张费用为 $i$ 的【一串香蕉（还剩 $j$ 根）】时可以使用【一串香蕉】的次数，则 $f_{0,1}=1$，$f_{1,1}=k\times f_{0,1}+1=k+1$。
	
由题意易得，$i>1$ 时：
	
$$
\begin{aligned}
  f_{1,i}&=k\times f_{0,i}+f_{1,i-1}+1\\
  f_{0,i}&=f_{1,i-1}+1
\end{aligned}
$$

则：

$$
\begin{aligned}
  f_{1,n}&=k\times f_{0,n}+f_{1,n-1}+1\\
  &=k\times(f_{1,n-1}+1)+f_{1,n-1}+1\\
  &=(k+1)\times f_{1,n-1}+(k+1)\\
  &=(k+1)\times[(k+1)\times f_{1,n-2}+(k+1)]+(k+1)\\
  &=(k+1)^2\times f_{1,n-2}+(k+1)^2+(k+1)\\
  &\dots\\
  &=(k+1)^{n-1}\times f_{1,1}+\sum\limits_{i=1}^{n-1}(k+1)^i\\
  &=\sum\limits_{i=1}^{n}(k+1)^i\\
  &=\frac{(k+1)\times[(k+1)^n-1]}{k}
\end{aligned}
$$

$f_{1,n}$ 即为答案，使用快速幂与乘法逆元计算即可，时间复杂度为 $\Theta(T(\log n+\log\text{mod}))$。

---

## 作者：Reserved_ (赞：3)

---

前言：求通过，不是 AI。

---

# 题目意思：
根据场上水上舞者索尼娅的数量 $k$ 和初始手牌中一串香蕉的剩余根数 $n$，计算一共可以使用一串香蕉的次数，并将结果对 $10^9+7$ 进行取模。
# 题目思路：
- 运用[快速幂](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%B9%82/5500243?fr=ge_ala)算法，快速求出 $a^b$ 是多少。
- 示例代码：

```cpp
long long js(int x,int y)
{
	long long a=1,b=x;
	while(y>0)
	{
		if(y%2==1)
		{
			a*=b;
			a%=mod;
		}
		b*=b;
		b%=mod;
		y=y>>1;//位运算，等于y=y/2
	}
	return a;
}
```
- 理解题意我们会发现答案：
$ans=\sum_{i=1}^{n}(k+1)^i$。
- 然后就可以用等比数列求和公式来求和，即答案是：$\frac{(k+1)\times [(k+1)^n-1]}{k+1}$。
# 注意事项：
1. 取模。
2. 乘法逆元。
# code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
long long js(int x,int y)//快速幂
{
	long long a=1,b=x;
	while(y>0)
	{
		if(y%2==1)
		{
			a*=b;
			a%=mod;
		}
		b*=b;
		b%=mod;
		y=y>>1;//位运算，等于y=y/2
	}
	return a;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,k;
		scanf("%d%d",&n,&k);
		printf("%lld\n",((js(k+1,n+1)-1)*js(k,mod-2)-1)%mod);
	}
	return 0;
}
```

---

## 作者：dongzirui0817 (赞：2)

## 思路

### 暴力

先列出一个 dp，以充当暴力。

**状态：** 设 $dp_{i, \, j}$ 为 $1$ 张法力值消耗为 $j$ 的【一串香蕉（还剩 $i$ 根）】可以使用的次数。

**初始化：** $dp_{1, \, 0} = 1 \text{,} \, dp_{1, \, 1} = 2$。

因为 $1$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $1$ 根）】用一次就没了；而 $1$ 张法力值消耗为 $1$ 的【一串香蕉（还剩 $1$ 根）】用完后可以变成 $1$ 张法力值消耗为 $0$ 的【一串香蕉（还剩 $1$ 根）】，可以用 $2$ 次。

**转移：**
$$dp_{i, \, j} = \begin{cases}
   dp_{i - 1, \, 1} + 1 & j = 0  \\
   k \times dp_{i, \, 0} + dp_{i - 1, \, 1} + 1 & j = 1
\end{cases}$$

按照题意模拟即可。（不要忘了用这张卡牌本身也算用了一次）

**答案：** 答案为 $dp_{n, \, 1}$。

## 正解思路

这个 dp 时间复杂度 $O(n)$，会超时。

首先可以发现，根据 $dp_{i, \, 0} = dp_{i - 1, \, 1} + 1$ 可得：

$\begin{aligned} dp_{i, \, 1} &= k \times dp_{i, \, 0} + dp_{i - 1, \, 1} + 1 \\ &=  k \times (dp_{i - 1, \, 1} + 1) + dp_{i - 1, \, 1} + 1 \\ &= (k + 1) \times dp_{i - 1, \, 1} + k + 1 \end{aligned}$

后面就别化简了，不然之后用它时又要重新拆开。

可以发现，将 $dp_{i - 1, \, 1}$ 拆开和上面的 $dp_{i, \, 1}$ 一个方法。所以：

$\begin{aligned} dp_{i, \, 1} &= (k + 1) \times dp_{i - 1, \, 1} + k + 1 \\ &= (k + 1) \times [(k + 1) \times dp_{i - 2, \, 1} + k + 1] + k + 1 \\ &= (k + 1) ^ 2 \times dp_{i - 2, \, 1} + (k + 1) ^ 2 + (k + 1) \end{aligned}$

以此类推，得出：

$\begin{aligned} dp_{i, \, 1} &= (k + 1) ^ i + \sum_{j = 1} ^ {i - 1} (k + 1) ^ j \\ &= \sum_{j = 1} ^ {i} (k + 1) ^ j \end{aligned}$

所以 $dp_{n, \, 1} = \displaystyle \sum_{i = 1} ^ {n} (k + 1) ^ n$

~~之后就可以套等比数列和公式了，但是我不套。~~

两边乘 $k + 1$，得 $(k + 1) \times dp_{n, \, 1} = \displaystyle \sum_{i = 2} ^ {n + 1} (k + 1) ^ i $

与 $dp_{n, \, 1} = \displaystyle \sum_{i = 1} ^ {n} (k + 1) ^ i$ 相减，得：

$\begin{aligned} k \times dp_{n, \, 1} &= \displaystyle \sum_{i = 2} ^ {n + 1} (k + 1) ^ i - \displaystyle \sum_{i = 2} ^ {n + 1} (k + 1) ^ i \\ &= (k + 1) ^ {n + 1} - k - 1\end{aligned}$

所以：

$\begin{aligned} dp_{n, \, 1} &= \frac{(k + 1) ^ {n + 1} - k - 1}{k} \\ &= \frac{(k + 1) ^ {n + 1} - 1}{k} - 1\end{aligned}$

（其实第二步可以不用）化简不下去了，所以可以开始做了。

## 实现

对于答案可以用[快速幂](https://www.luogu.com.cn/problem/P1226)和[逆元](https://www.luogu.com.cn/problem/P2613)来做。

其他细节……没有。

时间复杂度 $O(T \log n)$。

```
#include <bits/stdc++.h>
using namespace std;

const int p = 1e9 + 7;

int T;
int n, k;

long long Pow(int x, int y) {
	int ans = 1;
	while (y) {
		if (y & 1) ans = 1LL * ans * x % p;
		x = 1LL * x * x % p,
		y >>= 1;
	}
	return ans;
}

int main() {
	scanf("%d", &T);
	for ( ; T-- ; ) {
		scanf("%d%d", &n, &k);
		printf("%lld\n", ((Pow(k + 1, n + 1) - 1) * Pow(k, p - 2) - 1) % p);
	}
	return 0;
}
```

---

## 作者：末然Ender (赞：1)

# 题解：P11465 水上舞者索尼娅

## 题意

你有一张卡，每张卡有计数器，你的卡初始计数器为 $n$，当你打出一张卡时你获得一张计数器为 $n-1$ 的卡，特别的如果 $n$ 为 $1$ 就不会获得卡计数器更小的卡了。现在你每打出一张非复制品卡都会给你 $k$ 个复制品的卡，但是复制品的卡产生的计数器更小的卡不是复制品，请问你总共能打出多少次卡。

## 思路

显然，你打出一张计数器为 $i$ 的非复制的卡，再打完它所产生的的复制品卡，然后获得了 $k+1$ 张 $i-1$ 计数器的卡。

令 $a=k+1$，所以你一共能打出计数器为 $n$ 的卡 $a$ 张，计数器为 $n-1$ 的卡 $a^2$ 张，计数器为 $n-2$ 的卡 $a^3$ 张……计数器为 $1$ 的卡 $a^n$ 张.

又显然，你获得过多少卡你就能打出多少次卡（毕竟你将它们全甩出去了嘛），那么我们所统计的答案就是

$$ans=\sum^{n}_{i=1}(k+1)^i$$

所以可以用等比数列求和公式来求和，答案即是 $\frac{(k+1)*[(k+1)^n-1]}{k+1}$。

别忘取模和乘法逆元。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
//#define getchar getchar_unlocked
template<typename T>
void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
const int N=1200,mod=1e9+7;
ll n,k;
ll ksm(long long x, ll k) {
    ll res = 1;
    while(k) {
        if(k & 1) res = res * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return res;
}

ll inv(ll x) {
    return ksm(x, mod - 2);
}
void solve(){
	read(n,k);
	ll a=k+1;
	ll ans=a*(ksm(a,n)-1)%mod*inv(a-1)%mod;
	write(ans);
	putchar('\n');
}
int main(){
	ll t;
	read(t); 
	while(t--){
		solve();
	}
	return 0;
}
```

---

## 作者：Andy1101 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P11465)
# 思路
由题我们可以知道答案为 $\sum\limits_{i = 1}^{n} (k+1)^{i}$。但是我们需要优化两个点——**幂的运算**和**循环**。

1. 优化幂的运算，这里我们需要用到快速幂，作用是用来快速算出 $a^b$。   
   核心代码：
   
    ```cpp
    int ksm(int a,int b) //注意运算时要取模
    {
    	int ans=1;
    	while(b)
    	{
    		if(b&1)
    		{
    			ans=ans*a%P;
    		}
    		a=a*a%P;
    		b=b/2;
    	}
    	return ans;
    }
    ```
    
2. 优化循环，这里我们需要用到等比数列求和公式来进行求和：$\dfrac{ (k+1) \times [ (k+1)^n - 1]}{k+1}$。

# AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int P=1e9+7;
int ksm(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1)
		{
			ans=ans*a%P;
		}
		a=a*a%P;
		b=b/2;
	}
	return ans;
}
signed main()
{
	int t;
	cin >>t;
	while(t--)
	{
		int n,k;
		cin >>n>>k;
		int ans;
		int a=k+1;
		ans=((ksm(k+1,n+1)-1)*ksm(k,P-2)-1)%P;
		cout <<ans<<'\n';
	}
	return 0;
}

```

---


# [蓝桥杯 2023 国 Java B] 逆元

## 题目描述

数论中的逆元是一个可以把除法转换为乘法的工具。若自然数 $a, I_a$ 满足 $a \times I_a \equiv 1 \pmod{M}$，则称 $a$ 在模 $M$ 的意义下的逆元为 $I_a$，这样在模 $M$ 下计算除法时，可以把除以 $a$ 的运算转化为乘以其逆元 $I_a$。

给定质数模数 $M = 2\,146\,516\,019$，根据费马小定理对于不是 $M$ 倍数的正整数 $a$，有 $a^{(M-1)} \equiv 1 \pmod{M}$，求出 $[1, 233\,333\,333]$ 内所有自然数的逆元。则所有逆元的异或和为多少？

# 题解

## 作者：Tomwsc (赞：3)

# P12217 [蓝桥杯 2023 国 Java B] 逆元 题解

## 思路

两种不同的做法，由于我比较蒟，所以介绍暴力做法。

容易由费马小定理得：$a^{m-2}\bmod m$ 即为 $a \bmod m$ 的逆元。这可以使用快速幂实现，所以直接暴力跑即可。时间很短，只需要两分钟……

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf (1ll << 62)
#define regint register int
#define pb push_back
#define mp make_pair
#define PII pair<int , int>
using namespace std;
const int mod = 2146516019;
int ans;

inline int ksm(int base , int x , int mod) {
	int result = 1;
	while(x) {
		if(x & 1)
			result = (result * base) % mod;
		x >>= 1;
		base = (base * base) % mod;
	}
	return result;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for(regint i = 1;i <= 233333333;i ++)
		ans ^= ksm(i , mod - 2 , mod);
	cout << ans;
	return 0;
}

---

## 作者：JIN_LONG (赞：2)

## 思路：
这道题通过线性递推法高效计算逆元，输出答案即可。

我代码中的 $A$ 类处理逆元计算，使用线性递推公式。

```cpp
inv[i] = (M - M/i) * inv[M%i] % M
```
而 $L$ 类负责异或累加计算，维护一个整型累加器。

以下是我代码实现的具体步骤。

- 初始化逆元数组。
- 通过递推公式批量计算 $2$ 到 $n$ 的逆元。
- 对每个逆元执行异或累加操作。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
class A {
private:
    vector<ll> a;
    ll b;
    
    void c(ll d) {
        a.resize(d+1);
        a[1] = 1;
    }
    
public:
    A(ll e, ll f):b(e){
        c(f);
    }
    
    void g(ll h) {
        for(ll i=2; i<=h;i++){
            a[i]=(b-b/i)*a[b%i]%b;
        }
    }
    
    ll j(ll k) const {
        return a[k];
    }
};

class L {
private:
    int m;
    
public:
    L() : m(0) {}
    
    void n(ll o) {
        m^=static_cast<int>(o);
    }
    
    int p() const {
        return m;
    }
};

void q(ll r, ll s) {
    A t(s, r);
    t.g(r);
    
    L u;
    for(ll v=1; v<=r; v++) {
        u.n(t.j(v));
    }
    
    cout<<u.p();
}

int main() {
    const ll w=233333333;
    const ll x=2146516019;
    q(w, x);
    return 0;
}

```

```java
import java.util.ArrayList;

public class ModularInverseXor {
    static class A {
        private ArrayList<Long> a;
        private long b;
        
        private void c(long d) {
            a = new ArrayList<Long>((int)(d+1));
            for(int i=0; i<=d; i++) a.add(0L);
            a.set(1, 1L);
        }
        
        public A(long e, long f) {
            this.b = e;
            c(f);
        }
        
        public void g(long h) {
            for(long i=2; i<=h; i++) {
                a.set((int)i, (b - b/i) * a.get((int)(b%i)) % b);
            }
        }
        
        public long j(long k) {
            return a.get((int)k);
        }
    }

    static class L {
        private int m;
        
        public L() {
            m = 0;
        }
        
        public void n(long o) {
            m ^= (int)o;
        }
        
        public int p() {
            return m;
        }
    }

    public static void q(long r, long s) {
        A t = new A(s, r);
        t.g(r);
        
        L u = new L();
        for(long v=1; v<=r; v++) {
            u.n(t.j(v));
        }
        
        System.out.print(u.p());
    }

    public static void main(String[] args) {
        final long w = 233333333L;
        final long x = 2146516019L;
        q(w, x);
    }
}

```

---

## 作者：chenyyy (赞：1)

# 题解：P12217 [蓝桥杯 2023 国 Java B] 逆元
很简单好吧，直接线性推得到答案就完成了。公式如下：

$$val_i = (((p -\left\lfloor\dfrac{p}{i}\right\rfloor) \times val_{p \bmod i}) \bmod p + p) \bmod p$$

其中 $p$ 为模数 $2146516019$。

为什么要这么推呢？

首先我们先设一下好吧。

设 $k = \left\lfloor\dfrac{p}{i}\right\rfloor$ 和 $r = p \bmod i$。

则有：

$$p = k \times i + r$$

于是：

$$r \equiv (-k) \times i \pmod p$$

两边乘上 $i^{-1} \times r^{-1}$ 得：

$$r \times i^{-1} \times r^{-1}\equiv (-k) \times i \times i^{-1} \times r^{-1}\pmod p$$

又因为 $i^{-1}\times i\equiv 1\pmod p$ 和 $r^{-1}\times r\equiv 1\pmod p$ 我们得到：

$$i^{-1}\equiv (-k) \times r^{-1} \pmod p$$

即：

$$val_i \equiv -\left\lfloor\dfrac{p}{i}\right\rfloor\times val_{p \bmod i}\pmod p$$

再模几下就成了：

$$val_i = (((p - \left\lfloor\dfrac{p}{i}\right\rfloor) \times val_{p \bmod i})\bmod p + p) \bmod p$$

具体代码如下，非常快，只需要 $7$ 秒。

```java
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) {
        final long p = 2146516019L;
        long[] val = new long[233333334];
        long ans = 0;
        
        val[1] = 1;
        for (int i = 2; i <= 233333333; i++) {
            // Using BigInteger to handle modulo operations with negative numbers correctly
            BigInteger bigP = BigInteger.valueOf(p);
            BigInteger bigI = BigInteger.valueOf(i);
            BigInteger term1 = bigP.subtract(bigP.divide(bigI));
            BigInteger term2 = BigInteger.valueOf(val[(int)(p % i)]);
            BigInteger product = term1.multiply(term2);
            BigInteger modResult = product.mod(bigP);
            val[i] = modResult.longValue();
            
            ans = ans ^ val[i];
        }
        System.out.println(ans ^ 1);
    }
}
```

---

## 作者：langmouren (赞：1)

## 题目分析

$M$ 是一个质数，所以有任意 $a < M$，使得 $\gcd(a,M)=1$，那么我们可以使用费马小定理求逆元。

对于幂的计算，我们可以使用快速幂，单次时间复杂度 $O(\log M)$。我们要从 $1$ 遍历到 $233333333$，设后者为 $MX$，则可以将时间复杂度视为约 $O(MX \times \log M)$。

## 代码

C++：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int unsigned long long

const int M=2146516019;
const int MX=233333333;
int ans;

int fast_pow(int a,int b,int p){
	int ans=1;
	while(b>0){
		if(b&1) ans=ans*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ans;
}

signed main(){
	for(int i=1;i<=MX;i++){
		ans^=fast_pow(i,M-2,M);
	}
	cout<<ans;
	return 0;
} 
```

Java（使用了 C++ 转 Java 工具）：


```java
import java.util.*;

public class Main {

    static final long M = 2146516019L;
    static final long MX = 233333333L;
    static long ans;

    public static long fastPow(long a, long b, long p) {
        long result = 1;
        while (b > 0) {
            if ((b & 1) == 1) {
                result = (result * a) % p;
            }
            a = (a * a) % p;
            b >>= 1;
        }
        return result;
    }

    public static void main(String[] args) {
        for (long i = 1; i <= MX; i++) {
            ans ^= fastPow(i, M - 2, M);
        }
        System.out.println(ans);
    }
}

```

可以得到答案为 $1307261675$。

---

## 作者：yanzixuan2024 (赞：0)

由费马小定理可得 $a$ 在模 $m$ 意义下的逆元为 $a^{m-2} \bmod m$。写个暴力即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=2146516019;
ll qpow(ll n,ll m){
    ll res=1;
    while(m){
        if(m&1) res=res*n%mod;
        n=n*n%mod,m>>=1;
    }
    return res;
}
ll sum;
int main(){
    for(ll i=1;i<=233333333;++i) sum^=qpow(i,mod-2);
    printf("%lld",sum);
}
```

最后答案为 $1307261675$。

---

## 作者：Yi_chen123 (赞：0)

## 思路

线性求逆元！

我们设 $inv_i$ 为 $i$ 在模 $m$ 意义下的逆元，那么有如下递推公式：

$$
inv_i = \begin{cases}
1, & i = 1\\
((m - \lfloor \dfrac{m}{i} \rfloor) \times inv_{m \bmod i}) \bmod m, & \text{otherwise}
\end{cases}
$$

### 证明

设 $m = ki + r\ (0<r<i)$，则 $k = \lfloor \dfrac{m}{i}\rfloor,r = m \bmod i$。  
由于 $ki + r \equiv 0 \pmod m$，两边同乘 $inv_i \times inv_r$ 得：
$$ k \times inv_r + inv_i \equiv 0 \pmod m $$

因此：
$$ inv_i = -k\times inv_r \bmod m = (m - k) \times inv_r \bmod m $$
即：
$$ inv_i = (m - \lfloor \dfrac{m}{i} \rfloor) \times inv_{m \bmod i} \bmod m $$

因此：$inv_i = -k\times inv_r \bmod m = (m - k) \times inv_r \bmod m$ 即：$inv_i = (m - \lfloor \dfrac{m}{i} \rfloor) \times inv_{m \bmod i} \bmod m$

证毕。

---

因此，我们在本地上暴力计算，再把结果进行提交就行了。

## 代码

```cpp
//仅展示核心部分，剩余初始化部分省略，请自行补全
for(int i = 2; i <= n; ++i){
    inv[i] = ((m - m / i) * inv[m % i]) % m;
    ans ^= inv[i];
}
cout << ans;
```

输出：

```
（请读者自行补全代码并在本地运行后得到输出）
```

不开 O2 优化，在本地运行时间竟然达到了惊人的 $24.94$ 秒！在洛谷上跑绝对 TLE；就算开了 O2，也可以跑到 $19.34$ 秒，所以还是老老实实的在本地运行吧。

## 友情推荐

- [P3811 【模板】模意义下的乘法逆元](https://www.luogu.com.cn/problem/P3811)
- [P5431 【模板】模意义下的乘法逆元 2](https://www.luogu.com.cn/problem/P5431)

---

## 作者：EasonLIkeMath (赞：0)

# P12217 [蓝桥杯 2023 国 Java B] 逆元 题解

## 思路

线性求逆元。

### 求 $i$ 的逆元

设 $M = k \times i + r (0 \le r < M)$，则 $k = \lfloor \frac{p}{i} \rfloor,r = M - \lfloor \frac{p}{i} \rfloor \times i$。

$$
\begin{aligned}
M \equiv 0 \pmod M \\
k \times i + r \equiv 0 \pmod M \\
(k \times i + r) \times i^{-1} \times r^{-1} \equiv 0 \pmod M \\
k \times r^{-1} + i^{-1} \equiv 0 \pmod M \\
k \times r^{-1} + i^{-1} \equiv 0 \pmod M \\
i^{-1} \equiv -k \times r^{-1} \pmod M \\
\end{aligned}
$$

## 代码

运行后直接提交答案即可，答案为 $1307261675$。

```java
public class Main {
    static long[] inv = new long[233333334];
    public static void main(String[] args) {
        long p = 2146516019;
        long ans = 0;

        inv[1] = 1;
        for (int i = 1; i <= 233333333; i++) {
            if (i == 1) {
                inv[i] = 1;
                ans ^= inv[i];
                continue;
            }
            long k = p / i;
            inv[i] = ((-k) * inv[(int)(p - (k * i))]) % p;
            inv[i] = (inv[i] + p) % p;
            ans ^= inv[i];
        }
        System.out.println(ans);
    }
}


```

---

## 作者：yanmingqian (赞：0)

模板题。

之前的题解有了 $O(M \log M)$ 的暴力做法。但是那样还是太暴力了。再细看一眼，这不是我们的[线性求逆元板子](https://www.luogu.com.cn/problem/P3811)吗？直接把代码套过来就好了。

但是我们还是要来讲解一下线性求逆元的。

（已知 $1^{-1} \equiv 1 \pmod p$）

如何求 $i^{-1}$ 呢？

显然 $p=\lfloor \frac{p}{i}\rfloor \times i+(p \bmod i)$，因此有

$$
\lfloor \frac{p}{i}\rfloor\times i+(p \bmod i)\equiv 0 \pmod p \\
$$

式子两边同乘 $i^{-1},(p \bmod i)^{-1}$，则有

$$
\lfloor \frac{p}{i}\rfloor\times (p \bmod i)^{-1}+i^{-1} \equiv 0 \pmod p\\
i^{-1}\equiv -\lfloor \frac{p}{i}\rfloor\times (p \bmod i)^{-1} \pmod p
$$

这样我们就可以递推了。

本题代码如下：

```cpp
#include<iostream>
using namespace std;
#define ll long long
ll f[233333335];
int main(){
    ll n=233333333,p=2146516019;
    f[1]=1;
    for(int i=2;i<=n;i++){
        f[i]=(p-p/i)*f[p%i]%p;
    }
    int ans=0;
    for(int i=1;i<=n;i++){
    	ans^=f[i];
	}
    cout<<ans;
    return 0;
}
```

注意由于代码中 `f` 数组开得比较大，用在线 IDE 会爆空间。所以需要放到本地编译器里把答案跑出来再交。

---


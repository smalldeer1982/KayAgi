# [NOIP 1999 提高组] 旅行家的预算

## 题目描述

一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $D_1$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $D_2$、出发点每升汽油价格$P$和沿途油站数 $N$（$N$ 可以为零），油站 $i$ 离出发点的距离 $D_i$、每升汽油价格 $P_i$（$i=1,2,…,N$）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。


## 说明/提示

$N \le 6$，其余数字 $ \le 500$。

NOIP1999 普及组第三题、提高组第三题

## 样例 #1

### 输入

```
275.6 11.9 27.4 2.8 2
102.0 2.9
220.0 2.2
```

### 输出

```
26.95
```

# 题解

## 作者：Twilight_ (赞：2097)

这道题目应该算是妥妥的贪心+模拟吧……

算法原理如下：

1.枚举途中经过的加油站，每经过一个加油站，计算一次花费；

2.在一个加油站所需要加的油，就是能够支持它到达下一个油价比它低的加油站的量；

3.如果在这个加油站即使加满油，都不能到达一个比它油价低的加油站，就把油箱加满，前往能够到达的加油站中油价最低的那个；

4.如果在这个加油站即使加满油，都不能到达任意一个加油站，也不能到达终点城市，说明无解；


**第三点：为什么要加满油？**因为这样可以减少在下一个加油站（价格更贵）所需要加的油量。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double maxx,mo=0,d2,temlen=0,d1,c,p;
//temlen：油箱中在到达了下一个加油站时油箱中的剩余油量可以继续走的路程
int n;
struct add
{
    double co;
    double dis;
}pl[10000];//加油站结构体：dis-距离起点的距离，co：油价
int move(int now)//1.now:现在到达的加油站
{
    int can=99999;
    int f=pl[now].dis;
    for(int i=now+1;i<=n&&pl[i].dis-f<=maxx;i++)
    {
        if(pl[i].co<pl[now].co)//2.
        {
            mo+=((pl[i].dis-f-temlen)/d2)*pl[now].co;
            temlen=0;
            return i;
        }
        if(can==99999||pl[i].co<pl[can].co)can=i;
    }
    if(d1-pl[now].dis<=maxx)
        {
            mo+=((d1-pl[now].dis-temlen)/d2)*pl[now].co;
            return 9999;
        }
    if(can==99999)//4.
    {
        cout<<"No Solution";
        return -1;
    }
    else//3.
    {
        mo+=c*pl[now].co;
        temlen+=(maxx-pl[can].dis+f);
        return can;
    }
}
int cmp(add a,add b)
{
    return a.dis<b.dis;
}
int main()
{
    cin>>d1>>c>>d2>>p>>n;
    pl[0].dis=0;
    pl[0].co=p;
    for(int i=1;i<=n;i++)cin>>pl[i].dis>>pl[i].co;
    sort(pl,pl+n,cmp);
    maxx=c*d2;
    int k=0,t;
    do
    {
        t=move(k);
        k=t;
        if(t==-1)return 0;
    }while(t!=9999);
    printf("%.2f",mo);
    return 0;
}
```

Update：
	时隔一年之后偶然翻到，竟然有137个赞QAQ！感谢大家，但由于之前的写法上有一些不足（太丑啦！），现在贴一份新的代码上来。
    
```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 100000
#define db double
#define INF 9999999 
int n;
db D1, D2, C, P, res, ans, maxx;

struct node
{
	db co, dis;
	bool friend operator <(const node& a, const node& b)
	{ return a.dis < b.dis; }
}pl[maxn];

int Solve(int now)
{
	int flag = INF; db d = pl[now].dis; 
	for(int i = now + 1; i <= n && pl[i].dis - d <= maxx; i ++)
	{
		if(pl[i].co < pl[now].co)
		{
			ans += ((pl[i].dis - d - res) / D2) * pl[now].co;
			res = 0; return i;
		}
		if(flag == INF || pl[i].co < pl[flag].co) flag = i;
	}
	if(D1 - pl[now].dis <= maxx)
	{
		ans += ((D1 - pl[now].dis - res) / D2) * pl[now].co;
		return INF;
	}
	if(flag == INF) { printf("No Solution\n"); return -1; }
	else
	{
		ans += C * pl[now].co; res += (maxx - (pl[flag].dis - d));
		return flag;
	}
}

int main()
{
	scanf("%lf%lf%lf%lf%d", &D1, &C, &D2, &P, &n);
	pl[0].dis = 0, pl[0].co = P;
	for(int i = 1; i <= n; i ++) 
		scanf("%lf%lf", &pl[i].dis, &pl[i].co);
	sort(pl, pl + n + 1);
	maxx = C * D2;
	int k = 0, t;
	do
	{
		t = Solve(k), k = t;
		if(t == -1) return 0;
	}while(t != INF);
	printf("%.2lf", ans);
	return 0;
}
```

---

## 作者：dingcx (赞：409)

~~作为一个没有考过普及组的蒟蒻，做提高组的题还是很恶心的。。。~~

~~其实我打完代码都不知道自己在写什么，感觉自己的思路很奇怪的，就来发一篇题解~~
## 思路分析
如果按照题目的来写，就是到一个加油站，看看要加多少油。

而我的思路是：不管怎样，只要到一个加油站，就**把车上的油塞满**。如果某个加油站的油很贵，那么到了下一个便宜的加油站，就把上一个加油站剩下的油**全部退掉**，在用这个加油站的油填满油箱。为了得到更多退油得到的钱，**先耗便宜的油**。

总结：

1.每到一个加油站，就加满油。

2.到第i个加油站就把油箱里所有>p[i]的油退掉，换成价格为p[i]的油

3.开车时，用最便宜的油
## 代码分析
### 变量
1.用一个结构体记录每种油的价格和有多少在油箱。

2.用数组d记录第i个加油站距离出发点的距离，其中d[0]=0,d[n+1]=D1。

3.用变量len记录油箱里有几种油。
### 遍历
范围：从1到n+1。

内容1：减掉从上一个加油站来消耗的油。注意要从便宜的开始耗，如果不够再换贵的。如果没油了就No Solution并return。

内容2：加油和退油。注意一些细节。（见后面的代码）
## AC代码
~~相信不会有人喜欢上面的一通分析吧~~，那么，你们喜欢的代码来了——
```cpp
#include<cstdio>
using namespace std;
int n,len=0;//如上所述
struct LLLL{//结构体
	double price;
	double sum;
}l[10];
double s,c,dis,ans=0;//s就是D1，dis就是D2
double d[10],p[10];
int main(){
	scanf("%lf%lf%lf%lf%d",&s,&c,&dis,&p[0],&n);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&d[i],&p[i]);
	l[0].sum=c;//初始化
    l[0].price=p[0];
    ans=c*p[0];
    len++;
    d[n+1]=s;
	for(int i=1;i<(n+2);i++){//遍历
		double lll=(d[i]-d[i-1])/dis;//需要用的油量
		double lll1=lll;//复制一份
		bool flag=1;
		while(len){//只要还有油
			if(l[0].sum<lll){//不够
				len--;lll-=l[0].sum;//都减掉
				for(int k=0;k<len;k++){//往前挪一位，这样只用看l[0]
					l[k].price=l[k+1].price;
					l[k].sum=l[k+1].sum;
				}
			}
			else{//够了
				l[0].sum-=lll;
				flag=0;//记录
				break;
			}
		}
		if(flag){//没油了qwq
			printf("No Solution");
			return 0;//直接返回
		}
		flag=1;//再赋成true
		for(int j=0;j<len;j++){
			if(p[i]<l[j].price){//比后面的都小
				ans-=(l[j].sum*l[j].price);//退油，注意要从j开始退
				for(int k=j+1;k<len;k++){
					l[j].sum+=l[k].sum;//加油，注意l[j]是保留下来的，不用再加一次
					ans-=(l[k].sum*l[k].price);//后面全退掉
				}
				l[j].sum+=lll1;//还要加上开车耗掉的油
				l[j].price=p[i];//价钱记住
				ans+=l[j].price*l[j].sum;//付钱
				len=j+1;//注意是j+1，我如果这里没出问题就一遍过了qwq
				flag=0;//记录
				break;//返回
			}
		}
		if(flag){//如果比所有油都贵
			l[len].sum=lll1;//只用加开车耗掉的油
			ans+=p[i]*lll1;//付钱
			l[len].price=p[i];//价钱记住
			len++;//记录多了一种油
		}
	}
	printf("%.2lf",ans);//输出，注意格式
	return 0; //华丽结束
}
```
发题解不仅可以帮助别人，还可以帮自己梳理思路。不过写题解还是挺累的，别忘了点个赞再走哟~

---

## 作者：hongzy (赞：215)

## 贪心 + 单调队列
思路：

1 在起点加满油；

2 到第i个加油站把油箱里价格>P[i]的油退了，换成价格为P[i]的油。

3 每次烧油就找最便宜的油烧

实现:单调队列，每次取front的烧油，再把当前的油用单调队列方式插入队尾.

单调队列的插入方式：back比当前P[i]大 就pop 直到back <= P[i] 再插入

.

---

```cpp
#include <iostream>
#include <cstdio>
#include <deque>
using namespace std;

struct OIL { //汽油 
	double cost, x; //价格 和 油量 
	OIL(double c, double n) : cost(c), x(n) {}
};
double d1, c, d2, D[10], P[10], ans, nc; //nc (<= c)是当前的油量
int n;
deque<OIL> p; //STL双端队列 实现 

int main() {
	scanf("%lf%lf%lf%lf%d", &d1, &c, &d2, &P[0], &n);
	for(int i=1; i<=n; i++) {
		scanf("%lf%lf", &D[i], &P[i]);
		if(D[i] - D[i-1] > c * d2) { //无解很好判断:装满油也跑不完这一段 
			printf("No Solution\n");
			return 0;
		}
	}
	D[n+1] = d1; //把终点设为第n+1个加油站 距离为d1 
	p.push_back(OIL(P[0], nc = c)); //直接加满 
	ans += P[0] * c;
	for(int i=1; i<=n+1; i++) { //从第i-1个加油站到第i个加油站 
		double nd = (D[i] - D[i-1]) / d2;  //跑这一段需要多少升汽油
		while(!p.empty() && nd > 0) {  //不断循环直到跑完这这一段 
			OIL front = p.front(); p.pop_front(); //每次找最便宜的油跑 
			if(front.x > nd)  { //这种油够跑 
				nc -= nd;
				p.push_front(OIL(front.cost, front.x - nd));
				break;
			}
			nc -= front.x; nd -= front.x;
		}
		if(i == n+1) { //到达终点:退回所有油 
			while(!p.empty()) {
				ans -= p.front().cost * p.front().x;
				p.pop_front();
			}
			break;
		} 
		while(!p.empty() && p.back().cost > P[i]) { //把贵的油退了 换成当前加油站的便宜油 
			ans -= p.back().cost * p.back().x;
			nc -= p.back().x;
			p.pop_back();
		}
		ans += (c - nc) * P[i];
		p.push_back(OIL(P[i], c - nc)); //每次加满(多了后面再退)
		nc = c; 
	}
	printf("%.2lf\n", ans);
	return 0;
}
```

---

## 作者：ZhYic (赞：90)

看了一下各位大佬的题解，感觉代码有些长，这里介绍一下~~简短的~~简陋的方法（不涉及单调队列，完全按照题面意思的贪心+模拟）
### 思路
首先将起点和终点与道路上的加油站视为等价节点，按照距离起点的距离（即为通过顺序）排序。  
然后对于每一个节点我们可以进行以下贪心策略  
- 如果可以直达下一个油价更低的节点就加满够到此节点的油，开过去（中间的不用管）  
- 如果不能直达就加满油（因为中转节点的油更贵要少加），开到能到范围内油价最低的加油站$^{^{[1]}}$

对于$^{[1]}$的证明：  
因为从A到B的路程一定，不管是$A->C->B$还是$A->D->B$所需的油量一定，那么设$P_b<P_a<P_c<P_d~~D_{ac}<D_{ad}$，在A地加满油需$(C-left)~\cdot~P_a$，C处加油$cost_c=(D_{cb}/D2-(C-D_{ac}/D2))\cdot P_c$，D处加油$cost_d=(D_{db}/D2-(C-D_{ad}/D2))\cdot P_c$，  
变形为$cost_c=((D_{cb}+D_{ac})/D2-C)\cdot P_c,cost_d=((D_{cd}+D_{ad})/D2-C)\cdot P_d$
$$\because{D_{ab}=D_{ac}+D_{cb}=D_{ad}+D_{db}}~~\therefore (D_{cd}+D_{ad})/D2-C=(D_{cb}+D_{ac})/D2-C$$
$$\because P_c<P_d~\therefore cost_c<cost_d$$
然后就是按照策略打代码了
```
#include <bits/stdc++.h>
double D0,C,D,cost,left;
struct node
{
    double d,p;
}s[8];
int n;
bool cmp(node a,node b){return a.d<b.d;}
int main()
{ 
    scanf("%lf%lf%lf%lf%d",&D0,&C,&D,&s[0].p,&n);
    s[n+1].d=D0;
    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf",&s[i].d,&s[i].p);
        if(s[i].d-s[i-1].d>C*D)//中间有一段路加满油也到不了下个节点
        {
            printf("No Solution");
            return 0;
        }
    }
    std::sort(s+1,s+1+n,cmp);
    for(int i=0;i<=n+1;)
    {
        int j,k;
        for(j=k=i+1;j<=n;j++)//若直达终点，j++后j为n+1而不是n+2
        {
        	k=s[j].p<=s[k].p?j:k;//范围内最小花费
            if(s[j].p<=s[i].p||s[j+1].d-s[i].d>C*D)break;//找到下一个比当前节点便宜的节点或者到不了下个节点
        }
        if(s[j].p>s[i].p)//策略2
        {
            cost+=(C-left)*s[i].p,left=C-(s[k].d-s[i].d)/D;
            i=k;
        }
        else
            cost+=s[i].p*((s[j].d-s[i].d)/D-left),i=j,left=0;//策略1
    }
    printf("%.2lf",cost);
    return 0;
}
```
---
代码中的C，D，D0和题面不一一对应

---

## 作者：Dcue (赞：75)

看大家写的都是贪心，来一波dfs
------------
**dfs基本思路：对在每一个点的选择进行遍历，筛选出最小值**  

**那么每个点的选择有哪些呢，或者说基本选择有哪些（因为复杂选择都是在基本选择的基础上进行组合的）**  
 
~~经过我的论证（这不是显而易见嘛）：~~  

**（ps：这里的下一站不一定是当前站的下一站，直接开到当前站的下两站也是可以的哦，一个for的事嘛）** 

**基本选择1：加油但只够只加到下一站**   

**基本选择2：油箱里的油够到下一站，不加油**   

**基本选择3：加满（对应某些油站的油特别便宜的情况）**  


下面是代码（含注释）
------------
```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
int const MANX=9999;
int n,f;
double Ans=99999999,sum,c,dis;
//Ans为答案，sum总路程，c油箱容量，dis油距比
double d[MANX],p[MANX],nd[MANX];
//d离起点距离，p表示价格，nd该站的下一站价格
void dfs(int st,double oil,double mo){
	//st当前到达站的编号
   //oil当前剩余油
   //mo当前花费
	if(st==n+1){
		if(mo<Ans)Ans=mo;
		f=1;//有答案的标记
		return;
	}
	if(c*dis<nd[st])return;//不能到达返回
	double nx=0;
	for(re int i=st;i<=n;i++){
		nx+=nd[i];//累距器
		if(dis*c<nx)break;//不能再累了，再累就到不了了
		dfs(i+1,c-nx/dis,mo+p[st]*(c-oil));//加满
		dfs(i+1,0,mo+max((double)0,p[st]*nx/dis-p[st]*oil));
     	//double强制转换，max只能同类型，避免出现oil>nx/dis的情况，导致进行返钱的错误处理
      	//不够则加到够，够则为0，自己理解一下
	}
	return;
}
int main(){
	cin>>sum>>c>>dis>>p[0]>>n;
	for(re int i=1;i<=n;i++){
		cin>>d[i]>>p[i];
		nd[i-1]=d[i]-d[i-1];
	}
	nd[n]=sum-d[n];
   //nd算出当前站与下一站的距离
	dfs(0,0,0);
	if(f){
		printf("%.2lf",Ans);
	}
	else printf("No Solution");
	return 0;
}
```
题目非常简单，大家多多思考就悟了  
  
**审核大大感谢**

---

## 作者：swkyccbb (赞：46)

这是一道经典的题。只要用贪心+模拟就可以过了。

先去掉$No Solution$的情况，然后模拟+贪心就可以了。具体解释在代码中呈现。

附上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double d1,c,d2,p,d[10],v[10],last,ans;	//last:剩下的油量 ans:最小费用 其他变量均为输出数据 
int n;
int main(){
	scanf("%lf%lf%lf%lf%d",&d1,&c,&d2,&p,&n);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&d[i],&v[i]);
	d[n+1]=d1;v[0]=p;
	for(int i=1;i<=n;i++){		//油箱中的油能否跑完每一段加油站的距离 
		if(d[i+1]-d[i]>c*d2){
			printf("No Solution\n");	//不能打出 No Solution
			return 0;
		}
	}
	int j;
	for(int i=0;i<=n;i=j){
		for(j=i+1;j<=n+1;j++){
			if(d[j]-d[i]>c*d2){		//在c*d2的距离内的加油站中寻找最便宜的加油站
				j--;
				break;
			}
			if(v[j]<v[i]) break;	//找到更便宜的加油站就退出循环 
		}
		if(v[j]<v[i]){		//有找到更便宜的加油站
			ans+=((d[j]-d[i])/d2-last)*v[i];	//加刚好足够到达第j个加油站的油 
			last=0;
		}
		else {
			ans+=(c-last)*v[i];			//加满油箱
			last=c-(d[j]-d[i])/d2;
		}
	}
	printf("%.2lf\n",ans);
	return 0;
}
```

代码还是比较简洁的，思路也很是清楚的qwq。

---

## 作者：楚泫 (赞：32)

# 贪心 AC#
------------（利用了简单的队列存要走的油站）

### 好不容易AC了翻翻评论区，决心认认真真哒写个题解造福和自己一样的~~小可爱们~~

##### 注释写的炒鸡清楚啦QAQ！蒟蒻在第四个点上卡了1hour



```cpp
#include<iostream>
#include<cstdio>
#include<queue> 
using namespace std;
double all,each,c,full;
double dis[10],price[10],cost,oil,add,need;
int n,tmp,now;
queue<int>q;				//用队列表示走过的油站 
int main(){
    scanf("%lf%lf%lf%lf%d",&all,&c,&each,&price[0],&n);			//读入 
    tmp=0,full=each*c;			//full表示单次最大行驶距离 
    dis[n+1]=all;				//存入到达终点用的距离 
    price[n+1]=99999999;		//将到达终点的价格初始化为最大值（用于之后进行比较） 
    for(int i=1;i<=n;i++) scanf("%lf%lf",&dis[i],&price[i]); 	//读入 
	for(int i=1;i<=n+1;i++){
		if(dis[i]-dis[i-1]>full){				//如果两油站间距离超过最大到达距离，结束程序 
            printf("No Solution");
            return 0;
        }
        if(price[i]<price[tmp]&&dis[i]-dis[tmp]<=full){ 	//如果该油站油费<当前位置油站的油费，且能够抵达，加入队列 
            q.push(i);
            tmp=i;					//更新当前油站的位置 
        }
        else if(dis[i]-dis[tmp]>full){		//如果该油站距离>最大行驶距离 
            q.push(i-1);		//将前一个油站加入队列 
            tmp=i-1;			// 将当前油站的位置更新为前一个油站 
            i--;				//重新比较当前油站 
        }
	}
	q.push(n+1);			//将终点加入队列 
    price[n+1]=0;			//因为比较结束，将终点油费更改为0 
    while(q.size()){
        int x=q.front();		//x表示要到达的油站 
        q.pop();
        if(price[x]>price[now]){		//如果要到达的油站油费>当前油站油费 
        	add=c-oil;	//加满油 
        	oil=c-(dis[x]-dis[now])/each;	//更改油量 
        	cost+=add*price[now];	//记录费用 
		}
		else{	// 如果要到达的油站油费<=当前油站油费 
			need=(dis[x]-dis[now])/each;	// need表示需要的油量 
			if(oil>=need) oil-=need;	//如果当前油量大于需要的，不加油
			else{		// 如果当前油量不够，加刚好到达下一站的油 
				add=need-oil;
				oil+=add-need;	//更改油量 
				cost+=add*price[now];	//记录费用 
			}
		}
        now=x;	//更改当前油站位置 
    }
    printf("%.2lf",cost);	//输出 
} 
```

---

## 作者：林子沐 (赞：25)

### ~~本蒟蒻~~的第一篇题解！
# 首先是~~废话~~分析算法
每到一个加油站先不加油，先~~抽根烟~~看能到哪几个加油站再根据情况加多少油。
### 接下来是分类讨论
#### 1、在车加满油能开到的范围内有价格更低的
那么就把油加到刚好能开到第一个价格比它低的点。
#### 2、没有价格更低的，但可以直接到终点
直接去终点。
#### 3、没有价格更低的，也不可以直接到终点
加满油，去价格最低的点。

------------
然后~~废话不多说，直接~~上代码

```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 15
using namespace std;
double d1,c,d2,Max,oil,ans; 
//oil代表当前剩多少油 
int n,now_i; 
//now_i表示当前在哪个加油站 
bool flag;
struct node
{
	double d,p;
}a[N];
bool cmp(node x,node y)
{
	return x.d<y.d;
}
int main()
{
	cin>>d1>>c>>d2>>a[0].p>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].d>>a[i].p;
	Max=c*d2; //加满油可行多少路程 
	a[n+1].d=d1;
    //将终点看做最后一个加油站,避免忽略d1-a[n].d>Max的情况
	sort(a+1,a+1+n,cmp);	
	for(int i=1;i<=n+1;i++)
	{
		if(a[i].d-a[i-1].d>Max)
        //若两个相邻的点之间加满油了都不能到,无解 
		{
			printf("No Solution");
			return 0;
		}
	}
	
	while(1)
	{
		int next,k;
		float Min=10000;
		flag=0;
		for(int i=now_i+1;a[i].d-a[now_i].d<=Max && i<=n;i++)
		{   //遍历在now_i点可到达范围内的点 
			if(a[i].p<=a[now_i].p && !flag) //选出第一个p更小的点 
			{
				next=i;
				ans+=((a[i].d-a[now_i].d)/d2-oil)*a[now_i].p;
				//加油加到刚好能到就行
				flag=1;  //flag==1时代表范围内有更小的p 
				oil=0;
				break;
			}
			if(Min>a[i].p) //求出能到达的范围内p最小的点(为下文做铺垫) 
			{
				Min=a[i].p;
				k=i;
			}
		}
		if(!flag)  //若范围内没有更小的p 
		{
			if(d1-a[now_i].d<=Max) //若可以直接到终点 
			{
				ans+=((d1-a[now_i].d)/d2-oil)*a[now_i].p;
				break;
			}
			else  //加满油,去范围内最小的一个站 
			{
				next=k;
				ans+=a[now_i].p*(c-oil);
				oil=c; 
				oil-=(a[k].d-a[now_i].d)/d2;  //到了之后还剩的油 
			}
		}
		now_i=next;  //汽车移动到下一个点 
	}
	printf("%.2lf",ans);
	return 0; 
}
```


---

## 作者：TEoS (赞：21)

看到这个数据范围，本蒟蒻马上就想到了搜索 ~~毕竟万物皆可搜索嘛~~



------------
所有的加油站和起点终点都是在一条直线上的，我们可以把它们看做$N+2$个节点，起点编号为0，终点编号为$N+1$。对于每个节点，枚举在该处加油的多少。我们可以发现，加油量只有两种情况，一是刚好可以到达任何一个节点，二就是加满整个油箱。因此枚举也变得可行了。而对于枚举到的状态，进行搜索继续枚举，直到到达终点为止。

对于搜索函数，我们传入三个量，分别为该节点的编号，当时的油量和当时的花费。我们从该节点开始枚举节点$i$，直到$i==N+1$结束，枚举该节点加油到刚好可以行驶到$i$节点的状态。这样讲可能有点乱，上代码更清楚一点：
```cpp
void get(int x,double s,double m)//分别表示编号、油量和花费
{
	if(s<0 || s>c)
		return ;//若油箱的油不符合实际，则返回
	if(x==n+1)
	{
		ans=min(ans,m);
		return ;
	}//到达终点则更新答案
	for(int i=x;i<=n+1 && (cn[i][0]-cn[x][0])/d2<=c;i++)
		if((cn[i][0]-cn[x][0])/d2<=s)
			get(x+1,s-(cn[x+1][0]-cn[x][0])/d2,m);//若到达节点i所需的油比当前的油还少，则不用加油
		else
			get(x+1,(cn[i][0]-cn[x][0])/d2-(cn[x+1][0]-cn[x][0])/d2,m+((cn[i][0]-cn[x][0])/d2-s)*cn[x][1]);//若当前的油不够开到节点i，则加到刚好可以开到
	get(x+1,c-(cn[x+1][0]-cn[x][0])/d2,m+(c-s)*cn[x][1]);//加满油箱
	
}
```
最后说一下输出，题目要求是四舍五入保留两位小数输出，但经过本蒟蒻的试验，四舍五入是不行的，直接输出即可（~~为何如此毒瘤~~），用printf方便又快捷：
```cpp
if(ans==INF)//若没有更新答案说明不能到达终点
		cout<<"No Solution";
	else
		printf("%.2lf",ans);
```
好了，最后上一下完整的代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double d1,c,d2,p,ans=1e6,cn[10][2];
int n;
void get(int x,double s,double m)
{
	if(s<0 || s>c)
		return ;
	if(x==n+1)
	{
		ans=min(ans,m);
		return ;
	}
	for(int i=x;i<=n+1 && (cn[i][0]-cn[x][0])/d2<=c;i++)
		if((cn[i][0]-cn[x][0])/d2<=s)
			get(x+1,s-(cn[x+1][0]-cn[x][0])/d2,m);
		else
			get(x+1,(cn[i][0]-cn[x][0])/d2-(cn[x+1][0]-cn[x][0])/d2,m+((cn[i][0]-cn[x][0])/d2-s)*cn[x][1]);
	get(x+1,c-(cn[x+1][0]-cn[x][0])/d2,m+(c-s)*cn[x][1]);
	
}
int main()
{
	cin>>d1>>c>>d2>>p>>n;
	for(int i=1;i<=n;i++)
		cin>>cn[i][0]>>cn[i][1];
	cn[0][1]=p,cn[n+1][0]=d1;//初始化
	get(0,0,0);//从起点开始搜索
	if(ans==1e6)
		cout<<"No Solution";
	else
		printf("%.2lf",ans);
	return 0;
}
```

---

## 作者：卓卓卓卓 (赞：9)

题解 O(∩\_∩)O

简单（zhi zhang）易懂

贪心++ 每次只用最便宜的油

只计算用过的油

假设装满 遇到便宜的油就把之前贵的换掉


代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
double D1,D2,C,P[500010],d[500010],oil[500010],dollor,oil_used,dis,sum;
int N,pos,cheap_oil,expensive_oil;
void getcheap()
{
    double minn=2147483647;
    for(int i=0;i<=pos&&i<=N;i++)
    {
        if(P[i]<minn&&oil[i]>0)
        {
            cheap_oil=i;
            minn=P[i];
        }
    }
    return;
}
void getexpensive()
{
    double maxn=0;
    for(int i=0;i<=pos&&i<=N;i++)
    {
        if(P[i]>maxn&&oil[i]>0)
        {
            expensive_oil=i;
            maxn=P[i];
        }
    }
    return;
}
int spend()
{
    getcheap();
    while(oil_used>0)
    {
        if(oil[cheap_oil]>=oil_used)
        {
            oil[cheap_oil]-=oil_used;
            sum-=oil_used;
            dollor+=P[cheap_oil]*oil_used;
            oil_used=0;
            if(oil[cheap_oil]==0) getcheap();
            return 1;
        }
        else
        {
            getcheap();
            oil_used-=oil[cheap_oil];
            sum-=oil[cheap_oil];
            dollor+=P[cheap_oil]*oil[cheap_oil];
            oil[cheap_oil]=0;
            getcheap();
            if(oil[cheap_oil]==0)
            {
                printf("No Solution\n");
                return 0;
            }
        }
    }
}
void charge()
{
    getexpensive();
    while(P[expensive_oil]>P[pos])
    {
        oil[pos]+=oil[expensive_oil];
        oil[expensive_oil]=0;
        getexpensive();
    }
    if(sum<C)
    {
        oil[pos]+=C-sum;
        sum=C;
    }
}
void ssort()
{
    bool bo=true;int k=0;
    while(bo==true)
    {
        bo=false;
        for(int i=N;i>k;i--)
        {
            if(d[i]<d[i-1])
            {
                swap(d[i],d[i-1]);
                swap(P[i],P[i-1]);
                bo=true;
            }
        }
        k++;
    }
}
int main()
{
    scanf("%lf%lf%lf%lf%d",&D1,&C,&D2,&P[0],&N);
    oil[0]=C;dis=D1;sum=C;
    if(N==0)
    goto loop;
    for(int i=1;i<=N;i++)
    {
        scanf("%lf%lf",&d[i],&P[i]);
    }
    ssort();
    for(int i=N;i>0;i--)
    {
        d[i]-=d[i-1];
    }
    while(dis>d[pos]&&pos<N)
    {
        pos++;
        oil_used=d[pos]/D2;
        int ans=spend();
        if(ans==0) return 0;
        charge();
        dis-=d[pos];
    }
```
loop:
```cpp
    if(dis>0)
    {
        oil_used=dis/D2;
        int ans=spend();
        if(ans==0) return 0;
    }
    printf("%.2lf\n",dollor);
    return 0;
}
```

---

## 作者：暮光 (赞：8)

首先，祝贺自己 Green Name !

发个题解庆祝一下


其实这道题并不难，如果当前在第i个油站，往后遍历能到达的j个油站，然后如果有油费更低的，就先去那里，这样肯定更省钱；

如果没有油费更低的油站，就去最远的。


这里把起点和终点都看做一个油站，然后遍历就行了，不需要特判N==0的情况，因为肯定有起点和终点两个油站。


下面是代码，不美观，勿喷~


-----------------------------------------------------------------------------














```cpp
#include <iostream>
#include <iomanip>
using namespace std;
struct station{
    double dist;
    double price;
};
int main()
{
    double fee = 0;
    double DL,D,C,P;
    int N;
    cin >> DL >> C >> D >> P >> N;
    station s[150];
    for (int i = 1; i <= N; i++)
        cin >> s[i].dist >> s[i].price;
    s[0].dist = 0;
    s[0].price = P;
    s[N + 1].dist = DL;
    s[N + 1].price = -1;
    int i = 0;          //表示当前所在的车站
    double oil = 0;     //表示当前有的油
    while (i <= N){     //i == N + 1 表明已经到达终点
        int k = i;
        //有更便宜的就过去 否则 尽可能走远
        while (s[i].dist + C*D >= s[k+1].dist && k <= N+1){
            k++;
            if (s[k].price <= s[i].price)       //找到比当前i更便宜的车站 直接确定目标
                break;
        }
        if (k == i){                            //后面没有能到达的油站了
                cout << "No Solution";
                return 0;
        }
        double dist = s[k].dist - s[i].dist;  //需要前进的距离
        if (s[k].price <= s[i].price){  //前往一个油费更低的油站  尽量不买油
            if (oil <= dist / D){       //当前的油不能到达 k
                fee += (dist / D - oil) * s[i].price;
                oil = 0;                //移动后 没油
            }
            else
                oil -= (dist / D);
        }
        if (s[k].price > s[i].price){   //即将移动到一个油费更高的油站  出发前需要买满油
            if (oil <= dist / D){       //当前的油不能到达 k
                fee += (((dist / D) - oil)* s[i].price);
                oil = C - dist / D;     //移动后 剩余的油
                fee += (oil * s[i].price);
            }
            else{                       //当前的油可以到达 k
                fee += (C - oil + dist / D) * s[i].price;
                oil = C - dist / D;
            }
        }
        i = k;            //移动到下一个油站
    }
    cout << setiosflags(ios::fixed) << setprecision(2) << fee;
    return 0;
}

```

---

## 作者：纸醉一世 (赞：8)

简单理一下贪心的思想：


先确定每个节点间的距离，start为0节点，end为n+1节点。


若存在节点间的距离d[i]-d[i-1]大于D\*c，则No Solution；其余情况，必有解。


在每个节点，我们有三种选择：


1.如果指定的goal还未完成，继续行驶；


2.若到达了goal，则向前找第一个邮价比自己低的油站（end处油站油价为0）


i.能够开往（distance<=D\*c）,则将goal定为它；


ii不够开往（distance>D\*c）,将油加满，将goal定为在加满情况下所能开到的最远油站。


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
double d[600]={0},p[600];
double s,c,D,p1;
int n;
double money=0,oil=0;
double locin(int goal,int now)
{
    if(now==n+1)
    {
        printf("%.2lf",money);
        return 0;
    }
    if(now<goal)
    {
        oil-=(d[now+1]-d[now])/D;
        locin(goal,now+1);
        return 0;
    }
    if(now==goal)
    {
        int k=now+1;
        while(p[k]>p[now])k++;
        if(d[k]-d[now]<=D*c)
        {
            if(oil<(d[k]-d[now])/D)
            {
            money+=((d[k]-d[now])/D-oil)*p[now];
            oil=(d[k]-d[now])/D;
            }
            locin(k,now);
            return 0;
        }
        else
        {
            int w=now+1;
            while(d[w]-d[now]<=D*c)w++;
            w--;
            money+=(c-oil)*p[now];
            oil=c;
            locin(w,now);
            return 0;
        }
    }
}
int main()
{
    cin>>s>>c>>D>>p1>>n;
    p[0]=p1;
    for(int i=1;i<=n;++i)
    {
    cin>>d[i]>>p[i];
    if(d[i]-d[i-1]>D*c)    
    {
        cout<<"No Solution";
        return 0;
    }
    }
    d[n+1]=s;p[n+1]=0;
    if(d[n+1]-d[n]>D*c)    
    {
        cout<<"No Solution";
        return 0;
    }
    locin(0,0);
    return 0;
}
```

---

## 作者：KSkun (赞：6)

## 解题思路


这题我采取的方法是模拟车在加油站之间行驶的过程，使过程中需要用的每一份油都使用能够使用的最便宜的油。这种想法比较抽象，难以理解，不过清晰并且实现起来容易。题解中会有分析和举例帮助理解。


首先说一下怎么做到“使过程中需要用的每一份油都使用能够使用的最便宜的油”。我们不断地维护可用的“燃油提供者”（即加油站）的列表。等到要用油的时候，再从列表中选取最便宜的油拿来用，而不是在到那个油站的时候就决定好加多少油。我们设想现在正打算从加油站G1行驶到G2，模拟选取最优的过程。这个过程需要讨论，细节如下：


- 从当前可用的“提供者”中选取最便宜的备用

- 计算从G1行驶到G2所需的油量，并且从“提供者”处买来燃油，加进车的油箱里

- 将车从G1开到G2，再以G2为起点计算下一步的行动


可以容易得出以下的结论：


1. 每个加油站最多能给你加一油箱的油，如果加的更多油箱装不下

2. 只有到现在所在位置的距离小于一油箱油能够行驶的距离，在这样的加油站才能买油（实际情况是如果超出这一距离，等你到这个位置之前一油箱的油就被用完了，这些油包括了你在那个很远的油站买的油）


需要讨论的内容：


- 如果最便宜油站到现在所在位置的距离在一油箱油能够行驶的距离之内，且这个油站还可以买够从G1到G2所需的油，那很好，直接把这些油买下来

- 如果最便宜油站到现在所在位置的距离在一油箱油能够行驶的距离之外，或这个油站不能继续买油了，把它从列表中删去

- 如果最便宜油站到现在所在位置的距离在一油箱油能够行驶的距离之内，且这个油站买不够从G1到G2所需的油，选择次便宜的买够，若仍不够，循环操作


以题目样例为例：






```cpp
 ![](https://cdn.luogu.com.cn/upload/pic/8743.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/8744.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/8745.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/8746.png) 
```
实现上，列表用堆/优先队列维护，可以将起点、终点作为油站加入列表，走到终点结束前进即可。实现代码中有详细注释。

本题解同时发布于我的博客[旅行家的预算 NOIP1999 题解 – KSkun's Blog](http://ksmeow.moe/noip1999\_travel/)，欢迎来逛or收藏ww


## 实现代码

```cpp
#include <cstdio>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

struct gas {
    double pos, price, vol;
} g[505];

bool cmp(gas a, gas b) {
    return a.pos < b.pos;
} 

struct cmp1 {
    bool operator()(int a, int b) {
        return g[a].price > g[b].price;
    }
};

priority_queue<int, vector<int>, cmp1> pq; // 堆存可以用的油 

int n; // 注意n可以为0 
double dis, vol, doil, sprice, maxdis;

int main() {
    scanf("%lf%lf%lf%lf%d", &dis, &vol, &doil, &sprice, &n);
    maxdis = vol * doil;
    if(n == 0) { // 对n为0的特判 
        if(dis > maxdis) {
            printf("No Solution");
        } else {
            printf("%.2lf", dis / doil * sprice);
        }
        return 0;
    }
    // 把起点和终点都加入加油站的列表 
    g[0].pos = 0, g[0].price = sprice, g[0].vol = 0;
    g[n + 1].pos = dis, g[n + 1].price = -1, g[n + 1].vol = -1;
    for(int i = 1; i <= n; i++) {
        scanf("%lf%lf", &g[i].pos, &g[i].price);
        g[i].vol = 0;
    }
    sort(g, g + n + 1, cmp); 
    pq.push(0);
    int ngas = 0; // 表示现在开到了下表为ngas的加油站 
    double ncost = 0; // 表示现在的累计花费油钱 
    while(ngas < n + 1) {
        //printf("maxdis %lf dis %lf\n", maxdis, g[ngas].pos - g[pq.top()].pos);
        // 如果走的太远远处的油站就无法加油了，或是这个油站已经买了一箱油没办法再加了，这两种情况要把油站出堆 
        while(g[ngas].pos - g[pq.top()].pos > maxdis || g[pq.top()].vol >= vol) {
            pq.pop(); 
        } 
        // 无解的情况：存在相邻油站距离大于一箱油可以支持的距离 
        if(g[ngas + 1].pos - g[ngas].pos > maxdis) {
            printf("No Solution");
            return 0;
        }
        int gmin = pq.top();
        pq.pop();
        //printf("ngas %d ncost %lf gmin pos %lf price %lf vol %lf\n", ngas, ncost, g[gmin].pos, g[gmin].price, g[gmin].vol);
        double gcost = (g[ngas + 1].pos - g[ngas].pos) / doil;
        // 往前走一个油站，计算这段路程的油费开支 
        if(vol - g[gmin].vol >= gcost) { // 如果最便宜的油能够支持这一段路程 
            ncost += gcost * g[gmin].price;
            g[gmin].vol += gcost;
        } else { // 如果最便宜的油不能支持这一段路程，那么就要补充次便宜的 
            while(gcost > 1e-10) { // EPS设为1e-10避免浮点陷阱 
                double navailable = vol - g[gmin].vol; // 现在选择的油站可以买的油量 
                ncost += min(gcost, navailable) * g[gmin].price;
                gcost = max(1e-10, gcost - navailable);
                g[gmin].vol = min(vol, g[gmin].vol + gcost); 
                while(g[ngas].pos - g[pq.top()].pos > maxdis || g[pq.top()].vol >= vol) {
                    pq.pop(); 
                }
                gmin = pq.top();
            }
        }
        ngas++;
        pq.push(gmin); // 把还能加的油加进去 
        pq.push(ngas);
    }
    printf("%.2lf", ncost);
    return 0;
}
```

---

## 作者：whwh (赞：5)

调了一晚上，写一篇题解慰藉自己。写得不好请见谅。

这是一道贪心加实际应用题，有许多的细节（在代码中）;

首先介绍一下变量的作用：

1.q[]，d1,d2,c,p储存数据，ans储存钱数

2.c1记录在第i个加油站时得油量

3.w记录第i加油站在[i,w)中的加油费最小

4.u记录第i个加油站到下一个加油站所需的油量（也可不用，直接写）

5.max2记录在第i个时，c和(q[n+1].d-q[i].d)/d2（从第i个加油站所需的油量）中更小的一个，max2取后者是因为如果大于此值就会有油剩余，自然ans不是最小值

6.最最重要的一个，book[]记录哪一些加油站可以忽略掉

7.(q[x].d-q[y].d)/d2(x>y) 表示的是从第x个加油站到第y个加油站所需的油
（因为位置不够用所以写在这，请见谅）

介绍完后上AC代码：
```
#include<cstdio>
struct note{
	double d,p;
}q[10];
double min1(double x,double y){
	if(x>y) return y;
	return x;
}
bool book[10];
int main(){
	double d1,c,d2,p,c1=0,ans=0;
	int n,w;
	scanf("%lf%lf%lf%lf%d",&d1,&c,&d2,&p,&n);
	for(int i=1;i<=n;++i) scanf("%lf%lf",&q[i].d,&q[i].p);
    	//这一行初始化，为后面计算ans,u,w,c1,max2做准备，自行理解一下
	q[0].p=p;q[0].d=0;q[n+1].d=d1;q[n+1].p=0;
	for(int i=0;i<n;++i){
    		//计算u,max2
		double u=(q[i+1].d-q[i].d)/d2,max2=(q[n+1].d-q[i].d)/d2;
		max2=min1(max2,c);w=0;
		if(u>c) {
			printf("No Solution");
			return 0;
		}
        	//若加满了油还不能从i到i+1说明无法到达目的地，直接终止程序
        	//枚举第i个加油站后哪一些加油站（连续的）比第i个加油站的加油费贵
        	//j枚举到n+1是为了让w可以为目的地那个点
		for(int j=i+1;j<=n+1;++j){
        		/*已忽略的加油站不需再替那段路程加油了，若遇到了更
                	  贵的加油费的加油站要停止*/
			if(q[i].p<q[j].p&&!book[j]){
            			//若已有的油加上从j地到j+1地所需要的油比max2大就加油加到max2
                		//计算ans,c1（这里就不加说明了）
				if(c1+(q[j+1].d-q[j].d)/d2>=max2){
					ans+=(max2-c1)*q[i].p;
					c1=max2;break;//既然满了，那么就可以退出了
				}
                		//反之加上从j地到j+1地所需要的油
				else{
					ans+=(q[j+1].d-q[j].d)/d2*q[i].p;
					c1+=(q[j+1].d-q[j].d)/d2;
				}
			}
			else {w=j;break;}//给w赋值
		}
		for(int v=1;v<w;++v) book[v]=1;//标记
        	//还记得吗，我们还没加上从i地到i+1地所需的油量，那么这些油加不加就看下面的了
        	//关键，如果此时的油量小于到w地所需的油量，就需加上**适量**的油
		if(c1<(q[w].d-q[i].d)/d2) {
        		/*如果从i地到w地所需的油量小于max2那么加油，一直加
                	  到(q[w].d-q[i].d)/d2，反之加到max2即可*/
			if((q[w].d-q[i].d)/d2<=max2){
				ans+=((q[w].d-q[i].d)/d2-c1)*q[i].p;
				c1=(q[w].d-q[i].d)/d2;
			}
			else ans+=(max2-c1)*q[i].p,c1=max2;
		}
		c1-=u;//减去从i地到i+1地所需的油，为下站做准备
	}
	if((d1-q[n].d)/d2>c){
		printf("No Solution");
		return 0;
	}//若加满了油还不能从第n个加油站到达目的地说明不能到达目的地
	ans+=((d1-q[n].d)/d2-c1)*q[n].p;
    	//记住到了n地，油箱不知道有多少油，所以在这里还得再算一下油钱
	printf("%.2lf",ans);//保留2位
	return 0;
}
```
时空：9ms 800KB

恳请管理员通过我这篇题解



---

## 作者：enderrainy (赞：5)

利用一个优先队列，选出当前最便宜的油消耗，消耗之后再计算价格。

本人格式可能不是太好，请谅解。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<queue>
using namespace std;
struct oil{
       double r,p;
       inline bool operator <(const oil &a)const{
              return p>a.p;}};   //制成小根堆
int n;double S,D,C,V;
double p[100001],d[100001];
priority_queue<oil> q;
int main(){
    ios::sync_with_stdio(false);
    cin>>S>>C>>D>>p[0]>>n;
    for(int i=1;i<=n;i++)
      cin>>d[i]>>p[i];
    n++;d[n]=S;//此处一定记得把最后一位制成终点（我改了半天也没发现）
    for(int i=n;i>=1;i--)
      d[i]-=d[i-1];
    oil a0;a0.r=C;a0.p=p[0];
    q.push(a0);
    for(int i=1;i<=n;i++)
      {double l=d[i];
       while(l)
        {if(q.empty()) 
          {cout<<"No Solution"<<endl;
           system("pause");
           return 0;}
         oil a=q.top();q.pop();
         if(a.r*D>l)
           {a.r-=l/D;
            V+=a.p*l/D;
            l=0;q.push(a);}
         else
           {l-=a.r*D;
            V+=a.p*a.r;}}//计算消耗的油
       a0.p=p[i];
       q.push(a0);}//加新油
    printf("%.2f",V);
    //system("pause");
return 0;}//ＴＨＥＥＮＤ
```

---

## 作者：shimly (赞：5)

其实不太难，清楚思路就行了。别吓到


应该看得懂


```cpp
var
  p,d:array[0..10]of real;  //（p数组=price,d数组=distance)
  n:longint;
  d1,c,d2:real;//（d1终点距离，c油箱容量，d2一升油能开多远）
procedure init;
  var
    i:longint;
  begin
    readln(d1,c,d2,p[0],n);
    for i:=1 to n do
      readln(d[i],p[i]);
  end;
procedure qs(l,r:longint);//(按距离排序，方便处理，无聊打了下快排）
  var
    i,j:longint;
    k,t:real;
  begin
    i:=l;j:=r;k:=d[(i+j) div 2];
    repeat
      while d[i]<k do inc(i);
      while d[j]>k do dec(j);
      if i<=j then
      begin
        t:=d[i];d[i]:=d[j];d[j]:=t;
        t:=p[i];p[i]:=p[j];p[j]:=t;
        inc(i);dec(j);
      end;
    until i>j;
    if i<r then qs(i,r);
    if l<j then qs(l,j);
  end;
procedure main;
  var
    i,pre,t:longint;
    min,v,s:real;
  begin
    pre:=0;s:=0;v:=0;//（pre当前加油站，s花费，v当前油箱的油）
    repeat
      i:=pre+1;//（下一个加油站）
      while (p[i]>p[pre]) and (i<=n) and not(d[pre]+c*d2<d[i]) do
        inc(i);//（寻找有没有油费更低的加油站）
      if (i<=n) and (d[pre]+c*d2>=d[i])
      then begin//（1.情况，有油费更低的加油站）
           // （处理下v，不处理的话会弄出负数）
             if (d[i]-d[pre])/d2>v then  //（要开到下一站的油量比当前油箱油量大）
             begin
               s:=s+((d[i]-d[pre])/d2-v)*p[pre]; //（多加点油）
               v:=0;  //（在下一站耗光）
             end
             else v:=v-(d[i]-d[pre])/d2;  //（不用加油了，直接开过去）
             pre:=i;
           end
      else begin
             if d[pre]+c*d2>=d1 then//（能开到终点了，最优解出来了）
             begin
               s:=s+((d1-d[pre])/d2-v)*p[pre];  //（v不会大于d1-d[pre]的，不解释了）
               writeln(s:0:2);
               exit;
             end;
             //（还到不了终点）
             t:=0;min:=maxlongint;
             for i:=pre+1 to n do //（寻找能到站中油费最小的站）
               if d[pre]+c*d2<d[i] then break
               else if p[i]<min then begin
                                       t:=i;
                                       min:=p[i];
                                     end;
            if t=0 then begin //(t=0表示后面没站了，到不了终点了---无解）
                          writeln('No Solution');
                          exit;
                        end;
            s:=s+(c-v)*p[pre];//（加满油）
            v:=c;
            v:=v-(d[t]-d[pre])/d2; //（开到下一站，油箱的油减去对应的值）
            pre:=t;
          end;
    until false;
  end;
begin
  init;
  qs(1,n);
  main;
end.
```

---

## 作者：ciyou (赞：4)

这道题贪心就好了：

> 如所有经过的加油站中，多加最便宜的油一定是坠吼的；

这样一来将所有经过的加油站的最大加油量（就是C）和油价加到优先队列里，只要走着走着没油了，就从优先队列取出最便宜的油，加至恰好能到达下一个加油站（因为也许那里的油比你已经经过的更便宜），然后将它的最大加油量减去你加了的部分重新加入队列，如果堆顶的不够加，就继续取第二小，第三小的，如果所有能加的油都加完了还不能到达目的地，就无解。


代码如下，不太好看，勿喷^\_^


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct oil{
    double rest,cost;
    bool operator < (const oil& rhs) const{
        return cost>rhs.cost;
    }
};
priority_queue<oil> Q;
double dis[105],cost[105],D1,D2,P,C;
int N;
int main(){
    cin>>D1>>C>>D2>>P>>N;
    dis[0]=0;
    for(int i=1;i<=N;i++){
        cin>>dis[i]>>cost[i];
    }
    dis[N+1]=D1;
    N++;
    for(int i=N;i>=1;i--) dis[i]-=dis[i-1];
    int k=1;
    double ans=0;
    Q.push((oil){C,P});
    while(k<=N){
        double to=dis[k];
        while(to>0){
            if(Q.empty()){
                cout<<"No Solution";
                return 0;
            }
            oil o=Q.top();
            Q.pop();
            if(o.rest*D2>=to){
                o.rest-=to/D2;
                ans+=to/D2*o.cost;
                to=0;
                if(o.rest>0) Q.push((oil){o.rest,o.cost});
            }else{
                to-=o.rest*D2;
                ans+=o.rest*o.cost;
            }
        }
        Q.push((oil){C,cost[k]});
        k++;
    }
    printf("%.2f",ans);
}

```

---

## 作者：zfz04 (赞：3)

# 贪心&模拟

算是思路比较简单的一道贪心题，但是因为变量名的缘故，代码实现我却花了1个小时，在第一遍写的时候写到后面因为变量名都是什么abcd之类的，导致我自己都不知道我自己在写什么了，然后我就在线暴躁，直接关闭c++，取消保存，重新写了一份自从参加竞赛以来我码风最好的一份代码，这也是我为什么要写题解的原因（~~快乐~~）


------------

**进入正题（思路）：**

贪心分两种情况：

1. 你在这个加油站所能到达的加油站中有一个加油站的油价钱比你这个加油站的价钱低，那你就加油加到刚好可以到达那个加油站的油；
1. 如果没有，那你就把油加满，然后前往最远所能到达的加油站，然后再重复这两个操作；

很容易想到当遇到2种情况时就可以输出答案了：

1. 即使你加满油也无法从当前加油站到下一个加油站，那就输出No Solution；

1. 到终点时；


------------

**接下来就是我引以为傲的代码了（~~菜鸡世界的快乐~~）：**

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
double l/*终点*/,c/*油箱容量*/,d_everyc/*每升油所能走的路程*/,petrol_now/*当前油箱里的油*/,tot_money/*money*/,d_fullc/*加满油所能到达的距离*/;
int sta_now;//当前所在加油站； 
int n;
struct node
{
	double price,dis;
}sta[10];//加油站； 
bool cmp(node x,node y){return x.dis<y.dis;}
int main()
{
	cin>>l>>c>>d_everyc>>sta[0].price>>n;//把起点当做编号为0的加油站； 
	d_fullc=d_everyc*c;/*加满油所能到达的距离*/
	for(int i=1;i<=n;i++) cin>>sta[i].dis>>sta[i].price;
	sort(sta+1,sta+1+n,cmp);
	while(1){
		bool low_price=false;//在能到达的范围内是否有油价更低的加油站； 
		int i;
		for(i=sta_now+1;sta[i].dis-sta[sta_now].dis<=d_fullc&&i<=n;i++){
			if(sta[i].price<=sta[sta_now].price){//有； 
				tot_money+=((sta[i].dis-sta[sta_now].dis)/d_everyc-petrol_now)*sta[sta_now].price;//注意，要算上油箱里剩余的油； 
				petrol_now=0;
				low_price=true;
				sta_now=i;
				break;
			}
		}
		if(!low_price){//如果没有，就去往最远可到达的加油站； 
			i--;
			if(sta[sta_now].dis+d_fullc>=l){//可以到达终点了； 
				tot_money+=((l-sta[sta_now].dis)/d_everyc-petrol_now)*sta[sta_now].price;
				break;
			}
			else{
				if(i==sta_now){//油加满也无法到达下一个加油站； 
					cout<<"No Solution";
					return 0;
				}
				else{//去往最远的加油站； 
					tot_money+=(c-petrol_now)*sta[sta_now].price;
					petrol_now=(c-((sta[i].dis-sta[sta_now].dis)/d_everyc));
					sta_now=i;
				}
			}
		}
	}
	printf("%.2lf",tot_money);
	return 0;
}
```


------------

**优美码风从我做起！**（~~快乐~~）


---

## 作者：衡屿睿 (赞：3)

简单理一下贪心的思想：

先确定每个节点间的距离，start为0节点，end为n+1节点。

若存在节点间的距离d[i]-d[i-1]大于D\*c，则No Solution；其余情况，必有解。

在每个节点，我们有三种选择：

1.如果指定的goal还未完成，继续行驶；

2.若到达了goal，则向前找第一个邮价比自己低的油站（end处油站油价为0）

i.能够开往（distance<=D\*c）,则将goal定为它；

ii不够开往（distance>D\*c）,将油加满，将goal定为在加满情况下所能开到的最远油站。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
double d[600]={0},p[600];
double s,c,D,p1;
int n;
double money=0,oil=0;
double locin(int goal,int now)
{
    if(now==n+1)
    {
        printf("%.2lf",money);
        return 0;
    }
    if(now<goal)
    {
        oil-=(d[now+1]-d[now])/D;
        locin(goal,now+1);
        return 0;
    }
    if(now==goal)
    {
        int k=now+1;
        while(p[k]>p[now])k++;
        if(d[k]-d[now]<=D*c)
        {
            if(oil<(d[k]-d[now])/D)
            {
            money+=((d[k]-d[now])/D-oil)*p[now];
            oil=(d[k]-d[now])/D;
            }
            locin(k,now);
            return 0;
        }
        else
        {
            int w=now+1;
            while(d[w]-d[now]<=D*c)w++;
            w--;
            money+=(c-oil)*p[now];
            oil=c;
            locin(w,now);
            return 0;
        }
    }
}
int main()
{
    cin>>s>>c>>D>>p1>>n;
    p[0]=p1;
    for(int i=1;i<=n;++i)
    {
    cin>>d[i]>>p[i];
    if(d[i]-d[i-1]>D*c)    
    {
        cout<<"No Solution";
        return 0;
    }
    }
    d[n+1]=s;p[n+1]=0;
    if(d[n+1]-d[n]>D*c)    
    {
        cout<<"No Solution";
        return 0;
    }
    locin(0,0);
    return 0;
}
```

---

## 作者：Long·J·William (赞：3)

代码短才是真理。

碰上一些情况要跪，但AC没问题。

贪心思路：输入第一行数据，记录最大航程，输入加油站数据，跑不到就输出那个啥，

而后进函数，x是第几站，而后一个循环，get（a=所能到达的站的序号+1），

而后又一个循环，找到比出发站（x）油价低的一站作为下一个停靠站，

如果没有，就去能去的最远的一站（b），这时要记录下yl（生育汽油可跑路程），对，这次要加满油，

这样，一直跑到终点站（n+1）。

Ps：如果b的油价很高，而（x，b）之间又有一个只比x站油价贵一点的站，就呵呵了。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double d[110],p[110],cd,cl,zh,my,zhc,yl=0;
int n;
void hx(int x){
if(x==n+1) return;
double hc=0;
int a=x,b=x+1,pd=1;
do{
++a;
hc=d[a]-d[x];
if(a==n+2) break;
}while(hc<=zh);
for(int i=x+1;i<a;i++){
b=i;
if(p[i]<p[x]&&i<=n+1) {pd=0;break;}
}
my+=(d[b]-d[x]-yl)*p[x];
if(pd) {yl=zh-d[b]+d[x];my+=yl*p[x];}
else yl=0;
hx(b);
}
int main(){
scanf("%lf%lf%lf%lf%d",&zhc,&cl,&cd,&p[0],&n);
zh=cd*cl;d[n+1]=zhc;
for(int i=1;i<=n;i++){
cin>>d[i]>>p[i];
if(d[i]-d[i-1]>zh){
printf("No Solution");
return 0;
}
    }
    hx(0);
    printf("%.2lf\n",my/cd);
    return 0;
}
PS：第一次在洛谷发题解，这么多回车是什么鬼。删了好久的说。
```

---

## 作者：Posser (赞：3)

一开始思路出错了，改了我好久，刚开始以为是dfs，结果wa到我吐了去，不多说，先上我75分dfs代码
```cpp
#include <iostream>
#include <algorithm>

using namespace std;
double d1, c, d2, p;
int n;
const int _size = 15;
double pr[_size];
double d[_size];
double maxRun;
double ans = 1000000.0;

bool check()
{
	for (int i = 1; i <= n; i++)
		if (d[i] - d[i - 1] > maxRun)
			return false;
	if (d1 - d[n] > maxRun) 
		return false;
	return true;
}

void dfs(double cost, int pos, int cd)
{
	if (pos >= n)
	{
		ans = min(ans, cost + (d1 - d[pos]) / d2 * pr[pos]);
		return;
	}
	for (int i = pos + 1; i <= n; i++)
	{
		double dd = (d[i] - d[pos]);
		double add = dd / d2 * pr[pos];
		if (dd <= maxRun)
			dfs(cost + add, i, d1 - d[i]);
	}
	if ((d1 - d[pos]) <= maxRun)
		ans = min(ans, cost + (d1 - d[pos]) / d2 * pr[pos]);
	//printf("%.2lf\n", ans);
}

int main()
{

	cin >> d1 >> c >> d2 >> pr[0] >> n;
	for (int i = 1; i <= n; i++)
		cin >> d[i] >> pr[i];
	maxRun = d2 * c;
	if (!check()) puts("No Solution");
	else
	{
		dfs(0.0, 0, d1);
		printf("%.2lf\n", ans);
	}
	return 0;
}
```

改到我晕也就只有75分， 没办法，去看了一下大佬们的思路，结果就看了一行就看到了**贪心**。我只想说，把孩子的心都伤得完完的，说多都 是泪同，上ac代码
```cpp
#include <iostream>
#include <algorithm>

using namespace std;
double d1, c, d2, maxRun;
int n;
double  d[15], p[15];
double ans;

//检查是否存在不可达的情况
bool check()
{
	for (int i = 1; i <= n; i++)
		if (d[i] - d[i - 1] > maxRun)
			return false;
	if (d1 - d[n] > maxRun)
		return false;
	return true;
}

//得到下一个加油站的位置下标
int getNextPos(int pos, double maxD)
{
	int minPos = pos + 1;
	for (int i = pos + 1; i <= n; i++)
	{
		double dd = d[i] - d[pos];
		if (maxD < dd) break;
		if (p[minPos] >= p[i]) minPos = i;
	}
	return minPos;
}

//得到答案
double getAns()
{
	double cost = 0.0, cd = 0.0;
	int pos = 0;
	while (true)
	{
		if (pos == n) //在最后一个加油站
		{
			cost += (d1 - d[pos] - cd) / d2 * p[pos];
			break;
		}
		int nextPos = getNextPos(pos, d[pos] + maxRun);
		if (p[pos] > p[nextPos]) //目标油站的价格更低
		{
			cost += (d[nextPos] - d[pos] - cd) / d2 * p[pos];
			cd = 0.0;
			pos = nextPos;
		}
		else if (d[pos] + maxRun >= d1) //当前油站的价格最低，且可以直接到终点
		{
			cost += (d1 - d[pos] - cd) / d2 * p[pos];
			break;
		}
		else //当前油站的价格最低，但不能直接到终点
		{
			cost += (maxRun - cd) / d2 * p[pos];
			cd = maxRun - (d[nextPos] - d[pos]);
			pos = nextPos;
		}
	}
	return cost;
}

int main()
{
	cin >> d1 >> c >> d2 >> p[0] >> n;
	for (int i = 1; i <= n; i++)
		cin >> d[i] >> p[i];
	maxRun = c * d2;
	if (!check()) puts("No Solution");
	else  printf("%.2lf\n", getAns());
	return 0;
}
```

---

## 作者：hibiki (赞：3)

简单的贪心+递归

简单思路：

1、先判断下一个目的地，再计算油费和加的油

2、如果当前已经在最后一个加油站并且加满油仍然走不到终点则输出No Solution

3、每次在可以走到的范围内找油费最小的加油站

2.1如果该加油站的油费当前所在地点的油费要便宜，就加恰好能开到该加油站的油

2.2否则判断能否开到终点，如果能则加恰好能开到终点的油，否则加满油

4、进行第2步的同时，寻找可以走到的最远的加油站，如果最远的加油站就是当前所在地点且当前不在终点的话输出No Solution

5、如果最远可以走到的最远的加油站是终点，就输出答案。

[color=red]代码：[/color]

[codep ]

```cpp
Var
    d1,d2,c,p:real;
    i,n:longint;
    dist,price:array[0..100000] of real;
Procedure work(nowloc:longint;restfuel,ans:real); //nowloc储存了当前位置, restfuel储存了当前剩余的油, ans储存了当前花费的预算
    var
        i:longint;
        minloc,maxfar:longint;
    begin
        if dist[n+1]-dist[n]>c*d2 then begin // 上文的步骤2
            writeln('No Solution');
            halt;
        end;
        minloc:=nowloc; //将价格最便宜的加油站和能走到的最远距离都初始化为当前地点
        maxfar:=nowloc;    
        for i:=nowloc+1 to n+1 do begin //遍历所有加油站
            if ((dist[i]-dist[nowloc])/d2)>c then break; //如果即使油箱满也无法走到则停止遍历
            maxfar:=i; //每次将该点更新为能走到的最远的点
            if price[i]<=price[minloc] then minloc:=i; //如果当前点的油费低于之前最便宜的加油站的油费则更新
        end;
        if ((maxfar=nowloc) and (nowloc<>n+1)) then begin //如果能走到的最远点是当前点且当前不在终点，则代表无法前进，退出
            writeln('No Solution');
            halt;
        end;
        if minloc=nowloc then begin //如果油费最便宜的地方是当前点，则判断是否能走到终点
            if ((dist[n+1]-dist[nowloc])/d2)<=c then begin //如果能走到终点则加恰好走到终点的油
                ans:=ans+((dist[n+1]-dist[nowloc])/d2-restfuel)*price[nowloc];
                writeln(ans:0:2);
                halt;
            end
            else begin //否则加满油
                ans:=ans+(c-restfuel)*price[nowloc];
                restfuel:=c-(dist[maxfar]-dist[nowloc])/d2; //将剩余油量减去走到最远能走到的点花费的油
                if maxfar=n+1 then begin //如果最远能走到的点是终点就输出
                    writeln(ans:0:2);
                    halt;
                end;
                    work(maxfar,restfuel,ans); //递归
                    exit;
            end;
        end;
        if minloc>nowloc then begin //如果存在更便宜的点则走到那个加油站
            ans:=ans+((dist[minloc]-dist[nowloc])/d2-restfuel)*price[nowloc]; //加恰好能走到那个加油站的油
            restfuel:=0; //因为是恰好走到所以剩余的油一定是0
            if minloc=n+1 then begin //如果最便宜的点是终点则退出（回过头来看这段判断并没有意义）
                writeln(ans:0:2);
                halt;
            end;
            work(minloc,restfuel,ans); //递归
            exit;
        end;
    end;
Begin
    read(d1,c,d2,p,n); //读入
    dist[0]:=0; //先将起点距离初始化为0
    dist[n+1]:=d1; //将终点距离初始化为d1。
    price[0]:=p; //将起点的价格初始化为p
    price[n+1]:=maxlongint; //将终点价格设置为maxlongint(防止上文中认为终点是最便宜的点)
    for i:=1 to n do //正常读入
        read(dist[i],price[i]);
    work(0,0,0); //从起点为0，花费为0，剩余油量为0开始递归
End.
```
[/codep ]

---

## 作者：Alex_Cui (赞：2)

这题妥妥的贪心嘛, 我们整理下题目:

首先对于每一个加油站来说, 我们可以知道的信息是到上一个加油站(或起点)的距离, 以及本加油站的油钱. 对于车来说我们知道车最多能加多少油, 以及每升油能开多远.

最终要得到的结果是这辆车最少能花多少钱, 或者这辆车半路就没油了.

那么我们假设我们现在在任意一个加油站(假设是第 $i$ 个), 为了节省任意油费, 自然要选最便宜的油, 到开到这个加油站为止, 我们可以加油的点有 $i$ 个(包括起点), 我们需要选取其中油费最便宜的加足够开到下一个加油站的油即可.

但是需要额外考虑的一个问题就是油箱是有大小的(当然加油站你可以视为无限油桶), 也就是说一个加油站最多最多也只能加你车油箱的容量的油(不然就是犯规操作的了嘛). 假如说这个加油站以及加过了一油箱的油了, 那么车子在那个加油站就不可能再加油了. 我们就要考虑到另一个加油站加油了, 而那个加油站就是除去这个加油站以外的油钱最便宜的加油站了.

当然这个前提是在有别的可加油的加油站的情况的, 如果没有了呢, 就说明没地方加油了, 没油了, 车就开不了了, 直接输出"No Solution"

然后整理完解法后我们发现, **所有的基于当前的加油站的运算和之后的数据完全无关, 只和之前的数据有关**, 所以我们采取边输入, 边运算的方法.

**由于我们的数据都是依次输入得到的**, 所以我们采用**插入排序**, 用来得到最便宜的加油站, 如果这个加油站不能再加油了, 我们就删去这一项.

注意: 最后一段路(最后一个加油站(或起点)到终点)是没有输入的(终点的距离就是路程的距离), 所以我们要单独拿出来再运算, 不能漏掉.

```cpp
#include <iostream>
#include <iomanip>
#include <list>

struct Station {
	double added_oil; // 该加油站加过的油
	double oil_price; // 该加油站的汽油单价
};

void insert(std::list<Station> &list, double oil_price) {
	for (std::list<Station>::iterator iter = list.begin(); iter != list.end(); ++iter) {
		if (iter->oil_price > oil_price) {
			list.insert(iter, { 0.0, oil_price });
			return;
		}
	}
	list.push_back({ 0.0, oil_price });
}

int main() {
	double d1, d2, c, p;
	int n;
	std::cin >> d1 >> c >> d2 >> p >> n;
	std::list<Station> stations;
	stations.push_back({ 0.0, p });

	double distance, oil_price, last_distance = 0.0, oil_require, money = 0.0, oil_remaining;
	std::list<Station>::iterator iter;
	for (int i = 1; i <= n; ++i) {
		std::cin >> distance >> oil_price;
		oil_require = (distance - last_distance) / d2; // 需要的油量
		iter = stations.begin();
		while (oil_require) {
			oil_remaining = c - iter->added_oil;
			if (oil_require < oil_remaining) { // 当前最便宜的加油站可加的油还足够加
				iter->added_oil += oil_require;
				money += oil_require * iter->oil_price;
				break;
			}
			else { // 不够加了
				oil_require -= oil_remaining; // 缺少的油
				money += oil_remaining * iter->oil_price;
				stations.erase(iter); // 删除当前选择的加油站
				if (stations.empty()) { // 没有可用的加油站
					std::cout << "No Solution" << std::endl;
					return 0;
				}
				iter = stations.begin();
			}
		}
		last_distance = distance;
		insert(stations, oil_price);
	}

	// 这一段和上面for一样, 唯一的区别就是没有输入, 主要是我懒得封装一个函数传参了, 就直接复制了
	oil_require = (d1 - last_distance) / d2;
	iter = stations.begin();
	while (oil_require) {
		oil_remaining = c - iter->added_oil;
		if (oil_require < oil_remaining) {
			iter->added_oil += oil_require;
			money += oil_require * iter->oil_price;
			break;
		}
		else {
			oil_require -= oil_remaining;
			money += oil_remaining * iter->oil_price;
			stations.erase(iter);
			if (stations.empty()) {
				std::cout << "No Solution" << std::endl;
				return 0;
			}
			iter = stations.begin();
		}
	}
	
	std::cout << std::setprecision(2) << std::fixed << money << std::endl;
	return 0;
}
```



---

## 作者：G_A_TS (赞：2)

## 贪心题  
同步发布于[My blog](https://www.cnblogs.com/wzzorz/articles/10316545.html)  
[贪心算法](https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800?fr=aladdin)  
可以证明，**在一般情况下**，可以找身前最小点，然后算**总量+=（两点距离）/每升油跑的路程 乘上 此点油价**  
**但是！**  
我是说**“在一般情况下”**  
我此前WA了一个点 _75_ 分  
理由是没有考虑前点价小于后点能到达的所有价  
此时应该考虑把油加满，用nspc和lnspc记录箱内油量  
可是问题并未结束，如果不加满就可以到终点怎么办？~~此时就要看我代码了~~  
关于~~出现三次的~~goto：[这里科普](https://baike.baidu.com/item/goto%E8%AF%AD%E5%8F%A5/7603004?fr=aladdin)  
~~我相信我的变量命名简洁易懂~~  
应该看得懂的蒟蒻的代码：  


------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,now,bj;
double S,spc,perS,v[10],dis[10],total,nspc,tem,lnspc;
//S路程，perS每升路程，v价格，dis路程，spc=spc，nspc=nowspace，lnspc=lastnowspace
int find_cheapest(int x,int y)
{
	double maxx=1001;
	int maxn=0;
	for(int i=x;i<=y;i++)
	{
		if(v[i]<maxx)
		{
			maxx=v[i];
			maxn=i;
		}
	}
	return maxn;
}
int main()
{
	//freopen("travel.in","r",stdin);
	//freopen("travel.out","w",stdout);
	cin>>S>>spc>>perS>>v[0]>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>dis[i]>>v[i];
	}
	dis[n+1]=S;
	v[n+1]=9999;//将终点视为n+1
	n++;
	for(int i=1;i<=n;i++)//排除到达不了的情况 
		if((dis[i]-dis[i-1])/perS>spc)
		{
			cout<<"No Solution";
			return 0;
		}
	for(;;)//不到终点非好汉，所以使劲跑，反正排除了No Solution
	{
		for(int j=n;j>=now+1;j--)
		{
			int tmp=find_cheapest(now+1,j);//找身前最小点
			if(v[tmp]>v[now])//我说的WA掉的关键，判断与当前点油价比是否更小
			{
				nspc=spc;
				bj=1;
				goto Wzz;//玄学的跳法。。。只能慢慢体会
				Orz:
				total+=nspc*v[now];
				nspc-=(dis[tmp]-dis[now])/perS;
				lnspc=nspc;
				now=tmp;
			}
			else
			{
				bj=0;
				if((dis[tmp]-dis[now])/perS<=spc)
				{
					tem=(dis[tmp]-dis[now])/perS;
					total+=(tem-nspc)*v[now];
					nspc=0;
					now=tmp;
					Wzz:
					if(spc*perS>=dis[n]-dis[now])
					{
						total+=((dis[n]-dis[now])/perS-lnspc)*v[now];
						goto stop;//stop用来跳出循环输出结果
					}
					else
					{
						if(bj==1)
							goto Orz;
					}
					break;
				}
			}	
		}			
	}
	stop:
	printf("%.2lf",total);
	return 0;
}
```

---

## 作者：一条咸鱼 (赞：2)

因为不会优先队列，所以想了这个比较简单易懂的方法，个人认为代码还是很简单明了的。

算法和思想写在注释里了

直接粘上代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
double d1,c,d2;
int n;
struct oil {
    double p,len,over;//每个加油站油的价格，距离，和加满油超过这个加油站的距离
}a[125];
double tot;
int main(){
    scanf("%lf%lf%lf%lf%d",&d1,&c,&d2,&a[0].p,&n);
    double Max=c*d2;
    for(int i=1;i<=n;i++){
        scanf("%lf%lf",&a[i].len,&a[i].p);
        if(Max<a[i].len-a[i-1].len){cout<<"No Solution";return 0;
        //如果加满油开不到下一个加油站 结束
        }
    }
    a[0].len=0;
    a[n+1].len=d1;//终点距离
    int j=1;//下一次到达的加油站
    int i=0;//本次到达的加油站
    while(i!=n+1)//一开始用[0,n+1]的for循环，但是发现不对
        {
        double s=0;//前往下一个加油站的距离
        while(s<=Max&&j<=n&&(a[j].p>=a[i].p))//开到下一个油价比本站的便宜的加油站
        {
            j++;
            s+=a[j].len-a[j-1].len;
        }
        if(s<=Max){//如果能开到的话
            if(a[i].over>=a[j].len-a[i].len)a[j].over=a[i].over-a[j].len+a[i].len;
            //剩余的油足够开到下一个加油站
            else {
                //如果不够，在本站加油到正好能开到下一个加油站
                tot+=(a[j].len-a[i].len-a[i].over)/d2*a[i].p;
                a[j].over=0;
            }
        }
        else{
            //如果加满油开不到下一个便宜的加油站
            tot+=(Max-a[i].over)/d2*a[i].p;
            //在本站加油到开到下一个加油站
            j=i+1;
            a[j].over=Max-(a[j].len-a[i].len);
        }
        i=j;//到达加油站
    }
    printf("%.2lf",tot);
    //system("pause");
    return 0;
}

```

---

## 作者：曹有毒 (赞：2)

我用的是非常简单粗暴的模拟+贪心

贪心的基本思路 之前的各位dalao已经讲的非常明白 我就不多说明了

我跟他们不一样的地方在于  遍历每一站  每一站都把油箱中价格大于p[i]的油换成价格为p[i]的油

只在消耗油时更新cost

下面贴上蒟蒻的辣鸡代码

库和namespace

~~~cpp
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
```
~~~
用到的结构体和变量

~~~cpp  //oil是油箱中的油 是一个单调队列  由head向tail价格递增

       
```cpp
struct oil{
       double p,amo;
  }o[500];
struct stop{  // stop是每一站的距离和油价
       double d,p;   //d我处理成了两站之间间隔的距离
  }st[500];
double dis;   //当前已走的距离
double cost;   //当前花费的代价
int head=0,tail=-1;   //单调队列头尾
//因为我在每一站都将油箱补满  所以不需要贮存当前油量
```
~~~
用到的各种函数

~~~cpp

    
         
            
        
        


```cpp
bool  cmp(const stop & a,const stop &b){
    return a.d<b.d;    
}    //stop的比较函数 将离起点近的放在前面 （脑残）
void use(double d){  //消耗油    
    bool pd=1;
    while(pd){     //从便宜的（head）开始消耗
        if(d>=o[head].amo){       //如果d大于等于head  则把head的油消耗完
            d-=o[head].amo;
            cost+=o[head].amo*o[head].p;   //更新cost
            head++;
        }
        else if(d<o[head].amo){    //只将head的油消耗了一部分
            o[head].amo-=d;
            cost+=d*o[head].p;     //更新cost
            pd=0;    
        }
    }
    return ;    
}
void add(double d,double p){    //加油函数
    while(o[tail].p>p){   //如果tail的油价格大于当前pi   就将tail的油替换成当前油
        d+=o[tail].amo;    //将d累加
        tail--;
        if(head>tail)break;    
    }
    tail++;
    o[tail].amo=d;
    o[tail].p=p;
    return ;
}
```
~~~
主函数

~~~cpp
    
    
            
    

            

            
        
                
    
    

```cpp
int main(){
    double d1,c,d2,p;
    int n;
    scanf("%lf%lf%lf%lf%d",&d1,&c,&d2,&p,&n);   
    for(int i=1;i<=n;++i){
            scanf("%lf%lf",&st[i].d,&st[i].p);   
    }
    sort(st+1,st+1+n,cmp);
    for(int i=n;i>=1;--i){
            st[i].d-=st[i-1].d; //将d[i]处理成  两油站间距离（个人习惯  不处理也可）
    }
    add(c,p);  //在起点加满
    for(int i=1;i<=n;++i){
        if(dis+st[i].d<d1){    //这里不解释if  下文会解释
            double cc=(st[i].d)/d2;  //cc为 这次旅程需要消耗的油量
            if(c>=cc)    use(cc);    
            else  {printf("No Solution");return 0;}  //如果需要消耗的油量大于油箱容量 很明显no solution
            dis+=st[i].d;   //累加dis   这是我的习惯带来的代价..
            add(c-cc,st[i].p);  //将油补满        
               }
        else if(dis+st[i].d>=d1){     //如果在到达下一油站前先到达重点
            double cc=(d1-dis)/d2;
            if(now>=cc)    use(cc);
            else {printf("No Solution");return 0;}
            printf("%.2lf",cost);
            return 0;
        }    
    }
            //如果终点在所有油站之后  example：样例
    double cc=(d1-dis)/d2;
    if(c>=cc)    use(cc);
    else{ printf("No Solution");return 0;}
    printf("%.2lf",cost);
    return 0;
}
```
~~~
THE EHD


---

## 作者：xiejinhao (赞：2)

## 我承认以下是Dalao的思路
### 但是，为了总结经验，我决定把这篇题解写出来
这个题目考的就是贪心吧，貌似没有其他的什么了 ~~（除了队列操作？）~~

贪心思路：

1. 经过当前加油站，加满油可以到下下站，那么这一站和下下站中间的那一站可以舍去，本站入队；
1. 如果即使在本站加满油，也无法到达下下站，那么我们一定要经过下一站，在此时分情况取最优解；
1. 如果有一站即使加满了油也无法到达下一站，那就是无解；

以上是预处理；

4. 预处理完成后，我们舍掉了一部分加油站，我们用队列存储了可以“直达”的加油站，现在剩下两种情况：

**第一种：“下一站”的油更贵；**

**第二种：“下一站”油更便宜；**

- 如果下一站更贵，那我们就在当前站加满，并记录油箱到了下一站之后还剩多少油，然后我们更新当前的指针到下一站，这样我们就“抵达”下一站了；

- 如果下一站的油更便宜，我们在本站加的就越少越好，那么，如果油箱里省的油够我们跑到下一站，我们就把要用的油减掉,当前位置指针转向下一站，我们就“抵达”下一站了；否则，油箱里的油不够我们走到下一站，那就不得不加油，我们只要加的刚刚好就行，所以剩下的油就是0，位置指针移动，“抵达下一站”。

当然，加了多少油就要加相应的钱数，这个不用解释了；

所以以上就是本题的解题思路

完整代码：

```cpp
//认真看，杜绝抄袭 
#include<cstdio>
#include<queue>
using namespace std;
struct travel{
	double distance,pay;
}k[10];
//distance表示距离，pay表示花费 
double d1,c,d2,left,ans;
int n,temp=0,now=0;//temp  now用途往下看； 
queue<int> q;
int main()
{
	scanf("%lf %lf %lf %lf %d",&d1,&c,&d2,&k[0].pay,&n);
	//第一次输入的油价花费是起点的油价， 直接存入 
	for(int i=1;i<=n;i++)
	{
		scanf("%lf %lf",&k[i].distance,&k[i].pay);
	}
	k[0].distance=0;
	k[n+1].distance=d1;//到达终点的距离 
	k[n+1].pay=0x3f3f3f3f;
	//看下面代码就知道了，这边必须枚举到n+1，否则第n个加油站可能要经过却没有被存入 
	//所以到 n+1(即终点) 虽然不用加油，但终点的油价也要赋一个最大值，避免误判和死循环，后面计算时恢复成0 
	
	for(int i=1;i<=n+1;i++)
	{
		if(k[i].distance-k[i-1].distance>c*d2)//加满油都到不了，无解 
		{
			printf("No Solution");
			return 0; 
		}
		else if(k[i].distance-k[temp].distance<=c*d2 && k[i].pay<k[temp].pay)
		//这里的temp指针指向本站，而i却会指向下下站，仔细思考下为什么？ 
		{
			q.push(i);
			temp=i;//更新本站位置； 
		}
		else if(k[i].distance-k[temp].distance>c*d2)//如上，没办法到下下站，或者是下下站比这站更贵(贪心) 
		{
			q.push(i-1);//那么这站是要取的，进 
			temp=i-1;//指针移动到下一站； 
			i--;
			//保证i指针不是指向下下站，而是指向下一站
			//(每次循环i都会自加1，导致进入下下站，这样就可以抵消了) 
		}
		//解答上面的疑问：
		//如果上面的3个if都没有执行，那指针就指向下下站了； 
	}
	q.push(n+1);k[n+1].pay=0;
	//最后终点也要到达，n+1也算一站，进；同时恢复到终点的油价为0，避免出错； 
	while(!q.empty())
	{
		int x=q.front();q.pop();//出发去“下一站”，“下一站”出队
		//贪心过程： 
		if(k[x].pay>k[now].pay) //“下一站”更便宜 
		{
			ans+=c*k[now].pay;//钱记得加，油不是免费的~ (下同)
			left=c-(k[x].distance-k[now].distance)/d2;
		}
		else //否则就要讨论 
		{
			double need=(k[x].distance-k[now].distance)/d2;
			if(left>=need)//剩下的油够，那么不用加油 
			{
				left-=need;
			}
			else//剩下的油不够，那么还要加油，加到刚好能到下一站就行 
			{
				ans+=(need-left)*k[now].pay;//同上，油钱加上 
				left=0;
			}
		}
		now=x;//“抵达”下一站 
	}
	printf("%.2lf",ans);//保留两位小数 
	return 0;
} 
```

这次就是总结经验吧~（以及表示对Dalao的膜拜）


---

## 作者：Nuclear_Missile (赞：2)

# 这个题好像是纯模拟, 我的第一篇题解就拿这个题写吧
## 这个题有以下几点要注意
### 1.把起点看成加油站
### 2.按照加油站离起点距离排序
### 3.找到下一个最便宜且油箱装满能到达的加油站, 找不到如果能直接到终点就break, 不行就直接"No Solution"
### 4.看目前加油站和找到的加油站哪个便宜, 这个便宜就加到离终点最近的地方(看能不能直接到终点), 那个便宜就加到那个加油站
### 5.行驶到那个加油站
### 6.重复 3 - 5 , 最后输出答案


这里放我的ac代码, 由于我时间不足够一次性写完, 就写了很多注释, 方便我下次写起来能想起来上次写啥了. 注释还能方便改代码, 按照制定的策略完成, 建议大家每次都写注释. 另外, 我变量名几乎都是"拼音在手, 命名随手", 所以, emmmm, 大家会看的方便一点
------------
```cpp
//luogu p1016 ac
#include <stdio.h>
#include <algorithm>
//     总距离    邮箱容量   行驶消耗油 第一个的油价
double zongjuli, rongliang, xingshi, jiage;
int n; //加油站个数
//目前距离 目前油量 目前价格(答案)
double now, you, ans;
struct station {
	// 起点距离   油价
	double juli, jiage;
	inline bool operator<(const station& s1) const { //比较, 看距离
		return juli < s1.juli;
	}
} stations[505];
inline int getnextpos(int index) { //找到下一个能到达的价格最小的加油站
	if (stations[index].juli > rongliang * xingshi + now || index >= n) //无法找到下一个
		return -1;
	int ret = index;
	for (int i = index + 1; i < n; i++) {
		if (rongliang * xingshi + now < stations[i].juli) //到不了
			break;
		if (stations[i].jiage < stations[ret].jiage) //小则更新
			ret = i;
	}
	return ret;
}
int main() {
	scanf("%lf %lf %lf %lf %d", &zongjuli, &rongliang, &xingshi, &jiage, &n);
	for (int i = 0; i < n; i++)
		scanf("%lf %lf", &stations[i].juli, &stations[i].jiage);
	//把起点看成加油站
	stations[n++] = { 0, jiage };
	//按距离排序
	std::sort(stations, stations + n);
	int index = 0; //现在在的加油站, 开始为起点
	for (; now < zongjuli; ) {
		//找到下一个加油站
		int tmp = getnextpos(index + 1);
		//判断在哪加油
		if (tmp == -1) {
			//油箱够到终点则退出
			if (you * xingshi + now >= zongjuli)
				break;
			//如果油箱满能到达则加够
			if (rongliang * xingshi + now >= zongjuli) {
				//加够
				//    加入油量
				double jiaru = (zongjuli - stations[index].juli - you * xingshi) / xingshi;
				ans += jiaru * stations[index].jiage;
				break;
			}
			//无法到达
			puts("No Solution");
			return 0;
		}
		if (stations[index].jiage < stations[tmp].jiage) { //这里便宜
			if (now + rongliang * xingshi >= zongjuli) {
				//加够
				//    加入油量
				double jiaru = (zongjuli - stations[index].juli - you * xingshi) / xingshi;
				ans += jiaru * stations[index].jiage;
				break;
			}
			else {
				//加满
				ans += (rongliang - you) * stations[index].jiage;
				you = rongliang;
			}
		}
		else { //那里便宜
			//加到那个加油站
			//juli = you * xingshi     jiaruqian = you * jiage
			//if (you * xingshi < stations[tmp].juli - stations[index].juli) {
			//    加入油量
			double jiaru = (stations[tmp].juli - stations[index].juli - you * xingshi) / xingshi;
			ans += jiaru * stations[index].jiage;
			you += jiaru;
			//}
		}
		//行驶到下一个加油站
		now = stations[tmp].juli;
		you -= (stations[tmp].juli - stations[index].juli) / xingshi;
		if (you < 0) //小数可能有精度问题
			you = 0;
		index = tmp; //更新现在位置
	}
	printf("%.2lf", ans);
	return 0;
}
```



---

## 作者：mureZ (赞：2)

这么复杂的题目，难写的贪心，复杂的判定，不如～～
# 暴搜 #
所以下面我们用dfs实现
考虑数据量最多只有6站 dfs 5ms以内都可以出解
直接上代码 讲解在注释内
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define N 10 //数据范围是6所以10就够了
#define INF 19260.817 //暴力最大值
using namespace std; //std党
double d1,c,d2,p;
int n;
double ans=INF;
struct po{//用结构保存好处理
	double dis,v;
}a[N];
bool dfs(int s,double cnow,double cost){
	//s是当前站，我们令出发城市是0，终点城市是n+1
    //cnow是当前油箱油量
	//cost是当前花费
	if (s==n+1){//如果搜到终点城市就更新答案并退出
		ans=min(ans,cost);
		return 1;
	}
	bool flag=0;
	double maxdis=c*d2;//目前最大的距离范围
    //搜索树1
    //这是把油箱加满的情况
	double tcost=(c-cnow)*a[s].v;//油箱加满的花费
	for (int i=n+1;i>s;i--){//从终点开始暴搜
		if (a[i].dis-a[s].dis>maxdis) continue;//弱鸡剪枝
		if (dfs(i,cnow-(a[i].dis-a[s].dis)/d2,cost+tcost))
			flag=1;
	}
    //搜索树2
    //这是把油箱加到刚好到达下一个加油站的情况
	for (int i=n+1;i>s;i--){
		if (a[i].dis-a[s].dis>maxdis) continue;
		double tcost=(a[i].dis-a[s].dis)/d2*a[s].v;
		if (dfs(i,cnow-(a[i].dis-a[s].dis)/d2,cost+tcost))
			flag=1;
	}
	if (!flag) return 0;//如果没有一个节点可以到达终点，返回否
	return 1;
}
int main(){
	cin>>d1>>c>>d2>>p>>n;//输入d1,c,d2,p,n
	a[0].dis=0,a[0].v=p;
	a[n+1].dis=d1;
    
	for (int i=1;i<=n;i++)
		cin>>a[i].dis>>a[i].v;//输入加油变量
        
	if (dfs(0,0,0))//开始搜索
		printf("%.2f",ans);//答案四舍五入
	else cout<<"No Solution"<<endl;
	return 0;
}
```

暴力の结束了
无注释45行 也应该算短又好写的

---

## 作者：Elsa_Granger (赞：2)

各种解释都伴随在注释里面了

```cpp
//Copyright (C) 2017 Elsanna
//License:GPL
//Author:Elsanna

#include <string.h>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <iomanip>
using namespace std;

//Summary:
//    在开始前，进行判断，能不能到达最近的加油站，如果不行，No solution
//    在当前节点开始往后搜索，如果后面的节点没有比当前结点的单价便宜的，就在当前结点加满油，到达能到达的最便宜的节点那
//        如果有比当前结点便宜的，那么就在当前结点加有加到刚刚好能到那个油站
//            要求到里离当前结点最近的，比当前结点便宜的
int main() {
    //Init

    //
    double distance_tmp, capacity, dis_per_liter, price[101];
    int n_station;
    cin >> distance_tmp >> capacity >> dis_per_liter >> price[0] >> n_station;
    double distance[101];
    distance[0] = 0;
    distance[n_station + 1] = distance_tmp;

    for (int i = 1; i <= n_station; i++) {
        cin >> distance[i] >> price[i];
    }
    double usage = 0.0;

    //left_oil_capacity放错位置进行初始化了
    double left_oil_capacity = 0.0;

    for (int current_pos = 0; current_pos <= n_station;) {

        //最近的站台都到不了
        if (capacity*dis_per_liter < distance[current_pos + 1] - distance[current_pos]) {
            cout << "No Solution" << endl;
            return 0;
        }
        double min_price_forward = 0xffff;
        
        int min_price_forward_station = current_pos + 1;
        bool found_less_price = false;
        for (int next_pos = current_pos + 1; next_pos <= n_station + 1; next_pos++) {
            //保证能到下一个节点，否则就跳出
            if (capacity*dis_per_liter < distance[next_pos] - distance[current_pos]) {
                break;
            }

            //更新最近更便宜的节点
            if (price[next_pos] < min_price_forward) {
                min_price_forward = price[next_pos];
                min_price_forward_station = next_pos;
                //如果有比当前结点便宜的或者相等的
                if (price[next_pos] <= price[current_pos]) {
                    //加到刚刚好即可
                    usage += ((distance[next_pos] - distance[current_pos]) / dis_per_liter - left_oil_capacity)*price[current_pos];
                    left_oil_capacity = 0;

                    //到更便宜的节点那

                    //found_less_price便于判断是否找到了更少油价的节点
                    found_less_price = true;
                    current_pos = next_pos;
                    break;
                }
            }
            if (next_pos == n_station + 1) {
                //未来节点没有一个比当前结点便宜的
                //并且终点可以直接到达
                //那么直接加到刚刚够到达的容量即可
                if (min_price_forward > price[current_pos]) {
                    //这一部分要用等宽字体来看
                    //↓使用费用                 两点距离↓                                       减去还留下的油↓            单价↓
                    usage += ((distance[next_pos] - distance[current_pos]) / dis_per_liter - left_oil_capacity)*price[current_pos];
                    //到达终点

                    cout << setiosflags(ios::fixed) << setprecision(2) << usage << endl;
                    //system("pause");
                    return 0;
                }
            }
        }
        if (found_less_price)continue;

        
        //对于没有的比当前结点便宜的，就加满，到最便宜的下一个节点
        usage += (capacity - left_oil_capacity)*price[current_pos];
        left_oil_capacity = capacity - (distance[min_price_forward_station] - distance[current_pos]) / dis_per_liter;
        

        current_pos = min_price_forward_station;
    }
    cout << setiosflags(ios::fixed) << setprecision(2) << usage << endl;

    return 0;
}
```

---

## 作者：YZL11111 (赞：1)

题目链接：https://www.luogu.com.cn/problem/P1016

## 【题目描述】
一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格P和沿途油站数N（N可以为零），油站ii离出发点的距离Di、每升汽油价格Pi（i=1,2,…,N）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。

## 【输入格式】
第一行，D1，C，D2，P，N。

接下来有N行。

第i+1行，两个数字，油站i离出发点的距离Di和每升汽油价格Pi。

## 【输出格式】
所需最小费用，计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。

## 【解题思路】
借助（https://www.luogu.com.cn/discuss/show/134434）的思想

本题考虑贪心+dfs

具体看注释

## 【AC代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node
{
	double d, t;  //d代表距离，t代表邮费
	bool operator < (const node& b)const
	{
		if (d == b.d) return t < b.t;
		return d < b.d;
	}
}a[10];  //记录站点信息
int n;
double ans, d1, c, d2, p;
inline void dfs(int pos, double tot, double rest)  //pos指当前所在站点编号，tot指目前花费，rest代表剩余油量
{
	if (pos == n + 1)  //结束条件为到达终点
	{
		ans = min(ans, tot);  //更新答案
		return;
	}
	for (int i = pos + 1; i <= n + 1; ++i)  //从当前站点往后搜
	{
		if (a[i].d - a[pos].d <= c * d2)  //如果i站点加满油也到不了直接return
		{
			if (a[i].t > a[pos].t) dfs(i, tot + (c - rest) * a[pos].t, c - (a[i].d - a[pos].d) / d2); 
            //如果下一个站点油贵，在当前站点把油加满
			else  //如果下一个站点邮费便宜，考虑在当前站点尽量少买油（贪心）
			{
				if (rest * d2 >= a[i].d - a[pos].d) dfs(i, tot, rest - (a[i].d - a[pos].d) / d2);  //如果剩余油量能到下一站点，不加油
				else dfs(i, tot + ((a[i].d - a[pos].d - rest * d2) / d2) * a[pos].t, 0.0); //否则将油加至刚好能到
			}
		}
		else return;
	}
}
int main()
{
	scanf("%lf%lf%lf%lf%d", &d1, &c, &d2, &p, &n);
	double temp = c * d2;
	for (int i = 1; i <= n; i++)
	{
		scanf("%lf%lf", &a[i].d, &a[i].t);
		if (a[i].d - a[i - 1].d > temp) { puts("No Solution"); return 0; }  //如果两个站点间的距离我加满油也到不了，直接return
	}
	sort(a + 1, a + n + 1);  //按照距离排序
	a[0].d = 0.0;  //设置起点
	a[0].t = p;
	a[n + 1].d = d1;  //设置终点
	a[n + 1].t = 0.0;
	ans = 0x3f3f3f3f / 1.0; //将答案初始化为无穷
	dfs(0, 0.0, 0.0);  //开始爆搜
	printf("%.2f\n", ans);
	return 0;
}
```


---

## 作者：Violette (赞：1)

## 本题变量比较多

整体思路：

在当前站的后面如果有更便宜的站，并且油够用的情况下，就到那个站。

如果一直没有这样的站，就加满油，找一个相对便宜的地方加油。

定义c_cheap数组表示在当前量以内能走到的距离且第i个加油站的油都是最便宜的时需要加的油量。

c_cur表示在下一站的剩余油量，c_spend表示到下一站需要加多少油，c_fill是c_cur和油箱最大容量c的最小值。

最后要输出price，表示最小花费。

首先，两个点之间的距离除以d2（每升汽油能行驶的距离）就是需要加几升油。

其次，在当前位置的油价比前面的油价低时，把cheap数组重新赋值（要用双重循环遍历）。

此时，c_spend等于当前位置距离起点的位置减去上一个位置距离起点的位置再除以每升汽油能行驶的距离。

如果这个数大于了油箱的容量，就输出No Solution并return 0。

否则，赋值c_fill并判断它是否大于c_cur，累加price表示最小费用，表示最后输出price。

附上代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
double d[10],pi[10];
int main()
{
    double d1,c,d2,p,pmin=1000,l=0,pz=0;
    int n;
    cin>>d1>>c>>d2>>p>>n;
    d[0]=0;
    double d0=0;
    pi[0]=p;
    double x=c*d2;
    for(int i=1;i<=n;i++){
        cin>>d[i]>>pi[i];
    }
    for(int i=1;i<=n;i++){
        if(d[i]-d[i-1]>x){cout<<"No Solution";return 0;}
    }
    int ii=0;
    while(d1-d0){
        for(int i=ii+1;d[i]-d0<=x&&i<=n;i++){
            if(pi[i]<pmin){
            pmin=pi[i];ii=i;
            }
        }
        if(pmin<=p){pz+=((d[ii]-d0)/d2-l)*p;l=(d[ii]-d0)/d2;} 
        else if(d1-d0>x)  {
            pz+=(c-l)*p;
            l=c;
        }
        else{
            pz+=((d1-d0)/d2-l)*p;break; 
        }
        l=l-(d[ii]-d0)/d2;
        d0=d[ii];
        p=pmin;
        pmin=1000;
    }
    printf("%.2lf",pz);
    return 0; 
}
```


---

## 作者：治涨的馒头 (赞：1)

这是我写的第三篇题解，可能语言~~优质~~幼稚，请dalao原谅。

看到题目，第一反应便是贪心，~~迹象很简单——**直觉**~~。

思路也是在写题中一点点构成，逐渐完善，写题时不要担心重写或是码 _BUG_ ，这也是难免的，我想这也是一个逐渐完善的过程。

### 以上为心得，下面才是正题……


#### 本题基本思路不难想：

1. 重点是每一个站点，不可能在中途任意一处考虑后面的路。~~（废话）~~
1. 下一步肯定是到一个可以抵达且在可抵达的中 _q_ 最小的站点。

想到这，便可以开始码代码了。

#### 后来，我发现一次性加油未必加满，共分两种情况：

（一) 在以这个点为起点的路程内，有比此处油价更低廉的站点，那只需加足以到达这个站点的油即可。  
（二）反之，则可以加满。（注：结束时剩余油量一点为0。）  
其对应的代码：

```cpp
for(int i = 0;i <= n + 1;i++)
    {
        for(int j = i + 1;j <= n + 1;j++)
        {
            if((road[j].d - road[i].d) > (c * d2))
            {
                b[i] = 1;		//做标记
                break;			//已经找完了，没有，便可以做上标记
            }
            if(road[j].p < road[i].p)
            {
                break;			//已找到比他小的，便直接退出
            }
        }
    }
```

#### 后来因为有两类点之分：去那只因为油箱小和去那只因为油价小。（一个是should_n,另一个是min_n)

主要的分别在类型：

```cpp
if(road[i].p < road[min_n].p && i != n + 1) {min_n = i;break;} //这里i != n + 1起到去除终点的效果,此处break必须加，因为路程一样，油价越低，消费越低，到达第一个比当前油价小的点再说。
else if(road[i].p < road[should_n].p) should_n = i;
```

以及对应处理方法：

```cpp
if(min_n != now) 												//因为min_n被改变了，所以用min_n。 
{
	ans += max((road[min_n].d - road[now].d) / d2 - lest,0.0) * road[now].p;
	lest = max(0.0,lest - (road[min_n].d - road[now].d) / d2);	//lest用于存储剩余的油。
	now = min_n;
}
else 															//反之，用should_n 
{
	if(b[now] == 1)												//被标记号的站点  老板，加满！
	ans += (c - lest) * road[now].p,lest = max(0.0,c - (road[should_n].d - road[now].d) / d2);
	else
	ans += max((road[should_n].d - road[now].d) / d2 - lest,0.0) * road[now].p,lest = max(0.0,lest - (road[should_n].d - road[now].d) / d2);
	now = should_n;
}
```

最后，献上完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double d1,c,d2,p,ans;
int n;
bool b[10];

struct haha{
    double d,p; 
} road[10];

bool hehe(haha a,haha b)		//无视这些名称，只是虚名罢了……
{
    return a.d < b.d;
}

int main()
{
    int now = 0;
    cin>>d1>>c>>d2>>p>>n;
    for(int i = 1;i <= n;i++)
    cin>>road[i].d>>road[i].p;
    sort(road + 1,road + 1 + n,hehe);
    road[0].d = 0,road[0].p = p;
    road[n + 1].d = d1,road[n + 1].p = 0;
    for(int i = 0;i <= n + 1;i++)
    {
        for(int j = i + 1;j <= n + 1;j++)
        {
            if((road[j].d - road[i].d) > (c * d2))
            {
                b[i] = 1;
                break;
            }
            if(road[j].p < road[i].p)
            {
                break;
            }
        }
    }
    double lest = 0;
    while(now != n + 1)
    {
        int min_n,should_n;
        min_n = now;
        should_n = now + 1;
        for(int i = now + 1;i <= n + 1;i++)
        {
            if((road[i].d - road[now].d) > (c * d2))
            {
                if(i == now + 1){
                    cout<<"No Solution";
                    return 0;
                }
                break;
            }
            if(road[i].p < road[min_n].p && i != n + 1) {min_n = i;break;} //这里i != n + 1起到去除终点的效果,此处break必须加，因为路程一样，油价越低，消费越低，到达第一个比当前油价小的点再说。
            else if(road[i].p < road[should_n].p) should_n = i;
        }
        if(min_n != now) //因为min_n被改变了，所以用min_n。 
        {
            ans += max((road[min_n].d - road[now].d) / d2 - lest,0.0) * road[now].p;
            lest = max(0.0,lest - (road[min_n].d - road[now].d) / d2);
            now = min_n;
        }
        else //反之，用should_n 
        {
            if(b[now] == 1)
            {
                ans += (c - lest) * road[now].p;
                lest = max(0.0,c - (road[should_n].d - road[now].d) / d2);
            }

            else
            {
                ans += max((road[should_n].d - road[now].d) / d2 - lest,0.0) * road[now].p;
                lest = max(0.0,lest - (road[should_n].d - road[now].d) / d2);
            }

            now = should_n;
        }
    }
    printf("%.2lf",ans);
    return 0;
}
```


码风独特，希望原谅。

---

## 作者：陈年苦艾酒 (赞：1)

模拟
首先将目的地按坐标排序，重复以下过程

1.找到第一个比当前加油站油价低的加油站

①如果油箱容量足够到达该加油站,加(x2-x1)/d2-nowc升油,转到该加油站

②如果油箱容量不足以到达该加油站,加满油,并计算能到达的最近的加油站

③如果加满油之后还到达不了最近的加油站,no solution

2.如果找不到比当前油价低的加油站,即当前加油站的油价最低,加满油,计算能到达的最近加油站,如果到不了no solution 

模拟过程中可以将起点和终点分别视为油价为p和油价为一个极大值的加油站,模拟过程中最后一个加油站即可跳出

注意到达最后一个加油站时可能还剩有部分油,只需在之前模拟过程中记录最后一个加过油的加油站的编号以及剩余油的多少,再用ans减去该加油站油价*剩余油量即可

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

double d1,c,d2,ans,nowc;//nowc为当前油量 
int n,now,pp;//now表示当前加油站的编号,pp记录的是最近一次加油的加油站 
bool flag1,flag2;
struct node
{
	double dis,p;//坐标和油价 
};
node gas[510];//编号从0开始 
bool cmp(const node a,const node b){return a.dis<b.dis;}

int main()
{
	cin>>d1>>c>>d2>>gas[0].p>>n;//将出发点视为坐标为0的加油站 
	for(register int i=1;i<=n;i++)
	cin>>gas[i].dis>>gas[i].p;
	sort(gas+1,gas+n+1,cmp);
	gas[n+1].dis=d1;gas[n+1].p=1000;//将终点视为油价非常大的加油站
	//加油站从0开始,到n+1结束,共n+2个加油站 
	while(now!=n+1)
	{
		flag1=false;flag2=false;
		pp=now;
		int i=0;//i为第一个比当前加油站油价低的加油站 
		for(i=now+1;i<=n+1;i++)
		if(gas[i].p<gas[now].p)
		{
			flag1=true;//1.表示有比当前加油站油价低的加油站 
			break;
		}
		if(flag1)
		{
			if(c*d2>=gas[i].dis-gas[now].dis)//①
			{
				ans+=((gas[i].dis-gas[now].dis)/d2-nowc)*gas[now].p;//由于此时油量正好到达目的地,剩余油量为0 
				now=i;
			} 
			else//②
			{
				ans+=(c-nowc)*gas[now].p;
				for(int k=now+1;k<=n+1;k++)
				if(gas[k].dis<=gas[now].dis+c*d2)
				{
					i=k;
					flag2=true;//此时i记录能到达的最远的加油站,flag2表示能够到达 
				}
				if(flag2)
				{
					nowc=c-(gas[i].dis-gas[now].dis)/d2;
					now=i;//更新剩余油量和now 
				}
				else//③ 
				{
					cout<<"No Solution"<<endl;
					return 0;
				}
			} 
		}
		else//2.没有比当前油价低的加油站,当前加油站价格最低 
		{
			ans+=(c-nowc)*gas[now].p;//加满油 
			for(int k=now+1;k<=n+1;k++)
			if(gas[k].dis<=gas[now].dis+c*d2)
			{
				i=k;
				flag2=true;//此时i记录能到达的最远的加油站,flag2表示能够到达 
			}
			if(flag2)
			{
				nowc=c-(gas[i].dis-gas[now].dis)/d2;
				now=i;//更新剩余油量和now 
			}
			else
			{
				cout<<"No Solution"<<endl;
				return 0;
			}
		}
	} 
	if(nowc)//如果到达了终点,但是还有油 
	ans-=nowc*gas[pp].p;//把油再卖回去
	printf("%.2lf\n",ans);//自动四舍五入
	return 0; 
}
 
```

---

## 作者：SILENCE苏陌 (赞：1)

这道题我用的是······结构体双端队列

emmmm看了各位dalao的题解感觉略长，于是自己弄了一个

思路：
到达一个加油站保存可以加油的权利（现全部加满），至于到底加不加以后再说，如果到达下一个加油站油费更便宜，就把剩下的油全部退回去加这一个加油站的油（不知道我表述得够不够清楚）

至于具体的就附代码，解释的应该算清楚

```c
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
struct oil{double p,v;};
struct pt{double d,p;} a[100005];
bool cmp(pt t1,pt t2) {return t1.d<t2.d;}
deque<oil> dq;
double tot,v,dis,p,st,dist,ans;
int n;
int main()
    {
		scanf("%lf%lf%lf%lf%d",&tot,&v,&dis,&p,&n);//tot总距离,v油箱容量,dis每升油行驶路程,p出发点每升油
//												   价格,n加油站个数 
		dq.push_back((oil){p,v});
		for(int i=1;i<=n;i++)
			scanf("%lf%lf",&a[i].d,&a[i].p);//a[i].d油站i离出发点的距离,a[i].p每升汽油价格 
		a[n+1].d=tot+1;//常用技巧,故意在终点之外设置一个加油站,便于保证后面for循环结束时一定到达终点 
		sort(a+1,a+2+n,cmp);//按距起点的距离排成升序 
		for(int i=1;i<=n+1&&tot>1e-6;i++)//tot是到达第i站后还需要走的距离 
			{
				dist=a[i].d-st;//dist是从前一站出发到达第i站行驶的距离 
				st=a[i].d;//每到一个站就要更新st(到达下一站前的起点) 
				if(dist<tot) tot-=dist;//用的倒计数,这种情况表示还需行驶tot的距离才能到达终点 
				else dist=tot,tot=0;//到达第i个加油站之前行驶dist=tot的距离时就过了终点,别忘了清零tot=0 
				double vv=dist/dis;//到达该站用了多少油，方便后面"反悔"退油的计算 
				while(dq.size()&&dist>1e-6)
					{
						p=dq.front().p;//油箱中最便宜的油价 
						v=dq.front().v;//油箱中最便宜的油量 
						dq.pop_front();//弹出这种油用来结账 
						double t=min(dist/dis,v);//该价格用了多少油(显然不能超过v),一升油可行驶dis公里 
						ans+=t*p;//累加当前的费用 
						dist-=t*dis;//还剩dist远的路程未计费 
						v-=t;//该价格还剩多少油 
						if(v>0) dq.push_front((oil){p,v});//如果未用完从队头压入双端队列 
					}
				if(dist>=1e-6) {printf("No Solution");return 0;}//这种情况表示无法到达 
				while(dq.size()&&a[i].p<dq.back().p)//如果油箱内的油比第i站贵,"退掉"重新换成第i站的油 
					vv+=dq.back().v, dq.pop_back();
				dq.push_back((oil){a[i].p,vv});//将油箱补满 
			}
		printf("%.2lf",ans);
		return 0;
	}
```

---

## 作者：封禁用户 (赞：1)

分析：这道题比较容易想，就是实现细节实在是太考验人了.显然，走的路程是一定的，如果我们能使每一单位路程花的钱最少就好了，先把所有加油站按照距离从小到大排序，如果当前在加油站i,就算加满了油也无法到达其它的加油站，那么无解，如果在范围内有油费比i小的，那么就加油正好走到这个加油站，这样单位路程的油费就比i的小，如果没有邮费比i小的，那么就尽量选一个油费最小的，先加满油再开过去，因为i的油费更便宜，这个细节实在是太难调了
```
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cfloat>

using namespace std;

int n,st;
double d1,c,d2,p,ans,you;
bool flag2 = false;

struct node
{
    double d,p;
} e[100010];

bool cmp(node a,node b)
{
    return a.d < b.d;
}

/*
    1.在当前油站i如果加满了油，看能走到的油站中有没有费用更小的
    2.如果没有，就加满油，然后到费用最低的那个去.
    3.否则，加油刚好到费用最低的加油站就好了.
    原理就是走的路程就是那么多，路程上花的钱越少越好.
*/

int main()
{
    cin >> d1 >> c >> d2 >> p >> n;
    for (int i = 1; i <= n; i++)
        cin >> e[i].d >> e[i].p;
    sort(e + 1,e + 1 + n,cmp);
    e[0].d = 0;
    e[0].p = p; 
    int t = 0;
    while (1)
    {
        bool flag = false;
        int wh = 10000;
        for (int i = t + 1; i <= n; i++)
        {
            if (e[i].d - e[t].d > c * d2)
            break;
            if (e[i].p < e[t].p)
            {
            ans += ((e[i].d - e[t].d - you) / d2) * e[t].p;
            you = 0;
            t = i;
            flag = 1;
            break;
        }
    if (wh == 10000 || e[i].p < e[wh].p)
    wh = i;
        }
        if (flag)
        continue;
        if (d1 - e[t].d <= c * d2)
        {
            ans += (d1 - e[t].d -you) / d2 * e[t].p;
            break;
        }
        if (wh == 10000)
        {
            printf("No Solution");
            flag2 = 1;
            break;
        }
        else
        {
            ans += c*e[t].p;
            you += (c * d2 - e[wh].d + e[st].d);
            st = wh;
        }
    }
    if (!flag2)
    printf("%.2lf",ans);

    return 0;
}
```

---

## 作者：林志杰 (赞：1)

思路就是贪心，用一个数组模拟油箱，里面的油是一份一份的，每一份的价格和油量都不同。每次用最便宜的油（始终保证数组是有序的，越靠前的油越便宜），处理的时候假设当从油箱取出油后这部分油才算是买了，并且将花费记录下来。所以油箱里面的油相当于没买，那么我们就可以让油箱始终处于满的状态，防止因油不够而到不了下一个地点。注意应该保持油箱里的油是我们能够获取的最便宜的油。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<deque> 
#include<vector>
#include<algorithm>
#include<queue>
#include<functional>
using namespace std;
const int maxn=1000001;
double d1,c,d2,pp,oil,need,fee=0,now;
double dis[maxn],pi[maxn],box[maxn][2];
int n,l=1,r=1;
int main()
{
    scanf("%lf%lf%lf%lf%d",&d1,&c,&d2,&pp,&n);
    for(int i=1;i<=n;i++) scanf("%lf%lf",&dis[i],&pi[i]);
    dis[n+1]=d1; pi[0]=pp;
    if(n == 0)
    {
        if(double(d1/d2) > c)
        {
            cout<<"No Solution";
            return 0;
        }
        printf("%.2lf",(d1/d2)*pp);
        return 0;
    }
    box[l][0]=pp; box[l][1]=c;
    for(int i=1;i<=n+1;i++)
    {
        need=(dis[i]-dis[i-1])/d2;//计算出上一段路的需油量
        if( need > c )
        {
            cout<<"No Solution";
            return 0;
        }
        oil=need;//oil表示需要在这个加油站加多少油
        while(need > 0)//先计算出走完上段路消耗掉的钱 
        {
            //cout<<need<<endl;
            if( box[l][1] < need)
            {
                need = need - box[l][1];
                fee+=box[l][1]*box[l][0];
                l++;
            }
            else
            {
                fee+=need*box[l][0];
                box[l][1] -= need;
                break;
            }
            if( l > r )
            {
                cout<<"No Solution";
                return 0;
            }
        }
        if(i == n+1)
        {
            printf("%.2lf",fee);
            return 0;
        }
        while( l <= r && box[r][0] > pi[i] )//把贵的油换掉，为保持油箱满，换掉的这部分油应该用便宜的填充。
        {
            oil += box[r][1];
            r --;
        }
        r++;
        box[r][0] = pi[i]; box[r][1] = oil;
    }
}
```

---

## 作者：fanfan (赞：1)

介绍一种贪心的思路，在每一个加油站，包括起点，都把油箱加满，之后到达一个加油站的时候把油箱里剩下的价格贵的油退掉（就是把他从队列里删掉），等价于在以前的某个时刻我没有买这个油。还有就是在两个加油站之间，消耗的油都是最便宜的，这也是一种贪心。。

证明大概是这样的：因为我每次都在加油站把油箱加满，而且我把以前贵的油都卖掉了，所以剩下的是尽量小的，如此下去，每次都是尽量多盛便宜的油，每次退掉贵的油（等价于每次少买贵的），到终点的时候退掉所有的油，也就满足了整个贪心过程。。

所以我们想到了单调队列，每一次消耗队首的元素，退掉队尾的元素，把新的元素加进来，所需要的代价在退元素和近元素的时候更新一下即可。。。下面代码很好理解

然而很low的我在前两次读错了题，导致得了50分..............

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
double D,sum,d,c,p;
double que[10001][2];
int n;
int main()
{
    scanf("%lf%lf%lf%lf%d",&d,&c,&D,&p,&n);
    que[1][0]=c;
    que[1][1]=p;
    int p1=1,p2=1;//p1和p2是一个队首指针和队尾指针
    double re=c,sum=p*c,last=0;//re记录当时油箱剩下的油的体积
    for(int i=1;i<=n;++i)
    {
        double price,dis;
        scanf("%lf%lf",&dis,&price);
        double tmp=dis;
        if(i==n)
        d=d-dis;
        dis=dis-last;
        last=tmp;     //这里就是我以前读错题的地方！！！！每次读入的数是相对于起点的距离，不是两个点之间的距离！！！
        while(dis>=D*que[p1][0])  //消耗最便宜的油（队首元素）
        {
            re-=que[p1][0];
            dis-=D*que[p1][0];
            p1++;
            if(p1>p2)  //队列为空即是无解
            {
                printf("No Solution");return 0;
            }
        }
        re-=dis/D;
        que[p1][0]-=dis/D;
        while(price<que[p2][1]&&p2>=p1)  //弹出队尾元素（最贵的油）
        {
            sum-=que[p2][0]*que[p2][1];re-=que[p2][0];p2--;  //记得更新代价，移动指针
        }
        que[++p2][0]=c-re;
        que[p2][1]=price;
        re=c;
        sum+=que[p2][0]*que[p2][1]; //更新代价
    }
        //以后的代码是从最后一个点到终点的特殊情况，和以上相同
    if(c*D<d)
    {
        printf("No Solution");return 0;
    }
    while(d>=D*que[p1][0])
    {
        d-=D*que[p1][0];p1++;
    }
    que[p1][0]-=d/D;
    while(p1<=p2)
    sum-=que[p1][0]*que[p1][1],p1++;
    printf("%.2lf",sum);
}
```

---


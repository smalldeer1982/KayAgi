# 编码

## 题目描述

编码工作常被运用于密文或压缩传输。这里我们用一种最简单的编码方式进行编码：把一些有规律的单词编成数字。

字母表中共有 $26$ 个字母 $\mathtt{a,b,c,\cdots,z}$，这些特殊的单词长度不超过 $6$ 且字母按升序排列。把所有这样的单词放在一起，按字典顺序排列，一个单词的编码就对应着它在字典中的位置。

例如：

- $\verb!a! \to 1$；
- $\verb!b! \to 2$；
- $\verb!z! \to 26$；
- $\verb!ab! \to 27$；
- $\verb!ac! \to 28$。

你的任务就是对于所给的单词，求出它的编码。


## 样例 #1

### 输入

```
ab
```

### 输出

```
27
```

# 题解

## 作者：Alex_Wei (赞：176)

$\rm{Upd\ on\ 2020.1.21:}$ 为避免误导他人，修改了一个严重的常识性错误以及部分不太通顺的语句。原文章写于 $\rm{2019.8.10}$。

---

~~用组合数解这道题目实在是再简单不过了。~~

#### 前置芝士：组合数

$C_{n}^{m}$：在 $n$ 个数中选出 $m$ 个数的方案总数。**（不计顺序）**

计算公式是

$$C_{n}^{m}=\frac{\prod_{n-m+1}^{n}}{m!}$$

或者

$$C_{n}^{m}=\frac{n!}{m!(n-m)!}$$

通常的，$C_{n}^{0}=1$。

例如$\ \ C_{4}^{2}=\frac{3*4}{2*1}=6$。

即从 $4$ 个数中选取 $2$ 个有 $6$ 种取法：

$\{1,2\}\ \{1,3\}\ \{1,4\}\ \{2,3\}\ \{2,4\}\ \{3,4\}$。

计算代码如下：

```cpp
int c(int m,int n)
{
	if(m==0)return 1;
	int mut=1;
	for(int i=n;i>n-m;i--)mut*=i;
	for(int i=m;i>1;i--)mut/=i;
	return mut;
}
```

---

那么组合数与这题到底有什么关系呢？

拿 ```cgx``` 举例，设 $ans$ 为比 ```cgx``` 小的单词个数，初值为 $0$。

$\large1.$ 首先，```cgx``` 肯定比只有一个字母的单词大，$ans+26,\quad ans=26$。

$\large2.$ 其次，```cgx``` 肯定比只有两个字母的单词大。

只有两个字母的单词个数该怎么算呢？就是在 $26$ 个字母中选 $2$ 个。

$ans+C_{26}^{2},C_{26}^{2}=\frac{26*25}{2*1}=325,\quad ans=26+325=351$。

$\large3.$ 只有三个字母

$3.1.$ 第一位：它比以字母 ```a-b``` 为第一位的大（ ```cgx``` 第一位为 ```c```，所以要比 ```c``` 小）

- 以 ```a``` 为第一位，且有三位的单词个数：$C_{25}^{2}=\frac{25*24}{2*1}=300$。

  从**比 ```a``` 大的剩下 $25$ 个字母**中选 $2$ 个字母：
$ans+300,\quad ans=351+300=651$。

- 以 ```b``` 为第一位，且有三位的个数：$C_{24}^{2}=\frac{24*23}{2*1}=276$。

  从**比 $b$ 大的剩下 $24$ 个字母**中选 $2$ 个字母：$ans+276,\quad ans=651+276=927$。

$3.2$ 第二位（**即第一位已经确定为 $c$**）：它比以字母 ```d-f``` 为第二位的单词大 （第一位为 ```c``` ，所以要比 ```c``` 大，第二位为 ```g```，所以要比 ```g``` 小）

- 第二位为 ```d``` 的个数：$C_{22}^{1}=\frac{22}{1}=22$。

  从比 ```d``` 大的剩下 $22$ 个字母中选 $1$ 个字母：$ans+22,\quad ans=927+22=949$。

- 第二位为 ```e``` 的个数：$C^{1}_{21}=21,ans+21,\quad ans=949+21=970$。

- 第二位为 ```f``` 的个数：$C^{1}_{20}=20,ans+20,\quad ans=970+20=990$。

$3.3$ 第三位（一，二位已经确定）：它比以字母 ```h-w``` 为第三位的大，共有 $16$ 个。

$$\sum_{n=8}^{23}C^{0}_{n}=\sum_{n=8}^{23}1=16*1=16$$

$ans+16,\quad ans=990+16=1006$

因为比 ```cgx``` 小的单词共有 $1006$ 个，所以 ```cgx``` 是第 $1007$ 个。

![](https://cdn.luogu.com.cn/upload/pic/70890.png)

---

先判断该单词是否存在，再一位一位地去考虑共有多少比给出单词小的单词，如果用的是字符串，则还需要考虑一下边界问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int ans,n;
int c(int m,int n)//组合数计算 
{
	if(m==0)return 1;
	int mut=1;
	for(int i=n;i>n-m;i--)mut*=i;
	for(int i=m;i>1;i--)mut/=i;
	return mut;
}
int main()
{
	cin>>s,n=s.size();
	for(int i=1;i<n;i++)
		if(s[i]<=s[i-1])cout<<0,exit(0);//判断是否存在
	for(int i=1;i<n;i++)ans+=c(i,26);//计算出位数比它小的单词数
	for(int i=0;i<n;i++)//枚举每一位
		for(char j=(i==0?'a':s[i-1]+1);j<s[i];j++)//注意考虑边界
			ans+=c(n-i-1,'z'-j);//因为字符串下标从0开始，所以是n-i-1而不是n-i
	cout<<++ans;//别忘了最后把自己加上
	return 0;
}
```

---

## 作者：ICE_Wol (赞：67)

本题本质上是一个找规律填表(暨递推)的题目

思路非常明确，举一个简单的例子：



------------
对于一个字符串“ade”，它的长度为3.

那么他在题设要求中的字符串编号可以用以下方式求解：

1.  所有**长度为1和2**的字符串数量 + 所有**开头为a**，**由bc到de**的字符串数量；
2.  所有开头为a，由bc到de的字符串数量就相当于所有**开头为d长度为2**的字符串数量加上**开头为d长度为2直到末位是e**的字符串数量；



------------
由以上例子第二条我们可以类比其他情况，得到这样一个表格

[得到的表格](https://imgchr.com/i/PeVi9K)

**~~P.S.你可以在Excel中很轻松地制作出这个表格~~**

在该表格中，横行表示开头字母，纵行表示字串长度，表格中的数据以该字母开头的该长度字符串的总数

对于任何一群以i开头，长度为j的字符串，它的数量均为可以以这样一个公式表示：

## $f[i][j] = f[i + 1][j - 1] + f[i + 2][j - 1] + f[i + 3][j - 1] + … + f[z][j - 1]$

如果无法理解，没关系，我们再举一个例子



------------
以a开头，长度为3的字符串数量如何计算？

这样的字符串有很多： abc acd ace ...

我们可以发现，这样的字符串的数量就相当于以b开头的长度为2的串的数量，加上以c开头长度为2的串的数量...一直到以y开头长度为2的串的数量，即为以上公式

**（由于题设要求，没有以z开头长度为2的合法串）**


------------

但这样一个公式计算起来仍不方便，别急，我们再来看

由上面的公式，用i + 1替换i,我们可以得到这样一个式子

## $f[i + 1][j] = f[i + 2][j - 1] + f[i + 3][j - 1] +…+f[z][j - 1]$

将这个式子带入刚刚的公式，就可以得到表格的计算方法：

## $f[i][j] = f[i + 1][j - 1] + f[i + 1][j]$

用程序运行这个公式，计算数组f[i][j]，就可以得到上述表格

而显然地，计算某个字符串的编号，就是计算字符串每一位在对应行从a到该位的值得和，说的比较抽象，举个例子就能理解



------------
对于一个字符串“ade”：

从右至左，第一位是1，则第一行将a-e的数值相加

第二位是d，将第二行a-d的数值相加

以此类推，得到最终答案399.



------------
至此，本题思路已分析完毕，接下来就是代码实现，需要注意一些细节的处理（数组下标一类），以下是完整代码

```
#include<iostream>
using namespace std;
string s;
int f[30][10],ans,cnt;
int main(){
    cin >> s;
    for(int i = 1;i < s.size();i++){
        if(s[i - 1] >= s[i]){
            cout << 0;
            return 0;
        }
    }
    //判断字符串是否合法（升序）
    for(int i = 1;i <= 26;i++)
        f[i][1] = 1;
    //长度为1的字符串数量都是1
    for(int j = 2;j <= 6;j++)
        for(int i = 27 - j;i > 0;i--)
            f[i][j] = f[i + 1][j - 1] + f[i + 1][j];
    //由公式，我们从上至下从右至左进行计算
    for(int j = s.size() - 1;j >= 0;j--){
        cnt++;
        for(int i = 1;i <= s[j] - 'a' + 1;i++)
            ans += f[i][cnt];
    }
    //由以上的思路计算答案
    cout << ans;
    return 0;
}

```


---

## 作者：NZSWW33OMF2GC (赞：57)

又是一个~~暴力枚举~~

此方法易于理解，没有繁杂的推导过程，且性能较佳。

总的方法是枚举生成从 `a` 到 `uvwxyz` 的所有可能单词，每生成一个即比对一遍。

### TL;DR

主要问题在于如何**进位**。进位规则如下：
1. 从低位开始数的第 $i$ 位 $(0 \le i \le 5)$ 上最大只能为 $\texttt{z}-i$。超过此值则高位（第 $i+1$ 位）进一，当前位待定；
2. 产生向前进位的数位（即上一条中的第 $i$ 位）进位后应变为第 $i+1$ 位上字母的后一个字母。
3. (2) 中的规则应从高位到低位计算。即仔细观察从 `yz` 到 `abc` 的进位原理可知，

### 详细步骤

首先将输入的字符串整理为低第 $i$ $(0 \le i \le 5)$ 位位于 `ask[i]` 的格式，并且将字母转换为对应的序号。

最低位增 1，考察进位。这里分两个步骤，第一步只考虑进位中的*高位*得数，从低到高计算；第二步只考虑进位后*此位*得数，从高到低计算。

进位处理第一步：由题目要求可知以上进位规则中的 (1)。按照此规则向高位进 1。同时 `carry` 记录一共由多少位产生了进位。若某一位未进位，则高位不再进位（即产生进位的数位一定是低位上的连续 $n$ 位）。

进位处理第二步：由题中“升序排列”的要求，在一次进位中，低位（即产生进位的数位）应变为高位上字母的后一个字母。但经过以上处理后高位可能继续产生了进位，导致当前低位的字母无法直接确定，故需要从高位到低位计算。此前已经记录了哪些位产生了进位，逐个处理即可。

最高位向前进位时，由于数组均初始化为 0，故可直接加一。

最后逐个比对，成功则打印退出，不匹配则最低位继续进一，重复以上循环。

### 举例

以 `yz` + 1 = `abc` 为例分析以上过程。注：ASCII 中 'z' 的下一个字符是 '{'。

| | 步骤 | 结果 |
|:--|:--:|--:|
| | 最低位增 1 | `y{` |
| 第一步： 
| | 第 0 位超过 `z`，进位 | `z{` |
| | 第 1 位超过 `y`，进位 | `az{` |
| 第二步： |低二位产生了进位
| | 第 1 位应为第 2 位后一字母 | `ab{` |
| | 第 0 位应为第 1 位后一字母 | `abc` |

### 性能

最长用时 7ms.

---

最后奉上完整代码：

```c++
#include <stdio.h>
int main(void)
{
    char digit[8] = {0}, input[8], ask[8];
    int n = 0, carry, p = 0;
    bool match;
    scanf("%s", input);
    while(input[++p]);
    for(int i = 0; i < p; i++)
        ask[i] = input[p-i-1] - 'a' + 1;
    while(++n)
    {
        digit[0]++;
        // 进位处理第一步
        carry = 0;
        for(int i = 0; i < 8; i++)
        {
            if (digit[i] > 26 - i)
            {
                carry++;
                digit[i+1]++;
            }
            else break;
        }
        // 进位处理第二步
        for(int i = carry-1; i >= 0; i--)
            digit[i] = digit[i+1]+1;
        // 匹配检测
        match = true;
        for(int i = 0; i < p; i++)
        {
            if (ask[i] != digit[i])
            {
                match = false;
                break;
            }
        }
        if (match) { printf("%d", n); break; }
        if (digit[6]) { printf("0"); break; }
    }
    return 0;
}
}
```

---

最后，码字不易，不要脸地求赞（

---

## 作者：hongzy (赞：27)

### 【询问】用STL里的map就好

先预处理6位，把单词映射到编码 
```cpp
map<string, int> M;
```

然后询问的时候直接输出M[ask].

---

### 【预处理方法】DFS搜索

不同长度的单词分别处理，len从1到6

DFS，每次循环从上一位字母+1到'z',构成单词后记录编号为cnt的单词
```cpp
M[now] = ++cnt;
```
---
### 【参考代码】~~感觉非常短~~
```cpp
#include <iostream>
#include <map>
using namespace std;

int cnt;
map<string, int> M;
string now, ask;

void DFS(const int l, int k) {
	if(k > l) { M[now] = ++cnt; return;}
	for(char i=(k==1?'a':now[k-2]+1); i<='z'; i++)
		now[k-1] = i, DFS(l, k+1);
}

int main() {
	for(int len=1; len<=6; len++)
		now.clear(), now.resize(len), DFS(len, 1);
	cin >> ask;
	cout << M[ask] << endl;
	return 0;
}
```

---

## 作者：jijidawang (赞：14)

[~~没有~~更好的观看体验](https://www.cnblogs.com/CDOI-24374/p/13939443.html
)

看了题解发现没有和我一样做法的。

考虑枚举组合，方法就是 [P1157](https://www.luogu.com.cn/problem/P1157) 的方法。

我们令 $1$ 状态表示不填，故每个单词最多有一个不填的，隔 $2$ 枚举即可。
```cpp
using namespace std;
const int N=25;
int n,r,a[N],cc;
string A;
void C(int nn,int nm) // 枚举组合
{
	if (nm==r)
	{
		string tmp;
		for (int i=1;i<=r;i++)
			if (a[i]!=1) tmp.push_back(a[i]+'a'-2); // 1 代表空了，所以要 -2
		if (tmp==A){printf("%d",cc+1); exit(0);} // 如果枚举到了
		++cc; return ; // 否则计数器 +1
	}
	for (int i=nn+1;i<=n-(r-nm-1);i++) a[nm+1]=i,C(i,nm+1),a[nm+1]=0;
}
int main()
{
	cin>>A; n=27;
	for (r=2;r<=6;r+=2) memset(a,0,sizeof a),C(0,0); // 隔 2 枚举
	puts("0");
	return 0;
}
```

---

## 作者：iamrjj (赞：7)

这道题其实就是一个~~大暴力~~【雾】

[更好的](https://fkx4-p.top/?p=17)[阅读体验]()

第一步，我想到的是直接大暴力出当前的字母的数目。但是无奈不会写就放弃了。

然后就想到了枚举——没错，**枚举！！！！**

于是我就有以下代码:

[戳这里](https://paste.ubuntu.com/p/pscbnqtCM3/)

但是当我运行时，经过一秒就直接`ctrl+c`了，根本没用！这也是为什么我选择不把它放到这里直接显示出来。

那么，优化呢。

我想到了从某个字母数开始枚举。并且不记录在map中，直接用`cnt`计数，以节省时间。(虽然可能不是什么好方法)

这里注意几个数据（用之前链接中程序生成）

$ab$-$27$ $\ $ $abc$-$352$ $\ $ $abcd$-$2592$ $\ $ $abcde$-$17092$ $\ $ $abcdef$-$83682$ 

```cpp
#include <cstdio>
#include <iostream>
#include <string>
using namespace std;

string a;
string input;
int cnt;

void init_1()
{
    for (int i = 'a'; i <= 'z'; i++)
    {
        if (i == input[0])
        {
            cout << ++cnt << endl;
            return;
        }
        a += i;
        ++cnt;
        a.erase(a.begin(), a.end());
    }
}

void init_2()
{
    for (int i = 'a'; i <= 'z'; i++)
        for (int j = i + 1; j <= 'z'; j++)
        {
            if (i == input[0] && j == input[1])
            {
                cout << ++cnt << endl;
                return;
            }
            a += i;
            a += j;
            ++cnt;
            a.erase(a.begin(), a.end());
        }
}

void init_3()
{
    for (int i = 'a'; i <= 'z'; i++)
        for (int j = i + 1; j <= 'z'; j++)
            for (int k = j + 1; k <= 'z'; k++)
            {
                if (i == input[0] && j == input[1] && k == input[2])
                {
                    cout << ++cnt << endl;
                    return;
                }
                a += i;
                a += j;
                a += k;
                ++cnt;
                a.erase(a.begin(), a.end());
            }
}

void init_4()
{
    for (int l = 'a'; l <= 'z'; l++)
        for (int k = l + 1; k <= 'z'; k++)
            for (int i = k + 1; i <= 'z'; i++)
                for (int j = i + 1; j <= 'z'; j++)
                {
                    if (l == input[0] && k == input[1] && i == input[2] && j == input[3])
                    {
                        cout << ++cnt << endl;
                        return;
                    }
                    a += l;
                    a += k;
                    a += i;
                    a += j;
                    ++cnt;
                    a.erase(a.begin(), a.end());
                }
}

void init_5()
{
    for (int m = 'a'; m <= 'z'; m++)
        for (int l = m + 1; l <= 'z'; l++)
            for (int k = l + 1; k <= 'z'; k++)
                for (int i = k + 1; i <= 'z'; i++)
                    for (int j = i + 1; j <= 'z'; j++)
                    {
                        if (m == input[0] && l == input[1] && k == input[2] && i == input[3] && j == input[4])
                        {
                            cout << ++cnt << endl;
                            return;
                        }
                        a += m;
                        a += l;
                        a += k;
                        a += i;
                        a += j;
                        ++cnt;
                        a.erase(a.begin(), a.end());
                    }
}

void init_6()
{
    for (int n = 'a'; n <= 'z'; n++)
        for (int m = n + 1; m <= 'z'; m++)
            for (int l = m + 1; l <= 'z'; l++)
                for (int k = l + 1; k <= 'z'; k++)
                    for (int i = k + 1; i <= 'z'; i++)
                        for (int j = i + 1; j <= 'z'; j++)
                        {
                            if (n == input[0] && m == input[1] && l == input[2] && k == input[3] && i == input[4] && j == input[5])
                            {
                                cout << ++cnt << endl;
                                return;
                            }
                            a += n;
                            a += m;
                            a += l;
                            a += k;
                            a += i;
                            a += j;
                            ++cnt;
                            a.erase(a.begin(), a.end());
                        }
}
int main()
{
    cin >> input;
    if (input.length() == 1)
    {
        init_1();
        return 0;
    }
    for (int i = 1; i < input.length(); i++)
    {
        if (input[i] <= input[i - 1])
        {
            cout << '0' << endl;
            return 0;
        }
    }
    if (input.length() == 2)
    {
        cnt = 26;
        init_2();
        return 0;
    }
    if (input.length() == 3)
    {
        cnt = 351;
        init_3();
        return 0;
    }
    if (input.length() == 4)
    {
        cnt = 2951;
        init_4();
        return 0;
    }
    if (input.length() == 5)
    {
        cnt = 17901;
        init_5();
        return 0;
    }
    if (input.length() == 6)
    {
        cnt = 83681;
        init_6();
        return 0;
    }

    return 0;
}
```
事实证明，这样已经很优秀了，最慢的点我跑了7ms

当然对于6位的处理还可以再来一点，在这里不赘述了。

[链接](https://paste.ubuntu.com/p/DwCKV2x4QY/)

这段我跑了4ms，虽然提升不多，但是如果多组数据就有明显优势了。

并且，~~我压行了~~

_ ___EOF____

---

## 作者：bh1234666 (赞：5)

这题其实可以直接暴力枚举，而且不会超时，但不知道为神马用gets输入会出现多余的‘  ’要过滤一遍

            
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
    int i[6],j=1;
    char a[7],b[7];
    gets(a);
    for(i[0]=0;a[i[0]]!='\0';i[0]++) if(a[i[0]]>'z'||a[i[0]]<'a') a[i[0]]='\0';//过滤‘  ’
    for(i[0]=0;i[0]<26;i[0]++)//处理一个字母
    {
        b[1]='\0';
        b[0]='a'+i[0];
        if(strcmp(a,b)==0)
        {
            printf("%d",j);
            return 0;//找到直接退出
        }
        j++;
    }
    for(i[0]=0;i[0]<25;i[0]++)//处理两个
    {
        for(i[1]=i[0]+1;i[1]<26;i[1]++)
        {
            b[2]='\0';
            b[0]='a'+i[0];
            b[1]='a'+i[1];
            if(strcmp(a,b)==0)
            {
                printf("%d",j);
                return 0;//不用我一个一个写了吧
            }
            j++;
        }
    }
    for(i[0]=0;i[0]<24;i[0]++)//三个
    {
        for(i[1]=i[0]+1;i[1]<25;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<26;i[2]++)
            {
                b[3]='\0';
                b[0]='a'+i[0];
                b[1]='a'+i[1];
                b[2]='a'+i[2];
                if(strcmp(a,b)==0)
                {
                    printf("%d",j);
                    return 0;
                }
                j++;
            }
        }
    }
    for(i[0]=0;i[0]<23;i[0]++)//四个
    {
        for(i[1]=i[0]+1;i[1]<24;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<25;i[2]++)
            {
                for(i[3]=i[2]+1;i[3]<26;i[3]++)
                {
                    b[4]='\0';
                    b[0]='a'+i[0];
                    b[1]='a'+i[1];
                    b[2]='a'+i[2];
                    b[3]='a'+i[3];
                    if(strcmp(a,b)==0)
                    {
                        printf("%d",j);
                        return 0;
                    }
                    j++;
                }
            }
        }
    }
    for(i[0]=0;i[0]<22;i[0]++)//五个
    {
        for(i[1]=i[0]+1;i[1]<23;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<24;i[2]++)
            {
                for(i[3]=i[2]+1;i[3]<25;i[3]++)
                {
                    for(i[4]=i[3]+1;i[4]<26;i[4]++)
                    {
                        b[5]='\0';
                        b[0]='a'+i[0];
                        b[1]='a'+i[1];
                        b[2]='a'+i[2];
                        b[3]='a'+i[3];
                        b[4]='a'+i[4];
                        if(strcmp(a,b)==0)
                        {
                            printf("%d",j);
                            return 0;
                        }
                        j++;
                    }
                }
            }
        }
    }
    for(i[0]=0;i[0]<21;i[0]++)//六个
    {
        for(i[1]=i[0]+1;i[1]<22;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<23;i[2]++)
            {
                for(i[3]=i[2]+1;i[3]<24;i[3]++)
                {
                    for(i[4]=i[3]+1;i[4]<25;i[4]++)
                    {
                        for(i[5]=i[4]+1;i[5]<26;i[5]++)
                        {
                            b[6]='\0';
                            b[0]='a'+i[0];
                            b[1]='a'+i[1];
                            b[2]='a'+i[2];
                            b[3]='a'+i[3];
                            b[4]='a'+i[4];
                            b[5]='a'+i[5];
                            if(strcmp(a,b)==0)
                            {
                                printf("%d",j);
                                return 0;
                            }
                            j++;
                        }
                    }
                }
            }
        }
    }
    printf("0");//如果不符合要求（符合的前面已经return掉了）输出‘0’
    return 0;
}
```
当然不想过滤也可以用scanf
#include<cstdio>//这个我就不加注释了，除了输入其他和上面都一样的

            
```cpp
#include<cstring>
using namespace std;
int main()
{
    int i[6],j=1;
    char a[7],b[7];
    scanf("%s",&a);
    for(i[0]=0;i[0]<26;i[0]++)
    {
        b[1]='\0';
        b[0]='a'+i[0];
        if(strcmp(a,b)==0)
        {
            printf("%d",j);
            return 0;
        }
        j++;
    }
    for(i[0]=0;i[0]<25;i[0]++)
    {
        for(i[1]=i[0]+1;i[1]<26;i[1]++)
        {
            b[2]='\0';
            b[0]='a'+i[0];
            b[1]='a'+i[1];
            if(strcmp(a,b)==0)
            {
                printf("%d",j);
                return 0;
            }
            j++;
        }
    }
    for(i[0]=0;i[0]<24;i[0]++)
    {
        for(i[1]=i[0]+1;i[1]<25;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<26;i[2]++)
            {
                b[3]='\0';
                b[0]='a'+i[0];
                b[1]='a'+i[1];
                b[2]='a'+i[2];
                if(strcmp(a,b)==0)
                {
                    printf("%d",j);
                    return 0;
                }
                j++;
            }
        }
    }
    for(i[0]=0;i[0]<23;i[0]++)
    {
        for(i[1]=i[0]+1;i[1]<24;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<25;i[2]++)
            {
                for(i[3]=i[2]+1;i[3]<26;i[3]++)
                {
                    b[4]='\0';
                    b[0]='a'+i[0];
                    b[1]='a'+i[1];
                    b[2]='a'+i[2];
                    b[3]='a'+i[3];
                    if(strcmp(a,b)==0)
                    {
                        printf("%d",j);
                        return 0;
                    }
                    j++;
                }
            }
        }
    }
    for(i[0]=0;i[0]<22;i[0]++)
    {
        for(i[1]=i[0]+1;i[1]<23;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<24;i[2]++)
            {
                for(i[3]=i[2]+1;i[3]<25;i[3]++)
                {
                    for(i[4]=i[3]+1;i[4]<26;i[4]++)
                    {
                        b[5]='\0';
                        b[0]='a'+i[0];
                        b[1]='a'+i[1];
                        b[2]='a'+i[2];
                        b[3]='a'+i[3];
                        b[4]='a'+i[4];
                        if(strcmp(a,b)==0)
                        {
                            printf("%d",j);
                            return 0;
                        }
                        j++;
                    }
                }
            }
        }
    }
    for(i[0]=0;i[0]<21;i[0]++)
    {
        for(i[1]=i[0]+1;i[1]<22;i[1]++)
        {
            for(i[2]=i[1]+1;i[2]<23;i[2]++)
            {
                for(i[3]=i[2]+1;i[3]<24;i[3]++)
                {
                    for(i[4]=i[3]+1;i[4]<25;i[4]++)
                    {
                        for(i[5]=i[4]+1;i[5]<26;i[5]++)
                        {
                            b[6]='\0';
                            b[0]='a'+i[0];
                            b[1]='a'+i[1];
                            b[2]='a'+i[2];
                            b[3]='a'+i[3];
                            b[4]='a'+i[4];
                            b[5]='a'+i[5];
                            if(strcmp(a,b)==0)
                            {
                                printf("%d",j);
                                return 0;
                            }
                            j++;
                        }
                    }
                }
            }
        }
    }
    printf("0");
    return 0;
}
```

---

## 作者：Angel_s_Shadow (赞：4)

比起各位大佬，我简直就是一个……*****

这道题一开始怎么想都没思路，然后我就想着打表

……也不能是完全的打表，至少让计算机计算简便一点嘛……

```cpp
#include <iostream>
#include <string>
using namespace std;
long long check(string str,int len){
    long long index=1;
    switch(len){
    case 1:
        for(int i='a';i<='z';i++){
            string s;
            s+=((char)i);
            if(s==str){
                return index;
            }
            index++;
        }
        break;
    case 2:
        index=27;//打表
        for(int i='a';i<='z';i++){
            for(int j='a';j<='z';j++){
                if(!(i<j)){//判断是否顺序，下同
                    continue;
                }
                string s;
                s+=((char)i);
                s+=((char)j);
                if(s==str){
                    return index;//返回值，下同
                }
                index++;
            }
        }
        break;
    case 3:
        index=352;//打表
        for(int a='a';a<='z';a++)
        for(int i='a';i<='z';i++){
            for(int j='a';j<='z';j++){
                if(!(a<i&&i<j)){
                    continue;
                }
                string s;
                s+=((char)a);
                s+=((char)i);
                s+=((char)j);
                if(s==str){
                    return index;
                }
                index++;
            }
        }
        break;
    case 4:
        index=2952;//打表
        for(int b='a';b<='z';b++)
        for(int a='a';a<='z';a++)
        for(int i='a';i<='z';i++){
            for(int j='a';j<='z';j++){
                if(!(b<a&&a<i&&i<j)){
                    continue;
                }
                string s;
                s+=((char)b);
                s+=((char)a);
                s+=((char)i);
                s+=((char)j);
                if(s==str){
                    return index;
                }
                index++;
            }
        }
        break;
    case 5:
        index=17902;//打表
        for(int c='a';c<='z';c++)
        for(int b='a';b<='z';b++)
        for(int a='a';a<='z';a++)
        for(int i='a';i<='z';i++){
            for(int j='a';j<='z';j++){
                if(!(c<b&&b<a&&a<i&&i<j)){
                    continue;
                }
                string s;
                s+=((char)c);
                s+=((char)b);
                s+=((char)a);
                s+=((char)i);
                s+=((char)j);
                if(s==str){
                    return index;
                }
                index++;
            }
        }
        break;
    case 6:
        index=83682;//还是打表
        for(int d='a';d<='z';d++)
        for(int c='a';c<='z';c++)
        for(int b='a';b<='z';b++)
        for(int a='a';a<='z';a++)
        for(int i='a';i<='z';i++){
            for(int j='a';j<='z';j++){
                if(!(d<c&&c<b&&b<a&&a<i&&i<j)){
                    continue;
                }
                string s;
                s+=((char)d);
                s+=((char)c);
                s+=((char)b);
                s+=((char)a);
                s+=((char)i);
                s+=((char)j);
                if(s==str){
                    return index;
                }
                index++;
            }
        }
        break;
    }
    return 0;
}
int main(){
    string a;
    cin>>a;
    cout<<check(a,a.length());
    return 0;
}

```
awsl，最后竟然能过！

---

## 作者：SixnineMe (赞：3)

看了一下题解发现好像没有人说排列组合的，我不怎么喜欢暴力枚举的，特别这个会让代码很长。

既然这样我就说一下排列组合的方法，如果要弄一个 各位数字递增的三位数，只需要在一个有序数列里面取三个数字，此时就无需关注顺序，因为顺序只能是升序的。比如0 1 2 3 4 5 6 7 8 9。取得9 5 8 那么他的顺序就只能是589。总数就是C(x,y)，x代表位数，y代表可供选择的数的长度，

就像例子中是c(3,10)。对于字母排列，道理也是一样。只需要注意一下y的大小，然后从左到右一步一步推下去就好。

第一次发题解，弱鸡一个，有点不熟，代码也是用C写的，希望有人能给出更简洁的题解。。。。

```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
int c(int t,int b){
    double sum=1;//！
    for(int i=0;i<t;i++){
        sum=sum*(b-i);
        sum=sum/(t-i);
    }
    return floor(sum+0.5);//防止精度损失
}
int main(void){
    char str[7];
    int d[7];
    long long sum=0;
    scanf("%s",str);
    int l=strlen(str);
    for(int i=0;i<l;i++){
        if(i>0){
            if(str[i]<=str[i-1]){
                printf("0");
                return 0;
            }
```
}//判断是否为递增
```cpp
        d[i]=str[i]-'a'+1;
    }
    if(l==1){
        printf("%d",d[0]);
        return 0;
```
}//特判
    for(int i=1;i<l;i++){

        sum+=c(i,26);

}//累加小于L位所有可能性

```cpp
    for(int i=0;i<l-1;i++){
        for(int j=(i-1<0?1:d[i-1]+1);j<d[i];j++){
            //printf("%d|%d|%d|%d|%lld\n",i,j,l-1-i,26-j,c(l-1-i,26-j));
            sum+=c(l-i-1,26-j);
        }
    }
```
/\*
\* 如：BDF 先计数A**的个数 再BC\*的个数 再BD\*

\* \*/
```cpp
    sum+=(d[l-1]-d[l-2]);
    //比如BDE到BDF有2个，这个需要加上去。
    printf("%lld",sum);
}

```

---

## 作者：小样儿鸣 (赞：2)

萌新的第二篇题解
我现在是哭着给大家写题解的，为什么？被自己蠢哭了，一个下午的愚蠢！

**请大家一定要好好检查自己的输出！**

我多输出了源字符串（为了对照检查），结果我一直没发现。。。
神奇的是，就这我也拿了十分（第三个点），神奇的洛谷。。。。。也正因为这，我一直没有发现有什么不对。。。

在这里给大家分享一下我打表的程序吧（当然也有AC的程序），是的，我一一对照着人工OJ了一遍，最后才发现自己多输出了！

对了，我发现这个表打得挺快的，所以也许暴搜就能过这道题。。。

至于这道题怎么写，我用的是排列组合，大概过程是：

acty

abcd(等长)-》acde-》actu-》acty；利用这些中间过程一步步递推即可，其他大佬说地非常详细了（~~虽然看不懂~~），大家可以到他们那里借鉴一下。

好了，我不哭了，回教室上课了，谢谢大家看我的题解。

注：这个表其实并没有完全打完，只打到了“abcdef”，想要完整的只需改一下循环中i的边界即可。表用freopen输出了，前面有编号，不想要的可以删除相应的printf语句即可（编号变量名为ti）

打表程序：

```cpp
#include<bits/stdc++.h>

using namespace std;
char c[100];
int main()
{
	freopen("testtry.txt","w",stdout);
	memset(c,('a'-1),sizeof(c));
	int p=0,len_c=1;
	int ti=1;
	for(int i=0;i<83682;i++)		//改这里获得不同长度的表 
	{
		p=0;
		c[p]++;
		while(c[p]>'z')
		{
			c[p]='a';
			p++;
			c[p]++;
		}
		while(p>0)
		{
			p--;
			while(c[p]<c[p+1]+1)
			{
				c[p]++;
				while(c[p]>'z')
				{
					c[p]='a';
					p++;
					c[p]++;
				}
			}
		}
		len_c=strlen(c);
		printf("%d ",ti++);			//输出编号 
		for(int j=len_c;j>-1;j--)	//输出字符 
		if(c[j]!='`')
		printf("%c",c[j]);
		printf("\n");
	}
	return 0;
}
```

解题程序：

```cpp
#include<bits/stdc++.h>

using namespace std;
char c[10],f[10];
int tp=0,a[6];
//a[1]=26C1,a[2]=26C2+a[1],...;
int my_nCr(int n,int r)
{
	if(r>(n/2))r=n-r;
	if(r==0)return 1;
	int tp=n;
	for(int i=n-1;i>n-r;i--)
	{
		tp*=i;
	}
	for(int i=2;i<r+1;i++)
	{
		tp/=i;
	}
	return tp;
}
int main()
{
	for(int i=1;i<7;i++)
	{
		a[i]=my_nCr(26,i)+a[i-1];
	}
	scanf("%s",c);
	int len_c=strlen(c);
	
	for(int i=0;i<len_c;i++)
	{
		if(c[i]<'a' || c[i]>'z')
		{
			printf("0");
			return 0;
		}
		for(int j=0;j<i;j++)
		{
			if(c[i]==c[j])
			{
				printf("0");
				return 0;
			}
		}
	}
	tp+=a[len_c-1];
	tp++;
	f[0]='a';
	for(int i=0;i<len_c;i++)
	{
		while(f[i]!=c[i])
		{
			tp+=my_nCr('z'-f[i],len_c-i-1);
			f[i]++;
			
		}
		f[i+1]=f[i]+1;
		
	}
	printf("%d",tp);		//多输出了。。。。。。。 
	return 0;
}
```



---

## 作者：lamboo (赞：0)

这题由于范围不大

所以我们可以暴力枚举

讲所有的字符串都枚举出来

先枚举长度为1的情况

再枚举长度为2的情况

···
最后枚举长度为6的情况

如果在中途找到了就输出并推出程序

```cpp
var s,s1:string;i1,i2,i3,i4,i5,i6,t:longint;
procedure sc(t:longint);  //找到了就输出
begin
writeln(t);
close(input);close(output);halt;
end;
begin
readln(s);
for i1:=1 to 26 do  //长度为1的情况
  begin
  s1:='';t:=t+1;  //t表示当前是第几个字符串
  s1:=s1+chr(i1+96);
  if s1=s then sc(t);
  end;
for i1:=1 to 26 do  //长度为2的情况
  for i2:=i1+1 to 26 do
    begin
    s1:='';t:=t+1;
    s1:=s1+chr(i1+96);
    if s1=s then sc(t);
    s1:=s1+chr(i2+96);
    if s1=s then sc(t);
    end;
for i1:=1 to 26 do  //长度为3的情况
  for i2:=i1+1 to 26 do
    for i3:=i2+1 to 26 do
      begin
      s1:='';t:=t+1;
      s1:=s1+chr(i1+96);
      if s1=s then sc(t);
      s1:=s1+chr(i2+96);
      if s1=s then sc(t);
      s1:=s1+chr(i3+96);
      if s1=s then sc(t);
      end;
for i1:=1 to 26 do  //长度为4的情况
  for i2:=i1+1 to 26 do
    for i3:=i2+1 to 26 do
      for i4:=i3+1 to 26 do
        begin
        s1:='';t:=t+1;
        s1:=s1+chr(i1+96);
        if s1=s then sc(t);
        s1:=s1+chr(i2+96);
        if s1=s then sc(t);
        s1:=s1+chr(i3+96);
        if s1=s then sc(t);
        s1:=s1+chr(i4+96);
        if s1=s then sc(t);
        end;
for i1:=1 to 26 do  //长度为5的情况
  for i2:=i1+1 to 26 do
    for i3:=i2+1 to 26 do
      for i4:=i3+1 to 26 do
        for i5:=i4+1 to 26 do
          begin
          s1:='';t:=t+1;
          s1:=s1+chr(i1+96);
          if s1=s then sc(t);
          s1:=s1+chr(i2+96);
          if s1=s then sc(t);
          s1:=s1+chr(i3+96);
          if s1=s then sc(t);
          s1:=s1+chr(i4+96);
          if s1=s then sc(t);
          s1:=s1+chr(i5+96);
          if s1=s then sc(t);
          end;
for i1:=1 to 26 do  //长度为6的情况
  for i2:=i1+1 to 26 do
    for i3:=i2+1 to 26 do
      for i4:=i3+1 to 26 do
        for i5:=i4+1 to 26 do
          for i6:=i5+1 to 26 do
            begin
            s1:='';t:=t+1;
            s1:=s1+chr(i1+96);
            if s1=s then sc(t);
            s1:=s1+chr(i2+96);
            if s1=s then sc(t);
            s1:=s1+chr(i3+96);
            if s1=s then sc(t);
            s1:=s1+chr(i4+96);
            if s1=s then sc(t);
            s1:=s1+chr(i5+96);
            if s1=s then sc(t);
            s1:=s1+chr(i6+96);
            if s1=s then sc(t);
            end;
writeln(0);  //不符合要求就输出0
end.
```

---

## 作者：fighter_OI (赞：0)

没有Pascal题解我来一发。

用bfs即可。

对于每个单词，由于它必须按升序排列，所以往它末尾加上一个字母且该字母字典序比原单词最后一个字母字典序大，将新单词插入队列。

由于循环按字典序进行，每次只加一个字母，所以保证了整个队列是按长度由小到大，字典序由小到大排列的。

标程：

```cpp
var len,k,head,sum:longint;
    s:string[6];
    a:array[1..15000000] of string[6];//队列
    i:char;
begin
 readln(s);
 for i:='a' to 'z' do
  begin
   a[ord(i)-96]:=i;
  end;
 head:=1;
 len:=26;
 sum:=0;
 while a[head]<>s do
  begin
   i:=a[head][length(a[head])];
   for k:=1 to 26 do//创建新单词
    if i='z' then break else
     begin
      i:=succ(i);
      inc(len);
      if len>15000000 then begin len:=1; sum:=sum+15000000; end;//空间问题
      a[len]:=a[head]+i;
      if a[len]=s then//判断是否达到目标单词
       begin
        write(len+sum);
        halt;
       end;
     end;
   inc(head);
  end;
 write(head);//二重放错
end.
```

---


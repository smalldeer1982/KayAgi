# 黑白棋子的移动

## 题目描述

有 $2n$ 个棋子排成一行，开始为位置白子全部在左边，黑子全部在右边，如下图为 $n=5$ 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/dzfwand6.png)

移动棋子的规则是：每次必须同时移动相邻的两个棋子，颜色不限，可以左移也可以右移到空位上去，但不能调换两个棋子的左右位置。每次移动必须跳过若干个棋子（不能平移），要求最后能移成黑白相间的一行棋子。如 $n=5$ 时，成为：

![](https://cdn.luogu.com.cn/upload/image_hosting/yus9ph6d.png)

任务：编程打印出移动过程。

## 说明/提示

 $ 4\leq n\leq 100$ 

## 样例 #1

### 输入

```
7```

### 输出

```
ooooooo*******--
oooooo--******o*
oooooo******--o*
ooooo--*****o*o*
ooooo*****--o*o*
oooo--****o*o*o*
oooo****--o*o*o*
ooo--***o*o*o*o*
ooo*o**--*o*o*o*
o--*o**oo*o*o*o*
o*o*o*--o*o*o*o*
--o*o*o*o*o*o*o*
```

# 题解

## 作者：Steven_Meng (赞：90)

我们先分析一下样例
```
ooooooo*******--

oooooo--******o*
oooooo******--o*

ooooo--*****o*o*
ooooo*****--o*o*

oooo--****o*o*o*
oooo****--o*o*o*

ooo--***o*o*o*o*

ooo*o**--*o*o*o*
o--*o**oo*o*o*o*
o*o*o*--o*o*o*o*
--o*o*o*o*o*o*o*
```
每两行分一组的时候,可以很明显地看到规律.

- 中间的 "o*" 与 "--" 交换
- 最左边的 "**" 与 "--" 交换

然而后四行我并没有发现什么规律,于是无耻地打了一个表.

打表原理:

```
ooo*o**--* o*o*o*
o--*o**oo* o*o*o*
o*o*o*--o* o*o*o*
--o*o*o*o* o*o*o*
后6个字符为固定的"o*o*o*"
于是只要记录
	ooo*o**--*,
	o--*o**oo*,
	o*o*o*--o*,
	--o*o*o*o*
```
代码如下

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n;
char ch[205];//存储棋子的状态
void swap(char &a, char &b)//交换函数
{
    char t = a;
    a = b;
    b = t;
}
void output(){//输出
    for (int i = 0; i < 2 * n + 2; i++)
        putchar(ch[i]);
    putchar('\n');
}
void movechess(int start, int end)
{//移动棋子
    swap(ch[start], ch[end]);
    swap(ch[start + 1], ch[end + 1]);
    output();
}
string out[4] = {"ooo*o**--*", "o--*o**oo*", "o*o*o*--o*", "--o*o*o*o*"};
//打表qwq
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        ch[i] = 'o';
    for (int i = n; i < 2 * n; i++)
        ch[i] = '*';
    ch[2 * n] = '-';
    ch[2 * n + 1] = '-';
    //打印初始状态
    output();
    int len = n;
    //需要移动的黑/白棋子
    while (true)
    {
        movechess(len - 1, 2 * len);
        //中间的 "o*" 与 "--" 交换
        len--;
        if (len == 3)
        //不符合上述规律,开始输出打表内容
            break;
        movechess(len, 2 * len);
        //最左边的 "**" 与 "--" 交换
    }
    string ss;
    for (int i = 0; i < n - 4; i++)
        ss += "o*";
    for (int i = 0; i < 4; i++)
        cout << out[i] << ss << endl;
}
```

---

## 作者：HeartBlock_Love (赞：67)

【算法分析】

 我们先从n=4开始试试看，初始时：
 
           ○○○○●●●●
             
第1步：○○○——●●●○●  {—表示空位}

第2步：○○○●○●●——●

第3步：○——●○●●○○●

第4步：○●○●○●——○●

第5步：——○●○●○●○●

      如果n=5呢？我们继续尝试，希望看出一些规律，初始时：
      
           ○○○○○●●●●●
             
第1步：  ○○○○——●●●●○●

第2步：  ○○○○●●●●——○●

这样，n=5的问题又分解成了n=4的情况，下面只要再做一下n=4的5个步骤就行了。同理，n=6的情况又可以分解成n=5的情况，……，所以，对于一个规模为n的问题，我们很容易地就把他分治成了规模为n-1的相同类型子问题。

      数据结构如下：数组c[1..max]用来作为棋子移动的场所，初始时，c[1]~c[n]存放白子（用字符o表示），c[n+1]~c[2n]存放黑子（用字符*表示），c[2n+1]，c[2n+2]为空位置（用字符—表示）。最后结果在c[3]~c[2n+2]中。
      
```
#include<iostream>
using namespace std;
int n,st,sp;
char c[101];
void print()                                  //打印
{
	int i;
	cout<<"step "<<st<<':';
	for (i=1;i<=2*n+2;i++) cout<<c[i];
	cout<<endl;
	st++;
}
void init(int n)                             //初始化
{
	int i;
	st=0;
	sp=2*n+1;
	for (i=1;i<=n;i++) c[i]='o';
	for (i=n+1;i<=2*n;i++) c[i]='*';
	c[2*n+1]='-';c[2*n+2]='-';
	print();
}
void move(int k)                            //移动一步
{
	int j;
	for (j=0;j<=1;j++) 
	{
	   c[sp+j]=c[k+j];
	   c[k+j]='-';
	}
	sp=k;
	print();
}
void mv(int n)                                       //主要过程
{
	int i,k;
	if (n==4)                //n等于4的情况要特殊处理
	{
		move(4); move(8); move(2); move(7); move(1);
		}
	else
	{
		move(n); move(2*n-1); mv(n-1);
		}
}
int main()
{
	cin>>n;
	init(n);
	mv(n);
}

```


---

## 作者：DanielMeng (赞：24)

# 找规律直接做
## 发现第二行到倒数第六行有变化规律，剩下的几乎不变，直接输出
```
   最后5行分别是
   ooo--***+n-3个o*（如果n==4，这行就没有）
   ooo*o**--*+n-4个o*
   o--*o**o+n-3个o*
   o*o*o*--+n-3个o*
   --+n个o*
```
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	cout<<"o";
	for(int i=1;i<=n;i++)
	cout<<"*";
	cout<<"--"<<endl;	  //输出原始状态
	for(int i=2;i<=n-3;i++)
	{							//模拟规律
		for(int j=n;j>=i;j--)   //先输出n-i个"o"
		cout<<"o";
		cout<<"--";				//输出空格
		for(int j=n;j>=i;j--)   //再输出n-i个"*"
		cout<<"*";
		for(int j=1;j<i;j++)	//再输出i个"o*"
		cout<<"o*";
		cout<<endl;
		//-----分割线-----
		for(int j=n;j>=i;j--)
		cout<<"o";
		for(int j=n;j>=i;j--)
		cout<<"*";
		cout<<"--";
		for(int j=1;j<i;j++)
		cout<<"o*";		//把空格移到后面
		cout<<endl;
	}
	if(n>4)
	{
		cout<<"ooo--***";
		for(int i=1;i<=n-3;i++)
		cout<<"o*";
		cout<<endl;		//处理特例：如果n是4，这一步就没有
	}
   //---分割线---
	cout<<"ooo*o**--*";
	for(int i=1;i<=n-4;i++)
	cout<<"o*";
	cout<<endl;
	cout<<"o--*o**o";
	for(int i=1;i<=n-3;i++)
	cout<<"o*";
	cout<<endl;
	cout<<"o*o*o*--";
	for(int i=1;i<=n-3;i++)
	cout<<"o*";
	cout<<endl;
	cout<<"--";
	for(int i=1;i<=n;i++)
	cout<<"o*";
   //处理最后4行
   return 0;
}
```


---

## 作者：ars4me (赞：21)

这个题之前上课当作例题讲的

用的分治

-----------------------------------------------------------------------------------------------------

做这个题之前我们可以动手画一画 比如当n=4的时候应该怎么去移动

弄完n=4我们再去弄n=5..=6..=7..=8..

突然我们会发现 有一些步骤好像和前一个（也就是n-1）个一样

这样 n=5时有些地方和 n=4一样  n=6时有些地方和 n=5 一样

我们就可以把n的问题分解成n-1的问题（分治）

因此：

我们用一个数组chess作为“棋子移动的地方” 并且按照题目要求初始

函数Initial用来初始

函数Reflect\_用来输出

函数doo用来按题意执行 并且移动棋子

注意！答案最后应该在  chess 3~2n+2  中！别忘了

-----------------------------------------------------------------------------------------------------

当然这个题还有一个要点 因为n>=4（题干第一行） 所以分治后n==4是最小的规模

那么 我们就得特殊处理一下n==4的情况

其他的看代码吧

代码如下

```cpp
#include<iostream>
using namespace std;
int n,s;
char chess[101];
void Reflect_()
{
    for(int i=1;i<=2*n+2;i++){
        cout<<chess[i];
    }
    cout<<endl;
}
void Initial(int n)
{
    s=2*n+1;
    for(int i=1;i<=n;i++){
        chess[i]='o';
    }
    for(int i=n+1;i<=2*n;i++){
        chess[i]='*';
    }
    for(int i=2*n+1;i<=2*n+2;i++){
        chess[i]='-';
    }
    Reflect_();
}
void Fdoo(int k)
{
    for(int i=0;i<=1;i++){
        chess[s+i]=chess[k+i];
        chess[k+i]='-';
    }
    s=k;
    Reflect_();
}
void Sdoo(int n)
{
    int k;
    if(n==4){
        Fdoo(4);Fdoo(8);Fdoo(2);Fdoo(7);Fdoo(1);
    }
    else{
        Fdoo(n);Fdoo(2*n-1);Sdoo(n-1);
    }
}
int main()
{
    cin>>n;
    Initial(n);
    Sdoo(n);
}
//COYG
```

---

## 作者：千梦羽翼 (赞：18)

                                   分治思想
```
细心观察@-@然后找规律
```
------------
先看样例：https://cdn.luogu.com.cn/upload/pic/23680.png
发现在n<=4时有规律，重复两次，然后不断将规模缩小，然后到n=4时发现规律不重复，所以单独考虑。

------------
```
#include<bits/stdc++.h>
using namespace std;
int sp,n;
string c[206];
void printff(){ //输出
	for (int i=1;i<=2*n+2;i++)
	  cout<<c[i];
	cout<<endl;
}
void move(int p){
	for (int j=0;j<=1;j++){
		c[sp+j]=c[p+j];
		c[p+j]="-";
	}
	sp=p;//记录空白“-”的位置，方便下一次输出
	printff();
}
void pu(int k){
	if (k==4) {//单独考虑
		move(4);move(8);move(2);move(7);move(1);
	}else{
		move(k);move(2*k-1);pu(k-1);
	}
}
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++)//初始化
	c[i]="o";
	for (int i=n+1;i<=2*n;i++)
	c[i]="*";c[2*n+1]="-";c[2*n+2]="-";
	sp=2*n+1;
	printff();
	pu(n);
	return 0;
}
```
```
以上是AC程序。真香~
```

---

## 作者：无声告白 (赞：14)

分析：分治的思想。
这里普及一下分治~~大佬就别看了~~

所谓分治就是指的分而治之，即将较大规模的问题分解成几个较小规模的问题，通过对较小规模问题的求解达到对整个问题的求解。当我们将问题分解成两个较小问题求解时的分治方法称之为二分法。

再看题目

 我们先从n=4开始试试看，初始时：
             ○○○○●●●●
             
第1步：○○○——●●●○●  {—表示空位}

第2步：○○○●○●●——●

第3步：○——●○●●○○●

第4步：○●○●○●——○●

第5步：——○●○●○●○●

      如果n=5呢？我们继续尝试，希望看出一些规律，初始时：
             ○○○○○●●●●●
第1步：○○○○——●●●●○●

第2步：○○○○●●●●——○●

       这样，n=5的问题又分解成了n=4的情况，下面只要再做一下n=4的5个步骤就行了。
       同理，n=6的情况又可以分解成n=5的情况，……，所以，对于一个规模为n的问题，我们很容易地就把他分治成了规模为n-1的相同类型子问题。
       
      数据结构如下：数组c[1..max]用来作为棋子移动的场所，初始时，c[1]~c[n]存放白子（用字符o表示），
      c[n+1]~c[2n]存放黑子（用字符*表示），c[2n+1]，c[2n+2]为空位置（用字符—表示）。最后结果在c[3]~c[2n+2]中。
代码：

```cpp
#include<iostream>
using namespace std;
int n,st,sp;
char c[101];
void print()                                  //打印
{
	int i;
	cout<<"step "<<st<<':';
	for (i=1;i<=2*n+2;i++) cout<<c[i];
	cout<<endl;
	st++;
}
void init(int n)                             //初始化
{
	int i;
	st=0;
	sp=2*n+1;
	for (i=1;i<=n;i++) c[i]='o';
	for (i=n+1;i<=2*n;i++) c[i]='*';
	c[2*n+1]='-';c[2*n+2]='-';
	print();
}
void move(int k)                            //移动一步
{
	int j;
	for (j=0;j<=1;j++) 
	{
	   c[sp+j]=c[k+j];
	   c[k+j]='-';
	}
	sp=k;
	print();
}
void mv(int n)                                 //主要过程
{
	int i,k;
	if (n==4)                               //n等于4的情况要特殊处理
	{
		move(4); move(8); move(2); move(7); move(1);
		}
	else
	{
		move(n); move(2*n-1); mv(n-1);
		}
}
int main()
{
	cin>>n;
	init(n);
	mv(n);
    return 0；
}

```

---

## 作者：doby (赞：5)

不作过多的注解了，反正你们也不会看的……

总之只有最后四步不和谐，因此最后四步单独打表，其他的直接找规律……

```cpp
#include<iostream>  
using namespace std;  
int n,i,j;  
int main()  
{  
    cin>>n;  
    for(i=0;i<n;i++){cout<<"o";}  
    for(i=0;i<n;i++){cout<<"*";}  
    cout<<"--"<<endl;  
    for(i=n-1;i>2;i--)  
    {  
        if(i>3)  
        {  
            for(j=0;j<i;j++){cout<<"o";}  
            cout<<"--";  
            for(j=0;j<i;j++){cout<<"*";}  
            for(j=0;j<n-i;j++){cout<<"o*";}  
            cout<<endl;  
            for(j=0;j<i;j++){cout<<"o";}  
            for(j=0;j<i;j++){cout<<"*";}  
            cout<<"--";  
            for(j=0;j<n-i;j++){cout<<"o*";}  
            cout<<endl;  
        }  
        if(i==3)  
        {  
            for(j=0;j<i;j++){cout<<"o";}  
            cout<<"--";  
            for(j=0;j<i;j++){cout<<"*";}  
            for(j=0;j<n-i;j++){cout<<"o*";}  
            cout<<endl;  
        }  
    }  
    cout<<"ooo*o**--*";  
    for(i=0;i<n-4;i++){cout<<"o*";}  
    cout<<endl;  
    cout<<"o--*o**oo*";  
    for(i=0;i<n-4;i++){cout<<"o*";}  
    cout<<endl;  
    cout<<"o*o*o*--o*";  
    for(i=0;i<n-4;i++){cout<<"o*";}  
    cout<<endl;  
    cout<<"--o*o*o*o*";  
    for(i=0;i<n-4;i++){cout<<"o*";}  
    cout<<endl;  
}
```

---

## 作者：吴国铨 (赞：5)

看来p党也不少

黑白棋子

遇到这种类型的题，你系要找一些简单的例子手工模拟一下，以寻求规律。

n=4
oooo****--

ooo--***o\*

ooo\*o**--\*

o--\*o**oo\*

o\*o\*o\*--o\*

--o\*o\*o\*o\*

n=5
ooooo*****--

oooo--****o\*

oooo****--o\*

n=6
oooooo******--

ooooo--*****o\*

ooooo*****--o\*

由此可见，当n>=4时，先将第K和第K+1个棋子移到最右边，再将第2K-1和2K个棋子移到K和K+1处。

则规模为K的问题可转化为规模为K-1的问题，符合递归的特点

代码献上：

```cpp
//递归过程
procedure move(x:longint);
begin
  if x>4 then
  begin
    a[2*x+1]:=a[x]; a[2*x+2]:=a[x+1];
    a[x]:='-'; a[x+1]:='-';
    for i:=1 to 2*n+2 do write(a[i]);
    writeln;
    a[x]:=a[2*x-1]; a[x+1]:=a[2*x];
    a[2*x-1]:='-'; a[2*x]:='-';
    for i:=1 to 2*n+2 do write(a[i]);
    writeln;
    move(x-1);
  end;
end;
```
主程序自己写吧
注意当n<=4时需要手动输出


---

## 作者：gryql (赞：3)

分析样例数据可以看到，在最前方的白棋还剩下三个以上时，我们可以把最后一个白棋和其后的第一个黑棋一起移动到空格的位置，输出，然后把最后两个黑棋移动到空格的位置，输出。在最前方的白棋还剩下3个时，继续这样的方法就不适用了。因为无论如何都会到达还剩三步的状态，所以寻找规律直接输出最后几行即可。


四个指针的作用：l:连续的最后一个白棋出现的位置；h：连续的最后一个黑棋出现的位置；j第一个空格的位置；k：最后一个空格的位置

```delphi

var a:array[1..10000] of char;
    n,i,j,k,l,h,x,y:longint;

procedure printf;
var i:longint;
begin
    for i:=1 to 2*n+2 do write(a[i]);
    writeln;
end;

begin
    readln(n);
    for i:=1 to n do
        a[i]:='o';
    for i:=n+1 to n*2 do
        a[i]:='*';
    a[2*n+1]:='-';
    a[2*n+2]:='-';
    printf;
    l:=n;//last'o'
    h:=2*n;//last'*'
    j:=2*n+1;k:=2*n+2;//'-'
    while l>3 do
        begin
            a[j]:=a[l];
            a[k]:=a[l+1];
            a[l]:='-';
            a[l+1]:='-';
            printf;
            a[l]:='*';
            a[l+1]:='*';
            a[h]:='-';
            a[h-1]:='-';
            if l<>4 then printf;
            k:=h;
            j:=h-1;
            dec(l);
            dec(h,2);
        end;
    write('ooo*o**--*');
    for i:=1 to n-4 do write('o*');
    writeln;
    write('o--*o**oo*');
    for i:=1 to n-4 do write('o*');
    writeln;
    write('o*o*o*--o*');
    for i:=1 to n-4 do write('o*');
    writeln;
    write('--o*o*o*o*');
    for i:=1 to n-4 do write('o*');
    writeln;
end.

```
当然还有一种寻找字符串规律输出的做法，甚至不用开数组，详见http://www.cnblogs.com/yangqingli/p/4867334.html


---

## 作者：snaptrap (赞：3)

这题只要找到一定的规律就可以了。
比如：
n=5
●●●●●○○○○○--
●●●●--○○○○●○
**(●●●●○○○○)**--●○
括号里的不就是n=4时的样子吗？然后直接按题目要求移动，即Move(4,8,2,7,1)。
当然，如果你不想用公式Move(4,8,2,7,1)也可以继续递归分解把它变成n=3、n=2。
如果看不懂，那画一幅数组图模拟一下（设n=5）。

c[1] c[2] c[3] c[4] c[5] c[6] c[7] c[8] c[9] c[10] c[11] c[12]
  o    o    o    o    o    *    *    *    *    *     -     -
1. Move(n);等价于Move(5);
c[1] c[2] c[3] c[4] c[5] c[6] c[7] c[8] c[9] c[10] c[11] c[12]
  o    o    o    o   (o    *)   *    *    *    *    (-     -)
2. 括号处互换
c[1] c[2] c[3] c[4] c[5] c[6] c[7] c[8] c[9] c[10] c[11] c[12]
  o    o    o    o   (-    -)   *    *   (*    *)    o     *
3. 括号处再次互换
c[1] c[2] c[3] c[4] c[5] c[6] c[7] c[8] c[9] c[10] c[11] c[12]
  o    o    o    o    *    *    *    *    -    -     o     *
  模拟结束，下面看代码：
```cpp
#include <iostream>
using namespace std;
int Fc8[6]={0,4,8,2,7,1};
int n,s,i,j,v;
char c[1001];
char sc[1001][1001];
void PrintData()//输出
{
	int i;
	for(i=1;i<=2*n+2;i++) cout<<c[i];
	cout<<endl;
}
void Move(int x)
{
	int i;
	for(i=1;i<=2;i++)
	{
		c[s+i-1]=c[x+i-1];
		c[x+i-1]='-';
	}
	s=x;
	PrintData();
}
void MoveProcedure(int n)
{
	int i,k;
	if(n==4)//n等于4的情况需特殊处理（只是题目不让我们不特殊处理，还可以分解成n=3，最后只剩下一个）
	{
		for(i=1;i<=5;i++)
		Move(Fc8[i]);//等价于Move([4,8,2,7,1])
	}
	else
	{
		Move(n); //移走中间两颗相邻棋子，该为变为“--”
		Move(2*n-1);//从最后数两颗黑子移到刚才中间“--”处
		MoveProcedure(n-1); //对剩下的n-1可棋子继续分
	}
}
int main()
{
	cin>>n;
	s=2*n+1;
	for(i=1;i<=n;i++) c[i]='o';//7个白子
	for(i=n+1;i<=2*n;i++) c[i]='*';//7个黑子
	for(i=1;i<=2;i++) c[2*n+i]='-';//2个空格
	PrintData();//先输出一下
	MoveProcedure(n);
}
```

---

## 作者：华恋_韵 (赞：2)

其实主要就是一种递归的思想，~~整体来说很简单~~

大致思路就是把n个棋子转换成n-1个棋子做，由于4很特殊

所以单独输出；

初始化——（向后移——向前移——判断）（循环递归）——暴力枚举——输出


AC代码如下（定义了好多函数....）
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
void hou(long long n);
void qian(long long n);
void si(long long n);
void chu(long long n);
void shu(long long x);
char a[100001]; 
bool j=true;
long long n,x=0;
int main()//主程序（好少）
{

    cin>>n; 
    chu(n); 
    return 0;
}
void chu(long long n)//初始化 
{
    if(j)//赋值一下 
    {
        for(int i=1;i<=2*n;i++)//把棋子初始化
            a[i]='o';
        for(int i=n+1;i<=2*n;i++)
            a[i]='*';
        for(int i=2*n+1;i<=2*n+2;i++)
            a[i]='-';
        shu(x);
        j=false;
    }
    if(n==4) si(n); //如果还剩四个，单独输出
    if(n>4) hou(n); //否则继续操作
}
void hou(long long n) //向后移
{
    if(a[1]!='-')
   {  
    swap(a[n],a[2*n+1]);//交换位置
    swap(a[n+1],a[2*n+2]);
    shu(x);    //输出输出 
    qian(n);//做向前操作
    } 
    else return;
 } 
void qian(long long n)//向前移 
{
    swap(a[n],a[2*n-1]);//交换为主
    swap(a[n+1],a[2*n]);
    n--;
    shu(x);//一波输出 
    chu(n);//一波操作做完判断是否大于4 
}
void si(long long n)//4单独输出（暴力枚举） 
{
    swap(a[4],a[9]);
    swap(a[5],a[10]);
    shu(x);
    swap(a[4],a[8]);
    swap(a[5],a[9]);
    shu(x);
    swap(a[2],a[8]);
    swap(a[3],a[9]);
    shu(x);
    swap(a[2],a[7]);
    swap(a[3],a[8]);
    shu(x);
    swap(a[1],a[7]);
    swap(a[2],a[8]);
    shu(x);
    return;
} 
void shu(long long y)//负责输出 
{
    for(int i=1;i<=n*2+2;i++)
        cout<<a[i];
    cout<<endl;
    x++;
}
```
蒟蒻解题，大佬勿喷，如若有改进地方，欢迎指出，谢谢！

---

## 作者：yyyyyyy (赞：2)

解析：

我们先从n=4开始试试看，初始时：

○○○○●●●●

第1步：○○○——●●●○●（—表示空位） 48+1

第2步：○○○●○●●——●               84

第3步：○——●○●●○○●               28

第4步：○●○●○●——○●               72

第5步：——○●○●○●○●               17

如果n=5呢？我们继续尝试，希望看出一些规律，初始时：

○○○○○●●●●●

第1步：○○○○——●●●●○●

第2步：○○○○●●●●——○●

这样，n=5的问题又分解成了n=4的情况，下面只要再做一下n=4的5个步骤就行了。同理，n=6的情况又可以分解成n=5的情况，……，

因此，对于一个规模为n的问题，我们很容易地就把它分治成了规模为n-1的相同类型子问题。任何其它规模的问题最终都将可以使其转换成为n=4的情况，因而本题的边界重点特别处理的是当n=4的情况。

数据结构如下：数组b[1..maxn]用来作为棋子移动的场所，初始时，c[1]~c[n]存放白子（用字符o表示），c[n+1]~c[2n]存放黑子（用字符\*表示），c[2n+1]，c[2n+2]为空位置（用字符—表示）。最后结果在c[3]~c[2n+2]中。


program chessman;

const maxn=1000;

var
{数组b[1..maxn]用来作为棋子移动的场所}

```cpp
  b:array[1..maxn]of char;
  pt,i,n,num:integer; {pt用来指向移动点的位置，即可理解为空地，当棋子移走后，将留下新的空地，因而pt的值在每一次移动棋子的过程中，会随棋子的移动不断更新！}
procedure print;
  var
    i:integer;
  begin
    inc(num); {num，用来记录所移动的次数}
    for i:=1 to 2*(n+1) do write(b[i]); {输出所有棋子当前的状态}
    writeln;
  end;
procedure move(k:integer);
  var
    i:integer;
  begin
    for i:=0 to 1 do  begin {每一次均移动两颗棋子}
      b[pt+i]:=b[k+i];
      b[k+i]:='-'; {移走后该位置的状态}
    end;
    pt:=k; {pt指向新的空地}
    print;
  end;
procedure mv(n:integer);
  begin
    if n=4 then begin {重点：边界处的处理，即其移动方案}
      move(4);
      move(8);
      move(2);
      move(7);
      move(1);
end
```
{两次移动棋子位置的调整，可以将O（n）规模问题转换成等价的O（n-1）的等价子问题
分治思想的体现正在此！}

```cpp
    else begin 
           move(n);
           move(2*n-1);
           mv(n-1);
         end;
  end;
begin
 { assign(input,'chessman2.in'); reset(input);}
  readln(n);
 { close(input);}
  for i:=1 to n do b[i]:='o';
  for i:=n+1 to 2*n do b[i]:='*';
  b[i+1]:='-'; b[i+2]:='-';
  pt:=2*n+1;
  num:=-1;
  print;
  mv(n);
end.
```

---

## 作者：UKE开车自动机 (赞：2)

（上次发的太乱了，重新发一下）

这道题用的是分冶算法，我们可以画图。

画完n==4的情况，接着n==5、n==6……

我们会发现n==5情况下，有些步骤是和（n-1）的步骤是相同的，n==6也是。

因此，我们把这个主问题分解成子问题，分冶就派上用场了。

注意，n==4时要特判，因为它是分冶后最小的n。

代码如下：

```cpp
#include<iostream>
 using namespace std;
 int n,st,sp; char c[101];
 void print() //打印
 { int i; for(i=1;i<=2*n+2;i++) 
cout<<c[i]; cout<<endl; 
} 
void inti(int n) //初始化 
{ 
int i; st=0; 
sp=2*n+1; for(i=1;i<=n;i++)
 c[i]='o'; 
for(i=n+1;i<=2*n;i++) 
c[i]='*'; 
c[2*n+1]='-';
c[2*n+2]='-'; 
print();
 } void move(int k) //移动一步
 { int j; for(j=0;j<=1;j++) 
{ c[sp+j]=c[k+j]; c[k+j]='-'; 
} sp=k; print(); } 
void mv(int n) //主要过程 
{ 
int i,k; if(n==4) //n等于4时要特判 
{
 move(4);move(8);move(2);move(7);move(1); 
} else{ move(n);move(2*n-1);mv(n-1); }
 } int main(){ 
cin>>n;
 inti(n);
 mv(n); 
return 0; 
}
```

---

## 作者：ironwheel (赞：1)

/￥这就是一个不知道该怎么形容的算法，有点啰嗦￥


//￥n==4时应该特判，特判！！之后就直接打表输出了￥


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,step=0,cc;
char c[101];//￥全局字符数组，存储黑白棋子，交换什么的都要在这个数组里进行￥ 
void pr(int cc)//￥打印函数￥ 
{
    for(int i=1;i<=2*cc+2;i++)
    {
        cout<<c[i];
    }
    cout<<endl;
    step++;//￥没什么用 ￥ 
}
void csh()//￥初始化函数，不用多说￥ 
{
    cin>>n;
    cc=n;
    for(int i=1;i<=n;i++)
    {
        c[i]='o';
    }
    for(int i=n+1;i<=2*n;i++)
    {
        c[i]='*';
    }
    c[2*n+1]=c[2*n+2]='-';
    pr(cc);
}
void move(int now,int to)//￥交换函数，把c[now]和c[to]进行交换，并把c[now]变成空，也就是'-'￥ 
{
    swap(c[now],c[to]);
    c[now]='-';
}
void important(int cc)//￥程序的骨干，这就是为什么叫important函数了￥ 
{
    if(n==4)//￥交换时如果遇到4要进行特判，特殊交换，这里直接把4以后的步骤全部做完了￥ 
    {
        move(4,9);//￥特殊交换步骤不多说，参照样例￥ 
        move(5,10);
        pr(cc);//￥疯狂打印￥ 
        move(8,4);
        move(9,5);
        pr(cc);//￥打印￥ 
        move(2,8);
        move(3,9);
        pr(cc);//￥还是打印￥ 
        move(7,2);
        move(8,3);
        pr(cc);//￥依然是打印￥ 
        move(1,7);
        move(2,8);
        pr(cc);
    }
    else
    {
        move(n,n*2+1);//￥不是4时候的交换步骤，千篇一律￥ 
        move(n+1,n*2+2);
        pr(cc);
        move(n*2-1,n);
        move(n*2,n+1);
        pr(cc);
        n--;
        important(cc);//￥递归调用￥ 
    }
}
int main()//￥简短的主程序￥ 
{
    csh();
    important(cc);
}
//大家应该能看得懂吧？
```

---

## 作者：yin_sy (赞：1)

这题前面是有规律可循的，每次分两个部分，第一部分先把o\*移到空格处，第二次再移个**过去，最后四个特殊处理。

```cpp
var  
  v,n,i,j:longint;  
  t:char;  
  a:array [1..1000000] of char;  
begin  
  readln(n);  
  for i:=1 to n do  
    a[i]:='o';  
  for i:=n+1 to n*2 do  
    a[i]:='*';  
  a[n*2+1]:='-';  
  a[n*2+2]:='-';  
  for i:=n downto 4 do  
  begin  
    for j:=1 to n*2+2 do  
      write(a[j]);  
    writeln;  
    t:=a[i];  
    a[i]:=a[i*2+1];  
    a[i*2+1]:=t;  
    t:=a[i+1];  
    a[i+1]:=a[i*2+2];  
    a[i*2+2]:=t;  
    for j:=1 to n*2+2 do  
      write(a[j]);  
    writeln;  
    t:=a[i];  
    a[i]:=a[i*2-1];  
    a[i*2-1]:=t;  
    t:=a[i+1];  
    a[i+1]:=a[i*2];  
    a[i*2]:=t;  
  end;  
  write('ooo*o**--');  
  for i:=1 to n-4 do  
    write('*o');  
 writeln('*');  
  write('o--*o**oo');  
  for i:=1 to n-4 do  
    write('*o');  
  writeln('*');  
  write('o*o*o*--o*');  
  for i:=1 to n-4 do  
    write('o*');  
  writeln;  
  write('--');  
  for i:=1 to n do  
    write('o*');  
end.
```

---

## 作者：Reanap (赞：1)

#     找规律+打表
    首先观察样例，我们发现在有2n（n>4）个棋子未归位时，就是把
    中间的一黑一白的棋子挪到最后，然后再把棋子往前挪
    
    如果n<=4时则是固定操作（见样例）
    
    
    #include <cstdio>
    #include <algorithm>
    using namespace std;
    char a[205];
    int n;
    void print();
    void mov(int t) {
        if(t==4) return;
        swap(a[t],a[t*2+1]);
        swap(a[t+1],a[t*2+2]);
        print();
        swap(a[t],a[t*2]);
        swap(a[t+1],a[t*2-1]);
        print();
        mov(t-1);
        //n>4时的操作
    }
    void print() {
        for(int i=1;i<=2*n+2;++i) printf("%c",a[i]);
        printf("\n");
    }
    //输出函数
    int main() {
        scanf("%d",&n);
        for(int i=1;i<=n;++i) {
            a[i]='o';
        }
        for(int i=n+1;i<=n*2;++i) {
            a[i]='*';
        }
        a[n*2+1]=a[n*2+2]='-';
        print();
        mov(n);
        //以下为n<=4时的固定操作（打表）
        swap(a[4],a[9]);
        swap(a[5],a[10]);
        print();
        swap(a[4],a[8]);
        swap(a[5],a[9]);
        print();
        swap(a[2],a[8]);
        swap(a[3],a[9]);
        print();
        swap(a[2],a[7]);
        swap(a[3],a[8]);
        print();
        swap(a[1],a[7]);
        swap(a[2],a[8]);
        print();
        return 0;
    }

---

## 作者：hanghang0702 (赞：0)

方法一

将N的游戏变为4，然后打表。

```delphi
var n,io,i:longint;
    a:array[1..100] of char;
procedure o;
var i:longint;
begin
 for i:=1 to io do write(a[i]);
 writeln;
end;
procedure move(m1,m2:longint);
var t:char;
begin
 t:=a[m1];a[m1]:=a[m2];a[m2]:=t;
end;
begin
 readln(n); io:=n*2+2;
 for i:=1 to n do a[i]:='o';
 for i:=n+1 to 2*n do a[i]:='*';
 a[2*n+1]:='-';a[2*n+2]:='-'; o;
 while n>4 do
 begin
  move(n,2*n+1);move(n+1,2*n+2);o;
  move(2*n-1,n);move(2*n,n+1);o;
  dec(n);
 end;
 move(n,2*n+1);move(n+1,2*n+2);o;
 move(2*n,n);move(2*n+1,n+1);o;
 move(2,2*n);move(3,2*n+1);o;
 move(2*n-1,2);move(2*n,3);o;
 move(1,2*n-1);move(2,2*n);o;
end.
{32Line}

```
方法二

递归 思想一样

```delphi
var n,io,i:longint;
    a:array[1..100] of char;
procedure move(m1,m2:longint);
var t:char;
begin
 t:=a[m1];a[m1]:=a[m2];a[m2]:=t;
end;
procedure o;
var i:longint;
begin
 for i:=1 to io do write(a[i]);
 writeln;
end;
procedure work(n:longint);
begin
 if n=4 then
 begin
  move(n,2*n+1);move(n+1,2*n+2);o;
  move(2*n,n);move(2*n+1,n+1);o;
  move(2,2*n);move(3,2*n+1);o;
  move(2*n-1,2);move(2*n,3);o;
  move(1,2*n-1);move(2,2*n);o;
  halt;
 end;
 move(n,2*n+1);move(n+1,2*n+2);o;
 move(2*n-1,n);move(2*n,n+1);o;
 work(n-1);
end;
begin
 readln(n); io:=n*2+2;
 for i:=1 to n do a[i]:='o';
 for i:=n+1 to 2*n do a[i]:='*';
 a[2*n+1]:='-';a[2*n+2]:='-'; o;
 work(n);
end.
{38Line}

```

---


# [NOIP 2013 提高组] 积木大赛

## 题目背景

NOIP2013 提高组 D2T1

## 题目描述

春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 $n$ 的大厦，大厦可以看成由 $n$ 块宽度为 $1$ 的积木组成，第 $i$ 块积木的最终高度需要是 $h_i$。

在搭建开始之前，没有任何积木（可以看成 $n$ 块高度为 $0$ 的积木）。接下来每次操作，小朋友们可以选择一段连续区间 $[l, r]$，然后将第 $L$ 块到第 $R$ 块之间（含第 $L$ 块和第 $R$ 块）所有积木的高度分别增加 $1$。

小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。


## 说明/提示

**样例解释**

其中一种可行的最佳方案，依次选择：$[1,5]$，$ [1,3]$，$[2,3]$，$[3,3]$，$ [5,5]$。

**数据范围**

- 对于 $30\%$ 的数据，有 $1 \leq n \leq 10$；
- 对于 $70\%$ 的数据，有 $1 \leq n \leq 1000$；
- 对于 $100\%$ 的数据，有 $1 \leq n \leq 100000$，$0 \leq h_i \leq 10000$。


## 样例 #1

### 输入

```
5
2 3 4 1 2```

### 输出

```
5```

# 题解

## 作者：缄默Mutism (赞：43)

其实这道题没有那么麻烦（非常简单），只需要计算相邻两堆的高度差就行了。q为左边一堆高度，p为右边一堆高度，s为总摆放次数。

1.q<p，即左边的一堆比右边矮，左边的一堆摆完后，右边的还差一点，那么摆放次数s加上两堆的高度差p-q（相当于摆好了右堆）。

2.q>=p，即左边的一堆比右边矮，说明只要左边的一堆堆好了，那么右边的一堆也肯定堆好了，所以不需要增加摆放次数s。

附上代码(p党):

    readln(n); 
    for i:=1 to n do
      begin
          read(p);
          if q<p then s:=s+p-q;
          q:=p;
      end;
     writeln(s);

---

## 作者：niuniudundun (赞：5)

[原题。](https://www.luogu.com.cn/problem/P1969)

# 题目大意

你需要让一串 $n$ 个元素均为 $0$ 的序列，第 $i$ 个数变成 $h_i$，每次可以选择一个 $[l,r]$ 使 $[l,r]$ 的数字加一，求次数。

# 解法

对于一个 $h_i>h_{i-1}$，那么当对 $[i,i-1]$ 加一时，$h_{i-1}$ 就会被 $h_i$ 顺便加一，多的次数就是 $h_i-h_{i-1}$，所有 $h_i-h_{i-1}$ 就是答案，不过需要前提条件 $h_i>h_{i-1}$。

所以答案为：$\displaystyle \sum_{i=1}^{n} [h_i>h_{i-1}]\times (h_i-h_{i-1})$（其中 $[]$ 是艾弗森括号，真返回 $1$，假返回 $0$）。

代码：

复杂度：$O(n)$。

```cpp
//多倍经验：P5019 P3078
#include<iostream>
using namespace std;
long long n,d[100001],ans=0;//d 就是 h
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>d[i];
	}
	for(int i=1;i<=n;i++){
		if(d[i]>d[i-1]) ans+=d[i]-d[i-1];
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：FZzzz (赞：5)

前排提示：本题解**并不是**（也许是？）普及内容！

首先你看到这个题要求的东西是可以用线性规划描述的！我令每个区间 $[l,r]$ 被操作的次数为一个变量 $x_{l,r}$，每个位置对应一个约束，写出线性规划式：
$$\begin{aligned}\text{minimize}\sum x_{l,r}\\\begin{cases}\forall i,\sum\limits_{i\in[l,r]}x_{l,r}=a_i\\\forall x_{l,r}\ge0\end{cases}\end{aligned}$$
然后硬上对偶！由于是普及组题解所以我现场解释一下怎么对偶，就是下面这个图：

[![](https://img-blog.csdnimg.cn/20210223004933901.png)](https://blog.csdn.net/qq_43657442/article/details/106074037)

（出处点击图片）

对偶后每个位置对应一个 $b_i$，写出对偶之后的式子：
$$\begin{aligned}\text{maximize}\sum a_ib_i\\\forall[l,r],\sum\limits_{i\in[l,r]}b_{i}\le1\end{aligned}$$
用人话解释一下，就是求一个序列 $b$ 使得最大子段和不大于 $1$，最后最大化 $a_ib_i$ 的和。现在你发现你已经把一个不可做题（大嘘）转化成了一个更加不可做的题！让我们来分析一下性质：

首先如果有两个 $b$ 大于零并且它们中间全是 $0$，那么可以把其中 $a$ 大一点的那个变成两个的和，剩下一个变成零，这样显然是不会使得约束被破坏或是使答案变劣。而有两个相邻的小于零的 $b$ 时也是同理，所以把零去掉之后 $b$ 必然是正数和负数交替出现的。

考虑如果 $b$ 序列中有一个负数大于 $-1$，考虑它两边的两个正数。如果其中有一个为 $1$，那么把这个负数和另一个都变成零必然不劣。否则若这个负数对应的 $a$ 比两个正数对应的 $a$ 都要大，则把这个负数变成这三个数的和，两个正数变成零不劣。否则，将这个负数减去一个值，同时将两个正数中 $a$ 更大的一个的 $b$ 加上同样的值，不劣。那么可以进行若干次这样的操作，最后所有正数都为 $1$，负数为 $-1$。

现在我们已经得到了一个性质：$b$ 除 $0$ 之外，必然是 $1$ 和 $-1$ 交错，于是可以直接 dp 了。由于是普及组题解所以解释一下怎么 dp：设 $f_i$ 为当前到第 $i$ 位的最大值，$g_i$ 为到第 $i$ 位，并且在下一个 $1$ 之前必须放一个 $-1$ 的最大值，容易写出转移。

由于是普及组题解所以放一下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll readint(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	int n=readint(),f=0,g=0;
	while(n--){
		int a=readint(),f2=f,g2=g;
		f=max(f2,g2+a);
		g=max(g2,f2-a);
	}
	printf("%d\n",f);
	#ifdef LOCAL
	fprintf(stderr,"%d\n",(int)clock());
	#endif
	return 0;
}
```
题外话：转化出来的这个题我本来给的做法是用对偶转转化成积木大赛，结果被 fyk 用直接 dp 日了……一气之下（雾）水了这个题解。

另外我并不会用这题的语言直接解释这个代码，有没有老哥教教我啊。

---

## 作者：GSQ0829 (赞：1)

### 思路：
需要用最少的操作次数，将某些高度不同的积木搭建到指定高度。

很简单。这道题就是填坑法，所以用贪心。

假设现在有一个坑，但旁边又有一个坑。

那么你就会将两个坑一起减掉一。

那么小的坑肯定会被大的坑“带着”填掉。

大的坑也会减少相应的深度。

这就是贪心策略。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a, last = 0, ans = 0;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a;
		if (a > last) ans += (a - last);
		last = a;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：nju_zdd (赞：1)

# 这是比较简单的一道贪心
## 纯模拟即可



最后答案肯定至少要填第一个坑那么多次，所以直接读第一个坑的深度就好了.如果后面的深于当前目标，显然要多填几次;如果小于，现在在填这一个坑的时候顺便就可以把下一个填好了.所以只要+下一个坑比现在深的深度的就可以了.

------------
**详见注释。**

$\color{red}\text{附AC代码：}$
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;

template<typename T>
void read(T &x){
	x=0;int f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	x*=f;
}
int main(){
	int ans,s,now;
	read(n);
	read(ans);//最后答案肯定至少要填第一个坑那么多次，所以直接读第一个坑的深度就好了
	now=ans;//记录当前坑的深度
	for (int i=2;i<=n;i++){
		read(s);
		if(s>now) ans=ans+s-now;//如果后面的深于当前目标，显然要多填几次
//如果小于，现在在填这一个坑的时候顺便就可以把下一个填好了
//所以只要+下一个坑比现在深的深度的就可以了
		now=s;//更新现在目标的值
	}
	cout<<ans;
	return 0;
}


```
$\color{orange}\text{好了就是这样，祝大家切橙题愉快！}$

---

## 作者：ZMYJOE (赞：1)

比较简单的**贪心**

考虑最优的**建造策略**：

每次选择最左边的一个还未建好的积木，将其高度加一，同时使右边尽可能多的积木高度也加一（注意要是**连续**的一段）。

简单地证明一下：对于一个未建好的积木，如果不在当前这一步将其高度加一，则必然要在后面的某一步中加上，在当前加上至少不会更差。

**计算方案**：

直接模拟会TLE...

所以稍加思索就会发现：

我们可以考虑**每一个积木作为最左边的时候高度加一的次数**；

当该积木比上一个矮时显然次数为0；

当该积木比上一个高时，还需要的次数即为该积木的高度减去上一个的高度。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=100000+10;
int n;
int h[maxn],p[maxn];

int read(int &x) {
    int f=1;
    x=0;
    char c=getchar();
    while(c>'9' || c<'0') {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9') {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}

int main() {
    read(n);
    for(int i=1; i<=n; ++i) read(h[i]);
    h[0]=0;
    int ans=0;
    for(int i=1; i<=n; ++i) {
        if(h[i]>h[i-1]) ans+=h[i]-h[i-1];
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：ycy1124 (赞：1)

前言：[双倍经验。](https://www.luogu.com.cn/problem/P5019)
### 题意
题意，在一段长度为 $n$ 的区间，区间内每个位置初始高度都是 $0$，现在给一个目标区间，每次可以让一段连续区间内的高度增加一，试问最少需要多少次操作才能变成目标区间。
### 思路
我们可以从前往后扫，每次选择一段最长的区间增加 $1$，这样一定是最优的。假设我们现在能覆盖到一个最远距离而不延长，那么他到后面自己覆盖的次数一定是比现在覆盖更劣的。所以这样一定是最优的。

于是我们可以用一种最死板的方法，从前往后扫，然后每次向后延长最远的距离将这个区间内的高度减一直到自己被减完。这种做法的极限复杂度为 $\mathcal{O}( \sum_{i=1}^nh_i )$，最大 $10^9$，刚好能够通过。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int main()
{
	int n,js=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	int i=1,j=1;
	bool b;
	while(a[i]!=0||i!=n)
	{
		j=i;
		b=1;
		while(a[j+1]!=0&&j+1<=n)
		{
			j++;
		}
		for(int k=i;k<=j;k++)
		{
			if(b==1)
			{
				js++;
				b=0;
			}
			a[k]--;
		}
		while(a[i]==0&&i+1<=n)
		{
			i++;
		}
	}
	cout<<js;
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/197481350)

---

## 作者：lihl (赞：0)

### 题意
有一个序列 $a$，每次可以选取任意一个区间 $[l_i,r_i]$ 使 $a_{l_i}\sim a_{r_i}$ 加 $1$，你需要使 $a_i=h_i$，请最小化完成要求的操作次数。
### 分析
区间加可以考虑到差分。

首先考虑差分 $d_1=a_1,d_i=a_i-a_{i-1}$。

不难发现，若 $a_i$ 对操作次数有贡献，需要保证 $d_i$ 是非负的。在区间操作中，这样 $d_i>0$ 的位置会对答案产生 $d_i$ 的贡献。

> 不难发现，在操作过程中，一个数字进行了 $a_i$ 次操作。于是不难发现，一个数字进行的操作次数，恰恰是 $\sum_{i=0}^{a_i}d_i$。
>
> 这说明，若存在一个偏移量 $\Delta > 0$，当 $a_{i+\Delta} > a_i$ 时，$a_i$ 的操作会对 $a_{i+\Delta}$ 同时产生贡献。由于 $a_i = h_i$，于是这个位置 $a_{i+\Delta}$ 需要多进行 $d_{i+\Delta}$ 次操作，才能满足到 $a_{i+\Delta} = d_{i+\Delta}$。
>
> 于是，为了保证完成目的，注意以上操作仅在 $d_i > 0$ 时才能产生贡献，所以在以上过程中，我们多操作了 $\sum_{i=0}^{n} d_i[d_i > 0]$ 次。

故差分即可。时间复杂度 $\mathcal{O}(n)$，可以通过。

---

## 作者：3_14 (赞：0)

##  [题目传送门](https://www.luogu.com.cn/problem/P1969)

 # 思路

题目要求是要找到一种方法来最小化搭建大厦所需的最少操作次数。

观察题目，我们可以发现，如果当前积木的高度大于前一块积木的高度，则需要额外的操作来增加积木的高度。

我们可以遍历每个积木，计算当前积木与前一块积木的高度差，这个差值就是需要的操作次数。这样我们就能得到总的最少操作次数。

 # 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
long long ans=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=2;i<=n;i++)if(a[i]>a[i-1])ans+=a[i]-a[i-1];
	cout<<ans+a[1]<<'\n';
	return 0;
}
```

 ## [AC记录](https://www.luogu.com.cn/record/196670593)

---

## 作者：JingchenBian (赞：0)

### 延正常做题思路思考正解
这道题大部分人（包括我）都会本能的想到贪心。这种想法是好的，但很可惜，这道题不能贪心。

这道题之所以不能贪心是因为它可以一个区间同时增高，这是我们便不能使用贪心。

但是我们可以自然的从区间增高想到差分。没错，这道题就是一个简单的差分。

### 解题思路
其实说是差分，根本没那么复杂。

我们只需要求出任意两个之间的高度差在计算答案就可以了。只要高度差为正，在答案上加一下就可以了。

```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define int long long
using namespace std;
const int N=2e5+5;
int a[N],dif[N];
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dif[i]=a[i]-a[i-1];
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(dif[i]>=0) ans+=dif[i];
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：ylzpl (赞：0)

要注意一个点，本题是可以将一个区间同时增加高度的，那么贪心就不可以。所以我们可以用差分。如果差分数组的第 $i$ 项小于零就可以增加高度。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+10;
int a[maxn],cha[maxn];
signed main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		cha[i]=a[i]-a[i-1];
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(cha[i]>0)
		{
			ans+=cha[i];
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

首先我们可以想到一个贪心，找到最高的积木，再把高度差相加即可，但是这是错误贪心，因为我们要注意：我们可以将一个**区间**的高度**同时**相加。所以我们可以用差分。如果差分数组的第 $i$ 项小于零就可以把高度不上去，这样为最优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+10;
int diff[maxn];
int a[maxn];
signed main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		diff[i]=a[i]-a[i-1];
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(diff[i]>0)
		{
			ans+=diff[i];
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：lylcpp (赞：0)

## 思路

因为每一层都会增加高度，所以我们记录当前这个积木和前面一个积木的高度差。因为如果后面的积木比当前高，那么操作数量就要增加，而这个增加的量，就是这个差值。

如果后面比前面低呢？那就不用增加了，因为在增加高度的过程中，我们已经保证了比它低的积木都已经达到目标高度了。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

int n, h[100005];
int c[100005];

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &h[i]);
		// 计算高度差 
		c[i] = h[i] - h[i-1];
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		// 后面一个比前面大，增加答案 
		if (c[i] > 0) ans += c[i];
	}
	printf("%d", ans);
	return 0;
}
``````

---

## 作者：FastIO_DP (赞：0)

## 题目理解

简略来说，需要用最少的操作次数，将某些高度不同的积木搭建到指定高度。

## 解题思路

考虑贪心，设 $h_i$ 表示第 $i$ 个积木的目标高度。

定义 $\Delta h_i = h_i - h_{i-1}$，表示第 $i$ 个积木相对前一个积木的高度增量。

当 $\Delta h_i > 0$ 时，那么就得要加上额外的操作次数。

所以，统计第一个积木需要的操作次数，遍历后续积木，累加比前一个积木高的差值就 ok 了。

## 代码实现

```cpp
#include <iostream>
using namespace std;


int h[100005];  // 存储积木高度


int main() {
    int n;
    cin >> n;

    // 读入目标高度
    for (int i = 0; i < n; ++i) {
        cin >> h[i];
    }

    int op = h[0];  // 第一个积木的高度就是初始操作次数

    // 遍历后续积木，累加高度差
    for (int i = 1; i < n; ++i) {
        if (h[i] > h[i - 1]) {
            op += h[i] - h[i - 1];
        }
    }

    cout << op << endl;
    return 0;
}
```

## 复杂度分析

- 时间复杂度：$O(n)$。
  
  - 遍历了一次数组 $h$。

- 空间复杂度：$O(n)$。
  
  - 使用了一个数组 $h$。
  
  - $n,op$ 变量（貌似是常数不用计入）。

---

## 作者：sea_bird (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1969)。

[双倍经验](https://www.luogu.com.cn/problem/P5019)。

挺喜欢这题的，一道经典的**贪心**题目，在这个题出现的五年后，提高组又出现了一道解法一样的题目，那道题我也写了题解，这次我写更详细，读起来更轻松一点。

# 题目分析

## 前置知识

做贪心的题目，首先要了解贪心是什么。

> 贪心指的是贪心算法（Greedy Algorithm），是一种在每一步选择中都采取当前状态下最优选择的算法设计策略，旨在通过局部最优解的累积来获得全局最优解。

判断是贪心算法，得找到一个思路，看当前状态下最优选择是否也是全局最优，有时局部最优解无法做到全局最优的话，得考虑动态规划。

# 做法

这题的贪心思路便是如果每个需要的楼比上一个高，那么新增填增高的量，就是当前高度与上一个高度的差，也就是 `cnt+=a[i]-a[i-1];` 所表达的意思。

## 思路

如何想到贪心的思路是很重要的一点。回归题目，抛去题目背景，就是对于一串数，每次操作选定一段区间的数减一，使其整串数最终都变为零。

为了让代价最小，就得让每次操作能让**尽量多的数**减小。但是影响全部数变为零的时间还是要看**最大的**那个数，其原因在于当别的比它小的数都已经变为零时，减去的数不足以让其变为零，因此其一定会有剩余，所以必然要**用额外的代价去减小**它，因此整个序列中的代价都取决于值更大的那个，既然迟早要消耗这个代价，那么在代码中无需考虑消耗代价的顺序，这便能推出贪心思路，每次操作看更大的那个数。

这些数当然不一定有序，但这并不会影响贪心思路，因为减去小的数时更大的那个数也会减去那个量，而由于是减去了一个比它小的数，所以大的数剩余部分如上文所说的，最后也要用代价减去，那么不如现在减掉，以此类推。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt=0,n;//计数 数列的个数
long long a[100005];//存数列中每个数
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];//存入数组
	}
	for(int i=2;i<=n;i++){//遍历数列
		if(a[i]>a[i-1]){//贪心思路
			cnt+=a[i]-a[i-1];//加上为消除的大小
		}
	}
	cout<<cnt+a[1]<<endl; //别忘了消除第一个数
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：0)

## 解题思路：
考虑贪心。  


容易发现，对于若该序列单调不增，所需天数为第一个数。  
所以我们可以利用这个思路，找到每组单调不增的序列，记录下第一个数的值。 


但这个方法并不是最优的，因为在一个序列的最小值归零前，后面的数可以一起操作。所以要把每一个两个单调不增序列的最大值与上一个的最小值作差。

可借助代码更好地理解。
## CODE：

```cpp
#include <iostream>
using namespace std;
int n, ans, d[100001];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> d[i];
	for (int i = 1; i <= n; i++)
		if (d[i] > d[i - 1])
			ans += d[i] - d[i - 1];
	cout << ans;
	return 0;
}
```

---

## 作者：Trilarflagz (赞：0)

### ~~来自蒟蒻的~~分析
直接贪心 QWQ

最开始ans=a[1]
 
若a[i]>a[i-1]  ans+=a[i]-a[i-1] 
 
否则不改变ans的值
 
 为什么呢？
 因为是要覆盖连续的一段，如果后面一块（i+1）的高度低于前面(i)的一个，那么覆盖前面的一个的时候它已经被一起覆盖了，否则还要覆盖多出的高度
 （这句话不仅仅代表覆盖当前（i+1）块的多出的高度，也一起覆盖i+2....n块小于等于i+1块高度的部分√具体见代码就很清晰了）
 
 
### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100050;
int n,a[N],ans;
int read(){
	int sum=0,f=1;
     char ch=getchar();
    while(ch>'9'||ch<'0')
    {
    	if(ch=='-')f=-1;
    	ch=getchar();
	}
	 while(ch>='0'&&ch<='9')
    {
    	sum=(sum<<3)+(sum<<1)+ch-'0';
    	ch=getchar();
	}
	return sum*f;
}
int main(){
	freopen("block.in","r",stdin);
	freopen("block.out","w",stdout);
	n=read();
	a[1]=read();
	ans=a[1];
	for(int i=2;i<=n;i++)
	{
		a[i]=read();
		if(a[i]>a[i-1])ans+=a[i]-a[i-1];
	}
	cout<<ans;
	return 0;
} 
```



---


# 打开所有的灯

## 题目背景

pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。


## 题目描述

这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。



例如
```
0  1  1
1  0  0
1  0  1
```

点一下最中间的灯【2,2】就变成了
```
0  0  1
0  1  1
1  1  1
```

再点一下左上角的灯【1,1】就变成了

```
1  1  1
1  1  1
1  1  1
```

达成目标。最少需要2步。

输出2即可。


## 说明/提示

这个题水不水，就看你怎么考虑了。。。。


## 样例 #1

### 输入

```
0 1 1
1 0 0
1 0 1```

### 输出

```
2```

# 题解

## 作者：Bartholomew (赞：28)

~~发现自己跑的好优越,只是$2^{n}$级的复杂度~~

**其实这道题目你会发现其实只需要关心是否会与这盏灯操作一次就够了!**

为什么? 其实如果是操作 2 次, 4 次,或者 6 次......其实都是对答案是一样的---**根本没有操作!** 而 1 ,  3 , 5 ,7 ....也就等同于操作一次!

如 5 号灯操作了5下(原来是 **开**的) 就是:关,开,关,开,关...

**结果还是关**

那么...我们对于这 9 个格子,只要二进制操作一番就好了,比如:


$\mathcal{100111101}$


\*就是对于1,4,5,6,7,9这些灯盏操作,那么我们只要记录是否能够完成就好了!\*

~~有疑问的欢迎提问,但尽量别举报...~~


```cpp
#include <bits/stdc++.h>
#define P pair<int,int>
#define sc scanf
#define pi printf
#define N 1500
#define M 300005
#define INF 0x3f3f3f3f
 using namespace std;
inline int getmax(int x,int y){return (x>y)?x:y;}
inline int getmin(int x,int y){return (x>y)?y:x;}
int n,ans=INF,tot,a[13],s[13],how[13];
inline void get(int n)
{
    int cnt=0;
    memset(s,0,sizeof s);
    while(n)
    {
        s[cnt++]=n%2;
        n/=2;
    }
}
int main(int argc, char const *argv[])
{
    for(int i=0;i<9;i++) scanf("%d",a+i);
    for(int used=0;used<(1<<9);used++) // 暴力枚举二进制
    {
        get(used); memset(how,0,sizeof how);
        for(int i=0;i<9;i++) //算i号的灯盏被操作了多少次!
            if(s[i]) //9 个格子的打暴力,其实可以变得简洁一些!
            {
                if(!i) how[0]++,how[1]++,how[3]++;
                else if(i==1) how[0]++,how[1]++,how[2]++,how[4]++;
                else if(i==2) how[1]++,how[2]++,how[5]++;
                else if(i==3) how[0]++,how[6]++,how[4]++,how[3]++;
                else if(i==4) how[4]++,how[1]++,how[3]++,how[5]++,how[7]++;
                else if(i==5) how[4]++,how[5]++,how[2]++,how[8]++;
                else if(i==6) how[6]++,how[3]++,how[7]++;
                else if(i==7) how[7]++,how[6]++,how[8]++,how[4]++;
                else if(i==8) how[5]++,how[7]++,how[8]++;
            }
        bool flag=true;
        for(int i=0;i<9;i++)  // 计算是否可行!
            if(how[i]%2==1 && a[i]) flag=false;
            else if(how[i]%2==0 && !a[i]) flag=false;
        if(flag)
        {
            tot=0;
            for(int i=0;i<9;i++) if(s[i]) tot++;
            ans=getmin(tot,ans);
        } 
    }
  //  printf("%d\n",ans);
}

```


---

## 作者：nothingness (赞：23)

第一眼看这个题目：哎呀，好难啊。。。

蒟蒻不才，于是只好写一个状压DP才过。

很简单，因为只有 $9$ 个 $0$ 或 $1$ ，所以只要用 $2^9=512$ 个数字来对应状态，根据异或的变换规律进行变换就行了。这种方法是 $O(512*9)$ 的，比绝大多数题解要快。

$~$


```
#include "bits/stdc++.h"
using namespace std;

int a,x,f[512];
int h,t,q[513];
int upd[10]={0,416,464,200,308,186,89,38,23,11};

int main()
{
	for(int i=8;i>=0;i--)
		scanf("%d",&a),x+=a*(1<<i);
	memset(f,-1,sizeof(f));
	f[x]=0;
	q[++t]=x;
	while(h<t)
	{
		x=q[++h];
		for(int i=1;i<=9;i++)
			if(f[x^upd[i]]==-1)
				q[++t]=x^upd[i],f[x^upd[i]]=f[x]+1;
	}
	printf("%d",f[511]);
	return 0;
}
```

---

## 作者：ljc1301 (赞：18)

这道题的时间复杂度可以优化到O(2^行·行·列)，方法是先枚举第一行哪些点需要改变，之后从第二行到第三行枚举每一个灯，如果这个灯上面那个灯是关闭状态的，那么这个灯需要点。最后如果发现最后一行的灯不是全亮的，那么这样确定的第一行是无解的。细节参见代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int nex[5][2]={{0,0},{1,0},{0,1},{-1,0},{0,-1}}; //自己、上下左右
int n=3,num=0x7fffffff,ma[3][3],temp[3][3],ans[3][3];
void reverse(int x,int y) //模拟点击一个灯
{
    int i;
    for(i=0;i<5;i++)
    {
        int tx=x+nex[i][0],ty=y+nex[i][1];
        if(tx<0 || tx>=n || ty<0 || ty>=n) continue;
        temp[tx][ty]^=1; //变化状态
    }
}
int pd() //第一行确定了后，判断需要点击多少灯
{
    int i,j,t=0;
    memcpy(temp,ma,sizeof(ma));
    for(i=0;i<n;i++)
        if(ans[0][i])
        {
            reverse(0,i);
            t++;
        }
    for(i=1;i<n;i++)
        for(j=0;j<n;j++)
        {
            ans[i][j]=(temp[i-1][j]==0); //确定当前灯需不需要点
            if(ans[i][j]) { reverse(i,j); t++; }
        }
    for(i=0;i<n;i++)
        if(temp[n-1][i]==0) //如果最后一行有灯不是亮的，那么返回一个比较大的值
            return 0x7fffffff;
    return t;
}
void dfs(int s) //枚举第一行的状态
{
    if(s>=n) //如果第一行枚举完了，那就看看能不能更新答案
    {
        num=min(num,pd());
        return;
    }
    for(ans[0][s]=0;ans[0][s]<2;ans[0][s]++) //枚举当前灯点或者不点
        dfs(s+1);
}
int main()
{
    int i,j;
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            scanf("%d",&ma[i][j]);
    dfs(0);
    printf("%d\n",num);
    return 0;
}
```

---

## 作者：Uranus (赞：16)

** _2018.6.10 华师一机房_ **


------------

原题：[P2040 打开所有的灯](https://www.luogu.org/problemnew/show/P2040)

### 题目背景
pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。

### 题目描述
这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。

例如

0 1 1

1 0 0

1 0 1

点一下最中间的灯【2,2】就变成了

0 0 1

0 1 1

1 1 1

再点一下左上角的灯【1,1】就变成了

1 1 1

1 1 1

1 1 1

达成目标。最少需要2步。

输出2即可。

### 输入输出格式

输入格式：

九个数字，3*3的格式输入，每两个数字中间只有一个空格，表示灯初始的开关状态。（0表示关，1表示开）

输出格式：

1个整数，表示最少打开所有灯所需要的步数。

### 输入输出样例

输入样例#1： 

```
0 1 1
1 0 0
1 0 1
```

输出样例#1： 

```
2
```

### 说明

这个题水不水，就看你怎么考虑了。。。。

------------

明显的搜索练手题，可以快速用 _DFS_ 完成，那么写写试试吧！

## DFS思路

#### 引理：

同一个开关不会被同时使用两次。

#### 证明：

这不废话嘛用了两次就回去了啊，这还用证？

证毕。

 _（不要在意这个证明）_ 

通过我们严谨的证明，我们知道，同一个开关不可能被使用两次，所以我们就可以放心大胆地直接深度优先搜索了。可以用G数组表示目前灯的开关状态，用use数组表示开关是否用过（用过为1，未用过为0），再加上数据范围较小，总的运算次数不会超过O(9^9)，可以实现。

| 实现时间 | 程序耗时 | 占用内存 | 最终得分 |
| :----------: | :----------: | :----------: | :----------: |
| 10min | 108ms | 2113KB | 100 |

代码：

```cpp
#include<iostream>
using namespace std;
int G[5][5],ans=10;///由题可知，答案不会超过10，所以ans的初始值为10
bool use[5][5];///判断是否用过
///小技巧：用a和b两个数组快速完成位置变换
int a[5]={+0,+0,+1,-1,0};
int b[5]={+1,-1,+0,-0,0};
bool check()///判断函数
{
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            if(!G[i][j])
                return false;
    return true;
}
void change(int x,int y)///变化函数
{
    for(int i=0;i<5;i++) G[x+a[i]][y+b[i]]=1-G[x+a[i]][y+b[i]];
}
void dfs(int step)///主体部分
{
    if(step>=ans) return ;///最(mei)优(shen)剪(me)枝(yong)
    if(check()) ans=min(ans,step);///找到答案
    else
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            if(!use[i][j])
            {
                use[i][j]=1;
                change(i,j);
                dfs(step+1);
                ///回溯
                use[i][j]=0;
                change(i,j);
            }
}
int main()
{
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            cin>>G[i][j];
    dfs(0);
    cout<<ans;
    return 0;
}

```

优点：写起来简单而且好想。

缺点：数据范围过大时比较鸡肋，容易 _TLE_ 。

------------

## BFS+进制运算思路

其实一开始我看到这道题的时候是没有想到一个开关只能按一次的，所以就想打 _BFS_ ，用方便判断是否到达目标的 _string_ 储存当前状态，用方便判重的 _STL_ 自带的 _set_ 判断是否重复出现，这样就可以规避 _DFS_ 思路的思考。本来代码打的好好的，突然脑子一糊涂，想着：“咦，只有九盏灯诶，可以用二进制储存啊，肯定也不会超过 _1024_ ，不是很方便吗”。然后 _5min_ 打完的代码花了 _20min_ ......

不过不得不说二进制运算和 _BFS_ 是真的快，根本美好什么时间就运算完了，那就让 _STL_ 见鬼去吧！

| 实现时间 | 程序耗时 | 占用内存 | 最终得分 |
| :----------: | :----------: | :----------: | :----------: |
| 23min | 0ms | 2062KB | 100 |

代码：

```cpp
#include<iostream>
using namespace std;
int tmp,h,t,step[100000];///step数组储存步数（也就是使用的开关数）
int bfs[100000];///储存当前的灯光状态
bool use[300];///判重数组，事实证明不是不到1024，连256都到不了
int change(int x,int pos)///神仙一般的变换函数！引以为傲但是超级难想，因为这个本机测试的时候RE了好多次
{
    int re=x;
    re^=1<<(8-pos);
    if(pos%3!=0) re^=1<<(9-pos); ///开关不在第一列
    if(pos%3!=2) re^=1<<(7-pos); ///开关不在最后一列
    if(pos/3!=0) re^=1<<(11-pos);///开关不在第一排
    if(pos/3!=2) re^=1<<(5-pos); ///开关不在最后一排
    return re;
}
int main()
{
    for(int i=0;i<9;i++)
    {
        cin>>tmp;
        bfs[0]=bfs[0]*2+tmp;///转换为二进制储存
    }
    use[bfs[0]]=true;
    while(h<=t)///标准BFS
    {
        for(int i=0;i<9;i++)
        {
            bfs[++t]=change(bfs[h],i);
            step[t]=step[h]+1;
            if(bfs[t]==(1<<9)-1)///到达最终状态
            {
                cout<<step[t];
                return 0;
            }
            if(use[bfs[t]]) t--;
            else use[bfs[t]]=true;
        }
        h++;
    }
    return 0;
}

```

优点：跑得超级快，时空甩 _DFS_ 一大截。

缺点：累【这是真的】。

## 一定要提一下的一个小东西！

在我第一次用 _DFS_ 思路写的时候其实是用 _string_ 储存的，变换函数也和二进制思路比较相似，即：

```cpp
string act(string a,int pos)
{
    string re=a;
    re[pos]=(a[pos]='0'?'1':'0');
    if(pos%3!=0) re[pos-1]=a[pos-1]='0'?'1':'0';
    if(pos%3!=2) re[pos+1]=a[pos+1]='0'?'1':'0';
    if(pos/3!=0) re[pos-3]=a[pos-3]='0'?'1':'0';
    if(pos/3!=2) re[pos+3]=a[pos+3]='0'?'1':'0';
    return re;
}

```

甚至还用了我从来没用过的三目运算符。

可是结果是60分，3WA。虽然错的不是这里，但我还是要说一下：用三目运算符一定要打括号，你又不是OYYZ，你不知道运算符优先级啊喂。

正确写法：

```cpp
string act(string a,int pos)
{
    string re=a;
    re[pos]=(a[pos]='0'?'1':'0');
    if(pos%3!=0) re[pos-1]=(a[pos-1]='0')?'1':'0';
    if(pos%3!=2) re[pos+1]=(a[pos+1]='0')?'1':'0';
    if(pos/3!=0) re[pos-3]=(a[pos-3]='0')?'1':'0';
    if(pos/3!=2) re[pos+3]=(a[pos+3]='0')?'1':'0';
    return re;
}

```

 _2018.6.11 update1_ 
 
 好吧其实就错在这里，三目运算符中要打==判断而不是=。。。
 
 真·正确写法：
 
```cpp
string act(string a,int pos)
{
    string re=a;
    re[pos]=(a[pos]=='0'?'1':'0');
    if(pos%3!=0) re[pos-1]=(a[pos-1]=='0')?'1':'0';
    if(pos%3!=2) re[pos+1]=(a[pos+1]=='0')?'1':'0';
    if(pos/3!=0) re[pos-3]=(a[pos-3]=='0')?'1':'0';
    if(pos/3!=2) re[pos+3]=(a[pos+3]=='0')?'1':'0';
    return re;
}

```

 或者写成：
 
```cpp
string act(string a,int pos)
{
    string re=a;
    re[pos]=(a[pos]=='0')+'0';
    if(pos%3!=0) re[pos-1]=(a[pos-1]=='0')+'0';
    if(pos%3!=2) re[pos+1]=(a[pos+1]=='0')+'0';
    if(pos/3!=0) re[pos-3]=(a[pos-3]=='0')+'0';
    if(pos/3!=2) re[pos+3]=(a[pos+3]=='0')+'0';
    return re;
}

```

------------

今天的题目总结就到这里吧，还有个 _diggersun_ 老师提到的循环算法，还没有写，但是听说超级快，有时间再来补一下吧！

---

## 作者：「　」 (赞：16)

# 标准的广搜（虽然深搜也能做）
先给大家看一下我的结构体，不然后面的程序看不懂：
```
struct light
{
    int a[5][5],n;
};
```
a是当前的灯的打开情况，n是当前步数。

而广搜呢，最重要的是队列。
```cpp
light v[100000];
int l=0,r=1;
```
l是当前搜到的队列，r是总情况，v就是队列。其实l和r就是头和尾。

接下来，就是最关键的：
```cpp
light tmp
while(1)
    {
        tmp=v[l];
        ++tmp.n;
        for(int i=1;i<=3;++i)
        for(int j=1;j<=3;++j)
        {
            on(i,j);
            if(cmp()==true)
            {
                printf("%d",tmp.n);
                return 0;
            }
            v[r]=tmp;
            ++r;
            on(i,j);
        }
        ++l;
    }
```
因为我们肯定会将所有的灯打开（蜜汁自信），所以大胆while(1)。

tmp就是当前搜到的情况，cmp是判断是否成功，而on就是将周围的以及自己变化的函数：
```cpp
bool cmp()
{
    for(int i=1;i<=3;++i)
    for(int j=1;j<=3;++j)
    if(tmp.a[i][j]==0)
    return false;
    return true;
}
void change(int i,int j)
{
    if(tmp.a[i][j]==1)
    tmp.a[i][j]=0;
    else
    tmp.a[i][j]=1;
}
void on(int i,int j)
{
    change(i-1,j);
    change(i,j-1);
    change(i,j);
    change(i+1,j);
    change(i,j+1);
}
```
表示本蒟蒻比较懒，所以就用函数了。

其实程序到这里，拼凑起来就可以ac了。

但是，我们可以稍稍优化一下。就是将每一次的搜索情况储存一下。但是如果将v从0到r的所有情况查看一遍，需要3重循环，所以我们就想到了下面的方法:

将9个点赋予他们一个权值，就像下面一下：

1 2 4

8 16 32

64 128 256

每当这个位置的数为1时，就加上他的权值。大量实验表明，两个不一样的序列不会出现相同的权值。

所以就可以这样：
```cpp
int hei(light a)
{
    int n=0;
    for(int i=1;i<=3;++i)
    for(int j=1;j<=3;++j)
    if(a.a[i][j]==1)
    n+=pow(2,i-1+(j-1)*3);
    return n;
}
bool used(int n)
{
    if(u[n]==false)
    {
        u[n]=true;
        return false;
    }
    else
    return true;
}
```
表示本人的函数名比较无聊，但是hei是计算权值的函数，而used就是检查并记录的函数。

如此优化，也是可以ac的。追求完美的算法总是感觉不错的，对吗！

---

## 作者：Wyxrg (赞：9)

这题可以用一种~~奇怪的~~深搜来实现，首先可以知道每个点只能搜一遍，比如说样例：

------------
0 1 1

1 0 0

1 0 1

------------
按一下1,1后：

1 0 1

0 0 0

1 0 1

------------
若再按一次1,1就回去了。

------------
若按下1,2：

0 1 0

0 1 0

1 0 1

------------
再按一次1,1的话，发现：

1 0 0

1 1 0

1 0 1

------------
结果~~貌似~~和只按一次2没有区别（其实就是连续按两次1再按一次2）。

为了使搜索不重复，所以一个点不要搜两次，那么我们可以用两个 last 记录上一次的位置。

------------
所以输入和输出是这样滴：
```cpp
int main()
{
	for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) cin>>hxt[i][j];
	dfs(0,1,1);//从1,1尝试按，按了0次
	cout<<ans<<endl;
	return 0;
}
```
------------
定义变量：
```cpp
#include<bits/stdc++.h>
using namespace std;

int hxt[5][5],ans=82420520;//地图（习惯这个变量），初值赋值为很大值
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,-1,1};//简化代码，上下左右自己五个方向
```
------------
判断代码：
```cpp
bool check()
{
	int js=0;
	for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) if(hxt[i][j]==1) js++;//统计1的个数
	return js==9?true:false;//若为九，返回true，否则false
}
```
------------
最重要的（dfs）：
```cpp
void dfs(int dep,int last1,int last2)
{
	if(dep>ans) return;//如果比最优解还大，那就不用搜了
	if(check()==true) ans=min(dep,ans);//成功即可
	else
	{
		for(int i=last1;i<=3;i++)//从上次的下个点开始
		{
			for(int j=(i==last1?last2:1);j<=3;j++)//如果i停留在上一行，j从上一次开始，否则j从1开始
			{
				for(int k=0;k<5;k++) hxt[i+dx[k]][j+dy[k]]=(hxt[i+dx[k]][j+dy[k]]==0?1:0);//五个方向若0为1，若1为0
				dfs(dep+1,i,j+1);//下一步，下个点
				for(int k=0;k<5;k++) hxt[i+dx[k]][j+dy[k]]=(hxt[i+dx[k]][j+dy[k]]==0?1:0);//回溯
			}
		}
	}
}
```
------------
至此，这题就做出来了。

---

## 作者：南判 (赞：7)

咳咳，翻了一下众大佬的题解我觉得我这个蒟蒻终于有机会来一篇题解了。

首先考虑最容易的暴力枚举，九盏灯每盏灯都有开与关两种选择，这样枚举的话显然就要2的9次方种可能，~~目测好像还行~~，显然这种方法的效率是远远不够的，**于是重点来了！！！**

其实对这九盏灯，我们只需要枚举其中某一行或者某一列的开关情况就能得解，
由于我的目标是要所有灯全部开启，那么在枚举第一行灯的情况时，其实后面对应的灯的情况已然确定了。比如说：

对于样例中：	

0 1 1

1 0 0

1 0 1

第一次是全部不动，那么对应的情况是：

0 1 1

1 0 0

1 0 1

接着要对第二行的灯进行操作，显然第二行在进行选择时我是一定要关掉第一行未亮的灯，那么我对应的开关操作也就唯一确定了，即第二行第一栈按，其它不按，那么就又有：

1 1 1

0 1 0

1 0 1

同样第三行的决策也被确定，即要打开按下第一列和第三列的灯使第二行未亮的灯亮起，随之有：

1 1 1

1 1 1

0 0 0

如何判断是否达到要求只要观察最后一盏灯是不是全为1即可。

这样做就可以把枚举量从2的9次方减少到2的三次方。

于是代码它就来了（采取二进制来提高时空）

```cpp
#include<iostream>
using namespace std;
#include<cstring>
#include<algorithm>
char oriLights[3];	//最初灯矩阵，一个比特表示一盏灯
char lights[3];		//不停变化的灯矩阵
char result[3];		//结果开关矩阵
char switchs;		//某一行的开关状态
int ans = 0x3f3f3f;
int getBit(char c, int i)		//取c的第i位
{
	return (c >> i) & 1;
}
void setBit(char& c, int i, int v)		//设置c的第i位为v
{
	if (v)
		c |= (1 << i);
	else
		c &= ~(1 << i);
}
void flip(char& c, int i)		//将c的第i位取反
{
	c ^= (1 << i);
}
int main()
{
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			int s;
			cin >> s;
			setBit(oriLights[i], j, s);
		}
	}
	for (int i = 0; i < 8; i++)
	{
		switchs = i;
		memcpy(lights, oriLights, sizeof(oriLights));
		for (int j = 0; j < 3; j++)
		{
			result[j] = switchs;
			for (int k = 0; k < 3; k++)
			{
				if (getBit(switchs, k))
				{
					if (k > 0)	//修改左灯
						flip(lights[j], k - 1);
					flip(lights[j], k);		//修改开关位置的灯
					if (k < 2)	//修改右灯
						flip(lights[j], k + 1);
				}
			}
			if (j < 2)		//修改下一行的灯
				lights[j + 1] ^= switchs;
			switchs = lights[j] ^ 7;	//下一次的操作即当前每盏灯对应的数取反
		}
		if (lights[2] == 7)		//判断最后一行是不是全亮
		{
			int t = 0;
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
  					//统计方案中有多少个1即按了多少次开关
					if (getBit(result[i], j))
						t++;
				}
			}
			ans = min(t, ans);
		}
	}
	cout << ans << endl;
	return 0;
}
```
~~第一篇题解但愿能过~~，溜了溜了

---

## 作者：2016jzy (赞：6)

貌似大家发的题解都是用深搜或广搜，
那我就发个用异或方程组的吧。。。
初学者看不懂没关系，
等到学到时就会了。
```cpp
#include<iostream>
using namespace std;
bool a[101][101],b[101][101],ans[101];  //友情提示：一定要用bool！！！
int fx[5]={0,-1,0,1,0};
int fy[5]={0,0,1,0,-1};   //方向数组
int main()
{
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cin>>a[i][j];
			a[i][j]=!a[i][j];
		}
	}       //输入
	int t=1;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			for(int k=1;k<=4;k++)
			{
				int x=i+fx[k];
				int y=j+fy[k];
				if(x>=1&&x<=3&&y>=1&&y<=3)
				{
					b[t][x*3-3+y]=a[x][y];
				}
			}
			b[t][i*3-3+j]=a[i][j];
			b[t][10]=a[i][j];
			t++;
		}
	}   //将这九盏灯的情况转化为异或方程组
	for(int k=1;k<=8;k++)
	{
		int p=k;
		for(int i=k;i<=9;i++)
		{
			if(b[i][k]>b[p][k])p=i;
		}
		for(int i=1;i<=10;i++)
		{
			swap(b[k][i],b[p][i]);
		}
		for(int i=k+1;i<=9;i++)
		{
			if(!b[i][k])continue;  //要注意分母为0的情况
			for(int j=k;j<=10;j++)
			{
				b[i][j]=b[k][j]^b[i][j];
			}
		}
	}     //解异或方程组
	for(int i=9;i>=1;i--)
	{
		if(!b[i][i])continue;  //要注意分母为0的情况
		int s=0;
		for(int j=i+1;j<=9;j++)
		{
			if(b[i][j])s+=ans[j];
		}
		ans[i]=b[i][10]-s;
	}    //求解
	int sum=0;
	for(int i=1;i<=9;i++)
	{
		if(ans[i])sum++;
	}        //解中有几个为1答案就为几
	cout<<sum<<endl;   //输出
	return 0;
}
```

---

## 作者：小穹 (赞：5)

# 本人用的深搜来解决此题的
### 在其他深搜题解中加了些小优化，在原程序中有解释。
```
对于搜索的优化来说
每一个点至多点一次就够了
不然会出现重复现象导致TLE
理由如下：
如果依次按下 1、2、1 号开关的话
其效果与只按下 2 号开关相同,因此无效，剪去。
由此可得：
对于每一次搜索
只要在上一次按下开关的下面
所有的开关进行搜索就行了
```
每次搜索时改变该开关和四周开关的状态，回溯时再修改回来就可以了。
代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int hxt[5][5],ans=1000000,last,k;//last用来记录上一次搜索的点 
int dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};//每次按开关要修改的点，和走迷宫的4个路线差不多，只要加上自己本身就行了。 
void dfs(int t,int last)
{	
	k=0; for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) if(hxt[i][j]) k++; else break;//用来判断是否全是开着的状态 
	if(k==9) { ans=t;return; } 
	if(t+1>=ans) return; //小优化 不用深搜打擂台，提前省去 
	int y=(last-1)/3+1,l=(last-1)%3+1; //计算本次第一次要在哪一个开关上动手脚^-^ 
	for(int i=y;i<=3;i++) 
	{
		for(int j=l;j<=3;j++)
		{
			for(int f=0;f<=4;f++) hxt[i+dx[f]][j+dy[f]]=1-hxt[i+dx[f]][j+dy[f]];//修改节点 
			dfs(t+1,(i-1)*3+j+1);//进行下一次深搜，修改下一次搜索初始点 
			for(int f=0;f<=4;f++) hxt[i+dx[f]][j+dy[f]]=1-hxt[i+dx[f]][j+dy[f]];//把之前修改的改回来。 
		}	
		l=1;//在搜索完初始点所在行时，要恢复下一次搜索范围 切记！！！ 
	}
}
int main()
{
	for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) cin>>hxt[i][j];//输入 
	dfs(0,1); cout<<ans<<endl;
	return 0;
}
```


---

## 作者：yyy2015c01 (赞：5)

数据范围小。强行dfs

```cpp

#include <iostream>  
#include <cstdio>  
#include <cstdlib>  
#include <algorithm>  
#include <cmath>  
#include <climits>  
using namespace std;  
int map[4][4];  
int dx[5]= {0,0,-1,1,0},dy[5]= {-1,1,0,0,0};  
int ans=INT_MAX;  
bool check()  
{  
    for(int i=1; i<=3; i++)  
        for(int j=1; j<=3; j++)  
            if(!map[i][j])return false;  
    return true;  
}  
  
void fuck(int x,int y,int k)  
{  
    if(k>=ans)return;  
    if(check())  
    {  
        ans=k;  
        return;  
    }  
    if(x>3)return;  
    int xx,yy;  
    if (y>=3)  
    {  
        xx=x+1;  
        yy=1;  
    }  
    else  
    {  
        xx=x;  
        yy=y+1;  
    }  
    fuck(xx,yy,k);  
    for(int i=0; i<5; i++)  
        map[x+dx[i]][y+dy[i]]=1-map[x+dx[i]][y+dy[i]];  
    fuck(xx,yy,k+1);  
    for(int i=0; i<5; i++)  
        map[x+dx[i]][y+dy[i]]=1-map[x+dx[i]][y+dy[i]];  
}  
int main()  
{  
    for(int i=1; i<=3; i++)  
        for(int j=1; j<=3; j++)  
            scanf("%d",&map[i][j]);  
    fuck(1,1,0);  
    printf("%d\n",ans);  
    return 0;  
}  

```

---

## 作者：Crab_Dave (赞：4)

# 来自某蒟蒻的处女题解
楼下那位DL的代码无法应付新增的数据，本蒟蒻在这个代码的核心思想上做了一下优化，望支持~

```
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;

int a[5][5],ans=9,v[5][5];
//a数组存储灯的状态,ans最大为9（为什么？请自己想...）
//v数组是重点！优化！

bool check()//判断灯的开关情况
{
	for(register int i=1;i<=3;i++)
		for(register int j=1;j<=3;j++)
			if(!a[i][j]) return false;
	return true;
}

void dfs(int s)
{
	if(s>ans) return;//剪枝*1（如果越界，则返回）
	if(check()){ans=min(ans,s);return;}//判断是否全开
	for(register int i=1;i<=3;i++)
		for(register int j=1;j<=3;j++)//枚举每一个点的开关情况
		{
			if(v[i][j]) continue;//重点！！因为灯开了n次相当于开了n%2次，所以每盏灯最多开一次！！！
			v[i][j]=1;//已经按过了，之后就不用再按
			a[i][j]=!a[i][j];
			a[i-1][j]=!a[i-1][j];
			a[i+1][j]=!a[i+1][j];
			a[i][j-1]=!a[i][j-1];
			a[i][j+1]=!a[i][j+1];		//改变自己及周围四个方向
        		//以上是开关一次
			dfs(s+1);		//以下是回溯
			v[i][j]=0;
			a[i][j]=!a[i][j];
			a[i-1][j]=!a[i-1][j];
			a[i+1][j]=!a[i+1][j];
			a[i][j-1]=!a[i][j-1];
			a[i][j+1]=!a[i][j+1];		//消除变化
		}
}

int main()
{
	scanf("%d%d%d%d%d%d%d%d%d",&a[1][1],&a[1][2],&a[1][3],&a[2][1],&a[2][2],&a[2][3],&a[3][1],&a[3][2],&a[3][3]);//无脑输入...
	dfs(0);//愉快开搜~
	printf("%d\n",ans);//AC愉快~
	return 0;
}
```
呃呃，核心思想还是很简单的，只是需要一点小优化才能过第6个点。。。
还请各位DL多加指点~谢谢啦~
祝大家在OI之路上越走越远~

---

## 作者：liuzitong (赞：3)

这个题写其他题解的dalao们已经解释了

一个灯最多开一次

这个题一共就9个灯嘛,对吧

递归好想不好写(对于我这种蒟蒻)

所以我写了一个所有题解中最暴力的

# 直接枚举9个灯的开关状态就可以了

## #我们把原先的数组开半天在初始化不如弄一个已经全开了的数组开半天看看能不能返回原先的状态就好了更方便一点

```cpp
//打开所有的灯 九层循环法
#include<bits/stdc++.h>

using namespace std;

inline int read() {//快读
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void write(int x) //快写{
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

int b[11][11],c[11][11],a[11][11],tot,zx = 999;
int xx[] = {0,1,-1,0,0},yy[] = {0,0,0,1,-1},d[10];

int pd(int x) {//判断在哪一行
	if(x <= 3)
		return 1;
	if(x >= 7)
		return 3;
	return 2;
}

void kd(int x,int y) {//开它周围的灯
	for(int i = 0; i <= 4; ++i) {
		int x2 = x + xx[i] , y2 = y + yy[i];
		c[x2][y2] == 1 ? c[x2][y2] = 0 : c[x2][y2] = 1;
	}
}

bool jc() {//判断是否全打开了
	for(int i = 1; i <= 3; ++i)
		for(int j = 1; j <= 3; ++j)
			if(a[i][j] != c[i][j])
				return 0;
	return 1;
}

int main(int argc, char const *argv[]) {
	for(int i = 1; i <= 3; ++i)//读入并初始化c
		for(int j = 1; j <= 3; ++j) {
			a[i][j] = read();
			c[i][j] = 1;
		}
	int he = 0;
	for(d[1] = 0; d[1] <= 1; ++d[1])
		for(d[2] = 0; d[2] <= 1; ++d[2])
			for(d[3] = 0; d[3] <= 1; ++d[3])
				for(d[4] = 0; d[4] <= 1; ++d[4])
					for(d[5] = 0; d[5] <= 1; ++d[5])
						for(d[6] = 0; d[6] <= 1; ++d[6])
							for(d[6] = 0; d[6] <= 1; ++d[6])
								for(d[7] = 0; d[7] <= 1; ++d[7])
									for(d[8] = 0; d[8] <= 1; ++d[8])
										for(d[9] = 0; d[9] <= 1; ++d[9]) {
											for(int i = 1; i <= 9; ++i) {
												if(d[i] == 1) {//如果开着
													kd(pd(i),i % 3 == 0 ? 3 : i % 3);开灯
													he ++;//计数器
													if(he > zx)//如果不是正解直接退出
														break;
												}
											}
											if(jc() && he < zx) {//如果全都开了并且比最小值小
												zx = he;
											}
											he = 0;
											for(int i = 1; i <= 3; ++i)//清空数组
												for(int j = 1; j <= 3; ++j)
													c[i][j] = 1;
										}
	write(zx);
	cout<<endl;
	return 0;
}
```
友情赠送(递归版本)
```cpp
//打开所有的灯 递归法
#include<bits/stdc++.h>

using namespace std;

inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void write(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

int b[11][11],c[11][11],a[11][11],tot,zx = 999;
int xx[] = {0,1,-1,0,0},yy[] = {0,0,0,1,-1},d[10];

void kd(int x,int y) {
	for(int i = 0; i <= 4; ++i) {
		int x2 = x + xx[i] , y2 = y + yy[i];
		c[x2][y2] == 1 ? c[x2][y2] = 0 : c[x2][y2] = 1;
	}
}

bool jc() {
	for(int i = 1; i <= 3; ++i)
		for(int j = 1; j <= 3; ++j)
			if(a[i][j] != c[i][j])
				return 0;
	return 1;
}

void dg(int x,int y,int tot) {
	if(x == 4) {
		if(jc() == 1)
			zx = min(zx,tot);
		return ;
	}
	kd(x,y);
	y == 3 ? dg(x + 1,1,tot + 1) : dg(x,y + 1,tot + 1);
	kd(x,y);
	y == 3 ? dg(x + 1,1,tot) : dg(x,y + 1,tot);
}

int main(int argc, char const *argv[]) {
	for(int i = 1; i <= 3; ++i)
		for(int j = 1; j <= 3; ++j) {
			a[i][j] = read();
			c[i][j] = 1;
		}
	int he = 0;
    dg(1,1,0);
    write(zx);
	cout<<endl;
	return 0;
}
```


---

## 作者：木木！ (赞：3)

qwq蒟蒻来这交个此题必有解的证明。

因为只有9盏灯，所以可以考虑状压加速。每一个局面都可以唯一对应一个512以内的整数。

而开关灯就可以看做是状态对应的整数异或某个数qwq。

经过简单的计算和画图，可以发现操作所对应的二进制数分别为`
0640,0720,0310,0464,0272,0131,0046,0027,0013`（划重点，0打头是八进制数），顺序分别为左上->右下。

既然是异或，我们就可以联想到线性基。简单来说，线性基能构造一组数，使得那组数相互异或的值域与原数相互异或的值域相同。（简单来说就是原数能异或出来的数，线性基里的数也能异或出来，反之亦然）。线性基就像原子一样，从原数列中提取出来，又能组成万物。

构造线性基的方法很简单：枚举每一个数，从最高位开始，如果某一位是1，且线性基的对应位没有一个为1的话，就插入线性基；否则就异或那个对应位。

如果构造过程中数字被异或没了，就说明该数可以被线性基里的东西异或出来，否则说明该数应该在线性基里面。

如果最后的线性基对于每一位都有一个数将该位作为其最高位的话，可以构造出任意范围内的整数（证明简单，就略了）。

构造线性基的代码如下，结合这个应该更容易理解：

```cpp
void insert(int x)
{
	for(int i=8; i>=0; --i)
	{
		if(x&(1<<i))
		{
			if(!xi[i])
			{
				xi[i] = x;
			}
			else
			{
				x ^= xi[i];
			}
		}
	}
}
```

（几乎所有大括号均可被删系列）

然后就是验证了。运行代码之后，线性基中的数如下：

`416 200 112 44 23 10 5 2 1`

二进制数形式是`110 100 000`、`11 001 000`、`1 110 000`、`101 100`、`10 111`、`1 010`、`101`、`10`、`1`

至此，所有在范围内的数皆可通过异或的方式从线性基里构造出来，即任意局面间皆可通过异或的方式相互转化。

（大概可以用数学的方式证明，但是我们是OIer不是MOer啊qwq）

[线性基的模板题（可以从题解进一步学习）](https://www.luogu.org/problem/P3812)

附AC代码（思路是宽搜，状态数不大于`512`，跑得飞快）

```cpp
#include <queue>
#include <cstdio>
using namespace std;

int trans[] = {0640,0720,0310,0464,0272,0131,0046,0027,0013};

int walked[1005]; //两倍数组保平安

int bfs(int x)
{
	queue<int> q;
	q.push(x);
	walked[x] = 1;
	while(!q.empty())
	{
		register int th = q.front();
		q.pop();
		
		if(th == 511)
		{
			return walked[th];
		}
		
		for(register int i=0; i<9; ++i)
		{
			th ^= trans[i];
			if(!walked[th])
			{
				walked[th] = walked[th^trans[i]]+1; //异或和异或互为逆运算
				q.push(th);
			}
			th ^= trans[i];
		}
	}
}

int main()
{
	int beg = 0;
	for(register int i=1; i<=3; ++i)
	{
		for(register int j=1; j<=3; ++j)
		{
			int tmp;
			scanf("%d",&tmp);
			beg<<=1;
			beg += tmp;
		}
	}
	
	printf("%d",bfs(beg)-1);
}
```

---

## 作者：Soledad_S (赞：2)

显而易见，对于这道题有两个定理：每一个点只能打开一次（不然就多余了），而且顺序不影响结果。

对于第一行，只有8种打开情况，分别为000--111,(数位上为1表示第一行的这个位置需要打开)，枚举十进制的0--7并相应变换第一行，就能得到第一行处理后的所有状态。

对于其他点，如果a[i][j]==0则无脑打开a[i-1][j],能保证已打开的点不被破坏。这样可以打开除最后一行的外的所有灯，判断最后一行即可啦（由前文的两个定理可证明其正确性）

~~我就不写递归~~

```cpp
#include<iostream>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[10][10],ans,tmp[10][10],minn=0x3f3f3f3f;
inline void change(int x,int y){//模拟变换，0^1=1,1^1=0 
	tmp[x][y]^=1;
	tmp[x+1][y]^=1;
	tmp[x-1][y]^=1;
	tmp[x][y+1]^=1;
	tmp[x][y-1]^=1;
}
int main() {
	char ch;
	for(int i=1;i<=3;i++)
	  for(int j=1;j<=3;j++){
	  	cin>>ch;
	  	a[i][j]=ch-'0';
	  }
	for(int i=0;i<=7;i++){//0--7枚举所有情况 
		ans=0;
		for(int j=1;j<=3;j++)
		  for(int k=1;k<=3;k++)tmp[j][k]=a[j][k];//不能用原数组更改 
		int t=1,x=i;//同理，不能用i更改 
		while(x){
			if(x&1){//取出x二进制的每一位，如果是1，表示这个地方需打开  
				change(1,t);
				ans++;//计数 
			}
			t++;
			x>>=1;
		}
		for(int j=2;j<=3;j++)
		  for(int k=1;k<=3;k++)
		    if(!tmp[j-1][k]){//如果当前点为0，打开它下方的点 
		    	change(j,k); 
		    	ans++;//计数 
			}
		int bj=1;
		for(int j=1;j<=3;j++)//判断最后一行 
		  if(!tmp[3][j]){
		  	bj=0;
		  	break;
		  }
		if(bj)minn=min(minn,ans);
	}
	cout<<minn<<endl;
    return 0; 
}
```
时间复杂度 $O(2^nn^2)$ 

---

## 作者：陆依凡 (赞：2)

	
    我们可以对于题目进行分析，对于同一个位置最多只用按一次，按2、4、6次相当于没按，而按3、5、7次相当于按一次，但一定不是最优解。
    
	另外我们需要明确一点，按的顺序与最后的状态无关，所以，我们从上到下从左到右依次考虑是否要按。 
	
	事实上，我们只用枚举第一行哪些地方按，哪些地方不按即可，若第一行已经确定，则下面每一行就确定了，举例说明：假设初始状态如图一所示，我们对于第一行进行枚举，若第一行某一次枚举情况如图二，那么要保证所有数为1,第二行第二列一定要按，因为如果不按，就没有办法使第一行第二列的0变成1了（第一行的状态已经枚举确定）
	
	最后只要判断最后一行是否全部为1即可，注意比较最优解
	0 1 0 
	1 1 1 
	0 1 0 
	图一  
	1 0 1 
	1 0 1 
	0 1 0 
	图二  
    
    代码如下：

	#include<bits/stdc++.h>

	using namespace std;

	int a[5][5],A[5][5],tans,ans;

	void xg(int x,int y) //修改a[x][y]的位置 

	{

    	if (a[x][y]==0) a[x][y]=1;
    
     	   else a[x][y]=0;
        
    	if (a[x-1][y]==0) a[x-1][y]=1;
    
    	    else a[x-1][y]=0;
        
    	if (a[x+1][y]==0) a[x+1][y]=1;
    
        	else a[x+1][y]=0;
        
    	if (a[x][y-1]==0) a[x][y-1]=1;
    
        	else a[x][y-1]=0;
        
    	if (a[x][y+1]==0) a[x][y+1]=1;
    
        	else a[x][y+1]=0;
        
	}

	int main()

	{

    	for (int i=1; i<=3; i++)
    
        	for (int j=1; j<=3; j++)
        
            	cin>>A[i][j];
            
    	ans=INT_MAX;
    
    	for (int i=1; i<=2; i++)
    
        	for (int j=1; j<=2; j++)
        
            	for (int k=1; k<=2; k++) //枚举第一行的操作状态，1表示按，0表示不按，i是第一个，j是第二个，k是第三个 
            	{
                	tans=0;
                	for (int ii=1; ii<=3; ii++)
       					for (int jj=1; jj<=3; jj++)
            				a[ii][jj]=A[ii][jj];
                	if (i==1) {
                    	xg(1,1); tans++;
                	}
                	if (j==1) {
                    	xg(1,2); tans++;
                	}
                	if (k==1) {
                    	xg(1,3); tans++;
                	}
                	for (int ii=2; ii<=3; ii++)
                    	for (int jj=1; jj<=3; jj++)
                    	{
                        	if (a[ii-1][jj]==0) {
                            	xg(ii,jj); tans++;
                        	}
                    	}
                	bool ok=true;
                	for (int jj=1; jj<=3; jj++)
                	{
                    	if (a[3][jj]==0) {
                        	ok=false; break;
                    	}
                	}
                	if (ok&&tans<ans) ans=tans; 
                
            	}
    	cout<<ans;
    	return 0;
	}

---

## 作者：yin_sy (赞：2)

这道题目广搜可以做，不过我用的是暴力枚举，枚举每一处要不要按。




```cpp
var
  b,c,d,e,f,g,h,i,j,v,min:longint;
  us,a:array [1..9] of longint;
begin
  min:=10;
  readln(a[1],a[2],a[3]);
  readln(a[4],a[5],a[6]);
  readln(a[7],a[8],a[9]);
  us:=a;
  for b:=1 to 2 do
    for c:=1 to 2 do
      for d:=1 to 2 do
        for e:=1 to 2 do
          for f:=1 to 2 do
            for g:=1 to 2 do
              for h:=1 to 2 do
                for i:=1 to 2 do
                  for j:=1 to 2 do
                  begin
                    a:=us;
                    if b=1 then begin a[1]:=abs(a[1]-1); a[2]:=abs(a[2]-1); a[4]:=abs(a[4]-1); end;
                    if c=1 then begin a[2]:=abs(a[2]-1); a[1]:=abs(a[1]-1); a[3]:=abs(a[3]-1); a[5]:=abs(a[5]-1); end;
                    if d=1 then begin a[3]:=abs(a[3]-1); a[2]:=abs(a[2]-1); a[6]:=abs(a[6]-1); end;
                    if e=1 then begin a[4]:=abs(a[4]-1); a[1]:=abs(a[1]-1); a[5]:=abs(a[5]-1); a[7]:=abs(a[7]-1); end;
                    if f=1 then begin a[5]:=abs(a[5]-1); a[2]:=abs(a[2]-1); a[4]:=abs(a[4]-1); a[6]:=abs(a[6]-1); a[8]:=abs(a[8]-1); end;
                    if g=1 then begin a[6]:=abs(a[6]-1); a[3]:=abs(a[3]-1); a[5]:=abs(a[5]-1); a[9]:=abs(a[9]-1); end;
                    if h=1 then begin a[7]:=abs(a[7]-1); a[4]:=abs(a[4]-1); a[8]:=abs(a[8]-1); end;
                    if i=1 then begin a[8]:=abs(a[8]-1); a[5]:=abs(a[5]-1); a[7]:=abs(a[7]-1); a[9]:=abs(a[9]-1); end;
                    if j=1 then begin a[9]:=abs(a[9]-1); a[6]:=abs(a[6]-1); a[8]:=abs(a[8]-1); end;
                    if (a[1]=1) and (a[2]=1) and (a[3]=1) and (a[4]=1) and (a[5]=1) and (a[6]=1) and (a[7]=1) and (a[8]=1) and (a[9]=1) then
                    begin
                      v:=0;
                      if b=1 then inc(v);
                      if c=1 then inc(v);
                      if d=1 then inc(v);
                      if e=1 then inc(v);
                      if f=1 then inc(v);
                      if g=1 then inc(v);
                      if h=1 then inc(v);
                      if i=1 then inc(v);
                      if j=1 then inc(v);
                      if v<min then min:=v;
                    end;
                  end;
  writeln(min);
end.

```

---

## 作者：微雨燕双飞 (赞：2)

水题一道，算法：深搜dfs，不多解释。（本题应该还有枚举的方法，本人没去试过，估计有点烦）

这题简直就是数据结构书上的模板题，生搬硬套就行了，标准的深搜+回溯。

下面上100分代码：

```cpp
#include<iostream>
#define maxn 3
using namespace std;
int minans=100;
int map[10][10],vis[10][10]={0}; //判断是否已经搜过了
bool check()
{
  for(int i=1; i<=maxn; i++)
    for(int j=1; j<=maxn; j++)
    {
      if(map[i][j]==0) return false; //如果一开始就已经全打开了，就什么都不做
    }
  return true;
}
void init()
{
  for(int i=1; i<=maxn; i++)
    for(int j=1; j<=maxn; j++) cin>>map[i][j]; //读入数据，判断是否要处理
  if(check()) minans=0;
}
void dfs(int f) //深搜子过程
{
  if(f>9) return;
  for(int i=1; i<=maxn; i++) //遍历整个矩阵
    for(int j=1; j<=maxn; j++)
    {
      if(vis[i][j]==0) //若未搜到过就深搜
      {
        vis[i][j]=1; //做标记
        map[i][j]=1-map[i][j]; //这里耍了点小聪明，我没用大佬们的布尔数组，直接用1减一下，也很快 
        map[i-1][j]=1-map[i-1][j];
        map[i+1][j]=1-map[i+1][j];
        map[i][j-1]=1-map[i][j-1];
        map[i][j+1]=1-map[i][j+1];
        if(check()) minans=min(minans,f); //如果整个矩阵填完，就更新答案
        dfs(f+1); //深搜
        vis[i][j]=0; //一下为回溯部分，不多解释了
        map[i][j]=1-map[i][j];
        map[i-1][j]=1-map[i-1][j];
        map[i+1][j]=1-map[i+1][j];
        map[i][j-1]=1-map[i][j-1];
        map[i][j+1]=1-map[i][j+1];
      }
    }
}
void print()
{
  cout<<minans<<endl; //输出答案
}
int main()
{
  init();
  dfs(1);
  print();
  return 0;
} //完美结束（很好的一道深搜练手题）
```

---

## 作者：Creeper_LKF (赞：2)

我知道这是道水题，所以自然来水一发题解。

显然题目的数据范围是很小的，所以直接上O(2^9)的暴力即可。

然后我们认识到一个事实：答案不会超过9.因为如果答案超过了9自然说明有点被重复改变状态，如果改变奇数次，等价于改变一次，如果改变偶数次，等价于没有改变。所以答案不会超过9.

然后下面用了一堆位运算来减小常数。

```cpp
#include<cstdio>
using namespace std;
const short pow[10]={0,1,2,4,8,16,32,64,128,256};//枚举二进制串00...010...00
short l[10],s,ans;
inline bool ch(short tar){
    return s&pow[tar];//返回bool型判断state状态中i是否被改变
}
inline bool check(short tar){//检查一个点最后的情况（被改变的情况异或原来的情况）
    switch(tar){
        case 1:return ch(1)^ch(2)^ch(4)^l[1];
        case 2:return ch(1)^ch(2)^ch(3)^ch(5)^l[2];
        case 3:return ch(2)^ch(3)^ch(6)^l[3];
        case 4:return ch(1)^ch(4)^ch(5)^ch(7)^l[4];
        case 5:return ch(2)^ch(4)^ch(6)^ch(8)^ch(5)^l[5];
        case 6:return ch(3)^ch(5)^ch(6)^ch(9)^l[6];
        case 7:return ch(4)^ch(7)^ch(8)^l[7];
        case 8:return ch(5)^ch(7)^ch(8)^ch(9)^l[8];
        case 9:return ch(6)^ch(8)^ch(9)^l[9];
    }
}
void dfs(short depth,short state){//dfs枚举情况（for循环也行）
    if(depth==9){
        s=state;
        if(check(1)&&check(2)&&check(3)&&check(4)&&check(5)&&check(6)&&check(7)&&check(8)&&check(9)) ans=state;
        return ;
    }
    dfs(depth+1,state);
    dfs(depth+1,state|(1<<depth));
}
int main(){
    for(short i=1;i<=9;i++) scanf("%hd",&l[i]);
    dfs(0,0);
    short sum=0;
    for(short i=1,j=1;i<=9;i++,j<<=1) sum+=(bool)(ans&j);//统计方案
    printf("%hd",sum);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)


**这道题我用了一种很高（辣）端（鸡）的状态压缩，尚未有题解提起，然而我因为BFS时队列忘了pop()而调了两个小时（十年OI一场空，忘加pop()见祖宗！）。**

有兴趣的同学可以了解一下。

这道题问最小步数，加之地图规模较小且分支较多，我们可以用**ID_DFS即迭代加深**解决这个问题。

所以我选择BFS+神奇状态压缩（滑稽）。

---

### 状态设计与整合编码
通过简单的观察，可以发现这个地图每个位置只有两种状态，可以转化为一个二进制数，那么整张地图就转化为一个**九位二进制数**。地图状态设计完毕。

正如很多题解提到的，每一个开关最多被按一次。那么我们可以使用一个二进制数表示某一个开关是否被使用。一共九个开关，那么一个**九位二进制数**就可以表示每个开关是否被使用。选择状态设计完毕。

根据题意，我们必须知道对于某个状态，到达它的最少步数是多少。根据上面的分析，最大的最少步数是9（此时每个开关都被按了一次，是最坏情况）。所以一个**四位二进制数**（最大表示8+4+2+1=15）足以表示任意步数。

以上三个状态构成我们进行搜索必须知道的完整状态。要表达一个完整状态至少需要9+9+4=22个二进制位，而一个int有32位，也就是说，**一个int变量完全可以表达一个完整状态**。

这很神奇，三组状态就这样被压缩到一个int型变量内。

这是这部分的代码。

```cpp
int encode(void)
{
	int code = 0;
	for (int i = 1; i <= 3; i++)	//压缩地图
	{
		for (int j = 1; j <= 3; j++)
		{
			code <<= 1;
			if (map[i][j])
			{
				code |= 1;
			}
		}
	}
	for (int i = 1; i <= 9; i++)	//压缩选择
	{
		code <<= 1;
		if (choice[i])
		{
			code |= 1;
		}
	}
	int temp = step;
	for (int i = 3; i >= 0; i--)	//压缩当前步数
	{
		code <<= 1;
		code |= temp & 1;
		temp >>= 1;
	}
	return code;
}
```
---

### 状态解码
另一个重头戏。

这里可能会有点思维难度（其实很小）。我们只需要逆着我们编码的顺序，把状态还原就好了。详情见代码。有一个细节，最后解码当前步数的时候必须麻烦一点，因为最后不能再左移了。

```cpp
void decode(int code)
{
	step = 0;	//解码的顺序和编码是反着的，先解步数
	for (int i = 0; i < 3; i++)
	{
		if (code & 1)
		{
			step |= 1;
		}
		code >>= 1;
		step <<= 1;
	}
	step |= code & 1;	//细节！step只需要左移三次。
	code >>= 1;
	for (int i = 9; i >= 1; i--)	//所有的顺序都是反着的
	{
		choice[i] = code & 1;
		code >>= 1;
	}
	for (int i = 3; i >= 1; i--)
	{
		for (int j = 3; j >= 1; j--)
		{
			map[i][j] = code & 1;
			code >>= 1;
		}
	}
}
```

---

### 搜索！


这个BFS也是满满的细节，其中有一些类似**回溯**的操作，见代码。
总体这个BFS就是中规中矩的BFS，没啥特别值得说的地方。

```cpp
void bfs(void)
{
	queue<int> que;
	que.push(encode());
	while (!que.empty())
	{
		static int cur = 0;
		cur = que.front();	//当前状态
		que.pop();
		decode(cur);
		if (check())
		{
			cout << step;
			return;
		}
		step++;
		for (int i = 1; i <= 9; i++)
		{
			if (!choice[i])
			{
				choice[i] = true;
				touch(i);
				que.push(encode());
				touch(i);	//回溯，很神奇
				choice[i] = false;	//BFS也有回溯！
			}
		}
	}
}
```


---

### 高清无码的源代码


```cpp
#include <iostream>
#include <queue>

using namespace std;

bool map[5][5], choice[10];
int step, next_x[]{ 0, -1, 0, 1, 0 }, next_y[]{ -1, 0, 1, 0, 0 };

int encode(void);
void decode(int code);
void touch(int pos);
bool check(void);
void bfs(void);
void PrintMap(void);

int main(void)
{
	for (int i = 1; i <= 3; i++)
	{
		for (int j = 1; j <= 3; j++)
		{
			cin >> map[i][j];
		}
	}
	bfs();
	system("pause");
	return 0;
}

int encode(void)
{
	int code = 0;
	for (int i = 1; i <= 3; i++)
	{
		for (int j = 1; j <= 3; j++)
		{
			code <<= 1;
			if (map[i][j])
			{
				code |= 1;
			}
		}
	}
	for (int i = 1; i <= 9; i++)
	{
		code <<= 1;
		if (choice[i])
		{
			code |= 1;
		}
	}
	int temp = step;
	for (int i = 3; i >= 0; i--)
	{
		code <<= 1;
		code |= temp & 1;
		temp >>= 1;
	}
	return code;
}

void decode(int code)
{
	step = 0;
	for (int i = 0; i < 3; i++)
	{
		if (code & 1)
		{
			step |= 1;
		}
		code >>= 1;
		step <<= 1;
	}
	step |= code & 1;
	code >>= 1;
	for (int i = 9; i >= 1; i--)
	{
		choice[i] = code & 1;
		code >>= 1;
	}
	for (int i = 3; i >= 1; i--)
	{
		for (int j = 3; j >= 1; j--)
		{
			map[i][j] = code & 1;
			code >>= 1;
		}
	}
}

void touch(int pos)
{
	int x = (pos - 1) / 3 + 1;
	int y = (pos - 1) % 3 + 1;
	for (int i = 0, tx, ty; i < 5; i++)
	{
		tx = x + next_x[i], ty = y + next_y[i];
		map[tx][ty] = !map[tx][ty];
	}
}

bool check(void)
{
	for (int i = 1; i <= 3; i++)
	{
		for (int j = 1; j <= 3; j++)
		{
			if (!map[i][j])
			{
				return false;
			}
		}
	}
	return true;
}

void bfs(void)
{
	queue<int> que;
	que.push(encode());
	while (!que.empty())
	{
		static int cur = 0;
		cur = que.front();
		que.pop();
		decode(cur);
		if (check())
		{
			cout << step;
			return;
		}
		step++;
		for (int i = 1; i <= 9; i++)
		{
			if (!choice[i])
			{
				choice[i] = true;
				touch(i);
				que.push(encode());
				touch(i);
				choice[i] = false;
			}
		}
	}
}

void PrintMap(void)
{
	for (int i = 1; i <= 3; i++)
	{
		for (int j = 1; j <= 3; j++)
		{
			cout << map[i][j] << ' ';
		}
		cout << endl;
	}
	cout << endl;
}
```









---

## 作者：kevin_y (赞：1)

## 这一题的数据并不大，用暴搜可以水过。

#### 不过要确认搜索的边界条件是什么，因为本题变化只有0变1或者1变0，所以每个位置最多只能点一次。


#### 举个栗子： 点（1,1）（1,2）（1,1）和单点（1,2）是一样的。你们可以手推一下
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int ans=1<<30;
bool b[4][4],a[5][5];//b保证每个位置只点一次
inline int read(){//快读
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
inline int change(int x,int y){//a的数组大小开到[5][5]，这里就不用if判断
	a[x][y]^=1;//按位异或
	a[x-1][y]^=1;
	a[x][y-1]^=1;
	a[x+1][y]^=1;
	a[x][y+1]^=1;
	return 0;
}
inline bool check(){//检查是否全部点亮
	int t=0;
	for(int i=1;i<=3;i++)for(int j=1;j<=3;j++)if(a[i][j])t++;
	if(t==9)return 1;
	return 0;
}
int f(int sum){
	for(int i=1;i<=3;i++)for(int j=1;j<=3;j++)if(!b[i][j]){
		change(i,j);b[i][j]=1;
		if(check())ans=min(ans,sum+1);//最小次数
		f(sum+1);
		change(i,j);b[i][j]=0;//回溯
	}
	return 0;
}
int main(){
	for(int i=1;i<=3;i++)for(int j=1;j<=3;j++)a[i][j]=read();
	if(check()){cout<<0<<endl;return 0;}//如果全都点亮，就输出0
	for(int i=1;i<=3;i++)for(int j=1;j<=3;j++){
		change(i,j);b[i][j]=1;
		if(check()){cout<<1<<endl;return 0;}
		f(1);
		change(i,j);b[i][j]=0;
	}
	cout<<ans<<endl;
	return 0;
} 
```


---

## 作者：Ckkkk (赞：1)

# 标准的BFS
这道题真的看似超级水，但是还是有点真正的技术含量的。不过想通了，就是水题了
首先我们要想一下，它是九个地方都可以试的，因此不用两个方向数组。
然后涉及到开灯和关灯的，直接用布尔值，就不用判断0还是1了。
```pascal
var i,j,n,w,t:longint;
    b:array[1..150000] of longint;
    h:array[1..150000,0..4,0..4] of boolean;
function pd(x:longint):boolean;//判断是否全开了
var i,j:longint;
begin
  for i:=1 to 3 do
    for j:=1 to 3 do
      if h[x,i,j]=false then exit(false);
  exit(true);
end;
begin
  for i:=1 to 3 do//读入
    for j:=1 to 3 do
      begin
        read(n);
        if n=1 then h[1,i,j]:=true;//是开着就是true
      end;
  t:=1;w:=1;
  while t<=w do//标准的BFS
    begin
      for i:=1 to 3 do
        for j:=1 to 3 do
          begin
            inc(w);
            h[w]:=h[t];//将要关的数组定义一下
            h[w,i,j]:=not h[w,i,j]; //开关灯
            h[w,i-1,j]:=not h[w,i-1,j];
            h[w,i+1,j]:=not h[w,i+1,j];
            h[w,i,j-1]:=not h[w,i,j-1];
            h[w,i,j+1]:=not h[w,i,j+1];
            b[w]:=b[t]+1;//加一步
            if pd(w) then//全开了就结束啦
              begin
                write(b[w]);
                halt;
              end;
          end;
      inc(t);
    end;
end.
```

```



```



---

## 作者：嚯呀嚯呀 (赞：1)

首先这个点灯有两个规则

**1.一个点最多只要点1次，因为点多了就回去重复了，浪费步数
**

**2.如果第一行确定了怎么点，那么下面几行的点灯的方案是唯一的，**因为对于第i行确定了下来，如果是灭的，那么只能去点第i+1行同一个位置的灯，

**就这样我们尽量保证前面满足全亮，再全点完后看一下最后一行有没有全亮就好了**

总而言之，枚举第一行的点灯情况，然后去按照第2个规则去点，最后判断，找一个次数最少的

Code(Pascal):
```
var
  num,ans,a1:longint;
  x,t,i,j,m,n,k,p:longint;
  map,s:array[0..4,0..4]of longint;
begin
  for i:=1 to 3 do
    begin
      for j:=1 to 3 do
        read(map[i,j]);
      readln;
    end;
  ans:=maxlongint;
  for x:=0 to 7 do
    begin
      t:=0; a1:=x; num:=0;
      s:=map;
      while a1<>0 do
        begin
          inc(t);
          if a1 and 1=1 then
            begin
              s[1,t-1]:=(s[1,t-1]+1) mod 2;
              s[1,t]:=(s[1,t]+1) mod 2;
              s[2,t]:=(s[2,t]+1) mod 2;
              s[1,t+1]:=(s[1,t+1]+1) mod 2;
              inc(num);
            end;
          a1:=a1 shr 1;
        end;
      for i:=1 to 3 do
        if s[1,i]=0 then
          begin
            s[2,i-1]:=(s[2,i-1]+1) mod 2;
            s[2,i]:=(s[2,i]+1) mod 2;
            s[3,i]:=(s[3,i]+1) mod 2;
            s[2,i+1]:=(s[2,i+1]+1) mod 2;
            inc(num);
          end;
      for i:=1 to 3 do
        if s[2,i]=0 then
          begin
            s[3,i-1]:=(s[3,i-1]+1) mod 2;
            s[3,i]:=(s[3,i]+1) mod 2;
            s[3,i+1]:=(s[3,i+1]+1) mod 2;
            inc(num);
          end;
      if (s[3,1]=1)and(s[3,2]=1)and(s[3,3]=1) then
        if ans>num then
          ans:=num;
    end;
  writeln(ans);
end.

```

---

## 作者：pomelo_nene (赞：0)

至少是我觉得这是一道好题

---

这道题细细看了一下，有很多种做法

首先我们只有3*3的灯，可以发现这是一道搜索或者是状压dp

因为我tcl，所以只好写搜索

我们首先考虑深搜，我们对于每一个灯，只有翻和不翻两种方法，搜索一遍即可

然后广搜也是可以做的，我们储存这个灯可以用朴素存法，也可以用二进制优化，然后这道题GG掉了

回去考虑，我们对于每一个灯的操作只有两种：开->关，关->开

我们可以发现，对任意一个灯操作两次相当于没操作过，三次相当于操作1次，我们发现不需要对任意一个灯进行重复操作，同时我们也证明了开头dfs的正确

我们还需要一个东西，也就是证明灯的开关顺序与结果无关——显然，我们不必要在意过程，对于这道题，我们只需要在意结果，而一个灯一定会受到固定的几次操作（在确定操作个数和位置的情况下），这个灯的状况是肯定能够确定了

与此同时，我们发现这道题的搜索树层数有限（也就是9，因为最坏情况下所有灯只操作一次），我们发现我们可以用迭代加深/启发式搜索去做，如果加一个二进制判重也可以跑的很快，如果不加迭代加深似乎是过不掉的

最后证明一下时间复杂度为什么是$\Theta (2^9=512)$

我们对于每个灯只可能翻一次，~~根据搜索树长的样子，我们可以发现复杂度正确~~ 则我们枚举要操作多少个灯，也就是：

假设我们要翻x个灯，在9个灯中选x个，也就是$C^x_9$

我们可以发现时间复杂度即为$C^1_9+C^2_9+...+C^9_9=2^n$（可以自己参照一下杨辉三角）

所以说这道题其实搜索都不要，直接穷举就行了

---

## 作者：灵光一闪 (赞：0)

代码冗长，但思路明确 ~~（明确吗？？？~~

本题就是数据太小了，估计开大点能hack掉几乎所有人（有些dalao请无视

再说一句闲话：看到这题我就想到了Minecraft的红石灯上套拉杆，``3*3``，每个红石灯上都有，MC粉丝请自行脑补画面


~~请无视我上面的闲话~~

好的，开始讲题，首先这题的数据范围很小，然后……

我就构造了这么个东西：  
``000000000``  
过一轮……  
``000000001``

相当于2进制，穷举所有可能（0不拉，1拉），然后，你们懂的……

code:
```
//puts("The_man_who_AKed_IOI_and_Hanging_National_Training_Team's_name_is_chen_zhe_dalao");
/*本文提示：码风奇丑，请做好心理准备*/
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<string>
using namespace std;
int a[4][4];
int b[4][4];
const int dx[]={0,0,-1,1,0};
const int dy[]={-1,1,0,0,0};
bool checker(){//判断是不是全是1，比较简单，不讲，有需要手动私信作者我
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(b[i][j]==0){
                return false;
            }
        }
    }
    return true;
}
void work(int x,int y){//也不是太难，关键是坑点在：本身也要处理，虽然我没掉进去，但是我觉得还是提醒一下
    for(int c=0;c<5;c++/*万岁*/){
        if(x+dx[c]<0||x+dx[c]>=3||y+dy[c]<0||y+dy[c]>=3){//不满足要求
            continue;
        }
        else{
            b[x+dx[c]][y+dy[c]]=!b[x+dx[c]][y+dy[c]];//取倒过来的值，可以省事
        }
    }
    return;
}
int dg(int x,int y,string s){
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(s[i*3+j]=='1'){
                work(i,j);//手动处理一下
            }
        }
    }
    if(checker()){//如果过审核了（当然我也希望我的题解也能过）
        int ans=0;//准备记答案
        for(int i=0;i<s.size();i++){//循环9次
            if(s[i]=='1'){//碰到个1就记一次答案
                ans++;
            }
        }
        return ans;//返回
    }
    else{
        return 2e9;//如果不符合就return个很大的值（这里一定要贼大，，但切记切记不要爆int，不然就是个负数了……）
    }
}
int main(){
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            cin>>a[i][j];//先输入
        }
    }
    string s="000000000";//最基本的字符串
    int ans=2e9;//最大值
    while(1){
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                b[i][j]=a[i][j];//备份一下
            }
        }
        int sum=dg(0,0,s);//开始枚举
        s[s.size()-1]++;//末尾++，准备枚举下一个
        for(int i=s.size()-1;i>=0;i--){
            if(s[i]=='2'){//倒着推向前，使这个字符串没有2的存在
                s[i]='0';
                s[i-1]++;
            }
        }
        ans=min(ans,sum);//取最小值
        if(s=="111111111"){//穷举完成！
            cout<<ans<<endl;//输出环节
            return 0;
        }
    }
}
```
The End.

---

## 作者：SIGSEGV (赞：0)

此题甚水。首先要明确：同一盏灯操作一次就够了！！！因为灯的状态与开关灯的次序无关！

接着就好办了：用一个int记录下一个二进制数，代表对灯光的操作，如样例，最优操作是动第一与第五盏灯，操作码为000010001（2） 即17. 然后这个九位二进制数到范围在0～1023之间，慢慢去凑状态吧～

最后贴代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[5][5],b[5][5],dx[] = {0,1,0,-1},dy[] = {1,0,-1,0},ans = INT_MAX;
void chk(int num) //这是个检查的函数
{
	int cnt = 0;
	for (int i = 0;i < 3;i++)
		for (int j = 0;j < 3;j++)
		{
			if (num % 2) //此灯要戳一下
			{
				++cnt;
				b[i][j] = !b[i][j];
				for (int k = 0;k < 4;k++)
				{
					int nx = i + dx[k],ny = j + dy[k];
					if (nx >= 0 && ny >= 0 && nx < 3 && ny < 3)
						b[nx][ny] = !b[nx][ny];
				}
			}
			num /= 2;//向下一位进军
		}
	for (int i = 0;i < 3;i++)
		for (int j = 0;j < 3;j++) 
			if (b[i][j] == 0) return;
	ans = min(ans,cnt);
}
int main()
{
	for (int i = 0;i < 3;i++)
		for (int j = 0;j < 3;j++)
			scanf("%d",&a[i][j]);
	int mx = pow(2,10);
	for (int i = 0;i < mx;i++)//凑状态码
	{
		for (int j = 0;j < 3;j++)
			for (int k = 0;k < 3;k++) b[j][k] = a[j][k];//不想要用memcpy，反正时间差不多
		chk(i);
	}
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：q2368126021 (赞：0)

    
```cpp
#include<iostream>
using namespace std;
int a[10][10];
int total=200;
int finish()**判断其是否成功**
{
    int i,j;
    for(i=1;i<=3;i++)
     for(j=1;j<=3;j++)
      if(!a[i][j])
       return 0;
    return 1;
}
int dfs(int best)
{
    int i,j;
    if(finish())**开头判断**
     {
     total=min(total,best);
     return 0;
     }
    if(best>=total)**剪枝，如果中途大于total则必然不是最优解**
     return 0;
    for(i=1;i<=3;i++)
     for(j=1;j<=3;j++)**开始枚举**
      {
        a[i-1][j]=!a[i-1][j];        
        a[i][j-1]=!a[i][j-1];
        a[i+1][j]=!a[i+1][j];
        a[i][j+1]=!a[i][j+1];
        a[i][j]=!a[i][j];
```
**以上都是状态改变**
```cpp
        dfs(best+1);**步数加1**
        a[i-1][j]=!a[i-1][j];        
        a[i][j-1]=!a[i][j-1];
        a[i+1][j]=!a[i+1][j];
        a[i][j+1]=!a[i][j+1];
        a[i][j]=!a[i][j];
```
**回溯，变回之前的状态**

```cpp
      }
}
int main()
{
    int i,j;
    for(i=1;i<=3;i++) 
     for(j=1;j<=3;j++)
      cin>>a[i][j];
    dfs(0); 
    cout<<total; 
}
```

---

## 作者：EMT、游龙 (赞：0)

粗略地看了看，貌似没有用深搜的pas党，那就由我来发一个吧

```cpp
var i,j,max:longint;
a:array[0..10,0..10] of longint;
f:array[0..10] of boolean;
function pd:boolean;
var i,j:longint;
b:array[0..10,0..10] of longint;
begin
b:=a;
for i:=1 to 9 do
  if f[i] then
    begin
    case i of
    1:begin b[1,1]:=1-b[1,1];b[1,2]:=1-b[1,2];b[2,1]:=1-b[2,1];end;
    2:begin b[1,1]:=1-b[1,1];b[1,2]:=1-b[1,2];b[1,3]:=1-b[1,3];b[2,2]:=1-b[2,2];end;
    3:begin b[1,2]:=1-b[1,2];b[1,3]:=1-b[1,3];b[2,3]:=1-b[2,3];end;
    4:begin b[2,1]:=1-b[2,1];b[2,2]:=1-b[2,2];b[1,1]:=1-b[1,1];end;
    5:begin b[2,2]:=1-b[2,2];b[2,3]:=1-b[2,3];b[2,1]:=1-b[2,1];b[1,2]:=1-b[1,2];b[3,2]:=1-b[3,2];end;
    6:begin b[2,3]:=1-b[2,3];b[1,3]:=1-b[1,3];b[3,3]:=1-b[3,3];b[2,2]:=1-b[2,2];end;
    7:begin b[3,1]:=1-b[3,1];b[3,2]:=1-b[3,2];b[2,1]:=1-b[2,1];end;
    8:begin b[3,2]:=1-b[3,2];b[3,1]:=1-b[3,1];b[3,3]:=1-b[3,3];b[2,3]:=1-b[2,3];end;
    9:begin b[3,3]:=1-b[3,3];b[3,2]:=1-b[3,2];b[2,3]:=1-b[2,3];end;
    end;//这整段就是来开灯，灭灯，此处可以用一个for解决（b[i-1,j]=1-b[i-1,j],b[i+1,j]=1-b[i+1,j]......）但是我编到一半时才发现这个，qwq
    end;
for i:=1 to 3 do
  for j:=1 to 3 do
    if b[i,j]<>1 then exit(false);
exit(true);//判断是否都开灯了
end;
procedure sc(t:longint);
var i:longint;
begin
if t>=max then exit;//找最小的
if pd then
  begin
  max:=t;
  exit;
  end;
for i:=1 to 9 do
  if f[i]=false then//一盏灯最多只需要改变一次就够了，偶数次就回来了
    begin
    f[i]:=true;
    sc(t+1);
    f[i]:=false;
    end;
end;
begin
max:=maxlongint;
for i:=1 to 3 do
  begin
  for j:=1 to 3 do
    read(a[i,j]);
  readln;
  end;
sc(0);
writeln(max);
end.
```

---

## 作者：ww3113306 (赞：0)

突然发现以前的题解对于某一些数据可能会被卡，，所以，这是改进后的题解。。。被卡的数据：1 1 1 0 0 1 1 1 1

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[5][5],a[5]={-1,0,0,1},b[5]={0,1,-1,0},k[5][5]/*,zx[5][5]*/;int ans=99999,now;
bool may()
{
    int i,j;
    for(i=1;i<=3;i++)
        for(j=1;j<=3;j++)
            if(!s[i][j]) return false;
    return true;
}
void dfs(int x,int y,int now)
{
    int i,j;int z=false;
    if(may())
    {
        ans=min(ans,now);
    /*    for(i=1;i<=3;i++)
        {
            printf("\n");
            for(j=1;j<=3;j++)
                printf("%d ",zx[i][j]);
        }*/
        return;
    }
    if(y>3)y=1,x++;
    if(x>3) 
    {
        for(i=1;i<=3;i++)
            for(j=1;j<=3;j++)
                if(s[i][j]==0){z=true;break;}
        return ;
    }
    if(s[x][y]==0) s[x][y]=1;
    else s[x][y]=0;
    for(i=0;i<4;i++)
        if(s[x+a[i]][y+b[i]]==0) s[x+a[i]][y+b[i]]=1;
        else s[x+a[i]][y+b[i]]=0;
    //zx[x][y]=1;    
    dfs(x,y+1,now+1);
    //zx[x][y]=0;
    if(s[x][y]==0) s[x][y]=1;
        else s[x][y]=0;
    for(i=0;i<4;i++)
        if(s[x+a[i]][y+b[i]]==0) s[x+a[i]][y+b[i]]=1;
            else s[x+a[i]][y+b[i]]=0;
    dfs(x,y+1,now);        
} 
int main()
{
    int i,j;
    for(i=1;i<=3;i++)
        for(j=1;j<=3;j++)
            scanf("%d",&s[i][j]);
    dfs(1,1,0);
    printf("%d",ans);
    return 0;        
}
```

---

## 作者：ZigZagKmp (赞：0)

估计还没有几个人像我这样做的……

----

### 这一题比较典型，可以说是板子题，不过实际上还是有一些细节要注意

### 题意简述
给你一个9位二进制数，通过特定的变换法则，将其改变为$111111111$的最少步数。

### 算法分析
显然，我们就是用二进制来存储每一个状态，将法则变为二进制数，然后通过异或运算进行操作。

举个例子：
```
111       001
111 --->  011
111       111
```
相当于异或$(110100000)_2,$ 即$(416)_{10}$。

同理，我们可以写出其他操作的二进制数。

$110100000,111010000,011001000,100110100,010111010,001011001,000100110,000010111,000001011$

即

$416,464,200,308,186,89,38,23,11$
### 代码实现
下面就打裸的宽搜模板了。
```cpp
inline void in()
{
	int a;
	for(register int i=1;i<=9;i++)
	{
		cin>>a;
		if(a)
			st^=(1<<(9-i));//至于这边的9-i，我是为了调试的时候方便，你也可以改成i-1，不过有坑。
	}
	q.push(st);
	q.push(0);
	ed=(1<<9)-1;
	vis[st]=1;
}
inline void Do()
{
	int a,s,na,ns;
	while(!q.empty())
	{
		a=q.front();q.pop();
		s=q.front();q.pop();
		ns=s+1;na=a;
		for(register int i=0;i<9;i++)
		{
			na=a^d[i];
			if(!vis[na])
			{
				q.push(na);
				q.push(ns);
				if(na==ed)
				{
					printf("%d\n",ns);
					return;
				}
			}
		}
	}
}
```

---

## 作者：Mychael (赞：0)

水题一道，最简单最暴力的搜索，vis数组都不开

用now【9】记录每一次的状态，然后9个点枚举一遍，BFS

用上了一些技巧，比如用取余实现二维化一维，用typedef简化代码



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=105;
typedef int state[9];
int read()
{
    int out=0;
    char c=getchar();
    while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out;
}
```
class node
{
public:


```cpp
        state now;
        int step,last;
        node(state a,int b,int c): step(b),last(c) {for(int i=0;i<9;i++) now[i]=a[i];}
        node() {}
};
int main()
{
    queue<node> q;
    state s;
    for(int i=0;i<9;i++) s[i]=read();
    q.push(node(s,0,-1));
    node u,nu;
    int nx,ny,nxx,nyy,X[4]={0,0,1,-1},Y[4]={1,-1,0,0};
    while(!q.empty())
    {
        u=q.front();
        q.pop();
        /*for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
                cout<<u.now[i*3+j]<<' ';
            cout<<endl;
        }*/
        if(u.now[0]&&u.now[1]&&u.now[2]&&u.now[3]&&u.now[4]&&u.now[5]&&u.now[6]&&u.now[7]&&u.now[8])
        {
            cout<<u.step<<endl;
            return 0;
        }
        for(int i=0;i<9;i++)
        {
            if(i==u.last) continue;
            nx=i%3;
            ny=i/3;
            for(int i=0;i<9;i++) nu.now[i]=u.now[i];
            nu.now[nx+ny*3]=nu.now[nx+ny*3]^1;
            for(int j=0;j<4;j++)
            {
                nxx=nx+X[j];
                nyy=ny+Y[j];
                if(nxx<0||nyy<0||nxx>2||nyy>2) continue;
                nu.now[nxx+nyy*3]=nu.now[nxx+nyy*3]^1;
            }
            nu.step=u.step+1;
            nu.last=nx+ny*3;
            q.push(nu);
        }
    }
    cout<<"No solution"<<endl;
    return 0;
}

```

---

## 作者：chauchat (赞：0)

总的来说想复杂了 不过交个宽搜的题解

状态总共就是511个，怎么做都不超时，判重用一个最大为511的二进制数保存

最后的状态就是511（111111111）


其他就是bfs的模板了，枚举每个点尝试修改。






    



```cpp
#include<iostream>
using namespace std;
#include<cstring>
int place[4][4],vis[1500];
struct node{
    int now[4][4],step;
}queue[10000];
int head,tail;
int gox[5]={0,0,1,-1,0},goy[5]={1,-1,0,0,0};
void change(int head,int tail,int y,int x){
    for(int i = 1;i <= 3;i++)
        for(int j =1;j <= 3;j++) queue[tail].now[i][j] = queue[head].now[i][j];
    queue[tail].step = queue[head].step + 1;
    for(int i = 0;i < 5;i++){
        int nx = x +gox[i],ny = y + goy[i];
        if(nx >= 1 && ny >= 1 && nx <= 3 && ny <= 3)
            queue[tail].now[ny][nx] = 1 - queue[tail].now[ny][nx];
    }
}
void bfs(){
    head = tail = 0;
    queue[head].step = 0;
    for(int i = 1;i <= 3;i++) 
        for(int j =1;j <= 3;j++) queue[head].now[i][j] = place[i][j];
    while(head <= tail){
        int temp = 0;
        for(int i = 1;i <= 3;i++)
            for(int j = 1;j <= 3;j++)
                temp = temp * 2 + queue[head].now[i][j];
        if(vis[temp]){
            head++; continue;
        }vis[temp] = 1;
        if(temp == 511){
            cout<<queue[head].step;break;
        for(int i = 1;i <= 3;i++)
            for(int j = 1;j <= 3;j++){
                tail++; change(head,tail,i,j);
            }
        head++;
    }
}
int main()
{
    for(int i = 1;i <= 3;i++)
        for(int j = 1;j <= 3;j++)
            cin>>place[i][j];
    bfs();
    return 0;
}
```

---


# Hz吐泡泡

## 题目背景

Hz大大是一种可爱的动物（神）。他很喜欢吐泡泡（更喜欢写作业）。


## 题目描述

这天，Hz大大心血来潮，吐了n个不同的泡泡玩（保证没有重复的泡泡）。因为他还要写作业，所以他请你帮他把这些泡泡排序成树（左子树<=根<右子树）。输出它的后序遍历。


## 说明/提示

水题一道。


## 样例 #1

### 输入

```
8
1 4 3 9 10 35 2 7
```

### 输出

```
deep=5
2
3
7
35
10
9
4
1
```

# 题解

## 作者：judgejudge (赞：25)

# 通俗易懂！！！
其实我们只需要**构建一个二叉树**，每次构造左右子树时计算**目前深度**就可以辽。。。

构造左右子树方法：

如果目前左子树还未赋值，就赋值，比较目前最长深度；

如果目前已经赋值，那么就把它的左（右）子树作为根，进行判断。

最后用**后根次序遍历**输出！！！

那么奉上AC代码：
```cpp
#include <iostream>
using namespace std;
int d[10000000],dl[10000000],dr[10000000];
long long n;
int prt(int k){//输出
    if(k>0){
        prt(dl[k]);//先输出左边
        prt(dr[k]);//然后输出右边
        cout<<d[k]<<endl;//输出根
    }
} 
int main(){
    long long i,j,k,m,p;
    long long ans=1,tot;
    cin>>n;
    for(i=1;i<=n;i++)cin>>d[i];
    for(i=2;i<=n;i++){//从第二个开始比较
        p=1;
        tot=1;
        while(p!=0){
        	tot++;//深度++
            if(d[i]<=d[p]){//判断左右子树
                if(dl[p]==0){//未赋值
                    dl[p]=i;//赋值
                    p=0;//手动退出
                }
                else p=dl[p];//否则再进行一次判断
            }
            else{
                if(dr[p]==0){
                    dr[p]=i;//赋值
                    p=0;
                }
                else p=dr[p];//再次判断
            }
            ans=max(ans,tot);//计算目前最大深度
        }
    }
    cout<<"deep="<<ans<<endl;//输出深度
    prt(1);
}
```


---

## 作者：Dijkspfa (赞：12)

吐槽题目难度，就算暴力可以A，那也是数据的关系，怎么会是普及-……

首先根据题意，可以直接写一棵题目所要求的树，即下面题解提到的BST。

每次暴力插入节点，插入时从根开始将插入值与当前节点权值比较，大则递归右子树，否则递归左子树，直到找到第一个空儿子，建立新的节点插入。这里给出不用指针的小清新版本：






```cpp
#include <cstdio>
#include <iostream>
#define gt(x) x = read()
#define max(x,y) x < y ? y : x
const int mxn = 300007;
int n,cnt,dep,nowd,root;
struct data{
    int ls,rs,val;
}tr[mxn];//ls,rs代表左右儿子
inline int read(int out = 0)//读入优化
{
    char c;
    while((c=getchar()) < 48 || c > 57);
    while(c >= 48 &&c <= 57) out=out*10+c-48,c = getchar();
    return out;
}
void insert(int& rt,int x)//插入，在修改rt时可以同时修改上一层函数中的tr[rt].ls/rs(起到代替指针的作用)
{
    ++nowd;
    if(!rt){rt = ++cnt,tr[rt].val = x;dep = max(dep,nowd);return;}
    if(x > tr[rt].val) insert(tr[rt].rs,x);
    else insert(tr[rt].ls,x);return;
}
void dfs(int rt)
{
    if(tr[rt].ls) dfs(tr[rt].ls);
    if(tr[rt].rs) dfs(tr[rt].rs);
    printf("%d\n",tr[rt].val);
}
int main()
{
    int in;
    gt(n);
    for(register int i = 1;i <= n;i++)
    {
        nowd = 0;//当前深度，每递归一次+1，每次插入初始化为0
        gt(in);
        insert(root,in);
    }
    printf("deep=%d\n",dep);
    dfs(root);
    return 0;
}
```
BST在最坏情况下复杂度是O(n^2)，对比数据范围，显然不是正确的复杂度。但是由于数据没有卡，所以这样就可以AC了……
下面给出我能想到的复杂度比较优的做法，尽量详细地说，可能有点复杂……

读入全部数据后，对数据进行离散化，然后建立双向链表，其中i的前驱和后继分别为i-1和i+1。

然后考虑每一个数的插入，基于BST的性质，很容易发现，每一个节点插入后的父节点都是在它之前插入的数中比它小或比它大的第一个数,父节点具体是哪个数则取决于他们插入的先后顺序。

手动模拟一下，很容易看出，父节点一定是两个数中深度较大的那一个，即当前插入的节点的深度为为max(deepu,deepd)+1,其中u，d是上面所说的两个点。

按照插入顺序倒序处理，另开数组记录下当前点的前驱后继，然后把这个点从链表中删去。由于之后插入的点此时已经删去，所以得到的前驱后继就是所求的点u,v。

将第一个点设为根节点，深度设为1，然后按照插入顺序正序处理，节点i的父亲为记录的两个点中较深的一个，深度为父亲的深度+1.

过程中求出最大深度，并记录下父子关系，最后dfs一遍求出后序遍历。

除了离散化之外，其他部分的复杂度都为O(n)，离散化的复杂度为O(nlogn)，总复杂度为O(nlogn)，不会被一条链的数据卡（如果存在的话）

tip:深度一定要初始化为1，有一个测试点的数据只有一个点，果断WA90....

代码见下





```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define gt(x) x = read()
using namespace std;
const int mxn = 300007;
int n,cnte,root,deep = 1;
int a[mxn],b[mxn],dep[mxn],ls[mxn],rs[mxn];//b为离散化后数列，ls rs存储当前点孩子
int u[mxn],d[mxn],pre[mxn],nxt[mxn];//pre nxt构建链表，u d存储所求点
inline int read(int out = 0)
{
    char c;
    while((c=getchar()) < 48 || c > 57);
    while(c >= 48 &&c <= 57) out=out*10+c-48,c = getchar();
    return out;
}
void dfs(int rt)
{
    if(ls[rt]) dfs(ls[rt]);
    if(rs[rt]) dfs(rs[rt]);
    printf("%d\n",a[rt]);
}
int find(int x)
{
    int l = 1,r = n;
    while(l <= r)
    {
        int mid = l+r>>1;
        if(a[mid] <= x) l = mid+1;
        else r = mid-1;
    }
    return r;
}
int main()
{
    gt(n);
    for(register int i = 1;i <= n;++i) gt(a[i]),b[i] = a[i],pre[i] = i-1,nxt[i] = i+1;//初始化链表
    sort(a+1,a+n+1);
    for(int i = 1;i <= n;i++) b[i] = find(b[i]);//离散化过程
    for(register int i = n;i >= 1;--i)
    {
        int t = b[i];
        u[t] = pre[t],d[t] = nxt[t];
        nxt[pre[t]] = nxt[t],pre[nxt[t]] = pre[t];//删除当前点，记录前驱后继
    }
    root = b[1];dep[b[1]] = 1,deep = 1;
    for(int i = 2;i <= n;++i)
    {
        int f = 0,t = b[i];
        if(u[t] >= 1 && u[t] <= n && dep[u[t]]+1 > dep[t]) dep[t] = dep[u[t]]+1,f = u[t];
        if(d[t] >= 1 && d[t] <= n && dep[d[t]]+1 > dep[t]) dep[t] = dep[d[t]]+1,f = d[t];//判断父亲
        if(f < t) rs[f] = t;
        else ls[f] = t;//判断儿子左右
        deep = max(deep,dep[t]);
    }
    printf("deep=%d\n",deep);
    dfs(root);
    return 0;
}
```

---

## 作者：zhangyuhan (赞：11)


这道题的题面中说道**左子树<=根<=右子树**，这就是标准的二叉排序树(BST)的定义.

此题考查的二叉排序树知识点很简单，只需要考察建树。

建树就是不断的调用$insert$函数就可以了。

树的深度？DFS搜一下就可以了

后序遍历？众位大佬都会吧

$AC$ $Code$(里面有注释)

```cpp
#include<iostream>
using namespace std;

struct node{
    int data,left,right;
};//定义一棵二叉排序树

node tree[300010];

int n1;

int n;

int ans;

int newnode(int x){
    n++;
    tree[n].data=x;
    tree[n].left=tree[n].right=0;
    return n;
}//创建新节点

void insert(int x,int& idx){
    if(!idx){
        idx=newnode(x);//如果到了该插入的位置，就调用newnode函数
        return ;
    }
    if(x<tree[idx].data)
        insert(x,tree[idx].left);//往左子树走
    else    
        insert(x,tree[idx].right);//往右子树走
}

void dfs(int idx,int deep){
    if(!idx){
        ans=max(ans,deep);
        return ;
    }
    dfs(tree[idx].left,deep+1);
    dfs(tree[idx].right,deep+1);
}//求深度

void printhx(int idx){
    if(idx){
        printhx(tree[idx].left);
        printhx(tree[idx].right);
        cout<<tree[idx].data<<endl;
    }
}//后序遍历

int main(){
    cin>>n1;
    for(int i=1;i<=n1;i++){
        int x;
        cin>>x;
        int id=1;
        if(i==1)
            newnode(x);
        else
            insert(x,id);
    }//输入数列加建树
    dfs(1,0);
    cout<<"deep="<<ans<<endl;//输出深度
    printhx(1);//输出后序遍历
    return 0;
}
```

---

## 作者：_121017_ (赞：4)

实际上就是一道二叉搜索树的模板题，我们只要构建一颗二叉搜索树然后在dfs遍历一遍就可以了。

那么我们如何建树呢？看一眼隔壁二叉堆，我们不难想到用 ```p*2```
  表示当前节点的左儿子， ```p * 2 + 1``` 表示右儿子，插入时只要判断比当前节点大还是小，如果比它小而它的左儿子为空，则为它的左儿子，大之同理。
# code
```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
int n,ans=1;
int tree[20000005];
bool pd=1;
void push(int a){
	int p=1;//最开始访问根节点
	while(tree[p]){//判断当前节点是否为空
		if(a<tree[p]){//如果比它小
			p=p*2;//则访问它的左儿子
		}else{
			p=p*2+1;//否则访问他的右儿子
		}
	}
	tree[p]=a;//找到合适位置了，直接加入
}
void dfs(int p,int d){
	if(tree[p]==0){//如果当前节点为空了，返回深度
		ans=max(ans,d);
		return;
	}
	dfs(p*2,d+1);//遍历左儿子
	dfs(p*2+1,d+1);//遍历右儿子
}
void print(int p){//递归输出解
	if(tree[p*2]){//如果左儿子非空
		print(p*2);//则遍历左儿子
	}
	if(tree[p*2+1]){//如果右儿子非空
		print(p*2+1);//则遍历右儿子
	}
	cout<<tree[p]<<endl;
}
signed main(){
	cin>>n;
	for(ri i=1;i<=n;i++){
		int a;
		cin>>a;
		push(a);
	}
	dfs(1,0);
	cout<<"deep="<<ans<<endl;
	print(1);
	return 0;
}
```
提交上去，只有 70 分， RE 了三个点，是什么原因呢，看下面这一组数据：
```cpp
Input:
20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Output:
deep=20
20
19
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
```
显然当输入数据有序时，二叉搜索树的空间会退化为 O ( 2 n - 1 ) 对于题目   1 <= n <= 300000 是显然会炸空间的，那我们怎么办呢？只要用指针就可以解决了。
# code
```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
int n,ans=1,cnt=1;
int tree[2000005];
bool pd=1;
struct node{
	int l;//左儿子下标
	int r;//右儿子下标
}next[2000005];//指针数组
void add(int p,int a,bool o){//o判断是左儿子还是右儿子，a为父亲的下标
	tree[++cnt]=a;//新增空节点
	if(o)next[p].l=cnt;//新增左儿子
	else next[p].r=cnt;//新增右儿子
}
void push(int a){
	int p=1;//访问根节点
	while(1){//一直搜索知道当前节点没有儿子
		if(a<tree[p]){//如果比它小
			if(!next[p].l){//且它没有左儿子
				add(p,a,1);//找到了位置，新增为它的左儿子
				break;//退出搜索
			} 
			p=next[p].l;//否则访问它的左儿子
		}else{//否则比它大
			if(!next[p].r){//且没有右儿子
				add(p,a,0);//新增为右儿子
				break;退出搜索
			}
			p=next[p].r;//否则继续搜索右儿子
		}
	}
}
void dfs(int p,int d){
	if(p==0) return;//如果当前节点为空，直接返回
	if(next[p].l==0&&next[p].r==0){//如果搜到底了
		ans=max(ans,d);//返回深度
		return;
	}
	dfs(next[p].l,d+1);//遍历左儿子
	dfs(next[p].r,d+1);//遍历右儿子
}
void print(int p){
	if(next[p].l){//如果左儿子非空
		print(next[p].l);//访问左儿子
	}
	if(next[p].r){//如果右儿子非空
		print(next[p].r);//访问右儿子
	}
	if(tree[p])cout<<tree[p]<<endl;
}
signed main(){
	cin>>n;
	for(ri i=1;i<=n;i++){
		int a;
		cin>>a;
		push(a);
	}
	dfs(1,0);
	cout<<"deep="<<ans<<endl;
	print(1);
	return 0;
}
```

---

## 作者：切格瓦·星 (赞：4)

# ~~此题过水~~

题意就是让你建一棵二叉排序树然后输出深度和后序遍历的序号即可

二叉排序树的定义(来自百度百科)

```
二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；

（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；

（3）左、右子树也分别为二叉排序树；

（4）没有键值相等的节点。

```

每次暴力插入即可....


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+7;
int n,a[N],root,sum,dep[N];
struct Tree{
	int l,r,val;
}t[N];
void ins(int &p,int val){//&符号可让局部变量值改变时所对应的的全局变量也  						//改变
	if(!p){
		p=++sum;
		t[p].val=val;
		t[p].l=t[p].r=0;
	}
	else{
		if(t[p].val<=val)
			ins(t[p].r,val);
		else ins(t[p].l,val);
	}
}
void print(int x){
	if(t[x].val){
		print(t[x].l);
		print(t[x].r);
		cout<<t[x].val<<endl;
	}
}//根据后续排序遍历的性质输出即可
void dfs(int u,int fa){
	if(t[u].val){
		dep[u]=dep[fa]+1;
		dfs(t[u].l,u);
		dfs(t[u].r,u);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		ins(root,a[i]);
	}
	dep[1]=1;
	dfs(1,0);
	int maxn=0;
	for(int i=1;i<=sum;i++)
		maxn=max(maxn,dep[i]);//递归找出深度最大值;
	cout<<"deep="<<maxn<<endl;
	print(1);
	return 0;
}
```



---

## 作者：UhhhQQQU (赞：3)

### 蒟蒻第一次写题解= =

------------
#### 根据本蒟蒻的~~经验~~水平，一看题就只会暴力（不愧是蒟蒻）
# 然而暴力出奇迹！
###### ~~其实只是数据弱~~
####  _不说了，上代码~~~_ 
```cpp
#include<cstdio>
int n,a[101],ans;
bool flag[100001];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        for(int k=1;k<=n;k++)
          if (a[i]!=a[j]&&a[j]!=a[k]&&a[k]!=a[i]&&a[j]+a[k]==a[i])
            flag[i]=true;
    for(int i=1;i<=n;i++)ans+=flag[i];
    printf("%d",ans);
}
```

---

## 作者：qfpjm (赞：2)

# 题意
- 对一棵二叉排序树进行后序遍历。

# 题解
- 其实就是二叉排序树的几个基本操作：
1. 插入节点：每当插入一个节点时，只需从头节点开始，比较大小，然后向左或向右遍历，对于遍历到的每一个节点，重复这个操作即可。（注意：开始需判断根节点是否存在。）
3. 求深度：当前节点深度即为 **max(右节点深度， 左节点深度）**。
2. 后序遍历：判断节点是否存在。若存在，先遍历其左节点，在遍历其右节点，最后输出本节点的值即可。若不存在，结束。（其实后序遍历可以用非递归实现，大家可以去试着写一写。）
- 知道了这几点，便可以开始写代码了。

# 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

struct BSTreeNode{
    int data;
    BSTreeNode *left;
    BSTreeNode *right;
    BSTreeNode *parent;
    BSTreeNode (int e): data(e),left(NULL), right(NULL), parent(NULL){}
};

void addNode(BSTreeNode *& root, int e){
    if (root == NULL){
        root = new BSTreeNode(e);
        return;
    }
    BSTreeNode* node = new BSTreeNode(e);
    BSTreeNode* p = root;
    BSTreeNode* preNode = NULL;
    int flag = 0; // 0 表示左，1 表示右
    while (p){
        if (e > p->data){
            preNode = p;
            p = p->right;
            flag = 1;
        }else{
            preNode = p;
            p = p->left;
            flag = 0;
        }
    }
    if (flag == 0){
        preNode ->left = node;
        node ->parent = preNode;
    }else{
        preNode ->right = node;
        node ->parent = preNode;
    }

}

BSTreeNode *build(int elements[], int len){
    BSTreeNode* root = NULL;
    for (int i = 1; i <= len; i ++){
        addNode(root, elements[i]);
    }
    return root;
}

int deep(BSTreeNode *root){
    if (root == NULL)
    {
        return 0;
    }
    int ldeep = deep (root ->left);
    int rdeep = deep (root -> right);
    return max(ldeep , rdeep) + 1;
}

void postorder(BSTreeNode *root)
{
	if (root)
	{
		postorder(root -> left);
		postorder(root -> right);
		cout << root -> data << endl;
	}
}

int e[1000001], n;

int main()
{
	cin >> n;
	for (int i = 1;i <= n;i ++)
	{
		cin >> e[i];
	}
    BSTreeNode *root = build(e, n);
    cout << "deep=" << deep(root) << endl;
    postorder(root);
    return 0;
}
```



---

## 作者：血色黄昏 (赞：2)

为什么你谷没有py版的BSTQwQ

这道题就是个BST的模板（而且更水），因为只用支持insert方法和后序遍历就行了

~~
想当年窝学BST的删除学了一节课...自闭~~

废话不说，上代码，有详细解析哦！
```python
ans = 1#标记是第几层
ans1 = 0#最高层数
class BST(object):
    def __init__(self, data, left = None, right = None):#BST的三个，值，左子树，右子树
        super(BST, self).__init__()
        self.data = data
        self.left = left
        self.right = right

    def insert(self, val):#插入函数
        global ans, ans1#调用全局变量
        if val < self.data:#如果小于就放到左子树
            if self.left:#如果有左子树
                ans += 1#层数+1
                self.left.insert(val)#左子树调用递归
            else:#没有左子树
                ans += 1#层数+1
                self.left = BST(val)#把值放在这个点的左子树上
                if ans > ans1:#如果层数比之前最高层数高
                    ans1 = ans#替换
                ans = 1#重新开始
        else:#比节点的值大
            if self.right:#有右子树
                ans += 1#层数+1
                self.right.insert(val)#右子树调用递归
            else:#没有右子树
                ans += 1#层数+1
                self.right = BST(val)#将值放在右子树上
                if ans > ans1:#如果层数大于最高层数
                    ans1 = ans#覆盖
                ans = 1#重新开始

    def last(self):#后序遍历：左，右，根
        if self.left:#有左子树
            self.left.last()#先遍历它的左子树
        if self.right:#有右子树
            self.right.last()#遍历右子树
        print(self.data)#都没有或已经遍历完就输出值


n = int(input())#输入数字个数
s = input().split()#分割成一个一个的值
t = BST(int(s[0]))#建立一个对象
for i in range(1, n):#遍历要插入的数字
    t.insert(int(s[i]))#插入进去
print("deep={}".format(ans1))#输出深度
t.last()#后序遍历

```
如果想要完整python版的BST，可以私我哦QwQ

祝大家A了这道题~

---

## 作者：Crybl (赞：2)

考察BST的插入问题，暴力可以过，深度我选择了边建树边更新...反正数据水，下面给出小清新版本
```cpp
#include<iostream>
#include<cstdio>
#define max(a , b) a > b ? a : b 
using namespace std ;
int n , maxdeep = 0 ;

struct node 
{
	int v , deep ;
	node* lchild ;
	node* rchild ;	
} ;

node* root = NULL ;

node* newnode (int v , int deep)
{
	node* Node = new node ;
	Node -> v = v ;
	maxdeep = max(maxdeep , deep) ;
	Node -> deep = deep ;
	Node -> lchild = Node -> rchild = NULL ;
	return Node ;
}

void insert (node* &root , int v , int deep)
{
	if (root == NULL)
	{
		root = newnode (v , deep) ;
		return ;
	}
	if (v <= root -> v) insert (root -> lchild , v , deep + 1) ;
	else insert (root -> rchild , v , deep + 1) ;
}

void posorder (node* root)
{
	if (root == NULL) return ;
	posorder (root -> lchild) ;
	posorder (root -> rchild) ;
	printf ("%d\n" , root -> v) ;
}

inline int read ()
{
	char ch = getchar () ;
	int x = 0 , f = 1 ;
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1 ;
		ch = getchar () ;
	}
	while (ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0' ;
		ch = getchar () ;
	}
	return x * f ;
}

int main ()
{
	n = read () ;
	for (int i = 1 ; i <= n ; ++ i)
	{
		int x ;
		x = read () ;
		insert (root , x , 1) ;
	}
	printf ("deep=%d\n" , maxdeep) ;
	posorder (root) ;
	return 0 ;
}
```


---

## 作者：dessert (赞：2)

# 思路
先造树，记录好左儿子，右儿子，深度，爸爸和输入的每一个节点值，进行排序，完了然后递归输出后序遍历。

[~(@^_^@)~](https://www.luogu.org/blog/dessert/)安利一记

------------
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct {
	int deep;    //深度
	int left;    //左儿子
	int right;   //右儿子
	int father;  //爸爸
	int date;    //每一个节点的值
} a[300001];
int cout_last_tree(int x) {         
	if(a[x].left!=0)                //先搜索左边的
		cout_last_tree(a[x].left);
	if(a[x].right!=0)               //然后右边
		cout_last_tree(a[x].right);
	cout<<a[x].date<<endl;
}
int main() {
    a[1].deep=1;     
	int n,maxx=1;                   //一定记住，深度要赋值成1，因为有可能只有一个节点
	cin>>n>>a[1].date;
	for(int i=2; i<=n; i++) {
		int j=1;                    //记录在哪一个节点下面
		cin>>a[i].date;
		while(1)
			if(a[i].date<=a[j].date)  //是否在左边
				if(a[j].left==0) {    //左二子是否是空的
					a[i].father=j;
					a[j].left=i;
					a[i].deep=a[j].deep+1;
					break;
				} 
				else
					j=a[j].left;
			else                      //不在左边就在右边
			    if(a[j].right==0) {
				   a[j].right=i;
				   a[i].father=j;
				   a[i].deep=a[j].deep+1;
				   break;
			    }   
			    else
				   j=a[j].right;
		maxx=max(a[i].deep,maxx);     //记录最大深度
	}
	cout<<"deep="<<maxx<<endl;         //输出
	cout_last_tree(1);                 //开始逆序输出
	return 0;                          //小清新
}
```
辛苦管理大大了！！！

---

## 作者：浮尘ii (赞：2)

二叉排序树（BST）模版。

二叉排序树：对于任意一个结点，若有左子树，则左子树所有结点的值<该节点；若有右子树，则右子树所有结点的值>该节点。

对于本题，稍加改造，满足 左子树<=根<右子树。

对于二叉排序树，若选取的根不好，可能退化成一条链，这样单次操作的复杂度退化成O(n)，故BST在实际应用中不太常用。

而为了解决退化成链的情况，有一种新的数据结构：平衡树。即通过各种奇怪的操作使BST的单次操作复杂度达到O(log n)，具体的在这里不介绍。


```cpp
#include <iostream>
#include <cstdio>

using namespace std;

struct Node {
    int     val, dep; //结点的权值、深度
    Node    *ch[2]; //ch[1]:右子树, ch[0]:左子树
    Node(const int& _val) : val(_val)
    { ch[0] = ch[1] = nullptr, dep = 0; }
} *Root(nullptr);

int    N, Ai, Dep;

void Insert(const int& val) //将val插入到BST中
{
    Node    *x(Root), *y(nullptr);
    while(x) //寻找插入的位置
        y = x, x = x -> ch[val > x -> val];
        //若val>x->val则在右子树,反之在左子树
    x = new Node(val);
    if(y)
        y -> ch[val > y -> val] = x, x -> dep = y -> dep + 1;
    else
        Root = x, x -> dep = 1;
    Dep = max(Dep, x -> dep);
    //插入BST并维护结点及其父亲信息
}

void Out(const Node* x) //后序遍历:左 右 根
{
    if(x -> ch[0])
        Out(x -> ch[0]);
    if(x -> ch[1])
        Out(x -> ch[1]);
    printf("%d\n", x -> val);
}

int main()
{
    cin >> N;
    while(N--) {
        scanf("%d", &Ai);
        Insert(Ai);
    }

    printf("deep=%d\n", Dep);
    Out(Root);

    return 0;
}
```

---

## 作者：By_Ha (赞：1)

- 题面中`左子树<根<右子树`明摆着告诉我们这一题用BST(二叉查找树)做,由于这一题过于水,普通二叉查找树可以直接过,可以入门练手(比如我).
- 二叉查找树的性质:`左子树<根<右子树`,我们可以利用这一性质,在均摊$O(logN)$的时间内找到我们需要的值是否存在,需要注意的是,有可能退化到$O(N)$

![](https://cdn.luogu.com.cn/upload/image_hosting/d4tgpzne.png)

- 我们查找是否存在`7`这个节点,从1开始搜索,
    - 1比7小,向右到5,
    - 5比7小,向右到6,
    - 6比7小,向右到8,
    - 8比7大,向左到7,结束.
- 假如我们要插入10,我们可以用类似的方法找到
    - 用上面的方法找到9,发现无路可走
    - 向对应子树(右子树)插入10.
- 附带芝士:后续遍历: 输出在dfs的最后,即  ->  遍历左边-遍历右边-输出该点
- 注意:之前看别人的题解以为直接爆开数组就行,结果爆炸,还是得动态开点.

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

#define Rint register int

int N,deep;

struct BST{
    int t[300005],cnt;
    int lt[300005],rt[300005];
    int build(int p,int plc,int val){
        if(plc == 1) //插入left
            lt[p] = ++cnt,
            t[lt[p]] = val;
        else //插入right
            rt[p] = ++cnt,
            t[rt[p]] = val;
        return 0;
    }
    void ins(int val){
        Rint p = 1,this_deep = 1;
        while(true){
            deep = max(deep,++this_deep);
            if(t[p] > val) p=lt[p]?lt[p]:build(p,1,val);//如果无左儿子插入左儿子,否则跳到左儿子
            else p=rt[p]?rt[p]:build(p,2,val);//同理
            if(p == 0) return;//如果插入,就退出
        }
    }
    void dfs(int p){
        if(p == 0) return ;
        dfs(lt[p]);dfs(rt[p]);
        cout << t[p] << endl;
    }
    BST () {cnt = 1;deep=1;}//默认会读入一个数字,所以深度和编号要加1
}bst;

int main(){
    ios::sync_with_stdio(false);
    cin >> N;cin >> bst.t[1];//读入第一个可以减少后面的判断
    for(Rint i = 2,t;i<=N;i++){
        cin >> t;
        bst.ins(t);
    }
    cout << "deep=" << deep << endl;
    bst.dfs(1);
    return 0;
}
```

---

## 作者：Manjusaka丶梦寒 (赞：1)

题目还是比较简单的。

对于给出的点，我们建树，a[i]这个数的编号就是i，对于每个点我们记录它的左孩子和右孩子，每次插入一个点，就从第一个点开始比较然后递归查询，(如果学过二叉查找树的话...emm又怎么会来看我的题解)。

对于后续遍历，dfs就好啦。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;
int n,x,a[300006],deep=1;
struct ahah{
	int l,r,v;
}tree[300006];
void dfs(int x)
{
	if(tree[x].l)dfs(tree[x].l);
	if(tree[x].r)dfs(tree[x].r);
	printf("%d\n",a[x]);
}
int main()
{
	scanf("%d%d",&n,&a[1]);
	for(int i=2;i<=n;i++)
	{
		scanf("%d",&a[i]);
		int ssj=1,flag=0,cnt=0;
		while(a[ssj])
		{
			if(a[i]<=a[ssj])
			{
				if(tree[ssj].l)ssj=tree[ssj].l;
				else { flag=1; break; }
			}
			else 
			{
				if(tree[ssj].r)ssj=tree[ssj].r;
				else { flag=2; break; }
			}
			cnt++;
		}
		deep=max(deep,cnt+2);
		if(flag==1)tree[ssj].l=i;
		else tree[ssj].r=i;
	}
	
//	while(cin>>n)cout<<tree[n].l<<" "<<tree[n].r<<"\n";
	printf("deep=%d\n",deep);
	dfs(1);
}
```
洛谷数据就是良心啊。

---


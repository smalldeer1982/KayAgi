# 木材加工

## 题目背景

要保护环境


## 题目描述

木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度**均**为 $l$ 的小段木头（木头有可能有剩余）。

当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。

木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。

例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。

## 说明/提示


#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。

## 样例 #1

### 输入

```
3 7
232
124
456```

### 输出

```
114```

# 题解

## 作者：MilkyCoffee (赞：875)

$\boxed{\text{前言}}$

由于这道题有一名神仙选手@[yummy](https://www.luogu.com.cn/user/101694)重造了毒瘤数据并且撤下了 **24** 篇题解，我来义无反顾的填补这个巨大的坑!

这里很多题解都是几年前写的，思路不够完善、清晰，很多都是只放了一个代码就完事，我来注射一下新鲜血液。

$\boxed{\text{思路}}$

首先我们输入 n 和 k 并且运用二分找到合适的尺寸，而l 必须要足够小，r 必须要足够的大。题中写道数组中的数最大不会超过 100000000 ，所以我们设 100000001 就可以了。

现在就走到了判断的环节，我们如何判断 mid 是太小还是太大呢？我们需要编写一个新函数 -- f。

在函数 f 中，我们依次要判断 a 中的每一个数并计算出能切出多少个 mid ，还要用一个变量  ans 储存他们，如果 ans 分的分数比 k 多或者正好等于，返回真。如果是小于 k ，返回假。

当 f 返回的是真的时候，我们就要试试还能不能把 mid 调大一点，就要 

```
l = mid;
```

如果返回的是假，我们就加的太大了，就要把 $mid$ 调小一点，就要

```
r = mid;
```

一直到结束，输出 l 就可以了。

$\boxed{\text{完整代码区}}$

```cpp
// #include <bits/stdc++.h>
#include <queue>
#include <stack>
#include <cmath>
#include <string>
#include <cstdio>
#include <iomanip>
#include <cstring>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

long long n, k;
long long a[1000005];

bool f(long long x) {
	long long ans = 0;
	for (int i = 1; i <= n; i++) {
		ans += a[i] / x;
	}
	return ans >= k;
}

int main() {
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	
	long long l = 0, r = 100000001;
	long long mid;
	
	while (l + 1 < r) {
		mid = (l + r) / 2;
		if (f(mid)) l = mid;
		else r = mid;
	}
	cout << l << endl;
	return 0;
} 
```

$\boxed{\text{祈祷区}}$

管理员求过，路过人求赞，希望能给你一点点小小的帮助呢~

---

## 作者：zhaowangji (赞：155)

大家真的应该做一做[网线主管](http://noi.openjudge.cn/ch0111/04/)（但可惜的是洛谷并没有这道题，只有noi有）

两道题目几乎一模一样（除了数据的格式）

题目里出现了“能够切割得到的小段的最大长度”且数据范围较大，故使用二分答案

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,k;
int a[100007];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	cin>>a[i];//正常读入
	int l=0,r=1e8+1,m;//r=100000001
    	//l是能取到的最小值（所以是0，也方便最后直接输出，而不要一堆代码特判），r是绝对取不到的值
	while(l+1<r)//模板
	{
		m=(l+r)/2;
		int cnt=0;//以m为长度能够切出木板的段数
		for(int i=1;i<=n;i++)
		cnt+=a[i]/m;//c++自带整除，也可以用floor
        	//枚举每段木材能切出多少木板
		if(cnt>=k)l=m;//切得多或刚好等于，则说明还有可能长度更长
		else r=m;//切得少，说明长度太大了
	}
	cout<<l<<endl;//l为答案
	return 0;
}
```


---

## 作者：tzl_Dedicatus545 (赞：44)

这是一道二分答案题，熟悉二分答案的大佬可以跳过下面一段：

------------

### 二分答案介绍：

二分答案就是说用 **二分** 的方法枚举答案，具体请看例子：

我现在在一堆木头中找最长的，我可以用一下方法：

1. 最找到可行范围内最中间的数,用 $check$函数判断他是否可行，分两种情况：
- 如果可行（$check$函数返回$1$）标记，返回 $chazhao(mid,r)$
- 如果不可行（$check$函数返回$0$）标记，返回 $chazhao(l,mid)$

表如下：

| 1 | 2 | 3 | 4 |5  | 6 | 7 | 8 | 9 | 10 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |

----------

### 代码：

#### 1.$check$ 函数

```
bool check(int len)
{
	int cnt=0;
	
	for(int i=0;i<n;i++)
	{
		cnt+=a[i]/len;
	}
	
	if(cnt>=k)
		return true;
	
	return false;
}
return 0;
}
```
原理是：长度为 $len$ 的情况下如果可以分到的段数比 $k$ 多，返回$true$,否则返回 $false$



------------

#### 2.$chazhao$ 函数

```
int chazhao(int l,int r)
{
	if(r-l<=1){
		if(check(r))
			return r;
		if(check(l))
			return l;
		return 0;
	}
	
	int mid=(r+l)/2;
	
	if(check(mid))
		return chazhao(mid,r);
	else
		return chazhao(l,mid);
}
```

逻辑是：

- 当 $r-l<1$ 时：

如果 $check(r)$可以的话，返回 $r$,如果 $check(l)$可以的话，返回 $l$,否则返回 $0$。

注意：这里一定要先判断 $r$,再判断 $l$，因为 $r>l$,要先判断大的。



- 否则先算出 $mid$ ,然后按上面的逻辑算。

主函数没有技术含量，可以自己写，检验自己是否真正会了。

---

## 作者：newhy2001 (赞：29)

# 一道很经典的二分答案题
## 关键有三个
1. 判断能否二分答案或者选用相似的解法，贪心。
2. 用于筛选答案的判断函数
```cpp
bool pan(int x) {
	ans=0;
	for(int i=1;i<=n;i++) {
		if(a[i]>=x) {
			ans+=a[i]/x;
		}
	}
	if(ans>=m) return true;//如果砍后节数多了，那就要长一点的
	else return false;
}
```
3. 二分的while……（很恶心的东西……不过搞懂了就很快乐~）
```cpp
while(l<=r) {
		int mid=(l+r)/2;
		if(pan(mid)) l=mid+1;//如果理解不了最好自己手动模拟一下
		else r=mid-1;
	}
```
## 完整代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100001],ans,n,m,xiao=100000001,da;
inline int read() {
	int s=0;
	char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) {
		s=(s<<1)+(s<<3)+ch-'0';
		ch=getchar();
	}
	return s;
}
bool pan(int x) {
	ans=0;
	for(int i=1;i<=n;i++) {
		if(a[i]>=x) {
			ans+=a[i]/x;
		}
	}
	if(ans>=m) return true;
	else return false;
}
int main() {
	n=read();
	m=read();
	int x;
	for(int i=1;i<=n;i++) {
		x=read();
		da=max(da,x);
		a[i]=x;
	}
	int l=1,r=da;
	while(l<=r) {
		int mid=(l+r)/2;
		if(pan(mid)) l=mid+1;
		else r=mid-1;
	}
	printf("%d",r);
	return 0;
}
```
###### 谢谢观赏

---

## 作者：_无v名_ (赞：27)

咳咳，我又来了，这貌似是我第三次发题解了。。。

先贴代码：


```cpp
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k,x,y,i,j;
int a[100001];
int ge(int x)
{
    int s=0;
    for(register unsigned i=n;i>=1;i--)
    {
        if(a[i]/x) s+=a[i]/x;
        else return s;
    }
    return s;
}
int ef(int l,int r)
{
    if(l>r) return l-1;
    int mid=(l+r)/2;
    if(ge(mid)>=k) return ef(mid+1,r);
    else return ef(l,mid-1);
}
int main()
{
    scanf("%d%d",&n,&k);
    for(register unsigned i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    cout<<ef(1,a[n]);
    return 0;
}
```
大致思想应该和各位的差不多，二分答案，但是我这里有一个小小小小小小的优化，当然这里指的不是sort，指的是……
```cpp
for(register unsigned i=n;i>=1;i--)
    {
        if(a[i]/x) s+=a[i]/x;
        else return s;
    }
这个，如果此时a[i]/x已经为0了，那么因为前面已经排好了序，所以后面不必继续判断了，直接return掉，机智吧~
```

---

## 作者：LMB_001 (赞：23)

这道题是很经典的二分，我先写了一个函数，是说每段木材长度为x，最多能切多少段

```cpp
uses math;
var
 n,m,x,maxn,l,r:longint;
 a:array[1..100000]of longint;
function count(x:longint):longint;//每段木材长度为x，能切多少段
var
 i:longint;
begin
 if x=0 then exit(maxlongint);//如果x等于0，肯定说明不能切，把它退了
 count:=0;
 for i:=1 to n do begin
  count:=count+a[i] div x;//一根木头最多能切a[i] div x段
 end;
end;
begin
 readln(n,m);
 for x:=1 to n do begin
  read(a[x]);//读入
  maxn:=max(a[x],maxn);//找a数组里最大的一个
 end;
 l:=0;
 r:=maxn;//实际上可以直接用maxlongint，反正二分快嘛
 repeat
  x:=(l+r) div 2;//去中间的
  if count(x)>=m then l:=x+1//如果切的段数大于标准的，就说明每段短了，就把l置为x+1
   else r:=x-1;//否则长了就把r置为x-1
 until l>r;
 write(r);//记住输出是r不是l！
end.

```

---

## 作者：qzcbw (赞：15)

首先我想说一下，二分题大致模板其实都差不多，而且本人也是刚接触二分题目，题解可能有相似处，在此说明。（可能是本人水平不够吧）

请看题目：

## 木材加工

时间限制: 0 Sec  内存限制: 128 MB

题目描述

木材厂有一些原木，现在想把这些木头切割成一些长度相同的小段木头（木头有可能有剩余），需要得到的小段的数目是给定的。当然，我们希望得到的小段木头越长越好，你的任务是计算能够得到的小段木头的最大长度。木头长度的单位是cm。原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。 
例如有两根原木长度分别为11和21，要求切割成到等长的6段，很明显能切割出来的小段木头长度最长为5. 

#### 输入
 
第一行是两个正整数N和K(1 ≤ N ≤ 100000，1 ≤ K ≤ 100000000)，N是原木的数目，K是需要得到的小段的数目。 
接下来的N行，每行有一个1到100000000之间的正整数，表示一根原木的长度。 

#### 输出

能够切割得到的小段的最大长度。如果连1cm长的小段都切不出来，输出”0”。 

#### 样例输入

3 7

232

124

456

#### 样例输出

114

（时间限制0Sec ？ 额……）

## 分析题目

看起来有点复杂，其实很简单。

时间复杂度为O（log2n）

只要把木材每段长度二分就行了。

首先，还是两个指针l和r。

由于我们不知道长度的范围，这里就用一个大数据来代替。

```cpp
long long s,l=0,r=0x7fffffff;
```


输入

```cpp
   scanf("%d%d",&n,&k);

	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
```

开始二分。

我们还是区中点，找范围。

但这里判断方式不一样，我们为了要确保段数要符合条件，我们还需要一个判断。

判断方式就是累加段数，看看有没有小于段数，如果小就将左指针向右移至当前中点。

如果大于等于段数，就将右指针向左移至当前中点

```cpp
int js(int x)

{

	register int i;
	t=0;
	for(i=1;i<=n;i++)
	{
		t+=a[i]/x;
		if(t>=k) return 1;
	}
	return 0;
} 

while(l+1<r)
	{
    
		m=l+(r-l)/2;
		if(js(m)==1) l=m;
		else r=m;
	}
```

最后输出

```cpp
printf("%d",l);
```


### 贴代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[100001],t=0,k,m,n;
int js(int x)
{
	register int i;
	t=0;
	for(i=1;i<=n;i++)
	{
		t+=a[i]/x;
		if(t>=k) return 1;
	}
	return 0;
}
int main()
{
	long long s,l=0,r=0x7fffffff;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	while(l+1<r)
	{
		m=l+(r-l)/2;
		if(js(m)==1) l=m;
		else r=m;
	}
	printf("%d",l);
	return 0;
}

```

#### 谢谢！——qzcbw

---

## 作者：锦瑟，华年 (赞：9)

好了，好久没发题解了，今天发一篇。

这题很简单，一道基础的二分，现在我来讲一下思路。

本题分为三大块，分别是主程序，二分子程序，计算段数的子程序。

我们先讲讲主程序，先看一下代码吧：

	int main(){
		int i,max=0,k;
		scanf("%d%d",&n,&k);//输入
		for(i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]>max)max=a[i];//见下面注释1
		}
		int h=find(1,max,k),flag=0;//h为二分返回的答案
		if(!h){//判断输出，此条件代表分不出大于等于 1cm 小段的情况
			printf("0");return 0;
		}
		while(sum(h)==k){//见下面注释2
			h++;flag=1;
		}
		printf("%d",h-flag);//输出
		return 0;
	} 
    
注释：

_**1**_：为什么要取 max 呢？可不可以取 min ？不可以。如果你取的是 min ，那你看一下以下样例就知道为什么要取 max 了。

输入：

5 1

1

1

1

1

100000
    
输出：
    
100000
    
这就是原因了，如果你取了 min ，你就会输出：1。

 _**2**_ ：为什么答案算出来了还要再 while 一下呢？因为二分返回的是一种可行方案，但满足条件的 可能有很多个，而你不知道二分返回的是哪答案，所以，为了取最大的，要再 while 一下。记住，如果 while 了，要减一（很显然），如果没有，则不减一（自己想一想为什么，可以手动模拟一下），这就是 flag 的用处。
 
下面我们看一下二分程序：

	int find(int l,int r,int k){
		if(l>r)return 0;//正常二分模板
		int mid=(l+r)/2,i;
		long long ans=sum(mid);//计算段数
		if(ans==k)return mid;//情况判断，见下面注释3
		if(ans>k){
			if(sum(mid+1)<k)return mid;
			else return find(mid+1,r,k);
		}
		else return find(l,mid-1,k);
	}
    
_**注释 3**_:很显然，如果 $ans==k$ ,则代表此答案可行，返回答案。如果 $ans>k$,则判断，如果 $sum(mid+1)<k$ ,则表示当前的 mid 是最大的可行方案，返回 mid ，即答案。身下两个二分的递归就不要我讲了吧，这是正常模板。

下面我们看一下计算段数的子程序：

	long long sum(int k){
		long long ans=0;//一定要开long long！爆 int 不怪我
		for(int i=1;i<=n;i++){//计算以 k 为一段的长度可以分为几段
			ans=ans+1ll*a[i]/k;
		}
		return ans;//返回答案
	}
     
这不需要我讲了吧，我相信大家都能明白。

好了，上总代码：

	#include<stdio.h>
	using namespace std;
	int a[100005],n;
	long long sum(int k){
		long long ans=0;//一定要开long long！爆 int 不怪我
		for(int i=1;i<=n;i++){//计算以 k 为一段的长度可以分为几段
			ans=ans+1ll*a[i]/k;
		}
		return ans;//返回答案
	}
    	int find(int l,int r,int k){
		if(l>r)return 0;//正常二分模板
		int mid=(l+r)/2,i;
		long long ans=sum(mid);//计算段数
		if(ans==k)return mid;//情况判断，见上面注释3
		if(ans>k){
			if(sum(mid+1)<k)return mid;
			else return find(mid+1,r,k);
		}
		else return find(l,mid-1,k);
	}
    int main(){
		int i,max=0,k;
		scanf("%d%d",&n,&k);//输入
		for(i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]>max)max=a[i];//见上面注释1
		}
		int h=find(1,max,k),flag=0;//h为二分返回的答案
		if(!h){//判断输出，此条件代表分不出大于等于 1cm 小段的情况
			printf("0");return 0;
		}
		while(sum(h)==k){//见上面注释2
			h++;flag=1;
		}
		printf("%d",h-flag);//输出
		return 0;
	} 
    
好了，拜拜~~~~~

---

## 作者：ShawnZhou (赞：8)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

题意要求我们把木材切割成很多段，使得这个短段尽量的长。

我们切割的段肯定是在[ 0,max{ wood [ i ]  } ]中，满足二分的有界性。

由题意显然单调，满足单调性。所以可以使用二分答案求解。

我们在读入的时候预处理出上边界r，特别注意下边界l是0不是1否则会RE第四点。

check函数也很好实现。以当前的答案x为标准去切割这些木材。枚举所有木材，对于每一段木材其能分割的段数最大是wood[i] / x，设一个累加器cnt记录这个值，用一个ans变量记录答案。

如果发现能切够k段则去右半部分找更大的解，如果发现切不够k段就去左边找可行解。

参考代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <map>
#define maxn 100005
#define maxl 100000005
using namespace std;
inline int read(){
    int num = 0;
    char c;
    bool flag = false;
    while ((c = getchar()) == ' ' || c == '\n' || c == '\r');
    if (c == '-')
        flag = true;
    else
        num = c - '0';
    while (isdigit(c = getchar()))
        num = num * 10 + c - '0';
    return (flag ? -1 : 1) * num;
}
int wood[maxn];
int n,k,ans;

bool check(int x){
    int cnt = 0;
    if (x==0)
        return false;
    for (register int i=1;i<=n;i++)
        cnt += wood[i] / x;
    if (cnt >= k){
        ans = max(ans,x);
        return true;
    }

    else
        return false;

}
int main(){
    int l = 0,r = maxl;
    n = read();k = read();
    for (register int i=1;i<=n;i++){
        wood[i] = read();
        r = max(r,wood[i]);
    }
    while (l < r){
        int mid = (l+r) >> 1;
        if (check(mid))
            l = mid + 1;
        else
            r = mid;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：w12144 (赞：8)

简单二分题，二分找长度，然后判断下这个长度可不可行就可以了。不过要注意最多可分为K段的情况下，木头的长度也有很多种情况，要找到这里面的最大值。
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int N, K,len[100005];
int cmp(int a, int b) {
	return a > b;
}
int main() {
	cin >> N >> K;
	long long sum = 0;
	for (int i=0; i < N; i++) {
		scanf("%d", &len[i]);
		sum += len[i];
	}
	if (sum < K) cout << '0' << endl;
	else {
		sort(len, len + N, cmp);
		//二分找长度
		int mid,cnt,l,r;
		for (l = 1, r = len[0];l<=r;) {
			mid = l + r >> 1;
			cnt = 0;
			for (int j = 0; j < N; j++) {
				cnt += len[j] / mid;
				if (cnt > K||cnt<=K&&len[j]<mid) break;
			}
			if (cnt >= K)
				l = mid+1;
			else if (cnt < K)
				r = mid - 1;
		}
		cout << r << endl;
	}
	return 0;
}
```

---

## 作者：minamikotori (赞：4)

直接二分要截的长度，

check 找出能截出多少根。 若小于， 则答案应该更小， 若大于则答案可以更大。

但是无奈第四个点比较恶心= = 居然是0。 所以RE了一次- -。 特判一下mid=0；就可以了。

接着就是naive的输出了。

ps：数据好吓人，其实水的不行好吗

···




```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
typedef long long Lovelive;
using namespace std;
Lovelive scan() {
    int f = 1; Lovelive x = 0;char c = getchar();
    while(c > '9' || c < '0') {if(c == '-') f= -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x*10 + c - '0', c = getchar();
    return f*x;
}
int n, c;
Lovelive a[110000];
Lovelive ans;
Lovelive l, r;
bool check(int mid) {
    int res=0;
    for(int i = 1; i <= n; i++)
        res += a[i]/mid;
    if(res >= c) return true;
    else return false;
}
int main() {
    n = scan(); c = scan();
    for(int i = 1; i <= n; i++) a[i] = scan(), r = max(r, a[i]);
    while(l < r) {
        Lovelive mid = (l+r)/2;
        if(mid == 0) {cout << "0"; return 0;}
        if(check(mid)) {ans=mid; l=mid+1;}
        else r=mid;
    }
    printf("%lld", ans);
    return 0;
}
···
```

---

## 作者：doby (赞：4)

noip2005……

二分……

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,num,len[100009],l=0,r=0,m;
int maxn(int a,int b){if(a>b){return a;}else{return b;}}//毫无卵用
int isok(int t)
{
    num=0;
    for(int i=1;i<=n;i++)
    {
        if(num>=k){break;}//切了太多也没用啊……
        num=num+len[i]/t;//加上切出来的段数
    }
    if(num>=k){return 1;}//可以切大一点
    else{return 0;}
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&len[i]);
        if(r<len[i]){r=len[i];}//右上限最大
    }
    r++;
    while(l+1<r)
    {
        m=(l+r)/2;//二分
        if(!isok(m)){r=m;}//选区间
        else{l=m;}
    }
    printf("%d",l);//输出
    return 0;
}
```

---

## 作者：Enzymii (赞：3)

数据范围显然是骗人的。。。。

或者说我的范围不对是来卡小数据的。。。

其实应该直接加完除掉找出二分的右端点即可。。。

我上一句是不是暴露了我这道题的做法。。。

所以，总的来说这题数据真水。。。

```cpp
#include <cstdio>
int a[100001];
int in()
{
    char c=getchar();int a=0,f=1;
    for(;(c<'0'||c>'9')&&c!='-';c=getchar());
    if(c=='-'){f=-1;c=getchar();}
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return a*f;
}
int main()
{
    int n,k,ans=0,mm=0;n=in();k=in();
    for(int i=1;i<=n;i++)
    {
        a[i]=in();
        ans+=a[i]/k;mm+=a[i]%k;
        if(mm>ans) mm-=ans,ans++;
    }
    int l=0,r=ans<<1;
    while(r-l>1) //这里的条件让我调了好久RE
    {
        int tot=0,mid=(l+r)>>1;        
        for(int i=1;i<=n;i++)
            tot+=a[i]/mid;
        if(tot>=k) l=mid;
        if(tot<k) r=mid;
    }
    printf("%d",l);
}
```

---

## 作者：坚决杀毒2008 (赞：2)

二分搜索。函数C()判断当前的mid是否满足“能切出K条绳子”这一条件。初始化区间时，lb设为0，ub设得足够大即可。（K ≤ 100000000）

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<cstdlib>
using namespace std;
int n,k,l[100010],i;
bool C(int x)
{
    int num=0;
    for(i=1;i<=n;i++)
    {
        num+=l[i]/x;
    }
    return num>=k;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&l[i]);
    }
    int lb=0,ub=100000001;
    while(ub-lb>1)
    {
        int mid=(lb+ub)/2;
        if(C(mid))
            lb=mid;
        else
            ub=mid;
    }
    printf("%d",lb);
    return 0;
}
```

---


# [TJOI2007] 跳棋

## 题目背景

在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。

![](https://cdn.luogu.com.cn/upload/pic/6077.png)


## 题目描述

跳棋规则：

（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）

1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。

（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。

跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。

问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？

如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：

A － B － F － L － K － E  （可能不唯一）

3    2    3    3     3

它的距离为14。


## 说明/提示

$\text{upd 2022.7.27}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4  3  2
1  0  1  0 
1  1  1  1
0  0  1  0
1  1  0  1```

### 输出

```
6```

# 题解

## 作者：犇犇犇犇 (赞：15)

## 先看数据范围，这道题n（1≤n≤100），所以一个dfs就可以过了。

~~但是还是把我卡了好久。~~  

这道题稍微难一点的地方就是$dfs$的时候从$0$开始不碰到下一个0或者边界**永不停止**。  
所以自然可以想到用$while$语句。  
我们用$dx,dy$来表示向四个方向移动。用变量$s$来统计从这个$0$到下一个$0$的步数。

```
	int tx=x,ty=y,s=0;
    while(tx+dx[i]>0 && tx+dx[i]<=n && ty+dy[i]>0 && ty+dy[i]<=n) //碰到边界
    {
		tx+=dx[i];
		ty+=dy[i]; 
		s++;  //走到下一个点
        if(m[tx][ty]==0) break; //走到目标！
    }
```

下面就可以很愉快的打$dfs$模板了。

要注意的是，当我们的步数$s=1$时情况为两个$0$相连，同样不满足要求

### 上代码

```
#include <bits/stdc++.h>
using namespace std;     
int n,i,j,k,ans;
int m[105][105],f[105][105]; //m表示棋盘，f统计这个点是否走过
int dx[4]={-1,1,0,0},dy[4]={0,0,1,-1}; //dx,dy表示四向移动
void dfs(int x,int y,int step) 
{
	int i;
	ans=max(ans,step); //更新ans
    for(i=0;i<4;i++) 
	{
        int tx=x,ty=y,s=0;
        while(tx+dx[i]>0 && tx+dx[i]<=n && ty+dy[i]>0 && ty+dy[i]<=n) 
		{
			tx+=dx[i];
			ty+=dy[i];
			s++;
            if(m[tx][ty]==0) break;
        } //如上述
        if(tx>0 && tx<=n && ty>0 && ty<=n && f[tx][ty]==0 && m[tx][ty]==0 && s!=1) //碰壁，走过，当前格子为0，两个0相连都不能走
		{
            f[tx][ty]=1;
            dfs(tx,ty,step+s); //走到下一个点
            f[tx][ty]=0; //回溯
        }
    }
}
int main() 
{
    int x,y,i,j;
	cin>>n>>x>>y;
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            cin>>m[i][j];
    f[x][y]=1; //出发点被走过了，所以要单独写
    dfs(x,y,0);	
    cout<<ans<<endl;
    return 0;	
}
```


---

## 作者：JJA_ (赞：6)

## [题目](https://www.luogu.com.cn/problem/P3848)大意：

给你一个 $n\times n$ 的跳棋棋盘，和一个棋子位置。格子为 $0$ 的是可以到达的，格子为 $1$ 的则不能，而棋子只能上下左右 $4$ 个方向跳。
能到达的两个格子间不能相邻，即起点和终点最少要隔一格。显然，跳过的格子不能再跳。求最远跳跃总距离。

## 思路：

这道题目中数据范围为 $n\le100$ ，可以能用爆搜过掉。从 $0$ 开始，向四个方向搜索，直到遇到下一个 $0$ 为止。每次循环时用 `ans`记录答案，判断答案和步数的大小，`ans`取较大的那个。

## 代码实现：

用一个 `vis` 数组标记有没有到达，用一个 `mapp` 数组记录地图，用 `ans` 记录答案，每次循环都用 `t` 来更新距离，最后时刻更新 `ans`。

完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<sstream>
#include<queue>
//#include<map>
#include<vector>
using namespace std;
//#define int long long
#define forr(i,a,b) for(int i=a;i<=b;i++)
#define repp(i,a,b) for(int i=a;i>=b;i--)
#define INF 1e9
#define ll long long
#define MAXN 200005
const int _x[]={0,1,0,-1,0},_y[]={0,0,1,0,-1};//四个方向
#define mem(a,n) memset(a,n,sizeof(a));
#define chkmax(a,b) a=a>b?a:b;//取大
#define chkmin(a,b) a=a<b?a:b;//取小
int mapp[105][105];
int vis[105][105];
int n,px,py;//格子数和初始位置
int ans;
void dfs(int x,int y,int t){
	chkmax(ans,t);
	vis[x][y]=1;
	forr(i,1,4){
		int xx=x+_x[i],yy=y+_y[i];//向一个方向移动
		int sum=1;//跃过格子总数
		while(xx>0&&yy>0&&xx<=n&&yy<=n){
			if(mapp[xx][yy]==1){//如果不是0，继续
				xx+=_x[i],yy+=_y[i],sum++;
			}
			else{
				if(sum!=1&&vis[xx][yy]!=1){//如果是0，且不相邻，在这个点深搜
					dfs(xx,yy,t+sum);
				}			
				break;
			}
		}
	}
    vis[x][y]=0;
	return;
}
int main(){
	mem(vis,0);
	scanf("%d%d%d",&n,&px,&py);
	forr(i,1,n){
		forr(j,1,n){
			scanf("%d",&mapp[i][j]);
		}
	}
	vis[px][py]=1;
	dfs(px,py,0);
	printf("%d\n",ans);
}
```

---
UpDate On 2021/4/14

题解被 hack 了,于是修复了亿些问题，包括未回溯以及判断分支语句优先级，并通过了给出的 hack 数据。

同时修复了 $\LaTeX$ 。

---

## 作者：UperFicial (赞：3)

# 搜索

### 前言

前些日子做的逗比题。

~~现在估值掉光了回来水水~~

~~当时还 $\sout{\color{red}\text{Hack}}$ 了一篇题解~~

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P3848)

### 题意简述

这里其实为了更好地理解题面，直接把坑点和要点都形式化的写在这里了。

给定一个 $01$ 矩阵 $a$，能从 $(x1,y1)$ 到达 $(x2,y2)$ 当且仅当：

- $a_{x1,y1}=a_{x2,y2}=0$。

- 两个位置需在同一行或同一列且中途只有 $1$。

- $(x2,y2)$ 还没有被到达且两个位置不相邻。

两位置的距离为 $|x_1-x_2|+|y_1-y_2|$。

求对于给定的起点可能的走过的最远距离。

### 题目分析

~~看很多题解都是直接爆搜，但是很不优雅。~~

~~这里给一个优雅的做法~~

我们可以枚举一个点，然后枚举 $4$ 个方向，对于它能到达的点与之连边，并相应的将这两个点标号。

于是，我们就可以得到一张有向图了。

而对于其中任意有边的两个点都在原题中是可以单向到达的。

直接在起点跑 $dfs$，并注意对经过的点打上标记即可。

另外附一个当时卡了我 $1h$ 的坑点：两个相邻并都为 $0$ 的点不可互相到达。（其实这个也写在上面了）

细节其实就是在建图了。

[$code$](https://paste.ubuntu.com/p/VVQRtY5pvG/)

[$AC$ 记录](https://www.luogu.com.cn/record/49486542)

$$\texttt{The End.by UF}$$

---

## 作者：funky_monkey (赞：3)

```cpp
/*
LGOJ P3848 [TJOI2007]跳棋
时空限制：1s 128MB 
这道题目的数据规模较小，我们可以选择使用搜索的算法。
 
首先，我们先来看一看以下这个问题：
一个无向图，有n个顶点，规定从一个指定的定点开始走，求走过的边的权值之和最大为多少？（每个顶点只能经过一次）
这个问题十分简单，从定点搜索（dfs）即可。

再反观这道题目，如果把同一行（列）的0节点当做上面问题的顶点，两个顶点之间的距离是
（中间相隔的1的个数+1），那么就很容易处理了。

所以我们主要要做的是将题目中的矩阵转化为一个无向图。 
 
这道题我本来想用和 LGOJ P1560 [USACO5.2]蜗牛的旅行Snail Trails相同的算法，借助do-while语句实现，
但是我后来发现那样做的话题目难点太过集中，于是，我就独辟蹊径，想出了这种把难易程度分开处理的算法。 
*/ 
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100+10;
int m[MAXN][MAXN],num[MAXN][MAXN],last[MAXN*MAXN],n,sx,sy,cn=0,ans=0;
bool vis[MAXN*MAXN]={false};
struct node1
{
    int next,to,v;
}e[MAXN*MAXN*MAXN];//前向星 
void Addedge(int temp1,int temp2,int temp3)
{
    cn++;
    e[cn].next=last[temp1];
    e[cn].to=temp2;
    e[cn].v=temp3;
    last[temp1]=cn;
}//存边 
void dfs(int flag,int cnt)
{
    ans=max(ans,cnt);
    for(int i=last[flag];i;i=e[i].next)
    {
        int temp_to=e[i].to,temp_val=e[i].v;
        if(vis[temp_to]==false)
        {
            vis[temp_to]=true;
            dfs(temp_to,cnt+temp_val);
            vis[temp_to]=false;
        }
    }
}//搜索转化完成的无向图。 
int main()
{
    scanf("%d%d%d",&n,&sx,&sy);
    int temp1=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            temp1++;
            scanf("%d",&m[i][j]);
            num[i][j]=temp1;//这里是将矩阵的点转化为线性的编号，第一行为1、2……n，第二行为n+1……2*n，以此类推。 
        }
    }
    //下面这两个循环是转化行。 
    for(int x=1;x<=n;x++)
    {
        int lx=0;
        for(int y=1;y<=n;y++)
        {
            if(m[x][y]==0)
            {
                if(lx!=0&&y-lx!=1)//特判，如果两个0相邻，则不能走。（根据题意） 
                {
                    Addedge(num[x][lx],num[x][y],y-lx);
                    Addedge(num[x][y],num[x][lx],y-lx);
                }
                lx=y;//记录同一行前一个点的位置。 
            }
        }
    }
    //下面这两个循环是转化列，总体和转化行的大同小异。 
    for(int y=1;y<=n;y++)
    {
        int ly=0;
        for(int x=1;x<=n;x++)
        {
            if(m[x][y]==0)
            {
                if(ly!=0&&x-ly!=1)
                {
                    Addedge(num[ly][y],num[x][y],x-ly);
                    Addedge(num[x][y],num[ly][y],x-ly);
                }
                ly=x;
            }
        }
    }
    vis[num[sx][sy]]=true;
    dfs(num[sx][sy],0);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：zilingheimei (赞：2)

### 蒟蒻又来写题解了

先看题目：[P3848 [TJOI2007]跳棋](https://www.luogu.com.cn/problem/P3848)

这题就是一个求最大步数的搜索

## 注意事项：

- #### 1、因为这是跳棋，也就是从第一个0开始只要还是1就一直跳下去，所以用一个循环来走：

------------

```cpp
while(nx>=1&&nx<=n&&ny>=1&&ny<=n&&a[nx][ny]==1){
//如果没有超界并且还是障碍就继续走
    nx+=dx[i];
    ny+=dy[i];
}
```

------------

- #### 2、然后便是找最长可以跳多远，这里要注意：因为是一次跳很多所以我用一个x，y存现在的位置，然后用最终的位置减去x，y的差的绝对值（因为可能向左向下）

然后便得出走了几步


------------

```cpp

step+abs(nx-x)+abs(ny-y)


```

------------

- #### 3、然后还有一点就是：万一开始跳到了当前x，y的边上，说明x，y边上没有障碍物，不合法就结束掉


------------

```cpp

if(abs(nx-x)+abs(ny-y)==1)continue;
//就在起点旁边说明没有障碍物，无法行走，舍弃

```

------------


下面是dfs函数：
```cpp

void dfs(int x,int y,int step){//x与y代表当前位置，step代表当前步数

    if(step>ans)ans=step;//因为求最远的距离所以每次都要判断一下
    
    int nx,ny;//分别代表即将到的x与y
    
    for(int i=0;i<4;i++){
    
        nx=x+dx[i],ny=y+dy[i];//行走
        
        while(nx>=1&&nx<=n&&ny>=1&&ny<=n&&a[nx][ny]==1){//如果没有超界并且还是障碍就继续走
        
            nx+=dx[i];
            ny+=dy[i];
        }
        
        if(nx<1||nx>n||ny<1||ny>n)continue;//如果超界舍弃
        
        if(used[nx][ny]==1)continue;//走过舍弃
        
        if(abs(nx-x)+abs(ny-y)==1)continue;//就在起点旁边说明没有障碍物，无法行走，舍弃
        
        used[nx][ny]=1;//记录走过
        
        dfs(nx,ny,step+abs(nx-x)+abs(ny-y));//dfs，abs(nx-x)+abs(ny-y)表示走过的路程
        
        used[nx][ny]=0;//回溯
    }
}

```


------------


代码如下：
```cpp

#include<bits/stdc++.h>
using namespace std;
int n,sx,sy,a[101][101],ans,used[101][101];
int dx[4]={1,-1,0,0};//x轴移动
int dy[4]={0,0,1,-1};//y轴移动
void dfs(int x,int y,int step){//x与y代表当前位置，step代表当前步数
    if(step>ans)ans=step;//因为求最远的距离所以每次都要判断一下
    int nx,ny;//分别代表即将到的x与y
    for(int i=0;i<4;i++){
        nx=x+dx[i],ny=y+dy[i];//行走
        while(nx>=1&&nx<=n&&ny>=1&&ny<=n&&a[nx][ny]==1){//如果没有超界并且还是障碍就继续走
            nx+=dx[i];
            ny+=dy[i];
        }
        if(nx<1||nx>n||ny<1||ny>n)continue;//如果超界舍弃
        if(used[nx][ny]==1)continue;//走过舍弃
        if(abs(nx-x)+abs(ny-y)==1)continue;//就在起点旁边说明没有障碍物，无法行走，舍弃
        used[nx][ny]=1;//记录走过
        dfs(nx,ny,step+abs(nx-x)+abs(ny-y));//dfs，abs(nx-x)+abs(ny-y)表示走过的路程
        used[nx][ny]=0;//回溯
    }
}
int main(){
    cin>>n>>sx>>sy;//sx表示起点x，sy表示起点y
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    used[sx][sy]=1;//将起点记录走过
    dfs(sx,sy,0);//dfs开始
    cout<<ans;
    return 0;
}

```

珍爱生命，远离抄袭


---

## 作者：Arse、三千体 (赞：2)

本蒟蒻AC的第一道蓝题！

### 题目大意：
从给定的起点按照每一步必须跃过至少一个“1”的方式从一个“0”走到另一个“0”，求最长路径。
### 坑点：
路径长度不是走过“0”的个数！！而是输入中的一个数字即为一步。(这个题目中有解释，~~但我仍然错了~~)

### 方法：
显而易见（n<=100）的DFS。

解释都在代码里，上代码

```cpp
#include<bits/stdc++.h>//万能头大法好
using namespace std;
int n,sx,sy;//棋盘大小，起点横，纵坐标
int a[100][100];//棋盘
bool booka[100][100];//标记走过的点
int ans;//步数
int xz[4]={0,0,-1,1};
int yz[4]={-1,1,0,0};
void dfs(int x,int y,int sum)//dfs函数
{
	if(sum>=ans) ans=sum;//随时更新答案
	for(int i=0;i<4;i++)//枚举四个方向
	{
		int s=0;//每一次走的步数
		int xx,yy;
		xx=x;
		yy=y;
		while(xx+xz[i]>=0&&xx+xz[i]<n&&yy+yz[i]>=0&&yy+yz[i]<n)
		{//用一个while循环来不断跃过“1”
			s++;
			xx+=xz[i];
			yy+=yz[i];
			if(a[xx][yy]==0) break;//找到“0”便退出
		}
		if(s!=1&&!booka[xx][yy]&&xx>=0&&xx<n&&yy>=0&&yy<n&&a[xx][yy]==0) //判断是否走过以及是否越界
		{
			booka[xx][yy]=true;
			dfs(xx,yy,sum+s);//如果没有越界则总步数加上当前步数
			booka[xx][yy]=false;
		}
	}
}
int main(){
	cin>>n>>sx>>sy;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	booka[sx-1][sy-1]=true;//我是从零开始用数组的，所以要减一
	dfs(sx-1,sy-1,0);
	cout<<ans;
	return 0;
}
```
完美AC

# 抄袭可耻

最后如果谁有用BFS的做法请私信，谢谢！！！！

~~管理大大给个通过呗~~

---

## 作者：czcz (赞：2)

一开始想到的是图的联通问题

然后一看数据就是一个大法师

注意细节

# 不能跨点跳跃，每个点只能用1次，跳跃不能连续。


基本思想就是依靠i确认搜索方向后，

依靠k用力朝此方向上搜索。

就x轴而言，可以从搜索点x,y通过

公式
```cpp
tx=xx[i]*k+x
ty=yy[i]*k+y

```

计算出即将跳跃的点坐标tx,ty
然后

测试1 该点是否能跳，是否在搜索范围内，且对应qi[tx][ty]==0 （如果均真，则说明此处可跳，赶紧dfs(tx,ty,len+k) //(k!=1)

测试2 是否在搜索范围外（四个不等式确定搜索范围）&&该点是否跳过（had0数组实现）

注意break的地方，不能跨点跳跃，每个点只能用1次，跳跃不能连续。
细节考虑较多。
```c
//头文件略

int qi[100][100],
had0[100][100];//i j位曾经有过0，记录0位位置信息
int xx[]={0,0,-1,1};
int yy[]={1,-1,0,0};
int n,x,y,ans;


void dfs(int x,int y,int len){
	ans=max(len,ans);//打擂台得到最大值，原装max函数
	for(int i=0;i<4;i++){//朝某一个方向用力（k）搜索
		for(int k=1;k<101;k++){//考虑极限情况，即使从1，1开始搜索，边界只会到100，1，所以循环100次足够
			int tx=k*xx[i]+x,ty=k*yy[i]+y;//起始点x y  +偏移方向 * k值偏移量 == 尝试点tx ty
			if(tx>=0&&ty>=0&&tx<n&&ty<n&&qi[tx][ty]==0){//满足边界条件情况下，判断此点是否可跳
				qi[tx][ty]=1;
				if(k!=1)dfs(tx,ty,len+k);//k==1 意味着两点紧密相邻，不能跳.k!=1时，可以跳，并且对最终长度贡献为k
				qi[tx][ty]=0;//回溯
				break;//这个方向只能用搜到的第一个
			}else{
				if(tx<0||ty<0||tx>=n||ty>=n)break;//此方向上的用力搜索，超过了搜索边界，（剪枝）
				if(had0[tx][ty]==1)break;//遇到了曾经有过0的位置（此处0被使用过了）
			}
		}
	}
}
int main(){
	
	cin>>n>>x>>y;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++){
			cin>>qi[i][j];
			if(qi[i][j]==0)had0[i][j]=1;//记录一下0出现的次数
		}
			
	qi[x-1][y-1]=1;//从0,0 开始存储
	dfs(x-1,y-1,0);//同上
	cout<<ans;
}

```


---

## 作者：Register (赞：2)

### 题意描述
给你一个$n\times n$的跳棋棋盘，和一个棋子以及它的出生地，有些格子可以跳有些不能，只能上下左右$4$个方向跳。

每次跳起点和终点最少要隔一格，且这些格子中不能有可以跳的。

包括出生点，跳过的格子不能再跳。

求最远跳跃总距离，每次跳跃的距离定义为中间相隔的格子数加$1$。
### 解题思路
由于$n$只有$100$，因此可以用爆搜

跳下一个格子和目前跳了哪些格子有关，因此使用$DFS$会很方便
### 注意事项
题意非常清晰，只是在代码编写时要注意一些小细节

在枚举一个格子跳到另一个格子时要注意一下几点：

- 有边界条件

- 特判是否相邻

- 没跳过

### 代码

```cpp
#include <cstdio>
int n,ans,sx,sy,w[4][2]={{1,0},{0,1},{0,-1},{-1,0}};
bool b[101][101],vis[101][101];
int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
void dfs(int x,int y,int dis){
	ans=dis>ans?dis:ans;vis[x][y]=true;
	for(register int i=0,nx,ny,sum;i<4;i++)
	{
		nx=x+w[i][0];ny=y+w[i][1];sum=1;
		while(nx>0&&nx<=n&&ny>0&&ny<=n)
			if(b[nx][ny]) {nx+=w[i][0];ny+=w[i][1];sum++;}
			else
			{
				if(sum!=1&&!vis[nx][ny]) dfs(nx,ny,dis+sum);
				break;
			}
	}
	vis[x][y]=false;
}
int main(){
	n=read();sx=read();sy=read();
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++) b[i][j]=read();
	dfs(sx,sy,0);
	printf("%d\n",ans);
    return 0;
}
```


---


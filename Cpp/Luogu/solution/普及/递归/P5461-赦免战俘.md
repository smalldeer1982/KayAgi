# 赦免战俘

## 题目背景

借助反作弊系统，一些在月赛有抄袭作弊行为的选手被抓出来了！

## 题目描述

现有 $2^n\times 2^n (n\le10)$ 名作弊者站成一个正方形方阵等候 kkksc03 的发落。kkksc03 决定赦免一些作弊者。他将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有作弊者都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免作弊者……直到矩阵无法再分下去为止。所有没有被赦免的作弊者都将被处以棕名处罚。

给出 $n$，请输出每名作弊者的命运，其中 0 代表被赦免，1 代表不被赦免。

## 样例 #1

### 输入

```
3```

### 输出

```
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1```

# 题解

## 作者：Ritanlisa (赞：411)

(不想写LaTeX)

~~听说这是一道模拟/分治？？？就只有我用位运算吗？~~

分析了一下样例：

```
    000 001 010 011 100 101 110 111
000 0   0   0   0   0   0   0   1
001 0   0   0   0   0   0   1   1
010 0   0   0   0   0   1   0   1
011 0   0   0   0   1   1   1   1
100 0   0   0   1   0   0   0   1
101 0   0   1   1   0   0   1   1
110 0   1   0   1   0   1   0   1
111 1   1   1   1   1   1   1   1

```

1. 首先判断是否赦免的函数**一定是对称的**

为啥？

假设这个函数是 f(i,j)   (第i行，第j列）

那就有 f(i,j)=f(j,i)

**所以不可能把f（i,j）简化到f'（i-j）或f'(i/j)**

**~~经试验~~也不可能简化成f'(i+j),f'(i\*j)**

2. 由于i,j的取值在二进制上的位数都可以看做等于i，我们考虑用一下位运算

（~~我曾经设计了用位运算来求二叉树的LCA哈哈哈哈~~）

结果发现上图中 i|j=111（7）

所以有以下判断式：

**f(i,j)=((i|j)!=((1<<n)-1)?0:1);**


10行代码AC!

时间复杂度:Θ(4^n)!

OCD！

 (旁白:不要管这个沙雕,她HRM和7BH玩多了）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	for(int i=0;i<(1<<n);i++){
		for(int j=0;j<(1<<n);j++){
			printf("%d ",(i|j)!=((1<<n)-1)?0:1);}
		printf("\n");}
	return 0;}
```


---

## 作者：BrandonSoong (赞：342)

# 一份不太常规操作的题解(￣▽￣)"
## 它的核心是：杨辉三角递推式
***
**杨辉三角的递推式如下**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100010
int yanghui[2][maxn],n;
int main()
{ 
	scanf("%d",&n);
	memset(yanghui,0,sizeof(yanghui));
	for(int i=1;i<=n;i++)
	{
		int k=i%2;//两个数组循环使用
		yanghui[k][i]=1;
		for(int j=1;j<i;j++)
		yanghui[k][j]=yanghui[!k][j]+yanghui[!k][j-1];
  	  
		for(int j=1;j<=i;j++)
		printf("%3d ",yanghui[k][j]);
  	  
		printf("\n");
	}
	return 0; 
} 
```
**输一个16进去的结果是这样：**
```cpp
   1
   1    1
   1    2    1
   1    3    3    1
   1    4    6    4    1
   1    5   10   10    5    1
   1    6   15   20   15    6    1
   1    7   21   35   35   21    7    1
   1    8   28   56   70   56   28    8    1
   1    9   36   84  126  126   84   36    9    1
   1   10   45  120  210  252  210  120   45   10    1
   1   11   55  165  330  462  462  330  165   55   11    1
   1   12   66  220  495  792  924  792  495  220   66   12    1
   1   13   78  286  715 1287 1716 1716 1287  715  286   78   13    1
   1   14   91  364 1001 2002 3003 3432 3003 2002 1001  364   91   14    1
   1   15  105  455 1365 3003 5005 6435 6435 5005 3003 1365  455  105   15    1
```
**现在我把程序里面的输出函数改一下**

**改成 如果是奇数就输出1，如果是偶数就输出【空格】 试一试**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100010
int yanghui[2][maxn],n,k;
int main()
{ 
	scanf("%d",&k);
	memset(yanghui,0,sizeof(yanghui));
	for(int i=1;i<=n;i++)
	{
		int k=i%2;
		yanghui[k][i]=1;
		for(int j=1;j<i;j++)
		yanghui[k][j]=yanghui[!k][j]+yanghui[!k][j-1];
 	   
		for(int j=1;j<=i;j++)////////只改了这个地方！！！
  	  	if(yanghui[k][j]%2)
		printf("1 ");////////只改了这个地方！！！
  	 	else
  		printf("  ");
   	 
		printf("\n");
	}
	return 0; 
} 
```
**输出的结果是这样子**
```cpp
1
1 1
1   1
1 1 1 1
1       1
1 1     1 1
1   1   1   1
1 1 1 1 1 1 1 1
1               1
1 1             1 1
1   1           1   1
1 1 1 1         1 1 1 1
1       1       1       1
1 1     1 1     1 1     1 1
1   1   1   1   1   1   1   1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
**有没有很惊喜！？**

**这就是类似于题目所描述的答案！**

**每个2的次方边长方块都是右上角没有东东**

**而题目的描述是左上角没有东东**

输出前面的空格再打印杨辉三角~~不就完事了吗233333~~
***

**所以我们现在只需要在原程序的基础上添加一个输出前置空格的语句**

**并且将输出换成2^p中的k**

**就像这样：**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100010
int yanghui[2][maxn],n,p;
int main()
{ 
	scanf("%d",&p);
	n=1<<p;
	memset(yanghui,0,sizeof(yanghui));
	for(int i=1;i<=n;i++)
	{
		for(int j=n-i;j>=1;j--)//这个地方！！！
		printf("  ");
        
		int k=i%2;
		yanghui[k][i]=1;
		for(int j=1;j<i;j++)
		yanghui[k][j]=yanghui[!k][j]+yanghui[!k][j-1];
 	   
		for(int j=1;j<=i;j++)////////只改了这个地方！！！
  	  	if(yanghui[k][j]%2)
		printf("1 ");////////只改了这个地方！！！
  	 	else
  		printf("  ");
   	 
		printf("\n");
	}
	return 0; 
} 
```
**现在我们再输入4进去(2^4==16)，出来的就是想要的形式了！**
```cpp
                              1
                            1 1
                          1   1
                        1 1 1 1
                      1       1
                    1 1     1 1
                  1   1   1   1
                1 1 1 1 1 1 1 1
              1               1
            1 1             1 1
          1   1           1   1
        1 1 1 1         1 1 1 1
      1       1       1       1
    1 1     1 1     1 1     1 1
  1   1   1   1   1   1   1   1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
**再结合一下题意 填充上0！**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100010
int yanghui[2][maxn],n,p;
int main()
{ 
	scanf("%d",&p);
	n=1<<p;
	memset(yanghui,0,sizeof(yanghui));
	for(int i=1;i<=n;i++)
	{
		for(int j=n-i;j>=1;j--)
		printf("0 ");
		int k=i%2;
		yanghui[k][i]=1;
		for(int j=1;j<i;j++)
		yanghui[k][j]=yanghui[!k][j]+yanghui[!k][j-1];
 	   
		for(int j=1;j<=i;j++)////////只改了这个地方！！！
  	  	if(yanghui[k][j]%2)
		printf("1 ");////////只改了这个地方！！！
  	 	else
  		printf("0 ");
   	 
		printf("\n");
	}
	return 0; 
} 
```
**输入4**
```cpp
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1
0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1
0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1
0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
*Over！*
***
## At the end
**这个方法我也是偶然发现的**

**其实它的关键是利用了二进制相加进位的原理（其实就是mod 2可以实现的原因）**

**上一排的1+1或者0+0得到下一排的0**

**上一排的0+1或者1+0得到下一排的1**

**有点像数字金字塔那道DP入门题**

**炒鸡快速，O(n)的复杂度，几乎就是【加】+【判断】+【输出】就完了**

[AC提交](https://www.luogu.org/recordnew/show/21015884)
***
 ## 写在最后
### ---------刷题有感----------
### ---------BS一夏雪---------
### 如果有不懂，模拟是王道。
### O  I  深莫测 ， 抽象为核心。
### 感觉很玄学，领悟靠内化。
### 刷题不在多，刷透就能赢。
**这个是[我的博客](https://www.luogu.org/blog/tolearnbetter/)，欢迎各位神犇拍砖**

---

## 作者：dz_ice (赞：339)

本题基本思路是分治，代码可以通过递归来实现，每次递归将左上方的正方形清零，并再次递归剩余的三个正方形，当正方形的边长为2时结束递归。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p=1,a[1050][1050];
void di(int x,int l,int q) //x为正方形边长，l、q分别为递归正方形的横纵坐标
{
	if(x==2) //递归边界
	{
		a[l][q]=0;
		return;
	}
	for(int i=l; i<=l+x/2-1; i++)
		for(int j=q; j<=q+x/2-1; j++)
			a[i][j]=0; //将左上方的正方形清零
	di(x/2,l+x/2,q);
	di(x/2,l+x/2,q+x/2); 
	di(x/2,l,q+x/2); //此处是递归剩余的三个正方形
}
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		p*=2; //计算正方形的边长
	for(int i=1; i<=p; i++)
		for(int j=1; j<=p; j++)
			a[i][j]=1; //将a数组先赋值为1
	di(p,1,1); //开始递归
	for(int i=1; i<=p; i++)
	{
		for(int j=1; j<=p-1; j++)
			cout<<a[i][j]<<" ";
		cout<<a[i][p]<<endl; //输出，此处可以避免输出行尾空格
	}
	return 0;
}
```
~~其实这道题很水~~

---

## 作者：离月无言 (赞：120)

发的第一篇题解还在审核中，  
缺乏发题解的经验，如有错误或交代不清请各位见谅  

谢谢

当时同机房的大佬十分钟就A了这道题，而我A了一个多小时（水平不足）

刚开始看的时候马上就想到了**递归和分治**（然而我不会）  
然后懵逼了半小时  

我竟然还想过要打表（傻子）

后来想起了我做过的一道类似的题~~（当时我那道题全机房最高分，甩大佬们80分）~~跑题了

接下来说正事  

做题的时候不难发现把正方形分成四份后，左下，右上，右下三部分**完全相等**，而左上部分全是0，可以留到**后期处理**

做完看题解时没发现一个用字符串的，所以我这里用**字符串**（ _**string**_ ）来解

头文件#include<string>里有一个本题特别重要的函数—— _**insert()**_ 函数（不懂自己去查）  
                                                           
核心思想（方法）：求下一个方阵的情况，**逐行逐行的将当前方阵情况插入下方（在下面复制两次），最后再补0** 
  
话不多说，看代码：

（30行代码） 
  
    
```cpp
#include<cstdio>
#include<string>                                                      //字符串解法 
#include<iostream>
using namespace std;
long n;
string a[1025];                                                       //记录方阵情况 
long A[15]={1,2,4,8,16,32,64,128,256,512,1024};                       //A[i]为**2的i次方** 
int main(){
	scanf("%ld",&n);
	if(n==0)
	printf("1");                                                  //2^0=1,只有一个人，**无法再分，不赦免** 
	else
	if(n==1)
	printf("0 1\n1 1");                                           //小打表 
	else{
		a[0]="01";                                            //第一行情况 
		a[1]="11";                                            //第二行情况 
		for(long I=2;I<=n;I++){                               //现在是第几个方阵（即求输入I的输出结果）（**分治思想**） 
		for(long i=A[I-1];i<A[I];i++){                        //新增行的行号（是第几行）
		   	a[i].insert(a[i].length(),a[i-A[I-1]]);       //在新一行尾部插入
		    a[i].insert(a[i].length(),a[i-A[I-1]]);           //**插入两次** 
		}
		for(long i=0;i<A[I-1];i++)                            //在头几行最前面插入A[I-1]个0（应该不需要解释了吧） 
		for(long j=0;j<A[I-1];j++)                            //字符串**存储时不带空格，输出才带空格** 
		    a[i].insert(0,"0");
	    }
	    for(long i=0;i<A[n];i++){                                 //输出结果，**加空格**
	    for(long j=0;j<A[n];j++)
	        printf("%c ",a[i][j]);
	        printf("\n");
		}
	}
	return 0;
}
```
如果你认为有帮助的话请为我点个赞  

谢谢

---

## 作者：VenusM1nT (赞：47)

模拟。

模拟赛打完吃完饭就 5:10 了……月赛只剩不到一个小时，所以码完 T1 就回酒店了……

那么这道题显然是一个简单的递归题，虽然这么做跑的比较慢，但是毕竟好写嘛。

做法就是将当前矩阵的左上一块标记上，然后递归进剩下三块继续做，如果当前矩阵为 $1\times 1$ 直接退出递归即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 2005
#define reg register
#define inl inline
using namespace std;
int n;
bool ans[MAXN][MAXN];
void Dfs(reg int x,reg int y,reg int xx,reg int yy)
{
    if(x==xx && y==yy) return;
    reg int tx=(x+xx)/2,ty=(y+yy)/2;
    for(reg int i=x;i<=tx;i++)
    {
        for(reg int j=y;j<=ty;j++) ans[i][j]=1;
    }
    Dfs(x,ty+1,tx,yy);
    Dfs(tx+1,y,xx,ty);
    Dfs(tx+1,ty+1,xx,yy);
}
int main()
{
    reg int x;
    scanf("%d",&x);
    n=1<<x;
    Dfs(1,1,n,n);
    for(reg int i=1;i<=n;i++)
    {
        for(reg int j=1;j<=n;j++) printf("%d%c",ans[i][j]?0:1,j==n?'\n':' ');
    }
    return 0;
}
```

---

## 作者：NKL丶 (赞：37)

## 找规律的题目 ~~（为什么大家都用的分治）~~  
首先$n$要先变成$2^n$。  
不难发现，对于第一行的最后一个（即$(1,n)$），为$1$。  
从第二行开始，对于每一个数可以用它上一个的数+右上的一个数，然后再$\%2$。  
因为求出来之后这个数字就不会改变，而且只涉及到上一行，所以可以直接用一维数组来模拟（上一个数就是自身，右上的数就是后一个）。  
如果不理解的话，可以看看代码，里面的注释会更加方便理解。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[(1<<11)+5];//用位运算，加快一下速度
int main()
{
    ios::sync_with_stdio(false);//加快输入输出
    cin>>n;
    n=1<<n;//先变为2^n
    a[n]=1;//特殊处理第一列的最后一项
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(j!=n)cout<<a[j]<<" ";//去除行末的空格
            else cout<<a[j];
            a[j]=(a[j]+a[j+1])%2;//重点：上面的数字就是a[j]，右边的数字就是a[j+1]，注意要取模
        }
        cout<<endl;//换行
    }
    return 0;
}
```


---

## 作者：Mubuky (赞：28)

### 一道模拟题 P5461 赦免战俘

思路：在初始值为1的矩阵中挖0（下面的代码中是在0里挖1），类似深搜和分治,每次调用函数将右上方的正方形清零，再继续处理剩余的三个正方形，个人认为这是不加任何优化思维难度最低的常规方法。

如图:将一个方阵分成4个方阵，方阵1制为0，然后对其余3个方阵执行该过程

| 方阵1 | 方阵2 |
| :----------: | :----------: |
| 方阵3 | 方阵4 |

```cpp
#include<stdio.h>//C头文件
#include<math.h>
int map[1100][1100],n;
void sm(int x1,int y1,int x2,int y2,int cnt)
//方阵左上角坐标(x1,y1),方阵右上角坐标(x2,y2)
//cnt表示挖0的轮数(由边长等于2的n次方且方阵边长每次除以二得cnt==n时已挖完)
{
	//对两点标记的方阵挖0
	int i;
	for(i=x1;i<=(x2-x1)/2+x1;i++){
		int j;
		for(j=y1;j<=(y2-y1)/2+y1;j++){
			map[i][j]=1;//标记为“赦免”
		}
	}
    //类似深搜
	if(cnt<n){//判断轮数，亦可放在函数开始时
		sm(x1,(y2-y1+1)/2+y1,(x2-x1+1)/2+x1-1,y2,cnt+1);//方阵2
		sm((x2-x1+1)/2+x1,y1,x2,(y2-y1+1)/2+y1-1,cnt+1);//方阵3
		sm((x2-x1+1)/2+x1,(y2-y1+1)/2+y1,x2,y2,cnt+1);//方阵4
	}
	return;
}
int main()
{
	scanf("%d",&n);//输入n如题
	int bc=pow(2,n);//作弊者方阵边长
	sm(1,1,bc,bc,1);//赦免~~(sm)~~
	int i;
	for(i=1;i<=bc;i++){
		int j;
		for(j=1;j<=bc;j++){
			printf("%d ",!map[i][j]);//输出
		}
		printf("\n");
	}
	return 0;
}
```
**另外:不难发现所求“赦免”01方阵次对角线左侧均为0,可利用此修改算法，降低复杂度**

### **ACSDF·Mubuky**

---

## 作者：Null_Cat (赞：23)

# 刚 刚 做 完 ！

咳咳，话说这道题啊嘞。。。我们可以画图来~~手动模拟~~

#### step1:

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |


//这里初始都是不被赦免的，所以初始全部为1

#### step2:

| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |


//可以看到的说，题意中的分成四个小正方形其实就是指将原矩阵截为四个边长2^(n-1)的小正方形

//因为要赦免左上角的一部分嘛。。。所以说就把左上角的一部分变为0

#### step3:

| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

//于是乎我们又把剩下的三个小正方形割了出来，~~然后就成了上面这个鬼畜的东西~~

#### step4:


| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 |
| 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

//这时候我们就得到了最后的输出，共计n+1步



------------
那么这时候我们就来思考一下我们的算法——

~~模拟~~

### 暴力出奇迹！

我们可以根据我们刚才做题的思路

首先我们是从(0,0)赦免到(n/2,n/2)

然后继续分别赦免(n/2+1,0)到(n/2+1,n)……

但是我们采用的方法是一样的，都是不断的割割割割鸽鸽鸽鸽鸽……~~（逐渐本质起来）~~

而对于鸽好的每一个部分，我们就采用鸽出它的方法继续鸽

这熟悉的感觉。。。这熟悉的配方。。。这难道就是。。。

## ~~暴力~~ 分治！

~~喵喵喵!(激动得露出了本质~~

所以说我们就把这么一个

~~让kkksc03大发慈悲~~

~~善良~~

好题被我们转化成了~~暴力~~分治

上代码：

```cpp
#include <iostream> 
#include <cstring>		//比赛不敢用bits/stdc++.h（瑟瑟发抖）

using namespace std;

bool g[2000][2000];		//开两千不会爆（亲测）

void dfs(int x, int y,int n){		//（其实还是个二维dfs）
	if(n > 0){		//判断条件！避免出不来
		for(register int i = x; i < n / 2 + x; i++){	//开始赦免
			for(register int j = y; j < n / 2 + y; j++){
				g[i][j] = 0;
			}
		}
		dfs(n / 2 + x, y, n / 2);		//分治右上角，范围莫得错（不要问我为什么我会让你注意）
		dfs(x, n / 2 + y, n / 2);		//左下角
		dfs(n / 2 + x, n / 2 + y, n / 2);		//右下角
	}
} 

int main(int argc, char* argv[]){
	register int* n = new int;		//日常水指针
	cin >> *n;
	*n = 1 << *n;		//相当于2^n次幂，左移运算，相对快一些（其实就是自己懒得写快速幂）
	memset(g, true, sizeof(g));		//手写memset也行（懒得一批）
	dfs(0, 0, *n);		//从(0,0)开始分治
	for(register int i = 0; i < *n; i++){
		for(register int j = 0; j < *n; j++){
			cout << g[i][j] << " ";		//输出，没啥，别忘空格
		}
		cout<<endl;		//每行都要回车的呢。。。
	}
	delete n;		//指针党勿忘qaq
	return 0;
}
```

所以这么一道~~水~~好题就被我们轻松敲完喏！

---

## 作者：ttyclear (赞：18)

### ~~辣么多人爆搜，找规律不好吗~~

我们来分析一下前三个数据的情况

$n=1$的时候：

$\begin{bmatrix}0,1\\1,1\end{bmatrix}$

$n=2:$

$\begin{bmatrix}0,0,0,1\\0,0,1,1\\0,1,0,1\\1,1,1,1\end{bmatrix}$

$n=3:$

$\begin{bmatrix}0,0,0, 0, 0, 0, 0, 1\\0 ,0 ,0 ,0 ,0 ,0 ,1 ,1\\0 ,0, 0, 0, 0, 1, 0, 1\\0 ,0 ,0 ,0 ,1 ,1 ,1 ,1\\0 ,0, 0, 1, 0, 0, 0, 1\\0 ,0, 1, 1, 0, 0, 1, 1\\0 ,1 ,0 ,1 ,0 ,1 ,0 ,1\\1 ,1 ,1 ,1 ,1, 1 ,1 ,1\end{bmatrix}$

我们发现如果我们把方阵分成$4$个小正方形，除去最上面的是全$0$，剩下的$3$个正方形即为上一种情况的正方形（例如将$n=3$分成$4$个正方形，右上、左下和右下的$4*4$的正方形都为$n=2$的正方形）

那么我们就可以欢乐的模拟了，在代码里，我们用$s[i][j]$来表示第$i$种情况的第$j$行（如$s[1][1]="0\quad1"$）
```cpp
//#pragma GCC optimize("Ofast")
#include <set>
#include <map>
#include <cmath>
#include <stack>
#include <queue>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define endl '\n'
#define fast ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define zy 2333333
#define bql 2147483647
using namespace std;
int n;
string s[15][1024];
int main()
{
	  fast;
		cin>>n;
		s[1][1]="0 1",s[1][2]="1 1";
		for (int i=2;i<=n;i++)
		{
			for (int j=1;j<=pow(2,i-1);j++)
			   for (int k=1;k<=pow(2,i-1);k++)
				    s[i][j]+="0 ";//先打出第一个全0的正方形
		}
		for (int i=2;i<=n;i++)
		{
			for (int j=1;j<=pow(2,i);j++)
			   if (j<=pow(2,i-1))
			      s[i][j]+=s[i-1][j];
				 else if (j%int(pow(2,i-1))!=0)
				    s[i][j]+=s[i-1][j%int(pow(2,i-1))],s[i][j]+=' ',s[i][j]+=s[i-1][j%int(pow(2,i-1))];//因为j会大于上一种情况的边长，蒟蒻只能用这种方法了QAQ
				 else
				    s[i][j]+=s[i-1][int(pow(2,i-1))],s[i][j]+=' ',s[i][j]+=s[i-1][int(pow(2,i-1))];//最后一行模数为0要特殊处理
		}

		for (int i=1;i<=pow(2,n);i++)
		   cout<<s[n][i]<<endl;
    return 0;
}

```


---

## 作者：tangyifei009 (赞：14)

与[P1498南蛮图腾](https://www.luogu.org/problemnew/show/P1498)是一样的  
若倒序存储，将下表向下及右复制（分形效果）即可
```
1 1
1 0
```
```cpp
/*
 * @Description: U75693
 * @Author: Tang Yifei
 * @e-mail: tangyifei009@163.com
 * @LastEditTime: 2019-07-14 14:49:28
 * @Contact me: qq: 1585361453
 */
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int maxn = 1505;
int p[maxn][maxn];

void cp(int &x);

int main()
{
    int n, a = 2;
    p[1][1] = p[1][2] = p[2][1] = 1;
    scanf("%d", &n);
    for(int i = 1; i <= n-1; i++)
    {
        cp(a);
    }
    for(int i = a; i >= 1; i--)
    {
        for(int j = a; j >= 1; j--)
        {
            printf("%d ", p[i][j]);
        }
        printf("\n");
    }
}

void cp(int &x)
{
    for(int i = 1; i <= x; i++)
        for(int j = 1; j <= x; j++)
            p[i][j+x] = p[i+x][j] = p[i][j];
    x *= 2;
}
```

---

## 作者：critnos (赞：11)

~~窝太菜了~~

仔细地观察，会发现这题是递推


![](https://cdn.luogu.com.cn/upload/image_hosting/f7daxh51.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/9zvciztb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/bfzhd5mq.png)

~~请原谅图片那无知的大小~~

发现了什么？

把位置$(1,1)$赋值为1，当作一个子矩阵，每次把子矩阵复制到它的下面和右面，然后把子矩阵当作从$(1,1)$点到$(x*2,x*2)$点的正方形矩阵（假设上一个子矩阵是从$(1,1)$点到$(x,x)$点的正方形矩阵，注意最后要倒序输出）。

上图中红色的是子矩阵，蓝色的是复制的矩阵，未复制的地方（黑色）都是0。

~~就完了？~~


```cpp
#include<bits/stdc++.h>
using namespace std; 
int a[1200][1200];//标记数组
int main()
{
	int n,i,j,k,s=1;//s：子矩阵大小
	cin>>n;
	a[0][0]=1;//赋初值
	for(i=0;i<n;i++,s*=2)//递推n次
		for(j=0;j<s;j++)//核心代码：复制子矩阵
			for(k=0;k<s;k++)
				a[j][k+s]=a[j+s][k]=a[j][k];//递推公式
	for(i=s-1;i>=0;i--)//倒序输出
	{
		for(j=s-1;j>=0;j--)
			cout<<a[i][j]<<' ';
		cout<<endl;
	}	
}
```


---

## 作者：唐一文 (赞：11)

## 找规律 + 打表（~~我太菜了只会打表~~）
### 首先，我们来找规律

$n = 1$ 时：  
0 1  
1 1

$n=2$ 时：  
0 0 0 1  
0 0 1 1  
0 1 0 1  
1 1 1 1

把它平均分成四个$2^{2-1}*2^{2-1}$的正方形：

左上角的正方形全是 0

看看其它三个正方形，可以发现全是：  
0 1  
1 1  
再对比一下$n=1$时的正方形，  
### 发现完全一样！

我们再验证一下$n=3$ 时的规律是否一样：  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 1 1  
0 0 0 0 0 1 0 1  
0 0 0 0 1 1 1 1  
0 0 0 1 0 0 0 1  
0 0 1 1 0 0 1 1  
0 1 0 1 0 1 0 1  
1 1 1 1 1 1 1 1

左上角的正方形还是全是0！！  
再来看看其它三个正方形，和$n=2$时也一样！！！

### 于是我们就可以欢乐地打表了
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	if(n==1){
		cout<<"0 1"<<endl;
		cout<<"1 1";
	}
	else if(n==2){
		cout<<"0 0 0 1"<<endl;
		cout<<"0 0 1 1"<<endl;
		cout<<"0 1 0 1"<<endl;
		cout<<"1 1 1 1";
	}
	else if(n==3){
		cout<<"0 0 0 0 0 0 0 1"<<endl;
		cout<<"0 0 0 0 0 0 1 1"<<endl;
		cout<<"0 0 0 0 0 1 0 1"<<endl;
		cout<<"0 0 0 0 1 1 1 1"<<endl;
		cout<<"0 0 0 1 0 0 0 1"<<endl;
		cout<<"0 0 1 1 0 0 1 1"<<endl;
		cout<<"0 1 0 1 0 1 0 1"<<endl;
		cout<<"1 1 1 1 1 1 1 1";
	}
	else if(n==4){
		cout<<"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1"<<endl;
		cout<<"0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1"<<endl;
		cout<<"0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1"<<endl;
		cout<<"0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1"<<endl;
		cout<<"0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1"<<endl;
		cout<<"0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1"<<endl;
		cout<<"0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1"<<endl;
		cout<<"0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1"<<endl;
		cout<<"0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1"<<endl;
		cout<<"0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1"<<endl;
		cout<<"0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1"<<endl;
		cout<<"0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1"<<endl;
		cout<<"0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1"<<endl;
		cout<<"0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1"<<endl;
		cout<<"0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1"<<endl;
		cout<<"1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1";
	}
	return 0;
}
```
打了前4个，后面的自己打吧（~~我才不会告诉你我在比赛时打了前5个就AC了~~）
### 当然，我这个方法仅供参考  
### 想到更好的方法最好不用我这种方法  
### 因为太费时了！

---

## 作者：DrStrange (赞：7)

先来看看样例：
```
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
貌似看不出什么来。。。（正是我月赛时的想法）

那么先把左上角的0去掉，再**镜像翻转**一下

我们就得到了这么一个东西：
```
1
1 1
1 0 1
1 1 1 1
1 0 0 0 1
1 1 0 0 1 1
1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
这时许多大佬应该已经看出来了

如果没看出来再放一个
```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
```
我终于发现了规律：
### 题目所求的正是前$2^n$行的杨辉三角对2取模的值
而且这道题的n最大值为10，也就是说最大要求1024行的杨辉三角，共运行$(1024+1)\times1024\div2\le1000000$次，也就是说程序不会TLE，太棒了！！！

那么一切都变得简单起来了

#### 上代码：
```
#include<iostream>
#include<cmath>
using namespace std;
int n,f[1025][1025];//2^n不会很大，可以放心储存二维数组
int main()
{
    cin>>n;n=pow(2,n);//直接将n替换为2^n
    for(int i=1;i<=n;i++)f[i][n]=f[i][n-i+1]=1;//初始化
    for(int i=3;i<=n;i++)//从第3行开始计算
    	for(int j=n-i+2;j<n;j++)//从每行第二项到倒数第二项
    		f[i][j]=(f[i-1][j]+f[i-1][j+1])%2;//边算边取模，不然一定会爆int，long long都没用
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)cout<<f[i][j]<<" ";
    	cout<<endl;
	}//输出就好了
    return 0;
}//程序纯属本人构思，简短明了，希望月赛中也能像这样发挥......
```

---

## 作者：EarthGiao (赞：6)

## 【思路】
递归 + 分治    
这是一道很有意思的题目

### 【前缀知识】        
很考虑个人的建模能力或者认识自己的能力   
建模能力很显然就是在脑海中建立模型的能力   
根据题目想象出，也就是在脑海中模拟递归的过程   
然后得出递归的式子   

那么认自己的能力是什么呢？     
就是别自己以为自己有建模能力   
然后想当然的，就是看着思考   
最后想上半天还没有结果     
所以这个时候就必须要动一动笔和纸了  
画一画思路更清晰      
这就是认识自己的能力!!!!     

~~我就没有建模的能力也没有认识自己的能力所以导致这道题目花了我好久的时间~~      


### 【核心思路】      
这是一个 $2 ^ n$ 的正方形，所以每一次分成四个全等的正方形的时候,      
边长都是刚好可以满足是2的倍数且可以组成正方形的     
因为你 $2 ^ n$ 每一次除以2分开之后，     
就变成了 $2 ^ {n - 1}$，还是2的倍数,    
所以可以继续分知道变为1,    
这就是在写代码之前需要搞明白的,     

然后，因为是左上角的那个正方形可以被赦免    
也就是0。     
所以只需要递归另外三个正方形就可以了     

我想的递归是每次递归他们的两个对角上的顶点    
然后通过他们顶点位置的变化来判断正方形的变化   
从而达到递归的效果    

###【举例分析】       
先来考虑右上角这个小正方形  

![](https://cdn.luogu.com.cn/upload/image_hosting/dtp0u5tc.png)

左上角的顶点位置在（1,5）上面，x1没有变       
所以可以得 x1 = x1;     

但是y1确改变了    
成为了5，位置刚好是原来y2也就是大正方形的一半长度 + 1    
所以可以得y1 = y1 + (y2 - y1 + 1) / 2或者y1 = y1 + (y2 - y1)  /  2 + 1   
两者是一个道理的    

而右下角的顶点在（4，8）上面    
x2是原来的一半可得      
x2 = (x2 - x1 + 1) / 2;    
为什么是这样呢？而不是x2 = x2 / 2呢   
因为例子里面x1是等于1的，    
但是x1不会永远等于1，     
如果x1等于个别的你带入x2 = x2 / 2之后就会发现有很大的问题     
所以就考虑我说的那个正确的！     

y2是没有变的所以可得       
y2 = y2     
这样就很容易的推出了      
（x1,y1 + (y2 - y1 + 1) / 2,x2 / 2,y2）   
来了    
这样就可以处理右上角的那个正方形了

知道了这些另外的两个正方形就很好可以推出来了
这里我就不多说了
因为过程和上面是一模一样的     
分别考虑每个坐标的变化就好了      

直接给出：    
左下角的正方形：(x1 + (x2 - x1 + 1) / 2,y1,x2,y1 + (y2 - y1) / 2)；    
右下角的正方形：(x1 + (x2 - x1 + 1) / 2,y1 + (y2 - y1 + 1) / 2,x2,y2)；     

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>

using namespace std;
const int Max = 1030;
int a[11] = {1,2,4,8,16,32,64,128,256,512,1024};
int f[Max][Max];

void acioi(int x1,int y1,int x2,int y2)
{
	if(x1 == x2 && y1 == y2)
	{
		f[x1][y1] = 1;
		return;
	}
	acioi(x1 + (x2 - x1 + 1) / 2,y1 + (y2 - y1 + 1) / 2,x2,y2);
	acioi(x1,y1 + (y2 - y1 + 1) / 2,x1 + (x2 - x1) / 2,y2);
	acioi(x1 + (x2 - x1 + 1) / 2,y1,x2,y1 + (y2 - y1) / 2);
}

int main()
{
	int n;
	cin >> n;
	acioi(1,1,a[n],a[n]);
	for(int i = 1;i <= a[n];++ i)
	{
		for(int j = 1;j <= a[n];++ j)
			cout << f[i][j] << " ";
		cout << endl; 
	}
	return 0;
}
```


---

## 作者：绝顶我为峰 (赞：6)

还是挺水的题目

考虑到$n$很小，可以$dfs$

可以把合适的边长每次除以二，然后判断是否在最上方的正方形，也就是$x<=step>>1\&\&y<=step>>1$

然后就~~摸你~~模拟就好

```cpp
// luogu-judger-enable-o2
#include<iostream>
using namespace std;
int n,k;
bool a[1051][1051];
bool dfs(int x,int y,int step)
{
	if(x<=step&&y<=step)//如果在左上方的正方形就被释放
		return 0;
	if(step==1)//如果不能再分就标记没有释放
		return 1;
	if(x>step)//如果不在左上角就把坐标移到坐上
		x-=step;
	if(y>step)//同理
		y-=step;
	return dfs(x,y,step>>1);//继续分
}
int main()
{
	cin>>n;
	k=1;
	while(n--)
		k<<=1;//求边长
	for(int i=1;i<=k;++i)
		for(int j=1;j<=k;++j)
			a[i][j]=dfs(i,j,k>>1);//从每个点爆搜，初始边长设成边长的一半
	for(int i=1;i<=k;++i)
	{
		for(int j=1;j<=k;++j)
			cout<<a[i][j]<<" ";//输出
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：bellmanford (赞：6)

思路：递归

根据题意，可以知道：

一个(1<<n)*(1<<n)的矩阵

相当于由一个(1<<(n-1))*(1<<(n-1))的空白矩阵加上三个
(1<<(n-1))*(1<<(n-1))的所要求的矩阵拼凑成的

这时便可以递归了

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,ans[15][2005][2005];

int main(){
	scanf("%d",&n);
	ans[0][1][1]=1;//只有一人时不赦免 
	for(int l=1;l<=n;l++){//递归 
		int m=1<<(l-1);
		for(int i=1;i<=m;i++){
			for(int j=1;j<=m;j++){
				ans[l][i][j]=0;
			}
		}
		for(int i=m+1;i<=(m<<1);i++){
			for(int j=1;j<=m;j++){
				ans[l][i][j]=ans[l-1][i-m][j];
			}
		}
		for(int i=1;i<=m;i++){
			for(int j=m+1;j<=(m<<1);j++){
				ans[l][i][j]=ans[l-1][i][j-m];
			}
		}
		for(int i=m+1;i<=(m<<1);i++){
			for(int j=m+1;j<=(m<<1);j++){
				ans[l][i][j]=ans[l-1][i-m][j-m];
			}
		}
	}
	for(int i=1;i<=(1<<n);i++){
		for(int j=1;j<=(1<<n);j++){
			printf("%d ",ans[n][i][j]);
		}
		printf("\n");
	}
}
```


---

## 作者：由比滨丶雪乃 (赞：5)

## 分治+爆搜
##### 配合[博客](https://www.luogu.org/blog/Hikigaya/p5461-ti-xie)食用更加
**题意很好理解，是一道非常好写的递归题，确定好递归的边界就可以愉快的AC了qwq**
### （定义好正方形左上角还有右下角的坐标，递归的时候判断还能不能继续分成正方形）

#### 上代码（~~我知道你们只看这个~~）


```cpp
#include <iostream>//卑微的头文件
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

int n;
int a[2050][2050];

void dfs(int x1,int y1,int x2,int y2,int num)//(x1,y1)为正方形的左上角坐标，（x2，y2）为右下角坐标，这里注意：由于读入坐标的时候和  平常数学的平面直角坐标系不同，左上角的“纵坐标”是小于右下角的“纵坐标”的
{
	if(num<n)//判断是否能递归下去，分成三个小正方形
	{
		dfs((x2-x1)/2+x1+1,y1,x2,y1+(y2-y1)/2,num+1);
		dfs((x2-x1)/2+x1+1,(y2-y1)/2+y1+1,x2,y2,num+1);
		dfs(x1,(y2-y1)/2+y1+1,x1+(x2-x1)/2,y2,num+1);
	}
	for(int i=x1;i<=(x2-x1)/2+x1;i++)
	  for(int j=y1;j<=(y2-y1)/2+y1;j++)
	     a[i][j]=1;//标记能赦免，等等输出时取反即可qwq
}
	
int main()
{
	memset(a,0,sizeof(a));//初始化
	scanf("%d",&n);
	dfs(1,1,(1<<n),(1<<n),1);//位运算貌似快一点（雾）
	for(int i=1;i<=(1<<n);i++)
	   {
	    	for(int j=1;j<=(1<<n);j++)
	    	  printf("%d ",!a[i][j]);//取反输出
	    	printf("\n");//注意换行
	   }
	return 0;//华丽的结束
}
```


---

## 作者：杯子 (赞：5)

## 基本思路
仔细观察输出样例，其实可以发现一些规律的。
下面是输出样例：
```
1|0 0 0 0 0 0 0 1
2|0 0 0 0 0 0 1 1
3|0 0 0 0 0 1 0 1
4|0 0 0 0 1 1 1 1
5|0 0 0 1 0 0 0 1
6|0 0 1 1 0 0 1 1
7|0 1 0 1 0 1 0 1
8|1 1 1 1 1 1 1 1
```
其实也不难发现，每一个数都是它上面的那个数和它右上方那个数异或的结果。（异或，即不同结果为1，相同结果为0）

状态转移方程：
```
f[i][j]=f[i-1][j]^f[i-1][j+1]; //^为异或运算
```
再进行降维优化，可得：
```
f[i]=f[i]^f[i+1];
即f[i]^=f[i+1];
```
主要部分已经清楚了，但是为了保证第1行能正确输出，我们要注意第0行的初始化。我们可以将第0行进行这样的处理：
```
0|1 1 1 1 1 1 1 1 0//第0行不用输出
1|0 0 0 0 0 0 0 1
2|0 0 0 0 0 0 1 1
3|0 0 0 0 0 1 0 1
4|0 0 0 0 1 1 1 1
5|0 0 0 1 0 0 0 1
6|0 0 1 1 0 0 1 1
7|0 1 0 1 0 1 0 1
8|1 1 1 1 1 1 1 1
```
思路清晰，就可以开始打代码了。
# 最简单的DP AC代码（我知道你只想要这个）
时间复杂度$O(4^{n})$
空间复杂度$O(2^{n})$
```cpp
#include<cstdio>
#include<cmath>
bool f[1025]={};
int n,l;
int main()
{
    scanf("%d",&n);
    l=pow(2,n);					//几行几列。pow(x,y)在cmath中，求x的y次方。
    for(int i=1;i<=l;i++)
    {
        f[i]=1;
    }
    for(int i=1;i<=l;i++)
    {
        for(int j=1;j<=l;j++)
        {
            printf("%d ",f[j]^=f[j+1]);	//状态转移方程。这里我计算一个输出一个。
        }
        printf("\n");				//注意格式
    }
    return 0;
}
```
月赛时因为评测机的问题出来50分，多提交了几遍，最后评测机修复后就只有85分了。。。。（可恶的乐多赛制）

为什么用dp？因为其他的我也不会，hhhhhh

---

## 作者：TEoS (赞：5)

~~月赛竟然不到90分钟就有人AK了，洛谷会不会很没面子~~

T1，暴搜（听说由大佬用杨辉三角，还有大佬打表，但本蒟蒻只会暴搜）
 
那么暴搜要传什么参数呢？显然就是当前目标区域了。这里用三个参数表示一个区域：区域左上角的横坐标、纵坐标和区域的边长。然后对于每个区域，把左上角那块全部标记，然后再递归另外三块就好了。

具体实现看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const int N=1030;
int n,map[N][N];
void dfs(int x,int y,int l)
{
	if(map[x][y])
		return ;//假装剪枝
	for(int i=x;i<=x+l-1;i++)
		for(int j=y;j<=y+l-1;j++)
			map[i][j]=1;//标记左上角块
	if(l==1)
		return ;//递归边界
	dfs(x,y+l,l>>1);
	dfs(x+l,y+l,l>>1);
	dfs(x+l,y,l>>1);//递归另三块
}
int main()
{
	cin>>n;
	dfs(1,1,pow(2,n-1));
	for(int i=1;i<=pow(2,n);i++)
	{
		for(int j=1;j<=pow(2,n);j++)
			printf("%d ",1-map[i][j]);//原来标记时是反的，这里反着输出
		printf("\n");
	}
	return 0;
} 
```

---

## 作者：君立の曾祖父 (赞：4)

## 很多大佬都是几行写完，蒟蒻只好发一篇较长的代码
## 废话不多说，直接看代码
~~(我太蒻了，实在说不出来)~~


```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#define R register
const int N=5005;
int a[N][N];
inline void Init(int n){//先将每一个都设为不被赦免的状态
    int s=pow(2,n);
    for (R int i=1;i<=s;++i){
	for (R int j=1;j<=s;++j){
	    a[i][j]=1;
	}
    }
    return;
}
inline void solve(int x,int y,int n){//分治
	if (!n) return;//如果为0，就退出
	int s=pow(2,n);
    //每次将左上方的1/4方阵赦免
	for (R int i=1;i<=s/2;++i){
	    for (R int j=1;j<=s/2;++j){
		a[i+x-1][j+y-1]=0;//赦免
	    }
	}
    //继续分治另外的3/4
	solve(x,y+(s/2),n-1);//右上方的方阵
	solve(x+(s/2),y,n-1);//左下方的方阵
	solve(x+(s/2),y+(s/2),n-1);//右下方的方阵
}
inline void write(int a){//快速输出
	if(!a)putchar('0');if(a<0)putchar('-'),a=-a;
	char b[15]={0},i;
	for(i=13;a;--i)b[i]=a%10+'0',a/=10;
	for(++i;i<14;++i)putchar(b[i]);
	printf(" ");
}
inline void out(int n){//最后输出kkk赦免后的方阵
	int s=pow(2,n);
	for (R int i=1;i<=s;i++){
		for (R int j=1;j<=s;j++){
			write(a[i][j]);//快输
		}
		printf("\n");//换行
	}
}
int main (){
	int n;
	scanf ("%d",&n);
	Init(n);
	solve(1,1,n);
	out(n);
	return 0;
}//完结撒花qwq
```


---

## 作者：花落丶子不语 (赞：4)

一个小蒟蒻发个垃圾题解，DALAO不喜勿喷

洛谷月赛的时候就AC了这一题，不然排名要在1000外的我（然而最终排名也是八百多）

下面放代码↓↓↓
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,lengthsq;
bool sq[1025][1025];
bool s(int x,int y)
{
	return sq[x+1][y]==sq[x][y+1];
}
int main()
{
	cin>>n;
	lengthsq=pow(2,n);
	for(int i=1;i<lengthsq;i++)
	  for(int j=1;j<lengthsq;j++)
	    sq[i][j]=0;
	for(int i=1;i<lengthsq;i++)
	  sq[i][lengthsq]=1;
	for(int i=1;i<=lengthsq;i++)
	  sq[lengthsq][i]=1;
	for(int i=lengthsq-1;i>=1;i--)
	  for(int j=lengthsq-1;j>=1;j--)
	    sq[i][j]=!s(i,j);
	for(int i=1;i<=lengthsq;i++)
	{
	    for(int j=1;j<=lengthsq;j++)
	      cout<<sq[i][j]<<" ";
		cout<<endl;
	}  
	    
	return 0;	 
}
```
然后我想说。。。洛谷的评测机出bug是什么设定。。。

虽然我无所谓（太菜了没法子）

最终本题得分95。。。吐槽乐多赛制

首先，我不懂什么谢尔宾斯基三角~~（大佬勿喷）~~，甚至连PJ递归（还是递推？）算法也不会（菜到家了）。。。

然后的话，我在观察样例的时候，发现，**只有当该数下方和该数右方的数不同时，该数的只才为1**。

于是乎初始化该矩阵值为0**除了最下方和最右方为1**

所以，我从右下方开始算到左上，就可以的处于题目要求的答案。

不造有几个人发现这种~~垃圾做法~~，于是乎，便AC了（想不通为什么同一题AC了也要重新提交一次才算入通过数）。。。

总用时134ms，内存1.62MB

纪念第一个非打表题解（算上这篇也才提交了两篇题解）QAQ

---

## 作者：_•́へ•́╬_ (赞：4)

### 这题就分治
### 分成4块，对右上、左下、右下进行递归（左上已经赦免了
```cpp
#include<stdio.h>
int n,ans[5555][5555];
void dfs(int x,int y,int n)
{
    if(n==1){ans[x][y+1]=ans[x+1][y]=ans[x+1][y+1]=1;return;}//边界
    register int midx=x+(1<<n-1),midy=y+(1<<n-1);//算出最中间的
    dfs(x,midy,n-1);dfs(midx,y,n-1);dfs(midx,midy,n-1);//递归：右上、左下、右下
}
main()
{
    scanf("%d",&n);//输入
    dfs(0,0,n);
    for(register int i=0;i<(1<<n);++i)
    {
        for(register int j=0;j<(1<<n);++j)printf("%d ",ans[i][j]);//输出
        putchar('\n');
    }
}/**/
```

---

## 作者：innerway (赞：4)

这道题数据比较小，最大只有1024 * 1024  
所以可以用递归做  
每次把整个图分成四个方块，把左上方的方块清零，然后再同样处理其他三块  


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int graph[2000][2000];
void work(int,int,int);
int main(){
    cin>>n;
    n=(1<<n);
    for(int i=1;i<=n;i++){ //全部设成1
        for(int j=1;j<=n;j++){
            graph[i][j]=1;
        }
    }
    work(1,1,n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cout<<graph[i][j]<<" ";
        }
        cout<<endl;
    }
}
void work(int x1,int y1,int d){ //左上角的坐标，所处理的方块边长
    if(d==1) return;
    for(int i=x1;i<x1+(d/2);i++){ //将左上方方块清零
        for(int j=y1;j<y1+(d/2);j++){
            graph[i][j]=0;
        }
    }
    //处理其他三块
    work(x1+(d/2),y1,d/2);
    work(x1,y1+(d/2),d/2);
    work(x1+(d/2),y1+(d/2),d/2);
    return;
}
```

---

## 作者：ShineEternal (赞：4)

~~来一篇题解纪念一下~~

# 分析：

这道题其实是利用了分治的思想，我们可以利用函数递归实现。

每次函数传进去三个参数：当前矩阵左上角的坐标（x,y）和矩阵长度。

这样的话就能表示矩阵。

然后把左上角处理一下，其他部分接着递归即可。

> code
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int a[1200][1200];
int pd(int x,int y,int c)
{
	if(c==1)return 0; 
	if(c==0)return 0;
	for(int i=x;i<=x+c/2-1;i++)
	{
		for(int j=y;j<=y+c/2-1;j++)
		{
			a[i][j]=1;
		}
	}
	pd(x+c/2,y,c/2);
	pd(x,y+c/2,c/2);
	pd(x+c/2,y+c/2,c/2);
	return 0;
}
int main()
{
	//freopen("testb.out","w",stdout);
	int n;
	scanf("%d",&n);
	int tmp;
	tmp=pow(2,n);
	//printf("%d\n",tmp);
	pd(1,1,tmp);
	for(int i=1;i<=tmp;i++)
	{
		if(a[i][1]==1)printf("0");
		else
		printf("1");
		for(int j=2;j<=tmp;j++)
		{
			if(a[i][j]==1)printf(" 0");
			else
			printf(" 1");
		}
		printf("\n");
	}
	return 0;
} 
```

---

## 作者：_MRCMRC_ (赞：4)

### 事实证明，万物皆可DP
#### 根据本题的样例，观察输出，我们可以发现，矩阵的右半部分长这样：
```cpp
              1
            1 1
          1 0 1
        1 1 1 1
      1 0 0 0 1
    1 1 0 0 1 1
  1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
或者长成这样：
```cpp
       1
      1 1
     1 0 1
    1 1 1 1
   1 0 0 0 1
  1 1 0 0 1 1
 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
它的最右边一列是1，其中的每一个元素可以由上方两个数得到  

不难想到DP。二维的
#### 怎么发现的这个呢？
我们联想 [P1002 过河卒](https://www.luogu.org/problemnew/show/P1002)这道题 ，它的每一个元素由上方相邻两个元素相加得到

而观察这道题的构造，上方两数相同时为1，不同时为0

### 哎，等等，相同为0，不同为1？？

### ~~这不是异或嘛！~~

联想过河卒的方法：我们可以得到方程：  
$$ f[i][j]=f[i-1][j] \oplus f[i][j-1] $$ 
然后套上过河卒的模板就行了

~~呆~~代码：
```cpp
#include<bits/stdc++.h>
#define in inline
#define reg register
#define MAX 20030813
//#define int long long
using namespace std;
namespace qwq{
	in void read(int &o)
	{
		o=0;int w=1;
		char c=getchar();
		while(c<'0'||c>'9')
		{
			if(c=='-')w*=-1;
			c=getchar();
		}
		while(c>='0'&&c<='9')
		{
			o=(o<<3)+(o<<1)+(c^48);
			c=getchar();
		}
		o*=w;
	}
	in void write(int x)
	{
		if(x<0)putchar('-');
		if(x>9)write(x/10);
		putchar(x%10+48);
	}
	in int max(int a,int b){return a>b?a:b;}
	in int min(int a,int b){return a<b?a:b;}
}
using namespace qwq;
int n,f[2050][2050];
signed main()
{
	read(n);int N=2;
	for(reg int i=2;i<=n;++i)N<<=1;
	for(reg int i=0;i<=N;++i)f[i][0]=1;
	for(reg int i=1;i<N;++i)
	{
		for(reg int j=1;j<N;++j)
		{
			f[i][j]=f[i][j-1]^f[i-1][j];
		}
	} 
	for(reg int i=N;i>0;--i)
	{
		for(reg int j=N-1;j>=0;--j)
		{
			write(f[i][j]);
			if(j>0)putchar(' ');//坑！坑！坑！
		}
		puts("");
	}
	return 0;
}

```

---

## 作者：Substitute0329 (赞：3)

## 这道题是一道十分特别非常异常极其经典的深度优先搜索题目，也就是DFS（电风扇，大法师，大丰收，大放送，豆腐丝，大番薯，东方朔，巅峰赛~~逃~~~）
### ~~咳咳，说重点~~
### 对于这道题，我们要知道自己在搜索啥，怎么搜索？
### 嗯~
### 因为我要赦免的是矩阵左上角的一部分，所以，我们就搜索各个矩阵的左上角，用有序数对（x，y）表示。
## 接着，同志们要注意，这点很重要，我们对于下一次的搜索，是要搜索当前矩阵的  ￥$\正右/$￥   ￥$\正下/$￥    ￥$\右下/$￥   的    _**左上角**_  的点
#### 这样，我们大概可以得出一个dfs函数的模型：


```cpp
inline void dfs(x,y,po){  //x,y已经讲过，po是指有序数对(x,y)为左上角的矩阵的边长 
	for()      //循环赦免行数 
		for()  //循环赦免列数 
		.....  //赦免标记
	dfs();     //右下 
	dfs();     //正右 
	dfs();     //正下 
	return ;   //养成好习惯，记得return ; 
}
```


## 重点在于po怎么求？
### 其实我们很容易发现，每个被赦免的矩阵的边长都是2的次方数，如样例中被赦免的矩阵边长有${2^2}$,${2^1}$,${2^0}$。
#### 不难的得到：依次被赦免的矩阵边长是上次被赦免的矩阵的二分之一，而x，y的坐标的变化需要通过与 po 的计算得出
#### 而最初的 po 其实就是 ${2^{n-1}}$
#### 为啥？最初的矩阵的边长是${2^n}$，而此时需要赦免的矩阵边长不难得出,就是${2^{n-1}}$，也就是po
#### 当要搜索当前矩阵的正右矩阵的左上角坐标为（x,y+po）
#### 当要搜索当前矩阵的正下矩阵的左上角坐标为（x+po,y）
#### 当要搜索当前矩阵的右下矩阵的左上角坐标为（x+po,y+po）
## 经过这些分析，可以细化DFS函数:

```cpp
inline void dfs(x,y,po){
    for(register int i=x;i<x+po;i++)
        for(register int j=y;j<y+po;j++)
        mp[i][j]=1;           //我们用 mp 数组来标记这一点上的人是否被赦免。
		                      //当mp[i][j]=1时，此点被赦免，输出0.
                              //反则……（大佬们想得到啦） 
    dfs(x+po,y+po,po/2);
    dfs(x+po,y,po/2);
    dfs(x,y+po,po/2);
    return ;
}
```

## 但是，我们还要多考虑一点，当当前搜索到的有序数对所对应的矩阵，它的边长为${2^1}$时，继续搜索已经没有意义，因为继续搜索出来的矩阵边长只是为${2^0}$，不能继续赦免和搜索，所以，我们只需对当前边长为${2^1}$的矩阵的左上角进行赦免，然后退出搜索就好了。


### 所以，DFS函数又成了这样：

```cpp
inline void dfs(int x,int y,int po){
    if(po==1){        //当前矩阵的边长为2时
        mp[x][y]=1;   //赦免
        return ;
    }
    for(register int i=x;i<x+po;i++)
        for(register int j=y;j<y+po;j++)
        mp[i][j]=1;
    dfs(x+po,y+po,po/2);
    dfs(x+po,y,po/2);
    dfs(x,y+po,po/2);
    return ;
}
```

### 对于求${2^k}$的值，有多种方法，可以用<math.h>库中的函数pow()来求，在这里，可以用滚动数组进行预处理求出${2^k}$的值。

```cpp
inline void work_fir(){
    p[0]=1;
    for(register int i=1;i<=10;i++)
    p[i]=p[i-1]*2;
    return ;
}
```

### 这个滚动数组看似没用太大用处（仅针对此题而言），但是对于其他的知识点却发挥着无限大的作用，如哈希，哈希表，ST表（O(log n)求一个数列或区间最值，神仙算法）……这些玄学知识就等待大佬们去挖掘了。
### 滚动数组的好处就在于提前求出${x^k}$的值，随取随用，十分方便，当使用次数多时，耗时就会特别短，因为它不像pow函数一样，每次使用都要进行一次${x^k}$的计算。

## 说了这么多，是该让大佬们看看我的代码了（~~是该展现真正的技术了！！~~）


```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n;
int p[11];
int mp[1050][1050];
inline void work_fir(){
    p[0]=1;
    for(register int i=1;i<=10;i++)
    p[i]=p[i-1]*2;
    return ;
}
inline void dfs(int x,int y,int po){
    if(po==1){
        mp[x][y]=1;
        return ;
    }
    for(register int i=x;i<x+po;i++)
        for(register int j=y;j<y+po;j++)
        mp[i][j]=1;
    dfs(x+po,y+po,po/2);
    dfs(x+po,y,po/2);
    dfs(x,y+po,po/2);
    return ;
}
int main(){
    work_fir();
    scanf("%d",&n);
    dfs(1,1,p[n-1]);
    for(register int i=1;i<=p[n];i++){
        for(register int j=1;j<=p[n];j++){
            printf("%d ",(mp[i][j]^1));     //1^1=0,0^1=1，
            								//这是十分神奇的位运算，有何咨询问度娘。。
        }
        putchar('\n');
    }
    return 0;
}
```
## Thanks for your watching

---

## 作者：梦里调音 (赞：3)

来个思路简单的！

算法：**找规律+递推**

其实不难发现这个图有如下规律：

	1.关于左上-右下对角线对称（也就是（x,y）(y,x)的数字一样）
    
    2.除左上角的矩阵，其他三个完全一样，且与n-1的矩阵相同
    
于是：

```
#include <bits/stdc++.h>
using namespace std;
int n;
int len[21];
int s[2001][2001];
int main(){
	cin>>n;
	len[0]=1;//边长
	for(int i=1;i<=n;i++)len[i]=len[i-1]*2;
	s[len[n]][len[n]]=1;//从右下开始递推
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=len[i-1];j++)
			for(register int k=1;k<=j;k++)
				s[k][j]=s[j][k]=0;//赦免
		for(register int y=len[n]-len[i-1]+1;y<=len[n];y++){
			for(register int x=len[n]-len[i]+1;x<=len[n]-len[i-1];x++){
				s[x][y]=s[y][x]=s[y][x+len[i-1]];//复制矩阵
			}
		}
	}
	for(register int i=1;i<=len[n];i++){
		for(register int j=1;j<=len[n];j++)
			cout<<s[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```

总结：本题关键是找规律！

---

## 作者：Thomasguo666 (赞：3)

讲一个应该没什么人用的做法：细胞自动机

复杂度是$O((2^n)^2)$，但是写起来会比暴力方便不少。

首先~~通过肉眼观察法~~用数学方法可以得到，这个东西是个类似分形的东西。事实上，这个东西叫**谢尔宾斯基三角形**。

这玩意有很多求法，其中有些很诡异（比如杨辉三角中所有奇数的位置构成谢尔宾斯基三角形），而我要讲的是比较常规的一种做法。

考察一个格子的左上，正上，右上三格，我们可以发现一个递推规律：

如果这三格分别是010，或101，或001，或110，则这格是1

否则这格是0。

然后用递推就可以秒切了。

不过这个性质窝不会证，如果有会的大佬就在评论区~~吊打~~教教我或私信我呗！

```cpp
#include <bits/stdc++.h>
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define in inline
#define re register
using namespace std;
typedef long long ll;
typedef double db;
in int read()
{
    int ans=0,f=1;char c=getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=-1;
    for (;isdigit(c);c=getchar()) ans=(ans<<3)+(ans<<1)+(c^48);
    return ans*f;
}
int f[1500][1500];
int check1(int i,int j)
{
    return ((!f[i-1][j-1]) && (!f[i-1][j+1]) && (f[i-1][j]));
}
int check2(int i,int j)
{
    return ((f[i-1][j-1]) && (f[i-1][j+1]) && !f[i-1][j]);
}
int check3(int i,int j)
{
    return ((!f[i-1][j-1]) && (f[i-1][j+1]) && !f[i-1][j]);
}
int check4(int i,int j)
{
    return (f[i-1][j-1] && !f[i-1][j+1] && f[i-1][j]);
}
int main()
{
    int n=(1<<read());
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            if (i==1) f[i][j]=(j==n);
            else if (j==1) f[i][j]=(i==n);
            else if (j==n) f[i][j]=1;
            else f[i][j]=(check1(i,j)||check2(i,j)||check3(i,j)||check4(i,j));
            cout<<f[i][j]<<' ';
        }
        cout<<endl;
    }
    return 0;
}

```

---
upd:
其实这玩意不算正统的谢什么什么三角形，其实那玩意长这样：

![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=c116873eb251f819f125044ce2b44a76/622762d0f703918f58e83cdf533d269759eec4ee.jpg)

这个图形需要三位的细胞自动机生成。


至于题目中的那个玩意，直接杨辉三角啦！

所以，shorter code：
```cpp
#include <bits/stdc++.h>
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define in inline
#define re register
using namespace std;
typedef long long ll;
typedef double db;
in int read()
{
    int ans=0,f=1;char c=getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=-1;
    for (;isdigit(c);c=getchar()) ans=(ans<<3)+(ans<<1)+(c^48);
    return ans*f;
}
int f[1500][1500];
int main()
{
    int n=(1<<read());
    for (int i=1;i<=n;i++)
    {
        f[i][n+1-i]=1;
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=n-i+2;j<=n;j++)
        {
            if (j==n) f[i][j]=1;
            else f[i][j]=f[i-1][j]^f[i-1][j+1];
        }
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            cout<<f[i][j]<<' ';
        }
        cout<<endl;
    }
    return 0;
}

```




---

## 作者：AmemiyaHaruka5 (赞：3)

这题正解递归，歪解......一堆。

这里介绍一种比较简单的用循环模拟递归的写法。

我们发现给的这个图是自相似图形，（其实是斜过来的谢尔宾斯基三角形有损压缩的结果？）所以我们可以通过一个数组记录一个模式，并将其复制3次，加上左上角的全0正方形构成新的模式，如此迭代生成解。

详见代码：

```
#include <bits/stdc++.h>
using namespace std;

int d[1025][1025];

int pattern[1025][1025] = {{0,0},{0,1}};

int main()
{
    int p;
    cin >> p;
    //核心部分
    for(int i = 1;i <= p;i++)
    {
        int t = pow(2,i - 1);
        for(int j = 1;j <= t;j++)
        {
            for(int k = 1;k <= t;k++)
            {
                d[j][k] = 0;
                d[j + t][k] = d[j][k + t] = d[j + t][k + t] = pattern[j][k];
            }
        }
        for(int j = 1;j <= t * 2;j++)
        {
            for(int k = 1;k <= t * 2;k++)
            {
                pattern[j][k] = d[j][k];
                //printf("%d,%d,%d'\n",j,k,t);
            }
        }
    }
    int s = pow(2,p);
    for(int i = 1;i <= s;i++)
    {
        for(int j = 1;j <= s - 1;j++)
        {
            cout << d[i][j] << " ";
        }
        cout << d[i][s] << endl;
    }
    return 0;
}
```

---

## 作者：传奇英雄 (赞：3)

### 没什么好说的，分成4块，直接递归即可，时间复杂度O(n^2)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bool b[5005][5005];

void f(int x,int y,int z)
{
    int mid=z>>1;
    int m1=x+mid,m2=y+mid;
    for(int i=x;i<m1;i++)
        for(int j=y;j<m2;j++)
            b[i][j]=1;
    if(mid>1)
    {
        f(x,m2,mid);
        f(m1,y,mid);
        f(m1,m2,mid);
    }
}

int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&n);
    n=1<<n;
    f(1,1,n);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
            cout<<(b[i][j]^1)<<' ';
        printf("\n");
    }
    return 0;
}

```


---

## 作者：Ryzen_2990WX (赞：3)

废话不多说，直接上代码：

代码里已经写了注释，慢慢理解。
```cpp
#include <bits/stdc++.h>
#define read(x){			           \
    x=0;				           \
    char c=getchar();			           \
    while(c>='0'&&c<='9'){		           \
        x=(x<<3)+(x<<1)+(c^48);		           \
        c=getchar();			           \
    }                                              \
}
using namespace std;
int n,p[12]={1,2,4,8,16,32,64,128,256,512,1024};   // 列出2的n次方
bool a[1025][1025];                                // 2^10为1024，为了保险起见，设为1025
void bfs(int x,int y,int n)                        // x，y为开始赦免的左上角坐标 n为分出来的正方形长度
{
	int p=n/2;                                 // 因后面经常要使用到n/2，故在此设一个变量减少运算的次数
	for(int i=x;i<x+p;i++)                     // 从x开始到x+n结束
	{
		for(int j=y;j<y+p;j++)             // 从y开始到y+n结束
		{
			a[i][j]=0;		   // 赦免
		}
	 } 
	if(p>1)                                    // 如果还能继续赦免，就继续在另外三格里赦免
	{
		bfs(x+p,y,p);                      // 右上角的正方形
		bfs(x+p,y+p,p);                    // 右下角的正方形
		bfs(x,y+p,p);                      // 左下角的正方形
	}
}
int main()
{
	read(n);                                   // 额...快读嘛，只是比较特别而已
	n=p[n];	                                   // 把n转换为2的n次方
	memset(a,1,sizeof(a));                     // 初始化全设为1
	bfs(0,0,n);                                // 进入赦免阶段
	for(int i=0;i<n;i++)                       // 输出结果应该不用多解释了
	{
		for(int j=0;j<n;j++)
		{
			putchar(a[i][j]+48);       // putchar速度更快
			putchar(' ');
		}
		putchar('\n');
	}
} 
```
额...本人有强迫症，所以琢磨注释怎么对其琢磨了好久，还是...

(PS:谁有办法可以让我摆脱强迫症请在评论里告诉我，~~什么剁手的方法也行~~)

---

## 作者：YuRuiH_ (赞：3)

**这道题看大佬们都打表 直接搜索就可以了！！**

# 具体写法大家看下代码就能看懂 十分简单！！

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <queue>

#define LL long long
#define rg register

using namespace std;

template <class T>
inline void read(T &x)
{
    x=0;
    char c=getchar();
    bool f=0;
    for(;!isdigit(c);c=getchar())
        f^=c=='-';
    for(;isdigit(c);c=getchar())
        x=x*10+(c^48);
    x=f?-x:x;
}

template <class T>
inline void write(T x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    T y=1;
    int len=1;
    for(;y<=x/10;y*=10) ++len;
    for(;len;--len,x%=y,y/=10)
        putchar(x/y+48);
}

int n,now_n;
int a;
int gra[1500][1500];

void dfs(int now,int x,int y)
{
	if(now<1)//边界
		return;
	now/=2;//类似于模拟吧
	for(rg int i=0;i<now;i++)
		for(rg int j=0;j<now;j++)
		{
			gra[x+i][y+j]=1;	
		}
	dfs(now,x+now,y+now);//剩下的三块
	dfs(now,x+now,y);//剩下的三块
	dfs(now,x,y+now);//剩下的三块
}

int main()
{
	read(n);
	a=pow(2,n);
	dfs(a,1,1);
	for(rg int i=1;i<=a;i++)
		for(rg int j=1;j<=a;j++)
		{
        //由于反向搞得 此处要反向输出！！！
			if(gra[i][j]==1)
				cout<<"0"<<" ";
			else
				cout<<"1 ";
			if(j==a)
				cout<<endl;
		}
}
```


---

## 作者：chinaxjh (赞：3)

暴力题，按题意分解成4块处理，分治的思想，具体看代码
```pascal
var
  a:array[0..2000,0..2000] of longint;
  n,k,i,j:longint;
  f:array[1..20] of longint;
procedure fu0(x,y,n:longint);
var
  i,j:longint;
begin
  for i:=x to x+f[n-1]-1 do
   for j:=y to y+f[n-1]-1 do
   a[i,j]:=0;
end;//将一个单位矩阵的人释放
procedure chuli(x,y,n:longint);
begin
  if n=1 then
  begin
    a[x,y]:=0;
    exit;
  end;
  fu0(x,y,n);
  chuli(x,y+f[n-1],n-1);
  chuli(x+f[n-1],y,n-1);
  chuli(x+f[n-1],y+f[n-1],n-1);
end;//分成4块处理
begin
  readln(n);
  k:=1;
  for i:=1 to n do
  begin
  k:=k*2;
   f[i]:=k;
  end;
    for i:=1 to k do
   for j:=1 to k do 
     a[i,j]:=1;//初始化
  chuli(1,1,n);//分治
  for i:=1 to k do
  begin
    for j:=1 to k-1 do write(a[i,j],' ');
    writeln(a[i,k]);
  end;//输出，注意行末空格
end.
```


---

## 作者：SimonSu (赞：2)


通过样列和你聪明的头脑~~（人类智慧？？？）~~可以发现0显然是比1多的

所以我们可以对1赋值

然后可以开始分形了 类似于

[poj 2083 Fractal](http://poj.org/problem?id=2083)

[洛谷 1498 南蛮图腾](https://www.luogu.org/problemnew/show/P1498)

是按照分治思想不断分开治理

因为我太弱了比赛时不能正常使用小脑袋计算，所以运用了闭区间的方式下分。

具体细节与实现见代码

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<queue>
#include<stack>
#include<cmath>
#define LL long long
using namespace std;
inline void read(int &x){
    x=0;int f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();	}
    while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x*=f;
}
int n;
int c[1500][1500];
inline void dfs(int x1,int x2,int y1,int y2)
{
    if(x1==x2&&y1==y2)//二分尽头
    {
        c[x1][y1]=1;
        return;
    }
    //（x2-x1+1）/2 与 （y2-y1+1）/2 均是区间长度 考虑闭区间需要加减1的操作
    dfs(x1+(x2-x1+1)/2,x2,y1,y1+(y2-y1+1)/2-1);
    dfs(x1+(x2-x1+1)/2,x2,y1+(y2-y1+1)/2 ,y2);
    dfs(x1,x1+(x2-x1+1)/2-1,y1+(y2-y1+1)/2 ,y2);
    return ;
}
int main()
{
    read(n);
    n=pow(2,n);
    dfs(1,n,1,n);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            printf("%d ",c[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

欢迎大佬指正


---

## 作者：封禁用户 (赞：2)

### ~~纪念一下第一篇题解~~
看到大佬用分治或递归做，我这个蒟蒻只会暴力......

我们先来看一下输入输出样例。

输入样例#1：

6

输出样例#1：

0 0 0 0 0 0 0 1

0 0 0 0 0 0 1 1

0 0 0 0 0 1 0 1

0 0 0 0 1 1 1 1

0 0 0 1 0 0 0 1

0 0 1 1 0 0 1 1

0 1 0 1 0 1 0 1

1 1 1 1 1 1 1 1

很明显最后一行和最后一列都是1。

但是我们只需要把最后一列设为1就可以了。

为什么不用把最后一行设为1呢？别急，我们接着往下看。

我们还可以发现，除了最后一列，每一个的值都可以用二进制的加法可以算出来。

最后一行也在二进制的加法内，所以我们就没必要重复的设为1。

最后输出矩阵就是答案。

代码如下：
```cpp
#include<bits/stdc++.h>  
using namespace std;
const int N=1024+1;  //2的十次方是1024，我们是从一开始暴力，所以我们还要加上一。
int n;
int a[N][N];  //设定矩阵的大小。

int main()
{
    scanf("%d",&n);
    int maxn=1;
    for(int i=1;i<=n;i++)  //求出矩阵的大小。
      maxn*=2;
    for(int j=1;j<=maxn;j++)  //把最后一列设为1。
      a[j][maxn]=1;
    /*
	二进制的加法是这样的：
	0+0=0  1+0=1  0+1=1  1+1=0
	两个加数加起来的值等于1，那它的结果就是1，否则是0。
	*/ 
    for(int i=2;i<=maxn;i++)  //注意i从2开始，因为第一行除了最后一个是1，其它都是0
     for(int j=1;j<=maxn;j++) 
       if(a[i-1][j]+a[i-1][j+1]==1)  a[i][j]=1;  //这个值的结果等于a[i-1][j]+a[i-1][j+1]
       else  a[i][j]=0;
    for(int i=1;i<=maxn;i++)  //最后输出矩阵。
    {
      for(int j=1;j<=maxn;j++)
        printf("%d ",a[i][j]);
      printf("\n");
    }
    return 0;
}

```


---

## 作者：forlight (赞：2)

这个题目的数据规模比较小（n<=10），那么整个方阵的大小在1024*1024以内，可以通过纯模拟的方法来做

每次将大方阵变成四个小方阵，第一个全部置0，其余方阵递归处理即可

代码如下：

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n,a[1100][1100];//方阵模拟
void fills(int x1,int y1,int x2,int y2){
    for(register int i=x1;i<=x2;++i)
        for(register int j=y1;j<=y2;++j)
            a[i][j]=0;
}//填充函数
void solve(int x1,int y1,int x2,int y2){
    if(x1==x2)return; //递归边界
    int midx=(x1+x2-1)/2;
    int midy=(y1+y2-1)/2;
    fills(x1,y1,midx,midy);
    solve(x1,midy+1,midx,y2);
    solve(midx+1,y1,x2,midy);
    solve(midx+1,midy+1,x2,y2);
}//递归函数
int main()
{
    //输入 
    cin>>n;
    n=1<<n;
    //初始化 
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=n;++j)
            a[i][j]=1;
    //递归处理 
    solve(1,1,n,n);
    //输出 
    for(register int i=1;i<=n;++i){
        for(register int j=1;j<n;++j){
            putchar(a[i][j]+'0');
            putchar(' ');
        }
        putchar(a[i][n]+'0');
        putchar('\n');
    }
    return 0;
}

```


---

## 作者：vv123 (赞：2)

蒟蒻的做法，没有用到递归函数...

可以先把整个正方形四等分，将左上角标记为0.

令t等于正方形的宽度，第一次标记为0的满足

i和j%t < t/2 （在左上角） 

且 i和j %t>0; (排除最右列和最下行）

依次类推，令t=t/2，可以把大正方形继续细分，并筛掉左上角，直到t=2。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
int a[10001][10001];
int main(){
	cin>>n;
	m=pow(2,n);
	t=m;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=1;
	
	
	while(t>=2){
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++){
			if((i%t)<=(t/2)&&(j%t)<=(t/2)&&(i%t)>0&&(j%t)>0) 	a[i][j]=0;
		}
	t=t/2;
	}
	
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
	
        return 0;
	
}
```


---

## 作者：wind_cross (赞：2)

	初看本题——这是个什么东西
	然后——好像有点规律
	最后——这不就是个递归嘛
	但是，如何实现还是个问题，~~还是因为我太菜了~~
	首先想到的就是用数组来储存n的各种情况（因为n最大只有10）
	a[i][j][q]就表示当n为i时，第j行q列战俘的命运
	然后就是递归了
	下面上代码：
```cpp
#include<cstdio>
#include<cctype>//快读头文件
using namespace std;
template <class code>inline code read(const code &a)//一个快的不行的快读
{
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w?-x:x;
}
bool a[11][1500][1500]; //存储数据
int qwq(int z){//计算2的n次方
	int sum=1;
	for(int i=1;i<=z;i++){
		sum*=2;
	}
	return sum;
}
int main()
{
	int n;
	n=read(n);
	int zri=qwq(n);
	a[0][1][1]=1;初始化
	for(int i=1;i<=n;i++){
		for(int j=1,ri=qwq(i);j<=ri;j++){
			for(int q=1;q<=ri;q++){//主体循环
				if(j<=ri/2&&q<=ri/2)a[i][j][q]=0;//这是对左上角战俘的处理，直接设为0
				else if(q<=ri/2)a[i][j][q]=a[i-1][j-ri/2][q];//左下角战俘的处理
				else if(j<=ri/2)a[i][j][q]=a[i-1][j][q-ri/2];//右上角战俘的处理
				else a[i][j][q]=a[i-1][j-ri/2][q-ri/2];//右下角战俘的处理
			}//这是核心代码。通过对小数据的计算，可以发现只有左上角小正方形战俘全部为0，其他三方向直接复制n-1的情况
		}
	} 
	for(int i=1;i<=zri;i++){
		for(int j=1;j<=zri;j++){
			printf("%d ",a[n][i][j]); 
		}
		puts("");
	} //输出语句
	return 0;
}
```
	这份代码空间复杂度较高，但对于多组数据，会有不错的表现
	希望这份代码对大家有帮助！

---

## 作者：HRLYB (赞：2)

~~这是一道模拟题~~（废话）

观察题目，我们容易发现，这道题是不断的把问题分割成子问题，最后得解。那么不妨采用逆向递推的方法，先解决最小的子问题，由此推出大的问题的解。

根据题意，最小的子问题的解如下：

$$0\:\:1$$
$$1 \:\:1$$

而每一次当前问题，它的子问题实际上都具有同样的形式。



------------


------------

如果以上你已经看明白了，请不要提前阅读以下部分。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,now;
int f[1030][1030];
int main(){
	scanf("%d",&n);
	now=1<<1;//位运算，二进制表示左移一位，相当于2的1次方
	f[1][1]=0,f[1][2]=1,f[2][1]=1,f[2][2]=1;
	int t=2;
	while(t<=n){
		now=1<<t;//相当于2的t次方
		t++;
		for(int i=1;i<=now;i++){
			for(int j=1;j<=now;j++){
				if(i>(now>>1)/*相当于now除以2*/&&j>(now>>1))f[i][j]=f[i-(now>>1)][j-(now>>1)];
				else if(i<=(now>>1)&&j>(now>>1))f[i][j]=f[i][j-(now>>1)];
				else if(i>(now>>1)&&j<=(now>>1))f[i][j]=f[i-(now>>1)][j];//模拟，子问题的拓展构成新子问题
			}
		}
		for(int i=1;i<=(now>>1);i++)
			for(int j=1;j<=(now>>1);j++)f[i][j]=0;//原子问题区域清零，构建新子问题
	}
	for(int i=1;i<=now;i++){
		for(int j=1;j<=now;j++)printf("%d ",f[i][j]);
		printf("\n");//输出结果
	}
	return 0;
}
```


---

## 作者：AquaRio (赞：2)

~~本来开始想打表~~  
~~也不知道有没有打表的巨佬~~  
五十分提交了俩边被罚了5分...


------------
其实就是一道模拟题啦   
  
  
主要思路是**构建一个int数组**（bool也行） 然后通过**递归**的方式修改数组的值，输出即可，注意一下边界状态的处理。  
  
具体的解释看代码哦！
# **~~邪教~~代码欣赏**  
```cpp
//ラブライブ！サンシャイン！！ //祈祷一下RP++
#include<bits/stdc++.h>
using namespace std;
int a[1025][1025];
int wx,wy=1;
int n;
int m2(int x){//自己写一个2^n，数据范围比较小不必写快速幂
	int ans=1;
	for(int i=1;i<=n;i++){
		ans*=2;
	}
	return ans;
} 
void work(int xs,int xe,int ys,int ye){
//xs代表起始x轴坐标，xe代表终止时x轴坐标，y同理
	if(xe-xs==1){//如果2x2就直接修改
		a[xe][ye]=1;
		a[xs][ye]=1;
		a[xe][ys]=1;
	}
	else {//递归
		work((xs+xe+1)/2,xe,ys,(ys+ye-1)/2);
		work((xs+xe+1)/2,xe,(ys+ye+1)/2,ye);
		work(xs,(xs+xe-1)/2,(ys+ye+1)/2,ye);
	}
	return;//一个好习惯
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	
	work(1,m2(n),1,m2(n));对1 x 2^n 的格子进行操作
	for(int i=1;i<=m2(n);i++){
		for(int j=1;j<=m2(n);j++)
			cout<<a[i][j]<<" ";
		cout<<endl;//注意格式
	}
	return 0;//一个好习惯
 
}
```

---

## 作者：高way (赞：1)

### 这是一道练习码力的好题
我们看右下角，就会发现右下角是杨辉三角%2

于是我们先做一个杨辉三角。
```
for(i=1;i<q;i++){
  for(j=0;j<=i;j++){
	 if(!j)yanghui[i][j]=1;
	 else yanghui[i][j]=(yanghui[i-1][j-1]+yanghui[i-1][j])%2;
	}
}
```
这里有一个重要的提示：杨辉三角最好取模，否则有可能爆int。

好的，接下来我们要把它旋转135°。

萌新不才，需要一个线性数组辅助。

```
for(i=0;i<q;i++){
  for(j=0;j<=i;j++){
	s[an]=yanghui[i][j]%2;
	an++;
   }
}
```
接下来，蛇形填数。
```
for(j=q-1;j>=0;j--){
   tj=j;
   for(i=q-1;tj<q;i--,tj++) {
      an++;
   }
} 
```
输出不用我讲了吧。

全代码
```
#include <iostream>
using namespace std；
char p[1024][1024]；
char yanghui[1024][1024]； 
char s[1048576]={}；
int main(){
	int i,j,k；
	int n；
	cin>>n；
	int q=1；
	for(i=0；i<n；i++)q<<=1；
	//cout<<q<<endl；system("pause")；
	yanghui[0][0]=1；
	for(i=1；i<q；i++){
		for(j=0；j<=i；j++){
			if(!j)yanghui[i][j]=1；
			else yanghui[i][j]=(yanghui[i-1][j-1]+yanghui[i-1][j])%2；
		}
	}
	int ti,tj；
	int an=0；
	for(i=0；i<q；i++){
		for(j=0；j<=i；j++){
			s[an]=yanghui[i][j]%2；
			an++；
		}
	}
//	for(i=0；i<an；i++)cout<<(int)s[i]<<' '；
	an=0；
	for(j=q-1；j>=0；j--){tj=j；//cout<<"test3"<<endl；
		for(i=q-1；tj<q；i--,tj++) {//cout<<"test4"<<endl；
		//cout<<i<<' '<<tj<<' 'endl；
			p[i][tj]=s[an]；
			an++；
		}
	} 
//	cout<<"test2"<<endl；
	for(i=0；i<q；i++){
		for(j=0；j<q；j++){
			cout<<(int)p[i][j]<<' '；
		}
		cout<<endl；
	}
	return 0；
}
```
QED

---

## 作者：coolbreeze (赞：1)


矩阵需要用到二维数组保存。
#####  ps:"return value 3221225725"是因为数组过大主函数的内存承受不住，需要在主函数外定义（全局）。
## 具体实现：
观察样例图像，联系题目：可以得到几个部分的图像信息及规律：
下文以样例为例：
```
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
### 1：任意矩阵中，除去左上矩阵，其他三份的“形状”（即内部图像）是完全一致的；
### 2：基础的图像为：
```
0 1
1 1
```
### 3：填充图像大小由左上到右下缩小直至边长为1
###### 过程：
###### 1：从左上角（1,1）至（4,4）填充$4^{2}$大小的0.；
###### 2：从（5,5）填充$2^{2}$大小的0至（6,6）;
###### 3：在（7，7）填充$2^{2}$大小的0；（填充边长逐渐缩小，直至填充为$1^1$大小的图像）；
如此得到
```
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1     
1 1 1 1 0 0 1 1
1 1 1 1 0 0 1 1
1 1 1 1 1 1 0 1
1 1 1 1 1 1 1 1
```
#### （ps：慢些看，~~自己写的时候都有点蒙~~打印图像的思维模式还是需要好好掌握的）
   观察发现，右下角$2^2$的小矩阵就是基础图像

   我们可以把右下角已按要求赦免的图像“复制”到该矩阵上方和左方的$2^2$矩阵

   接下来扩大复制范围，将右下角的$4^2$矩阵“复制”到上方及左方同等大小矩阵。

   以此类推，直到填充大小为原来以$2^n$次方为边长的正方形的1/4（填充来源边长为初始边长的1/2）；

#### 样例的“复制”一次的结果：
```
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
1 1 1 1 0 0 0 1
1 1 1 1 0 0 1 1
1 1 1 1 0 1 0 1
1 1 1 1 1 1 1 1
```

如上操作，就可以得到题目要求图像；
#### 分析完毕，得到控制图像生成的两个循环体
1：自左上向右下填充n次内容为0的矩阵，边长由 $2^{n-1}$
逐渐缩小至1。

2：“扫描”右下的 $2^{2}$ 矩阵，将该矩阵内图像向上，左两方向“复制”，随即扩大复制范围边长，直至复制边长扩大到 $2^{n-1}$。

#### 下列AC代码就直接给出了，具体过程在代码里，写了旁批方便阅读。
```cpp
#include<cstdio>
using namespace std;
int jz[1025][1025];
int main(){
	//freopen("smzf.out","w",stdout);
	int n,bc=1; 
	scanf("%d",&n);
	for(int i=1;i<=n;i++)	bc*=2;
	int BC=bc;
	for(int i=1;i<=bc;i++)
		for(int j=1;j<=bc;j++)
			jz[i][j]=1;
	int qsi=0,qsj=0;
	bc=bc/2;//边长的一半,第一次循环坐标终点； 
	int bj=bc,f=BC/2;//bj(同时控制填充0范围)；f（控制填充次数）。
	while(f>=1){ 
		for(int i=qsi;i<=bj;i++){//从起始点(起始点不断变化)开始将0填充在2的f次方为边长的正方形矩阵内； 
			for(int j=qsj;j<=bj;j++){
				jz[i][j]=0;
			}
		}	
		qsi=bj+1;//从填充终点向下走一格； 
		qsj=qsi;//从填充终点向右走一格； 
		f/=2;//填充范围边长缩小； 
		bc/=2; //新填充范围边长； 
		bj+=bc;	// 新填充范围终点点坐标; 			
	}//↑为"填充0"步骤循环体, ↓为"基础图像逐步'复制'过程"循环体； 
	int s=2,x,y;
	for(s=2;s<=BC/2;s*=2)//控制复制次数； 
		for(x=BC-s+1;x<=BC;x++)//从右下角扫描以s为边长的矩阵。 
			for(y=BC-s+1;y<=BC;y++){
				jz[x-s][y]=jz[x][y]; 
				jz[x][y-s]=jz[x-s][y];//←↑粘贴扫描结果
			}
	for(int i=1;i<=BC;i++){
		for(int j=1;j<=BC;j++)
			printf("%d ",jz[i][j]);
		printf("\n");
		}		
	return 0;
}
```
### 总结：

PS:部分采用英文标点请谅解！
#### 看到这里很感谢！话很多，但是很详细！望大家认真的看，初次写题解多多关照！

2020-03-08 简化代码注释


---

## 作者：Kisaragi_77 (赞：1)

### 签到题！

因为格式的问题卡了我将近一个小时和四次提交，毒瘤

### **思路：**

就是一个分治嘛 ！

大力模拟即可

写过线段树的都会做吧

![示意](https://cdn.luogu.com.cn/upload/pic/63746.png)

按题意模拟

**先处理左上角的每一个格子，再递归的处理右上，左下，右下三个块**

**递归出口: $xL =xR , yL=yR$ (矩形退化成点)**

分治的时候类似线段树，处理中点即可

### 代码

```cpp
#include<cstdio>
using namespace std;
int s[5000][5000];
inline void sovle(int xl,int xr,int yl,int yr){
    if(xl==xr &&yl==yr)	return ;					//递归出口
    int xmid =(xl+xr) >>1,ymid =(yl+yr) >>1;
    for(int x=xl;x<=xmid;++x)
        for(int y=yl;y<=ymid;++y)	s[x][y] =1;		//暴力处理左上角
    sovle(xmid+1,xr,yl,ymid);
    sovle(xl,xmid,ymid+1,yr);
    sovle(xmid+1,xr,ymid+1,yr);						//直接分治
}
int main(){
    int n;	scanf("%d",&n);
    n =(2<<(n-1));
    sovle(1,n,1,n);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j)	printf("%d ",!s[i][j]);	//取反输出
        puts("");
    }
}
```

### 复杂度分析

**记  $N =(2^n)^2$**   且 $n_{max} =10$

假设每个点都会被标记一次那么

**复杂度上界为** $O(N)$

显然这是不可能的，远远达不到这个上界

~~那么我们来口胡一个 (以下内容不保证正确性)~~

因为我们左上角是暴力解决的

其他三个块是递归解决的

考虑递推式
$$
T(N) =3*T(N/4) + N/4
$$
根据主定(kou)理(hu)
$$
T(N) \thicksim N^{\frac{log_23}{2}} <O(N)
$$
 ~~实际上有兴趣可以等比求和展开然后求个极限什么的看一看~~

---

## 作者：白厶冯弓吿氵 (赞：1)

## 一道~~简单~~的分治题，用递归就可以实现啦！

### 1.先把大正方形分为四个小正方形。
($1$)设定好大正方形的左上角坐标 $x1,y1$ ,右下角坐标 $x2,y2$ 。

($2$)找出大正方形中四个小正方形的坐标（如下图 $8\times 8$ 的正方形）。

($3$)然后就可以得到

**行与行的中间值：$xmid=(x1+x2)/2$** 

还有

**列与列的中间值：$ymid=(y1+y2)/2$**

### 2.再计算出每个正方形的左上角和右下角坐标
$\color{yellow}\text{左上角正方形：}$

>①左上角坐标：$x1,y1$ 

>②右下角坐标：$xmid,ymid$

$\color{blue}\text{右上角正方形：}$

>①左上角坐标：$x1,ymid+1$ 

>②右下角坐标：$xmid,ymid$

$\color{red}\text{左下角正方形：}$

>①左上角坐标：$xmid+1,y1$ 

>②右下角坐标：$x2,ymid$

$\color{green}\text{右下角正方形：}$

>①左上角坐标：$xmid+1,ymid+1$ 

>②右下角坐标：$x2,y2$

![](https://cdn.luogu.com.cn/upload/pic/63776.png)
### 3.接着就把左上角小正方形全部变为0，再递归其他三个小正方形。
是不是和某SP的完善程序非常相似呢？
## 上代码
详细看注释哦！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1030][1030];
void dfs(int x1,int y1,int x2,int y2)
{
	int xmid=x1+x2>>1;//位移加速，相当于(x1+x2)/2，+的优先级比>>高
	int ymid=y1+y2>>1;//不放心的可以加（），你喜欢就好:)
	for(int i=x1;i<=xmid;i++)
		for(int j=y1;j<=ymid;j++)
			a[i][j]=1;
	if(x2-x1<=2 && y2-y1<=2) return ;//边界条件——2*2正方形
	dfs(x1,ymid+1,xmid,y2);//递归其他三个小正方形
	dfs(xmid+1,y1,x2,ymid);
	dfs(xmid+1,ymid+1,x2,y2);
}
int main()
{
	cin>>n;
	n=(1<<n);//相当于2^n
	dfs(1,1,n,n);//分别是左上角坐标和右下角坐标
	for(int i=1;i<=n;i++)//懒得初始化
	{
		for(int j=1;j<=n;j++)//递归时赦免的标记为1,现在转换一下
			cout<<abs(a[i][j]-1)<<" ";//其实还可以这样写呢：cout<<1-a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```

在中华人民共和国成立70周年之际，中央军委主席、中共中央总书记、国家主席习近平颁布特赦令，彰显法治大国优良风范。

在洛谷月赛来临之际，~~洛谷站长kkksc03决定赦免部分作弊者~~，彰显洛谷社区开放的风气。

---

## 作者：Alarm5854 (赞：1)

这道题明显就是分治，不过我既没有递归函数，也没有太多条件分治，可以先打个表
```
n=1:
0 1
1 1

n=2:
0 0 0 1
0 0 1 1
0 1 0 1
1 1 1 1

n=3:
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
发现了没有，n=2时就是3个n=1加上四个0，所以只要把n=1的状态复制到n=2的其他三个点，再清理左上角就可以了
### 代码如下：
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int brown[1025][1025],n,x=1;//brown就是棕名
    int main()
    {
        scanf("%d",&n);
        brown[1][1]=0,brown[1][2]=brown[2][1]=brown[2][2]=1;//首先定义初始状态
        while(--n)//如果n=1，那么一次也不做
        {
            x<<=1;//相当于x*=2
            for(int i=1;i<=x;i++)
                for(int j=1;j<=x;j++)
                    brown[i+x][j+x]=brown[i][j+x]=brown[i+x][j]=brown[i][j],brown[i][j]=0;
        }
        for(int i=1;i<=x<<1;i++)
        {
            for(int j=1;j<=x<<1;j++)
                printf("%d ",brown[i][j]);
            printf("\n");
        }
        return 0;
    }
```


---

## 作者：邻叔丁基苯酚 (赞：1)

## 思路：题目要求对一直对方阵分割，且每次分割的方式相同，子方阵的规格相同，显然用分治算法解决。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long LL;
LL a[5005][5005];//方阵。为方便，a[i][j]==0表示未赦免，a[i][j]==1表示赦免。
void absolve(LL x1,LL y1,LL x2,LL y2,LL len)//赦免的递归函数。
//(x1,y1)为方阵左上角的坐标，（x2,y2）为方阵右下角的坐标。
{
	for(LL i=x1;i<=(x1+x2)/2;++i)
		for(LL j=y1;j<=(y1+y2)/2;++j)
			a[i][j]=1;
    //方阵左上角的赦免。
	if(len==2){return;}//边界条件。如果是2*2的方阵，终止递归。
	absolve(x1,(y1+y2+1)/2,(x1+x2)/2,y2,len/2);//递归方阵的右上角。
	absolve((x1+x2+1)/2,y1,x2,(y1+y2)/2,len/2);//递归方阵的左下角。
	absolve((x1+x2+1)/2,(y1+y2+1)/2,x2,y2,len/2);//递归方阵的右下角。
}
int main()
{
	LL n,len;
	scanf("%lld",&n);
	len=1<<n;
	absolve(1,1,len,len,len);
	for(LL i=1;i<=len;++i)
	{
		for(LL j=1;j<=len;++j)
		{
			if(a[i][j]==1) printf("0 ");
			else if(a[i][j]==0) printf("1 ");
		}
		printf("\n");
	}
	return 0;
}
```

关于方阵递归参数的转移在草稿纸上算出即可。

---


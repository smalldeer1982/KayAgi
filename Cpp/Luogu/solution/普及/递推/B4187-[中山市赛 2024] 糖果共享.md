# [中山市赛 2024] 糖果共享

## 题目描述

Jimmy 要和其他同学们一起分享老师带来的糖果了！可是，老师不想让同学们这么快就领到糖果，于是决定跟大家玩一个分享糖果的游戏。

老师让 $n$ 个同学们围成一圈坐在一起。接下来，对于第 $i$ 个同学，老师会在第 $t_i$ 秒发给 TA 一份糖果；每次得到糖果之后，第 $i$ 个同学会固定等待 $p_i$ 秒，然后把糖果分给身旁的第 $i + 1$ 个同学（特殊的情况是，第 $n$ 个同学会把糖果分给第 $1$ 个同学）。注意每个同学既可以从老师那里得到糖果，也可以从旁边的同学那里得到糖果，而且老师发的糖果足够多，同学们只要收到了糖果，就一定能将糖果分出去。同学们的分糖果动作非常快，可以认为是不占用时间的。

在参与游戏的同时，Jimmy 很想知道他的几个好朋友们最快什么时候能得到糖果。你能帮帮他吗？

## 说明/提示

### 样例解释 1

以下是游戏开始后，每个时刻发生的事件：

1. 第 $3$ 秒，第 $1$ 个同学领到了老师给的一份糖果；
2. 第 $7$ 秒，第 $1$ 个同学将糖果分给了第 $2$ 个同学（糖果是老师给的）；
3. 第 $8$ 秒，第 $2$ 个同学将糖果分给了第 $3$ 个同学（糖果是第 $1$ 个同学给的）；
4. 第 $10$ 秒，第 $2$ 个同学领到了老师给的一份糖果；
5. 第 $11$ 秒，第 $2$ 个同学将糖果分给了第 $3$ 个同学（糖果是老师给的）；
6. 第 $13$ 秒，第 $3$ 个同学领到了老师给的一份糖果；

可知，第 $2$ 个同学最快在第 $7$ 秒得到了糖果；第 $3$ 个同学最快在第 $8$ 秒得到了糖果。接下来，游戏还会继续下去，同学们还会继续互相分糖果，但是不会再改变 Jimmy 问题的答案了。

### 数据范围

- 对于 $30\%$ 的数据，保证 $1 \leq n, q \leq 5000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, q \leq 2 \times 10^5$，$1 \leq t_i, p_i \leq 10^9$，$1 \leq x_i \leq n$。

## 样例 #1

### 输入

```
3
3 10 13
4 1 5
2
2
3```

### 输出

```
7
8```

## 样例 #2

### 输入

```
4
1 1 1 1
100 100 100 100
3
3
4
1```

### 输出

```
1
1
1```

## 样例 #3

### 输入

```
4
1 2 4 7
1 2 3 4
4
3
3
2
4```

### 输出

```
4
4
2
7```

## 样例 #4

### 输入

```
8
50 22 63 28 91 60 64 27
84 87 78 16 94 36 87 93
8
1
2
3
4
5
6
7
8```

### 输出

```
50
22
63
28
44
60
64
27```

# 题解

## 作者：songge888 (赞：3)

这里提供一个迭代的思路。

### 题意

有 $n$ 个人围成了一圈，第 $i$ 个人会在 $t_i$ 秒获得糖果，在 $p_i$ 秒之后将糖果传递给第 $i+1$ 个人（第 $n$ 个人传递给第 $1$ 个人），有 $q$ 次询问，给你一个 $x$，输出第 $x$ 个人最早在什么时候可以得到糖果。

### 思路

考虑 DP，$dp_i$ 表示第 $i$ 个同学最早获得糖果的时间。

则得到状态转移方程：
$$
dp_i=\min(dp_i,dp_{i-1}+p_{i-1})
$$
写完代码，一提交，WA 了。

考虑这样一组样例：

```cpp
4
100 100 100 1
1 1 1 1
4
1 2 3 4
```

我的输出：

```cpp
2 100 100 1
```

正确输出：

```cPP
2 3 4 1
```

这是因为当前 $i$ 同学的 $dp_i$ 是由 $dp_{i-1}$ 转移而来的，而在单次从左到右遍历中，$dp_{i-1}$ 本身可能还未达到最优值，导致 $dp_i$ 的计算基于一个偏大的 $dp_{i-1}$，最终使得某些同学的最早时间偏大。

可以记录一个 $flag$，如果当前这一轮有最短时间被更新，$flag$ 就更新成 $1$，如果当前这一轮没有更新，那么下一轮也不会更新，$flag$ 设为 $0$，直接退出即可。

**关于时间复杂度：**

理论上如果一次只更新一个位置的话，时间复杂度是 $O(n^2)$ 的，但是这个题的数据只有 $4$ 个测试点需要更新 $2$ 轮，其他都只要更新 $1$ 轮，所以这份代码也是跑的快到飞起，目前是最优解。

### Code

```cpp
#include<bits/stdc++.h>
#define double long double
#define bug cout<<"___songge888___"<<'\n';
using namespace std;
int n;
int t[200010],dp[200010];
int p[200010];
int q;
int flag;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>t[i];
        dp[i]=t[i];
    }
    for(int i=1;i<=n;i++){
        cin>>p[i];
    }
    flag=1;
    while(flag){
        flag=0;
        for(int i=2;i<=n;i++){
            if(dp[i]>dp[i-1]+p[i-1]){
                flag=1;
                dp[i]=dp[i-1]+p[i-1];
            }
        }
        if(dp[1]>dp[n]+p[n]){
            flag=1;
            dp[1]=dp[n]+p[n];
        }
    }
        
    cin>>q;
    while(q--){
        int x;
        cin>>x;
        cout<<dp[x]<<'\n';
    }
    return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/206386291)

---

## 作者：封禁用户 (赞：3)

- 定义 $que$，用于存储需要更新的时间位置。
- 遍历环形数组 $t$ 的每个位置 $i$，对于每个位置 $i$，检查其后继位置的时间是否大于 $t_i+p_i$，并将后继位置加入队列 $que$，以便后续进一步更新。
- 使用队列 $que$ 进行动态更新
  - 每次从队列中取出一个位置 $x$，检查其后继位置是否需要更新。
  - 如果需要更新，则更新后继位置的时间，并将其加入队列，以便后续进一步更新。
 - 这个过程会不断重复，直到队列为空，确保所有需要更新的位置都被更新。
- 输入查询次数 $q$。对于每次查询，输入查询位置 $x$，并输出该位置的时间 $t_{x-1}$。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
long long t[MAXN], p[MAXN], n, q, x;
queue<int> que;//这个就是队列了。
int main() {
    cin>> n;
    for(int i=0;i<n;i++) cin>> t[i];
    for(int i=0;i<n;i++) cin>> p[i];
    for (int i=0;i<n;i++) {
        if(t[(i+1)%n]>t[i]+p[i]) {
            t[(i+1)%n]=t[i]+p[i];//对于每个位置 i，检查其后继位置 (i+1)%n 的时间是否大于 t[i]+p[i]。
            que.push((i+1)% n);//如果满足条件，则更新后继位置的时间为 t[i] + p[i]，并将后继位置加入队列 que，以便后续进一步更新。
        }
    }
    while(!que.empty()) {//队列没空。
        int x=que.front();
        que.pop();//取出位置 x。
        if (t[(x+1)%n]>t[x]+p[x]) {//检查其后继位置 (x+1)%n 是否需要更新。
            t[(x+1)%n]=t[x]+p[x];
            que.push((x+1)%n);//如果需要更新，则更新后继位置的时间，并将其加入队列，以便后续进一步更新。
        }
    }
    cin>> q;
    while (q--) {
        cin>> x;
        cout<<t[x-1]<<endl;//输出该位置的时间 t[x-1]。
    }
    return 0;
}
```

---

## 作者：Sliarae (赞：2)

容易发现“多次询问”的形式是假的，因为数据可以让 $q = n$，然后对每个人都问一次。所以本质上你要对所有人求答案。

设 $f_i$ 表示第 $i$ 个人最早什么时候能拿到糖果，这个就是答案数组。发现转移有两种：

- $f_i \gets t_i$。

- $f_i \gets f_{i - 1} + p_{i - 1}$。

建立图论模型，建立虚拟源点 $0$，由 $0$ 向 $i$ 连长度为 $t_i$ 的有向边，由 $i$ 向 $i + 1$ 连长度为 $p_i$ 的有向边。容易发现 $f_i$ 就是由 $0$ 到 $i$ 的最短路。

注意上述问题是单源最短路的形式，并且边权全部为正，可以用 Dijkstra 算法解决，时间复杂度 $O(n \log n)$。

另外，本题还存在时间复杂度 $O(n)$ 的做法，代码实现同样非常简单。大致思路是倍长数组，直接递归求答案。感兴趣的同学可以自己研究。

```cpp
#include <iostream>
#include <queue>

using namespace std;
using Pii = pair<int, int>;

const int kN = 2e5 + 5;
const int Inf = 1e9;

int n, q;
int f[kN], p[kN];

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	fill(f + 1, f + n + 1, Inf);
	priority_queue<Pii, vector<Pii>, greater<Pii>> Q;
	for (int i = 1, t; i <= n; ++i) 
		cin >> t, Q.push({t, i});
	for (int i = 1; i <= n; ++i) cin >> p[i];
	while (!Q.empty()) {
		Pii tp = Q.top();
		Q.pop();
		int v = tp.first, i = tp.second;
		if (v < f[i]) {
			f[i] = v;
			Q.push({v + p[i], i % n + 1});
		}
	}
	cin >> q;
	for (int i = 1, x; i <= q; ++i)
		cin >> x, cout << f[x] << '\n';
	return 0; 
}
```

---

## 作者：hcy666666114514 (赞：1)

## 思路
看到这个题目，很明显是动态规划。有 $q$ 次询问，考虑预处理。
## 状态设计
$dp[i]$ 表示第 $i$ 个小朋友最快获得糖果的时间。
## 状态转移方程
不难发现，获得糖果的方式只有老师直接给和第 $i-1$ 个同学分。
## 55pts
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
int t[maxn],p[maxn],dp[maxn];
int main(){
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	for(int i=1;i<=n;i++)cin >> t[i];
	for(int i=1;i<=n;i++)cin >> p[i];
	dp[1]=t[1];
	for(int i=2;i<=n;i++){
		dp[i]=min(dp[i-1]+p[i-1],t[i]);
	}
	int q;
	cin >> q;
	for(int i=1;i<=q;i++){
		int x;
		cin >> x;
		cout << dp[x] << '\n'; 
	} 
	return 0;
} 
```
## 错误原因
这份代码是从 $1$ 开始枚举的。因此，如果是第 $n$ 个小朋友获得糖果之后分给他更快的话这个解就是错的。
## 正解
也就是说我们要保证我们第一个枚举的小朋友从老师那里获得的一定比左边的同学分过来要快。因此，我们就确定了枚举顺序。可以从老师第一个发糖果的同学开始，就能确保老师发一定是最快的获得方式。$dp[minid]=t[minid]$ 为边界条件，从 $dp[minid+1]$ 开始枚举。这里要注意 $minid+1$ 要对 $n$ 取模，保证 $minid \leq n$。时间复杂度为 $O(n)$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
int t[maxn],p[maxn],dp[maxn];
int main(){
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	int minn=0x3f3f3f3f,minid=-1;
	for(int i=0;i<n;i++){
		cin >> t[i];
		if(t[i]<minn){
			minn=t[i];
			minid=i;
		}
	}
	for(int i=0;i<n;i++)cin >> p[i];
	dp[minid]=t[minid];
	for(int i=(minid+1)%n,j=1;j<n;i=(i+1)%n,j++){
		dp[i]=min(dp[(i-1+n)%n]+p[(i-1+n)%n],t[i]);
	}
	int q;
	cin >> q;
	for(int i=1;i<=q;i++){
		int x;
		cin >> x;
		cout << dp[x-1] << '\n'; 
	} 
	return 0;
} 
``

---

## 作者：yihang2011 (赞：0)

### [题解：B4187 [中山市赛 2024] 糖果共享](https://www.luogu.com.cn/problem/B4187)

----

~~最短路的题有了个动态规划标签。~~

这篇题解用提升时间复杂度的方法降低了思维难度。

求最早得到糖果的时间，而且糖果会传递，那么一眼最短路，用 Dijsktra 解决。

不用看题，先把 Dijkstra 板子写下来，然后思考建图。

首先，第 $i$ 位同学只能给第 $i + 1$ 位同学传递糖果，需要等待 $p_i$ 单位时间，所以要建一条 $i \rightarrow i + 1$ 的边，边权为 $p_i$。注意不要建 $n \rightarrow n + 1$，而是要建 $n \rightarrow 1$ 形成环。

然后思考分糖果，就是一个老师给所有人分糖果，第 $i$ 位同学会在 $t_i$ 单位时间收到糖果，所以把老师作为点 $0$，连接所有同学。即对于第 $i$ 位同学建一条 $0 \rightarrow i$，边权为 $t_i$ 的边。

建完边之后套板子，注意把 `vis` 数组删了，不需要。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, q;
int t[200010], p[200010];
int d[200010];
vector<pair<int, int>> g[200010];

void dijkstra() {
    struct node {
        int u, w;
        node() {}
        node(int u, int w) : u(u), w(w) {}
        bool operator < (const node &x) const {
            return x.w < w;
        }
    } ; priority_queue<node> q;
    q.push(node(0, d[0] = 0));
    while (!q.empty()) {
        int u = q.top().u;
        q.pop();
        for (auto [v, w] : g[u]) {
            if (d[v] > d[u] + w) {
                d[v] = d[u] + w;
                q.push(node(v, d[v]));
            }
        }
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; cin >> t[i++]);
    for (int i = 1; i <= n; cin >> p[i++]);
    for (int i = 1; i < n; i++) {
        g[0].push_back(make_pair(i, t[i]));
        g[i].push_back(make_pair(i + 1, p[i]));
    }
    g[n].push_back(make_pair(1, p[n]));
    g[0].push_back(make_pair(n, t[n]));
    memset(d, 0x3f, sizeof d);
    dijkstra();
    cin >> q;
    while (q--) {
        int t;
        cin >> t;
        cout << d[t] << endl;
    }
    return 0;
}
```

跑了 4 秒多，应该是最慢解了。

---

## 作者：TJB_LHY (赞：0)

#### 提示

本题解基于[另一篇题解](https://www.luogu.com.cn/article/29pd9z18)，并对其进行优化。

# 思路

我们可以用一个优先队列维护每一个时刻的先后性，从老师那发下来的可以先放进去，如果前面同学传得快在弹掉。因为当一个同学拿到糖果后，那么后面拿到糖果在发出去就没有前面那么快了，所以每个点只用遍历一次，所以复杂度是 $O(n \log n)$ 级别的，完全够用。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
    int t,id;
    bool operator<(const node& a)const{
        return t>a.t;
    }//自定义排序（按时间从小到大）
}u;
int n,t,q,x,p[200005];
priority_queue<node> Q;
int vis[200005];//记录最早分到糖果的时间
int main() {
  	cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>t;
        Q.push({t,i});//老师发下来
    }
    for(int i=1;i<=n;i++)cin>>p[i];
    while(Q.size()){
        u=Q.top();
        Q.pop();
        if(vis[u.id])continue;//已经分到过了，没必要再更新了
        vis[u.id]=u.t;
        Q.push({u.t+p[u.id],(u.id%n)+1});//传给同学
    }
    cin>>q;
    while(q--){
        cin>>x;
        cout<<vis[x]<<'\n';//输出
    }
	return 0;
}
```

#### 对比

[没有优化的代码](https://www.luogu.com.cn/record/208231373) VS [我优化的代码](https://www.luogu.com.cn/record/208231560)，差了 $5ms$，~~作用不大~~。

---

## 作者：2024zcy (赞：0)

~~希望大家除了关注我以外也照顾一下我的大号（2023iostream）。~~



---

本题一眼 dp。

先把状态转移方程贴一下，方便某些只想看思路不想看代码的君子（说的就是你，代码是给审核员看的）。

$dp[i] = \min(dp[i], dp[i - 1] + p[i - 1])$

这里来分享一下我这个题的三个阶段。

1.~~垃圾阶段~~ 初始阶段。

基本上有了代码雏形，但我的粗心不允许我这么快过。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int dp[N], t[N], p[N], q, n, f = 1;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> t[i], dp[i] = t[i];
    for (int i = 0; i < n; i ++ ) cin >> p[i];
    while (f) {
        f = 0;
        for (int i = 0; i < n; i ++ ) if (dp[i] > dp[(i + n - 1) % n] + p[(i + n - 1) % n]) f = 1, dp[i] = dp[(i + n - 1) % n];
    }
    cin >> q;
    while (q -- ) {
        int qustions;
        cin >> qustions;
        cout << dp[qustions + 1] << "\n"; // 从0开始应该-1
    }
    return 0;
}
```

2.~~自信阶段~~ 调试阶段。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int n, t[N], dp[N], p[N], q, f;
int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    for(int i = 0; i < n; i ++ ) cin >> t[i], dp[i] = t[i];
    for(int i = 0; i < n; i ++ ) cin >> p[i];
    f = 1;
    while(f){
        f = 0;
        for(int i = 1; i < n; i ++ ) if(dp[i] > dp[(i + n - 1) % n] + p[(i + n - 1) % n]) f = 1, dp[i] = dp[(i + n - 1) % n] + p[(i + n - 1) % n]; // 循环应该从0开始
    }
    cin >> q;
    while(q -- ) {
        int qustions;
        cin >> qustions;
        cout << dp[qustions - 1] << "\n";
    }
    return 0;
}
```

3.AC。

```cpp
/*
这次好好讲讲
*/
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10; // 开常量
#define int long long
int n, t[N], dp[N], p[N], q, f;
signed main() {
    ios::sync_with_stdio(0), cin.tie(0); // 输入输出优化
    cin >> n; 
    for(int i = 0; i < n; i ++ ) cin >> t[i], dp[i] = t[i]; // 初始化
    for(int i = 0; i < n; i ++ ) cin >> p[i];
    f = 1; // 初始化
    while(f) { // 代表可以优化
        f = 0;
        for(int i = 0; i < n; i ++ ) if(dp[i] > dp[(i + n - 1) % n] + p[(i + n - 1) % n]) f = 1, dp[i] = dp[(i + n - 1) % n] + p[(i + n - 1) % n]; // (i + n - 1) % n 等价于 i - 1（同时i = 0时会跳为n - 1）。如果能优化就优化，如果一直无法优化就结束程序。
    }
    cin >> q;
    while(q -- ) {
        int qustions;
        cin >> qustions;
        cout << dp[qustions - 1] << "\n"; // 输出，记得-1
    }
    return 0;
}
```

---


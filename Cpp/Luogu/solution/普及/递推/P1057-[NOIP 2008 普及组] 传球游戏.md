# [NOIP 2008 普及组] 传球游戏

## 题目描述

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 和 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$，共 $2$ 种。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 20$；
- 对于 $100\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 30$。

2008普及组第三题


## 样例 #1

### 输入

```
3 3```

### 输出

```
2```

# 题解

## 作者：HighPerformanceRobot (赞：555)

#### UPD:2019/7/7 

主要更新了关于DP的讲解，使本文更适合初学者。

#### UPD:2020/2/12

由于似乎有人看不懂表是怎么打出来的，我就~~在咕了几个月之后~~来说明一下。

整理了文章内容，删去了一些无关言论。

~~改变码风~~，调整注释，并添加解法说明。

优化阅读体验，将**过长且不很必要**的代码转移到剪贴板中。~~节约读者滑滚轮时间。~~

### 正文

这道题明眼人都看得出有很多做法，比如搜索、DP等等，似乎还有人用了矩阵乘法。

总而言之，~~彰显出大佬的强大，但~~麻烦且对初学者非常不友好。

像我这种蒟蒻，只会打暴力的BFS。。

解释一下思路：先开一个结构体：

```cpp
struct node
{
	int now,state;		//当前球的位置和传了几次
	node(int a,int b)	//这个是一个函数，可以在结构体队列中方便地进行元素入队，待会会讲到
	{
		now=a,state=b;
	}
};
```

最早我的想法就是，开这样一个队列，将当前球的状态（球传到到第几个人）的往左传和往右传的可能压进队列（特判一下1和n的情况），（当然作为显示传了几次的state要加一）然后扔掉队首元素。

完整代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,i;
long long ans;
struct node
{
	int now,state;			//now是当前球在谁手中，state是球被传了几次
	node(int a,int b)
	{
		now=a,state=b;
	}
};
queue <node> que;
void bfs(int x,int step)
{
	if(step==m)		//步数已经达到了上限
	{
		que.push(node(x,step));
		return;
	}				//特判1
	if(x==1)
	{
		que.push(node(n,step+1));
		que.push(node(2,step+1));
	}
	else if(x==n)	//特判n
	{
		que.push(node(n-1,step+1));
		que.push(node(1,step+1));
	}
	else
	{
		que.push(node(x-1,step+1));
		que.push(node(x+1,step+1));
	}
	return;
}
void all()			//统计函数，就是最后到了步数都达到上限的时候，统计所有球在1位置的情况
{
	while(!que.empty())
	{
		node xy=que.front();
		if(xy.now==1)
			ans++;
		que.pop();
	}
}
int main()
{
//	freopen("ball.in","r",stdin);
//	freopen("ball.out","w",stdout);
	cin>>n>>m;
	que.push(node(1,0));
	while(que.front().state!=m)
	{
		bfs(que.front().now,que.front().state);
		que.pop();
	}
	all();
	cout<<ans<<endl;
	return 0;
}
```

当然，各位dalao都知道，这种做法是不可能AC的。

为什么？（因为这是暴力枚举啊，连剪枝都没有）

来让我们加一个小小的剪枝。

我们可以判断一下，就是当前位置如果连一直往一个方向走都到不了位置1的话，那这个状态也就没用了，可以直接return掉。

贴上剪枝版的BFS中要添加的内容：

```cpp
    if(x-(m-step)>1&&x-(m-step)<n)	//判断是不是到不了位置1
    	return;
```

~~然后，我们输入数据“5  27”的答案是正确的，运行时间从未剪枝的29.65秒缩短到了26秒多~~

所以说，普通的搜索+优化是不可行的。

### 怎么办？

1. 打表！

我第一个想到的方法。

暴力标程都出来了，不打表干嘛呢？~~有时间再去死磕DP正解啊~~

用于打表的程序：[前往剪贴板查看](https://www.luogu.com.cn/paste/ta5bcm4c)

于是，就有了接下来的表：[前往剪贴板查看](https://www.luogu.com.cn/paste/an1o0712)

好了，我们的表已经出来了。提交，AC！

~~（话说洛谷的评测现在似乎每个测评点时间下限从以前的0ms提高到了2ms/3ms？不然打表程序一般情况下怎么可能需要几十ms的时间呢？）~~

2. 高级优化

本来解法2和解法3都是没有的，直接就到DP了。

但是后来我回顾了一下以前做过的一道题：[P1877 音量调节](https://www.luogu.com.cn/problem/P1877)

这是我对该题的题解（已过审）：[P1877](https://www.luogu.com.cn/blog/133720/p1877-post)

（~~宣传博客？算了不管了~~）

在P1877中，本来我的BFS也是过不了的，但是我后来想到一个优化方法，把BFS给过了，在洛谷的环境下用时28ms，也就是平均每个测试点2~3ms，这个已经和我交上去通过的DP程序差不多了（第一次24ms，后面又交了一次，29ms？）。

这个优化方法就是**压缩/合并相同状态**

~~状压DP~~

其实原理很简单：不再是每个状态用一次BFS，而是每一轮传球用一次BFS，在这一次BFS中将所有这轮传的球统一处理，先**全部统计**起来，最后**统一入队**。

这样子的话，我们的队列当中最多**最多也只会有30个元素**，因为每个位置最多会在当前队列中出现一次。这样空间和时间复杂度是不是就降下来了？

[前往剪贴板查看](https://www.luogu.com.cn/paste/)

但是其实如果这么做的话，跟DP就没有本质上的区别了，所以似乎所有的方法最终都指向了DP。

3. 记忆化搜索

记忆化搜索，我们教练是有专门针对这道题讲过的。~~懒得打，由于年代久远又抄不到教练的标程~~，而且我翻了翻题解，已经有别人的记搜过审了。~~oh yeah我可以不放标程了，诸位自行寻找吧~~

4. DP

对于DP新手来说，打DP是一件很痛苦的事情。

有一个技巧（？）：要从找规律开始。

我们可以发现，任何一个位置都只能从左边和右边传过来，那么他只能从他左边和他右边的同学手上接到球，**那球传到他手上的路径数是不是球传到他左边同学的路径数与球传到他右边同学的路径数之和？**

有点绕，但是如果你是想认真学习的人，那么希望你能按下性子，认真理解一下这句话。

这样我们就可以列出我们的方程：


```cpp
f[i][j]=f[i-1][j-1]+f[i-1][j+1]
```

为什么是这样？

让我们用手模拟一下（假设有5个人，传6次球，为了方便理解，我将其做成了一个环）：

![](https://i.loli.net/2019/07/07/5d21a071b972034201.jpg)

在初始情况下，小蛮手中必然有且只有一个球，记为1；

第一轮传球后，小蛮必然将手中的球传给2号或5号同学，于是这两个同学各有1种方式接到球；

第二轮传球后，（如果上一轮小蛮将球传给2号）2号同学必然将球传给小蛮或3号，（如果上一轮小蛮将球传给5号），5号同学必然将球传给小蛮或4号，于是小蛮有2种情况接到球（分别从2号和5号手中）；

第三轮及其后以此类推。

我们据图可以发现，假设初始情况为第0行，小蛮为第1列，则有（从第1行开始）：

```cpp
f[i][j]=f[i-1][j-1]+f[i-1][j+1];
```

只需要特判一下1和n就行了。

贴DP标程：


```cpp
#include<bits/stdc++.h>
using namespace std;
int f[31][31],i,j,m,n;
int main()
{
	cin>>n>>m;
	f[0][1]=1;
	for(int i=1; i<=m; i++)
		for(int j=1; j<=n; j++)
			if(j==1)
				f[i][j]=f[i-1][n]+f[i-1][2];
			else if(j==n)
				f[i][j]=f[i-1][1]+f[i-1][n-1];
			else
				f[i][j]=f[i-1][j-1]+f[i-1][j+1];
	cout<<f[m][1]<<endl;
	return 0;
}
```

最后，告诫大家：

DP是毒瘤，谁打谁知道。

要想不被毒，暴力少不了。

---

## 作者：kunkun127 (赞：5)

## 思路

一道经典的 DP 练习题。

我们令 $f_{i,j}$ 为球传到 $i$ 时传球次数为 $j$ 的方案数。显然根据题意，我们需要找到的是 $f_{1, m}$。

我们从 $1$ 开始，逐次计算每个 $f_{i,j}$ 的值。每次计算，它的值就是 $f_{i-1, j-1}$ 和 $f_{i+1, j-1}$ 的和。球可以从 $i-1$ 号同学传到 $i$ 号同学，也可以从 $i+1$ 号同学传到 $i$ 号同学。

最终输出 $f_{1,m}$ 即可。

## 注意事项

由于游戏围成一个圆圈，因此我们要处理 $i = 1$ 和 $i = n$ 的边界情况。

## 参考代码


```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;

int dp[35][35];

int main()
{
    int n, m; 
    cin >> n >> m;
    dp[1][0] = 1;
    for (int j = 1; j <= m; j++)
    {
        dp[1][j] = dp[2][j - 1] + dp[n][j - 1];
        dp[n][j] = dp[1][j - 1] + dp[n - 1][j - 1];
        for (int i = 2; i < n; i++) dp[i][j] = dp[i - 1][j - 1] + dp[i + 1][j - 1];
    }
    cout << dp[1][m] << endl;
    return 0;
}
```

---

## 作者：ljh0727 (赞：5)

# P1057传球游戏

题目传送门：[题目](https://www.luogu.com.cn/problem/P1057)

### 思路

这道题切入点在于每个同学可以从左或右边同学接球，即当前这**一轮中间**同学可以拿到球的总方法等于**上一轮左**同学的可拿球方法和**上一轮右**同学的可拿球方法的和。

这道题可以用 dp 来做。设 $dp_{i,j}$ 为第 $j$ 次传球传到第 $i$ 个人的方案数，一个球可以从左边传过来 $i-1$，也可以从右边传过来 $i+1$。

所以很容易就可以推出了如下公式。

 $dp_{i,j} = \begin{cases} 1 & i=1,j=0 \\ dp_{n,{j-1}} + dp_{2,{j-1}} & i=1 \\ dp_{1,{j-1}} + dp_{{n-1},{j-1}} & i=n \\ dp_{{i-1},{j-1}} + dp_{{i+1},{j-1}} & otherwise \end{cases}$ 

### 代码


```cpp
#include<iostream>
#include<cstdio>


using namespace std;

int dp[35][35];
 
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
    dp[1][0]=1;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(j==1)
				dp[j][i]+=dp[n][i-1]+dp[2][i-1];
            else if(j==n)
				dp[j][i]+=dp[1][i-1]+dp[n-1][i-1];
            else 
				dp[j][i]+=dp[j-1][i-1]+dp[j+1][i-1];
        }
    }
    printf("%d",dp[1][m]);
    return 0;
}
```

---

## 作者：Idoyt (赞：4)

# 前言
很多题解都是直接给出状态转移方程的，并没有从维度的角度去分析，所以这篇博客是从维度开始分析的。

**Ps：本博客关于维度的分析会借鉴[《全新的动态规划入门——从维度谈起》](http://www.cnblogs.com/WABoss/p/DP.html)中关于维度的内容，在此感谢原作者独具一格的阐述。以下在括号中注明引用的语句，皆处于上述文章
**

# 正题
## 一、维度

维度其实就是允许某种东西自由变化的范围。（引用）

那么对于本体的状态可以是 球从i->j的方案数，因此我们得到了一个维度f[i] (表示从1号到i号的方案数，显然仅仅一维并不能满足我们的需求)

zhw说：当你的DP不能解决现在的问题时，加一个维度就好了，但是能不能过是另一个问题。（大意如此）

但是题干中还有一个限制条件——传球的次数。为了满足我们的需要，我们可以设f[i][j]为球从1->i传球次数为j次的方案数。

因此，我们关于解决本题的所有需求都已经满足了。


## 二、状态转移方程 
### 1.状态

事物具有多个维度，反之多个维度就能共同描述一个事物，而多个维度的值就描述了事物的状态。（引用）

由此可知，我们在上文中假设的**f[i][j]**即为我们需要的状态。
### 2.状态的转移

DP的状态的转移一般有两种：递推/我为人人，递归/人人为我(间接引用，原句于北大ACM-ICPC暑期课课件)

众所周知，**递归极容易爆栈**（如果您会手动模拟栈，请无视），所以我们在这里采用一种更为稳妥的方式----**递推**。

下面我们将探究如何递推。

因为i号点在一个环上,所以有点i-1和点i+1可以向点i转移（可以顺时针穿球，也可以逆时针）。

虽然点i-1，i+1向点i的转移有多种方式，但我们在更新i-1和i+1时已经加入了，所以我们可以得到状态转移方程**f[i][j]=f[i-1][j-1][i+1[j-1]**。其中当i==n时i-1=1，当i==1时i+1=n。

至此我们已经解决了问题的根本了。

## 三、枚举的顺序

根据DP的基本定义，我们需要先依次解决传球次数为1，2，3......j的问题

所以我们第一层循环为枚举传球次数。显然，枚举点（人）就需要在第二层循环了。

到这里，全部问题就都解决了。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int f[30][30];
int main()
{
	scanf("%d%d",&n,&m);
	f[1][0]=f[0][1]=1;
	for(int i=1;i<=m;i++)
	{
		f[1][i]=f[n][i-1]+f[2][i-1];
		for(int j=2;j<n;j++)
		 f[j][i]=f[j-1][i-1]+f[j+1][i-1];
		f[n][i]=f[n-1][i-1]+f[1][i-1];
	}
	printf("%d",f[1][m]);
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路：
动态规划的题目，我们可以发现，从任何一个位置都只会从左右两边传过来，所以球传到他手上的路径数等于球传到他左边同学的路径数与球传到他右边同学的路径数之和，那就是 $dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]$，除非 $j$ 是一，或者是 $n$，那才有其它的状态转移方程。

---
### code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 31;
int dp[MAXN][MAXN], n, m;

int main() {
	cin >> n >> m;
	dp[0][1] = 1;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			if (j == 1) dp[i][j] = dp[i - 1][2] + dp[i - 1][n];
			else if (j == n) dp[i][j] = dp[i - 1][1] + dp[i - 1][n - 1];
			else dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
		}
	}
	cout << dp[m][1] << endl;
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

设 $dp_{i,j}$ 表示 $i$ 轮过后 $j$ 号同学拿着球的方案数。为方便用 $0$ 号同学来表示 $n$ 号同学。由每个同学都可以传给左右同学中的任意一个，有转移方程 $dp_{i,j}=dp_{i,(j-1+n)\bmod n}+dp_{i,(j+1)\bmod n}$。其中加上 $n$ 再取模可以防止这个数变为负数。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=32;
int dp[N][N];

int main(){
	int n,m;cin>>n>>m;dp[0][1]=1;
	for(int i=1; i<=m; i++) for(int j=0; j<n; j++) dp[i][j]=dp[i-1][(j-1+n)%n]+dp[i-1][(j+1)%n];
	cout<<dp[m][1];
	return 0;
}
```

当然为节省空间（本题不必须）我们可以用滚动数组再减少一维。因为我们每次状态转移只需要获取上一层的状态，所以我们只用根据存下上一层的状态即可。这一点可以依据当前层的奇偶性来完成。

由于 $i+1$ 与 $i-1$ 奇偶性相同，可以用 $(i+1)\bmod2$ 代替 $(i-1)\bmod2$ 以防止其变为负数。

```cpp
#include<bits/stdc++.h>
using namespace std;

int dp[2][32];

int main(){
	int n,m;cin>>n>>m;dp[0][1]=1;
	for(int i=1; i<=m; i++) for(int j=0; j<n; j++) dp[i%2][j]=dp[(i+1)%2][(j-1+n)%n]+dp[(i+1)%2][(j+1)%n];
	cout<<dp[m%2][1];
	return 0;
}
```

---

## 作者：lucky_Mrzhao (赞：1)

## 思路

从题目中观察可知，这道题的 `n` 和 `m` 都较小，考虑用较为暴力的做法。

因为每一次都只是传给左右两名同学；且前面的决策不会再影响后续决策；同时问题具有最优性，所以考虑动态规划。

假设 $a_{i,j}$ 为传球 $i$ 次，从第 $j$ 名同学处传出的所有方案数，由于围成一个圈，所以 $1$ 号和 $n$ 号是相邻的，故有
$$
a_{i,j} = \begin{cases}
a_{i-1,n} + a_{j-1,j+1} & j=1 \\
a_{i-1,1} + a_{i-1,j-1} & j=n \\
  a_{i-1,j-1} + a_{i-1,j+1} & 1<j<n
\end{cases}
$$

## 代码
```cpp
#include<bits/stdc++.h>
//#pragma GCC opminize(2,3,"Ofast","inline")
using namespace std;
long long a[35][35];
int main(){
	int n,m;
	cin >> n >> m;
	a[0][1] = 1;
	for(int i = 1;i <= m;i++){
		for(int j = 1;j <= n;j++){
			if(j==1) a[i][j] = a[i-1][n] + a[i-1][j+1];
			else if(j==n) a[i][j] = a[i-1][1] + a[i-1][j-1]; 
			else a[i][j] = a[i-1][j-1] + a[i-1][j+1];
			//cout << a[i][j] << " ";
		}
		//cout << endl;
	}
	cout << a[m][1];
	return 0;
}
```

---

## 作者：yanghaoyu123 (赞：1)

# [P1057 [NOIP2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)

## 思路

既然是动规题，那肯定要找规律。
我们可以发现，从任何一个位置都只能从左边和右边传来，那么他只能从他的左边和右边的同学手上接球，所以球传到他手上的路径数等于球传到他左边同学的路径数与球传到他右边同学的路径数之和。

这样，我们就可以列出我们的方程：$dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]$ 这就是这道题的方程。

## Code


```cpp
#include <iostream>
using namespace std;
int dp[35][35];
int main(){
    int n,m;
    cin>>n>>m;
    dp[0][1]=1;
    for (int i=1;i<=m;i++){
        for (int j=1;j<=n;j++){
            if (j==1){
                dp[i][j]=dp[i-1][n]+dp[i-1][2];
            }
            else if (j==n){
                dp[i][j]=dp[i-1][1]+dp[i-1][n-1];
            }
            else{
                dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1];
            }
        }
    }
    cout<<dp[m][1];
    return 0;
}
```

---

## 作者：神一般的世界 (赞：1)

p1057的一般DP解法比较简单

至于做矩阵优化纯粹为了好玩

首先把这张图做成邻接矩阵，然后走几步就自乘几次

```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#define LL long long
using namespace std;
LL n,t,m;
struct Matrix{//谜之矩阵 
    int r,c;
    LL N[35][35];
    void init(int r,int c) {
        this->r=r, this->c=c;
        memset(N,0,sizeof(N));
    }
    Matrix operator*(Matrix& B)const{
        Matrix C;
        C.init(r,B.c);
        for(int i=0;i<C.r;i++)
           for(int j=0;j<C.c;j++)
           {
              for(int k=0;k<c;k++) C.N[i][j] += N[i][k]*B.N[k][j];
           }
        return C;
    }
    Matrix pow(LL p) {
        Matrix tmp=*this;
        Matrix ans;
        ans.init(r,r);
        for(int i=0;i<r;i++) ans.N[i][i]=1;
        while(p) {
            if(p&1) ans=ans*tmp;
            tmp=tmp*tmp;
            p>>=1;
        }
        return ans;
    }
};
Matrix x1,ans;
int main(){
    ios::sync_with_stdio(false);
    scanf("%d%d",&n,&m);
    x1.init(n,n);
    for(int i=0;i<n;i++)x1.N[i][(i+1)%n]=x1.N[i][(i+n-1)%n]=1;
    ans=x1.pow(m);
    printf("%d",ans.N[0][0]);
    return 0;
}
```

---

## 作者：ylzpl (赞：0)

## P1057 [NOIP2008 普及组] 传球游戏
- 定义状态 $dp_{i,j}$ 表示第 $i$ 个人传 $j$ 次到了编号为 $1$ 的人的手里的方案数。
- 求状态转移方程：要么传给左边的人，要么传给右边的人，因此状态转移方程就是两个方案的总和，即：
  $$dp[j][i]=dp[j-1][i-1]+dp[j+1][i-1];$$
- 边界条件：如果 $i=1$，那么 $dp_{j+1,i-1}$ 时 $i$ 就是 $0$，不可行。如果 $j=n$，则 $j+1>n$，因此需要特判。**$dp[1][0]=1$，因为第一个人传 $0$ 次给第一个人只有一种方案。**
  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int a[N],dp[N][N];
int main()
{
	int n,m;
	cin>>n>>m;
	dp[1][0]=1;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(j==1) dp[j][i]=dp[n][i-1]+dp[j+1][i-1];
			else if(j==n) dp[j][i]=dp[j-1][i-1]+dp[1][i-1];
			else dp[j][i]=dp[j-1][i-1]+dp[j+1][i-1];
		}
	}
	cout<<dp[1][m];
	return 0;
}
```

---

## 作者：sjh0626 (赞：0)

## 思路分析
一种简单的线性动规，我们可以知道在第 $1$ 次传球之前，球是小蛮的。

我们可以知道后面其他人第 $i$ 次接到球的可能性是由左右两边的人第 $i-1$ 次的可能性之和。

则我们可以推出动态转移方程：

`dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]`

而 $j = 1$ 时就要变一下，变成：

`dp[i][j]=dp[i-1][n]+dp[i-1][j+1]`

而 $j = n$ 同理。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
#define ll long long
#define PII pair<int,int>
using namespace std;
int n,m,dp[100][100];
int main(){
	cin>>n>>m;
	dp[0][1]=1; //最开始是小蛮的球 
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			if(j==1)dp[i][j]=dp[i-1][j+1]+dp[i-1][n];
			else if(j==n)dp[i][j]=dp[i-1][1]+dp[i-1][j-1];
			else dp[i][j]=dp[i-1][j+1]+dp[i-1][j-1];
		}
	}
	cout<<dp[m][1];
	sjh0626s code;
}
```

---

## 作者：Jerry_zpl (赞：0)

## [  P1057 [NOIP2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)
题目大意：聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 回到小蛮手里的方式有 $1→2→3→1$ 和 $1→3→2→1$，共 $2$ 种。  
我们可以画一张图来模拟传球过程:
![https://cdn.luogu.com.cn/upload/image_hosting/urrd1gy4.png](https://cdn.luogu.com.cn/upload/image_hosting/urrd1gy4.png)
然后可以发现，这就是数字三角形，每个点都可以从左上方和右下方走来。求最大和，所以状态转移方程就是
  $$dp_{i,j}=dp_{i-1,j-1}+dp_{i-1,j+1}$$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1005;
int dp[maxn][maxn];
signed main()
{
	int n,m;
	cin>>n>>m;
	dp[0][1]=1;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(j==1)//边界情况考虑
			{
				dp[i][1]=dp[i-1][2]+dp[i-1][n];
			}
			else if(j==n)//边界情况考虑
			{
				dp[i][n]=dp[i-1][1]+dp[i-1][n-1];
			}
			else
			{
				dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1];
			}
		}
	}
	cout<<dp[m][1];
	return 0;
}
```

---


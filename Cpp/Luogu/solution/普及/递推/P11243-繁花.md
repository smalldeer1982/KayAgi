# 繁花

## 题目背景

[English statement](https://www.luogu.com.cn/problem/U505208). **You must submit your code at the Chinese version of the statement.**

我已经知道，在设置好循环播放时就已经知道，我是在麻痹自己，在逃避问题。

我承认如此，可捞起那些沉于水底的细节时，却一瞬间突然和所有所有真实的心跳共鸣。

那时总想的太少，现在常想得太多，不知所措似荒塘里的绿藻蔓延着。

然而这世间情感太多，小 R 也只能体会更开心和更难过。

## 题目描述

小 R 想对上面的问题进行探究，她想先做一些统计，于是她抽象了这个问题。

小 R 有 $n$ 个未知量 $a_1\dots a_n$，对每个 $1 \leq i < n$，她都比较了 $a_i$ 和 $a_{i+1}$ 并写下了一个字符 $c_i \in \{\texttt <, \texttt >, \texttt =\}$，表示两个未知量之间的比较结果。具体地：

- 若 $c_i = \texttt >$，则 $a_i > a_{i+1}$；
- 若 $c_i = \texttt <$，则 $a_i < a_{i+1}$；
- 否则（$c_i = \texttt =$），表示 $a_i = a_{i+1}$。

小 R 称 $\bm{a_i}$ **比** $\bm{a_j}$ **更开心**，当且仅当对任何 **满足上述 $\bm{n - 1}$ 条约束的** $[a_1, \dots, a_n] \in \mathbb R^n$，都有 $a_i < a_j$。请你帮她数出 $1 \leq i, j \leq n$ 且 $a_i$ 比 $a_j$ 更开心的整数数对 $(i, j)$ 个数。

因为要循环播放，所以有多组数据。

## 说明/提示

### 样例解释

- 对于第一组数据，$a_i$ 比 $a_j$ 开心当且仅当 $1 \leq i < j \leq n$，故共有 $\frac{5\times 4}{2} = 10$ 对合法的 $(i, j)$。
- 对于第二组数据，合法的 $(i, j)$ 分别为：$(1, 2), (1, 3), (4, 2), (4, 3), (4, 5), (4, 6), (4, 7), (5, 7), (6, 7)$，共 $9$ 对。
- 对于其他几组数据，聪明的读者可以自行验证。

### 数据规模与约定

**本题采用捆绑测试和子任务依赖。**

- Subtask 0（0 pts）：样例。
- Subtask 1（10 pts）：$n \leq 8$，$T \leq 8$。
- Subtask 2（20 pts）：$n \leq 5000$，$T \leq 8$。依赖于子任务 $0, 1$。
- Subtask 3（20 pts）：$c_i \neq \texttt =$。
- Subtask 4（50 pts）：无特殊限制。依赖于子任务 $0 \sim 3$。

对于所有数据，保证 $2 \leq n \leq 2\times 10^5$，$1 \leq T \leq 10^4$，$c_i \in \{\texttt <, \texttt >, \texttt =\}$，$\sum n \leq 5\times 10^5$。

## 样例 #1

### 输入

```
5
5
<<<<
7
<=><=<
9
=<<><==<
11
>=<<=>>>=>
13
=><<=<=>=><>
```

### 输出

```
10
9
13
29
25
```

# 题解

## 作者：TLEWA (赞：28)

Upd on 2024/11/11：在 @[小之森夏音](https://www.luogu.com.cn/user/532572) 大佬的帮助下，将代码长度压缩至 92B，结合另一个优化思路压缩至 91B，更新相关讲解。

## 观前提示

本题解主要讲解此题代码的 CodeGolf 思路，代码语言为 Ruby，且对题目本身解法可能介绍较简略，使用了较有特色的正则表达式辅助解决了该题的计数，如你还不会本题的解法，不推荐首先观看本题解。

本题解默认大家理解基本的类 C/C++ 语法，如三目运算符等，以及基本的面向对象逻辑，如我不会解释类似 C++ 中的 `std::string::size()` 的基本使用语法（仅作举例）。

关于 CodeGolf：简单来说 CodeGolf 是在实现指定功能的同时尽量压缩代码长度的运动，**短并不意味着简单**，在更短的空间内塞下同样的功能不会比更长要简单，欢迎大家闲暇之时进行相关活动放松身心。

## 思路解析

先考察只有 `<`，`>` 的情况，发现答案显然是如样例 1 的第一个输入一样，设 $s$ 为原字符串，$S$ 为 $s$ 的最长连续相同子串集合，答案是：

$$$\sum_{i \in S} \frac{siz(i) \times  (siz(i)+1)}{2} $$$

现在考虑加入 `=`。假设我们有一个串 `<=>`，匹配为：
$(1,2),(1,3),(2,4),(3,4)$。

考虑第一个算式和 `=` 连续段的关联，我们发现其实这个东西相当于延长了左右 `<` 与 `>` 的长度，不同的是 `=` 内部不存在这样的贡献。同样以 `<=>` 举例，`<=>` 可以拆成 `<<` 和 `>>`，同时 `=` 被使用了两次。

如何更具体地理解这个东西？我们观察 `<==<` 这个串中贡献：

- 我们发现 `=` 对 `<` 来说，匹配贡献和 `<` 等同，如当 $a_1 < a_2$ 时，只要 $a_2 \le a_3$，对 $a_1$ 的贡献都等同。

- `<` 对 `=` 来说，匹配贡献也类似：当 $a_3 \le a_4$ 时，只要 $a_4 < a_5$，$a_3,a_4$ 对 $a_5$ 的贡献都相同。

- 在连续 `=` 串中，显然无任何贡献。

于是把 `=` 视作通配符，匹配 `<` 和 `>` 连续串，减去内部 `=` 串的内部贡献即可。

## 代码编写

本篇题解的重点！根据上面的思路，我们首先写出一个初版代码（长度 160B）：

```
gets.to_i.times{gets;a=gets;p ['<','>'].map{|i|a.scan(/[#{i}=]*#{i}[#{i}=]*/).map{|j|(n=j.size)*(n+1)/2-j.scan(/=+/).map{|k|(m=k.size)*(m+1)/2}.sum}.sum}.sum}
```

下面来逐步解析一下这个代码里面各个东西的作用：

- `gets.to_i.times{}` 首先读入 $T$，转换成整型，然后通过 Ruby 的 times 方法进行多测的循环解题。

- `gets;a=gets` 我们这个代码并不需要知道字符串的长度，直接读掉就好。然后令变量 $a$ 等于读入的字符串 $s$。

- `['<','>'].map{}` 作用类似于 python 的列表推导式和 C++ 的 for_each 语法（`arr.map{|i|}` 类似于 `for(auto i:arr) {}`，不同的是 `map` 中表达式的值会直接返回，在原列表基础上生成一个新列表），我们遍历 `['<','>']` 这个字符列表中的所有变量，根据列表内的变量生成一个等长的新列表。

- `|i|` 钦定变量 $i$ 迭代字符列表内的值。

- `a.scan(/[#{i}=]*#{i}[#{i}=]*/)` 对 $a$ 应用一个正则表达式（`[#{i}=]*#{i}[#{i}=]*`，大意为找到 `<,>` 中，数量为 $1$ 的当前遍历字符，同时在两侧匹配尽量多的`=` 或当前遍历字符（数量可以为 0）），在代码内的作用是生成仅包含遍历中的 `<`，`>` 之一和 `=` 两种字符的最长连续串，同时判掉仅有 `=` 的串（代码中 `#{i}` 表示在表达式串的这个位置插入变量 $i$，在 python 中也有类似语法）。

- `.map{|j|(n=j.size)*(n+1)/2` 计算解题思路内提到的正贡献。

- `-j.scan(/=+/).map{|k|(m=k.size)*(m+1)/2}.sum` 我们对连续段中用到的 `=` 连续串应用同样的方式计算减去的贡献。

- `.sum` 对于列表求和。

- `p` Ruby 的输出函数之一。

这个东西已经很短了，但是其实这个做法的潜力不止于此！我们真的需要这么多长度去单独处理 `=` 的情况吗？不！沿着这个思路，我们可以一路把代码长度压缩到 120B，目前最短！

我们首先发现其实不需要判掉仅有 `=` 的串，在 160B 代码的内层循环中，这部分多算的贡献会直接被抵消掉，应用这个优化思路简化正则表达式（优化为 `[#{i}=]+`，大意是匹配尽量多的（一个以上）`=` 或当前遍历字符），可以优化到 146B，是我赛时最短的代码（然后就被一个很朴素的 Ruby 代码（133B）打爆了）。

考察一下应用上个改变后两层循环的本质，我们发现所有内层循环的贡献之和实际上只是把所有 `=` 串匹配了两遍，于是我们把减去 `=` 权值的工作移到外层循环（此时正则表达式处理 `=` 时匹配字符集的表达式为 `#{i}=`，生成的字符集为 `==`，被自动去重后正好能匹配上所有最长连续 `=` 串），乘以 $-2$ 的权值即可。

代码变成：

```
gets.to_i.times{gets;a=gets;p ['<','>','='].map{|i|(i=='='?-2:1)*a.scan(/[#{i}=]+/).map{|j|(n=j.size)*(n+1)/2}.sum}.sum}
```

长度 120B。

然后我们发现字符列表 `['<','>','=']` 由于内层循环被提出来了，相应变成了三个元素，开销较大，我们考虑改写成另一种形式 `"<>=".chars`，节省 2B。以及我们可以把里面计算贡献的 `(n=j.size)*(n+1)/2` 拆成两部分，除法放在外面避免括号的 2B 额外开销，接着我们发现，改写成字符串再转换为字符数组的形式还有额外的好处，我们不用在 `p` 函数后面加一个空格，Ruby 也可以正常解析我们的代码了，于是再节省 1B。

接着我们翻遍语言特性，发现我们忽略了[一个语法糖](https://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-sum)，然后我们根据这个东西把所有 `map{}.sum` 缩写为 `sum{}` 即可压缩到 107B（对于 `sum` 方法支持这种语法，但是对于 `max`，`min` 等方法是不支持的，请注意）。

代码：

```
gets.to_i.times{gets;a=gets;p"<>=".chars.sum{|i|(i=='='?-2:1)*a.scan(/[#{i}=]+/).sum{|j|(n=j.size)*n+n}/2}}
```

接下来，我们就要应用一些更魔怔的压行思路了！`"<>=".chars` 这个写法还是太长，我们利用一些不太为人知的写法，再次改写为 `%w(< = >)` 或 `[*?<..?>]`，可以节省 2B，但是 `p` 后面的空格没法再压于是只能增加 1B，整体长度仍减少。

我们发现我们显式声明循环变量名称还是有点太长了！（`|i|`，开销至少 3B）我们不妨使用在 Ruby 2.7 引入的一项功能（[但是在 tio.run 的古旧版本下甚至不被支持](https://tio.run/##KypNqvz/P9pQx0jHOFYvN7GgukAh3rD2/38A)），用 `_1` 代替我们显式声明的循环变量吧！可惜的是，其对嵌套循环支持不是很好，我们仅压缩了内层循环的 2B 长度。

回到我们对多测的处理，`gets.to_i.times` 和两次 `gets` 还是开销太大，我们不妨滥用一下 Ruby 提供给我们的全局变量 `$<`，其能获取到全部输入，于是我们直接操作流，以 2B 的代价和一些其它处理读入所有有用部分的东西：

先以一个 `gets` 读掉最前面不方便在循环内处理的测试用例数量（我们并不需要它的数值，而且因为破坏输入规整性的特性只好以 5B 的巨大开销去处理！），然后使用 `.map` 遍历 `$<`，此时输入的每一行都是我们遍历的一个元素，我们发现提前读掉 $T$ 后我们第一次遍历到的是第一个测试数据的 $n$，我们也不需要。好在这个时候 `$<` 把 $n$ 遍历出来之后读入流同时移动到了下一行。我们直接令 `a=gets`，在读入需要处理的串的同时，`gets` 也会再次使流后移，此时结束本次循环之后 `$<` 刚好直接遍历到下一组测试用例的 $n$，形成循环。这样处理内部的解题代码也不用做读入串合法的额外判断，完美符合我们缩短长度的目的。

具体到代码：

```
gets;$<.map{a=gets;p [*?<..?>].sum{|i|(i=='='?-2:1)*a.scan(/[#{i}=]+/).sum{(n=_1.size)*n+n}/2}}
```

长度 95B。

但是，这份代码的长度仍没有压缩到极限，在 @[小之森夏音](https://www.luogu.com.cn/user/532572) 帮助下，我们将以下几个地方再次压缩：

`[*?<..?>]` 变为 `(?<..?>)`：后者能够再次短下 1B，在这个场景下，范围和数组应当发挥一样的作用，但是在我的在线编辑环境下似乎并不支持后面那种写法。

`'='` 变为 `?=`：我的严重疏忽，单字符字符串在 Ruby 中，除了以 `''` 包裹，也可以在前方加上 `?` 将其转变为字符串。

`.sum{(n=_1.size)*n+n}/2` 变为 `.sum{(1.._1.size).sum}`：思路解析中的算式，本质上是一个简单的等差数列求和，我们为何要通过复杂的求和公式 $O(1)$ 计算和式？直接列出等差数列并求和可以获得更短的长度，同时复杂度瓶颈仍在正则表达式的字符串匹配，复杂度不变。

同时，我有了另一个小优化：再次滥用一下 Ruby 提供的全局变量，我们可以不显式声明 `a=gets`，`gets` 的结果会存储在变量 `$_` 中，直接访问 `$_` 即可省下 1B。

代码最终变为：


```
gets;$<.map{gets;p (?<..?>).sum{|i|(i==?=?-2:1)*$_.scan(/[#{i}=]+/).sum{(1.._1.size).sum}}}
```


长度 91B，时间复杂度 $O(\sum n)$。（最短解收录于[此处](https://www.luogu.com.cn/article/nlbz7z8j)）

---

## 作者：lilong (赞：12)

为了方便思考，以下分析满足条件 $i<j$。对于 $i>j,a_i<a_j$ 的情况，则转化为 $i<j,a_i>a_j$（前后对调）。

先分析 $i<j,a_i<a_j$ 的情况。显然，必须要满足 $a_i \le a_{i + 1} \le a_{i + 2} \le \cdots \le a_j$ 时，才**有可能**产生贡献，否则一定可以构造反例。除此之外，为了保证 $a_i < a_j$，必须至少存在一个 $k \in [i,j)$ 使 $a_k < a_{k+1}$，这样才能产生贡献。$i<j,a_i>a_j$ 的情况同理。于是不难写出 $O(n^2)$ 的做法：


```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int n,c[1000001],ans,flag;
string s;

int main()
{
	int T;
	cin >> T;
	while( T -- )
	{
		cin >> n;
		cin >> s;
		ans = 0;
		for( int i = 1 ; i < n ; i ++ )
		{
			if( s[i - 1] == '>' ) c[i] = 1;
			if( s[i - 1] == '=' ) c[i] = 2;
			if( s[i - 1] == '<' ) c[i] = 3;
		}
		for( int i = 1 ; i <= n ; i ++ )
		{
			flag = 0;
			for( int j = i ; j < n ; j ++ )
			{
				if( c[j] == 1 ) break;
				if( c[j] == 3 ) flag = 1;
				if( flag ) ans ++;
			}
			flag = 0;
			for( int j = i ; j < n ; j ++ )
			{
				if( c[j] == 3 ) break;
				if( c[j] == 1 ) flag = 1;
				if( flag ) ans ++;
			}
		}
		cout << ans << '\n';
	} 
	return 0;
}
```

考虑优化该算法。还是以 $i<j,a_i<a_j$ 的情况为例，固定 $i$ 后，第一个产生贡献的位置应该是第一个 $k$ 使 $a_{k-1} < a_k$，最后一个产生贡献的位置应该是第一个 $l$ 使 $a_l > a_{l+1}$（之后的一定都不合法）。根据上文的分析，在 $[k,l]$ 上都能产生贡献。因此预处理每个位置后的第一个大于号和小于号的位置，再一遍计算贡献即可。

时间复杂度 $O(n)$。


```cpp
#include <iostream>
#include <cstdio>
#define int long long

using namespace std;

int n,c[1000001],f1[1000001],f2[1000001],ans,flag1,flag2,pd1,pd2;
string s;

signed main()
{
	int T;
	cin >> T;
	while( T -- )
	{
		cin >> n;
		cin >> s;
		ans = 0;
		for( int i = 1 ; i < n ; i ++ )
		{
			if( s[i - 1] == '>' ) c[i] = 1;
			if( s[i - 1] == '<' ) c[i] = 2;
			if( s[i - 1] == '=' ) c[i] = 3;
			f1[i] = f2[i] = 0; 
		}
		f1[n] = f2[n] = 0;
		for( int i = n - 1 ; i >= 1 ; i -- )
		{
			f1[i] = f1[i + 1];
			f2[i] = f2[i + 1];
			if( c[i] == 1 )
				f1[i] = i;
			if( c[i] == 2 )
				f2[i] = i;
		}
		for( int i = 1 ; i < n ; i ++ )
		{
			if( f1[i] )
			{
				if( !f2[i] )
					ans += n - f1[i];
				else if( f2[i] > f1[i] )
					ans += f2[i] - f1[i];
			}
			if( f2[i] )
			{
				if( !f1[i] )
					ans += n - f2[i];
				else if( f1[i] > f2[i] )
					ans += f1[i] - f2[i];
			}
		}
		cout << ans << '\n';
	} 
	return 0;
}
```

---

## 作者：Stairs_upon_temple (赞：6)

## 这是一篇图论做法题解

闲话：我看到基本上都是动态规划做法，但我考场上第一时间想到了图论，并且个人认为图论做法更好想到一些，故写此题解。

# 思路

首先，容易知道对于一个点的贡献，可以认为是**一定比该点小**的点的个数，而在这里很容易想到可以从该点连边到比该**直接**点小的点（即题目描述中直接用 $>$ 或 $<$ 连接的点），而题目描述中出现若干的点值可能相等，我们可以将这些点合并为一个点并统计相同的个数，然后整体来乘比该点小的点的个数，这样可以用 $O(n)$ 的复杂度过掉此题。

方便理解，这里给出样例中最后一个的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/4rrzjqlg.png)

# 具体实现

先根据题中给的大小关系建图，**从大的点向小的连边**，**相等则合并**（我用的是并查集，其实也可以用缩点），然后统计子树大小总和，该点的贡献即为该点的数量乘上子树大小总和。

```cpp
/*
g++ -o2 2.cpp -o c -std=c++14
./c

*/

#include<cstdio>

using namespace std;
typedef long long ll;

const int N=5e6+100;
const int M=5e6+100;

char *p1,*p2;
char buf[100];

#define nc() getchar()
// #define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++)

inline void read(int &x){
    x=0;
    char ch=nc();
    while(ch<48 || ch>57){
        ch=nc();
    }
    while(ch>=48 && ch<=57){
        x=(x<<3)+(x<<1)+ch-48;
        ch=nc();
    }
    return ;
}

int tot;
int head[N];
struct edge{
    int x;
    int y;
    int next;
}e[M];

int T;
int n,m;

int siz[N];
int cnt[N];
int son[N];
int fa[N];
int in[N];
char s[N];
int vis[N];
ll ans;

inline void init(){
    tot=0;
    for(int i=1;i<=n+10;i++){
        siz[i]=0;
        cnt[i]=1;
        head[i]=-1;
        fa[i]=i;
        vis[i]=0;
    }
    return ;
}

inline void add(int x,int y){
    e[tot].x=x;
    e[tot].y=y;
    e[tot].next=head[x];
    head[x]=tot++;
    return ;
}

inline int find(int x){
    while(fa[x]^x)
	x=fa[x];
	return x;
}

inline void merge(int x,int y){
    int a=find(x);
    int b=find(y);
    if(a!=b){
        fa[b]=a;
        cnt[a]+=cnt[b];
        cnt[b]=0;
    }
    return ;
}

void dfs(int x,int fa){
    siz[x]=cnt[x];
    for(int i=head[x];~i;i=e[i].next){
        int y=e[i].y;
        if(y==fa)continue;
        if(!vis[y])dfs(y,x);
        siz[x]+=siz[y];
    }
    if(!vis[x]){
        ans+=ll(cnt[x]*(siz[x]-cnt[x]));
        vis[x]=1;
    }
    return ;
}

void debug_build(){
    printf("\n");
    printf("%d\n",tot);
    for(int i=0;i<tot;i++){
        int x=e[i].x;
        int y=e[i].y;
        // int w=e[i].w;
        printf("%d %d\n",x,y);
    }
    printf("\n");
    return ;
}

int main(){
    read(T);
    while(T--){
        ans=0;
        read(n);
        init();
        scanf("%s",s);
        for(int i=1;i<n;i++){
            if(s[i-1]=='='){
                merge(i,i+1);
                vis[i+1]=1;
            }
        }
        for(int i=1;i<n;i++){
            int x=find(i);
            int y=find(i+1);
            if(s[i-1]=='<')add(y,x);
            else if(s[i-1]=='>')add(x,y);
        }
        // debug_build();
        for(int i=1;i<=n;i++){
            printf("%d %d \n",i,fa[i]);
        }
        for(int i=1;i<=n;i++){
            if(!vis[i])dfs(i,0);
        }
        printf("%lld\n",ans);
    }
    return 0;
}


/*
1
13
=><<=<=>=><>

*/
```

---

## 作者：SXqwq (赞：5)

### Description

给定一个长度为 $n-1$ 的字符串 $s$，$s_i\in\{>,<,=\}$。$s_i$ 描述了 $a_i$ 和 $a_{i+1}$ 的大小关系。求有多少对整数数对 $(i,j)$，对于任意满足约束的 $[a_1\dots,a_n]\in\R^n$ 都满足 $a_i<a_j$。

$2\le n\le 2\times 10^5,\sum n\le 5\times 10^5$。

### Analysis

场切了。下面是赛时做法。

计数题。考虑将 `<` 和 `>` 分开处理，因为单独处理 `<` 和单独处理 `>` 方法是相同的，下面以处理 `<` 为例。

首先考虑忽略 `=` 怎么做。字符串 $s$ 一定形如 `<<<><<<><`，即一段连续的 `<` 后有若干个 `>` 分隔。若有 $k$ 个连续的 `<`，会产生 $\dfrac{k
\times(k-1)}{2}$ 的贡献。$20$ 分到手。

再考虑有 `=` 号时，考虑一种最简单的情况，设 $a<b<c$，计算序列 $\{a,a,b,b,b,c,c,c,c\}$ 产生多少贡献，不难发现产生 $2\times 3+2\times 4+3\times 4$ 的贡献。将该结论推广，答案一定形如 $\sum \limits_{1\le i<j\le n}x_i\cdot x_j$。其中 $x_i,x_j$ 为有多少个数连续相等。我们需要快速计算这个式子。

考虑所有 $x_i$ 和的平方。

$$\left(\sum\limits_{i=1}^n x_i\right)^2$$

将其展开得。

$$\left(\sum\limits_{i=1}^nx_i\right)^2=\sum\limits_{i=1}^n x_i^2+2\sum\limits_{1\le i<j\le n}x_i\cdot x_j$$

移项，得。

$$2\sum\limits_{1\le i<j\le n}x_i\cdot x_j=\left(\sum\limits_{i=1}^n x_i\right)^2-\sum\limits_{i=1}^n x_i^2$$

同除以 $2$ 得到目标式。

$$\sum\limits_{1\le i<j\le n}x_i\cdot x_j=\dfrac{1}{2}\left(\left(\sum\limits_{i=1}^n x_i\right)^2-\sum\limits_{i=1}^n x_i^2\right)$$

因此，对于连续相等的数，我们使用并查集缩点，记录每个连通块有多少个相等的数。这一步预处理即可。计算时，维护当前 $\sum x_i$ 和 $\sum x_i^2$，当出现 `>` 时套用公式计算贡献即可。复杂度是线性的。

对于 `>` 贡献的计算同理，见代码。

### Code

```cpp
constexpr int N = 2e5+10;
namespace solution
{
    char opt[N];
    int fa[N];
    int val[N];
    int n;
    int sum1 = 0,sum2 = 0;
    void init(){for(int i=1;i<=n;i++) {fa[i] = i,val[i] = 1;}} // 并查集
    int find(int x){if(fa[x] == x) return x;fa[x] = find(fa[x]);return fa[x];}
    void solve()
    {
        int ans = 0;
        cin>>n;
        cin>>(opt+1);
        init();
        for(int i=n-1;i>=1;i--) // 预处理缩点
        {
            if(opt[i] == '=') 
            {
                int fa_i = find(i),fa_j = find(i+1);
                fa[fa_j] = fa[fa_i];
                val[fa_i] += val[fa_j];
            }
        }
        for(int i=n;i>=0;i--)
        {
            int fa_i = find(i);
            sum1 += val[fa_i],sum2 += val[fa_i]*val[fa_i]; 
            if(!fa_i || (opt[fa_i-1] != '<'))
            {
                ans += (sum1*sum1-sum2)/2; // 计算贡献，下面同理
                sum1 = sum2 = 0;
            }
            i = find(fa_i); //不断跳 father
        }
        for(int i=n;i>=0;i--)
        {
            int fa_i = find(i);
            sum1 += val[fa_i],sum2 += val[fa_i]*val[fa_i];
            if(!fa_i || (opt[fa_i-1] != '>'))
            {
                ans += (sum1*sum1-sum2)/2;
                sum1 = sum2 = 0;
            }
            i = find(fa_i);
        }
        cout<<ans<<"\n";
    }
    void mian()
    {
        int T;
        cin>>T;
        while(T--) solve();
    }
}
```

---

## 作者：Aventurine_stone (赞：4)

## 1. 题目分析
其实这道题并不难，看到有人用图论做，完全是大材小用了。其实这道题只用考虑两种情况就行了。
## 2. 题目做法
- 情况一，等号。  
题目中明确说明只有 $a_i < a_j$ 时才会计数。所以我们可以将相等的两个数合并成一个数，并且用一个数组来记录这个数是由多少个初始的数合并而成的即可。
- 情况二，连续的大于或连续的小于号。  
处理完情况一后，那就只剩情况二了。对于连续的符号，我们线性扫描，用一个值 $t$ 记录在扫到这个数之前的所有连续符号上的数之和。那么每次将答案加上 $t \times a_i$ 即可。
## 3. 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=200010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int T,n;
char c[N];
int a[N],cnt;
ll t1,s;
bool t2;
bool b[N];//0< 1>
int main()
{
	T=read();
	while(T--)
	{
		n=read();
		scanf("%s",c+1);
		cnt=1,a[1]=1;
		for(int i=1;i<n;i++)
		{
			c[i]=='='?a[cnt]++:1;
			c[i]=='<'?b[cnt]=0,a[++cnt]=1:1;
			c[i]=='>'?b[cnt]=1,a[++cnt]=1:1;
		}
		s=0;
		b[n]=b[n-1];
		t1=a[1],t2=b[1];
		for(int i=2;i<=cnt;i++)
		{
			s+=t1*a[i];
			if(b[i]!=t2)
				t1=a[i],t2=b[i];
			else
				t1+=a[i];
		}
		printf("%lld\n",s);
	}
	return 0;
}
```

---

## 作者：yayia0503 (赞：2)

# P11243 繁花
## 题意简述
[题目链接](https://www.luogu.com.cn/problem/P11243)  
题面初看有些蒙，大致意思如下：  
现在有一个有 $n$ 个具体数值未知的数的数列 $a$，给定一字符串 $c$，其中 $c_i \in \{\texttt <, \texttt >, \texttt =\}$，用来表示 $a_i$ 和 $a_{i+1}$ 的大小关系，即：  

- 若 $c_i = \texttt >$，则 $a_i > a_{i+1}$；
- 若 $c_i = \texttt <$，则 $a_i < a_{i+1}$；
- 否则（$c_i = \texttt =$），表示 $a_i = a_{i+1}$。

我们规定，**当 $a_i<a_j$ 时**，我们称 $a_i$ 比 $a_j$ 更开心。  
现在，我们要求求出所有 $1 \leq i, j \leq n$ 且 $a_i$ 比 $a_j$ 更开心的整数数对 $(i, j)$ 个数。  
需要注意的是，**$i,j$ 的大小关系并未做规定**。  
共有 $T$ 组测试数据。
## 分析
由于数列 $a$ 的具体值未知，为了避免因胡乱将数代入导致的错误（大家可以尝试一下），我们这里不为数列 $a$ 中的元素代入具体数值。当然，这题也用不到具体值，解题的关键在于字符串 $c$ 所表示的大小关系。  
因为第一组数据的字符串 $c$ 为 `<<<<`，过于特殊，因此，接下来我们用第二组数据的 `<=><=<` 进行分析。可得如下图。  
  
![图1](https://cdn.luogu.com.cn/upload/image_hosting/urb7ffue.png)  

我们可能下意识的想到一个思路：可以从 $a_1$ 开始，遍历整个数列。对于每个 $a_i$，我们都再从 $a_{i+1}$ 开始，向后遍历整个数列，找到所有**肯定比 $a_i$ 大**的元素，即用 $\texttt <$ 或 $\texttt =$ 连接的元素（用 $\texttt =$ 连接的，当且仅当在其之前有使用 $\texttt <$ 连接的），统计答案。如下图示：

![图2](https://cdn.luogu.com.cn/upload/image_hosting/oqckrpnh.png)  

我们用这种方法，暂且得到了 $7$ 个合法的数对 $(i, j)$，但离样例输出的 $9$ 个仍相差甚远。可以发现，我们这里只考虑到了 $\texttt <$ 的情况，并没有考虑 $\texttt >$ 的情况。同上，在考虑该情况后我们可以得到下图：

![图3](https://cdn.luogu.com.cn/upload/image_hosting/ut2g9psa.png)

和样例答案一样！可以说明这个思路可能是正确的。于是乎愉快地把代码写出来，提交一看：[结果](https://www.luogu.com.cn/record/186590417)。有几个点超时，再加上捆绑测试，导致本就不富裕的得分更加雪上加霜，仅得 $30pts$。  
为什么会这样？分析后我们可以发现，我们做了过多的无用功。用 $\texttt =$ 连接的我们可以视作和先前（或之后）为同一种情况。在先前的处理方法里，我们把这些可以等同看待的也每个都再处理了一遍，再加上本身复杂度就不算优，超时也在情理之中。 
## 改进
换个思路来看，我们希望只遍历一遍字符串就得到答案。那我们来看每个 $c_i$ 对答案的贡献如何。  
注：由于 $\texttt <$ 和 $\texttt >$ 连接的情况几乎相同，接下来我们对于 $\texttt <$ 的情况进行分析，再迁移到 $\texttt >$ 的情况上去。
设对于每个 $c_i$ ，其对于答案的贡献为 $ans_i$。  
1. 当 $c_i= \texttt =$ 时，左右 $a_i$ 和 $a_{i+1}$ 相等，故 $c_i$ 对答案的贡献和 $c_{i-1}$ 的贡献相等，即 $ans_i\gets ans_{i-1}$。
2. 当 $c_i= \texttt <$ 时，其对答案的贡献如何呢？显然的，此时 $c_i$ 肯对会对答案有 $1$ 的贡献。但当 $c_i$ 左侧还有 $\texttt =$ 连接时，情况会有所不同。假设有如下图的一种情况：

![图3](https://cdn.luogu.com.cn/upload/image_hosting/cv60yioe.png)

我们现在正在处理 $c_5$，因为其左侧有 $3$ 个 $\texttt =$，故除了最初的 $c_5$ 对答案的贡献外，还有 $c_5$ 与 $c_2$ 到 $c_4$ 的 $3$ 个贡献。再除此之外，我们发现 $c_1$ 为 $\texttt <$，当忽略之中的 $\texttt =$ 时，我们可以直接看作 $a_1 < a_6$，即又可以加上 $c_1$ 对答案的贡献。显然的，当等于号链左端没有 $\texttt <$ 时，无需考虑这部分贡献。因此，此时 $c_5$ 对答案的贡献为 $ans_5\gets(1+3+ans_1)$。  
从特殊到一般，假设在 $c_i$ 的左侧有 $cnt$ 个 $\texttt =$，此时 $ans_i\gets(1+cnt+ans_{i-cnt-1})$。    
至此，我们将 $c_i = \texttt <$ 的各种情况下对答案的贡献，我们已经讨论完毕。由于 $c_i = \texttt <$ 的情况相同，所以不再单做讨论。  
因此，我们可以只需要遍历一遍字符串 $c$，把各字符对答案的贡献计算出来，并在遍历的过程中把最终答案 $sum$ 算出来。      
假设 $c_i = \texttt <$ 时，对答案的贡献为 $ans1_i$；$c_i = \texttt >$ 时，对答案的贡献为 $ans2_i$。  
故 $sum \gets \sum_{i=1}^{n-1}(ans1_i+ans2_i) $。  
代码如下。
## CODE

```cpp
#include <iostream>
#include <cstring>
using namespace std;
typedef long long ll;//不开long long会爆
int t,n;
string s;
int main()
{
    ios::sync_with_stdio(0);
    cin>>t;
    while(t--)
    {
        cin>>n>>s;
        ll ans1[n+5]={0},ans2[n+5]={0};/*防止因memset导致的超时(血与泪的教训)
            开局部变量，初始化为0*/
        s=' '+s;//将字符串下标向后移一位，之后会使用到i-1，防止越界
        int cnt=0;//统计“=” 个数
        ll sum=0;//最终答案
        for(int i=1;i<s.size();i++)
        {
            if(s[i]=='=')
            {
                ans1[i]=ans1[i-1];
                ans2[i]=ans2[i-1];
                cnt++;//统计等号的数量
            }
            else if(s[i]=='<')
            {
                ans1[i]=1+cnt+ans1[i-cnt-1];
                cnt=0;//等号链结束 记得清空统计
            }
            else
            {
                ans2[i]=1+cnt+ans2[i-cnt-1];
                cnt=0;//等号链结束 记得清空统计
            }
            sum+=ans1[i]+ans2[i];//边算边统计
        }
        cout<<sum<<endl;
    }
    return 0;
}
```

---

## 作者：MnZnOIer (赞：2)

考场上死磕一个半小时打了假算，结果还剩 30 分钟的时候 5 分钟写出正解，导致遗憾落幕。~~菜就多练。~~

### 解题思路
我们先正着统计一遍 `<` 的贡献，再反着统计一遍 `>` 的贡献。我们可以用乘法原理，分讨当前的情况：

1. 对于当前字符为 `<` 的情况，我们直接给贡献加上前面连续的 `<` 或 `=` 个数加一，即对于这个字符后面的数字，前面的所有连续的小于号都可以对这个数字产生贡献。然后清空连续 `=` 的数量。

2. 对于当前字符为 `=` 的情况，我们需要额外统计当前连续 `=` 的个数，然后给贡献加上前面的连续 `<` 号或者 `=` 号个数减去前面连续 `=` 号个数，因为同阶的 `<` 号不能算贡献。

3. 对于当前字符为 `>` 的情况，我们直接清空连续 `=` 数量和连续 `<` 号或 `=` 号的数量即可。

对于 `>` 号的统计，我们直接把大于号和小于号代表的符号取反即可，比较典型的就是异或。一开始，我们令 `<` 为 $1$，`>` 为 $0$，`=` 为 $-1$。$-1\operatorname{xor}1=-2$，所以我们可以认为 `=` 就是 $<0$ 的。$0$ 和 $1\operatorname{xor}1$ 之后就相互取反了。如果不想写的这么复杂，也可以直接在字符串上修改。

### 代码部分
压行码风，不喜勿喷。

```cpp
#include <bits/stdc++.h>
#define int long long//不开 long long 见____。
using namespace std;
const int N = 2e5 + 5;
int t, n, f[N];
int solve ()//统计贡献函数。
{
	int pre = 0, ans = 0, c = 0;
    //pre 记录前面连续 < 或 = 号数量；
    //c 记录前面连续 = 号的数量；
    //ans 记录总贡献。
	for (int i = 0; i < n; ++ i)//统计贡献见上。
	{
		if (f[i] < 0)ans += ++ pre - ++ c;
		else if (f[i])ans += ++ pre, c = 0;
		else c = 0, pre = 0;
	}
	return ans;
}
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> t;
	while (t --)
	{
		cin >> n;
		-- n;
		string s;
		cin >> s;
		for (int i = 0; i < n; ++ i)f[i] = (s[i] == '<' ? 1 : (s[i] == '>' ? 0 : -1));//用 f[i] 表示当前符号表示的数字。
		int ans = solve ();//正着统计贡献。
		for (int i = 0; i < n; ++ i)f[i] ^= 1;//异或把符号取反。
		reverse (f, f + n);//记住，数组也要倒过来，因为是倒着统计贡献的。但是实测不加这一句也能过？（大雾）
		ans += solve ();//统计贡献。
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：MenDaRun (赞：2)

# P11243
## 题目分析
  分析题目，很容易发现，题目实际的意思是，给了我们 $a$ 之间的关系，是要找**一定**满足 $a_i < a_j$ 条件的数对 $(i,j)$ 的数量。   
  我们把解决本题分成两个步骤：
1.   统计所有的有相等关系的 $a$ 的数量，因为这些数字是等效的，所以这些数最后处理的时候能看成一个数，但是等效的数字的数量不能忽略。随后，把问题转化到只剩 $\texttt<$ 或者 $\texttt>$ 的情况，统计去掉等号后的符号，方便我们后续处理，具体步骤稍后介绍。
2.   统计答案，把连续单调递增的情况，根据步骤 $1$ 中处理的相同的数，将他们相乘再相加，具体的操作步骤稍后再说。

### 步骤 $1$
把等号去掉，只保留大于或者小于的情况，能很大程度上简化问题。   
去掉等号很简单，我这里选择了开两个数组，分别记录符号，中间相等的数的数量，以及数组的赋值指针，并定义了一个数 $sum$ ，初始情况下赋值成 $1$。过程描述如下：

1. [初始化] 整数数组 $sav$，字符数组 $savs$，分别用来存放每个大于号或者小于号之间连接的相等的数的数量、每个数之间连接的符号（只能为大于号或者小于号）；$sum$ 存放当前统计的相等的数的个数，默认为 $1$ ，因为符号之间至少也要连接着一个未知数；$cnt\_eq$ 存放数组 $sav$ 的赋值指针，默认为 $1$；$cnt\_gt$ 存放数组 $savs$ 的赋值指针，默认为 $1$；临时变量 $ch$ 记录读入的字符。
2. [读入符号] 读入输入的符号到 $ch$。
3. [判断 $ch$ 是否为 $\texttt=$ ] 如果是，那么令 $sum$ 自增；如果不是，置 $savs[cnt\_gt] \gets ch$，$cnt\_gt \gets cnt\_gt+1$，$sav[cnt\_eq] \gets sum$，$cnt\_eq \gets cnt\_eq + 1$，$sum \gets 1$。
4.  [循环] 循环过程 $2,3$，直到读入完成。
5. [处理剩余没处理的 $sum$ ] 等读入完符号，我们会发现，还有累加的 $sum$ 没有处理，因为最后的一个符号后面还有一个数要处理，置 $savs[cnt\_eq] \gets sum$ 即可。

现在我们得到了两个数组，一个是存放了最后简化的符号数组，一个是存放简化后符号之间连接的数字，例如：
```
<=><=<
```
得到的 $savs$，$sav$ 数组内容分别是是

```
1 2 1 2 1
< > < <
```
因为中间有一个等于号，所以中间有两个相同的数字，这就是数组中 $2$ 的来历，多模拟几次就会体会到其中的思想。

![](https://cdn.luogu.com.cn/upload/image_hosting/mnh6unju.png)

### 步骤 $2$
得到两个数组，我们就要开始处理答案，我们仍然以样例为例子，首先是第一步骤处理过后的两个数组。
```
1 2 1 2 1
< > < <
```
首先第一个小于号之间连接的为 $1$ 和 $2$ 代表，有两个数比小于号左边的一个数要大，因此答案要自增到 $2$。   
继续，第二个等于号之间连接了 $2$ 和 $1$ 代表有两个数比第一个数要大，因为答案自增 $2$，自增到 $4$。
以此类推，直到最后两个连续的小于号，这种情况略微复杂，最后的 $1,2,1$ 代表分别有两个数比一个数要大（分别是 $1,2$ ），有一个数比两个数要大（分别是 $2,1$ ），有一个数比一个数要大（分别是 $1,1$ ），答案要自增 $2 + 2 + 1$ 到 $9$。

用图片解释（可能比较乱），如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/p3fem54m.png)

处理连续大于或者小于的情况，只需要准备一个累加变量，将前面连大于之间的数字相加，然后与当前的数的数量相乘再累加到答案，就是我们需要的答案，对于上面的连小于情况也就是：
$$1 × 2 + ( 1 + 2 ) ×1 = 5$$
可以按照上面的流程多模拟几遍，这里结合我们步骤 $1$ 处理的数组，给出下面的流程描述：
1. [初始化] 定义累加器 $sum$ 求前面连大于或小于之间连接的数量之和；长整型变量答案 $ans$ 记录答案；字符型变量 $last$ 记录上一个检索的符号，初始化为 $savs[1]$，用于判断连续大于或小于以判断是否要需要累加器累加；循环变量 $i$。
2. [循环检索直到 $i$ 到 $cnt\_eq$ (步骤 $1$ 出现的，是最后存放数量数组的末尾指针)]
3. [更新答案] 置 $ans \gets sum × sav[i]$。
4. [判断 $i$ 是否等于 $cnt\_eq$] 如果等于，跳出循环。
5. [判断 $last$ 是否等于 $savs[i]$] 如果等于，置 $sum \gets sum + sav[i]$；否则置 $sum \gets sav[i]$。
6. [赋值] 置 $last \gets savs[i]$，$sav[i] \gets 0$，$savs[i] \gets 0$，以便后续测试点使用，避免使用`memset`【注】。
7. [循环检查] 判断循环是否结束，没有结束返回到 第 $3$ 步
8. [输出答案] 输出 $ans$，置 $ans \gets 0$。

【注】第 $6$ 步选择这样清空数组，是因为再提交代码时，蒟蒻采用`memset`一些数据点会超时，如果采用这种方法清空数组，会节约几百毫秒的时间，详情见 [提交记录](https://www.luogu.com.cn/record/186596496)

## 代码
综合上面的步骤，得到了如下的代码：

```cpp
#include <iostream>
#include <string.h>
#include <cstring>
using namespace std;
const int maxn = 2e5+10;
int t,n;
long long sav[maxn];
char savs[maxn];
long long ans = 0;
int main() {
    ios::sync_with_stdio(false);
    cin >> t;
    while(t--) {
        cin >> n;
        int cnt_eq = 1;
        int cnt_gt = 1;
        long long sum = 1;
        for(int i = 1; i < n; i++) {
            char ch; 
            cin >> ch;
            if(ch == '=') sum++; //统计连等于的数的数量 
            else savs[cnt_gt++] = ch, sav[cnt_eq++] = sum, sum = 1; //如果撞到不是等于号的情况，那么就往下统计更新 
        }
        sav[cnt_eq] = sum; // 处理最后没处理完的sum 
        sum = 0;
        char last = savs[1];
        for(int i = 1; i <= cnt_eq; i++) {
            ans += sum*sav[i]; // 更新答案，让累加器的数量与当前数相乘就是符合条件的数量 
            if(i == cnt_eq) break; //到最后直接退出，因为此时访问存储符号的数组会越界 
            if(last == savs[i]) sum += sav[i];
            else sum = sav[i];
            last = savs[i];
            sav[i] = 0, savs[i] = 0; //清空数组，避免使用 memset 浪费时间 
        }
        cout << ans << endl;
        ans = 0;
    }
    return 0;
}
```

当然，本题也可以不开任何数组就能过，可以结合上面的流程思考如何简化代码，这里蒟蒻把代码也简化了一下，使其不采用数组，以及两次的循环判断，代码如下：


```cpp
#include <iostream>
using namespace std;
int t,n;
long long ans = 0,sum = 1, add = 0;
char last;
int main() {
    ios::sync_with_stdio(false);
    cin >> t;
    while(t--) {
        cin >> n;
        bool signal = false;
        for(int i = 1; i < n; i++) {
            char ch;
            cin >> ch;
            if(ch == '=') sum++;
            else {
                if(!signal) last = ch, signal = true;
                ans += add * sum;
                if(last == ch) add += sum;
                else add = sum;
                last = ch;
                sum = 1;
            }
        }
        ans += add*sum;
        cout << ans << endl;
        ans = 0; sum = 1; add = 0;
    }
    return 0;
}
```

---

## 作者：Claire0918 (赞：0)

我们注意到对于一个数对 $(i, j)$，如果对于任意 $\{a_i\}$ 都有 $a_i > a_j$ 或 $a_i < a_j$，当且仅当 $a_i$ 到 $a_j$ 之间所有的符号中有且仅有一种不等号，即 $c_i$ 到 $c_{j - 1}$ 中有且仅有一种不等号。证明使用不等式的传递性反证不难。

考虑枚举一个 $i$，计算其后面有多少个 $j$ 满足条件。

记 $col1_i$ 为 $\sum_{k = 1}^{i - 1} [c_k = \texttt{<}]$，$col2_i$ 为 $\sum_{k = 1}^{i - 1} [c_k = \texttt{>}]$。我们发现 $(i, j)$ 满足条件当且仅当 $(col1_i < col1_j) \wedge (col2_i = col2_j)$。

设 $pos1$ 表示首个 $col1_i < col1_j$ 的 $j$，$pos2$ 表示首个 $col2_i < col2_j$ 的 $j$。答案即为 $|pos1 - pos2| - 1$。

枚举 $i$，$pos1$ 与 $pos2$ 使用二分处理。时间复杂度 $\mathcal{O}(Tn\log n)$。

Code：
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

const int maxn = 2e5 + 10;

int t, n;
long long res;
int c[maxn], col1[maxn], col2[maxn];

int main(){
    scanf("%d", &t);
    while (t--){
        res = 0;
        scanf("%d", &n);
        getchar();
        for (int i = 2; i <= n; i++){
            char ch = getchar();
            col1[i] = col1[i - 1] + (ch == '<');
            col2[i] = col2[i - 1] + (ch == '>');
        }
        for (int i = 1; i <= n; i++){
            const int pos1 = upper_bound(col1 + 2, col1 + n + 1, col1[i]) - col1, pos2 = upper_bound(col2 + 2, col2 + n + 1, col2[i]) - col2;
            res += abs(pos1 - pos2);
        }
        printf("%lld\n", res);
    }

return 0;
}
```

---

## 作者：枫之都 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P11243)

### 题目含义

每组数据有一个长度为 $n$ 的数列 $A$，给出一个长度为 $n-1$，由 $<$、$=$ 或 $>$ 组成的字符串，表示数列中两个相邻数的大小关系。求对于每一组数据，有多少组 $i<j$，满足 $A_i<A_j$。

### 题目思路

首先想到把相等的数缩为一个数，然后寻找连续的单调递增或递减的子段，分别求每个子段的贡献，然后求和。
对于一个长度为 $k$ 的子段，如果这个子段中没有连续相等的数，很显然，这个子段的贡献是 $\frac{n\times (n-1)}2$。

现在我们考虑子段中有连续相等的数的情况。

对于这个长度为 $k$ 的子段中的第 $i$ 个数，和它相等的数一共有 $m$ 个，那它在这个子段中一共可以形成 $k-m$ 个合法数对，而这 $m$ 个数一共可以形成 $m\times (k-m)$ 个数对。

注意这样计数时每一个数对都被计数了两遍，最后输出时要输出 $\frac{ans}2$。
### others
我们将字符串 $s$ 末尾加上一个和所有符号都不同的字符，从而结束持续到数列末尾的子段，并将其加入计算。

对于每一组数据，尽管使用了两层循环，由于每一个数最多入队一次，因此时间复杂度为 $O(n)$。另外，本做法本质是双指针的变体。

用字符 $c$ 记录当前子段的趋势（单增或单减）。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=uint_fast32_t;
class P11243
{
public:
    class _MyIn
    {
    public:
        using _I=ll;
        static constexpr bool sign=0;
        //#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,BZ,stdin),p1==p2)?EOF:*p1++)
        #ifdef getchar
        static constexpr int BZ=1<<20;
        char buf[BZ],*p1=buf,*p2=buf;
        #endif
        _I operator()()
        {
            _I n=0;
            bool b=0;
            char c=getchar();
            while(c<48||c>57)((sign&&c=='-')?b=1:0),c=getchar();
            while(c>=48&&c<=57)
                n=(n<<1)+(n<<3)+(c^48),c=getchar();
            return b?-n:n;
        }
        _MyIn& operator>>(_I &n){return n=operator()(),(*this);}
        #undef getchar
    }read;
    ll T,n;
    string s;
    int solve()
    {
        n=read();
        cin>>s;
        s+="0";
        ll eq=1,ans=0,sum=0;
        char c=s[0];
        vector<ll> tp;
        for(int i=0;i<n;++i)
        {
            if(s[i]=='=')++eq;
            else
            {
                tp.push_back(eq);
                sum+=eq;
                if(s[i]!=c)
                {
                    for(auto &a:tp)ans+=a*(sum-a);
                    tp.clear();
                    tp.push_back(sum=(s[i-1]=='=')?eq:1);
                    c=s[i];
                }
                eq=1;
            }
        }
        cout<<(ans>>1)<<endl;
        return 0;
    }
    P11243()
    {
        T=read();
        while(T--)solve();
    }
}obj;
int main()
{
    return 0;
}
```

---

## 作者：buowen123 (赞：0)

## 题目大意

对于一个长度为 $n$ 的序列 $a$，可以求出长度为 $n-1$ 的字符串 $s$，满足 $s_{i}$ 为 $a_i$ 与 $a_{i+1}$ 的比较结果（$\texttt{>},\texttt{<},\texttt{=}$）。

现在已经确定字符串 $s$，问有多少组 $(i,j)$ 使得 $a_i < a_j$ 一定成立。

$\sum n \le 5 \times 10 ^ 5$。

## 题目解决

很显然，如果 $(i,j)$ 能够确定严格的大小关系，那么 $a_i < a_j$，$a_j < a_i$ 中必有一个成立（废话）。

先考虑没有 $\texttt{=}$ 的情况。

如果 $s_l\sim s_{r-1}$ 都相等，那么 $a_l \sim a_r$ 就会严格递增或递减。反之，对于 $s_i \neq s_{i+1}$ 的情况，$a_i$ 和 $a_{i + 2}$ 的大小关系不能确定。

所以 $(i,j)$ 符合题意的充要条件就是以下两者之一：
- $i < j$ 且 $s_{i} \sim s_{j-1}$ 均为 $\texttt{<}$。
- $i > j$ 且 $s_{i} \sim s_{j-1}$ 均为 $\texttt{>}$。

不妨提取出 $s$ 的每个**极长**的全相等的连续段。对于 $s_l \sim s_{r-1}$，不难算得其对答案的贡献就是 $C_{r-l+1}^2$。

---

再来考虑等号。不妨将所有相等的数合并为一个“节点”，并画出折线图。例如样例二 $\texttt{<=><=<}$ 的折线图如下所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/tt2ydbbr.png)

其中红点为节点，数字表示这个节点上有多少个数。

于是问题变为：选择两个不在同一节点上的数，且两数所在的节点在同一个单调的连续段上，求方案数。

同样把极长连续段提取出来，如上图中，极长连续段分别为 $[1,2][2,3][3,5]$。

对于同一个连续段，设节点上数的数量分别为 $b_1 \sim b_m$。在第 $i$ 个，第 $j$ 个节点上分别取一个数，有 $b_ib_j$ 种方案。不论单调递增还是递减，根据之前的结论，这里面任何一种都有 $1$ 的贡献。

最后是短暂的 dirty work，简单算一算可以得出贡献为 $\sum_{i=1}^m\sum_{j=i+1}^mb_ib_j=\dfrac{1}{2}[(\sum_{i=1}^mb_i)^2-(\sum_{i=1}^mb_i^2)]$。

把每一段的贡献加起来，计算答案即可。

```cpp
// 考场代码，有注释，勿喷（
const int maxn = 2e5 + 3;
string s, t;
int T, n;
ll tot, a[maxn], res; // a 为题解中的 b
void slv() {
	cin >> n >> s;
	s = " " + s, t = " ", a[1] = tot = 1;
	for (int i = 1; i < n; i++) {
		if (s[i] == '=') a[tot]++;
		else a[++tot] = 1, t += s[i];
	}
	for (int i = 1; i <= tot; i++) {
		if (i == tot || (i != 1 && i != tot && t[i] == t[i - 1])) continue;
		int j = i;
		while (j + 1 <= tot && t[j] == t[i]) j++; //[i,j] 为提取出的连续段
		ll sum = 0;
		for (int k = i; k <= j; k++) sum += a[k], res -= a[k] * a[k];
		res += sum * sum;
	}
	cout << res / 2 << '\n';
	res = 0;
}
```

题外话：在适宜的环境下，绿藻的生长速度可达 $20$ 小时内增长到自身的四倍，在 $5$ 天内可以增长到原本的 $4096$ 倍，$5000$ 天就是 $2.2906 \times 10^{3612}$ 倍，~~出题人是怎么好意思以绿藻自比的？~~

---

## 作者：Camellia2025 (赞：0)

其实就是对于每一个值，它的左边和右边有多少个是小于它的。

因此可以遍历两边，从左至右和从右至左。

我们就只讲从左至右，求一个值它的左边有多少个值一定少于它。

先考虑如下情况 $a < b < c$，发现除了 $a < b$ 和 $b < c$ 还可以用不等式的传递性推出 $a < c$，不难想到用一个累加器 $sum$ 来记录是有多少个小于它的。

再考虑这种情况 $a > b < c$，我们显然只能推出 $b < c$，因此碰到大于号时我们要把 $sum$ 清空。

最后考虑取等 $a < b = c$，显然只能推出 $a < b$ 和 $a < c$，因此碰到等号时要将答案加上上一次非等于号的 $sum$，可以用一个 $res$ 来记录上一次非等于号的 $sum$。

### code


```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
unsigned long long ans, sum, res;
char c[N];

int main() {
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		for (int i = 1; i < n; i++) cin >> c[i];
		res = sum = ans = 0;
		for (int i = 1; i < n; i++)
			if (c[i] == '<') ans += ++sum, res = sum; 
			else if (c[i] == '=') ans += res, sum++;
			else res = sum = 0;
		res = sum = 0;
		for (int i = n - 1; i > 0; i--) 
			if (c[i] == '>') ans += ++sum, res = sum; 
			else if (c[i] == '=') ans += res, sum++;
			else res = sum = 0;
		cout << ans << endl;
	}
	return 0;
}
```

---


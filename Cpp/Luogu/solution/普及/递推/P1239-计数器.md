# 计数器

## 题目描述

一本书的页数为 $n$，页码从 $1$ 开始编起，请你求出全部页码中，用了多少个 $0,1,2\cdots 9$。每个页码不含前导 $0$，如 $n=1234$ 时第 $5$ 页不是 $0005$，只是 $5$。


## 说明/提示

对于 $100\%$ 数据，满足 $1\le n\le 10^9$。

---

$2022.7.4$：新添加三组 $\text{Hack}$ 数据。

## 样例 #1

### 输入

```
11```

### 输出

```
1
4
1
1
1
1
1
1
1
1```

# 题解

## 作者：wjy666 (赞：47)

楼下dalao都是数学方法和数位dp，看的本蒟蒻心慌慌

如果对高级方法难以理解的话，这里提供一种简单方法，虽然效率比dalao们差很多，但是对于本题已经够了

对于每一个数x，可以分为x/10000和x%10000两个部分(也就是前几位和后4位)

那么对于中间很大一段数字，同样的前几位会重复出现一万次，后4位就是0000-9999

所以对于中间这一段，可以枚举前几位，贡献值乘以1万，然后每枚举一个，0-9的出现次数加上4000就是后4位的贡献值

(0000-9999总共4万个数码，每个数码出现次数都相等)

然后前面的1-9999和最后一截 前几位没出现1万次的数暴力算就行了

这份代码绝对容易理解，而且对于这题也是0ms

```cpp
#include<cstdio>
#include<cstring>
#define N 10000
#define For(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
int a[10];
void f(int y){ //计算一个数中每个数码出现次数
    while(y>0) a[y%10]++,y=y/10;
}
int main(){
    int n,x,b[10]={0},y; scanf("%d",&n); x=n/N;
    if (n<10000) For(i,1,n) f(i); //特判n<10000
    else {
        For(i,1,N-1) f(i); //算出前面的1-9999
        For(i,1,x-1){ //算中间一段，方法如上面所述
            memset(b,0,sizeof(b)); y=i;
            while(y>0) b[y%10]++,y=y/10;
            For(j,0,9) a[j]+=b[j]*N;
        }
        For(i,0,9) a[i]+=4000*(x-1); //后4位的贡献值一次性加上，不用一个一个加
        For(i,x*N,n) f(i); //算最后的一些数
    }
    For(i,0,9) printf("%d\n",a[i]); //输出
    return 0;
}
```

---

## 作者：explorerxx (赞：26)

  	本蒟蒻写这道题用了两天半里大概五六个小时。（我太弱了）
    然后这篇题解将写写我经历的沟沟坎坎，详细的分析一下，
   	但是由于它很长，因此一定还有多余的地方，比如说我的
    预处理，可能比较多余。但是我觉得，信息学需要耐心！
    不管是写这道题还是写这个题解，我都花了很长时间。
    
 **我认为写一道题，最好是自己完全写出来，所以我才自己琢磨了很久，虽然仍然很多不美满,但我可以骄傲的说这是我自己的成果（~~蒟蒻蜜汁自满~~）。**
 所以如果想凭自己做出来，不应该害怕时间的问题（当然比赛是需要效率的）。如果想从题解吸取经验，也应该看得仔细才有用。
   
	
   因为我不会什么数位dp，看到算法标签里只有递推，于是我来（~~自信的~~）挑战了，但我这次终于是自己研究了一道黄题，还是小有成就感的（~~蒟蒻蜜汁成就感~~）。		
    然后我看题了，在我的印象里，我研究过譬如100~1000内有多少3这样的问题，所以我感觉这题应该不差多少，于是我一开始按照每个数量级的区间有多少个数字1~9来写，于是自然的错了。
    
   然后我想到这应该从1开始记录到某一个数量级（个，十，百，千对应1，2，3，4级），数字0~9有多少个，我一开始只是隐约觉得0和1~9是不一样的，所以我就想先算出来这个再想后面怎么做吧。
   
   
   首先既然是递推的话，肯定要有边界，因此数量级为1的时候，很显然1~9肯定是只出现了一次。于是我开了一个二维数组，f[i][j]其中i表示数字i，j表示数量级。
	
   然后我用一下代码来给边界赋值。


------------
 
```cpp
	f[0][0]=0;	
	f[0][1]=1;
	for(int i=1;i<=9;i++)
	{
		f[i][1]=1;
		f[i][0]=0;
	}//十以内每个数的数量
```


------------

所以对于后面的每一个数量级，比如1~99，如果把1~9的十位看作0的话，那么可以看到从0~9作十位，每一个数一定会在作为个位出现十次，可以认为是十位的数字控制了个位上数字出现的次数。而如果十位上是某个数的话，比如1作十位，那么10~19，1不仅会作为个位出现1次，也会作为十位出现一次，因此要加上10。这样各个数字会在1~99中出现10+10=20次，那么如果是1~999，在十位上的每个数字会出现多少次？
那就是f[i][2]*10+100;也就是说

f[i][j]=f[i][j-1]*10+10^（j-1）。
为了将这个10^（j-1）方便的运算，我用o[10]来储存，
将o[1]=1;o[2]=10;
	
这样，f[i][j]=f[i][j-1]*10+o[j];

如此，对于每一个数量级内1~9出现了多少次，就可以用如下代码运算。



------------
```cpp
	o[1]=1;
	for(int i=2;i<=10;i++)
	{
		o[i]=o[i-1]*10;
	}//o[i]用来表示在数量级i中，出现了某一个n，要多叠加o[i]个，比如在10^2的数量级中，即1~99中，对于每一个数，都有它作十位的时候，那么除了每十个数的个位它会出现一次，它会作为十位多出现10次，为了叠加方便，o[2]=10,就可以直接叠加上去了。
for(int i=1;i<10;i++)
	{	
		for(int j=1;j<=9;j++)
		{
			f[j][i]=f[j][i-1]*10+o[i];
		}
	}//计算1~9的每个数在某一个数量级中的个数                           
```


------------

接下来，考虑一下0；
0特殊在一个地方，那就是每一次最高位是不会出现0的。
因为我做到这里的时候比较懒，用了一个打表找规律。


------------
```cpp
#include<bits/stdc++.h>
using namespace std;	
int a,b[10]={};
int main()//打表器 
{		
	int n;
	cin>>n;
		int h[10]={};
		for(int i=1;i<=n;i++)
		{
			int m=i;
			while(m>0)
			{	
				int v;
				v=m%10;
				for(int j=0;j<=9;j++)
				{
					if(v==j) h[j]++;
				}
				m=m/10;
			}
		}
	for(int i=1;i<=10;i++)
	{
		cout<<h[0]<<endl;
	}
	return 0;
}
```


------------
发现了0的递推式

f[0][i]=f[0][i-1]+(i-1)* 9* o[i-1];

到了真正使用的时候我才又更深入的思考。
所以说如果这道题只是问某一数量级的0出现次数，其实打表找规律就好。

那么到这时候，我相当于进行了一个预处理。

下一步就是具体的分析了。

对于一个数12345，找到1~12345中各数字出现多少次。
我首先想的是吧10000以前的直接用刚刚的f[i][4]添加给ans[i],然后处理后面的2345。但是这里的调用很麻烦，于是我想到了倒着来处理，从5开始，看看5对答案的贡献，发现它仅仅贡献了0~5这几个数字，每个多一次。那么4呢，贡献给了所有数字f[i][1]*4个结果，（1~40中每个数字先在个位上有一个），对于1~3，它们还作10位，各多出现10次。
所以我想到了，对于1~9的一个处理方式。



------------
```cpp
while(u>0)
	{
		u=u/10;
		c++;
	}
	int l=0,z;//z用来表示当前位数上的数字是几	
	int r[12]={};//r用来补齐某一位上的数出现的次数要加上r。 
	while(k>0)//从最后一位开始数，出现了多少次某一个数字  
	{	
		l++;//表示这是倒数第几位，也相当于多少的数量级，比如l=1时，表示这是个位 
		z=k%10;//用z提取数字的最后一位 
		for(int i=1;i<=9;i++)//先判1~9的数 
		{
			ans[i]=ans[i]+f[i][l-1]*z; 
			if(i<z) 
			{
				ans[i]=ans[i]+o[l];   //如果说在这一位上的数大于i，说明有o[l]个i要作为l位来记录，比如235,210~219中，1会作为十位出现十次，那么就多记录上o[l]个1； 
			}
			if(i==z)
			{
				ans[i]=ans[i]+1+r[l];//比如235，在记录3时，不仅要记录200~229,230的3也算一次，后面的5算5次，总共是1+r次 
			}
		}
		k=k/10;
		r[l+1]=r[l]+z*o[l];//这里可以看到 比如 235，对于3 来说 200~230中可以直接用上面算出来，但是后面的231~235，需要加上5，这里5就用r来记录. 
	}
```


------------
**我的想法都体现在了注释里面。为了不让自己迷糊，我就边写边注释，我觉得这不失是一种在做比较复杂的题（~~对我这种蒟蒻来说~~）的时候的一种好方法。**
	
**最后这个0，令我“深恶痛绝”（~~还是我太弱了~~）
我一开始以为0也可以这样推，但是0太特殊，它在第一位肯定不会有，而在最后一位上又会受前面所有的数控制。**

等到真正思考0的答案时，我才想到了“控制出现”的思路。

比如说110，个位上的0出现的次数，受什么控制？百位上的1，控制了0一定会在10~90的个位一共出现9次，十位上的1，则只控制0在100的个位上会出现一次。那么个位上的0总共出现了9+1 =10 次。

十位上的0呢？

在100~109上出现了十次。
于是我就认为，个位上的0受到前面所有数的控制，而十位上的0受到了自己的控制，因为十位上是1，所以个位十位是0的情况一定出现了，这里和1~9的思想一样 其实还是如果这一位上的数字大于0,0作为这一位的情况已经出现了，那么这时候可以认为这一位上的0受前面更高位的控制。

经过几个数的分析，我做出了一下总结。
对于个位上的0，在数量级十位以上，那么它受控制，十位会控制它有几个，百位控制有几十个，例如320,3控制了它有10~99,100~199,200~299的个位上分别有10个零，3*10-1，因为单个零不计，所以减一就好。2则控制了他从300~320上有3个0。个位本身不控制自己。对于十位来说，百位控制了它的有几十个数，也就是说3，控制了它有100~109,200~209，十位上均有十个0，因为在0~99内十位上没有0，所以就是3*10-10，这时候，它本身就会控制自己了，因为从300~309有多少个十位上的零，取决于十位上的数，当它>=1时，肯定有300~309的十个，如果为零，则受后边数的控制 ，比如说308，那么十位上出现的次数就加上（8+1），即九次。对于最高位三，他肯定不会出现0；

所以说，对于一个四位数abcd来说，a上没有0，d上的零有abc-1个，c上的0有ab0个（c>=1）或者ab0-10+d个（c=0），对于b来说，b上的0有a00个（b>=1）或者cd个.

所以我就做了开了两个数组，一个t[i]表示i位上的0有多少个，一个r[i]表示i位以后的数字是多少。



------------
```cpp
	int t[10]={},s;
	s=n;
	for(int i=c;i>=1;i--)
	{	
		if(i==c)
		{
			t[i]=0;
		} 
		if(i<c&&i!=1)
		{	
			if(s/o[i]>=1)
			{
			t[i]=(n/o[i+1])*o[i];
			}
			if(s/o[i]==0)
			{
				t[i]=(n/o[i+1])*o[i]-o[i]+r[i]+1;
			}
		}
		if(i==1)
		{
			t[i]=n/o[i+1];
		}
		s=s%o[i];
	}//读取每一位上的数字，并且判断其贡献
	for(int i=1;i<=c;i++)
	{
		ans[0]=ans[0]+t[i];
	}
```


------------
到了这里，整个题基本结束了。中间不管是思路还是细节的处理，（因为我很弱）都花了不少时间，但我觉得这是值得的，是一次锻炼（因为我很弱）。

下面是我AC代码。


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10][10];//表示0~9 十个数在每个数量级里的数量
int ans[10]={};
int main()
{	
	int o[11]={};	
	o[1]=1;
	for(int i=2;i<=10;i++)
	{
		o[i]=o[i-1]*10;
	} 
	f[0][0]=0;	
	f[0][1]=1;
	for(int i=1;i<=9;i++)
	{
		f[i][1]=1;
		f[i][0]=0;
	}//十以内每个数的数量
	f[0][2]=9;
	for(int i=1;i<10;i++)
	{	
		for(int j=1;j<=9;j++)
		{
			f[j][i]=f[j][i-1]*10+o[i];
		}
	}//计算1~9的每个数在某一个数量级中的个数 
	f[0][2]=9;
	for(int i=3;i<10;i++)
	{	
		f[0][i]=f[0][i-1]+(i-1)*9*o[i-1];
	}	//计算0在每个数量级里的数量  
	int n;	
	int k;
	cin>>n;
	k=n;
	int u,c=0;
	u=n;
	while(u>0)
	{
		u=u/10;
		c++;
	}
	int l=0,z;	
	int r[12]={};//r用来补齐某一位上的数出现的次数要加上r。 
	while(k>0)//从最后一位开始数，出现了多少次某一个数字  
	{	
		l++;//表示这是倒数第几位，也相当于多少的数量级，比如l=1时，表示这是个位 
		z=k%10;//用z提取数字的最后一位 
		for(int i=1;i<=9;i++)//先判1~9的数 
		{
			ans[i]=ans[i]+f[i][l-1]*z; 
			if(i<z) 
			{
				ans[i]=ans[i]+o[l];   
			}
			if(i==z)
			{
				ans[i]=ans[i]+1+r[l];
			}
		}
		k=k/10;
		r[l+1]=r[l]+z*o[l]; 
	}
	int t[10]={},s;
	s=n;
	for(int i=c;i>=1;i--)
	{	
		if(i==c)
		{
			t[i]=0;
		} 
		if(i<c&&i!=1)
		{	
			if(s/o[i]>=1)
			{
			t[i]=(n/o[i+1])*o[i];
			}
			if(s/o[i]==0)
			{
				t[i]=(n/o[i+1])*o[i]-o[i]+r[i]+1;
			}
		}
		if(i==1)
		{
			t[i]=n/o[i+1];
		}
		s=s%o[i];
		}//读取每一位上的数字
	for(int i=1;i<=c;i++)
	{
		ans[0]=ans[0]+t[i];
	}
	if(c<=2)//数据小的话就直接枚举 
	{
		int h[10]={};
		for(int i=1;i<=n;i++)
		{
			int m=i;
			while(m>0)
			{	
				int v;
				v=m%10;
				for(int j=0;j<=9;j++)
				{
					if(v==j) h[j]++;
				}
				m=m/10;
			}
		}
		for(int i=0;i<=9;i++)
		{
			cout<<h[i]<<endl;
		}
	}
	if(c>=3)
	{
		for(int i=0;i<=9;i++)
	{
		cout<<ans[i]<<endl;
	}
	}
	return 0;
}
 
```


------------
码风较乱，算法很菜。
但是有一点，用这个程序去做p2062（紫题），它问的是区间[a,b]里每个数字出现多少次，所以我就用b中每个数字出现的次数减去a-1中每个数出现的次数，A掉了一道紫题。
这样一来，我做一道黄题的时间，其实也相当于花在了一道紫题上了（仍然不能改变蒟蒻的现实）

本蒟蒻的第一篇题解，还是不够简练，不够熟练，各位大佬见谅轻喷啊~


   
    



---

## 作者：yveh (赞：6)

数位DP。


首先预处理f[i][j][k]表示，有i位，最高位为j的数中，数字k的数量(这里不管数字合不合法，包含前导零)。


后面按照逐位拆分思想去做。


设这个数字有n位，1位到n-1位我们已经预处理出来了，只需要讨论n位的情况。


设当前位为x，这一位从1到x-1我们已经预处理出来了。当前位x的情况，这一位的信息我们是知道的，但是后面就需要讨论了。


每一位这样做，直到最后一位。


注意边界，注意特判。

···
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,sum,pos,p,cnt;
int f[20][10][11]={0};
int ans[20],c[20],bin[20];
void init()
{
    sum=1;
    for (int i=0;i<=9;i++)
        f[1][i][i]=1;
    for (int i=2;i<=15;i++)
    {
        sum=sum*10;
        f[i][0][0]=f[i-1][1][0]*9+f[i-1][0][0]+sum;
        for (int k=1;k<=9;k++)
            f[i][0][k]=f[i-1][0][k]*9+f[i-1][k][k];
        for (int j=1;j<=9;j++)
        {
            f[i][j][0]=f[i-1][1][0]*9+f[i-1][0][0];
            for (int k=1;k<=9;k++)
            {
                if (j==k)
                    f[i][j][k]=f[i-1][0][k]*9+f[i-1][k][k]+sum;
                else 
                    f[i][j][k]=f[i-1][0][k]*9+f[i-1][k][k];
            }    
        }
    }
    bin[1]=1;
    for (int i=2;i<=10;i++)
        bin[i]=bin[i-1]*10;
}
void solve(int x)
{
    memset(ans,0,sizeof(ans));
    cnt=0;
    int num=x;
    while (x>0)
    {
        c[++cnt]=x%10;
        x=x/10;
    }
    for (int i=1;i<cnt;i++)
        for (int j=1;j<=9;j++)
            for (int k=0;k<=9;k++)
                ans[k]+=f[i][j][k];
    for (int i=cnt;i>=1;i--)
    {
        for (int j=0;j<c[i];j++)
        {
            if (i==cnt&&j==0)
                continue;
            for (int k=0;k<=9;k++)
                ans[k]+=f[i][j][k];
        }
        ans[c[i]]+=num%bin[i]+1; 
    }
}
void work()
{
    scanf("%d",&n);
    solve(n);
    for (int i=0;i<=9;i++)
        printf("%d\n",ans[i]);
}
int main()
{
    init();
    work();
    return 0;
}
···
```

---

## 作者：吴国铨 (赞：5)

没有pascal题解？

好吧，p党都来看了。

```cpp
program P1239;
var i,n,m,x,y,r,ans:longint;
     a:array[0..9] of longint;
begin
  readln(n);
  fillchar(a,sizeof(a),0);
  m:=n;
  ans:=1;
  r:=0;
  while m<>0 do
    begin
      x:=n div ans mod 10;
      y:=n mod ans;
      for i:=0 to 9 do a[i]:=a[i]+r*x*ans div 10;
      for i:=0 to x-1 do a[i]:=a[i]+ans;
      a[x]:=a[x]+y+1;
      a[0]:=a[0]-ans;
      ans:=ans*10;
      inc(r);
      m:=m div 10;
    end;
  for i:=0 to 9 do writeln(a[i]);
end. 
```
在统计m位数时，0多算了(11……1)这样一个全是1的m位数。
基本算法描述如下：

输入n；

计算n的位数Len；

将n每一位上的数字存放到数组c里；

计算10的0次方到len-1次方并存放到数组b里；

i控制位数，for i:=len downto 1 do

    begin

0到9的使用次数增加平均使用的次数b[i-1]\*(i-1)\*c[i]；

0到c[i-1]的使用次数增加作为当前位使用的次数b[i-1]；

c[i]的使用次数增加n mod b[i-1]

    end

最后减去多计算的0的个数；

输出结果。


---

## 作者：GrayCatH (赞：4)

  # 普及减用数位dp？？
真实感受到自己的弱小
## 回归普及难度，~~开始找规律~~
规律（价值->个数）：  
100->11  21 20 20……   
1000->192  301 300  ……  
10000->2893   4001   4000   4000……    
#### 由此拓展      
100里对1有价值的只有1,11,21……和11 12 13 14……最后100   
那么1->10+10+1=21    
1000呢     
百位是1时，有一百个     
十位是1时，有一百个    
个位是1时，有一百个    
1000自带一个     
所以100+100+100+1   
100是10的二次方，1000是10的三次方，观察所加10,100个数发现规律    
并且发现不管是100还是1000里面对1有意义的数都是规律、集中分布的    
并发现2~9都相等->一定范围内可获得价值相等       
200就变成             +20+20,  
2000—>+200+200+200=+(3* 2 )乘100） ……     
//具体看程序 
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int read(){
	int ret=0;char c;
	while((c=getchar())<'0'||c>'9');
	while(c>='0'&&c<='9')ret=ret*10+(c-'0'),c=getchar();
	return ret;
}
int  n;
ll a[10];
ll b[10];//c
ll c[10]={0,1};//b{01
ll d[10]={0};//a{0
ll zero[10]={1,11,192,2893,38894};
           //1  2   3   
//规律（价值->个数）：
//100->11  21 20 20……
// 1000->192  301 300  ……
//10000->2893   4001   4000   4000……
// 由此拓展 
//100里对1有价值的只有1,11,21……和11 12 13 14……最后100
//那么1->10+10+1=21
//1000呢
//百位是1时，有一百个
//十位是1时，有一百个
//个位是1时，有一百个
//1000自带一个
//所以100+100+100+1
//100是10的二次方，1000是10的三次方，观察所加10,100个数发现规律
//并且发现不管是100还是1000里面对1有意义的数都是规律、集中分布的
//并发现2~9都相等->一定范围内可获得价值相等
//200就变成+20+20,2000->+200+200+200=+3*（2*100） …… 
//具体看程序 
int main(){
	n=read();
	//规律程序  
	int m=1;
	for(int k=1;k<=10;k++){
		m*=10;
		if(m>n)break;
		if(n==m){
	int x=n/10;
	int y=n;
	int z=0;
	while(y/=10){
	z++;
	}
	//cout<<z<<endl; 
	x*=z;
	int j=10;
	a[0]=x;
	for(int i=1;i<=z-1;i++){
		a[0]-=j;
		j*=10;
	} 
	a[0]=a[0]+z-1; 
	a[1]=x+1;
for(int i=2;i<=9;i++){
	a[i]=x;
	
}
for(int i=0;i<=9;i++)
printf("%lld\n",a[i]);
return 0;}
}
/*int x,y,z;
for(int i=0;i<10;i++){
	int m=1;
	while(m<=n){
		x=n/(m*10);
		b[i]+=x*m;
		if(x!=0&&i==0)b[i]-=m;
		y=(x*10+i)*m;
		if(y<=n&&y!=0){
			z=n-y+1;
			if(z>m)z=m;
			b[i]+=z;}
		m*=10;}}
for(int i=0;i<10;i++){
	if(i!=0)printf("\n");
	printf("%lld",b[i]);
}*/
//正解程序 
int x=0,k;
     k=n;
     while(k>0) {
	 	x++;//存位数 
		b[x]=k%10;
		k/=10;}//取出每一位上的数 
     for(int i=2;i<=9;i++)
	  c[i]=c[i-1]*10;//预存0,1,10,100,1000,10000…… 
     k=n;
     for(int i=x;i>=1;i--)
     {//从最高位往后看 
         for(int j=0;j<=9;j++)//计算0~9每个数能由这一位获得的价值 
		 d[j]+=c[i-1]*(i-1)*b[i];//规律发现的计算价值方法 
		 //比如232，这样就把4~9都直接找出来了，
         //因为此时4~9一样的232最多影响到这个100里多出不是正好成组的3 
		 //例如100（i==3）->10*2*1 
         for(int j=1;j<=b[i]-1;j++) 
		 d[j]+=c[i];
		 //但每一位上的数字不一定是整齐的，还要单独找一遍 
		 /*例如n=232
		 x=3;
		 b[2]=3;
		 这时候b[2]-1=2;发现31里有成组1,2 
		 d[1]+=c[2]…
		 */ 
         d[b[i]]+=k%c[i]+1;
         cout<<"#"<<d[5]<<endl;
        //对于d[3],+=n(232)%100+1 //30 31 32 
     }
     //for(int i=1;i<=x;i++)
	  //d[0]-=c[i];
     for(int i=0;i<=9;i++)
         printf("%lld\n",d[i]);
     return 0;
 }


```

---

## 作者：孤单光量子 (赞：2)

###### 好像这儿的Pascal题解好少啊，那我来发一个~~~
看到这题，很多人会尝试枚举，例如下面的程序：
```var a:array[0..9]of longint;
    i,k,l,m:longint;
begin 
    readln(l);fillchar(a,sizeof(a),0);
	for i:=1 to l do begin 
	k:=i;
	while k<>0 do begin 
	m:=k mod 10;
	inc(a[m]);
	k:=k div 10;
	end;end;
	for i:=0 to 9 do writeln(a[i]);
end.```
###### //然而本蒟蒻信誓旦旦的向你保证，这样会超时。因为这题的数据范围是10^9.
好吧这题事实上应该这么做：（思路出自吴国铨 ）
```var i,n,m,x,y,r,ans:longint;
     a:array[0..9] of longint;
begin
    readln(n);m:=n;ans:=1;r:=0;
	while m<>0 do begin
	x:=n div ans mod 10;
	y:=n mod ans;
	for i:=0 to 9 do a[i]:=a[i]+r*x*ans div 10;
	for i:=0 to x-1 do a[i]:=a[i]+ans;
	a[x]:=a[x]+y+1;
	a[0]:=a[0]-ans;
	ans:=ans*10;
	inc(r);
	m:=m div 10;
    end;
    for i:=0 to 9 do writeln(a[i]);
end. ```

---

## 作者：青春ing (赞：2)

对于N位数X，可以将它拆分为X=A[1]\*10^N+A[2]\*10^(N-1)+...+A[N]\*10^(N-N)的形式。

对于A[i] (1<=i<=N)，

一、如果它不为0,那么它：

1. 首先会分别增加A[i]\*(N-i)\*10^(N-i-1)个0...9；

2. 其次会增加10^(N-i)个1..A[i]-1；

3. 然后会增加A[i]\*10^(N-i+1)个A[1]...A[i-1]；

4. 最后会增加一个A[i]。


二、如果它为0，则应减去被多计算的10^(N-i-1)-1个0。


#### 以上仅为大意，不保证没有错误，具体请见代码：





```cpp
#include <cstring>
#include <cstdio>
using namespace std;
constexpr int base[11] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};//事先计算好的10^i
constexpr int dif[11] = {0, 1, 20, 300, 4000, 50000, 600000, 7000000, 80000000, 900000000};//事先计算好的i*10^(i-1)
int ans[11];//用于存储答案
int main()
{
    char num[11];//读入的数字，用字符串会更方便接下来的处理。当然，用int也没问题
    scanf("%s", num);
    int len = strlen(num) - 1;//求数字的位数
    int plus = 0;//plus即前述A[i]不为0将要增加的A[1]...A[i-1]的个数。程序倒序处理，所以plus需要累计
    for (int i = len; i >= 0; --i)//N-1>=i>=0，与之前描述有差别
    {
        int dig = num[i] - '0';//即前述A[i]
        ans[dig] += plus + 1;//前述A[i]不为0时要处理的3和4。程序倒序处理，与描述有差别
        plus += dig * base[len - i];//累计plus
        if (dig == 0)
        {
            ans[0] -= base[len - i];//A[i]为0时减去10^(N-i)个0（因第19行将ans[0]加了1,所以这里要多减1个0）
        }
        for (int j = 0; j < 10; ++j)
        {
            ans[j] += dig * dif[len - i];//前述A[i]不为0时要处理的1
        }
        for (int j = 1; j < dig; ++j)
        {
            ans[j] += base[len - i];//前述A[i]不为0时要处理的2
        }
    }
    for (int i = 0; i < 10; ++i)
    {
        printf("%d\n", ans[i]);//输出答案
    }
    return 0;
}
```

---


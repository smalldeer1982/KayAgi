# 排序集合

## 题目描述

对于集合 $N=\{1,2,\cdots,n\}$ 的子集，定义一个称之为“小于”的关系：

设 $S1=\{X_1,X_2,\cdots,X_i\}$，$(X_1<X_2<\cdots<X_i)$，$S2=\{Y_1,Y_2,\cdots,Y_j\}$，$(Y_1<Y_2<\cdots<Y_j)$，如果存在一个 $k$，$(0\leq k\leq\min(i,j))$，使得 $X_1=Y_1,\cdots,X_k=Y_k$，且 $k=i$ 或 $X_{k+1}<Y_{k+1}$，则称 $S1$ “小于” $S2$。

你的任务是，对于任意的 $n(n\leq31)$ 及 $k(k<2^n)$，求出第 $k$ 小的子集。

## 样例 #1

### 输入

```
3 4
```

### 输出

```
1 2 3
```

# 题解

## 作者：lytqwq (赞：20)

~~说炸int为什么不好好看题呢~~

对于N的子集，每个数我们都可以取或者不取，

如果不取1，会有2^(n-1)种方法在“不取1时”的前面，

就是有2^(n-1)种方法比“不取1时”小，


------------

所以当k>2^(n-1)时，不取第一个数，

k-=pow(2,n-i)，再考虑取不取2，我们发现：

#### 如果不取i，会多2^（n-i）种方法比“不取i时” 小

所以，当k<=2^（n-i）时，我们只能取i，因为如果不取就会多2^（n-i）种方法比不取i时小

但这时我们要k - - ,因为还有一种就是不取i且之后所有都不取的情况。

然后k<2^n的，所以并不会炸int，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main()
{
	scanf("%d%d",&n,&k);
	if(k==1)
	{
		printf("0\n");
		return 0;
	}
	k--;
	for(int i=1;i<=n;i++)
	{
		if(k==0)
		{
			break;
		}
		if(k<=pow(2,n-i))
		{
			printf("%d ",i);
			k--;
		}
		else
		{
			k-=pow(2,n-i);
		}
		
	}
	
}
```



---

## 作者：WOWHandsome (赞：9)

## 前言

本题是我们昨天考试的 $\text{T4}$，因为时间不够没写 T_T...

然后，本人经过一番找规律发现这题就是个大水题啊，居然没人做，本人决定水一发题解，顺便 **创造10行AC** 的奇迹。

## 思路

我们发现，当 $n=4$ 时，这个集合排序后的结果是这样的：

$\{\},\{1\},\{1,2\},\{1,2,3\},\{1,2,3,4\},\{1,3\},\{1,3,4\},\{1,4\}$

$\{2\},\{2,3\},\{2,3,4\},\{2,4\}$

$\{3\},\{3,4\}$

$\{4\}$

不难发现，以 $1$ 开头的集合有 $2^3$ 个，以 $2$ 开头的集合有 $2^2$ 个，以 $3$ 开头的集合有 $2^1$ 个，以 $4$ 开头的集合有 $2^0$ 个。

那不就好办了吗？每次我们只需要在剩下的 $k$ 中减去最大的 $2$ 的幂次方就可以了！

核心代码：

```cpp
while (m > 0) {
	t++, m--;  //此处 k 用 m 表示，t 表示集合元素个数
	if (m <= 0) break; // 如果 m 减完了就退出
	a[t] = a[t - 1] + 1;   // 当前集合元素赋初值
	while (m > (1 << n - a[t]) && a[t] <= n) m -= (1 << n - a[t]), a[t]++;   // 枚举最大的 2 的幂次方
} 
```

好了，我们还需要注意其他的一点点小细节：

1. $k$ 的最大值是 $2^{31}$，而 int 的最大值是 $2^{31}-1$，需要开 long long

2. 题目要求空集输出 $0$，按照我刚才的核心代码，只需要判断 $t$ 是否大于 $1$ 即可。

## 代码

其实你可以按照我的核心代码写，因为剩下的部分真的很简单。这里可以看一下我的 **10行AC代码** 作为参考(~~顺便学习压行技巧~~)

```cpp
# include <bits/stdc++.h>
long long n, m, t, a[1000005]; 
signed main() {
	scanf("%lld%lld", &n, &m);
	while (m > 0) {
		if (++t, (--m <= 0)) break; else a[t] = a[t - 1] + 1;
		while (m > (1 << n - a[t]) && a[t] <= n) m -= (1 << n - a[t]), a[t]++;
	} 
	if (t != 1) for (int i = 1; i < t; i++) printf("%lld ", a[i]); else puts("0");
}  //10行AC代码 || BYH || 2020-08-18
```
## 其他

本篇题解就到这里，如果大家还是不懂可以私信与我交流。

我的博客(周末会从洛谷博客更新): <https://www.baoyh.vip>

蒟蒻自己建的小OJ，可以作为刷题的补充题库：
<https://www.dreamoj.com>

thanks!

---

## 作者：xiamingxuan_IWoLongI (赞：3)

~~其实是一道找规律的题。~~

## 正文

这道题，我们只要枚举一下样例输出的子集：

$\left \{  \right \}$，

$\left \{ 1 \right \}$，$\left \{ 2 \right \}$，$\left \{ 3 \right \}$，

$\left \{ 1,2 \right \}$，$\left \{ 1,3 \right \}$，$\left \{ 2,3 \right \}$，

$\left \{ 1,2,3 \right \}$，

就会发现，**一个长度为 $n$ 的集合最多会有 $2^n$ 个子集**。

于是乎，在这个集合里，对于数 $i$，每次都有取和不取两种情况。

当取的时候，之后肯定会有 $n-i$ 个空位需要确定下来，根据上面得出的发现，这些空位的可能种数为 $2^{n-i}$ 种，此时的 $k$ 需要小于这些种数，才能保证最优。

当不取的时候，就说明当前这个数取不能保证之后最优，于是将 $k$ 减去 $2^{n-i}$。

这里还有一个小坑，就是 $k=1$，最小的子集时，需要特判。因为最小的子集肯定就是空集，直接输出 $0$（~~这个坑卡了我三次 $90$ 分~~）。

## 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[10000001];
int cnt;
int main() {
	cin>>n>>k;
	if(k==1) {//特判，就是这个坑害我连交了三发90分 
		cout<<0;
		return 0;
	}
	k--;
	for(int i=1; i<=n; i++) {
		int t=pow(2,n-i);
		if(k<=t) {//取 
			a[++cnt]=i;
			k--;
		} else if(k>t)//不取 
			k-=t;
		if(k<=0)//取完了，退出 
			break;
	}
	for(int i=1; i<=cnt; i++)//输出 
		cout<<a[i]<<" "; 
	return 0; 
}
```

蒟蒻第一次写题解，可能不是特别好，希望 dalao 们指出。

---

## 作者：Ezis (赞：3)

**前言**

此题为我们测试第 $4$ 题，本以为很难，结束后一看发现竟然是黄题？！
####  发现：一个长度为 $n$ 的序列最多 $2^n$ 个子集

第 $n$ 位上是有 $2$ 的 $n$ 次个

```cpp
#include<bits/stdc++.h>	//万能头 
using namespace std;
int n,m,t;
int a[35];	//N最大是31 
int main(){
	scanf("%d%d",&n,&m);	//输入 
	while(m>0){
		m--;
		t++;		//位数+1 
		if(m<=0)	//若m<=0了，就break掉 
			break;
		a[t]=a[t-1]+1;	//a[t]最少为a[t-1]+1 
		while(m>(1<<(n-a[t]))&&a[t]<=n){ 
			m-=(1<<(n-a[t]));
			a[t]++;				//找当前的最大的 
		}
	} 
	t--;
	bool flag=false;	//为了判断接下来是否为空集 
	for(int i=1;i<=t;i++)
		printf("%d ",a[i]),flag=true;
	if(flag==false)
		printf("0");	//若是空集，输出0 
	return 0;
}
```

蒟蒻的第一篇题解，希望能通过


---

## 作者：hehelego (赞：3)

上来先写注意事项  
### k不是自然数是正整数啊,@cz快来修锅啊
我们枚举一下\[1,2,3]的子集就知道了  
{},{1},{1,2},{1,2,3},{1,3},{2},{2,3},{3}

思路讲解:  
首先我们应该明白...这个叫集合排序但是其实排序的是"排列方案",排列方案的排名?是不是想到了康托展开和逆康托展开,但是很遗憾这个排列方案的长度不要求是n,并不是康托展开的做法(康托展开有点玄学简单来说就是通过比较每一位上可选的元素中小于这个元素的个数来算出有多少个小于当前排列的个数)(好像没讲清楚啊那您百度自己找吧....还是能看懂的)    

~~前面都是瞎扯~~

严肃正经的解题思路.
我们把子集排序后插到一个trie上面...emmm,或者说我们发现很多子集有公共前缀所以把他们扔到trie上.  
我们分析一下这个trie的性质,首先每个节点到根(是个虚节点)的路径代表一个集合(特别的,空集是根单个节点构成的路径)  
其次,u的子树中的节点都大于u,画图/分析可知  
然后我们就知道...按照 子节点从小到大 这种方式进行dfs,遇到的第k个节点就是我们要的答案....  
然后问题来了  
1. 这个trie可是有 2^n个节点啊!  

QAQ,说到这里,不知道您有没有看出来这个过程有点像二叉树上kth的过程....不过这里是最多n叉,其实是一样的,我们只要知道每个节点的子树size就能方便的进行这个过程了,最多走n层就能找到,然后一顿分析发现这个kth过程好像是O(n)的....
### 好了说关键
怎么算子树size,这个吧,由于子集之间有非常强的自相似性....(抱歉我说的太玄学了...但是如果写一个子集生成应该就知道我是什么意思),我们发现son\[u]\[i]和 son\[1]\[u+i]是一样的结构....所以搞个树形dp先前算好.是代码里面的 f / g 分别对应子树大小和前i个儿子的大小.
基本上可以写了...

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <string>
using namespace std;
int read(){
  int x=0,f=1;char ch;
  do{ch=getchar();if(ch=='-')f=-1;}while(ch>'9'||ch<'0');
  do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
  return x*f;
}
typedef long long ll;
const int N=32;

int n,k;
int used[N];
int ans[N],cnt;

ll dp[N],tbl[N][N];
int g(int,int);
// lim的子树的话我举个例子
//      0
//    1    2    3
//   2  3    3
// 3 
// 求出 lim的子树size
int f(int lim){
  if(lim==n) return 1;
  if(dp[lim]) return dp[lim];
  return dp[lim]=1+g(lim,n-lim);
}
// lim的前cnt个儿子的子树size之和
int g(int lim,int cnt){
  if(cnt<=0) return 0;
  if(tbl[lim][cnt]) return tbl[lim][cnt];
  return tbl[lim][cnt]=g(lim,cnt-1)+f(lim+cnt);
}
//这个就是kth...
// lim为根的子树中排名k的节点
void dfs(int lim,int k){
  // printf("dfs %d,%d\n",lim,k);
  // 排名第一的子集就是当前节点,特别的这可能会使空集合
  if(k==1){
    if(cnt==0) printf("0");
    else
      for(int i=0;i<cnt;i++)
        printf("%d ",ans[i]);
    puts("");
    return ;
  }
  k--;// 这个节点本身也是有size 1的啊...
  for(int i=0;i<n-lim;i++)
  	// 找一个kth所在的子树
    if(g(lim,i)<k&&k<=g(lim,i+1)){
      // printf("%d in [%d,%d]\n",k,g(lim,i),g(lim,i+1));
      ans[cnt++]=lim+i+1;
      dfs(lim+i+1,k-g(lim,i));
      return ;
    }
  // 这里怕前面i+1挂所以单独搞出来..
  // 只能在最后一个儿子的话...这个儿子是n...画图可知
  ans[cnt++]=n;
  dfs(n,1);
}

int main(){
  n=read();k=read();
  // 其实这句不写没事....反正是记忆搜索
  // 不会产生重复计算
  f(0);
  dfs(0,k);
  return 0;
}

```

---

## 作者：Huami360 (赞：2)

哪有楼下说的那么复杂~~，树形DP都来了~~。
可以发现若长度为$n$，则以$1$开头的子集个数为$2^{n-1}$，以$2$开头的为$2^{n-2}$个。以$1$开头，第二位为$2$的为$2^{n-2}$个，以$2$开头，第二位为$3$的为$2^{n-3}$，相信大家都发现规律了。

于是我们可以在$\log k$的时间复杂度里求出第$i$位，最坏总时间复杂度$O(n^2)$

还有个细节就是$k$的最大值是$2^{31}$，而$int$的范围刚好是$2^{31}-1$，~~刚好炸了~~，所以要开$unsigned\ int$

```cpp
#include <cstdio>
#include <cstring>
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
int n, k, out[50], p = 1;
unsigned int now;

void print(){
	for(int i = 1; i <= out[0]; ++i)
		printf("%d ", out[i]);
	if(!out[0]) printf("0");
	puts("");
}
void find(){
	while(k > now) k -= now, now >>= 1, ++p;
	out[++out[0]] = p++; now >>= 1;
}
int main(){
	Open("sort");
	scanf("%d%d", &n, &k); now = 1 << (n - 1);
	while(2333){
		if(k == 1){   //该位为空，直接输出
			print(); 
			break;
		}
		--k;
		find();    //找这一位是什么
	}
	Close;
	return 0;
}

```

---

## 作者：Tr_Sup (赞：0)

### 前言
------------
今天模拟赛考到了这道题，一眼找规律，直接AC了，

看了一眼题解，发现没有用**递归**写的，我在此补充下。

### 分析
------------
若 $n$ = 3 时，子集由小到大排列为：

$\{\}$ ,

$\{1\}$ , $\{1,2\}$ , $\{1,2,3\}$ , 

$\{2\}$ , $\{2,3\}$ ,

$\{3\}$

由大到小排列为：

$\{3\}$ ，

$\{2,3\}$ ，$\{2\}$ ，

$\{1,3\}$ , $\{1,2,3\}$ , $\{1,2\}$ , $\{1\}$ ,

$\{\}$ 

在由大到小排列的子集中，我们不难发现

第 $i$ 行的所有子集由第 $1$ 行至 $i-1$ 行的所有子集前

加上 $n-i+1$ 而得到，然后最后在加个 $n-i+1$ 的子集

而题目让我们求第 $k$ 小的子集，

我们可以转换成第 $tot$（子集总数）$-k+1$ 大的子集 

（因为是从大到小求子集）

### 思路
------------
假设求第 $q$ 大的子集

我们可以一行一行的记录已统计的子集数量

若 $q\leq sum$ （$sum$为已统计的子集数量）

则在当前此行进行操作

若 $q=sum$ 输出该子集的第一个数，结束程序

若 $q<sum$ 输出该子集的第一个数，再递归求该子集后面的数字

核心代码如下：

```cpp
void ac(int q){
	int sum=0,m=n;
   	//m为当前行的子集的第一个数，sum如上
	while(1){
		sum*=2;
		sum++;
		if(sum>=q){
			cout<<m<<' ';
			if(sum==q) exit(0);
			ac(q-(sum-1)/2);//递归继续求答案
			return ;
		}
		m--;
	}
}
```

### 代码
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,tot=1;
void ac(int k){
	int sum=0,m=n;
	while(1){
		sum*=2;
		sum++;
		if(sum>=k){
			cout<<m<<' ';
			if(sum==k) exit(0);
			ac(k-(sum-1)/2);
			return ;
		}
		m--;
	}
}
int main(){//rp++
//	freopen("sort.in","r",stdin);
//	freopen("sort.out","w",stdout);
	cin>>n>>k;
	if(k==1){
		cout<<0<<endl;
		return 0;
	}
	for(int i=2;i<=n;i++) tot=tot*2+1;
	tot++;
	k=tot-k+1;
   	//求第k小转换为求第tot-k+1大
	ac(k);
	return 0;
}
```

新人第一篇题解，管理员求通过

---

## 作者：huoxin (赞：0)

## 题目大意

对于 $X,Y$ 两个严格递增集合，若 $X$ “大于” $Y$，当且仅当存在一个 $k$ 使得对于任意 $i<k$ 时 $X_i=Y_i$，且$X_{k+1}>Y_{k+1}$。

求 $1$ 到 $n$ 的集合的子集中第 $k$ 小的子集，将其升序输出。

## 解题思路

考虑每个 $i\in[1,n]$，对于这个 $i$，有选与不选两种情况：

- 选，在 $i$ 之后共有 $(n-i)$ 个位置需要确定，它们的可能种数为 $2^{n-i}$ 种，此时的子集将**大于**任意一个不选i的子集（i前面相同）
- 不选，此时的子集将**小于**任意一个不选i的子集（i前面相同）

特别地，在前面的情况相同时，若对于任意 $j \geq i$，$j$ 都不选，则此时的子集最小。

所以当 $i$ 不选时，$k$ 的最小值为 $2^{n-i}+1$。


因此，我们就可以通过比较 $k$ 与 $2^{n-i}+1$ 的大小，来判断此时 $i$ 取或不取。

## 注意事项

- $k=1$ 要特判，因为此时输出的是“最小”的子集，又因为按照题目给的大小判断，空集是最小的子集，所以此时直接输出 $0$。
- $k$ 最开始要减 $1$（想想为什么）。
- $k$ 每次判断完之后要减去一个数，这是因为我们每次只判断 $i$ 之后的可能大小，这样方便我们判断。


```cpp
#include<bits/stdc++.h>
using namespace std;
int ksm(int s,int q){//快速幂 
	int sum=1;
	while(q){
		if(q&1)sum*=s;
		s*=s;
		q/=2;
	}
	return sum;
}
int main(){
	int n,k;scanf("%d%d",&n,&k);//输入 
	k--;
	if(!k)printf("0\n");//特判 
	else for(int i=1;i<=n;i++){
		if(!k)break;//i以及后面都不取 
		if(k>ksm(2,n-i))k-=ksm(2,n-i);//不取 
		else {//取 
			printf("%d ",i);
			k--;
		}
	}
	printf("\n");
	return 0;
}
```

---


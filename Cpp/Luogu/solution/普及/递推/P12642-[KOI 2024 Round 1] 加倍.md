# [KOI 2024 Round 1] 加倍

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

给定一个长度为 $N$ 的正整数序列 $A_1, A_2, \dots, A_N$。现在希望将该序列变为升序排列。所谓升序排列，是指对于所有的 $i$（$1 \leq i \leq N - 1$），都有 $A_i \leq A_{i+1}$。

为了将序列 $A$ 排成升序，可以对序列执行以下操作若干次（可为零次）：

- 对于某个 $i$（$1 \leq i \leq N$），将 $A_i$ 乘以 $2$。

你的任务是以最小的操作次数将序列 $A$ 排成升序，并输出所需的最小操作次数。

## 说明/提示

**样例 1 说明**

对 $A_2$ 和 $A_4$ 各执行两次操作后，序列变为 $[3, 4, 4, 4, 5]$。

**样例 2 说明**

对 $A_2$ 操作两次，$A_4$ 操作三次，$A_5$ 操作一次，最终序列为 $[3, 4, 5, 8, 10]$。

**约束条件**  
- 所有给定的数均为整数。
- $1 \leq N \leq 250\,000$
- $1 \leq A_i \leq 1\,000\,000$，其中 $1 \leq i \leq N$

**子问题**
1. （12 分）对于所有 $i$（$1 \leq i \leq N$），$A_i = 1$ 或 $A_i = 2$
2. （10 分）对于所有 $i$（$1 \leq i \leq N$），存在非负整数 $k_i$，使得 $A_i = 2^{k_i}$
3. （11 分）$N \leq 10$
4. （19 分）对于所有 $i$（$1 \leq i \leq N$），$A_i = 2$ 或 $A_i = 3$
5. （20 分）对于所有 $i$（$1 \leq i \leq N - 1$），$A_i \geq A_{i+1}$
6. （28 分）无额外限制条件

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
5
3 1 4 1 5```

### 输出

```
4```

## 样例 #2

### 输入

```
5
3 1 5 1 5```

### 输出

```
6```

## 样例 #3

### 输入

```
5
1 2 3 4 5```

### 输出

```
0```

# 题解

## 作者：complete_binary_tree (赞：6)

首先，任何使用 `long long`、`unsigned long long` 甚至 `double` 的暴力 $\times 2$ 做法肯定是过不了这题的。

稍微分析一下就可以知道出题人可以构造出 $[1000000,999999,999998,\dots]$ 这样的序列，而这样的序列操作次数是 $1\sim n$ 的等差数列级别的（$n^2$ 级别），操作出来的数是 $2^n$ 级别的，`long double` 来了都存不下。

但是我们想到 `double`，我们可以发现 `double` 由指数位和真实数位组成。我们是否能像 `double` 一样把指数位存起来呢？

我们可以开一个结构体，一个存数字 $a$，一个存指数 $n$。那么这个数就能表示为 $a \times 2^n$ 的形式。

当数字读入进来，我们先将它的二进制下最高位 $1$ 对齐到 `1<<20` 这位（方便比大小），然后计算它的指数（原来最高位的 $1$ 是 $2$ 的几次方就存几）。

由于它要大于等于前一个数，所以它最终的指数肯定要大于等于前一个数的指数，所以我们先加上这一段。

此时这个数可能还小于前面那个数。不过这好办，再乘一次 $2$ 就行了。

代码：（拿下[最优解](https://www.luogu.com.cn/record/218849112)）

```cpp
#include<iostream>
using std::cout;
static char buf[1048576], * pa(buf), * pb(buf);
#define gc pa == pb && (pb = (pa = buf) + fread(buf, 1, 1048576, stdin), pa == pb) ? EOF : *pa++
int cnt=0,n,x;
long long ans;
struct node{
    int a,b;
}a[250001];
char ch;
inline void read(int&x) {
  x=0;
  ch=gc;
  while (!isdigit(ch)) {
    ch = gc;
  }
  while (isdigit(ch)) {
    x = (x << 3) + (x << 1) + (ch ^ 48);
    ch = gc;
  }
}
int main() {
    read(n);
    for (int i = 0; i < n; i++) {
        read(a[i].a);
        cnt=0;
        while(a[i].a>>cnt)++cnt;
        a[i].a<<=(20-cnt)+2,a[i].b=cnt;
        if(!i)continue;
        if(a[i-1].b>a[i].b)ans+=a[i-1].b-a[i].b,a[i].b=a[i-1].b;
        if(a[i-1].b==a[i].b&&a[i-1].a>a[i].a)a[i].b++,ans++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Mark_Pei (赞：5)

## Solution

我们先把 $b$ 都变为相同，然后比较 $a$，如果前一个数的 $a$ 更大，那么 $b$ 再加 $1$，即再乘以 $2$。只需要遍历序列，对每个数进行以上操作即可。

然后可以将 $a_i$ 设为 $\log_2 a_i$ ，这样就会 $×2$ 就会变成 $+1$ 。

最后至于 `double` 的精度问题，我们可以先减去一个较小的数如 $10^{-6}$，再向上取整即可。

**AC code**
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-6;
long long n,x,s;
double a,b;
int main()
{
    cin>>n;
	while(n--)
    {
		cin>>x;
		b=log2(x);
		if(a>b)
        {
			x=ceil(a-b-eps); 
			s+=x;
            b+=x;
		}
		a=b;
	}
    cout<<s;
	return 0;
}
```

---

## 作者：StarTwinkleTwinkle (赞：4)

谁说 `double` 过不去的？

考虑令 $a_i\gets\log_2{a_i}$，那么这个 $\times 2$ 操作就会变成 $+1$ 操作。

然后就简单了，但我们还得考虑一下 `double` 的精度问题，故我们可以先减去一个较小的数（我这里取的是 $10^{-6}$）再向上取整即可。

代码：

```cpp
#include<bits/stdc++.h>
#define eps 1e-6
using namespace std;
int n,x;
long long ans;
double a,b;
signed main(){
	scanf("%d",&n);
	while(n--){
		scanf("%d",&x);
		b=log2(x);
		if(a>b){
			x=ceil(a-b-eps); 
			ans+=x,b+=x;
		}
		a=b;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Clare613 (赞：3)

~~666！这道题蒟蒻交了 15 才 A，关于通过率为何这么低。~~
## 思路：
T1 没抢到（写作业去了），那我就写一下 T2 的吧。蒟蒻发现这道题 A 了的人数极少，这里给上各位神犇思路。不难发现，$n$ 十分的大，这就告诉你了一个重要的道理：如果全部乘起来会爆 long long。同时蒟蒻发现很多人都交了类似于这样一个代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
	int n,last,ans=0;
	cin>>n>>last;
	for(int i=2;i<=n;i++){
		int x;
		cin>>x;
		while(x<last){
			x*=2;
			ans++;
		}
		last=x;
	}
	cout<<ans;
    return 0;
}
```
这样不仅超时，而且爆 long long。那么我们可以先解决超时这个问题。蒟蒻左思右想，发现好像可以倍增，学过 LCA 的都知道，这里给大家解释一下什么是倍增。其实就是直接从 $2$ 的高次方往小遍历。我们可以看到 $1 \leq A_i \leq 10^6$，于是蒟蒻又算出了 $2^{30} = 1073741824$，便想当然的跑了从 $30$ 至 $1$ 的倍增，于是有了这样一个代码：
```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
int a[35];
signed main(){
//	cin.tie(0)->sync_with_stdio(0);
	int n,last,ans=0;
	cin>>n>>last;
	a[0]=1;
	for(int i=1;i<=30;i++){
		a[i]=a[i-1]*2;
	}
	for(int i=2;i<=n;i++){
		int x;
		cin>>x;
		for(int k=30;k>=1;k--){
			if(x*a[k]<last){
				x*=a[k];
				ans+=k;
			}
		}
		if(x<last){
			x*=2;
			ans++;
		}
		last=x;
	}
	cout<<ans;
    return 0;
}
```
好家伙，超时是没了，但是得分依旧是 $33$。于是想出来源头：一定是因为 $2^x$ 爆了 long long。那么就开始用二分来破此法，当然用倍增亦可。我们还是老规矩，因为 $2^{30} = 1\,073\,741\,824$，所以我们可以把右端点放在 $30$ 上，这也证明了倍增的可行性。不扯远了，我们只要存上一个数是几，乘了二的几次方即可，因为我们可以让新的数假设先乘了上一个数一样的次方，如果当前这个数的本身小于上一个数的本身，那么就还要加，相反就是减，记得要保证这个数的本身乘二的几次方一定要大于上一个数的本身乘二的几次方，输出加的次数即可，~~感觉可以评黄。~~
## code：
你们最喜欢的代码来了，制作不易，求点赞。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ans;
int fun(int x){
	if(x==1) return 0;
	int l=1,r=30;
	while(l<r){
		int mid=(l+r)/2;
		if((1<<mid)>=x) r=mid;
		else l=mid+1;
	}
	return l;
}
signed main(){
	int n,last,s=0;
	cin>>n>>last;
	for(int i=2;i<=n;i++){
		int x,w=0;
		cin>>x;
		if(x>last){
			if(x%last==0){
				if((1<<fun(x/last))!=x/last) w++;
				w+=s-fun(x/last);
			}
			else{
				w=s-fun(x/last+1)+1;
			}
		}
		else{
			if(last%x==0) w=s+fun(last/x);
			else w=s+fun(last/x+1);
		}
		w=max(w,0LL);
		ans+=w;
		s=w;
		last=x;
//		cout<<x<<" "<<w<<"\n";
	}
	cout<<ans;
	return 0;
}
```
~~我相信这是第一篇题解，写完后就会有更多人来写题解。~~

---

## 作者：darklf (赞：2)

# 题解：P12642 [KOI 2024 Round 1] 加倍
### [题目传送门](https://www.luogu.com.cn/problem/P12642)
## 思路
看数据范围我们知道，正常的暴力乘二肯定过不了。   
我们可以对于下标不为一的数，用一个 $last$ 记录上一个数乘了几次二，再用一个 $ans$ 记录一共的操作次数，有两种情况：
1. 这个数比前一个小，计算最少乘几次二才比前一个数大，次数为 $now$，$ans = ans + last + now$，$last = last + now$。
2. 这个数比前一个大，计算最少除几次二就比前一个数小，次数为 $now$，$ans = ans + last - now$，$last = last - now$。

附上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=25e4+10;
int n,ai,last,now,ans=0,a[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i!=1){
			ai=a[i];now=0;
			if(a[i]<a[i-1]){
				while(ai<a[i-1])ai*=2,now++;
				ans+=last+now,last+=now;
			}
			else{
				while(ai/2>=a[i-1])ai/=2,now++;
				if(now<last)ans+=last-now,last-=now;
				else last=0;
			}
		}
	}
	cout<<ans;
	return 0;
}
```
完结撒花。

---

## 作者：lmz105 (赞：2)

### 思路
比较两个数 $a$ 和 $b$ 的大小可以用除法来判断，如果 $a \ge b$，那么 $\frac{a}{b} \ge 1$。

我们用一个长度为 $N$ 的非负整数序列 $B_1, B_2, \dots, B_N$ 来表示每个 $A_i$ 需要操作 $B_i$ 次能将序列 $A$ 排成升序，现在我们需要让每个 $B_i$ 尽可能小。

首先让 $B_1 = 0$，接下来对于每个 $i$（$2 \leq i \leq N$），可以分为三种情况：

- $A_i = A_{i-1}$，让 $B_i = B_{i-1}$ 就能保证 $\frac{A_i \cdot 2^{B_i}}{A_{i-1} \cdot 2^{B_{i-1}}}=1$ 且 $B_i$ 最小。
- $A_i > A_{i-1}$，先让 $B_i = B_{i-1}$，然后每次循环 $B_i$ 都减少 $1$，在此过程中需要保证 $B_i$ 减一后 $\frac{A_i}{A_{i-1} \cdot 2^{B_{i-1}-B_i}} \ge 1$ 且 $B_i \ge 0$，循环结束后的 $B_i$ 就是能取得的最小值。
- $A_i < A_{i-1}$，先让 $B_i = B_{i-1}$，然后每次循环 $B_i$ 都增加 $1$，在此过程中需要保证 $\frac{A_i}{A_{i-1} \cdot 2^{B_i-B_{i-1}}} < 1$，循环结束后的 $B_i$ 就是能取得的最小值。

序列 $B$ 中所有数的和就是答案。

### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define rw() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#ifndef rw()
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif

namespace FX {
	template<typename T> inline void r(T &in) {
		in = 0;
		bool bo = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			bo ^= (ch == '-');
			ch = getchar();
		}
		while (isdigit(ch))
			in = (in << 1) + (in << 3) + (ch ^ 48), ch = getchar();
		if (bo) {
			in = -in;
		}
	}
	template<typename T> inline void w(T out) {
		static char op[25];
		int top = 0;
		if (out < 0) {
			putchar('-');
			do {
				op[++top] = -(out % 10) + 48, out /= 10;
			} while (out);
		} else {
			do {
				op[++top] = out % 10 + 48, out /= 10;
			} while (out);
		}
		while (top)
			putchar(op[top--]);
		putchar('\n');
	}
	template<typename T, typename... Ts> inline void r(T &in, Ts &... ins) {
		r(in), r(ins...);
	}
	template<typename T, typename... Ts> inline void w(T out, Ts... outs) {
		w(out), w(outs...);
	}
	inline void w(const char *p) {
		while (*p) {
			putchar(*p++);
		}
	}
}
#undef getchar
#undef putchar
using namespace FX;
#endif
using namespace std;
ll n,a,b,a1,b1,ans;
int main(){
	r(n,a);
	for (ll i=2;i<=n;i++){
		r(a1);
		if (a1==a){
			b1=b;
		}else if (a1>a){
			b1=b;
			while(a1>=(a<<1) && b1>=1){
				b1--;
				a<<=1;
			}
		}else{
			ll x=a1;
			b1=b;
			while(x<a){
				x<<=1;
				b1++;
			}
		}
		ans+=b1;
		a=a1,b=b1;
	}
	w(ans);
	return 0;
}
```

### 时间复杂度
设 $M$ 为序列 $A$ 中的最大值，对于每个 $i$（$2 \leq i \leq N$），最多需要 $\log M$ 次循环，所以时间复杂度为 $O(N \log M)$。

---

## 作者：lichenxi111 (赞：2)

## 前言
本题比较简单的做法

## 思路

暴力的思路就是遍历序列，然后一直给 $A_i$ 乘以 $2$ 直到它大于等于 $A_{i-1}$。

可能有一些做法能将时间复杂度做到比较不错，但是注意到如果直接存数的话会存不下，考虑到操作只有乘以 $2$，可以把数转化为 $a \times 2^b$ 的形式储存，这样进行操作就变成了改变 $b$ 的值。

这时候有人会问了，即使我的 $b$ 相同，我的 $a$ 可能差异会很大，需要再进行若干次操作才能使序列升序，这样不就等于暴力吗？

那么我们用 `double` 类型储存 $a$，把 $a$ 强制除以 $2$，使 $1\le a \lt 2$，这样可以保证在一次操作内时将 $b$ 相同的两个数保证升序。

明确思路，先把 $b$ 变为相同，然后比较 $a$，如果前一个数的 $a$ 更大，那么 $b$ 再加 $1$，即再乘以 $2$。只需要遍历序列，对每个数进行以上操作即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node
{
	double a;
	int b;
} a[310000];
signed main()
{
	int n;
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		int x;
		cin >> x;
		double y = x;
		int cnt = 0;
		while(y >= 2)
		{
			y /= 2;
			cnt++;
		}
		a[i].a = y,a[i].b = cnt;
	}
	int ans = 0;
	for(int i = 2;i <= n;i++)
	{
		if(a[i].b <= a[i - 1].b)
		{
			ans += a[i - 1].b - a[i].b;
			if(a[i - 1].b - a[i].b < 0)
			{
				cout << 9;
				return 0;
			}
			a[i].b = a[i - 1].b;
			if(a[i].a < a[i - 1].a)
			{
				ans++;
				a[i].b++;
			}
		}
	}
	cout << ans;
	return 0;
} 
```

---

## 作者：WE_TRT (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P12642)
# 思路：
循环从 2 开始，一直到 $ n $，每次跟上一个的判断大小，如果小，就乘以 2，但是这样会超时，所以需要知道一个公式：
$\log_{2} (xy) = \log_2 (x) + \log_2 (y)$，这样我们就可以优化代码。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Nmax=250005;
long long n,a[Nmax],ans,b[Nmax];//b[i]的意思是第i个数需要乘以2的几次方
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=2;i<=n;i++){
		double op1=a[i]*1.0/a[i-1],op2=a[i-1]*1.0/a[i];
		if((b[i-1]!=0&&b[i-1]>log(op1)/log(2))||(b[i-1]==0&&a[i]<a[i-1])){//把原来的判断进行一步步的优化后得来
			b[i]=ceil(log(op2)/log(2)+b[i-1]);//记录这一次需要乘以几个2
			ans+=b[i];
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：残阳如血 (赞：1)

显然对于这种题，直接用 Python 规避问题。

贪心地从前往后枚举，当前数不断乘 $2$ 直到满足条件。

当然这样做会 TLE，所以可以处理出数字二进制下的长度并且做差，这就**大概**是乘的次数了。最后需要一些微调。

```python
import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# pre 表示“前一个位置在贪心操作后”的值
pre = A[0]
ans = 0

for i in range(1, N):
    a = A[i]
    if a >= pre:
        pre = a
        continue
    # 使用位长估算最小 x:
    Lb = pre.bit_length()
    La = a.bit_length()
    x0 = Lb - La
    # 如果 a<<(x0) 还小于 pre，就需要再多一次
    if a << x0 < pre:
        x = x0 + 1
    else:
        x = x0
    ans += x
    pre = a << x

print(ans)
```

---

## 作者：hoko (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P12642)

注意到如果每次都给每个数一直乘二的话，肯定会爆 ```long long```。所以我们要用 $sum$ 记录前一个乘了几次二，到第 $i$ 个数时，分讨一下，当前这个数比前一个大还是小，如果大的话就记录要除几次才能比前一个小，假设值为 $k$，然后答案就加上 $sum-k+1$，再把 $sum$ 的值赋值为 $sum-k+1$。如果要小的话就相反，计算要乘几次才能大于等于前一个数，答案要加上 $sum+k$，$sum$ 赋值为 $sum+k$。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1010101;
ll n,a[N],ans,sum,x,k;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i!=1){
			if(a[i]>=a[i-1]){
				x=a[i],k=0;
				while(x/2>=a[i-1]){
					x>>=1;
					k++;
				}
				if(k<sum)ans+=sum-k,sum-=k;
				else sum=0;
			}
			if(a[i]<a[i-1]){
				x=a[i],k=0;
				while(x<a[i-1]){
					x<<=1;
					k++;
				}
				ans+=sum+k;
				sum+=k;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_second_coming_ (赞：0)

### 我的思路
题目要求把序列 $A$ 排成升序。

现考虑两种情况：

- $A_i\leq A_{i+1}$ 时，无须更改，因为已经是升序。
- $A_i>A_{i+1}$ 时，把 $A_{i+1}$ 乘上 $2^k$ 使得 $k$ 最小。

也就是让 $A_i\gets\log_2{A_i}$，让每个 $\times2$ 对应 $+1$。

但直接用 `double` 会有精度误差，所以要减掉一个极小值。

然后就通过了这题。

### 代码
```cpp
#include<bits/stdc++.h>
#define min 1e-6
//极小值
#define int long long
//开long long
using namespace std;

signed main(){
    int n,x,c=0;
    double a=0,b=0;
	cin>>n;
	while(n--){
		cin>>x;
		b=log2(x);//对数函数
		if(a>b){
			x=ceil(a-(b+min));//精度控制 
			c+=x,b+=x;
		}
		a=b;
	}
	cout<<c;
}
```
### 闲话

[通过记录](https://www.luogu.com.cn/record/219885272)

~~管理给我过吧好不好~~

---


# 覆盖墙壁

## 题目描述

你有一个长为 $N$ 宽为 $2$ 的墙壁，给你两种砖头：一个长 $2$ 宽 $1$，另一个是 L 型覆盖 $3$ 个单元的砖头。如下图：

```
0  0
0  00
```

砖头可以旋转，两种砖头可以无限制提供。你的任务是计算用这两种来覆盖 $N\times 2$ 的墙壁的覆盖方法。例如一个 $2\times3$ 的墙可以有 $5$ 种覆盖方法，如下：
```
012 002 011 001 011  
012 112 022 011 001
```
注意可以使用两种砖头混合起来覆盖，如 $2\times4$ 的墙可以这样覆盖：
```
0112
0012
```
给定 $N$，要求计算 $2\times N$ 的墙壁的覆盖方法。由于结果很大，所以只要求输出最后 $4$ 位。例如 $2\times 13$ 的覆盖方法为 $13465$，只需输出 $3465$ 即可。如果答案少于 $4$ 位，就直接输出就可以，不用加前导 $0$，如 $N=3$ 时输出 $5$。


## 说明/提示

数据保证，$1\leq N\leq 1000000$。

## 样例 #1

### 输入

```
13```

### 输出

```
3465```

# 题解

## 作者：info___tion (赞：532)

这道题其实就是一道递推题目，但它的递推公式又很复杂。

不得不说，前面两位DALAO的解法都是对的，但他们没有讲到他们写的状态转移方程是怎么来的，所以这应该会让很多蒟蒻（包括笔者本人）一脸懵逼~~~。所以本人打算详细地讲一讲这一题。

下面开始进入题解：

------------
首先，既然是递推，那么分好状态就是一件非常重要的事情。这里本人直接讲状态。

（下文中的F\[N]表示**铺满**前N\*2的面积的墙的方案数；“一列”指长为1，宽为2的墙壁）

------------
1.当这面墙的最后一列被铺满时（如下图所示）

![](https://cdn.luogu.com.cn/upload/pic/18285.png
)

以这种状态结尾的方案数为F\[N-1]。

------------
2.当这面墙的最后两列被铺满时（如下图所示，注意颜色的区别）

![](https://cdn.luogu.com.cn/upload/pic/18286.png
)

以这种状态结尾的方案数为F\[N-2]。

------------
大家也看到，前两种状态很容易想到，也很容易描述。

但是，L形的瓷砖又怎么办呢？

~~（呵呵，刚开始想到这里的时候，我自己都蒙了。）~~

为了方便大家思考，我们先往简单的方向想。（**以下是重点！！！**）



------------


我们可以用一个数组G\[N]来表示**铺满前(N+1)\*2的面积的墙，但是第(N+1)列有一个瓷砖已经被铺过（注意，是已经被铺过！）**的方案数。

所以，L形瓷砖的问题就已经被“初步”解决了。

所以，下面这种情况的方案数就是G\[N-2]（因为实际上第N列已经铺满了，所以这里要处理的是前N-1列墙，所以多减了1）（如下图所示）:

![](https://cdn.luogu.com.cn/upload/pic/18287.png
)

同理，这一种情况的方案数也是G\[N-2]：

![](https://cdn.luogu.com.cn/upload/pic/18288.png
)

------------
OK,现在问题来了：这个G数组应该怎么维护呢？

不急，我们可以画图。

首先，第一种情况就是直接先让它变成一个长方形：

![](https://cdn.luogu.com.cn/upload/pic/18289.png
)

以这种状态结尾的方案数为F\[N-3]。

第二种情况是，加上一块砖后，它仍然不是一个长方形：

![](https://cdn.luogu.com.cn/upload/pic/18290.png
)

so,这第二种情况的方案数就是G\[N-3]（可能需要转一下弯，希望大家能弄懂）。

所以，G\[N-2]（注意，不是G\[N]）的方案数就等于F\[N-3]+G\[N-3]。

稍微化简一下，就可以得出：G\[N]=F\[N-1]+G\[N-1]。


------------
所以，F\[N]的转移方程就是：

F\[N]=F\[N-1]+F\[N-2]+2\*G\[N-2]（别忘了前面讲过G\[N-2]的情况有**两种**）

而G\[N]的转移方程就是：G\[N]=F\[N-1]+G\[N-1]。

初始化：F\[0]=1,G\[0]=0;F\[1]=G\[1]=1;

以下献上代码：

```cpp
#include<iostream>
using namespace std;

const int maxn=1000002;
const int mod=10000;

int f[maxn],g[maxn];

int main()
{
	int n;
	
	cin>>n;
	
	f[0]=1;	//g[0]=0
	
	f[1]=g[1]=1;
	
	for(int i=2;i<=n;i++)
	{
		f[i]=((f[i-1]+f[i-2])%mod+2*g[i-2]%mod)%mod;
		
		g[i]=(g[i-1]+f[i-1])%mod;
	}
	
	cout<<f[n];
	
	return 0;
}
```


------------


总而言之，这道题目所涉及的算法并不复杂，但很考验各位OIer的思维能力（特别是分类讨论和转化思想），这是一道好题！

---

## 作者：Lylighte (赞：226)

用如下两种砖块（可旋转）填充 $2\times n$ 的墙壁，求出不重复方案数，结果对 $10^4$ 取模。

![](https://cdn.luogu.com.cn/upload/image_hosting/m7vipknd.png)

按照惯例，定义  $F_n$ 为填满 $2\times n$ 墙壁的方案总数，边界条件 $F_0 = 1$，对于 $k<0$，$F_k=0$。（$F_0$ 表示无需再填，$F_k(k<0)$ 表示无意义情况）

考虑最后放的情况：

1. 放 $1$ 个 $2\times 1$ 的砖块（竖放）：显然它的方案数为 $F_{n-1}$；（图 1）

2. 放 $2$ 个 $2\times 1$ 的砖块（横放）：方案数为 $F_{n-2}$；（图 2）

3. 放 $1$ 个 L 型砖块（因为该砖块可以翻转着放，所以这样放的总方案数要 **乘**  $2$）：这么填会带来 $1$ 个格子的突出，如何消去这个突出？

   - 再放 $1$ 个 L 型砖块，恰好消去突出，方案数 $F_{n-3}$；（图 3-1）
   - 横放 $1$ 个 $2\times 1$ 的砖块，再放 L 型砖块，方案数 $F_{n-4}$（图 3-2）；
   - $2\times 1$ 的砖块可以交替着放下去，再补上一个 L 型砖块，从而消去这个突出。
   - 直到 $2\times 1$ 砖块和 L 型砖块恰好填满墙壁（$F_0$）。

   综上，最后放 $1$ 个 L 型砖块得到的方案数为 $2\times (F_{n-3}+F_{n-4}+\cdots+F_{0})$（已经乘了 $2$）。

综合 $3$ 种情况，得：
$$F_n=\left(\sum_{i=0}^{n-1}F_i\right)+\left(\sum_{i=0}^{n-3}F_i \right)$$
如果每次都重新算前 $n-1$ 个方案总和，很明显会超时。当然很容易能想到前缀和：

定义 $\texttt{preF}_n=\sum_{i=0}^{n}F_i$，即前 $n$ 个方案数之和。对于 $k<0$，$\texttt{preF}_k=0$。很明显得出 $\texttt{preF}_n=\texttt{preF}_{n-1}+F_n$。

那么之前的式子可以变成：
$$F_n=\texttt{preF}_{n-1}+\texttt{preF}_{n-3}$$
接着就~~愉快~~地写代码：

```cpp
#include <bits/stdc++.h>
int F[1000010];				//方案数
int preF[1000010];			//前缀和
int n;
int main(){
	std::cin >> n;
	F[0] = 1;
	preF[0]=1;
	for(int i=1; i<=n; i++){
		F[i]=(i-1<0?0:preF[i-1])+(i-3<0?0:preF[i-3]); 	//递推，特判 k<0 的情况
		F[i] %= 10000;									//保留后 4 位
		preF[i] = preF[i-1]+F[i];						//更新前缀和
		preF[i] %= 10000;
	}
	std::cout << F[n] << std::endl;		//直接输出就行了
	return 0;
}
```

附图（从上到下为图 1，图 2，图 3-1，图 3-2）：

![](https://cdn.luogu.com.cn/upload/image_hosting/wehhuvjg.png)

#### 2020/08/30 更新一下

来自[楼上玄学题解](https://www.luogu.com.cn/blog/_post/145804)很久以前的评论：

![](https://cdn.luogu.com.cn/upload/image_hosting/09lz5yf5.png)

~~人话翻译~~一下：

注意到计算 $F_k$ 和 $F_{k-1}$ 时都加上了许多相同的部分（具体见下）。

令 $n=k$，得

$$F_k=\left(\sum_{i=0}^{k-1}F_i\right)+\left(\sum_{i=0}^{k-3}F_i \right) =F_{k-1}+F_{k-2}+2\cdot F_{k-3} +2\cdot \left(\sum_{i=0}^{k-4}F_i \right).$$

令 $n=k-1$，得 

$$F_{k-1} = \left(\sum_{i=0}^{k-2}F_i\right)+\left(\sum_{i=0}^{k-4}F_i \right) = F_{k-2}+F_{k-3}+2\cdot \left(\sum_{i=0}^{k-4}F_i \right).$$

（相同的部分是什么应该能看清吧……）

上式减去下式，得到 $F_k - F_{k-1} = F_{k-1}+F_{k-3}$，

移项就得到 $F_k = 2\cdot F_{k-1}+F_{k-3}$。

于是这个递推式就得到化简了。

$$F_n=\left(\sum_{i=0}^{n-1}F_i\right)+\left(\sum_{i=0}^{n-3}F_i \right)=2\cdot F_{n-1}+F_{n-3}.$$

于是这篇题解更新完了。

~~希望 LaTeX 别炸呀~~。

---

## 作者：Juvenile (赞：116)

这是一道~~明显的~~递推题

**1.样例为13，我们可以先从1开始算**

得到：**dp[1]=1,dp[2]=2,dp[3]=5,dp[4]=11;**

2.（~~大雾） 这有什么卵用吗~~

如果不是一些十分明显的规律数列

那就 **不用想了** ~~开始瞎搞~~

经过一系列~~玄学~~操作

你就会惊奇的发现   咦？

#### dp[i]=dp[i-1]*2+dp[i-3]; ~~这个式子居然过了样例~~


这样的话，就放心的把它怼上去吧。。。



Code：
------------



```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1000009],n;
int main()
{
	dp[1]=1;
	dp[2]=2;
	dp[3]=5;
	scanf("%d",&n);
	for(int i=4;i<=n;i++)
	{
		dp[i]=(dp[i-1]*2)%10000+dp[i-3]%10000;
		dp[i]%=10000;
	}
	printf("%d\n",dp[n]);
	return 0;	
}
```

希望排版调过之后重审能过！！！谢谢管理员大大！！！

---

## 作者：中国飞鱼 (赞：32)

**很经典的dp，2维的dp[n][0/1]表示铺2\*n个格子\_剩下\_1~2空格时的最大方案数**

```cpp
#include<iostream>
using namespace std;
int n,dp[1000001][2];
int main()
{
    cin>>n;
    dp[0][0]=1;dp[1][0]=1;          初始化；
    for(int i=2;i<=n;i++)
    {
        dp[i][0]=(dp[i-1][1]+dp[i-1][0]+dp[i-2][0])%10000;
        dp[i][1]=(dp[i-1][1]+2*dp[i-2][0])%10000;
```
**通过画图观察发现铺满2\*n的方案数等于铺满2\*(n-2)的方案数与铺满2\*(n-1)的方案数与铺2\*(n-1)剩一个格子的方案数之和，比如下面（2\*3）用R表示已经覆盖的格子，G表示空格，理解一下~~**
**RRG**                    **RGG**                    **RRG**

**RRG**                    **RGG**                    **RGG**

**剩一个空格的情况留给大家自己思考，方程已经在上面了**

    }
    cout<<dp[n][0];

    return 0;

}

---

## 作者：不存在之人 (赞：13)

**解题思路：状压DP，以宽为行长为列从左到右dp，dp [ i ] [ j ]表示第 i 列状态为 j 的情况共有多少种情况。为描述方便，我用1代表格子被覆盖，0代表未被覆盖**

初始化：
              
              dp[1][0]=0;   //不会出现这种情况；
              dp[1][1]=0;   //不会出现这种情况；
              dp[1][2]=0;   //不会出现这种情况；
              dp[1][3]=1;   //放一块第一种砖头；
              dp[2][0]=1;   //放一块第一种砖头；
              dp[2][1]=1;   //放一块第二种砖头；
              dp[2][2]=1;   //放一块第二种砖头；
              dp[2][3]=2;   //放两块第一种砖头，有横着放和竖着放两种；
```cpp
#include<cstdio>
#include<cstring>
const int maxn=1000000+10;
int dp[maxn][4];
int main(void)
{
	int n;
	scanf("%d",&n);
	dp[1][0]=0;
	dp[1][1]=0;
	dp[1][2]=0;
	dp[1][3]=1;
	dp[2][0]=1;
	dp[2][1]=1;
	dp[2][2]=1;
	dp[2][3]=2;
	for(int i=3;i<=n;i++)
	{
		dp[i][0]=(dp[i-1][3])%10000;
		dp[i][1]=(dp[i-1][2]+dp[i-1][0])%10000;
		dp[i][2]=(dp[i-1][1]+dp[i-1][0])%10000;
		dp[i][3]=(dp[i-1][3]+dp[i-1][1]+dp[i-1][2]+dp[i-1][0])%10000;
	}
	printf("%d\n",dp[n][3]%10000);
}
```

---

## 作者：环日加速器 (赞：13)

# 很明显的递推~~水~~题
LJ给我们考这题时我在写递推式

~~一开始大雾~~

后来发现好简单

这是递推

原本以为大概是从前面几个状态转移过来的

```
#include<bits/stdc++.h>
using namespace std;
int f[10000019];
int main()
{
    int n;
    scanf("%d",&n);
    f[10]=1;
    for(int i=11;i<=n+10;i++)
    {
        f[i]=f[i-1]+f[i-2]+f[i-3]*2+f[i-4]*2……;
        f[i]=f[i]%10000;
    }
    cout<<f[n+10];
    return 0;
}
```

越写越不对，发现要用一个变量存从头到i-3的值
```
#include<bits/stdc++.h>
using namespace std;
int f[10000019],kkk=0;
int main()
{
    int n;
    scanf("%d",&n);
    f[10]=1;
    for(int i=11;i<=n+10;i++)
    {
        kkk+=f[i-3];
        kkk=kkk%10000;
        f[i]=f[i-1]+f[i-2]+kkk*2;
        f[i]=f[i]%10000;
    }
    cout<<f[n+10];
    return 0;
}
```
又想了一下，发现不用开f[n]的数组，因为只用前两个，所以我们就有了一个空间十分优秀的代码
```
#include<bits/stdc++.h>
using namespace std;
int kkk=0;
int main()
{
    int n,a=1,b=0,c=0,ans=0;
    scanf("%d",&n);
    for(int i=11;i<=n+10;i++)
    {
        kkk+=c;
        kkk=kkk%10000;
        ans=a+b+kkk*2;
        ans=ans%10000;
        c=b;
        b=a;
        a=ans;
    }
    cout<<ans;
    return 0;
}
```

不用开数组太爽了~

---

## 作者：cccgift (赞：9)

pascal的题解好少（事实上这题比较多）。

事实上，楼上各位的递推公式可以简化一下，变得更简单。

原来是f[n]=f[n-1]+f[n-2]+2g[n-2]和g[n]=g[n-1]+f[n-1]。

考虑f[n-2]=f[n-1]-f[n-3]-2g[n-3]，g[n-2]-g[n-3]=f[n-3]。

可得f[n]=2f[n-1]-f[n-3]+2(g[n-2]-g[n-3])=2f[n-1]+f[n-3]。

于是就很简单了，最近我正在学矩阵，就发一个矩阵的代码吧：

```pascal
const mo=10000;
type arr1=array[0..2] of int64;
     arr2=array[0..2,0..2] of int64;
var n,t:int64;
    f:array[0..2] of int64=(1,1,2);
    a:array[0..2,0..2] of int64=((0,0,1),(1,0,0),(0,1,2)); //构造矩阵
//矩阵乘法
procedure mul(var f:arr1;var a:array of arr1);
var i,j:longint;
    c:array[0..2] of int64;
begin
  fillchar(c,sizeof(c),0);
  for i:=0 to 2 do
    for j:=0 to 2 do
      c[i]:=(c[i]+f[j]*a[j,i]) mod mo;
  f:=c;
end;
procedure mulself(var a:arr2);
var i,j,k:longint;
    c:array[0..2,0..2] of int64;
begin
  fillchar(c,sizeof(c),0);
  for i:=0 to 2 do
    for j:=0 to 2 do
      for k:=0 to 2 do
        c[i,j]:=(c[i,j]+a[i,k]*a[k,j]) mod mo;
  a:=c;
end;
begin
  readln(n);
  while n>0 do
  begin
    if (n and 1)=1 then mul(f,a); //相当于n mod 2=1
    mulself(a);
    n:=n shr 1;
  end;
  writeln(f[0]);
end.
```

---

## 作者：AlexanderPitt (赞：8)

先看题意，给你长为n的墙壁，一共有几种覆盖方法？

这道题看完后很容易联想到走楼梯那道题（P1255）

可以通过递推（dp）来完成这道题

根据题意，覆盖墙壁的方法有
![](https://cdn.luogu.com.cn/upload/pic/51535.png )

画出来之后，能知道 


**长为N的墙壁覆盖方法数=长为N-1的墙壁覆盖方法数+2✖长为N-2多一个格子的墙壁覆盖方法数+长为N-2的墙壁的覆盖方法数**

所以我们得考虑多余一个格子的情况

之后我就想，既然要考虑多余的格子的情况，

**那我不如考虑已有N条边，我可以**

**（1）竖着摆2*1的砖头 **

         
                                           图1
**（2）横着摆两个2*1的砖头 **                            
                     
                                           图4

**（3）摆L型覆盖3个单元的砖头（有两种摆法）** 
         
                                           图2、3
                                           
                                          
                                          
**而在N条边多一个格子时候，我可以**

**（1）横着摆2*1的砖头 考虑N-1条边多一个格子的情况            （只有一种摆法）图5**

**（2）根据多余的格子位置摆一个摆L型覆盖3个单元的砖头（只有一种摆法） 没画图**

**想一想为什么**

下来这样做会TLE，想一想为什么，所以我们就要加上记忆化搜索
                                          
这样这道题的dp方程就出来了

if(不多余格子)

x[已覆盖的边长][判定是否有多余格子]=(dp(已覆盖的边长+1,没有多余格子)+**2**（L型砖块两种摆法）*dp(已覆盖的边长+1,有多余格子)+dp(已覆盖的边长+2,没有多余格子))%10000（题目要求输出覆盖方法的最后4位，如果不足4位就输出整个答案。）;

else if(多余格子）
x[已覆盖的边长][判定是否有多余格子]=(dp(已覆盖的边长+2,没有多余格子)+dp(已覆盖的边长+1，有多余格子))%10000;



然后这道题就做出来了

```cpp

#include<bits/stdc++.h>
using namespace std;
int n;
long int x[1000002][3];
long int dp(int ge,int pan)
{
    if(x[ge][pan]!=0)
    return x[ge][pan]%10000;
    if(ge==n&&pan==0)
    return 1;
    else if(ge>=n)
    return 0;
    if(pan==0)
    return x[ge][pan]=(dp(ge+1,0)+2*dp(ge+1,1)+dp(ge+2,0))%10000;
    if(pan==1)
    return x[ge][pan]=(dp(ge+2,0)+dp(ge+1,1))%10000;
    return 0;
}
int main()
{
    cin>>n;
    cout<<(dp(0,0))%10000;
    return 0;
} 
```

                                           
                              

---

## 作者：瞿葩 (赞：8)

很简单的一道递推题

递推公式: f[i]:=f[i-1]+f[i-2]+2\*g[i-2]

g[i]:=f[i-1]+g[i-1](f[i]表示用1\*2的砖头,g[i]表示用L型的砖头)

代码如下:

```delphi

var f,g:array[0..1000000] of longint;
    n,i:longint;
begin
  readln(n);
  f[0]:=1;
  f[1]:=1;
  g[0]:=0;
  g[1]:=1;
  for i:=2 to n do
  begin
    f[i]:=(f[i-1]+f[i-2]+2*g[i-2]) mod 10000;
    g[i]:=(f[i-1]+g[i-1]) mod 10000;
  end;
  writeln(f[n]);
end.

```

---

## 作者：xyn0901 (赞：2)

一道非常经典的递推

公式是 a[ i ]=a[ i-1 ]*2+a[ i-2 ]

但只要输出后四位 所以mod10000 就行了
```pascal
var a:array[1..1000000]of longint;
i,n:longint;
begin
read(n);
a[1]:=1;
a[2]:=2;
a[3]:=5;
for i:=4 to 1000000 do 
a[i]:=(a[i-1]+a[i-2]*3)mod 10000;
write(a[n]);
end.
```

---


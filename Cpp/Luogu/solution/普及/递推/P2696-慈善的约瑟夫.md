# 慈善的约瑟夫

## 题目描述

你一定听说过约瑟夫问题吧？即从 $N$ 个人中找出唯一的幸存者。现在老约瑟夫将组织一个皆大欢喜的新游戏，假设 $N$ 个人站成一圈，从第 $1$ 人开始交替的去掉游戏者，但只是暂时去掉，直到最后剩下唯一的幸存者为止。幸存者选出后，所有比幸存者号码高的人每人得到 $1$ 个金币，永久性离开。其余剩下的将重复以上的游戏过程，比幸存者号码大的人每人得到 $1$ 个金币后离开。经过若干轮这样的过程后，一旦人数不再减少，则最后剩下的那些人将得到 $2$ 个金币。请你计算一下老约瑟夫一共要付出多少钱？

## 说明/提示

1<=N<=100000


## 样例 #1

### 输入

```
10```

### 输出

```
13```

# 题解

## 作者：K0stlin (赞：48)

## 推公式
0,1,2,3,4……k，k+1，……M-1,共M个人中，要删除报数为k的人，假设最后的幸存者编号为X，则第一只被删除的人的编号一定是(K-1)%M，第一个人出圈后下一轮是:K,k+1……M-1，0,1……k-1,这M-1只人。把这个序号映射为以下编号
0,1,2,3,4……，k+1，……M-2，在这个序列中，假设最后的幸存者编号为Y，则X=(Y+K)%M

K→0    k+1→1   K+2→2

则有
```cpp
int what(int n,int k){
	int t=0;
	for(int i=2;i<=n;i++)t=(t+k)%i;
	return t+1;
}
```
main：
```cpp
int main(){
	scanf("%d",&n);
	while(1){
		int s=what(n,2);//交替出圈，所以k=2
		if(s==n){ans+=s*2;break;}//剩下的每人2元
		ans+=(n-s);//出去的发1元
		n-=(n-s);//该出去的出去
	}
	printf("%d",ans);
	return 0;
}
```
by 我的老师+我自己的思考

PS：因为一开始写错成猴子选大王了，与题意不符，改了一下，希望管理员再审一下。谢谢！

---

## 作者：hanjicheng (赞：29)


我们先从n个人的幸存者说起


设$j_n=n$个人的最后幸存者

```cpp
n   :|1|2,3|4,5,6,7|8,9,10,11,12,13,14,15|16……|

j_n :|1|1,3|1,3,5,7|1,3,5 ,7 ,9 ,11,13,17|1 ……|
```

注意我把$n$以及对应的$j_n$分为几段

对于任意一个$n$

可以发现$n$所在的那一段的起点是小于等于$n$的最大的$2^m$

引入一个新的量$l$，表示$2^m$与$n$的差

$n=2^m+l$

$j_n=j_{2^m+l}=2*l+1$(找规律，~~其实也可以反证法但我不会~~)

把$n$转为二进制

$b_i$为二进制的第$i$位的值($0$或$1$)

因为$l<2^m$

所以l的二进制的位数不超过$2^m$

所以$n$的位数为$m+1$，最高位为$1$

```cpp
n  =         (1      b[m-1] b[m-2]…… b[2] b[1] b[0])2 这个2只是
表示二进制

2^m=         (1      0      0     …… 0    0    0   )2 这里有m个
0

n-2^m=l=     (0      b[m-1] b[m-2]…… b[2] b[1] b[0])2

l*2=         (b[m-1] b[m-2] b[m-3]…… b[1] b[0] 0   )2

l*2+1=j(n)=  (b[m-1] b[m-2] b[m-3]…… b[1] b[0] 1   )2
```

$j_n$ $=$n的二进制将最高位去除$(-2^m)$再左移一位（乘以二）再加一

$j_n=(n-2^m)*2+1$

---

对于新约瑟夫问题

$ans=j(j(j(……j(j(n))……)))$,$ans$为最后剩下的人数

一直嵌套到$2^k-1$(因为$2^k-1$的二进制为$1111……1111$,他的$j_n$还是等于$n$

所以$ans=j(2^k-1)=j((111……11)2)=(111……11)2$    <--这个2只是表示二进制

因为在运算过程中，把最高位去掉，最高位后面的$0$都会被去掉，例如 $n=(10011)2$ , $j_n=(111)2$

而$1$不会被去掉，所以$2^k-1$二进制的$1$的个数为$n$的二进制等于$1$个数

于是公式就是$n$+((把$n$的二进制的所有$0$去掉)再变成十进制)*$2$  (先给$n$个人每人一块钱，再给最后剩下的$ans$个人每人一块钱)

有一个名叫
```cpp
__builtin_popcount()
```

的函数是用来数一个数的二进制有多少个1

把1左移_builtin_popcount(n)为得到的是一个数，二进制是1后面有
_builtin_popcount(n)个0

这个数减一后的二进制就是__builtin_popcount(n)个1

就等于$j(2^k-1)=ans$

所以程序为

```cpp
#include<iostream>
using namespace std;
int main()
{
   int n;
   cin>>n;
   cout<<n+(1<<__buitin_popcount(n)-1);
   return 0;
}
```
---

$update$ $on$ $2019/1/26$

---

## 作者：Vic_ (赞：11)

#正文部分

先把楼下的坑给填了（划去

先把问题放到经典的约瑟夫问题去，即m=2的约瑟夫问题

假设现在有x个人，那么当前要出列的第一个人必定是第二个（x>=2){OXOOOOOOO……}

当第二个人出列时，接下来剩下x-1个人。

如果这个时候你把剩下的人重新排列，也就是把前面m-1个人放到最后，然后重新标号1~m-1，你就会发现，又变成了n-1的约瑟夫问题。

像这样一直递推求出n-1的答案后，由于之前编号有所变动（（i-2+n)%n），固还要对n-1的答案进行操作一番才能变成n的答案

递推式：f[i]=(f[i-1]+m)%m

那么目前这个问题就非常的好些了



```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>inline void read(T &x)
{
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x*=10,x+=ch-'0',ch=getchar();
};
template <typename T>inline void print(const T x)
{
    if(x>=10)print(x/10);
    putchar('0'+(x%10));
};
template<typename T>inline void printfn(const T x){print(x);putchar('\n');}//以上皆为读优输优，模板套路而已
int f[100001];
int n;
int main()
{
    read(n);
    f[1]=1;
    for(register int i=2;i<=n;i++)
        f[i]=(f[i-1]+1)%i+1;//预处理出f数组
    int ans=0;
    while(1)//递归出n的位置
    {
        if(n==f[n])
        {
            ans+=n*2;
            break;
        }
        ans+=(n-f[n]);
        n=f[n];
    }
    printfn(ans);
}
```
#题外话系列（关于约瑟夫问题的小优化）
问题是这样的：给你T组数据，每组数据给你约瑟夫问题里的n和m，要你求出剩下的那个人的编号

数据范围，T<=20,n<=1e9,m<=1e5

如果你按照上面这个公式纯暴力推算的话是会炸的

时间复杂度O（Tn），稳稳的特勒额（TLE）

而且如果你还要专门开一个f数组，那就是稳稳的膜勒额

那么如何?

先观察这个过程。题目并不要求我们求出每次的值，因此没有必要存储每个f数组，只要用一个变量维护就行了

再，观察我们的公式，每次都是+m然后再%m。那是不是可以优化每次+m的这个过程呢？

用一个变量来表示当前这个答案在小于n的情况下能加几次m（rem=(i-ans)/m）

那么每次操作的时候直接将ans+m\*rem,然后再将i加上rem

这里需要有一个特判，如果i加上rem大于了n，那么就只用将rem赋为（n-i）就行了

此题代码


```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>inline void read(T &x)
{
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x*=10,x+=ch-'0',ch=getchar();
};
template <typename T>inline void print(const T x)
{
    if(x>=10)print(x/10);
    putchar('0'+(x%10));
};
template<typename T>inline void printfn(const T x){print(x);putchar('\n');}
int n,m;
int main()
{
    int T=0;
    read(T);
    while(T--)
    {
        n=0,m=0;
        read(n),read(m);
        int ans=1;
        for(register int i=2;i<=n;i++)
        {
            ans=(ans+m-1)%i+1;
            int rem=(i-ans)/m;
            if(i+rem>n)rem=n-i;
            ans+=rem*m;
            i+=rem;
        }
        printfn(ans);
    }
}
```
##小结
1.大胆猜测。随便推，随便想，不要局限自己的想象力（lb力），说不定就对了

2.不要忽略一点点小的优化。别看这个优化这么微不足道，好写也好想，但数据一大就能带来不一样的惊喜

我这是不是全luogu最长的题解。。。。



---

## 作者：wuwenjiong (赞：8)

## 题目：
有 $n$ 个人围成一圈，从第 $1$ 人开始交替的去掉游戏者，但只是暂时去掉，直到最后剩下唯一的幸存者为止。幸存者选出后，所有比幸存者号码高的人每人将得到 $1$ 块钱，并且永久性地离开，其余剩下的人将重复以上过程，比幸存者号码高的人每人将得到 $1$ 块钱后离开。一旦经过这样的过程后，人数不再减少，最后剩下的那些人将每人得到 $2$ 块钱。请计算一下一共要付出多少钱？
### 样例说明：
这里为了简单，我选择一个简单的样例来说明。

样例输入:
```cpp
5
```
样例输出：
```cpp
8
```
第一轮，按顺序出去了 $2,4,1,5$ 号游戏者，剩下 $3$ 号，比三号序号大的人有 $4,5$ 号，所以 $4,5$ 号每人获得 $1$ 个金币，并永久离开。 第二轮，按顺序又出去了 $1,2$ 号游戏者，但是由于 $1,2$ 号比幸存者 $3$ 号编号要小，所以再也不会有人离开了，那么这三人都获得 $2$ 个金币。总计： $2+2\times3=8$ 元，故输出 $8$ 。

题目不难，直接**模拟**。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];//注意数据范围
int num,f,n,s,x;
int main()
{
	cin>>n;
	while(1)//死循环
	{
		num=n;
		x=f=0;
		memset(a,0,sizeof(a));
		while(num!=1)//num为计数器
		{
			x++;//x为当前排到的游戏者序号
			if(x>n)//如果序号大于n，就已经绕完了一圈，得重新计序号
				x-=n;
			if(a[x]!=0)//用数组记录状态，0表示未离开
				continue;
			f++;
			if(f==2)//当到了第2人时，开始处理
			{
				f=0;
				a[x]=1;
				num--;
			}
		}
		for(int i=1;i<=n;i++)//查找那个幸存者
			if(a[i]==0)
			{
				if(i==n)//当幸存者序号是最大的时，输出
				{
					cout<<s+i*2;
					return 0;
				}//否则处理这轮结果，开始下一轮
				s=s+n-i;
				n=i;
				break;
			}
	}
	return 0;
}
```
谢谢！！！

---

## 作者：_lfxxx_ (赞：7)

**题目传送门：[P2696 慈善的约瑟夫](https://www.luogu.com.cn/problem/P2696)**

~~这题是我们今天考试T5，发篇题解纪念一下。~~
### 思路：
**纯模拟**。

这题只是多模拟几遍约瑟夫而已，不是非常难。

我选择了用[队列](https://blog.csdn.net/zichen_ziqi/article/details/80819939)做这道题，因为这样能省去很多细节，容易调试。

~~STL大法好！~~

**用 ans 记录钱， a 表示幸存者。**
### 核心代码：
```cpp
ans=n;//每个人先算一元
while(1){
	for(int i=1;i<=n;i++)
		q.push(i);//将1~n放进队列中
	for(int i=1;i<n;i++){//淘汰n-1个人
		q.push(q.front());
		q.pop();
		q.pop();
	}//按约瑟夫的方法模拟。
   //如 5 4 3 2 1，模拟过一遍后是 1 5 4 3。
	int a=q.front();
	if(n==a){//幸存者是n号说明没法淘汰人了
		ans+=n;//这n个人少算1元，加回来这少的
		break;//结束
	}
	n=a;//总人数变为n
    q.pop();//弹出幸存者，为下一次做准备
}
```
用时和内存： $\texttt{53ms/964.00KB}$ 。比找规律慢不了多少。~~我说这题怎么会出现在递推的考试中~~

更新：

`2021-05-08`：中间的统计钱优化了一些。

---

## 作者：20213116lyd (赞：7)

**听说本题题解很多，本人发现了一种~~奇葩~~的递推式。**

**先~~手动~~枚举** n 个人中第一个幸运儿的编号

**2个人 —> 1为幸运儿**

  3 -> 3

  **4 -> 1**

  5 -> 3

  6 -> 5

  7 -> 7

  **8 -> 1**
  
  发现规律没

  9 -> 3

  10 -> 5

  11 -> 7

  12 -> 9

  ...

  **16 -> 1**

  ### 2^n -> 1

  ### 没错，当人数 n 为**2的幂数**时，第一个幸运儿都会是 1
 
  ### 后面的就依次为公差为 2 的等差数列（1,3,5,7,9...），直到下一个2的幂数

  设 f[n] 为n个人所需的钱数

### 当n为2的幂时 比 1 大的全部淘汰 最后 1 号得到2金币，其余得1金币 所以 

### f[n] = n+1

### 当n不为2的幂时，通过等差数列，轻易求出第一个幸运儿 k，

### f[n] = f[k]+(n-k) //大于k的全部淘汰，剩下1-k，就是f[k]

### 还有一种特殊情况，当n== 2^n-1时 幸运儿的就是n 所以每个人得两个 金币

### f[n] = n*2


```cpp
#include <cstdio>
long long a[105],b[65540]={0,0,2,6}; //前面四个打表
int main() {
	for(int i=1;i<=30;++i) {
		a[i]=1<<i;       //利用位运算枚举2的幂
	}
	int n;
	scanf("%d",&n);
	int p=2,k=1;
	for(int i=4;i<=n;++i) {
		if(i==a[p]) {
			p++;
			k=1;
			b[i]=i+1;
		}
		else if(i==a[p]-1) b[i]=2*k;
		else b[i]=b[k]+(i-k);
		k+=2;
	}
	printf("%lld",b[n]);
	return 0;
}
```


---

## 作者：MuYC (赞：6)

```cpp
/*关于这道题，我是用类似链表的处理方式A的，首先，我们储存下所有人对应的下一个人，然后在处理过程中不断更新，通过这里的处理来减少时间复杂度*/
#include <bits/stdc++.h>
bool book[100200];
bool b[100040];
long long  a[100005];
using namespace std;
int main(){
	long long i,j,k,n,m,next=0,ji=0,l,res=0,t,p;
	cin>>n;
	m=n;
	t=n;
	for(i=0;i<=n-1;i++)
	a[i]=i+1;//预处理，对应的下一个人
	a[n]=1;
	while(1){
		if(next!=0)//特判，我是从0开始用的next
		l=next;
		else l=1;
		next=a[next];//更新此时的人的标号
		ji++;
		if(ji==2){//如果数数到了2，next号人暂时出去
			ji=1;
			book[next]=1;
			next=a[next];
			a[l]=next;//更新对应的下一个人
			m--;//幸存人数--
		}//如果此时只剩下一个人了
	if(m==1){
		for(i=1;i<=n;i++)
		if(book[i]!=1){
			p=i;
			break;
		}//判断幸存者
		if(p==n||b[p+1]==1){
			res+=t*2;
			break;
		}//如果再进行不会有人出去了
		for(i=p+1;i<=n;i++)
		b[i]=1,res++,t=p;//更新答案以及标记出去的人
		for(i=0;i<=p-1;i++)
		a[i]=i+1;//重复一开始的预处理
		for(i=1;i<=n;i++)
		book[i]=0;
		a[p]=1;//所有东西都清零
		next=0;
		ji=0;
		m=p;//进行下次数数的预处理
		n=p;	
	}
}
	cout<<res;//输出答案
	return 0;
}
```

---

## 作者：hukk (赞：5)

这是本蒟蒻的第一篇题解。
## 分析
首先，我们来读读题：

+ 假设几个人站成一圈
+ 从第1人开始交替的去掉游戏者，但只是暂时去掉，直到最后剩下唯一的幸存者为止
+ 幸存者选出后，所有比幸存者号码高的人每人得到1个金币，永久性离开
+ 其余剩下的将重复以上的游戏过程，比幸存者号码主的人每人得到1个金币后离开
+ 经过这轮的过程后，一旦人数不再减少，则最后剩下的那些人将得到2个金币

有点晕？我们来看看这张图（图中红字为每轮出圈顺序）：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/ekjn4ulj.png)

当有 5 个人时：

+ 首轮出圈顺序为： 2→4→1→5 ， 3 为幸存者。

+ 然后， 4、5 分别得到 $1$ 个金币并离开，剩下 3 。

+ 接着第 2 轮出圈顺序为： 2→1 ， 3 为幸存者。

+ 此时无人离开， 1、2、3 分别得到 $2$ 个金币，游戏结束。

## 思路
按照题意直接模拟出游戏过程，并累加金币。

## 代码
比较朴素，码风可能不是那么优美，大佬轻喷。
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
bool a[100010];//用来标记每轮出圈者
int main(){
	int n,k,p=0,l=0,s=0;
	cin>>n;
	while(1){
		memset(a,0,sizeof(a));//注意标记每轮开始前都需要初始化
		l=0;k=n;p=0;//变量初始化
		while(k>=1){//重复执行直到最后一个人（注意>=来标记最后出圈的人,实际上是让所有人都出圈）
			p++;//p是每个人的序号
			if(p>n)p=1;//防止溢出
			if(a[p]==0)l++;//只记录没有出圈的人
			if(l==2){//每隔一个人出圈（第二个在圈内的人）
				a[p]=1;//标记为已出圈
				k--;//在圈内的人数减1
				l=0;//这里要记得初始化
			}
		}
		if(n-p==0)break;//当没有出圈的人时退出循环
		s+=n-p;//金币累加（n-p即为出圈人数）
		n=p;//使出圈者出圈，进入下一轮
	}
	s+=n*2;//未出圈者拿到2个金币
	cout<<s;
	return 0;
}
```

---

## 作者：光明正大 (赞：5)

# 翻了翻题解，发现大部分都是递推
# 我就来发一篇极简洁的模拟
### 用next[i]表示i后面的人的编号
### 比如next[1]=2,next[2]=3
### 删除2就令next[1]=next[2]
### 另外用sur记录本轮幸存者
### lsur记录上轮幸存者
### 然后就可以开始愉快地模拟了

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sur,lsur,next[10100];
int main()
{
    cin>>n;sur=n;
	for(int i=1;i<=n;i++) next[i]=i+1;next[n]=1;//处理每个人的后继 
    while(lsur!=sur)//如果这两轮幸存者相同则结束 
    {
        lsur=sur;
        for(int i=1;;i=next[i])
        {	
            next[i]=next[next[i]];//间隔删除人,看不懂的拿纸和笔模拟一下就行了 
            if(i==next[i]) {sur=i;break;}//若只剩一个人则结束 
        }
        for(int i=1;i<=sur;i++) next[i]=i+1;next[sur]=1;//再次处理每个人的后继 
    }
    cout<<lsur+n;//lsur*2+(n-lsur) 
    return 0;
}
```
请不要直接复制提交！！！


---

## 作者：银河AI (赞：3)

### 解题思路

看这个数据，模拟是打不过了，那我们考虑找规律。


对于这类问题，我们有递推式：

$f[i\times 2]=2 \times f[i]-1,f[i\times 2+1]=2\times f[i]+1$

其中 $f[i]$ 表示 $i$ 个人最后出圈的那个人的编号，初始化 $f[1]=1$

我们发现，当 $f[i]=i$ 的时候，人数不会减少。

所以接下来的代码就很简单了。

### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+1;
int n;
int f[N],ans;
int dfs(int x){
	if(x==f[x]) return f[x];
	dfs(f[x]);
}
int main(){
	scanf("%d",&n);f[1]=1;
	for(int i=1;i<=n;i++) f[i*2]=2*f[i]-1,f[i*2+1]=2*f[i]+1;
	printf("%d",dfs(n)+n);
}
```

---

## 作者：cms061817 (赞：3)

```cpp
//这道题是约瑟夫系列的问题
//当然有人会直接使用模拟，但很可惜，n<=100000
//超时~\(≧▽≦)/~，所以需要使用另一种方法
//看过具体数学这本书的OIer就能顺利的求解
//对于两人轮流出列的此类问题有递推公式：
//f[1]=1;f[2n]=2f[n]+1; f[2n+1]=2f[n]-1;  f[n]表示n个人最后出圈的那个
//至于怎么推的这里就不详细解释了╮(╯▽╰)╭不好意思╮(╯﹏╰)╭ 
#include<cstdio>
int f[200000];
int main(){
    int n;
    scanf("%d",&n);
    f[1]=1;
    for(int i=1;i<=n;i++){
        f[2*i]=2*f[i]-1;
        f[2*i+1]=2*f[i]+1;
    }
    int sum=0;
    while(f[n]!=n){
        int k=f[n];
        sum+=n-k;
        n=f[n];    
    }
    sum=sum+f[n]*2;
    printf("%d",sum);
    return 0;
}
```

---

## 作者：Heap_Sort (赞：1)

我来给Pascal写个题解(本蒟蒻的第一篇题解，
~~大佬勿喷~~）

由题意可知，每个人都至少得到一块钱，所以可以先使每个人都得到一块钱，再算多出的部分。

当某次报数后人数不再改变，则中止报数。

经过~~长久的~~找规律之后，可以发现，当剩余的人数为2的次方时，幸存者号码总是1；其他情况下，幸存者的号码是人数少1时的幸存者号码+2。

~~然后......就没有然后了(手动滑稽)~~

上代码
```pascal
var
  n:longint;
function bs(q:longint):longint;//当前人数下的报数情况
var
  i,j,k:longint;
begin
  i:=1;
  j:=1;
  while j*2<=q do j:=j*2;//最接近的2的次方数
  for k:=1 to q-j do i:=i+2;//根据规律算出幸存者编号
  bs:=0;
  if i=q then bs:=q else bs:=bs(i);//如果当前幸存者号码最大,则结束报数,得到两元的人数为当前人数;否则继续报数
end;
begin
  readln(n);
  writeln(n+bs(n));//每个人都得1元+幸存人多得1元
end.
```


---

## 作者：tmp27 (赞：1)


大体思路
首先，每个人都一定会得到 $1$ 块钱（，只有最后的那些幸存者会得到 $2$ 块钱，所以，我们只要求出最后幸存几个人就好了。假设经过 $x$ 次出圈操作后还剩 $final(x)final(x)$ 个人，这个时候人数绝对不会减少了，所以这个问题的正解是 $final(x)+nfinal(x)+n$ ，加上一个 $n$ 是什么意思呢？就是其余的，淘汰的那些人得到的钱数。
设 $a$ 数组为 $i$ 个人的圈报数后的幸存者编号，设报到 kk 的人出去，则 $a[i-1]a[i?1]$ 可以理解为第 11 轮第 11 次报数， kk 出去后的状态。 kk 出去后会从 k+1k+1 继续报数，此时圈中 有 i-1i?1 个人，从 k+1k+1 开始报数，编号$a[i]$为： k+1,k+2,...i,1,2,...k-1k+1,k+2,...i,1,2,...k?1 。
```
代码
AC 代码：
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,a[100001],ans;//n用来存储游戏的人数，a数组用来存经过x次出圈操作后剩余的人的编号，ans用来存给了存活者编号小给了多少2元 
int final(int x){//final函数用来记录还剩多少个人 
    if(x==a[x])// 如果第x次x=a[x]时，人数就不会再减少了 
        return a[x];//将a[x]返回 
    final(a[x]);//递推，调用final的a[x] 
}
int main(){
    cin>>n;//将人数输入 
    a[2]=1;//a[2]必有1个人 
    for(int i=3;i<=n;i++)//进行上一段代码x+1次循环 
        a[i]=(a[i-1]+1)%i+1;//计算经过i次出圈操作后剩余的人的编号
    ans=final(n);//将ans赋值为剩余人数 
    cout<<n+ans<<endl;//将n+ans输出（注意！ans只是2元*获胜人数，还有一些暂时离开的人得了1元的钱没有加上，所以要加上） 
    return 0;//结束程序 
}
```




---


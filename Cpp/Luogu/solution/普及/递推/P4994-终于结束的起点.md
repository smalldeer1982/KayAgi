# 终于结束的起点

## 题目背景

> 终于结束的起点  
> 终于写下句点  
> 终于我们告别  
> 终于我们又回到原点  
> ……

一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。  
如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。  
如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。  
也许这是你最后一次在洛谷上打比赛，也许不是。  
不过，无论如何，祝你在一周后的比赛里，好运。

当然，这道题也和轮回有关系。

## 题目描述

广为人知的斐波拉契数列 $\mathrm{fib}(n)$ 是这么计算的

$$
\mathrm{fib}(n)=\begin{cases}
0,& n=0 \\
1,& n=1 \\
\mathrm{fib}(n-1) + \mathrm{fib}(n-2),& n>1
\end{cases}
$$

也就是 $0, 1, 1, 2, 3, 5, 8, 13 \cdots$，每一项都是前两项之和。

小 F 发现，如果把斐波拉契数列的每一项对任意大于 $1$ 的正整数 $M$ 取模的时候，数列都会产生循环。

当然，小 F 很快就明白了，因为 ($\mathrm{fib}(n - 1) \bmod M$) 和 ($\mathrm{fib}(n - 2) \bmod M)$ 最多只有 $M ^ 2$ 种取值，所以在 $M  ^ 2$ 次计算后一定出现过循环。

甚至更一般地，我们可以证明，无论取什么模数 $M$，最终模 $M$ 下的斐波拉契数列都会是 $0, 1, \cdots, 0, 1, \cdots$。

现在，给你一个模数 $M$，请你求出最小的 $n > 0$，使得 $\mathrm{fib}(n) \bmod M = 0, \mathrm{fib}(n + 1) \bmod M = 1$。

## 说明/提示

#### 样例 1 解释

斐波拉契数列为 $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \cdots$，在对 $2$ 取模后结果为 $0, 1, 1, 0, 1, 1, 0, 1, 1, 0, \cdots$。

我们可以发现，当 $n = 3$ 时，$f(n) \bmod 2= 0, f(n + 1) \bmod 2 = 1$，也就是我们要求的 $n$ 的最小值。

#### 数据范围

对于 $30\%$ 的数据，$M \leq 18$；

对于 $70\%$ 的数据，$M \leq 2018$；

对于 $100\%$ 的数据，$2 \leq M \leq 706150=\verb!0xAC666!$。

#### 提示

如果你还不知道什么是取模 $(\bmod)$，那我也很乐意告诉你，模运算是求整数除法得到的余数，也就是竖式除法最终「除不尽」的部分，也即
$$a \bmod M =k \iff a = bM + k\ (M > 0, 0 \leq k < M)$$
其中 $a, b, k$ 都是非负整数。

如果你使用 `C` / `C++`，你可以使用 `%` 来进行模运算。

如果你使用 `Pascal`，你可以使用 `mod` 来进行模运算。

## 样例 #1

### 输入

```
2```

### 输出

```
3```

## 样例 #2

### 输入

```
6```

### 输出

```
24```

# 题解

## 作者：CzxingcHen (赞：53)

说一下暴力为什么是对的  
早上打了一个$1 - 50$的表看了$20$分钟没找到规律，有点自闭。   
打开OEIS输了几项进去，发现这个数列是存在的，然后就把我引向了这个词条  [皮萨诺周期](https://zh.wikipedia.org/wiki/%E7%9A%AE%E8%90%A8%E8%AF%BA%E5%91%A8%E6%9C%9F)   
感觉wiki好像不怎么好上，截几张图出来好了    
![](https://cdn.luogu.com.cn/upload/pic/41960.png)  
![](https://cdn.luogu.com.cn/upload/pic/41963.png)
![](https://cdn.luogu.com.cn/upload/pic/41964.png)
![](https://cdn.luogu.com.cn/upload/pic/41966.png)    
就这么一脸愣逼地看完了$\pi (n) \leq 6n$的证明。
然后就可以愉快地暴力了。

---

## 作者：万弘 (赞：29)

正如另几位大佬所说，此题没有什么规律  

那怎么办办？

### 暴力呀！

题目中已经把递归式告诉你了  
照着打就行
```cpp
typedef long long ll;
ll f(ll i)
{
	if(i==1||i==2)return i%m;
    else return (f(i-1)+f(i-2))%m;
}
```

但人家还是有月赛题的尊严的！！

这样打会TLE

但作为T1，加个记忆化就OK，不用优化空间


```cpp
#include<cstdio>
typedef long long ll;
using namespace std;
const ll INF=0x7fffffff;
ll fp[10000002];//记忆数组，虽然m不大但是不知道n多大，尽量开大，不过1千万差不多极限
ll m;
ll f(ll i)
{
    if(fp[i])return fp[i];//调取记忆
    if(i==1||i==2)return fp[i]=1%m;
    else return fp[i]=(f(i-1)+f(i-2))%m;//这时就顺带%m可以使主程序更简单
}
int main()
{
    scanf("%lld",&m);
    ll i=1;//枚举
    while(f(i)!=0||f(i+1)!=1)//题目要求
    {
        i++;
    }
    printf("%lld",i);
    return 0;
}
```

---

## 作者：a13518354766 (赞：22)

这道题,发现暴力能过时,喷了3k的血。。。本人花了近半小时打表找规律。。。然后真找出来一些了。。。

1.f[x^n]=f[x]*(x^(n-1))

2.设x,y为不相同的质数,则f[x^a*y^b]=lcm(f[x^a],f[y^b])。

3.对于一个质数x,他的f[x]极小(似乎都很小??)

对于一个n,我们就可以将他进行质因数分解:设n=x^a*y^b*...

然后我们暴力求出f[x],f[y],套上规律一,求出f[x^a],f[y^b],再套规律二,就可以求出来了。。。

分析:因为n<=706150,所以我们最多只需要暴力7个素数,而经试验,每个素数的f最多只有自身的2倍多(除了5是4倍。。。)
所以暴力运行次数最多为14*n(稳过。。。)

对于求f[x^a]套个log的快速幂,lcm也是log...所以,所有数据都是稳过的。。。

奉上代码:

    #include<bits/stdc++.h>
    using namespace std;
    const int N=10000000;
    int M;
    bool is_not_prime[N];
    int f[N],zhi[N],e;
    inline void sai(int maxe){
        for(int i=2;i<=maxe;++i){
            if(!is_not_prime[i]){
                zhi[++e]=i;
                for(int j=i;j<=maxe/i;++j){
                    is_not_prime[i*j]=1;
                }
            }
        }
    }
    inline int gcd(int x,int y){
        return x%y==0?y:gcd(y,x%y);
    }
    inline int lcm(int x,int y){//lcm
        return x/gcd(x,y)*y;
    }
    inline int bl(int x){//暴力计算
        f[1]=1;
        for(int i=2;i;++i){
            f[i]=f[i-1]+f[i-2];
            f[i]%=x;
            if(f[i]==1&&f[i-1]==0){
                return i-1;
            }
        }
    }
    inline int ksm(int x,int y){
        int ans=1;
        while(y){
            if(y&1){
                ans*=x;
            }
            x*=x;
            y>>=1;
        }
        return ans;
    }
    inline int div(int x){
        int ans=1;
        for(int i=1;i<=e;++i){
            if(zhi[i]>x){
                break;
            }
            if(x%zhi[i]==0){//分解质因数
                int tim=0;
                while(x%zhi[i]==0){//求幂
                    tim++;
                    x/=zhi[i];
                }
                int ti=bl(zhi[i]);
                ti*=ksm(zhi[i],tim-1);
                ans=lcm(ans,ti);
            }
        }
        return ans;
    } 
    int main(){
        //2^n=3*2^(n-1)
        //3^n=8*3^(n-1)
        //5^n=20*5^(n-1)
        sai(706150);//筛法筛质数
        int x;
        scanf("%d",&x);
        printf("%d\n",div(x));
        return 0;
    }

---

## 作者：Cheng_yf (赞：11)

# 数论大法好！！！

对于一个正整数n，我们求Fib数模n的循环节的长度的方法如下：

***（1）把n素因子分解，即n=p1^a1*p2^a2...pk^ak **

**（2）分别计算Fib数模每个p^m的循环节长度，假设长度分别是x1,x2……xk**

**（3）那么Fib模n的循环节长度l=lcm(x1,x2,x3...,xk)**

从上面三个步骤看来，貌似最困难的是第二步，那么我们如何求Fib模p^m的循环节长度呢？

这里有一个玄学的定理：
**Fib数模p^m的最小循环节长度等于G(p)*p^(m-1)，其中G(p)表示Fib数模素数的最小循环节长度。可以看出我们现在最重要的就是求G(p)**

对于G(p)求我们利用如下定理：
**如果5是模p的二次剩余，那么循环节的的长度是(p-1)的因子，否则，循环节的长度是2*(p+1)的因子。**

顺便说一句，对于小于等于5的素数，我们直接特殊判断，**loop(2)=3,loop(3)=8,loop(5)=20。**

那么我们可以先求出所有的因子，然后用矩阵快速幂来一个一个判断，这样时间复杂度不会很大。
### code:
```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define pb push_back
#define sd second
#define ft first 
typedef long long ll;
using namespace std;
int T,n;
const ll INF=1e18;
map<ll,ll>S;
inline ll power(ll a,ll b,ll mod){
    int rs=1;a=a%mod;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)rs=1ll*rs*a%mod;
    return rs;  
}
inline ll gcd(ll x,ll y){return y?(gcd(y,x%y)):x;}
typedef pair<int,int> pii;
namespace SP1{
    vector<pii>fac;
    ll nowlen,M;
    inline void mul(ll *a,ll *b,ll mod){
        unsigned long long bd=a[0]*b[0],bc=a[0]*b[1],ad=a[1]*b[0],ac=a[1]*b[1];
        a[1]=(bc+ad+ac)%mod,a[0]=(bd+ac)%mod;
    }
    inline void power_p(ll *a,ll b,ll mod){
        ll c[2]={1,0};
        for(;b;b>>=1,mul(a,a,mod))
            if(b&1)mul(c,a,mod);
        a[0]=c[0];a[1]=c[1];
    }
    inline bool check(ll sum){
        ll b[2]={0,1};
        power_p(b,sum,M);
        return b[1]==0&&b[0]==1;
    } 
    inline void dfs(int pos,ll sum){
        if(pos==fac.size()){
            (sum!=1&&check(sum))?(nowlen=min(nowlen,sum)):0;
            return;
        }
        ll rs=1;
        for(int i=0;i<=fac[pos].sd;++i){
            dfs(pos+1,sum*rs);
            rs*=fac[pos].ft;
        }
    }
    inline ll getlen(ll x){
        if(x==2)return 3;
        if(x==3)return 8;
        if(x==5)return 20;
        if(S.find(x)!=S.end())return S[x];
        ll base=(power(5,(x-1)/2,x)==1)?(x-1):(2*x+2);
        fac.clear();nowlen=INF;M=x;
        for(int i=2;i*i<=base;++i){
            if(!(base%i)){
                pii t=mp(i,0);
                while(!(base%i))base/=i,++t.sd;
                fac.pb(t);
            }
        }
        if(base!=1)fac.pb(mp(base,1));
        dfs(0,1);return S[x]=nowlen;
    }
}
vector<pii>fac;
ll ans;
inline void solve(int n){
    if(n==1){puts("1");return;}
    fac.clear();
    for(int i=2;i*i<=n;i++){
        if(!(n%i)){
            pii t=mp(i,0);
            while(!(n%i))n/=i,++t.sd;
            fac.pb(t);
        }
    }
    if(n!=1)fac.pb(mp(n,1)); 
    ans=1;
    for(int i=0;i<fac.size();++i){
        ll l=SP1::getlen(fac[i].ft);
        l=l*power(fac[i].first,fac[i].second-1,INF);
        ans=(ans*l)/gcd(ans,l);
    }
    printf("%llu",ans);
}
int main(){
    scanf("%d",&n);
    solve(n);
    return 0;
}
//珍爱生命，远离抄袭
```

---

## 作者：Misaka19280 (赞：11)

oh,sh_t

这题告诉我们一个基本事实

暴力出奇迹

我首先先把m为2-100的打表打了出来

然后___规律都没找到

![](https://cdn.luogu.com.cn/upload/pic/41924.png)

苦思冥想半小时

我觉得

是不是根本就没规律啊

就把m开到1000

统计m和ans的倍数关系

发现没有倍数超过7的

嘻嘻嘻嘻

所以这是不是一个裸暴力呢

试试1W

哎嘿嘿

也是的

然后我就写了个10W的，也没有到7的

于是就搞出1-m*7的数列就可以过了

```
Const 
	maxm=706150;

Var
	a:array[0..maxm*7]of longint;
	n,m,i,max:longint;
	
Begin
	readln(m);
	a[0]:=0;
	a[1]:=1;	
	a[2]:=1;
	for i:=3 to m*7 do
		begin
			a[i]:=((a[i-1] mod m)+(a[i-2] mod m)) mod m;
			if (a[i]=1) and (a[i-1]=0) then
				begin
					writeln(i-1);
					break;
				end;
		end;
End.
```

这题告诉我们

## 暴力出奇迹！

# 最后祝大家NOIP2018 RP++

---

## 作者：Catalan1906 (赞：7)

希望是这道题的第一篇题解，~~并且真的做到了！~~

upd 2018/11/4：规律补锅，让代码更加易懂

---

本来月赛时想打个表，打到一半，发现$n$稳定在$m$附近？

题目的意思是$n < m ^ 2$，实际上$n < kn, k \approx 6$

所以暴力即可，然后……

记得开longlong，不开longlong爆零见祖宗
---
code:
```
#include <cstdio>
#include <vector>
#define ll long long

int main()
{
    ll n = 1, m;
    // 此处的n没什么用，后面会用f.size()
    scanf("%lld", &m);
    std :: vector < ll > f;
    f.push_back(0);
    f.push_back(1);
    for(; f[f.size() - 2] != 0 || f[f.size() - 1] != 1 || f.size() == 2;)
        f.push_back((f[f.size() - 2] + f[f.size() - 1]) % m);
    // for循环写的有些诡异……不过仔细研究一下就明白了
    // 提醒：f.size() == 2时，f(0) == 0, f(1) == 1，但0不是正整数
    printf("%lld", f.size() - 2);
    // f.size() - 2，因为要求的是f(n) == 0 && f(n + 1) == 1 , 而不是f(n - 1) == 0 && f(n) == 1
    return 0;
}
```
~~虽然代码还是很丑，但是总比上一次的代码好看多了~~

---

## 作者：yijan (赞：6)

一个没有代码的题解

斐波那契数列？好，我们看看转移矩阵

(非常抱歉不会用latex写矩阵)

```plain
f(i)   ( 1 1 )
f(i-1) ( 1 0 )
```
这个相信大家都知道。。矩阵快速幂没必要多讲了。不会出门右转百度

假设$G$是11  10 这个矩阵

我们要找的就是$G^k$为单位矩阵的k（mod m）  
（跑回到单位矩阵显然就循环了）

对原矩阵跑一次bsgs就好。

想到后懒得写，，不丢代码至少丢一个别人的题解吧

[板子](https://blog.csdn.net/qq_18455665/article/details/50673156)

由于自己没写。。不确定正确性。。有问题欢迎指出

~~但是这题的m显然不用这么搞也可以卡过去~~




---

## 作者：tkysss (赞：4)

## T1：
题面写的太好了，ORZ出题人。

看到没有一般的做法就忍不住补充一下；


求斐波那契的循环节；

比较一般的做法：

对于一个合数P = $\Pi p_{i}^{k_{i}}$

$G(P) = lcm(G(p_{i}^{k_{i}}))$

而$ G(p_{i}^{k_{i}}) = G(p) * p_{i}^{k_{i}-1}$

对于G(p)

$p==2 , G(p) = 3$

$p==5 , G(p) = 20$ 


如果5是模p的二次剩余那么循环节的长度是$ p-1 $的因子 

如果5是模p的二次非剩余那么循环节的长度是$ 2(p+1) $的因子 

枚举因子并快速幂检验

复杂度:$O(\sqrt{M} log(M))$

这个题暴力就可以了因为M比较小；

所以要仔细分析

当时我因为把结论背错以为暴力过不了。。。。。

十分感谢出题人让我发现我板子的问题。。。。。



```c
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<cmath>
#include<vector>
#include<stack>
#include<map>
#include<set>
#define Run(i,l,r) for(int i=l;i<=r;i++)
#define Don(i,l,r) for(int i=l;i>=r;i--)
#define ll long long
#define ld long double
#define inf 0x3f3f3f3f
using namespace std;
const int N = 1000100;
int M,cnt,vis[N],pri[N],fac[N],num[N],tot;
void pre(){
	for(int i=2;i<=M;i++){
		if(!vis[i])pri[++cnt]=i;
		for(int j=1;j<=cnt&&i*pri[j]<=M;j++){
			vis[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
}
struct mat{int c[2][2];};
mat mul(mat x,mat y,int mod){
	mat re;
	memset(re.c,0,sizeof(re.c));
	for(int i=0;i<2;i++)
	for(int j=0;j<2;j++)
	for(int k=0;k<2;k++){
		re.c[i][j]=(re.c[i][j]+1ll*x.c[i][k]*y.c[k][j]%mod)%mod;
	}
	return re;	
}
bool check(ll y,int mod){
	mat re,a;
	memset(re.c,0,sizeof(re.c));
	memset(a.c,0,sizeof(a.c));
	re.c[0][0]=1;
	a.c[0][0]=a.c[1][0]=1;
	a.c[0][1]=1;
	while(y){
		if(y&1)re=mul(re,a,mod);
		y>>=1;a=mul(a,a,mod);
	}
	return re.c[0][0]==1 && re.c[0][1]==0;
}
int pw(int x,ll y,int mod){
	x%=mod;
	int re=1;
	while(y){
		if(y&1)re=1ll*re*x%mod;
		y>>=1;x=1ll*x*x%mod;
	}
	return re;
}
void split(int x){
	tot=0;
	for(int i=1;i<=cnt&&pri[i]<=x;i++)if(x%pri[i]==0){
		fac[++tot]=pri[i] , num[tot]=0;
		while(x%pri[i]==0&&(x/=pri[i]))num[tot]++;
	}
}
ll ret=0; 
void dfs(int cur,ll now,int mod){
	if(ret)return;
	if(cur==tot+1){
		if(check(now,mod))ret=now;
	}else{
		for(int i=0;i<=num[cur];i++){
			dfs(cur+1,now,mod);
			now*=fac[cur]; 
		}
	}
}
ll cal(int p){
	if(p==2)return 3;
	if(p==5)return 20; 
	if(pw(5,(p-1)>>1,p)==1)split(p-1);
	else split(2*(p+1));
	ret = 0; dfs(1,1,p);
	return ret;
}
ll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}
ll lcm(ll a,ll b){return a/gcd(a,b)*b;}
int main(){ 
	//freopen("in.in","r",stdin);
	//freopen("out.out","w",stdout);
	scanf("%d",&M);
	pre();
	ll ans=1;
	for(int i=1;i<=cnt&&pri[i]<=M;i++)if(M%pri[i]==0){
		ll now=cal(pri[i]); M/=pri[i];
		while(M%pri[i]==0&&(M/=pri[i]))now*=pri[i];
		ans = lcm(ans , now);
	}
	printf("%lld\n",ans);
	return 0;
}//by tkys_Austin;

```










---

## 作者：A星际穿越 (赞：4)

# 写在前面
md比赛的时候数组开小了，结果导致循环次数也变小了，于是90WAWA。。。
# 可以A的做法——暴力
前面的题解说的很明白了，就不再重复了，这里主要讲讲这道题目更一般的数学解法
# 从数学的角度~~剖析本质~~思考这道题
毕竟原题这个n是1e9的，所以暴力的童鞋们。。。~~你们懂得~~

但很显然，第一个为0的项不会太大，暴力找就可以找到，只是其后面一项不一定为1。但这启示我们，能不能从这个位置入手，推出我们要找的位置。

很幸运，我们可以找到这个关系。设斐波那契数列最早在第x项（不是第0项）为0，第x+1项为y，则我们只需要找到最小的一个z，使得$y^z \equiv 1 \pmod{n}$，则答案即为$x*z$

~~假的~~简单的证明：取模后，数列第x+1至第2x项可以看成第一项至第x项乘上一个y~~感性理解~~，那么第2x+1至3x项就是第1项至第x项乘上$y^2$，因此$f[mx+1]=y^m*f[1]$。然后就很显然了。

至于那个z怎么求，emmmm，我好像记得有$log$复杂度的求法，但我忘了，只会一个一个暴力加。。。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 0x7fffffff
#define ME 0x7f
#define FO(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
#define fui(i,a,b,c) for(int i=(a);i<=(b);i+=(c))
#define fdi(i,a,b,c) for(int i=(a);i>=(b);i-=(c))
#define fel(i,a) for(register int i=hd[a];i;i=dg[i].nxt)
#define ll long long
#define MEM(a,b) memset(a,b,sizeof(a))
#define maxn 3000010
ll n;
ll fib[maxn];
template<class T>
inline T read(T &n){
	n=0;int t=1;double x=10;char ch;
	for(ch=getchar();!isdigit(ch)&&ch!='-';ch=getchar());(ch=='-')?t=-1:n=ch-'0';
	for(ch=getchar();isdigit(ch);ch=getchar()) n=n*10+ch-'0';
	if(ch=='.') for(ch=getchar();isdigit(ch);ch=getchar()) n+=(ch-'0')/x,x*=10;
	return (n*=t);
}
template<class T>
T write(T n){
	if(n<0) putchar('-'),n=-n;
	if(n>=10) write(n/10);putchar(n%10+'0');return n;
}
template<class T>
T writeln(T n){write(n);putchar('\n');return n;}
int main(){
	read(n);fib[1]=1;
	fui(i,2,3000000,1)fib[i]=(fib[i-1]+fib[i-2])%n;
	fui(i,1,3000000,1)if(!fib[i]){
		ll x=fib[i+1];
		if(x==1)return 0*writeln(i);
		ll y=1,z=x;while(z%n!=1)++y,(z*=x)%=n;
		return 0*writeln(y*i);
	}
	return 0;
}
```

---

## 作者：柏木由纪AKB48 (赞：3)

晚上过来看月赛题，居然第一题就花了1个多小时

其实矩阵乘法也是可以A的

就是．．．

一般我们看到样例我们都要手玩一下吧

手玩之后我们就会发现：

在　mod m　意义下的０出现是有规律的，它总是隔几个数出现一遍

打完表之后，我们发现在m*2的范围内必定会出现一个０

于是我们就可以发现循环节

我们知道，出现 0 和 １必定会先出现　１和 ０　

1 0 1 1 2 - - - - - - 

我们就可以用矩阵快速蜜找到每一个 0 前面的数，检查它是不是１

```cpp
#include<cstdio>
int m;
struct node{long long d[3][3];int a,b;};
inline void clear(node &a){a.d[1][1]=a.d[1][2]=a.d[2][1]=a.d[2][2]=0;}
inline void pre(node &a){a.d[1][1]=a.d[2][2]=1;}
node pow(node a,node b){
    node ans;
    clear(ans);
    int t1=a.a,t2=b.b;
    for(int i=1;i<=t1;i++){
        for(int j=1;j<=t2;j++){
            for(int k=1;k<=a.b;k++){
                ans.d[i][j]=(ans.d[i][j]+a.d[i][k]*b.d[k][j])%m;
            }
        }
    }
    ans.a=t1,ans.b=t2;
    return ans;
}

node fastmi(node e,int t){
    node ans;clear(ans);pre(ans);
    ans.a=ans.b=2;
    while(t){
        if(t%2)ans=pow(ans,e);
        t>>=1;
        e=pow(e,e);
    }
    return ans;
}
int main(){
    scanf("%d",&m);
    int t1=1,t2=1,pos=0;
    t1=1,t2=1;
    for(int i=3;i<=50000000;i++){
        int v=(t1+t2)%m;
        t1=t2,t2=v;
        if(v==0){pos=i;break;}
    }
    node ori;clear(ori);
    ori.a=1,ori.b=2;
    ori.d[1][1]=t1,ori.d[1][2]=t2;
    node e;clear(e);
    e.a=2,e.b=2;
    e.d[1][2]=e.d[2][1]=e.d[2][2]=1;
    node ts=fastmi(e,pos);
   for(int c=1;c<=500000;c++){
        if(ori.d[1][1]==1){printf("%lld\n",1ll*pos*c);return 0;}
        ori=pow(ori,ts);
    }
    return 0;
}
```

---


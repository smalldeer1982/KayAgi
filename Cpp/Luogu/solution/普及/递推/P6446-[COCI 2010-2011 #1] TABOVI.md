# [COCI 2010/2011 #1] TABOVI

## 题目背景

Zvonkec 是在一家小公司工作的程序员。


## 题目描述

Zvonkec 每天都必须重构一个源代码文件。令他大为沮丧的是，源代码的代码风格很奇怪。他尤其会受到缩进不均匀的困扰，即缩进每行的制表符（即键盘上的 `Tab`）的数量。

幸运的是，他的编辑器具有命令来选择一组连续的行，并从每行的开头添加或删除字符。请你帮助 Zvonkec 尽快整理代码。

给出的行数为 $n$，在每行开始处指定当前制表符数量的序列以及在每行开始处指定所需制表符数量的序列。

Zvonkec 可以执行许多命令，包括：

- 选择任意数量的连续行。
- 向每条选定行的开头添加或删除单个制表符。

无论选择多少行，以上两个动作都包含一个命令。

应该注意的是，禁止从一行中删除的制表符比在一行的开始处实际显示的要多，因为编辑器将开始删除除制表符以外的字符。

要求您计算整理代码所需的最少命令数。

## 说明/提示

#### 数据范围
- 对于 $70\%$ 的数据，$1 \leq n \leq 100$，$0 \le p_i \le 80$，$0 \leq k_i \leq 80$。
- 对于 $100\%$ 的数据，$1 \leq n \le 1000$，$0 \le p_i \le 80$，$0 \leq k_i \leq 80$。
#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #1](https://hsin.hr/coci/archive/2010_2011/contest1_tasks.pdf) *T5 TABOVI*。**

## 样例 #1

### 输入

```
3
3 4 5
6 7 8 
```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
1 2 3 4
3 1 1 0 
```

### 输出

```
6```

## 样例 #3

### 输入

```
4
5 4 5 5
1 5 0 1 
```

### 输出

```
10```

# 题解

## 作者：Math_rad_round (赞：10)

[P6446](https://www.luogu.com.cn/problem/P6446)

题意简述：

给你两个长 $n$ 的数组 $p_i$，$k_i$

每一次操作可以将任意长度的区间每一个数 $\pm 1$

求把 $p_i$ 转换成 $k_i$ 的最小操作次数

------------

我们可以想到，我们关心的是 $p_i$ 和$ k_i$ 的差值

所以可以设 $a_i=p_i-k_i$

我们可以从左往右慢慢递推

假设在 $a_i$ 之前我们加上了 $l$ 排（删去就是负数）

可以发现，$l=a_{i-1}$，因为我们已经处理好了$a_{i-1}$

如果$a_i$和$a_{i-1}$的操作种类一样，那么我们直接把原来$a_{i-1}$用的操作右界限移一位覆盖$a_i$，也就是节省了$|a_{i-1}|$次操作，剩余的操作次数就是$max(0,|a_i|-|a_{i-1}|)$

否则，$a_{i-1}$的操作不能沿用，需要单独为$a_i$操作。次数为$abs(a_i)$

依次不断递推，每次将$ans$加上额外用的操作数。最终$ans$就是答案

复杂度空间$O(n)$，时间$O(n)$，达到了理论下限。

------------

AC代码:

```cpp
#include<iostream>
using namespace std;
int a[100000];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		int a1;
		cin>>a1;
		a[i]=a1-a[i];
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(a[i]>0&&a[i-1]>0)ans+=max(0,a[i]-a[i-1]);
		else if(a[i]>0&&a[i-1]<=0)ans+=a[i];
		else if(a[i]<0&&a[i-1]<0)ans+=max(0,a[i-1]-a[i]);//因为都是负数 
		else ans+=-a[i]; 
	}
	cout<<ans;
} 
```

------------

~~这题数据是真的水~~


---

## 作者：GGapa (赞：2)

我感觉我是前段时间被扫描线搞怕了，现在看到什么就是扫描线的思想。

我们考虑统一将其转化为区间加操作，把所有的数化成复数，接着分段处理。

遇见一个 `^` 的拐角，意味着需要的操作次数会减少 1，反之亦然。

这道题就可以利用扫描线的思想完成了

但是真的没有必要。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i = (a), stOwxc = (b); i <= stOwxc; i++)
#define per(i, a, b) for(int i = (a), stOwxc = (b); i >= stOwxc; i--)
using namespace std;
typedef long long ll;
#define int long long
using VI = vector<int>;

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int n; cin >> n;
    vector<int> A(n + 1);
    rep(i, 1, n) cin >> A[i];
    for(int i = 1, x; i <= n; i++) 
        cin >> x, A[i] = -A[i] + x;
    ll ans = 0;
    auto work = [&](int l, int r) {
        rep(i, l, r) if(A[i] > 0) A[i] *= -1;
        if(l == r) return A[l] * -1;
        if(l == r + 1) return min(A[l], A[r]) * -1;

        vector<pair<int, int>> nd; 
        nd.push_back({0, 0});
        rep(i, l, r - 2) {
            int s = i + 1, t = i + 2;
            while(t < n && A[s] == A[t]) t++;
            if(A[i] > A[s] && A[s] < A[t]) nd.push_back({A[s], 2});
            if(A[i] < A[s] && A[s] > A[t]) nd.push_back({A[s], -2});
        }
        if(A[l] < A[l + 1]) nd.push_back({A[l], 2});
        if(A[r] < A[r - 1]) nd.push_back({A[r], 2});
        if(nd.size() == 1) nd.push_back({A[l], 2});
        sort(nd.begin(), nd.end());
        int cnt = 0;
        rep(i, 0, (int)nd.size() - 1) {
            auto p  = nd[i];
            if(i) {
                ans += max((cnt + 1) / 2, 1ll) * (p.first - nd[i - 1].first);
            }
            cnt += p.second;
        }
        return 0ll;
    };
    for(int l = 1, r = 1; r <= n && l <= n; l = r + 1) {
        r = l;
        while(r < n && A[l] * A[r + 1] > 0) r++;
        ans += work(l, r);
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：hcy1117 (赞：1)

## 简化题意
求最少的操作数使得所有的 $p_{i}-k_{i}$ 为零，每次操作可以将连续的一段 $p_{i}-k_{i}$ 加一或减一。
## 思路
先将	$p_{i}=p_{i}-k_{i}$。

枚举 $i$ 从 $1$ 到 $n$ 为区间的左端点（$p_{i}\ne 0$），再向右扩展右端点 $j$ 只要当前的 $p_{j}$ 不为零并且 $p_{i} p_{j}$ 都大于或小于零就可。每枚举一个区间就将答案加一。

区间中数的加一减一可以在右端点的枚举中实现。$p_{j}>0$ 就将 $p_{j}$ 减一，反之则加一。

语文不好可能难理解，不理解的可以参考代码和注释。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int p[1005];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>p[i];
	for(int i=1;i<=n;i++)
	{
		int k;
		cin>>k;
		p[i]=k-p[i];
	}
	int ans=0;//记录答案 
	for(int i=1;i<=n;i++)//枚举右端点 
	{
		bool flag=(p[i]>0);//判断是大于零还是小于零 
		while(p[i]!=0)//不为零就要继续改 
		{
			++ans;
			if(p[i]>0)p[i]--;
			else ++p[i];
			for(int j=i+1;(p[j]>0)==flag/*都是大于或小于零*/&&p[j]!=0/*不为零*/&&j<=n;j++)//枚举右端点 
			{
				if(p[j]>0)p[j]--;
				else ++p[j];
			}
		}
	}
	cout<<ans;//输出 
}
```
### 后言
本人蒟蒻有错误请指出谢谢。

---

## 作者：A_small_WA (赞：1)

~~居然有黄题还可以发题解！~~

本题题目虽然长，但意思很简单。

即输入两个数组，每次可对第一个数组中某个区间内所有数加 $1$ 或减 $1$，求最少要操作多少步才能将第一个数组变为第二个数组的样子。

#### 因此很容易想到用贪心算法对两个数组的差进行操作。


------------
以样例 $2$ 为例，具体操作如下：

1.两个数组相减得到差 $-2$ $1$ $2$ $4$；

2.判断每个数的正负性，并进行归零，如果出现多个同号的数，则同时加或减他们之中一个最小的数，并计算次数：

- $0$ $1$ $2$ $4$ ($ans+2$)
- $0$ $0$ $1$ $3$ ($ans+1$)
- $0$ $0$ $0$ $2$ ($ans+1$)
- $0$ $0$ $0$ $0$ ($ans+2$)

3.故答案为 $6$。


------------
## 上代码
``` cpp
#include <bits/stdc++.h>
using namespace std;
long long a[100000],b[100000],c[100000];
int main(){
	ios::sync_with_stdio(false), cin.tie(0);
	long long n,p,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		c[i]=a[i]-b[i];
	}
	for(int i=1;i<=n;i++){
		if(c[i]>0){
			p=c[i]-0;
			c[i]=0;
			ans+=p;
			for(int j=i+1;j<=n;j++){
				if(c[j]>0){
					if(c[j]<=p){
						p=c[j];
						c[j]=0;
					}
					else c[j]-=p;
				}else break;
			}
		}
		else if(c[i]<0){
			p=0-c[i];
			c[i]=0;
			ans+=p;
			for(int j=i+1;j<=n;j++){
				if(c[j]<0){
					if(0-c[j]<=p){
						p=0-c[j];
						c[j]=0;
					}
					else c[j]+=p;
				}else break;
			}
		}
	}
	cout<<ans;
	return 0;
}
`````
这是蒟蒻发的第一篇题解，各位支持一下孩子吧！

---

## 作者：chl090410 (赞：1)

## The Solution to P6446 [COCI2010-2011#1] TABOVI

### 题目大意

有一个数组 $a$，对任意一个区间中的数 $\pm$1 视为一次操作。问最少多少次操作能使数组 $a$ 变为数组 $b$。

### 分析

我们将原来的 $a_i$ 分别替换成 $b_i-a_i$，然后考虑用动态规划求解。

#### 具体思路:

定义 $f_i$：处理到第 $i$ 位时的最少操作数。

我们分三种情况讨论。

1. 当 $a_i>0$ 且 $a_{i-1}>0$ 时
- 若 $a_i>a_{i-1}$，那么每次选中第 $i-1$ 位进行操作时，可将第 $i$ 位也一起操作了，而第 $i$ 位比第 $i-1$ 位多的部分则需单独操作。此时 $f_i=f_{i-1}+(a_i-a_{i-1})$。

- 若 $a_i\le a_{i-1}$，那么每次选中第 $i-1$ 位进行操作时，也可将第 $i$ 位也一起操作了，但第 $i$ 位比第 $i-1$ 位少，所以不用单独操作。此时 $f_i=f_{i-1}$。

2. 当 $a_i<0$ 且 $a_{i-1}<0$ 时
- 若 $a_i<a_{i-1}$，则说明第 $i$ 位需要的操作次数比第 $i-1$ 位多，那么每次选中第 $i-1$ 位进行操作时，可将第 $i$ 位也一起操作了，而第 $i$ 位比第 $i-1$ 位多的部分则需单独操作。此时 $f_i=f_{i-1}+(a_{i-1}-a_i)$。

- 若 $a_i\ge a_{i-1}$，那么每次选中第 $i-1$ 位进行操作时，也可将第 $i$ 位也一起操作了，但第 $i$ 位需要的操作次数比第 $i-1$ 位少，所以不用单独操作。此时 $f_i=f_{i-1}$。

3. 当 $a_i>0$ 且 $a_{i-1}<0$ 时或当 $a_i<0$ 且 $a_{i-1}>0$ 时（可简记为 $a_
i\times a_{i-1}<0$ 时）

此时第 $i-1$ 位与第 $i$ 位不能同时操作，第 $i$ 位需要单调操作，因为 $a_i$ 的正负未知，所以第 $i$ 位的操作次数为 $|a_i|$，此时 $f_i=f_{i-1}+|a_i|$。

总动态转移方程为：

$f_i = \begin{cases}
  f_{i-1}+(a_i-a_{i-1}) & a_i>0,a_{i-1}>0,a_i>a_{i-1}\\
  f_{i-1} & a_i>0,a_{i-1}>0,a_i\le a_{i-1}\\
  f_{i-1}+(a_{i-1}-a_i) & a_i<0,a_{i-1}<0,a_i<a_{i-1}\\
  f_{i-1} & a_i<0,a_{i-1}<0,a_i\ge a_{i-1}\\
  f_{i-1}+|a_i| & a_
i\times a_{i-1}<0\\
\end{cases}$

时间复杂度为 $O(n)$。

### 下面附上完整代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1005],b[1005],f[1005],t[1005],mx,ans,k,p;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];a[i]=b[i]-a[i];
	}
	f[1]=abs(a[1]);
	for(int i=2;i<=n;i++){
		if(a[i]>0 && a[i-1]>0){
			if(a[i]>a[i-1]) f[i]=f[i-1]+(a[i]-a[i-1]);
			else f[i]=f[i-1];
		}else if(a[i]<0 && a[i-1]<0){
			if(a[i]<a[i-1]) f[i]=f[i-1]+(a[i-1]-a[i]);
			else f[i]=f[i-1];
		}else{
			f[i]=f[i-1]+abs(a[i]);
		}
	}
	cout<<f[n];
	return 0;
}  

	

---

## 作者：cosf (赞：1)

[***P6446 TABOVI***](https://www.luogu.com.cn/problem/P6446)
---

## 题目大意

给你两个数列 $p, k$，求最少要使某个区间集体 $\pm 1$ 使得 $p$ 变为 $k$。

---

## 思路

先将 $p_i$ 替换成 $k_i-p_i$，则原题是使现在的 $p$ 变为全零。
接下来就可以用贪心了。

### AC Code
```c++
#include <iostream>
using namespace std;

int p[1005];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> p[i];
    }
    int cur;
    for (int i = 1; i <= n; i++)
    {
        cin >> cur;
        p[i] = cur - p[i];
    }
    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        if (p[i] > 0 && p[i - 1] > 0) // 需要一起+Tab
        {
            if (p[i] > p[i - 1]) // 当前需要Tab数>已有Tab数
            {
                res += p[i] - p[i - 1];
            }
        }
        if (p[i] > 0 && p[i - 1] <= 0) // 需要从-变+
        {
            res += p[i];
        }
        if (p[i] < 0 && p[i - 1] >= 0) // 从+变-
        {
            res += -p[i];
        }
        if (p[i] < 0 && p[i - 1] < 0) // 需要一起-Tab
        {
            if (p[i] < p[i - 1]) // 当前多余Tab数<“已多余”Tab数
            {
                res += p[i - 1] - p[i];
            }
        }
    }
    cout << res << endl;
    return 0;
}

```


---

## 作者：pengzy (赞：0)

一道有思维难度的贪心，没有思路可以先去看一下  [P5019](https://www.luogu.com.cn/problem/P5019)。

### 题意
题面略微有些复杂，这是**简化版**：

给定一个序列 $a$，每次操作可以给任意区间 $[L,R]$ 全部数字加一或者减一，问至少需要多少次操作可以变为序列 $b$。

## 思路
首先，可以想到先处理一下两个序列。设 $a_{i}$ 到 $b_{i}$ 需要操作 $x_{i}$ 次，我们先记录下 $x$ 序列（即 $x_{i}$ 为 $a_{i}$ 和 $b_{i}$ 的差值）。

接下来，就是对 $x$ 序列进行操作。我们从第一个数开始思考，发现可以分情况讨论：

1. $x_{i}>0$ 且 $x_{i-1}>0$

	当 $x_{i}>x_{i-1}$ 时，还需要进行 $x_{i}-x_{i-1}$ 次操作。

	为什么不是进行 $x_{i}$ 次操作呢？因为在处理 $x_{i-1}$ 的时候，相当于已经进行了 $x_{i-1}$  次操作，而这个操作数量可以贡献给 $x_{i}$。

	当 $x_{i}<x_{i-1}$ 时，不需要再进行操作了，因为 $x_{i-1}$ 的贡献足够大了。

2. $x_{i}<0$ 且 $x_{i-1}<0$

	这种情况思路与第一种相同，不再做解释，直接看代码吧。

3. $x_{i}>0$ 且 $x_{i-1}<0$

	这种情况首先会想到让 $ans$ 加上 $x_{i}+\lvert x_{i-1} \rvert$，我们记为方法 $1$，其实这个想法是对的。这样会不会目光短浅呢？不会。

	如果 $x_{i+1}$，$x_{i+2}$ 都是负数，你可能会想到以 $x_{i-1}$ 来贡献给全部，这样牺牲 $x_{i}$ 换来了其他负数的增加。

	看一个例子:

	`-3 4 -3 -3 -3`

	如果先全部增加 $3$，再给第二个数减小 $7$，总共需要 $10$ 步，记为法 $2$。而分别对 $[1,1]$， $[2,2]$ ，$[3,5]$ 三个区间进行处理的结果是一样的。可以证明在第三种情况下法 $1$ 的操作次数小于等于法 $2$。

4. $x_{i}<0$ 且 $x_{i-1}>0$

	与第三种情况相同，自行思考。

### 注意
上面的讨论还有一些细节有待思考，比如 $a_{i}=a_{i-1}$ 的情况。在等于的时候，不管正负，$a_{i}$ 不需要再加了，只需要使用 $a_{i-1}$ 的贡献。

### 代码
```cpp
const int Max=1e3+10;
int n,a[Max],ans,f[Max];
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++) {
		int k;k=read();
		a[i]=k-a[i];
	}
	for(int i=1;i<=n;i++) {
		if(a[i]>=0&&a[i-1]>=0) {
			if(a[i]>a[i-1])ans+=a[i]-a[i-1];
			//如果等于，ans+=0 
		}
		else if(a[i]<=0&&a[i-1]<=0) {
			if(a[i]<a[i-1])ans+=(a[i-1]-a[i]);
		}
		else ans+=abs(a[i]); 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：yx666 (赞：0)

# P6446 TABOVI 题解
## Part 1：题目大意
### Part 1.1：题干
给定两个长度为 $n$ 的数列 $p_i$ 与 $k_i$，每次可以对 $p_i$ 进行如下一次如下操作：

- 选择任意长度的连续子序列。
- 对选定的子序列全部元素进行 $\pm 1$ 的操作。

求最少经过多少次操作可以使 $p_i$ 与 $k_i$ 完全相同。

### Part 1.2：数据范围与约定
- $n\in[1,1\times10^3]$。

- $p_i,k_i\in[0,80]$。

- 时间限制 $1$ 秒，空间 $125$ MB。

### Part 2：解决思路
#### Part 2.1：结论
考虑贪心。

记 $f_i\gets k_i-p_i$，表示 $p_i$ 需要增加 $f_i$ 才使 $p_i=k_i$。

于是就将题意简化成：最少经过多少次操作可以使 $f_i=0,\footnotesize(i\in[1,n])$。

得到：（证明在后面）

$$ans=\sum^n_{i=0} \left| f_{i+1}-f_i \right|$$

#### Part 2.2：证明
- 发现 $f_i$ 像一个波，我们只需要记录每个波峰（或波谷）的高度（或深度）。

- 每个操作可以看做是将一个波峰（或波谷）的高度（或深度）减 $1$，所以所有波峰（或波谷）的高度（或深度）之和，即是答案。

听起来有点抽象，举个栗子：

- 对于 $f_i=\{-1,-2,-3,2,4,-6\}$，可以看做一个由 $\{-1,-2,-3\},\{2,4\},\{-6\}$ 构成的波。

- 最优解：
	1. 对 $f_i,\footnotesize i\in[1,3]$ 执行 $1$ 次 $+1$，$f_i,\footnotesize i\in[2,3]$ 执行 $1$ 次 $+1$，$f_i,\footnotesize i\in[3,3]$ 执行 $1$ 次 $+1$。操作次数为 $3$，是 $\{-1,-2,-3\}$ 这个波谷的深度。
    
    2. 同理，对 $f_i,\footnotesize i\in[4,5]$ 执行 $2$ 次 $+1$，$f_i,\footnotesize i\in[5,5]$ 执行 $2$ 次 $+1$。操作次数为 $4$，恰为 $\{2,4\}$ 这个波峰的高度。    
    3. $f_i,\footnotesize i\in[6,6]$ 全部执行 $6$ 次 $+1$，操作次数为 $6$，$\{-6\}$ 这个波谷的深度。
    
#### Part 2.3：核心代码
``` cpp
int ans=abs(f[1]);
for(int i=1;i<=n;++i){
	ans+=abs(f[i+1]-f[i]);
}
cout<<ans/2;
```

注意这里，不可以使用找波峰与波谷的方法，理由：

如果有一个 $f_i=\{1,3,1,3\}$，直接找高度是 $3+3=6$，但最优解是 $1+2+2=5$。可以采取改变 $x$ 轴的办法（认为 $1$ 是高度 $0$），也可以采用上面的记录相邻的差的方法。

### Part 3：代码与优化
#### Part 3.1：代码
``` cpp
#include<bits/stdc++.h>
using namespace std;

#define N 1024

int n;
int p[N],k[N],f[N];
signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>p[i];
	for(int i=1;i<=n;++i){
		cin>>k[i];
		f[i]=k[i]-p[i];
	}
	
	int ans=abs(f[1]);
	for(int i=1;i<=n;++i){
		ans+=abs(f[i+1]-f[i]);
	}
	cout<<ans/2;
	return 0;
}
```

### Part 3.2：优化
- 空间上：$k_i,p_i,f_i$ 可以一起压缩成一个数组。

- 时间上：快读快写，转成 C 语言，循环展开……能快一些，但不多。

## Part 4：同类型题
以下三个代码几乎一致，只是在数据范围上有细微差别，难度上都没有本题大。

1. [P1969](https://www.luogu.com.cn/problem/P1969)

2. [P5019](https://www.luogu.com.cn/problem/P5019)
3. [P3078](https://www.luogu.com.cn/problem/P3078)

---

## 作者：xuan_gong_dong (赞：0)

## 题面
[P6446 [COCI2010-2011#1] TABOVI](https://www.luogu.com.cn/problem/P6446)

## 分析
手模一下样例，很容易想到贪心，具体地，当前面一个数增加，并且本次的操作也是增加时，可以用一下上次增加的量，如果本次操作与上次操作相反（即一个增加，一个减少）时就直接修改，不管前面的操作。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int xgd[1010];
int hys[1010];
int shit[1010];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&xgd[i]); 
	for(int i=1;i<=n;i++){
		scanf("%d",&hys[i]);
		shit[i]=hys[i]-xgd[i];
	}
	int ans=abs(shit[1]);
	for(int i=2;i<=n;i++){
		if(shit[i]*shit[i-1]<0)
			ans+=abs(shit[i]);
		else if(abs(shit[i-1])<abs(shit[i]))
		ans+=abs(shit[i]-shit[i-1]);
	}
	printf("%d",ans);
	return 0;
 } 
```

---

## 作者：liuandwang (赞：0)

## 主要思路：
先求出 $k _ {i} - a _ {i}$ 的差值储存在 $a _ {i}$ 中。
```cpp
	for(int i=0;i<n;i++) cin>>a[i];//输入a[i]
	for(int i=0,k;i<n;i++){//定义一个k
		cin>>k;
		a[i]=k-a[i];//将k-a[i]的差值存入a[i]中
	}
```

之后从 $a _ {0}$ 到 $a _ {n - 1}$ 遍历，如果 $a _ {i}$ 与 $a _ {i + 1}$ 为同号，则命令次数 $ans = ans + \max(0,\operatorname{abs}(a _ {i} - a _ {i + 1}))$，否则命令次数 $ans = ans + a _ {i}$。
```cpp
	for(int i=0;i<n;i++){
		if(a[i]<=0&&a[i+1]<=0) ans+=max(0,a[i+1]-a[i]);
		else if(a[i]>=0&&a[i+1]>=0) ans+=max(0,a[i]-a[i+1]);
		else ans+=abs(a[i]);
	}
```
## 最后代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	//freopen("P6446 [COCI2010-2011#1] TABOVI.in","r",stdin);
	//freopen("P6446 [COCI2010-2011#1] TABOVI.out","w",stdout);
	int n;
	cin>>n;
	int a[n+1]={0};
	for(int i=0;i<n;i++) cin>>a[i];
	for(int i=0,k;i<n;i++){
		cin>>k;
		a[i]=k-a[i];
	}
	int ans=0;
	for(int i=0;i<n;i++){
		if(a[i]<=0&&a[i+1]<=0) ans+=max(0,a[i+1]-a[i]);
		else if(a[i]>=0&&a[i+1]>=0) ans+=max(0,a[i]-a[i+1]);
		else ans+=abs(a[i]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：drinktowind (赞：0)

# 大意
给你两个长 $n$ 的数列，求将他们修改为相同的数列需要几步。
# 思路  
取两个数列的差值，就把原来的问题转化为将这个数列全变为零，接着就可以使用贪心。如果当前这个数与前一个数的操作是相同的，需要同加或同减，那么就沿用上一个数的操作，反之则单独操作当前这个数。
```
#include<bits/stdc++.h>
using namespace std;
int a[100010],ans;
int main()
{
	int n,x;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		a[i]=x-a[i];//需要Tab数
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]>0&&a[i-1]>0)//需要一起Tab 
			ans+=max(0,a[i]-a[i-1]);
		else if(a[i]>0&&a[i-1]<=0)//a[i-1]需要Tab 
			ans+=a[i];
		else if(a[i]<0&&a[i-1]<0)//需要一起删除Tab 
			ans+=max(0,a[i-1]-a[i]);
		else//a[i]需要Tab 
			ans-=a[i];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Stay_Hungry (赞：0)

转换题意：   

给出一种能批量修改区间数值的操作（也就是区间加减）  
问至少需要多少次这样的操作

提供一种能过的贪心思路：   

我们在+- tab数量时，+-的区间肯定是连续的，因此能一次多修改大的区间就修改大的区间，而这样修改的顺序是无序的，为了方便就直接从左到右做啦。

如何实现？

1.把需要加的和需要减的进行分类（直接计算差值就ok了）  
2.每次递归查找所在区间的最值，再以这个已经达到目的的点开始左右递归   

```cpp
#include <cstdio>
const int N = 2005 ;
int n , a[ N ] , b[ N ] , s[ N ] ;
int dfs( int l , int r ) {
	if( l == r ) return 0 ;
	int p = l , res = 0 , nxt ;
	if( s[ l ] > 0 ) { // 按照上述做法执行
		for( res = 1e9 ; s[ p ] >= 0 && p < r ; ++p ) 
			if( s[ p ] < res ) res = s[ p ] , nxt = p ;
		for( int i = l ; i < p ; ++i ) s[ i ] -= res ;
		res += dfs( l , nxt ) + dfs( nxt + 1 , r ) ;
	}
	else {
		for( res = -1e9 ; s[ p ] <= 0 && p < r ; ++p ) 
			if( s[ p ] > res ) res = s[ p ] , nxt = p ;
		for( int i = l ; i < p ; ++i ) s[ i ] -= res ;
		res = dfs( l , nxt ) + dfs( nxt + 1 , r ) - res ;
        // 这里正负号注意
	}
	return res ;
}
int main() {
	scanf( "%d" , &n ) ;
	for( int i = 1 ; i <= n ; ++i ) scanf( "%d" , a + i ) ;
	for( int i = 1 ; i <= n ; ++i ) scanf( "%d" , b + i ) ;
	for( int i = 1 ; i <= n ; ++i ) s[ i ] = b[ i ] - a[ i ] ; // 计算差值
	printf( "%d\n" , dfs( 1 , n + 1 ) ) ; // 这里我习惯用左闭右开的写法
	return 0 ;
}
```

根据公式，这个做法的复杂度为$O(nlogn)-O(n^2)$，还是能轻松过这题的。

不难发现，每次计入答案中的都是最值，因此直接查询区间最值就ok了，线段树啥的优化一下$O(nlogn)$

但是这显然不够优秀，根据这种思路，我还yy出了一种$O(n)$的做法

其实没有必要用线段树找区间最值，因为每次找的最值都是带有前缀的，所以开个数记录一下然后就可以轻松做到$O(n)$了

只是提供一下思路，自己去打吧~~我还是太懒了~~


---


# [蓝桥杯 2018 国 AC] 约瑟夫环

## 题目描述

$n$ 个人的编号是 $1 \sim n$，如果他们依编号按顺时针排成一个圆圈，从编号是 $1$ 的人开始顺时针报数。

（报数是从 $1$ 报起）当报到 $k$ 的时候，这个人就退出游戏圈。下一个人重新从 $1$ 开始报数。

求最后剩下的人的编号。这就是著名的约瑟夫环问题。

本题目就是已知 $n$，$k$ 的情况下，求最后剩下的人的编号。


## 说明/提示

$0<n,k<10^6$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
10 3```

### 输出

```
4```

# 题解

## 作者：Joton (赞：34)

这是本蒟蒻的第一篇题解，大佬轻点喷。

“约瑟夫环” （普及+/提高），这一看就不简单。

**本题下标从 $0$ 开始编号**
## 题目大意
有 $n$ 个人编号为 $1$，$2$，…… ，$n$，每当报道 $k$ 时的人退出游戏圈，不参与报数，下一个人从 $1$ 继续开始报数。
## Algorithm 1 模拟 $O(nk)$
首先可以将人不断入队和出队，当有人报的数到达了 $k$ 时，就将其出队，而不继续入队，并且将报的数字归零。直到队列中只剩下了最后一个人为止。

下面是我的模拟代码，很显然时间复杂度太高了。
```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n,k;
    cin >> n >> k;
    queue<int> peo;
    for(int i = 1;i <= n;i++)
    {
    	peo.push(i);
    }
    int cnt = 0;
    while(peo.size() != 1)
    {
    	int name = peo.front();
    	cnt++;
    	if(cnt == k)
    	{
            peo.pop();
    		cnt = 0;
    		continue;
    	}
        peo.pop();
    	peo.push(name);
    }
    cout << peo.back();
    return 0;
}
```
## Algorithm 2 使用约瑟夫环的递推公式 $O(n)$
设 $F(i)$ 为 $i$ 个人报数到 $k$ 就出局，最后剩下的人的编号。
**初始状态**
![初始状态](https://cdn.luogu.com.cn/upload/image_hosting/e4l5oaqb.png)
**第一次出队后**
![第一次出队后](https://cdn.luogu.com.cn/upload/image_hosting/2uxlfs8w.png)
**第二次出队后**
![第二次出队后](https://cdn.luogu.com.cn/upload/image_hosting/pk3lyk8g.png)
每次出队一人，在约瑟夫环上的每个人都向前移动了 $k$ 位。
那么如果要反着来，就是每次加上一个人，在约瑟夫环上的每个人都向后移动了 $k$ 位。
易得剩下一个人的时候，最终答案对应的下标为 $F(1)=0$。
那么加上一个人，最终答案对应的下标就是 $F(2) = (F(1) + k) \bmod 2$。
再加上一个人，最终答案对应的下标就是 $F(3) = (F(2) + k) \bmod 3$。
以此类推，
那么可以得出递推公式：
-  $F(1)=0$
-  $F(n)=(F(n-1)+k)\bmod n$
于是就可以求答案了。

```cpp
#include <bits/stdc++.h>
 
using namespace std;

int main()
{
    int n,k,s = 0;
    cin >> n >> k;
    for(int i = 2;i <= n;i++)
    {
        s=(s+k)%i;
    }
    cout << s+1; //答案初始下标为1
    return 0;
}
```
[题目传送门](https://www.luogu.com.cn/problem/P8671) 

**鸣谢 [@cqrcqr](https://www.luogu.com.cn/user/240457)。**

---

## 作者：_fairytale_ (赞：12)

# 大家好，我非常喜欢线段树，所以我用线段树通过了这道题。

看各位大佬们用的都是递推公式，本蒟蒻就讲一个好理解一点的线段树吧。

### 朴素做法当然是直接枚举，时间复杂度 $\mathcal O(nk)$。

我们现在想一下它的问题在哪里。每次踢一个人没有问题，但是查找下一个要被踢掉的人要用 $\mathcal O(k)$ 的时间来找。这时候就要用强大的线段树来优化啦。

我们的线段树要支持以下操作：

- 单点修改（删除）

- 查询区间中第 $k$ 个没被删除的点

第一个操作好说，第二个其实有做法，但是有点科技，这里讲一个小技巧转化成全局查询。

我们先把没被踢的人记为 $1$，踢掉的人记为 $0$。

这样，我们便可以 $\mathcal O(\log n)$ 求出一个人前面和后面还剩下多少人。

设当前被删的人的位置为 $pos$，这个人前面剩下的人数为 $pre$，后面剩下的人数为 $suf$。

接下来分类讨论一下：

- $suf \geq k$：查询全局第 $pre + k$ 个没被删除的点。

- $suf < k$：查询全局第 $k - suf$ 个没被删除的点。

全局查询直接在线段树上二分就可以。

这样就做完啦，有什么问题欢迎指出！
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define ls p<<1
#define rs p<<1|1
#define mid ((l+r)>>1)
const int maxn=1e6+10;
int n,k;
int t[maxn<<2];
inline void pushup(int p){
	t[p]=t[ls]+t[rs];
}
void build(int p,int l,int r){
	if(l==r){
		t[p]=1;
		return ;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(p); 
}
void remove(int p,int l,int r,int v){
	if(l==r){
		t[p]=0;
		return ;
	}
	if(mid>=v)remove(ls,l,mid,v);
	else remove(rs,mid+1,r,v);
	pushup(p);
}
int querys(int p,int l,int r,int L,int R){
	if(L<=l&&r<=R)return t[p];
	int res=0;
	if(mid>=L)res+=querys(ls,l,mid,L,R);
	if(mid<R)res+=querys(rs,mid+1,r,L,R);
	return res;
}
int queryr(int p,int l,int r,int rk){
	if(l==r)return l;
	if(t[ls]>=rk)return queryr(ls,l,mid,rk);
	else return queryr(rs,mid+1,r,rk-t[ls]); 
}
int pos=0;
int rest;
bool killed[maxn];
int tmp,pre,suf;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	rest=n;
	build(1,1,n);
    while(rest>1){
    	tmp=(k-1)%rest+1;//随着剩余人数的减少，k有可能比n大，需要处理一下
    	pre=(pos<=1?0:querys(1,1,n,1,pos-1));
    	suf=querys(1,1,n,pos+1,n);
        if(suf<tmp)pos=queryr(1,1,n,tmp-suf);
    	else pos=queryr(1,1,n,pre+tmp);
    	remove(1,1,n,pos);
    	killed[pos]=true;
    	rest--;
	}
	for(re int i=1;i<=n;++i){
		if(!killed[i]){
			cout<<i;
			break;
		}
	}
	return 0;
}

```

---

## 作者：5k_sync_closer (赞：9)

设 $f_{n,k}$ 表示 $n$ 个人，$k$ 次一出的约瑟夫问题答案。

则有 $f_{n,k}=f_{n-1,k}+k-1\bmod n + 1$。

证明：考虑第一个人出去后，问题变成 $n-1$ 个人，$k$ 次一出的约瑟夫问题，

算出该问题的答案 $f_{n-1,k}$ 后，原问题的答案即为 $f_{n-1,k}$ 向后平移开始报的 $k$ 位。

```cpp
#include <cstdio>
int n, k, q;
int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i)
        q = (q + k - 1) % i + 1;
    return !printf("%d", q);
}
```


---

## 作者：i_love_tym (赞：2)

模拟 $O(nk)$ 显然不行,只能用公式。

我们设 $f(i)$ 表示 $i$ 个人每次报到 $k$ 就出局，最后剩下的人的编号。

可得，

$f(1)=0$ 

$f(2)=(f(1)+k) \mod 2$

$……$

$f(n)=(f(n-1)+k) \mod n$

所以我们只需要递推这个公式即可，时间复杂度 $O(n)$。

# code 

```
#include<iostream>
using namespace std;
int main(){
	int n,k;
	cin>>n>>k;
	int ans=0;
	for(int i=2;i<=n;i++) ans=(ans+k)%i;	
	cout<<ans+1;
}
```

其中 ``ans+1`` 是因为程序中人的编号是从 $0$ 开始的，而题目是从 $1$ 开始的，所以 ``+1``。

---

## 作者：FDOI (赞：2)

# 思路
第一眼：直接把 [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996) 的代码稍微调一下就好。

这种方法显然要超时，因为这种写法的复杂度为 $O(nk)$，只能过 $3$ 个点。有没有更好的方法呢？有，那就是递推式法。

我们可以推出这个递推式，现在复杂度降为了 $O(n)$： 
$$f(n) =(f(n-1) + k)\mod n$$
[具体证明可以借鉴这篇文章](https://blog.csdn.net/mzpqq/article/details/124568918)。

# Python Code：
```python
n, k = map(int, input().split())
s = 0
for i in range(2, n+1): #从2开始循环
    s = (s+k) % i #递推式
print(s+1) #f(0)为1,所以要加上1
```
[AC记录，供参考](https://www.luogu.com.cn/record/109367864)

---

## 作者：fengziyi (赞：2)

### 没用前言

~~数学~~乱搞题，不知道为什么要打上线段树的 tag。

### 思路

显然 $O(nk)$ 的模拟不可行，发现约瑟夫环问题可以 $O(n)$ 求解，故尝试证明。

### 证明  

首先简化一下题意，$n$ 个人环状按 $1 \rightarrow k$ 序报数，报到 $k$ 的人噶掉，求最后剩下的人。  

我们通过**倒推**的方法证明。  

预先定义一些概念：  
幸存者称为 $svr$；  
“安全”表示一个人在本轮 $k$ 人中不会被噶；  
$pos$ 表示 $svr$ **在当前环中**的序号，从 $1$ 开始；  
$k$ 和 $n$ 的定义同题目。

倒向递推：

- 最后一轮报完，只剩 $svr$ 一人，此时总人数为 $1$，$pos = 0 \bmod 1 + 1$。
- 倒数第二轮中，剩下 $2$ 人，由于 $svr$ 是安全的，$pos = k \bmod 2 + 1$。
- 倒数第三轮中，剩下 $3$ 人，由于 $svr$ 是安全的，$pos = (k \bmod 2 + k) \bmod 3 + 1$。
- 倒数第四轮中，剩下 $4$ 人，$pos = ((k \bmod 2 + k) \bmod 3 + k) \bmod 4 + 1$。
- 依此类推，循环求解即可。

若希望得到准确数学证明，可以看下[知乎大佬的博文](https://zhuanlan.zhihu.com/p/121159246)。  

### 贴个代码

```cpp
inline int find(const int& n, const int& k)
{
    int pos = 0;
    for (reg int i = 2; i <= n; ++i)
        pos = (pos + k) % i;
    return pos + 1;
}
```

---

## 作者：WaterSky (赞：0)

[P8671 [蓝桥杯 2018 国 AC] 约瑟夫环](https://www.luogu.com.cn/problem/P8671)。

这题分四种做法，一种模拟，一种队列，这两种都超时了，第三种递归，第四种线段树二分，但是这一种我不会。

## 第一种做法：模拟（22ps）。
做法是开一个数组，然后再用一个循环一圈一圈的找。

时间超限。

## 第二种做法：队列。
做法是开一个队列，然后再一个一个枚举。和模拟差不多，也就少那么一点点时间。


## 第三种做法：递归。敲黑板！
递归要推公式。

先把题目描述一下吧。

$0$，$1$，$\cdots$，$n-1$。从数字 $0$ 每次把第 $m$ 个数删除。求最后剩下的数字。

思考操作过程，可以想到我们可以看到每一轮中移走的是第 $m$ 个数字。所以每一轮的第 $m+1$ 会成为下一轮数字为 $0$ 的数。

解决约瑟夫环问题，我们采用倒推，我们倒推出：最后剩下的这个数字，在最开始的数组中的位置。

1. 剩下最后一个数字（简称“它”）的时候，总个数为 $1$，目前下标为：$0$。
2. 那么它在上一轮也是安全的，总个数为 $2$，目前下标为：$(0+m)\bmod{} 2$。
3. 那么它在上上一轮也是安全的，总个数为 $3$，目前下标为：$((0+m)\bmod2+m)\bmod3$。
4. $\cdots$

一共执行 $n$ 次。

答案就为 $((0+m)\bmod2+m)\bmod3 \cdots +m\bmod{n}$。

具体思路就是这样。

具体的数学推导过程和证明方法请看这里：[知乎帖](https://zhuanlan.zhihu.com/p/121159246)。

程序：
```
#include <bits/stdc++.h>
using namespace std;
long long n,k;
long long X(long long x,long long y)
{
	if(x==n) return (y+k)%n;
	return X(x+1,(y+k)%x);
}//答案的子函数。
int main(){
    cin>>n>>k;
    cout<<X(2,0)+1;//因为下标是从0开始的，所以要加1.
    return 0;
}
```

---

## 作者：Mx_sky (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8671)

## 方法一

$O(nk)$ 模拟（此解法加各种卡常可以拿到 $30$ 分）：

本人用的是队列实现，如果第 $i$ 个元素是 $k$，出队；否则，放在末尾。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int Max=1000003;
#define ll long long
queue<int>a;
int n,m,k;
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i) a.push(i);
	while(a.size()>1)
	{
		k++;
		if(k%m==0) k=0,a.pop();
		else a.push(a.front()),a.pop();
	}
	printf("%d",a.front());
    return 0;
}
```

## 方法二

递归公式（时间复杂度 $O(n)$，可以 $\verb!AC!$）：
  $$F(n,m)=(F(N-1,M)+M) \bmod N$$
具体推导过程请移步至这篇[文章](https://mp.weixin.qq.com/s?__biz=MzIzMjgyOTg3NQ==&mid=2247491346&idx=1&sn=a32d9957d5c30521601d1b28e37492c3&chksm=e88fb9cedff830d83fa3b3b31ad97c7b4b614611c25e5788a68d02b7e3069aa2ae11360a6a66&scene=27)。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,ans;
int main(){
	scanf("%d %d",&n,&k);
	for(int i=2;i<=n;++i) ans=(ans+k)%i;
	printf("%d\n",ans+1);
    return 0;
}
```

## The End


---

## 作者：Steve_xh (赞：0)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/P8671)

**题目大意：**

约瑟夫问题，给出人数 $n$ 和 $k$，求最后剩下的人是第几号。

# 思路

其实是加强版的[**约瑟夫**](https://www.luogu.com.cn/problem/P1996)。
$n$ 和 $k$ 的范围都是 $10^6$，直接用队列模拟是肯定会 TLE 的，所以得想一种复杂度接近或等于 $O(n)$ 的算法。我们先来看看淘汰某人后约瑟夫环的规律，我们每次把要杀掉的人都放在圈顶（首位），就可以发现，每次要杀掉一个人，整个圈就会逆时针转 $k$ 次。所以我们可以根据这个发现写出如下递推式：
$$F(i)=(F(i-1)+k)\bmod n$$
$$F(1)=0$$
这条式子的意思是，用上一次淘汰的人加上 $k$（正着是减，反着就要加回来）并判断这个位置是在循环圈里的第几位。那么代码就容易写了，直接套用函数即可，复杂度 $O(n)$，不用再考虑优化了。

# 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;//方便和k区分写成m
int f(int n,int k){//直接套用
    if(n<=1)
        return 0;
    return (f(n-1,k)+k)%n;
}
int main(){
    cin>>n>>m;
    cout<<f(n,m)+1;//加一是因为正常mod n结果范围从0开始，而答案要求是从1开始
    return 0;
}
```

---


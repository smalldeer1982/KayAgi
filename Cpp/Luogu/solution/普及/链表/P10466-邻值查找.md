# 邻值查找

## 题目描述

给定一个长度为 $n$ 的序列 $A$，$A$ 中的数各不相同。

对于 $A$ 中的每一个数 $A_i$，求：

$\min_{1 \le j <i}|A_i-A_j|$

以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择使 $A_j$ 较小的那个。

## 说明/提示

对于 $30\%$ 的数据 $n \le 100$。

对于 $70\%$ 的数据 $n \le 10^4$。

对于 $100\%$ 的数据 $n \le 10^5,|A_i| \le 10^9$。

## 样例 #1

### 输入

```
3
1 5 3```

### 输出

```
4 1
2 1```

# 题解

## 作者：cqbzhzf (赞：21)

[题目链接](https://www.luogu.com.cn/problem/P10466)

### 思路分析
对于每一个数字 $A_i$ 而言，要得到一个值，使得它们的差的绝对值最小，那么这个值只可能是在排序情况下的前一个或后一个位置的值。

若直接暴力计算，则可以使用插入排序，每次插入一个新的值，再进行上述方法的一个判断，时间复杂度为 $O(n^2)$，只能得 80 分。因此，需要考虑其它更优的方法解题。

我们可以思考这样一个问题：若要减少时间复杂度，那就要优化成一个 $O(n \log n)$ 排序，可是排完序后又该怎么做呢？我们可以发现，对于最后一个数字而言，因为它后面没有数字，所以，这个数字的答案为排序后它前面那个数字与它的差的绝对值。而在除去最后一个数字后，倒数第二个数字又成了新的最后一个数字，又可以用同样的方式计算答案。

这里我们可以用链表完成删除数据的操作，可是动态链表每一次查询的时间复杂度太大，所以采用查询速度更快的静态链表，利用结构体储存。这样我们就可以实现 $O(n \log n)$ 的排序；每个数字 $O(1)$，总计 $O(n)$ 的查询。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
pair<int, int> a[N],ans[N];
int p[N],L[N],R[N];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n,x;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		a[i]={x,i};
	}
	sort(a+1,a+n+1);
	a[0].first=INT_MIN;
	a[n+1].first=INT_MAX; 
	for(int i=1;i<=n;i++)
	{
		p[a[i].second]=i; 
		L[i]=i-1,R[i]=i+1;
	}
	for(int i=n;i>1;i--)
	{
		int k=p[i],left=L[k],right=R[k],v=a[k].first;
		int l=v-a[left].first;
		int r=a[right].first-v;
		if(l<=r)
			ans[i]={l,a[left].second};
		else 
			ans[i]={r,a[right].second}; 
		L[right]=left;
		R[left]=right; 
	}
	for(int i=2;i<=n;i++)
		cout<<ans[i].first<<" "<<ans[i].second<<"\n";
}
```

---

## 作者：chenhanzheapple (赞：10)

# [传送门](https://www.luogu.com.cn/problem/P10466)

前置芝士：~~平衡树~~，STL 中的 set。

首先看一下这题的暴力，就是插入排序，每次插入一个新的值，答案只可能是在排序情况下的前一个或后一个位置的值。

复杂度瓶颈在于排序，是 $O(n^2)$ 的，考虑优化。

set 本质上是平衡树，插入时可以实现自动排序，且插入复杂度为 $O(\log n)$。

将插入排序替换成 set 就是正解了。

实际上不用二分查找，find 函数是 $O(\log n)$ 的。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
set<pair<int,int> > s;
int a[100005];
int main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    s.insert({a[1],1});
    for(int i=2;i<=n;i++){
        s.insert({a[i],i});
        auto it = s.find({a[i],i});
        int p = INT_MAX,j = -1;
        if(it!=s.begin()){
            auto it2 = it;
            it2--;
            p = abs((*it2).first-a[i]),j = (*it2).second;
        }
        auto it2 = it;
        it2++;
        if(it2!=s.end()){
            if(abs((*it2).first-a[i])<p){
                p = abs((*it2).first-a[i]),j = (*it2).second;
            }
        }
        cout << p << " " << j << endl;
    }
    return 0;
}

```

---

## 作者：starfallen (赞：6)

## 形式化题意

给定一个长度为 $n$ 的序列 $A$，$A$ 中的数各不相同。

对于 $A$ 中的每一个数 $A_i$，求：

$\min_{1 \le j <i}|A_i-A_j|$

以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择使 $j$ 较小的那个。

本来就很简洁了。

## 做法

给大家推荐一个好 STL：`std::set`。

你只用理解成一个会自动给你排序，并且向前后移动指针都是 $\Theta(\log(n))$ 的容器就行了。

使用 `s.find(a)` 就是在 `s` 这个 `set` 里找到 `a` 这个元素，并返回它的指针（时间复杂度 $\Theta(\log(n))$）。

然后我们再比较它与前后的差异就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
set<pii> s;
int n, a;
int main() {
	ios_base::sync_with_stdio(false);
	cin >> n >> a;
	s.insert(make_pair(a, 1));
	for (int i = 2; i <= n; ++i) {
		cin >> a;
		s.insert(make_pair(a, i));
		set<pii>::iterator t = s.find(make_pair(a, i));
		pii ans;
		ans.first = 1e9;
		if (++t != s.end()) {
			ans = make_pair(t->first - a, t->second);
		}
		--t;
		if (t-- != s.begin() && ans.first >= a - t->first) {
			ans = make_pair(a - t->first, t->second);
		}
		cout << ans.first << ' ' << ans.second << endl;
	}
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：5)

投一波 Hash + 链表。

这是一种离线做法。

先观察，$1 \le j <i$。

那么，离线之后倒序处理最好了。

先对 $a_i$ 排序。

再按排序的顺序插入链表。

让 $i$ 从 $n$ 枚举到 $2$。

每次从链表里删去在**原序列**排名为 $i$ 的数，在删除前看下自己两边的数，哪个离 $a_i$ 的值较近，就取哪个。

这样能求出所需的答案。

找在**原序列**排名为 $i$ 的数可以用 Hash 记录。

其他都用链表 $O(1)$ 完成。

这样就可以很好的用链表的性质。

加个小基数排序，理论 $O(n)$ 解决。

接着，一首小诗献上。

我爱 STL。

他给我了常数。

他给了我码疯。

但是。

他还给了我便捷。

他还给了我码短。

有时候，明知常数大，却要去图方便。

有时候，明知代码乱，却要去压码长。

啊！万恶的 STL。

请大家配着代码自行体会。

**致管理，这只是在说明 STL 用多了的后果。**

```cpp
#include<bits/stdc++.h>
using namespace std;
list<int>s;//STL发癫之作
int n,a[int(1e5)+10],b[int(1e5)+10];
int buc[310],c[int(1e5)+10];
void radix_sort(int a[],int l,int r){
    for(int i=l;i<=r;i++) a[i]+=1e9;
	int radix=0;
	for(int i=1;i<=4;i++){
		memset(buc,0,sizeof buc);
		for(int j=l;j<=r;j++) buc[(a[j]>>radix)&255]++;
		for(int j=0;j<256;j++) buc[j]+=buc[j-1];
		for(int j=r;j>=l;j--) c[l+(buc[(a[j]>>radix)&255]--)-1]=a[j];
		for(int j=l;j<=r;j++) a[j]=c[j];
		radix+=8;
	}
	for(int i=l;i<=r;i++) a[i]-=1e9;
}
unordered_map<int,int>mp;
unordered_map<int,list<int>::iterator>pos;
stack<pair<int,int> >st;
int main() {
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[i]=a[i];
		mp[a[i]]=i;
	}
	radix_sort(a,1,n);
	for(int i=1;i<=n;i++){
		s.push_back(a[i]);
		pos[a[i]]=prev(s.end());
	}
	for(int i=n;i>1;i--){
		list<int>::iterator it=pos[b[i]];
		int t1=2e9,t2=2e9;
		if(next(it)!=s.end()) t1=*next(it);
		if(it!=s.begin()) t2=*prev(it);
		int ans;
		if(t2==2e9) ans=t1;
		else if(t1==2e9) ans=t2;
		else if(abs(t1-*it)==abs(t2-*it))
			ans=t2;
		else if(abs(t1-*it)<abs(t2-*it))
			ans=t1;
		else ans=t2;
		st.push({abs(ans-*it),mp[ans]});
		s.erase(it);
	}
	while(!st.empty()) cout<<st.top().first<<" "<<st.top().second<<"\n",st.pop();
	return 0;
}
```
~~TM 的，一个 $O(n)$ 的连 $O(n\log n)$ 平衡树都跑不过。~~

---

## 作者：c______ (赞：2)

提供一种双链表的做法：

## 思路
先将 $A$ 数组排序，再用 $B$ 数组，记录 $A$ 中元素在双链表的位置。

为了后面的点对前面情况点答案计算无影响，采用倒序枚举每个点在链表的位置从 $n$ 到 $n - 2$ ，计算左侧和右侧答案，比较大小，用 ```pair<int, int>``` 记录答案及位置，把该点删除计算再前一次。

最后输出答案即可。

时间复杂度 $O(n\log n)$ ，瓶颈在排序.

## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5 + 5;
const ll INF = 2e18;

int n;
int l[N], r[N], b[N];
struct node
{
    ll val, id;
    bool operator< (const node &e) const
    {
        return val < e.val;
    }
}a[N];
pair<ll, ll> ans[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++)
    {
        cin >> a[i].val;
        a[i].id = i;
    }
    sort(a + 1, a + 1 + n);
    a[0].val = -INF,a[n + 1].val = INF;
    for (int i = 1; i <= n; i ++)
    {
        l[i] = i - 1;
        r[i] = i + 1;
        b[a[i].id] = i;
    }
    for(int i = n; i >= 2; i --)
    {
        ll pos = b[i];
        ll lpos = l[pos], rpos = r[pos];
        ll lval = abs(a[pos].val - a[lpos].val);
        ll rval = abs(a[pos].val - a[rpos].val);
        if(lval <= rval)
            ans[i] = make_pair(lval, a[lpos].id);
        else
            ans[i] = make_pair(rval, a[rpos].id);
        r[lpos] = rpos;
        l[rpos] = lpos;
    }
    for (int i = 2; i <= n; i ++)
        cout << ans[i].first << " " << ans[i].second << endl;
    return 0;
}
```

---

## 作者：hzoi_Shadow (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10466)

# 前置知识

[二叉搜索树 & 平衡树](https://oi-wiki.org/ds/bst/)

# 解法

笔者写这篇题解的时候题面应该是出锅了，建议去看 [Acwing](https://www.acwing.com/problem/content/138/) 的题面。

第一问同 [luogu P2234 [HNOI2002] 营业额统计](https://www.luogu.com.cn/problem/P2234) ，平衡树维护前驱、后继（非严格意义上的）求出差值后取 $\min$ 即可；第二问用 ``map`` 实现一个映射即可维护位置。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
const ll INF=0x3f3f3f3f3f3f3f3f;
ll rt_sum=0;
map<ll,ll>f;
struct Treap
{
    ll son[2],val,rnd,cnt,siz;
}tree[100010];
#define lson(rt) (tree[rt].son[0])
#define rson(rt) (tree[rt].son[1])
#define dson(rt,d) (tree[rt].son[d])
#define ason(rt,d) (tree[rt].son[d^1])
void pushup(ll rt)
{
    tree[rt].siz=tree[lson(rt)].siz+tree[rson(rt)].siz+tree[rt].cnt;
}
ll build(ll val)
{
    rt_sum++;
    lson(rt_sum)=rson(rt_sum)=0;
    tree[rt_sum].val=val;
    tree[rt_sum].rnd=rand();
    tree[rt_sum].cnt=tree[rt_sum].siz=1;
    return rt_sum;
}
void rotate(ll &rt,ll d)
{
    ll lsrt=ason(rt,d);
    ason(rt,d)=dson(lsrt,d);
    dson(lsrt,d)=rt;
    pushup(rt);
    rt=lsrt;
    pushup(rt);
}
void insert(ll &rt,ll val)
{
    if(rt==0)
    {
        rt=build(val);
    }
    else
    {
        if(tree[rt].val==val)
        {
            tree[rt].cnt++;
            tree[rt].siz++;
        }
        else
        {
            ll d=(val>tree[rt].val);
            insert(dson(rt,d),val);
            if(tree[rt].rnd<tree[dson(rt,d)].rnd)
            {
                rotate(rt,d^1);
            }
            pushup(rt);
        }
    }
}
ll query_pre(ll rt,ll val)
{
    if(rt==0)
    {
        return -INF;
    }
    if(tree[rt].val<val)
    {
        return max(tree[rt].val,query_pre(rson(rt),val));
    }
    else
    {
        return query_pre(lson(rt),val);
    }
}
ll query_lower(ll rt,ll val)
{
    if(rt==0)
    {
        return INF;
    }
    if(tree[rt].val>=val)
    {
        return min(tree[rt].val,query_lower(lson(rt),val));
    }
    else
    {
        return query_lower(rson(rt),val);
    }
}
int main()
{
    ll n,x,rt=0,sum1,sum2,i;
    srand(time(0));
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>x;
		if(i>=2)
		{
			sum1=query_pre(rt,x);
			sum2=query_lower(rt,x);
			if(x-sum1<sum2-x)
			{
				cout<<x-sum1<<" "<<f[sum1]<<endl;
			}
			if(x-sum1==sum2-x)
			{
				cout<<x-sum1<<" "<<f[min(sum1,sum2)]<<endl;
			}
			if(x-sum1>sum2-x)
			{
				cout<<sum2-x<<" "<<f[sum2]<<endl;
			}
		}
        insert(rt,x);
		if(f.find(x)==f.end())
		{
			f[x]=i;
		}
    }
    return 0;
}
```

---

## 作者：YuzhenQin (赞：2)

## 题意

给定一个长度为 $n$ 的序列 $A$，$A$ 中的数各不相同。

对于 $A$ 中的每一个数 $A_i$，求：$\min_{1 \le j <i}|A_i-A_j|$。

以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择使 $j$ 较小的那个。

## 做法

对于 $A_i$ 求出比它小的第一个数和比它大的第一个数（前驱和后继），选择差的绝对值小的一个。如果差的绝对值相等，选择在序列中靠前的一个。

可以使用 `std::set` 来存储序列，用 `std::set::lower_bound()` 和 `std::set::upper_bound()` 查询前驱和后继。用一个 `std::map` 保存序列里值的位置。

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(void) {
	int n;
	cin >> n;
	
	set<int> s;
	map<int, int> mp;
	
	int tmp;
	cin >> tmp;
	s.insert(tmp);
	mp[tmp] = 1;
	
	for(int i = 2; i <= n; i++) {
		cin >> tmp;
		
		s.insert(tmp);
		
		mp[tmp] = i;
		
		auto it_lower = s.lower_bound(tmp),
		     it_upper = s.upper_bound(tmp);
		
		int minval = 0x3f3f3f3f, pj = 0;
		
		if(it_lower != s.begin()) {
			--it_lower;
			// cout << *it_lower << endl;
			if(abs(tmp - *it_lower) < minval) {
				minval = abs(tmp - *it_lower);
				pj = mp[*it_lower];
			}
		}
		
		if(it_upper != s.end()) {
			// cout << *it_upper << endl;
			if(abs(tmp - *it_upper) < minval) {
				minval = abs(tmp - *it_upper);
				pj = mp[*it_upper];
			}
		}
		
		cout << minval << " " << pj << endl;
	}
	
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

对于每一个数字 $a_i$ 而言，要得到一个值，使得他们的差的绝对值最小。那么，这个值只可能是在排序情况下的前一个或后一个位置的值。

我们发现，对于最后一个数字而言，因为没有数字在它的后面，所以，这个数字的答案可以直接比较排序后前后两个值的大小来计算。去除掉最后一个数字后，倒数第二个数变成了最后一个数，其计算方式于原最后一个数的计算方式同理。

所以，我们只需要找到每个数字在原来序列的位置，用静态链表存储每个数字在原序列上的位置和排序后的位置即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,p[100005],l[100005],r[100005];
struct node{
	int now,nxt;
}a[100005],s[100005];
bool cmp(node x,node y){
	if(x.now==y.now)return x.nxt<y.nxt;
	return x.now<y.now;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].now;
		a[i].nxt=i;
	}
	a[0].now=1e9;
	a[n+1].now=-1e9;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		p[a[i].nxt]=i;
		l[i]=i-1;
		r[i]=i+1;
	}
	for(int i=n;i>=2;i--){
		int x=p[i];
		int tl=l[x],tr=r[x];
		int vl=abs(a[x].now-a[tl].now);
		int vr=abs(a[x].now-a[tr].now);
		if(vl<=vr){
			s[i].now=vl;
			s[i].nxt=a[tl].nxt;
		}
		else{
			s[i].now=vr;
			s[i].nxt=a[tr].nxt;
		}
		r[tl]=tr;
		l[tr]=tl; 
	}
	for(int i=2;i<=n;i++){
		cout<<s[i].now<<" "<<s[i].nxt<<"\n";
	}
	return 0;
}
```

---

## 作者：Moya_Rao (赞：1)

# 题目大意
给定一个长度为 $n$ 的序列 $A$，保证 $A$ 中的数字各不相同。  
现在要求对于每一个 $2 \le i \le n$ 的 $i$，求出 
$\min_{1 \le j <i}|A_i-A_j|$，并同时求出使 $A_j$ 较小的那个 $j$。

# 思路

首先用一个结构体输入进来，并把结构体中的 $nxt$ 变量设为 $i$，即它原本的位置。  
接着，我们在 $a_0$ 和 $a_{n+1}$ 里存下极大极小值，这里我使用的是 `0x3f3f3f3f`。  
然后我们排一次序，优先按照值来排，值相同则按位置来排。  
再开一个 $p$ 数组，$p_i$ 里边存的就是原本位置是 $i$ 的数值现在的位置。并且用 $l$ 和 $r$ 两个数组来存链表。

重要环节到了！  
先存下那两个可能的较小差值，再进行比较。  
如果两个差值不同，选差值小的那个；  
如果两个差值相同，选原值更小的那个。  
并且，把答案依次存进 $ans$ 数组里。

最后，把 $ans$ 数组输出，就搞定了！

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
int n,p[N],l[N],r[N];
struct number{int x,nxt;}a[N];//链表
int as1[N],as2[N];//即 ans
bool cmp(number a1,number a2){//按照这个排序，均为从小到大
    if(a1.x==a2.x)return a1.nxt<a2.nxt;//x 相同则按 nxt
    return a1.x<a2.x;//优先按 x
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){cin>>a[i].x;a[i].nxt=i;}//输入 + 初始化
    a[0].x=0x3f3f3f3f,a[n+1].x=-0x3f3f3f3f;//存下极大值
    sort(a+1,a+n+1,cmp);//排一次序
    for(int i=1;i<=n;i++)p[a[i].nxt]=i,l[i]=i-1,r[i]=i+1;//存链表
    for(int i=n;i>=2;i--){//倒叙扫
        int num=p[i];
        int id_l=l[num],id_r=r[num];
        int ml=abs(a[num].x-a[id_l].x);
        int mr=abs(a[num].x-a[id_r].x);//存下两个小值
        if(ml<=mr)/* 注意是 <=，不是 < */as1[i]=ml,as2[i]=a[id_l].nxt;
        else as1[i]=mr,as2[i]=a[id_r].nxt;
        l[id_r]=id_l,r[id_l]=id_r;//链表迭代更新
    }
    for(int i=2;i<=n;i++)cout<<as1[i]<<" "<<as2[i]<<endl;//输出 as 即可
    return 0;
}



```
此处有 [AC 代码提交记录](https://www.luogu.com.cn/record/171321785)哦！

---

## 作者：niuzh (赞：0)

## 思路

由于只有求一个数的前驱和后继，所以考虑用搜索树，而手写没有必要，所以可以用 $set$。

具体实现就是求这个数的 upper_bound 和 upper_bound 指针的上一个，因为当前的数还没有加入，上一个指针指向的数一定是比它小并且最大的数。

## 代码

```cpp
/*
 * @FilePath: test.cpp
 * @Author: niu-zh
 */
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf=2147483647;
set<pair<int,int>> s;//需要存下标
int main()
{
	int n;
	cin>>n;
	s.insert({inf,0});
	s.insert({-inf,0});//第一重防止越界
	for (int i=1; i<=n; i++)
	{
		ll v;
		cin>>v;
		if (i>1)
		{
			auto it1=s.upper_bound({v,0}),it2=it1;
			it2--;//上一个，不是当前的数
			ll l=v-it2->first,r=it1->first-v;
			if (it2->first==-inf)//第二重防止越界
			{
				l=inf;
			}
			else if (it1->first==inf)
			{
				r=inf;
			}
			if (l<=r)
			{
				cout<<l<<" "<<it2->second<<'\n';
			}
			else
			{
				cout<<r<<" "<<it1->second<<'\n';
			}
		}
		s.insert({v,i});
	}
	return 0;
}
```

---

## 作者：leiaxiwo (赞：0)

# 题解：P10466 邻值查找
### [传送门](https://www.luogu.com.cn/problem/P10466)
### 题意分析

给定一个长度为 $n$ 的序列 $A$，$A$ 中的数**各不相同**。

对于 $A$ 中的每一个数 $A_i$，求：

$\min_{1 \le j <i}|A_i-A_j|$

以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择**使 $j$ 较小的那个**。

~~这不就是题面吗~~。

那么我们可以很方便地使用平衡树完成它。

不会平衡树的建议去[这里](https://www.luogu.com.cn/problem/P3369)熟悉一下。

### 参考代码
我考虑到有大佬用了 splay 完成它，那我来一发 fhq_treap 吧。

~~珍爱账号，远离copy。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int root=0,tot=0;

struct FHQ_treap{
	struct fhq_treap{
		int l,r,val,siz,dat;
	}tree[500005];
	inline void update(int x){
		tree[x].siz=tree[tree[x].l].siz+tree[tree[x].r].siz+1;
		return ;
	}
	inline int newnode(int x){
		tree[++tot].val=x;
		tree[tot].siz=1;
		tree[tot].dat=rand();
		return tot;
	}
	inline void split(int k,int key,int &x,int &y){
		if(k==0){
			x=y=0;
			return ;
		}
		if(tree[k].val<=key){
			x=k;
			split(tree[x].r,key,tree[x].r,y);
		}
		else{
			y=k;
			split(tree[y].l,key,x,tree[y].l);
		}
		update(k);
		return ;
	}
	inline int merge(int x,int y){
		if(x==0){
			return y;
		}
		if(y==0){
			return x;
		}
		if(tree[x].dat>tree[y].dat){
			tree[x].r=merge(tree[x].r,y);
			update(x);
			return x;
		}
		else{
			tree[y].l=merge(x,tree[y].l);
			update(y);
			return y;
		}
	}
	void insert(int key){
		int x,y;
		split(root,key-1,x,y);
		int id=newnode(key);
		root=merge(merge(x,id),y);
		return ;
	}
	void remove(int key){
		int x,y,z;
		split(root,key-1,x,y);
		split(y,key,y,z);
		if(y){
			y=merge(tree[y].l,tree[y].r);
		}
		root=merge(merge(x,y),z);
		return ;
	}
	int rnk(int key){
		int x,y,ans;
		split(root,key-1,x,y);
		ans=tree[x].siz+1;
		root=merge(x,y);
		return ans;
	}
	int kth(int rnk){
		int p=root;
		while(p){
			if(tree[tree[p].l].siz+1==rnk){
				break;
			}
			else if(tree[tree[p].l].siz+1>rnk){
				p=tree[p].l;
			}
			else{
				rnk-=tree[tree[p].l].siz+1;
				p=tree[p].r;
			}
		}
		return tree[p].val;
	}
	int pre(int key){
		int x,y,p;
		split(root,key-1,x,y);
		p=x;
		while(tree[p].r!=0){
			p=tree[p].r;
		}
		root=merge(x,y);
		return tree[p].val;
	}
    int next(int key){
		int x,y,p;
		split(root,key,x,y);
		p=y;
		while(tree[p].l!=0){
			p=tree[p].l;
		}
		root=merge(x,y);
		return tree[p].val;
	}
}liver_treap;
int n;
signed main(){
	srand(time(0));
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		liver_treap.insert(x);
		if(i==1){
			continue;
		}
		int rnk=liver_treap.rnk(x);
		if(rnk==1){
			int kth=liver_treap.kth(2);
			printf("%d %d\n",kth-x,2);
		}
		else if(rnk==i){
			int kth=liver_treap.kth(i-1);
			printf("%d %d\n",x-kth,i-1);
		}
		else{
			int kth1=liver_treap.kth(rnk-1);
			int kth2=liver_treap.kth(rnk+1);
			if(x-kth1<=kth2-x){
				printf("%d %d\n",x-kth1,rnk-1);
			}
			else{
				printf("%d %d\n",kth2-x,rnk+1);
			}
		}
	}
	return 0;
}
```

---

## 作者：Jerry_heng (赞：0)

（一）

[A potentially better experience](https://www.cnblogs.com/Jh763878/p/18197577)

出门左转 [P3369](https://www.luogu.com.cn/problem/P3369)。

只需要同时记录原本属于哪一位即可。

这里给出 Splay 做法。

（二）

AC 代码。

建议自己打一遍巩固印象。~~虽然我是直接拉过来的。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
  int x=0,f=1;char c=getchar();
  while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
  while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
  return x*f; 
}
int n,rt,cnt;
struct node{
	int msiz,tsiz,val,ch[2],f,id;
}tree[1000010];
void maintain(int o){
	if(!o)return;
	tree[o].tsiz=tree[o].msiz;
	if(tree[o].ch[0])tree[o].tsiz+=tree[tree[o].ch[0]].tsiz;
	if(tree[o].ch[1])tree[o].tsiz+=tree[tree[o].ch[1]].tsiz;
}
int get(int o){
	return tree[tree[o].f].ch[1]==o;
}
void clear(int o){
	tree[o].ch[0]=tree[o].ch[1]=tree[o].f=tree[o].msiz=tree[o].tsiz=0;
}
int find_pre(){
	int o=tree[rt].ch[0];
	while(tree[o].ch[1])o=tree[o].ch[1];
	return o;
}
int find_nxt(){
	int o=tree[rt].ch[1];
	while(tree[o].ch[0])o=tree[o].ch[0];
	return o;
}
void rotate(int o){
	int fa=tree[o].f,ffa=tree[fa].f,pos=get(o);
	tree[fa].ch[pos]=tree[o].ch[pos^1];
	tree[tree[fa].ch[pos]].f=fa;
	tree[o].ch[pos^1]=fa;
	tree[fa].f=o;
	tree[o].f=ffa;
	if(ffa)tree[ffa].ch[tree[ffa].ch[1]==fa]=o;
	maintain(fa);
	maintain(o);
}
void splay(int o){
	for(int fa;fa=tree[o].f;rotate(o))
		if(tree[fa].f)rotate((get(o)==get(fa))?fa:o);
	rt=o;
}
void insert(int x,int id){
	if(!rt){
		cnt++;
		rt=cnt;
		tree[cnt].ch[0]=tree[cnt].ch[1]=0;
		tree[cnt].f=0;
		tree[cnt].msiz=tree[cnt].tsiz=1;
		tree[cnt].val=x;
		tree[cnt].id=id;
		return;
	}
	int o=rt,fa=0;
	while(1){
		if(x==tree[o].val){
			tree[o].msiz++;
			maintain(o);
			maintain(fa);
			splay(o);
			break;
		}
		fa=o;
		o=tree[o].ch[x>tree[o].val];
		if(!o){
			cnt++;
			tree[cnt].ch[0]=tree[cnt].ch[1]=0;
			tree[cnt].msiz=tree[cnt].tsiz=1;
			tree[cnt].val=x;
			tree[cnt].f=fa;
			tree[cnt].id=id;
			tree[fa].ch[tree[fa].val<x]=cnt;
			maintain(fa);
			splay(cnt);
			break;
		}
	}
}
int find_rank(int x){
	int ans=0,o=rt;
	while(1){
		if(x<tree[o].val)o=tree[o].ch[0];
		else{
			if(tree[o].ch[0])ans+=tree[tree[o].ch[0]].tsiz;
			if(x==tree[o].val){
				splay(o);
				return ans+1;
			}
			ans+=tree[o].msiz;
			o=tree[o].ch[1];
		}
	}
}
void remove(int x){
	int r=find_rank(x);
	if(tree[rt].msiz>1){
		tree[rt].msiz--;
		maintain(rt);
		return;
	}
	if(!tree[rt].ch[0]&&!tree[rt].ch[1]){
		clear(rt);
		rt=0;
	}
	else if(!tree[rt].ch[0]){
		int xx=rt;
		rt=tree[rt].ch[1];
		tree[rt].f=0;
		clear(xx);
	}
	else if(!tree[rt].ch[1]){
		int xx=rt;
		rt=tree[rt].ch[0];
		tree[rt].f=0;
		clear(xx);
	}
	else{
		int pos=find_pre(),xx=rt;
		splay(pos);
		tree[rt].ch[1]=tree[xx].ch[1];
		tree[tree[xx].ch[1]].f=rt;
		clear(xx);
		maintain(rt);
	}
}
node find_val(int x){
	int o=rt;
	while(1){
		if(tree[o].ch[0]&&tree[tree[o].ch[0]].tsiz>=x)o=tree[o].ch[0];
		else{
			int s=(tree[o].ch[0]?tree[tree[o].ch[0]].tsiz:0)+tree[o].msiz;
			if(x<=s)return tree[o];
			x-=s;
			o=tree[o].ch[1];
		}
	}
}
signed main(){
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		int x=read();
		insert(x,i);
		if(i==1)continue;
		int rk=find_rank(x);
		if(rk==1){
			node t=find_val(2);
			printf("%lld %lld\n",t.val-x,t.id);
		}
		else if(rk==i){
			node t=find_val(i-1);
			printf("%lld %lld\n",x-t.val,t.id);
		}
		else{
			node t1=find_val(rk-1),t2=find_val(rk+1);
			if(x-t1.val<=t2.val-x)printf("%lld %lld\n",x-t1.val,t1.id);
			else printf("%lld %lld\n",t2.val-x,t2.id);
		}
	}
    return 0;
}
```

---


# [蓝桥杯 2025 省 C/Java A/研究生组] 冷热数据队列

## 题目描述

冷热数据队列 $q$ 可以看做由两个子队列组成：长度为 $n_1$ 的热数据队列 $q_1$ 和长度为 $n_2$ 的冷数据队列 $q_2$。当我们需要访问某个数据页 $p$ 时：

1. 若 $p$ 不在队列 $q$ 中（即既不在 $q_1$ 中，也不在 $q_2$ 中），则加载数据页 $p$，并插入到 $q_2$ 的首部。
2. 若 $p$ 已经在队列 $q$ 中，则将 $p$ 移动至 $q_1$ 首部。
3. 当 $q_1$ 或 $q_2$ 队列容量不足时，会将其尾部的数据页淘汰出去。
4. 当 $q_1$ 已满，但 $q_2$ 未满时，从 $q_1$ 中淘汰出的数据页会移动到 $q_2$ 首部。

## 说明/提示

### 样例说明

| $i$   | $v_i$   | $q_1$           | $q_2$           |
|-------|---------|-----------------|-----------------|
| $- $  | $-$     | $[]$            | $[]$            |
| $1 $  | $1$     | $[]$            | $[1]$           |
| $2 $  | $2$     | $[]$            | $[2,1]$         |
| $3 $  | $3$     | $[]$            | $[3,2,1]$       |
| $4 $  | $4$     | $[]$            | $[4,3,2]$       |
| $5 $  | $3$     | $[3]$           | $[4,2]$         |
| $6 $  | $2$     | $[2,3]$         | $[4]$           |
| $7 $  | $2$     | $[2,3]$         | $[4]$           |
| $8 $  | $1$     | $[2,3]$         | $[1,4]$         |
| $9 $  | $3$     | $[3,2]$         | $[1,4]$         |
| $10$  | $4$     | $[4,3,2]$       | $[1]$           |

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n_1, n_2 \leq 10$，$1 \leq m \leq 10$；
- 对于 $40\%$ 的评测用例，$1 \leq n_1, n_2 \leq 20$，$1 \leq m \leq 100$；
- 对于 $60\%$ 的评测用例，$1 \leq n_1, n_2 \leq 100$，$1 \leq m \leq 1000$；
- 对于 $80\%$ 的评测用例，$1 \leq n_1, n_2 \leq 10^3$，$1 \leq m \leq 10^4$；
- 对于所有评测用例，$1 \leq n_1, n_2 \leq 10^4$，$1 \leq m \leq 10^5$，$0 \leq v_i \leq 10^4$。

## 样例 #1

### 输入

```
3 3
10
1 2 3 4 3 2 2 1 3 4```

### 输出

```
4 3 2
1```

# 题解

## 作者：YBa2Cu3O7 (赞：8)

## 背景简介
最近最少使用（LRU）算法是一种常用的缓存淘汰算法，用于在缓存空间不足时决定哪些数据应该被移除。其基本思想是，如果一个数据最近被访问过，那么它将来被访问的概率也会更高。因此，当缓存空间不足时，应该优先淘汰最久未被访问的数据。

基于LRU原理的各种变体经常被应用到操作系统的内存页面置换策略和数据库的缓冲池管理中。

## 算法描述

### LRU算法
使用双向链表+哈希表的组合结构实现时间复杂度 $O(1)$ 的插入，查找和删除。其中双向链表描述了历史访问顺序，哈希表记录了页面编号到链表节点指针的映射，用于查找和确定位置。

对于要调用的新页面，先检查是否已经存在于队列中，这是通过查哈希表来实现的。如果已经存在，那么先将这个节点移出队列，再放到队首，否则执行插入流程。

将新页面插入到队首，插入前检查队列容量是否已满，如果满了则先把队尾页面出队（这里描述的名称似乎和普通队列刚好反过来），再将新页面入队，同时用哈希表记录页面编号到链表节点指针的映射。

出队时除了整理链表中的指针关系，还要记得在哈希表中删除对应的映射。

### 冷热数据队列
本题相当于在四条额外规则下维护两个LRU队列。在这种情况下，多出了热队列中的页面出队后还要向冷队列中入队，第一次调用要先向冷队列中入队等操作。

## 代码解释
这种大模拟题最好还是写得工程化一些，语义明确，减少耦合，能少写很多不必要的代码，也便于debug。

代码中的结构体 `node` 作为双向链表的节点，存储页面编号和前后节点的两个指针。类 `lru` 即为LRU算法的实现，为了方便插入和删除，在双向链表的头尾各添加一个辅助节点，其中不存储任何信息。类 `hotcoldq` 是解决问题的核心类，包括两个LRU队列作为成员变量和插入函数作为成员函数。其中 `q1` 表示热队列，`q2` 表示冷队列。

成员函数 `lru::move` 是用来配合做移动操作的，减少 `new` 的次数。其它诸如 `lru::begin` 的函数则是一点个人代码爱好（~~伪装成标准库~~），本质上是可以不用的。正常来说 `lru` 应该有一个自己的插入函数，但是本题没有用到就没有特别去写了，它本质上就是一个 `new`/`move`+`push` 的组合。

这里除输出外没有需要遍历的操作，因此没有添加相应的迭代器类，直接操纵了指针。重载的函数也仅仅是为了方便使用，其中的指导思想是，**任何与应用逻辑无关的部分，都应该在类成员函数中处理而不是在外部调用时**。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
struct node {
	T num;
	node* nxt;
	node* pre;
	node(T n = 0) :num(n), nxt(0), pre(0) {}
};

template <typename T>
class lru {
	size_t maxsz;
	size_t sz;
	node<T>* q;
	node<T>* qend;
	unordered_map<T, node<T>*> ump;

public:
	lru(size_t n) :sz(0), maxsz(n) {
		q = new node<T>;
		qend = new node<T>;
		q->nxt = qend;
		qend->pre = q;
	}

	size_t size() {
		return sz;
	}

	size_t maxsize() {
		return maxsz;
	}

	bool full() {
		return sz == maxsz;
	}

	node<T>* end() {
		return qend;
	}

	node<T>* begin() {
		return q->nxt;
	}

	void push(node<T>* p) {
		if (full()) {
            erase(end()->pre);
        }
		auto nxt = q->nxt;
		p->nxt = nxt;
		nxt->pre = p;
		p->pre = q;
		q->nxt = p;
		++sz;
		ump[p->num] = p;
	}

	void push(T n) {
		auto* p = new node<T>(n);
		push(p);
	}

	node<T>* move(node<T>* p) {
		auto pre = p->pre;
		auto nxt = p->nxt;
		pre->nxt = nxt;
		nxt->pre = pre;
		--sz;
		ump.erase(p->num);
		return p;
	}

	node<T>* move(T n) {
		return move(ump[n]);
	}

	void erase(node<T>* p) {
		move(p);
		delete p;
	}

	void erase(T n) {
		erase(ump[n]);
	}

	node<T>* find(T n) {
		if (ump.find(n) == ump.end()) {
			return end();
		}
		else {
			return ump[n];
		}
	}

	void output() {
		for (node<T>* p = begin(); p != end(); p = p->nxt) {
			cout << p->num << ' ';
		}
	}

	~lru() {
		auto p = begin();
		while (p != qend) {
			auto q = p;
			p = p->nxt;
			delete q;
		}
		delete q;
		delete qend;
	}

};

template <typename T>
class hotcoldq {
	lru<T> q1, q2;

public:
	hotcoldq(T n, T m) :q1(n), q2(m) {}

	void insert(T n) {
		bool ck1 = (q1.find(n) == q1.end());
		bool ck2 = (q2.find(n) == q2.end());
		if (ck1 && ck2) {
			if (q2.full()) {
				q2.erase(q2.end()->pre);
			}
			q2.push(n);
		}
		else {
			node<T>* p = 0;
			if (!ck1) {
				p = q1.move(n);
			}
			else if (!ck2) {
				p = q2.move(n);
				if (q1.full()) {
					auto q = q1.move(q1.end()->pre);
					q2.push(q);
				}
			}
			q1.push(p);
		}
	}

	void output() {
		q1.output();
		cout << '\n';
		q2.output();
	}

	~hotcoldq() = default;

};

int main() {
	int n, m;
	cin >> n >> m;
	hotcoldq<int> q(n, m);
	int t;
	cin >> t;
	for (int i = 0; i < t; ++i) {
		int v;
		cin >> v;
		q.insert(v);
	}
	q.output();
	return 0;
}
```

---

## 作者：Merlin_Meow (赞：4)

## Analysis

模拟题。

注意到 C++ STL 给我们提供了做出这道题所需要的一切科技，我们硬做就好了。

- 注意到题中的 $q_1$，$q_2$ 都需要支持在支持在队头和队尾的操作，考虑使用 `deque` 维护。

- 我们还需要查询一个元素是否在队列内，可以使用哈希表维护，这里直接用 `unordered_set`。

- 对于已经在队列中的元素要移动到队头的情况，我们可以直接用 `find` 来找到元素并删除，随后重新插入。

随后按题意模拟操作即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define int long long

int n1, n2, m;

deque<int> q1, q2;
unordered_set<int> in_q1, in_q2;

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n1 >> n2;
    cin >> m;
    while (m--)
    {
        int p;
        cin >> p;
        if (in_q1.count(p))
        {
            q1.erase(find(q1.begin(), q1.end(), p));
            q1.push_front(p);
        }
        else if (in_q2.count(p))
        {
            q2.erase(find(q2.begin(), q2.end(), p));
            in_q2.erase(p);
            q1.push_front(p);
            in_q1.insert(p);
            if (q1.size() > n1)
            {
                int tail = q1.back();
                q1.pop_back();
                in_q1.erase(tail);
                if (q2.size() < n2)
                {
                    q2.push_front(tail);
                    in_q2.insert(tail);
                }
            }
        }
        else
        {
            q2.push_front(p);
            in_q2.insert(p);
            if (q2.size() > n2)
            {
                int tail = q2.back();
                q2.pop_back();
                in_q2.erase(tail);
            }
        }
    }
    for (int i = 0; i < q1.size(); ++i)
        cout << q1[i] << " ";
    cout << endl;
    for (int i = 0; i < q2.size(); ++i)
        cout << q2[i] << " ";
    cout << endl;
    return 0;
}
```

---

## 作者：Amidst (赞：3)

## 思路

直接模拟。我不会写工程化代码。

考虑使用 `list` 模拟两个队列，不用 `deque` 一个原因是常数太大，另一个原因是貌似不支持删除中间元素。

### 操作一

若 $p$ 不在队列 $q$ 中（即既不在 $q_1$ 中，也不在 $q_2$ 中），则加载数据页 $p$，并插入到 $q_2$ 的首部。

我们考虑开一个 `bitset` 或者 `bool` 数组 $vis$ 来记录对于某个 $p$ 其是否在队列中。若 $vis_i=0$，则在 $q_2$ 的头部插入元素 $p$，同时更新 $vis_i$。

当然，为了后面的淘汰元素考虑，我们可以开一个桶存储元素所在的队列和其所在位置的迭代器。

#### 实现

```cpp
if(vis[x])
{
  // ...
}
else
{
  vis[x]=1;
  qb.push_front(x);
  _Mp[x]=make_pair(2,qb.begin());
}
```

### 操作二

若 $p$ 已经在队列 $q$ 中，则将 $p$ 移动至 $q_1$ 首部。

这时候我们前面记录的 $vis$ 又起作用了。若 $vis_i=1$，找到桶中记录的 $p$ 所在的队列和指向 $p$ 的迭代器，利用 `erase` 删除即可，删除迭代器貌似是 $O(1)$ 的。最好不要使用 `remove`。

删除后重新将 $p$ 加入至 $q_1$ 首部，此时和操作一中的步骤类似，记录下 $p$ 所在的队列和其所在位置的迭代器。由于 $vis_i$ 已经等于 $1$，无需再更新。

#### 实现

```cpp
if(vis[x])
{
  auto tmp=_Mp[x];
  if(tmp.first==1)
    qa.erase(tmp.second);
  else
    qb.erase(tmp.second);
  qa.push_front(x);
  _Mp[x]=make_pair(1,qa.begin());
}
```

### 操作三

当 $q_1$ 或 $q_2$ 队列容量不足时，会将其尾部的数据页淘汰出去。

和操作四一起实现。

### 操作四

当 $q_1$ 已满，但 $q_2$ 未满时，从 $q_1$ 中淘汰出的数据页会移动到 $q_2$ 首部。

由于 $q_1$ 淘汰的元素会移动到 $q_2$，不妨考虑先淘汰 $q_1$ 中的元素，若加入 $q_2$ 后导致 $q_2$ 满了，再淘汰 $q_2$ 中的最后一个元素。`list` 自带 `rbegin` 返回指向最后一个元素的迭代器。

同样地，记录元素所在的队列及指向这个元素的迭代器，注意 $q_2$ 淘汰的元素的 $vis$ 值应当变为 $0$。

#### 实现

```cpp
if(qa.size()>na)
{
  auto tmp=*qa.rbegin();
  qb.push_front(tmp);
  _Mp[tmp]=make_pair(2,qb.begin());
  qa.pop_back();
}
if(qb.size()>nb)
{
  auto tmp=*qb.rbegin();
  vis[tmp]=0;
  qb.pop_back();
}
```

### 输出

遍历两个链表即可。

#### 实现

```cpp
for(auto i:qa)
  printf("%d ",i);
printf("\n");
for(auto i:qb)
  printf("%d ",i);
printf("\n");
```

## 代码

算上我~~又臭又长~~的缺省源总共六十多行。非常好写。

```cpp
#include <bits/stdc++.h>
//#include <bits/extc++.h>
//#define int long long
#define __MULTITEST__
#undef __MULTITEST__
using namespace std;
//using namespace __gnu_cxx;
//using namespace __gnu_pbds;
int na,nb,m;
list<int> qa,qb;
bitset<100005> vis;
pair<int,list<int>::iterator> _Mp[100005];
signed main()
{
	#ifdef __MULTITEST__
	signed T;
	scanf("%d",&T);
	while(T--)
	{
	#endif
		scanf("%d%d%d",&na,&nb,&m);
		for(int i=1;i<=m;i++)
		{
			int x;
			scanf("%d",&x);
			if(vis[x])
			{
				auto tmp=_Mp[x];
				if(tmp.first==1)
					qa.erase(tmp.second);
				else
					qb.erase(tmp.second);
				qa.push_front(x);
				_Mp[x]=make_pair(1,qa.begin());
			}
			else
			{
				vis[x]=1;
				qb.push_front(x);
				_Mp[x]=make_pair(2,qb.begin());
			}
			if(qa.size()>na)
			{
				auto tmp=*qa.rbegin();
				qb.push_front(tmp);
				_Mp[tmp]=make_pair(2,qb.begin());
				qa.pop_back();
			}
			if(qb.size()>nb)
			{
				auto tmp=*qb.rbegin();
				vis[tmp]=0;
				qb.pop_back();
			}
		}
		for(auto i:qa)
			printf("%d ",i);
		printf("\n");
		for(auto i:qb)
			printf("%d ",i);
		printf("\n");
	#ifdef __MULTITEST__
	}
	#endif
	return 0;
}
```

---

## 作者：Gongyujie123 (赞：2)

## [P12166 [蓝桥杯 2025 省 C/Java A/研究生组] 冷热数据队列](https://www.luogu.com.cn/problem/B4279)题解
### 1. 思路分析
**一道模拟题，我们直接使用 STL 大法即可。**

首先，对于题目中的两个队列，我们注意到操作 2（若 $p$ 已经在队列 $q$ 中，则将 $p$ 移动至 $q_1$ 首部），我们很容易想到把 $p$ 在 $q$ 中删除，再从 $q_1$ 首部插入。但如果用 $O(n)$ 的时间复杂度删除很明显会超时，这里用 $O(1)$ 删除的 `list`（也就是链表）来存储。

但是 `list` 只能删除指定的迭代器，我们再用 $O(n)$ 的时间复杂度查询 $p$ 在 $q_1$ 或 $q_2$ 中的位置上的迭代器吗？

我们可以使用两个 `map`（$m1$ 和 $m2$）来分别存储 $p$ 在 $q_1$ 和 $q_2$ 中的位置上的迭代器。

然后就是实现这四个操作：

1. 若 $m1_p$ 和 $m2_p$ 都不存在迭代器，就将 $p$ 插入 $q_2$ 的开头，并且将 $m2_p$ 设为 $q_2$ 的开头。
2. 若 $m1_p$（或 $m2_p$）中存在迭代器，就在 $q_1$（或 $q_2$）中删除 $m1_p$（或 $m2_p$）指向的位置，并且将 $m1_p$（或 $m2_p$）删除。然后将 $p$ 插入 $q_2$ 的开头，并且将 $m2_p$ 设为 $q_2$ 的开头。
3. 每次在操作一和操作二之后执行操作三，若 $q_1$ 的长度大于 $n_1$ 或 $q_2$ 的长度大于 $n_2$，设超出的部分为 $u$，就将 $u$ 删除，并删除 $m1_u$ **或** $m2_u$。
4. 若执行操作三后 $q_2$ 的长度小于 $n_2$，就将操作三中的 $u$ 插入 $q_2$ 的开头，并且将 $m2_u$ 设为 $q_2$ 的开头。

最后，输出最终的 $q_1$ 和 $q_2$ 即可。

### 2. AC 代码
[AC 记录](https://www.luogu.com.cn/record/229205749)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
list<int> l1, l2;
map<int, list<int>::iterator> m1, m2;
int n1, n2;
void f() {
	if (l1.size() > n1 && l2.size() < n2) {  // 当 q1 已满，但 q2 未满时
		int t = l1.back();
		l2.push_front(t);
		l1.pop_back();
		m1.erase(t);
		m2[t] = l2.begin();
	} else if (l1.size() > n1) {  // 当 q1 已满时
		m1.erase(l1.back());
		l1.pop_back();
	} else if (l2.size() > n2) {  // 当 q2 已满时
		m2.erase(l2.back());
		l2.pop_back();
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n1 >> n2;
	int m;
	cin >> m;
	for (int i = 0; i < m; i++) {
		int p;
		cin >> p;
		if (m1.count(p)) { // 若 p 已经在队列 q1 中，即 m1[p] 中存在迭代器
			l1.erase(m1[p]);
			l1.push_front(p);
			m1[p] = l1.begin();
			f();  // 操作三与四
		} else if (m2.count(p)) {  // 若 p 已经在队列 q2 中，即 m2[p] 中存在迭代器
			l2.erase(m2[p]);
			l1.push_front(p);
			m2.erase(p);
			m1[p] = l1.begin();
			f();
		} else {  // 若 p 不在队列 q 中，即 m1[p] 和 m2[p] 都不存在迭代器
			l2.push_front(p);
			m2[p] = l2.begin();
			f();
		}
	}
	for (auto i : l1) cout << i << ' ';  // 遍历并输出 q1
	cout << endl;
	for (auto i : l2) cout << i << ' ';  // 遍历并输出 q2
	return 0;
}
```

---

## 作者：long_hao (赞：2)

# 思考
给大家献上一份最朴实无华的模拟做法。

不难发现，题中给出的冷热数据队列并非我们日常中常用的队列（queue）。因为我们平常用的队列，都是先来的在前面，后来者在后面，先进先出，后进后出。但题中的队列是后来者插在所插入队列的最前面，其实也不难，只需要我们手动模拟一下 $q1$ 和 $q2$ 队列就好。

不妨创建两个数组，代表 $q1$ 和 $q2$，同时创建一个数组 $v$ 来，使用 $v[x]$ 来代表 $x$ 是否存在于队列之中，此数组使用 $bool$ 类型也可以。

接下来我们定义一个函数 $cha$，专门用于将一个数据页插入队列当中，接下来结合题中所给的四个判断条件，可以得出以下代码：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
int q1[maxn],q2[maxn],v[maxn];//q1 q2 数组代表两个队列，q1[0] q2[0] 则代表该队列中有几个数据页。
int n1,n2,m;
void cha(int a[],int x,int n)//将 x 插入到 a 队列中，a 队列容量是 n。
{
    if(a[0]==n)
        v[a[n]]--;
    if(a[0]<n)
        a[0]++;
    for(int i=n;i>=2;i--)//整体位移。
        a[i]=a[i-1];
    a[1]=x;
    v[x]++;
}
int main()
{
    cin>>n1>>n2>>m;
    for(int i=1;i<=m;i++)
    {
        int temp_v;
        cin>>temp_v;
        if(v[temp_v]==0)//若查询的数据页不存在于队列中。
            cha(q2,temp_v,n2);
        else if(v[temp_v])
        {
            bool yes=false;
            int temp=0;
            for(int i=1;i<=q1[0];i++)
                if(q1[i]==temp_v)
                    yes=true,temp=i;//以 yes 代表数据页是不是在 q1 队列，temp 标记位置。
            if(yes)
            {
                for(int i=temp;i>=2;i--)
                    q1[i]=q1[i-1];
                q1[1]=temp_v;
            }
            else
            {
                for(int i=1;i<=q2[0];i++)
                    if(q2[i]==temp_v)
                        temp=i;
                for(int i=temp;i<q2[0];i++)
                    q2[i]=q2[i+1];
                q2[0]--;
                if(q1[0]==n1 && q2[0]<n2)
                {
                    cha(q2,q1[n1],n2);
                    q1[0]--;
                    v[q1[n1]]--;
                }
                cha(q1,temp_v,n1);
                v[temp_v]--;
            }
        }
    }
    for(int i=1;i<=q1[0];i++)
        cout<<q1[i]<<' ';
    cout<<endl;
    for(int i=1;i<=q2[0];i++)
        cout<<q2[i]<<' ';
    return 0;
}
```
这道题本质上还是一道模拟题，考验一些基础的代码功底。我们只需要根据题目中所给出的要求和条件写出对应的处理代码即可。

---

## 作者：linruicong_gegeji (赞：1)

一道模拟题。

## 题目分析

其实看到第一眼挺像某种 STL 的应用的。略微思考过后发现可以直接用 `list` 秒了。于是直接开始做。

### list 双向链表

没有学过的同学看这里。

双向链表虽然不支持随机访问，但是在任意位置插入或者删除元素非常高效。这里就不多讲了，感兴趣的同学可以自行了解。这里只介绍一些代码中用到的函数。

- `l.size();` 与许多容器相同，它是用来求元素个数的。
- `l.push_front(value);` 在头部添加元素。
- `l.pop_back();` 删除尾部元素。
- `l.erase(iterator position);` 删除指定位置元素。
- `l.begin();` 返回指向第一个元素的迭代器。
- `l.rbegin();` 返回指向最后一个元素的逆向迭代器。

## AC 代码实现
[记录](https://www.luogu.com.cn/record/229545183)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n1,n2,m,x,t;
pair<int,list<int>::iterator> d[1000005];//存储位置信息
list<int> q1,q2;//两个双向链表
map<int,bool> vis;//检查是否出现过
int main()
{
	scanf("%d%d%d",&n1,&n2,&m);
	for(int i=1;i<=m;i++)
    {
		scanf("%d",&x);
		if(vis[x]==false)//没有出现过
        {
            vis[x]=true;
            q2.push_front(x);
            d[x].first=2;
            d[x].second=q2.begin();
        }
		else//出现了
        {
			auto p=d[x];
			if(p.first==1) q1.erase(p.second);
			else q2.erase(p.second);
			q1.push_front(x);
            d[x].first=1;
            d[x].second=q1.begin();
		}
		if((int)q1.size()>n1)//对于热数据队列溢出的操作
        {
			t=*q1.rbegin();
			q2.push_front(t);
			d[t].first=2;
            d[t].second=q2.begin();
			q1.pop_back();
		}
		if((int)q2.size()>n2)//对于冷数据队列溢出的操作
        {
			t=*q2.rbegin();
			vis[t]=0;
			q2.pop_back();
		}
    }
    //输出答案
	for(auto i:q1) printf("%d ",i);
	printf("\n");
	for(auto i:q2) printf("%d ",i);
    return 0;
}

```

---

## 作者：封禁用户 (赞：1)

### 题目大意
有四个操作：
1. 若 $p$ 不在队列 $q$ 中（即既不在 $q_1$ 中，也不在 $q_2$ 中），则加载数据页 $p$，并插入到 $q_2$ 的首部。
2. 若 $p$ 已经在队列 $q$ 中，则将 $p$ 移动至 $q_1$ 首部。
3. 当 $q_1$ 或 $q_2$ 队列容量不足时，会将其尾部的数据页淘汰出去。
4. 当 $q_1$ 已满，但 $q_2$ 未满时，从 $q_1$ 中淘汰出的数据页会移动到 $q_2$ 首部。

### 题目思路
直接用链表大模拟。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
int n1,n2,m;
list<int> q1,q2;
bool b[1000005];
pair<int,list<int>::iterator> p[1000005];
int main(){
    scanf("%d%d%d",&n1,&n2,&m);
    while(m--){
        int x;
        scanf("%d",&x);
        if(!b[x]){
            q2.push_front(x);
            b[x]=1;
            p[x]={2,q2.begin()};
        }
        else{
            auto it=p[x];
            if(it.first==1)
                q1.erase(it.second);
            else    q2.erase(it.second);
            q1.push_front(x);
            p[x]={1,q1.begin()};
        }
        if(q1.size()>n1){
            int t=*q1.rbegin();   
            q2.push_front(t);
            p[t]={2,q2.begin()};
            q1.pop_back();
        }
        if(q2.size()>n2){
            int t=*q2.rbegin();   
            b[t]=0;
            q2.pop_back();
        }
    }
    for(auto i:q1)
        cout<<i<<' ';
    cout<<endl;
    for(auto i:q2)
        cout<<i<<' ';
}
```

---

## 作者：chenxinran12 (赞：0)

### 题意分析
我们拥有两个双端队列 $q_1$ 与 $q_2$，容量分别为 $n_1$  和 $n_2$。每次输入 $p$，然后依次进行三次操作。
- 若 $p$ 不在双端队列中，则将其加入 $q_2$ 的队头，否则将其在队列里删除后再加入 $q_1$ 的队头。
- 若 $q_1$ 超出了容量则弹出 $q_1$ 的队尾，此时若 $q_2$ 未满，则将 $q_1$ 的队尾加入 $q_2$ 的队头。若 $q_2$ 超出容量，则弹出 $q_2$ 的队尾。
最后输出 $q_1$ 和 $q_2$。
### 分析
模拟。  
我们用一个数组 $inv$ 记录此数在哪里。若值为 $0$，则此数不在双端队列里；若值为 $1$，则此数在 $q_1$ 里；若值为 $2$，则此数在 $q_2$ 里。之后就用两个双端队列模拟就行了。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n1,n2,m,op,inv[10002];
deque<int> q1,q2;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n1>>n2>>m;
	while(m--)
	{
		cin>>op;
		if(!inv[op])
		{
			inv[op]=2;
			q2.push_front(op);
		}
		else
		{
			if(inv[op]==1)
			{
				q1.erase(find(q1.begin(),q1.end(),op));
				q1.push_front(op);
			}
			else
			{
				q2.erase(find(q2.begin(),q2.end(),op));
				q1.push_front(op);
			}
			inv[op]=1;
		}
		while(q1.size()>n1)
		{
			inv[q1.back()]=0;
			if(q2.size()<n2)
			{
				q2.push_front(q1.back());
				inv[q1.back()]=2;
			}
			q1.pop_back();
		}
		while(q2.size()>n2)
		{
			inv[q2.back()]=0;
			q2.pop_back();
		}
	}
	while(q1.size())
	{
		cout<<q1.front()<<" ";
		q1.pop_front();
	}
	cout<<"\n";
	while(q2.size())
	{
		cout<<q2.front()<<" ";
		q2.pop_front();
	}
    return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

没错，C++ STL 给我们提供了做出这道题所需要的 `list`。

`list` 给我们提供了插入，删除的操作。而位置就可以用 `list` 的迭代器保存。按题意模拟即可。

```cpp
#include<bits/stdc++.h> 
#define fi first
#define se second
using namespace std;
int n1,n2,m;
list<int> q1,q2;
bool vis[1000005];
pair<int,list<int>::iterator> pos[1000005];
int main(){
	scanf("%d %d %d",&n1,&n2,&m);
	while(m--){
		int x;
		scanf("%d",&x);
		if(!vis[x]) q2.push_front(x),vis[x]=1,pos[x]={2,q2.begin()};
		else{
			auto it=pos[x];
			if(it.fi==1) q1.erase(it.se);
			else q2.erase(it.se);
			q1.push_front(x);
			pos[x]={1,q1.begin()};
		}
		if(q1.size()>n1){
			int t=*q1.rbegin();
			q2.push_front(t);
			pos[t]={2,q2.begin()};
			q1.pop_back();
		}
		if(q2.size()>n2){
			int t=*q2.rbegin();
			vis[t]=0;
			q2.pop_back();
		}
	}
	for(auto i:q1) printf("%d ",i);
	putchar('\n');
	for(auto i:q2) printf("%d ",i);
}
```

---

## 作者：W_C_B_H (赞：0)

弥补一下这道题（截至写这篇题解时）没有 Java 题解的空缺。

由于需要支持将队列中某个元素移到队列开头（可以视为先删去该元素，再将其插入至队列开头），并且数据范围不大（$0\le v_i\le10^4$），故我们可以考虑使用双向链表模拟该队列，并用 $idx_i$ 记录当前值为 $i$ 的数据在其中的下标（若不存在则为 $-1$）。

对于插入或删除操作，我们可以将相应位置数据的值在 $idx$ 中对应的位置设为相应的值（若是插入操作，则设为存储该数据的位置；若是删除操作，则设为 $-1$），并更新前驱、后继数组以及（可能要更新的）队头、队尾下标（“淘汰”操作同理，但仅在队列已存储的数据量等于其长度时进行）。 对于“将 $q_1$ 中淘汰出的数据页移动到 $q_2$ 首部”的要求，我们也只需将 $q_1$ 的队尾数据插入 $q_2$ 并弹出（删除） $q_1$ 队尾的数据即可。此处无需判断 $q_2$ 是否已满，因为从 $q_1$ 中弹出数据时，只有一种情况：当前要访问的数据页已经存在于 $q_2$。此时其将会被从 $q_2$ 中删除，并插入到 $q_1$ 的队头。因为 $q_2$ 刚刚删除了一个数据页，所以 $q_2$ 此时的容量一定没有达到上限，故无需判断 $q_2$ 是否已满。

据此，我们可以在 $O(1)$ 的时间复杂度内完成一次对数据页的访问（即一次操作），总时间复杂度 $O(m)$，可以通过本题。

Code：

```java
import java.util.Scanner;
public class Main {
    static final int M = 100005, V = 10005;
    // 查询数, 值域
    public static class dataList {  // 使用双向链表实现的队列
        int[] q = new int[M], pre = new int[M], nxt = new int[M], idx = new int[V];
        // 存放的值, 每个位置的前驱, 每个位置的后继, 每个值对应的下标
        int len, head, tail, size, tot;
        // 长度, 开头下标, 结尾下标, 当前存储的数据数量, 当前用到的下标的最大值
        public dataList(int n) {    // 构造函数
            for(int i = 0; i < M; i++) {
                this.q[i] = this.pre[i] = this.nxt[i] = 0;
            }
            for(int i = 0; i < V; i++) {
                this.idx[i] = -1;
            }
            this.len = n;
            this.head = this.tail = this.size = this.tot = 0;
        }
        public boolean check(int x) {   // 查询 x 是否在队列中
            return this.idx[x] > 0;
        }
        public void insert(int x) { // 将 x 插入到首部
            this.size++;
            this.q[++this.tot] = x;
            this.idx[x] = this.tot;
            this.pre[this.tot] = 0;
            this.nxt[this.tot] = this.head;
            if(this.head != 0) {
                this.pre[this.head] = this.tot;
            }
            this.head = this.tot;
            if(this.tail == 0) {
                this.tail = this.tot;
            }
        }
        public void erase(int x) {  // 删除值为 x 的元素
            if (this.idx[x] == -1) {
                return;
            }
            this.size--;
            int i = this.idx[x];
            this.idx[x] = -1;
            if(this.pre[i] != 0) {
                this.nxt[this.pre[i]] = this.nxt[i];
            } else {
                this.head = this.nxt[i];
            }
            if(this.nxt[i] != 0) {
                this.pre[this.nxt[i]] = this.pre[i];
            } else {
                this.tail = this.pre[i];
            }
        }
        public void pop() {    // 弹出队列的最后一个元素
            if (this.tail == 0) {
                return;
            }
            this.size--;
            int i = this.tail;
            this.idx[this.q[i]] = -1;
            this.tail = this.pre[i];
            this.nxt[this.tail] = 0;
            if (this.size == 0) {
                this.head = 0;
            }
        }
        public void print() {   // 打印队列
            for(int i = this.head; i != 0; i = this.nxt[i]) {
                System.out.print(this.q[i] + " ");
            }
            System.out.println();
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        dataList q1 = new dataList(sc.nextInt()), q2 = new dataList(sc.nextInt());  // 建立两个双向链表
        int m = sc.nextInt();
        while(m-- > 0) {
            int x = sc.nextInt();
            if(!q1.check(x) && !q2.check(x)) {  // x 既不在 q1 中, 也不在 q2 中
                if(q2.size == q2.len) {
                    q2.pop();
                }
                q2.insert(x);
            } else if(q1.check(x)) {    // 在 q1 中
                q1.erase(x);
                q1.insert(x);   // 由于 q1 刚弹出了 x, 故此时 q1 必定未满
            } else {    // 在 q2 中
                q2.erase(x);
                if(q1.size == q1.len) {
                    q2.insert(q1.q[q1.tail]);   // 由于 q2 刚弹出了一个元素, 故此时 q2 必定未满
                    q1.pop();
                }
                q1.insert(x);
            }
        }
        q1.print();
        q2.print();
        sc.close();
    }
}
```

---


# [蓝桥杯 2024 国 Java A] 栈

## 题目描述

小蓝有一个栈，他不断地向这个栈的顶端添加数字。小蓝希望栈中不存在相同的数，当他加入了一个之前已经存在的数时，栈中之前存在的那个数会消失（其它原有元素的相对顺序不变），小蓝还想随时知道栈中所有相邻的数中和为奇数的总共有多少组，请你计算出小蓝要求的结果。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq n \leq 1000$，$A_i \leq 300$；
- 对于 $70\%$ 的评测用例，$1 \leq n \leq 10^5$，$A_i \leq 1000$；
- 对于所有评测用例，$1 \leq n \leq 5 \times 10^5$，$1 \leq A_i \leq 10^6$。

## 样例 #1

### 输入

```
4
1
2
3
2```

### 输出

```
0
1
2
1```

# 题解

## 作者：liborui0000 (赞：1)

# P12288  题解

核心：双向链表维护栈内数据，用 map 维护每个数出现的次数和位置（因为 map 内元素键的数量是唯一的便），于查找和删除。

我们可以用一条双向链表储存每个数据的前驱和后继。用 $ans$ 代表栈内相邻元素和是奇数的组数。每次向链表里添加元素时，先判断在 map 里有无重复元素（$j$）。如果有，分三种情况：

1.  $j$ 是链表第一个元素，那么它只对后面的 $ans$ 有贡献，所以将它对后面的贡献减去。
2.    $j$ 是链表当前的最后一个元素，那么它只对前面的 $ans$ 有贡献，所以将它对后面的贡献减去。
3.    $j$ 是链表中间的元素，那么它对前面和后面的 $ans$ 都有贡献，所以都减去。如果被删除后 $j$ 前面和后面的两个数和是奇数，那么 $ans$ 应加 $1$ 。

判断完成后将新元素添加到链表中，并计算新元素对答案的贡献。最后输出。

于是我们就快乐的通过了这道题 QAQ。


## AC code：


```cpp
#include <bits/stdc++.h>

using namespace std;
#define int long long

int n;
const int N = 5e5 + 10;
const int M = 1e6 + 10;

struct node{
	int prev, nxt, id;
}a[N];

map<int, int> num;
int ans = 0, cnt = 2;

inline void add(int k, int x){
	a[cnt].id = x;
	a[cnt].nxt = a[k].nxt;
	a[a[k].nxt].prev = cnt;
	a[cnt].prev = k;
	a[k].nxt = cnt;
	cnt++;
}

signed main(){
	cin >> n;
	a[0].nxt = 1;
	a[1].prev = 0;
	for (int i = 1; i <= n; i++){
		int x;
		cin >> x;
		int j = 0;
		if (num[x]){
			j = num[x];
			int pre = a[j].prev;
			int next = a[j].nxt;
			if (pre) ans -= (a[pre].id + a[j].id) % 2;
			if (next != 1) ans -= (a[next].id + a[j].id) % 2;
			if (next != 1 && pre != 0) ans += (a[next].id + a[pre].id) % 2;
			a[a[j].prev].nxt = a[j].nxt;
			a[a[j].nxt].prev = a[j].prev;
		}
		num[x] = i + 1;
		add(a[1].prev, x);
		j = num[x];
		if (a[j].prev) ans += (a[j].id + a[a[j].prev].id) % 2;
		cout << ans << "\n";
	}
	return 0;
}
```

---

## 作者：Peruere_Arlecchino (赞：1)

这是一道有点思维性的题目，我们可以找到两个老朋友来解决问题：

**双向链表**：便于维护元素顺序。

**哈希表**：记录每个元素在链表中的位置，实现 $O (1)$ 时间的元素存在性检查和定位。

好，然后我们就确定了基本思路，可以开始做题了：
### 算法步骤（我分了二步）
#### 处理重复元素：
若元素已存在，就通过哈希表找到其在链表中的位置，然后计算删除该元素对奇数对数量的影响。若该元素前后都有元素，要考虑前后元素合并后的新贡献，然后分别减去该元素与前、后元素的奇数对贡献。最后从链表中删除该元素，并从哈希表中移除记录就好。
#### 添加新元素：
先将新元素添加到链表尾部，然后计算新元素与前一个元素的奇数对贡献，并更新结果，最后在哈希表中记录新元素的位置。

### 上代码！（有注释，方便理解）：
```cpp
#include<iostream>
#include<list>
#include<unordered_map>
using namespace std;
struct Node{
    int val;
    list<int>::iterator it; // 记录元素在链表中的迭代器
};

int main() {
    int n;
    cin >> n;
    
    list<int> lst; // 双向链表模拟栈
    unordered_map<int, Node> pos; // 哈希表记录元素位置
    int ans = 0; // 记录奇数对数量
    
    for (int i = 0; i < n; i++) {
        int num;
        cin >> num;
        
        // 处理重复元素
        if (pos.find(num) != pos.end()) {
            auto it = pos[num].it; // 获取重复元素的迭代器
            
            // 判断是否有前一个和后一个元素
            bool has_prev = (it != lst.begin());
            bool has_next = (it != --lst.end()); // 等价于 next(it) != lst.end()
            
            // 情况1：元素前后都有元素，需计算前后元素合并的贡献
            if (has_prev && has_next) {
                auto prev_it = it;
                --prev_it; // 前一个元素
                auto next_it = it;
                ++next_it; // 后一个元素
                if ((*prev_it + *next_it) % 2 == 1) {
                    ans++; // 前后元素合并可能新增一个奇数对
                }
            }
            // 情况2：减去当前元素与前一个元素的贡献
            if (has_prev) {
                auto prev_it = it;
                --prev_it;
                if ((*prev_it + *it) % 2 == 1) {
                    ans--; // 删除前，当前元素与前一个元素的奇数对减少
                }
            }
            // 情况3：减去当前元素与后一个元素的贡献
            if (has_next) {
                auto next_it = it;
                ++next_it;
                if ((*it + *next_it) % 2 == 1) {
                    ans--; // 删除前，当前元素与后一个元素的奇数对减少
                }
            }
            
            // 从链表中删除元素，并清空哈希表记录
            lst.erase(it);
            pos.erase(num);
        }
        
        // 添加新元素到链表尾部
        lst.push_back(num);
        auto it = --lst.end(); // 获取新元素的迭代器
        
        // 计算新元素与前一个元素的贡献
        if (it != lst.begin()) { // 若不是第一个元素
            auto prev_it = it;
            --prev_it; // 前一个元素
            if ((*prev_it + *it) % 2 == 1) {
                ans++; // 新增一个奇数对
            }
        }
        
        // 记录新元素的位置到哈希表
        pos[num] = {num, it};
        
        // 输出当前结果
        cout << ans << endl;
    }
    
    return 0;
}
```
求赞求过。

---

## 作者：封禁用户 (赞：1)

# P12288 题解

## 思路

1. 双向链表结构：每个节点存储当前数字，前驱指针和后继指针。
2. 哈希表辅助：记录每个数字对应的节点指针，以便快速查找和删除。
3. 奇数和统计：维护变量 $ans$ 记录当前相邻数中和为奇数的组数。每次插入或删除节点时，更新 $ans$：插入节点，检查新节点与栈顶节点的和是否为奇数。删除节点，检查被删除节点与其相邻节点的和是否为奇数，并调整统计。

## [AC](https://www.luogu.com.cn/record/215875900) 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct N {  
    int v;  
    N* p;   
    N* n;   
    N(int x) : v(x), p(0), n(0) {}
};
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int m;
    cin >> m;
    N* h = 0;
    N* t = 0;
    unordered_map<int, N*> mp;
    int c = 0; 
    for (int i = 0; i < m; ++i) {
        int x;
        cin >> x;
        if (mp.count(x)) {
            N* d = mp[x];
            if (d->p) {
                if ((d->p->v + d->v) % 2) {
                    --c;
                }
            }
            if (d->n) {
                if ((d->v + d->n->v) % 2) {
                    --c;
                }
                if (d->p) {
                    if ((d->p->v + d->n->v) % 2) {
                        ++c;
                    }
                }
            }
            if (d->p) {
                d->p->n = d->n;
            } else {
                h = d->n;
            }
            if (d->n) {
                d->n->p = d->p;
            } else {
                t = d->p;
            }
            mp.erase(x);
            delete d;
        }
        N* nn = new N(x);
        if (!t) {
            h = t = nn;
        } else {
            if ((t->v + x) % 2) {
                ++c;
            }
            t->n = nn;
            nn->p = t;
            t = nn;
        }
        mp[x] = nn;

        cout << c << '\n';
    }
    while (h) {
        N* tmp = h;
        h = h->n;
        delete tmp;
    }
    return 0;
}
```
java8 代码
```java8
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
class Node {
    int v;
    Node p;
    Node n;
    
    Node(int x) {
        v = x;
        p = null;
        n = null;
    }
}
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        Node h = null;
        Node t = null;
        Map<Integer, Node> mp = new HashMap<>();
        int c = 0;
        for (int i = 0; i < m; ++i) {
            int x = scanner.nextInt();
            if (mp.containsKey(x)) {
                Node d = mp.get(x);
                if (d.p != null) {
                    if ((d.p.v + d.v) % 2 != 0) {
                        --c;
                    }
                }
                if (d.n != null) {
                    if ((d.v + d.n.v) % 2 != 0) {
                        --c;
                    }
                    if (d.p != null) {
                        if ((d.p.v + d.n.v) % 2 != 0) {
                            ++c;
                        }
                    }
                }
                if (d.p != null) {
                    d.p.n = d.n;
                } else {
                    h = d.n;
                }
                if (d.n != null) {
                    d.n.p = d.p;
                } else {
                    t = d.p;
                }
                mp.remove(x);
                d = null;
            }
            Node nn = new Node(x);
            if (t == null) {
                h = t = nn;
            } else {
                if ((t.v + x) % 2 != 0) {
                    ++c;
                }
                t.n = nn;
                nn.p = t;
                t = nn;
            }
            mp.put(x, nn);

            System.out.println(c);
        }
        Node current = h;
        while (current != null) {
            Node next = current.n;
            current = next;
        }
        
        scanner.close();
    }
}
```

---

## 作者：_Hzq_ (赞：0)

## 题解：P12288 \[蓝桥杯 2024 国 Java A] 栈

### 题意分析

题目要求我们模拟一个栈，但与普通的栈不同的是，栈中不会出现相同的元素，相同的元素只会保留后插入的那一个，问我们每一次插入后在栈中相邻的数的和为奇数的个数，读完题目，我们便很容易能想到模拟。

### 具体做法

这里介绍一种不同的做法，双向链表。

:::info[什么是双向链表]
不同于数组，双向链表是一种非线性数据结构，其储存地址并不连续，采用前后指针的方式将各个数据串联起来，因此，双向链表在查询某一个特定元素时特别麻烦。
:::

在这题中，每一个元素在栈中只会出现一次，而且 $1\leq a_i\leq10_6$，刚好弥补了链表查询困难的缺点，我们只需用一个桶存每一种元素出现的最后的地址就可以了。\
得益于使用双向链表，本题的删除操作异常简单，只需将要删除的节点的左节点的右节点改为节点的右节点，右节点在同理操作便可。

### Code

```cpp line-numbers
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7;
struct node
{
	int val;
	node* left;
	node* right;
};
int n,res;
node* lastx[N];
node* tail;
int main()
{
	cin >> n;
	int i,j,k,x;
	for(i=1;i<=n;i++)
	{
		scanf("%d",&x);
		node* temp=new node();
		temp->val=x;
		temp->left=tail;
		if(tail!=NULL) //插入元素x
		{
			tail->right=temp;
			if((tail->val+x)%2==1) res++;
		}
		if(lastx[x]!=NULL) //删除之前存在过的元素x
		{
			if(lastx[x]->left!=NULL)
			{
				if((lastx[x]->val+lastx[x]->left->val)%2==1) res--;
				lastx[x]->left->right=lastx[x]->right;
				if((lastx[x]->left->val+lastx[x]->right->val)%2==1) res++;
			}
			lastx[x]->right->left=lastx[x]->left;
			if((lastx[x]->val+lastx[x]->right->val)%2==1) res--;
		} 
		lastx[x]=temp;
		tail=temp;
		cout << res << endl;
	}
	return 0;
}
```

### 温馨提示

~~使用链表需小心，一不小心就 RE~~\
由于空指针的特殊性，直接使用空指针中的值会 RE，如

```cpp
lastx[x]->val=1;
```

**所以，我们在使用指针前要判断一下它是否为空。**

---

## 作者：W_C_B_H (赞：0)

由于需要支持在添加已有数字时将原有的该数字删除（可以视为将栈中某个元素移到栈顶，即先删去该元素，再将其插入至栈顶），但数据范围不大（$1\le A_i\le10^6$），而且要维护当前栈内相邻的数中和为奇数的组数，故我们可以考虑使用双向链表模拟该栈，并用 $idx_i$ 记录当前值为 $i$ 的数据在其中的下标（若不存在则为 $-1$）。

同时，我们可以维护一个 $ans$ 变量，记录当前栈内相邻的数中和为奇数的组数。在栈顶（即链表的开头）插入一个数据时，如果当前栈中已有数据（即链表的开头位置不为 $0$），则检查栈顶数据和新插入的数据之和是否为奇数，如果是，则将 $ans$ **加** $1$。删除某个数据时，如果该数据存在前驱，则要判断其前驱与其之和是否为奇数，如果是，则将 $ans$ **减** $1$；对后继的判断同理（满足条件时也是将 $ans$ **减** $1$）；此外，如果其同时拥有前驱和后继，则还要判断其前驱、后继之和是否为奇数，如果是，则将 $ans$ **加** $1$。

据此，我们可以在 $O(1)$ 的时间复杂度内完成一次操作，总时间复杂度 $O(n)$，可以通过本题。

Code：

```java
import java.util.Scanner;
public class Main {
    static final int M = 500005, V = 1000005;   // 查询数, 值域
    public static class dataList {  // 使用双向链表实现的数据列表 (用于维护题目所述的栈)
        int[] q = new int[M], pre = new int[M], nxt = new int[M], idx = new int[V];
        // 存放的值, 每个位置的前驱, 每个位置的后继, 每个值对应的下标 (不存在则为 -1)
        int head, tail, tot, ans;
        // 开头下标, 结尾下标, 当前用到的下标的最大值, 当前相邻的数中和为奇数的组数
        public dataList() {    // 构造函数
            for(int i = 0; i < M; i++) {
                this.q[i] = this.pre[i] = this.nxt[i] = 0;
            }
            for(int i = 0; i < V; i++) {
                this.idx[i] = -1;
            }
            this.head = this.tail = this.tot = this.ans = 0;
        }
        public void insert(int x) { // 将 x 插入到首部
            this.q[++this.tot] = x;
            this.idx[x] = this.tot;
            this.pre[this.tot] = 0;
            this.nxt[this.tot] = this.head;
            if(this.head != 0) {
                if((this.q[this.head] + this.q[this.tot]) % 2 == 1) {   // 维护答案
                    this.ans++;
                }
                this.pre[this.head] = this.tot;
            }
            this.head = this.tot;
            if(this.tail == 0) {
                this.tail = this.tot;
            }
        }
        public void erase(int x) {  // 删除值为 x 的元素
            if(this.idx[x] == -1) {
                return;
            }
            int i = this.idx[x];
            this.idx[x] = -1;
            if(this.pre[i] != 0) {
                if((this.q[this.pre[i]] + this.q[i]) % 2 == 1) {    // 维护答案
                    this.ans--;
                }
                this.nxt[this.pre[i]] = this.nxt[i];
            } else {
                this.head = this.nxt[i];
            }
            if(this.nxt[i] != 0) {
                if((this.q[this.nxt[i]] + this.q[i]) % 2 == 1) {    // 维护答案
                    this.ans--;
                }
                this.pre[this.nxt[i]] = this.pre[i];
            } else {
                this.tail = this.pre[i];
            }
            if(this.pre[i] != 0 && this.nxt[i] != 0) {
                if((this.q[this.pre[i]] + this.q[this.nxt[i]]) % 2 == 1) {  // 维护答案
                    this.ans++;
                }
            }
        }
        /*
        public void print() {   // 打印队列, 调试用
            for(int i = this.head; i != 0; i = this.nxt[i]) {
                System.out.print(this.q[i] + " ");
            }
            System.out.println();
        }
        */
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        dataList Q = new dataList();
        int n = sc.nextInt();
        for(int i = 1; i <= n; i++) {
            int x = sc.nextInt();
            Q.erase(x); // erase 函数中会判断当前 x 是否在 dataList 中, 故此处无需判断 
            Q.insert(x);
            System.out.println(Q.ans);
        }
        sc.close();
    }
}
```

---

## 作者：Taojizhu1126 (赞：0)

## 题意：

维护一个栈，要求在加入一个数时删除原有的重复数字，求有几组相邻的和为奇数的数对。

## 思路：

利用双向链表保存数据，并记录元素出现位置以快速删除重复数字。

不难发现，每次删除数字只会影响自己和前后两个数。可以用一个数组记录这个数与前面的数是否满足要求。方便在删除数字时清除其贡献。然后再判断前后两个数是否满足要求。

而每次加入一个数，只需要判断它与后面的数是否满足要求，用一个 $sum$ 进行统计。  
需要注意的是，如果被删除的数前面或后面没有数，前后就不可能满足要求。

时间复杂度为 $O(n)$ 。

AC 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
struct c{
	bool f;
	int pos;
}f[1000005];//记录元素出现位置
struct aa{
	int data;
	int last;
	int next;
}a[500005];//双向链表进行维护
int n;
bool f1[500005];//记录是否满足要求
signed main(){
	cin>>n;
	int sum=0;
	for(int i=1;i<=n;i++){
		int b,p=0;
		cin>>b;
		if(f[b].f){//如果之前出现过就删掉
			p=f[b].pos;
			a[p].data=0;
			a[a[p].last].next=a[p].next;
			a[a[p].next].last=a[p].last;
		}
		f[b].pos=i;//记录位置
		f[b].f=1;//该元素出现过了
		if(p==i-1){//判断上一个是否被删除
			a[i].last=a[p].last;
			a[a[i].last].next=i;
		}
		else{//否则连接下一个
			a[i-1].next=i;
			a[i].last=i-1;
		}
		a[i].data=b;
		if(i>=2){//避免上一个是零的情况
			if(p){//如果有元素被删掉
				//清除贡献
				if(f1[p]){
					sum--;
					f1[p]=0;
				}
				if(f1[a[p].last]){
					sum--;
					f1[a[p].last]=0;
				}
				//判断前后是否满足要求
				if((a[a[p].last].data+a[a[p].next].data)%2==1&&a[p].next!=0&&a[p].last!=0){
					sum++;
					f1[a[p].last]=1;
				}
			}
			//判断与上一个否满足要求
			if((a[a[i].last].data+a[i].data)%2==1){
				sum++;
				f1[a[i].last]=1;
			}
		}
		cout<<sum<<"\n";
	}
	return 0;
}

```

---


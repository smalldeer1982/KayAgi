# 求区间所有后缀最大值的位置

## 题目描述

给定一个长度为 $n$ 的数列 $a$，对于其中每个长度为 $k$ 的子区间，请你求出这个这个子区间构成的数列的所有后缀最大值的位置个数。

一个下标 $i$ 是是数列 $b$ 的后缀最大值下标当且仅当：对于所有的 $i < j \leq |b|$，都有 $b_i > b_j$，其中 $|b|$ 表示 $b$ 的元素个数。


## 说明/提示

### 样例 1 解释

第一个子数列：$2, 1, 3$。其中 $3$ 是后缀最大值。  
第二个子数列：$1, 3, 5$，其中 $5$ 是后缀最大值。  
第三个子数列：$3,5,4$，其中 $5$ 和 $4$ 是后缀最大值。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq k \leq n \leq 10^6$，$1 \leq x_i \lt 2^{64}$。

## 样例 #1

### 输入

```
5 3
2 1 3 5 4```

### 输出

```
1
1
2```

# 题解

## 作者：一扶苏一 (赞：15)

## B3667 求区间所有后缀最大值的位置

### Ayalysis

请先阅读[这篇 B3666 的题解](https://www.luogu.com.cn/blog/fusu2333/solution-b3666#)了解如何用单调栈维护前缀的后缀最值，我们将不再赘述。

对于一个区间 $[l, r]$，注意到 $l$ 前面的数不会影响到 $[l, r]$ 的后缀最值。换句话说，我们求区间 $[l, r]$ 的后缀最值其实就是求 $[1, r]$ 这个前缀的后缀最值里下标落在 $[l, r]$ 的那部分。也就是维护前缀的后缀最值的那个单调栈里某个位置之后的所有元素。

我们按 $r$ 从小到大的顺序求出区间 $[r - k + 1, r]$ 的后缀最值个数，以下记 $l = r - k + 1$。我们假设有一个类似单调栈的数据结构按顺序维护了 $[l - 1, r - 1]$ 这个区间内的后缀最值，现在要求 $[l, r]$ 内的。首先删除 $l - 1$ 不会影响 $l$ 以后的后缀最值，所以我们直接判断这个”栈“的”栈底“元素是不是 $l - 1$，如果是，则直接将之”弹出“，不会影响整个容器的结构。此时“栈”里就是 $[l, r - 1]$ 内的后缀最值。我们用与单调栈完全相同的方法将 $a_r$ 加入这个数据结构里（即不断弹出直到”栈顶“元素比 $a_r$ 大或”栈“为空），就得到了 $[l, r]$ 内的所有后缀最大值。

但是普通的栈是不能在栈底一侧弹出元素的，我们需要一个功能包括：在一侧弹出、加入元素，在另一侧弹出元素的数据结构。于是我们用双端队列（`std::deque`）替换这个栈即可。

对应到代码上去就是

```cpp
if (!que.empty() && que.front() < l) que.pop_front();
while (!que.empty() && a[que.back()] <= a[r]) que.pop_back();
que.push_back(r);
```

对时间复杂度的分析与单调栈完全相同。因为只会被压入队列一次，所以也只会被删除一次。整个数列的元素总共被压入、删除了不超过 $2n$ 次，于是总时间复杂度是 $O(n)$，均摊每次操作 $O(1)$。

### Code

```cpp
#include <vector>
#include <array>
#include <queue>
#include <iostream>

int n, k;
std::deque<int> q;
std::array<unsigned long long, 1000005> a;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n >> k;
  for (int i = 1; i <= n; ++i) {
    std::cin >> a.at(i);
    if (q.size() && q.front() + k - 1 < i) q.pop_front();
    while (q.size() && (a.at(i) >= a.at(q.back()))) {
      q.pop_back();
    }
    q.push_back(i);
    if (i >= k) std::cout << q.size() << '\n';
  }
}
```



---

## 作者：continueOI (赞：13)

## 题目描述

给定一个长度为 $n$ 的数列 $a$，对于其中每个长度为 $k$ 的子区间，请你求出这个这个子区间构成的数列的所有后缀最大值的位置个数。

一个下标 $i$ 是是数列 $b$ 的后缀最大值下标当且仅当：对于所有的 $i < j \leq |b|$，都有 $b_i > b_j$，其中 $|b|$ 表示 $b$ 的元素个数。

## 解法

以样例为例先模拟一遍。

![](https://cdn.luogu.com.cn/upload/image_hosting/3icrnb27.png)

---

![](https://cdn.luogu.com.cn/upload/image_hosting/w2tl12yc.png)

---

![](https://cdn.luogu.com.cn/upload/image_hosting/70tu0tvj.png)

---

![](https://cdn.luogu.com.cn/upload/image_hosting/rqu0gtsz.png)

---

![](https://cdn.luogu.com.cn/upload/image_hosting/mbb3oxqv.png)

### 下面是文字说明：

很容易就可以想到，用暴力方法求解：每输入一个数，将其与之前的所有后缀最大值的数遍历，如果比它大，那么就将比它小的那个数删除，再判断队列最前面的数是不是第 $l-k+1$ 个数即可。

利用双端队列这个数据结构，将当时的后缀最大值入队列，如果遍历后不是后缀最大值了，那么便出队列，每次操作判断是不是第 $l-k+1$ 个数，若是，则将那个数出队列。便可以得到一下核心代码：

```cpp
if(head-tail&&ans[tail+1]+k<=i) tail++; //尾出队 
while(head-tail&&stk[ans[head]]<=stk[i]) head--; //头出队 
ans[++head]=i; //头入队 
```
这里解释一下，`head-tail` 指的是队列中剩余的元素数量，其余便不再多讲，详情请见我的[这篇文章](https://www.luogu.com.cn/blog/QAQ-AK/solution-b3666)。

### 数据规模与约定

**注意**，由于对于全部的测试点，保证 $1 \leq k \leq n \leq 10^6$，$1 \leq x_i \lt 2^{64}$，所以需要开 unsigned long long。

### 关于时间复杂度

显然，每个元素至多只会进入队列中一次，也至多只会出一次，所以时间复杂度为 $O(n)$。因为共有 $n$ 个数，所以单次输入比较输出结果的时间复杂度均摊大概是 $O(1)$ 的。

## 代码（STL）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
deque<int> ans;
array<unsigned long long,1000005> stk;
int main() {
	cin>>n>>k;
    for(int i=1;i<=n;i++){
    	cin>>stk.at(i);
    	if(ans.size()&&ans.front()+k-1<i) ans.pop_front();
    	while(ans.size()&&(stk.at(i)>=stk.at(ans.back())))
    	    ans.pop_back();
    	ans.push_back(i);
    	if(i>=k) cout<<ans.size()<<'\n';
    }
    return 0;
}
```

## 代码（用数组模拟）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,k,tail,head,ans[N];
unsigned long long stk[N];
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) {
        scanf("%llu",stk+i);
        if(head-tail&&ans[tail+1]+k<=i) tail++;
        while(head-tail&&stk[ans[head]]<=stk[i]) head--; 
        ans[++head]=i;
        if(i>=k) printf("%d\n",head-tail);
    }
    return 0;
}
```

---

## 作者：_O_v_O_ (赞：4)

前置知识：[B3666](https://www.luogu.com.cn/problem/B3666)。

此题和前面那题差不多，不过用的是**单调队列**。

我们可以用一个“栈”来存储每个区间，每个数入栈时，为了维护“栈”内的单调，需要让这个数反复跟“栈顶”比较，如果“栈顶”大于这个数，则将“栈顶”弹出，知道这个“栈”为空或“栈顶”小于这个数，就将这个数入栈。最后这个栈的大小就是这个区间后缀最大值的数量。

不过有种特殊情况：栈顶不在这个区间内，此时我们需要将栈顶弹出，而判断栈顶只能用这个下标判断，所以这个“栈”只能存下标。并且这个“栈”既能从前面弹出又能从后面弹出，则只能是**双端队列**，这就是**单调队列**。

最后：记得开 unsigned long long。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long

list<int> dq;  //可以用 list 代替 deque，比较省空间。
int n,k;
vector<int> a; //用动态数组。

signed main(){
	a.push_back(0);  //因为之后的下标是从1开始，而vector下标是从0开始，所以先插入一个数。
	scanf("%llu%llu",&n,&k);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%llu",&x);
		a.push_back(x);
		if(!dq.empty()&&dq.front()+k-1<i) dq.pop_front();
		while(!dq.empty()&&a[dq.back()]<x) dq.pop_back();
		dq.push_back(i);
		if(i>=k) printf("%llu\n",dq.size());
	}
	return 0;
}
```


---

## 作者：卷王 (赞：4)

## 题目大意

[传送门](https://www.luogu.com.cn/problem/B3667)

## 大体思路

由数据范围和大概的题意不难知道这题用的是单调队列。

但是好多大佬直接用 deque 秒杀了这题，但是其实可以有更优的方法，于是 **给出一种不用 STL，且空间小、代码简短的近似于单调队列模板的方式。**

定义 $head$ 和 $tail$ 分别维护这个单调队列的头和尾。每次读入的循环里保持 $k$ 的间距，按照题意模拟即可。最后的答案即 $tail - head$。

注意点：

* 第一个 while 循环完后 $q_{head}$ 依然是不小于 $l$ 的，因此后面一定要 `head--`！

* 当一次循环开始我们要求左端点时，$i - k + 1$ 必须对 $1$ 取最大值，不然如果 $i < k$，左端点就会是负数，不满足题意。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
inline ll read() {
	ll x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}
int n, k, head = 1, tail = 0, q[1000007];
ll a[1000007];
int main() {
	n = read(), k = read();
	for(int i = 1; i <= n; i++) {
		a[i] = read();
		int l = max(1, i - k + 1), r = i;
		while(head < tail && q[head] < l) head++; head--;
		while(head < tail && a[q[tail]] <= a[i]) tail--;
		q[++tail] = i;
		if(i >= k) printf("%d\n", tail - head);
	}	
	return 0;
}
```

---

## 作者：cxpluogu (赞：2)

## 题意简化
对于每个长度为 $k$ 的子区间，求出它最长不连续单调递减序列的长度。
## 解决方法
可以使用单调队列解决，使用 STL 中的双端队列 deque,但在使用的过程中需要转化 `q.front()` 的类型，例如 `q.front()<=i-k` 是不行的，而 `q.front()+k<=i` 是可以的。

单调队列的基本思想是插入合法元素，踢出过期元素，也就是传说中的“如果一个人比你小还比你强，那你就寄了”。

在这道题中，在单调队列中存入下标；那么过期是指如果队头超出 $k$ 的范围，需将其从队头踢出；而合法指的则是如果当前元素**小于**（注意题目，不是小于等于）队尾所存下标对应的值，就将其插入队中，否则，就踢出队尾，重复上一过程。

下面是 ac 代码详细版的，虽然比较长，但相对好理解，在其下方还有简化般的。

```
#include<bits/stdc++.h>
using namespace std;
deque<unsigned long long > q;
unsigned long long n,k,a[1000005];//注意题意要开 ull 。
inline unsigned long long read(){
	char c=getchar();
	long long x=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
inline void write(unsigned long long x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
	return;
}
int main(){
	n=read();
	k=read();
	for(register int i=1;i<=n;i++){
		a[i]=read();
	}
	for(register int i=1;i<=k;i++){
		while(!q.empty()&&a[i]>=a[q.back()])
			q.pop_back();
		q.push_back(i);
	}
	write(int(q.size()));
	putchar('\n');
	for(register int i=k+1;i<=n;i++){
		while(!q.empty()&&q.front()<=i-k)//踢出过期元素
			q.pop_front();
		while(!q.empty()&&a[i]>=a[q.back()])
			q.pop_back();
		q.push_back(i);
		write(int(q.size()));	
		putchar('\n');
	}
	return 0;
}
```
简化版。
```cpp
#include<bits/stdc++.h>
using namespace std;
deque<unsigned long long > q;
unsigned long long n,k,a[1000005];
inline unsigned long long read(){
	char c=getchar();
	unsigned long long x=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
inline void write(unsigned long long x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
	return;
}
int main(){
	n=read();
	k=read();
	for(register int i=1;i<=n;i++){
		a[i]=read(); 
		while(!q.empty()&&q.front()+k<=i)
			q.pop_front();
		while(!q.empty()&&a[i]>=a[q.back()])
			q.pop_back();
		q.push_back(i);
		if(i>=k){
			write(q.size());
			putchar('\n');
		}
	}
	return 0;
}
```



---

## 作者：Eleveslaine (赞：2)

在阅读这篇题解前，请确保已经学过单调栈的相关知识，且做过 [B3666](https://www.luogu.com.cn/problem/B3666)。若没有，推荐阅读我写的[这篇题解](https://www.luogu.com.cn/blog/450246/mono-stack-solution-b3666)。  
以下是正文。

---

由**单调栈维护数列每个前缀的后缀最大值**（上面那篇文章有所涉及）的过程，发现本题也可以用一个类似于单调栈的数据结构维护；即每当子区间右移一位时，在这个数据结构的右端点按照单调栈一样的方法添加元素。

设原来的子区间是 $[l,r](1 \le l,r \le n,r-l+1=k)$，则右移一位后新的区间为 $[l+1,r+1]$。注意到单调栈只能维护 $r+1$ 这个位置上的元素，可能存在 $l$ 这个位置上有一个元素没有删除，而根据单调性可以发现 $l$ 一定在栈底，那么我们把栈底开个口删掉 $l$ 即可。

栈底开个口显然就是一个双端队列了，其中队首（原来的栈底）支持删除，队尾（原来的栈顶）支持加入和删除，队列元素还满足单调性，这就是我们说的单调队列。

代码实现上，虽然 `deque` 可以通过，但还是建议用 `list` 代替 `deque` 节省时间与空间（当然，在不需要随机访问的情况下）。

```cpp
#define maxn 1000005
int n,k;
ull a[maxn];
list <int> q;
int main()
{
    n=read<int>(),k=read<int>();
    for(int i=1;i<=n;++i)
    {
        a[i]=read<ull>();
        int l=i-k+1;
        l=max(1,l);
        if(!q.empty() && q.front()<l) // 从队头删除
            q.pop_front();
        while(!q.empty() && a[q.back()]<=a[i]) // 从本行开始，下面三行（包括本行）是单调栈基本操作
            q.pop_back();
        q.push_back(i);
        if(i>=k)
            printf("%d\n",q.size());
    }
    return 0;
}
```

---

## 作者：asas111 (赞：1)

## 思路
因为子区间长度固定，所以这题就是一个定长滑窗，可以使用单调队列。

考虑维护一个单调递减的队列，共分以下几步：
- 先判断队列长度是否超过 $k$，如果超过就将队列的尾部加 $1$，即把最老入队的元素删除，以维持队列长度为 $k$。这个操作每轮只需要执行 $1$ 次，因为每轮只会加入 $1$ 个元素。

- 再判断将要加入队列的元素的大小是否大于头部，如果大于就把头部减 $1$，即把头部元素删除，这样做是为了维持队列的单调性，因为如果后面加入的元素既比前面的元素大，又比它们年轻，前面的元素就不满足要求了。这个操作和上一个操作都需要判断尾部是否小于头部，以防止越界。

- 接下来将新加入的元素加入进队列，因为每一个新加入的元素都有机会，比如等之前的元素离开队列。

- 最后判断一下尾部是否大于等于 $k$，这样子区间长度才能为 $k$，如果符合条件就可以直接输出了，输出的内容是队列长度，即头部位置减去尾部位置。

单调队列的时间复杂度为 $O(n)$，因为每一个元素最多加入一次，最多删除一次。记得开 unsigned long long。
## 代码
```cpp
#include<bits/stdc++.h>
#define N 1000009
#define int unsigned long long
using namespace std;
int n,k,x[N],ans[N],q[N];
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>x[i];
	int l=0,r=0;
	for(int i=1;i<=n;i++){
		while(l<r&&i-q[l]>=k)l++;                                       
		while(l<r&&x[i]>x[q[r-1]])r--;
		q[r++]=i;
		if(i>=k)cout<<r-l<<endl;
	}
	return 0;
}
```


---

## 作者：zzbzwjx (赞：0)

# B3667题解
## 题意
[~~自己看题~~](https://www.luogu.com.cn/problem/B3667)
## 分析
这题其实~~并不难~~，其实就是[单调队列](https://www.luogu.com.cn/problem/solution/P1886)（~~没别的了就这~~）。

### 单调队列
**单调队列**是队列中元素之间的关系具有单调性，而且队首和队尾都可以进行出队操作，只有队尾可以进行入队操作，本质是由**双端队列** deque 实现的。

详见[**这里**](https://blog.csdn.net/qq_53268869/article/details/122870945)。

单调队列实现代码：
```cpp
if(!q.empty()&&q.front()+k-1<i)q.pop_front();//删队首
while(!q.empty()&&a[q.back()]<x)q.pop_back();//删队尾
q.push_back(i);//进队
```

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,k,b;
deque<unsigned long long>q;//双端队列
vector<unsigned long long>a;//动态数组省空间
int main(){
   cin>>n>>k;
   a.push_back(114514);//把第一项填上（因为从1开始用）
   for(int i=1;i<=n;i++){
      cin>>b;
      a.push_back(b);
      if(!q.empty()&&q.front()+k-1<i)q.pop_front();
      while(!q.empty()&&a[q.back()]<b)q.pop_back();
      q.push_back(i);
      //单调队列操作
      if(i>=k)cout<<q.size()<<'\n';//输出后缀最大值数量
   }												
   return 0;//over
}												
```
友情提醒：不开 unsigned long long 见祖宗。

------------


（禁止抄袭代码）

---


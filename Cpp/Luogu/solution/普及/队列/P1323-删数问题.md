# 删数问题

## 题目描述

一个集合有如下元素：$1$ 是集合元素；若 $P$ 是集合的元素，则 $2\times P+1$，$4\times P+5$ 也是集合的元素。

取出此集合中最小的 $k$ 个元素，按从小到大的顺序组合成一个多位数，现要求从中删除 $m$ 个数位上的数字，使得剩下的数字最大，编程输出删除前和删除后的多位数字。

注：不存在所有数被删除的情况。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $1\le k,m\le300$。
- 对于 $100\%$ 的数据，保证 $1\le k,m\le3\times10^4$。

## 样例 #1

### 输入

```
5  4```

### 输出

```
137915
95```

# 题解

## 作者：zhaowangji (赞：36)

其实，这是由两条题目凑在一起，拼接而成的一条题目。

而这两题，在JS夏令营冬令营，NT国庆冲刺营中都有出现。

分别是[丑数](https://www.luogu.com.cn/problem/UVA136)（队列部分的题目，但似乎题面各有不同，这是其中的一个版本，是符合真正数学定义“丑数”的）和[删数问题](https://www.luogu.com.cn/problem/P1106)（没错，名字一模一样）（贪心部分题目）后一题可参考我写的[题解](https://zhaoqi.blog.luogu.org/solution-p1106)。

把本题拆分成两部分。首先，把这些元素全都找出来并拼接在一起，然后，逐渐删去。

1. 找元素

	由于题中说是“最小的k个元素”“从小到大”，所以是依次添加元素，而每次都 O(n) 去找目前最小的元素显然不现实，手写二分由太过麻烦，所以考虑STL中的**优先队列**->**priority_queue**。

	priority_queue 默认是大根堆（即大的元素在前），所以我们需要修改参数，变为小根堆，这样就可以每次 O(logn) 找出当前最小的元素，取出并添加它的两个附属元素。

```cpp
priority_queue<int,vector<int>,greater<int> > q;
//int 是数据类型，vector 是存储方式（据说也可以用其他的），greater/less 控制大根堆，小根堆
```


2. 拼接
在这里给大家介绍一种黑科技：**to_string** (很不幸的是，它隶属于 c++**11**，所以竞赛中不能使用，但在平时做题时使用是没有问题的)

	to_string 可以将**数字**转化为所对应的**字符串**（特殊、奇怪的字符就不要出现了）**不仅仅**是 int ！double,float,long long,long double 等都是支持的。
所以我们在取出目前最小元素后，可以使用 to_string 将其转化为字符串，然后进行字符串的累加。（若不用 to_string，也可以通过取模的方式，将数字依次取出，然后转化成 char 进行拼接）

5. 寻找要删除的数字
可以发现：本质上就是维护一个**不下降序列**
并不会数学证明，故通过举例说明：
29523->9523->953->95->9
其实就是与它同名的[删数问题](https://www.luogu.com.cn/problem/P1106)的翻版，本题要求剩下的数最大，它要求剩下的数最小，规律是反过来的（大于号、小于号的区别）
6. 如何删除
使用 string 中的 erase 函数。写法： 
```cpp
str.erase(起始位置,删除的长度)
```
5.循环的写法
由于不知道如何删除，外面应该是一个 while(1) 或 for( ; ; )，内部枚举字符串中的每位。删去一个，记录一次，达到总次数便立即退出，可使用 exit(0) 直接退出整个程序（也可以用标记的形式，达到总次数后更改标记，外部循环每次都判断标记）
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,m;
priority_queue<int,vector<int>,greater<int> > cre;
string s;
int main(){
    cin>>k>>m;
    cre.push(1);
    for(int i=1;i<=k;++i){
        int x=cre.top();
        s+=to_string(x);
        cre.pop();
        cre.push(2*x+1);
        cre.push(4*x+5);
    }
    cout<<s<<endl;
    int cnt=0;
    for(;;){
        for(int i=0;i<s.size()-1;++i){
            if(s[i]<s[i+1]){
            ++cnt;s.erase(i,1);
            if(cnt>=m){cout<<s<<endl;exit(0);}
            break;
            }
        }
    }
	return 0;
}
```


---

## 作者：太叔寒云 (赞：27)

用int数组仿佛比char更加快捷？毕竟数字更好比较，具体见代码啦，太叔寒云不想说话。
本代码将数字两遍拆解由gyr111大佬提出可以再优化一点，但是太叔寒云表示不拘小节。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
priority_queue<int,vector<int>,greater<int> > q;
int a[30005],ans[5000010],topa,topans,next[5000010];
int main()
{
    int l,m;
    cin>>l>>m;
    memset(ans,0x3f,sizeof(ans));
//先将ans设置最大，删除时如果是递减序列方便特判。
    q.push(1);
    while(1)
    {
        int x=q.top(),d=0;q.pop();
        q.push(2*x+1);q.push(4*x+5);  
        a[++topa]=x;//记录输入的数
        while(x)
        {
            d=d*10+x%10;
            x/=10;
        }//反向拆解
        while(d)
        {
            ans[++topans]=d%10;
            d/=10;
        }//将数字一位位加入ans
        if(topa>=l) break;//到限度停止加入
    }
    for(int i=1;i<=topa;i++) cout<<a[i];
    cout<<endl;
    for(int i=0;i<topans;i++) next[i]=i+1;
//模拟链表，记录当前位的下一位的位置，方便比较，就不用删数了
    while(m)
    {
        int l=0;
        while(ans[next[l]]>=ans[next[next[l]]])
//末尾不用特判，因为一定不会比0x3f大
            l=next[l];//直到出现前比后小
        next[l]=next[next[l]];
        m--;
    }
    for(int i=0;next[i];i=next[i]) cout<<ans[next[i]];
    return 0;
}
```

---

## 作者：defense (赞：25)

### 我们将这道题分解成$2$个子问题
* ①生成这个序列
* ②删除$m$个数

针对子问题①，看到**最小**的$K$个元素，想到用小根堆来维护，先在堆中插入$1$，然后每次取堆中的最小值进行扩展，然后将堆顶```pop```掉，用一个字符串（个人认为方便），每次```pop```之前，将堆顶转化为字符串型接到那个字符串后面，最后就输出就可以啦。
其中的转换代码：
```
std::string sum(int a){
	std::stringstream ss;
	ss << a;
	std::string ans = ss.str();
	return ans;
}
```
针对子问题②，首先将删去$M$个转化为留下$total-M$个，然后运用贪心的思想，**前面的位数越大越好**
，于是我们的搜索区间也要越大越好。由于要留$total-M$个，可以将初始的(第一个的)搜索区间定为$[0,M]$然后每次将$Left$设成$i+1$,$Right$设成$Right+1$。前提条件：$Left\leq Right$切$Right < total$
### 附上AC代码：
```
#include <cstdio>
#include<iostream>
#include<queue>
#include<sstream>
#define MAX 30001
std::priority_queue<int , std::vector<int> , std::greater<int> >Num;
std::string ans1 , ans2;
int K , M , L , R;
std::string sum(int a){
	std::stringstream ss;
	ss << a;
	std::string ans = ss.str();
	return ans;
}
int main(){
	Num.push(1); 
	scanf("%d%d",&K , &M);
	int Cnt = 0 ; 
	while(Cnt < K){
		int a = Num.top() * 2 + 1;
		int b = Num.top() * 4 + 5;
		ans1 += (sum(Num.top()));
		Num.pop(); 
		Num.push(a);
		Num.push(b);  
		++Cnt;
	}
    std::cout << ans1 <<"\n"; 
    L = 0;R = M;
    int Maxx = 0;
    while(L <= R && R < ans1.length()){
        for(register int i = L ; i <= R ; i++){
    	    if((ans1[i] - '0') > Maxx) Maxx = (ans1[i] - '0') , L = i + 1;
	    }
	    ans2 += (sum(Maxx));
	    R++;
	    Maxx = 0;
	}
    std::cout<< ans2;
	return 0;
}
```


---

## 作者：库特 (赞：15)

看提交记录好像没有0ms过这道题的，发一个0ms的题解吧

本蒟蒻也不会什么高端的算法维护，没怎么优化，用的都是最基础的算法。没有用优先队列，因为优先队列毕竟是nlogn的算法，排序用的是手动标记，应该是o（n）的吧。

然后之所以是0ms大概还是因为最后删数的时候使用的方法不同吧，虽然同样是贪心的思想，但不是用的删递减首字符的方法（太弱了并没有想到），用的是单纯的贪心，就是前m-n+1个数里找最大的数，这本应该是一个o（n的平方）的算法，但是当时怕超时想到了一种能优化成近似o（n）的算法~~（然而不优化也不会超时）~~

因为这个数组不是随机的数组，而是2p+1和4p+5组成的，理论上按不确定性里面有着无数个9，按概率来看平均不到10个数就能出现一个9（因为末尾都是奇数嘛），贪心是前m-n+1（m指原串长度，n指删掉后剩几个字符）个数找最大的，但是一定没有比9大的数，所以只要找到9就可以安心去找下一个数了，而最后删数删到找不到9了就正常on方去找那10个左右的没有出现9的数就行，对于10左右的数n方很小，所以整个算法可以近似是o（n）的，所以就可以简简单单的0ms AC啦（扯了一大堆简而言之就是暴力找‘9’）


贴一下代码吧，本人纯新手，代码写的很不规整，请见谅

```cpp
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
using namespace std;

int main()
{
    int a[30005];
    char chuan[200000];//原串
    char mb[200000];//删数后的串
    char b[10];
    int c,d,tmax,zc,kt;
    a[1]=1;
    while(scanf("%d%d",&d,&c)!=EOF)
    {
        int i=1,j=1,k=1;
        chuan[0]='1';
        for(int pp=2; pp<=d; pp++)
        {

            if(a[i]*2+1<a[j]*4+5)
            {
                a[pp]=a[i]*2+1;
                kt=0;
                zc=a[pp];
                while(zc>0)
                {
                    b[kt]=zc%10+48;
                    zc/=10;
                    kt++;
                }
                kt--;
                while(kt>=0)
                {
                    chuan[k++]=b[kt];
                    kt--;
                }
                i++;
            }
            else
            {
                a[pp]=a[j]*4+5;
                kt=0;
                zc=a[pp];
                while(zc>0)
                {
                    b[kt]=zc%10+48;
                    zc/=10;
                    kt++;
                }
                kt--;
                while(kt>=0)
                {
                    chuan[k++]=b[kt];
                    kt--;
                }
                j++;
            }
        }//标记排好2p+1和4p+5的顺序，并把它转换成了一个字符串
        int len=strlen(chuan);
        kt=0;
        //贪心删数 前m-n+1个数找最大的，如果有9直接停止去找下一个数
        for(i=0; i<len-c; i++)
        {
            tmax='0'-1;
            for(j=kt; j<=c+i; j++)
            {
                if(chuan[j]=='9')
                {
                    kt=j+1;
                    mb[i]=chuan[j];
                    break;
                }
                if(chuan[j]>tmax)
                {
                    tmax=chuan[j];
                    kt=j+1;
                    mb[i]=chuan[j];
                }
            }
        }
        mb[i]='\0';
        puts(chuan);
        puts(mb);
    }
    return 0;
}



```

---

## 作者：Professor_L (赞：11)

删除m个数，就让剩下的k-m个数最大
- 
所以贪心一下，最高位和次高位都要大
- 
并且要用到数字转字符串（本人表示并不会所以百度了一下）
-   
就是这东西
- 


```
for(int i=1;i<=k;i++)//数字转为字符串
{
　　stringstream ss;
　　ss<<num[i];
　　string str;
　　ss>>str;
　　s+=str;
}
```


------------
然后你就发现
- 
很快就会AC
- 
感谢某~~大佬~~的推荐
- 
推荐各位可以先拿P1106练手
- 
祝各位（包括自己）考试顺利
- 

------------


------------
```
#include <bits/stdc++.h>
using namespace std;

long long num[310000];

int main()
{
    int k,m;
    cin>>k>>m;
    num[1]=1;
    int s1=1,t1=1;
    for(int i=2;i<=k;i++){
        int q=2*num[s1]+1;
        int w=4*num[t1]+5;
        if(q<w){
            s1++;
            num[i]=q;
        }
        else if(q==w){
            s1++;t1++;
            num[i]=q;
        }
        else{
            t1++;
            num[i]=w;
        }
    }
    for(int i=1;i<=k;i++) cout<<num[i];
    cout<<endl;
    string s="";
    //百度来的数字转字符串
    for(int i=1;i<=k;i++){
        stringstream ss;
        ss<<num[i];
        string str;
        ss>>str;
        s+=str;
    }
    //cout<<s1<<endl;
    //插入9来比较
    string::iterator it =s.begin();s.insert(it,'9');  
    //cout<<s<<endl;
    int r=0;
    int n=s.size();
    int sum=0;
    int h=1;
    while(h<=n&&sum!=m){
        if(s[h]<=s[r]){
            s[++r]=s[h++];
        }
        else
            r--,sum++;
    }
    while(h<=n) s[++r]=s[h++];
    for(int i=1;i<n-m;i++) cout<<s[i];
    cout<<endl;
    return 0;
}
```



---

## 作者：yyy2015c01 (赞：10)

有种排序叫做优先队列，有种歧视叫做STL。

```cpp

#include<iostream>
#include<queue>
#include<list>
using namespace std;
priority_queue<int,vector<int>,greater<int> > q;
int a[30001],g=0;
int k,m;
int st[200001],l=0,sum=0;
void bfs()
{
    q.push(1);
    while(!q.empty())
    {
        int p=q.top(),d=0;
        q.pop();
        q.push(2*p+1);
        q.push(4*p+5);
        a[++g]=p;
        while(p)
        {
            d=d*10+p%10;
            p/=10;
        }
        while(d)
        {
            if(l==0)
                st[++l]=d%10;
            else
            {
                while(l!=0&&d%10>st[l]&&sum<m)
                {
                    l--;
                    sum++;    
                }
                st[++l]=d%10;
            }
            d/=10;
        }
        if(g==k)
            return;
    }
}
int main()
{
    cin>>k>>m;
    bfs();
    int i;
    for(i=1;i<=g;i++)
        cout<<a[i];
    cout<<endl;
    for(i=1;i<=l-(m-sum);i++)
        cout<<st[i];
    return 0;
}

```

---

## 作者：兴安黑熊 (赞：6)

本题使用优先队列求解，这个还是容易的，把返回的最小的数按位分解，然后存在数组里，接下来对数字里的数字进行贪心策略就可以了，贪心最好使用链表，因为链表删除很容易，当然也可以使用数组模拟链表。注意本题的题意，比如输入 9 9 输出应该是 13791517193133 99333 每次删除1个元素，立刻返回，从新从起始位置找到升序的元素，然后删掉。 输入 7 6 输出为： 9719 如果最后都是降序后，如果删除的个数不够的话，就从前往后输出 长度-M 个数字；
注意这句：int len=(int)log10(s)+1;
计算一个数的位数（也就是长度），这是基本知识！
```cpp
#include <iostream>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
using namespace std;
typedef long long LL;
LL a[600000],next[600000];
int num=0;
struct sa
{
    int w;
    struct sa *next;

};
int main()
{  LL k,m,s,x,y;
int flag=0;
memset(next,0,sizeof(next));
memset(a,0,sizeof(a));
  priority_queue< LL,vector<LL>,greater<LL> > v;
  cin>>k>>m;
  v.push(1);
  x=0;
  while(!v.empty())
  {
    s=v.top();
    v.pop();
    num++;
    v.push(2*s+1);
    v.push(4*s+5);
   int len=(int)log10(s)+1;
    for(int i=len+x;i>x;i--)
    {a[i]=s%10;
     s=s/10;

    }
     x=x+len;

  if (num==k) break;
  }
  for(int i=1;i<=x;i++)
  cout<<a[i];
  cout<<endl;
  struct sa *head,*p,*q;
  head=(struct sa *)malloc(sizeof(struct sa));
  head->w=0;
 q=head;
  for(int i=1;i<=x;i++)
  {
      p=(struct sa *)malloc(sizeof(struct sa));
      p->w=a[i];
      q->next=p;
      q=q->next;

  }
  q->next=NULL;
  int tt=0;
  //int flag=0;
   while(1)
   {
   p=head;
     flag=0;
      while(p->next!=NULL&&p->next->next!=NULL)
       {
         if (p->next->w<p->next->next->w)
        {
          q=p->next;
          p->next=p->next->next;
          free(q);
          tt++;
          flag=1;
          break;

        }
        else
        p=p->next;
        }

  if (flag==0) break;
  if (tt==m) break;
  }

  for(p=head->next;p!=NULL;p=p->next)
    cout<<p->w;
    cout<<endl;
    return 0;
}
```

---

## 作者：vegetabird (赞：5)

分享一个求出集合$p$的新思路：

若$x$是集合$p$的元素，则$\frac{x-1}{2},\frac{x-5}{4}$中至少有一个是集合$p$的元素

所以我们可以筛出集合$p$

至于下面的贪心，就没什么好说的，就是把“取出$m$个数字”变成了“取$n-m$个数字（$n$为数字总数）”

每一次取能取到的最靠前的最大数字

Code:
```cpp
#include<stdio.h>
bool flag[5000010];                          flag[i]表示i是否是p的元素
int p[30010],cnt;
int num[200010];int n;
void insert(const int &val){
    if(val/10)insert(val/10);
    num[++n]=val%10;
}
int pos[10][40010],size[10],now[10];
int main(){
    register int i,K,m;
    scanf("%d%d",&K,&m);
    flag[1]=flag[3]=flag[7]=true;
    p[1]=1,p[2]=3,p[3]=7,cnt=3;
    for(i=9;cnt<K;i+=2){
        if(flag[i]=flag[i>>1]||(!((i-1)&3)&&flag[(i-5)>>2]))p[++cnt]=i;
    }
    for(i=1;i<=K;++i)insert(p[i]);
    for(i=1;i<=n;++i){
        putchar(num[i]+48);
        pos[num[i]][size[num[i]]++]=i;
    }
    putchar('\n');
    m=n-m;
    if(m<0)return 0;
    while(m--){
        for(i=9;i>=0;--i)if(now[i]<size[i]&&n-pos[i][now[i]]>=m)break;
        putchar(i+48);
        K=pos[i][now[i]];
        for(i=0;i<=9;++i)while(pos[i][now[i]]<=K&&now[i]<size[i])++now[i];
    }
    putchar('\n');
}
```

---

## 作者：Y_B_Y (赞：4)

## 这一题可以分为三个部分

1.得出集合中最小的K个元素并拆分为每一个独立的数(如1,2,15->1,2,1,5)

2.删除M个数位上的数字，使得剩下的数字最大

3.输出
### 第一部分

用k[i]表示数i是否再集合中,因为题意30000数中最大的数不超过5000000 ~~(别问我怎么知道的)~~ 所以i从1-5000000循环如果数i是集合中的数就将它归为集合中第num2小的数(拆分在后面讲),num2加一,并将2*i+1与4*i+5也加入集合中(即k[2*i+1]=1,k[4*i+5]=1)当num2==n(即题意中的k)时停止循环

拆分:当将i归为集合中的num小的数时将i的每一位存入a数组中,a数组的大小用num来存(即a[++num]=i的某一位),这里用数组来模拟链表next[i]表示i的下一个,pre[i]表示i的前一个,所以拆数时还要将next[num]=num+1,pre[num]=num-1,具体看代码



代码:
```cpp
#define pow ppo
int pow(int b)//因为原本的pow返回double型所以自己编了一个,这里的函数名因为用了define实际上是ppo,返回的数是十的b次方(int型)
{
	int an=1;
	for(int p=1;p<=b;p++) an*=10;
	return an;
}
void cs(int k,int l)
{
	if(k/pow(l)) cs(k,l+1);//递归拆数高位在前
	int k1;
	k1=((k%pow(l))/pow(l-1));//从右往左第l位,如543%pow(3)/pow(3-1)=543%1000/100=5(从右往左第三位)	
	a[++num]=k1;//存入a数组
	next[num]=num+1;//表示下一个数的位置
	pre[num]=num-1;//表示上一个数的位置
}
k[1]=1;//1是集合元素
for(int p=1;p<=5000000;p++)
{
	if(k[p])如果数p是集合中的数
	{
	    num2++;//第num2小的数
            cs(p,1);//将p的每一位存入a数组中
	    k[2*p+1]=1;
	    k[4*p+5]=1;//并将2*p+1与4*p+5加入集合中
	}
	if(num2==n) break;//当num2==n(即题意中的k)时停止循环
	}
```

### 第二部分

贪心可知每次要删的数为第一个下降子序列的最后一位(即第一个上升子序列的第一位),所以当a[i]<a[next[i]]时将a[i]删除(删除的具体步骤看代码),因为a[num+1]为一个很大的数所以如果没有上升子序列就会删最后一个数,用h表示h之后(包括)可能出现上升子序列(h的位置转移看代码),用两层循环来删数(第一个表示删第几个数,第二个为找要删的数,知道了一定要停止)

代码

```cpp
	next[num+1]=0;//最后一个没有下一个
	a[num+1]=32165478;
	for(int _=1;_<=m;_++)//删m个数
	{
		for(int i=h;i<=num;i=next[i])//链表,i不超过num
		{
			if(a[i]<a[next[i]])//出现上升子序列(也可能是最后一个数)
			{
				if(pre[i])//如果上升子序列的第一个数不是序列第一个数(前一个数不是a[0])
				{
					h=pre[i];//h为它的前一个数,因为a[h]可能为上升子序列的第一个数,那么它的前一个数也可能为上升子序列的第一个数如:547,h=2指向4,删除4得57,h应等于1指向5
					next[h]=next[i];//前一个数的下一个数等于它的下一个数(删除第i个数)
					pre[next[i]]=h;//它的下一个数的前一个数为h
				}
				else h=next[i],pre[h]=0;//没有前一个数h为它的下一个数且a[h]也没有前一个数,因为前面都没有了(即没有可能为h的数)所以只能为i的下一个数
				break;//找到了一定要停止
			}
		}
	}
```

关于删除链表中的一个数(当删除的数不为第一个数时)

h=pre[2]=1
![](https://cdn.luogu.com.cn/upload/pic/71338.png)

如果3不存在(即2为最后一个数)也可以用

当删除的数为第一个数时

h=next[1]=2
![](https://cdn.luogu.com.cn/upload/pic/71340.png)


### 第三部分
先输出h的前一个数的前一个数的前一个数的....(所以用递归输出直到前一个数为a[0])

代码
```cpp
void print(int b)//首先要判断b不为零
{
	if(pre[b]) print(pre[b]);
	cout<<a[b];
}
```
再输出h与h的后面

代码
```cpp
for(int i=h;i<=num;i=next[i]) cout<<a[i];//i要小于num
```

## 完整代码

```cpp
//大部分上面已经讲过了
#include<bits/stdc++.h>
using namespace std;
#define next nettt//防止因为定义next出错
#define pow ppo
int pre[3000001],a[3000001],next[3000001],h,n,m,num,num2;
bool k[30000001];
void print(int b)
{
	if(pre[b]) print(pre[b]);
	cout<<a[b];
}
int pow(int b)
{
	int an=1;
	for(int p=1;p<=b;p++) an*=10;
	return an;
}
void cs(int k,int l)
{
	if(k/pow(l)) cs(k,l+1);
	int k1;
	k1=((k%pow(l))/pow(l-1));	
	a[++num]=k1;
	next[num]=num+1;
	pre[num]=num-1;
}
int main()
{
	cin>>n>>m;
	k[1]=1;
	for(int p=1;p<=5000000;p++)
	{
		if(k[p])
		{
			num2++;
            cs(p,1);
			k[2*p+1]=1;
			k[4*p+5]=1;
		}
		if(num2==n) break;
	}
	h=1;//h一开始为1
	for(int i=h;i<=num;i=next[i]) cout<<a[i];//输出删除前的数字
	cout<<endl;//一定要换行
	next[num+1]=0;
	a[num+1]=32165478;
	for(int _=1;_<=m;_++)
	{
		for(int i=h;i<=num;i=next[i])
		{
			if(a[i]<a[next[i]])
			{
				if(pre[i])
				{
					h=pre[i];
					next[h]=next[i];
					pre[next[i]]=h;
				}
				else h=next[i],pre[h]=0;
				break;
			}
		}
	}
	if(pre[h]) print(pre[h]);//一定要先判断不为零,虽然不判断也能ac(但过不了样例)
	for(int i=h;i<=num;i=next[i]) cout<<a[i];
	return 0;
}
```





---

## 作者：lytqwq (赞：3)

#### 我们把问题分开：

1.  求出删除前的数字

2.  删数


------------

#### 问题1：
我们可以开小根堆，堆开始只有1，然后每次取顶上的元素p，弹出堆顶的p，将p存入数组a，在堆中加入2*p+1和4*p+5

当存每个p的a数组有k个元素时，这a数组就是存的集合中最小的k个元素了，我们直接按顺序输出，问题1 O(N log N)解决


------------

#### 问题2：
我们先把数组a中的数的每一位分开，然后存到一个新的数组b中

再开存问题2答案的数组c，枚举数组b的每一位，设现在c中有k个元素，贪心，我们要利用好每一次删数的机会，当
```cpp
c[k-1] < c[k] && m>0
```
时，我们把c数组中第k-1个数删掉，然后m- -,k- -
，然后就O(N)完成了问题2。~~（好像还要乘一个N以10为底的对数）~~

问题2具体还是有很多细节的，如c[0]=10;等，代码都有解释：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define M 30001
int k,m;
int b[M*10],topb,c[M*10],topc=1;
int top,a[M];
priority_queue<int,vector<int>,greater<int> > q;//小根堆 
int main()
{
	scanf("%d%d",&k,&m);
	q.push(1);//开始先存1在小根堆中 
	int now;
	while(!q.empty())
	{
		now=q.top();
		q.pop();
		a[++top]=now;
		if(top==k)
		{
			break;//当a（既存每个最小值）的数组有k个时，就不用在求了，跳出 
		}
		q.push(2*now+1);
		q.push(4*now+5);
	}
	//下面是写的很丑的取每一位的数到数组b 
	int qaq=1;
	while(now>=qaq)
	{
		qaq*=10;
	}
	qaq/=10;
	//qaq为最大位数的1e（位数-1） 
	for(int i=1;i<=top;i++)
	{
		int yes=0,nowqaq=qaq;
		for(;nowqaq!=0;nowqaq/=10)
		{
			if(a[i]/nowqaq==0 && yes==0)
			{
				a[i]%=nowqaq;
				continue;
			}
			if(a[i]/nowqaq!=0)
			{
				yes=1;
			}
			b[++topb]=a[i]/nowqaq;
			a[i]%=nowqaq;
			printf("%d",b[topb]);//在这里输出和在之前输出一样 （也许可能慢点） 
		}
	}
	
	printf("\n");
	c[0]=10;//边界条件 ，取10可以大于所有合法的c数组的其他数 
	//我这里的topc是下一个位置的 
	for(int i=1;i<=topb;i++)
	{
		if(b[i]>c[topc] || m==0)
		{
			c[topc]=b[i];//存入到c数组 
			topc++;
		}
		else
		{
			m--;//在根源解决问题 
		}
		while(m>0 && c[topc-2]<c[topc-1])//事后解决问题 
		{
			m--;
			topc--;
			c[topc-1]=c[topc];
			c[topc]=0;
		}
	}
	topc-=m;//m可能没利用完 
	for(int i=1;i<=topc-1;i++)
	{
		printf("%d",c[i]);//输出最后结果 
	}
	printf("\n");
}
```



---

## 作者：吃葡萄吐糖 (赞：3)

### 实验性题解 请勿在noip中使用

正如管理员所说，“有一种歧视叫STL”。

首先我们有两个任务：

-  完成数列

-  删除数字

#### 完成数列

首先我们要知道有一种东西叫优先队列，并且可以要求它其中的所有元素从小到大排列。

我们~~清晰的~~意识到这个集合容纳的元素很多，所以我们使用优先队列，每次取出最小的，将2*p+1和4*p+5入队，头出队，并将该值接在总数字串的后面（使用string），这样就能保证拿到题目所要求的数字串

这里使用了c++11的to_string，使原本需要十多行的代码变为一行，**但是不要在noip中使用。**

#### 删除数字

我们既然使用了string，删除操作就简单的多了（erease即可）。首先这里使用了贪心的思想，每次删除的是数字串中从左往右第一次出现的升序数列的第一个数，删除之后又从头开始。

这里是代码：
```cpp
#include<iostream>
#include<string>
#include<queue>
using namespace std;
priority_queue<int,vector<int>,greater<int> > q;
int k,m;
string num;
string got;
int main()
{
	cin>>k>>m;
	q.push(1);
	while(k--)
	{
		int head=q.top();
		q.pop();
		q.push(head*2+1);
		q.push(head*4+5);
		num+=to_string(head);
	}
	cout<<num<<endl;
	while(m){
		for(int i=0;i<(num.size());i++){
			if(num[i]<num[min(i+1,int(num.size()-1))]){
				num.erase(i,1);
				m--;
				break;
			}
		}
	}
	cout<<num;
    return 0;
}
```
~~所以我真是个懒人。~~

---

## 作者：NKL丶 (赞：3)

## 这一题我使用了优先队列 ~~（因为自带从小到大，并且用起来比较方便）~~
### 我先将数列里面的数字存进去一个数组int的数组里面，存数列里面的数字。
### 然后用字符串将存进去的数字“压在一起”。（注，这里要注意“压”的方向，要先用一个字符串顺序，然后逆序加进去）
### 接下来的操作就像[1106](https://www.luogu.org/problemnew/show/P1106)一样了。
附上我的代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
using namespace std;
priority_queue<int,vector<int>,greater<int> > a;//优先队列的定义
int n,k,x,tot[30005],tt,l;//tot存数列的数字，tt存tot当前到达的位置
string ee,eee;
int main()
{
	ios::sync_with_stdio(false);//加快字符串输出
	cin>>k>>n;
	a.push(1);
	for(int i=1;i<=k;i++)
	{
		if(a.top()==tot[tt]){a.pop();continue;}//已经出现过了
		a.push(a.top()*2+1);//*2+1
		a.push(a.top()*4+5);//*4+5
		tt++;//已经筛掉了，直接加入tot
		tot[tt]=a.top();
		a.pop();//弹出
	}
	for(int i=1;i<=k;i++)
	{
	eee="";//顺向存入当前的数字
	while(tot[i])
	{
		eee=eee+char(tot[i]%10+'0');
		tot[i]/=10;
	}
	l=eee.size();
	for(int j=l-1;j>=0;j--)ee+=eee[j];//逆向存储
	}
	l=ee.size();
	cout<<ee<<endl;
	for(int i=1;i<=n;i++)//下面是1106的操作
	{
	for(int j=0;j<l;j++)
	if(ee[j]<ee[j+1])
	{
	ee.erase(j,1);//用erase，用for会超时
	break;
	}
	l--;
	}
	cout<<ee;
	return 0;
}
```


---

## 作者：A_little_fresh (赞：2)

浏览了一遍，发现题解里没有蜜汁string的题解，本萌新就分享一下我不是很满意的源代码吧。
过是过了但效果不是很满意：
耗时/内存 1776ms, 5484KB
思路是用STL大法的set存集合元素然后找，从小的开始找，一边找一边加一边转成字符串，用了stringstream这里需要#include<sstream>才可以。具体可以看[数字转字符串](https://blog.csdn.net/michaelhan3/article/details/75667066/)
  
  然后是一波我的代码：
  ```
#include <set>
#include <cmath>
#include <sstream>
#include <string>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

set < int > st;  //用来存找元素
set < int > ::iterator it;

int main()
{
    int k,m,tmp,co;
    string s,ans;

    st.insert(1);   // 先放个1
    it=st.begin();
    while (cin>> k >> m)
    {
        s="",ans="";
        it=st.begin();
        co=0;
        while ( st.size()<60000 && co<k) //适当地找
        {
            tmp=*it;

            string tmps;
            stringstream tmpstr;
            tmpstr << tmp ;
            tmpstr >> tmps;
            s+=tmps;
            co++;         //一边找一边转化存进字符串

            st.insert(2*tmp+1);
            st.insert(4*tmp+5);
            it= st.find(tmp);  //保证it 的时效性
            it++;
        }
        cout << s << endl;  //这个很容易就搞到手了

        int p=m;
        ans=s;      //在s的基础上删
        unsigned int i=0;
        while (p--)   //计次
        {
            if (ans.length()==1)
            {
                ans="";
                break;
            }
			//先找非递减数删掉
            while (i<ans.length()-1 && ans[i]>=ans[i+1])
                i++;
            if (i!=ans.length()-1)
            {
                ans=ans.substr(0,i)+ans.substr(i+1,ans.length());
                if (i>0)    i--;
            }
            else //然后删尾巴（可能的递减数）
                ans=ans.substr(0,ans.length()-1);
        }

        cout << ans << endl;
    }

    return 0;
}
```

在后半部分一开始错了，想了好久，虽然还是不太满意，但应该可以供大家参考下。

---

## 作者：Jonas_Max (赞：2)

不太会操作string类和sprintf函数，就自己yy了一种构建这个字符串的方式。就是需要倒着看，倒着想。于是贪心策略变成:a[i]<a[j]且i>j 则优先删掉a[i]。构建时使用了STL。不加优化会T两个点左右。


```cpp
#include <cstdio>
#include <queue>
using namespace std;
int k,m,t,save[500000],cnt;
int del[50000000],next[50000000],last[50000000];
char list[50000000];
priority_queue<int,vector<int>,greater<int> > q;
int find(int s)
{
    do s=next[s];
    while (del[s]==1);
    return s;
}
int main()
{
    scanf("%d%d",&k,&m);
    q.push(1);
    while(!q.empty()&&cnt<k) { //取到足够k的数就跳出
        t=q.top();
        save[cnt]=t;
        q.pop();
        q.push(t*2+1);//这里两个入队本来是需要判重的，但经验证不需要
        q.push(t*4+5);
        ++cnt;
    }
```
/\*将数分离成数字并"填"到这个字符串中 \*/

```cpp
    int p=0;//p当前数字的位置
    //由于每个数各位分离的过程是由低到高 即个十百千万
    //所以应从最后一个数字倒着分离 i=cnt-1 这样这个字符串也是倒的
    for(int i=cnt-1; i>=0; --i) {
        t=save[i];
        while(t) {
            list[p++]=t%10+'0';
            t/=10;
        }
    }
```
/\*处理前\*/

```cpp
    for(int i=p-1; i>=0; --i) {
        putchar(list[i]);
    }
    putchar('\n');
```
/\*贪心删数+链表优化\*/

```cpp
    for(int i=p-1; i>=0; --i) { //构建链表
        next[i]=i-1;
        last[i]=i+1;
    }
    //s相当于头指针 e1,e2用来遍历这个字符串 每次从头开始遍历 
    //贪心策略: list[e1]<list[e2],e1>e2 则优先删掉list[e1]
    int s=p-1,e1,e2,o,tmp;
    for(int i=1; i<=m; ++i) { //删数 做m次
        o=0;
        e1=s;
        e2=find(e1);
        while(1) {
            if(list[e1]<list[e2]
                ||e2==-1) { //如果遍历到了最后一个元素 则必定删掉它
                del[e1]=1;
                if(o==0)s=e2;
                //如果第一次循环就删掉一个数 相当于删掉头节点 只需让s指向新的头节点
                else { //否则删除链表中的元素
                    next[last[e1]]=e2;//删除掉e1；
                    if(e2!=-1)last[e2]=last[e1]; //最后一个元素需要特判
                }
                break;
            } else {
                tmp=e1;
                e1=e2;
                e2=find(tmp);
            }
            ++o;
        }
    }
```
/\*处理后\*/
```cpp
    for(int i=s; ;i=next[i] ) {
        putchar(list[i]);
        if(next[i]==-1)break;
    }
    return 0;
}.

```

---

## 作者：hhe_benlaji (赞：2)

看到下面的dalao用的都是char，本蒟蒻表示没有那麽厉害，又想偷懒，就用了string

里面的那个int-〉string 的网站:http://blog.csdn.net/hobbit1988/article/details/7935546


```cpp
#include<bits/stdc++.h>
using namespace std;
string s,s2;
int k,m;
void int2str(const int &int_temp,string &string_temp)
{
        stringstream stream;
        stream<<int_temp;
        string_temp=stream.str();   //此处也可以用 stream>>string_temp
}
int main()
{
    cin>>k>>m;
    int tot=0;
    priority_queue<int,vector<int>,greater<int> >q;
    q.push(1);
    while(tot<k)
    {
        int c=q.top();
        q.pop();
        q.push(c*2+1);
        q.push(c*4+5);
        tot++;
        cout<<c;
        int2str(c,s2);
        s+=s2;
    }
    cout<<endl;
    tot=0;
    for(int i=1;i<=m;++i)
    {    int l=s.size();
        int j; 
        for(j=0;j<l-1;++j)
        {
            if(s[j]<s[j+1])
            {
                s.erase(j,1);
                break;
            }
        }
        if(j==l-2);
            s.erase(l-1,1);
    }
    cout<<s;
}
```

---

## 作者：ceba_robot (赞：2)

这个题目大致上分为两个部分，第一部分是构造出题目要求的集合中的前k个元素，第二部分是贪心删数。第二部分和洛谷上的同命题目思路几乎完全相同，只不过是把最小变成最大，贪心策略变成了删除第一个递增数列的第一个（第一个递减数列的最后一个）。第一部分的重点是按大小顺序产生元素。第一种思路是产生足够多的元素然后排序，但是很遗憾，数据范围很大，超时；第二种思路是利用STL优先队列，这个管理员yyy2015c01已经在他的题解中写过了；第三种思路是利用归并排序中的分治第三步，将两个有序表合成一个有序表，我采用的就是第三种。下面具体讲讲怎么回事：首先很显然，由2p+1或4p+5递推产生的数列都是一个严格递增的有序数列，我们把它当作两个队列，我们每次取出一个数时，比较两个队列队首元素的大小，将较小的元素出队，然后将这个元素经过处理后在分别放入两个队列，这样就可以得到一个严格递增的元素集合。这个地方我用了STL中的queue容器。

另外有一个细节值得注意：在删数之前可以将数列转化为字符串进行处理，我利用了一下sprintf函数的返回值，使得代码简化，效率提高。


###**禁止复制粘贴刷ac**


下面是代码：

···




        
    
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=30000+100;
char str[200010];
int next[200010];
int last[200010];
int k,m;
queue<int> q1;
queue<int> q2;
inline int f1(int x)
{
    return 2*x+1;
}
inline int f2(int x)
{
    return 4*x+5;
}
int main()
{
    scanf("%d %d",&k,&m);
    int now=1;
    str[1]='1';
    int pp=2;                                    //整个过程完成后，pp就是整个字符串的长度。 
    for(int i=1;i<k;i++)
    {
        q1.push(f1(now));
        q2.push(f2(now));
        if(q1.front()<q2.front())
        {
            now=q1.front();
            q1.pop();
        }
        else 
        {
            now=q2.front();
            q2.pop();
        }
        int tt=pp;
        tt+=sprintf(str+pp,"%d",now);
        pp=tt;
    }
    //删数部分 链表实现 
    for(int i=0;i<=pp;i++)
    {
        next[i]=i+1;
        last[i]=i-1;
    }
    printf("%s\n",str+1);    
    int ii=next[0];
    int ans=0;
    while(ii!=pp && ans<m)
    {
        if(str[ii]<str[next[ii]])
        {
            next[last[ii]]=next[ii];
            last[next[ii]]=last[ii];
            ans++;
            ii=next[0];
        }
        else
            ii=next[ii];
    }
    while(ans<m)
    {
        int temp=last[pp];
        next[last[temp]]=pp;
        last[pp]=last[temp];
    }
    for(int i=next[0];i!=pp;i=next[i])
        printf("%c",str[i]);
    printf("\n");
    return 0;
}
···
```

---

## 作者：疯疯芸 (赞：1)

**优先队列+单调队列** 了解一下   ~~手动滑稽~~

话不多说 先**%**楼上各位**dalao**



------------

取数操作就不说的,单纯的像一张白(hei)纸的优先队列,Google上找个板轻松搞定(~~一不小心暴露了什么~~)

下面就是删掉其中的M位得到一个最大的数;各位**dalao**各显神通,什么贪心,链表,string操作,STL......看得蒟蒻我眼冒金星,**dalao**就是**dalao**;

删数操作其实可以用单调队列~~手动滑稽~~

见代码

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=3e5+10;
struct fy//定义优先队列优先级 
{int d;bool operator<(const fy a)const{return d>a.d;}};
priority_queue<fy>q;//优先队列 
fy a,b;
int n,m,s[maxn],w,qq[maxn],p[maxn];
//s:取出的数每一位上的数; qq:单调队列; p:单调队列中每一位的位置 
void make(int a)//将取出的数装进s 
{
	int b=w+1,c;
	while(a){s[++w]=a%10;a/=10;} 
	c=w;//顺序反了,把它翻转 
	while(b<c) swap(s[b++],s[c--]);
}
int main()
{
	scanf("%d%d",&n,&m);
	a.d=1; q.push(a);
	while(n--)//优先队列 
	{
		a=q.top(); make(a.d);
		printf("%d",a.d); q.pop();
		b.d=a.d*2+1; q.push(b);
		b.d=a.d*4+5; q.push(b);
	}
	printf("\n");
	int t=1,we=0,l=m+1;
	for(int i=1;i<=w;i++)//单调队列 
	{
		while(t<=we&&s[i]>qq[we]) we--;
		qq[++we]=s[i];p[we]=i;
		if(i-p[t]+1>l) t++;
		if(i>=l) 
		{
			printf("%d",qq[t]);
			t++;
		} 
	}
	return 0;//完美结束 
}
```

---


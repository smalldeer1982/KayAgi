# [KOI 2025 #1] 稻草人

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

一支带有力量 $P$ 的箭从数轴上的位置 0 向右方发射。在每个整数位置 $i$ ($1 \le i \le N$)，最多可以设置一个防御力为 $A_i$ 的稻草人。当箭撞到稻草人时，如果箭的力量小于或等于稻草人的防御力，箭会立即停止。反之，如果箭的力量大于防御力，箭的力量会减去 $A_i$ 并继续前进。

对于整数 $i$，我们将 $f(i)$ 的值定义为“为了使箭在位置 $i$ 或其左侧停止所需要的**稻草人的最小数量**”。如果无法使箭停止，则值为 $-1$。

例如，假设 $N=5, P=10$ 并且 $A_1=3, A_2=6, A_3=1, A_4=1, A_5=10$。所有 $f(i)$ 的值和安装的稻草人的位置如下表所示。

| $i$ | $f(i)$ 的值 | 安装的稻草人的位置 |
| :--: | :--: | :--: |
| $i=1$ | $-1$ | 不可能 |
| $i=2$ | $-1$ | 不可能 |
| $i=3$ | $3$ | $[1, 2, 3]$ |
| $i=4$ | $3$ | 可选择 $[1, 2, 3]$ 或 $[1, 2, 4]$ 之一 |
| $i=5$ | $1$ | $[5]$ |

请编写一个程序，求出对于所有 $1 \le i \le N$ 的 $i$ 的 $f(i)$ 值。

## 说明/提示

### 限制条件

*   给定的所有数都是整数。
*   $1 \le N \le 500,000$
*   $1 \le P \le 10^9$
*   对于每个 $1 \le i \le N$ 的 $i$，都有 $1 \le A_i \le 10^9$。

### 子任务

1.  (4 分) $N \le 8$
2.  (8 分) $N \le 5000$
3.  (8 分) 对于所有 $1 \le i \le N$ 的 $i$，$A_i = 1$。
4.  (20 分) 对于所有 $1 \le i \le N$ 的 $i$，$A_i = 2$ 或 $A_i = 3$。
5.  (40 分) 对于所有 $1 \le i \le N$ 的 $i$，$A_i \le 50$。
6.  (40 分) 对于所有 $1 \le i < N$ 的 $i$，$A_i \le A_{i+1}$。
7.  (30 分) 无附加限制条件。

## 样例 #1

### 输入

```
5 10
3 6 1 1 10```

### 输出

```
-1 -1 3 3 1```

## 样例 #2

### 输入

```
3 10
20 20 20```

### 输出

```
1 1 1```

## 样例 #3

### 输入

```
1 5
3```

### 输出

```
-1```

# 题解

## 作者：chen_zhe (赞：8)

### 子问题 2

优先安装防御力高的稻草人是最佳策略。每次计算 $f(i)$ 时，从子数组 $A_1, \dots, A_i$ 中，从大到小依次选择元素，使得所选元素之和不小于 $P$，这是最优策略。此方法可以在 $O(N^2 \log N)$ 的时间复杂度内解决问题。

### 子问题 3

对于所有的 $i$，如果 $i \ge P$，则 $f(i) = P$，否则 $f(i) = -1$。

### 子问题 4

优先安装防御力为 3 的稻草人是最佳策略。设位置 1 到 $i$ 的稻草人中，防御力为 2 的数量为 $X_i$，防御力为 3 的数量为 $Y_i$。$X_i$ 和 $Y_i$ 可以通过前缀和求得。

*   如果 $Y_i \times 3 \ge P$，则 $f(i) = \lceil \frac{P}{3} \rceil$
*   如果 $X_i \times 2 + Y_i \times 3 \ge P > Y_i \times 3$，则 $f(i) = Y_i + \lceil \frac{P - Y_i \times 3}{2} \rceil$
*   否则，$f(i) = -1$

时间复杂度为 $O(N)$。

### 子问题 5

与子问题 4 中维护前缀和的方法类似，分别维护防御力从 1 到 50 的稻草人的数量。对于每个 $i$，与子问题 4 类似，从防御力大的稻草人开始使用，检查防御力之和是否超过 $P$，并求出所需的最小数量。时间复杂度为 $O(50 \times N)$。

### 子问题 6

设有一个队列 $Q$ 用于存储稻草人的防御力，队列中元素的和为 $S$。从最前面的稻草人开始，将其防御力依次插入队列中。随着 $i$ 的增大，插入队列的值是单调递增的。因此，如果从队列中移除队首元素后，队列中元素的和仍然能维持在 $P$ 或以上，就移除该元素。注意，这个操作需要不断重复，直到无法再进行为止。

在每个 $i$ 处，重复更新操作以保持队列大小最小。如果 $S < P$，则 $f(i) = -1$，否则 $f(i) = |Q|$。（其中 $|Q|$ 是 $Q$ 中元素的数量）时间复杂度为 $O(N)$。

### 子问题 7

如果使用优先队列代替子问题 6 中维护的队列，那么即使输入不具有单调性，也可以解决问题。时间复杂度为 $O(N \log N)$。

```cpp
#include <iostream>
#include <queue>
 
using namespace std;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
 
    int n, p;
    cin >> n >> p;
 
    priority_queue<int, vector<int>, greater<>> pq;
    for (int i = 0; i < n; i++) {
        int a;
        cin >> a;
 
        p -= a;
        pq.push(a);
        while (!pq.empty() && p + pq.top() <= 0) {
            p += pq.top();
            pq.pop();
        }
 
        cout << (p > 0 ? -1 : (int)pq.size()) << " ";
    }
}
```

---

## 作者：__Clare613__ (赞：4)

关于这题能评黄为什么，我不知道，但无所谓。这道题主要是审题。
## 思路：
:::info[题目大意]{open}
有 $n$ 个稻草人，一支力量为 $P$ 的箭。现求在位置为 $i$ 的地方，$\sum^{1}_{i} a_{i}$ 的和是否大于等于 $P$，是，输出最小几个稻草人，否输出 $-1$。
:::
明确了题目大意后，我们可以看到时限为 2.00s。那么我们用优先队列的小根堆，每次加入后判断是否大于等于 $P$。如果大于等于 $P$，就把栈顶的数字减去，再判断是否大于等于 $P$，直到再减就小于 $P$ 为止。
## code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[500005];
signed main(){
	int n,p;
	cin>>n>>p;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	priority_queue<int,vector<int>,greater<int> > q; 
	int sum=0,cnt=0,l=1;
	for(int i=1;i<=n;i++){
		sum+=a[i];
		q.push(a[i]);
		cnt++;
		if(sum<p){
			cout<<"-1 "; 
			continue;
		}
		while(!q.empty()&&sum-q.top()>=p){
			sum-=q.top();
			q.pop();
		}
		cout<<q.size()<<" ";
	}
	return 0;
}
/*
11 13
*/
```

---

## 作者：yezile0225 (赞：4)

# P13512 [KOI 2025 #1] 稻草人 题解

[原题传送门](https://www.luogu.com.cn/problem/P13512)

## 题目大意

求出对于所有 $1 \le i \le N$ 的 $i$，为了使箭在位置 $i$ 或其左侧停止所需要的稻草人的最小数量。

## 题目思路

需要的稻草人的最小数量，那么所选择的稻草人的防御力要尽量大。因为需要的稻草人的最小数量，每次添加一个稻草人的防御力后就进行判断**取出一个所选稻草人中防御力最小的是否仍然能使所选稻草人的防御力总和大于箭力量 $P$**，如果满足，就取出那个所选稻草人中防御力最小的。

操作过程：
- 添加第 $i$ 个稻草人的防御力 $A_i$。
- 如果满足条件，就取出那个所选稻草人中防御力最小的。

要注意的是，取出的步骤可能**执行多次**。

每次添加后寻找最小的可以给它排序，但时间复杂度是 $O(N^2\log{N})$，会 TLE。

这时候就可以用**小根堆**来实现，时间复杂度只需要 $O(N\log{N})$。

可以直接用 C++ 的 STL 库的 `priority_queue` 构建小根堆。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int N, P;
int s = 0;//s指所选稻草人的防御力总和
int A[500005];
priority_queue<int, vector<int>, greater<int> >q;
//小根堆
int main() {
	cin >> N >> P;
	for (int i = 1; i <= N; i++) {
		cin >> A[i];
	}
	for (int i = 1; i <= N; i++) {
		s += A[i];
		q.push(A[i]);//添加第 i 个稻草人的防御力
		while (q.size() && s - q.top() >= P) {
			int tmp = q.top();
			q.pop();
			s -= tmp;
      //取出所选稻草人中防御力最小的
		}
		if (s < P) cout << -1 << ' ';//如果所有的选择的稻草人的防御力小于箭力量 P，那么输出 -1
		else cout << q.size() << ' ';
	}
	return 0;
}
```

---

## 作者：Light_Rainbow (赞：3)

## P13512 [KOI 2025 #1] 稻草人题解

不难不易的一道优先队列的黄题。先依次读入数据并将其储存进优先队列里，再通过循环判断箭的力量 $p$ 与队头的和是否不大于 $0$ 且队不为空，如果是，箭的力量 $p$ 就加上队头并弹出队头。最后判断 $p$ 并输出。再代码奉上。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll a,n,p;
priority_queue<ll,vector<ll>,greater<ll> > pq;
signed main() {
    cin>>n>>p;
    for(ll i=1;i<=n;i++){
    	cin>>a;
    	p-=a;
    	pq.push(a);
    	while(!pq.empty()&&p+pq.top()<=0){
    		p+=pq.top();
    		pq.pop();
		}
		if(p>0)cout<<-1<<' ';
		else cout<<pq.size()<<' ';
	}
    return 0;
}
```

---

## 作者：ChampionCyan (赞：2)

## 思路

显然想使需要的稻草人数量最少一定会取防御力较大的那些稻草人，因为选较小的稻草人防御力总和在稻草人数量一样的情况下一定不更大，则能满足条件的稻草人数量一定不更少，也就一定不更优。

## 做法

当目前稻草人防御值之和小于 $P$ 时答案显然为 $-1$。

否则持续循环将总和减去防御值最小的一个直到总和减去防御值最小的一个小于 $P$ 为止，则答案即为循环次数。

用一个变量维护防御力总和，使用堆可以方便地维护最小值。

我们可以用 C++ 自带的[优先队列（`priority_queue`）](https://oi-wiki.org/lang/csl/container-adapter/#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)来实现堆，当然手写也是可以的。

显然 $f(i)$ 的值单调不上升，且因为 $P$ 的值不变，所以已经排除的稻草人以后均不用选，所以可以在线处理，时间复杂度 $O(n\log n)$（优先队列和手写堆的单次操作时间复杂度都是 $O(\log n)$，共有最多 $n$ 次操作），可以通过此题。

## 赛时 AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    cin.tie(0) -> sync_with_stdio(0);
    int n, m, sum = 0;
    cin >> n >> m;
    priority_queue<int, vector<int>, greater<int> > q;
    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        sum += x;
        q.push(x);
        if (sum < m)
            printf("-1 ");
        else {
            while (sum - q.top() >= m)
                sum -= q.top(), q.pop();
            printf("%d ", q.size());
        }
    }
    return 0;
}
```

---

## 作者：lilong (赞：1)

首先根据贪心显然应该优先选较大的数。加入当前新的数后，依次删除较小的数直到恰好不小于，并与之前的答案取较小值。使用 multiset 模拟此过程即可。时间复杂度 $O(n\log n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#define N 500010
#define int long long
using namespace std;
multiset<int> s;
int n,m,a[N],sum,nw,ans=1e18;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i],nw++,s.insert(a[i]);
        if(sum<m){
            cout<<-1<<' ';
            continue;
        }
        while(sum-*s.begin()>=m)
            sum-=*s.begin(),nw--,s.erase(s.begin());
        ans=min(ans,nw);
        cout<<ans<<' ';
    }
    return 0;
}
```

---

## 作者：mairuisheng (赞：1)

- 题目：[P13512 [KOI 2025 #1] 稻草人](https://www.luogu.com.cn/problem/P13518)。

- 简化题意：

有一个数列 $A_1, A_2, \cdots, A_N$，在 $A_1, A_2, \cdots, A_i$ 中至少选 $k$ 个数使得这 $k$ 个数的和大于 $P$，如果可以办到，$f(i)=k$；否则 $f(i)=-1$。

- 主要算法：贪心、堆（优先队列）。

- 分析：

分两种情况讨论：

①如果 $A_1, A_2, \cdots, A_i$ 的和小于 $P$，那么 $f(1), f(2), \cdots, f(i)$ 的值都是 $-1$，（把所有的数都选了还是无法满足条件）。

②否则，要使选择的数的个数最小，那么要选尽量选大的数，也就是删除小的数，用一个优先队列维护选择的数，首先将 $A_i$ 加入队列，如果删除队首的数后队列中数的和大于等于 $P$，就删除队首的数，重复执行此过程。最后输出队列大小即为 $f(i)$。

实际操作中可以将可以将①归并进②。

- 时间复杂度：$O(N\log N)$。

- 参考代码：

```cpp
//Author: mairuisheng
//#pragma GCC optimize(3)
#include<cstdio>
#include<queue>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char s;
	s=getchar();
	while(s<48||s>57)
	{
		if(s=='-')f=-f;
		s=getchar();
	}
	while(s>47&&s<58)
	{
		x=(x<<3)+(x<<1)+s-48;
		s=getchar();
	}
	return x*f;
}
int n,p;
priority_queue<int,vector<int>,greater<int> > q;
int main()
{
	n=read();
	p=read();
	int sum=0,a;
	while(n--)
	{
		a=read();
		q.push(a);
		sum+=a;
		while(!q.empty()&&sum-q.top()>=p)
		{
			sum-=q.top();
			q.pop();
		}
		printf("%d ",sum<p?-1:q.size());
	}
	return 0;
}
```

---

## 作者：alice_c (赞：1)

## 思路

考虑贪心。我们每一次选择防御力最大的 $a_i$，直到总和 $sum$ 大于等于 $p$，一定就是最优方案。暴力做法就是在每个位置 $i$ 给前 $i$ 个稻草人们排序，时间复杂度 $O(N^2 \log N)$。但是，$N \le 5 \times 10^5$，这显然是不行的。

我们可以把 $a_i$ 存到一个优先队列 $q$ 里，当 $sum$ 足够大且 $q$ 里还有元素时，我们可以选择不要一些稻草人，所以我们要把防御力最小的稻草人从优先队列里弹出。如果最后 $sum$ 还是小于 $p$ 就输出 $-1$，否则输出 `q.size()`。

优先队列默认是从大到小的，~~本蒟蒻不会重载小于号~~，只好把 $a_i$ 的相反数放入队列，用的时候再取一遍相反数就是从小到大了。

时间复杂度 $O(N \log N)$。

## 代码

```cpp
#include <iostream>
#include <queue>
using namespace std;
int n,p,a;
long long sum;
priority_queue<int> q;
int main()
{
    cin >> n >> p;
    for(int i=1;i<=n;i++){
        cin >> a;
        sum+=a;
        q.push(-a);
        while(q.size() && p<=sum-(-q.top())){
            sum-=(-q.top());
            q.pop();
        }
        if(p>sum) cout << -1 << ' ';
        else cout << q.size() << ' ';
    }
}
``````

---

## 作者：__HappY__ (赞：0)

最开始的想法，当然是贪心。既然想让选取的物品个数最少且权值尽量的大，直觉告诉我们，只要每次选取权值最大的，个数一定会最少。简单证明一下。

假设现在我们需要一个 $a_i$，则至少需要两个比 $a_i$ 小的数达到与其同样的贡献，此时的答案显然是不优的，所以需要每次取出最大值。

代码也不难写，每次加进来一个数，进行排序，找出最大值，进行遍历，只要总和大于要求即可， 代码如下。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, p;
const int N = 1e6 + 5;
int a[N];
int cmp (int a, int b) {
	return a > b;
}
signed main() {
	cin >> n >> p; 
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		sort(a + 1, a + n + 1, cmp); 
		int tot = 0;
		for(int j = 1; j <= i; j++) {
			tot += a[j];
			if(tot >= p) {
				cout << j << ' ';
				break;
			}
			if(j == i && tot < p) {
				cout << -1 << ' ';
				break;
			}
		}
	}
	return 0;
}
``````````

交上去之后只有可怜的十二分，观察后，发现时间复杂度为 $O (n^2 log n)$，包过不了的。

思索后发现，我们每次都需要取最值，所以自然想到优先队列。如果维护最大值，略嫌麻烦，不妨维护最小值。每次求一次前缀和，如果全部的加起来还没有到目标，则显然不行，操作时弹出最小值，操作到不能继续，则输出剩余的个数。

代码也比较简洁，大致如下。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, p;
const int N = 1e6 + 5;
int a[N];
priority_queue <int, vector<int>, greater<>> heap;
int s;
int tot = 0;
signed main() {
	cin >> n >> p; 
	for(int i = 1; i <= n; i++) {
		tot++;
		cin >> a[i];
		s += a[i];
		heap.push(a[i]);
		if(s < p) {
			cout << -1 << ' ';
			continue;
		}
		while(s - heap.top() >= p) {
			s -= heap.top();
			heap.pop(); 
			tot--;
		}
		cout << tot << ' '; 
	}
	
	return 0;
}
``````
希望管理员赶紧通过。

---

## 作者：ran_qwq (赞：0)

根据贪心，肯定要放尽量大的稻草人，但是如果每次都排序从大往小取会超时。

考虑用一个小根堆维护当前最大的那些数，使得和刚好 $\ge P$，答案即为小根堆大小。每次加数的时候把堆头那些较小的且 pop 掉之后和仍然 $\ge P$ 数 pop 掉。

每个数最多加入一次，所以是 $O(n\log n)$ 的。

[这是代码。](https://www.luogu.com.cn/paste/u1s93cr6)

---

## 作者：_xdd_ (赞：0)

### 题目大意：

一支力量为 $P$ 的箭从数轴上的位置 0 向右方发射，你可以在 $i$ 的位置设置一个防御力 $A_i$ 的稻草人，箭穿过时会减去 $A_i$ 的力量，力量小于等于 $0$ 后箭停止运动，对于每个 $i$，求使箭在位置 $i$ 或其左侧停止所需要的稻草人的最小数量。

### 解题方法

贪心的想，肯定要优先设置防御最强的几个稻草人拦截箭，这样才能做到稻草人数量最小，不过不好实现，所以容易想到，首先我们设置所有的稻草人，随后一个一个减少稻草人的数量，减少的稻草人防御肯定是最弱的（这样减少的数量才更多），这个的实现很简单，用小根堆维护一下就好，具体看代码。

### code

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define r0 return 0
#define inf (0x7fffffff)
#define maxn ( 500000 +5)
#define int long long
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
int n,p;
int a[maxn];
priority_queue<int,vector<int>,greater<int>>pq;
signed main(){
    cin >> n >> p;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    for(int i=1;i<=n;i++){
        p-=a[i];//摆放稻草人
        pq.push(a[i]);
        if(p>0){
            cout << -1 << ' ';//无解
            continue;
        }
        while(pq.size() && p+pq.top()<=0){//循环移除稻草人
            p+=pq.top();
            pq.pop();
        }
        cout << pq.size() << ' ';//最后剩下的数量
    }
    return 0;
}
```

---

## 作者：_Sky_Dream_ (赞：0)

# [传送门](https://www.luogu.com.cn/problem/P13512)

考虑贪心。要求使用最少的稻草人来抵御攻击，显然说明防御力越大的稻草人要越优先放置。

我们对于每个 $i$，都会有一个新的 $a_i$ 加入并且我们要进行排序，所以考虑用优先队列来维护。

对于每个新输入的 $a_i$，我们用箭现有的力量 $P$ 来减去 $a_i$，判断其正负，若为正，则说明即使用上现有的所有的稻草人也无法拦住这只箭。若为负，则说明可以拦下这只箭。

接下来考虑如何处理最小值。我们与其选择防御力更大的稻草人让他退休，显然不如让防御力更小的稻草人去退休，可以裁掉更多的稻草人来保证总数更小。从小到大枚举，注意判断是否符合条件。

```cpp
//#pragma GCC optimize(1)
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define int long long
#define MAX 1145141919810
#define rep(i,x,y) for(int i=x;i<=y;++i)
#define dep(i,x,y) for(int i=x;i>=y;--i)
#define N 114514
using namespace std;
int n,p,x;
priority_queue<int,vector<int>,greater<> >jyaakioi;//小根堆
void Enchanted(){
	srand(time(0));
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>p;
	rep(i,1,n){
		cin>>x;
		p-=x;//减去这个稻草人的衰弱
		jyaakioi.push(x);//加入这个稻草人
		while(!jyaakioi.empty()&&p+jyaakioi.top()<=0){//如果可以裁掉当前最小的稻草人
			p+=jyaakioi.top();//箭的力量削弱
			jyaakioi.pop();//这个稻草人退休
		}
		if(p>0)cout<<-1;//不符合情况
		else cout<<jyaakioi.size();//优先队列里剩下的稻草人数即为最小数
		cout<<' '; 
	}
}
signed main(){Enchanted();return 0;}



```

---

## 作者：FamousKillerconan (赞：0)

一道优先队列好题。


## 思路
首先，大家肯定是用贪心想法，把前 $i$ 个中大的加起来就行，但这样子不太好算，会超时。但是，我们可以使用小根堆，每次计算时都把小的弹出，这样里边的元素个数就是我们所求的答案了。


AC 代码：


```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<int,int>
#define endl "\n"
using namespace std;
const int N=5e5+5;
const int INF=1e9;
const double EPS=1e-6;
const int MOD=1e9+7;
int n,m,x,sum,cnt;
priority_queue<int,vector<int>,greater<int>>que;
void solve(){
	cin>>n>>m; 
	for(int i=1;i<=n;i++){
		cin>>x;
		que.push(x);
		sum+=x;
		cnt++;
		if(sum<m)cout<<"-1 ";
		else{
			while(sum-que.top()>=m)sum-=que.top(),que.pop(),cnt--;
			cout<<cnt<<" ";
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

## 题意

对于 $1\le i\le N$ 的每个位置 $i$，选出最少个不同的 $j$ 使得 $1\le j\le i$ 且 $\sum{A_j}\ge P$，求 $j$ 的个数的最小值，无法达到输出 $-1$。

## 解法

考虑贪心。显然选出的 $A_j$ 越大越优，用优先队列维护最大值，如果当前的总值仍然达不到要求，说明无解，否则不断弹出当前最小值直到刚好满足要求。每个 $A_i$ 最多只会被插入和弹出两次，优先队列维护是对数复杂度，时间复杂度正确，总时间复杂度 $O(N\log N)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
priority_queue<int,vector<int>,greater<int>> q;
signed main()
{
	int n,p,sum=0;
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		q.push(x);
		sum+=x;
		if(sum<p) cout<<"-1 ";
		else
		{
			while(sum-q.top()>=p) sum-=q.top(),q.pop();
			cout<<q.size()<<" ";
		}
	}
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13512)

## 思路：

简单反悔贪心。

一个很显然的贪心策略是每个区间计算时都一直优先在 $A_i$ 大的地方放稻草人直到可以让箭停下或者判断无法阻挡箭（即每个位置都放了稻草人仍不能使箭停下）为止。

但是这只是一个区间的贪心策略，如果对每个区间都这样计算，复杂度太大不能接受。

考虑将小区间的答案转移到大区间中，小区间中的答案已经是最优的了，但是在大区间中不一定优，例如可能在大区间中某一点的 $A_i$ 比小区间某两点的 $A_i$ 大，那么替换就能使答案变小。

所以要进行反悔操作，每次将大区间中不属于小区间的 $A_i$ 加进和中，然后若仍然无法使箭停下就输出 ```-1```，否则只要所选点的 $A_i$ 之和能让箭停下就一直将选择的 $A_i$ 中最小的删除，直到若删除这个 $A_i$ 就不能使箭停下为止。

对于维护所选的点中最小的 $A_i$，需要用到优先队列（小根堆），使用 STL 中的 ```priority_queue<long long,vector<long long>,greater<long long> >``` 即可。

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline long long read() {
	long long x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
void out(long long x) {
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
long long n,m;
long long a[5000005];
priority_queue<long long,vector<long long>,greater<long long> >q;
int main(){
	n=read();
	m=read();
	for(long long i=1;i<=n;i++) cin>>a[i];
	long long sum=0,cnt=0;
	for(long long i=1;i<=n;i++){
		q.push(a[i]);
		sum+=a[i];
		cnt++;
		if(sum<m){
			cout<<"-1 ";
			continue;
		} 
		while(1){
			long long g=q.top();
			q.pop();
			sum-=g;
			cnt--;
			if(sum<m){
				q.push(g);
				sum+=g;
				cnt++;
				break;
			}
		}
		cout<<cnt<<" ";
	}
	return 0;
}
```

---

## 作者：___TwilightEcho___ (赞：0)

~~蒟蒻的第一篇题解~~
## 核心思路
贪心策略 & 小根堆

### 问题转化
对于每个位置 $i$，需要找到最少的稻草人数量，使得这些稻草人的总防御值 ≥ 箭的初始力量 $P$，并且其中最大的防御值足够大（确保箭到达该位置时能被拦截）。
### 贪心策略
- 优先选择防御值大的稻草人，因为它们能更高效地消耗箭的力量。
- 使用 **小根堆（优先队列）** 动态维护当前选中的稻草人，堆顶元素为最小值。
- 遍历每个位置 $i$ 时，将当前稻草人加入堆，并尝试移除最小的元素（如果移除后总和仍满足条件），以减少稻草人数量。

## Code
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
int n, p;
int main() 
{
    cin >> n >> p;
    vector<int> ans(n);
    priority_queue<int, vector<int>, greater<int>> heap;
    int sum = 0; // 当前选中的稻草人总防御值

    for (int i = 0; i < n; ++i) 
	{
        int a;
        cin >> a;
        heap.push(a);
        sum += a;
        
        // 移除最小的元素，直到总和不小于P且最大元素足够大
        while (!heap.empty() && sum - heap.top() >= p) 
		{
            sum -= heap.top();
            heap.pop();
        }
        
        if (sum >= p && heap.top() >= (sum - p + 1))
            ans[i] = heap.size();
		else
            ans[i] = -1;
    }

    // 输出
    for (int i = 0; i < n; ++i)
        cout << ans[i] << (i == n - 1 ? '\n' : ' ');

    return 0;//完结撒花
}
```

---


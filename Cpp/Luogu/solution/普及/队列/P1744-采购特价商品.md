# 采购特价商品

## 题目背景

《爱与愁的故事第三弹·shopping》第一章。

## 题目描述

中山路店山店海，成了购物狂爱与愁大神的“不归之路”。中山路上有 $n$（$n \leq 100$）家店，每家店的坐标均在 $-10000$ 至 $10000$ 之间。其中的 $m$ 家店之间有通路。若有通路，则表示可以从一家店走到另一家店，通路的距离为两点间的直线距离。现在爱与愁大神要找出从一家店到另一家店之间的最短距离。你能帮爱与愁大神算出吗？

## 说明/提示

对于 $100 \%$ 的数据：$2 \le n \leq 100$，$1 \le i, j, s, t \le n$，$1 \le m \leq 1000$。 

## 样例 #1

### 输入

```
5
0 0
2 0
2 2
0 2
3 1
5
1 2
1 3
1 4
2 5
3 5
1 5```

### 输出

```
3.41```

# 题解

## 作者：xhQYm (赞：62)

### $\texttt{Update:}$

- $\texttt{2020/05/10:}$ 修改了部分文章错误和表述问题。


----

这题就是一道SPFA裸题啊。。本蒟蒻在此讲解一下SPFA的做法。


SPFA的时间复杂度：

最好：$O(m)$

最坏：$O(n*m)$

不稳定的。

SPFA的思路如下：

- 定义一个队列，将第一号点放进去

- 把队列的每一个数拿出来看并标记已出队还有pop掉。

   - 挨个看所有与这个点联通的点
   
      - 如果更优，判断是否再队列里，如果不在，放到队列里并更新最短路
      
      - 如果不更优，啥都不干就完了。


思路就是上面这亚子。一句话概括就是：

Spfa就是定义一个队列，将所有有可能能优化最短路的点全都放进去，最后拿出来一个个判断就可以了

SPFA的模板带注释（不是这题答案）：

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,h[N],e[N],ne[N],dist[N],w[N],idx;
bool st[N];
void add(int a,int b,int c)
{
	e[idx]=b;w[idx]=c;ne[idx]=h[a];h[a]=idx++;
}//邻接表存储
void Spfa()
{
	memset(dist,0x3f,sizeof dist);
	dist[1]=0;
	queue<int> q;
	q.push(1);
	st[1]=true;
	while(!q.empty())
	{
		int t=q.front();//取出来
		q.pop();
		st[t]=false;
		for(int i=h[t];i!=-1;i=ne[i])//所有相邻的
		{
			int j=e[i];
			if(dist[j]>dist[t]+w[i])//如果更优
			{
				dist[j]=dist[t]+w[i];//更新
				if(!st[j])//不在队列里面
				{
					q.push(j);//放进去
					st[j]=true;	//标记已在队列里
				}	
			}	
		}	
	}
}
int main()
{
	cin>>n>>m;
	memset(h,-1,sizeof h);
	while(m--)
	{
		int a,b,c;
		cin>>a>>b>>c;
		add(a,b,c);//建一条边
	}
	Spfa();//调用
	if(dist[n]==0x3f3f3f3f) cout<<"impossible";//如果不行输出impossible
	else cout<<dist[n];
	return 0;
}
/**
 * 注意：此模板默认1->n
 * 如果想自定义起点终点，把其中的1改成起点，输出改成终点就可以了
 * 
 *
 * 这个模板在我的CSDN博客上也有。
 * 链接：https://blog.csdn.net/user_qym/article/details/104107107
 */
 
 

```

标注：以上模板来自 [AcWing](https://www.acwing.com/about/)

好了，这题就是把SPFA稍微改一改就行了。

上代码！！（无注释，上面都有）：
```
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=1010;
int h[N*2],e[M*2],ne[M*2],n,m,x[N*2],y[N*2],s,end,idx;
double w[M*2],dist[N*2];
bool st[N*2];
double distance(int x1,int y1,int x2,int y2)
{
	return sqrt(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2));
}
void add(int a,int b,double c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
void spfa()
{
	for(int i=1;i<=n;i++) dist[i]=1000000000.0;
	dist[s]=0;
	queue<int> q;
	q.push(s);
	st[s]=true;
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		st[t]=false;
		for(int i=h[t];i!=-1;i=ne[i])
		{
			int j=e[i];
			if(dist[j]>dist[t]+w[i])
			{
				dist[j]=dist[t]+w[i];
				if(!st[j])
				{
					st[j]=true;
					q.push(j);
				}
			}
		}
	}
	cout<<fixed<<setprecision(2)<<dist[end];
}
int main()
{
    cin>>n;
    memset(h,-1,sizeof h);
    for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
    cin>>m;
    while(m--)
    {
    	int a,b;
    	cin>>a>>b;
    	add(a,b,distance(x[a],y[a],x[b],y[b])),add(b,a,distance(x[a],y[a],x[b],y[b]));
	}
	cin>>s>>end;
	spfa();
    return 0;
}
```
走之前别忘了点赞哟~
    

---

## 作者：飞雪连天 (赞：22)

从题解立逛了一圈，惊奇的发现发现居然没有人用
# Dijkstra+堆

的，所以给大家带来一篇Dijkstra+堆的题解；
关于Dijkstra+堆：
Dij的堆优化在保证了算法正确性的基础上使用一个小根堆来维护当前dis[]值最小的节点，将算法的复杂度从O(N^2)降到了O((N+M)logM)。

不同于SPFA的[O(KE)，O(NM)]，Dij将复杂度压到了很小的范围里，并且不会因为数据~~毒瘤~~而退化，但其唯一的缺点就是不能处理负权变。

以下是AC代码：


------------


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<queue>
#define M(x,y) make_pair(x,y)
const int maxn=108;
const int maxm=2008;
using namespace std;
int n,m,x[maxn],y[maxn],vis[maxn],head[maxm],a,b,num_edge=0,s,end;
double dis[maxn];
struct Edge{
	int next,to;
	double dis;
}edge[maxm];
priority_queue < pair<double,int> > q;
void addedge(int from,int to,double dis)//前向星存边
{
	num_edge++;
	edge[num_edge].next=head[from];
	edge[num_edge].to=to;
	edge[num_edge].dis=dis;
	head[from]=num_edge;
}
void SPFA()
{
	for(int i=1;i<=n;++i)
	{
		dis[i]=1e10;
		vis[i]=0;
	}
	q.push(M(0,s));
	dis[s]=0;
	vis[s]=1;
	while(!q.empty())//==while(q.size())
	{
		int u=q.top().second;//每次取出dis为最小的，大大减少了算法时间；
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].dis)
			{
				dis[v]=dis[u]+edge[i].dis;
				if(vis[v]==0)//松弛操作
				{
					vis[v]=1;
					q.push(M(-dis[v],v));//作用等同于重载运算符，因为是小根堆，所以用-dis[i]；
				}
			}
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d %d",&x[i],&y[i]);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;++i)
	{
		scanf("%d %d",&a,&b);
		double lon=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));
		addedge(a,b,lon);
		addedge(b,a,lon);//题中是双向边，否则则会WA
	}
	scanf("%d %d",&s,&end);
	SPFA();
	printf("%.2f",dis[end]);
	return 0;
}
```


------------

最后不要忘记输出的是实数；


---

## 作者：三好代表 (赞：16)

### **实话说我本来想找SPFA的题，结果我硬生生的把这道题做成了Floyd**
先来看题，我们会发现如果把他所给的变量都输入，那么会发现用Floyd的解法，输入占了main函数的一半长度。。。

题目分为两步走：

1.根据题意，我们可知是让我们算两点间直线距离，那我们就可以顺理成章的去用~~我们学过~~的——两点间距离公式！

2.就要看Floyd的了，我们知道了两点间的距离，那么我们就用Floyd找出最短的哪条路径（直接贴板子就行）

最后一定要记住，保留两位小数！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1100;
int n,m,s,t;
int a,b;
double f[N][N];
double x[N],y[N];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	f[i][j]=2020040222;//这里一定要初始化，要不然你会输出0.00
	for(int i=1;i<=n;i++)
	cin>>x[i]>>y[i];
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b;
		f[a][b]=f[b][a]=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));
	}
	cin>>s>>t;
	for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	printf("%.2lf",f[s][t]);
	return 0;
}
```

---

## 作者：wmyQAQ (赞：8)

 ## 前言
看到许多大佬都用SPFA的算法，本蒟蒻就来发一篇Floyd的题解。~~还是数据太水了QAQ~~

## 题目分析
不难看出这道题是一道最短路径的题（传送门：[P1744 采购特价商品](https://www.luogu.org/problemnew/show/P1744)），求最短路的方法也不过三种：Floyd，dij，SPFA，然后看了下数据范围，发现数据范围小，所以静态的数组（邻接矩阵）可以存的开，n也是[0,100],所以选择了比较好写的Floyd（O（n^3））。

## Floyd
### 基本思想：dp
Floyd算法其实就是一个dp，dp方程为
```
  f[i][j]=min(f[i][k]+f[k][j],f[i][j]);
```
枚举所有的点，其中k为“中转点”：如果点i到点k再到点j的距离比直接从点i到点j短，我们就选择i->k->j这条路,而不选择i->j这条路；反之，就选i->j。

Floyd可以求图中任意一点到任意另一点的最短路径，而且可以支持负路，但是时间为O（n^3），所以n偏大时不要用。（自行脑补：[Floyd](https://baike.baidu.com/item/Floyd%E7%AE%97%E6%B3%95/291990?fr=aladdin)）

### 具体过程
1.初始化：将dp数组f的初值设为一个很大的数，也就是一开始所有的点都无限远。
```
  memset(f,0x7f,sizeof(f);
```
2.输入时：
```
  f[a][b]=f[b][a]=w; //w为边权，因为是无向图所以付给[a][b]和[b][a]
```
3.核心代码
```
  for(int k=1;k<=n;k++) //中转点的循环一定在最外面
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        if(i!=j&&j!=k&&k!=i) //防止自环(本题没有用)
          f[i][j]=min(f[i][j],f[i][k]+f[k][j]); //dp
```

### 再次强调：k的循环一定在最外面！！!

上代码：
```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>

using namespace std;

double n,m,f[101][101];
int c,d,a,b;
struct zb {
    double x;
    double y;
}xb[101]; //存各个点的坐标的结构体

double ma(double x1,double y1,double x2,double y2)
{
    return sqrt(pow(max(x1,x2)-min(x1,x2),2)+pow(max(y1,y2)-min(y1,y2),2));
} //本题中算边权的式子，其实就是勾股定理:a^2+b^2=c^2可推得c=sqrt(a^2+b^2)

int main()
{
    memset(f,0x7f,sizeof(f)); //初始化很大的数
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>xb[i].x>>xb[i].y;
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a>>b;
        f[a][b]=f[b][a]=ma(xb[a].x,xb[a].y,xb[b].x,xb[b].y);
    }
    for(int k=1;k<=n;k++)
        for(int j=1;j<=n;j++)
            for(int i=1;i<=n;i++)
                if(i!=j&&j!=k&&k!=i)
                    f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
    cin>>c>>d;
    printf("%.2lf\n",f[c][d]); // 两位小数
    return 0;
}
//个人习惯
/*
5
0 0
2 0
2 2
0 2
3 1
5
1 2
1 3
1 4
2 5
3 5
1 5

*/
```

---

## 作者：WSQTCL (赞：6)

对于我这个蒟蒻来说，这道题还是用弗洛伊德简单一点
~~~~你以为我会告诉你我不想写SPFA吗（滑稽）
```
#include<bits/stdc++.h>
using namespace std;
double e[110][110],x[110],y[110]; 
int a,b,n,m,s,t;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	e[i][j]=99999;//初始化邻接矩阵
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];//读入i点坐标
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b;
		e[a][b]=e[b][a]=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));//两点之间距离公式
	}
	cin>>s>>t;
	for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                e[i][j]=min(e[i][j],e[i][k]+e[k][j]);//简单的弗洛伊德
	printf("%.2lf\n",e[s][t]);//完美输出
}
```

---

## 作者：SIXIANG32 (赞：5)

一道最短路板子题。。。。。。  
闲话少说，切入正题：


------------
本题题目大意为  
> 给你一个图，给出每个点的距离，求从 $s$ 点到 $t$ 点的最短路。  

那么问题就来了：  
Q1：如何计算距离？  
A1：平面两点坐标之间的距离为$ \sqrt{\left|x_1-x_2\right|^2+\left|y_1-y_2\right|^2}$。  

Q2：那么选择什么算法跑最短路呢？  
A1：当然是 dijkstra 啦~  

dijkstra，时间复杂度朴素为 $O(n^2)$，堆优化后为 $O(n\log_2 m)$。  

dijkstra 的工作原理是：将点 $Q$ 加入集合，然后遍历相邻的边找到边权最小的 $K$ ，最后遍历与 $K$ 相邻的边进行松弛操作，时间复杂度为 $O(n^2)$。

不难发现 dijkstra 的时间复杂度的瓶颈为查找最小值，这也没关系，我们可以用二叉堆（优先队列）来维护，最小值就直接冒上来了~ 堆优化 dijkstra 时间复杂度为 $O(n \log_2 m)$  

但是 dijkstra 只能处理正权图的情况（不过两点之间的距离能是负数？），尽管如此 dij 还是很稳定的，至于 SPFA 很容易被卡（比如菊花图，网格图等等），虽然随机数据下优秀，但是在正权图上还是推荐用 dijkstra。  

上朴实无华的蒟蒻代码~  
```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<vector>
#include<cmath>
#include<iomanip>
using namespace std;
double dis[100100];
bool vis[100100];
double x[100100],y[100100];
int n,m,s,t;
struct node{
	int to;
	double val;
	bool operator < (const node &other) const//重载运算符
    {
        return other.val < val;
    }
	node(int t,double v)
	{to=t,val=v;}
};
vector<node>gra[1010001];//存图
double juli(double x1,double y1,double x2,double y2)//计算平面两个坐标的距离
{
	return sqrt(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2));
}
void dijkstra(node s)//dij
{
	for(int p=1;p<=n;p++)
		dis[p]=123456789,vis[p]=0;//清空集合（vis），将dis（最短路结果数组）赋值成一个大数
	priority_queue<node>que;//二叉堆
	dis[s.to]=0;//起始点肯定是0
	que.push(s);//压入起始点
	while(!que.empty())
	{
		node fr=que.top();que.pop();
		if(vis[fr.to])continue;//如果就如了集合那还干啥
		vis[fr.to]=1;//进入集合
		for(int p=0;p<gra[fr.to].size();p++)//遍历与最小值相邻的边
		{
			if(gra[fr.to][p].val+dis[fr.to]<dis[gra[fr.to][p].to])//如果从最小值到这比目前的最短路小
			{//松弛
				dis[gra[fr.to][p].to]=dis[fr.to]+gra[fr.to][p].val;
				if(!vis[gra[fr.to][p].to])//如果没有进入集合
					que.push(node(gra[fr.to][p].to,dis[gra[fr.to][p].to]));//进去
			}
		}
	} 
}
int main()
{
	cin>>n;
	for(int p=1;p<=n;p++)
		cin>>x[p]>>y[p];//输入坐标
	cin>>m;
	for(int p=1,i,j;p<=m;p++)
		cin>>i>>j,gra[i].push_back(node(j,juli(x[i],y[i],x[j],y[j]))),gra[j].push_back(node(i,juli(x[i],y[i],x[j],y[j]))); //建图，这是无向图
	cin>>s>>t;//输入起点和重点
	dijkstra(node(s,0));//跑dij求最短路
	cout<<fixed<<setprecision(2)<<dis[t]<<endl;//华丽的输出
}
```

---

## 作者：Lips (赞：3)

# $\text{dijkstra}$ 模板

看到楼下的 $dalao$ 都用的某~~已死~~算法，而本蒟蒻好久没水图论的题了，就来用 $\text{dijkstra}$ 练练手。

**清晰以下题意**

有 $n$ 个点的坐标，其中有 $m$ 个点对 $(i,j)$ 之间有一条长度为 $d(i,j)$ 的双向边，求 $s\to t$ 的最短路。

$d(i,j)$ 为欧几里得距离。

**解题思路**

首先普及一下欧几里得距离，点 $i$ 到点 $j$ 的欧几里得距离为：

$$\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$$

第一步是建图，将输入给出的 $i$ 和 $j$ 之间连一条长度为 $\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$ 的双向边就好了，不过一定注意存的是 $double$ 类型。

第二步是跑最短路，以 $s$ 为起点跑一边 $\text{dijkstra}$ 的板子即可。

最后输出，保留两位小数，`printf("%.2lf\n",d[t])`。

上高清代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
#include<cmath>
using namespace std;
const int MAXN=110;
int n,m,s,t,x[MAXN],y[MAXN];
double d[MAXN];
struct edge
{
	int to;
	double cost;
	edge(int to,double cost):to(to),cost(cost){}
};
vector<edge>G[MAXN];
typedef pair<double,int> P;
double dis(int x1,int y1,int x2,int y2)
{
	return sqrt(pow(x1-x2,2)+pow(y1-y2,2));
}
void add_edge(int i,int j)
{
    G[i].push_back(edge(j,dis(x[i],y[i],x[j],y[j])));
}
void dijkstra(int s)
{
	priority_queue<P,vector<P>,greater<P> >q; 
	for(register int i=1;i<=n;i++) d[i]=1e9;
	d[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		P p=q.top();
		q.pop();
		int v=p.second;
		if(d[v]<p.first) continue;
		for(register int i=0;i<G[v].size();i++)
		{
			edge e=G[v][i];
			if(d[e.to]>d[v]+e.cost)
			{
				d[e.to]=d[v]+e.cost;
				q.push(make_pair(d[e.to],e.to));
			}
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
	scanf("%d",&m);
	while(m--)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(u,v);
		add_edge(v,u);
	}
	scanf("%d%d",&s,&t);
	dijkstra(s);
	printf("%.2lf",d[t]);
	return 0;
}
```
$$\texttt{\huge{}The End.}$$

---

## 作者：dltzr6662019 (赞：3)

**SPFA+两点之间距离公式=AC**

该题可以采用其他算法：Floyed, dijkstra，本蒟蒻擅长SPFA，

Floyed友情链接：https://www.luogu.org/blog/cdttzr666/qian-tan-floyedcpp

dijkstra友情链接：https://www.luogu.org/blog/cdttzr666/qian-tan-dijkstracpp

 _**注意：此题是无向图，不是有向图！** _  
```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#include<queue>
#include<cstring>
#include<cmath>		//头文件，不做解释
using namespace std;	//名字空间
const int MAXN=500;		
const int INF=100000000;	//常量
struct edge {		//邻接表所需结构体
	int to;			//终点
	double cost;	//边的权值
};	
struct point {		//存坐标
	int x,y;
};
point p[MAXN];		//坐标
vector<edge> G[MAXN];	//邻接表
double d[MAXN];		//记录最短路径
bool used[MAXN];	//记录是否在队列中
queue<int> q;		//队列
int n,m,s,t;
double dis(point x, point y) {			//两点之间距离公式
	return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));
}
void spfa(int s) {		//spfa大法好，模板
	fill(d+1,d+n+1,INF);	//赋初值
	memset(used,false,sizeof(used));
	d[s]=0;		//起点到起点距离为0
	q.push(s);	//起点入队列
    used[s]=true;	//标记起点入队列
	while (!q.empty()) {	//直到队列为空
		int v=q.front();	//取队列首元素
		q.pop();	//该元素出队列
		used[v]=false;	//标记
		for (int i=0; i<G[v].size(); i++) {		//循环与该点的所有边
			edge e=G[v][i];		//取这条边
			if (d[e.to]>d[v]+e.cost) {		//如果当前边的权值加上已经走过的点的最短路小于当前点的最短路（重点）
				d[e.to]=d[v]+e.cost;	//更新
				if (!used[e.to]) {		//如果该边的另一个点不在队列中
					used[e.to]=true;	//让它在队列中
					q.push(e.to);		//入队列
				}
			}
		}
	}
}
int main() {
	cin>>n;		//读入
	for (int i=1; i<=n; i++) {		//读入坐标
		cin>>p[i].x>>p[i].y;
	}
	cin>>m;		//读入
	for (int i=1; i<=m; i++) {	//开始存边
		int u,v;
		cin>>u>>v;		//读入
		G[u].push_back((edge){v,dis(p[u],p[v])});	//邻接表读入
		G[v].push_back((edge){u,dis(p[u],p[v])});
	}
	cin>>s>>t;	//读入起点和终点
	spfa(s);	//最短路
	printf("%.2f",d[t]);	//输出
	return 0;
}

```

---

## 作者：ars4me (赞：3)

说两个方法 **Floyed&Bell—Ford**


Floyed(Floyd)

一般来说求最短路都不用这个方法了 因为时间复杂度太高 于是Floyed貌似主要被用在了判联通上

不过这个题用Floyed还是可以的 跑了40ms

注意一开始初始化

    memset(map,0x7f,sizeof(map));

然后核心代码三重循环

```cpp
inline void folyed_()
{
    for(int k=1;k<=n;k++){
          for(int i=1;i<=n;i++){
               for(int j=1;j<=n;j++){
                   if(i!=j&&i!=k&&j!=k){
                       map[i][j]=min(map[i][j],map[i][k]+map[k][j]);
                   }
               }
           } 
    }
}
```
注意把k(中间值)放在最外层

全代码如下







```cpp
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
#define size 101
int a[size][3];
double map[size][size];
int n,k,x,y,m,s,e;
inline void output()
{
    printf("%.2lf\n",map[s][e]);
}
inline void folyed_()
{
    for(int k=1;k<=n;k++){
          for(int i=1;i<=n;i++){
               for(int j=1;j<=n;j++){
                   if(i!=j&&i!=k&&j!=k){
                       map[i][j]=min(map[i][j],map[i][k]+map[k][j]);
                   }
               }
           } 
    }
}
inline void input()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i][1]>>a[i][2];
    }
    cin>>m;
    memset(map,0x7f,sizeof(map));
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        map[y][x]=map[x][y]=sqrt(pow(double(a[x][1]-a[y][1]),2)+pow(double(a[x][2]-a[y][2]),2));
    }
    cin>>s>>e;
}
int main()
{
    input();
    folyed_();
    output();
}
Bellman—Ford
```
这个方法比Floyed要先进很多 时间复杂度O(点数\*边数)
但是这个题不知道哪里有问题 Ford只得了80分 跑了2ms

关键还是说这个方法...

运用了蓝白点思想 一开始蓝点都设为无穷大

dis[1]的话一开始是0

for(int i=1;i<=m;i++){

        dis[i]=0x7fffffff/3;

}
然后核心代码

```cpp
inline void ford_()
{
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(dis[f[j][1]]+w[j]<dis[f[j][2]]){
                dis[f[j][2]]=dis[f[j][1]]+w[j];
            }
            if(dis[f[j][2]]+w[j]<dis[f[j][1]]){
                dis[f[j][1]]=dis[f[j][2]]+w[j];
            }
        }
    }
}
```
其实就是用白点修改蓝点

全代码如下







```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
#define size 1001
double a[101][3],dis[size],w[size];
int n,m,x,y,f[size][3],s,t;
inline void output()
{
    printf("%.2f",dis[t]);
}
inline void ford_()
{
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(dis[f[j][1]]+w[j]<dis[f[j][2]]){
                dis[f[j][2]]=dis[f[j][1]]+w[j];
            }
            if(dis[f[j][2]]+w[j]<dis[f[j][1]]){
                dis[f[j][1]]=dis[f[j][2]]+w[j];
            }
        }
    }
}
inline void input()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i][1]>>a[i][2];
    }
    cin>>m;
    for(int i=1;i<=m;i++){
        dis[i]=0x7fffffff/3;
        f[i][1]=0x7fffffff/3;
        f[i][2]=0x7fffffff/3;
    }
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        f[i][1]=x;
        f[i][2]=y;
        w[i]=sqrt(pow(a[x][1]-a[y][1],2)+pow(a[x][2]-a[y][2],2));
    }
    cin>>s>>t;
    dis[s]=0;
}
int main()
{
    input();
    ford_();
    output();
}
```
两种方法参考书上都有记录
一起学习


//COYG

---

## 作者：_pwl (赞：2)

# 分析：
这个题通过简单的分析题意，可以看出，显然是一道
## SPFA的题（标签里的。。。。。。）
~~## But 本人太弱。。。。。。~~

~~NO Problem，无伤大雅~~

### 我们用Floyd来代替一下

这道题求任意两点之间的距离，众所周知，Floyd可以求任意两点的最短路，而且包括负边权，~~很强大~~。

-----------------------------------

## 先补充一点预备知识:

两点间距离公式：对于平面上两点（x1,y1）,（x2,y2）他们的直线距离为

$$
\sqrt {(x1-x2)^2+(y1-y2)^2}
$$


------------

# 代码
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int a[101][3];
double f[101][101]	//f[i][j]表示i点到j点的最短路;
int n,i,j,k,x,y,m,s,e;
int main(){
	cin>>n;
	for(i=1;i<=n;i++) cin>>a[i][1]>>a[i][2];
	cin>>m; 
	memset(f,0x7f,sizeof(f));  //在没有已知连接不连接的情况下，对于有权值的图
								//我们全部预处理成无限大 
	for(i=1;i<=m;i++){         //对于有连接的，我们用两点间距离公式更新距离 
		cin>>x>>y;	//第二次输入有连接的 
		f[y][x]=f[x][y]=sqrt(pow(double(a[x][1]-a[y][1]),2)+pow(double(a[x][2]-a[y][2]),2));
	}
	cin>>s>>e;	//原点和目标点 
	//Floyd关键部分 
	for(k=1;k<=n;k++){
		for(i=1;i<=n;i++){
			for(j=1;j<=n;j++){
				if((i!=j)&&(i!=k)&&(j!=k)&&(f[i][k]+f[k][j]<f[i][j])) f[i][j]=f[i][k]+f[k][j];
				//如果有一个点k，使原先找到的最短路f[i][j]更短，则更新 
			}
		}
	}
	printf("%.2lf\n",f[s][e]);    //输出要求的 
	return 0;
}
```
### **但是**我发现有一个更好的做法
#### 优化核心思想
当原点和目标点之间有连线的时候，我们用两点之间距离公式求出来的距离就是最短路。我们可以加一个特判，即f[i][j]不是无穷大时，输出，结束。这样就可以少跑一边Floyd，对于某些数据，可以稍快一点。
### 代码请读者自行思考

---

## 作者：yagyagyag (赞：2)

题解怎么全是Dji，我还没学过，都没看懂，本蒟蒻用搜索

1.看见标签是：队列，一开始就用BFS来锻炼一下，结果写了80行还只有60分，而且一个还超时。。。

2.算了，还是用DFS吧，46行AC

```cpp
#include<bits/stdc++.h>
using namespace std;
const int L=105;
int n,m,s,t,x_,y_,begin,end;
double ans=2e9;
int x[L],y[L],array[L][L];
bool used[L];
double js(int a,int b,int c,int d)
{
	return sqrt( (a-c) * (a-c) + (b-d) * (b-d) );
}
void dfs(int start,double sum)
{
	if (start==end){
		ans=ans<sum?ans:sum;
		return;
	}
	if (sum>ans) return;//剪枝优化 
	for (int i=1;i<=n;i++){
		if (!used[i]&&array[i][start]){
			used[i]=1;
			dfs(i,sum+js(x[start],y[start],x[i],y[i]));
			used[i]=0;
		}
	}
}
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>x_>>y_;
		x[i]=x_;
		y[i]=y_;
	}
	cin>>m;
	for (int i=1;i<=m;i++){
		cin>>s>>t;
		array[s][t]=1;
		array[t][s]=1;
	}
	cin>>begin>>end;
	used[begin]=1;
	dfs(begin,0);
	printf("%.2lf",ans);
	return 0;
}
```
浙江某教练：不到万不得已，用DFS，别用BFS



---

## 作者：xzjds (赞：2)

这道题要注意是双向边，不然四十分。。。还有就是要注意取绝对值，这样就可以通过勾股定理求出两点间的距离（不取貌似也可以，因为平方会将负数消掉）然后就可以直接spfa。这里我打了领接表，没看数据范围，所以内存开的有点大。下面是代码。这题目比较有良心，数据保证了两点能走到。还有就是要注意精度问题a，b数组必须开double，不然爆炸。（其他细节看代码）
```cpp
#include<bits/stdc++.h>
using namespace std;
int la[500005],ne[500005],lnk[10005],q[500005*2],tot=0,n,m,s,t,x,y;
int d[200000];
bool v[500005];
double co[500005],dis[10005],z,a[1005],b[1005];
long long sqr(long long x)
{
	return x*x;
}
int add(int x,int y,double z)
{
	tot++;ne[tot]=y;la[tot]=lnk[x];lnk[x]=tot;co[tot]=z;
}
void spfa(int s)
{
	int head,tail,now;
	head=0;tail=1;
	for (int i=1;i<=10005;i++)
	dis[i]=2000000000.0;
	memset(v,sizeof(v),false);
	memset(d,sizeof(d),0);
	d[tail]=s;v[s]=true;dis[s]=0;
	while (head<tail)
	{
		head++;
		now=d[head];
		for (int k=lnk[now];k;k=la[k])
		if (dis[ne[k]]>dis[now]+co[k])
		{
			dis[ne[k]]=dis[now]+co[k];
			if (v[ne[k]]==false)
			{
				v[ne[k]]=true;
				tail++;
				d[tail]=ne[k];
			}
		}
		v[now]=false;
	}
	return;
}
int read()
{
	int x=0;char c;bool f;
	f=true;
	c=getchar();
	if (c=='-') f=false;
	while (c<'0'||c>'9')c=getchar();
	while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	if (f==false) x=x*-1;
	return x;
}
int main()
{
	n=read();
	for (int i=1;i<=n;i++)
	scanf("%lf%lf",&a[i],&b[i]);
	m=read();
	for (int i=1;i<=m;i++)
	{
	scanf("%d%d",&x,&y);
	z=sqrt(sqr(abs(a[x]-a[y]))+sqr(abs(b[x]-b[y])));
	add(x,y,z);
	add(y,x,z);
    }
	s=read();t=read();
	spfa(s);
	//if (dis[t]>2000000000) {printf("-1");return 0;}
	printf("%.2lf",dis[t]);
	return 0;
}
```

---

## 作者：bingliang (赞：2)

就用dijkstra就好了，预处理出道路间的距离，建出图暴力跑最短路就好了，我用得是dijkstra


也没啥好说明的，会写dijkstra就行了，可以说是比较基础的板子题。要在有的话就是要注意数据的要求。

因为各个点在平面内，所以，要用勾股定理算出两点间的距离， 及a^2+b^2=c^2

然后用 dis【i】表示s到i点的（以知）最短距离。我话不多说具体还请参照dijkstra模板

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,t1,t2,mi;
double a[100],b[100],c[100],e[100][100],dis[1000];
int s,t,book[100],u;
const int inf=99999999;
void input()
{
        cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i]>>b[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            e[i][j]=inf;
        }
    }
    cin>>m;
    for(int i=1;i<=m;i++)
{
    cin>>t1>>t2;
    e[t2][t1]=e[t1][t2]=sqrt((a[t1]-a[t2])*(a[t1]-a[t2])+(b[t1]-b[t2])*(b[t1]-b[t2]));
}
cin>>s>>t;
}
void start()
{
    for(int i=1;i<=n;i++)
    {
        dis[i]=e[s][i];
    }
    for(int i=1;i<=n;i++)
    {
        book[i]=0;
    }
    book[s]=1;
}
void dijkstra()
{
 start();
for(int i=1;i<=n-1;i++)
{
    mi=inf;
    for(int j=1;j<=n;j++)
    {
    if(book[j]==0&&dis[j]<mi)    
    {
        mi=dis[j];
        u=j;
    }
    }
    book[u]=1;
    for(int v=1;v<=n;v++)
    {
        if(e[u][v]<inf)
        {
            if(dis[v]>dis[u]+e[u][v])
            {
                dis[v]=dis[u]+e[u][v];
            }
        }
    }
    }    
}
int main()
{
    input();
     dijkstra();
     printf("%.2lf\n",dis[t]);
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：2)

#采购特价产品

分析：图论+最短路

随便说说：”标签与题解都是SPFA

所以我写了dijkstra

发现普通dij会TLE一个点后

需要heap(堆)优化

分析·解：

该题的实质其实就是小数的最短路

并且变态的题目是给点的坐标

算边的长度还要自己算

计算两点间距离公式（根据勾股定理）：sqrt(abs(x1-x2)²+abs(y1-y2)²);

↑正是该题的烦人之处

并且很多小数

需要注意小数的处理

所以我认为难度：普及+/提高-   最短路+技巧

我选择：dij+heap

如果不会dij+heap的话，那…，那……，那………

你怎么不问问神奇海螺呢

【正经】

我采用STl里的优先队列做heap

详细解释见代码中注解

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<iostream>
#define I 2147483647
#define S 101                    //方便代码书写 若大家被这玩意绕晕 概不负责【←划】请见谅！ 
#define X x[0]
#define Y y[0]
#define A abs
#define D double
using namespace std;
struct heap   //构建堆的形式 
{
    D val;int key;   //val是距离 key是点的编号 
    bool operator<(const heap& rhs)
    const
    {
        return val>rhs.val;
    }    
}k;
priority_queue<heap>l;  //构建堆（优先队列） 
int n,m,x[S],y[S],i,s,t,j;
bool f[S];   //标记数组 
D r[S][S],d[S];  //邻接矩阵存边与大家熟悉的dis数组 
D p(int q)   //该用户太懒了，连算一个数的平方都要搞个函数 
{
    return q*q*1.0;
}
void TiJKstra()   //迪杰斯特拉...至于这个TiJK，请见用户Tjkfred 
{
    for (i=1;i<=n;i++)d[i]=I;d[s]=0;  //初始化d数组 
    l.push((heap){0,s});  //先存放起点进堆 
    while (l.size())  //dij主体 
    {
        k=l.top();l.pop();j=k.key;  //取堆顶 
        if (f[j])continue;f[j]=1;  //标记 
        for (i=1;i<=n;i++)   //dij核心 
            if (r[j][i] && d[j]+r[j][i]<d[i])  //如果存在连接边 并且可以被更新 
            {
                d[i]=d[j]+r[j][i];  //更新d 
                l.push((heap){d[i],i});  //推进堆里 
            }
    }
}
int main()
{
    cin>>n;  //奇妙的读入 （一点都不奇妙好吗！） 
    for (i=1;i<=n;i++)cin>>x[i]>>y[i];
    cin>>m;
    for (i=1;i<=m;i++)
    {
        cin>>X>>Y;
        r[X][Y]=r[Y][X]=sqrt(p(A(x[X]-x[Y]))+p(A(y[X]-y[Y])));  //计算两点间的距离 
    }
    cin>>s>>t;
    TiJKstra();   //执行dij 
    printf("%.2lf",d[t]);  //华丽的输出 
    return 0;
}
```

---

## 作者：cxy004 (赞：2)

首先把有通路的距离算出来

再用SPFA算法

注意初始化除了s都要为max

max要足够大【被坑了

```cpp
#include<cstdio>
#include<cmath>
#include<queue>
#define qf q.front()
using namespace std;

int n,m,map[101][2],s,h;
double t[101][101],f[101];
queue<int>q;
//解释一下，map存点的位置，t存两点间的距离，f存从起点到各点的最短距离
//s为起点，h为终点，q是队列
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) {scanf("%d%d",&map[i][0],&map[i][1]);f[i]=0xfffff;}
    scanf("%d",&m);
    for(int x,y;m--;)  //算距离 
    {scanf("%d%d",&x,&y);t[x][y]=t[y][x]=sqrt((map[x][0]-map[y][0])*(map[x][0]-map[y][0])+(map[x][1]-map[y][1])*(map[x][1]-map[y][1]));}
    scanf("%d%d",&s,&h);f[s]=0;  //以下为SPFA算法
    for(q.push(s);!q.empty();q.pop()) for(int i=1;i<=n;++i) if((t[qf][i])&&((f[qf]+t[qf][i])<f[i])) {f[i]=f[qf]+t[qf][i];q.push(i);}
    printf("%.2f",f[h]);
    return 0;
}
```

---

## 作者：花千树 (赞：1)

怎么都是SPFA的题解啊，我来发一波dijkstra的题解吧

虽然标签是SPFA，但是dij可以过，甚至Floyd都可以，我还是给大家普及dij算法，虽然是模板题，不过还是需要注意两个点：1，double浮点数不能忘，两点间距离公式要记牢；2，双向存边，不要弄错了

还有就是，double类型的最大值memset时赋127就行了

注意了这些，基本上就是模板了

code：

```
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>//一发头文件
using namespace std;
typedef long long ll;
template<class AC>void r(AC &x){
    x=0;
    int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}//快读
int n,m,s,c,g[100005]/*记录读入的横坐标*/,h[100005]/*记录读入的纵坐标*/,v[1000005]/*dijkstra标准vis数组，红白点思想*/;
vector<int>a[100005];//存边
vector<double>b[100005];//存边的权值（距离）
double f[1000005];//记录起点到所有点的距离的数组
int main(){//主程序开始
	r(n);//读入
	for(int i=1;i<=n;i++)r(g[i]),r(h[i]);//读入
	r(m);//读入
	for(int i=1;i<=m;i++){
		int x,y;
		r(x);r(y);//读入
		a[x].push_back(y);//存边
		b[x].push_back(sqrt(pow(g[x]-g[y],2)+pow(h[x]-h[y],2)));//两点间距离公式，求距离
		a[y].push_back(x);//如上，反向存边
		b[y].push_back(sqrt(pow(g[x]-g[y],2)+pow(h[x]-h[y],2)));//如上，反向存
	}
	r(s);r(c);//读入起点终点
	memset(f,127,sizeof(f));//memset
	double tot=f[0];//记录double的最大值（因为memset127太大了，直接用变量存）
	f[s]=0;//起点为0
	for(int i=1;i<=n;i++){//dij正式开始！
		int id=-1;
		double sum=tot;
		for(int j=1;j<=n;j++)if(f[j]<sum&&!v[j])id=j,sum=f[j];//找到最近点
		if(id==-1)break;//如果没有，退出
		v[id]=1;//标记，下次不可以用这个点了，这个点也被标记为不可修改
		for(int j=0;j<a[id].size();j++){//枚举最近点联通的点
			if(!v[a[id][j]]&&f[a[id][j]]>f[id]+b[id][j]){//如果该点没有被标记，且可以更新最小值
				f[a[id][j]]=f[id]+b[id][j];//更新
			}
		}
	}
	printf("%.2lf\n",f[c]);//输出到终点的最小值（注意，保留两位小数）
    return 0;
}
```

管理员大大给过哈QWQ

---

## 作者：一碗粥 (赞：1)

图论算法，不是很难，先算出各种距离，a[i,j]代表从i到j的距离，先存在一个real数组中（f），接着a[j,i]:=a[i,j]这个应该很好理解，也是从i到j的距离当然也是从j到i的距离啦，这样写也很方便计算，随后使用弗洛伊德算法：三层循环。

第一层找中间点，第二、三层循环起点终点（反之）i，j。

代码如下

```delphi
var i,j,k,l,m,n,sum,s,e,x,y:longint;
    a:array[1..100,1..2]of longint;
    f:array[1..100,1..100]of real;
begin
  readln(n);
  for i:=1 to n do
    readln(a[i,1],a[i,2]);
  readln(m);
  fillchar(f,sizeof(f),$7f);
  for i:=1 to m do
  begin
    readln(x,y);
    f[x,y]:=sqrt(sqr(a[x,1]-a[y,1])+sqr(a[x,2]-a[y,2]));
    f[y,x]:=f[x,y];
  end;
  readln(s,e);
  for i:=1 to n do
  begin
    for j:=1 to n do
    begin
      for k:=1 to n do
      begin
        if(i<>j)and(j<>k)and(i<>k)and(f[j,i]+f[i,k]<f[j,k])
        then f[j,k]:=f[j,i]+f[i,k];
      end;
    end;
  end;
  writeln(f[s,e]:0:2);
end.
```

---

## 作者：bestzzy (赞：0)

发现各位大佬都用spfa，本蒟蒻发一波dij

```cpp
var
 a:array[0..1000,0..1000]of real;
 low,x,y:array[0..1000]of real;
 f:array[0..1000]of boolean;
 i,j,n,m,s,num,t,xx,yy:longint;
 min:real;
 ans:int64;
begin
 fillchar(f,sizeof(f),true);
 readln(n);
 for i:=1 to n do
  readln(x[i],y[i]);
 readln(m);
 for i:=1 to m do
  begin
   read(xx,yy);
   a[xx,yy]:=sqrt(sqr(x[xx]-x[yy])+sqr(y[xx]-y[yy]));//勾股定理求距离
   a[yy,xx]:=a[xx,yy];//无向图
  end;
  read(s,t);
 f[s]:=false;//起点
 for i:=1 to n do
  for j:=1 to n do
   if a[i,j]=0 then a[i,j]:=maxlongint;//没有路
 for i:=1 to n do
  low[i]:=a[s,i];//预处理起点到每个点的距离
 for i:=1 to n do
 begin
  min:=maxlongint;
  for j:=1 to n do//找最近的点
   if (f[j])and(low[j]<min) then
    begin
     num:=j;
     min:=low[j];
    end;
  if num<>0 then
  begin
   f[num]:=false;
   for j:=1 to n do//更新距离
    if (f[j])and(a[num,j]<>maxlongint)and(low[j]>a[num,j]+low[num]) then
    low[j]:=low[num]+a[num,j];
  end;
 end;
 write(low[t]:0:2);//输出到终点距离
end.
```

---

## 作者：ljc20020730 (赞：0)

这道题目应为是单向的还是双向的引发一系列混战

[混战地址](https://www.luogu.org/discuss/show?postid=386)

我个人认为，题目叙说下应该是双向的。

为什么呢？

因为一条街总不可能只能向一个方向去的吧？总可以回来

故我写了个无向图的算法，就过了……

【当然这是题外话】

题目叙述不够严谨。

大概就是这样的意思：

平面上有n个点（n<=100），每个点的坐标均在-10000~10000之间。其中的一些点之间有连线。若有连线，则表示可从一个点到达另一个点，即两点间有通路，通路的距离为两点间的直线距离。现在的任务是找出从一点到另一点之间的最短路径。

注意到N^3=10^6没有到达一亿，所以可以用O(n^3)的算法，即图论中的弗洛伊德算法

比较简单：

```cpp
var n,m,i,j,k,x,y,s,t:longint;
    g:array[1..1000,1..2]of longint;
    f:array[1..100,1..100]of double;
begin
 readln(n);
 for i:=1 to n do readln(g[i,1],g[i,2]);
 readln(m);
 fillchar(f,sizeof(f),$7f);
 for i:=1 to m do begin
  readln(x,y);
  f[x,y]:=sqrt(sqr(g[x,1]-g[y,1])+sqr(g[x,2]-g[y,2]));//算下直线距离
  f[y,x]:=f[x,y];//如果删去这条就是有向图了
 end;
 for k:=1 to n do
  for i:=1 to n do
   for j:=1 to n do
    if (i<>j)and(j<>k)and(k<>i)and(f[i,j]>f[i,k]+f[k,j])
    then f[i,j]:=f[i,k]+f[k,j];
  readln(s,t);
  writeln(f[s,t]:0:2);
end.
```
补充一下：在pascal的math库里有这个东西
hypot
原型：function hypot(x:float;y:float):float

功能：返回直角三角形中较长边的长度，也就是sqrt(sqr(x)+sqr(y))

也就是hypot(3,4)=5.000000000000000000


---


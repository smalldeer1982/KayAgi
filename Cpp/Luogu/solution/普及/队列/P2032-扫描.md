# 扫描

## 题目描述

有一个 $1 \times n$ 的矩阵，有 $n$ 个整数。

现在给你一个可以盖住连续 $k$ 个数的木板。

一开始木板盖住了矩阵的第 $1 \sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。

每次移动前输出被覆盖住的数字中最大的数是多少。

## 说明/提示

对于 $20\%$ 的数据，$1 \leq k \leq n \leq 10^3$。

对于 $50\%$ 的数据，$1 \leq k \leq n \leq 10^4$。

对于 $100\%$ 的数据，$1 \leq k \leq n \leq 2 \times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。 

## 样例 #1

### 输入

```
5 3
1 5 3 4 2
```

### 输出

```
5
5
4
```

# 题解

## 作者：Berlin_Jacor (赞：286)

STL大法好（雾

就用队列就好了，一定记得要优先考虑数据结构

（挑战最短代码QAQ，然后我输了

每次判断队头是否符合要求，将不符合要求的删除掉
```
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,k;
struct node{int v,id;}a[N];
deque<node> qmin,qmax;
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)cin>>a[i].v,a[i].id=i;
    for(int i=1;i<=n;i++)
    {
        while(!qmax.empty()&&qmax.back().v<=a[i].v)qmax.pop_back();
        qmax.push_back(a[i]);
        if(qmax.front().id==i-k)qmax.pop_front();
        if(i>=k)cout<<qmax.front().v<<endl;
    }
    return 0;
}
```

这题其实可以用来练习线段树，但我不会啊，我太菜了，，，

另外推荐P1886和P1440，是三倍经验哦

打题解不易，留个Zan再走吧

**虽然自己写代码很慢，收获的却是自己**

---

## 作者：Manjusaka丶梦寒 (赞：46)

为啥不用STL，多方便。

定义一个大根堆，里边放一对数，这个数的大小和位置。

我们对于每次查询，判断首元素的位置是否在[i-k+1,i]这个范围内，不符合的话就弹出来。

代码好写。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;
#define mp make_pair
typedef pair <int,int> pill ; 
priority_queue <pill,vector<pill>,less<pill> > Q;
int n,m,k,a[2000006];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		Q.push(mp(a[i],i)); 
		if(i>=k)
		{
			while(Q.top().second<=i-k)Q.pop();
			printf("%d\n",Q.top().first);
		}
	}
}
```

---

## 作者：EarthGiao (赞：31)

## 【思路】
单调队列     
手写单调队列有点双指针的意思     
从第一个开始枚举      
如果队首的数超出了k区间的距离限制就将队尾弹出      
直到队首符合在k区间内的要求     
如果队尾的值比这个要插入的值还小     
那这个队尾是不可能被输出的     
**他比我小还比我强！这让我怎么活！所以弹出我吧！**     

处理完成之后      
每一个k区间需要输出的值就是他的队首      
因为这是一个递减的区间      


## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>

using namespace std;
const int Max = 2000006;
int a[Max];
int q[Max];

int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(register int i = 1;i <= n;++ i)
		scanf("%d",&a[i]);
	int t = 0,w = 1;
	for(register int i = 1;i <= n;++ i)
	{
		while(t <= w && q[t] + k <= i)t ++;
		while(t <= w && a[q[w]] < a[i])w--;
		q[++ w] = i;
		if(i >= k)
			cout << a[q[t]] << endl;
	}
	return 0;
}
```

---

## 作者：轩槿 (赞：20)

/\*这是一道裸的单调队列，，，，看不懂底下在干嘛，，，，，可能是我太弱了，，，，

一共n个数，，有一块m的板，，每覆盖一次找最大

如果暴力，，绝对超时=\_=||
所以，就有了单调队列。。。。。

由样例得

1 5 3 4 2

每次覆盖3

第一次

1 5 3
最大5

第二次

5 3 4
最大5

第三次

3 4 2
最大4

因为5不再覆盖，就删掉。。。

处理自己看单调队列。。

\*/
```cpp
#include<algorithm>
#include <iostream>
#include <stdlib.h>
#include <string.h>
#include  <stdio.h>
#include   <math.h>
#include   <time.h>
#include   <vector>
#include   <bitset>
#include    <queue>
#include      <set>
#include      <map>
 using namespace std;
int n,ans=0,k;
int a[2000005],f[20000005],h=1,t=1;//数据范围应该是2*10^6，，因为这个，，我一直80，，，
//f记录下标，，h为头，，t为尾
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    f[1]=1;
    for(int i=1;i<=n;i++){        
        if(f[h]<=i-k)h++;//如果f[h]不在里面，就用下一个最大值
        while(t>=h&&a[f[t]]<=a[i])t--;//选择此数位置
        f[++t]=i;
        if(i>=k)printf("%d\n",a[f[h]]);
    }
return 0;
}

```

---

## 作者：星之海 (赞：12)

都是写一些STL和单调队列正解的大佬，tql

还是线段树比较好打

然后就没有然后了……

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 2000005;
int a[N],c[N*4],n,m;
inline int read()//手写快读卡个常
{
	int x=0,w=1; char c=getchar();
	while (c<'0' || c>'9') {if (c=='-') w=-1; c=getchar();}
	while (c<='9' && c>='0') {x=(x<<3)+(x<<1)+c-'0'; c=getchar();}
	return w*x;
}
void pushup(int o)//上传操作
{
	c[o]=max(c[o<<1],c[o<<1|1]);
}
void build(int o,int l,int r)//建树
{
	if (l==r) {c[o]=a[l]; return ;}
	int mid=(l+r)>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	pushup(o);
}
int query(int o,int l,int r,int ql,int qr)//查询
{
	if (ql<=l&&qr>=r) return c[o];
	int mid=(l+r)>>1,ans=0;
	if (ql<=mid) ans=max(ans,query(o<<1,l,mid,ql,qr));
	if (qr>mid) ans=max(ans,query(o<<1|1,mid+1,r,ql,qr));
	return ans;
}
int main()
{
	n=read(); m=read();
	for (int i=1;i<=n;++i)
		a[i]=read();
	build(1,1,n);
	for (int i=1;i<=n-m+1;++i)
		printf("%d\n",query(1,1,n,i,i+m-1));
	return 0;
}
```
然后无脑线段树就结束了……

数据结构就是好

---

## 作者：最喜欢saber了 (赞：11)

[题目传送门](https://www.luogu.org/problemnew/show/P2032)

这个题实际上和滑动窗口那道题是一毛一样的

其实这道题看上去很容易想到用线段树或ST表做，但它们都是O(nlogn)级别的，而在本题的数据下不会太高效，于是我们来苟一个优化：

本题中有一个重要的信息：

##  所有区间都是等长且连续的 。

那么对于“相邻”的两个区间(l,r)与(l+1,r+1)有些不错的性质：

序列a：a[l],a[l+1],a[l+2]......a[r-1],a[r],a[r+1]。

以最大值为例：在(l,r)中：

max{a[l],a[l+1],a[l+2]...a[r-1],a[r]}
=max{a[l],max{a[l+1],a[l+2]...a[r-1],a[r]}}

max{a[l+1],a[l+2]...a[r-1],a[r],a[r+1]}=max{max{a[l+1],a[l+2]......a[r-1],a[r]
},a[r+1]}。

这两个方程有相同的部分max{a[l+1],a[l+2]...a[r-1],a[r]}，所以区间(l,r)中的最大值落在(l+1,r)的概率很大。那么，在求(l+1,r+1)的最值时，我们完全没必要再扫描一次。只有当上一次的最值落在a[l]上时才需重新扫描，从而达到优化的目的。

然后我们再想一个问题以最大值为例，对任意的l<=i<=j<=r，如果a[i]<a[j]，那么在区间向右移的过程中，最大值究其一生也不会落到a[i]上，因为a[i]比a[j]先失效，能用a[i]一定可以a[j],所以我们不再需要a[i]了，这个性质与[单调队列](https://blog.csdn.net/er111er/article/details/78344161)很吻合。

当我们将区间从(l,r)移动到(l+1,r+1)时，若队首元素不在(l+1,r+1)区间当中，则删除它，将a[r+1]插入单调队列中，这样处理后的队首元素便是(l+1,r+1)区间内的最大值。

时间复杂度为O(n).

欢迎各位DALAO纠错，我太弱了。

代码

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int maxa = 1e6+5;
int a[maxa],q[maxa],num[maxa]={},fx[maxa],fn[maxa],n,head,i,k,tail;
int main(){
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    head=1,tail=0;
    for(i=1;i<=n;i++){
        while(num[head]<i-k+1&&head<=tail)head++;
        while(a[i]>=q[tail]&&head<=tail)tail--;
        num[++tail]=i;
        q[tail]=a[i];
        fx[i]=q[head];
    }
    for(i=k;i<=n;i++){
        printf("%d ",fx[i]);printf("\n");
    }
    return 0;
}
```

---

## 作者：STOcjyORZ (赞：9)

## 简洁代码+核心讲解
 1.**首先先看间接代码**.代码中是单调队列的核心部分,很短就可以把这个裸题A了.
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2100000],dui[2100000]={0};//dui数组来存队列
int h=1,t=0;//head和tail:首和尾的英文名
int n,m;
int main()
{cin>>n>>m;
for(int i=1;i<=n;i++)
{
	scanf("%d",&a[i]);
	if(i-dui[h]>=m)h++;//如果队首已经过期了,也就是当前队首不在m个数这个窗口范围内,那么从队首出队;
	while(h<=t&&a[i]>=a[dui[t]])t--;//维护一个单增的队列
	dui[++t]=i;//存下标
	if(i>=m)printf("%d\n",a[dui[h]]);//如果当前位置在m及以后才能输出
}
return 0;
}
```
2. **接下来请看几处其他题解没有讲到的细节理解(核心)**

- i-dui[h]>=m处要取等号,等号的意思就是队首元素刚好在前m位,由于接下来要把新元素加到队列中来,所以整个长度就超了m位了,所以就算刚好在前m位上你也要狠心把他删去,为了新元素至少有地方放;
- dui[++t]而不是dui[t++],自加在前和自加在后是有区别的,滥用小心出错.
- 如果当前位置在m及以后才能输出,这样一来就控制了输出次数,就不用再循环输出了;

---

## 作者：陈晋衍 (赞：7)

裸的单调队列

至于单调队列是什么，简而言之，就是一种比较特殊的队列，它的元素不超过$k$个，且元素在其中单调递增/递减。

比如这道题求最大值，在插入某个元素之前，先检查队列尾部的元素是否比它小，如果小，那么把队尾删除。
再检查队头，是否还在那个区间内。如果在区间外部，删除。
最后才是插入这个元素。

按这种算法，就可以维护队列的单调性。

这里给大家带来一个常见的写法：双向队列（$deque$）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<deque>//双向队列
using namespace std;
deque<int> dq;//双向队列的使用
int n,k,a[2000001];
void into(int x)//插入函数，注意，x是位置，dq里存的都是位置。
{
	while(!dq.empty()&&a[x]>a[dq.back()]){//检查队尾是否大于它
		dq.pop_back();//是，就pop
	}
	if(!dq.empty()&&x-dq.front()>=k){//检查对头是否在区间外
		dq.pop_front();//是，就pop  
	}
	dq.push_back(x);//插入这个数
}
int main()
{
	cin>>n>>k;//读入不解释
	for(int i=1;i<=n;i++)
	{
    	//边读边输出
		cin>>a[i];
		into(i);//把位置入队
		if(i>=k)cout<<a[dq.front()]<<endl;//是一个完整的区间就输出
	}
	return 0;//结束
}
```

---

## 作者：like1 (赞：6)

其实这题非常简单，与其说这是一道单调队列模板的题，还不如说优先队列的题。

本题只需要定义一个二维的优先队列就可以了 ，priority_queue< pair<int,int> >q; 它的的第一维存当前最大数的值，第二维存当前最大值的下标。

在遍历每一个数时，我们只需要把当前最大值的下标与i-k比较就行了，若当前最大值的下标小于等于i-k，说明当前的最大值已经在所要求的区间范围之外了，所以弹去即可；

另外要注意的细节也不多，就是在下标比较时注意不要出错了就行，下面放上代码
```
#include <cstdio>
#include <iostream>
#include <queue>
using namespace std;

const int N=2e6+6;
int a[N];
int n,k;
priority_queue< pair<int,int> >q;

int main( )
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		q.push(make_pair(a[i],i));
		if(i>=k)
		{
			while(q.top().second<=i-k) q.pop();
			printf("%d\n",q.top().first);
		}
	}
	return 0;
}
```
另外既然本题的标签是单调队列，所以下面我也放上单调队列的代码，供大家比较和参考
```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int N=2e6+6;
int a[N],q[N],num[N],f[N];
int n,head=1,tail=0,k;

int main( )
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		while(num[head]<i-k+1&&head<=tail) head++;
		while(a[i]>=q[tail]&&head<=tail) tail--;
		num[++tail]=i;
		q[tail]=a[i];
		f[i]=q[head];
	}
	for(int i=k;i<=n;i++)
	printf("%d\n",f[i]);
	return 0;
}
```
最后祝大家CSP2019rp++,score++。


---

## 作者：Waddles (赞：4)

~~这个题的treap题解来了~~

~~其实就是板子题中的几个操作，不知道为什么没有题解拿平衡树写~~

先将1-k每个数插入，然后移动一次就把左端的点删除，右端点插入，查询第k小的元素

然后就没了

code:

```
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
template<class Read>void in(Read &x){
    x=0;
    int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}
int n,k,top,root,a[2000005],f[2000005],w[2000005],val[2000005],s[2000005][2];
inline void pushup(int x){
    f[x]=f[s[x][0]]+f[s[x][1]]+1;
}
void rotate(int &x,int c){//旋转
    int id=s[x][c];
    s[x][c]=s[id][c^1];
    s[id][c^1]=x;
    pushup(x);
    pushup(id);
    x=id;
}
void ins(int &x,int c){//插入
    if(x==0){
        x=++top;
        val[x]=rand();
        w[x]=c;
        f[x]=1;
        return;
    }
    f[x]++;
    if(c<=w[x]){
        ins(s[x][0],c);
        if(val[s[x][0]]<val[x])rotate(x,0);
    }
    else{
        ins(s[x][1],c);
        if(val[s[x][1]]<val[x])rotate(x,1);
    }
}
void del(int &x,int c){//删除
    if(w[x]==c){
        if(s[x][0]*s[x][1]==0){
            x=s[x][0]+s[x][1];
            return;
        }
        if(val[s[x][0]]>val[s[x][1]]){
            rotate(x,1);
            del(s[x][0],c);
        }
        else{
            rotate(x,0);
            del(s[x][1],c);
        }
        pushup(x);
        return;
    }
    if(c<w[x])del(s[x][0],c);
    else del(s[x][1],c);
    pushup(x);
}
int query(int x,int c){//查询第c小
    if(f[s[x][0]]==c-1)return w[x];
    if(c<=f[s[x][0]])return query(s[x][0],c);
    else return query(s[x][1],c-f[s[x][0]]-1);
}
int main(){
    srand(0);
	in(n);in(k);
    for(int i=1;i<=n;i++)in(a[i]);
    for(int i=1;i<=k;i++)ins(root,a[i]);
    printf("%d\n",query(root,k));
    for(int i=k+1;i<=n;i++){
        del(root,a[i-k]);
        ins(root,a[i]);
        printf("%d\n",query(root,k));
    }
	return 0;
}
```

---

## 作者：18811162081lyh (赞：3)

```
/*此题是单调队列裸题
求最大值要保证队列单调非增，且队列覆盖长度不超过k
因此需要记录队首元素的位置，可以用一个变量来记录
本题的代码使用了两个数组，a记录元素，q用来模拟队列，
注意q中存放的不是元素大小而是元素位置 
*/ 
#include<cstdio>
#define MAXN 2000005
using namespace std;
int n, k, a[MAXN], q[MAXN], head = 1, tail;
//head指向队首，tail指向队尾，注意这里的初始化
int main()
{
	scanf("%d%d%d", &n, &k, &a[1]);
	q[++tail] = 1; //a元素入队，注意这里队列中存的是元素下标！
	for(int i = 2; i <= n; i++)
	{
		scanf("%d", &a[i]);
		while(head <= tail && a[i] > a[q[tail]]) tail--; //弹出队尾元素直到队列递减
		q[++tail] = i;
		if(i - q[head] == k) head++;       //队列长度超过k时队首出队 
		if(i >= k) printf("%d\n", a[q[head]]); //输出结果 
	}
	return 0;
}
```

---

## 作者：doby (赞：2)

我竟然是第一个线段数题解？？

完全就是裸的线段树啊……

本题==P1886……

233333333333……

```cpp
#include<cstdio>
#define maxn 200000 
using namespace std;
int n,k,a;
struct Tree
{
    int m;
}t[maxn*4];
int max(int a,int b)
{
    if(a>b){return a;}
    else{return b;}
}
void change(int k,int l,int r,int p,int c)//感觉这些不需要什么说明啊……
{
    if(l==r)//找到要找的点，修改
    {
        t[k].m=c;
        return;
    }
    int mid=(l+r)/2;
    if(p<=mid){change(k*2,l,mid,p,c);}
    else{change(k*2+1,mid+1,r,p,c);}
    t[k].m=max(t[k*2].m,t[k*2+1].m);//pushup
}
int query(int k,int l,int r,int ll,int rr)//简直都是标准RMQ……
{
    if(ll<=l&&rr>=r){return t[k].m;}//要找的部分全部在找的区间内
    int mid=(l+r)/2,ret=-(1<<29);
    if(ll<=mid){ret=max(ret,query(k*2,l,mid,ll,rr));}//要找的一部分在找的区间内
    if(rr>mid){ret=max(ret,query(k*2+1,mid+1,r,ll,rr));}
    return ret;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        change(1,1,n,i,a);
    }
    for(int i=1;i<=n-k+1;i++)//题目中都说了有多少个，直接复制下来……
    {
        printf("%d\n",query(1,1,n,i,i+k-1));
    }
    return 0;
}
```

---

## 作者：Dr_殇 (赞：1)

#一个非常简单的模拟。

#题目分析：

这题其实就是求在一个区间内的最大值。

先模拟区间的终点（也可以是起点，这里我做的是终点）然后再模拟这个区间内的最大值。

##代码如下：



```cpp
#include <ctime>
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
int n,m,ans,ans1,a[20000005];
int main(){
    freopen ("2032.in","r",stdin);
    freopen ("2032a.out","w",stdout);
    scanf ("%d %d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf ("%d",&a[i]);
    }
    for (int i=m;i<=n;i++){
        ans=0;
        for (int j=i-m+1;j<=i;j++){
            ans=max(ans,a[j]);
        }
        printf ("%d\n",ans);
    }
    return 0;
}
```
当然，这题的n最大有2\*10^6，时间复杂度为O((n/2)^2)很显然会超时，所以我们要加以改进。
那我们先在1到m中模拟一个最大值，将它的下标记下来，然后再从m+1模拟到n（当然，这是终点模拟），如果这个最大值不在区间范围内，也就是小于这个区间的起点，那么最大值就就是这个区间的最大值（模拟就行了，不会超时），还要把下标记下来。还有一种情况，就是新的区间的终点那个数比记下来的最大值还大，那么就把它变成最大值，并把下标记下来。

优化后的代码如下：



```cpp
#include <ctime>
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
int n,m,ans,ans1,a[20000005];
int main(){
    freopen ("2032.in","r",stdin);
    freopen ("2032.out","w",stdout);
    scanf ("%d %d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf ("%d",&a[i]);
    }
    for (int i=1;i<=m;i++){
        if (ans<=a[i]){
            ans=a[i];
            ans1=i;
        }
    }
    printf ("%d\n",ans);
    for (int i=m+1;i<=n;i++){
        if (ans1<=i-m+1){
            ans=0;
            for (int j=i-m+1;j<=i;j++){
                if (ans<=a[j]){
                    ans=a[j];
                    ans1=j;
                }
            }
        }
        if (a[ans1]<a[i]){
            ans1=i;
            ans=a[i];
        }
        printf ("%d\n",ans);
    }
    return 0;
}
```
完成^\_^
#珍爱生命，拒绝抄袭！


---

## 作者：【天朝】MILK (赞：1)

- 这道题目类似于[滑动窗口](https://www.luogu.org/problemnew/show/P1886)

- **标准**做法应该是**单调队列**

- 查看了已有的**题解**，似乎还没有我这种**奇葩**的做法，只是给大家增加一种解法。

- 但是以下算法**太菜了**，**切勿用于滑动窗口！**（不然会**TLE** 3个点）


------------

### 现在讲一下我对这道题目的**独特的思维**

------------
注意到题目的数据范围：

> 矩阵中元素大小不超过 **1000**。

这才给予了我**无穷的动力**

### 提前声明算法复杂度 

$O$($Nlog_2^2 Num$)，其中$Num$为离散化之后的不同元素个数。

已知$Num<=1000$。

------------
看到这个时间复杂度带着这么多$log$，你是否想起了什么？

本蒟蒻的算法是

### 二分答案+树状数组优化前缀和

------------
其实这很好理解：

怎么样才能**保证**答案是被覆盖其中最大的呢？

------------
#### 壹.离散化 $O$($Nlog_2 N$)

------------
```
for(int i=1;i<=N;i++)scanf("%d",&A[i]),B[i]=A[i];
sort(B+1,B+N+1);
Num=unique(B+1,B+N+1)-B-1;
for(int i=1;i<=N;i++)A[i]=lower_bound(B+1,B+Num+1,A[i])-B;
```
------------
#### 贰.维护 $O$($Nlog_2 Num$)

------------
**模拟**板子的移动：

**初始化**先加入M个元素。

**删去**第一个元素后**再加入**一个元素用**树状数组**来维护。

------------
#### 叁.查询 $O$($Nlog_2^2 Num$)

------------
满足最大值$Max$一定有：

1. $Sum[Max]=M$

2. $Sum[Max-1] < M$

------------
**加之，其满足单调递增函数，即$Sum[i]\le Sum[i-1]$**

那么，我们可以**二分**求临界值

------------
建议配合使用$O(5)$优化：
```
#pragma GCC optimize(5)
```
 
------------
好的，废话不多说，我们上码

------------
```
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<cstdio>
using namespace std;
int C[2000005],A[2000005],B[2000005];
int N,M,Num;
inline int L_B(int x){return x&(-x);}
void Add(int P,int Ni){for(int i=P;i<=Num;i+=L_B(i))C[i]+=Ni;return;}
int Ask(int P){int Ans=0;for(int i=P;i;i-=L_B(i))Ans+=C[i];return Ans;}
int Query_Max(int Ni)
{
	int L=0,R=Num,Ans=0;
	while(L<=R)
	{
		int Mid=(L+R)>>1;
		if(Ni-Ask(Mid))L=Mid+1;
		else R=Mid-1,Ans=Mid;
	}
	return Ans;
}
int main()
{
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;i++)scanf("%d",&A[i]),B[i]=A[i];
	sort(B+1,B+N+1);
	Num=unique(B+1,B+N+1)-B-1;
	for(int i=1;i<=N;i++)A[i]=lower_bound(B+1,B+Num+1,A[i])-B;
	for(int i=1;i<=M;i++)Add(A[i],1);
	for(int i=M+1;i<=N;i++)
	{
		printf("%d\n",B[Query_Max(M)]);
		Add(A[i-M],-1);Add(A[i],1);
	}
	printf("%d\n",B[Query_Max(M)]);
	return 0;
}

```
------------
希望大家**不要嫌弃**，毕竟~~太慢~~了。

------------


---

## 作者：X_WT (赞：1)

有趣的题目		
看到很多巨佬用的单调队列，可是本蒟不会（悄悄地，别说出来）		
但是很快想出来一中神奇的思路……
大致介绍一下，一轮下来找一个最大值，并标记一下这个最大值的位置，然后进入下一个数，如果新的数比最大值大，最大值和位置更新，否则判断之前的最大值在不在范围里，不在的话一遍循环找一下，并更新……以此类推一直到最后一个数进去	
下面祭上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,k,m=0,d;
	cin>>n>>k;
	int a[n+1],i,j;
	for(i=1;i<=n;i++)
		cin>>a[i];
	for(i=1;i<=k;i++)
		if(a[i]>m){
			m=a[i];
			d=i;
		}//寻找第一个最大值
	cout<<m<<endl;
	for(i=k+1;i<=n;i++)
	{
		if(a[i]>m){
			m=a[i];
			d=i;
			cout<<m<<endl;
		}//需要更新最大值
		else{
			if(d<=i-k)//就是最大值不在范围里
				for(j=i-k+1,m=0;j<=i;j++)
					if(a[j]>m){
						m=a[j];
						d=j;
					}//找一遍
			cout<<m<<endl;
		}//不需要更新哦
	}
	return 0;
}//结束，完美
```

---

## 作者：蔡俊黠 (赞：0)

题目意思：求i-k+1~i之间的最大值

最大值可以用STL里的priority_queue来存储，队内元素从大到小，当队头元素的位置不在i-k+1~i的时候（模板盖不到）就删除（因为他已经没有利用价值了）

那么我们怎么知道队头元素在不在木板内呢？可以将队列元素的类型定义为结构体，存储元素值和编号

定义：
```cpp
struct node{
	int num; //元素值
	int id; //元素编号
	bool operator<(const node&a) const
	{
		return a.num>num;
     //这样的话就按照元素值从小到大排序
	}
}e;
priority_queue<node> q;
```
在每次输出前判断一下队头是否符合要求，将不符合要求的删除，就行了

#### code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
struct node{
	int num;
	int id;
	bool operator<(const node&a) const
	{
		return num<a.num;
	}
}e;
priority_queue<node> q;
int main()
{
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)
	{
		int a;
		scanf("%d",&a);
		e.num=a; e.id=i;
		q.push(e); //将类型为node的e推进去 
		if (i>=k) //可以输出 
		{
			while (q.top().id<i-k+1) q.pop(); //其实改成if语句也行，因为每次最多删除一个队头 
			printf("%d\n",q.top().num); //输出队头的元素值 
		}
	}
	return 0;
}
```


---

## 作者：Seanq (赞：0)

**P2032 扫描**  
单调队列  
每次维护一个递减的序列即可  
std:  
```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
#include <cctype>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define frep(i,x,y) for(int i=x;i>=y;i--)
const int N=2000005;
int n,m;
int a[N];
int h=1,t=0;
int q[N];
int main()
{
	scanf("%d%d",&n,&m);
	rep(i,1,n) scanf("%d",&a[i]);
	rep(i,1,m)
	{
		while(h<=t&&a[q[t]]<=a[i]) t--;
		q[++t]=i;
	}
	printf("%d\n",a[q[h]]);
	rep(i,m+1,n)
	{
		while(h<=t&&q[h]<i-m+1) h++;
		while(h<=t&&a[q[t]]<=a[i]) t--;
		q[++t]=i;
		printf("%d\n",a[q[h]]);
	}
	return 0;
} 
```

---

## 作者：NTG_Adiord (赞：0)

emmm这种解法貌似没人发过
思路大概是用一个数组存一下这个数字在这片区域内的出现次数，再用优先队列存一下这片区域内的最大值，然后再存一个队列，k之前只进不出，k之后把前面的弹出去然后再把对应值-1就好

然后每轮的时候，先看一下优先队列头的那个数出现次数是否大于等于一，否则先弹出，再看下一个数

emm代码如下

```cpp
#include <cstdio>
#include <queue>
using namespace std;
int n,k;
int d;
int num[10001];//存数字
queue<int> pass;//这片区域读入的数字
priority_queue<int > now;//该区域出现过的数字，排序
int main(){
	scanf("%d%d",&n,&k);
	for(int w=1;w<=n;w++){
		scanf("%d",&d);    //边读入边判断就好
		pass.push(d);
		num[d]++;	//读进来++
		if(num[d]==1)now.push(d);//如果是1，肯定是刚丢进来啦
		if(w>=k){//开始输出
			if(w>k){//w比k大就是说明区间该往右跳一个了
				num[pass.front()]--;//最左侧读入的数量-1再丢掉
				pass.pop();
			}
			while(num[now.top()]==0)now.pop();//如果没了就丢掉
			int ggg=now.top();
			if(num[ggg]>=1){
				printf("%d\n",ggg);
			}
		}
	}
    return 0;
}

```

ok,收工

---

## 作者：redegg (赞：0)

看着你们都用单调队列什么的高级玩意。


作为发题解只发线段树的我。

当然还是选择它啦~

#线段树做这题又快又稳又装蠢。#

如果你看到现在还不恍然大悟的话，你应该去补一补线段树，因为线段树真的没什么高级的东西（这也是为什么我只发线段树题解）。


代码如下

```cpp
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;

long long n,k;
int b[2000005];

int a[8000005];

void build(int l,int r,int id)
{
    if(l==r)
    {
        a[id]=b[l];
        return ;
    }
    else
    {
        int mid=(l+r)/2;
        build(l,mid,id\*2);
        build(mid+1,r,id\*2+1);
        a[id]=max(a[id\*2],a[id\*2+1]);
    }
}

int update(int l,int r,int z,int y,int id)
{
    if(l==z&&r==y)
    {
        return a[id];
    }
    else
    {
        int mid=(l+r)/2;
        if(z>mid)return update(mid+1,r,z,y,id\*2+1);
        else if(y<=mid)return update(l,mid,z,y,id\*2);
        else return max(update(l,mid,z,mid,id\*2),update(mid+1,r,mid+1,y,id\*2+1));
    }
}

int main()
{
    scanf("%lld%lld",&n,&k);

    for(int i=1;i<=n;i++)
    {
        scanf("%d",&b[i]);
    }
    build(1,n,1);
    for(int j=k;j<=n;j++)
    {
        printf("%d\n",update(1,n,j-k+1,j,1));
    }

    return 0;
}

---

## 作者：Rocket_Ruaccoon (赞：0)

裸的RMQ

不过貌似数据范围不太应该有100wQAQ







```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
using namespace std;
const int MaxN=200005;
const int MaxM=18;
int N,K;
int Max[MaxN][MaxM+1];
void Init(){
    int i;
    scanf("%d%d",&N,&K);
    for(i=1;i<=N;i++)
        scanf("%d",&Max[i][0]);
}
void ST(){
    int i,j;
    for(j=1;j<=MaxM;j++)
        for(i=1;i<=N;i++)
            if(i+(1<<j)-1<=N)
                Max[i][j]=max(Max[i][j-1],Max[i+(1<<(j-1))][j-1]);
}
void Query(){
    int s,e,k;
    for(e=K;e<=N;e++){
        s=e-K+1;
        k=(int)(log(e-s+1)/log(2.0));
        printf("%d\n",max(Max[s][k],Max[e-(1<<k)+1][k]));
    }
}
int main(){
    Init();
    ST();
    Query();
    return 0;
}
```

---

## 作者：pupuvovovovovo (赞：0)

```cpp
type rec=record
num,tim:longint;
end;
var a:array [1..2000001] of longint;
dl:array [0..2000001] of rec;
n,k,i,h,t:longint;
procedure push(x:longint);
begin
  while (t>=h) and (x>=dl[t].num) do dec(t);
  inc(t);
  dl[t].num:=x;
  dl[t].tim:=i;
end;
begin
  read(n,k);
  h:=1;
  for i:=1 to n do
  read(a[i]);
  for i:=1 to k-1 do
  push(a[i]);
  for i:=k to n do
  begin
    push(a[i]);
    if dl[h].tim<=i-k then inc(h);
    writeln(dl[h].num);
  end;
end.
单调队列水题，但由于本题的数据似乎是说明的十倍，所以开大点。
```

---

## 作者：十四LO (赞：0)

```cpp
//本题关键是速度优化
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
long long a[1000001];
int main(){
  long long i,j,k,m,n,max=0,x=0,ans=0,flag=0;//x为木板中最大数的编号
  scanf("%lld%lld",&n,&m);//输入
  for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);//输入
  for(i=1;i<=m;i++)
    if(a[i]>max){
      max=a[i];
          x=i;
```
}//首次进行最大赋值
```cpp
  printf("%lld\n",max);//第一个最大的
  for(i=2;i<=n-m+1;i++){
      if(i>x){  //如果x已经不被木板盖住
      max=a[i];  //max假设为该木板最前面的数字
      for(j=i;j<=i+m-1;j++)//从i~（i+m-1）选取最大的数字
        if(a[j]>max){
          max=a[j];
            x=j;//木板中的最大数赋新值
        }
    flag=1;//标记
    }
    if(flag==0)
      if(a[i-1+m]>max){  //如果上一个木板中最大的数在这依然存在，只要将max与新进来的数比较
        max=a[m+i-1];x=m+i-1;
      }
    flag=0;//flag归零
    printf("%lld\n",max);//输出
  }
  return 0;
}
```

---

## 作者：zhengrunzhe (赞：0)

貌似没有线段树题解。

强行线段树、、不多解释。

```cpp
#include<iostream>
using namespace std;
const int N=200001,INF=2147483647;
int n,k,i;
struct tree{int l,r,s;}t[4*N];
void build(int l,int r,int k)
{
    t[k].l=l;t[k].r=r;
    if (l==r){cin>>t[k].s;return;}
    int mid=(l+r)/2;
    build(l,mid,k*2);
    build(mid+1,r,k*2+1);
    t[k].s=max(t[k*2].s,t[k*2+1].s);
}
int query(int l,int r,int k)
{
    if (t[k].l>r || t[k].r<l)return -INF;
    if (l<=t[k].l && r>=t[k].r)return t[k].s;
    return max(query(l,r,k*2),query(l,r,k*2+1));
}
int main()
{
    cin>>n>>k;build(1,n,1);
    for (i=1;i<=n-k+1;i++)
        cout<<query(i,i+k-1,1)<<endl;
    return 0;
}
```

---


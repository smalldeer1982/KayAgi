# 化学1（chem1）- 化学合成

## 题目背景

蒟蒻 HansBug 在化学考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在蒟蒻 HansBug 面前的是一个化学合成题，据他所知，一般答案如下面这样的格式：

![](https://cdn.luogu.com.cn/upload/pic/2223.png) （接下一行）

![](https://cdn.luogu.com.cn/upload/pic/2221.png) 

简单解释下：每种化合物可以通过一步反应生成另一个化合物（将这称作一步反应，设为 $A\rightarrow B$），现在假设每个 $A\rightarrow B$ 中，理论上 $1$ 个单位的 $A$ 都仅可以生成 $1$ 个单位的 $B$。然而实际实验表明，并不存在绝对完全的化学转化，设转化率为 $C$（即 $1$ 个单位 $A$ 实际可以生成 $C$ 个单位的 $B$，$0<C<1$）。

现在蒟蒻 HansBug 的知识体系中有 $N$ 个这样 $A\rightarrow B$ 的转化。然而题目中蒟蒻 HansBug 要由 $1$ 个单位的化合物 $S$ 生成化合物 $T$，可是他脑细胞和 RP 已经消耗殆尽，所以找到最终产量最高的合成路线的艰巨任务就交给你啦！

## 说明/提示

样例 1 和样例 2 中，两条合成路线分别为 $1\rightarrow3$、$1\rightarrow2$、$2\rightarrow3$，产率分别为 $0.8$、$0.9$、$0.9$。

在样例 1 中，有两种可行的路线 $1\rightarrow3$ 和 $1\rightarrow2\rightarrow3$ ，最终产量分别为 $0.8$、$0.9\times0.9=0.81$，故第二条路线更优，产量为 $0.8100$。

样例 2 中，$2$ 只能生成 $3$，$3$ 无法生成别的化合物，故无法生成，蒟蒻 HansBug 只好选择 `orz`。

**【数据范围】**

![](https://cdn.luogu.com.cn/upload/pic/2220.png)


## 样例 #1

### 输入

```
3 3 1 3
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
0.8100```

## 样例 #2

### 输入

```
3 3 2 1
1 3 0.8
1 2 0.9
2 3 0.9
```

### 输出

```
orz```

# 题解

## 作者：XiaoX (赞：9)

##### 谁说不能用Dijkstra了？
####  堆优化dijA了 ~~（第2个点960ms。。。）~~ 
上代码： _（坑点挺多）_ 
```
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
typedef pair<double,int> kk;//注意小数*1
const int N=5005,M=2000000;
int n,m,s,t;
int head[N],tot;
double d[N];//注意小数*2
bool v[N];
struct edge{
	int nxt,ver;
	double w;//*3
}e[M*2];
void add(int x,int y,double z){
	e[++tot].ver=y,e[tot].w=z,e[tot].nxt=head[x],head[x]=tot;
}
//邻接表存图（没啥说的吧）
void dij(int st){
	for(int i=1;i<=n;i++) d[i]=-1;//都赋值成-1（未到达）
	priority_queue<kk>q;//大根堆
	d[st]=1;q.push(make_pair(1,st));
	while(q.size()){
		int x=q.top().second;q.pop();
		if(v[x]) continue;v[x]=1;
		for(int i=head[x];i;i=e[i].nxt){
			int y=e[i].ver;
			if(d[x]*e[i].w>d[y]){
				d[y]=d[x]*e[i].w;//注意题目要求（乘法）
				q.push(make_pair(d[y],y));
			}
		}
	}
}
int main ()
{
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=1;i<=m;i++){
		int x,y;
		double z;//注意小数*4...
		scanf("%d%d%lf",&x,&y,&z);
		add(x,y,z);//图存起来！！
	}
	dij(s);
	if(d[t]!=-1) printf("%.4lf",d[t]);//-1说明不连通
	else printf("orz");
}
```

---

## 作者：Diamiko (赞：6)

最长路模板

SPFA算法求最长路是很方便的，只要把SPFA最短路模板里的大于号改成小于号，初始化的时候把dis改为极小值就ok了。

这个题要注意的还有起点一开始距离是1，如果是0的话后面怎么乘都是0.

上代码

```cpp
#include<queue>
#include<cstdio>
using namespace std;
struct Node
{
    int head;
    double dis;
    bool vis;
}node[5005];
struct Edge
{
    int to,next;
    double len;
}edge[2000005];
int cnt,n,m,s,t;
void addEdge(int u,int v,double w)
{
    edge[++cnt].to=v;
    edge[cnt].len=w;
    edge[cnt].next=node[u].head;
    node[u].head=cnt;
}
void SPFA()
{
    queue<int>q;
    for(int i=1;i<=n;i++)
    {
        node[i].dis=-0x3f3f3f3f;
        node[i].vis=0;
    }
    node[s].dis=1;
    node[s].vis=1;
    //初始化要注意
    q.push(s);
    while(q.size())
    {
        int u=q.front();
        q.pop();
        node[u].vis=0;
        for(int e=node[u].head;e;e=edge[e].next)
        {
            int v=edge[e].to;
            if(node[v].dis<node[u].dis*edge[e].len)
            {
                //注意是求最长路，所以是小于号
                node[v].dis=node[u].dis*edge[e].len;
                //注意这里的计算方法不是加而是乘
                if(!node[v].vis)
                {
                    q.push(v);
                    node[v].vis=1;
                }
            }
        }
    }
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        double w;
        scanf("%d%d%lf",&u,&v,&w);
        addEdge(u,v,w);
    }
    SPFA();
    if(node[t].dis<=-0x3f3f3f3f)
        puts("orz");
    else 
        printf("%.4lf\n",node[t].dis);
    //没更新到就说明没路，orz
    return 0;
}
```

---

## 作者：幽灵特工 (赞：4)

# 这是一道最短路的~~裸~~好题。

## 小学生秒懂系列。

[欢迎进入 blog 查看你的小学生秒懂系列都更新了啥。](https://www.luogu.com.cn/blog/Liya2304238405/#type=%E9%A2%98%E8%A7%A3)

本题是最长路裸题，但我在讲算法时会按最短路讲。不过大家最喜欢的~~可以直接提交 AC 的~~代码是本题的最长路。话不多说接下来上菜。

# 菜单 menu
 
1. 草草讲下我推荐的存图方案：图的边集数组存储；

2. 本题思路；

2. Bellman-Ford 算法；

3. Bellman 算法的队列优化： Shortest Path Faster Algorithm ，即 SPFA（看见全称我也不知道是什么算法）；

4. Dijkstra 算法。



# 边集数组

此存储方式使用两个数组：一个一维的边数组，一个二维的点数组。

采用此方法的优势是容易对边进行操作，并且可以方便地为边添加信息（流量、费用、权值、校草喜欢你的程度）。

在边数组中存储每条边的信息，点数组中存储一个点连接的所有边的信息。在读入数据时，同一次循环中先存边，然后将该边在边数组中的下标保存到点数组中。

```cpp
struct edge {
	int from, to;
	double w;
	edge(int x, int y, double z) { from = x; to = y; w = z; }
};
vector <edge> e;
vector <int> G[MAXN];
  
int main() {
	cin >> n >> m >> s >> t;
	int a, b;double c;
	for (int i = 0; i < m; i++) {
		cin >> a >> b >> c;
		e.push_back(edge(a, b, c));
		G[a].push_back(e.size() - 1);
	}	
}
```

另外，常见的图的存储方式还有邻接矩阵，邻接表，链式前向星。

# 本题思路

有向图，要求目标最大 ？最长路。

没有负权 ？可以用 Dijkstra 。

数据范围超过 1000 ？不可以用 Floyd 。

而且很显然需要把最短路模板中的加改乘， min 改 max ，初始化自己到自己的距离为1，其他长度为-1。



------------

# Bellman-Ford 算法求最短路


Bellman-Ford 算法是一种基于松弛（ relax ）操作的最短路算法，支持负权。能找到某个结点（起点）出发到所有结点的最短路，或者报告某些最短路不存在。

## relax （松弛）操作

设起点为 $S$ ，定义 $dist[u]$ 为 $S$ 到 $u$ 的最短路径长度。

$relax(u,v)$ 操作就是指$dist[v]=min(dist[v],dist[u]+len(u,v))$  。

其中 $len(u,v)$ 是指边 $(u,v)$ 的权值（或者说长度）。

为什么 $relax$ 可以拿来求最短路？

答案蕴含在各位胎教时都学过的三角形不等式中：两边之和大于第三边，即 $dist[v]\le dist[u]+len(u,v)$。

## 实现

有了上面的芝士， Bellman 算法可以表示如下：

```
while (1) {
	relax所有的m条边;
	if (没有一条边可以执行relax操作)break;
}
```

可以执行 $relax$ 操作就是指用 $dist[u]+len(u,v)$ 更新了$dist[v]$。

如果图中有 $S$ 能到达的负环，那么程序会无限循环，应该在合适的时间退出并报告没有某些最短路，这个合适的时间稍后会讲。

考虑最短路存在的情况。

由于一次松弛操作会使最短路的边数至少 $+1$，而最短路的边数最多为 $n-1$ 。所以最多执行 $n-1$ 次松弛操作，即最多循环 $n-1$ 次。如果能执行第 $n$ 次循环则应该退出并报告存在负环。

因此总时间复杂度为 $O(nm)$ 。

## 伪代码

接下来的队列优化版会给全 C++ 代码。

```cpp
void Bellman() {
	relax(u, v) {
		dist[v] = min(dist[v], dist[u] + edge_len(u, v));
	}
	for (i = 1; i <= n; i++) {
		dist[i] = edge_len(S, i);
	}
	for (i = 1; i < n; i++) {
		for each edge(u, v) {
			relax(u, v);
		}
	}
}
```



------------

# SPFA



SPFA 是 Bellman 的队列优化版。

## 实现

很多时候我们并不需要那么多无用的松弛操作。

很显然，只有上一次被松弛的结点所连接的边，才有可能引起下一次的松弛操作。

那么我们用队列来维护“哪些结点可能会引起松弛操作”，就能只访问必要的边了。

## SPFA的伪代码如下

```
q = new queue();
q.push(S);
in_queue[S] = true;
while (!q.empty()) {
  u = q.pop();
  in_queue[u] = false;
  for each edge(u, v) {
    if (relax(u, v) && !in_queue[v]) {
      q.push(v);
      in_queue[v] = true;
    }
  }
}
```

## 本题代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5010;
int n, m, s, t;
struct edge {
	int from, to;
	double w;
	edge(int x, int y, double z) { from = x; to = y; w = z; }
};
vector <edge> e;
vector <int> G[MAXN];
queue <int> q;
bool in_queue[MAXN];
double dist[MAXN];
void SPFA() {
	for (int i = 1; i <= n; i++)dist[i] = -1;
	dist[s] = 1.00;
	q.push(s);
	while (!q.empty()) {
		int u = q.front(); q.pop();
		in_queue[u] = 0;
		for (int i = 0; i < G[u].size(); i++) {
			int v = e[G[u][i]].to;
			if (dist[v] < dist[u] * e[G[u][i]].w) {
				dist[v] = dist[u] * e[G[u][i]].w;
				if (!in_queue[v]) { q.push(v); in_queue[v] = 1; }
			}
			
			
		}
	}
}

int main() {
	ios::sync_with_stdio(0);//为输入输出加速
	cin >> n >> m >> s >> t;
	int a, b;double c;
	for (int i = 0; i < m; i++) {
		cin >> a >> b >> c;
		e.push_back(edge(a, b, c));
		G[a].push_back(e.size() - 1);
	}
	SPFA();
	if (dist[t] < 0.00001)cout << "orz";
	else cout << fixed << setprecision(4) << dist[t];
}




```


Bellman 算法的其它优化形式 ：[知乎](https://www.zhihu.com/question/292283275/answer/484871888)


------------

# Dijkstra 算法求最短路



只适用于非负权图，但复杂度可以优化到很低。

## 实现

将所有点划分为两个集合：已确定最短路的点集 $A$ ，未确定最短路的点集 $B$ 。
 
由于起点 $S$ 到自己的距离为 0 ，因此一开始 $A$ 里只有   $S$ 。

然后执行以下循环：

1. 对刚刚被加入第一个集合的结点的所有 **出边** 执行松弛操作；

2. 从 $B$ 中选一个点，该点到 $A$ 中一点的距离的最小值是 $B$ 中最小的，将该点从 $B$ 移至 $A$ ；

3. 检查 $B$ 是否为空，若空则算法结束。

## 复杂度

普通做法是 $n^2$ 。

优先队列优化 $mlogm$ 。

斐波那契堆优化 $nlogn+m$ 。

ZKW线段树优化 $mlogn+n$ 。

## 代码

代码我贴一个之前做的模板题，采用优先队列优化。

[【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,s;
struct edge{
	int from,to,w;
	edge(int a,int b,int c){
		from=a;to=b;w=c;
	}
};
struct node{
	int u,d;
	bool operator < (node b)const{
		return this->d > b.d;
	}
	
};
vector <edge> e;
vector <int> G[100004];
bool vis[100004];
int d[100004];
void Dij(int x){
	for(int i=1;i<=n;i++)d[i]=1e9;
	d[x]=0;
	priority_queue <node> q;
	q.push((node){x,0});
	while(!q.empty()){
		int now=q.top().u;q.pop();
		if(vis[now])continue;
		vis[now]=1;
		for(int i=0;i<G[now].size();i++){
			edge ed = e[G[now][i]];
			if(d[ed.to]>d[ed.from]+ed.w){
				d[ed.to]=d[ed.from]+ed.w;
				q.push((node){ed.to,d[ed.to]});
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>s;
	int a,b,c;
	for(int i=0;i<m;i++){
		cin>>a>>b>>c;
		e.push_back(edge(a,b,c));
		G[a].push_back(e.size()-1);
	}
	Dij(s);
	for(int i=1;i<=n;i++){
		if(d[i]==1e9)cout<<2147483647<<" ";
		else cout<<d[i]<<" ";
	}
}



```


辛苦一下午，留个赞再走呗~

---

## 作者：sukimo (赞：3)

浮点数版单源最长路，很容易想到spfa。把模板改一改即可。

```
#include<bits/stdc++.h>
#define db double
using namespace std;
queue<int>que;int sta,end,fir[5005];bool vis[5005];db dis[5005];struct STR{db val;int next,to;}edge[2000005];
void add(int u,int v,db val,int pos){
	edge[pos].next=fir[u];fir[u]=pos;edge[pos].val=val;edge[pos].to=v;
}
void spfa(){
	vis[sta]=dis[sta]=1;que.push(sta);
	while(!que.empty()){
		int fr=que.front();
		for(int i=fir[fr];i;i=edge[i].next)
			if(dis[edge[i].to]<edge[i].val*dis[fr]){
				dis[edge[i].to]=edge[i].val*dis[fr];
				if(!vis[edge[i].to]){
					vis[edge[i].to]=1;que.push(edge[i].to);
				}
			}
		vis[fr]=0;que.pop();
	}
}
int main(){
	int n,m;scanf("%d%d%d%d",&n,&m,&sta,&end);
	for(int i=1;i<=m;i++){
		int u,v;db turn;scanf("%d%d%lf",&u,&v,&turn);add(u,v,turn,i);
	}
	spfa();dis[end]?printf("%.4lf",dis[end]):printf("orz");
	return 0;
}
```


---

## 作者：vegetabird (赞：3)

不知为何，这题用dijstra做最后的一个点超时了，无奈之下只能用spfa这个不稳定的算法2333

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,s,e;
int a[2000010],b[2000010];
double c[2000010];
int first[5010],next[2000010];
double dis[5010];
bool visited[5010];
int q[10010];
void dijstra(){                                            会超时的dijstra……
    memset(dis,0,sizeof(dis));
    memset(visited,false,sizeof(visited));
    int u,k,i,j;
    dis[s]=1;                                            将初始点的距离标记为1
    for(i=1;i<=n;i++){
        u=0;
        for(j=1;j<=n;j++){
            if(!visited[j]&&dis[j]>dis[u]){
                u=j;
            }
        }                                            找到dis最大的蓝点
        visited[u]=true;                                并将其标记为白点
        k=first[u];
        while(k!=-1){
            if(!visited[b[k]]&&dis[b[k]]<dis[u]*c[k]){            遍历与白点u有边相连的所有蓝点
                dis[b[k]]=dis[u]*c[k];                    更新dis
            }
            k=next[k];
        }
    }
}
void spfa(){
    int fir=0,las=0,u,k;
    memset(dis,0,sizeof(dis));
    memset(visited,false,sizeof(visited));
    visited[s]=true;
    dis[s]=1;                                        将初始点的dis标记为1
    q[0]=s;                                        将初始点放进队列
    while(fir<=las){                                队列内元素数量>=1
        u=q[fir];                                    取出队列的第一个点u
        k=first[u];
        while(k!=-1){                                遍历与u相邻的所有点
            if(dis[b[k]]<dis[u]*c[k]){
                dis[b[k]]=dis[u]*c[k];                更新dis
                if(!visited[b[k]]){
                    visited[b[k]]=true;                如果该点的dis被更新且该点不在队列内
                    q[(++las)%n]=b[k];                就将该点放进队列
                }
            }
            k=next[k];
        }
        fir++;                                    头指针指向下一个点
        visited[u]=false;                            将点u标记为未进入队列
    }
}
int main(){
    memset(first,-1,sizeof(first));
    int i;
    scanf("%d%d%d%d",&n,&m,&s,&e);
    for(i=1;i<=m;i++){
        scanf("%d%d%lf",&a[i],&b[i],&c[i]);
        next[i]=first[a[i]];                                        链式前向星记录图
        first[a[i]]=i;
    }
    spfa();
    if(dis[e]){
        printf("%.4lf\n",dis[e]);
    }else{
        printf("orz\n");
    }
}
```

---

## 作者：Johnson_sky (赞：0)

Bfs搜索，单项边，注意一下代码中标注的两个剪枝。


PS：感谢楼下让我学习了double的读入优化~~~








```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,en,s,t,x,y,head[5010];
double z,ans[5010];bool vis[5010];
struct Node
{
    int to,next;
    double val;
}e[2000010];
queue<int>q;
inline int get_num()
{
    int now=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){
        now=(now<<1)+(now<<3)+ch-'0';
        ch=getchar();
    }
    return now;
}
inline double get_double(){
    double now=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){
        now=now*10+ch-'0';
        ch=getchar();
    }
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){
        now=now*10+ch-'0';
        w=w*0.1;
        ch=getchar();
    }
    return now*w;
}
inline void add(int u,int v,double z)
{
    e[++en].to=v;
    e[en].val=z;
    e[en].next=head[u];
    head[u]=en;
}
void bfs()
{
    q.push(s);ans[s]=1;vis[s]=1;//入队打标记
    while(q.size()){
        int now=q.front();q.pop();vis[now]=0;//出队清标记
        for(int i=head[now];i;i=e[i].next){
            if(ans[e[i].to]<ans[now]*e[i].val){//更新答案
                if(vis[e[i].to]==0){//判断元素是否在队中
                    q.push(e[i].to);
                    vis[e[i].to]=1;//入队打标记
                }
                ans[e[i].to]=ans[now]*e[i].val;
            }
        }
    }
}
int main()
{
    n=get_num();m=get_num();s=get_num();t=get_num();//读入优化
    for(int i=1;i<=m;i++){
        x=get_num();y=get_num();z=get_double();
        add(x,y,z);
    }
    bfs();
    if(ans[t]==0)puts("orz");
    else printf("%.4lf",ans[t]);//注意保留4位小数（题目中说四舍五入）
    return 0;
}
```

---

## 作者：Kwork (赞：0)

这道题其实就是变式的Dijkstra，求最长路，只需要修改最短路算法的松弛条件就可以了，并不难。

但是从数据范围来看邻接矩阵式万万不行的，会爆内存，我的同学手工二分，发现邻接矩阵最多80分。

小伙伴们还是写邻接表吧。

下面是代码。

ps：洛谷的cpp题解提交后怎么都不带缩进的。。。。。。。。。。。

```cpp

#include <iostream>
#include <cstring>
#include <cmath>
#include <vector>
#include <cstdio>
using namespace std;
const int maxn=5005;
typedef pair<int,double> pp;
int n,m,s,t;
vector<pp>G[maxn];
double d[maxn];

void solve(){
    bool f[maxn];
    memset(f,false,sizeof(f));
    for(int i=1;i<=n;i++)
        d[i]=0;
    d[s]=1;
    for(int i=1;i<=n;i++){
        int flag=-1;
        double minn=-2;
        for(int i=1;i<=n;i++)
            if(!f[i])
                if(flag==-1 || d[i]>minn)
                    flag=i,minn=d[i];
        f[flag]=true;
        for(int i=0;i<G[flag].size();i++){
            d[G[flag][i].first]=max(d[G[flag][i].first],d[flag]*G[flag][i].second);
        }
    }
    if(d[t]==0) printf("orz");
    else printf("%.4lf\n",d[t]);
    
    return;
}

int main(){
    //freopen("1.txt","r",stdin);
    //freopen("2.txt","w",stdout);
    std::ios::sync_with_stdio(false);
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++){
        int u,v;double w;
        scanf("%d%d%lf",&u,&v,&w);
        pp s(v,w);
        G[u].push_back(s);
    }
    solve();

    return 0;
}

```

---

## 作者：bymlg001 (赞：0)

先来解释一下楼下的 dj为何不行

首先 看一下数据范围 边m最多 2000000 个 而 点n最多才 5000 个

dj用的是边更新 而 spfa用的是点更新

可见这个题很容易卡dj

况且楼下还没写堆优化


2000000 这个数有点大所以用的动态邻接表 稍多用一些时间换空间（时间没多少差别 空间倒是差了不少

静态小数据也要占那么大内存实在感觉太浪费

感觉2000000就是来吓吓你，所以开静态邻接表万一爆炸了一分也得不了，多怨！（应该没有题那么 keng23333

###


```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
const int N=5001;
int n,m,u,v,t1,t2;
double t3;
double dist[N];
bool in[N];
struct node{
    int to;
    double data;
};
vector<node> e[N];
inline double getdouble(){
    double data=0,w=1;char ch=0;
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') w=-w;
    while(ch!='.'&&ch>='0'&&ch<='9') data=data*10+ch-'0',ch=getchar();
    if(ch=='.'){
    ch=getchar();
    while(ch>='0'&&ch<='9') w*=0.1,data=data*10+ch-'0',ch=getchar();    
    }
    return data*w;    
}
inline int getint(){
    int data=0,w=1;char ch=0;
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') w=-w,ch=getchar();
    while(ch>='0'&&ch<='9') data=data*10+ch-'0',ch=getchar();
    return data*w;
}
inline void add(int x,int y,double z){
    node t;
    t.to=y;t.data=z;
    e[x].push_back(t);
}
void spfa(int x){
    queue<int> q;
    dist[x]=1.0;
    q.push(x);
    in[x]=1;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        in[now]=0;
        for(int i=0;i<e[now].size();i++){
            if(dist[e[now][i].to]<dist[now]*e[now][i].data&&dist[now]!=-1){
                dist[e[now][i].to]=dist[now]*e[now][i].data;
                if(!in[e[now][i].to]){
                    q.push(e[now][i].to);
                    in[e[now][i].to]=1;
                }
            }
        }
    }
}
int main(){
    n=getint();m=getint();u=getint();v=getint();
    fill(dist,dist+N,-1);
    for(int i=1;i<=m;i++){
        t1=getint();t2=getint();t3=getdouble();
        add(t1,t2,t3);
    }
    spfa(u);
    if(dist[v]==-1){
        printf("orz");
    }
    else printf("%.4lf",dist[v]);
}
//输出orz比输出-1好玩多了

```

---


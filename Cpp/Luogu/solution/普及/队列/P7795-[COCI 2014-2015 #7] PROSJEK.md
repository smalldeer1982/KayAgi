# [COCI 2014/2015 #7] PROSJEK

## 题目描述

给定一个有 $n$ 个整数的数列 $a$。请找出一个长度至少为 $k$ 的连续子序列，使这个子序列的所有数的平均值最大。

## 说明/提示

**【数据范围】**

对于 $30\%$ 的数据，保证 $n\leqslant 5000$。  
对于所有数据，$1\leqslant k\leqslant n\leqslant 3\times 10^5$，$1\leqslant a_i\leqslant 10^6$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T5 PROSJEK_**，按照原题数据配置，满分 $140$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 1
1 2 3 4```

### 输出

```
4.000000```

## 样例 #2

### 输入

```
4 2
2 4 3 4```

### 输出

```
3.666666```

## 样例 #3

### 输入

```
6 3
7 1 2 1 3 6```

### 输出

```
3.333333```

# 题解

## 作者：Pengzt (赞：7)

[P7795](https://www.luogu.com.cn/problem/P7795)

简单二分。

显然 $\mathcal{O}(n ^ 2)$ 的时间复杂度无法通过。

使子段平均值最大，考虑二分。

可以二分平均值 $mid$，然后判断是否有满足条件的和 $\ge 0$ 且长度 $\ge k$ 的子段。

记录一个前缀和数组 $s$，变为对于每个 $i$，看是否存在 $j(j<i)$ 使得 $i-j\ge k$ 且 $s_i\ge s_j$。这个东西显然可以变为查询 $s$ 的某一个前缀中是否存在一个值使得 $s_j<s_i$，从前往后扫一遍做一个前缀 $\min$ 即可。

时间复杂度：$\mathcal{O}(\dfrac{n\log V}{\text{eps}})$，其中 $\text{eps}$ 为设置的精度，$V$ 为值域。

代码：
```cpp
#include<bits/stdc++.h>

using ll = long long;
using pii = std::pair<int, int>;

const int N = 3e5 + 5;
const double eps = 1e-6;
int n, k;
int a[N];
double b[N];

bool check(double mid) {
	for (int i = 1; i <= n; i++) {
		b[i] = b[i - 1] + a[i] - mid;
	}
	double res = -1, mnv = 1e9;
	for (int i = k; i <= n; i++) {
		mnv = std::min(mnv, b[i - k]);
		res = std::max(res, b[i] - mnv);
	}
	return res >= 0;
}

int main() {
	scanf("%d %d", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	double l = 1, r = 1e6;
	while (l + eps < r) {
		double mid = (l + r) / 2;
		if (check(mid))
			l = mid;
		else
			r = mid;
	}
	printf("%.6lf\n", l);
	return 0;
}
```

---

## 作者：wangbinfeng (赞：7)

# 思路：
首先暴力思路大家应该很容易想到，不详细讲解，时间复杂度 $O(nk)$ 。显然超时。

但是我们可以发现，本题要求**连续**的序列。对于区间和问题，最快的解决方案就是： _**前缀和**_ 。

现在我们要考略，如何让平均值最大。这种问题也并不复杂，只需对平均值（结果）进行 _**二分**_ 即可。

这样这道题就解决了：用前缀和统计答案，二分找出最合适的结果。

时间复杂度： $O(n \log 10^6)$ 。

具体见注释。
# 代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,a[1000009];
double l,r,mid,s[1000009];
inline int read(){
	//快读模板
}
inline bool cheak(const double x){
	for(int i=1;i<=n;i++)s[i]=s[i-1]+a[i]-x;//前缀和
	double minn=0;
	for(int i=k;i<=n;i++){//用O(n)的时间复杂度判断结果是否正确
		if(s[i]>=minn)return true;//如果mid可以使用返回true
		minn=min(minn,s[i-k+1]);
	}
	return false;//否则返回false
}
int main(){
	n=read();
	k=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(l=0,r=1e6+10.0,mid=(l+r)/2.0;r-l>1e-7;mid=(l+r)/2.0){//二分
		if(cheak(mid))l=mid;//检查mid
		else r=mid;
	}
	printf("%.6lf",mid);//输出，注意格式
}
```

---

## 作者：lvvd (赞：3)

`O(n)` 做法。

对于选择的一段区间（假设区间左端点为 `l` ，右端点为 `r` ），平均值为 $\dfrac{\sum\limits_{i=l}^{r}a_i}{r - l + 1}$ 。

观察一下这个式子，这是不是很像斜率？其中的 `r - l + 1` 就是 `x` 轴值，而 $\sum\limits_{i=l}^{r}a_i$ 就是 `y` 轴值。

于是我们可以把每一个决策看成斜率，把它丢进单调队列里维护下凸包就行了。假设当前抉择的点与上凸包上的点相连，一定比与下凸包的点相连更劣（与上凸包上的点相连的斜率比与下凸包的点相连的斜率小），所以我们应该维护的是下凸包而不是上凸包。

另外，单调队列维护的值关联着队首的两个值（下凸包的最后两条斜率），用 `STL` 不太方便，就手打了。

```cpp
//p7795 
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,k,p,front,back,sum[300005],q[300005];
double ans;
double xl(ll s,ll t){//求斜率 
	return(sum[t]-sum[s])*1.0/(t-s);
}
int main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld",&sum[i]);
		sum[i]+=sum[i-1];
	}
	for(int i=k;i<=n;i++){
		while(back-front>=2&&xl(i-k,q[back-2])>xl(i-k,q[back-1]))--back;
		q[back++]=i-k;
		while(back-front>=2&&xl(i,q[front+1])>xl(i,q[front]))++front;
		ans=max(ans,xl(i,q[front]));
	}
	printf("%.4lf",ans);
	return 0;
}
```


---

## 作者：404Not_Found (赞：3)

简单二分。

考虑二分答案平均值，`check` 时将所有数减去 $mid$，若最大子段和 $\ge 0$ 则合法。

时间复杂度：$\mathcal{O}(n \log \max a_i)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5+5;
const double eps = 1e-7;
int n,k;
double a[N],sum[N];
bool check(double x)
{
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i]-x;
	double minv=0,ret=0;
	for(int i=k,j=0;i<=n;i++,j++)
	{
		minv=min(minv,sum[j]);
		if(sum[i]-minv>=0) return 1;
	}
	return 0;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%lf",&a[i]);
	double l=0,r=1e6;
	while(r-l>eps)
	{
		double mid=(l+r)/2;
		if(check(mid)) l=mid;
		else r=mid;
	}
	printf("%lf\n",l);
}
```

---

## 作者：loverintime (赞：2)

## 题目描述

给定一个有 $n$ 个整数的数列 $a$，请找出一个长度至少为 $k$ 的连续子序列，使这个子序列的所有数的平均值最大。

### 正解：二分答案（分数规划）+前缀和+单调数组

首先，根据题意，我们想到二分答案

我们需要找到最大的数 $s$，使得：

$\large \exists~~ l,r,~~r-l\geqslant k\land \frac{\sum_{i=l}^ra_i}{r-l+1}\geqslant s$



将 $r-l+1$ 乘到等式右边，移项，得到：

$\large\sum_{i-l}^r(a_i-s)\geqslant 0$

### 然后怎么做呢

我们可以很快的想到前缀和，因为要求 $a_l-a_r$ 的和。减去$s$也可以用 $\Theta(n)$ 的时间算出来

现在我们想要求的：最大的长度不小于 $k$ 的区间和。如果这个和大于 $0$，就说明现在二分的 $s$ 可行，否则不行。

我们继续简化：对于每一个位置 $p$，我们要找到 $p-k$ 之前的一个位置 $p'$，使得 $sum_p-sum_{p'}\geqslant 0$，其中 $sum$ 是减去 $s$ 后的前缀和

即求 $p-k$ 之前最小的 $sum$，想到单调数组。当枚举到 $p$ 时将 $sum_{p-k}$ 打到单调数组$r$里面，判断 $sum_p-r_1$ 的正负性即可

时间复杂度： $\Theta(n\log n)$

# Code:

```cpp

#include<bits/stdc++.h>

double l=0,k=1e7;
int n,s[300005],m;
double r[300005],p[300005];
bool f(double x){
	int cnt=0;
	if(p[m]-x*m>=0) return 1;
	for(int i=m+1; i<=n; i++){
		r[++cnt]=p[i-m]-x*(i-m);
		while(cnt>1&&r[cnt]<r[cnt-1]){ //打入单调数组
			r[cnt-1]=r[cnt];
			cnt--;
		}
		if(p[i]-x*i-r[1]>=0||p[i]-x*i>=0) return 1;
	}
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++){
		scanf("%d",&s[i]);
		p[i]=p[i-1]+s[i];
	}
	if(m==n){
		printf("%.8f",p[n]/n);
		return 0;
	}
	while(k-l>1e-8){
		double mid=(l+k)/2;
		if(f(mid)) l=mid;
		else k=mid;
	}
	printf("%.8f",k);

	return 0;
}



---

## 作者：UperFicial (赞：2)

# 二分答案

**前言**

由于这是一个经典 trick，我就写得简略一点吧。

~~但感觉楼下写得太过于简略了。~~

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P7795)

**题意简述**

> 如果标算太难请鉴定信念，不如回头再看一眼题面。

> 题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P7795)

大雾（


**题目解析**

我们发现 $a_i\le 10^6$，这提示我们可以从这一点入手。跟值有关的自然想到**二分答案**。

考虑二分一个答案 $x$，表示这个子序列的所有数的平均值。

假设说我们能找到另一个长度至少为 $k$ 的子序列使得这个子序列的平均值大于等于 $x$，是不是就说明这个 $x$ 的值我们可以猜的大一点，也就是移动左端点。

那么怎么判断存不存在这样序列呢？考虑推柿子。

我们假设存在这样的字序列 $b$，长度为 $m$，那么它需要满足平均值大于等于 $x$ 这样的条件，也就是：

$$\dfrac{\sum_{i=1}^mb_i}{m}\ge x$$

接下来考虑移项，把 $m$ 移过去：

$$\sum_{i=1}^mb_i\ge mx$$

然后再把 $mx$ 移过来：

$$\sum_{i=1}^mb_i-mx\ge0$$

$$\sum_{i=1}^m(b_i-x)\ge0$$

所以说，如果子序列 $b$ 的平均值是一个比 $x$ 更优的答案，那么它需满足上面的柿子。

换句话说，**当 $b$ 满足上面的柿子，它的平均值就比 $x$ 更优。**

我们发现 $b$ 中的每一项都减去了 $x$，但我们不知道 $b$ 具体是什么，于是，我们可以将 $a$ 中的每一项减去 $x$，这样问题转化成，**检查 $a$ 每一项减去 $x$ 后是否存在子序列的和大于等于 $0$。**

我们先做一下前缀和，即 $s_i=s_{i-1}+(a_i-x)$。

然后考虑贪心来做这件事。

我们先枚举 $b$ 的右端点 $i$，然后维护一个 $lst$，$lst$ 表示 $\min_{j=1}^{i-k+1}s_j$，因为我们想要得到一段子序列 $l$ 至 $r$ 的平均值大于等于 $0$，也就是 $s_r-s_{l-1}\ge 0$，既然 $s_r$ 也就是我们枚举右端点的前缀和已经确定，那么我们希望 $s_{l-1}$ 尽量小，所以 $lst$ 需要存最小值，这个 $i-k+1$ 的边界是因为序列长度至少为 $k$。

$lst$ 的维护方式是对于每一次更新的 $i$，与 $s_{i-k+1}$ 取个 $\min$ 即可。

~~本来想写简略一点的~~![/wq](https://cdn.luogu.com.cn/upload/pic/62248.png)![/wq](https://cdn.luogu.com.cn/upload/pic/62248.png)![/wq](https://cdn.luogu.com.cn/upload/pic/62248.png)

然后这种平均值还有一种经典题就是在图上做，方法是 $\text{SPFA}$ 找环，好像是 UVA 一道题忘了![/fad](https://cdn.luogu.com.cn/upload/pic/62250.png)

$\texttt{AC}$ 链接：[$\texttt{Link}$](https://www.luogu.com.cn/record/56142408)

时间复杂度 $O(n\log10^6)$，空间复杂度 $O(n)$。

啥？你说代码？std 不到 $40$ 行你要代码？

$$\texttt{The End.by UF}$$

---

## 作者：Jayun (赞：2)

# [COCI2014-2015#7] PROSJEK：

## 题目大意：

给出包含一个 $N$ 个整数的数组 $A$。找出一段长度至少为 $K$ 的连续序列，最大化它的平均值。

## 思路：

二分答案，考虑到可以以当前平均值是否存在为 key。可以在 check 时将数组 $A$ 全部减去平均值，试图找到一个区间 $[l,r]$ 使得区间和大于零。


## 代码：

```cpp
const int N = 3e5 + 10;

inline ll Read()
{
	ll x = 0, f = 1;
	char c = getchar();
	while (c != '-' && (c < '0' || c > '9')) c = getchar();
	if (c == '-') f = -f, c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x * f;
}

int n, m;
double a[N], sum[N], l, r, mid;

bool check(double x)
{
	bool ans = 0;
	sum[0] = 0;
	for (int i = 1; i <= n; i++) 
		a[i] -= x, sum[i] = a[i] + sum[i - 1];
	double p = 0;
	for (int i = m; i <= n; i++)
	{
		if (sum[i] - p >= 0) {ans = 1; break;}
		p = min(p, sum[i - m + 1]);
	} 
	for (int i = 1; i <= n; i++) 
		a[i] += x;
	return ans;
}

int main()
{
	n = Read(), m = Read();
	for (int i = 1; i <= n; i++) 
		a[i] = Read(), r = max(r, a[i]);
	
	while (r - l > 1e-6)
	{
		mid = (l + r) / 2.0;
		if (check(mid)) l = mid;
		else r = mid;
	}
	
	printf ("%.5lf", l);
	return 0;
}
```

---

## 作者：lanretE (赞：1)

一道二分题。

主函数：
没啥好讲的，左边界取最大值，然后二分子段平均值即可。

check：

本题涉及到子段和，所以我们首先预处理**前缀和**，注意由于是为了验证 $mid$ 而计算，我们在每次加下一个数时减去 $mid$。

根据使用前缀和求最大子段和的思路，我们采用**双指针**，即`sum[j,i]=sum[i]-sum[j]`。此外，验证一个 $mid$ 是否成立我们只需找到一种可行方案，所以我们定义 $minn$ 记录 $sum[j]$ 的最小值，再判断`sum[i]-minn>=0`是否成立，成立就把 $l$ 变为 $mid$，反之则把 $r$ 变为 $mid$。

### 上代码


```
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
double a[300010],sum[300010],maxx=0;
int n,m;
bool check(double mid){
	for(int i=1;i<=n;++i) sum[i]=sum[i-1]+a[i]-mid;
	double minn=0;
	for(int i=m,j=0;i<=n;++i,++j){
		minn=min(sum[j],minn);//找最小值
		if(sum[i]-minn>=0)//只要找到一种方案就说明可行 
			return true;
	}
	return false;//一种方案都找不到 
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>a[i]; 
		maxx=max(a[i],maxx);
	}
	double l=0,r=maxx;
	while(r-l>1e-10){
		double mid=(l+r)/2;
		if(check(mid)) l=mid;
		else r=mid;
	}
	printf("%0.6lf",l);
   	return 0;
}
```


---

## 作者：little_sheep917 (赞：0)

> 有一个由 $n$ 个整数组成的数列 $a$ 。请求出所有长度不少于 $k$ 的子串的平均值最大为多少，保留三位小数。
>
> 注意：某一子串的平均值为子串中所有数的和除以子串的长度。
>
> $1\leq n\leq 3\cdot 10^5,1\leq k\leq n,1\leq a_i\leq 10^6$

如果枚举子串的大小的话，时间复杂度无法做到 $O(\log n)$ 或者 $O(\log^2 n)$ .

因为是平均值，可以考虑二分，二分平均值的大小 . 

这里可以直接二分小数，或者乘以 $10000$ . 我选择后一种 .

那么，对于当前 $mid$ ，枚举子串的右端点 $r$ ，那么左端点 $l$ 满足 $r-k+1\geq l$ ，且 $\frac{\sum\limits_{i=l}^{r} a_i}{r-l+1}\geq mid$ ，就存在一组满足条件的解 . 
$$
\frac{\sum\limits_{i=l}^{r} a_i}{r-l+1}\geq mid\   \longrightarrow\   
\sum\limits_{i=l}^{r}a_i\geq mid(r-l+1)\   \longrightarrow\   
\sum\limits_{i=l}^{r}a_i-mid(r-l+1)\geq 0\   \longrightarrow\   
\sum\limits_{i=l}^{r}(a_i-mid)\geq 0
$$
此时，这是一个以 $r$ 结尾的后缀和，可以直接 $O(n)$ 地解决 . 

这里还有一个问题，就是在我写的时候，发现比如说 $0.755$ 不管是 printf(".3f") 还是 fixed setprecision 都不会进位到 $0.76$ ，但是对于 $0.7555$ 就会，我感到很迷惑. 

时间复杂度 : $O(n\log 10000a_i)$

空间复杂度 : $O(n)$

```c++
#include<bits/stdc++.h>
using namespace std;
const long long inf=1e18+10;
int n,k;
long long a[300010],sum[300010];
inline int read(){
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	int res=0;
	while(ch>='0'&&ch<='9'){
		res=res*10+ch-'0';
		ch=getchar();
	}
	return res;
}
bool check(long long x){
	for(int i=0;i<n;i++)sum[i]=a[i]-x;
	for(int i=1;i<n;i++)sum[i]+=sum[i-1];
	long long mx=-inf;
	for(int i=0;i<n;i++){
		if(mx!=-inf)mx+=a[i]-x;
		if(i+1>=k)mx=max(mx,sum[i]-(i-k>=0?sum[i-k]:0));
		if(mx>=0)return true;
	}
	return false;
}
int main(){
//	freopen("test.txt","r",stdin);
	n=read();k=read();
	for(int i=0;i<n;i++)a[i]=read();
	for(int i=0;i<n;i++)a[i]*=10000ll;
	long long mx=a[0];
	for(int i=1;i<n;i++)mx=max(mx,a[i]);
	long long low=0,high=mx+1,ans=0;
	while(low<high){
		long long mid=(low+high)>>1;
		if(check(mid)){
			ans=max(ans,mid);
			low=mid+1;
		}
		else{
			high=mid;
		}
	}
	printf("%lld",ans/10000);
	int tmp=ans%10,res=ans%10000/10;
	if(tmp%10>=5)res++;
	printf(".");
	vector<int>v;
	for(int i=0;i<3;i++){
		v.push_back(res%10);
		res/=10;
	}
	for(int i=2;i>=0;i--)printf("%d",v[i]);
	printf("\n");
	return 0;
}
/*inline? ll or int? size? min max?*/

```



---


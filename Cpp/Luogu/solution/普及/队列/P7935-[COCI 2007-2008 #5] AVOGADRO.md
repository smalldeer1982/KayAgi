# [COCI 2007/2008 #5] AVOGADRO

## 题目描述

Luka 画了一张 $3$ 行 $N$ 列的表格，然后将整数 $1$ 到 $N$ 写进表格。对于表格第一行，每个整数只出现一次。对于其余两行，每个数字可以出现任意次或者不出现。

Luka 现在可以删去任意一些列。完成后，他对这个表的每一行进行升序排序。

他希望得到一张表，使得表中的三行在升序排序后完全相同。请您求出他至少需要删去多少列。

## 说明/提示

对于 $40\%$ 的测试点，$N\le 100$。

对于 $70\%$ 的测试点，$N\le 10000$。

对于 $100\%$ 的测试点，$1\le N\le 10^5$。

### 样例 1 解释：

对于样例 1，Luka 需要删除第二、第四、第六和第七列。删除并排序后，这三行都只包含 $1,3,5$ 三个整数。

本题分值按照原比赛设置，满分 $60$ 分。

## 样例 #1

### 输入

```
7
5 4 3 2 1 6 7
5 5 1 1 3 4 7
3 7 1 4 5 6 2 ```

### 输出

```
4```

## 样例 #2

### 输入

```
9
1 3 5 9 8 6 2 4 7
2 1 5 6 4 9 3 4 7
3 5 1 9 8 6 2 8 7```

### 输出

```
2```

# 题解

## 作者：_edge_ (赞：19)

一句话题意：

**一个排列和两个序列我简称三个序列。**

给定一个排列，两个序列，在 $1 \sim n$ 范围，每次操作可以删除三个序列里的同一位置的数，求最少删几次可以使得三个序列元素相等(排序之后)。

其实这题目首先一看到就应该要考虑排列的性质即：每个元素仅仅出现一次。

我们发现这个性质很有利，只要我们寻找出两个序列里面不存在的数，在排列里面删除即可，然后发现删除的那个位置，在另外两个序列里面也有删除就这样继续。

至于为什么正确，其实也挺显然的。

考虑当前的三个序列必然数量相同，在数量相同的前提下，有一个是排列，那么如果另外两个序列有了相同的数，必然它没有另外一个数。

那么这样删下去肯定会使得其变为只出现一次或者不出现。

具体的实现可以考虑用队列做。

当然这是一个拓扑的结构，我没有很深入的探究。

均摊意义下复杂度 $O(n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
const int INF=1e5+5;
queue <int> q;
int n,a[INF],b[INF],c[INF],f[INF],f1[INF],f2[INF],vis[INF],ans;
signed main()
{
        scanf("%d",&n);
        for (int i=1; i<=n; i++) scanf("%d",&a[i]),f2[a[i]]=i;
        for (int i=1; i<=n; i++) scanf("%d",&b[i]);
        for (int i=1; i<=n; i++) scanf("%d",&c[i]);
        for (int i=1; i<=n; i++) {f[b[i]]++; f1[c[i]]++;}
        for (int i=1; i<=n; i++)
                if (f[i]==0 || f1[i]==0)
                        q.push(i);
        while (q.size()) {
                int xx=q.front(); q.pop();
                if (vis[f2[xx]]) continue;
                vis[f2[xx]]=1;
                f[b[f2[xx]]]--;
                f1[c[f2[xx]]]--;
                if (f[b[f2[xx]]]==0)
                        q.push(b[f2[xx]]);
                if (f1[c[f2[xx]]]==0)
                        q.push(c[f2[xx]]);
                ans++;
        }
        cout<<ans<<"\n";
        return 0;
}

```

如有问题，还请指出。

---

## 作者：Neil_Qian (赞：9)

## Part I 前言
此题其实有**一定难度**， $n\le10^5$ 会把人吓到，容易**想复杂化**。仔细想一想，其实**没那么复杂**。  
我写题解之前看了看其它几篇题解，都是用拓扑排序的框架（或者说思想）做的，代码量大且容易出错。  
本蒟蒻提供一种新的思路，代码只有 18 行，但请仔细看，理解代码的每一句话。
## Part II 思路
任何一种算法都要知道它大概是怎么想出来的，比如最短路中的动态规划解法。  
首先要**简化题意**。题面有一个地方会让人想复杂。题中说让排序，但仔细想想，真的要排序吗？  
答案是**不需要排序**。你想想，删了数以后只要每个数的数量相等，排了序以后肯定是一样的啊！就和全等三角形一个道理，只要三条边一样，面积肯定也一样。  
**综上所述，只要删除不需要的就行了**。  
或许你会说：“我枚举每列数删不删，在检查一下，会怎样？”  
很遗憾，这是指数级的算法，有可能没有分，但勇气可嘉。  
既然要让剩下的数的数量相等，而第一个序列每个数有且仅有一个，那就在第一个序列中看看这个元素在第二、三个序列中是否存在，只要不存在就把这一列删去。这样操作若干次即可。考虑到 $n\le10^5$ ，再循环 100 次比较合适。
## Part III 注意事项
因为要记录每个数的数量，有些人习惯性用了 map 映射。这道题数都在 $n$ 以内，可以直接上数组，避免 $logn$ 带来的超时。  
一定要对之前所述的操作执行至少 100 次，少了有可能没找全。
## Part IV 代码
说了那么多，上代码！
```cpp
#include<iostream>
#include<cstdio>
#define _for(i,a,b) for(int i=a;i<(int)(b);i++)//不知道自行搜索，注意左闭右开
using namespace std;
int n,a[5][100002],d[100002],now,cnt,ans,c[5][100002];
int main(){
	scanf("%d",&n);
	_for(i,1,4)
		_for(j,1,n+1)scanf("%d",&a[i][j]),c[i][a[i][j]]++;
	_for(T,1,101)//执行若干次
		_for(i,1,n+1)//遍历序列
			if(a[1][i]!=-1)//没有被删除
				if(c[2][a[1][i]]==0||c[3][a[1][i]]==0){//在第二个或第三个中没有第一个
					c[1][a[1][i]]--;c[2][a[2][i]]--;c[3][a[3][i]]--;a[1][i]=-1;//更新并标记为删除
				}
	_for(i,1,n+1)ans+=(a[1][i]==-1);//被删了就累加
	return printf("%d\n",ans),0;//完结撒花
}
```


---

## 作者：ikunTLE (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P7935)

对于表格第一行，每个整数只出现一次。所以我们可以用桶排序找到第二个序列和第三个序列中，哪个数字没有出现过出现，就删掉那个数字。但是由于连锁反应，会影响到后面的数字，所以将要删除的数字放入队列之中。只要队列没空这个数字删除，此过程一直持续。需要注意的是一列不要重复删，需要打标记。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,a[4][N],s[N],e[N],wei[N],ans;
bool vis[N];
queue<int> q;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[1][i]),
		wei[a[1][i]]=i;
	for(int i=1;i<=n;++i)
		scanf("%d",&a[2][i]),
		e[a[2][i]]++;
	for(int i=1;i<=n;++i)
		scanf("%d",&a[3][i]),
		s[a[3][i]]++;
	for(int i=1;i<=n;++i){
		if(!e[i]||!s[i])
			q.push(i);
		while(!q.empty()){
			int del=wei[q.front()];
			if(vis[del]){
				q.pop();
				continue;
			}
			vis[del]=1;
			--e[a[2][del]];
			--s[a[3][del]];
			//确保不会重复删
			if(!e[a[2][del]])
				q.push(a[2][del]);
			if(!s[a[3][del]])
				q.push(a[3][del]);
			ans++;
			q.pop();
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：WsW_ (赞：4)

### 思路：
将第一、二、三行的序列分别称为 $a,b,c$。  
显然，当序列 $a,b,c$ 中剩下的数字相同时，排序后三个序列相同，问题转化成要删除几列使得 $a,b,c$ 中剩下的数字相同。  
题目中保证序列 $a$ 中包含 $1\sim n$ 这 $n$ 个整数，序列 $b,c$ 中的数字在 $1\sim n$ 范围内。显然，序列 $b,c$ 中可能缺少某些数字，对于这些缺少的的数字，必须找到它在序列 $a$ 的位置，并且把它在序列 $a$ 中删除。  
然而，必须整列删除，因此删除时还会删掉序列 $b,c$ 中的数字，可能删了数字后序列 $b,c$ 中又缺少某些数字了，我们再找到它在序列 $a$ 的位置，并且把它在序列 $a$ 中删除即可。  
我选择用队列记录要删除哪些数字，每次弹出队首，并删除队首数字在序列 $a$ 中对应的列，计数器加一。**注意，若这个数字已经被删除过了，跳过即可！** 若这次操作导致序列 $b,c$ 中缺少数字时，把缺少的数字加入队列。  
当队列空时，说明 $b,c$ 中已经不缺少数字了，停止循环，输出计数器中记录的次数。  
### 代码：
```cpp
//代码中i均指该数组中的下标 
#include<bits/stdc++.h>
using namespace std;
struct node{
	int a,b,c;
}s[100003];//在s中，下标代表列
queue<int> del;
int t[100003];//记录数字i在哪一列 
int cntb[100003],cntc[100003];//记录b,c中有几个数字i 
int ans;
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&s[i].a);
		t[s[i].a]=i;
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&s[i].b);
		cntb[s[i].b]++;//在计数器中增加数字s[i].b的数量
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&s[i].c);
		cntc[s[i].c]++;
	}
	for(int i=1;i<=n;i++)
		if(!cntb[i]||!cntc[i])del.push(i);//如果缺少数字i，将其加入队列
	while(!del.empty()){
		int x=del.front();//我们要删掉数字x 
		del.pop();
		if(t[x]==0)continue;//已经删过数字x了，跳过。 
		ans++;
		cntb[s[t[x]].b]--;
		cntc[s[t[x]].c]--;
		if(cntb[s[t[x]].b]==0)del.push(s[t[x]].b);
		if(cntc[s[t[x]].c]==0)del.push(s[t[x]].c);
		t[x]=0;//标记数字x已经被删了 
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：船酱魔王 (赞：4)

# P7935 [COCI2007-2008#5] AVOGADRO 题解

## 题意回顾

有三个长度为 $ n $ 的序列 $ a,b,c $，元素值均在 $ [1,n] $ 之间且 $ a $ 是排列。求出数集 $ D $，满足先 $ \forall x \in D $，删去 $ a_x,b_x,c_x $，之后将剩下的三数列分别排序后三数列完全相同，求出 $ \min{|D|} $。

$ 1 \le n \le 10^5 $。

## 分析

**提示：本题思路难想，但是易懂，因此本题题解会摧毁本题的思考体验。**

我们定义 $ d_i,e_i,f_i $ 代表 $ a,b,c $ 中 $ i $ 出现的次数。

可以发现，$ \forall 1 \le i \le n $，$ d_i=0 $ 或 $ e_i=0 $ 或 $ f_i=0 $ 时，意味着其中一个数列不可能出现 $ i $，因为要求三数列相同所以另外两数列也不可以有数字 $ i $，因此将所有含有数字 $ i $ 的下标元素删除。重复这个过程，最后 $ d_i,e_i,f_i $ 均要不全 $ 0 $，要不非 $ 0 $。此时因为 $ a $ 数组两两不同，所以 $ d_i $ 均为 $ 1 $，易得 $ e_i,f_i $ 也均为 $ 1 $。此时三数列排序后相同。可以使用拓扑排序思想优化这个过程。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int N = 1e5 + 5;
int n;
int a[N];
int b[N];
int c[N];
int ans = 0;
vector<int> g[N];
int vis[N];
int c1[N];
int c2[N];
int c3[N];
queue<int> que;
int isd[N];
void prec(int x) {
    if(isd[x] == 1) {
        return;
    }
    if(c1[x] == 0 || c2[x] == 0 || c3[x] == 0) {
        isd[x] = 1;
        for(int i = 0; i < g[x].size(); i++) {
            que.push(g[x][i]);
        }
    }
}
int main() {
    //freopen("debug.in", "r", stdin);
    //freopen("debug.out", "w", stdout);
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        g[a[i]].push_back(i);
        c1[a[i]]++;
    }
    for(int i = 1; i <= n; i++) {
        scanf("%d", &b[i]);
        g[b[i]].push_back(i);
        c2[b[i]]++;
    }
    for(int i = 1; i <= n; i++) {
        scanf("%d", &c[i]);
        g[c[i]].push_back(i);
        c3[c[i]]++;
    }
    for(int i = 1; i <= n; i++) {
        prec(i);
    }
    int now;
    while(!que.empty()) {
        now = que.front();
        que.pop();
        if(vis[now] == 1) {
            continue;
        }
        vis[now] = 1;
        ans++;
        c1[a[now]]--;
        prec(a[now]);
        c2[b[now]]--;
        prec(b[now]);
        c3[c[now]]--;
        prec(c[now]);
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Ophi (赞：2)

~~蒟蒻第一次写题解，望各位神犇指出缺点~~
# 题意&思路

给定 $1\sim n$ 的排列 $a$，和 $1\sim n$ 的序列 $b$ 和 $c$，求最少删除多少次（删除一次为**同时删除** $a_i$、$b_i$、$c_i$）使得 $a$、$b$、$c$ 中的元素相等。

首先统计 $b$ 和 $c$ 中缺少哪些数，假设 $b$ 中缺少了一个 $x$，那么就要在 $a$ 中找到 $x$ 并把那一整列删除。如果这次删除导致了 $b$ 或 $c$ 中新增了缺少的元素，也要执行上面的删除步骤。**需要注意：如果删除过了 $x$ 后面就不能再删 $x$，否则 $a$ 中就会没有 $x$ 删。** 重复上述过程直到 $a$、$b$ 和 $c$ 中的元素相同。

我们可以使用一个顺序表来存储缺少的数字，队列自然最优。当队列为空时说明 $b$ 和 $c$ 相对 $a$ 不再缺少元素，此时就输出删除的次数，程序结束。

复杂度方面是 $O(n)$ 级别的，虽然常数很大但 $10^5$ 的数据范围对于 $O(n)$ 还是很友好的，不会超时。

# *AC Code*

实现时需要作不少的预处理，如记录下 $1\sim n$ 在 $a$ 中的位置，$b$ 和 $c$ 中数字出现的次数等。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=1e5+5;
ll n,a[N],mp[N],b[N],c[N],cb[N],cc[N],ans;
// mp表示1~n在a中的位置，cb和cc分别表示b和c中数字出现的次数
queue<ll> q;
int main(){
    scanf("%lld",&n);
    for(ll i=1;i<=n;i++)
        scanf("%lld",&a[i]),mp[a[i]]=i;
    for(ll i=1;i<=n;i++)
        scanf("%lld",&b[i]),cb[b[i]]++;
    for(ll i=1;i<=n;i++)
        scanf("%lld",&c[i]),cc[c[i]]++;
    for(ll i=1;i<=n;i++)
        if(cb[i]==0||cc[i]==0)
            q.push(i); // 将初始缺少的数字添加到队列中
    while(!q.empty()){
        ll k=q.front(); // 取出队首
        q.pop();
        if(mp[k]!=-1){ // 当队首没有被删除过
            ans++; 
            cb[b[mp[k]]]--,cc[c[mp[k]]]--; // 将对应列b和c中的元素删除
            // 如果这次删除造成了b或c中缺少了数字，就将缺少的数字加入队列中
            if(cb[b[mp[k]]]==0)
                q.push(b[mp[k]]);
            if(cc[c[mp[k]]]==0)
                q.push(c[mp[k]]);
            mp[k]=-1; // 记录k被删除过了
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：AndyPomeloMars (赞：1)

## P7935 [COCI2007-2008#5] AVOGADRO

### 题目大意

* 给你一个 $3$ 行 $N$ 列的表格，将整数 $1$ 到 $N$ 写进表格。对于表格第一行，每个整数只出现一次。对于其余两行，每个数字可以出现任意次或者不出现。

* 请你求出至少需要删去多少列后，使得表中的三行在升序排序后完全相同。

* 对于 $100\%$ 的测试点，$1\le N\le 10^5$。

### 题目分析

注：下面三个序列分别由：序列 $A$，序列 $B$，序列 $C$ 来代替。

题目中给出一个非常有用的性质：**每个元素仅仅出现一次**。

所以我们只要寻找出 序列 $B$、序列 $C$ 里面不存在在 $1$ 到 $N$ 的数，将它们在序列 $A$ 里面删除。

删除整列后，序列 $B$、序列 $C$ 又会出现一些空缺的数，然后我们重复上面的步骤即可。

我们可以使用一个队列（`queue`）来进行操作：

1. 首先记录需要删除哪些数（进入队列）。

2. 当队列不为空时弹出队首，并删除队首数字在序列 $A$ 中对应的一列，并将 $ANS$ 加一（如果这个数字已经被删除过了，直接跳过 `continue`）。

3. 重复以上过程。

### 题目代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100010;

int N, ANS;
int A[MAXN], B[MAXN], C[MAXN], rec[MAXN], cntB[MAXN], cntC[MAXN]; // A、B、C 三个序列，rec记录数字在哪一列，cntB、cntC 记录在序列 B、C 中出现过的数字
queue<int> Q; // 队列 queue 负责删除

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> N; // 读入 N
    for (int i = 1; i <= N; ++i) cin >> A[i], rec[A[i]] = i; // 读入序列 A，并记录 A[i] 在哪一列
    for (int i = 1; i <= N; ++i) cin >> B[i], ++cntB[B[i]]; // 读入序列 B，并记录 B[i] 出现次数
    for (int i = 1; i <= N; ++i) cin >> C[i], ++cntC[C[i]]; // 读入序列 C，并记录 C[i] 出现次数
    for (int i = 1; i <= N; ++i) if (!cntB[i] || !cntC[i]) Q.push(i); // 将 cntB 或 cntC 中不存在的数弹入队尾
    while (!Q.empty()){
        int x = Q.front();
        Q.pop();
        if (!rec[x]) continue; // 如果这个数字已经被删除过了，直接跳过 `continue`
        ++ANS; // ANS 加一
        --cntB[B[rec[x]]], --cntC[C[rec[x]]]; // 删除队首数字在序列 A 中对应的一列
        if (!cntB[B[rec[x]]]) Q.push(B[rec[x]]);
        if (!cntC[C[rec[x]]]) Q.push(C[rec[x]]); // 如果序列 B、C 中还有未删除的数，再将它们弹入队尾
        rec[x] = 0; // 标记为删除过了
    }
    cout << ANS << endl; // 输出 ANS
    return 0;
}
```


---

## 作者：emo_male_god (赞：1)

### 题目大意
给你三个长度为 $n$ 的序列（以下我称为 $a,b,c$ 这三个序列），要求：**最少删除多少列之后使得在 $a$，$b$，$c$ 三个序列中，每个数字出现的次数相等**。

### 贪心思路
在输入时用**桶**给每个序列记个数（以下我用 $ca$，$cb$，$cc$ 表示），然后在遍历 $a$ 序列时，如果这个数 $a$ 有，但是 $b$ 或者 $c$ 没有，就得删除。

删除是一整列的删，要把这 3 个数在 $a$，$b$，$c$ 中出现的次数减去。

要注意的是：一列里可能会有本身就合法的数，为了删去不合法的数，这些合法的也会被删去，使得 3 个序列还是不相同。怎么办呢？只能继续删。

所以我们进行多次删除。其实很简单，无脑重复很多次次上述遍历数组 $a$ 的操作，知道遍历一次数组不会再发生删除操作。

这道题就解决了。

### Code
```cpp
#include <iostream>

using namespace std;

const int N = 1e5 + 5;
int n, ans, a[N], b[N], c[N], ca[N], cb[N], cc[N];

int main()
{
	//	freopen("table.in", "r", stdin);
	//	freopen("table.out", "w", stdout);
	
	scanf("%d", &n);
	
	for (int i = 1; i <= n; i ++ )
	{
		scanf("%d", &a[i]);//输入并给a数组计数
		ca[a[i]] ++ ;
	}
	
	for (int i = 1; i <= n; i ++ )
	{
		scanf("%d", &b[i]);//输入并给b数组计数
		cb[b[i]] ++ ;
	}
	
	for (int i = 1; i <= n; i ++ )
	{
		scanf("%d", &c[i]);//输入并给c数组计数
		cc[c[i]] ++ ;
	}
	
	int temp = 100;
	while (temp -- )//重复执行100次，反复确认
	{
		for (int i = 1; i <= n; i ++ )//遍历a数组
		{
			if (a[i] != -1 && (cb[a[i]] == 0 || cc[a[i]] == 0))//如果这个数在a数组中没被删掉并且在b和c数组中没有出现，就要删除
			{
				ca[a[i]] -- ;
				cb[b[i]] -- ;
				cc[c[i]] -- ;
				a[i] = -1;
			}
		}
	}
	for (int i = 1; i <= n; i ++ ) ans += (a[i] == -1);//如果这个数被删除了，ans ++
	printf("%d\n", ans);
	return 0;
}
```
如果还不懂可以私聊我。

---

## 作者：杨岛主杨东润 (赞：1)

不算特别难的一道黄题。

话不多说，直接上解法。

### 具体解法：
第一步，先把 $n$ 和三行输入。

注意我们要先保存一下第一行，作为标准。

接下来，我们就用一个 $for$ 循环，计算一下最少需要删除几行

当然了，这里是有一些技巧的：

我们可以用一个队列存数据，避免 TLE，把复杂度降到 $On$
这样子的话，最后输出 $sum$,然后就结束了！

### 代码实现：
不要抄袭哦！

```
#include<bits/stdc++.h>//省心的万能头 
using namespace std;
queue<int>q;//队列 
int a[100006],b[100006],c[100006],d[100006],e[100006],f[100006],check[100006];//所有要用到的数组 
int main()
{
    int n;
    cin>>n;//输入 
    for(int i=1;i<=n;i++){
        cin>>a[i];
        f[a[i]]=i;//保存一下 
    }
    for(int i=1;i<=n;i++){
        cin>>b[i];
    }
    for(int i=1;i<=n;i++){
        cin>>c[i];
    }
    for(int i=1;i<=n;i++) {
        d[b[i]]++; 
        e[c[i]]++;
    }
    int sum=0;//计数器sum 
    for(int i=1;i<=n;i++){ 
        if(d[i]==0||e[i]==0){ //如果两个都是0，那么放到q里面 
            q.push(i);
        }
        while(!q.empty()){//来一个while循环一下 
            int p=q.front();
            q.pop();//一次去一位 
            if(check[f[p]]){
                continue;//如果是0就跳过 
            }
            check[f[p]]=1;
            d[b[f[p]]]--;//清理 
            e[c[f[p]]]--;//清理 
            if(d[b[f[p]]]==0){
                q.push(b[f[p]]);
            }
            if(e[c[f[p]]]==0){
                q.push(c[f[p]]);
            }
            sum++;//计数器++ 
        }
    }
    while(1){
        //还是，防止抄袭工作 
    }
    cout<<sum;//输出 
    return 0;//结束啦！ 
}
  ```
谢谢观看！
  

---

## 作者：lovely_qiqi (赞：0)

## 思路

小模拟题。

容易发现一个性质：假如一个数在第一行出现了，但它在第二行或者第三行没有出现，则说明它不能留下了。

于是思路产生了：

遍历每一列，如果它满足上面的性质，则删除这一行，重复这个过程直到删除不了为止。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool flag,book[100010];
int n,ans,a[100010],b[100010],c[100010],t1[100010],t2[100010];
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]),t1[b[i]]++;
	for(int i=1;i<=n;i++) scanf("%d",&c[i]),t2[c[i]]++;
	while(ans<n){
		flag=false;
		for(int i=1;i<=n;i++){
			if(book[i]==false&&(t1[a[i]]==0||t2[a[i]]==0)){
				t1[b[i]]--;
				t2[c[i]]--;
				ans++;
				flag=true;
				book[i]=true;
			}
		}
		if(flag==false) break;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

给定一个整数 $n$ 和 $3$ 个长度为 $n$ 的序列 $a,b,c$，保证 $a$ 是 $1 \dots n$ 的一种排列组合方式，$b,c$ 则不保证。需要求出至少在删除多少列之后，$a,b,c$ 中还保留的元素在经过排序后相等。

## Part 2 引入

相信大家对拓扑排序都不陌生，本题运用到拓扑思想，具体如下。

既然 $a$ 是 $1 \dots n$ 的一种排列组合方式，那我们可以从 $b,c$ 下手。我们发现：

- 如果 $b$ 中没有元素 $i$，那 $a$ 中元素 $i$ 所在的一列必定会被删除。

- 如果 $c$ 中没有元素 $j$，那 $a$ 中元素 $j$ 所在的一列必定会被删除。

这是因为，$b,c$ 在没有元素 $i,j$ 的前提下，排序之后依旧没有 $i,j$。而 $a$ 中又必定存在 $i,j$，就会与我们的目标发生冲突。

进一步我们又发现，如果我们删除 $b_i$，也将删除 $a_i,c_i$，当 $c_i$ 是元素 $j$ 唯一一次在 $c$ 中出现的时候，又有要新删除的列出现了。

很显然，这便是拓扑思想的应用。

## Part 3 思路

首先，在符合条件时，要删除 $a$ 中元素 $i$ 所在的一列，因此我们要先用一个数组储存元素 $i$ 在 $a$ 中的位置。

其次，我们要记录每个元素在 $b,c$ 中出现的次数，如果发现某个元素不在 $b$ 或 $c$ 中出现，那我们就要删除该元素在 $a$ 中的那一列。

最后，我们不能频繁的删除同一列，故需要记录每一列是否被删除过。

## Part 4 代码

```
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,a[maxn],b[maxn],c[maxn],d[maxn],e[maxn],f[maxn],result;
bool cmp[maxn];
queue<int> que;
inline int read()
{
	int x=0,y=1;
	char ch=getchar();
	while (ch<'0' || ch>'9')
	{
		if (ch=='-') y=-1;ch=getchar();
	}
	while (ch>='0' && ch<='9')
	{
		x=x*10+int(ch-'0');ch=getchar();
	}
	return x*y;
}
int main()
{
	n=read();
	for (int i=1;i<=n;i++) a[i]=read(),d[a[i]]=i;
	for (int i=1;i<=n;i++) b[i]=read(),e[b[i]]++;
	for (int i=1;i<=n;i++) c[i]=read(),f[c[i]]++;
	for (int i=1;i<=n;i++)
	{
		if (e[i]==0 || f[i]==0) que.push(i);
	}
	while (!que.empty())
	{
		int sum=que.front();
		que.pop();
		if (cmp[d[sum]]) continue;
		cmp[d[sum]]=true;
		if (--e[b[d[sum]]]==0) que.push(b[d[sum]]);
		if (--f[c[d[sum]]]==0) que.push(c[d[sum]]);
		result++;
	}
	cout<<result;
	return 0;
}
```

---


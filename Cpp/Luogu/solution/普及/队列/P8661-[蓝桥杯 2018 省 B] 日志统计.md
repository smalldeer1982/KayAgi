# [蓝桥杯 2018 省 B] 日志统计

## 题目描述

小明维护着一个程序员论坛。现在他收集了一份“点赞”日志，日志共有 $N$ 行。其中每一行的格式是 `ts id`，表示在 $ts$ 时刻编号 $id$ 的帖子收到一个“赞”。

现在小明想统计有哪些帖子曾经是“热帖”。如果一个帖子曾在任意一个长度为 $D$ 的时间段内收到不少于 $K$ 个赞，小明就认为这个帖子曾是“热帖”。

具体来说，如果存在某个时刻 $T$ 满足该帖在 $[T,T+D)$ 这段时间内（注意是左闭右开区间）收到不少于 $K$ 个赞，该帖就曾是“热帖”。

给定日志，请你帮助小明统计出所有曾是“热帖”的帖子编号。

## 说明/提示

对于 $50\%$ 的数据，$1 \le K \le N \le 1000$。

对于 $100\%$ 的数据，$1 \le K \le N \le 10^5$，$0 \le id, ts \le 10^5$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛

## 样例 #1

### 输入

```
7 10 2  
0 1  
0 10    
10 10  
10 1  
9 1
100 3  
100 3  ```

### 输出

```
1  
3  ```

# 题解

## 作者：jb123456 (赞：16)

暴力
排序把每个 $id$ 相同的找出，用指针记录相同时间最后位置都成立的位置。
因为排序把 $ts$ 按从小到大排序过了，所以不需要考虑 $ts$ 的大小。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct o{
	int a,b;
}a[100005];
int n,d,k;
int cmp(o x,o y){
	if(x.b!=y.b)return x.b<y.b;
	return x.a<y.a;
}
int f1(int x,int y){
	int r=x;
	for(int i=x;i<=y;i++){
		while(a[r+1].a-a[i].a<d&&r<y)r++;//找最后一个时间和位置都成立的位置
		if(r-i+1>=k)return 1;//判断位置是i时是否是热帖
	}
	return 0;
}
int main()
{
	cin>>n>>d>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].a>>a[i].b;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		int r=i;
		while(a[r+1].b==a[i].b)r++;//找到最后一个id相同的位置 
		if(f1(i,r)){//判断i到r可不可以是热帖 
			cout<<a[i].b<<endl;
		}
		i=r;
	}
	return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P8661)

### 算法 && 前置芝士

单调队列（滑动窗口）（[模板，和此题差不多](https://www.luogu.com.cn/problem/P1886)）

结构体排序（更简单的优化？）

### 解题思路

```
如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞
```

看到这个，很容易想到滑动窗口来做。**$D$ 其实就是窗口长度。并且可以发现，只要头尾元素的长度到达了 $K$，就可以直接出结果。**

但是仔细观察可以发现，输入数据是无序的，对于每一个帖子，我们都需要建立一个单调队列并单独处理。空间码量可能都会炸掉，还可能出现一些奇怪的错误。

但是，如果这些数据是有序的呢？**如果这些数据是按帖子的编号从大到小和同编号的时间排序的呢？** 在这种情况下，我们只需每一段单独用处理即可。因为每一段是连续的，只需要一个单调队列重复使用。

很容易想到，上述问题可以直接使用结构体排序来完成。即 **先按照编号大小，编号相同按时间排序**。得到一个编号时间都递增的数据序列。

### 代码参考

代码实现很简单，最重要的地方就是对滑动窗口的掌握和每一段的截取两点。

~~模板题就算了吧，至少要看一遍掌握思路（懂得都懂）~~

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,d,k;
int l=1,head,tail,que[100050];//l是这一段的开头
struct Zan{
	int ts,id;
	bool operator <(const Zan &a)const{
		if(id!=a.id)return id<a.id;
		return ts<a.ts;
	}//当然可以用构造比较函数 cmp，但是个人更加喜欢重载运算符
}z[100050];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//关闭流同步好习惯
	cin>>n>>d>>k;
	for(int i=1;i<=n;i++)cin>>z[i].ts>>z[i].id;
	sort(z+1,z+n+1);
	for(int i=1;i<=n;i++){
		while(z[l].id==z[i].id)i++;
		i--;//循环找到第一个不处于这一段的，此时i为下一段的开头，为了方便减去一
		head=1;
		tail=0;
		memset(que,0,sizeof(que));//每一段都要初始化
		for(int j=l;j<=i;j++){
			while(head<=tail&&z[que[head]].ts+d<=z[j].ts)head++;//消除队头不满足的元素
			que[++tail]=j;//进队
			if(tail-head+1>=k){//满足要求直接输出，因为已经按编号排好
				cout<<z[l].id<<'\n';
				l=i+1;//更新端点，在下一个循环，i也会加一变成和l一样，在for循环开头的while循环一样可以找到末端点
				break;
			}
			if(j==i)l=i+1;//没有找到也要更新端点
		}//单调队列模板
	}
	return 0;
} 
```


---

## 作者：Withershine (赞：7)

~~好久没写题解了，水一篇~~。

这里主要想讲的是不同的处理方法，在阅读本篇题解前请确保读完题。

## 详解
### 一，排序
这很好理解，题目要求将热帖从小到大输出，同时题目中还有相对的时间这一概念，因此将输入的 $id$ 与 $ts$ 按照优先 $id$ 其次 $ts$ 的排序方式从小到大，排序，这样输出时就没必要刻意去处理顺序。
### 二，分段
为了将每一个帖子（编号不同）区分开，额外增设三个数组 $L$，$R$，$ide$ 与变量 $block$ 分别表示**在排完序后**的序列中共有数量为 $block$ 的帖子，对于每一个 $L_i$ 与 $R_i$，分别表示第 $i$ 个热帖在序列中从 $L_i$ 开始到 $R_i$ 结束，并且第 $i$ 个帖子的编号为 $ide_i$。请注意区分这里第 $i$ 个帖子与第 $i$ 个帖子的编号的区别。
#### 部分分段代码展示
```cpp
sort(s + 1 , s + n + 1 , cmp);
s[0].id = s[n + 1].id = -1;
fr(i , 1 , n)
{
	if(s[i].id != s[i - 1].id)
	{
		R[block] = i - 1;
		L[++block] = i;
		ide[block] = s[i].id;
	}
}
R[block] = n;
```
注意这里 `s[0].id = s[n + 1].id = -1;` 的目的是为了防止序列中有**零**这一编号的存在导致存储出现错误（不加只有八十八分）。最后补齐 $R_{block}$。
### 三，输出
在进行了上面的处理了，输出就变得非常简单了。只需要从 $1$ 到 $block$ 遍历一遍所有编号的帖子，判断是否是热帖即可。
### 四，判断是否为热帖
想必大家都会[单调队列](https://zhuanlan.zhihu.com/p/346354943)吧。不会的话给大家推荐一篇。
而这里我们只需要执行出队操作，将超过时限的点赞消息踢出队列即可，非常简单。
## 代码
```cpp
#include<bits/stdc++.h>
#define ll int
#define mod 100000000
#define fr(i , a , b) for(ll i = a ; i <= b ; ++i)
#define fo(i , a , b) for(ll i = a ; i >= b ; --i)
using namespace std;
ll n , d , k;
struct node
{
	ll ts , id;
}s[100005];
inline bool cmp(node x , node y)
{
	return (x.id != y.id) ? x.id < y.id : x.ts < y.ts;
}
ll L[100005] , R[100005] , block;
ll ide[100005];
ll q[100005];
inline void max_deque(ll l , ll r , ll now_block)
{
	ll head = 1 , tail = 0;
	fr(i , l , r)
	{
		while(head <= tail && q[head] + d <= s[i].ts)
		{
            head++;
		}
		q[++tail] = s[i].ts;
		if(tail - head + 1 >= k)
		{
			cout << now_block << '\n'; 
			return;
		}
	}
}
signed main()
{
//	freopen("data.in","r",stdin);
//	freopen("data.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> d >> k;
	fr(i , 1 , n)
	{
		cin >> s[i].ts >> s[i].id;
	}
	sort(s + 1 , s + n + 1 , cmp);
	s[0].id = s[n + 1].id = -1;
	fr(i , 1 , n)
	{
		if(s[i].id != s[i - 1].id)
		{
			R[block] = i - 1;
			L[++block] = i;
			ide[block] = s[i].id;
		}
	}
	R[block] = n;
//	fr(i , 1 , n)
//	{
//		cout << s[i].ts << ' ' << s[i].id << '\n';
//	}
	fr(i , 1 , block)
	{
//		cout << L[i] << ' ' << R[i] << ' ' << ide[i] << '\n';
		max_deque(L[i] , R[i] , ide[i]);
	}
	return 0;
}
```


---

## 作者：wsx248 (赞：6)

由于题目要求判断某个帖子是否在 $[T, T+D)$ 时间内被点赞至少 $k$ 次，自然而然地想到可以按时间排序，分别统计每个帖子被点赞的时间，然后用双指针或滑动窗口的方式去统计在限定时间段内被点赞的次数。

具体可以看代码注释。

```
#include<iostream>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
const int N = 1e5+5;
int n, d, k;
vector<int> id[N];	//存储所有帖子的点赞时间 
int mi = 1e6, mx = 0;
int q[N], fr, ed;	//采取滑动窗口的思想，记录符合条件的时间 

inline void read(int &num)
{
	num = 0;
	char ch = getchar();
	while(!isdigit(ch))
		ch = getchar();
	while(isdigit(ch))
	{
		num = (num<<1) + (num<<3) + (ch^48);
		ch = getchar();
	}
}

int main()
{
	read(n), read(d), read(k);
	for(int i=1;i<=n;i++)
	{
		int t, x;
		read(t), read(x);
		id[x].push_back(t);
		mi = min(mi, x);
		mx = max(mx, x);
	}
	for(int i=mi;i<=mx;i++)
		sort(id[i].begin(), id[i].end());	//对所有帖子的点赞时间进行排序 
	
	for(int i=mi;i<=mx;i++)
	{
		fr = 1, ed = 0;	//重置头尾指针 
		q[fr] = 0; //相当于清空队列 
		bool flg = 0;
		for(auto j:id[i])
		{
			if(fr<=ed && j>=q[fr]+d)
				fr++;
			q[++ed] = j;
			if(ed-fr+1>=k)	//只要满足了条件就可以直接break 
			{
				flg = 1;
				break;
			}
		}
		if(flg)
			printf("%d\n", i);
	}
	return 0;
}
```

---

## 作者：A_Bit_Cold (赞：5)

题目链接：[P8661 [蓝桥杯 2018 省 B] 日志统计](https://www.luogu.com.cn/problem/P8661#submit)

这道题的主要思路是单调队列，首先，题目没有给出共有多少个帖子，我们需要求出最大帖子的编号 $maxn=\max(id_1,id_2,id_3,...,id_{n-1},id_n)$。

要按时间排序，因为这样能保证单调队列的单调。

然后，我们开始思考怎样用单调队列解决此题，因为帖子的 $id$ 是不一样的，所以考虑用 $n$ 个队列，第 $i$ 个单调队列中记录编号为 $i$ 的热帖。

接着，为了判断之前的帖子是否过时，要将当前帖子和队首帖子的时间的差是否大于等于 $D$，如果是，就出队。

如果这个队列的长度大于等于 $K$，则说明在某时刻满足该帖 $[T,T+D)$ 这段时间内收到不少于 $K$ 个赞，即这个贴是热帖，为了不让热帖编号重复输出，弄一个 $f$ 数组记录一下这个贴是热帖。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
struct node {
	int ts;
	int id;
} a[N];
bool f[N];
bool cmp(node x,node y) {//排序
	if(x.ts!=y.ts) return x.ts<y.ts;
	return x.id<y.id;
}
deque <int> q[N];
int main() {
    int n,d,k,maxn=0;
    cin>>n>>d>>k;
    for(int i=1;i<=n;i++) {
		cin>>a[i].ts>>a[i].id;
		maxn=max(maxn,a[i].id);//最大编号
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) {
		q[a[i].id].push_back(a[i].ts);//入队
		while(!q[a[i].id].empty()&&a[i].ts-q[a[i].id].front()>=d) q[a[i].id].pop_front();//如果过时，出队
		if(q[a[i].id].size()>=k) f[a[i].id]=1;//这个贴是热帖
	}
	for(int i=0;i<=maxn;i++) {
		if(f[i]) cout<<i<<"\n";//输出热帖编号
	}
    return 0;
}
```


---

## 作者：5k_sync_closer (赞：4)

别的题解好像都带 $\log$，来个 $O(n)$ 的。

扫描时间轴，对当前时间 $i$ 维护 $(i-d,i]$ 时刻每个帖子 $j$ 的获赞数 $c_j$。

维护 $v_i$ 表示 $i$ 时间获赞的帖子，扫描到 $i$ 时刻时 $\forall j\in v_{i-d},c_j\gets c_j-1$，然后 $\forall j\in v_i,c_j\gets c_j+1$，边加边统计 $c_j\ge k$ 的 $j$。

```cpp
#include <cstdio>
#include <vector>
using namespace std;
int n, d, k, c[100050];
bool b[100050];
vector<int> v[100050];
int main()
{
    scanf("%d%d%d", &n, &d, &k);
    for (int i = 1, x, y; i <= n; ++i)
        scanf("%d%d", &x, &y), v[x].push_back(y);
    for (int i = 0; i <= 1e5; ++i)
    {
        if (i >= d)
            for (auto j : v[i - d])
                --c[j];
        for (auto j : v[i])
            if (++c[j] >= k)
                b[j] = 1;
    }
    for (int i = 0; i <= 1e5; ++i)
        if (b[i])
            printf("%d\n", i);
    return 0;
}
```


---

## 作者：Wy_x (赞：4)

题目传送门：[P8661 [蓝桥杯 2018 省 B] 日志统计](https://www.luogu.com.cn/problem/P8661)

提供一个与其他题解都不同的做法。


## 思路：

1. 先把输入的日志先按编号从小到大排序，编号相同再按时间从小到大排序。

2. 在排过序的结构体中，从 $1$ 到 $n$ 枚举区间右端点 $r$，以帖子曾经是“热帖”的最小区间长度（最小点赞数）$k$ 确定区间左端点 $l=r-k+1$，判断几种情况:
> - 若 $l<1$，则不存在该区间，该区间非法；
> - 若 $l$ 所属帖子的编号与 $r$ 所属帖子的编号不同，该区间非法；
> - 若 $l$ 所属帖子的点赞时间与 $r$ 所属帖子的点赞时间相差不小于 $d$（大于等于 $d$），该区间非法；
> - 若这个帖子已经被评为热帖（这个帖子的编号被输出过），该区间非法。

若这个区间以上任何一个条件都不满足，则这个区间合法，输出这个帖子的编号（$r$ 所属帖子的编号）。

同时，这种输出方法也满足按从小到大的顺序输出热帖 $id$。

## Code：

[AC 记录](https://www.luogu.com.cn/record/list?pid=P8661&user=735416)

------------

### 无注释

[P8661 Code](https://www.luogu.com.cn/paste/961je9m3)


------------

### 有注释

```cpp
#include<bits/stdc++.h>

using namespace std; 

int n,d,k;//题意

struct node { int t,id; } a[1<<20]; //结构体存
bool cmp(node x,node y) { return x.id<y.id||(x.id==y.id&&x.t<y.t); }
//对结构体 node 进行排序：
//先按编号从小到大排序，编号相同再按时间从小到大排序

bool vis[1<<20]; //记录编号是否输出过

signed main()
{
	cin>>n>>d>>k; //输入
    for(int i=1;i<=n;i++) cin>>a[i].t>>a[i].id; //输入

    sort(a+1,a+1+n,cmp);//排序

    for(int i=1;i<=n;i++)//枚举右端点
    {   
        int l=i-k+1,r=i;
        //枚举区间 [l(i-k+1),r(i)]，保证此区间点赞数恒为 k

        if(l<1) continue;
        //如果 l 不合法（比一小），开始下一次循环

        if(a[l].id!=a[r].id) continue;
        //如果 l 与 r 所属帖子 id 不同，此区间不合法，开始下一次循环

        if(a[r].t-a[l].t>=d) continue;
        //如果两次点赞时间间隔 >= d，此区间不合法，开始下一次循环

        if(vis[a[l].id]) continue;
        //如果这个 id 被记录过（被输出过），开始下一次循环

        //合法情况
        cout<<a[l].id<<endl; //输出
        vis[a[l].id]=1; //记录
    }
	return 0;
}

```

---

## 作者：Zaku (赞：4)

### 解法
暴力做法很显然。

在求某段时间区间内的赞数时，前一区间和后一区间有大部分是存在重复的：

![](https://cdn.luogu.com.cn/upload/image_hosting/52yis6w8.png)

假设我们已经统计了上面区间的赞数，那我统计下面区间的赞数，可以直接把开头去掉，把结尾加上：

![](https://cdn.luogu.com.cn/upload/image_hosting/wqrjqupe.png)

这种做法就是双指针。

在使用双指针时，要注意对所有的博客记录按时间从小到大先排好顺序，因为在有序的区间内才能使用双指针记录两个区间相差，相当于把一个有序的时间序列进行每次递增 $1$ 的划分。

所以，这里我用划分来理解所用的双指针，也就是不能把双指针看作是在所有数据内访问，应该是在一个个被细分的符合要求的时间区间内访问。

使用 while 循环做的工作就是维护时间区间。若 $i$ 前移过程中超出了时间区间 $D$，$j$ 就向前移，找到符合要求的下一个区间位置。

并且要退回之前的 $cnt$，也就是在 while 循环里，先执行 ```cnt[j] --```，再进行 ```j ++```。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, d, k;
int cnt[N];//用于存储每个id号获得赞数
struct node{int ts, id;}a[N];//用于存储日志ts, id
bool st[N]; //用于存储每个帖子是否是热帖
int main(){
    cin >> n >> d >> k;
    for (int i = 0; i < n; i ++ ) 
		scanf("%d%d", &a[i].ts, &a[i].id);
    sort(a, a + n);
    for (int i = 0, j = 0; i < n; i ++ ){//双指针算法，i在前，j在后
        cnt[a[i].id] ++;//i获得一个赞，所以此刻 ++
        while (a[i].ts - a[j].ts >= d){//如果俩个帖子时间相差超过d，说明该赞无效
            cnt[a[j].id] --;
            j ++;//要把指针j往后，否则死循环
        }
        if (cnt[a[i].id] >= k) //如果该id贴赞超过k，说明是热帖
			st[a[i].id] = true;
    }
    for (int i = 0; i < N; i ++ ) 
		if(st[i]) printf("%d\n",i);
    return 0;  
}
```

---

## 作者：technopolis_2085 (赞：3)

分析：

一道模拟题。

设当前被“赞”的帖子的编号是 $id$，时间是 $t$。

先弹出队列里所有时间小于等于 $t-D$ 的，因为这些“赞”和当前的“赞”无联系了。

然后将 $id$ 的赞数加 $1$，并将它放入队列里。

具体细节看代码吧。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;

struct node//记录每一个赞
{
	int t;//时间
	int num;//帖子编号
	
	bool operator <(const node &cmp) const
	{
		return t<cmp.t;//按时间从小到大排序
	}
};

const int maxn=1e5+10;
node a[maxn];
int cnt[maxn];
bool ans[maxn];

int main()
{
	int n,d,k;
	scanf("%d%d%d",&n,&d,&k);
	
	for (int i=1;i<=n;i++) scanf("%d%d",&a[i].t,&a[i].num);
	
	sort(a+1,a+1+n);
	
	queue<int> q;
	while (!q.empty()) q.pop();
	
	for (int i=1;i<=n;i++)
	{
		while (!q.empty()&&a[q.front()].t+d<=a[i].t)
		{//将时间小于等于 a[i].t-d的弹出
			cnt[a[q.front()].num]--;//该帖子的赞的数量减1
			q.pop();
		}
		
		q.push(i);//将第i个赞入队列
		cnt[a[i].num]++;//该帖子的赞加1
		
		if (cnt[a[i].num]>=k) ans[a[i].num]=true;//如果赞的数量大于等于k，则该帖子是热帖
	}
	
	for (int i=0;i<=1e5;i++)
	{
		if (ans[i]) printf("%d\n",i); 
	}
	return 0;
}
```


---

## 作者：minVan (赞：1)

**题目大意**

第 $\text{id}$ 个帖子在 $\text{ts}$ 时刻收到了一个赞。

第 $\text{id}$ 个帖子是否为热帖取决于是否存在 $t$ 使得在 $t$ 至 $t+d$ 这段时间内收到了大于等于 $k$ 个赞。

**解题思路**

先将原数组排序，把所有 $\text{id}$ 相同的最后位置记录下来，而又因为我们已经排过序了，所以就不用考虑时刻的大小。

这种算法可以认为是暴力加排序。

**AC 代码，请勿抄袭**

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node {
    int ts, id;
} a[100005];
int n, d, k;
inline int cmp(node x, node y) {
    if (x.id != y.id) {
        return x.id < y.id;
	}
    return x.ts < y.ts;
}
inline bool check(int x, int y) {
    int r = x;
    for (int i = x; i <= y; i++) {
        while (a[r + 1].ts - a[i].ts < d && r < y) {
            r++;
		} if (r - i + 1 >= k) {
            return 1;
		}
    }
    return 0;
}
int main() {
    cin >> n >> d >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].ts >> a[i].id;
    }
    sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= n; i++) {
        int tmp = i;
        while (a[tmp + 1].id == a[i].id) {
            ++tmp;
		}
        if (check(i, tmp)) {
            cout << a[i].id << '\n';
        }
        i = tmp;
    }
    return 0;
}
```

---


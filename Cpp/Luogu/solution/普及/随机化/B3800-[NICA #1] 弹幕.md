# [NICA #1] 弹幕

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/d7u8mpld.png)

## 题目描述

某款弹幕游戏的 BOSS 会放出弹幕攻击玩家（自机）。由于这些弹幕的行动轨迹十分诡异，因此现在希望找到一个「安定点」（只要呆在这个位置就不会被任何弹幕打到的地方）

假定空中有 $n$ 道弹幕。我们用三元组 $(a_i,b_i,c_i)$ 描述每一个弹幕的参数。我们认为自机在一条标着 $0,1,2,\cdots,10^6$ 的数轴上，且只能处于**整点**处。

假定自机位于坐标为 $x$ 的位置。那么自机会被第 $i$ 枚弹幕打到，当且仅当 $x^3+a_ix^2+b_ix+c_i=0$。

现在你需要求出**任意**一个 $x$，使得自机不会被任何一个弹幕打中。你需要保证求出来的 $x$ 在 $[0,10^6]$ 之内。

## 说明/提示

### 样例解释

- 第一枚弹幕只会打到位于 $0$ 位置的自机；
- 第二枚弹幕只会打到位于 $1$ 位置的自机；
- 第三枚弹幕只会打到位于 $1,2,3$ 位置的自机。

因此如果在 $4$ 位置，自机就不会被打中。事实上，只要不是 $0,1,2,3$ 位置均可，答案不唯一。

### 数据范围及约定

对于全部数据，保证 $1\le n\le 2\times 10^5$，$|a_i|\le 10^6$，$|b_i|\le 10^{12}$，$|c_i|\le 10^{18}$。

## 样例 #1

### 输入

```
3
0 0 0
-3 3 -1
-6 11 -6```

### 输出

```
4```

# 题解

## 作者：Chenyichen0420 (赞：6)

## 简要题意

给出 $n$ 个关于 $x$ 的一元三次方程，求出任意一个整数 $x$ 使其均**不是**这些方程的解。

## 主思路

作为一道正常的题，我们暴力枚举肯定不行，其复杂度显然过大。

这时我们能轻松地想到一种有点瞎搞的做法：随机化。

我们来分析一下其时间复杂度：

首先有一个数学上的常识：对于一个一元 $k$ 次方程，其实数解最多有 $k$ 个。那么对于此题的 $3$ 次方程，每个方程最多有 $3$ 个实数解。总共最多也只有 $6\times10^5$ 个解。那么对于一个长度为 $1000001$ 的区间，一个整数满足其均**不是**这些方程的解的概率实际上在 $0.4$ 以上。平均算下来枚举 $3$ 次左右就可以成功了。

但是本地调试和提交测评的时候要注意一些坑点：

`rand()` 在 Windows 系统中的值域为 $0$ 至 $32767$，需要将两个 `rand()` 乘起来。

我们还需要强转一下 `long long` 再取模，因为 `rand()` 在 Linux 系统中的值域更大，乘起来会炸 `int`，所以如果想兼容 Windows 和 Linux 的话需要进行上述操作。

考虑到概率过小的超时，可以用 `srand()` 刷新一下运气，这样每次运行都极大概率能输出不相同的值。

其具体用法为在主函数中加上 `srand((unsigned)time(0))`。不过请添加上 `ctime` 头文件。

这样，当我们输入并存储完毕后，就可以随机枚举答案并验证，如果通过就直接输出，否则继续随机枚举。

下面附上代码。

```cpp
#include<iostream>
#include<algorithm>
#include<ctime>
using namespace std;
#define int long long
int a[200005], b[200005], c[200005], n;
inline bool check(int ps) {
	for (int i = 1; i <= n; ++i)
		if (ps * ps * ps + a[i] * ps * ps + b[i] * ps + c[i] == 0) return 0;
	return 1;
}
signed main() {
	ios::sync_with_stdio(0);
	srand((unsigned)time(0));
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> a[i] >> b[i] >> c[i];
	for (register int i = 1; i <= n; ++i) {
		int pos = rand() * 1ll * rand() % 1000000;
		if (check(pos)) {
			cout << pos << endl;
			return 0;
		}
	}
}
```

---

## 作者：引领天下 (赞：5)

看了一下似乎题解做法都是基于随机化的，这里给出一个不基于随机化的做法。

首先注意到想找到满足题意的点其实可以直接求出所有的方程的根，而三次方程是有求根公式的。

那么我们的思路就十分简单了，直接用三次方程求根公式求出三次方程的根，然后排除掉这些根即可。

三次方程的求根公式（以 $ax^3+bx^2+cx+d=0$ 为例）：

$$\begin{cases}
	x_1=-\frac{b}{3a}+\sqrt[3]{-\frac{27a^2d-9abc+2b^3}{54a^3}+\sqrt{\varDelta}}+\sqrt[3]{-\frac{27a^2d-9abc+2b^3}{54a^3}-\sqrt{\varDelta}}\\
	x_2=-\frac{b}{3a}+\frac{-1+\text{i}\sqrt{3}}{2}\sqrt[3]{-\frac{27a^2d-9abc+2b^3}{54a^3}+\sqrt{\varDelta}}+\frac{-1-\text{i}\sqrt{3}}{2}\sqrt[3]{-\frac{27a^2d-9abc+2b^3}{54a^3}-\sqrt{\varDelta}}\\
	x_3=-\frac{b}{3a}+\frac{-1-\text{i}\sqrt{3}}{2}\sqrt[3]{-\frac{27a^2d-9abc+2b^3}{54a^3}+\sqrt{\varDelta}}+\frac{-1+\text{i}\sqrt{3}}{2}\sqrt[3]{-\frac{27a^2d-9abc+2b^3}{54a^3}-\sqrt{\varDelta}}\\
\end{cases}$$

其中 $\varDelta =\left( \frac{27a^2d-9abc+2b^3}{54a^3} \right) ^2+\left( \frac{3ac-b^2}{9a^2} \right) ^3$，是三次方程的判别式。

对求根公式推导方式感兴趣的可以看[这里](https://zhuanlan.zhihu.com/p/587001143)。

具体实现中，使用 std 库里的 complex 类就可以。

但是如果你这样写，会发现 WA 了。

原因很简单，double 的运算精度不够，导致我们求出的根精度不够。

为了解决这个问题，我们将得到的根作为近似根。为方便起见，我们不检查其是否为实根，而是直接取实部，对其前后各 2 个整数标记是否为该方程的根。这样我们所进行的运算全部为整数运算，精度足够。

求根部分的复杂度为 $O(Vn)$，其中 $V=3\times4=12$。

最后求答案的部分只需要找出 $0\sim10^6$ 的整数中未被标记的即可。复杂度为常数 $O(N)$，其中 $N=10^6$。

这个做法理论上求出了**所有**满足题意的点，且复杂度正确。~~数竟生大胜利！~~

代码：

```cpp
#include<bits/stdc++.h>
#define lfg(x) pow(x,1.0/3)
using namespace std;
long long b,c,d;
complex<double> x1{-0.5,sqrt(3)/2},x2{-0.5,-sqrt(3)/2},tmp,z;
int n;
bool s[1000005];
inline complex<double> operator *(const int p,const complex<double> q){
    return complex{p*q.real(),p*q.imag()};
}
inline complex<double> operator /(const complex<double> p,const int q){
    return complex{p.real()/q,p.imag()/q};
}
inline complex<double> operator +(const long long a,const complex<double> b){
    return complex{b.real()+a,b.imag()};
}
inline void work(complex<double> x){
    if(x.real()<-2||x.real()>1000002)return;
    for(long long i=x.real()-2;i<=x.real()+2;i++)if(i*i*i+i*i*b+i*c+d==0&&i>=0&&i<=1e6)s[i]=1;
}
int main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>n;
    while(n--){
        cin>>b>>c>>d;
        tmp=-(27*d-9*b*c+2*b*b*b)/54,z=(3*c-b*b)/9;
        work(-b/3+lfg(tmp+sqrt(tmp*tmp+z*z*z))+lfg(tmp-sqrt(tmp*tmp+z*z*z)));
        work(-b/3+x1*lfg(tmp+sqrt(tmp*tmp+z*z*z))+x2*lfg(tmp-sqrt(tmp*tmp+z*z*z)));
        work(-b/3+x2*lfg(tmp+sqrt(tmp*tmp+z*z*z))+x1*lfg(tmp-sqrt(tmp*tmp+z*z*z)));
    }
    for(int i=0;i<=1e6;i++)if(!s[i]){cout<<i;return 0;}
}
```

---

## 作者：xueruo (赞：4)

## 题意

给出 $n$ 个与 $x$ 有关的多项式，求出任意一个 $x$ 使得这些多项式的值都不等于 $0$。

## 思路

对于一个多项式 $x^3+a_i x^2+b_i x+c_i$。
+ 如果 $c_i$ 不为 $0$，当 $x$ 取 $0$ 的时候，多项式的值为 $c_i$，一定不等于 $0$。  
+ 如果 $c_i$ 为 $0$，考虑用随机化枚举区间 $[0,10^6]$，每次用枚举的 $x$ 判断是否合法。如果合法就输出并结束，否则就继续随机。  

## 时间复杂度

一个一元三次方程最多有 $3$ 个实数根。最坏情况下要所有实数根都随机到一遍。因为最多有 $2 \times 10^5$ 个方程，最多有 $6 \times 10^5$ 个实数根，每次的成功概率为 $\displaystyle \frac{1 \times 10^6-6 \times 10^5}{1 \times 10^6} = 40\%$，每 $2.5$ 次就能查找到答案。期望复杂度省去常数为 $\Theta(n)$。  

记得加个记忆化把判断过的直接去除，不用再判断。
```cpp
#include<stdio.h>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<ctime>
#define int long long
using namespace std;
const int N=2e5+10;
int n;
int a[N],b[N],c[N];
bool book[N];
inline bool check(int x){
	if(!book[x])return 0;//如果判断过这个 x 不合法就不在判了
	for(register int i=1;i<=n;++i){
		if(!(x*x*x+a[i]*x*x+b[i]*x+c[i])){
			return book[x]=0;	
		}
	}
	return 1;
}
signed main(){
    srand(time(0));//取系统当前时间为随机化种子
	scanf("%lld",&n);
	for(register int i=0;i<=N-5;++i) {
		book[i]=1;
	}
	for(register int i=1;i<=n;++i) {
		scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
	}
	for(register int i=1;i<=n;++i){
		if(c[i]){
			register int x=rand()%1000001;
			while(!check(x)){
				x=rand()%1000001;
			}
			printf("%lld",x);
			return 0;
		}
	}
	printf("0");
    return 0;
}
```

---

## 作者：Code_Fish_GoodBye (赞：2)

[题目链接](https://www.luogu.com.cn/problem/B3800)
## 题目大意
找出一个数 $x(x\in[0,10^6])$，使得如下式子成立：
$$
x^3+a_ix^2+b_ix+c_i=0
$$

## 思路
与其暴力枚举，不如使用随机数来解决此问题。

在这里，我们可以使用比 `rand` 函数更方便的 `mt19937`。

对于此题，我们可以不断产生随机数并判断，直到找到了满足条件的数就可以结束程序了。

**参考代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+10,MOD=1e6;
long long n,a[MAXN],b[MAXN],c[MAXN];

inline bool check_ans(long long x){
	for(int i=1;i<=n;i++) if(x*x*x+a[i]*x*x+b[i]*x+c[i]==0) return false;//判断
	return true;
}
int main(){
	mt19937 mrand(time(0));//初始化种子
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
	while(true){
		long long x=mrand()%MOD;//产生随机数
		if(check_ans(x)){
			printf("%lld\n",x);
			exit(0);//找到即可退出
		}
	}
	return 0;
}
```

---

## 作者：Register_int (赞：2)

本题解主要给出随机化方法的复杂度分析。

先简述该算法的过程：

- 在 $[0,10^6]$ 内等概率地选择整数 $x$。
- 如果该点为“安定点”，直接输出，否则继续进行随机。

题面给出的每个方程都是三次方程，在最坏情况下，每个方程都有三个整数根，且恰好位于 $[0,10^6]$ 的范围内，每个根互不相同。总共 $2\times10^5$ 个方程，最坏情况下有 $6\times10^5$ 个位置不是安定点，也就是约 $4\times10^5$ 个位置是安定点，占总点数的 $\dfrac{4\times10^5}{10^6}=\dfrac25$，即每次有约 $40\%$ 的概率找到安定点。

通过期望的线性性，我们可以计算出，该程序的期望查找次数为 $\dfrac25$ 的倒数即 $2.5$ 次，期望复杂度 $O(n)$。

通过实际测试，在不做记忆化的情况下，随机的次数稳定在 $1\sim8$ 之间。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;

mt19937 eng(time(0));
uniform_int_distribution<int> dist(0, 1e6);

int n; ll a[MAXN], b[MAXN], c[MAXN], x;

inline 
ll calc(ll x, int p) {
	ll res = ((x + a[p]) * x + b[p]) * x + c[p];
	return res;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lld%lld%lld", &a[i], &b[i], &c[i]);
	for (bool f; ; x = dist(eng)) {
		f = 0;
		for (int i = 1; i <= n; i++) if (!calc(x, i)) { f = 1; break; }
		if (!f) return printf("%lld", x), 0;
	}
}
```

---

## 作者：spacebar (赞：1)

本来想用这题写整活题解的。

[整活题解](https://www.luogu.com.cn/blog/wenlebo-GCOI/solution-b3800)

看到这题我们可以通过循环枚举检查某处能否成为安全点，只要找到即为答案，但是如果我们考虑最坏的情况，我们枚举到的每一个点都在弹道上，那么我们就要一直枚举，直到 $n$ 条弹道都弄完了一遍，如此多的枚举次数，肯定要超时。

事实上只要数据巧妙无论你是正序、倒序、枚举奇数、枚举偶数、枚举质数都可以出现最坏的情况（如果出题人足够狡猾）！

我们可以换个思路，我们可以**随机**一个点检查！随机到每一个点的概率相等，通过数据范围可以发现对于每个点成功的概率极高！而随机让出题人无法预判你每个输出的数，轻轻松松就能通过！

关于为什么要用随机化思想（对重要结论的证明），举个例子：

有五十张卡片，你最多选三张，而有四张是红色的，其余是白色的，你希望得到白卡，你不知道某一张是红的或白的，也许你想到了一种选卡方式，比如选出第一张、第五张、第十四张，但是给你卡的人非常智慧，他预想到了你会使用一种定式获取卡片，于是提前在你想的三个地方放上了红卡，甚至让你多次重复这一操作，每一次的位置都不一样，这样无论如何都你选的位置都会出现三张红卡！

但你可以使用抛骰子的方式来决定你的选择，摆卡片的人并不能预判你的（骰子的）选择，事实上，他的摆法对你没什么影响，因为无论放在什么位置你取到红卡片的概率一致！此时只要你不是太非酋就能选出至少一张白卡片了。

注意：

- 一定要将当前时间作为随机种子,否则无法保证通过每个阴间测试点（似乎暂时没卡，但不代表以后的随机化题目不会卡）

- 记得取模！

代码：

```
#include <bits/stdc++.h>
using namespace std;
long long n;
long long o;
long long a[200010],b[200010],c[200010];
bool check(long long x){      //检查位置
	for(int i=1;i<=n;i++){
		if(x*x*x+a[i]*x*x+b[i]*x+c[i]==0){
			return 0;
		}
	}
	return 1;
}
int main(){
	srand(time(NULL));  //用时间当随机数种子
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i]>>c[i];
	}
	while(1){
		o=rand()%1000001; //取模，否则会超出输出范围限制
		if(check(o)){
			cout<<o;   //发现可行位置
			return 0;  
		}
	}
	return 0;
} 
```


---

## 作者：Miracle1024 (赞：1)

蒟蒻的first题解

题目：[here](https://www.luogu.com.cn/problem/B3800)

AC记录：[here](https://www.luogu.com.cn/record/113277666)

## 题意简述

有 $n$ 个三次函数 $y=x^3+a_ix^2+b_ix+c_i$，现要求出任意一个正整数 $m$ 使得整点 $A(0,m)$ 不在任意一个函数与 $x$ 轴的交点上，且 $m \le 10^6 $。

## 思路：

首先，如果你对三次函数有过了解，那么你会发现，一个三次函数会有 $1\sim 3$ 个与 $x$ 轴的交点。

若要求出函数所有零点，涉及的数学知识太多，~~我不会~~，我们暂时不予研究。

换一种思路，遍历 $x$ 轴上每一个整点，逐个判断是否是函数与 $x$ 轴的交点。这种思路的时间复杂度是 $O(n)$。

但如果你试试 ~~（就像我）~~ ，你会发现，因为有 $10^6$ 的常数，有 $4$ 个点会 TLE！虽说这样能够拿到 68 分，但这远远不是我们想要的。

所以我们要优化这个代码。我们仍然遍历每一个点，但遍历的顺序改为随机，这样复杂度还是 $O(n)$，但不会超时。这是因为在运行中，因为函数的交点最多有 $2\times10^5\times3=6\times10^5$ 个，所以每次随机至少有 $40\%$ 的概率得到答案。

### 代码实现：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<set>
using namespace std;
typedef long long ll;
const int maxx=0x3f3f3f,minn=-0x3f3f3f;
int ans,n,a[222222],b[222222],c[222222];
set<int>s;//这个集合用于标记随机访问是否访问过
ll f(int x,int i){//第 i 个函数里目前 x 对应的 y，保险起见，开 long long
	return x*x*x+a[i]*x*x+b[i]*x+c[i];
}
int main(){
	srand(time(0));//随机种子设为时间才能真正做到随机
    cin>>n;
    for(int i=1;i<=n;i++)scanf("%d%d%d",&a[i],&b[i],&c[i]);
	while(1){
		ans=rand()%1000001;//取一个 0~1000000 范围内的随机整数
        bool flag=1;
        if(s.count(ans)) continue;//忽略被遍历过的位置
        s.insert(ans);//标记访问
        for(int i=1;i<=n;i++){//遍历每一条函数
            if(f(ans,i)==0){//判断是否在交点上
                flag=0;
                break;
            }
        }
        if(flag){//是解则输出
            cout<<ans;
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：xhz0311 (赞：0)

### 思路
显然把所有三次方程全解出来是不可能的。再看题目只要求输出一个满足题意的答案即可，所以我们只需要生成随机数再判断即可。由于根的总数不超过 $3\times2\times10^5=6\times10^5$，因此随机数有 $40\%$ 的概率为满足题意的答案；又因为检查是否被击中可以很简单的做到 $O(n)$，这个方法完全可取。   
注意别忘记加 `srand(time(NULL));`
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
long long a[200010],b[200010],c[200010],x;
long long check(long long x, int p)
{
	long long res=x*x*x+a[p]*x*x+b[p]*x+c[p];
	return res;
}
int main()
{
	srand(time(NULL));
	scanf("%d",&n);
	for (int i=1; i<=n; i++)
	{
		scanf("%lld %lld %lld",&a[i],&b[i],&c[i]);
	}
	for (bool f=0;;x=rand()%1000001)
	{
		f=0;
		for (int i=1; i<= n; i++)
		{
			if (!check(x,i))
			{
				f=1;
				break;
			}
		}
		if (!f)
		{
			printf("%lld",x);
			return 0;
		}
	}
}
```
### 后记
如何想到这个随机化思路呢？以出题人角度思考即可：
> 我要配 SPJ   
> 怎么判断选手输出的答案满足题意呢？   
> 把所有 $a$ $b$ $c$ 全部跑一下判断是否为根即可。

---


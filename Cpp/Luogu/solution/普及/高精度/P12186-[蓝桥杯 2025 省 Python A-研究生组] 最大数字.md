# [蓝桥杯 2025 省 Python A/研究生组] 最大数字

## 题目描述

我们有 $n$ 个连续的整数 $1, 2, 3, \cdots, n$，可以自由排列它们的顺序。

然后，我们把这些数字转换成二进制表示，按照排列顺序拼接形成一个新的二进制数。

我们的目标是让这个二进制数的值最大，并输出这个二进制对应的十进制表示。

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 10$；
- 对于 $40\%$ 的评测用例，$1 \leq n \leq 100$；
- 对于 $60\%$ 的评测用例，$1 \leq n \leq 500$；
- 对于 $80\%$ 的评测用例，$1 \leq n \leq 1000$；
- 对于所有评测用例，$1 \leq n \leq 10000$。

## 样例 #1

### 输入

```
3```

### 输出

```
30```

# 题解

## 作者：shenliyan (赞：5)

先看看题目要我们干什么。读完题后，可知题目要求给定整数 $n$，将 $1-n$ 的整数排列后转换为二进制字符串拼接，输出能形成的最大二进制数对应的十进制值。


**核心思路:贪心。**

**难点：大数处理**
  
对于两个数 $a$ 和 $b$，$a$ 的二进制字符串 $+ b$ 的二进制字符串 $> b$ 的二进制字符串 $+ a$ 的二进制字符串，则 $a$ 应排在 $b$ 前面。通过此策略排序后（好吧我不会推了），逆序拼接可得到最大二进制数。  
  
当 $n$ 较大时，二进制字符串可能长达数万位，无法用普通整数存储。需用字符串模拟十进制运算逐位乘 $2$ 和加 $1$ 实现转换。


#### 代码实现 （呜呜呜这马蜂没救了。。。。。。）
```cpp
#include<bits/stdc++.h>
using namespace std;
bool c(const string&x,const string&y){return x+y<y+x;}
string t(int n,int k){
 if(n==0)return"0";
 string a;
 while(n>0){int r=n%k;a+=r<10?r+'0':r-10+'A';n/=k;}
 reverse(a.begin(),a.end());
 return a;
}
string b2d(const string&bin){
 vector<int>d={0};
 for(char ch:bin){
  int c=0;
  for(int i=0;i<d.size();++i){int v=d[i]*2+c;d[i]=v%10;c=v/10;}
  while(c){d.push_back(c%10);c/=10;}
  if(ch=='1'){
   int ca=1;
   for(int i=0;i<d.size()&&ca;++i){int v=d[i]+ca;d[i]=v%10;ca=v/10;}
   if(ca)d.push_back(ca);
  }
 }
 string r;
 for(int i=d.size()-1;i>=0;--i)r+=d[i]+'0';
 return r;
}
int main(){
 ios_base::sync_with_stdio(false);cin.tie(0);
 int n;cin>>n;
 vector<string>s(n+1);
 for(int i=1;i<=n;++i)s[i]=t(i,2);
 sort(s.begin()+1,s.end(),c);
 string m;
 for(int i=n;i>=1;--i)m+=s[i];
 cout<<b2d(m)<<endl;
 return 0;
}
```


**总结**  
- **贪心策略**是排序的核心，通过比较拼接结果确定顺序。  
- **大数处理**是关键，避免直接使用整数导致溢出，需用字符串模拟运算。  
- 逆序拼接是排序后得到最大结果的必要步骤。

---

## 作者：Pufflet233 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P12186)

[更好的阅读体验](https://www.luogu.me/article/a3ssytlk)

本题解是 Python 题解，C++ 用户可以参考本题解思路，但需自行实现高精度二进制转十进制，并且需要使用快速读入技巧。这里放出作者的 C++ 代码，不过作者**码风极差**，仅供参考。[链接](https://www.luogu.me/paste/kmujt5jm)

## 题目简介

给一个数字 $n$，要求把 $1, 2, 3, \cdots, n$ 这 $n$ 个连续的数字转成二进制并任意排序，这些数字可以连接在一起组成一个新的二进制数字，把可以组成最大的数字用十进制输出。

## 解题思路

首先我们先将 $1$ 至 $n$ 全部数字转为二进制。

接着就是进行排序，我们这里设两个二进制字符串分别为 $s_1$ 和 $s_2$。我们可以把这两个字符串拼在一起变成 $s_1 + s_2$ 及 $s_2 + s_1$ 进行比较，为了令到组成的数字更大，我们在两个字符串连接时肯定会选择拼成两个拼装的字符串中更大的一位，因此若 $s_1 + s_2 > s_2 + s_1$，我们就把 $s_1$ 放在前面，否则把 $s_1$ 放在后面。

例如：我现在有两个二进制字符串 ```10``` 及 ```11```（在十进制中分别为 2 和 3），把这两个字符串连接后可以组成 ```1011``` 及 ```1110```（在十进制分别为 11 及 14），为了组成更大的数字，我们会将 ```11``` 放在 ```10``` 前面。

## 代码实现

首先我们需要把 $1$ 至 $n$ 全部数字转成二进制，我们可以用到 ```bin()``` 函数，这个函数可以把一个整数转成二进制字符串，不过生成的字符串前面会带 ```0b``` 而我们不需要，因此我们在用这个函数的时候还需要进行切片，代码是 ```bin(i)[2:]``` 。我们只需要用循环，把每一个数转成二进制后放进一个列表即可，以下是代码。

```python
bins=[bin(i)[2:] for i in range(1,n+1)]
```

然后进行排序即可，我们可以先写一个自定义比较函数。
```python
def check(a,b):
    if a+b>b+a:
        return 0
    else:
        return 1
```
接着用自带的 ```list.sort()``` 函数即可，我们对一个列表可以用这个函数进行排序，默认是从小到大，如果我们需要自定义排序，需要先用 ```functools.cmp_to_key()``` 函数将比较函数转换为 ```key``` 函数，再传给 ```key``` 参数，这个函数需要导入 ```functools``` 库。下面是参考代码。


```
import functools #functools.cmp_to_key需要导入functools库
def check(a,b): #自定义检查函数
    if a+b>b+a:
        return -1
    else:
        return 1


bins.sort(key=functools.cmp_to_key(check)) #排序
```


因为组成的数字过大，因此需要修改 int 最大处理值。
```python
import sys #导入sys库
sys.set_int_max_str_digits(0) #将Python的int最大处理值设置为无上限
```

下面是完整代码
```python
import functools
import sys
sys.set_int_max_str_digits(0)
def check(a,b): #自定义检查函数
    if a+b>b+a:
        return -1
    else:
        return 1
n=int(input()) #输入
bins=[bin(i)[2:] for i in range(1,n+1)] #开一个列表，储存1到n+1全部数的二进制
bins.sort(key=functools.cmp_to_key(check)) #排序
ans=''.join(bins) #把数连接在一起
print(int(ans,2)) #输出
```


## 相关题目

[P1012 [NOIP 1998 提高组] 拼数](https://www.luogu.com.cn/problem/P1012)

[B3619 10 进制转 x 进制](https://www.luogu.com.cn/problem/B3619)

[B3620 x 进制转 10 进制](https://www.luogu.com.cn/problem/B3620)

---

## 作者：Ag2WO4 (赞：1)

Python 的魅力时刻！

考虑贪心，将所有数想象成无限循环小数的循环节，可以用交换——逐步优化法发现在交换时显然有小数越大越应该靠前的结论，于是排序加和输出即可。
```python
a='';import sys;sys.set_int_max_str_digits(1<<30)
for i in sorted((bin(i+1)[2:]for i in range(int(input()))),key=lambda i:i*16,reverse=1):a+=i
print(int(a,2))
```

---

## 作者：YBa2Cu3O7 (赞：0)

本题分为两个部分，贪心排序和大整数的二进制转十进制。

### 贪心
数据规模使得我们可以直接构造一个 $1\sim  n$ 的数组，然后直接在这上面排序，关键点是排序的比较函数。

对于被比较的两个数字 $a$ 和 $b$，检查把 $a$ 拼在 $b$ 前面和把 $b$ 拼在 $a$ 前面这两种情况下，谁组成的数字更大，前者更大则返回 `true` 否则返回 `false`。

这个的证明也很简单，两个数之间插入任何数 $c$ 都不影响这两种拼接方式 $a/c/b$ 和 $b/c/a$ 之间的相对大小关系。因此如果有违反的情况，那么交换违反的数对后一定比之前更大。

### 高精度
排序后需要将上面十进制数组转二进制拼接再转回十进制，因此只需要高精度的 $+1$ 和 $\times 2$ 两种操作。

### 其它
开了 `ios::sync_with_stdio(0)` 用 `unsigned long long` 也一样会 TLE，用 `int` 就够了。

（可惜在考场上只在想怎么让 $1$ 更靠前了，再加上要高精度直接放弃思考。）

### 代码

高精度在具体实现中用的是 `vector` 模拟，低位在前。

最开头的 `using ull=int;` 是因为之前 `using ull=unsigned long long;` 超时才改的。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ull=int;

template <typename T>
class bigint{
    vector<T> digits;
public:
    bigint() : digits{0} {}
    bigint(const vector<T>& nums) : digits(nums) {}
    void mult2() {
        int n = 0;
        for (int i = 0; i < digits.size(); ++i) {
            int product = digits[i] * 2 + n;
            digits[i] = product % 10;
            n = product / 10;
        }
        if (n != 0) {
            digits.push_back(n);
        }
    }

    void add1() {
        int n = 1;
        for (int i = 0; i < digits.size() && n > 0; ++i) {
            int s = digits[i] + n;
            digits[i] = s % 10;
            n = s / 10;
        }
        if (n > 0) {
            digits.push_back(n);
        }
    }

    void output() const {
        int i=digits.size()-1;
        while(i>=0&&digits[i]==0){
            --i;
        }
        while(i>=0){
            cout<<digits[i];
            --i;
        }
    }

};

template <typename T>
bigint<T> trans(const vector<T>& nums) {
    string bs;
    for (T num : nums) {
        if (num == 0) {
            bs += "0";
        } 
        else {
            string temp;
            while (num > 0) {
                temp = (num % 2 == 0 ? "0" : "1") + temp;
                num /= 2;
            }
            bs += temp;
        }
    }
    bigint<T> res;
    for (auto bit : bs) {
        res.mult2();
        if (bit == '1') {
            res.add1();
        }
    }
    return res;
}

int main(){
    ull x;
    cin>>x;
    vector<ull> nums(x);
    for(int i = 0; i < x; i++){
        nums[i] = i + 1;
    }
    sort(nums.begin(), nums.end(), [](ull a, ull b) {
        ull bita = log2(a) + 1;
        ull bitb = log2(b) + 1;
        ull tempa = (a << bitb) + b;
        ull tempb = (b << bita) + a;
        return tempa > tempb;
    });
    bigint<ull> bs=trans(nums);
    bs.output();
    
    return 0;
}
```

---

## 作者：yanmingqian (赞：0)

题意：给定 $n$，将 $1,2,3,\dots,n$ 按照一定方式排序后全部转化为二进制表示并顺次拼接成一个新的二进制数，求这个二进制数最大是多少，输出其对应的十进制表示。

我们考虑直接按照题意，对原序列进行排序。

考虑排序方式。如果在排序过程中有两个数 $a$ 和 $b$，显然当把 $a$ 的二进制拼接在 $b$ 的二进制之前比把 $b$ 的二进制拼接在 $a$ 之前更大时，要把 $a$ 往前放。因此我们可以直接对于每个数生成其二进制，存为字符串，这样排序的时候直接拼接，对字符串直接进行比较即可。

python 在这题好像反而更好实现一些，因为包含了很多内置函数，而且不用高精度。可是我不太会写，所以喂给了 deepseek，让它帮我生成了一份，我理解了一下，写了点注释。由于产生的数可能会很大，要加上 `sys.set_int_max_str_digits(10000000)`。

代码：

```py
import functools
import sys
sys.set_int_max_str_digits(10000000)
n = int(input())
binary_strs=[bin(i)[2:] for i in range(1,n+1)]  #生成二进制
def compare(a,b):  #按思路比较
    if a+b > b+a:
        return -1
    else:
        return 1

binary_strs.sort(key=functools.cmp_to_key(compare))  #自定义排序
result = ''.join(binary_strs)
print(int(result, 2))
```

---


# [蓝桥杯 2015 国 C] 机器人繁殖

## 题目描述

X 星系的机器人可以自动复制自己。它们用 $1$ 年的时间可以复制出 $2$ 个自己，然后就失去复制能力。
每年X星系都会选出 $1$ 个新出生的机器人发往太空。也就是说，如果X星系原有机器人 $5$ 个，  
$1$ 年后总数是：$5 + 9 = 14$  
$2$ 年后总数是：$5 + 9 + 17 = 31$

如果已经探测经过 $n$ 年后的机器人总数 $s$，你能算出最初有多少机器人吗？

## 说明/提示

时限 1 秒, 512M。蓝桥杯 2015 年第六届国赛

## 样例 #1

### 输入

```
2 31```

### 输出

```
5```

## 样例 #2

### 输入

```
97 2218388550399401452619230609499```

### 输出

```
8```

# 题解

## 作者：SunnyLi (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P8629)

看到几个大佬的题解，深感数学不行。本蒟蒻就来发一个小学生都能看懂的找规律题解。

## 思路

我们假设开始时有 $t$ 个机器人。我们记 $f(x)$ 为 $x$ 年后的机器人个数，然后我们开始尝试前几项：

$$
\begin{aligned}
f(1) &= t+(2t-1)      &= 3t-1 \\
f(2) &= 3t-1+(2(2t-1)-1) &= 7t-4 \\
f(3) &= 7t-4+(2(4t-3)-1) &= 15t-11 \\
f(4) &= 15t-11+(2(8t-7)-1) &= 31t-26 \\
f(5) &= 31t-26+(2(16t-15)-1) &= 63t-57 \\
\cdots
\end{aligned}
$$

我们先看结果含 $t$ 的一次项：

$3t\quad7t\quad15t\quad31t\quad63t\cdots$

取他们系数的差可以发现，差的数列为：

$4\quad8\quad16\quad32\cdots$

又因为 $3=1+2$，我们记 $A(x)$ 为一次项系数，$x$ 为过去的时间，可以得到以下关系：

$$A(x)=1+2+4+\cdots+2^x=2^{x+1}-1$$

接下来看常数项：

$1\quad4\quad11\quad26\quad57\cdots$

取差：

$3\quad7\quad15\quad31\cdots$

有没有觉得很眼熟，这就是一次项系数的规律。

所以我们记 $B(x)$ 为常数项，$x$ 为所过的时间，可以得到以下关系：

$$B(x)=\sum^{x}_{i=1}A(i-1)$$

当然 $B(0)$ 是特例，$B(0)=0$。

现在我们来计算一下 $B(x)$ 的通项公式：

$$
\begin{aligned}
B(x) &= \sum^{x}_{i=1}A(i-1)\\
&= A(0)+A(1)+\cdots+A(x-1)\\
&= (2^1-1)+(2^2-1)+\cdots+(2^{x}-1)\\
&= (2^{x+1}-2)-x\\
\end{aligned}
$$

所以基本上就大功告成了！

所以 $n$ 年后的机器总数为：

$$
\begin{aligned}
s &= A(n)t+B(n)\\
&= (2^{n+1}-1)t-[(2^n-2)-n]\\
&= 2^{n+1}t-t+n-2^{n+1}+2\\
&= (2^{n+1}-1)(t-1)+t+1\\
\end{aligned}$$

把它化简表示为 $t$ 的函数形式，易得

$$t=\frac{s-n-1}{2^{n+1}-1}+1$$

最后看到样例二的那一大串数字 $2218388550399401452619230609499$，我们肯定要用高精度。作为一个蒟蒻，高精度肯定用 Python 啦！

## AC 代码

```python
#Python代码
from math import pow
n,s = input().split(" ")
n,s = int(n),int(s)
print(str(int((s-n-1)/(int(pow(2,n+1))-1)+1)))
```

[AC 记录](https://www.luogu.com.cn/record/108632180)

---

## 作者：chenhaoyou (赞：2)

看了楼上几位大佬的数学公式，我一个初一的蒟蒻表示~~很不李姐~~，既然我是被二分吸引过来的，那我就写一份**二分**的题解吧。
## 二分思路
有于机器人一开始的数量和最后的总和一一对应，且具有单调性（在天数相同的情况下，一开始的机器人数量越多，最后的数量总和越多），所以可以用二分来遍历一开始的机器人数量，在高精度计算 $n$ 天后的数量。如相同则输出，不同则调整一开始的机器人数量，继续找。由于 $n<100$ 并且 $s$ 的位数小于 $50$ ，二分又是 $\log_2~n$ 的算法，所以时间复杂度很小，可过。

具体的细节在注释里
## 代码

```
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
ll n,l=1,r=100,mid,d;
string s,s1;
int f(string x,string y)//比大小，如果第一个大返回1，第二个大返回2
{
	int lx,ly;
	lx=x.size();
	ly=y.size();
	if(lx>ly) return 1;
	if(ly>lx) return 2;
	for(int i=0;i<lx;i++)
	{
		if(x[i]>y[i]) return 1;
		if(x[i]<y[i]) return 2;
	}
	return 0;
}
string check(int x)
{
	ll a[1111],b[1111],c[1111];
	ll wa=0,wb=0;
	string ans;
	memset(a,0,sizeof(a));//别忘了清空哦
	memset(c,0,sizeof(c));
	while(x)
	{
		c[++wb]=x%10;
		a[++wa]=x%10;
		x/=10;
	}//数字转到数组里
	for(int k=1;k<=n;k++)//高精推结果
	{
		memset(b,0,sizeof(b));
		for(int i=1;i<=wb;i++)//b数组里记录当前可繁殖的机器人，繁殖出来的机器人数
		{
			b[i]+=c[i]*2;
			if(b[i]>9)
			{
				b[i+1]+=b[i]/10;
				b[i]%=10;
			}
		}
		if(b[wb+1]>0)
		{
			wb++;
		}
		b[1]-=1;//有一个去了太空
		for(int i=1;b[i]==-1;i++)
		{
			b[i]=9;
			b[i+1]-=1;
		}
		if(b[wb]==0)
		{
			wb--;
		}
		for(int i=1;i<=wb;i++)//c数组记录当前可繁殖的机器人数
		{
			c[i]=b[i];
		}
		wa=max(wa,wb);
		for(int i=1;i<=wa;i++)//把繁殖出来的机器人加到结果里去
		{
			a[i]+=b[i];
			if(a[i]>9)
			{
				a[i+1]+=a[i]/10;
				a[i]%=10;
			}
		}
		if(a[wa+1]>0)
		{
			wa++;
		}
		
	}
	for(int i=wa;i>=1;i--)//转为字符串，被忘了反过来
	{
		ans+=char(a[i]+'0');
	}
	return ans;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>s;
	if(s=="0")
	{
		cout<<0;
		return 0;
	}
	while(l<=r)
	{
		mid=(l+r)>>1;//取中间
		d=f(check(mid),s);//那个大
		if(d==2)//小了就往大了搜，左端点右移
		{
			l=mid-1;
		}
		else if(d==1)//大了就往小了搜，右端点左移
		{
			r=mid+1;
		}
		else//相等就是答案
		{
			cout<<mid;
			break;
		}
	}
	return 0;
}

```


---

## 作者：andyli (赞：2)

设最初有 $x$ 个机器人，则第 $1$ 年会增加 $2x - 1$ 个机器人，第 $2$ 年会增加 $2(2x - 1) - 1 = 4x - 3$ 个机器人，第 $3$ 年会增加 $2(4x - 3) - 1 = 8x - 7$ 个机器人，第 $n$ 年会增加 $2^n x - (2^n - 1)$ 个机器人。故在 $n$ 年末将有机器人的数目为：   
$$
\begin{aligned}
s = &\sum\limits_{i=0}^{n} 2^i x - (2^i - 1) \\
= & n + 1 + (\sum\limits_{i=0}^{n} 2^i)(x-1) \\
= & n + 1 + (2^{n+1} - 1)(x-1)
\end{aligned}
$$


所以 $x = \dfrac{s - n - 1}{2^{n+1} - 1} + 1$。


注意使用高精度。  
```cpp
int main() {
    dR(int, n);
    dR(std::string, _s);
    BigInteger s = _s;
    writeln(to_string(1 + (s - n - 1) / (power(BigInteger(2), n + 1) - 1)));
    return 0;
}
```

---

## 作者：liupei (赞：1)

## 思路
首先，我们可以根据题目描述得到公式：$s=a_1(2^{n+1}-1)$，其中 $s$ 为最终机器人总数，$a_1$ 为最初机器人数量，$n$ 为年数。接下来，我们只需要根据输入的 $s$ 和 $n$ 求出 $a_1$ 即可。具体求解过程如下。$$ \begin{aligned} s &= a_1(2^{n+1}-1) \ \Leftrightarrow \frac{s}{2^{n+1}-1} &= a_1 \ \end{aligned} $$ 所以，我们只需要计算 $\frac{s}{2^{n+1}-1}$ 即可得到最初机器人数量 $a_1$。
## 代码
```python
n, s = map(int, input().split())
a1 = s // (2 ** (n + 1) - 1)
print(a1+1)

```


---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

每个机器人每年可以进行一次复制，然后失去复制能力。每年都有一个机器人被发往太空。现在给出第 $n$ 年后机器人总数为 $s$ 现在让你求出第一天有几个机器人。

## 思路

二分讨论第一天有几个机器人（设为 $mid$），然后计算第一天有 $mid$ 个机器人时，第 $n$ 年的机器人个数，计算方法如下：

$$a_n = 2 \times a_{n-1} - 1, (a_1 = mid)$$

经过[不动点法](https://baike.baidu.com/item/%E4%B8%8D%E5%8A%A8%E7%82%B9%E6%B3%95/938944?fr=aladdin)数列计算可得：

$$a_n = mid \times 2^{n-1} - 2^{n-1} + 1$$

则在第 $n$ 年机器人数总和为：

$$S_n = \sum_{i=1}^{n}mid\times 2^{i-1} - 2^{i-1} + 1$$

$$S_n = (mid - 1) \times \sum_{i=1}^{n}2^{i-1} + n$$

$$S_n = (mid - 1) \times (2^{n+1} - 1) + n$$

二分判断即可，注意使用[高精度](https://www.luogu.com.cn/paste/587vee21)。

## 代码


```cpp
Bignum calc(Bignum mid)
{
	Bignum f=qpow(Two, n+1)-One;
	Bignum ret=f*mid-f;
	ret.add(n);
	return ret;
}

int main()
{
    ios::sync_with_stdio(false);
    
    cin >> n;last.read();
    
    Bignum l, r;//第一天可能机器人数 
    l.set("1");//初始化 
    r.set("100");//初始化
    
    One.set("1");
    Two.set("2");
    while(l < r)
    {
    	Bignum mid=(l+r)/2;//第一天机器人数为mid
    	Bignum t=calc(mid);//计算当第一天机器人数为mid时最后一天机器人数
		if(t < last) l=mid+One;//如果最后一天机器人数小于题目所给，往右搜 
		else	r=mid;
	}
	l.print();
    return 0;
}
```

---

## 作者：0x282e202e2029 (赞：1)

# P8629 [蓝桥杯 2015] 机器人繁殖 题解
蒟蒻又来写题解了！~~（蒟蒻三篇题解都是黄题？）~~

首先， [题目传送门](https://www.luogu.com.cn/problem/P8629)

## 分析
初看此题，很明显是一个数学问题。

有几篇找规律做出来的，不禁觉得不严谨，本蒟蒻就试试数学推导。

设最开始有 $x$ 个机器人，记第 $k$ 年总机器人数目为 $S_k$。

根据题干，我们能够写出 $\{S_k\}$ 的递推式

$$S_k = \begin{cases}
   x & \text{if } k = 0, \\
   S_{k - 1} + 2(S_{k - 1} - S_{k - 2}) - 1 & \text{if } k ≥ 1.
\end{cases}$$

为了求出通项式，我们可以先构造 $\{\Delta_k\}$，使 $\Delta_k = S_k - S_{k - 1}$。

接着，可以写出 $\{\Delta_k\}$ 的递推式

$$\Delta_k = \begin{cases}
   x & \text{if } k = 0, \\
   2\Delta_{k - 1} - 1 & \text{if } k ≥ 1.
\end{cases}$$

由上式得 

$$\Delta_{k + 1} = 2\Delta_k - 1$$
$$\Delta_k = 2\Delta_{k - 1} - 1$$
$$\Delta_{k + 1} - \Delta_k = 2(\Delta_k - \Delta_{k - 1})$$

因此，数列 $\{\Delta_{k + 1} - \Delta_k\}$ 为以 $x - 1$ 为首项，公比为 $2$ 的等比数列。

所以

$$\Delta_{k + 1} - \Delta_k = 2 ^ k(x - 1)$$
$$2\Delta_k - 1 - \Delta_k = 2 ^ k(x - 1)$$
$$\Delta_k = 2 ^ k(x - 1) + 1$$

那么

$$S_k = S_{k - 1} + 2 ^ k(x - 1) + 1$$
$$S_k = \overset{k}{\underset{i = 0}{\sum}} [2 ^ i(x - 1) + 1]$$
$$S_k = (x - 1)\overset{k}{\underset{i = 0}{\sum}} (2 ^ i) + k + 1$$
$$S_k = (2 ^ {k + 1} - 1)(x - 1) + k + 1$$

于是

$$s = (2 ^ {n + 1} - 1)(x - 1) + n + 1$$

整理得

$$x = \frac{s - n - 1}{2 ^ {n + 1} - 1} + 1$$

输出这个数，直接 AC。

记得高精度，毕竟样例输入有个 $2218388550399401452619230609499$，这么大的数字，不用高精度，~~直接去世~~。（P.S. 用 python 的不要脸）。

## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Wint:vector<int>//使用 std 容器 vector 作基类，再也不用担心 RE
{
    Wint(int n = 0)
    {
        push_back(n);
        check();
    }
    Wint& check()
    {
        while(!empty() && !back())
        {
			pop_back();
		}
        if(empty())
        {
			return *this;
		}
        for(int i = 1; i < size(); ++i)
        {
            (*this)[i] += (*this)[i - 1] / 10;
            (*this)[i - 1] %= 10;
        }
        while(back() >= 10)
        {
            push_back(back() / 10);
            (*this)[size() - 2] %= 10;
        }
        return *this;
    }//进位函数，直接内置
}n, s;
istream& operator >> (istream &is, Wint &n)
{
    string s;
    is >> s;
    n.clear();
    for(int i = s.size() - 1; i >= 0; --i)
	{
		n.push_back(s[i] - '0');
	}
    return is;
}
ostream& operator << (ostream &os, const Wint &n)
{
    if(n.empty())
	{
		os << 0;
	}
    for(int i = n.size() - 1; i >= 0; --i)
	{
		os << n[i];
	}
    return os;
}//配套cin输入输出
bool operator != (const Wint &a, const Wint &b)
{
    if(a.size() != b.size())
	{
		return true;
	}
    for(int i = a.size() - 1; i >= 0; --i)
    {
        if(a[i] != b[i])
		{
			return true;
		}
	}
    return false;
}
bool operator == (const Wint &a, const Wint &b)
{
    return !(a != b);
}
bool operator < (const Wint &a, const Wint &b)
{
    if(a.size() != b.size())
	{
		return a.size() < b.size();
	}
    for(int i = a.size() - 1; i >= 0; --i)
    {
        if(a[i] != b[i])
		{
			return a[i] < b[i];
		}
	}
    return false;
}
bool operator > (const Wint &a, const Wint &b)
{
    return b < a;
}
bool operator <= (const Wint &a, const Wint &b)
{
    return !(a > b);
}
bool operator >= (const Wint &a, const Wint &b)
{
    return !(a < b);
}
Wint& operator += (Wint &a, const Wint &b)
{
    if(a.size() < b.size())
    {
		a.resize(b.size());
	}
    for(int i = 0; i != b.size(); ++i)
    {
		a[i] += b[i];
	}
    return a.check();
}
Wint operator + (Wint a, const Wint &b)
{
    return a += b;
}
Wint& operator -= (Wint &a, Wint b)
{
    if(a < b)
	{
		swap(a, b);
	}
    for(int i = 0; i != b.size(); a[i] -= b[i], ++i)
    {
        if(a[i] < b[i])
        {
            int j = i + 1;
            while(!a[j])
            {
				++j;
			}
            while(j > i)
            {
                --a[j];
                a[--j] += 10;
            }
        }
    }
    return a.check();
}
Wint operator - (Wint a, const Wint &b)
{
    return a -= b;
}
Wint operator * (const Wint &a, const Wint &b)
{
    Wint n;
    n.assign(a.size() + b.size() - 1, 0);
    for(int i = 0; i != a.size(); ++i)
    {
        for(int j = 0; j != b.size(); ++j)
        {
            n[i + j] += a[i] * b[j];
        }
    }
    return n.check();
}
Wint& operator *= (Wint &a, const Wint &b)
{
    return a = a * b;
}
Wint divmod(Wint &a, const Wint &b)
{
    Wint ans;
    for(int t = a.size() - b.size(); a >= b; --t)
    {
        Wint d;
        d.assign(t + 1, 0);
        d.back() = 1;
        Wint c = b * d;
        while(a >= c)
        {
            a -= c;
            ans += d;
        }
    }
    return ans;
}
Wint operator / (Wint a, const Wint &b)
{
    return divmod(a, b);
}
Wint& operator /= (Wint &a, const Wint &b)
{
    return a = a / b;
}
Wint& operator %= (Wint &a, const Wint &b)
{
    divmod(a, b);
    return a;
}
Wint operator % (Wint a, const Wint &b)
{
    return a %= b;
}//上面有一些可以不用的，但我懒，直接复制自己写的模板
Wint pow(const Wint &n, const Wint &k)
{
    if(k.empty())
    {
		return 1;
	}
    if(k == 2)
    {
		return n * n;
	}
    if(k.front() % 2)
    {
		return n * pow(n, k - 1);
	}
    return pow(pow(n, k / 2), 2);
}//快速幂
int main()
{
	cin >> n >> s;
	cout << (s - n - 1) / (pow(2, n + 1) - 1) + 1;
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/list?pid=P8629&user=793427)

[超级模板](https://www.luogu.com.cn/paste/1cf7sp8b)

---

## 作者：Smg18 (赞：0)

我们可以先根据题目得到公式：

$$sum=a_{1}(2^{n+1}-1)$$

$sum$ 为机器人总数，$a_{1}$ 为最初数量，$n$ 为年数。

然后带入公式，但是我们这个公式要等式转换成：

$$\frac{sum}{2^{n+1}-1}=a_{1}$$

高精度建议 Python。

```python
n, sum = map(int, input().split())
a1 = sum // (2 ** (n + 1) - 1)#整除，机器分不开呀
print(a1+1)
```


---

## 作者：MspAInt (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8629)

简单推导。

我们可以先用 $n=4$ 这个例子列出一个式子：

$$x+2x-1+2(2x-1)-1+2(2(2x-1)-1)-1+2(2(2(2x-1)-1)-1)-1=s$$

一堆 $2$，好烦，所以拆开。

$$x+2x-1+4x-2-1+8x-4-2-1+16x-8-4-2-1$$

合并一部分同类项。

$$x+(2x-1)+(4x-3)+(8x-7)+(16x-15)$$

把每个括号当作一项，显然经过 $n$ 年就是前 $n+1$ 项。先代入样例看看：

$$x+2x-1+4x-3=7x-4=31$$

这玩意就是个一元一次方程。

现在的问题是，对于此题 $ax-b=c$ 的形式，如何求 $a,b$。

还记得第二个式子中的一次项是怎么来的吗？它们是由第一个式子使用乘法分配律转化而来的。事实上，这个过程中我们把每一年所增加的机器人数“从里到外”进行拆分。举个例子，对于 $2(2(2x-1)-1)-1$，具体步骤如下：

$$2(2(2x-1)-1)-1=2(4x-2-1)-1=8x-4-2-1$$

注意到在乘法分配的过程中，一次项系数被乘上了很多 $2$。由于每过年都会乘上一个 $2$（这里先不讨论常数项），所以对于前 $n$ 年，一次项系数和为：

$$a=2^0+2^1+\dots+2^{n-1}+2^{n}=2^{n+1}-1$$

常数项同理，每一次乘法分配都会乘上一个 $2$。另外，每一次拆开括号，就会减去 $1$。此时再看上面的具体步骤，我们发现，外面套了多少层括号，该常数项就会乘上（被分配）多少个 $2$。因为每一次减 $1$ 都携带着一个乘 $2$。可以发现，由于每一年增加的机器人个数都是上一年的机器人个数乘 $2$ 减 $1$，所以每一年都会多出一个括号（参考第一个式子），并在括号外多出一个 $-1$。显然，对于第 $n$ 年，我们可以对常数项列出如下等式：

$$b_0=2^{n-1}+2^{n-2}\dots+2^1+2^0$$

那么对于前 $n$ 年的常数项总和即为：

$$b_1=0+(2^0)+(2^1+2^0)+\dots+(2^{n-2}+2^{n-3}\dots+2^1+2^0)+(2^{n-1}+2^{n-2}\dots+2^1+2^0)$$

根据 $2$ 次幂的性质（$2^0+2^1+\dots+2^{n-2}+2^{n-1}=2^n-1$）可以化为：

$$b_1=2^1-1+2^2-1+\dots+2^{n-1}-1+2^n-1$$

化简得：

$$b_1=2^1+2^2+\dots+2^{n-1}+2^n-n$$

前面一堆 $2$ 的次幂，就差一个 $2^0$。那么后面加上一个 $2^0-1$，保证等式不变，还能进一步化简：

$$b_1=2^{n+1}-n-2$$

解释一下，由于加上 $2^0$ 满足了上面二次幂的性质，所以那一长串的数可以化为 $2^{n+1}-1$，保证等式不变还要减去 $1$（$2^0$），最后把总共 $n$ 个 $-1$ 合并变成 $-n$，就变成一个非常清爽的式子了。

现在得到了方程的所有系数，直接求解。答案显然为 $\frac{s+(2^{n+1}-n-2)}{2^{n+1}-1}$。

注意要写高精度。

---


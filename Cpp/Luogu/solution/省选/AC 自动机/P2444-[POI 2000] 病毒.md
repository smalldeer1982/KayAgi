# [POI 2000] 病毒

## 题目描述

二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。

示例：

例如如果 $\{011, 11, 00000\}$ 为病毒代码段，那么一个可能的无限长安全代码就是 $010101 \ldots$。如果 $\{01, 11, 000000\}$ 为病毒代码段，那么就不存在一个无限长的安全代码。

现在给出所有的病毒代码段，判断是否存在无限长的安全代码。

## 说明/提示

$1 \leq n \leq 2000$，所有病毒代码段的总长度不超过 $3 \times 10^4$。

## 样例 #1

### 输入

```
3
01 
11 
00000
```

### 输出

```
NIE```

# 题解

## 作者：Sooke (赞：162)

## 思路概述

我们知道，AC自动机是一种多模字符串匹配算法。构造 Trie 树 后，在模式串末尾一位的结点作上标记。平常的 AC自动机 是尽量能多接触到这些标记，使总值最大。本题倒是有点奇葩，要构造一个可行的无限长文本串，使没有任何子串为给出模式串中的一个。也就是说，我们需要让平常 AC自动机 的查询操作，尽量避免标记，能用失配指针跳转就跳转。

因为要有无限长的可行串，根据 AC自动机 的原理，我们可以将结点连接到儿子的边当作一条单向边，同时失配指针也当作一条单向边，如果存在一个环，且环上没有任何危险标记（即病毒代码段末尾一位的结点专门作的编号），此时 AC自动机 能一直在环上匹配，并且永远也不会得到为模式串的一个子串，就像程序中的死循环一样。这个找环我们可以通过 dfs 来实现。

## 注意事项

- 1 . 我们需要建立两个布尔数组，其中一个布尔数组记录每个节点在当前 dfs 走的路径上有没有被选中，另一个布尔数组记录每个节点历史上有没有被访问过。如果当前路径形成回路，就找到环了，应该还是比较好实现的。

- 2 . 避免危险标记，也就是说如果下一个结点拥有危险标记，就不走那个结点。

- 3 . 在构造失配指针时，一个很明显的优化是：如果一个结点拥有了失配指针，它指向的结点如果有危险标记，自己必然也危险，因为它到根结点形成的串是自己到根节点的后缀。

## 代码实现

代码和注释都认认真真打了，如果上面的概述有点难懂的话……请结合代码和该行的注释进行理解吧。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>

using namespace std;

queue < int > Q; // 标失配结点编号所需的队列 

struct Node{
    int t[2] , f; // t 数组为下个二进制位结点编号，f 为失配结点编号
    bool c; // c 变量为该结点是否为危险代码段的最后一位 
}; // 定义字典树结点结构体
struct AcAutomaton{
    Node N[30001]; // 字典树的结点
    int S = 0; // 字典树的当前非根节点总数
    inline void Insert(char c[] , int l){ 
        int nd = 0; // 定义当前点，当然从根节点 0 开始
        for(int i = 0 ; i < l ; i++)
            if(N[nd].t[c[i] - 48] == 0)
                N[nd].t[c[i] - 48] = ++S , nd = S; // 没有目标节点，新建个
            else
                nd = N[nd].t[c[i] - 48]; // 有目标节点，直接转移当前点
        N[nd].c = true; // 标上病毒段末尾的危险标记      
    } // 函数：向字典树内插入长度为 l 的病毒串 
    inline void PutFail(){
        if(N[0].t[0] > 0)
            Q.push(N[0].t[0]); // 根节点有没有 0 儿子，如果有推入队列
        if(N[0].t[1] > 0)
            Q.push(N[0].t[1]); // 根节点有没有 1 儿子，如果有推入队列
        while(!Q.empty()){
            int nd = Q.front() ; Q.pop(); // 得到队列首
            for(int i = 0 ; i <= 1 ; i++)
                if(N[nd].t[i] > 0){
                    Q.push(N[nd].t[i]);
                    int td = N[nd].f;
                    while(td > 0 && N[td].t[i] <= 0)
                        td = N[td].f; // 要不到根节点，要不找到最长匹配后缀段
                    if(N[td].t[i] <= 0)
                        N[N[nd].t[i]].f = 0; // 失配指针转移到根节点 
                    else{
                        N[N[nd].t[i]].f = N[td].t[i];
                        if(N[N[td].t[i]].c)
                            N[N[nd].t[i]].c = true;
                        // 既然自己后缀都行不通，自己也危险 
                    }
                }else
                    N[nd].t[i] = N[N[nd].f].t[i]; 
        } 
    } // 函数：设置失配指针 
}; // 定义 AC 自动机结构体 

AcAutomaton A; // 新建 AC 自动机 
bool v[30001]; // v 为结点是否是当前搜索路径上的一点
bool f[30001]; // f 为结点是否是否被现在或过往搜索过 
char c[30001];
int n;

void Dfs(int d){ // 通过搜索寻找有没有环 
    v[d] = true; // 作下路径标记 
    for(int i = 0 ; i <= 1 ; i++) 
        if(v[A.N[d].t[i]]){ // 根据路径标记判断是否拥有环
            printf("TAK");
            exit(0); // 找到了环，输出并退出程序 
        }else if(!A.N[A.N[d].t[i]].c && !f[A.N[d].t[i]]){
            // 只有下一位不为危险结点并且有可能成环，才递归搜索
            f[A.N[d].t[i]] = true; // 下一个结点已经被搜索过了 
            Dfs(A.N[d].t[i]); 
        }
    v[d] = false; // 抹除路径标记 
}

int main(){
    scanf("%d" , &n); // 输入病毒串数量（这个不用我打注释了吧……） 
    for(int i = 1 ; i <= n ; i++)
        scanf("%s" , c) , A.Insert(c , strlen(c)); // 输入并插入病毒串;
    A.PutFail(); // 设置每个结点的失配指针
    Dfs(0); // 从字典树的根结点开始找环 
    printf("NIE"); // 既然程序没有退出，就输出无解 
    return 0;
}
```

---

## 作者：FlashHu (赞：80)

AC自动机入门——[yyb巨佬的博客](http://www.cnblogs.com/cjyyb/p/7196308.html)

AC自动机入手经典好题~~（虽然年代久远）~~

有了fail指针，trie树就不是原来的树型结构了，我们可以把它叫做trie图，由父节点向子节点连的边和fail代表的边构成（都是单向边）。

最模板的AC自动机，就是直接匹配字符串。然而这题思维并非如此简单。

来一波逆向思维。假设我们构造出了一个无限长的安全代码，再拿到AC自动机上匹配，会发生什么？

没错，当我们一位一位地匹配的时候，我们会发现，永远都不会跳到某个病毒代码段结尾的位置（以后把这里称作**危险节点**，因为匹配到此处表明已经出现了某个病毒代码段），然后似乎会在自动机里永无止境地打转转。。。。。。

既然这个自动机又像一个图，那我们的问题不就变成了——在AC自动机(trie图)中寻找**一个环**，并且**环上没有任何危险节点**，并且还要注意，**这个环能被根节点访问到**（也就是说从根节点出发能在不经过危险节点的情况下走到到这个环，不然在模拟AC自动机匹配的时候无法到达这个这个环，也就失去了意义，楼上Dalao这里可能表述不尽准确）。

找环就属于图论了，**DFS**一遍，只不过**必须从根节点出发**（上面提到）。开两个布尔数组，一个记录历史是否访问过，一个记录是否在搜索的栈中。如果搜索过程中发现将要访问的下一个节点之间已经入栈了，就找到解了。不走危险节点，不走历史访问过而已经不在栈中的节点。还注意一下，**如果某节点fail指向的是危险节点，那么该节点也是危险节点**，AC自动机的性质，这里不再赘述。

多说几句，数据太小（因为年代久远？），根本不像AC自动机的题目。。。。。。~~提交记录都是0ms，若想冲榜要压空间，开short吧。我还是承认yyb_test比FlashHu强多啦！~~

下面是数组代码，可结合注释与上面的分析。
```
#include<cstdio>
#include<cstdlib>
const int N=33333;
short c[N][2],f[N],q[N];//没错short
bool e[N],vis[N],inst[N];
char s[N];
void dfs(short u)
{
	if(inst[u])puts("TAK"),exit(0);//找到啦，直接拜拜
	if(vis[u]||e[u])return;//走不通
	inst[u]=vis[u]=1;
	dfs(c[u][0]);
	dfs(c[u][1]);
	inst[u]=0;//两个标记意义不同，这个记得搜完清0
}
int main()
{
	fread(s,1,N,stdin);
	short n,i,u,v,cnt=0,h=0,t=0;
	char*p=s;
	n=*p&15;
	while(*++p>' ')n*=10,n+=*p&15;
    //建自动机
	while(n--)
	{
		while(*++p<=' ');
		for(u=0;*p>' ';++p)
		{
			if(!c[u][i=*p&1])c[u][i]=++cnt;
			u=c[u][i];
		}
		e[u]=1;//标记危险节点（这时还没把所有的危险节点都找出来）
	}
    //处理fail以及危险节点
	if(c[0][0])q[++t]=c[0][0];
	if(c[0][1])q[++t]=c[0][1];
	while(h<t)
	{
		u=q[++h];
		for(i=0;i<=1;++i)
			if((v=c[u][i]))f[q[++t]=v]=c[f[u]][i],e[v]|=e[f[v]];
            //这时候才都找出来了
			else c[u][i]=c[f[u]][i];//直接改空儿子，方便失配处理
	}
	dfs(0);
	puts("NIE");//这时全搜遍了还没找到
	return 0;
}
```

---

## 作者：Refun (赞：23)

QvQ现在才理解AC自动机buildfail的时候继承儿子其实就相当于把trie树补成trie图

对于这个题只需要建好trie图，然后在trie图上找一个环

为什么呢？因为我们如果拿一个安全代码在自动机上跑

一定会不停的跑而到不了单词的结束点，这就要求必须有个环

而且这个环要求必须经过根节点，且不经过一些限制节点

限制节点包括单词的结束节点，还有若一个点的fail指向的点是限制节点

那么这个点也是限制节点。

因为fail指向的是当前串的最长后缀，

fail指向的后缀都是病毒了，那当前串本身一定也是病毒了

[代码QwQ](http://www.cnblogs.com/refun/p/8685602.html)

---

## 作者：天宇裨益 (赞：13)

  本题主要寻找是否存在一个循环元使得其无限扩大。
  
  我们的目的在于寻找这样的循环元。
  
  而我们就需要先将所有的模式串放进trie树上。然后我们需要明确一个东西
  
  就是每个单词的末尾属于非法状态，若该节点的fail指针所指向的状态非法
  
  那它也是非法的，所以我们先处理出所有非法状态，同时处理fail树。
  
  
------------

```cpp
inline void built(){
	for(int i=0;i<2;i++){if(trie[0][i])q.push(trie[0][i]);}
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=0;i<2;i++){
			if(trie[x][i]){
			fail[trie[x][i]]=trie[fail[x]][i];q.push(trie[x][i]);
			if(en[trie[fail[x]][i]]) en[trie[x][i]]=1;}
			else trie[x][i]=trie[fail[x]][i];
		}
	}
}
```
------------
  下一步在于找环上，我们在dfs上处理环的问题，我们如果发现第二次发现
  v[x]=1,则证明出环已经发现，我们考虑一条路找到黑，如果这条路走到底
  都没有找到环，说明这个点并不合法。所以将v[x]=-1;下次遇见时直接return false;
  
 
------------
```cpp
inline bool dfs(int x){
	if(v[x]==1) return true;
	if(v[x]==-1) return false;
	v[x]=1;
	for(int i=0;i<=1;i++){if(!en[trie[x][i]]){if(dfs(trie[x][i]))return 1;}}
	v[x]=-1;
	return false;
}
```
------------
完整代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
#define ll long long

using namespace std;
queue<int> q;
const int maxn=30030;
int trie[maxn][2],fail[maxn],n,tot,v[maxn];
char s[maxn];
bool en[maxn];
inline void insert(){
	int len=strlen(s),p=0;
	for(int i=0;i<len;i++){
		int ch=s[i]-'0';
		if(!trie[p][ch])trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	en[p]=true;
}
inline void built(){
	for(int i=0;i<2;i++){if(trie[0][i])q.push(trie[0][i]);}
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=0;i<2;i++){
			if(trie[x][i]){
			fail[trie[x][i]]=trie[fail[x]][i];q.push(trie[x][i]);
			if(en[trie[fail[x]][i]]) en[trie[x][i]]=1;}
			else trie[x][i]=trie[fail[x]][i];
		}
	}
}
inline bool dfs(int x){
	if(v[x]==1) return true;
	if(v[x]==-1) return false;
	v[x]=1;
	for(int i=0;i<=1;i++){if(!en[trie[x][i]]){if(dfs(trie[x][i]))return 1;}}
	v[x]=-1;
	return false;
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){scanf("%s",s);insert();}
	built();
	if(dfs(0))cout<<"TAK"<<endl;
	else cout<<"NIE"<<endl;
	return 0;
}
```



  




---

## 作者：Tommy_clas (赞：6)

前言：这道题我之前做完了以后便没有再管，直到今天我又做了一道和这道题有异曲同工之妙的$AC$自动机题目后，我想做一个总结，顺带写一下两道题的题解。

[传送门1](https://www.luogu.com.cn/problem/P2444)

题目大意：给定$n$个$01$串，保证$01$串长度之和不超过$30000$，询问是否存在无限长的$01$串，使得给定串都不是它的子串。

多个子串匹配一个模板串的问题一般能使用$AC$自动机解决，因此我们将这些$01$串建造出一个自动机。

但是这里有一个问题：$AC$自动机一般解决的是子串问题，而不是“不是子串问题”，然后该怎么做呢？

这里我们就需要考虑$AC$自动机的性质：它的本质是一个有向图，而从当前点出发去哪个点完全由当前匹配串对应位置的字符决定，而$fail$指针连起来的一系列节点（也就是$fail$树上竖直方向的链）在匹配上是等价的（也就是如果$u.fail=v$，而$v$有某个串的结尾标记，则匹配到$u$也说明存在该子串）。

而题目要求我们不存在给定的串是子串，也就是要求在匹配字符串时不能经过

**有结尾标记的节点**

或 

**能通过$fail$指针跳到有结尾标记的节点的节点**。

而“无限长”就是指**删去不能经过的节点以后形成的有向图存在环**

因为如果删点后的$AC$自动机有环，就说明存在字符串能在不经过删除点的前提下无限匹配下去，也就是无限长。

但是如果暴力判断某个节点能否跳$fail$指针跳到存在结尾标记的节点会$TLE$，因此我们可以考虑在构造$fail$指针时一起判断。

具体方法如下：
~~~cpp
while(!q.empty())
{
	int x=q.front();q.pop();
	for(int i=0;i<2;i++)
	{
		int y=t[x].ch[i];
		if(y)
		{
			t[y].fail=t[t[x].fail].ch[i],q.push(y);
			if(t[t[y].fail].ed)t[y].ed=1;//此处为判断方法
		}
		else t[x].ch[i]=t[t[x].fail].ch[i];
	}
}
~~~
由于$fail$指针的构建是从上而下的，因此我们一定会从上而下的访问要删除的节点，这样我们只需要查看该节点的$fail$指针所连的节点是否被删除，就能知道该节点是否要被删除。

节点的删除只需要给节点打上标记，然后在图上$dfs$的时候，不访问已经打过标记的节点即可。

然后问题就变成了有向图上找环问题了，该问题便不再赘述。

上代码：
~~~cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define N 2005
#define M 30005
using namespace std;
int n,rt,tot,cnt;
bool cir,vis[N*M/10],f[N*M/10];
char s[M];
struct AC
{
	int ch[2],fail;bool ed;
}t[N*M/10];
void add()
{
	if(!rt)rt=++tot;
	int l=strlen(s+1),p=rt;
	for(int i=1;i<=l;i++)
	{
		p=t[p].ch[s[i]-'0']=t[p].ch[s[i]-'0']?t[p].ch[s[i]-'0']:++tot;
		if(i==l)t[p].ed=1;
	}
}
void build_fail()
{
	queue<int>q;
	for(int i=0;i<2;i++)
	{
		if(t[1].ch[i])t[t[1].ch[i]].fail=1,q.push(t[1].ch[i]);
		else t[1].ch[i]=1;
	}
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=0;i<2;i++)
		{
			int y=t[x].ch[i];
			if(y)
			{
				t[y].fail=t[t[x].fail].ch[i],q.push(y);
				if(t[t[y].fail].ed)t[y].ed=1;
//将这个节点跳fail指针得到的所有节点是否存在标记集中体现到一个节点上,换而言之，如果一个节点跳fail指针能到标记节点，那么它也是要打标记的 
			}
			else t[x].ch[i]=t[t[x].fail].ch[i];
		}
	}
}
void dfs(int x)//模仿AC自动机的匹配过程，如果出现不经过危险节点的环就说明存在无限长的代码 
{
	vis[x]=1;
	for(int i=0;i<2;i++)
	{
		int y=t[x].ch[i];
		if(vis[y])
		{
			cir=1;return;
		}
		if(t[y].ed||f[y])continue;
		f[y]=1;
		dfs(y);
		if(cir)return;
	}
	vis[x]=0;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		add();
	}
	build_fail();
	dfs(1);
	if(cir)puts("TAK");
	else puts("NIE");
	return 0;
}
~~~

[传送门2（谢绝吐槽）](http://ybt.ssoier.cn:8088/problem_show.php?pid=1705)

题目描述：给定$m$个长度不超过$10$的$DNA$序列，一个$DNA$序列是合法的，当且仅当任何给定序列都不是它的子串，求合法的长度为$n$的$DNA$序列个数，对$100000$取模，保证$m≤10,n≤2e9$。

一开始的转化和上一道题完全相同，问题就变为了“求有向图中固定起点和路径长度的路径个数”。

我们可以设数组$dp[i][j]$表示从根出发，走了$i$步，最终到达$j$的路径数，转移显然。

但是路径长度最大是$2e9$，空间和时间都不允许。

怎么样才能压缩空间？这里可以考虑一下倍增。

我们设$dp[t][i][j]$表示从点$i$出发，经过$2^t$条边，最终走到点$j$的方案数。可以得到转移方程：

$dp[t][i][j]=\sum_{k=1}^{tot}dp[t-1][i][k]\times dp[t-1][k][j]$

其中$tot$表示$AC$自动机的总节点个数，不超过$m^2$个。

这样预处理的时间复杂度是$O(m^6log_2n)$，空间复杂度是$O(m^4log_2n)$，可以承受。

预处理之后就需要求解固定长度的路径数。

因此我们可以将$n$拆成$log_2n$个$2$的次幂之和，并将对应的指数存入数组$a$中。

与此同时我们再设$dp2[i][j]$表示从根节点出发，经过了$\sum_{k=1}^{i}2^{a_k}$条边，最终走到$j$点的方案数。转移方程：

$dp2[t][i]=\sum_{j=1}^{tot}dp2[t-1][j]\times dp[a[t]][j][i]$

显然，最后的答案是$\sum_{i=1}^{tot}dp2[a.size][i]$。

上代码：
~~~cpp
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#define N 105
#define ll long long
using namespace std;
int n,m,rt,cnt,a[N];
ll dp[35][N][N],dp2[35][N],ans;
const ll mod=100000;
char s[N];
struct AC
{
	int fail,ch[4],ed;
}t[N];
int chk(char c)
{
	if(c=='A')return 0;
	else if(c=='C')return 1;
	else if(c=='T')return 2;
	else return 3;
}
void add()
{
	if(!rt)rt=++cnt;
	int len=strlen(s+1);
	for(int i=1,nw=rt;i<=len;i++)
	{
		int c=chk(s[i]);
		if(!t[nw].ch[c])t[nw].ch[c]=++cnt;
		nw=t[nw].ch[c];
		if(i==len)t[nw].ed=1;
	}
}
queue<int>q;
void build()
{
	for(int i=0;i<4;i++)
	{
		int y=t[rt].ch[i];
		if(y)t[y].fail=rt,q.push(y);
		else t[rt].ch[i]=rt;
	}
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=0;i<4;i++)
		{
			int y=t[x].ch[i];
			if(y)
			{
				t[y].fail=t[t[x].fail].ch[i],q.push(y);
				if(t[t[y].fail].ed)t[y].ed=1;
			}
			else t[x].ch[i]=t[t[x].fail].ch[i];
		}
	}
}
void init()
{
	for(int i=1;i<=cnt;i++)
	{
		if(t[i].ed)continue;
		for(int jj=0;jj<4;jj++)
		{
			int j=t[i].ch[jj];
			if(t[j].ed)continue;
			dp[0][i][j]++;
		}
	}
	int K=log(n)/log(2);
	for(int t=1;t<=K;t++)
		for(int k=1;k<=cnt;k++)
			for(int i=1;i<=cnt;i++)
				for(int j=1;j<=cnt;j++)
					dp[t][i][j]=(dp[t][i][j]+dp[t-1][i][k]*dp[t-1][k][j]%mod)%mod;
}
int main()
{
	scanf("%d %d",&m,&n);
	for(int i=1;i<=m;i++)
		scanf("%s",s+1),add();
	build(),init();
	int temp=n;
	for(int i=0;temp;i++,temp>>=1)
		if(temp&1)a[++a[0]]=i;
	dp2[0][rt]=1;
	for(int t=1;t<=a[0];t++)
		for(int i=1;i<=cnt;i++)
		{
			for(int j=1;j<=cnt;j++)
				dp2[t][i]=(dp2[t][i]+dp2[t-1][j]*dp[a[t]][j][i]%mod)%mod;
			if(t==a[0])ans=(ans+dp2[t][i])%mod;
		}
	printf("%lld\n",ans);
	return 0;
}
~~~
更新日志：修改了一些细节问题，删除了奇怪网址。


---

## 作者：ωαηg (赞：4)

### 一句话题意
给你若干模式串，全部由01构成，问是否能够找到一个无限长的由01构成的母串，使得任意一个模式串都不是这个母串的子串。

### Solution
看到“子串”二字，我们显然可以想到模式串匹配。又因为这里有很多模式串，所以这是一道AC自动机。

AC自动机的基本操作是什么？

1. 针对所有的模式串，建立一棵trie树；
2. 求出该trie树所有节点的前缀指针；
3. 把母串在trie树上匹配。

我们现在要让母串无限长，但是不能让任意一个模式串是母串的子串，也就是说：

**我们需要让母串在trie树上不停地匹配、失配，但是不能经过任何一个模式串的结尾节点，如此循环往复，直到永远**

因此：

**我们需要在trie树上找到一个不经过任何结尾节点的环**


那么如何找这个环呢？

----

在找环之前，我们先明确一下什么是“结尾节点”：
  
在建立trie树的过程中，我们会把每个字符串的结尾所在的节点都标记一下，那么这就是结尾节点。

但这并不是全部的结尾节点。

根据前缀指针的定义可知，经过这个节点就相当于经过这个节点的失配节点。所以：

**一个节点是结尾节点，当且仅当其本身是结尾节点，或者其失配节点是结尾节点，或者失配节点的失配节点是结尾节点，或者失配节点的失配节点的。。。是结尾节点。**

在找完前缀指针后，我们可以通过手写队列里面的残留数据来找出所有结尾节点，具体见代码。

----
我们回到正题。

如何找环？

这里介绍一种比较神奇的方法：dfs版spfa找环。

相比起bfs版spfa，dfs版spfa在找环方面有着明显的优势。因为它不用每次都放进队列的尾部。如果找到一个点，我们就可以立即从这个点开始向外拓展。在面对随机数据时，其效率远胜于bfs。~~当然构造数据我就不清楚了~~

~~(若不会写dfs版spfa请自行查阅资料）~~

代码看一下：
```cpp
void spfa(int x,int h){
    if(PC) return;//PC表示当前是否已经找到了正环
    vis[x]=h;//染色
    for(int i=0;i<2;i++){
        int y=ch[x][i];//字典树中的儿子
	if(bo[y] || y==0) continue;
        //bo[i]表示i是否是结尾节点
	if(dist[y]<dist[x]+1){
	    dist[y]=dist[x]+1;
	    if(!vis[y]){
	        spfa(y,h);
	        if(PC) return;
	    }
	    else if(vis[y]==h){
	             PC=true;
	             return;
	         }
        }
   }
   vis[x]=0;//回溯
}
```
其中vis和dist的初始值均为0

什么？为什么dist为0？请参阅《信息学奥赛一本通 · 提高篇》第三章

----

以下是全部代码：

```cpp
#include<bits/stdc++.h>
#define next Next//防止与头文件重名
using namespace std;
int const maxn=3e4+5;
int const maxz=2;
int n,tot=1,ch[maxn][maxz],next[maxn],dist[maxn],vis[maxn],que[maxn];
bool bo[maxn],PC;
char s[maxn];
inline void insert(char *s){//字典树的插入操作
	int u=1,len=strlen(s);
	for(int i=0;i<len;i++){
		int c=s[i]-'0';
		if(!ch[u][c]) ch[u][c]=++tot;
		u=ch[u][c];
	}
	bo[u]=true;//标记该节点，为结尾节点
}
inline void bfs(){//AC自动机基本操作：求出字典树中每个节点的前缀指针
	next[1]=0,que[1]=1;
	for(int l=1,r=1;l<=r;l++){
		int u=que[l];
		for(int i=0;i<2;i++){
			if(!ch[u][i]) ch[u][i]=ch[next[u]][i];
			else{
				que[++r]=ch[u][i];
				next[ch[u][i]]=ch[next[u]][i];
			}
		}
	}
}
void spfa(int x,int h){//dfs版spfa找环
	if(PC) return;
	vis[x]=h;
	for(int i=0;i<2;i++){
		int y=ch[x][i];
	    if(bo[y] || y==0) continue;
		if(dist[y]<dist[x]+1){
			dist[y]=dist[x]+1;
			if(!vis[y]){
			    spfa(y,h);
			    if(PC) return;
		    }
		    else if(vis[y]==h){
			    PC=true;
			    return;
		    }
		}
	}
	vis[x]=0;
}
int main(){
	for(int i=0;i<2;i++)
	  ch[0][i]=1;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		insert(s);
	}
	bfs();
	for(int i=1;i<=tot;i++)
	  bo[que[i]]=bo[que[i]] || bo[next[que[i]]];
    //广搜的队列已经空了，但里面仍然有残留数据，这个残留数据有很大用处，因为它是一棵树的层次遍历。可以保证在判断我这个节点的时候，我的失配节点已经判断过了。
	PC=false; 
	for(int i=1;i<=tot;i++)
	  if(!bo[i]){
		  spfa(i,i);
		  if(PC) break;
	  }//spfa判负环的基本操作
	PC?puts("TAK"):puts("NIE");
	return 0;  
}


---

## 作者：Celtic (赞：2)

题意：给出$n$个$01$串，求是否存在一个无限长的$01$串，使得这$n$个$01$串都不是这个无限长的$01$串的子串。

我们给$n$个$01$串建出$Trie$图，给每个$01$串的结尾节点打上标记，代表这个点表示的字符串不能出现在构造出的串中。同时如果一个点得$fail$指针带有标记，那么他自己一定也不能出现，我们给他也打上标记。问题就等价于在$Trie$图中是否存在一个环，环上的每个节点都没有标记。直接$dfs$即可。

代码
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#include<tr1/unordered_map>
#define re register
#define N 30001
#define MAX 2001
#define inf 1e18
#define eps 1e-10 
using namespace std;
typedef unsigned long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
    ret=pd?-ret:ret;
    return;
}
ll n,trie[N][2],tot,f[N],nxt[N];
char s[N];
inline void insert()
{
	re ll p=0,len=strlen(s+1);
	for(re int i=1;i<=len;i++)
	{
		re ll c=(s[i]&15);
		if(!trie[p][c])
			trie[p][c]=++tot;
		p=trie[p][c];
	}
	f[p]=true;
	return;
}
inline void bfs()
{
	queue<ll>q;
	if(trie[0][0])
		q.push(trie[0][0]);
	if(trie[0][1])
		q.push(trie[0][1]);
	while(!q.empty())
	{
		re ll p=q.front();
		q.pop();
		for(re int i=0;i<2;i++)
		{
			if(!trie[p][i])
				trie[p][i]=trie[nxt[p]][i];
			else
			{
				nxt[trie[p][i]]=trie[nxt[p]][i];
				f[trie[p][i]]|=f[nxt[trie[p][i]]];
				q.push(trie[p][i]);
			}
		}
	}
	return;
}
tr1::unordered_map<ll,bool>vis,vst;
inline void dfs(re ll deep)
{
	if(f[deep])return;
	if(vis[deep])
	{
		puts("TAK");
		exit(0);
	}
	if(vst[deep])
		return;
	vis[deep]=true;
	vst[deep]=true;
	dfs(trie[deep][0]);
	dfs(trie[deep][1]);
	vis[deep]=false;
}
signed main()
{
	read(n);
	for(re int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		insert();
	}
	bfs();
	dfs(0);
	puts("NIE");
	exit(0);
}
```


---

## 作者：bluewzl (赞：1)

这道题拿到题，可以很清晰地知道题目要求我们要找一个无限长的串使其做多模式串匹配永远不会匹配成功，翻译过来就是要让一个无限长的串在多个模式串建成的AC自动机上永远到达不到被标记为模式串末尾的点，由于被匹配的串是无限长的，因此可以很容易想到要让匹配这个串时要进入一个没有任意被标记点的环上，并在上面不断跳动，因此我们只需建完AC自动机后跑个Tarjan也行，dfs也行，找到AC自动机上的环，若存在就说明有满足要求的串，否则无。

以下为鄙人的代码：
```
#include "cstdio"
#include "cstring"
#include "algorithm"
#include "queue"
#define MAXN 100000 + 10
#define ll long long

using namespace std;

struct ACauto
{

	int node[2][MAXN];
	int f[MAXN];
	bool tag1[MAXN];
	int tops;
	queue < int > q;
	
	inline void pusht( char *s )
	{
		int str = strlen( s + 1 ) , k = 0 , ss;
		for( int i = 1 ; i <= str ; i++ )
		{
			ss = s[i] - '0';
			node[ss][k] = !node[ss][k] ? ( ++tops ) : node[ss][k];
			k = node[ss][k];
		}
		tag1[k] = 1;
		return ;
	}

	inline void getfail()
	{
		for( int i = 0 ; i <= 1 ; i++ )
			if( node[i][0] )
			{
				f[ node[i][0] ] = 0;
				q.push( node[i][0] );
			}
		while( !q.empty() )
		{
			int head = q.front(); q.pop();
			for( int i = 0 ; i <= 1; i++ )
				if( node[i][head] ) { 
					f[ node[i][head] ] = node[i][ f[head] ]; 
					q.push( node[i][head] );
					if( tag1[ node[i][ f[head] ] ] ) tag1[ node[i][head] ] = 1;
				}
				else node[i][head] = node[i][ f[head] ]; 
		}
		return ;
	}

};

char s[MAXN];
ACauto A;
bool used1[MAXN] , used2[MAXN];
bool flg;

inline void dfs( int t )
{
	used1[t] = 1;
	if( A.tag1[t] ) { return ; }
	used2[t] = 1;
	for( int i = 0 ; i <= 1 ; i++ )
	if( !used1[ A.node[i][t] ] ) {
		dfs( A.node[i][t] ); 
		if( flg ) return ;
	}
	else if( used2[ A.node[i][t] ] ) { flg = 1; return ; }
	used2[t] = 0;
	return ;
}

int main()
{
	int n;
	scanf( "%d" , &n );
	for( int i = 1 ; i <= n ; i++ )
	{
		scanf( "%s" , s + 1 );
		A.pusht( s );
	}
	A.getfail();
	dfs( 0 );
	flg ? printf( "TAK\n" ) : printf( "NIE\n" );
	return 0;
}


---

## 作者：弦巻こころ (赞：0)



题意就是给你n个模式串，问你是否有一个无限长的文本串，使得这个文本串不包含任何一个模式串。

平常的AC自动机都是让你求是否有一个文本串能匹配多少模式串，这个题却反其道而行之，让你求一个不包含任何一个模式串的文本串是否存在。

我们略加分析就可以得出，只要我们找到一个不包含任何一个模式串的字符串环，就一定存在，反之就一定不存在。

对于怎么找这个环我们就设一个危险标记$ e $。这个$e$就是将串尾以及所有爆跳$fail$值最终能跳到串尾的值打为1.然后为了避免重复做无用功我们就设一个$vis$这样就不会重复找一个值了（相当于一个记搜？），然后如果我们找到了这一次dfs访问过的点就证明有直接输出$ TAK $就行了。如果找不到就说明一定不存在就输出$ NIE $。

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;		
char s[100005];
int fail[maxn],trie[maxn][2];
int n,tot;
bool vis[maxn],inst[maxn],e[maxn];//vis 记搜 e危险标记 inst 找环
void dfs(int u)
{
	if(inst[u])//如果找到了环
	{
		puts("TAK");
		exit(0);
	}
	if(vis[u]||e[u])//如果访问到了之前的无用点或危险节点就返回
	{
		return ;
	}
	inst[u]=vis[u]=1;
	dfs(trie[u][1]);
	dfs(trie[u][0]);
	inst[u]=0;//注意此处的与vis定义不同需清0
} 
void make_trie(char s[100005])
{
	int now=0,len=strlen(s);
	for(int i=0;i<len;i++)
	{
		int next=s[i]-'0';
		if(!trie[now][next])
		{
			trie[now][next]=++tot;
		}
		now=trie[now][next];
	}
	e[now]=1;//将串尾打上危险标记
} 
void getfail()
{
	queue<int> q;
	for(int i=0;i<2;i++)
	{
		if(trie[0][i])
		{
			fail[trie[0][i]]=0;
			q.push(trie[0][i]);
		}
	}
	int now=0;
	while(!q.empty())
	{
		now=q.front();
		q.pop();
		for(int i=0;i<2;i++)
		{
			if(trie[now][i])
			{
				fail[trie[now][i]]=trie[fail[now]][i];
				e[trie[now][i]]|=e[fail[trie[now][i]]];
                		//将可能跳到危险节点的地方打上标记
				q.push(trie[now][i]); 
				
			}else
			{
				trie[now][i]=trie[fail[now]][i];
			}
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);
		make_trie(s);
	}
	getfail();
	dfs(0);
	
	printf("NIE");
	return 0;
}
```

---

## 作者：yqbylty (赞：0)

**解题思路：**

很显然，这个要求的安全代码其实就是要求一个字符串满足给定的所有模式串都不是它的子串就行了。

对于这题而言，若当前字符的$fail$指针指向的字符是一个模式串的结尾字符，那么当前字符所在的串也一定是一个病毒串。

然后我们就可以借助$dfs$去扩展安全串了。

**Code：**

```cpp
/*Program from Luvwgyx*/
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=3e4+10;
char s[maxn];
bool f[maxn],vis[maxn];
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void print(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
void write(int x){print(x);puts("");}
struct AC_automaton{
    int tot,ed[maxn],fail[maxn],trie[maxn][2];
    void insert(char *s){
        int p=0,len=strlen(s);
        for(int i=0;i<len;i++){
            int ch=s[i]-'0';
            if(!trie[p][ch])trie[p][ch]=++tot;
            p=trie[p][ch];
        }ed[p]++;
    }
    void make_fail(){
        queue<int >q;
        memset(fail,0,sizeof(fail));
        for(int i=0;i<2;i++)if(trie[0][i])q.push(trie[0][i]);
        while(!q.empty()){
            int x=q.front();q.pop();
            if(ed[fail[x]])ed[x]=1;
            for(int i=0;i<2;i++){
                if(trie[x][i]){
                    fail[trie[x][i]]=trie[fail[x]][i];
                    q.push(trie[x][i]);
                }else trie[x][i]=trie[fail[x]][i];
            }
        }
    }
    bool query(int x){
        f[x]=1;
        for(int i=0;i<2;i++){
            if(f[trie[x][i]])return 1;
            if(vis[trie[x][i]]||ed[trie[x][i]])continue;
            vis[trie[x][i]]=1;
            if(query(trie[x][i]))return 1;
        }f[x]=0;return 0;
    }
}AC;
int main(){
    int n=read();
    for(int i=1;i<=n;i++)scanf("%s",s),AC.insert(s);
    AC.make_fail();puts(AC.query(0)?"TAK":"NIE");
    return 0;
}
```

---

## 作者：wanghaoyu1008 (赞：0)

本题要求构造一字符串，使得其无法与给定任一字符串匹配。这样有关多字符串匹配的问题，自然是用 AC自动机 处理。

但这题要求不匹配，就需要在所有不能匹配的点（链）上跑。

——哪些点（链）是可匹配的呢？就需要看对AC自动机的理解了。蒟蒻（比如我）就想当然认为只有建 trie 时标记的点是可匹配（不可到）的。其他几位发题解的$dalao_{orz}^{tql}$都能看出还有别的情况：

给出一组数据：

| 输入数据 | 正确答案 | 大部分73分代码给出答案 |
| :----------- | -----------: | -----------: |
|   | NIE | TAK |
| 4 |
| 00 |
| 101 |
| 111 |
| 10000 |


考虑在构建的 trie图 上遍历一个节点，就相当于增加一个字符。显然，这个字符不止会影响到全串，该串的每个后缀都可能是危险的。此时我们不可能去检查每个后缀，但 fail链 给我们提供了方便： fail链 上的每个节点代表的字符串都有公共的后缀。于是我们只要标记不可到达点的后继 fail链 上的结点都不可到即可。

剩下的任务就是找环，从根节点出发的环是有效的。

代码如下（acm部分为借鉴hzwer）：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int S=1e6+6;
const int X=2;

struct acm{						//AC自动机
	int cnt,c[S][X],d[S],fl[S];
	char s[S];
	int hd,tl,q[S];
	acm(){cnt=1;c[0][0]=c[0][1]=1;}
	void insrt(){				//加入串
		scanf("%s",s);
		int l=strlen(s),v=1,i;
		for(i=0;i<l;i++)
			if(c[v][s[i]-'0'])v=c[v][s[i]-'0'];
			else{++cnt;c[v][s[i]-'0']=cnt;v=cnt;}
		++d[v];
	}
	void bldfl(){				//fail链
		hd=0;tl=1;q[0]=1;
		int v,i;
		while(hd!=tl){
			v=q[hd];++hd;
			if(d[fl[v]])d[v]=1; //fail链后继标记
			for(i=0;i<X;i++)
				if(c[v][i]){fl[c[v][i]]=c[fl[v]][i];q[tl]=c[v][i];++tl;}
				else c[v][i]=c[fl[v]][i];
		}
	}
	bool dfs(int v){			//找环
		if(d[v]==-1)return 1;
		if(d[v]!=0)return 0;
		d[v]=-1;				//标记在dfs系统栈中
		if(dfs(c[v][0]))return 1;
		if(dfs(c[v][1]))return 1;
		d[v]=-2;				//找过的且已知无法找到的点标记为-2以免重复
		return 0;
	}
}acm;

int main()
{
	int n,i;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		acm.insrt();
	acm.bldfl();
	if(acm.dfs(1))printf("TAK\n");
	else printf("NIE\n");
	return 0;
}
```
总结一下，这道题虽然不是很难（与阿狸相比），但也需要对 AC自动机 一个相对透彻的理解，否则难以想到或想的不全（比如我）。

---

## 作者：Gavin·Olivia (赞：0)

emmm……最近教练讲了AC自动机，写篇题解复习一下。刚学会AC自动机的同学，建议先把模板题打完。

AC自动机简单来说就是建一棵$Trie$树，对于病毒代码的结尾，把它做一个标记，这个节尾点即为关键点。在树上每一个点建一个失配指针$fail$，从根节点到$fail$所指向的点组成的字符串是当前字符串的某一段后缀。

由上述性质，我们可以轻易得到一个结论，如果一个节点沿$fail$指针一直追溯上去，会到达一个关键点的话，就说明会访问到此节点的字符串至少包含有一段的病毒代码段。那么问题就转化成了我们要在AC自动机上找到一个环，且这个环上没有一个点的$fail$直接或间接指向关键点。那就很简单啦~$DFS$一遍就好啦~

详细实现过程请见程序。
```cpp
#include<bits/stdc++.h>
 using namespace std;
 struct node{int fail,son[26]; bool pd;}t[30005];
 bool ans,used[30005],ins[30005];
 int n,i,cnt;
 char s[30005];
 inline int read()
{
	int x=0,c; bool f=0;
	for(;(c=getchar())<'0'||c>'9';f|=c=='-');
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;
	return f?-x:x;
}
 inline void build()//建Trie树
{
	int i,l=strlen(s),now=0;
	for(i=0;i<l;i++)
	{
		if(!t[now].son[s[i]-'0']) t[now].son[s[i]-'0']=++cnt;
		now=t[now].son[s[i]-'0'];
	}
	t[now].pd=true;
}
 inline void get_fail()//建立fail指针
{
	int i,x,u; queue<int> q;
	t[0].fail=0; t[0].pd=false;
	for(i=0;i<2;i++) 
		if(t[0].son[i]) 
		{
			x=t[0].son[i]; t[x].fail=0; q.push(x);
		}
	while(!q.empty())
	{
		x=q.front(); q.pop();
		for(i=0;i<2;i++)
			if(t[x].son[i])
			{
				u=t[x].son[i]; q.push(u);
				t[u].fail=t[t[x].fail].son[i];
				t[u].pd|=t[t[u].fail].pd;
			}
			else t[x].son[i]=t[t[x].fail].son[i];
	}
}
 inline void dfs(int x)//DFS找环
{
	int i,k; ins[x]=true;
	for(i=0;i<2;i++)
	{
		k=t[x].son[i];
		if(t[k].pd) continue;
		if(!k||ins[k]){ans=true; return;}
		if(used[k])continue;
		else {used[k]=true; dfs(k);}
		if(ans) return;
	}
	ins[x]=false;
}
 int main()
{
	n=read();
	for(i=1;i<=n;i++){scanf("%s",s); build();}
	get_fail(); ans=false; dfs(0);
	if(ans) printf("TAK");
	else printf("NIE"); 
	return 0;
}
```

---


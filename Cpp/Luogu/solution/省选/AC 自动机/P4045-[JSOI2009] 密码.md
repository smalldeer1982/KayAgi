# [JSOI2009] 密码

## 题目描述

众所周知，密码在信息领域起到了不可估量的作用。对于普通的登陆口令以，唯一的破解方法就是暴力破解——逐个尝试所有可能的字母组合，但这是一项很耗时又容易被发现的工作。所以，为了获取对方的登陆口令，在暴力破解密码之前，必须先做大量的准备工作。经过情报的搜集，现在得到了若干有用信息，形如：

> ​     “我观察到，密码中含有字符串*。”

例如，对于一个 $10$ 位的密码以及观察到的字符串 `hello` 与 `world`，可能的密码组合为 `helloworld`与 `worldhello`；而对于 $6$ 位的密码以及到的字符串 `good` 与 `day`,可能的密码组合为 `gooday`。

有了这些信息，就能够大大地减少尝试的次数了。请编一个程序，计算所有密码组合的可能。密码中仅可能包含 `a-z` 之间的小写字母。

## 说明/提示

对于 $100\%$ 的数据，$1\leq L\leq 25,1\leq N\leq 10$，每个观察到的字符串长不超过 $10$，并且保证输出结果小于 $2^{63}$。


## 样例 #1

### 输入

```
10 2
hello
world```

### 输出

```
2
helloworld
worldhello```

# 题解

## 作者：皎月半洒花 (赞：19)

这里说一种跟另外两篇题解不一样的剪枝。

同时……这题大概也就是蓝~紫左右，这个黑实在太虚了。

观察题意，由 `good+day=gooday` 可知应该放在 $\rm AC$ 自动机上做，观察范围可知是状压。记 $f_{i,j,s}$ 表示匹配到串的第 $i$ 位，走到了自动机上的第 $j$ 个节点，当前已经拼完了集合 $s$ 中的模式串的方案数。那么转移自然很简单。值得提一句的的是，由于本身 $\rm AC$ 自动机存在路径压缩，所以是 `认子不认父` 的结构，只能刷表。

之后考虑输出方案。考虑一种无脑的输出方式。由于很容易 $dfs$ 出每个状态 $(i,j,k)$ 是否可以转移到终点，所以不需要考虑 $42$ 的限制，剪完枝直接输出即可。

同时，只要在 $\rm AC$ 自动机上保证每次走最小的字母，就一定是字典序最优的方案。

```cpp
int o ;
LL ans ;
int n, m ;
int t[N] ;
char s[N] ;
LL f[N][W][Z] ;
bool g[N][W][Z] ;
bool v[N][W][Z] ;

struct ACAM{
    int size ;
    int _ed[W] ;
    int fail[W] ;
    queue <int> q ;
    int trans[W][26] ;
    void Ins(char *t, int num){
        int rt = 0, len ;
        len = strlen(t + 1) ;
        for (int x, i = 1 ; i <= len ; ++ i){
            x = t[i] - 'a' ;
            if (!trans[rt][x])
                trans[rt][x] = ++ size ;
            rt = trans[rt][x] ;
        }
        _ed[rt] |= (1 << num) ;
    }
    void build(){
        for (int i = 0 ; i < 26 ; ++ i)
            if (trans[0][i]) q.push(trans[0][i]) ;
        while (!q.empty()){
            int x = q.front() ;
            q.pop() ; _ed[x] |= _ed[fail[x]] ;
            for (int i = 0 ; i < 26 ; ++ i){
                if (!trans[x][i]) trans[x][i] = trans[fail[x]][i] ;
                else fail[trans[x][i]] = trans[fail[x]][i], q.push(trans[x][i]) ;
            }
        }
    }
}S ;
bool search(int x, int y, int z){
    if (x == n){
        v[x][y][z] = 1 ;
        return g[x][y][z] = (bool)(z == o) ;
    }
    bool p = 0 ;
    if (v[x][y][z])
        return g[x][y][z] ;
    else v[x][y][z] = 1 ;
    for (int i = 0 ; i < 26 ; ++ i)
        p |= search(x + 1, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;
    return g[x][y][z] = p ;
}
void output(int x, int y, int z){
    if (!g[x][y][z]) return ;
    if (x == n){
        for (int i = 1 ; i <= n ; ++ i)
            printf("%c", t[i] + 'a') ;
        return puts(""), void() ;
    }
    for (int i = 0 ; i < 26 ; ++ i)
        t[x + 1] = i, output(x + 1, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;
}
int main(){
    cin >> n >> m ; S.size = 0 ;
    for (int i = 1 ; i <= m ; ++ i)
        scanf("%s", s + 1), S.Ins(s, i - 1) ;
    S.build() ; f[0][0][0] = 1 ; o = (1 << m) - 1 ;
    for (int i = 0 ; i < n ; ++ i)
        for (int j = 0 ; j <= S.size ; ++ j)
            for (int k = 0 ; k <= o ; ++ k)
                if (f[i][j][k])
                    for (int l = 0 ; l < 26 ; ++ l)
                        f[i + 1][S.trans[j][l]][k | S._ed[S.trans[j][l]]] += f[i][j][k] ;
    for (int i = 0 ; i <= S.size ; ++ i) ans += f[n][i][o] ;
    if (ans > 42) return printf("%lld\n", ans), 0 ;
    else return cout << ans << '\n', search(0, 0, 0), output(0, 0, 0), 0 ;
}

```

---

## 作者：longgod (赞：8)


说实在的，讲真，思路并不是很难

但是由于自己脑抽了，

所以几乎怼了一上午

重要的事情说三遍，

不要直接给字符串排序 

不要直接给字符串排序

真的不要直接给字符串排序

不然很容易翻车的…… 

废话不多说，题解：

 
一串密码，必须包含以下所有的单词

很显然，trie上面跑AC自动机构建fail指针

然后dp

几乎已经成为AC自动机的一个套路了…… 

其实在我们没看数据范围之前我们就可以大胆猜测

既然是包含所有单词的问题，没准是状压dp呢？

一看数据范围 

n<=10

很好，状压不解释

dp[i][j][S]

长度为i，并且当前状态在trie树上第j个节点，单词使用为S的方案数

在我们构建trie树的时候，对于有单词的节点，我们就设置一个from，标记它来自第几个单词

这样，在dp转移的时候，我们就可以把他和S取或，将这个单词存进S里面向下转移

那么转移的方程就可以非常轻易的推出了，

首先，我们枚举接下来可能去到的单词(a-z)

然后从当前的j往下走一层

同时长度i+1

如果这个节点恰好是个单词节点，不管三七二十一，加入到S里面去（并没有规定不可以重复使用）

最后统计dp[Len][trie树所有节点][S总]即可，

很好，如果你真的这么干的话，

你只有40分

为什么？

如果单词是 ca和a

当我们取ca之后

实际上我们已经取了a，也就是所有单词都已经出现了。

但是，我们的上述算法并不能对此作出反应，他会认为，'a'，没有出现过。

怎么办？

去掉重复单词，去除被包含单词，

只要是被其他单词所包含的单词 删掉！

重复的单词，删掉！

这么刚？

就是这么刚！

然后dp就行了

当然，最后统计答案的时候

S总的实际意义指的是没有被删除的单词的集合

等等……

还有输出方案呢!

暴搜！

当答案小于等于42时

实际上是不会存在单个字符的

严格的说，就是答案小于等于42时

必然是所有单词（去重后）以某种顺序相连所组成的

直接暴搜就好了

注意处理一下单词间的重复前后缀

我这里用了一种很暴力的方法

网上有更好的 

~~但我觉得我的更好理解~~

感觉自己代码巨丑无比
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
ll dp[35][105][2105];
struct ha
{
    int next[26];
    int fail;
    int from;
    ha()
    {
        memset(next,0,sizeof next);
        fail=from=0;
    }
}trie[205];
int Len,n,cnt;
char tmp[25][25];
int q[2550];
char save[205];
bool book[205];
char answer[55][205];
int ranky[55];
int co;
int del[105];
int all;
inline void insert(char *s,int from)
{
    register int i,j,now=0,len=strlen(s);
    all+=len;
    for(i=0;i<len;i++)
    {
        j=s[i]-'a';
        if(!trie[now].next[j])
        trie[now].next[j]=++cnt;
        now=trie[now].next[j];
    }
    trie[now].from=from;
}
inline void getfail()
{
    register int i,j,u,fail,head=1,tail=1;
    for(i=0;i<26;i++)
    if(trie[0].next[i])
    q[tail++]=trie[0].next[i];
    while(head<tail)
    {
        u=q[head++];
        for(i=0;i<26;i++)
        {
            if(!trie[u].next[i])
            {
                trie[u].next[i]=trie[trie[u].fail].next[i];
                continue;
            }
            q[tail++]=trie[u].next[i];
            fail=trie[u].fail;
            fail=trie[fail].next[i];
            trie[trie[u].next[i]].fail=fail;
        }
    }
}
inline bool getin(int k,int l,int r)
{
    register int i,j=0;
    for(i=l;i<=r;i++)
    {
        if(tmp[k][j]!=save[i]) return false;
        j++;
    }
    return true;
}
inline int in(int k,int loc,int len)//loc 要插的位置，即末尾减一 
{
    register int i,j;
    int reme=loc;
    for(i=loc-1;i>=0;i--)
    if(getin(k,i,loc-1))
    reme=i;
    i=reme;
    for(j=0;j<len;j++)
    save[i]=tmp[k][j],i++;
    if(i<loc) i=loc;
    return i;
}
inline void out(int now)
{
    for(register int i=0;i<now;i++)
    putchar(save[i]);
    putchar('\n');
}
inline void dfs(int now,int rest)
{
    register int i,j,k;
    //out(now);
    if(now>Len) return;
    if(now==Len&&rest==0)
    {
        co++;
        for(i=0;i<Len;i++)
        answer[co][i]=save[i];
        return;
    }
    else
    if(now==Len||rest==0) return;
    for(i=1;i<=n;i++)
    {
        if(del[i]||book[i]) continue;
        int len=strlen(tmp[i]);
        j=in(i,now,len);
        book[i]=true;
        dfs(j,rest-1);
        book[i]=false;
    }
}
inline bool check(char *T,char *s)
{
    register int i,j,k,l1=strlen(T),l2=strlen(s);
    if(l1<l2) return false;
    for(i=0;i<l1;i++)
    {
        if(l1-i<l2) return false;
        for(k=i,j=0;j<l2;j++)
        {
            if(T[k]!=s[j]) 
            break;
            k++; 
        }
        if(j==l2)
        return true;
    }
    return false;
}
inline bool cmp(int x,int y)
{
     for(int i=0;i<Len;i++)
     if(answer[x][i]!=answer[y][i])return answer[x][i]<answer[y][i];
     return 0;
}
inline void _swap(char *a,char *b)
{
	 register int i;
     for(i=0;i<Len;i++)
     {
     	swap(a[i],b[i]);
     }
}
int main()
{
    scanf("%d%d",&Len,&n);
    register int a,b,c,i,j,k;
    int S=1<<n;
    for(i=1;i<=n;i++)
    scanf("%s",tmp[i]);
    for(a=1;a<=n;a++)
    {
    	for(b=1;b<n;b++)
    	{
    		if(strcmp(tmp[b],tmp[b+1])==1)
    		swap(tmp[b],tmp[b+1]);
    	}
    }
    for(a=1;a<=n;a++)
    {
    	if(del[a]) continue;
        for(b=1;b<=n;b++)
    	if(b!=a&&!del[b])
    	if(check(tmp[a],tmp[b]))
    	del[b]=1;
    }
    for(i=1;i<=n;i++)
    if(!del[i])
    insert(tmp[i],i);
    getfail();
    dp[0][0][0]=1;
    for(a=0;a<Len;a++)
    {
        for(b=0;b<=cnt;b++)
        {
            for(c=0;c<S;c++)
            {
                for(k=0;k<26;k++)
                {
                    int Next=trie[b].next[k];
                    int tmpc=c;
                    if(trie[Next].from)
                    {
                        j=trie[Next].from;
                        j=(1<<(j-1));
                        tmpc|=j;
                    }
                    dp[a+1][Next][tmpc]+=dp[a][b][c];
                }
            }
        }
    }
    ll ans=0;
    int right=0;
    for(a=1;a<=n;a++)
    if(!del[a])
    right+=(1<<(a-1));
    for(a=0;a<=cnt;a++)
    ans+=dp[Len][a][right];
    cout<<ans<<endl;
    if(ans<=42)
    {
    	int tot=n;
        for(a=1;a<=n;a++)
        if(del[a])
        tot--;
     	dfs(0,tot);
        for(a=1;a<=co;a++)
        ranky[a]=a;
        sort(ranky+1,ranky+1+co,cmp);
        for(a=1;a<=co;a++)
        puts(answer[ranky[a]]);
    }
    return 0;
}
```
哦，对了，学弟的博客，推荐一下 [http://www.cnblogs.com/dedicatus545/]

---

## 作者：jijidawang (赞：5)

显然 AC 自动机，吧

和 [文本生成器](https://www.luogu.com.cn/problem/P4052) 那题类似，考虑状压 DP，令 $dp_{i,j,k}$ 表示到第 $i$ 位，自动机上是 $j$，包含集合 $k$ 的模式串个数 .

于是转移就在 AC 自动机上走一步即可（刷表）.

然后这个输出方案就很恶心，注意到如果输出方案则答案不超过 $42$，于是暴搜即可 .

DP 转移咋写的暴搜就咋写，本质是相同的 .

**数组别开小 数组别开小 数组别开小 数组别开小 数组别开小**


代码：
```cpp
using namespace std;
typedef long long ll;
const int L = 27, N = 111, T = 1<<11, alphabet = 26;
inline int trans(const char c){return c - 'a';}
int n, m;
ll dp[L][N][T];
struct AC
{
	int tr[N][alphabet], mark[N], fail[N], root, cc;
	inline void insert(int id, string s)
	{
		int u = root, l = s.length();
		for (int i=0; i<l; i++)
		{
			int _ = trans(s[i]);
			if (!tr[u][_]) tr[u][_] = ++cc;
			u = tr[u][_];
		} mark[u] |= (1 << id);
	}
	inline void build()
	{
		queue<int> q; fail[root] = root;
		for (int i=0; i<alphabet; i++)
		{
			if (tr[root][i]){q.push(tr[root][i]); fail[tr[root][i]] = root;}
			else tr[root][i] = root;
		}
		while (!q.empty())
		{
			int u = q.front(); q.pop(); mark[u] |= mark[fail[u]];
			for (int i=0; i<alphabet; i++)
			{
				if (tr[u][i]){fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); mark[tr[u][i]] |= mark[fail[tr[u][i]]];}
				else tr[u][i] = tr[fail[u]][i];
			}
		}
	}
	inline ll DP()
	{
		dp[0][0][0] = 1;
		for (int i=0; i<n; i++)
			for (int j=0; j<=cc; j++)
				for (int s=0; s<(1<<m); s++)
				{
					if (!dp[i][j][s]) continue;
					for (int k=0; k<alphabet; k++) // trans
					{
						int v = tr[j][k];
						dp[i+1][v][s | mark[v]] += dp[i][j][s];
					}
				}
	    ll ans = 0;
	    for (int i=0; i<=cc; i++) ans += dp[n][i][(1<<m)-1];
	    return ans;
	}
	AC(){root = cc = 0;}
}ac;
bool vis[L][N][T], chk[L][N][T];
int mov[L];
bool dfs(int i, int j, int s)
{
	if (i == n)
	{
		vis[i][j][s] = true;
		return chk[i][j][s] = (s == (1<<m)-1);
	}
	if (vis[i][j][s]) return chk[i][j][s];
	vis[i][j][s] = true;
	bool ans = false;
	for (int k=0; k<alphabet; k++)
		ans |= dfs(i+1, ac.tr[j][k], s | ac.mark[ac.tr[j][k]]);
	return chk[i][j][s] = ans;
}
void output(int i, int j, int s)
{
	if (!chk[i][j][s]) return ;
	if (i == n)
	{
		for (int p=1; p<=n; p++) putchar(mov[p] + 'a');
		puts(""); return ;
	}
	for (int k=0; k<alphabet; k++)
	{
		mov[i+1] = k;
		output(i+1, ac.tr[j][k], s | ac.mark[ac.tr[j][k]]);
	}
}
int main()
{
	string tmp; scanf("%d%d", &n, &m);
	for (int i=1; i<=m; i++){cin >> tmp; ac.insert(i-1, tmp);}
	ac.build();
	ll ans = ac.DP();
	printf("%lld\n", ans);
	if (ans > 42) return 0;
	dfs(0, 0, 0); output(0, 0, 0);
	return 0;
}
```

---

## 作者：Hoks (赞：2)

## 前言
这题还算比较简单的 ACAM+dp 吧，只是输出方案有点折磨了。

广告：[串串博客](https://www.luogu.com.cn/article/dv6dig1o)。
## 思路分析
首先因为是多模匹配，考虑先建出 ACAM，求出 fail 指针。

接着考虑如何处理题目中的计数问题，考虑 dp。

貌似 dp 的空间会炸飞？

发现 $n\le10$，考虑状压。

设计 $dp_{i,j,k}$ 表示已经填了 $i$ 位，ACAM 上跑到了状态 $j$，已用字符串状态为 $k$ 的方案数。

其中 $k$ 的值域即为 $[0,2^n-1]$。

那么再完善下 ACAM 部分，插入一个字符串后在他的结尾打标记表示这个状态包含这个编号的字符串。

那么在求 fail 指针的时候传下 fail 的标记和当前节点的标记或下就行了。

接着考虑下这个 dp 怎么转移，假设枚举到的字符为 $c$，或上当前状态标记后状态为 $k'$。
$$dp_{i,\delta(j,c),k'}=dp_{i,j,k}$$
实际转移的时候累加一下就行了。

因为最后可能停在任何一个位置上，所以要遍历一遍 ACAM 的所有状态累加下答案。

这块都还非常简单，可以先去码一下，交的话是能有 $50$ 分。

接着考虑如何输出方案，考虑 dfs。

在 dfs 是用类似前面 dp 转移时的状态进行跑，并给每个这样的状态打标记代表是否访问与是否可行。

最后再跑一遍输出答案即可。

空间如果不是很紧的话建议多开点防止炸光。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=110,INF=0x3f3f3f3f3f3f3f3f,mod=998244353;
int l,n,m,mx,ans,f[N][N][1024],a[N];char s[N];
bool mp[N][N][1024],ff[N][N][1024];
struct ACAM
{
	struct node{int nxt,ed,mp[26];}t[N*N];int tot=0;
	inline void insert(char s[],int n,int id)
	{
		int u=0;
		for(int i=1;i<=n;i++){if(!t[u].mp[s[i]-'a']) t[u].mp[s[i]-'a']=++tot;u=t[u].mp[s[i]-'a'];}
		t[u].ed|=(1<<id);
	}
	inline void build()
	{
		queue<int>q;
		for(int i=0;i<26;i++) if(t[0].mp[i]) t[t[0].mp[i]].nxt=0,q.push(t[0].mp[i]);
		while(!q.empty())
		{
			int u=q.front();q.pop();t[u].ed|=t[t[u].nxt].ed;
			for(int i=0;i<26;i++)
				if(t[u].mp[i]) t[t[u].mp[i]].nxt=t[t[u].nxt].mp[i],q.push(t[u].mp[i]);
				else t[u].mp[i]=t[t[u].nxt].mp[i];
		}
	}
}ac;
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)&&fc!=-1){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)&&fc!=-1) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        if(fc==-1) exit(0);return x*t;
    }
    inline void print(int x)
    {
        if(x<0) putchar('-'),x=-x;
        if(x>9) print(x/10);
        putchar(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
bool dfs(int x,int y,int z)
{
	if(x==l) return mp[x][y][z]=1,ff[x][y][z]=z==mx;
	bool p=0;if(mp[x][y][z]) return ff[x][y][z];mp[x][y][z]=1;
	for(int i=0;i<26;i++) p|=dfs(x+1,ac.t[y].mp[i],z|ac.t[ac.t[y].mp[i]].ed);
	return ff[x][y][z]=p;
}
void make(int x,int y,int z)
{
	if(!ff[x][y][z]) return ;
	if(x==l)
	{
		for(int i=1;i<=l;i++) putchar(a[i]+'a') ;
		return puts(""),void();
	}
	for(int i=0;i<26;i++) a[x+1]=i,make(x+1,ac.t[y].mp[i],z|ac.t[ac.t[y].mp[i]].ed) ;
}
signed main()
{
	l=read(),n=read();f[0][0][0]=1;mx=(1<<n)-1;
	for(int i=1;i<=n;i++) m=0,rd(s,m),ac.insert(s,m,i-1);ac.build();
	for(int i=0;i<l;i++)
		for(int j=0;j<=ac.tot;j++)
			for(int k=0;k<=mx;k++)
				if(f[i][j][k])
					for(int c=0;c<26;c++)
						f[i+1][ac.t[j].mp[c]][k|ac.t[ac.t[j].mp[c]].ed]+=f[i][j][k];
	for(int i=0;i<=ac.tot;i++) ans+=f[l][i][mx];
	if(ans>42) print(ans);
	else print(ans),puts(""),dfs(0,0,0),make(0,0,0);
	return 0;
}
```

---

## 作者：CMY2013 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4045)

看到题目要求求出方案数，所以要么用 dp 要么用组合数学，这里本蒟蒻用的是 dp 求解。

首先我们来考虑这道题的算法。结合字符串和题目要求，我们发现这道题跟 AC 自动机有关~~我才不会告诉你我是从标签里看到的~~。 

其次来推导 dp 方程。观察数据范围得出，这道题可以使用状压来解决，那么这道题的方程就显而易见了。用 $ dp_{i,j,k} $ 来表示构造出 $i$ 位后，当前在 AC 自动机的第 $j$ 个节点，子串集为 $k$ 的方案数，则转移方程为 $ dp_{i,j,k}→dp_{i+1,tr_{j,l},k|state_{tr_{j,l}}} $ 。那么最终答案为 $ \sum\limits_{i=0}^{temp} dp_{len,i,2^n-1} $ 。 

最后来考虑怎样输出答案。我们可以用一个 bool 数组 $ f_{i,j,k} $ 来表示构造出 $i$ 位后，当前在 AC 自动机的第 $j$ 个节点，子串集为 $k$ 时是否可以继续构造下去使得最终可以构造出一个满足题目条件的字符串。而这个 bool 数组可以用 dfs 来解决。最终我们在结合着 $f$ 数组输出就可以了。

#### 提醒

1. 一定要开 long long 。 

2. dfs 时一定要加记忆化。


### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,tr[110][30],cnt[110],fail[110],tot=0;
long long dp[30][110][(1<<10)];
bool f[30][110][(1<<10)],vis[30][110][(1<<10)];
void addtrie(string s,int x) //创建trie树
{
	int rt=0;
	for(int i=0;i<s.size();i++)
	{
		if(!tr[rt][s[i]-'a']) tr[rt][s[i]-'a']=++tot;
		rt=tr[rt][s[i]-'a'];
	}
	cnt[rt]|=(1<<(x-1));
}

void qfail() //通过BFS算出失配指针
{
	queue<int> q;
	for(int i=0;i<26;i++) 
	{
		if(tr[0][i])
		{
			fail[tr[0][i]]=0;
			q.push(tr[0][i]);
		}
	 } 
	while(!q.empty())
	{
		int nw=q.front();
		q.pop();
		for(int i=0;i<26;i++)
		{
			if(tr[nw][i])
			{
				fail[tr[nw][i]]=tr[fail[nw]][i];
				cnt[tr[nw][i]]|=cnt[tr[fail[nw]][i]];
				q.push(tr[nw][i]);
			}
			else tr[nw][i]=tr[fail[nw]][i];
		}
	}
}

bool dfs1(int x,int y,int z) //求取f数组
{
	if(vis[x][y][z]) return f[x][y][z];
	vis[x][y][z]=true;
	if(x==l)
	{
		if(z==(1<<n)-1) f[x][y][z]=true;
		return f[x][y][z];
	}
	for(int i=0;i<26;i++)
	{
		f[x][y][z]|=dfs1(x+1,tr[y][i],z|cnt[tr[y][i]]);
	}
	return f[x][y][z];
}

char c[30];

void dfs2(int x,int y,int z) //输出最终答案
{
	if(x==l)
	{
		for(int i=1;i<=l;i++) cout<<(char)(c[i]+'a');
		cout<<endl;
		return;
	}
	for(int i=0;i<26;i++)
	{
		if(f[x+1][tr[y][i]][z|cnt[tr[y][i]]])
		{
			c[x+1]=i;
			dfs2(x+1,tr[y][i],z|cnt[tr[y][i]]);
		}
	}
}

int main()
{
	string s;
	cin>>l>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		addtrie(s,i);
	}
	qfail(); //构建AC自动机
	dp[0][0][0]=1;
	for(int i=0;i<l;i++)
	{
		for(int j=0;j<=tot;j++)
		{
			for(int k=0;k<(1<<n);k++)
			{
				for(int o=0;o<26;o++)
				{
					dp[i+1][tr[j][o]][k|(cnt[tr[j][o]])]+=dp[i][j][k];  //dp求解每种状态能以多少种方案完成
				}
			}
		}
	}
	long long ans=0;
	for(int i=0;i<=tot;i++) ans+=dp[l][i][(1<<n)-1]; //统计方案数
	cout<<ans<<endl;
	if(ans<=42)
	{
		dfs1(0,0,0);
		dfs2(0,0,0);
	}
	return 0;
}
```

---

## 作者：zhangxy__hp (赞：1)

设 $dp_{i,j,S}$ 表示填了 $i$ 位，在 AC 自动机上的 $j$ 号节点，当前覆盖的字符串集位 $S$ 的方案数。于是有转移：

$$
\large{dp_{i,j,S}\to dp_{i+1,tr_{j,k},S\operatorname{or}sta_{tr_{j,k}}}}
$$

其中 $tr_{j,k}$ 表示 AC 自动机上 $j$ 点加上字符 $k$ 的节点，$sta_j$ 表示以 $j$ 点为结尾的字符串构成的集合，$\operatorname{or}$ 表示按位或。

输出方案，先记忆化搜索确定每个状态 $(i,j,S)$ 能否转移到合法状态，再一遍 dfs 输出即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline

using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=(1<<10)+5;
int n,m,tr[105][30],tot;
int fail[105],sta[105];
ll dp[30][105][maxn];
bool vis[30][105][maxn];
bool f[30][105][maxn];
char ans[maxn];
string s;
queue<int> q;
il bool dfs1(int i,int j,int S){
	if(vis[i][j][S]){
		return f[i][j][S];
	}
	vis[i][j][S]=1;
	if(i==m){
		return f[i][j][S]=S==(1<<n)-1;
	}
	bool &res=f[i][j][S];
	for(int k=0;k<=25;k++){
		res|=dfs1(i+1,tr[j][k],S|sta[tr[j][k]]);
	}
	return res;
}
il void dfs2(int i,int j,int S){
	if(i==m){
		for(int k=1;k<=m;k++){
			cout<<ans[k];
		}
		cout<<"\n";
		return ;
	}
	for(int k=0;k<=25;k++){
		if(f[i+1][tr[j][k]][S|sta[tr[j][k]]]){
			ans[i+1]=k+'a';
			dfs2(i+1,tr[j][k],S|sta[tr[j][k]]);
		}
	}
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>m>>n;
	for(int i=1,p;i<=n;i++){
		cin>>s;
		p=0;
		for(int j=0,d;j<s.size();j++){
			d=s[j]-'a';
			if(!tr[p][d]){
				tr[p][d]=++tot;
			}
			p=tr[p][d];
		}
		sta[p]|=1<<(i-1);
	}
	for(int i=0;i<=25;i++){
		if(tr[0][i]){
			q.push(tr[0][i]);
		}
	}
	while(q.size()){
		int u=q.front();
		q.pop();
		for(int i=0;i<=25;i++){
			if(tr[u][i]){
				fail[tr[u][i]]=tr[fail[u]][i];
				sta[tr[u][i]]|=sta[fail[tr[u][i]]];
				q.push(tr[u][i]);
			}
			else{
				tr[u][i]=tr[fail[u]][i];
			}
		}
	}
	dp[0][0][0]=1;
	for(int i=0;i<=m;i++){
		for(int j=0;j<=tot;j++){
			for(int S=0;S<1<<n;S++){
				if(!dp[i][j][S]){
					continue;
				}
				for(int k=0;k<=25;k++){
					dp[i+1][tr[j][k]][S|sta[tr[j][k]]]+=dp[i][j][S];
				}
			}
		}
	}
	ll ans=0;
	for(int i=0;i<=tot;i++){
		ans+=dp[m][i][(1<<n)-1];
	}
	cout<<ans<<"\n";
	if(ans>42){
		return 0;
	}
	dfs1(0,0,0);
	dfs2(0,0,0);
	return 0;
}
}
int main(){return asbt::main();}
```

---


# [BJWC2011] 禁忌

## 题目描述

Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……

如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。

这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。

为了说明什么是禁忌魔法及其伤害，引入以下概念：

1. 字母集$A$上的每个非空字符串对应了一个魔法。其中$A$是包含了前alphabet个小写字母的集合。
2. 有一个集合$T$，包含了$N$个字母集$A$上的字符串。$T$中的每一串称为一个禁忌串（Taboo string）
3. 一个魔法，或等价地，其对应的串$s$因为包含禁忌而对使用者造成的伤害按以下方式确定：把$s$分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。

由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集$A$上所有长度为$len$的串。

但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。

你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。

## 说明/提示

【样例1解释】
一共有$2^4 = 16$种不同的魔法。

需要注意的是“aabb”的禁忌伤害是1而不是2。

### 数据范围

有不少于40%的数据中：$N = 1$。  
100%的数据中$N ≤ 5$，$len ≤10^9$，$1 ≤ alphabet ≤ 26$。  
数据保证每个串$T_i$的长度不超过$15$，并且不是空串。  
数据保证每个$T_i$均仅含有前$alphabet$个小写字母。  
数据保证集合$T$中没有相同的元素，即对任意不同的$i$和$j$，有$T_i \neq T_j$。

## 样例 #1

### 输入

```
2 4 2
aa
abb```

### 输出

```
0.75
```

# 题解

## 作者：lzx2005 (赞：10)



**【算法分析】**

算法一：（对于$40\%$的数据）：

kmp上的dp+矩阵乘法优化，可通过子任务三，得40pts。

做法类似，GT考试

>   <https://www.luogu.com.cn/problem/P3193>

>   <http://ybt.ssoier.cn:8088/problem_show.php?pid=1646>

此处不详细讲了。

算法二（对于 $30\%$ 的数据）：

   本题求的是禁忌伤害的期望值。实际上，期望也就是所有可能情况的禁忌伤害的的加权平均数。不难想到，可以枚举所有可能出现的字符串，所有串的禁忌伤害和除以串的个数即为答案。对于已知的一个串，计算它的禁忌伤害，显然可以贪心：我们需要把它分成若干段，每一段包含一个禁忌串，答案即为段数。对此，我们对该串求伤害的最大值，显然要把它划分成尽量多的段。那么我们可以对禁忌串建一个AC自动机，让已知串从根节点出发进行匹配，如果遇到一个终止节点（该节点表示的字符串或其后缀为某个完整的禁忌串），则这个串的禁忌伤害加1，回到根节点继续匹配。

复杂度$O(\text{alphabet}^{\text{len}} \times len + \sum_{1}^{N}{|T_{i}|}$）可以通过子任务一，得$30pts$。

算法三（对于 $70\%$ 的数据）：

   在算法二贪心计算答案的启发下，我们发现可以使用AC自动机处理本题，考虑将枚举每一个串的搜索改为期望dp。不难发现，本题可以顺推。设$\text{dp}_ {i,j}$表示长度为$i$，匹配到AC自动机上的第$j$个节点的禁忌伤害概率值。

$\forall i,j,k$（$1 \leq i\leq len,1 \leq j \leq tot,0 \leq k <alphabet$）（$tot$为AC自动机上点数）

当$\text{ch}_ {j,k}$不是终止节点时，显然有$\text{dp}_{i,\text{ch}_{j,k}} + =\text{dp}_{i - 1,j} \times \frac{1}{\text{alphabet}}$的转移方程。

否则有$\text{dp}_{i,1} + = (\text{dp}_{i - 1,j} + 1) \times\frac{1}{\text{alphabet}}$的转移方程。

初始状态全部为0，答案为$\sum_{i = 1}^{\text{len}}\sum_{j = 1}^{\text{tot}}
\text{dp}_{\text{i},j}\times\text{bo}_j$。

复杂度$O(len \times tot + \sum_{1}^{N}{|T_{i}|})$可通过子任务一、二和部分子任务三得70~90pts。

算法四：

算法三中，tot在100以下，几乎可以忽略不计，超时的原因显然是$10^{9}$级别的$len$。

   我们可以发现：转移方程中只在相邻的长度上转移，显然是一个tot阶递推式，可以使用矩阵乘法优化！大体思想同算法一。但由于常数项的原因，我们的转移矩阵应该是$(tot   + 1) \times (tot + 1)$的。$a_{i,tot +   1}$表示当前状态到点i已经计入答案的期望值。初始矩阵，只需设为单位矩阵即可，转移矩阵构造方法如下：枚举AC自动机上每一个节点，

  设当前到了第i个节点，则枚举i的每一条出边，对于点i的第k条出边

（$0 \leq k < alphabet$），若$\text{ch}_{i,k}$是终止节点，则$a_{i,tot +1} + = \frac{1}{\text{alphabet}},a_{i,tot + 1} + =\frac{1}{\text{alphabet}}$.

   否则$a_{i,\text{ch}_{i,k}} + = \frac{1}{\text{alphabet}}$，特别地$a_{tot+ 1,tot + 1} = 1$保存过程中的答案，最终取$a^{\text{len}}$矩阵。

   答案为$a_{1,tot + 1}$（转移len次后根节点对答案的贡献）。

   使用矩阵快速幂优化，复杂度$O(\text{tot}^{3} \times\operatorname{log_2}\text{len} + tot \times \text{alphabet} +\sum_{1}^{N}{|T_{i}\ |})$,得100pts。

注意事项：

代码实现中建议全程使用long double，其他细节见代码注释。

【参考程序】
```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
#define al alphabet
#define ld long double//本题精度要求较高，建议使用long double型变量
using namespace std;
inline int read()
{
	int lzx=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){lzx=lzx*10+c-'0';c=getchar();}
	return lzx*f;
}
int ch[80][26],net[80],bo[80];
int n,len,al,tot=1;
char s[101];
inline void add()//建Trie树
{
	int len=strlen(s+1),u=1;
	for(re int i=1;i<=len;i++)
	{
		int c=s[i]-'a';
		if(!ch[u][c])ch[u][c]=++tot;
		u=ch[u][c];
	}
	bo[u]=1;//点u表示的串是禁忌串
	return;
}
inline void bfs()//求next数组，建AC自动机
{
	for(re int i=0;i<26;i++)
		ch[0][i]=1;
	net[1]=0;
	queue<int> q;
	q.push(1);
	while(!q.empty())
	{
		int u=q.front();
		bo[u]|=bo[net[u]];//它的后缀为禁忌串，它也是禁忌串
		for(re int i=0;i<26;i++)
		{
			int v=net[u];
			while(!ch[v][i])v=net[v];
			if(ch[u][i])
			{
				q.push(ch[u][i]);
				net[ch[u][i]]=ch[v][i];
			}
			else ch[u][i]=ch[v][i];
		}
		q.pop();
	}
	return;
}
struct point 
{
	ld mapp[110][110];
	int a,b;
};//用结构体保存矩阵信息
inline void pre(point &a)
{
	for(re int i=1;i<=a.a;i++)
		for(re int j=1;j<=a.b;j++)
			a.mapp[i][j]=0.0;
	for(re int i=1;i<=tot;i++)
	{
		for(re int j=0;j<al;j++)
		{
			if(bo[ch[i][j]])
			{
				a.mapp[i][1]+=(ld)1.0/(ld)al;
				a.mapp[i][tot+1]+=(ld)1.0/(ld)al;
			}
			else a.mapp[i][ch[i][j]]+=(ld)1.0/(ld)al;
		}
	}
	return;
}//构造转移矩阵
inline point times(point a,point b)
{
	point c;c.a=c.b=a.a;
	for(re int i=1;i<=c.a;i++)
		for(re int j=1;j<=c.b;j++)
			c.mapp[i][j]=(ld)0.0;
	for(re int i=1;i<=c.a;i++)
		for(re int j=1;j<=c.b;j++)
			for(re int k=1;k<=a.b;k++)
				c.mapp[i][j]+=a.mapp[i][k]*b.mapp[k][j];
	return c;
}//两个矩阵相乘
inline point ksm(point a,int k)
{
	point res;res.a=res.b=a.a;
	for(re int i=1;i<=res.a;i++)
		for(re int j=1;j<=res.b;j++)
			res.mapp[i][j]=(ld)(i==j);
	while(k)
	{
		if(k&1)res=times(res,a);
		a=times(a,a);
		k>>=1;
	}
	return res;
}//矩阵快速幂
point a;
int main()
{
	n=read(),len=read(),al=read();
	for(re int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		add();
	}
	bfs();
	a.a=a.b=tot+1;//矩阵规格为(tot+1)×(tot+1)
	pre(a);
	a.mapp[a.a][a.b]=(ld)1.0;
	a=ksm(a,len);//求矩阵a^len
	printf("%Lf\n",a.mapp[1][tot+1]);//long double型用“%Lf”输出
	return 0;
}

```

---

## 作者：Alex_Wei (赞：5)

> [题目传送门](https://www.luogu.com.cn/problem/P4569)。

> 题意简述：给出大小为 $n$ 的字典 $s$。设函数 $g(t)$ 表示 $t$ 最多能被分割成的单词个数。等概率随机生成长度为 $len$ 的字符串 $T$，求 $E(g(t))$。

> [在我的 cnblog 内查看](https://www.cnblogs.com/alex-wei/p/P4569.html)。

hot tea. 比较像 [P3193 [HNOI2008]GT考试](https://www.luogu.com.cn/problem/P3193)。

---

首先对 $s_i$ 建出 ACAM，然后在上面 DP。设 $f_{i,j}$ 表示关于所有 $T$（$|T|=i$ 且 $T$ 在 ACAM 上能跑到状态 $j$）的一个东西。那么究竟是表示什么呢？

记 $P=\dfrac{f_{i,j}}{a}$；$p$ 为 $j$ 的所有子节点，即 $p\in son_j$。

**错误思路**：如果 $f_{i,j}$ 单纯表示字符串 $T$ 的 “概率”（即 $\dfrac{num(T)}{a^i}$），那么转移与统计答案就是：如果 $p$ 是终止节点，将 $ans$ 加上 $P$；同时将所有 $f_{i+1,p}$ 加上 $P$。不错，如果 $g(T)$ 表示的是所有单词 $s_i$ 在 $T$ 中出现次数之和，那么这样是没错的，可惜不是，因为会有重复计算，即若字典 $s=\{\texttt{ab,bc}\}$，那么 $T=\{\texttt{abc}\}$ 会算入两次贡献（样例中也有提到这种情况）。

**正确思路**：注意到这个 "最多" 有点麻烦，不过还是有处理的办法：如果 $p$ 是一个终止节点，那么在下传概率的时候，将 $f_{i+1,0}$（而不是 $f_{i+1,p}$）加上 $P$。**如果成功匹配一个单词，就必须从头开始匹配。**

注意到 $\sum |s_i|$ 很小，只有 $75$。这也意味着 $j$ 的范围只有 $75$。因此，用矩阵快速幂加速 DP 即可，别忘了在矩阵中留个位置记录 $ans$。

总时间复杂度 $\mathcal{O}((\sum |s_i|)^3\log len)$。

```cpp
/*
	Powered by C++11.
	Author : Alex_Wei.
*/

#include <bits/stdc++.h>
using namespace std;

//#pragma GCC optimize(3)
//#define int long long

using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
using db = double;
using ld = long double;

const int N=77;
const int S=26;

int sz,al,son[N][S],fa[N],ed[N];
void ins(string s){
	int p=0;
	for(char it:s){
		if(!son[p][it-'a'])son[p][it-'a']=++sz;
		p=son[p][it-'a'];
	} ed[p]=1;
}
void build(){
	queue <int> q;
	for(int i=0;i<al;i++)if(son[0][i])q.push(son[0][i]);
	while(!q.empty()){
		int t=q.front(); q.pop();
		for(int i=0;i<al;i++)
			if(son[t][i])q.push(son[t][i]),fa[son[t][i]]=son[fa[t]][i];
			else son[t][i]=son[fa[t]][i];
		ed[t]|=ed[fa[t]];
	}
}
struct mat{
	ld a[N][N];
	friend mat operator * (mat x,mat y){
		mat z; mem(z.a,0);
		for(int i=0;i<=sz;i++)
			for(int j=0;j<=sz;j++)
				for(int k=0;k<=sz;k++)
					z.a[i][j]+=x.a[i][k]*y.a[k][j];
		return z;
	}
}base,ans;

int n,len;
int main(){
	cin>>n>>len>>al;
	for(int i=0;i<n;i++){
		string s;
		cin>>s,ins(s);
	} build();
	for(int i=0;i<=sz;i++)
		for(int j=0;j<al;j++){
			int p=son[i][j];
			if(ed[p])base.a[i][0]+=1.0/al,base.a[i][sz+1]+=1.0/al;
			else base.a[i][p]+=1.0/al;
		}
	sz++,ans.a[0][0]=base.a[sz][sz]=1;
	while(len){
		if(len&1)ans=ans*base;
		base=base*base,len>>=1;
	} printf("%.10Lf\n",ans.a[0][sz]);
	return 0;
}
```

---

## 作者：lhm_ (赞：5)

考虑用$AC$自动机来解决本题这样的多字符串匹配问题。

要最大化魔法分割后得到的禁忌串数目，最优情况肯定为在一个串中每个禁忌串的右端点进行分割。对应到$AC$自动机上，就是匹配到一个禁忌串后，就直接转移到根节点。

若用朴素的$DP$解决，发现题目中的$len$过大，于是用矩阵快速幂优化。

先构造初始矩阵，$a_{i,j}$的值表示当串长为$1$时从状态$i$转移到状态$j$的概率，对这样的一个矩阵进行$len$次幂后，所得的含义即为串长为$len$时所对应的概率。

同时新增一个状态$t$来统计期望，若转移过程中，转移到了一个合法的状态，即匹配上了一个禁忌串，那么就可以把当前概率统计到状态$t$上了，最后直接查询根到状态$t$即可。

构造矩阵时，分情况讨论。设$P=\frac{1}{alphabet}$，若一个状态$x$可转移到状态$y$，若状态$y$不是禁忌串的终止状态，则$a_{x,y}$加上$P$，否则让$a_{x,root}$加上$P$和$a_{x,t}$加上$P$。

具体实现细节看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 110
using namespace std;
typedef long double ld;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,l,alph,tot,root;
ld P;
int trie[maxn][30],fail[maxn];
bool end[maxn];
char s[maxn];
struct matrix
{
    ld a[maxn][maxn];
}m,e;
matrix operator *(const matrix &x,const matrix &y)
{
    matrix z;
    memset(z.a,0,sizeof(z.a));
    for(int k=root;k<=tot+1;++k)
        for(int i=root;i<=tot+1;++i)
            for(int j=root;j<=tot+1;++j)
                z.a[i][j]+=x.a[i][k]*y.a[k][j];
    return z;
}
matrix qp(matrix x,int y)
{
    matrix t=e;
    while(y)
    {
        if(y&1) t=t*x; 
        x=x*x;
        y>>=1;
    }
    return t;
}
void insert()
{
    int len=strlen(s+1),p=root;
    for(int i=1;i<=len;++i)
    {
        int ch=s[i]-'a';
        if(!trie[p][ch]) trie[p][ch]=++tot;
        p=trie[p][ch];
    }
    end[p]=true;
}
void build()
{
    queue<int> q;
    for(int i=0;i<alph;++i)
        if(trie[root][i])
            q.push(trie[root][i]);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=0;i<alph;++i)
        {
            int y=trie[x][i];
            if(y)
            {
                fail[y]=trie[fail[x]][i];
                end[y]|=end[fail[y]],q.push(y);
            }
            else trie[x][i]=trie[fail[x]][i];
        }
    }
    e.a[tot+1][tot+1]=m.a[tot+1][tot+1]=1;
    for(int x=root;x<=tot;++x)
    {
        e.a[x][x]=1;
        for(int ch=0;ch<alph;++ch)
        {
            int y=trie[x][ch];
            if(end[y]) m.a[x][tot+1]+=P,m.a[x][root]+=P;
            else m.a[x][y]+=P;
        }
    }
}
int main()
{
    read(n),read(l),read(alph),P=(ld)1.0/(ld)alph;
    for(int i=1;i<=n;++i)
        scanf("%s",s+1),insert();
    build(),m=qp(m,l);
    printf("%Lf",m.a[root][tot+1]);
    return 0;
}
```

---

## 作者：Gold_Dino (赞：5)

首先有一个贪心策略，如果一个串有一个后缀为禁忌，就一定会划分

考虑建出自动机后，在自动机上动态规划

$f_{u,i}$ 表示自动机上 $u$ 节点出发，再走 $i$ 步的期望

令 $v$ 为 $u$ 在自动机上走一个字符跳到的点

设 $\mathrm{flag}_u$ 为 $u$ 是否为禁忌

$$
f_{u,i}=\sum_v\frac{1}{\alpha}\begin{cases}f_{1,i-1}+1&\mathrm{flag}_v=1\\f_{v,i-1}&\mathrm{flag}_v=0\end{cases}
$$

由于总字符数是 $75$ 的，故矩阵快速幂

将式子改为枚举点，并累计系数，由于多加了 $1$，需要多加一项


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ris(i,a,b) for(int i=a;i<=b;++i)
const int N=111;
int n,l,a;string s;
int tot=1,trie[N][26],fail[N],flag[N];
int que[N],head,tail;
double f[N],mat[N][N],tmp[N][N];
int main(){
	int p;
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>l>>a;
	ris(i,1,n){
		cin>>s;
		p=1;
		for(char c:s){
			int &v=trie[p][c-'a'];
			if(!v) v=++tot;
			p=v;
		}
		flag[p]=1;
	}
	fail[1]=1;
	que[(tail=head=1)++]=1;
	while(head<tail){
		int u=que[head++];
		flag[u]|=flag[fail[u]];
		ris(i,0,a-1)
			if(int v=trie[u][i]){
				que[tail++]=v;
				p=fail[u];
				while(p!=1&&!trie[p][i]) p=fail[p];
				if(trie[p][i]&&trie[p][i]!=v) fail[v]=trie[p][i];
				else fail[v]=1;
			}
	}
	ris(u,1,tot)
		if(flag[u])
			f[u]=1;
	f[tot+1]=1;
	mat[tot+1][tot+1]=1;
	ris(u,1,tot)
		ris(i,0,a-1){
			int v;
			p=u;
			while(p!=1&&!trie[p][i]) p=fail[p];
			if(trie[p][i]) v=trie[p][i];
			else v=1;
			if(flag[v]) mat[1][u]+=1.0/a,mat[tot+1][u]+=1.0/a;
			else mat[v][u]+=1.0/a;
		}
	while(l){
		if(l&1){
			memcpy(tmp[1],f,sizeof tmp[1]);
			memset(f,0,sizeof f);
			ris(i,1,tot+1)
				ris(j,1,tot+1)
					f[i]+=tmp[1][j]*mat[j][i];
		}
		memcpy(tmp,mat,sizeof tmp);
		memset(mat,0,sizeof mat);
		ris(i,1,tot+1)
			ris(j,1,tot+1)
				ris(k,1,tot+1)
					mat[i][j]+=tmp[i][k]*tmp[k][j];
		l>>=1;
	}
	printf("%lf",f[1]);
	return 0;
}
```


---

## 作者：ToBiChi (赞：5)

[AC自动机/DP/矩阵乘法]

[另一番阅读体验](https://yirannn.com/string/aho_corasick_automaton/bzoj_2553/)
### 题解 ：

对输入的子串建立Trie图，这样我们就可以直接在图上DP了。

- 方程 ：$F[i][j]$表示已经说了$i$个字符，在图上$j$点的概率。

- 转移 ：若$son$不是危险节点，$F[i+1][son]+=F[i][j]\times temp$ 其中$temp$是说$son$这个字符的概率，等于$\frac{1}{alphabet}$

- 若$son$是危险节点，那么走到它相当于匹配了一次禁忌串，可以统计答案再从根重新开始走

由于匹配到每个危险节点的答案贡献都是$1$，那么期望可以通过计算概率和得到。

但是$len$太大了，$O(len)$跑不下来。

因为这是一张图，每次都走一步，我们可以考虑用邻接矩阵做矩阵乘法优化。

**每乘一次边表相当于走了一步。**

对这个理解不是很好的推荐两道题 ：[GT考试](https://www.luogu.org/problemnew/show/P3193) 和 [迷路](https://www.luogu.org/problemnew/show/P4159) 前者同样是字符串和矩乘的结合，后者是边表矩乘。

为了让矩乘方便统计答案，我们需要建立一个虚拟汇点，每次向根转移的同时也转移到它。最后读取答案的时候直接读取它即可。

  注意本题*卡精度*，必须用$long \;double$，尤其是$temp = 1/alphabet$中的1也要强制转$long\;double$

### 代码 ：

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;
#define f3 long double
const int N = 110;
char s[N];
int n, len, alphabet;
struct Mat {
	f3 a[N][N];
	Mat() {memset(a, 0, sizeof a);}
	f3* operator [] (int cur) {return a[cur];}
	void operator *= (Mat &b) {
		Mat c;
		for(int i = 0; i <= n; i ++ )
		for(int j = 0; j <= n; j ++ )
		for(int k = 0; k <= n; k ++ ) 
		c[i][j] += a[i][k]*b[k][j];
		*this = c;
	}
	Mat operator ^ (int y) {
		Mat I;
		for(int i = 0; i <= n; i ++ ) I[i][i] = 1;
		for(;y;y>>=1, *this *= *this) if(y&1) I *= *this;
		return I;
	}
}f;
struct Aho_Corasick_Automaton {
	int cnt, ch[N][26], fail[N];
	bool flg[N], vis[N]; queue<int> q;
	void insert() {
		int p = 0;
		for(int i = 1; s[i]; i ++ ) {
			int &son = ch[p][s[i]-'a'];
			if(!son) son = ++cnt;
			p = son;
		}
		flg[p] = 1;
	}
	void getFail() {
		for(int i = 0; i < alphabet; i ++ ) if(ch[0][i]) q.push(ch[0][i]);
		while(!q.empty()) {
			int u = q.front(); q.pop();
			for(int i = 0; i < alphabet; i ++ ) {
				if(ch[u][i]) fail[ch[u][i]] = ch[fail[u]][i], q.push(ch[u][i]);
				else ch[u][i] = ch[fail[u]][i];
			}
			flg[u] |= flg[fail[u]];
		}
	}
	void getF() {
		f3 tmp = (f3)1.0/alphabet;
		q.push(0); vis[0] = 1;
		while(!q.empty()) {
			int u = q.front(); q.pop();
			for(int i = 0; i < alphabet; i ++ ) {
				if(!vis[ch[u][i]]) vis[ch[u][i]] = 1, q.push(ch[u][i]);
				if( flg[ch[u][i]]) f[u][n] += tmp, f[u][0] += tmp;
				else f[u][ch[u][i]] += tmp;
			}
		}
		f[n][n] = 1;
	}
}Trie;
int main() {
	scanf("%d%d%d", &n, &len, &alphabet);
	for(int i = 1; i <= n; i ++ ) {
		scanf("%s", s+1);
		Trie.insert();
	}
	n = Trie.cnt+1;
	Trie.getFail();
	Trie.getF();
	printf("%.7f\n", (double)(f^len).a[0][n]);
	getchar(), getchar();
}
```

---

## 作者：PigNotFound (赞：2)

AC 自动机 + 概率 dp + 矩阵加速

首先，将所有禁忌串插入 AC 自动机。可以列出 dp 方程。定义 $f_{i,j}$ 表示一个长为 $i$ 的字符串匹配到了 $j$ 点禁忌伤害的期望值。思考转移方程。定义 $ch_{i,j}$ 表示自动机上 $i$ 点向 $j$ 字符的儿子，$end_i$ 表示自动机上以 $i$ 节点结尾的字符串个数，则转移方程应该是 $\frac{f_{i,j}+end_{ch_{j,k}}}{alphabet}\xrightarrow{+} f_{i+1,ch_{j,k}}$

可是，如果到了一个单词的末尾，会跳到 $fail$，而这种情况不合法，并且答案也统计不了。所以对于自动机上字符串结尾的点，转移方程为 $\frac{f_{i,j}}{alphabet}\xrightarrow{+} f_{i+1,ch_{0}}$ 并且  $f_{i,j}\xrightarrow{+}ans$

最后，用矩阵快速幂优化，即可。

还有，可以把矩阵开大一点，最外面存答案，就可以顺带统计答案了。

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int Pig = 1e2 + 10;
typedef long double d;
typedef long long ll;
ll n, l;
d alpha;
struct matrix {
    d da[Pig][Pig];
    ll n, m;
    matrix() = default;
    matrix(ll n, ll m, bool flag = 0) {
        this->n = n;
        this->m = m;
        for (int i = 0; i < n; i++) {
             for (int j = 0; j < m; j++) {
                 da[i][j] = 0;
             }
        }
        if (flag) {
            for (ll i = 0; i < n; i++)
                da[i][i] = 1;
        }
    }
    d *operator[](ll i) {
        return da[i];
    }
    matrix operator*(matrix a) {
        matrix res(n, a.m);
        for (ll i = 0; i < n; i++) {
            for (ll k = 0; k < m; k++) {
                d cur = da[i][k];
                for (ll j = 0; j < a.m; j++) {
                    res[i][j] += cur * a[k][j];
                }
            }
        }
        return res;
    }
};
ostream &operator<<(ostream &out, matrix a) {
    for (ll i = 0; i < a.n; i++) {
        for (ll j = 0; j < a.m; j++) {
            out << setw(5) << a[i][j] << ' ';
        }
        out << '\n';
    }
    return out;
}
matrix operator^(matrix a, ll n) {
    matrix res(a.n, a.n, 1);
    while (n) {
        if (n & 1)
            res = res * a;
        a = a * a;
        n >>= 1;
    }
    return res;
}
struct ac_automaton {
    ll tr[Pig][26], end_[Pig], fail[Pig], cnt = 0, val[Pig];
    ac_automaton() {
        memset(tr, 0, sizeof(tr));
        memset(end_, 0, sizeof(end_));
        memset(val, 0, sizeof(val));
        memset(fail, 0, sizeof(fail));
    }
    void insert(string n) {
        ll p = 0;
        for (auto v : n) {
            if (!tr[p][v - 'a'])
                tr[p][v - 'a'] = ++cnt;
            p = tr[p][v - 'a'];
        }
        end_[p] = 1;
    }
    void build() {
        queue<ll> q;
        for (ll i = 0; i < 26; i++) {
            if (tr[0][i])
                q.emplace(tr[0][i]);
        }
        while (!q.empty()) {
            ll p = q.front();
            q.pop();
            for (ll i = 0; i < 26; i++) {
                if (tr[p][i]) {
                    fail[tr[p][i]] = tr[fail[p]][i];
                    q.push(tr[p][i]);
                } else {
                    tr[p][i] = tr[fail[p]][i];
                }
            }
            end_[p] |= end_[fail[p]];
        }
    }
};
ac_automaton ac;
matrix graph, init(1, 0);
int main() {
    cin >> n >> l >> alpha;
    for (ll i = 0; i < n; i++) {
        string s;
        cin >> s;
        ac.insert(s);
    }
    ac.build();
    init.m = graph.n = graph.m = ac.cnt + 2;
    d cur = d(1.0) / alpha;
    for (ll i = 0; i < ac.cnt; i++) {
        for (ll j = 0; j < alpha; j++) {
            if (ac.end_[ac.tr[i][j]]) {
                graph[i][0] += cur;
                graph[i][ac.cnt + 1] += cur;
            } else {
                graph[i][ac.tr[i][j]] += cur;
            }
        }
    }
    init[0][0] = graph[ac.cnt + 1][ac.cnt + 1] = d(1.0);
    graph = graph ^ l;
    init = init * graph;
    printf("%.10Lf", init[0][ac.cnt + 1]);
    return 0;
}
```

---

## 作者：jijidawang (赞：2)

~~题目背景好评~~

这个 $alphabet$ 看着就不顺眼，改成 $c$ .

首先对模式串建出 AC 自动机 .

然后这个禁忌魔法的伤害只需要在 AC 自动机上贪心就可以了，比较平凡 .

考虑 DP，令 $dp_{i,j}$ 表示到第 $i$ 个字符，在 AC 自动机上到第 $j$ 个字符的概率，这是 AC 自动机上 DP 的常见形式 .

考虑在 AC 自动机上走一步 $j\to k$ 进行转移，于是
$$dp_{i+1,k}=\sum \dfrac1c\cdot dp_{i,j}$$

然而我们的划分不能重复，也就是样例解释里说的那个东西 .

于是如果 $k$ 是某个模式串的末尾（也就是匹配上了），我们就令 $k\gets root$（相当于回到起始点重新匹配）.

当然我们这个 $dp$ 数组是概率，我们要在 DP 过程中统计期望 .

直接大力 DP 显然是过不去的，因为 $len$ 贼大 .

然而这个东西相当于同样的转移跑 $len$ 次，可以直接矩阵快速幂优化掉，这个和 [GT 考试](https://www.cnblogs.com/CDOI-24374/p/16020972.html) 的手法类似 .

然后时间复杂度瞬间变成 $O\big((\sum|s|)^3\log len\big)$，轻松跑过 .

details: 加一维用来统计期望 .

Core Code:
```cpp
Matrix<db> D, ans;
ACAM ac;
int n, len, ab;
db one = 1.0;
int main()
{
	scanf("%d%d%d", &n, &len, &ab); string tmp;
	for (int i=1; i<=n; i++){cin >> tmp; ac.insert(tmp);}
	ac.build();
	int S = ac.size();
	for (int i=0; i<=S; i++)
		for (int j=0; j<ab; j++)
		{
			int k = ac.tr[i][j];
			if (ac.mark[k]){D[S+1][i] += one/ab; D[0][i] += one/ab;}
			else D[k][i] += one/ab;
		}
	D[S+1][S+1] = one; D ^= len;
	ans[0][0] = 1; D *= ans; // !!!!!
	printf("%.10f\n", D[S+1][0]);
	return 0;
}
```

完整代码：[R71833633](https://www.luogu.com.cn/record/71833633) .

这个矩阵快速幂优化 DP 也可以看成 AC 自动机上走 $len$ 步，这个先保留 .



---

## 作者：zhangxy__hp (赞：1)

考虑如果暴力 DP，设 $f_{i,j}$ 为当前的串长为 $i$，在 AC 自动机的 $j$ 节点的概率。转移时枚举在后面加的字符 $k$，如果加上 $k$ 后匹配上了一个禁忌串就直接回到根节点，同时给答案贡献，否则就继续匹配。$len$ 在 $10^9$，时间复杂度会超标，于是矩阵加速。

如果 $j$ 节点可以贡献给 $k$ 节点，那就将转移矩阵第 $j$ 行第 $k$ 列加上一个 $\frac{1}{alphabet}$。多开一行存答案，在需要累计答案时将贡献加给答案。

时间复杂度 $O((\sum|T_i|)^3\log len)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline

using namespace std;
namespace asbt{
namespace cplx{bool begin;}
int n,m,tr[80][30];
int tot,fail[80];
double ab;
bool end[80];
string s;
queue<int> q;
struct juz{
	double mat[80][80];
	juz(){
		for(int i=0;i<=tot;i++){
			for(int j=0;j<=tot;j++){
				mat[i][j]=0;
			}
		}
	}
	il double*operator[](int x){
		return mat[x];
	}
	il juz operator*(juz x)const{
		juz res;
		for(int i=0;i<=tot;i++){
			for(int j=0;j<=tot;j++){
				for(int k=0;k<=tot;k++){
					res[i][j]+=mat[i][k]*x[k][j];
				}
			}
		}
		return res;
	}
}bas;
il juz qpow(juz x,int y){
	juz res;
	for(int i=0;i<=tot;i++){
		res[i][i]=1;
	}
	while(y){
		if(y&1){
			res=res*x;
		}
		y>>=1,x=x*x;
	}
	return res;
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m>>ab;
	for(int i=1,p;i<=n;i++){
		cin>>s;
		p=0;
		for(int j=0,d;j<s.size();j++){
			d=s[j]-'a';
			if(!tr[p][d]){
				tr[p][d]=++tot;
			}
			p=tr[p][d];
		}
		end[p]=1;
	}
	for(int i=0;i<ab;i++){
		if(tr[0][i]){
			q.push(tr[0][i]);
		}
	}
	while(q.size()){
		int u=q.front();
		q.pop();
		for(int i=0;i<ab;i++){
			if(tr[u][i]){
				fail[tr[u][i]]=tr[fail[u]][i];
				end[tr[u][i]]|=end[fail[tr[u][i]]];
				q.push(tr[u][i]);
			}
			else{
				tr[u][i]=tr[fail[u]][i];
			}
		}
	}
//	for(int i=0;i<=tot;i++){
//		cout<<fail[i]<<" ";
//	}
//	puts("");
	tot++;
	for(int i=0;i<tot;i++){
		for(int j=0;j<ab;j++){
			if(end[tr[i][j]]){
				bas[i][0]+=1.0/ab;
				bas[i][tot]+=1.0/ab;
			}
			else{
				bas[i][tr[i][j]]+=1.0/ab;
			}
		}
	}
	bas[tot][tot]=1;
	printf("%.10f",qpow(bas,m)[0][tot]);
	return 0;
}
}
int main(){return asbt::main();}
```

---

## 作者：lsj2009 (赞：1)

### Solution

对于这种字符串匹配的问题很自然地会想到先建一个 AC 自动机出来，考虑将 AC 自动机看成一个图，则我们每次在当前字符串末尾添加一个字符 $ch$，就相当于在这个图上行走，也就是一条边 $u\to trie_{u,ch}$；特别地，对于每个某个单词的结尾在完成匹配后需要回到根节点，也就是 $ed_p\to rt$，然后会对答案产生贡献，我们不妨额外开一个虚点 $t$，然后同样连边 $ed_p\to t$，也就是虚点 $t$ 保存了答案。

那么现在我们相当于建出了一张图，由于每个点恰有 $\alpha$ 条出边，且每个出边选择概率相等，所以每条边有一个权值 $\frac{1}{\alpha}$，则问题就变成了，给定一张图，求恰经过 $len$ 条边的路径上权值之积的和，矩阵快速幂即可。

考虑到该 AC 自动机节点数 $m\le 5\times 15=75$ 个节点，复杂度为 $\Theta(m^3\log{len})$。

### Code

```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define ull unsigned long long
#define ld long double
#define PII pair<int,int>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=1e2+5,M=26;
int trie[N][M],fail[N],cnt,alpha,n,len;
bool ed[N];
struct matrix {
	ld c[N][N];
	matrix() {
		cl(c,0);
	}
	void init() {
		rep(i,0,cnt+1)
			c[i][i]=1;
	}
	matrix operator * (const matrix &tmp) const {
		matrix res;
		rep(i,0,cnt+1) {
			rep(j,0,cnt+1) {
				rep(k,0,cnt+1)
					res.c[i][j]+=c[i][k]*tmp.c[k][j];
			}
		}
		return res;
	}
}; matrix g;
matrix qpow(matrix a,int b) {
	matrix res,base=a; 
	res.init();
	while(b) {
		if(b&1)
			res=res*base;
		base=base*base; b>>=1;
	}
	return res;
}
void ins(char s[]) {
	int len=strlen(s+1),p=0;
	rep(i,1,len) {
		int ch=s[i]-'a';
		if(!trie[p][ch])
			trie[p][ch]=++cnt;
		p=trie[p][ch];
	}
	ed[p]=true;
}
void build() {
	queue<int> q;
	rep(i,0,alpha-1) {
		if(trie[0][i])
			q.push(trie[0][i]);
	}
	while(!q.empty()) {
		int u=q.front(); q.pop();
		rep(i,0,alpha-1) {
			if(trie[u][i]) {
				fail[trie[u][i]]=trie[fail[u]][i];
				q.push(trie[u][i]);
			} else
				trie[u][i]=trie[fail[u]][i];
		}
		ed[u]|=ed[fail[u]];
	}
}
char s[N];
void solve() {
	scanf("%d%d%d",&n,&len,&alpha);
	rep(i,1,n) {
		scanf("%s",s+1);
		ins(s);
	}
	build();
	ld p=1.0/alpha;
	g.c[cnt+1][cnt+1]=1.0;
	rep(u,0,cnt) {
		rep(i,0,alpha-1) {
			int v=trie[u][i];
			if(ed[v])
				g.c[u][0]+=p,g.c[u][cnt+1]+=p;
			else
				g.c[u][v]+=p;
		}
	}
	printf("%.9Lf\n",qpow(g,len).c[0][cnt+1]);
}
signed main() {
    int testcase=1;
    while(testcase--)
        solve();
    return 0;
}
```

---

## 作者：LEWISAK (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4569)

[我的板蓝根](https://www.cnblogs.com/lewisak/p/18777974)

# 前言

这个题的数据范围及其出卖解法，其实很简单。

# 题目大意

定义一个字符串的权值为将其**分割**后子串与 $N$ 个文本串相等个数的最大值，求：在由前 $alphabet$ 个小写字母组成的长度为 $len$ 的任意字符串中随机选择出的字符串的期望权值。

# 题解

看到这个题第一反应是一个常用小技巧：为了减小误差，把期望拆成权值和除以总方案数，然后看一眼数据范围：$len \le 10^9$，直接就死了。

但是这也启示了我们：能通过 $10^9$ 级别的算法，要么复杂度根本不带 $len$ 要么是 $\log$ 级别的，考虑后者发现只有矩阵快速幂看起来比较可行。

然后再看到 $N \le 5$ 和模式串的长度不超过 $15$，那这应该就是矩阵的宽了。

注意到样例说 $\text {aabb}$ 不能拆成 $\text {aa}$ 和 $\text {abb}$，也就是说一个字节不能给多次贡献，于是有一个很有意思的伪做法就是将文本串“堆”起来，然后转移是要么在 $i-len$ 的位置“堆”一个文本串，要么放杂的字符，比如下图是一种权值为4的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/52t21wtj.png)

但如果杂字符联合成了一个文本串就废了，而且拆成 $\text {ab}$ 不如拆成 $\text {a}$ 和 $\text {b}$，如过有这种情况也会废，但这个伪做法启示我们文本串匹配成功后就要从头开始匹配。

于是我们考虑一个文本匹配多个模式看着就像是 AC 自动机，进一步考虑 AC  自动机上 dp。

设 $dp_{i,j}$ 表示从 $i$ 出发走 $j$ 步的期望，然后受伪做法的启发，如果匹配成功了就要从根节点从新开始匹配，也就是有转移：

$$
dp_{i_j}=\frac{1}{alphabet} \left ( \sum_{flag_v=1} \left(dp_{1,j-1}+1\right)+\sum_{flag_v=0} dp_{v,j-1}\right )
$$

其中 $v$ 是 $i$ 在 AC 自动机上的子节点，$flag_i$ 表示到 $i$ 有没有后缀是文本串，然后矩阵快速幂优化即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define LF long double
using namespace std;
namespace FFF{
const int mod=1e4+7;
struct AAA{
	int son[30],flag,fail;
}tr[100100];
struct QQQ{
	LF mapp[110][110];
	int x,y;
}a;
int n,m,cnt=1,ans,alp,len;
char s[100100];
queue<int> q;
void insert(char s[]){
	int u=1,len=strlen(s);
	for(int j=0;j<len;j++){
		int v=s[j]-'a';
		if(!tr[u].son[v]){
			tr[u].son[v]=++cnt;
		}
		u=tr[u].son[v];
	}
	tr[u].flag=1;
}
void init(){
	for(int i=0;i<26;i++){
		tr[0].son[i]=1;
	}
	q.push(1);
	while(!q.empty()){
		int u=q.front(),f=tr[u].fail;
		q.pop();
		for(int i=0;i<26;i++){
			int v=tr[u].son[i];
			if(!v){
				tr[u].son[i]=tr[f].son[i];
				continue;
			}
			tr[v].fail=tr[f].son[i];
			tr[v].flag|=tr[tr[v].fail].flag;
			q.push(v);
		}
	}
}
QQQ cheng(QQQ x,QQQ y){
	QQQ ans;
	for(int i=1;i<=x.x;i++){
		for(int j=1;j<=x.x;j++){
			ans.mapp[i][j]=0.0;
		}
	} 
	for(int i=1;i<=x.x;i++){
		for(int j=1;j<=x.x;j++){
			for(int k=1;k<=x.y;k++){
				ans.mapp[i][j]+=(LF)x.mapp[i][k]*y.mapp[k][j];
			}
		}
	}
	ans.x=ans.y=x.x;
	return ans;
}
QQQ qpow(QQQ x,int y){
	QQQ aaa=x;
	y--;
	while(y){
		if(y&1){
			aaa=cheng(aaa,x);
		}
		x=cheng(x,x);
		y>>=1;
	}
	return aaa;
}
string main(){
	cin>>n>>len>>alp;
	for(int i=1;i<=n;i++){
		cin>>s;
		insert(s);
	}
	init();
	a.x=a.y=cnt+1;
	a.mapp[cnt+1][cnt+1]=1;
	for(int i=1;i<=cnt;i++){
		for(int j=0;j<alp;j++){
			if(tr[tr[i].son[j]].flag){
				a.mapp[i][1]+=1.0/(LF)alp;
				a.mapp[i][cnt+1]+=1.0/(LF)alp;
			}
			else{
				a.mapp[i][tr[i].son[j]]+=1.0/(LF)alp;
			}
		}
	}
	a=qpow(a,len);
//	cout<<a.mapp[1][cnt+1];
	printf("%Lf",a.mapp[1][cnt+1]);
	return "woshiyuanshenwanjia!!!";
}
}
signed main(){
	FFF::main();
	return 0;
}
```

---

## 作者：xuyiyang (赞：0)

### [P4569 [BJWC2011] 禁忌](https://www.luogu.com.cn/problem/P4569)
### Solution
以下中的 $k$ 就是 $\text{alphabet}$。$\\$
首先是个多串匹配问题，所以先建出 AC 自动机进行 DP。对于一个串的伤害值，可以贪心求得，注意不能重复！也就是说，当当前位有一个后缀是禁忌串时，则转移到下一位需要将在自动机上当前的点**回到根节点**。若没有，则正常转移到下一位。$\\$
于是就有 DP：令 $f_{i,j}$ 表示当前在第 $i$ 位，在 AC 自动机的节点 $j$ 上的期望伤害。考虑刷表。令 $u$ 为下一位选择字母 $t$ 时 $j$ 的位置，即自动机的 $son_{j,t}$。
$$\begin{cases} f_{i+1,u} \gets \frac{1}{k}f_{i,j} & \text{j has no vaild suffix} \\ f_{i+1,0} \gets \frac{1}{k}(f_{i,j}+1) & \text{otherwise}
\end{cases}$$
发现 $f_{i+1}$ 可以由 $f_i$ 的线性组合表示，则直接矩阵快速幂。然后就做完了。$\mathcal O((\sum\lvert S_i \rvert)^3 \log len)$。
```cpp
void ins(char *s) {
	int p = 0;
	for (int i = 0; s[i]; i ++ ) {
		int u = s[i] - 'a';
		if (!son[p][u]) son[p][u] = ++ idx;
		p = son[p][u];
	} ed[p] = 1;
}
void build() {
	int hh = 0, tt = -1;
	for (int i = 0; i < k; i ++ ) if (son[0][i]) q[ ++ tt] = son[0][i];
	while (hh <= tt) {
		int t = q[hh ++ ]; ed[t] |= ed[fa[t]];
		for (int i = 0; i < k; i ++ ) 
			if (son[t][i]) fa[son[t][i]] = son[fa[t]][i], q[ ++ tt] = son[t][i];
			else son[t][i] = son[fa[t]][i];
	}
}

struct Matrix {
	double w[M][M];
	void cl() { for (int i = 0; i <= idx + 1; i ++ ) for (int j = 0; j <= idx + 1; j ++ ) w[i][j] = 0; }
	Matrix operator * (const Matrix& t) const {
		Matrix c; c.cl();
		for (int i = 0; i <= idx; i ++ ) for (int j = 0; j <= idx; j ++ ) for (int k = 0; k <= idx; k ++ )
			c.w[i][j] += w[i][k] * t.w[k][j];
		return c;
	}
} g, f;

void mian() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i ++ ) scanf("%s", s), ins(s);
	build(); g.cl(); f.cl();
	for (int i = 0; i <= idx; i ++ ) for (int j = 0; j < k; j ++ ) {
		if (ed[son[i][j]]) g.w[i][0] += 1.0 / k, g.w[i][idx + 1] += 1.0 / k;
		else g.w[i][son[i][j]] += 1.0 / k;
	} idx ++ ; f.w[0][0] = g.w[idx][idx] = 1;
	while (m) {
		if (m & 1) f = f * g;
		m >>= 1; g = g * g;
	}	
	printf("%.8lf\n", f.w[0][idx]); return void();
}
```

---

## 作者：creation_hy (赞：0)

这题其实可以直接反过来算期望（？

题面容易想到 AC 自动机上 dp。建出自动机后，状态 $f_{i,j}$ 表示当前字符串长度为 $i$，对应到自动机上的节点为 $j$，求此时的期望，那么有转移（为了固定转移的起点，一定要倒着转移）：

$$f_{i,x} = \displaystyle\sum_{x\to y} \dfrac{f_{i+1,y}+tag_y}{alphabet}$$

这样最后 $f_{0,0}$ 就是答案了。然后用矩阵快速幂优化一下。

最后为了防止算重，经过一个 $tag=1$ 的点后要直接回到起点，也就是对于 $tag_y=1$ 的 $y$，把 $x\to y$ 的转移改成 $x\to 0$。



```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
const int N = 80;
int n, m, al, tot;
struct Matrix
{
    ld a[N][N];
    inline Matrix() { memset(a, 0, sizeof(a)); }
    inline Matrix operator*(const Matrix &t) const
    {
        Matrix res;
        for (int i = 0; i <= tot; i++)
            for (int j = 0; j <= tot; j++)
                for (int k = 0; k <= tot; k++)
                    res.a[i][j] += a[i][k] * t.a[k][j];
        return res;
    }
    inline Matrix operator^(ll k)
    {
        Matrix res, x = *this;
        for (int i = 0; i <= tot; i++)
            res.a[i][i] = 1;
        while (k)
        {
            if (k & 1)
                res = res * x;
            x = x * x;
            k >>= 1;
        }
        return res;
    }
} A, B;
struct ACAM
{
    int t[N][26], fail[N], tag[N], deg[N];
    inline void insert(string s)
    {
        int p = 0;
        for (char c : s)
        {
            c -= 'a';
            if (!t[p][c])
                t[p][c] = ++tot;
            p = t[p][c];
        }
        tag[p] = 1;
    }
    inline void build()
    {
        queue<int> q;
        for (int i = 0; i < al; i++)
            if (t[0][i])
                q.emplace(t[0][i]);
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            tag[x] |= tag[fail[x]];
            for (int i = 0; i < al; i++)
                if (t[x][i])
                    fail[t[x][i]] = t[fail[x]][i], q.emplace(t[x][i]);
                else
                    t[x][i] = t[fail[x]][i];
        }
    }
} ac;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> al;
    string s;
    for (int i = 1; i <= n; i++)
        cin >> s, ac.insert(s);
    B.a[0][++tot] = 1, ac.build();
    for (int i = 0; i < tot; i++)
        for (int j = 0; j < al; j++)
            if (ac.tag[ac.t[i][j]])
                A.a[0][i] += ld(1) / al, A.a[tot][i] += ld(1) / al;
            else
                A.a[ac.t[i][j]][i] += ld(1) / al;
    A.a[tot][tot] = 1;
    B = B * (A ^ m);
    cout << fixed << setprecision(10) << B.a[0][0] << '\n';
    return 0;
}
```

---

## 作者：LKY928261 (赞：0)

首先考虑求一个已经确定的字符串会造成的禁忌伤害，一种显然的贪心是每次选取所有当前能选的字符串中右端点最小的计入总数。

涉及到多模式串匹配，容易想到 AC 自动机。

由于匹配的串必须两两不交，所以要在走到结束节点的时候直接跳回根节点。只需将 AC 自动机上所有连向结束节点的边手动改为连向根节点（同时要更新答案）。

这样就可以轻松地完成对单串的计算了——

**——吗？**

下面给出一组 hack 数据：

```text
2 5 2
ababa
b
```

对于这组数据，如果给定的字符串为 `ababa`，那么答案理应是 2，但上面给出的这种做法给出的结果是 1。

考虑一下 WA 的原因：算法一开始就往 `ababa` 跑，忽略了原本所在位置更靠前的 `b`，而我们**没有做任何操作来让自动机在跑到 `ab` 的时候记录答案**。所以我们的自动机执着于 `ababa`。

所以还要将自动机上所有以某个模式串为后缀的节点设为结束节点。

而 AC 自动机自带的 fail 树恰好满足了我们的要求。我们只要在某个节点的 fail 是结束节点的时候，把当前节点也设为结束节点即可。

（这一点不难处理，但也比较容易漏，原先有两篇题解都会被 hack）

---

会做单个文本串之后，接下来的就容易做了。

考虑在 AC 自动机上 dp，每次每个节点向接下来的 $alphabet$ 种可能情况进行转移。

注意到最多只有 75 个节点，且每次的转移都相同，直接将所有状态存到矩阵中，矩阵快速幂优化即可。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double db;
const ll _=80;
ll n,m,k,T,a[_][26],b[_],i,j;db t;bool f[_];
struct mtx{
	db a[_][_];
	mtx(){for(ll j,i=0;i<_;i++)for(j=0;j<_;j++)a[i][j]=0;}
	mtx operator*(const mtx &t){
		mtx s;ll i,j,g;
		for(i=0;i<_;i++)for(g=0;g<_;g++)if(a[i][g])for(j=0;j<_;j++)
			s.a[i][j]+=a[i][g]*t.a[g][j];
		return s;
	}
}A,B;
mtx qp(mtx x,ll y){mtx z=x;for(y--;y;y>>=1,x=x*x)if(y&1)z=z*x;return z;}
void ins(){
	string str;ll t=0,x;
	cin>>str;
	for(char ch:str){
		x=ch-97;
		if(!a[t][x])a[t][x]=++T;
		t=a[t][x];
	}
	f[t]=1;
}
void build(){
	queue<ll>q;ll x,i;
	for(i=0;i<m;i++)if(a[0][i])q.push(a[0][i]);
	while(q.size()){
		x=q.front();q.pop();
		if(f[b[x]])f[x]=1;//不加这句就假了，但能水过去
		for(i=0;i<m;i++){
			if(a[x][i])b[a[x][i]]=a[b[x]][i],q.push(a[x][i]);
			else a[x][i]=a[b[x]][i];
		}
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>k>>m;B.a[0][0]=1;t=1/(db)m;
	for(i=0;i<n;i++)ins();
	build();A.a[79][79]=1;
	for(i=0;i<=T;i++)for(j=0;j<m;j++)
		if(f[a[i][j]])A.a[i][0]+=t,A.a[i][79]+=t;
		else A.a[i][a[i][j]]+=t;
	cout<<setprecision(10)<<fixed<<(B*qp(A,k)).a[0][79]<<'\n';
}
```

---


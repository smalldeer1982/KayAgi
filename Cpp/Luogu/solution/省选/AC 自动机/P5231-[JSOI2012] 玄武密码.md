# [JSOI2012] 玄武密码

## 题目背景

在美丽的玄武湖畔，鸡鸣寺边，鸡笼山前，有一块富饶而秀美的土地，人们唤作进香河。相传一日，一缕紫气从天而至，只一瞬间便消失在了进香河中。老人们说，这是玄武神灵将天书藏匿在此。 

很多年后，人们终于在进香河地区发现了带有玄武密码的文字。更加神奇的是，这份带有玄武密码的文字，与玄武湖南岸台城的结构有微妙的关联。于是，漫长的破译工作开始了。

## 题目描述

 经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 $n$ 的序列 $s$ 来描述，序列中的元素分别是 `E`，`S`，`W`，`N`，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 $m$ 段文字。这里的四象，分别是东之青龙，西之白虎，南之朱雀，北之玄武，对东南西北四向相对应。 

现在，考古工作者遇到了一个难题。对于每一段文字 $t$，求出其最长的前缀 $p$，满足 $p$ 是 $s$ 的子串。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$，$m \leq 50$。
- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^4$，$m \leq 2 \times 10^3$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^6$，$m \leq 2 \times 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^7$，$1 \leq m \leq 10^5$，$1 \leq |t| \leq 100$，$s, t$ 中均只含字母 `E` `S` `W` `N`。

## 样例 #1

### 输入

```
7 3
SNNSSNS
NNSS
NNN
WSEE
```

### 输出

```
4
2
0```

# 题解

## 作者：itisover (赞：24)

极简思路：

先跑一边AC自动机，处理出 ``fail`` 数组，然后再把文本串匹配一下，可以获得 ``vis`` 数组，代表着 ``trie`` 树上的这个点是文本串的前缀。最后只需要再每个模式串跑一遍 ``trie`` 树，就可以得到最长的公共前缀长度了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5,M=1e5+5;
int n,lent;
int trie[N][26],tot,fail[N],End[N];
int vis[N];
char tmp[M][105],t[N];
queue<int> q;
void ins(char *str){
  int len=strlen(str),p=0;
  for(int i=0;i<len;i++){
    int ch=str[i]-'A';
    if(!trie[p][ch]) trie[p][ch]=++tot;
    p=trie[p][ch];
  }
  End[p]++;
}
void build(){
  for(int i=0;i<26;i++) if(trie[0][i]) q.push(trie[0][i]),fail[trie[0][i]]=0;
  while(!q.empty()){
    int u=q.front();q.pop();
    for(int i=0;i<26;i++){
      if(trie[u][i]) fail[trie[u][i]]=trie[fail[u]][i],q.push(trie[u][i]);
      else trie[u][i]=trie[fail[u]][i];
    }
  }
  int p=0;
  for(int i=0;i<lent;i++){
    p=trie[p][t[i]-'A'];
    for(int k=p;k&&!vis[k];k=fail[k]) vis[k]=1;
  }
}
int Query(char *str){
  int len=strlen(str),p=0,res=0;
  for(int i=0;i<len;i++){
    p=trie[p][str[i]-'A'];
    if(vis[p]) res=i+1;
  }
  return res;
}
int main(){
  scanf("%d%d",&lent,&n);
  scanf("%s",t);
  for(int i=1;i<=n;i++){
    scanf("%s",tmp[i]);
    ins(tmp[i]);
  }
  build();
  for(int i=1;i<=n;i++){
    printf("%d\n",Query(tmp[i]));
  }
  return 0;
}
```

---

## 作者：chzhc (赞：24)

做法 ：`AC自动机`。

我们考虑把 $M$ 个询问子串建成一棵 $trie$ 树，构建出 $fail$ 指针，用长串 $S$ 在 `AC自动机` 上进行匹配，根据 $fail$ 指针的定义，可知对于长串 $S$ 遍历 $trie$ 树时遍历过的结点以及此结点通过 $fail$ 指针跳到的结点 $u$，在 $trie$ 树上 $1$ 到 $u$ 的路径上的字符串一定存在于长串 $S$ 上，即某个串的前缀 $1 … u$ 存在于长串 $S$ 上，故我们可以在结点 $u$ 上打标记，再重新遍历每个询问字符串在 $trie$ 树上的结点，拥有标记即可更新答案。

$Code:$
```cpp
#include <bits/stdc++.h>

const int MaxN = 1e7 + 10;
const int MaxM = 1e5 + 10;
const int MaxLM = 1e2 + 10;

using namespace std;

inline int read() {
    int cnt = 0, opt = 1;
    char ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar())
        if (ch == '-') opt = 0;
    for (; ch >= '0' && ch <= '9'; ch = getchar())
        cnt = (cnt << 3) + (cnt << 1) + (ch ^ 48);

    return opt ? cnt : -cnt;
}

inline int modify(char s) {
	if (s == 'E') return 0;
	if (s == 'S') return 1;
	if (s == 'W') return 2;
	if (s == 'N') return 3;
}

int n, m;
char s[MaxN], s2[MaxM][MaxLM];
int ch[MaxLM * MaxM][4], tot = 1;
int nxt[MaxN], bo[MaxN];
queue <int> que;

inline void insert(int num) {
	int len = strlen(s2[num] + 1), u = 1;
	for (int i = 1; i <= len; ++ i) {
		int str = modify(s2[num][i]);
		if (! ch[u][str]) ch[u][str] = ++ tot;
		u = ch[u][str];
	}
}//把当前字符串插入 trie 树

inline void make_fail() {
	for (int i = 0; i <= 3; ++ i)
		ch[0][i] = 1;
	que.push(1), nxt[1] = 0;

	while (que.size()) {
		int u = que.front();
		que.pop();

		for (int i = 0; i <= 3; ++ i) {
			if (! ch[u][i]) ch[u][i] = ch[nxt[u]][i];
			else {
				que.push(ch[u][i]);
				int v = nxt[u];
				while (v > 1 && ! ch[v][i]) v = nxt[v];
				nxt[ch[u][i]] = ch[v][i];
			}
		}

	}
}//构建 fail 指针

inline void s_find() {
	int u = 1;
	for (int i = 1; i <= n; ++ i) {
		int str = modify(s[i]);
		u = ch[u][str];
		int k = u;
		while (k > 1 && ! bo[k]) {//若 k 结点打过标记，则所有 k 的 fail 指针跳到的结点都打过标记，故可以跳过
			bo[k] = 1;
			k = nxt[k];
		}
	}
}//把在 Trie 树上与 s 串匹配的位置打上标记

inline int solve(int num) {
	int len = strlen(s2[num] + 1), u = 1;
	int ans = 0; 
	for (int i = 1; i <= len; ++ i) {//遍历当前字符串在 trie 树上的每一个结点
		int str = modify(s2[num][i]);
		u = ch[u][str];
		if (bo[u])//存在标记就更新答案
			ans = i;
	}
	return ans;
}//找出前缀最大匹配

int main() {
    n = read(), m = read();
    scanf("%s", s + 1);

    for (int i = 1; i <= m; ++ i) {
    	scanf("%s", s2[i] + 1);
    	insert(i);
}

    make_fail();
    s_find();

    for (int i = 1; i <= m; ++ i)
    	printf("%d\n", solve(i));
    return 0;
}

```

---

## 作者：谦谦君子 (赞：10)

这是一道AC自动机的裸题，现在我们先来介绍一下AC自动机（也就是Aho-Corasick automaton算法），该算法在1975年产生于贝尔实验室，是著名的  _多模匹配算法_ 。
在学AC自动机之前，我们必须知道什么是Trie，也就是字典树。Trie树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。可以用于统计和排序大量的字符串（但不仅限于字符串），也经常被搜索引擎系统用于文本词频统计。
AC自动机大体分为构造一棵Trie树，构造失败指针和模式匹配的过程。具体操作可以看看

[AC自动机详解](https://www.cnblogs.com/jason2003/p/9651073.html)或[AC自动机](https://www.cnblogs.com/cmmdc/p/7337611.html)等博客

在这道题之中，需要
### 对所有文字段建AC自动机；
### 将母串放到AC自动机上匹配；
### 匹配到一个点就沿着它的fail指针向上走，
### 将经过的点标记成已匹配，
### 碰到已匹配的点就退出。
### 这样每个点最多只会被标记一次，
### 统计答案的时候从每个单词的最后一个点，
### 向上走到第一个被标记的节点即可。


------------

# 详情见代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 10000010	//10^7母串长度
#define M 100010	//文字串的最大个数
#define L 110		//100文字串的长度
using namespace std;
int ch[N][4],l[M],cnt=1,n,m,q[N],fail[N],fa[N],pos[N],point[M];
/*
ch为字典树,l为文字串i的长度,fa为u的父结点编号,cnt为u结点数,q为队列,
fail为u结点匹配失败时的回退结点编号,pos为到u结点止的子串是否与母串匹配
point为文字串i未尾字母的结点编号
*/
char ss[L],ms[N];						//ss为临时文字串，ms为母串
int cal(char x)							//将东南西北转换为数字0-3
{
	if (x=='E') return 0;
	if (x=='S') return 1;
	if (x=='W') return 2;
	if (x=='N') return 3;
}
void insert(int x)						//构建Trie树
{
	l[x]=strlen(ss);
	int u=1;
	for (int i=0; i<l[x]; i++)
	{
		int c=cal(ss[i]);
		if (!ch[u][c])
		{
			ch[u][c]=++cnt;
			fa[cnt]=u;					//记下父结点编号，以便回溯
		}
		u=ch[u][c];
	}
	point[x]=u;							//记下文字串末尾结点编号
}
void getfail()							//广搜匹配
{
	int h=0,t=1;						//队头队尾编号
	q[0]=1;
	fail[1]=0;
	while (h<t)
	{
		int c=q[h++];
		for (int i=0; i<4; i++)
		{
			int k=fail[c];
			while (!ch[k][i])
			{
				k=fail[k];
			}
			if (ch[c][i])
			{
				fail[ch[c][i]]=ch[k][i];
				q[t++]=ch[c][i];
			}
			else
			{
				ch[c][i]=ch[k][i];
			}
		}
	}
}
void pre()
{
	int u=1;
	for (int i=0;i<n;i++)
	{
		int c=cal(ms[i]);
		u=ch[u][c];
		for (int j=u;j;j=fail[j])
		{
			if (pos[j])
			{
				break;
			}
			else
			{
				pos[j]=1;
			}
		}
	}
}
int getans(int x)
{
	int ans=l[x];						//假定全部匹配
	for (int i=point[x]; i; i=fa[i])	//非虚结点
	{
		if (pos[i])
		{
			return ans;
		}
		ans--;
	}
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",ms);
	for (int i=1;i<=m;i++)
	{
		scanf("%s",ss);
		insert(i);
	}
	for (int i=0;i<4;i++)				//建虚结点0
	{
		ch[0][i]=1;
	}
	getfail();
	pre();
	for (int i=1;i<=m;i++)
	{
		printf("%d\n",getans(i));
    	}
        return 0;
}
```





---

## 作者：JK_LOVER (赞：9)

## 题意
给你 $n$ 个匹配串 $S_i$ ，$1$ 个匹配串 $T$ 。求 $T$ 对于 $S_i$ 能匹配的最长前缀长度。 [$QAQ$](https://www.luogu.com.cn/blog/xzc/solution-p5231)
## 分析
这题用 $SAM$ 应该是比较简单的吧。

- $\text{SAM}$ 最简单、也最重要的性质是，它包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $t_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个 $\text{子串}$ 。反之每个 $s$ 的子串对应从 $t_0$ 开始的某条路径。 -- oi-wiki

有了这个 $SAM$ 最基本的性质。那么就可以很正常得到这个。

- 从 $t_0$ 出发的每一条路径都是某个后缀的前缀。

先对 $T$ 建一个 $\text{SAM}$ 。那么对于每个匹配串我们只需要走转移边就行了。如果失配，可以直接输出长度。时间复杂度为  $O(|T|+\sum|S_i|)$

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int si,last;
const int N = 1e7+10;
struct Node{
	int link,len;
	int nxt[4];
}st[N<<1];
void init(){
	st[0].link = -1;st[0].len = 0;si++;last = 0;
}
void insert(int c){
	int cur = si++;st[cur].len = st[last].len + 1;
	int p = last;
	while(p != -1 && !st[p].nxt[c]){
		st[p].nxt[c] = cur;p = st[p].link;
	}
	if(p == -1) st[cur].link = 0;
	else {
		int q = st[p].nxt[c];
		if(st[q].len == st[p].len + 1) st[cur].link = q;
		else {
			int cl = si++;
			st[cl].len = st[p].len + 1;st[cl].link = st[q].link;
			for(int i = 0;i < 4;i++) st[cl].nxt[i] = st[q].nxt[i];
			while(p != -1 && st[p].nxt[c] == q){
				st[p].nxt[c] = cl;p = st[p].link;
			}
			st[cur].link = st[q].link = cl;
		}
	}
	last = cur;
}
char ch[N];
int n,m;
int main(){
	init();
	cin >> n >> m;
	cin >> ch;
	for(int i = 0;i < n;i++) {
		if(ch[i] == 'E') insert(0);
		if(ch[i] == 'S') insert(1);
		if(ch[i] == 'W') insert(2);
		if(ch[i] == 'N') insert(3);
	}
	for(int i = 1;i <= m;i++) {
		cin >> ch;
		int L = strlen(ch),now = 0,len = 0;
		for(int j = 0;j < L;j++)
		{	
			int c;
			if(ch[j] == 'E') c = 0;
			if(ch[j] == 'S') c = 1;
			if(ch[j] == 'W') c = 2;
			if(ch[j] == 'N') c = 3;
			if(!st[now].nxt[c]) break;
			++len;now = st[now].nxt[c];
		}
		printf("%d\n",len);
	}
	return 0;
}
```



---

## 作者：BzhH (赞：3)

这道题其实就是一道裸的AC自动机板子题，只需要在建tire图的时候稍微处理一下，因为它求的是子串的最长前缀，那么我们可以将子串再划分为许多长度不同的前缀就行了，然后再记录一下划分出来的前缀分别属于哪一个子串。

代码
```
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
const int N = 1e7 + 5;

char str[N], s[N];
int tr[N][4], cnt[N], net[N], idx, mp[200], ans[N];
bool vis[N];
queue<int> q;
vector<int> v, bel[N];

void insert(int x)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int t = mp[(int)str[i]];
        if (!tr[p][t])
            tr[p][t] = ++idx;
        p = tr[p][t];
        cnt[p] = i + 1;//记录每一个前缀的长度
        bel[p].push_back(x);//记录当前节点可以更新哪些子串
    }
}

void build()
{
    for (int i = 0; i < 4; i++)
        if (tr[0][i])
            q.push(tr[0][i]);
    while (!q.empty())
    {
        int t = q.front();
        q.pop();
        for (int i = 0; i < 4; i++)
        {
            int p = tr[t][i];
            if (!p)
                tr[t][i] = tr[net[t]][i];
            else 
            {
                net[p] = tr[net[t]][i];
                q.push(p);
            }
        }
    }
}//AC自动机

int main()
{
    mp['N'] = 0, mp['W'] = 1, mp['S'] = 2, mp['E'] = 3;
    int n, m;
    scanf("%d%d", &n, &m);
    scanf("%s", &s);
    for (int i = 1; i <= m; i++)
    {
        scanf("%s", &str);
        insert(i);
    }
    build();
    for (int i = 0, j = 0; s[i]; i++)
    {
        int t = mp[(int)s[i]];
        j = tr[j][t];
        int p = j;
        while (p)
        {
            if (vis[p])
                break;//一个优化，即先把所有的找出来，然后在一起更新
            vis[p] = true;
            v.push_back(p);
            p = net[p];
        }
    }
    for (int i = 0; i < v.size(); i++)
    {
        int p = v[i];
        for (int j = 0; j < bel[p].size(); j++)
            ans[bel[p][j]] = max(ans[bel[p][j]], cnt[p]);//更新答案
    }
    for (int i = 1; i <= m; i++)
        printf("%d\n", ans[i]);
    return 0;
}
```


---

## 作者：Kalium (赞：2)

# P5231 [JSOI2012]玄武密码 题解

## 前言：

代码开了防抄袭(freopen)，文件名是歌名。

## 题意：

给个母串 $T$，再给出 $N$ 个子串 $S$，要求 $S$ 在 $T$ 中最多连续占了多少字母。

## 思路：

多串匹配，第一反应AC自动机。

由于我们见这个串只有 $4$ 个字母，所以可以考虑将其离散化。

我们想想这个 $fail$ 的性质，是不是 $root$ 到 $j$ 所形成的的串是 $root$ 到 $i$ 所形成的串的最长后缀。

那么我们将 $T$ 这玩意儿每个字母的 $fail$ 边标记出来，

然后在从每个 $S$ 串中搜索，如果碰见当前字母是标记过得，移动到此位置，

那么不符合，跳出即可。

## 代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>

const int N = 1e7 + 7;
const int T = 1e2 + 7;
const int M = 1e5 + 7;

using namespace std;

int tot, n, m;

char s1[N], s2[M][T];

inline int init(char c) {
	if (c == 'E') return 0;
	if (c == 'S') return 1;
	if (c == 'W') return 2;
	if (c == 'N') return 3;
}

struct AC {
	int trie[N][7];
	int fail[N];
	bool flag[N];
	
	inline void insert(char *ss) {
		int len = strlen(ss + 1), pos = 0;
		
		for (int i = 1; i <= len; i ++) {
			int c = init(ss[i]);
			
			if (! trie[pos][c])
				trie[pos][c] = ++ tot;
			
			pos = trie[pos][c];
		} 
	}
	
	inline void bfs() {
		queue <int> q;
		
		for (int i = 0; i < 4; i ++) {
			int pos = trie[0][i];
			
			if (pos) {
				q.push(pos);
				fail[pos] = 0;
			}
		}
		
		while (! q.empty()) {
			int u = q.front();
			q.pop();
			
			for (int i = 0; i < 4; i ++) {
				int pos = trie[u][i];
				
				if (pos) {
					fail[pos] = trie[fail[u]][i];
					q.push(pos);
				} else
					trie[u][i] = trie[fail[u]][i];
			}
		}
	}
	
	inline void remember(char *ss) {
		int len = strlen(ss + 1), pos = 0;
		
		for (int i = 1; i <= len; i ++) {
			int c = init(ss[i]);
			pos = trie[pos][c];
			
			for (int j = pos; j; j = fail[j])
				flag[j] = 1;
		}
	} 
	
	inline int find(char *ss) {
		int len = strlen(ss + 1), pos = 0, ans = 0;
		
		for (int i = 1; i <= len; i ++) {
			int c = init(ss[i]);
			pos = trie[pos][c];
			
			if (flag[pos]) 	ans = i;
			else break;
		}
		
		return ans;
	}
} ac;

int main() {
	freopen("tired.in", "r", stdin);
	freopen("tired.out", "w", stdout);
	
	cin >> n >> m;
	scanf("%s", s1 + 1);
	
	for (int i = 1; i <= m; i ++) {
		scanf("%s", s2[i] + 1);
		ac.insert(s2[i]);
	} 
	
	ac.bfs();
	ac.remember(s1);
	
	for (int i = 1; i <= m; i ++)
		cout << ac.find(s2[i]) << endl;
		
	fclose(stdin);
	fclose(stdout);
		
	return 0;
} 
```

$Atlantic.$

---

## 作者：Celtic (赞：1)

题意：给出一个文本串和$n$个模式串，求对于每个模式串，其前缀在文本串上的最大匹配长度。


离线。

先给模式串建出$trie$图，然后在$trie$图上查询文本串，对到达的每个节点跳失配指针，给能跳到的节点打上标记。

对于每个模式串，它在$trie$图上遍历到的节点如果被打了标记，当前的前缀就是匹配的。找出最大的即可。

代码
```cpp
#include<bits/stdc++.h>
#define eps 1e-7
#define re register
#define N 2001001
#define MAX 2001
#define PI 3.1415927
#define inf 1e18
using namespace std;
typedef long long ll;
typedef double db;
const ll mod=998244353;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
    ret=pd?-ret:ret;
    return;
}
ll n,m,trie[N][5],nxt[N],tot;
bool b[N];
inline ll calc(re char c)
{
    switch(c)
    {
        case 'E':
            return 1;
        case 'S':
            return 2;
        case 'W':
            return 3;
        default :
            return 4;
    }
}
char s[10000001],a[100001][101];
inline void insert(re ll pos)
{
    re ll p=0,len=strlen(a[pos]+1);
    for(re int i=1;i<=len;i++)
    {
        re ll c=calc(a[pos][i]);
        if(!trie[p][c])
            trie[p][c]=++tot;
        p=trie[p][c];
    }
    return;
}
queue<ll>q;
inline void bfs()
{
    while(!q.empty())q.pop();
    for(re int i=1;i<=4;i++)
        if(trie[0][i])
            q.push(trie[0][i]);
    while(!q.empty())
    {
        re ll p=q.front();
        q.pop();
        for(re int i=1;i<=4;i++)
        {
            if(!trie[p][i])trie[p][i]=trie[nxt[p]][i];
            else
            {
                q.push(trie[p][i]);
                nxt[trie[p][i]]=trie[nxt[p]][i];
            }
        }
    }
    return;
}
inline void find()
{
    re ll len=strlen(s+1),p=0;
    for(re int i=1;i<=len;i++)
    {
        re char c=calc(s[i]);
        p=trie[p][c];
        re ll k=p;
        while(k)
        {
            b[k]=true;
            k=nxt[k];
        }
    }
    return;
}
inline ll solve(re ll pos)
{
    re ll len=strlen(a[pos]+1),p=0,ans=0;
    for(re int i=1;i<=len;i++)
    {
        re ll c=calc(a[pos][i]);
        p=trie[p][c];
        if(b[p])
            ans=i;      
    }
    return ans;
}
int main()
{
    read(n);
    read(m);
    scanf("%s",s+1);
    for(re int i=1;i<=m;i++)
    {
        scanf("%s",a[i]+1);
        insert(i);
    }
    bfs();
    find();
    for(re int i=1;i<=m;i++)
        printf("%lld\n",solve(i));
    exit(0);
}

```



---

## 作者：_Diu_ (赞：1)

题目：[玄武密码](https://www.luogu.com.cn/problem/P5231)

这是一道
## AC自动机
的题

~~至少我是用AC自动机做的~~

仔细阅读题目之后就会发现

要求的是每个字符串在母串中的最长前缀

## 个人思路（$T$了）

### 不想看的可以跳过

开一个结构体$cxk$~~不要介意这个命名，个人习惯~~

表示所属字符串编号和在这个编号中的第几个字符

在$find$的过程中把每个字符串的值更新，去最大值

但是每个节点可能会被多个字符串包含，所以我用了$vector$来维护

$push$:
```cpp
num[p].push_back({k,i+1});
```

$find$:
```cpp
for(int j=0;j<num[k].size();j++)ans[num[k][j].x]=max(ans[num[k][j].x],num[k][j].id);
```

结果$T$了，不清楚加了优化之后会不会$T$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int trie[N][4],n,nxt[N],tot,ans[N];
string s,str;
struct cxk{
    int x,id;
};
vector<cxk> num[N];
const char ch[]{'E','S','W','N'};
int gett(char s){
    for(int i=0;i<4;i++){
        if(ch[i]==s)return i;
    }
}
inline void push(string s,int k){
    register int p=0;
    for(register int i=0;i<s.size();++i){
        register int c=gett(s[i]);
        if(trie[p][c])p=trie[p][c];
        else p=trie[p][c]=++tot;
        num[p].push_back({k,i+1});
    }
}
inline void getfail(){
    queue<int> q;
    for(register int i=0;i<4;++i){
        if(trie[0][i])q.push(trie[0][i]);
    }
    while(!q.empty()){
        register int p=q.front();
        q.pop();
        for(register int i=0;i<4;i++){
            if(trie[p][i]){
                nxt[trie[p][i]]=trie[nxt[p]][i];
                q.push(trie[p][i]);
            }else trie[p][i]=trie[nxt[p]][i];
        }
    }
}
inline void find(string s){
    register int p=0;
    for(register int i=0;i<s.size();i++){
        register int c=gett(s[i]);
        register int k=trie[p][c];
        while(k>0){
            for(int j=0;j<num[k].size();j++)ans[num[k][j].x]=max(ans[num[k][j].x],num[k][j].id);
            k=nxt[k];
        }
        p=trie[p][c];
    }
}
int main(){
    scanf("%d",&n);
    scanf("%d",&n);
    cin>>str;
    for(int i=1;i<=n;i++){
        cin>>s;
        push(s,i);
    }
    getfail();
    find(str);
    for(int i=1;i<=n;i++)printf("%d\n",ans[i]); 
}
```

好了，然后$T$的很惨，于是决定从算法上优化

## 正解

可以想到一个节点可能被便利多次，被统计多次，这些统统都可以省略

所以我们可以等全部统计完了之后再进行统计

我们可以定义$flag[p]$表示$trie$数中$p$这个位置上的节点是否被遍历过

在$find$的时候顺便把遍历过的点打上标记就行了

注意如果某个节点已经打上标记了，那么它在往上的节点也一定会打上标记，所以就可以剪枝

```cpp
while(k>0&&!flag[k])flag[k]=1,k=nxt[k];
```

这样就不怕时间超限了

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int trie[N][4],n,nxt[N],tot,ans[N];
bool flag[N];
string s[N],str;
struct cxk{
	int x,id;
};
const char ch[]{'E','S','W','N'};
inline char nc(){
    static char buf[1000010],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000010,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
    register int s=0,w=0;
    static char ch=nc();
    for(;!isdigit(ch);)ch=nc();
    for(;isdigit(ch);){
        s=(s<<1)+(s<<3)+(ch^48);
        ch=nc();
    }
    return w?-s:s;
}//快读
inline string reads(){
    register string s="";
    static char ch=nc();
    for(;ch<'A'||ch>'Z';ch=nc());
    for(;ch>='A'&&ch<='Z';ch=nc())s+=ch;
    return s;
}//快读++
inline int gett(char s){
	for(int i=0;i<4;i++){
		if(ch[i]==s)return i;
	}
}
inline void push(string s,int k){
	register int p=0;
	for(register int i=0;i<s.size();++i){
		register int c=gett(s[i]);
		if(trie[p][c])p=trie[p][c];
		else p=trie[p][c]=++tot;
	}
}//插入
inline void getfail(){
	queue<int> q;
	for(register int i=0;i<4;++i){
		if(trie[0][i])q.push(trie[0][i]);
	}
	while(!q.empty()){
		register int p=q.front();
		q.pop();
		for(register int i=0;i<4;i++){
			if(trie[p][i]){
				nxt[trie[p][i]]=trie[nxt[p]][i];
				q.push(trie[p][i]);
			}else trie[p][i]=trie[nxt[p]][i];
		}
	}
}//获得失配指针
inline void find(string s){
	register int p=0;
	for(register int i=0;i<s.size();i++){
		register int c=gett(s[i]);
		register int k=trie[p][c];
		while(k>0&&!flag[k])flag[k]=1,k=nxt[k];//将没遍历过的点标记
		p=trie[p][c];
	}
}
inline int solve(string s) {
	int p=0,ans=0; 
	for(int i=0;i<s.size();i++){
		int c=gett(s[i]);
		p=trie[p][c];
		if(flag[p])ans=i+1;
		else break;//小剪枝：如果这个点没被遍历过，那么就算后面的点被便利了也不会匹配到，何况后面也不会被遍历
	}
	return ans;
}
int main(){
	n=read(),n=read(),str=reads();
	for(int i=1;i<=n;i++){
		s[i]=reads();
		push(s[i],i);
	}
	getfail();
	find(str);
	for(int i=1;i<=n;i++)printf("%d\n",solve(s[i])); 
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

其实还是很好想的一道题。       

先甩做法：我们首先 $AC$ 自动机走一下，然后我们就会在我们建成的 $Trie$ 上跳，令跳到的节点为 $u$ ，那么 $Trie$ 上 $1 \sim u$ 形成的字符串一定出现在 $S$ 里面，然后我们把这些节点都打上标记然后对于每个字符串在 $Trie$ 上由下至上跑即可。        

然后很多题解到这里就戛然而止了，那么为什么这个做法是对的呢？      

首先假设我们此时走到一个结点 $u$ ，那么 $1 \sim u$ 肯定是必须出现在 $S$ 里面的对吧，但是现在我们还有一些信息，即 $1 \sim u$ 的前缀没有处理，这时如果我们在用 $fail$ 指针去跳着更新的话，那么我们必然可以找完所有的在 $Trie$ 里面出现的 $1 \sim u$ 里的前缀，然后就必然可以找完所有的模式串里面的前缀并且无遗漏。        

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int Len = 1e7 + 5;
int n,m,trie[Len][5],Cnt[Len],cnt,pos[Len],fail[Len],fa[Len],dep[Len];
char S[105],ss[Len];
int Calc(char x)
{
	if(x == 'E') return 0;
	if(x == 'S') return 1;
	if(x == 'W') return 2;
	if(x == 'N') return 3;
} 
inline void Init(char s[],int x)
{
	int lens = strlen(s + 1) , root = 0;
	for(int i = 1 ; i <= lens ; i ++)
	{
		int Ind = Calc(s[i]); 
		if(!trie[root][Ind]) 
		{
			trie[root][Ind] = ++ cnt;
			dep[cnt] = dep[root] + 1;
			fa[cnt] = root;
		}
		root = trie[root][Ind];
	}
	pos[x] = root;
}
void Build_Trie_Graph()
{
	queue<int> q;
	for(int i = 0 ; i <= 3 ; i ++) 
	{
		if(trie[0][i])
		{
			fail[trie[0][i]] = 0;
			q.push(trie[0][i]);
		}
	}
	while(!q.empty())
	{
		int u = q.front() ; q.pop();
		for(int i = 0 ; i <= 3 ; i ++)
		{
			if(trie[u][i])
			{
				fail[trie[u][i]] = trie[fail[u]][i];
				q.push(trie[u][i]);
			}
			else trie[u][i] = trie[fail[u]][i];
		}
	}
}
void qry(char s[])
{
	int lens = strlen(s + 1) , root = 0;
	for(int i = 1 ; i <= lens ; i ++)
	{
		int Ind = Calc(s[i]);
		root = trie[root][Ind];
		for(int t = root ; t ; t = fail[t]) Cnt[t] = 1;
	}
}
int Find(int x)
{
	int P = pos[x];
	while(P != 0 && Cnt[P] != 1)
		P = fa[P];
	return dep[P];
}
int main()
{
	scanf("%d %d",&n,&m);
	scanf("%s",ss + 1);
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%s",S + 1);
		Init(S , i);
	} 
	fail[0] = dep[0] = 0;
	Build_Trie_Graph();
	qry(ss);
	for(int i = 1 ; i <= m ; i ++) printf("%d\n",Find(i));
	return 0;
}
```

---


# [BJOI2019] 奥术神杖

## 题目描述

Bezorath 大陆抵抗地灾军团入侵的战争进入了僵持的阶段，世世代代生活在 Bezorath 这片大陆的精灵们开始寻找远古时代诸神遗留的神器，试图借助神器的神秘力量帮助她们战胜地灾军团。

在付出了惨痛的代价后，精灵们从步步凶险的远古战场取回了一件保存尚完好的神杖。但在经历过那场所有史书都视为禁忌的“诸神黄昏之战”后，神杖上镶嵌的奥术宝石已经残缺，神力也几乎消耗殆尽。精灵高层在至高会议中决定以举国之力收集残存至今的奥术宝石，并重金悬赏天下能工巧匠修复这件神杖。

你作为神术一脉第五百零一位传人，接受了这个艰巨而神圣的使命。
神杖上从左到右镶嵌了 $n$ 颗奥术宝石，奥术宝石一共有 $10$ 种，用数字 "`0123456789`" 表示。有些位置的宝石已经残缺，用 "`.`" 表示，你需要用完好的奥术宝石填补每一处残缺的部分（每种奥术宝石个数不限，且不能够更换未残缺的宝石）。古老的魔法书上记载了 $m$ 种咒语 $(S_i,V_i)$ ，其中 $S_i$ 是一个非空数字串，$V_i$ 是这种组合能够激发的神力。

神杖的初始神力值 $Magic = 1$，每当神杖中出现了连续一段宝石与 $S_i$ 相等时，神力值 $Magic$ 就会乘以 $V_i$。但神杖如果包含了太多咒语就不再纯净导致神力降低：设 $c$ 为神杖包含的咒语个数（若咒语类别相同但出现位置不同视为多次），神杖最终的神力值为 $ \sqrt[c]{Magic}$。（若 $c = 0$ 则神杖最终神力值为 $1$ ）

例如有两种咒语 $(01,3)$ 、$(10,4)$ ，那么神杖 “`0101`” 的神力值为 $\sqrt[3]{ 3 \times 4 \times 3}$

你需要使修复好的神杖的最终的神力值最大，输出任何一个解即可。

## 说明/提示

样例 1 ：法杖最终神力值为 $2$ 。

样例 2 ：法杖最终神力值为 $\sqrt[3]{2 \times 3 \times 4}$

设 $s = \sum_{i=1}^{m} |S_i|$ ，即所有咒语的串长之和。
![](https://cdn.luogu.com.cn/upload/pic/57052.png)

## 样例 #1

### 输入

```
4 3
....
1 2
2 2
3 1```

### 输出

```
2019```

## 样例 #2

### 输入

```
5 4
..0..
0 2
00 2
01 4
10 3```

### 输出

```
11012```

## 样例 #3

### 输入

```
18 6
...2.1.0.1..1.0..1
011 6
111 4
010 12
121 7
101 5
10 3```

### 输出

```
121211203112120121```

# 题解

## 作者：小粉兔 (赞：15)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/BJOI2019D1T1.html](https://www.cnblogs.com/PinkRabbit/p/BJOI2019D1T1.html)。

### 题意简述：

有一个长度为 $n$ 的母串，其中某些位置已固定，另一些位置可以任意填。

同时给定 $m$ 个小串，第 $i$ 个为 $S_i$，所有位置都已固定，它的价值为 $V_i$。

每次每个小串在母串中出现一次，便会给答案的多重集贡献一个 $V_i$。

最终的答案为多重集的几何平均数，定义空集的几何平均数为 $1$。

请你求出一个合法母串（往可以填的位置填合法字符）使得答案最大。

$1\le n,s\le 1501$，$1\le V_i\le \max V=10^9$，其中 $\displaystyle s=\sum_{i=1}^{m}|S_i|$。

### 题解：

假设多重集的大小为 $c$，第 $i$ 个元素为 $w_i$，则 $\displaystyle \mathrm{Ans}=\sqrt[c]{\prod_{i=1}^{c}w_i}$。

两边取对数，有 $\displaystyle \ln\mathrm{Ans}=\frac{1}{c}\sum_{i=1}^{c}\ln w_i$，转化为经典的 0/1 分数规划问题。

二分答案，若等式右边大于 $\mathrm{mid}$，则有：

$\begin{aligned}\frac{1}{c}\sum_{i=1}^{c}\ln w_i&>\mathrm{mid}\\\sum_{i=1}^{c}\ln w_i&>c\cdot\mathrm{mid}\\\sum_{i=1}^{c}(\ln w_i-\mathrm{mid})&>0\end{aligned}$

所以，建出小串的 AC 自动机，然后二分答案后在 AC 自动机上 DP 判断不等式是否满足。

DP 时每个小串的权值设为 $\ln V_i-\mathrm{mid}$，注意要记录最佳转移点，以输出方案。

下面是代码，复杂度 $\mathcal{O}(n s \Sigma \log \log(\epsilon^{-1} \max V))$：

```cpp
#include <cstdio>
#include <cmath>

typedef double f64;
const int MN = 1505, Sig = 10;
const f64 eps = 1e-6, inf = 1e99;

int N, M;
char T[MN];

char str[MN];
int ch[MN][Sig], fail[MN], sum[MN], cnt;
f64 val[MN];

inline void Insert(char *s, f64 v) {
	int now = 0;
	for (; *s; ++s) {
		if (!ch[now][*s & 15]) ch[now][*s & 15] = ++cnt;
		now = ch[now][*s & 15];
	} ++sum[now], val[now] += v;
}

int que[MN], l, r;
void BuildAC() {
	fail[0] = -1;
	que[l = r = 1] = 0;
	while (l <= r) {
		int u = que[l++];
		for (int i = 0; i < Sig; ++i) {
			if (ch[u][i]) {
				int x = fail[u];
				while (~x && !ch[x][i]) x = fail[x];
				if (~x) fail[ch[u][i]] = ch[x][i];
				que[++r] = ch[u][i];
			}
			else if (~fail[u]) ch[u][i] = ch[fail[u]][i];
		}
	}
	for (int i = 2; i <= r; ++i)
		sum[que[i]] += sum[fail[que[i]]],
		val[que[i]] += val[fail[que[i]]];
}

f64 f[MN][MN];
int g[MN][MN][2];
char AT[MN];
inline f64 DP(f64 V) {
	for (int j = 0; j <= cnt; ++j) val[j] -= sum[j] * V;
	for (int i = 0; i <= N; ++i)
		for (int j = 0; j <= cnt; ++j)
			f[i][j] = -inf;
	f[0][0] = 0;
	for (int i = 0; i < N; ++i) {
		for (int j = 0; j <= cnt; ++j) {
			if (f[i][j] == -inf) continue;
			if (T[i] == '.') {
				for (int k = 0; k < Sig; ++k) {
					int _j = ch[j][k];
					if (f[i + 1][_j] < f[i][j] + val[_j])
						f[i + 1][_j] = f[i][j] + val[_j],
						g[i + 1][_j][0] = j,
						g[i + 1][_j][1] = k;
				}
			}
			else {
				int _j = ch[j][T[i] & 15];
				if (f[i + 1][_j] < f[i][j] + val[_j])
					f[i + 1][_j] = f[i][j] + val[_j],
					g[i + 1][_j][0] = j,
					g[i + 1][_j][1] = T[i] & 15;
			}
		}
	}
	for (int j = 0; j <= cnt; ++j) val[j] += sum[j] * V;
	int ans = 0;
	for (int j = 1; j <= cnt; ++j)
		if (f[N][j] > f[N][ans]) ans = j;
	for (int i = N, j = ans; i >= 1; --i)
		AT[i - 1] = g[i][j][1] | 48,
		j = g[i][j][0];
	return f[N][ans];
}

int main() {
	scanf("%d%d", &N, &M);
	scanf("%s", T);
	for (int i = 1; i <= M; ++i) {
		f64 v;
		scanf("%s%lf", str, &v);
		Insert(str, log(v));
	}
	BuildAC();
	f64 l = 0, r = log(1e9 + 5), mid, ans = 0;
	while (r - l > eps) {
		mid = (l + r) / 2;
		if (DP(mid) > 0) ans = mid, l = mid;
		else r = mid;
	}
	DP(ans);
	printf("%s\n", AT);
	return 0;
}
```

---

## 作者：81179332_ (赞：11)

由题意可知，若最后的字符串中包含的集合为 $S=\{ \{s_i,v_i\}\}$，则 $ans=\sqrt[|S|]{\prod \limits_{i=1}^{|S|}v_i}$

$\prod \limits_{i=1}^{|S|}$ 是个高精度，没法搞

看过题解后发现，我们可以两边取 $\ln$，则 $\ln ans=\dfrac1{|S|}\sum\limits_{i=1}^{|S|}\ln v_i$

这是一个经典的 0/1 分数规划问题，我们二分一个答案 $mid$

$$\dfrac1{|S|}\sum\limits_{i=1}^{|S|}\ln v_i>mid$$

$$\sum\limits_{i=1}^{|S|}\ln v_i>|S|\cdot mid$$

$$\sum\limits_{i=1}^{|S|}(\ln v_i-mid)>0$$

然后在 AC 自动机上跑 dp 即可，注意记录每个状态是从哪个状态转移来的、从哪个字母转移来的，来输出方案。

```cpp
const int N = 2000;
int n,m;char ch[N],ans[N];
double f[N][N];int g[N][N][2];
struct AC
{
	struct tree
	{
		int ch[10],fail;
		int& operator [](int x) { return ch[x]; }
	}t[N];int cnt;
	int sum[N];double val[N];
	void insert(char *s,double v)
	{
		int now = 0;
		for(int i = 1;s[i];i++)
		{
			if(!t[now][s[i] - '0']) t[now][s[i] - '0'] = ++cnt;
			now = t[now][s[i] - '0'];
		}sum[now]++,val[now] += v;
	}
	int q[N],head,tail;
	void get_fail()
	{
		head = 1,tail = 0;
		for(int i = 0;i < 10;i++) if(t[0][i]) q[++tail] = t[0][i];
		while(head <= tail)
		{
			int u = q[head++];
			sum[u] += sum[t[u].fail],val[u] += val[t[u].fail];
			for(int i = 0;i < 10;i++)
				if(t[u][i]) t[t[u][i]].fail = t[t[u].fail][i],q[++tail] = t[u][i];
				else t[u][i] = t[t[u].fail][i];
		}
	}
	double DP(double v)
	{
		for(int i = 0;i <= cnt;i++) val[i] -= sum[i] * v;
		for(int i = 0;i <= n;i++) for(int j = 0;j <= cnt;j++) f[i][j] = -1e100;
		f[0][0] = 0;
		for(int i = 0;i < n;i++) for(int j = 0;j <= cnt;j++) if(f[i][j] > -1e99)
			for(int k = 0;k < 10;k++) if(ch[i] == '.' || ch[i] == k + '0')
			{
				int c = t[j][k];
				if(f[i + 1][c] < f[i][j] + val[c])
				{
					f[i + 1][c] = f[i][j] + val[c];
					g[i + 1][c][0] = j,g[i + 1][c][1] = k;
				}
			}

		for(int i = 0;i <= cnt;i++) val[i] += sum[i] * v;
		int pos = 0;
		for(int i = 1;i <= cnt;i++) if(f[n][i] > f[n][pos]) pos = i;
		for(int i = n,now = pos;i;i--)
			ans[i] = g[i][now][1] + '0',now = g[i][now][0];
		return f[n][pos];
	}
}T;
int main()
{
	n = read(),m = read();scanf("%s",ch);
	for(int i = 1;i <= m;i++)
	{
		static char s[N];
		scanf("%s",s + 1);
		T.insert(s,log(read()));
	}T.get_fail();
	double l = 0,r = log(INF),res = 0;
	while(r - l > eps)
	{
		double mid = (l + r) / 2.0;
		if(T.DP(mid) > 0) res = mid,l = mid;
		else r = mid;
	}T.DP(res);
	printf("%s",ans + 1);
}

```

---

## 作者：Oxide (赞：8)

# $\text{Description}$

[传送门](https://www.luogu.com.cn/problem/P5319)

# $\text{Solution}$

发现有 $ans=\sqrt[c]{\prod_{i=1}^c v_i}$。不过显然这个东西直接算出来会爆。



有一个操作就是同时取对数。就有：


$$
\ln ans=\ln\left(\sqrt[c]{\prod_{i=1}^c v_i}\right )
$$



$$
\ln ans=\frac{1}{c} \ln\left(\prod_{i=1}^c v_i\right )
$$

$$
\ln ans=\frac{1}{c} \sum_{i=1}^c \ln v_i
$$




因为 $e>1$，$\ln(x)$ 是单增的，所以就是求 $\frac{1}{c} \sum_{i=1}^c \ln v_i$ 的最大值。观察柿子，有一个未知的求和柿子和与之相配的系数。想到了什么？$0/1$ 分数规划！



所以二分答案 $mid$，若有：


$$
mid<\frac{1}{c} \sum_{i=1}^c \ln v_i
$$

$$
c\cdot mid<\sum_{i=1}^c \ln v_i
$$

$$
\sum_{i=1}^c \left(\ln v_i-mid\right)>0
$$


我们可以对于每个 $mid$，求出 $\sum_{i=1}^c \left(\ln v_i-mid\right)$ 的最大值（这里的所有 $v$ 显然是自己选定）。如果满足最大值 $>0$，说明 $mid$ 还可以取到更大（带回原来的柿子看）。



对于求出 $\sum_{i=1}^c \left(\ln v_i-mid\right)$ 的最大值，显然就是将单个咒语权值减 $mid$，用 $\text{AC}$ 自动姬统计某个后缀出现的权值（这个后缀可能包含很多咒语），然后大力 $\text{DP}$。



设 $f[i][j]$ 为到神杖的第 $i$ 位，在 $\text{AC}$ 自动姬上的节点 $j$ 的最大值。（如果不是很懂为什么要取节点 $0$，可以看看[我的这篇博客](https://www.cnblogs.com/AWhiteWall/p/14123750.html)）



就有：


$$
f_{i+1,son_{j,k}}=\max\{f_{i,j}+val_{son_{j,k}},f_{i+1,son_{j,k}}\}
$$


$son_{j,k}$ 就是本轮添加字符 $k$ 对应的节点。





# $\text{Code}$

```cpp
#include <cstdio>

#define rep(i,_l,_r) for(register signed i=(_l),_end=(_r);i<=_end;++i)
#define fep(i,_l,_r) for(register signed i=(_l),_end=(_r);i>=_end;--i)
#define erep(i,u) for(signed i=head[u],v=to[i];i;i=nxt[i],v=to[i])
#define efep(i,u) for(signed i=Head[u],v=to[i];i;i=nxt[i],v=to[i])
#define print(x,y) write(x),putchar(y)

template <class T> inline T read(const T sample) {
    T x=0; int f=1; char s;
    while((s=getchar())>'9'||s<'0') if(s=='-') f=-1;
    while(s>='0'&&s<='9') x=(x<<1)+(x<<3)+(s^48),s=getchar();
    return x*f;
}
template <class T> inline void write(const T x) {
    if(x<0) return (void) (putchar('-'),write(-x));
    if(x>9) write(x/10);
    putchar(x%10^48);
}
template <class T> inline T Max(const T x,const T y) {if(x>y) return x; return y;}
template <class T> inline T Min(const T x,const T y) {if(x<y) return x; return y;}
template <class T> inline T fab(const T x) {return x>0?x:-x;}
template <class T> inline T gcd(const T x,const T y) {return y?gcd(y,x%y):x;}
template <class T> inline T lcm(const T x,const T y) {return x/gcd(x,y)*y;}
template <class T> inline T Swap(T &x,T &y) {x^=y^=x^=y;}

#include <cmath>
#include <queue>
#include <cstring>
using namespace std;

const int maxn=1505;
const double eps=1e-6,inf=1e11;

int n,m,Value,t[maxn][12],tot,num[maxn],f[maxn],memo[maxn][maxn][2];
char s[maxn],ori[maxn],ans[maxn];
double val[maxn],dp[maxn][maxn];
queue <int> q;

void Insert() {
	int p=0,len=strlen(s+1);
	rep(i,1,len) {
		int d=s[i]-'0';
		if(!t[p][d]) t[p][d]=++tot;
		p=t[p][d]; 
	}
	++num[p],val[p]+=log2(Value);
}

void GetFail() {
	rep(i,0,9) if(t[0][i]) q.push(t[0][i]);
	while(!q.empty()) {
		int u=q.front(); q.pop();
		val[u]+=val[f[u]],num[u]+=num[f[u]];
		rep(i,0,9)
			if(t[u][i]) f[t[u][i]]=t[f[u]][i],q.push(t[u][i]);
			else t[u][i]=t[f[u]][i];
	}
}

bool ok(double x) {
	rep(i,0,tot) val[i]-=x*num[i];
	rep(i,0,n) rep(j,0,tot) dp[i][j]=-inf;
	dp[0][0]=0;
	rep(i,0,n-1) rep(j,0,tot) rep(k,0,9)
		if(ori[i+1]=='.'||ori[i+1]==k+'0') {
			if(dp[i+1][t[j][k]]<dp[i][j]+val[t[j][k]]) {
				dp[i+1][t[j][k]]=dp[i][j]+val[t[j][k]];
				memo[i+1][t[j][k]][0]=j,memo[i+1][t[j][k]][1]=k;
			}
		}
	rep(i,0,tot) val[i]+=x*num[i];
	int pos=0;
	rep(i,1,tot) if(dp[n][i]>dp[n][pos]) pos=i; // 找匹配 n 位后值最大
	if(dp[n][pos]>0) {
		for(int i=n,now=pos;i>=1;now=memo[i][now][0],--i) ans[i]=memo[i][now][1]+'0';
		return 1;
	}
	return 0;
} 

int main() {
	n=read(9),m=read(9),scanf("%s",ori+1);
	rep(i,1,m) scanf("%s",s+1),Value=read(9),Insert();
	GetFail();
	double l=0,r=log2(1e9+7),mid; // 因为 V_i<=1e9，所以其集合平均数也在这个范围
	while(r-l>eps) {
		mid=(l+r)/2;
		if(ok(mid)) l=mid;
		else r=mid;
	}
	ok(l); puts(ans+1);
	return 0;
}
```


---

## 作者：yzhang (赞：3)

[原题传送门](https://www.luogu.org/problemnew/show/P5319)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11221640.html)

题目让我们最大化$val=\sqrt[k]{\prod_{i=1}^k w_i}$，其中$k$是咒语的个数，$w_i$是第$i$个咒语的神力

看着根号和累乘不爽，我们两边同取$\ln$

$$\ln val=\frac{1}{k}\sum_{i=1}^k \ln w_i$$

易知当$\ln val$最大化时，$val$也最大化。所以我们将问题转化成了最大化$\frac{1}{k}\sum_{i=1}^k \ln w_i$，我们发现这是算数平均数。我们珂以通过二分答案找到它的最大值，问题就是二分答案如何check是否合法：


当$\frac{1}{k}\sum_{i=1}^k \ln w_i>mid$时才合法

即当$\sum_{i=1}^k(w_i-mid)>0$时才合法

我们先对所有咒语建AC自动机，在上面跑dp求出$\sum_{i=1}^k(w_i-mid)$的最大值，判断是否可行

具体dp：就像其他很多AC自动机上的dp一样，设$f[i][j]$表示神杖前$i$个字符，匹配到了AC自动机上$j$号节点，依照套路转移，~~就是不要忘了题目原有的限制~~

此算法精度误差较大，但本题还是珂以通过

```cpp
#include <bits/stdc++.h>
#define db double
#define N 1505
#define eps 1e-6
using namespace std;
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
int n,m;
char T[N],s[N],ans[N];
db V[N],val[N],f[N][N];
pair<int,int> pre[N][N];
struct node{
    int son[10],fail,cnt;
    db val;
}tr[N];
int tot=0;
inline void Insert(register char *s,register db v)
{
    int len=strlen(s+1),now=0;
    for(register int i=1;i<=len;++i)
    {
        if(!tr[now].son[s[i]-'0'])
            tr[now].son[s[i]-'0']=++tot;
        now=tr[now].son[s[i]-'0'];
    }
    ++tr[now].cnt,tr[now].val+=v;
}
inline void getfail()
{
    queue<int> q;
    for(register int i=0;i<10;++i)
        if(tr[0].son[i])
            q.push(tr[0].son[i]);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        tr[u].cnt+=tr[tr[u].fail].cnt;
        tr[u].val+=tr[tr[u].fail].val;
        for(register int i=0;i<10;++i)
        {
            if(tr[u].son[i])
            {
                tr[tr[u].son[i]].fail=tr[tr[u].fail].son[i];
                q.push(tr[u].son[i]);
            }
            else
                tr[u].son[i]=tr[tr[u].fail].son[i];
        }
    }
}
inline void updateans(register int i,register int j)
{
    if(!i)
        return;
    updateans(i-1,pre[i][j].first);
    ans[i]=pre[i][j].second+'0';
}
inline bool check(register db mid)
{
    memset(f,-0x3f,sizeof(f));
    db inf=-f[0][0];
    f[0][0]=0;
    for(register int i=1;i<=n;++i)
        for(register int j=0;j<=tot;++j)
        {
            if(fabs(f[i-1][j]+inf)<1)
                continue;
            if(T[i]=='.')
            {
                for(register int k=0;k<10;++k)
                {
                    int v=tr[j].son[k];
                    if(f[i-1][j]+tr[v].val-tr[v].cnt*mid>f[i][v])
                    {
                        f[i][v]=f[i-1][j]+tr[v].val-tr[v].cnt*mid;
                        pre[i][v]=make_pair(j,k);
                    }
                }
            }
            else
            {
                int k=T[i]-'0',v=tr[j].son[k];
                if(f[i-1][j]+tr[v].val-tr[v].cnt*mid>f[i][v])
                {
                    f[i][v]=f[i-1][j]+tr[v].val-tr[v].cnt*mid;
                    pre[i][v]=make_pair(j,k);
                }
            }
        }
    int pos=0;
    for(register int i=1;i<=tot;++i)
        if(f[n][i]>f[n][pos])
            pos=i;
    if(f[n][pos]>eps)
    {
        updateans(n,pos);
        return 1;
    }
    else
        return 0;
}
int main()
{
    n=read(),m=read();
    scanf("%s",T+1);
    db L=0,R=0;
    for(register int i=1;i<=m;++i)
    {
        scanf("%s",s+1);
        V[i]=log(read());
        R=max(R,V[i]);
        Insert(s,V[i]);
    }
    getfail();
    while(R-L>eps)
    {
        db mid=(L+R)/2.0;
        if(check(mid))
            L=mid;
        else
            R=mid;
    }
    for(register int i=1;i<=n;++i)
        putchar(ans[i]);
    return 0;
}
```

---

## 作者：lupengheyyds (赞：2)

一种不取对数的做法

## 题意

给定一个由字符`.`与数字`0~9`组成的母串，字符`.`处可以任意填入数字。

同时给出 $m$ 个由数字组成的小串，并伴随有一个权值，小串两两不同。

每次每个小串在母串中出现一次，便会给答案的多重集贡献小串的权值。

最终的答案为多重集的几何平均数，定义空集的几何平均数为 $1$。

请你求出一个合法母串使得答案最大。

## 题解

令多重集大小为 $c$ ，第 $i$ 个元素为 $v_i$ 则答案为 $\sqrt[c]{\prod_{i=1}^cw_i}$。

考虑二分答案，转计算为判定，也就是令：

$$
\begin{aligned}
&\sqrt[c]{\prod_{i=1}^cw_i}>mid\\
&\prod_{i=1}^cw_i>mid^c=\prod_{i=1}^cmid\\
&\prod_{i=1}^c\dfrac{w_i}{mid}>1\\
\end{aligned}
$$

所以我们只需要将每个权值除以 $mid$，直接 DP 求最大值，时间复杂度 $\mathcal O(ns\sum\log(\max V\epsilon^{-1}))$，这样做不需要太大的精度，开 $10^{-2}$ 就可以了。

## 注意

这里上式不能等于 $1$ 的，因为 $c=0$ 是也会被特判成 $1$ 但事实上这个答案不是通过上式得来的，而且说明上式的最大值不会大于 $1$ 所以理应将 $mid$ 减小。

并且最后为了防止最后构造出一个 $c=0$ 的解法，应该在 DP 时用一个数组记录每个状态下是否有匹配了的小串，优先更新从由匹配的状态转移。

本题卡常，可以在 DP 时用滚动数组优化。

---

## 作者：_ReClouds_ (赞：2)

[更好的阅读体验](https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5319%20BJOI2019%20%E5%A5%A5%E6%9C%AF%E7%A5%9E%E6%9D%96%20%E9%A2%98%E8%A7%A3.html)

### 题意

给定一个长为 $n$ 的字符串 $S$，其每一位为数字 $0\sim 9$ 或一个 $.$ 符号，后者表示该位可以为任何数字。

再给定 $m$ 个字符串 $T_i$，每个字符串有其对应的权值 $V_i$。

初始时有变量 $\mathcal{Magic} = 1, \mathcal{Count} = 0$。

每当 $T_i$ 在 $S$ 中出现一次（即不同位置出现算作多次），我们就将 $\mathcal{Magic}$ 乘上 $V_i$ ，将 $\mathcal{Count}$ 加 $1$。

最终的答案为 $\mathcal{Answer} = \sqrt[\mathcal{Count}]{\mathcal{Magic}}$。

要求找到一种填充字符串 $.$ 位置的方案，使得 $\mathcal{Answer}$ 最大，输出任意一种最终字符串即可。

$\mathcal{Data~Range}: 1 \le n, m \le 1501, 1 \le V_i \le 10^9, 1 \le \displaystyle{\sum_{i = 1}^m} |T_i| \le 1501$

------

### 题解

~~（你真的会高精度开任意次方根吗？）~~

所以这题显然不能直接做。

和乘积有关的题目，一个好的思路是化乘为加。所以我们把每个 $V_i$ 求 $\ln$，就可以把 $\mathcal{Magic}$ 由求积转化为求和了，并且这样的转化并不会影响答案之间的大小关系。

而 $\mathcal{Count}$ 次方根这个部分，可以发现它直接变成了 $\displaystyle \frac{1}{\mathcal{Count}}$，所以原式就化为了 $\displaystyle \frac{\mathcal{Magic}}{\mathcal{Count}}$。

我们再重新审视一遍 $\mathcal{Magic}$ 和 $\mathcal{Count}$：每次当前者加上一个 $V_i$ 时，后者就会伴随着加上一个 $1$，而又因为两者的贡献是呈分数形式的，所以算法的大致轮廓大致就出来了 —— $0/1$ 分数规划。

我们知道，$0/1$ 分数规划关于 “解的存在性” 具有单调性。所以，我们可以考虑二分一个答案 $mid$，那么有：
$$
\begin{matrix}
\dfrac{\displaystyle{\sum_{i = 1}^{\mathcal{Count}} V_i}}{\mathcal{Count}} > mid
\\
\displaystyle{\sum_{i = 1}^{\mathcal{Count}}} V_i > {\mathcal{Count}} * mid
\\
\displaystyle{\sum_{i = 1}^{\mathcal{Count}}} (V_i - mid) > 0
\end{matrix}
$$

（注意到大于号 $>$ 了吗？这里并非大于等于号 $\ge$，因为当贡献最大值为 $0$ 时，二分到的 $mid$ 并非一个可行答案。当然，也会存在 $\mathcal{Answer}$ 为 $0$ 的情况，此时任意一个合法的字符串均为答案。）

推导到这里，可以发现，只要给每一个权值减去一个 $mid$，那么这个式子的值和 $\mathcal{Count}$ 的具体值已经没有关系了。

剩下的部分，就是求出左侧式子的最大值，然后和 $0$ 比较了。

而我们要如何求这个最大值呢？可以发现它和普通的 $0/1$ 分数规划不太一样：每个位置是 $0$ 还是 $1$ 并不能自由决定。

我们再重新审视一遍这个问题：填充 $S$ 的所有 $.$ 字符，使得出现的所有 $T_i$ 的权值和最大。

这个问题显然涉及到了字符串的多模匹配问题，因此我们考虑用 $\operatorname{AC}$ 自动机来解决这个问题。

我们可以设状态 $f_{i, j}$，表示走到自动机的 $i$ 号节点，同时 $S$ 串已经填完第 $j$ 个字符的最大权值。

转移很简单，由于自动机具有优美的结构，因此我们仅需每次枚举下一个字符进行转移即可。

（注意由于我们需要输出最终字符串，因此转移时需要记录前驱状态和转移时枚举的字符。）

最后一个问题来了：如何处理自动机上每个点的贡献？

显然，对于一个点，如果它对应了一个 $T_i$，那么在 $\mathcal{Fail}$ 树中以它为根的子树都需要加上他的权值（因为都会匹配到这个串）。所以，对于每一个 $mid$，我们利用树上差分重构一遍自动机上每个点的贡献即可。

---

## 作者：行吟啸九州 (赞：2)

拿到这个题，不难有一个在$AC$自动机上做$dp$的思路。

本题$n,m,|S|$同阶，故讨论复杂度时都用$n$代替。

$dp[i][j][k]$代表dp进行到自动机上i这个点，做了$j$个字符的$dp$，其中有$k$个咒语的$Magic$最大值，复杂度O($n ^ 3$)。

不过这个做法，最大的问题就是$Magic$是一个高精度数，你要是用高精度来做的话，还得多一个$FFT$的复杂度，O($n ^ 4logn$)，沦为与爆搜同分。

我们考虑一下平常这种dp为什么不会有这个问题。

这个题需要高精度的原因，就在于我们以前遇见的是加，这个是乘，那如何把乘法转化成加法呢？

这个时候不难想到需要用到取$\log$，我们依旧刚才的思路，还是那么$dp$，此时估计能获得$80$分。但实际上因为还有字符集的$10$倍的常数，需要卡常能力。对于这种$dp$题，优秀的循环展开不难卡个几倍的常数。

对于正解，我们不难发现，其实我们刚才求的问题就是选几个数，使得他们的平均数最大。

对于求平均数的问题，我们可以直接二分这个平均数，以此转化成一个判定性问题。

具体的实现你把所有咒语的权值取$\log$后都减去这个$mid$，然后做一遍$dp$，看是否答案$>0$，然后过程中记录一下转移过程，最后输出转移路径即可。

过程需要用$double$，复杂度是O($n ^ 2logn$)，实际上估计会跑得比较慢，需要一定的卡常，比如一些点不用跑就不跑，循环展开一下。

开始的时候，我一直感觉这个优化思路和某种我学过的算法有相似之处，看到粉兔的题解才想到是$01$分数规划，$orz$一波。

---

## 作者：Orion545 (赞：1)

### 广告

### [蒟蒻的blog](https://www.cnblogs.com/dedicatus545/p/10876324.html)

# 思路

首先，看到这个乘起来开根号的形式，应该能想到用取$\log$的方式做一个转化：

$\sqrt[n]{\prod_i a_i}=\frac{1}{n}\sum_i \log_b a_i$

这里我们把$b$取到$e$，就是$\ln a_i$了，不过实际上$b$取什么都没有问题

那么，这个问题就转化为了求所有匹配的宝石序列的最大平均值

**遇到这种多模式串、单模板串的情况，应当第一时间想到AC自动机**

我们建立模式串的AC自动机，并在上面跑dp即可完成题目的求解

建立AC自动机的时候，注意每个节点需要继承$fail$树上所有祖先的信息！

**遇到这种有对选取的元素求平均值的最值的情况，应当第一时间想到0-1分数规划**

我们二分最大平均值的答案，设当前为$C$

那么若有一组匹配方式能达到这个$C$，或以上，则有：

$\frac{1}{siz}\sum_{i=1}^{siz}w_i\geq C$

$\sum_{i=1}^{siz}w_i\geq C\ast siz$

$\sum_{i=1}^{siz}(w_i-C)\geq 0$

所以我们把每一个取过$\log$的元素减去当前二分的$C$，在AC自动机上跑dp

这样的好处是**避免了需要在dp中维护已匹配元素个数的一个维度**，可以优化一个$n$的时间复杂度

建立AC自动机后，设$dp[i][u]$表示当前遍历完成了模板串的前$i$个字符，匹配指针位置在AC自动机节点$u$上的情况时的最大值。

若模板串的下一个字符是确定的，就直接走到对应的儿子即可

否则需要更新每一个$dp[i+1][son_u]$的值

详细的更新方式见代码

**算法总复杂度：$O(ns\frac{max_i{\ln V_i}}{eps})$**,eps建议选取1e-6或更小

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cassert>
#include<queue>
#include<cmath>
#define ll long long
using namespace std;
inline int read(){
	int re=0,flag=1;char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
int n,m;double w[1510];
char a[1510],s[1510][1510];
int ch[1510][10],cntn=0,num[1510],fail[1510];
double sum[1510];
//AC Automaton
inline void insert(int x,int len){
	int i,cur=0,tmp;
	for(i=1;i<=len;i++){
		tmp=s[x][i]-'0';
		if(!ch[cur][tmp]) ch[cur][tmp]=++cntn;
		cur=ch[cur][tmp];
	}
	num[cur]++;sum[cur]+=w[x];
}
queue<int>q;
inline void build(){
	int i,u,v;
	for(i=0;i<10;i++){
		if(!ch[0][i]) continue;
		q.push(ch[0][i]);fail[ch[0][i]]=0;
	}
	while(!q.empty()){
		u=q.front();q.pop();
		num[u]+=num[fail[u]];
		sum[u]+=sum[fail[u]];
		for(i=0;i<10;i++){
			v=ch[u][i];
			if(v) fail[v]=ch[fail[u]][i],q.push(v);
			else ch[u][i]=ch[fail[u]][i];
		}
	}
}
//Dynamic Programming
double dp[1510][1510];
int from[1510][1510][2],endpos;
inline bool check(double mid){
	int i,j,k,son;
	for(i=0;i<=n;i++) for(j=0;j<=cntn;j++) dp[i][j]=-2e20;
	for(i=0;i<=cntn;i++){
		sum[i]-=mid*(double)num[i];//cut the value according to binary search process
	}
	dp[0][0]=0;
	for(i=1;i<=n;i++){
		for(j=0;j<=cntn;j++){
			if(dp[i-1][j]==-2e20) continue;
			if(a[i]!='.'){//character is fixed in original S
				son=ch[j][a[i]-'0'];
				if(dp[i][son]<dp[i-1][j]+sum[son]){
					dp[i][son]=dp[i-1][j]+sum[son];
					from[i][son][0]=j;//record the source of the maximum value
					from[i][son][1]=a[i]-'0';//record the corresponding character
				}
			}
			else{//character is unfixed
				for(k=0;k<10;k++){
					son=ch[j][k];
					if(dp[i][son]<dp[i-1][j]+sum[son]){
						dp[i][son]=dp[i-1][j]+sum[son];
						from[i][son][0]=j;
						from[i][son][1]=k;
					}
				}
			}
		}
	}
	int pos=0;
	for(i=1;i<=cntn;i++) if(dp[n][i]>dp[n][pos]) pos=i;
	for(i=0;i<=cntn;i++) sum[i]+=mid*(double)num[i];//repair the value cut
	endpos=pos;return dp[n][pos]>0;//determine if largest value is over zero
}
char re[1510];
int main(){
	n=read();m=read();int i;
	scanf("%s",a+1);
	for(i=1;i<=m;i++){
		scanf("%s",s[i]+1);
		w[i]=read();
		w[i]=log((double)w[i]);
		insert(i,strlen(s[i]+1));
	}
	build();
	double l=0,r=log(1e9+7),mid,ans=0;
	while(r-l>1e-6){//binary search
		mid=(l+r)*0.5;
		if(check(mid)) ans=mid,l=mid;
		else r=mid;
	}
	check(ans);
	for(i=n;i>=1;i--){//get the answer string
		re[i]=from[i][endpos][1]+'0';
		endpos=from[i][endpos][0];
	}
	for(i=1;i<=n;i++) putchar(re[i]);
	putchar('\n');
}

```



---

## 作者：StudyingFather (赞：1)

原来的答案看起来并不好处理，我们考虑取个对数：

$$
\begin{aligned}
\ln \sqrt[c]{\prod_{i=1}^c w_i} &= \frac{1}{c} \ln \prod_{i=1}^c w_i\\
 &= \frac{\sum_{i=1}^c \ln w_i}{c}
\end{aligned}
$$

观察这个结果，发现它满足 0/1 分数规划的形式。

我们二分答案 $mid$，若 $mid$ 可行，则有 $\frac{\sum_{i=1}^c \ln w_i}{c} \gt 0$，即 $\sum_{i=1}^c \ln w_i -c \gt 0$。

又因为这个问题是一个和多模式串匹配相关的问题，考虑在 AC 自动机上跑动态规划求解。

设 $f(i,j)$ 表示当前匹配到第 $i$ 个字符（即 $i-1$ 之前的位置都已经匹配），当前处在 AC 自动机的 $j$ 号节点上时，$\sum_{i=1}^c \ln w_i -c$ 的最大值。

转移的时候枚举每个节点接的下一个数字即可转移。

因为本题要输出方案，需要记录每个状态的最优决策点。

```cpp
// Problem : P5319 [BJOI2019]奥术神杖
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P5319
// Memory Limit : 125 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cmath>
#include <iostream>
#include <string>
#include <queue>
using namespace std;
const double eqs=1e-6;
const int sigma=10;
string s[1505],t;
int n,m;
int tr[1505][sigma],fail[1505],cnt;
double val[1505];
int sum[1505];
double f[1505][1505];
char ans[1505];
pair<int,int> g[1505][1505];
void insert(string s,double x)
{
 int u=0;
 for(auto c:s)
 {
  if(!tr[u][c-'0'])
   tr[u][c-'0']=++cnt;
  u=tr[u][c-'0'];
 }
 sum[u]++,val[u]+=x;
}
void build()
{
 queue<int> q;
 for(int i=0;i<sigma;i++)
  if(tr[0][i])q.push(tr[0][i]);
 while(!q.empty())
 {
  int u=q.front();
  q.pop();
  sum[u]+=sum[fail[u]],val[u]+=val[fail[u]];
  for(int i=0;i<sigma;i++)
  {
   if(tr[u][i])
    fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);
   else
    tr[u][i]=tr[fail[u]][i];
  }
 }
}
bool check(double x)
{
 for(int i=0;i<=cnt;i++)
  val[i]-=x*sum[i];
 for(int i=0;i<=n;i++)
  for(int j=0;j<=cnt;j++)
   f[i][j]=-1e100;
 f[0][0]=0;
 for(int i=0;i<n;i++)
  for(int j=0;j<=cnt;j++)
   for(int k=0;k<sigma;k++)
    if(t[i]=='.'||t[i]==k+'0')
    {
     int v=tr[j][k];
     if(f[i][j]+val[v]>f[i+1][v])
     {
      f[i+1][v]=f[i][j]+val[v];
      g[i+1][v]=make_pair(j,k);
     }
    }
 double res=-1e100;
 int pos=0;
 for(int i=0;i<=cnt;i++)
 {
  if(f[n][i]>res)
   res=f[n][i],pos=i;
 }
 for(int i=n;i;i--)
 {
  ans[i-1]=g[i][pos].second+'0';
  pos=g[i][pos].first;
 }
 for(int i=0;i<=cnt;i++)
  val[i]+=x*sum[i];
 return res>0;
}
int main()
{
 cin>>n>>m;
 cin>>t;
 for(int i=1;i<=m;i++)
 {
  double v;
  cin>>s[i]>>v;
  insert(s[i],log(v));
 }
 build();
 double l=0,r=log(1e9);
 while(r-l>=eqs)
 {
  double mid=(l+r)/2;
  if(check(mid))l=mid;
  else r=mid;
 }
 check(l);
 cout<<ans<<endl;
 return 0;
}
```

---

## 作者：Great_Influence (赞：1)

我们要求的答案是 $\sqrt[c]{\prod_{i=1}^c V_i}$ 。

这个东西非常像平均数，因此我们对每个 $V_i$ 取 $\ln$ ，然后答案变成:

$$\frac{1}{c}\sum_{i=1}^c \ln V_i$$

这就很套路了。因为答案显然具有可二分性，因此我们二分答案 $C$ ，则如果实际答案比 $C$ 更大，则满足关系式:

$$\frac{1}{c}\sum_{i=1}^c \ln V_i\ge C$$

$$\sum_{i=1}^c \ln V_i\ge cC$$

$$\sum_{i=1}^c \ln V_i-C\ge 0$$

我们将每个小串的权值设为 $\ln V_i-C$ ，然后如果存在一个大串满足匹配上的所有小串权值之和大于 $0$ 则答案可以增大。

那么我们就只需要找到一个最大的串即可。大串匹配小串，明显可以在 $AC$ 自动机上面跑 $dp$ 。

注意 $dp$ 的时候至少要匹配上一个小串，因此再设一维 $0/1$ 表示是否匹配过小串即可。

时间复杂度 $O(ns\log \frac{\log V_{\max}}{eps})$ 。

代码:
```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<queue>
#include<iostream>
#include<climits>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
		if(nowps-Out>=1<<23)flush();
	}

	inline void getstr(char*q)
	{
		register char ch;
		for(ch=getc();!isgraph(ch);ch=getc());
		for(;isgraph(ch);ch=getc())*q++=ch;
		*q='\0';
	}

	inline void getwd(char&x){for(x=getc();!isupper(x);x=getc());}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void Chkmax(double&u,double v){u<v?u=v:0;}

inline void Chkmax(ll&u,ll v){u<v?u=v:0;}

inline void Chkmin(ll&u,ll v){u>v?u=v:0;}

const int MAXN=1511;

static int n,m;

static char Z[MAXN],K[MAXN];

vector<double>p[MAXN];

vector<int>ed[MAXN];

static double val[MAXN];

namespace ACauto
{
	static int son[MAXN][11],fail[MAXN],e;

	inline void insert(char*q,double w)
	{
		register int cr=0;
		for(;*q!='\0';++q)
		{
			int dr=*q-'0';
			if(!son[cr][dr])son[cr][dr]=++e;
			cr=son[cr][dr];
		}
		p[cr].pb(w);
	}

	queue<int>G;

	inline void build_fail()
	{
		Rep(i,0,9)if(son[0][i])G.push(son[0][i]);
		while(!G.empty())
		{
			int u=G.front();G.pop();
			ed[fail[u]].pb(u);
			Rep(i,0,9)if(son[u][i])
				fail[son[u][i]]=son[fail[u]][i],G.push(son[u][i]);
			else son[u][i]=son[fail[u]][i];
		}
	}
}
using ACauto::insert;
using ACauto::build_fail;
using ACauto::son;
using ACauto::e;

static double l,r;

inline void init()
{
	read(n),read(m);
	getstr(Z+1);
	static int w;
	Rep(i,1,m)
	{
		getstr(K),read(w);
		Chkmax(r,log(w));
		insert(K,log(w));
	}
}

static int vis[MAXN];

const double eps=1e-5;

void getvl(int cr,double wd,double sm)
{
	for(double z:p[cr])sm+=z-wd;
	if(sm>0)vis[cr]=1;
	val[cr]=sm;
	for(int v:ed[cr])getvl(v,wd,sm);
}

static double dp[MAXN][MAXN][2];

static int pre[MAXN][MAXN][2],hs[MAXN][MAXN][2];

static char vr[MAXN][MAXN][2];

inline void getdp(bool ty=0)
{
	Rep(i,0,n)Rep(j,0,e)Rep(l,0,1)dp[i][j][l]=-1e17;
	dp[0][0][0]=0;
	Rep(i,0,n-1)Rep(j,0,e)Rep(l,0,1)if(dp[i][j][l]>-1e4)
	{
		if(Z[i+1]=='.')Rep(k,0,9)
		{
			if(dp[i][j][l]+val[son[j][k]]>dp[i+1][son[j][k]][l|vis[son[j][k]]])
			{
				dp[i+1][son[j][k]][l|vis[son[j][k]]]=dp[i][j][l]+val[son[j][k]];
				if(ty)pre[i+1][son[j][k]][l|vis[son[j][k]]]=j
					,hs[i+1][son[j][k]][l|vis[son[j][k]]]=l
					,vr[i+1][son[j][k]][l|vis[son[j][k]]]=k^48;
			}
		}
		else
		{
			int k=Z[i+1]^48;
			if(dp[i][j][l]+val[son[j][k]]>dp[i+1][son[j][k]][l|vis[son[j][k]]])
			{
				dp[i+1][son[j][k]][l|vis[son[j][k]]]=dp[i][j][l]+val[son[j][k]];
				if(ty)pre[i+1][son[j][k]][l|vis[son[j][k]]]=j
					,hs[i+1][son[j][k]][l|vis[son[j][k]]]=l
					,vr[i+1][son[j][k]][l|vis[son[j][k]]]=k^48;
			}
		}
	}
}

inline bool Judge(double wd)
{
	getvl(0,wd,0);
	getdp();
	Rep(i,0,e)if(dp[n][i][1]>=0)return 1;
	return 0;
}

inline void getans(double wd)
{
	getvl(0,wd,0),getdp(1);
	static int ps=0,z=0;
	static double mx=-1e9;
	Rep(i,0,e)if(dp[n][i][1]>mx)mx=dp[n][i][1],ps=i,z=1;
	Repe(i,n,1)
	{
		Z[i]=vr[i][ps][z];
		int nxv=hs[i][ps][z];
		ps=pre[i][ps][z],z=nxv;
	}
}

inline void solve()
{
	build_fail();
	getvl(0,1e5,-1e4);
	while(r-l>eps)
	{
		double md=(l+r)/2;
		if(Judge(md))l=md;
		else r=md;
	}
	getans(l);
	puts(Z+1);
}

int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

一道简单题。

显然两边同时取对数。（我见过若干到道对数的题目，但是实际上做法的精度误差相当大，但是这是无奈之举。），转化为 $0/1$ 分数规划问题。

二分答案的时候，每个串的权值变成了 $val_s - \Delta$。很容易想到建立出每个串的 $\rm AC$ 自动机，在 $\rm AC$ 自动机上 $\rm DP$ 即可。

不过有一个小问题：实际上一个串都不出现，会得到 $0$。所以在 $\rm DP$ 的过程中，我们或者记录是否一个串都没有出现，或者选择一个极小量 $\epsilon$ 进行比较。

复杂度 $O(s \Sigma \log V)$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1600+10;
int n,m,v[MAXN],tot,cnt[MAXN],tr[MAXN][10],fail[MAXN];
double lgv[MAXN],sum[MAXN];
string T,S[MAXN];
void insert(string S,double v) {
	int u=0;
	for(auto ch:S) {
		if(!tr[u][ch-'0']) tr[u][ch-'0']=++tot;
		u=tr[u][ch-'0'];	
	}
	return sum[u]+=v,cnt[u]++,void();
}
void build(void) {
	queue<int> q;
	ffor(i,0,9) if(tr[0][i]) q.push(tr[0][i]);
	while(!q.empty()) {
		int u=q.front(); q.pop();
		sum[u]+=sum[fail[u]],cnt[u]+=cnt[fail[u]];
		ffor(i,0,9) if(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);
		else tr[u][i]=tr[fail[u]][i];
	}
	return ;
}
double dp[MAXN][2][MAXN];
short frm[MAXN][2][MAXN],opt[MAXN][2][MAXN];
bool psl[MAXN][2][MAXN];
int solve(double del) {
	ffor(i,0,n) ffor(j,0,tot) dp[i][0][j]=dp[i][1][j]=-1000000000000;	
	dp[0][0][0]=0;
	ffor(i,1,n) {
		ffor(lst,0,tot) ffor(ppp,0,1) {
			if(dp[i-1][ppp][lst]+10000000000<0) continue ;
			ffor(op,0,9) {
				if(T[i]!='.'&&op!=T[i]-'0') continue ;
				int to=tr[lst][op],tp=ppp;
				double getval=sum[to]-del*cnt[to];
				if(cnt[to]) tp=1;
				if(dp[i-1][ppp][lst]+getval>dp[i][tp][to]) dp[i][tp][to]=dp[i-1][ppp][lst]+getval,frm[i][tp][to]=lst,opt[i][tp][to]=op,psl[i][tp][to]=ppp;
			}
		}
	}
	return *max_element(dp[n][1],dp[n][1]+tot+1)>=-1e-10;
}	
double bfind(double l,double r) {
	while(r-l>=1e-10) {
		double mid=(l+r)/2.0;
		if(solve(mid)) l=mid;
		else r=mid;
	}
	return l;
}
void output(int dep,int st,int ooo) {
	if(dep==0) return ;
	output(dep-1,frm[dep][ooo][st],psl[dep][ooo][st]);
	cout<<opt[dep][ooo][st];	
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>T,T="&"+T;
	ffor(i,1,m) cin>>S[i]>>v[i],lgv[i]=log2((double)1.0*v[i]),insert(S[i],lgv[i]);
	build();
	double res=bfind(0,log2(1000000000.00));
	solve(res);
	double maxval=*max_element(dp[n][1],dp[n][1]+tot+1);
	ffor(i,0,tot) if(abs(dp[n][1][i]-maxval)<=1e-10) {
		output(n,i,1);
		return 0;	
	}
	return 0;
}
```

常数好像有点大。

---

## 作者：Piggy343288 (赞：0)

几何平均值，我吐了。  

如何把几何平均值搞掉？重点是如何把指数搬下来，那么我们所学的运算中，对数就有这一特殊性质。所以考虑 $\ln ans\ge c\times mid$，每次二分时设权值为 $w_i=\ln v_i-mid$，这样只要在小串的 AC 自动机上跑 DP 看看答案能否 $\ge 0$ 就行了。  

接下来就是喜闻乐见的 $dp[i][j]$ 表示神杖的第 $i$ 位跑到了节点 $j$ 的方案数，是熟知的 DP 方式。

---

## 作者：未来姚班zyl (赞：0)

## 题目大意
给定一个字符串 $T$，其中有些位置上是通配符。同时给定 $m$ 个字符串 $S_i$，每个字符串有个权值 $V_i$。现在你需要为这些通配符填上字母，最大化：

$\sqrt[t]{\prod{V_i^{c_i}}}$。

其中，$c_i$ 表示 $S_i$ 在最终的字符串中出现的次数，$t=\sum c_i$。

## 题目分析

这个值简直无法快速求出，但它又是乘又是开方，而且只用比大小，这无非是把对数怼到了我们的脸上。

所以我们对其取个对数，式子很容易变成 $\frac{\sum c_iV_i}{t}$。

这样我们就很容易想出一个动态规划的设计。

建立出 $S_i$ 的 AC 自动机，然后在上面跑 dp。

观察到，化简后的式子就是在取算术平均值。朴素的 dp 需要记录取的数的个数，复杂度无法接受。但如果平均数确定，则每个数减去平均数，就能巧妙的消除个数的影响。而这题显然可以二分答案再跑 dp，复杂度 $O(Σns\log V)$。~~精度随缘。~~ 记得记录一下从哪转移来的！

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned int 
inline ll read(){ll s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1.5e3+5,M=1e6+5,inf=2147000000;
const ll llf=1e18;
const double eps=1e-6,dof=1e9;
using namespace std;
int n,m,cnt;double a[N];
string t;
string s;
string ans;
struct node{
	int son[10],fail;
	double k;
	int siz;
}trie[N];
inline void insert(string s,int id){
	int len=s.length(),now=0;
	rep(i,0,len-1){
		int k=s[i]-'0';
		if(!trie[now].son[k])trie[now].son[k]=++cnt;
		now=trie[now].son[k];
	}
	trie[now].k+=a[id],trie[now].siz++;
}
inline void getfail(){
	queue<int>q;
	rep(i,0,9)if(trie[0].son[i])q.push(trie[0].son[i]);
	while(!q.empty()){
		int x=q.front();q.pop();
		trie[x].siz+=trie[trie[x].fail].siz;
		trie[x].k+=trie[trie[x].fail].k;
		rep(i,0,9)if(trie[x].son[i])trie[trie[x].son[i]].fail=trie[trie[x].fail].son[i],q.push(trie[x].son[i]);
		else trie[x].son[i]=trie[trie[x].fail].son[i];	
	}
}
double dp[N][N];//前 i 个在 AC自动机的j 位置 
int fr[N][N],ty[N][N];
inline bool check(double x){
	double del=x;
	rep(i,0,n)rep(j,0,cnt)dp[i][j]=-dof,fr[i][j]=ty[i][j]=-1;
	dp[0][0]=0;
	rep(i,1,n){
		int Ll=0,Rr=9;
		if(t[i-1]!='.')Ll=Rr=t[i-1]-'0';
		rep(x,0,cnt){
			if(dp[i-1][x]<=-dof)continue;
			rep(j,Ll,Rr){
				int y=trie[x].son[j];
				if(dp[i-1][x]+trie[y].k-(double)trie[y].siz*del>dp[i][y])dp[i][y]=dp[i-1][x]+trie[y].k-(double)trie[y].siz*del,fr[i][y]=x,ty[i][y]=j;
			}
		}
	}
	rep(i,0,cnt){
		if(dp[n][i]>eps){
			int now=i;
			per(j,n,1){
				ans[j-1]=ty[j][now]+'0';
				now=fr[j][now];
			}
			return 1;
		}
	}
	return 0;
}
string out;
int main(){
	n=read(),m=read();
	cin >>t;ans=t;
	double l=0,r=0;
	rep(i,1,m)cin >>s,a[i]=log(read()),r=max(r,a[i]),insert(s,i); 
	getfail();
	rep(o,0,40){
		double Mid=(l+r)*0.5;
		if(check(Mid))l=Mid,out=ans;
		else r=Mid;
	}
	cout <<out;
	return 0;
}
```


---

## 作者：KokiNiwa (赞：0)

# [BJOI 2019]奥术神杖

[题目链接](https://loj.ac/problem/3089)

挺套路的一道题。

## 题目叙述

给你一个大字符串，其中有数字和字符"."，"."处可以填任意数字。有$n$个小字符串，每个小字符串有一个价值，设一共匹配了$c$个小字符串（不同位置匹配，或者不同字符串匹配都算不同的匹配），每个匹配上的小字符串的价值为$v_i$。那么大字符串的价值为$\Pi_{i=1}^cv_i$开$c$次更好。构造一个大字符串，使得价值最大，求这个字符串。

## 题解

首先看到乘积形式，我们可以想到通过两边同时取$log$的形式变成了几个数相加的形式。然后可以发现这就变成了一个$01$分数规划的问题，即匹配到一个字符串就会获得一定的价值，求平均价值最高。二分平均价值，然后在```AC```自动机上$dp$即可（具体就是匹配一个字符串得到一定价值，求最大价值）。

## 代码

[code](https://loj.ac/submission/728103)

**注意该用double的用double！！！另外有小数据就开始调试，不要瞪着代码看！因为调试实际上没有那么麻烦。**

## 知识点
+ 如果是出现乘积形式的 $Ans$=$c$次根号下${\sqrt{\Pi_{i=1}^na_i}}$，我们可以两边同时取对数，得到$ln\ Ans=\frac{1}{c}\sum_{i=1}^cln\ a_i$。可以化为形式$\sum_{i=1}^c ln\ a_i-ln\ Ans$。
+ 记住这次这个$ac$自动机上$dp$的简单模型（其实记不记无所谓）。
+ 注意当前这个节点的状态包含的其他状态（就是$fail$指针所指向的）。

---


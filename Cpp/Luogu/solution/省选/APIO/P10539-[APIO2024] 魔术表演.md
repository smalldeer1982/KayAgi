# [APIO2024] 魔术表演

## 题目背景

在洛谷上提交时，只需要提交一个文件。

不要引入 `alice.h` 和 `bob.h`。在文件头加入以下内容：

```cpp
long long setN(int n);
```

只支持 C++17 / C++20 提交。

## 题目描述

Alice 和 Bob 是著名的魔术师。Catherine 是一位富豪，她非常喜欢观看 Alice 和 Bob 的魔术。某一天，Catherine 决定向 Alice 和 Bob 发出挑战：只要他们能成功表演如下的魔术，Catherine 就将向他们提供巨额奖金！这个魔术的表演过程如下：

- 步骤 $1$：Bob 进⼊⼀个密室中，在魔术的全程中，他只能与 Catherine 交流。接下来，Alice 告诉 Catherine ⼀个在 $2$ 到 $5000$ 之间的整数 $n$。
- 步骤 $2$：Catherine 告诉 Alice ⼀个在 $1$ 到 $10^{18}$ 之间的整数 $X$。
- 步骤 $3$：Alice 生成⼀个具有 $n$ 个节点的树，并告诉 Catherine。
- 步骤 $4$：Catherine 删除树中的⼀些边（至多 $\left\lfloor\dfrac{n-2}{2}\right\rfloor$ 条），并将剩余的边告诉 Bob。
- 步骤 $5$：Bob 根据 Catherine 给出的信息，猜出 Catherine 告诉 Alice 的数是多少。

然⽽，Alice 和 Bob 被这个魔术难倒了，于是他们不得不寻求你的帮助。请你写一段程序，实现 Alice 和 Bob 的策略，以帮助他们赢得 Catherine 的挑战。

通信方式：

你需要实现两个函数

1. `std::vector<std::pair<int, int>> Alice();`
- 对于每组测试数据，这个函数只会被调用⼀次。
- 函数应当返回⼀个含有 `pair<int, int>` 类型的 `vector`，表示 Alice 在魔术的步骤 3 中生成的树的边集。
  - 注意树中的节点应当从 1 开始编号。
  - 你需要确保函数返回的树是符合规范的，也就是说，树中应当恰好包含 n − 1 条边，且所有节点彼此连通。
  
函数 `Alice()` 应当调用如下函数**恰好⼀次**：

`long long setN(int n);`

- 这个函数表示，在魔术的步骤 1 中，Alice 选择⼀个数 $n$ 告诉 Catherine。
- 函数返回⼀个数 $X$，表示 Catherine 在魔术的步骤 2 中告诉 Alice 的数。
---
2. `long long Bob(std::vector<std::pair<int, int>> V);`

- 对于每组测试数据，这个函数只会被调用⼀次，且⼀定是在调用 `Alice()` 之后。
- $V$ 表⽰在魔术的步骤 4 中，Catherine 告诉 Bob 的边集。
- 上述边集是有序的，具体而言：
  - 对于⼀条边的两个端点而言，编号较⼩的端点靠前；
  - 所有的边按照第⼀个端点为第⼀关键字、第⼆个端点为第⼆关键字的顺序升序排序。
- 函数应当返回⼀个整数 $X$，表⽰ Bob 在魔术的步骤 5 中给出的回答。

## 说明/提示

### 例子

考虑下面的调用：
调用函数| 返回值
:-:|:-:
`Alice()`|
`setN(4)`| $3$
||$\{\{1, 2\}, \{2, 3\}, \{2, 4\}\}$
`Bob({{1,2},{2,4}})`| $3$
该样例代表了以下场景：
- 步骤 1：最开始，Alice 将数字 $4$ 告诉 Catherine。
- 步骤 2：Catherine 将数字 $3$ 告诉 Alice。
- 步骤 3：Alice 生成了⼀棵具有 $4$ 个节点的树，其边集为 $\{\{1, 2\}, \{2, 3\}, \{2, 4\}\}$，将这棵树告诉 Catherine。
- 步骤 4：Catherine 删去了树中连接节点 $2$ 和 $3$ 的边，并把剩余的边 $\{\{1, 2\}, \{2, 4\}\}$ 告诉 Bob。
- 步骤 5：Bob 给出数字 $3$ 作为回答。由于他给出了正确答案，他们的魔术表演⼤获成功。


### 子任务

1. (5 分)：$X\leq 5, 000$。
2. (30 分)：$X\leq25, 000, 000$。
3. (65 分)：没有特殊限制。


# 题解

## 作者：Milmon (赞：18)

这里讲一下赛时 20 分钟想到的垃圾做法。

对于 Alice，我们充分发扬人类智慧，考虑对任意 $2 \leq v \leq n$，都让 $X \bmod (v-1) + 1$ 向 $v$ 连边。

对于 Bob 只需把所有边的信息都用数论知识合并起来即可得出 $x$ 的值。

事实上，本题不需要 excrt，因为 $n$ 只有 $5000$。暴力枚举（假设已知答案模 $p$ 余 $q$，就每次把 $q$ 加上 $p$ 直到满足下一个同余条件）时间复杂度 $O(n^2)$，可以通过。并且取 $n=75$ 时可以通过赛时评测，峰值运行时间 $0$ 毫秒。

事实上，在交互库足够强的情况下，$n=75$ 无法保证一定得出正确答案，具体说明见文章结尾处。（事实上，也可以随机一个置换或者对 $X$ 随机异或一个数使得这个做法不容易被卡，但是我们追求完全确定性做法。）

```cpp
#include<bits/stdc++.h>
#include"Alice.h"
using namespace std;
const int N=5000;

vector<pair<int,int>> Alice(){
    long long x=setN(N);
    vector<pair<int,int>> edges;
    for(int i=2;i<=N;i++)
        edges.emplace_back(x%(i-1)+1,i);
    return edges;
}
```

```cpp
#include<bits/stdc++.h>
#include"Bob.h"
using namespace std;

long long Bob(vector<pair<int,int>> edges){
    __int128 answer=0,nowmod=1;
    for(pair<int,int> edge :edges){
        int r=edge.first-1,mod=edge.second-1;
        while(answer%mod!=r)answer+=nowmod;
        nowmod*=mod/__gcd(nowmod,(__int128)mod);
        if(nowmod>1e18)return answer;
    }
    return answer;
}
```

---

考虑优化，容易发现在最初的做法中，一些素数只要删除一次或者两次就无法对答案造成贡献，这样会产生大量的信息浪费，所以考虑构造 $a_i < i$，然后对于任意 $2 \leq v \leq n$，令 $X \bmod (a_v-1) + 1$ 向 $v$ 连边。（一开始想到了这么优化，结果因为脑子问题一直以为这么改是变劣的，直到 lhx 大神指点这样居然变优了。）

如果令 $a$ 中每个数为素数的幂，那么可以用暴力搜索和动态规划找出一个较优秀的解。在数列 $a$ 的细节继续优化，目前可以构造出数列 $a$ 使得只需要 $n = 99$ 个结点保证确定性。（之前的 $n=95$ 是错的）

```plain
1 2 3 4 5 5 7 7 9 9 11 11 11 13 13 13 16 17 17 17 19 19 19 23 23 23 25 25 27 29 29 29 29 31 31 31 31 32 37 37 37 37 41 41 41 41 43 43 43 43 47 47 47 47 49 49 53 53 53 53 59 59 59 59 61 61 61 61 64 67 67 67 67 71 71 71 71 71 73 73 73 73 79 79 79 79 83 83 83 83 83 89 89 89 89 79 97 97
```

直觉上 $n$ 可以再小，不知道能不能通过数学证明得出理论最小的 $n$，可是我太菜了。

---

附：最简易的数论做法需要 $n=615$ 可以保证通过：

- $n=614$ 时，取 $X=897,612,484,786,617,601=2^8 \times 3^4 \times 5^2 \times 7^2 \times 11 \times 13 \times 17 \times 19 \times 23 \times 29 \times 31 \times 37 + 1$，只有 $308$ 条边不可以保证得出正确答案。
- $n=615$ 时可以证明一定可以得出正确答案。

---

## 作者：_Ch1F4N_ (赞：8)

考虑对 $x$ 二进制拆位。

我们用 $80$ 个点来维护二进制下每一位，假若交互器随机删点那么这一位彻底丢失的概率只有 $2^{-80}$ 即使需要 $60$ 位都正确也是很轻松的。问题是如何用点维护 $0,1$ 信息？

考虑对于点 $u$ 随机两个父亲 $fa_{u,0/1} < u$ 由于编号都比自己小，故一定构成树，那么当其维护的位信息是 $0$ 时将父亲设置为 $fa_{u,0}$ 否则为 $fa_{u,1}$，由于这两个值都是随机的所以树的形态实际上也是随机的。

然后你发现交互库可能使用特殊策略删边，没关系，随机一个置换并将边的端点编号置换掉，那么相当于构造出来的树编号随机且形态随机，每条边代表哪一位的信息也是随机，交互库删点过程也等价于随机。

注意到将底数更换为 $k$ 也就是使用 $k$ 进制拆位也是可行的，并且应该能得到更低的所需点数。

记得将不同位的信息均匀地放在原序列中以及随机置换打乱树的编号。

事情到这里应该结束了。

但是发生了神秘的事件。

有好心人发现我的代码更换种子后会爆炸。

并且并不是因为丢失信息，因为答案变大了而我的写法中丢失了信息答案会减少。

这个时候 milmon 老师说：

![](https://cdn.luogu.com.cn/upload/image_hosting/lmwi6dq4.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

（此处 $faA,faB$ 就是 $fa_{u,0},fa_{u,1}$）

![](https://cdn.luogu.com.cn/upload/image_hosting/hzn7q8to.png?x-oss-process=image/resize,m_lfit,h_680,w_900)

由于不是每一次都有这么好的运气，所以说要记得判重。

[参考代码](https://qoj.ac/submission/1011495)

---

## 作者：NOI_Winner (赞：6)

本文介绍的是一种不确定性做法，但它是一种在考场上能够容易想到且容易拿分的解法。

我们考虑依次处理 $X$ 的每一位。假设当前枚举到第 $i$ 位，我们分配 $2c$ 个节点给它，设它们分别为 $a_1,a_2,a_3,\cdots,a_c$ 和 $b_1,b_2,b_3,\cdots,b_c$。如果第 $i$ 位为 $1$，就将 $a_1$ 和 $b_1$ 连边，$a_2$ 和 $b_2$ 连边，以此类推。如果第 $i$ 位为 $0$，就不用处理。最后剩下的边随机连，但是要注意不能将编号相邻的两个节点连边。在 Bob 的程序中我们判断这 $c$ 对节点中是否存在一对有边相连的。如果有，那么这一位为 $1$，否则为 $0$。我们可以取 $c=40$。

由题意发现每条边被删除的概率不到 $\frac{1}{2}$，所以出错的概率很小。我们还可以生成完树后将点的编号加密（也就是重新排列），在 Bob 的程序开始时解密，进一步减小被卡的风险。

`Alice.cpp` 代码示例：
```cpp
#include "Alice.h"
#include <vector>
#include <random>
#include <ctime>

using namespace std;

using ll = long long;
constexpr int n = 4800;
int fa[n + 5];              // 并查集
mt19937 rnd(time(nullptr));

int get(int x)
{
    if (x == fa[x])
        return x;
    return fa[x] = get(fa[x]);
}

vector<pair<int, int>> Alice()
{
    ll x = setN(n);
    for (int i = 1; i <= n; i++)
        fa[i] = i;
    
    vector<pair<int, int>> ans;
    for (int bit = 0; bit < 60; bit++)
        if (x >> bit & 1)
            for (int i = 1; i <= 80; i += 2)
            {
                int x = bit * 80 + i, y = bit * 80 + i + 1;
                int fx = get(x), fy = get(y);
                fa[fx] = fy;
                ans.emplace_back(x, y);
            }

    while (ans.size() < n - 1)
    {
        int x, y;
        do
        {
            x = rnd() % n + 1;
            y = rnd() % n + 1;
            if (x > y)
                swap(x, y);
        } while (x == y || y == x + 1 || get(x) == get(y));
        fa[get(x)] = get(y);
        ans.emplace_back(x, y);
    }

    for (auto& [x, y] : ans)   // 加密
    {
        x = (x + 1736) % n + 1;
        y = (y + 1736) % n + 1;
    }
    return ans;
}
```

`Bob.cpp` 代码示例：
```cpp
#include "Bob.h"
#include <vector>
#include <utility>

using namespace std;

using ll = long long;
constexpr int n = 4800;
bool g[n + 5][n + 5];

ll Bob(vector<pair<int, int>> v)
{
    for (auto [x, y] : v)    // 解密
    {
        x = (x - 1 + n - 1737) % n + 1;
        y = (y - 1 + n - 1737) % n + 1;
        g[x][y] = g[y][x] = true;
    }

    ll ans = 0;
    for (int bit = 0; bit < 60; bit++)
    {
        bool flag = false;
        for (int i = 1; i <= 80; i += 2)
            if (g[bit * 80 + i][bit * 80 + i + 1])
            { flag = true; break; }
        if (flag)
            ans |= 1ll << bit;
    }
    return ans;
}
```

---

## 作者：vzcx_host (赞：6)

在看本题解之前，请确保你会做 P9165。

---

考虑设置一个质数 $P$，$1\sim P$ 内部随便连，$P+1\sim N$ 仅向 $1\sim P$ 连边，这相当于传入了一个长为 $N-P$ 的序列，值域为 $[0,P)$，其中有最多 $N/2$ 个数被删掉。

有点熟悉对吗，这里的限制远比 P9165 弱，直接套用那题的做法就好了。写个拉插可以轻松做到 $X=10^{1000}$ 的水准，足以卡爆大部分二进制拆分的做法。

---

## 作者：dxzier (赞：4)

（（使用基于运气的做法

首先读题容易发现，这道题目是让我们把数据编码成树，并在丢失一定数据的情况下还原出原本的数据。根据题目中给出的公式容易得到，丢失的数据至多为一半。

## $5$ pts

由于 $n,X \le 5 \times 10^3$，且 $n$ 是我们自己给出的。容易想到可以将每一个点都连向第 $X$ 号点，这意味着删除部分数据后除了 $X$ 号点，其余每个点至多连向一个点。接收到数据后只需要统计每个点所连向的点的数量，当发现有一个点连向了不止一个点时，这个点的编号就是答案。

（（菜菜 UP 赛场上就拿了这点分 QAQ

## $100$ pts

（（是的这道题部分分极度没有区分度

先不考虑数据丢失。首先我们可以把收到的数据进行二进制拆分，每一位对应树上的一个节点（可以在代码层面就打乱顺序）。初始时每个节点都连向前一个节点。如果此位为 $0$，则该点连向 $1$ 号节点。接收到数据后再根据此规则还原数据即可。

此时再考虑数据丢失，考虑最坏情况。对于一位数，它被修改的概率为 $\frac{n}{\lfloor \frac{n - 2}{2} \rfloor}$，在 $n$ 足够大的情况下可以取近似值 $\frac{1}{2}$。再考虑两位数的情况，设第一位被修改的事件为 A，第二位被修改的事件为 B，由容斥容易得到两位中有任意一位被修改或都被修改的概率为 $P(A) + P(B) - P(A \cap B)$。由于两事件相对独立，在 $n$ 较大的情况下影响不大，为简便计算可以取 $P(A) \times P(B)$，由此可以得到其值约为 $\frac{3}{4}$。根据容斥原理，我们可以得到如果传输 $m$ 位二进制数，它**未被修改**的概率大约仅有 $(1 - P(A))^m$，约为 $\frac{1}{2^m}$。对于题目中 $X$ 的取值范围，这一正确的概率几乎可以忽略。

考虑一些常见的数据纠错算法，比如重复传递多次。容易观察到上述构造方法中并不像常见数据纠错需求中会发生比特翻转，而**仅会由 1 变为 0**。根据此性质，只需要传递多次，只要其中有一次值为 $1$ 就判定此位为 $1$。我们可以设对于一位数据，它第一次传递时被修改的事件为 C，第二次为 D，当且仅当事件 C、D 同时发生时，才会出现错误，所以出错的概率为 $P(C \cap D)$。不妨设一共传输 $k$ 次，可以近似的得到对于此位**出错的概率**为 $P(A) = \frac{1}{2^k}$。再根据上方的公式可以得出，传递 $m$ 位二进制数据，每位重复传递 $k$ 次时，它**未被修改**的概率大约为 $(1 - \frac{1}{2^k})^m$。**注意由于删除边的最大数量一定，随着 $k \times m$ 逐渐接近 $n$，这一公式所得值与真实值的误差会逐渐增大**。

对于 $X \le 10^{18}$ 可以得到 $m = 60$ 即可。当 $n = 5000$ 时，$k \le 83$，也就意味着每一位出错的概率仅约 $\frac{1}{2^{83}}$。虽然此时公式的误差将会巨大，但这已经是非常小的概率了，如同哈希算法一样，这样小的概率使得我们可以在有 $25$ 次提交机会的情况下接受。如果出错，把节点编号随机打乱一下即可，每次评测改编随机数种子，我们基本可以忽略 $25$ 次评测均出错的概率。

## $100$ pts 后的进一步优化

时刻注意一个性质，此题的删边操作仅仅是删除，它并不会加边，这与常见的数据纠错面对的场景不同，我们的数据仅会从 $1$ 变为 $0$，而不会从 $0$ 变为 $1$。这意味着对于二进制为 $0$ 的位，它必然正确，而我们程序出错的概率也仅与 $X$  在二进制下 $1$ 的位数有关。那么如果 $1$ 的位数超过一半，我们可以对其按位取反再传输。之前如果某一个节点对于的位是 $0$，我们将它连向 $1$ 号节点，那么此时我们可以将其连向 $2$ 号节点以作区分。由于 $0$ 的位数多余一半，且本身还有一些无意义节点可以连接，所以必然有一半以上的节点连向 $1$ 号或 $2$ 号节点，所以区分是否需要反转的正确性严格为 $100\%$。这使得错误的概率进一步大大降低。

------------

闲话：当时考场上想到这道题时在想什么呢...嗯...其实在想之前划水时看的科普吧...当时想 ECC 只能处理 $1$ 位错误（$2$ 位只能发现但是不能纠正），里德所罗门好像可以处理但又记不太清。光面对恐怖的错误率害怕，于是只写了最暴力的 $5$ 分。其实我感觉这好像是很多 OIer 都会踩的坑，就是过度追求绝对的正确性，有时候像哈希这样的算法感觉算两遍算三遍都不敢用。其实，即使面对 OI 赛制好像也没必要这样紧张，而尤其是面对这样 IOI 赛制时，我们真的需要在意那一点点的错误率吗？我们总想着求稳，不希望最终自己几年的努力最终靠运气，但却因为这样的心态而错失很多机会。我常想，如果当时能有勇气写下这个算法，那再面对第一题时的心态应该会放松很多吧，自然也就不会紧张到想着求最大值却写成最小值、多测忘记清空...即使没有这些连带效应，再不济也能拿到 Cu 吧。但如果能呢？Ag？Au？或许真的连 Au 都不是那么困难吧。我常说，这或许是我历史中离 Au 最近的一次，但最后却拿了 Fe。

那就，希望这最后的一段闲话能给大家一个警示吧 QwQ 。加油！我们的未来，具有无限可能性 QwQ！！！

---

## 作者：AC_love (赞：1)

APIO2024，忆昔当年泪不干。

这个题的解决思路有两种，一种是保存完整的信息不要让信息被删干净，另一种是保存一些有效信息通过删除后剩余的有效信息还原原数。

第一个思路的一种可行做法为 $k$ 进制拆分，先对 $X$ 拆位，每一位连向代表 $0 \sim k - 1$ 的点，多连几遍。随机删点的情况下正确率非常高。

但交互库可能会采取某种特殊策略删点，比如删除某个点连出去的所有边之类的。这样就有很大的可能会丢失信息。

多做几次随机置换能降低丢失信息的概率，最后能不能过比较吃运气。

由这个做法可以延伸到第二个思路的类似做法：我们对 $X$ 做多次 $k$ 进制拆分，每次取不同的 $k$。最后就算删除了相当一部分信息，我们仍然能从剩余的信息里还原出原来的 $X$。

这个做法可行但很麻烦，考虑一个更简单的做法。

把 $k + 1$ 连向 $X \bmod k + 1$，最后 exCRT 还原一下即可（实际上直接暴力还原复杂度也是对的）。

设保留下来的边里的更大的数为 $x_i$，那么最后一定能还原出一个小于所有 $x - 1$ 的最小公倍数的解。

我们只要保证这个最小公倍数大于 $10^{18}$ 即可，为了保证正确性，要把 $n$ 取大一点。

---

## 作者：P_Bisector (赞：1)

做这个题的时候不知道为什么想到了 P4581。我们注意到 P4581 为了避免算重使用了 $\min$ 和 $\max$ 。而这一题我们也可以考虑为了避免丢失选择某种运算 $\oplus$ 满足 $A\oplus A=A$。不知道 $\min$ 和 $\max$ 能不能做，反正我选用了按位或。为了方便书写，我们定义 $\text{or}$ 为按位或，$\text{and}$ 为按位与，Alice 得到的数为 $x$。

考虑使用一些偏招给每个点赋一个点权。虽然 Alice 和 Bob 不能互相通讯，但是可以先预留一个“密码本”，即使用同样的方法生成一个数列。接着我们给每一条边赋一个边权。我们定义边权为两端的点的按位与的值。（考虑到按位或这种东西完全不可逆，那么假如某个点的点权为 $f_i$，并且 $x\ \text{or}\ f_i $ 不等于 $x$ ，那么我们就可以考虑一些方法把 $f_i$ 中无法利用的位消掉。于是我们想到了按位与。比较暴力地，我们可以考虑让这个点和点权为 $0$ 的点连边。）那么我们就默认 $x$ 为所有边的边权按位或得到的结果。

接下来就简单了。对于第 $i$ 个点，我们找到所有 $j$ 满足 $j<i$ 且 $f_i \ \text{and}\ f_j=f_i \ \text{and}\ f_j\ \text{and} \ x$（注意到只有这样的边才合法），然后从中随机选一条并连上。当 Bob 拿到这棵“残树”的时候，直接考虑各边，计算出边权按位或的值即可。

注意到为了保证有解，我们可以将第一个点的点权设为 $0$。

#

以下是一些不知道哪些有用哪些没有用的优化。

首先我们设置一大部分点权为 $2$ 的整数次幂。这样大多数有 $x\ \text{or}\ f_i $ 不等于 $x$ 的 $i$ 也可以和这一部分点连边。

其次我们设置一大部分点权只有两个二进制位不等于 $0$。理由同上。

接下来我们设置一个奇怪的数字，在接到 $x$ 之后用 $x$ 按位异或上这个数字，最后得出 $x$ 以后再按位异或回去。防止没有良心的出题人来卡。（实测这个似乎没用）

#

代码如下：

```cpp
#include <vector>
#include<iostream>
#include<stdlib.h>
#define B __int128
using namespace std;
typedef long long ll;
ll x;
long long setN(int n);
long long key=911451419198105432ll;
long long f[5050];
void createf(){
    f[1]=0;
    for(int i=2;i<=500;i++){
    	f[i]=(1ll<<(i%63));
	}
	f[501]=1;
	for(int i=501;i<=1000;i++){
		f[i]=((__int128)(f[i-1])*257+1)%key;
	}
	for(int i=1001;i<=1250;i++){
		f[i]=(1ll<<(f[i-250]%63))|(1ll<<(f[i-500]%63));
	}
	for(int i=1251;i<=5000;i++){
		f[i]=((B)(f[i-114])*(B)257+(B)(f[i-514])*752+f[i-1])%key;
	}
} 
vector<pair<int, int> >Alice(){
    x=setN(5000);
    int n=5000; 
    x^=key;
    createf();
    vector<pair<int,int> >ans;
    for(int i=2;i<=n;i++){
    	vector<int>ok; 
    	for(int j=1;j<i;j++){
    		if((f[i]&f[j])==(f[i]&f[j]&x)){
    			ok.push_back(j);
			}
		}
		int r=rand()%ok.size();
		ans.push_back(make_pair(i,ok[r]));
	}
	return ans;
}
ll Bob(vector<pair<int, int> >v){
    x=0;
    createf();
    for(int i=0;i<v.size();i++){
    	x|=(f[v[i].first]&f[v[i].second]);
	}
	return x^key;
}
```

---

## 作者：gan1234 (赞：1)

最暴力的想法就是二进制下每一位用 $80$ 个点来维护。若该位为 $1$ 则全部连向 $1$，否则连向 $2$。

这个东西的正确概率不是很会算，但是感觉不是很牛。

我们考虑使用 $k$ 进制。这样我们有 $\log_k 10^{18}$ 位，每一位可以分 $\frac{5000-k}{\lfloor \log_k 10^{18} \rfloor}$ 个点。当 $k=1000$ 时，每一位可分到的点数最多。此时有 $6$ 位，每位 $666$ 个点。

但是这样子还是太容易卡了，考虑给每个点重标号一下，并且每个点维护的数字也重标号一下就行了。

#### 代码

```cpp
#include<bits/stdc++.h>
long long setN(int n);
#define ll long long
#define P pair<int,int>
using namespace std;
mt19937 rd(time(0));
int pos[5005],p2[5005];
int id[5005][5005],id2[5005][5005];
int a[5005];
vector<P>Alice(){
    ll S=setN(4996);
    for(int i=1;4996>=i;i++)pos[i]=i;
    shuffle(pos+1,pos+4997,rd);
    for(int i=1;4996>=i;i++)p2[pos[i]]=i;
    S--;
    vector<P>E;
    for(int i=1;1000>i;i++)E.push_back(P{pos[i],pos[i+1]});
    for(int i=1;1000>=i;i++)a[i]=i;
    for(int i=1001;4996>=i;i++){
        shuffle(a+1,a+i,rd);
        for(int j=1;1000>=j;j++)id[i][j]=a[j],id2[i][a[j]]=j;
        a[i]=i;
    }
    ll B=1e15;
    int t=1001;
    while(B){
        for(int i=t;t+666>i;i++)E.push_back(P{pos[id[i][S/B+1]],pos[i]});
        S%=B;
        t+=666;
        B/=1000;
    }
    return E;
}
ll Bob(vector<P>E){
    ll S=0,B=1e15;
    int t=1001;
    while(B){
        for(auto p:E){
            int x,y;
            if(p2[p.first]>p2[p.second])x=p.first,y=p.second;
            else x=p.second,y=p.first;
            if(p2[x]>=t&&p2[x]<t+666){
                int l=id2[p2[x]][p2[y]]-1;
                S+=B*l;
                break;
            }
        }
        t+=666;
        B/=1000;
    }
    return S+1;
}
```

---

## 作者：WaTleZero_pt (赞：0)

根据题意，很显然，我们只需要想办法传递 $N$ 二进制下每一位的值即可。因为点数 $5000$ 远大于 $N$ 在二进制下的位数 $60$，所以在许多边重复记录要传达的信息的情况下，删去一些边后出错率仍然极低。

为了避免被毒瘤交互库卡掉，我们要让生成的树尽可能均匀，让交互库无法猜测到每个点或边的功能，或者即使可能被交互库卡也要尽可能提高正确率。我们考虑一些非常神奇的做法：

我们将这 $5000$ 个点分成大小相等的两组：一组 $2500$ 个点（编号 $1 \sim 2500$）用于表示 $1$ 或 $0$，其中前 $1250$ 个点表示 $1$，后 $1250$ 个点表示 $0$；另一组 $2500$ 个（编号 $2501 \sim 5000$）分别描述 $N$ 的每一个二进制位，第 $2501 + i$ 个点表示 $N$ 从低到高第 $(i \mod 60)$ 个二进制位（从 $0$ 开始）的值。

我们将第 $2501 \sim 5000$ 的点连向前 $2500$ 个点，若对应 $N$ 的二进制位应当为 $1$ 则随机连接 $1 \sim 1250$ 中的一个点，否则随机连接 $1251 \sim 2500$ 中的一个点。如果你愿意，你甚至可以把一部分用于记录二进制位为 $0$ 的点随机连接到其他编号在 $2501 \sim 5000$ 中的点，使得这个树在交互库看来更加随机，反正我们最终以是否连接到表示二进制位为 $1$ 的点来判断 $N$ 每一个二进制位的值是否为 $1$，所以没有任何问题。

至于前面 $2500$ 个点之间怎么连边，那就随便了，我是将每个点随机连到比它编号小的一个点上。

这样做唯一的弱点就是在交互库删除叶子节点所连接的边是会导致正确率降低，但是大致估测~~凭感觉~~发现这样的边数通常大于 $3000$（由于随机，编号在 $1251 \sim 2500$ 的点很多就是叶子节点），极端情况下正确率仍可接受（实测提交 $4$ 次全部通过）。

如果你怕被卡也可以选定一个随机种子，把点的编号打乱（事实证明这种方法对于毒瘤的交互库来说几乎没用），当然我没有打乱也过了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long setN(int n);
#include<bits/stdc++.h>
using namespace std;
long long setN(int n);
vector<pair<int,int> > Alice(){
	long long t=setN(5000);
	mt19937 rnd(time(0));
	vector<pair<int,int> > res;
	bool tag;int x;
	for(int i=0;i<60;i++){
		tag=(t&(1ll<<i))>0;
		for(int j=2501+i;j<=5000;j+=60)
			res.push_back(make_pair(tag?(x=rnd()%1250+1):(x=rnd()%1250+1251),j));
	}
	for(int i=2;i<=2500;i++)
		res.push_back(make_pair(rnd()%(i-1)+1,i));
	return res;
}
long long Bob(vector<pair<int,int> > g){
	long long ans=0;
	for(pair<int,int> e:g){
		if(e.first<=1250&&e.second>2500){
			ans|=(1ll<<((e.second-2501)%60));
		}
	} 
	return ans;
}
```

---


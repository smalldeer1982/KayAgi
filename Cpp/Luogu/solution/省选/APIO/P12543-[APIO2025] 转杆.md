# [APIO2025] 转杆

## 题目背景

请注意：本题只支持 C++ 语言提交；你不需要也不应该实现 `main` 函数；你需要在程序开头添加如下内容：

```cpp
#include <vector>

void energy(int n, std::vector<int> v);
void rotate(std::vector<int> t, int x);
```

## 题目描述

Asadullo 是电力与工业优化联盟（Alliance for Power and Industrial Optimization，APIO）的杰出研究员。最近，他研究出利用一种未知材料的发电方法。

这种未知材料不能单独地发电；但如果用这种材料制造出若干极长的杆，这些长杆之间的相互作用能产生电力。

特别地，给定 $n$ 根长杆的属性 $v[0], v[1], \ldots, v[n-1]$。该属性描述了第 $i$ 根长杆放置在与 $x$ 轴正方向逆时针成 $a[i] = 360 \cdot \frac{v[i]}{100000}$ 的角度。这 $n$ 根长杆的发电效率为：

$$\sum_{i<j} \operatorname{acute}(i,j)$$

其中 $\operatorname{acute}(i,j)$ 表示第 $i$ 根长杆和第 $j$ 根长杆所形成的锐角。在本题中，我们认为 $90^\circ$ 也是锐角。形式化地，$\operatorname{acute}(i,j) = \min(|v[i] - v[j]|, 50000 - |v[i] - v[j]|)$。

换句话说，发电效率取决于每对长杆所形成的锐角度数的总和。

例如，当 $v = [5000, 12500, 37500]$ 则相应地 $a = [18, 45, 135]$，我们将得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xkk4vtuf.png)

此图中，$\operatorname{acute}(0,1) = 7500$（即 $27^\circ$），$\operatorname{acute}(0,2) = 17500$（即 $63^\circ$），以及 $\operatorname{acute}(1,2) = 25000$（即 $90^\circ$）。因此，这些长杆的发电效率等于 $7500 + 17500 + 25000 = 50000$。

Asadullo 想要调整这 $n$ 根长杆的相对角度以最大化发电效率。然而，存在以下约束条件：

- 首先，由于长杆的材料对生命体具有极高危害，这些长杆只能在受控的方式下操作一个特殊的机械装置来转动。这个装置允许选择若干长杆，并将所有选择的长杆转动相同的角度。
- Asadullo 不希望这些长杆的发电效率降低。因此，每次操作后，发电效率都不能低于转动前的发电效率。
- 由于操作这个装置需要耗费大量的能量，所有操作里被选择的长杆总数不能超过 2000000。

在这些约束条件下，Asadullo 希望执行最优的若干操作，来最大化这些长杆的发电效率。写一段代码来帮助 Asadullo 实现最大可能的发电效率。

### 实现细节

你需要实现以下函数：

```cpp
void energy(int n, std::vector<int> v)
```

- `n`：长杆的数目。
- `v`：大小为 `n` 的数组描述这些长杆的属性。
- 这个函数给调用一次。

在上述函数里，你可以调用以下函数：

```cpp
void rotate(std::vector<int> t, int x)
```

- `t`：互不相同的元素组成的下标数组，即对任意 `i` 有 $0 \leq t[i] < n$，且对任意 $i < j$ 有 $t[i] \neq t[j]$。数组 `t` 不要求有序。
- 这个函数将下标数组 `t` 所选择的长杆同时转动 `x` 个单位。那么，每个在 `t` 数组的元素 `i`，将使 `v[i]` 变成 $(v[i] + x) \mod 50000$。
- 这个函数可以被调用多次。数组 `t` 在所有调用里的累加长度不能超过 2000000。

## 说明/提示

### 例子

#### 例 1

考虑以下函数调用：

```cpp
energy(2, [20000, 10000])
```

此处，$v = [20000, 10000]$ 且初始的发电效率为 $20000 - 10000 = 10000$。以下是一种可能的场景：

1. 调用 `rotate([0, 1], 8000)`。那么 `v` 变成 `[28000,18000]`。发电效率保持不变。
2. 调用 `rotate([0], 15000)`。那么 `v` 变成 `[43000,18000]`。发电效率变成 $43000 - 18000 = 25000$。

可以证明，对于初始配置，25000 是能实现的最大发电效率。因此，Asadullo 可以停止操作。

#### 例 2

考虑以下函数调用：

```cpp
energy(3, [5000, 12500, 37500])
```

题面的示例插图描述的就是这个例子，可以证明，初始配置实现的即是最大的发电效率。所以，不需要执行任何操作。

### 约束条件

- $2 \leq n \leq 100 \, 000$
- 对任意的 $0 \leq i < n$，满足 $0 \leq v[i] \leq 49 \, 999$
- 数组 `v` 的元素不一定互不相同

### 子任务

1. (5 分) $n = 2$
2. (11 分) 对于每个 $0 \leq i < n$，均有 $v[i] < 25 \, 000$
3. (8 分) $n \leq 10$
4. (15 分) $n \leq 100$
5. (15 分) $n \leq 300$
6. (20 分) $n \leq 2000$
7. (26 分) 没有额外的约束条件。

### 评测程序示例

评测程序示例按以下格式读取输入：

- 第 1 行：$n$
- 第 2 行：$v[0] \, v[1] \ldots \, v[n-1]$

评测程序示例按以下格式打印输出：

- 第 1 行：长杆最终的发电效率

此外，评测程序示例会将你所调用的转动操作的详细信息写入 `log.txt` 文件。

# 题解

## 作者：Iniaugoty (赞：44)

如何~~苏瞳~~速通 APIO 2025 Ag？？？很难不注意到只有 T3 是可做题，考虑把它过掉！

考虑 $n = 2$ 的情况，显然当且仅当两直线垂直时最优。

考虑 $n = 3$ 的情况，显然答案会是一个平角，否则会出现四条不共线的直线。特别地，当有两条直线垂直时能取到：它们之间夹一个直角，而第三条线与它们产生一对互余的角。不过不是仅当，但这并不重要。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ardau7u.png)

以上是两个基本的情形，下面将利用她们进行推广。

很难不发现最优解总是，直线两两垂直的配对起来（当然 $n$ 为奇数时会有一个多出来的）。

如果你发现不了的话，考虑归纳 / 增量法构造。$n = 2, 3$ 时我们已经会了，利用 $n = 2k$ 时的最优解推出 $n = 2k + 1, 2k + 2$ 的。首先考虑加入第 $2k + 1$ 条直线，出现了 $k$ 个 $n = 3$ 的情形，发现随便加（甚至跟已有的重合）都行；再加入第 $2k + 2$ 条直线，出现了 $k$ 个 $n = 3$ 的情形与 $1$ 个 $n = 2$，前者没啥要求，后者只需要保持使其与第 $2k + 1$ 条直线垂直即可。

那么有一个 naive 的想法是直接 $(i, i + \lfloor \frac n 2 \rfloor)$ 配对，但这是错的。问题出在哪，发现题目要求每一步之后值都不降，这个东西随便手玩一下就能 hack 掉。

如图，直接让 3 来迁就 1 得到与其垂直的 3' 的话，它与 2 和 4 的夹角明显会变小，而这个减小的程度超过了与 1 夹角的增加。

![](https://cdn.luogu.com.cn/upload/image_hosting/dnccx0ut.png)

考虑大胆地将 $n$ 条直线排序一下，再 $(i, i + \lfloor \frac n 2 \rfloor)$ 配对。然后你发现这甚至**是对的**。

~~如果是赛时，几乎就不用管它了，我们已经完成了 Ag 中最难的一步！~~

考虑这个为什么是对的。对于已经配对好的直线来讲，别的不管怎么动贡献肯定都是直角，是没有影响的，因此忽略掉她们。注意到，从 $i$ 到 $\lfloor \frac n 2 \rfloor$ 之间的直线的数量（当然，只考虑剩下来的没被忽略掉的），与 $i + \lfloor \frac n 2 \rfloor$ 到 $n$ 之间的直线的数量，几乎是一样的，取决于 $n$ 的奇偶性最多相差 $1$。

考虑 $i + \lfloor \frac n 2 \rfloor$ 转动带来的变化，设其转动的锐角为 $\delta$。注意到那两部分间必然存在一部分，到 $i + \lfloor \frac n 2 \rfloor$ 的角度全部增加，且增加了 $\delta$；而另一部分中有增有减，并且变化的幅度都不超过 $\delta$。由于数量相差不超过 $1$，以及 ，$i + \lfloor \frac n 2 \rfloor$ 本身的增加，整体上是不减的。

![](https://cdn.luogu.com.cn/upload/image_hosting/5fh7ihk1.png)

如上图是几种情况。

```cpp
const int N = 1e5 + 5;
const int rt = 2.5e4, m = 5e4;
int a[N], p[N];
bool cmp(int x, int y) { return a[x] < a[y]; }
void energy(int n, vector<int> v) {
  F(i, 0, n - 1) a[i] = v[i], p[i] = i;
  sort(p, p + n, cmp);
  F(i, 1, n >> 1) {
    int x = p[i - 1], y = p[i - 1 + (n >> 1)];
    rotate({y}, ((v[x] + rt - v[y]) % m + m) % m);
  }
}
```

操作数是恰好的 $\lfloor \frac n 2 \rfloor$，而出题人的限制给到了足足 $2 \times 10 ^ 6$，哈哈哈，真幽默呀。

我是 xst 粉丝，建议降黄，嘟嘟嘟。

---

## 作者：Undead2008 (赞：24)

如何十行代码拿下（详细揭秘）

因为原问题显然不弱于直接求解最优解，直接观察最优解的性质容易得到最优解一定满足存在一组 $n$ 条直线的大小为 $\lfloor \dfrac{n}{2}\rfloor$ 的匹配，使得每组匹配的两条直线互相垂直。

然后考虑如何构造方案变成最优解，一个自然的思路是使用调整，观察到一个解如果可以将某条直线调整一步使得答案变更优，则他两边的直线数量是不平衡的，这启发我们在将直线按照 $v$ 排序后，将上文所述的“匹配”构造为 $(i,i+\lfloor\dfrac{n}{2}\rfloor)$，其中 $1\le i\le \lfloor\dfrac{n}{2}\rfloor$。

然后以顺序将每组匹配的两条直线调整至垂直即可，尽管这很反直觉，但是手动模拟一下可以发现答案函数斜率始终非负。

```cpp
#include"bits/stdc++.h"
int V[100010],I[100010];
void rotate(std::vector<int> t, int x);
bool cmp(int u,int v){return V[u]<V[v];}
void energy(int n, std::vector<int> v){
    for(int i=1;i<=n;i++)V[i]=v[i-1],I[i]=i;
    std::sort(I+1,I+n+1,cmp);
    for(int l=1,r=n/2+1;l<=n/2;l++,r++)
        rotate({I[r]-1},V[I[l]]+25000-V[I[r]]);
}
```

---

## 作者：hhoppitree (赞：8)

将直线按照幅角排序后，依次将第 $\left\lceil\dfrac{n}{2}\right\rceil+i$ 条直线转至与第 $i$ 条直线垂直即可（$i=1,2,\cdots,\left\lfloor\dfrac{n}{2}\right\rfloor$），操作次数 $\left\lfloor\dfrac{n}{2}\right\rfloor$。

代码实现：

```cpp
#include <bits/stdc++.h>
#include "rotate.h"

using namespace std;

void energy(int n, vector<int> a) {
    vector< pair<int, int> > p;
    for (int i = 0; i < n; ++i) p.emplace_back(a[i], i);
    sort(p.begin(), p.end());
    for (int i = 0, j = (p.size() + 1) / 2; j < p.size(); ++i, ++j) {
        rotate({p[j].second}, p[i].first + 25000 - p[j].first);
    }
}
```

---

## 作者：wukaichen888 (赞：7)

将直线按一二象限分类，$0$ 归一象限，$25000$ 归二象限。

考虑最终应该构造一些十字对（两条直线相垂直）。

注意到十字对对于其他直线贡献固定，猜想一堆十字对带至多一条直线最优。

所以考虑两两一组归于坐标轴，形成十字对。

若一象限线严格多于二象限线，则将一象限线最靠近 $x,y$ 轴的两条直线一条一条移动到坐标轴。

二象限线严格多于一象限线，同理。

若一象限线、二象限线数量相等，将二象限线最靠近 $y$ 的 $a$、一象限线最靠近 $x$ 的 $b$。两条一起旋转，$a$ 往 $y$ 方向转，$b$ 往 $x$ 方向转，使离目标坐标轴近的移动至坐标轴，再一步操作另一条移动至坐标轴。

显然一象限线、二象限线最多各剩一条。

然后变成 $n=2$ 按最后一种做就行，$n=1$ 不用管。

证明能量不减：可以考虑移动单条直线，贡献提高的线的数量多于贡献减少的线的数量，多直线同理。

这是 $n$ 次操作，移动至多 $2n$ 条线的解法。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1e6+5,inf=1e18,mod=1e9+7;
ll l1,r1,l2,r2,d;
struct node{ll x,id;}b[N];
void rotate(std::vector<int>t,int x);
inline bool cmp(node u,node v){return u.x<v.x;}
void energy(int n,std::vector<int>v){
	for(int i=0;i<n;i++) b[i+1]=node{v[i],i};
	sort(b+1,b+n+1,cmp);
	l1=1,r2=n;r1=0;
	for(int i=1;i<=n;i++) if(b[i].x<25000) r1=i;
	l2=r1+1;
	while((l1<r1)||(l2<r2)){
		if((r1-l1)>(r2-l2)){
			// case1
			rotate({b[l1].id},0-b[l1].x);
			rotate({b[r1].id},25000-b[r1].x);
			l1++,r1--;
		}
		else if((r1-l1)<(r2-l2)){
			// case2
			rotate({b[l2].id},25000-b[l2].x);
			rotate({b[r2].id},50000-b[r2].x);
			l2++,r2--;
		}
		else{
			// case3
			d=min(b[l2].x-25000,b[l1].x-0);
			rotate({b[l1].id,b[l2].id},-d);
			if(b[l2].x-25000>=b[l1].x-0) rotate({b[l2].id},-(b[l2].x-25000-d));
			else rotate({b[l1].id},-(b[l1].x-0-d));
			l1++,l2++;
		}
	}
	if((l1==r1)&&(l2==r2)){
			// case3
			d=min(b[l2].x-25000,b[l1].x-0);
			rotate({b[l1].id,b[l2].id},-d);
			if(b[l2].x-25000>=b[l1].x-0) rotate({b[l2].id},-(b[l2].x-25000-d));
			else rotate({b[l1].id},-(b[l1].x-0-d));
			l1++,l2++;
	}
}
```

---

## 作者：LostKeyToReach (赞：4)

把上界想明白了就会做了。

结论：发电效率的上限为 $25000 \lfloor\dfrac{n^2}{4}\rfloor$，即让前 $\lfloor\dfrac{n}{2}\rfloor$ 个 $v_i$ 为 $0$，剩余的 $v_i$ 为 $25000$。

怎么证明？首先，$f(i, j)$ 的上限为 $25000$，然后我们考虑在前半部分把 $1$ 个 $v_i$ 换成 $x$（这里更改 $v_0$），设被更改后的 $v_i$ 为 $v'_i$，那么这个贡献的变化为：

$$
\begin{aligned}
\sum_{i < j} f_{v'}(i, j) - \sum_{i < j} f_{v}(i, j) &= \sum_{j = 1} ^ {n - 1}f_{v'}(0, j) - \sum_{j = 1} ^ {n - 1} f_v(0, j) \\
&= x\left(\lfloor\frac{n}{2}\rfloor - 1\right) + \sum_{j = \lfloor\frac{n}{2} \rfloor} ^ {n - 1} \left(25000 - x\right) - \sum_{j = \lfloor\frac{n}{2} \rfloor} ^ {n - 1} 25000 \\
&= x\left(\lfloor\frac{n}{2}\rfloor - 1\right) - \sum_{j = \lfloor\frac{n}{2} \rfloor} ^ {n - 1} x \\
&= x\left(\lfloor\frac{n}{2}\rfloor - 1\right) - x\left(n - \lfloor \frac{n}{2}\rfloor\right) \\
&= x\left[2\lfloor\frac{n}{2}\rfloor - (n + 1)\right] < 0.
\end{aligned}
$$

容易发现更劣，当填充更多 $x$ 同理，证毕。

然后我们考虑设 $o_i$ 为排名为 $i$ 的下标，那么每次我们将编号为 $o_i$ 和 $o_{i + \lfloor \frac{n}{2}\rfloor}$ 的 $v_i$ 配对一下，让 $|v_{o_{i + \lfloor \frac{n}{2}\rfloor}} - v_{o_i}| = 25000$ 就行（为什么？因为这样子我们在配对 $(x, o_{{i + \lfloor \frac{n}{2}\rfloor}})$ 和 $(x, o_i)$ 的时候可以把 $v_x$ 消除，从而化成 $(o_{{i + \lfloor \frac{n}{2}\rfloor}}, o_i)$ 的情况），注意我们只需要调整左边，这样的操作次数为 $0.5n$。

```cpp
/*
 * author: LostKeyToReach
 * created time: 2025-05-19 12:22:13
 */
#include <bits/stdc++.h>
// #define int long long
#define vi vt<int>
using ll = long long; using pii = std::pair<int, int>;
template<typename T> using vt = std::vector<T>;
#define all(x) (x).begin(),(x).end()
#define sz(x) ((int)(x).size())
#define For(i, a, b) for(int i = (a); i <= (b); ++i)
#define Rof(i, a, b) for(int i = (a); i >= (b); --i)
#define S std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0)
template<typename T> T chkmax(T& x, T y) {
    return (x < y) ? (x = y, y) : x;
} template<typename T> T chkmin(T& x, T y) {
    return (x > y) ? (x = y, y) : x;
}int fio = (S, 0); constexpr int N = 5e5 + 5, mod = 5e4;
void rotate(vi, int);
void energy(int n, vi v) {
    vi ord(n); std::iota(all(ord), 0);
    std::sort(all(ord), [&](int a, int b) { return v[a] < v[b]; });
    For(t, 0, (n >> 1) - 1) { rotate({ord[t]}, 
        (v[ord[t + (n >> 1)]] - v[ord[t]] + 25000) % mod);
    }
}

```

---

## 作者：Junounly (赞：4)

不同于 std 的做法。

----------

首先可以盯出一个结论：

- $\big \lfloor \cfrac{n}{2} \big \rfloor$ 根线水平放置，$\big \lceil \cfrac{n}{2} \big \rceil$ 根线竖直放置，一定是一种最优形态。

证明简单，调整法即可。

钦定 $v_i=0$ 为 $\text{x}$ 轴，$v_i=25000$ 为 $\text{y}$ 轴，考虑如何做出最终形态。

我们将所有线分为以下几种：

- 红线：平行于 $\text{x}$ 轴的线

- 黑线：平行于 $\text{y}$ 轴的线

- 蓝线：斜率为正数的线

- 绿线：斜率为负数的线

![](https://cdn.luogu.com.cn/upload/image_hosting/wm0a354w.png)

记红线、黑线、蓝线、绿线的数量分别为 $rd,bl,bu,gr$。

**请注意，一开始需要钦定没有红线和黑线，对于 $v_i$ 为 $0$ 或 $25000$ 的线，将它们钦定为蓝线或绿线。**

称将一条蓝线或绿线转为黑线或红线的操作为**校正**。

在一开始没有红线和黑线的情况下，我们可以交替进行校正操作。

具体地，当 $bl \le rd$ 时，可以将一条蓝线或绿线转为黑线；当 $bl \ge rd$ 时，可以将一条蓝线或绿线转为红线，取等时的选择后面会用到。

在保证夹角和不降的情况下，最后一定有 $\big \lfloor \cfrac{n}{2} \big \rfloor$ 根红线和 $\big \lceil \cfrac{n}{2} \big \rceil$ 根黑线。

考虑怎么保证夹角和不降。

红线校正与黑线校正同理，这里只讨论黑线校正。

不失一般性地，我们钦定 $bu \ge gr$，否则可以将整个图镜面翻转。

将斜率最大的蓝线转 $\theta$ 的角度校正为黑线。

最劣情况下，这样做对总夹角和的贡献为 $\theta(bu-1+rd-bl-gr)$。

这样做是对的当且仅当 $bu-1+rd-bl-gr \ge 0$，所以可以拿到 $11$ 分。

由于此时为黑线校正，$bl \le rd$，又有 $bu \ge gr$。

不难得出仅在 $bu=gr,bl=rd$ 时有可能出现错误。

考虑这个局面怎么做。

不难发现这个局面有非常好的性质：

- 对于一条线，将其旋转任意角度，红线和黑线对其夹角和的总贡献是不变的。

原因是红线黑线数量相同，且一条线与红线黑线的夹角和总为 $90^{\circ}$。

因此只需考虑蓝绿线之间的夹角和变化。

可以同时转所有的蓝线和绿线，并进行一次校正，但这样花费太高了，只能拿到 $74$ 分。

刚才的做法启发我们转同样数量的蓝线和绿线。

具体地，我们可以同时转动斜率最大的蓝线和绿线各一根，角度为 $\theta$。

最劣情况下，对夹角和的贡献为 $\theta(bu-1-gr+1)+\theta(gr-1-bu+1)=0$。

但上述式子有前提条件，即**绿线不能变为蓝线，蓝线不能变为绿线**。

这是好处理的，令斜率最大的蓝线与 $\text{y}$ 轴夹角为 $\theta_1$，斜率最大的绿线与 $\text{x}$ 轴夹角为 $\theta_2$，取 $\theta=\min \{ \theta_1 , \theta_2 \}$ 即可。

由于此时黑线和红线数量相等，所以红线校正和黑线校正都是可行的。

每次花 $1$ 或 $2$ 的代价校正一条线，操作数不超过 $2n$。

根据上述分析模拟即可。


----------

Code:

```c++
#include<bits/stdc++.h>
using namespace std;
void energy(int n,vector<int> v);
void rotate(vector<int> t,int x);
multiset<pair<int,int> > g,b;
void rotate_(int pos,int x)
{
    vector<int> t;
    t.emplace_back(pos);
    rotate(t,(x+50000)%50000);
}
void energy(int n,vector<int> v)
{
    int rd=0,bl=0,bu=0,gr=0;
    for(int i=0;i<n;i++)
    {
        int x=v[i];
        if(x<25000) bu++,b.emplace(x,i);
        else gr++,g.emplace(x,i);
    }
    for(;bu|gr;)
        if(bl<=rd)
        {
            if(bu==gr&&bl==rd)
            {
                vector<int> t;
                int x=(--b.end())->first,y=(--b.end())->second;
                int x_=(--g.end())->first,y_=(--g.end())->second;
                if(50000-x_<25000-x)
                {
                    int del=50000-x_;
                    t.emplace_back(y);t.emplace_back(y_);
                    rd++;
                    rotate(t,del);
                    g.erase(--g.end());gr--;
                    b.erase(--b.end());
                    v[y]=(v[y]+del)%50000;
                    if(v[y]==25000) bl++,bu--;
                    else b.emplace(v[y],y);
                }
                else
                {
                    int del=25000-x;
                    t.emplace_back(y);t.emplace_back(y_);
                    bl++;
                    rotate(t,del);
                    b.erase(--b.end());bu--;
                    g.erase(--g.end());
                    v[y_]=(v[y_]+del)%50000;
                    if(v[y_]==0) rd++,gr--;
                    else g.emplace(v[y_],y_);
                }
            }
            else if(bu>=gr)
            {
                int x=(--b.end())->first,y=(--b.end())->second;
                b.erase(--b.end());
                bu--;bl++;
                rotate_(y,25000-x);
            }
            else
            {
                int x=(g.begin())->first,y=(g.begin())->second;
                g.erase(g.begin());
                gr--;bl++;
                rotate_(y,25000-x);
            }
        }
        else
        {
            if(bu>=gr)
            {
                int x=(b.begin())->first,y=(b.begin())->second;
                b.erase(b.begin());
                bu--;rd++;
                rotate_(y,-x);
            }
            else
            {
                int x=(--g.end())->first,y=(--g.end())->second;
                g.erase(--g.end());
                gr--;rd++;
                rotate_(y,50000-x);
            }
        }
}
```

---

## 作者：Xuan_qwq (赞：4)

前情提要：主播在 APIO 赛场上通过三份程序拼成一份程序的方法过了这个题，因此题解不放代码。

首先我们直接考虑极限解是什么。在平面上建坐标系，然后发现极限解就是一半杆子与 $x$ 轴重合，剩下的杆子与 $y$ 轴重合。不过要不要和轴重合不重要，只要是垂直的就行。

接下来我们考虑怎么转杆子来达到目标状态。假设这是初始的样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/1fdutab8.png)

其中 $x$ 轴和 $y$ 轴上有若干根杆子重合。我们发现第一象限里的杆子数量（以下设为 $A$）比第四象限里的的杆子数量（以下设为 $B$）多，所以考虑调整第一象限中的一根杆子。那么我们有两种选择：

![](https://cdn.luogu.com.cn/upload/image_hosting/5lbou4wl.png)

把标绿（最靠近 $x$ 轴）的杆子旋转到 $x$ 轴上，或者把标红（最靠近 $y$ 轴）的杆子旋转到 $y$ 轴上。至于如何选择让我们来看 $x$ 轴上的杆子数量 $C$ 和 $y$ 轴上的杆子数量 $D$ 的大小。

如果 $C>D$ 则转动红色杆子。因为此时 $x$ 轴上杆子与绿杆的夹角变大，第一象限上杆子与绿杆的夹角也变大，那么夹角变大的杆子数量至少是 $A-1+C> B+D$，也就是剩下的杆子中至少有一半与绿杆的夹角在增大。因为每根杆子与绿杆的夹角变化量至多就是增大的角度，所以可以满足题目夹角度数之和不降的要求。

否则转动绿色杆子，角变大的杆子数量至少是 $A-1+D\ge B+C$，同上分析可知夹角度数之和不降。

第四象限的杆子数量比第一象限大，即 $B>A$ 的情况同理，不在赘述。

接下来考虑 $A=B$ 的情况。显然如果 $C\ne D$ 那么同上对 $C,D$ 大小分析决定方案仍然可做，所以我们考虑 $A=B$ 且 $C=D$ 的情况。

这时发现我们无论把哪一根杆子转到坐标轴上都可能会导致夹角度数之和减小，所以此时需要同时转动两根杆子。具体来说：

![](https://cdn.luogu.com.cn/upload/image_hosting/roy01cmp.png)

我们同时转动两根标蓝的杆子，直到其中恰好有一根杆子与坐标轴重合。我们可以发现，两根蓝色杆子的夹角是不变的，与第四象限中蓝色杆子夹角增大的杆子至少有 $B+C-1$ 根，夹角减小的杆子至多有 $A+D-1=B+C-1$ 根，所以可以保证总的夹角度数之和不降。对于第一象限中的蓝色杆子做同样的分析，就可以知道操作是符合题目要求的。

而每次转动杆子都会让 $x$ 轴或者 $y$ 轴上的杆子数量增加，所以经过有限次操作之后这个过程一定会结束。

接着我们考虑让 $x$ 轴和 $y$ 轴上的杆子数量平衡。具体来说，将一条坐标轴上的若干杆子转到另一坐标轴上，可以知道夹角度数之和不降。于是这道题就做完了。

对于题目要求的操作杆子数量上限，我们发现在平衡坐标轴上的杆子数量时，最多会操作 $\lfloor\frac{n}{2}\rfloor$ 根杆子，而每次同时转动两根杆子后，一定是以下两种情况之一：
- 两根杆子都转到了坐标轴上。
- 一根杆子转到了坐标轴上，另一根没有。那么下一步一定是将这根不在坐标轴上的杆子转到对应的坐标轴上。

所以将两根杆子转到坐标轴上的最大花费是操作 $3$ 次数的杆子，也就是说我们在将杆子转到轴上时，操作的杆子次数至多为 $\lfloor\frac{3n}{2}\rfloor$。取 $n=10^6$，发现极限总操作次数 $\lfloor\frac{n}{2}\rfloor+\lfloor\frac{3n}{2}\rfloor=2\times 10^6$ 刚好到达上界，所以这个构造是合法的。

---

## 作者：Galois_Field_1048576 (赞：3)

**题目 1** (C. 转轴). 给定 $n$ 个实数
$r_0, \dots, r_{n - 1} \in [0, 1)$. 定义这组实数的 $F$-值为
$$F(r) = \sum_{0 \le i < j < n} \min\left(|r_i - r_j|, 1 - |r_i - r_j|\right).$$
每次操作可以选择一个 $r_i$, 使其变为任意一个 $\lambda \in [0, 1)$. 请在
$\left\lfloor\dfrac n2\right\rfloor$ 次操作, 使得 $F$-值最大, 且过程中,
$F$-值单调不降.


**定理 1**. $F$-值最大值当存在 $\left\lfloor \dfrac n2 \right\rfloor$
对 $\{r_i, r_j\}$ 使得 $|r_i - r_j| = \dfrac 12$ 时取得.

*Proof.* 记 $d(x, y) = \min(|x - y|, 1 - |x - y|)$. 一个点 $v$
的贡献显然是它到其它点的 $d$-值之和. 考虑某个点 $p$ 的
$$A(p) = \sum_{0 \le i < n} d(r_i, p)$$ 的最大值, 这是一个分段线性函数,
每遇到一个 $r_i$, 斜率 $+2$, 每遇到一个 $r_i + \dfrac 12$, 斜率 $-2$.
因此斜率第一次变号处在于某一个 $r_i + \dfrac 12$. 逐一加点即证定理. ◻

**定理 2**. 令 $r_0 < r_1 < \dots < r_{n - 1}$, 令
$r_{\lfloor n / 2 \rfloor + i} \gets r_i + \dfrac 12$ ($\bmod 1$ 意义下)
是正确的.

*Proof.* 只需证明它单调不降. 注意到, 如果已经完成了
$r_{\lfloor n / 2 \rfloor} \gets r_0 + \dfrac 12$, 那么 $0$ 与
$\left\lfloor \dfrac n2 \right\rfloor$ 的总贡献和为固定的.
因此我们可以删去 $r_0$ 与 $r_{\lfloor n / 2 \rfloor}$.
同理我们可以删去其它已配对元素. 所以不妨假设我们尚未执行任何一个操作,
这样只需注意到 $\lambda \to \mu$ 时, 考虑
$C = \dfrac{\lambda + \mu}{2}$, 则 $C$ 和 $C + \dfrac 12$ 将
$\mathbb R/\mathbb Z$ 分成两半, 其中含有 $\lambda$ 的那半有的贡献差为正,
含有 $\mu$ 的那半有的贡献差为负. 如果选定坐标系让 $C = 0$, 形式化地此时
$$\dfrac{v_0 + v_{\lfloor n/2 \rfloor}}{2} + \dfrac 14 = 0 \iff v_0 + v_{\lfloor n/2 \rfloor} = \dfrac 12.$$
显然此时 $v_0$ 和 $v_{\lfloor n/2 \rfloor}$ 在同一个
$\mathbb R/\mathbb Z$ 的半圆内, 进而他们之间的所有点. 因此,
$v_{\lfloor n/2 \rfloor} \to v_{0} + \dfrac 12$ 时, $F$-值单调不降. ◻

```cpp
#include <bits/stdc++.h>
using namespace std;

void rotate(vector<int> t, int x);

void energy(int n, vector<int> v) {
    vector<int> id(n);
    iota(id.begin(), id.end(), 0);
    sort(id.begin(), id.end(), [&](int a, int b) { return v[a] < v[b]; });
    for (int i = 0; i < n / 2; i++)
        rotate({id[i + (n / 2)]},
               (v[id[i]] - v[id[i + n / 2]] + 75000) % 50000);
}
```

---

## 作者：liuzhangfeiabc (赞：1)

题目大意：给定 $n$ 个 $[0,50000)$ 的整数 $v_i$，你每次要选择一个下标集合和一个数 $x$，将这个下标集合中的数全部加上 $x$，并对 $50000$ 取模。

定义当前的分数为两两数在环上的距离之和，也就是$\sum_{1 \le i < j \le n} \min⁡(|v_i-v_j|,50000-|v_i-v_j|)$。

你要通过若干次操作来最大化分数，并且每次操作后的分数相比操作前都要严格不降。

![](https://cdn.luogu.com.cn/upload/image_hosting/in1qw1yi.png)

如图，这里我将所有的数视为一个长 $50000$ 的环上的点，这与原题中的直线倾角有所不同（例如原题中两条垂直的直线在我这里就是两个对径点），请注意；环上两点的距离实际上也就是它们之间劣弧的长度。

这是今年 APIO 三个题里相对简单的一个，达到最优解的方法不止一种，接下来直接介绍一种容易理解且容易证明的方法：

我们称两个数“对称”，若它们的差是 $25000$，也就是说它们在环上互为对径点。

容易发现，对于一对对称点以及任意的第三个点来说，无论它们的位置如何，产生的贡献总是固定的。如下图可见第三个点到这一对点的距离之和一定等于 $25000$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fntzjvrp.png)

如果两个点已经对称了，且你不打算破坏这一对称关系，那么它们产生的总贡献也就固定了，后续操作就可以直接删掉它们。

那么我们有结论：当所有的 $n$ 个点两两对称时，价值达到最大。特别地，$n$ 是奇数时会有一个点孤立出来。如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/0pozl0t4.png)

利用上面的结论可知，这个最大值其实就是把 $\lceil \frac{n}{2} \rceil$ 个点放在 $0$，$\lfloor \frac{n}{2} \rfloor$ 个点放在 $25000$ 的答案，即 $25000 \times \lceil \frac{n}{2} \rceil \times \lfloor \frac{n}{2} \rfloor$；但其实没有必要非得这么放，只要随便搞出 $\lfloor \frac{n}{2} \rfloor$ 对两两对称的点就行了。

结论的证明其实也就是具体的构造过程，考虑调整法：假设当前的方案不是满足所有点两两对称，就将其调整为这一状态，并且过程中保持总答案始终不下降即可。

假设已经去除所有两两配对的点，目前还剩下至少两个点没有配对。随便选择一个点，如果它的对称位置上已经有其他尚未配对的点，就直接配对即可；否则，以它与它的对称位置连接形成的直径将圆划分为两个半圆，统计一下这两个半圆内各自的点数。然后选择一个点数较少的半圆（若相等则任意选一个），将当前点向这个半圆的方向移动。（如下方图片的左图所示。）

容易看出，在它本身及它的对称位置越过其他点之前，这样的移动带来的价值增量是：两个半圆的点数之差*移动距离，显然总价值一定是不降的。

如果移动过程中它自己越过了某个其他点，这只会使得点数较少的半圆进一步减少，点数较多的半圆进一步增加，因此继续移动仍然是可以的，实际上我们根本不需要处理这种情况。（如下方图片的中图所示。）

如果移动过程中它的对称位置遇到了某个其他点，就相当于已经找到了当前点的配对目标，我们直接停下来即可。注意，虽然继续移动可能依然能使答案上升，但我们的目标只是将点配对而已，因此没必要继续移动了。（如下方图片的右图所示。）

![](https://cdn.luogu.com.cn/upload/image_hosting/au5v673p.png)

然后就简单了，我们只需要用 set 维护当前还没配对的点，用树状数组维护区间内剩余点的个数，然后直接在 set 上查询前驱/后继来找到当前点的配对目标，调用一次 `rotate` 函数即可。总的时间复杂度为 $O(n \log n )$，调用 `rotate` 的总开销只有不超过 $\frac{n}{2}$，远远不到题目限制的 $2\times 10^6$。（说起来为什么要开这么大的调用开销限制？）

代码如下，为了减少分类讨论我把整个环复制了三份，查询时在中间一份进行，这样可以避免把环断成两个区间之类的讨论细节。

```cpp
#include<bits/stdc++.h>
void rotate(std::vector<int> t, int x);
#define li long long
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
using namespace std;
int t[150010],m = 150000;
#define opp(x) (((x) + 25000) % 50000)
inline void ins(int x){
	++x;
	for(int i = x;i <= m;i += i & -i) ++t[i];
}
inline void del(int x){
	++x;
	for(int i = x;i <= m;i += i & -i) --t[i];
}
inline int qry(int x){
	++x;
	int ans = 0;
	for(int i = x;i;i -= i & -i) ans += t[i];
	return ans;	
}
inline int cx(int l,int r){
	return qry(r) - qry(l - 1);
}
set<pii> s;
void ins_a_node(int x,int id){
	x = (x % 50000 + 50000) % 50000;
	s.insert(mp(x,id));
	s.insert(mp(x + 50000,id));
	s.insert(mp(x + 100000,id));
	ins(x);
	ins(x + 50000);
	ins(x + 100000);
}
void del_a_node(int x,int id){
	x = (x % 50000 + 50000) % 50000;
	s.erase(mp(x,id));
	s.erase(mp(x + 50000,id));
	s.erase(mp(x + 100000,id));
	del(x);
	del(x + 50000);
	del(x + 100000);
}
void energy(int n, std::vector<int> v){
	vector<int> vis(n,0);
    s.clear(); 
    for(int i = 0;i < n;++i){
		ins_a_node(v[i],i);
	} 
	int cnt = 0;
	for(int i = 0;i < n;++i) if(!vis[i]){
    	vis[i] = 1;
    	del_a_node(v[i],i);
		auto it = s.lower_bound(mp(opp(v[i]), -1));
		if(it != s.end() && it->fi == opp(v[i])){ 
			// opposite node exists
			int j = it->se;
			vis[j] = 1;
    		del_a_node(v[j],j);
		}
		else{
			int x = v[i] + 50000;
			int oppx = opp(v[i]) + 50000;
			int ql = cx(x - 24999,x - 1);
			int qr = cx(x + 1,x + 24999);
			int j = -1;
			if(ql > qr){ 
				// turn right
				j = (s.lower_bound(mp(oppx, -1)))->se;
			}
			else{
				// turn left
				j = (--s.lower_bound(mp(oppx, -1)))->se;
			}
			// turn i to opp(j)
			vis[j] = 1; 
			del_a_node(v[j],j);
			rotate({i}, (opp(v[j]) - v[i] + 50000) % 50000);
		}
		cnt += 2; 
    	if(cnt >= n - 1) break;
	}
	for(int i = 0;i < n;++i) if(!vis[i]) del_a_node(v[i],i); // clear
}
```

---

## 作者：未来姚班zyl (赞：1)

emmm 我结论是猜的但我的实现方法还是正确性很自然的，场上也很好地证明了。

结论是这样的：最大的权值就是直线两两匹配成直角时的权值。

相信其它的题解会给出详细证明，我这里就简略了（而且这个结论是非常符合直觉的）。

现在我们就是要在题目要求下将直线两两匹配形成直角，呕象给出一种构造方案，共需要 $n$ 步操作。

- 第一步，将直线按照 $y$ 轴为分界线各分一半。
- 第二步，将左右两半按照 $v_i$ 从小到大排序，再按照大小依次匹配。

相较于 $\frac{n}{2}$ 步的做法，我的第一步似乎有点多余，不过会让证明变得非常自然：

第一步是这样实现的：用 $y$ 轴将直线分为 $[0,24999]$ 和 $[25000,49999]$ 两部分。

考虑哪一部分的直线多，将多的那一部分的直线分到另一边，我们假设是左边的那部分多。

那么找到左边**最靠右**的直线 $i$，将其 $v_i$ 修改为 $25000$。

这一步绝对不会让权值变小，因为对于左部分的其它直线 $j$，其与 $i$ 形成的夹角从一个锐角变成了更大的锐角，且中途没有跨过 $90\degree$。而左部点的数量是大于 $\frac{n}{2}$ 的，所以其它的点再怎么减总权值也不会减。

如果右边的更多是类似的。

第二步，我们在做一个类似双指针的东西，我们将 $v_i$ 从小到大排序，将 $v_j$ 与 $v_{j+\frac{n}{2}}$ 匹配。$j$ 从 $\frac{n}{2}$ 扫到 $1$。（$1\sim \frac{n}{2}$ 在左边，剩下的在右边）。

那么对于 $[j+1,\frac{n}{2}]$ 与 $[j+\frac{n}{2}+1,n]$ 的直线，由于其两两匹配，所以其它直线与一对匹配直线的权值和都是 $90\degree$，不用管。

考虑将 $v_j$ 和 $v_{j+\frac{n}{2}}$ 中偏左的那个往右边调，假设是调 $v_j$。

那么 $[1,j-1]$ 中的直线 $k$，其与直线 $j$ 的夹角也是从一个锐角变为更大的锐角。

对于直线 $j$ 与 $j+\frac{n}{2}$，它们的夹角从锐角变为直角。

所以依旧有超过一半的直线权值完全增加，总权值就不会减少。

使用桶排可以做到时间复杂度 $O(n)$。

---

## 作者：_Kenma_ (赞：1)

## 前言

详细解密为什么我过 T3 没有 Ag。

## 思路分析

首先这个题面太唬人了，但是读完发现和计算几何啥的没关系。

考虑末态，不难发现是线段两两配对垂直，此时答案是 $25000(\lfloor\frac{n}{2}\rfloor)^2$。

于是考虑构造合法操作方案使得答案不降。

有一个想法是，以和 $x$ 轴角度最小的直线为新的 $x$ 轴建立坐标系，然后依次旋转直线使得所有直线和坐标轴平行，最后再调整使得和 $x$ 轴平行和 $y$ 轴平行的直线数的差小于等于 $1$。

然后考虑什么时候直线可以被旋转至和坐标轴平行。

我们建立新的坐标轴之后，图上的直线可以分为四类，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1pm7lys0.png)

考虑什么时候可以旋转什么样的直线：

- $a+c>b+d$，旋转 $a$ 中最靠近 $d$ 的直线至 $d$；

- $a+c<b+d$，旋转 $b$ 中最靠近 $c$ 的直线至 $c$；

- $a+d>b+c$，旋转 $a$ 中最靠近 $c$ 的直线至 $c$；

- $a+d<b+c$，旋转 $b$ 中最靠近 $d$ 的直线至 $d$。

因为每次都是 $a,b$ 移动到 $c,d$，所以移动会在有限次内结束。

无法移动的情况可能有两种：

- $a=b$ 且 $c=d$；

- 满足不等式但是 $a=0$ 或 $b=0$。

仔细思考后发现第二种是不可能的，此时除非 $a=b=0$，不然一定存在满足条件的移动方式。

于是我们只需要考虑第一种情况的处理，因为此时满足 $c=d$，相当于之前移动的直线已经两两配对，我们只需要把剩下 $a,b$ 中的直线两两配对即可。这个部分是简单的，仔细手玩之后发现只需要把 $a$ 中最靠近 $d$ 的直线和 $b$ 中最靠近 $c$ 的直线配对即可，依次进行，判断谁去向谁垂直，就能做到每次移动直线都不相交。

如果没有出现第一种情况，那么一定能移动至 $a=b=0$ 的末态，此时我们再调整 $c,d$ 的值使得 $|c-d|\le 1$ 即可。

使用 set 维护直线斜率，复杂度 $O(n \log n)$，操作次数在 $1.5n$ 以内。

## 后记

这个做法其实属于比较麻烦的那种，所以场上我刚了 4h 才刚出来，导致 T1 T2 暴力基本没打，Cu 遗憾离场。

有无老哥帮我复现一下代码。

---


# [APIO2012] 派遣

## 题目背景

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。

## 题目描述

在这个帮派里，有一名忍者被称之为 Master。除了 Master 以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。

现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被派遣，你就不需要支付管理者的薪水。

   
你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。

   
写一个程序，给定每一个忍者 $i$ 的上级 $B_i$，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$，输出在预算内满足上述要求时顾客满意度的最大值。

## 说明/提示

$1 \le N \le 10^5$，$1 \le M \le 10^9$，$0 \le B_i \lt i$，$1 \le C_i \le M$，$1 \le L_i \le 10^9$。

对于 $30\%$ 的数据，$N \le 3000$。

## 样例 #1

### 输入

```
5 4
0 3 3
1 3 5
2 2 2
1 2 4
2 3 1
```

### 输出

```
6
```

# 题解

## 作者：KingBenQi (赞：48)

Solution
---
只是本人自己的代码,果然很弱
这道题就是我的忍者们都看成一个单独的堆
对于每个忍者我们对进行相应的枚举,把他的当作领导节点
考虑对每个节点建堆,对于每个非叶节点,将该节点与每个儿子节点合并(左偏树),维护堆中节点数和堆中节点的点权和
```
#include<bits/stdc++.h>
#define LL long long
#define N 100005
using namespace std;
inline int gi(){
    char ch=getchar();int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
struct Player{
	int fa,cost,lead;
}R[N<<2];
int n,m;
LL ans;
int size[N],root[N],dis[N],ls[N],rs[N];
LL sum[N];
void BuildHeap(int now){
	size[now]=1;
	root[now]=now;
	sum[now]=R[now].cost;
}
int Merge(int A,int B){
	if(!A||!B) return A+B;
	if(R[A].cost<R[B].cost) swap(A,B);
	rs[A]=Merge(rs[A],B);
	if(dis[ls[A]]<dis[rs[A]]) swap(ls[A],rs[A]);
	dis[A]=dis[rs[A]]+1;
	return A;
}
int main(){
	//freopen("Master.in","r",stdin);
	//freopen("Master.out","w",stdout);
	n=gi();m=gi();
	for(int i=1,b,c,l;i<=n;i++){
		b=gi();c=gi();l=gi();
		R[i]=(Player){b,c,l};
		ans=max((LL)(R[i].lead),ans);
		BuildHeap(i);    //每个忍者看成一个单独的堆
	}
	for(int i=n;i>1;i--){
		int fa=R[i].fa;          //当前的忍者看作为领导,对每个点都进行枚举
		root[fa]=Merge(root[i],root[R[i].fa]);      //合并当前节点和本身的父亲节点
		size[fa]+=size[i];sum[fa]+=sum[i];        //把当前的元素加到父亲数size和sum都想应改变
		while(sum[fa]>m){
			sum[fa]-=R[root[fa]].cost;      //如果超过了删除堆顶元素
			root[fa]=Merge(ls[root[fa]],rs[root[fa]]);     
			size[fa]--;    //更新size
		}
		ans=max(ans,(LL)(R[fa].lead)*(LL)(size[fa]));   //取max的ans
	}
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：枫林晚 (赞：23)

博客地址：https://www.cnblogs.com/Miracevin/p/9368414.html

n个点组成一棵树，每个点都有一个领导力和费用，可以让一个点当领导，然后在这个点的子树中选择一些费用之和不超过m的点，得到领导的领导力乘选择的点的个数（领导可不被选择）的利润。求利润最大值。
n≤100000 ；

从叶子节点开始，每个点开始是一个大根堆，堆里的就是这个点的人。

往父亲那里合并堆，记录堆的大小，费用的总和。

从儿子合并完毕后，在每个节点，不断踢出费用最大的人，直到费用的总和<=m 这就是这个点的最优方案了。（显然，花费最小的都留下了）

对于每个点，用这个点的领导力乘堆的大小尝试更新答案即可。

 

注意：和子树合并的时候,rt[x]=mer(rt[x],rt[y]) 注意是rt[y]因为这才是y的所属堆的入口。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100000+10;
int n;
ll m;
ll c[N],p[N];
int rt[N];
ll siz[N];
ll ans;
struct node{
    int nxt,to;
}e[2*N];
int hd[N],cnt;
void add(int x,int y){
    e[++cnt].nxt=hd[x];
    e[cnt].to=y;
    hd[x]=cnt;
}
struct tr{
    int ls,rs,d;
    ll cos;
    ll sum,siz;
}z[N];
void pushup(int x){
    z[x].sum=z[z[x].ls].sum+z[z[x].rs].sum+z[x].cos;
    z[x].siz=z[z[x].ls].siz+z[z[x].rs].siz+1;
}
int mer(int x,int y){
    if(!x||!y) return x+y;
    if(z[x].cos<z[y].cos) swap(x,y);
    z[x].rs=mer(z[x].rs,y);
    
    if(z[z[x].ls].d<z[z[x].rs].d) swap(z[x].ls,z[x].rs);
    z[x].d=z[z[x].rs].d+1;
    pushup(x);
    return x;
}
int split(int x){
    return mer(z[x].ls,z[x].rs);
}
void dfs(int x,int fa){
    z[x].cos=c[x];
    z[x].ls=z[x].rs=0;z[x].siz=1;
    z[x].sum=c[x];
    rt[x]=x;
    for(int i=hd[x];i;i=e[i].nxt){
        int y=e[i].to;
        if(y==fa) continue;
        dfs(y,x);
        rt[x]=mer(rt[x],rt[y]);//注意rt[y] 
    }
    while(z[rt[x]].sum>m&&z[rt[x]].siz){
        rt[x]=split(rt[x]);
    }
    ans=max(ans,z[rt[x]].siz*p[x]);
}
int main()
{
    scanf("%d%lld",&n,&m);
    int fa;
    for(int i=1;i<=n;i++){
        scanf("%d%lld%lld",&fa,&c[i],&p[i]);
        add(fa,i);add(i,fa);
    }
    dfs(1,0);
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：vegetabird (赞：11)

嗯，这道题可以用线段树合并做。

我们考虑以任意一个点$u$为领导者的情况：

显然，我们选出以$u$为根节点的子树中$C$(薪水)最小的$k$个点(忍者)，使$\sum{C}\leq m$，且令$k$尽量大。这样以$u$为领导者的最大满意度为$L_{u}*k$。

我们可以先将所有的$C$离散化，对于每一个点$u$，记录$C_u$的排名$rk_u$。这是准备工作。

接下来的问题就是如何高效地求出每个点为领导者时能派遣的忍者的最大数量。

不妨设当前根节点为$u$。假设我们已经通过奇妙的方法将以$u$为根的子树中所有的$C$存入一棵以$rk$为下标的线段树中，那么我们只要在这棵线段树上二分一下，就能求出派遣忍者的最大数量(因为在这棵树中，随着叶子节点的下标的递增，该节点所代表的忍者的薪水就越大)。

现在我们需要找到一个***奇妙的方法***得到这样一棵线段树。

我们可以通过线段树合并实现。这里的线段树全部需要动态开点。首先，我们对于每一个忍者(包括$Master$)都建一棵线段树，然后向树中插入该忍者的$C$；然后我们从忍者树的底层依次向上，每一次通过树上二分求出当前点为领导者时能派遣的忍者的最大数量，然后将当前忍者的线段树合并到该忍者上级的线段树上。这样我们能够在$\Omega(nlogn)$的时间内求出答案。

对于这题的线段树合并，可以证明不会出现合并时$key$相同的情况。

代码(**真的很短！！**)：
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#define cint const int
#define newnode() ++idx
using namespace std;
int lch[3000010],rch[3000010];
long long sum[3000010];
int cnt[3000010];
int idx;
int root[100010];
void merge(int &u,cint &v){
	if((!u)||(!v)){
		sum[u+v]=sum[u]+sum[v];
		cnt[u+v]=cnt[u]+cnt[v];
		u+=v;
	}else{
		merge(lch[u],lch[v]);
		merge(rch[u],rch[v]);
		sum[u]=sum[lch[u]]+sum[rch[u]];
		cnt[u]=cnt[lch[u]]+cnt[rch[u]];
	}
}
void ins(cint &u,cint &left,cint &right,cint &pos,cint &w){
	sum[u]+=w;
	++cnt[u];
	if(right-left>1){
		if(pos<((left+right)>>1)){
			if(!lch[u])lch[u]=newnode();
			ins(lch[u],left,(left+right)>>1,pos,w);
		}else{
			if(!rch[u])rch[u]=newnode();
			ins(rch[u],(left+right)>>1,right,pos,w);
		}
	}
}
int bisearch(cint &u,cint &left,cint &right,cint &limit){
	if(!u)return 0;
	if(right-left>1){
		if(sum[lch[u]]<limit)
			return cnt[lch[u]]+bisearch(rch[u],(left+right)>>1,right,limit-sum[lch[u]]);
		else
			return bisearch(lch[u],left,(left+right)>>1,limit);
	}else{
		if(sum[u]<=limit)return 1;
		else return 0;
	}
}
struct node{
	int a,b;
	inline bool operator<(const node &v)const{return a<v.a;}
};
int n,m;
int b[100010],c[100010];
long long l[100010];
node t[100010];
int rk[100010];
long long ans;
int main(){
	int i,j,k;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i){
		scanf("%d%d%lld",b+i,c+i,l+i);
		t[i]={c[i],i};
	}
	stable_sort(t+1,t+n+1);
	for(i=1;i<=n;++i){
		k=t[i].b;
		rk[k]=i;
		root[k]=newnode();
		ins(root[k],1,n+1,rk[k],c[k]);
	}
	for(i=n;i;--i){
		ans=max(ans,l[i]*bisearch(root[i],1,n+1,m));
		if(b[i])merge(root[b[i]],root[i]);
	}
	printf("%lld\n",ans);
}
```

---

## 作者：Priori_Incantatem (赞：9)


左偏树 + 树形DP

这题的思路还是比较好想的  
首先，对于每一个节点维护一个左偏树（大根堆），同时维护堆内忍者个数和费用和  
接着，我们用 dfs 从下往上合并  
当我们合并到点 $x$ 时，有可能目前堆内的总费用之和超出预算，所以我们利用贪心的思想将费用最高的忍者依次弹出，直到总费用不超过预算

设 $s[x],c[x],id[x]$ 分别为 $x$ 所在的堆中忍者数，费用和，和该堆的根节点

关键代码

```cpp
void dfs(long long x)
{
	s[x]=1,c[x]=a[x]; // a[x] 为忍者x所需的费用
	for(long long i=0;i<e[x].size();++i)
	{
		long long y=e[x][i];
		dfs(y);
		id[x]=merge(id[x],id[y]); //合并所有子节点所在的堆
		s[x]+=s[y],c[x]+=c[y];// 更新
	}
	while(c[x]>m) // 将最贵的忍者依次弹出，直到不超过预算位置
	{
		--s[x],c[x]-=v(id[x]);
		id[x]=del(id[x]);
	}
	ans=max(ans,b[x]*s[x]);
}
```

注：这里的 费用和与堆中人数 都是在左偏树外面维护的，个人认为比较简洁，其实也可以在堆内维护

完整代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const long long Maxn=200000+10,inf=0x3f3f3f3f;
struct node{
	long long ls,rs,val,fa,dis;
	#define ls(x) g[x].ls
	#define rs(x) g[x].rs
	#define v(x) g[x].val
	#define f(x) g[x].fa
	#define dis(x) g[x].dis
}g[Maxn];
long long a[Maxn],b[Maxn];
long long s[Maxn],c[Maxn],id[Maxn];
vector <long long> e[Maxn];
long long n,m,root,ans;
inline long long read()
{
	long long s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void init()
{
	for(long long i=1;i<=n;++i)
	f(i)=i,v(i)=a[i];
}
long long merge(long long x,long long y)
{
	if(!x || !y)return x|y;
	if(v(x)<v(y))swap(x,y);
	rs(x)=merge(rs(x),y);
	if(dis(rs(x))>dis(ls(x)))swap(ls(x),rs(x));
	if(!rs(x) || !ls(x))dis(x)=0;
	else dis(x)=dis(rs(x))+1;
	return x;
}
long long del(long long x)
{
	long long l=ls(x),r=rs(x);
	f(l)=l,f(r)=r;
	ls(x)=rs(x)=dis(x)=0;
	return merge(l,r);
}
void dfs(long long x)
{
	s[x]=1,c[x]=a[x];
	for(long long i=0;i<e[x].size();++i)
	{
		long long y=e[x][i];
		dfs(y);
		id[x]=merge(id[x],id[y]);
		s[x]+=s[y],c[x]+=c[y];
	}
	while(c[x]>m)
	{
		--s[x],c[x]-=v(id[x]);
		id[x]=del(id[x]);
	}
	ans=max(ans,b[x]*s[x]);
}
int main()
{
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	n=read(),m=read();
	dis(0)=-1;
	for(long long i=1;i<=n;++i)
	{
		long long x=read();
		a[i]=read(),b[i]=read();
		if(x)e[x].push_back(i);
		else root=i;
		id[i]=i;
	}
	init();
	dfs(root);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：埃罗芒阿老师· (赞：9)

首先是很容易想到采用树形DP的方法向上合并解。


故想到使用可并堆。但是是大根堆还是小根堆？


若小根堆(我最开始写的)，应当顺序统计，直到和大于m为止，其他全部pop


看出，这样的复杂度比较高。(然而我没有TLE，WA了。。。。。。。。)


大根堆的话，弹出元素直到元素和<=m.比较容易实现。


在DFS的过程中，为了防止变量之间的冲突，


还要设一个数组表示当前点所属的堆。（可能我就WA在这里吧。。。。）

```cpp
#include<bits/stdc++.h>
#define RG register
#define il inline
#define N 100010
#define LL long long
using namespace std;
int v[N],l[N],r[N],d[N],L[N],n,head[N],tot,BL[N],sz[N];LL sum[N];
struct ed{int nxt,to;}e[N];int m;LL ans;
void add(RG int u,RG int v){e[tot].nxt=head[u];e[tot].to=v;head[u]=tot++;}
il int merge(RG int x,RG int y){
  if(!x||!y)return x+y;
  if(v[x]<v[y])swap(x,y);
  r[x]=merge(r[x],y);
  if(d[r[x]]>d[l[x]])swap(r[x],l[x]);
  d[x]=d[r[x]]+1;return x;
}
il int getint(){
    int w=0;bool q=0;
    char c=getchar();
    while((c>'9'||c<'0')&&c!='-') c=getchar();
    if(c=='-') c=getchar(),q=1;
    while(c>='0'&&c<='9') w=w*10+c-'0',c=getchar();
    return q?-w:w;
}
il void dfs(int u){BL[u]=u;sum[u]=v[u];sz[u]=1;
  for(RG int i=head[u];i!=-1;i=e[i].nxt){
      RG int v=e[i].to;
      dfs(v);sum[u]+=sum[v];
      sz[u]+=sz[v];
      BL[u]=merge(BL[u],BL[v]);
  }while(sum[u]>m&&sz[u]){
    sum[u]-=v[BL[u]];
    BL[u]=merge(r[BL[u]],l[BL[u]]);
    sz[u]--;
  }ans=max(ans,(LL)sz[u]*L[u]);
}
int main(){
  freopen("dispatching.in","r",stdin);
  freopen("dispatching.out","w",stdout);
  memset(head,-1,sizeof(head));
  n=getint(),m=getint();
  for(RG int i=1;i<=n;++i){int ytk;
    ytk=getint(),v[i]=getint(),L[i]=getint();
    add(ytk,i);
  }dfs(1);printf("%lld",ans);
  return 0;
}

```

---

## 作者：amazingOZR (赞：6)

左偏树裸题。

明显领导关系形成一棵树，则答案为ans=max{L[u]\times k}，其中k代表以u为根的字数中选出的节点数个数（设这些节点为v\_1,v\_2\cdots v\_k）且有\sum\_{i=1}^{k}C[v\_i]\leq M。

所以以每个节点建一个大根堆，维护薪水值。初始时若自己满足条件就选自己，否则不选。从叶子节点往上推，对于每个节点，将它与它的儿子节点合并。如果当前的选择费用超出了M，就弹出堆里最大的，一直到不超过M为止。动态维护当前选择的节点数num和选择费用sum即可。复杂度有点难分析，不过大概是O(nlogn)级别？如果有大神知道请教我orz

代码：

```cpp
#include<cstdio>
#include<cstring>
typedef long long ll;
const int maxn=100005,maxe=100005;
int val[maxn],lc[maxn],rc[maxn],dis[maxn],root[maxn],l[maxn],num[maxn],c[maxn],head[maxn],next[maxe],to[maxe],sum[maxn],n,m,cnt,b,w;
ll ans;
void swap(int&a,int&b){int c=a;a=b,b=c;}
int merge(int x,int y)
{
    if(!x||!y)return x?x:y;
    if(val[x]<val[y])swap(x,y);
    rc[x]=merge(rc[x],y);
    if(!lc[x]||dis[lc[x]]<dis[rc[x]])swap(lc[x],rc[x]);
    dis[x]=dis[rc[x]]+1;
    return x;
}
void insert(int a,int b){to[cnt]=b,next[cnt]=head[a];head[a]=cnt++;}
ll max(ll a,ll b){return a>b?a:b;}
int main()
{
    memset(head,-1,sizeof head);dis[0]=-1;
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;++i)
    {
        scanf("%d%d%d",&b,c+i,l+i);
        insert(b,i);
    }
    for(register int u=n;u;--u)
    {
        if(c[u]<=m)root[u]=++w,num[u]=1,val[w]=sum[u]=c[u];
        for(register int i=head[u],v=to[i];~i;v=to[i=next[i]])
        {
            root[u]=merge(root[u],root[v]);
            sum[u]+=sum[v],num[u]+=num[v];
            while(sum[u]>m)
            {
                sum[u]-=val[root[u]];--num[u];
                root[u]=merge(lc[root[u]],rc[root[u]]);
            }
        }
        ans=max(ans,(ll)l[u]*num[u]);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Created_equal1 (赞：6)

实际上不用左偏树也可作。。

可以用平衡树+启发式合并

方法与楼上类似，不过处理某个子树中最多有多少个点满足条件时，就贪心的选择尽量小的薪水，并使得它们相加不超过M。

```cpp


#include <cstdio>
#include <cstdlib>
#include <algorithm>

using namespace std;

template<typename Type>
void Get_Val(Type &Ret)
{
    Ret = 0;
    char ch;
    while (ch = getchar(), ch > '9' || ch < '0')
        ;
    do
    {
        (Ret *= 10) += ch - '0';
    }
    while (ch = getchar(), ch >= '0' && ch <= '9');
}

const int Max_N(100050);

struct UFS
{
    int Father[Max_N];
    void given(const int&);
    int Get_Father(const int&);
};
UFS Tree;

void UFS::given(const int &n)
{
    for (int i = 1;i <= n;++i)
        Father[i] = i;
}

int UFS::Get_Father(const int &x)
{
    return Father[x] == x ? x : Father[x] = Get_Father(Father[x]);
}

struct Treap
{
    Treap(const long long int &v = 0) : v(v), sumv(v), size(1)
    {
        priority = rand();
        ch[0] = ch[1] = NULL;
    }
    int priority;
    long long int v, sumv;
    int size;
    Treap *ch[2];
};
Treap *root[Max_N];

void pushup(Treap *&o)
{
    o -> sumv = o -> v, o -> size = 1;
    if (o -> ch[0] != NULL)
    {
        o -> sumv += o -> ch[0] -> sumv;
        o -> size += o -> ch[0] -> size;
    }
    if (o -> ch[1] != NULL)
    {
        o -> sumv += o -> ch[1] -> sumv;
        o -> size += o -> ch[1] -> size;
    }
}

void rotate(Treap *&o, const int &d)
{
    Treap *k = o -> ch[d ^ 1];
    o -> ch[d ^ 1] = k -> ch[d];
    k -> ch[d] = o;
    pushup(o), pushup(k), o = k;
}

void insert(Treap *&o, const long long int &v)
{
    if (o == NULL)
        o = new Treap(v);
    else
    {
        int d = v > o -> v;
        insert(o -> ch[d], v);
        if (o -> ch[d] -> priority > o -> priority)
            rotate(o, d ^ 1);
    }
    pushup(o);
}

void merge(Treap *&a, Treap *&b)
{
    if (a == NULL)
        return;
    merge(a -> ch[0], b);
    merge(a -> ch[1], b);
    insert(b, a -> v);
    delete a, a = NULL;
}

void addedge(const int &u, const int &v)
{
    int f1 = Tree.Get_Father(u), f2 = Tree.Get_Father(v);
    if (f1 != f2)
        if (root[f1] -> size < root[f2] -> size)
        {
            merge(root[f1], root[f2]);
            Tree.Father[f1] = f2;
        }
        else
        {
            merge(root[f2], root[f1]);
            Tree.Father[f2] = f1;
        }
}

int maxsize(Treap *o, const long long int &m)
{
    if (o == NULL || m == 0LL)
        return 0;
    long long int sv = (o -> ch[0] == NULL ? 0 : o -> ch[0] -> sumv) + o -> v;
    int s = (o -> ch[0] == NULL ? 0 : o -> ch[0] -> size) + 1;
    if (m >= sv)
        return s + maxsize(o -> ch[1], m - sv);
    else
        return maxsize(o -> ch[0], m);
}

int N;
long long int M;
int Father[Max_N];
long long int C[Max_N], L[Max_N];

void init()
{
    Get_Val(N), Get_Val(M);
    for (int i = 1;i <= N;++i)
    {
        Get_Val(Father[i]), Get_Val(C[i]), Get_Val(L[i]);
        root[i] = new Treap(C[i]);
    }    
    Tree.given(N);
}

void work()
{
    long long int Ans(0LL);
    for (int i = N;i >= 1;--i)
    {
        Ans = max(Ans, maxsize(root[Tree.Get_Father(i)], M) * L[i]);
        if (i != 1)
            addedge(i, Father[i]);
    }
    printf("%lld\n", Ans);
}

int main()
{
    init();
    work();
    return 0;
}

```

---

## 作者：Light_snow (赞：5)

具体思路就不讲惹。

这里提供一种用 STL 实现的方法，跑得很快。

启发式 priority_queue 操作。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#define ll long long
#define N 100005

ll n,m;

struct P{
ll f,c,l;
ll head,sum;
P(){sum = 0;}
}T[N];

std::priority_queue<ll>QWQ[N];

ll head[N],cnt,ans;

struct E{int to,next;}e[N << 1];

inline void add(int x,int y){
	e[++cnt].to = y;
	e[cnt].next = head[x];
	head[x] = cnt;
}

inline void merge(int x,int y){//x -> y
	if(QWQ[T[x].head].size() > QWQ[T[y].head].size())
	std::swap(T[x].head,T[y].head),std::swap(T[x].sum,T[y].sum);
	while(QWQ[T[x].head].size())
	QWQ[T[y].head].push(QWQ[T[x].head].top()),T[y].sum += QWQ[T[x].head].top(),QWQ[T[x].head].pop();
}

inline void dfs(int u,int f){
//	std::cout<<u<<" "<<f<<std::endl;
	if(T[u].c <= m)
	QWQ[T[u].head].push(T[u].c),T[u].sum += T[u].c;
	for(int i = head[u];i;i = e[i].next){
		int v = e[i].to;
		if(v == f)
		continue;
		dfs(v,u);
		merge(v,u);
	}
	while(T[u].sum > m)
	T[u].sum -= QWQ[T[u].head].top(),QWQ[T[u].head].pop();
	ans = std::max((1ull) * ans, T[u].l * QWQ[T[u].head].size());
}

int main(){
	scanf("%lld%lld",&n,&m);
	for(int i = 1;i <= n;++i)
		scanf("%lld%lld%lld",&T[i].f,&T[i].c,&T[i].l),add(T[i].f,i);
	for(int i = 1;i <= n;++i)
	T[i].head = i;
	dfs(1,0);
	std::cout<<ans<<std::endl;
}
```


---

## 作者：lhm_ (赞：4)

根据题意，我们不难发现忍者之间的关系是树形结构。

发现答案的统计只是在该节点的子树中，因此我们考虑通过树形$DP$来解决问题。

从叶子节点开始，从下往上考虑，因为一个节点的最优答案只与他的领导力和在子树中选了几个点有关，与选哪些点无关，所以我们要最大化选点的个数。

贪心策略即为尽可能的多选点，当选出的点的薪水超过预算时，删去当前选出的点中薪水最大的点，通过这样的策略来保证我们能选出最多的点。

通过可并堆（左偏树）来实现，同时维护一些信息，选出点的薪水总和$sum$，选出点的个数$siz$。

其他的一些细节就看代码吧，统计答案记得开$long\ long$。

$code:$
```cpp
#include<bits/stdc++.h>
#define maxn 200010
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
	x=0;char c=getchar();bool flag=false;
	while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	if(flag)x=-x;
}
ll n,m,root,ans;
ll fa[maxn],ls[maxn],rs[maxn],dis[maxn],val[maxn],l[maxn],sum[maxn],siz[maxn];
struct edge
{
    int to,nxt;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to)
{
    e[++edge_cnt]=(edge){to,head[from]};
    head[from]=edge_cnt;
}
int find(int x)
{
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
int merge(int x,int y)
{
	if(x==y) return 0;
    if(!x||!y) return x+y;
	if(val[x]<val[y]) swap(x,y);
	rs[x]=merge(rs[x],y),fa[rs[x]]=x;
	if(dis[ls[x]]<dis[rs[x]]) swap(ls[x],rs[x]);
	if(rs[x]) dis[x]=dis[rs[x]]+1;
	else dis[x]=0;
	return x;
}
void del(int x)
{
	fa[ls[x]]=ls[x],fa[rs[x]]=rs[x];
	fa[x]=merge(ls[x],rs[x]);
}
void dfs(int x)
{
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        dfs(y);
        siz[x]+=siz[y];
        sum[x]+=sum[y];
        merge(find(x),find(y));
    }
    while(sum[x]>m)
    {
        int rootx=find(x);
        siz[x]--;
        sum[x]-=val[rootx];
        del(rootx);
    }
    ans=max(ans,l[x]*siz[x]);
}
int main()
{
	read(n),read(m);
    for(int i=1;i<=n;++i)
    {
        int fath;
        read(fath),read(val[i]),read(l[i]);
        sum[i]=val[i],siz[i]=1,fa[i]=i;
        if(fath) add(fath,i);
        else root=i;
    }
    dfs(root);
    printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：hongzy (赞：4)

**题意**

给定一个$1$为根的树，每个点有$c,w$两个属性，你需要从某个点$u$子树里选择$k$个点，满足选出来的点$\sum_{i=1}^k w(i)\leq m$，最大化$k\times c(u)$

**题解**

可以启发式合并$splay$来做，$\text{dfs}$每个点，每次和儿子的$splay$合并，就得到了一个维护这个点子树的平衡树。再用这个点的$w$（题目中的领导力）乘以子树中最多选多少结点满足$c$（薪水）和$\leq m$

肯定贪心选，小的先选

然后这玩意我一开始脑抽写了二分$+kth$的两个$\log$做法，会$\text{TLE}$一个点，$97pts$：

```cpp
int kth(int u, int k) {
    while(1) {
        if(sz[ch[u][0]] >= k) u = ch[u][0];
        else {
            k -= sz[ch[u][0]] + 1;
            if(k <= 0) break ;
            u = ch[u][1];
        }
    }
    splay(u);
    return u;
}

ll qsum(int &u, int k) {
    u = kth(u, k);
    return sum[ch[u][0]] + w[u];
}
ll query(int &u) {
    int l = 1, r = sz[u], ans = 0;
    while(l <= r) {
        int mid = (l + r) >> 1;
        if(qsum(u, mid) <= m) l = (ans = mid) + 1;
        else r = mid - 1;
    }
    return ans;
}
```

后来发现直接递归找就行了，十分简单，从左子树往自己往右子树依次判能不能选进去

最后的代码就是这样了qwq：

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

typedef long long ll;

const int N = 2e5 + 10;

int n, m, w[N], c[N];
int fa[N], sz[N], ch[N][2];
vector<int> G[N];
ll ans, sum[N];

int dir(int u) { return ch[fa[u]][1] == u; }
void upd(int u) {
    sum[u] = sum[ch[u][0]] + sum[ch[u][1]] + w[u];
    sz[u] = sz[ch[u][0]] + sz[ch[u][1]] + 1;
}
void rotate(int u) {
    int d = dir(u), f = fa[u];
    if(fa[u] = fa[f]) ch[fa[u]][dir(f)] = u;
    if(ch[f][d] = ch[u][d ^ 1]) fa[ch[f][d]] = f;
    fa[ch[u][d ^ 1] = f] = u;
    upd(f); upd(u);
}
void ins(int &rt, int u, int f = 0) {
    if(!rt) {
        rt = u; fa[u] = f;
        sz[u] = 1; sum[u] = w[u];
        ch[u][0] = ch[u][1] = 0;
        return ;
    }
    ins(ch[rt][w[u] > w[rt]], u, rt);
    upd(rt);
}
void splay(int u) {
    for(; fa[u]; rotate(u)) if(fa[fa[u]])
        rotate(dir(u) == dir(fa[u]) ? fa[u] : u);
}
ll query(int u, ll s) {
    if(!u || !s) return 0;
    if(sum[u] <= s) return sz[u];
    if(sum[ch[u][0]] >= s) return query(ch[u][0], s);
    if(sum[ch[u][0]] + w[u] == s) return sz[ch[u][0]] + 1;
    if(sum[ch[u][0]] + w[u] > s) return sz[ch[u][0]];
    return sz[ch[u][0]] + 1 + query(ch[u][1], s - sum[ch[u][0]] - w[u]);
}

int a[N], l;
void get(int u) {
    if(u) {
        get(ch[u][0]);
        a[++ l] = u;
        get(ch[u][1]);
    }
}
int merge(int u, int v) {
    if(sz[u] < sz[v]) swap(u, v);
    l = 0; get(v); int rt = u;
    for(int i = 1; i <= l; i ++) {
        ins(rt, a[i]);
        splay(rt = a[i]);
    }
    return rt;
}

int dfs(int u) {
    int rt = u; sz[u] = 1; sum[u] = w[u];
    fa[u] = ch[u][0] = ch[u][1] = 0;
    for(int i = 0; i < G[u].size(); i ++)
        rt = merge(rt, dfs(G[u][i]));
    ans = max(ans, c[u] * query(rt, m));
    return rt;
}

int main() {
    scanf("%d%d", &n, &m);
    for(int f, i = 1; i <= n; i ++) {
        scanf("%d%d%d", &f, &w[i], &c[i]);
        G[f].push_back(i);
    }
    dfs(1);
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：crashed (赞：3)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P1552)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心$+$主席树。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难想到一种贪心思路，也就是枚举作为管理者的点$u$，那么这个时候可以选择派遣的忍者就只能在$u$的子树内了。我们肯定是尽量选取最多的忍者，这样满意度才可以尽量大。于是我们每次就先选择最便宜的忍者加入派遣。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到这些可选的忍者都在$u$的子树内，我们不难想到一种经典的套路，就是把所有的点按照$DFS$序排成一个序列，然后构建主席树。每次查询就可以参考静态区间第$K$大，用两个指针在主席树上面二分，并且这样可以保证每次加入派遣的忍者一定是当前最便宜的。构建主席树之后扫一遍点，用上面说到的方法计算答案即可。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预处理主席树可以离散化之后再构建，当然~~懒了的话~~也可以直接写动态开点。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间是$O(n\log_2n)$（离散化），或者$O(n\log_2m)$（动态开点）。  
# 代码
```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 1e5 + 5, MAXLOG = 35, up = 1e9;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ){ f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ), x = -x; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

struct segmentTreeNode
{
	LL s; int lch, rch, siz;
	#define s( a ) ( segTree[a].s )
	#define siz( a ) ( segTree[a].siz )
	#define lch( a ) ( segTree[a].lch )
	#define rch( a ) ( segTree[a].rch )
}segTree[MAXN * MAXLOG];

struct edge
{
	int to, nxt;
}Graph[MAXN];

int seq[MAXN], rt[MAXN], tsiz[MAXN];
int head[MAXN], DFN[MAXN], C[MAXN], L[MAXN];
LL res;
int N, M, cnt, siz, ID;

void addEdge( const int from, const int to ) { Graph[++ cnt].to = to, Graph[cnt].nxt = head[from], head[from] = cnt; }
void upt( const int u ) { s( u ) = s( lch( u ) ) + s( rch( u ) ), siz( u ) = siz( lch( u ) ) + siz( rch( u ) ); }

int update( const int u, const int l, const int r, const int pos )
{
	int cur = ++ siz, mid = l + r >> 1; segTree[cur] = segTree[u];
	if( pos <= l && r <= pos ) { s( cur ) += pos, siz( cur ) ++; return cur; }
	if( pos <= mid ) lch( cur ) = update( lch( u ), l, mid, pos );
	else rch( cur ) = update( rch( u ), mid + 1, r, pos );
	upt( cur ); return cur;
}

int query( const int lr, const int rr, const int l, const int r, const int mon )
{
	if( ! lr && ! rr ) return 0;
	if( l == r ) return mon / l;
	LL cost = s( lch( rr ) ) - s( lch( lr ) );
	int mid = l + r >> 1;
	if( mon <= cost ) return query( lch( lr ), lch( rr ), l, mid, mon );
	else return siz( lch( rr ) ) - siz( lch( lr ) ) + query( rch( lr ), rch( rr ), mid + 1, r, mon - cost );
}

void DFS( const int u ) 
{ 
	tsiz[u] = 1, seq[++ ID] = u, DFN[u] = ID; 
	for( int i = head[u], v ; i ; i = Graph[i].nxt ) 
		DFS( v = Graph[i].to ), tsiz[u] += tsiz[v]; 
}

void solve( const int u )
{
	res = MAX( res, 1ll * L[u] * query( rt[DFN[u] - 1], rt[DFN[u] + tsiz[u] - 1], 1, up, M ) );
	for( int i = head[u] ; i ; i = Graph[i].nxt ) solve( Graph[i].to );
}

int main()
{
	int Master;
	read( N ), read( M );
	for( int i = 1, B ; i <= N ; i ++ ) 
	{
		read( B ), read( C[i] ), read( L[i] );
		if( B ) addEdge( B, i ); else Master = i;
	}
	DFS( Master );
	for( int i = 1 ; i <= N ; i ++ ) rt[i] = update( rt[i - 1], 1, up, C[seq[i]] );
	solve( Master );
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：我没有名称 (赞：3)

贪心+乱搞

~~这题的数据弱到一定程度了~~

暴力：枚举领导者 在他的子树中从小往大选

剪枝：考虑一个忍者 如果存在一个他的上级领导力比他高 那么选他肯定不优 排除这些忍者 剩下暴力就过了。。。。。。
~~~ cpp
#include<iostream>
#include<vector>
#include<ctime>
#include<algorithm>
using namespace std;
vector<int> tu[100010];
int n,zuo[100010],you[100010],cnt,c[100010],b[100010],ni[100010];
long long m,xs[100010],l[100010],sz[100010],ans;
struct ren
{
       int id;
       long long l;
}a[100010];
void dfs(int x,long long mxl)
{
     int i;
     zuo[x]=++cnt;
     ni[cnt]=x;
     sz[x]=1;
     if(l[x]>mxl) c[x]=1;
     for(i=0;i<tu[x].size();i++)
     {
          dfs(tu[x][i],max(mxl,l[x]));
          sz[x]+=sz[tu[x][i]];
     }
     you[x]=cnt;
}
long long check(int x)
{
    int i,tt=0,now=0,tot=0;
    for(i=zuo[x];i<=you[x];i++) b[++tt]=xs[ni[i]];
    sort(b+1,b+tt+1);
    for(i=1;i<=tt;i++)
     if(now+b[i]<=m)
     {
         now+=b[i];
         tot++;
     }
    return tot;
}
int main()
{
    int i,t1,tt=clock();
    cin>>n>>m;
    for(i=1;i<=n;i++)
    {
        cin>>t1>>xs[i]>>l[i];
        tu[t1].push_back(i);
    }
    dfs(1,0);
    cnt=0;
    for(i=1;i<=n;i++) if(c[i]==1) a[++cnt].id=i,a[cnt].l=l[i];
    for(i=1;i<=cnt;i++) ans=max(ans,a[i].l*check(a[i].id));
    cout<<ans;
    //system("pause");
    return 0;
}

~~~

---

## 作者：adolphshi (赞：2)

# P1552 派遣 pbds题解
~~我因为懒得写左偏书于是用pbds过了这道题。~~

## pbds是什么
**pbds** ~~又称平板电视~~ 是 extc++ 中的一个非常强大的库，其中内涵：
- 平衡树 `tree`
- 优先队列 `priority_queue`
- 哈希表 `cc_hash_table`
- 字典树 `trie`

但是，由于它在 `extc++` 中，我们**无法**用万能头去调用它。因此我们需要使用 `bits/extc++.h`  去调用 `extc++` ，此外还需要调用 `pbds` 专属的命名空间 `__gnu_pbds`，因此初始部分代码如下：
```
#include <bits/extc++.h>

using namespace __gnu_pbds;
```  
于是我们就可以正常使用 `pbds` 力！
## 解题过程
**做法前面的人已经讲解的很详细了，我主要就来讲解一下 pbds 部分。**  
这题我们用 `priority_queue` （以下简称 `pq`）来解，`pbds` 库的 `pq` 与 STL 中的 `pq` 没有什么不同，但是支持以 $O(1)$ 的时间复杂度合并。

先看定义：
```
__gnu_pbds::priority_queue<int > q;//__gnu_pbds:: 是为了防止与STL混淆，默认为大根堆
```
再看函数，`pbds` 中的 `pq` 拥有与 `STL` 中的 `pq` 相同的函数。但值得注意的是，它还拥有以下几个函数：
```


q.modify(iterator, key);//修改迭代器位置的值

q.erase(iterator);//删除迭代器位置值

q.join(x);//把x合并到原堆并清空x

```

因此，我们发现它可以做到所有左偏树所能做到的事。  
于是，就有了以下代码。
## code
```
#include <bits/stdc++.h>
#include <bits/extc++.h>

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef const int ci;

ci maxn=100010;
int n,m,fa[maxn],val[maxn],tot,mon[maxn];
ll ans,siz[maxn];
__gnu_pbds::priority_queue<int > q[maxn];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d%d%d",&x,&mon[i],&val[i]);
		siz[i]=mon[i],fa[i]=x;
		ans=max((ll)val[i],ans);
		q[i].push(mon[i]);//压入大根堆
	}
	for(int i=n;i>=1;i--)
	{
		q[fa[i]].join(q[i]);//pbds操作，合并
		siz[fa[i]]+=siz[i];
		while(siz[fa[i]]>m)//持续弹出费用最大的节点，直到可以接受
			siz[fa[i]]-=(ll)q[fa[i]].top(),q[fa[i]].pop();
		ans=max(ans,(ll)val[fa[i]]*(ll)q[fa[i]].size());//统计答案
	}
	printf("%lld",ans);
	return 0;
}
```

如果你想再深入了解 `pbds` 的话，推荐你看[这篇博客](https://blog.csdn.net/Gh0st_Lx/article/details/122851588)
完结撒花(＾－＾)V

upd: 修改了一些代码中的错误，把挂掉的链接换上了  

---

## 作者：maomao9173 (赞：2)

#### [题目链接  Click  Here](https://www.luogu.org/problemnew/show/P1552)

这个题好像大多数人用的都是左偏树啊？这里我来贡献一发主席树的解法。

把题目中的问题抽象出来，其实就是询问每一个点的子树中，工资前$tot_i$大的点，使它们的和满足$\sum cost_i<=m$，在此前提下使$tot_i$尽可能大，答案就是$ans=max(tot_i*lead_i)$。



如果只有一个点的话直接二分一下就好了，但现在树上的每一个点都可能是答案的产生处。为了便于访问每一棵子树，我们把原先的树按$dfs$序划分，子树显然就是连续的一个序列。紧接着我们按$dfs$序对整棵树进行维护，最后在主席树上每个点二分一下$tot_i$的大小就好啦～



```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 100010;
int ans;
int n, m, rt, cnt, sz[N], dfn[N], cost[N], lead[N], head[N];

struct edge {
    int nxt, to;

    edge (int _nxt = 0, int _to = 0) {
        nxt = _nxt, to = _to;
    }
}e[N << 1];

void add_len (int u, int v) {
    e[++cnt] = edge (head[u], v); head[u] = cnt;
    e[++cnt] = edge (head[v], u); head[v] = cnt;
}

#define mid ((l + r) >> 1)

int tot;

struct Segment_Tree {
    struct Segment_Node {
        int ls, rs, sz, sum;
        Segment_Node () {sum = ls = rs = sz = 0;}
    }t[N << 5];
    
    int modify (int _rt, int l, int r, int w) {
        int p = ++tot;
        t[p].ls = t[_rt].ls;
        t[p].rs = t[_rt].rs;
        t[p].sz = t[_rt].sz + 1;
        t[p].sum = t[_rt].sum + w;
        if (l != r) {
            if (w <= mid) {
                t[p].ls = modify (t[_rt].ls, l, mid, w);
            } else {
                t[p].rs = modify (t[_rt].rs, mid + 1, r, w);
            }
        }
        return p;
    }

    #undef mid

    int query (int u, int v, int l, int r, int m) {
        int ans = 0;
        while (l < r) {
            int mid = (l + r) >> 1;
            int suml = t[t[v].ls].sum - t[t[u].ls].sum;
            // printf ("v = %d, t[v].sum = %d, t[v].sz = %d, t[ls].sum = %d, t[ls].sz = %d\n", v, t[v].sum, t[v].sz, t[t[v].ls].sum, t[t[v].ls].sz);
            // printf ("l = %d, r = %d, m = %d, mid = %d, suml = %d, sz = %d\n", l, r, m, mid, suml, t[t[v].ls].sz - t[t[u].ls].sz);
            if (m <= suml) {
                u = t[u].ls;
                v = t[v].ls;
                r = mid;
            } else {
                ans += t[t[v].ls].sz - t[t[u].ls].sz;
                u = t[u].rs;
                v = t[v].rs;
                l = mid + 1;
                m -= suml;
            }
        }
        // printf ("m = %d, r = %d, ans = %d\n", m, r, ans);
        ans += floor ((1.0 * m) / (1.0 * r));
        // printf ("ans = %d\n", ans);
        return ans;
    }
}tree;

int root[N];
void pre (int u, int fa) {
    sz[u] = 1;
    dfn[u] = ++dfn[0];
    root[dfn[u]] = tree.modify (root[dfn[u] - 1], 1, m, cost[u]);
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (v != fa) {
            pre (v, u);
            sz[u] += sz[v];
        }
    }
}

signed main () {
    cin >> n >> m;
    for (int u = 1; u <= n; ++u) {
        static int v;
        cin >> v >> cost[u] >> lead[u];
        if (v == 0) {
            rt = u;
        } else {
            add_len (u, v);
        }
    }
    pre (rt, 0);
    for (int u = 1; u <= n; ++u) {
        int dfnu = dfn[u];
        int dfnv = dfn[u] + sz[u] - 1;
        ans = max (ans, 1LL * lead[u] * tree.query (root[dfnu - 1], root[dfnv], 1, m, m));
    }
    cout << ans << endl;
} 

```



---

## 作者：JOHNKRAM (赞：2)

树形DP+左偏树。

开始每个点都是一棵左偏树。

处理一个点时，先处理它的孩子，再把它和它所有孩子的左偏树合并。

每次删去工资最高的，直至工资在允许范围内为止。

最后求所有f[i]中最大的即可。

另外，由于可能有100000层，所以得用手工栈（否则会挂几个点）


---

## 作者：cyn2006 (赞：1)

### 题目大意
问题就是找一个结点，使从自己和子树中找到尽量多的节点，总的权值和不超过 $m$，节点数$\times$自己的权值最大。

很明显，对于一个结点，应该在子树中选择权值尽量小的结点。 

可以用可并堆，当然可以直接向上合并堆（用启发式合并优化）

### 堆的合并
这里的堆用优先队列代替。
- 对于叶子结点，堆的大小为 $1$

- 对于非叶子结点，令当前结点为 $x$，儿子集合为 $\{son_i\}$，儿子集合中的堆都已经处理好了，只需要将堆 $son_1\ldots son_n$ 合并到堆 $x$ 即可。

这里我们发现了一个问题：如果堆维护的是当前的从小到大的点权（即小根堆），那么我们在维护点权和 $\leqslant m$ 的时候比较麻烦（因为此时优先队列只能 $pop$ 最小的点，而不能 $pop$ 最大的点），于是我们改用大根堆，每次维护堆的操作变为 $pop$ 最大的值，直到点权和 $\leqslant m$。

这样还不够，普通的往上合并在 $Luogu$ 评测（开 $O2$）只有 $88pts$，于是我们采用启发式合并，将堆大小小的往堆大小大的堆合并，于是：

```cpp
std::priority_queue<int> q;
inline int merge(int x,int y){
	if(q[x].size()<q[y].size()) std::swap(x,y);
	while(!q[y].empty()){
		q[x].push(q[y].top()),ret[x]+=q[y].top(),q[y].pop();
		while(ret[x]>m&&!q[x].empty()) ret[x]-=q[x].top(),q[x].pop();
	}
	return x;
}
```
其中 $\{ret_i\}$ 为编号为 $i$ 的堆的点权和。

### 树形 $dp$ ?
可能不算树形 $dp$ 吧。。。

$dfs$ 时先遍历，等到回到原先的点 $x$ 时，记堆合并后的大小 $sz_x$，点 $x$ 的点权（题目中的领导值）为 $led_x$，则该点的最大值为 $sz_x\times led_x$，答案为 $Max_{i=1}^n sz_x\times led_i$，$dfs$ 一次即可求出答案。

时间复杂度 $O(nlog^2n)$ ？~~可能会退化成 $O(n^2)$，不过……~~

$dfs$ 的代码：
```cpp
inline void dfs(int x){
	id[x]=x; //id 表示堆合并后的编号
	if((ret[x]=val[x])<=m) q[x].push(val[x]);
	for(int i:e[x]){
		dfs(i);
		id[x]=merge(id[x],id[i]);
	}
	ans=std::max(ans,led[x]*static_cast<long long>(q[id[x]].size()));
	// ans 即为答案 
}
```

### 思考

用 $STL$ 的 $priority\_queue$ 会被卡吗？可能常数有点儿大，可以换成 $pd\_ds$ 的优先队列吧（~~反正 noip 也让用~~）

---

## 作者：1234KID (赞：1)

其实这题还可以用线段树合并来做。

考虑每个点对答案的贡献子树中尽量多的点被选择。然而怎么维护每个点为根的子树中的被选人数呢？

可以线段树合并。

用一棵权值线段树来维护。

线段树中需要记录的是每个点所代表的区间的总的花费，以及总的节点个数。

然后对于左儿子的总花费大于预算经费，则递归到左儿子去查询。

否则，就递归到右儿子，此时已经选择了整个左子树，所以预算经费要减去左儿子的总权值。

然后在递归的时候算一下可以选的个数就可以了。


---

## 作者：pinkex (赞：1)

想了较长时间（其实是脑子坏了）。

我最初的想法就是，我们可以定住一个点x，将它当做是管理者，然后那些被派遣的人从以其为根的子树中找。

然后ans=max(ans,lead[x]\*calc(x))。显然，这是正确的吧。因为管理者需要能到达所有的被派遣者，及管理者是被选出子树的根节点。

这样方便了我们calc（其实就是运用了一点点的动规思想和贪心思想）。

那么，calc怎么办？也就是说，我们要在x的几棵子树中（包括自己）找到最多的点代价和不超过m。

想到了什么？左偏树好像可以。

就是说，对于每一个点x，都连着好几棵处理好的左偏树，然后我们可以用log的时间合并。

但是，我们还要删掉一些点使满足条件。我选择了用大根堆，这样删除方便。

但是这个操作具体的复杂度是多少呢？由于删除的点不会重新被加入，所以每个点最多被删除一次，复杂度为nlogn。

加上上面的一系列操作nlogn的复杂度，总复杂度依然是nlogn。

可以参考我的blog：<http://www.cnblogs.com/whc200305/p/7616108.html>

code：

```cpp
%:pragma GCC optimize(2)
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=100005;
vector <int> son[N];
int n,m,ro[N]; LL s[N],c[N],f[N],ans;
struct lft {int l,r,d,w; void cl() {l=r=d=0;}}a[N];
inline int read() {
    int x=0; char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
int merge(int x,int y) {
    if (!x||!y) return x+y; if (a[x].w<a[y].w) swap(x,y);
    a[x].r=merge(a[x].r,y); int l=a[x].l,r=a[x].r;
    if (a[l].d<a[r].d) swap(a[x].l,a[x].r);
    a[x].d=a[a[x].r].d+1;
    return x;
}
int main() {
    n=read(),m=read(),ans=0,a[0].d=-1;
    for (int i=1; i<=n; i++) {
        a[i].cl(),ro[i]=i,son[read()].push_back(i);
        s[i]=a[i].w=read(),c[i]=1,f[i]=read();
    }
    for (int i=n,siz; i>=1; i--) {
        siz=son[i].size();
        for (int k=0,j; k<siz; k++) {
            j=son[i][k],ro[i]=merge(ro[i],ro[j]);
            s[i]+=s[j],c[i]+=c[j];
        }
        for (; s[i]>m;) {
            s[i]-=a[ro[i]].w,c[i]--;
            ro[i]=merge(a[ro[i]].l,a[ro[i]].r);
        }
        ans=max(ans,f[i]*c[i]);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Prev1ous (赞：1)

## 看到这道题我第一感觉以为是dp（但是不会写（感觉没法做。
### 那就用标准~~sao~~做法吧。


------------

~~orzorzorzorzorzorzorzorz。~~


------------

### 我们先选一个根节点，然后从这个点子树里找若干个点，使薪水总和不超过M。
### 满意度max=根节点L * 这棵子树我们选的点的个数。
# 钱越少人越多岂不美滋滋。
### 用大根堆对每一个点去进行维护，在每个点都要更新一波答案。
### 合并之后把超过的就可以pop掉了。
### 比较懒的可以选择一种东西叫做pbds(平板电视）。
~~据说noip可以用的不会被卡掉。~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cctype>
#include<ext/pb_ds/priority_queue.hpp>
#define rg register 
#define int unsigned long long
using namespace std;
inline int read(){
	rg int s=0,f=0;
	rg char ch=getchar();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
int n,m,ans;
const int MAX=100015;
const int inf=1e9;
int f[MAX],v[MAX],l[MAX];
int sum[MAX];
__gnu_pbds::priority_queue<int>q[MAX];
signed main(){
	n=read(),m=read();
	for(rg int i=1;i<=n;++i){
		f[i]=read();
		v[i]=read();
		l[i]=read();
	}
	for(rg int i=n;i;--i){
		q[i].push(v[i]);
		sum[i]+=v[i];
		while(sum[i]>m){
			sum[i]-=q[i].top();
			q[i].pop();
		}
		ans=max(ans,1ll*q[i].size()*l[i]);
		sum[f[i]]+=sum[i];
		q[f[i]].join(q[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

#### pbds这玩意具体用法以后会往我博客里做一期（真方便嘻嘻嘻。
## ~~over and sto~~

---

## 作者：GoldenPotato137 (赞：0)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p1552-apio2012%E6%B4%BE%E9%81%A3/)

---
# Solution
这是一道左偏树的模板题，不会左偏树的可以[戳这里](https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%AF%E5%B9%B6%E5%A0%86%E5%B7%A6%E5%81%8F%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)

显然，我们可以发现对于同一颗子树，我们想让取的人尽可能便宜，如果说目前为止取的价格超过$C$,就优先把贵的人先丢掉。

因此，我们考虑用左偏树来维护这个东西。对于每一个人，我们都建一颗以价格为关键字的大根堆。考虑从下往上合并，一旦堆的元素总和超过$C$就不断弹栈，弹到合法为止。然后我们算一下$l_i*size$，取个最大值就好。

时间复杂度$O(nlogn)$

就酱，我们就可以把这道题切掉啦(ﾉﾟ∀ﾟ)ﾉ 

---
# Code
```cpp
//Luogu  P1552 [APIO2012]派遣
//Mar,15th,2019
//左偏树水题
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;	c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=100000+100;
struct LST
{
	int fa[N],son[N][2],dis[N],w[N];
	long long sum[N],size[N];
	inline void update(int x)
	{
		sum[x]=sum[son[x][0]]+sum[son[x][1]]+w[x];
		size[x]=size[son[x][0]]+size[son[x][1]]+1;
	}
	int Merge(int x,int y)
	{
		if(x==0 or y==0) return x+y;
		if(w[x]>w[y]) swap(x,y);
		son[y][1]=Merge(x,son[y][1]);
		fa[son[y][1]]=y;
		update(y);
		if(dis[son[y][1]]>dis[son[y][0]]) 
			swap(son[y][0],son[y][1]);
		dis[y]=dis[son[y][1]]+1;
		return y;
	}
	int Pop(int x)
	{
		fa[x]=Merge(son[x][0],son[x][1]);
		return fa[x];
	}
}lst;
vector <int> e[N];
long long c[N],l[N],size[N],n,m;
int root[N];
long long ans;
void dfs(int now)
{
	for(int i=0;i<int(e[now].size());i++)
	{
		dfs(e[now][i]);
		root[now]=lst.Merge(root[now],root[e[now][i]]);
	}
	while(root[now]!=0 and lst.sum[root[now]]>m)
		root[now]=lst.Pop(root[now]);
	if(root[now]!=0)
		ans=max(ans,l[now]*lst.size[root[now]]);
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		e[i].reserve(4);
	for(int i=1;i<=n;i++)
	{
		int fa=read();c[i]=read(),l[i]=read();
		e[fa].push_back(i);
		size[i]=1;
		root[i]=i,lst.w[i]=lst.sum[i]=c[i],lst.size[i]=1;
	}
	
	dfs(1);
	
	printf("%lld",ans);
	return 0;
}

```






---

## 作者：ywh666 (赞：0)

很显然我们应该选最价值尽量小的

这时候我们就可以用两个堆，小的堆往大的堆上面合并

但人懒呀，于是就直接开了一堆优先队列（逃)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
template <class T> void read(T &x) {
	x = 0;
	ll f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
	x *= f;
}
ll n,m,head[100005],cnt,val[100005],leader[100005],fa[100005],ans,nowval[100005],gg[100005],siz[100005];
struct edge{ll to,next;
}e[200005];
priority_queue<ll>q[100005];
void dfs(ll u,ll pre)
{
	gg[u]=u;
	for(ll i=head[u];i;i=e[i].next)
	{
		if(e[i].to==pre)continue;
		dfs(e[i].to,u);
		if(q[gg[u]].size()>=q[gg[e[i].to]].size())
		{
			while(!q[gg[e[i].to]].empty())
			{
				ll x=q[gg[e[i].to]].top();
				q[gg[e[i].to]].pop();
				q[gg[u]].push(x);
			}
		}
		else
		{
			while(!q[gg[u]].empty())
			{
				ll x=q[gg[u]].top();
				q[gg[u]].pop();
				q[gg[e[i].to]].push(x);
			}
			gg[u]=gg[e[i].to];
		}
		siz[u]+=siz[e[i].to];
		nowval[u]+=nowval[e[i].to];
	}
	q[gg[u]].push(val[u]);
	siz[u]++;nowval[u]+=val[u];
	while(nowval[u]>m)
	{
		ll x=q[gg[u]].top();
		q[gg[u]].pop();
		siz[u]--;
		nowval[u]-=x;
	}
	ans=max(ans,siz[u]*leader[u]);
}
void add(ll a,ll b)
{
	e[cnt].to=b;
	e[cnt].next=head[a];
	head[a]=cnt++;
}
int main()
{
	cnt=1;
	read(n);read(m);
	for(ll i=1;i<=n;++i)
	{
		read(fa[i]);read(val[i]);read(leader[i]);
		if(fa[i])add(fa[i],i);
	}
	dfs(1,0);
	cout<<ans<<endl;
}
```

---

## 作者：Rye_Catcher (赞：0)

- 题目链接:

  https://www.luogu.org/problemnew/show/P1552
  
- 分析:

  一开始愣是没看懂题,后面发现就是你要找一个树上点集使得各点权值之和小于$M$,并且找一个点集的公共祖先$Anc$(管理者),使$Anc$的领导力乘以点集大小最大
  
  一开始想DP,一看数据范围,我们可以稍微暴力一点,枚举每个点作为管理者的答案最大值,我们只要在子树中权值最小的点选起使权值之和小于$M$就可以了,一下问题简单了许多.
  
  再暗中观察分析,发现这个信息是可以维护转移的,在两颗子树合并时可以用大根堆搞一搞.我们不妨先对树进行$dfs$,中途不断合并权值信息.
  
  当$dfs$ $x$节点时,以$x$为根建一个大根堆称为x的代表堆,$dfs$完$x$的一个子树回溯到$x$时,将子树的代表堆与$x$的代表堆进行合并,同时将两堆权值之和相加.若权值之和大于$m$,由于是大根堆,不断$pop$堆顶直至小于$m$,满足最优子结构.
  
  
- 注意

  本题思维容易但要注意一些问题:
  
  1. 虽说是X的代表堆,然而X可能会被$pop$这个堆,于是要用一个$root$记录代表堆的根,同时dfs返回该root值
  
  2. 可并堆可用斜堆或左偏堆 COGS上斜堆略胜一筹,luogu上却不尽人意
  
  3. 还有一些细节和小技巧,比如处理祖宗的最大领导力可以看代码
  
  
- 代码(左偏树)

  ```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
#include <queue>
#define ri register int 
#define ll long long 
using namespace std;
const int maxn=103005;
const int inf=0x7fffffff;
template <class T>inline void read(T &x){
	x=0;int ne=0;char c;
	while(!isdigit(c=getchar()))ne=c=='-';
	x=c-48;
	while(isdigit(c=getchar()))x=(x<<3)+(x<<1)+c-48;
	x=ne?-x:x;
	return ;
}
int n;
ll  m,leader[maxn],key[maxn],ans[maxn],anss=-inf;
int ls[maxn],rs[maxn],fa[maxn],cnt[maxn],npl[maxn];//可并堆
vector <int>son[maxn];
int get(int x){
	while(x!=fa[x])fa[x]=get(fa[x]);
	return fa[x];
}
int merge(int x,int y){
	if(!x)return y;
	if(!y)return x;
	if(key[x]<key[y])swap(x,y);
	fa[y]=x;
	rs[x]=merge(rs[x],y);
	if(!ls[x]||npl[ls[x]]<npl[rs[x]])swap(ls[x],rs[x]);
	if(!rs[x])npl[x]=0;
	else npl[x]=npl[rs[x]]+1;
	//swap(ls[x],rs[x]);
	return x;
}
int del(int now){
	fa[now]=-1;
	fa[ls[now]]=fa[rs[now]]=0;
	return merge(ls[now],rs[now]);
}
int dfs(int now,ll mx){//mx--祖先上的领导力最大值
	int s,root=now,ro_s;
	mx=max(mx,leader[now]);
	ans[now]=key[now],cnt[now]=1;
	anss=max(anss,leader[now]);
	for(ri i=0;i<son[now].size();i++){		
		s=son[now][i];		
		ro_s=dfs(s,mx);	
		ans[now]+=ans[s],cnt[now]+=cnt[s];
		root=merge(root,ro_s);	
		while(ans[now]>m&&cnt[now]) {
			ans[now]-=key[root];
			cnt[now]--;
			root=del(root);
		}
		anss=max(anss,cnt[now]*mx);
	}
	return root;
}
int main(){
	int pa;
	//freopen("dispatching.in","r",stdin);
	//freopen("dispatching.out","w",stdout);
	read(n),read(m);
	for(ri i=1;i<=n;i++){
		read(pa),read(key[i]),read(leader[i]);
		ls[i]=rs[i]=0,fa[i]=i,npl[i]=0;
		son[pa].push_back(i);
	}
	dfs(1,leader[1]);
	printf("%lld\n",anss);
	fclose(stdin);
	fclose(stdout);
	return  0;
}
```

---

## 作者：温词 (赞：0)

## BZOJ2809&&LG1552 APIO2012派遣(线段树合并)

### 题面

自己找去

### HINT

简化一题面就是让你从每个点的子树中以$<=m$的代价选取尽可能多的点，然后乘上子树根的一个属性值，每个点做一遍取个$max$。看大家都是什么可并堆、dfs序+主席树，我的做法是对于每个节点开一颗权值线段树，每个节点维护$size$和$tot$，然后修改和线段树合并都是常规写法。
### 着重讲一下查询
这样的写法之后就是要实现查询用m的代价可以最多选择多少个点
```cpp
inline int query(int p,long long rk,int l,int r){
        if(!p) return 0;//如果进入了空节点，就肯定没有可选的，返回0
        if(l==r){
            int x=st[p].tot/st[p].size;return min((long long)rk/x,(long long)st[p].size);
//这里是重点，查询到该点的时候我还有rk的剩余，已经到叶子节点了，这个时候我们就要计算一下自己最多可以选多少个，如果能都选就都选，如果不能多选就尽量选满
        }
        long long now=st[ls(p)].tot;int mid=(l+r)>>1;
        if(rk<=now) return query(ls(p),rk,l,mid);
        else return st[ls(p)].size+query(rs(p),rk-now,mid+1,r);
    }
```
### 其他的看代码吧
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ls(x) st[x].ch[0]
#define rs(x) st[x].ch[1]
using namespace std;
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        w=(w<<3)+(w<<1)+ch-48;
        ch=getchar();
    }
    return w*f;
}
int n,m,cur,root[100010],a[100010],b[100010],val[100010],now[100010];
long long l[100010],ans[100010];
bool debug;
struct CHAIRMANTREE{
    struct Node{
        int size,ch[2];long long tot;
    }st[6000010];
    int tot;
    inline void pushup(int x){
        st[x].size=st[ls(x)].size+st[rs(x)].size;
        st[x].tot=st[ls(x)].tot+st[rs(x)].tot;return;	
    }
    inline int change(int p,int l,int r,int pos,int val){
        if(!p)p=++tot;
        if(l==r){
            st[p].size+=1;st[p].tot+=val;return p;
        }
        int mid=(l+r)>>1;
        if(pos<=mid) ls(p)=change(ls(p),l,mid,pos,val);
        else rs(p)=change(rs(p),mid+1,r,pos,val);
        pushup(p);return p;
    }
    inline int merge(int x,int y,int l,int r){
        if(!x||!y) return x|y;
        int p=++tot;
        if(l==r){
            st[p].size=st[x].size+st[y].size;
            st[p].tot=st[x].tot+st[y].tot;return p;
        }
        int mid=(l+r)>>1;
        ls(p)=merge(ls(x),ls(y),l,mid);
        rs(p)=merge(rs(x),rs(y),mid+1,r);
        pushup(p);return p;
    }
    inline int query(int p,long long rk,int l,int r){
        if(!p) return 0;
        if(l==r){
            int x=st[p].tot/st[p].size;return min((long long)rk/x,(long long)st[p].size);
        }
        long long now=st[ls(p)].tot;int mid=(l+r)>>1;
        if(rk<=now) return query(ls(p),rk,l,mid);
        else return st[ls(p)].size+query(rs(p),rk-now,mid+1,r);
    }
}TREE;
int cnt,head[100010];
struct Edge{
    int from,to,next;
}edge[200010];
inline void addedge(int u,int v){
    cnt++;
    edge[cnt].from=u;
    edge[cnt].to=v;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
map<int,int> mapp;
inline void prework(){
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        if(!mapp[a[i]]){
            cur++;mapp[a[i]]=cur;b[cur]=a[i];
        }
    }
    for(int i=1;i<=n;i++){
        val[i]=mapp[val[i]];
    }
}
inline void dfs(int u){
    root[u]=TREE.change(root[u],1,cur,val[u],now[u]);
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].to;dfs(v);
        root[u]=TREE.merge(root[u],root[v],1,cur);
    }
    if(debug)cout<<"test"<<u<<endl;
    ans[u]=(long long)TREE.query(root[u],m,1,cur);
    if(debug){
        cout<<u<<" "<<ans[u]<<endl;
    }
}
signed main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        int x=read();addedge(x,i);
        now[i]=a[i]=val[i]=read();l[i]=read();
    }
    prework();
    //debug=true;
    dfs(1);
    long long Ans=-1;
    for(int i=1;i<=n;i++){
        //cout<<l[i]<<" "<<ans[i]<<endl;
        Ans=max(Ans,l[i]*ans[i]);
    }
    cout<<Ans<<endl;
    return 0;
}
```

---


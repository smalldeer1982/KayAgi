# [APIO2010] 特别行动队

## 题目描述

你有一支由 $n$ 名预备役士兵组成的部队，士兵从 $1$ 到 $n$ 编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号**应该连续**，即为形如 $(i, i + 1, \cdots,i + k)$ 的序列。所有的队员都应该属于且仅属于一支特别行动队。

编号为 $i$ 的士兵的初始战斗力为 $x_i$，一支特别行动队的初始战斗力 $X$ 为队内士兵初始战斗力之和，即 $X = x_i + x_{i+1} + \cdots + x_{i+k}$。

通过长期的观察，你总结出对于一支初始战斗力为 $X$ 的特别行动队，其修正战斗力 $X'= aX^2+bX+c$，其中 $a,b,c$ 是已知的系数（$a < 0$）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。

## 说明/提示

#### 样例输入输出 $1$ 解释

你有 $4$ 名士兵，$x_1 = 2,~x_2 = 2,~x_3 = 3,~x_4=4$。修正战斗力公式中的参数为  $a = -1,~b = 10,~c = -20$。

此时，最佳方案是将士兵组成 $3$ 个特别行动队：第一队包含士兵 $1$ 和士兵 $2$，第二队包含士兵 $3$，第三队包含士兵 $4$。特别行动队的初始战斗力分别为 $4,~3,~4$，修正后的战斗力分别为 $-4^2 + 10 \times 4 -20 = 4$，$-3^2 + 10 \times 3 - 20 = 1$，$-4^2 + 10 \times 4 -20 = 4$。修正后的战斗力和为 $4 + 1 + 4 = 9$，没有其它方案能使修正后的战斗力和更大。


#### 数据范围与约定

对于 $20\%$ 的数据，$n \leq 10^3$。

对于 $50\%$ 的数据，$n \leq 10^4$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$-5 \leq a \leq -1$，$-10^7 \leq b \leq 10^7$，$-10^7 \leq c \leq 10^7$，$1 \leq x_i \leq 100$。

## 样例 #1

### 输入

```
4 
-1 10 -20 
2 2 3 4 ```

### 输出

```
9```

# 题解

## 作者：VSEJGFB (赞：54)

斜率优化DP

找斜率式的方法还可以把dp方程化为kx+b=y的一次函数形式。

参考资料:http://www.cnblogs.com/MashiroSky/p/6009685.html

显然先预处理前缀和$s(i)=\sum_{k=1}^ix_i$

设$d(i)$为将前$i$个士兵分组的最大修正后战斗力。

$d(i)=max\{\ d(j)+a(s(i)-s(j))^2+b(s(i)-s(j))+c\ \}$

$d(i)=max\{\ d(j)+a\times s(i)^2-2a\times s(i)s(j)+a\times s(j)^2+b\times s(i)-b\times s(j)+c\ \}$

$d(i)=max\{\ d(j)-2a\times s(i)s(j)+a\times s(j)^2-b\times s(j)\ \}+a\times s(i)^2+b\times s(i)+c$

设
$K_i=2a\times s(i)$

$X_j=s(j)$

$B_i=d(i)-a\times s(i)^2-b\times s(i)-c$

$Y_j=d(j)+a\times s(j)^2-b\times s(j)$

直线解析式为$K_iX_j+B_i=Y_j$其中斜率$K_i$单减,$X_j$单增。

要求$d(i)$最大即求$B_i$最大，结合图像可得最优点$(X_j,Y_j)$一定在上凸包上。

用单调队列维护上凸包即可。

**代码**


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define k(A) (2*a*s[A])
#define x(A) s[A]
#define b(A) (d[A]-a*s[A]*s[A]-b*s[A]-c)
#define y(A) (d[A]+a*s[A]*s[A]-b*s[A])
using namespace std;
const int maxn=1000010;
long long d[maxn],s[maxn];
int q[maxn],n,a,b,c;
double slope(int i,int j){
    return 1.0*(y(i)-y(j))/(x(i)-x(j));
}
int main(){
    cin>>n>>a>>b>>c;
    s[0]=q[0]=d[0]=0;
    for(int i=1;i<=n;i++){
        int x;
        scanf("%d",&x);
        s[i]=s[i-1]+x;
    }
    int head=0,tail=0;
    for(int i=1;i<=n;i++){
        while(head<tail&&slope(q[head],q[head+1])>k(i)) head++;
        d[i]=-(k(i)*x(q[head])-y(q[head])-a*s[i]*s[i]-b*s[i]-c);
        while(head<tail&&slope(q[tail-1],q[tail])<=slope(q[tail],i)) tail--;
        q[++tail]=i;
    }
    cout<<d[n]<<endl;
}
    
```

---

## 作者：yunsk (赞：36)

# 	  		特别行动队（斜率优化DP）
### 首先我们预处理一个前缀和s[i],s[i]表示1~i的x[i]的和；

dp方程$f[i]$表示对于1~i的所有$x[i]$,已经分好组的最大和
### 对于50分的做法我们直接O（n^2）的枚举当前的i是从哪一个j转移过来的即可$f[i]=max{f[j]+a*(s[i]-s[j])^2+b*(s[i]-s[j])+c}$

### 对于100分的做法 考虑斜率优化假设j比k更优那么
$f[j]+a*(s[i]-s[j])^2+b*(s[i]-s[j])+c > f[k]+a*(s[i]-s[k])^2+b*(s[i]-s[k])+c$


拆开得 $f[j]+a*s[i]^2+2*s[i]*s[j]+a*s[j]^2+b*s[i]-b*s[j] > f[k]+a*s[i]^2+2*s[i]*s[k]+a*s[k]^2+b*s[i]-b*s[k]$

移项得 $2*a*s[i](s[j]-s[k])> f[k]- f[j]+ b*s[j] - b*s[k] +a * s[k]^2 -a * s[j]^2$

将左边除过去得 $s[i]>(f[k]- f[j]+ b*s[j] - b*s[k] +a * s[k]^2 -a * s[j]^2)/((s[j]-s[k])*2*a)$

以上是又来判断队首和不合法的 ；

### 接下来开始构造直线解析式 
以下参考 [ VSEJGFB](https://www.luogu.org/problemnew/solution/P3628)

假设f[i]是由f[j]转移过来的 那么 $f[i]=max{f[j]+a*(s[i]-s[j])^2+b*(s[i]-s[j])+c}$

$f[i]=max{ f[j]+a*s[i]^2+2*a*s[i]*s[j]+a*s[j]^2+b*s[i]-b*s[j] }$

$f[i]=max{	f[j]+2*s[i]*s[j]++a*s[j]^2-b*s[j] }+a*s[i]^2+b*s[i]+c ;$

开始构造直线解析式是$y = k * x + b $的形式

x 是自变量 显然应该是$ s[j]$

$  y = f[j] - a * s[j]^2 -b*s[j] -c $
 
$b$是直线的截距 另$ b =  f[i] - a * s[i]^2 -b*s[i]-c$

由于$a<0 $所以直线的斜率肯定是负的 那么我们就维护一个上凸壳

![flag](https://i.loli.net/2018/10/16/5bc5928f91b0b.png)


### 以下附上代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<cmath>
#define N 1000050
#define int long long
using namespace std;
int a,b,c,n,l,r;
int d[N],s[N],f[N],q[N];
double pd(int j,int k){
    return double( (f[j]-f[k]+a*(s[j]*s[j]-s[k]*s[k])+b*(s[k]-s[j]))/double(2*a*(s[j]-s[k])) );
}
signed main(){
    scanf("%lld%lld%lld%lld",&n,&a,&b,&c);
    for(int i=1;i<=n;i++){
        scanf("%lld",&d[i]);s[i]=s[i-1]+d[i];
    }l=1,r=1;
    for(int i=1;i<=n;i++){
        while(l<r&&pd(q[l],q[l+1])<=s[i]*1.0)l++;
        int j=q[l],x=s[i]-s[j];
        f[i]=f[j]+a*x*x+b*x+c;
        while(l<=r&&pd(q[r-1],q[r])>=pd(q[r],i))r--;
        q[++r]=i;
    }
    printf("%lld",f[n]);
}

```



---

## 作者：yybyyb (赞：22)

[如果公式挂了到CSDN上去看](http://blog.csdn.net/qq\_30974369/article/details/78308761)

又是一道斜率优化的DP题目

首先还是写出一个$O(n^{2})$的DP

```cpp
    for(int i=1;i<=n;++i)
        for(int j=0;j<i;++j)
            f[i]=max(f[i],f[j]+F(c[i]-c[j]));

```
其中$F(x)$是题目中的二次函数$c[i]$是前缀和

还是和之前是一样的

假设$j$的转移优于$k$

那么就有

$$f[j]+F(c[i]-c[j])>f[k]+F(c[i]-c[k])$$

又有
$$F(x)=Ax^{2}+Bx+C$$

直接带入得到

$$f[j]+A(c[i]-c[j])^{2}+B(c[i]-c[j])+C$$

右边同理

然后两边同时减掉一部分得

$$f[j]+Ac[j]^{2}-2Ac[i]c[j]-Bc[j]>f[k]+Ac[k]^{2}-2Ac[i]c[k]-Bc[k]$$

移项得到

$$2Ac[i](c[j]-c[k])<(f[j]+Ac[j]^{2}-Bc[j])-(f[k]+Ac[k]^{2}-Bc[k])$$

除过去搞一下

$$c[i]<\frac{(f[j]+Ac[j]^{2}-Bc[j])-(f[k]+Ac[k]^{2}-Bc[k])}{2A(c[j]-c[k])}$$

然后就可以[斜率优化](http://blog.csdn.net/qq\_30974369/article/details/78306743)直接搞了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
using namespace std;
#define ll long long
#define MAX 1010000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
ll A,B,C;
ll n,c[MAX];
ll F(ll x){return 1LL*A*x*x+1LL*B*x+C;}
ll f[MAX];
ll s[MAX],h,t;
ll sqr(ll x){return x*x;}
double count(ll j,ll k)
{
    return ((f[j]-B*c[j]+A*sqr(c[j]))-(f[k]-B*c[k]+A*sqr(c[k])))/(2.0*A*(c[j]-c[k]));
}
int main()
{
    n=read();A=read();B=read();C=read();
    for(int i=1;i<=n;++i)c[i]=c[i-1]+read();
    for(int i=1;i<=n;++i)f[i]=-1e18;
    /*
    for(int i=1;i<=n;++i)
        for(int j=0;j<i;++j)
            f[i]=max(f[i],f[j]+F(c[i]-c[j]));
    */
    for(int i=1;i<=n;++i)
    {
        while(h<t&&count(s[h],s[h+1])<=c[i]*1.0)h++;
        int get=s[h];
        f[i]=f[get]+F(c[i]-c[get]);
        while(h<t&&count(s[t-1],s[t])>=count(s[t],i))t--;
        s[++t]=i;
    }
    printf("%lld\n",f[n]);
    return 0;
}


```

---

## 作者：FlashHu (赞：12)

安利蒟蒻[斜率优化总结](https://www.cnblogs.com/flashhu/p/9480669.html)

由于人是每次都是连续一段一段地选，所以考虑直接对$x$记前缀和，设现在的$x_i=$原来的$\sum\limits_{j=1}^ix_i$。

设$f_i$为安排前$i$个人的最大值$(f_0=0)$

$f_i=\max\limits_{j=0}^{i-1}\{f_j+a(x_i-x_j)^2+b(x_i-x_j)+c\}$
$\quad=\max\limits_{j=0}^{i-1}\{f_j-2ax_ix_j+ax_j^2-bx_j\}+ax_i^2+bx_i+c$

决策$j$比$k$优当且仅当

$$f_j-2ax_ix_j+ax_j^2-bx_j\ge f_k-2ax_ix_k+ax_k^2-bx_k$$

$$\frac{f_j+ax_j^2-bx_j-(f_k+ax_k^2-bx_k)}{x_j-x_k}\ge 2ax_i$$

于是每个决策可以看成是一个点$(x_i,y_i)(y_i=f_i+ax_i^2-bx_i)$

不用考虑变号。因为$a<0$，$x_i$递增，斜率$2ax_i$递减，所以我们用单调队列维护一个下凸包就行了。依旧是维护队首为当前最优解。

当然注意这里的转移是从$0$到$i-1$，所以和土地征用有点点不一样，要先求出$f_i$再加入决策点$i$。

纯天然代码
```cpp
#include<cstdio>
#define RG register
#define R RG int
#define G c=getchar()
#define Calc(j,k) (y[j]-y[k])/(x[j]-x[k])//求斜率
const int N=1e6+9;
int q[N];
double f[N],k[N],x[N],y[N];//变量名同上
inline int in(){
	RG char G;RG bool f=0;
	while(c<'-')G;
	if(c=='-')f=1,G;
	R x=c&15;G;
	while(c>'-')x=x*10+(c&15),G;
	return f?-x:x;
}
int main(){
	R n=in(),i,h,t;
	RG double a=in(),b=in(),c=in(),now;
	for(i=h=t=1;i<=n;++i){
		x[i]=x[i-1]+in();//前缀和
		now=2*a*x[i];//当前斜率
		while(h<t&&k[h]>=now)++h;
		f[i]=-now*x[q[h]]+y[q[h]]+(a*x[i]+b)*x[i]+c;//先求fi,根据定义式求
		y[i]=f[i]+(a*x[i]-b)*x[i];//yi跟着求
		while(h<t&&k[t-1]<=Calc(q[t],i))--t;//维护凸包
		k[t]=Calc(q[t],i);q[++t]=i;
	}
	printf("%.0lf\n",f[n]);
	return 0;
}
```

---

## 作者：Siyuan (赞：10)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

## Description

> 题目链接：[Luogu 3628](https://www.luogu.org/problemnew/show/P3628)

你有一支由 $n$ 名预备役士兵组成的部队，士兵从 $1$ 到 $n$ 编号，要将他们拆分 成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号 应该连续，即为形如 $(i,i+1,\dots,i+k)$ 的序列。 编号为 $i$ 的士兵的初始战斗力为 $x_i$ ，一支特别行动队的初始战斗力 $x$ 为队内 士兵初始战斗力之和，即 $x=x_i+x_{i+1}+\cdots+x_{i+k}$。

通过长期的观察，你总结出一支特别行动队的初始战斗力 $x$ 将按如下经验公 式修正为 $x'$：$x'= ax^2+bx+c$，其中 $a,b,c$ 是已知的系数（$a<0$）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队修正后战斗力之和最大。试求出这个最大和。

数据范围：$1\le n\le 10^6$，$-5\le a\le -1$，$\vert b\vert,\vert c\vert\le 10^7$，$1\le x_i\le 100$

------

## Solution

我们先列出一个朴素的 $\texttt{DP}$ 方程，定义 $f_i$ 表示考虑到第 $i$ 个人时的战斗力之和的最大值，记 $sum_i=\sum_{k=1}^i x_k$，那么转移方程为：

$$f_i=\max\{f_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c\}\quad (0\le j<i)$$

直接转移的复杂度是 $O(n^2)$ 的，由于有平方项考虑斜率优化。

根据套路，我们任取 $j,k$ 且 $0\le k<j<i$，如果 $j$ 比 $k$ 更优，那么有：

$$f_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c\ge f_k+a(sum_i-sum_k)^2+b(sum_i-sum_k)+c$$

整理得到（注意题目中保证 $a<0$）：

$$2a\cdot sum_i\le \frac{(f_j+a\cdot{sum_j}^2-b\cdot sum_j)-(f_k+a\cdot{sum_k}^2-b\cdot sum_k)}{sum_j-sum_k}$$

我们发现，不等式左边是单调递减的，右边分母上的前缀和是单调递增的。

那么我们用单调队列维护一个**上凸壳**，斜率递减且均小于当前的 $2a\cdot sum_i$，每次的最优决策就是队首。

**时间复杂度**：$O(n)$

------

## Code

```cpp
#include <cstdio>

const int N=1e6+5;
int n,A,B,C,a[N],q[N];
long long sum[N],f[N];

long long sqr(long long x) {
    return x*x;
}
double slope(int i,int j) {
    return 1.0*((f[i]+1LL*A*sqr(sum[i])-1LL*B*sum[i])-(f[j]+1LL*A*sqr(sum[j])-1LL*B*sum[j]))/(sum[i]-sum[j]);
}
int main() {
    scanf("%d%d%d%d",&n,&A,&B,&C);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]),sum[i]=sum[i-1]+a[i];
    int l=1,r=0;
    f[0]=q[++r]=0;
    for(int i=1;i<=n;++i) {
        while(l<r&&slope(q[l],q[l+1])>=2.0*A*sum[i]) ++l;
        f[i]=f[q[l]]+1LL*A*sqr(sum[i]-sum[q[l]])+1LL*B*(sum[i]-sum[q[l]])+C;
        while(l<r&&slope(q[r-1],q[r])<=slope(q[r],i)) --r;
        q[++r]=i;
    }
    printf("%lld\n",f[n]);
    return 0;
}
```



---

## 作者：夢子電 (赞：8)

[传送门](https://www.luogu.org/problemnew/show/P3628)

题目大意：

一只队伍中有$n$个士兵，每个人的战斗力$num_i$，现要将士兵划分为若干组，每组的人为连续的一串，整个组的初始战斗力所有人之和 $y$,修正后的战斗力$y^\prime=a\cdot x^2+b\cdot x+c$ ($a,b,c$为已知常数,$a<0$)。总的战斗力
       为所有组的修正战斗力之和。要求最大化总战斗力。($n<=10^6$)
****

本题可以很容易地写出状态转移方程

$dp[i]=max(dp[j]+a\cdot(\sum_{h=j}^inum_h)^2+b\cdot\sum_{h=j}^inum_h+c)$

**对于30分做法：直接枚举能够转移到当前的 $i$ 的 $j$，区间暴力加和(时间复杂度$O(n^3)$)**    
**对于50分做法：预处理出前缀和，仍然是枚举能转移到当前 $i$ 的 $j$(时间复杂度$O(n^2)$)**

$dp[i]=max(dp[j]+a\cdot(s[i]-s[j])^2+b\cdot(s[i]-s[j])+c)$

**对于100分做法：对状态转移方程进行变形**

原状态转移方程括号内展开：

$dp[i]=max(dp[j]+a\cdot s[i]\cdot s[i]-2\cdot a\cdot s[i]\cdot s[j]+a\cdot s[j]\cdot s[j]+b\cdot s[i]-b\cdot s[j]+c)$

对于两个决策$j$，$k$ $(j>k)$：

若决策$j$比决策$k$更优，则有

$dp[j]+a\cdot(s[i]-s[j])^2+b\cdot(s[i]-s[j])+c>dp[k]+a\cdot(s[i]-s[k])^2+b\cdot(s[i]-s[k])+c$

$dp[j]-2\cdot a\cdot s[i]\cdot s[j]+a\cdot s[j]^2-b\cdot s[j]>dp[k]-2\cdot a\cdot s[i]\cdot s[k]+a\cdot s[k]^2-b\cdot s[k]$

$dp[j]-dp[k]+a\cdot s[j]^2-a\cdot s[k]^2-b\cdot s[j]+b\cdot s[k]>s[i]\cdot (2\cdot a\cdot s[j]-2\cdot a\cdot s[k])$

令：

$X(i)=2\cdot a\cdot s[i]$

$Y(i)=dp[i]+a\cdot s[i]^2-b\cdot s[i]$

$G(i,j)=dp[j]+a\cdot(s[i]-s[j])^2+b\cdot(s[i]-s[j])+c$

$K(i,j)=(Y(i)-Y(j))/(X(i)-X(j))$

由上式可得：

$(Y(j)-Y(k))>K(j,k)\cdot(X(j)-X(k))$

$(Y(j)-Y(k))/(X(j)-X(k))>K(j,k)$

**然后就可以斜率优化了**

斜率优化的经典方法：用单调队列维护决策的凸单调性

$a<0$，直线斜率为负，维护一个斜率单调递减的上凸包

谨附上本蒟蒻奇丑无比的代码：

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
typedef long long lint;
#define N 1000010
lint n,a,b,c,d[N],s[N],dp[N];
lint X(int i)
{
	return 2*a*s[i];
}
lint Y(int i)
{
	return dp[i]+a*s[i]*s[i]-b*s[i];
}
lint G(int i,int j)
{
	return dp[j]+a*s[i]*s[i]-2*a*s[i]*s[j]+a*s[j]*s[j]+b*s[i]-b*s[j]+c;
}
double K(int i,int j)
{
	return (double)(Y(i)-Y(j))/(double)(X(i)-X(j));
}
lint q[N],head,tail;
int main()
{
	scanf("%lld%lld%lld%lld",&n,&a,&b,&c);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&d[i]);
	}
	for(int i=1;i<=n;i++)
	{
		s[i]=s[i-1]+d[i];
	}
	for(int i=1;i<=n;i++)
	{
		while(head<tail&&K(q[head],q[head+1])<=s[i]) head++;
		dp[i]=G(i,q[head]);
		while(head<tail&&K(i,q[tail])<=K(q[tail],q[tail-1])) tail--;
		q[++tail]=i;
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

**( 时间复杂度$O(n)$ )**

感觉本题比较适合初学斜率优化DP做$\cdots$

---

## 作者：AC_love (赞：6)

题解很多，然而都是比较千篇一律的斜率优化。不过这道题其实也是个决策单调性优化的板子题，可以用 cdq 分治来做。

我们设 $f(i)$ 表示前 $i$ 个士兵的最大收益。

不难得到转移：

$$f(i) = \max_{j = 0}^{i - 1}\{f(j) + w(j + 1, i)\}$$

其中：

$$w(i, j) = F(\sum_{k = i} ^ {j}x_k)$$

其中：

$$F(x) = ax^2 + bx + c$$

因为我们要做的是取 $\max$ 而不是取 $\min$，因此我们需要证明 $w(i, j)$ 是否满足反过来的四边形不等式。

令 $A \le B \le C \le D$：

$$w(A, C) + w(B, D) = a(s_C - s_{A - 1}) ^ 2 + b(s_C - s_{A - 1}) + c + a(s_D - s_{B - 1}) ^ 2 + b(s_D - s_{B - 1}) + c$$

$$w(A, D) + w(B, C) = a(s_D - s_{A - 1}) ^ 2 + b(s_D - s_{A - 1}) + c + a(s_C - s_{B - 1}) ^ 2 + b(s_C - s_{B - 1}) + c$$

发现 $b$ 和 $c$ 都可以消掉，那么我们只保留带 $a$ 的项即可。

式子展开得到：

$$w(A, C) + w(B, D) = a(s_C^2 - 2s_Cs_{A - 1} + s_{A - 1} ^ 2) + a(s_D^2 - 2s_Ds_{B - 1} + s_{B - 1}^2) + ?$$

$$w(A, D) + w(B, C) = a(s_D^2 - 2s_Ds_{A - 1} + s_{A - 1} ^ 2) + a(s_C^2 - 2s_Cs_{B - 1} + s_{B - 1}^2) + ?$$

相减。

$$w(A, C) + w(B, D) - w(A, D) - w(B, C) = 2a(s_Ds_{A - 1} + s_Cs_{B - 1} - s_Cs_{A - 1} - s_Ds_{B - 1})$$

不难发现：$0 < s_{A - 1} \le s_{B - 1} < s_C \le s_D$，我们分别令其为 $s_1, s_2, s_3, s_4$。

对于等式右面，我们变形为：

$$2a(s_1s_4 + s_2s_3 - s_1s_3 - s_2s_4)$$

因式分解：

$$2a(s_1 - s_2)(s_4 - s_3)$$

三个数相乘，其中一个数大于等于 $0$，一个数小于等于 $0$，一个数严格小于 $0$，因此乘积大于等于 $0$。

但是 $a < 0$，因此：

$$w(A, C) + w(B, D) - w(A, D) - w(B, C) \ge 0$$

也就是：

$$w(A, C) + w(B, D) \ge w(A, D) + w(B, C)$$

我们发现这玩意是满足反方向的四边形不等式的，而题目刚好要求取 $\max$，因此可以直接决策单调性优化 DP。

决策单调性优化 DP 常见的方法有：单调栈和分治。此题是同一维度内从左向右转移，无法使用一般的分治法通过，不过可以使用 cdq 分治处理。

代码实现：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 100;
int n;
int a, b, c;
int x[N];
int f[N];

int F(int x) { return a * x * x + b * x + c; }
int w(int i, int j) { return F(x[j] - x[i - 1]); }
int calc(int i, int j) { return f[i] + w(i + 1, j); }

void solve(int l, int r, int L, int R)
{
    if(l > r)
        return;
    int mid = (l + r) / 2;
    int maxn = -1e18;
    int w = 0;
    for(int i = L; i <= R && i < mid; i = i + 1)
    {
        if(calc(i, mid) > maxn)
            w = i, maxn = calc(i, mid);
    }
    f[mid] = max(f[mid], maxn);
    solve(l, mid - 1, L, w);
    solve(mid + 1, r, w, R);
}

void cdq(int l, int r)
{
    if(l == r)
        return;
    int mid = (l + r) / 2;
    cdq(l, mid);
    solve(mid + 1, r, l, mid);
    cdq(mid + 1, r);
}

signed main()
{
    cin >> n;
    cin >> a >> b >> c;
    for(int i = 1; i <= n; i = i + 1)
    {
        cin >> x[i];
        x[i] += x[i - 1];
    }
    memset(f, -0x3f, sizeof(f));
    f[0] = 0;
    cdq(0, n);
    cout << f[n] << "\n";
    return 0;
}
```

---

## 作者：殇雪 (赞：5)

网上对斜率优化的解释太玄乎，我看不懂，所以用自己的方法来解释一下斜率优化：

所谓斜率优化，优化的是DP【i】=max（min）（C（i）+C（j）+K（j）\*S（i））的dp方程

其中C(i)是只跟i有关的常数，c（j）是和j有关的常数，K（j）和S(i)是分别与ij有关的函数。

整理 得 DP【i】-C（i）=K（j）\*S(i)+C(j)，我们只要求K（j）\*S(i)+C(j)的最值即可。

我们发现每一个J代表一条直线，其自变量为S(i)，且S(i)单调递增。

那么我们可以动态的维护一个直线的集合，其K依次递增，C依次递减。（当存在一条直线的K，C都比另一条小时，那它就永远不会成为最优解）。

又因为K依次递增，C依次递减，而且S(i)单调递增，那么一条直线被他后面的直线追上后，就一直比被其追上的直线小了。（两线一交点）。

那么我们就可以这样来维护一个单调队列来优化DP了吗？

答案是否定的。

我们发现了反例。

我们考虑三条直线，y1=10,y2=X+9,y3=100x+1.

显然这三条直线在单调队列中是合法的。

但我们发现 y1和y2的交点在X=1处，y1与y3的交点却在X=0.09处。

按照我们刚才的做法，当X=0.5时，我们还是误以为y1是当前的最优直线，但事实上是y3最优。

所以我们在队尾加入直线时，要判当前要加的直线与前一条直线与前一条直线的前一条直线的交点哪一个在前，如果当前直线的交点在前的话，那就可以将队尾的直线弹出了，因为它已经没有机会成为最优解了。

```cpp
#include<bits/stdc++.h>
#define B(x) (1ll*a*sum[x]*sum[x]+dp[x]-b*sum[x])//就是题解里的C（j），直线的截距，y=kx+b中的b
#define K(x) (-2ll*a*sum[x])//直线的斜率
#define N 1070001
#define LL long long
#define sight(C) (C<='9'&&C>='0')
using namespace std;
LL sum[N],q[N],n,m,x,head,tail,dp[N],a,b,c;
LL check(int x,int y) {//判断当前直线与i组合的DP值
    return dp[y]+a*(sum[x]-sum[y])*(sum[x]-sum[y])+b*(sum[x]-sum[y])+c;
} char C;int B;
double jiao(int x,int y){ //求直线的交点
    return 1.0*(B(x)-B(y))/(K(x)-K(y));
} 
LL read(LL &x) {
    C=getchar(); B=1;
    for(;!sight(C);C=getchar()) if (C=='-') B=-1;
    for(x=0;sight(C);C=getchar()) x=x*10+C-'0';
    x*=B;
}
int main () {
     read(n); 
     read(a); read(b); read(c);
        for (int i=1;i<=n;i++) 
         read(x),sum[i]=sum[i-1]+x;
        head=tail=0;
        q[tail++]=0;
        for (int i=1;i<=n;i++) {
            while (head+1<tail && check(i,q[head])<=check(i,q[head+1])) head++;//当前解被超过，将其出队
            dp[i]=check(i,q[head]);
            while (head+1<tail && jiao(q[tail-2],i)<=jiao(q[tail-1],i)) tail--;//i与q【tail-1】相比，i的交点在前，所以将q【tail-1】删除
            q[tail++]=i;
        } 
    printf("%lld\n",dp[n]);
    return 0;
}
```

---

## 作者：chenxia25 (赞：3)

>### [洛谷题目页面传送门](https://www.luogu.org/problemnew/show/P3628)

>题意见洛谷。

这题一看就是DP。。。

设$dp_i$表示前$i$个士兵的最大战斗力。显然，最终答案为$dp_n$，DP边界为$dp_0=0$，状态转移方程为$dp_i=\max\limits_{j\in[0,i)}\left\{dp_j+a\left(\sum\limits_{k=j+1}^ix_k\right)^2+b\sum\limits_{k=j+1}^ix_k+c\right\}$。
这其中要求区间和，可以先预处理出前缀和数组$Sum$。那么方程变为了$dp_i=\max\limits_{j\in[0,i)}\left\{dp_j+a(Sum_i-Sum_j)^2+b(Sum_i-Sum_j)+c\right\}$。

朴素地转移是$\operatorname{O}\left(n^2\right)$的，肯定会超时，于是要考虑优化。乍一看，这方程中$\max$的下界不动、上界在DP过程中随状态变量$i$单调递增，里面又有既和状态变量$i$又和决策变量$j$相关的项$(Sum_i-Sum_j)^2$……这不就是斜率优化的标志吗？

我们假设有两个决策变量$j,k$满足$j>k$且$j$比$k$优，那么
$$dp_j+a(Sum_i-Sum_j)^2+b(Sum_i-Sum_j)+c>dp_k+a(Sum_i-Sum_k)^2+b(Sum_i-Sum_k)+c$$
即
$$dp_j+a(Sum_i-Sum_j)^2+b(Sum_i-Sum_j)>dp_k+a(Sum_i-Sum_k)^2+b(Sum_i-Sum_k)$$
去括号，得
$$dp_j+aSum_i^2-2aSum_iSum_j+aSum_j^2+bSum_i-bSum_j>dp_k+aSum_i^2-2aSum_iSum_k+aSum_k^2+bSum_i-bSum_k$$
即
$$dp_j-2aSum_iSum_j+aSum_j^2-bSum_j>dp_k-2aSum_iSum_k+aSum_k^2-bSum_k$$
把只关于决策变量的项放到左边来，既关于状态变量又关于决策变量的项放到右边去，得
$$\left(dp_j+aSum_j^2-bSum_j\right)-\left(dp_k+aSum_k^2-bSum_k\right)>2aSum_i(Sum_j-Sum_k)$$
由于$j>k,x_i>0$，所以$Sum_j-Sum_k>0$**（这就是要设${j>k}$的原因）**，那么可以把$Sum_j-Sum_k$除到左边去且不等号方向不变（同理，设$j<k$也可以，只不过不等号要变方向），得
$$\frac{\left(dp_j+aSum_j^2-bSum_j\right)-\left(dp_k+aSum_k^2-bSum_k\right)}{Sum_j-Sum_k}>2aSum_i$$
这时，左边的东西似乎很眼熟……是什么呢……斜率！这不就相当于**以${dp_i+aSum_i^2-bSum_i}$为点${i}$的纵坐标，以${Sum_i}$为点${i}$的横坐标的直角坐标系中，点${k}$与点${j}$之间直线的斜率**吗？

我们令$f(j,k)$为这个斜率。现在设$j,k,o$是三个决策变量，满足$j>k>o$，那么若$f(j,k)\ge f(k,o)$，可以证明$k$永远不可能成为最优决策。因为当$f(j,k)>2aSum_i$时，$j$比$k$优，$k$不是最优的；当$f(j,k)\le 2aSum_i$时，结合$f(j,k)\ge f(k,o)$可以得出$f(k,o)\le 2aSum_i$，即$k$不比$o$优，此时$k$也不是最优的。

所以我们要维护一个两个元素之间的直线的斜率严格单调递减的决策序列$J$（下标从$1$开始），即一个上凸壳，只有$J$里的决策才有可能最优。

但是$J$里有那么多决策，那个才是最优的呢？如果$J$中没有一个斜率$\le2aSum_i$，即所有斜率都$>2aSum_i$，显然$J_{|J|}$是最优决策；如果有，设$J_j$是第一个$\le2aSum_i$的斜率所对应的直线的左端点，那么$J_j$是最优决策。

不难想到，我们可以维护一个单调栈充当$J$，装着对于目前的$i$，所有可能最优的决策，然后二分找到最优决策。可是在DP的过程中，$2aSum_i$也是单调递减的（因为$a<0$），也就是说今朝一个斜率$>2aSum_i$，那么它以后都要$>2aSum_i$，即它对应的直线的左端点以后都不会成为最优决策，那就把这个废点弹出吧！用一个单调队列，在每次找最优决策时，不断地弹出队首~~（自带音效biubiubiu）~~直到第$1$个斜率$\le2aSum_i$为止。这样最优决策就是队首了。

$[1,n]$内每个元素最多入队出队各一次，所以单调队列操作的总时间复杂度是$\operatorname{O}(n)$，DP也是$\operatorname{O}(n)$的，整个就是$\operatorname{O}(n)$啦！

最后再唠叨$2$句：
1. 这题用`int`会爆炸，要用`long long`。
2. 单调队列用STL里的`deque`比较慢，最好自己写。

讲了这么多，终于上代码了（逃
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//防爆int
#define N 1000000
inline int sq(int x){return x*x;}//平方
int Sum[N+1]/*前缀和*/,q[N]/*单调队列*/,dp[N+1]/*dp[i]表示前i个士兵的最大战斗力*/,a,b,c;
inline double son(int j,int k)/*纵坐标之差，即斜率的分子*/{return (dp[j]+a*sq(Sum[j])-b*Sum[j])-(dp[k]+a*sq(Sum[k])-b*Sum[k]);}
inline double ma(int j,int k)/*横坐标之差，即斜率的分母*/{return Sum[j]-Sum[k];}
inline double f(int j,int k)/*斜率*/{return son(j,k)/ma(j,k);}
signed main(){
	int n/*士兵个数*/,head=0,tail=0,i;scanf("%lld%lld%lld%lld",&n,&a,&b,&c);
	for(i=1;i<=n;i++){
		int x;scanf("%lld",&x);
		Sum[i]=Sum[i-1]+x;//预处理前缀和
	}
	q[tail++]=0;//初始有一个决策0
	for(i=1;i<=n;i++){//状态转移
		while(head+1<tail&&f(q[head+1],q[head])>2*a*Sum[i])head++;//弹出废点
		dp[i]=dp[q[head]]+a*sq(Sum[i]-Sum[q[head]])+b*(Sum[i]-Sum[q[head]])+c;//最佳决策是队首，转移
		//转移完了之后，i成了i+1的决策，压入队列
		while(head+1<tail&&f(i,q[tail-1])>=f(q[tail-1],q[tail-2]))tail--;//维护队尾单调性
		q[tail++]=i;//入队
//		printf("dp[%d]=%d\n",i,dp[i]);
	}
	printf("%lld",dp[n]);//答案为dp[n]
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：3)

## 前言
感觉各位大佬的题解已经很详细了，但是我发现我推的斜率优化不太一样，特来发一发我的解法

今天超级开心，一发过$dp$紫题。主要思路便是用斜率优化+单调队列

如不会以上两种算法请自觉看到:

1、$P3195$ $[HNOI2008]$玩具装箱$TOY$（基础斜率优化）

2、$P1886$ 滑动窗口（基础单调队列）

## 正文

先维护一个前缀和$sum$，那么易知$(l,r]$中的$x[i]$和为$sum[r]-sum[l]$

那么$dp[i]$表示前$i$个人的最大战斗力和，那么推得方程为

$$dp[i]=max(dp[i],dp[j]+a*(sum[j]-sum[i])^2+b*(sum[j]-sum[i])+c)$$

那么将这部分$dp[j]+a*(sum[j]-sum[i])^2+b*(sum[j]-sum[i])+c$来用斜率优化

设$j<k<i$，不妨令$$dp[j]+a*(sum[i]-sum[j])^2+b*(sum[i]-sum[j])+c\leq dp[k]+a*(sum[i]-sum[k])^2+b*(sum[i]-sum[k])+c$$

约去$c$得

$$dp[j]+b*(sum[i]-sum[j]-sum[i]+sum[k])\leq dp[k]+a*(sum[i]-sum[k]+sum[i]-sum[j])(sum[j]-sum[k]) $$

整理得

$$dp[j]+b*(sum[k]-sum[j])\leq dp[k]+a*(2*sum[i]-sum[k]-sum[j])(sum[j]-sum[k])$$

发现相同因式$(sum[j]-sum[k])$,移项得

$$[a*(2*sum[i]-sum[k]-sum[j])+b]*(sum[k]-sum[j])\leq dp[k]-dp[j]$$

所以得

$$a*(2*sum[i]-sum[k]-sum[j])\leq \frac{dp[k]-dp[j]}{sum[k]-sum[j]}-b$$

注意！！！$a$是负数！！！上次推斜率优化就是被这个坑了

最终得（这里$Tex$公式两层分式不好看）

$$2*sum[i]\geq \frac{(dp[k]-dp[j])/(sum[k]-sum[j])-b}{a}$$

那么我们维护一个下凸包，维护一个序号单调递增且经战斗力公式

$$a*(sum[i]-sum[j])*(sum[i]-sum[j])+b*(sum[i]-sum[j])+c+dp[j]$$

计算后的战斗力和单调递减的单调队列

补充：$long\ long$转$double$类型注意乘上$1.0$或者强行转$double$！这是上次仓库建设的惨痛教训

$Code\ Below:$
```cpp
#include <bits/stdc++.h>
#define ll long long
#define maxn 1000010
using namespace std;
ll n,a,b,c,sum[maxn];
ll dp[maxn],q[maxn],head=1,tail=1;

double slope(ll j,ll k){
	return (((((dp[k]-dp[j])*1.0/(sum[k]-sum[j]))-b)*1.0/a)+(sum[k]+sum[j])*1.0); 
}
ll calc(ll i,ll j){
	return a*(sum[i]-sum[j])*(sum[i]-sum[j])+b*(sum[i]-sum[j])+c+dp[j];
}
int main()
{
	scanf("%lld",&n);
	scanf("%lld%lld%lld",&a,&b,&c);
	for(int i=1;i<=n;i++){
		scanf("%lld",&sum[i]);
		sum[i]+=sum[i-1];
	}
	for(int i=1;i<=n;i++){
		while(head<tail&&slope(q[head],q[head+1])<=2*sum[i])
			head++;
		dp[i]=calc(i,q[head]);
		while(head<tail&&slope(q[tail],i)<=slope(q[tail-1],q[tail]))
			tail--;
		q[++tail]=i;
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

---

## 作者：Zcus (赞：2)

## 题目大意

​	给你一个序列， 将这个序列分成若干段， 每一段的贡献为 $ax ^ 2 + bx + c$(x 为 这一段的权值之和)



## 具体思路

 

------------------------------

### 50pts
​	考虑Dp， 设$Dp_i$为前i个数分成若干段的最大收益, 则$Dp[i] = max(Dp[j-1] + Cost_{i,j})\quad(j <= i)$

​	现在想$cost$ 函数怎么求得

​		设$Sum[i]$ 为 i 的前缀和， 则$cost_{i, j} = a(Sum[i] - Sum[j]) ^  2 + b (Sum[i] - Sum[j-1]) + c$   可以$O(1)$ 求得



### 100pts

​	想一想如何优化这个转移， 发现j每次都是从1 至 n , 考虑进行斜率优化

​	不妨设　x > y 且　ｘ的转移优于ｙ

​	则$Dp[x] + a(Sum[i] - Sum[x]) ^  2 + b (Sum[i] - Sum[x]) + c  > Dp[y]+ a(Sum[i] - Sum[y]) ^  2 + b (Sum[i] - Sum[y]) + c$

$\Leftrightarrow Dp[i] + a(Sum[i] ^ 2 + Sum[x] ^ 2 - 2 * Sum[i] * Sum[x]) + b(Sum[i] - Sum[x]) + c > Dp[y] + a(Sum[i] ^ 2 + Sum[y] ^ 2 - 2 * Sum[i] * Sum[x]) + b(Sum[i] - Sum[y]) + c$

$\Leftrightarrow Dp[i] + aSum[i] ^ 2 + aSum[x] ^ 2 - 2 * a * Sum[i] * Sum[x] + b Sum[i] - bSum[x ] + c > Dp[y] + a * Sum[y] ^ 2 + a * Sum[y] ^ 2  - 2aSum[i] * Sum[x] +  bSum[i] - bSum[y] + c$

移项、合并同类项得

​	$Dp[x] - Dp[y] + a(Sum[x ] ^ 2 - Sum[y] ^ 2) - b(Sum[x] - Sum[y]) > 2aSum[i](Sum[x] - Sum[y])$

$\Leftrightarrow \frac{Dp[x] - Dp[y] + a(Sun[x] ^ 2 - Sum[y] ^ 2) - b(Sum[x] - Sum[y])}{(Sum[x] - Sum[y])} > 2aSum[i]​$

$\Leftrightarrow \frac{Dp[x] + aSum[x] ^ 2 + bSum[x] - Dp[y] - aSum[y]^2 - bSum[y]}{(Sum[x] - Sum[y])} > 2aSum[i]$

​	注意：由于题面说$a < 0 ​$ 所以如果要将ａ除过去要将符号转向

不难发现左式为一个直线的点斜式，故令其为Slope(x, y)　要满足决策单调性即Slope满足单调性，　用单调队列维护即可

## 代码实现



```cpp
#pragma GCC optimize("O2")
#pragma GCC optimize("O3")

#include <cstdio>

template<class T>
inline void read(T &a){
    T s = 0, w = 1;
    char c = getchar();
    while(c < '0' || c > '9') {if(c == '-') w = -1; c = getchar();}
    while(c >= '0' && c <= '9') {s = (s << 1) + (s << 3) + (c ^ 48), c = getchar();}
    a = s * w;
}

#define maxn  1000010
static int n,s[maxn],l,r,q[maxn];
static long long a,b,c,dp[maxn];

#define A(x) (dp[x] + a * s[x] * s[x] - b * s[x])
#define P(x) (s[i] - s[x])

inline double slope(register int x, register int y){
    return 1.0 * (A(x) - A(y)) / ((s[x] - s[y]));
}

signed main(){
    read(n), read(a), read(b), read(c);
    for (register int i = 1; i <= n; i++){
        int x;
        read(x);
        s[i] = s[i-1] + x;
    }

    for (register int i = 1; i <= n; i++){
        while(l < r && slope(q[l + 1], q[l]) > 2*a*s[i]) l++;
        dp[i] = dp[q[l]] + a * P(q[l]) * P(q[l]) + b * P(q[l]) + c;
        while(l < r && slope(q[r], q[r-1]) < slope(i, q[r])) r--;
        q[++r] = i;
    }
    printf("%lld", dp[n]);
    return 0;
}
```









---

## 作者：smzzl (赞：2)

#### 就是一个斜率优化了我这里不做累赘解释其他楼讲的很清楚了，我这里给大家提几个醒

### 在推斜率方程时注意：a是<0，千万记得变号

### 为防止精度爆炸slope（斜率函数）返回时记得是double

### dp数组最好开long long（我没试过int)(估计会炸)

```cpp
#include<iostream>
using namespace std;
int n;
int a,b,c;
long long sum[1000066];
int q[1000006];
long long d[1000006];
double slope(int j,int k)
{
    int re=(((d[k]-d[j]+a*sum[k]*sum[k]-a*sum[j]*sum[j]-b*sum[k]+b*sum[j])*1.0) / (a*2.0*(sum[k]-sum[j])));
    return re;
}
int main()
{
    cin>>n;
    cin>>a>>b>>c;
    for (int i=1;i<=n;i++) {int x;cin>>x;sum[i]=sum[i-1]+x;}
    int l=0,r=0;
    for (int i=1;i<=n;i++)
        {
            while (l<r && slope(q[l],q[l+1])<sum[i]) l++;
            int p=q[l];
            d[i]=d[p]+a*(sum[i]-sum[p])*(sum[i]-sum[p])+b*(sum[i]-sum[p])+c;
            while (l<r && slope(q[r-1],q[r])>slope(q[r],i)) r--;
            q[++r]=i;
        }
    cout<<d[n];
}
```

---

## 作者：yuki_ (赞：2)

这是本人第一次发布题解，如果有错误的地方还请大佬指出。
首先，斜率优化dp，这个算法研究了两天才终于攻下来，也想借着题解巩固巩固自己学过的知识点。

------------

先推下公式：
###  首先，对于一个$N^2$算法，我们有推dp公式：
### $dp[i]$=$max(dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])$)
但是对于本题的大数据来说，N^2算法并不能顺利通过（~~卡在了奇怪的地方~~）

经过多方寻求大佬帮助，我们得到了一个斜率优化的算法。
### 斜率k的计算公式为：（y1-y2）/(x1-x2)
由上述dp方程，我们取两个i前的状态j与状态k，若j比k更优，则有：
### $dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])>dp[k]+a(sum[i]-sum[k])^2+b(sum[i]-sum[k])$
此时，左右拆括号，移项，整理可得：

### (（$dp[j]+asum[j]^2+bsum[j]$）-($dp[k]+asum[k]^2-bsum[k]$))/($sum[j]-sum[k]$)<=$2asum[i]$
(~~忘记变号倒错公式可怜的本蒟蒻~~)

不等式右侧在枚举i的情况下为定值，也是常值，而我们可以设sum[p]为自变量，$dp[p]+asum[p]^2+bsum[p]$为因变量）
### 由斜率公式可得到点坐标（$sum[p],dp[p]+asum[p]^2+bsum[p]$）


------------

## 注：下面这一段话很重要，是一直找不到解释的，大多数大佬讲解到这里时不会解释单调性，会直接贴代码：
那么，我们为什么能以O(N)的时间复杂度进行斜率优化dp呢？？？

（~~千反田：我很好奇（此处应有配音）~~）

#### 我是境界线哒-------------------------------------------------------------------------------------------

对于一个O（N）级别的算法，我们枚举每一个i，便能得到答案。

那么，对于能更新i值的dp值，我们在访问这个i值时，已经处理出了i值以前的可以用来更新i值的值，而斜率优化可以让我们保证，每次处理后的数据是最优值。

由于题目中保证a<0,我们每次得到的斜率值是一个负值，因此斜率越小，它在y轴上的截距就越大，而我们期望的dp最大值则是截距，所以我们可以维护一个单调队列，去拿每次对于当前循环下的i值之前的斜率最小值。

所以，我们要做的事情有两件：

### 1、对于队列中两个已入队的值，若他们连线的斜率大于2asum[i]的斜率的话，则不符合上述方程，故此值也不可以用来更新dp[i]值，将其弹出队列。
### 2、对于队列后的元素，我们可以进行删点处理，若后进队的元素与队尾元素的斜率要大于队尾元素与倒数第二个元素的斜率的话，也要删除队尾元素，然后放入i的时候可以直接得到倒数第二的元素与新元素的斜率,此时保证该斜率优于上一个点。
### 3、记得最开始把0扔进队列！！！！！！！
（众所周知，两件事当然要有三点了QwQ）

最后的最后：贴上本蒟蒻的lj代码：


```

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
using namespace std;
#define ll long long
const int maxn=2e6+5;
int i,j,heis[maxn],sum[maxn],que[maxn];
int head,tail;
ll dp[maxn],n;
ll a,b,c;
int size(){return tail-head;}
void push(int x)
{
	que[tail]=x;
	tail++;
	return ;
}
void pop(){head++;return;}
void slip(){tail--;return;}
int rex(int q){return sum[q];}
ll rey(int q){return dp[q]+a*sum[q]*sum[q]-b*sum[q];}
ll calc(int p,int q)
{
	return dp[q]+a*pow(sum[p]-sum[q],2)+b*(sum[p]-sum[q])+c;
}
double k(int o,int r){return (double)(rey(r)-rey(o))/(double)(rex(r)-rex(o));}
int main()
{
	ios::sync_with_stdio(false);
	freopen("xydp.in","r",stdin);
	freopen("xydp.out","w",stdout);
	cin>>n;
	cin>>a>>b>>c;
	for(i=1;i<=n;i++)
	{
		cin>>heis[i];
		sum[i]=sum[i-1]+heis[i];
	}
	tail=1;
	head=1;
	push(0);
	for(i=1;i<=n;i++)
	{
		while((size()>1)&&((k(que[head],que[head+1]))>=2*a*sum[i])){pop();}
		dp[i]=calc(i,que[head]);
		while((size()>1)&&(k(i,que[tail-1])>=k(que[tail-1],que[tail-2]))){slip();}
		push(i);
	}
	cout<<dp[n];
	return EXIT_SUCCESS;
}
------------
//wrote by yuki 2019.7.30

---

## 作者：2018heyuyang (赞：2)

这道题有一个不太一样的写法 ~~（虽然还是斜率DP）~~

我AC了这道题，然后随便翻了翻题解

Then，大家的代码怎么和我不大一样？（雾）

回到正题，我们先造一个前缀数组$sum$

然后写出$DP$转移方程:

### $f[i]=f[j]+a*(sum[i]-sum[j])^2+b*(sum[i]-sum[j])+c$ $(j<i)$

接下来解法基本上和其他的题解相同，我就直接讲我代码不一样的地方了

我们看转移方程中的那一项：$b*(sum[i]-sum[j])$

其大致意思是：$j$+$1$~ $i$ 项的总和乘上 $b$

所以，对于每一个分段，我们都可以得到一份$b*(sum[r]-sum[l])$的战斗力

然后我们将这些分段的 $b*(sum[r]-sum[l])$ 接起来，就有

$b*(sum[r1]-sum[l1])+b*(sum[r2]-sum[l2])+...+b*(sum[rk]-sum[lk])$

其中，$0=l1$，$r1=l2$，$r2=l3$，$rk=n$ (要是你们连这个都不懂，那没办法了)

我们愉快地消掉同类项，得到：

$b*(sum[n]-sum[0])=b*sum[n]$

所以这道题和 $b$ 是没什么关系的，原题便转化为求各个 $a*x^2+c$ 的最大和，最后把答案加上 $b*sum[n]$ 即可

当然，斜率方程里面也可以不用把 $b$ 给加进去了

呃，其他题解的思路也是正确的，我只是提供个新的思路而已

# 代码
```cpp
#include<cstdio>
using namespace std;
typedef long long ll;
int list[1000005],head=1,tail=1;
ll f[1000005];
ll sum[1000005],a,b,c;
ll Y(int k,int j){return f[j]-f[k]+(sum[j]*sum[j]-sum[k]*sum[k])*a;}
ll X(int k,int j){return sum[j]-sum[k];}
double slop(int j,int k){return ((double)Y(j,k))/((double)X(j,k));}
int main()
{
	int n;scanf("%d%lld%lld%lld",&n,&a,&b,&c);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&sum[i]);
		sum[i]+=sum[i-1];
	}
	list[1]=0;
	for(int i=1;i<=n;i++)
	{
		while(head<tail&&slop(list[head],list[head+1])>(double)(2.0*a*sum[i]))head++;
		int j=list[head];
		f[i]=f[j]+(sum[i]-sum[j])*(sum[i]-sum[j])*a+c;
		while(head<tail&&slop(list[tail-1],list[tail])<slop(list[tail],i))tail--;
		list[++tail]=i;
	}
	printf("%lld\n",f[n]+sum[n]*b);
	return 0;
}
```


---

## 作者：HoshiuZ (赞：1)

你有一支由$n$名预备役士兵组成的部队，士兵从$1$到$n$编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号**应该连续**，即为形如$(i, i + 1, \cdots i + k)$的序列。所有的队员都应该属于且仅属于一支特别行动队。

编号为$i$的士兵的初始战斗力为$x_i$，一支特别行动队的初始战斗力$X$为队内士兵初始战斗力之和，即$X = x_i + x_{i+1} + \cdots + x_{i+k}$。

通过长期的观察，你总结出对于一支初始战斗力为$X$的特别行动队，其修正战斗力$X'= aX^2+bX+c$，其中$a,b,c$是已知的系数$(a < 0)$。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。
### 链接

[[APIO2010]特别行动队](https://www.luogu.com.cn/problem/P3628)

### 思路

由于**同一支特别行动队中队员的编号应该连续**，那么就比较好想了。

定义$dp[i]$表示前$i$名队员已经分属于各自的行动队，目前所有行动队的修正战斗力之和的最大值。

于是可以从$[0,i)$队员中枚举$j$，使得第$j+1$名队员到第$i$名队员属于一个行动队。

那么
$$
dp[i]=max\{dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c\},c\in[0,i)
$$
其中$sum$为$x$的前缀和。初始化$dp[0]=0$，其余均为一个极小的负值。

于是可以得到一个$O(n^2)$的算法，TLE。

```cpp
#include<bits/stdc++.h>
#define N 1000010
#define ll long long

using namespace std;

int n;
ll a,b,c,x[N],sum[N],dp[N];

int main() {
	cin>>n;
	cin>>a>>b>>c;
	for(int i=1;i<=n;i++) {
		cin>>x[i];
		sum[i]=sum[i-1]+x[i];
	}
	
	memset(dp,~0x3f,sizeof(dp));
	dp[0]=0;
	for(int i=1;i<=n;i++) {
		for(int j=0;j<i;j++) {
			ll X=(sum[i]-sum[j]);
			dp[i]=max(dp[i],dp[j]+a*X*X+b*X+c);
		}
	}
	
	cout<<dp[n]<<endl;
	
	return 0;
}
```

将$max$内的式子单独提出来看看

$dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c$

$=dp[j]+a(sum[i]^2-2sum[i]sum[j]+sum[j]^2)+b(sum[i]-sum[j])+c$

$=dp[j]+a\times sum[j]^2-b\times sum[j]-2a\times sum[i]sum[j]+a\times sum[i]^2+b\times sum[i]+c$

剔除掉求状态$i$时的常量项，则为

$dp[j]+a\times sum[j]^2-b\times sum[j]-2a\times sum[i]sum[j]$

定义$f[i]=a\times sum[i]^2-b\times sum[i]$，则原式可化为

$dp[j]+f[j]-2a\times sum[i]sum[j]$

则
$$
dp[i]=max\{dp[j]+f[j]-2a\times sum[i]sum[j]\}+a\times sum[i]^2+b\times sum[i]+c
$$
将$max$内提出来

$dp[j]+f[j]-2a\times sum[i]sum[j]$，发现$sum[j]$这一项，其系数为常量。

于是该式子可以看做一斜率为$2a\times sum[i]$的过点$(sum[j],dp[j]+f[j])$的直线与$y$轴的截距，于是定义决策点$i(sum[i],dp[i]+f[i])$。

那么问题就转化为求一个最大的截距，于是需要维护一个上凸壳。

明显$sum$具有单调性。

于是令$k<j<i$，若转移决策$j$比转移决策$k$更优的话，则

$dp[j]+f[j]-2a\times sum[i]sum[j]\ge dp[k]+f[k]-2a\times sum[i]sum[k]$

$dp[j]+f[j]-(dp[k]+f[k])\ge 2a\times sum[i](sum[j]-sum[k])$

因为$j>k$且$sum$单调递增，则

$\frac{dp[j]+f[j]-(dp[k]+f[k])}{sum[j]-sum[k]}\ge 2a$ 式①

而若要维护上凸壳，则其具有上凸性，即满足$j_1<j_2<j_3$，则决策点$j_1$与$j_2$之间连线段的斜率大于决策点$j_2$与$j_3$之间的斜率，即

$\frac{dp[j_2]+f[j_2]-(dp[j_1]+f[j_2])}{sum[j_2]-sum[j_1]}>\frac{dp[j_3]+f[j_3]-(dp[j_2]+f[j_2])}{sum[j_3]-sum[j_2]}$ 式②

于是用单调队列维护上凸壳，用式①保持队头为最优决策点，用式②维护上凸壳即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define N 1000010
#define ll long long

using namespace std;

int n,q[N],head=1,tail=1;
ll a,b,c,x[N],sum[N],dp[N],f[N];

int main() {
	cin>>n;
	cin>>a>>b>>c;
	for(int i=1;i<=n;i++) {
		cin>>x[i];
		sum[i]=sum[i-1]+x[i];
		f[i]=a*sum[i]*sum[i]-b*sum[i];
	}
	
	memset(dp,~0x3f,sizeof(dp));
	dp[0]=0,q[0]=0;
	for(int i=1;i<=n;i++) {
		while(head<tail&&dp[q[head+1]]+f[q[head+1]]-dp[q[head]]-f[q[head]]>=2*a*sum[i]*(sum[q[head+1]]-sum[q[head]])) head++;
		dp[i]=dp[q[head]]+f[q[head]]-2*a*sum[i]*sum[q[head]]+a*sum[i]*sum[i]+b*sum[i]+c;
		while(head<tail&&(dp[q[tail]]+f[q[tail]]-dp[q[tail-1]]-f[q[tail-1]])*(sum[i]-sum[q[tail]])<=(dp[i]+f[i]-dp[q[tail]]-f[q[tail]])*(sum[q[tail]]-sum[q[tail-1]])) tail--;
		q[++tail]=i;
	}
	
	cout<<dp[n]<<endl;
	
	return 0;
}
```


---

## 作者：Thomasguo666 (赞：1)

首先这种有区间和的题，前缀和是逃不掉了。

设
$$S_i=\sum_{j=1}^ia_i$$

我们可以先列一个简单的dp方程:
$$
f(i)=\min_{j=1}^{i-1} \{A(S_i-S_j)^2+B(S_i-S_j)+C\}
$$
先去掉$min$符号，然后整理：
$$
2AS_iS_j-AS_i^2-BS_i-C+f(i)=f(j)+AS_j^2-BS_j
$$
我们把所有与$i$有关的全部项移到左边，其余移到右边。并且以$j$为主元，把$j$和$S_j$等看作变量，其余看作常数。然后我们确保$2AS_i$为正数。（为了方便，我们把$A$，$B$，$C$均乘以$-1$，然后求$f(i)$的最小值）

接下来我们构造$i-1$个点，形如$(S_j,f(j)+AS_j^2-BSj) (1\leq j \leq i-1)$，称为“决策点”。 设第$k$个点为$P_k$。(其实本来应该有n个决策点的，不过计算$f(i)$时$P_i,P_{i+1}\cdots P_n$都没有用)

我们让一条斜率为$2AS_i$的直线依次经过这$i-1$个点，然后找到使它在$y$轴上的截距最小的点即可。

注意到当直线$P_{j-1}P_j$的斜率大于$P_jP_{j+1}$时，$P_j$一定不是我们要找的点，所以我们可以用单调队列来维护所有的决策点，每次插入一个新决策点时，先检查它与队首构成的直线的斜率，以及队首的两个点构成的直线的斜率，如果不对就把队首扔掉，并继续。（详见代码）

![](https://cdn.luogu.com.cn/upload/pic/60134.png)

这个不对

![](https://cdn.luogu.com.cn/upload/pic/60135.png)

这个对



并且，如果$P_{j-1}Pj$的斜率大于$2AS_i$，说明$P_{j-1}$优于$P_j$。如果$P_jP_{j+1}$的斜率小于$2AS_i$，说明$P_{j+1}$优于$P_j$。因此，如果有三个点$P_{j-1}$,$P_j$,$P_{j+1}$，满足$K_{P_{j-1}P_j}<2AS_i\leq K_{P_jP{j+1}}$，那么$P_j$就是最优决策点。在本题中，由于$2AS_i$单调递增，所以若$P_jP_{j+1}$的斜率小于$2AS_i$，就可以把$P_j$扔掉，这样队尾永远是当前最优的决策点。但是，在某些问题中，斜率并不是单调递增的，这时不能把队尾扔掉，而是每次要使用二分查找的技巧，找到第一条斜率不小于$2AS_i$的直线。

然后就看代码吧：

```cpp
#include <bits/stdc++.h>
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define in inline
#define re register
#define sqr(i) (ll((i))*(i))
#define F(i) (A*sqr(s[(i)])-B*s[(i)]+f[(i)])
using namespace std;
typedef long long ll;
typedef double db;
in int read()
{
    int ans=0,f=1;char c=getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=-1;
    for (;isdigit(c);c=getchar()) ans=(ans<<3)+(ans<<1)+(c^48);
    return ans*f;
}
int a[1000005],s[1000005];
int q[1000005],l,r;
ll f[1000005];
ll A,B,C;
// f(i)=f(j)+A(s[i]-s[j])^2+B(s[i]-s[j])+C
//     =f(j)+A*s[i]^2-2As[i]s[j]+As[j]^2+Bs[i]-Bs[j]+C
// 2As[i]s[j]-As[i]^2-Bs[i]-C+f(i)=f(j)+As[j]^2-Bs[j]
int main()
{
    int n=read();
    A=-read(),B=-read(),C=-read();
    for (int i=1;i<=n;i++) a[i]=read(),s[i]=s[i-1]+a[i];
    l=r=1;
    for (int i=1;i<=n;i++)
    {
        while (r>l && (F(q[l+1])-F(q[l]))<2*A*s[i]*(s[q[l+1]]-s[q[l]])) l++;
        f[i]=f[q[l]]+A*sqr(s[i]-s[q[l]])+B*(s[i]-s[q[l]])+C;
        while (r>l && (F(q[r])-F(q[r-1]))*(s[i]-s[q[r]])>(F(i)-F(q[r]))*(s[q[r]]-s[q[r-1]])) r--;
        q[++r]=i;
    }
    cout<<-f[n]<<endl;
    return 0;
}

```









---

## 作者：VenusM1nT (赞：1)

居然自己推出来了一次斜率优化，热泪盈眶（雾）

然后不小心维护凸壳的时候大于号写错了……哭了

进入正题，这道题的转移方程还是很明显的（$sum$记录前缀和）：

$$f[i]=\sum_{j=1}^{i-1}max(f[j]+a\times (sum[i]-sum[j])^2+b\times (sum[i]-sum[j])+c)$$

首先很明显，这个东西是$n^2$的，必然会$T$掉，所以考虑斜率优化

（但是我这种菜鸡只会用 不很懂原理）

假定决策$j$比$k$更优，当且仅当：

$$f[j]+a\times(sum[i]-sum[j])^2+b\times (sum[i]-sum[j])+c>$$

$$f[k]+a\times(sum[i]-sum[k])^2+b\times(sum[i]-sum[k])+c\quad\  $$

（预防超出边界只能这么写了$QAQ$）

拆开来如下：

$$f[j]+a\times sum[i]^2+2a\times sum[i]\times sum[j]+a\times sum[j]^2+b\times sum[i]-b\times sum[j]+c >$$

$$f[k]+a\times sum[i]^2+2a\times sum[i]\times sum[k]+a\times sum[k]^2+b\times sum[i]-b\times sum[k]+c\quad$$

（好多式子啊(╯‵□′)╯︵┻━┻）

硬着头皮移项，把同时和$i,j$有关的项和同时与$i,k$有关的项移到一边，其他的全部丢到另一边，同类项合并一下，结果如下：

$$2a\times sum[i]\times (sum[j]-sum[k])>$$

$$a\times (sum[k]^2-sum[j]^2)+b\times (sum[j]-sum[k])+(f[k]-f[j])$$

令左式（其实是上式）只与$i$有关，则可得：

$$sum[i]>\frac{a\times (sum[k]^2-sum[j]^2)+b\times (sum[j]-sum[k])+(f[k]-f[j])}{2a\times (sum[j]-sum[k])}$$

然后我们就$get$了斜率怎么算（右边那坨）

接着我们考虑维护的是上凸壳还是下凸壳，首先回头看之前的转移方程，把它拆开应该是这样的：

$$f[i]=\sum_{j=1}^{i-1}max(f[j]+a\times sum[i]^2-2a\times sum[i]\times sum[j]+a\times sum[j]^2+b\times sum[i]-b\times sum[j]+c)$$

设直线为：

$$y=kx+b$$

因为$x$是自变量，所以令$x$等于$sum[j]$，既然$x=sum[j]$，令$k=2a\times sum[i]$，令$y=f[j]+a\times sum[j]^2$，$b=f[i]-a\times sum[i]^2-b\times sum[i]-c$，可以发现斜率$k$单调递减（因为$a<0$），因此维护上凸壳即可

见代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
ll a,b,c;
ll sum[1000005],f[1000005],q[1000005];
double Slope(int x,int y)
{
	return (double)(a*(sum[x]*sum[x]-sum[y]*sum[y])+b*(sum[y]-sum[x])+f[x]-f[y])/(double)(a*2*(sum[x]-sum[y]));
}
int main()
{
	scanf("%d",&n);
	scanf("%lld %lld %lld",&a,&b,&c);
	for(int i=1;i<=n;i++)
	{
		ll x;
		scanf("%lld",&x);
		sum[i]=sum[i-1]+x;
	}
	int head=1,tail=1;
	for(int i=1;i<=n;i++)
	{
		while(head<tail && Slope(q[head],q[head+1])<=sum[i]) head++;
		f[i]=f[q[head]]+a*(sum[i]-sum[q[head]])*(sum[i]-sum[q[head]])+b*(sum[i]-sum[q[head]])+c;
		while(head<tail && Slope(q[tail-1],q[tail])>=Slope(q[tail],i)) tail--;
		q[++tail]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

---

## 作者：aiyougege (赞：1)

### P3628 [APIO2010]特别行动队
#### Solution
$$f(i)=\max f(j)+a\left(\sum_{k=j+1}^ix_k\right)^2+b\sum_{k=j+1}^ix_k+c$$
因为这么表示不是很方便, 则用$x_j$代替$\sum\limits{k=j+1}^ix_k$.则式子变为
$$f(i)=\max f(j)+ax_j^2+bx_j+c$$
若$f(j)$比$f(k)$转移到$f(i)$更优, 则
$$f(j)+ax_j^2+bx_j+c>f(k)+ax_k^2+bx_k+c$$
将$x_j$表示成前缀和的$s_i-s_j$的形式, 则式子进一步变为
$$s_i<\frac{f(j)-f(k)+as_j^2-as_k^2-bs_j+bs_k}{2as_j-2as_k}$$
则可以用**斜率优化**优化转移.单调队列每个点只会被插入删除一次, 均摊复杂度$O(n)$.
#### Code
需要用long long, 不用会出神奇错误.
```c++
#include<iostream>
#include<cstdio>
#define N 1000005
#define int long long
using namespace std;

int a,b,c,d[N],s[N];
int q[N],f[N];
int h,t;
int n;

double slope(int j,int k){
    return (double)(f[j]-f[k]+a*s[j]*s[j]-a*s[k]*s[k]-b*s[j]+b*s[k])/(double)(2*a*s[j]-2*a*s[k]);
}

main(){
    h=t=1;
    scanf("%lld",&n);
    scanf("%lld%lld%lld",&a,&b,&c);
    for(int i=1;i<=n;++i)scanf("%lld",&d[i]);
    for(int i=1;i<=n;++i)s[i]=s[i-1]+d[i];//前缀和
    for(int i=1;i<=n;++i){
        while(h<t&&slope(q[h],q[h+1])<=s[i]*1.0)++h;//不满足式子的去掉
        int j=q[h],x=s[i]-s[j];
        f[i]=f[j]+a*x*x+b*x+c;//算出dp值
        while(h<t&&slope(q[t-1],q[t])>=slope(q[t],i))--t;//将f[i]加入单调队列
        q[++t]=i;
    }
    printf("%lld",f[n]);
    return 0;
}
```

---

## 作者：ModestCoder_ (赞：1)

斜率优化

令$s_i=\sum_{j=1}^{i}x_j$

写出暴力DP方程：$dp_i=max(dp_j+a(s_i-s_j)^2+b(s_i-s_j)+c)$

按照套路

如果存在两个决策$x,y(x>y)$，x比y更优必须满足

$dp_x+a(s_i-s_x)^2+b(s_i-s_x)+c>dp_y+a(s_i-s_y)^2+b(s_i-s_y)+c$

化简得$\frac{(dp_x+as_x^2)-(dp_y+as_y^2)}{s_x-s_y}>b+2as_i$

单调性比较乱，发现$a<0$，两边乘个-1

得$-\frac{(dp_x+as_x^2)-(dp_y+as_y^2)}{s_x-s_y}<-b-2as_i$

右边部分是个递增的，所以可以维护斜率递增的单调队列

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
#define LL long long
using namespace std;
LL n, A, B, C, s[maxn], q[maxn], dp[maxn];

inline LL read(){
	LL s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
} 

LL sqr(LL x){ return x * x; }
LL F(LL x){ return A * sqr(x) + B * x + C; }
double slope(int x, int y){ return -1.0 * (dp[x] + A * sqr(s[x]) - dp[y] - A * sqr(s[y])) / (s[x] - s[y]); }

int main(){
	n = read(), A = read(), B = read(), C = read();	
	for (int i = 1; i <= n; ++i) s[i] = read() + s[i - 1];
	int h = 0, t = 0;
	for (int i = 1; i <= n; ++i){
		while (h < t && slope(q[h + 1], q[h]) < (- B - 2LL * A * s[i])) ++h;
		dp[i] = dp[q[h]] + F(s[i] - s[q[h]]);
		while (h < t && slope(q[t], q[t - 1]) > slope(i, q[t])) --t;
		q[++t] = i;
	}
	printf("%lld\n", dp[n]);
	return 0;
}
```


---

## 作者：Binah_cyc (赞：0)

看见题解区没有用李超树的，我当然要来水水咕值了。

套路的，我们先写暴力的 dp 式子。

$dp_i=\displaystyle \min _{j=0}^{i-1}\{dp_j+a\times (sum_i-sum_j)^2+b \times (sum_i-sum_j)+c\}$

然后，让我们把它完全展开以方便优化。

$dp_i=dp_j+a\times sum_i^2+a \times sum_j^2-2a\times sum_i\times sum_j+b\times sum_i-b\times sum_j+c$

我们发现其中只有一项同时和 $i$ 与 $j$ 相关，很明显的斜率优化。我们把它美化一下。

$dp_i=-2a\times sum_j\times sum_i+dp_j+a \times sum_j^2-b\times sum_j+a\times sum_i^2+b\times sum_i+c$

这个时候斜率优化的式子就很明显了，令 $y=dp_i,k=-2a\times sum_j,x=sum_i,b=a \times sum_j^2-b\times sum_j$，那它就是函数取最值的板子，可以使用李超树维护。

还有一点小细节就是李超树不能动态开点，否则会炸空间，需要将 $x$ 的取值离散化之后再插到李超树里面。

下面给出我的实现并不精细的代码。

```cpp
// Problem: P3628 [APIO2010] 特别行动队
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3628
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Author: Binah_cyc

#include<bits/stdc++.h>
using namespace std;
#define int long long
constexpr int N=1e6+5;
int n,A,B,C,a[N];
vector<int> b;

struct Segment
{
	int k,b;
	int operator()(int x){return k*::b[x]+b;}
	Segment(int _k=0,int _b=INT_MIN){k=_k,b=_b;}
}t[N<<2];
void change(Segment id,int tl=1,int tr=n,int p=1)
{
	int mid=(tl+tr)>>1;
	if(t[p](mid)<id(mid)) swap(t[p],id);
	if(t[p](tl) <id(tl) ) change(id,tl,mid,p<<1);
	if(t[p](tr) <id(tr) ) change(id,mid+1,tr,p<<1|1);
}
int ask(int x,int tl=1,int tr=n,int p=1)
{
	if(tl==tr) return t[p](x);
	int mid=(tl+tr)>>1;
	if(x<=mid) return max(t[p](x),ask(x,tl,mid,p<<1));
	else return max(t[p](x),ask(x,mid+1,tr,p<<1|1));
}
//以上是李超树板子,我实现的可能有点丑

int dp[N];

main()
{
	cin.tie(0)->sync_with_stdio(false);
	cin>>n>>A>>B>>C;
	for(int i=1;i<=n;i++) cin>>a[i],a[i]+=a[i-1];
	b.push_back(-1);
	for(int i=1;i<=n;i++) b.push_back(a[i]);
	sort(b.begin(),b.end()),b.erase(unique(b.begin(),b.end()),b.end());
	change({0,0});//它代表dp[0]
	for(int i=1;i<=n;i++)
	{
		dp[i]=ask(lower_bound(b.begin(),b.end(),a[i])-b.begin())+A*a[i]*a[i]+B*a[i]+C;//转移
		change({-2*A*a[i],dp[i]+A*a[i]*a[i]-B*a[i]});//插线段
	}
	cout<<dp[n];
	return 0;
}
```

---

## 作者：little_sun (赞：0)

斜率优化的练手题

通读题目可以发现

$$
f_i=\max \{f_j+g(s[i]-s[j])\}
$$

其中$f_i$表示在i处强制结束一段的最大代价,$s_i$表示$a_i$的前缀和,$g(x)$表示$(ax^2+bx+c)$

展开这个式子我们得到
$$
f_i=\max\{f_j+as_i^2-2as_is_j+as_j^2+bs_i-bs_j+c\}
$$
去掉$\max$，移项得到:
$$
(f_j+as_j^2-bs_j)=2as_is_j+(f_i-as_i^2-bs_i-c)
$$

然后就是常规的单调队列维护凸壳了

```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define sum(a, b, mod) (((a) + (b)) % mod)

const int MaxN = 1e6 + 10;

ll n, A, B, C;
ll a[MaxN], s[MaxN], f[MaxN], q[MaxN];

inline ll read()
{
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0')
    {
        if (ch == '-')
            f = 0;
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return f ? x : (-x);
}

ll g(int num) { return A * num * num + B * num + C; }
ll x(int num) { return s[num]; }
ll y(int num) { return (f[num] + A * s[num] * s[num] - B * s[num]); }
ll k(int num) { return 2 * A * s[num]; }

int main()
{
    n = read(), A = read(), B = read(), C = read();
    for (int i = 1; i <= n; i++)
        a[i] = read(), s[i] = s[i - 1] + a[i];
    int l = 1, r = 1;
    for (int i = 1; i <= n; i++)
    {
        while (l < r && (y(q[l + 1]) - y(q[l])) >= k(i) * (x(q[l + 1]) - x(q[l])))
            ++l;
        f[i] = f[q[l]] + g(s[i] - s[q[l]]);
        while (l < r && (y(q[r]) - y(q[r - 1])) * (x(i) - x(q[r])) <= (y(i) - y(q[r])) * (x(q[r]) - x(q[r - 1])))
            --r;
        q[++r] = i;
    }
    printf("%lld\n", f[n]);
    return 0;
}

```



---

## 作者：Tgotp (赞：0)

首先读题后第一感觉这是个dp；

然后我们继续看到方程 =》一般来说这种题就可以用斜率优化了。

然后我们很容易推导得到f[i] = max(f[j]+a(s[i]-s[j])^2+b(s[i]-s[j])+c；

设k < j且j优于k；

即有：f[j]+a(s[i]-s[j])^2+b(s[i]-s[j])+c >= f[k]+a(s[i]-s[k])^2+b(s[i]-s[k])+c；

展开得到：(f[j]-f[k] + a\*(pow(s[j])-pow(s[k]))+b\*(s[k]-s[j]))/(2.0\*a\*(s[j]-s[k])) < s[i]（这里复制的底下代码，懒得打了QAQ）

然后就套斜率优化就好了；

ok；

c++代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
typedef long long ll;
deque<int>q;
const int N = 1e6 + 10;
int z[N],n,a,b,c;
ll s[N],f[N];
inline void read(int&x){
    x = 0;int sign = 1;char c;
    do{ c = getchar();if(c == '-') sign = -1; }while(c < '0' || c >'9');
    do{ x = x*10 + c - '0';c = getchar(); }while(c <= '9' && c >='0');
    x*=sign;
}
inline ll pow(ll x){ return x*x; }
inline double slop(int k,int j){ return (double)(f[j]-f[k] + a*(pow(s[j])-pow(s[k]))+b*(s[k]-s[j]))/(2.0*a*(s[j]-s[k])); }
int main()
{
    read(n);read(a);read(b);read(c);
    for(int i = 1;i <= n;i++) read(z[i]),s[i] = s[i-1] + z[i];
    q.push_back(0);
    for(int i = 1;i <= n;i++)
    {
        while(q.size() > 1 && slop(q[0],q[1]) < s[i]) q.pop_front();
        int x = q.front(),j,t=s[i]-s[x];
        f[i] = f[x] + a*t*t + b*t+c;
        while((j = q.size())> 1 && slop(q[j-1],i) < slop(q[j-2],q[j-1])) q.pop_back();
        q.push_back(i);
    }
    cout<<f[n];
    return 0;
}
另外安利下我的blog：< http://tgotp.science >
```

---

## 作者：ljk123 (赞：0)

# 特别行动队题解
~~刷水题什么的最愉快了。~~

题意十分明了，就是选出一种分配方案将士兵分为若干组，使修正后的战斗力最大。

我们先可以写出暴力dp转移：

设$f[n]$为将前$i$个士兵分组，且第$i$个士兵为最后一组最后一个的最大战斗力。

$f[i]=max_{j=1}^{j<i}f[j]+a*\sum_{k=j+1}^{k<=i}x[k] *\sum_{k=j+1}^{k<=i}x[k] +b*\sum_{k=j+1}^{k<=i}x[k] +c$

时间复杂度:$O(n^3)$

设前缀和$sum[i]=\sum_{j=1}^{j<=i}x[j]$

则化为：$f[i]=max_{j=1}^{j<i}f[j]+a*(sum[i]-sum[j])*(sum[i]-sum[j])+b*(sum[i]-sum[j])+c$

最后斜率优化一下：

拆开平方，移项：

$f[i]-a*sum[i]*sum[i]-b*sum[i]-c+2*sum[i]*sum[j]=f[j]+a*sum[j]*sum[j]-b*sum[j]$

其中:

$\bullet y=f[j]+a*sum[j]*sum[j]-b*sum[j]$

$\bullet k=2*sum[i]$

$\bullet x=sum[j]$

$\bullet b=f[i]-a*sum[i]*sum[i]-b*sum[i]-c$

$\therefore f[i]=y-kx+a*sum[i]*sum[i]+b*sum[i]+c$

![解释](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190822154327907-790036712.png)
代码：
``` cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=1000006;
int n,head=1,tail=1;
ll f[N],sum[N],ans=0,a,b,c,t;
struct point{ll x,y;}tmp,q[N];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T; 
}
bool check(point u,point v,int z){return v.y-u.y>=2*a*sum[z]*(v.x-u.x);}
bool check2(point u,point v,point z){return (v.y-u.y)*(z.x-v.x)<=(z.y-v.y)*(v.x-u.x);}
int main(){
    n=read(),a=read(),b=read(),c=read();
    q[tail].x=0,q[tail].y=0;
    for(int i=1;i<=n;++i){
        t=read(),sum[i]=sum[i-1]+t;
        while(head<tail&&check(q[head],q[head+1],i)) ++head;
        f[i]=a*sum[i]*sum[i]+b*sum[i]+q[head].y-2*a*sum[i]*q[head].x+c,ans=max(ans,f[i]),tmp.x=sum[i],tmp.y=f[i]+a*sum[i]*sum[i]-b*sum[i];
        while(head<tail&&check2(q[tail-1],q[tail],tmp)) --tail;
        q[++tail]=tmp;
    } 
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：_Sein (赞：0)

## 题面描述
[传送门](https://www.luogu.org/problemnew/show/P3628)

## 思路
## 状态转移方程

应该很好想:

设$s$为战斗力前缀和，那么有

$$F_i=\max(F_j+a*(s_i-s_j)^2+b*(s_i-s_j)+c)$$

## 决策单调性
设有
$$F_k+a*(s_i-s_k)^2+b*(s_i-s_k)+c\ge F_j+a*(s_i-s_j)^2+b*(s_i-s_j)+c$$

化简为

$$F_k-2*a*s_i*s_k+a*{s_k}^2-b*s_k\ge F_j-2*a*s_i*s_j+a*{s_j}^2-b*s_j$$

对于未来状态$t$，证明:

$$F_k+a*(s_t-s_k)^2+b*(s_t-s_k)+c\ge F_j+a*(s_t-s_j)^2+b*(s_t-s_j)+c$$

化简为

$$F_k-2*a*s_t*s_k+a*{s_k}^2-b*s_k\ge F_j-2*a*s_t*s_j+a*{s_j}^2-b*s_j$$

由于$s_t=s_i+val$，则

$$F_k-2*a*(s_i+val)*s_k+a*{s_k}^2-b*s_k\ge F_j-2*a*(s_i+val)*s_j+a*{s_j}^2-b*s_j$$

根据

$$F_k-2*a*s_i*s_k+a*{s_k}^2-b*s_k\ge F_j-2*a*s_i*s_j+a*{s_j}^2-b*s_j$$

只需要证明

$$-2*a*val*s_k\ge-2*a*val*s_j$$

由于$a<0,val>0,s_k>s_j$，可知:

$$val*s_k\ge val*s_j$$

证毕。

## 踢队头
根据上文，

$$F_k-2*a*s_i*s_k+a*{s_k}^2-b*s_k\ge F_j-2*a*s_i*s_j+a*{s_j}^2-b*s_j(k>j)$$

$$F_j-F_k+a*{s_j}^2-a*{s_k}^2-b*s_j+b*s_k\le 2*a*s_i*s_j-2*a*s_i*s_k$$

$$(F_j+a*{s_j}^2-b*s_j)-(F_k+a*{s_k}^2-b*s_k)\le 2*a*s_i*(s_j-s_k)$$

由于$s_j-s_k<0,a<0$，所以

$$calc(j,k)=\frac{(F_j+a*{s_j}^2-b*s_j)-(F_k+a*{s_k}^2-b*s_k)}{a*(s_j-s_k)}\le2*s_i$$

当$calc(j,k)\le 2*s_i$时，$k$优于$j$.

因此当$$calc(q_{head},q_{head+1})\le 2*s_i$$

$head+1$优于$head$。

由于$s_i$随$i$增大而增大，那么$calc(q_{head},q_{head+1})$随$head$增大而增大，才符合$head$为最优解，因此斜率是不断递增的。

## 踢队尾
根据斜率是不断递增的，仅当

$$calc(q_{tail},i)\ge calc(q_{tail-1},q_{tail})$$

斜率才满足不断递增。

故当

$$calc(q_{tail},i)\le calc(q_{tail-1},q_{tail})$$

删去队尾。

## AC code
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#define gc getchar()
#define ll long long
using namespace std;
const int N=1e6+10;
inline void qr(ll &x)
{
	x=0;int f=1;char c=gc;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
inline void qw(ll x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll s[N],a,b,c,f[N];
int q[N],l,r;
inline double calc(int j,int k)
{
	return ((f[j]+a*s[j]*s[j]-b*s[j])-(f[k]+a*s[k]*s[k]-b*s[k]))/(double)(a*(s[j]-s[k]));
}
int main()
{
	int n;scanf("%d",&n);
	qr(a),qr(b),qr(c);
	for(int i=1;i<=n;i++)qr(s[i]),s[i]+=s[i-1];
	l=1;r=1;q[1]=0;
	for(int i=1;i<=n;i++)
	{
		while(l<r&&calc(q[l],q[l+1])<=2.0*s[i])++l;
		f[i]=f[q[l]]+a*(s[i]-s[q[l]])*(s[i]-s[q[l]])+b*(s[i]-s[q[l]])+c;
		while(l<r&&calc(q[r],i)<=calc(q[r-1],q[r]))--r;
		q[++r]=i;
	}
	qw(f[n]);puts("");
	return 0;
}
```

---

## 作者：zrz_orz (赞：0)

## [APIO2010]特别行动队

这道题可以先推一下DP的式子

记 sum[i] 初始的前缀和

则有

$$
dp[i] = max(dp[j] + a * (sum[i] - sum[j])^2 + b * (sum[i] - sum[j]) + c)
$$

这个式子显然可以使用斜率优化。

首先构造斜率式，设 j < k 若  j  比  k  优，则有

$$
dp[j] + a * (sum[i] - sum[j]) ^ 2 + b *  (sum[i] - sum[j]) + c >  dp[k] + a * (sum[i] - sum[k]) ^ 2  +  b  *  (sum[i] - sum[k]) + c
$$

消掉相同的项，再移一下项。

$$
dp[j] -  dp[k] + a  * sum[j] ^ 2 - a  * sum[k] ^ 2  > (2 *  a * sum[i] + b) * (sum[j] - sum[k])
$$

令 f[i] = dp[i] + a * sum[i] ^ 2

则：

$$
\frac{f[j] - f[k]}{s[j] - s[k]} < 2 * a * sum[i] + b
$$

接下来就是上模板的事情啦。

实现的时候要注意符号，还有数组下标和数组的值

不然会凉。。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define N 1000001
using namespace std;
int n, l, r;
ll a, b, c, x;
ll dp[N], f[N], q[N << 1], sum[N];
inline void insert(int i) {
  while (l < r && (double)(f[q[r - 1]] - f[i]) / (1.0 * (sum[q[r - 1]] - sum[i])) > (double)(f[q[r - 1]] - f[q[r]]) / (sum[q[r - 1]] - sum[q[r]])) r--;
  q[++r] = i;
}
int main() {
  scanf("%d", &n);
  scanf("%lld%lld%lld", &a, &b, &c);
  for (int i = 1; i <= n; i++) {
    scanf ("%lld", &x);
    sum[i] = sum[i - 1] + x;
  }
  for (int i = 1; i <= n; i++) {
    while (l < r && f[q[l + 1]] - f[q[l]] > (2ll * a * sum[i] + b) * (sum[q[l + 1]] - sum[q[l]])) l++;
    dp[i] = dp[q[l]] + a * (sum[i] - sum[q[l]]) * (sum[i] - sum[q[l]]) + b * (sum[i] - sum[q[l]]) + c;
    f[i] = dp[i] + a * sum[i] * sum[i];
    insert(i);
  }
  printf("%lld\n", dp[n]);
  return 0;
}
```



---

## 作者：bztMinamoto (赞：0)

打广告->[这里](https://www.cnblogs.com/bztMinamoto/p/9545985.html)

先写出转移方程$$dp[i]=max\{dp[j]+a*(sum[i]-sum[j])^2+b*(sum[i]-sum[j])+c\}$$

假设$j$比$k$更优，则有$$dp[j]+a*(sum[i]-sum[j])^2+b*(sum[i]-sum[j])+c>dp[k]+a*(sum[i]-sum[k])^2+b*(sum[i]-sum[k])+c$$

展开，并消去同类项之后得$$dp[j]-2*a*sum[i]*sum[j]+a*sum[j]^2-b*sum[j]>dp[k]-2*a*sum[i]*sum[k]+a*sum[k]^2-b*sum[k]$$

移项，得$$(dp[j]+a*sum[j]^2-b*sum[j])-(dp[k]+a*sum[k]^2-b*sum[k])>2*a*sum[i]*sum[j]-2*a*sum[i]*sum[k]$$

设$Y[i]=dp[i]+a*sum[i]^2-b*sum[i],X[i]=sum[i]$

则有$$Y[j]-Y[k]>2*a*sum[i]*X[j]-2*a*sum[i]*X[k]$$

$$\frac{Y[j]-Y[k]}{X[j]-X[k]}>2*a*sum[i]$$

那么就是要我们维护一个上凸包，简单来说就是把原来维护下凸包的那些东西给反过来就好了（ps：我今天刚知道原来凸包还能是上凸的……我太菜了……）
```
//minamoto
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=1000005;
int sum[N],q[N],h,t,n;ll dp[N],a,b,c;
inline ll Y(int i){return dp[i]+a*sum[i]*sum[i]-b*sum[i];}
inline double slope(int j,int k){return 1.0*(Y(j)-Y(k))/(sum[j]-sum[k]);}
inline ll check(int x){return a*x*x+b*x+c;}
int main(){
	//freopen("testdata.in","r",stdin);
	n=read(),a=read(),b=read(),c=read();
	for(int i=1;i<=n;++i) sum[i]=read()+sum[i-1];
	for(int i=1;i<=n;++i){
		int k=2*a*sum[i];
		while(h<t&&slope(q[h],q[h+1])>k) ++h;
		dp[i]=dp[q[h]]+check(sum[i]-sum[q[h]]);
		while(h<t&&slope(q[t],q[t-1])<slope(q[t-1],i)) --t;q[++t]=i;
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

---


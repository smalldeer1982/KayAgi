# [APIO2010] 巡逻

## 题目描述

在一个地区中有 $n$ 个村庄，编号为 $1, 2, \dots, n$。有 $n-1$ 条道路连接着这些村庄，每条道路刚好连接两个村庄，从任何一个村庄，都可以通过这些道路到达其他任何一个村庄。每条道路的长度均为 $1$ 个单位。为保证该地区的安全，巡警车每天要到所有的道路上巡逻。警察局设在编号为 $1$ 的村庄里，每天巡警车总是从警察局出发，最终又回到警察局。下图表示一个有 $8$ 个村庄的地区，其中村庄用圆表示（其中村庄 $1$ 用黑色的圆表示），道路是连接这些圆的线段。为了遍历所有的道路，巡警车需要走的距离为 $14$ 个单位，每条道路都需要经过两次。

![](https://cdn.luogu.com.cn/upload/pic/4401.png)

为了减少总的巡逻距离，该地区准备在这些村庄之间建立 $K$ 条新的道路，每条新道路可以连接任意两个村庄。两条新道路可以在同一个村庄会合或结束，如下面的图例 (c)。一条新道路甚至可以是一个环，即其两端连接到同一个村庄。由于资金有限，$K$ 只能是 $1$ 或 $2$。同时，为了不浪费资金，每天巡警车必须经过新建的道路正好一次。下图给出了一些建立新道路的例子：

![](https://cdn.luogu.com.cn/upload/pic/4402.png) 

在 (a) 中，新建了一条道路，总的距离是 $11$。在 (b) 中，新建了两条道路，总的巡逻距离是 $10$。在 (c) 中，新建了两条道路，但由于巡警车要经过每条新道路正好一次，总的距离变为了 $15$。试编写一个程序，读取村庄间道路的信息和需要新建的道路数，计算出最佳的新建道路的方案使得总的巡逻距离最小，并输出这个最小的巡逻距离。



## 说明/提示

- $10\%$ 的数据中，$1≤n≤1000,K=1$；
- $30\%$ 的数据中，$K=1$；
- $80\%$ 的数据中，每个村庄相邻的村庄数不超过 $25$；
- $90\%$ 的数据中，每个村庄相邻的村庄数不超过 $150$；
- $100\%$ 的数据中，$3≤n≤10^5,1≤K≤2$。


## 样例 #1

### 输入

```
8 1 
1 2 
3 1 
3 4 
5 3 
7 5 
8 5 
5 6 ```

### 输出

```
11```

## 样例 #2

### 输入

```
8 2 
1 2 
3 1 
3 4 
5 3 
7 5 
8 5 
5 6 ```

### 输出

```
10```

## 样例 #3

### 输入

```
5 2 
1 2 
2 3 
3 4 
4 5 ```

### 输出

```
6```

# 题解

## 作者：llzzxx712 (赞：129)

# P3629
解释详细，题目思路和所有涉及到的算法都有讲解。

代码精简清晰，不用STL，无压行代码59行。(核心代码只有：两次 dfs 共10行，标记直径 2行，dp 10行）
## 核心算法

**两次dfs求树的直径 + 树上DP求树的直径 + 数学思考**

## 题目分析

首先分析题目，刚开始这是一颗树，所以警车要将整个树遍历一遍再回到起点，边都为1,走的路程是 $2*(n-1)$ 。

所以我们只要算出修建新的道路可以让警车少走的边数，减一下就是答案了。

题目中的 K 只能是 1 或 2 ，所以我们先来看 k=1 的情况。

修了一条道路后，这棵树中就出现了一个环（也就是基环树，不知道也没关系），反正现在它有一个环，而因为我们只能经过新修的道路一次（0 和 2 都不行），所以我们肯定要将这个环走一遍。假设这个环中除去新加的边长度为 L ，那么我们少走的长度就是 L （原来要走两遍，现在只要一遍）。再加上新的边，因此要走的路就是 $2*(n-1)-L+1$ ，显然当 L 最大时这就是答案。一颗树中最长的一条路径就是它的直径，所以我们现在只要求出它的直径就可以了。

这里我们使用两次dfs求树的直径（原因下面会讲），因为这样可以知道直径的端点，进而确定整个直径的路线。

**知道dfs求树的直径的可以跳过这一部分**

树的直径有一个性质：**距离树上一个点最远的点必定是直径的端点（之一）**。

证明：反证法。假设 $a,b$ 是直径的两个端点，对于一个节点 $i$ ， 假如节点 $c$ 距离 $i$ 比$a,b$ 距离 $i$ 都要远，那么 $c$ 一定可以和 $a,b$ 中的一个节点构成一条更长的路径，与假设不符。性质成立。

这样，我们通过一次 dfs 比较深度，求出了直径的一个端点，那么接下来再以端点为根来一次 dfs ，标记路径并记录长度。

两次dfs代码基本一样，除了第二次要处理 $fa$ 数组。$fa$ 数组用来存每个节点的父亲。

```cpp
#define N 100010
int head[N],ne[N<<1],to[N<<1],size[N<<1];//邻接表存边,size[ ] 存边权，一开始都是 1
int fa[N],de[N];//de[ ] 存深度
```

```cpp
void dfs(int x,int pre,int z,int t){//x表示当前节点，pre 是它的父亲，z的边权，t表示第几次 dfs 。
	de[x]=de[pre]+z;
	if(t==2) fa[x]=pre;//第二次跑dfs记录直径 
	for(int i=head[x];i;i=ne[i]){
		int y=to[i],z=size[i];
		if(y==pre) continue;
		dfs(y,x,z,t);
	}
	if(de[x]>de[leaf]) leaf=x;//leaf 存直径的端点，易知它一定是叶节点
}
```

此时 k=1 的情况就解决了，你可以拿到 30分 。

------------
建立第二条道路后，又会形成一个环。若两个环不重叠，我们只要像刚才那样处理就好了。但如果重叠呢？按照题目的要求，新边必须被走仅一次，所以重叠的边必须走两遍。

![](https://cdn.luogu.com.cn/upload/image_hosting/qezn9ak7.png)

如图，我们从红色点开始走，黄色边为新修建的边，红色边为重叠边，易知红边要走两次。
所以在计算答案的时候我们需要将重叠边减去或是不选重叠边，因此我们可以将**第一次求的直径取反**这样如果选到了原直径上的边就相当于减去了这部分,保证了答案正确。**这也就是我们刚才需要用dfs求直径的原因。** 

将边权取反后新的树上再求直径，设长度为 L2，那么答案就是 $2*(n-1)-(L1-1)-(L2-1)=2*n-L1-L2$

**如何标记刚才求出的直径呢？**
我们只要从刚才求出的 leaf （端点）开始往上标记直径中的节点就好了。

```cpp
for(int i=leaf;i;i=fa[i]) v[i]=1;
```

如果碰到两个点都被标记的情况，就将这条边边权取反。

因为dfs不能处理负边权情况，所以第二次求直径需要用 DP 。知道DP求树的直径的同志就可以结束这篇题解了（能给个赞就更好了）。

我们先随便找一个点（比如1号点），把这个无根树当成有根树， $d[x]$ 表示从 x 出发走向以 x 为根的子树可以走到的最远距离，显然叶子节点 $i$ 的 $d[i] = 0$  ，它父亲节点 $j$ 的 $d[j]=max(d[j],d[i]+edge_{i,j})$ 我们可以递归地求出每一个点的 $d$ 。然后一条路径的长度就是两个点的 $d$ 之和加上他们直径的距离，也就是 $d[x]+d[y]+edge_{x,y}$ ，当我们递归地处理时，假如 x 是父节点，处理到 y 时肯定已经将前面的几个节点处理过了，所以可以直径更新$ans$ 。也就是 $ans=max(ans,d[x]+d[y]+size[i])$ （我用 size 存边权）

DP完整代码：

```cpp
void dp(int x,int pre){//pre 是父亲 
	for(int i=head[x];i;i=ne[i]){
		int y=to[i];
		if(y==pre) continue;//无根树 
		if(v[x]&&v[y]) size[i]=-1;//两点有标记，边权变负 
		dp(y,x);//递归处理 
		L2=max(L2,d[x]+d[y]+size[i]);//更新答案 
		d[x]=max(d[x],d[y]+size[i]);
	} 
}
```

## 完整AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
#define N 100010
int n,k,tot,leaf=1,leaf1=1,L1,L2; 
int head[N],ne[N<<1],to[N<<1],size[N<<1];
int fa[N],de[N];
int v[N],d[N];
void add(int x,int y,int z){
	to[++tot]=y;
	ne[tot]=head[x];
	size[tot]=z;
	head[x]=tot;
}
void dfs(int x,int pre,int z,int t){//x表示当前节点，pre 是它的父亲，z的边权，t表示第几次 dfs 。
	de[x]=de[pre]+z;
	if(t==2) fa[x]=pre;//第二次跑dfs记录直径 
	for(int i=head[x];i;i=ne[i]){
		int y=to[i],z=size[i];
		if(y==pre) continue;
		dfs(y,x,z,t);
	}
	if(de[x]>de[leaf]) leaf=x;//leaf 存直径的端点，易知它一定是叶节点
}
void dp(int x,int pre){//pre 是父亲 
	for(int i=head[x];i;i=ne[i]){
		int y=to[i];
		if(y==pre) continue;//无根树 
		if(v[x]&&v[y]) size[i]=-1;//两点有标记，边权变负 
		dp(y,x);//递归处理 
		L2=max(L2,d[x]+d[y]+size[i]);//更新答案 
		d[x]=max(d[x],d[y]+size[i]);
	} 
}
int main(){
	read(n),read(k);
	for(int i=1;i<n;i++){
		int x,y;
		read(x),read(y);
		add(x,y,1),add(y,x,1);
	}
	dfs(1,0,0,1);
	dfs(leaf,0,0,2);
	L1=de[leaf];
	if(k==1){
		printf("%d",2*(n-1)-L1+1);
		return 0;
	}
	for(int i=leaf;i;i=fa[i]) v[i]=1;
	dp(1,0);
	cout<<n*2-L1-L2;	
	return 0;
}


```

有什么不理解的地方或建议可以评论或私信我，如果题解对你有帮助，给个赞呗。

---

## 作者：Wow_Goodjob (赞：102)

From 多年不写题解的蒟蒻

###### ~~先吐槽一句某谷的评测机,我有一份提交一直N/A~~

*正解为 ：树的直径+数学推断*


-------------------------------下面是真_题解--------------------

**RT**,有一棵树，要求我们在树上加上1~2两条边，是警察遍历时经过的路径最短，关于路径，有以下几个要求

1. 造出来的路必须且仅经过一遍
1. 允许出现某条路有某点连向同一个点
1. 从1好节点出发，回到一号节点

好了让我们开始思考，只要我们认真地读题了，就会发现*k*只有两种情况:k==1或k==2，那么不妨进行一波分类讨论

# *k==1*时

当k==1时，发现，只要不zz一般地从自己连到自己(造的路必须通过)，都是可以帮警察省下路程的，所以我们不妨考虑一下贪心地选择，即选择树上距离最长的两点，因为不管我们选择了那两个点，省下的距离都是*两点之间的距离 - 1（走造的那条路还要 1）*
那么我们只要找到距离最大的两个点就可以省下最长的路程这就引出了我们的主角——**树的直径**

## 树的直径
什么是树的直径呢？其实就是树上距离相差最大的两个点之间的路径，概念非常好理解，代码也不长

### 怎么树的直径

1. 两次dfs
2. 树形dp

两种方法各有优缺点将在先问中讲到

#### dfs求树的直径
其实就是在树上随机选一个点，对他进行一次dfs求出距离它距离最远的一个点*A*,然后再用那一个点dfs回来找到一个离*A*点距离最远的*B*点，*AB*之间的路径即为树的直径

代码:(dfs)
```cpp
void dfs(int x,int father,int weight){
    if(weight>=_max){
        _max=weight;
        id=x;
    }
    for(int i=linkk[x];i;i=e[i].nxt)
        if(e[i].to!=father)
            dfs(e[i].to,x,weight+e[i].value);
}
```

优点:可以记录直径的起点，重点，再配合一个dfs可以求出直径上的每一个点

缺点:遇到副边权的树就*GG*

#### 树上dp求树的直径

通过树形dp的方式，通过求出差不多每个点之间的距离，求最大值，听上去比较难理解，但学过树形dp的同学应该都知道码量比较小

代码:(树上dp)

```cpp
void Dp_to_Find_D_afther(int now,int father){
    for(int i=linkk[now];i;i=e[i].nxt){
        if(e[i].to==father)  continue;
        Dp_to_Find_D_afther(e[i].to,now);
        Dafter=max(Dafter,dis[now]+dis[e[i].to]+e[i].value);
        dis[now]=max(dis[now],dis[e[i].to]+e[i].value);
    }
}
```

优点:可以处理负边权的树

缺点:真的只能求一个树的直径的长度，其他的求不出

**两种方法互相补充，正是这题的优秀之处，它同时考到了两种算法**

然后当k==1时，就可以省下*树的直径-1*的路啦(显然这是省的最多的)，由于本来要走的路程是*(N-1)<<1*(每条路走两次),我们当*k==1*时的答案就是
```cpp
            (2*(N-1)-Dfront+1)//Dfront是树的直径
```

# k==2时
这是这道题目的难点所在，但如果想通了k==1时的情况的话，其实也不是很难~~然而本蒟蒻还是卡了差不多一个上午~~我们在求出了一开始求出了树的直径之后，我们可以把造的那条边先忽略掉，然而，要怎么解决有些边已经被省下的情况呢？

首先，我们得发现，当我们加入了一条边后，就多了一个环~~这棵树就变成了一颗基环树~~，所以当我们加入第二条边时，他会出现第二个环，这个环的情况也不多，不如再来一波分类讨论

1. 此环的边和第一个环有重叠
1. 此环的边和第一个环没有重叠

当第二种情况时，不用想就应该知道，只要再贪心一次(把第一条直径上的边忽略)就可以了，所以我们真正的挑战在第一种情况

**敲黑板，以下是重点**

当我们的第二个环有与第一个环有重边时，因为造出来的路必须只经过一次，所以这个环肯定是要遍历一次的，也就是相当于我们第一次造路并没有帮重叠的边省下路程，那么怎么处理这种情况呢？？

想必各位*dalao*都知道，
```cpp
                       x-y-(-y)=x
```

*bingo!!!*我们只要把第一条直径上的边的边权改为* -1 (或一个你喜欢的负数) *就行啦

**敲黑板，重点结束**

那么我们怎么样才能把直径上的边权改为* -1 *呢？

同学，你知道吗？STL库里有一个东西，他叫做**map**,根据树的性质，两点之间的路径，**有且只有**一条，所以当两个点都是树的直径上的点时，连接他们的边一定是树的直径上的一条边，我们就可以这条边的权值改为* -1 *啦

## map

map是STL库一种东西(我也不知道算不算数据结构)

它形似**map<int,bool>Mymap**,它支持以前一个数为下标(也可以是字符或字符串)，返回后一个值，它的主要函数叫做，举个例子：
```cpp
	map<int,bool>Mymap;//定义一个叫Mymap的map
    	if(Mymap.count(x)==1)//判断x这个元素是否在map中,是返回1，否则返回0
    		…………；//一波操作
    Mymap[x]=1;//将x这个元素加入Mymap中
```
不知道这么说合不合适，其实*map*是非常好用的，常被我用来代替字符串Hash

那么问题又被我们简化了，我们现在只要求出直径上有那些点就可以了,这个时候就体现出了dfs的强大

我们需要定义一个*fr*数组来记录我们的直径上的点

代码(求树的直径上的点)
```cpp
void dfs_for_D(int now,int father,int tar/*需要到的目标点*/){
    if(flag_find_D==true)  return;//记录是否已经找到了所有点
    for(int i=linkk[now];i;i=e[i].nxt){
        if(flag_find_D==true)  return;
        if(e[i].to==father)  continue;
        if(e[i].to==tar){
            fr[now]=e[i].to;//记录这个点连向的下一个点
            flag_find_D=true;
            return;
        }
        fr[now]=e[i].to;
        //如果这并不是需要的点，不用担心，他会在以后的dfs中被覆盖
        dfs_for_D(e[i].to,now,tar);
        if(flag_find_D==true)  return;
    }
}

dfs_for_D(start,0,end);//start,end分别为直径的起点，终点

```

然后，我们就把树的直径中的所有点存在了*fr*中
下面我们需要利用*map*记录下这些点，通过上面的代码，不难发现，*fr*数组的思想类似于邻接表，所以便历也与邻接表相似

```cpp
for(int i=start;i!=end;i=fr[i])
        __map[i]=1;//如果这个点在直径上，把他打上tag(__map是定义的map)
```
但是，由于*for*循环的缘故，我们直径的最后一个节点并没有被打上标记，需要我们自己加:

```cpp
                          __map[end]=1;
```

现在，所有直径上的点都被我们打上了*tag*，我们只需要把连着这些点的边的权值修改就可以了，做法很简单

代码(修改权值)
```cpp
 for(int i=1;i<=N;++i)//遍历每一个点
        if(__map.count(i)==1)//边的起点首先要被打上过标记
            for(int j=linkk[i];j;j=e[j].nxt)//遍历这个点所衍生出的边
                if(__map.count(e[j].to)==1)//终点也打上标记表示这就是直径上的点
                    e[j].value=-1;//修改权值
```

然后，我们就成功地把这个图加工成了我们需要的东西，再求一遍树的直径就可以了，等等_注意要用树形dp求，因为这棵树此时已经有了负边权的边！！~~诶呦我去，这个卡了我好久，太菜了，没有办法~~

我们帮警察叔叔省下的路就是
```cpp
               2*(N-1)-(Dfront-1)-(Dafter-1)
              =2*N-Dfront_Dafter
```
因为在第二次求边权是的边的权值是* -1 *  所以第二个环的重边,在计算时已经从省下的路径中减去了，所以我们可以大胆地这么计算


奉献一波AC码(339ms(whithout O-2),5696kb)~~应该很少有人这么写吧~~
```cpp
#include <bits/stdc++.h>
#define C getchar()
using namespace std;
const int maxn=100010;
inline int read(){
    int x=0;char ch;bool flag=true;
    for(;!isdigit(ch);ch=C)  flag=ch=='-'?false:true;
    for(;isdigit(ch);ch=C)   x=(x<<3)+(x<<1)+(ch^48);
    return flag?x:-x;
}//神仙快读

int N,K;
struct edge{
    int nxt;
    int to;
    int value;
}e[maxn<<1]={};//邻接表,注意开两倍
int linkk[maxn]={};
int len,x,y,_max,id,Dfront,Dafter,start,end,fr[maxn]={},dis[maxn]={};
bool flag_find_D=false;
map<int,bool>__map;//定义一个map

void insert(int x,int y){
    e[++len].to=y;
    e[len].nxt=linkk[x];
    e[len].value=1;
    linkk[x]=len;
}

void dfs(int x,int father,int weight){
    if(weight>=_max){
        _max=weight;
        id=x;
    }
    for(int i=linkk[x];i;i=e[i].nxt)
        if(e[i].to!=father)
            dfs(e[i].to,x,weight+e[i].value);
}//dfs求树的直径

void dfs_for_D(int now,int father,int tar){
    if(flag_find_D==true)  return;
    for(int i=linkk[now];i;i=e[i].nxt){
        if(flag_find_D==true)  return;
        if(e[i].to==father)  continue;
        if(e[i].to==tar){
            fr[now]=e[i].to;
            flag_find_D=true;
            return;
        }
        fr[now]=e[i].to;
        dfs_for_D(e[i].to,now,tar);
        if(flag_find_D==true)  return;
    }
}//记录树的直径上的点

void Dp_to_Find_D_afther(int now,int father){
    for(int i=linkk[now];i;i=e[i].nxt){
        if(e[i].to==father)  continue;
        Dp_to_Find_D_afther(e[i].to,now);
        Dafter=max(Dafter,dis[now]+dis[e[i].to]+e[i].value);
        dis[now]=max(dis[now],dis[e[i].to]+e[i].value);
    }
}//树形dp求树的直径

int main(){
    N=read(),K=read();
    for(int i=2;i<=N;++i){
        x=read(),y=read();
        insert(x,y);
        insert(y,x);
    }//建图
    dfs(1,0,0);//第一次dfs(从一个你喜欢的节点开始)
    start=id,_max=0;
    dfs(start,0,0);//第二次dfs(从到你喜欢的节点的最远的哪一个节点开始)
    Dfront=_max,end=id;//求出造第一条路时的树的直径——Dfront
    if(K==1){
        printf("%d",(2*(N-1)-Dfront+1));
        return 0;
    }//k==1时直接输出并退出(30分)
    dfs_for_D(start,0,end);//记录直径——Dfront上的点
    __map[end]=1;
    __map[start]=1;
    for(int i=start;i!=end;i=fr[i])
        __map[i]=1;//给直径——Dfront上的点打上标记
    for(int i=1;i<=N;++i)
        if(__map.count(i)==1)
            for(int j=linkk[i];j;j=e[j].nxt)
                if(__map.count(e[j].to)==1)
                    e[j].value=-1;//修改边权
    Dp_to_Find_D_afther(1,0);//树上dp求造第二条路时树的直径——Dafter(此时有负边权的边)
    printf("%d",2*N-Dfront-Dafter);//k==2时输出并退出
    return 0;
}
```

---

## 作者：wu3412790 (赞：49)

  加一条边相当于选一条树上路径并加他们连接，加两条边相当于选两条。很多题解似乎直接默认其中一条必选直径却没有证明这一点。
  
 我们用一种不需要考虑直径的办法。注意到如果选了两条路径，他们重复的部分相当于没有用还是要走两次，所以本题相当于选两条树上路径使他们的"异或”边数最大。
  
  观察到两条树上路径的相交也是一段树上连续的路径。所以其实两条树上路径的“异或”可以看成两条不相交的树上路径。这样我们可以用DP来求在树中选两条不相交路径的最大长度。
  
  这个DP可以看作求树直径DP的扩展，用$f[x][0-3]$表示x向下前四深的路径，用$g[x]$表示在$X$为根的子树里可以选出的最长路径，用$w[x]$表示在以$x$为根子树里，选一条从$x$向下的路径再选另一条和它不相交的路径的最大可能总长度。
  
  然后我们可用他们组合出答案的备选方案，枚举$x$，有以下几种组合方法：
  
 (1) $f[x][0]+f[x][1]+f[x][2]+f[x][3]$ 
     
   (2) $g[y_1]+g[y_2]$，$y_1,y_2$是$x$的两个不同的儿子
   
   (3) $f[x][i]+f[x][j]+g[y]$,其中$y$是$x$的一个儿子且$f[x][i],f[x][j]$不来自$y$这棵子树。
   
   (4) $f[x][i]+w[y]$，其中$y$是$x$的一个儿子且$f[x][i]$不来自$y$这棵子树。
   
   
   ```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int const N=2e5+1;
struct edge{
	int from,to,pre;
}e[N];
int cnt,n,k,ans,f[N][4],d[N],g[N],w[N],last[N];
bool comp(int a, int b){
	return d[a]>d[b];
}
void add(int a, int b){
	e[++cnt]={a,b,last[a]};
	last[a]=cnt;
}
void update(int i, int j){
	if (d[j]>d[f[i][3]]) f[i][3]=j;
	sort(f[i],f[i]+4,comp);
}
void dfs(int x, int father){
	for (int i=last[x];i;i=e[i].pre)
		if (e[i].to!=father){
			dfs(e[i].to,x);
			w[x]=max(w[x],w[e[i].to]+1);
			d[x]=max(d[x],d[e[i].to]);
			update(x,e[i].to);
		}
	w[x]=max(w[x],d[f[x][0]]+d[f[x][1]]+d[f[x][2]]);
	d[x]++;
	for (int i=last[x];i;i=e[i].pre)
		if (e[i].to!=father){
			ans=min(ans,2*n-2+k-g[e[i].to]-g[x]);
			g[x]=max(g[x],g[e[i].to]);
			if (e[i].to==f[x][0]) {
				ans=min(ans,2*n-2+k-d[f[x][1]]-d[f[x][2]]-g[e[i].to]);
				ans=min(ans,2*n-2+k-d[f[x][1]]-w[e[i].to]-1);
				w[x]=max(w[x],d[f[x][1]]+g[e[i].to]);
			} else{
				ans=min(ans,2*n-2+k-d[f[x][0]]-w[e[i].to]-1);
				w[x]=max(w[x],d[f[x][0]]+g[e[i].to]);
				if (e[i].to==f[x][1]) ans=min(ans,2*n-2+k-d[f[x][0]]-d[f[x][2]]-g[e[i].to]);
				else ans=min(ans,2*n-2+k-d[f[x][0]]-d[f[x][1]]-g[e[i].to]);
			}
		}
	g[x]=max(g[x],d[f[x][0]]+d[f[x][1]]);
	ans=min(ans,2*n-2+k-d[f[x][0]]-d[f[x][1]]-d[f[x][2]]-d[f[x][3]]);
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>k;
	ans=2*(n-1)+k;
	for (int i=1;i<=n-1;i++){
		int a,b;
		cin>>a>>b;
		add(a,b);
		add(b,a);
	}
	dfs(1,0);
	if (k==1){
		ans=2*n-2+k;
		for (int i=1;i<=n;i++)
			ans=min(ans,2*n-2+k-d[f[i][0]]-d[f[i][1]]);
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：Treeloveswater (赞：30)

我来一份题解吧。

网上很多该题的题解忽略了一种情况，但却没有去证明该情况不需要计算。

我在下面会提到。


首先，k=1的时候 即找出树的直径即可。

难点在k=2的时候

第一条边肯定是连直径，那么第二条边怎么连？

因为要求必须经过新连的边，所以有一些本来只需要经过一次的边，在连了第二条边之后就必须再走一次，我们称该事件为事件A。


我们画图得出如下结论

设我们选的第二条边的两个端点分别为 s,t

如果 s,t均 不在直径上任意一点（除1外)的子树内 则不会出现事件A

如果s或t在直径上任意一点（除1外)的子树内 则会出现事件A

我们直接去考虑s和t均在直径的子树中的情况：

画图可知，第二条边连后 要重复经过的边有两种选择

第一种是s到t的那条链

第二种是 s往下走，经过新连的第一条边，再往上走，从而到达t

对于第一种情况，我们可以将直径上的边赋上权值 -1，其他边权值为1 然后找出此时树的直径即可。

对于第二种情况，又该如何做呢

我们不可能连边后对图跑dp，这是很难做的，也不可能断边。那我们该怎么办呢？

我们发现，如果s和t是按照第二种情况走的，

那么我们会损失 s到直径顶端的长度+t到直径的另一顶端的长度+1的收益，

获得 s的子树（不包括直径所在子树）中最长链长度+t的子树（不包括直径所在子树）中最长链长度

突然，我们发现一个事情：  因为s和t是在直径上的点，所以

s到直径顶端的长度>=s的子树（不包括直径所在子树）中最长链长度

t到直径顶端的长度>=t的子树（不包括直径所在子树）中最长链长度

这是直径的性质，无需在此证明了。

所以我们发现，这样的话收益是负的！还不如连个自环！

所以，情况二无需考虑！


那么问题就圆满地解决了。

题解做法：

1.找出树的直径

2.将直径上的边赋值为-1，其他边为1，再找直径


附上代码：

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define o 200100
using namespace std;
queue<int> q;
int head[o],nxt[o*2],point[o*2],weight[o*2],f[o],deep[o],father[o];
bool vis[o];
int tot=1,n,k,ui,vi,zoom,cnt;
void addedge(int x,int y){
    tot++;nxt[tot]=head[x];head[x]=tot;point[tot]=y;weight[tot]=1;
    tot++;nxt[tot]=head[y];head[y]=tot;point[tot]=x;weight[tot]=1;
}
int solve(int root){
    memset(vis,0,sizeof(vis));
    father[root]=0;
    vis[root]=true; 
    deep[root]=0;
    int ans=root;
    q.push(root);
    while(!q.empty()){
        int now=q.front();q.pop();
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(!vis[v]){
                father[v]=now;
                deep[v]=deep[now]+1;
                if(deep[v]>deep[ans])ans=v;
                q.push(v);
                vis[v]=true;
            }
        }
    }
    return ans;
}
void sign(int now){
    for(int tmp=head[now];tmp;tmp=nxt[tmp]){
        int v=point[tmp];
        if(v!=father[now]){
            if(vis[now]&&vis[v])
                weight[tmp]=weight[tmp^1]=-1;
            sign(v);
        }
    }
}
void dfs(int now){
    int maxnum=0;
    for(int tmp=head[now];tmp;tmp=nxt[tmp]){
        int v=point[tmp];
        if(v!=father[now]){
            dfs(v);
            zoom=max(zoom,maxnum+f[v]+weight[tmp]);
            maxnum=max(maxnum,f[v]+weight[tmp]);
        }
    }
    zoom=max(zoom,maxnum);
    f[now]=maxnum;
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<n;i++){
        scanf("%d%d",&ui,&vi);
        addedge(ui,vi);
    }
    int s,t;
    s=solve(1);
    t=solve(s);
    solve(1);
    memset(vis,0,sizeof(vis));
    if(deep[s]<deep[t])swap(s,t);
    vis[s]=vis[t]=true;
    while(deep[s]>deep[t]){
        s=father[s];
        vis[s]=true;
        cnt++;
    }
    while(s!=t){
        s=father[s];
        t=father[t];
        vis[s]=vis[t]=true;    
        cnt+=2;
    }
    if(k==1){
        printf("%d\n",(n-1)*2+1-cnt);
        return 0;
    }
    if(cnt==n-1){
        printf("%d\n",n+1);
        return 0;
    }
    sign(1);
    dfs(1);
    printf("%d\n",(n-1)*2+2-cnt-zoom);
    return 0;
}
```





---

## 作者：Cutest_Junior (赞：18)

## P3629 【巡逻】

题意相当于选两条路径，让它们不相交部分的长度最大。

大多题解的做法都是先选直径、修改权值后再选直径，即默认 **其中一条路径就是原树的直径**，且大家似乎都没有证明，似乎是唯一意识到这点的@[wu3412790](https://www.luogu.com.cn/blog/wu3412790/solution-p3629) 也只给出了另一种做法。这里主要给出证明。

### 证明

模拟其它题解的做法，设树的一条直径为 $AB$，选的另一条路径为 $CD$。若两路径不相交，得到的答案为 $d(A,B)+d(C,D)$；若两路径相交，如图，

![](https://cdn.luogu.com.cn/upload/image_hosting/ex8iwyl8.png)

得到的答案为 $d(A,C)+d(B,D)$（也可能是 $d(A,D)+d(B,C)$）。

所以可以把题意改为：选两条 **没有重复边** 的路径，让它们的长度最大。若无特殊说明，之后的叙述都按这个新的题意。

+ 引理：如果最优解中的两条路径的其中两个端点分别为 $A$ 和 $B$，这种做法一定是最优解。
+ 证明：若两条路径分别为 $AB$ 和 $CD$，那显然正确；若两条路径分别为 $AC$ 和 $BD$，那第二条路径选 $CD$ 也能获得最优解。得证。

那接下来只需要证明：最优解（之一）的两条路径一定有两个端点分别为 $A$ 和 $B$。

若选的两条路径 $C_1D_1$ 和 $C_2D_2$ 均与 $AB$ 没有重复边，那么把其中任一条改成 $AB$ 一定不会更劣。猜想成立。

若 $C_1D_1$ 与 $AB$ 有重复边而 $C_2D_2$ 没有，把 $C_1D_1$ 改成 $AB$ 也不会更劣，反过来同理。猜想成立。

若两条路径都和 $AB$ 有重复边，如图，

![](https://cdn.luogu.com.cn/upload/image_hosting/3a94u09m.png)

把两条路径分别改为 $AD_1$ 和 $BC_2$ 不会更劣。猜想成立。

综上，若按初始题意，最优解（之一）选择的其中一条路径就是原树的直径。

---

## 作者：山蛙or山兔 (赞：15)

个人觉得此前的题解不够严谨，于是我补充一下新的证明思路：

当k==1时，很容易察觉到连接最长的路径的两端即可。

当k==2时，需要找到边权和最大的两条路径。

注意：这里并不是分情况去讨论的，两个环是否相交说明不了什么，无法证明每次选择直径的贪心策略是正确的。

正确的证明思路应该是用网络流中用到的增广路来解释。

即当我们选择一条最长的路径之后，把这条路径的上的边权全部标记为负，意味着：再次选择这条边的时候，相当于之前不选这条边。

这样以后，每次求直径就是去找能够使得路径和增加的最多的方案。

很明显，如果图中已有一条直线，再画一条上去，把两直线重合部分擦去，依然是新的两条直线。

但如果图中已有两条直线，再画一条，就可能有四条，所以不能保证用三条直线能够得到最优解，这也是1<=k<=2的原因。

代码如下：
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#define INF 0x3f3f3f3f
#define maxn 100010
using namespace std;

int n,k,sz,fa[maxn],ans,pos;
struct pii
{
	int f,s;
}arr[maxn];
struct edge
{
	int from,to,value,next;
}err[2*maxn];

int front[maxn];
void add(int a,int b,int c)
{
	err[++sz].from=a;
	err[sz].to=b;
	err[sz].value=c;
	err[sz].next=front[a];
	front[a]=sz;
}

void dfs(int u)
{
	for (int i=front[u];i!=-1;i=err[i].next)
	{
		int v=err[i].to;
		if (fa[u]==v) continue;
		fa[v]=u;
		dfs(v);
		int temp=arr[v].f+err[i].value;
		if (temp>arr[u].f)
		{
			arr[u].s=arr[u].f;
			arr[u].f=temp;
		} else if (temp>arr[u].s)
		{
			arr[u].s=temp; 
		}
		if (arr[u].f+arr[u].s>arr[pos].f+arr[pos].s) pos=u;
	}
}

int vis;

void update(int u,int deep)
{
	for (int i=front[u];i!=-1;i=err[i].next)
	{
		int v=err[i].to;
		if (vis==v || fa[u]==v) continue;
		if (deep-1==arr[v].f)
		{
			if (u==pos) vis=v;
			err[i].value=-err[i].value;
			update(v,deep-1);
			break;
		}
	}
}

int main()
{
	cin >> n >>k;
	memset(fa,0,sizeof(fa));
	memset(front,-1,sizeof(front));
	sz=ans=0;
	for (int i=0;i<n-1;i++)
	{
		int a,b;
		cin >> a >> b;
		add(a,b,1);
		add(b,a,1);
	}
	for (int i=0;i<k;i++)
	{	
		memset(arr,0,sizeof(arr));	
		pos=0;
		dfs(1);
		if (pos==0) continue;
		ans+=arr[pos].f+arr[pos].s; 
		vis=0;
		update(pos,arr[pos].f);
		update(pos,arr[pos].s);
	}
	cout << 2*(n-1)-ans+k << endl;
	return 0;
}
```


---

## 作者：ButterflyDew (赞：14)

遇到这种题当然选择手玩数据啦

我们发现：对于初始的树，每条边得经过两次，当连出一个环时，环上的边全都只经过了一次。

那么k=1的30分就拿到了，求出树的直径，统计答案即可。

------------
k=2时，网上大多数的做法是把直径上的边权置-1再求一遍直径，我提供一种大同小异却麻烦一点的做法（可能对我来说比较好想吧）

对链上的每个点，我们以它为根做一遍树的直径，不经过直径上的点，统计出这颗子树的直径和它的最大深度。

直径可以直接更新答案，但这样并不全，可能会有以下一种情况

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/n5Y4Jss*Wk2dztsomYqzSm2pX0hIQKSIOgRNPvyzsDw!/b/dC4BAAAAAAAA&bo=oQL3AKEC9wADCSw!&rf=viewer_4)

黄链为直径，而~~紫~~蓝链为第二次连出的环。

最大深度就在这时候用一下，从左至右扫描一遍直径，用单调队列维护当前最优深度（记得减去原本在直径上的边），更新答案即可

[露迭月喵~~](http://www.cnblogs.com/ppprseter/)

参考代码
```cpp
#include <cstdio>
#include <cstring>
int max(int x,int y){return x>y?x:y;}
const int N=100010;
int head[N],to[N<<1],next[N<<1],F[N],cnt,dis[N],mx,mxl,l,r,n,k,q[N][2],is[N],f[N];
void add(int u,int v)
{
    to[++cnt]=v;next[cnt]=head[u];head[u]=cnt;
}
void dfs1(int now,int len,int fa)
{
    if(len>mxl)
    {
        l=now;
        mxl=len;
    }
    for(int i=head[now];i;i=next[i])
    {
        int v=to[i];
        if(!is[v]&&fa!=v)
            dfs1(v,len+1,now);
    }
}
void dfs2(int now,int len,int fa)
{
    if(mx<len)
    {
        r=now;
        mx=len;
    }
    for(int i=head[now];i;i=next[i])
    {
        int v=to[i];
        if(!is[v]&&fa!=v)
        {
            f[v]=now;
            dfs2(v,len+1,now);
        }
    }
}
void get_d(int s)
{
    mx=0,mxl=0,l=0,r=0;
    dfs1(s,0,0);
    is[s]=0;
    dfs2(l,0,0);
    is[s]=1;
}
int main()
{
    scanf("%d%d",&n,&k);
    int u,v;
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&u,&v);
        add(u,v),add(v,u);
    }
    get_d(1);
    is[1]=0;
    int L=l,R=r,D=mx,ans=0;
    if(k>1)
    {
        int now=R;
        while(now)
        {
            is[now]=1;
            F[now]=f[now];
            now=f[now];
        }
        for(int i=1;i<=n;i++)
            if(is[i])
            {
                get_d(i);
                dis[i]=mxl;
                ans=max(ans,mx);
            }
        now=R;
        int cntt=1,ll=1,rr=0;
        memset(q,-0x3f,sizeof(q));
        while(now)
        {
            if(ll<=rr)
                ans=max(ans,q[ll][0]-cntt+q[ll][1]+dis[now]);
            while(ll<=rr&&dis[now]>=q[ll][0]-cntt+q[ll][1]) ll++;
            q[++rr][0]=dis[now],q[rr][1]=cntt;
            cntt++;
            now=F[now];
        }
    }
    ans+=D;
    printf("%d\n",(n-1<<1)+k-ans);
    return 0;
}

```

---

## 作者：gznpp (赞：11)

这题还蛮有意思的，可以来看看。

题目里说，我们最后要**回到警察局**，所以显然，每一条路需要跑两遍。

当 $k=1$ 时，我们按照题目要求建一条路，也就是建出一个环。你如果要在环上巡逻并且回到原点的话，每条边只需要走一次。

那么问题来了，连接哪两点呢？

我们肯定想让环长越大越好，所以就在直径两端建咯。

`ans=(n-1)<<1-d+1`。（`d`为直径，`+1`加的是新建边长）

现在你已经有了30pts。

我们来讨论一下 $k=2$ 时的情况。

这时我们可以建两个环。

分类讨论：

1. 两环有重叠部分。

   就像样例图(c)，两环重叠部分1-3-5-8，长度为3；车子还要跑正好一遍1-8这条新路，就导致1-3-5-8要多走一遍，花费增加了4，还不如建个自环。
   
   那我们怎么计算多建一条路应该见在哪儿，和之后花费变化量呢？
   
   首先，还是要建在树的直径两端，不过树的边权要改一下了——
   
   众所周知，$x-(-y)=x+y$。
   
   那我们就把**可能的重叠部分**，也就是原树的直径上的边权取反（`1->-1`），然后再求一遍树的直径，统计最后答案时`ans=((n-1)<<1)-d1-d2+2`，`d1`为原树直径，`d2`为取反后直径，`+2`加的是新建两条边长度。
   
   这样，我们可以让两环重叠尽量少，并且统计答案时两环重叠部分在`d1`中的边权将会被`d2`中对应的负边权加回来。

2. 两环无重叠部分。

   既然没重叠，那边权取反对答案统计无影响（倒是对选直径有影响），直接按上面方法做就可以了。

注意：

1. 边权可能为负时只能用dp求直径。

2. 深搜/广搜要搜两遍，两遍中间一定要把“是否访问过”`book`数组，“标记路径”`fa`数组清空。

3. 无向边要存两遍，一定要记得取反时把两个方向都取反

还有，为什么大多数题解里都用dfs写直径？

我喜欢bfs,无递归不爆栈常数小。

```cpp
#include <iostream>
#include <utility>
#include <queue>
#include <cstring>
#define rgi register int
using namespace std;
const int maxn=100005;
const int maxm=maxn<<1;
int n,m,k,ans,d[maxn],pairs[maxm],fa[maxn];
//pairs标记反向边编号，fa标记路径，d为dp用数组
int u[maxm],v[maxm],w[maxm],fst[maxn],nxt[maxm];//邻接表
bool book[maxn];
void dp(int x)//码长超短，你值得拥有
{
	book[x]=1;
	for(rgi i=fst[x];i;i=nxt[i])
	{
		int y=v[i];
		if(book[y])
			continue;
		dp(y);
		ans=max(ans,d[x]+d[y]+w[i]);
		d[x]=max(d[x],d[y]+w[i]); 
	}
}
pair<int,int> bfs(int s)
//first返回直径长度，second返回直径一端
//注意这里只有一遍bfs，但求一次直径要写两遍
{
	pair<int,int> ret;
	ret.first=0,ret.second=0;
	queue< pair<int,int> > que;
	que.push(make_pair(s,0));
	book[s]=1;
	while(!que.empty())
	{
		int x=que.front().first,val=que.front().second;
		if(val>ret.first)
		{
			ret.first=val;
			ret.second=x;
		}
		que.pop();
		for(rgi i=fst[x];i;i=nxt[i])
		{
			int y=v[i];
			if(book[y])
				continue;
			fa[y]=i;
            //标记来路，在边权为1的前提下bfs搜到了就是最优解，大胆放心标记
			book[y]=1;
			que.push(make_pair(y,val+w[i]));
		}
	}
	return ret;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>k;
	m=n-1;
	for(rgi i=1;i<=m;++i)
	{
		cin>>u[i]>>v[i];
		w[i]=1;
		nxt[i]=fst[u[i]];
		fst[u[i]]=i;
		rgi j=i+m;
		u[j]=v[i],v[j]=u[i];
		w[j]=1;
		nxt[j]=fst[u[j]];
		fst[u[j]]=j;
		pairs[i]=j,pairs[j]=i;
	}
	if(k==1)
	{
		dp(1);
		cout<<(m<<1)-ans+1<<endl;
	}
	else
	{
		pair<int,int> tans=bfs(1);//原树直径第一步
		memset(book,0,sizeof(book));
		memset(fa,0,sizeof(fa));//多测不清空，爆零两行泪
		tans=bfs(tans.second);//求直径：确定一端后确定另一端
		for(rgi i=fa[tans.second];i;i=fa[u[i]])
			w[i]=-1,w[pairs[i]]=-1;//取反
		memset(book,0,sizeof(book));//两行泪
		dp(1);
		cout<<(n<<1)-tans.first-ans<<endl;
	}
	return 0;
}
```

---

## 作者：zijinjun (赞：11)

这道题其实在紫题并~~不算难~~，最初考试时候遇到了这道题之后~~我太水，只有k==1的分数~~。
首先来分析一下k==1的情况，当k==1时候，加一条边，省去的相当于两点原来的距离，所以，为了省去的尽可能多，我们考虑最长的路径（~~卖关子~~）

最长的路径是什么？？？**直径**！

所以，当k=1时，问题就简单了（虽然我当时打了很久），我们只需求出树的直径在直径，在其上建边。若直径长l，答案就是2(n-1)-l+12(n−1)−l+1。
于是k==1就这样~~不~~轻松地解决了。
然后。。。由于不怎么会树的直径，就打了个dfs
特别丑的代码如下：

```cpp
#include <bits/stdc++.h>
#define FOR(i,n,m) for(int i=n;i<=m;++i)
#define FR(i,n,m) for(int i=n;i>=m;--i)
const int N=100010;
int n,h[N<<1],cnt;
struct node {
	int next,to,w;
} e[N<<1];
#define add(u,v,w) e[++cnt]= (node){h[u],v,w};h[u]=cnt;
#define n(i) e[i].next
#define t(i) e[i].to
#define QXX(u) for(int i=h[u],v;v=t(i),i;i=n(i))
using namespace std;
int f[N],_max,k;

void dfs(int u,int fa,int w) {
	f[u]=w;
	QXX(u) if(v!=fa) dfs(v,u,w+e[i].w);
}

int main() {
	scanf("%d",&n);
	FOR(i,1,n-1) {
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w) add(v,u,w)
	}
	dfs(1,0,0);_max=0;
	FOR(i,1,n) if(f[i]>_max) _max=f[i],k=1;
	dfs(k,0,0);
	FOR(i,1,n) if(f[i]>_max) _max=f[i];
	cout<<_max;
	return 0;
}
```
（这就是一个裸的树的直径）。
**but**，悲伤的是，还有k=2的存在，那么k=2该怎么办呢？
可以Tarjan吧...听大佬们讲的...但是我不会...
可以修改权值，修改为0吧...但是我用的前向星也不会修改...
然后作为一个蒟蒻想到了bfs，搜出第一次经过的点，进行标记...太复杂...然后想到了在第一次跑树的直径的第二次dfs中对父亲做一下标记，就可以很容易的处理了。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200010;
int head[N],to[N],nextt[N],tot = 1,k,n;
int maxx,p,q,fa[N],vis[N],ans,sum,f[N];
void add(int x,int y) {
	to[tot] = y;
	nextt[tot] = head[x];
	head[x] = tot++;
}
void dfs1(int u,int faa,int len) {
	if (len > maxx) {
		maxx = len;
		p = u;
	}
	for (int i = head[u]; i; i = nextt[i]) {
		int v = to[i];
		if (v == faa)
			continue;
		dfs1(v,u,len + 1);
	}
}
void dfs2(int u,int faa,int len) {
	if (len > maxx) {
		maxx = len;
		q = u;
	}
	fa[u] = faa; //记录父亲
	for (int i = head[u]; i; i = nextt[i]) {
		int v = to[i];
		if (v == faa)
			continue;
		dfs2(v,u,len + 1);
	}
}

void dfs3(int u,int faa) {
	for (int i = head[u]; i; i = nextt[i]) {
		int v = to[i];
		if (v == faa)
			continue;
		dfs3(v,u);
		int temp = 1;
		if (vis[u] && vis[v])
			temp = -1;
		ans = max(ans,f[u] + f[v] + temp);
		f[u] = max(f[u],f[v] + temp);
	}
}

int main() {
	scanf("%d%d",&n,&k);
	for (int i = 1; i < n; i++) {
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs1(1,0,0);
	maxx = 0;
	dfs2(p,0,0);
	if (k == 1) {
		printf("%d\n",2 * (n - 1) - maxx + 1);
		return 0;
	}
	while (q != 0) { //标记
		vis[q] = 1;
		q = fa[q];
	}
	dfs3(1,0);
	sum = 2 * (n - 1) - maxx + 1;
	printf("%d\n",sum - ans + 1);

	return 0;
}

```
于是这道题就很~~轻松~~的解决了

---

## 作者：bugaile (赞：10)

题目大意$:$

给你一棵树,你可以新建$k$条边,求新建边后至少将所有边经历一次的最小代价,所有边权值均为$1$,且新加入的边只能经过刚好一次.$n<=100000,1<=k<=2.$

首先,在不加边的情况下,我们很容易得知,由于要回到起点,每条边必须经过两次,即进入当前子树时一次,出子树时一次,此时巡逻路线长度为$2*(n-1)$,如图$:$

![](https://i.loli.net/2019/08/21/eNj9pV5ZFCaLunA.png)

而当我们要新建一条边时,由于所有的边只需要经过至少一次即可,那么新建的边的两个端点之间的路径只需要经过一次,设两端点路径长度为$l_1$,那么现在的巡逻路线长度为$2*(n-1)-l_1+1$,而此时为了最大化减少的长度,此时在树的直径的两个端点间修建一条边最优.

而当我们修建第二条边时,如果我们这次修建的边的两个端点的路径与上次的路径有重复,那么由于两个环上的每条路径都要经过,那么环上的重复部分又会计算两次.

$($在上图的基础上,在$2-6$,$1-4$之间加了一条边,绿色为只经过一次的边,红色为经过两次的的边$)$

![](https://i.loli.net/2019/08/21/UXwjfJlgAoteMHB.png)

那么只需要将原来直径上的边权变为$-1$,表示选择这条路,会使第一条路减少的遍历会增加一次遍历,然后在找一条树的直径即可.

不过,此时由于有负边权,所以要用$dp$求树的直径,此时代码如下$:$

```cpp

inline void dfs_2(int g,int f){
	for(int i=head[g],v;i;i=nex[i]){
		v=to[i];
		if(v==f)continue;;
		dfs_2(v,g);
		l2=max(dis[v]+dis[g]+w[i],l2);
		dis[g]=max(dis[g],dis[v]+w[i]);
	}
	return ;
}
```

$dis[g]$表示在以$g$为根的子树中,$g$所能到达的最长路径,$l_2$即此时的直径,对于$g$的子节点$v$,可以与$g$的另外的子节点之间形成一条路径,用$v$上的最大路径与已经遍历过的子树的最大路径来更新$l_2$,然后在更新$dis[g]$即可.

最终答案$ans=(n-1)*2-l_1+1-l_2+1$,$(n-1)*2$是原本需要走的边数,而$l_1$是第一条边可以减少的边数,由于新加了一条边,所以需要再加上一条边,对于第二条边同理.

完整代码如下$:$
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int N=1e5+2;
int to[N<<1],nex[N<<1],head[N],w[N<<1],dis[N],n,k,tt,pos,st,ed;
int fa[N],vis[N];
inline void add(int x,int y){
	to[++tt]=y,nex[tt]=head[x],w[tt]=1,head[x]=tt;
	return ;
}
inline void dfs(int g,int f){
	if(dis[g]>dis[pos]||pos==st)pos=g;//更新直径端点;
	fa[g]=f;
	for(int i=head[g],v;i;i=nex[i]){
		v=to[i];
		if(v==f)continue;
		dis[v]=dis[g]+w[i];
		dfs(v,g);
	}
	return ;
}
inline void change(int g,int f){
	for(int i=head[g],v;i;i=nex[i]){
		v=to[i];
		if(v==f)continue;
		if(vis[v])w[i]=-1,w[((i-1)^1)+1]=-1;//链表加边时,双向边是相邻的,所以将边权变为-1直接用成对变换将双向边更改;
		change(v,g);
	}
	return ;
}
int l2;
inline void dfs_2(int g,int f){
	for(int i=head[g],v;i;i=nex[i]){
		v=to[i];
		if(v==f)continue;;
		dfs_2(v,g);
		l2=max(dis[v]+dis[g]+w[i],l2);//更新第二次的直径;
		dis[g]=max(dis[g],dis[v]+w[i]);//更新dis[g];
	}
	return ;
}
int main(){
	cin>>n>>k;
	int x,y;
	for(int i=1;i<n;++i)cin>>x>>y,add(x,y),add(y,x);
	pos=1,dis[1]=0,st=1,dfs(st,0),st=pos;
	pos=st,fa[st]=0,dis[st]=0,dfs(st,0),ed=pos;//找直径;
	int l1=dis[ed];
	int p=ed;
	while(p)vis[p]=1,p=fa[p];//标记直径上的点;
	change(st,0);
	memset(dis,0,sizeof dis);
	dfs_2(st,0);
	if(k==1)l2=1;
	cout<<n*2-l1-l2<<'\n';
	return 0;
}
```

---

## 作者：Minakami_Yuki (赞：6)

[更好的阅读体验](https://zgjjj.github.io/)

# 题目链接

[P3629 [APIO2010]巡逻](https://www.luogu.org/problemnew/show/P3629)

# 题意简述

给你一张无向图，有$n$个点和$n - 1$条边，**无重边和自环**，边长都为$1$，给定源点$1$，新建$k$条道路，要求从源点出发，每条道路**必须**经过**至少一次**，且**新建的道路必须仅经过一次**，求可能的新建道路的方案，使**遍历路径最短**。


# 解题思想

暴力就不讲了，应该都能想到。

我们直接考虑$100\%$的数据。

注意原题中的$1\le k \le 2$，我们考虑**分类讨论**。

## 先来考虑$k == 1$的情况。

在`k == 1`时，这道题和[草鉴定](https://www.luogu.org/problemnew/show/P3119)有点像，但是读完题目后我们会发现，两道题的方向是相反的，要求也不同。

那要怎么做呢？

先来看题目：

>  有$n$个点和$n - 1$条边，**无重边和自环**

这句话告诉我们，题中的图实质上是一颗**无根树**。

看到题目中描述的**新道路**甚至可以是**自环**（题意简述中没写），我们先来考虑这种情况：

当新道路是一个自环时，我们不能通过它来从一个点到另一个点。而又因题目要求，新道路必须经过一次，那么我们只会在新道路上浪费$1$巡逻距离，如图：（这是**样例1**）

![](https://cdn.luogu.com.cn/upload/pic/60199.png)

根据`DFS`的思想，我们要想遍历途中的每一个节点，需要访问每一条边两次（访问一次，回溯一次）。可以得到巡逻距离为$2 \times (8 - 1)  = 14$。

如果我们添加的新道路为节点$2$的自环，我们就会在访问节点$2$时被**强制**经过新道路一次，但是自环访问完后，依然要从$2$回溯至$3$，因此添加**任意的自环**都仅会使**最小访问距离变大**，舍弃。

那么我们考虑在**两个不同的节点之间**连边。

在一棵树上连一条边的话，原树就会变成一颗**基环树**。

如图：连接了$7,2$两点。
![](https://i.loli.net/2019/06/06/5cf87f5b6abe427205.png)

那么如果必须经过新建道路，我们就必须经过**基环树的环**，这样，环上的道路都只需要**遍历一次**（因为我们可以通过环来回到某一个点，这样就可以遍历完环后**直接回溯**，而环上的边就不需要再增加回溯时的费用）。于是考虑让这个环的长度**最大**，也就是说，让连边前的**链**最长，于是可以求出原树的直径`L`，然后将直径的两端连边，那么答案就是$2 * (n - 1) - L + 1$。

其中$2 * (n - 1)$为遍历原树的费用，L - 1为环的长度（不明白的动手在上面的图中数一数）。

~~30分到手了不做了~~

## 再来考虑$k == 2$的情况

和$k == 1$时相似，自环依然是被舍弃的，这个自己理解。

我们的第一条边依然连在直径两端，接着考虑第二条边的位置：
不难看出有如下两种可能：

- 环重叠
- 环不重叠

先来连接直径的**两端**，如图：

![](https://i.loli.net/2019/06/06/5cf87f7daad8544803.png)

这时的点$1 -  2 - 6 - 5 - 3$构成了一个环。我们考虑让环不重叠，连接点$7,8$，如图：

![](https://i.loli.net/2019/06/06/5cf87f8ec23b499834.png)

这时，新的环上的边也仅需经过一次，看上去非常的~~实惠~~。

别急，我们再来考虑一下**重叠**的情况，如图：

![](https://i.loli.net/2019/06/06/5cf87f9e7c8d375395.png)

这次连接了$4,7$两个点。看上去形成了一个更大的环，**节省**了中间重叠部分的费用，但是是这样嘛？

再次回去看一遍题目，发现了一个要求：

> 每条道路**必须**经过**至少一次**

这样，中间的道路就**不能不走**，如果走的话，不仅没有节省费用，相反会因为两个环都要经过而增加了**重叠长度**的费用。

结果就很显然了，需要连接两个**不会导致重环**的点。

那么要连接**哪两个**？怎么样才会导致**不重环**？

考虑$k == 1$时的做法，我们尝试找一条**次长链**，而且不与原链**重复**。有了第二个要求，我们反而会比较好做：

只需要将原直径上的边**毁掉**，然后建立一颗新的树，再在这棵树上求出直径就好了。

但是可能会出现某些~~dl~~数据，让连边后不得不重环，其实计算后我们就会发现，**不论是否重环**，都需要用原图长度减去两个环的大小，而重叠的部分被减了两次（不需要容斥的），这点我们通过求出直径后把直径上的边权值取反就能达到。

取反的实现类似于`EK`算法的`upd()`操作，需要在第一遍`bfs()`求直径时维护一个`pre[]`数组。

第二条直径可以**树上dp**来求。

# 参考代码

>  恰当的函数使用可以极大减少码量

```cpp
//Author: zgjjj
#include <cstdio>
#include <cctype>

namespace FastIO {
    inline int read() {
        char ch = getchar(); int r = 0, w = 1;
        while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
        while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}
        return r * w;
    }
    void _write(int x) {
        if(x < 0) putchar('-'), x = -x;
        if(x > 9) _write(x / 10);
        putchar(x % 10 + '0');
    }
    inline void write(int x) {
        _write(x);
        puts("");
    }
}

using namespace FastIO;

const int N = 100010;
const int M = N << 2;

template <typename T> inline T max(T a, T b) {return a > b ? a : b;}

template <typename T>
class queue {
    private:
        int head, tail;
        T q[N << 1];
    public:
        queue() {head = tail = 0;}
        inline bool empty() {return head >= tail;}
        inline void push(T x) {q[++tail] = x;}
        inline void pop() {if(!empty()) head++;}
        inline T front() {return q[head + 1];}
};

int head[N], nxt[M], edge[M], ver[M], d[N], pre[N];
int cnt = 1, n, k, l, r, l1, l2;
bool v[N];

inline void add(int x, int y, int z) {
    ver[++cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt;
}

inline int bfs(int s) {
    for(register int i = 1; i <= n; i++) d[i] = 0xcfcfcfcf, pre[i] = v[i] = 0;
    int ans = 0;
    d[s] = 0;
    queue <int> q;
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        v[x] = 1;
        for(register int i = head[x]; i; i = nxt[i]) {
            int y = ver[i], z = edge[i];
            if(v[y]) continue;
            d[y] = d[x] + z;
            pre[y] = i;
            q.push(y);
        }
    }
    for(register int i = 1; i <= n; i++) if(d[ans] < d[i]) ans = i;
    return ans;
}

void dp(int x) {
    v[x] = 1;
    for(register int i = head[x]; i; i = nxt[i]) {
        int y = ver[i], z = edge[i];
        if(v[y]) continue;
        dp(y);
        l2 = max(l2, d[y] + d[x] + z);
        d[x] = max(d[x], d[y] + z);
    }
}

int main() {
    n = read(), k = read();
    for(register int i = 1; i < n; i++) {
        int x = read(), y = read();
        add(x, y, 1);
        add(y, x, 1);
    }
    l = bfs(1);
    r = bfs(l);
    l1 = d[r];
    if(k == 1)
        return write(2 * (n - 1) - l1 + 1), 0;
    int x = r;
    while(x != l) {
        int i = pre[x];
        edge[i] = edge[i ^ 1] = -1;
        x = ver[i ^ 1];
    }
    for(register int i = 1; i <= n; i++) d[i] = v[i] = 0;
    dp(1);
    return write(2 * n - l1 -l2), 0;
}
```



---

## 作者：vеctorwyx (赞：5)

## 思路：求树的直径*2

#### 但是，两种方法是不一样的。

求树的直径的两种方法：

### 1. dfs

优点：可以求出直径具体包含哪些边；

缺点：不能包含负边权；

代码：

```cpp
//f记录父节点，dis为长度（深度），maxx为离根节点最远的点，v为边权
void dfs(int x,int fa)
{
	f[x]=fa;
	if(dis[x]>dis[maxx])
	maxx=x;
	for(int i=h[x];i;i=q[i].nxt)
	{
		int y=q[i].to;
		if(y==fa)
		continue;
		dis[y]=dis[x]+v[i];
		dfs(y,x);
	}
}

//以下为主函数内的代码

memset(dis,0,sizeof(dis));
dfs(1,0);
dis[maxx]=0;//找到离根节点（1）最远的点并以它为根再次dfs（其实它就是树直径的一端）
dfs(maxx,0);
//此时的maxx为直径的一端，另一端则为树根
```
### 2. dp 

优点：可以处理负边权；

缺点：无法具体求出直径包含的边，只能求出其长度；

代码：

```cpp

//max2记录直径长度，dis此处表示节点可向下延申的最长距离，其他变量同上面的dfs部分的代码
void dp(int x,int fa)
{
	for(int i=h[x];i;i=q[i].nxt)
	{
		if(q[i].to==fa)
		continue;
		dp(q[i].to,x);
		max2=max(max2,dis[x]+dis[q[i].to]+v[i]);
		dis[x]=max(dis[x],dis[q[i].to]+v[i]);
	}
}

```

### 回归题目:

 1. 如果不修建任何道路，则每条道路都会被经过两遍，即$ans=(n-1)*2$。

 2. 如果修建一条道路连接任意两个不相同的点，则会形成一个环，环上的边都只会被经过一次，则$ans$会在```1```的基础上减去环上边的个数再加2，此时修建的道路连接树直径的两端最佳（使用dfs求直径）。
 
 3. 如果在```2```的基础上再修建一条道路，则此环上的边也只会被经过一次，但是如果树上某一边同时在两个环上，则会被经过两遍。
 
 	所以我们将第一个环上的边权标为$-1$，再次求直径，使修建的道路连接直径两端（因为有负边权，所以使用dp求直径）
    
   小细节：
   
   - 所有新建道路都要被全部经过；
   
   - 新建的道路必须为K条，不是$ \le K$；
   
   完整代码：
  ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,ans;
struct node
{
	int to,nxt;
}q[1000010];
int cnt,h[1000010],maxx,f[1000010],dis[1000010],v[1000010],max2=0;//用处上面说过了这里不再赘述
bool b[1000010];//b用来标记第一个环上的点
void add(int x,int y)
{
	q[++cnt].to=y;
	q[cnt].nxt=h[x];
	h[x]=cnt;
}
void dfs(int x,int fa)//dfs求直径
{
	f[x]=fa;
	if(dis[x]>dis[maxx])
	maxx=x;
	for(int i=h[x];i;i=q[i].nxt)
	{
		int y=q[i].to;
		if(y==fa)
		continue;
		if(dis[y]<dis[x]+v[i])
		dis[y]=dis[x]+v[i];
		dfs(y,x);
	}
}
void dp(int x,int fa)//dp求直径
{
	for(int i=h[x];i;i=q[i].nxt)
	{
		if(q[i].to==fa)
		continue;
		dp(q[i].to,x);
		max2=max(max2,dis[x]+dis[q[i].to]+v[i]);
		dis[x]=max(dis[x],dis[q[i].to]+v[i]);
	}
}
int main()
{
	cin>>n>>m;
	ans=(n-1)*2;//初始化ans
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	for(int i=1;i<=cnt;i++)//初始化v
	{
		v[i]=1;
	}
	dis[1]=0;
	dfs(1,0);
	dis[maxx]=0;
	dfs(maxx,0);//第一次求环
	for(int i=maxx;i;i=f[i])
	{
		ans--;
		b[i]=1;
	}
	for(int i=maxx;i;i=f[i])//把环上边的边权改为-1（方法暴力了点）
	{
		for(int j=h[i];j;j=q[j].nxt)
		{
			if(b[q[j].to])
			v[j]=-1;
		}
	}
	ans+=2;
	if(m==1)
	{
		cout<<ans;
		return 0;
	}
	memset(dis,0,sizeof(dis));//二次利用dis数组
	dis[1]=0;
	dp(1,0);
	ans-=max2;
	ans+=1;
	cout<<ans;
}
```
代码没有太多优化（~~其实根本没有，因为本人太菜~~）不吸氧能跑到628ms。

---

## 作者：Tmbcan (赞：3)

## [P3629 [APIO2010] 巡逻](https://www.luogu.com.cn/problem/P3629)

看题解大佬们都用数学推理求两遍直径的方法，然而萌新并不会这么高级的方式，只能大力分讨了。

### 思路

对于 $k=1$ 的情况，加上一条边时，树上出现了一条环且长为 $S$，环上的原路径都可以少走一遍，再算上新路径要走一遍。此时答案为 $2 \times (n-1) - (S-1) + 1$。  
我们需要令 $S-1$ 尽可能大，即原路径的那条链尽可能长，那么应该取树的直径。

对于 $k=2$ 的情况，加上两条边会出现两条环。由于出现的每条环长度比所选链长多一，所以只考虑树上所选链的情况即可。  
若想使总步数尽可能小，那么**选出的两条链要尽可能多的覆盖树上的路径**。且在每条环上，我们都会把环上所有边都经过一遍再走出这条环，两条链重合的部分会重复走，所以**两条链的重合部分要尽可能少**。       
我们巡逻的策略是一但遇到不在环上的点，就优先去走它，然后再想办法走到环上。所以实际答案为 $2 \times (n-1) - S_{并}+S_{交}+2$。 

贪心地取，我们取到的其中一条链一定是树的直径。  
粗略证明：  
对于我们选的两条链，它们分别越长一定不劣。如果两条链没有重合部分，那么其中一条上半部分选中两条链中间的部分，接到另一条的下半部分，答案不劣。由于两条链都要尽量长，那么第一条链如此操作一定能够取到直径。

第二条链在取的时候我们分类讨论。  
设第一条链选出的点共有 $m$ 个，点集为 $T$，按照深度顺序排列。  

如果第二条链与第一条链没有重叠部分，那么我们对每个 $T_i$ 求其子树直径即可。  
如果第二条链与第一条链有重叠部分，我们找到重合部分的两个端点 $T_i$、$T_j$。那么我们将这条链分为一段重合部分、和两段非重合部分。可以钦定 $i < j$，那么 $S_{重} = j-i$。  

![](https://cdn.luogu.com.cn/upload/image_hosting/cbhmopms.png)

我们需要使 $S_{并}-S_{交}$ 最大，那么分别取到 $T_i$、$T_j$ 的子树内距其最深的深度 $maxdep{T_i}$、$maxdep{T_j}$ 一定更优。  
此时答案为 $2 \times (n-1) -(m-1)-[ maxdep{T_1}+maxdep{T_2} - (j-i)] +2$，找到$\max\{maxdep{T_1}+maxdep{T_2} - (j-i)\}$ 即可。  

令 $g_i = maxdep{T_i}+i$，$f_j = maxdep{T_j}-j$，此时转化为求 $\max \{ g_i+f_j \}$ （$i<j$）。  
只需要 $O(n)$ 扫一遍 $f_j$，对于每个 $f_j$ 维护出最大的 $g_i$（在求第二条链的时候顺便维护即可）。 

### 代码

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
template <typename T>
inline void read(T&x){ //快读
	int w = 0;x = 0;
	char ch = getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') w = 1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	if(w) x = ~x+1;
}
template <typename T,typename...Args>
inline void read(T&t,Args&...args){
	read(t);read(args...);
}
template <typename T>
inline T Max(T x,T y){ return (x > y ? x : y); }
const int N = 1e5+10;
int n,m,cnt;
struct{
	int to,nex;
}edge[N<<1];
int head[N],edge_num;
inline void add(int x,int y){// 存边
	edge[++edge_num].to = y;
	edge[edge_num].nex = head[x];
	head[x] = edge_num;
}
int dis[N],fa[N],vis[N];
inline int bfs(int s,int flag){// 用来找以 s 为根最深的深度对应的点
	memset(dis,0,sizeof(dis));
	queue <int> q;
	q.push(s);
	int idx = 0;
	if(flag) fa[s] = 0; //只有选直径的时候才标记父亲
	while(!q.empty()){
		int now = q.front();
		q.pop();
		for(int i=head[now];i;i=edge[i].nex){
			int tto = edge[i].to;
			if(dis[tto] || tto==s || vis[tto]) continue;
			if(flag) fa[tto] = now;
			dis[tto] = dis[now]+1;
			if(dis[tto]>dis[idx]) idx = tto;
			q.push(tto);
		}
	}
	return idx;
}
int main(){
	// freopen("data.out","r",stdin);
	// freopen("put.out","w",stdout);

	read(n,m);
	for(int i=1,u,v;i<n;++i){
		read(u,v);
		add(u,v); add(v,u);
	}
	int t1 = bfs(1,1),t2 = bfs(t1,1); //求直径
	if(m==1){// k==1
		printf("%d",2*(n-1)-dis[t2]+1);
		return 0;
	}
    // 把直径上的点标记，强制第二次找最深的深度时，只在直径上的点的子树内
	for(int i=t2;i;i=fa[i]) vis[i] = 1;
	int maxdis = dis[t2],maxn = 0;
	for(int i=t2,f,g,maxg=0;i;i=fa[i]){
		vis[i] = 0;// 防止第一个儿子可能统计不到
		t1 = bfs(i,0);// 最大深度

		++cnt;
        // 求 g 和 f
		g = dis[t1]+cnt;
		f = dis[t1]-cnt;
		// 求 max{g + f}
		maxn = Max(maxn,f+maxg);
		maxg = Max(maxg,g);

		t2 = bfs(t1,0);// 求其子树直径
		vis[i] = 1;// 记得加回来
		maxn = Max(maxn,dis[t2]);// 没有重合部分的情况
	}
	printf("%d",2*(n-1)-maxdis-maxn+2);// 答案

	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：3)

#### 题意

在树上从一个点(一号点)遍历每一条边再返回，但是并没有这么简单，因为还要加一条或两条边，要求走过的最短距离

样例图:

![e3s43t.png](https://s2.ax1x.com/2019/07/29/e3s43t.png)

加边后的图：

![e3yiE4.png](https://s2.ax1x.com/2019/07/29/e3yiE4.png)

样例加一条2-8的边后(如(a))会形成一个环

我们会发现从1出发走到8后

可以走8-2，2-1返回1这个节点

于是2-1-3-5-8这条链上的每条边都只用走一次(只不过多走了一次8-2)

若再加一条边6-7(如(b))则又形成了一个环

这两个环上的边都不重合，所以第二个环的情形和第一个一样(5-7，5-6只用走一次)

那么我们来~~作死~~考虑一下另一种情况，就是两个环又重叠部分的情况(如(c))

我们会发现两个环都分别会经过一次重叠的部分，及重叠的部分会被经过两次(和最初不是一样的吗(´･ω･´) )

这时不仅不能少走，反而要再走一次

经过一波通俗易懂的分析后我们可以发现每次加边只用找到最长链，再在链的两端加上一条边即可。

如有重叠特殊处理即可。

上代码：

```cpp
inline void DFS(int x,int y,int z)//(两次)DFS求直径
{
	int i,j;
	if(y>=sum)
	{
		sum=y;
		bj=x;
	}
	for(i=h[x];i;i=a[i].next)
	{
		j=a[i].to;
		if(j==z)
		{
			continue;
		}
		DFS(j,y+a[i].v,x);
	}
}
inline bool DFSA(int x,int y,int z)//路径取反
{
	int i,j;
	if(y==L1)
	{
		bjj[x]++;
		return true;
	}
	for(i=h[x];i;i=a[i].next)
	{
		j=a[i].to;
		if(j==z)
		{
			continue;
		}
		if(DFSA(j,y+a[i].v,x))
		{
			bjj[x]++;
			a[i].v=-a[i].v;
			a[i^1].v=a[i].v;
			return true;
		}
	}
	return false;
}
inline void DP(int x,int y)//树形DP求直径
{
	int i,j;
	for(i=h[x];i;i=a[i].next)
	{
		j=a[i].to;
		if(j==y)
		{
			continue;
		}
		DP(j,x);
		sum=max(sum,D[x]+D[j]+a[i].v);
		D[x]=max(D[x],D[j]+a[i].v);
	}
}
int main()
{
	int i,x,y;
	scanf("%d%d",&n,&k);
	for(i=1;i<=n-1;i++)
	{
		scanf("%d%d",&x,&y);
		zsz(x,y,1);
		zsz(y,x,1);
	}//读入建边
	bj=1;
	sum=0;
	DFS(bj,0,0);
	sum=0;
	S1=bj;
	DFS(bj,0,0);
	L1=sum;//第一次减少的距离
	T1=bj;
//先用两次DFS求直径，顺便记录直径的端点
	DFSA(S1,0,0);
//把直径上的边权改为负数，即当再次走到这条边时视为重叠，不减反加
	sum=0;
	DP(1,0);//树形DP求直径
	L2=sum;//第二次减少的距离
	if(k==1)
	{
		printf("%d",2*n-L1-1);
	}
		else
		{
			printf("%d",2*n-L1-L2);
		}
	return 1;
}
```

Upd:早年题解，把格式改了，过不过都行。

---

## 作者：_sry (赞：3)


若$k=0$时，则没有走过任何一个新建道路,所以答案为$2\times (n-1)$，因为用$dfs$可以发现每条边经过一次，回溯一次

设树的直径为$L1$

若$k=1$时，则我们发现若连接$(u,v)$,则会产生一个环，环中每条边只经过一次，其余都经过两次，则答案是$2\times{(n-1)}-L1+1$,+1是因为要走过这条边，再直径的连边

若$k=2$时，因为我们肯定是要选当$k=1$时的情况，但是后面应该怎样去选择呢。若选边$(u1,v1)$,则有肯定又形成一个环，目前两个环，环中若两环有共边，则走两次，其余环内就走一次即可，所以就可以想到让第一次的树上直径中的每一条边$-1$，然后在找一个当前树上的直径$(L2)$，所以答案为$2\times{(n-1)}-(L1-1)-(L2-1)$

即可求树上直径的方法:1.$dfs$,$bfs$2.$dp$（两者都写了,I think 第一种只适应都为正权的边，有负的就崩了）
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read()
{
    int f=1,ans=0;char c;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
struct node{
    int u,v,w,nex;
}x[200001];
int head[200001],n,k,cnt,dis[200001];
void add(int u,int v,int w){
    x[cnt].u=u,x[cnt].v=v,x[cnt].w=w,x[cnt].nex=head[u],head[u]=cnt++;
}
void dfs(int f,int fa){
    for(int i=head[f];i!=-1;i=x[i].nex){
        if(x[i].v==fa) continue;
        dis[x[i].v]=dis[f]+x[i].w;
        dfs(x[i].v,f);
    }
}
bool ff;
void dfs1(int f,int fa,int end){
    if(ff) return;
    if(f==end){
        ff=true;
        return;
    }
    for(int i=head[f];i!=-1;i=x[i].nex){
        if(x[i].v==fa) continue;
        x[i].w=-1;
        x[i^1].w=-1;
        dfs1(x[i].v,f,end);
        if(ff) return;
        x[i^1].w=1;
        x[i].w=1;
    }
}
int get(){
    memset(dis,0,sizeof(dis));
    dfs(1,0);
    int maxn=0,pos;
    for(int i=1;i<=n;i++){
        if(dis[i]>maxn) maxn=dis[i],pos=i;
    } 
    memset(dis,0,sizeof(dis));
    int sta=pos;
    dfs(pos,0);
    maxn=0;
    for(int i=1;i<=n;i++){
        if(dis[i]>maxn) maxn=dis[i],pos=i;
    }
    int end=pos;
    dfs1(sta,0,end);
    return maxn;
}
int d[200001],maxn;
int dp(int f,int fath){
    for(int i=head[f];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        dp(x[i].v,f);
        maxn=max(maxn,d[f]+d[x[i].v]+x[i].w);
        d[f]=max(d[f],d[x[i].v]+x[i].w);
    }
    return maxn;
}
int main()
{
    memset(head,-1,sizeof(head));
    n=read(),k=read();
    for(int i=1;i<n;i++)
    {
        int u=read(),v=read();
        add(u,v,1),add(v,u,1);
    }
    int L1=get();
    if(k==1)printf("%d\n",(n-1)*2-L1+1);
    else{
        int L2=dp(1,0);
        printf("%d\n",n*2-L1-L2);
    }
}
```

---

## 作者：potatoler (赞：2)

### 关于树的直径

连接树上相距最远的两点的路径被称作这棵树的最长链。树的直径指这条最长链或者它的长度。

### 树的直径的求法

一般来将我们可以使用两种方法求数的直径，它们的时间复杂度都是 $O(n)$。

#### 两次搜索

我们可以通过两次 DFS 或两次 BFS 来求树的直径，其原理非常简单：从任意一个节点 $start$ 出发进行第一次搜索，找到距离起点最远的点（记为 $deepest$），再从 $deepest$ 出发进行第二次搜索，找到距离它最远的点（记为 $ending$）。$deepest$ 和 $ending$ 之间的路径便是这棵树的直径，在这个过程中 $deepest$ 一定是直径的一端，否则第一次搜索的结果一定不是 $deepest$，因为直径的两个端点中一定有一个比 $deepest$ 离 $start$ 远。

```cpp
#define des edge[i].destinationVertex
inline void BFS(int x, int secondTime){
    Reset();
    queue<int> q;
    q.push(x);
    vertex[x].vis = true;
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        for(int i=head[cur];i;i=edge[i].nextEdge){
            if(!vertex[des].vis){
                vertex[des].vis = true;
                vertex[des].depth = vertex[cur].depth + edge[i].value;
                q.push(des);
                if(secondTime) vertex[des].father = cur;
            }
        }
    }
    for(int i=1;i<=n;i++)
        if(treeLength < vertex[i].depth){
            treeLength = vertex[i].depth;
            deepest = i;
        }
}
```

不同于接下来只能统计直径长度的树形 DP，在第二次搜索中，我们可以记录每一个点第一次被访问时的父亲节点，最后从搜索到的 $ending$ 往回走，就可以取得这条直径。两次搜索的方法虽然码量稍大，但是它记录信息量大，且思维简单容易理解——不过它真正的致命缺点在于遇到负权边就会暴毙。

#### 树形 DP

设 $d[x]$ 表示从 x 出发走向以 x 为根的子树所能够到达的最远节点的深度，$f[x]$ 表示经过 x 的树上最长链的长度，x 的子节点分别为 $y_1,y_2,…,y_k$，则可以得到 $d[x]=max_{1≤i≤k}(d[y_i]+edge[x,y_i])$。

对于 x 的任意两子节点 $y_i,y_j(j<i)$，我们可以将经过 x 的最长链长度拆成 4 个部分：$d[y_i],d[y_j],edge[x,y_i],edge[x,y_j]$。于是有 $f[x]=max_{1≤j≤i≤k}(d[y_i],d[y_j],edge[x,y_i],edge[x,y_j])$。

事实上我们没有必要使用 $y_i,y_j$ 两个参数来更新 $f[x]$—— 回顾一下 $d[x]$ 的定义：从 x 出发走向以 x 为根的子树所能达到的最远节点的深度 —— 在循环枚举到 $i$ 之前，$d[x]$ 所表示的就是 $max_{1≤j≤i}(d[y_j]+edge[x,y_j])$，当然这个值是 $f[x]$ 的一部分。也就是可以先用 $d[x]+d[y]+edge(x,y)$ 更新 $f[x]$，再用 $d[y]+edge[x,y]$ 更新 $d[x]$。

```cpp
#define des edge[i].destinationVertex
inline void DP(int x){
    vertex[x].vis = true;
    for(int i=head[x];i;i=edge[i].nextEdge){
        if(vertex[des].vis) continue;
        DP(des);
        treeLength = max(treeLength, vertex[x].depth + vertex[des].depth + edge[i].value);
        vertex[x].depth = max(vertex[x].depth, vertex[des].depth + edge[i].value);
    }
}
```

DP 方法的码量明显小于搜索方法，但是缺点也很明显，由于只关注状态的转移，DP 方法只能求出直径的长度，由于在树形图上搜索的时间复杂度也是 $O(n)$，DP 节约时间的方法在这里变成了它的劣势。但是 DP 方法也弥补了搜索方法最大的不足 —— 它可以处理负权边，可以说是一种短小精悍的方法了。

### 例题

一道我个人感觉挺好的题，这里当作例题来做：[P3629 巡逻](https://www.luogu.com.cn/problem/P3629)

#### 题目大意

给定一棵 n 个节点的树，树上的每条边边权都为 1。我们规定“巡逻距离”是从 1 号点出发将树上所有遍历至少一次再回到起点所走过的边权和。现在在树上添加 1 或 2 条边，规定添加的边**必须且只能走一次**，求最短的巡逻距离。

#### 思路

在还没有添加任何边的时候，巡逻距离显然是 $2*(n-1)$，因为在树上巡逻一次相当于做了一遍 DFS，每条边都会被递一次归一次 —— 换句话说，由于是一棵树，所以从 1 号点到达每一点的最短路径是唯一的，而对于每个节点 $vertex[i]$，直接连接它的边 $edge[j]$ 都会在到达 $vertex[i]$ 和从 $vertex[i]$ 返回时各被走一遍。

![添加一条边.png](https://i.loli.net/2020/06/04/qT4RLzgUOuF9amc.png)添加一条边的时候也很简单，因为添加一条边相当于在图上添加了一个环，由于每条边都要巡逻到，我们要把这个环完整地走一遍。对于题目中给出的样例树，我们添加一条 $edge_{2,8}$，那么现在就有由 8，5，3，1，2 构成的环。原本遍历环上的边（除了新添加的那条）巡逻距离为 8，但是现在我们走这个环距离就只有 5 —— 环上每条边都少走了一次，取而代之的是走了一次新添加的边。对于树上的一条链，如果用其两端点为 $i,j$，其长度为 $chain[i][j]$，那么在这种情况下我们遍历这个链只需要 $chain[i][j]+1$ 的路程，即可以节约 $chain[i][j]-1$ 的路程。

所以添加一条边的时候，我们只需要求出树的直径长度 $treeLength$，巡逻路径长度便是 $2*(n-1)-(treeLength-1)$。

添加两条边时，我们按照上面的思路添加好第一条边，重点处理第二条边。添加第二条边就又增加了一个环，如果这个环与第一个环毫不相干，那么只需要按照上面的方法计算第二个环节约的路径长度。

![添加两条边.png](https://i.loli.net/2020/06/04/5vs4JYrUhQm9VRa.png)但是当第二个环与第一个环有重合的边时，事情就没有那么简单了。对于题目中给出的样例树，再添加一条 $edge_{4,6}$，就形成了由 3，5，6，4 构成的第二个环。此时 $edge_{3,5}$ 既在第一个环上又在第二个环上。由于每条边都要被巡逻到，我们必须要把第二个环也完整地走一遍。这样一来 $edge_{3,5}$ 就被走了两边，和不添加任何边的时候相同。也就是说添加第一条边的时候减少的那次，又被走回来了。

我们可以认为添加一条边时求出的直径是“要被减少的距离”，因为有直径长度的边被少走了一次。现在添加第二条边时有些边少走的那一次被加回来了，我们可以将第一次求出的直径上的所有边权取负，这样在走第二个环的时候走上这些重合的边，将会在答案中减去这条边的边权，即“不仅没有再减少距离，反而还让本来被减少的边又被走了”。

再修改后的树上求直径添加第二条边，这个题就基本做完了。同添加第一条边一样，节省的路径长度是 $treeLength-1$。

回过头来看，第一次我们不仅需要求出树直径的长度，而且还需要求出直径的具体方案，因此使用两次搜索的方法；第二次只需要求出直径的长度，且因为修改后出现了负权边，所以要使用树形 DP 的方法求直径 —— 一次就把两种方法练了，这难道不是一道很妙的题吗？

#### Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<queue>
#define des edge[i].destinationVertex
using namespace std;
const int MaxN = 100005;
struct Edge{
    int destinationVertex, nextEdge, value;
}edge[MaxN * 2];
struct Vertex{
    int depth, father;
    bool vis;
}vertex[MaxN];
int head[MaxN], tot, n, k, deepest, treeLength;
bool vis[MaxN];

inline void AddEdge(int u, int v){
    tot++;
    edge[tot].destinationVertex = v;
    edge[tot].nextEdge = head[u];
    edge[tot].value = 1;
    head[u] = tot;
}

inline void Reset(){
    for(int i=1;i<=n;i++){
        vertex[i].depth = 0;
        vertex[i].vis = false;
    }
}

inline void BFS(int x, int secondTime){
    Reset();
    queue<int> q;
    q.push(x);
    vertex[x].vis = true;
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        for(int i=head[cur];i;i=edge[i].nextEdge){
            if(!vertex[des].vis){
                vertex[des].vis = true;
                vertex[des].depth = vertex[cur].depth + edge[i].value;
                q.push(des);
                if(secondTime) vertex[des].father = cur;
            }
        }
    }
    for(int i=1;i<=n;i++)
        if(treeLength < vertex[i].depth){
            treeLength = vertex[i].depth;
            deepest = i;
        }
}

inline void Change(int x){
    while(vertex[x].father){
        int fa = vertex[x].father;
        for(int i=head[fa];i;i=edge[i].nextEdge){
            if(des == x){
                edge[i].value = -1;
                break;
            }
        }   
        for(int i=head[x];i;i=edge[i].nextEdge){
            if(des == fa){
                edge[i].value = -1;
                break;
            }
        }
        x = fa;
    }
}

inline void DP(int x){
    vertex[x].vis = true;
    for(int i=head[x];i;i=edge[i].nextEdge){
        if(vertex[des].vis) continue;
        DP(des);
        treeLength = max(treeLength, vertex[x].depth + vertex[des].depth + edge[i].value);
        vertex[x].depth = max(vertex[x].depth, vertex[des].depth + edge[i].value);
    }
}

int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<n;i++){
        int u, v;
        scanf("%d%d",&u,&v);
        AddEdge(u,v), AddEdge(v,u);
    }
    if(k == 1){
        BFS(1, 0);
        BFS(deepest, 0);
        printf("%d", 2 * n - vertex[deepest].depth - 1);
    }
    else{
        BFS(1, 0);
        BFS(deepest, 1);
        int firstLength = vertex[deepest].depth;
        Change(deepest);
        Reset();
        treeLength = 0;
        DP(1);
        printf("%d", 2 * n - treeLength - firstLength);
    }
    return 0;
}
```



---

## 作者：yingyudou (赞：2)

[题目链接][1]
[1]:https://www.luogu.org/problemnew/show/P3629
——萌新第一份题解

## 题意简述
n个村庄连成一棵树，每条边长1。警察蜀黍要从1号节点开始跑，跑遍所有边（可以重复），回到起点。为了省油费，可以新建k条边$(1\le k\le2)$，新建的边只能且必须跑一次。问要跑的最小距离。
## 题解
首先，我们考虑村庄懒得修路的情况。
因为每条边都需要跑一次，且最终要回到起点，所以每条边都会经过两次，总路程为$2(n-1)$。

我们可以发现，当在两点之间新建边时，省去的油费相当于**两点原来的距离**，因为跑了新边就可以少跑一次原来的路径。那么，为了省去更多的油费，选择跳过的路径需尽量长。

**最长的路径？直径！**

所以，当$k=1$时，问题就简单了，我们只需在**直径的两端点**间建边即可。若直径长$L$，答案就是$2(n-1)-L+1$。

同理，若要建第二条新边，同样会再出现一个环。

若两次建边形成的环**不重叠**，那么答案直接再减去这次省去的油费即可。

若**重叠**，原本只跑一次的边一趟，变成一次都不跑。而题目要求所有边都必须跑，苦逼的警察蜀黍还得再去跑这些边，再跑回来，一趟又变回了两趟……

到这里，我们只需要**yy**一下，便可得出正解：

**1.** 在原树上求直径，长为$L1$，

**2.** 把直径上的边都取反（边权改为$-1$）

**3.** 再求一遍直径，长为$L2$

**4.** 答案为$2(n-1)-(L1-1)-(L2-1)$

其实考虑重叠的边，第一次减减去的是$1$，第二次再减减去的是$-1$，相当于**走两趟**变为**走一趟**再变为**走两趟**，此做法正确性得证。

附上代码：

——用了两种找直径方法供参考（原理不再赘述）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n,k;
int a,b;
int len,lin[N];
struct nc{int y,nxt,v;}e[N<<1];
int d[N],mx,id;
int u,v;
bool f;
int ans;
inline int read()
{
    int N=0,C=0;
    char tf=getchar();
    while(!isdigit(tf))C=tf=='-',tf=getchar();
    while(isdigit(tf))N=(N<<1)+(N<<3)+(tf^48),tf=getchar();
    return C?-N:N;
}
inline void ins(int x,int y)
{
    e[++len].nxt=lin[x];
    lin[x]=len;
    e[len].y=y;
    e[len].v=1;
}
void dfs(int x,int fa)
{
    for(int i=lin[x];i;i=e[i].nxt)
    {
        int y=e[i].y,v=e[i].v;
        if(y==fa)continue;
        d[y]=d[x]+v;//这里的d[x]表示从根到x的距离
        if(d[y]>mx)mx=d[y],id=y;
        dfs(y,x);
    }
}
void change(int x,int fa)
{
    if(x==v){f=1;return;}//找到直径
    for(int i=lin[x];i;i=e[i].nxt)
    {
        int y=e[i].y;
        if(y==fa)continue;
        change(y,x);
        if(f)
        {
            e[i].v=-1;
            i&1?e[i+1].v=-1:e[i-1].v=-1;//双向边
            return;
        }
    }
}
void dp(int x,int fa)
{
    for(int i=lin[x];i;i=e[i].nxt)
    {
        int y=e[i].y,v=e[i].v;
        if(y==fa)continue;
        dp(y,x);
        mx=max(mx,d[x]+d[y]+v);//这里的d[x]表示x往它的子树走的最远距离
        d[x]=max(d[x],d[y]+v);
    }
}
int main()
{
    n=read(),k=read();
    ans=(n-1)<<1;
    for(int i=1;i<n;++i)
    {
        a=read(),b=read();
        ins(a,b),ins(b,a);
    }
    d[1]=mx=0,dfs(1,0),u=id;
    d[u]=mx=0,dfs(u,0),v=id;//第一次需要找出直径两端点u,v
    ans-=mx-1;
    if(k==1){printf("%d",ans);return 0;}
    change(u,0);//取反
    memset(d,0,sizeof(d));
    mx=0,dp(1,0);//第二次只需找出直径长度
    ans-=mx-1;
    printf("%d",ans);
    return 0;
}
```
嫌代码丑的大佬勿喷>_<

欢迎提问……和hack……

---

## 作者：Jμdge (赞：2)

树形dp 好题，考察的主要是树的直径之类的东西。

首先我们看到 K 只有两种情况：1 \ 2

# $first$

对于 1 的情况比较简单，我们考虑题目中给出的树是以 1 号点为根的树，那么我们连的边必然可以和这棵树中的一条路径形成环（并且一般的，我们会选择两个叶子结点作为路径的起点和终点）。

然后我们思考这条路径的贡献：这条新加的边使连上的路径减少了一次访问。
那么也就是说，这条新边的贡献就是路径长度-1（因为新加的边要走一次）。

那么我们只要找出树的直径，把端点连起来就好了。

# $second$

第二种情况，首先是基于第一种情况执行完毕之后的。

也就是说，我们要先来一遍 $first$ 中的步骤。

那么现在我们考虑再加一条边。

那么容易得出：如果新加的这条边所涵盖的路径与 $first$ 中处理出的直径的边毫无交集的话，那么他们的贡献是不会相互影响的。

那么如果相交了？

那么我们在草稿纸上画一画就知道了：相交的边会走两次。

也就是说重叠的边贡献抵消了（第二次加边也许会起部分反作用）

那么我们可以将 $first$ 步骤中的直径中的边的边权（一开始是 1 ），全部改成 -1。 然后再跑一遍直径，这时候第二次加边的最大贡献就出来了。

那么如果这棵树是一条链呢？那么我们在第二次连边的时候随便连一条自环（题目中有说可以自环）就好了。


# $third$

既然说要找直径所覆盖的边。。。那么推荐做一下这一道题：

  $Loj 10159$ [「一本通 5.2 练习 2」旅游规划](https://loj.ac/problem/10159)


----


### 然后是...

灰常简洁的代码...（建议在 dev 中 $ctrl + shift + A$ 了之后再看）


```cpp
//by Judge
#include<iostream>
#include<cstdio>
using namespace std;
const int M=1e5+111;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,K,pat,res,ans,root,head[M],fir[M],sec[M],ch[M][2];
struct Edge{ int to,val,next; Edge(int to,int val,int next):to(to),val(val),next(next){} Edge(){} }e[M<<1];
inline void add(int u,int v){ e[++pat]=Edge(v,1,head[u]),head[u]=pat, e[++pat]=Edge(u,1,head[v]),head[v]=pat; }
#define v e[i].to
int dfs(int u,int fa){ //找当前树的直径
	fir[u]=sec[u]=0,ch[u][1]=ch[u][0]=-1;
	for(int i=head[u],dis;i;i=e[i].next){
		if(v==fa) continue; dis=dfs(v,u)+e[i].val;
		if(dis>=fir[u]) sec[u]=fir[u],fir[u]=dis,ch[u][1]=ch[u][0],ch[u][0]=v;
		else if(dis>=sec[u]) sec[u]=dis,ch[u][1]=v;
	} if(ans<fir[u]+sec[u]) ans=fir[u]+sec[u],root=u; return fir[u];
}
//找直径路径
void dfs(int u){ for(int i=head[u];i;i=e[i].next) if(v==ch[u][0]) e[i].val=-1,dfs(v);  }
#undef v
signed main(){
	n=read(),K=read(),res=n-1<<1,ans=0;
	for(int i=1,u,v;i<n;++i) u=read(),v=read(),add(u,v);
	dfs(1,0),res-=ans-1,ans=0; if(K==1) return !printf("%d\n",res); //=1 直接输出
	for(int i=head[root];i;i=e[i].next) //找直径的边
		if(e[i].to==ch[root][0] || e[i].to==ch[root][1])
			e[i].val=-1,dfs(e[i].to);
	dfs(1,0),res-=ans-1; return !printf("%d\n",res);
}
```

---

## 作者：yjxyjx (赞：2)

这道题…是某书上面的例题...

------

### 30分做法

直接求树的直径的长度(设 $L_1 = $ 树的直径), 然后用一个式子:$2 \times (n - 1) -L_1 + 1$ (其中$- L_1 $表示:直径上的只用走一次)

~~算了还是放一下代码吧QWQ~~:
```cpp
#include <bits/stdc++.h>

const int MaxN = 100000 + 10;
const int MaxM = MaxN * 2;

int n, k, v[MaxM], next[MaxM], last[MaxN], edgeNum = 0, p = 0, q = 0, maxLen = 0, fuck = 0;

inline int GetInt() {
    int x = 0, f = 1; char ch;
    do {ch = getchar(); if (ch == '-') f = -1;} while (ch < '0' || ch > '9');
    do {x = x * 10 + ch - '0'; ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

inline void AddEdge(const int &x, const int &y) {
    v[++edgeNum] = y;
    next[edgeNum] = last[x];
    last[x] = edgeNum;
}

bool visit[MaxN];

void DFS1(int now, int len) {
    visit[now] = true;
    if (len > maxLen) {
        p = now;
        maxLen = len;
    }
    for (int i = last[now]; i; i = next[i]) {
        int end = v[i];
        if (!visit[end]) {
            DFS1(end, len + 1);
        }
    }
}

int main() {
    n = GetInt(); k = GetInt();
    for (int i = 1; i <= n - 1; ++i) {
        int x = GetInt(), y = GetInt();
        AddEdge(x, y); AddEdge(y, x);
    }
    memset(visit, false, sizeof visit);
    DFS1(1, 0);
    memset(visit, false, sizeof visit);
    DFS1(p, 0);
    std::cout << 2 * (n - 1) - maxLen + 1 << std::endl;
    return 0;
}

/*本做法只寻找树的直径, 预计得分30分*/
```

-------

### 100分做法

上面的直接可以用在$k = 1$的任务里.

至于...$k = 2$时:

首先: 第二条边的选择:
   由于选择第二条边之后又会形成一个环, 我们要考虑:
      1. 第二条边的环与第一条边形成的环相重叠.
      
      2. 不重合.  
   对应情况:
      1. 重叠的话, 意味着两个环重叠的部分又要被巡逻两遍.
      2. 不重合, 那么新的环又只需要走一遍.
综上所述, 我们得到如下算法:

1. 在最初的树上求直径, 设第一次得到的直径为$L_1$, 然后把直径上的边权取反(从$1$改为$-1$).

2. 在最长链边权取反后的树上再次求直径, 设直径为$L_2$.

答案就是$2 \times (n - 1) - L_1 + 1 - L_2 + 1$

(好吧上面那么学术又抽象的算法引用自《算法竞赛进阶指南》).

代码:
```cpp
#include <bits/stdc++.h>

const int MaxN = 100000 + 10;
const int MaxM = MaxN * 2;

int n, k, v[MaxM], next[MaxM], last[MaxN], edgeNum = 1, p = 0, q = 0, maxLen = 0, weight[MaxM], dis[MaxN];

inline int GetInt()
{
    int x = 0, f = 1;
    char ch;
    do
    {
        ch = getchar();
        if (ch == '-')
            f = -1;
    } while (ch < '0' || ch > '9');
    do
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    } while (ch >= '0' && ch <= '9');
    return f * x;
}

inline void AddEdge(const int &x, const int &y, const int &w)
{
    v[++edgeNum] = y;
    next[edgeNum] = last[x];
    weight[edgeNum] = w;
    last[x] = edgeNum;
}

bool visit[MaxN];

void DFS1(int now, int len)
{
    visit[now] = true;
    if (len > maxLen)
    {
        p = now;
        maxLen = len;
    }
    dis[now] = len;

    for (int i = last[now]; i; i = next[i])
    {
        int end = v[i];
        if (!visit[end])
        {
            DFS1(end, len + weight[i]);
        }
    }
    visit[now] = false;
}

int MarkEdgeDfs(const int &now)
{

    if (!dis[now])
        return 1;
    for (int i = last[now]; i; i = next[i])
    {
        int end = v[i];
        // std::cerr << "QAQ" << v[i] << "\n";
        if (dis[end] == dis[now] - 1)
        {
            if (MarkEdgeDfs(end))
            {
                weight[i] = weight[i ^ 1] = -1;
                // std::cerr << "QAQQAQ\n";
                return 1;
            }
        }
    }
    return 0;
}

void DP(const int &now)
{
    visit[now] = 1;
    for (int i = last[now]; i; i = next[i])
    {
        int end = v[i];
        if (visit[end])
            continue;
        DP(end);
        maxLen = std::max(maxLen, dis[now] + dis[end] + weight[i]);
        // std::cerr << "mx == " << maxLen << "\n";
        dis[now] = std::max(dis[now], dis[end] + weight[i]);
    }
}

inline void debug1()
{
    for (int i = 1; i <= edgeNum + 5; ++i)
    {
        // std::cerr << "weight[" << i << "] == " << weight[i] << "\n";
    }
}

int main()
{
    n = GetInt();
    k = GetInt();
    int ans = 2 * (n - 1);
    for (int i = 1; i <= n - 1; ++i)
    {
        int x = GetInt(), y = GetInt();
        AddEdge(x, y, 1);
        AddEdge(y, x, 1);
    }
    memset(visit, false, sizeof visit);
    DFS1(1, 0);
    maxLen = -1e9;
    memset(dis, 0, sizeof dis);
    DFS1(p, 0);
    ans = ans - maxLen + 1;
    if (k == 1)
    {
        std::cout << ans << std::endl;
        return 0;
    }
    // std::cerr << "p == " << p << "dist == " << dis[p] << "\n";
    MarkEdgeDfs(p);
    debug1();
    maxLen = 0;
    memset(visit, false, sizeof visit);
    memset(dis, 0, sizeof dis);
    DP(1);
    std::cout << ans - maxLen + 1;
    return 0;
}

```
~~为什么满分做法的代码风格如此鬼畜呢~~

~~因为我把这篇代码搬运回vs code后发生了奇妙的格式化~~

能用$DP$求第一次的树的直径吗?

好像不行, 因为“将直径取反的时候”, 要记住直径所在的节点.

~~至于我这种做法那都是题解区dalao们的奇技淫巧QWQ~~

---

## 作者：ysner (赞：2)

[更好的阅读体验](https://zybuluo.com/ysner/note/1164854)
##题面

给定一颗树，现可加入$k$（$k=1,2$）条边，问在加边后，从$1$号节点出发走遍所有点再回到$1$号点最小距离是多少？
##解析

（大前提：加入虚边，统计实边）

$k$的范围耐人寻味，可以尝试用分类讨论完成此题。
###$k=1$
没加边时，最小距离是**边数×2**。
要减距离就从这些  本来就存在的边上  来。
加了一条虚边（*不是自环*）后，整个图转变为一个环套树。
环越大，距离越小。
如何让环的大小最大？
把树的直径两端连起来即可。
这时最小距离改变为**环的大小+环外边数×2**
减少的距离为**环的大小-2**（因在加边之前，环其它边对距离的贡献为**（环的大小-1）×2**,加完后变为**环的大小**）。
同时等价于**树的直径-1**

###$k=2$
这时我们要在环套树上加一条虚边。
再加一条边，会引起什么改变呢？

$step\ 1$ **虚边两端点都在环外**

这肯定是更优的,减少的距离还是**树的直径-1**。($1$代表新加入的边）

$step\ 2$ **虚边一端点在环内**

这样会形成两个有公共边的环。

要符合要求地走完它，就要额外把公共边多走一遍。（画图理解）

则距离减少量为**-公共边数量+新纳入环的实边数-1**($1$代表新加入的边）

$step\ 3$ **虚边两端点都在环内**

这种情况貌似是上一种的特殊情况。

因为**新纳入环的实边数=0**

所以这种做法是不存在的。

##实现

发现$step\ 1$和$step\ 2$式子可以合并，$so\ happy...$

肯定先找一遍树的直径。

然后把在环中的边权标为$-1$，再找一遍。

**注意到这次就不能用bfs找直径了，只能用DP，反正不用找出树的直径上的边**

找出的直径是不是正数，说明加边肯定亏，那就加自环吧。
```
// luogu-judger-enable-o2
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=1e5+100;
int n,k,h[N],cnt=1,mx,pos,dis[N],ans;
bool vis[N];
struct Edge{int to,next,w;}e[N<<1];
il void add(re int u,re int v){e[++cnt]=(Edge){v,h[u],1};h[u]=cnt;}
il int gi()
{
  re int x=0,t=1;
  re char ch=getchar();
  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
il void dpdp(re int u)
{
  vis[u]=1;
  for(re int i=h[u];i+1;i=e[i].next)
    {
      re int v=e[i].to;
      if(vis[v]) continue;
      dpdp(v);
      mx=max(mx,dis[u]+dis[v]+e[i].w);
      dis[u]=max(dis[u],dis[v]+e[i].w);
    }
}     
il void dfs(re int u,re int len)
{
  vis[u]=1;if(len>mx) mx=len,pos=u;dis[u]=len;
  for(re int i=h[u];i+1;i=e[i].next)
    {
      re int v=e[i].to;
      if(vis[v]) continue;
      dfs(v,len+e[i].w);
    }
  vis[u]=0;
}
il int dfsb(re int u)
{
  if(!dis[u]) return 1;
  for(re int i=h[u];i+1;i=e[i].next)
    {
      re int v=e[i].to;
      if(dis[v]==dis[u]-1)
    if(dfsb(v)) {e[i].w=e[i^1].w=-1;return 1;}
    }
  return 0;
}
int main()
{
  memset(h,-1,sizeof(h));
  n=gi();k=gi();ans=(n-1)*2;
  fp(i,1,n-1)
    {
      re int u=gi(),v=gi();
      add(u,v);add(v,u);
    }
  dfs(pos=1,0);
  mx=-1e9;memset(dis,0,sizeof(dis));
  dfs(pos,0);//printf("%d\n",pos);
  ans-=mx-1;
  if(k==1) {printf("%d\n",ans);return 0;}
  dfsb(pos);mx=0;memset(vis,0,sizeof(vis));memset(dis,0,sizeof(dis));
  dpdp(1);
    ans-=mx-1;
  printf("%d\n",ans);
  return 0;
}
```

---

## 作者：heyuhhh (赞：2)

如果考虑不算上新修的道路，那么答案显然为$2*(n-1)$。

考虑$k=1$的情况，会发现如果我们新修建一个道路，那么就会有一段路程少走一遍。这时选择连接树的直径的两个端点显然是最优的。

难就难在$k=2$的时候，还是上面的思路，首先肯定连接两个叶子结点最优。假设我们连接的是$x,y$两个叶子结点，它们到直径的距离分别为$dis[x],dis[y]$，并设直径上两点的距离为$d[u,v]$，这里$u,v$分别为叶子结点所在链和直径的交点。

因此最后的答案会增加$d[u,v]-dis[x]-dis[y]$。要使答案最小，那么也就也是使得$dis[x]+dis[y]-d[u,v]$最大。脑补一下，就会发现这其实就是在所有直径上面的边权取反过后，树的最长链。

所以再求一次树的直径就好了。因为最后有负边权存在，通过$dfs/bfs$来求会出错。所以最后dp一次就好啦。

代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
int n, k;
struct Edge{
    int u, v, next, w;
}e[N << 1];
int head[N], tot;
void adde(int u, int v) {
    e[tot].w = 1; e[tot].v = v; e[tot].next = head[u]; head[u] = tot++;
}
int vis[N], f[N], d[N], dp[N];
void dfs(int u, int fa) {
    f[u] = fa;
    for(int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].v;
        if(v != fa) {
            d[v] = d[u] + e[i].w;
            dfs(v, u) ;
        }
    }
}
int mx, p, L;
void Get(int x) {
    d[x] = mx = 0;
    dfs(x, 0);
    for(int i = 1; i <= n; i++)
        if(d[i] > mx) mx = d[i], p = i;
}
int solve() {
    Get(1);Get(p);
    return mx;
}
void dfs2(int u, int fa) {
    vis[u] = 1;
    for(int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].v;
        if(v == fa || !vis[v]) continue ;
        e[i].w = e[i ^ 1].w = -1;
        dfs2(v, u) ;
    }
}
void Dp(int u, int fa) {
    for(int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].v;
        if(v == fa) continue ;
        Dp(v, u);
        L = max(L, dp[u] + dp[v] + e[i].w) ;
        dp[u] = max(dp[u], dp[v] + e[i].w) ;
    }
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> k;
    memset(head, -1, sizeof(head)) ;
    for(int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        adde(u, v); adde(v, u);
    }
    int l = solve() ;
    int ans = 2 * (n - 1) - l + 1;
    if(k == 2) {
        int u = p;
        while(u != 0) {
            vis[u] = 1;
            u = f[u];
        }
        dfs2(p, 0) ;
        Dp(1, 0) ;
        ans = ans - L + 1;
    }
    cout << ans ;
    return 0;
}

```


---

## 作者：JoaoFelix (赞：1)

sry_两年前就切了这道题orz%%%

这题主要是涉及了一些有关于树的直径的套路。

我们在有关于一些最小化什么距离之类的题目，大部分会用到一些关于树的直径相关的问题。

首先我们发现当k=0的时候就是每条边都走一遍。

如果k=1的时候就是直径上的点不需要走，然后其他没条边都要走一遍。

依次类推，我们感觉k=2的时候也是有有关于最优性的规律的

我们发现如果两个环有交，有交的边就是走两遍，其他在环上的点我们走一遍，剩下的我们也要走两遍。

关于这个怎么处理？

我们可以先求一个直径，然后第二遍做的时候第一条直径上的边设为-1，其他为1，再跑一遍直径就ok了。

需要注意的是有负权的边，我们求直径要用一个dp，然后第一遍可以dfs或者bfs。

大概这个证明可以意会一下，可以用反证法来证明第一条直径如果有多个相同的，取哪个都一样！

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
#define pii pair<int,int>
using namespace std;
const int N=1e5+5;
struct Graph{int u,v;}gra[N];
int n,k,res;
vector<pii>adj[N];
void adde(int u,int v,int w){adj[u].pb(pii(v,w));}
namespace T1{
	int fa[N],oth,md,pos;bool od[N];
	void dfs(int u,int d,int f){
		fa[u]=f;if(d>md)md=d,pos=u;
		for(auto edg:adj[u]){
			int v=edg.first,w=edg.second;
			if(v!=f)dfs(v,d+w,u);
		}
	}
	void solve(){
		md=-1;dfs(1,0,0);oth=pos;
		md=-1;dfs(pos,0,0);
		while(pos!=oth)od[pos]=true,pos=fa[pos],res++;
		od[oth]=true;
		if(k==1){printf("%d\n",((n-1)<<1)-res+1);exit(0);} 
		for(int i=1;i<=n;i++)adj[i].clear();
		for(int i=1,u,v;i<n;i++){
			u=gra[i].u;v=gra[i].v;
			if(od[u]&&od[v])adde(u,v,-1),adde(v,u,-1);
			else adde(u,v,1),adde(v,u,1);
		}
	}
}
namespace T2{
	int ans,d[N];
	void dfs(int u,int f){
		for(auto edg:adj[u]){
			int v=edg.first,w=edg.second;
			if(v!=f)dfs(v,u),ans=max(ans,d[u]+d[v]+w),d[u]=max(d[u],d[v]+w);
		}
	}
	void solve(){
		dfs(1,0);
		printf("%d\n",((n-1)<<1)-res+1-ans+1); 
	}
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1,u,v;i<n;i++)
		scanf("%d%d",&u,&v),gra[i]=(Graph){u,v},adde(u,v,1),adde(v,u,1);
	T1::solve();T2::solve();
	return 0;
}

```


---

## 作者：xixike (赞：1)

**前置知识**： 树的直径，树的最长链。

首先，我们考虑当不建立新的道路时，从1号结点出发，把树上每一条边遍历一次，在返回1号节点,一定会经过每条边恰好两次，**所以路线总长度为$\bold{2×(n-1)}$**。

建立1条新的道路后，因为新的道路一定要经过一次，所以沿着新建道路$(x_1,y_1)$巡逻过之后，要返回$x_1$，就必须沿着原来的树上$y_1$至$x_1$的路径返回，也就是说，$x_1$至$y_1$的路径从不建新边的树中需要走2次到建立1条新边后只需走一次。

因此，当$k=1$时，我们要找到树的最长链，在两个端点，之间增加一条新的道路，就能使巡逻总距离最小。我们设树的直径为$L_1$,**则路线总长度为$\bold{2×(n-1)-L_1+1}$**。

建立第2条新边$(x_2,y_2)$后，又会形成一个环，所以根据上面的推论，我们可以设建立1条边后的树的直径长度为$L_2$，**所以现在路线总长度为$\bold{2×(n-1)-L_1+1-L_2+1} = \bold{2×n-L_1-L_2}$**。
但是两次求的树的最长链会有重复的部分（如下图），并且题目要求我们要遍历所有的边.图中$(3,5)$的边就是两条直径重复的边，没有被遍历到，所以我们要将第一条最长链上的所有边权值重新赋值为$-1$，。

![](https://cdn.luogu.com.cn/upload/image_hosting/wvhkjj86.png)

**综上所述，我们得到以下算法**：

1. 在最初的树上求直径，设直径为$L_1$。然后把直径上的边权值取反（1变为-1）。
2. 在最长链边权取反之后的树上再次求直径，设直径为$L_2$,答案就是$\bold{2×(n-1)-L_1+1-L_2+1} = \bold{2×n-L_1-L_2}$。

关于树的直径如何求，有两种方法：

1. 树形dp
2. 两遍dfs或bfs

这里不再赘述，不会的可以自行去查阅相关资料。

**附代码**
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 100010

using namespace std;

struct node{
	int u,v,w,next;
}edge[N<<1];//前向星存树
int head[N],tot;
int vis[N],fr[N];//vis判断是否为最长链上的点，fr利用前向星存树的最长链
int n,k;
int ans1,ans2;//ans1为建立第一条边后的树的直径，ans2为建立第二条边后的
int id,start,end,res;//start,end分别存树的最长链的两个端点
int flag;
int dis[N];

void add(int x,int y,int z){
	tot++;
	edge[tot].u=x;
	edge[tot].v=y;
	edge[tot].w=z;
	edge[tot].next=head[x];
	head[x]=tot;
}//加入边

void dfs(int x,int fa,int sum){
	if(sum>=res){
		res=sum;
		id=x;
	}
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].v;
		if(y!=fa)
			dfs(y,x,sum+edge[i].w);
	}
}//两遍dfs求树的直径

void get_path(int now,int nex,int fa){
	if(flag) return;//flag判断是否到达最长链另一端，到了直接return
	for(int i=head[now];i;i=edge[i].next){
		if(flag) return;
		int y=edge[i].v;
		if(y==fa) continue;//判断是否为父亲节点
		if(y==nex){//如果到达终点，flag=1，并return
			fr[now]=y;
			flag=1;
			return;
		}
		fr[now]=y;
		get_path(y,nex,now);//递归找路径
	}
}//找出树的直径经过的路径

void dp(int x,int fa){
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].v;
		if(y==fa) continue;
		dp(y,x);
		ans2=max(ans2,dis[x]+dis[y]+edge[i].w);
		dis[x]=max(dis[x],dis[y]+edge[i].w);
	}
}//树形dp求树的直径

int main(){
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v,1);
		add(v,u,1);
	}
//----------------------------------
	dfs(1,0,0);//两遍dfs求树的直径
	res=0;
	start=id;
	dfs(id,0,0);
	end=id;
	ans1=res;
//----------------------------------
	if(k==1){
		cout<<2*(n-1)-res+1<<endl;
		return 0;
	}
	get_path(start,end,0);
	vis[start]=vis[end]=1;
	for(int i=start;i!=end;i=fr[i])
		vis[i]=1;//把树的最长链上的点全部标记为1
	for(int i=1;i<=n;i++)//最长链权值取反
		if(vis[i])
			for(int j=head[i];j;j=edge[j].next){
				int y=edge[j].v;
				if(vis[y])
					edge[j].w=-1;
			}
	dp(1,0);//树形dp求树的直径
	cout<<2*n-ans1-ans2<<endl;
	return 0;
}
```


---

## 作者：红色OI再临 (赞：1)

考虑不加边，每条边都要回溯一遍，答案为$2*(n-1)$

加上一条边后，答案为$2*(n-1)-l+1$(`l`为最长链长度）。

再考虑加上两条边，可以先求出最长链的距离，将最长链上

的边权都取反，再求一次最长链，因为加上第二条边可以分

为与第一条边环重合或者不重合，但无论是哪种，都可以剪掉两个环的大小，只不过重合的时候要加上重合部分而已.

所以可以将最长链的边权取反，答案为$(n-1)*2-(L1-1)-(L2-1)$

思维难度还是有，特别就是在最长链取反那里，剪掉重合部分一个不好求的问题被取反操作巧妙的解决了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define re register int
#define ll long long 
#define MAXN 100010
#define inf 0x3f3f3f3f;
using namespace std;
struct EDGE{
	int u,v,w,nxt;
}e[MAXN*2];
int a[MAXN],head[MAXN],d[MAXN],pre[MAXN],vis[MAXN];
int n,m,k,l1,l2,cnt=1;//反向边
void add(int u,int v,int w){
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].nxt=head[u];
	e[cnt].w=w;
	head[u]=cnt;
}
int bfs(int x){
	memset(d,0,sizeof(d));
    memset(vis,0,sizeof(vis));
    memset(pre,0,sizeof(pre));
	int ans=0;
	queue<int>q;
	q.push(x);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=1;
		for(re i=head[u];i;i=e[i].nxt){
			int v=e[i].v,w=e[i].w;
			if(vis[v])continue;
			d[v]=d[u]+w;
			pre[v]=i;
			q.push(v);
		}
	}
	for(re i=1;i<=n;i++)
		if(d[ans]<d[i])ans=i;
	return ans;
}
void dp(int u){
	vis[u]=1;
	for(re i=head[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(vis[v])continue;
		dp(v);
		l2=max(l2,d[v]+d[u]+w);
		d[u]=max(d[u],d[v]+w);
	}

}
int main(){
	scanf("%d%d",&n,&k);
	for(re i=1;i<=n-1;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v,1);
		add(v,u,1);
	}
	int l=bfs(1);
	int r=bfs(l);
	l1=d[r];
//	printf("%d\n",l1);
	if(k==1){
		printf("%d\n",2*(n-1)-l1+1);
		return 0;
	}
	int x=r;
	while(x!=l){
		int i=pre[x];
		e[i].w=e[i^1].w=-1;
		x=e[i^1].v;
	}//将直径上的边权取反
	memset(vis,0,sizeof(vis));
    memset(d,0,sizeof(d));
	dp(1);
	printf("%d\n",2*n-l1-l2);
  //其实原来是2*(n-1)-(l1-1)-(l2-1),若两个环有重叠，相当于加上重叠部分
	return 0;
}
```


---

## 作者：iamY (赞：1)

## **题目大意：在一个n个点，（n-1）条边无向图中添加k条边（k为1/2），然后求遍历完整个图的最小距离//题目声明每条边的距离都为1**
### 那么就可以看出k的值非常小，只能取1或2，那么我们就来对k进行分析入手：
### 1.当我们不需要添加任何一条边时：
####  我们可以推出要搜完所有边，就必须要经过2(n-1)的距离，因为每个点都有边连接，所以对于每个边，我们搜索时就要递归一次，回溯一次。即每一条边都会被经过2次。（这个很显然吧，怕~~奆奆们~~不理解，给张图了解一下）
#  (^-^)
![](https://t1.picb.cc/uploads/2019/07/29/grjBwi.png)
### 2.新加入一条边时：
#### 我们会发现变成了n个点，n条边的情况，也就是说，必定会有环的出现，但是稍微观察一下即可发现：新成的那个环上的每一条边都只用经过一次了！！ :) 也就是说我们省了很多距离，也就与我们要求的东西合上拍了，那么也就是说我们要答案最小，就只需要找到这颗树上相距最远的两个节点，找到树的直径，设其长度为L，将他们连一条边，然后就有了答案，ans=2*(n-1)-L+1=2n-2-L+1=2n-L-1;
![](https://t1.picb.cc/uploads/2019/07/29/grpZLM.jpg)
###### //蓝色的部分每条边只用遍历一次
### 3.要加入2条边时：
#### 在新加入一条边的基础上，又会多出来一个新的环如果两个环不重合的话，那么还是每个环上的边都只用遍历一次；如果有重合部分的话，那么为了保证每条边都遍历到，那就只有遍历那两条边两次；
![](https://t1.picb.cc/uploads/2019/07/29/grpUHJ.jpg)//蓝色部分要遍历2次
### 那么我们可以由以上思路推得一个题解思路
#### Step One:在最初的树上求直径，设直径为L1，再把直径上的边权取反。
/***为什么要去取反呢？？
Because:我们还要再一次求直径，但是如果让他们不改变的话，会重复计算同一条直径，重复计算不但不会变少，还会变得越来越大,所以我们只需要将边权变成相反数，即可避免这种情况***/
#### //ps：如果只用加一条边，那么就计算完第一遍直径就可以直接输出了，ans=a*n-L1-1。与后面的计算完全没有一点关系所以要记得分类讨论
#### Step Two：在后来的树上再次求直径，设直径为L2
### **Thus，我们要的答案就是2*(n-1)-(L1-1)-(L2-1)=2n-L1-L2*
#### //经过我们的第一波操作，两个环的重叠部分（那个本来要经过两次的边）就变成只用经过一次了，而在计算一次后就相当于把我们之前减去的又加了回来（取了反）


~~放一波代码，行善积德~~
------------
```
#include<bits/stdc++.h>
using namespace std;
int n,m,bj,S1,maxx,maxxx,maxn,cnt=1,h[200005],vst[200005],dis[200005],prt[200005],edge[200005],deep[200005];
struct edge
{
	int to,next,w;
}a[200005];
void addedge(int x,int y)//前向星建边时顺手将每条边的边权都赋为1 
{
	cnt++;
	a[cnt].to=y;
	a[cnt].next=h[x];
	a[cnt].w=1;
	h[x]=cnt;
}
void dfs(int x,int d/*d是目前层数（几层就有多远。。距离唯一），dfs1中相同*/)
{
	if(maxx<d)
	{
		maxx=d;
		bj=x;
	}
	vst[x]=1;
	for(int i=h[x];i;i=a[i].next)
	{
		int y=a[i].to;
		if(vst[y])
			continue;
		dfs(y,d+a[i].w);
	}
}
bool dfs1(int x,int d)
{
	if(d==maxx)
		return 1;
	vst[x]=1;
	for(int i=h[x];i;i=a[i].next)
	{
		int y=a[i].to;
		if(vst[y])
			continue;
		if(dfs1(y,d+1))
		{
			a[i].w=a[i^1].w=-a[i].w;//我们的cnt初始为一，为了这里,这样的话编号就是从2->2n-1了
            //没有了1这个特殊玩意就可以用异或来找两点间的另一条边，打个比方，2^1=3,3^1=2     ^-^其实就是自己那条边，我们建的是双边，
			return 1;
		}
	}
	return 0;
}
void dp(int x)//由于我们第二次只要求直径的长度，所以就不需要用dfs或bfs来找啦 
{
	vst[x]=1;
	for(int i=h[x];i;i=a[i].next)
	{
		int y=a[i].to;
		if(vst[y])
			continue;
		dp(y);
		maxxx=max(maxxx,dis[x]+dis[y]+a[i].w);
		dis[x]=max(dis[x],dis[y]+a[i].w);
	}
}
/*
多一句嘴，为什么要用dp，还有一点原因:
我们在之前就将边权取反了，边的长度变成了负数，那么就不能仅简单的用dfs或bfs来累加了
dfs或bfs的本质就是累加边权,而dp则是取的最大值，这样-1就不会影响到答案了 
*/
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		addedge(x,y);
		addedge(y,x);
	}
	dfs(1,0);
	S1=bj;
	memset(vst,0,sizeof(vst));
	dfs(bj,0);
	if(m==1)
	{
		printf("%d\n",2*n-maxx-1);
		return 0;
	}
	memset(vst,0,sizeof(vst));
	dfs1(S1,0);
	memset(vst,0,sizeof(vst));
	dp(1);
	printf("%d\n",2*n-maxx-maxxx);
	return 0;
}
/*
8 1
1 2
3 1
3 4
5 3
7 5
8 5
5 6
*/
/*
8 2
1 2
3 1
3 4
5 3
7 5
8 5
5 6
*/
/*
5 2
1 2
2 3
3 4
4 5
*/
```



---

## 作者：Tari (赞：1)

## 我要说：负权树千万别用dfs找直径。。。

### ~~本来看了看题解，后来觉得题解都太不友好（我太菜了），一气之下自己打。。。一打打到第二天QAQ、、、管理员大大求过啊。。。。~~
其实自己不明白的主要是树的直径的记录。。。所以就自己用递归打了一个函数 ~~，就是慢了30ms？~~

首先什么边也不加时，总路程就是
#### 2*(n-1)

考虑k=1的时候，答案显然是

#### 2*(n-1)-直径+1=2*n-直径-1，

如果能加一条边的话，因为希望减少的尽可能多，那么只需要把直径的首尾接起来，就不需要来回走，加一就是加了这一条新加入的边。

而k=2的时候，首先还是往最长链上面思考。然而做k=1的时候已经用掉了一段，我们需要k=2的和k=1的不重叠。

于是乎，我们跑完直径后之后把直径上的边权全部修改为-1，再跑一遍直径就可以了。那权值为-1的边又被选了就是考虑第一次算这条边的时候加了1，第二次的时候是-1，相当于是这条边没有产生任何贡献。所以最后答案是
#### 2*(n-1)-(直径1-1)-(直径2-1)=2*n-直径1-直径2


负权的树一定要用DP跑直径，不要像我一样傻乎乎的用dfs（妄想dfs一石二鸟，何不如直接全DP（但我不会用DP记路径））

哪位大佬能教教我DP记路径吗。。。。感激不尽( ⊙ o ⊙ )啊！
我的傻乎乎的代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define R register int
using namespace std;
const int N=100010,Inf=0x3f3f3f3f;
inline int g() {
	R ret=0,fix=1; register char ch; while(!isdigit(ch=getchar())) fix=ch=='-'?-1:fix;
	do ret=ret*10+(ch^48); while(isdigit(ch=getchar())); return ret*fix;
}
int n,k,mx,mx1,cnt,st,ed;
int pre[N],fir[N],cnte[N],d[N];
struct edge{
	int v,w,nxt;
	#define v(i) e[i].v
	#define w(i) e[i].w
	#define nxt(i) e[i].nxt
}e[N<<1];
inline void add(int u,int v,int w) {v(++cnt)=v,w(cnt)=w,nxt(cnt)=fir[u],fir[u]=cnt;}
namespace _dp {
	void dp(int u,int fa) {
		for(R i=fir[u];i;i=nxt(i)) {
			R v=v(i);
			if(v==fa) continue;
			dp(v,u);
			mx=max(mx,d[u]+d[v]+w(i));
			d[u]=max(d[u],d[v]+w(i));
		}
	}
	inline void solve() {
		memset(d,0,sizeof(d));
		dp(1,0);
	}
}
inline void dfs(int u,int fa) {
	for(R i=fir[u];i;i=nxt(i)) {
		R v=v(i);
		if(v==fa) continue;
		d[v]=d[u]+w(i);
		dfs(v,u);
	}
}
inline void solve() {
	memset(d,0x3f,sizeof(d));
	d[1]=0; dfs(1,0); mx=-Inf; st=0,ed=0;
	for(R i=1;i<=n;++i) if(d[i]>mx&&d[i]!=Inf&&i!=1)
		mx=d[i],st=i;
	memset(d,0x3f,sizeof(d));
	d[st]=0,dfs(st,0); mx=-Inf;
	for(R i=1;i<=n;++i) if(d[i]>mx&&d[i]!=Inf&&i!=st) 
		mx=d[i],ed=i;
}
inline void fd_p(int u,int fa) {
	for(R i=fir[u];i;i=nxt(i)) {
		R v=v(i);
		if(v==fa) continue;
		fd_p(v,u);
		pre[v]=u; 
		cnte[v]=i;
	}
}
signed main() {
	n=g(),k=g();
	for(R i=1,u,v;i<n;++i) u=g(),v=g(),add(u,v,1),add(v,u,1);
	solve();
	if(k==1) {printf("%d\n",2*n-mx-1); return 0;}
	fd_p(st,0); mx1=mx; pre[st]=0;
	for(R i=ed;i;i=pre[i]) if(cnte[i]&1) w(cnte[i])=-1,w(cnte[i]+1)=-1; else w(cnte[i])=-1,w(cnte[i]-1)=-1;
	mx=0;
	_dp::solve();
	printf("%d\n",2*n-mx1-mx);
}
```


---

## 作者：AubRain (赞：1)

[luogu3629](https://www.luogu.org/problemnew/show/P3629)

ans本来是2*(n-1)

先求一次树的直径 L1,ans变成ans-L1+1

如果k=1，就可以结束程序了

把该直径上的边权都变成-1(把环重叠的部分加回来)

再求一次树的直径 L2(不能用两次bfs了，要用树形dp)

输出2*n-L1-L2

注意：因为是双向边，N要设成2e5

```cpp
#include<bits/stdc++.h>
#define N 200005

using namespace std;

int n,k,ans,ma,po;
bool vis[N];
int head[N],cnt;
int dis[N],pre[N];
struct nd{int next,to,v;}e[N];
void add(int x,int y){e[++cnt]=(nd){head[x],y,1};head[x]=cnt;}
queue<int> q;

void dp(int x)
{
    vis[x]=1;
    for(int i=head[x];i;i=e[i].next)
    {
        int y=e[i].to;
        if(vis[y]) continue;
        dp(y);
        ma=max(ma,dis[x]+dis[y]+e[i].v);
        dis[x]=max(dis[x],dis[y]+e[i].v);
    }
}
void del(int now)
{
    while(pre[now])
    {
        int fa=pre[now];
        for(int i=head[fa];i;i=e[i].next)
            if(e[i].to==now){e[i].v=-1;break;}

        for(int i=head[now];i;i=e[i].next)
            if(e[i].to==fa){e[i].v=-1;break;}
        now=fa;
    }
}
void bfs(int f,int pd)
{
    q.push(f);
	while(q.size())
	{
		int d=q.front();q.pop();

		for(int i=head[d];i;i=e[i].next)
		{
			int t=e[i].to;
			if(t==f||dis[t]) continue;
			dis[t]=dis[d]+1;
            if(pd)pre[t]=d;
			q.push(t);
		}
	}
}
void clear()
{
    ma=0;
    memset(dis,0,sizeof dis);
}
void get()
{
    ma=0;
    for(int i=1;i<=n;i++)
		if(dis[i]>ma)
			ma=dis[i],po=i;
}
int main()
{
	cin>>n>>k;
	for(int x,y,i=1;i<n;i++){cin>>x>>y;add(x,y);add(y,x);}
	bfs(1,0);
    get();
    clear();
	bfs(po,1);
	get();
    ans=2*n-ma;
    if(k==1){cout<<ans-1;return 0;}
	del(po);
    clear();
    dp(1);
	cout<<ans-ma;
	return 0;
}

```

---

## 作者：fanfansann (赞：0)

首先看题，从1号结点开始，全部遍历并回到1号结点会恰好经过所有的边两次，这样总长度为 $2*(n-1)$。
那么如果建立一条路以后，由题意可知新道路必须经过恰好一次，也只能经过一次，所以新路从x到y形成一个环，这样就可以用新路的权值1来代替老路径中从x到y的路径1次，也就是说从x到y之间的路径在建立了新路以后只需要再经过一次就行了。所以我们要求最短，肯定要把整棵树上的最长链也就是树的直径省掉答案最优。所以当k = 1 时，我们找到最长链，在这两个端点之间加一条新路，设直径为L，则答案$ans = 2*(n-1) - L +1$（+1是因为要走一次新加的新路）。

当k = 2时，我们按照刚刚的理论，再求一次最长链。这样形成两个环，第一条肯定不能跟第二条一样，所以我们求完第一条以后要把第一条最长链给删去。这里找到第一次的最长链，遍历一遍，将值从1变成-1。
如果第二条与第一条链没有重叠，那么就跟第一条链一样，直接减去即可。
若第二条连与第一条链有重叠，那么由于本应只走一次的路径会走两次，多减去的值需要加回来，但是由于第一条链上的所有边已经取反为-1，这样减去负数又相当于加上这个数，所以两种答案是一样的。
最终的答案为$ans = 2*(n-1) - (L_1-1) - (L_2-1) = 2*n - L_1 - L_2$
总时间复杂度为$O(n)$

这里将第一条链的值全部赋值为-1的时候用到了一个位运算的小技巧  —— 成对变换。

> 当n为偶数的时候，n XOR 1 = n + 1 当n为奇数的时候，n XOR 1 = n - 1
> 
> 利用这个小技巧，我们在使用链式前向星的时候初始化tot等于1，这样每天无向边看成的两条有向边会成对存储在ver和edge数组的下标为2和3，4和5...的位置上，通过对下标进行XOR1运算，就可以直接定位到当前边的反向的边。换句话说，如果ver[i]是第i条边的终点，那么ver[i xor1]就是第i条边的起点。
> ——《算法竞赛进阶指南》

放到代码里就是这样：
```cpp
 while(fa[q]){//成对变换
            edge[fa[q]] = edge[fa[q]^1] = -1;
            q = ver[fa[q]^1];
        }
```
具体的看下面的代码就好
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<cstring>
#include<bitset>
#include<vector>
#include<queue>
#define ls (p<<1)
#define rs (p<<1|1)
#define over(i,s,t) for(register int i = s;i <= t;++i)
#define lver(i,t,s) for(register int i = t;i >= s;--i)
//#define int __int128
#define lowbit(p) p&(-p)
using namespace std;

typedef long long ll;
typedef pair<int,int> PII;
const int INF = 0x3f3f3f3f;
const int N = 1e5+7;
const int M = 2007;
int n,k;
int ver[N << 1],edge[N << 1],nex[N << 1],head[N],tot = 1;
int fa[N];
bool vis[N];
int dis[N];

void add(int u,int v,int val){
    ver[++tot] = v;
    edge[tot] = val;
    nex[tot] = head[u];
    head[u] = tot;
}

void dfs(int x,int &t){//不能处理负值
    vis[x] = 1;
    for(int i = head[x];i;i = nex[i]){
        int y = ver[i],z = edge[i];
        if(vis[y])continue;
        dis[y] = dis[x] + z;
        if(dis[y] >= dis[t])t = y;
        fa[y] = i;//存路径,用于成对变换，存的是前向星的指针
        dfs(y,t);
    }
    vis[x] = 0;//回溯
}

void DP(int x,int &t){//可以处理负值
    vis[x] = 1;
    for(int i= head[x];i;i = nex[i]){
        int y = ver[i],z = edge[i];
        if(vis[y])continue;
        DP(y,t);
        t = max(t,dis[x] + dis[y] + z);
        dis[x] = max(dis[x],dis[y] + z);
    }
}

int main()
{
    scanf("%d%d",&n,&k);
    over(i,1,n-1){
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y,1);
        add(y,x,1);
    }
    int p = 1;//两次dfs找最远的p和q
    dfs(1,p);
    dis[p] = fa[p] = 0;//找到之后把它当成根节点
    int q = p;
    dfs(p,q);
    int ans = ((n - 1) * 2) - dis[q] + 1;// + 1是因为新增了一条必须走一次的边
    if(k == 2){
        while(fa[q]){//成对变换
            edge[fa[q]] = edge[fa[q]^1] = -1;
            q = ver[fa[q]^1];
        }
        q = 0;
        memset(dis,0,sizeof dis);
        DP(p,q);
        ans -= q - 1;
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Object_ (赞：0)

**易错点：**

- l2必须要设置全局变量而不能设置局部变量，这是由于设置局部变量无法兼顾所有情况造成的.
- bfs并设置直径上边权为-1后，如果k=2则不能继续直接使用bfs获得答案，这是bfs的拓展加点性造成的（类比dijkstra）.
- 如果两个变量可以用一个变量导出就用一个变量. 

**BFS方法正确性的证明：**
- 如果源点在直径上：显然正确.
- 如果源点不在直径上：既然源点不在直径上那么直径一定在源点的某棵子树内。由树和直径的性质可知此时直接取最远点然后再进行一次bfs即可求得直径.

------------
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int MAXN=2e5,INF=0x3f3f3f3f;
struct Edge{
	int from,to,w,nxt;
}e[MAXN*2];
int head[MAXN],edgeCnt=1;
void addEdge(int u,int v,int w){
	e[++edgeCnt].from=u;
	e[edgeCnt].to=v;
	e[edgeCnt].w=w;
	e[edgeCnt].nxt=head[u];
	head[u]=edgeCnt;
}
int n;
int d[MAXN],pre[MAXN];
int bfs(int p){
	memset(d,0x3f,sizeof(d));
	queue<int> q;
	q.push(p);
	d[p]=pre[p]=0;
	while(!q.empty()){
		int nowNode=q.front();q.pop();
		for(int i=head[nowNode];i;i=e[i].nxt){
			int nowV=e[i].to;
			if(d[nowV]==INF){
				d[nowV]=d[nowNode]+e[i].w;
				pre[nowV]=i;
				q.push(nowV);
			}
		}
	}
	int ans=1;
	for(int i=1;i<=n;i++){
		if(d[i]>d[ans])ans=i;//如果两个变量可以用一个变量导出就用一个变量. 
	}
	return ans;
}
int p;
int get(){
	p=bfs(1);
	p=bfs(p);
	return d[p];
}
void change(){
	for(;pre[p];p=e[pre[p]].from){
		e[pre[p]].w=e[pre[p]^1].w=-1;
	}
}
bool vis[MAXN];
int f[MAXN],l2;
void dfs(int p){
	vis[p]=1;
	for(int i=head[p];i;i=e[i].nxt){
		int nowV=e[i].to;
		if(!vis[nowV]){
			dfs(nowV);
			l2=max(l2,f[p]+f[nowV]+e[i].w);
			f[p]=max(f[p],f[nowV]+e[i].w);
		}
	}
}
int main(){
	int k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n-1;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		addEdge(a,b,1);
		addEdge(b,a,1);
	}
	int l1=get();
	if(k==1){
		printf("%d\n",2*(n-1)-l1+1);
		return 0;
	}else{
		change();
		dfs(1);
		printf("%d\n",2*n-l1-l2);
		return 0;
	}
}
```


---

## 作者：fangxk2003 (赞：0)

[欢迎](https://blog.csdn.net/jokingcoder/article/details/88077214)[来](https://blog.csdn.net/jokingcoder/article/details/88077214)[CSDN](https://blog.csdn.net/jokingcoder/article/details/88077214)[蹭](https://blog.csdn.net/jokingcoder/article/details/88077214)[访问](https://blog.csdn.net/jokingcoder/article/details/88077214)[量](https://blog.csdn.net/jokingcoder/article/details/88077214)

题目的意思是让你在一棵树上加K条边，再从1出发经过所有节点和所有边（点和边均可重复）回到1的最短路径

鉴于`K == 1 || K == 2`，分类讨论就好了

### K = 1

不加边的时候`ans = edges_sum * 2`

加一条边能将ans减少这条边两点之间原来的距离-1

显然找直径是最合适的。。

所以`ans = edges_sum * 2 - diameter + 1`

### K = 2

在`K == 1`的时候形成的基环树在加一条边，则红色部分要走两遍，所以ans又减少了绿色部分的长度-红色部分的长度-1

![](https://img-blog.csdnimg.cn/20190302160221268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pva2luZ2NvZGVy,size_16,color_FFFFFF,t_70)

求[绿](https://blog.csdn.net/jokingcoder/article/details/88077214)色部分的长度-[红](https://blog.csdn.net/jokingcoder/article/details/88077214)色部分的长度的最大值有一种很好的方法

——把红色部分（其实是环上的部分）的边权全都变成-1（撒花花

再次跑直径

------

~~如果你现在跑去写代码，那么恭喜你有50%的几率像我一样DeBuG好久~~

**因为含有负权边的直径不能用两个dfs/bfs求(第二个样例就是这样)，所以得写树形dp求直径**



[贴上代码](https://blog.csdn.net/jokingcoder/article/details/88077214)；

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 100010
#define INF 0x3f3f3f3f

using namespace std;

struct Node{
	int to, nxt, len;
}e[N << 1];

int dep, lst[N], cnt, d[N], v[N], x[N], y[N], n, K, tot, dx[N];

inline void add(int u, int v) {
	e[++cnt].to = v;
	e[cnt].nxt = lst[u];
	lst[u] = cnt;
	e[cnt].len = 1;
}

inline void dfs(int x, int fa, int dep) {
	d[x] = dep;
	for (int i = lst[x]; i; i = e[i].nxt) {
		int son = e[i].to;
		if (son == fa) continue;
		dfs(son, x, dep + e[i].len);
	}
}

inline int dfs1(int x, int fa, int goal) {
	if (x == goal) return 1;
	for (int i = lst[x]; i; i = e[i].nxt) {
		int son = e[i].to;
		if (son == fa) continue;
		if (dfs1(son, x, goal)) {
			e[i].len = -1;
			return 1;
		}
	}
	return 0;
}

inline void make(int x, int fa) {
	for (int i = lst[x]; i; i = e[i].nxt) {
		int son = e[i].to;
		if (son == fa) continue;
		make(son, x);
		tot = max(tot, dx[x] + dx[son] + e[i].len);
		dx[x] = max(dx[x], dx[son] + e[i].len);
	}
}

int main() {
	scanf("%d%d", &n, &K);
	for (int i = 1; i < n; ++i) {
		scanf("%d%d", &x[i], &y[i]);
		add(x[i], y[i]);
		add(y[i], x[i]);
	}
	int ans = n - 1 << 1;
	int dmax = 0, imax = 0;
	dfs(1, 1, 0);
	for (int i = 1; i <= n; ++i) {
		if (d[i] > dmax) {
			dmax = d[i];
			imax = i;
		}
	}
	memset(d, 0, sizeof d);
	dfs(imax, imax, 0);
	dmax = 0;
	int iimax = 0;
	for (int i = 1; i <= n; ++i) {
		if (d[i] > dmax) {
			dmax = d[i];
			iimax = i;
		}
	}
	ans -= dmax - 1;
	if (K == 1) {
		printf("%d\n", ans);
		return 0;
	}
	dfs1(imax, imax, iimax);
	dfs1(iimax, iimax, imax);//正反两次把环上的所有边搞成-1
	make(1, 1);
	ans -= tot - 1;
	printf("%d\n", ans);
	return 0;
}
```

---


# [APIO2010] 信号覆盖

## 题目描述

一家电信公司正在北京城搭建一个 GSM 网络。城市里共有 n 个房子需要被 信号覆盖。由于经费的限制，电信公司只能安装一个天线。 这里将每个房子用一个点坐标来表示。为了简化天线的放置，电信公司将会 选择其中的 3 个房子作一个外接圆，然后将天线放在圆的中心，所有位于这个圆 内或者圆的边界上的房子都将被天线的信号所覆盖。 电信公司将会随机选择城市中的 3 个房子来搭建天线，他们想知道在所有可 能放置天线的方案中平均会有多少个房子被信号覆盖。 例如，假设共有 4 个房子 A, B, C, D，它们的位置如下图：

  ![](https://cdn.luogu.com.cn/upload/pic/4405.png) 

如果我们选择ABC或者BCD三个点搭建的外接圆，所有的房子都会被覆盖。 如果我们选择 ACD 或者 ABD，剩下的房子将不会在天线的信号覆盖范围内。因 此平均有(4 + 4 + 3 + 3) / 4 = 3.50 个房子被信号覆盖。 给定所有房子的位置，你的任务是计算平均有多少个房子被信号覆盖。假定 每一个房子都有一个二维的整数坐标，并且保证任何三个房子都不在同一条直线 上，任何四个房子都不在同一个圆上。


## 说明/提示

【样例说明】

3.5, 3.50, 3.500, … 中的任何一个输出均为正确。此外，3.49, 3.51, 3.499999，…等也都是可被接受的输出。

【数据范围】

100%的数据保证，对于 i = 1, 2, .., n, 第 i 个房子的坐标(xi, yi)为整数且 –1,000,000 ≤ xi, yi ≤ 1,000,000. 任何三个房子不在同一条直线上，任何四个房子不 在同一个圆上；

40%的数据，n ≤ 100；

70%的数据，n ≤ 500；

100%的数据，3 ≤ n ≤ 1,500。


## 样例 #1

### 输入

```
4
0 2 
4 4 
0 0 
2 0```

### 输出

```
3.500 ```

# 题解

## 作者：Hammer_cwz_77 (赞：17)

N^4的算法很好想，枚举三个点组成一个圆，再枚举一个点判断点是否在圆内，统计输出就可以了，但这样显然只能拿到40分。

对于任意4个点，组成的图形只有两种，一种是凸四边形，一种是凹四边形，即一个点在另外三个点组成的三角形内。

对于凸四边形，必有一组对角大于180°，此时这组对角所对应的顶点必然在另外三个点组成的圆中，所以每个凸四边形对于总的答案贡献两个点。

对于凹四边形，设D在三角形ABC内，那么只有D在三角形ABC组成的圆中，A，B和C都不在另外三个点的圆中，所以凹四边形对总的答案贡献一个点。

由于总的四边形个数一定，我们只需要求出凹四边形的个数。

首先枚举凹点D，以D作为极点，x轴正半轴为极轴进行极角排序，对于一个合法的三角形ABC，过D的任意一条直线都不能使三个点在D的同一侧，这样我们就用总的三角形个数C（n-1，3）来减去同一侧的三角形个数。这样枚举一个点A，找到A到C的角小于180°的最远点C，设A的编号为i，C的编号为j，那么此时在一侧的三角形个数为C（j-i，2），由于C对于每一个A是单调的，所以每一次的复杂度均为n，总的复杂度就是n^2，加上排序的复杂度，总复杂度为n^2logn。

Code
```cpp
program test3;
uses math;
var x,y:array[0..1500]of extended;
    p,q:array[0..3000]of extended;
    i,j,m,k:longint;
    tot,sum1,sum2,sum,now,n:int64;
    ans:extended;
procedure kp(l,r:longint);
var i,j:longint;
    x,y:extended;
begin
    i:=l;j:=r;
    x:=p[(l+r)shr 1];
    repeat
        while p[i]<x do inc(i);
        while p[j]>x do dec(j);
        if i<=j then
        begin
            y:=p[i];
            p[i]:=p[j];
            p[j]:=y;
            inc(i);
            dec(j);
        end;
    until i>j;
    if l<j then kp(l,j);
    if i<r then kp(i,r);
end;
begin
    readln(n);
    for i:=1 to n do readln(x[i],y[i]);
    tot:=n*(n-1)*(n-2)div 6;
    for k:=1 to n do
    begin
        p[k]:=0;
        for i:=1 to n do
        begin
            if i=k then continue;
            q[i]:=(x[i]-x[k])/sqrt(sqr(x[i]-x[k])+sqr(y[i]-y[k]));
            p[i]:=arccos(q[i]);
            if y[i]<y[k] then p[i]:=2*pi-p[i];
        end;
        kp(1,n);
        for i:=2 to n do p[i+n-1]:=p[i];
        j:=2;
        now:=0;
        for i:=2 to n do
        begin
            while (((p[j+1]-p[i]<=pi)and(p[j+1]>=p[i]))or(p[j+1]-p[i]<-pi))and(j<i+n-2) do inc(j);
            now:=now+(j-i)*(j-i-1)div 2;
        end;
        sum:=sum+(n-1)*(n-2)*(n-3)div 6-now;
    end;
    sum1:=sum;
    sum2:=n*(n-1)*(n-2)*(n-3)div 24-sum1;
    sum:=sum1+sum2*2+tot*3;
    ans:=sum/tot;
    writeln(ans:0:6);
end.
```

---

## 作者：huayucaiji (赞：12)

## 前言

[博客食用链接](https://www.cnblogs.com/huayucaiji/p/LG3630.html)

~~南海都有网络了，怎么北京还要覆盖信号啊~~

好久以前做的计算几何题了，回来复盘一下。

## 解法

首先，题目中各有一个条件很重要：

> 保证任何三个房子都不在同一条直线 上，任何四个房子都不在同一个圆上。

翻译一下，没有四点共圆，没有三点共线。

我们做这道题依赖于这个条件。

首先对于 $A,B,C$ 三个点作的外接圆，一定覆盖这三个点，对于任何一个圆都是如此。那我们的答案可以表示为：

$$ans=\frac{sum}{C_n^3}+3$$

其中，$C^3_n$ 是圆的总数，而 $sum$ 是所有圆**圆内的点**的数的总和。

问题就转化为，如何求 $sum$ 呢？

**正难则反。**

我们可以算每个点在多少个圆**内部**，对于第 $i$ 个点，这个值我们记为 $f_i$。那么 $sum=\sum\limits_{i=1}^n f_i$。这样，我们就要考虑确定圆的三个点和点 $i$，也就是四个点。因此我们考虑这四个点组成的四边形。

**如果组成凸四边形。** 则如下图：

![1](https://cdn.luogu.com.cn/upload/image_hosting/bmd5m9xd.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

由于没有四点共圆的情况，一定没有对角和为 $180$ 的可能。那么以 $A,D,C$ 作圆，一定能覆盖 $C$，以 $D,C,B$ 作圆，一定覆盖 $A$。所以一个凸四边形对 $sum$ 做 $2$ 的贡献。

**如果组成凹四边形。** 则如下图：

![2](https://cdn.luogu.com.cn/upload/image_hosting/kpd36r1a.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

显然，只有以 $C,B,D$ 作圆才能覆盖 另一个点 $A$，因此一个凹四边形对 $sum$ 的贡献是 $1$。

问题再次被我们转化，变为有多少个凸四边形，多少凹四边形。设他们的数量分别为 $x,y$。我们有：

$$x+y=C_n^4$$

我们到底是求 $x$，还是求 $y$ 呢？

由于

$$sum=2x+y=C_n^4+x$$

我们只需要求出凸多边形数量 $x$ 即可。

但是，真的是这样做吗？我们发现这样做其实很难。

凹四边形的数量会比凸四边形数量好求得多。~~呵呵~~

如果你仔细想想，就会发现，每个凹四边形都有一个凹角，所以我们要求出凹角数量。我们令凸角数量为 $a$，凹角数量为 $b$，由于每个四边形有四个角，我们有：

$$a+b=4\cdot C_n^4$$

又到了熟悉的岔路口，但这一次，我们选择计算凸角数量 $a$。

这个求法非常简单，直接枚举每个点作为原点，其他的点做极角排序。

![3](https://cdn.luogu.com.cn/upload/image_hosting/8pukqn7b.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

用双指针扫一下，得到以某一条边为定边的小于 $180$ 度的角的个数。即 $i$ 为定边，到 $j$ 为止的角小于 $180$ 度，$j+1$ 与 $i$ 所夹的角大于 $180$ 度。那么这个区间里面的凸角所属四边形有 $C_{j-i+1}^2$ 个。

**注意要破环为链。**

这样我们就求得了 $a$，我们就可以依次求出 $b,y,x,sum,ans$。

最后输出 $ans$ 即可。

最后时间复杂度为 $O(n^2\log n)$。

---

## 作者：mRXxy0o0 (赞：3)

upd：早年写的太简略了，补一补细节。

# 分析

求平均转化为求被圆覆盖点数总和。经观察，一个凸四边形的四个圆盖住的点数和（对答案的贡献）为 $2$，凹四边形为 $1$。设凸四边形有 $a$ 个，凹四边形有 $b$ 个。

考虑一种直观的计数，枚举对角线，计算包含此对角线的所有四边形，设有 $s1$ 个，则 $s1=4a+6b$。这里可以固定一个点，旋转扫描线计算。

注：这里“对角线”的定义是四边形中**任意**两点连线使得另外两点在所连直线的两侧。

注意到，$a+b=(^n_4)$，直接算出 $a,b$ 的值。总和即为 $2a+b$。

---

## 作者：xkai (赞：3)

## 前言
一道有意思的题目，做了一个晚上和一个上午，终于搞定了。

思路跟其他题解不一样。

## 理论分析

我们对三点构成的圆进行如下图的拆分：


![拆分答案](https://cdn.luogu.com.cn/upload/image_hosting/ivo36p8l.png)

（解释：一个圆覆盖的点数 $\times 2$ $=$ 边 $AB$ 截下的图形覆盖的点数 $+$ 边 $AC$ 截下的图形覆盖的点数 $+$ 边 $BC$ 截下的图形覆盖的点数 $-$ 三角形 $ABC$ 覆盖的点数。）

接下来分成两部分：圆弧状的图形 和 三角形。

对于第二部分，我们计算每个点被多少个三角形覆盖。枚举每个点，将其作为原点，统计有多少个三角形包含原点。这部分不着重讲解，可以发现这一部分恰好是[这道题](https://www.luogu.com.cn/problem/P2992)。（还是说一下，这部分用容斥，先计算出所有三角形数量，再减去不合法的。从原点向每个点连接一条边，如果一个三角形不合法，那必然有两个点与原点的连线之间的角大于 $180$ 度。）

重点看第一部分。如果我们已经确定了两个点（即确定了一条边），加入第三个点后所形成的圆覆盖的点数其实是一段从 $3$ 开始的连续自然数，见下图：

![看图](https://cdn.luogu.com.cn/upload/image_hosting/gypyqegl.png)

如上图，我们确定了边 $AB$ ，如果只统计边 $AB$ 的一侧的话，我们按 $C,J,G,I,L,K$ 的顺序统计答案，发现在这一侧，每一个圆都完全覆盖上一个圆，覆盖的点数恰好是 $3,4,5,6,7,8$ 一段以 $3$ 开始的连续自然数。所以我们只需要统计出边 $AB$ 一侧的点数，就可以用等差数列公式求出这部分对答案的贡献。

对于每条边的两侧分别进行这样的统计，这时候发现对于一个圆，它的中间三角形部分的面积被统计了 $3$ 次，其余部分面积被统计了 $2$ 次，所以按照最初我们对图形的拆分进行计算，那么恰好不重不漏地统计了所有的答案。（补充一下：注意到代码实现时每条边被从两个端点各遍历了一次，所以实际上三角形部分被统计了 $6$ 次，其余部分被统计了 $4$ 次。）

至此，此题理论分析完毕。

## 代码实现

第一部分我们需要知道每条直线的左边和右边的点数，第二部分我们需要固定一个点，并要知道每条以该点为一端点的边逆时针（也可以顺时针，取决于排序方式）相距大于 $180$ 度的边的数量。再一想，第一部分求直线两侧的点数也需要转 $180$ 度进行统计，所以最终我们固定一个点，将其余点对于该点进行极角排序后，然后进行 $O(n)$ 统计。

最终复杂度 $O(n^2\log n)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1510;
typedef long long ll;
ll ans,ans1;
int n;
struct Point{
	int x,y;
	double angle;
	Point(int x=0,int y=0):x(x),y(y){}
	Point operator-(Point A){
		return Point(x-A.x,y-A.y);
	}
}a[N],tmp[N<<1];
bool cmp(const Point&x,const Point&y){
	return x.angle<y.angle;
}
ll crs(const Point&x,const Point&y){
	return (ll)x.x*y.y-(ll)x.y*y.x;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	for(int i=1;i<=n;i++){
		swap(a[1],a[i]);
		for(int j=1;j<n;j++)tmp[j]=a[j+1]-a[1],tmp[j].angle=atan2(tmp[j].y,tmp[j].x);
		sort(tmp+1,tmp+n,cmp);
		for(int j=1;j<n;j++)tmp[j+n-1]=tmp[j];
		ans1+=(ll)(n-1)*(n-2)*(n-3)/6+(ll)(n-1)*(n-2)/2;
		for(int j=1,k=1;j<n;j++){
			while(k<j+n-1&&crs(tmp[j],tmp[k])>=0)k++;
			ll cnt1=k-j-1,cnt2=n-2-cnt1;
			ans+=(3+cnt1+2)*cnt1/2+(3+cnt2+2)*cnt2/2;
			ans1-=cnt2*(cnt2-1)/2;
		}
	}
	ans=(ans/2-ans1)/2;
	cout<<(double)ans/((double)n*(n-1)*(n-2)/6);
}
```


---

## 作者：huangxianghui (赞：1)

~~说起来为什么这题没有一个c++题解呢~~

### solution

这道题$n^4$的算法不难想，枚举任意四个点，一个一个算过去，然而$n\leq1500$想妄图不炸几乎不可能 ~~除非你能创造某些登峰造极的优化~~，保底40分

换一种思路，每四个点构成一个四边形，四边形分为凸四边形和凹四边形，分类讨论一下。

凸四边形如下图，从图中可以看出，有一对对角和小于等于180°的对角时，以该对顶点所构成的圆必然包含剩下的两个点，所以对于题目的总贡献为2

![凸四边形](https://cdn.luogu.com.cn/upload/image_hosting/sh9v9ckv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

凹四边形如下图，从图中可以看出，无论怎么样，只有作为三个锐角的顶点的点，所构成的圆才能包含所有顶点，所以对于题目的总贡献为1

![凹四边形](https://cdn.luogu.com.cn/upload/image_hosting/sbcoiykg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可以知道，题目中的总四边形个数为$C_{n}^{4}$，所以我们只需要求出凸四边形的个数。

首先暴力枚举每个点作为凹四边形的凹点，然后以该点建立极坐标系，将每个点的极角按大小排序。其次，从$x$轴正半轴开始，逆时针寻找离该点最远且两角差小于180°的，由于我们设定的凹点所在的角小于180°，所以该四边形自然为凸四边形（这里的判定实际上会有点问题，因为除凹点外的剩下三个点可能组成一个大于180°的角，但这个问题在所有的统计中会被略去~~因为这里多了后面就会少了~~）。设该点编号为$i$，最远的点编号为$j$，所得到的凸四边形的个数为$C_{j-i}^{2}$，最后再按照前面的推断进行统计。

```c++
#include<bits/stdc++.h>
#define ll long long
#define f(i,a,b) for (ll i=a;i<=b;i++)
#define fx(i,a,b) for (ll i=a;i>=b;i--)
using namespace std;
const int maxn=1510;
const double pi=3.1415927;//弧度制都懂
int n;
int a[maxn][2];
ll sum,ao;
double ans;
priority_queue<double,vector<double>,greater<double> >q;//代替sort，但是这样会慢很多
double ta[maxn<<2];//角度
inline ll read()
{
	ll l=0,f=1;
	char c;
	while (!isdigit(c=getchar())) if (c=='-') f=-1;
	while (isdigit(c)) l=(l<<3)+(l<<1)+(c^48),c=getchar();
	return l*f;
}
ll C(int x,int y)//求组合数
{
	ll c=1;
	f(i,x-y+1,x) c*=i;
	f(i,1,y) c/=i;
	return c;
}
signed main()
{
	n=read(),ao=n*C(n-1,3);
	if (n==3)
	{
		printf("3.00");
		return 0;
	}
	else sum=C(n,4);//总四边形个数
	f(i,1,n) a[i][0]=read(),a[i][1]=read();
	f(i,1,n)
	{
		f(j,1,n)
		{
			if (i!=j)
			{
				double jiao=atan2(a[j][1]-a[i][1],a[j][0]-a[i][0]);//使用atan2函数反求角度
				if (jiao<0) jiao+=2*pi;
				q.push(jiao); 
			}
		}
		f(j,1,n-1) ta[j]=q.top(),ta[j+n-1]=q.top()+2*pi,q.pop();//因为是逆时针数点，需要再复制一遍接在序列后面，记得加上360°
		for (int head=1,j=1;j<n;j++)
		{
			if (head<j) head=j;
			while (ta[head+1]-ta[j]<pi && head<2*n-1) head++;//数点
			ao-=C(head-j,2);//减去凸四边形个数
		}
	}
	printf("%.3f",((sum*2-ao)/1.0/C(n,3))+3);//计算
	return 0;
}
```



---

## 作者：0x3F (赞：1)

简要题意：

平面上有 $n$ 个点 $P_i=(x_i,y_i)$，保证任意三点不共线，任意四点不共圆。

求任意三个点组成的所有外接圆所包含的点的数量的平均值。

数据范围是 $3 \leq n \leq 1500, \lvert x_i\rvert, \lvert y_i\rvert \leq 10^6$，输入数据都是整数。

很有意思的计算几何题。需要求的就是满足点 $D$ 包含在 $A, B, C$ 构成的外接圆内的四元组 $(A, B, C, D)$ 的数量，其中 $A, B, C$ 没有顺序。

考虑 $D$ 与 $A, B, C$ 中的一个相同的情况。由 $A, B, C$ 构成的外接圆一定包含 $A, B, C$ 三个点，而这样的外接圆有 $\binom{n}{3}$ 个，故对答案有 $3\times\binom{n}{3}$ 的贡献。

考虑 $D$ 与 $A, B, C$ 都不相同的情况。此时 $A, B, C, D$ 可以看作四边形，可以分类讨论其形状。

![](https://s3.bmp.ovh/imgs/2022/07/09/6c45f01e19edcd3b.png)

当 $A, B, C, D$ 构成凸四边形时，由于任意四点不共圆，有 $\angle A+\angle C \neq 180^{\circ}$。如图，有两个点符合条件，两个点不符合条件。故一个凸四边形对答案的贡献是 $2$。

![](https://s3.bmp.ovh/imgs/2022/07/09/d02ec55337ce917d.png)

当 $A, B, C, D$ 构成凹四边形时，如图，有一个点符合条件，三个点不符合条件。故一个凹四边形对答案的贡献是 $1$。

（注：这里 $A, B, C, D$ 可以构成三个凹四边形，这里只算一个）

而四边形的总数是 $\binom{n}{4}$，故只需要求出凸四边形或者凹四边形的数量就可以知道答案。

这里我们选择计算凹四边形，因为凹四边形中有一个与众不同的凹点，可以作为枚举的依据。

将凹四边形的数量记作 $S$。于是答案就是：

$$3 \times \binom{n}{3} + 2 \times \binom{n}{4} - R$$

于是只需要求出 $R$ 即可。

枚举凹点 $D$，以它作为极点进行极角排序，则 $D$ 在三角形 $ABC$ 内部，即对于任意一条过 $D$ 的直线 $l$，$A, B, C$ 都不在 $l$ 的同一侧。也就可以转化成三角形总数件减去在同一侧的三角形数量，将后者记作 $S_D$。

![](https://s3.bmp.ovh/imgs/2022/07/09/ed1d1cd2e4aaedb0.png)

存在一条过 $D$ 的直线 $l$ 使得 $A, B, C$ 在 $l$ 的同一侧，也就说明 $\overrightarrow{DA}, \overrightarrow{DB}, \overrightarrow{DC}$ 的角度跨度不超过 $180^{\circ}$。

![](https://s3.bmp.ovh/imgs/2022/07/09/b3068f014a0eed8d.png)

假设三个点按照逆时针方向排依次是 $A, B, C$，枚举 $A$, 则 $B, C$ 都在 $\overrightarrow{DA}$ 的左侧。所以只需要知道在 $\overrightarrow{DA}$ 左侧的点的数量即可。将它记作 $c_{D, A}$，当 $A$ 逆时针转动时，用双指针维护第一个在 $\overrightarrow{DA}$ 右侧的点，它们之间点的数量就是 $T_{D, A}$。故

$$S_D=\sum_{A \neq D} \binom{T_{D, A}}{2}$$

$$R=\sum_{D \in P} \binom{n-1}{3} - S_D = 4 \times \binom{n}{4} - \sum_{D \in P} \sum_{A \neq D} \binom{T_{D, A}}{2}$$

于是答案就是

$$3 \times \binom{n}{3} - 2 \times \binom{n}{4} + \sum_{D \in P} \sum_{A \neq D} \binom{T_{D, A}}{2}$$

最后要除以 $\binom{n}{3}$。

$$\color{white}\tiny\texttt{我是唯一一个不用 double 的}$$

```cpp
#include <algorithm>
#include <cstdio>
#define _ 1510
#define __ 3010
long long n, ans, cnt;
struct vec {long long x; long long y;} arr[_], tmp[__];
inline vec sub(const vec& a, const vec& b) {return (vec){a.x - b.x, a.y - b.y};}
inline long long quad(const vec& a) {return ((a.x < 0) ^ (3 * (a.y < 0)));}
inline long long cross(const vec& a, const vec& b) {return a.x * b.y - a.y * b.x;}
inline bool cmp(const vec& a, const vec& b) {return ((quad(a) == quad(b)) ? (cross(a, b) > 0) : (quad(a) < quad(b)));}
int main() 
{
    scanf("%lld", &n);
    for (register long long i = 1; i <= n; i++) scanf("%lld%lld", &((arr+i)->x), &((arr+i)->y));
    ans = (long long) n * (n-1) * (n-2) / 2 - (long long) n * (n-1) * (n-2) * (n-3) / 12;
    cnt = (long long) n * (n-1) * (n-2) / 6;
    for (register long long i = 1; i <= n; i++) {
        register long long N = 0;
        for (register long long j = 1; j <= n; j++) if (i != j) tmp[++N] = sub(arr[j], arr[i]);
        std::sort(tmp+1, tmp+N+1, cmp);
        for (register long long j = 1; j <= N; j++) tmp[j+N] = tmp[j];
        for (register long long j = 1, k = 1; j <= N; j++) {
            if (k == j) k++;
            while (cross(tmp[j], tmp[k]) > 0) k++;
            ans += (k-j-1) * (k-j-2) / 2;
        }
    }
    printf("%lld.%lld%lld", ans / cnt, ((ans * 10ll) / cnt) % 10ll, ((ans * 100ll) / cnt) %10ll);
    return 0;
}
```

---


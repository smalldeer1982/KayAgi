# [APIO2011] 方格染色

## 题目描述

Sam 和他的妹妹 Sara 有一个包含 $n \times m$ 个方格的表格。他们想要将其中的每个方格都染成红色或蓝色。出于个人喜好，他们想要表格中每个 $2 \times 2$ 的方形区域都包含奇数个（ $1$ 个或 $3$ 个）红色方格。例如，下面是一个合法的表格染色方案（`R` 代表红色，`B` 代表蓝色）：
```
B B R B R
R B B B B
R R B R B
```
可是昨天晚上，有人已经给表格中的一些方格染上了颜色！现在 Sam 和 Sara 非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格依然满足他们的要求。如果可能的话，满足他们要求的染色方案数有多少呢？

## 说明/提示

对于 $20\%$ 的测试数据，$n,m,k \leqslant 5$。

对于 $50\%$ 的测试数据，$n,m \leqslant 5000$，$k \leqslant 25$。

对于 $100\%$ 的测试数据，$2 \leqslant n,m \leqslant 10^5$，$0 \leqslant k \leqslant 10^5$，$1 \leqslant x_i \leqslant n$，$1 \leqslant y_i \leqslant m$，$\forall c_i \in \{0,1\}$。

## 样例 #1

### 输入

```
3 4 3
2 2 1
1 2 0
2 3 1```

### 输出

```
8```

# 题解

## 作者：xiaolilsq (赞：44)

[题目链接](https://www.luogu.com.cn/problem/P3631)

刚刚做了这道题，感觉这题有诸多细节（~~调了我几个小时~~），后来发现大家的代码太麻烦了，于是过来写（shui）篇题解。

这道题思路大致是这样的（记$(x,y)$表示格子$(x,y)$的颜色）：

$$(x,y)\oplus(x-1,y)\oplus(x,y-1)\oplus(x-1,y-1)=1$$

令$x=x-1$，有：

$$(x-1,y)\oplus(x-2,y)\oplus(x-1,y-1)\oplus(x-2,y-1)=1$$

两式异或起来得到：

$$(x,y)\oplus(x,y-1)\oplus(x-2,y)\oplus(x-2,y-1)=0$$

于是便有：

$$(x,y)\oplus(x,y-1)\oplus(x-2k,y)\oplus(x-2k,y-1)=0$$

令$y=y-1$，得到：

$$(x,y-1)\oplus(x,y-2)\oplus(x-2k,y-1)\oplus(x-2k,y-2)=0$$

两式异或起来得到：

$$(x,y)\oplus(x,y-2)\oplus(x-2k,y)\oplus(x-2k,y-2)=0$$

同理：

$$(x,y)\oplus(x,y-t)\oplus(x-2k,y)\oplus(x-2k,y-t)=0$$

同理亦有：

$$(x,y)\oplus(x,y-2k)\oplus(x-t,y)\oplus(x-t,y-2k)=0$$

于是我们便得到若$x,y$中至少有一个是奇数时:

$$(x,y)\oplus(x,1)\oplus(1,y)\oplus(1,1)=0$$

当$x,y$都是偶数时，自己推一下不难得到:

$$(x,y)\oplus(x,1)\oplus(1,y)\oplus(1,1)=1$$

这时有些题解的做法是枚举$(1,1)$的所有可能（即$0$或$1$），其实这样做麻烦了，我们可以多开一行一列（即$(0,y)$和$(x,0)$），然后默认$(0,0)=0,(1,0)=0$，这样整个图就是新开的这一行这一列决定的了，然后就不必考虑那么多了

对于一个新添加的颜色$(x,y)=t$，若$x,y$中至少有一个是偶数时，令：

$$(x,0)\oplus(0,y)=(x,y)\oplus(0,0)\oplus1=t\oplus1$$

否则令：

$$(x,0)\oplus(0,y)=(x,y)\oplus(0,0)=t$$

用种类并查集维护一下$(x,0)$和$(0,y)$之间的关系，最后记得把$(1,0)$去掉，然后记录一下连通块的个数$cnt$，最后的答案便是$2^{cnt}$

放上~~巨丑无比的~~代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100005;
int fa[maxn<<2],opp[maxn<<2],del[maxn<<2];
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
int push(int x,int y){
	fa[x]=y;
}
int push(int x,int y,int c){
	if(c){
		x=find(x);y=find(y);
		if(x==y)return false;
		if(x==opp[y])return true;
		push(x,opp[y]);push(opp[x],y);
	}
	else{
		x=find(x);y=find(y);
		if(x==opp[y])return false;
		if(x==y)return true;
		push(x,y);push(opp[x],opp[y]);
	}
	return true;
}
long long mod=1e9;
long long power(long long a,int n){
	long long ans=1;
	while(n){
		if(n&1)ans=ans*a%mod;
		n>>=1;a=a*a%mod;
	}
	return ans;
}
int main(){
	int n,m,k;
	scanf("%d %d %d",&n,&m,&k);int all=n+m;
	for(int i=1;i<=all;++i)opp[i+all]=fa[i]=i,opp[i]=fa[i+all]=i+all;//(x,0)->x (0,y)->y+n
	int Im=0;
	for(int i=0,x,y,c,t;i<k;++i){
		scanf("%d %d %d",&x,&y,&c);
		if((x+1&1)==0&&(y+1&1)==0)c^=1;
		y+=n;
		if(!push(x,y,c)){
			Im=1;break;
		}
	}
	if(Im){
		putchar(0);
	}
	else{
		int temp=find(1),ans=0;
		del[temp]=true;del[opp[temp]]=true;
		for(int i=2;i<=all;++i){
			int x=find(i);
			if(!del[x])++ans;
			del[x]=del[opp[x]]=true;
		}
		printf("%lld",power(2,ans));
	}
	return 0;
}
```

~~似乎比其他做法要简洁吧。。。~~

~~希望这篇题解对你有帮助~~

~~欢迎提供hack数据~~

---

## 作者：是个汉子 (赞：21)

[洛谷传送门](https://www.luogu.com.cn/problem/P3631)

yyy，题解没看懂，还是自己说一个吧

### Solution

如果只要 $20\%$ 的分，状压是你最好的选择

（此题正解和状压没关系）

---

还是想想正解吧(\*^_^*)

既然输入就是这么输的，就直接将蓝色看作 $0$ ，红色看作 $1$ ，那么满足条件的 $2\times 2$ 的区域就是 $a_{i,j}\oplus a_{i,j+1}\oplus a_{i+1,j}\oplus a_{i+1,j+1}=1$  。

注意到，当第一列和第一行确定了如何染色时，整个表格就确定了。因为当一个 $2\times 2$ 的区域有三个确定时，最后一个也就确定了。

如果没有 $k$ 个已填格子的限制，方案数就是 $2^{n+m-1}$ 。

那么只要能把限制转化成和第一行第一列有关系，就可以求出真的方案数了。

对于一个点 $(x,y)$ ，经过一系列推导（推导别的题解写的很清楚）得：
$$
a_{1,1}\oplus a_{x,1}\oplus a_{1,y}\oplus a_{x,y}=((x-1)*(y-1))\&1
$$
人话就是：当 $x,y$ 均为偶数时，这四个东西异或为 $1$ ，不然为 $0$ 。

进一步意思是，我们知道了 $a_{x,y},a_{1,1}$ ，就可以知道 $a_{x,1}$ 和 $a_{1,y}$ 是颜色相同 $(0)$ 还是不同 $(1)$ 。

这个性质具有传递性——我们知道 $i,j$ 和 $j,k$ 的关系， $i,k$ 的关系也确定了。

那么考虑枚举 $a_{1,1}$ 的染色情况，用带权并查集来维护不同的关系。当块里某一个值确定了，那整个块就确定了。因为值有 $0,1$ 两种，所以每个块的贡献为 $2$ 。

设块数为 $cnt$ ，则答案为 $2^{cnt-1}$ 。（因为 $a_{1,1}$ 是确定的，则所在的连通块是确定的）

~~完结撒花~~

小细节：1.如果题目给了 $a_{1,1}$ 是什么色，那就不用枚举了。2. $a_{1,1}=0$ 直接枚举，当 $a_{1,1}=1$ 时，把除了第一行第一列的全部取反。因为之前是 $a_{x,y}\oplus0=a_{x,y}$ ，现在是 $a_{x,y}\oplus 1=(a_{x,y}\oplus1)\oplus 0$ 。3.在确定 $a_{x,1},a_{{1,y}}$ 关系时，为了方便，使得`四个东西`什么情况异或都为 $0$ ，具体操作为使得 $a_{x,y}\oplus 1$ 

其他细节可以看代码

### Code

```c++
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;
const int N=200010,mod=1e9;
int fa[N],g[N],n,m,k,ans,flag[2]={1,1};
int x[N],y[N],c[N];

int find(int x){
    if(x==fa[x]) return x;
    int tmp=find(fa[x]);
    g[x]^=g[fa[x]];	//带权并查集特殊之处
    return fa[x]=tmp;
}


int solve(){
    for(int i=1;i<=n+m;i++) fa[i]=i,g[i]=0;
    fa[n+1]=1;
    for(int i=1;i<=k;i++){
        int fx=find(x[i]),fy=find(y[i]+n);
        int tmp=g[x[i]]^g[y[i]+n]^c[i];
        if(fx!=fy) fa[fx]=fy,g[fx]=tmp;
        else if(tmp) return 0;
    }
    int res=-1;
    for(int i=1;i<=n+m;i++)
        if(fa[i]==i){
            if(res==-1) res=1;
            else res<<=1;
            if(res>=mod) res-=mod;
        }
    return res;
}

int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++){
        scanf("%d%d%d",&x[i],&y[i],&c[i]);
        if(x[i]==1&&y[i]==1) flag[c[i]^1]=0,--k,--i;
        else if(x[i]%2==0&&y[i]%2==0) c[i]^=1;	//x,y都为偶数时
    }
    if(flag[0]) ans+=solve();
    if(flag[1]){
        for(int i=1;i<=k;i++)
            if(x[i]>1&&y[i]>1) c[i]^=1;	//除了第一行第一列，都取反
        ans+=solve();
    }
    if(ans>=mod) ans-=mod;
    printf("%d\n",ans);
}
```



---

## 作者：litble (赞：14)

个人博客里的题解：<http://blog.csdn.net/litble/article/details/77506815>

# 题目分析

首先发现，如果我们把蓝色看作1，把红色看作0（不过红配蓝什么的真的丑....），那么对于每一个格子a(i,j)，都有：a(i,j)^a(i+1,j)^a(i,j+1)^a(i+1,j+1)=1

那么只要第一列和第一行确定了如何染色，整个表格的染色就确定了。（这是显然的，因为一个$2*2$的格子中有三个被染色了，剩下的格子颜色已定。）

现在我们把上面那个式子记作S(i,j),则我们对于每一个(i,j),求一次s(1,1)^s(1,2)^...^s(i-1,j-1),这个过程数学感不好的人（比如本蒟蒻），就要崩溃了。不过我们可以形象的想一想，相当于在一个i\*j的格子中用一块2\*2的小毯子不停地移位覆盖，那么被盖了偶数次的一个a(x,y），就会发生a(x,y)^a(x,y)=0这样的事故，而0^0=0,0^1=1,所以就相当于消除了。那么被盖了奇数次的格子只有a(1,1),a(i,1),a(1,j)和a(i,j),因此，a(1,1)^a(i,1)^a(1,j)^a(i,j)在i和j均为偶数的时候（此时(i-1)\*(j-1)是奇数，s的异或前缀和是1）为1，否则为0.

那么我们可以枚举a(1,1)的值，然后因为a(i,j)的值和a(1,1)的异同关系，a(i,1)和a(1,j)的异同关系可以确定，用带权并查集维护所有有关系的点a(i,1)或a(1,j)，然后有多少个集，答案就有2的多少次方的贡献。当然还要注意一点，有些集因为题目给出的条件所以已经确定了所有元素是1还是0，所以这些集对答案的贡献是1不是2.

# 代码实现

虽然题目分析已经很明了了，但是代码实现不够简洁，就容易如boshi大佬一样怀疑人生，怀疑鲁迅，怀疑枣树。

以下两个操作可以简洁代码：

1.如果a(1,1)=0，直接操作，如果枚举到a(1,1)=1,则把除了第一行和第一列以外的颜色都反过来即可。

2.带权并查集，通过异或等位运算操作进行判断，来简洁代码。给对于位运算操作不是很熟悉的人（比如本蒟蒻）的提醒：对于1和0，如果异或0，则不变，如果异或1，则发生变化。

还有本蒟蒻因为没取模WA了两次QAQ

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
using namespace std;
#define LL long long
LL mod=1000000000;
const int N=100005;
int n,m,T;
int x[N],y[N],w[N],f[N<<1],bj[N<<1],d[N<<1];
LL ans;
int find(int x){//带权并查集维护异同关系
    if(f[x]==x)return x;
    int t=f[x];
    f[x]=find(f[x]),d[x]=(d[x]+d[t])%2;
    return f[x];
}
LL work(){
    int i,r1,r2,t;LL re=1;
    for(i=1;i<=n+m;++i)f[i]=i,d[i]=0,bj[i]=-1;//bj[i]=-1表示这个集里的元素没有确定，0表示根节点取0，1表示根节点取1；d[i]=1表示i和根节点值不同，等于0表示相同。
    f[n+1]=1,bj[1]=0;
    for(i=1;i<=T;++i){
        if(x[i]==1&&y[i]==1)continue;
        if(x[i]==1||y[i]==1){//特判
            if(y[i]==1)r1=find(x[i]),t=x[i];
            else r1=find(y[i]+n),t=y[i]+n;
            if(bj[r1]==-1)bj[r1]=w[i]^d[t];
            else if(bj[r1]!=w[i]^d[t])return 0;
            continue;
        }
        r1=find(x[i]),r2=find(y[i]+n);
        if(r1!=r2){//连接
            f[r1]=r2,d[r1]=(d[y[i]+n]-d[x[i]]+w[i]+4)%2;
            if(bj[r1]!=-1&&bj[r2]!=-1&&bj[r2]!=bj[r1]^d[r1])return 0;
            if(bj[r2]==-1&&bj[r1]!=-1)bj[r2]=bj[r1]^d[r1],bj[r1]=-1;
        }
        else if(d[x[i]]^d[y[i]+n]^w[i]==1)return 0;//判断可行性
    }
    for(i=1;i<=n+m;++i)if(find(i)==i&&bj[i]==-1)re=(re<<1)%mod;//注意取模
    return re;
}
int main(){
    int i,j,flag=-1;
    scanf("%d%d%d",&n,&m,&T);
    for(i=1;i<=T;++i){
        scanf("%d%d%d",&x[i],&y[i],&w[i]);
        if(x[i]==1&&y[i]==1)flag=w[i];
        if(!(x[i]&1)&&!(y[i]&1))w[i]^=1;
    }
    if(flag==-1||flag==0)ans+=work();
    if(flag==-1||flag==1){
        for(i=1;i<=T;++i)//反过来后可以继续当a[1][1]=0
            if(x[i]!=1&&y[i]!=1)w[i]^=1;
        ans+=work();
    }
    ans%=mod//注意取模
    printf("%lld",ans);//我是不是很可爱啊QWQ？
    return 0;
}
```

---

## 作者：totorato (赞：8)

设格子颜色为0和1，那么每个2\*2方格中的异或值必定都为1．


根据这个条件，我们可以知道：

若我们选择了某些格子，此时已选格子的异或值为x，这时我们再选择某个2\*2的方格，异或值将变为x^1．每选择一个2\*2的方格，如果方格里的数已经被选择，那么相当于不再选择，没有选择的将添加到已选格子的集合中去．因此选择格子也是一个异或的过程．

这意味着．我们可以通过选择恰当的一些2\*2的方格，使得棋盘上有恰当的几个格子被选择，而它们的异或值我们又是可以维护的．


通过尝试与归纳，不难发现：

对于格子(x,y):

若x,y均为偶数，那么(x,y)=(x,1)^(1,y)^(1,1)^1

否则(x,y)=(x,1)^(1,y)^(1,1)

所以根据每一个已知颜色的格子，我们可以建立第一行和第一列格子相等与不相等的关系．这种关系可以用带权并查集维护．


我们又发现，如果确定了第一行和第一列，整个棋盘都是确定的了．因此我们只需要统计第一行和第一列的方案数即可．


对于已知格子(x,y)，如果它不再第一行或第一列，我们用它维护并查集，否则用来确定第一行和第一列某些并查集的颜色．


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

#define MX 2000002
#define MD 1000000000

using namespace std;

typedef long long ll;

int fa[MX],dis[MX];//表示该节点到根节点的距离，以及中途经过了多少次＂不同＂的关系
int have[MX],must[MX];//这个节点是否确定数值，确定的数值是几(用于判定冲突)
int n,m,k;
int px[MX],py[MX],pn[MX];//已知点的x,y,number
int vis[MX];

ll ksm(ll x,int t)
{
    ll ans=1;
    while(t)
    {
        if(t&1)ans=ans*x%MD;
        x=x*x%MD;
        t>>=1;
    }
    return ans;
}

int findfa(int x)
{
    if(fa[x]==x)return x;
    else
    {
        findfa(fa[x]);
        dis[x]+=dis[fa[x]];
        fa[x]=fa[fa[x]];
        return fa[x];
    }
}

ll work(int top)
{
    int f1,f2,x,y,del,ans=0;
    for(int i=1;i<=n+m;i++)fa[i]=i,dis[i]=0,vis[i]=0,must[i]=0,have[i]=0;
    for(int i=1;i<=k;i++)
    {
        if(px[i]==1||py[i]==1)continue;
        f1=findfa(x=px[i]);
        f2=findfa(y=(py[i]+n));
        del=(top+pn[i])&1;
        if(f1==f2)
        {
            if(((x&1)||(y&1)))
            {
                if((dis[x]+del)%2!=dis[y]%2)return 0;
            }
            else
            {
                if((dis[x]+del)%2==dis[y]%2)return 0;
            }
        }
        else
        {
            fa[f1]=f2;
            dis[f1]=((dis[x]%2!=dis[y]%2)+del+((x&1)||(y&1))+1)%2;
        }
    }
    fa[1]=n+1;
    have[findfa(1)]=1;
    must[fa[1]]=top;
    for(int i=1;i<=k;i++)
    {
        x=px[i];
        y=n+py[i];
        if(px[i]==1)
        {
            if(have[findfa(y)]==0)have[fa[y]]=1,must[fa[y]]=(pn[i]+dis[y])%2;
            else if(must[fa[y]]!=(pn[i]+dis[y])%2)return 0;
        }
        if(py[i]==1)
        {
            if(have[findfa(x)]==0)have[fa[x]]=1,must[fa[x]]=(pn[i]+dis[x])%2;
            else if(must[fa[x]]!=(pn[i]+dis[x])%2)return 0;
        }
    }
    for(int i=1;i<=n+m;i++)
        if(!vis[findfa(i)]&&!have[findfa(i)])
            vis[fa[i]]=1,ans++;
    return ksm(2,ans);
}

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++)scanf("%d%d%d",&px[i],&py[i],&pn[i]);
    cout<<(work(0)+work(1))%MD<<endl;
    return 0;
}
```

---

## 作者：wrpwrp (赞：6)

## T15 Apio2011 方格染色

~~20分算法：暴力枚举每个点~~

~~抄题解做的还是好好写总结吧~~

把红色视为0，蓝色视为1

假设有一个表格如下：

| A    | C    | E    | G    |
| ---- | ---- | ---- | ---- |
| B    | D    | F    | H    |

根据题设有$A\bigoplus B\bigoplus C\bigoplus D=C\bigoplus D\bigoplus E\bigoplus F=1$

然后有$A\bigoplus B\bigoplus E\bigoplus F=0$

而$E\bigoplus F\bigoplus G\bigoplus H=1$

所以$A\bigoplus B\bigoplus G\bigoplus H=1$

再放到一般性的表格中

| A       | ...... | C       |
| ------- | ------ | ------- |
| B       | ...... | D       |
| I       | ...... | J       |
| ....... | ...... | ....... |
| E       | ...... | G       |
| F       | ...... | H       |

当C，D处于奇数列的时候，有:

$A\bigoplus B\bigoplus C\bigoplus D=0,E\bigoplus F\bigoplus G\bigoplus H=0,B\bigoplus I\bigoplus D\bigoplus J=0$

所以有:

$A\bigoplus C\bigoplus I\bigoplus J=0$

推出

$A\bigoplus C\bigoplus F\bigoplus H=0$

即：

$A\bigoplus H=C\bigoplus F$

当C，D在偶数列上，有：

$A\bigoplus B\bigoplus C\bigoplus D=1,E\bigoplus F\bigoplus G\bigoplus H=1,B\bigoplus I\bigoplus D\bigoplus J=1$

当H在奇数行：

$1\bigoplus A\bigoplus H=C\bigoplus F$

当H在偶数行：

$A\bigoplus H=C\bigoplus F$



设H坐标为$(i,j)$,A坐标为$(1,1)$

则有：
$if(i\ mod\ 2==0\ and\ j\ mod \ 2==0) \ 1\bigoplus(1,1)\bigoplus(i,j) ==(1,j)\bigoplus(i,1)$
$else\ (1,1)\bigoplus(i,j) ==(1,j)\bigoplus(i,1)$

而显然如果确定了第一排，第一列，那么可以确定整张图。

所以可以枚举$(1,1)$的值，然后合并所有相关的集合，去掉已知点的集合，剩下的集合个数为$cnt$，则答案为$2^{cnt}$。
把(1,1)为0,1的答案加起来即可

合并集合的时候使用扩展域并查集维护到根节点的异或值。

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>

#define R register
#define ll long long

const int MAXN=1e6+10;
const int Mod=1e9;

inline int read()
{
	int x=0,f=1;
	char a=getchar();
	for(;a>'9'||a<'0';a=getchar()) if(a=='-') f=-1;
	for(;a>='0'&&a<='9';a=getchar()) x=x*10+a-'0';
	return x*f;
}

int n,m,k,flg=-1,cnt,Size;
int fa[MAXN];
int X[MAXN],Y[MAXN],Z[MAXN];

inline int find(int x) { return x==fa[x]?x:fa[x]=find(fa[x]); }
inline void merge(int x,int y)
{	
	int fx=find(x),fy=find(y); 
	fa[fx]=fy;cnt-=fx!=fy;
}

inline void Init()
{
	n=read();m=read();k=read();
	Size=n+m-1;
	for(R int i=1;i<=k;i++)
	{
		X[i]=read();Y[i]=read();Z[i]=read();
		if(X[i]==1&&Y[i]==1) flg=Z[i];
	}
}

inline int id(int x) { return x==1?1:m+x-1; }

int vis[MAXN];
int ans=0;

inline void Solve(bool delta)
{
	for(R int i=1;i<=Size*2;i++) fa[i]=i;
	cnt=Size*2;
	for(R int i=1;i<=k;i++)
	{
		int a=X[i],b=Y[i];
		if(a==1&&b==1) continue;
		if(a%2==0&&b%2==0)
		{
			if(1^delta^Z[i]) 
			{
				merge(id(a),b+Size);merge(id(a)+Size,b);
			}
			else
			{
				merge(id(a),b);merge(id(a)+Size,b+Size);
			}
		}
		else
		{
			if(delta^Z[i]) 
			{
				merge(id(a),b+Size);
				merge(id(a)+Size,b);
			}
			else
			{
				merge(id(a),b);
				merge(id(a)+Size,b+Size);
			}
		}
		if(find(b)==find(b+Size)||find(id(a))==find(id(a)+Size))
		{
			printf("0\n");
			exit(0);
		}
	}
	memset(vis,0,sizeof(vis));
	cnt--;
	vis[find(1)]=1;
	for(R int i=1;i<=k;i++)
	{
		if(X[i]==1&&vis[find(Y[i])]==0) 
		{
			vis[find(Y[i])]=1;
			cnt--;
		}
		else 
			if(Y[i]==1&&vis[find(id(X[i]))]==0)
			{
				vis[find(id(X[i]))]=1;
				cnt--;
			}
	}
	cnt>>=1;
	int tmp=1;
	for(R int i=1;i<=cnt;i++) tmp=(tmp<<1)>=Mod?(tmp<<1)-Mod:(tmp<<1);
	ans=ans+tmp>=Mod?ans+tmp-Mod:ans+tmp;
}

int main()
{
	Init();
	if(flg==-1) Solve(0),Solve(1);
	if(flg==0) Solve(0);
	if(flg==1) Solve(1);
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：DengDuck (赞：4)

将红色看作 $1$，蓝色看作 $0$，那么题目要求即为，对于所有的 $x,y$，满足：

$$
a_{x,y}\oplus a_{x-1,y}\oplus a_{x,y-1} \oplus a_{x-1,y-1}=1
$$

显然也应该满足：

$$
a_{x-1,y}\oplus a_{x-2,y}\oplus a_{x-1,y-1} \oplus a_{x-2,y-1}=1
$$

两式子合并，得：

$$
a_{x,y}\oplus a_{x,y-1}\oplus a_{x-2,y}\oplus a_{x-2,y-1}=0
$$

这个式子继续推广，最后可以得到结论：

$$
a_{x,y}\oplus a_{x,y-1}\oplus a_{x-2t,y}\oplus a_{x-2t,y-1}=0
$$

同理我们有：

$$
a_{x,y-1}\oplus a_{x,y-2}\oplus a_{x-2t,y-1}\oplus a_{x-2t,y-2}=0
$$

两式子合并，得：

$$
a_{x,y}\oplus a_{x,y-2}\oplus a_{x-2t,y}\oplus a_{x-2t,y-2}=0
$$

这个式子与上面的那个结论比较，可以得到结论：

$$
a_{x,y}\oplus a_{x,y-k}\oplus a_{x-2t,y}\oplus a_{x-2t,y-k}=0
$$



同理：

$$
a_{x,y}\oplus a_{x,y-2*k}\oplus a_{x-t,y}\oplus a_{x-t,y-2*k}=0
$$


因此，不难发现：

当 $x $ 和 $y$ 中有任意一个数字为奇数，则：

$$
a_{x,y}\oplus a_{x,1}\oplus a_{1,y}\oplus a_{1,1}=0
$$

否则，我们有：


$$
a_{x,y}\oplus a_{x,1}\oplus a_{1,y}\oplus a_{1,1}=1
$$
 
这个怎么证明呢？同机房大佬证出来了，我贴一个 [剪贴板](https://www.luogu.com.cn/paste/0vduacja)。

好了，准备工作完成了。

我们接下来发现确定了第一行和第一列之后就可以确定整个方案，原因很简单。

所以一开始空的方案数为 $2^{n+m-1}$。

再看看上面的式子，我们发现当 $a_{1,1}$ 和 $a_{x,y}$ 已知时可以推出 $a_{x,1}$ 和 $a_{1,y}$ 的关系就不难想到每个点对答案的贡献了。

因为一开始点与点之间的决策是独立的，而每个点相当于确定了他们之间的一些关系，所以用一个带权并查集维护即可。

设有 $k$ 个连通块，则答案为 $2^{k-1}$。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=1e6;
const LL mod=1e9;
LL ksm(LL x,LL y)
{
	if(y<0)return 0;
	LL ans=1;
	while(y)
	{
		if(y&1)ans=ans*x%mod;
		x=x*x%mod,y>>=1; 
	}
	return ans;
}
LL n,m,k,fa[N],g[N],x[N],y[N],z[N],flg[2],ans;
LL find(LL x)
{
	if(fa[x]==x)return x;
	LL t=find(fa[x]);
	g[x]^=g[fa[x]];
	return fa[x]=t;
}
LL solve(LL a)
{
	for(int i=1;i<=n+m;i++)fa[i]=i,g[i]=0;
	fa[1]=1+n;
	for(int i=1;i<=k;i++)
	{
		LL fx=find(x[i]),fy=find(n+y[i]);
		LL t=z[i]^a;
		if(x[i]%2==0&&y[i]%2==0)t^=1;
		if(fx!=fy)fa[fx]=fy,g[fx]^=t^g[x[i]]^g[y[i]+n];
		else if(t!=g[x[i]]^g[y[i]+n])return 0;
	}
	LL cnt=0;
	for(int i=1;i<=n+m;i++)
	{
		if(find(i)==i)cnt++;
	}
	return ksm(2,cnt-1);
}
int main() 
{
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>x[i]>>y[i]>>z[i];
		if(x[i]==1&&y[i]==1)flg[z[i]]=1,i--,k--;
	}
	if(!flg[1])ans=(ans+solve(0))%mod;
	if(!flg[0])ans=(ans+solve(1))%mod;
	cout<<ans<<endl;
}
```

---

## 作者：WRuperD (赞：2)

这里因该是一个更加好理解的简单，没有繁琐证明的简单做法。

首先，感觉出现奇数次太抽象了，于是我们令所有 $x\bmod2=1,y\bmod2=1$ 的点的染色全部都换一下。发现题目条件变为了出现偶数次。这样做的好处是现在整个矩阵中任意四个位置可以构成矩形的位置的染色都会满足题目限制。个人感觉会稍微好看不少。

然后你手玩一下发现（或者是经典套路），只要确定第一行和第一列就可以确定整个矩阵。首先可以判定初始答案为  $2^{n+m-1}$。然后注意到每一步你填的那一行或者那一列已经有填过数了，相当于确定了那一行和当前行（那一列和当前列）的元素关系，答案除以二。

于是用拓展域并查集随便维护一下就可以了。


```cpp
// Problem: P3631 [APIO2011] 方格染色
// URL: https://www.luogu.com.cn/problem/P3631
// Writer: WRuperD
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
const long long inf = 1e18;
const int mininf = 1e9 + 7;
#define int long long
#define pb emplace_back
inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void write(int x){if(x<0){x=~(x-1);putchar('-');}if(x>9)write(x/10);putchar(x%10+'0');}
#define put() putchar(' ')
#define endl puts("")
const int MAX = 3e5 + 10;
const int mod = 1e9;
int quickPower(int a,int b,int p){int base=a,ans=1;while(b){if(b&1)ans*=base,ans%=p;base*=base;base%=p;b>>=1;}return ans;}

map <pair<int,int>, int> a;
int st[MAX], st2[MAX];
int fa[MAX * 4];
int find(int x){
	if(fa[x] == x)	return x;
	return fa[x] = find(fa[x]);
}

void merge(int x, int y){
	fa[find(x)] = find(y);
}

void solve(){
	// int inv = quickPower(2, mod - 2, mod);
	int n = read(), m = read(), q = read();
	int ans = n + m - 1;
	for(int i = 1; i <= 2 * n + 2 * m + 1; i++)	fa[i] = i;	
	for(int i = 1; i <= max(n, m); i++)	st[i] = st2[i] = -1;
	while(q--){
		int x = read(), y = read(), val = read();
		if(x % 2 and y % 2)	val ^= 1;
		a[make_pair(x, y)] = val;
		bool fl = 0;
		bool fl2 = 1;
		for(int i = 1; i <= n; i++){
			if(st[y] == -1)	break;
			i = st[y];
			// if(a.count(make_pair(i, y))){
			fl2 = 0;
			if((a[make_pair(i, y)] ) == val){
				if(find(i + n) == find(x) or find(x + n) == find(i)){
					puts("0"), exit(0);
					break;
				}
				if(find(i + n) == find(x + n) or find(i) == find(x))	break;
				fl = 1;
				merge(i + n, x + n), merge(i, x);
			}else{
				if(find(i + n) == find(x + n) or find(i) == find(x)){
					puts("0"), exit(0);
					break;
				}
				if(find(i + n) == find(x) or find(x + n) == find(i))	break;
				fl = 1;
				merge(i + n, x), merge(i, x + n);
			}
			break;
		}
		
		for(int i = 1; i <= m; i++){
			if(st2[x] == -1){
				break;
			}
			i = st2[x];
			fl2 = 0;
			if((a[make_pair(x, i)]) == val){
				if(find(2 * n + i + m) == find(2 * n + y) or find(2 * n + y + m) == find(2 * n + i)){
					puts("0"), exit(0);
					break;
				}
				if(find(2 * n + i + m) == find(2 * n + y + m) or find(2 * n + i) == find(2 * n + y))	break;
				fl = 1;
				merge(2 * n + i + m, 2 * n + y + m), merge(2 * n + i, 2 * n + y);
			}else{
				if(find(2 * n + i + m) == find(2 * n + y + m) or find(2 * n + i) == find(2 * n + y)){
					// write(find(2 * n + i + m)), put(), write(find(2 * n + x + m)), endl;
					puts("0"), exit(0);
					break;
				}
				if(find(2 * n + i + m) == find(2 * n + y) or find(2 * n + y + m) == find(2 * n + i))	break;
				fl = 1;
				merge(2 * n + i + m, 2 * n + y), merge(2 * n + i, 2 * n + y + m);
			}
			break;
		}
		st2[x] = y;
		st[y] = x;
		if(fl or fl2)	ans --;
	}
	if(ans < 0)	puts("0");
	else write(quickPower(2, ans, mod)), endl;
}

signed main(){
	int t = 1;
	while(t--)	solve();
	return 0;
}
```

---

## 作者：木xx木大 (赞：2)

[P3631 [APIO2011]方格染色](https://www.luogu.com.cn/problem/P3631)

挺神奇的一道题。于是决定写篇题解总结一下。本篇题解和其他题解的思路差不多，主要是有一些我自己的理解。

记 $(x,y)$ 表示格子 $(x,y)$ 的颜色：$(x,y)⊕(x−1,y)⊕(x,y−1)⊕(x−1,y−1)=1$

令 $x=x-1$，有：$(x−1,y)⊕(x−2,y)⊕(x−1,y−1)⊕(x−2,y−1)=1$

两式异或起来得到：$(x,y)⊕(x,y−1)⊕(x−2,y)⊕(x−2,y−1)=0$

归纳得到：$(x,y)⊕(x,y−1)⊕(x−2k,y)⊕(x−2k,y−1)=0$

同理有：$(x,y)⊕(x,y−2)⊕(x−2k,y)⊕(x−2k,y−2)=0$

同理：$(x,y)⊕(x,y−t)⊕(x−2k,y)⊕(x−2k,y−t)=0$

同理亦有：$(x,y)⊕(x,y−2k)⊕(x−t,y)⊕(x−t,y−2k)=0$

于是若 $x,y$ 中至少有一个是奇数时：$(x,y)⊕(x,1)⊕(1,y)⊕(1,1)=0$

当 $x,y$ 都是偶数时，$(x,y)⊕(x,1)⊕(1,y)⊕(1,1)=1$

如果原方格内的第一行和第一列的格子被确定，那么整个方格即可被唯一确定。如果 (1,1) 和 $(i, j)$ 确定了，那么 $(1,j)$ 和 $(i,1)$ 的关系也就被确定了，也就是一定相等和一定不相等。我们可以用带权并查集来实现。

具体地，枚举（1,1）可能的情况，对于每种情况把有关系的点放在一个连通块内，最终除了(1,1)所在的连通块，其他连通块都有1,0两种选择，最后的答案即为 $2^{连通块个数-1}$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5;
const int mo=1e9;
int n,m,k,x[N],y[N],z[N],fa[N],g[N];
ll qpow(ll x,int y)
{
	ll s=1;
	while(y)
	{
		if(y&1)s=s*x%mo;
		x=x*x%mo;
		y>>=1;
	}
	return s;
}
int find(int u)
{
	if(u==fa[u])return u;
	int f=find(fa[u]);
	g[u]^=g[fa[u]];
	fa[u]=f;
	return fa[u];
}
ll calc(int opt)
{
	int cnt=0;
	for(int i=1;i<=n+m;i++)
	{
		fa[i]=i;
		g[i]=0;
	}
	fa[n+1]=1;
	if(opt)
	{
		for(int i=1;i<=k;i++)
			if(x[i]>1||y[i]>1)
				z[i]^=1;
	}
	for(int i=1;i<=k;i++)
	{
		if(x[i]==1&&y[i]==1)continue;
		int fx=find(x[i]),fy=find(n+y[i]);
		int w=g[x[i]]^g[n+y[i]]^z[i];
		if(fx!=fy)
		{
			fa[fx]=fy;
			g[fx]=w;
		}
		else if(w)return 0;
	}
	for(int i=1;i<=n+m;i++)
		if(i==find(i))cnt++;
	return qpow(2,cnt-1);
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	int fl=-1;
	for(int i=1;i<=k;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&z[i]);
		if(!(x[i]&1)&&(!(y[i]&1)))z[i]^=1;
		if(x[i]==1&&y[i]==1)
			fl=z[i];
	}
	if(fl!=-1)
		printf("%lld",calc(fl));
	else printf("%lld",(calc(0)+calc(1))%mo);
	return 0;
}
```

---

## 作者：Kazeno_Akina (赞：1)

纪念一下自己第一道独立完成的非网络流紫。

看到要求，感觉这个“要求 $2\times 2$ 方格内的红格子数量为 $1$ 或 $3$”很奇怪。

于是考虑转化限制。观察举例可以发现，这其实就是说，记 $k_{i,j}$ 表示网格第 $i$ 行第 $j$ 列与第 $i+1$ 行第 $j$ 列颜色是否相同，那么 $\forall 1\le i < m,\ k_{i,j} \not =k_{i+1,j}$。

然后考虑这个 **上下相邻** 的特殊做法能不能拓展。发现在确定第 $i$ 列的任意一个格子之后，这一列的所有数就都可以被这一个格子异或一段 $k_{i,j}$ 得到。

因此这个东西可以非常方便地拓展。具体地，考虑使用扩展域并查集维护。当 $i$ 与 $j$ 在同一父亲下时，代表第 $i$ 行与第 $j$ 行在奇数列取值相同、偶数列取值相反；而若 $i$ 与 $j+n$ 在同一父亲下，代表第 $i$ 行与第 $j$ 行在偶数列取值相同、奇数列取值相反。

$merge$ 操作只需在每一列下做即可，最后的答案是 $2^{free}\times 2^{cnt-1}$，其中 $free$ 指没有任何钦定颜色的列的数量，$cnt$ 指相关联的行一共分为几种（比如 $1,2,3$ 行相互关联，$4,6$ 行相互关联，第 $7$ 行独立，那此时 $free$ 就是 $3$）。当然判断 $0$ 也非常容易，在 $merge$ 做完之后查一遍是否不存在 $i$ 使得 $find(i)=find(i+n)$ 即可。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5,P=1e9;
int n,m,k,cnt,kcnt,fa[N<<1];
long long ans;
vector<pair<int,bool>> mem[N];
int find(int p){return(p==fa[p])?(p):(fa[p]=find(fa[p]));}
inline void merge(int u,int v,bool flag){
    if(flag){
        if(find(u)==find(v)) return;
        fa[find(u)]=find(v),fa[find(u+n)]=find(v+n),--kcnt;
    }
    else{
        if(find(u)==find(v+n)) return;
        fa[find(u+n)]=find(v),fa[find(u)]=find(v+n),--kcnt;
    }
}
inline long long qp(long long a,int b,int p=P){
    long long res(1);
    for(a%=p;b;a=a*a%p,b>>=1) if(b&1) res=res*a%p;
    return res;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >> m >> k,kcnt=n;
    for(int i(1);i<=2*n;++i) fa[i]=i;
    for(int i(1),x,y,c;i<=k;++i) cin >> x >> y >> c,mem[y].push_back({x,c});
    for(int i(1);i<=m;i+=2) for(int j(1);j<mem[i].size();++j) merge(mem[i][j-1].first,mem[i][j].first,mem[i][j].second==mem[i][j-1].second);
    for(int i(2);i<=m;i+=2) for(int j(1);j<mem[i].size();++j) merge(mem[i][j-1].first,mem[i][j].first,(mem[i][j].second!=mem[i][j-1].second)^(mem[i][j-1].first-mem[i][j].first&1)^1);
    for(int i(1);i<=n;++i) if(find(i)==find(i+n)) return cout << 0,0;
    for(int i(1);i<=m;++i) cnt+=(mem[i].empty());
    cout << qp(2,cnt)*qp(2,kcnt-1)%P;
    return 0;
}
```

---

## 作者：WTR2007 (赞：0)

## [APIO2011] 方格染色

### 题目描述

给定 $k$ 个坐标的颜色 $(0$ 或 $1)$，用 $0$ 和 $1$ 两种颜色对剩下的方格染色，使得对于任意 $2 \times 2$ 的方格中，只有 $1$ 个 $1$ 或 $3$ 个 $1$。求满足条件的染色方案数，答案对 $10^9$ 取模。

数据范围：$2 \leqslant n,m \leqslant 10^5$，$0 \leqslant k \leqslant 10^5$。

### 题解

本题解中 $n, m$ 被视为同阶。

我们规定 $f(x, y)$ 表示 $(x, y)$ 上的颜色。注意到，任意 $ 2 \times 2 $ 的方格中有 $1$ 个或 $3$ 个 $1$，这等价于这四个方格的**异或和**为 $1$，即对于任意 $1 \le x < n$，$1 \le y < m$，都满足：
$$f(x, y) \oplus f(x + 1, y) \oplus f(x, y + 1) \oplus f(x + 1, y + 1) = 1$$

--------

#### Theorem 1

所以如果合法方格内的第一行和第一列的格子颜色被确定，那么整个 $ n \times m $ 方格即可被唯一确定。

#### Prove 1

如果我们已知 $ 2 \times 2 $ 的格子中的 $3$ 个的颜色，显然可以确定剩下一个的颜色。接下来按照第二行，第三行，$\dots$，第 $n$ 行的顺序，每行从左往右依次确定颜色，每次用 $(x - 1, y), (x, y - 1), (x - 1, y - 1)$ 三个点的颜色确定 $(x, y)$ 的颜色，即整个 $ n \times m $ 方格即可被唯一确定。

形式化地讲，利用数学归纳法，当 $n = 1$ 或 $m = 1$ 时结论显然成立。假定 $(n, m) = (x - 1, y)$ 和 $(n, m) = (x, y - 1)$ 结论成立，其中 $x \ne 1, y \ne 1$，那么当 $(n, m) = (x, y)$ 时，$f(x, y) = f(x - 1, y) \oplus f(x, y - 1) \oplus f(x - 1, y - 1) \oplus 1$，因此结论成立。

------

#### Theorem 2

合法方格中，对于任意 $1 \le x \le n$，$1 \le y \le m$，都有 $(1, 1)$，$(x, y)$，$(x, 1)$，$(1, y)$ 的颜色异或和为 $(x - 1)(y - 1) \bmod 2$，即
$$f(1, 1) \oplus f(1, y) \oplus f(x, 1) \oplus f(x, y) = \begin{cases} 1 & x \bmod 2 = y \bmod 2 = 0 \ \\ 0 & \text{Otherwise} \end{cases}$$

#### Prove 2

我们将这 $ x \times y $ 方格中的每个 $ 2 \times 2 $ 的单位方格全部异或起来，注意到，不在该方格边缘的格子被异或了 $4$ 次，而在方格边缘又不在四个角的格子被异或了 $2$ 次，它们的颜色对答案不做贡献，因此最后的异或和等于方格中四个角的异或和。由于每个 $ 2 \times 2 $ 的单位方格的异或值都为 $1$，又共有 $(x - 1)(y - 1)$ 个单位方格，所以最后的异或和为 $(x - 1)(y - 1) \bmod 2$。

------------

由 $\text{Theorem 1}$ 可知答案等价于第一行和第一列的合法染色数。

因此，我们考虑枚举 $(1, 1)$ 位置的颜色，对于每个已知的点 $(x, y)$，由 $\text{Theorem 2}$ 可知 $(x, 1)$ 和 $(1, y)$ 的关系，用拓展域并查集维护。如果在维护中矛盾，此时不存在合法方案，否则我们记 $cnt$ 为第一行和第一列中连通块的数量，由于和 $(1, 1)$ 相连的点颜色确定，因此这次枚举答案便为 $2 ^ {cnt - 1}$，求和取模即可。

注意，若 $(1, 1)$ 的颜色已经确定，那么便不需要枚举。

时间复杂度为：$ \mathcal O(n \log n)$ 或 $ \mathcal O(n \times \alpha(n))$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MOD = 1000000000;
struct dsu {
	vector<int> fa;
	dsu(int n) : fa(n + 2) { iota(fa.begin(), fa.end(), 0); };
	inline int Find(int r) {
		while (r != fa[r]) r = fa[r] = fa[fa[r]];
		return r;
	}
	inline bool Merge(int x, int y) {
		x = Find(x); y = Find(y);
		if (x == y) return true;
		else return fa[y] = x, false;
	}
}; // 并查集模板
inline int read() {
	int w = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		w = (w << 1) + (w << 3) + ch - 48;
		ch = getchar();
	}
	return w * f;
}
inline int Pow(int a, int b) {
	int ans = 1;
	a %= MOD;
	for (; b; b >>= 1) {
		if (b & 1) ans = ans * a % MOD;
		a = a * a % MOD;
	}
	return ans;
}
signed main() {
	int n, m, k, ans = 0, flag = -1;
	n = read(); m = read(); k = read();
	const int tot = n + m - 1; // 第一行和第一列的总点数
	vector<int> x(k + 1), y(k + 1), z(k + 1);
	for (int i = 1; i <= k; i++) {
		x[i] = read(); y[i] = read(); z[i] = read();
		if (y[i] == 1 && x[i] == 1) flag = z[i];
	}
	auto Pos = [&](int x, int op1, int op2) {
	    if (x == 1) {
	        if (op2 == 1) return tot + 1; // (1, 1) 的扩展域为 tot + 1
	        else return x;
	    }
		if (op2 == 1) x += tot; // 表示为扩展域
		if (op1 == 1) x += n - 1; // 表示在第一行上
		return x;
	};
	for (int rt = 0; rt <= 1; rt++) {
		int sum = 0;
		dsu A(tot << 1);
		if (flag != -1 && flag != rt) continue; // 若 (1, 1) 确定就不进行枚举
		for (int i = 1; i <= k; i++) {
			if (x[i] == 1 && y[i] == 1) continue;
			int x1 = Pos(x[i], 0, 0), y1 = Pos(y[i], 1, 0), x2 = Pos(x[i], 0, 1), y2 = Pos(y[i], 1, 1);
			int opt = ((x[i] & 1) | (y[i] & 1)) ^ (z[i] ^ rt);
			if (!opt) A.Merge(x1, y2), A.Merge(x2, y1);
			else A.Merge(x1, y1), A.Merge(x2, y2);
			if (A.Find(x1) == A.Find(x2) || A.Find(y1) == A.Find(y2)) {
				printf("0\n"); // 发生冲突
				return 0;
			}
		}
		for (int i = 1; i <= tot; i++) 
			if (i == A.Find(i)) sum++; // 统计联通块数目
		ans = (ans + Pow(2, sum - 1)) % MOD;
	}
	printf("%lld\n", ans);
	return 0;
}
```


---


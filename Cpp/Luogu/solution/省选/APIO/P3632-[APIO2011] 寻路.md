# [APIO2011] 寻路

## 题目描述

TooDee 是一块二维格子状的土地（就像著名的笛卡尔坐标系那样），在这里生活着很多可爱的 Dee。Dee 是像蜜蜂一样的小动物，它们只在二维活动，而且他们非常的 文明开化。TooDee 的蜂窝和正常世界的蜂窝也是很不一样的，他们是矩形的且它们的边平行于 TooDee 的地理坐标系，就是说矩形的边或者是东西走向， 或者是南北走向。

因为 Dees 是很高级的生物，他们有很多固定的飞行轨道，这些轨道由一些平行于坐标轴的线段组成，线段只会在经纬度都是整数的点相交。Dee 在 TooDee 飞行时必须遵守以下规则（请记住 TooDee 中所有点的经纬度都是整数）：

1. 如果当前在点 $(X, Y)$，则下一步只能飞到四个邻点 $(X, Y - 1), (X, Y + 1), (X - 1, Y), (X + 1, Y)$；

2. 不可以进入蜂巢；

3. 只能在蜂巢的角上或者边上改变飞行方向；

4. 开始的时候可以向任何方向飞；

今晚是公共财政大臣 Deeficer 的女儿的生日，她想尽早回家，请帮她找到最快的回家路径。假设她每秒可以飞行一个单位的距离。

## 说明/提示

对于 $20\%$ 的测试数据，$n\leq 10$，所有的坐标都是小于 $100$ 的非负整数；

对于 $60\%$ 的测试数据，$n\leq 100$，所有坐标的绝对值都小于 $10^3$；

对于 $100\%$ 的测试数据，$0\leq n\leq 10^3$，所有坐标的绝对值都是不超过 $10^9$ 的整数。

## 样例 #1

### 输入

```
2

1 7 7 8
2
2 5 3 8
4 10 6 7

2 1 5 4
1
3 1 4 3
```

### 输出

```
9
No Path
```

# 题解

## 作者：Eleveslaine (赞：9)

## 前言

调了三天终于过了。  
一道基于图论、初中平面几何基础的大模拟。  
感谢 @[lovely_seele](https://www.luogu.com.cn/user/714821) 提供的帮助。  
赠送一个固定 $n=2$ 的[数据生成器](https://www.desmos.com/calculator/emcwegdahq?lang=zh-CN)，其中所有点都可以拖动。绿点为浮标，数长度用。  
彩蛋：[不可以“不可以，总司令”](https://www.luogu.com.cn/record/100308813)。

## 题意

平面内给定起点 $S$、终点 $E$ 和 $n$ 个矩形。  

- 走上下左右，只能在矩形边上转向，在平面的其他位置不能转向。  
- 不能进入矩形内部。  
- 可以以任意方向从起点出发。

求起点到终点的最短路径长度，或报告无解。

例如，本题样例中第一组数据如图所示。

![图片无法显示](https://cdn.luogu.com.cn/upload/image_hosting/ren9vopc.png)

## 思路

对于此题，单纯的 BFS 难以实现，并且在时间复杂度上也无法接受，考虑**连点、建图跑最短路**。  

### 准备工作

先写图论部分，实现链式前向星存图、加边和一种单源最短路算法即可。本题无负权，可以采用~~还没死的~~ Dijkstra 算法。代码实现上把所有图论内容放在 `namespace Graph` 中。  
为了后续建图的方便，我们令本题中所有的长方形都长这个样子：

![图片无法显示](https://cdn.luogu.com.cn/upload/image_hosting/fna36ksm.png)

其中 $A,B$ 为输入的两点，保证 $x_A<x_B,y_A>y_B$。这样 $C,D$ 可以由 $A,B$ 的坐标得到，即 $C(x_B,y_A),D(x_A,y_B)$。为了保证 $A,B$ 相对位置正确，输入时需要视情况交换 $A,B$ 的某个坐标。

之后，需要进行离散化，实现几何点 $(x,y)\to$ 图中结点 $u$ 的映射。以下代码中，一些函数和自定义类可以看名称理解其作用。

```cpp
// Point 为自定义类，有 int x,y 两个值
// 离散化，id[A] 表示 (A.x, A.y) 在图中结点编号
int cnt=0;
map <Point,int> id;
// 返回 (A.x, A.y) 在图中结点编号，没有的建立新点
inline int PointID(const Point &A)
{
    if(id[A]!=0)
        return id[A];
    ++cnt;
    return id[A]=cnt;
}
// 两点是否连接过
map <pair<Point,Point>,bool> connected;
// 在几何图形中连接两点，边权为其几何距离
inline void Connect(const Point &A,const Point &B)
{
    if(A==B||connected[(pair<Point,Point>){A,B}]||connected[(pair<Point,Point>){B,A}])
        return;
    connected[(pair<Point,Point>){A,B}]=connected[(pair<Point,Point>){B,A}]=1;
    // Dist(A,B) 为 A,B 之间的距离
    Graph::AddEdge(PointID(A),PointID(B),Dist(A,B));
    Graph::AddEdge(PointID(B),PointID(A),Dist(A,B));
}
```

### 连边建图

假设有一点 $P(x_P,y_P)$，需要实现一个函数 $\mathbf{Make}(P)$ 建立点 $P$ 与给出的 $n$ 个矩形可能的连边。  
因为**不能进入矩形内部**，所以只要找到 $P$ 分别向上、向下、向左、向右**距离最小**的 $4$ 个矩形并连接即可。找最小值时遍历所有矩形，时间复杂度 $O(n)$，可以接受。  
为了处理同一矩形的同一条边上出现两个不同点 $T_1,T_2$ 却没有在图中连接 $T_1T_2$ 的情况，定义矩形 $\alpha$ 的边 $m$ 上连接过的点集为 $\mathrm{coord[\alpha]}[m]$。例如，一个矩形 $\alpha$ 的边 $BD$ 形如 $D\text-T_1\text-\text-T_2\text-B$，则 $\mathrm{coord[\alpha]}[BD]=\{D,T_1,T_2,B\}$，最后再依次连接 $DT_1,T_1T_2,T_2B$。代码中使用默认有序的 `STL set` 实现，省去排序过程。  
下面给出的伪代码描述了找点 $P$ 向上、向下 $2$ 个矩形并连接的过程，其中 $\mathrm{Rectangles}$ 为输入的矩形集，$\square ACBD$ 定义为线段 $AC,CB,BD,AD$ 上点的并集，$A_{\alpha},B_{\alpha}$ 等定义为矩形 $\alpha$ 的对应顶点。  
找到交点后将交点放进所在矩形边的 $\text{coord}$ 集合中，最后再枚举矩形的每条边依次连接即可。

$$
\begin{aligned}
  \ & \underline{\mathbf{Make}(P)}\\
 1\ & \mathrm{min}x_1,\mathrm{min}x_2 \gets +\infty; \alpha_1,\alpha_2 \gets \emptyset\\
 2\ & \mathbf{for}\ \square ACBD \in \mathrm{Rectangles}:\\
 3\ & \quad \mathbf{if}\ l:x=x_P \cap \square ACBD \ne \emptyset:\\
 4\ & \qquad \mathbf{if}\ P\ \mathrm{is\ below}\ \square ACBD:\\
 5\ & \qquad\quad \mathrm{Point}\ T=(l:x=x_P \cap BD)\\
 6\ & \qquad\quad\mathbf{if}\ |PT| < \mathrm{min}x_1:\\
 7\ & \qquad\qquad \mathrm{min}x_1 \gets |PT|\\
 8\ & \qquad\qquad \alpha_1 \gets \square ACBD\\
 9\ & \qquad \mathbf{else\ if}\ P\ \mathrm{is\ above}\ \square ACBD:\\
 10\ & \qquad\quad \mathrm{Point}\ T=(l:x=x_P \cap AC)\\
 11\ & \qquad\quad\mathbf{if}\ |PT| < \mathrm{min}x_2:\\
 12\ & \qquad\qquad \mathrm{min}x_2 \gets |PT|\\
 13\ & \qquad\qquad \alpha_2 \gets \square ACBD\\
 14\ & \mathrm{Point}\ T_1=(l:x=x_P \cap B_{\alpha_1}D_{\alpha_1})\\
 15\ & \mathrm{Point}\ T_2=(l:x=x_P \cap A_{\alpha_2}C_{\alpha_2})\\
 16\ & \mathrm{Connect}\ PT_1,PT_2 \\
 17\ & \mathrm{Insert}\ T_1\ \mathrm{to\ coord[\alpha_1]}[BD] \\
 18\ & \mathrm{Insert}\ T_2\ \mathrm{to\ coord[\alpha_2]}[AC] \\
\end{aligned}
$$

求交点坐标可以使用初中平面几何相关知识。对向左、向右两个方向上矩形的处理与上面相似，不再展示。

实现 $\mathbf{Make}(P)$ 函数后，对每个矩形 $ACBD$ 依次对其四个顶点进行 $\mathbf{Make}$ 操作。另外别忘了对 $S,E\ \mathbf{Make}$ 一下。

### 特殊情况

1. $n=0$，即没有矩形。  
这时可以节省时间，如果 $S,E$ 同在一条平行于坐标轴的直线上，那么答案就是 $|SE|$；否则无解。

2. $S=E$，即起点终点重合。  
为了减少可能的麻烦这里特判一下，显然答案为 $0$。

3. $n \ne 0,S \ne E$ 且 $S,E$ 在同一条平行于坐标轴的直线上。  
如果没有考虑这种情况或处理不当会 WA on \#6。此时若 $S,E$ 之间没有矩形需要连接 $SE$。这个判断直接枚举即可，时间复杂度为 $O(n)$，为减小常数与最后处理 $\mathrm{coord}$ 的循环合并。  
另外，有[一篇题解](https://www.luogu.com.cn/blog/124571/solution-p3632)直接连接了 $SE$ 而不考虑它们之间是否有矩形，针对此有 hack 数据，具体见[此贴](https://www.luogu.com.cn/discuss/562904)。

最后建完图以 $S$ 为起点跑一波 Dijkstra，如果结果为 `inf`，报告无解；否则输出最短距离。

## 代码

上面思路中提到的问题仅仅是对平面几何关系最简洁直观的描述。真正的实现需要判断点坐标之间的关系，略为复杂，但是都在初中平面几何知识范围内，推出来也并不难。  
完整代码见[云剪贴板](https://www.luogu.com.cn/paste/mwqcfbhz)。总时间复杂度 $O(n^2)$，并且已经尽量合并循环、减小常数，对本题的 $3\text s$ 时限绰绰有余。  
另外**多测记得清空，建图要清彻底**，就因为这个调了三天才过。

最后求过一下吧（可怜）。另外以现在的标准，这题现在还没有合规的题解。

---

## 作者：_RainCappuccino_ (赞：5)

> $\texttt{TAG}$：模拟、最短路

目前能通过该题所有 hack。

题意略，求 $(X_s,Y_s)$ 到 $(X_t,Y_t)$ 的最短路。

首先，考虑暴力建图，点的值域范围到了 $10^9$ 显然是不能直接暴力建图的。

由于中间的点其实不重要，我们只需要考虑转弯的情况和同一条边上相邻的点，即在矩形的顶点直线走到**最近的**其他矩形边上的情况。

这个时候你可能会问，为什么只考虑在矩形顶点转弯的情况呢？如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hrdzv8rk.png)

$EF$，显然是等价于 $C_1G$ 的，即平行线间垂线段长度相等。那么，我们仅考虑矩形顶点的情况一定能把所有最短路径考虑到。

所以，我们对于每个顶点暴力找距离该点最近的矩形，在其边上建立新点，连边，然后再对于每个矩形边上相邻的点连边即可。点的量级：$O(n)$。

接下来就是实现的难度。

首先，对于每个矩形，肯定需要存储四个顶点和四条边上的点，那么可以这样储存：

```cpp
struct node {
	point top_left, lower_left, top_right, lower_right;
	/*
	tl --1--- tr
	|**********|
	3**********4
	|**********|
	ll --2--- lr
	*/
	vector<point> edge[5];
}s[N];
```

接着就是连边：

对于每个顶点及起点和终点，枚举四个方向，接着枚举 $n$ 个矩形，找到按这个方向走距离最近的一个矩形。

这里我编写了一个函数，返回从一个点到一个矩形按 $4$ 种方向走的距离。

```cpp
// 注：这个函数写在结构体里
int check (point x, int dec) {
	if(dec == 1) { 	// This rectangles is below the given point
		if(top_left.y <= x.y && top_left.x <= x.x && top_right.x >= x.x) return x.y - top_left.y;
		return -1;
	} else if(dec == 2) { // This rectangles is over the given point
		if(lower_left.y >= x.y && lower_left.x <= x.x && lower_right.x >= x.x) return lower_left.y - x.y;
		return -1;
	} else if(dec == 3) { // This rectangles is on the left of the given point
		if(top_right.x <= x.x && top_right.y >= x.y && lower_right.y <= x.y) return x.x - top_right.x;
		return -1;
	} else { // This rectangles is on the right of the given point
		if(top_left.x >= x.x && top_left.y >= x.y && lower_left.y <= x.y) return top_left.x - x.x;
		return -1;
	}
}
```

如果到不了会返回 $-1$。

接着按上文所述模拟即可：

```cpp
void find_near (point x, int dec) {
	// 1 : Down 2 : Up  3 : Left 4 : Right
	int pos = -1, minn = inf;
	for (int i = 1; i <= n; i ++) {
		int len = s[i].check(x, dec);
		if(len != -1) {
			if(len < minn) minn = len, pos = i;
		}
	}
	if(pos == -1) return;
	point y;
	if(dec == 1) y = {x.x, x.y - minn}, s[pos].edge[1].push_back(y);
	if(dec == 2) y = {x.x, x.y + minn}, s[pos].edge[2].push_back(y);
	if(dec == 3) y = {x.x - minn, x.y}, s[pos].edge[4].push_back(y);
	if(dec == 4) y = {x.x + minn, x.y}, s[pos].edge[3].push_back(y);
	graph::addedge(id(x), id(y), minn);
}
```

接着，考虑矩形边内连边，排序去重后模拟即可：

```cpp
void in_squar(int i) { // 表示第 i 个矩形
	for (int k = 1; k <= 4; k ++) {
		vector<point> &f = s[i].edge[k];
		sort(f.begin(), f.end());
		f.erase(unique(f.begin(), f.end()), f.end());
		for (int j = 0; j < (int)f.size() - 1; j ++) {
			point x = f[j], y = f[j + 1];
			graph::addedge(id(x), id(y), getdis(x, y));
		}
	}
}
```

处理完后，跑 dijkstra。

但是答案还有以下一种**特殊情况**：起点和终点在同一条直线上且直线上不存在矩形，此时直接输出两点间的距离即可。

实现如下：

```cpp
if(st.x == ed.x || st.y == ed.y) {
	bool flag = 0;
	if(st > ed) swap(st, ed);
	for (int i = 1; i <= n; i ++) {
		if(st.x == ed.x) {
			flag |= (s[i].top_left.x <= st.x && s[i].top_right.x >= st.x && s[i].top_left.y >= st.y && s[i].lower_left.y <= ed.y);
		} else {
			flag |= (s[i].top_left.y >= st.y && s[i].lower_left.y <= st.y && s[i].top_left.x >= st.x && s[i].top_right.x <= ed.x);
		}
	}
	if(flag) {
		if(graph::dis[id(ed)] != inf)cout << graph::dis[id(ed)] << endl;
		else cout << "No Path" << endl;
	} else cout << getdis(st, ed) << endl;
	return;
}
```

否则直接输出，
```cpp
if(graph::dis[id(ed)] != inf) cout << graph::dis[id(ed)] << endl;
else cout << "No Path" << endl;
```

然后这题就愉快地结束了……吗？

注意到**多测**，记得**清空**：

```cpp
void init () {
	for (int i = 1; i <= point_cnt; i ++) graph::g[i].clear();
	for (int i = 1; i <= n; i ++) {
		for (int d = 1; d <= 4; d ++) 
			s[i].edge[d].clear();
	}
	_id.clear();
	point_cnt = 0;
}
```

注：这里我用 map 将点映射为一个数值，方便存储。

```cpp
map<point, int> _id;
int point_cnt;
int id (point x) {
	if(!_id[x]) _id[x] = ++ point_cnt;
	return _id[x];
} 
```

以下是主函数：

```cpp
void solve () {
	init();
	point st, ed;
	cin >> st.x >> st.y >> ed.x >> ed.y;
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		int x_1, y_1, x_2, y_2;
		cin >> x_1 >> y_1 >> x_2 >> y_2;
		if(x_1 > x_2) swap(x_1, x_2);
		if(y_1 > y_2) swap(y_1, y_2);
		s[i].lower_left = {x_1, y_1}, s[i].top_right = {x_2, y_2}, s[i].top_left = {x_1, y_2}, s[i].lower_right = {x_2, y_1};
		s[i].edge[1].push_back(s[i].top_left), s[i].edge[1].push_back(s[i].top_right);
		s[i].edge[2].push_back(s[i].lower_left), s[i].edge[2].push_back(s[i].lower_right);
		s[i].edge[3].push_back(s[i].top_left), s[i].edge[3].push_back(s[i].lower_left);
		s[i].edge[4].push_back(s[i].top_right), s[i].edge[4].push_back(s[i].lower_right);
	}
	for (int i = 1; i <= n; i ++) {
		for (int d = 1; d <= 4; d ++) 
			make_graph::find_near(s[i].top_left, d), make_graph::find_near(s[i].lower_left, d), make_graph::find_near(s[i].top_right, d), make_graph::find_near(s[i].lower_right, d);
	}
	for (int d = 1; d <= 4; d ++) make_graph::find_near(st, d), make_graph::find_near(ed, d);
	for (int i = 1; i <= n; i ++) make_graph::in_squar(i);
	id(st), id(ed);
	graph::dijkstra(id(st));
	if(st.x == ed.x || st.y == ed.y) {
		bool flag = 0;
		if(st > ed) swap(st, ed);
		for (int i = 1; i <= n; i ++) {
			if(st.x == ed.x) {
				flag |= (s[i].top_left.x <= st.x && s[i].top_right.x >= st.x && s[i].top_left.y >= st.y && s[i].lower_left.y <= ed.y);
			} else {
				flag |= (s[i].top_left.y >= st.y && s[i].lower_left.y <= st.y && s[i].top_left.x >= st.x && s[i].top_right.x <= ed.x);
			}
		}
		if(flag) {
			if(graph::dis[id(ed)] != inf)cout << graph::dis[id(ed)] << endl;
			else cout << "No Path" << endl;
		} else cout << getdis(st, ed) << endl;
		return;
	}
	if(graph::dis[id(ed)] != inf) cout << graph::dis[id(ed)] << endl;
	else cout << "No Path" << endl;
}
```

---

## 作者：cryozwq (赞：3)

这题为什么 $n\le 10^3$？

显然就是我们考虑在一个矩形上走到另外一个矩形上，那么必然要不是从一个顶点开始走到边上或者顶点，要不就是边上走到一个顶点，把所有这些关键点抓出来跑最短路即可。

具体来说，对于一个矩形的每个顶点可以朝两个方向走，对于每个顶点，我们需要找到这每个方向走第一个矩形是谁，也就容易知道会走到这个矩形哪条边的具体某个位置，在这两个点之间连边。把所有这些位置抓出来，然后把一个矩形上的所有相邻且可达的点连上边，最后跑最短路即可。（两条边之间的边权就是曼哈顿距离）

比如对于下面这个图，红色表示需要连的边，绿色表示需要建的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/m58ifk8h.png)

这个暴力做是 $n^2$ 的，也可以过。但是，我们当然要精益求精对不对？容易发现这个问题事实上可以简单扫描线，就是扫过去的时候维护一个线段树，维护每个位置当前被哪个矩形覆盖。一个实现细节是，只用写从左到右的扫描线，然后每次翻转坐标系即可。

代码（并没有可读性）

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=5e5+5;
int T;
int data[maxn],dt;
int n;
int tax[maxn],tay[maxn],tbx[maxn],tby[maxn];
int ax[maxn],ay[maxn],bx[maxn],by[maxn];
int xs,ys,xt,yt;
int tot;
int id[maxn][4],idt;
bool vis[maxn];
ll dis[maxn];
struct pr{
	ll w;
	int u;
};
inline bool operator <(pr a,pr b){
	return a.w>b.w;
}
priority_queue<pr>q;
struct Edge{
	int v;
	ll w;
	int nxt;
}e[maxn];
int h[maxn],cnt;
void add(int u,int v,ll w){
//	 cout<<u<<" "<<v<<" "<<w<<endl;
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=h[u];
	h[u]=cnt;
	swap(u,v);
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=h[u];
	h[u]=cnt;
}
const ll infll=1e18;
void dijkstra(int s){
	for(int i=1;i<=idt;i++){
		dis[i]=infll;
		vis[i]=0;
	}
	dis[s]=0;
	q.push((pr){0,s});
	while(q.size()){
		pr now=q.top();
		int u=now.u;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=h[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].w){
				dis[v]=dis[u]+e[i].w;
				q.push((pr){dis[v],v});
			}
		}
	}
} 
int lz[maxn];
#define ls 2*i
#define rs 2*i+1
int al[maxn];
void push_up(int i){
	if(al[ls]==al[rs])al[i]=al[ls];
	else al[i]=-1;
}
void build(int i,int l,int r){
	lz[i]=-1;
	al[i]=0;
	if(l==r)return ;
	int mid=(l+r)/2;
	build(ls,l,mid);
	build(rs,mid+1,r);
}
void push_down(int i){
	if(lz[i]==-1)return ;
	al[ls]=al[rs]=lz[i];
	lz[ls]=lz[rs]=lz[i];	
	lz[i]=-1;
}
void update(int i,int l,int r,int u,int v,int k){
	if(u<=l&&r<=v){
		al[i]=k;
		lz[i]=k;
		return ;
	}
	push_down(i);
	int mid=(l+r)/2;
	if(u<=mid)update(ls,l,mid,u,v,k);
	if(mid+1<=v)update(rs,mid+1,r,u,v,k);
	push_up(i);
}
int query(int i,int l,int r,int x){
	if(l==r)return al[i];
	push_down(i);
	int mid=(l+r)/2;
	if(x<=mid)return query(ls,l,mid,x);
	else return query(rs,mid+1,r,x);
}
map<int,int>mp[maxn];
struct node{
	int tp;
	int l,r,x;
};
vector<node>G[maxn];
int m1[maxn],m2[maxn];
void solve(){
	build(1,1,dt);
	for(int i=1;i<=tot;i++)m1[i]=m2[i]=0;
	for(int i=1;i<=dt;i++)G[i].clear();
	for(int i=1;i<=tot;i++){
		G[ax[i]].push_back((node){2,ay[i],by[i],i});
		G[bx[i]].push_back((node){1,ay[i],by[i],i});
	}
	for(int i=1;i<=dt;i++){
		for(auto v:G[i]){
			if(v.tp==1){
				// cout<<"UPDATE"<<v.l<<" "<<v.r<<" "<<v.x<<endl;
				update(1,1,dt,v.l,v.r,v.x);
			}
			if(v.tp==2){
				m1[v.x]=query(1,1,dt,v.l);
				m2[v.x]=query(1,1,dt,v.r);
			}
		}
	}
}
/*
12
03
*/
struct pit{
	int x,y;
}cr[maxn];
vector<pit>ptt[maxn]; 
int ct;
inline bool cmpx(pit a,pit b){
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
inline bool cmpy(pit a,pit b){
	if(a.y==b.y)return a.x<b.x;
	return a.y<b.y;
}
bool tag;
void lik(int ax,int ay,int bx,int by,int i=0,int j=0){
//	cout<<ax<<" "<<ay<<" "<<bx<<" "<<by<<endl;
	if(ax!=bx&&ay!=by)return ;
	if(!mp[ax][ay]){
		mp[ax][ay]=++idt;
		if(!tag)ptt[i].push_back((pit){ax,ay});
		else ptt[i].push_back((pit){ay,ax});
	}
	int A=mp[ax][ay];
	if(!mp[bx][by]){
		mp[bx][by]=++idt;
		if(!tag)ptt[j].push_back((pit){bx,by});
		else ptt[j].push_back((pit){by,bx});
	}
	int B=mp[bx][by];
	add(A,B,1ll*abs(data[bx]-data[ax])+1ll*abs(data[by]-data[ay]));
}
void link(int i,int j,int op){
	if(!j)return ;
	if(op==0){
		lik(ax[i],ay[i],bx[j],ay[i],i,j);
	}
	if(op==1){ 
		lik(ax[i],by[i],bx[j],by[i],i,j);
	}
	if(op==2){
		lik(bx[i],by[i],ax[j],by[i],i,j); 
	}
	if(op==3){
		lik(bx[i],ay[i],ax[j],ay[i],i,j);
	}
}
#define mk make_pair
#define fr first
#define sc second
vector<pair<pair<int,int>,int> >vc;
void filpxy(){
	tag^=1;
	vc.clear();
	for(int i=1;i<=dt;i++){
	for(auto vv:mp[i]){
//		cout<<i<<"-"<<vv.fr<<endl;
		vc.push_back(mk(mk(i,vv.fr),vv.sc));
	}
	}
	for(int i=1;i<=dt;i++)mp[i].clear();
	for(auto v:vc){
		mp[v.fr.sc][v.fr.fr]=v.sc;
	} 
	for(int i=1;i<=tot;i++){
		swap(ax[i],ay[i]);
		swap(bx[i],by[i]);
	}
}
void filpx(){
	for(int i=1;i<=tot;i++){
		ax[i]=dt-ax[i]+1;
		bx[i]=dt-bx[i]+1;
		swap(ax[i],bx[i]);
	}
}
int main(){ 
	scanf("%d",&T);
	while(T--){
		tag=0;
		ct=0;
		cnt=0;
		for(int i=1;i<=tot;i++)ptt[i].clear();
		for(int i=0;i<=dt;i++)mp[i].clear();
		for(int i=1;i<=idt;i++)h[i]=0;
		idt=0;
		tot=0;
		dt=0;
		scanf("%d%d%d%d",&xs,&ys,&xt,&yt);
		data[++dt]=xs;data[++dt]=ys;data[++dt]=xt;data[++dt]=yt;
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d%d%d%d",&ax[i],&ay[i],&bx[i],&by[i]);
			if(ax[i]>bx[i])swap(ax[i],bx[i]);
			if(ay[i]>by[i])swap(ay[i],by[i]);
			data[++dt]=ax[i];
			data[++dt]=ay[i];
			data[++dt]=bx[i];
			data[++dt]=by[i];
		} 
		sort(data+1,data+dt+1);
		dt=unique(data+1,data+dt+1)-data-1;
		tax[n+1]=tbx[n+1]=xs;
		tay[n+1]=tby[n+1]=ys;
		tax[n+2]=tbx[n+2]=xt;
		tay[n+2]=tby[n+2]=yt;
		xs=lower_bound(data+1,data+dt+1,xs)-data;
		ys=lower_bound(data+1,data+dt+1,ys)-data;
		xt=lower_bound(data+1,data+dt+1,xt)-data;
		yt=lower_bound(data+1,data+dt+1,yt)-data;
		for(int i=1;i<=n;i++){
			ax[i]=lower_bound(data+1,data+dt+1,ax[i])-data;
			ay[i]=lower_bound(data+1,data+dt+1,ay[i])-data;
			bx[i]=lower_bound(data+1,data+dt+1,bx[i])-data;
			by[i]=lower_bound(data+1,data+dt+1,by[i])-data;
			mp[ax[i]][ay[i]]=++idt;  
			mp[ax[i]][by[i]]=++idt;
			mp[bx[i]][ay[i]]=++idt;  
			mp[bx[i]][by[i]]=++idt;
			ptt[i].push_back((pit){ax[i],ay[i]});
			ptt[i].push_back((pit){bx[i],ay[i]});
			ptt[i].push_back((pit){ax[i],by[i]});
			ptt[i].push_back((pit){bx[i],by[i]});
		}
		tot=n+2; 
		ax[n+1]=bx[n+1]=xs;
		ay[n+1]=by[n+1]=ys;
		ax[n+2]=bx[n+2]=xt;
		ay[n+2]=by[n+2]=yt;  
		mp[xs][ys]=++idt;  
		mp[xt][yt]=++idt;
		solve();
		for(int i=1;i<=tot;i++){
//			cout<<i<<" "<<m1[i]<<" "<<m2[i]<<endl;
			link(i,m1[i],0);
			link(i,m2[i],1);		
		}
		filpx();
		solve();
		filpx();
		for(int i=1;i<=tot;i++){
			// cout<<i<<" "<<m1[i]<<" "<<m2[i]<<endl;
			link(i,m1[i],3);
			link(i,m2[i],2);		
		}
		filpxy();
		solve();
		for(int i=1;i<=tot;i++){
			// cout<<i<<" "<<m1[i]<<" "<<m2[i]<<endl;
			link(i,m1[i],0);
			link(i,m2[i],1);		
		}
		filpxy();
		filpxy();
		filpx();
		solve();
		filpx();
		for(int i=1;i<=tot;i++){ 
			link(i,m1[i],3);
			link(i,m2[i],2);	
		}
		filpxy(); 
//		cout<<"trash!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
		for(int id=1;id<=tot;id++){
			ct=0;
			for(auto v:ptt[id]){
				if(v.x==ax[id]||v.x==bx[id])cr[++ct]=v;
			}
			sort(cr+1,cr+ct+1,cmpx);
			for(int i=1;i<=ct;i++){
				if(i!=1&&cr[i-1].x==cr[i].x)lik(cr[i].x,cr[i].y,cr[i-1].x,cr[i-1].y);
				if(i!=ct&&cr[i+1].x==cr[i].x)lik(cr[i].x,cr[i].y,cr[i+1].x,cr[i+1].y);
			}
			ct=0;
			for(auto v:ptt[id]){
				if(v.y==ay[id]||v.y==by[id])cr[++ct]=v;
			}
			sort(cr+1,cr+ct+1,cmpy);
			for(int i=1;i<=ct;i++){
				if(i!=1&&cr[i-1].y==cr[i].y)lik(cr[i].x,cr[i].y,cr[i-1].x,cr[i-1].y);
				if(i!=ct&&cr[i+1].y==cr[i].y)lik(cr[i].x,cr[i].y,cr[i+1].x,cr[i+1].y);
			}
		} 
//		cout<<mp[xs][ys]<<" "<<mp[xt][yt]<<endl;
		dijkstra(mp[xs][ys]);
		if(dis[mp[xt][yt]]>=infll)printf("No Path\n");
		else printf("%lld\n",dis[mp[xt][yt]]);
		// return 0;
	}
	return 0;
}
```

---

## 作者：Zechariah (赞：3)

打了一中午。。。  
感觉自己打的是纯暴力  
首先离散化，重新给所有点标上坐标  
对于蜂巢边缘的每一个点，向他四周最近的点（蜂巢边缘的点）连边  
然后是起点终点连边  
然后跑最短路，就做完了，主要是细节问题，模拟建图，很耗时间  
~~下面是我又臭又长的代码~~
```cpp
#include <bits/stdc++.h>
#define jh(x,y) x^=y^=x^=y
#define loc(x,y) (x-1)*totl+y
using namespace std;
const int N = 2e3 + 10;
inline int read()
{
	register int num = 0;
	register char ch;
	register bool flag = false;
	while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r');
	if (ch == '-')flag = true; else num = ch ^ 48;
	while ((ch = getchar()) != ' '&&ch != '\n'&&ch != '\r'&&~ch)
		num = (num << 1) + (num << 3) + (ch ^ 48);
	if (flag)return -num; return num;
}
int sx, sy, ex, ey, hang[10 * N], lie[10 * N], toth, totl;
struct Node {
	int x1, y1, x2, y2;
	inline Node() { x1 = y1 = x2 = y2 = 0; }
	inline Node(register int a, register int b, register int c, register int d) { x1 = a, y1 = b, x2 = c, y2 = d; }
}fc[N];
inline void change(register int &x, register int &y)
{
	x = lower_bound(hang + 1, hang + toth + 1, x) - hang;
	y = lower_bound(lie + 1, lie + totl + 1, y) - lie;
}
bool  in[N][N];
int mp[N][N], nt[N*N], b[N*N], p[N*N], w[N*N], num;
inline void add(register int x, register int y, register int z)
{
	if (z == 0)return;
	b[++num] = y; w[num] = z;
	nt[num] = p[x]; p[x] = num;
	b[++num] = x; w[num] = z;
	nt[num] = p[y]; p[y] = num;
}
inline void update(register int x, register int y)
{
	for (register int i = x + 1; i <= toth; ++i)
		if (mp[i][y])
		{
			if (mp[i][y] == mp[x][y] && y != fc[mp[x][y]].y1&&y != fc[mp[x][y]].y2)break;
			add(loc(x, y), loc(i, y), hang[i] - hang[x]);
			break;
		}
	for (register int i = y + 1; i <= totl; ++i)
		if (mp[x][i])
		{
			if (mp[x][i] == mp[x][y] && x != fc[mp[x][y]].x1&&x != fc[mp[x][y]].x2)break;
			add(loc(x, y), loc(x, i), lie[i] - lie[y]);
			break;
		}
}
inline void ud(register int x, register int y)
{
	for (register int i = x + 1; i <= toth; ++i)if (mp[i][y]) { add(loc(x, y), loc(i, y), hang[i] - hang[x]); break; }
	for (register int i = x - 1; i >= 1; --i)if (mp[i][y]) { add(loc(x, y), loc(i, y), hang[x] - hang[i]); break; }
	for (register int i = y + 1; i <= totl; ++i)if (mp[x][i]) { add(loc(x, y), loc(x, i), lie[i] - lie[y]); break; }
	for (register int i = y - 1; i >= 1; --i)if (mp[x][i]) { add(loc(x, y), loc(x, i), lie[y] - lie[i]); break; }
}
int dist[N*N], top;
bool flag[N*N];
struct node {
	int bh, dist;
	inline node() { bh = dist = 0; }
	inline node(register int a, register int b) { bh = a, dist = b; }
}q[N*N];
inline void shift()
{
	register int i = 1, j = 2;
	while (j <= top)
	{
		if (j < top&&q[j + 1].dist < q[j].dist)++j;
		if (q[i].dist > q[j].dist)
			jh(q[i].bh, q[j].bh), jh(q[i].dist, q[j].dist);
		i = j, j = i << 1;
	}
}
inline void shift2()
{
	register int i = top, j = top >> 1;
	while (i > 1)
	{
		if (q[i].dist >= q[j].dist)break;
		jh(q[i].bh, q[j].bh);
		jh(q[i].dist, q[j].dist);
		i = j, j = i >> 1;
	}
}
inline int dijkstra(register int x)
{
	memset(dist, 63, sizeof(dist));
	memset(flag, 0, sizeof(flag));
	q[top = 1] = node(x, dist[x] = 0);
	while (top)
	{
		register node k = q[1]; q[1] = q[top--]; shift();
		if (!flag[k.bh])
		{
			flag[k.bh] = true;
			register int e = p[k.bh];
			while (e)
			{
				register int kk = b[e];
				if (dist[kk] - w[e] > dist[k.bh])
					dist[kk] = dist[k.bh] + w[e];
				q[++top] = node(kk, dist[kk]); shift2();
				e = nt[e];
			}
		}
	}
	return dist[loc(ex, ey)];
}


int main()
{
	register int t = read();
	while (t--)
	{
		num = 0, toth = totl = 0; memset(p, 0, sizeof(p));
		memset(mp, 0, sizeof(mp)); memset(in, 0, sizeof(in));
		hang[++toth] = sx = read(), lie[++totl] = sy = read();
		hang[++toth] = ex = read(), lie[++totl] = ey = read();
		register int n = read();
		for (register int i = 1; i <= n; ++i)
		{
			register int x1 = read(), y1 = read(), x2 = read(), y2 = read();
			if (x1 > x2)jh(x1, x2);
			if (y1 > y2)jh(y1, y2);
			hang[++toth] = x1, hang[++toth] = x2;
			lie[++totl] = y1, lie[++totl] = y2;
			fc[i] = Node(x1, y1, x2, y2);
		}
		sort(hang + 1, hang + toth + 1);
		sort(lie + 1, lie + totl + 1);
		toth = unique(hang + 1, hang + toth + 1) - hang - 1;
		totl = unique(lie + 1, lie + totl + 1) - lie - 1;
		change(sx, sy); change(ex, ey);
		for (register int i = 1; i <= n; ++i)
			change(fc[i].x1, fc[i].y1),
			change(fc[i].x2, fc[i].y2);
		for (register int i = 1; i <= n; ++i)
			for (register int x = fc[i].x1; x <= fc[i].x2; ++x)
				for (register int y = fc[i].y1; y <= fc[i].y2; ++y)
					mp[x][y] = i;
		for (register int i = 1; i <= n; ++i)
		{
			for (register int x = fc[i].x1 + 1; x < fc[i].x2; ++x)update(x, fc[i].y1), update(x, fc[i].y2);
			for (register int y = fc[i].y1; y <= fc[i].y2; ++y)update(fc[i].x1, y), update(fc[i].x2, y);
		}
		mp[sx][sy] = mp[ex][ey] = 1;
		ud(sx, sy); ud(ex, ey);
		register int ans = dijkstra(loc(sx, sy));
		if (ans < 1e9)printf("%d\n", ans);
		else printf("No Path\n");
	}
	return 0;
}

```

---

## 作者：rainbow_cat (赞：0)

印象很深的一道题，难在码量和建模，跑最短路反而是次要的，题解中间会穿插代码片段。    
首先肯定要对所有点作离散化，然后记录蜂巢的每一条边方便以后查询，并在最短路图上连接两点。
```cpp
cin>>stx>>sty>>edx>>edy>>n;
if(!mp[{stx,sty}])mp[{stx,sty}]=++pidx;
if(!mp[{edx,edy}])mp[{edx,edy}]=++pidx;	
for(int i=1;i<=n;i++)
{
	cin>>ax[i]>>ay[i]>>bx[i]>>by[i];
	if(ax[i]>bx[i])swap(ax[i],bx[i]);
	if(ay[i]<by[i])swap(ay[i],by[i]);
	yl[++idy]={by[i],ay[i],ax[i]};
	yl[++idy]={by[i],ay[i],bx[i]};
	xl[++idx]={ax[i],bx[i],ay[i]};
	xl[++idx]={ax[i],bx[i],by[i]};
	if(!mp[{ax[i],ay[i]}])mp[{ax[i],ay[i]}]=++pidx;
	if(!mp[{ax[i],by[i]}])mp[{ax[i],by[i]}]=++pidx;
	if(!mp[{bx[i],ay[i]}])mp[{bx[i],ay[i]}]=++pidx;
	if(!mp[{bx[i],by[i]}])mp[{bx[i],by[i]}]=++pidx;
//			cout<<ax[i]<<' '<<ay[i]<<' '<<mp[{ax[i],ay[i]}]<<' '<<pidx<<' '<<'\n';
	merge(mp[{ax[i],ay[i]}],mp[{bx[i],ay[i]}],bx[i]-ax[i]);
	merge(mp[{bx[i],ay[i]}],mp[{bx[i],by[i]}],ay[i]-by[i]);
	merge(mp[{bx[i],by[i]}],mp[{ax[i],by[i]}],bx[i]-ax[i]);
	merge(mp[{ax[i],by[i]}],mp[{ax[i],ay[i]}],ay[i]-by[i]);
}
//		cout<<eidx<<'\n';
for(int i=1;i<=idx;i++)xlv[i].clear();
for(int i=1;i<=idy;i++)ylv[i].clear();
sort(xl+1,xl+idx+1,cmp),sort(yl+1,yl+idy+1,cmp);
```
接下来考虑蜂巢之间如何连边。   
对于每个蜂巢的四个顶点和起点、终点，向四个方向飞行相交在别的蜂巢上的交点连边。   
同时，这些交点要和对应蜂巢边的两端连接。
这句话可能有些难以理解，看图更加清晰。   
![](https://cdn.luogu.com.cn/upload/image_hosting/stxvei2p.png)    
假如 $n \le 10^5$ 那就需要用扫描线，$n \le 10^3$ 可以直接枚举。   
```cpp
void uget(int x,int y)//向上
{
	int pos=0;
	for(int j=1;j<=idx;j++)
	{
		if(xl[j].st<=x&&x<=xl[j].ed&&xl[j].pos>y)
		{
			pos=j;
			break;
		}
	}
	if(!mp[{x,xl[pos].pos}])mp[{x,xl[pos].pos}]=++pidx;
	xlv[pos].insert({x,mp[{x,xl[pos].pos}]});
	if(pos)
	{
		merge(mp[{x,xl[pos].pos}],mp[{x,y}],xl[pos].pos-y);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].st,xl[pos].pos}],xl[pos].st-x);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].ed,xl[pos].pos}],xl[pos].ed-x);
	}
}
void dget(int x,int y)//向下
{
	int pos=0;
	for(int j=1;j<=idx;j++)if(xl[j].st<=x&&x<=xl[j].ed&&xl[j].pos<y)pos=j;
	if(!mp[{x,xl[pos].pos}])mp[{x,xl[pos].pos}]=++pidx;
	xlv[pos].insert({x,mp[{x,xl[pos].pos}]});
	if(pos)
	{
		merge(mp[{x,xl[pos].pos}],mp[{x,y}],xl[pos].pos-y);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].st,xl[pos].pos}],xl[pos].st-x);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].ed,xl[pos].pos}],xl[pos].ed-x);
	}
}
void lget(int x,int y)//向左
{
	int pos=0;
	for(int i=1;i<=idy;i++)if(yl[i].st<=y&&y<=yl[i].ed&&yl[i].pos<x)pos=i;
	if(!mp[{yl[pos].pos,y}])mp[{yl[pos].pos,y}]=++pidx;
	ylv[pos].insert({y,mp[{yl[pos].pos,y}]});
	if(pos)
	{
		merge(mp[{yl[pos].pos,y}],mp[{x,y}],yl[pos].pos-x);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].st}],y-yl[pos].st);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].ed}],y-yl[pos].ed);
	}
}
void rget(int x,int y)//向右
{
	int pos=0;
	for(int i=1;i<=idy;i++)
	{
		if(yl[i].st<=y&&y<=yl[i].ed&&yl[i].pos>x)
		{	
			pos=i;
			break;
		}
	}
	if(!mp[{yl[pos].pos,y}])mp[{yl[pos].pos,y}]=++pidx;
	ylv[pos].insert({y,mp[{yl[pos].pos,y}]});
	if(pos)
	{
		merge(mp[{yl[pos].pos,y}],mp[{x,y}],yl[pos].pos-x);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].st}],y-yl[pos].st);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].ed}],y-yl[pos].ed);
	}
}
```
接下来如果直接跑最短路就只有 $30$ 分，我们遗漏了一个细节，加入一条边上有多个交点，他们之间要互相连接。    
这里开一个动态数组记录每条边上的点，按对应坐标排序后，将相邻的连边。   
```cpp
for(int i=1;i<=idx;i++)
{
	pair<int,int>las={0,-1};
	for(auto j:xlv[i])
	{
		if(las.second!=-1)merge(j.second,las.second,j.first-las.first);
		las=j;
	}
}
for(int i=1;i<=idy;i++)
{
	pair<int,int>las={0,-1};
	for(auto j:ylv[i])
	{
		if(las.second!=-1)merge(j.second,las.second,j.first-las.first);
		las=j;
	}
}
```
此时只剩最后一点问题了，对于起点和终点，如果他们之间没有障碍且横竖坐标中有一个相同，则可以直接连边。   
完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,stx,sty,edx,edy,idx,idy,eidx,pidx,ax[2010],ay[2010],bx[2010],by[2010],elast[100010],dis[100010];
bool vis[100010];
struct edge{int st,ed,pos;}xl[200010],yl[200010];
struct edg{int x,y,z,pre;}e[100010];
struct node{int u,dis;};
bool cmp(edge x,edge y){return x.pos<y.pos;}
set<pair<int,int>>xlv[200010],ylv[200010];
map<pair<int,int>,bool>flag;
void merge(int x,int y,int z)
{
	if(flag[{x,y}]||x==y)return;
	e[++eidx]={x,y,abs(z),elast[x]};
	flag[{x,y}]=1;
	elast[x]=eidx;
	e[++eidx]={y,x,abs(z),elast[y]};
	flag[{y,x}]=1;
	elast[y]=eidx;
}
map<pair<int,int>,int>mp;
bool operator < (node x,node y){return x.dis>y.dis;}
priority_queue<node>q;
void uget(int x,int y)
{
	int pos=0;
	for(int j=1;j<=idx;j++)
	{
		if(xl[j].st<=x&&x<=xl[j].ed&&xl[j].pos>y)
		{
			pos=j;
			break;
		}
	}
	if(!mp[{x,xl[pos].pos}])mp[{x,xl[pos].pos}]=++pidx;
	xlv[pos].insert({x,mp[{x,xl[pos].pos}]});
	if(pos)
	{
		merge(mp[{x,xl[pos].pos}],mp[{x,y}],xl[pos].pos-y);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].st,xl[pos].pos}],xl[pos].st-x);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].ed,xl[pos].pos}],xl[pos].ed-x);
	}
}
void dget(int x,int y)
{
	int pos=0;
	for(int j=1;j<=idx;j++)if(xl[j].st<=x&&x<=xl[j].ed&&xl[j].pos<y)pos=j;
	if(!mp[{x,xl[pos].pos}])mp[{x,xl[pos].pos}]=++pidx;
	xlv[pos].insert({x,mp[{x,xl[pos].pos}]});
	if(pos)
	{
		merge(mp[{x,xl[pos].pos}],mp[{x,y}],xl[pos].pos-y);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].st,xl[pos].pos}],xl[pos].st-x);
		merge(mp[{x,xl[pos].pos}],mp[{xl[pos].ed,xl[pos].pos}],xl[pos].ed-x);
	}
}
void lget(int x,int y)
{
	int pos=0;
	for(int i=1;i<=idy;i++)if(yl[i].st<=y&&y<=yl[i].ed&&yl[i].pos<x)pos=i;
	if(!mp[{yl[pos].pos,y}])mp[{yl[pos].pos,y}]=++pidx;
	ylv[pos].insert({y,mp[{yl[pos].pos,y}]});
	if(pos)
	{
		merge(mp[{yl[pos].pos,y}],mp[{x,y}],yl[pos].pos-x);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].st}],y-yl[pos].st);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].ed}],y-yl[pos].ed);
	}
}
void rget(int x,int y)
{
	int pos=0;
	for(int i=1;i<=idy;i++)
	{
		if(yl[i].st<=y&&y<=yl[i].ed&&yl[i].pos>x)
		{	
			pos=i;
			break;
		}
	}
	if(!mp[{yl[pos].pos,y}])mp[{yl[pos].pos,y}]=++pidx;
	ylv[pos].insert({y,mp[{yl[pos].pos,y}]});
	if(pos)
	{
		merge(mp[{yl[pos].pos,y}],mp[{x,y}],yl[pos].pos-x);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].st}],y-yl[pos].st);
		merge(mp[{yl[pos].pos,y}],mp[{yl[pos].pos,yl[pos].ed}],y-yl[pos].ed);
	}
}
void dijkstra()
{
	q.push({mp[{stx,sty}],0});
	dis[mp[{stx,sty}]]=0;
	while(q.size())
	{
		int u=q.top().u;
		q.pop();
		if(vis[u])continue;
		vis[u]=0;
		for(int i=elast[u];i;i=e[i].pre)
		{
			if(dis[e[i].y]>dis[u]+e[i].z)
			{
				dis[e[i].y]=dis[u]+e[i].z;
				q.push({e[i].y,dis[e[i].y]});
			}
		}
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--)
	{
		q=priority_queue<node>();
		mp.clear();
		flag.clear();
		memset(elast,0,sizeof elast);
		memset(vis,0,sizeof vis);
		memset(dis,0x7f,sizeof dis);
		memset(e,0,sizeof e);
		memset(xl,0,sizeof xl);
		memset(yl,0,sizeof yl);
		idx=idy=eidx=pidx=0;
		cin>>stx>>sty>>edx>>edy>>n;
		if(!mp[{stx,sty}])mp[{stx,sty}]=++pidx;
		if(!mp[{edx,edy}])mp[{edx,edy}]=++pidx;	
		for(int i=1;i<=n;i++)
		{
			cin>>ax[i]>>ay[i]>>bx[i]>>by[i];
			if(ax[i]>bx[i])swap(ax[i],bx[i]);
			if(ay[i]<by[i])swap(ay[i],by[i]);
			yl[++idy]={by[i],ay[i],ax[i]};
			yl[++idy]={by[i],ay[i],bx[i]};
			xl[++idx]={ax[i],bx[i],ay[i]};
			xl[++idx]={ax[i],bx[i],by[i]};
			if(!mp[{ax[i],ay[i]}])mp[{ax[i],ay[i]}]=++pidx;
			if(!mp[{ax[i],by[i]}])mp[{ax[i],by[i]}]=++pidx;
			if(!mp[{bx[i],ay[i]}])mp[{bx[i],ay[i]}]=++pidx;
			if(!mp[{bx[i],by[i]}])mp[{bx[i],by[i]}]=++pidx;
//			cout<<ax[i]<<' '<<ay[i]<<' '<<mp[{ax[i],ay[i]}]<<' '<<pidx<<' '<<'\n';
			merge(mp[{ax[i],ay[i]}],mp[{bx[i],ay[i]}],bx[i]-ax[i]);
			merge(mp[{bx[i],ay[i]}],mp[{bx[i],by[i]}],ay[i]-by[i]);
			merge(mp[{bx[i],by[i]}],mp[{ax[i],by[i]}],bx[i]-ax[i]);
			merge(mp[{ax[i],by[i]}],mp[{ax[i],ay[i]}],ay[i]-by[i]);
		}
//		cout<<eidx<<'\n';
		for(int i=1;i<=idx;i++)xlv[i].clear();
		for(int i=1;i<=idy;i++)ylv[i].clear();
		sort(xl+1,xl+idx+1,cmp),sort(yl+1,yl+idy+1,cmp);
		if(stx==edx)
		{
			bool flag=1;
			for(int i=1;i<=idy;i++)
			{
				if(xl[i].st<=stx&&stx<=xl[i].ed&&min(sty,edy)<=xl[i].pos&&xl[i].pos<=max(sty,edy))flag=0;
			}
			if(flag)merge(mp[{stx,sty}],mp[{edx,edy}],sty-edy);
		}
		if(sty==edy)
		{
			bool flag=1;
			for(int i=1;i<=idx;i++)
			{
				if(yl[i].st<=sty&&sty<=yl[i].ed&&min(stx,edx)<=yl[i].pos&&yl[i].pos<=max(stx,edx))flag=0;
			}
			if(flag)merge(mp[{stx,sty}],mp[{edx,edy}],stx-edx);
		}
		for(int i=1;i<=n;i++)
		{
			uget(ax[i],ay[i]),lget(ax[i],ay[i]);
			uget(bx[i],ay[i]),rget(bx[i],ay[i]);
			dget(ax[i],by[i]),lget(ax[i],by[i]);
			dget(bx[i],by[i]),rget(bx[i],by[i]);
		}
		uget(stx,sty),dget(stx,sty),lget(stx,sty),rget(stx,sty);
		uget(edx,edy),dget(edx,edy),lget(edx,edy),rget(edx,edy);
		for(int i=1;i<=idx;i++)
		{
			pair<int,int>las={0,-1};
			for(auto j:xlv[i])
			{
				if(las.second!=-1)merge(j.second,las.second,j.first-las.first);
				las=j;
			}
		}
		for(int i=1;i<=idy;i++)
		{
			pair<int,int>las={0,-1};
			for(auto j:ylv[i])
			{
				if(las.second!=-1)merge(j.second,las.second,j.first-las.first);
				las=j;
			}
		}
		dijkstra();
		if(dis[mp[{edx,edy}]]==0x7f7f7f7f7f7f7f7f)cout<<"No Path";
		else cout<<dis[mp[{edx,edy}]];
		cout<<'\n';
	}
	return 0;
}
```

---


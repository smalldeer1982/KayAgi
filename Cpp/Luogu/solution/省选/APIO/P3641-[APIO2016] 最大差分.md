# [APIO2016] 最大差分

## 题目背景

## 评测方式
以下是本题评测方式，与题面不符时以这里为准。

你的代码中不应该包含 `gap.h` 库。

你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：
```cpp
extern "C" void MinMax(long long,long long,long long*,long long*);
extern "C" long long findGap(int,int);
```

[spj 与交互库](https://www.luogu.com.cn/paste/c4olee2x)

不保证没锅，要是有锅请私信供题人然后 D 死他。

## 题目描述

有 $N$ 个严格递增的非负整数 $a_1, a_2, \dots, a_N$（$0 \leq a_1 < a_2 < \cdots < a_N \leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \leq i \leq N - 1$）里的最大的值。

你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。

你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \leq i \leq N - 1$）中的最大值。

## 实现细节

**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。

### C/C++
你需要包含头文件 `gap.h`。

你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：

- $T$：子任务的编号（$1$ 或者 $2$）
- $N$：序列的长度

你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \leq t$，否则程序将会终止，该测试点计为 $0$ 分。

### Pascal
你需要使用单元 `graderhelperlib`。

你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：

- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）
- $N$：序列的长度（`LongInt` 类型）

你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \leq t$，否则程序将会终止，该测试点计为 $0$ 分。

## 说明/提示

## 限制与约定

对于所有的测试点，有 $2 \leq N \leq 100000$。

每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。

子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \leq \frac{N + 1}{2}$。

子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \leq 3N$，你将得到 70 分，否则将得到 $\dfrac{60}{\sqrt{\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。


# 题解

## 作者：Taduro (赞：15)

这题我UOJ上AC了，来洛谷发题解是为了水社区分。

[uoj#206](http://uoj.ac/problem/206)

#### 子任务1（30分）

就是送的啊，会读题就会做。

先$MinMax(0,1e18,a_1,a_n)$你就知道了$a_1$和$a_n$，之后$MinMax(a_1+1,a_n-1,a_2,a_{n-1})$。。。。

这样问$\frac{n+1}{2}$次你就知道了整个序列。

#### 子任务2（70分）

我们这次还是先问出$a_1$和$a_n$，然后考虑一下答案的最小值，就是中间n-2个数均匀分配。

这时答案最小是$\frac{a_n-a_1}{n-1}$，如果把序列分块，每块大小是$\frac{a_n-a_1}{n-1}$的话，很显然块内不会有答案。

那么我们就可以把每个块都问一遍，答案只会出现在当前块的最小值和上一个有值的块的最大值。

这样的话，第一次讯问对k的贡献是n+1，中间对k的贡献是$n-1+n-2$，意思是问了$n-1$次，出现了$n-2$个点。所以加起来最坏是$3n-2$。

```c++
#include "gap.h"
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
ll a[100011];
long long findGap(int T, int N){
	ll ans=0;int n=N;
if (T==1){
	a[0]=-1; a[n+1]=1LL*1000000000000000010;
	for (int i=1; i<=(n+1)>>1; i++)
		MinMax(a[i-1]+1,a[n-i+2]-1,&a[i],&a[n-i+1]);
	for (int i=1; i<n; i++)
		ans=max(ans,a[i+1]-a[i]);
}
else{
	ll minn,maxn,l,r,k,rl,las=-1;
	MinMax(0,1LL*1000000000000000000,&minn,&maxn);
	k=(maxn-minn)/(n-1); las=minn;
	if ((maxn-minn)%(n-1)) k++;
	for (ll i=minn+1; i<maxn; i+=k){
		rl=min(i+k-1,maxn-1);
		MinMax(i,rl,&l,&r);
		ans=max(ans,l-las);
		if (r>0) las=r;
	}
	ans=max(ans,maxn-las);
}
	return ans;
}
```



---

## 作者：tyccyt (赞：2)

# P3641 [APIO2016] 最大差分

## 关于交互题~

[交互题 - OI Wiki ](https://oi-wiki.org/contest/interaction/)

## 题解

- ### T=1(30pts)

  直接模拟！第一次询问 $a_1,a_n$ 第二次询问 $a_2,a_{n-1}$ 第三次询问 $a_3,a_{n-2}$，以此类推，比较送分

- ### T=2(70分)

  这一部分比较神奇

  我们仍可先确定 $a_1,a_n$ 

  得到了这两个数我们能做什么呢？

  我们可以知道其中有 $n-1$ 段，每段最小为 $\frac{a_n-a_1}{n-1}$ 

  我们可以就此考虑把 $a$ 数组**分成块**

  **那么最大差分就会出现在一个块的末尾与其后面那一块的开头交接之处**

  原因是因为每段最小为 $\frac{a_n-a_1}{n-1}$ 肯定小于等于一块的开头减其后面一块的结尾的差

  不会超过 $3n$ 次，顺利通过此题！！！

---

## 作者：一E孤行 (赞：2)

比较神奇的一个题目，两组子任务没太大关系（

+ 子任务一

需要你询问不超过 $\frac{N+1}{2}$ 次，而每次询问可以找 $2$ 个数，因此可以很自然的想到，我们一开始在整个值域寻找最小和最大，然后每次寻找上次的最小加一和上次的最大减一，这样找到最后就可以找到答案，没什么难度。

+ 子任务二


我们考虑最坏的情况（答案最小）是什么，是整个等差数列在值域内均匀分布，这样我们第一次询问整个序列的最大值和最小值，然后将它分成 $N-1$ 个块，分别进行询问。因为一个块内的最大值和最小值的差一定小于块长，但是在所有两两相邻的数之间的答案又至少是块长，所以块内的数比不可能是答案，因此，答案必然是跨区间的相邻的两个数，我们只用考虑这次查询的最小值和上次查询出来的最大值的差就可以了。

考虑 $k$ 的增长，第一次会提高 $N+1$ ，然后整个中间会提高 $2\times N-3$ ，可以满足题目要求。

注意边界情况。

~~我交了一页半才过（~~

```cpp
#define ll long long
ll max(ll x,ll y) {
    return x > y ? x : y;
}
ll min(ll x,ll y) {
    return x > y ? y : x;
}
#include<algorithm>
extern "C" void MinMax(long long,long long,long long*,long long*);
extern "C" long long findGap(int T,int n) {
    if(T == 1) {
        ll ans=0;
        n-=2;
        ll minn,minlst,maxx,maxlst;
        MinMax(0,1e18,&minlst,&maxlst);
        while(n > 0) {
            n-=2;
            MinMax(minlst+1,maxlst-1,&minn,&maxx);
            ans=max(ans,max(minn-minlst,maxlst-maxx));
            minlst=minn,maxlst=maxx;
        }
        ans=max(ans,maxlst-minlst);
        return ans;
    }
    ll lst,firmin,firma;
    MinMax(0,1e18,&firmin,&firma);
    lst=firmin;
    ll ad=(firma-firmin)/(n-1);
    ll minn,maxx,maxans=    0;
    if((firma-firmin)%(n-1)) ad++;
    for(ll l=firmin+1;l<firma;l+=ad) {
        ll r=min(firma-1,l+ad-1);
        MinMax(l,r,&minn,&maxx);
        if(minn != -1) maxans=max(maxans,minn-lst);
        if(maxx != -1) lst=maxx;
    }
    maxans=max(maxans,firma-lst);
    return maxans;
}

---

## 作者：loveJY (赞：2)

提供一个优秀一点的$Subtask2$套路？

$Subtask1$

满足我们的查询次数不超过序列长的一半上取整

如果我们每次查询能够确定序列的两个位置，这道题就做完了

因为a序列是排好序的，所以我们会发现最大最小值一定是在开头和结尾处

而我们又不存在相同的元素，所以找到开头和结尾的值之后，每次查询$Max-1$和$Min+1$就可以知道次小值和次大值是什么

如此这样做下去，我们就能确定a序列了

会发现n为偶数时最后刚好查完，n为奇数时最后我们还要多一次查出单独的一个数，这也是为什么上取整

$Subtask$

本篇题解的核心思想：最优化剪枝

首先要观察到答案可以初步确定到$(a_n-a_1)/n-1$

因为最坏情况下就是等差数列均匀分散

然后我们可以根据这个初步确定的答案去做出第一次询问：

$(a_1+1,a_1+ans)$

如果我们找到了数，你会发现**不管找到了多少数，他们之间的差分都不可能作为新答案**,因为那个差分一定小于当前设定的最小答案

所以我们把$a_1$设置为$max$值（要保证连续的两个做差），并继续下去

如果我们没有找到数，你会发现**答案一定至少变大了1**

因为下一个数至少是$a_1+ans+1$,而他和$a_1$的差是$ans+1$

所以我们把最小答案设置成ans+1，并且下一次从上次的右端点+1开始查询即可

不过这样的找不到数过程可能会重复多次，最小答案限制也会变大多次，具体实现的细节可以看看代码

注意我们不要多次查询$a_1$和$a_n$

正确性....操作次数严格来讲是和数据有关的，不过最多可以卡到$3
n-1$，再向上就卡不动了

比如：

```cpp
2 6

1 2 3 4 5 7

```

最后说说如何调试本题吧

1. 把题目中给出的两个函数复制粘贴到自己的代码中，然后给$findgap$函数加上自己喜欢的参数
2. 把给出的交互库复制粘贴到代码中，然后调整一下头文件等的位置
3. 编写$findgap$，之后按照交互库里的$main$函数进行输入输出调试即可

AC code:

```cpp


#include<bits/stdc++.h>
#define ll long long
using namespace std;
extern "C" void MinMax(long long, long long, long long *, long long *);

extern "C" long long findGap(int T, int n) {
	ll inf = 1e18;
	ll b_n, b_1,ans=0;
	if(T==1) {
		ll b_2,b_n2;
		MinMax(0,inf,&b_1,&b_n);
		n-=2;
		while(n>0) {
			MinMax(b_1+1,b_n-1,&b_2,&b_n2);
			n-=2;
			ans=max(ans,max(b_2-b_1,b_n-b_n2));
			b_1=b_2;
			b_n=b_n2;
		}
		ans=max(ans,b_n-b_1);
		return ans;
	}
	MinMax(0, inf, &b_1, &b_n);
	ll Lim = (b_n - b_1) / (n - 1);
	ll lst = b_1, tmp1 = 0, tmp2 = 0,R;
	for(ll L = b_1 + 1; L < b_n; L = R + 1) {
		R=min(L + Lim - 1, b_n - 1);
		MinMax(L, R, &tmp1, &tmp2);
		if(tmp1 == -1) {
			Lim=max(Lim,R-lst+1);
			continue;
		}
		ans = max(ans, tmp1 - lst);
		Lim= max(Lim,ans);
		lst = tmp2;
	}
	ans = max(ans, b_n - lst);
	return ans;
}


```

---

## 作者：Kexi_ (赞：1)

第一次写交互题，感觉很新颖，不是很会用。

那么说说思路吧。

### 第一问

第一问是不是简单题（？

根据数组单调性，收缩这个值域的边界，推出整个数组之后做一遍最大差分就行。

### 第二问

这个能想出来的是神人，很奇妙的解法。

首先根据鸽巢原理发现这个差分必须大于等于 $\frac{a_{max} - a_{min}}{n - 1}$ 好理解对罢。

这就造就了一个情况，就是咱们可以**根据值域**给这 $a_{min}$  到 $a_{max}$ 化成 $n - 1$ 段，这样的话每段内部是不是就不会出现答案了，因为你无论段内咋减都是小于刚才那个值的。

这个时候答案的两端就只能出现在不同段内了，然后又由于这个单调性，两个段中位置相邻的元素分别是左边段的最大值和右边段的最小值，因此算一下这个交界处是不是就可以了。

还要提一嘴的就是，如果一个值域是空的，跳过就好，保留之前的最小值。

### 题外话

由于是第一次做这个交互题，编译错误了无数回，认为有必要为新手说一下这个玩意的格式。

这个头文件用万能头就好，然后还要在外面包上题目中提到的"extern C"，可以看我代码。 


```cpp
#include <bits/stdc++.h>

long long a[100007];

extern "C" {
	void MinMax(long long  , long long  , long long* , long long*);
	
	long long findGap(int T , int N) {
		long long ans = 0;
		switch(T) {
			case 1 : {
				MinMax((long long)0 , (long long)1e18 , &a[1] , &a[N]);
				for(register int i = 2; i  <= (N + 1) / 2 ; ++i) {
					MinMax(a[i - 1]  + 1 , a[N - i + 2] - 1 , &a[i] , &a[N - i + 1]);
				}
				for(register int i = 1; i <= N - 1; ++i) {
					ans = std :: max(ans , a[i + 1] - a[i]);
				} 
				break;
			}
			case 2 : {
				long long Max , Min , block , lst;
				MinMax((long long)0 , (long long)1e18 , &Min , &Max);
				lst = Min;
				block = (Max - Min) / (N - 1) + (((Max - Min) % (N - 1)) ? 1 : 0); 
				
				for(long long i = Min + 1; i < Max; i += block) {
					long long j = std :: min(i + block - 1 , Max - 1) , l , r;
					MinMax(i , j , &l , &r);
					if(r != - 1) { 
						ans = std :: max(ans , l - lst);
						lst = r;
					}
				}
				ans = std :: max(ans , Max - lst);
				break;
			}
		}
		return ans;
	}
}
```

---

## 作者：山田リョウ (赞：1)

## [「APIO2016」最大差分](https://www.luogu.com.cn/problem/P3641)

### 题意：

有一个大小为 $n$ 的多重集 $s$，每次询问可以给其一个区间 $[l,r]$，返回 $\min(s\cap [l,r])$ 和 $\max(s\cap [l,r])$，求最大相邻差。

分两个子任务：

1. 每次询问耗费代价为 $1$，要求总代价不超过 $\frac{n+1}2$。

2. 每次询问耗费代价为 $|s\cap [l,r]|+1$，要求总代价不超过 $3n$。

### 题解：

#### 子任务 $1$

考虑每次询问出目前范围内的极值 $l$ 和 $r$，再把范围缩至 $[l-1,r-1]$，这样我们每次查询都能得到 $s$ 中两个元素的值（但如果是最后一次区间内只剩一个点时也就只能得到一个），因此最多询问 $\frac{n+1}2$ 次，符合。

#### 子任务 $2$

忽略掉代价中的 $+1$，我们可以询问一堆不交区间得到集合的信息，总代价却依然是 $n$，是优的。

在此基础上考虑每次询问的额外代价，要尽量减少区间个数。

易见得我们不需要关心长度小于等于最大相邻差内的区间内的贡献，又联系抽屉原理有最大相邻差不小于 $\lceil\frac{\max-\min}{n-1}\rceil$，所以先花 $n+1$ 的代价得到最大和最小值，再将极值内的区间划分成 $n-1$ 个不交的长度为 $\lceil\frac{\max-\min}{n-1}\rceil$ 的区间依次查询即可，总代价应恰为 $n+1+n+n-1=3n$ 次。

[code](https://paste.ubuntu.com/p/gs6pYzfPCT/)

---

## 作者：EricWan (赞：1)

题面好懂，不再赘述。

两个任务：

任务一是询问次数维持在 $[0,\frac{N + 1}{2}]$，很明显，因为序列严格递增，所以我们可以每一次通过询问，获得两边的数，从而快速获得整个序列，得到结果。设上一次得到的两个数是 $l$ 与 $r$，那么这一次就询问 $[l+1,r-1]$。

任务二限制了询问次数加询问内的数个数。我们可以先获取 $a_1$ 与 $a_n$，之后我们就知道答案一定大于等于 $\frac{a_n-a_1}{n}$，之后我们以 $\frac{a_n-a_1}{n}$ 为块长，每块进行询问。比较每一个有数的块的最大值和下一个有数的块的最小值的差即可。

---

## 作者：Ryo_Yamada (赞：1)

挺有意思的一道题（

### $\text{Subtask 1}$

大概是送的分。可以先通过 `MinMax(0, inf, a + 1, a + n)` 得到全局的最大值和最小值，再向中间推进。推进的过程为先得到 $a_1$ 和 $a_n$，然后调用 `MinMax(a[1] + 1, a[n] - 1, a + 2, a + n - 1)`，就可以得到 $a_2$ 和 $a_{n-1}$ 的值了，以此类推。最多调用 $M \le \dfrac{n+1}{2}$ 次。

### $\text{Subtask 2}$

还是先求出 $a_1$ 和 $a_n$ 的值，此时题目中计数器 $k=n+1$。

首先很明显的，答案的下界为 $\dfrac{a_n-a_1}{n-1}$。考虑这个答案什么时候会更新。我们先把 $a_1 \sim a_n$ 这段值域分成 $n-1$ 段，显然地，如果存在更优的答案，这个答案两端在值域上一定是跨区间的。我们可以暴力找出每个区间中是否有数，如果有的话 $\min$ 和 $\max$ 有分别是多少，过程中更新即可。

最终的计数器 $k=(n+1)+(n-1)+(n-2)=3n-2$。也就是一共询问了 $n-1$ 次，区间中共有 $n-2$ 个序列中的数。

$\text{Code}$：

```cpp


def(N, int, 1e5 + 5)
def(inf, ll, 1e18)

ll a[N];

extern "C" void MinMax(ll, ll, ll *, ll *);
extern "C" long long findGap(int T, int n) {
	if(T == 1) {
		MinMax(0, inf, a + 1, a + n);
		rep(i, 2, n / 2) MinMax(a[i - 1] + 1, a[n - i + 2] - 1, a + i, a + n - i + 1);
		if(n & 1) MinMax(a[n / 2] + 1, a[n / 2 + 2] - 1, a + (n / 2 + 1), a + (n / 2 + 1));
		ll ans = 0;
		rep(i, 2, n) To_max(ans, a[i] - a[i - 1]);
		return ans;
	} 
	else {
		MinMax(0, inf, a + 1, a + n);
		ll ret = 0, ans = (a[n] - a[1]) / (n - 1);
		ans += (a[n] - a[1]) % (n - 1) != 0;
		ll r = a[1];
		for(ll l = a[1] + 1; l < a[n]; l += ans) {
			ll L, R;
			MinMax(l, min(l + ans - 1, a[n] - 1), &L, &R);
			To_max(ret, L - r);
			if(R != -1) r = R;
		}
		To_max(ret, a[n] - r);
		return ret;
	}
}
```


---

## 作者：Aegleseeker_ (赞：0)

## subtask 1：

要求询问次数 $\le \frac{n+1}{2}$。

注意到序列 $a$ **严格递增**，所以最小值、最大值一定在两侧。

我们先询问 `MinMax(0,inf,a[1],a[n])`，可以得出最两边的最值，同样再次询问 `MinMax(a[1]+1,a[n]-1,a[2],a[n-1])` 可以在区间 $[2,n]$ 中得到两边的最值。

以此类推，每次我们可以缩小未询问区间，得到两边数的信息，所以经过最多 $\frac{n+1}{2}$ 次询问后可以得到答案。

## subtask 2：
要求询问次数加上「序列多少数在询问区间内之和」$\le 3n$。

直接做似乎比较麻烦，还是先考虑询问 `MinMax(0,inf,a[1],a[n])`，得出 $a_1,a_n$。

既然次数限制和序列本身有关，我们考虑从值域入手。不难发现「最大差分」的最小值是 $\frac{a_n-a_1}{n-1}$，显然这样将剩下 $n-2$ 个数平均开来一定是最小的。

什么时候能取到比这个更大的值呢？我们将 $a$ 的值域划分成 $n-1$ 段，每一段长度都是 $\frac{a_n-a_1}{n-1}$。根据上面的推论，如果存在更大的答案，则一定是**跨越两个段的**。我们扫一遍每个段，通过 `MinMax` 来维护当前块的最小值、最大值以及上一个非空块的最大值。直接拿当前块的最小值和上一个非空块的最大值的差值取 $\max$ 即可。

询问次数是多少呢？最开始耗费了 $n+1$，后面每个段询问一次，耗费 $n-1$，总共还有 $n-2$ 个数会出现在询问区间内，于是总代价为 $3n-2\le 3n$，可以通过。

---

## 作者：strcmp (赞：0)

纯人类智慧啊。但是强行二合一，差评。

第一个部分分纯送，先问 $[0,\,10^{18}]$ 然后根据最小最大值的开区间递归即可。

首先 $3n$ 这个限制太死了，我们不可能哪个地方带个 $\log V$ 或者 $\log n$ 这种东西。而且我们除了 $a_i$ 是非负整数且长度为 $n$ 之外一点信息都没有。

第一步你也只能问 $[0,\,10^{18}]$，不然可能第一步之后你啥信息都不知道，那就倒闭了。

于是只有了 $2n - 1$ 次询问，那基本啥也干不了啊。

发现知道了最小值和最大值，我们就有了一步鸽巢原理（注意到这个真需要不少观察力吧）。令最大值为 $mx$，最小值为 $mi$。

则我们有答案 $\ge \lceil \frac{mx - mi}{n - 1} \rceil$，这个是鸽巢原理。

我们令 $l \leftarrow \lceil \frac{mx - mi}{n - 1} \rceil$，考虑在值域上询问 $n - 1$ 个长度为 $l$ 的区间。第一个区间左端点是最小值，之后每个区间的左端点都是前一个区间的右端点 $+1$。

首先小于等于答案下界的显然不用考虑。

如果要大于这个答案的下界，那么两个相邻的数必定跨了至少一个区间端点。

然后画个图。

对于跨过一个区间端点的答案，显然就是这个端点右边区间的最小值减去左边区间的最大值。

当然有可能区间内没有点，那么就去掉它，把它旁边有点的区间看作相邻的。

这样就做完了。

操作代价：一个区间包含 $k$ 个点那么代价就是 $k + 1$，假设每个区间都恰好包含一个点，然后还有一个区间包含两个点。$n + 1 + 2(n - 1) + 1 = 3n$。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
using pli = pair<ll, int>;
using pq = priority_queue<int>;
using ld = double;
constexpr int maxn = 5e5 + 10, bs = 19260817, mod = 22309287, v = 501;
constexpr ll inf = 1e18;
extern "C" void MinMax(long long, long long, long long*, long long*);
extern "C" ll findGap(int, int);
/*
int n; ll a[maxn];
void MinMax(ll l, ll r, ll* x, ll* y) {
    *x = -1, * y = -1;
    rep(i, 1, n) if (l <= a[i] && a[i] <= r) {
        if (*x == -1 || *x > a[i]) *x = a[i];
        if (*y == -1 || *y < a[i]) *y = a[i];
    }
}
*/
ll a[maxn];
ll findGap(int C, int n) {
	ll ans = -1;
	if (C == 1) {
		a[0] = -1, a[n + 1] = inf + 10;
		rep(i, 1, (n + 1) / 2) MinMax(a[i - 1] + 1, a[n - i + 2] - 1, &a[i], &a[n - i + 1]);
		rep(i, 2, n) ans = max(ans, a[i] - a[i - 1]);
		return ans;
	}
    ll mi, mx; MinMax(0, inf, &mi, &mx);
    ll w = (mx - mi + n - 2) / (n - 1), pre = mi;
    for (ll l = mi + 1, r; l < mx; l += w) {
        r = min(l + w - 1, mx - 1); ll x, y; MinMax(l, r, &x, &y);
        if (pre != -1) ans = max(ans, x - pre);
        if (y != -1) pre = y;
    }
    ans = max(ans, mx - pre);
    return ans;
}
/*
int main() {
    scanf("%d", &n);
    rep(i, 1, n) scanf("%lld", &a[i]);
    //cout << findGap(1, n) << "\n";
    return 0;
}
*/
```

---

## 作者：Leasier (赞：0)

### Subtask $1$
首先调用 $\operatorname{MinMax}(0, \inf, a_1, a_N)$，我们就会得到 $a_1, a_N$ 的值。以此类推，依次调用 $\operatorname{MinMax}(a_{i - 1} + 1, a_{N - i + 2} - 1, a_i, a_{N - i + 1})$，我们就可以得到 $a_1, a_2, \cdots, a_N$ 的值，最后统计答案即可。

### Subtask $2$
仍然首先调用 $\operatorname{MinMax}(0, \inf, a_1, a_N)$，我们就会得到 $a_1, a_N$ 的值。然后考虑最小值，会发现就是中间 $n - 2$ 个数均匀分配后的值。

此时答案最小可能是 $\displaystyle\frac{a_N - a_1}{N - 1}$。如果把序列分块，每块大小是 $\displaystyle\frac{a_N - a_1}{N - 1}$ 的话，那么我们就可以依次查询每个块的最大最小值（如果没有则不管），并用它依次更新答案即可。

代码：
```cpp
#include <iostream>

using namespace std;

typedef long long ll;

ll a[100007];

extern "C" {
	void MinMax(ll, ll, ll*, ll*);

	ll findGap(int T, int N){
		ll ans = 0;
		if (T == 1){
			int t = (N + 1) / 2;
			a[0] = -1;
			a[N + 1] = 0x7fffffffffffffff;
			for (register int i = 1; i <= t; i++){
				MinMax(a[i - 1] + 1, a[N - i + 2] - 1, &a[i], &a[N - i + 1]);
			}
			for (register int i = 1; i < N; i++){
				ans = max(ans, a[i + 1] - a[i]);
			}
		} else {
			ll a1, an, last, i, t;
			MinMax(0, 0x7fffffffffffffff, &a1, &an);
			last = a1;
			t = (an - a1) / (N - 1);
			if ((an - a1) % (N - 1) != 0) t++;
			for (i = a1 + 1; i < an; i += t){
				ll l, r;
				MinMax(i, min(i + t - 1, an - 1), &l, &r);
				if (l != -1){
					ans = max(ans, l - last); // 更新答案
					last = r;
				}
			}
			ans = max(ans, an - last);
		}
		return ans;
	}
}
```

---


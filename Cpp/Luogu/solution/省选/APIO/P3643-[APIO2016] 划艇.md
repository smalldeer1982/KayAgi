# [APIO2016] 划艇

## 题目描述

在首尔城中，汉江横贯东西。在汉江的北岸，从西向东星星点点地分布着 $N$ 个划艇学校，编号依次为 $1$ 到 $N$。每个学校都拥有若干艘划艇。同一所学校的所有划艇颜色相同，不同的学校的划艇颜色互不相同。颜色相同的划艇被认为是一样的。每个学校可以选择派出一些划艇参加节日的庆典，也可以选择不派出任何划艇参加。如果编号为 $i$ 的学校选择派出划艇参加庆典，那么，派出的划艇数量可以在 $a_i$ 至 $b_i$ 之间任意选择（$a_i \leq b_i$）。

值得注意的是，编号为 $i$ 的学校如果选择派出划艇参加庆典，那么它派出的划艇数量必须大于任意一所编号小于它的学校派出的划艇数量。

输入所有学校的 $a_i,b_i$ 的值，求出参加庆典的划艇有多少种可能的情况，必须有至少一艘划艇参加庆典。两种情况不同当且仅当有参加庆典的某种颜色的划艇数量不同。


## 说明/提示

【样例解释】

在只有一所学校派出划艇的情况下有 $4$ 种方案，两所学校都派出划艇的情况下有 $3$ 种方案，所以答案为 $7$。

【数据范围】

子任务 $1$（$9$ 分）：$1 \leq N \leq 500$ 且对于所有的 $1 \leq i \leq N$，保证 $a_i=b_i$。

子任务 $2$（$22$ 分）：$1 \leq N \leq 500$ 且 $\sum_{i=1}^N (b_i-a_i) \leq 10^6$。

子任务 $3$（$27$ 分）：$1 \leq N \leq 100$。

子任务 $4$（$42$ 分）：$1 \leq N \leq 500$。


## 样例 #1

### 输入

```
2
1 2
2 3```

### 输出

```
7
```

# 题解

## 作者：sky_of_war (赞：53)

同步更新于我的博客：[APIO2016划艇](https://www.skyofwar.net/2019/05/06/143.html)
# Solution
首先有一种比较好想的状态表示：$f_{i, j}$为前$i$所学校中，第$i$所学校参赛，且派出$j$艘划艇的方案数。这样的话最后答案就是$\displaystyle \sum_i \sum_j f_{i,j}$，转移大概就是：
$$ \begin{aligned}f_{0,1} &= 1\\f_{i, j} &=\begin{cases}\displaystyle \sum_{k=1}^{j-1}\sum_{p=0}^{i-1}f_{p, k}, &j\in I_i\\0, &j \notin I_i\end{cases}\end{aligned} $$
这种状态表示有一个很严重的问题在于，第二维的范围是$10^9$的，连$9$分都过不去。
对于这种范围比较大的数据，可以考虑离散化。
重新定义设一下状态：先把区间离散化成$\mathcal O(n)$个端点，然后设$f_{i, j}$为前$i$所学校中，第$i$所学校参赛，且派出的划艇数落到第$j$个区间内的方案数。于是在第$i$所学校之前的学校便分为了两类：在区间$j$内的和不在区间$j$内的。
考虑怎么计算**在**区间$j$内的贡献。先来证明一个引理。
> **Lemma**. 从区间$[0,L]$中取$n$个数，要求所有**非零数**严格递增，则方案数为$\binom{L+n}{n}$。

**Proof**. 对于没有$0$的情况，答案肯定就是$\binom L n$。原因是如果我们确定了一种组合，那么方案也就随之确定了，就是这个组合的从小到大的排列，这两者一一对应。对于把$0$加进去的情况，观察如下序列：
$$\underbrace{\text{0 0 0 $\dots$ 0}}_{n \text{个} } \text{ 1 2 3 $\dots L$}$$
考虑从这个序列取$n$个数，方案数为$\binom{L+ n}{n}$。可以发现，它和原问题的答案是一一对应的！取第$i$个$0$对应着第$i$次取$0$，取某个非零数$k$对应着没取$0$的第$k$次取$k$。于是我们就通过这个巧妙的构造轻而易举地证明了该引理。$\square$

回到原来的问题，由于第$i$所学校必须参赛，所以计算的时候$0$的个数需要$-1$。方案数即为$\binom{m+L-1}m$，$m$表示挑选划艇个数包含第$j$个区间的学校的数量。具体来说就是枚举上一个有学校的区间$k$，前$p$所学校不在区间$j$中，则$m$是$p+1..i$号学校中能选区间$j$的学校的数量，则转移方程容易得出，即：
$$\begin{aligned}f_{0,1}&=1\\f_{i, j} &= \begin{cases}\displaystyle\sum_{k=1}^{j-1}\sum_{p=0}^{i-1}\binom{L+m-1}m f_{p, k}, &j\subseteq I_i (\text{记为}\square \text{式})\\0, &j \nsubseteq I_i\end{cases}\end{aligned}$$
这东西显然可以前缀和处理。设
$$g_{i, j} = \sum_{k=1}^{j-1}f_{i, k}$$
于是$(\square)$可以简化为
$$f_{i, j} = \sum_{p=0}^{i-1}\binom{L+m-1}mg_{p, j-1}, j \subseteq I_i$$
关于实现，每次递推好组合数防止过多的取模就可以了。
```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#include<bits/stdc++.h>
#define getchar getchar_unlocked
#define putchar putchar_unlocked
constexpr int MAXN = 5e2 + 10;
typedef long long ll;
constexpr int mo = 1e9 + 7;
using namespace std;
int n, tot, a[MAXN], b[MAXN], num[MAXN << 1], g[MAXN], C[MAXN], inv[MAXN];
template <class T>
inline void _read(T &x)
{
    x = 0;
    char t = getchar();
    while(!isdigit(t)) t = getchar();
    while(isdigit(t))
    {
        x = x * 10 + t - '0';
        t = getchar();
    }
}
template <class T>
inline void print(T x)
{
    if(x < 0)
    {
        putchar('-');
        x = -x;
    }
    if(x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}
template <class T>
inline int fastmod(T x)
{
    if (x >= mo) return x - mo; else return x;
}
int main()
{
    _read(n);
    inv[1] = 1;
    for(int i = 2; i <= n; ++i) inv[i] = (ll)(mo - mo / i) * inv[mo % i] % mo;
    for(int i = 1; i <= n; ++i)
    {
        _read(a[i]), _read(b[i]);
        num[++tot] = a[i];
        num[++tot] = b[i] + 1;
    }
    sort(num + 1, num + 1 + tot);
    tot = unique(num + 1, num + 1 + tot) - num - 1;
    for(int i = 1; i <= n; ++i)
    {
        a[i] = lower_bound(num + 1, num + 1 + tot, a[i]) - num;
        b[i] = lower_bound(num + 1, num + 1 + tot, b[i] + 1) - num;
    }
    C[0] = 1;
    g[0] = 1;
    for(int j = 1; j < tot; ++j)
    {
        int len = num[j + 1] - num[j];
        for(int i = 1; i <= n; ++i) C[i] = (ll)C[i - 1] * (len + i - 1) % mo * inv[i] % mo;
        for(int i = n; i; --i)
            if(a[i] <= j && j + 1 <= b[i])
            {
                int f = 0, m = 1, c = len;
                for(int p = i - 1; p >= 0; --p)
                {
                    f = fastmod(f + (ll)c * g[p] % mo);
                    if(a[p] <= j && j + 1 <= b[p]) c = C[++m];
                }
                g[i] = (g[i] + f) % mo;
            }
    }
    int ans = 0;
    for(int i = 1; i <= n; ++i) ans = fastmod(ans + g[i]);
    print(ans);
    return 0;
}
```

---

## 作者：walk_alone (赞：25)

首先考虑最朴素的DP如何实现：

确定状态$f_{i,j}$为前$i$个学校，第$i$个学校派出$j$艘划艇的方案总数（规定$j$不为0，则第$i$个学校必须参赛）。转移方程也非常好写：

$$f_{i,j}=\sum_{h=0}^{i-1} \sum_{k=1}^{j-1} f_{h,k},j \in [a_i,b_i]$$

即，$f_{i,j}$可以由以下情况转移得到：在$i$前面派的最后一个学校编号为$h(h \leq i-1)$，且第$h$个学校派出了$k(k \leq j-1)$艘划艇的方案和。

但是这显然会炸裂：划艇数会达到$10^9$的量级，这非得把汉城短短的汉江全部塞满划艇不可，而且我们的空间时间也都炸裂了。但是我们注意到学校数目$n$很小，只有$500$，因而可以考虑离散化。

将每一个学校区间$[a_i,b_i]$处理为前闭后开区间$[a_i,b_i+1)$，然后将$2n$个端点进行离散化处理，得到至多$2n$个**互不相交**的区间。那么一个学校派出的划艇数目，就可以被唯一的划分到一个子区间中。

如：区间分别为$[1,3],[2,4],[1,5],[3,7]$，那么端点为$1,2,3,4,5,7$，子区间为$[1,2],[2,3],[3,4],[4,5],[5,7]$。对第三个学校$[1,5]$来说，它可以取得的区间编号为$1,2,3,4$。第四个学校区间编号为$3,4,5$。对于一个学校来说，它派出的划艇数目如果在某一个区间中，其实问题是本质等价的——如果落入$[5,7]$中，那么派出6和派出7对这个学校来说没有本质区别。

但是这么做就会出现一个问题：如果若干个学校出现在了同一个子区间怎么办？这个地方就是整个DP的核心。

我们重新刻画状态：$f_{i,j}$表示第$i$个学校派出的划艇数在第$j$个区间。由于我们的区间不包含$0$，因而第$i$个学校必定参赛。

为了解决上面新出现的问题，我们就要考虑有多少个学校和第$i$个学校同在第$j$个区间。但是这么好像也非常复杂：有些学校的$[a_i,b_i]$不一定覆盖第$j$个区间，也就是说不是我们想枚举多少就有多少的。于是我们刻画一个镜像状态：前$p$个学校不在第$j$个区间（即小于$j$区间）。后面这种数目$m$可以通过计算出来。

因而我们成功的将前面的$i-1$个学校划分成了两部分：前面$p$个学校不在$j$区间，后面的$m$个学校同第$i$个一样，都在$j$区间。显然，如果$p$不同，那么派出的种类一定不同，不会造成重复。

那么，如何转移呢？

对于前面的$p$个学校的数目，这个问题与当前大问题本质相同，因而可以直接使用$f_{p,k}$——前面$p$个学校，最后一个学校所在区间在第$k(k\leq j-1)$个区间的数目。因而第一部分的数目就是$\displaystyle \sum_{k=1}^{j-1}f_{p,k} $——$k$需要枚举，因为任意的$k$都存在满足条件的数目。第二部分，对于和第$i$个学校派出数目区间一样的$m$个学校，这部分种类数如何计算？

将问题用另一种方式呈现：在$[0,len]$区间中取$m$个数，使得非零数单增的方案总数。

接用sky_of_war大佬的证明想法：首先在$[1,len]$个数中任取$m$个数，方案总数为$C_{len}^{m}$——只关心选了那些，排列是唯一的。之后考虑下面这个序列，由前面$m$个$0$和$1,2,3……,len$所组成。在这个序列中任取$m$个数，同理可得方案总数为$C_{len+m}^{m}$。而且这个方案与原问题方案是一一对应的——前面取$0$的位置对应不参赛的学校，后面取的地方也与原来学校位置对应。因而答案为$C_{len+m}^{m}$。

由于第$i$个学校必须参赛，那么0的数量要少一个，即$C_{len+m-1}^{m}$种。

而且，前后两个子问题互不影响，因而满足乘法原理。对于一个$p$，对应的方案总数就应该为：$\displaystyle C_{len+m-1}^{m}\sum_{k=1}^{j-1}f_{p,k}$。考虑$p$也是要枚举的，所以：

$$f_{i,j}= \sum_{p=0}^{i-1} C_{len+m-1}^{m}\sum_{k=1}^{j-1}f_{p,k}$$

很显然可以发现，第一部分的答案可以作为一个整体$sum$：记$\displaystyle sum_{p,j}=\sum_{k=1}^{j-1}f_{p,k}$，因而原式化简为：

$$f_{i,j}= \sum_{p=0}^{i-1} C_{len+m-1}^{m}sum_{p,j}$$

总复杂度$O(n^3)$。

放上核心代码：

```cpp
    c[0] = 1;
    g[0] = 1;//即sum数组
    for (int j = 1; j < tot;j++)//tot为总的端点（区间）个数
    {
        long long len = num[j + 1] - num[j];
        for (int i = 1; i <= n;i++)
            c[i] = c[i - 1] * (long long)(i + len - 1) % mod * inv[i] % mod;//提前算好组合数。由于几个亿的组合数显然没办法递推，只能用带乘除的递推。由于在同一层循环中下标恒一样，c[i]表示上标为i的组合数。
        for (int i = n; i >= 0;i--)//此处使用了省空间的写法。考虑递推式中，第i行的信息只从i-1行获得，因而可以类比背包的省空间写法，倒推来压缩空间。
            if(a[i] <= j && j + 1 <= b[i])
            {
                long long C = c[1], f = 0;
                int m = 1;//m为满足条件的个数。由于是从后往前的枚举，所以m单调递增。每碰到一个合法的p，m就要自增
                for (int p = i - 1; p >= 0;p--)
                {
                    f = (f + C * g[p] % mod) % mod;
                    if(a[p] <= j && j + 1 <= b[p])
                        C = c[++m];//C为组合数，与m相绑定
                }
                g[i] = (g[i] + f) % mod;
            }
    }
    long long ans = 0;//ans统计答案。显然答案可以从所有的g中出现。
    for(int i = 1; i <= n; i++)
        ans = (ans + g[i]) % mod;
```


---

## 作者：碳六灵 (赞：23)

先考虑$O(n^2max(a_i,b_i))$的做法

$Dp[i][j]$表示到了第$i$个学校,第$i$个学校参加且派$j$个划艇的方案数

方程即为

$Dp[i][j]=\sum_{p < i,q<j} Dp[p][q]$

加个前缀和优化即可

但是这题的$max(a_i,b_i)$是$10^9$级别,不可过

考虑其他状态,发现想不出

再加思考发现,选出的若干个数我们只关心它们是否递增即只关心大小关系

考虑离散化

对于离散化,是将一个值域区间取出若干个关键点后关键点的排名即这样的


![](https://cdn.luogu.com.cn/upload/image_hosting/78rg5moi.png)

其中$1,2,3,4$对应的是离散化后的四个区间即在$[Ai , A_{i+1})$都会被离散化为$i$

那我们依照离散化后修改一下状态

令$Dp[i][j][k]$表示前$i$个学校,第$i$个学校选的划艇数落在第$j$个区间内,已经有$k$个学校落在第$j$个区间了

那么转移就要分两种了

枚举$i$和$j$
za
$1^\omicron$ 第$i$个学校选的划艇数不落在第$j$个区间

则可以用上述方程的转移,前缀和优化复杂度$O(n^3)$

$2^\omicron$ 第$i$个学校选的划艇数落在第$j$个区间

现给出一个引理,$n$个数,值域在$D$之内的递增序列个数为$C_D^n$

根据这个引理,插入一个新数的方案数为$\frac{LastAns}{C_D^n}\times C_D^{n + 1}$

则在枚举$k$即可转移,复杂度$O(n^3)$

综上,总复杂度$O(n^3)$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
typedef long long ll;
#define inc(i) (++ (i))
#define dec(i) (-- (i))
#define Rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i <= i##Limit ; inc(i))
#define rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i >= i##Limit ; dec(i))
#define Eep(i , u , v) for(int i = Head[u] , v = Node[i] ; i; v = Node[i = Next[i]])
using namespace std;

const int N = 1000 + 7 , Mod = 1000000000 + 7;
inline int Inc(int A , int B) { A += B; return A >= Mod ? A - Mod : A; }
inline int Dec(int A , int B) { A -= B; return A < 0 ? A + Mod : A; }
inline int Mul(int A , int B) { return 1ll * A * B % Mod; }
int n , a[N] , b[N] , A[N] , B[N] , C[N] , Dp[N][N] , Sum[N] , Limit[N] , Inv[N];

int main() {
	int Sz = 0;
	scanf("%d" , &n);
	Rep(i , 1 , n) scanf("%d%d" , A + i , B + i) , C[inc(Sz)] = A[i] , C[inc(Sz)] = B[i] + 1;
	sort(C + 1 , C + 1 + Sz) , Sz = unique(C + 1 , C + 1 + Sz) - C - 1;
	Rep(i , 1 , n) a[i] = lower_bound(C + 1 , C + 1 + Sz , A[i]) - C;
	Rep(i , 1 , n) b[i] = lower_bound(C + 1 , C + 1 + Sz , B[i] + 1) - C;
	Inv[1] = 1; Rep(i , 2 , N - 1) Inv[i] = Dec(0 , Mul(Inv[Mod % i] , Mod / i));
	Dp[0][0] = 1;
	Rep(i , 0 , Sz - 1) Sum[i] = 1;
	Rep(i , 1 , n) {
		Rep(j , a[i] , b[i] - 1) {
			inc(Limit[j]);
			rep(k , Limit[j] , 2) Dp[j][k] = Inc(Dp[j][k] , Mul(Dec(Mul(Dp[j][k - 1] , C[j + 1] - C[j] - k + 1) , 0) , Inv[k]));
			Dp[j][1] = Inc(Dp[j][1] , Mul(Sum[j - 1] , Dec(C[j + 1] , C[j])));
		}
		Rep(j , 1 , Sz - 1) {
			Sum[j] = Sum[j - 1];
			Rep(k , 1 , Limit[j]) Sum[j] = Inc(Sum[j] , Dp[j][k]);
		}
	}
	printf("%d" , Dec(Sum[Sz - 1] , 1));
	return 0;
}
```

---

## 作者：嘉然小姐的狗 (赞：19)

提供一个无脑离散微积分的做法，看起来和其他做法应该差不多。

---

不知道诸位有没有学过拉格朗日插值，学过的话应该做过一些题目吧：

* 给出 $n, k$ 求 $\sum_{i = 1}^n i^k$
* 给出 $n, k, p$ 求 $\sum_{i = 1}^n \sum_{j = 1}^{ik} j^p$

它们都是 $i$ 或者 $2i$ 或者 $2i + 1$ 之类的次数的多项式。

它们大概有一个共同的特性，就是 $f_0(x) = C$（常数列），$f_i(x) = \sum_{j = 1}^x f_{i - 1}(jd)$（若干次前缀和之类的玩意）。


然后可以发现题目这个式子长得特像这样的东西，所以大概可以猜到它也是一个 $i$ 次多项式。

这个是思路。

---

设 $f_i(n)$ 表示前 $i$ 个中（每个元素可选可不选），末尾元素为 $n$ 的方案数。不难注意到，如果没有 $a_i, b_i$ 的限制，那么就有

$$f_i(n) = \mathrm{C}^i_n$$

显然是一个 $i$ 次多项式。

那么有限制的话，就有

$$f_i(n) = f_{i - 1}(n) + [a_i \leq n \leq b_i]\sum_{x = 1}^{n - 1} f_{i - 1}(x)$$

不难发现是一个分段 $i$ 次多项式（段数不超过 $2i + 1$）。

所以直接分段离散微积分就好了。也就是说，对于 $f_i(n)$，我们用多个三元组 $(l, r, A(x))$ 记录它，其中 $A(x)$ 是一个用阶乘下降幂记录的多项式 $A(x) = \sum_{i = 0}^\infty a_ix^{\underline i}$。对于任意三元组 $(l, r, A(x))$，满足对于 $l \leq n \leq r$，有

$$f_i(n) = A(n)$$

虽然思路很无脑，但是代码比较长，常数较大。

时间复杂度：$O(n^3)$。

## 代码
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

typedef long long int64;

const int MOD = 1000000007;
const int MAXN = 500 + 10;
const int INF = 1000000000;

int inv[MAXN];
int n;
int a[MAXN], b[MAXN];

inline int qmod(int x) { return (x >= MOD) ? (x - MOD) : x; }
inline int qpow(int64 b, int p, int mod = MOD) {
    int res = 1;

    while (p) {
        if (p & 1)
            res = res * b % mod;
        b = b * b % mod;
        p >>= 1;
    }
    return res;
}

inline int dpow(int n, int k) {
    int i, prod = 1;

    for (i = 0; i < k; i++) prod = 1ll * prod * (n - i) % MOD;
    return prod;
}

struct Node {
    int l, r;
    int a[MAXN], len;

    Node() {
        memset(a, 0, sizeof(a));
        len = l = r = 0;
    }
    Node(int _l, int _r, int _C) {
        memset(a, 0, sizeof(a));
        l = _l;
        r = _r;
        a[0] = _C;
        len = 0;
    }
    void clear() {
        memset(a, 0, (len + 1) << 2);
        l = r = len = 0;
    }
    void operator=(const Node b) {
        memset(a, 0, (len + 1) << 2);
        l = b.l;
        r = b.r;
        len = b.len;
        memcpy(a, b.a, (len + 1) << 2);
    }
    Node operator+(const Node b) const {
        static Node ans;
        int i;

        ans.clear();
        ans.len = std::max(len, b.len);
        ans.l = l | b.l;
        ans.r = r | b.r;
        for (i = 0; i <= ans.len; i++) ans.a[i] = qmod(a[i] + b.a[i]);
        return ans;
    }
    Node operator+(const int x) const {
        static Node ans;

        ans = (*this);
        ans.a[0] = qmod(ans.a[0] + x);
        return ans;
    }

    int get(int n) const {
        int i, x = 1;
        int ans = 0;

        for (i = 0; i <= len; i++) {
            ans = (ans + 1ll * x * a[i]) % MOD;
            x = 1ll * x * (n - i) % MOD;
        }
        return ans;
    }
    Node integral() const {  // F(n) = sum_l^n f(x)
        static Node ans;
        int i;

        ans.clear();
        ans.l = l;
        ans.r = r;
        ans.len = len + 1;
        for (i = 0; i <= len; i++) ans.a[i + 1] = 1ll * a[i] * inv[i + 1] % MOD;
        ans.a[0] = qmod(MOD - ans.get(l));
        return ans;
    }
    int get_integral() const { return integral().get(r + 1); }
};
Node f[MAXN << 1], g[MAXN << 1];
int fn, gn;

inline void ins(const Node x) {
    if (x.l <= x.r) {
        fn++;
        f[fn] = x;
    }
}

void init() {
    int i;

    for (i = 1; i < MAXN; i++) inv[i] = qpow(i, MOD - 2);
}

int main() {
    int i, j, C, ans;

    init();

    scanf("%d", &n);
    for (i = 1; i <= n; i++) scanf("%d %d", &a[i], &b[i]);

    fn = 1;
    f[1].l = f[1].r = 0;
    f[1].a[0] = 1;
    for (i = 1; i <= n; i++) {
        memcpy(g, f, sizeof(f));
        gn = fn;

        memset(f, 0, sizeof(f));
        fn = 1;
        f[1].l = f[1].r = 0;
        f[1].a[0] = 1;

        C = 1;
        for (j = 2; j <= gn and g[j].r < a[i]; j++) {
            fn++;
            f[fn] = g[j];
            C = qmod(C + g[j].get_integral());
        }

        if (j > gn) {
            ins(Node(f[fn].r + 1, a[i] - 1, 0));
            ins(Node(a[i], b[i], C));
            continue;
        } else {
            if (g[j].l < a[i]) {
                fn++;
                f[fn] = g[j];
                f[fn].r = a[i] - 1;
                C = qmod(C + f[fn].get_integral());
                g[j].l = a[i];
            }
        }

        for (; j <= gn and g[j].r <= b[i]; j++) {
            fn++;
            f[fn] = g[j] + g[j].integral() + C;
            C = qmod(C + g[j].get_integral());
        }

        if (j > gn) {
            ins(Node(f[fn].r + 1, b[i], C));
            continue;
        } else {
            if (g[j].l <= b[i]) {
                fn++;
                f[fn] = g[j];
                f[fn].r = b[i];
                f[fn] = f[fn] + f[fn].integral() + C;
                g[j].l = b[i] + 1;
            }
        }

        for (; j <= gn; j++) {
            fn++;
            f[fn] = g[j];
        }
    }

    ans = 0;
    for (i = 2; i <= fn; i++) ans = qmod(ans + f[i].get_integral());
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：xht (赞：18)

首先将区间离散化成若干个左闭右开的区间。

设 $f_{i, j}$ 表示考虑到 $a_i$，$a_i$ 在第 $j$ 个区间内的方案数。

枚举上一个在 $j$ 之前的位置 $a_k$ 转移。

设 $k + 1 \sim i$ 中有 $c$ 个位置可以选择第 $j$ 个区间，设第 $j$ 个区间的长度为 $l_j$，则方案数为 $\binom{l_j + c}{c}$。

需要前缀和优化，时间复杂度 $\mathcal O(n^3)$。

```cpp
const int N = 507;
int n, a[N], b[N], c[N*2], t;
modint f[N], g[N], ans;

int main() {
	rd(n);
	for (int i = 1; i <= n; i++)
		rd(a[i]), rd(b[i]), c[++t] = a[i], c[++t] = ++b[i];
	sort(c + 1, c + t + 1), t = unique(c + 1, c + t + 1) - (c + 1);
	for (int i = 1; i <= n; i++)
		a[i] = lower_bound(c + 1, c + t + 1, a[i]) - c,
		b[i] = lower_bound(c + 1, c + t + 1, b[i]) - c;
	f[0] = 1;
	for (int j = 1; j < t; j++) {
		int l = c[j+1] - c[j];
		g[0] = 1;
		for (int i = 1; i <= n; i++) g[i] = g[i-1] * (l + i - 1) / i;
		for (int i = n; i; i--)
			if (a[i] <= j && j < b[i])
				for (int c = 1, k = i - 1; ~k; k--) {
					f[i] += g[c] * f[k];
					if (a[k] <= j && j < b[k]) ++c;
				}
	}
	for (int i = 1; i <= n; i++) ans += f[i];
	print(ans);
	return 0;
}
```

---

## 作者：Alex_Wei (赞：14)

> [题面传送门](https://www.luogu.com.cn/problem/P3643)。

> 题意简述：给出序列 $a_i,b_i$，求出有多少序列 $c_i$ 满足 $c_i=-1$ 或 $c_i\in[a_i,b_i]$，同时非 $-1$ 的部分单调递增。

> 本文选自 [DP 大锅乱炖 例题 IX.](https://www.cnblogs.com/alex-wei/p/DP_Involution.html)。

直到做到这题我才意识到我的 DP 水平有多菜。

---

注意到值域过大，于是对区间进行离散化，设离散化后的端点分别为 $p_1,p_2,\cdots,p_c$。注意要将 $[a_i,b_i]$ 变成 $[a_i,b_i+1)$，即**将 $b_i$ 加 $1$**，方便计算答案。

接下来考虑 DP：设 $f_{i,j}$ 表示第 $i$ 个学校派出划艇数量在 $L_j=[p_j,p_{j+1})$ 之间时的方案数。

错误思路：$f_{i,j}=\begin{cases}\sum_{pos=1}^{i-1}\sum_{k=1}^{j-1}f_{pos,k}\times (p_{j+1}-p_j)&[p_j,p_{j+1})\subseteq[a_i,b_i)\\0&\mathrm{otherwise}\end{cases}$。错误原因：I. 没有考虑边界条件 & 枚举下界。II. 没有考虑在同一区间内也合法的情况。

边界条件就是 $f_{i,0}=1$，并且注意 $pos,k$ 的枚举下界应为 $0$。

考虑在同一区间内合法的情况：不妨枚举最右端的不在区间 $j$ 的位置 $pos$，那么剩下来 $i-pos$ 个位置。假设当中有 $m$ 个位置满足可以落在区间 $j$ 上，那么方案数就相当于从 $m-1$ 个 $-1$ 和 $L_j$ 个数 $p_j,p_j+1,\cdots,p_{j+1}-1$ 中选出 $m$ 个数（因为位置 $i$ 必须选所以是 $m-1$ 而不是 $m$；$-1$ 相当于不选），即 $\binom{m+L_j-1}{m}$。

综上所述，更新后的转移方程应为 $f_{i,j}=\begin{cases}\sum_{pos=0}^{i-1}\sum_{k=0}^{j-1}f_{pos,k}\times\binom{m+L_j-1}{m}&[p_j,p_{j+1})\subseteq[a_i,b_i)\\0&\mathrm{otherwise}\end{cases}$。注意到后面的组合数可以 $\mathcal{O}(1)$ 递推（$\binom{m+L_j}{m+1}=\binom{m+L_j-1}{m}\times\frac{m+L_j}{m+1}$），那么使用前缀和优化（因为 $m$ 与枚举的 $k$ 无关，所以记 $s_{i,j}=\sum_{k=0}^j f_{i,k}$，则上面那一坨可以写成 $\sum_{pos=0}^{i-1}s_{pos,j-1}\times\binom{m+L_j-1}{m}$）+ 倒序枚举 $pos$（实时更新 $m$ 与组合数）即可 $\mathcal{O}(n^3)$ 计算。

代码放在了 cnblogs 里面。

---

## 作者：_LHF_ (赞：14)

一种拉格朗日插值的做法。

考虑所有 $a_i,b_i$ 分别相等的做法。

设 $f_{i,j}$ 表示考虑完前 $i$ 个学校，最大值为 $j$ 的方案。

观察 $f_{i,j}$ 可以发现，当 $n=1$ 时是一个一次多项式，当 $n=2$ 时是一个二次多项式，当 $n=3$ 时是一个三次多项式。

于是欣然上拉格朗日插值。

求出前 $n$ 个点值然后直接插值，由于点值连续，所以可以线性插值。

再考虑其他情况，把区间分隔开之后发现每一段都是一个 $n$ 次多项式，具体的，我们把所有区间化作 $[a_i,b_i)$ （读入时把 $b_i$ 加一）的形式，于是就好弄了。时间复杂度 $O(n^3)$

当然，常数巨大，LOJ上无法通过（因为那里时限是1s）。

```cpp
#include<cstdio>
#include<algorithm>
#define N 1010
#define ll long long
using namespace std;
const int mod=1e9+7;
ll p[N],q[N],fac[N],ifac[N],s[N][N];
int len,sum,ss[N][N],g[N][N],ans;
ll fastpow(ll a,int b)
{
	ll s=1;
	while(b)
	{
		if(b&1) s=s*a%mod;
		a=a*a%mod, b>>=1;
	}
	return s;
}
int Mod(int a){return a<mod?a:a-mod;}
int Lagrange(int n,int m,int*a)
{
	if(m<=n) return a[m];
	p[0]=m,q[n+1]=1;
	ll sum=0;
	for(int i=1;i<=n;i++) p[i]=p[i-1]*(m-i)%mod;
	for(int i=n;i>=0;i--) q[i]=q[i+1]*(m-i)%mod;
	for(int i=0;i<=n;i++)
	{
		sum=(sum+a[i]*(i>0?p[i-1]*ifac[i]%mod:1)%mod*q[i+1]%mod*ifac[n-i]%mod*((n-i)%2?mod-1:1)%mod+mod)%mod;
	}
	return sum;
}
int n,x[N<<1],y[N],a[N],b[N],l[N],r[N];
int main()
{
	scanf("%d",&n);
	fac[0]=ifac[0]=1;
	for(int i=1;i<=n+1;i++) fac[i]=fac[i-1]*i%mod;
	ifac[n+1]=fastpow(fac[n+1],mod-2);
	for(int i=n;i;i--) ifac[i]=ifac[i+1]*(i+1)%mod;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		x[++len]=a[i];
		x[++len]=++b[i];
	}
	sort(x+1,x+len+1);
	len=unique(x+1,x+len+1)-x-1;
	for(int i=1;i<=n;i++)
	{
		l[i]=lower_bound(x+1,x+len+1,a[i])-x;
		r[i]=lower_bound(x+1,x+len+1,b[i])-x;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=l[i];j<r[i];j++)
		{
			sum=1;
			for(int k=0;k<=n;k++)
			{
				y[k]=Mod(s[i-1][j-1]+sum);
				sum=Mod(ss[j][k]+sum);
				ss[j][k]=Mod(ss[j][k]+y[k]);
			}
			for(int k=1;k<=n;k++) y[k]=Mod(y[k]+y[k-1]);
			g[i][j]=Lagrange(n,x[j+1]-x[j]-1,y);
			ans=Mod(ans+g[i][j]);
		}
		for(int j=1;j<len;j++)
			s[i][j]=(s[i][j-1]+s[i-1][j]-s[i-1][j-1]+g[i][j]+mod)%mod;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：fy0123 (赞：13)

组合dp。
```cpp
/*
*	离散成一些开区间；
*	用f[i,j]表示最后一个取到i这个学校，取值在第j段的方案数；
*	转移，考虑前一个取到的学校；
*	如果之前取的数小于j这个区间，则直接全部累加；
*	否则之前的数在这个区间内；
*	假设[l,r)中只有m所学校能满足派出数量在j区间中的划艇，设j区间的大小为l；
*	计算出cal(l,r,j)表示[l,r)中每所学校都在j区间中选数，可选可不选；
*	第r所学校必须选，序列递增的方案数；
*	cal(l,r,j)=sigma(C(l,i)*C(m,i-1))(1<=i<=m+1)=C(l+m,m+1)；
*	枚举每一段j，依次考虑，组合数可以预处理；
*	并使用前缀和优化；
*	http://blog.csdn.net/ruoruo_cheng/article/details/51873577
*/
#include<bits/stdc++.h>
#define rep(i, x, y) for(int i = (x); i <= (y); i++)
#define per(i, x, y) for(int i = (x); i >= (y); i--)
#define N 505
#define ll long long
#define mod 1000000007
using namespace std;
int n, tot, a[N], b[N], num[N<<1], g[N], C[N], inv[N];
int main() {
	scanf("%d", &n);
	inv[1] = 1; rep(i, 2, n) inv[i] = (ll)(mod-mod/i)*inv[mod%i]%mod;
	rep(i, 1, n) {
		scanf("%d%d", &a[i], &b[i]);
		num[++tot] = a[i]; num[++tot] = b[i]+1;
	}
	sort(num+1, num+1+tot); tot = unique(num+1, num+1+tot)-num-1;
	rep(i, 1, n) {
		a[i] = lower_bound(num+1, num+1+tot, a[i])-num;
		b[i] = lower_bound(num+1, num+1+tot, b[i]+1)-num;
	}
	C[0] = 1; g[0] = 1;
	rep(j, 1, tot-1) {
		int len = num[j+1]-num[j];
		rep(i, 1, n) C[i] = (ll)C[i-1]*(len+i-1)%mod*inv[i]%mod;
		per(i, n, 1) if(a[i] <= j && j+1 <= b[i]) {
			int f = 0, m = 1, c = len;//m是i-p
			per(p, i-1, 0) {
				f = (f+(ll)c*g[p]%mod)%mod;
				if(a[p] <= j && j+1 <= b[p]) c = C[++m];
			} g[i] = (g[i]+f)%mod;
		}
	}
	int ans = 0; rep(i, 1, n) ans = (ans+g[i])%mod;
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：楠枫 (赞：6)

## 题解
一种思路很好想：$f_{i,j}$ 表示前 $i$ 所学校中，第 $i$ 所学校参赛且派出 $j$ 艘划艇的方案数。（转移就不列了。）

这种方式有一个致命点，就是 $j$ 的范围是 $10^9$，这样连 $9$ 分都过不去。当我们看到这么大数据范围时，一般想的都是离散化。

此时我们就可以设状态为：$f_{i,j}$ 表示前 $i$ 所学校中第 $i$ 所学校参赛，且派出的划艇数落到第 $j$ 个区间的方案数。因为一共有 $n$ 个区间，所以 $j$ 复杂度最多为 $\mathcal O(n)$。

所以在第 $i$ 所学校之前的学校可以分为两种，在区间 $j$ 的和不在的。

引理 ：

>若要从 $[0,L]$ 中选出 $n$ 个数，其中非零数严格递增，则有 $(^{L+n}_{\kern 0.6em n})$ 种可能
>

（证明请看别的大佬的题解）

那么对于本题来说，因为我们设的第 $i$ 所学校必须参赛，所以计算 $0$ 时答案需要减 $-1$ ，方案数即为 $(^{m-1+L}_{\;\;\;\ m})$，$m$ 表示挑选划艇个数在第 $j$ 个区间的学校的数量。

那么转移方程容易得出：
$$
f_{i,j}=\left\{
\begin{array}{l}
\sum_{p=1}^{i-1}\sum_{k=1}^{j-1}(^{m+L-1}_{\;\;\;\ m})f_{p,k} \kern 1.5emj\in [a_i,b_i] \\ 
0 \kern 10.8emj\notin [a_i,b_i]\\
\end{array}
\right.
$$

对于 $\sum_{p=1}^{i-1}\sum_{k=1}^{j-1}(^{m+L-1}_{\;\;\;\ m})f_{p,k}$ 我们可以用一个前缀和处理一下

则设 $g_{i,j}=\sum_{k=1}^{j}f_{i,k}$ 

那么最后的转移为
$$
f_{i,j}=\sum_{p=1}^{i-1}(^{m+L-1}_{\;\;\;\ m})g_{p,j-1} \;\;\;\ j\in[a_i,b_i]
$$
$AC \;\;\ CODE:$
```cpp
#include<bits/stdc++.h>
#define ri register int
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    inline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    inline int read() {
        ri x=0,f=1;char ch=gc();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
        return x*f;
    }
}
using IO::read;
namespace nanfeng{
    #define ll long long
    static const int N=550;
    static const int MOD=1e9+7;
    int inv[N],a[N],b[N],num[N<<1],C[N],g[N],tot,n;
    inline int main() {
        n=read();
        inv[1]=1;
        for (ri i(2);i<=n;p(i)) inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;
        for (ri i(1);i<=n;p(i)) {
            a[i]=read(),b[i]=read();
            num[p(tot)]=a[i];num[p(tot)]=b[i]+1;
        }
        sort(num+1,num+tot+1);
        tot=unique(num+1,num+tot+1)-num-1;
        for (ri i(1);i<=n;p(i)) {
            a[i]=lower_bound(num+1,num+tot+1,a[i])-num;
            b[i]=lower_bound(num+1,num+tot+1,b[i]+1)-num;
        }
        C[0]=g[0]=1;
        for (ri j(1);j<tot;p(j)) {
            int len=num[j+1]-num[j];
            for (ri i(1);i<=n;p(i)) C[i]=(ll)C[i-1]*(ll)(len+i-1)%MOD*inv[i]%MOD;
            for (ri i(n);i;--i) {
                if (a[i]<=j&&j+1<=b[i]) {
                    int f=0,cnt=1,l=C[1];
                    for (ri k(i-1);k>=0;--k) {
                        f=(f+(ll)l*g[k]%MOD)%MOD;
                        if (a[k]<=j&&j+1<=b[k]) l=C[p(cnt)];
                    }
                    g[i]=(g[i]+f)%MOD;
                }
            } 
        }
        int ans=0;
        for (ri i(1);i<=n;p(i)) ans=(ans+g[i])%MOD;
        printf("%lld\n",ans);
        return 0;
    }
    // #undef int
}
int main() {return nanfeng::main();}
```
复杂度为 $\mathcal O(n^3)$ 

---

## 作者：Star_Cried (赞：3)

## P3643 [APIO2016]划艇

### 题意

一个合法序列可表示为一个长度为 $n$ 的序列，其中第 $i$ 个数可以为 0 或 $[l_i,r_i]$ 中一个整数，且满足所有不为零的数组成的子序列严格上升。求合法序列方案数。

### 思路

朴素动态规划做法为，设 $f_{ij}$ 表示第 $i$ 个数不为零且数量为 $j$ 的方案数，则
$$
ans=\sum_{i=1}^n\sum_{j=l_i}^{r_i}f_{ij}
$$
$$
f_{ij}=\sum_{k=1}^{j-1}\sum_{q=0}^{i-1}f_{qk},j\in[l_i,r_i]
$$
但是第二维枚举太多。考虑优化。

首先，我们考虑一段区间，按照上面的方式递推需要依次枚举数量再枚举 $i-1$ 个数的方案进行转移，不能够简化的主要原因是因为每个数都有一个限定的区间。若不加限定，发现这段转移可以简化为一个简单问题：每个数可以选取值范围内任意的值或 0，求所有不为零的数组成的子序列严格上升方案数。设取值区间大小为 $len$，数的数量为 $n$，则答案为 $\binom{len+n}n$。可以理解为额外增加 $n$ 个 0 表示选 0。

所以我们进行离散化，将取值范围分为若干段，每个数的范围由若干这样的段组成。对于每一段我们都可以按照上面的方法转移。即对于这一段区间 $j$，对于所有包含它的数字，可以从 $0$ 到 $i-1$ 中任意一种状态 $k$ 转移得到，并且需要乘上在 $k$ 到 $i$ 中选任意个区间包含 $j$ 的数字不为 0 的方案数，即 $\binom{len+m-1}m$ 其中 $m$ 为上述数的个数，$len$ 为第 $j$ 段的长度，减 1 是因为第 $i$ 个必选。即
$$
ans=\sum_{i=1}^n\sum_{j=l_i}^{r_i}f_{ij}
$$
$$
f_{ij}=\sum_{q=0}^{i-1}\binom{len+m_{jq}-1}{m_{jq}}\sum_{k=1}^{j-1}f_{qk},j\in[l_i,r_i],m_{jq}=\sum_{o=q+1}^i[j\in[l_o,r_o]]
$$
发现后面的求和维护一个前缀和即可。总时间复杂度 $O(n^3)$。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=505,mod=1e9+7;
	int n,m,l[maxn],r[maxn],b[maxn<<1],C[maxn],inv[maxn],f[maxn],ans;
	inline void work(){
		n=read();
		inv[1]=1;for(int i=2;i<=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		for(int i=1;i<=n;i++) l[i]=b[(i<<1)-1]=read(),r[i]=b[i<<1]=read(),b[i<<1]++;
		sort(b+1,b+1+(n<<1));
		m=unique(b+1,b+1+(n<<1))-b-1;
		for(int i=1;i<=n;i++) l[i]=lower_bound(b+1,b+1+m,l[i])-b,r[i]=lower_bound(b+1,b+1+m,r[i]+1)-b;
		C[0]=f[0]=1;
		for(int j=1;j<m;j++){
			int len=b[j+1]-b[j];
			for(int i=1;i<=n;i++) C[i]=1ll*C[i-1]*(len+i-1)%mod*inv[i]%mod;
			for(int i=n;i;i--) if(l[i]<=j and r[i]>=j+1){
				int cnt=1;
				for(int k=i-1;~k;k--) f[i]=(f[i]+1ll*C[cnt]*f[k])%mod,cnt+=l[k]<=j and r[k]>=j+1;
			}
		}
		for(int i=1;i<=n;i++) ans=(ans+f[i])%mod;
		printf("%d\n",ans);
	}
}
signed main(){
	star::work();
	return 0;
}
```



---

## 作者：Varuxn (赞：2)

## 解题思路
先想一下最简单的打法吧。

用 $f[i][j]$ 表示前 i 所学校中，第 i 所学校参赛，且派出 j 艘划艇的方案数。

显然，$f[i][j]=1+\sum\limits_{k=1}^{i-1}\sum\limits_{k=1}^{j-1}f[k][t]$

考虑优化，我们需要的只是长度，因此可以将每个端点**离散化**，然后分段枚举

假设$\operatorname{all}(x,y)$表示 $(x \sim y)$ 所有的方案数

方案分两部分：

1.  i 从 $(j-1)\sim j$ 选一个，前面所有的学校要么不选要么从 $1\sim(j-1)$ 区间中选，方案数为 $\sum\limits_{l=1}^{i-1}\sum\limits_{r=1}^{j-1} f[l][r]\times C_{len}^1$
2.  i 从 $(j-1)\sim j$ 选一个，前面有学校也从 $(j-1)\sim j$ 中选，定第一个从 $(j-1)\sim j$ 中选的学校为 k，显然总方案数为$\operatorname{all}(k,i)\times \sum\limits_{l=1}^{k-1}\sum\limits_{r=1}^{j-1} f[l][r]$

将1和2式子合并一下就可以得到 $\sum\limits_{l=1}^{i-1}\sum\limits_{r=1}^{j-1} f[l][r]+\sum\limits_{l=1}^{k-1}\sum\limits_{r=1}^{j-1} f[l][r]$

可知 $k\sim i$ 学校一定选择 $(j-1)\sim j$ 中的数或者选择 0。

因为 k 和 i 都从 j 区间中选， $(k+1)\sim (i-1)$ 学校可以选择 j 区间的如果选的话一定从 j 区间中选，如果不选就选0，而不可以选 j 区间的一定不能派划艇。

有一个**引理**：

从区间 $[0,L]$ 中取 n 个数，要求所有非零数严格递增，则方案数为 $C_n^{L+n}$

一看这式子，直接**杨辉三角**走起，再一看数据范围。。。。十分不友善，考虑一下从以前的状态中转移过来：

$C_{n+1}^{m+1}=C_n^m\times \frac{n+1}{m+1}$

然后用**前缀和**维护一下。

 $f[i][j]$ 表示 $1\sim i$ 学校从 $1\sim j$ 区间选的方案总数,也就是下面的式子：
$f[i][j]=len\times f[i-1][j-1]+\sum\limits_{k=i-1}^{1} C_{l+p-2}^p\times f[k-1][j-1]$

## $code$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e2+10,mod=1e9+7;
int n,cnt,ans,ys[N<<1],a[N],b[N],f[N],g[N],inv[N];
void get_INV()//预处理逆元
{
	inv[0]=inv[1]=1;
    for(int i=2;i<=n;i++)
        inv[i]=((mod-mod/i)*inv[mod%i])%mod;
}
#undef int
int main()
{
	#define int long long
	scanf("%lld",&n);
	get_INV();
	for(int i=1;i<=n;i++)//离散化一下
	{
		scanf("%lld%lld",&a[i],&b[i]);
		ys[++cnt]=a[i];
		ys[++cnt]=++b[i];
	}
	sort(ys+1,ys+cnt+1);
	cnt=unique(ys+1,ys+cnt+1)-ys-1;
	for(int i=1;i<=n;i++)
	{
		a[i]=lower_bound(ys+1,ys+cnt+1,a[i])-ys;
		b[i]=lower_bound(ys+1,ys+cnt+1,b[i])-ys;
	}
	f[0]=g[0]=1;
	for(int j=1;j<cnt;j++)//递推式子应用
	{
		int len=ys[j+1]-ys[j];
		for(int i=1;i<=n;i++)
			g[i]=g[i-1]*(len+i-1)%mod*inv[i]%mod;
		for(int i=n;i>=1;i--)
			if(a[i]<=j&&j<b[i])
				for(int k=i-1,tot=1;k>=0;k--)
				{
					f[i]=(f[i]+f[k]*g[tot]%mod)%mod;
					if(a[k]<=j&&j<b[k])
						tot++;
				}
	}
	for(int i=1;i<=n;i++)//注意取mod
		ans=(ans+f[i])%mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：i207M (赞：1)

写了好久，总算是自己写出来了。~~轻度卡常~~

显然$dp[i][j]$表示填了前i个位置，第i个位置填的是j的方案数。

因为值域很大，所以我们要离散化。但是这样如何统计方案数？

先说一下离散化的方法：我们把$l,r+1$离散化，这样每个值域的区间就是左闭右开的了。

注意到如果前一个数的值域和自己不在一起，方案数很容易算。求一个前缀和即可。

否则，我们对于连续一段一起考虑，枚举在同一个连续区间的最后一个位置，转移的系数是和区间长度以及中间包含的位置数有关，可以预处理。

**注意**：

1. 对第二种情况的DP，要想好方案数里究竟有没有包含端点的选择

```cpp
#define N 505
int n;
int lm[N],rm[N];
int ui[N*2],cu;
int dp[N][N*2];
int sdp[N][N*2];
int c[N][N];
int iv[N];
int f[N*2][N];
int num[N*2];
signed main()
{
#ifdef M207
    freopen("in.in","r",stdin);
    // freopen("ot.out","w",stdout);
#endif
    in(n);
    c[0][0]=1;
    for(ri i=1; i<=n; ++i)
    {
        c[i][0]=1;
        for(ri j=1; j<=i; ++j) c[i][j]=add(c[i-1][j-1],c[i-1][j]);
    }
    for(ri i=1; i<=n; ++i)
    {
        in(lm[i],rm[i]);
        ui[++cu]=lm[i],ui[++cu]=rm[i]+1; // [ , )
    }
    lm[0]=0,rm[0]=0;
    ui[++cu]=0,ui[++cu]=1;
    sort(ui+1,ui+1+cu); cu=unique(ui+1,ui+1+cu)-ui-1;
    for(ri i=0; i<=n; ++i)
    {
        int lw=lower_bound(ui+1,ui+1+cu,lm[i])-ui;
        for(ri j=lw; ui[j]<=rm[i]; ++j) ++num[j];
    }
    for(ri i=1; i<=n; ++i) iv[i]=mdinv(i);
    for(ri i=1; i<cu; ++i)
    {
        int len=ui[i+1]-ui[i];
        for(ri j=2; j<=num[i]; ++j)
        {
            int fc=len;
            for(ri k=2; k<=j&&k<=len; ++k)
            {
                fc=mul(fc,len-k+1,iv[k]);
                inc(f[i][j],mul(fc,c[j-2][k-2]));
            }
        }
    }
    dp[0][1]=1;
    for(ri i=0; i<=n; ++i)
    {
        int lw=lower_bound(ui+1,ui+1+cu,lm[i])-ui;
        for(ri j=lw; ui[j]<=rm[i]; ++j)
        {
            int &v=dp[i][j];
            int t=v; v=(i?sdp[i-1][j-1]:0);
            if(v)
            {
                int cnt=1;
                for(ri k=i+1; k<=n; ++k)
                    if(lm[k]<=ui[j]&&ui[j]<=rm[k])
                    {
                        ++cnt;
                        inc(dp[k][j],mul(v,f[j][cnt]));
                    }
            }
            v=add(mul(v,ui[j+1]-ui[j]),t);
        }
        for(ri j=1; j<=cu; ++j) sdp[i][j]=add(sdp[i][j-1],dp[i][j]);
        if(i) for(ri j=1; j<=cu; ++j) inc(sdp[i][j],sdp[i-1][j]);
    }
    int ans=sub(sdp[n][cu],1);
    out(ans);
    return 0;
}
```


---


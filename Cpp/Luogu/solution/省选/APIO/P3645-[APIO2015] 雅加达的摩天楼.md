# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# 题解

## 作者：浮尘ii (赞：58)

根本不需要最短路算法，这是一个无权图最短路，所以直接 BFS 就行。

也不需要显式建图，直接 BFS 转移即可。

状态 $(i,j)$ 表示，当前在第 $i$ 个点，当前的 doge 跳跃能力为 $j$。

当 $j \le \sqrt{n}$ 时，只有 $n \sqrt{n}$ 个状态。

当 $j \gt \sqrt{n}$ 时，只有 $m \sqrt{n}$ 个状态（最多有 $m$ 只 doge，每只 doge 只有 $\frac{n}{j}\lt \sqrt{n}$ 个可行位置）。

$(i,j)$ 可以转移到 $(i-j, j)(i-j\ge0)$ 和 $(i+j,j) (i+j\lt n)$，同时对于第一次访问到的 $i$，把初始在 $i$ 的所有 doge 加入队列。

状态判重时使用 `std::set` 会 TLE，可以用 hash 或者 `std::bitset`。

时间复杂度 $O((n+m)\sqrt{n})$。

另外原题数据有点水，同时洛谷只取了原题的很少一部分数据所以更水，建议大家去 [UOJ](http://uoj.ac/problem/111) 提交此题以进一步检验程序正确性。

```cpp
#include <queue>
#include <tuple>
#include <bitset>
#include <cstdio>
#include <vector>
#include <algorithm>

const int maxN = 30005;

int N, M, S, T;
std::vector<int> Doge[maxN];
std::queue<std::tuple<int, int, int>> Q;
std::bitset<maxN> vis[maxN];
bool Vis[maxN];

void insert(int i, int p, int step)
{
	if (!Vis[i])
	{
		Vis[i] = true;
		for (auto x : Doge[i])
			if (!vis[i].test(x))
				vis[i].set(x), Q.emplace(i, x, step);
	}
	if (!vis[i].test(p))
		vis[i].set(p), Q.emplace(i, p, step);
}

int main()
{
	scanf("%d%d", &N, &M);
	for (int i = 0, b, p; i != M; ++i)
	{
		scanf("%d%d", &b, &p);
		if (i == 0)
			S = b;
		if (i == 1)
			T = b;
		Doge[b].push_back(p);
	}

	if (S == T)
	{
		puts("0");
		return 0;
	}

	Vis[S] = true;
	for (auto x : Doge[S])
		if (!vis[S].test(x))
		{
			vis[S].set(x);
			Q.emplace(S, x, 0);
		}

	while (!Q.empty())
	{
		int i, p, step;
		std::tie(i, p, step) = Q.front();
		Q.pop();
		if (i - p == T || i + p == T)
		{
			printf("%d\n", step + 1);
			return 0;
		}
		if (i - p >= 0)
			insert(i - p, p, step + 1);
		if (i + p < N)
			insert(i + p, p, step + 1);
	}

	puts("-1");

	return 0;
}
```

---

## 作者：wurzang (赞：9)

这题本质就是个 bfs 啊。

考虑根号分治。对于 $p > \sqrt{n}$ ，可以到达的点不超过 $\sqrt{n} $ 个；对于 $p \leq \sqrt{n}$ ，可以走的距离不超过 $\sqrt{n}$ 。

因此可以直接取 $(b,p)$ 作为状态，表示我们的 doge 在 $b$ 点，可以走的距离为 $p$ ，这个状态数量肯定不超过 $n \sqrt{n}$ 个。


然后就可以用这个状态直接去 bfs，用 bitset 判重，时间复杂度为 $\mathcal{O}(n\sqrt{n})$ 或 $\mathcal{O}(\frac{nm}{w})$

$n \leq 3 \times 10^4$，因此 bitset 复杂度正确。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30000+5;
bitset<N> vis[N];
vector<int> p[N];
struct node{
	int pos,jump,dep;
	node(){
	}
	node(int _p,int _j,int _d){
		pos=_p;jump=_j;dep=_d;
	}
};
deque<node> q;
int n,B[N],P[N];
void bfs(){
	node u;
	while(!q.empty()){
		u=q.front();q.pop_front();
		//cout<<u.pos<<" "<<u.jump<<endl;
		if(u.pos==B[1]) cout<<u.dep,exit(0);
		if(vis[u.pos][u.jump]) continue;
		vis[u.pos][u.jump]=1;
		for(int i=0;i<p[u.pos].size();++i)
			q.push_front(node(u.pos,p[u.pos][i],u.dep));
		if(u.pos-u.jump>=0) q.push_back(node(u.pos-u.jump,u.jump,u.dep+1));
		if(u.pos+u.jump<n) q.push_back(node(u.pos+u.jump,u.jump,u.dep+1));
	}
	cout<<-1;
}
int main(){
	int m;
	cin>>n>>m;
	for(int i=0;i<m;++i){
		cin>>B[i]>>P[i];
		p[B[i]].push_back(P[i]);
	}
	q.push_back(node(B[0],P[0],0));
	bfs();
	return 0;
}
 
```


---

## 作者：chu_yh (赞：5)

题解区大部分代码无法通过数据更强的[UOJ111【APIO2015】Jakarta Skyscrapers](https://uoj.ac/problem/111)，建议阅读我的，自认为写的最好的一集。建议提交前往 UOJ111。如果写得好，就点个赞吧。

~~水题~~。题面不难理解，我们直接进入正题。

### 解题思路

发现神秘生物反复横跳（~~好像跳蚤~~）会产生多个状态，定义一个三元组 $(\mathrm{pos},x,\mathrm{step})$ 表示 doge 的状态：**信息用了 $\mathrm{step}$ 步到位于大楼 $\mathrm{pos}$ 的跳跃能力（之后简称弹力）为 $x$ 的 doge 那里**。

先别着急 DP，发现状态的转移分为两种：

- 同一栋楼里的 doge 传递信息，**步数不变**。
- 一只 doge 跳到其他楼里，**步数加一**。

发现越往后转移，步数只有可能更大。联想到图的遍历，每个状态类比为图上的节点。同样，离初始节点（也就是初始状态）越远的节点所需的步数越多，于是，我们就能用一种类似与 BFS 的方法，先把离初始节点近的点处理了，再去处理远的，保证了答案的正确性。

### 具体实现

因为同一楼内信息可无代价传递给楼内的所有 doge，我们再定义一个二元组 $(\mathrm{pos},\mathrm{step})$ 表示**信息用了 $\mathrm{step}$ 步到了大楼 $\mathrm{pos}$**，称为楼 $\mathrm{pos}$ 的状态。楼的状态其实包含了目前在楼内的所有 doge 的状态，下文所说把某栋楼的状态压入队，其实就是把目前在楼内的所有 doge 的状态压入队。

具体的，用个 `vector` 储存每栋楼里 doge 的弹力。先让起始状态 $(s,0)$（$s$ 为 $0$ 号 doge 所在楼的编号）入队。开始广度优先遍历。注意，队列中的是 doge 的状态！

- 取出队首状态 $(\mathrm{pos},x,\mathrm{step})$；
- 判断其下一步能否到达 $t$（即 $1$ 号 doge 所在楼）。如果能，找到答案，结束程序。
- 分别向左右跳（向左右转移状态），注意判断是否出界。

重复上述过程即可。

### 时间复杂度证明

利用根号分治思想。每只弹跳力为 $p$ 的 doge 可延伸出的状态数只有 $\sqrt n$ 种，共 $n$ 只 doge，时间复杂度 $O(n \sqrt n)$。

### 代码实现

#### 节省内存小技巧

由上面的具体实现可知，我们需要把 doge 的状态和楼的状态分别建判重数组。楼的状态很好开，只需给总共 $n(n\le30000)$ 栋楼开就好了（不需要管步数）。但 doge 的状态就难办了：要开 $n^2$ 的 `bool` 型数组。

考虑使用 `bitset`。可以将 `bitset` 理解为 `bool` 型数组。但 `bitset` 每个元素仅占 $1$ 比特，$N$ 位仅占用 $N \over 8$ 字节。

使用范例：

```cpp
#include<bitset> //头文件准备
#include<iostream>
bitset<100> b;// -> bool b[100];

int main(){
    for(int i=0;i<100;i++) std::cin>>b[1];
    b[6]=true;
    for(int i=0;i<100;i++) if(b[i]) std::cout<<b[i]<<std::endl;
    return 0;
}
```

#### 把 doge 的状态压入队：`Push` 函数

```cpp
struct doge{int pos,x,step;};//队列状态:用了step步到有跳跃能力为x的doge的大楼pos
queue<doge> q;//BFS

void Push(doge u){
	if(!b[u.pos][u.x])//判断该状态是否已进入过队
        b[u.pos][u.x]=1,q.push(u);
}
```

#### 把楼 $pos$ 的状态压入队并标记：`mark` 函数

```cpp
void mark(int pos,int step){//把楼pos的状态压入队并标记
	vis[pos]=true;//别忘了打标记
	for(int P:p[pos]) Push((doge){pos,P,step});//把目前在楼内的所有doge的状态压入队
}
```

#### 状态的转移：`turn` 函数

```cpp
void turn(register doge u,register bool F=0){//转移状态
	u.step++,u.pos+=F?u.x:-u.x;
	Push(u);//别忘了自己入队
	if(!vis[u.pos]) mark(u.pos,u.step);
}
```

#### Code

自认为本代码是题解区可读性最高的了。本代码需要吸氧（其实能过 UOJ111 的都要吸氧），有兴趣的话可以尝试卡常。

```cpp
#include<queue>
#include<cstdio>
#include<vector>
#include<bitset>
using namespace std;
inline int read(){
	register int X=0;register bool F=0;register char C=getchar();
	while(C<'0'||'9'<C){F=0;if(C=='-') F=1;C=getchar();}
	while('0'<=C&&C<='9'){X=(X<<3)+(X<<1)+(C^'0');C=getchar();}
	return F?-X:X;
}
const int N=3e4+2;
int n,m,s,t;
vector<int> p[N];//p[i]表示楼i上的doge的弹力p的集合
bitset<N> b[N];//bitset节省内存,就是省内存的bool b[N][N]
//状态判重,b[pos][x]表示"弹力为x的doge到大楼pos"的状态是否出现过
struct doge{int pos,x,step;};
//队列状态:用了step步到有跳跃能力为x的doge的大楼pos
queue<doge> q;//BFS
bool vis[N];//vis[i] 标记大楼i是否到过

void Push(doge u){//doge的状态入队
	if(!b[u.pos][u.x]) b[u.pos][u.x]=1,q.push(u);
}

void mark(int pos,int step){//把楼pos的状态压入队并标记
	vis[pos]=true;
	for(int P:p[pos]) Push((doge){pos,P,step});
}

void turn(register doge u,register bool F=0){//转移状态
	u.step++,u.pos+=F?u.x:-u.x;
	Push(u);
	if(!vis[u.pos]) mark(u.pos,u.step);
}

int main(){
	n=read(),m=read();
	s=read();
	p[s].push_back(read());
	t=read();
	p[t].push_back(read());//留意读入顺序!!!
	if(s==t){putchar('0');return 0;}
	for(register int i=2,d;i<m;i++){
		d=read();
		p[d].push_back(read());
	}
	mark(s,0);//出发
	while(!q.empty()){
		doge u=q.front();
		q.pop();
		if(u.pos-u.x==t||u.pos+u.x==t){
			printf("%d",u.step+1);
			return 0;
		}
		if(u.pos-u.x>=0) turn(u);
		if(u.pos+u.x<n) turn(u,1);
	}
	putchar('-'),putchar('1');
	return 0;
}
```

### 从本题我们能学到什么

1. `bitset` 的省内存小技巧：代替开不下的 `bool` 型数组。
1. BFS 状态观：把广度优先遍历的对象像 DP 一样看作许多状态。
1. 大小状态包含技巧：楼的大状态包含 doge 的小状态，带动理解，清晰思路。

---

完结撒花！感谢你的耐心。

---


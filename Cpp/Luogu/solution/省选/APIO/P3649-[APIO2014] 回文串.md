# [APIO2014] 回文串

## 题目描述

给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。

对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。


## 说明/提示

【样例解释1】

用 $\lvert s \rvert$ 表示字符串 $s$ 的长度。

一个字符串 $s_1 s_2 \dots s_{\lvert s \rvert}$ 的子串是一个非空字符串 $s_i s_{i+1} \dots s_j$，其中 $1 \leq i \leq j \leq \lvert s \rvert$。每个字符串都是自己的子串。

一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。

这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。

所以回文子串中最大的存在值为 $7$。



第一个子任务共 8 分，满足 $1 \leq \lvert s \rvert \leq 100$。

第二个子任务共 15 分，满足 $1 \leq \lvert s \rvert \leq 1000$。

第三个子任务共 24 分，满足 $1 \leq \lvert s \rvert \leq 10000$。

第四个子任务共 26 分，满足 $1 \leq \lvert s \rvert \leq 100000$。

第五个子任务共 27 分，满足 $1 \leq \lvert s \rvert \leq 300000$。


## 样例 #1

### 输入

```
abacaba
```

### 输出

```
7
```

## 样例 #2

### 输入

```
www```

### 输出

```
4```

# 题解

## 作者：bztMinamoto (赞：44)

这题不是回文自动机的板子么……为啥没人用回文自动机写啊……

蒟蒻就大言不惭的来讲一讲这玩意儿好了->[广告](https://www.cnblogs.com/bztMinamoto/p/9630617.html)

# 前言

刚学完manacher就来学回文自动机……

感觉好像（板子）也不是很难（背）？

前置知识：Manacher（也不一定非要因为和这个没啥关系），知道自动机是个啥以及怎么建

# 简述

回文树和回文自动机指的是同一个东西

是由某西伯利亚人于2014夏发明的

这东西主要是用于计数，计算回文串的个数以及种类啥的

# 建树

图我就不放了（太乱了放了也看不懂），要看图的话可以去这位大神的blog里看一下->[这里](https://blog.csdn.net/Clove_unique/article/details/53750322)

不过个人感觉看文字描述应该就会了……吧……

首先，回文树里有两棵树，分别记录长度为奇数和偶数的回文串

每个节点代表一个回文串，记录转移$x$，表示如果在这个回文串前后都加上字符$x$形成的回文串是子节点的子串

然后每一个节点记录一个fail指针，指向这个回文串的最长后缀回文串

然后我们考虑建树，假设已经建好了串$s[1...i-1]$，要把字符$s[i]$插入这棵树

那么每一次只会把$s[1...i]$的最长后缀回文串加进树里。

证明：（抄[这里](https://www.cnblogs.com/nietzsche-oier/p/6935081.html)的）

我们设后缀回文$i$是最长后缀回文$k$的子串，那么$i$肯定关于$k$的回文中心有一个对称串$j$，由于$k$本身是对称的，所以$j$和$i$是相同的，那么$j$已经被加入到回文树中，所以$i$不必再加入

然后就没问题了。我们设最长回文后缀为$k$，加入字符$c$，那么如果可以，最长回文后缀会变成$ckc$

然而如果$k$之前的字母不是$c$怎么办？这个时候$fail$指针就派上用场了。我们用$fail$维护每一个节点的最长后缀回文，如果$k$不行，我们看看$k$的最长后缀回文是否可行（就是看$k$的最长后缀回文的前一个字母是否等于$c$），然后就这样一直跳$fail$指针直到找到为止（如果一直没有找到会跳到根节点，下面再说）

然后如何维护$fail$呢？我们只要找到了当前节点的最长回文后缀然后记录一下就就好了

然后字符要接在之前的串的后面，记录一下$last$表示上一个串的节点

然后注意特殊处理两个根节点，$0$代表长度为偶数的后缀的根，$1$代表长度为$1$的后缀的根，我们令$fail[0]$指向$1$，$len[1]=-1$，然后令$s[0]=-1$（或任何一个不在原串中出现的字符）（$len$代表这个节点的串长）

就比如说如果跳的时候一直找不到回文怎么办？这个时候这个节点就单独形成一个回文串，那么我们在判断$s[i-len[x]-1]==s[i]$的时候，因为$len[1]=-1$，所以必定会停止，那么就不用担心会无限跳下去了

然后来几道题吧

[洛谷P3649 [APIO2014]回文串](https://www.luogu.org/problemnew/show/P3649)

这就是一个板子，顺便记录一下出现次数就好了

然后该有的注解都会写在代码里
```
//minamoto
#include<cstdio>
#include<cstring>
#define ll long long
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
const int N=3e5+5;
char s[N];
int n,p,q,fail[N],cnt[N],len[N],tot,last,ch[N][26];
ll ans;
inline int newnode(int x){
	//建立一个新节点，长度为x 
    len[++tot]=x;return tot;
}
inline int getfail(int x,int n){
	//跳fail指针知道找到后缀回文为止 
    while(s[n-len[x]-1]!=s[n]) x=fail[x];
    return x;
}
int main(){
    scanf("%s",s+1);
    //一堆乱七八糟的初始化 
    s[0]=-1,fail[0]=1,last=0;
    len[0]=0,len[1]=-1,tot=1;
    for(int i=1;s[i];++i){
        s[i]-='a';
        //找到可以回文的位置 
        p=getfail(last,i);
        if(!ch[p][s[i]]){
        	//如果有了转移就不用建了，否则要新建 
            //前后都加上新字符，所以新回文串长度要加2 
            q=newnode(len[p]+2);
            //因为fail指向的得是原串的严格后缀，所以要从p的fail开始找起 
            fail[q]=ch[getfail(fail[p],i)][s[i]]; 
            //记录转移 
            ch[p][s[i]]=q;
        }
        ++cnt[last=ch[p][s[i]]];
    }
    for(int i=tot;i;--i)
    cnt[fail[i]]+=cnt[i],cmax(ans,1ll*cnt[i]*len[i]);
    printf("%lld\n",ans);
    return 0;
}
```
[洛谷P4287 [SHOI2011]双倍回文](https://www.luogu.org/problemnew/show/P4287)

我们肯定要先建出回文自动机的

然后如果是枚举每一个节点暴跳fail指针肯定得T

那么我们对于每一个节点记录一个$trans[i]$，表示小于等于它长度一半的节点

这个可以在建自动机的时候顺便求出来，具体看代码

然后对每一个节点判断长度是否模4为0且$trans[i]$的长度是它的一半就好了
```
//minamoto
#include<cstdio>
#include<cstring>
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
const int N=500005;
int fail[N],ch[N][26],cnt[N],len[N],trans[N];
int n,m,tot,last,p,q,ans;
char s[N];
inline int newnode(int x){
    len[++tot]=x;return tot;
}
inline int getfail(int x,int n){
    while(s[n-1-len[x]]!=s[n]) x=fail[x];return x;
}
void build(){
    for(int i=1;s[i];++i){
        int x=s[i]-'a';
        p=getfail(last,i);
        if(!ch[p][x]){
            q=newnode(len[p]+2);
            fail[q]=ch[getfail(fail[p],i)][x];
            ch[p][x]=q;
            if(len[q]<=2) trans[q]=fail[q];
            else{
                int tmp=trans[p];
                while(s[i-1-len[tmp]]!=s[i]||(len[tmp]+2)*2>len[q]) tmp=fail[tmp];
                trans[q]=ch[tmp][x];
            }
        }
        cnt[last=ch[p][x]]++;
    }
}
int main(){
//	freopen("testdata.in","r",stdin);
    scanf("%d",&n);
    scanf("%s",s+1);
    s[0]=-1,fail[0]=1,last=0;
    len[0]=0,len[1]=-1,tot=1;
    build();
    for(int i=tot;i>=2;--i) cnt[fail[i]]+=cnt[i];
    for(int i=2;i<=tot;++i)
    if((len[trans[i]]<<1)==len[i]&&len[i]%4==0) cmax(ans,len[i]);
    printf("%d\n",ans);
    return 0;
}
```
[洛谷P4762 [CERC2014]Virus synthesis](https://www.luogu.org/problemnew/show/P4762)

先建一个回文自动机，然后记$dp[i]$表示转移到$i$节点代表的回文串的最少的需要次数

首先肯定2操作越多越好，经过2操作之后的串必定是一个回文串，所以最后的答案肯定是由一个回文串+不断暴力添加得来，那么答案就是$min(ans,dp[i]+n-len[i])$

然后对于一个串$i$，如果它在前面和后面加上一个字母可以形成回文串$j$，则$dp[j]=dp[i]+1$

为啥嘞？我们可以假设在形成$i$的之前一步把这个字母加上去，执行2操作后就可以变成$j$了

然后我们可以fail指针找到最长的回文串$x$满足$len[x]<=len[i]/2$，那么$dp[i]=min(dp[i],dp[x]+1+len[i]/2-len[x])$（先暴力填好一半，剩下的用2操作）

然后可以用队列记录状态，保证转移至有序的

至于怎么找$x$，我们可以直接在建自动机的时候顺便求出来，就是多跳几次。这个看代码好了
```
//minamoto
#include<cstring>
#include<cstdio>
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
const int N=2e5+5,M=5;
char s[N];int dp[N],len[N],fail[N],ch[N][M];
int trans[N],last,p,q,str[N],tot,ans,n,qu[N];
int val[105];
inline int newnode(int x){
    len[++tot]=x;memset(ch[tot],0,sizeof(ch[tot])*5);return tot;
}
inline int getfail(int x,int n){
    while(s[n-len[x]-1]!=s[n]) x=fail[x];return x;
}
inline void init(){
    val['A']=0,val['T']=1,val['C']=2,val['G']=3;
    s[0]=-1,fail[0]=1,last=0;
    len[0]=0,len[1]=-1,tot=1;
    memset(ch[0],0,sizeof(int)*5),memset(ch[1],0,sizeof(int)*5);
}
void ins(int c,int i){
    p=getfail(last,i);
    if(!ch[p][c]){
        q=newnode(len[p]+2);
        fail[q]=ch[getfail(fail[p],i)][c];
        ch[p][c]=q;
        if(len[q]<=2) trans[q]=fail[q];
        else{
            int tmp=trans[p];
            while(s[i-1-len[tmp]]!=s[i]||(len[tmp]+2)*2>len[q]) tmp=fail[tmp];
            trans[q]=ch[tmp][c];
        }
    }
    last=ch[p][c];
//    printf("%d\n",last);
}
int main(){
//    freopen("testdata.in","r",stdin);
    int T;scanf("%d",&T);
    while(T--){
        scanf("%s",s+1);
        init(),ans=n=strlen(s+1);
        for(int i=1;i<=n;++i) ins(val[s[i]],i);
        for(int i=2;i<=tot;++i) dp[i]=len[i];
        int h=1,t=0;qu[++t]=0,dp[0]=1;
        while(h<=t){
            int u=qu[h++];
            for(int i=0;i<4;++i){
                int x=ch[u][i];
                if(!x) continue;
                dp[x]=dp[u]+1;
                int y=trans[x];
                cmin(dp[x],dp[y]+1+len[x]/2-len[y]);
                cmin(ans,dp[x]+n-len[x]);
                qu[++t]=x;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
妈耶我感觉我整个人都自动机了……

---

## 作者：Treeloveswater (赞：24)

看楼上各位Dalao都是用的回文树等数据结构做的，真是太神了。


这道题网上普遍有3种做法：

1.回文树裸题 2.SAM+manacher 3.SA+manacher


后两者的大体思路都是结合manacher性质找出所有回文串，然后上数据结构统计次数的。


我来介绍一种只用后缀自动机的做法。


这种做法是从2015年国家集训队论文中看来，张天扬也没有进行详细地解答，也找不到《APOI2014 回文串 解题报告》，只能靠自己对着标程一点一点理解。


这种做法的大体是这样的：对于原串建立SAM，对于每个状态我们保存其endpos的maxpos。然后将反串放上去跑（我们通过从右往左扫来实现，所以下述的所有位置都是指的原串的位置）。如果当前反串中的匹配串[l,r]覆盖了当前节点的maxpos，那么[l,maxpos]是一个回文串。


  　　
    ![](http://i1.bvimg.com/629163/48b4c06eeaa99623s.png)

这样的话，我们就可以通过状态出现的次数，轻松地算出贡献了。

  
接着我们要不断跳link边（也就是跳后缀树上的边），再次统计答案。并标记经过的点，之后不再经过已标记的点。


那么我们会有几个疑惑。


1.为什么要记录maxpos？为什么这样是对的？


![](http://i1.bvimg.com/629163/f78149666825ddc9s.png)

我们假设绿色位置也属于该状态的endpos，同时红绿两点间形成一个回文串，而反串位置和maxpos间无法形成回文。


设反串位置为i，绿色位置为pos，匹配长度为len


已知pos-len<i，由于该状态的maxlen一定大于len,[i,pos]是个回文串

所以[maxpos-len,maxpos]这个区间也是个回文串。这个回文串的答案会在maxpos-len的时候贡献。


所以记录maxpos一定是对的。


2.为什么要跳link边？


已知，link边指向的节点，代表着该后缀的最长不同endpos的后缀，同时link边指向的节点的maxpos必定大于等于当前节点的maxpos。也就是说在link边指向的节点可能存在更优解，我们需要进行更新的答案。但注意当你跳link的时候，匹配的长度就不再是len了，而是该状态的maxlen。


打标记是为了优化常数。


这样这个题就解决了。


至于打标记为什么不会漏解的问题，我现在也没想明白。等明白了再更新。


看看代码可能大家就懂了。


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define o 1000011
#define ll long long
using namespace std;

struct node{
    int link,len,nxt[26],maxpos;
    void clear(){
        link=-1;len=0;maxpos=0;
        for(int i=0;i<26;i++) nxt[i]=0;
    }
}st[o];
char s[o];
int size,last,len,b[o],cc[o];
ll dp[o],ans;
bool vis[o];
void init(){
    st[0].clear();
    size=last=0;
}
void insert(char c,int pos){
    int cur=++size;
    st[cur].clear();
    st[cur].len=st[last].len+1;
    st[cur].maxpos=pos;
    dp[cur]=1;
    int p,x=c-'a';
    for(p=last;p!=-1&&!st[p].nxt[x];p=st[p].link) st[p].nxt[x]=cur;
    if(p==-1)
        st[cur].link=0;
    else{
        int q=st[p].nxt[x];
        if(st[p].len+1==st[q].len)
            st[cur].link=q;
        else{
            int clone=++size;
            st[clone].clear();
            st[clone].len=st[p].len+1;
            st[clone].link=st[q].link;
            st[clone].maxpos=st[q].maxpos;
            for(int i=0;i<26;i++) st[clone].nxt[i]=st[q].nxt[i];
            for(;p!=-1&&st[p].nxt[x]==q;p=st[p].link) st[p].nxt[x]=clone;
            st[q].link=st[cur].link=clone;
        }
    }
    last=cur;
}
int main(){
    init();
    scanf("%s",s);
    len=strlen(s);
    for(int i=0;i<len;i++) insert(s[i],i);
    for(int i=0;i<=size;i++) cc[st[i].len]++;
    for(int i=1;i<=len;i++) cc[i]+=cc[i-1];
    for(int i=0;i<=size;i++) b[--cc[st[i].len]]=i; 
    for(int i=size;i;i--){
        st[st[b[i]].link].maxpos=max(st[st[b[i]].link].maxpos,st[b[i]].maxpos);
        dp[st[b[i]].link]+=dp[b[i]];
    }
    int now=0,l=0;
    for(int i=len-1;i>=0;i--){
        while(now&&!st[now].nxt[s[i]-'a']){
            now=st[now].link;
            l=st[now].len;
        }
        if(st[now].nxt[s[i]-'a']){
            now=st[now].nxt[s[i]-'a'];
            l++;
        }
        if(st[now].maxpos<i+l){
            if(i<=st[now].maxpos)
                ans=max(ans,(ll)(st[now].maxpos-i+1)*dp[now]);
            for(int p=st[now].link;p!=-1&&!vis[p];p=st[p].link){
                vis[p]=true;
                if(i<=st[p].maxpos&&st[p].maxpos<=i+st[p].len-1)
                    ans=max(ans,(ll)(st[p].maxpos-i+1)*dp[p]);
            }    
        }        
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：beretty (赞：22)

这道题好像是一道回文树裸题

~~但是我并不会回文树~~

可以用SA＋manacher或SAM+manacher

最近刚学$SAM$，所以用$SAM+manacher$过掉了这道题

首先先对原串建立$SAM$

然后跑$manacher$，一旦有回文串就在SAM上进行查询

查询$S(l , r)$在原串中出现多少次

暴力查询一次的复杂度是$O(n)$

总复杂度$O(n^2)$

显然不能通过此题

所以我们可以考虑用倍增快速查询出$S(l,r)$在原串中出现次数

设$st[i][j]$表示$SAM$上的节点i向上跳$2^j$步能到达哪个节点

如果当前节点的$step >= r - l + 1$就说明要查询的回文串仍然是当前节点的一个后缀

就一直往上跳到不能再跳为止

此时的节点所代表的子串的$right$集合大小就是$S(l,r)$在原串中的出现次数辣

这样的时间复杂度$O(nlogn)$，可以通过此题

上代码↓


```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
# define LL long long
const int M = 600005 ;
using namespace std ;
char s[M] ;
int n , m ;
LL Ans ;
int Last , cnt ;
int size[M] , son[M][26] , fa[M] , step[M] , c[M] , b[M] ;
int p[M] , r[M] , fir[M] ;
int pos[M] , lg[M] , dep[M] , st[M][20] ;
inline void Insert(int c , int id){
    int np = ++cnt , p = Last ;  step[np] = step[p] + 1 ; 
    Last = cnt ; size[np] = 1 ; pos[id] = np ;
    while(!son[p][c] && p) son[p][c] = np , p = fa[p] ;
    if(!p) fa[np] = 1 ;
    else {
        int q = son[p][c] ;
        if(step[q] == step[p] + 1) fa[np] = q ;
        else{
            int nq = ++cnt ; step[nq] = step[p] + 1 ;
            memcpy(son[nq] , son[q] , sizeof(son[q])) ;
            fa[nq] = fa[q] ; fa[q] = fa[np] = nq ;
            while(son[p][c] == q) son[p][c] = nq , p = fa[p] ;
        }
    }
}
inline void Build(){
    Last = cnt = 1 ;
    for(int i = 1 ; i <= n ; i ++) Insert(s[i] - 'a' , i) ;
    for(int i = 1 ; i <= cnt; i ++) c[step[i]] ++ ;
    for(int i = 1 ; i <= n ; i ++) c[i] += c[i - 1] ;
    for(int i = 1 ; i <= cnt; i ++) b[c[step[i]]--] = i ;
    for(int i = cnt , p ; i ; i --) {
        p = b[i] ;
        size[fa[p]] += size[p] ;
    }
    for(int i = 1 , p ; i <= cnt ; i ++) {
    	p = b[i] ;
    	dep[p] = dep[fa[p]] + 1 ;
    	st[p][0] = fa[p] ;
    	for(int j = 1 ; (1<<j) <= dep[p] ; j ++)
    	  st[p][j] = st[st[p][j - 1]][j - 1] ;
	}
}
inline void Check(int l , int r){
    if(l < 1 || r > n) return ;
    int now = pos[r] ;
    for(int i = lg[dep[now]] ; i >= 0 ; i --) {
    	int temp = st[now][i] ;
    	if(step[temp] >= r - l + 1) now = temp ;
	}
	Ans = max(Ans , 1LL * size[now] * (r - l + 1)) ;
}
inline void Manacher() {
    p[++m] = '@' ;
    for(int i = 1 ; i <= n ; i ++) p[++m] = '#' , p[++m] = s[i] , fir[m] = i ;
    p[++m] = '#' ; p[++m] = '$' ;
    int pos = 0 , mx = 0 ;
    for(int i = 1 ; i <= m ; i ++) {
        if(i < mx) r[i] = min(mx - i , r[pos * 2 - i]) ;
        else r[i] = 1 ;
        Check(fir[i - r[i] + 2] , fir[i + r[i] - 2]) ;
        while(p[i - r[i]] == p[i + r[i]]) ++r[i] , Check(fir[i - r[i] + 2] , fir[i + r[i] - 2]) ;
        if(i + r[i] > mx) 
          mx = i + r[i] , pos = i ;
    }
}
int main(){
    scanf("%s",s + 1) ; n = strlen(s + 1) ;
    for(int i = 2 ; i <= n ; i ++) lg[i] = lg[i >> 1] + 1 ;
	Build() ; Manacher() ;
    printf("%lld\n",Ans) ;
    return 0 ;
}
```

---

## 作者：苏联元帅 (赞：9)

作为一个不会manacher和ｓａｍ的蒟蒻这个题也是可以做的。
用二分哈希找回文串，根据本质不同回文子串数量不超过O(n)级别的结论，对于每个中间位置从大到小枚举长度，将枚举过的串扔进哈希表去重，如果遇到一个串已经枚举过，该位置不会再可能有不同的回文子串了。不重不漏地枚举回文子串后，用后缀数组ｒｍｑ二分快速统计子串出现次数。总复杂度O(nlogn)

```cpp
#pragma GCC optimize("Ofast")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4")
#include <stdio.h>
#include <iostream>
#include <cstring>
using namespace std;
const int maxn=300000*2+100;
char s2[maxn],s[maxn];
int n,len;
typedef long long ll;
const ll P=307;
const ll Q=311;
const ll R=257;
ll hash1[maxn],hash2[maxn],f[maxn];
ll hash3[maxn],hash4[maxn],f2[maxn];
ll hash5[maxn],hash6[maxn],f3[maxn];
int cntsum[maxn];
const long long ha=1e9+79;
const long long ha2=1e9+9;
const long long ha3=1004535809;
inline ll getphash(int x,int y)
{
    long long qq=(hash1[y]-hash1[x-1]*f[y-x+1])%ha;
    return (qq>=0)?qq:qq+ha;
}
inline ll getshash(int x,int y)
{
    long long qq=(hash2[x]-hash2[y+1]*f[y-x+1])%ha;
    return (qq>=0)?qq:qq+ha;	
}

inline long long getphash2(int x,int y)
{
    long long qq=(hash3[y]-hash3[x-1]*f2[y-x+1])%ha2;
    return (qq>=0)?qq:qq+ha2;
}
inline long long getshash2(int x,int y)
{
    long long qq=(hash4[x]-hash4[y+1]*f2[y-x+1])%ha2;
    return (qq>=0)?qq:qq+ha2;
}
inline ll getphash3(int x,int y)
{
    long long qq=(hash5[y]-hash5[x-1]*f3[y-x+1])%ha3;
    return (qq>=0)?qq:qq+ha3;
}
inline ll getshash3(int x,int y)
{
    long long qq=(hash6[x]-hash6[y+1]*f3[y-x+1])%ha3;
    return (qq>=0)?qq:qq+ha3;	
}
const int mod=1e7+19;
struct Hashtable
{
    ll v1,v2;
    int next;
}e[(int)1e6];
int head[mod]={0},ecnt=0;
inline bool insert(ll v1,ll v2)
{
    int h=v1%mod;
    for(int k=head[h];k;k=e[k].next)
    {
        if(e[k].v1==v1&&e[k].v2==v2)
            return false;
    }	
    ++ecnt;
    e[ecnt].v1=v1;
    e[ecnt].v2=v2;

    e[ecnt].next=head[h];
    head[h]=ecnt;
    return true;
}
int sa[maxn],x[maxn],y[maxn],height[maxn],rnk[maxn],c[maxn];
void buildsa(int m)
{
    x[n]=y[n]=-1;
    for(int i=1;i<=m;i++)
        c[i]=0;
    for(int i=0;i<n;i++)
        c[x[i]=s[i]]++;
    for(int i=1;i<=m;i++)
        c[i]+=c[i-1];
    for(int i=n-1;i>=0;i--)
        sa[--c[x[i]]]=i;
    for(int k=1;k<n;k<<=1)
    {
        int p=0;
        for(int i=n-k;i<n;i++)
            y[p++]=i;
        for(int i=0;i<n;i++)
        {	
            if(sa[i]>=k)
                y[p++]=sa[i]-k;
        }
        for(int i=0;i<=m;i++)
            c[i]=0;
        for(int i=0;i<n;i++)
            c[x[y[i]]]++;
        for(int i=1;i<=m;i++)
            c[i]+=c[i-1];
        for(int i=n-1;i>=0;i--)
            sa[--c[x[y[i]]]]=y[i];
        swap(x,y);
        x[sa[0]]=m=0;
        for(int i=1;i<n;i++)
        {
            if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])
                x[sa[i]]=m;
            else
                x[sa[i]]=++m;
        }
        ++m;
        if(n==m)
            break;
    }
}
void buildheight()
{
    for(int i=0;i<n;i++)
        rnk[sa[i]]=i;
    int k=0;	
    for(int i=0;i<n;i++)
    {	
        if(!rnk[i])
            continue;
        int j=sa[rnk[i]-1];
        if(k)
            --k;
        while(s[i+k]==s[j+k])
            ++k;
        height[rnk[i]]=k;
    }
}
int rmq[(int)3e5+100][20];
int log[(int)3e5+100];
void buildrmq()
{
    log[1]=0;
    for(int i=2;i<=n;i++)
        log[i]=log[i>>1]+1;
    for(int i=1;i<n;i++)
        rmq[i][0]=height[i];
    for(int j=1;j<20;j++)
    for(int i=1;(1<<j)+i-1<n;i++)
        rmq[i][j]=min(rmq[i][j-1],rmq[i+(1<<(j-1))][j-1]);
}
inline int queryrmq(int l,int r)
{
    int lg=log[r-l+1];
    return min(rmq[l][lg],rmq[r-(1<<lg)+1][lg]);
}
inline int count(int x,int y)
{
    int l=0,r=rnk[x];
    while(r>l)
    {
        int mid=(l+r)>>1;
        if(queryrmq(mid+1,rnk[x])>=y-x+1)
            r=mid;
        else
            l=mid+1;
    }
    int lb=l,rb;
    if(height[rnk[x]+1]<y-x+1)
        rb=rnk[x];
    else
    {
        l=rnk[x]+1,r=n;
        while(r-l>1)
        {
            int mid=(l+r)>>1;
            if(queryrmq(rnk[x]+1,mid)>=y-x+1)
                l=mid;
            else
                r=mid;
        }
        rb=l;
    }
    return rb-lb+1;
}

int main()
{
//	freopen("palindrome.in","r",stdin);
//	freopen("palindrome.out","w",stdout);
    scanf("%s",s);
    n=strlen(s);
    buildsa(300);
    buildheight();
    buildrmq();

    char* t=s2;
    *t++='#';
    for(char* x=s;*x;x++)
        *t++=*x,*t++='#';
    len=2*n+1;
    f[0]=1;
    f2[0]=1;
    for(int i=1;i<maxn;i++)
    {
        f[i]=f[i-1]*P%ha; 
        f2[i]=f2[i-1]*Q%ha2;
    }
    hash3[0]=hash1[0]=s2[0];
    for(int i=1;i<len;i++)
    {
        hash1[i]=(hash1[i-1]*P+s2[i])%ha;
        hash3[i]=(hash3[i-1]*Q+s2[i])%ha2;
    }
    hash4[len-1]=hash2[len-1]=s2[len-1];	
    for(int i=len-2;i>=0;i--)
    {
        hash2[i]=(hash2[i+1]*P+s2[i])%ha;
        hash4[i]=(hash4[i+1]*Q+s2[i])%ha2;
    }
    for(int i=1;i<len;i++)
    {
        if(s2[i]!='#')
            cntsum[i]=cntsum[i-1]+1;
        else
            cntsum[i]=cntsum[i-1];
    }
    ll ans=0;
    for(int i=0;i<len;i++)
    {
        int l=1,r=min(i+1,len-i)+1;
        while(r-l>1)
        {
            int mid=(l+r)>>1;
            if(getphash(i-mid+1,i)==getshash(i,i+mid-1)&&getphash2(i-mid+1,i)==getshash2(i,i+mid-1))
                l=mid;
            else
                r=mid;
        }

        if(l==1&&s2[i]=='#')
            continue;
        
        int le,st,ed;
        if(s2[i]=='#')
        {
            le=(l-1)/2;
            st=i/2-1-le+1;	
            ed=st+le*2-1;
        }
        else
        {
            le=l/2;
            st=i/2-le+1;		
            ed=st+le*2-2;
        }
        for(int j=0;;j++)
        {
            int p=st+j;
            int q=ed-j;
            int pp=p*2+1,qq=q*2+1;
            if(p<=q&&insert(getphash(pp,qq),getphash2(pp,qq)))
                ans=max(ans,(ll)count(p,q)*(q-p+1));
            else
                break;
        }
    }	
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：wzj423 (赞：8)

第一次做到把manacher和SA结合的题目......
#### 基本思路
用Manacher统计出所有的回文子串,再使用后缀数组SA统计出所有此类子串的出现次数,统计答案.
#### 细化思路-manacher
由于回文子串可能有很多(所以可能爆int),所以不能暴力统计,必须利用Manacher算法的一个性质:
```cpp
	for(int i=1;i<len;++i) {
		if(mx>i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ms[i+p[i]]==ms[i-p[i]]) {
			++p[i];	
			if(i+p[i]>mx) {
				//只有在这里突破了mx的子串才是之前没有出现过的回文子串.
                //算入分隔符#的限制的话.
				calc(i-p[i]+1,i+p[i]-1);
			}
		}
		if(p[i]+i>mx) {
			mx=i+p[i],id=i;
		}
	}	
```
实测发现,Manacher算法的此类拓展不一定提交本质不同的回文子串(不算#),因为会有#的限制,

但是结合Manacher算法对称性(关于id对称)的原理可以发现,不在此类拓展中提交(calc)的子串一定在之前提到过.

而Manacher总复杂度O(n),所以是完全能够接受的.
#### 细化思路-SA
然后问题就换成了如何统计一个回文子串(也就是一个子串)的出现次数.

这里使用后缀数组解决.

一个子串是某一个后缀的前缀,因而,如果一个子串在K个后缀中出现过,那么该子串一定是这K个后缀Lcs的前缀.

也就有len(LCS)>=len(子串)

易知这K个后缀排序后构成连续的一段,所以可以用后缀数组解决.

每次在Height数组上二分,向前后分别拓展,rmq查询判断Lcs长度是否满足要求即可.
**总复杂度O(nlogn)**
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
//defs=====================================
void calc(int x,int y);
const int MAXN=5e5+10;
typedef int arr[MAXN];
int a[MAXN],N,M,T;
char s[MAXN];
ll ANS;
//vector<int> pos;//本质不同的回文子串开头点 
//manacher================================
char ms[MAXN*4];
int p[MAXN];
void do_manacher() {
	ms[0]=ms[1]='#';
	for(int i=1;i<=N;++i) ms[i<<1]=s[i],ms[i<<1|1]='#';
	int len=strlen(ms+1),mx=0,id=0;
	for(int i=1;i<len;++i) {
		if(mx>i) p[i]=min(p[id*2-i],mx-i);
		else p[i]=1;
		while(ms[i+p[i]]==ms[i-p[i]]) {
			++p[i];	
			if(i+p[i]>mx) {
				calc(i-p[i]+1,i+p[i]-1);
			}
		}
		if(p[i]+i>mx) {
			mx=i+p[i],id=i;
		}
	}	
}
//SA=======================================
arr sa,tax,rak,tp,height;
void Qsort() {
	for(int i=0;i<=M;++i) tax[i]=0;
	for(int i=1;i<=N;++i) tax[rak[i]]++;
	for(int i=1;i<=M;++i) tax[i]+=tax[i-1];
	for(int i=N;i>=1;--i) sa[ tax[rak[tp[i]]]-- ]=tp[i]; 
} 
void Ssort() {
	for(int i=1;i<=N;++i) a[i]=s[i];
	M=127;
	for(int i=1;i<=N;++i) {
		rak[i]=a[i];
		tp[i]=i;
	}
	Qsort();
	for(int w=1,p=1;p<N;M=p,w<<=1) {
		p=0;
		for(int i=1;i<=w;++i) tp[++p]=N-w+i;
		for(int i=1;i<=N;++i) if(sa[i]>w) tp[++p]=sa[i]-w;
		Qsort();
		swap(rak,tp);
		rak[sa[1]]=1;p=1;
		for(int i=2;i<=N;++i) 
			if(	tp[sa[i-1]]==tp[sa[i]]
				&&tp[sa[i-1]+w]==tp[sa[i]+w])
				rak[sa[i]]=p;
			else	rak[sa[i]]=++p;
	}
	int i,j,k=0;
	for(i=1;i<=N;++i) rak[sa[i]]=i;
	for(i=1;i<=N;height[rak[i++]]=k)
		for(k=k?k-1:k,j=sa[rak[i]-1];a[i+k]==a[j+k];++k);
}
//rmq======================================
int st[MAXN][20];
int Log2[MAXN];
void init_rmq() {//最小值 
	for(int i=1;i<=N;++i) st[i][0]=height[i];
	for(int i=2;i<=N;++i) Log2[i]=Log2[i/2]+1;
	for(int j=1;j<=19;++j)
		for(int i=1;i+(1<<j)-1<=N;++i) {
			st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
}
int qry_rmq(int L,int R) {
	int x=Log2[R-L+1];
	return min(st[L][x],st[R-(1<<x)+1][x]);
}
int lcs(int L,int R) {//查询rak L,R之间lcs长度 
	if(L==R)	return 1e9;
	return qry_rmq(L+1,R); 
}
//modules==================================
void calc(int x,int y) {//查询[x,y]子串的贡献 
	x=(x+1)/2,y>>=1;
	int len=y-x+1;
	int pos=rak[x];//排名,在height数组上向前和向后拓展.
	ll tim=1;
	//向后 
	int L,R,ans=0;
	L=0,R=N-pos;
	while(L<=R) {
		int mid=(L+R)>>1;
		if(lcs(pos,pos+mid)>=len) {
			ans=mid;
			L=mid+1;
		} else R=mid-1;
	} 
	tim+=ans;
	//向前 
	L=0,R=pos-1;
	while(L<=R) {
		int mid=(L+R)>>1;
		if(lcs(pos-mid,pos)>=len) {
			ans=mid;
			L=mid+1;
		} else R=mid-1;
	}
	tim+=ans;
	ANS=max(ANS,(ll)tim*len);
}
//main=====================================
signed main(){
	scanf("%s",s+1);N=strlen(s+1);
	Ssort();
	init_rmq();
	do_manacher();
	printf("%lld\n",ANS);
	return 0;
}

```

---

## 作者：djy213 (赞：8)

再此安利一种十分有趣的数据结构：

回文自动机（或称回文树）

他主要用于对单串计数（回文子串种类及出现次数，即其他周边信息）

于是该题，就变成一道模板题；

对每个点维护cnt表示她是几个字符的最长回文后缀；

那么他出现的次数就是她作为自己的末端字符的最长回文后缀出现的次数，以及她作为自己的末端字符的最长回文后缀的回文后缀（也不比是除她外最长的）出现的次数；

《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《

有关回文树的详细内容请看

2017年国家队候选队论文《回文树及其应用》作者：翁文涛

或直接阅读笔者的blog，以稍稍入门:

[http://www.cnblogs.com/nietzsche-oier/p/6935081.html](http://www.cnblogs.com/nietzsche-oier/p/6935081.html)

《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《《

代码：

···
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char s[300010];
struct Pld_T{
    int ch[26],fail,len,cnt;
};
Pld_T pld_t[300010];
int tot;
int main()
{
    int i,j,k,len;
    long long ans=0;
    scanf("%s",s+1);
    len=strlen(s+1);s[0]='#';
    pld_t[0].fail=1;k=0;pld_t[1].len=-1;tot=1;
    for(i=1;i<=len;i++){
        while(s[i-pld_t[k].len-1]!=s[i])k=pld_t[k].fail;
        if(!pld_t[k].ch[s[i]-'a']){
            pld_t[++tot].len=pld_t[k].len+2;
            j=pld_t[k].fail;
            while(s[i-pld_t[j].len-1]!=s[i])j=pld_t[j].fail;
            pld_t[tot].fail=pld_t[j].ch[s[i]-'a'];
            pld_t[k].ch[s[i]-'a']=tot;
        }
        k=pld_t[k].ch[s[i]-'a'];
        pld_t[k].cnt++;
    }
    for(i=tot;i>=2;i--){
        pld_t[pld_t[i].fail].cnt+=pld_t[i].cnt;
        if((long long)pld_t[i].cnt*pld_t[i].len>ans)
            ans=(long long)pld_t[i].cnt*pld_t[i].len;
    }
    printf("%lld",ans);
    return 0; 
}
···
```

---

## 作者：KesdiaelKen (赞：6)

看了题解区，除了第一篇（那个看不懂）几乎没有纯用后缀自动机的题解。本人在这里提供一种$O(n\log n)$的后缀自动机题解。

看到回文串，首先想到将正串和反串接在一起（注意中间要加特殊字符，且因为是判断回文串，要加两个不同字符），然后跑后缀自动机。建完后缀自动机后，考虑如何处理回文串的问题。

我们知道一个回文串必定有一个回文中心（长度为偶数的回文串回文中心在二字符之间），于是我们考虑枚举它。一个回文中心必定在正反串里有两个对应的出现位置。如果一个串在后缀自动机的$endpos$包含了两个对应的出现位置，那么等于这个串扩展出来的回文串（$ab$可拓展出$aba$或$abba$）在原串上出现了一次。

基于以上的原理，我们分回文串长度为奇数或偶数两种情况讨论。对于一种情况，$O(n)$枚举两个对应出现位置，并找到它们在$parent\space tree$的$lca$。于是，从这个$lca$到根的路径上每一个状态（节点）的扩展回文串都将在原串里多出现一次。于是我们可以在$lca$的位置上加上一个$1$。枚举完之后，从根开始$dfs$，那么记$val[i]$表示状态$i$扩展出的回文串在原串中出现的次数，则$val[i]=\sum _j val[j]$，其中$j$为$i$的子节点。然后基于分的类，状态$i$扩展出的回文串的长度为$newlen=len*2$或$newlen=len*2-1$。最后的答案即为$\{newlen[i]*val[i]\}_{max}$。

很高兴地觉得能$AC$，结果一交上去发现$80$分 $MLE$ qaq。考虑如何优化空间。$lca$不能用倍增，只能树剖。然后尽量用重复的数组，不要多开空间。最难优化的是$SAM$里的边，因为空间是$O(n*26)$的。易发现边存储的数都是小于$2^{21}$的（因为节点数量不超过$2000000$）。显然有空间浪费。于是我们用$3$个$char$替代一个$int$，用类似高精度的方法进行操作。这样空间就可以刚好卡过。

代码：

```
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iostream>
#include<map>
using namespace std;
const int SIZE=1000100;
int aadd;
struct NODE
{
    int fa,len;
	unsigned char bian[28][3];
	int lb(int&a)
	{
		aadd=bian[a][0];aadd*=255;
        aadd+=bian[a][1];aadd*=255;
        aadd+=bian[a][2];return aadd;
	}
	void zh(int&a,int&node)
	{
		aadd=node;
        bian[a][2]=aadd%255;aadd/=255;
        bian[a][1]=aadd%255;aadd/=255;
        bian[a][0]=aadd%255;
	}
}dian[SIZE];
int las=1,js=1;
int val[SIZE]={0};
int la[SIZE],zs=0;
void ins(int a)
{
    int p=las,np=las=++js;
    la[++zs]=las;dian[np].len=dian[p].len+1;
	for(;p&&dian[p].lb(a)==0;p=dian[p].fa)dian[p].zh(a,np);
    if(!p)dian[np].fa=1;
    else
    {
		int q=dian[p].lb(a);
        if(dian[q].len==dian[p].len+1)dian[np].fa=q;
        else
        {
            int nq=++js;
            dian[nq]=dian[q];
            dian[nq].len=dian[p].len+1;dian[np].fa=dian[q].fa=nq;
			for(;p&&dian[p].lb(a)==q;p=dian[p].fa)dian[p].zh(a,nq);
        }
    }
}
char dr[400000];int len;
struct Edge
{
    int t,nexty;
}edge[SIZE];
int head[SIZE],cnt=0;
void add(int a,int b)
{
    cnt++;
    edge[cnt].t=b;
    edge[cnt].nexty=head[a];
    head[a]=cnt;
}
int son[SIZE],fa[SIZE],dep[SIZE],lianfa[SIZE],sl=0;
void dfs1(int node)
{
    lianfa[node]=1;son[node]=0;
    for(int i=head[node];i;i=edge[i].nexty)
    {
        dep[edge[i].t]=dep[node]+1;
        fa[edge[i].t]=node;
        dfs1(edge[i].t);
        lianfa[node]+=lianfa[edge[i].t];
        if(lianfa[edge[i].t]>lianfa[son[node]])son[node]=edge[i].t;
    }
}
void dfs2(int node,int lf)
{
    lianfa[node]=lf;
    if(son[node])dfs2(son[node],lf);
    for(int i=head[node];i;i=edge[i].nexty)
    {
        if(edge[i].t==son[node])continue;
        dfs2(edge[i].t,edge[i].t);
    }
}
int kt[400000],jw[400000];
long long ans=0,aa,bb;
void dfs3(int node,long long ty)
{
    for(int i=head[node];i;i=edge[i].nexty)
    {
        dfs3(edge[i].t,ty);
        val[node]+=val[edge[i].t];
    }
    aa=val[node],bb=dian[node].len*2-1+ty;
    ans=max(ans,aa*bb);
}
int lca(int a,int b)
{
    while(lianfa[a]!=lianfa[b])
    {
        if(dep[lianfa[a]]>dep[lianfa[b]])a=fa[lianfa[a]];
        else b=fa[lianfa[b]];
    }
    if(dep[a]<dep[b])return a;
    else return b;
}
int main()
{
    scanf("%s",dr);len=strlen(dr);
    for(int i=0;i<len;i++)ins(dr[i]-'a'+2);
    ins(0);ins(1);for(int i=len-1;i>=0;i--)ins(dr[i]-'a'+2);
    for(int i=2;i<=js;i++)add(dian[i].fa,i);
    fa[1]=0;dep[1]=1;dfs1(1);dfs2(1,1);
    for(int i=1;i<=len;i++)kt[i]=la[i],jw[i]=la[zs-i+1];
    int lc;
    memset(val,0,sizeof(val));
    for(int i=1;i<=len;i++)
    {
        lc=lca(kt[i],jw[i]);
        val[lc]++;
    }
    dfs3(1,0);
    memset(val,0,sizeof(val));
    for(int i=2;i<=len;i++)
    {
        lc=lca(kt[i-1],jw[i]);
        val[lc]++;
    }
    dfs3(1,1);
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：xtx1092515503 (赞：3)

# [Portal](https://www.luogu.com.cn/problem/P3649)

这里介绍一种**全新的后缀数组解法**。

定义：$sa$、$rk$、$ht$数组，即为SA里的常规数组。

我们依旧求出$ht$数组，并利用**单调栈**（可以参见[[AHOI2013]差异](https://www.luogu.com.cn/problem/P4248)的题解或者本人的[后缀数据结构学习笔记](https://www.luogu.com.cn/blog/Troverld/hou-zhui-shuo-ju-jie-gou-xue-xi-bi-ji)）求出每个位置最多可以向左向右分别延伸到多远。即，$(L_i,R_i)$为满足$(\min\limits_{j=L_i+1}^{R_i-1}ht_j)\geq ht_i$的最大区间。则串$s[sa_i,\dots,sa_i+ht_i-1]$共出现了$R_i-L_i$次。

这里是求出$(L_i,R_i)$的代码:

```cpp
L[0]=stk[0]=1;
for(int i=2;i<=n;i++){
	while(tp&&ht[stk[tp]]>ht[i])R[stk[tp--]]=i;
	if(ht[stk[tp]]==ht[i])L[i]=L[stk[tp]];
	else L[i]=stk[tp];
	stk[++tp]=i;
}
while(tp)R[stk[tp--]]=n+1;
```
（事实上，我们求出这个数组的目的，就是为了得到$R_i-L_i$，即它的出现次数）

然后，对于每个$i$，我们**HASH+二分**出来$s[sa_i,\dots,sa_i+ht_i-1]$的**前缀**中，最长的**回文串**长度。则（长度*出现次数），即可与答案取$\max$。

这里我们先解答几个问题：

Q1：为什么一定要是**前缀回文串**？$s[sa_i,\dots,sa_i+ht_i-1]$的任何子串不都出现了$R_i-L_i$次吗？

A1:确实，这里是应该用它的全部子串。但是，我们不要忘记，它的每个子串，都是**某一条后缀的前缀**！所以，总有一条后缀，会计算它的非前缀子串的。并且，在这里计算的话，它出现的次数也会少于它真实的出现次数，毕竟这里是要求$s[sa_i,\dots,sa_i+ht_i-1]$这**一整个字符串**全都出现，但是如果只讨论该字符串的子串的话，出现次数也会更多。

Q2：那既然讨论子串时次数会更多，为什么要在这里讨论它的前缀呢？说不定它的前缀的出现次数也会更多呢？

A2：确实，它的次数确实会更多。我们把前缀的合法区间设为$(L',R')$，则必有$(L_i,R_i)\subset(L',R')$。但是，我们设$(L',R')$中$\min$的位置为$p$，则必有$(L_p,R_p)=(L',R')$！因此，这个前缀的贡献，会在$p$处被计算，在那时的$(L_p,R_p)$即是它真实的出现次数。

这里是二分+HASH的写法：

```cpp
for(int i=2;i<=n;i++){
	int tms=R[i]-L[i];
	int l=0,r=ht[i];
	while(l<r){
		int mid=(l+r+1)>>1;
		if((pre[sa[i]+mid-1]-pre[sa[i]-1])==(suf[sa[i]+ht[i]-mid]-suf[sa[i]+ht[i]]))l=mid;
		else r=mid-1;
	}
	res=max(res,1ll*tms*l);
}
```

当然，以某个位置开头的最长回文串长度，是可以使用Manacher$O(1)$求出的，这里因为~~懒得推了~~就使用HASH吧。

但是，如果你带入第一组样例算的话，会发现算出来的结果是$6$，而非$7$。

为什么呢？

因为所有只出现一次的回文串都不会被统计上！

所以我们只需再跑一遍Manacher求回文串最大长度即可。不会的可以参见本人的[Manacher感性瞎扯](https://www.luogu.com.cn/blog/Troverld/manacher-gan-xing-xia-che)。

复杂度$O(n\log n)$。

代码（~~SA+HASH+Manacher模板三合一，你值得拥有~~）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int x[400100],y[400100],sa[400100],ht[400100],rk[400100],buc[400100],n,m;
int L[400100],R[400100],stk[400100],tp;
char s[400100],str[800100];
ll res;
bool mat(int a,int b,int k){
	if(y[a]!=y[b])return false;
	if((a+k<=n)^(b+k<=n))return false;
	if((a+k<=n)&&(b+k<=n))return y[a+k]==y[b+k];
	return true;
}
void SA(){
	for(int i=1;i<=n;i++)buc[x[i]=s[i]]++;
	for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
	for(int i=n;i;i--)sa[buc[x[i]]--]=i;
	for(int k=1;k<=n;k<<=1){
		int num=0;
		for(int i=n-k+1;i<=n;i++)y[++num]=i;
		for(int i=1;i<=n;i++)if(sa[i]>k)y[++num]=sa[i]-k;
		for(int i=1;i<=m;i++)buc[i]=0;
		for(int i=1;i<=n;i++)buc[x[y[i]]]++;
		for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
		for(int i=n;i;i--)sa[buc[x[y[i]]]--]=y[i],y[i]=0;
		swap(x,y);
		x[sa[1]]=num=1;
		for(int i=2;i<=n;i++)x[sa[i]]=mat(sa[i],sa[i-1],k)?num:++num;
		m=num;
	}
	for(int i=1;i<=n;i++)rk[sa[i]]=i;
	for(int i=1,k=0;i<=n;i++){
		if(rk[i]==1)continue;
		if(k)k--;
		int j=sa[rk[i]-1];
		while(j+k<=n&&i+k<=n&&s[j+k]==s[i+k])k++;
		ht[rk[i]]=k;
	}
}
typedef unsigned long long ull;
ull sd1=998244353,sd2=666623333,pov1[401000],pov2[401000];
struct HASH{
	ull val1,val2;
	int len;
	HASH(){
		val1=val2=0ull;
		len=0;
	}
	HASH(char ip){
		val1=val2=ip;
		len=1;
	}
	friend HASH operator +(const HASH &x,const HASH &y){
		HASH z;
		z.val1=x.val1*pov1[y.len]+y.val1;
		z.val2=x.val2*pov2[y.len]+y.val2;
		z.len=x.len+y.len;
		return z;
	}
	friend HASH operator -(const HASH &x,const HASH &y){
		HASH z;
		z.val1=x.val1-y.val1*pov1[x.len-y.len];
		z.val2=x.val2-y.val2*pov2[x.len-y.len];
		z.len=x.len-y.len;
		return z;
	}
	friend bool operator ==(const HASH &x,const HASH &y){
		if(x.len!=y.len)return false;
		if(x.val1!=y.val1)return false;
		if(x.val2!=y.val2)return false;
		return true;
	}
}pre[401000],suf[800100];
int Centre,Rpos,rad[800100],S;
void prep(){
	str[S++]='#';
	for(int i=1;i<=n;i++)str[S++]=s[i],str[S++]='#';
}
void Manacher(){
    Centre=Rpos=-1;
    for(register int i=0;i<S;i++){
        rad[i]=(i<Rpos)?min(Rpos-i,rad[Centre*2-i]):1;
        while(i+rad[i]<S&&i-rad[i]>=0)if(str[i+rad[i]]==str[i-rad[i]])rad[i]++;else break;
        if(i+rad[i]>Rpos)Rpos=i+rad[i],Centre=i;
        res=max(res,1ll*rad[i]-1);
    }
}
int main(){
	scanf("%s",s+1),n=strlen(s+1),m='z',pov1[0]=pov2[0]=1;
	for(int i=1;i<=n;i++)pov1[i]=pov1[i-1]*sd1,pov2[i]=pov2[i-1]*sd2;
	for(int i=1;i<=n;i++)pre[i]=pre[i-1]+HASH(s[i]);
	for(int i=n;i>=1;i--)suf[i]=suf[i+1]+HASH(s[i]);
	SA();
//	for(int i=1;i<=n;i++)printf("%d ",rk[i]);puts("");
//	for(int i=1;i<=n;i++)printf("%d ",ht[i]);puts("");
	L[0]=stk[0]=1;
	for(int i=2;i<=n;i++){
		while(tp&&ht[stk[tp]]>ht[i])R[stk[tp--]]=i;
		if(ht[stk[tp]]==ht[i])L[i]=L[stk[tp]];
		else L[i]=stk[tp];
		stk[++tp]=i;
	}
	while(tp)R[stk[tp--]]=n+1;
	for(int i=2;i<=n;i++){
		int tms=R[i]-L[i];
		int l=0,r=ht[i];
		while(l<r){
			int mid=(l+r+1)>>1;
			if((pre[sa[i]+mid-1]-pre[sa[i]-1])==(suf[sa[i]+ht[i]-mid]-suf[sa[i]+ht[i]]))l=mid;
			else r=mid-1;
		}
		res=max(res,1ll*tms*l);
	}
	prep();
	Manacher();
//	for(int i=0;i<S;i++)printf("%c ",str[i]);puts("");
//	for(int i=0;i<S;i++)printf("%d ",rad[i]);puts("");
	printf("%lld\n",res);
	return 0;
} 
```


---

## 作者：elijahqi (赞：2)

用manacher o(n)复杂度找出串中的回文，然后用后缀数组处理，+rmq 最后再用二分的方法，我们可以子串在串中出现的次数

就是找到最长的满足区间内height都大于等于Len 求这个最大长度，分别在左右二分就可以了

最后再用出现次数乘以长度即可，在洛谷我是大牛分站交过的bzoj可以过

参考下bzoj3172  (http://www.elijahqi.win/2017/08/27/bzoj-3172/)

还有manacher的板子

```cpp
#include<cstdio>
#include<cstring>
#define N 330000
char s[N<<1];
int a[N],height[N],sa[N],tmp[N],count[N],rank[N<<1],rank1[N],n,Log[N],fmin[N][20],p[N<<1];
long long ans;
inline int min(int x,int y){
    return x<y?x:y;
}
inline long long max(long long x,long long y){
    return x>y?x:y;
}
inline int lcp(int l,int r){
    l++;int t=Log[r-l+1];
    return min(fmin[l][t],fmin[r-(1<<t)+1][t]);
}
inline long long calc(int x,int len){
    x=rank[x];int l1,r1;
    if (height[x]<len) l1=x;else{
        int l=1,r=x-1;
        while (l<=r){
            int mid=(l+r)>>1;
            if(lcp(mid,x)>=len) r=mid-1;else l=mid+1;
        }l1=l;
    }
    if (height[x+1]<len) r1=x;else{
        int l=x+1,r=n;
        while (l<=r){
            int mid=(l+r)>>1;
            if (lcp(x,mid)>=len) l=mid+1;else r=mid-1;
        }r1=r;
    }
    return (long long)len*(r1-l1+1);
}
int main(){
    freopen("3649.in","r",stdin);
    scanf("%s",s+1);n=strlen(s+1);
    for (int i=1;i<=n;++i) a[i]=s[i]-'a'+1;
    //sa
    int m=30;
    for (int i=1;i<=n;++i) count[a[i]]=1;
    for (int i=1;i<=m;++i) count[i]+=count[i-1];
    for (int i=1;i<=n;++i) rank[i]=count[a[i]];
    int k=0;
    for (int p1=1;k!=n;p1<<=1,m=k){
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i+p1]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) tmp[count[rank[i+p1]]--]=i;
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) sa[count[rank[tmp[i]]]--]=tmp[i];
        memcpy(rank1,rank,sizeof(rank)>>1);
        rank[sa[1]]=k=1;
        for (int i=2;i<=n;++i){
            if (rank1[sa[i]]!=rank1[sa[i-1]]||rank1[sa[i]+p1]!=rank1[sa[i-1]+p1]) ++k;
            rank[sa[i]]=k;
        }
    }
    k=0;
    for (int i=1;i<=n;++i) {
        if (rank[i]==1) continue;
        k=k==0?0:k-1;
        while (a[i+k]==a[sa[rank[i]-1]+k]) ++k;
        height[rank[i]]=k;
    }Log[0]=-1;
    for (int i=1;i<=n;++i) Log[i]=Log[i>>1]+1;
    for (int i=1;i<=n;++i) fmin[i][0]=height[i];
    for (int j=1;j<=Log[n];++j){
        for (int i=1;i<=n-(1<<j)+1;++i){
            fmin[i][j]=min(fmin[i][j-1],fmin[i+(1<<(j-1))][j-1]);
        }
    }
//    for (int i=1;i<=n;++i){
//        for (int j=sa[i];j<=n;++j) printf("%c",s[j]);printf("\n");
//    }
//    for (int i=1;i<=n;++i) printf("%d ",height[i]);printf("\n");
    for (int i=1;i<=n;++i){s[(i<<1)-1]='#';s[i<<1]=a[i]+'a'-1;}
    n<<=1;n++;s[n]='#';
    //printf("%s",s+1);printf("\n");
    int id=0;
    for (int i=1;i<=n;++i){
        if (i<id+p[id]) p[i]=min(id+p[id]-i,p[(id<<1)-i]);else p[i]=1;
        while (i+p[i]<=n&&i-p[i]>0&&s[i+p[i]]==s[i-p[i]]){
            if (s[i-p[i]]=='#') ++p[i];else{++p[i];continue;}
            if (i+p[i]>id+p[id]) ans=max(ans,calc(i/2-p[i]/2+1,p[i]-1));
        }
        if (i+p[i]>id+p[id]) id=i;
    }
    //for (int i=1;i<=n;++i) printf("%d ",p[i]);printf("\n");
    printf("%lld",ans);
    return 0;
}
```
(http://www.elijahqi.win/2017/07/16/hdu3068/)

本文地址：(http://www.elijahqi.win/2017/09/02/bzoj3676luogu3649-apio2014%e5%9b%9e%e6%96%87%e4%b8%b2/)

蒟蒻的blog(elijahqi.win)


---

## 作者：chihik (赞：1)


不懂回文自动机的[点这里](https://www.luogu.com.cn/blog/chihik/hui-wen-zi-dong-ji)

如果单纯的记录每个点结束回文串的数量，因为我们用的增量法 ，$ww$ 只会被计算一次 ， 第二个样例都过不了。

所以在构建回文自动机后 ， 我们将每一个 $Cnt[Link[u]]+=Link[u]$ , 就可以避免由上述方法带来的影响了。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
#define Mod 51123987

const int MAXN = 300000 , MAXK = 26;
char str[ MAXN + 5 ];
struct Palindromes_Automaton {
    int Size , Last , Root0 , Root1 , Trans[ MAXN + 5 ][ MAXK + 5 ] , Link[ MAXN + 5 ];
    int Len[ MAXN + 5 ] , Cnt[ MAXN + 5 ];

    Palindromes_Automaton( ) {
        Root0 = Size ++ , Root1 = Size ++; Last = Root1;
        Len[ Root0 ] = 0  , Link[ Root0 ] = Root1;
        Len[ Root1 ] = -1 , Link[ Root1 ] = Root1; 
    }

    void Extend( int ch , int dex ) {
        int u = Last;
        for( ; str[ dex ] != str[ dex - Len[ u ] - 1 ] ; u = Link[ u ] );
        if( !Trans[ u ][ ch ] ) {
            int Newnode = ++ Size , v = Link[ u ];
            Len[ Newnode ] = Len[ u ] + 2;
            for( ; str[ dex ] != str[ dex - Len[ v ] - 1 ] ; v = Link[ v ] );
            Link[ Newnode ] = Trans[ v ][ ch ]; Trans[ u ][ ch ] = Newnode;
        }
        Last = Trans[ u ][ ch ];
        Cnt[ Last ] ++;
    }
    void Build( char *str ) {
        int len = strlen( str );
        for( int i = 0 ; i < len ; i ++ )
            Extend( str[ i ] - 'a' + 1 , i );
    }
    long long Calc( ) {
        long long Ans = 0;
        for( int i = Size ; i >= 0 ; i -- )
            Cnt[ Link[ i ] ] += Cnt[ i ] , Ans = max( Ans , 1ll * Cnt[ i ] * Len[ i ] );
        return Ans;
    }
}PAM;

int main() {
    scanf("%s", str );
    PAM.Build( str );
    printf("%lld", PAM.Calc( ) );
    return 0;
}

```


---

## 作者：大奕哥 (赞：1)

楼下dalao写的简短我的回文自动机可能比较繁琐。

回文树，也叫回文自动机，是2014年被西伯利亚民族发明的，其功能如下：

1、求前缀字符串中的本质不同的回文串种类

2、求每个本质不同回文串的个数

3、以下标i为结尾的回文串个数/种类

4、每个本质不同回文串包含的本质不同回文串种类

（本文参考自Palindromic Tree——回文树【处理一类回文串问题的强力工具】，Palindromic Tree 回文自动机-回文树 解决回文串的神器）

下面介绍一些数组的意义

next[][]类似于字典树，指向当前字符串在两段同时加上一个字符

fail[] fail指针，类似于AC自动机，返回失配后与当前i结尾的最长回文串本质上不同的最长回文后缀

cnt[] 在最后统计后它可以表示形如以i为结尾的回文串中最长的那个串个数

num[] 表示以i结尾的回文串的种类数

len[] 表示以i为结尾的最长回文串长度

s[] 存放添加的字符

last 表示上一个添加的字符的位置

n 表示字符数组的第几位

p 表示树中节点的指针

本题用cnt \* len取max即可

安利博客：http://www.cnblogs.com/nbwzyzngyl/p/8260921.html

    
    
    
    
    
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
const int M=26;
typedef long long ll;
struct Palindromic_Tree{
    int nex[N][M];
    int fail[N];
    int cnt[N];
    int num[N];
    int len[N];
    int S[N];
    int last;
    int n;
    int p;
    int newnode(int l)
    {
        for(int i=0;i<M;++i)nex[p][i]=0;
        cnt[p]=0;
        num[p]=0;
        len[p]=l;
        return p++;
    }
    void init()
    {
        p=0;
        newnode(0);
        newnode(-1);
        last=0;
        n=0;
        S[n]=-1;
        fail[0]=1;
    }
    int get_fail(int x){
        while(S[n-len[x]-1]!=S[n])x=fail[x];
        return x;
    }
    void add(int c){
        c-='a';
        S[++n]=c;
        int cur=get_fail(last);
        if(!nex[cur][c]){
            int now=newnode(len[cur]+2);
            fail[now]=nex[get_fail(fail[cur])][c];
            nex[cur][c]=now;
            num[now]=num[fail[now]]+1;
        }
        last=nex[cur][c];
        cnt[last]++;
    }
    long long count(){
        long long ans=0;
        for(int i=p-1;i>=0;--i)cnt[fail[i]]+=cnt[i],ans=max(ans,1ll*cnt[i]*len[i]);
        return ans;
    }
}T;
char s[N];
int main()
{
    scanf("%s",s);
    int n=strlen(s);
    T.init();
    for(int i=0;i<n;++i)
    {
        T.add(s[i]);
    }
    printf("%lld",T.count());
    return 0;
}
```

---

## 作者：MrMorning (赞：0)

#Brief Description

一个回文串的value定义为这个回文串的长度乘以出现次数。给定一个字符串，求$value_{max}$。


#Algorithm Design

我们使用Manacher暴力算出所有的回文子串，放在SAM里倍增，大力算贡献就好了。


#Code
```cpp
#include <algorithm>
#include <cstdio>
#define ll long long
#include <cstring>
const int maxn = 600010;
int n;
ll ans;
int p[maxn];
char str[maxn];
struct Suffix_Automaton {
  int trans[maxn][26], fa[maxn][20], pos[maxn], len[maxn], size[maxn];
  int last, root, sz;
  int v[maxn], q[maxn], dep[maxn];
  void init() {
    sz = 0;
    last = root = ++sz;
  }
  void insert(int x, int id) {
    int p = last, np = last = ++sz;
    len[np] = len[p] + 1;
    pos[id] = np;
    size[np] = 1;
    for (; !trans[p][x]; p = fa[p][0])
      trans[p][x] = np;
    if (p == 0)
      fa[np][0] = root;
    else {
      int q = trans[p][x];
      if (len[q] == len[p] + 1) {
        fa[np][0] = q;
      } else {
        int nq = ++sz;
        for (int i = 0; i < 26; i++)
          trans[nq][i] = trans[q][i];
        fa[nq][0] = fa[q][0];
        len[nq] = len[p] + 1;
        fa[q][0] = fa[np][0] = nq;
        for (; trans[p][x] == q; p = fa[p][0])
          trans[p][x] = nq;
      }
    }
  }
  void pre() {
    for (int i = 1; i <= sz; i++)
      v[len[i]]++;
    for (int i = 1; i <= n; i++)
      v[i] += v[i - 1];
    for (int i = sz; i >= 1; i--)
      q[v[len[i]]--] = i;
    for (int i = sz; i >= 1; i--) {
      int t = q[i];
      size[fa[t][0]] += size[t];
    }
    for (int i = 1; i <= sz; i++) {
      int t = q[i];
      dep[t] = dep[fa[t][0]] + 1;
      for (int j = 1; (1 << j) <= dep[t]; j++)
        fa[t][i] = fa[fa[t][i - 1]][i - 1];
    }
  }
  void query(int l, int r) {
    int ret = pos[r];
    for (int i = 19; i >= 0; i--) {
      int t = fa[ret][i];
      if (len[t] >= r - l + 1)
        ret = t;
    }
    ans = std::max(ans, (ll)size[ret] * (r - l + 1));
  }
} sam;
void manacher() {
  int mx = 0, id;
  for (int i = 1; i <= n; i++) { // even
    if (mx > i)
      p[i] = std::min(mx - i, p[2 * id - i - 1]);
    else
      p[i] = 0;
    for (; str[i + p[i] + 1] == str[i - p[i]];
         sam.query(i - p[i] + 1, i + p[i]))
      p[i]++;
    if (p[i] + i > mx)
      mx = p[i] + i, id = i;
  }
  mx = 0;
  for (int i = 1; i <= n; i++) { // odd
    if (mx > i)
      p[i] = std::min(mx - i - 1, p[2 * id - i]);
    else {
      p[i] = 1;
      sam.query(i - p[i] + 1, i + p[i] - 1);
    }
    for (; str[i + p[i]] == str[i - p[i]];
         sam.query(i - p[i] + 1, i + p[i] - 1))
      p[i]++;
    if (p[i] + i > mx)
      mx = p[i] + i, id = i;
  }
}
int main() {
#ifndef ONLINE_JUDGE
// freopen("input", "r", stdin);
#endif
  scanf("%s", str + 1);
  n = strlen(str + 1);
  str[0] = '+', str[n + 1] = '-';
  sam.init();
  for (int i = 1; i <= n; i++) {
    sam.insert(str[i] - 'a', i);
  }
  sam.pre();
  manacher();
  printf("%lld\n", ans);
}
```

---


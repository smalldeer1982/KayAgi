# [APIO2017] 考拉的游戏

## 题目背景

### 特别提示

**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**

1. 提交时请在程序里加入以下函数声明语句：

```cpp
void playRound(int*,int*);
```

2. 程序开头不用，也不应该包含 `koala.h` 头文件。
3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。

## 题目描述

Koala 发明了一个新游戏，来邀请你一起玩！游戏的开始，她会在桌上放 $N$ 个物品，物品从 $0$ 到 $N - 1$ 标号。接着，她会秘密地给每个物品分配一个 $1$ 到 $N$ 之间的整数权值，且任意两个物品不会被分配到相同的权值。其中，第 $i$ 个物品的权值为 $P_i$。她请你来确定由这些权值构成的序列 $P=P_0,P_1,\dots ,P_{N-1}$ 的一些特征。

为了回答她的问题，你可以请 Koala 玩若干轮游戏。每一轮中，你会得到 $W$ 个蓝色石子，Koala 会得到 $W$ 个红色石子。首先，你可以选择若干个物品，再把你的一些（或全部）石子放在这些物品的旁边。Koala 会观察你的石子分配，然后类似地把她的一些（或全部）石子放在若干个物品旁边。如果一个物品旁边的红色石子数严格大于蓝色石子数，那么，Koala可以获得这个物品。Koala 分配她的石子时，总会选择使她获得的物品的权值和最大的方案，如果有多种方案可以做到这一点，她会选择一种获得的物品数最多的方案，如果仍然有多种方案，她会选择其中任意一种。

Koala 非常懒，如果你和她玩太多轮游戏，她就会睡着。你的任务是通过尽可能少轮数的游戏，确定 Koala 的序列 $P$ 的相关特征。

### 任务

在这个任务中，你需要实现 $4$ 个函数：`minValue`, `maxValue`, `greaterValue` 和 `allValues`。

每个函数需要你确定序列 $P$ 的不同特征。我们强烈推荐在我们提供的模版的基础上进行作答。注意，即使你只想获得部分子任务的分数，你也必须为四个函数都提供一个实现（尽管一些函数的内部可能为空）。你的程序禁止从标准输入读数据、向标准输出写数据或与任何文件交互。

在每个函数中，参数 `N` 表示游戏中物品的个数，参数 `W` 表示你和 Koala 在每一轮游戏中拥有的石子数。

* `minValue(N, W)` --- 这个函数需要返回权值最小的物品的标号 $i$，即 $P_i=1$
* `maxValue(N, W)` --- 这个函数需要返回权值最大的物品的标号 $i$，即 $P_i=N$
* `greaterValue(N, W)` --- 这个函数需要比较物品 $0$ 和物品 $1$ 的权值，返回权值较大的物品的标号。具体来说，若 $P_0>P_1$​，它应该返回 $0$ ，否则返回 $1$ 。
* `allValues(N, W, P)` --- 这个函数需要确定整个排列，并将其存放在给定的数组 $P$ 中：具体来说，$P[i]$ 应该保存物品 $i$ 的权值 $P_i (0 \leq i \leq N-1)$。

在每个测试点中，交互库会一次或多次调用这些函数中的一个。每次函数调用代表不同的任务，哪个函数会被调用、以及最多被调用多少次取决于子任务（见下文）。你可以认为 Koala 在每次函数调用前确定了她的序列 $P$，并且序列不会在一次函数的调用过程中改变。一次调用结束后，她可以在下次函数调用之前改变她的序列。

你实现的四个函数可以通过调用函数 `playRound` 来获取 Koala 的序列的相关信息。

* `playRound(B, R)`，请 Koala 和你玩一轮游戏。

数组 `B` 描述你在每个物品旁边放了多少蓝色石子。具体来说，对任意 $0 \leq i \leq N-1$，$B[i]$ 个蓝色石子将会被放在物品 $i$ 旁边。每个 $B[i]$ 必须是一个非负整数，且 $B[0]+B[1]+\cdots +B[N-1]$ 不能超过 $W$ 。

交互库会把 Koala 的回应存放在你提供的数组 `R` 中。具体来说，对任意 $0 \leq i \leq N-1$，Koala 会在物品 $i$ 旁边放 $R[i]$ 个红色石子。

每个子任务对你在每次游戏中调用 `playRound` 的次数有所限制。注意，调用次数越少你的得分可能会越高。（具体限制和评分方式参见下文）

## 说明/提示

### 子任务

#### 样例数据：$0$ 分

**因为特殊原因（不支持设置 $0$ 分测试点），评测时将不测样例**。

* 有 $5$ 个「样例数据」测试点，每个测试点恰好调用一次 $4$ 个函数中的某一个。请看下文的「样例」获取各测试点的详细信息。
* $N=6$
* $P=5,3,2,1,6,4$

每次游戏中，你可以调用 `playRound `至多 $3200$ 次。

#### 子任务 1：$4$ 分
* 在这个子任务中，交互库只会调用函数 `minValue`，每个测试点中，这个函数最多会被调用 $100$ 次。
* $N=100$
* $W=100$
* 每一次游戏中，你可以调用 `playRound` 至多 $2$ 次。

#### 子任务 2：$15$ 分
* 在这个子任务中，交互库只会调用函数 `maxValue`。每个测试点中，这个函数最多会被调用 $100$ 次。
* $N=100$
* $W=100$
* 每一次游戏中，你可以调用 `playRound` 至多 $13$ 次。
* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：
  - 若 $C_{max}\leq 4$，获得 $15$ 分。
  - 若 $5 \leq C_{max} \leq 13$，获得 $7$ 分。

#### 子任务 3：$18$ 分
* 在这个子任务中，交互库只会调用函数 `greaterValue`。每个测试点中，这个函数最多会被调用 $1100$ 次。
* $N=100$
* $W=100$
* 每一次游戏中，你可以调用 `playRound` 至多 $14$ 次。
* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：
  - 若 $C_{max}\leq 3$，获得 $18$ 分。
  - 若 $C_{max}=4$，获得 $14$ 分。
  - 若 $C_{max}=5$，获得 $11$ 分。
  - 若 $6 \leq C_{max}\leq 14$，获得 $5$ 分。

#### 子任务 4：$10$ 分
* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。
* $N=100$
* $W=200$
* 你可以调用 `playRound` 至多 $700$ 次。

#### 子任务 5：$53$ 分
* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。
* $N=100$
* $W=100$
* 你可以调用 `playRound` 至多 $3200$ 次。
* 这个子任务中，一个测试点的分数取决于 `playRound` 被调用的次数 $C$ ，具体来说，你的得分为：
  - 若 $C \leq 100$，获得 $53$ 分。
  - 若 $101 \leq C \leq 3200$，获得 $\lfloor 53-8 \log_2 (c/100) \rfloor$ 分。其中，$\lfloor x \rfloor$ 为不大于 $x$ 的最大整数。举例来说，若 $C=3200$，那么你的解答将获得 $13$ 分。

### 评分方式

- 和传统题一样，你的程序的运行时间和空间不能超过时间和空间限制。**交互库运行的时间和空间也会算入你的程序的总时间和空间当中**。当你估算这一部分的时空消耗时，你可以认为，在评测时使用的交互库与我们提供的样例交互库有**相同的函数**和**相似的实现**。
- 在一个测试点中，若你在调用 `playRound` 时传入了非法的数组 B，或调用 `playRound` 的总次数超过了上限，那么该测试点记 $0$ 分。
- 在一个测试点的任意一次游戏中，若一个函数没有正确地回答所要求的 Koala 的序列的特征，那么该测试点记 $0$ 分。
- 子任务 4 和子任务 5 均要求你实现函数 `allValues`，但在调用时传入了不同的 $W$。你可以利用两个子任务在这个参数上的不同，从而在你的实现中区分两个子任务。你可以参考你的语言的模板实现获取更详细的信息。
- 比赛时，你可以提交本题目最多 60 次，连续两次的提交至少间隔 2 分钟。
- **你在一个子任务上的得分，等于你在该子任务所有测试点中的最低得分**。

### 如何测试你的程序

在终端下输入如下命令进行编译：

```bash
g++ grader.cpp koala.cpp -o grader -g -Wall --std=c++11
```

样例交互库将按如下格式从标准输入读入数据：

第一行两个整数 $F,G$，其中 $F$ 代表交互库调用的函数类型，$G$ 代表调用函数的次数；

接下来 $G$ 行，每行开头两个整数 $N,W$，后跟 $N$ 个整数 $P_0,P_1,\ldots,P_{N-1}$。

$F$ 对应的样例交互库调用的函数类型如下表所示：

| $F$ | 调用的函数类型 |
| ----------- | ----------- |
| $1$ | `minValue` |
| $2$ | `maxValue` |
| $3$ | `greaterValue` |
| $4$ | `allValues` |

对于每次函数调用，样例交互库将向标准输出输出两行。第一行代表你调用 `playRound` 的次数，第二行代表函数调用后返回的结构（对于 $F=4$ 的情况，将输出调用 `allValues` 时返回的数组，对于其他情况，将输出函数的返回值）。

### 样例

考虑如下的排列：

| $i$ | 0 | 1 | 2 | 3 | 4 | 5 |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| $P_i$ | 5 | 3 | 2 | 1 | 6 | 4 |

下表展示了几次调用函数 `playRound` 的例子，以及交互库对每个调用的有效反馈（注意，一次 `playRound` 的调用，可能会有多种可能的有效反馈） 。

| $W$ | 调用 | 可能的交互库反馈 | 解释 |
| ----------- | ----------- | ----------- | ----------- |
| 6 | `playRound([0,3,0,2,1,0],R)` | `R=[1,1,1,0,2,1]` | Koala 获得了物品 $0,2,4,5$，总权值为 $17$，这是一种可能的权值最大的方案。 |
| 6 | `playRound([1,2,3,1,2,0],R)` | 非法调用 | 你总共放了 $9$ 个石子，超过了 $W$ 的限制。 |
| 12 | `playRound([0,3,0,2,1,0],R)` | `R=[2,3,0,2,3,1]` | 你不用放完 $W$ 个石子，Koala 也不用放完 $W$ 个石子。 |
| 6 | `playRound([0,1,0,0,1,0],R)` | `R=[1,0,1,1,2,1]` | 若 Koala 有多种方案最大化获得物品的权值，她会选择使自己获得物品最多的方案。因此 `R=[1,2,0,0,2,1]` 不是一个合法的返回值。 |

下面是样例数据的返回值，请注意在样例数据中，你可以调用 `playRound` 至多 $3200$ 次。

| # | 交互库调用 | 期望返回值 | 解释 |
| ----------- | ----------- | ----------- | ----------- |
| 1 | `minValue(6,6)` | 3 | $P_3=1$ |
| 2 | `maxValue(6,6)` | 4 | $P_4=6$ |
| 3 | `greaterValue(6,6)` | 0 | $P_0=5,P_1=3$ |
| 4 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 注意 `allValues` 无返回值，而是将正确结果放入 P 中。 |
| 5 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 同上。 |


### 附加文件

附加文件包含样例输入输出，C++ 样例交互库和程序模板，我们推荐您在模板的基础上实现您的程序。

# 题解

## 作者：Froggy (赞：13)

好van的交互题。。

---

## Subtask 1

询问一次即可。

直接询问 $[1,0,0,\cdots,0]$，输出得到的数组中为 $0$ 的位置。

理由很简单，Koala 至少得不到一个物品，那么不要的物品一定是价值最小的物品。

***code:***

```cpp
int minValue(int n, int W) {
	static int a[N],b[N];
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	a[0]=1;
	playRound(a,b);
	for(int i=0;i<n;++i){
		if(b[i]<=a[i])return i;
	}
	return 114514; //真香
}
```

---

## Subtask 2

这个 Subtask 不是很好想。

首先发现这个 Subtask 的套路一定是逐步缩小前若干大值位置的集合大小，直到集合大小为 $1$。

下面就是拿交互库乱试了！

首先每个位置放一个 $1$，可以确定权值在区间 $[51,100]$ 的位置集合。

然后再把这个集合中的每个位置放 $2$，其他位置放 $0$，就可以确定 $[76,100]$ 了。

按照这个套路，之后分别放 $4$ 个，最后分别放 $11$ 个，就能确定区间 $[92,100]$ 然后确定 $[100,100]$，成功找到最大值。

刚好询问 $4$ 次。

***code:***

```cpp
int maxValue(int n, int W) {
    static int a[N],b[N];
    memset(a,0,sizeof(a));
    for(int i=0;i<n;++i){
    	a[i]=1;
	}
	playRound(a,b);
	memset(a,0,sizeof(a));
	for(int i=0;i<n;++i){
		if(b[i]>1)a[i]=2;
	}
	playRound(a,b);
	memset(a,0,sizeof(a));
	for(int i=0;i<n;++i){
		if(b[i]>2)a[i]=4;
	}
	playRound(a,b);
	memset(a,0,sizeof(a));
	for(int i=0;i<n;++i){
		if(b[i]>4)a[i]=11;
	}
	playRound(a,b);
	for(int i=0;i<n;++i){
		if(b[i]>11)return i;
	}
	return 1919810;   //越来越香
}
```

---

## Subtask 3

有了 Subtask 2 的经验，不难想到一定存在一个数 $x$，询问 $[x,x,0,\cdots,0]$ 使得 Koala 选择位置 $0$ 的物品和位置 $1$ 的物品中的一个。

显然 $1\leq x\leq 14$，因为 $\sum_{i=1}^{15}i>100$，无论前两个物品的价值有多大 Koala 都不会选择。

把 $x$ 二分出来即可。

但现在最多还是要询问 $4$ 次，所以还需要人工细化二分的过程（就是把循环拆开）。

经过尝试，我下面这种二分方法也可以 AC。（当然，手工二分最保险）

***code:***

```cpp
bool Comp(int i,int j){      //比较i的价值和j的价值
	int l=1,r=14;
	static int a[N],b[N];
	while(l<r){
		int mid=(l+r)>>1;
		memset(a,0,sizeof(a));
		a[i]=a[j]=mid;
		playRound(a,b);
		if(b[i]>mid&&b[j]<=mid)return false;
		if(b[i]<=mid&&b[j]>mid)return true;
		if(b[i]<mid&&b[j]<mid){
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	return false;
}
int greaterValue(int n, int W) {
    return Comp(0,1);
}
```

---

## Subtask 4

最多询问 $700$ 次，看这个数字可以猜要询问 $\mathcal{O}(n\log n)$ 次。

这个 $W=200$ 的性质非常好,可以找到一种 $1$ 次就完成比较两个物品价值的方法：

设比较的物品分别为 $i$ 和 $j$，那么只需要在位置 $i$ 和 $j$ 分别放上 $100$ 个，其他位置放 $0$ 个即可。因为这样 Koala 一定会选择 $i$ 和 $j$ 其中的一个物品。被选择的物品价值较大。

有了比较方法下面只需要找个东西排个序啦！

`stable_sort` 可以胜任。（用法与 `sort` 一摸一样）

注：做交互题比较多的同学一定明白 `sort` 这个玩意千万不要用。由于它过于追求速度所以当递归到较小的区间后就会改成插入排序之类的，这样就浪费了很多询问。

***code:***

```cpp
bool cmp(int i,int j){
	int tmp[N]={},gugu[N];
	tmp[i]=tmp[j]=100;
	playRound(tmp,gugu);
	return gugu[i]<=100;
}
void allValues(int n, int W, int *p) {
    if(W==(n<<1)){
    	static int a[N];
    	memset(a,0,sizeof(a));
        for(int i=0;i<n;++i){
        	a[i]=i;
		} 
		stable_sort(a,a+n,cmp);    //好东西，其实就是归并排序
		for(int i=0;i<n;++i){
			p[a[i]]=i+1;
		}
    }
}
```

---

## Subtask 5

重头戏。（否则怎么可能占一半一上的分数呢？）

首先有个很显然的做法就是结合 Subtask 3 和 Subtask 4，用 `stable_sort` 排个序，这样大约询问 $700$ 多次，实测能得 $29$ 分。

然鹅只能询问 $n$ 次，考虑分治。

类似于 Subtask 2 的做法，维护权值在 $[l,r]$ 的位置集合，然后通过分治逐渐缩小区间。

每次都可以找到一个权值 $w$，然后把当前分治的位置集合中的位置放 $w$ 个，其他位置放 $0$ 个，使得得到的数组 $b$ 中存在集合中的某些位置为 $0$。假设这些位置有 $k(0< k<r-l+1)$ 个，那么可以分成 $[l,l+k-1]$ 和 $[l+k,r]$ 两个区间。

边界即 $l=r$ 的时候直接存下来然后跳出，就不需要再询问了。

这样只需要询问 $99$ 次就可以了。（自行思考为什么是 $99$ 次）

现在的问题就在于如何找到一个 $w$ 了。

可以直接暴力枚举，然后进行判断。由于我们只想去知道能否把集合分成两半，所以并不需要通过询问交互库来判断。构造一个价值依次为 $[1,2,\cdots,100]$ 的权值序列，然后求出 Koala 给的序列就能轻松判断了。

你问我怎么求？像我这种懒人就直接复制交互库的代码然后瞎魔改一下了。。（没说过不让复制交互库吖^_^) 其实就是一个背包。

还有一些细节写到注释里了。

***code:***

```cpp
//别看挺长的，check函数都是复制交互库的qwq。
bool check(int x,int l,int r){           //判断是否能把 [l,r] 切成两部分 
	int cache[2][205];
    int num[2][205];
    char taken[N][205];
    
    memset(cache[1],0,sizeof(cache[1]));
    memset(num[1],0,sizeof(num[1]));
    
    const int W=100;
    for(int i=0;i<N;++i) {
        int v=(i>=l&&i<=r)?x+1:1;
        int ii=i&1;
        int o=ii^1;
        for(int j=0;j<=W;++j) {
            cache[ii][j]=cache[o][j];
            num[ii][j]=num[o][j];
            taken[i][j]=0;
        }
        for(int j=W;j>=v;--j) {
            int h=cache[o][j-v]+i+1;
            int hn=num[o][j-v]+1;
            if(h>cache[ii][j]||(h==cache[ii][j]&&hn>num[ii][j])){
                cache[ii][j]=h;
                num[ii][j]=hn;
                taken[i][j]=1;
            }
			else{
                taken[i][j]=0;
            }
        }
    }
    int cur=W;

    static int qwq[N];
    
    for(int i=N-1;i>=0;--i) {
        int tmp=taken[i][cur]?((i>=l&&i<=r)?x+1:1):0;
        qwq[i]=tmp;
        cur-=tmp;
    }
    int jb=qwq[l];
    for(int i=l+1;i<=r;++i)if(qwq[i]^jb)return true;  //对于集合中的位置，存在两个位置放个红色石子数量不同就说明可以把集合分开。
    return false;
}
int get_val(int l,int r){
	for(int i=1;i<=100/(r-l+1);++i){  //暴力枚举是否合法
		if(check(i,l,r))return i;
	}
	exit(-1);
}
void Solve(int l,int r,vector<int> &vec,int *ans){
	if(l==r){
		ans[vec[0]]=l+1;
		return;
	}
	static int a[N],b[N];
	memset(a,0,sizeof(a));
	
	int w=get_val(l,r);
	for(int i=0;i<(int)vec.size();++i){
		a[vec[i]]=w;
	}
	playRound(a,b);
	vector<int> L,R; 
	for(int i=0;i<(int)vec.size();++i){
		if(b[vec[i]]<=w)L.push_back(vec[i]);
		else R.push_back(vec[i]); 
	}
	Solve(l,l+L.size()-1,L,ans);
	Solve(l+L.size(),r,R,ans);
}
void allValues(int n, int W, int *p) {
    if(W==n){
    	vector<int> myh;   //实在不知道用什么变量名了就用我npy的名字。
        for(int i=0;i<n;++i){
        	myh.push_back(i);
		}
		Solve(0,n-1,myh,p);  //开心分治
    }
}
```

---

最后提醒一句：**多测不清空，爆蛋两行泪。**

最终全部代码：

```cpp
#include "koala.h"
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>

using namespace std;

void playRound(int*,int*);
#define N 100


int minValue(int n, int W) {
	static int a[N],b[N];
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	a[0]=1;
	playRound(a,b);
	for(int i=0;i<n;++i){
		if(b[i]<=a[i])return i;
	}
	return 114514;
}

int maxValue(int n, int W) {
    static int a[N],b[N];
    memset(a,0,sizeof(a));
    for(int i=0;i<n;++i){
    	a[i]=1;
	}
	playRound(a,b);
	memset(a,0,sizeof(a));
	for(int i=0;i<n;++i){
		if(b[i]>1)a[i]=2;
	}
	playRound(a,b);
	memset(a,0,sizeof(a));
	for(int i=0;i<n;++i){
		if(b[i]>2)a[i]=4;
	}
	playRound(a,b);
	memset(a,0,sizeof(a));
	for(int i=0;i<n;++i){
		if(b[i]>4)a[i]=11;
	}
	playRound(a,b);
	for(int i=0;i<n;++i){
		if(b[i]>11)return i;
	}
	return 1919810;
}

bool Comp(int i,int j){
	int l=1,r=14;
	static int a[N],b[N];
	while(l<r){
		int mid=(l+r)>>1;
		memset(a,0,sizeof(a));
		a[i]=a[j]=mid;
		playRound(a,b);
		if(b[i]>mid&&b[j]<=mid)return false;
		if(b[i]<=mid&&b[j]>mid)return true;
		if(b[i]<mid&&b[j]<mid){
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	return false;
}
int greaterValue(int n, int W) {
    return Comp(0,1);
}

bool cmp(int i,int j){
	int tmp[N]={},gugu[N];
	tmp[i]=tmp[j]=100;
	playRound(tmp,gugu);
	return gugu[i]<=100;
}
bool check(int x,int l,int r){ 
	int cache[2][205];
    int num[2][205];
    char taken[N][205];
    
    memset(cache[1],0,sizeof(cache[1]));
    memset(num[1],0,sizeof(num[1]));
    
    const int W=100;
    for(int i=0;i<N;++i) {
        int v=(i>=l&&i<=r)?x+1:1;
        int ii=i&1;
        int o=ii^1;
        for(int j=0;j<=W;++j) {
            cache[ii][j]=cache[o][j];
            num[ii][j]=num[o][j];
            taken[i][j]=0;
        }
        for(int j=W;j>=v;--j) {
            int h=cache[o][j-v]+i+1;
            int hn=num[o][j-v]+1;
            if(h>cache[ii][j]||(h==cache[ii][j]&&hn>num[ii][j])){
                cache[ii][j]=h;
                num[ii][j]=hn;
                taken[i][j]=1;
            }
			else{
                taken[i][j]=0;
            }
        }
    }
    int cur=W;

    static int qwq[N];
    
    for(int i=N-1;i>=0;--i) {
        int tmp=taken[i][cur]?((i>=l&&i<=r)?x+1:1):0;
        qwq[i]=tmp;
        cur-=tmp;
    }
    int jb=qwq[l];
    for(int i=l+1;i<=r;++i)if(qwq[i]^jb)return true;
    return false;
}
int get_val(int l,int r){
	for(int i=1;i<=100/(r-l+1);++i){
		if(check(i,l,r))return i;
	}
	exit(-1);
}
void Solve(int l,int r,vector<int> &vec,int *ans){
	if(l==r){
		ans[vec[0]]=l+1;
		return;
	}
	static int a[N],b[N];
	memset(a,0,sizeof(a));
	
	int w=get_val(l,r);
	for(int i=0;i<(int)vec.size();++i){
		a[vec[i]]=w;
	}
	playRound(a,b);
	vector<int> L,R; 
	for(int i=0;i<(int)vec.size();++i){
		if(b[vec[i]]<=w)L.push_back(vec[i]);
		else R.push_back(vec[i]); 
	}
	Solve(l,l+L.size()-1,L,ans);
	Solve(l+L.size(),r,R,ans);
}
void allValues(int n, int W, int *p) {
    if(W==(n<<1)){
    	static int a[N];
    	memset(a,0,sizeof(a));
        for(int i=0;i<n;++i){
        	a[i]=i;
		} 
		stable_sort(a,a+n,cmp);
		for(int i=0;i<n;++i){
			p[a[i]]=i+1;
		}
    }
	else{
        vector<int> myh;
        for(int i=0;i<n;++i){
        	myh.push_back(i);
		}
		Solve(0,n-1,myh,p);
    }
}
```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!


---

## 作者：Deep_Kevin (赞：6)

## 正题
这题还挺好玩的，花了6h左右吧。ztO emofunc Orz
只有第三个subtask比其他人的更严格，其他的大致相同，最后一个subtask可以做到$O(n^2log_2 w)$。
### Subtask1
十分的简单，只需要随便给一个点放一个就行，不选的那个就是最小的。
### Subtask2
首先考虑第一次给每一个点都放一个，这样可以选出来$[51,100]$。
然后再给这50个放两个，考虑什么样的点会被选到，假设先选了$[1,50]$，剩下50个球选$[85,100]$，然后开始调整决策，比较$1$和$84$（还剩下两个球，只需要多增添一个），然后比较$2+3+4$和$83$，...，可以写一个程序帮助自己实现。就会发现第二次会选出来$[76,100]$，第三次给这$25$个球放$4$个，选出来$[92,100]$，第四次给这$9$个球放$11$个，选出来$[100,100]$
### Subtask3
我认为的重头戏来了。
这个$Subtask$因为不严谨所以被好多人说错了二分界限，虽然可以用正确的次数得到正确的答案，但是没有深究其中的道理。
可以想到，如果要比较两个位置的值，就分别给这两个位置都放上$w$个球，当有一方选而另一方不选的时候，答案就出来了。
我们先来确定当有$w$个球时，两个位置都选的话，值满足什么样的条件，设两个值分别为$a,b,a<b$。
当$w=1$时，由于当前手中还有两个球，可以先选一个$b$，$a$至少要满足$\gt 1+2=3$时，$a$才会被选。（此处虽然说的不严谨，仅仅提供了一种方式去猜$a$的下界，但可以发现，实际上只用分两种情况来讨论，即$a<=3$或者$a>3$，可以发现，在$a<=3$时，无论怎么取，取到的两个球都$\geq a$，在$a>3$时，换掉的最小的两个球恰好是$1+2=3$，所以$a>3$这个条件是充分必要的，下面同理。）
当$w=2$时，由于当前手中还有两个球，可以先用$1$选一个$b$，$a$至少要满足$\gt 2+3+4=9$时，$a$才会被选。
当$w=3$时，由于当前手中还有两个球，可以先用$1,2$选一个$b$，$a$至少要满足$\gt 3+4+5+6=18$时，$a$才会被选。
以此类推，我们可以很轻易算出如果两个球都取的话满足的下界条件。
|  球数| 下界$x$(即$a,b>x$) |
|--|--|
| 1 | 3 |
| 2 | 9 |
| 3 | 18 |
| 4 | 30 |
| 5 | 45 |
| 6 | 63 |
| 7 | 84 |
| 8 | 108 |

我们再来讨论一下如果两者都不选的情况下，$a,b$满足的上界大小。
这里提供一种计算上界的方法，即只用考虑$a=1,b=x$的情况，若$a\neq 1,b=x$，这样会使得替换数的和变小，更可能替换$b$，而我们需要找到的是一个**保证**的上界，所以我们只用考虑上界最松的限制，即当$a=1,b=x$时。
当$w=1$时，因为手中有两个球，所以必选一个，即$b<=0$。
当$w=2$时，因为手中有两个球，只需要另外替换出一个就可以选，即$b<=2$
当$w=3$时，因为手中有两个球，另外替换出两个就可以选，即$b<=2+3=5$
以此类推，我们可以很轻易算出如果两个球都取的话满足的上界条件。
|  球数| 上界$x_1$(即$a,b<=x_1$) |下界x_2(即$a,b>x_2$)|
|--|--|--|
| 1 | 0 |3|
| 2 | 2 |9|
| 3 | 5 |18|
| 4 | 9 |30|
| 5 | 14 |45|
| 6 | 20 |63|
| 7 | 27 |84|
| 8 | 35 |108|
对于这个表格我们很轻易就可以看出，在$w=i$时两个都选，那么在$w=i+1$时就不可能两个都不选，而当$w=8$时只可能不选或者一个选一个不选，在$w=1$时，只可能都选或者一个选一个不选，所以就一定可以在$w=[1,8]$中二分出一个答案。这样需要二分$4$次，并不能满足条件。
一个简单的缩减二分范围的方法就是直接把$7$去掉，因为当$w=6$时两个都选的话，在$w=8$时就不可能两个都不选，因为$63>35$，那么就做完了。
实际上，我们可以将$w=x$可以区分的答案写成$x_1<(a\ or\ b)<=x_2$
所以我们只需要找出若干个球使他们的并集包括$[1,100]$就可以了。
但这还没完，因为可以通过尝试发现$w\in [1,3,5,8]$时，会通过此题，也许你会问到$a=4,b=5$的情况怎么办？，那是因为下界在$a\neq 1,b=x$时，是会变窄的，一个球数管理的答案也就变多了，想要找出所有的方案吗？自行提交$2^8$次就可以找出来了，也许下一个最优解就是你。
### Subtask4
十分简单，考虑怎么用$1$次比较两个位置，在每一个位置上放上$100$个球就可以了，这样他一定会选一个。
### Subtask5
由于只给了$100$次，考虑分治，每次想办法将一个值域区间用$1$次的代价$[l,r]$分成两部分。
我们考虑在值为$[l,r]$的位置上放上$k$个球，看一下是否选一部分不选一部分即可。
怎么计算$k$？
显然满足二分性质，当$k$越小的时候，越有可能取，$k$越大的时候，越不可能取。
当$k$可以使得区间全部被选时，增加答案，全部不被选时减小答案，否则找到合法的$k$。
这样我们就可以用$n \log_2 w$次找出答案，还是不行。
发现区间$[l,r]$内放$k$个球，其他不放，取最大代价这种事情可以自己干，只需要枚举区间内选几个，其他的贪心选就可以了，时间复杂度$O(n)$
所以总的尝试次数就变成$n-1$了，时间复杂度就变成$O(n^2\log_2 w)$了。
由于$n$才$100$，所以博主直接写了暴力枚举。
```cpp
#include<bits/stdc++.h>
using namespace std;
void playRound(int*,int*);

const int N=110;
int a[N],b[N],n,w;

int minValue(int n,int w){
	a[0]=1;
	playRound(a,b);
	for(int i=0;i<n;i++) if(!b[i]) return i;
}

int maxValue(int n,int w){
	for(int i=0;i<n;i++) a[i]=1;
	for(int t=1;t<=4;t++){
		playRound(a,b);
		int tot=0;
		for(int i=0;i<n;i++) if(b[i]>a[i] && a[i])
			tot++;
		for(int i=0;i<n;i++) 
			if(b[i]>a[i] && a[i]) a[i]=w/tot;
			else a[i]=0;
        if(tot==1) break;
	}
	for(int i=0;i<n;i++) if(a[i]) return i;
}

int greaterValue(int n,int w){
    int l=1,r=4;
    int op[10]={0,1,3,5,8};
	while(l<=r){
		int mid=(l+r)/2;
		a[0]=a[1]=op[mid];
		playRound(a,b);
		if((b[0]>a[0]) ^ (b[1]>a[1])) return (b[0]>a[0])?0:1;
		else if(b[0]>a[0]) l=mid+1;
		else r=mid-1;
	}
}

bool check(int x,int l,int r){
	int mmax=l*(l-1)/2,pos=0,tot=w-(n-r)-x-1,ans=0;
	for(int t=r;t>=l && tot>=0;t--,tot-=x+1){
		ans+=t;
		if(mmax<ans+(l-1+l-tot)*tot/2) mmax=ans+(l-1+l-tot)*tot/2,pos=t;
	}
	return pos!=0 && pos!=l;
}

int get_value(int l,int r){
	for(int i=1;i<=w/(r-l+1);i++)
		if(check(i,l,r)) return i;
}

void solve(int l,int r,vector<int>&op,int*num){
	if(l==r){
		num[op[0]]=l;
		return ;
	}
	int k=get_value(l,r);
	vector<int> L,R;
	memset(a,0,sizeof(a));
	for(int i=0;i<op.size();i++) a[op[i]]=k;
	playRound(a,b);
	for(int i=0;i<op.size();i++){
		if(b[op[i]]>k) R.push_back(op[i]);
		else L.push_back(op[i]);
	}
	solve(l,l+L.size()-1,L,num);
	solve(l+L.size(),r,R,num);
}

void allValues(int N,int W,int*c){
	vector<int> V;n=N;w=W;
	for(int i=0;i<n;i++) V.push_back(i);
	solve(1,n,V,c);
}
```

---

## 作者：zhylj (赞：6)

为了更好的阅读体验，你可以前往[我的博客](http://zhylj.cc/index.php/archives/12/)。

### 子任务 1

考虑任取一个位置放一个石子，进行一轮游戏，那么 Koala 只能且只会取恰好 $N - 1$ 个 $P_i$，唯一剩下的一个就是最小值。

### 子任务 2

考虑逐轮分析，每一轮尽可能地缩小范围。

注意到对于一些你放了相同数量的石子的位置，Koala 取的那部分一定是最大的若干个数。

**第一轮游戏**：考虑确认 $[51,100]$：所有位置均放一个石子，那么 Koala 将会只在所有前 $50$ 大的位置放恰好两个石子。

**第二轮游戏**：考虑确认 $[76,100]$：在 $[51,100]$ 的位置放 $2$ 个石子，其余位置不放石子，我们注意到这样相当于两个代价分别为 $1$ 和 $3$ 的背包，也就是后面三个可以换前面一个，我们设取了 $x$ 个在 $[76,100]$ 的数，则可以大致列得方程 $3(50 - (100 - 3x)) = 100 - x$，解得 $x = 25$，实际跑一边背包发现确实如此。

所以，Koala 将恰好取掉 $[76,100]$ 和 $[26,50]$ 的部分，我们就得以确定 $[76,100]$.

**第三轮游戏**：在 $[76,100]$ 放 $3$ 个石子，在 $[51,75]$ 放 $1$ 个石子，其余位置不放，注意到这样背包的代价均为倍数关系，我们可以很方便的计算出 Koala 只会取 $[95, 100]$ 中的数。

**第四轮游戏**：我们在最大的那六个数中都放上 $11$ 个石子，显然 Koala 会且只会取 $1$ 个数，所以我们就做完了。

### 子任务 3

上面在第四轮游戏中的做法启发我们去考虑给这两个数带上代价 $k$，而其余的数不带上任何代价，如果有某个 $k$ 这两个数被取的状态不同，那么被取的那个较大。

于是，我们考虑当给某个数带上代价 $k$ 的时候，会发生什么情况（我们暂时先假设 $P_0+P_1 > 2k$，其余情况稍后再做讨论）。

- 这两个数全部被选，那么 Koala 必然不取一段从 $1$ 开始的 $2k$ 个连续自然数，那么我们有：

$$k(2k + 1) < P_0 + P_1$$

- 这两个数全部不选，那么意味着 $P_0,P_1$ 中任何一个均不超过从 $1$ 开始的 $k$ 个连续自然数。

$$\frac{k(k + 1)}2 \ge \max \{P_0,P_1\}$$

注意到这两个不等式我们不容易操作，所以考虑对第二个不等式进行放缩：

$$\frac{k(k + 1)}2 \ge P_0 + P_1 - 2$$

于是，我们得到一个范围，使得这个范围内的数一定能被 $k$ 区分出来：

$$\frac{k(k + 1)}2 + 2 < P_0 + P_1\le k(2k + 1)$$

我们把这些区间搞出来对 $[3,200)$ 做个最小区间覆盖，发现我们需要查 $5$ 个 $k$ 才能找到答案（做最小区间覆盖的时候，可以发现只有 $k = 2$ 的时候要考虑边界，容易发现这样是可以判断 $P_0+P_1 \in[3, 5]$ 的情况的）。

可以发现，若某个 $k$ 使得 $P_0,P_1$ 全都取了，则 $k'\le k$ 的一定全都取了，若某个 $k$ 使得 $P_0,P_1$ 全都不取，则 $k'\ge k$ 的一定全都不取。

于是可以二分，于是做到了 $3$ 次，可以通过该子任务。

### 子任务 4

这个子任务比较简单。

注意到 $700 = 100\times \lceil \log_2 100\rceil$，于是考虑用排序做，但是我们注意到我们原先的比较方法要带上一个常数，所以考虑利用 $W=200$ 的条件把比较两个数的操作优化到恰好一次游戏。

考虑只对 $x,y$ 两个位置放 $100$ 个石子，这样就可以完成 $P_x$ 和 $P_y$ 的比较了。

### 子任务 5

首先，我们考虑 $\forall i,B_i=1$ 的一个状态，这样所有 $P_i\in [51,100]$ 内的位置 $i$ 都被放了两个石子。

接下来的每一步，我们考虑维护一个位置集合 $S=\{i\mid R_i\ge 2\}$，每次从 $S$ 中取出两个元素 $i_0,i_1$，将 $B_{i_0},B_{i_1}$ 设为 $0$，则在新的一轮游戏中，这两个位置的 $R_i$ 必然为 $1$（因为它们在先前的游戏中被 Koala 不惜花费 $2$ 的代价也要取到，所以当它代价减少时 Koala 必然也会取它），那么 Koala 会多出来两个新的石子，那么 Koala 必然会用它们取它还没取的最大的数（因为所有它还没取的数代价都相等），这个数第一次是 $50$，第二次是 $49$...

注意到我们每次对 $S$ 先删除两个数，再加入一个数，所以每次 $|S|$ 减少 $1$，而最开始 $|S| = 50$，故我们一共可以做 $49$ 次。

注意到根据我们在第一次游戏中得到的信息，$1$ 所在的位置是可以被确定的，并不需要额外再做游戏。

这样我们成功确认了 $[1,50]$，考虑对剩下的数分治处理，假设我们需要确定 $[l,r](51\le l\le r\le 100)$ 中的数的位置，考虑使用子任务 3 的方法，将一部分 $B_i$ 设为相同的值，其余部分设为 $0$：

- 若 $r - l + 1 \le 10$，则根据我们在子任务 3 中证过的结论（注意到这些数任取两个的和均大于 $100$ 且小于 $200$），我们将这些位置的 $B_i$ 全部设为 $10$ 即可保证这个区间一定被分成了两部分。

- 否则，显然 $(r,100]$ 的数 Koala 一定会选，则留给 $[1,r]$ 的共有 $r$ 个石子，我们将 $i\in[l,r]$ 的 $B_i$ 全设为 $\left\lceil\dfrac {r}{r-l+1}\right\rceil - 1$，我们发现显然这个区间不能被全部选取（因为这样就花费了超过 $r$ 个石子了），也显然会至少再选取一个（因为即使剩下的部分全部选取也有剩）。

于是我们每次都能缩小区间，就能恰好在 $99$ 次内搞出来整个排列了。

## 代码

```cpp
#include <bits/stdc++.h>

void playRound(int*, int*);

const int kN = 1e2 + 5;

int B[kN], R[kN], typ[kN];

int minValue(int N, int W) {
	memset(B, 0, sizeof(B));
	B[0] = 1;
	playRound(B, R);
	for(int i = 0; i < N; ++i)
		if(R[i] <= B[i]) return i;
}

int maxValue(int N, int W) {
	for(int i = 0; i < N; ++i) B[i] = 1;
	playRound(B, R);
	for(int i = 0; i < N; ++i) {
		typ[i] = (R[i] >= 2);
		B[i] = typ[i] * 2;
	}
	playRound(B, R);
	for(int i = 0; i < N; ++i) {
		if(R[i] >= 3) typ[i] = 2;
		if(typ[i] != 2) B[i] = typ[i];
		else B[i] = 3;
	}
	playRound(B, R);
	for(int i = 0; i < N; ++i) {
		if(R[i] >= 3) typ[i] = 3, B[i] = 11;
		else B[i] = 0;
	}
	playRound(B, R);
	for(int i = 0; i < N; ++i)
		if(R[i] >= 12) return i;
}

int greaterValue(int N, int W) {
	memset(B, 0, sizeof(B));
	B[0] = B[1] = 4;
	playRound(B, R);
	if((B[0] < R[0]) && (B[1] < R[1])) {
		B[0] = B[1] = 8;
		playRound(B, R);
		if((B[0] < R[0]) != (B[1] < R[1]))
			return (B[0] < R[0]) < (B[1] < R[1]);
		B[0] = B[1] = 10;
		playRound(B, R);
		return (B[0] < R[0]) < (B[1] < R[1]);
	} else if((B[0] >= R[0]) && (B[1] >= R[1])) {
		B[0] = B[1] = 1;
		playRound(B, R);
		if((B[0] < R[0]) != (B[1] < R[1]))
			return (B[0] < R[0]) < (B[1] < R[1]);
		B[0] = B[1] = 2;
		playRound(B, R);
		return (B[0] < R[0]) < (B[1] < R[1]);
	} else return (B[0] < R[0]) < (B[1] < R[1]);
}

bool Check(int N, int W, int x, int y) {
	memset(B, 0, sizeof(B));
	B[x] = B[y] = W / 2;
	playRound(B, R);
	return R[x] >= W / 2 + 1;
}

int idx[kN], pos[kN], cnt;
bool vis[kN];

void Div(int l, int r, std::vector <int> &p, int *P) {
	if(l == r) P[p[0]] = l;
	else {
		memset(B, 0, sizeof(B));
		std::vector <int> p_l, p_r;
		int x = (r - 1) / (r - l + 1);
		if(r - l + 1 <= 10) x = 10;
		for(auto i : p)
			B[i] = x;
		playRound(B, R);
		for(auto i : p) {
			if(R[i] > B[i])
				p_r.push_back(i);
			else p_l.push_back(i);
		}
		Div(l, l + p_l.size() - 1, p_l, P);
		Div(l + p_l.size(), r, p_r, P);
	}
}

void allValues(int N, int W, int *P) {
	if (W == 2 * N) {
		for(int i = 0; i < N; ++i) {
			int l = 0, r = cnt;
			while(l < r) {
				int mid = (l + r) >> 1;
				if(Check(N, W, idx[mid], i)) r = mid;
				else l = mid + 1;
			}
			for(int j = cnt; j > l; --j)
				idx[j] = idx[j - 1];
			++cnt; idx[l] = i;
		}
		for(int i = 0; i < N; ++i)
			P[idx[i]] = i + 1;
	} else {
		memset(vis, false, sizeof(vis));
		for(int i = 0; i < N; ++i) B[i] = 1;
		playRound(B, R);
		for(int i = 0; i < N; ++i) {
			typ[i] = (R[i] >= 2);
		}
		for(int i = 0; i < N; ++i) {
			B[i] = 1;
			if(typ[i] == 1 || typ[i] == 2)
				R[i] = 2;
		}
		for(int i = 0; i < 49; ++i) {
			int x = -1, y = -1;
			for(int j = 0; j < N; ++j) {
				if(x == -1 && R[j] > B[j] && B[j]) x = j;
				else if(x != -1 && R[j] > B[j] && B[j]) {
					y = j; break;
				}
			}
			B[x] = B[y] = 0;
			playRound(B, R);
			for(int j = 0; j < N; ++j)
				if(typ[j] != 1 && R[j] > B[j] && !vis[j]) {
					vis[j] = true; P[j] = 50 - i;
					break;
				}
		}
		for(int i = 0; i < N; ++i)
			if(typ[i] == 0 && !vis[i]) {
				vis[i] = true; P[i] = 1;
				break;
			}
		for(int i = 0; i < N; ++i) B[i] = 1;
		std::vector <int> p;
		for(int i = 0; i < N; ++i)
			if(!vis[i]) p.push_back(i);
		Div(51, 100, p, P);
	}
}
```

---

## 作者：clamee (赞：1)

这是一个比较好玩的交互题。

### subtask 1：

找最小值。

可以任意在一个位置上放一个石头，这样对手必定会选 $N-1$ 个位置。直接找到对手没选的位置即可。

### subtask 2：

找最大值。

假设最大值在集合 $S$ 中（一开始为全集），然后你在集合 $S$ 中等量加入一些石子，那么必定会有一部分被选，有一部分没有被选。

显然可以知道，被选的集合的元素比没有被选的集合的元素都要大，所以就可以将 $S$ 更新继续求解。

显然如果我们每次等量添加的石子尽可能多，$S$ 的大小减小的越快，经过手工验证可以保证次数在 $4$ 次以内。

### subtask 3：

比较两个数的大小。

考虑在这两个数上加上若干相同的石子，可以通过计算得知，在石子数不超过 $11$ 时必然存在一组解使得其中一个数被选另一个不被选。因为问题相当于两函数求交点的问题，于是可以二分，因为有几个点的取值条件具有包含关系，所以在 $3$ 次以内可以求得答案。

### subtask 4：

确定整个排列 \# 1。

考虑在 $N=200，W=200$ 时可以很简单地比较两个数的大小：在两个数的所在位置各放 $100$ 石子，看哪个被选即可。所以可以直接使用归并排序使得比较次数在 $n\log_2n$ 级别，此时最大次数不会超过 $700$。

### subtask 5：


确定整个排列 \# 2。

试分析 subtask 2 的做法，发现这个办法可以在一次询问内将当前集合拆成两份。

如果能够保证每次拆成的集合均不为空，那么就可以在 $N-1$ 次询问内确定答案。

所以我们就枚举在当前集合放相等的石子的个数，找到一个不为空的拆分方案。可以证明，这样的拆分总是成立的。

然后进行询问并递归求解。

以下是代码：
```
//#include "koala.h"
#include<bits/stdc++.h>

using namespace std;

int B[105],R1[105],R2[105];
void playRound(int*,int*);
int judge2(int i,int j)
{
	if(B[i]<R2[i]&&B[j]>=R2[j])
		return 0;
	if(B[i]>=R2[i]&&B[j]<R2[j])
		return 1;
	return -1;
}

int minValue(int N, int W) {
    // TODO: Implement Subtask 1 solution here.
    // You may leave this function unmodified if you are not attempting this
    // subtask.
    //playRound(B,R1);
    int s=0;
	//for(int i=1;i<=n;i++)
		
    B[0]=1;
    playRound(B,R2);
    for(int i=0;i<N;i++)
    	if(R2[i]<=B[i])s=i;
    return s;
}

int maxValue(int N, int W) {
    // TODO: Implement Subtask 2 solution here.
    // You may leave this function unmodified if you are not attempting this
    // subtask.
    set<int> s;
    for(int i=0;i<N;i++)
    	s.insert(i);
    while(s.size()!=1)
    {
    	set<int>::iterator it;
    	memset(B,0,sizeof(B));
    	it=s.begin();
    	while(it!=s.end())
    	{
    		B[*it]=W/s.size();
    		it++;
    	}
    	playRound(B,R2);
    	for(int i=0;i<N;i++)
    		if(!s.count(i))continue;
    		else if(R2[i]<=B[i])s.erase(i);
    }
    return *s.begin();
}

int greaterValue(int N, int W) {
    // TODO: Implement Subtask 3 solution here.
    // You may leave this function unmodified if you are not attempting this
    // subtask.
    int l=1,r=(N>10)?11:4;
    while(l<=r)
    {
    	int mid=(l+r)>>1;
    	B[0]=B[1]=mid;
    	playRound(B,R2);
    	int now=judge2(0,1);
    	if(now!=-1)return now;
    	if(B[0]<R2[0])l=mid+1;
    	else r=mid-1;
    }
}
int T;
bool cmp(const int i,const int j)
{
	memset(B,0,sizeof(B));
//	memset(R2,0,sizeof(R2));
	B[i]=B[j]=T;
    playRound(B,R2);
    return R2[i]<=T;
}
bool cmp2(const int i,const int j)
{
	memset(B,0,sizeof(B));
//	memset(R2,0,sizeof(R2));
    int l=1,r=(T>10)?8:4;
    while(l<=r)
    {
    	int mid=(l+r)>>1;
	//	cerr<<mid<<endl;
    	B[i]=B[j]=mid;
    	playRound(B,R2);
	//	cerr<<mid<<" "<<R2[i]<<" "<<B[i]<<" "<<R2[j]<<" "<<B[j]<<" "<<i<<" "<<j<<endl;
    	int now=judge2(i,j);
	//	cerr<<mid<<" "<<i<<" "<<j<<" "<<now<<endl;
    	if(now!=-1)return 1^now;
    	if(B[i]<R2[i])l=mid+1;
    	else r=mid-1;
    }
}

bool pd(int x,int l,int r)
{
    int cache[2][205];
    int num[2][205],i,j;
    char taken[105][205];

    for (i=0;i<205;++i) {
        cache[1][i] = 0;
        num[1][i] = 0;
    }

    for (i=0;i<T;++i) {
        int v = (i>=l&&i<=r)?x+1:1;
        int ii = i&1;
        int o = ii^1;
        for (j=0;j<=T;++j) {
            cache[ii][j] = cache[o][j];
            num[ii][j] = num[o][j];
            taken[i][j] = 0;
        }
        for (j=T;j>=v;--j) {
            int h = cache[o][j-v] + i+1;
            int hn = num[o][j-v] + 1;
            if (h > cache[ii][j] || (h == cache[ii][j] && hn > num[ii][j])) {
                cache[ii][j] = h;
                num[ii][j] = hn;
                taken[i][j] = 1;
            } else {
                taken[i][j] = 0;
            }
        }
    }

    int cur = T;
    int a[T];
    for (i=T-1;i>=0;--i) {
        int tmp=taken[i][cur]?((i>=l&&i<=r)?x+1:1):0;
        a[i]=tmp;
        cur -= tmp;
    }
    int now=a[l];
    for(int i=l+1;i<=r;i++)
    	if(now!=a[i])return 1;
    return 0;
}

int getval(int l,int r)
{
	for(int i=1;i<=T;i++)
		if(pd(i,l,r))return i;
}
int b[105],ans[105];
void sol(int l,int r,vector<int> &a)
{
	if(l==r)return ans[a[0]]=l,void();
	int w=getval(l,r);
	memset(B,0,sizeof(B));
	for(int i=0;i<a.size();i++)
		B[a[i]]=w;
	playRound(B,R2);
	vector<int> a1,a2;
	for(int i=0;i<a.size();i++)
	{
		if(R2[a[i]]>B[a[i]])a2.push_back(a[i]);
		else a1.push_back(a[i]);
	}
	sol(l,l+a1.size()-1,a1);
	sol(l+a1.size(),r,a2);
}

void allValues(int N, int W, int *P) {
    if (W == 2*N) {
        // TODO: Implement Subtask 4 solution here.
        // You may leave this block unmodified if you are not attempting this
        // subtask.
		T=N;
        for(int i=0;i<N;i++)
        	R1[i]=i;
        stable_sort(R1,R1+N,cmp);
		for(int i=0;i<N;i++)
			P[R1[i]]=i+1;
    } else {
        // TODO: Implement Subtask 5 solution here.
        // You may leave this block unmodified if you are not attempting this
        // subtask.
		T=N;
		vector<int> a;
		for(int i=0;i<N;i++)
			a.push_back(i); 
		sol(0,N-1,a);
		for(int i=0;i<N;i++)
			P[i]=ans[i]+1;
    }
}
```

---


# [APIO2017] 商旅

## 题目描述

在广阔的澳大利亚内陆地区长途跋涉后，你孤身一人带着一个背包来到了科巴。你被这个城市发达而美丽的市场所深深吸引，决定定居于此，做一个商人。科巴有$N$个集市，集市用从$1$到$N$的整数编号，集市之间通过$M$条单向道路连接，通过每条道路都需要消耗一定的时间。


在科巴的集市上，有$K$种不同的商品，商品用从$1$到$K$的整数编号。每个集市对每种商品都有自己的定价，买入和卖出商品的价格可以是不同的。并非每个集市都可以买卖所有的商品：一个集市可能只提供部分商品的双向交易服务；对于一种商品，一个集市也可能只收购而不卖出该商品或只卖出而不收购该商品。如果一个集市收购一种商品，它收购这种商品的数量是不限的，同样，一个集市如果卖出一种商品，则它卖出这种商品的数量也是不限的。


为了更快地获得收益，你决定寻找一条盈利效率最高的环路。环路是指带着空的背包从一个集市出发，沿着道路前进，经过若干个市场并最终回到出发点。在环路中，允许**多次**经过同一个集市或同一条道路。在经过集市时，你可以购买或者卖出商品，一旦你购买了一个商品，你需要把它装在背包里带走。由于你的背包非常小，任何时候你最多只能持有一个商品。在购买一个商品时，你不需要考虑你是否有足够的金钱，但在卖出时，需要注意只能卖出你拥有的商品。


从环路中得到的收益为在环路中卖出商品得到的金钱减去购买商品花费的金钱，而一条环路上消耗的时间则是依次通过环路上所有道路所需要花费的时间的总和。环路的盈利效率是指从环路中得到的收益除以花费的时间。需要注意的是，一条没有任何交易的环路的盈利效率为$0$。


你需要求出所有**消耗时间为正数**的环路中，盈利效率**最高**的环路的盈利效率。答案**向下取整**保留到整数。如果没有任何一条环路可以盈利，则输出 0 。


## 说明/提示

## 样例解释

在样例中，我们考虑下面两条环路，“1 - 2 - 3 - 1” 和 “1 - 4 - 3 - 1”。

考虑环路 “1 - 2 - 3 - 1” ：这条环路消耗的总时间是$(3+3+1)=7$分钟。在这条环路中，最佳的交易方式是：在编号为 1 的集市中购买编号为 2 的商品（花费的金钱为 5）；在编号为 2 的集市中卖出编号为 2 的商品（得到的金钱为 15），然后立即购买编号为 1 的商品（花费的金钱为 6）；带着编号为 1 的商品经过编号为 3 的集市，在回到编号为 1 的城市后卖出（得到的金钱为 9）。在这个环路中，总盈利为$-5+15-6+9=13$ 。 这个环路的盈利效率为$13/7$ ，向下取整后为 1 。


考虑环路 “1 - 4 - 3 - 1” ：这条环路消耗的总时间是$(1+1+1)=3$分钟。在这条环路中，最佳的交易方式是：在编号为 1 的集市中购买编号为 2 的商品（花费的金钱为 5）；在编号为 4 的集市中卖出编号为 2 的商品（得到的金钱为 11）；然后经过编号为 3 的集市回到编号为 1 的城市。在这个环路中，总盈利为$-5+11=6$。 这个环路的盈利效率为$6/3$，向下取整后为 2 。


综上所述，盈利效率最高的环路的盈利效率为 2 。


## 子任务

在所有的子任务中，保证$1 \leq N \leq 100$，$1 \leq M \leq 9900$，$1 \leq K \leq 1000$, 如果在编号为$i (1 \leq i \leq N)$的集市中，编号为$j (1 \leq j \leq K)$的商品既可以购买又可以卖出，则$0 \leq S_{i,j} \leq B_{i,j} \leq 1000000000$。对于编号为$p (1 \leq p \leq M)$的道路，保证$V_p \not= W_p$且$1 \leq T_p \leq 10000000$。 不存在满足$1 \leq p < q \leq M$的$p$，$q$使得$(V_p, W_p)=(V_q, W_q)$。

![](https://cdn.luogu.com.cn/upload/pic/5529.png)


## 样例 #1

### 输入

```
4 5 2
10 9 5 2
6 4 20 15
9 7 10 9
-1 -1 16 11
1 2 3
2 3 3
1 4 1
4 3 1
3 1 1```

### 输出

```
2```

# 题解

## 作者：wu3412790 (赞：13)

首先这题并不卡精度。二分的时候只二分整数就没有任何问题了。。。

裸分数规划+Folyd, 预处理出任意两点的距离$g[i][j]$，预处理在i点买某个东西到j点卖出的最大获益$earn[i][j]$,然后二分收益r率。把两点的距离重新定义为$w[i][j]=earn[i][j]-r*g[i][j]$。跑个Floyd，然后判断是否 $\max w[i][i]\geq 0$，即是否有正环即可。

```
#include <iostream>
#define ll long long
using namespace std;
int const N=101,K=1001,L=8;
ll const INF=1e9;
int n,m,t;
ll s[N][K],b[N][K],earn[N][N],g[N][N],f[N][N];
bool find(ll r){	
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (i==j) f[i][j]=-INF; else f[i][j]=earn[i][j]-r*g[i][j];
	for (int k=1;k<=n;k++)
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				f[i][j]=max(f[i][j],f[i][k]+f[k][j]);
	ll now=-INF;
	for (int i=1;i<=n;i++) now=max(now,f[i][i]);
	return now>=0;
}
ll get(){
	ll l=1,r=1e9;
	while (l<r-1){
		ll mid=(l+r)/2;
		if (find(mid)) l=mid; else r=mid-1;
	}
	if (find(r)) return r;
	if (find(l)) return l;
	return l-1;
}
int main(){
	cin>>n>>m>>t;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=t;j++){
			cin>>b[i][j]>>s[i][j];
			if (b[i][j]==-1) b[i][j]=INF;
			if (s[i][j]==-1) s[i][j]=0;
		}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			for (int k=1;k<=t;k++)
				earn[i][j]=max(earn[i][j],s[j][k]-b[i][k]);
	for (int i=1;i<=m;i++){
		int x,y;
		ll z;
		cin>>x>>y>>z;
		g[x][y]=z;
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (!g[i][j]) g[i][j]=INF;
	for (int k=1;k<=n;k++)
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				if (!g[i][j] || g[i][k]+g[k][j]<g[i][j]) g[i][j]=g[i][k]+g[k][j];
	
	cout<<get()<<endl;
	return 0;
}
```


---

## 作者：ywy_c_asm (赞：7)

这题搞得我十分不爽，来写篇题解。~~如此卡精度还行……~~

首先这题不禁让我们想到了一个经典问题就是最优比率生成环，就是每条边上有两个权值$a_i,b_i$，找一个环最大/小化$\frac {\sum a_i}{\sum b_i}$，这个就是0/1分数规划，二分答案然后消掉分号，转化为用SPFA判正/负环就行了。

然而这题看上去并没有那么简单，这个在环上“买入”和“卖出”的关系看上去比较复杂，然而这题有个条件就是背包容量是1，那么我们走一个环的过程就相当于这样：

![](https://cdn.luogu.com.cn/upload/pic/57408.png)

其中红的边表示从一个点买了东西，再到另一个点卖掉的过程，可以发现我们走一个环其实就走了2种边：①被红边覆盖的边（这个过程中手里拿着东西），②没有拿着东西的边，那么，我们可以将红边看做一条有价值的边！这样的话仍然能够成一个这样的环。那么我们就$O(n^2)$枚举点对$(s,t)$，求出在s买东西再在t卖出的最大价值，把这个看做一条边加进去，这条边的长度为s->t的最短路，价值为这个最大价值。对于原图的边价值就是0。然后跑个最大比率生成环就行了。

另外这题卡精度，而且你如果直接输出$(long\space long)ans$的话连样例都过不去，必须加个eps（没办法这是在double上二分出来的……），但是有个点求出来的答案是$0.999999998$，稍有不慎就会WA……把eps开成1e-9就好了……

上代码~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
#define double long double
#define abs(_o) ((_o < 0) ? -(_o) : _o)
using namespace std;
namespace ywy {
	inline int get() {
	    int n = 0;
	    char c;
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            break;
	        if (c == '-')
	            goto s;
	    }
	    n = c - '0';
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 + c - '0';
	        else
	            return (n);
	    }
	s:
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 - c + '0';
	        else
	            return (n);
	    }
	}
	typedef struct _b {
	    int dest;
	    int nxt;
	    double len;
	} bian;
	bian memchi[1000001];
	int gn = 1, heads[201];
	double dis[201];
	int que[1000001];
	unsigned char bv[201];
	inline void add(int s, int t, double l) {
	    memchi[gn].dest = t;
	    memchi[gn].len = l;
	    memchi[gn].nxt = heads[s];
	    heads[s] = gn;
	    gn++;
	}
	int deep[201];
	inline int spfa(int pt) {
	    int head = 0, tail = 1;
	    dis[pt] = 0;
	    que[0] = pt;
	    deep[pt] = 0;
	    do {
	        int me = que[head];
	        head++;
	        bv[me] = 0;
	        for (register int i = heads[me]; i; i = memchi[i].nxt) {
	            if (dis[me] + memchi[i].len >= dis[memchi[i].dest]) {
	                dis[memchi[i].dest] = dis[me] + memchi[i].len;
	                deep[memchi[i].dest] = deep[me] + 1;
	                if (deep[memchi[i].dest] > 150) {
	                    return (1);
	                }
	                if (!bv[memchi[i].dest]) {
	                    bv[memchi[i].dest] = 1;
	                    que[tail] = memchi[i].dest;
	                    tail++;
	                }
	            }
	        }
	    } while (head < tail);
	    return (0);
	}
	int g[201][201];
	int ss[100001], ts[100001], val[100001], len[100001], buy[201][2001], reng[201][2001];
	void ywymain() {
	    int n = get(), m = get(), k = get();
	    for (register int i = 1; i <= n; i++) {
	        for (register int j = 1; j <= k; j++) {
	            buy[i][j] = get();
	            reng[i][j] = get();
	        }
	    }
	    memset(g, 0x3f, sizeof(g));
	    for (register int i = 1; i <= m; i++) {
	        int s = get(), t = get(), l = get();
	        ss[i] = s;
	        ts[i] = t;
	        len[i] = l;
	        g[s][t] = min(g[s][t], l);
	    }
	    for (register int a = 1; a <= n; a++) {
	        for (register int i = 1; i <= n; i++) {
	            for (register int j = 1; j <= n; j++) g[i][j] = min(g[i][j], g[i][a] + g[a][j]);
	        }
	    }
	    for (register int i = 1; i <= n; i++) {
	        for (register int j = 1; j <= n; j++) {
	            if (g[i][j] == 0x3f3f3f3f)
	                continue;
	            int mx = -1;
	            for (register int a = 1; a <= k; a++) {
	                if (buy[i][a] == -1 || reng[j][a] == -1 || buy[i][a] >= reng[j][a])
	                    continue;
	                mx = max(mx, reng[j][a] - buy[i][a]);
	            }
	            if (mx == -1)
	                continue;
	            m++;
	            ss[m] = i;
	            ts[m] = j;
	            len[m] = g[i][j];
	            val[m] = mx;
	        }
	    }
	    double ans = -1, l = 0, r = 1e12;
	    while (r - l > 1e-10) {
	        double mid = (l + r) / 2;
	        for (register int i = 1; i <= n; i++) heads[i] = 0, dis[i] = 0, bv[i] = 0;
	        gn = 1;
	        for (register int i = 1; i <= m; i++) {
	            add(ss[i], ts[i], val[i] - len[i] * mid);
	        }
	        for (register int i = 1; i <= n; i++) {
	            if (dis[i] == 0) {
	                if (spfa(i)) {
	                    ans = mid;
	                    l = mid;
	                    goto s;
	                }
	            }
	        }
	        r = mid;
	    s:;
	    }
	    if (ans == -1) {
	        cout << 0 << endl;
	        return;
	    }
	    cout << (ll)(ans + 1e-9) << endl;
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：Eznibuil (赞：3)

前置芝士：0/1 分数规划、Floyd 求全源最短（长）路。

可以发现答案形如：$\max\left\{\dfrac{\sum s}{\sum d}\right\}$，其中 $d$ 是路径长，$s$ 是盈利。考虑 0/1 分数规划。

首先用 Floyd 预处理出任意两点间的最短路，令 $i,j$ 之间的最短路为 $d_{i,j}$。

接着预处理出 $c_{i,j}$ 代表在 $i$ 买一个并在 $j$ 卖出去的最大盈利。

二分一个答案 $x$，考虑如何检查。

令 $e_{i,j}=c_{i,j}-x\cdot d_{i,j}(i\ne j)$ 作为 $i,j$ 之间新的距离。

为了求出最大环，直接 Floyd 求出任意两点间的新最长路，令 $i,j$ 之间的新最长路为 $e'_{i,j}$。

若答案大于等于 $x$，必然存在非负环；若预先让 $e_{i,i}=-\infty$（防止出现 $i$ 自己一个点也是非负环），则必然存在 $i$，使得 $e'_{i,i}\ge0$。检查即可。

经过一通分析，可以看出这道题其实并不卡精度。二分只需要整数。如果被卡精度，可能并未考虑 $i$ 自己一个点形成环（此时答案为 $\frac00$）并在判断时取了大于而非大于等于。

记得开 `long long`。
```cpp
#include<stdio.h>
long long b[101][1001],s[101][1001],d[101][101],c[101][101],e[101][101];
int main()
{
	bool f;
	int n,m,k,v,w,t;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=0;i<n;i++)
		for(int j=0;j<k;j++)
		{
			scanf("%lld%lld",&b[i][j],&s[i][j]);
			if(!~b[i][j])
				b[i][j]=1e9;
			if(!~s[i][j])
				s[i][j]=-1e9;
		}
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			d[i][j]=i==j?0:1e9;
	while(m--)
		scanf("%d%d%d",&v,&w,&t),d[v-1][w-1]=t;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			for(int k=0;k<n;k++)
				if(d[j][k]>d[j][i]+d[i][k])
					d[j][k]=d[j][i]+d[i][k];
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			for(int l=0;l<k;l++)
				if(c[i][j]<s[j][l]-b[i][l])
					c[i][j]=s[j][l]-b[i][l];
	long long l=0,r=1e9,mid;
	while(l<=r)
	{
		mid=l+r>>1,f=1;
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				e[i][j]=i==j?-1e18:c[i][j]-mid*d[i][j];
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				for(int k=0;k<n;k++)
					if(e[j][k]<e[j][i]+e[i][k])
						e[j][k]=e[j][i]+e[i][k];
		for(int i=0;i<n&&f;i++)
			if(e[i][i]>=0)
				f=0;
		if(f)
			r=mid-1;
		else
			l=mid+1;
	}
	printf("%lld",r);
	return 0;
}
```

---

## 作者：Jason0211 (赞：2)

# 前置知识
需掌握 floyd 算法，0/1 分数规划，以及 SPFA 判正（负）环等知识。

可以先去尝试[P3199最小圈](https://www.luogu.com.cn/problem/P3199)，[P3385负环](https://www.luogu.com.cn/problem/P3385)等题。

# 解法
~~调了好几个小时才调出来~~，写完后发现和 @[hegm](https://www.luogu.com.cn/user/331947) 的思路比较相似。

根据题目中盈利效率的定义，我们可以知道，本题即要求我们找到某个环上的所有点的点集 $V$，使得 $\sum \frac{w(V_{i},V_{i+1})}{dis(V_{i},V_{i+1})}$ 最大。

其中 $w(i,j)$ 从 $i$ 点购买一件商品，并在 $j$ 点卖掉此商品所能获取的最大利润，$dis(i,j)$ 指从点 $i$ 到点 $j$ 的最短距离，因为只有这样才能使上述分数的值最大。

$w(i,j)$ 容易求解，直接三重循环枚举即可；$dis(i,j)$ 直接用 floyd 求全源点最短路即可。

接下来就和最小圈那一题的思路类似，进行二分答案，通过二分出的值构建一个完全图，如果图中存在正环，则答案可以更大，反之更小。边权求法如下：

$$\begin{aligned} dist(i,j)=w(i,j)-mid\times dis(i,j) \end{aligned}$$

具体细节见代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,b[105][1005],s[105][1005],w[105][105],dis[105][105],flag[105],dist[105],cnt[105],G[105][105];

int SPFA(int mid)
{
	memset(flag,0,sizeof(flag));
	memset(cnt,0,sizeof(cnt));
	memset(dist,-0x3f,sizeof(dist));
	queue<int> Q;
	Q.push(1);flag[1]=1;dist[1]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			G[i][j]=w[i][j]-mid*dis[i][j];
		}
	}
	while(!Q.empty())
	{
		int x=Q.front();
		Q.pop();
		flag[x]=0;
		if(cnt[x]>=n) return 1;
		for(int i=1;i<=n;i++)
		{
			if(dist[i]<=dist[x]+G[x][i])
			{
				dist[i]=dist[x]+G[x][i];
				cnt[i]=cnt[x]+1;
				if(flag[i]==0)
				{
					Q.push(i);
					flag[i]=1;
				}
			}
		}
	}
	return 0;
}//SPFA判正环

signed main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=k;j++)
		{
			scanf("%lld%lld",&b[i][j],&s[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			dis[i][j]=1e9;
			for(int t=1;t<=k;t++)
			{
				if(b[i][t]==-1||s[j][t]==-1) continue;
				w[i][j]=max(s[j][t]-b[i][t],w[i][j]);
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		int u,v,val;
		scanf("%lld%lld%lld",&u,&v,&val);
		dis[u][v]=min(val,dis[u][v]);//防止重边
	}
	for(int p=1;p<=n;p++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				dis[i][j]=min(dis[i][j],dis[i][p]+dis[p][j]);//floyd求最短路
			}
		}
	}
	int l=0,r=1e9;
	while(l<r)
	{
		int mid=(l+r+1)/2;//注意是选择左偏还是右偏
		if(SPFA(mid)) l=mid;
		else r=mid-1;
	}
	printf("%lld",l);
	return 0;
}
```

---

## 作者：_sry (赞：2)


这题卡我精度，调了一晚上才调对，因为没有想到图还可以不连通

其实可以预处理出好多东西，距离（$dis(u,v)$），买卖物品(从$u$到$v$买卖物品的最大利润，例($max{S_{u,i}-B_{v,i}}$)，然后其实可以发现就是一个十分普通普遍的分数规划式子，就每次二分$k$,然后建边，$spfa$判正环就行
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<climits>
#include<queue>
#define int long long
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int MAXN=1001;
int n,m,k;
int dis[MAXN][MAXN],b[MAXN][MAXN],s[MAXN][MAXN],st[MAXN][MAXN],l,r,maxn,D[MAXN][MAXN],num[MAXN],Dis[MAXN],vis[MAXN];
queue<int> que;
bool check(int P){
    while(!que.empty()) que.pop();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++) D[i][j]=st[i][j]-dis[i][j]*P;
    memset(Dis,0,sizeof(Dis));
    memset(num,0,sizeof(num));
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++) num[i]=vis[i]=1,que.push(i);
    while(!que.empty()){
        int xx=que.front();que.pop();vis[xx]=0;
        for(int i=1;i<=n;i++){
            int d=D[xx][i];
            if(dis[xx][i]>INT_MAX) continue;
            if(Dis[xx]+d>=Dis[i]){
                Dis[i]=d+Dis[xx];
                num[i]=num[xx]+1;
                if(num[i]>n+10) return 1;
                if(!vis[i]){
                    vis[i]=1;
                    que.push(i);
                }
                
            }
        }
    }return 0;
}
signed main(){
    memset(dis,127/3,sizeof(dis));
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=k;j++) b[i][j]=read(),s[i][j]=read();
    for(int i=1;i<=k;i++){
        for(int x=1;x<=n;x++)
           for(int y=1;y<=n;y++)
            if(b[x][i]!=-1&&s[y][i]!=-1) {
                st[x][y]=max(st[x][y],s[y][i]-b[x][i]),r=max(r,st[x][y]);
            }
    }
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),w=read();
        dis[u][v]=min(dis[u][v],w);
    }
    for(int ss=1;ss<=n;ss++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                dis[i][j]=min(dis[i][j],dis[i][ss]+dis[ss][j]);
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid)) maxn=max(maxn,mid),l=mid+1;
        else r=mid-1;
    }
    printf("%lld\n",maxn);
}
```

---

## 作者：OIer_ACMer (赞：0)

~~交易是人与人交流的一大准则~~。

------------
这道题做了我两天，现在我来大致的讲一下~~信口开河~~这道题的基本思路。


## 大致思路：
1. 输入时注意到 $n \le 100$，因此用**邻接矩阵**就可以了（本人在这里提醒各位：一道题中最好**只用一组前向星**，因为前向星涉及到的变量名字太过于混乱，容易干扰大家 AC 的速度）。


2. 紧接着，我们要用 **Floyd** 算法跑出最短路（不会超时，请君享用），然后，就是在最短路的基础上将**每个点的交易详细信息**预处理出来，为我们后面的 $01$ 规划打下基础（至于怎么预处理，实力和我差不多的蒟蒻可以详见代码，大佬可以自行思考）。


3. 然后，就是本题的重点——$01$ 规划，但是，主角不仅仅只有它，想要求出期望的盈利效率，我们就需要关注到题目中~~商人强烈要求~~要求**必须在环上交**易的条件，因此我们就可以用 **Spfa**（因为只有它能支持环）**判正环**，从而满足题目要求，同时，在这里就可用**链式前向星**建图。


4. 当然，输出答案也是必不可少的一步，由于 $01$ 分数规划要用到二分答案，所以我们输出的时候只用在当 $left$ 左标记与 $right$ 右标记~~相遇~~相等的时候输出两者任意一个就可以了（$01$ 规划性质）。



## 代码如下：

```c++

#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 1009;
const int M = 10000;
const int P = 1000;
const int INF = 2000000000;
struct edge
{
    int u, v;
    int w;
} eee[M];
struct Edge
{
    int to, nxt;
    int val;
} edge[(M << 1)];
int dist[N];
int que[N];
bool inq[N];
int tot[N];
bool vis[N];
int head[N];
int buy[N][P], sell[N][P];
int maxntra[N][N];
int dis[N][N];
int n, m, p, cnt;
void addedge(int u, int v, int w)
{
    edge[++cnt].to = v;
    edge[cnt].val = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
}
void clear()
{
    for (int i = 1; i <= n; i++)
    {
        head[i] = 0, vis[i] = false;
    }
    for (int i = 1; i <= cnt; i++)
    {
        edge[i].to = edge[i].val = edge[i].nxt = 0;
    }
    cnt = 0;
}
bool spfa(int s)
{
    for (int i = 1; i <= n; i++)
    {
        dist[i] = -INF, tot[i] = 0, inq[i] = false;
    }
    int first = 1, tail = 2;
    que[tail - 1] = s;
    dist[s] = 0ll;
    inq[s] = true;
    tot[s] = 1;
    vis[s] = true;
    while (first != tail)
    {
        int u = que[first];
        first++;
        if (first > n + 1)
        {
            first = 1;
        }
        for (int i = head[u]; i; i = edge[i].nxt)
        {
            int y = edge[i].to;
            int val = edge[i].val;
            if (dist[y] <= dist[u] + val)
            {
                dist[y] = dist[u] + val;
                vis[y] = true;
                if (!inq[y])
                {
                    que[tail] = y;
                    tail++;
                    if (tail > n + 1)
                    {
                        tail = 1;
                    }
                    inq[y] = true;
                    tot[y]++;
                    if (tot[y] > n)
                    {
                        return true;
                    }
                }
            }
        }
        inq[u] = false;
    }
    return false;
}
void floyed()
{
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
            }
        }
    }
}
signed main()
{
    n = read();
    m = read();
    p = read();
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            dis[i][j] = INF;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= p; j++)
        {
            buy[i][j] = read();
            sell[i][j] = read();
        }
    }
    for (int i = 1; i <= m; i++)
    {
        eee[i].u = read();
        eee[i].v = read();
        eee[i].w = read();
        dis[eee[i].u][eee[i].v] = eee[i].w;
    }
    floyed();
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            maxntra[i][j] = -INF;
            if (dis[i][j])
            {
                for (int k = 1; k <= p; k++)
                {
                    if (buy[i][k] != -1 && sell[j][k] != -1)
                    {
                        maxntra[i][j] = max(maxntra[i][j], sell[j][k] - buy[i][k]);
                    }
                }
            }
            // cout << "maxntra[" << i << "][" << j << "]=" << maxntra[i][j] << endl;
        }
    }
    int left = 0ll, right = INF;
    while (left < right)
    {
        int mid = (left + right + 1ll) >> 1;
        for (int i = 1; i <= m; i++)
        {
            addedge(eee[i].u, eee[i].v, -eee[i].w * mid);
        }
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (maxntra[i][j] > -INF)
                {
                    addedge(i, j, maxntra[i][j] - mid * dis[i][j]);
                }
            }
        }
        bool ok = false;
        for (int i = 1; i <= n; i++)
        {
            if (!vis[i])
            {
                bool cur = spfa(i);
                if (cur)
                {
                    ok = true;
                    break;
                }
            }
        }
        if (ok)
        {
            left = mid;
        }
        else
        {
            right = mid - 1;
        }
        clear();
    }
    cout << left;
    return 0;
}

```
[AC记录](https://www.luogu.com.cn/record/120383310)

---

## 作者：hegm (赞：0)

### [[APIO2017] 商旅](https://www.luogu.com.cn/problem/P3778)

整体二分。

本质是让你找出一个点集 $V'\in V$，使得 $\sum\limits\dfrac{w(V_i',V_{i+1}')}{dis(V_i',V_{i+1}')}$ 最大。

$w_{i,j}$ 表示的是从 $i$ 卖一件物品然后买到 $j$ 能获得的最大利润。

$dis_{i,j}$ 表示从 $i$ 到 $j$ 的最短路。

$w(i,j)$ 可以 $n^2k$ 的暴力枚举，$dis(i,j)\ n^3$ 全源最短路即可。

然后建立一个完全图，边权为 $w(i,j)-mid\times dis(i,j)$ 即可，如果此时存在正环就说明答案还能更大，否则更小。

这部分复杂度为 $n^2\log V$。

### $\text{CODE}$

```cpp
#include<bits/stdc++.h>
#define N 105
#define K 1005
#define int long long
#define inf 1000000009
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,b[N][K],s[N][K],w[N][N],dis[N][N],kl[N][N],len[N],v[N],p;
bool vis[N];
queue<int> q;
bool check(int mid)
{
	memset(len,0,sizeof(len));
	memset(vis,0,sizeof(vis));
	memset(v,-0x3f,sizeof(v));
	while(q.size())q.pop();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		kl[i][j]=w[i][j]-mid*dis[i][j];
	}
	v[1]=0;q.push(1);len[1]=1;
	while(q.size())
	{
		int now=q.front();q.pop();
		vis[now]=0;
		if(len[now]>n)return 1;
		for(int i=1;i<=n;i++)
		{
			if(v[now]+kl[now][i]>=v[i])
			{
				v[i]=v[now]+kl[now][i];
				len[i]=len[now]+1;
				if(!vis[i])q.push(i),vis[i]=1;
			}
		}
	}
	return 0;
}
signed main()
{
	n=read();m=read();p=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=p;j++)
	{
		b[i][j]=read();
		s[i][j]=read();
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			dis[i][j]=inf;
			for(int k=1;k<=p;k++)
			{
				if(b[i][k]<0||s[j][k]<0)continue;
				w[i][j]=max(s[j][k]-b[i][k],w[i][j]);
			}
		}
	}
	for(int i=1,u,v,w;i<=m;i++)
	{
		u=read();v=read();w=read();
		dis[u][v]=min(dis[u][v],w);
	}
	for(int k=1;k<=n;k++)
	{
		for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	}
	int l=0,r=1e9+9,mid;
	while(l<=r)
	{
		mid=(l+r)>>1;
		
		if(check(mid))l=mid+1;
		else r=mid-1;
	}
	cout<<l-1<<"\n";
	return 0;
}

```

---

## 作者：劉子颺 (赞：0)

水题：
01分数规划了解下？

完成这道题前请先通过如下题目

HNOI2009最小圈（几乎一模一样）

SDOI2017新生舞会

SCOI2014方伯伯运椰子

然后就会发现把路程sigma一拆开二分ans判正环就完了

小trick由于是贪心判正环那么其必然是只需要两两连一条边
```
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(g[i][j]!=INF&&i!=j){
                mmp[i][j]=0;
                for(int k=1;k<=K;k++){
                    if(b[i][k]!=-1&&s[j][k]!=-1){
                        mmp[i][j]=max(mmp[i][j],s[j][k]-b[i][k]);
                    }
                }				
            }
        }
    }
```

邻接矩阵感受下？




---


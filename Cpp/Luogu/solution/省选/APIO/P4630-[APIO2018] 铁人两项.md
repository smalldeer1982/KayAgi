# [APIO2018] 铁人两项

## 题目描述

比特镇的路网由 $m$ 条双向道路连接的 $n$ 个交叉路口组成。

最近，比特镇获得了一场铁人两项锦标赛的主办权。这场比赛共有两段赛程：选手先完成一段长跑赛程，然后骑自行车完成第二段赛程。

比赛的路线要按照如下方法规划：

1. 先选择三个两两互不相同的路口 $s$、$c$ 和 $f$，分别作为比赛的起点、切换点（运动员在长跑到达这个点后，骑自行车前往终点）、终点。
2. 选择一条从 $s$ 出发，经过 $c$ 最终到达 $f$ 的路径。考虑到安全因素，选择的路径经过同一个点至多一次。

在规划路径之前，镇长想请你帮忙计算，总共有多少种不同的选取 $s$、$c$ 和 $f$ 的方案，使得在第 $2$ 步中至少能设计出一条满足要求的路径。


## 说明/提示

**提示**

在第一个样例中，有以下 $8$ 种不同的选择 $(s, c, f)$ 的方案：

- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$；
- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$。

在第二个样例中，有以下 $14$ 种不同的选择 $(s, c, f)$ 的方案：

- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$；
- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$；
- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$。

**子任务（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

- Subtask 1（points: $5$）：$n \leq 10$，$m \leq 100$。
- Subtask 2（points: $11$）：$n \leq 50$，$m \leq 100$。
- Subtask 3（points: $8$）：$n \leq 100000$，每个交叉路口至多作为两条双向道路的端点。
- Subtask 4（points: $10$）：$n \leq 1000$，在路网中不存在环（存在环是指存在一个长度为 $k$（$k \ge 3$）的交叉路口序列 $v_1, v_2, \ldots, v_k$，序列中的路口编号两两不同，且对于 $i$ 从 $1$ 到 $k - 1$，有一条双向道路直接连接路口 $v_i$ 和 $v_{i+1}$，且有一条双向道路直接连接路口 $v_k$ 和 $v_1$）。
- Subtask 5（points: $13$）：$n \leq 100000$，在路网中不存在环。
- Subtask 6（points: $15$）：$n \leq 1000$，对于每个交叉路口，至多被一个环包含。
- Subtask 7（points: $20$）：$n \leq 100000$，对于每个交叉路口，至多被一个环包含。
- Subtask 8（points: $8$）：$n \leq 1000$，$m \leq 2000$。
- Subtask 9（points: $10$）：$n \leq 100000$，$m \leq 200000$。

## 样例 #1

### 输入

```
4 3
1 2
2 3
3 4
```

### 输出

```
8
```

## 样例 #2

### 输入

```
4 4
1 2
2 3
3 4
4 2
```

### 输出

```
14
```

# 题解

## 作者：crashed (赞：70)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P4630)看题目。   
# 分析
&emsp;&emsp;首先，我们很容易看出，在 $s$ 和 $f$ 确定时，$c$ 的备选数量就等于**从$s$到$f$所有简单路径的并的大小减二** （要把$s$和$f$去掉）。    
&emsp;&emsp;随手画几个图就会发现， $s$ 到 $f$ 所有简单路径的并似乎也就是**从$s$到$f$经过的所有点双的并**。   
&emsp;&emsp;考虑证明这个猜想。首先，由于点双之间最多只有一个公共点，所以每个点双内，每条从 $s$ 到 $f$ 的简单路径，必然是从**一个固定点进入点双，从另一个固定点离开**。   
&emsp;&emsp;因而我们只需要再证明：在点双内部，对于任意三点$a, b, c$，必然存在简单路径满足从$a$到$c$到$b$。  
&emsp;&emsp;为了方便，以下用$u\overset{c}{\rightarrow}v$表示从$u$向$v$连一条容量为$c$的边。     
&emsp;&emsp;考虑构建一个网络来证明，如下：      
&emsp;&emsp;1. 拆点。对于$u$拆成$u$和$u'$，并且连接$u\overset{1}{\rightarrow} u'$，表示每个点只能经过一次。   
&emsp;&emsp;2. 拆边。无向边先要拆成有向边。对于有向边$(u,v)$，连接$u'\overset{1}{\rightarrow} v$，表示边只能经过一次。    
&emsp;&emsp;3. 连接源汇。连接$S\overset{2}{\rightarrow} c, a'\overset{1}{\rightarrow} T,b'\overset{1}{\rightarrow} T$。   
&emsp;&emsp;这样，如果原图最大流为 $2$ ，则存在需要的路径。   
&emsp;&emsp;也就是说，我们需要证明，原图最大流，也即是最小割为 $2$ 。   
&emsp;&emsp;设最小割为$C$。显然$C\le 2$。那么我们需要证明$C>1$，即不可以只删除一条边就使得$S$到$T$不连通。   
&emsp;&emsp;分类讨论：   
&emsp;&emsp;1. 如果删除 $u\overset{1}{\rightarrow} u'$ 的边，我们就相当于拆掉了一个点。根据点双的定义，不影响连通性。   
&emsp;&emsp;2. 如果删除 $u'\overset{1}{\rightarrow} v$ 的边，我们就相当于拆掉了一条边。由于这个操作影响比拆点更小，因而也不影响连通性。   
&emsp;&emsp;3. 删除$a'\overset{1}{\rightarrow} T$或者是$b'\overset{1}{\rightarrow} T$。显然只删除一边而另一边留存都不会影响连通性。   
&emsp;&emsp;因而有$C>1$，根据连边特性我们知道就有$C=2$，即命题成立。     
&emsp;&emsp;这也就是说，我们的猜想也是成立的。   
     
&emsp;&emsp;因而我们只需要统计任意两点之间，经过的点双的并的大小减二即可。     
&emsp;&emsp;考虑建出圆方树，这样任意两点之间经过的点双就是路径上的方点。    
&emsp;&emsp;下面需要使用到一个技巧：**为圆方树上的点赋合适的权**。    
&emsp;&emsp;这一题中，我们首先可以猜想给方点赋为点双大小。由于两个点双之间最多只有一个交点，因而我们可以直接给圆点赋为 $-1$ 进行扣除多余贡献。同时，圆点赋 $-1$ 也能顺带处理 " 并集大小减二 " 这个情况。    
&emsp;&emsp;总结一下，我们给**圆点赋 $-1$ ，方点赋大小**，然后统计**任意两个圆点之间路径的权值和即可**。建出圆方树后一边 DFS 计算答案即可。时间$O(n)$。   
# 代码
```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 2e5 + 5, MAXM = 2e6 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct GRAPH
{
	struct edge
	{
		int to, nxt;
	}Graph[MAXM << 1];
	
	int head[MAXN] = {}, cnt;
	
	GRAPH() { cnt = 0; }
	
	void addEdge( const int from, const int to )
	{
		Graph[++ cnt].to = to, Graph[cnt].nxt = head[from];
		head[from] = cnt;
	}
	
	void addE( const int from, const int to )
	{
		addEdge( from, to ), addEdge( to, from );
	}
	
	void nxt( int &ptr ) const { ptr = Graph[ptr].nxt; }
	edge& operator [] ( const int indx ) { return Graph[indx]; }
}G, T;

int stk[MAXN];
int siz[MAXN], w[MAXN];
int DFN[MAXN], LOW[MAXN];
LL ans;
int N, M, cnt, ID, top, tot, subn;

void Tarjan( const int u, const int fa )
{
	subn ++;
	DFN[u] = LOW[u] = ++ ID;
	w[stk[++ top] = u] = -1;
	for( int i = G.head[u], v ; i ; G.nxt( i ) )
		if( ( v = G[i].to ) ^ fa )
		{
			if( ! DFN[v] )
			{
				Tarjan( v, u );
				LOW[u] = MIN( LOW[u], LOW[v] );
				if( LOW[v] >= DFN[u] )
				{
					T.addE( ++ tot, u ), w[tot] ++;
					do T.addE( tot, stk[top] ), w[tot] ++;
					while( stk[top --] ^ v );
				}
			}
			else LOW[u] = MIN( LOW[u], DFN[v] );
		}
}

void DFS( const int u, const int fa )
{
	siz[u] = u <= N;
	for( int i = T.head[u], v ; i ; T.nxt( i ) )
		if( ( v = T[i].to ) ^ fa )
		{
			DFS( v, u ); 
			ans += 2ll * siz[u] * siz[v] * w[u];
			siz[u] += siz[v];
		}
	ans += 2ll * siz[u] * ( subn - siz[u] ) * w[u];
}

int main()
{
	read( N ), read( M ), tot = N;
	for( int i = 1, a, b ; i <= M ; i ++ )
		read( a ), read( b ), G.addE( a, b );
	for( int i = 1 ; i <= N ; i ++ )
		if( ! DFN[i] )
		{
			subn = 0;
			Tarjan( i, 0 );
			DFS( i, 0 );
		}
	write( ans ), putchar( '\n' );
	return 0;
}
```

---

## 作者：s_r_f (赞：44)

$luogu$上的题解都太神仙了,我不太懂怎么容斥。。。。。   

首先这道题要建出圆方树。   

考虑枚举中转点$c$,统计满足条件的$(s,f)$的个数。

如果$c$为圆点:

对于$c$的每一个儿子$x$，$x$子树内的所有点作为$s$都能和其他子树中的节点组成合法的$(s,f)$,对$ans$的贡献为$size[x] * (size[c] - 1  - size[x]).$

那么一个圆点作为$c$的$ans$就是$\Sigma size[x] * (size[c] - 1  - size[x])$

看起来是$O(n^2)$的,因为要枚举根来计算$size$,但是我们可以通过一个$dp$,求出$size2[x]$表示**当$x$为根时,(dfs树上的)$fa[x]$的$size$.**

这个$dp$是$O(n)$的。  

那么就可以$O(n)$统计所有圆点的$ans$了。

再思考方点的贡献。

对于$s$和$f$都不在该点双内的$(s,f)$,它们到达这个点双内部之前,已经被这个点双里的一些点$c$计算过了，所以我们不考虑。

那么方点计算的就是**以这个点双中的某个点作为$c$,$(s,f)$中至少有一个点在点双内**，且**没有被圆点的ans统计到的**答案。   

求出这个点双中的圆点数,即方点的度数$deg[x]$.

如果$(s,f)$中有一个点在点双内部，那么可以有$(deg[x]-1)$个点双内的点作为$c$.

但是$(s,f)$在割点处被计算了一次,所以应该是$(deg[x] - 2).$

如果$(s,f)$都在点双内部,那么可行的$c$显然有$(deg[x] - 2)$种。

所以方点的答案为 $\Sigma (deg[c] - 2) * size[x] * (size[c] - size[x])$

这个也可以用类似上面的$dp$方法做到$O(n)$.

所以这道题的复杂度为$O(n+m).$

注意图**不联通**。

代码:

```cpp

#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline LL read(){
    LL x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(LL x){
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
inline void writeln(LL x){ write(x),putchar('\n'); }

const int N = 100005,M = 200005,E = M*4;
int To[E],Ne[E],He1[N],He2[N<<1],k;
inline void add(int *He,int x,int y){
	++k; To[k] = y,Ne[k] = He[x],He[x] = k;
	++k; To[k] = x,Ne[k] = He[y],He[y] = k;
}

int n,m,tot,deg[N<<1];
int dfn[N],low[N],st[N],top,Tim;
void tarjan(int x){
	dfn[x] = low[x] = ++Tim,st[++top] = x;
	for (int y,p = He1[x]; p ; p = Ne[p]){
		y = To[p];
		if (!dfn[y]){
			tarjan(y);
			low[x] = min(low[x],low[y]);
			if (low[y] >= dfn[x]){
				++tot; add(He2,tot,x); add(He2,tot,y);
				++deg[x],++deg[y],deg[tot] += 2;
				while (st[top] ^ y) add(He2,st[top],tot),++deg[tot],++deg[st[top]],--top;
				--top;
			}
		}
		else low[x] = min(low[x],dfn[y]);
	}
}

int size1[N<<1],size2[N<<1],fa[N<<1];
void dfs1(int x){
	size1[x] = x <= n ? 1 : 0;
	for (int p = He2[x]; p ; p = Ne[p]) if (To[p] ^ fa[x]) fa[To[p]] = x,dfs1(To[p]),size1[x] += size1[To[p]];
}
LL ans,ret;
void dfs2(int x){
	if (fa[x]) size2[x] = size2[fa[x]] + size1[fa[x]] - size1[x];
	for (int y,p = He2[x]; p ; p = Ne[p]) if ((y=To[p])^fa[x]) dfs2(To[p]);
	int sum = size2[x] + size1[x];
	ret = 0;
	if (x <= n){
		for (int y,p = He2[x]; p ; p = Ne[p]) if ((y=To[p])^fa[x]){
			ans += (LL)(sum - size1[y] - 1) * size1[y];
		}
		ans += (LL)(sum - size2[x] - 1) * size2[x];
	}
	else{
		for (int y,p = He2[x]; p ; p = Ne[p]) if ((y=To[p])^fa[x]){
			ans += (LL)(sum - size1[y]) * size1[y] * (deg[x] - 2);
		}
		ans += (LL)(sum - size2[x]) * size2[x] * (deg[x] - 2);
	}
}

int main(){
	int i,u,v;
	tot = n = read(),m = read();
	while (m--) u = read(),v = read(),add(He1,u,v);
	for (i = 1; i <= n; ++i) if (!dfn[i]) top = 0,tarjan(i);
	for (i = 1; i <= tot; ++i) if (!size1[i]) dfs1(i);
	for (i = 1; i <= tot; ++i) if (!size2[i]) dfs2(i);
	writeln(ans);
    return 0;
}

```

---

## 作者：我家羊肉汤 (赞：20)

对于一般无向图上的简单路径问题，我们一般考虑 Tarjan。

对于这题，我们首先将每一个点双联通分量缩起来，方便我们的统计。

具体方法是，每找到一个点双联通分量，你就新建一个点，将其向点双联通分量里的每一个点连边，这样图就变成了一棵树。
考虑这棵树的性质：我们将我们新建的点叫做 **_方点_** ,原来的点叫做 **_圆点_**，那么我们就得出一棵叫做 **_圆方树_** 的树。

对于这么一棵树，我们有什么性质呢？

-	树上只存在“圆圆边”和“圆方边”。
-	每一个方点对应一个点双联通分量。
-	方点的点度是点双联通分量的大小。

对于点双联通分量，我们又有什么性质呢？

我们称满足题意的路径叫做 **_合法路径_**，那么：

-	对于属于一个点双联通分量的任意点对 $(u,v)$，以这个点双联通分量除了 $u$ 和 $v$ 以外的任何点作为中间点，都存在一条合法路径

-	若圆方树上的点对之间的路径（显然树上路径是唯一的）经过一个点双联通分量，则这个点双联通分量内的每一个点都能当做中间点（即题中的点 $c$）。

注意到这里的统计与点 $c$ 有关，所以我们考虑枚举每一个点作为点 $c$ 时候的答案。

设 $f(i)$ 表示 $i$ 的子树内有多少个点对 $(u,v)$ 满足 $(u,i,v)$ 是一条合法路径。

若 $i$ 是圆点，设 $siz(i)$ 表示 $i$ 的子树大小（方点不算大小），那么有：

$$f(i)=\sum_{j=son_i} (siz(i)-siz(j)-1)siz(j)$$

若 $i$ 是方点，设 $deg(i)$ 表示 $i$ 代表的点双联通分量的大小（即该点点度），由于一个任意一个点双联通分量内的点都可以作为中转点（点双联通分量的性质）。所以有：

$$f(i)=(deg(i)-2) \sum_{j=son_i} (siz(i)-siz(j))siz(j)$$

枚举根 $dp$，复杂度 $O(n^2)$。

~~强行加上换根 dp 就 O(n) 了，可以通过。~~

换根 dp 太复杂了，我们采取一种更简单的做法。

观察我们刚刚的做法，我们最终求的是所有 $f(root)$ 的和。

我们换种统计方法，对于树上的任意一条路径，都是一条合法路径，且此时的方案数为该点两边点数的积再乘上这个点代表的点双联通分量的大小。

当然这样割点被我们重复统计了，在最后算答案的时候我们要将经过割点的答案扣掉（事实上是一个小容斥）

复杂度 $O(n)$，可以轻松通过。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#ifdef DEBUG
	#define debug(a...) (fprintf(stderr,a),fflush(stderr),1)
#else
	#define debug(a...) (1)
#endif
#define dmax(x,y) ((x)<(y)?(y):(x))
#define dmin(x,y) ((x)<(y)?(x):(y))
#define cmax(x,y) (((x)<(y))&&((x)=(y)))
#define cmin(x,y) (((x)>(y))&&((x)=(y)))
#define reg register
inline int read()
{
	reg int x=0;reg char ch=getchar();reg bool f=0;
	for(;ch<48||57<ch;ch=getchar()) f|=(ch=='-');
	for(;47<ch&&ch<58;ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
	return f?-x:x;
}

namespace RRP
{
	const int maxn=200010;
	struct edge{int to;edge*nxt;}*head1[maxn],*head2[maxn];
	inline void add1(int u,int v)
	{
		static edge E[maxn<<1],*tot=E;
		*++tot=(edge) {v,head1[u]},head1[u]=tot;
		*++tot=(edge) {u,head1[v]},head1[v]=tot;
	}
	inline void add2(int u,int v)
	{
		static edge E[maxn<<1],*tot=E;
		*++tot=(edge) {v,head2[u]},head2[u]=tot;
		*++tot=(edge) {u,head2[v]},head2[v]=tot;
	}
	int n,m,cntt;
	int cnt,tmr,dfn[maxn],low[maxn],stk[maxn],*top;
	int siz[maxn];
	long long ans,tmpans[maxn];
	void Tarjan(int u)
	{
		*++top=u;++cnt;dfn[u]=low[u]=++tmr;
		for(edge* i=head1[u];i;i=i->nxt)
		if(!dfn[i->to])
		{
			Tarjan(i->to);
			cmin(low[u],low[i->to]);
			if(dfn[u]==low[i->to])
			{
				int tmp=0;++cntt;
				for(;tmp!=i->to;--top)
				{
					tmp=*top;
					add2(cntt,tmp);
				}
				add2(cntt,u);
			}
		} else cmin(low[u],dfn[i->to]);
	}
	void dfs(int u,int fa)
	{
		siz[u]=(u<=n)?1:0;
		for(edge* i=head2[u];i;i=i->nxt)
		if(i->to!=fa)
		{
			dfs(i->to,u);
			siz[u]+=siz[i->to];
		}
		if(u<=n)
		{
			ans+=1ll*(cnt-1)*(cnt-1);
			for(edge* i=head2[u];i;i=i->nxt) if(i->to!=fa) ans-=tmpans[i->to];
		}
		else
		{
			for(edge* i=head2[u];i;i=i->nxt)
				if(i->to!=fa) tmpans[u]+=1ll*siz[i->to]*siz[i->to];
			for(edge* i=head2[u];i;i=i->nxt)
				if(i->to!=fa) ans-=tmpans[u]-1ll*siz[i->to]*siz[i->to]+1ll*(cnt-siz[u])*(cnt-siz[u]);
		}
	}
	
	inline int main()
	{
		n=read(),m=read();cntt=n;
		while(m--) add1(read(),read());
		for(reg int i=1;i<=n;++i) if(!dfn[i]) top=stk,cnt=0,Tarjan(i),dfs(i,0);
		printf("%lld\n",ans);
		return 0;
	}
}
int main() {return RRP::main();}
```



---

## 作者：Great_Influence (赞：19)

简单圆方树。

可以发现，答案就是路径上可能经过的点数。考虑将图缩成圆方树，统计树上路径点数。可以简单发现，如果将方点的权值标为点双大小，圆点的权值标为-1，则某条路径上可能经过的点数就是圆方树上路径点权和。直接做是$O(n^2)$的，但是可以改为统计每个点被经过多少次再乘上它的权值，可以利用简单$dfs+dp$做到$O(n)$。

注意图不一定联通。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmin(a,b) a=a<b?a:b
template<typename T>inline void read(T &x)
{
	T f=1;x=0;char c;
	for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+(c^48);
	x*=f;
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
	freopen("duathlon.in","r",stdin);
	freopen("duathlon.out","w",stdout);
#endif
}
const int MAXN=1e6+7,MAXM=2e6+7;

static int n,m,Q,e;

struct edge
{
    int v,nxt;
};

static struct edges
{
    edge p[MAXM];
    int head[MAXN];

    inline void add(int u,int v)
	{this->p[++e]=(edge){v,head[u]};this->head[u]=e;}
}p,q;

static int dfn[MAXN],low[MAXN],bel[MAXN],cnt,sta[MAXN],tp,dfc,w[MAXN],siz;

void tarjan(int u,int ff)
{
    dfn[u]=low[u]=++dfc;sta[++tp]=u;w[u]=-1;++siz;
    for(register int v=p.head[u];v;v=p.p[v].nxt)
    {
        if(!dfn[p.p[v].v])
        {
            tarjan(p.p[v].v,u);
            Chkmin(low[u],low[p.p[v].v]);
            if(low[p.p[v].v]>=dfn[u])
            {
                q.add(u,++cnt);w[cnt]=1;
                static int las;
                do
                {
                    las=sta[tp--];++w[cnt];
                    q.add(cnt,las);
                }while(las^p.p[v].v);
            }
        }else if(p.p[v].v^ff)Chkmin(low[u],dfn[p.p[v].v]);
    }
}

static int dep[MAXN];

inline void init()
{
	read(n);read(m);
	static int u,v;
	Rep(i,1,m)read(u),read(v),p.add(u,v),p.add(v,u);
}

static int sz[MAXN],vis[MAXN];

static long long ans;

void calculate(int u,int ff)
{
	if(u<=n)sz[u]=1,vis[u]=1;
	long long cnt=0ll;
	for(register int v=q.head[u];v;v=q.p[v].nxt)if(q.p[v].v^ff)
	{
		calculate(q.p[v].v,u);
		cnt+=(long long)2*sz[u]*sz[q.p[v].v];
		sz[u]+=sz[q.p[v].v];
	}
	cnt+=(long long)2*sz[u]*(siz-sz[u]);
	ans+=cnt*w[u];
}

inline void solve()
{
	cnt=n;
	Rep(i,1,n)if(!vis[i])siz=0,tarjan(i,0),calculate(i,0);
	printf("%lld\n",ans);
}

int main()
{
	file();
	init();
	solve();
	return 0;
}

```

---

## 作者：Sure042 (赞：17)

一道圆方树模板题

推荐阅读/参考资料 [圆方树学习笔记——小粉兔](https://www.luogu.com.cn/blog/PinkRabbit/Introduction-to-Block-Forest)

## 题意简述

给定一张简单无向图，问有多少对三元组 $<s,c,f>$ （互不相同）使得存在一条简单路径从 $s$ 出发，经过 $c$ 到达 $f$ 。

## 思路

每一对固定的从起点 $s$ 到终点 $f$ 的 $c$ 的数量显然相当于这两点间所有简单路径上的点数之和减去 $2 (s,f $ 本身 $)$ ，但对于题目中的无规律图（无规律在于含有环、可能为森林等），这样的点数显然不好求，所以我们想到了圆方树。

> 圆方树可以做到把简单无向图转换为我们熟悉的树结构，从而进行一些树上的操作，所以我们在遇到这种图时会想到圆方树

利用差分的思想，我们将圆方树上的每个圆点权值赋为 $-1$ ，每个方点的权值赋为其点双的大小，最终答案转化为：

 $$\sum w_i,i\in T$$ 
 
( $T$ 为圆方树， $G$ 为原图）
 
 考虑到每个点 $i$ 作为中转点 $c$ ，它的贡献为以下两种情况之和：
 
 - $s$ **与** $f$ **都** 为它的子树中的点，此时贡献为
 
  $$ 2\times \sum size_j\times (size_i-size_j)\times w_i$$
  
-  $j$ 为 $i$ 子树中的节点
 
 图示为 $j=2$ ， $i=1$ 时，红色为 $size_2$ ，蓝色为 $size_1-size_2$ ，相乘即为节点 $2$  作为节点 $1$ 的子节点时对 $1$ 的贡献。
 
 ![QQ截图20211008212447.png](https://i.loli.net/2021/10/08/ae1UdlhKC5V2qYm.png)
 
 -  $s,f$ 有且仅有一个为 $i$ 的子节点时，所有点 $j$ 产生的总贡献为：
  $$2\times size_i\times (num-size_i)\times w_i$$ 
  
- 其中 $num$ 为圆方树总节点数。

需要注意的是： $\text{dfs}$ 遍历每个点作为中转点时，子树中的节点既可作为起点也可作为终点，所以它的贡献要乘 $2$ 。

这样做的好处在于在统计贡献时不用专门区分方点和圆点，只需通过特殊点权 $w$ 就可以实现统计，比较好理解。

具体实现看代码

Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N=2e5+7,M=2e5+7;//圆方树点数记得开双倍

int w[N];//点权
int n,m;

inline void read(int &x)
{
    char ch=getchar();x=0;
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
}

int fst[N],tot=0;
int fst1[N],tot1=0;
struct rec{int to,nxt;}e[M<<1];
struct rec1{int to,nxt;}e1[M<<1];

inline void add(int u,int v,bool o)
{
    if(!o)
    {
        e[++tot].to=v;
        e[tot].nxt=fst[u];
        fst[u]=tot;
        e[++tot].to=u;
        e[tot].nxt=fst[v];
        fst[v]=tot;
    }
    else
    {
        e1[++tot1].to=v;
        e1[tot1].nxt=fst1[u];
        fst1[u]=tot1;
        e1[++tot1].to=u;
        e1[tot1].nxt=fst1[v];
        fst1[v]=tot1;
    }
}

int dfn[N],low[N],st[N];
int sub=0,cnt=0,top=0,num=0;
int min(int a,int b){return a<b?a:b;}

void Tarjan(int u)//圆方树经典操作
{
    dfn[u]=low[u]=++sub,st[++top]=u;
    num++;
    for(int i=fst[u];i;i=e[i].nxt)
    {
        int v=e[i].to;
        if(!dfn[v])
        {
            Tarjan(v);
            low[u]=min(low[v],low[u]);
            if(low[v]==dfn[u])
            {
                w[++cnt]=1;//更新方点权值
                while(st[top]!=v)
                {
                    w[cnt]++;
                    add(cnt,st[top],1);
                    top--;
                }
                add(cnt,u,1);
                top--,w[cnt]++,add(v,cnt,1);
            }
        }
        else
            low[u]=min(dfn[v],low[u]);
    }
}

ll ans=0;
int size[N<<1];

void dfs(int x,int fa)
{
    size[x]=(x<=n);//方点不具实际大小
    for(int i=fst1[x];i;i=e1[i].nxt)
    {
        int y=e1[i].to;
        if(y==fa) continue;
        dfs(y,x);
        ans+=(ll)2*(ll)size[x]*(ll)size[y]*(ll)w[x];//节点作为x子节点的贡献，注意此时的size[x]在未加上size[y]前与size[y]相乘        size[x]+=size[y]; 
    }
    ans+=(ll)2*(ll)size[x]*(ll)(num-size[x])*(ll)w[x];//子树内的节点与外部节点作为s，f的贡献
}

int main()
{
    read(n),read(m);
    cnt=n;
    for(int i=1;i<=n;i++) w[i]=-1;
    for(int i=1,x,y;i<=m;i++)
    {
        read(x),read(y);
        add(x,y,0);
    } 
    for(int i=1;i<=n;i++)//注意处理森林
        if(!dfn[i])
        {
            num=0;
            Tarjan(i);
            --top;
            dfs(i,0);
        }
    cout<<ans;
    return 0;
}
```


---

## 作者：楠枫 (赞：8)

## 题解
题目[传送门](https://www.luogu.com.cn/problem/P4630)  

题目简化：给出一张无向图，问存在多少组 $<s,c,f>$ 使得 $s$ 由 $c$ 可以到达 $f$ 。

这道题可以算是一道圆方树的模板题,由圆方树的性质可知，对于一个点双中的两点，他们之间简单路径和其上的点的并集恰好为这个点双。意思就是点双中的两个点 $u$ , $v$ 之间一定存在一条简单路径经过同一个点双内的另外一个点 $w$ 。

由这个结论可知，考虑两圆点在圆方树上的简单路径，与路径上经过的方点相邻的圆点的集合，即为原图此简单路径上的点集。

因此，对于题目中的 $<s,c,f>$ ，我们可以固定 $s$ 和 $f$ ，求合法的 $c$ 的数量，易得合法的 $c$ 的数量等于 $s$ ， $f$ 之间简单路径并集的点数减 $2$ 。(去掉 $s$ ，$f$ 本身)。

这里可以用一个圆方树的技巧，即在路径统计时，给点附上合适的点权。但要具体情况具体分析。

本题中，每个方点权值对应其点双的大小，每个圆点权值为 $-1$ 。(自己动手画一画就明白了)。

问题就转化为了统计圆方树上 $\sum$  **两圆点**间简单路径权值和。

这样统计很麻烦，而我们换个角度思考一下，考虑每个点对答案的影响，即用通过它的路径条数乘上它的权值。而它的路径条数就是： (所有以此点为根的树中每两个子树中圆点个数相乘再相加，再加上每个子树中圆点个数与不属于这个点的树的圆点个数相乘) $×$ $2$ 。

最后不要忘了处理图不联通的情况。  
 $AC \kern 0.5emCODE$ :
 ```cpp
#include<bits/stdc++.h>
#define int long long//懒人大法
using namespace std;
const int N=100100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,m,dfn[N],low[N],tot,cnt,size[N<<1],num,ans,w[N<<1];
stack<int> s;
vector<int> G[N],T[N<<1];
void tarjan(int u) {//求点双，建圆方树
	low[u]=dfn[u]=++tot;
	s.push(u);num++;//num记录所有的圆点个数
	for (int i=0;i<G[u].size();i++) {
		int v=G[u][i];
		if (!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if (low[v]>=dfn[u]) {
				w[++cnt]=0;//方点权值为其点数
				int k=0;
				while(k!=v) {
					k=s.top();
					T[cnt].push_back(s.top());
					T[s.top()].push_back(cnt);
					w[cnt]++;
					s.pop();
				}
				T[u].push_back(cnt);T[cnt].push_back(u);w[cnt]++;//割点可能属于多个点双，所以只建边即可，不能退栈
			}
		} else low[u]=min(low[u],dfn[v]);
	}
}
void dfs(int u,int fa) {
	size[u]=(u<=n);//判断是否是圆点，size存树中圆点的数量
	for (int i=0;i<T[u].size();i++) {
		int v=T[u][i];
		if (v!=fa) {
			dfs(v,u);
			ans+=2*w[u]*size[u]*size[v];
			size[u]+=size[v];//不能与上一行换位置
		}
	}
	ans+=2*w[u]*size[u]*(num-size[u]);
}
signed main() {
	n=read(),m=read();
	memset(w,-1,sizeof(w));
	cnt=n;//方点从圆点后编号
	for (int i=1;i<=m;i++) {
		int u=read(),v=read();
		G[u].push_back(v);G[v].push_back(u);
	}
	for (int i=1;i<=n;i++) {//处理图不联通的情况
		if (!dfn[i]) {
			num=0;//图可能不联通，所以num要初始化为0
			tarjan(i);dfs(i,0);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
 ```
注意：
```cpp
int k=0;
while(k!=v) {
	k=s.top();
	T[cnt].push_back(s.top());
	T[s.top()].push_back(cnt);
	w[cnt]++;
	s.pop();
}
```
不能写成
```cpp
while(s.top()!=u) {
	T[cnt].push_back(s.top());
	T[s.top()].push_back(cnt);
	w[cnt]++;
	s.pop();
}
```
本题解得到了[小粉兔](https://www.luogu.com.cn/user/10703)巨佬博客的很大帮助，也借鉴了很多，在此感谢。

---

## 作者：Sai0511 (赞：8)

圆方树。             
我们建立圆方树之后枚举每个起点和终点。    
然后设方点的权值为点双的个数，圆点的权值是-1。     
之后可以得到答案就是两点之间的点权和。       

之后不难发现对于一个点的贡献可以用一遍$\text{dfs}$得到,这道题就做完了。          
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int maxn = 4e5 + 10;
typedef long long ll;
namespace Fast_Input {
    template<class T> inline void read(T& res) {
        res = 0;  char ch;  bool sign = 0;   
        do { ch = getchar();  sign |= ch == '-'; } while(!isdigit(ch));
        while(isdigit(ch)) res = (res << 1) + (res << 3) + (ch & 15),ch = getchar();
        (sign) && (res = -res);
        return;
    }
}
using Fast_Input::read;  
int n,m,i,j,k,sta_top,extra,tot,s;   
int dfn[maxn],low[maxn],sta[maxn],val[maxn],sz[maxn];
ll ans;  
struct Graph {
    int head[maxn],nxt[maxn << 1],ver[maxn << 1];   int ecnt;    
    inline Graph() { ecnt = 0;  memset(head,-1,sizeof(head)); }   
    inline void adde(int u,int v) {
        ver[++ecnt] = v;  nxt[ecnt] = head[u];
        head[u] = ecnt;  return;
    }
    inline void readd(int u,int v) {
        adde(u,v);  adde(v,u);  return;
    }
} gold,gnew;
inline void cmin(int& x,int y) {
    if(x > y) x = y;  return;
}
void tarjan(int u) {
    dfn[u] = ++tot;  low[u] = ++tot;  sta[++sta_top] = u;  sz[u] = 1;    
    for(int i = gold.head[u],v;~i;i = gold.nxt[i]) {
        v = gold.ver[i];  
        if(!dfn[v]) {
            tarjan(v);  cmin(low[u],low[v]); 
            if(low[v] >= dfn[u]) {
                int t = 0,cnt = 1;  extra++;
                do {
                    t = sta[sta_top--];  cnt++;  
                    gnew.readd(extra,t);
                    sz[extra] += sz[t];
                } while(t != v);  
                val[extra] = cnt;  sz[u] += sz[extra];  
                gnew.readd(extra,u); 
            }
        } else cmin(low[u],dfn[v]);   
    }
}
void dfs(int u,int fa) {
    int x = u <= n;   ans += 2ll * sz[u] * (s - sz[u]) * val[u];
    for(int i = gnew.head[u],v;~i;i = gnew.nxt[i]) {
        v = gnew.ver[i];  if(v == fa) continue;
        ans += 2ll * x * sz[v] * val[u];
        x += sz[v];  dfs(v,u);  
    }
    return;
}
int main() {
    read(n);  read(m);  extra = n;
    for(int i = 1;i <= n;i++) val[i] = -1;
    for(int i = 1,u,v;i <= m;i++) {
        read(u);  read(v);  
        gold.readd(u,v);
    } 
    for(int i = 1;i <= n;i++) {
        if(!dfn[i]) {
            tarjan(i); s = sz[i];  dfs(i,-1);   
        }
    }
    printf("%lld\n",ans);
}

```

---

## 作者：Sol1 (赞：6)

给定一个无向图，求有多少个三元组 $(x,y,z)$ 使得存在从 $x$ 开始，经过 $y$，在 $z$ 结束的简单路径。

无向图路径问题，限制是点只能经过 $1$ 次，故从 v-BCC 考虑。v-BCC 有一个很知名的产物就是圆方树，所以直接将原图化为圆方树，然后在圆方树上求解。

然后观察出如果 $y$ 与 $x\rightsquigarrow z$ 在树上的路径上的某一个方点有边连接，则 $(x,y,z)$ 一定满足条件。

大概可以这样证明：

设与 $y$ 有连接的路径上的那个方点为 $v$，则存在另外两个点 $x',z'$ 使得树上路径 $x\rightsquigarrow z$ 等价于 $x\rightsquigarrow x'\rightarrow v\rightarrow z'\rightsquigarrow z$，且 $x',y,z'$ 在同一个 v-BCC。

然后如果在原图上无法找到一条 $x'$ 到 $y$ 的路径和一条 $y$ 到 $z'$ 的路径使得两条路径只在 $y$ 相交，那么所有 $x'$ 到 $y$ 的路径的交 $P$ 和所有 $z'$ 到 $y$ 的路径的交 $Q$ 的交集 $P\cup Q$ 一定有一个除 $y$ 以外的点 $u$，而割掉 $u$ 之后 $x',z'$ 与 $y$ 均不连通（因为所有到 $y$ 的路径都要经过 $u$），这与 $x',y,z'$ 在同一个 v-BCC 矛盾。

所以上述结论成立。

那么，在得到这个结论之后，对于路径 $x\rightsquigarrow z$，可选取的 $y$ 就分两种：

1. 在路径上的圆点。
2. 与路径上的至少一个方点有边直接相连的圆点。

（事实证明 2 是包含 1 的……不过我代码这么写了就这么说吧……）

所以在圆点上面记录 $1$ 的权值，在方点上面记录度数减 $2$ 的权值（因为路径会过两个与之相连的圆点），问题转化为对树上每个点对求路径点权之和。

这是一个经典问题，直接换根 DP 即可。

复杂度 $O(n+m)$。

一个小坑是这题的图可以不连通，WA 64 分可能是因为这个原因。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

struct Edge {
	int to, nxt;
	Edge() {
		nxt = -1;
	}
};
struct Graph {
	Edge e[400005];
	int hd[200005], pnt;
	Graph() {
		pnt = 0;
		memset(hd, -1, sizeof(hd));
	}
	inline void AddEdge(int u, int v) {
		e[++pnt].to = v;
		e[pnt].nxt = hd[u];
		hd[u] = pnt;
	}
};
Graph reg, rst;
int n, m, stk[200005], stktop, bcccnt, dfn[200005], low[200005], _time;
long long siz[200005], sumdep[200005], w[200005], wsum[200005], ans;
bool vis[200005];

inline void Read() {
	n = qread(); m = qread();
	for (int i = 1;i <= m;i++) {
		int u = qread(), v = qread();
		reg.AddEdge(u, v);
		reg.AddEdge(v, u);
	}
}

inline void Tarjan(int u, int fa) {
	dfn[u] = low[u] = ++_time;
	stk[++stktop] = u;
	for (int i = reg.hd[u];~i;i = reg.e[i].nxt) {
		int v = reg.e[i].to;
		if (!dfn[v]) {
			Tarjan(v, u);
			low[u] = Min(low[u], low[v]);
			if (low[v] >= dfn[u]) {
				bcccnt++;
				w[bcccnt + n] = -1;
				for (;;) {
					int x = stk[stktop--];
					rst.AddEdge(bcccnt + n, x);
					rst.AddEdge(x, bcccnt + n);
					w[bcccnt + n]++;
					if (x == v) break;
				}
				rst.AddEdge(bcccnt + n, u);
				rst.AddEdge(u, bcccnt + n);
			}
		} else if (dfn[v] < dfn[u] && v != fa) {
			low[u] = Min(low[u], dfn[v]);
		}
	}
}

inline void Prefix() {
	for (int i = 1;i <= n;i++) {
		if (!dfn[i]) Tarjan(i, -1);
		siz[i] = 1;
		w[i] = 1;
	}
}

inline void Link(int u, int v) {
	siz[u] += siz[v];
	wsum[u] += wsum[v];
	sumdep[u] += sumdep[v] + siz[v] * w[u];
}

inline void Cut(int u, int v) {
	sumdep[u] -= sumdep[v] + siz[v] * w[u];
	siz[u] -= siz[v];
	wsum[u] -= wsum[v];
}

inline void Dfs1(int u, int fa) {
	vis[u] = 1;
	wsum[u] = w[u];
	siz[u] = (u <= n);
	sumdep[u] = w[u];
	for (int i = rst.hd[u];~i;i = rst.e[i].nxt) {
		int v = rst.e[i].to;
		if (v != fa) {
			Dfs1(v, u);
			Link(u, v);
		}
	}
}

inline void Dfs2(int u, int fa) {
	//printf("%d %lld %lld %lld\n", u, sumdep[u], siz[u], wsum[u]);
	if (u <= n) ans += sumdep[u] - (siz[u] - 1) * w[u] - wsum[u];
	for (int i = rst.hd[u];~i;i = rst.e[i].nxt) {
		int v = rst.e[i].to;
		if (v != fa) {
			//printf("v=%d\n", v);
			Cut(u, v);
			//printf("%lld\n", siz[u]);
			Link(v, u);
			Dfs2(v, u);
			Cut(v, u);
			Link(u, v);
		}
	}
}

inline void Solve() {
	for (int i = 1;i <= n;i++) {
		if (!vis[i]) {
			Dfs1(i, -1);
			Dfs2(i, -1);
		}
	}
	printf("%lld", ans);
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---

## 作者：wurzang (赞：4)

先考虑部分分...

$\rm Subtask \ 1 \ \& \ 2$：直接 $\mathcal{O(n^4)}$ 暴力做即可。

期望得分 $\rm 16 \ pts$


$\rm Subtask \ 4  \ \& \ 5 $：非环的情况，可以考虑树形 dp 去做。

设 $f_i$ 为以 $i$ 为中转点的点对数量，然后式子很显然...直接看代码如下：

```cpp
	for(int i=0;i<g[x].size();++i){
		int v=g[x][i];
		if(v==fath) continue;
		dfs(v,x);
		ans+=1ll*sz[x]*sz[v];
		sz[x]+=sz[v];	
	}
	++sz[x];
	ans+=1ll*(all-sz[x])*(sz[x]-1);
```

由于图并不保证联通，所以用 `all` 来表示联通块的点的数量。

顺便一提由于 $s \rightarrow c \rightarrow f$ 和 $f \rightarrow c \rightarrow s$ 算两种不同的方案，所以最后答案还要乘个 $2$

期望得分 $\rm 16+23=39 \ pts$

$\rm Subtask \ 6 \ \& \ 7 $：仙人掌的情况...仙人掌+dp 那不就是在圆方树上 dp 吗...

跟上面一样设 $f_i$ 为以 $i$ 为中转点的点对数量，圆点的情况和原来差不多。

对于方点的情况...分类讨论一下。

设 $Bsz$ 为方点代表的环的大小。

$s$ 和 $f$ 都在方点代表的环内：显然中转点有 $Bsz-2$ 个

$s$ 和 $f$ 两个都不在方点代表的环内：有 $Bsz$ 个中转点。然而会被 $2$ 个圆点给计算过一次，发现会有重复，去重一下就有 $Bsz-2$ 个中转点。

$s$ 和 $f$ 有且只有一个在方点代表的环内：$Bsz-1$ 个中转点。发现会算重，去重一下 $Bsz-2$ 个中转点。


综上所述中转点数量有 $Bsz-2$ 个。于是在算的时候乘上一个 $Bsz-2$ 的系数就行。


期望得分 $\rm39+35=74 \ pts$





------------


至于正解...直接对原图建广义圆方树，然后做法同 $\rm Subtask \ 6 \ \& \ 7$ 。


代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200000+5;
struct edge{
	int nxt,to;
}e[N<<1];
int head[N],cnt=1;
vector<int> g[N];
void add(int x,int y){
	e[++cnt].to=y; e[cnt].nxt=head[x]; head[x]=cnt;
}
int n,all,dfn[N],low[N],tot,sz[N],Bsz[N],amt;
stack<int> S;
void tarjan(int x,int fath){
	dfn[x]=low[x]=++tot;
	S.push(x);
	++all;
	for(int i=head[x];i;i=e[i].nxt)
		if(e[i].to!=fath){
			int v=e[i].to;
			if(!dfn[v]){
				tarjan(v,x);
				if(low[v]==dfn[x]){
					++amt;
					g[amt].push_back(x);
					g[x].push_back(amt);
					Bsz[amt]=1;
					while(1){
						int now=S.top();S.pop();
						g[now].push_back(amt);
						g[amt].push_back(now);
						Bsz[amt]++;
						if(now==v) break;
					}
				}
				else if(low[v]>dfn[x]) S.pop(),g[x].push_back(v),g[v].push_back(x);
				low[x]=min(low[x],low[v]);
			}
			else low[x]=min(low[x],dfn[v]);
		}
}
long long ans;
void dfs(int x,int fath){
	for(int i=0;i<g[x].size();++i){
		int v=g[x][i];
		if(v==fath) continue;
		dfs(v,x);
		if(x<=n) ans+=1ll*sz[x]*sz[v];
		else ans+=1ll*(Bsz[x]-2)*sz[x]*sz[v];
		sz[x]+=sz[v];	
	}
	if(x<=n){
		++sz[x];
		ans+=1ll*(all-sz[x])*(sz[x]-1);
	}
	else ans+=1ll*(Bsz[x]-2)*(all-sz[x])*sz[x];
}
int main(){
	int m;
	cin>>n>>m;
	int U,V;
	for(int i=1;i<=m;++i){
		cin>>U>>V;
		add(U,V);add(V,U);
	}
	amt=n;
	for(int i=1;i<=n;++i)
		if(!dfn[i]){
			all=0;
			tarjan(i,0);
			dfs(i,0);
		}
	cout<<ans*2ll;
	return 0;
}

```


---

## 作者：dsidsi (赞：4)

# [「APIO2018」铁人两项-圆方树](https://loj.ac/problem/2587)

## Description

给定一张无向图，询问存在多少三元组$(s,c,f)$（$s,c,f$各不相同）满足存在一条从$s$到$c$，$c$到$f$的简单路径。

$n \leq 10^5, m \leq 10^5$

## Solution

考虑建立圆方树。

固定$s,f$，满足条件的$c$一定存在$s$到$f$路径上方点所代表的点双上。

不妨设圆点权值为$-1$，方点权值为其所代表的点双的大小。那么满足条件的点$c$数量为路径上的权值（路径上的圆点为割点，存在于多个点双上，正好抵消）。

所以答案为经过某个点的路径条数乘其权值的和。树形DP即可。

```cpp

#include <bits/stdc++.h>
using namespace std;

inline int gi()
{
	char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	int sum = 0;
	while('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

typedef long long ll;
const int maxn = 100005;

int n, m;

struct edge
{
	int to, next;
} e[maxn * 4];
int h[maxn], tot;

inline void add(int u, int v)
{
	e[++tot] = (edge) {v, h[u]}; h[u] = tot;
	e[++tot] = (edge) {u, h[v]}; h[v] = tot;
}

int dfn[maxn], low[maxn], Time, stk[maxn], top;

vector<int> to[maxn << 1];
int cnt, vis[maxn << 1], val[maxn << 1];
ll up[maxn << 1], down[maxn << 1], ans;

void tarjan(int u, int fa)
{
	dfn[u] = low[u] = ++Time;
	stk[++top] = u;
	for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
		if (!dfn[v]) {
			tarjan(v, u);
			low[u] = min(low[u], low[v]);
			
			if (dfn[u] == low[v]) {
				++cnt;
				while (stk[top + 1] != v)
					to[stk[top]].push_back(cnt), to[cnt].push_back(stk[top]), --top, ++val[cnt];
				to[u].push_back(cnt), to[cnt].push_back(u); ++val[cnt];
			}
		} else low[u] = min(low[u], dfn[v]);
}

void dfs1(int u, int fa)
{
	vis[u] = 1;
	if (u <= n) down[u] = 1;
	for (int v : to[u])
		if (v != fa) {
			dfs1(v, u);
			down[u] = down[u] + down[v];
		}
}

void dfs2(int u, int fa)
{
	vis[u] = 2;
	ll Ans = 0;
	if (u <= n) ans += val[u] * up[u], Ans = up[u], ++up[u]; 
	ll sum = up[u];
	for (int v : to[u])
		if (v != fa) {
			up[v] = up[u] + down[u] - down[v] - (u <= n);
			ans += sum * down[v] * val[u]; Ans += sum * down[v]; sum += down[v];
			dfs2(v, u);
		}
	//printf("%d %lld\n", u, Ans);
}

int main()
{
	n = gi(); m = gi();
	for (int i = 1; i <= m; ++i) add(gi(), gi());

	cnt = n;
	for (int i = 1; i <= n; ++i)
		if (!dfn[i]) tarjan(i, 0), --top;

	fill(val + 1, val + n + 1, -1);
	for (int i = 1; i <= n; ++i) if (!vis[i]) dfs1(i, 0);
	for (int i = 1; i <= n; ++i) if (vis[i] == 1) dfs2(i, 0);

	printf("%lld\n", ans * 2); 
	
	return 0;
}
```

---

## 作者：orz_z (赞：2)

# 圆方树的定义

圆方树是用来解决仙人掌图的问题的，那什么是仙人掌图呢？

即不存在边同时属于多个环的无向连通图是一棵仙人掌。

## 点双连通分量的定义
要介绍圆方树，首先要介绍点双连通分量。

一个点双连通图的一个定义是：图中任意两不同点之间都有至少两条点不重复的路径。

一种简单的定义：不存在割点的图。

但这种定义对于两点一边的图时是没用的，它没有割点，但是并不能找到两条不相交的路径，因为只有一条路径。（也可以理解为那一条路径可以算两次，但的确没有相交，因为不经过其他点）。

在点双连通图内，一个点可能属于多个点双，但是一条边属于恰好一个点双。

更多关于有向图的强连通分量的知识，请看我的博客 $\to$ [强连通分量](https://www.cnblogs.com/orzz/p/15104647.html)

更多关于点双连通分量的知识，请看我的博客 $\to$ [双连通分量](https://www.cnblogs.com/orzz/p/15114866.html)

## 继续介绍圆方树

关于圆方树的建图，也比较简单，将一个点双连通分量内的所有边删去，再将一个点双连通分量中的每个点向一个新建的点连边，这个新建的点即是方点。

所以在圆方树中有 $n+c$ 个点，其中 $n$ 是原图点数，$c$ 是原图点双连通分量的个数。

每个点双都可以形成一个菊花图，多个菊花图通过原图中的割点连接在一起（因为点双的分隔点是割点）。

显然，圆方树中每条边连接一个圆点和一个方点。

在下面这张图中，$[1,2,3,4,5]$ 是圆点，$[6,7]$ 是方点。

![](https://img-blog.csdnimg.cn/img_convert/a64ea1977df8894a39bf10c1ae9b80ab.png)

而如果圆方树连通，则有以下性质：

* 方点之间不会存在连边。

* 原图的割点就是圆方树中度数大于 $1$ 的圆点。

* 圆方数是一棵非常好的树，即点数等于边数加 $1$。
  
* 圆方树上任意一条路径上圆点方点间隔分布。

* 如果圆点的 $size$ 为 $1$，那么一个圆点子树的 $size$ 和就是它下面的所有点的数量。

* 对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双，即同一个点双中的两不同点 $u$，$v$ 之间一定存在一条简单路径经过给定的在同一个点双内的另一点 $w$。也就是说，考虑两圆点在圆方树上的路径，与路径上经过的方点相邻的圆点的集合，就等于原图中两点简单路径上的点集。

如果原图中某个连通分量只有一个点，则需要具体情况具体分析，我们在后续讨论中不考虑孤立点。

注意一条边连接两个点的在这里不算点双。

## 广义圆方树

普通圆方树只能解决仙人掌图上的问题，而广义圆方树则可以将所有无向图转化为圆方树处理。

广义圆方树性质：圆点方点相间，不存在两个‘’相同形状‘’的点相连。

与圆方树不同的是，广义圆方树需要把一条边连接两个点也看成一个点双，原本两个圆点有一条边相连，现在在中间插入一个方点间隔开就好了。

可以参照这张图

![](https://img-blog.csdnimg.cn/img_convert/51b720e058f7a5dc7dc77c9eb881274f.png)


# 圆方树的应用

[洛谷 P4630 [APIO2018] Duathlon 铁人两项](https://www.luogu.com.cn/problem/P4630)

### 题目大意
给定一张简单无向图，问有多少对三元组 $⟨s,c,f⟩$（$s$，$c$，$f$ 互不相同）使得存在一条简单路径从 $s$ 出发，经过 $c$ 到达 $t$。
### 解题思路
考虑怎么计算这种三元组，可以枚举 $s$ 和 $f$，然后计算从 $s$ 到 $f$ 的点不重复路径中可以经过的点的个数。

$s$ 到 $t$ 点不重复路径中可以经过的点必定在也只能在这条路径所经过的点双内。

所以可以考虑缩点双之后建出圆方树，然后就只需要在树上求出每一对 $(u,v)$ 之间经过的点双点数大小。

但是直接将点双大小加起来的话两个点双的公共点会算重，于是将公共点的权值（圆点）设为 $-1$，方点的权值设为点双的大小。

原因是路径中除端点外每个圆点（即割点）都会被相邻的两点双算两遍，而两端点虽然只被算一遍但本身并不能被统计，故每个点都需要减一。

那么问题又进一步转化成了求树上所有路径的权值和，显然只要分别计算每个点的贡献即可，就是一个简单的 `DP`。

于是这题便转化成了求树上所有的圆点对之间的路径权值和。

直接做是 $n^2$，

可以换个角度考虑，改为统计每一个点对答案的贡献，即权值乘以经过它的路径条数，这可以通过简单的树形 DP 求出。

### AC CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 100005;

int n, m, cnt;
vector<int> G[_], T[_ * 2];
long long Ans;

int dfn[_], low[_], cnt_node, num;

stack<int> s;

int wjy[_ * 2];

int vis[_ * 2], siz[_ * 2];

void Tarjan(int u)
{
  low[u] = dfn[u] = ++cnt_node;
  s.push(u);
  ++num;
  for (auto v : G[u])
  {
    if (!dfn[v])
    {
      Tarjan(v);
      low[u] = min(low[u], low[v]);
      if (low[v] == dfn[u])
      {
        wjy[++cnt] = 0;
        while (1)
        {
          int x = s.top();
          s.pop();
          T[cnt].push_back(x);
          T[x].push_back(cnt);
          ++wjy[cnt];
          if (x == v)
            break;
        }
        T[cnt].push_back(u);
        T[u].push_back(cnt);
        ++wjy[cnt];
      }
    }
    else
      low[u] = min(low[u], dfn[v]);
  }
}

void dfs(int u, int fz)
{
  vis[u] = 1;
  siz[u] = (u <= n);
  for (auto v : T[u])
    if (v != fz)
    {
      dfs(v, u);
      Ans += 2ll * wjy[u] * siz[u] * siz[v];
      siz[u] += siz[v];
    }
  Ans += 2ll * wjy[u] * siz[u] * (num - siz[u]);
}

int main()
{
  scanf("%d%d", &n, &m);
  cnt = n;
  for (int i = 1; i <= n; ++i)
    wjy[i] = -1;
  for (int i = 1; i <= m; ++i)
  {
    int u, v;
    scanf("%d%d", &u, &v);
    G[u].push_back(v);
    G[v].push_back(u);
  }
  for (int i = 1; i <= n; ++i)
    if (!dfn[i])
    {
      num = 0;
      Tarjan(i);
      dfs(i, 0);
    }
  printf("%lld\n", Ans);
  return 0;
}
```

---

## 作者：zhylj (赞：2)

[广告](http://zhylj.cc/index.php/archives/48/)

## 题目

给定一张 $n$ 个点 $m$ 条边的图，求有多少个有序点对 $(a,b,c)$，使得存在一条 $a\to b\to c$ 且不经过重复点的路径。

$1\le n\le 10^5$，$1\le m\le 2\times 10^5$.

## 分析

这是道不好好分析会分类死的题目。

考虑建出圆方树，则原题条件等价于：求有多少个有序点对 $(a,b,c)$，使得存在一条 $a\to b\to c$，且**不重复经过圆点，但可以重复经过方点**的路径。

于是不难想象，我们枚举中转点 $b$，我们可以把 $b$ 相连的所有点（显然都是方点）与其合并，然后以 $b$ 为中转点的方案数即为在任意两个不同的子树中取两个点 $a,c$ 的方案数。

然后可以考虑容斥，先求出不考虑在不同子树内的方案，再求出在同一子树内的方案，然后用前者减去后者。

$$
\sum_i\sum_{j\neq i}s_is_j = \left(\sum_i s_i\right)^2 - \sum_is_i^2
$$

于是我们只需要维护，以每个点为根时，所有子树大小的平方和（显然，所有子树大小的和为当前连通块大小 $-1$）。

这可以用简单的换根求出，时间复杂度为 $\mathcal O(n + m)$，然后这道题就做完了。

### 代码

```cpp
const int N = 5e5 + 5;

int n, m, b_cnt; ll ans;

int dfv, top, dfn[N], low[N], st[N], rt[N], siz[N];
std::vector <int> E[2][N];
void Add(int u, int v, int p) {
	E[p][u].push_back(v);
	E[p][v].push_back(u);
}
void Tarjan(int u, int r) {
	rt[u] = r;
	dfn[u] = low[u] = ++dfv;
	st[++top] = u;
	for(auto v : E[0][u]) {
		if(!dfn[v]) {
			Tarjan(v, r);
			low[u] = std::min(low[u], low[v]);
			if(low[v] == dfn[u]) {
				rt[++b_cnt] = r;
				for(int x = 0; x != v; --top) {
					Add(b_cnt, x = st[top], 1);
					++siz[b_cnt];
				}
				Add(b_cnt, u, 1);
				++siz[b_cnt];
			}
		} else low[u] = std::min(low[u], dfn[v]);
	}
}

int t_siz[N]; ll t_sq_s[N];
void Dfs(int u, int p) {
	if(u <= n) t_siz[u] = 1;
	for(auto v : E[1][u])
		if(v != p) {
			Dfs(v, u);
			t_siz[u] += t_siz[v];
			t_sq_s[u] += 1LL * t_siz[v] * t_siz[v];
		}
}
void Dfs2(int u, int p) {
	for(auto v : E[1][u])
		if(v != p) Dfs2(v, u);
	if(u <= n) {
		ll sq_s = 0;
		for(auto v : E[1][u])
			sq_s += t_sq_s[v];
		sq_s -= 1LL * t_siz[u] * t_siz[u];
		ll s_fa = t_siz[rt[u]] - t_siz[p];
		sq_s += s_fa * s_fa;
		ans += 1LL * (t_siz[rt[u]] - 1) * (t_siz[rt[u]] - 1) - sq_s;
	}
}

int main() {
	rd(n, m); b_cnt = n;
	for(int i = 1; i <= m; ++i) {
		int u, v; rd(u, v);
		Add(u, v, 0);
	}
	for(int i = 1; i <= n; ++i)
		if(!dfn[i]) {
			Tarjan(i, i);
			top = 0;
		}
	for(int i = 1; i <= n; ++i)
		if(rt[i] == i) Dfs(i, 0), Dfs2(i, 0);
	printf("%lld\n", ans);
	return 0;
}
```

---


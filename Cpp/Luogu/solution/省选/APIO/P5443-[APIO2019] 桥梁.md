# [APIO2019] 桥梁

## 题目背景

圣彼得堡市内所有水路长度总和约 $282$ 千米，市内水域面积占城市面积的 $7\%$。——来自维基百科

## 题目描述

圣彼得堡位于由 $m$ 座桥梁连接而成的 $n$ 个岛屿上。岛屿用 $1$ 到 $n$ 的整数编号，桥梁用 $1$ 到 $m$ 的整数编号。每座桥连接两个不同的岛屿。有些桥梁是在彼得大帝时代建造的，其中一些是近期建造的。这导致了不同的桥梁可能有不同的重量限制。更具体地，只有重量不超过 $d_i$ 的汽车才能通过第 $i$ 座桥梁。有时圣彼得堡的一些桥梁会进行翻新，但这并不一定会使桥梁承重变得更好，也就是说，进行翻新的桥梁的 $d_i$ 可能会增加或减少。你准备开发一个产品，用于帮助公民和城市客人。目前，你开发的模块要能执行两种类型的操作：

1. 将桥梁 $b_j$ 的重量限制改为 $r_j$。

2. 统计一辆重为 $w_j$ 的汽车从岛屿 $s_j$ 出发能够到达多少个不同的岛屿。

请你回答所有第二种操作的答案。



## 说明/提示

对于全部数据，$1 \leq n \leq 5\times 10^4$，$0 \leq m \leq 10^5$，$1 \leq q \leq 10^5$。保证 $1 \leq u_i$，$v_i$, $s_j \leq n$，$u_i \neq v_i$，$1 \leq d_i$, $r_j$, $w_j \leq 10^9$，$1 \leq b_j \leq m$，$t_j \in {1,2}$。

详细子任务附加限制与分值如下表 **（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

| 子任务 | 附加限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $n$, $m\leq 10^3$，$q\leq 10^4$ | 13 |
| 2 | 岛屿和桥梁将形成一个树结构；$m=n-1$，$u_i=i$，$v_i=i+1$；（$1\leq i\leq m$） | 16 |
| 3 | 岛屿和桥梁将形成一个完全二叉树结构；$n=2^k-1$，$m=n-1$，$u_i=\frac{i+1}{2}$，$v_i=i+1$；（$1\leq k\leq 15$，$1\leq i\leq m$） | 17 |
| 4 | 所有 $t_i$ 均为 $2$ | 14 |
| 5 | 岛屿和桥梁将形成一个树结构 | 13 |
| 6 | 无特殊限制 | 27 |

## 样例 #1

### 输入

```
3 4
1 2 5
2 3 2
3 1 4
2 3 8
5
2 1 5
1 4 1
2 2 5
1 1 1
2 3 2```

### 输出

```
3
2
3```

## 样例 #2

### 输入

```
7 8
1 2 5
1 6 5
2 3 5
2 7 5
3 4 5
4 5 5
5 6 5
6 7 5
12
2 1 6
1 1 1
2 1 2
1 2 3
2 2 2
1 5 2
1 3 1
2 2 4
2 4 2
1 8 1
2 1 1
2 1 3```

### 输出

```
1
7
7
5
7
7
4```

# 题解

## 作者：mrsrz (赞：39)

操作分块+可撤销并查集。

我们将操作进行分块，对每块的询问进行处理。设块大小为$S$。

对当前块之前的修改可以直接修改掉。

对每个块，都有一部分边会被修改，这些边的个数不超过$S$。而剩下的边不会被修改。询问的个数也不会超过$S$。

将询问按照重量从大到小排序，边也按重量限制从大到小排序。枚举询问，把满足重量限制的不会被修改的边加入即可。用并查集维护。

考虑会被修改的边产生的影响。由于这些边的个数并不多，我们对每个询问，把符合条件的边暴力插入即可。处理完这个询问，再把这些边暴力删掉即可。

需要用到可撤销并查集。

每个块处理的复杂度为$O(m\log m+S^2\log n)$。

根据实际情况取块大小即可。理论复杂度$O(q\sqrt q\log m)$。

可以把$O(m\log m)$的排序用归并优化掉$\log$。则理论复杂度可以做到$O(q\sqrt{q\log m})$。

~~看起来log放根号外面也挺快的啊~~

## Code：
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int N=1e5+7,siz=1024;
int n,m;
struct edge{
	int u,v,w,id;
	inline int operator<(const edge&rhs)const{return w>rhs.w;}
}e[N];
inline int cmp(const edge&a,const edge&b){return a.id<b.id;}
int ans[N];
struct f_t{
	int bc,id,tim;
	inline int operator<(const f_t&rhs)const{return bc>rhs.bc;}
};
vector<f_t>M,Q;
int q;
int fa[N],sz[N],sta[N],top,vis[N],ys[N];
inline int find(int x){return x==fa[x]?x:find(fa[x]);}
inline void merge(int u,int v){
	u=find(u),v=find(v);
	if(u==v)return;
	if(sz[u]<sz[v])swap(u,v);
	sta[++top]=v;
	sz[u]+=sz[v],fa[v]=u;
}
void back(int lst){
	while(top>lst){
		int v=sta[top--];
		sz[fa[v]]-=sz[v];
		fa[v]=v;
	}
}
void solve(){
	sort(e+1,e+m+1);
	sort(Q.begin(),Q.end());
	for(int i=1;i<=m;++i)ys[e[i].id]=i;
	static vector<f_t>MM;MM.clear();
	for(f_t i:M)vis[i.id]=-1,MM.push_back((f_t){e[ys[i.id]].w,i.id,0});
	for(f_t i:M)MM.push_back(i);
	for(int i=1;i<=n;++i)fa[i]=i,sz[i]=1;
	top=0;
	for(int i=0,it=1;i<Q.size();++i){
		while(it<=m&&e[it].w>=Q[i].bc){
			if(!vis[e[it].id])merge(e[it].u,e[it].v);
			++it;
		}
		int last=top;
		for(f_t a:MM)
		if(a.tim<=Q[i].tim)vis[a.id]=a.bc;
		for(f_t a:M)
		if(vis[a.id]>=Q[i].bc)merge(e[ys[a.id]].u,e[ys[a.id]].v);
		ans[Q[i].tim]=sz[find(Q[i].id)];
		back(last);
	}
	for(f_t i:M)e[ys[i.id]].w=i.bc,vis[i.id]=0;
	M.clear(),Q.clear();
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;++i)cin>>e[i].u>>e[i].v>>e[e[i].id=i].w;
	cin>>q;
	for(int t=1;t<=q;++t){
		int op;f_t x;
		cin>>op>>x.id>>x.bc;
		x.tim=t;
		if(op==1)M.push_back(x);else Q.push_back(x);
		if(t%siz==0)solve();
	}
	if(q%siz)solve();
	for(int i=1;i<=q;++i)if(ans[i])cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Fading (赞：32)

感谢 @soar_unprecedentedly 指出的一处错误以及提供的更优解~

### 算法$1$： 

考虑最暴力的暴力：

对于每一个修改，直接修改这个边。 

对于每一个询问，枚举所有边。 

如果这个边的重量限制大于等于当前询问的重量，那么加入并查集。

最后看询问点所在的并查集的大小就好了。 

复杂度$O(Qm\alpha)$

期望得分：$13$分。 

### 算法$2$：

我们考虑对所有边，所有的询问排序（根据重量从大到小）。

有趣的是，如果没有修改操作的话，我们可以通过离线把边加入并查集的方法完美解决这个问题。

这个方法很简单，此处不再赘述。

如果有修改怎么办呢？ 

我们分两类边讨论：有修改的边，和无修改的边。 

有些边是永远没有修改的，可以在离线的时候直接加入并查集。

对于有修改的边，我们如何处理？

可以暴力枚举。我们枚举所有修改操作，看看操作时间是否大于当前询问时间。

如果大于，不做处理。否则修改这些边。

最后根据重量大小把这些有修改的边加入并查集。

最后撤销一下加入并查集的有修改的边即可。 

时间复杂度$O(Q\log_2Q+m\log_2m+Q(Q+Q\log_2n))$

期望得分：$13$分。 

### 算法$3$：

算法$1$和算法$2$的瓶颈很显然：一个枚举了所有的边，一个枚举了所有的操作。

两个算法也各有优劣：

算法$1$在边很少的情况下非常快，直接把边改了。 

算法$2$在询问很少的情况下非常快，而且离线了，只需要考虑修改过的边。

所以我们考虑均摊一下两个做法。

怎么均摊？

考虑分块。 

对于所有询问分块。$S$个询问为$1$块。

如何对询问块进行处理？ 

先对第$1$个块内的所有询问操作,所有边按照重量排序（从大到小）。

然后我们直接照搬算法$2$的流程，离线，枚举每一个询问。 

对于这$S$个操作无修改的边，直接加入并查集。

对于这$S$个操作内有修改的边，枚举所有这$S$个操作的所有修改操作。根据时间判断这些边的重量。

然后加入并查集，得到答案，再撤回，进行下一个询问。

最后我们像算法$1$一样，处理完这个块后，执行这个块的所有修改操作，直接把边权改了。

然后进行第$2$个块的操作，做完再搞第$3$个块...以此类推。 

我们发现复杂度变得很有意思，因为一个块内最多只有$S$个修改操作。 

时间复杂度为$O(\frac QS m\log_2m+\frac QS S^2\log_2n)$

即$O(QS\log_2n+\frac {Qm\log_2m}{S})$

时间复杂度懒得算了，特别奇怪，好像$S$取$\sqrt{m\log_2n}$跑的飞快，因为并查集常数是跑不满$\log_2n$的。

期望得分：100分。 

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
struct edge{
    int from,to,dis,id;
}g[120001],g1[120001],g2[120001];
int tot;
inline void made(int from,int to,int dis,int id){
    g[++tot].from=from;g[tot].to=to;g[tot].dis=dis;g[tot].id=id;
}
inline bool cmp(edge a,edge b){
    return a.dis>b.dis;
}
inline bool cmpid(edge a,edge b){
    return a.id<b.id;
}
struct que{
    int opt,id,W,num;
}q[120001],cac1[120001],cac2[120001];
inline bool cmp0(que a,que b){
    return a.W>b.W;
}
int n,m,S,ans[120001],Id[120001],sz[120001],F[120001];
int find(int u){
    if (F[u]!=u) return find(F[u]);
    else return u;
}
int sta[120001][2],top;
inline void merge(int u,int v){
    int fu=find(u),fv=find(v);
    if (fu==fv) return;
    if (sz[fu]<sz[fv]) swap(fu,fv);
    F[fv]=fu;sz[fu]+=sz[fv];
    sta[++top][0]=fu;sta[top][1]=fv;
}
inline void cancel(){
    ll u=sta[top][0],v=sta[top--][1];
    sz[u]-=sz[v];F[v]=v;
}
int cnt1,cnt2,D[120001];
bool vis[120001];
int all,dl[120001],Op[120001];
inline void work(int sum){
    cnt1=all=top=cnt2=0;
    for (int i=1;i<=m;i++) vis[i]=0,D[i]=0,Id[g[i].id]=i;
    for (int i=1;i<=sum;i++){
        if (q[i].opt==1){
            cac1[++cnt1]=q[i];
            if (vis[Id[q[i].num]]) continue;
            D[Id[q[i].num]]=g[Id[q[i].num]].dis;
            vis[Id[q[i].num]]=1;
            dl[++all]=Id[q[i].num];
        }else{
            cac2[++cnt2]=q[i];
        }
    }
    for (int i=1;i<=n;i++) F[i]=i,sz[i]=1;
    sort(cac2+1,cac2+1+cnt2,cmp0);
    int pos=1;
    for (int i=1;i<=cnt2;i++){
        while (pos<=m&&g[pos].dis>=cac2[i].W){
            if (!vis[pos]) merge(g[pos].from,g[pos].to);
            pos++;
        }
        ll las=top;
        for (int j=1;j<=cnt1;j++){
            if (cac1[j].id<cac2[i].id){
                D[Id[cac1[j].num]]=cac1[j].W;
            }
        }
        for (int j=1;j<=all;j++){
            if (D[dl[j]]>=cac2[i].W){
                merge(g[dl[j]].from,g[dl[j]].to);
            }
            D[dl[j]]=g[dl[j]].dis;
        }
        ans[cac2[i].id]=sz[find(cac2[i].num)];
        for (;las!=top;) cancel();
    }
    ll tot1=0,tot2=0;
    for (int i=1;i<=sum;i++){
        if (q[i].opt==1) g[Id[q[i].num]].dis=q[i].W; 
    }
    for (int i=1;i<=m;i++){
        if (vis[i]) g1[++tot1]=g[i];
        else g[++tot2]=g[i]; 
    }
    sort(g1+1,g1+1+tot1,cmp);
    merge(g+1,g+1+tot2,g1+1,g1+1+tot1,g2+1,cmp); 
    for (int i=1;i<=m;i++) g[i]=g2[i];
}
signed main(){
    n=read(),m=read();
    S=sqrt(m*log2(n));
    for (int i=1;i<=m;i++){
    	int x=read(),y=read(),z=read();
    	made(x,y,z,i);
    }
    int Q=read();
    sort(g+1,g+1+m,cmp);
    int cnt=0;
    for (int i=1;i<=Q;i++){
    	q[++cnt].id=i;
    	int op=read();q[cnt].opt=op;
    	Op[i]=op;
    	if (op==1){
    		q[cnt].num=read(),q[cnt].W=read();
        }else{
    		q[cnt].num=read(),q[cnt].W=read();
        }
        if (cnt==S) work(S),cnt=0;
    }
    if (cnt) work(cnt);
    for (int i=1;i<=Q;i++){
        if (Op[i]==2) printf("%d\n",ans[i]);
    }
    return 0;
}


```

算法$4$：

感谢 @soar_unprecedentedly 提供做法~

$\log$在外面跑不快，怎么把并查集的复杂度去掉呢？

发现一次最多加入$S$条边，那么我们可以去掉带撤销并查集，每一次加入边暴力 dfs 即可。

时间复杂度为$O(\frac QS m\log_2m+\frac QS S^2\alpha)$

即$O(QS\alpha+\frac {Qm\log_2m}{S})$。

$S$取$\sqrt{m\log_2m}$跑的飞快，直接最优解了。

代码就不贴了。




---

## 作者：Sai0511 (赞：10)

APIO场外选手没事休闲做题。（看了yyb的题解才把这题做出来）          
对操作进行分块，把每$\text{SZ}$个操作分成1组，里面大概有2类：**没被修改过的和被修改过的。**   
接着对块内询问进行离线。    
对于没有修改过的：我们可以直接排序然后把他们加入并查集。     
对于修改过的，我们看他的时间是否大于当前操作的时间，如果大于则加入原来的权值，如果小于则用修改后的权值。  
最后答案其实就是查一下连通块的大小。    
再注意一点，因为这里的并查集是支持撤回的，所以并不能路径压缩。     
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>

const int maxm = 1e5 + 10;

inline void _swap(int& a,int& b) { a ^= b ^= a ^= b; }
template<class T> inline void read(T& res) {
    res = 0;  char ch = getchar();  bool neg = 0;
    while(!isdigit(ch))
        neg |= ch == '-', ch = getchar();
    while(isdigit(ch))
        res = (res << 1) + (res << 3) + (ch & 15), ch = getchar();
    if(neg)
        res = -res; 
}

int n, m, i, j, k, tote, totq, top, lastop, SZ;  
int fa[maxm], sz[maxm], id[maxm], ans[maxm], r[maxm];  
std::pair<int,int> sta[maxm];  

int find(int u) { return u == fa[u] ? u : find(fa[u]); }
inline void Union(int u,int v) {
    int ru = find(u), rv = find(v);
    if(ru == rv)
        return;
    if(sz[ru] < sz[rv])
        _swap(ru,rv);
    fa[rv] = ru;  sz[ru] += sz[rv];
    sta[++top] = std::make_pair(ru,rv);  
}

bool vis[maxm];  
struct edge {
    int u, v, w, id;  
    edge() { u = v = w = id = 0; }
    edge(int _u,int _v,int _w,int _id) {
        u = _u;  v = _v;  w = _w;  id = _id;
    }
    inline friend bool operator < (edge a,edge b) {
        if(a.w != b.w)
            return a.w > b.w;
        else
            return a.id < b.id;    
    }
} e[maxm], e1[maxm], e2[maxm];
struct node {
    int id, t, b, r;  
    node() { id = t = b = r = 0; }
    node(int _id,int _t,int _b,int _r) {
        id = _id;  t = _t;  b = _b;  r = _r;
    }  
    inline friend bool operator < (node a,node b) {
        return a.b > b.b;  
    }
} Q[maxm], x[maxm], y[maxm];  

inline void solve() {
    memset(vis,0,sizeof(vis));  top = lastop = 0;
    for(int i = 1;i <= n;i++)
        fa[i] = i, sz[i] = 1;
    int tot1 = 0, tot2 = 0;
    for(int i = 1;i <= totq;i++) {
        if(Q[i].t == 1)
            vis[ Q[i].b ] = 1, x[++tot1] = Q[i];
        else
            y[++tot2] = Q[i];
    }
    std::sort(y + 1,y + tot2 + 1);
    for(int i = 1;i <= m;i++)
        id[ e[i].id ] = i;
    int j = 1;
    for(int i = 1;i <= tot2;i++) {
        while(j <= m && e[j].w >= y[i].b) {
            if(!vis[ e[j].id ])
                Union(e[j].u,e[j].v);
            j++;
        }
        lastop = top;
        for(int j = 1;j <= tot1;j++)
            r[ x[j].b ] = e[ id[ x[j].b ] ].w;
        for(int j = 1;j <= tot1;j++)
            if(x[j].id < y[i].id)
                r[ x[j].b ] = x[j].r;  
        for(int j = 1;j <= tot1;j++)
            if(r[ x[j].b ] >= y[i].b)
                Union(e[ id[ x[j].b ] ].u,e[ id[ x[j].b ] ].v);
        ans[ y[i].id ] = sz[ find(y[i].r) ];
        while(top > lastop) {
            int u = sta[top].first, v = sta[top].second;
            top--;
            fa[v] = v;
            sz[u] -= sz[v];  
        }
    }
    for(int i = 1;i <= tot1;i++)
        e[ id[ x[i].b ] ].w = x[i].r; 
    tot1 = tot2 = 0;
    for(int i = 1;i <= m;i++) {
        if(vis[ e[i].id ])
            e1[++tot1] = e[i];
        else
            e[++tot2] = e[i];
    }
    std::sort(&e1[1],&e1[tot1 + 1]);
    std::merge(&e[1],&e[tot2 + 1],&e1[1],&e1[tot1 + 1],&e2[1]);
    for(int i = 1;i <= m;i++)
        e[i] = e2[i];  
}

int main() {
    SZ = 500;   
    read(n);  read(m);
    for(int i = 1, u, v, w;i <= m;i++)
        read(u), read(v), read(w), e[i] = edge(u,v,w,i);   
    std::sort(&e[1],&e[m + 1]);  
    int q;  read(q);
    for(int i = 1, op, x, y;i <= q;i++) {
        read(op);  read(x);  read(y);
        if(op == 2)
            _swap(x,y);
        Q[++totq] = node(i,op,x,y);  
        if(totq == SZ)
            solve(), totq = 0;   
    } 
    if(totq)
        solve();
    for(int i = 1;i <= q;i++)
        if(ans[i])
            printf("%d\n",ans[i]);
    return 0;  
}
```


---

## 作者：FZzzz (赞：9)

这不是跟 P3247 是同一个题吗……做了那题应该就会这题了吧。

如果只有一个询问的话我们可以暴搜一遍，或者把所有权值大于他的边都丢到并查集里，然后看这个点所在连通块的大小。

带上修改的话，一个修改能影响到的是时间在他之后，这个边的下一个修改之前，并且权值小于等于他的所有询问。我们可以把线段树分治丢到 kdt 上跑 kdt 分治。

时间复杂度 $O(m\sqrt m\log m)$（认为 $m$ 与 $q$ 同阶，$\log m$ 与 $\log n$ 同阶），空间复杂度 $O(m\sqrt m)$。

然而我不会 kdt。这个做法我没写过不知道能不能过。

我们可以考虑时间轴分块，对于一个块内的每个询问，我们可以先加入没有被修改过的边，再加被修改过的边。把所有不会在这个块中被修改的边拿出来按权值排序，把询问也拿出来按权值排序，对于这两个归并一下，然后处理每个询问时暴力加入所有在这个块内会被修改的边，并回退。

这样的话复杂度是 $O(\dfrac{m^2\log m}s+ms\log m))$，取块长 $s=\sqrt m$ 得到一个 $O(m\sqrt m\log m)$ 算法，如果你常数跟我一样大那肯定过不了。

优化一：上一个块和这一个块都没有被修改过的边在上一个块一定已经被排好序了，所以我们只需要对上一个块修改过但这个块不会被修改的边排序，然后对这两个数组归并。这样的话复杂度其实没有改变，因为可回退并查集的时间开销也是 $\dfrac{m^2\log m}s$，但是这样可以优化掉很大常数。另外，如果取 $s=\sqrt{m\log m}$，复杂度为 $O(m\sqrt{m\log m}\log m)$，但实际表现非常优秀，可能是因为暴力加入被修改过的边时常数远远跑不满。

优化二：并查集使用路径压缩按秩合并，然后处理被修改过的边时，可以在并查集缩点的基础上加边，然后暴搜即可。这样复杂度应该是 $O(\dfrac{m^2\log m}s+ms)$，大力解得 $s=\sqrt{m\log m}$ 时最优，复杂度 $O(m\sqrt{m\log m})$。

优化三：就是把前两个优化一起上，最后复杂度为 $O(\dfrac{m^2\alpha(m)}s+ms)$，解得 $s=\sqrt{m\alpha(m)}$ 时最优复杂度为 $m\sqrt{m\alpha(m)}$，基本可以看作一个根号。

后两个优化我没有进行实现，不知道具体的效率怎么样。

下面是优化一的代码，我觉得非常漂亮。但在洛谷上无法通过，在 loj 上可以通过。如果块长取 $\sqrt{m\log m}$ 则在洛谷和 loj 都可以通过。
```cpp
#include<algorithm>
#include<vector>
#include<cmath>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=5e4+5,maxm=1e5+5,maxs=350;
int n,m,q,u[maxm],v[maxm],d[maxm],t[maxs],b[maxs],r[maxs];
bool vis[maxm];
bool cmp1(int x,int y){
	return d[x]>d[y];
}
int ans[maxs];
bool cmp2(int x,int y){
	return r[x]>r[y];
}
int fa[maxn],size[maxn];
int findrt(int x){
	return fa[x]==x?x:findrt(fa[x]);
}
int d2[maxm];
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	m=readint();
	for(int i=1;i<=m;i++){
		u[i]=readint();
		v[i]=readint();
		d[i]=readint();
	}
	q=readint();
	int s=sqrt(q);
	vector<int> e1,e2;
	for(int i=1;i<=m;i++) e1.push_back(i);
	sort(e1.begin(),e1.end(),cmp1);
	for(int i=0;i<(q-1)/s+1;i++){
		int len=i==(q-1)/s?q-i*s:s;
		for(int j=0;j<len;j++){
			t[j]=readint();
			b[j]=readint();
			r[j]=readint();
		}
		for(int j=0;j<len;j++) if(t[j]==1) vis[b[j]]=1;
		vector<int> e11,e12;
		for(int j=0;j<(int)e1.size();j++) if(!vis[e1[j]]) e11.push_back(e1[j]);
		for(int j=0;j<(int)e2.size();j++) if(!vis[e2[j]]) e12.push_back(e2[j]);
		sort(e12.begin(),e12.end(),cmp1);
		e1.clear();
		int cur=0;
		for(int j=0;j<(int)e12.size();j++){
			while(cur<(int)e11.size()&&d[e11[cur]]>d[e12[j]]) e1.push_back(e11[cur++]);
			e1.push_back(e12[j]);
		}
		for(int j=cur;j<(int)e11.size();j++) e1.push_back(e11[j]);
		e2.clear();
		for(int j=1;j<=m;j++) if(vis[j]) e2.push_back(j);
		vector<int> q2;
		for(int j=0;j<len;j++) if(t[j]==2) q2.push_back(j);
		sort(q2.begin(),q2.end(),cmp2);
		for(int j=1;j<=n;j++){
			fa[j]=j;
			size[j]=1;
		}
		cur=0;
		for(int j=0;j<(int)q2.size();j++){
			while(cur<(int)e1.size()&&d[e1[cur]]>=r[q2[j]]){
				int x=findrt(u[e1[cur]]),y=findrt(v[e1[cur]]);
				cur++;
				if(x==y) continue;
				if(size[x]>size[y]) swap(x,y);
				fa[x]=y;
				size[y]+=size[x];
			}
			for(int k=0;k<(int)e2.size();k++) d2[e2[k]]=d[e2[k]];
			for(int k=0;k<q2[j];k++) if(t[k]==1) d2[b[k]]=r[k];
			vector<int> res;
			for(int k=0;k<(int)e2.size();k++) if(d2[e2[k]]>=r[q2[j]]){
				int x=findrt(u[e2[k]]),y=findrt(v[e2[k]]);
				if(x==y) continue;
				if(size[x]>size[y]) swap(x,y);
				fa[x]=y;
				size[y]+=size[x];
				res.push_back(x);
			}
			ans[q2[j]]=size[findrt(b[q2[j]])];
			for(int k=(int)res.size()-1;k>=0;k--){
				int x=res[k];
				size[fa[x]]-=size[x];
				fa[x]=x;
			}
		}
		for(int j=0;j<len;j++) if(t[j]==2) printf("%d\n",ans[j]);
		for(int j=0;j<len;j++) if(t[j]==1) vis[b[j]]=0;
		for(int j=0;j<len;j++) if(t[j]==1) d[b[j]]=r[j];
	}
	return 0;
}
```

---

## 作者：MuYC (赞：3)

考虑假如没有修改怎么做。

显然没有修改的话这是一个水题。我们可以用 $Kruscal$ 重构树或者把所有询问离线下来然后按照询问的权值排序动态加边输出并查集大小即可。

但是带了修改后，考虑对于操作分块。假设我们把 $B$ 个操作当成一个块来处理，也就是每 $B$ 个操作我们处理一次询问。

然后我们一共要处理 $\frac{q}{B}$ 次。

每次处理这些操作的时候，因为被改变的边的数量肯定不超过 $B$ 条（因为一共才 $B$ 个操作），然后我们把这些被操作到的边拿下来。再把没有修改到的边按照承重能力从小到大排序一下，这 $B$ 个操作里面的询问我们也离线下来按照车辆重量进行从小到大排序。

对于没有被修改到的边我们就按照没有修改的方法做。对于被修改到的边我们就判断有多少条边会影响某一次的询问（需要每个询问前面的操作有哪些，可以用时间戳的方法实现），然后加入后为了不影响到下一次询问，我们获得当前询问的答案后要将这个询问的加入的边撤销（需要用到可持久化并查集）。

答案就是所在并查集的集合大小。

时间复杂度： $O(\frac{q}{B} \times m \log m + Bq \log q)$

用均值不等式求的最佳块长是 $\sqrt {m \log m}$。（$mq$ 同阶看作相同）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MP(a,b) make_pair(a,b)
inline int read() {
	int x = 0, flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
	for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}
const int MAXN = 1e5 + 50, block = 1400;
int n, m, q, tack[MAXN][2];
int Change[MAXN][2], lst[MAXN], nc = 0, nq = 0, Ans[MAXN], book[MAXN], LS[MAXN];
struct Edge {
	int from, to, w;
} edge[MAXN], tmp[MAXN];
struct Ques {
	int s, w, id, tim;
} Q[MAXN];
bool cmp(Edge a, Edge b) { return a.w > b.w; }
bool cmp2(Ques a, Ques b) { return a.w > b.w; }
namespace DSU { // 可撤销并查集
	int f[MAXN], top, siz[MAXN];
    pair <int, int> tack[MAXN];
    void reset() { for(int i = 1 ; i <= n ; i ++) f[i] = i, siz[i] = 1; top = 0; }
    int find(int x) { return f[x] == x ? x : find(f[x]); }
    int merge(int x, int y) {
        int fax = find(x), fay = find(y);
        if(fax == fay) return 0;
        if(siz[fax] > siz[fay]) swap(fax, fay);
        f[fax] = fay, siz[fay] += siz[fax];
        tack[++ top] = MP(fax, fay);
        return siz[fay];
    }
    void Cancle() { 
        pair <int, int> D = tack[top --];
        f[D.first] = D.first;
        siz[D.second] = siz[D.second] - siz[D.first];
        return ;
    }
} ;
void GetAns() {
	int h = 0, now = 0; DSU::top = 0;
	for(int i = 1 ; i <= n ; i ++) DSU::f[i] = i, DSU::siz[i] = 1;
	for(int j = 1 ; j <= m ; j ++) if(book[j] != 1) tmp[++ h] = edge[j];
	sort(tmp + 1, tmp + 1 + h, cmp);
	sort(Q + 1, Q + 1 + nq, cmp2);
	for(int i = 1 ; i <= nq ; i ++) {
		int qw = Q[i].w;
		while(tmp[now + 1].w >= qw) now ++, DSU::merge(tmp[now].from, tmp[now].to); // 没有修改到的就直接扫
		int tp = DSU::top;
		for(int j = Q[i].tim ; j >= 1 ; j --) { // 一个细节，要反正做，要以最后一次修改为准！
			int id = Change[j][0], w = Change[j][1];
			if(LS[id]) continue;
			LS[id] = 1;
			if(w >= qw) DSU::merge(edge[id].from, edge[id].to);
		}
		for(int j = Q[i].tim + 1; j <= nc; j ++) { // 这个是因为虽然有些边在整个块里面被修改了，但是在这个询问之前没有被修改
			int id = Change[j][0];
			if(LS[id]) continue;
			if(edge[id].w >= qw) DSU::merge(edge[id].from, edge[id].to);
		}
		for(int j = 1 ; j <= Q[i].tim ; j ++) {// 这里是在复原
			int id = Change[j][0], w = Change[j][1];
			LS[id] = 0;
		}
		Ans[Q[i].id] = DSU::siz[DSU::find(Q[i].s)]; // 求答案
		while(DSU::top > tp) DSU::Cancle(); // 撤销
	}
	for(int j = 1 ; j <= nc ; j ++) book[Change[j][0]] = 0; // 记得复原
	for(int j = 1 ; j <= nc ; j ++) edge[Change[j][0]].w = Change[j][1]; // 记得要修改掉边权哦
	for(int i = 1 ; i <= nq ; i ++) printf("%d\n", Ans[i]);
	nq = 0, nc = 0;
	return ;
}

int main() {
    //freopen("Bridge.in", "r", stdin);
    //freopen("Bridge.out", "w", stdout);
	n = read(), m = read();
	for(int i = 1 ; i <= m ; i ++) {
		int u = read(), v = read(), w = read();
		edge[i] = (Edge){ u, v, w };
	} int q = read();
	for(int v = 1 ; v <= q ; v ++) {
		int op = read(), a = read(), b = read();
		if(op == 1) Change[++ nc][0] = a, book[a] = 1, Change[nc][1] = b;
		else Q[++ nq].s = a, Q[nq].w = b, Q[nq].id = nq, Q[nq].tim = nc;
		if(v % block == 0) GetAns();
	} if(nq) GetAns();
	return 0;
}
```

---

## 作者：chenxia25 (赞：3)

> ### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P5443)

>题意见洛谷。

（以下认为所有 $\log$ 同阶，用 $\log n$ 表示）

首先在我认知范围内似乎稍微复杂一点的图上询问题都没有 polylog 做法。先来考虑暴力。

先上一个**都会的暴力：修改就直接改，查询就把所有符合条件的边连起来建出一张图跑 DFS。$\mathrm O(qm)$。

再考虑一个稍微经过大脑的想法。假如问题是静态的话，我们可以将所有边和所有询问排个序，使得在之前有的边之后一定有，这样就可以 two-pointers 地递推建图了，并查集维护连通性即可。但是有修改怎么办呢？依然排序，只将永远不会被修改的边排序按上述方法加，有修改的边的话就把修改它的操作有序地存下来，每次查询就二分查找出每条有修改的边最后一次修改并符合条件就加入并查集，得出答案后撤销。时间复杂度 $\mathrm O\!\left(m\log n+q^2\log n\right)$。

事实上这两种暴力并不能视作并列。不难发现，暴力一单次操作复杂度仅与 $m$ 相关，暴力二单次操作复杂度仅与 $q$ 相关，但是暴力二还有一个单独的 $m$，而且这个 $m$ 和暴力一里的 $m$ 是做的同样的工作：往图里加边。如果把暴力一的 DFS 也看成并查集的话，完全可以这样理解：暴力二是一些连续的操作离线下来排序，可以将所有操作分成若干段抱团取暖，暴力二本质上是 $1$ 段，而暴力一是 $q$ 段。

显然这两种分段方式都太极端了。不妨强行令每段大小相等，这样就有了分块的想法：每段 $sz1$ 个操作，共 $\mathrm O\!\left(\dfrac q{sz1}\right)$ 段。这样总时间复杂度显然是 $\mathrm O\!\left(\dfrac q{sz1}(m\log n+sz1^2\log n)\right)=\mathrm O\!\left(\dfrac{qm\log n}{sz1}+q\cdot sz1\log n\right)$ 。根据均值不等式，$sz1=\sqrt m$ 时时间复杂度为最优为 $\mathrm O(q\sqrt m\log n)$，如果你常数跟我一样大就别想了老老实实优化吧，如果你常数跟 fz 一样小可以考虑卡过去。

考虑优化。接下来分析复杂度的时候不考虑线性和线性乘以 $\log$ 的操作，因为它们对复杂度的影响实在是微乎其微。把剩下来的操作都拎出来整理一遍。

1. 将没有修改的边排序：每块都要排一遍，$\mathrm O\!\left(\dfrac{qm\log n}{sz1}\right)$；
1. 将没有修改的边加入可撤销并查集：每块都要加一遍，$\mathrm O\!\left(\dfrac{qm\log n}{sz1}\right)$；
1. 将有修改的边加入可撤销并查集：$\mathrm O\!\left(q\cdot sz1\log n\right)$。

考虑操作 $1$。注意到这一块和上一块都没有修改的边一定是排好序的了，我们只需要将上一块有修改这一块没有修改的边拎出来排序然后和之前那个归并一下即可。而第二类那种边单块只能有 $\mathrm O(sz1)$ 条，总共就是 $\mathrm O(q)$ 条。于是操作 $1$ 的 $\log$ 没了。然鹅复杂度没有变，因为下面有个复杂度一样的操作（悲）

考虑操作 $2$。显然这一部分是永远不会被撤销的，于是这一部分改到普通并查集模式，路径压缩 + 启发式合并可以变 $\log$ 为 $\alpha$。至此总复杂度降到了 $\mathrm O\!\left(q\sqrt{m\alpha(n)\log n}\right)$。~~（还是很大）~~

考虑操作 $3$。可以并查集缩点，然后暴力连边跑DFS。这样复杂度显然是少了一个 $\log$ 了的。至此，令 $sz1=\sqrt{m\alpha(n)}$ 即可拥有 $\mathrm O\!\left(q\sqrt{m\alpha(n)}\right)$ 的总复杂度。

可把我给卡常卡死了。人傻常数大就是指我吧。邻接表需要用链式前向星。

下面贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define X first
#define Y second
#define pb push_back
const int N=50000,M=100000,QU=100000;
int n,m,qu;
int a[M+1],b[M+1],w[M+1];
struct query{int tp,x,y;}qry[QU+1];
int ans[QU+1];
vector<int> chged,unchged;
int las_unchged[M+1];
vector<int> chgid[M+1];
vector<int> ask;
bool cmp(int x,int y){return qry[x].y>qry[y].y;}
bool cmp0(int x,int y){return w[x]>w[y];}
struct ufset{
	int fa[N+1],sz[N+1];
	void init(){
		for(int i=1;i<=n;i++)fa[i]=0,sz[i]=1;
	}
	int root(int x){return fa[x]?fa[x]=root(fa[x]):x;}
	void mrg(int x,int y){
		x=root(x),y=root(y);
		if(x==y)return;
		if(sz[x]>sz[y])swap(x,y);
		fa[x]=y,sz[y]+=sz[x];
	}
	int _sz(int x){return sz[x];}
}ufs;
struct addedge{
	int sz,head[N+1],nxt[2*M+1],val[2*M+1];
	void init(){sz=0;}
	void ae(int x,int y){
		val[++sz]=y;nxt[sz]=head[x];head[x]=sz;
	}
}nei;
vector<int> cc;
bool vis[N+1];
int dfs(int x){
	vis[x]=true;
	cc.pb(x);
	int res=ufs._sz(x);
	for(int i=nei.head[x];i;i=nei.nxt[i]){
		int y=nei.val[i];
		if(vis[y])continue;
		res+=dfs(y);
	}
	return res;
}
int main(){
//	freopen("C:\\Users\\chenx\\OneDrive\\桌面\\06.in","r",stdin);
	cin>>n>>m;
	for(int i=1;i<=m;i++)scanf("%d%d%d",a+i,b+i,w+i);
	cin>>qu;
	for(int i=1;i<=qu;i++)scanf("%d%d%d",&qry[i].tp,&qry[i].x,&qry[i].y);
	int sz1=sqrt((m+1)*4);
	for(int i=1,ie;i<=qu;i=ie+1){
		ie=min(qu,i+sz1-1);
		memset(las_unchged,0,sizeof(las_unchged));
		for(int j=0;j<unchged.size();j++)las_unchged[unchged[j]]=1;
		chged.clear();ask.clear();
		for(int j=1;j<=m;j++)chgid[j].clear();
		for(int j=i;j<=ie;j++)
			if(qry[j].tp==1){
				if(chgid[qry[j].x].empty())chged.pb(qry[j].x);
				chgid[qry[j].x].pb(j);
			}
			else ask.pb(j);
		sort(ask.begin(),ask.end(),cmp);
		vector<int> v,v0;
		for(int j=1;j<=m;j++)if(chgid[j].empty()){
			las_unchged[j]++;
			if(las_unchged[j]==1)v.pb(j);
		}
		sort(v.begin(),v.end(),cmp0);
		for(int j=0;j<unchged.size();j++)if(las_unchged[unchged[j]]==2)v0.pb(unchged[j]);
		unchged.clear();
		int now1=-1,now2=-1;
		while(now1+1<v.size()||now2+1<v0.size()){
			if(now1+1==v.size()||now2+1<v0.size()&&cmp0(v0[now2+1],v[now1+1]))unchged.pb(v0[++now2]);
			else unchged.pb(v[++now1]);
		}
		ufs.init();
		int now=-1;
		for(int j=0;j<ask.size();j++){
			while(now+1<unchged.size()&&qry[ask[j]].y<=w[unchged[now+1]])
				now++,ufs.mrg(a[unchged[now]],b[unchged[now]]);
			nei.init();
			for(int k=0;k<chged.size();k++){
				int fd=lower_bound(chgid[chged[k]].begin(),chgid[chged[k]].end(),ask[j])-chgid[chged[k]].begin()-1;
				int w0=fd==-1?w[chged[k]]:qry[chgid[chged[k]][fd]].y;
				if(qry[ask[j]].y>w0)continue; 
				int ar=ufs.root(a[chged[k]]),br=ufs.root(b[chged[k]]);
				nei.ae(ar,br),nei.ae(br,ar);
				}
			ans[ask[j]]=dfs(ufs.root(qry[ask[j]].x));
			for(int k=0;k<chged.size();k++)nei.head[ufs.root(a[chged[k]])]=nei.head[ufs.root(b[chged[k]])]=0;
			for(int k=0;k<cc.size();k++)vis[cc[k]]=false;
			cc.clear();
		}
		for(int j=i;j<=ie;j++)if(qry[j].tp==1)w[qry[j].x]=qry[j].y;
	}
	for(int i=1;i<=qu;i++)if(qry[i].tp==2)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：lhm_ (赞：3)

考虑若只有查询操作，那么就可以构造$Kruskal$重构树，然后在线询问了，也可以更简单的把询问离线，把询问和边都按权值从大到小排序，然后双指针依次加入对于当前询问合法的边，用并查集维护每个点的答案即可。

现在加上修改操作，考虑可以对所有操作分块，对块内所有询问操作排序，和之前的离线做法一样，用双指针依次加边。

但是有些边会在块内这些操作中涉及修改，那么对于每个询问,暴力扫一遍块内的修改操作，若一个修改操作在当前询问的时间点之前，那么就执行对应边的修改，执行完所有能够执行的修改后，再考虑这些涉及修改的边，加入合法的。

当指针扫到下一个询问时，因为询问已经不再是按时间顺序，所以有可能上一个询问执行的一些修改在当前询问不能生效，所以用可撤销并查集把除了不涉及修改的边都撤销掉，然后就和之前处理询问的过程一样了。

设块大小为$S$，对于一个块，需要对边排序和处理询问，处理询问时需要枚举所有的修改和用可撤销并查集来维护，那么处理一个块的复杂度为$O(m\log m + S^2 \log n)$，总共$\frac{q}{S}$个块，所以总复杂度就为$O(\frac{q m\log m}{S}+ qS \log n)$，块大小取$\sqrt{m\log m}$时会比较快。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 200010
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,S,qu,tot,top,cnt1,cnt2;
int ans[maxn],fa[maxn],siz[maxn],bel[maxn],val[maxn];
bool vis[maxn];
struct edge
{
    int x,y,v,id;
}e[maxn];
bool cmp1(const edge &a,const edge &b)
{
    return a.v>b.v;
}
struct query
{
    int x,v,id,opt;
}q[maxn],q1[maxn],q2[maxn];
bool cmp2(const query &a,const query &b)
{
    return a.v>b.v;
}
struct node
{
    int x,y;
}st[maxn];
int find(int x)
{
    return fa[x]==x?x:find(fa[x]);
}
void merge(int x,int y)
{
    int rx=find(x),ry=find(y);
    if(rx==ry) return;
    if(siz[rx]<siz[ry]) swap(rx,ry);
    st[++top]=(node){rx,ry};
    fa[ry]=rx,siz[rx]+=siz[ry];
}
void del(int id)
{
    int x=st[id].x,y=st[id].y;
    fa[y]=y,siz[x]-=siz[y];
}
void init()
{
    top=cnt1=cnt2=0,sort(e+1,e+m+1,cmp1);
    for(int i=1;i<=n;++i) fa[i]=i,siz[i]=1;
    for(int i=1;i<=m;++i) val[i]=vis[i]=0,bel[e[i].id]=i;
    for(int i=1;i<=tot;++i)
    {
        if(q[i].opt==1) q1[++cnt1]=q[i],vis[q[i].x]=true;
        else q2[++cnt2]=q[i];
    }
    sort(q2+1,q2+cnt2+1,cmp2);
}
void work()
{
    init();
    int now,pos=1;
    for(int i=1;i<=cnt2;++i)
    {
        int x=q2[i].x,v=q2[i].v,id=q2[i].id;
        while(e[pos].v>=v)
        {
            if(!vis[e[pos].id])
                merge(e[pos].x,e[pos].y);
            pos++;
        }
        now=top;
        for(int j=1;j<=cnt1;++j)
            val[q1[j].x]=e[bel[q1[j].x]].v;
        for(int j=1;j<=cnt1;++j)
            if(q1[j].id<id)
                val[q1[j].x]=q1[j].v;
        for(int j=1;j<=cnt1;++j)
            if(val[q1[j].x]>=v)
                merge(e[bel[q1[j].x]].x,e[bel[q1[j].x]].y);
        ans[id]=siz[find(x)];
        while(top>now) del(top--);
    }
    for(int i=1;i<=cnt1;++i) e[bel[q1[i].x]].v=q1[i].v;
}
int main()
{
    read(n),read(m),S=sqrt(m*log2(m));
    for(int i=1;i<=m;++i)
        read(e[i].x),read(e[i].y),read(e[i].v),e[i].id=i;
    read(qu);
    for(int i=1;i<=qu;++i)
    {
        q[++tot].id=i,read(q[tot].opt);
        read(q[tot].x),read(q[tot].v);
        if(tot==S) work(),tot=0;
    }
    if(tot) work();
    for(int i=1;i<=qu;++i)
        if(ans[i])
            printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：wurzang (赞：2)

先讲下部分分怎么搞。

有个非常暴力的暴力做法：

对于每一个询问，把边权大于 $w_j$ 的边加入，并查集维护联通块即可。

时间复杂度 $\mathcal{O(qm)}$，可以过 $\mathrm{Subtask\ 1}$

当 $t_i=2$ 的时候，可以直接 `kruskal` 重构树，可以过 $\mathrm{Subtask \ 4}$

$\rm Subtask \ 2$ 是一个链的结构，发现问题转为 $\max\limits_{l,r,i\in[l,r] \& d_i>=w_j}\{ r-l+1 \}$

然后就可以用线段树做一下。


$\rm Subtask \ 3,5$...不会做，告辞（

于是就可以收获 $43 \rm pts$




------------

至于正解...

可以把询问分块，设块长为 $S$，把每一条边分成三种去做，一种是块内没修改过的，一种是块内修改过，时间在询问前的，另一种是块内修改过，时间在询问后的。

前一种边可以直接与询问排序去做，时间复杂度 $\mathcal O(\frac{q}{S}m \log m)$

第二种边，第三种边可以枚举块内修改，用可撤销化并查集去做，时间复杂度是 $\mathcal O(\frac{q}{S}S^2 \log n)$


至于块长多大最优，~~人肉二分得出~~好像是 $\sqrt{m \log n}$



交 LOJ ，直接 AC 了，然后再交洛谷，TLE 44 pts....


神 $\sf\color{black}{F}\color{red}{zzzz}$ 说这题还有两个优化，看了一眼题解，发现第一种边在排序的时候完全可以先排序再归并，流程如下：

1. 在解决询问之前先把边排序一遍
2. 把排序后的边塞进块里解决询问，把询问排序，没修改的边拉出来和询问做一次归并排序，时间复杂度 $\mathcal{O(\frac{q}{S}m)}$
3. 解决当前块内的询问后，把块内修改的边拉出来排序，没有修改的边也拉出来，和修改的边做一次归并排序，时间复杂度 $\mathcal{O}(\frac{q}{S}m)$



看起来好像优化了时间复杂度但其实只是卡常，因为时间复杂度主要在可撤销化并查集上...

总而言之这题是一道不错的数据结构题，也许能放进 NOIP 提高组并查集讲课里（


如果看不懂可以看代码，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int u[N], v[N], d[N], vis[N], n, m;
struct query {
    int type, val, id;
    query() {}
    query(int _t, int _v, int _id) {
        type = _t;
        val = _v;
        id = _id;
    }
    bool operator<(const query &b) const { return val == b.val ? type < b.type : val > b.val; }
};
void merge(query *A, query *B, query *f, int n, int m) {
    int i = 1, j = 1, cnt = 0;
    while (i <= n && j <= m)
        if (A[i] < B[j])
            f[++cnt] = A[i++];
        else
            f[++cnt] = B[j++];
    while (i <= n) f[++cnt] = A[i++];
    while (j <= m) f[++cnt] = B[j++];
}
query a[N << 1], A[N << 1], B[N << 1], F[N << 1];
int type[N], b[N], r[N], s[N], w[N], ans[N], cnt;
int f[N], sz[N];
int find(int x) {
    while (x != f[x]) x = f[x];
    return x;
}
int st[N], top = 0;
void solve(int L, int R) {
    cnt = 0;
    int cnt1 = 0, cnt2 = 0;
    for (int i = 1; i <= n; ++i) f[i] = i, sz[i] = 1;
    for (int i = L; i <= R; ++i)
        if (type[i] == 1)
            vis[b[i]] = i;
        else
            A[++cnt1] = query(1, w[i], i);
    sort(A + 1, A + cnt1 + 1);
    for (int i = 1; i <= m; ++i)
        if (vis[F[i].id] == 0)
            B[++cnt2] = F[i];
    merge(A, B, a, cnt1, cnt2);
    cnt = cnt1 + cnt2;
    for (int i = L; i <= R; ++i) vis[b[i]] = 0;
    for (int i = 1; i <= cnt; ++i) {
        // if(L==3) cout<<a[i].type<<" "<<a[i].id<<" "<<d[a[i].id]<<endl;
        if (a[i].type == 0) {
            int x = find(u[a[i].id]), y = find(v[a[i].id]);
            if (x == y)
                continue;
            if (sz[x] >= sz[y])
                swap(x, y);
            f[x] = y;
            sz[y] += sz[x];
        } else {
            top = 0;
            for (int j = L; j <= a[i].id; ++j)
                if (type[j] == 1)
                    vis[b[j]] = r[j];
            for (int j = L; j <= a[i].id; ++j)
                if (type[j] == 1 && vis[b[j]] >= a[i].val) {
                    int x = find(u[b[j]]), y = find(v[b[j]]);
                    if (x == y)
                        continue;
                    if (sz[x] >= sz[y])
                        swap(x, y);
                    st[++top] = x;
                    f[x] = y;
                    sz[y] += sz[x];
                }
            for (int j = a[i].id; j <= R; ++j)
                if (type[j] == 1 && d[b[j]] >= a[i].val && vis[b[j]] == 0) {
                    // if(i==3) cout<<j<<" Q\n";
                    int x = find(u[b[j]]), y = find(v[b[j]]);
                    if (x == y)
                        continue;
                    if (sz[x] >= sz[y])
                        swap(x, y);
                    st[++top] = x;
                    f[x] = y;
                    sz[y] += sz[x];
                }
            int x = find(s[a[i].id]);
            ans[a[i].id] = sz[x];
            while (top > 0) sz[f[st[top]]] -= sz[st[top]], f[st[top]] = st[top], --top;
            for (int j = L; j <= a[i].id; ++j)
                if (type[j] == 1)
                    vis[b[j]] = 0;
        }
    }
    for (int i = L; i <= R; ++i)
        if (type[i] == 1)
            vis[b[i]] = 0;
}
int L[N], R[N];
int rd() {
    int x = 0;
    char ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
    return x;
}
void write(int x) {
    if (x < 0)
        return putchar('-'), write(-x);
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
int main() {
    n = rd();
    m = rd();
    for (int i = 1; i <= m; ++i) u[i] = rd(), v[i] = rd(), d[i] = rd();
    for (int i = 1; i <= m; ++i) F[i] = query(0, d[i], i);
    sort(F + 1, F + m + 1);
    int q;
    cin >> q;
    for (int i = 1; i <= q; ++i) {
        cin >> type[i];
        if (type[i] == 1)
            b[i] = rd(), r[i] = rd();
        else
            s[i] = rd(), w[i] = rd();
    }
    int len = 1000, cnt = q / len;
    for (int i = 1; i <= cnt; ++i) L[i] = R[i - 1] + 1, R[i] = L[i] + len - 1;
    if (R[cnt] < q)
        ++cnt, L[cnt] = R[cnt - 1] + 1, R[cnt] = q;
    for (int i = 1; i <= cnt; ++i) {
        solve(L[i], R[i]);
        for (int j = L[i]; j <= R[i]; ++j)
            if (type[j] == 1)
                d[b[j]] = r[j];
        int cnt1 = 0, cnt2 = 0;
        for (int j = L[i]; j <= R[i]; ++j)
            if (type[j] == 1)
                vis[b[j]] = 1;
        for (int j = 1; j <= m; ++j)
            if (vis[F[j].id] == 0)
                A[++cnt1] = F[j];
            else
                B[++cnt2] = query(0, d[F[j].id], F[j].id);
        sort(B + 1, B + cnt2 + 1);
        merge(A, B, F, cnt1, cnt2);
        for (int j = L[i]; j <= R[i]; ++j)
            if (type[j] == 1)
                vis[b[j]] = 0;
    }
    for (int i = 1; i <= q; ++i)
        if (type[i] == 2)
            write(ans[i]), putchar('\n');
    return 0;
}
```


对于我来说，这题是典型的口胡 3 分钟，写代码 3 小时 /kk

---

## 作者：FutaRimeWoawaSete (赞：2)

备选 T3 。                   

什么屑题啊，把块长开成 $3\sqrt n$ 就跑的飞快连常都不用卡，而开个正经的 $\sqrt n$ 就 T 飞了。              

其实还是挺简单的，只要想到询问分块即可。                 

考虑到对于一个询问如何处理：将当前图中所有的边中权值大于等于询问 $w$ 的边加进一个初始化的并查集中最后访问点 $b$ 的连通块大小。          

有了这个思想后我们发现加进去的边有一个性质：满足权值大于等于询问 $w$。那么假设现在有一些询问和一些按权值从大到小排的边和一些按 $w$ 从大到小排的询问，我们就可以双指针做这个问题了。                

考虑询问分块，令块长为 $\sqrt q$ ，对于每条不在块内修改的边我们提出来排序，对于块内的询问我们也提出来按 $w$ 排序。然后这一部分的边合并我们就用上述的双指针来做就好了，由于只有每个块要做一次双指针和排序，所以这一部分的时间复杂度是 $O(m \sqrt q (\log m + \log n))$ 。           

考虑对块内的边暴力做，先对于所有当前询问前的修改直接改掉，再把当前块内的合法边加入并查集中回答询问，考虑到我们排序已经有 $O(m \sqrt q \log m)$ 了所以用可撤销并查集撤销这些边，最后这一部分的时间复杂度是 $O(q \sqrt q \log n)$ 。                

一个比较显然的优化是对于块内的边不用并查集维护，直接并查集缩点后重新建图跑，那么前面双指针的部分就可以使用路径压缩并查集 $O(m \sqrt q a(n))$ ，而块内的边仅需要 $O(q\sqrt q)$ 的时间复杂度最后总的时间复杂度就是 $O(m \sqrt q a(n))$ 了，不过这种做法常数较大不推荐写。       

~~还是和 P3247 太像了。~~

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e5 + 5 , SIZE = 335;
int top,Ans[Len],n,m,t,sizt,L[SIZE],R[SIZE],q,cnt,flag[Len],eedge[Len],ssedge[Len],ccnt,qcnt,smr[Len];
struct Ques
{
	int opt,b,r;
}qu[Len];
struct node
{
	int x,y,w;
}edge[Len];
bool cmmp(int x,int y){return qu[x].r > qu[y].r;}
bool cmp(int x,int y){return edge[x].w > edge[y].w;}
struct Node
{
	int x,y,siz;
	Node(){x = y = siz = 0;}
	Node(int X,int Y,int SIZ){x = X , y = Y , siz = SIZ;}
}stk[Len];
struct NNode
{
	int fa[Len],siz[Len];
	void makeSet(){top = 0;for(int i = 1 ; i <= n ; i ++) fa[i] = i , siz[i] = 1;}
	int findSet(int x){return fa[x] == x ? fa[x] : findSet(fa[x]);}
	void unionSet(int x,int y)
	{
		int u = findSet(x) , v = findSet(y);
		if(u == v) return;
		if(siz[u] < siz[v]) swap(u , v);
		stk[++ top] = Node(u , v , siz[u]);
		fa[v] = u , siz[u] += siz[v];
	}
	void del(int ID)
	{
		int u = stk[ID].x , v = stk[ID].y;
		fa[v] = v , siz[u] = stk[ID].siz;
	}
}S1;
signed main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= m ; i ++) scanf("%d %d %d",&edge[i].x,&edge[i].y,&edge[i].w);
	scanf("%d",&q);
	for(int i = 1 ; i <= q ; i ++) scanf("%d %d %d",&qu[i].opt,&qu[i].b,&qu[i].r);
	t = 1024; 
	sizt = q / t;
	for(int i = 1 ; i <= sizt ; i ++) L[i] = (i - 1) * t + 1 , R[i] = i * t;
	if(R[sizt] < q)
	{
		sizt ++;
		L[sizt] = R[sizt - 1] + 1;
		R[sizt] = q;
	}
	for(int i = 1 ; i <= sizt ; i ++) 
	{
		cnt = ccnt = qcnt = 0;S1.makeSet();int idx = 1;
		for(int j = L[i] ; j <= R[i] ; j ++) 
		{
			if(qu[j].opt == 1) flag[qu[j].b] = i , ssedge[++ ccnt] = qu[j].b;
			else smr[++ qcnt] = j;
		}
		for(int j = 1 ; j <= m ; j ++) if(flag[j] != i) eedge[++ cnt] = j;
		sort(eedge + 1 , eedge + 1 + cnt , cmp);
		sort(ssedge + 1 , ssedge + 1 + ccnt);
		sort(smr + 1 , smr + 1 + qcnt , cmmp);
		ccnt = unique(ssedge + 1 , ssedge + 1 + ccnt) - ssedge - 1;
		for(int j = 1 ; j <= qcnt ; j ++)
		{
			while(idx <= cnt && edge[eedge[idx]].w >= qu[smr[j]].r) 
			{
				S1.unionSet(edge[eedge[idx]].x , edge[eedge[idx]].y);
				idx ++;
			}
			int Top = top;
			for(int k = L[i] ; k <= smr[j] ; k ++) if(qu[k].opt == 1) swap(edge[qu[k].b].w , qu[k].r); 
			for(int k = 1 ; k <= ccnt ; k ++) if(edge[ssedge[k]].w >= qu[smr[j]].r) S1.unionSet(edge[ssedge[k]].x , edge[ssedge[k]].y);
			Ans[smr[j]] = S1.siz[S1.findSet(qu[smr[j]].b)];
			while(top > Top) S1.del(top --); 
			for(int k = smr[j] ; k >= L[i] ; k --) if(qu[k].opt == 1) swap(edge[qu[k].b].w , qu[k].r);
		}
		for(int j = L[i] ; j <= R[i] ; j ++) if(qu[j].opt == 1) edge[qu[j].b].w = qu[j].r;
	}
	for(int i = 1 ; i <= q ; i ++) if(qu[i].opt == 2) printf("%d\n",Ans[i]);
	return 0;
}
```

---

## 作者：mulberror (赞：1)

$$\href{http://blog.chhokmah.cn/index.php/archives/80/}{\Large\texttt{My blog}}$$

----
## 题目概括
给定一张 $N$ 个点，$M$ 条边的无向带权图。

每次询问给定一个二元组 $(x,y)$，从 $x$ 号节点开始出发，只允许通过边权 $\geq y$ 的边。

问能够到达的联通块最大的大小。

**要求动态修改边权**

## 思路要点
### 子任务讨论
暴力就不进行过多的讲解。

#### 子任务 链
本质是一个序列问题。

你可以发现每一次的操作是进行一次向左边扩展和向右边扩展，找到第一条不满足的边。也就是说你需要找到一个包含起点的最大区间，满足在上面的所有边权都满足 $\geq y$。

因为支持修改操作，所以考虑用二分答案，线段树查询的方法在 $O(nlog^2n)$ 的时间解决。

#### 子任务 只有查询
我们假设联通块中最小的边权为 $min$，那么某一个起点开始能够遍历整个联通块的充要条件是 $min \ge y$。

也就是最小边的边权 $\ge y$，这就容易想到用 $Kruscal$ 重构树来实现这个过程。

建立出 $Kruscal$ 重构树之后，以每一个节点为根节点的子树，都可以被以根节点为起点的路径包含，所以只需要倍增找到**最后一个满足条件的祖先节点**，然后其子树大小即为答案。 

也可以采用离线做法，将操作离线后，按照 $y$ 值从大到小查询，将所有的边按照顺序加入到并查集中，**答案就是联通块大小**。

### 正解
采用「子任务 只有查询」中的做法，考虑暴力。

我们按照询问分块，在当前块中的所有操作都相当于和前面所有块的到的新图**重新暴力**求一遍答案，然后**更新为新图**。

将当前块中不需要修改的边加入到联通块中，考虑修改的边，将在当前操作之前的每一条边最后一次操作得到的权值和标准值 $y$ 进行比较，否则视为未被修改。

每一次操作，同一条边可能被不同的修改操作，所以考虑要**可撤销并查集**。

## 代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

namespace FastIO {

template <class T> 
void rd(T& x) {
  x = 0;
  char ch = 0;
  bool f = 0;
  while (!isdigit(ch)) f |= ch == '-', ch = getchar(); 
  while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
  f ? x = -x : 1;
}

template <class T> 
void ptf(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) ptf(x / 10);
  putchar(x % 10 + 48);
}

void read(int& x) { rd(x); }
void read(long long& x) { rd(x); }
void read(unsigned int& x) { rd(x); }
void read(unsigned long long& x) { rd(x); }
void read(char& x) { x = getchar(); }
void read(string& x) { cin >> x; }
template <class T, class R> 
void read(pair<T, R>& x) {
  read(x.first), read(x.second);
}
template <class T> 
void read(vector<T>& x) { 
  for (auto& ele : x) read(x); 
}

void write(int x) { ptf(x); }
void write(long long x) { ptf(x); }
void write(unsigned long long x) { ptf(x); }
void write(unsigned int x) { ptf(x); }
void write(char x) { putchar(x); }
void write(char* x) { printf("%s", x); }
void write(string x) { cout << x; }
template <class T> 
void write(vector<T> x) {
  for (auto ele : x)  (x); 
}
template <class T, class R> 
void write(pair<T, R> x) {
  write(x.first), putchar(','), write(x.second);
}
template <class T> 
void writeln(T x) {
  write(x), puts("");
}

}

using FastIO::read;
using FastIO::write;
using FastIO::writeln;

namespace RevocableDisjoinSet {

const int N = 1e5 + 5; 

struct DisjoinSet {
  int top, n; 
  int fa[N], sz[N];
  pair<int, int> stk[N];

  void init(int x) {
    n = x, top = 0;
    for (int i = 1; i <= n; i++) {
      fa[i] = i; 
      sz[i] = 1;
    }
  }

  int get(int x) {
    return fa[x] == x ? x : get(fa[x]); 
  }

  void merge(int x, int y) {
    int p1 = get(x), p2 = get(y);
    if (p1 != p2) {
      if (sz[p1] > sz[p2]) { swap(p1, p2); }
      fa[p1] = p2; 
      sz[p2] += sz[p1];
      stk[++top] = make_pair(p1, p2);
    }
  }

  void revoke(int goal) {
    while (top > goal) {
      fa[stk[top].first] = stk[top].first;
      fa[stk[top].second] = stk[top].second; 
      sz[stk[top].second] -= sz[stk[top].first];
      top--; 
    }
  }

  int check(int x, int y) {
    return get(x) == get(y);
  }
};

}

// ===============

RevocableDisjoinSet::DisjoinSet dsu;

const int N = 5e4 + 5, M = 1e5 + 5; 

struct Ed {
  int u, v, w, id; // 现在第 i 条边 原来的编号
  
  bool operator<(const Ed& rhs) const {
    return w > rhs.w || (w == rhs.w && id < rhs.id);
  }
} ed[M], ed2[M], tmp[M];

struct Op {
  int t, x, y, id;

  bool operator<(const Op& rhs) const {
    return y > rhs.y;
  }
} op[M], op1[M], op2[M];

int n, m, q, tot;
int ismdy[M], did[M], ans[M];
int rk[M]; // 第 i 条边的 rank (按照 w 排序)

/**
 * 对于当前的边 i， 原来的编号为 ed[i].i 
 * 其中原来的编号是没有排序过的，现在的编号为排序完的下标
 */
void solve() {
  dsu.init(n);
  memset(ismdy, 0, sizeof ismdy);
  int t1 = 0, t2 = 0, pt = 1; // pt 遍历现在的编号
  for (int i = 1; i <= tot; i++) 
    if (op[i].t == 1) {
      op1[++t1] = op[i];
      ismdy[op[i].x] = 1; // 将这条边的原来的编号打上修改标记
    } else 
      op2[++t2] = op[i];
  // op2 是询问 op1 是修改
  sort(op2 + 1, op2 + 1 + t2);
  for (int i = 1; i <= t2; i++) {
    while (pt <= m && ed[pt].w >= op2[i].y) {
      if (!ismdy[ed[pt].id]) 
        dsu.merge(ed[pt].u, ed[pt].v);
      pt++; 
    }
    int temp = dsu.top;
    for (int j = 1; j <= t1; j++) 
      did[op1[j].x] = 0;
    for (int j = 1; j <= t1; j++) 
      if (op1[j].id < op2[i].id) 
        did[op1[j].x] = j; 
    for (int j = 1; j <= t1; j++) 
      if (did[op1[j].x] == j) {
        if (op1[j].y >= op2[i].y) 
          dsu.merge(ed[rk[op1[j].x]].u, ed[rk[op1[j].x]].v);
      } else if (did[op1[j].x] == 0 && ed[rk[op1[j].x]].w >= op2[i].y) 
        dsu.merge(ed[rk[op1[j].x]].u, ed[rk[op1[j].x]].v);
    ans[op2[i].id] = dsu.sz[dsu.get(op2[i].x)];
    dsu.revoke(temp);
  }
  memset(did, 0, sizeof did);
  int l = 1, r = 1, num = 0, t = 0;
  for (int i = t1; i >= 1; i--) 
    if (!did[op1[i].x]) {
      did[op1[i].x] = 1; 
      ed2[++num] = ed[rk[op1[i].x]];
      ed2[num].w = op1[i].y; 
    }
  sort(ed2 + 1, ed2 + 1 + num);
  while (l <= m && r <= num) {
    while (l <= m && did[ed[l].id]) 
      l++;
    if (ed[l].w >= ed2[r].w) 
      tmp[++t] = ed[l], l++;
    else 
      tmp[++t] = ed2[r], r++;
  }
  while (l <= m) {
    if (!did[ed[l].id])
      tmp[++t] = ed[l];
    l++;
  }
  while (r <= num) 
    tmp[++t] = ed2[r], r++;
  for (int i = 1; i <= m; i++) {
    ed[i] = tmp[i];
    rk[ed[i].id] = i; 
  }
}

int main() {
  read(n), read(m);
  for (int i = 1; i <= m; i++) {
    read(ed[i].u), read(ed[i].v), read(ed[i].w);
    ed[i].id = i; 
  }
  sort(ed + 1, ed + 1 + m);
  for (int i = 1; i <= m; i++) 
    rk[ed[i].id] = i; 
  read(q);
  tot = 0;
  for (int i = 1; i <= q; i++) {
    read(op[++tot].t), read(op[tot].x), read(op[tot].y);
    op[tot].id = i; 
    if (tot == 500) {
      solve();
      tot = 0;
    }
  }
  if (tot) 
    solve();
  for (int i = 1; i <= q; i++) 
    if (ans[i]) 
      writeln(ans[i]);
  return 0;
}
```
## 后言
- 当操作复杂，且不容易优化的时候，可以尝试用分块来降低复杂度。
- 还是强调一定要一步步分析问题，也要通过题目的性质来看出题目的模型。

---

## 作者：KokiNiwa (赞：1)

# [APIO2019]桥梁

[题目链接](https://www.luogu.com.cn/problem/P5443)

## 草稿

如果问题是静态的，我们可以用```kruaskal```重构树。

我们对操作进行分块。设块的大小为$S$。每隔$1$块构建一颗```kruaskal```重构树，需要$O(m)$的复杂度。然后计算更改$(u,v,w)$对询问的影响。分两种情况：

+ 如果这个边从能走转为不能走
+ 如果这个便从不能走变为能走

就不会了。因为两种东西都没法搞。

## 正解

两种形式的暴力：

1. 枚举所有边，看边中有哪些边可以走，把两个并查集合并，看大小。
2. 把所有询问排序（按照能走的边的最大值）。下面把边分为两类：
   1. 这条边被更改过。枚举所有更改过的边，合并。然后撤销掉这些操作，这样就不会对排好序之后的其他排序造成影响。
   2. 这条边没有被更改过。那么把所有边按照权值排序，每次询问加入一些边。

现在合并两个暴力，我们考虑分块（这有些套路......）。设块的大小为$S$，每一块给所有在该块内没被更改的边排一遍序。这个的复杂度是$O(\frac{m}{S}mlog_2m)$。在同一块内，对于每个询问找所有在它前面的更改，看这个边是否可以通过，如果可以通过，那么就合并两个端点。在合并完所有边之后，再撤销掉所有合并。这个复杂度是$O(\frac{m}{S}S^2log_2n)=O(mSlog_2n)$。于是总复杂度为$\frac{m}{S}mlog_2m+mSlog_2n$的。可以认为$n,m$是同阶的，那么可以把式子化为$\frac{n^2}{S}log_2n+nSlog_2n$。利用均值不等式可知，$\frac{n^2}{S}log_2n+nSlog_2n\ge \sqrt{n^{3}log_2^2n}=n^{\frac{3}{2}}log_2n$。可以发现在$\frac{n^2}{S}log_2n=nSlog_2n$的时候取得最优值，即$S=\sqrt{n}$时取最优解。

感觉实现好麻烦啊！

## 知识点

+ 可撤销并查集按高度合并复杂度分析：
  + 一个高度为$h$的树，必然是两个高度为$h-1$的树合并出来的。
+ 经典问题结点解法（不带更改的解法）：
  + 我们可以将所有的询问按照能走的路的最大限度排序，一条一条的加边。（见到这种题，一定要往这里想一想，一开始就没想这个，想的是```kruaskal```重构树）。
+ 卡常小常识：
  + 对于那种卡不过去分块题，可以把块的大小改为原来的```4```倍。
  + 可撤销并查集按照大小合并，可以一次操作只入队一个点（就是那个父亲被更改了的点）。这样就不需要一个节点记录一个版本了。

## 代码

[Link](https://paste.ubuntu.com/p/HnPF7Tt7Bs/)

---


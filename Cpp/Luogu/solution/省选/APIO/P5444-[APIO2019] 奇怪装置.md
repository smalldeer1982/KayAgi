# [APIO2019] 奇怪装置

## 题目描述

考古学家发现古代文明留下了一种奇怪的装置。该装置包含两个屏幕，分别显示两个整数 $x$ 和 $y$ 。

经过研究，科学家对该装置得出了一个结论：该装置是一个特殊的时钟，它从过去的某个时间点开始测量经过的时刻数 $t$，但该装置的创造者却将 $t$ 用奇怪的方式显示出来。若从该装置开始测量到现在所经过的时刻数为 $t$，装置会显示两个整数：$x = ((t + \lfloor \frac {t}{B} \rfloor) \bmod A)$，与 $y=(t \bmod B)$。这里 $\lfloor x \rfloor$ 是下取整函数，表示小于或等于 $x$ 的最大整数。

考古学家通过进一步研究还发现，该装置的屏幕无法一直工作。实际上，该装置的屏幕只在 $n$ 个连续的时间区间段中能正常工作。第 $i$ 个时间段从时刻 $l_i$ 到时刻 $r_i$。现在科学家想要知道有多少个不同的数对 $x,y$ 能够在该装置工作时被显示出来。

两个数对 $(x_1,y_1)$ 和 $(x_2,y_2)$ 不同当且仅当 $x_1 \neq x_2$ 或 $y_1 \neq y_2$。


## 说明/提示

对于第一个样例，装置屏幕将显示如下这些数对。

$t=4:(2,1)$

$t=7:(0,1)$

$t=8:(1,2)$

$t=9:(0,0)$

$t=17:(1,2)$

$t=18:(0,0)$

共有四个不同的数对：$(0,0),(0,1),(1,2),(2,1)$

对于全部数据，$1 \leq n \leq 10^6,1 \leq A,B \leq 10^{18},0 \leq l_i \leq r_i \leq 10^{18}$

令 $S=\sum_{i=1}^n (r_i-l_i+1)$ 与 $L=\max_{i=1}^n (r_i-l_i+1)$

详细子任务附加限制与分值如下表：

| 子任务 | 附加限制 | 分值 |
| :-----------: | :----------- | :-----------: |
| 1 | $S\leq 10^6$ | 10 |
| 2 | $n=1$ | 5 |
| 3 | $A\times B \leq 10^6$ | 5 |
| 4 | $B=1$ | 5 |
| 5 | $B\leq 3$ | 5 |
| 6 | $B\leq 10^6$ | 20 |
| 7 | $L\leq B$ | 20 |
| 8 | 无附加限制 | 30 |


## 样例 #1

### 输入

```
3 3 3
4 4
7 9
17 18```

### 输出

```
4```

## 样例 #2

### 输入

```
3 5 10
1 20
50 68
89 98```

### 输出

```
31```

## 样例 #3

### 输入

```
2 16 13
2 5
18 18```

### 输出

```
5```

# 题解

## 作者：Fading (赞：18)

显然这一类问题都有循环节。

发现这个题目让我们求的点对$(x,y)$


$$\left\{\begin{aligned}x\equiv t+\lfloor\frac tB\rfloor \pmod {A} \\y \equiv t\pmod {B} \end{aligned} \right.$$

我们设$t_1,t_2$两个时间点，所得到的$(x,y)$完全一致，即

$$\left\{\begin{aligned}t_1+\lfloor\frac {t_1}B\rfloor \equiv t_2+\lfloor\frac {t_2}B\rfloor \pmod {A} \\t_1 \equiv t_2\pmod {B} \end{aligned} \right.$$

不妨设$t_1<t_2,$则$t_2=t_1+xB(x \in N^*)$

代入上式

$$t_1+\lfloor\frac {t_1}B\rfloor \equiv t_1+xB+\lfloor\frac {t_1+xB}B\rfloor \pmod {A}$$

$$t_1+\lfloor\frac {t_1}B\rfloor \equiv t_1+xB+\lfloor x+\frac {t_1}B\rfloor \pmod {A}$$

根据高斯函数的性质，原式化为

$$\lfloor\frac {t_1}B\rfloor \equiv xB+x+\lfloor\frac {t_1}B\rfloor \pmod {A}$$

$$\therefore xB+x \equiv 0 \pmod {A}$$

$$ A|x(B+1)$$

根据整除的性质，或者提取最大公约数，得

$$\frac {A}{\gcd(A,B+1)}|x$$

所以只要满足这个式子，就可以满足对于任意$t,t+Bx$与$t$等价。

而且这个式子是**强**的，即不存在不满足这个式子依旧可以满足条件的$x$。

所以我们得到了我们想要的循环节$Bx$。显然$x$取$\frac {A}{\gcd(A,B+1)}$最小且满足条件。

此时$\frac {AB}{\gcd(A,B+1)}$就是我们要的最小循环节。

设最小循环节为$G$。

然后我们开始对每一个给定的区间$[l,r]$进行分类讨论：

### 情况$1:$

如果$r-l+1 \geq G$，则最终答案一定是$G$，直接退出程序。

### 情况$2:$

设$L=l \bmod G,R=r \bmod G$

如果$L\leq R$，因为这个情况不属于情况$1$（已经特判掉了）

所以我们可以取到这$R-L+1$个点对。

发现这正好是一个**数轴线段覆盖**问题。如果我们给所有点对进行编号$(0\sim (G-1)$,即$t\in [0,G-1] $时得到的点对$)$，并把编号抽象到数轴上，那么我们对线段$[L,R]$进行覆盖，就表示可以取到这些点。

### 情况$3:$

如果$L>R$，我们进行$[0,R],[L,G-1]$的区间覆盖。

最后整个数轴被覆盖的长度就是答案了。

### 实现

关于线段覆盖，我写了$3$种算法。

### 算法$1:$

动态开点线段树。

亲测只有$20$分 (loj)，$64000000\times 3$个$\texttt{long long}$你家评测机开的下？

### 算法$2:$

区间覆盖...珂朵莉树...岂不美哉？

loj 上过了（跑了最后一页），但是 luogu 不开 O2 过不去...

### 算法$3:$

由于懒得写 set ，我想到了一种类似贪心的方法。

所有要覆盖的线段按照左端点从小到大排序，然后从左向右扫，找到每一个连通块。

如果当前可以扩展到的右端点比这个线段的左端点小，说明已经有一个连通块了！答案加上连通块的长度即可。

这比上面两个快多了。

看不懂的可以看代码，包看包懂（滑稽）

代码如下（算法$3$，有注释）：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll long long
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-') f=-1LL;ch=gc();}
    while (isdigit(ch)){x=(x<<3LL)+(x<<1LL)+ch-'0';ch=gc();}
    return (f==1LL)?x:-x;
}
struct node{
    int l,r;
}g[2000001];
int tot;
inline bool cmp(node a,node b){
	return a.l<b.l;
}
signed main(){
	int n=read(),A=read(),B=read();
	int G=A/__gcd(A,B+1)*B;
	while (n--){
		int l=read(),r=read();
		if (r-l+1>=G){
			printf("%lld\n",G);return 0;
		}else{
			l=l%G,r=r%G;
			if (l>r){
				g[++tot].l=0;g[tot].r=r;
				g[++tot].l=l;g[tot].r=G-1;
			}else{
				g[++tot].l=l;g[tot].r=r;
			}
		}
	}
	sort(g+1,g+1+tot,cmp);
	int ans=0,nowL=g[1].l,nowR=g[1].r;
	g[tot+1].l=G+1;//新加入一个哨兵线段，把最后一个连通块算入总答案。
	for (int i=2;i<=tot+1;i++){
		if (nowR<g[i].l){//前面的线段已经形成了连通块
			ans+=nowR-nowL+1;nowL=g[i].l,nowR=g[i].r;
		}else{
			nowR=max(g[i].r,nowR);//更新可以扩展到的右端点，把这个线段加入连通块。
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Sai0511 (赞：13)

先来证明一个引理。    
$ac \equiv bc(modp),(c,p)=d$则$a \equiv b(mod \frac{p}{d})$         
$\because ac ≡ bc(mod p)$       
$\therefore p|ac-bc$     
$\therefore p|c(a-b)$                  
$\because (c,p)=d$   
$\therefore \frac{p}{d}|\frac{c}{d}(a-b)$     
$\because c,p$已经除去了$gcd$，      
$\therefore (\frac{p}{d},\frac{c}{d})=1$       
那么又$\because$整除    
$\therefore \frac{p}{d}|a-b$        
即$a \equiv b(mod \frac{p}{d})$    
正文开始。        
我们想办法计算出$x=((t+\lfloor \frac{t}{B} \rfloor)modA)$和$y=(t mod B)$    
当$t=k$时，假设$x=0,y=0$(当前是第一次循环，循环节就是$k$)       
把$t$换成$k$            
则$x=((k+\lfloor \frac{k}{B} \rfloor)modA),y=(kmodB)$        
此时因为$y=0$,所以$kmodB=0$，即$k|B$                       
那么$x$式子的下取整符号就可以去掉。        
即   
$$0=((k+\frac{k}{B})modA)$$      
$$0=(\frac{k(B+1)}{B}modA)$$     
不难想出和$0 \equiv \frac{k(B+1)}{B}(modA)$是等价的。    
**这时根据引理，把$\frac{k}{B}$当成引理中的$a$，把$B+1$当成引理中的$b$，把$A$当成引理中的$p$**           
得到    
$$0 \equiv \frac{k}{B} (mod \frac{A}{gcd(A,B+1)})$$         
$$0 \equiv k (mod \frac{AB}{gcd(A,B+1)})$$    
所以最小循环节$k$就是$\frac{AB}{gcd(A,B+1)}$。                                                         
做到这里恭喜你做完了这道题的一半。     
我们考虑把这道题变成一道区间覆盖问题。   
对区间$[l,r]$进行考虑                  
情况1：若$r-l+1>=k$      
则说明此区间的长度已经大于了循环节，即循环节的每一个数都能取到，答案就是循环节，直接退出程序即可。          
情况2：       
将$l$和$r$都模$k$（下文的$l$和$r$都是模$k$之后的）   
若$l <= r$         
表示这段区间被完全包含在了循环节里面，即这条线段都可以取到。   
我们在数轴上画一条$l \sim r$的线段。       
情况三：    
接着情况2，讨论$l > r$的情况    
此时的情况是$l$到某一个点刚好结束了循环节，而这个点之后又重新开始了下一个循环，所以会出现$l>r$的情况。                       
我们在数轴上画$2$条线段。     
$[l,k - 1]$和$[0,r]$                                               
最后的答案就是数轴被覆盖的长度。    
算这个东西就很简单了。    
把所有线段按照左端点排序。           
我们设$nl,nr$表示当前连通的线段的左端点和右端点。   
之后枚举每$1$条线段。设当前枚举到的线段为$L$。
若$L$的左端点$>nr$则说明这条线段已经与当前连通的线段所断开了，我们将答案加上$nr-nl+1$，然后将$nl$和$nr$更新为这条线段的左端点和右端点即可。        
否则说明这条线段也可以和当前已经连通的线段相连。                            
我们$check \_ max$一次$nr$和当前线段的右端点即可。（这部分配合着看我代码会更容易理解一些）                                        
## 代码   
```cpp
#include <bits/stdc++.h>

const int maxn = 1e6 + 10;
typedef long long ll;

template<class t> inline void read(t& res) {
	res = 0;  char ch = getchar();  bool neg = 0;
	while (!isdigit(ch))
		neg |= ch == '-', ch = getchar();
	while (isdigit(ch))
		res = (res << 1) + (res << 3) + (ch & 15), ch = getchar();
	if (neg)
		res = -res;
}

ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

ll n, m, i, j, k, A, B, sz, len, nl, nr;  
ll ans;   
struct line {
	ll l, r;     
	line() { l = r = 0; }
	line(ll _l, ll _r) { l = _l;  r = _r; }
	inline friend bool operator < (line a, line b) {
		return a.l < b.l;
	}
} l[maxn << 1];

int main() {
	read(n);  read(A);  read(B);
	len = A / gcd(A, B + 1) * B;  
	for (int i = 1; i <= n; i++) {
		ll le, ri;  read(le);  read(ri);
		if (ri - le + 1 >= len) { printf("%lld\n", len);  return 0; }
		le %= len;  
		ri %= len;
		if (le <= ri) 
			l[++sz] = line(le, ri);
		else
			l[++sz] = line(le, len - 1), 
			l[++sz] = line(0, ri);	
	}
	std::sort(l + 1, l + sz + 1);     
	l[++sz] = line(len + 1, 0);
	nl = l[1].l, nr = l[1].r;
	for (int i = 2; i <= sz; i++) {
		if (nr < l[i].l) {
			ans += nr - nl + 1;
			nl = l[i].l;
			nr = l[i].r;
		} else {
			nr = std::max(nr, l[i].r);
		}
	}
	printf("%lld\n", ans);
	return 0;   
} 
```

---

## 作者：StudyingFather (赞：7)

容易发现整个时间序列是有周期性的，我们设周期长度为 $T$。

接下来记 $x=f(t)=(t+\left \lfloor\dfrac{t}{B} \right \rfloor) \bmod A$，$y=g(t)=t \bmod B$。

由周期性的性质可得，$f(t)=f(t+T)$，$g(t)=g(t+T)$。即，

$$
t+\left \lfloor\dfrac{t}{B} \right \rfloor \equiv t+T+ \left \lfloor\dfrac{t+T}{B} \right \rfloor \pmod A
$$

以及，

$$
t \equiv t+T \pmod B
$$

发现 $g(t)$ 的等式较为简单，我们先从它入手。容易得到 $T \equiv 0 \pmod B$。

因此我们令 $T=kB$。

回代到 $f(t)$ 的等式中，得到（中间推导过程略），

$$
(B+1)k \equiv 0 \pmod A
$$

进一步得到，

$$
k=\frac{A}{\gcd(A,B+1)}
$$

从而得出，

$$
T=\frac{AB}{\gcd(A,B+1)}
$$

这样我们就把问题转变为了一个在 $[0,T)$ 区间上求若干条线段交大小的问题。

```cpp
// Problem: P5444 [APIO2019]奇怪装置
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5444
// Memory Limit: 500 MB
// Time Limit: 4000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<long long,long long> pll;
vector<pll> v;
long long gcd(long long x,long long y)
{
 return y==0?x:gcd(y,x%y);
}
int main()
{
 ios::sync_with_stdio(false);
 long long n,a,b;
 cin>>n>>a>>b;
 long long T=a/gcd(a,b+1);
 if((__int128)T*b>=1e18)
  T=1e18;
 else
  T*=b;
 for(int i=1;i<=n;i++)
 {
  long long l,r;
  cin>>l>>r;
  if(r-l+1>=T)
  {
   cout<<T<<endl;
   return 0;
  }
  l%=T,r%=T;
  if(l<=r)
   v.emplace_back(l,r);
  else
   v.emplace_back(l,T-1),v.emplace_back(0,r);
 }
 sort(v.begin(),v.end());
 long long l=v[0].first,r=v[0].second,ans=0;
 for(auto p:v)
  if(p.first<=r)
   r=max(r,p.second);
  else
  {
   ans+=r-l+1;
   l=p.first,r=p.second;
  }
 ans+=r-l+1;
 cout<<ans<<endl;
 return 0;
}
```

---

## 作者：chenxia25 (赞：3)

>  [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P5444)

>给定$n,a,b$以及$n$个区间$[l_i,r_i]$，求$\left|\bigcup\limits_{i=1}^n\left\{\left(\left(x+\left\lfloor\dfrac xb\right\rfloor\right)\bmod a,x\bmod b\right)\mid x\in[l_i,r_i]\right\}\right|$。

>$n\in\left[1,10^6\right],a,b\in\left[1,10^{18}\right],0\leq l_i\leq r_i\leq 10^{18}$。

首先可以手玩或者写个程序打个表，摸清楚$\left(\left(x+\left\lfloor\dfrac xb\right\rfloor\right)\bmod a,x\bmod b\right)$这个东西的规律。不难发现，随着$x$加一，第二个数肯定是加一（在$\bmod b$意义下），第一个数先加上个一，然后如果$b\mid x$就再加个一（在$\bmod a$意义下）。

由于每步的二元组值只跟上一步有关，而且值域有限大，所以显然是有循环节的。不妨找出这个循环节。

显然，第二个满足二元组等于$(0,0)$的$x$就是循环节大小（第一个$x=0$）。注意到，第一个数的增量与第二个数有关，而第二个数自己加自己的不受干扰，所以设$x=yb$，其中$y$是整数。显然，在从$0$开始的前$x$次增加中，第一个数正常加的是$x$次，额外增加了$y$次。在$\bmod a$意义下为$0$，所以满足$a\mid x+y$，即$a\mid y(b+1)$。即$\dfrac{a}{\gcd(a,b+1)}\mid y\dfrac{b+1}{\gcd(a,b+1)}$，显然$y=\dfrac{a}{\gcd(a,b+1)}$时取得最小值，于是循环节为$x=yb=\dfrac{a}{\gcd(a,b+1)}b$。

接下来，把每个区间$l,r$都弄成$\bmod x$意义下的集合，分三种情况：

1. $r-l+1\geq x$，此时显然它一个人就承包了值域里的所有元素，直接输出$x$走人；
1. 否则，$l\bmod x>r\bmod x$，显然是跨过了一个断点，可以将它拆成$[l\bmod x,x-1],[0,r\bmod x]$两个区间；
1. 否则，$l\bmod x\leq r\bmod x$，就变成$[l\bmod x,r\bmod x]$这一个区间。

接下来就是个区间并的事了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define X first
#define Y second
const int inf=0x3f3f3f3f3f3f3f3f;
int gcd(int x,int y){return y?gcd(y,x%y):x;}
int n,a,b;
vector<pair<int,int> > rg,ans;
signed main(){
	cin>>n>>a>>b;
	int x=a/gcd(a,b+1);
	x=x<LLONG_MAX/b?x*b:inf;
	while(n--){
		int l,r;
		scanf("%lld%lld",&l,&r);
		if(r-l+1>=x)return cout<<x,0;
		else if(l%x>r%x)rg.pb(mp(l%x,x-1)),rg.pb(mp(0,r%x));
		else rg.pb(mp(l%x,r%x));//分三种情况 
	}
	sort(rg.begin(),rg.end());
	for(int i=0;i<rg.size();i++)//区间并 
		if(ans.size()&&rg[i].X<=ans.back().Y)ans.back().Y=max(ans.back().Y,rg[i].Y);
		else ans.pb(rg[i]);
//	for(int i=0;i<ans.size();i++)printf("[%lld,%lld]\n",ans[i].X,ans[i].Y);
	int ans0=0;
	for(int i=0;i<ans.size();i++)ans0+=ans[i].Y-ans[i].X+1;//统计答案 
	cout<<ans0;
	return 0;
}
```

---

## 作者：空の軌跡 (赞：2)

这题很明显我们要求循环节，那么我们开始证明：


# 证明：
### 设 当前时间为 $t$，那么：

$x = ((t + \lfloor \frac{t}{B} \rfloor) \% A)$

$y=(t \% B)$

### 设 $ a×B $ 为最小的循环节 ( $a$ 为非负整数 ) , 那么：

对于 $y$ ，可见 $a$ 的取值没有约束:

$y=((t+a×B) \% B)$

$0=(a×B) \%B $

对于 $x$:

$x = ((t +a×B+ \lfloor \frac{t+a×B}{B} \rfloor) \% A)$

$x=((t+a×B+ \lfloor \frac{t}{B} \rfloor+a)\% A)$

提出 $x = ((t + \lfloor \frac{t}{B} \rfloor) \% A)$：

$0=(a×B+a)\%A$

$0=(a×(B+1))\%  A$

可见需要满足 $a×(B+1)$ 是 $A$ 的整数倍

$a × (B+1)=n×A $  (其中 $ n $ 为正整数，表示倍数 )

移项:

$ a = n × \frac{A}{B+1}$

所以为使得 $a$ 最小非负整数,

约分 $a=n× \frac {\frac{A}{gcd(A,B+1)}} {\frac{B+1}{gcd(A,B+1)}}$

可见 $n$ 最小为 $\frac{B+1}{gcd(A,B+1)}$

此时 $a$ 最小，
$a= \frac{A}{gcd(A,B+1)}$

则最小循环节为 $a×B=\frac{A×B}{gcd(A,B+1)}$

注 : 如果你的循环节 $<0$ 说明爆了 $long long$，直接设为 $1e18+10$就行
# 处理范围:

我们现在有了循环节，那么我们就可以处理了，

设 循环节为 $xhj$，以下的自行理解，思想很简单

对于$l÷xhj==r÷xhj$，我们把它改为 $L=l\%xhj,R=r\%xhj$ 这个区间

对于$l÷xhj==r÷xhj-1$, 我们把它分为 

$L=0,R=r\%xhj ------  L=l\%xhj,R=xhj-1$

两个区间

对于 $l÷xhj<r÷xhj-1$，很明显跨了整个区间，直接输出 $xhj$ 走人

接下来就是线段覆盖求并集问题了，我们直接以 $l$ 为关键字从小到大 $sort$ , 并保存最远的 $r$ , 然后按照顺序记录到 $ans$ 就可以

# 代码:
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
struct zxc
{
    long long l,r;
}qaq[3000010];
long long gcd(long long a,long long b)
{
    if(b==0)return a;
    return gcd(b,a%b);
}
bool cmp(zxc a,zxc b)
{
    return a.l<b.l;
}
inline long long read()
{
    long long a=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c<='9'&&c>='0')
    {
        a=a*10+c-'0';
        c=getchar();
    }
    return a;
}
int main()
{
    int n,cnt;long long a,b,xhj;
    n=read();a=read();b=read();
    xhj=a/gcd(a,b+1)*b;
    cnt=n;
    if(xhj<0)xhj=1e18+10;
    for(register int i=1;i<=n;++i)
    {
        qaq[i].l=read();qaq[i].r=read();
        long long A=qaq[i].l/xhj,B=qaq[i].r/xhj;
        if(A==B)
        {
            qaq[i].l%=xhj;
            qaq[i].r%=xhj;
        }
        if(A==B-1)
        {
            qaq[++cnt].l=0;
            qaq[cnt].r=qaq[i].r%xhj;
            qaq[i].l=qaq[i].l%xhj;
            qaq[i].r=xhj-1;
        }
        if(A<B-1)
        {
            cout<<xhj;
            return 0;
        }
    }
    sort(qaq+1,qaq+cnt+1,cmp);
    long long ans=qaq[1].r-qaq[1].l+1,now=qaq[1].r;
    for(register int i=2;i<=cnt;++i)
    {
        if(qaq[i].r<=now)continue;
        ans+=qaq[i].r-max(qaq[i].l-1,now);
        now=qaq[i].r;
    }
    cout<<ans;
}
```

---

## 作者：Erina (赞：2)

## 表示先膜AK APIO2019的大佬

然后进入正题.

这题其实可以通过一些简单的思维实验来直接找到规律, 不需要证明什么引理的说......

$((t+\frac{t}{b}) mod a,t mod b)$

第一眼看到这个式子的时候整个人内心是崩溃的.

但是看到数据范围这题就知道里面必然有玄机, 好像有一个循环节一样的东西, 然后就可以大莉

思想实验1: 考虑$t=ab$的情况, 发现和$t=0$是一样的, 这玩意儿的循环节长度必定是ab的因数.

思想实验2: 考虑**每一个**$(0,0)$的情况, 发现这时候$t mod b=0$, 况且$(t+\frac{t}{b}) mod a=0$成立.

那么这个情况也和$t=0$时相同, 况且这**一定是最小循环节**. 推一下式子, 发现刚好是$\frac{ab}{(a,b+1)}$

敲黑板

接下来我们需要说明每一个循环节之内的数不会重复.

我们再做一个思想实验: 我们发现$t mod b=1$时左边会+2, 其余时间+1, 也就是说, 每一次左边+2的时间是固定的.

那么左边出现一个确定的数对, 它到上一个$(0,0)$数对的时间一定是确定的.

那么我们就可以说明数对不会重复了.

然后就是一道线段合并的题目了.

大力排个序然后合并算长度就好了.

题目难度: 蓝牌

放一下代码......

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<set>
#include<map>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
namespace fio{
	streambuf*in=cin.rdbuf();
	char bb[1000000],*s=bb,*t=bb;
	#define gc() (s==t&&(t=(s=bb)+in->sgetn(bb,1000000),s==t)?EOF:*s++)
	inline __int128 read(){
		__int128 x=0;
		char ch=gc();
		while(ch<48)ch=gc();
		while(ch>=48)x=x*10+ch-48,ch=gc();
		return x;
	}
}using fio::read;
int n;__int128 a,b;
typedef pair<__int128,__int128>mp;
mp huaji[5000005];int top;
mp huaji2[5000005];int top2;
void w(__int128 x){
	if(x>=10)w(x/10);
	putchar(x%10+48);
}
__int128 gcd(__int128 a,__int128 b){return a==0?b:gcd(b%a,a);}
int main(){
	n=read(),a=read(),b=read();
	__int128 lcm;
	lcm=a*b/gcd(a,b+1);
	for(int i=1;i<=n;i++){
		__int128 l=read(),r=read();
		if(r-l+1>=lcm)w(lcm),exit(0);
		l%=lcm,r%=lcm;
		if(l<=r)huaji[++top]=mp(l,r);
		else huaji[++top]=mp(l,lcm-1),huaji[++top]=mp(0,r);
	}
	sort(huaji+1,huaji+top+1);
	huaji2[1]=huaji[1],top2=1;
	for(int i=2;i<=top;i++){
		if(huaji[i].first<=huaji2[top2].second)huaji2[top2].second=max(huaji2[top2].second,huaji[i].second);
		else huaji2[++top2]=huaji[i];
	}
	__int128 ans=0;
	for(int i=1;i<=top2;i++)ans+=huaji2[i].second-huaji2[i].first+1;
	w(ans);
}
```


---

## 作者：mulberror (赞：1)

$$\href{http://blog.chhokmah.cn/index.php/archives/81/}{\Large\texttt{My blog}}$$


-----
## 题目概括
给定 $n$ 个不相交的区间 $[l_i,r_i]$ 和 $A$ 和 $B$。

定义一个数 $t$ 到另一个二元组的映射为 $t\rightarrow ((t+\lfloor \frac tB\rfloor) \; mod \; A,t \; mod \; B)$

问这些区间的并中所有数的映射中不同的二元组有多少个。

数据范围：$N\leq 10^6,A,B,l_i,r_i\leq 10^{18}$


## 思路要点
考虑循环节大小，设循环节长度为 $S$，二元组分别为两个函数表示

$$
x(t)=(t+\lfloor \frac tB\rfloor) \; mod \; A
$$

$$
y(t)=t \; mod \; B
$$

$$
x(t+S)=(t+S+\lfloor \frac {t+S}B\rfloor) \; mod \; A
$$

$$
y(t+S)=(t+S) \; mod \; B
$$

$$
t\equiv t+S \mod B
$$

显然
$$
S\mod B=0
$$
那么令$S=kB$
$$
x(t+kB)\equiv (t+\lfloor \frac tB\rfloor+kB+k)\mod A
$$

$$
k(B+1)\mod A=0
$$

显然
$$
k=\frac A{\text{gcd}(B+1,A)}
$$
循环节大小为
$$
B\cdot \frac A{\text{gcd}(B+1,A)}
$$
然后就是离散化后线段覆盖即可

时间复杂度 $\Theta(nlogn)$

## 代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int N = 2e6 + 5;

ll A, B, cir, ans; 
int n, tot;
pair<ll, ll> sec[N];

template <class T> 
T gcd(T x, T y) {
  return !y ? x : gcd(y, x % y); 
}

ll calc(ll x) {
  return x % cir ? x % cir : cir; 
}

int main() {
  scanf("%d %lld %lld", &n, &A, &B);
  cir = A / gcd(A, B + 1);
  if (3e18 / cir < B) 
    cir = 3e18;
  else 
    cir *= B;
  tot = n;  
  for (int i = 1; i <= n; i++) {
    scanf("%lld %lld", &sec[i].first, &sec[i].second);
    if (sec[i].second - sec[i].first + 1 >= cir) {
      printf("%lld\n", cir);
      return 0;
    }
    sec[i] = make_pair(calc(sec[i].first), calc(sec[i].second));
    if (sec[i].first > sec[i].second) {
      sec[++tot] = make_pair(sec[i].first, cir);
      sec[i] = make_pair(1, sec[i].second);
    }
  }
  sec[++tot] = make_pair(cir + 1, cir);
  sort(sec + 1, sec + 1 + tot);
  ll left = sec[1].first, right = sec[1].second;
  for (int i = 2; i <= tot; i++) {
    if (sec[i].first <= right) {
      right = max(right, sec[i].second);
    } else {
      ans += right - left + 1; 
      left = sec[i].first, right = sec[i].second;
    }
  }
  printf("%lld\n", ans);
  return 0;
}
```

## 后言
- 对于数据较大，这题目又存在模运算，所以题目的突破口一定是找循环节。

---

## 作者：Flandre_495 (赞：1)

#### 我也是先膜拜一下参加APIO的大佬们orz，我因为NOIP太菜没能参加。。。

~~然后我无意间看到此题~~，神仙题！~

后来仔细推了推，发现不是很难。。过了一道APIO的题，毕竟机房大佬在考试当天就把这题切了，所以菜鸡在此写篇题解纪念一下。

___________

这题上来就让人很懵，$x$和$y$毫无优美性质，数据也很不和谐：暴力只有15分。

对大佬来说这题一上来就找到正解切了，但本菜鸡不是一上来就推式子的人，所以我是把$x$和$y$都列出来了。。。

我们发现x这个数由两部分组成，我们将$x$分成2部分，$x1 + x2$.

x1 = t % A，x2 = ⌊t/B⌋ % A;

然后仔细把样例模拟一遍，比如A = 4，B = 5。


```
t  ： 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 | 15

x1 ： 0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  | 3
x2 ： 0  0  0  0  0 |1  1  1  1  1 |2  2  2  2  2  | 3
y  ： 0  1  2  3  4 |0  1  2  3  4 |0  1  2  3  4  | 0
x  :  0  1  2  3  0 |2  3  0  1  2 |0  1  2  3  0  | 2

```

接下来不难发现t%B和⌊t/B⌋的每一段长度都为B，我们用$"|"$将其隔开。

我们不难发现：$x$中的每一段，只要第一个数确定，后面的数都是顺着下来，也是确定的。所以对于一个$t1$与$t2$，其$(x,y)$相等，那么$t1+1$与$t2+1$的$(x,y)$也相等，比如上表中的0与10。

#### 所以此题就是找一个循环节：最小的循环节使得两个数的（x，y）相等。

然后对于输入的每一段，mod B之后在循环节上找相应的位置，所有线段的交集的长度就是数对的个数。

循环节怎么找？ 这就很简单了：既然x与y都相等，那么首先y肯定得相等对吧，所以循环节长度是B的倍数。

x的增长规律很显然：每个数+1，过每一段再+1。

我们假设k段后出现相等的$x$，则

$$\begin{cases}t1+k+k*B=t2\\t1+k+k*B\equiv t1(mod\ A)\\(B+1)*k\equiv0(mod\ A)\end{cases}$$

求一个最小的k，他就是 $gcd(B+1, A)$;$\ \ $循环节长度就是$B*k$。

然后就好办了~，计算每一段询问在循环节上对应的位置，做一遍线段覆盖。按左端点排好序，更新最右端点的位置，我觉得肯定都会吧，具体在代码里。

#### 此题还要注意一个细节：会不会爆long long？

#### 肯定不会了~，t都没那么大怎么会爆？

但是你计算的循环节长度是$A*B/gcd(B+1,A)$的，是可以爆的，于是稍微处理一下，如果算出来的循环节长是负数，就把循环节改成无限大。

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll long long 
#include<vector>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const ll N=2001010;
const ll qwq=303030;
const ll inf=0x3f3f3f3f3f3f3f3f;
ll n,m;
ll H,R;
ll x,y;
ll A,B;
ll ans,cnt;
struct E{ ll l,r; } e[N];

inline ll read() {
	ll sum = 0; char c = getchar();
	while(c<'0' || c>'9') c = getchar();
	while(c>='0'&&c<='9') { sum = sum * 10 + c - '0'; c = getchar(); }
	return sum;
}

ll gcd(ll a,ll b) { return a%b==0 ? b : gcd(b,a%b); }

inline bool cmp(E aa,E bb) { return aa.l < bb.l; }

int main() {
	n = read(); A = read(); B = read();
	H = A / gcd(B+1,A) * B;
	if(H < 0) H = inf;            //爆long long
	for(int i=1;i<=n;i++) {
		x = read(); y = read();
		if(y-x+1>=H) { e[++cnt] = (E){0,H-1}; break; }                  //整个区间都能覆盖。
		x = x % H; y = y % H;
		if(y>=x) { e[++cnt] = (E){x,y}; }        //x，y在区间内。
		else {                //x，y在区间两遍。
			e[++cnt] = (E){0,y};
			e[++cnt] = (E){x,H-1};
		}
	}
	sort(e+1,e+cnt+1,cmp); R = e[1].r;
	for(int i=1;i<=cnt;i++) {
		ans += max((ll)0,e[i].l-R-1);
		R = max(R,e[i].r);
	}
	printf("%lld",H-(H-e[cnt].r)-e[1].l-ans+1);
	return 0;
}

```

---

## 作者：SamariumPhosphide (赞：1)

这道题还是比较水的。

首先显然我们不能考虑怎么样会不同，而是应该考虑什么情况会相同。

不妨假设在 $t$ 和 $t'$ 的时间相同，不妨 $t' > t$。

那么 $t' \equiv t (\mod B)$。设 $t' = t + Bx$。

那么 $t + \lfloor \frac{t}{B}\rfloor \equiv t + Bx + \lfloor \frac{t}{B} \rfloor + x (\mod A)$。

所以 $bx + x \equiv 0 (\mod A)$。

所以 $A | (b+1)x \Rightarrow \frac{A}{\gcd(A, B+1)} | x$。

因此相等的循环节是 $Bx = \frac{AB}{\gcd(A, B+1)}$。

那么我们考虑在这个循环节中有多少可以取到，也就是给出若干条线段在 $[0,Bx]$ 之间的线段，求总覆盖长度。

贪心即可。

[Code](https://www.luogu.com.cn/paste/hgg2z7o4)

---

## 作者：high_sky (赞：0)

# 题解：P5444 [APIO2019] 奇怪装置 题目分析

## 思路

一个想要提高代码效率的想法：找循环节。

题目要求求点对 $(x,y)$，我们不妨看看其循环节是什么。

我们假设有两个时间点 $a,b$，他们所得到的 $(x,y)$ 相同的条件为：

- 首先满足 $a\equiv b\pmod{B}$。
- 其次满足 $a+\left\lfloor\frac{a}{B}\right\rfloor\equiv b+\left\lfloor\frac b B \right \rfloor\pmod{A}$。

利用第一个式子，不妨设 $a<b$，可以假设出 $b=a+kB$，其中 $k$ 是正整数。

转换其下面的式子为：
$$
a+\left\lfloor\frac a B\right\rfloor\equiv a+kB+k+\left\lfloor\frac a B\right\rfloor\pmod{A}
$$
移项得到：
$$
k(B+1)\equiv 0\pmod{A}
$$
根据整除的性质，得到：
$$
x\equiv 0\pmod{\frac{A}{\gcd(A,B+1)}}
$$
当 $x$ 取最小的 $\frac{A}{\gcd(A,B+1)}$ 后，得到最小循环节 $p=xB=\frac{AB}{\gcd(A,B+1)}$。

于是乎我们可以开始分类讨论啦！

### 第一个情况

描述为：$r-l+1\geq p$。

也就是说其已经大于最小循环节了，其中所有的值都可以得到，直接输出 $p$ 即可。

### 第二个情况

首先不难想到离散化（因为不影响）使：
$$
l\leftarrow l\bmod p\\
r\leftarrow r\bmod p
$$
这种情况描述为：$l\leq r$。

此时 $[l,r]$ 这个区间可以取遍。

### 第三个情况

其描述为：$r<l$。

于是得到其可以得到的时间点的区间为 $[0,r]$ 和 $[l,p-1]$。

### 后续

得到这些区间之后就考虑求区间并集的长度即可，这个可以参考[[CSP-S 2024] 超速检测](https://www.luogu.com.cn/problem/P11232)的方法。

主要是将 $l$ 从大到小排序，接着求 $l$ 开始与当前区间是否存在交集然后进行扩张，到了实在不能扩张的时候统计答案即可。

## 代码

时间复杂度 $\mathcal{O}(n\log n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <stdlib.h>
#include <vector>
#include <set>
#include <map>
#define PII pair<int,int>
#define int long long
#define N 1000006
using namespace std;
int gcd(int a,int b) {
	return b ? gcd(b,a % b) : a;
}
int n,A,B,l[N],r[N];
set<PII> st;
vector<PII> v;
signed main(){
	cin >> n >> A >> B;
	int p = A / gcd(A,B + 1) * B;
	for (int i = 1;i <= n;i ++) {
		int l,r;
		scanf("%lld%lld",&l,&r);
		if (r - l + 1 >= p) return cout << p,0;
		l %= p,r %= p;
		if (l <= r) {
			v.push_back({l,r});
		}
		else {
			v.push_back({0,r}),v.push_back({l,p - 1});
		}
//		for (int i = l;i <= r;i ++)
//			st.insert({(i + i / B) % A,i % B});
//		l[i] = l,r[i] = r;
	}
//	int cnt = 0;
//	for (int i = 0;i < A;i ++)
//		for (int j = 0;j < B;j ++) {
//			
//		}
//	cout << st.size();
	stable_sort(v.begin(),v.end());
	int ans = 0,nl = v[0].first,nr = v[0].second;
	v.push_back({p + 1,0});
	for (int i = 1;i < v.size();i ++) {
		if (nr < v[i].first) {
			ans += nr - nl + 1,nl = v[i].first,nr = v[i].second;
		}
		else nr = max(nr,v[i].second);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：幸存者 (赞：0)

考虑如果存在 $t_1<t_2$ 使 $(t_1+\lfloor\dfrac{t_1}{B}\rfloor)\bmod A = (t_2+\lfloor\dfrac{t_2}{B}\rfloor) \bmod A$，$t_1\bmod B=t_2\bmod B$。

那么不妨设 $t_2=t_1+xB$，则 $xB+x\equiv0\pmod A$，所以 $A\mid x(B+1)$，即 $x_{\min}=\dfrac{A}{\gcd(A,B+1)}$。

所以我们找到了最小循环节 $\dfrac{AB}{\gcd(A,B+1)}$，设其为 $k$。

对于一个区间 $[l,r]$：

- 若 $r-l+1\ge k+1$，直接输出 $k$，程序结束；
- 若 $l\bmod k\le r\bmod k$，则对区间 $[l\bmod k,r\bmod k]$ 染色；
- 否则，对区间 $[l\bmod k,k-1]$ 和区间 $[0,r\bmod k]$ 染色。

最终答案显然就是被染色的点的个数，但如果你用动态开点线段树显然存不下，所以可以考虑直接对所有区间左端点排序，然后随便搞一下就行了。

可以看一下代码：

```cpp
sort(v.begin(), v.end());
int last = v[0].first, now = last, ans = 0;
for (auto i : v)
{
	if (i.first > now)
	{
		ans += now - last + 1;
		last = i.first, now = i.second;
	}
	else now = max(now, i.second);
}
ans += now - last + 1;
```

---

## 作者：xuantianhao (赞：0)

# [奇怪装置](https://www.luogu.com.cn/problem/P5444)

找到循环就很简单了。

很显然 $y$ 是每 $B$ 次一循环的，对于每个相邻的 $y$ 循环 $x$ 的值均相差 $B+1(\bmod A)$。

因此总的循环就是 $B+1$ 对于 $A$ 的循环乘上 $B$。

即 $\frac{A}{\gcd(A,B+1)} \times B$。

知道循环节之后，把查询分成 $O(n)$ 个区间，排序之后直接解决即可。

如果使用基数排序即可做到 $O(n)$。

以下是快排版本:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e6+100;
int n,A,B,cnt,res;
int r=-1,L,R;
pair<int,int> s[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>A>>B;
	A=min(1.0*B*(A/__gcd(A,B+1)),1e18);
	for(int i=1;i<=n;++i) {
		cin>>L>>R;
		if(R-L+1>=A){
			cout<<A;
			return 0;
		}
		L%=A;R%=A;
		if(L<=R) s[++cnt]=make_pair(L,R);
		else{
			s[++cnt]=make_pair(L,A-1);
			s[++cnt]=make_pair(0,R);
		}
	}
	sort(s+1,s+cnt+1);
	for(int i=1;i<=cnt;++i){
		if(r<=s[i].second){
			res+=s[i].second-max(r,s[i].first-1);
			r=s[i].second;
		}
	}
	cout<<res;
	return 0;
}
```


---

## 作者：I_am_Accepted (赞：0)

## Analysis

显然随着 $t$ 的增大，$(x,y)$ 是有循环节的。

但是循环节有多长呢？

### 求最小循环节长度

* * *
**引理：**
$$
A\ |\ BC
\iff
\frac{A}{\gcd(A,B)}\ |\ C
$$
* * *

这里我们称 $(x,y)$ 相同的 $t$ 的集合为等价类。

$r<s\ (\in\mathbb{N})$ 为两个等价的时刻，当且仅当
$$\begin{aligned}
r+\left\lfloor\frac{r}{B}\right\rfloor
&\equiv
s+\left\lfloor\frac{s}{B}\right\rfloor
&\pmod{A}
\quad
&(1)
\\
r
&\equiv
s
&\pmod{B}
\quad
&(2)
\end{aligned}$$
由 $(2)$ 设 $s=kB+r\ (k\in\mathbb{N}^+)$，则 $(1)$ 式改为

（以下全部为 $\pmod{A}$）
$$\begin{aligned}
&
r+\left\lfloor\frac{r}{B}\right\rfloor
\equiv
s+\left\lfloor\frac{s}{B}\right\rfloor
\\
\iff\quad&
r+\left\lfloor\frac{r}{B}\right\rfloor
\equiv
kB+r+\left\lfloor\frac{kB+r}{B}\right\rfloor
\\
\iff\quad&
r+\left\lfloor\frac{r}{B}\right\rfloor
\equiv
kB+r+\left\lfloor\frac{r}{B}+k\right\rfloor
\\
\iff\quad&
r+\left\lfloor\frac{r}{B}\right\rfloor
\equiv
kB+r+\left\lfloor\frac{r}{B}\right\rfloor+k
\\
\iff\quad&
kB+k
\equiv
0
\\
\iff\quad&
k(B+1)
\equiv
0
\\
\iff\quad&
A\ |\ k(B+1)
\\
\iff\quad&
\frac{A}{\gcd(A,B+1)}\ |\ k
\end{aligned}$$

由于我们要求**最小**循环节长度 $kB$，所以要 $k$ 最小，为
$$
\frac{A}{\gcd(A,B+1)}
$$
最小循环节为
$$
\frac{AB}{\gcd(A,B+1)}
$$

### 环形区间覆盖问题

设我们求出的最小循环节为 $d$。

若有一个 $r_i-l_i+1\ge d$，则所有可能的 $(x,y)$ 均被取到，输出 $d$ 即可。

否则，就是在同余系中的区间覆盖问题了。

接下来有多种写法，我这里用排序 + 求连续段的方法，具体看代码。

## Detail

最小循环节可能会爆 int64，所以建议用 long double 判断是否 $>10^{18}$，若是则设为 $10^{18}$。（因为循环节太长相当于没循环）

## Code

```cpp
//Said no more counting dollars. We'll be counting stars.
//#pragma GCC optimize("Ofast")
//#pragma GCC optimize("unroll-loops")//DONT use rashly,I have suffered
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")//DONT use rashly,I have suffered
#include<bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i<=k;i++)
#define Rof(i,j,k) for(int i=j;i>=k;i--)
#define Fe(x,y) for(int x=head[y];x;x=e[x].nxt)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define fin(s) freopen(s,"r",stdin)
#define fout(s) freopen(s,"w",stdout)
#define file(s) fin(s".in");fout(s".out")
#define cerr cerr<<'_'
#define debug cerr<<"Passed line #"<<__LINE__<<endl
template<typename T>T ov(T x){cerr<<"Value: "<<x<<endl;return x;}
#define ll long long
const ll mod=1000000007;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&1)r=r*x%mod;x=x*x%mod;y>>=1;}return r;}
inline void mad(ll &a,ll b){a=(a+b)%mod;while(a<0)a+=mod;}
inline void mmu(ll &a,ll b){a=a*b%mod;while(a<0)a+=mod;}
#define inv(a) pw(a,mod-2)
#define int long long
#define N -1

const long double Lim=1.1e18;
int n,A,B;
long double mul(int x,int y){
	long double xx=x,yy=y;
	return xx*yy;
}
vector<pair<int,int> > v;
signed main(){IOS;
	cin>>n>>A>>B;
	A/=__gcd(A,B+1);
	if(mul(A,B)>=Lim) A=Lim;//循环节 > 1e18，相当于没有循环 
	else A*=B;
	int x,y;
	For(i,1,n){
		cin>>x>>y;
		if(y-x+1>=A){
			cout<<A<<endl;
			return 0;
		}
		x%=A;
		y%=A;
		if(x<=y){
			v.pb(mkp(x,y));
		}else{
			v.pb(mkp(x,A-1));
			v.pb(mkp(0,y));
		}
	}
	sort(v.begin(),v.end());
	int lst=-1,now=-2,ans=0;
	for(auto i:v)
		if(i.fir<=now){
			ckmx(now,i.sec);
		}else{
			ans+=now-lst+1;
			lst=i.fir;
			now=i.sec;
		}
	ans+=now-lst+1;
	cout<<ans<<endl;
return 0;}
```

---


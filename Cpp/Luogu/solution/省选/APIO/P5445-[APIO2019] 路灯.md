# [APIO2019] 路灯

## 题目描述

一辆自动驾驶的出租车正在 Innopolis 的街道上行驶。该街道上有 $n+1$ 个停车站点，它们将街道划分成了 $n$ 条路段。每一路段都拥有一个路灯。当第 $i$ 个路灯亮起，它将照亮连接第 $i$ 与第 $i+1$ 个站点的路段。否则这条路段将是黑暗的。

安全起见，出租车只能在被照亮的路段上行驶。换言之，出租车能从站点 $a$ 出发到达站点 $b (a<b)$ 的条件是：连接站点 $a$ 与 $a+1$，$a + 1$ 与 $a+2$，……，$b-1$ 与 $b$ 的路段都被照亮。

在经过一些意外故障或修理之后，街道上的路灯可能是亮起的，也可能是熄灭的。

现在给定 $0$ 时刻时，街道上路灯的初始状态。之后 $1,2,\ldots,q$ 时刻，每时刻会发生下列两种事件之一：

- $\text{toggle} \ i$：切换第 $i$ 个路灯的状态。具体地说，若路灯原来亮起，则现在将熄灭；若路灯原来熄灭，则现在将亮起。

- $\text{query}  \  a  \  b$：出租车部门的负责人想知道，从 $0$ 时刻起到当前时刻，有多少个时刻满足：出租车能够从站点 $a$ 出发到达站点 $b$。

请你帮助出租车部门的负责人回答他们的问题。

## 说明/提示

对于全部数据，$1 \leq n,q \leq 3\times 10^5$，$|s|=n$，$1 \leq i \leq n$，$1 \leq a < b \leq n+1$。

详细子任务附加限制与分值如下表 **（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

| 子任务 | 附加限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $n$, $q\leq 100$ | 20 |
| 2 | 对于所有 $\text{query}\ a\ b$ 事件，满足 $a=b-1$ | 20 |
| 3 | 对于所有 $\text{toggle}\ i$ 事件，第 $i$ 个路灯将被点亮 | 20 |
| 4 | 所有 $\text{toggle}$ 事件都发生在第一个 $\text{query}$ 事件之前 | 20 |
| 5 | 无特殊限制 | 20 |

## 样例 #1

### 输入

```
5 7
11011
query 1 2
query 1 2
query 1 6
query 3 4
toggle 3
query 3 4
query 1 6```

### 输出

```
1
2
0
0
1
2```

# 题解

## 作者：ix35 (赞：23)

 P5445 APIO2019 路灯

一道清新的数据结构题...

将连续一段亮着的灯所连接的站点称为一个连通块，考虑点亮/熄灭一盏灯对于答案的贡献。

若点亮了一盏灯，相当于沟通了左右两个连通块，因此我们找出左右两个连通块的左右端点，将它们标记为连通即可。

若熄灭了一盏灯，相当于将一个连通块拆成两个，将两边之间的联系标记成中断即可。

考虑如何实现这个问题。

首先是找到一个点所在的连通块的左右端点，这个可以用两棵线段树来维护（另一篇题解貌似直接set了），点亮的操作相当于是区间赋值（右部连通块中点的左端点修改成左连通块中点的左端点，左连通块中点的右端点修改成右连通块中点的右端点），熄灭同理（左连通块中点的右端点修改成这个路灯左侧的站点，右连通块中点的左端点修改成这个路灯右侧的站点）。

接下来考虑如何统计答案。

构造一个$(n+1)\times (n+1)$的矩阵$M$，$M_{ij}$表示$i$与$j$站点的连通性，我们采用代价提前计算的方法，考虑点亮的操作，若操作在$t$时刻进行，左右连通块区间分别为$[l,x],[x+1,r]$，那么将矩阵中左上角为$(l,x+1)$，右下角为$(x,r)$的子矩阵中所有元素的值增加$q-t$，表示接下来的所有时刻，它们都将连通。

同理，如果要熄灭一盏灯，将那个子矩阵中的所有元素减少$q-t$即可，表示接下来的所有时刻，它们都不连通。

需要注意的就是，$t$时刻询问时如果$x,y$依然连通，由于我们采用代价提前计算，所以需要减掉当前时刻之后的代价，即$q-t$。若$x,y$现在不连通，那么之后的代价已经在曾经的某个时候减掉了，不需要再处理。

于是现在我们要解决子矩阵加，单点求值。

什么？CDQ？如果在线呢？

通过差分将子矩阵加转化成四个点的加减，单点求值转化成前缀矩阵求和。然后就是常规的树状数组套权值线段树问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=400010;
int tot,cnt,n,q,x,y,ans,rt[MAXN],val[MAXN<<5],ch[MAXN<<5][2],lp[2][4*MAXN];    //rt,val,ch为BIT套权值线段树用，lp为维护连通块左右端点用
char s[MAXN];
void upd (int p) {
	val[p]=val[ch[p][0]]+val[ch[p][1]];
	return;
}
void modify_t (int &rt,int l,int r,int pos,int v) {
	if (!rt) {rt=++tot;}
	if (l==r) {val[rt]+=v;return;}
	int mid=(l+r)>>1;
	if (pos<=mid) {modify_t(ch[rt][0],l,mid,pos,v);}
	else {modify_t(ch[rt][1],mid+1,r,pos,v);}
	upd(rt);
	return;
}
int query_t (int rt,int l,int r,int xl,int xr) {
	if (xr<l||r<xl) {return 0;}
	if (xl<=l&&r<=xr) {return val[rt];}
	int mid=(l+r)>>1;
	return query_t(ch[rt][0],l,mid,xl,xr)+query_t(ch[rt][1],mid+1,r,xl,xr);
}
void modify (int x,int y,int v) {
	if (y>n+1) {return;}
	for (int i=x;i<=n+1;i+=(i&(-i))) {modify_t(rt[i],1,n+1,y,v);}
	return;
}    //差分后的单点修改
int query (int x,int y) {
	int res=0;
	for (int i=x;i;i-=(i&(-i))) {res+=query_t(rt[i],1,n+1,1,y);}
	return res;
}    //前缀矩阵和
void pd (int p) {
	if (lp[0][p]) {
		lp[0][p*2]=lp[0][p*2+1]=lp[0][p];
		lp[0][p]=0;
	}
	if (lp[1][p]) {
		lp[1][p*2]=lp[1][p*2+1]=lp[1][p];
		lp[1][p]=0;
	}
	return;
}    //区间覆盖的标记下传
void buildt (int p,int l,int r) {
	if (l==r) {lp[0][p]=lp[1][p]=l;return;}
	int mid=(l+r)>>1;
	buildt(p*2,l,mid),buildt(p*2+1,mid+1,r);
	return;
}
void modify2 (int k,int p,int l,int r,int xl,int xr,int v) {
	if (xr<l||r<xl) {return;}
	if (xl<=l&&r<=xr) {lp[k][p]=v;return;}
	pd(p);
	int mid=(l+r)>>1;
	modify2(k,p*2,l,mid,xl,xr,v),modify2(k,p*2+1,mid+1,r,xl,xr,v);
}    //区间覆盖
int query2 (int k,int p,int l,int r,int pos) {
	if (l==r) {return lp[k][p];}
	pd(p);
	int mid=(l+r)>>1;
	if (pos<=mid) {return query2(k,p*2,l,mid,pos);}
	else {return query2(k,p*2+1,mid+1,r,pos);} 
}    //单点查询
bool chk (int x,int y) {
	return (query2(0,1,1,n+1,x)==query2(0,1,1,n+1,y));
}    //判断两点是否连通，只要看所在连通块左端点是否相等
void con (int x,int v) {
	int l=query2(0,1,1,n+1,x),r=query2(1,1,1,n+1,x+1);
	modify2(1,1,1,n+1,l,x,r),modify2(0,1,1,n+1,x+1,r,l);
	modify(l,x+1,q-v),modify(l,r+1,v-q),modify(x+1,x+1,v-q),modify(x+1,r+1,q-v);
	return;
}
void del (int x,int v) {
	int l=query2(0,1,1,n+1,x),r=query2(1,1,1,n+1,x+1);
	modify2(1,1,1,n+1,l,x,x),modify2(0,1,1,n+1,x+1,r,x+1);
	modify(l,x+1,v-q),modify(l,r+1,q-v),modify(x+1,x+1,q-v),modify(x+1,r+1,v-q);
	return;
}
int main () {
	scanf("%d%d%s",&n,&q,s+1);
	buildt(1,1,n+1); 
	for (int i=1;i<=n;i++) {
		if (s[i]=='1') {con(i,0);}
	}
	for (int i=1;i<=q;i++) {
		scanf("%s%d",s+1,&x);
		if (s[1]=='q') {
			scanf("%d",&y);
			ans=query(x,y);
			if (chk(x,y)) {ans-=q-i;}
			printf("%d\n",ans);
		} else {
			if (chk(x,x+1)) {del(x,i);}
			else {con(x,i);}
		}
	}
	return 0;
}
```


---

## 作者：Fading (赞：18)

看到点对，什么思路？转化为平面问题。

显然点对连通性可以转化到平面上。

设点对$(x,y)$在平面上表示为坐标$(x,y)$。

就是把点对映射到坐标上。 

我们用 set 来维护亮灯的连续段。

设当前时间为$t$，总时间为$T$。 

对于一个点$x$,设$x$可以到达最左边的位置为$lb$，$x+1$可到达最右边的位置为$rb$。 

### 修改

如果$[x,x+1]$之间的路灯开了，那么显然$[lb,x]$内的点与$[x+1,rb]$内的点就可以连通了！

$[lb,x],[x+1,rb]$连通，我们转化为矩形加$T-t$，表示这个矩形在$t$时刻亮了。 

这个矩形左下端点为$[lb,x+1]$，右上端点为$[x,rb]$。

如果$[x,x+1]$之间的路灯断了，$[lb,x]$与$[x+1,rb]$不再连通，我们转化为矩形减$T-t$。

表示这个矩形在$t$时刻又暗了。 

### 查询

发现询问就是矩形单点查询。

假设这个位置在$t_1$时连通，$t_2$时断开，

根据刚才的修改操作，这个点对连通的时间为$T-t_1-(T-t_2)=t_2-t_1$

正好相等！

#### 注意：如果查询的两点依然连通，答案还需要减去$(T-t)$

我们成功把问题转化为了普通的**矩形加，单点查**问题。

这就是普普通通的二维数点问题。

由于有时间轴，所以等价于三维偏序问题。 

所以就有两种解法：

### 算法$1$：CDQ分治+扫描线。

很显然这个可以用 CDQ 分治维护。

矩形加不好处理，先用扫描线把矩形差分成$4$个操作（和$\texttt{[HNOI2015]接水果}$ 很像）。 

第一维时间排序掉，第二维$x$坐标 CDQ ，第三维$y$坐标用差分+树状数组。

### 算法$2$：树套树+扫描线。 

用树套树可以支持在线。

先把矩形加用扫描线差分成$4$个操作。 

然后就是普普通通的单点修改，区间查询了。

这个不就是树套树可以维护的东西吗？

树状数组维护$x$坐标，动态开点线段树维护$y$坐标即可。

### 总结

两个算法复杂度都是$O(n\log_2^2n)$的。

而且有树状数组在，常数巨小。可以通过此题。

怎么开心怎么写吧。我写了算法$2$（因为我CDQ老写错）。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#define gc getchar
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int n,N,T,root[600001],cnt;
struct node{
	int l,r,sum;
}seg[15020001];
#define mid ((lb+rb)>>1)
void Update(int &rt,int lb,int rb,int pos,int w){
	if (!rt) rt=++cnt;seg[rt].sum+=w;
	if (lb==rb) return;
	(mid>=pos?Update(seg[rt].l,lb,mid,pos,w):Update(seg[rt].r,mid+1,rb,pos,w));
}
int Query(int rt,int lb,int rb,int l,int r){
	if (!rt||lb>r||rb<l) return 0;
	if (lb>=l&&rb<=r) return seg[rt].sum;
	return Query(seg[rt].l,lb,mid,l,r)+Query(seg[rt].r,mid+1,rb,l,r);
}
inline void update(int pos,int r,int w){
	for (;pos<=n+1;pos+=pos&-pos) Update(root[pos],1,n+1,r,w);
}
inline int query(int posx,int posy){
	int ans=0;
	for (;posx;posx-=posx&-posx) ans+=Query(root[posx],1,n+1,1,posy);
	return ans;
}
inline void Add(int x1,int y1,int x2,int y2,int W){
	update(x1,y1,W);update(x1,y2+1,-W);
	update(x2+1,y1,-W);update(x2+1,y2+1,W);
}
struct road{
	int l,r;
};
inline bool operator < (road a,road b){
	return a.r<b.r;
} 
set<road> S;
set<road>::iterator it;
bool zt[2000001];
signed main(){
	n=1+read(),T=read();N=n-1;
	for (int i=1;i<=n;i++){
		S.insert((road){i,i});
	}
	for (int i=1;i<=N;i++){
		char ch=gc();
		while (!isdigit(ch)) ch=gc();
		zt[i]=(ch-48);
		if (zt[i]){
			it=S.lower_bound((road){0,i+1});it--;
			int lb=(*it).l;
			S.erase(it);S.erase((road){i+1,i+1});
			S.insert((road){lb,i+1});
		}
	}
	for (it=S.begin();it!=S.end();++it){
		Add((*it).l,(*it).l,(*it).r,(*it).r,T);
	}
	for (int t=1;t<=T;t++){
		char s[11];scanf("%s",s+1);
		if (s[1]=='q'){
			int x=read(),y=read();
			int ans=query(x,y);
			int X=(*(S.lower_bound((road){0,x}))).l;
			int Y=(*(S.lower_bound((road){0,y}))).l;
			printf("%d\n",ans-(T-t)*(X==Y));
		}else if (s[1]=='t'){
			int x=read();
			if (zt[x]==1){
				it=S.lower_bound((road){0,x});
				int lb1=(*it).l,rb1=x;
				int lb2=x+1,rb2=(*it).r;
				Add(lb1,lb2,rb1,rb2,t-T);
				S.erase((road){lb1,rb2});
				S.insert((road){lb1,rb1});S.insert((road){lb2,rb2}); 
				zt[x]^=1;
			}else{
				it=S.lower_bound((road){0,x});
				int lb1=(*it).l,rb1=x;
				it++;
				int lb2=x+1,rb2=(*it).r;
				Add(lb1,lb2,rb1,rb2,T-t);
				S.erase((road){lb1,rb1});S.erase((road){lb2,rb2});
				S.insert((road){lb1,rb2}); 
				zt[x]^=1;
			}
		}
	}
    return 0;
}

```


---

## 作者：mulberror (赞：7)

$$\href{http://blog.chhokmah.cn/index.php/archives/82/}{\Large\texttt{My blog}}$$

----

## 思路要点
我们称能够相互到达的子段为关键段。

维护关键段可以用线段树维护。

先考虑断开某一个关键段 $[l,r]$ 的某一条边 $k$，那么这个操作只对 $[l,k]$ 到 $[k+1,r]$ 内的答案有贡献。同理加入这条边也只对这两个关键段有贡献。

考虑将这个贡献差分，就得到了：
- 若插入，在第 $i$ 个时刻，$[l,k]$ 到 $[k+1,r]$ 内的答案 $-i$
- 若删除，在第 $i$ 个时刻，$[l,k]$ 到 $[k+1,r]$ 内的答案 $+i$

一个特判，如果每个询问的最后时刻 $t$，若这两个点是联通的，那么我们需要 $+t$。

接下来，我们将两个关键段抽象成二维坐标系内的 $x$ 轴和 $y$ 轴，也就是每次在 $(l,k+1,k,r)$ 内的矩形进行带权修改。

因此考虑离线分治计算答案，是一个二维数点问题。

时间复杂度 $\Theta (nlog^2n)$

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 3e5 + 5;

char s[N];
int n, q, etot;
int a[N], ans[N];
bool vis[N];

struct Node {
  pair<int, int> bd;
  bool tag;
} tr[N << 2];

struct Op {
  int t, x1, y1, x2, y2, id, v;
} op[N];

struct Event {
  int x, ys, ye, v;

  bool operator<(const Event& rhs) const {
    return x < rhs.x;
  }
} evt[N << 1];

int fw[N];

void pushdown(int x) {
  if (tr[x].tag) {
    tr[x << 1].bd = tr[x << 1 | 1].bd = tr[x].bd;
    tr[x << 1].tag = tr[x << 1 | 1].tag = 1;
    tr[x].tag = 0;
  }
}

void build(int x, int l, int r) {
  if (l == r) {
    tr[x].bd = make_pair(l, l);
    return;
  }
  int mid = (l + r) >> 1;
  build(x << 1, l, mid);
  build(x << 1 | 1, mid + 1, r);
}

void modify(int x, int l, int r, int ql, int qr, pair<int, int> val) {
  if (ql <= l && r <= qr) {
    tr[x].bd = val;
    tr[x].tag = 1;
    return;
  }
  pushdown(x);
  int mid = (l + r) >> 1;
  if (ql <= mid)
    modify(x << 1, l, mid, ql, qr, val);
  if (qr > mid)
    modify(x << 1 | 1, mid + 1, r, ql, qr, val);
}

pair<int, int> query(int x, int l, int r, int p) {
  if (l == r) 
    return tr[x].bd;
  pushdown(x);
  int mid = (l + r) >> 1;
  if (p <= mid) 
    return query(x << 1, l, mid, p);
  else 
    return query(x << 1 | 1, mid + 1, r, p);
}

void add(int p, int v) {
  for (int i = p; i <= n + 1; i += i & -i)
    fw[i] += v; 
}

int query(int p) {
  int ans = 0; 
  for (int i = p; i >= 1; i -= i & -i)
    ans += fw[i];
  return ans;
}

void addEvent(int x, int ys, int ye, int v) {
  evt[++etot] = (Event){x, ys, ye, v};
}

void solve(int l, int r) {
  if (l == r)
    return;
  int mid = (l + r) >> 1;
  solve(l, mid), solve(mid + 1, r);
  etot = 0;
  for (int i = l; i <= mid; i++)
    if (op[i].t == 1) {
      addEvent(op[i].x1, op[i].y1, op[i].y2, op[i].v);
      addEvent(op[i].x2 + 1, op[i].y1, op[i].y2, -op[i].v);
    }
  sort(evt + 1, evt + 1 + etot);
  sort(op + mid + 1, op + 1 + r, [](Op a, Op b) {
    return a.x1 < b.x1;
  });
  int pt = 1; 
  for (int i = mid + 1; i <= r; i++)
    if (op[i].t == 2) {
      while (pt <= etot && evt[pt].x <= op[i].x1) {
        add(evt[pt].ys, evt[pt].v);
        add(evt[pt].ye + 1, -evt[pt].v);
        pt++;
      }
      ans[op[i].id] += query(op[i].y1);
    }
  for (int i = 1; i < pt; i++) {
    add(evt[i].ys, -evt[i].v);
    add(evt[i].ye + 1, evt[i].v);
  }
}

int main() {
#ifndef ONLINE_JUDGE
  freopen("input.in", "r", stdin);
  freopen("output.out", "w", stdout);
#endif
  scanf("%d %d", &n, &q);
  scanf("%s", s);
  for (int i = 1; i <= n; i++)
    a[i] = s[i - 1] - '0';
  build(1, 1, n + 1);
  for (int i = 1; i <= n; i++) 
    if (a[i] == 1 && !vis[i]) {
      int it = i;
      vis[i] = 1; 
      while (a[it]) 
        it++, vis[it] = 1; 
      modify(1, 1, n + 1, i, it, make_pair(i, it));
    }
  memset(ans, 0, sizeof ans);
  memset(vis, 0, sizeof vis);
  char opt[10];
  for (int i = 1; i <= q; i++) {
    scanf("%s", opt);
    op[i].t = (opt[0] == 'q' ? 2 : 1);
    op[i].id = i; 
    if (op[i].t == 1) {
      int k; 
      scanf("%d", &k);
      if (a[k] == 1) {
        pair<int, int> p = query(1, 1, n + 1, k);
        op[i].x1 = p.first, op[i].x2 = k;
        op[i].y1 = k + 1, op[i].y2 = p.second;
        op[i].v = i; 
        modify(1, 1, n + 1, p.first, k, make_pair(p.first, k));
        modify(1, 1, n + 1, k + 1, p.second, make_pair(k + 1, p.second));
      } else {
        pair<int, int> p1 = query(1, 1, n + 1, k), p2 = query(1, 1, n + 1, k + 1);
        op[i].x1 = p1.first, op[i].x2 = k; 
        op[i].y1 = k + 1, op[i].y2 = p2.second;
        op[i].v = -i;
        modify(1, 1, n + 1, p1.first, p2.second, make_pair(p1.first, p2.second));
      }
      a[k] ^= 1;
    } else {
      scanf("%d %d", &op[i].x1, &op[i].y1);
      pair<int, int> p = query(1, 1, n + 1, op[i].x1);
      if (p.second >= op[i].y1 && p.first <= op[i].y1) 
        ans[i] += i; 
      vis[i] = 1; 
    }
  }
  memset(fw, 0, sizeof fw);
  solve(1, q);
  for (int i = 1; i <= q; i++)
    if (vis[i])
      printf("%d\n", ans[i]);
  return 0;
}
```

## 后言
- 这道题目充分的运用了数形结合和差分的思想，这可以将每一个操作对整体答案的贡献独立处理。而且更加形象的理解。

---

## 作者：panyf (赞：7)

类似 [P4690 [Ynoi2016] 镜中的昆虫](https://www.luogu.com.cn/problem/P4690) 的做法。

用 set 维护所有值为 $0$ 的位置，方便查询前驱后继。

对于某个为 $0$ 的位置 $l$,设其后继为 $r$，则对于询问 $(a,b)$ 满足全为 $1$ 当且仅当存在一组 $(l,r)$ 满足 $l<a,r\geq b$（边界情况假设位置 $0$ 和位置 $n+1$ 都为 $0$）。

将 $(l,r)$ $(a,b)$ 都视为二维平面上的点，则转化为二维偏序。

考虑如何处理修改操作。对每个点 $(l,r)$ 多维护一个权值 $w$ 和时间 $t$。修改一个点的权值，会导致 $O(1)$ 次前驱后继关系的改变。$t$ 时刻新增的 $(l,r)$ 相当于加入点 $(l,r,1,t)$，删除的 $(l,r)$ 相当于加入点 $(l,r,-1,t)$。

若 $l<a,r\geq b,t_0<t_1$，点 $(l,r,w,t_0)$ 对询问 $(a,b,t_1)$ 的答案贡献就是 $(t_1-t_0)\times w$，否则是 $0$。于是原题转化为三维偏序，想到 cdq 分治。

先按 $t$ 排序，然后按 $r$ 归并排序，在 $l$ 位置插入树状数组。需要维护两个树状数组 $a_1,a_2$，在 $a_1$ 中插入 $t_0w$，$a_2$ 中插入 $w$。询问的答案即为 $a_2$ 的前缀和乘 $t_1$ 再减去 $a_1$ 的前缀和。

时间复杂度 $O((n+q)\log^2(n+q))$，空间 $O(n+q)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
enum{N=300009,M=N*4};
int n,ans[N],t1[N],id,v1[N],v2[N];
long long t2[N];
bool b[N];
struct P{int l,r,t,i;}p[M],q[M];
set<int>st;
void add(auto t,int*v,int x,int y){for(++x;x<=n;t[x]+=y,x+=x&-x)if(v[x]!=id)v[x]=id,t[x]=0;}
auto sum(auto t,int*v,int x){auto r=*t*0;for(++x;x;x&=x-1)if(v[x]==id)r+=t[x];return r;}
void cdq(int l,int r){
	if(l==r)return;
	int m=l+r>>1,i=l,j=m+1,k=l;
	for(cdq(l,m),cdq(j,r),++id;j<=r;q[k++]=p[j++]){
		for(;i<=m&&p[i].r>=p[j].r;q[k++]=p[i++])if(p[i].i<2)add(t1,v1,p[i].l,p[i].t*p[i].i),add(t2,v2,p[i].l,p[i].i);
		if(p[j].i>1)ans[p[j].i]+=sum(t2,v2,p[j].l-1)*1ll*p[j].t-sum(t1,v1,p[j].l-1);
	}
	memcpy(q+k,p+i,sizeof(P)*(r-k+1)),memcpy(p+l,q+l,sizeof(P)*(r-l+1));
}
int main(){ios::sync_with_stdio(0),cin.tie(0);
	int q,i,j,k,tq=1,t=0;
	string s;
	for(cin>>n>>q>>s,i=1;i<=n;++i)b[i]=s[i-1]-'0';
	for(i=0,++n;i<=n;++i)if(!b[i]){
		if(st.size())p[++t]={*st.rbegin(),i,0,1};
		st.insert(i);
	}
	for(i=1;i<=q;++i)if(cin>>s>>j,s[0]=='t'){
		if(b[j]^=1){
			auto o=st.lower_bound(j);
			if(o!=st.begin())if(p[++t]={*prev(o),j,i,-1},o!=--st.end())p[++t]={*prev(o),*next(o),i,1};
			if(o!=--st.end())p[++t]={j,*next(o),i,-1};
			st.erase(o);
		}else{
			auto o=st.insert(j).first;
			if(o!=st.begin())if(p[++t]={*prev(o),j,i,1},o!=--st.end())p[++t]={*prev(o),*next(o),i,-1};
			if(o!=--st.end())p[++t]={j,*next(o),i,1};
		}
	}else cin>>k,p[++t]={j,k,i,++tq};
	for(cdq(1,t),i=2;i<=tq;++i)cout<<ans[i]<<'\n';
	return 0;
}

```

---

## 作者：hegm (赞：5)

### [P5445 [APIO2019] 路灯](https://www.luogu.com.cn/problem/P5445)

放在题单里面好长时间了，终于拿它开刀了。

发现题目很抽象，询问的是所有历史版本中联通的数量，就很难受。

我们先考虑维护好连通性，而且不仅仅是连通性，还有联通的时间，所以我们考虑暴力一点，维护一个矩阵 $A_{i,j}$ 表示 $i,j$ 联通的总时间。那么我们某次将操作 $[l,x]\sim[x+1,r]$ 连接了起来，那么我们在矩阵上对应的某一个矩形的值也会随之变化。

那么我们就要弄清楚两点

1. 变化的值是多少。

2. 变化的矩形范围是啥。


首先我们考虑变化的值，显然对于一次操作，他的持续时间是下次两点断开的时间，那么对于某一个位置，我们记录下他的开始时间，再某一次结束/查询的时候用结束的时间减去开始时间就行了。

这里用了一个更方便的方法：

加入我们连接的时候的时间为 $T_1$，断开的时间为 $T_2$，容易知道，这个过程中 $l\sim r$ 的连接时间为 $T_2-T_1$。（连接时间左闭右开）

那么我们不妨给他定下一个权值，在连接的时候我们将矩阵的权值增加 $-T_1$，断开的时候我们将权值减去 $-T_2$，这样我们的贡献就是 $T_2-T_1$ 了。

接下来我们考虑矩形的范围，假如说我这次操作修改的是第 $x$ 条道路，那么会影响的是 $x,x+1$ 两点所在连通块的关系。

为了确切的知道某个点所在的联通块是什么，我们需要动态的维护他，因为连通块需要支持的是连接和断裂，我们将他转化一下：

-  对于一个连通块 $l\sim r$ 我从中间某处 $x$ 道路断裂，那么 $l\sim x$ 所在的连通块的右端点会全部变为 $x$， $x+1\sim r$ 所在的连通块的左端点会变为 $x+1$ 很基础的区间赋值，直接用一棵普通线段树维护即可。

- 联通同理，我们将 $l\sim x,x+1\sim r$ 联通，只需要将 $l\sim r$ 的左端点设为 $l$ 右端点设为 $r$ 即可。

现在知道了要修改的连通块我们来看看修改的矩阵具体是什么：

1. 亮灯：
	
    假如我这次修改是将 $[l,x]$ 和 $[x+1,r]$ 连接起来，首先我们需要清楚这两个连通块在矩形上的含义：
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/v31c76gj.png)
    
    现在我们需要让他们联通，结合上面的矩阵含义，我们知道 $x,y$ 的连通时间就是 $A_{x,y}$ 的值，那么现在我们是要将 $a\in[l,x],b\in[x+1,r],A_{a,b}$ 的值全部加上，所以我们要支持矩形加，加的矩形是 $[l,x+1]\sim [x,r]$。
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/9abjjnxk.png)
    
    黄色部分就是我们添加的。
    
2. 灭灯
	
    和上方同理，在对应位置减去 $-T_2$ 即可。
    
上述操作需要对联通的线段树修改最左边和最右边端点，别忘记了。

- 一些小问题：
	
    假如说我的 $l\sim x\sim x+1\sim r$ 连接的好好地，这个时候有一个 $k\in(l,x)$ 将 $l\sim x$ 断开了怎么办？
    
    那么根据上述方法，我们能画出矩形。$[l,k+1]\sim[k,r]$
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/c93yhdv9.png)
    
    我们来手算一下，现在假设 $l\sim x$ 是在 $T_1$ 的时候联通的， $l\sim r$ 是在 $T_2$ 联通的， $k$ 打断是在 $T_3$ 时刻，你会发现所有的连接都是合法的。所以做法没有问题。
    
考虑用树套树维护，外层树状数组，内层动态开点线段树节省空间。

使用差分将操作转化为单点修改，区间查询即可。
    
如果某一次询问的时候，两个节点还处于连通状态，因为它们之前已经在 $T_1$ 时刻被增加了，别忘记在当前询问时，减去当前时间。

### $\text{CODE}$
```cpp
#include<bits/stdc++.h>
#define N 300005
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,q,a[N],m;
#define ls (now<<1)
#define rs (now<<1|1)
struct link
{
	int l,r,lz,rz;
}kl[N*4];//用于维护连通性的线段树
void kldown(int now)
{
	if(kl[now].lz)
	{
		kl[ls].l=kl[rs].l=kl[ls].lz=kl[rs].lz=kl[now].lz;
		kl[now].lz=0;
	}
	if(kl[now].rz)
	{
		kl[ls].r=kl[rs].r=kl[ls].rz=kl[rs].rz=kl[now].rz;
		kl[now].rz=0;
	}
}
void cover(int now,int l,int r,int cl,int cr,int val,int op)
{
	if(l>=cl&&r<=cr)
	{
		if(op)kl[now].r=val,kl[now].rz=val;
		else kl[now].l=val,kl[now].lz=val;
		return ;
	}
	kldown(now);
	int mid=(l+r)>>1;
	if(mid>=cl)cover(ls,l,mid,cl,cr,val,op);
	if(mid<cr)cover(rs,mid+1,r,cl,cr,val,op);
}
int klque(int now,int l,int r,int x,int op)
{
	if(l==r)
	{
		if(op)return kl[now].r;
		else return kl[now].l;
	}
	kldown(now);
	int mid=(l+r)>>1;
	if(mid>=x)return klque(ls,l,mid,x,op);
	return klque(rs,mid+1,r,x,op);
}
#undef ls
#undef rs
#define lc tr[now].ls
#define rc tr[now].rs
struct tree
{
	int ls,rs,val;
}tr[N*100];int tot;
void up(int now)
{
	tr[now].val=0;
	if(lc)tr[now].val+=tr[lc].val;
	if(rc)tr[now].val+=tr[rc].val; 
}
void adt(int now,int l,int r,int x,int val)
{
	if(!now)return;
	if(l==r)
	{
		tr[now].val+=val;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=x)
	{
		if(!lc)lc=++tot;
		adt(lc,l,mid,x,val);
	}
	else
	{
		if(!rc)rc=++tot;
		adt(rc,mid+1,r,x,val);
	}
	up(now);
}
int qut(int now,int l,int r,int ql,int qr)
{
	if(!now)return 0;
	if(l>=ql&&r<=qr)return tr[now].val;
	int mid=(l+r)>>1,cnt=0;
	if(mid>=ql)cnt+=qut(lc,l,mid,ql,qr);
	if(mid<qr)cnt+=qut(rc,mid+1,r,ql,qr);
	return cnt;
}
int k[N*4];
int lowbit(int x){return x&(-x);}
void add(int x,int y,int val)
{
	while(x<=m)
	{
		adt(x,1,m,y,val);
		x+=lowbit(x);
	}
}
int que(int x,int y)
{
	int ans=0;
	while(x)
	{
		ans+=qut(x,1,m,1,y);
		x-=lowbit(x);
	}
	return ans;
}
void midy(int x1,int y1,int x2,int y2,int val)
{
	y2++;x2++;
	add(x1,y1,val);
	add(x2,y1,-val);
	add(x1,y2,-val);
	add(x2,y2,val);
}
int main()
{
	n=read();q=read();m=n+2;tot=m;
	for(int i=1;i<=n;i++)
	{
		char c;cin>>c;
		a[i]=c-'0';
	}
	for(int i=1;i<=m;i++)
	{
		cover(1,1,m,i,i,i,0);
		cover(1,1,m,i,i,i,1);
	}
	for(int l=1,r;l<=n;l++)
	{
		r=l;
		while(a[r])r++;r--;
		cover(1,1,m,l,r+1,l,0);
		cover(1,1,m,l,r+1,r+1,1);
		l=r+1;
	}
	for(int i=1,x,y;i<=q;i++)
	{
		char c;cin>>c;x=read();
		if(c=='t')
		{
			if(a[x]==0)
			{
				int l=klque(1,1,m,x,0),r=klque(1,1,m,x+1,1);
				cover(1,1,m,l,r,l,0);
				cover(1,1,m,l,r,r,1);
				a[x]=1;
				midy(l,x+1,x,r,-i);
			}
			else
			{
				int l=klque(1,1,m,x,0),r=klque(1,1,m,x,1);
				a[x]=0;
				cover(1,1,m,l,x,x,1);
				cover(1,1,m,x+1,r,x+1,0);
				midy(l,x+1,x,r,i);
			}
		}
		else
		{
			y=read();if(x>y)swap(x,y);
			int r=klque(1,1,m,x,1);
			int ans=que(x,y);
			if(y<=r)ans+=i;
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：FZzzz (赞：5)

挺妙的一道题，竟然 1A 了那就写篇题解吧。

首先你可以想出各种神奇的搞法，但是发现都不太行。

我们考虑改变一个灯的状态的影响。

可以发现相互可达的点形成了一个连通快，然后开一个灯就是把两个块合成一个，关灯就是拆散一个连通块。

这个连通块的维护，我本来想的是用线段树去维护每个点的左右端点，然后去区间赋值单点查询。但是其实我们可以直接用一个 `set` 去维护每个快。

现在我们可以直接考虑去维护每对点之间的可达关系。实际上这就是一个二维的平面，每次开关灯就是修改一个矩形内的点的状态。

但是怎么维护这个时间轴的问题呢？这里有一个很巧妙的想法：我们把时间段看作是时间点相减。这样我们只需要在每次改变状态时做一个矩形加就可以了。

现在我们需要矩形加单点查。我们做一个二维差分，然后树状数组套动态开点线段树即可。

code：
```cpp
#include<algorithm>
#include<set>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
    int x=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c)&&c!='-') c=getchar();
    if(c=='-'){
        f=1;
        c=getchar();
    }
	while(isdigit(c)){
        x=x*10+c-'0';
        c=getchar();
    }
    return f?-x:x;
}
const int maxn=3e5+5;
int n,q;
inline char readchar(){
	char c=getchar();
	while(isspace(c)) c=getchar();
	return c;
}
typedef pair<int,int> pii;
set<pii> s;
struct node{
	int l,r;
	node* ch[2];
	int sum;
	node(int l,int r):l(l),r(r),sum(0){
		ch[0]=ch[1]=0;
	}
	void modify(int x,int k){
		sum+=k;
		if(l<r){
			int mid=l+(r-l)/2;
			if(x<=mid){
				if(!ch[0]) ch[0]=new node(l,mid);
				ch[0]->modify(x,k);
			}
			else{
				if(!ch[1]) ch[1]=new node(mid+1,r);
				ch[1]->modify(x,k);
			}
		}
	}
	int query(int ql,int qr){
		if(ql==l&&qr==r) return sum;
		else{
			int ans=0;
			if(ch[0]&&ql<=ch[0]->r) ans+=ch[0]->query(ql,min(qr,ch[0]->r));
			if(ch[1]&&qr>=ch[1]->l) ans+=ch[1]->query(max(ql,ch[1]->l),qr);
			return ans;
		}
	}
};
inline int lowbit(int x){
	return x&-x;
}
struct bit{
	node* c[maxn];
	void init(){
		for(int i=1;i<=n+1;i++) c[i]=new node(1,n+1);
	}
	void modify(int x,int y,int k){
		while(x<=n+1){
			c[x]->modify(y,k);
			x+=lowbit(x);
		}
	}
	int query(int x,int y){
		int s=0;
		while(x>0){
			s+=c[x]->query(1,y);
			x-=lowbit(x);
		}
		return s;
	}
}t;
pii get(int x){
	set<pii>::iterator it=s.upper_bound(pii(x,n+1));
	return *(--it);
}
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=readint();
    q=readint();
    int last=0;
    for(int i=1;i<=n;i++)
    	if(readchar()=='0'){
    		s.insert(pii(last+1,i));
    		last=i;
		}
	s.insert(pii(last+1,n+1));
	t.init();
	for(int i=1;i<=q;i++){
		char opt=readchar();
		if(opt=='t'){
			int x=readint();
			pii l=get(x),r=get(x+1);
			if(l==r){
				t.modify(l.first,x+1,i);
				t.modify(x+1,x+1,-i);
				if(r.second<=n){
					t.modify(l.first,r.second+1,-i);
					t.modify(x+1,r.second+1,i);
				}
				s.erase(l);
				s.insert(pii(l.first,x));
				s.insert(pii(x+1,r.second));
			}
			else{
				t.modify(l.first,x+1,-i);
				t.modify(x+1,x+1,i);
				if(r.second<=n){
					t.modify(l.first,r.second+1,i);
					t.modify(x+1,r.second+1,-i);
				}
				s.erase(l);
				s.erase(r);
				s.insert(pii(l.first,r.second));
			}
		}
		else{
			int a,b;
			a=readint();
			b=readint();
			if(get(a)!=get(b)) printf("%d\n",t.query(a,b));
			else printf("%d\n",t.query(a,b)+i);
		}
	}
    return 0;
}
```


---

## 作者：_Ponder_ (赞：3)

[路灯](https://www.luogu.com.cn/problem/P5445)

### 题目大意

在 $n+1$ 个站点之间有 $n$ 盏路灯，给定 $0$ 时刻所有路灯的亮灭情况，在接下来的 $q$ 个时刻，每时刻会发生以下两种事件之一：

- 切换某一盏路灯的亮灭。

- 询问两点之间存在多少时刻使得两点之间的路灯全部亮起。

### 思路分析

一道不错的数据结构。

首先分析题目，发现这是一个和点对连通性相关的问题，要查询点对之间连通的时间。点对不好处理，考虑扩充一维，将一维的点对变成二维的点。

具体的说，设点对 $(x,y)$ 表示二维平面上的一个点 $(x,y)$，其点权为在没有后续修改的情况下在所有时刻中两点连通的时间。

那么询问操作就变成了裸的单点查询，不过值得注意的是，如果查询时这两点依然连通，那么还需要将得到的答案减去 $q-t$。（$t$ 为该操作的时刻）

接着考虑修改操作，设 $l_x,r_x$ 分别为点 $x$ 所在的极长连通段的左端点和右端点。

容易发现，当 $x$ 灭时，相当于将连通段 $(l_x,r_x)$ 分裂成 $(l_x,x)$ 和 $(x+1,r_x)$，同时以 $(l_x,x)$ 为左下端点，$(x+1,r_x)$ 为右上端点的矩形减 $q-t$。这代表着如果不考虑接下来的修改，那么从 $l_x$ 到 $x$ 中的所有点在接下来的时间中都会与 $x+1$ 到 $r_x$ 中的所有点连通。

类似的，当 $x$ 亮时，相当于将连通段 $(l_x,x)$ 和 $(x+1,r_{x+1})$ 合并成 $(l_x,r_{x+1})$，同时以 $(l_x,x)$ 为左下端点，$(x+1,r_{x+1})$ 为右上端点的矩形加 $q-t$。

那么这就变成了一个单点查区间加的二维数点问题，可以将一次矩形加差分成四个单点修改，这就是一个一般的区间查单点加的二维数点问题。

- 如何维护 $l_x,r_x$。

可以用类似于 ODT 的方法，用 `set` 进行维护。

具体的说，在 `set` 中储存所有的极长连通段的左右端点，合并时 `lower_bound` 一下，然后删除左右两个，再插入一个新的就可以了，分裂类似。

### 代码

这里使用树状数组套线段树实现二维数点。

时间复杂度 $O(n\log^2n)$，但常数较大，不吸氧会 T 一个点。（`set` 常数大，树套树常数也大，合在一起就这样了）

```
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <set>

using namespace std;
const int N=300100;

int n,q,in1,in2;
int light[N<<2];
char ch[N],inp[10];

namespace DCP_2{//普通的二维数点树套树
    #define mid (l+r>>1)
    #define lowbit(x) ((x)&(-(x)))
    int rt[N<<1],tot;
    struct STn{
        int l,r,sum;
    }a[N<<7];

    void change(int &p,int l,int r,int x,int k){
        if(!p) p=++tot;a[p].sum+=k;
        if(l==r) return ;
        if(x<=mid) change(a[p].l,l,mid,x,k);
        else change(a[p].r,mid+1,r,x,k);
    }
    int ask(int p,int l,int r,int x,int y){
        if(!p||x>y||l>y||r<x) return 0;
        if(x<=l&&r<=y) return a[p].sum;
        return ask(a[p].l,l,mid,x,y)+ask(a[p].r,mid+1,r,x,y);
    }
    void add(int x,int y,int k){
        for(;x<=n+1;x+=lowbit(x)) change(rt[x],1,n+1,y,k);
    }
    int query(int x,int y){
        int ans=0;
        for(;x;x-=lowbit(x)) ans+=ask(rt[x],1,n+1,1,y);
        return ans;
    }
}

namespace SET{//维护极长颜色段
    #define SNI set<Node>::iterator 
    struct Node{
        int l,r;
        bool operator < (const Node &b) const{
            return r<b.r;
        }
    };
    set<Node> s;

    void init(){
        for(int i=1;i<=n;i++) s.insert(Node{i,i});
    }
    void merge(int x1,int x2,int y1,int y2){//将(x1,x2) 和 (y1,y2) 合并成 (x1,y2)
        s.erase(Node{x1,x2});
        s.erase(Node{y1,y2});
        s.insert(Node{x1,y2});
    }
    void split(int x1,int x2,int y1,int y2){//将(x1,y2) 分裂成 (x1,x2) 和 (y1,y2)  
        s.erase(Node{x1,y2});
        s.insert(Node{x1,x2});
        s.insert(Node{y1,y2});
    }
    bool same(int x,int y){//判断是否在同一个极长连通块
        return s.lower_bound(Node{0,x})->l==s.lower_bound(Node{0,y})->l;
    }
}

using namespace DCP_2;
using namespace SET;

void ADD(int x1,int y1,int x2,int y2,int k){//差分成四个单点修改
    add(x1,y1,k);add(x2+1,y2+1,k);
    add(x1,y2+1,-k);add(x2+1,y1,-k);
}

int main(){
    scanf("%d%d",&n,&q);n++;
    scanf("%s",ch+1);
    init();
    for(int i=1;i<=n-1;i++){
        light[i]=ch[i]-'0';
        if(light[i]) merge(s.lower_bound(Node{0,i})->l,i,i+1,i+1);
        //合并初始块
    }
    for(SNI it=s.begin();it!=s.end();it++)
        ADD(it->l,it->l,it->r,it->r,q);//更新初始时间
    for(int i=1;i<=q;i++){
        scanf("%s",inp+1);
        if(inp[1]=='q'){
            scanf("%d%d",&in1,&in2);
            int ans=query(in1,in2);
            if(same(in1,in2)) ans-=q-i;//特判
            cout<<ans<<'\n';
        }
        if(inp[1]=='t'){
            scanf("%d",&in1);
            SNI it=s.lower_bound(Node{0,in1});
            int x1=it->l,x2=in1,y1=in1+1;//找到 lx,x,x+1,rx,r(x+1)
            if(light[in1]){
                int y2=it->r;
                ADD(x1,y1,x2,y2,i-q);
                split(x1,x2,y1,y2);
            }
            else{
                int y2=(++it)->r;
                ADD(x1,y1,x2,y2,q-i);
                merge(x1,x2,y1,y2);
            }
            light[in1]^=1;//更新状态
        }
    }
    return 0;
}
```

---

## 作者：zyp123456 (赞：3)

### 一、前置芝士

+ [平板电视（pb_ds）](https://blog.csdn.net/riba2534/article/details/80454602)

+ [set](http://www.360doc.com/content/17/0526/22/10408243_657567440.shtml)

+ 二维树状数组

### 二、题目解析

1. 将已经点亮的路段考虑成是一个大的连通块，则**点亮**某段路的灯就相当于**连通**两个连通块，**关上**某段路的灯就相当于**分开**两个连通块。

+ 此部分可以利用 $set$ 维护

2. 下面考虑如何计算答案

+ 构造一个 $(n+1) \times (n+1)$ 的矩阵 $c$，$c_{ij}$ 表示 $i$ 与 $j$ 站点的有多长时间是连通的。我们采用代价提前计算的方法，考虑点亮的操作，若操作在 $t$ 时刻进行，左右连通块区间分别为 $[l,x]$,$[x+1,r]$，那么将矩阵中**左下角**为 $(l,x+1)$，**右上角**为 $(x,x+1)$ 的子矩阵中所有元素的值增加 $T-t$ 即可。同理，如果要熄灭一盏灯，将那个子矩阵中的所有元素减少 $T-t$ 即可。

+ 上方明显是一个子矩阵加，单点查询。
+ ~~难道要用树状数组套权值线段树？~~ 不，作为 OI 新时代的 OIer，我们的 stl 是经过 $O_2$ 优化的！所以使用 pb_ds + 二维线段树来进行动态开点就能过啦。

### 三、代码
+ 注意请使用 pb_ds，使用 map 和 unordered_map 导致 TLE 者后果自负

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void rd(T&x) {
	x = 0;
	T f = 1;
	char ch = getchar();
	while (!isdigit(ch))f = (ch == '-') ? -1 : 1, ch = getchar();
	while (isdigit(ch))x = (x << 1) + (x << 3) + ch - '0', ch = getchar();
	x *= f;
}
inline char gc() {
	char ch = getchar();
	while (!isdigit(ch))ch = getchar();
	return ch;
}
const int M=300010;
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace __gnu_pbds;
gp_hash_table<int,int>c[M];
int n, T, a[M];
inline void add(int x,int y,int v){
	for(int i=x;i<=n+1;i+=i&-i)
		for(int j=y;j<=n+1;j+=j&-j)c[i][j]+=v;
}
inline void add(int x1,int y1,int x2,int y2,int v){
	add(x1,y1,v);
	add(x2+1,y2+1,v);
	add(x1,y2+1,-v);
	add(x2+1,y1,-v);
}
inline int ask(int x,int y){
	int res=0;
	for(int i=x;i;i-=i&-i)
		for(int j=y;j;j-=j&-j)res+=c[i][j];
	return res;
}
struct Node {
	int l, r;
	bool operator <(const Node a)const {
		return r < a.r;
	}
};
set<Node>s;
set<Node>::iterator it;
int main() {
	rd(n), rd(T);
	for (int i = 1; i <= n + 1; i++)s.insert({i, i});
	for (int i = 1; i <= n; i++) {
		char ch = gc();
		a[i] = ch - '0';
		if (a[i]) {
			it = s.lower_bound( {0, i + 1});
			it--;
			int l = it->l;
			s.erase(it);
			s.erase({i + 1, i + 1});
			s.insert({l, i + 1});
		}
	}
	for (it=s.begin();it!=s.end();++it)
		add(it->l,it->l,it->r,it->r,T);
	for (int t=1;t<=T;t++){
		char op[11];scanf("%s",op+1);
		if (op[1]=='q'){
			int x,y;rd(x),rd(y);
			int ans=ask(x,y);
			int X=s.lower_bound({0,x})->l;
			int Y=s.lower_bound({0,y})->l;
			printf("%d\n",ans-(T-t)*(X==Y));
		}
		else{
			int x;rd(x);
			if (a[x]==1){
				it=s.lower_bound({0,x});
				int l1=it->l,r1=x;
				int l2=x+1,r2=it->r;
				add(l1,l2,r1,r2,t-T);
				s.erase({l1,r2});
				s.insert({l1,r1});
				s.insert({l2,r2}); 
				a[x]^=1;
			}
			else{
				it=s.lower_bound({0,x});
				int l1=it->l,r1=x;
				it++;
				int l2=x+1,r2=it->r;
				add(l1,l2,r1,r2,T-t);
				s.erase({l1,r1});s.erase({l2,r2});
				s.insert({l1,r2}); 
				a[x]^=1;
			}
		}
	}
	return 0;
}
```


---

## 作者：pengyule (赞：2)

> $n+1$ 个点，从 $1\sim n+1$ 编号，相邻两个点之间有一条线段连接它们，$s_i(1\le i\le n)$ 表示初始时线段通断。$q$ 次操作，第 $t$ 次询问中，`toggle i` 表示切换 $s_i$ 状态，`query a b` 表示查询 $[1,t]$ 中有多少时刻满足两点 $a,b$ 之间的线段全部是通的。$n,q\le 3\times 10^5$。

考虑使用一个 `map/set` 维护每个时刻的极长连续段的左右端点二元组构成的集合，则两点 $a,b$ 连通只需要判断它们是否处在同一极长连续段中。

从连通性的角度去考虑，如果我们维护一个 $(n+1)\times(n+1)$ 的连通性矩阵 $G$ 表示 $i,j$ 是否连通。  
将 $s_x$ 0 变 1 时，会将线段两端的极长连续段合并为一，假如分别为 $[l,x],[x+1,r]$，造成的影响是 $左上(l,x+1)\sim 右下(x,r)$ 0 变 1；反之就是将矩形 1 变 0。  
那我们还是没有办法做到把时间轴融入进来。

事实上，时间轴可以作为数值的角色融入进来，将 $G_{i,j}$ 定义为**在假设后续没有修改操作的情况下** $i,j$ 两点在整个 $[1,q]$ 时间中有几个时刻是连通的。$s_x$ 0 变 1：将上述矩形同 $+(q-t)$；1 变 0：将上述矩形同 $-(q-t)$。

我们把题目化为二维数点问题：矩形修改+单点查询。为了更方便使用树套树维护，可以将矩形差分成 4 个单点修改，从而变成二位前缀和查询。使用树状数组+动态开点权值线段树在 $O(n\log^2 n)$ 的时间复杂度、$O(n\log n)$ 的空间复杂度内解决。

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=3e5+5;
int n,q,tot,a[N],rt[N];
struct node {
	int s,ls,rs;
}t[N*75];
char s[N],op[7];
void pushup(int k){
	t[k].s=t[t[k].ls].s+t[t[k].rs].s;
}
void chg(int p,int v,int l,int r,int &k){
	if(!k)k=++tot;
	if(l==r){t[k].s+=v;return;}
	int mid=l+r>>1;
	if(p<=mid)chg(p,v,l,mid,t[k].ls);
	else chg(p,v,mid+1,r,t[k].rs);
	pushup(k);
}
void add(int x,int y,int v){
	for(int i=x;i<=n+1;i+=i&-i)chg(y,v,1,n+1,rt[i]);
}
int qry(int L,int R,int l,int r,int k){
	if(L<=l&&r<=R)return t[k].s;
	int mid=l+r>>1,s=0;
	if(L<=mid)s+=qry(L,R,l,mid,t[k].ls);
	if(R>mid)s+=qry(L,R,mid+1,r,t[k].rs);
	return s;
}
int ask(int x,int y){
	int s=0;
	for(int i=x;i;i-=i&-i)s+=qry(1,y,1,n+1,rt[i]);
	return s;
}
int main(){
	scanf("%d%d%s",&n,&q,s+1);s[++n]='0';
	map<int,int>b;
	for(int i=1;i<=n+1;i++)rt[i]=++tot,b[i]=i;
	for(int i=1;i<=n;i++)if(s[i]=='1'){
		map<int,int>::iterator it=b.upper_bound(i);
		int l=prev(it)->fi,r=it->se;
		add(l,i+1,q);
		add(l,r+1,-q);
		add(i+1,i+1,-q);
		add(i+1,r+1,q);
		prev(it)->se=r;
		if(it!=b.end())b.erase(it);
	}
	for(int x,y,i=1;i<=q;i++){
		scanf("%s",op);
		if(op[0]=='q'){
			scanf("%d%d",&x,&y);
			map<int,int>::iterator u=prev(b.upper_bound(x)),v=prev(b.upper_bound(y));
			printf("%d\n",ask(x,y)-(u==v)*(q-i));
		}
		else {
			scanf("%d",&x);
			if(s[x]=='0'){
				map<int,int>::iterator it=b.upper_bound(x);
				int l=prev(it)->fi,r=it->se;
				add(l,x+1,q-i);
				add(l,r+1,i-q);
				add(x+1,x+1,i-q);
				add(x+1,r+1,q-i);
				prev(it)->se=r;
				b.erase(it);
			}
			else {
				map<int,int>::iterator it=b.upper_bound(x);
				int l=prev(it)->fi,r=prev(it)->se;
				add(l,x+1,i-q);
				add(l,r+1,q-i);
				add(x+1,x+1,q-i);
				add(x+1,r+1,i-q);
				it--;
				it->se=x;
				b[x+1]=r;
			}
			s[x]=97-s[x];
		}
	}
}
```

---

## 作者：chenxia25 (赞：2)

> ### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P5445)

>题意见洛谷。

首先考虑实时维护 $\forall i,j\in[1,n]$，目前有多少时刻满足能从 $i$ 到达 $j$。

显然，$i$ 能到达 $j$ 当且仅当 $i,j$ 在同一个亮灯连续段里。将当前状态剖成若干个极大亮灯连续段，那么能否到达关于 $i,j$ 两维的函数应该是由这些连续段，每段分别在 $i$ 轴和 $j$ 轴上作为两条邻边、$j=i$ 上的一段作为副对角线的一些充满 $1$ 的正方形组成的，其他地方都是 $0$。

那么在某一时刻的答案函数就是之前所有时刻的所对应的上述 01 函数之和。考虑实时维护这个答案函数（二维函数，即一个矩阵）。

一种很容易想到的方法是递推，每次将当前时刻的 01 函数加到当前维护的答案函数里面去。当前时刻的 01 函数显然是由上一时刻的 01 函数进行常数次矩形修改得来的（开灯就是连接两边接壤的 $1$ 矩形并补全，关灯就是从所在 $1$ 矩形断开，至于如何维护这些连续段，`set` 即可，太简单不多说），而将 01 函数加到答案函数里去又等价于对答案矩阵进行若干次（这里不是常数次了，而是连续段个数次，即 $1$ 矩形个数次）矩形增加 $1$ 。这里对 01 函数的更新显然是力所能及的，而对答案函数的更新的复杂度就没法保证了。

不难发现，这里对 01 函数的更新是若干次矩形加 $1$，其中 $1$ 是个常数，而这些矩形随时刻递增又是常数差异的，就一脸可以优化成在这些常数级别的差异上增加非常数，从而保证复杂度。

考虑一个 01 函数关于时刻的三维函数。考虑当前答案函数的每一处在这个三维函数上的意义：显然是从当前时刻断开时间轴得到的纵切面的左边的所有此处的和。这是一些 $0/1$ 的和，$0$ 显然不用考虑，剩下来就是一些 $1$ 的区间，设为 $[l_1,r_1],[l_2,r_2],\cdots,[l_k,r_k]$，那么这个和就是 $\sum\limits_{i=1}^k(r_i-l_i+1)$。考虑在一个区间开始的时候给此处贡献上 $-l_i$，在区间结束的时候给此处贡献上 $r_i+1$。此时增加量显然不是常数了，我们来看看增加次数有没有减少。区间开始和区间结束的时候，就是相邻 01 函数差异对此处影响的时候，每次时刻的递推都只有 01 函数差异的矩形量次矩形增加，哦吼，可以了。需要注意的是，若当前要查询的那处在 01 函数中为 $1$ 的话，那么第 $k$ 个区间还未结束，我们要强行令它结束，即在答案函数在此处的值的基础上再加上当前时刻。

（上面这一段重要的转化是本题的瓶颈。个人感觉这个哲学思想理解的还不是很透彻，大概以后重点做 DS 的时候题做多了感觉就上来了吧。）

接下来就是个矩形增加、单点查询的事了。看起来能够线段树套动态开点线段树，但写到一半才发现外层线段树的懒标记无法 $\mathrm O(1)$ 存储。于是想到将修改和查询范围颠倒的方式：差分。考虑二维差分，这样一次矩形增加转化为 $4$ 次单点增加，单点查询转化为前缀矩形求和。这就是个经典的二维数点模型，写一发 BIT 套动态开点线段树即可（萌新第一次写这个~~，多多关照~~）。二维数点应该是有其他方法的（如 cdq 分治），然而我还没有系统的学这一块，不管，而且这题重点不在这里。

btw，这是我第二次写 `vector` 动态开点数据结构（第一次是列队），犯了跟列队同样的错误（UB + `vector` 分配内存原理造成赋不进去值）。多错几次就不会犯了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define X first
#define Y second
const int inf=0x3f3f3f3f;
int lowbit(int x){return x&-x;}
const int N=300000;
int n,qu; 
char a[N+5];
struct segtree{//动态开点线段树 
	struct node{int lson,rson,l,r,sum;};
	#define lson(p) nd[p].lson
	#define rson(p) nd[p].rson
	#define l(p) nd[p].l
	#define r(p) nd[p].r
	#define sum(p) nd[p].sum
	vector<node> nd;
	int nwnd(int l=1,int r=n){return nd.pb(node({0,0,l,r,0})),nd.size()-1;}
	void init(){//初始化 
		nd.pb(node({0,0,0,0,0}));
		nwnd();
	}
	void add(int x,int v,int p=1){//单点增加 
		sum(p)+=v;
		if(l(p)==r(p))return;
		int mid=l(p)+r(p)>>1,res;
		if(x<=mid){
			if(!lson(p))res=nwnd(l(p),mid),lson(p)=res;
			add(x,v,lson(p));
		}
		else{
			if(!rson(p))res=nwnd(mid+1,r(p)),rson(p)=res;
			add(x,v,rson(p));
		}
	}
	int _sum(int l,int r,int p=1){//区间求和 
		if(!p)return 0; 
		if(l<=l(p)&&r>=r(p))return sum(p);
		int mid=l(p)+r(p)>>1,res=0;
		if(l<=mid)res+=_sum(l,r,lson(p));
		if(r>mid)res+=_sum(l,r,rson(p));
		return res;
	}
};
struct bitree{//BIT 
	segtree segt[N+1];
	void init(){//初始化 
		for(int i=1;i<=n;i++)segt[i].init();
	}
	void add(int x,int y,int v){
		if(y>n)return;
		while(x<=n)segt[x].add(y,v),x+=lowbit(x);
	}
	void add(int l1,int r1,int l2,int r2,int v){//矩形增加 
		add(r1+1,r2+1,v);add(l1,r2+1,-v);add(r1+1,l2,-v);add(l1,l2,v);//转化为差分数组上的单点增加 
	}
	int val(int x,int y){//单点查询 
		int res=0;
		while(x)res+=segt[x]._sum(1,y),x-=lowbit(x);//转化为差分数组上的矩形求和 
		return res;
	}
}bit;
int main(){
	cin>>n>>qu;
	scanf("%s",a+1);
	set<pair<int,int> > st;
	for(int i=1,las=0;i<=n+1;i++)
		if(a[i]=='1')las=las?las:i;
		else if(las)st.insert(mp(las,i-1)),las=0;
	bit.init();
	for(int i=1;i<=qu;i++){
		char tp[10];int x,y;
		scanf(" %s%d",tp,&x);
		if(tp[0]=='t'){
			set<pair<int,int> >::iterator fd=st.upper_bound(mp(x,inf));
			if(fd!=st.begin()&&x<=(--fd)->Y){//关灯 
				int l=fd->X,r=fd->Y;
				st.erase(fd);
				bit.add(l,r,l,r,i);
				if(l<x)st.insert(mp(l,x-1)),bit.add(l,x-1,l,x-1,-i);
				if(r>x)st.insert(mp(x+1,r)),bit.add(x+1,r,x+1,r,-i);
			}
			else{//开灯 
				fd=st.upper_bound(mp(x,inf));
				int l=x,r=x;
				if(fd!=st.begin())fd--,fd->Y==x-1?bit.add(fd->X,fd->Y,fd->X,fd->Y,i),l=fd->X,st.erase(fd++):fd++;
				if(fd!=st.end())fd->X==x+1&&(bit.add(fd->X,fd->Y,fd->X,fd->Y,i),r=fd->Y,st.erase(fd),0);
				st.insert(mp(l,r));
				bit.add(l,r,l,r,-i);
			}
		}
		else{
			scanf("%d",&y);y--;
			set<pair<int,int> >::iterator fd=st.upper_bound(mp(x,inf));
			if(fd!=st.begin()&&y<=(--fd)->Y)printf("%d\n",bit.val(x,y)+i);
			else printf("%d\n",bit.val(x,y));
		}
	}
	return 0;
}
```

---

## 作者：takanashi_mifuru (赞：2)

考虑维护一个 $(n+1)\times(n+1)$ 的布尔类型矩阵 $LTDZ$，其中 $LTDZ_{i,j}$ 表示如果保持当前状态不动直到 $m$ 次操作结束，$i$ 和 $j$ 有多少个时刻联通。

再维护两个长度为 $n$ 的数组 $L$ 和 $R$ 表示最左端到哪个点，最右端到哪个点。

这个 $L$ 数组和 $R$ 数组是很好更新的，假设 $x$ 到 $x+1$ 的路灯断开了，假设断开路灯之前 $x$ 能往左最远能走到 $lt$，$x+1$ 能往右最远走到 $rt$，中间的边断开了那么 $[x,lt]$ 里面的所有点往右都只能走到 $x$了，而 $[x+1,rt]$ 里面的所有点往左都只能走到 $x+1$ 了，这个操作反过来做就是把灯打开的操作，于是拿两棵区间赋值单点求值的线段树维护就好了。

然后我们考虑怎么维护 $LTDZ$，最开始的 $LTDZ$ 是好维护的，很明显所有可达的点都赋值为 $m$ 就可以了。

考虑修改怎么办，容易发现如果打开 $x$ 和 $x+1$ 之间的路灯，那么 $[lt,x]$ 到 $[x,rt]$ 的所有点都可达了，如果关闭则反之。

假设这是第 $i$ 次操作，那么我们就让所有新变得可达的点加上 $m-i$，表示如果他保持现在的状态一直到操作结束，就会多出 $m-i$ 个时刻这两个点可达。

如果是断掉的话我们就把他减掉 $m-i$，这个时候假设之前第 $j$ 次操作变得可达，这次变得不可达，中间的贡献差是 $(m-j)-(m-i)=m-i-m+j=j-i$，正好是两次操作之间的时间差。

于是维护 $LTDZ$ 就变成了维护矩形加单点查询，二维差分一下变成单点加矩形差分，可以直接树套树。

代码如下，我觉得还是比较可读的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			w=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*w;
}
class SegTree{ 
	public:
	int cnt=0;
	int rt[300005<<2];
	int Tree[50000005];
	int lson[50000005];
	int rson[50000005];
	void pushup(int cur){
		Tree[cur]=Tree[lson[cur]]+Tree[rson[cur]];
		return;
	}
	void update(int &cur,int lt,int rt,int Q,int val){
		if(lt>Q||rt<Q){
			return;
		}
		if(!cur)cur=++cnt;
		if(lt==rt&&lt==Q){
			Tree[cur]+=val;
			return; 
		}
		int mid=lt+rt>>1;
		update(lson[cur],lt,mid,Q,val);
		update(rson[cur],mid+1,rt,Q,val);
		pushup(cur);
		return;
	}
	int query(int cur,int lt,int rt,int qx,int qy){
		if(lt>qy||rt<qx){
			return 0;
		}
		if(!cur){
			return 0;
		}
		if(lt>=qx&&rt<=qy){
			return Tree[cur];
		}
		int mid=lt+rt>>1;
		return query(lson[cur],lt,mid,qx,qy)+query(rson[cur],mid+1,rt,qx,qy);
	}
}P;
class SegSegTree{
	public:
	void update(int cur,int lt,int rt,int Qx,int Qy,int val){
		if(lt>Qx||rt<Qx)return;
		if(lt==rt&&lt==Qx){
			P.update(P.rt[cur],1,300001,Qy,val);
			return;
		}
		int mid=lt+rt>>1;
		update(cur<<1,lt,mid,Qx,Qy,val);
		update(cur<<1|1,mid+1,rt,Qx,Qy,val);
		P.update(P.rt[cur],1,300001,Qy,val);
		return;
	}
	int query(int cur,int lt,int rt,int Ql,int Qr,int Qx,int Qy){
		if(lt>Qr||rt<Ql){
			return 0;
		}
		if(lt>=Ql&&rt<=Qr){
			return P.query(P.rt[cur],1,300001,Qx,Qy);
		}
		int mid=lt+rt>>1;
		return query(cur<<1,lt,mid,Ql,Qr,Qx,Qy)+query(cur<<1|1,mid+1,rt,Ql,Qr,Qx,Qy);
	}
}Q;
int n,m;
bool vis[300005];
void Add(int lt,int rt,int qx,int qy,int val){
	Q.update(1,1,300001,lt,qx,val);
	Q.update(1,1,300001,rt+1,qx,-val);
	Q.update(1,1,300001,lt,qy+1,-val);
	Q.update(1,1,300001,rt+1,qy+1,val);
	return;
}
class Seg{
	public:
	int Tree[300005<<2];
	int Tag[300005<<2];
	void pushup(int cur){
		Tree[cur]=Tree[cur<<1]+Tree[cur<<1|1];
		return;
	}
	void addtag(int cur,int lt,int rt,int val){
		Tag[cur]=val;
		Tree[cur]=(rt-lt+1)*val;
		return;
	}
	void pushdown(int cur,int lt,int rt){
		if(!Tag[cur])return;
		int mid=lt+rt>>1;
		addtag(cur<<1,lt,mid,Tag[cur]);
		addtag(cur<<1|1,mid+1,rt,Tag[cur]);
		Tag[cur]=0;
		return;
	}
	void update(int cur,int lt,int rt,int qx,int qy,int val){
		if(lt>qy||rt<qx){
			return;
		}
		if(lt>=qx&&rt<=qy){
			addtag(cur,lt,rt,val);
			return;
		}
		pushdown(cur,lt,rt);
		int mid=lt+rt>>1;
		update(cur<<1,lt,mid,qx,qy,val);
		update(cur<<1|1,mid+1,rt,qx,qy,val);
		pushup(cur);
		return;
	}
	int query(int cur,int lt,int rt,int Q){
		if(lt>Q||rt<Q){
			return 0;
		}
		if(lt>=Q&&rt<=Q){
			return Tree[cur];
		}
		pushdown(cur,lt,rt);
		int mid=lt+rt>>1;
		return query(cur<<1,lt,mid,Q)+query(cur<<1|1,mid+1,rt,Q);
	}
}L,R;
signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		char c;
		cin>>c;
		vis[i]=c-'0';
	}
	int len=0;
	for(int i=n+1;i>=1;i--){
		if(vis[i]==0){
			Add(i,i,i,i,m);
			len=0;
			continue;
		}
		len++;
		Add(i,i,i,i+len,m);
	}
	len=0;
	for(int i=1;i<=n+1;i++){
		int j=i;
		while(vis[j])j++;
		L.update(1,1,300001,i,j,i);
		R.update(1,1,300001,i,j,j);
		i=j;
	}
	for(int i=1;i<=m;i++){
		string opt;
		cin>>opt;
		if(opt=="query"){
			int x,y;
			x=read(),y=read();
			if(x>y)swap(x,y);
			int tmp=Q.query(1,1,300001,1,x,1,y);
			if(R.query(1,1,300001,x)>=y){
				tmp-=(m-i);
			} 
			printf("%d\n",tmp);
		}
		else{
			int x;
			x=read();
			vis[x]^=1;
			int lt=L.query(1,1,300001,x); 
			int rt=R.query(1,1,300001,x+1);
			if(vis[x]){
				L.update(1,1,300001,x+1,rt,lt);
				R.update(1,1,300001,lt,x,rt);
				Add(lt,x,x+1,rt,m-i);
			}
			else{
				L.update(1,1,300001,x+1,rt,x+1);
				R.update(1,1,300001,lt,x,x);
				Add(lt,x,x+1,rt,i-m);
			}
		}
	}
	return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：1)

## 思路

离线下来从右往左扫描线。

用 ODT 维护形如“$l$ 到 $r$ 时间最远能到达 $y$”的信息。

遇到灭灯的时间段，在这段时间里把最远到达位置改为当前扫到的位置。

把这些信息的出现与失效再离线下来，则有 $\mathcal O(n)$ 条。

查询操作应当在扫到的时候加入，形如“先前的信息中，最远到达 $\geq y$ 的时间中有多少是先于查询的时间的”。

这是三维偏序，直接上 cdq 即可。复杂度 $\mathcal O(n\log^2n)$。

为什么查询可以直接在“先前的信息”中找？因为只有中间全是亮灯，信息才能保留，否则信息会在中间灭灯的地方被删掉。

## code

ODT 常数有点大，跑得很慢。

```cpp
#include<stdio.h>
#include<vector>
#include<map>
#define pr pair<int,int> 
#define N 1048576
#define lc ((i)<<1|1)
#define rc ((i)+1<<1)
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int n,m,q,sz;char s[N];vector<int>o[N],qx[N],qt[N],id[N];
map<int,pr>mmp;long long ans[N],sum[N],lazy[N];
struct node{int tl,tr,y,x;}a[N],b[N];
inline void pd(int i,int l,int mid,int r)
{
	if(lazy[i])
	{
		sum[lc]+=lazy[i]*(mid-l+1);lazy[lc]+=lazy[i];
		sum[rc]+=lazy[i]*(r-mid);lazy[rc]+=lazy[i];
		lazy[i]=0;
	}
}
inline void upd(int i,int l,int r,int ql,int qr,int x)
{
	if(qr<l||r<ql)return;
	if(ql<=l&&r<=qr){sum[i]+=x*(r-l+1);lazy[i]+=x;return;}
	int mid=l+r>>1;pd(i,l,mid,r);
	upd(lc,l,mid,ql,qr,x);upd(rc,mid+1,r,ql,qr,x);
	sum[i]=sum[lc]+sum[rc];
}
inline long long qry(int i,int l,int r,int ql,int qr)
{
	if(qr<l||r<ql)return 0;
	if(ql<=l&&r<=qr)return sum[i];
	int mid=l+r>>1;pd(i,l,mid,r);
	return qry(lc,l,mid,ql,qr)+qry(rc,mid+1,r,ql,qr);
}
inline void cdq(int l,int r)
{
	if(l==r)return;
	int mid=l+r>>1,k=l,i=l,j=mid+1;cdq(l,mid);cdq(mid+1,r);
	for(int i=l;i<=r;b[i]=a[i],++i);
	for(;i<=mid&&j<=r;)if(b[i].y>=b[j].y)
	{
		if(~b[i].tl)upd(0,0,m,b[i].tl,b[i].tr,b[i].x);
		a[k++]=b[i++];
	}
	else
	{
		if(b[j].tl>>31)ans[b[j].x]+=qry(0,0,m,0,b[j].tr);
		a[k++]=b[j++];
	}
	for(;j<=r;a[k++]=b[j++])
		if(b[j].tl>>31)ans[b[j].x]+=qry(0,0,m,0,b[j].tr);
	for(int j=l;j<i;++j)if(~b[j].tl)upd(0,0,m,b[j].tl,b[j].tr,-b[j].x);
	for(;i<=mid;a[k++]=b[i++]);
}
main()
{
	read(n);read(m);
	for(int i=1;i<=n;o[i++].emplace_back(0))
		for(;s[i]=nc(),(s[i]^'0')&&(s[i]^'1'););
	for(int i=1,c,x,y;i<=m;++i)
	{
		for(;c=nc(),(c^'q')&&(c^'t'););
		if(c^'q')read(x),o[x].emplace_back(i);
		else read(x),read(y),qx[x].emplace_back(y),
			qt[x].emplace_back(i),id[x].emplace_back(q++);
	}
	mmp[0]=(pr){m,n+1};
	a[sz++]=(node){0,m,n+1,1};
	for(int i=n;i;--i)
	{
		o[i].emplace_back(m+1);
		for(int j=s[i]^'0';j+1<o[i].size();j+=2)
		{
			map<int,pr>::iterator it=mmp.lower_bound(o[i][j]);
			for(;it!=mmp.end()&&it->first<o[i][j+1];)
				if(it->second.first<o[i][j+1])
			{
				a[sz++]=(node){it->first,it->second.first,
					it->second.second,-1};
				it=mmp.erase(it);
			}
			else
			{
				a[sz++]=(node){it->first,o[i][j+1]-1,it->second.second,-1};
				mmp[o[i][j+1]]=it->second;mmp.erase(it);break;
			}
			it=mmp.lower_bound(o[i][j]);
			if(it!=mmp.begin())
			{
				--it;
				if(it->second.first>=o[i][j])if(it->second.first<o[i][j+1])
				{
					a[sz++]=(node){o[i][j],it->second.first,
						it->second.second,-1};
					it->second.first=o[i][j]-1;
				}
				else
				{
					a[sz++]=(node){o[i][j],o[i][j+1]-1,it->second.second,-1};
					mmp[o[i][j+1]]=it->second;
					it->second.first=o[i][j]-1;
				}
			}
			a[sz++]=(node){o[i][j],o[i][j+1]-1,i,1};
			mmp[o[i][j]]=(pr){o[i][j+1]-1,i};
		}
		for(int j=0;j<qx[i].size();++j)
			a[sz++]=(node){-1,qt[i][j]-1,qx[i][j],id[i][j]};
	}
	cdq(0,sz-1);
	for(int i=0;i<q;printf("%lld\n",ans[i++]));
}
```

---

## 作者：LJ07 (赞：1)

[LOJ 传送门](https://loj.ac/p/3146) [洛谷传送门](https://www.luogu.com.cn/problem/P5445)

这里比较建议去 LOJ 提交，因为洛谷下不了数据而且数据不全（）。

---

这里提供一个跟其他题解不太一样的做法。

令 $pre_i$ 表示 $i$ 及 $i$ 之前第一个（从后往前）的 $0$ 的位置。

对于询问 $(Query_a,Query_b,Query_T)$，发现要求的就是 $0$ 到 $Query_T$  有多少个 $pre_{Query_b}<Query_a$。

---

发现灯的状态可以拆分若干个成 $(l,r,stT,edT)$ 这样表示，表示从 $stT$ 到 $edT$ 这些时刻中 $[l,r]$ 的 $pre$ 都是 $l$。

那么每一个 $edT \le Query_T$ 且 $l\le Query_b\le r$，$pre<Query_a$（即 $pre\le Query_a-1$) 的这样表示都会对答案产生贡献 $edT-stT+1$。

发现这是一个 CDQ 分治。

上面的表示可以边读入询问使用一个 ```set<pair<int,int> >``` 和 ```ti[...]``` 维护，具体实现细节参见代码。

---

同时我们又发现还有一种 $stT\le QueryT$ 且 $edT> QueryT$ 的表示也能对答案产生贡献。

这个可以在读入答案时直接处理（因为在同一时刻，灯的状态表示的 $[l,r]$ 两两不交，所以它此时一定只会在一个表示内，这个时候我们能用 ```set``` 和 ```ti``` 算出这部分的答案）。



```cpp
#include <bits/stdc++.h>
#define GC c=getchar()
#define IG isdigit(c)
#define int long long 
#define U(i,l,r) for(int i(l),END##i(r);i<=END##i;++i)
#define D(i,r,l) for(int i(r),END##i(l);i>=END##i;--i)
template<class T>void rd(T &x=0,char GC,bool f=1)
{
    for(x=0;!IG;GC)f=c!='-';for(;IG;GC)x=x*10+(c^48);x=f?x:-x;
}
template<class A,class... B>void rd(A& x,B&... y) {rd(x),rd(y...);}
using namespace std;

typedef set<pair<int,int> >::iterator SIT;
const int N(3e5+5);
int n,q,_n,cnt,ti[N+5],pre,ans[N+5];
char s[N+5];
set<pair<int,int> >qj;
bool ask[N+5],lit[N+5];
struct Nd {int p,pr,v,id;} A[N*10+5],B[N*10+5];
bool iQry(Nd a) {return a.id;}
			
struct Bit
{
	int tr[N+5];
	void Add(int x,int y) {++x;for(;x<=_n;x+=x&-x) tr[x]+=y;}
	int Ask(int x,int y=0) {++x;for(;x;x-=x&-x) y+=tr[x]; return y;}
} bit;

void cdq(int l,int r)
{
	if(l==r) return ;
	int mid(l+r>>1);
	cdq(l,mid),cdq(mid+1,r);
	for(int i(l),j(mid+1),k(l);i<=mid||j<=r;++k)
		if(j>r||i<=mid&&A[i].pr<=A[j].pr)
		{
			if(!iQry(B[k]=A[i++])) bit.Add(B[k].p,B[k].v);
		}else if(iQry(B[k]=A[j++])) ans[B[k].id]+=bit.Ask(B[k].p);
	U(i,l,mid) if(!iQry(A[i])) bit.Add(A[i].p,-A[i].v);
	U(i,l,r) A[i]=B[i];
}

void Insert(int l,int r,int t)
{
	int dt(t-ti[l]);
	if(l!=r) A[++cnt]=Nd{l+1,l,dt,0},r<n?A[++cnt]=Nd{r+1,l,-dt,0},1:1;
	ti[l]=t;
}
signed main()
{
	rd(n,q),scanf("%s",s+1),_n=n+1;
	U(i,1,n)if(s[i]^49) qj.insert({pre,i-1}),pre=i,lit[i]=1;
	qj.insert({pre,n}),qj.insert({n+1,n+1}); //notice!!
	U(i,1,q)
	{
		char s[10];scanf("%s",s);
		if(s[0]=='t') 
		{
			int x;rd(x);SIT it; pair<int,int> t;
			if(lit[x])
			{
				it=qj.lower_bound({x,0}),Insert(it->first,it->second,i),t=*prev(it);
				qj.erase(t),Insert(t.first,t.second,i),t.second=it->second,qj.insert(t);	
				qj.erase(it),lit[x]=0;
			}
			else
			{
				it=qj.lower_bound({x,0}),t=*prev(it);
				qj.erase(t),Insert(t.first,t.second,i),t.second=x-1,qj.insert(t);
				ti[x]=i,qj.insert({x,it->first-1}),lit[x]=1;
			}
		}else 
		{
			int x,y;rd(x,y),ask[i]=1,--y;
			SIT it(prev(qj.lower_bound({y+1,0})));
			if(it->first<x) ans[i]=i-ti[it->first];
			A[++cnt]=Nd{y,x-1,0,i};
		} 
	}
	cdq(1,cnt);
	U(i,1,q)if(ask[i])printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：1)

感觉挺离谱的，现在颜色段均摊在题解区里都已经成为一个很自然的想法了（     

---------------------------------------

考虑判断一个区间 $[a,b]$ 全为 $1$ 的充要条件是存在一个极长 $1$ 颜色段 $[l,r]$ 满足 $l \leq a \leq b \leq r$。

考虑修改操作，发现无非是合并或分裂两个相邻的极长 $1$ 颜色段，所以总共产生的颜色段数量级为 $n + q$ 。           

考虑维护所有颜色段以及它们的出现时间，这个用线段树可以在 $O(n \log n)$ 的时间复杂度解决。               

现在问题转化成了按顺序给定 $m$ 个大区间依次加入集合 $S$ 中，在加入过程中会有一些询问，每次询问给出一个小区间查询 $S$ 集合里面的大区间对小区间的包含时间之和。                  


考虑用扫描线，由于任意时刻的大区间不交，将一个大区间表示为四元组 $(l,r,s,t)$ 表示大区间 $[l,r]$ 在时刻 $[s,t]$ 中出现，则在扫描线扫到 $s$ 时我们就将 $-(s-1)$ 加入，当扫到 $t$ 时我们就将 $+t$ 加入，记 $nowt$ 为现在时间，这么做是因为你计算被包含的时间是用 $nowt - (s - 1)$ 计算的，而当大区间消失时其不能继续贡献，就将 $t - nowt$ 加入，抵消后面的贡献。       

考虑当查询时至多只会有一个大区间包含查询区间，而前面所有曾包含过查询的区间都已经消失其贡献就是 $t - s + 1$，所以再维护一下当前的这个查询区间是否被一个大区间正包着就知道是否还需要再加入一个 $nowt$ 作为贡献。                    

综上，根据查询的内容，维护 $S$ 集合里面的区间就可以直接树套树实现，用线段树套平衡树即可，具体一点来说就是在区间线段树上以大区间的 $[l,r]$ 中的 $l$ 作为键值，以 $r$ 作为在平衡树上的键值，平衡树上同时维护上述中所说的信息即可。            

时间复杂度 $O(n \log ^ 2 n)$，空间复杂度 $O(n \log n)$，常数巨大跑不过分块实现的 $O(n \sqrt n\log n)$。

```cpp
/*
考虑维护 sum_i，但是感觉还是不好做
考虑 1 -> 0 就是分裂颜色段，0 -> 1 就是合并颜色段
自始至终只会有 (n + q) 个颜色段
把所有颜色段求出来后需要维护给定很多个大区间包含小区间
这个可以用树套树解决
*/
#pragma GCC optimize(2)
#include "bits/stdc++.h"
using namespace std;
const int Len = 3e5 + 5;
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void write(int x) {
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
int n,q,a[Len];
#define ls(p) p << 1 
#define rs(p) p << 1 | 1
struct Node
{
	int opt,l,r,s,t,ds;
	Node(){opt = l = r = s = t = ds = 0;}
	Node(int OPT,int L,int R,int S,int T,int DS){opt = OPT , l = L , r = R , s = S , t = T , ds = DS;}
};
bool cmp(Node x,Node y){return x.s < y.s || (x.s == y.s && x.opt < y.opt);}
vector<Node> S;
struct Seg
{
	int sum[Len << 2],flag[Len << 2],tim[Len << 2],tag[Len << 2];
	void push_up(int x){sum[x] = sum[ls(x)] + sum[rs(x)];flag[x] = (flag[ls(x)] & flag[rs(x)]);}
	void push_down(int p)
	{
		if(tag[p])
		{
			tim[ls(p)] = tim[rs(p)] = tag[ls(p)] = tag[rs(p)] = tag[p];
			tag[p] = 0;
		}
	}
	void build(int p,int l,int r)
	{
		if(l == r){sum[p] = flag[p] = a[l];tim[p] = 0;return;}
		int mid = (l + r) >> 1;
		build(ls(p) , l , mid);
		build(rs(p) , mid + 1 , r);
		push_up(p);
	}
	void update(int p,int l,int r,int idx)
	{
		if(l == r){sum[p] = (a[l] ^= 1);return;}
		push_down(p);
		int mid = (l + r) >> 1;
		if(idx <= mid) update(ls(p) , l , mid , idx);
		else update(rs(p) , mid + 1 , r , idx);
		push_up(p);
	}
	void push(int p,int l,int r,int nl,int nr,int w)
	{
		if(nl <= l && nr >= r){tim[p] = tag[p] = w;return;}
		push_down(p);
		int mid = (l + r) >> 1;
		if(nl <= mid) push(ls(p) , l , mid , nl , nr , w);
		if(nr > mid) push(rs(p) , mid + 1 , r , nl , nr , w);
	}
	int qtime(int p,int l,int r,int idx)
	{
		if(l == r) return tim[p];
		push_down(p);
		int mid = (l + r) >> 1;
		if(idx <= mid) return qtime(ls(p) , l , mid , idx);
		return qtime(rs(p) , mid + 1 , r , idx);
	}
	int query(int p,int l,int r,int nl,int nr)
	{
		if(nl <= l && nr >= r) return sum[p];
		push_down(p);
		int mid = (l + r) >> 1 , res = 0;
		if(nl <= mid) res += query(ls(p) , l , mid , nl , nr);
		if(nr > mid) res += query(rs(p) , mid + 1 , r , nl , nr);
		return res; 
	}
	int Ll(int idx)
	{
		int l = 1 , r = idx , anss = 0;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(query(1 , 1 , n , mid , idx) < idx - mid + 1) l = mid + 1;
			else anss = mid , r = mid - 1;
		}
		if(!anss) return idx + 1;
		return anss;
	}
	int Rr(int idx)
	{
		int l = idx , r = n , anss = 0;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(query(1 , 1 , n , idx , mid) < mid - idx + 1) r = mid - 1;
			else anss = mid , l = mid + 1;
		}
		if(!anss) return idx - 1;
		return anss;
	}
}S1;
char s[15];int l,r;
inline void ADD(int l,int r,int s,int t)
{	
	//printf("%d %d %d %d\n",l,r,s,t);
	S.push_back(Node(0 , l , r , s , 0 , -1));
	S.push_back(Node(0 , l , r , t , 0 , 1));
}
int tot,rt[Len << 2];
struct retr
{
	int v,num;
	retr(){v = num = 0;}
	retr(int V,int NUM){v = V , num = NUM;}
	retr operator + (const retr &Ano) const
	{return retr(v + Ano.v , num + Ano.num);}
};
struct Splayyy
{
	struct vode
	{
		int ch[2],siz,cnt,val,ff,v,sumv,num,sumn;
		vode(){ch[0] = ch[1] = siz = cnt = val = ff = v = sumv = num = sumn = 0;}
		vode(int CH0,int CH1,int SIZ,int CNT,int VAL,int FF,int V,int SUMV,int NUM,int SUMN){ch[0] = CH0 , ch[1] = CH1 , siz = SIZ , val = VAL , ff = FF , v = V , sumv = SUMV , num = NUM , sumn = SUMN;}
	};
	vode t[Len * 21];
	void push_up(int x){t[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + t[x].cnt;t[x].sumv = t[t[x].ch[0]].sumv + t[t[x].ch[1]].sumv + t[x].v;t[x].sumn = t[t[x].ch[0]].sumn + t[t[x].ch[1]].sumn + t[x].num;}
	void rotate(int x)
	{
		int y = t[x].ff , z = t[y].ff , kf = t[y].ch[1] == x , kgf = t[z].ch[1] == y;
		t[z].ch[kgf] = x;
		t[x].ff = z;
		t[y].ch[kf] = t[x].ch[kf ^ 1];
		t[t[x].ch[kf ^ 1]].ff = y;
		t[x].ch[kf ^ 1] = y;
		t[y].ff = x;
		push_up(y) , push_up(x);	
	}
	void Splay(int x,int goal,int &root)
	{
		while(t[x].ff != goal)
		{
			int y = t[x].ff , z = t[y].ff;
			if(z != goal) (t[y].ch[1] == x) ^ (t[z].ch[1] == y) ? rotate(x) : rotate(y);
			rotate(x);
		}
		if(!goal) root = x;
	}
	void insert(int x,int V,int adn,int &root)
	{
		int u = root , ff = 0;
		while(u && t[u].val != x) ff = u , u = t[u].ch[x > t[u].val];
		if(u) t[u].cnt ++ , t[u].v += V , t[u].num += adn , push_up(u);
		else
		{
			u = ++ tot;
			if(ff) t[ff].ch[x > t[ff].val] = u;
			t[u] = vode(0 , 0 , 1 , 1 , x , ff , V , V , adn , adn);
			push_up(u);
		}
		Splay(u , 0 , root);
	}
	void Find(int x,int &root)
	{
		int u = root;
		if(!u) return;
		while(t[u].ch[x > t[u].val] && t[u].val != x) u = t[u].ch[x > t[u].val];
		Splay(u , 0 , root);
	}
	int Next(int x,int f,int &root)
	{
		Find(x , root);
		int u = root;
		if((t[u].val < x && !f) || (t[u].val > x && f)) return u;
		u = t[u].ch[f];
		while(t[u].ch[f ^ 1]) u = t[u].ch[f ^ 1];
		return u;
	}
	retr askkth(int x,int id)
	{
		Find(x , rt[id]);
		//printf("%d %d %d\n",x,t[rt[id]].val,rt[id]); 
		return retr((t[rt[id]].val >= x) * t[rt[id]].v + t[t[rt[id]].ch[1]].sumv , (t[rt[id]].val >= x) * t[rt[id]].num + t[t[rt[id]].ch[1]].sumn);
	}
}Spl;
struct anoSeg
{
	retr now;
	void update(int p,int l,int r,int IDX,int idx,int v,int num)
	{
		Spl.insert(idx , v , num , rt[p]);
		if(l == r) return;
		int mid = (l + r) >> 1;
		if(IDX <= mid) update(ls(p) , l , mid , IDX , idx , v , num);
		else update(rs(p) , mid + 1 , r , IDX , idx , v , num);
	}
	retr query(int p,int l,int r,int nl,int nr,int idx)
	{
		if(nl <= l && nr >= r) return Spl.askkth(idx , p);
		int mid = (l + r) >> 1;retr res;
		if(nl <= mid) res = res + query(ls(p) , l , mid , nl , nr , idx);
		if(nr > mid) res = res + query(rs(p) , mid + 1 , r , nl , nr , idx);
		return res;
	}
}S2;
int Print[Len],OPT[Len];
char ss[Len];
int main()
{
	//freopen("12.in","r",stdin);
	//freopen("122.out","w",stdout);
	n = read() , q = read();
	scanf("%s",ss + 1);
	for(int i = 1 ; i <= n ; i ++) a[i] = ss[i] - '0';
	S1.build(1 , 1 , n);
	for(int i = 1 ; i <= q ; i ++)
	{
		scanf("%s",s);
		if(s[0] == 't')
		{
			l = read();
			S1.update(1 , 1 , n , l);
			int L = l , R = l;
			if(!a[l])
			{
				if(l != 1) L = S1.Ll(l - 1);
				if(l != n) R = S1.Rr(l + 1);
				if(L <= R) ADD(L , R , S1.qtime(1 , 1 , n , L) , i - 1);
				S1.push(1 , 1 , n , L , R , i);
			}
			else
			{
				if(l != 1) L = S1.Ll(l - 1);
				if(l != n) R = S1.Rr(l + 1);
				if(L <= l - 1) ADD(L , l - 1 , S1.qtime(1 , 1 , n , L) , i - 1);
				if(l + 1 <= R) ADD(l + 1 , R , S1.qtime(1 , 1 , n , l + 1) , i - 1);
				S1.push(1 , 1 , n , L , R , i);
			}
		}
		else
		{
			l = read() , r = read() - 1;
			OPT[i] = 1;
			S.push_back(Node(1 , l , r , i - 1 , i - 1 , 0));
		}
	}
	for(int l = 1 , r ; l <= n ; l = r + 1)//保存剩余颜色段 
	{
		if(!a[l]){r = l;continue;}
		r = S1.Rr(l + 1);
		ADD(l , r , S1.qtime(1 , 1 , n , l) , q);
	}
	sort(S.begin() , S.end() , cmp);
	for(int i = 0 ; i < S.size() ; i ++)
	{
		if(S[i].opt == 0) 
		{
			//printf("%d %d %d\n",S[i].l,S[i].r,S[i].ds);
			if(S[i].ds == -1) S2.update(1 , 1 , n , S[i].l , S[i].r , -(S[i].s - 1) , 1);//插入/删除区间操作
			else S2.update(1 , 1 , n , S[i].l , S[i].r , S[i].s , -1);
		}
		else 
		{
			retr now = S2.query(1 , 1 , n , 1 , S[i].l , S[i].r);
			//printf("%d %d %d %d\n",S[i].t + 1,now.s,now.t,now.num);
			Print[S[i].t + 1] = now.v + now.num * (S[i].t);
		}
	}
	for(int i = 1 ; i <= q ; i ++) if(OPT[i]) write(Print[i]) , putchar('\n');
	return 0;
}
```

---

## 作者：Push_Y (赞：1)

[view in Push_Y's blog](https://www.wzsyyh.ml/post/ludeng/)

## 思路
对于一段连续的能够互相到达的站点，这里不妨称它为一个**连通块**

考虑用线段树维护每一个连通块

对于一个连通块里的每一个站点，存下这个连通块的左右端点（即一个站点所能到达的最左端和最右端）

对于一次连通块改变的操作，以操作的时刻 $t$ 来记录对答案产生的贡献

- 若为插入操作，对修改的区间贡献为 $-t$

- 若为删除操作，对修改的区间贡献为 $t$

**特别的**：询问时刻如果两点是连通的，记录答案 $+t$

这样处理可以很方便的解决某两点连通的时长

考虑切换第 $k$ 个路灯的状态对 $k$ 与 $k+1$ 所在连通块的影响

- 第 $k$ 个路灯原先是亮的

    - 相当于把这个连通块以 $k$ 与 $k+1$ 之间为断点分成 2 个连通块
    
    - 具体的，在线段树中查询得到左右端点 $l$ 和 $r$，修改 $[l,k]$ 和 $[k+1,r]$ 分别为 1 个连通块

- 第 $k$ 个路灯原先是灭的

    - 相当于是将 $k$ 和 $k+1$ 所在的 2 个连通块合并成 1 个
    
    - 具体的，查询 $k$ 所能到达的左端点和 $k+1$ 所能到达的右端点，记为 $l$ 和 $r$，修改 $[l,r]$ 为 1 个连通块
    
每次操作的贡献的区间修改，可以转化为二维平面上的矩形加，于是可以用容斥的思想在矩形上差分

比如对于 $[l,k]$ 和 $[k+1,r]$ 这两个区间的一次插入操作，看做是插入 $[l,k+1]、[k,r]$ 并删除 $[l,r]、[k,k+1]$

二维的矩形加上时间这一维 => 三维数点问题
这里我用 **CDQ分治** 实现
~~由于码力太弱~~，在题解和 [阿丑](https://www.luogu.com.cn/user/364963) 神佬的帮助下完成
## CODE
```cpp
//#pragma GCC optimize("Ofast") 
#include <bits/stdc++.h>
#define int long long
#define ls x<<1
#define rs x<<1|1
using namespace std;
typedef pair<int,int> pi;

inline int gin(){
	char c=getchar();
	int s=0,f=1;
	while(c<'0' || c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=6e5+5;
char s[N];
int n,Q,tot,c[N],a[N],ans[N];
bool vis[N];

struct seg{
	pi py;
	bool tag;
} tr[N<<2];

struct node{
	int op,x,y1,y2,id,v;
} t[N],tmp[N];

void pushdown(int x){
	if(tr[x].tag){
		tr[ls].py=tr[rs].py=tr[x].py;
		tr[ls].tag=tr[rs].tag=1;
		tr[x].tag=0;
	}
}

void build(int x,int l,int r){
	if(l==r){
		tr[x].py=make_pair(l,l);
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
}

void change(int x,int l,int r,int L,int R,pi d){
	if(L<=l && r<=R){
		tr[x].py=d;
		tr[x].tag=1;
		return;
	}
	pushdown(x);
	int mid=l+r>>1;
	if(L<=mid) change(ls,l,mid,L,R,d);
	if(mid< R) change(rs,mid+1,r,L,R,d);
}

pi query(int x,int l,int r,int p){
	if(l==r) return tr[x].py;
	pushdown(x);
	int mid=l+r>>1;
	if(p<=mid) return query(ls,l,mid,p);
	else return query(rs,mid+1,r,p);
}

void upd(int x,int d){
	while(x<=n+1){
		c[x]+=d;
		x+=x&-x;
	}
}
void del(int x){
	while(x<=n+1){
		if(c[x]) c[x]=0;
		else break;
		x+=x&-x;
	}
}
int ask(int x){
	int res=0;
	while(x){
		res+=c[x];
		x-=x&-x;
	}
	return res;
}

void cdq(int l,int r) {
	if(l==r) return;
	int mid=l+r>>1,p=l,q=mid+1;
	cdq(l,mid),cdq(mid+1,r);
	for(int i=l;i<=r;i++){
		if(q>r || p<=mid && t[p].x<=t[q].x){
			tmp[i]=t[p++];
			if(tmp[i].op==2) continue;
			upd(tmp[i].y1,tmp[i].v);
			upd(tmp[i].y2+1,-tmp[i].v);
		}
		else {
			tmp[i]=t[q++];
			if(tmp[i].op==2) ans[tmp[i].id]+=ask(tmp[i].y1);
		}
	}
	for(int i=l;i<=r;i++){
		t[i]=tmp[i];
		if(t[i].op==1){
			del(tmp[i].y1);
			del(tmp[i].y2+1);
		}
	}
	return;
}

signed main(){
	n=gin(),Q=gin();
	scanf("%s",s);
	for(int i=1;i<=n;i++)
		a[i]=s[i-1]-'0';
	build(1,1,n+1);
	for(int i=1;i<=n;i++)
		if(a[i]==1 && !vis[i]){
			int j=i;
			vis[i]=1;
			while(a[j]) vis[++j]=1;
			change(1,1,n+1,i,j,make_pair(i,j));
		}
	memset(vis,0,sizeof(vis));
	int tot=0;
	for(int i=1;i<=Q;i++){
		scanf("%s",s);
		t[++tot].op=(s[0]=='t' ? 1 : 2);
		t[tot].id=i;
		if(t[tot].op==1){
			int k=gin();
			++tot, t[tot]=t[tot-1];
			if(a[k]==1){
				pi u=query(1,1,n+1,k);
				t[tot-1].x=u.first,t[tot].x=k+1;
				t[tot-1].y1=t[tot].y1=k+1,t[tot-1].y2=t[tot].y2=u.second;
				t[tot-1].v=i, t[tot].v=-i;
				change(1,1,n+1,u.first,k,make_pair(u.first,k));
				change(1,1,n+1,k+1,u.second,make_pair(k+1,u.second));
			}
			else {
				pi p1=query(1,1,n+1,k),p2=query(1,1,n+1,k+1);
				t[tot-1].x=p1.first,t[tot].x=k+1;
				t[tot-1].y1=t[tot].y1=k+1,t[tot-1].y2=t[tot].y2=p2.second;
				t[tot-1].v=-i, t[tot].v=i;
				change(1,1,n+1,p1.first,p2.second,make_pair(p1.first,p2.second));
			}
			a[k]^=1;
		}
		else {
			t[tot].x=gin(),t[tot].y1=gin();
			pi p=query(1,1,n+1,t[tot].x);
			if(p.second>=t[tot].y1)
				ans[i]+=i;
			vis[i]=1;
		}
	}
	cdq(1,tot);
	for(int i=1;i<=Q;i++)
		if(vis[i])
			printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：foreverlasting (赞：1)

[推销博客](https://foreverlasting1202.github.io/2019/08/16/APIO2019%E8%B7%AF%E7%81%AF/)

一道奇形怪状的线段树分治+线段树的奇怪题。
<!--more-->

我的思路好像有点奇怪。

拿到题目，直观的想法应该是直接维护这个序列。于是，就有了一种大暴力，考虑用树状数组维护单点修改和区间查询，然后每次暴力从$1$的时刻查询到$now$时刻，判断$sum[l,r]==r-l+1$即可，这样的复杂度是$O(n^2logn)$。

有没有其他办法呢？我想到了线段树分治。把单点修改扔到线段树上，然后询问看做是时间轴$[1,now]$的区间查询，也丢到线段树上，用线段树分治去维护。这样可不可行呢？

在开始，我以为再用个树状数组维护一下，再在递归回来的时候撤销一下就好了。然而这样子样例都过不了。冷静一分析，你会发现时间轴的区间$[1,now]$可能是若干个连续的区间拼凑成的，而这若干个区间的贡献却是不一的，不能直接当$1$算，这下就麻烦了。

正常人可能到了这里就会放弃线段树分治了，然后我却脑抽地继续坚持了下去。我们想想看一个点反转后，对于其他的贡献会是怎么样的。一些与这个点无关的区间若是满的（我们称一个区间为满的即这个区间全是$1$）则加上当前反转与上次反转的时间差。有了这个想法的那一刻，我突然想起了$ZJOI2019$的线段树，发现两道题其实有异曲同工之妙。于是这道题就有了这个奇怪的做法。

在线段树分治加入修改操作的时候，你维护一棵线段树，每个结点维护该结点所表示的区间满的时候的区间，这个东西是可以类似懒标记的想法下传的，所以是$log$级别的。在修改的时候，除了修改的这一条链以外，其他地方你再下传个当前时间减去上次修改时间的加法标记，表示又多了这么多的贡献。每个结点你再维护个$sum[rt]$表示当前节点所代表区间的$1$的数量，$su[rt]$表示历史上总共的答案，这一系列的东西都是可以在$pushup$和$pushdown$的时候维护出来的。查询操作就是正常的区间查询，然后你再利用启发式合并的思想合并所表示的区间满的时候的区间这个信息，保证这个合并过程也在了两个$log$的复杂度。总时间复杂度$O(nlog^3n)$。

~~实际上，如果想到将$(a,b)$看做二维坐标上的点对的话，不仅好写，而且复杂度更优。~~

~~以上均为口胡，有错误请指出。~~

---

## 作者：eastcloud (赞：0)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17233040.html)

## 题目描述

给你一个 01 串，有 $q$ 个时刻，每个时刻要么把一位取反，要么问你在过去的所有时刻中有多少个时刻 $a$ 和 $b-1$ 之间都为 1。

## 题目分析

观察题目，我们会发现可以把全为 1 的段看做一个连通块，如果两个位置在一个块内则可以互相到达，修改某个位置的值就相当于把两边的连通块合并或者分裂。

但是我们此时并非维护一个动态的连通块，而是需要知道所有时刻的信息，但是如果又把所有时刻遍历一遍会超时，考虑能不能用空间换时间，储存下所有时刻的信息方便维护。

容易观察到，维护一个连通块的目的无非是为了检查某两个点联不联通，那么我们可以抛弃连通块，转而维护两个点联通的时间数，这看似有些暴力，毕竟从空间复杂度上看 $n^2$ 规模就已经超标了，别急，让我们先看看题目怎么操作。

对于一个询问操作自然没什么好说的，那么对于修改操作则如先前所述是将两边连通块分裂或者合并，我们把操作更改一下，记 $l_1$，$r_1$，$l_2$，$r_2$ 分别为两边连通块的左右端点，则合并操作表示所有左端点在 $[l_1,r_1]$ 内，右端点在 $[l_2,r_2]$ 的点对以后都联通，分裂相反。

注意到受影响的点实际上在平面内构成一个矩形，而询问相当于单点求值，我们能不能把修改转化成对于矩形的修改呢？当然可以，我们把对于一个点实际有效的时间段抽出来看，它实际上可以差分成一次单点加和单点减。

记当前时刻为 $t$，只要合并时把整个矩形加上 $q-t$，分裂时减去 $q-t$ 即可，差分后可以使用 cdq 分治或者树套树解决，另外要注意的是查询时如果还联通，由于不考虑以后的时间，要将答案减去 $q-t$。

那么左右联通块如何维护呢，其实很简单，要么模仿珂朵莉树用 set 维护，要么用一颗线段树维护查询时二分即可，笔者这里使用了线段树的写法，不过细节多而且复杂度较高，还是建议使用 set 维护。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<cstring>
#define ite set<pai>::iterator
#define N 300005
using namespace std;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int tot,num,sta[N];
int a[N],rt[N];
int n,q;
struct Node{
	int ls,rs,sum;
	#define ls(x) tr[x].ls
	#define rs(x) tr[x].rs
	#define s(x) tr[x].sum
}tr[N<<8];
int query(int x,int l,int r,int L,int R){
	if(!x) return 0;
	if(L>=l && R<=r)return s(x);
	int mid=(L+R)>>1,ans=0;
	if(l<=mid) ans+=query(ls(x),l,r,L,mid);
	if(r>mid) ans+=query(rs(x),l,r,mid+1,R);
	return ans;
}
void change(int &x,int p,int L,int R,int s){
	if(!x) x=++tot;
	s(x)+=s;if(L==R) return;
	int mid=(L+R)>>1;
	if(p<=mid) change(ls(x),p,L,mid,s);
	else change(rs(x),p,mid+1,R,s);
}
int lowbit(int x){
	return x&(-x);
}
int ask(int x,int y){
	int ans=0;
	while(x){
		ans+=query(rt[x],1,y,1,n+2);
		x-=lowbit(x);
	}
	return ans;
}
void add(int x,int y,int p){
	while(x<=n){
		change(rt[x],y,1,n+2,p);
		x+=lowbit(x);
	}
}
struct no{
	int ls,rs,sum,l,r;
	#define tls(x) t2[x].ls
	#define trs(x) t2[x].rs
	#define ts(x) t2[x].sum
	#define tl(x) t2[x].l
	#define tr(x) t2[x].r
}t2[N<<2];
void build(int &x,int l,int r){
	x=++num;tl(x)=l;tr(x)=r;
	if(l==r){ts(x)=sta[l];return;}
	int mid=(l+r)>>1;
	build(tls(x),l,mid);build(trs(x),mid+1,r);
	ts(x)=ts(tls(x))+ts(trs(x));
}
void ct(int x,int p){
	if(tl(x)==tr(x)) {ts(x)=sta[tl(x)];return;}
	int mid=(tl(x)+tr(x))>>1;
	if(p<=mid) ct(tls(x),p);
	else ct(trs(x),p);
	ts(x)=ts(tls(x))+ts(trs(x));
}
int qt(int x,int l,int r){
	if(tl(x)>=l && tr(x)<=r) return ts(x);
	int mid=(tl(x)+tr(x))>>1;int ans=0;
	if(l<=mid) ans+=qt(tls(x),l,r);
	if(r>mid) ans+=qt(trs(x),l,r);
	return ans;
}
int findr(int x){
	if(x==n) return n+1;
	if(qt(1,x+1,x+1)==0) return x+1;
	int l=x+1,r=n;
	while(l<r){
		
		int mid=(l+r+1)>>1;
		if(qt(1,x+1,mid)==mid-x){
			l=mid;
		}
		else r=mid-1;
	}
	return l+1;
}
int findl(int x){
	if(x==1) return 1;
	if(qt(1,x-1,x-1)==0){
		return x;
	}
	int l=1,r=x-1;
	while(l<r){
		int mid=(l+r)>>1;
		if(qt(1,mid,x-1)==x-1-mid+1) r=mid;
		else l=mid+1;
	}
	return l;
}
void opti(int l,int r,int ll,int rr,int p){
	add(l,r,p);add(ll+1,r,-p);add(l,rr+1,-p);add(ll+1,rr+1,p);
}
int main(){
	n=read();q=read();int l,r;char ch;string s;
	for(int i=1;i<=n;i++){cin>>ch;sta[i]=ch-'0';}
	build(l,1,n);int st=0;
	for(int i=1;i<=n;i++){
		if(sta[i]==1 && sta[i-1]==0) st=i;
		if(sta[i]==1 && sta[i+1]==0){
			opti(st,st,i+1,i+1,q);
		}
	}
	for(int i=1;i<=q;i++){
		cin>>s;
		if(s=="query"){
			l=read();r=read();if(l==r){cout<<i<<endl;continue;}
			int ans=ask(l,r);
			if(qt(1,l,r-1)==(r-1-l+1)) ans+=i-q;
			cout<<ans<<endl;
		}
		else{
			l=read();
			int ll=findl(l);
			int rr=findr(l);
			if(sta[l]==0)opti(ll,l+1,l,rr,q-i);
			else opti(ll,l+1,l,rr,i-q);
			sta[l]^=1;ct(1,l);
			
		}
	}
}

```


---

## 作者：Yansuan_HCl (赞：0)

很 Educational 的题。

路灯的极长连通块是容易维护的。但是，本题的询问为 $[a,b]$ 连通的时间长度。

## I. 转换时间

我们知道，时间等于末时刻减初时刻，段时间求和等于总时间。这样，可以把时间长度转换为时刻的贡献。

## II. 计算贡献

考虑一个连通块的贡献。假设有 $[l,r]$ 的连通块在 $[t_1,t_2)$ 时刻亮着，那么所有 $[a,b]\subseteq [l,r]$ 且询问时刻在 $t_1$ 之后的的询问会被这个连通块所贡献。

**不妨把区间转化成点对**，这样**子区间**就转化为**子矩形**。通过加减**时刻**，我们可以把原问题转化为矩形加、单点查。

具体地，某个“开灯”操作将对在 $(l,l)-(r,r)$ “矩形”的询问减去当前时刻 $t$，而某个“关灯”操作将对上述“矩形”的询问加上当前时刻 $t$。这样矩形内某个位置的和就是时间。

需要注意的是，若查询时 $[a,b]$ 仍连通，则由于缺少一个关灯的标记，需要手动加上询问时刻 $T$。

可以用 CDQ 分治或树套树进行维护，时间复杂度 $\mathcal{O}(n\log^2 n)$。

---


# [APIO2020] 粉刷墙壁

## 题目背景

由于官方数据包过大，本题仅评测部分数据。

本题仅支持 C++ 系列语言，提交时**不需要**包含 `paint.h` 头文件。

如果交互库存在其他问题，请私信 mrsrz。

## 题目描述

距离上一次 Pak Dengklek 在他的家中粉刷墙壁已经过了一段时间，所以他想重新粉刷一次。他家的墙壁由 $N$ 段组成，它们从 $0$ 到 $N - 1$ 编号。本题中我们假设存在 $K$ 种不同的颜色，颜色用从 $0$ 到 $K - 1$ 的整数表示（例如，红色用 $0$ 表示, 蓝色用 $1$ 表示，以此类推）。Pak Dengklek 希望用第 $C[i]$ 种颜色来粉刷第 $i$ 段的墙壁。

为了粉刷墙壁，Pak Dengklek 雇用了一家有 $M$ 个承包商的承包商公司，承包商从 $0$ 到 $M - 1$ 编号。对 Pak Dengklek 来说不幸的是，承包商只愿意粉刷他们自己喜欢的
颜色。具体来说，第 $j$ 个承包商喜欢 $A[j]$ 种颜色，并且只想用下列颜色来粉刷墙壁：第 $B[j][0]$ 种颜色，第 $B[j][1]$ 种颜色，$\dots$，或第 $B[j][A[j] − 1]$ 种颜色。

Pak Dengklek 可以给承包商公司提出一些要求。在单个要求中，Pak Dengklek 将给出两个参数 $x$ 和 $y$， 其中 $0 \leq x < M$，$0 \leq y \leq N - M$。承包商公司将会指派第 $((x + l) \mod M)$ 个承包商粉刷第 $(y + l)$ 段墙壁，其中 $0 \leq l < M$。如果存在一个 $l$ 使
得第 $((x + l) \mod M)$ 个承包商不喜欢第 $C[y + l]$ 种颜色，那么该要求将无效。

Pak Dengklek 需要为每个要求付费，因此他想知道为了使墙壁中每个段都能用自己预期的颜色粉刷，他至少要提出多少个要求，或是确认他的预期无法达到。每一段墙壁可以被粉刷多次，但必须保证每次粉刷的颜色都是 Pak Dengklek 所预期的。

你必须实现 `minimumInstructions` 函数：

- `minimumInstructions(N, M, K, C, A, B)` - 该函数将被评测库恰好调用一次。
	- $N$：一个整数表示墙壁的段数。
	- $M$：一个整数表示承包商的数量。
	- $K$：一个整数表示颜色的种数。
	- $C$：一个长度为 $N$ 的整数序列，表示每段墙壁预期的颜色。
	- $A$：一个长度为 $M$ 的整数序列，表示承包商喜欢的颜色数。
	- $B$：一个长度为 $M$ 的每个元素为序列的序列，表示承包商喜欢的具体颜色。
	- 该函数必须返回一个整数，表示 Pak Dengklek 为了让墙壁按预期粉刷所需要提出的最小要求数；若预期无法达到则返回 $-1$。

## 说明/提示

在第一个样例中， $N = 8$，$M = 3$，$K = 5$，$C = [3, 3, 1, 3, 4, 4, 2, 2]$，$A = [3, 2, 2]$，$B = [[0, 1, 2], [2, 3], [3, 4]]$。Pak Dengklek 可以提出下列的要求。

1. $x = 1$，$y = 0$。这是一个有效的要求，第一个承包商可以粉刷第零段墙壁，第二个承包商可以粉刷第一段墙壁，第零个承包商可以粉刷第二段墙壁。
2. $x = 0$，$y = 2$。 这是一个有效的要求，第零个承包商可以粉刷第二段墙壁，第一个承包商可以粉刷第三段墙壁，第二个承包商可以粉刷第四段墙壁。
3. $x = 2$，$y = 5$。 这是一个有效的要求，第二个承包商可以粉刷第五段墙壁，第零个承包商可以粉刷第六段墙壁，第一个承包商可以粉刷第七段墙壁。

容易看出 Pak Dengklek 不能用少于 $3$ 个的要求来达到预期，因此 `minimumInstructions(8, 3, 5, [3, 3, 1, 3, 4, 4, 2, 2], [3, 2, 2], [[0, 1, 2], [2, 3], [3,
4]])` 应该返回 $3$。

在第二个样例中，$N = 5$，$M = 4$，$K = 4$，$C = [1, 0, 1, 2, 2]$，$A = [2, 1, 1, 1]$，$B =
[[0, 1], [1], [2], [3]]$。由于第三个承包商只喜欢第 $3$ 种颜色但没有任何一段墙壁能被该颜色粉刷，Pak Dengklek 无法给出任何有效指令。因此`minimumInstructions(5, 4, 4,[1, 0, 1, 2, 2], [2, 1, 1, 1], [[0, 1], [1], [2], [3]])` 应该返回 $-1$。

对于 $0 \leq k < K$, 令 $f(k)$ 表示喜欢第 $k$ 种颜色的承包商数量。

【条件限制】

- $1 \leq N \leq 100 000$。
- $1 \leq M \leq \min(N, 50 000)$。
- $1 \leq K \leq 100 000$。
- $0 \leq C[i] < K$。
- $1 \leq A[j] \leq K$。
- $0 \leq B[j][0] < B[j][1] < \dots < B[j][A[j] − 1] < K$。
- $\sum f(k)^2 \leq 400 000$。

【子任务 $1$（$12$ 分）】

- $f(k) \leq 1$。

【子任务 $2$（$15$ 分）】

- $N \leq 500$。
- $M \leq \min(N, 200)$。
- $\sum f(k)^2 \leq 1 000$。

【子任务 $3$（$13$ 分）】

- $N \leq 500$。
- $M \leq \min(N, 200)$。

【子任务 $4$（$23$ 分）】

- $N \leq 20 000$。
- $M \leq \min(N, 2 000)$。

【子任务 $5$（$37$ 分）】

- 无附加限制。

## 样例 #1

### 输入

```
8 3 5
3 3 1 3 4 4 2 2
3 0 1 2
2 2 3
2 3 4
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5 4 4
1 0 1 2 2
2 0 1
1 1
1 2
1 3
```

### 输出

```
-1
```

# 题解

## 作者：ethan_zhou (赞：11)

(本题解在博客页面显示正常)

> 注：本题解详细讲解了各部分分的得法以及对于正解的启发

## 问题转化

理解题意之后我们不难发现，只要我们能算出是否有以 i 块墙壁开始，刷 M 块墙的合法请求，那么这就转化成了一个区间覆盖问题。

> 比如：
> 样例1中，x=1，y=0 是一个合法请求，那么 [0,M-1] 就是一个合法区间（即：一次请求就可以覆盖这个区间）

找出这些区间之后，就可以做一个简单的贪心了，贪心代码如下：

```cpp
/* 
 * canpaint[i]表示有没有从第i块开始的合法区间
 * lastr表示目前匹配到的右端点
 * newl表示下一个合法区间的左端点
 */
int lastr=-1,newl=0,ans=0;
while(lastr<N-1){
	int mxl=-1;
	while(newl<=lastr+1 && newl<N){
		if(canpaint[newl])mxl=newl;
		newl++;
	}
	if(mxl==-1)return -1;
	lastr=mxl+M-1;
	ans++;
}
```

## 预处理

但是，我们做完了吗？并没有。这题的不好搞的地方在于 canpaint 数组的预处理。

### 28分

NM^2 的暴力，枚举每个 x 和 y，并暴力匹配，能得到第二组和第三组的分数，代码过于简单，略。

### 51分
写一个dp，令 f[i][j] 表示从第 j 个商家，第i块墙壁开始匹配，最多能刷几块墙，则其转移如下

$$
f[i][j]=\left\{
\begin{aligned} 
&0&（第j个商家不能刷第i个墙）\\
&f[i+1][(j+1)mod M]&（第j个商家能刷第i个墙）
\end{aligned}  \right. 
$$

但是 NM 的空间显然是存不下的，所以你需要将i那一维滚动掉，最终的时间复杂的也是 NM。

> 注：这里必须使用滚动数组，而不能使用其他方法，否则将无法保证后效性，因为这里的转移模了 M。

### 63分
观察数据特点：f(k)<1，我们可以利用这点来优化我们的dp，即：在转移时只转移喜欢 C[i] 这个颜色的那个商家即可，这个思路也给正解打下了基础，但至于加了这个优化之后，滚动时怎么清零之前计算的结果，待会会说。

### 100分
再看整体的数据范围，发现 f(k) 还是很小，所以我用一个 vector 数组 like[i] 表示喜欢第 i 种颜色的商家编号，转移如下：

$$
f[i][j]=f[i+1][(j+1)modM](j \in like[C[i]])
$$

代码如下
```cpp
for(int i=0;i<M;i++)
	for(int j=0;j<A[i];j++)
		like[B[i][j]].push_back(i);
for(int l=N-1;~l;l--){
	/*
	 * 每次使用like[l&1]这一行，就可以不用重新赋值
	 * 由于上次使用like[l&1]这一行是在l=l+2是
	 * 所以需要清除like[l&1][k]，当且仅当k在like[C[l+2]]中
	 */
	int tlsize=like[C[l+2]].size();
	for(int i=0;i<tlsize;i++)
		mxl[l&1][like[C[l+2]][i]]=0;
	//lsize表示喜欢当前墙壁颜色的公司数量
	int lsize=like[C[l]].size();
	for(int i=0;i<lsize;i++){
		//curc表示当前公司
		int curc=like[C[l]][i];
		mxl[l&1][curc]=mxl[!(l&1)][(curc+1)%M]+1;
		if(mxl[l&1][curc]>=M)canpaint[l]=1;
	}
}
```


---

## 作者：syksykCCC (赞：4)

APIO 打铁选手开始补题了 /ll

本文下标从 $0$ 开始，和题面相同。

标记简介：$\vee$ 可以理解为**或**，$\wedge$ 可以理解为**与**，$|S|$ 表示**集合 $S$ 的大小**，$[x]$ 可以表示为表达式 $x$ 是 true/fase。

## Subtask 2, 3

首先遍历一遍 $B$，统计出每种颜色有哪些承包商喜欢，$F_{i}$ 表示喜欢颜色 $i$ 的承包商编号集合。$|F_i|$ 即题目中的 $f(i)$。

用一个数组 $P_i = 0/1$ 表示是否可以以 $i$ 为起点，进行一次粉刷。

求 $P_i$ 的方式很简单：

$$ P_i = \bigvee_{j=0}^{M-1} \left( \bigwedge_{k=i}^{i+M-1} \left( \left(j+(k-i) \right) \bmod M \right) \in F_{C_k} \right) $$

可以理解为，对于位置 $i$，枚举它由哪个承包商 $j$ 刷，那么显然 $j$ 一旦决定，$[i, i+M-1]$ 需要哪个承包商粉刷就确定了，检验是否满足条件即可。对于位置 $i$，只要**有一个 $j$ 满足条件，$P_i$ 就等于 $1$**。

这部分时间复杂度为 $O(N \times M^2)$。

那么 $P$ 已经求出来了，该如何求答案呢？

不难想到一个简单的贪心：

1. 该位置 $i$ 已经染过色，则不操作；
2. 该位置 $i$ 尚未染色，则在 $[i-M+1, i]$ 中找到**最后一个** $P_x = 1$ 的，以 $x$ 为起点染色，答案加 $1$，将 $[x, x + M - 1]$ 标记为染过色；如果找不到，返回 $-1$。

那么显然贪心部分可以 $O(N \times M)$ 解决。

## Subtask 1

这个部分分很显然，但是和正解却有十分重要的关系。

既然 $|F_k| \le 1$，那么是不是其实我们：每个位置的墙壁，只能有唯一固定的承包商来粉刷。不妨将粉刷 $i$ 位置的承包商编号（也就是 $F_{C_i}$ 当中唯一的元素）记为 $D_i$。

我们设置一个 $Q$ 数组，$Q_i$ 表示，从 $i$ 位置开始粉刷，最远可以粉刷到哪里。即：

$ Q_i = \max pos \text{ s.t. } \forall i \le x \le pos, D_x = (D_i+(x-i)) \bmod M $

$Q_i$ 可以**逆序递推**求得：

$$ Q_i = \begin{cases} i & (i=N-1 \vee D_{i+1} \ne (D_i + 1) \bmod M) \\ Q_{i+1} & (\text{otherwise}) \end{cases} $$

$O(N)$ 就能求！

那么，这个 $Q$ 和 $P$ 有什么关系呢？很显然，$P_i = [Q_i - i \ge M-1]$（也就是从 $i$ 开始可以往后再刷 $M-1$ 格，加上 $i$ 就是 $M$ 格）

但是，似乎贪心的复杂度还不足以通过，尝试优化。显然，任何时刻，我们所粉刷过的墙壁都是一个前缀，那么可以记为一个变量 $far$，表示 $[0, far]$ 已经染过色。同时记录 $last_1$ 表示在 $[1, i]$ 中最后一个 $P=1$ 的位置，那么上面的贪心过程可以描述为：

* 如果 $P_i = 1$，$last_1 \gets i$；
* $i \le far$，不操作；
* 否则，在 $last_1$ 处操作，即 $far \gets last_1 + M-1$；
* 如果操作后 $far$ 依然 $< i$，返回 $-1$。

贪心就是 $O(N)$ 了。

## Subtask 4

$f(k)$ 增大，显然无法再 $O(N)$ 求得 $P$，尝试改造上面的算法。

$Q_{i, j}$ 表示从 $i$ 位置开始，让承包商 $j$ 粉刷 $i$ 位置，最远可以刷到哪里。

同样，可以 $O(N \times M)$ 逆序递推：

$$ Q_{i, j} = \begin{cases} -\infty & (j \not \in F_{C_i}) \\ i & \left(j \in F_{C_i} \wedge (i=N-1 \vee (j+1) \bmod M \not \in F_{C_{i+1}}\right) \\ Q_{i+1, (j+1)\bmod M} & (\text{otherwise}) \end{cases} $$

$P_i = \bigvee_{j=0}^{M-1} [Q_{i, j} - i \ge M - 1]$，贪心不变。

## Subtask 5

$\sum f(k)^2 \le 4 \times 10^5$ 的条件还没用，这个条件说明，$f(k) \le \sqrt{\sum f(k)^2} \le 700$（而且远低于这个上界）。

优化一下求 $Q$ 的过程：显然，我们只需要求出 $Q \ge 0$ 的那些。这也就是说，并不是所有的 $0 \le j < M$ 都需要求 $Q_{i, j}$，只要求 $j \in F_{C_i}$ 的那些就行了。

大概需要一下滚动数组防止空间爆炸，时间复杂度 $O(N \times \sum f(k))$。

值得一提的是，滚动数组清空时不能使用 `memset`，因为这会造成大量无用清空，一个比较好的方法是新建一个 $\text{vis}$ 数组，$\text{vis}_{c}$ 表示最后一次使用 $c$ 这种颜色时 $i$ 为多少，那么对于 $\text{vis}_{(j+1)\bmod M} \ne i+1$ 的那些 $Q_{i+1, (j+1)\bmod M}$，就可以认为它是 $-\infty$ 了，显然不能从那里转移。可以看代码辅助理解。

```cpp
#include "paint.h"
#include <cstring>
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <string>
#include <vector>
using namespace std;
const int MAXN = 100005, MAXM = 50005;
int Q[2][MAXM], vis[MAXM], last1, far, ans;
bool P[MAXN];
vector<int> F[MAXN];
int minimumInstructions(int N, int M, int K, vector<int> C, 
    vector<int> A, vector<vector<int> > B)
{
    for(int i = 0; i < M; i++)
        for(int j = 0; j < A[i]; j++)
            F[B[i][j]].push_back(i);
    for(int i = 0; i < K; i++)
        sort(F[i].begin(), F[i].end());
    for(int i = N - 1; i >= 0; i--)
    {
        for(int j : F[C[i]])
        {
            if(i == N - 1) Q[i & 1][j] = N - 1;
            else if(vis[(j + 1) % M] == i + 1) Q[i & 1][j] = Q[i & 1 ^ 1][(j + 1) % M];
            else Q[i & 1][j] = i;
            P[i] |= Q[i & 1][j] - i >= M - 1;
        }
        for(int j : F[C[i]]) vis[j] = i;
    }
    far = last1 = -1;
    for(int i = 0; i < N; i++)
    {
        if(P[i]) last1 = max(last1, i);
        if(i <= far) continue;
        ans++;
        if(last1 != -1) far = last1 + M - 1;
        if(far < i) return -1;
    }
    return ans;
}
```

---

## 作者：szh_AK_all (赞：3)

### 分析
显然，这是一道动态规划题目。设 $f_{i,j}$ 表示由第 $j$ 个承包商来刷第 $i$ 段墙，最多能往后再刷多少段墙。考虑如何转移。

既然是从第 $j$ 个承包商开始刷，那么下一段墙，也就是第 $i+1$ 段墙，便应该由第 $j$ 个承包商的下一位承包商来刷，也就是 $f_{i,j}=f_{i+1,nxt_j}+1$，其中 $nxt_j$ 表示第 $j$ 个承包商的下一位承包商，当 $j<m$ 时，$nxt_j=j+1$；当 $j=m$ 时，$nxt_j=1$。

再考虑一些细节：

- $f_{i,j}$ 有意义当且仅当第 $j$ 个承包商可以刷第 $i$ 段墙，所以在枚举 $j$ 时，只需枚举可以刷第 $i$ 段墙的承包商。
- 由于 $f_{i,j}$ 是由 $f_{i+1,nxt_j}$ 转移而来的，所以 $i$ 应该从大到小枚举。
- $N\times M$ 的空间会爆掉，所以使用滚动数组。
- 最后计算最少要求数时，可以转换为拼接线段的模型，每次尽量拼接上可以拼接的最远的线段。并且，拼接的开头位置为 $N-(M-1)=N-M+1$。因为从第 $x$ 个位置开始，可以到达第 $x+M-1$ 个位置。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[400005];
int f[2][400005];
vector<int>c[400005];
int p[400005];
vector<int>k[400005];

int minimumInstructions(int N, int M, int K, vector <int> C, vector <int> A, vector <vector <int> > B) {
	for (int i = 1; i <= N; i++)
		a[i] = C[i - 1] + 1;
	for (int i = 1; i <= M; i++)//c[x]记录第x种颜色可以由哪些承包商来刷
		for (int j = 0; j < (int)B[i - 1].size(); j++)
			c[B[i - 1][j] + 1].push_back(i);
	for (int i = 1; i <= N; i++)
		k[i] = c[a[i]];//k[x]记录第x段墙可以由哪些承包商来刷
	for (int i = N; i >= 1; i--) {
		for (int j = 0; j < (int)k[i].size(); j++) {
			int x = k[i][j] + 1;//下一个承包商
			if (x > M)//第M个承包商的下一个承包商为第1个承包商
				x = 1;
			f[i & 1][k[i][j]] = f[1 - (i & 1)][x] + 1;//f[i][j]=f[i+1][j+1]+1
			if (f[i & 1][k[i][j]] >= M)//刷的格子数>=M，代表这段可行
				p[i] = 1;
		}
		for (int j = 0; j < (int)k[i + 1].size(); j++)//滚动数组
			f[1 - (i & 1)][k[i + 1][j]] = 0;
	}
	int ans = 0;
	for (int i = N - M + 1; i >= 1; i--) {
		if (!p[i])
			return -1;
		ans++;
		for (int j = max(i - M, 1); j < i; j++) {
			if (p[j]) {//接到哪一段
				i = j + 1;
				break;
			}
		}
	}
	return ans;
}
```

---

## 作者：duyi (赞：3)

# LOJ3345 「APIO2020」粉刷墙壁

以下下标（包括颜色编号、位置编号和承包商的编号）全部从$1$开始。

---

首先，问题相当于我们要求出一个长度为$n-m+1$的数组$\text{canPaint}[1\dots n-m+1]$，表示以每个位置开始（也就是作为题目里的$y$），是否可以进行一段合法的染色。求出这个数组后，我们很容易用贪心或单调队列优化DP求出答案。

这里介绍一种用单调队列优化DP求出答案的方法。设$dp[i]$表示恰好把$1\dots i$全部涂好的最小代价。如果$\text{canPaint}[i-m+1]=\text{false}$，则$dp[i]=\inf$。否则，$dp[i]=\min_{j=i-m}^{i-1}\{dp[j]+1\}$。用单调队列维护这个长度为$m$的“滑动窗口”即可。

---

现在问题主要就是求这个$\text{canPaint}[1\dots n-m+1]$数组。

朴素的做法是枚举$i$，再枚举第一个承包商的位置$j$ ($i\leq j\leq i+m-1$)，再暴力检查是否每个承包商都喜欢他对应的颜色。判断一个承包商$a$是否喜欢$b$，可以用某些位运算技巧做到$O(1)$实现。总时间复杂度$O(nm^2)$。

---

优化。发现枚举了$i,j$以后，当前的染色方案合法，相当于从$j-1$到$i$这些颜色，依次被承包商$m,m-1,m-2,\dots,m-(j-i)+1$喜欢；并且从$j$到$j+(m-(j-i))-1$这些颜色，依次被承包商$1,2,\dots,m-(j-i)$喜欢。我们预处理出每个$j$向左，最多连续能被多少承包商喜欢，记为$L[j]$；每个$j$向右最多连续能被多少承包商喜欢，记为$R[j]$。

则$\text{canPaint}[i]=\text{true}$当且仅当存在一个$j$ ($i\leq j\leq i+m-1$) 满足$L[j-1]\geq j-i$且$R[j]\geq m-(j-i)$。

如果暴力预处理$L,R$，再对每个$i$暴力枚举$j$，则时间复杂度$O(nm)$。

---

发现我们始终没有用到$\sum f(k)^2\leq 4\times10^5$这个性质。

这个$\sum$太诡异了，为了拆掉它，我们不妨先放宽条件，变成$\max\{f(k)^2\}\leq 4\times 10^5$，即$\max\{f(k)\}^2\leq 4\times10^5$，即$\max\{f(k)\}= \sqrt{\max\{f(k)\}^2}\leq 632$。

把$\sum$换成$\max$，虽然看起来我们亏了，但至少得到一个可以利用的条件：$f(k)\leq 632$。这就告诉我们，一个$\sum_{i=1}^{n}f(c_i)$的复杂度，不会超过$n\times 632$，是可以接受的。

我们利用这一点，来优化“暴力预处理$L,R$”。

以预处理$R$为例。从左到右扫描，对每个位置$i$，维护一个集合（其实就是个$\texttt{vector}$），表示从承包商$1$开始连续的若干个承包商，分别刷对应的位置，以当前位置为结尾，可能的数量（也就是这个“若干”可能是几，把所有可能的值都存在$\texttt{vector}$里）。因为是从$1$开始，所以这个“数量”，就等于“刷当前位置的承包商的编号”。

显然这个集合大小的上限，就是“能刷$c_i$的承包商”数量，不超过$632$。但并不是每个“能刷$c_i$的承包商”都会出现在集合里。具体来说，一个承包商$x$，要出现在集合里，必须满足：(1)它能刷$c_i$；(2)$x-1$出现在了前一个位置的集合里。

求出当前位置的集合后，我们枚举集合里每个元素$x$，令$R[i-x+1]$对$x$取$\max$。

这样就能求出所有的$R$。复杂度$O(\sum_{i=1}^{n}f(c_i))\leq O(n\times\max\{f(k)\})$，时间上可以接受，空间上需要用滚动数组优化。同理，从右往左扫描一遍，可以求出$L$。

求出$L,R$后，枚举$j$。发现对当前$j$来说，满足条件的$i$，一定是一段连续的区间：即$[j-L[j-1],j+R[j]-m]$。要把这段区间的$\text{canPaint}$设为$\text{true}$，相当于做一个区间覆盖。用差分实现即可，这部分复杂度$O(n)$。

最后做那个单调队列优化DP，复杂度也是$O(n)$。

总时间复杂度$O(n\times \max\{f(k)\})$，其中$\max\{f(k)\}\leq 632$。

参考代码：

```cpp
//problem:LOJ3345
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN=1e5,MAXM=4e4,MAXK=1e5;
const int INF=1e9;
int n,m,K,c[MAXN+5];
vector<int> col_liker[MAXK+5];
vector<int> good_len[2];
bool good[MAXK+5];

int go_left[MAXN+5],go_right[MAXN+5];
int can_paint[MAXN+5];
int dp[MAXN+5],que[MAXN+5],ql,qr;

int main() {
	cin>>n>>m>>K;
	for(int i=1;i<=n;++i){
		cin>>c[i]; ++c[i];
	}
	for(int i=1;i<=m;++i){
		int sz; cin>>sz;
		for(int j=1;j<=sz;++j){
			int col; cin>>col; ++col;
			col_liker[col].push_back(i);
		}
	}
	vector<int>(1,0).swap(good_len[0]);
	for(int i=1;i<=n;++i){
		int cur=(i&1);
		int lst=(cur^1);
		vector<int>(1,0).swap(good_len[cur]);
		for(int j=0;j<SZ(col_liker[c[i]]);++j){
			int man=col_liker[c[i]][j];
			good[man]=1;
		}
		for(int j=0;j<SZ(good_len[lst]);++j){
			int len=good_len[lst][j];
			if(len==m) continue;
			if(good[len+1]){
				good_len[cur].push_back(len+1);
				assert(len+1<=i);
				ckmax(go_right[i-len], len+1);
			}
		}
		for(int j=0;j<SZ(col_liker[c[i]]);++j){
			int man=col_liker[c[i]][j];
			good[man]=0;
		}
	}
	vector<int>(1,0).swap(good_len[0]);
	vector<int>(1,0).swap(good_len[1]);
	for(int i=n;i>=1;--i){
		int cur=(i&1);
		int lst=(cur^1);
		vector<int>(1,0).swap(good_len[cur]);
		for(int j=0;j<SZ(col_liker[c[i]]);++j){
			int man=col_liker[c[i]][j];
			good[man]=1;
		}
		for(int j=0;j<SZ(good_len[lst]);++j){
			int len=good_len[lst][j];
			if(len==m) continue;
			if(good[m-len]){
				good_len[cur].push_back(len+1);
				assert(i+len<=n);
				ckmax(go_left[i+len], len+1);
			}
		}
		for(int j=0;j<SZ(col_liker[c[i]]);++j){
			int man=col_liker[c[i]][j];
			good[man]=0;
		}
	}
	for(int i=1;i<=n;++i){
		if(go_left[i-1]+go_right[i]>=m){
			int l=i-go_left[i-1];
			int r=i+go_right[i]-m;
			assert(l<=r);
			can_paint[l]++;
			if(r+1<=n-m+1)
				can_paint[r+1]--;
		}
	}
	for(int i=1;i<=n-m+1;++i){
		can_paint[i]+=can_paint[i-1];
	}
	for(int i=1;i<=n;++i)
		cerr<<can_paint[i]<<" ";
	cerr<<endl;
	
	for(int i=1;i<=n;++i)
		dp[i]=INF;
	dp[0]=0;
	que[ql=qr=1]=0;
	for(int i=m;i<=n;++i){
		if(can_paint[i-m+1]){
			while(ql<=qr && que[ql]<i-m) ql++;
			if(ql<=qr){
				dp[i]=dp[que[ql]]+1;
				while(ql<=qr && dp[que[qr]]>=dp[i]) qr--;
				que[++qr]=i;
			}
		}
	}
	if(dp[n]==INF)
		cout<<-1<<endl;
	else
		cout<<dp[n]<<endl;
	return 0;
}
```





---

## 作者：Priori_Incantatem (赞：2)

[P6764 [APIO2020]粉刷墙壁](https://www.luogu.com.cn/problem/P6764)

VP的时候打满了63分，没想到正解竟是两个暴力的合体/dk

首先，在这里定义粉刷匠的下家关系：  
对于粉刷匠 $i,j$，如果 $i+1=j$ 或者 $i=m,j=1$，则称 $j$ 是 $i$ 的下家

### 6分：$f(k)\le 1$
可以发现，对于每一次操作，要么所有的粉刷匠都刷一格，要么都不刷。所以，我们尝试对于每一格，是否存在一种粉刷顺序使得可以刷完后面的 $m$ 格。

设 $f_i$ 表示从第  $i$ 格开始刷最多可以往后刷多远（包括第 $i$ 格）  
转移方程：$f_i=f_{i+1}+1$  
如果 $i+1$ 不是 $i$ 的下家，则 $f_i=1$

时间复杂度 $\mathcal O(n)$

### 51分
上一档部分分考虑的是每个格子只能由一个粉刷匠刷，现在我们考虑把问题扩展到多个粉刷匠

设 $f_{i,j}$ 表示位置 $i$ 由编号为 $j$ 的粉刷匠来刷，最多可以往后刷多少格（包括第 $i$ 格）

转移方程：$f_{i,j}=f_{i+1,k}$，这里 $k$ 为 $j$ 的下家
如果粉刷匠 $j$ 不能刷第 $i$ 格，则 $f_{i,j}=0$

时空复杂度 $\mathcal O(nm)$

### 100分

观察上面51分的做法，可以发现他进行了许多冗余的操作：  
对于位置 $i$，所有不能刷第 $i$ 格的粉刷匠都被访问了一遍。

那么，我们可以预处理出每个位置可能被哪些粉刷匠刷，并且在转移时只转移可以刷第 $i$ 格的粉刷匠
这样，时间复杂度就变成了 $\mathcal O(\sum f(k))$  
注意这里的空间也也需要优化，可以使用滚动数组或者用 `map` 优化掉后一维，代码中采用的是后者

```cpp
#include <vector>
#include<map>
using namespace std;
const int Maxn=1e5+10;
map <int,int> f[Maxn];
vector <int> c[Maxn],b[Maxn];
int a[Maxn];
bool flag[Maxn];
int n,m,k;
int minimumInstructions(
    int N, int M, int K, std::vector<int> C,
    std::vector<int> A, std::vector<std::vector<int>> B)
{
	n=N,m=M,k=K;
	for(int i=1;i<=n;++i)
	a[i]=C[i-1]+1;
	for(int i=1;i<=m;++i)
	{
		int tmp=A[i-1];
		for(int j=0;j<tmp;++j)
		b[B[i-1][j]+1].push_back(i);
	}
	for(int i=1;i<=n;++i)
	c[i]=b[a[i]];
	for(int i=n;i;--i)
	for(int j=0;j<c[i].size();++j)
	{
		int x=c[i][j];
		int y=c[i][j]+1;
		if(y>m)y=1;
		f[i][x]=1;
		if(i+1<=n)f[i][x]=f[i+1][y]+1;
		f[i][x]=min(f[i][x],m);
		if(f[i][x]==m)flag[i]=1;
	}
	int ret=0;
	for(int i=n-m+1;i;--i)
	{
		if(!flag[i])return -1;
		++ret;
		if(i==1)break;
		int tmp=max(i-m,1);
		for(int j=tmp;j<i;++j)
		if(flag[j] || j==i-1){i=j+1;break;}
	}
	return ret;
}
```

---

## 作者：tommymio (赞：2)

题面有点长，但仔细读题后我们会发现，每次操作事实上是选择一段长度为 $M$ 的区间 $[Y,Y+M-1]$，再选择初始承包商 $X$。如果能够判断 $X$ 点能否延伸出一个长度为 $M$ 的区间，那么这个问题就变成了经典的区间覆盖问题：使用最少线段覆盖 $[0,N)$。

记 $b_i$ 为是否存在合法区间 $[i,i+M-1]$，更为具体的说，是否存在一个 $X$ 使得方案 $(X,Y)$ 合法。现在问题转变为快速求出 $b$。直接求时间复杂度会退化为 $O(nm^2)$，考虑判定转最优。设 $f[i,j]$ 为第 $i$ 段墙选择了第 $j$ 家承包商，所能粉刷的最长合法区间长度，则有：

$$
\begin{cases}
f[i,j]\leftarrow \max{f[i+1,(j+1)\bmod m]+1},\text{if }\exists b_{j,k}=c_i
\\
f[i,j]\leftarrow 0,\text{if }\nexists b_{j,k}=c_i
\end{cases}
$$

空间复杂度和时间复杂度均为 $O(nm)$。先考虑优化掉空间复杂度，使用滚动数组。再考虑优化时间复杂度，我们注意到对于 $f[i,j]\leftarrow 0$ 的部分，其实没啥意义，所以考虑不更新这些 $f[i,j]$，而是只更新 $\exists b_{j,k}=c_i$ 的那些 $f[i,j]$，这样总时间复杂度就是 $O(n\sqrt{\sum f(k)^2}+\sum f(k)+N)$ 的了，但是根本跑不满啊（逃

```cpp
#include "paint.h"
#include<cstdio>
#include<vector>
std::vector<int> clr[100005];
int f[2][100005],g[100005];
inline int max(const int &x,const int &y) {return x>y? x:y;}
int minimumInstructions(
    int N, int M, int K, std::vector<int> C,
    std::vector<int> A, std::vector<std::vector<int> > B) {
    for(register int i=0;i<M;++i) {
    	for(register int j=0;j<A[i];++j) {
    		clr[B[i][j]].push_back(i);
		}
	}
	for(register int i=0;i<M;++i) f[N&1][i]=0;
	for(register int i=N-1;i>=0;--i) {
		int cur=i&1,mx=0;
		if(i+2<=N-1) for(register int j=0;j<clr[C[i+2]].size();++j) f[cur][clr[C[i+2]][j]]=0;
		for(register int j=0;j<clr[C[i]].size();++j) {
			int x=clr[C[i]][j];
			f[cur][x]=max(f[cur][x],f[cur^1][(x+1)%M]+1);
			mx=max(mx,f[cur][x]);
		}
		g[i]=(mx>=M? mx:-1);
	}
	int L=0,R=0,res=0;
	while(R<=N-1) {
		int mxR=-1;
		while(L<=R) {
			if(g[L]!=-1&&L+M-1>=R) mxR=max(mxR,L+M); 
			++L;
		}
		if(mxR==-1) return -1;
		R=mxR; ++res;
	}
	return res;
}
```



---

## 作者：gznpp (赞：2)

题意比较复杂，这里就不写了。$N, M, K$ 变量较多，写代码的时候一定要注意别弄混了。

我们倒着来看：如果我们知道了哪些墙壁可以作为粉刷的起点，这个问题可以直接贪心解决，相当于最少区间覆盖问题。

<https://www.cnblogs.com/acgoto/p/9824723.html>

在这里，值域较小，而且区间长度都相等，所以我们可以考虑枚举值域，记录最优区间的左端点。

我们形象地将编号环形递增的承包商粉刷墙壁的过程比喻为一个承包商构成的滚筒在水平矩形上滚动进行染色，如果滚筒能滚完一圈则该长度一定为 $M$ 的区间合法，可以进行贪心。

前面的 dp 可以维护：在确定点 $i$ 的前提下再确定选择哪个承包商 $j$，从该点开始向右滚动，最远能到达哪个点。最后我们关注的当然是 $dp_{i, j}$ 到 $i$ 的距离是否大于等于 $M - 1$，这意味着我们可以从这个点开始滚一圈，但也要考虑到维护的成本，我们最好从下一个位置开始转移。

我们看一看数据范围：$\sum f^2(k) \le 4 \times 10^5$，这个条件看起来很迷，但是：

$${Q_K}^2 \cdot K = \sum f^2(k) = 4 \times 10^5 \ge K \cdot {A_K}^2$$

其中 $Q_K$ 表示平方平均，为 $\sqrt{\dfrac{f^2(1) + f^2(2) + \cdots + f^2(K)}{K}}$；$A_K$ 表示算术平均，不用写表达式了吧。

又因为 $K \cdot {A_K}^2 = \dfrac{\sum^2 f(k)}{K}$

所以：

$$\sum f(k) \le \sqrt{4 \times 10^5 \cdot K} \le \sqrt{4 \times 10^{10}} = 2 \times 10^5$$

~~草，跟这儿考高中数学呢~~

也就是说，记录喜欢每种颜色的承包商不是问题。

这个条件还有一个很妙的地方，在于喜欢一种颜色的承包商数小于等于 $\sqrt{\sum f^2(k)} < 633$。如果只限定 $\sum f(k)$，那么平方平均只有下界，喜欢一种颜色的承包商数可以飞到九霄云外。

现在实现思路比较清晰了：倒着枚举每一个点，到一个点之后枚举能刷这个点对应颜色的承包商，即 $f(C_i)$ 中每一个元素，如果它下一个承包商刷了下一个位置，那么可以从 $dp_{i + 1, (j + 1) \bmod M}$ 处转移；否则单开一个滚动，$dp$ 值设为 $i$ 本身。

时间复杂度瓶颈处为 $O(K \cdot \sqrt{\sum f^2(k)}\ )$，实际上达不到；空间复杂度跟 $N, M, \sum f(k)$ 都成线性关系。

Code:

```cpp
#include <bits/stdc++.h>
#include "paint.h"
using namespace std;
const int inf = 1e9 + 7;
int n, m, k, fans;
vector<int> book, ans;
vector<vector<int>> f, g;

int minimumInstructions(int n, int m, int k, vector<int> c, vector<int> a, vector<vector<int>> b) {
	// 几个 resize 和清空千万别写错，认真审题
    f.resize(k);
    ans.resize(n);
    book.resize(m);
    g.resize(2);
    for (int i = 0; i < 2; ++i) g[i].resize(m);
    for (int i = 0; i < m; ++i) book[i] = -inf;
    for (int i = 0; i < m; ++i) g[0][i] = g[1][i] = -inf;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < a[i]; ++j) f[b[i][j]].push_back(i);
    for (int i = 0; i < k; ++i) sort(f[i].begin(), f[i].end());
    for (int i = n - 1; i >= 0; --i) {
        for (int j : f[c[i]]) {
            if (book[(j + 1) % m] == i + 1)
                g[i & 1][j] = g[(i & 1) ^ 1][(j + 1) % m];
            else // book 已经清 -inf 了
                g[i & 1][j] = i;
            if (g[i & 1][j] >= m + i - 1)
                ans[i] = 1; // 能滚完一圈，记录合法区间的左端点
        }
        for (int j : f[c[i]]) book[j] = i;
    }
    int lst = -inf, r = -inf; // 贪心：lst 表示左端点在上一个被选择区间内，最靠右的区间；r 表示现在覆盖到了哪里
    for (int i = 0; i < n; ++i) { // 枚举值域即可
        if (ans[i])
            lst = i;
        if (i <= r)
            continue;
        ++fans;
        r = lst + m - 1;
        if (i > r)
            return -1;
    }
    return fans;
}
```

传统题版：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 100002, maxm = 50002;
const int inf = 1e9 + 7;
int n, m, k, fans;
vector<int> c, a, book, ans;
vector<vector<int>> b, f, g;

signed main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m >> k;
    c.resize(n); a.resize(m), b.resize(n);
    for (int i = 0; i < n; ++i)
        cin >> c[i];
    for (int i = 0; i < m; ++i) {
    	cin >> a[i];
        b[i].resize(a[i]);
        for (int j = 0; j < a[i]; ++j)
            cin >> b[i][j];
    }
    f.resize(k); ans.resize(n); book.resize(m);
    g.resize(2);
    for (int i = 0; i < 2; ++i)
        g[i].resize(m);
    for (int i = 0; i < m; ++i)
        book[i] = -inf;
    for (int i = 0; i < m; ++i)
    	g[0][i] = g[1][i] = -inf;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < a[i]; ++j)
            f[b[i][j]].push_back(i);
    for (int i = 0; i < k; ++i)
        sort(f[i].begin(), f[i].end());
    for (int i = n - 1; i >= 0; --i) {
        for (int j : f[c[i]]) {
        	if (book[(j + 1) % m] == i + 1)
                g[i & 1][j] = g[(i & 1) ^ 1][(j + 1) % m];
            else g[i & 1][j] = i;
            if (g[i & 1][j] >= m + i - 1)
            	ans[i] = 1;
        }
        for (int j : f[c[i]]) book[j] = i;
    }
    int lst = -inf, r = -inf;
    for (int i = 0; i < n; ++i) {
        if (ans[i]) lst = i;
        if (i <= r) continue;
        ++fans;
        r = lst + m - 1;
        if (i > r)
            return cout << "-1" << endl, 0;
    }
    return cout << fans << endl, 0;
}
```

---

## 作者：lory1608 (赞：2)

### 前言

总体来说这次APIO题目质量高，参赛体验很棒。

但要吐槽一下：传统题出成交互的形式真的好吗，输入太毒瘤了。

本题是我在场上唯一切了的题，所以来写一篇题解。

### 题意简述

有 $N$ 段墙，每段墙都需要用一种特定的颜色染色，有 $M$ 个承包商，每个承包商都有一些自己喜欢的颜色，对于一段墙 $x,x+1,x+2,\cdots,x+M-1$ 一种合法的染色方案，当且仅当存在 $i$ 使得, $i$ 到 $i-1$ 按顺序圆排列后，每个承包商承包的对应位置颜色是他喜欢的，即 $C[x],C[x+1],\cdots,C[x+M-1]$ 分别是承包商 $i,i+1,\cdots M-1,0,1,\cdots,i-1$ 所喜欢的，每段墙壁可以重复染色，但颜色必须相同且为其对应的特定颜色，并求出最少染色次数，若无法达到要求则输出 $-1$ 。

### 解题思想

对于一段区间的墙，我们需要判断他是否可以被合法的染色，然后我们可以进行dp,设 $dp[i]$ 为前面的所有墙全部染完的最小步数，若$C[i-M+1],C[i-M+2],\cdots,C[i]$ 合法，那么我们可以有如下转移 $dp[i]=\min\limits_{i-M\leq k \leq i-1}\{ dp[k] \}+1 $  。

dp的同时，我们可以用单调队列来维护转移的位置，这一部分的复杂度是 $O(n)$ 的。

由此我们可以将最优性问题转换为**判定性问题**。

### 解题方法

#### 算法1：

对于 $f(k) ≤ 1$ ，我们可以将每个颜色对应的承包商标记上去，一段墙可以被染色当且仅当这一段墙的颜色所对应的承包商编号连续，显然在从第 $i-1$ 个位置向第 $i$ 个位置转移时，只需要用桶进行技术 $O(1)$ 可以解决。

此时总复杂度为 $O(n)$ ，期望的分 $12$ 分。

#### 算法2:

对于 $N ≤ 500,M ≤ \min(N, 200).$ 我们可以对每个颜色维护一个桶 ,去记录每个点可以被那些编号的承包商所覆盖，每次判断只需要对每个编号进行暴力的匹配即可，单次最坏判定复杂度 $O(nm^2)$ 。

最坏的复杂度是 $O(nm^2)$ ,期望得分 $27$ 分。

如果这一道题算法你的常数小，实际跑不满，由于数据比较水，有可能同时过第 $1,4$ 个子任务，获得 $63$ 分的高分。

#### 算法3:

这和正解是一个思路。

对于一个位置 $i$ 开始的长度为 $M$ 的序列，我们只需要知道对于这一段序列编号是否连续即可，同样我们用桶去维护，**对每个承包商编号作为桶**，对于第 $i+k$ 个位置的颜色对应的承包商编号 $id$ ，我们只需要在对 $M$ 取模的意义下的桶的第 $(id-i+1)$ 位加上一即可，同时维护最大值，最后在加到第 $i+M-1$ 位时，我们只需要判断最大值是否等于 $M$ 即可。

最坏复杂度为 $O(nm\max\{f[i]\})$，期望得分 $27$ 分。

如果这一道题算法你的常数小，实际跑不满，由于数据比较水，有可能同时过第 $1,4$ 个子任务，获得 $63$ 分的高分。

#### 算法4：

这是正解。

对于每一个开始的位置，我们重新用桶去维护复杂度太高，注意到我们的每个标记可以相减，所以对于每一个位置上的可用的承包商，我们只用维护其与 $1$ 的相对位置即可，在做完后，只需要把长度大于 $M$ 的位置上的承包商编号所对应的值减一即可。

最坏复杂度 $O(n\max\{f[i]\})$ ,注意到 $\sum f(k)^2\leq 400000$ ,期望得分 $100$ 分。

### 我的考场上的做法

我考场上想到了算法4，但是我脑袋一时糊涂去用线段树去代替桶维护，平白无故加了一个 $\log$ ,只有 $63$ 分。

后来，我将每一个位置上的连续区间都记录下来用线段树区间加一去做，然后就过了，然后就没有然后了。

~~这说明这数据有多水。~~

### 正解代码

```cpp
#include"paint.h"
#include<vector>
#include<algorithm>
#include<cmath>
#include<cstring>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int maxn=1e5+5;
int dp[maxn],q[maxn],hd=0,tl=-1,d[maxn];
vector<int>S[maxn];
inline int A1(int x,int pos,int mod){return ((x-pos+1)%mod+mod)%mod;}
int minimumInstructions(
    int N, int M, int K, std::vector<int> C,
    std::vector<int> A, std::vector<std::vector<int> > B) {
    	memset(dp,0x3f,sizeof(dp));
    	dp[0]=0;
    	q[++tl]=0;
    	FOR(i,0,M-1)
    		FOR(j,0,A[i]-1)S[B[i][j]].push_back(i);
		FOR(i,1,N)
		{
			while(q[hd]<i-M&&hd<=tl)hd++;
			if(dp[q[hd]]>N+1)return -1;
			if(i-M>=1)
			{
				FOR(j,0,(int)(S[C[i-1-M]].size())-1)
				{
					int x=A1(S[C[i-M-1]][j],i-M,M)+1;
					d[x]--;
				}
			}
			int maxv=0;
			FOR(j,0,(int)(S[C[i-1]].size())-1)
			{
				int x=A1(S[C[i-1]][j],i,M)+1;
				d[x]++;
				if(d[x]>maxv)maxv=d[x];
			}
			if(maxv==M)dp[i]=dp[q[hd]]+1;
			while(dp[i]<=dp[q[tl]]&&hd<=tl)tl--;
			q[++tl]=i;
		}
		if(dp[N]!=0x3f3f3f3f)return dp[N];
		else return -1;
}
```

### 附加文件

本题公开的评测库、样例测试点和程序框架可在此查看：[here](https://sandalphon.contest-chn.apio2020.id/api/v2/problems/JIDPROGUKGRVhLLZJbO0JOxDOLw/render/paint.zip)

希望这篇题解能给你带来收获。

---

## 作者：hty2023 (赞：1)

# 解题思路
第一步，求出从每个墙壁开始刷是否合法。

第二步，合法的墙壁位置作为每个区间的左端点，变成区间覆盖问题。

第二步很显然是个贪心，重点是第一步如何解决。

我们设`dp[i][j]`表示从第 $i$ 个墙壁第 $ j$ 个承包商开始刷能刷的墙壁的数量。

那么:

当第 $j$ 个承包商能刷第 $i$ 个墙的时候，`dp[i][j]=dp[i+1][j+1]+1`。

当第 $j $ 个承包商不能刷第 $i$ 个墙的时候，`dp[i][j]=0`。

# 优化

空间上：滚动数组。

时间上：对于确定的 $i$，枚举喜欢`c[i]`颜色的承包商。
# 代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=100005;
vector<int> d[maxn];
int n,m,k,vis[2][maxn],dp[2][maxn],ok[maxn];
struct node{
	int l,r;
}s[maxn];
bool cmp(node a,node b){
	return a.l<b.l;
}
int minimumInstructions(int N,int M,int K,vector<int> C,vector<int> A,vector<vector<int> > B){
	n=N;
	m=M;
	k=K;
	for(int i=1;i<=n;i++) C[i-1]++;
	for(int i=1;i<=m;i++){
		for(int j=0;j<A[i-1];j++) B[i-1][j]++;
	}
	for(int i=1;i<maxn;i++) d[i].push_back(0);
	for(int i=1;i<=m;i++){
		for(int j=0;j<A[i-1];j++) d[B[i-1][j]][0]++,d[B[i-1][j]].push_back(i);
	}
	for(int i=n;i>=1;i--){
		for(int j=1;j<=d[C[i-1]][0];j++){
			if(vis[(i+1)&1][d[C[i-1]][j]%m+1]==i+1) dp[i&1][d[C[i-1]][j]]=dp[(i+1)&1][d[C[i-1]][j]%m+1]+1;
			else dp[i&1][d[C[i-1]][j]]=1;
			vis[i&1][d[C[i-1]][j]]=i; 
			if(dp[i&1][d[C[i-1]][j]]>=m) ok[i]=1;
		}
	}
	int cnt=0;
	for(int i=1;i<=n-m+1;i++){
		if(ok[i]){
			cnt++;
			s[cnt].l=i;
			s[cnt].r=i+m-1;
		}
	}
	sort(s+1,s+cnt+1,cmp);
	int now=0,ans=0;
	for(int i=1;i<=cnt;i++){
		if(s[i].l>now+1){
			return -1;
		}
		int maxr=s[i].r;
		while(i<cnt&&s[i+1].l<=now+1){
			maxr=max(maxr,s[i+1].r);
			i++;
		}
		ans++;
		now=maxr;
	}
	if(now<n){
		return -1;
	}
	return ans;
}
```

---

## 作者：小木虫 (赞：1)

### Preface  
一道题面很吓人，实际上码量不大的思维题。
### Problem  
太长了，[原题传送门](https://www.luogu.com.cn/problem/P6764)。  
### Solution  
很容易发现每次粉刷之间互不干扰，这次用了哪几个承包商和下一次没关系。  
同时对于一个点，我们大可以只关心当前点可不可以往后刷 $m$ 个格子。只要可以，那么所有这样的方案是等价的，可以把这个点往后延长 $m$ 个点看作一个线段。  
现在我们想知道对于一个点 $i$，能否向后延出线段。   
设第 $i$ 个墙壁可以被 $f$ 个承包商粉刷。  
发现 $\sum f$ 很小，$O(\sum f×n)$ 似乎可以通过，同时对于每个点只有 $f$ 个状态，即从哪个承包商开始，其它的 $m-f$ 个状态根本不需要转移，因为其不匹配，本身就应该为 0。  
我们已经成功了一半了，至少知道了状态，接下来就是转移。  
一般来说二维的 dp 复杂度会是近乎 $O(n^3)$ 的，因为还有转移复杂度。但是我们发现这道题可以直接 $O(1)$ 转移！因为每次只会转移到后面一格和后面一个承包商。~~这还能算 dp 吗？~~  
感觉就是刷了个表，dp 都算不上。  
转移方程：  
$dp_{i,j}=dp_{i+1,(j+1)modm}+1$  
一开始一切都为 0，因为转移一次长度加一，没有进行转移的时候后面没有任何线段，就为 0。  
这个记录的是往后的最大延长长度，只要这个点从任意一个承包商开始施工大于等于 $m$ 这个点就可以了。  
空间不够，可以滚动数组优化一下。

------------

现在我们得到了一个最少线段覆盖问题。  
容易发现这个问题可以贪心，即每次找到这个线段与最后一个与它交会的线段，然后跑到那个线段上。这个贪心易证：因为我们尽量往后走，更前面的点肯定要继续向后面走，又因为在前面并且所有线段等长，所以一定有一步走在最后一个线段上，而在前面显然不优。  
code：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e5+10;
int dp[2][N];int a[N];vector <int> c[N];
bool f[N];vector <int> q[N];
int minimumInstructions(int n,int m,int k,vector <int> C,vector <int> A,vector <vector <int> > B){
	for(int i=1;i<=n;i++)a[i]=C[i-1]+1;
	for(int i=1;i<=m;i++){
		for(int j=0;j<B[i-1].size();j++){
			c[B[i-1][j]+1].push_back(i);
		}
	}
	for(int i=1;i<=n;i++)q[i]=c[a[i]];
	bool cur=1;
	for(int i=n;i>=1;i--){
		for(int j=0;j<q[i].size();j++){
			int to=q[i][j]+1;
			if(to>m)to=1;
			dp[cur][q[i][j]]=dp[cur^1][to]+1;
			if(dp[cur][q[i][j]]>=m)f[i]=true;
		}
		cur^=1;
		if(i<n)
			for(int j=0;j<q[i+1].size();j++)dp[cur][q[i+1][j]]=0;
	}
	int res=0;
	for(int i=n-m+1;i>=1;i--){
		if(!f[i])return -1;
		res++;
		for(int j=max(i-m,1);j<i;j++){
			if(f[j]){i=j+1;break;}
		}
	}
	return res;
}
//int main(){
//	int n,m,k,t;
//	cin>>n>>m>>k;
//	vector <int> C;C.clear();
//	for(int i=1;i<=n;i++){
//		cin>>t;C.push_back(t);
//	}
//	vector <int> A;A.clear();
//	vector <int> B[N];
//	for(int i=1;i<=m;i++)B[i].clear();
//	for(int i=1;i<=m;i++){
//		cin>>t;
//		A.push_back(t);
//		for(int j=0;j<A[i-1];j++){
//			cin>>t;
//			B[i].push_back(t);
//		}
//	}
//	cout<<minimumInstructions(n,m,k,C,A,B);
//	return 0;
//}
```


---

## 作者：Genius_Star (赞：0)

[更好的阅读体验](https://www.cnblogs.com/rgw2010/p/18340226)

### 思路：

本质上能进行的操作就是我们算出从第 $i$ 块砖开始，连续刷 $M$ 块砖，是否有承包商可以刷出期望颜色。

那么设 $f_i$ 表示 $[i,i+m-1]$ 是否合法，那么就变成了最小区间覆盖问题。

令 $Max$ 表示当前覆盖了 $[1,Max]$。

那么我们需要找到左端点在 $[1,Max+1]$ 内，且右端点最大的区间。

在本题中因为区间长度都为 $m$，那么我们只需要找到尽可能在最后的合法 $f_i$。

此时 $Max \gets i+m-1$，那么对于小于 $j$ 的 $i$，是无法覆盖到 $i+m-1$ 之后的，于是就没有贡献了，于是我们可以直接走指针维护。

**最小区间覆盖代码:**

```cpp
ll get(){
	ll Max=-1,x=0,id,ans=0;
	while(Max<n-1){
		id=-1;
		while(x<=Max+1&&x<n){
			if(f[x])
			  id=x;
			x++;
		}
		if(id==-1)
		  return -1;
		Max=id+m-1;
		ans++;
	}
	return ans;
}
```

那么我们需要考虑的就是如何求出 $f_i$。

#### 28pts：

对于每个 $i$，暴力枚举一个 $j$，然后查看是否能匹配上。

时间复杂度为 $O(NM^2)$。

#### 51pts：

考虑动态规划优化，定义 $dp_{i,j}$ 表示从第 $i$ 块墙壁开始，从第 $j$ 个商家开刷最多能刷几块墙。

那么若第 $j$ 个商家不能刷第 $i$ 个墙壁，则：

$$dp_{i,j}=0$$

否则能刷：

$$dp_{i,j} = dp_{i+1,(j+1) \bmod M} + 1$$

注意，空间开不下，考虑滚动数组优化。

时间复杂度为 $O(NM)$。

~~震惊的是，这玩意儿竟然过了……~~

**$O(NM)$ 代码：**

```cpp
int minimumInstructions(int N, int M, int K,vector<int> C,vector<int> A,vector<vector<int>> B){
	n=N,m=M,k=K;
	for(int i=0;i<n;i++)
	  a[i]=C[i];
	for(int i=0;i<m;i++){
		len[i]=A[i];
		for(auto v:B[i])
		  s[v].push_back(i);
	}
	for(int i=n-1;i>=0;i--){
		for(int j=0;j<m;j++)
		  dp[i&1ll][j]=0;
		for(auto j:s[a[i]]){
			dp[i&1ll][j]=dp[(i&1ll)^1ll][(j+1)%m]+1;
			if(dp[i&1ll][j]>=m)
			  f[i]=1;
		}
	}
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB"<<'\n';
	return get();
}
```

#### 100pts：

注意到可以优化上面状态转移的 $j$。

我们可以提前预处理能刷颜色 $x$ 的承包商的集合 $S_x$，那么 $j \in S_{c_i}$。

但是因为是滚动数组，实时清空的话复杂度又上去了，那么再维护一个时间戳即可。

时间复杂度为 $O(\sum f(k))$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef int ll;
bool Begin;
const ll N=100100,M=50050;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,k;
ll a[N],len[M];
ll dp[2][M],low[2][M];
vector<ll> s[N];
bool f[N];
bool End;
ll get(){
	ll Max=-1,x=0,id,ans=0;
	while(Max<n-1){
		id=-1;
		while(x<=Max+1&&x<n){
			if(f[x])
			  id=x;
			x++;
		}
		if(id==-1)
		  return -1;
		Max=id+m-1;
		ans++;
	}
	return ans;
}
int minimumInstructions(int N, int M, int K,vector<int> C,vector<int> A,vector<vector<int>> B){
	n=N,m=M,k=K;
	for(int i=0;i<n;i++)
	  a[i]=C[i];
	for(int i=0;i<m;i++){
		len[i]=A[i];
		for(auto v:B[i])
		  s[v].push_back(i);
	}
	for(int i=n-1;i>=0;i--){
		for(auto j:s[a[i]]){
			if(low[(i&1ll)^1ll][(j+1)%m]!=i+1)
			  dp[i&1ll][j]=1;
			else
			  dp[i&1ll][j]=dp[(i&1ll)^1ll][(j+1)%m]+1;
			low[i&1ll][j]=i;
			if(dp[i&1ll][j]>=m)
			  f[i]=1;
		}
	}
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB"<<'\n';
	return get();
}
```

---


# [APIO2020] 交换城市

## 题目背景

由于官方数据包过大，本题仅评测部分数据。

本题仅支持 C++ 系列语言，提交时**不需要**包含 `swap.h` 头文件。

由于交互库本身的性能问题，本题的时间限制上调为 $3$ 秒。如果交互库存在其他问题，请私信 mrsrz。

## 题目描述

印度尼西亚有 $N$ 个城市以及 $M$ 条双向道路，城市从 $0$ 到 $N - 1$ 编号，道路从 $0$ 到 $M - 1$ 编号。每条道路连接着两个不同的城市，第 $i$ 条道路连接第 $U[i]$ 个城市与第 $V[i]$ 个城市，汽车行驶这条道路将耗费 $W[i]$ 个单位汽油。通过这些道路，任意两个城市间能够互相到达。

接下来的 $Q$ 天中, 每天会有一对城市希望建立政治关系。具体来说，第 $j$ 天，第 $X[j]$ 个城市想要和第 $Y[j]$ 个城市建立政治关系。为此，第 $X[j]$ 个城市将会派一名代表坐汽车前往第 $Y[j]$ 个城市。同样地，第 $Y[j]$ 个城市也会派一名代表坐汽车前往第 $X[j]$ 个城市。

为了避免拥塞，两辆车不应在任何时间点碰面。更具体地，两辆车不能在同一个时间点出现在同一个城市。同样地，两辆车也不应该沿相反的方向同时行驶过同一条道路。另外，汽车行驶过一条道路时必须完整经过道路并到达道路另一端的城市（换句话说，汽车不允许在道路中间掉转方向）。但是，汽车可以多次到达一个城市或是多次经过一条道路。此外，汽车可以在任何时间在任何城市等候。

由于高燃料容量汽车的价格昂贵，两个城市都分别希望选择一条路线，使得两辆汽车所需的最大单位汽油容量最小。每个城市中都有加油站并且供油量是无限的，因此汽车所需的单位汽油容量实际上就是行驶过的道路中最大的单位汽油消耗量。

你必须实现 `init` 和 `getMinimumFuelCapacity` 函数。

- `init(N, M, U, V, W)` - 该函数将在所有 `getMinimumFuelCapacity` 的调用前被评测库恰好调用一次。
	- $N$： 一个整数表示城市数。
	- $M$： 一个整数表示道路数。
	- $U$： 一个长为 $M$ 的整数序列表示道路的第一个端点城市。
	- $V$： 一个长为 $M$ 的整数序列表示道路的第二个端点城市。
	- $W$： 一个长为 $M$ 的整数序列表示道路的汽油消耗。

- `getMinimumFuelCapacity(X, Y)` - 该函数将被评测库调用恰好 $Q$ 次。
	- $X$： 一个整数表示第一个城市。
	- $Y$： 一个整数表示第二个城市。
	- 该函数必须返回一个整数，表示根据题目描述中的规则，两辆分别从第 $X$ 个城市与第 $Y$ 个城市出发要到达彼此城市的车，它们的单位汽油容量最大值的最小值。若无法满足题目规则则返回 $−1$。

## 说明/提示

第一个样例中, $N = 5$，$M = 6$，$U = [0, 0, 1, 1, 1, 2]$，$V = [1, 2, 2, 3, 4, 3]$，$W =
[4, 4, 1, 2, 10, 3]$，$Q = 3$，$X = [1, 2, 0]$，$Y = [2, 4, 1]$。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/j3x1idy8.png)

评测库初始时将调用 `init(5, 6, [0, 0, 1, 1, 1, 2], [1, 2, 2, 3, 4, 3],[4, 4, 1, 2, 10, 3])`。之后，评测库将进行如下函数调用：

- `getMinimumFuelCapacity(1, 2)`。首先，从第一个城市出发的汽车可以行驶到第三个城市。接着，从第二个城市出发的汽车可以行驶到第一个城市，并且在第三个城市的汽车可以行驶到第二个城市。因此，最大的单位汽油容量为 $3$ （从第三个城市到第二个城市需要花费 $3$ 个单位汽油）。没有其他更优的路线方案，因此该函数应该返回 $3$。

- `getMinimumFuelCapacity(2, 4)`。任何从第四个城市出发或要到达第四个城市的汽车都需要耗费 $10$ 个单位汽油，因此该函数应该返回 $10$。

- `getMinimumFuelCapacity(0, 1)`。该函数应该返回 $4$。

第二个样例中，$N = 3$，$M = 2$，$U = [0, 0]$，$V = [1, 2]$，$W = [5, 5]$，$Q = 1$，$X = [1]$，$Y = [2]$。 如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3df9k1og.png)

评测库初始时将调用 `init(3, 2, [0, 0], [1, 2], [5, 5])`，之后，评测库将进行如下函数调用：

- `getMinimumFuelCapacity(1, 2)`。两辆车无法满足不在同一时间点碰面的要求，所以该函数应该返回 $-1$。

【条件限制】

- $2 \leq N \leq 100 000$。
- $N - 1 \leq M \leq 200 000$。
- $0 \leq U[i] < V [i] < N$。
- 任意两个城市间至多存在一条道路直接相连。
- 任意两个城市经过道路可以互相到达。
- $1 \leq W[i] \leq 10^9$。
- $1 \leq Q \leq 200 000$。
- $0 \leq X[j] < Y [j] < N$。

【子任务 $1$（$6$ 分）】

- 每个城市至多是两条道路的一个端点。

【子任务 $2$（$7$ 分）】

- $M = N - 1$。
- $U[i] = 0$。

【子任务 $3$（$17$ 分）】

- $Q \leq 5$。
- $N \leq 1 000$。
- $M \leq 2 000$。

【子任务 $4$（$20$ 分）】

- $Q \leq 5$。

【子任务 $5$（$23$ 分）】

- $M = N - 1$。

【子任务 $6$（$27$ 分）】

- 无附加限制。


## 样例 #1

### 输入

```
5 6
0 1 4
0 2 4
1 2 1
1 3 2
1 4 10
2 3 3
3
1 2
2 4
0 1
```

### 输出

```
3
10
4
```

## 样例 #2

### 输入

```
3 2
0 1 5
0 2 5
1
1 2
```

### 输出

```
-1
```

# 题解

## 作者：周子衡 (赞：19)

**前置思想：Kruskal 重构树**

在讲解原题的算法前，先简单介绍一下 Kruskal 重构树的思想。一个经典问题：

> 给一张无向图 $G$，边有边权。每次询问给定 $x,v$，求从 $x$ 出发只经过边权 $\leq v$ 的边能到达多少个点。**强制在线。**

众所周知，图上两点的**最小瓶颈路**（也就是最大边最小的路）一定包括最小生成树上两点的路。所以我们可以先把边排序，用 Kruskal 算法求出最小生成树。但这样仍然不能方便地求出答案，怎么办呢？Kruskal 重构树的思想是：在 Kruskal 算法确定一条最小生成树上的边 $(x,y)$ 时，不直接连接 $(x,y)$，而是新建一个节点 $T$，分别连接 $(T,x),(T,y)$，将 $T$ 的点权设置为 $x,y$ 的边权，这就形成了 Kruskal 重构树。容易发现一些性质：

- 对于每个点 $x$，$x$ 祖先上的点权单调递增。
- 对于每个点 $x$ 和每个阈值 $v$，从 $x$ 出发只经过边权 $\leq v$ 的边能到达的点的集合，和 $x$ 祖先节点中深度最大的 $\leq v$ 的节点的子树内的所有原图节点的集合是一样的。这样就可以解决上面的题目了。
- 对于两点 $x,y$，$x,y$ 的最小瓶颈边权（也就是最大边最小的路的最大边权）等于 $x,y$ 的最近公共祖先（LCA）的点权。

关于更详细的讲解，请见 [NOI2018 归程](https://www.luogu.com.cn/problem/P4768) 一题的题解。

---------------

对于本题来说，也可以理解为是查询两点间的瓶颈边，我们尝试运用类似 Kruskal 重构树的思想。

首先分析原题中的描述，可以知道：两点 $x,y$ 能互相派出使者访问，**当且仅当两点连通，且它们所在的连通块不是一条链。** 证明较为简单，连通性显然必须满足，而如果连通块是链也显然无解，尝试一下发现只要有度数 $\geq 3$ 的点或者环那么必定有解。

将边从小到大排序，运行和 Kruskal 算法类似的过程。不同的是，我们不仅要维护连通性，还要维护一个连通块究竟是不是链。发现一条链的性质很大程度上取决于两个端点，于是不妨在并查集的根节点处维护两个数组 $st_i,en_i$，如果该连通块是链，则存储链的端点。当一个连通块从链变成非链时，我们就在 Kruskal 重构树上新建一个节点，这个节点向所有链上的点连边；连通块合并同理。不难发现这样做仍然能保证原来 Kruskal 重构树的大部分性质，而且也能用 LCA 来处理在线询问。

简单来说，我们扫描每条边：

1. 如果边两端已经连通：如果这个连通块是一条链，那么加上这条边显然不再是链了，那么打上标记，同时在 Kruskal 重构树上连边；否则没有变化。
1. 如果没有连通：
- 如果原来两个连通块有至少一个不是链，那么新连通块也一定不是链；
- 如果原来两个连通块都是链，那么新连通块是不是链取决于连边是不是在端点之间进行的。也可简单维护。

注意我们由于要维护一个点所在的连通块，且要支持合并，应采用启发式合并，使时间复杂度稳定在 $O(n\log n)$。

总时间复杂度 $O((n+q)\log n)$。

下面是代码，其中并查集 $B$ 用来维护连通性，$conn_i$ 表示并查集里以 $i$ 为根的连通块是不是脱离链的形态了，$tr$ 表示 Kruskal 重构树的边。

```cpp
#include"swap.h"

#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

struct BCJ
{
	int fa[500000];
	void init(int n){for(int i=0;i<n;i++)fa[i]=i;}
	int fnd(int x){return x==fa[x]?x:fa[x]=fnd(fa[x]);}
}B;

struct e
{
	int u,v,w;e(int uu=0,int vv=0,int ww=0):u(uu),v(vv),w(ww){}
};vector<e> ed;
bool operator<(e a,e b){return a.w<b.w;}

bool conn[500000];int st[500000],en[500000],rt[500000];vector<int> pnt[500000];

vector<int> tr[500000];

int fa[500000][20],dep[500000];

void dfs(int u,int f)
{
	fa[u][0]=f;for(int i=1;i<20;i++)fa[u][i]=fa[u][i-1]==-1?-1:fa[fa[u][i-1]][i-1];
	rt[u]=f==-1?u:rt[f],dep[u]=f==-1?1:dep[f]+1;
	for(int i=0;i<tr[u].size();i++)dfs(tr[u][i],u);
}

int LCA(int x,int y)
{
	if(rt[x]!=rt[y])return -1;
	if(dep[x]<dep[y])swap(x,y);
	for(int i=19;i>=0;i--)
	{
		if(fa[x][i]!=-1&&dep[fa[x][i]]>=dep[y])x=fa[x][i];
	}
	if(x==y)return x;
	for(int i=19;i>=0;i--)
	{
		if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
}
int n,m;
void init(int N, int M,vector<int> U,vector<int> V,vector<int> W)
{
	n=N,m=M;
	for(int i=0;i<M;i++)ed.push_back(e(U[i],V[i],W[i]));sort(ed.begin(),ed.end());
	B.init(N);for(int i=0;i<N;i++)st[i]=en[i]=rt[i]=i,pnt[i].push_back(i);
	for(int i=0;i<M;i++)
	{
		int u=ed[i].u,v=ed[i].v,fu=B.fnd(u),fv=B.fnd(v);
		if(pnt[fu].size()<pnt[fv].size()){swap(u,v),swap(fu,fv);}
		if(fu==fv)
		{
			if(!conn[fu])
			{
				conn[fu]=1;
				for(int j=0;j<pnt[fu].size();j++)tr[i+N].push_back(pnt[fu][j]);
				rt[fu]=i+N;
			}
		}
		else
		{
			if(conn[fu]||conn[fv])
			{
				if(conn[fu])tr[i+N].push_back(rt[fu]);
				else for(int j=0;j<pnt[fu].size();j++)tr[i+N].push_back(pnt[fu][j]);
				if(conn[fv])tr[i+N].push_back(rt[fv]);
				else for(int j=0;j<pnt[fv].size();j++)tr[i+N].push_back(pnt[fv][j]);
				conn[fu]=1,rt[fu]=i+N;B.fa[fv]=fu;
			}
			else
			{
				if((u==st[fu]||u==en[fu])&&(v==st[fv]||v==en[fv]))
				{
					st[fu]=u^st[fu]^en[fu];en[fu]=v^st[fv]^en[fv];
					for(int j=0;j<pnt[fv].size();j++)pnt[fu].push_back(pnt[fv][j]);
					B.fa[fv]=fu;
				}
				else
				{
					conn[fu]=1;
					for(int j=0;j<pnt[fu].size();j++)tr[i+N].push_back(pnt[fu][j]);
					for(int j=0;j<pnt[fv].size();j++)tr[i+N].push_back(pnt[fv][j]);
					B.fa[fv]=fu;rt[fu]=i+N;
				}
			}
			
		}
	}
	/*for(int i=0;i<N+M;i++)
	{
		printf("%d: ",i);
		for(int j=0;j<tr[i].size();j++)printf("%d ",tr[i][j]);puts("");
	}*/
	for(int i=N+M-1;i>=0;i--)
	{
		if(!dep[i])dfs(i,-1);
	}
	//for(int i=0;i<N+M;i++){printf("%d\n",dep[i]);for(int j=0;j<4;j++)printf("%d ",fa[i][j]);puts("");}
}

int getMinimumFuelCapacity(int X,int Y)
{
	
	int u=LCA(X,Y);if(u==-1)return -1;
	return ed[u-n].w;
}
```

---

## 作者：LAWArthur (赞：13)

这道题说实话出题人设计用心很良苦了，但我就是不领情……

因为一种情况没考虑，喜提 $0$ 分……

---

# 题意
__强制在线__ 问询将图上两点交换所走过的边中权值最大的。

# 部分分性质
这道题设计好就好在部分分可以很好地帮助想到正解。

## Subtask1
Subtask1 讲的其实是链和环的情况，结论显然：__如果是链__，则 $-1$，__如果是环__，则输出环上最大值。

## Subtask2
Subtask2 是菊花图，结论是 __当 $n\ge3$ 时，一定有解__。

当 $x$ 为根时，答案为 $w(x,y)$ 以及这条边之外的其他边的次小值两者的最大值。

当 $x,y$ 均不为根，设 $u$ 为根，答案为 $w(u,x),w(u,y)$ 和其余边中最小值三者的最大值。

## Subtask5
Subtask5 是一棵树，因为不存在环的情况，所以只需要有三岔路就可以了，考虑 $dp$ 出到各个点的最大值最小三岔路，再和 $(x,y)$ 链上最大值比较得到最终答案。

情况分为子树内和子树外：

__子树内：__

定义 $E_u$ 为以 $u$ 为一个端点的边的集合，$v$ 为 $u$ 的一个孩子，$v_k$ 为 $E_u$ 中的第 $k$ 小值，$h_u$ 为子树内的最小三岔路。

状态转移方程：$h_u=\min(\min\limits_v\{\max(h_v,w_{(u,v)})\},v_3\mid|E_u|\ge 3)$

__子树外：__

定义 $H_u$ 为整体最小三岔路，$p$ 为 $u$ 的父亲。

状态转移方程：$H_u=\min(\max(F_p,w_{(u,p)}),h_u)$

如果不存在三岔路 $H_u=INF$。

最终 $H_{lca(x,y)}$ 就是我们要求的 $(x,y)$ 向三岔路进行交换的最大值。

有些人可能会问：为什么取 $v_3$ 一定是对的？

我们考虑到满足条件的一个岔路要且仅要用到三条边。对于最好的情况，会用到 $v_1,v_2,v_3$ 的三条边。但由于进入和离开岔路的方向问题，很多时候会用到更大的边。

考虑转移方程中 $\max(h_v,w_{(u,v)})$ 一句，实际就是将进入子树的边同样做了次比较，因此如果只有一条边规定了，答案仍然是正确的。

对于两条边规定的情况，只可能出现在 $(x,y)$ 链上，而我们计算答案时会和链作比较取最大值，因此仍然是正确的。

# 为正解做准备
考虑图上两个点能互换的条件：由 Subtask1，__有环__；由 Subtask2，__有三岔路__。（都铺垫好了）

可以证明只要这两种情况出现一种就一定可以互换。

所以答案一定是在点 $x,y$ 能到达的最大值最小环、最大值最小三岔路、$x$ 到 $y$ 的最小直链上三者之一。

分析数据规模：$N\le100000,M,Q\le200000$，由于在线问询，每次问询复杂度要在 $\log$ 以下。考虑图论中的 $\log$ 级别算法都是在树上操作的，因此可以想见一定会用到生成树。

又由于我们要最大值最小，不难想到使用最小生成树。

# 正解
我们先建一棵最小生成树。

为了之后的解题方便，我们在连边时加一个中继节点 $x$，将 $x$ 的点权设为 $w$，并连接 $(x,u)$ 及 $(x,v)$。

根据上文的讲解，我们分三类计算：（注：下文所谓最小环、最小三岔路即从点 $u$ 向环/三岔路走进行一次交换的最小花费）

## $(x,y)$ 间直链
根据最小生成树性质，$(x,y)$ 间的最大值意义最小路就是树上两点间的简单路径，可以通过树上 $ST$ 表 $O(\log n)$ 求解。

## 最小环
因为最小生成树对于原图中的每一个环都去掉了环上的最大边，我们发现每一条不在树上的边一定就是原图中一个环的最大值。

又考虑到走不在树上的边只会使结果变大，因此我们找环时只能沿着树上的边走，这样就可以树形 $DP$预计算。

处理和 Subtask5 类似，情况同样分为子树内和子树外。

__子树内：__

定义 $E_u$ 为以 $u$ 为一个端点的边的集合，$E_T$ 为在树上的边集合，$v$ 为 $u$ 的一个子节点，$f_u$ 为点 $u$ 及子树内可达的最大值意义下最小环上的最大值（有点绕）。

则有状态转移方程：$f_u=\min(\min\limits_v\{\max(f_v,w_{(u,v)})\},\min\limits_{e\in E_u,e\not\in E_T}\{w_e\})$

即子树内的值要和出子树的那条边取个最大值，且还要和连接该点的非树上的边比较。

__子树外：__

定义 $F_u$ 为 $u$ 可达的最大值意义下最小环上的最大值，$p$ 为 $u$ 的父亲。

状态转移方程：$F_u$ = $\min(\max(F_p,w_{(u,p)}),f_u)$

如果 $f_p$ 从 $u$ 转移得到，则将子树内同样计算了上去。

同样注意，如果不存在环 $F_u=INF$。

最终 $F_{lca(x,y)}$ 就是我们要求的 $(x,y)$ 向最小环进行交换的最大值。

## 最小三岔路
这种情况可以直接采用 Subtask5 的处理。

## 最终答案
$ans_{(x,y)}=\max(st(x,y),\min(F_{lca(x,y)},H_{lca(x,y)}))$

注意如果 $ans=INF$，输出 $-1$。

复杂度：$O((n+m)\log n)$（预处理），$O(Q\log n)$（计算答案）

## 代码
（代码细节较多，请结合文章享用）
```cpp
#include "swap.h"

#include <bits/stdc++.h>
using namespace std;
#define INF 1000000005
#define NMAX 100005
#define MMAX 200005
#define LOGNMAX 20

std::vector<int> U,V,W;
int n,m,val[2*NMAX][3];

//////前向星，前三小值
int hd[2*NMAX],t,deg[2*NMAX];

struct edge{
  int u,v,w;
  bool isTree;//边是否在树上
  int nxt;
} es[4*MMAX];

inline void add_edge(int u,int v,int w,bool isTree){
  es[++t]=(edge){u,v,w,isTree,hd[u]};
  hd[u]=t;

  // 同时计算前三小值
  if(val[u][0]==0||w<val[u][0])val[u][2]=val[u][1],val[u][1]=val[u][0],val[u][0]=w;
  else if(val[u][1]==0||w<val[u][1])val[u][2]=val[u][1],val[u][1]=w;
  else if(val[u][2]==0||w<val[u][2])val[u][2]=w;
}
//////

//////建树，倍增，树上st表
int idx;//新增节点数
int p[2*NMAX][LOGNMAX],st[2*NMAX][LOGNMAX],d[2*NMAX];

void buildTree(int u,int fa){
  p[u][0]=fa;
  if(fa>=0)d[u]=d[fa]+1;else d[u]=1;//注意此处特判根节点

  for(int i=hd[u];i;i=es[i].nxt){
    if(!es[i].isTree||es[i].v==fa)continue;
    buildTree(es[i].v,u);
  }
}

void doublep(){//建立倍增关系
  for(int i=1;i<LOGNMAX;i++){
    for(int j=0;j<n+idx;j++){
      if(p[j][i-1]>=0){
        p[j][i]=p[p[j][i-1]][i-1];
        st[j][i]=max(st[j][i-1],st[p[j][i-1]][i-1]);
      }
      else p[j][i]=-1,st[j][i]=st[j][i-1];//事实上此处不管如何赋值st都没有太多意义
    }
  }
}

inline int lca(int u,int v){
  if(d[u]<d[v])swap(u,v);
  for(int i=LOGNMAX-1;i>=0;i--){
    if(p[u][i]>=0&&d[p[u][i]]>=d[v])u=p[u][i];
  }
  if(u==v)return v;
  for(int i=LOGNMAX-1;i>=0;i--){
    if(p[u][i]!=p[v][i])u=p[u][i],v=p[v][i];
  }
  return p[u][0];
}

inline int ST(int u,int v){
  int res=0;
  //照搬lca
  if(d[u]<d[v])swap(u,v);
  for(int i=LOGNMAX-1;i>=0;i--){
    if(p[u][i]>=0&&d[p[u][i]]>=d[v])res=max(res,st[u][i]),u=p[u][i];
  }
  if(u==v)return max(res,st[u][0]);
  for(int i=LOGNMAX-1;i>=0;i--){
    if(p[u][i]!=p[v][i])res=max(res,max(st[u][i],st[v][i])),u=p[u][i],v=p[v][i];
  }
  return max(max(res,st[p[u][0]][0]),max(st[u][0],st[v][0]));
}
//////

////// Kruscal
int id[MMAX],bel[2*NMAX];

bool cmp(const int &a,const int &b){
  return W[a]<W[b];
}

int find(int u){
  return u==bel[u]?u:bel[u]=find(bel[u]);
}

void unite(int u,int v){
  int fu=find(u),fv=find(v);
  if(fu!=fv)bel[fu]=fv;
}

void kruscal(){
  for(int i=0;i<m;i++)id[i]=i;
  for(int i=0;i<2*n;i++)bel[i]=i;
  sort(id,id+m,cmp);//对边排序
  for(int i=0;i<m;i++){
    if(find(U[id[i]])!=find(V[id[i]])){
      unite(U[id[i]],V[id[i]]);
      add_edge(U[id[i]],n+idx,W[id[i]],true);//新建一个点连边
      add_edge(n+idx,U[id[i]],W[id[i]],true);
      add_edge(V[id[i]],n+idx,W[id[i]],true);
      add_edge(n+idx,V[id[i]],W[id[i]],true);
      st[n+idx][0]=W[id[i]];
      idx++;
    }
    else{
      add_edge(U[id[i]],V[id[i]],W[id[i]],false);
      add_edge(V[id[i]],U[id[i]],W[id[i]],false);
    }
    
    //累加度数
    deg[V[id[i]]]++;
    deg[U[id[i]]]++;
  }
}
//////

////// h,f,H,F（尽管h,f计算可以合并在建树中，但分开来计算更易于管理）
int h[2*NMAX],f[2*NMAX],H[2*NMAX],F[2*NMAX];
void dfs_fh(int u){
  f[u]=INF;
  h[u]=val[u][2]?val[u][2]:INF;
  int v;
  for(int i=hd[u];i;i=es[i].nxt){
    if(es[i].v==p[u][0])continue;
    v=es[i].v;
    if(es[i].isTree){
      dfs_fh(v);
      f[u]=min(f[u],max(f[v],es[i].w));
      h[u]=min(h[u],max(h[v],es[i].w));
    }
    else{
      f[u]=min(f[u],es[i].w);
    }
  }
}

void dfs_FH(int u,int w){
  F[u]=f[u],H[u]=h[u];
  if(p[u][0]>=0){
    F[u]=min(F[u],max(w,F[p[u][0]]));
    H[u]=min(H[u],max(w,H[p[u][0]]));
  }
  int v;
  for(int i=hd[u];i;i=es[i].nxt){
    if(es[i].v==p[u][0])continue;
    v=es[i].v;
    if(es[i].isTree){
      dfs_FH(v,es[i].w);
    }
  }
}
//////


void init(int N, int M,
  std::vector<int> U, std::vector<int> V, std::vector<int> W) {
  n=N,m=M;
  ::U=U,::V=V,::W=W;//全局变量引用

  kruscal();

  buildTree(0,-1);
  doublep();

  dfs_fh(0);
  dfs_FH(0,0);
}

int getMinimumFuelCapacity(int X, int Y) {
  int lxy=lca(X,Y);
  int ans=max(ST(X,Y),min(F[lxy],H[lxy]));
  if(ans==INF)return -1;
  return ans;
}

```


---

## 作者：syksykCCC (赞：7)

## Subtask 1

「每个城市至多是两条道路的一个端点」说明只存在两种情况：一是整张图构成一条链，这时答案显然始终为 $-1$；二是整张图构成一个环，这时答案显然为 $\max W$，因为唯一可能的错车方法就是两辆车分别从两边走，那正好遍历了图上的每一条边，答案为全局最大值。

## Subtask 2

菊花图的处理方法也很简单，分为两种情况：

一是 $X = 0, Y \ne 0$ ，那么答案为**连接 $(0, Y)$ 的边**以及其他边中**最小**的和**次小**的这三边的 $\max$（图左）。

二是 $X \ne 0, Y \ne 0$，那么答案为**连接 $(0, X)$ 的边**，**连接 $(0, Y)$ 的边**，以及其他边中**最小**的这三边的 $\max$（图右）。

![image.png](https://i.loli.net/2020/09/08/rNBta59sLmdMgA1.png)

## Subtask 3

我们可以用一个类似 Dijkstra 的算法来尝试解决这个部分分。

用 $cost_{A, B}$ 来表示有两辆车分别是 $X \to A, Y \to B$ 时所需要的最小边权。初始除了 $cost_{X, Y} \gets 0$ 外其他均为 $+\infty$。显然答案为 $cost_{Y, X}$。

比如现在我们已经有 $cost_{A, B}$ 的值了，我们可以尝试把位于 $A$ 的车移动到一个相邻的点 $C$ ($C \ne B$)，这条连接 $(A, C)$ 的边边权为 $D$。然后我们就可以更新 $cost_{C, B} \gets \min(cost_{C, B}, \max(cost_{A, B}, D))$。同样我们可以尝试把位于 $B$ 的车移动到一个相邻的点，全部更新结束就可以得到答案了。

时间复杂度 $O(Q \times N \times (N+M) \times \log (N^2))$。

## Subtask 4

回想 Subtask 1, 2，我们可以得到，两个城市可以互相到达当且仅当下面两个条件**之一**成立：

* 构成环；
* 某结点度数 $\ge 3$。

总结一下，就是**所在连通块不为链**即可。

由于本题求的是瓶颈边，考虑利用 Kruskal 算法求最小生成树的过程。

我们按照 $W$ 从低到高插入每条边，动态维护一个 $\text{nch}_u$ (**n**ot a **ch**ain) 表示以 $u$ 为代表元的连通块是否脱离的链的形态。下面记 $\operatorname{Find}(u)$ 表示寻找包含 $u$ 的连通块的代表元，也就是并查集的找父亲操作。

当我们插入某一条边后 $\operatorname{Find}(X) = \operatorname{Find}(Y) = Z$（$X, Y$ 连通）且 $\text{nch}_Z = 1$（该连通块脱离链的形态），那么我们就可以停止操作，答案即为这条边的边权。

问题在于 $\text{nch}_u$ 怎么维护。比如现在插入的边是 $(A, B)$，首先 $deg_A \gets deg_A + 1, deg_B \gets deg_B + 1$，那么 $\text{nch}_u = 1$ 当且仅当下面五者有一个成立：

* $\text{nch}_{\operatorname{Find}(A)} = 1$；
* $\text{nch}_{\operatorname{Find}(B)} = 1$；
* $deg_A \ge 3$；
* $deg_B \ge 3$；
* $\operatorname{Find}(A) = \operatorname{Find}(B)$（原本已经连通了，再加一条就构成环）。

如果所有边都插入了终止条件还是不满足，答案为 $-1$。

时间复杂度 $O(M \log M + Q \times M \times \alpha(N))$。

## subtask 5

图的形态是一棵树，那么我们就不用考虑构成环的情况了。

用 $cost_u$ 表示从 $u$ 出发，找到一个可以错车的三叉路口，走过的最大边权最小是多少。初始时，如果 $deg_x \ge 3$，则 $cost_x = $ 和 $x$ 连接的第三小的边权；否则 $cost_x = \infty$。

如果有一条边连接了 $(A, B)$，边权为 $C$，那么可以得到 DP 式子 $ cost_A \gets \min(cost_A, \max(cost_B, C)), cost_B \gets \min(cost_B, \max(cost_A, C)) $。DP 的顺序很套路，可以从叶子结点一路上传到根，再从根传播到各个子节点。

最终，答案就是 $\max(X \to Y$ 路径上的最大边权$, cost_X)$。前面那部分可以直接倍增维护一下。

时间复杂度 $O(N \log N + Q \log N)$。

## subtask 6

Subtask 4 的做法是比较靠谱的，可惜它需要每次询问都做一次 Kruskal。所以，我们可以尝试使用 **Kruskal 重构树**的思路。

普通的 Kruskal 重构树可以回答 $X, Y$ 连通之后的瓶颈边权，现在我们不是想要 $X, Y$ 简单连通，而是**不呈现链状连通**。可以改造一下 Kruskal 重构树，使得它成为一棵多叉树，但依然满足 $\operatorname{LCA}(X, Y)$ 的权值就是答案。

所以，在 $\text{nch}_u = 1$ 之前，用一个数组 $\text{pnt}_u$ 来表示 $u$ 所在连通块内点的编号，而在 $\text{nch}_u = 1$ 之后，把 $\text{pnt}_u$ 当中的每一个元素都连到父结点上。$\text{pnt}$ 可以通过启发式合并来保证复杂度。（感谢[这篇题解](https://www.luogu.com.cn/blog/zhouziheng666/solution-p6765)的优秀思路）

比如现在加入一条边 $(A, B)$，分如下情况：

* 如果之前 $A, B$ 已经连通且是链，那么加上这条边就不再是链了，打上标记，同时在 Kruskal 重构树上连边；
* 如果原来 $A, B$ 两个连通块有至少一个不是链，那么新连通块也一定不是链，打上标记，同时在 Kruskal 重构树上连边；
* 如果原来 $A, B$ 两个连通块都是链，那么新连通块是不是链取决于连边是不是在端点之间进行的。可以维护 $s_u$ 和 $t_u$ 表示 $u$ 为代表元的链的端点，那么这里就很好判断：
   * 如果不是在端点进行的，那么加上这条边就不再是链了，打上标记，同时在 Kruskal 重构树上连边；
   * 如果是在端点进行的，那么加上这条边依然是链，更新 $s$ 和 $t$，同时合并 $\text{pnt}$。

时间复杂度 $O(N \log N + Q \log N)$。

代码中结点编号从 $1$ 开始。

```cpp
#include "swap.h"
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <string>
#include <vector>
using namespace std; 
const int MAXN = 500005;
int n, m, cnt, f[20][MAXN], dep[MAXN], s[MAXN], t[MAXN], rt[MAXN];
vector<int> pnt[MAXN], tr[MAXN];
bool nch[MAXN];
struct disjoint_sets_union
{
	int fa[MAXN];
	void init() { for(int i = 1; i <= n; i++) fa[i] = i; }
	int find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }
} dsu;
struct edge
{
	int u, v, w;
	bool operator < (const edge &oth) const { return w < oth.w; }
} e[MAXN];

void DFS(int u, int fa)
{
	dep[u] = dep[fa] + 1;
	rt[u] = fa ? rt[fa] : u;
	f[0][u] = fa;
	for(int k = 1; k <= 19; k++) f[k][u] = f[k - 1][f[k - 1][u]];
	for(int v : tr[u]) DFS(v, u);
}

int LCA(int u, int v)
{
	if(rt[u] != rt[v]) return -1;
	if(dep[u] < dep[v]) swap(u, v);
	for(int k = 19; ~k; k--)
	{
		if(dep[f[k][u]] < dep[v]) continue;
		u = f[k][u];
	}
	if(u == v) return u;
	for(int k = 19; ~k; k--)
	{
		if(f[k][u] == f[k][v]) continue;
		u = f[k][u]; v = f[k][v];
	}
	return f[0][u];
}

void init(int N, int M, vector<int> U, vector<int> V, vector<int> W) 
{
	n = N; m = M;
	for(int i = 0; i < m; i++) e[++cnt] = (edge){U[i] + 1, V[i] + 1, W[i]};
	sort(e + 1, e + m + 1);
	dsu.init();
	for(int i = 1; i <= n; i++) { s[i] = t[i] = rt[i] = i; pnt[i].push_back(i); }
	for(int i = 1; i <= m; i++)
	{
		int u = e[i].u, v = e[i].v;
		int fau = dsu.find(u), fav = dsu.find(v);
		if(pnt[fau].size() < pnt[fav].size()) { swap(u, v); swap(fau, fav); }
		int cur = i + n;
		if(fau == fav)
		{
			if(!nch[fau])
			{
				nch[fau] = true;
				for(int k : pnt[fau]) tr[cur].push_back(k);
				pnt[fau].clear();
				rt[fau] = cur;
			}
		}
		else
		{
			if(nch[fau] || nch[fav])
			{
				if(nch[fau]) tr[cur].push_back(rt[fau]);
				else for(int k : pnt[fau]) tr[cur].push_back(k);
				if(nch[fav]) tr[cur].push_back(rt[fav]);
				else for(int k : pnt[fav]) tr[cur].push_back(k);
				pnt[fau].clear(); pnt[fav].clear();
				nch[fau] = true;
				rt[fau] = cur;
				dsu.fa[fav] = fau;
			}
			else
			{
				if((u == s[fau] || u == t[fau]) && (v == s[fav] || v == t[fav]))
				{
					s[fau] = u ^ s[fau] ^ t[fau]; t[fau] = v ^ s[fav] ^ t[fav];
					for(int k : pnt[fav]) pnt[fau].push_back(k);
					pnt[fav].clear();
					dsu.fa[fav] = fau;
				}
				else
				{
					nch[fau] = true;
					for(int k : pnt[fau]) tr[cur].push_back(k);
					for(int k : pnt[fav]) tr[cur].push_back(k);
					pnt[fau].clear(); pnt[fav].clear();
					rt[fau] = cur;
					dsu.fa[fav] = fau;
				}
			}
		}
	}
	for(int i = n + m; i; i--)
		if(!dep[i]) DFS(i, 0);
}

int getMinimumFuelCapacity(int X, int Y)
{
	int a = LCA(X + 1, Y + 1);
	if(a == -1) return -1;
	return e[a - n].w;
}
```

---

## 作者：cyh_toby (赞：5)

# 题意

[题目](https://www.luogu.com.cn/problem/P6765)

# 写在前面

本篇主要补充一下有关合并连通块的更简便的方法，整体思路与其他题解一致。

### 心路历程（建议跳过）：

本来打算整体二分做，然后发现强制在线，悲催。然后玩了玩发现可以搞个`可持久化并查集`（瞎猜有这种数据结构），结果一搜发现真的有这种东西，但放在这里再加个二分，就有三个 $\log$，不太行。

后来看有人在可持久化并查集题解底下评论，说 Kruskal 重构树在很多时候可以替代可持久化并查集。于是又玩了玩，感觉可做。

至于为啥 Kruskal 重构树的时间复杂度比可持久化并查集+二分优秀，我认为是因为前者需要预处理一些信息，不支持一边加边一边询问，但后者支持修改和询问的交替，导致其时间复杂度较高。

# 分析

看到要最小化瓶颈，容易联想二分（尽管最后没有用二分），那么可以考虑什么样的图上的两点可以 `swap`。显然，首先，两个点必须在同一连通块内。之后手玩一下，容易发现这个连通块必须不是一条链。即两点可以 `swap` 等价于两点在同一连通块内，并且连通块不是一条链。

如何判定连通块是不是链呢？我的做法是，记录连通块大小 $size$、度数为 $1$ 的点的个数 $c_1$、度数为 $2$ 的点的个数 $c_2$。那么，当且仅当 $c_1=2$ 且 $c_1+c_2=size$ 时，连通块是链。有这个等价条件，就容易维护了，只需要再额外记录一下每个点的度数就行，在加边的时候 $O(1)$ 修改即可，然后并查集正常合并，**不需要**很多题解提到的启发式合并。

剩下 Kruskal 重构树的思路就与其他题解大致相同，不再赘述。

# 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5+5, M = 2e5+5, K = 3e5+5;// K = N + M

int n, m;
struct Edge {
	int x, y, w;
	Edge() : x(0), y(0), w(0) {}
	Edge(int _x, int _y, int _w) : x(_x), y(_y), w(_w) {}
} e[M];

inline bool operator < (const Edge &x, const Edge &y) { return x.w < y.w; }

struct Kruskal {// kruskal 重构树
	int g[K], v[K], nxt[K], tot, idx;
	int f[K], siz[K], d[N], c[K][3], a[K];
	int anc[K][20], dep[K], h[K];
	inline void add(int x, int y) {
		v[++tot] = y, nxt[tot] = g[x], g[x] = tot;
	}
	int getf(int x) {
		if (f[x] == x) return x;
		return f[x] = getf(f[x]);
	}
	inline void upd(int x, int v) {
		if (1 <= d[x] && d[x] <= 2) c[getf(x)][d[x]] += v;
	}
	void dfs(int x, int fa, int dpt) {
		anc[x][0] = fa, dep[x] = dpt;
		if (c[x][1] == 2 && c[x][1] + c[x][2] == siz[x]) h[x] = h[fa];
		else h[x] = x;
		for (int i = 1; (1 << i) <= dep[x]; i++)
			anc[x][i] = anc[anc[x][i-1]][i-1];
		for (int i = g[x]; i; i = nxt[i]) {
			int y = v[i];
			dfs(y, x, dep[x] + 1);
		}
	}
	inline int lca(int x, int y) {
		if (dep[x] < dep[y]) swap(x, y);
		int dlt = dep[x] - dep[y];
		for (int i = 19; i >= 0; i--)
			if ((dlt >> i) & 1)
				x = anc[x][i];
		if (x == y) return x;
		for (int i = 19; i >= 0; i--)
			if (anc[x][i] != anc[y][i])
				x = anc[x][i], y = anc[y][i];
		return anc[x][0];
	}
	inline int qry(int x, int y) {
		int d = h[lca(x, y)];
		if (!d) return -1;
		return a[d];
	}
	inline void init() {
		sort(e + 1, e + 1 + m);
		for (int i = 1; i <= n; i++) f[i] = i, siz[i] = 1;
		idx = n;
		for (int i = 1; i <= m; i++) {
			int x = e[i].x, y = e[i].y, z = e[i].w;
			int fx = getf(x), fy = getf(y);
			if (fx != fy) {
				++idx, f[idx] = idx, a[idx] = z, siz[idx] = siz[fx] + siz[fy];
				c[idx][1] = c[fx][1] + c[fy][1], c[idx][2] = c[fx][2] + c[fy][2];
				f[fx] = idx, f[fy] = idx;
				add(idx, fx), add(idx, fy);
			}
			else if (z != a[fx]) {
				++idx, f[idx] = idx, a[idx] = z, siz[idx] = siz[fx];
				c[idx][1] = c[fx][1], c[idx][2] = c[fx][2], f[fx] = idx, add(idx, fx);
			}
			upd(x, -1), upd(y, -1);
			d[x]++, d[y]++;
			upd(x, 1), upd(y, 1);
		}
		dfs(idx, 0, 0);
	}
} kt;

void init(int N, int M, vector<int> U, vector<int> V, vector<int> W) {
	n = N, m = M;
	for (int i = 0; i < m; i++) e[i+1] = Edge(U[i] + 1, V[i] + 1, W[i]);
	kt.init();
}

int getMinimumFuelCapacity(int x, int y) {
	x++, y++;
	return kt.qry(x, y);
}
```

---

## 作者：int_R (赞：3)

来点简单做法，好想好写，不用 Kruskal 重构树！

尽管是 $O(q\log m\log n)$，但是实测很快！

----

考虑只有一次询问，我们可以边做 Kruskal，边实时判断加入一条边以后是否可以建立关系。

首先，一个连通块之内的任意两个点一定都可以或都不可以建立关系。我们称一个内部点可以互相建立关系的连通块为好的连通块。一个好的连通块等价于连通块不为链。

我们定义 $b_i$ 表示以 $i$ 为祖先的连通块最早的变成好的连通块的时间，有三种情况会更改 $b_i$：

- 和另一个好的连通块相连了。

- 在连通块内又加入了一条边。

- 有一个点度数大于 $2$。

这个东西是好处理的。查询时每次只需要判断两个点是否在同一个好的连通块内即可。

```cpp
inline void link(int u,int v,int i)
{
    ++d[u],++d[v];int fau=find(u),fav=find(v);
    if(fau==fav){if(!b[fau]) b[fau]=i;return ;}//存在环了
    if(!b[fau]&&b[fav]) b[fau]=i;//与好的连通块相连了
    if(b[fau]&&!b[fav]) b[fav]=i;//与好的连通块相连了
    if(siz[fau]>siz[fav]) swap(u,v),swap(fau,fav);//按秩合并
    tim[fau]=i,fa[fau]=fav,siz[fav]+=siz[fau];
    if((d[u]>2||d[v]>2)&&!b[fav]) b[fav]=i;//有点度数大于 2 了
}
```

----

对于多次询问，我们肯定不能直接做，所以考虑二分答案。但这样就要求我们记录下每次加入边后的并查集数组。

一个 naive 的想法是用主席树维护，并查集还要按秩合并，再加一个二分，然后直逼三 $\log$。

后来发现既然都按秩合并了，干脆不路径压缩，这样每个 $fa_i$ 只会更改一次，记录一下更改的时间，这样查询历史版本的父亲时，只需要判断是在更改前还是更改后就行了，这样就是双 $\log$ 了。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int MAXN=1e5+10,MAXM=2e5+10;
int n,m,fa[MAXN],tim[MAXN],siz[MAXN],d[MAXN],b[MAXN];
struct node{int u,v,w;}p[MAXM];
inline int F(int x,int i){return (!tim[x]||i<tim[x])?x:fa[x];}
inline bool cmp(node x,node y){return x.w<y.w;}
inline int find(int x){return (fa[x]==x)?x:find(fa[x]);}
inline void link(int u,int v,int i)
{
    ++d[u],++d[v];int fau=find(u),fav=find(v);
    if(fau==fav){if(!b[fau]) b[fau]=i;return ;}
    if(!b[fau]&&b[fav]) b[fau]=i;
    if(b[fau]&&!b[fav]) b[fav]=i;
    if(siz[fau]>siz[fav]) swap(u,v),swap(fau,fav);
    tim[fau]=i,fa[fau]=fav,siz[fav]+=siz[fau];
    if((d[u]>2||d[v]>2)&&!b[fav]) b[fav]=i;
}
void init(int N,int M,vector <int> u,vector <int> v,vector<int> w)
{
    n=N,m=M;for(int i=0;i<m;++i) p[i+1]={u[i]+1,v[i]+1,w[i]};
    sort(p+1,p+1+m,cmp);
    for(int i=1;i<=n;++i) fa[i]=i,siz[i]=1;
    for(int i=1;i<=m;++i) link(p[i].u,p[i].v,i);
}
inline bool Check(int x,int y,int i)
{
    for(int fa=F(x,i);fa!=x;) x=fa,fa=F(x,i);
    for(int fa=F(y,i);fa!=y;) y=fa,fa=F(y,i);
    return (x==y&&b[x]&&b[x]<=i);
}
int getMinimumFuelCapacity(int x,int y)
{
    ++x,++y;int l=1,r=m;
    if(!Check(x,y,m)) return -1;
    while(l<r)
    {
        int mid=(l+r)>>1;
        Check(x,y,mid)?r=mid:l=mid+1;
    }return p[l].w;
}
```

顺便提一嘴，如果允许离线的话可以一起二分，$\log$ 层每次都从头跑一遍 Kruskal，这样并查集可以路径压缩，把并查集复杂度忽略的话就到单 $\log$ 了。虽然本来就有单 $\log$ 在线做法。

---

## 作者：TianyiLemon (赞：3)

其实这题很简单啊，不像一些题解说的要启发式合并。

按照边权从小到大加边，然后有一个结论：点 $u$ 和 $v$ 能够互相通车，当且仅当 $u$ 和 $v$ 联通，且 $u$ 与 $v$ 所在的连通块不是一条链。结论自证不难。

问题是如何用 kruskal 重构树维护这个信息。

考虑加入一条边：

当 $u$ 和 $v$ 不联通时，我们首先合并 $u$ 与 $v$ 所在的联通块，然后分类讨论：

+ 如果 $u$ 和 $v$ 所在的联通块有一个不是链，那么新联通块一定不是链。
+ 否则，记录联通块对应链的左右端点，如果能接起来就是链，否则就不是。

当 $u$ 和 $v$ 联通时，如果 $u$ 和 $v$ 所在的联通块是链，那么加一条边后一定不是链。我们将 $u$ 和 $v$ 所在联通块对应的点接到新点上，将新点设为不是链。

因为一个联通块至多有一次从是链转变成不是链，所以最终节点总数不超过 $3n$。

查询的时候，我们首先找到 $u$ 和 $v$ 在 	kruskal	 重构树上的 lca，如果对应的联通块不是链，直接返回对应边权即可；否则从 lca 开始倍增，找到第一个不是链的点即可。

时间复杂度 $O((n+q)\log n)$，空间复杂度 $O(n\log n)$。

[代码](https://loj.ac/s/1677370)

---

## 作者：Tony102 (赞：3)

[Luogu6765](https://www.luogu.com.cn/problem/P6765)

还是推荐用 LOJ 评测,可以评测全部的数据

[LOJ3346](https://loj.ac/p/3346)


[更好的阅读体验](https://tony102.xyz/index.php/2021/05/18/loj3346-apio2020%e4%ba%a4%e6%8d%a2%e5%9f%8e%e5%b8%82/)


### Description

给一个简单一些的题面

有一张 $n$ 个点 $m$ 条边的带权无向图, 均从 $0$ 开始编号.现在有 $Q$ 组询问,每次两个人从 $u,v$ 出发,要求这两个人不能同时在一个点上,也不能同时经过一条边.允许多次走一个点或者一条边.

现在要求最小化路径上的最大边权.



### Sol

APIO2021来之前决定做一些 APIO 的真题来练练手

APIO 的题都是用实现函数类似于交互库的形式, 还是要提前适应

首先看到最小化最大这种东西,可以先试着往二分上靠.那么就二分这个答案最大权,每次两个点丢进去暴跳的途中判断就完事儿了.可能要注意下细节.应该可以拿到 Subtask3 的部分分

现在二分判定的瓶颈不在二分出答案上面,而是在判定答案时我是爆判的.考虑来优化这个过程.最简单的情形就是在一条链上面,这个两个人如果同时往中间跳时相遇,就跑不掉了.这样链的答案是 $-1$ . 菊花图的情况对应 Subtask2, 那么只需要判断一下起点和终点经不经过菊花根就可以了.

现在要解决的问题就是什么时候一定会有答案. 已知链无解,无解是因为必要同时经过同一边.但凡有一条别的出边能出去,就有可能有解. 假如现在有这么一条边能让它出去了,要再让他回来到达终点就必须有一条边引回.这样就是一个三元环.(这个过程可以多画画图)

解决了这个问题,二分的方法复杂度是 $O(Qn \log n)$ .可以通过 Subtask4

解决问题的关键又变成了二分不够优秀.考虑 Kruskal 重构树.可以用来解决这个问题. 在 Kruskal 重构树上, $u, v$ 路径上的最小被阀值限制的边权就是它们 lca 的点权.

还有一个问题就是做 Kruskal 的时候还要注意连通块是不是链的问题.可以这么解决,同时维护一个连通块的起点和终点,以及连通块的一个根.合并的时候注意,分情况讨论.

1. 现在两个连通块要合并,不是链的话合并以后也不是
2. 还不能合并: 
   1. 有一个不是新的就不是
   2. 原来两个都是链,那么就看是不是两条链的端点连边,如果是的话就会连成一条链.



### Code

Luogu 的不要加 `swap.h` 这一句

**[Code戳这里](https://tony102.xyz/index.php/2021/05/18/loj3346-apio2020%e4%ba%a4%e6%8d%a2%e5%9f%8e%e5%b8%82/)**

---

## 作者：摸鱼酱 (赞：3)

纪念一下过的第一道交互类型的题目。

[**题目Link**](https://www.luogu.com.cn/problem/P6765)

题意：$n$ 个点 $m$ 条边的无向图，$q$ 组询问 $(x,y)$ ，问从 $x,y$ 分别走到对方，让路径上边权的最大值最小，要求两条路径不完全重合。

各个子任务真的都多少指向了正解吧。。

$Q\leq 5$ 的部分让我们想到了 $\mathcal O(Qnlogn)$ 的**二分答案**。

想这个 $Subtask$ 的时候需要思考一些实现细节，比如简化一下题意，即二分出一个答案 $k$ ，我们利用 Kruskal 的思想，把边权小于等于 $k$ 的边都加进去，如果 $x,y$ 连通，那么说明这个 $k$ 允许我们有一条路径让 $x$ 到达 $y$ 。

问题是我们需要两条不完全重合的路径，于是 $M=N-1$ （树）的部分是两点之间路径唯一，那我们只能让一个点走出这条路径一步，等另一边走到了终点再走过去。特殊的，如果从起点只有一条路退出去是不行的，否则另一边走到了自己的位置之后就走不回去了。

停下来观察一下，我们需要**路径上任意一点的度数大于2**，这样即使是在初始 $x$ 就退一步到 $z_1$，$y$ 到达 $x$ 的位置之后，还有一个空位 $z_2$ 可以走过去停留，让 $x$ 走过去，路径上的点同理。

于是不难想到，要两条不完全重合的路径，我们只需要让这条路径上的点有一个度数超过2的，这样我们就可以走出这条链，等待另一边过去之后再继续走。这个用简单的权值并查集可以实现。

考虑整体二分，但是会发现题目这个实现的要求迫使我强制在线，那么就想其他算法。

发现 Kruskal 的思路可以继续沿用，考虑 Kruskal 重构树。即做生成树时，如果一对 $(u,v)$ 成功连通两个连通块，那么改变原来把它们 merge 起来的做法，而是新建一个点 $f$，把 $u,v$ 都**在并查集上**并到 f 上，然后**在图上**把 $get(u),get(v)$ 连向父亲 $f$。这样做完生成树之后，就得到了一棵 Kruskal 重构树。

并且在这道题中，我们把对应的权值 $w$ 作为点权赋值给父亲 $f$。这样的话如果只考虑一条路径的话，$x,y$ 之间的答案就是 $lca(x,y)$ 的点权。

因为当产生它们的 $lca$ 的边加进去之后它们才连通，而边权又是从小到大加入的，于是到 $lca$ 的点权就是最优的答案。

到这里已经很接近正解了。我们发现，$lca$ 及其之上的点都可以满足让 $x,y$ 连通，那么我们就从 $lca$ 向上找到其最近的一个点使其满足有路径点数大于2。发现这个性质是可以合并的，即挨着加边进去的时候让 $u,v$ 的度数加一，如果其中有大于2的，那么新合并出来的点就拥有这个性质。

于是我们就得到了某些点天然有这个性质，加完边之后 dfs 下去就可以传递最近的拥有性质的祖先结点了。

打出来发现会过不了样例，为什么呢？

考虑在加入边 $(u,v)$ 时它们已经连通，最简单的是形成了一个 $(a-b-c-a)$ 的环，图中每个点的度数都是2，但我们是可以让 $a,b$ 分别走到对方的位置的，这种情况特判一下就好了。

[**完整代码Link**](https://www.luogu.com.cn/paste/jf032za1)



---

## 作者：I_am_Accepted (赞：2)

### Analysis

* * *

**引理：** 若连通简单图 $G$ 不是链，则 $G$ 有一个点的度 $\ge 3$ 或有环。

**证明：** 无环连通图为树，一棵树不是链则有一个度数 $\ge 3$ 的点。

* * *

我们设两个城市为 $X,Y$，车为 $x,y$。

核心问题：怎样的图可以让 $X,Y$ 互通车？

手玩一下，发现答案是**除了链的所有图**（当然要保证两城市在同一个连通块中），下面给出证明。

* * *

首先一条链肯定是不行的，因为两辆车在链上的相对位置不会改变。

我们证明不是链（有一个点的度 $\ge 3$ 或有环）一定可行。

**有环：**

1. 将 $x,y$ 开到环上。

2. 将 $x,y$ 在环上交换位置。

3. $x$ 沿着 $y$ 来的路回，$y$ 同理。

**无环：**

不妨设度 $\ge 3$ 的点为 $O$，且度数恰好为 $3$，相邻的点为 $A,B,C$。

以 $O$ 定根。

不妨设城市 $X$ 在 $A$ 的子树内。

**（一）** $Y$ 也在 $A$ 子树内。不妨设 $Y$ **不是** $X$ 的祖先。则：

1. $x$ 移到 $B$。

2. $y$ 移到 $C$。

3. $x$ 移到 $Y$。

4. $y$ 移到 $X$。

**（二）** $Y$ 不在 $A$ 子树内，不妨设在 $B$ 的子树内。

1. $x$ 移到 $C$。

2. $y$ 移到 $X$。

3. $x$ 移到 $Y$。

* * *

我们要找到对于每组询问，让 $X,Y$ 同连通块不为链的最大边权最小值。（慢慢读 qwq）

这让我们想起了 **Kruskal 重构树**，没学过的快去学 awa。

将边按照边权排序，依次加入（设当前为 $(x,y)$）：

* 若 $x,y$ 已在一个连通块里。
1. 该连通块为链，新开结点，标记为非链。
2. 否则不做。

* 若 $x,y$ 不在一个连通块里。
1. $x,y$ 所在连通块中至少有一个不是链，或者 $x$ 或 $y$ 不为该连通块的两端之一。将两连通块合并，标记为非链。
2. 否则，将两连通块合并，标记为链，并记录两端以便后续查询。

最后询问时查询 $x,y$ 的 LCA 的最近非链祖先，输出边权即可。

### Detail

建议用 `C++ 20` 编译，否则会 CE。

注意不能 `#define int long long`，因为题目中给的函数返回必须是 int32。

由于此 Kruskal 重构树变形有 链 $\to$ 非链 新开节点的操作，空间记得开 $3$ 倍而不是 $2$ 倍。

### Code

```cpp
//Said no more counting dollars. We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=j;i<=k;i++)
#define Rof(i,j,k) for(int i=j;i>=k;i--)
#define vi vector<int>
#define N 100010
#define M 200010
#define C 20 
struct edge{
	int u,v,w;
	friend bool operator<(edge x,edge y){return x.w<y.w;}
}e[M];
int rt[3*N],st[3*N],ed[3*N],f[3*N][C+1],tot,val[3*N],dep[3*N];
inline int gf(int x){return rt[x]==x?x:rt[x]=gf(rt[x]);}
void init(int n,int m,vi U,vi V,vi W){
	For(i,0,m-1) e[i+1]=(edge){U[i]+1,V[i]+1,W[i]};
	sort(e+1,e+1+m);
	For(i,1,3*n) rt[i]=i;
	For(i,1,n) st[i]=ed[i]=i;
	tot=n;
	int x,y,w,xx,yy;
	For(i,1,m){
		x=e[i].u,y=e[i].v,w=e[i].w;
		xx=gf(x),yy=gf(y);
		if(xx==yy){
			if(st[xx]!=-1){
				val[++tot]=w;
				f[xx][0]=tot;
				rt[xx]=tot;
				st[tot]=-1;
//				cerr<<xx<<"->"<<tot<<":"<<val[tot]<<" "<<st[tot]<<"*"<<ed[tot]<<endl; 
			}
		}else{
			val[++tot]=w;
			f[xx][0]=f[yy][0]=tot;
			rt[xx]=rt[yy]=tot;
			if(st[xx]!=-1 && st[yy]!=-1 && (x==st[xx] || x==ed[xx]) && (y==st[yy] || y==ed[yy])){
				st[tot]=x^st[xx]^ed[xx];
				ed[tot]=y^st[yy]^ed[yy];
			}else st[tot]=-1;
//			cerr<<xx<<"&"<<yy<<"->"<<tot<<":"<<val[tot]<<" "<<st[tot]<<"*"<<ed[tot]<<endl; 
		}
	}
	Rof(i,tot,1) dep[i]=dep[f[i][0]]+1;
//	For(i,1,tot) cout<<dep[i]<<" "; cout<<endl;
	For(j,1,C) For(i,1,tot) f[i][j]=f[f[i][j-1]][j-1];
}
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	int xx,yy;
	Rof(i,C,0){
		xx=f[x][i];
		if(dep[xx]>=dep[y]) x=xx;
	}
	if(x==y) return x;
	Rof(i,C,0){
		xx=f[x][i];
		yy=f[y][i];
		if(xx!=yy) x=xx,y=yy;
	}
	return f[x][0];
}
int antichain(int x){
	if(st[x]==-1) return x;
	int xx;
	Rof(i,C,0){
		xx=f[x][i];
		if(xx && st[xx]!=-1) x=xx;
	}
	return f[x][0];
}
int getMinimumFuelCapacity(int x,int y){
	x++,y++;
	int z=lca(x,y);
	z=antichain(z);
	if(st[z]!=-1) return -1;
	else return val[z];
}
```

---

## 作者：小木虫 (赞：2)

update on 2022.4.28 修改了代码中的一个小错误
### Preface  
这题继承了 APIO 话多事少的题面特点...  
### Problem  
题意简述：  
在一个无向连通图中求使一个点对连通且连通块不为链的最大边权最小的连通块。  
### Solution  
发现这玩意没有连通块不为链的性质其实就是在求瓶颈路，直接 Kruskal 重构树就可以直接进行求解。但是它有一个不为链的性质。  
我们发现一旦有这个性质，那么在原 Kruskal 重构树中没有卵用的边可以变得有用了，因为其虽然对连通块没有贡献但对是否为链是有贡献的。  
马上就可以想到先把这些原本没用的边也加到重构树中去，反正不会影响重构树的原本性质（易证）。  
然后我们对于每个重构树上的点维护一下它所代表的连通块是否为链，这个记录一下链的头尾然后合并的时候判断一下就可以了，易发现如果为链该点权值为 0，否则为 1 的话这棵树依然是一个大根堆，所以如果一个点为链，那么所有其子节点都为链。  
现在我们拿到一个点对，首先按照一般流程处理连通，也就是在重构树上找到两点 LCA。然后我们要求离这个 LCA 最近的父亲。依照之前的推论，一个点如果是链，其所有子节点都用不了，可以直接二分步数套一个倍增解决。  
tips：这个二分如果分到了一个比其深度还要深的步数，那么 $r=mid-1$ 。和发现为链的 $l=mid+1$ 不一样，这点需要注意一下。  
code：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=4e5+10;
int n,m;int f[MAXN];
struct EDGE{int u,v,w;}edge[MAXN];
int st[MAXN][21];int fa[MAXN];int value[MAXN];
int root;int son[MAXN][2];bool chain[MAXN];
int s[MAXN];int t[MAXN];int deep[MAXN];
int find(int x){
	if(fa[x]==x)return x;
	else return fa[x]=find(fa[x]);
}
void merge(int x,int y,int i){
	fa[x]=y;
	if(s[y]==0&&t[y]==0){
		chain[y]=chain[x];
		s[y]=s[x];t[y]=t[x];
		return;
	}
	if(chain[x]&&chain[y]){
		if(s[x]==edge[i].u&&t[y]==edge[i].v)t[y]=t[x];
		else if(s[x]==edge[i].v&&t[y]==edge[i].u)t[y]=t[x];
		else if(t[x]==edge[i].u&&t[y]==edge[i].v)t[y]=s[x];
		else if(t[x]==edge[i].v&&t[y]==edge[i].u)t[y]=s[x];
		else if(s[x]==edge[i].u&&s[y]==edge[i].v)s[y]=t[x];
		else if(s[x]==edge[i].v&&s[y]==edge[i].u)s[y]=t[x];
		else if(t[x]==edge[i].u&&s[y]==edge[i].v)s[y]=s[x];
		else if(t[x]==edge[i].v&&s[y]==edge[i].u)s[y]=s[x];
		else chain[y]=0;
	}else{
		chain[y]=0;s[y]=t[y]=-1;
	}
}
bool cmp(EDGE a,EDGE b){return a.w<b.w;}
void dfs(int u){
	//cout<<u<<" "<<son[u][0]<<" "<<son[u][1]<<endl;
	deep[u]=deep[f[u]]+1;
	st[u][0]=f[u];
	for(int i=1;i<=20;i++)st[u][i]=st[st[u][i-1]][i-1];
	if(son[u][0])dfs(son[u][0]);
	if(son[u][1])dfs(son[u][1]);
}
int LCA(int x,int y){
	if(deep[x]<deep[y])swap(x,y);
	for(int i=20;i>=0;i--){
		if(deep[st[x][i]]>=deep[y])x=st[x][i];
	}
	if(x==y)return x;
	for(int i=20;i>=0;i--){
		if(st[x][i]!=st[y][i]){
			x=st[x][i];y=st[y][i];
		}	
	}
	return f[x];
}
void init(int N,int M,vector <int> U,vector <int> V,vector <int> W){
	n=N;m=M;
	for(int i=0;i<m;i++)
		edge[i+1]=(EDGE){U[i]+1,V[i]+1,W[i]};
	for(int i=1;i<=n+m;i++)fa[i]=i;
	for(int i=1;i<=n;i++)chain[i]=1,s[i]=i,t[i]=i;
	sort(edge+1,edge+1+m,cmp);
	for(int i=1;i<=m;i++){
		int x=find(edge[i].u);
		int y=find(edge[i].v);
		value[i+n]=edge[i].w;
		if(x==y){
			f[x]=i+n;son[i+n][0]=x;
			merge(x,i+n,i);chain[i+n]=0;
			continue;
		}
		f[x]=f[y]=i+n;son[i+n][0]=x;son[i+n][1]=y;
		merge(x,i+n,i);
		merge(y,i+n,i);
	}
	//for(int i=1;i<=m;i++)cout<<edge[i].u<<" "<<edge[i].v<<" "<<chain[i+n]<<endl;
	dfs(n+m);
}
int res;
int check(int x,int y){
	for(int i=20;i>=0;i--){
		if(st[x][i]==0)continue;
		if((1<<i)<=y){
			x=st[x][i];y-=(1<<i);
		}
	}
	res=value[x];
	if(y)return -1;
	if(chain[x])return 0;
	return 1;
}
int getMinimumFuelCapacity(int x,int y){
	x++;y++;
	int lca=LCA(x,y);
	//cout<<lca<<endl;
	int l=0;int r=n;
	while(l<r){
		int mid=(l+r)/2;
		int c=check(lca,mid);
		if(c==-1)r=mid-1;
		if(c==0)l=mid+1;
		if(c==1)r=mid;
	}
	if(check(lca,l)!=1)return -1;
	check(lca,l);
	return res;
}
//int main(){
//	int n,m,q,u,v,w;
//	vector <int> U;U.clear();
//	vector <int> V;V.clear();
//	vector <int> W;W.clear();
//	cin>>n>>m;
//	for(int i=1;i<=m;i++){
//		cin>>u>>v>>w;
//		U.push_back(u);
//		V.push_back(v);
//		W.push_back(w);
//	}
//	init(n,m,U,V,W);
//	cin>>q;
//	for(int i=1;i<=q;i++){
//		cin>>u>>v;
//		cout<<getMinimumFuelCapacity(u,v)<<endl;
//	}
//	return 0;
//}
```


---

## 作者：xh39 (赞：1)

前置算法:kruskal重构树(包含 kruskal解最小生成树(用到了并查集))。

本题解中最短路定义为最大值最小的路。

第一辆车肯定走最短路。现在要考虑第二辆车如何走。

有两种类型:避让 或 新走一条路。

避让:指两辆车走同一条路。但第二辆车要在中途对第一辆车避让。比如对于下图:

```
0-1-2
  |
  3
```
对于这张图，第一辆车和第二辆车都要走 0-1-2，但第二辆中途需去 $3$ 结点避让以免撞车。

很容易观察到避让必须要有一个度数大于 $2$ 的结点才行。此时建 kruskal重构树。但是遇到度大于 $2$ 的结点就要标记，表示这个点可用，求 lca 时必须要找到被标记过的祖先保证可以避让。

如何找度>2的点很容易，初始 $\text{所有度数=0}$，然后加一条边将两个端点的度数自增 $1$，然后若其中有一个度数大于 $2$ 就可以标记了。

比如，还是对于上面那张图，构建出重构树(小括号表示重构的点，中括号表示被标记的点):
```
   [6]
   / \
 (5)  3
 / \
(4) 2
/ \
0  1
```
此时，两辆车分别在 $0$ 和 $1$，求出 $lca(0,1)=4$，但 $4$ 无标记，不能作为查询的点。此时要找到 lca 的最近被标记过的祖先，即 $6$。

新路:指两条不同的路。

比如:
```
0-1
| |
2-3
```
第一辆走 0-1-3，第二辆走 3-2-0 。这就是不同的路。

容易发现，不同的两条路构成了一个环。所以就要求最小环。

一样还是 kruskal重构树，构成环就标记。

问题是怎么判环。并查集就可以处理。若并查集中祖先相同则连成了环。如果这个祖先没被标记过，则将其标记，并易其点权为此边权。

举个例子。对于这张图。
```
 0---(4)---1
 |         |
(1)       (2)
 |         |
 2---(3)---3
 ```
建重构树(注:为方便，重构出来的点直接写点权，没标号了)
```
   [4]
  /   \
(1)   (2)
/ \   / \
0  2  1  3
```
对于最上方的点，本来边权为 $3$，无标记。但加入边 $(0,1)$ 后，构成了环，故标记，并改权为 $4$。

注意:若一点被标记，其所有祖先都必须标记。关于如何实现，见代码。
```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct bian{ //邻接表。
	int u,v,w;
}_[1000005];
struct rule{ //按边权从小到大排序。
	bool operator()(const bian &s1,const bian &s2){
		return s1.w<s2.w;
	}
};
int father[1000005]; //并查集。
int getfather(int iakioi){
	if(father[iakioi]==iakioi){
		return iakioi;
	}
	father[iakioi]=getfather(father[iakioi]);
	return father[iakioi];
}
int a[1000005],du[1000005]; //a表示点重构树权,du表示度。
bool can[1000005]; //can表示标记数组。
struct xyq{ //存重构树。
	int v,next;
}asdf[1000005];
int head[1000005],tot=1;
void add(int u,int v){
	asdf[tot].v=v;
	asdf[tot].next=head[u];
	head[u]=tot;
	tot++;
}
int depth[1000005],f[21][200005],dianshu,logn; //节点数。 
int getMinimumFuelCapacity(int b,int c){
	if(b==c){
		return -1;
	}
	int i;
	if(depth[b]<depth[c]){ //把深度大的当做b。方便倍增。
		swap(b,c);
	}
	for(i=logn;i>=0;i--){ //将b跳到与c深度相同。
		if(depth[b]>(1<<i)&&depth[f[i][b]]>=depth[c]){
			b=f[i][b];
		}
	}
	for(i=logn;i>=0;i--){ //求出lca。
		if(f[i][b]!=f[i][c]){
			b=f[i][b];
			c=f[i][c];
		}
	}
	b=f[0][b]; //此刻b点为lca。
	for(i=logn;i>=0;i--){ //跳到被标记的点。
		if(depth[b]>(1<<i)&&!can[f[i][b]]){  //如果这个点没有被标记,其子更不可能被标记。就跳至此点。
			b=f[i][b];
		}
	}
	if(!can[b]&&depth[b]>1){
		b=f[0][b];
	}
	if(can[b]){  //如果所有点均为被标记,则无解,否则返回对应权值。
		return a[b];
	}else{
		return -1;
	}
}
void dfs(int iakioi,int step){
	depth[iakioi]=step;
	int i;
	for(i=head[iakioi];i>=0;i=asdf[i].next){
		dfs(asdf[i].v,step+1);
	}
}
void init(int n,int m,vector<int> u,vector<int> v,vector<int> w){
	dianshu=n;
	memset(head,-1,sizeof(head));
	tot=1;
	int i,j,f1,f2,ykb=(n<<1);
	for(logn=0;(1<<logn)<=n;logn++){
	}
	logn++;
	for(i=0;i<=ykb;i++){
		father[i]=i;
	}
	for(i=0;i<m;i++){
		_[i].u=u[i];
		_[i].v=v[i];
		_[i].w=w[i];
	}
	sort(_,_+m,rule());
	for(i=0;i<m;i++){
		f1=getfather(_[i].u);
		f2=getfather(_[i].v);
		du[_[i].u]++;
		du[_[i].v]++;
		if(f1==f2){ //说明构成了环。
			if(!can[f1]){ //若未标记,则标记而易其值。
				can[f1]=1;
				a[f1]=_[i].w;
			}
		}else{
			father[f1]=dianshu;
			father[f2]=dianshu;
			add(dianshu,f1);
			add(dianshu,f2);
			f[0][f1]=dianshu;
			f[0][f2]=dianshu;
			a[dianshu]=_[i].w;
			can[dianshu]=(du[_[i].u]>=3||du[_[i].v]>=3||can[f1]||can[f2]); //若儿子被标记,则此点也需标记。若度>2,亦需标记。
			dianshu++;
		}
	}
	for(i=dianshu-1;i>=0;i--){
		if(!depth[i]){
			dfs(i,1);
		}
	}
	for(i=1;i<=logn;i++){
		for(j=0;j<dianshu;j++){
			if(depth[j]>(1<<i)){
				f[i][j]=f[i-1][f[i-1][j]];
			}
		}
	}
}
//加上下面的语句可将此题变为传统题,方便调试。
// vector<int> u,v,w;
// int main(){
// 	freopen("1.in","r",stdin);
// 	freopen("1.out","w",stdout);
// 	int n,m,q,i,A,B,C;
// 	cin>>n>>m;
// 	for(i=0;i<m;i++){
// 		cin>>A>>B>>C;
// 		u.push_back(A);
// 		v.push_back(B);
// 		w.push_back(C);
// 	}
// 	init(n,m,u,v,w);
// 	cin>>q;
// 	for(i=0;i<q;i++){
// 		cin>>A>>B;
// 		cout<<getMinimumFuelCapacity(A,B)<<endl;
// 	}
// 	return 0;
// } 
```

---

## 作者：天梦 (赞：0)

这道题不难想到用可持久化并查集做，但是我们考虑如何用 Kruskal 重构树来做。

首先，不难发现最终答案和 Kruskal 有一定关系，但是有可能答案比 Kruskal 大，而且我们在做 Kruskal 重构树的时候维护点集当前图是否为一条链。我们这样来做：

我们按照边权从小到大来做，然后我们考虑对于当前边两端的连通块，如果两端有一个不是链，那么我们可以把这条边的权值挂在这个点上，如果两端都是链，连起来之后不是，我们仍然这样做，否则我们什么都不做，维护这条链就行。如果一条边两边点属于同一个连通块，我们就更新当前 lca 上的答案即可。

然后我们从上面往下 dfs，如果父亲有值，儿子没有值，我们直接覆盖。

考虑这么做的正确性，当一个两个连通块合并为非链的时刻，当前的权值一定是最优的，否则不符合 Kruskal 重构树的性质，如果一直是链，到某一条边的时候不是链了，那么之前的答案也一定是这条边的权值。这就是为什么我们要把答案往下推。 

然后我们直接树剖，求 lca 就可以了。

代码：

```c++
#include<bits/stdc++.h>
// #include"swap.h"
#define dd double
#define ld long double
#define ll long long
#define uint unsigned int
#define ull unsigned long long
using namespace std;

const int maxn=200010;
const int INF=0x3f3f3f3f;

template<typename T> inline void read(T &x) {
    x=0; int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    x*=f;
}

struct edge{
    int from,to,next,w;
    inline void Init(int fr_,int to_,int ne_){
        from=fr_;to=to_;next=ne_;
    }
    inline bool operator < (const edge &b)const{return w<b.w;}
}li[maxn<<2],li2[maxn<<2];
int head[maxn],tail;

inline void Add(int from,int to){
    li[++tail].Init(from,to,head[from]);
    head[from]=tail;
}

int fa[maxn<<1],now,n,m;
int Ans[maxn<<1],P[maxn<<1][2],Tag[maxn<<1];

inline int Find(int x){return x==fa[x]?x:fa[x]=Find(fa[x]);}

inline bool IsNotThePoint(int p,int top){
    return p!=P[top][0]&&p!=P[top][1];
}

inline int OtherPoint(int p,int top){
    if(p==P[top][0]) return P[top][1];
    else return P[top][0];
}

inline void dfs(int k){
    for(int x=head[k];x;x=li[x].next){
        int to=li[x].to;
        if(Ans[k]&&!Ans[to]) Ans[to]=Ans[k];
        dfs(to);
    }
}

int Top[maxn],Dep[maxn],Size[maxn],Son[maxn],Fa[maxn];

inline void dfs1(int k,int fat){
    Dep[k]=Dep[fat]+1;Size[k]=1;Fa[k]=fat;
    for(int x=head[k];x;x=li[x].next){
        int to=li[x].to;
        dfs1(to,k);Size[k]+=Size[to];
        if(Size[Son[k]]<Size[to]) Son[k]=to;
    }
}

inline void dfs2(int k,int t){
    Top[k]=t;
    if(Son[k]) dfs2(Son[k],t);
    for(int x=head[k];x;x=li[x].next){
        int to=li[x].to;
        if(to==Son[k]) continue;
        dfs2(to,to);
    }
}

inline int GetLca(int a,int b){
    while(Top[a]!=Top[b]){
        if(Dep[Top[a]]<Dep[Top[b]]) swap(a,b);
        a=Fa[Top[a]];
    }
    if(Dep[a]>Dep[b]) swap(a,b);
    return a;
}

inline void Kruskal(){
    sort(li2+1,li2+m+1);
    for(int i=1;i<=(n<<1);i++){
        fa[i]=i;Tag[i]=-1;P[i][0]=P[i][1]=i;
    }
    for(int i=1;i<=m;i++){
        int faa=Find(li2[i].from),fab=Find(li2[i].to);
        if(faa==fab){
            if(Ans[faa]) continue;
            Tag[faa]=2;Ans[faa]=li2[i].w;
        }   
        else{
            now++;
            fa[faa]=now;fa[fab]=now;Add(now,faa);Add(now,fab);
            if(Tag[faa]==2||Tag[fab]==2||(IsNotThePoint(li2[i].from,faa)||IsNotThePoint(li2[i].to,fab))){
                if(Ans[now]) continue;
                Ans[now]=li2[i].w;Tag[now]=2;
            }
            else{
                P[now][0]=OtherPoint(li2[i].from,faa);
                P[now][1]=OtherPoint(li2[i].to,fab);
                Tag[now]=1;
            }
        } 
    }
    dfs(now);dfs1(now,0);dfs2(now,now);
}

void init(int N, int M, std::vector<int> U, std::vector<int> V, std::vector<int> W){
    n=N;m=M;
    for(int i=1;i<=M;i++){
        li2[i].from=U[i-1];li2[i].to=V[i-1];li2[i].w=W[i-1];
        li2[i].from++;li2[i].to++;
    }
    now=N;Kruskal();
}

int getMinimumFuelCapacity(int X, int Y){
    X++;Y++;
    int lca=GetLca(X,Y);
    return (!Ans[lca])?-1:Ans[lca];
}

// inline void Init(){
//     read(n);read(m);
//     for(int i=1;i<=m;i++){
//         read(li2[i].from);read(li2[i].to);read(li2[i].w);
//         li2[i].from++;li2[i].to++;
//     }
//     now=n;Kruskal();
// }

// int main(){
//     freopen("my.in","r",stdin);
//     freopen("my.out","w",stdout);
//     Init();
//     int Q;read(Q);
//     for(int i=1;i<=Q;i++){
//         int a,b;read(a);read(b);
//         a++;b++;
//         printf("%d\n",getMinimumFuelCapacity(a,b));
//     }
//     return 0;
// }
```



---


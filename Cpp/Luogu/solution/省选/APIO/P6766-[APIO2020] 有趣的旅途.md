# [APIO2020] 有趣的旅途

## 题目背景

由于官方数据包过大，本题仅评测部分数据。

本题仅支持 C++ 系列语言，提交时**不需要**包含 `fun.h` 头文件，但需要在程序开头声明 `int hoursRequired(int,int)` 以及 `int attractionsBehind(int,int)`。如果您不明白这是什么意思，也可以直接将 `fun.h` 中的内容粘贴到程序的开头。

交互库在程序非正常结束时可能会返回一些奇怪的信息。

如果交互库存在其他问题，请私信 mrsrz。

## 题目描述

雅加达最大的主题公园中有 $N$ 个景点，它们从 $0$ 到 $N -1$ 编号。这些景点由 $N-1$ 条双向道路连接，任意两个景点间经由这些道路将存在唯一一条简单路径。道路从 $0$ 到 $N - 2$ 编号。第 $i$ 条道路连接第 $A[i]$ 个景点与第 $B[i]$ 个景点，经过这条道路需要花费一个小时。为了避免拥塞，每个景点将至多与三条道路相连。

你想寻找一条游玩路线并使得每个景点都被参观一次。你认为从一个景点走到下一个景点时经过太多道路是十分无聊的。为了寻找一条有趣的路线，你打算安排景点的参观顺序，使得参观下一个景点所花费的时间不超过参观之前景点所花费的时间。换句话说，你想找到一个序列 $P[0], P[1],\dots, P[N - 1]$ 使其包含 $0$ 到 $N - 1$ 中的所有整数恰好一次，并且从第 $P[i]$ 个景点到达第 $P[i + 1]$ 个景点所需的时间不超过从第 $P[i - 1]$ 个景点到达第 $P[i]$ 个景点所需的时间，其中 $0 < i < N - 1$。

你手上没有景点的完整地图，因此你必须向信息中心进行若干次询问才能找到一条有趣路线。你最多能进行 $Q$ 次询问，每次询问需要提供两个参数 $X$ 和 $Y$ ，其中 $0 \leq X, Y < N$。每次询问是以下任意一种：

- 从第 $X$ 个景点到第 $Y$ 个景点需要花费多少个小时。特别地，若 $X = Y$ 则回答将是 $0$。

- 有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。第 $Y$ 个景点将会被计算在内，特别地，若 $X = Y$ 则回答将是 $N$。

你必须实现 `createFunTour` 函数：

- `createFunTour(N, Q)` - 该函数将被评测库恰好调用一次。
	- $N$：一个整数表示景点的数量。
	- $Q$：一个整数表示询问次数的最大值。
	- 该函数可以调用以下两个交互函数：
    	- `hoursRequired(X, Y)`
        	- $X$：一个整数表示第一个景点的编号。
			- $Y$：一个整数表示第二个景点的编号。
			- 该函数将返回一个整数表示从第 $X$ 个景点到第 $Y$ 个景点需要花费的小时数。
			- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。
		- `attractionsBehind(X, Y)`
			- $X$：一个整数表示第一个景点的编号。
            - $Y$：一个整数表示第二个景点的编号。
			- 该函数将返回一个整数表示有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。
			- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。
	- 该函数必须返回一个长为 $N$ 的整数序列，表示你找到的景点参观顺序。

## 说明/提示

在下图的例子中 $N = 7$，$Q = 400 000$，$A = [0, 0, 0, 1, 1, 2]$，$B = [1, 5, 6, 2, 4, 3]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/j8tmoxuo.png)

评测库将调用 `createFunTour(7, 400000)`。
- 如果你询问 `hoursRequired(3, 5)`，函数将返回 $4$。
- 如果你询问 `hoursRequired(5, 4)`，函数将返回 $3$。
- 如果你询问 `attractionsBehind(5, 1)`，函数将返回 $4$。从第五个景点到第一、二、三、四个景点将一定会经过第一个景点。
- 如果你询问 `attractionsBehind(1, 5)`，函数将返回 $1$。
- 一个符合要求的返回序列为 $[3, 6, 4, 5, 2, 0, 1]$，到达下一个参观景点所需的时间按顺序分别为 $[4, 3, 3, 3, 2, 1]$。

【条件限制】

- $2 \leq N \leq 100 000$。
- $Q = 400 000$。
- 任意两个景点间可以通过双向道路互相到达。
- 每个景点至多连接着三条道路。

【子任务 $1$（$10$ 分）】

- $N \leq 17$。

【子任务 $2$（$16$ 分）】

- $N \leq 500$。

【子任务 $3$（$21$ 分）】

- 对所有的 $1 \leq i < N$，有一条连接着第 $i$ 个景点与第 $\lfloor \dfrac{i-1}{2} \rfloor$
个景点的双向道路。

【子任务 $4$（$19$ 分）】

存在至少一个景点 $T$ 使得对于所有 $0 \leq i < N$，`hoursRequired(T, i)` $<30$ 并且存在一个整数区间 $[L[i], R[i]](0 \leq L[i] \leq i \leq R[i] < N)$ 满足下列条件：

- 从第 $T$ 个景点到达第 $j$ 个景点必须经过第 $i$ 个景点当且仅当 $L[i] \leq j \leq R[i]$。

- 若 $L[i] < i$，则恰有一个景点 $X$ 满足：
	- $L[i] \leq X < i$。
	- 有一条连接第 $i$ 个景点与第 $X$ 个景点的道路。   
- 若 $i < R[i]$，则恰有一个景点 $Y$ 满足：
	- $i < Y \leq R[i]$。
	- 有一条连接第 $i$ 个景点与第 $Y$ 个景点的道路。

【子任务 $5$（$34$ 分）】
- 无附加限制。

## 样例 #1

### 输入

```
7 400000
0 1
0 5
0 6
1 2
1 4
2 3
```

### 输出

```
3 6 4 5 2 0 1
```

# 题解

## 作者：幻影星坚强 (赞：9)

时隔多月重见此题，~~发现没有题解~~发现其实考场上的思路是对的把重心当成根就好了（）

- **思路**

我们一开始并不能确定根节点是哪里所以我们先不去管它。

假设我们找到了一个根节点，并且它的度数为2，我们考虑怎么做。

一个显然的想法，我们每次从它的左右两个子树中选取深度最大的一个，因为总路程可以看成一个子树->根->另一个子树，而因为对于每一个子树里我们选取的深度都是不增的，所以一个子树->根与根->另一个子树的值都是不增的，总路程也是不增的。

现在的问题是如何找到这样的一个根。我们发现每两次操作都会使两棵子树大小各减一，而如果一个子树的大小与另一颗子树的大小相差2及以上，那么在最后就只会剩下根->子树，我们不能保证有一个合适的方案使其在路程小于等于之前的同时走的路程不增，所以最好的办法是让一个子树的大小与另一颗子树的大小相差1及以下，所以我们可以知道选择的点是重心。

以上是重心度数为2的情况下，我们可以选择重心为根，接下来考虑重心的度数是3该怎么处理。

因为重心的子树大小不会超过 $\left\lfloor\dfrac{n}{2}\right\rfloor$，所以如果其中有一个子树大于等于其他两个子树的和，那么它的大小一定是$\left\lfloor\dfrac{n}{2}\right\rfloor$，我们可以将剩下的两棵子树看成一棵子树来处理。这就成了度数为2的情况。

而如果最大的子树大小小于剩余两个的和，那么我们每次从非上一次选的子树中选择一个最大的（第一次可任意选），这样也能保证路程递减，如图

![](https://cdn.luogu.com.cn/upload/image_hosting/8rmqef6l.png)

一开始先从黄边走到第三棵子树如果接下来走蓝边的话就和度数为2的情况下一样必然是不增的，假如走红边我们可以用反证法，如果它的长度比第一棵子树里的黄边大，那么它们的长度顺序为第一棵子树黄$<$边第二棵子树红边$<$第三棵子树黄边，那么第一棵子树黄边则是最短的，那么之前第一棵子树的黄边肯定不会选到，选择的节点会在第二棵和第三棵子树之间，他们的深度一定大于第一棵子树的黄边，所以不成立，即第一棵子树黄$>$边第二棵子树红边。

我们可以按照这样的方式进行选择，每次都会在最大的子树和剩下的两个子树里交替选择，而剩下的两个子树也可以交替选择，所以剩余两个子树的和$-$最大的子树大小会不断变小($\Delta$前者的大小始终会$\ge$$\Delta$后者的大小),最终他们会相等,这时就可以将剩余两个子树合并起来,成为度数为2的情况

（有一处细节在代码里）

```cpp
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
int hoursRequired(int X, int Y);
int attractionsBehind(int X, int Y);
std::vector<int> createFunTour(int N, int Q);
const int N = 1e5 + 10;
int siz[N], dep[N];
int b[3], tot;
std::vector<pair<int, int> >q[7];
std::vector<int>ans;
int root;
void merge()
{
	while(q[2].size())
	{
		q[1].push_back(q[2][q[2].size() - 1]);
		q[2].pop_back();
	}
	sort(q[1].begin(), q[1].end());
}

void br2()
{
	while(q[0].size() + q[1].size())
	{
		pair<int, int>now = q[0][q[0].size() - 1];
		q[0].pop_back();
		ans.push_back(now.second);
		q[0].swap(q[1]);
	}
	ans.push_back(root);
}

int C(int a, int b, int c)
{
	return a + b + c - max(a, max(b, c));
}
int nn;
void br3()
{
	if(q[0].size() == nn / 2)
	{
		merge();
		if(q[0].size() < q[1].size())
		q[0].swap(q[1]);
		br2();
		return;
	}
	int flag = 0;
	while(1)
	{
		int to = flag;
		for (int i = flag + 1; i <= 2; ++ i)
		{
			if(q[i][q[i].size() - 1] >= q[to][q[to].size() - 1])
			to = i;
		}
		flag = 1;
		pair<int, int>maxs = q[to][q[to].size() - 1];
		ans.push_back(q[to][q[to].size() - 1].second);
		q[0].swap(q[to]);
		q[0].pop_back();
		if(max(max(q[0].size(), q[1].size()), q[2].size()) == C(q[0].size(), q[1].size(), q[2].size()))
		{
			int now = 0;
			if(q[0].size() < q[1].size())
			q[0].swap(q[1]), now = 1;
			if(q[0].size() < q[2].size())
			q[0].swap(q[2]), now = (now == 0 ? 2 : now);
			if(now != 0)
			{
				if(maxs < q[((now - 1) ^ 1) + 1][q[((now - 1) ^ 1) + 1].size() - 1])
				ans.push_back(q[((now - 1) ^ 1) + 1][q[((now - 1) ^ 1) + 1].size() - 1].second), q[((now - 1) ^ 1) + 1].pop_back();
			}
        //此处注意，假如合并的两个子树中有一个是最近选择的，另一个子树的最大深度大于这个，那么要再选择一次，否则合并后下一次选择的深度就不能保证不增了
			merge();
			if(now == 0)
			q[0].swap(q[1]);
			br2();
			return;
		}
	}
	ans.push_back(root);
}

std::vector<int> createFunTour(int n, int Q)
{
	nn = n;
	for (int i = 0; i < n; ++ i)
	{
		siz[i] = attractionsBehind(0, i);
	}
	for (int i = 0; i < n; ++ i)
	{
		if(siz[i] > (n >> 1) && siz[i] < siz[root])
		root = i;
	}
	for (int i = 0; i < n; ++ i)
	{
		if((dep[i] = hoursRequired(root, i)) == 1)
		{
			b[tot] = i;
			++ tot;
		}
	}
	-- tot;
	for (int i = 0; i < n; ++ i)
	{
		if(i != root)
		{
			int to = 0;
			for (int j = 1; j <= tot; ++ j)
			{
				if(hoursRequired(b[j], i) <= dep[i])
				to = j;
			}
			q[to].push_back(make_pair(dep[i], i));
		}
	}
	for (int i = 0; i <= tot; ++ i)
	{
		sort(q[i].begin(), q[i].end());
		printf("%d\n", q[i][0].second);
	}
	if(tot == 1)
	{
		if(q[0].size() < q[1].size())
		q[0].swap(q[1]);
		br2();
	}
	else
	{
		if(q[0].size() < q[1].size())
		q[0].swap(q[1]);
		if(q[0].size() < q[2].size())
		q[0].swap(q[2]);
		br3();
	}
	return ans;
}
```


---

## 作者：vectorwyx (赞：6)

一个重要的问题是怎么利用好子树大小这个信息，这指引我们去想**重心**。考虑求出重心作为根，先特判掉它只有一颗子树（$n=2$）的情况。如果它有两棵子树，这两棵子树大小之差一定 $\le 1$。那么从较大的一颗子树内开始，交替选取每棵子树中最深的结点即可。如果它有三棵子树，选取最深的一个结点作为起点，每次从其它子树中选取最深的一个跳过去，在只剩一颗子树之前这样跳出来的序列一定合法。证明考虑一个引理：令 $P_i$ 表示 $p_i$ 所属的子树，对于任意的 $i$，如果 $j>i$ 且 $P_j\not=P_i,P_{i-1}$ 则 $dep_{p_i}\ge dep_{p_j}$。然后对每个 $i$ 看看它下两步的抉择 $p_i,p_{i+1},p_{i+2}$，只需证明 $dep_{p_i}\ge dep_{p_{i+2}}$。$i=1$ 时显然。如果 $p_i$ 与 $p_{i+2}$ 同子树那么有 $dep_{p_{i+2}}\le dep_{p_i}$。如果 $p_i,p_{i+2}$ 不同子树且 $P_{i+2}\not= P_{i-1}$ 那么根据引理得证。剩下的情况只有 $P_{i-1}=P_{i+2}\not= P_i$。此时 $P_{i-1},P_i,P_{i+1}$ 互不相同，$P_{i},P_{i+1},P_{i+2}$ 也互不相同。那么由引理得 $dep_{p_i}\ge dep_{p_{i+1}}$，同理 $dep_{p_{i+1}}\ge dep_{p_{i+2}}$，命题得证。

这样构造的问题在于，中途可能会出现只剩下一颗子树非空的情况，这时对于正确性的分析就失效了，因为 $P_i$ 不一定不等于 $P_{i+1}$。不过我们可以证明：在正确性失效前一定存在一个时刻，使得最大的子树的大小与其余子树的大小之和相等，此时把其余子树视为一棵子树套用两棵子树的做法即可。记 $f$ 为最大的那棵子树的大小与其余子树的总大小之差（$2\max-\mathit{cnt}$），由重心的性质知初始时 $f\le 1$。如果 $f=1$ 的话可以直接视为两颗子树，特判掉。现在有 $f\le 0$，然后每次删一个点对于 $\max$ 的影响只有可能是 $0,-1$ 两种，而 $\mathit{cnt}$ 的变化一定是 $-1$，所以 $f$ 的变化量是 $\pm 1$。不合法的局面一定有 $f\ge 1$，那么中途一定存在一个时刻满足 $f=0$。命题得证。

于是我们构造出的序列最终由两部分拼接而来，这两部分的内部都满足条件，接壤处的处理有诸多细节。不妨令这两部分的长度都大于等于 $2$（否则接壤处的限制会更少）。假设第一部分的后两个元素依次是 $x,y$。第二部分的前两个元素依次是 $s,t$。首先 $y,s$ 不能同属一棵子树（条件一），其次 $dep_{s}\le dep_x$（条件二），$dep_t\le dep_y$（条件三）。由于第二部分是交替选最深的结点所以 $s,t$ 的取值已确定，自由的只有顺序。分类讨论（下面视 $a=b$ 当且仅当 $a,b$ 同属一棵子树，注意第一部分中的引理还是生效的）：

* 如果 $s,t$ 中有一个等于 $y$。不妨设 $t=y$。则条件一、三均被满足。对于条件二，如果 $s=x$ 则成立。否则 $s\not=x,s\not=y\to dep_y\ge dep_s$，考虑 $ x$ 的前一个元素 $z$，如果它不等于 $s$ 那么 $z,x\not= s$ 由引理知 $dep_x\ge dep_s$；否则 $z,x\not= y\to dep_x\ge dep_y\ge dep_s$。
* 如果 $s,t\not=y$，那么 $s,t$ 中一定有且仅有一个元素等于 $x$，不妨设为 $s$。则条件一、二均被满足。对于条件三，$t\not=x,y\to dep_y\ge dep_t$，条件三成立。 

不过我们到现在好像还没用到度数 $\le 3$ 的限制啊？实际上这个限制是用来约束询问次数的，因为你需要对于每个点判断它属于哪颗子树，这需要 $(D-1)(n-1)$ 次询问（$D$ 为根的子树数量），然后找重心需要 $n-1$ 次询问子树大小，求深度需要 $n-1$ 次询问。总询问次数看起来是 $2n-2+(D-1)(n-1)\le 4n-4$。

代码如下（码字不易，希望能给个赞QAQ）：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
//#include "fun.h"
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){signed ch=getchar();int x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

int hoursRequired(int,int);
int attractionsBehind(int,int);
#define dis(i,j) (hoursRequired(i-1,j-1))
#define siz(i,j) (attractionsBehind(i-1,j-1))
#define heap __gnu_pbds::priority_queue<pii>

const int N=1e5+5,D=3;
int dep[N],p[D],id,bel[N],mp[N],lst;
vector<int> ans;

void solve(heap &x,heap &y){
	if(x.empty()) re;
//	puts("ok");
	if(ans.size()==1){
		if(bel[x.top().se]==bel[ans[0]]) swap(x,y);
	}else if(!ans.empty()){
		int si=(int)ans.size();
		int X=bel[ans[si-2]],Y=bel[ans[si-1]];
		if(Y==bel[x.top().se]) swap(x,y);
		if(Y!=bel[y.top().se]){
			if(X!=bel[x.top().se]) swap(x,y);			
		}
	}
	while(1){
		if(x.empty()) re;
//		int X=x.top().se;printf("bel[%d]=%d dep=%d\n",X,bel[X],dep[X]);
		ans.eb(x.top().se);x.pop();
		if(y.empty()) re;
//		int Y=y.top().se;printf("bel[%d]=%d dep=%d\n",Y,bel[Y],dep[Y]);
		ans.eb(y.top().se);y.pop();
	}
}

#define print ans.eb(rt);for(int &i:ans) i--;re ans

std::vector<int> createFunTour(int n, int vcw) {
	if(n==2){
//		ans[0]=0,ans[1]=1;
		ans.eb(0),ans.eb(1);
		re ans;
	}
	int rt=1,mn=n;
	fo(i,2,n){
		int si=siz(1,i);
		if(n-si<=n/2&&mn>si) mn=si,rt=i;
	}
	fo(i,1,n) if(i!=rt){
		dep[i]=dis(rt,i);
		if(dep[i]==1) p[id]=i,mp[i]=id++;
	}
	heap q[D];
	fo(i,1,n) if(i!=rt){
		fo(j,1,id-1) if(1+dis(p[j],i)==dep[i]){bel[i]=j;brk;}
		q[bel[i]].push(mk(dep[i],i));
	}
	{
		int x=(int)q[0].size(),y=(int)q[1].size(),z=(int)q[2].size();
//		printf("%d,%d,%d\n",x,y,z);
		if(x>=y+z){q[1].join(q[2]),solve(q[0],q[1]);print;}
		if(y>=x+z){q[0].join(q[2]),solve(q[1],q[0]);print;}
		if(z>=x+y){q[0].join(q[1]),solve(q[2],q[0]);print;}
	}
	fo(i,1,id-1) if(q[i].top().fi>q[lst].top().fi) lst=i;
	ans.eb(q[lst].top().se);q[lst].pop();
	while(1){
		if(q[0].empty()&&q[1].empty()&&q[2].empty()) brk;
		int x=(int)q[0].size(),y=(int)q[1].size(),z=(int)q[2].size();
//		printf("lst=%d x=%d y=%d z=%d\n",lst,x,y,z);
		if(x==y+z){q[1].join(q[2]);solve(q[0],q[1]);print;}
		if(y==x+z){q[0].join(q[2]);solve(q[1],q[0]);print;}
		if(z==x+y){q[0].join(q[1]);solve(q[2],q[0]);print;}		
//		fo(i,0,id-1) if()
		int pos=-1,mx=-1;
		fo(i,0,id-1) if(!q[i].empty()&&i!=lst&&q[i].top().fi>mx) mx=q[i].top().fi,pos=i;
		lst=pos;
//		printf("pos=%d dep=%d\n",q[lst].top().se,q[lst].top().fi);
		ans.eb(q[lst].top().se);q[lst].pop();	
	}
	print;
}
/*
-------------------------------------------------
*/
```



---

## 作者：y_dove (赞：4)

- 首先我们考虑是否可以在$4n$次操作内将树还原出来,然后接下来就可以通过维护直径等方法通过这道题
- 但是很遗憾,我不会$O(n^2)$以下的做法,也许有$O(n\log n)$,但也无法满足$4e5$次的询问要求
- 我们真的需要知道这棵树长什么样吗$?$
- 考虑假设我们知道这棵树长什么样,我们可以怎么做
- 找重心,注意此时不同的子树$siz \leq floor(\frac{n}{2})$
- 假设度数只有$2$,那么显然轮流选不同的子树中**深度最大**的点就可以了
- 若度数等于$3$,(题目保证任意点度数$\leq 3$),那么我们可以每次选**和上一个子树不同的子树中**最深的点,**并将其删去**那么一定存在一个时刻使得最大的子树等于其余子树的和,那么按上面的方法轮流选即可
- 为什么这样是对的呢$?$考虑我们这个构造方法如果不满足题目要求会是什么情况,即只剩一个子树不为空,**那么我们只需证明在这种情况来临前,一定会存在某一时刻使得最大的子树等于其余子树大小的和即可**
### $proof$
考虑设函数$V:Tree->N,V(T) = 2 * maxsize - sum$

注意到初始时由重心定义,$V(T) \leq 0$

若只剩一个子树不为空那么显然$V(T) > 0$

如果初始时$V(T) = 0$,那么由于情况比较特殊,我们可以直接从取最大子树中最深的点转化为$V(T) = -1$

否则,注意到若存在一个时刻最大的子树等于其余子树的和,那么$V(T) = -1$

注意到按我们上述的方法,每进行一次操作,$|\Delta V(T)| \leq 1$,即这个函数在整值上是连续的,所以若从$<0$变成$>0$一定会经过$V(T) = -1$这一个点,证明完毕
- 那么我们发现,根据这种方法,我们真的需要知道整棵树长什么样吗$?$
- 我们只需知道以下几点
- 树的重心,并以它为根----$(1)$
- 每个点的深度----$(2)$
- 每个点在根的哪个子树内----$(3)$
- 考虑如何构造,注意到题目中提供第二种交互操作``attractionsBehind(int X, int Y)``可以知道以$x$为根,$y$的子树的大小,于是我们可以以$0$为根,得到$\forall i,siz(i)$,那么满足$n - siz_i \leq floor(\frac{n}{2})$且$siz_i$最小的$i$即为重心,这步需要消耗的操作是$n$
- $(2)$操作是显然的,也要花费$n$
- 然后接下来是$(3)$操作,这个比较复杂,我们考虑最差情况有$3$个儿子,$p_1,p_2,p_3$可以通过询问$dis(p_j,i)$和$dep_j$作比较来判断$i$是否在$p_j$的子树内,但很遗憾如果直接这样做是$3 * n$的,和前面加起来就等于$5 * n \ge 4e5$
- 但是假设我们设$siz_{p_1} = a,siz_{p_2} = b,siz_{p_3} = c$,按顺序询问,然后如果确定了就$break$,那么询问次数就是$a * 1 + b * 2 + c * 3$,根据排序不等式,如果我们将$p_j$按照子树大小降序排序,那么是反序和以达到最小值,以最极端的情况来算,是$a = b = c = \frac{n}{3}$,那么取到最差情况即$\frac{n}{3} * (1 + 2 + 3) = 2 * n$,$2 * n + n + n = 4 * n \leq 4e5$,可以卡着询问次数通过本题
- 有一些细节详见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int hoursRequired(int X, int Y);
int attractionsBehind(int X, int Y);
vector<int> createFunTour(int N, int Q);
vector<int>ans;
const int _ = 1e5 + 7;
int dep[_],siz[_];
typedef pair<int,int> pii;
#define mp make_pair
#define pb push_back
#define fi first
#define se second
priority_queue<pii>s[4];
bool cmp(int x,int y){
	return siz[x] > siz[y];
}
int opp(int x){
	return (x == 1)?2:1;
}
bool cmps(int x,int y){
	return s[x].size() > s[y].size();
}
vector<int> createFunTour(int n, int q){
	int rt = -1;
	siz[0] = n;
	for(int i = 1; i < n; ++i)		siz[i] = attractionsBehind(0,i);
	for(int i = 0; i < n; ++i){
		if(n - siz[i] > n / 2)	continue;
		if(rt == -1 || siz[rt] > siz[i])		rt = i;
	}
	for(int i = 0; i < n; ++i)		dep[i] = hoursRequired(rt,i);
	static int p[4];memset(p,0,sizeof(p));
	int tot = 0;
	for(int i = 0; i < n; ++i){
		if(dep[i] == 1)		p[++tot] = i,siz[i] = attractionsBehind(rt,i);
	}
	sort(p+1,p+tot+1,cmp);
	for(int i = 0; i < n; ++i){
		for(int j = 1; j <= tot; ++j){
			if(hoursRequired(p[j],i) + 1 == dep[i]){
				s[j].push(mp(dep[i],i));
				break;
			}
		}	
	}
	int Last = -1;
	p[1] = 1,p[2] = 2,p[3] = 3;
	for(int k = 1; k < n; ++k){
		sort(p+1,p+tot+1,cmps);
		if(k == 1 && s[p[1]].size() == s[p[2]].size() + s[p[3]].size() + 1){
			Last = p[1];
			ans.pb(s[p[1]].top().se) ;
			s[p[1]].pop();
			continue;
		}
		if(s[p[1]].size() == s[p[2]].size() + s[p[3]].size() || s[p[3]].size() == 0){
			int lst = 1,now = 2;
			int T = s[p[1]].size() + s[p[2]].size() + s[p[3]].size();
			if(Last == -1){
				if(s[p[now]].size() < s[p[lst]].size())	swap(now,lst);				
			}
			else{
				if(Last == p[1])	now = 2;
				else{
					if(s[p[3]].size() && s[p[2]].top().fi < s[p[3]].top().fi)		swap(p[2],p[3]);
					if(Last == p[1])	now = 2;
					else{
						now = 1;
						if(Last == p[3]){
							if(s[p[2]].size()){
								T--;
								ans.pb(s[p[2]].top().se);
								s[p[2]].pop();
							}
						}
					}
				}
			}
			while(s[p[3]].size()){
				pii nxt = s[p[3]].top();
				s[p[3]].pop();
				s[p[2]].push(nxt);
			}
//			if(Last == p[2] || Last == p[3])	now = 1;
//			else if(Last == p[1])	now = 2;
			while(T--){
				ans.pb(s[p[now]].top().se);
				s[p[now]].pop();
				now = opp(now);
			}
			break;	
		}
		else{
			int now = -1;
			for(int i = 1; i <= tot; ++i){
				if(Last == i)	continue;
				if(now == -1 || s[now].top().fi < s[i].top().fi){
					now = i;
				}
			}
			Last = now;
			ans.pb(s[now].top().se);
			s[now].pop();
		}
	}
	ans.pb(rt);
//	assert(ans.size() == n);
	return ans;
}
```

---

## 作者：Corzica (赞：1)

先考虑一个子问题，如果现在给一棵指定形态的树，怎么去构造这个序列。

不难想到可以把根的每一棵子树中的点的深度提取出来，从大到小排序，每一次取最靠前且不和自身在一个子树内的点作为后继，根节点放在最后。

但是这样有一个问题，如果有一个子树的大小远远大于其他的点怎么办？答案是显然的，我们要找出这个树的重心作为根节点，重心的最大子树的大小不超过总结点数的一半，这样我们总是能够保证能构造出来这样的序列。

我们得到这些信息需要 $n-1$ 次的全体查询深度。因为度数小于等于 $3$，所以根下面最多只有 $3$ 个子树。在对每一个节点搞 $2$ 次询问确定在哪一个子树，总的询问次数是 $3(n-3)$。

现在的问题是在剩下的 $n$ 次询问内求出这个树的重心。先钦定一个根，对于重心而言，满足子树外节点数量小于等于总结点数的一半，我们找出所有满足这种条件的点。对于这些点来说，如果不是重心，说明有一个子树的大小大于总点数一半。而重心就在那棵子树内，所以我们找所有这种点中 $siz$ 最小的即可。

实现的时候要注意子树的大小，一旦最小的两个子树大小等于最大的那个，要把子树进行合并再去处理。

```cpp
#include "fun.h"
#include <bits/stdc++.h>
using namespace std;
int hoursRequired(int X, int Y);
int attractionsBehind(int X, int Y);
vector<pair<int, int>> a[5];
int n, maxa, maxb, d[100005], c[5], cnt, name[100005];
std::vector<int> createFunTour(int N, int Q) {
	n = N;
	if (n <= 2) {
		vector<int> v;
		for (int i = 0; i < n; i++) v.push_back(i);
		return v;
	}
	maxa = n, maxb = 1;
	int op;
	for (int i = 2; i <= n; i++) {
		op = attractionsBehind(0, i - 1);
		if (n - op <= (n / 2) && op < maxa) {
			maxa = op, maxb = i;
		}
	}
	for (int i = 1; i <= n; i++) {
		if (i == maxb) continue;
		d[i] = hoursRequired(i - 1, maxb - 1);
		if (d[i] == 1) c[++cnt] = i, name[i] = cnt;
	}
	for (int i = 1; i <= n; i++) {
		if (i == maxb) continue;
		if (d[i] == 1) {
			a[name[i]].push_back(make_pair(1, i));
			continue;
		}
		for (int j = 1; j < cnt; j++) {
			if (hoursRequired(i - 1, c[j] - 1) == d[i] - 1) {
				name[i] = name[c[j]];
				break;
			}
		}
		if (!name[i]) name[i] = cnt;
		a[name[i]].push_back(make_pair(d[i], i));
	}
	for (int i = 1; i <= cnt; i++) sort(a[i].begin(), a[i].end());
	for (int i = 2; i <= cnt; i++) {
		if (a[i].size() > a[1].size()) swap(a[i], a[1]);
	}
	a[cnt].push_back(make_pair(0, maxb));
	sort(a[cnt].begin(), a[cnt].end());
	for (int i = 2; i <= cnt; i++) {
		if (a[i].size() > a[1].size()) swap(a[i], a[1]);
	}
	if (a[1].size() == a[2].size() + a[3].size() && cnt == 3) {
		for (pair<int, int> i : a[3]) a[2].push_back(i);
		sort(a[2].begin(), a[2].end());
		cnt--;
	}
	int cur = 0, opp;
	int er = -1,  err = -1;
	for (int j = 1; j <= cnt; j++) {
		if (a[j].size() == 0 || j == cur) continue;
		if (a[j][a[j].size() - 1].first > er) {
			er = a[j][a[j].size() - 1].first;
			err = j;
		}
	}
	cur = err;
	vector<int> ans;
	for (int i = 1; i <= n; i++) {
		ans.push_back(a[cur][a[cur].size() - 1].second - 1);
		opp = a[cur][a[cur].size() - 1].first;
		a[cur].pop_back();
		er = -1,  err = -1;
		if (i == n) break;
		for (int j = 2; j <= cnt; j++) {
			if (a[j].size() > a[1].size()) {
				swap(a[j], a[1]);
				if (cur == j) cur = 1;
				else if (cur == 1) cur = j;
			}
		}
		if (a[1].size() == a[2].size() + a[3].size() && cnt == 3) {
			if (cur == 2) swap(a[2], a[3]);
			if (a[2].size()) {
				if (opp < a[2][a[2].size() - 1].first) {
					ans.push_back(a[2][a[2].size() - 1].second - 1);
					a[2].pop_back();
					i++;
				}
			}
			for (pair<int, int> i : a[3]) a[2].push_back(i);
			sort(a[2].begin(), a[2].end());
			cur = 2;
			cnt--;
		}
		if (i == n) break;
		for (int j = 1; j <= cnt; j++) {
			if (a[j].size() == 0 || j == cur) continue;
			if (a[j][a[j].size() - 1].first > er) {
				er = a[j][a[j].size() - 1].first;
				err = j;
			}
		}
		cur = err;
	}
//	for (int i : ans) cout << i << " ";
	return ans;
};

```

---


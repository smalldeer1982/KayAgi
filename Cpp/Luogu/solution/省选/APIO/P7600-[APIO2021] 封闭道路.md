# [APIO2021] 封闭道路

## 题目背景

本题只支持 C++ 提交，提交时不需要包含 `roads.h` 头文件，只需要将附件中的 `roads.h` 中的内容粘贴到代码的开头即可。



## 题目描述

在泗水市，有 $N$ 个路口（编号从 $0$ 到 $N-1$）。这些路口由 $N-1$ 条双向道路连接（编号从 $0$ 到 $N-2$），因此通过这些道路，任意一对路口之间都有一条唯一的路径。$i$ 号道路（$0 \le i \le N-2$）连接着 $U[i]$ 号和 $V[i]$ 号路口。

为了提高环保意识，泗水市长 Pak Dengklek 计划举办无车日。为了鼓励该活动，Pak Dengklek 将组织封路。Pak Dengklek 将首先选择一个非负整数 $k$，然后封闭一些道路，以使每个路口只能直接连接至多 $k$ 条未封闭的道路。封闭 $i$ 号道路的成本为 $W[i]$。

请你帮助 Pak Dengklek 对每个可能的非负整数 $k$（$0 \le k \le N-1$）计算封闭道路的最低总成本。

你需要实现下列函数：

`int64[] minimum_closure_costs(int N, int[] U, int[] V, int[] W)`

- $N$：泗水市的路口数量。

- $U$ 和 $V$：大小为 $N-1$ 的数组，其中 $U[i]$ 号路口和 $V[i]$ 路口通过 $i$ 号道路直接连接。

- $W$：大小为 $N-1$ 的数组，其中封闭 $i$ 号道路的成本为 $W[i]$。

- 该函数需要返回一个大小为 $N$ 的数组。对每个 $k$（$0 \le k \le N-1$），$k$ 号元素是使得每个路口与至多 $k$ 条未封闭道路直接连接的最低总成本。

该函数将被调用恰好一次。

## 说明/提示

## 例子

### 例子 $1$

考虑如下调用:

`minimum_closure_costs(5, [0, 0, 0, 2], [1, 2, 3, 4], [1, 4, 3, 2])`

这个例子中共有 $5$ 个路口和 $4$ 条道路，分别连接着路口 $(0,1),(0,2),(0,3)$ 和 $(2,4)$，封闭它们的成本依次为 $1,4,3$ 和 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/k3z9vmxl.png)

为了得到最低的总成本：

- 如果 Pak_Dengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $1+4+3+2=10$；
- 如果 Pak_Dengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $1$ 号道路，总成本为 $1+4=5$；
- 如果 Pak_Dengklek 选择 $k=2$，那么需要封闭 $0$ 号道路，总成本为 $1$；
- 如果 Pak_Dengklek 选择 $k=3$ 或 $k=4$，那么没有道路需要封闭。

因此，`minimum_closure_costs` 应该返回数组 $[10,5,1,0,0]$。

### 例子 $2$

考虑如下调用：

`minimum_closure_costs(4, [0, 2, 0], [1, 0, 3], [5, 10, 5])
`

这个例子中共有 $4$ 个路口和 $3$ 条道路，分别连接着路口 $(0,1),(2,0)$ 和 $(0,3)$，封闭它们的成本依次为 $5,10$ 和 $5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9fdtl4aj.png)

为了得到最低的总成本:

- 如果 PakDengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $5+10+5=20$；
- 如果 PakDengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $2$ 号道路，总成本为 $5+5=10$；
- 如果 PakDengklek 选择 $k=2$，那么需要封闭 $0$ 号道路或 $2$ 号道路，总成本为 $5$；
- 如果 PakDengklek 选择 $k=3$，那么没有道路需要封闭。

因此，minimum_closure_costs 应该返回数组 $[20,10,5,0]$。

## 约束

- $2 \le N \le 10^5$
- $0 \le U[i],V[i] \le N-1$ $(0 \le i \le N-2)$
- 任意一对路口可以通过道路互相到达。
- $1 \le W[i] \le 10^9$ $(0 \le i \le N-2)$。

## 子任务
1. (5 分) $U[i]=0$ $(0 \le i \le N-2)$
2. (7 分) $U[i]=i$，$V[i]=i+1$ $(0 \le i \le N-2)$
3. (14 分) $N \le 200$
4. (10 分) $N \le 2000$
5. (17 分) $W[i]=1$ $(0 \le i \le N-2)$
6. (25 分) $W[i] \le 10$ $(0 \le i \le N-2)$
7. (22 分) 无附加限制

## 样例 #1

### 输入

```
5
0 1 1
0 2 4
0 3 3
2 4 2
```

### 输出

```
10 5 1 0 0
```

## 样例 #2

### 输入

```
4
0 1 5
2 0 10
0 3 5
```

### 输出

```
20 10 5 0
```

# 题解

## 作者：y_dove (赞：11)


感觉是整场考试中思维最简单的一题

考场写了 $O(n(\sqrt n + \log n))$ ,在 luogu 和 uoj 都是73,~~然后可能是因为没打.h~~,在 CCF 上爆零了,然后喜提铜牌

此处做法的复杂度是 $O(n\log n)$ 的,在 luogu 上跑了440ms左右,还是挺快的
## solution
首先我们考虑朴素 dp 怎么做,方便起见,以下我们都计算允许每个点保留 k 条边,最大的边权和,容易发现这个和答案刚好是互补的,最后用总数减一下即可

我们注意到每个 k 之间, dp 是没有关联的,考虑 $dp1_u$ ,为 $u$ 的子树内(**注意这里不考虑与父亲节点的边是否选择**),所有点都选了不超过 k 条边, u 选了 k 条边的最优方案, $dp2_u$ 表示 u 的子树内,所有点都选了不超过 k 条边, u 选了 **k-1条边** 的最优方案,这里可以理解为剩下的那条边要连到父亲


考虑如何转移,我们考虑贪心的转移,首先,假设我们一条边都不选,答案显然是 $\sum_{v \in son(u)}{dp1_v}$ ,接下来我们有 **k** 次反悔的机会,每次可以选一条边,那么贡献就是 $w + dp2_v - dp1_v$ ,我们设它为 $f_v$ ,那么 $dp1_u = \max(\sum_{v \in son(u)}{dp1_v}$ + (至多$k$个$f_v))$, $dp2_u$ 则是至多 k-1 个 $f_v$


容易用排序做到 $O(n^2\log n)$

考虑单 $\log$ 怎么做,我们不妨先分析点性质



定义:假设我们当前在计算允许保留$k$条边,一个点被定义为无用的,当且仅当degree(v)(以下简称$deg_v$) $\leq k$

首先我们注意到无用点和无用点之间的边我们无需决策,是一定可以选的,这部分贡献我们可以事先用差分来预处理
```cpp
for(int u = 0; u < N; ++u)
    for(auto v:E[u]){
        int o = max(deg[u],deg[v]);
        F[o] += w; 
    }
for(int i = 1; i < N; ++i)  F[i] += F[i-1];
```

考虑有用点 u 和无用点 v 之间的决策,我们发现如果一个点成为了无用点,那么在之后,其贡献将一直不变,保持为 w(u,v) ,那么我们可以考虑用一个堆来维护.

那么我们每次可以只计算有用点和有用点之间的贡献,不够的再直接用无用点的堆的前缀和来补充
- 此部分代码如下(注意此处无需考虑父子关系)
```cpp
void _delete(int u){
	for(auto now:E[u]){
		int v = now.fi,w = now.se;
		q[v].push(-w);Sw[v] += w;
	}
}
```

那么我们可以发现,对于每个 k ,我们只需保留 $deg \ge k$ 的点形成的森林来遍历,我们可以先在邻接表上按度数排序,用 vector 的 pop_back 和双指针来删除点.

这样做的复杂度看起来很暴力,但是实际上我们可以分析,一个点至多只会被遍历度数次,而所有的点的度数和是线性级别的,加上堆和排序的复杂度,总复杂度就是 $O(n \log n)$


有一些细节,详见代码


时间复杂度 $O(n\log n)$ ,空间复杂度 $O(n)$ 


代码如下

```cpp
#include<bits/stdc++.h>
std::vector<long long> minimum_closure_costs(int N, std::vector<int> U,
                                             std::vector<int> V,
                                             std::vector<int> W);
using namespace std;
int read(){
	char c = getchar();
	int x = 0;
	while(c < '0' || c > '9')	c = getchar();
	while(c >= '0' && c <= '9')	x = x * 10 + c - 48,c = getchar();
	return x;
}
const int _ = 1e5 + 7;
int deg[_];int n;
#define ll long long
#define mp make_pair
#define fi first
#define se second
#define pb push_back 
typedef pair<int,int> pii;
vector<pii>E[_];
vector<ll>F;
vector<int>Ver;
bool cmp(pii a,pii b){
	return deg[a.fi] > deg[b.fi];
}
bool Cmp(int a,int b){
	return deg[a] < deg[b];
}
priority_queue<ll>q[_],bq[_];ll Sw[_];
int dfn[_],dfncnt;
void dfs1(int u,int fa){
	for(auto now:E[u]){
		int v = now.fi,w = now.se;
		if(v ^ fa){
			int o = max(deg[u],deg[v]);
			F[o] += w;
//			cout<<o<<" "<<w<<'\n'; 
			dfs1(v,u); 
		}
	}
}
ll dp1[_],dp2[_];
int st[_],top,bac[_],bcnt;
void _delete(int u){
	for(auto now:E[u]){
		int v = now.fi,w = now.se;
		q[v].push(-w);Sw[v] += w;
	}
}
void work(int u,int par,const int D){
	dfn[u] = D;
	dp1[u] = dp2[u] = 0;/*dp1[u]取D个,dp2[u]取D-1个*/
	for(auto now:E[u]){
		int v = now.fi;
		if(v ^ par){
//			cout<<u<<' '<<v<<"E"<<'\n';
			work(v,u,D);
		}
	}
	ll ans = 0;
	top = 0;
	for(auto now:E[u]){
		int v = now.fi,w = now.se;
		if(v ^ par){
			ans += dp1[v];
			if(w > (dp1[v] - dp2[v])){
				st[++top] = w - (dp1[v] - dp2[v]);
			}
		}
	}
	sort(st + 1,st + top + 1);
	reverse(st + 1,st + top + 1);
	ll S1 = 0,S2 = Sw[u];
	dp1[u] = Sw[u];dp2[u] = Sw[u];
//	if(D == 2)	cout<<Sw[u]<<'\n';
	assert(q[u].size() <= (unsigned int)D);
	if((int)q[u].size() == D)	dp2[u] += q[u].top();
//	cout<<u<<'\n';
	bcnt = 0;
//	cout<<u<<'\n';
	for(int i = 1; i <= min(top,D); ++i){/*选i个有用点,D-i个无用点*/
		S1 += st[i];
		if((int)q[u].size() > D - i){
			bac[++bcnt] = q[u].top();
			S2 += bac[bcnt];
			q[u].pop();
		}
		dp1[u] = max(dp1[u],S2 + S1);
		if(i == D)		continue;
		ll V = S2 + S1;if((int)q[u].size() >= D - i){
			V += q[u].top(); 
		}
		dp2[u] = max(dp2[u],V);
	}
//	cout<<u<<'\n';
	while(bcnt)	q[u].push(bac[bcnt]),bcnt--;
//	if(D == 2 && u == 1)	cout<<dp1[u]<<'\n';
	dp1[u] += ans;dp2[u] += ans;
	if(!par)	F[D] += dp1[u]; 
}
//vector<int> U;vector<int> V;vector<int> W;
vector<ll> minimum_closure_costs(int N,vector<int> U,vector<int> V,vector<int> W) {
	ll S = 0;
//	int N = read();
	n = N;
	/*for(int i = 0; i < N - 1; ++i){
		U.pb(0),V.pb(0),W.pb(0);
		U[i] = read(),V[i] = read(),W[i] = read();
	}*/
	for(int i = 1; i < N; ++i){
		int u = U[i-1] + 1,v = V[i-1] + 1,w = W[i-1];
//		u--,v--;
		deg[u]++,deg[v]++;
		S += w;
		E[u].pb(mp(v,w));E[v].pb(mp(u,w));
	}
	for(int i = 1; i <= N; ++i)	F.pb(0);
	for(int i = 1; i <= N; ++i)	Ver.pb(i);
	sort(Ver.begin(),Ver.end(),Cmp);Ver.pb(0);
	dfs1(1,0);
	for(int i = 1; i <= N; ++i)	sort(E[i].begin(),E[i].end(),cmp);
	for(int i = 1; i < N; ++i)	F[i] += F[i-1];
	int l = 0;
//	for(int i = 0; i < N; ++i)	cout<<Ver[i]<<' ';
//	cout<<'\n';
	for(int i = 1; i < N; ++i){
		while(l <= N && deg[Ver[l]] <= i){
			_delete(Ver[l]);
			l++;
		}
//		cout<<i<<' '<<l<<'\n';
		for(int ver = l; ver < N; ++ver){
			int u = Ver[ver];
			int k = E[u].size() - 1;
			while(k >= 0 && deg[E[u][k].fi] <= i){
				E[u].pop_back();
				k--;
			}
		}
//		puts("hxsb");
		for(int ver = l; ver < N; ++ver){
			int u = Ver[ver];
			while((int)q[u].size() > i){
				ll x = -q[u].top();
				q[u].pop();Sw[u] -= x;
				bq[u].push(x);
			}
			if((int)q[u].size() < i){
				if((int)bq[u].size()){
					ll x = bq[u].top();
					bq[u].pop();q[u].push(-x);Sw[u] += x;
				}
			}
			else{
				if((int)bq[u].size()) {
					ll x = bq[u].top();ll y = -q[u].top();
					if(x > y){
						q[u].pop();bq[u].pop();
						Sw[u] -= y;Sw[u] += x;
						q[u].push(-x);bq[u].push(y);
					}
				}
			}
		} 
		for(int ver = l; ver < N; ++ver){
			int u = Ver[ver];
			if(dfn[u] != i)	work(u,0,i);
		}
	}
	for(int i = 0; i < N; ++i)	F[i] = S - F[i];
//	for(int i = 0; i < N; ++i)	cout<<F[i]<<' ';
	return F;
}
/*int main(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
	minimum_closure_costs();
	return 0;
}*/
```


---

## 作者：WrongAnswer_90 (赞：8)

[P7600 [APIO2021] 封闭道路](https://www.luogu.com.cn/problem/P7600)

[更好的阅读体验](https://www.cnblogs.com/WrongAnswer90-home/p/17763762.html)

APIO 从 CF 搬的题，模拟赛又搬了一遍/jy。

首先考虑暴力怎么做，即做 $n$ 次树形 DP，设 $f_{i,0}$ 表示**强制**删掉 $(i,fa_i)$ 这条边的最小代价，$f_{i,1}$ 表示**强制**保留 $(i,fa_i)$ 这条边的最小代价。

对于一个点 $u$，在限制度数为 $x$ 时，对于 $f_{i,0}$ 需要删 $deg_u-x-1$ 个儿子，$f_{i,1}$ 需要删 $deg_u-x$ 个儿子。

删去 $(u,v)$ 的代价是 $val+f_{v,0}$，不删的代价是 $f_{v,1}$。首先强制一条边都不删，然后我们选一些儿子用 $cost=val+f_{v,0}-f_{v,1}$ 来替代，我们要选择最小的一些 $cost$ 加到 $f_u$ 里，需要排序，复杂度为 $\mathcal O(n^2\log n)$。

考虑如何优化，观察题目中的限制，度数是一个比较特殊的东西，手玩几组数据可以发现对于一个度数较小的节点，在 $x\geq deg_u$ 的时候，$f_{u,0}$ 和 $f_{u,1}$ 都选择了全部的儿子，没有进行替代操作，但对于每次 DP 它都需要计算一次，非常的呆，考虑删去这些节点，把这个节点的东西存在它相邻的有用的节点即度数 $>x$ 的节点里。然后每次只 DP 度数 $>x$
 的点，这样复杂度就是对的，因为 $\sum deg=2n-2$，而一个点被 DP，当且仅当 $x\in[0,deg]$，这样一个点最多被计算 $deg$ 次。

记当前度数限制为 $x$，设 $deg_u\leq x$ 的点为无用点，$deg_u>x$ 的点为有用点，我们对于当前的答案只需要 DP 有用点，对于已经无用的点 $u$，它的 $f_{u,0}$ 和 $f_{u,1}$ 之间只差了一个 $(u,fa_u)$ 的权值（因为它不需要删任何子树内的边，只需要满足 DP 状态的限制），所以它的 $cost$ 就是一条边权 $val$。

但是这样可能会出现一个点变成了无用点，它的父亲是有用点，儿子也是有用点，此时我们不需要 DP 它，但是需要 DP 它的父亲和儿子。

考虑删掉一些无用点后会形成若干个连通块，在对它的父亲所在连通块 DP 时可以把它直接看成叶子，而对于它的儿子所在连通块 DP 是可以把也它看成叶子，这样一个点可能有多个父亲，但是由于它是无用的，它的 $cost$ 只和边权有关，删掉它的时候只考虑连接它的有用点并想办法存下它的 $cost$ 即可。而对于无用点和无用点之间的边，我们一定会选择保留，所以这部分是不需要考虑的。

图大概是这样的：

![image.png](https://s2.loli.net/2023/10/14/9UPkYwcsgfp5nSN.png)

其中 $2,4$ 是无用点，剩下的都是有用点，对于一个红色的连通块，它的内部仍然先原来一样 DP，只不过它还连了一些无用点，这些无用点对它有一个 $cost$ 的影响，即选择 $cost$ 来替代是是不一定全需要从它的有用点子树里找，也可以选无用点，所以我们现在的问题是如何解决无用点对有用点的贡献。

暴力计算是不对的，因为我们上面只保证了 DP 有用点点数的正确性，如果对于每个有用点都扫一遍连接它的所有无用点，那一个菊花就噶了。

但是发现 DP 连接**有用点和有用点的边**的总个数也是线性的，刚刚复杂度假掉的原因是计算了**有用点和无用点的边**所以我们考虑用一个数据结构维护一个点的所有 $cost$，然后从中选一些最小的。

理一下思路，我们需要支持加数（无用点对于有用点以及有用点的有用点儿子对他自己的 $cost$），删数（当前有用点的儿子可能在 $x$ 时的 $cost$ 和在 $x+1$ 时不同，所以 DP 完一次要删掉一个有用点的儿子对他自己的 $cost$），可以用堆维护，这样总复杂度就是 $\mathcal O(n\log n)$。

代码也不太好写，有注释，一不小心复杂度就假了。

```cpp
struct Heap
{
	priority_queue<int> q1,q2;
	int sum;
	inline void add(int x){q1.e(x),sum+=x;}
	inline void del(int x){q2.e(x),sum-=x;}
	inline void update(){while(!q1.empty()&&!q2.empty()&&q1.top()==q2.top())q1.pop(),q2.pop();}
	inline int top(){return update(),q1.top();}
	inline void pop(){sum-=top(),q1.pop();}
	inline int size(){return q1.size()-q2.size();}
}a[250001];//可删堆
vector<pii> T[250001];
vector<int> ins,ers,ans;
int pos,dg,vis[250001],f[250001][2],n,deg[250001],p[250001];
bool cmp(pii x,pii y){return deg[x.fi]>deg[y.fi];}
bool cmp2(int x,int y){return deg[x]<deg[y];}
inline void del(int k){for(auto [to,v]:T[k])if(deg[to]<=dg)break;else a[to].add(v);}//删除无用点是把它的 $cost$ 即边权 $v$ 存到它旁边的所有有用点的堆里
inline void dfs(int k,int fa)
{
	int del=deg[k]-(vis[k]=dg);//需要删的边数
	while(a[k].size()>del)a[k].pop();//删的边一定越来越少，堆里存太多无用点也是没用的，只保留cost最小的
	for(auto [to,v]:T[k])if(to!=fa){if(deg[to]<=dg)break;else dfs(to,k);}//按度数排序后只DP有用点
	ins.clear(),ers.clear();
    //ins 存的有用点儿子的所有 cost，在最后把它删掉
  	//在找前 del 大的时候需要弹堆知道 siz=del，可能会弹出一些需要保留的无用点的 cost
    //ers 存的不小心被弹出的无用点的 cost，它还是有用的
	int sum=0;
	for(auto  [to,v]:T[k])
	{
		if(to==fa)continue;
		if(deg[to]<=dg)break;
		int val=f[to][0]+v-f[to][1];sum+=f[to][1];//val 即 cost
		if(val<=0)ans[dg]+=val,--del;
      //有时删边比留边优秀，而对于删边是没有限制的，可以把它连接的边全删了即把 del 减成负数，要加特判，否则 WA on test 4
		else a[k].add(val),ins.eb(val);
	}
	while(a[k].size()&&a[k].size()>del)ers.eb(a[k].top()),a[k].pop();//删 deg-x 条
	f[k][1]=sum+a[k].sum;
	while(a[k].size()&&a[k].size()>=del)ers.eb(a[k].top()),a[k].pop();//删 deg-x-1 条
	f[k][0]=sum+a[k].sum;
	for(int x:ers)a[k].add(x);
	for(int x:ins)a[k].del(x);
}
vector<int> minimum_closure_costs(signed N,vector<signed> U,vector<signed> V,vector<signed> W)
{
	n=N,ans.resize(n);int x,y,z;
	for(int i=1;i<n;++i)x=U[i-1]+1,y=V[i-1]+1,z=W[i-1],ans[0]+=z,++deg[x],++deg[y],T[x].eb(mp(y,z)),T[y].eb(mp(x,z));
	for(int i=1;i<=n;++i)sort(T[i].begin(),T[i].end(),cmp),p[i]=i;//把边按 deg 排序保证复杂度
	sort(p+1,p+1+n,cmp2);//把点按 deg 排序保证复杂度
	for(dg=1,pos=1;dg<n;++dg)
	{
		while(pos<=n&&deg[p[pos]]<=dg)del(p[pos++]);//p_pos 变成无用点 
		if(pos>n)break;
		for(int j=pos;j<=n;++j)if(vis[p[j]]!=dg)dfs(p[j],0),ans[dg]+=f[p[j]][1];
	}
	return ans;
}
```

---

## 作者：zac2010 (赞：5)

### 思路

一道很好口糊，但是实现细节颇多的题（时间复杂度容易假掉）。

我们先考虑固定 $k$ 的情况，用 $dp_{u,0}$ 表示删除点 $u$ 到其父亲的连边的最小删边代价，用 $dp_{u,1}$ 表示不删除点 $u$ 到其父亲的连边的最小删边代价。对于儿子 $v$ 有两种转移方式，第一种 $dp_{v,0}+cost(u,v)$，第二种 $dp_{v,1}$。发现直接转移要多加一维，和树上背包类似。但是复杂度会爆炸。故而我们选择一种带反悔的方法，一开始所有都选 $dp_{v,1}$，再把一些 $1$ 的换成 $0$ 的。那么只要用堆 $dp_{v,0}+cost(u,v)-dp_{v,1}$ 即可。

之后我们考虑从小到大枚举 $k$，对于所有度数大于 $k$ 的点的联通块按上述简易版方法跑一遍树 DP。那些不用跑的点我们在枚举到的度数等于它时就已经把其删除，对所有它连出去的点的大根堆放入了它的权值了（注意当前进行树 DP 时已经删除的点不用操作就满足，故而不会产生额外贡献）。

时间复杂度 $O(\text{度数})$，若要更具体的可以就代码分析。

### 代码

切记不要用 C++14 提交，不然会满屏 CE（GCC 9 编译版本过低）。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pb push_back
#define L(i, a, b) for(int i = a; i <= b; i++)
#define R(i, a, b) for(int i = a; i >= b; i--)
using namespace std;
vector<ll> minimum_closure_costs(int N, vector<int> U, vector<int> V, vector<int> W);
const int N = 1e5 + 10; 
int n, dg, de[N], id[N], vis[N]; ll sm, dp[N][2];
vector<pair<int, int> > e[N]; vector<ll> a, d, ans;
struct Large_Root_Heap{
    priority_queue<ll> q, d; ll sz, s;
    void upd(){while(!d.empty() && q.top() == d.top()) d.pop(), q.pop();}
    ll top(){upd(); return q.top();}
    void ins(ll x){q.push(x), s += x, sz++;}
    void del(ll x){d.push(x), s -= x, sz--;}
} h[N];
bool cmp(int i, int j){return de[i] < de[j];}
bool cmpe(pair<int, int> &x, pair<int, int> &y){return de[x.first] > de[y.first];}
void dfs(int u, int pre){
    int cnt = de[u] - dg; ll ss = 0;
    while(h[u].sz && h[u].sz > cnt)
        a.pb(h[u].top()), h[u].del(h[u].top());
    for(auto &ne: e[u]){
        int v = ne.first; if(de[v] <= dg) break;
        if(v == pre) continue; dfs(v, u);
    }
    a.clear(), d.clear(), vis[u] = dg;
    for(auto &ne: e[u]){
        int v = ne.first, w = ne.second;
        if(v == pre) continue; if(de[v] <= dg) break;
        ll vl = dp[v][0] + w - dp[v][1]; ss += dp[v][1];
        if(vl <= 0) cnt--, ss += vl;
        else h[u].ins(vl), d.pb(vl);
    }
    while(h[u].sz && h[u].sz > cnt)
        a.pb(h[u].top()), h[u].del(h[u].top());
    ss += h[u].s, dp[u][1] = ss;
    dp[u][0] = ss - ((cnt > 0 && h[u].sz)? h[u].top() : 0);
    for(auto &vl: a) h[u].ins(vl);
    for(auto &vl: d) h[u].del(vl);
}
vector<ll> minimum_closure_costs(int N, vector<int> U, vector<int> V, vector<int> W){
    n = N, ans.resize(n);
    L(i, 1, n - 1){
        int u = U[i - 1] + 1, v = V[i - 1] + 1, w = W[i - 1];
        e[u].pb(make_pair(v, w)), de[u]++;
        e[v].pb(make_pair(u, w)), de[v]++, ans[0] += w;
    }
    L(i, 1, n) id[i] = i, sort(e[i].begin(), e[i].end(), cmpe);
    sort(id + 1, id + n + 1, cmp);
    for(int i = dg = 1; dg < n; dg++){
        while(i <= n && de[id[i]] <= dg){
            for(auto ne: e[id[i]]) h[ne.first].ins(ne.second);
            i++;
        }
        L(j, i, n) if(vis[id[j]] != dg)
            dfs(id[j], 0), ans[dg] += dp[id[j]][1];
    }
    return ans;
}
```

---

## 作者：xfrvq (赞：2)

引路双倍经验 [$\tt CF1119F$](/problem/CF1119F)，还有我那题的 [题解](https://www.luogu.com.cn/blog/368107/solution-cf1119f)。

---

考虑固定 $x$ 怎么做。我们树形 $\tt dp$，记

+ $f_{u,0}$ **删除 $u$ 到父亲的边**，让 $u$ 子树符合度数条件的最小代价
+ $f_{u,1}$ **保留 $u$ 到父亲的边**，让 $u$ 子树符合度数条件的最小代价
+ $d_u$ 为 $u$ 的度数，$u$ 点要删除的总边数是 $de_u-x(de_u\gt x)$。

然后对于若干个 $u$ 的儿子 $v$ 以及它们之间边权 $w$，每种都有

1. 删除 $u$ 到 $v$ 的边，代价 $f_{v,0}+w$（一类贡献 $a_1$）
2. 保留 $u$ 到 $v$ 的边，代价 $f_{v,1}$（二类贡献 $a_2$）

+ 对于 $f_{u,0}$ 的计算而言，需要至少删除 $de_u-x-1$ 条到儿子的边（在至少 $de_u-x-1$ 个儿子那里取 $a_1$，剩下儿子取 $a_2$）
+ 对于 $f_{u,1}$ 的计算而言，需要至少删除 $de_u-x$ 条到儿子的边（在至少 $de_u-x$ 个儿子那里取 $a_1$，剩下儿子取 $a_2$）

我们先假设全部取 $a_2$，然后在找出代价最小的某种方式，替换若干个 $a_2$ 为 $a_1$。

我们先计算出所有 $v$ 的 $a_2$ 的和，然后对于每个 $v$ 我们计算出 $a_1-a_2$ 的值，挑出最小的那些加上到这个和里面即可（注意 $a_1-a_2=f_{v,0}+w-f_{v,1}$）。

对于 $u$ 的 $\tt dfs$ 过程中，我们用堆维护出所有 $a_1-a_2$ 的值，然后从小往大加到 $a_2$ 的和里面（即完成了替换若干个 $a_2$ 为 $a_1$ 这步）。

总复杂度 $\mathcal O(n\log n)$。

---

现在考虑从小往大计算每一个 $x_0$ 怎么做。

我上面说树上 $\tt dfs$ 时要对每个点维护一个堆，但是那个堆是对每个点而言的，一旦这个点的计算结束之后，这个堆也就没用了。

如果我们是朴素的对每个 $x_0$ 都计算，总有某些信息会被重复计算，所以我们这里给每个点都维护堆，加上“从小往大枚举”这个条件，尝试让后来的计算可以利用以前算过的信息。

观察从小往大这个条件，如果一个 $u$ 有 $d_u\le x_0$，那在后续的 $x_0\sim n$ 的计算中，这个 $u$ 就没用了，因为它的度数已经满足条件了。而一个点 $u$ 只会有用 $d_u$ 次，而 $\sum d_u=O(n)$，所以我们对于每个 $x_0$ 都只计算当前有用的点，时间是可行的

我们以有用的点为根进行 $\tt dfs$，无用点视为叶子，虽然有若干个由有用点构成的子树共用一个叶子（无用点将会有多个父亲），但是无妨因为无用点根本不会处理，可以当作其不存在。

![](https://cdn.luogu.com.cn/upload/image_hosting/0wohinyb.png)

如图，$u$ 是无用点，$p,q$ 是两个有用点的子树，我们从 $p,q$ 中任意挑一个点开始 $\tt dfs$ 都可以把这个子树给 $\tt dfs$ 完一遍。因为无用点是叶子，此时它相邻的有用点（$p_3,q_2$）全都可以视为它父亲。

因为只会计算有用的点，所以一个点被标记无用之后，就应该处理它余留的贡献。由这个父子关系，它带给每个父亲的贡献是一个 $u$ 的 $a_1-a_2$ 的权。因为无用点没有子树，所以不删边没有子树代价（$a_2=0$），删边只会有删边自身的代价（$a_1=w$），这个权就等于 $w$，即这个点连向他父亲的边的权，我们把这个权放进它父亲的堆里就把这个点的余留贡献处理完了。

然后考虑这个 $\tt dfs$ 的过程。首先肯定要计算所有儿子 $a_2$ 的和，然后把 $a_1-a_2$ 的值放到堆里。堆里此时会有两类元素。

1. 无用点儿子带来的贡献（所有无用点儿子 $v_0$ 的 $w_0$ 值）这个东西在后面的计算中还有用，因为无用点儿子的父子关系是不会变的。
2. 有用点儿子带来的贡献（所有有用点儿子 $v_1$ 的 $a_1-a_2$ 权值）这个东西只在这轮计算中有用，因为下一轮又有些点会变得没用，有用点树形态发生改变。

我们可以考虑在这轮 $\tt dfs$ 完之后撤销堆中二类元素的加入。复杂度分析还是 $\sum d_u\log d_u=\mathcal O(n\log n)$。

在处理好堆中的东西之后，我们计算前若干小的元素之和，这个可以通过动态维护堆元素和，然后踢掉多余元素的方法解决。但是你踢掉的可能有不应该踢掉的一类元素，所以此时还需要撤销这些踢掉的操作。

总体而言就是需要一个可删除撤销删除，插入操作的堆。这个可以维护两个堆分别表示插入和删除，插入元素放插入堆删除元素放删除堆，求 `top` 需要先踢掉两个堆顶部的相同元素，复杂度可以均摊。

---

实现时很容易不小心让复杂度带上一个 $n^2$，也需要一些优化。

然后注意这个题是交互，点编号是 $0\sim n-1$，并且 $n$ 的范围小一点就行了。

[代码](https://www.luogu.com.cn/paste/q3d23958) 没有注释要的话可以去我原题题解看。

---

## 作者：UKE_Automation (赞：1)

### CF1119F Niyaz and Small Degrees / P7600 [APIO2021] 封闭道路

[$\text{CF Link}$](https://codeforces.com/problemset/problem/1119/F)，[$\text{Luogu Link}$](https://www.luogu.com.cn/problem/P7600)

首先先来看对于单独的固定的 $x$ 如何求答案，显然考虑树形 dp，设 $dp(i,0/1)$ 表示钦定点 $i$ 与父亲的连边不删除或删除时，让 $i$ 子树内合法的最小代价。转移是比较好想的，对于一个儿子 $v$，有两种决策：该边不删除，代价为 $dp(v,0)$；该边删除，代价为 $dp(v,1)+w$。为了让 $i$ 也满足条件，显然删除的边的数量至少有 $deg_i-x$，但是对于每个儿子只取最优解并不一定能满足这个要求。因此对于所有取到不删除的点，把代价之差 $dp(v,1)+w-dp(v,0)$ 扔到一个堆里，然后取最小的加到答案中即可。

这样做单次复杂度为 $O(n^2\log n)$，无法通过。考虑进一步观察性质，容易发现对于一个 $x$，$deg_i\le x$ 的点是完全不用重新 dp 的，称这样的点为无用点。将无用点从树中删去后就形成了若干连通块，每次只需要对连通块 dp 即可。此时再看复杂度，对于一个点 $i$，它会被处理 $deg_i$ 次，所以总复杂度是 $O(\sum deg_i)=O(n)$ 的，那么这个做法是有前途的。

考虑对于以有用点为根进行 dp，然后将无用点视为一个叶子节点，此时这个节点不删除的代价为 $0$，删除的代价就是边权 $w$。按道理来讲此时直接按照上述过程实现就行了，不过实际上不然。因为我们复杂度的正确性是建立在每一次只遍历有用点的基础上的，如果每次还要把无用点扔进堆复杂度是不正确的。

解决方法实际上也比较容易，无用点的贡献一定是不变的，所以对于每个点，其堆中含有的无用点贡献也是不变的。那么我们只需要在一个点变为无用点时向其周围的有用点的堆中加入贡献即可；同时对于每个点，如果把堆中无用点的贡献删掉了，我们也要重新加回来。这个用 `set` 实现会方便一点，或者用两个堆拼成可删堆实现，复杂度还是 $O(n\log n)$ 的。

但是还有最后一个问题：如果我们每一次把 `set` 中最小的 $deg_i-x$ 个暴力删除求和的话复杂度还是不对，会退化成 $O(\sum deg_i^2)$。考虑我们实际上是对 `set` 中一段前缀求和，可以转化为用总和减去一段后缀的和。而求后缀就给了我们操作空间；在最开始的时候，集合中应该只有无用点，我们先把它的大小压到 $deg_i-x$ 以内，然后加入有用点，此时要删到只剩 $deg_i-x$ 个点最多只用有用点个数步。这样的话这一部分的复杂度也变成了有用点的个数之和，总复杂度就是 $O(n\log n)$ 的了。

```cpp
#include <bits/stdc++.h>
#define il inline
#define int long long

using namespace std;

const int Maxn = 2.5e5 + 5;
const int Inf = 2e9;

int n;
#define pii pair<int, int>
#define mk make_pair
#define fi first
#define se second
vector <pii> V[Maxn];
int deg[Maxn];
void add(int u, int v, int w) {
	deg[u]++, deg[v]++;
	V[u].push_back(mk(v, w)), V[v].push_back(mk(u, w));
}
int id[Maxn];

multiset <int> s[Maxn];
int f[Maxn][2], sum[Maxn]; 
int vis[Maxn];
void del(int x) {
	for(auto p : V[x]) {
		int to = p.fi, w = p.se;
		s[to].insert(w); sum[to] += w;
	}
}

vector <int> dl, is;
void dfs(int x, int fth, int lim) {
	int tar = deg[x] - lim; int res = 0;
	for(auto p : V[x]) {
		int to = p.fi;
		if(to == fth) continue;
		if(deg[to] <= lim) break;
		dfs(to, x, lim);
	}
	while(s[x].size() > tar) sum[x] -= *(--s[x].end()), s[x].erase(--s[x].end());
	res = sum[x]; vis[x] = 1;
	dl.clear(), is.clear();
	for(auto p : V[x]) {
		int to = p.fi, w = p.se;
		if(to == fth) continue;
		if(deg[to] <= lim) break;
		int v1 = f[to][1] + w, v2 = f[to][0];
		res += v1;
		if(v1 <= v2) tar--;
		else s[x].insert(v1 - v2), is.push_back(v1 - v2);
	}
	while(s[x].size() && (signed)s[x].size() > tar) {
		auto it = --s[x].end();
		dl.push_back(*it), res -= *it, s[x].erase(it); 
	}
	f[x][0] = res;
	while(s[x].size() && (signed)s[x].size() >= tar) {
		auto it = --s[x].end();
		dl.push_back(*it), res -= *it, s[x].erase(it); 
	}
	f[x][1] = res;
	for(auto i : dl) s[x].insert(i);
	for(auto i : is) s[x].erase(s[x].find(i));
}

vector <int> ret;
std::vector<long long> minimum_closure_costs(signed n, std::vector<signed> u, std::vector<signed> v, std::vector<signed> w) {
    int sum = 0;
	for(int i = 1; i < n; i++) {
		add(u[i - 1] + 1, v[i - 1] + 1, w[i - 1]); sum += w[i - 1];
	}
	for(int i = 1; i <= n; i++) id[i] = i, sort(V[i].begin(), V[i].end(), [](pii x, pii y){return deg[x.fi] > deg[y.fi];});
	sort(id + 1, id + n + 1, [](int x, int y){return deg[x] < deg[y];}); int pos = 1;
	ret.push_back(sum);
	for(int i = 1; i < n; i++) {
		while(pos <= n && deg[id[pos]] <= i) del(id[pos]), pos++;
		int ans = 0;
		for(int j = pos; j <= n; j++) {
			int x = id[j];
			if(!vis[x]) {
				dfs(x, 0, i), ans += f[x][0];
			}
		}
		ret.push_back(ans);
		for(int j = pos; j <= n; j++) vis[id[j]] = 0;
	}	
	return ret;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

貌似时间复杂度比较劣，但是非常好想。

注意到度数小于等于 $k$ 的限制对于本来度数小于等于 $k$ 的点是完全无意义的。

所以直接枚举 $k$，将度数大于 $k$ 的点取出来建虚树，在虚树上 dp，具体而言考虑设计 $dp_{u,0/1}$ 表示考虑 $u$ 的子树并且点 $u$ 保留了不超过 $k-1$ 或者 $k$ 条边，其余子树内的点均保留了不超过 $k$ 条边的最小代价，转移形如将一条边的割去代价更改后求出一个点所有儿子边割去代价的前 $k$ 大或者前 $k-1$ 大和，对顶堆维护即可，由于度数之和是 $O(n)$ 的，时间复杂度是 $O(\sum_{i=1}^n \frac{n}{i} \log n) = O(n \log^2 n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5+114;
vector<int> E[maxn];
int fa[maxn];
int dep[maxn];
int top[maxn],sz[maxn],son[maxn];
int dfn[maxn],dfncnt;
void dfs(int u){
    dfn[u]=++dfncnt;
    sz[u]=1;
    dep[u]=dep[fa[u]]+1;
    for(int v:E[u]){
        if(v!=fa[u]){
            fa[v]=u;
            dfs(v);
            sz[u]+=sz[v];
            if(sz[v]>sz[son[u]]) son[u]=v;
        }
    }
}
void init(int u,int tp){
    top[u]=tp;
    if(son[u]!=0) init(son[u],tp);
    for(int v:E[u]){
        if(v!=fa[u]&&v!=son[u]) init(v,v);
    }
}
int LCA(int u,int v){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    return v;
}
long long val[maxn];
struct node{
    multiset<long long> S1,S2;
    long long sum;
}ds[maxn];
int k;
void del(int u){
    int x=fa[u];
    if(ds[x].S1.find(val[u])!=ds[x].S1.end()){
        ds[x].S1.erase(ds[x].S1.find(val[u]));
        if(ds[x].S1.size()<k&&ds[x].S2.size()>0){
            long long del=(*ds[x].S2.rbegin());
            ds[x].sum-=del;
            ds[x].S1.insert(del);
            ds[x].S2.erase(ds[x].S2.find(del));
        }
    }else{
        ds[x].S2.erase(ds[x].S2.find(val[u]));
        ds[x].sum-=val[u];
    }
}
void ins(int u){
    int x=fa[u];
    if(ds[x].S1.size()<k){
        ds[x].S1.insert(val[u]);
    }else{
        if(val[u]>(*ds[x].S1.begin())){
            long long del=(*ds[x].S1.begin());
            ds[x].sum+=del;
            ds[x].S2.insert(del);
            ds[x].S1.erase(ds[x].S1.find(del));
            ds[x].S1.insert(val[u]);
        }else{
            ds[x].sum+=val[u];
            ds[x].S2.insert(val[u]);
        }
    }
}
long long ask(int u,int K){
    if(k==K) return ds[u].sum;
    else if(K==k-1){
        return ds[u].sum+(ds[u].S1.size()==k)*(*ds[u].S1.begin());
    }
}
long long dp[maxn][2];//0 子树内保留了 k-1 条边 1 子树内保留了 k 条边
int cst[maxn];
vector<int> vec[maxn];
vector<int> vE[maxn];
void DP(int u){
    dp[u][0]=dp[u][1]=0;
    long long bas=0;
    for(int v:vE[u]){
        DP(v);
        if(fa[v]==u){
            //v 的代价：割去代价为 dp[v][1]+cst[v] 不割去代价为 dp[v][0];
            //默认为不割去
            //特判割去更优的情况
            if(dp[v][1]+cst[v]<=dp[v][0]){
                bas+=dp[v][1]+cst[v];
                del(v);
                val[v]=0;
                ins(v);
            }else{
                bas+=dp[v][0];
                del(v);
                val[v]=dp[v][1]+cst[v]-dp[v][0];
                ins(v);
            }
        }else{
            bas+=min(dp[v][1]+cst[v],dp[v][0]);
        }
    }
    dp[u][0]=ask(u,k-1),dp[u][1]=ask(u,k);
    dp[u][0]+=bas,dp[u][1]+=bas;
    for(int v:vE[u]){
        if(fa[v]==u){
            del(v);
            val[v]=cst[v];
            ins(v);
        }
    }
}
vector<long long> minimum_closure_costs(int N, vector<int> U, vector<int> V, vector<int> W){
    for(int i=0;i<N-1;i++){
        E[U[i]+1].push_back(V[i]+1);
        E[V[i]+1].push_back(U[i]+1);
    }
    dfs(1);
    init(1,1);
    for(int i=0;i<N-1;i++){
        if(fa[U[i]+1]==V[i]+1) cst[U[i]+1]=W[i];
        else cst[V[i]+1]=W[i];
    }
    for(int i=1;i<=N;i++) vec[E[i].size()].push_back(i);
    vector< pair<int,int> > S;
    k=N;
    vector<long long> ans;
    ans.resize(N);
    for(int i=2;i<=N;i++){
        val[i]=cst[i];
        ins(i);
    }
    for(int i=N-1;i>=1;i--){
        for(int x:vec[i+1]){
            S.push_back(make_pair(dfn[x],x));
        }
        if(S.size()!=0){
            k=i;
            set<int> T;
            T.insert(1);
            sort(S.begin(),S.end());
            for(int i=0;i+1<S.size();i++) T.insert(LCA(S[i].second,S[i+1].second));
            for(pair<int,int> now:S) T.insert(now.second);
            vector< pair<int,int> > build;
            for(int x:T) build.push_back(make_pair(dfn[x],x));
            sort(build.begin(),build.end());
            for(int i=0;i+1<build.size();i++){
                int u=build[i].second,v=build[i+1].second;
                vE[LCA(u,v)].push_back(v);
            }
            for(pair<int,int> now:build){
                int x=now.second;
                while(ds[x].S1.size()>k){
                    long long del=(*ds[x].S1.begin());
                    ds[x].sum+=del;
                    ds[x].S2.insert(del);
                    ds[x].S1.erase(ds[x].S1.find(del));
                }
            }
            DP(1);
            for(pair<int,int> x:build) vE[x.second].clear();
            ans[i]=dp[1][1];
        }
    }
    for(int i=0;i<N-1;i++) ans[0]+=W[i];
    return ans;
}
```

---

## 作者：nullqtr_pwp (赞：0)

### APIO2021 T3

考虑给定 $k$ 之后的 dp 就是 $f_{u,0/1}$ 表示 $u$ 子树内满足要求的最小代价，使得 $(u,fa)$ 的边断开或者不断开。转移形如 $f_{u,1}$ 求和后对前 $k/k-1$ 大的 $(f_{u,1}-f_{u,0})$ 进行求和，对于 $f_{u,1}$ 而言最终还需要加上 $w_{E(u,fa)}$，时间复杂度是 $\mathcal O(nk\log n)$。对于所有的 $k$ 求一遍 dp 值显然是劣的。观察一下解的形态，对于当前度数 $\leq k$ 的点我们可以自动做出全部保留的决策，也就是对子树的 $f_{u,0}$ 进行求和直接进行转移。而度数 $>k$ 的点我们对于每个 $k$ 暴力找一遍的复杂度是均摊正确的，由调和级数总点数是 $\mathcal O(n\ln n)$ 的，问题是如何进行 dp 的维护。

注意到一个 $\leq k$ 度数的点 $p$ 在后续决策中并没有用，我们考虑删去这个点而将与其相邻的 $>k$ 度的点 $u$ 的边的边权丢进 $u$ 的决策里，因为 $p$ 的作用仅仅只是对于子树的 $f$ 进行求和，向上汇总，此时 $f_{u,1}-f_{u,0}$ 是确定的 $w_{E(p,u)}$，我们只关心差值，因此 $p$ 相当于把这些部分割成了独立的连通块。对于每个连通块可以任选一个根开始 dfs，注意到一个边的决策在后续是永久存在的，我们希望在 $k\to k+1$ 的过程中继承一些信息，考虑将大度点上传的 $\Delta f$ 视为临时决策，在求出 $f_{u}$ 之后撤销这些决策，使用带删堆或者 ```std::multiset``` 维护即可，时间复杂度 $\mathcal O(n\log^2n)$。

---

## 作者：_ANIG_ (赞：0)

[传送门](https://www.luogu.com.cn/problem/P7600)

首先考虑对每个 $k$ 如何分别计算答案。

设 $f_{x,0/1}$ 表示考虑 $x$ 的子树内的所有边和 $x$ 与父节点相连的边全部合法，$x$ 与父节点的边是/否封闭的最小代价。

转移的时候考虑 $x$ 和儿子的连边。

也就是要在与儿子的连边中选若干个，使得 $x$ 的度数不超过 $k$ 且代价最小。

首先全都不选，然后可以发现把节点 $y$ 从不选变为选的代价为 $f_{y,1}-f_{y,0}$。

把 $x$ 的儿子按 $f_{y,1}-f_{y,0}$ 排序，取前若干小的即可。

但是这样是 $O(n^2\log n)$ 的。

首先有个经典结论：树上所有点度数之和为 $O(n)$。

可以发现，度数不超过 $k$ 的点是不需要考虑的。

而度数大于 $k$ 的点只有 $O(\frac nk)$ 个。

所以所有合法的点的数量之和是调和级数的 $O(n\log n)$。

对于每个 $k$，只考虑所有度数大于 $k$ 的点。

这些点会形成若干个联通块，每个连通块分别 dp，答案加起来。

对每个点开个 set 维护所有儿子，均摊维护一下，总复杂度 $O(n\log^2 n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=2.5e5+5,inf=1e18;
struct node{
	int to,sm;
	friend bool operator<(node a,node b){
		if(a.sm==b.sm)return a.to<b.to;
		return a.sm<b.sm;
	}
	friend bool operator<=(node a,node b){
		return !(b<a);
	}
}g1[N],g2[N];
set<node>q[N];
vector<node>p[N];
vector<int>e[N],g[N];
int n,ds[N],mk[N],dfn[N],idx,dep[N],w[N],dp[N][2],nw,bk[N],gs[N],f1[N],f2[N];
vector<int>dd,jl;
signed fa[N][20];
void dfs(int x){
	g1[x]=g2[x]={-inf,-inf};
	for(int i=1;i<=18;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	mk[x]=1;dfn[x]=++idx;
	for(auto v:p[x]){
		int c=v.to;
		if(mk[c])continue;
		g[x].push_back(c);
		fa[c][0]=x;
		dep[c]=dep[x]+1;
		w[c]=v.sm;
		gs[x]+=v.sm;
		q[x].insert({c,-w[c]});
        dfs(c);
	}
}
bool CMP(int a,int b){
	return dfn[a]<dfn[b];
}
int up(int x,int k){
	while(k){
		x=fa[x][__lg(k&-k)];
		k^=k&-k;
	}
	return x;
}
int lca(int a,int b){
    if(dep[a]>dep[b])swap(a,b);
    b=up(b,dep[b]-dep[a]);
    if(a==b)return a;
    for(int i=18;i>=0;i--){
    	if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i];
    }
    return fa[a][0];
}
void clr(){
	for(auto c:jl)e[c].clear(),bk[c]=0;
	jl.clear();
}
void add(int a,int b){
//	cout<<a<<" "<<b<<endl;
	if(dep[b]-dep[a]==1)e[a].push_back(b),jl.push_back(a),jl.push_back(b),bk[b]=1;
}
void init(vector<int>q){
	clr();
	for(auto c:q){
		if(ds[fa[c][0]]>nw){
			add(fa[c][0],c);
		}
	}
}
void del(int x,node sm){
	if(sm<=g1[x]){
		g1[x]=*q[x].upper_bound(g1[x]);
		f1[x]+=min(g1[x].sm,0ll)-min(sm.sm,0ll);
	}
	if(sm<=g2[x]){
		g2[x]=*q[x].upper_bound(g2[x]);
		f2[x]+=min(g2[x].sm,0ll)-min(sm.sm,0ll);
	}
	q[x].erase(q[x].find(sm));
}
void ist(int x,node sm){
	q[x].insert(sm);
	if(sm<g1[x]){
		f1[x]+=min(sm.sm,0ll)-min(g1[x].sm,0ll);
		g1[x]=*(--q[x].find(g1[x]));
	}
	if(sm<g2[x]){
		f2[x]+=min(sm.sm,0ll)-min(g2[x].sm,0ll);
		g2[x]=*(--q[x].find(g2[x]));
	}
}
void Dfs(int x){
    dp[x][0]=w[x]+gs[x];
	dp[x][1]=gs[x];
	if(nw>=1&&nw<=q[x].size()){
		g1[x]=*q[x].upper_bound(g1[x]);
		f1[x]+=g1[x].sm;
	}
	if(nw>=2&&nw-1<=q[x].size()){
		g2[x]=*q[x].upper_bound(g2[x]);
		f2[x]+=g2[x].sm;
	}
	for(auto c:e[x]){
	    Dfs(c);
	    dp[x][0]+=dp[c][0]-w[c];
	    dp[x][1]+=dp[c][0]-w[c];
	    if(-w[c]==dp[c][1]-dp[c][0])continue;
		ist(x,{c,dp[c][1]-dp[c][0]});
	    del(x,{c,-w[c]});
	}
	dp[x][0]+=f1[x];
	dp[x][1]+=f2[x];
	//cout<<nw<<" "<<x<<" "<<f1[x]<<" "<<f2[x]<<endl;
	for(auto c:e[x]){
		if(-w[c]==dp[c][1]-dp[c][0])continue;
	    ist(x,{c,-w[c]});
		del(x,{c,dp[c][1]-dp[c][0]});
	}
//	cout<<nw<<" "<<x<<" "<<dp[x][0]<<" "<<dp[x][1]<<endl;
}
int solve(int x){
//	cout<<x<<endl;
	nw=x;
	vector<int>q;
	for(int i=0;i<n;i++){
		if(ds[dd[i]]>x)q.push_back(dd[i]);
		else break;
	}
	init(q);
	int res=0;
	for(int i=0;i<n;i++){
	    if(ds[dd[i]]<=x)break;
	    if(bk[dd[i]])continue;
		Dfs(dd[i]);
		res+=min(dp[dd[i]][0],dp[dd[i]][1]);
	}
	return res;
}
bool cmp(int a,int b){
	return ds[a]>ds[b];
}
vector<int>minimum_closure_costs(signed nn,vector<signed>U,vector<signed>V,vector<signed>W){
	n=nn;
	for(int i=1;i<n;i++){
		int x=U[i-1],y=V[i-1],z=W[i-1];
		x++;y++;
		p[x].push_back({y,z});
		p[y].push_back({x,z});
		ds[x]++;ds[y]++;
	}
	for(int i=1;i<=n;i++)dd.push_back(i);
	sort(dd.begin(),dd.end(),cmp);
	dfs(1);
	vector<int>rs;
	for(int i=0;i<n;i++)rs.push_back(solve(i));
	return rs;
}
```

---


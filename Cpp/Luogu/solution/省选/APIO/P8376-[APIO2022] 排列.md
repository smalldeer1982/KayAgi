# [APIO2022] 排列

## 题目背景

本题只支持 C++ 提交，提交时不需要包含 `perm.h` 头文件，只需要将附件中的 `perm.h` 中的内容粘贴到代码的开头即可。

## 题目描述

法老们利用行星的引力来加速飞船。假设飞船将依次以 $p[0], p[1],\dots , p[n - 1]$ 的轨道速度飞掠 $n$ 颗行星。飞掠每颗行星时，法老科学家可以选择是否利用它来加速飞船。为了节省能量，当飞船以轨道速度 $p[i]$ 飞掠一颗行星并完成加速后，它将不能再在以轨道速度 $p[j] < p[i]$ 飞掠行星时进行加速。也就是说，选择用来加速的行星构成 $p[0], p[1],\dots , p[n - 1]$ 的一个**递增子序列**。$p$ 的子序列是从 $p$ 中删除零个或多个元素得到的序列。例如，$[0]$、$[ ]$、$[0, 2]$ 和 $[0, 1, 2]$ 是 $[0, 1, 2]$ 的子序列，但 $[2, 1]$ 不是。

科学家已经确认，总共有 $k$ 种方案来选择行星对飞船进行加速，但是他们弄丢了轨道速度的记录信息（甚至包括 $n$ 的大小）。不过他们记得 $(p[0], p[1],\dots , p[n - 1])$ 是 $0, 1,\dots , n - 1$ 的一个排列。这里的排列是包含从 $0$ 到 $n - 1$ 每个整数恰好一次的序列。 你的任务是找出一个长度尽量小且符合要求的排列 $(p[0], p[1],\dots , p[n - 1])$。

你要对 $q$ 艘不同的飞船来解决该问题。对每艘飞船 $i$，你会得到一个整数 $k_i$，表示选择行星加速飞船的不同方案数。你的任务是找出长度 $n$ 足够小的轨道速度序列，使得从中恰好可以选出 $k_i$ 个轨道速度递增的行星子序列。

## 实现细节

你要实现以下函数：

```cpp
int[] construct_permutation(int64 k)
```

- $k$ 是应有的递增子序列的数量。
- 该函数要返回有 $n$ 个元素的数组，每个元素是 $0$ 到 $n - 1$ 之间（包括 $0$ 和 $n - 1$）的数。
- 返回的数组必须是恰好有 $k$ 个递增子序列的合法排列。
- 该函数总共被调用 $q$ 次。每次调用被视为一个独立的场景。

## 说明/提示

## 例子

### 例 $1$

考虑以下调用：

```cpp
construct_permutation(3)
```

该函数应该返回一个恰好有 $3$ 个递增子序列的排列。一种可能的答案是 $[1,0]$，它的递增子序列有 $[]$（空的子序列）、$[0]$ 和 $[1]$。

### 例 $2$

考虑以下调用：

```cpp
construct_permutation(8)
```

该函数应该返回一个恰好有 $8$ 个递增子序列的排列。一种可能的答案是 $[0,1,2]$。

## 约束条件

- $1\le q\le 100$。
- $2\le k_i\le 10^{18}$（对所有 $0\le i\le q-1$）。

## 子任务

1. （$10$ 分）$2\le k_i\le 90$（对所有 $0\le i\le q-1$）。如果你给出的所有排列长度至多为 $90$ 且结果正确，你将获得 $10$ 分，否则获得 $0$ 分。
2. （$90$ 分）没有额外的约束条件。对该子任务，令 $m$ 为你在所有场景中给出的排列的最大长度，则你的得分按下表来计算：

|条件|得分|
|:-:|:-:|
|$m\le 90$|$90$|
|$90 < m\le 120$|$90-\dfrac{m-90}{3}$|
|$120 < m\le 5000$|$80-\dfrac{m-120}{65}$|
|$m > 5000$|$0$|

## 样例 #1

### 输入

```
2
3
8```

### 输出

```
2
1 0
3
0 1 2```

# 题解

## 作者：WeLikeStudying (赞：38)

- 以前作者的措辞可能不太恰当，但是我觉得这是能够理解的，毕竟作者早已退役，$\text{APIO}$ 比赛，就算规模再大，对我来说只有思维训练的价值而已。
- 如果各位不嫌弃我的祝福的话，我希望大家不要留下遗憾。

**题意**
- 输出一个排列，满足它存在恰好 $k$ 个递增子序列（包括空序列）。
- 你需要使得排列长度不大于 $90$，$k\le 10^{18}$。
- 多测，测试组数不超过 $100$。

**分析**
- 一个小的部分分：$k\le 90$。
- 输出长度为 $k-1$ 的逆序排列[代码](https://www.luogu.com.cn/paste/olh44ife)，信息复杂度 $O(k)$，最坏情况显然是需要用 $10^{18}-1$ 个数表示 $10^{18}$，理论得分 $10$，实际得分 $10$。
- 你采取任何一种合法构造方法都能拿到这 $10$ 分，因为这已经是可能构造出来的最长排列了。
- 是构造题呢，仔细思考一下，构造这样一种排列：所有合法的不下降子序列都不能跨过一个范围。
![](https://cdn.luogu.com.cn/upload/image_hosting/nl18pjru.png)
- （上图实际的形状：多段连续的上升子序列，其中相对前面的段的元素严格大于后面的段）
- 现在问题就变成了：给定 $n\le90$ 个数 $a_i$，满足：
$$\sum_{i=1}^n(2^{a_i}-1)=k-1$$
- 然后就可以构造了，不论怎么样都不会超过 $90$ 个数吧（flag）（upd：flag 没了）。
- [代码](https://www.luogu.com.cn/paste/osj3i9r4)，信息复杂度 $O(\log^2k)$，更具体地，它需要用 $1713$ 个数来表示 $2^{59}+2^{58}-58$，理论得分 $65.49$，实际得分 $71.2$。
- 我似乎建立了一个钢琴的模型，如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/yazkm876.png)
- （上图实际的形状：一个严格上升序列，一个严格下降序列，交错摆放，且上升序列的数严格大于下降序列）
- 考虑每个黑点右上方有多少个红点，那么黑点的贡献是关于二的指数，可以发现这个结构很适合拆位，[代码](https://www.luogu.com.cn/paste/zwjqib7x)，信息复杂度 $O(\log k)$，更具体地，它需要用 $117$ 个数来表示 $2^{59}+2^{58}-1$，理论得分 $91$，实际得分 $91.36$。
- [类题](https://www.luogu.com.cn/problem/AT2363)，接下来进入玄学领域：卡常，因为能用长度不超过 $n$ 的数列表示的数（不论它具体是啥）大小显然绝对不超过 $\lceil \log_2 k\rceil$（毕竟你至少要表示得出这么大的数才行）。
- 所以 $O(\log k)$ 是一个不可逾越的理论下限，在这个时候，常数就极其重要了，我们刚才的算法信息复杂度理论上是 $\lfloor\log_2k\rfloor+\operatorname{popcount}(k)-1$，即常数最坏为 $2$，但是这道玄学题目的常数最坏是 $1.5$。
- [奆佬](https://www.luogu.com.cn/user/52881)的[赛时想法](https://www.luogu.com.cn/paste/s7yshq23)，既然明确了正解不是它，那么它很可能得到满分（如果你有足够的代码实现功底的话）。
- 以下是和[奆佬](https://www.luogu.com.cn/user/58705)讨论的结果，奆佬的信息学直觉：$2^{60}$ 恰好在 $10^{18}$ 左右，而 $90=60\times 1.5$，实在是太整了，不像是乱搞的信息复杂度，正因为有了奆佬的提醒，才能有以下的思考，它的简洁和优美显示它确实是正解。
- 首先那个骨架是很难少的，所以我们就要针对 $\operatorname{popcount}$ 的常数下功夫。
- 如何做呢，容易发现这样一个性质：
![](https://cdn.luogu.com.cn/upload/image_hosting/hkl4wfss.png)
- 具体是为啥呢，原因就是如果其它的贡献单独考虑，而且把高上去的点与前两个点相互作用产生的权值累加的话，那么等价于这个高的黑点权值乘 $3$。
- 也就是说：如果我们在前面先定下了两个 $1$，那么后面就可以用一个 $1$ 来代表连续的两个 $1$。
- 看起来这种做法很有希望呢，那么采用这种做法最多要放几个黑颜色的点呢？假设 $k$ 足够大，我们最多放 $\lfloor0.5\log_2k\rfloor+1$ 个点，因为如果我们放两个 $1$，那么可以等价为 $11$ 占了两位，如果我们被迫放一个 $1$，那么可以等价为 $10$ 占了两位（或者到了结尾），总之：常数被卡到了 $1.5$，我们可以等着做出这题了。
- 这个做法的实现稍微麻烦一点，不过代码并不因此超过 $1\text{KB}$：[代码](https://www.luogu.com.cn/paste/x15x5gjm)，信息复杂度 $O(\log k)$，更具体地，它需要 $89$ 个数来表示 $2^{59}+2^{58}-1$，理论得分 $100$。

---

## 作者：ZYLZPP (赞：24)

## 一句话题意

- 构造一个长度 $\le 90$ 的排列，使其递增子序列数（包含空串）为 $K(\le 10^{18})$。

## 朴素做法

考虑**从小到大**加数。

显然（记当前递增子序列数为 $ans$）：

- 初始：$ans = 1$（空串）
- 放最前：$ans + 1$
- 放最后：$ans \times 2$

则我们得到了一个简单的构造方法：对 $K$ 进行二进制处理即可。

$len = O(2 \times \log{K})$，**然而** $\log{10^{18}} \approx 60$，$len_{max} \approx 120 > 90$。

## 优化做法

**注意到 $1.5 \times 60 = 90$（qwq）**。

而 $\times 2$ 的操作是**满的**，不可优化。

这提示我们对 $+1$ 操作进行优化，尝试**合并** $+1$ 操作（一次处理多个二进制 $1$）。

显然 $+1$ 操作每次将**最大**的数添加至最前，所以是**单调递减**的（如图中 **O**）。

|   O   |       |       |       |       |
| :---: | :---: | :---: | :---: | :---: |
|       |       |       |       |   *   |
|       | **O** |       |       |       |
|       |       |       |   *   |       |
|       |       | **O** |       |       |

而**单调递减**正是 $ans$ 增长较慢的原因（每次只 $+1$）。

考虑将新的数插到第三位（如图中 **X**，注意数是**从小到大**插入的）。

|       |       | **X** |       |       |       |
| :---: | :---: | :---: | :---: | :---: | :---: |
| **O** |       |       |       |       |       |
|       |       |       |       |       |   *   |
|       | **O** |       |       |       |       |
|       |       |       |       |   *   |       |
|       |       |       | **O** |       |       |

可使 $ans \to ans + 3$（即一次处理两个二进制 $1$）。

### 综上

记 $K$ 为目标数，则有以下操作：

1. 当 $K \bmod 2 = 0$ 时，将数加到最后，$K \to \frac{K}{2}$。
2. 当 $K \bmod 4 = 1$ 时，先将数放到最前，$K \to K - 1$，再做两次 $1$ 操作。
3. 当 $K \bmod 4 = 3$ 时，先将数放到第三位，$K \to K - 3$，再做两次 $1$ 操作。
4. 注意到 $3$ 操作前须有至少 $2$ 个 $2$ 操作，则可在 $K \le 4$ 时暴力进行 $2$ 操作以保证。

则此时每加 $3$ 个数后 $K$ 至少除以 $4$，$len_{max} = 1.5 \times \log{K} \approx 90$。

## ACcode

```cpp
#include<bits/stdc++.h>
using namespace std;

vector<int > ans;
int n;

void work(long long x) {
    if (x <= 4) {
        while (--x) ans.insert(ans.begin(), n++);
        return;
    } //x<=4时暴力+1以保证+1操作数>=2
    if (x % 2 == 0) work(x >> 1), ans.push_back(n++);
    else if (x % 4 == 1) work(x - 1), ans.insert(ans.begin(), n++);
    else if (x % 4 == 3) work(x - 3), ans.insert(ans.begin() + 2, n++);
}

vector<int > construct_permutation(long long k) {
    ans.resize(n = 0);
    work(k);
 return ans;
}
```

感谢审核，辛苦 : ) 。

---

## 作者：I_am_Accepted (赞：20)

场上 $91.36$ 分选手前来补题。

以下 vi 均指 `std::vector<int>`，IS 指上升子序列。

由于这道题比较难调，这里~~凉~~良心地给出 checker（返回序列上升子序列个数）：

```cpp
long long f[100];
long long check(vi x){
	int len=x.size();
	long long res=1;
	for(int i=0;i<len;i++){
		f[i]=1;
		For(j,0,i-1) if(x[j]<x[i]) f[i]+=f[j];
		res+=f[i];
	}
	return res;
}
```

### Analysis

首先，$\{0,1,2,\dots,(x-1)\}$ 拥有 $2^x$ 个 IS（含空）。

这启示我们将 $k$ 二进制拆分。

设 $k$ 的最高位为 $2^x(x\ge 1)$，则我们先构造（横坐标为序列，纵坐标为值）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gjh0bo25.png)

满足了 $k$ 的最高位，接下来我们 $k:=k-2^x$。

然后我们能插入一些数来满足剩下的二进制位。具体地，假设我们还要增加 $2^c$ 个 IS：

![](https://cdn.luogu.com.cn/upload/image_hosting/k6p0hpjf.png)

由于二进制位之间 IS 个数是单纯「加」的关系，所以下面这一排要单调递减：

![](https://cdn.luogu.com.cn/upload/image_hosting/kjakdp5v.png)

（所以总体看起来像一个小于号 $<$）

此时恭喜你可以获得 $91.36$ 的分数！在场上建议去开别的题了。

* * *

满分做法：

考虑到 $k=10^{18}<2^{60}$，代表着我们最多再用 $30(=90-60)$ 个位置表示出 $2^0,2^1,\dots,2^{58}$，这比刚才每一位都加一个点的限制缩小了一半（$59\to 30$）。

有一个~~螺旋升天的~~想法：**试着将 $k$ 二进制中连续的两个 $1$ 只用一个位置弄出来。**

这个想法是可行的，我们这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/0jigc2rw.png)

也就是从左往右加下面那排的点：

* 若这个点右边紧接着下一个要加的点，并且下排的点至少有了两个。我们将这个点的纵坐标插在次小和次次小之间，横坐标为紧邻的这两个位置中靠右的位置。

* 否则像之前那样单点加。

即可 AC。

~~时间复杂度啥的就不管了吧。~~

### Code

```cpp
#include <vector>
std::vector<int> construct_permutation(long long k);
//We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i<=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i>=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug cerr<<"Line#"<<__LINE__<<endl
#define vi vector<int>
const int inf=2022;
vi s,res;
int a[100];
bool b[100];
vi construct_permutation(long long k){
	res.clear(); 
	int x=1; while((1ll<<(x+1))<=k) x++;
	k-=(1ll<<x);
	memset(a,-1,sizeof a);
	For(i,0,x-1) b[i]=1ll&(k>>i);
	int mn=-1,se=-1;
	Rof(i,x-1,0) if(b[i]){
		if(i && b[i-1] && mn!=-1 && se!=-1){
			a[mn]--;
			a[i-1]=a[se];
			a[se]--;
			i--;
		}else if(mn!=-1){
			a[i]=a[mn]-1;
			se=mn;
			mn=i;
		}else{
			a[i]=inf-1;
			mn=i;
		}
	}
	For(i,0,x-1){
		if(a[i]!=-1) res.pb(a[i]);
		res.pb(2*inf-i);
	}
	reverse(res.begin(),res.end());
	s=res;
	sort(s.begin(),s.end());
	for(int &i:res) i=lower_bound(s.begin(),s.end(),i)-s.begin();
	return res;
} 
```

---

## 作者：enucai (赞：10)

## Preface

随机化算法。

## Analysis

考虑随机一个长度 $n$，再随机一个长度为 $n$ 的排列。算出这个排列中在每一位后面加数所产生的贡献。用这些贡献去凑出还需要增加的上升子序列个数即可。凑不出或长度过长就重新随机。

### 细节 1

“算出这个排列中在每一位后面加数所产生的贡献。”

考虑 Dp。先从前往后 Dp 算出以每一种数结尾的上升子序列个数，即：

$$g_i=\sum\limits_{j=1}^{i-1}g_j\times[\mathtt{location}_j<\mathtt{location}_i]$$

其中 $\mathtt{location}_i$ 表示数字 $i$ 在排列中的的位置。这个 Dp 可以使用树状数组优化到 $n\log n$。

再对 $g$ 按照**位置**做一次前缀和即可求出 $f_i$ 表示在位置 $i$ 后面加 $\ge n$ 的数所产生的贡献。即：

$$f_i=\sum\limits_{j=1}^ig_{a_j}$$

### 细节 2

“用这些贡献去凑出还需要增加的上升子序列个数即可。”

最容易想到的是背包。但是数字的值太大，背包算法不能被接受。因此考虑贪心，由于 $f$ 从后往前的值是依次递减的，因此从后往前贪心凑数即可得到很优的答案。

### 细节 3

“随机一个长度为 $n$ 的排列。”

如果排列过于随机，则所有的贡献都不会很大，就很难得到满足要求的解。因此我们先将 $0$ 至 $n-1$ 从小到大排列，随机数 $i$ 向前移 $\Delta_i\in[0,5]$ 位（若 $k$ 很大，则移 $\Delta_i\in[0,2]$ 位）。这样就能保证排列整体呈上升趋势，容易得到解。

### 细节 4

参数问题，$k$ 在不同范围时 $n$ 适合区的范围也不同。若范围参数不当，会导致凑出答案的期望枚举次数过高。

（这一点本题解没有通过计算得到最优答案，但使用的参数足以通过此题，读者可自行思考更优的参数范围。）

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=(j);i<=(k);i++)
#define Rof(i,j,k) for(int i=(j);i>=(k);i--)
#define ll long long
#define lll __int128
int get(int l,int r){
	return 1ll*rand()*rand()%(r-l+1)+l;
}
int a[110],delta[110],add[110],pos[110];
lll f[110],g[110],c[110];
void upd(int x,lll val){
	while(x<=100) c[x]+=val,x+=x&(-x);
}
lll qry(int x){
	lll res=0;
	while(x) res+=c[x],x-=x&(-x);
	return res;
}
stack<int> st;
vector<int> res;
std::vector<int> construct_permutation(ll k){
	srand(time(0));
	while(1){
		int n;
		if(k<=1000000ll) n=get(1,20);
		else if(k<=10000000000ll) n=get(30,40);
		else if(k<=100000000000000ll) n=get(50,60);
		else if(k<=10000000000000000ll) n=get(65,75);
		else n=get(70,75);
		For(i,0,n-1) a[i]=i;
		For(i,0,n-1) delta[i]=get(0,5);
		For(i,0,n-1) pos[i]=i;
		if(k>10000000000000000ll) For(i,1,n-1) delta[i]=get(0,2);
		For(i,0,n-1){
			int now=pos[i],tar=max(0,now-delta[i]);
			Rof(j,now,tar+1) swap(pos[a[j]],pos[a[j-1]]),swap(a[j],a[j-1]);
		}
		memset(f,0,sizeof(f));
		memset(c,0,sizeof(c)); 
		f[1]=1; upd(1,1);
		For(i,0,n-1) f[a[i]+2]+=qry(a[i]+1),upd(a[i]+2,f[a[i]+2]);
		lll sum=0;
		For(i,1,n+1) sum+=f[i];
		if(sum>(lll)k) continue;
		lll rest=k-sum;
		For(i,0,n-1) f[i]=f[i+2];
		For(i,0,n-1) g[i]=f[a[i]];
		For(i,1,n-1) g[i]=g[i]+g[i-1];
		For(i,0,n-1) g[i]++;
		if(n+rest/g[n-1]>90) continue;
		memset(add,0,sizeof(add));
		Rof(i,n-1,0){
			while(rest>=g[i]) add[i]++,rest-=g[i];
		}
		if(rest>0) continue;
		while(!st.empty()) st.pop();
		res.clear();
		int now=n;
		Rof(i,n-1,0){
			For(j,1,add[i]) st.push(now),now++;
			st.push(a[i]);
		}
		if(now>=90) continue;
		while(!st.empty()) res.push_back(st.top()),st.pop();
		return res;
	}
}
```

评测记录：[Status](https://www.luogu.com.cn/record/77082137)，评测最劣时间 $999$ms（极限 qwq）。

---

## 作者：xzzduang (赞：6)

2022.7.8 update：修改了代码，感谢 @feecle6418 提供的 hack。

[传送门](https://www.luogu.com.cn/problem/P8376)

一般这种比较开放的构造题都很适合乱搞。

考虑一个 $k$ 怎么被得出来，显然可以通过一个简单的 DP $f_i=1+\sum_{a_j<a_i}f_j$ 计算。

考虑往排列里从 $0$ 到 $n$ 插数，每次尽可能往后放，这样 $f$ 会尽可能地大，就更容易达到 $k$。这种贪心的做法已经能水到 91 分了！

可以想一想这种贪心填的方法为什么不是最优，是因为虽然它能快速的接近 $k$，但是要恰好凑出 $k$ 却不简单。这种贪心的填法 $f$ 会增长的很快，所以当填到 $k$ 剩下不多的时候，我们的 $f$ 小的很小，大的很大，而剩下的 $k$ 不足以填大的，只能不停地填小的，所以 $n$ 就超了。

解决方法也很简单，我们让每次插数的时候存在 $\frac{1}{5}$ 的概率不尽量填大的，而是在合法的范围内随机一个位置填就好啦！

最终代码就只有二十多行。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> construct_permutation(long long k);
int a[5005];
long long f[5005];
vector<int> construct_permutation(long long k){
    mt19937 rnd(114514);
    k--;vector<int> res;
    int n=0;long long kk=k;
    for(;;k=kk,n=0){
        while(k){
            int pos=0;long long sum=1;
            while(pos+1<=n && sum+f[a[pos+1]]<=k) pos++,sum+=f[a[pos]];
            if(rnd()%5<1) pos=rnd()%(pos+1);
            sum=1;
            for(int i=1;i<=pos;++i) sum+=f[a[i]];
            for(int i=n;i>=pos+1;--i) a[i+1]=a[i];
            a[pos+1]=++n,f[n]=sum,k-=f[n];
        }
        if(n<=90){for(int i=1;i<=n;++i) res.push_back(a[i]-1);return res;}
    }
}
```



---

## 作者：Sheng_Horizon (赞：3)

# P8376 [APIO2022] 排列
## 题目大意

寻找一个长度为 $n$ 的数列，数列是 $0,1,\dots,n-1$ 的一个排列，使它的递增子序列数恰好是 $k$。注意 **$n$ 并没有给定**，因此本题还要求在得到数列的同时使其长度 $n$ 最小。

## 前置引入

1. 当一个数列 $p[0],p[1],\dots,p[n-1]$ 正好是顺序的时，它有着所有由 $n$ 个元素组成的数列中最多的递增子序列数量，数量为 $2^n$。

   至于为什么是最多，感觉一下就知道了。

   $Eg:$ 对于数列 $0,1,2,3$，它的递增子序列有：

   	1. $(Empty)$ **是的空串也是递增子序列**
   	1. $[0],[1],[2],[3]$
   	1. $[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]$
   	1. $[0,1,2],[0,1,3],[0,2,3],[1,2,3]$
   	1. $[0,1,2,3]$

   共 $2^4=16$ 个

2. 一个长度为 $n$ 的顺序数列的递增子序列的个数为 $2^n$ 的本质是：

   在该数列中，每个数都有 **选择被递增子序列包括** 与 **选择不被递增子序列包括** 两个选项，根据排列组合的乘法原理，$n$ 个 $2$ 相乘即为 $2^n$。

##  题解

### 正解思路的根基：91分做法

我们首先把 $k$ 化为二进制，在这里以 $k=(21)_{10}$ 为例

因此 $k=(10101)_2=2^4+2^2+2^0$

根据前置引入，我们**希望将 $k$ 用多个顺序数列整合在一起处理掉**

这里以上述 $k=21$ 为例，具体这样做：

1. 为了处理掉 $2^4$，我们先列开一个长度为 $4$ 的顺序数列：

   $$[1,2,3,4]$$

2. 接下来我们想处理掉 $2^2$，这时我们在数列的第二个数后面加上数字 $5$：

   $[1,2,5,3,4]$

   这样，尽管 $[1,2,3,4]$ 被隔开，但仍有 $2^4$ 个递增子序列，而 $[1,2,5]$ 又担起了提供 $2^2$ 个递增子序列的责任。

   可是，明明 $[1,2,5]$ 有三个数，为什么不是提供 $2^3$ 个而是 $2^2$ 个递增子序列呢？

   因为在 $[1,2,5]$ 中，$5$ **必须被包括在递增子序列中**，否则去掉 $5$ 后，$[1,2]$ 的取值和 $[1,2,3,4]$ 是重复的。

3. 处理 $2^0$ 的方法与处理 $2^2$ 一致，不再赘述。

上面所述的操作可以被画成一个图，如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/kluw02b6.png)

这样做的信息复杂度是 $O(\log k)$ ，这已经是本题最优级别的复杂度了（因为 $n$ 个元素的数列最多有 $2^n$ 个递增子序列；反之，想要得到 $k$ 个 递增子序列，至少需要 $\lceil\log_2 k\rceil$ 个元素）。但是该做法常数太大：

$\log_2 10^{18}\approx60$，根据题目，$n$ 要在 $90$ 之内，这意味着信息复杂度的常数最大只能是 $1.5$。当前做法在类似于 $k=(11111111\dots111)_2$ 的情况下信息复杂度 $\approx \log_2k+\log_2k=2\log_2k$，常数为 $2$，超了。

至于为什么，画一个和上一张图类似的图就明白了（这里以 $k=(111111)_2$ 为例）

![](https://cdn.luogu.com.cn/upload/image_hosting/zg99a60q.png)

二倍常数的罪魁祸首就是，由于 $k$ 在二进制下每一位都是 $1$，为此需要为除了第一个 $1$ 的所有 $1$ 都新增一个数。而刚好 $k$ 又有 $\log_2k$ 个二进制位，常数就多了 $1$。

### 正解

于是，顺理成章地，正解就成了**卡常**



![](https://cdn.luogu.com.cn/upload/image_hosting/ydh8h7h5.png)

仍以 $k=(111111)_2$ 为例。维护两个值，$MAX$ 和 $SECONDMAX$，分别指向当前数列中最大数和次大数的位置。

**仍是从后往前处理**

后三个 $1$ 仍按照老方法处理，这样做的目的是 用为了维护第 $5,4$ 个 $1$ 而新建的点维护 $MAX$ 和 $SECONDMAX$（处理最后一个 $1$ 时不需要额外增加数）。

前面的 $1$，**如果存在有两个 $1$ 连续**，则将这两个 $1$ 以一组处理。

具体处理方法是：如上面例子的第 $2,3$ 个 $1$，它们分别代表着 $2^1$ 和 $2^2$ 个递增子序列。先将 $MAX$ 和 $SECONDMAX$ 处的数增加 $1$，然后在第一个数后面插入一个 比 $MAX$ 和 $SECONDMAX$ 处小，比其他值大的（即第三大的）数。

这样就产生了个新的子数列：$[0,5,7]$ 和 $[0,5,6]$。其中 $5$ 必须在递增子序列里，$6,7$ 在不在皆可，$0$ 以及 $0$ 前面的数（如果在其他情况下有的话）则负责产生贡献。

因此，产生递增子序列现在去三个情况分类讨论：

1. 递增子序列中取 $6$
2. 递增子序列中取 $7$
3. 递增子序列中既不取 $6$ 也不取 $7$

而 $0$ 以及 $0$ 前面的数（如果在其他情况下有的话），即产生贡献的部分处在全部三个情况中。这样，在这里就能产生 $3*2^0=2^0+2*2^0=2^0+2^1$ 的贡献。

更一般的，对于两个连续的，分别在位置 $a,a+1$ 的 $1$ ，想要共增加 $2^{a-1} +2^{a}$ （注意在位置 $a$ 的 $1$ 的实际值是 $2^{a-1}$ 次方！）个递增子序列，只需先将 $MAX,SECONDMAX$ 处的值加一，再在当前数列的位置 $a-1$ 后面加入一个数 $\alpha$，使其成为当前数列第三大数，即可获得 $3*2^{a-1} =2^{a-1}+2*2^{a-1}=2^{a-1}+2^{a}$ 的 递增子序列贡献。

**如果两个 $1$ 非延续，或仅剩一个 $1$**，处理方式和老方法基本相同，按老方式插入数 $\alpha=当前数列最大数+1$，并更新 $MAX,SECONDMAX$ 使它们正确指向当前最大值和次大值。

这样，即可使 增加新数 的信息复杂度常数缩减到原来的一般，是信息复杂度 $O(\log k)$ 的常数将至 $1+0.5=1.5$，刚好通过此题。

有些东西文字讲不清楚，看代码。

```cpp
#include <vector>
#include<bits/stdc++.h>
using namespace std;

std::vector<int> construct_permutation(long long k)
{
	vector<int> vc;
	vector<int> ans;
	int MAX,SEM;//即 MAX 和 SECONDMAX
	vc.clear();
	while(k){
		vc.push_back(k&1);
		k>>=1;
	}
	int n=vc.size();
	for(int i=0;i<n-1;i++) ans.push_back(i);
	int mi=n-2;
	n-=2;
	//初始化最大、次大值的位置
	int count=0;
	while(count<2&&mi>=0){
		while(mi>=0&&!vc[mi]) mi--;
		if(mi>=0&&vc[mi]){
			ans.insert(ans.begin()+mi,++n);
			if(count==0) SEM=mi;
			else{
				MAX=mi;
				SEM++;
			}
			count++;
			mi--;
		}
	}
	//继续往后
	int synic=0;
	while(mi>=0){
		while(mi>=0&&!vc[mi]) mi--;
		//两个1一起
		if(mi>0&&vc[mi]&&vc[mi-1]){
			ans[SEM]++,ans[MAX]++;
			ans.insert(ans.begin()+mi-1,ans[SEM]-1);
			SEM++,MAX++;
			mi-=2;
		}
		//一个1
		else if(mi>=0&&vc[mi]){
			ans.insert(ans.begin()+mi,ans[MAX]+1);
			SEM=MAX;
			MAX=mi;
			SEM++;
			mi--;
		}
	}
	for(int i=0;i<ans.size();i++){
		if(ans[i]<0){
			ans[i]=ans[MAX]-ans[i];
		}
	}
	return ans;
}
```



---

## 作者：Erine (赞：2)

呃为什么没有我这种做法。

考虑两个序列 $a,b$ 拼接在一起。假设递增子序列数分别为 $x,y$。如果你让右边整体加，做到 $\max\{a\}<\min\{b\}$，子序列数会变成 $xy$。否则令左边整体加，会变成 $x+y-1$（$-1$ 是因为空序列会被算两次）。

对于 $k$ 很大的部分，暴力 pollard-rho 分解一下质因数，然后随便找一个接近 $\sqrt k$ 的因数 $p$，从 $p$ 和 $\dfrac kp$ 合并过来。

对于 $k\le 100$ 的部分，暴力枚举当前排列是怎么被拆成了两部分，更新一下。

大质数就寄了。所以 $k$ 是质数的时候我们递归构造 $k-1$ 的答案，然后全部抬高 $1$ 后边再补一个 $0$ 就好了。

不会算复杂度，但是跑的飞快，随了几个数答案也在 $85$ 以内。

```cpp
int dec(int n) {
	int B = min(n - 1, (int)sqrt(n) * 4), cur = 1;
	vector<int> d;
	while (n > 1) {
		int x = pr(n);
		d.push_back(x);
		n /= x;
	}
	if (n > 1) d.push_back(n);
	for (int i : d) if (i * cur <= B) cur *= i;
	return cur;
}

vector<int> f(int k) {
	if (k <= 100) return bk[k];
	vector<int> ans;
	if (mr(k)) {
		ans = f(k - 1);
		for (int &i : ans) ++i;
		ans.push_back(0);
	} else {
		int p = dec(k);
		ans = f(k / p);
		int x = ans.size();
		vector<int> r = f(p);
		for (int i : r) ans.push_back(i + x);
	}
	return ans;
}
```

---

## 作者：FjswYuzu (赞：2)

如果有一个单独的长为 $n$ 的上升子序列，那么可以在这个子序列上拆出总共 $2^n$ 个上升子序列。

那么有一个 $n=2 \log_2 k$ 的构造方案。先构造一个长为 $n = \lceil \log_2 k \rceil$ 的上升子序列，然后将 $k$ 二进制拆分，如果有 $2^i$ 这一位就倒着数在第 $i$ 个空位插入一个点，新插入的所有点按序列的顺序满足单调下降，这样最坏是 $2 \log_2 k$ 的。

那么现在问题出现了，$90 ≈ 1.5 \log_2 k$。首先构造长为 $\log_2 k$ 的上升子序列已经被固定，还有 $0.5 \log_2 k$ 要处理 $k$ 的每一位。

Motivation: 观察限制数值特点。

那么我们考虑把满足某些性质的两位绑一块儿，并且之前用两个点现在用一个点代替。

一通乱配分析之后，发现如果之前有 $a,b,c_1,c_2$ 满足 $a < b < c_1 = c_2-1$（四个都是指插入位置），我们只保留 $a,b,c_2$ 并且使 $v_{c_2} > v_a > v_b$ 就好。

证明的话，记 $c_2$ 的贡献为 $x$，那么 $c_1$ 的贡献为 $2x$。现在这么处理之后 $c_2$ 有个基本贡献 $x$，然后 $a \to c_2 \to \cdots$ 和 $b \to c_2 \to \cdots$ 的贡献也是 $x$，加和贡献和之前相同。

然后对于其他的，也就是前后都没有相邻的 $1$ 的时候，我们只需要保证不会有前面的点通过这个点造成多余的贡献。

那么构造要求是：

- 如果当前没满两个点：暴力插；   
- 如果当前点前后没有其他的 $1$：插入的点比当前插入的所有点还要小；    
- 如果当前点后面有其他的 $1$：在后面插入权值在第二小的点和第三小的点权值之间的一个点。

这个可以用 `set` 维护，怪七八糟一顿写就过了。

哦对了，不要用 `log2` 和 `log`，这两大笔东西精度太低了。

```cpp
#include <vector>

std::vector<int> construct_permutation(long long k);

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
vector<int> construct_permutation(LL k)
{
	static int sta[70];
	memset(sta,0,sizeof sta);
	int n=0;
	while((1ll<<n)<=k)	++n;
	--n;
	int c=0,u=10086001,d=10086;
	set<int> S;
	for(int i=n-1;~i;--i)
	{
		if((k>>i)&1)
		{
			if(c<2)	S.insert(sta[i]=u),u-=100000,++c;
			else if(!i || !((k>>(i-1))&1))
			{
				int c=*S.begin()-100000;
				sta[i]=c;
				S.insert(c);
			}
			else
			{
				int c=*next(S.begin())+(--d);
				sta[--i]=c;
				S.insert(c);
			}
		}
	}
	vector<int> B;
	for(auto v:S)	B.push_back(v);
	for(int i=0;i<n;++i)	if(sta[i])	sta[i]=lower_bound(B.begin(),B.end(),sta[i])-B.begin();else	sta[i]=-1;
	int t=int(B.size());
	vector<int> Ret;
	// printf("%d\n",n);
	for(int i=n-1;~i;--i)
	{
		Ret.push_back(t++);
		if(~sta[i])	Ret.push_back(sta[i]);
	}
	return Ret;
}
```

---

## 作者：Sol1 (赞：2)

场外选手自己口胡一个多小时干掉了这个题，还是挺开心的。

首先有个朴素想法：按值域分段 $[0,p_1),[p_1,p_2),\cdots,[p_{k-1},p_k),[p_k,n)$，然后再反过来接起来 $p_k,p_k+1,\cdots,n-1,p_{k-1},p_{k-1}+1,\cdots,p_k-1,\cdots,0,1,\cdots,p_1-1$。

分段的时候先 $-1$（减去空子序列），然后每一段贡献 $2^{l}-1$ 其中 $l$ 是这一段的长度。从而每一次 +1 然后取二进制最低位，重复即可。

这样构造大概是 $\dfrac{1}{2}\log^2n$ 的，听说能得 $71.2$ 分。

然后为了方便考虑，在这个序列前面加一个 $-\infty$，规定它必须选在子序列里面，然后把这个序列转成一个 DAG。那么上升子序列个数就可以这样计数：$-\infty$ 的权值是 $1$，然后每一个点的权值是除了自己以外能到它的点的权值之和，最终答案是所有点的权值之和。

得到这个模型之后可以注意到上面的构造算法就是构造了若干条从根出发的链，这看起来就挺浪费的，考虑能不能压成一棵树。

考虑保留一条链，那么这条链上面的点权就分别是 $1,1,2,4,8,16,\cdots$，然后每一个位置支出来一个点可以得到一个 $2$ 的整数次幂，于是直接二进制拆分即可，构造量级 $2\log n$，听说能得 $91.36$ 分。~~现场写这个跑路就行了。~~

现在感觉树的压缩能力也被榨干了，考虑用图来进行压缩。

发现 $\dfrac{3}{2}\log n$ 就可以通过，考虑进行四进制拆分，这需要我们构造出一个 $3$。自然的想法就是把支出来的点接到两个出度为 $0$ 的点上就可以 $\times 3$ 了。

于是我们有这样一个想法：构造一条链，然后考虑剩下的数。把二进制最高位支出去一个点设为 $T_1$，把链头设为 $T_2$，这样如果一个点要 $\times 3$ 就把它向 $T_1$ 和 $T_2$ 连边。

可惜的是，这样并不能保证构造出的图一定可以转成一个序列。考虑这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/y5zbfwab.png)

手摸一下可以发现 10 在这种情况下一定会有出边。整合一下发现只要有一个 $\times 1$ 点出现在 $\times 3$ 点的上面就会出现这个问题。

但是没有关系！我们可以把 $\times 3$ 点向上面最近的两个 $\times 1$ 点连边，这样就不会出现这个问题。

最后进行两次拓扑排序。第一次优先扩展距离大的点，距离一样的优先扩展链上的点，记录每一个点被扩展到的时间；第二次优先扩展时间晚的点。

构造量级 $\dfrac{3}{2}\log n$，可以通过。

感觉不太方便说清楚，可以看代码理解。

```cpp
struct Edge {
	int to, nxt;
	Edge() {
		nxt = -1;
	}
};
int n, hd[105], pnt, idx[105], indgr[105], indt[105];
Edge e[100005];

inline void AddEdge(int u, int v) {
	// cerr << u << "->" << v << endl;
	e[++pnt].to = v;
	e[pnt].nxt = hd[u];
	hd[u] = pnt;
	indgr[v]++;
}

std::vector<int> construct_permutation(long long k) {
	k--;
	memset(indgr, 0, sizeof(indgr));
	memset(hd, -1, sizeof(hd));
	pnt = 0;
	int npnt = 0;
	long long tmp = k + 1;
	while (tmp >> 1) {
		npnt++;
		AddEdge(npnt - 1, npnt);
		tmp >>= 1;
	}
	k++; k -= (1ll << npnt);
	// cerr << "npnt = " << npnt << " k = " << k << endl;
	if (k) {
		int t1 = npnt;
		int lg = 63 - __builtin_clzll(k);
		AddEdge(lg, ++npnt);
		k -= (1ll << lg);
		int t2 = npnt;
		int s = 0;
                //从上到下构造
		while (k) {
			int lg = 63 - __builtin_clzll(k);
			if (lg && (k & (3ll << (lg - 1))) == (3ll << (lg - 1))) {//x3 点
				AddEdge(lg - 1, ++npnt);
				AddEdge(npnt, t1); AddEdge(npnt, t2);
				k -= 3ll << (lg - 1);
			} else {//x1 点
				AddEdge(lg, ++npnt);
				t1 = t2; t2 = npnt;//切换最近的 x1 点
				k -= 1ll << lg;
			}
		}
	}
	
	// cerr << "pass" << endl;
	memcpy(indt, indgr, sizeof(indt));
	priority_queue <pair <int, int> > que;
	que.push(make_pair(0, 0));//第一次拓扑排序，我的实现保证链上的点是编号最小的，所以二元组第二个放下标即可
	int cnt = 0;
	while (!que.empty()) {
		pair <int, int> cur = que.top();
		que.pop();
		cnt++;
		int u = cur.second;
		idx[u] = cnt;//记录时间
		for (int i = hd[u];~i;i = e[i].nxt) {
			indgr[e[i].to]--;
			if (!indgr[e[i].to]) {
				que.push(make_pair(cur.first + 1, e[i].to));
			}
		}
	}
	memcpy(indgr, indt, sizeof(indgr));
	que.push(make_pair(0, 0));//第二次拓扑排序
	vector <int> ans;
	while (!que.empty()) {
		pair <int, int> cur = que.top();
		que.pop();
		if (cur.second) ans.push_back(idx[cur.second] - 2);
		int u = cur.second;
		for (int i = hd[u];~i;i = e[i].nxt) {
			indgr[e[i].to]--;
			if (!indgr[e[i].to]) {
				que.push(make_pair(idx[e[i].to], e[i].to));
			}
		}
	}
	// for (int i : ans) cerr << i << " "; cerr << endl;
	return ans;
}
```

---

## 作者：401rk8 (赞：1)

给一个比较简单的随机化做法，与现有两篇题解都不同，没证出正确性

---

核心思想是二进制拆分，从小到大加数

记 $n=\log k$。考虑一个 $2n$ 的做法:

1. 初始有 $n$ 的递增数列
2. 如果 $k-2^{n}$ 的第 $i$ 位为 $1$，就在第 $i$ 位后加入一个数（前面的数都比新加的数小因此恰好贡献 $2^i$）

冷静一下发现这个做法实际上是 $n+\text{popcount}(k)$ 的，题目要求的长度为 $90=\frac{3}{2}n$，因此 $\text{popcount}$ 只能有 $\frac{1}{2}n$。随机情况下是恰好能过的，考虑打乱 $k$ 的二进制表示

第一步的作用主要是为第二步提供足够多的数（显然第二步中 $i<n$），而贡献 $2^n$ 只是顺带的。可以考虑在第一步后 `shuffle` 数列的前缀，$\text{popcount}(k-\text{现有上升子序列数})$ 期望只有 $\frac{1}{2}n$  
此时第二步不能直接构造（放到第 $i$ 位后不一定贡献 $2^i$），新加入数贪心往后放即可  
时间复杂度 $O(q\text{ poly }n)$，根据调参可以得到 $[97,100]$ pts

现场选手没拿到代码就不放了，很好写但还是懒得再写一遍了

> Cyber_Tree: 我能用 < 1KB 写完，赌不赌？

---


# [CSP-S2019] 划分

## 题目描述

2048 年，第三十届 CSP 认证的考场上，作为选手的小明打开了第一题。这个题的样例有 $n$ 组数据，数据从 $1 \sim n$ 编号，$i$ 号数据的规模为 $a_i$。

小明对该题设计出了一个暴力程序，对于一组规模为 $u$ 的数据，该程序的**运行时间**为 $u^2$。然而这个程序运行完一组规模为 $u$ 的数据之后，它将在任何一组规模**小于** $u$ 的数据上运行错误。样例中的 $a_i$ 不一定递增，但小明又想在不修改程序的情况下正确运行样例，于是小明决定使用一种非常原始的解决方案：将所有数据划分成若干个数据段，段内数据编号**连续**，接着将同一段内的数据合并成新数据，其规模等于段内原数据的**规模之和**，小明将让新数据的规模能够递增。

也就是说，小明需要找到一些分界点 $1 \leq k_1 \lt k_2 \lt \cdots \lt k_p \lt n$，使得

$$ \sum_{i=1}^{k_1} a_i \leq \sum_{i=k_1+1}^{k_2} a_i \leq \cdots \leq \sum_{i=k_p+1}^{n} a_i $$

注意 $p$ 可以为 $0$ 且此时 $k_0 = 0$，也就是小明可以将所有数据合并在一起运行。

小明希望他的程序在正确运行样例情况下，运行时间也能尽量小，也就是**最小化**

$$ (\sum_{i=1}^{k_1} a_i)^2 + (\sum_{i=k_1+1}^{k_2} a_i)^2 + \cdots + (\sum_{i=k_p+1}^{n} a_i)^2 $$

小明觉得这个问题非常有趣，并向你请教：给定 $n$ 和 $a_i$，请你求出最优划分方案下，小明的程序的最小运行时间。


## 说明/提示

【样例 1 解释】

最优的划分方案为 $\{5,1\}, \{7\}, \{9\}, \{9\}$。由 $5 + 1 \leq 7 \leq 9 \leq 9$ 知该方案合法。

答案为 $(5 + 1)^2 + 7^2 + 9^2 + 9^2 = 247$。

虽然划分方案 $\{5\}, \{1\}, \{7\}, \{9\}, \{9\}$ 对应的运行时间比 $247$ 小，但它不是一组合法方案，因为 $5 \gt 1$。

虽然划分方案 $\{5\}, \{1,7\}, \{9\}, \{9\}$ 合法，但该方案对应的运行时间为 $251$，比 $247$ 大。

【样例 2 解释】

最优的划分方案为 $\{5\}, \{6\}, \{7\}, \{7\}, \{4,6,2\}, \{13\}, \{19,9\}$。

【数据范围】

| 测试点编号 | $n \leq$ | $a_i \leq$ | $type =$ |
| :----------- | :----------- | :----------- | :----------- |
| $1 \sim 3$ | $10$ | $10$ | 0 |
| $4 \sim 6$ | $50$ | $10^3$ | 0 |
| $7 \sim 9$ | $400$ | $10^4$ | 0 |
| $10 \sim 16$ | $5000$ | $10^5$ | 0 |
| $17 \sim 22$ | $5 \times 10^5$ | $10^6$ | 0 |
| $23 \sim 25$ | $4 \times 10^7$ | $10^9$ | 1 |

对于$type=0$的所有测试点,保证最后输出的答案$\leq 4 \times 10^{18}$

所有测试点满足：$type \in \{0,1\}$，$2 \leq n \leq 4 \times 10^7$，$1 \leq a_i \leq 10^9$，$1 \leq m \leq 10^5$，$1 \leq l_i \leq r_i \leq 10^9$，$0 \leq x,y,z,b_1,b_2 \lt 2^{30}$。

## 样例 #1

### 输入

```
5 0
5 1 7 9 9```

### 输出

```
247```

## 样例 #2

### 输入

```
10 0
5 6 7 7 4 6 2 13 19 9```

### 输出

```
1256```

## 样例 #3

### 输入

```
10000000 1
123 456 789 12345 6789 3
2000000 123456789 987654321
7000000 234567891 876543219
10000000 456789123 567891234```

### 输出

```
4972194419293431240859891640```

# 题解

## 作者：syksykCCC (赞：110)

~~**UPD：官方数据出来，原题解无法通过。现在已经常数优化，保险起见，评测请开启 O2。**~~

**（一年半后）UPD2：经过一晚上的卡常，手写高精度终于在不开 O2 的情况下稳稳地通过了这题！**

---

既当作是一个赛场自己没做出来的总结，也给那些不愿使用 `__int128` 的同学们一篇可以参考的题解吧。

首先由 **完全平方公式** ，可以得到 $(a + b)^2 \ge a^2 + b^ 2$。

所以，我们要尽可能 **多分段**。

观察这个图：

![](https://i.loli.net/2019/12/01/M18YfQrFOXDikC6.png)


如果此时，$sum_L + x \le sum_R$，那么 $x$ 这个数应该分到那一边呢？

显然，$sum_L \le sum_R$，$x$ 加到 $side$ **那边** 将会产生 $2x\cdot sum_{side}$ 的代价。

为了使得总代价最小，我们当然把 $x$ 加到 $sum_L$ 那一边啦！

综上所述，对于某一段，我们贪心的在最靠后的可行位置划分，也就是使得最后一段最小，答案必然最优。

-----

64pts 的做法是贪心的记录这一段的值，枚举 **上一段的终点**。

大概就是这样：

```cpp
for(int i = 2; i <= n; ++i)
    for(int j = 1; j < i; ++j)
        if(sum[i] - sum[j] >= last[j] && f[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) < f[i])
            f[i] = f[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]), last[i] = sum[i] - sum[j];
```

$last_i$ 表示以 $i$ 结尾的那一段的和，$f_n$ 即为答案。

----

那 100pts 的做法呢？

用 $g_i$ 表示现在划分段的末尾为 $i$ ，**上一段的末尾**。

用 $s_i$ 表示 $\sum_{k = 1}^{i} a_k$（前缀和）。

换言之， $g_i = \max pos\ s.t.  \ s_i - s_{pos} \ge s_{pos} - s_{g_{pos}}$。

移项得到，$g_i = \max pos\ s.t.  \ s_i \ge 2s_{pos} - s_{g_{pos}}$。

令 $ val(x) = 2 s_x-s_{g_x} $，则$g_i = \max pos\ s.t.  \ s_i \ge val(pos)$，有结论：

如果 $x, y$ 都是当前位置 $i$ 的合法来源，即 $s_i \ge val(x), val(y)$，而且 $x<y$，则 $x$ 必然 **无法成为** $g_i$。

由此，当求 $g_i$ 时，先把单调队列中所有队首的过时决策弹出（如果队列中的下一个数的 $val$ 都 $\le s_i $ 的话，这个决策就被弹出）。
 
$g_i$ 就是 **新的队首** ，然后把 $i$ 加入决策时，要把队尾所有 $val \ge val(i)$ 的弹出（因为 $i$ 在它们 **后面** ，$val$ 还比它们 **小** ，那它们必然 **不会成为** 任何一个位置的 $g$ 了）。

最后一段的末端点是 $n$，所以让 $p = n$，不断的朝 $g_p$ 追溯，并统计答案。

注意时间优化，空间优化，高精度，时间复杂度 $O(n)$。

前缀和不用平方，不要开 **高精度数组** ！

代码如下:

```cpp
#include <stdio.h>
#include <ctype.h>
#include <memory.h>
#define rg register
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
#define val(x) (s[x] << 1) - s[g[x]]
typedef unsigned long long ULL;
const int MOD = (1 << 30) - 1, N = 4e7 + 3, M = 1e5 + 3, BASE = 1e9;
int g[N], b[N], p[M], q[N];
ULL s[N];
char buf[1 << 21], *p1 = buf, *p2 = buf;
inline int read()
{
    int val = 0; char c = gc();
    while(!isdigit(c)) c = gc();
    while(isdigit(c)) { val = (val << 3) + (val << 1) + (c ^ 48); c = gc(); }
    return val;
}
struct bigint
{
    int len;
    ULL num[4];
    bigint operator + (const bigint &oth)
    {
        bigint res; 
        memset(res.num, 0, sizeof(res.num));
        res.len = len > oth.len ? len : oth.len; rg ULL p = 0;
        for(rg int i = 0; i < res.len; i++) 
        {
            res.num[i] = num[i] + oth.num[i] + p;
            p = res.num[i] / BASE;
            res.num[i] -= BASE * p;
        }
        if(p) res.num[res.len++] = p;
        return res;
    }
} ans;
int main()
{
    int n = read(), type = read();
    if(type)
    {
        ULL x, y; int z, m, l, r;
        x = read(); y = read(); z = read(); b[1] = read(); b[2] = read(); m = read();
        for(rg int i = 3; i <= n; i++) b[i] = (x * b[i - 1] & MOD) + (y * b[i - 2] & MOD) + z & MOD;
        for(rg int j = 1; j <= m; j++)
        {
        	p[j] = read(); l = read(); r = read();
        	for(rg int i = p[j - 1] + 1, a; i <= p[j]; s[i] = s[i - 1] + a, i++)
                a = b[i] % (r - l + 1) + l;
		}
    }
    else for(rg int i = 1, a; i <= n; s[i] = s[i - 1] + a, i++) a = read();
   	rg int head = 1, tail = 1;
    for(rg int i = 1; i <= n; i++)
    {
        while(head < tail && val(q[head + 1]) <= s[i]) head++;
        g[i] = q[head];
        while(head <= tail && val(q[tail]) >= val(i)) tail--;
        q[++tail] = i;
    }
    ans.len = 0;
    for(rg int pos = n; pos; pos = g[pos])
    {
        bigint tmp, res; ULL val = s[pos] - s[g[pos]];
        tmp.len = 0;
        while(val) { tmp.num[tmp.len++] = val % BASE; val /= BASE; }
	    memset(res.num, 0, sizeof(res.num));
	    res.len = (tmp.len << 1) - 1; ULL p = 0;
	    for(rg int i = 0; i < tmp.len; i++) for(rg int j = 0; j < tmp.len; j++)
	        res.num[i + j] += tmp.num[i] * tmp.num[j];
	    for(rg int i = 0; i < res.len; i++)
	    {
	        res.num[i] += p;
	        p = res.num[i] / BASE;
	        res.num[i] -= BASE * p;
	    }
	    while(p) { res.num[res.len++] = p % BASE; p /= BASE; }
        ans = ans + res;
    }
    printf("%llu", ans.num[ans.len - 1]); for(rg int i = ans.len - 2; ~i; i--) printf("%09llu", ans.num[i]);
    return 0;
}
```

---

## 作者：KSkun (赞：84)

本文同步发布在我的博客：[[CSP-S2 2019]划分 题解 | KSkun's Blog](https://ksmeow.moe/partition-csps219-sol/)，欢迎来逛~

广告：CSP-J/S2 2019 志愿者的幕后故事：[CSP-JS2 2019 游记 | KSkun's Blog](https://ksmeow.moe/csp-js2-2019/)

## 题意简述

给定一个长度为 $n$ 的数列 $\{a_i\}$，求对数列的一个划分 $T = \{ k_1, k_2, \dots, k_p \}$，使得该划分满足 $\sum\limits_{i=1}^{k_1} a_i\le \sum\limits_{i=k_1+1}^{k_2} a_i \le \dots \le \sum\limits_{i=k_p+1}^n a_i$，且最小化 $ \left(\sum\limits_{i=1}^{k_1} a_i \right)^2+\left(\sum\limits_{i=k_1}^{k_2} a_i \right)^2+\cdots +\left(\sum\limits_{i=k_p+1}^n a_i \right)^2 $。

## 题解

这个题的部分思路并不难，但最优解法确实具有一定的难度和复杂程度，以至于从开始写到整理思路写这篇题解一共用了三天时间。

### 最初的 DP

首先可以设计出一个比较简单的 DP，状态 $f(i, j)$ 表示对前 $i$ 个数字分段，上一段的结尾为 $j$ 的时候段平方和的最小值。转移时，枚举上一段的结尾 $j$，再枚举上上一段的结尾 $k$，先判断是否满足转移条件 $\sum\limits_{t=k+1}^j a_t \leq \sum\limits_{t'=j+1}^i a_{t'}$，然后进行最小化转移：

$$ f(i, j) = \min_{ \sum\limits_{t=k+1}^j a_t \leq \sum\limits_{t'=j+1}^i a_{t'} } \left\{ f(j, k) + \left( \sum\limits_{t=j+1}^i a_i \right)^2 \right\} $$

显然这个 DP 的复杂度为 $O(n^3)$。

### 贪心策略与 DP 优化

看这个式子：

$$ a^2 + b^2 < (a+b)^2 \ \ \ (a, b > 0) $$

在转移时，最后一段最长肯定越可能满足转移条件。当段较长的时候，可能将段从中间拆成多段也可以满足转移条件。假设切为两段后满足转移条件且前一段之和为 $a$、后一段之和为 $b$，上面的式子告诉我们，这里切成两段后的段平方和更小。因此，段肯定是越短越好的，或者也可以说，最后一段越短越好。事实上，段越短有利于之后分的段也较短。

因此，这里有贪心策略：段分得越短越好。

考虑将贪心应用进 DP 的过程中，既然最后一段越短越好，最优解中的最后一段一定是最短的，因此上一段的结尾不再有多种可能性，而是直接选择使最后一段最短的那一个。将前 $i$ 个数字分段的最优解中，上一段的结尾记为 $lst(i)$，DP 状态也可改为 $f(i)$ 代表前 $i$ 个数字分段的最优解的段平方和。转移方程如下：

$$ f(i) = \min_{ \sum\limits_{t=lst(j)+1}^j a_t \leq \sum\limits_{t'=j+1}^i a_{t'} } \left\{ f(j) + \left( \sum\limits_{t=j+1}^i a_i \right)^2 \right\} $$

复杂度降为 $O(n^2)$，但依然不够。

### 单调队列

记 $a_i$ 的前缀和为 $s(i)$，将转移条件写成前缀和的形式：

$$ s(j)-s[lst(j)-1] \leq s(i)-s(j) $$

移项可得

$$ s(i) \geq 2s(j)-s[lst(j)-1] $$

上式的左边只与 $i$ 有关，右边只与 $j$ 有关，我们需要找到满足上述条件的最大的 $j$。

此外，还可以发现，当一个 $j$ 满足上述条件时，根据前缀和的单增性可以得到 $s(i+1) \geq s(i) \geq 2s(j)-s[lst(j)-1]$，即 $j$ 也可以作为 $i+1$ 的决策。因此可行的决策点是一个以 $1$ 为左端点的区间，当 $i$ 增大时，决策点的区间右端点也是单增的（性质 1）。显然，$2s(j)-s[lst(j)-1]$ 的值越小，$j$ 越可能成为合法的决策点，也就是说，记 $A(j) = 2s(j)-s[lst(j)-1]$，当 $j_1 > j_2$ 且 $A(j_1) \leq A(j_2)$ 时，$j_1$ 一定优于 $j_2$（性质 2）。

上述性质决定了我们可以应用单调队列优化 DP 转移的复杂度：维护一个 $A(j)$ 数值单调递增且 $j$ 也单增的单调队列，每次转移时找到队列中最大的满足上述条件的决策点 $j_m$（性质 1），转移后仅保留 $j_m$ 而弹出小于 $j_m$ 的满足条件的决策点（性质 2）。转移完成后，计算 $A(i)$ 再将 $i$ 放入队列中，作为以后的状态的可能决策点。

利用单调队列优化 DP 后，转移的复杂度变为 $O(1)$，则总复杂度为 $O(n)$，可以通过极限数据。

### 卡常

由于最开始的写法使用了大量 STL 和常数略大的写法，在各种 OJ 上都跑不过极限数据，于是开始了卡常。

- 首先自然是用了 fread 版快读，这算是我的一个习惯。
- 在高精计算过程中利用特殊条件判断减少了总运算次数，尤其是减少了取模的次数。
- 原本是在输入之后单独算一遍前缀和，改成了边输入边算前缀和。
- 由于有点卡空间，复用了前缀和数组 s 的空间作为生成数据用的临时空间。
- 单调队列没封装，直接把实现展开到 DP 的过程中了。
- 手动开了个 O3。

最后终于在洛谷上 AC 了。不过没卡的这么极端的时候也能在 LOJ、UOJ 之类的地方跑过，可能洛谷跑的会略有点慢。

### 严谨性说明和性质证明

本题解的说明并不严谨，在说明单调队列优化转移时并未给出相关性质的证明，表述也不尽清晰。本文受本人水平、时间、精力等所限，暂时无法呈现出更好的效果，欢迎提出建议或改写本文部分内容。

关于有关性质的证明，可以在毛爷爷的博客：[CSP2019划分的简要题解 - 博客 - matthew99](http://matthew99.blog.uoj.ac/blog/5299)的博客阅读。

## 代码

```cpp
#pragma GCC optimize(3) // 手动开 O3
// Code by KSkun, 2019/12
#include <cstdio>
#include <cctype>
#include <cstring>

#include <algorithm>
#include <utility>

typedef unsigned long long LL;
typedef std::pair<int, int> PII;

inline char fgc() {
	static char buf[100000], * p1 = buf, * p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)
		? EOF : *p1++;
}

inline LL readint() {
	register LL res = 0, neg = 1; register char c = fgc();
	for (; !isdigit(c); c = fgc()) if (c == '-') neg = -1;
	for (; isdigit(c); c = fgc()) res = res * 10 + c - '0';
	return res * neg;
}

inline char readsingle() {
	char c;
	while (!isgraph(c = fgc())) {}
	return c;
}

const int MAXN = 40000005, MAXM = 100005;;
const LL MASK = (1ull << 30) - 1; // % 2^30 和 & MARK 等价

int n, type, lst[MAXN];
LL s[MAXN];

void gen_data() {
	LL x, y, z, m;
	x = readint(); y = readint(); z = readint();
	s[1] = readint(); s[2] = readint();
	m = readint();
	int* p = new int[MAXM], * l = new int[MAXM], * r = new int[MAXM];
	p[0] = l[0] = r[0] = 0;
	for (int i = 1; i <= m; i++) {
		p[i] = readint();
		l[i] = readint();
		r[i] = readint();
	}
	for (int i = 3; i <= n; i++) {
		s[i] = (x * s[i - 1] + y * s[i - 2] + z) & MASK; // 复用 s 数组省空间
	}
	for (int i = 1; i <= m; i++) {
		for (int j = p[i - 1] + 1; j <= p[i]; j++) {
			s[j] = (s[j] % (r[i] - l[i] + 1)) + l[i] + s[j - 1]; // 复用 s 数组省空间
		}
	}
	delete[] p; delete[] l; delete[] r; // 内存回收
}

const int BN_MAX = 1e9;
struct BigNum {
	LL dat[5];
	int len;
	BigNum() {
		dat[0] = dat[1] = dat[2] = dat[3] = dat[4] = 0; // 手动初始化没用 memset 减小常数
		len = 0;
	}
	BigNum(LL x) {
		dat[0] = dat[1] = dat[2] = dat[3] = dat[4] = 0;
		len = 0;
		while (x > 0) {
			dat[len++] = x % BN_MAX;
			x /= BN_MAX;
		}
	}

	BigNum operator+(const BigNum& rhs) const {
		BigNum res;
		if (len == 0) return rhs; // 减少运算次数
		if (rhs.len == 0) return *this;

		res.len = std::max(len, rhs.len);
		for (register int i = 0; i < res.len; i++) {
			if (dat[i] == 0 && rhs.dat[i] == 0) continue; // 减少运算次数
			res.dat[i] += dat[i] + rhs.dat[i];
			if (res.dat[i] > BN_MAX) { // 减少运算次数
				res.dat[i + 1] += res.dat[i] / BN_MAX;
				res.dat[i] %= BN_MAX;
			}
		}
		if (res.dat[res.len] != 0) res.len++;
		return res;
	}
	BigNum operator*(const BigNum& rhs) const {
		BigNum res;
		if (len == 0 || rhs.len == 0) return res;

		res.len = len + rhs.len - 1;
		for (register int i = 0; i < len; i++) {
			if (dat[i] == 0) continue; // 减少运算次数
			for (register int j = 0; j < rhs.len; j++) {
				if (rhs.dat[j] == 0) continue; // 减少运算次数
				res.dat[i + j] += dat[i] * rhs.dat[j];
			}
		}
		for (register int i = 0; i < res.len; i++) {
			if (res.dat[i] > BN_MAX) { // 减少运算次数
				res.dat[i + 1] += res.dat[i] / BN_MAX;
				res.dat[i] %= BN_MAX;
			}
		}
		if (res.dat[res.len] != 0) res.len++;
		return res;
	}
};

int d_dat[MAXN], d_l, d_r;

inline LL A(int idx) {
	return 2 * s[idx] - s[lst[idx]];
}

int main() {
	n = readint(); type = readint();

	if (type == 0) {
		for (register int i = 1; i <= n; i++) {
			s[i] = s[i - 1] + readint(); // 输入时就把前缀和做了，减小单独计算的常数
		}
	} else {
		gen_data();
	}

	d_l = d_r = 0; // 单调队列手写而且没封装，常数优化
	for (register int i = 1; i <= n; i++) {
		int lst_ele = 0;
		while (d_l != d_r && s[i] >= A(d_dat[d_l])) {
			lst_ele = d_dat[d_l]; d_l++;
		}
		lst[i] = lst_ele; d_dat[--d_l] = lst_ele;
		LL Ai = A(i); // 没空间存 A 数组，所以用函数，这里是避免重复运算减小常数
		while (d_l != d_r && Ai <= A(d_dat[d_r - 1])) d_r--;
		d_dat[d_r++] = i;
	}

	BigNum ans;
	for (register int i = n; i != 0; i = lst[i]) {
		BigNum t = BigNum(s[i] - s[lst[i]]);
		ans = ans + t * t;
	}
	for (register int i = ans.len - 1; i >= 0; i--) {
		if (i == ans.len - 1) {
			printf("%llu", ans.dat[i]);
		} else {
			printf("%09llu", ans.dat[i]);
		}
	}

	return 0;
}
```

---

## 作者：cjy2003 (赞：30)

这是一个贪心题，首先说结论：最优情况是划分的最后一段最小。

我们来证明这个结论。

首先，设 $sum_i$ 表示前缀和，令 $j$ 为长度为 $i$ 的前缀最优情况下的最后一个划分点，令 $s_i=sum_i-sum_j$

考虑归纳证明：

1. 长度为 $1$ 的前缀不需要划分，最后一段长度只能是 $1$，满足上面的条件。

2. 假设对于长度 $<i(i\ge 2)$ 的前缀，最优情况都是划分的最后一段最小，现在来说明长度为 $i$ 的前缀划分的最优情况也是划分的最后一段最小。

我们找到最大的 $j$，满足 $sum_i-sum_j\ge s_j$，此时前缀 $i$ 最后一个划分点可以是 $j$。

现在我们来说明对于其它满足 $sum_i-sum_k\ge s_k$ 且 $k<j$ 的 $k$，前缀 $i$ 以 $j$ 为最后一个划分点 一定不劣于 以 $k$ 为最后一个划分点。

我们分别考虑以 $j,k$ 为划分点时，整个前缀的所有划分点。

首先，下面这种情况是不存在的。

![](https://cdn.luogu.com.cn/upload/image_hosting/h9f1hau1.png)

在这种情况下，因为 $B$ 可以作为前缀 $C$ 的划分点，所以 $sum_D-sum_B> sum_C-sum_B\ge s_B$，且 $sum_D-sum_B<sum_D-sum_A=s_D$，前后仍然满足，于是 $B$ 作为前缀 $D$ 的划分点一定可行，而由归纳假设，我们可以得到，$D$ 一定不会以 $A$ 为划分点。

于是最终一定是下面两种情况之一。

![](https://cdn.luogu.com.cn/upload/image_hosting/e22jpj37.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/pbjlur3a.png)

其中第一条红线为两种划分下的最后一个公共划分点(这里把 $0$ 也看成了划分点)。

两种情况的区别仅仅在于公共划分点之后的第一个划分点属于前一种划分还是后一种划分。

然后除了第一种划分中最后的若干个划分点，其它的划分点都满足交替出现。

注意到我们只需要先说明 $j$ 比 $l$ 优，再说明 $l$ 比 $k$ 优即可，所以现在只考虑下面这两种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/584j9tzg.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/fi2ixm2q.png)

设前一种划分中公共划分点之后的每一段数字和为 $a_1,a_2,...,a_{n1}$，后一种划分为 $b_1,b_2,...,b_{n2}$

现在我们不考虑原序列，只考虑这两个 $a,b$ 序列，我们要证明 $\sum_{i=1}^{n1} a_i^2\le \sum_{i=1}^{n2} b_i^2$

我们来通过一些操作使 $a$ 和 $b$ 相同，并且要求对 $a$ 的操作不使 $a$ 更优，对 $b$ 的操作不使 $b$ 更劣，这样我们就可以推出 $a$ 不劣于 $b$ 了。

在两种情况中，如果 $b_1+1<b_{n2}$，那么我们找到最小 $l$ 满足 $b_l!=b_1$，找到最大的 $b_r$ 满足 $b_r!=b_{n2}$。

然后给 $b_{l-1}+1$，给 $b_{r+1}-1$，这样会使 $b$ 在满足 $b_i\le b_{i+1}$ 的同时变得更优。

如果这时存在 $b$ 序列的一个前缀和 $a$ 序列的一个前缀相等，我们就将 $a,b$ 从这个前缀的位置断开，分成两个子序列，将问题划分为两个子问题。可以看出，在子问题中，仍然满足划分点交替出现。我们一直进行这个操作，直到不能进行为止。

这时，我们有 $b_1=b_{n2}$ 或 $b_1=b_{n2}-1$

由于 $a_{n1}<b_{n2}$，所以 $a_{n1}\le b_1$，所以 $\forall i\in[1,n1],a_i\le b_1$

如果有 $n1=n2$，那么两个序列一定完全相同。

否则有 $n1=n2+1$，此时我们去掉 $a_1$，将 $a$ 重新编号，然后对于所有 $i\in[1,n2]$ 给 $a_i$ 加一个数，使之变为 $b_i$，则 $a$ 与 $b$ 相同了。注意到在这个过程中，我们使一个较小的数变小，较大的数变大，会使 $a$ 变得更劣。

于是，我们通过一些操作，使得 $a$ 与 $b$ 相同，并且所有对 $b$ 的操作都是使之更优，所有对 $a$ 的操作都是使之更劣，就可以得到 $a$ 不劣于 $b$。

这样就证明完了。

具体实现可以用单调队列，需要手写高精度。

复杂度 $O(n)$

代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cassert>
using namespace std;
namespace io
{
	const int N=1<<20;
	char buf[N],*t1=buf,*t2=buf;
	#define getc() t1==t2&&(t2=(t1=buf)+fread(buf,1,N,stdin),t1==t2)?EOF:*t1++
	inline int read()
	{
		static int an;an=0;
		static char ch;ch=getc();
		while(ch<48||ch>57)ch=getc();
		while(ch>=48&&ch<=57)an=(an<<3)+(an<<1)+(ch^48),ch=getc();
		return an;
	}
}
using io::read;
int n,op,f[40000010];
long long sum[40000010];

namespace task1
{
	long long dp[51][50050];
	void solve()
	{
		for(int i=1;i<=n;++i)
		{
			for(int j=0;j<=50000;++j)dp[i][j]=0x3f3f3f3f3f3f3f3fll;
			for(int k=0;k<i;++k)dp[i][sum[i]-sum[k]]=dp[k][sum[i]-sum[k]]+(sum[i]-sum[k])*(sum[i]-sum[k]);
			for(int j=1;j<=50000;++j)dp[i][j]=min(dp[i][j],dp[i][j-1]);
		}
		printf("%lld",dp[n][sum[n]]);
	}
}

int x,y,z,m,p[100010],l[100010],r[100010],b[40000010],pos=1;
int rnd(int i)
{
	if(i>2)b[i]=(b[i-1]*x+b[i-2]*y+z)&((1<<30)-1);
	if(i>p[pos])++pos;
	return b[i]%(r[pos]-l[pos]+1)+l[pos];
}

int q[40000010],h,t;
struct data
{
	int a[4];
	friend data operator * (data a,data b)
	{
		static long long C[4];
		static data c;
		memset(C,0,sizeof(C));
		for(int i=0;i<4;++i)
			for(int j=0;i+j<4;++j)
				C[i+j]+=1ll*a.a[i]*b.a[j];
		for(int i=0;i<4;++i)
			if(C[i]>999999999)
			{
				C[i+1]+=C[i]/1000000000;
				C[i]%=1000000000;
			}
		for(int i=0;i<4;++i)c.a[i]=C[i];
		return c;
	}
	friend data operator + (data a,data b)
	{
		static long long C[4];
		static data c;
		memset(C,0,sizeof(C));
		for(int i=0;i<4;++i)C[i]=a.a[i]+b.a[i];
		for(int i=0;i<4;++i)
			if(C[i]>1000000000)
			{
				C[i+1]+=C[i]/1000000000;
				C[i]%=1000000000;
			}
		for(int i=0;i<4;++i)c.a[i]=C[i];
		return c;
	}
}cur,ans;
void print(data x)
{
	static int st[100],tp;
	for(int i=0;i<=3;++i)
	{
		int w=x.a[i];
		for(int j=0;j<9;++j)st[++tp]=w%10,w/=10;
	}
	while(tp>1&&!st[tp])--tp;
	while(tp)putchar(st[tp]^48),--tp;
}
int main()
{
//	freopen("partition.in","r",stdin);
//	freopen("partition.out","w",stdout);
	n=read(),op=read();
	if(!op)
	{
		for(int i=1;i<=n;++i)sum[i]=read();
	}
	else 
	{
		x=read(),y=read(),z=read(),b[1]=read(),b[2]=read(),m=read();
		for(int i=1;i<=m;++i)p[i]=read(),l[i]=read(),r[i]=read();
		for(int i=1;i<=n;++i)sum[i]=rnd(i);
	}
	long long mx=0;
	for(int i=1;i<=n;++i)mx=max(mx,sum[i]),sum[i]+=sum[i-1];
	if(n<=50&&mx<=1000)
	{
		task1::solve();
		return 0;
	}
	h=0,t=0;
	for(int i=1;i<=n;++i)
	{
		while(h<t&&sum[q[h+1]]+sum[q[h+1]]-sum[f[q[h+1]]]<=sum[i])++h;
		f[i]=q[h];
		while(h<=t&&sum[q[t]]+sum[q[t]]-sum[f[q[t]]]>=sum[i]+sum[i]-sum[f[i]])--t;
		q[++t]=i;
	}
	int x=n;
	while(x)
	{
		cur.a[0]=(sum[x]-sum[f[x]])%1000000000;
		cur.a[1]=(sum[x]-sum[f[x]])/1000000000;
		cur.a[2]=cur.a[3]=0;
		ans=ans+cur*cur;
		x=f[x];
	}
	print(ans);
	return 0;
}
```


---

## 作者：frankchenfu (赞：16)

### 1. 题意简述

给定一个长度为 $n$ 的正整数序列 $\{a\}$ ，要求找出一种划分方式，使得当划分的断点在 $k_1,k_2,\ldots,k_p$ 时，满足以下条件：

$\bullet\ \displaystyle\sum_{i=1}^{k_1} a_i\le\displaystyle\sum_{i=k_1 + 1}^{k_2} a_i\le\ldots\le\displaystyle\sum_{i=k_p + 1}^{n} a_i $

$\bullet\ \left(\displaystyle\sum_{i=1}^{k_1} a_i \right)^2 +\left( \displaystyle\sum_{i=k_1 + 1}^{k_2} a_i\right )^2 + \cdots + \left(\displaystyle\sum_{i=k_p + 1}^{n} a_i\right)^2 $的值最小。

注意，这里的 $p$ 可以是任意值，即可以划分任意段数。特别地，所有的数可以全部划为一段。

### 2. 部分分算法

#### 2.1 $12\text{pts}$ 做法

**关键词：枚举，搜索**

注意到 $n\le 10$ ，这也就意味着我们可以枚举两个数之间是否分开，最后统计一次答案取最优解。

由于每两个数之间会有一个空格，有分开和不分开两种情况，因此可以在 $\mathcal{O}(n\cdot 2^{n-1})$ 的时间内得出答案。

#### 2.2 $24\text{pts}$ 做法

**关键词：搜索，剪枝，搜索序**

$n\le 50$，暴力无法通过。但是得到暴力算法之后，我们可以考虑优化搜索顺序和最优性剪枝。

显然地，根据 $(a+b)^2\le a^2+b^2$，我们可以知道划分的段数越多越好，但是单调递增的条件限制着我们。所以我们搜索的时候优先搜索划分多的方案，也就是能划尽量划；

另一方面，我们如果当前已经划的答案甚至大于最优解了，直接结束这部分“失败”的搜索。

综合以上优化，我们可以得到 $12\sim 24$ 分不等的部分分。

#### 2.3 $36\text{pts}$ 做法

**关键词：动态规划 $\cdot\ \alpha$**

面对 $n\le 400$ 的范围，搜索无法承受，我们考虑动态规划算法。

我们设计一个状态 $f(j,i)$ 表示当前划分到 $i$ 并且决定在这里截断，上一次断点取在了 $j$ 的地方，那么我们就可以直接算出区间 $[j,i]$ 的贡献了。接下来，我们再枚举一维 $k$ 表示 $j$ 之前从哪一个断点转移过来，显然有转移方程 $f(j,i)=\min\left\{f(k,j-1)+\left(\displaystyle\sum_{x=j}^{i}a_x\right)^2\right\}$

状态是 $\mathcal{O}(n^2)$ 的，转移是 $\mathcal{O}(n)$ 的，总复杂度 $\mathcal{O}(n^3)$。

#### 2.4 $64\text{pts}$ 做法

**关键词：动态规划 $\cdot\ \beta$**

在 $n\le 5000$ 的时候，上述动态规划难以进行直接的优化，我们需要发掘题目的性质。

重新考虑 $24\text{pts}$ 算法中关于搜索序优化的部分。

由于 $(a+b)^2=a^2+b^2+2ab>a^2+b^2$ ，我们得出的结论是段数要划分得越多越好；那么反过来，对于给定的一段 $i$，如果对于任意的位置 $j(1\le j<i)$ 之前的那一段总和值确定的，换句话说对于任意的 $j$都有 $\displaystyle\sum_{x=j}^{i}a_x$ 必须要大于的值只和 $j$ 有关并且是确定的，那么我们具体选择哪一个 $j$ 是不是也是确定的呢？

答案是肯定的。

假设我们发现了有 $j_1,j_2,\ldots(j_1<j_2<\ldots)$ 这些 $j$ 都是可以转移到 $i$ 的，也就是 $\displaystyle\sum_{x=j}^{i}a_x$ 都能保证使得到目前为止的序列是递增的，那么我们会选择哪一个呢？

显然选择最大的一个 $j$ 是最优的，这样分的段数会尽可能大。如果选择的不是最大的那个 $j$（记为 $j'$） ，那么肯定 $j'$ 前面能分的段数要大于 $j$ 前面的段数——可是我们可以和 $j'$ 的分法一模一样，然后把 $(j',j]$ 这个区间直接并进最后一段，这样总的段数至少不会变劣；由于 $(j',j]$ 内可能可以再分，因此可能更优。

这样，我们就证明了转移策略：**每次必然是转移到能转移到的最靠后的点**。

既然转移是唯一的，那么我们自然可以记下分到 $i$ 的时候，以 $i$ 结尾的这一段总和是多少——这个是唯一确定的，记为 $g(i)$；继承 $f(i)$ 的定义，同时省略 $j$ 这一维，表示的就是到 $i$ 为止的最优解，则

$$f(i)=f(\text{argmax}(j))+\sum_{x=j}^i a_x$$

其中 $\text{argmax}(j)$ 表示的是 $j$ 能取的最大值。

这样一来，时间复杂度降到了 $\mathcal{O(n^2)}$，可以通过 $n\le 5000$ 的数据。

### 3. 标解算法

#### 3.1 算法

从 $64\text{pts}$ 的做法开始考虑。我们每次都需要向前枚举，找到第一个能够转移的 $j$ ，这个看起来很可优化的样子。

如果有两个位置 $a,b$ ，满足$a>b$ 且 $f(a)\le f(b)$，这说明 $a$ 离得更近，并且连起来的代价还更小，那么我们肯定就不会选 $b$ 了；这个结论甚至与 $i$ 无关，也就是一旦出现了一个这样的 $a$ ，那么这个 $b$ 它就被永远地抛弃了。

这样，我们最后会留下来一串的数，它们一定是满足若 $a>b$ 则 $f(a)>f(b)$ ，换言之它们是单调的。

于是我们用一个单调队列维护所有可能的转移点。

然后每次 $i$ 向右移的时候需要判断队首是不是已经没有第二个优了，如果是，弹出队首。反复执行以上操作。

此时我们的 $f(i)$ 就是用队首来更新的。然后尝试加入 $i$ 这个决策点。

接下来我们看看原来的队尾是不是还不如 $i$ 这个点优，如果是，弹出队尾。最后加入 $i$。

这样，因为单调队列每个数至多进队一次，出队一次，复杂度是 $\mathcal{O}(n)$ 的，可以直接拿到 $88\text{pts}$。

#### 3.2 优化

可是想要拿到 $100\text{pts}$ 可不是一件容易的事情。

##### 3.2.1 输入

根据题目的要求，我们需要用一些奇怪的方法输入，这些按照题目的意思走即可——**但是**，如果直接开了`long long`以达到算出 $b_i$ 然后再取模得出 $a_i$ ，这可能导致超时——**`long long`的乘法与取模运算非常慢！**

但是我们可以使用 `unsigned int` 来存储这些数字。众所周知，`unsigned int` 在溢出的时候回舍弃高位而保留低位，而题目给出的模数是 $2^{30}$——恰好就是二进制位下的后 $30$ 位。于是我们大胆地让它自然溢出，然后取后 $30$ 位。效率显著提高。

**Tips: 推荐使用`fread`快读。**

##### 3.2.2 状态存储

题目给出的数据范围非常大，最多情况下可能是 $(4\times 10^{7}\times 10^{9})^2=1.6\times 10^{33}$，此时 $64$ 位整数无法存下，需要使用高精度（$4$位`int`）。

但是这样一来，我们相当于空间上直接乘上了 $4$ 的常数，加之 $n=4\times 10^7$ ，即使是 $1\text{G}$ 的内存也是不够用的，因此我们的 $f$ 数组需要作出改变：每次存它是从哪里转移过来的。显然转移点固定，这样就可以使用一个 `int` 存下所有的转移了。

可是这样最后的答案怎么计算？最后从 $n$ 倒推回去即可！反正前缀和是 `long long`范围的，最后只要开一个高精度数即可。空间省下来了！~~`fread`快读的空间开得下了！~~

##### 3.2.3 高精度计算

你别以为省下空间就好了！高精度可慢了！

想一想常数那么大的乘法运算，动不动模一模除一除，两下子就`Time Limit Exceeded`了。

那么就把模运算和除法运算去掉吧！

首先，先把高精度数用 $2^{32}$ 进制存储，然后模运算就是 `a&0x7fffffff` 或是强制转换 `unsigned int`，除法运算就是 `a>>32`。

然后正常地算高精度，由于是位运算，快得起飞。

然后最后还原一次答案，还原成 $10$ 进制即可。

-----

这样一来，我们就解决了这道题的绝大多数问题，剩下的常数问题就各显神通了。

以下代码可以在洛谷的评测机上跑进1.2s

```cpp
#include <cstdio>
#include <cstring>
#include <ctime>
const int MAXN=40000010;
const unsigned PMOD=(1<<30)-1;
const unsigned MOD=1e9;

long long _sum[MAXN],*sum=_sum+5,g[MAXN];
int q[MAXN],f[MAXN];
int p[100010],l[100010],r[100010];

char _B[1<<21],*_S=_B,*_T=_B;
#define getchar() (_S==_T&&(_T=(_S=_B)+fread(_B,1,1<<21,stdin),_S==_T)?EOF:*_S++)
inline int read(){
	register int res=0;
	register char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<3)+(res<<1)+(ch&15);
		ch=getchar();
	}
	return res;
}

int main(){
	int n=read(),type=read();
	if(type==0){
		for(int i=1;i<=n;i++){
			int x=read();
			sum[i]=sum[i-1]+x;
		}
	}
	else{
		register unsigned x,y,z,m;
		register unsigned s1,s2,s3,pos=1;
		x=read();y=read();z=read();s1=read();s2=read();m=read();
		for(register int i=1;i<=m;i++){
			register unsigned p=read(),l=read(),r=read(),len=r-l+1;
			for(;pos<=p;pos++){
				if(pos==1)
					s3=s1;
				else if(pos==2)
					s3=s2;
				else{
					s3=(x*s2+y*s1+z)&PMOD;
					s1=s2;s2=s3;
				}
				sum[pos]=sum[pos-1]+s3%len+l;
			}
		}
	}
	register int *hd=q+1,*tl=q+1;
	for(register int i=1;i<=n;i++){
		while(hd<tl&&sum[*hd]+g[*hd]<=sum[i])
			hd++;
		g[i]=sum[i]-sum[*(hd-1)];
//		f[i]=f[q[hd-1]]+g[i]*g[i];
		f[i]=*(hd-1);
		while(hd<tl&&sum[*(tl-1)]+g[*(tl-1)]>=sum[i]+g[i])
			tl--;
		*tl++=i;
	}
	register unsigned pos=n;
	register unsigned long long ans[3]={0,0,0};
	while(pos){
		register unsigned long long tmp1=g[pos]&PMOD,tmp2=g[pos]>>30;
		ans[2]+=tmp2*tmp2;
		ans[1]+=tmp1*tmp2<<1;
		ans[0]+=tmp1*tmp1;
		ans[1]+=ans[0]>>30;ans[0]&=PMOD;
		ans[2]+=ans[1]>>30;ans[1]&=PMOD;
		pos=f[pos];
	}
	register unsigned long long tmp[4]={ans[2],0,0,0};
	for(int i=1;~i;i--){
		for(int j=0;j<=3;j++)
			tmp[j]<<=30;
		tmp[0]+=ans[i];
		for(int j=0;j<=2;j++){
			tmp[j+1]+=tmp[j]/1000000000;
			tmp[j]%=1000000000;
		}
	}
	if(tmp[3])
		printf("%llu%09llu%09llu%09llu\n",tmp[3],tmp[2],tmp[1],tmp[0]);
	else if(tmp[2])
		printf("%llu%09llu%09llu\n",tmp[2],tmp[1],tmp[0]);
	else if(tmp[1])
		printf("%llu%09llu\n",tmp[1],tmp[0]);
	else
		printf("%llu\n",tmp[0]);
	return 0;
}
```

---

## 作者：Mirasycle (赞：4)

先考虑暴力，设 $dp(i,j)$ 表示最后一段分割在区间 $[i,j)$ 上，那么最暴力的就是 $O(n^3)$ 枚举，我们发现 $dp(j,k) \to dp(i,j)$ 对于每一个 $j$ 可选的 $k$ 集应该是不断增大的，于是我们可以对于每一个 $j$ 单调队列，复杂度 $O(n^2)$。

其实我们可以配合贪心通过一些数学性质来解决这个问题或者打表，就像方差那题一样。对于这题显然越大的数，平方越大，也就是 $(a+b)^2 \ge a^2+b^2$，于是我们需要保证最后一段划分尽可能小，也就是这么多段尽可能接近或者说划分更多段。

于是我们设出 $f_i$ 表示前 $i$ 个数的答案，$g_i$ 表示最后一段划分的和。这样只需要每次找到最大的 $j$ 满足 $sum_{j+1,i} \ge g_j $ 进行转移即可。即 $pre_i \ge g_j+pre_j$，相同变量在一侧，单调队列即可。注意 $g_i$ 不一定大于 $g_{i-1}$，只是要求大于前一段并不是大于上一个位置。

时间复杂度 $O(n)$。


```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=4e7+10;
const int maxm=1e5+10;
const int mod=(1<<30);
long long pre[maxn],g[maxn]; int top=0;
int q[maxn],p[maxm],l[maxm],r[maxm],b[maxn],a[60];
inline long long calc(int x){ return 2*pre[x]-pre[g[x]]; }
inline long long val(int x){ return pre[x]-pre[g[x]]; }
void print(__int128 ans){
	while(ans){
		a[++top]=ans%10;
		ans/=10;
	}
	while(top) cout<<a[top--];
}
int main(){
	int n,type; cin>>n>>type;
	if(!type){
		pre[0]=0;
		for(int i=1;i<=n;i++){
			int x; cin>>x;
			pre[i]=pre[i-1]+x;
		}
	}else{
		int x,y,z,m;
		cin>>x>>y>>z>>b[1]>>b[2]>>m;
		for(int i=1;i<=m;i++) cin>>p[i]>>l[i]>>r[i];
		for(int i=3;i<=n;i++) b[i]=(1ll*b[i-1]*x+1ll*b[i-2]*y+z)%mod;
		for(int i=1;i<=m;i++)
			for(int j=p[i-1]+1;j<=p[i];j++){
				x=b[j]%(r[i]-l[i]+1)+l[i];
				pre[j]=pre[j-1]+x;
			}
	}
	q[0]=0; int l=1,r=1; q[1]=0;
	for(int i=1;i<=n;i++){
		while(pre[i]>=calc(q[l+1])&&l<r) l++;
		g[i]=q[l];
		while(calc(i)<=calc(q[r])&&l<=r) r--;
		q[++r]=i;
	}
	int P=n; __int128 ans=0,mul=1;
	while(P){
		mul=val(P); mul=mul*mul;
		ans=ans+mul; 
		P=g[P];
	}
	print(ans);
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：3)

# 思路分析

首先，我们有一个结论：划分的段数越多越好。

如何证明呢？可以感性理解：若将 $a_{1\sim i}$ 分成 $k$ 段，则所有的方案中，最后一段小一点的会更优。而分的段数越多，最后一段就可以越小，所以我们会让分的段数尽可能的多。

如何求最小段数呢？一个直观的 dp 思路是，设 $f_{i,j}$ 将 $1\sim i$ 划分，最后一段右端点为 $i$，倒数一段右端点为 $j$，直接转移即可，时间复杂度 $O(n^3)$，可以拿到 $36$ 的分数。

状态难以简化，不妨从贪心角度考虑，我们从前往后取。如果当前段的和大于我们上一个划分的段，则令答案加一，开始划分新的一段，反之则将一个新的元素放入当前段。这个贪心实际上是错的，可以 Hack 掉。

例如给定的数列是 $\{5,5,1,2,8,9\}$，我们的贪心策略划分的结果是 $\{5\},\{5\},\{1,2,8\}$，但实际上的最优策略是 $\{5\},\{5,1,2\},\{8\},\{9\}$，我们思考贪心算法错误的原因。

倘若要将 $\{5,5,1,2,8\}$ 这部分划分成三段，则上面的两种算法分别将第三段划为了 $\{1,2,8\}$ 和 $\{8\}$，这两种方法都是合法的，但是第二种划分这一段的和更小，所以对于后面的转移更优。所以，我们划分时，不仅要让段数多的情况下合法，还要让最后一段的和尽可能小。

我们依据这个贪心思路重新设计 dp。设 $f_i$ 表示将 $1\sim i$ 合法划分的最大段数，$g_i$ 表示将 $1\sim i$ 划分成 $f_i$ 的基础上，最小化最后一段的总和，同时记录序列 $a$ 的前缀和 $s$，则可以得到 $f$ 的转移式为 $f_i=\max\{f_j+1\}$ 满足 $j\in [0,i-1],g_j\le s_i-s_j$。每求出 $f_i$ 后，我们都求出 $g_i$，$g_i$ 就是所有满足所有满足 $f_i=f_j+1$ 中 $s_i-s_j$ 的最小值。暴力跑是 $O(n^2)$，可以得到 $64$ 的分数。

如何优化转移的过程呢？容易发现一个特点，$s_i$ 都是单调不降的。因为无论如何只需要将 $a_i$ 加入最后一段，$f_i$ 就可以继承 $f_{i-1}$ 的值，而 $a_i>0$，所以 $s$ 也具有单调性。因为我们要找到最大的 $s_i-s_j$，所以我们只需要找到最后一个 $j$ 满足 $s_i-s_j\ge g_j$ 即可最大化 $f_i$ 的同时，最小化 $g_i$。

而对于 $s_i-s_j\ge g_j$ 移项可得 $s_i\ge s_j+g_j$。对于 $k>j$，若有 $s_k+g_k\le s_j+g_j$，则 $k$ 一定比 $j$ 优，则维护一个 $s_i+g_i$ 单调的栈，每次计算 $f_i$ 时则找到最后一个 $j$，容易发现这个最优决策 $j$ 实际上也是单调的，所以可以换成单调队列。

最后统计方案时，只需记录每个点的最优决策 $p_i$，然后回溯计算即可，时间复杂度 $O(n)$。

下面给出几点卡常建议：

1. 用 $s_i-s_{p_i}$ 代替 $g_i$。

2. 我们对于 $n\le 4\times 10^7$，实际上不需要开 $a,b,s$ 三个数组，直接用同一个数组生成 $a,b$，计算前缀和 $s$。

# Code


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef __int128 i128;
typedef long long ll;
const int N=4e7+5;
const int M=1e5+10;
const ll mod=(1<<30);
int f[N],p[N],q[N];
ll s[N];
int n,type,m;
i128 ans=0;
inline ll g(int x){
	return s[x]-s[p[x]];
}
void init(){
	scanf("%d %d",&n,&type);
	if(type==0){
		for(int i=1;i<=n;i++)scanf("%lld",s+i);
	}else{
		long long x,y,z,pp,l,r,lstp=0;
		scanf("%lld %lld %lld %lld %lld %d",&x,&y,&z,s+1,s+2,&m);
		for(int i=3;i<=n;i++)s[i]=(x*s[i-1]+y*s[i-2]+z)%mod;
		for(int i=1;i<=m;i++){
			scanf("%lld %lld %lld",&pp,&l,&r);
			for(int j=lstp+1;j<=pp;j++)s[j]=(s[j]%(r-l+1))+l;
			lstp=pp;
		}
	} 
	for(int i=1;i<=n;i++)s[i]+=s[i-1];
	return;
}
void write(i128 x){
	if(x>9)write(x/10);
	putchar(x%10+'0');
};
int main(){
	init();
	int l=1,r=1;q[1]=0;
	for(int i=1;i<=n;i++){
		while(l<r&&s[i]>=g(q[l+1])+s[q[l+1]])l++;
		p[i]=q[l],f[i]=f[p[i]]+1;
		while(l<=r&&g(q[r])+s[q[r]]>=g(i)+s[i])r--;
		q[++r]=i; 
	}
	for(;n;n=p[n])ans+=(i128)(s[n]-s[p[n]])*(s[n]-s[p[n]]);
	write(ans);
	return 0;
}
```

如有错误，请指出。

---

## 作者：EndSaH (赞：3)

# Solution

首先有一个暴力 DP： 设 $f(i, j)$ 表示已经划分了前 $i$ 个数的段，最后一段以 $j$ 开头的最小总运行时间。设 $S(j, i) = \sum \limits _{k = j} ^i a _k$，有转移：

$$
f(i, j) = \min _{0 < k < j, S(j, i) \ge S(k, j - 1)} \{f(j - 1, k)\} + S(j, i) ^2
$$

直接按方程转移是 $O(n ^3)$ 的。注意到若将 $j$ 从 $i$ 到 $1$ 逆顺序转移，能够贡献的那些 $k$ 不断变多。于是设置一个指针 $p$，初值为 $i$，每次 $j \gets j - 1$ 时调整 $p$ 的位置不断向左走，即可做到均摊下 $O(1)$ 转移，复杂度 $O(n ^2)$。

状态数很明显的需要优化，打表可以发现：能够转移到其他状态的 $f(i, j)$ 必定满足 $f(i, j)$ 是最后一个合法的状态，即 $f(i, j + x)$ 均是不合法状态。换句话说，只要让以 $i$ 结尾的最后一段划出来的总和尽可能小，就可以构造出一种最优方案。

[myy 的证明](http://matthew99.blog.uoj.ac/blog/5299)

于是重设状态：设 $g _i$ 表示最大的满足以 $g _i$ 作为最后一段的开头能够合法的位置。有转移：

$$
g _i = \max _{0 < j < i, S(j + 1, i) \ge S(g _j, j)} \{j\} + 1
$$

设 $P _i = \sum \limits _{j = 1} ^i a _i$，将 $S(j + 1, i) \ge S(g _j, j)$ 变形为 $P _i \ge 2P _j - P _{g _j}$。再设 $T _i = 2P _i - P _{g _i}$。

用数据结构维护 $T$ 固然可行，但复杂度仍不够优秀。注意到其单调性：由于是取 $\max$ 并且是从前往后转移的，那么对于当前状态 $i$ 而言，前面的 $j$ 若有 $T _j \ge T _i$ 则 $j$ 一定不会比 $i$ 更优。

这是个典型的单调队列优化转移的情况。队尾出队按 $T$ 比较即可，当队头的后一个元素 $u$ 满足 $T _u < P _i$ 时可知队头已经不会再产生贡献，将队头出队。

注意一开始要放入 0，并设 $g _0 = 1$ 以减少边界情况的处理。

这样可以顺利获得 88pts。再考虑高精度的问题。

可以考虑将答案表示为 $a \times 10 ^{18} + b$ 的形式并进行运算。加法直接将 $a, b$ 分别相加（注意 $b > 10 ^{18}$ 时得进位）。乘法则是一个 `long long` 范围内数 $x$ 的平方，将 $x$ 表示为 $a \times 10 ^9 + b$ 的形式则有（将 $10 ^9$ 省略为 $B$）：

$$
\begin{aligned}
& x ^2 \\\\
=& (aB + b) ^2 \\\\
=& a ^2 B ^2 + 2abB + b ^2 \\\\
=& a ^2 B ^2 + 2(a'B + b')B + b ^2 \\\\
=& (a ^2 + 2a') B ^2 + (2b'B + b ^2) \\\\
=& (a ^2 + 2a') 10 ^{18} + (2b'B + b ^2)
\end{aligned}
$$

其中 $ab = a' \times 10 ^9 + b'$。这样即可避免高精度问题。

同样的，$2b'B + b ^2$ 处注意进位。另外由于可以直接求出分段情况（也就是 $g _i$），不需要存答案数组，也避免了炸空间的问题。

# Code

（当然不是考场代码...

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

#define squ(x) (LL(x) * (x))

using namespace std;

typedef long long LL;
typedef unsigned int uint;

const int maxN = 4e7 + 5;
const LL INF = 0x3F3F3F3F3F3F3F3F;
const int BASE = 1e9;
const LL __base = 1e18;

int n, type, head, tail;
int g[maxN], q[maxN];
LL sum[maxN];

template<typename _Tp>
inline bool Chkmin(_Tp& x, const _Tp& y)
{ return x > y ? x = y, true : false; }

inline LL Res(int i)
{ return sum[i] * 2 - sum[g[i] - 1]; }

struct Num
{
    LL a, b;

    Num() { }

    Num(LL num) : a(0), b(num) { }

    Num& operator+=(const Num& x)
    {
        a += x.a, b += x.b;
        if (b >= __base)
            ++a, b -= __base;
        return *this;
    }
} ans;

Num Squ(LL num)
{
    Num res;
    int a = num / BASE, b = num - (LL)a * BASE;
    int _a = (LL)a * b / BASE, _b = (LL)a * b - (LL)_a * BASE;
    res.a = (LL)a * a + 2 * _a;
    res.b = (LL)b * b + 2ll * _b * BASE;
    res.a += res.b / __base, res.b %= __base;
    return res;
}

uint b[maxN];

void Input()
{
    int x, y, z, m, last = 0;
    cin >> x >> y >> z >> b[1] >> b[2] >> m;
    for (int i = 3; i <= n; ++i)
        b[i] = x * b[i - 1] + y * b[i - 2] + z;
    for (int i = 1; i <= m; ++i)
    {
        int l, r, p;
        cin >> p >> l >> r;
        for (int j = last + 1; j <= p; ++j)
            sum[j] = sum[j - 1] + (b[j] & ((1 << 30) - 1)) % (r - l + 1) + l;
        last = p;
    }
}

int main()
{
    freopen("partition.in", "r", stdin);
    freopen("partition.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin >> n >> type;
    if (type == 1)
        Input();
    else
        for (int i = 1; i <= n; ++i)
            cin >> sum[i], sum[i] += sum[i - 1];
    g[0] = 1;
    head = tail = 1;
    for (int i = 1; i <= n; ++i)
    {
        while (head < tail and Res(q[head + 1]) <= sum[i])
            ++head;
        g[i] = q[head] + 1;
        while (tail > head and Res(i) <= Res(q[tail]))
            --tail;
        q[++tail] = i;
    }
    for (int i = n; i; i = g[i] - 1)
        ans += Squ(sum[i] - sum[g[i] - 1]);
    if (ans.a)
        printf("%lld%18lld\n", ans.a, ans.b);
    else
        printf("%lld\n", ans.b);
    return 0;
}
```

---

## 作者：wallace_QwQ (赞：1)

因为 $(a+b)^2 \ge a^2 + b^2$，所以要尽可能多分段。

令 $sum_{i,j}$ 表示 $[i,j]$ 的区间和，$pre_{i}$ 表示 $i$ 的前缀和。

若 $sum_{a,b}+sum_{c,d} \le sum_{e,f}$，则 $(sum_{a,b}+sum_{c,d})^2+{sum_{e,f}}^2 \le {sum_{a,b}}^2+(sum_{c,d}sum_{e,f})^2$，那么说明一个区间与前面合并一定优于与后面合并。

所以最后一段要尽可能的小。

设 $f_i$ 表示前 $i$ 个数的答案，$g_i$ 表示前 $i$ 个数最优情况下划分的最后一段的左端点。

那么对于 $i$，我们需要找到最大的 $j$，使得 $sum_{j+1,i}\ge sum_{g_j,j}$。

两边同时加 $pre_{j}$，得到 $pre_{i}\ge 2\times pre_{j}-pre_{{g_j}-1}$。

由于 $pre_i$ 单调不减，所以显然可以单调队列优化。

对于任意的 $x\le y$，若 $2\times pre_{x}-pre_{{g_x}-1}\ge 2\times pre_{y}-pre_{{g_y}-1}$，那么无论在什么情况下 $x$ 都不会被选择，直接踢出单调队列。

所以单调队列里的元素一定是根据 $2\times pre_{i}-pre_{{g_i}-1}$ 单增的。

每个元素最多分别进出单调队列一次，时间复杂度 $O(n)$。
```cpp
int n; bool ty;
ULL pre[N];
__int128 ans;
int b[N],p[M],l[M],r[M];
int q[N],g[N];
LL calc(int p){return 2*pre[p]-pre[g[p]-1];}
void solve(){
	cin>>n>>ty;
	if(!ty){
		ULL a;
		for1(i,1,n) {rin(a); pre[i]=pre[i-1]+a;}
	}else{
		int x,y,z,m;
		cin>>x>>y>>z>>b[1]>>b[2]>>m;
		for1(i,1,m) cin>>p[i]>>l[i]>>r[i];
		for1(i,3,n) b[i]=(1ll*b[i-1]*x+1ll*b[i-2]*y+z)%mod;
		for1(i,1,m)
			for1(j,p[i-1]+1,p[i])
				pre[j]=pre[j-1]+b[j]%(r[i]-l[i]+1)+l[i];
	}
	int h=1,t=1;
	for1(i,1,n){
		while(pre[i]>=calc(q[h+1])&&h<t) h++;
		g[i]=q[h]+1;
		while(calc(i)<=calc(q[t])&&h<=t) t--;
		q[++t]=i;
	}
	int pos=n;
	while(pos){
		__int128 qwq=pre[pos]-pre[g[pos]-1];
		ans+=qwq*qwq;
		pos=g[pos]-1;
	}
	rout(ans);
	return ;
}
```

---

## 作者：__Deng_Rui_Song__ (赞：1)

# preface
毒瘤题，输入卡常都毒瘤
# problem
[传送门](/problem/P5665)
# solution
## 12pts
很简单，对于每个空位，枚举它是否划分，最后验证是否满足条件，用 dfs 实现即可。

时间复杂度 $\mathcal{O}(n!\cdot n)$。
## 24pts
此时 $n\le50$，暴力过不了，需要优化。

根据**完全平方公式**，可得 $(a+b)^2>a^2+b^2(a,b>0)$，所以划分的段数越多越好，所以 dfs 时优先搜索段数多的即可。
## 36pts
此时 $n\le400$，dfs 直接寄掉，考虑 dp。

我们设 $dp_{i,j}$ 表示划分到 $j$ 且最后一段为 $[i,j]$ 的答案，所以我们枚举**倒数第二段的左端点** $k$，则转移公式为：
$$dp_{i,j}=\min\{dp_{k,j-1}+(\sum_{x=j}^ia_x)^2\}$$

其中 $\sum_{x=j}^ia_x$ 用前缀和优化，时间复杂度 $\mathcal{O}(n^3)$。
## 64pts
此时 $n\le5000$，考虑优化。

回顾 24pts 的部分，段的数量越多越好，所以转移的 $k$ 也尽量靠后，那么我们**重新设** $dp_i$ 表示划分到 $i$ 的答案，枚举**最后一段的左端点** $j$，刚才说了，转移越靠后越好，所以我们设 $lst_i$ 为划分到 $i$ 的最优方案的**最后一段的总和**。

怎么转移呢？**从大到小**枚举 $j$，若当前的 $j$ 满足 $\sum_{k=j+1}^ia_k\ge lst_j$，那么不用想，直接 $dp_i=dp_j+(\sum_{k=j+1}^ia_k)^2$，同时 $lst_i=(\sum_{k=j+1}^ia_k)^2$。

时间复杂度 $\mathcal{O}(n^2)$。

~~插个题外话，我们教练赛时打 64pts 结果全机房都拿到了 64pts 就他一个人挂了 20pts（逃~~
## 88pts
此时 $n\le5\times10^5$，接着优化。

从 64pts 部分，我们得到了满足

$$\sum_{k=j+1}^ia_k\ge lst_j$$

时，才可以转移，现在主要是怎么 $\mathcal{O}(1)$ 求出这个 $j$，我们把上面的式子拆分一下：

$$pre_i-pre_j\ge lst_j$$

注：这里 pre 指前缀和数组。

$$pre_i\ge lst_j+pre_j$$

发现了吗？$pre_i$ 和 $lst_j+pre_j$ 都是单调递增的，所以考虑单调队列，还是那句话，段越多越好，队列里的下标也是单调递增的，所以每次转移时从队头开始找到最后满足上述条件的 $j$，其它的直接踢，转移完后从队尾开始，如果队尾的 $lst_{back}+pre_{back}\ge lst_i+pre_i$，那么 $back$ 就不需要了，直接踢，直到不能踢为止，把 $i$ 放入队列。

单调队列可以用双端队列或者优先队列，由于每个状态只会进去一次出去一次，所以双端队列时间复杂度为 $\mathcal{O}(n)$，优先队列时间复杂度为 $\mathcal{O}(n\log n)$

## 100pts
此时 $n\le4\times10^7$，只能用双端队列实现，然后写一下~~毒瘤~~输入，卡一下常，最后 dp 改成 int128 即可。

### 关于卡常
- $lst$ 数组直接不要，~~pair 是个好东西~~。
- 快读快写加上。
- mod 慢死了，建议用减号。
- 边输入边算前缀和。
### 关于输入
~~服了，毒瘤输入调死我了~~

你就按题目做就行，建议用三个变量维护 $b$ 数组，就这么简（kun）单（nan）。
# code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1 << 30;
int n,type,pre[40000005];
signed b[40000005];
__int128 dp[40000005];
deque<pair<int,int> > dq;
int read(){
	int val = 0;
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)){
		val = val * 10 + c - '0';
		c = getchar();
	}
	return val;
}
void write(__int128 x) {
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
signed main(){
	n = read();
	type = read();
	if (type == 1){
		int x = read(),y = read(),z = read(),p1 = read(),p2 = read(),m = read(),p3,cur = 1;
		for(int i = 1; i <= m; i++){
			int p = read(),l = read(),r = read();
			while (cur <= p){
				if (cur == 1) p3 = p1;
				else if (cur == 2) p3 = p2;
				else{
					p3 = ((x * p2 % mod + y * p1 % mod) % mod + z) % mod;
					p1 = p2;
                    p2 = p3;
				}
				pre[cur] = pre[cur - 1] + p3 % (r - l + 1) + l;
                cur++;
			}
		}
	}// 毒瘤输入要仔细看
	else for (int i = 1,x; i <= n; pre[i] = pre[i - 1] + x,i++) x = read();
    dq.push_back({0,0});// 注意！一开始一定要先放一个 0
	for (int i = 1; i <= n; i++){
		int x,y;
		while (!dq.empty() && pre[i] >= dq.front().second){
			x = dq.front().first;
			y = dq.front().second;
			dq.pop_front();
		}// 找到 j
        __int128 num = pre[i] - pre[x];// 注意和的平方会炸 long long，我在这里卡了半天
		dp[i] = dp[x] + num * num;
		while (!dq.empty() && dq.back().second >= pre[i] + pre[i] - pre[x]) dq.pop_back();
		dq.push_back({i,pre[i] + pre[i] - pre[x]});// 入队
	}
	write(dp[n]);
	return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P5665)

---

# 思路：

首先求出 $a$ 的前缀和数组 $s$。

考虑动态规划，令 $dp_{i,j}$ 表示以 $i$ 结尾，末尾有 $j$ 个为一组的最小答案，则状态转移方程为：$dp_{i,j} = \min [s_{i-j}-s_{i-j-k} \le s_i - s_{i-j}] dp_{i-j,k} + (s_i - s_{i-j})^2$。

朴素直接转移是 $O(N^3)$ 的，可以得到 $36pts$ 的好成绩。

考虑优化，对于求出最小的一个 $k$，使得 $s_{i-j}-s_{i-j-k} > s_i - s_{i-j}$，那么状态转移方程为：$dp_{i,j} = (s_i - s_{i-j})^2 + \min\limits_{l=1}^k dp_{i-j,l}$。

后面的一串可以提前前缀预处理好，现在的复杂度在求 $k$ 上，注意到 $s_{i,j} - s_{i-j-k}$ 是单调的，那么直接二分即可。

时间复杂度优化至 $O(N^2 \log N)$。

之后我们可以发现，若 $j$ 的单增的，则 $i-j-k+1$ 是单降的，那么我们直接对 $k$ 进行走指针即可，时间复杂度优化至 $O(N^2)$，可以拿到 $64pts$ 的好成绩。

因为我们这种 ```dp``` 的状态数都已经达到了 $N^2$，于是考虑找一些性质。

容易打表发现在合法情况下，满足 $dp_{i,j} \le dp_{i,j+1}$。

那么我们可以找到每个位置 $i$，记录一下 $f_i$ 表示 $\min dp_{i,j}$，且最后一段为 $[g_i,i]$，则状态转移方程为：$f_i = \min\limits_{j=0}^{i-1} [s_j-s_{g_j-1} \le s_i - s_j] f_j + (s_i - s_j)^2$。

此时我们就将状态时降至 $O(N)$ 级别，现在考虑来优化状态转移方程。

容易发现，当 $j$ 最大时，这个式子的值最小，所以我们需要求出一个最大的 $j$ 满足 $s_j-s_{g_j-1} \le s_i - s_j$，即：$2s_j - s_{g_j-1} \le s_i$。

注意到 $s_i$ 单增，我们可以维护一个 $2s_j - s_{g_j-1}$ 单增的单调队列，然后找到这个队列最后一个满足条件的 $j$，那么 $j$ 以前的数对答案无法造成贡献，将其弹出。

这样每个数至多被弹出一次，时间复杂度为 $O(N)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=4e7+10;
const int INF=0x3f3f3f3f3f3f3f3f3f3f3f3f;
const int mod=1ll<<30;
typedef __int128 __;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(__ x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
bool bg,op,ed;
__ t,ans;
int n,head=1,tail,s[N],g[N],Q[N];
int get(int l,int r){
	if(l>r){
	  	return 0;
	}
	if(l<1){
	  	return s[r];
	}
	return s[r]-s[l-1];
}
int date(int x){
	return 2ll*s[x]-s[g[x]-1];
}
signed main(){
	n=read();
	op=read();
	if(op==1){
		int x,y,z,m,p,l,r,pre=0;
		x=read();
		y=read();
		z=read();
		s[1]=read();
		s[2]=read();
		m=read();
		for(int i=3;i<=n;i++){
			s[i]=(x*s[i-1]+y*s[i-2]+z)%mod;
		}
		for(int i=1;i<=m;i++){
			p=read();
			l=read();
			r=read();
			for(int j=pre+1;j<=p;j++){
			  	s[j]=(s[j]%(r-l+1))+l;
			}
			pre=p;
		}
	}else{
		for(int i=1;i<=n;i++){
		  	s[i]=read();
		}
	}
	for(int i=1;i<=n;i++){
	  	s[i]+=s[i-1];
	}
	g[0]=Q[++tail]=0;
	g[1]=Q[++tail]=1;
	for(int i=2;i<=n;i++){
		while(date(Q[head+1])<=s[i]&&head+1<=tail){
		  	head++;
		}
		g[i]=Q[head]+1;
		t=get(g[i],i);
		while(date(i)<=date(Q[tail])&&tail>=head){
		  	tail--;
		}
		Q[++tail]=i;
	}
	for(int i=n;i>=1;i=g[i]-1){
	  	ans+=(__)(s[i]-s[g[i]-1])*(s[i]-s[g[i]-1]);
	}
	write(ans);
	cerr<<endl<<abs(&bg-&ed)/1048576<<"MB";
	return 0;
}
```
完结撒花~

---

## 作者：P2441M (赞：1)

## 一些闲话
毒瘤题！！！时空都卡。~~难以想象 2019 年的考生作何感想。~~

## 简述题意
给定长度为 $n$ 的序列 $a$。你需要找到一些分界点 $1 \leq k_1 \lt k_2 \lt \cdots \lt k_p \lt n$，使得

$$ \sum_{i=1}^{k_1} a_i \leq \sum_{i=k_1+1}^{k_2} a_i \leq \cdots \leq \sum_{i=k_p+1}^{n} a_i $$

在此基础上，最小化

$$ \left(\sum_{i=1}^{k_1} a_i\right)^2 + \left(\sum_{i=k_1+1}^{k_2} a_i\right)^2 + \cdots + \left(\sum_{i=k_p+1}^{n} a_i\right)^2 $$

对于所有数据，$2\leq n\leq 4\times 10^7$，$1\leq a_i\leq 10^9$。

## 题解
### 算法 1
暴力 DP。令 $f_{i,j}$ 表示考虑 $a[1,i]$，且最后一段为 $a[j+1,i]$ 的最小价值。转移时直接枚举倒数第二段的划分点并保证合法即可。时间复杂度 $O(n^3)$。

### 算法 2
考虑**贪心**。

我们有一个性质：在最优划分方案中，最后一段的元素和必然是所有合法划分方案中**最小**的。由各段元素和具有单调性，证明显然。

于是可以优化算法 1。这时候我们改变状态，令 $f_i$ 表示考虑 $a[1,i]$，且最后一段为 $[f_i+1,i]$。再设 $g_i=s_i-s_{f_i}$，即最优划分方案中最后一段的元素和。考察一个位置 $j$ 能够作为决策点的条件：
$$g_j\leq s_i-s_j$$
所以我们在转移时，暴力枚举决策点，找到满足上述条件且最靠右的 $j$。时间复杂度 $O(n^2)$。

### 正解
显然
$$g_j\leq s_i-s_j\Leftrightarrow g_j+s_j\leq s_i$$

所以对每个位置维护这个 $val_j=g_j+s_j$，随便套个数据结构就能做到 $O(n\log n)$，但依然会被卡掉。所以我们需要（均摊）$O(1)$ 的转移。

考虑**单调队列优化**。对于两个**合法**决策点 $i,j$，我们只需要保留较大的那一个，所以我们维护一个下标和对应的 $val$ 均**单调递增**的单调队列。每次循环一个 $i$，若 $val_{q_{head+1}}\leq s_i$，就不断弹出队头。决策点就是最终**合法**的队头或 $0$。加入一个新的决策时，平凡地维护单调性即可。时间复杂度 $O(n)$。

当然，这题十分***毒瘤***，空间和时间都卡得很死，需要拼命优化。空间优化上，不要开高精数组，一个多余的 $O(n)$ 数组都不要开。时间优化上，快读肯定要上的，高精压位压到 $8$ 位应该够用了。

## 代码
```cpp
#include <iostream>
#include <iomanip>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define add_mod(x, v) (x) = ((ll)(x) + (v)) % MOD
#define mul_mod(x, v) (x) = (1ll * (x) * (v)) % MOD
#define sub_mod(x, v) (x) = (((ll)(x) - (v)) % MOD + MOD) % MOD
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int MAX_N = 4e7 + 5, MAX_BITS = 4 + 5, BIT = (1 << 30) - 1, C = 1e8;

int n, tp;
ll f[MAX_N], a[MAX_N];
int l = 1, r = 0;
ll q[MAX_N];

ll calc(int i) { return a[i] - a[f[i]] + a[i]; }

ll read() {
	int s = 1; char ch;
	for (ch = getchar(); (ch < '0' || ch > '9') && ch != EOF; ch = getchar())
		if (ch == '-') s = -1;
	ll x = ch - '0';
	for (ch = getchar(); ch >= '0' && ch <= '9' && ch != EOF; ch = getchar()) x = x * 10 + (ch ^ 48);
	return x * s;
}

struct BigInt {
	ll d[MAX_BITS];
	
	void init(ll x = 0) {
		for (int i = 0; i <= MAX_BITS - 5; ++i) d[i] = 0;
		for (int i = 0; x; ++i, x /= C) d[i] = x % C;
	}
	
	BigInt &operator+=(BigInt &x) {
		for (int i = 0; i <= MAX_BITS - 5; ++i)
			if ((d[i] += x.d[i]) >= C) ++d[i + 1], d[i] -= C;
		return *this;
	}
	
	BigInt operator*(BigInt &x) const {
		BigInt res; res.init();
		for (int i = 0; i <= MAX_BITS - 5; ++i)
			for (int j = 0; j <= i; ++j)
				if ((res.d[i] += d[j] * x.d[i - j]) >= C)
					res.d[i + 1] += res.d[i] / C, res.d[i] %= C;
		return res;
	}
	
	friend ostream &operator<<(ostream &s, const BigInt &x) {
		int i;
		for (i = MAX_BITS - 5; i >= 0 && !x.d[i]; --i);
		if (i < 0) return s << 0;
		s << x.d[i--];
		while (i >= 0) s << setw(8) << setfill('0') << x.d[i--];
		return s;
	}
} ans, sum;

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    n = read(); tp = read();
    if (!tp) for (int i = 1; i <= n; ++i) a[i] = read();
    else {
    	int x, y, z, b1, b2, m;
    	x = read(); y = read(); z = read();
    	b1 = read(); b2 = read(); m = read();
    	for (int i = 1, j = 1; j <= m; ++j) {
    		int p, l, r; p = read(); l = read(); r = read();
    		while (i <= p) {
    			int b;
    			if (i == 1) b = b1;
    			else if (i == 2) b = b2;
    			else {
    				b = (((1ll * x * b2) & BIT) + ((1ll * y * b1) & BIT)) & BIT;
    				(b += z) &= BIT;
    			}
    			a[i] = b % (r - l + 1) + l;
    			if (i >= 3) b1 = b2, b2 = b;
    			++i;
    		}
    	}
    }
    for (int i = 2; i <= n; ++i) a[i] += a[i - 1];
    f[1] = 0; q[++r] = 1;
    for (int i = 2; i <= n; ++i) {
    	while (l < r && calc(q[l + 1]) <= a[i]) ++l;
    	f[i] = (l <= r && calc(q[l]) <= a[i] ? q[l] : 0);
    	while (l <= r && calc(q[r]) >= calc(i)) --r;
    	q[++r] = i;
    }
    int p = n;
    while (p) {
    	sum.init(a[p] - a[f[p]]);
    	sum = sum * sum; ans += sum;
    	p = f[p];
    }
    cout << ans;
    return 0;
}
```

---

## 作者：MoonCake2011 (赞：1)

首先对于两个段 $a$ 与 $b$，且 $a<b$，显然 $(a+b)^2>a^2+b^2$。

于是需要在 $a<b$ 的情况尽量多分段，于是考虑 dp。

设 $dp_i$ 为前 $i$ 个数的最优运行时间。

因为多分段，所以 $dp_i$ 的最后一段一定最小，所以 $dp_i$ 对于后买你的状态一定最优。

我们将 $dp_i$ 的最后一段和记为 $l_i$。

设 $dp_i$ 是从 $dp_j$ 转移来的，那么 $l_i=\sum_{k=j+1}^ia_k$。

得出代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,FW_number;
int a[100010];
__int128 s[100010];
__int128 dp[5010];
inline void write(__int128 x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x<10){
		putchar(x%10+'0');
		return;
	}
	write(x/10);
	putchar((x%10)^48);
}
int l[5010];
int main() {
	cin>>n>>FW_number;
	for(int i=1;i<=n;i++) cin>>a[i],s[i]=s[i-1]+a[i];//前缀和
	memset(dp,0x3f,sizeof dp);
	dp[0]=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<i;j++)
			if(s[i]-s[j]>=l[j] && dp[i]>dp[j]+(s[i]-s[j])*(s[i]-s[j])) dp[i]=dp[j]+(s[i]-s[j])*(s[i]-s[j]),l[i]=s[i]-s[j];
	write(dp[n]);
	return 0;
}
```
[记录](https://www.luogu.com.cn/record/156188255)。

## 单调队列优化

如果 $dp_i$ 由 $dp_j$ 转移，设 $p_i=j$。

设 $s$ 为 $a$ 的前缀和数组，于是有 $l_i=s_i-s_{p_i}$。

这个转移的条件有 $s_j-s_{p_j}\le s_i-s_j$。

移项可得 $s_i\ge 2s_j-s_{p_j}$。

又因为 $s_{i+1}>s_i$，所以一个 $j$ 对于 $i$ 满足条件，它对于 $i+1$ 也满足条件。

于是我们建立单调队列，内装候选项。

转移时直接将不满足条件的排出，插入时将比此状态劣（也就是 $2s_j-s_{p_j}$ 大的）的排出。

最后直接计算答案即可。

时间复杂度 $O(n)$。

注意**最后**使用 `__int128` 记录答案，开多了会爆空间，少了会答案错误。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,FW_number;
int a[40000010];
long long s[40000010];
inline void write(__int128 x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x<10){
		putchar(x%10+'0');
		return;
	}
	write(x/10);
	putchar((x%10)^48);
} 

int pre[40000010];
int q[40000010],head,tail;
int b[40000010],p[100010];
inline long long l(int x){
    return s[x]-s[pre[x]];
}
void read(){
	long long x,y,z,m;
	cin>>x>>y>>z>>b[1]>>b[2]>>m;
	for(int i=3;i<=n;i++) b[i]=(x*b[i-1]+y*b[i-2]+z)%(1<<30);
	for(int i=1;i<=m;i++){
		long long l,r;
		cin>>p[i]>>l>>r;
		for(int j=p[i-1]+1;j<=p[i];j++) a[j]=(b[j]%(r-l+1))+l;
	}
	for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
}
int main() {
	cin>>n>>FW_number;
	if(!FW_number) for(int i=1;i<=n;i++) cin>>a[i],s[i]=s[i-1]+a[i];
	else read();
	head=1,tail=0;
	q[++tail]=0;
	for(int i=1;i<=n;i++){
		while(head<tail && s[i]-s[q[head+1]]>=l(q[head+1])) head++;
		pre[i]=q[head];
		while(head<tail && s[q[tail]]-s[i]>=l(i)-l(q[tail])) tail--;
		q[++tail]=i;
	}
	__int128 ans=0;
	for(int i=n;i;i=pre[i]) ans+=(__int128)l(i)*l(i);
	write(ans);
	return 0;
}
```

---

## 作者：Melo_DDD (赞：0)

好玩！

提供一种比较不同的贪心证明方式？

结论：在转移的时候，我们尽量让当前的结尾段规模最小，一定最优。

假设我们现在有一个结尾段 $s_i$ 和他的上一段 $s_{i-1}$，此时我们有 $s_i\ge s_{i-1}$，接下来我们考虑要是他俩中间还有一个数 $a$，这个数既可以分到 $s_{i-1}$ 也可以分到 $s_i$，哪一个更优，分到 $s_{i-1}$ 的贡献是 $(s_{i-1}+a)^2$，分到 $s_i$ 的贡献是 $(s_i+a)^2$，显然前者贡献更小。

同时分到前面我们也可以保证最后一段规模尽量小，对后面的约束也就越宽松。

总结一下，如果一个数能不分到最后一段，我们一定不把他分到最后一段。

得证。

那么我们可以 dp，设 $dp_i$ 表示当前最后一段以 $i$ 结尾，上一段的结尾最靠后能在哪里，如果 $dp_i=j$ 的话，那么显然最后一段是 $[j+1,i]$。

考虑对于一个 $dp_i$，能够合法转移到他的 $j$ 需要满足什么条件，不难发现是 $[dp_j+1,j]$ 这段的和小于 $[j+1,i]$ 这段。

进行前缀和操作，条件等价于 $sum_j-sum_{dp_j}\le sum_i-sum_j$，移项有 $sum_i\ge 2\times sum_j-sum_{dp_j}$．

右边只和 $j$ 有关，可以使用单调队列优化。

队尾的维护比较简单，队头的维护说一说。

观察到 $sum_i$ 单增，那么对于一个队头 $j$，如果他在队列中的后一个元素也满足上面不等式，那队头就没用了，弹掉。

复杂度是我们熟悉的 $\Theta(n)$。

这题比较卡常，稍微卡一卡就可以了。

Code


```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ; i <= (n) ; i += (x))
using ll = long long ; using i128 = __int128 ;

template < typename T > inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ; char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ; 
	} while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	} flag ? x = - x : 0 ;
} template < typename T ,typename ...Args >
inline void read ( T &x ,Args &...tmp ) {
	read (x) ,read (tmp...) ;
}

const int N = 4e7 + 7 ,M = 1e5 + 7 ;
const ll mod = 1ll << 30 ;
int n ,type ,dp[N] ,m ,q[N] ,h = 1 ,t ,b[N] ,p[M] ,l[M] ,r[M] ,x ,y ,z ,a[N] ;
ll sum[N] ;
i128 ans ;

template < typename T > inline void print ( T x ) {
	if (x >= 10) print (x / 10) ;
	putchar (x % 10 + '0') ;
}

int main () {
	read (n ,type) ;
	if (! type) { f (i ,1 ,n ,1) read (a[i]) ; goto her ;}
	read (x ,y ,z ,b[1] ,b[2] ,m) ;
	f (i ,1 ,m ,1) read (p[i] ,l[i] ,r[i]) ;
	f (i ,1 ,n ,1) {
		if (i > 2) b[i] = (1ll * x * b[i - 1] + 1ll * y * b[i - 2] + 1ll * z) % mod ;
		int j = std :: lower_bound (p + 1 ,p + m + 1 ,i) - p ;
		a[i] = (b[i] % (r[j] - l[j] + 1)) + l[j] ;
	} 
	her : ;
	f (i ,1 ,n ,1) sum[i] = sum[i - 1] + 1ll * a[i] ;
	q[++ t] = 1 ;
	f (i ,2 ,n ,1) {
		while (h < t && 2 * sum[q[h + 1]] - sum[dp[q[h + 1]]] <= sum[i]) h ++ ;
		if (sum[i] >= 2 * sum[q[h]] - sum[dp[q[h]]]) dp[i] = q[h] ;
		while (h <= t && 2 * sum[i] - sum[dp[i]] <= 2 * sum[q[t]] - sum[dp[q[t]]]) t -- ;
		q[++ t] = i ;
	}
	int cur = n ; 
	while (cur) {
		ans += (i128) (sum[cur] - sum[dp[cur]]) * (sum[cur] - sum[dp[cur]]) ;
		cur = dp[cur] ;
	} 
	//f (i ,1 ,n ,1) std :: cout << dp[i] << ' ' ; puts ("") ;
	print (ans) ;
	return 0 ;
}
```

---

## 作者：weiyiqian (赞：0)

[传送门](https://www.luogu.com.cn/problem/P5665)

---

看到划分，可以想到去暴力 dp。$f_i$ 表示前 $i$ 个数划分方案的权值，$g_i$ 表示前 $i$ 个数的最优划分方案最后一段数的和，$s_i$ 表示 $a$ 序列的前缀和，于是就有
$$
f_i=\min_{0\le j<i,g_j\le s_i-s_j}\{f_j+(s_i-s_j)^2\}
$$
这个做法是 $O(n^2)$ 的，能拿到 64pts 的好成绩！


---

接下来考虑如何优化。

仔细思考一下，想到一个性质：$(a+b)^2\ge a^2+b^2$，所以分段分得越多越好。这个性质启发我们去贪心地进行状态转移，即状态转移的决策点 $j$ 越大越好，也就是找到最大的 $j$ 使得 $s_i-s_j\ge g_j$。

移向后得到 $s_i\ge s_j+g_j$。
1. 由于 $s_{i+1}\ge s_i\ge s_j+g_j$，$j$ 也能作为 ${i+1}$ 的决策点，而 $j$ 之前 $s_{j'}+g_{j'}\le s_j+g_j$ 的决策点 $j'$ 就一定不会作为 $i+1$ 的决策点。
2. 若有两个决策点 $j1>j2$ 且 $s_{j1}+g_{j1}\le s_{j2}+g_{j2}$，则 $j1$ 一定是更优的，$j2$ 一定不会被选。

结合以上两点我们就能用单调队列来优化 dp，将没有用的决策点从单调队列中弹出，这样就能 $O(1)$ 地进行状态转移。总时间复杂度 $O(n)$。


---

由于该题的数据规模达到~~惊人的~~ $4\times 10^7$，并且最后答案有可能爆`long long`，所以需要优化一下空间。转移时不记录 dp 值，只记录转移的决策点，最后开`__int128`的变量计算答案即可。

代码：
```cpp
#include<bits/stdc++.h>
#define LL unsigned long long
#define gc() getchar()
using namespace std;
const int N=4e7+10,mod=1<<30;
int n,type;
LL s[N];
int q[N],hh,tt=-1,g[N];
int read(){
    int x=0,f=1;
    char ch=gc();
    for(;!isdigit(ch);ch=gc()) if(ch=='-') f=-1;
    for(;isdigit(ch);ch=gc()) x=x*10+ch-'0';
    return x*f;
}
void out(__int128 x){
    if(x>9) out(x/10);
    putchar(x%10+'0');
}
int main(){
    n=read(),type=read();
    if(!type){
        for(int i=1;i<=n;i++) s[i]=read(),s[i]+=s[i-1];
    }
    else{
        LL x,y,z;
        int m,p,r,l;
        LL b[3];
        x=read(),y=read(),z=read(),b[1]=read(),b[2]=read(),m=read();
        for(int j=1,i=1;j<=m;j++){
            p=read(),l=read(),r=read();
            for(;i<=p;i++){
                if(i>2) b[i%3]=(b[(i+2)%3]*x+b[(i+1)%3]*y+z)%mod;
                s[i]=b[i%3]%(r-l+1)+l+s[i-1];
            }
        }
    }
    for(int i=1;i<=n;i++){
        while(hh<=tt&&s[q[hh]]*2-s[g[q[hh]]]<=s[i]) hh++;
        hh--;
        g[i]=q[hh];
        while(hh<=tt&&s[q[tt]]*2-s[g[q[tt]]]>=s[i]*2-s[g[i]]) tt--;
        q[++tt]=i;
    }
    __int128 ans=0;
    int t=n;
    while(t){
        ans+=(__int128)(s[t]-s[g[t]])*(s[t]-s[g[t]]);
        t=g[t];
    }
    out(ans);
    return 0;
}
```

---

## 作者：_2eyks (赞：0)

考点：dp、前缀和、单调队列。

**$\color{orange}{64}$ pts**

设 $dp_{i,j}$ 表示最后一次合并时选择的段落为 $[j+1,i]$ 的情况下，前 $i$ 个数任意合并后答案的最小值。

可以枚举前一个转移状态 $dp_{j,t}$，满足 $\sum\limits_{i=t+1}^ja_i\leq\sum\limits_{i=j+1}^ia_i$，并让 $dp_{i,j}$ 从所有符合条件的 $dp_{j,t}$ 转移而来。具体地，其转移方程式为：

$$dp_{i,j}=\min\limits_{j=1}^{i-1}(\min\limits_{0\leq t<j,\sum\limits_{i=t+1}^ja_i\leq\sum\limits_{i=j+1}^ia_i} dp_{j,t})+\sum\limits_{i=j+1}^ia_i$$

注意到 $t$ 的下限是单调的，可以用指针搞定，而 $dp_{j,t}$ 的 $\min$ 可以用后缀 $\min$ 求出。

```cpp
for (int i=1;i<=n;i++){
    dp[i][0]=sq(pre[i]);
    for (int j=1,t=0;j<i;j++){
        while (pre[j]-pre[t]>pre[i]-pre[j]&&t<j)
            t++;
        if (t>=j) dp[i][j]=4e18;
        else dp[i][j]=dp[j][t]+sq(pre[i]-pre[j]);
    }
    for (int j=i-2;j>=0;j--)
        dp[i][j]=min(dp[i][j],dp[i][j+1]);
}
```

**$100$ pts**

考虑证明 $dp_{i,j}\geq dp_{i,j-1}$ 的正确性。

因为 $(a+b)^2\geq a^2+b^2$，意味着数列在能多分段的时候就应该分段。而对于三个节点 $l,t,r$ 满足 $l<t<r$，若 $\sum\limits_{i=l}^{t-1}a_i\leq\sum\limits_{i=t}^{r}a_i$，则一定有 $\sum\limits_{i=l}^{t}a_i\leq\sum\limits_{i=t+1}^{r}a_i$，原因显然。而因为 $\sum\limits_{i=l}^{t-1}a_i\leq\sum\limits_{i=t+1}^{r}a_i$，且对于任意正整数常数 $y$，当 $x$ 增大，$(x+y)^2-x^2=xy+y^2$ 的值也会增大，所以将 $a_t$ 归于左段更优。证毕。

改令 $f_i$ 为前 $i$ 个值分段的答案。当 $f(x)>f(y)$ 且 $x<y$ 时，说明将前 $y$ 个值分段时，最后一段的前端覆盖 $x$ 会更优。排除这些存在一个 $y$ 使得条件成立的 $x$ 节点后，$f$ 数值单调。

至此，令 $ls[i]$ 为 $i$ 为右端的段的最优左端，使用单调队列即可，只需要弹掉队列左边区间和不符合条件的位置，并维护右端的单调性。可以用 `__int128` 和手写双端队列避免过度卡常。

```cpp
for (int i=1;i<=n;i++){
    while (l<r&&2*pre[q[l+1]]-pre[ls[q[l+1]]]<=pre[i]) l++;
    ls[i]=q[l];
    while (l<=r&&2*pre[q[r]]-pre[ls[q[r]]]>=2*pre[i]-pre[ls[i]]) r--;
    q[++r]=i;
}
```

---

## 作者：Jerrywang09 (赞：0)

数据范围较小时，可以考虑 dp。设 $f(i,j)$ 表示当前段末尾为 $i$，上一段末尾为 $j$ 的最小代价。转移为：
$$
f(i,j)= \min _{s_i-s_j \ge s_j-s_k}f(j,k)+(s_i-s_j)^2
$$
时间复杂度 $O(n^3)$。

不难想到一个性质：要使得 $f(i,j)$ 最小，上一段末尾 $j$ 要尽可能靠后。这样就能保证 $(s_i-s_j)^2$ 每次都比较小。

有了这个贪心结论，重新定义 dp 状态，省去第二维。假如现在有决策点 $j$，要求划分合法，则需要 $s_i-s_j\ge pre(j)$，$pre(j)$ 表示上一段末尾为 $j$ 的总和。移项，$s_j+pre(j) \le s_i$。

不难发现，$s_j+pre(j)$ 满足单调性，因此可以二分 $j$，或者直接使用单调队列。

注意：本题内存紧张，需要尽可能地省去无用的数组，比如说，$f(n)$ 其实可以倒推得到。同时注意 `__int128`。

```cpp
// Title:  划分
// Source: CSP-S2019
// Author: Jerrywang
#include <bits/stdc++.h>
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define F first
#define S second
#define pii pair<int, int>
#define ll long long
#define LL __int128
#define debug(x) cout<<#x<<":"<<x<<endl;
const int N=40000001;
using namespace std;

inline void write(LL x)
{
    if(x<10)
    {
        putchar(x+48); return;
    }
    write(x/10), putchar(x%10+48);
}

int n, type, b[N], q[N], pre[N], hh, tt;
ll a[N];
inline ll d(int i) {return a[i]-a[pre[i]];}

int main()
{
    scanf("%d%d", &n, &type);
    if(type==0)
    {
        rep(i, 1, n) scanf("%lld", a+i), a[i]+=a[i-1];
    }
    else
    {
        int x, y, z, m; scanf("%d%d%d", &x, &y, &z);
        scanf("%d%d%d", b+1, b+2, &m);
        rep(i, 3, n)
            b[i]=((ll)x*b[i-1]+(ll)y*b[i-2]+z)%(1<<30);
        int p1=0;
        while(m--)
        {
            int p, l, r; scanf("%d%d%d", &p, &l, &r);
            rep(i, p1+1, p) a[i]=b[i]%(r-l+1)+l, a[i]+=a[i-1];
            p1=p;
        }
    }
    rep(i, 1, n)
    {
        int j;
        // s[i]-s[q[hh]]>=d[q[hh]]
        while(hh<=tt && a[q[hh]]+d(q[hh])<=a[i])
            j=q[hh++];
        pre[i]=j;
        while(hh<=tt && a[q[tt]]+d(q[tt])>=a[i]+d(i)) tt--;
        q[++tt]=i;
    }
    LL res=0; int i=n;
    while(i) res+=(LL)d(i)*d(i), i=pre[i];
    write(res);

    return 0;
}
```

---


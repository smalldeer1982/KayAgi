# [CSP-S2019] 树的重心

## 题目描述

小简单正在学习离散数学，今天的内容是图论基础，在课上他做了如下两条笔记：
1. 一个大小为 $n$ 的树由 $n$ 个结点与 $n - 1$ 条无向边构成，且满足任意两个结点间**有且仅有**一条简单路径。在树中删去一个结点及与它关联的边，树将分裂为若干个子树；而在树中删去一条边（保留关联结点，下同），树将分裂为**恰好**两个子树。
2. 对于一个大小为 $n$ 的树与任意一个树中结点 $c$，称 $c$ 是该树的**重心**当且仅当在树中删去 $c$ 及与它关联的边后，分裂出的所有子树的大小均**不超过** $\lfloor \frac{n}{2} \rfloor$（其中 $\lfloor x \rfloor$ 是下取整函数）。对于包含至少一个结点的树，它的重心只可能有 1 或 2 个。

课后老师给出了一个大小为 $n$ 的树 $S$，树中结点从 $1 \sim n$ 编号。小简单的课后作业是求出 $S$ 单独删去每条边后，分裂出的两个子树的重心编号和之和。即：

$$
\sum_{(u,v) \in E} \left( \sum_{1 \leq x \leq n \atop 且 x 号点是 S'_u 的重心} x + \sum_{1 \leq y \leq n \atop 且 y 号点是 S'_v 的重心} y \right)
$$

上式中，$E$ 表示树 $S$ 的边集，$(u,v)$ 表示一条连接 $u$ 号点和 $v$ 号点的边。$S'_u$ 与 $S'_v$ 分别表示树 $S$ 删去边 $(u,v)$ 后，$u$ 号点与 $v$ 号点所在的被分裂出的子树。

小简单觉得作业并不简单，只好向你求助，请你教教他。


## 说明/提示

【样例 1 解释】

对于第一组数据：

删去边 $(1,2)$，1 号点所在子树重心编号为 $\{1\}$，2 号点所在子树重心编号为 $\{2,3\}$。

删去边 $(2,3)$，2 号点所在子树重心编号为 $\{2\}$，3 号点所在子树重心编号为 $\{3,5\}$。

删去边 $(2,4)$，2 号点所在子树重心编号为 $\{2,3\}$，4 号点所在子树重心编号为 $\{4\}$。

删去边 $(3,5)$，3 号点所在子树重心编号为 $\{2\}$，5 号点所在子树重心编号为 $\{5\}$。

因此答案为 $1 + 2 + 3 + 2 + 3 + 5 + 2 + 3 + 4 + 2 + 5 = 32$。

【数据范围】

| 测试点编号 | $n =$ | 特殊性质 |
| :----------- | :----------- | :----------- |
| $1 \sim 2$ | $7$ | 无 |
| $3 \sim 5$ | $199$ | 无 |
| $6 \sim 8$ | $1999$ | 无 |
| $9 \sim 11$ | $49991$ | A |
| $12 \sim 15$ | $262143$ | B |
| $16$ | $99995$ | 无 |
| $17 \sim 18$ | $199995$ | 无 |
| $19 \sim 20$ | $299995$ | 无 |


表中特殊性质一栏，两个变量的含义为存在一个 $1 \sim n$ 的排列  $p_i (1 \leq i \leq n)$，使得：
- A：树的形态是一条链。即 $\forall 1 \leq i \lt n$，存在一条边 $(p_i, p_{i + 1})$。
- B：树的形态是一个完美二叉树。即 $\forall 1 \leq i \leq \frac{n-1}{2}$ ，存在两条边 $(p_i, p_{2i})$ 与 $(p_i, p_{2i+1})$。

对于所有测试点：$1 \leq T \leq 5 , 1 \leq u_i,v_i \leq n$。保证给出的图是一个树。

## 样例 #1

### 输入

```
2
5
1 2
2 3
2 4
3 5
7
1 2
1 3
1 4
3 5
3 6
6 7```

### 输出

```
32
56```

# 题解

## 作者：xht (赞：225)

考虑每个点作为重心的次数。

首先拿出一个重心来当作根 $rt$。

对于点 $x \ne rt$，如果 $x$ 为割掉某条边后的重心，那么这条边一定不在 $x$ 的子树内。

设割掉一条边后，另外一棵树的大小为 $S$。

设 $g_x = \max_{y \in \text{son}(x)} \{s_y\}$。

由于 $x$ 为重心，所以要满足：
$$
2 \times (n - S - s_x) \le n - S
$$

$$
2 \times g_x \le n - S
$$

即：
$$
n - 2s_x \le S \le n - 2g_x
$$
即我们要找到对于一个 $x$，有多少条可以割掉的边满足：

1. $n - 2s_x \le S \le n - 2g_x$。
2. 边不在 $x$ 的子树内。

如果只有第一个条件，那么我们可以进行一次 dfs，同时拿一个树状数组动态维护割掉当前点和其父亲之间的边后每一个 $S$ 的值有多少个，那么对于每一个点的询问实质上就是一个区间求和。

然后我们要去掉不满足第二个条件，即在 $x$ 的子树内的边，可以再拿一个树状数组按照 dfs 序动态维护经过的所有点的每一个 $s$ 的值有多少个，那么对于一个点，在其子树内可以割掉的边就是回溯与进入时区间求和后的差。

最后还有一个问题是，当 $x = rt$，我们如何统计 $x$ 为重心的次数？

设 $x$ 的儿子中子树最大的节点为 $u$，次大的节点为 $v$。

若割掉的边在 $u$ 的子树中，则需要满足：
$$
2 \times s_v \le n - S
$$
即：
$$
S \le n - 2s_v
$$
否则，需要满足：
$$
2 \times s_u \le n - S
$$
即：
$$
S \le n - 2s_u
$$

可以在 dfs 的时候直接维护。

那么总时间复杂度为 $\mathcal O(n \log n)$。

```cpp
const int N = 3e5 + 7;
int n, rt, s[N], g[N], u, v, z[N];
vi e[N];
ll ans, c1[N], c2[N];

inline void add(ll *c, int x, int k) {
	++x;
	while (x <= n + 1) c[x] += k, x += x & -x;
}

inline ll ask(ll *c, int x) {
	++x;
	ll k = 0;
	while (x) k += c[x], x -= x & -x;
	return k;
}

void dfs1(int x, int f) {
	s[x] = 1, g[x] = 0;
	bool fg = 1;
	for (ui i = 0; i < e[x].size(); i++) {
		int y = e[x][i];
		if (y == f) continue;
		dfs1(y, x);
		s[x] += s[y];
		g[x] = max(g[x], s[y]);
		if (s[y] > (n >> 1)) fg = 0;
	}
	if (n - s[x] > (n >> 1)) fg = 0;
	if (fg) rt = x;
}

void dfs2(int x, int f) {
	add(c1, s[f], -1);
	add(c1, n - s[x], 1);
	if (x ^ rt) {
		ans += x * ask(c1, n - 2 * g[x]);
		ans -= x * ask(c1, n - 2 * s[x] - 1);
		ans += x * ask(c2, n - 2 * g[x]);
		ans -= x * ask(c2, n - 2 * s[x] - 1);
		if (!z[x] && z[f]) z[x] = 1;
		ans += rt * (s[x] <= n - 2 * s[z[x]?v:u]);
	}
	add(c2, s[x], 1);
	for (ui i = 0; i < e[x].size(); i++) {
		int y = e[x][i];
		if (y == f) continue;
		dfs2(y, x);
	}
	add(c1, s[f], 1);
	add(c1, n - s[x], -1);
	if (x ^ rt) {
		ans -= x * ask(c2, n - 2 * g[x]);
		ans += x * ask(c2, n - 2 * s[x] - 1);
	}
}

inline void solve() {
	rd(n);
	for (int i = 1; i <= n; i++) e[i].clear();
	for (int i = 1, x, y; i < n; i++) rd(x), rd(y), e[x].pb(y), e[y].pb(x);
	ans = 0;
	dfs1(1, 0);
	dfs1(rt, 0);
	u = v = 0;
	for (ui i = 0; i < e[rt].size(); i++) {
		int x = e[rt][i];
		if (s[x] > s[v]) v = x;
		if (s[v] > s[u]) swap(u, v);
	}
	for (int i = 1; i <= n + 1; i++) c1[i] = c2[i] = 0;
	for (int i = 0; i <= n; i++) add(c1, s[i], 1), z[i] = 0;
	z[u] = 1;
	dfs2(rt, 0);
	print(ans);
}

int main() {
	int T;
	rd(T);
	while (T--) solve();
	return 0;
}
```

---

## 作者：soar_ing (赞：190)

本题解远短于其他题解,只需要两次dfs和一次倍增

二叉树:

深度较浅,暴力换重儿子

对于一个点,若x不是重心,重心要么在重儿子子树里,要么在父亲节点上

第一次dfs求出son[x],s[x]

p[x][i]表示x沿着重儿子走$2^i$步

第二次dfs换根,把上面数组的定义从以1为根改为以x为根

对于一条边,以下方的重心,可以直接倍增,可以跳的条件为上方

的size<=sum/2

对于上方的重心,换根时记录信息,倍增方法一样

于是我们就用纯CSP算法解决了CSP2019 Day2 T3

给出简短的代码
```cpp
#include<bits/stdc++.h>
#define o 300005
#define g0(a) memset(a,0,sizeof(a))
#define gc(a,b) memcpy(a,b,sizeof(a))
using namespace std;
inline int read()
{
	register int data=0,w=1;
	char ch=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')w=-1,ch=getchar();
	while(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();
	return data*w;
}
struct node
{
	int to,next;
}w[o*2];
int n,T,son[o],s[o],pr[o],son2[o],p[o][18],son3[o],f[o],h[o],cnt,s2[o];
void add(int x,int y){++cnt;w[cnt].to=y;w[cnt].next=h[x];h[x]=cnt;}
void dfs(int x,int fa)
{
	s[x]=1;pr[x]=fa;
	for(int i=h[x];i;i=w[i].next)
	{
		int y=w[i].to;
		if(y==fa)continue;
		dfs(y,x);s[x]+=s[y];
		if(s[y]>s[son[x]])son2[x]=son[x],son[x]=y;
		else if(s[y]>s[son2[x]])son2[x]=y;
	}
	p[x][0]=son[x];
	for(int i=1;i<=17;i++)p[x][i]=p[p[x][i-1]][i-1];
}
long long ans;
int judge(int x,int sum)
{
	return x*(max(s2[son3[x]],sum-s2[x])<=sum/2);
}
void dfs2(int x,int fa)
{
	for(int i=h[x];i;i=w[i].next)
	{
		int y=w[i].to;
		if(y==fa)continue;
		s2[x]=s[1]-s[y];f[y]=0;f[x]=0;
		if(son[x]==y)son3[x]=son2[x];
		else son3[x]=son[x];
		if(s2[fa]>s2[son3[x]])son3[x]=fa;
		p[x][0]=son3[x];
		for(int j=1;j<=17;j++)p[x][j]=p[p[x][j-1]][j-1];
		int b=x;
		for(int j=17;j>=0;j--)if(s2[x]-s2[p[b][j]]<=s2[x]/2)b=p[b][j];
		ans+=judge(son3[b],s2[x])+judge(b,s2[x])+judge(f[b],s2[x]);
		b=y;
		for(int j=17;j>=0;j--)if(s2[y]-s2[p[b][j]]<=s2[y]/2)b=p[b][j];
		ans+=judge(son3[b],s2[y])+judge(b,s2[y])+judge(f[b],s2[y]);
		f[x]=y;
		dfs2(y,x);
	}
	son3[x]=p[x][0]=son[x];f[x]=pr[x];
	for(int j=1;j<=17;j++)p[x][j]=p[p[x][j-1]][j-1];
	s2[x]=s[x];
}
int main()
{
	T=read();
	while(T--)
	{
		g0(h);g0(son);g0(f);g0(pr);cnt=0;ans=0;
		n=read();
		for(int i=1;i<n;i++)
		{
			int x=read(),y=read();
			add(x,y);add(y,x);
		}
		dfs(1,0);
		gc(s2,s);gc(son3,son);gc(f,pr);
		dfs2(1,0);
		cout<<ans<<'\n';
	}
	return 0;
}
```



---

## 作者：TEoS (赞：74)

考场上扔了T2来打这题的部分分，然后没看到数据范围是等号，不知道怎么判完全二叉树然后40分滚粗……

本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/11938664.html)

----

**思路分析**

很容易想到$O(n^2)$每次暴力找重心，这个暴力可以用各种神仙方法优化。

通过分析35分的特殊构造分，可以有一个想法，既然特殊构造可以有结论，那么是否也可以有一些结论来解决或者优化整个问题的解法。实际上，通过分析样例可以得到一些性质，这些性质可能有利于问题的求解：

1. 一棵树如果有两个重心，这两个重心一定是相邻的
2. 一棵树的重心一定在根节点所在的重链上
3. 一棵树的重心一定是以该树根节点重儿子为根的子树的重心的祖先

这些性质可以节省下很多不必要的时间。根据性质1，我们可以先找到深度较大的重心，然后对于已求出的重心再判断其父亲是否也是重心（因此接下来说的重心都是深度较大的重心）；根据性质2，我们在找重心的时候可以只往根节点所在的重链上找；根据性质3，我们可以从下往上找重心，不用每次重新找。

还有一些性质，接下来对于每种情况具体分析。

删掉一条边后一棵树会变成两部分，设该边的两个端点为$x,y$，其中深度较大的一点为$y$，则这两部分分别为以$y$为根的子树和整棵树减掉以$y$为根的子树。我们先分析以$y$为根的子树。

##### 以$y$为根的子树

我们可以根据性质3预处理出以所有节点为根的子树的重心，只要不断向上走就可以，时间复杂度$O(n)$。

##### 整棵树减掉以$y$为根的子树

根据性质2，这棵树的重心一定在根节点所在的重链上。试想，只要删掉的以$y$为根的子树大小一样，位置实际上是对重心没有影响的，唯一有可能影响的情况就是删掉的这个子树在以根节点重儿子为根的子树中。我们将这些情况再具体分析。

###### $y$不在以根节点重儿子为根的子树中

这是最平常的情况。既然只有删掉子树的大小对重心有影响，我们可以预处理出删去所有大小的子树之后的重心，然后直接询问。这个预处理只需要从根节点所在的重链从下到上走一遍就可以，时间复杂度$O(n)$。

###### $y$在以根节点重儿子为根的子树中

试想，如果删掉以$y$为根的子树后，这个重儿子仍然是重儿子，那么重心还是会在原来这条重链上，而重心显然只可能往重链上远离$y$的一端移动，而如果根节点就是重心，删掉子树之后根节点仍然会是重心。因此，最开始我们可以让整棵树的重心作为根节点，处理这种情况就变得很方便。

如果删掉子树后这个重儿子不再是重儿子了怎么办？显然，现在这个重儿子只会是原来的次重儿子。因此，我们可以预处理出次重儿子所在的重链上删去所有大小的子树之后的重心，然后按照$y$不在以根节点重儿子为根的子树中的情况处理。

所有预处理都是$O(n)$，每次询问$O(1)$，总的复杂度$O(n)$。

下面给出具体实现。（~~由于本人太菜，实现过程可能常数比较大，请勿模仿~~）

**具体实现**

**1.找重心**

dfs一遍随便找到一个重心即可。把整棵树的重心作为之后的根节点。

```c++
void findroot(int x,int f)
{
	siz[x]=1;
	for(int i=head[x],y=ver[i];i;i=Next[i],y=ver[i])
		if(y!=f)
		{
			findroot(y,x);
			siz[x]+=siz[y];
			if(siz[y]>siz[son[x]])
				son[x]=y;
		}
	if(siz[son[x]]*2<=n && (n-siz[x])*2<=n)
		root=x;
}

findroot(1,0);
```

**2.预处理节点信息**

预处理每个节点的子树大小、重儿子、深度、父亲以及属于根节点哪个儿子的子树，同时找到根节点的次重儿子。dfs一遍即可。

```c++
void pre(int x,int f)
{
	siz[x]=1,d[x]=d[f]+1,fa[x]=f;//分别表示子树大小、深度以及父亲
	if(f==root)
		ffa[x]=x;
	else
		ffa[x]=ffa[f];//属于根节点的哪个子树
	for(int i=head[x],y=ver[i];i;i=Next[i],y=ver[i])
		if(y!=f)
		{
			pre(y,x);
			siz[x]+=siz[y];
			if(siz[y]>siz[son[x]])
			{
				if(x==root)
					son2=son[x];
				son[x]=y;//找重儿子
			}
			else
				if(x==root && siz[y]>siz[son2])
					son2=y;//找根节点的次重儿子
		}
}

memset(son,0,sizeof(son));
pre(root,0);
```

**3.预处理答案**

分别预处理出根节点重儿子所在的重链的答案、根节点次重儿子所在的重链的答案以及以每个节点为根的子树的重心。每种情况从下到上走一遍即可。

第一种情况，对于每个删掉子树大小$y$，应该在根节点重儿子所在的重链上找到深度最大的$x$满足$2siz_x\geq n-y$。第二种情况同理。

第三种情况，对于每个子树的根节点$y$，应该其子树内深度最大的$x$满足$siz[x]\geq siz[y]$。

```c++
void get1(int x,int f)
{
	if(son[x])
		get1(son[x],x);//有重儿子走重儿子
	while(n-2*siz[x]<=nowans && nowans)
	{
		ans1[nowans]=x;
		nowans--;
	}
}//根节点重儿子所在的重链的答案

void get2(int x,int f)
{
	if(x==root)
		nowans=n,get2(son2,x);//走根节点次重儿子
	else
		if(son[x])
			get2(son[x],x);//其余节点有重儿子走重儿子
	while(n-2*siz[x]<=nowans && nowans)
	{
		ans2[nowans]=x;
		nowans--;
	}
}//根节点次重儿子所在的重链的答案


void get3(int r)
{
	if(son[r])
		get3(son[r]);//先走重儿子
	for(int i=head[r],y=ver[i];i;i=Next[i],y=ver[i])
		if(y!=son[r] && d[y]>d[r])
			get3(y);
	int now=son[r]?ans3[son[r]]:r;//从重儿子的重心往上找
	while(siz[now]*2<siz[r])
		now=fa[now];
	ans3[r]=now;
}//以r为根的子树的重心

get1(root,0),get2(root,0),get3(root);
```

**4.枚举删边求答案**

实际上枚举删掉子树也是可以的，这里还是用删边来写。

按照前面说到的情况，对于每种情况，先找到一个重心，然后再判断其父亲是否也是重心。判断的时候只要按照重心的定义来判断即可，注意有些特殊的节点要进行特判。

```c++
for(int i=1;i<=tot;i+=2)
{
	int x=ver[i],y=ver[ano];
	if(d[x]>d[y])
		swap(x,y);//令y为深度较大的节点
	int h1=ans3[y];
	ans+=h1;//h1就是以y为根的子树的重心
	if(d[fa[h1]]>=d[y] && check1(fa[h1],y))
		ans+=fa[h1];//判断h1的父亲是否也是以y为根的子树的重心
	if(ffa[y]==son[root])//y在以根节点重儿子为根的子树中
		if(siz[son[root]]-siz[y]>=siz[son2])
			ans+=root;//不影响重链，重心为根节点
		else
		{
			ans+=ans2[siz[y]];
			if(check2(fa[ans2[siz[y]]],y))
				ans+=fa[ans2[siz[y]]];
		}//影响重链
	else//y不在以根节点重儿子为根的子树中
	{
		ans+=ans1[siz[y]];
		if(check3(fa[ans1[siz[y]]],y))
			ans+=fa[ans1[siz[y]]];
	}
}
```

（感觉好多地方可以整合在一起写……凑合着看吧qwq）

下面给出完整代码：

```c++
//40分暴力
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ll long long
#define ano ((i-1)^1)+1
using namespace std;
const int N=3e5+100;
int T,n,cnt,tot;
ll ans;
int head[N],ver[2*N],Next[2*N];
int maxson[N],siz[N],d[N],nowh[N],nowsiz[N];
bool sp[N],v[N];
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,Next[tot]=head[y],head[y]=tot;
}
void dfs(int x,int root)
{
	if(x!=root)
		nowsiz[x]=1;
	v[x]=1;
	for(int i=head[x];i;i=Next[i])
		if(!sp[ver[i]] && !v[ver[i]])
		{
			int y=ver[i];
			dfs(y,root);
			maxson[x]=max(maxson[x],nowsiz[y]);
			if(x!=root)
				nowsiz[x]+=nowsiz[y];
		}
	if(maxson[x]*2<=nowsiz[root] && (nowsiz[root]-nowsiz[x])*2<=nowsiz[root])
		nowh[++cnt]=x;
}//找重心
void pre(int x,int f,int root)
{
	siz[x]=1,d[x]=d[f]+1;
	for(int i=head[x];i;i=Next[i])
		if(!d[ver[i]] && ver[i])
		{
			int y=ver[i];
			if(x==root)
				ffa[y]=y;
			else
				ffa[y]=ffa[f];
			pre(y,x,root);
			siz[x]+=siz[y];
		}
}//预处理子树大小和深度
void clearly()
{
	memset(maxson,0,sizeof(maxson));
	memset(nowsiz,0,sizeof(nowsiz));
	memset(v,0,sizeof(v));
	cnt=0;
}
void solve()
{
	pre(1,0,1);
	for(int i=1;i<=tot;i+=2)
	{
		clearly();
		int x=ver[i],y=ver[ano];
		sp[x]=sp[y]=1;//dfs时不走x,y
		if(d[x]>d[y])
			swap(x,y);//令y为深度较大的节点
		nowsiz[x]=n-siz[y],nowsiz[y]=siz[y];
		dfs(x,x),dfs(y,y);
		sp[x]=sp[y]=0;//还原
		for(int j=1;j<=cnt;j++)
			ans+=nowh[j];
	}
}
void clear()
{
	memset(head,0,sizeof(head));
	memset(Next,0,sizeof(Next));
	memset(siz,0,sizeof(siz));
	memset(d,0,sizeof(d));
	tot=ans=0;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		clear();
		scanf("%d",&n);
		for(int i=1,x,y;i<n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		solve();
		printf("%lld\n",ans);
	}
	return 0;
}
```

```c++
//100分
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define ano ((i-1)^1)+1
using namespace std;
const int N=3e5+100;
int T,n,tot,root,son2,nowans;
ll ans;
int head[N],ver[2*N],Next[2*N];
int siz[N],son[N],ans1[N],ans2[N],ans3[N],ffa[N],d[N],od[N],fa[N];
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,Next[tot]=head[y],head[y]=tot;
}
void findroot(int x,int f)
{
	siz[x]=1;
	for(int i=head[x],y=ver[i];i;i=Next[i],y=ver[i])
		if(y!=f)
		{
			findroot(y,x);
			siz[x]+=siz[y];
			if(siz[y]>siz[son[x]])
				son[x]=y;
		}
	if(siz[son[x]]*2<=n && (n-siz[x])*2<=n)
		root=x;
}//找重心
void pre(int x,int f)
{
	siz[x]=1,d[x]=d[f]+1,fa[x]=f;
	if(f==root)
		ffa[x]=x;
	else
		ffa[x]=ffa[f];
	for(int i=head[x],y=ver[i];i;i=Next[i],y=ver[i])
		if(y!=f)
		{
			pre(y,x);
			siz[x]+=siz[y];
			if(siz[y]>siz[son[x]])
			{
				if(x==root)
					son2=son[x];
				son[x]=y;
			}
			else
				if(x==root && siz[y]>siz[son2])
					son2=y;
		}
}//预处理节点信息
void get1(int x,int f)
{
	if(son[x])
		get1(son[x],x);
	while(n-2*siz[x]<=nowans && nowans)
	{
		ans1[nowans]=x;
		nowans--;
	}
}
void get2(int x,int f)
{
	if(x==root)
		nowans=n,get2(son2,x);
	else
		if(son[x])
			get2(son[x],x);
	while(n-2*siz[x]<=nowans && nowans)
	{
		ans2[nowans]=x;
		nowans--;
	}
}
void get3(int r)
{
	if(son[r])
		get3(son[r]);
	for(int i=head[r],y=ver[i];i;i=Next[i],y=ver[i])
		if(y!=son[r] && d[y]>d[r])
			get3(y);
	int now=son[r]?ans3[son[r]]:r;
	while(siz[now]*2<siz[r])
		now=fa[now];
	ans3[r]=now;
}//预处理答案
void clear()
{
	memset(head,0,sizeof(head));
	memset(Next,0,sizeof(Next));
	memset(ver,0,sizeof(ver));
	memset(son,0,sizeof(son));
	nowans=n,son2=tot=ans=0;
}
bool check1(int x,int y)
{
	return x && siz[son[x]]*2<=siz[y] && (siz[y]-siz[x])*2<=siz[y];
}
bool check2(int x,int y)
{
	if(x==root)
		return siz[son2]*2<=n-siz[y];
	return x && siz[son[x]]*2<=n-siz[y] && (n-siz[y]-siz[x])*2<=n-siz[y];
}
bool check3(int x,int y)
{
	if(x==root)
		return siz[son[x]]*2<=n-siz[y];
	return x && siz[son[x]]*2<=n-siz[y] && (n-siz[y]-siz[x])*2<=n-siz[y];
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		clear();
		for(int i=1,x,y;i<n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		findroot(1,0);
		memset(son,0,sizeof(son));
		pre(root,0),get1(root,0),get2(root,0),get3(root);
		for(int i=1;i<=tot;i+=2)
		{
			int x=ver[i],y=ver[ano];
			if(d[x]>d[y])
				swap(x,y);
			int h1=ans3[y];
			ans+=h1;
			if(d[fa[h1]]>=d[y] && check1(fa[h1],y))
				ans+=fa[h1];
			if(ffa[y]==son[root])
				if(siz[son[root]]-siz[y]>=siz[son2])
					ans+=root;
				else
				{
					ans+=ans2[siz[y]];
					if(check2(fa[ans2[siz[y]]],y))
						ans+=fa[ans2[siz[y]]];
				}
			else
			{
				ans+=ans1[siz[y]];
				if(check3(fa[ans1[siz[y]]],y))
					ans+=fa[ans1[siz[y]]];
			}
		}//枚举删边求答案
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：1gnat2 (赞：55)

根据重心的性质，这个题明显有$O(n)$解法。

以重心$root$为根。

记$g_x$表示子树$x$的重心，$size(x)$表示子树$x$的大小，$mx_x$表示$x$的子树大小最大的儿子。

那么$g_x$肯定在$path(x,g_{mx_x})$上。直接从$g_{mx_x}$向上走即可。总时间复杂度$O(n)$。

然后考虑去掉子树$x$的重心。去掉子树$x$后，重心$root$只可能向最大的儿子移动。

记$root$的次大儿子是$mx'$，第一步移动只可能向$mx_{root}$或$mx'$。

若$x$在子树$mx_{root}$内，且删去子树$x$后$2size(mx')>n$（此时$2size(mx_{root})<n$必然成立），则重心向$mx'$移动。

（显然，若$root$有多个次大儿子，则重心不可能向任一次大儿子移动。）

记$g$为当前重心，之后只可能向$g_{mx}$移动。

删除的子树越大重心移动得越远。各种线性复杂度的方法都行。

注意处理两个重心的情况。

总复杂度$O(n)$。

```cpp
#include <cctype>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define rep(i,x,y) for (int i=x; i<=(y); ++i)
#define repe(i,x) for (edge *i=x; i; i=i->nxt)

int get()
{
    char c;
    while (!isdigit(c=getchar()));
    int k=c-'0';
    for (; isdigit(c=getchar()); k=k*10+c-'0');
    return k;
}

using namespace std;

typedef long long ll;

const int N=3e5;

int n,root,idx,id[N],s[N],mx[N],fa[N];
ll ans;

struct edge
{
    int v;
    edge *nxt;
} pool[N*2],*tp,*fst[N];

int dfs0(int x,int fa=0)
{
    s[x]=1;
    int v,mx=0;
    repe(i,fst[x])
        if ((v=i->v)!=fa)
        {
            int t=dfs0(v,x);
            if (t)
                return t;
            s[x]+=s[v],mx=max(mx,s[v]);
        }
    mx=max(mx,n-s[x]);
    return mx<<1<=n? x:0;
}

int dfs1(int x)
{
    id[x]=++idx,s[x]=1,mx[x]=0;
    int v,g=x;
    repe(i,fst[x])
        if ((v=i->v)!=fa[x])
        {
            fa[v]=x;
            int t=dfs1(v);
            s[x]+=s[v];
            if (s[v]>s[mx[x]])
                mx[x]=v,g=t;
        }
    if (x==root)
        return x;
    while (s[g]<<1<s[x])
        g=fa[g];
    ans+=s[g]<<1>s[x]? g:g+fa[g];
    return g;
}

int a[N],*pa;
int b[N],*pb;

int find(int &g,int n)
{
    while (s[mx[g]]<<1>=n)
        g=mx[g];
    return s[g]<<1>n? g:g+fa[g];
}

int gx[N],gy[N];

void work()
{
    tp=pool,memset(fst,0,sizeof(fst)),ans=0;
    n=get();
    rep(i,2,n)
    {
        int u=get(),v=get();
        *tp=(edge){v,fst[u]},fst[u]=tp++;
        *tp=(edge){u,fst[v]},fst[v]=tp++;
    }
    root=dfs0(1);
    idx=fa[root]=0,dfs1(root);
    
    int x=root,y=0;
    repe(i,fst[root])
        if (i->v!=mx[x] && s[i->v]>s[y])
            y=i->v;
    int mn=n-s[y]*2,l=id[mx[x]],r=l+s[mx[x]];
    rep(k,1,n-1)
        gx[k]=find(x,n-k);
    gx[n]=0;
    fill(gy+1,gy+mn,root);
    rep(k,mn,n-1)
        gy[k]=find(y,n-k);
    rep(i,1,n)
        ans+=l<=id[i] && id[i]<r? gy[s[i]]:gx[s[i]];
    printf("%lld\n",ans);
}

int main()
{
    for (int tc=get(); tc--; work());
    return 0;
}
```

---

## 作者：Kinandra (赞：43)

本做法洛谷上可以通过, 发篇题解攒攒人品.

标签:主席树, dfs序, 树状数组.

容易想到对每个点分别求贡献(即求每个点割去那些边会成为重心), 我们选择任意一个点(就是 $1$号节点辣!)将其作为根节点.

模仿题目中的描述, 定义 $u$ 的 **分裂子树** 表示在树中删去 $u$ 及与它关联的边后, 分裂出的子树, 那么一条边 $e$ 对一个点 $u$ 有贡献, 当且仅当割去 $e$ 后, 考虑 $u$ 所在的一部分(记这部分的大小为 $tmp$, 记另一部分为**割去的部分**), $u$ 最大的**分裂子树** 的大小不大于 $\lfloor
\frac{tmp}2\rfloor$. 

#### Part 1

首先我们先考虑**根结点**的贡献, 我们先求出**根节点**的每一棵儿子的子树的大小 $size$, 取 $size$ 最大的儿子记为 $mx$.

显然如果我们割掉的边不在 $mx$ 的子树内, $u$ 最大的**分裂子树** 的大小不会改变, 那么这条边有贡献需要满足$size_{mx}\leqslant \lfloor\frac{n-t}{2}\rfloor$, 其中 $t$ 表示**割去的部分** 的大小, 稍加变形后得到 $t\leqslant n-2\times size_{mx}$.

考虑割掉的边在 $mx$ 的子树内, $u$ 的最大 **分裂子树** 可能会变成原来次大的(记为 $mx'$ ), 那么我们需要满足 $size_{mx}-t\leqslant \lfloor\frac{n-t}{2}\rfloor, size_{mx'}\leqslant \lfloor\frac{n-t}{2}\rfloor$, 稍加变形后得到 $2\times size_{mx}-n\leqslant t\leqslant n-2\times size_{mx'}$.

所以我们需要知道 $t$ 取每个值的方案数, 显然 $t$ 的一个取值对应了一个节点子树的大小, 我们对每个**根**的儿子求出其子树内 $t$ 的取值情况, 在分别求出合法的 $t$ 的方案就好了.

复杂度 $\mathcal O(n)$, 事实上枚举每个点做根求一遍答案可以做到 $\mathcal O(n^2)$.

#### Part 2

接下来考虑其他点的贡献, 发现其他点与根节点唯一的区别就是具有 **外子树** (指断掉与父亲节点的连边的那棵子树), 那么该如何维护外子树的 $t$ 的取值呢?

发现我们可以很容易地在 $\mathcal O(n\log n)$ 的时间内通过 线段树合并, 主席树+dfs序 等方法来维护 **内子树** (与**外子树**相对)的 $t$ 的取值, 这里不赘述, 那么是否可以维护**整棵树**对于某个点的 $t$ 的取值呢? 这样减去**内子树**的部分, 就可以得到**外子树**的 $t$ 的取值了.

事实上这是可以维护的, 首先整棵树对于**根**结点的 $t$ 取值就是处根节点外所有点的子树大小. 考虑我们已知整棵树对点 $u$ 的情况,  如何求 $u$ 的一个儿子 $v$ 的情况呢? 发现 $u, v$ 断去某条边的 $t$ 不同当且仅当这条边是 $(u,v)$, 所以 $v$ 的 $t$ 的取值比 $u$ 多了一个 $n-sz_v$, 少了一个 $sz_v$. 于是我们可以边dfs边维护整棵树对于某个点的 $t$ 的取值了, 这里要用到树状数组/线段树, 复杂度是 $\mathcal O(n\log n)$ 的.

时间复杂度 $\mathcal O(n\log n)$ , 空间复杂度  $\mathcal O(n\log n)$ .

~~代码不敢贴, 怕被hack~~

upd, 把代码补上, 不然可能看不太懂哈.

```cpp
#include <bits/stdc++.h>
using namespace std;
int read();

int n;

int hd[300005], nx[600005], to[600005], cnt;
void add(int f, int t) { nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t; }

struct Bit {
	int ts[300005];
	void add(int p, int v) {
		for (; p <= n; p += p & (-p)) ts[p] += v;
	}
	int qry(int l, int r) {
		if (l > r) return 0;
		l--;
		int rt = 0;
		while (l != r) {
			if (l > r) rt -= ts[l], l -= l & (-l);
			if (r > l) rt += ts[r], r -= r & (-r);
		}
		return rt;
	}
} bit;

int sz[300005], mx[300005][2];

struct P {
	int u, l, r;
} w[600005];

int root[300005];
struct Pseg {
	int idcnt;
	int ls[10000007], rs[10000007], ts[10000007];
	void add(int &x, int k, int l, int r, int p) {
		ts[x = ++idcnt] = ts[k] + 1, ls[x] = ls[k], rs[x] = rs[k];
		if (l == r) return;
		int mid = l + r >> 1;
		(p <= mid) ? add(ls[x], ls[k], l, mid, p)
			: add(rs[x], rs[k], mid + 1, r, p);
	}
	int qry(int k1, int k2, int l, int r, int st, int en) {
		if (st > r || en < l) return 0;
		if (st <= l && en >= r) return ts[k2] - ts[k1];
		int mid = l + r >> 1;
		return qry(ls[k1], ls[k2], l, mid, st, en) + qry(rs[k1], rs[k2], mid + 1, r, st, en);
	}
} seg;

long long res;

int l[300005], r[300005], L[300005], R[300005];
int pre[300005], pst[300005], frt[300005], dfn;
int fa[300005];
void dfs1(int u) {
	sz[u] = 1, root[pre[u] = ++dfn] = 0, frt[dfn] = u, mx[u][0] = mx[u][1] = 0;
	int tmx = 0, tci = 0;
	for (int i = hd[u], v; i; i = nx[i]) {
		if ((v = to[i]) == fa[u]) continue;
		fa[v] = u, dfs1(v), sz[u] += sz[v];
		if (sz[mx[u][1]] < sz[v]) mx[u][1] = v;
		if (sz[mx[u][0]] < sz[mx[u][1]]) swap(mx[u][0], mx[u][1]);
	}
	if (fa[u]) bit.add(sz[u], 1);
	tmx = sz[mx[u][0]], tci = sz[mx[u][1]];
	if (sz[mx[u][1]] < n - sz[u]) {
		mx[u][1] = fa[u], tci = n - sz[u];
		if (sz[mx[u][0]] < n - sz[u]) 
			swap(mx[u][0], mx[u][1]), swap(tmx, tci);
	}
	L[u] = 1, R[u] = n - tmx * 2; 
	l[u] = max(1, 2 * tmx - n),	r[u] = n - 2 * tci;
	pst[u] = dfn;
}

void dfs2(int u) {
	res += 1ll * u * ((mx[u][0] == fa[u]) ? 
					  bit.qry(l[u], r[u]) : bit.qry(L[u], R[u]));
	for (int i = hd[u]; i; i = nx[i])
		if (to[i] != fa[u]) {
			bit.add(sz[to[i]], -1), bit.add(n - sz[to[i]], 1);
			dfs2(to[i]);
			bit.add(sz[to[i]], 1), bit.add(n - sz[to[i]], -1);
		}
}

int main() {
	int T = read();
	while (T--) {
		n = read(), cnt = 0, res = 0, dfn = 0, seg.idcnt = 0;
		for (int i = 1; i <= n; ++i) hd[i] = 0;
		for (int i = 1, u, v; i < n; ++i)
			u = read(), v = read(), add(u, v), add(v, u);
		for (int i = 1; i <= n; ++i) bit.ts[i] = 0;
		dfs1(1), dfs2(1);
		for (int i = 1; i <= n; ++i)
			seg.add(root[i], root[i - 1], 1, n, sz[frt[i]]);
		for (int u = 1; u <= n; ++u) {
			if (mx[u][0] != fa[u]) {
				for (int i = hd[u], v; i; i = nx[i]) {
					if ((v = to[i]) == mx[u][0]) {
						res -= 1ll * u * 
							seg.qry(root[pre[v] - 1], root[pst[v]], 1, n, L[u], R[u]);
						res += 1ll * u * 
							seg.qry(root[pre[v] - 1], root[pst[v]], 1, n, l[u], r[u]);
					}
				}
			} else {
				res -= 1ll * u * 
					seg.qry(root[pre[u]], root[pst[u]], 1, n, l[u], r[u]);
				res += 1ll * u * 
					seg.qry(root[pre[u]], root[pst[u]], 1, n, L[u], R[u]);
			}			
		}
		printf("%lld\n", res);
	}
	return 0;
}

int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (!isdigit(c)) f = (c == '-') ? -1 : f, c = getchar();
	while (isdigit(c)) x = x * 10 + c - '0', c = getchar();
	return x * f;
}
```


---

## 作者：frank3215 (赞：28)

本题解是[题解栏][0]内一些常见思路的集合。

为了篇幅紧凑，在一些地方我可能跳过了证明/阐述的不是怎么详细，如果希望看到某一个思路的详细阐述/代码，可以点击相关的超链接。

## 思路

本题的部分分启发我们去找性质：

1. 链的部分分启发我们去考虑**树链剖分**。
2. 二叉树的部分分启发我们去考虑**以重心为根**的情况。
3. 由于要同时考虑子树与外子树的情况，这启发我们想到**换根法**。

性质：

1. 熟练剖分之后，考虑根节点所在的重链，可证明重心$u$在这条重链上。
2. 对根$rt$的任意一个儿子$u$，考虑以$u$为根的子树，若它的重心为$v$，则可证明在原树中，原树的重心为$v$的祖先。
3. 若不止有一个重心，且已知$u$为重心，那么只有$u$的重儿子（或父亲）有可能是重心。——这个性质在检查其他重心时有用。

计数方法：

1. 对于每一个点，我们计算它作为重心的次数：这会导致实现偏向数据结构（BIT、可持久化线段树、树状数组等）。
2. 对于每一个分割，我们去找两课树的重心：这回导致实现偏向图论类方法（树链剖分、找重儿子、倍增等）。

## 方法0：考虑点，只考虑定义

 [代码](https://loj.ac/submission/775715)  [类似思路的题解][3] 

考虑一个点$u$，我们想要知道，它会成为几次重心。

将树在$u$处定根，设其最大的子树大小为$S=siz_w$，则可以分为两种情况：

1. 删去的边不在$tree_w$中，$tree_v\not\subseteq tree_w$：则$siz_v\le n-2S$时，$u$成为重心。
2. 删去的边在$tree_w$中：设除了$tree_w$最大的子树大小为$T$，则$2S-n\le siz_v\le n-2T$时$u$成为重心。

因此，我们考虑处理出以$u$为根，各个儿子的$\{siz\}$的可重集合的情况，再查询一段区间内的$siz$的个数即可。

### 维护方法

可以用可持久化线段树（可能可以线段树合并/将所有查询离线化）维护。

特别地，$fa_u$的情况，相当于$tree-anc_u-tree_u$与$\{u\}+anc_u-\{rt\}$取反。（其中，$anc_u$表示$u$的所有祖先节点）

## 方法1：考虑点，以重心为根

我们先找到重心$rt$，并以它作为根。这样和随意选根有什么区别呢？

**性质**：若$x\ne rt$为重心，则删去的边$(u,v)$一定不在$tree_x$内。

因此，对一个点$u\ne rt$，他作为重心仅当删去了一条边$(x,y)$，且：$(x,y)$不在$tree_u$内，$n-2s_x\le S\le n-2g_x$。（设树减少的大小为$S$）

对于根的情况，可以另外（分成割去的边在重儿子子树内与不在重儿子子树内）判断。

可以用树状数组维护，具体见[这篇题解][4]。

## 方法2：考虑边

考虑一种删边情况，我们需要快速求出，划分后的所有重心。

考虑如何求一棵树的重心：因为重心一定在根节点所在重链上，从根一直跳重儿子，直到找到最深的$v$使得，$2s_v > s_u$，则$v$（可能还有它的重儿子）为重心。此过程可以用倍增加速。

由这种做法，我们可以在树链剖分，并预处理倍增数组之后$O(\log n)$地求出任何子树的重心。

### 某[高赞题解][5]的变体

我们考虑一个划分$(u,v)$，不妨设$dep_u>dep_v$：

考虑如何求$tree_u$的重心：**我们从$u$出发**，一直向重儿子跳，跳到找到重心（即，重儿子的子树大小不超过原树的一半）为止。

考虑如何求出$tree-tree_u$的重心：我们先将根换到$v$处（此时只改变了两个节点的关系），这样实际上就相当于求$tree_u$的重心！

具体实现在[此][6]。

## 方法3：考虑边，[某神奇的$O(n)$做法][9]

就如之前所说的，可以在$O(n)$计算出所有子树的重心，但是很难对去掉子树的部分找到一个重心单调移动的计算序列……

以重心为根，考虑删去的边在哪棵子树内：

1. 不在重儿子的子树内：则枚举所有可能的子树大小，在根所在的重链上面走就好了。
2. 在重儿子的子树内：
   1. 重儿子仍然为重儿子：此时，根仍然为重心。
   2. 次重儿子变为了重儿子：在次重儿子的重链上走即可。

这样就用纯图论方法完成了这题。

## 参考资料

[0]: https://www.luogu.com.cn/problemnew/solution/P5666
[3]: https://dra.blog.luogu.org/solution-p5666
[4]: https://www.luogu.com.cn/blog/xht37/solution-p5666
[5]: https://www.luogu.com.cn/blog/soaring/solution-p5666
[6]: https://loj.ac/submission/717065
[9]: https://www.luogu.com.cn/blog/qzh/p5666-shu-di-zhong-xin

- https://www.luogu.com.cn/problemnew/solution/P5666
- https://dra.blog.luogu.org/solution-p5666
- https://www.luogu.com.cn/blog/xht37/solution-p5666
- https://www.luogu.com.cn/blog/soaring/solution-p5666
- https://loj.ac/submission/717065
- https://www.luogu.com.cn/blog/qzh/p5666-shu-di-zhong-xin




---

## 作者：wucstdio (赞：21)

考场这道题的思考时间比前两道题都短……

果然是学的太多思维僵化了。

首先，题目中给的式子可以等价为枚举一个点，然后查看这个点会作为多少棵子树的重心。

接下来我们的问题就是对每一个点 $x$ ，求出这个点会被统计多少次，也就是求出有多少割掉一棵子树的方案，使得 $x$ 成为重心。

首先拎出来一个重心当做树根，然后 dfs 一遍。

如果 $x$ 不是重心，那么就需要在它父亲的那颗子树中切掉一棵子树：

![](https://cdn.luogu.com.cn/upload/image_hosting/ygohn2wr.png)

我们设 $x$ 这棵子树大小为 $s$ ， $x$ 的子节点中最大的子树大小为 $m$ ，那么切掉的点 $del$ 需要满足如下式子：

$$\begin{cases}n-s-size[del]\le \dfrac{n-size[del]}{2}\\m\le \dfrac{n-size[del]}{2}\end{cases}$$

化简可以得到

$$n-2s\le size[del]\le n-2m$$

我们用一个树状数组记录这个点父节点的那颗子树中 $size=i$ 的子树数量。在 dfs 的过程中，每 dfs 到一个点 $x$ 就让 $c[size[x]]-1,c[n-size[x]]+1$ ，也就是当我们割掉 $f$ 与 $x$ 的边的时候切掉的子树大小从 $size[x]$ 变成了 $n-size[x]$ 。统计答案就是区间求和。

但是还有一个问题。这样一来我们统计的答案有可能会包含在 $x$ 的子树中删掉一棵子树的情况，这样是不满足条件的。

为了解决这个问题，我们可以再 dfs 一遍，这一次我们用线段树合并求出每一个点的子树中 $size=i$ 的子树数量。这里统计的是不合法的方案，从答案里面减去就行了。

最后还剩下 $x$ 是重心的情况。由于重心只有最多两个，我们可以先以重心为根对整棵树进行dfs，统计出 $x$ 这个点最大的子树 $m_1$ 和次大的子树 $m_2$ 。

接下来分情况讨论。如果我们是在最大的子树里面切割，就需要满足

$$m_2\le \dfrac{n-size[del]}{2}$$

即

$$size[del]\le n-2m_2$$

否则我们需要满足

$$m_1\le \dfrac{n-size[del]}{2}$$

即

$$size[del]\le n-2m_1$$

我们可以在线段树合并的过程中顺便求出这个答案。

总时间复杂度是 $O(n\log n)$ ，在考场电脑上不写读入优化 $3$s 左右，写读入优化 $2.5$s 。

下面是代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll long long
#define lson tree[x].child[0]
#define rson tree[x].child[1]
#define mid (l+r)/2
using namespace std;
struct Edge
{
	int to;
	int nxt;
}e[600005];
struct Tree
{
	int child[2];
	int sum;
}tree[10000005];
int n,m,edgenum,tot,head[300005],pa[300005],size[300005],s[300005],root[300005];
ll ans;
bool isroot[300005];
int read()
{
	char c=(char)getchar();
	while(c>'9'||c<'0')c=(char)getchar();
	int t=0;
	while(c>='0'&&c<='9')
	{
		t=t*10+c-'0';
		c=(char)getchar();
	}
	return t;
}
void add(int u,int v)
{
	e[++edgenum].to=v;
	e[edgenum].nxt=head[u];
	head[u]=edgenum;
}
void dfs_pre(int node)//预处理，找出重心
{
	size[node]=1;
	for(int hd=head[node];hd;hd=e[hd].nxt)
	{
		int to=e[hd].to;
		if(to==pa[node])continue;
		pa[to]=node;
		dfs_pre(to);
		size[node]+=size[to];
		if(size[to]>n/2)isroot[node]=0;
	}
	if(n-size[node]>n/2)isroot[node]=0;
}
void dfs1(int node)//求出所有的size
{
	size[node]=1;
	for(int hd=head[node];hd;hd=e[hd].nxt)
	{
		int to=e[hd].to;
		if(to==pa[node])continue;
		pa[to]=node;
		dfs1(to);
		size[node]+=size[to];
	}
}
void add(int p)
{
	while(p<=n)
	{
		s[p]++;
		p+=p^(p&(p-1));
	}
}
void dec(int p)
{
	while(p<=n)
	{
		s[p]--;
		p+=p^(p&(p-1));
	}
}
int sum(int p)
{
	int ans=0;
	while(p)
	{
		ans+=s[p];
		p&=p-1;
	}
	return ans;
}
int sum(int l,int r)
{
	if(l>r)return 0;
	return sum(r)-sum(l-1);
}//以上是树状数组
int merge(int x,int y)
{
	if(!x||!y)return x+y;
	tree[x].sum+=tree[y].sum;
	lson=merge(lson,tree[y].child[0]);
	rson=merge(rson,tree[y].child[1]);
	return x;
}
void add(int x,int l,int r,int p)
{
	tree[x].sum++;
	if(l==r)return;
	if(p<=mid)
	{
		if(!lson)lson=++tot;
		add(lson,l,mid,p);
	}
	else
	{
		if(!rson)rson=++tot;
		add(rson,mid+1,r,p);
	}
}
//void debug(int x,int l,int r)
//{
//	if(l==r)
//	{
//		printf("%lld ",tree[x].sum);
//		return;
//	}
//	debug(lson,l,mid);
//	debug(rson,mid+1,r);
//}
ll sum(int x,int l,int r,int from,int to)
{
	if(from>to)return 0;
	if(!x)return 0;
	if(l>=from&&r<=to)return tree[x].sum;
	ll ans=0;
	if(from<=mid)ans+=sum(lson,l,mid,from,to);
	if(to>mid)ans+=sum(rson,mid+1,r,from,to);
	return ans;
}//以上是线段树合并
void dfs2(int node)
{
//	printf("%d:\n",node);
	int max1=0,max2=0;
	for(int hd=head[node];hd;hd=e[hd].nxt)
	{
		int to=e[hd].to;
		if(to==pa[node])continue;
		if(size[to]>max1)max2=max1,max1=size[to];
		else if(size[to]>max2)max2=size[to];
	}
//	printf("max1=%d,max2=%d\n",max1,max2);
	if(isroot[node]&&pa[node])
	{
		if(n-size[node]>max1)max2=max1,max1=n-size[node];
		else if(n-size[node]>max2)max2=n-size[node];
		if(n-size[node]==max1)ans+=1ll*node*sum(1,n-2*max2);
		else ans+=1ll*node*sum(1,n-2*max1);
	}
	for(int hd=head[node];hd;hd=e[hd].nxt)
	{
		int to=e[hd].to;
		if(to==pa[node])continue;
		pa[to]=node;
		dec(size[to]);
		add(n-size[to]);
		dfs2(to);
//		printf("to=%d,root=%d,",to,root[to]);
//		debug(root[to],1,n);
//		printf("\n");
		if(isroot[node])
		{
//			printf("%d->%d,range=",node,to);
//			if(size[to]==max1)printf("%d %d,res=%lld\n",1,n-2*max2,sum(root[to],1,n,1,n-2*max2));
//			else printf("%d %d,res=%lld\n",1,n-2*max1,sum(root[to],1,n,1,n-2*max1));
			if(size[to]==max1)ans+=1ll*node*sum(root[to],1,n,1,n-2*max2);
			else ans+=1ll*node*sum(root[to],1,n,1,n-2*max1);
		}
		root[node]=merge(root[node],root[to]);
		add(size[to]);
		dec(n-size[to]);
	}
	if(!isroot[node])
	{
//		printf("node=%d:tot=%lld-%lld\n",node,sum(max(1,n-2*size[node]),min(n,n-2*max1)),sum(root[node],1,n,max(1,n-2*size[node]),min(n,n-2*max1)));
		ans+=1ll*node*sum(max(1,n-2*size[node]),min(n,n-2*max1));
		ans-=1ll*node*sum(root[node],1,n,max(1,n-2*size[node]),min(n,n-2*max1));
	}
	if(isroot[node]&&pa[node])
	{
		if(n-size[node]==max1)ans-=1ll*node*sum(root[node],1,n,1,n-2*max2);
		else ans-=1ll*node*sum(root[node],1,n,1,n-2*max1);
	}
	add(root[node]?root[node]:root[node]=++tot,1,n,size[node]);
//	printf("node=%d:\n",node);
//	printf("tree:");
//	debug(root[node],1,n);
//	printf("\n");
//	printf("array:");
//	for(int i=1;i<=n;i++)printf("%lld ",sum(i)-sum(i-1));
//	printf("\n");
}
int t;
int main()
{
//	freopen("centroid.in","r",stdin);
//	freopen("centroid.out","w",stdout);
	t=read();
	while(t--)
	{
		n=read();
		ans=edgenum=0;
		for(int i=1;i<=tot;i++)tree[i].sum=tree[i].child[0]=tree[i].child[1]=0;
		for(int i=1;i<=n;i++)s[i]=head[i]=pa[i]=size[i]=root[i]=0,isroot[i]=1;
		tot=0;
		for(int i=1;i<n;i++)
		{
			int u=read(),v=read();
			add(u,v);
			add(v,u);
		}
		dfs_pre(1);
		for(int i=1;i<=n;i++)
		{
			if(isroot[i])
			{
				pa[i]=0;
				dfs1(i);
				for(int j=1;j<=n;j++)
				  if(j!=i)add(size[j]);
				dfs2(i);
				break;
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：strcmp (赞：17)

谷友们圣诞节快乐。

- **前言**

> 進んで 未来は
>
> そこにあるから

可爱小南梁的几大特征，如果您的朋友有以下表现，那么她很可能是可爱的小南梁：

1. 说话奶声奶气，喜欢喵喵叫。

2. 喜欢粉白蓝配色。

3. 喜欢穿可爱的女装。

4. 不知道 dfs 序排行 $\lceil\frac{n}{2}\rceil$ 的点的祖先链包含重心。

5. **写这道题不给答案开 `long long`。**

$\Large\text{Main Text}$

提供一个**题解区没有的新做法**，是模拟赛学到的一个 trick，感觉**扩展性极高且对比其它做法思维上压倒性简单**，就来分享一下。

---

重心的判定是 $\max(n - \text{siz}_u,\,\text{siz}_{\text{maxson}})$ 最小的点。

$n$ 个结点的树，**任意**定一个点为根，**任意** dfs 序下排行 $\lceil\frac{n}{2}\rceil$ 的点的祖先链中**一定包含重心。**

等价描述是重心的子树内一定包含 dfs 序排行 $\lceil\frac{n}{2}\rceil$ 的点。

**证明：**

**引理：** 以树的重心为根时，所有子树的大小不超过整棵树大小的一半。

证明根据重心的定义，重心是最大子树最小的点，如果有超过整棵树大小一半的子树，那重心往这个方向靠一定变优，矛盾。

也就是以任意点为根时，$n - \text{siz}_u \le \lfloor \frac{n}{2} \rfloor$，也即 $\text{siz}_u \ge \lceil\frac{n}{2}\rceil$。

重心 $u$ 的子树是区间 $[\text{dfn}_u,\,\text{dfn}_u + \text{siz}_u - 1]$，由区间长度 $\text{siz}_u \ge \lceil\frac{n}{2}\rceil$，必然包含 dfs 序排行 $\lceil\frac{n}{2}\rceil$ 的那个点。

---

知道这个结论之后这题就秒杀完了。

先钦定 $1$ 为根。

直接枚举删哪条边 $(u,\,\text{fa}_{u})$，整棵树分割成了 $u$ 子树和整棵树去掉 $u$ 子树后的联通块（显然也是一棵树）。

众所周知，$u$ 子树在 dfs 序上是一段区间 $[\text{dfn}_u,\,\text{dfn}_u + \text{siz}_u - 1]$。

首先 $u$ 这个子树的重心非常好找，我们直接维护 $\text{siz}$ 然后顺着重链用个指针扫下去即可，毕竟重心在重链上有单调性。

整棵树刨去 $u$ 子树怎么求？首先我们还是容易找到整棵树刨去 $u$ 子树的情况下，dfs 序排行一半的点是啥。

删去 $u$ 子树等价于 $\text{fa}_u$ 到根的路径的所有点的 $\text{siz}$ 全部减去 $\text{siz}_u$。

然后倍增，但是我们要单点查 $\text{siz}$ 是什么。

到根的链减和单点查，差分一下就是单点修改和子树查询，简单树状数组即可。同时维护重儿子和次重儿子，知道了 $\text{siz}$ 之后容易 check。

时间复杂度 $\Theta(n \log^2 n)$，有办法能直接优化到  $\Theta(\frac{n \log^2 n}{\log \log n})$ 但没有必要。

虽然对比其它做法时间复杂度上比较劣势，但**很容易**就能扩展到删去 $k$ 个子树求重心（直接维护前 $k$ 重儿子即可），而且完全不依赖本题要删除每个子树这个性质，可以直接做 $q$ 次询问。代码的话因为不需要啥思考很容易写，时间常数也比较小。甚至改一改也许能上 ETT 支持对树结构的修改（？）。

---

不对啊我在干什么。

实际上因为这题我们只有一个 $u$，因此每个点的 $\text{siz}$ 是完全可以简单 $\Theta(1)$ 求出的，那就是 $u$ 和 dfs 序排行一半的那个点的 LCA 之上 $\text{siz}$ 会减少 $\text{siz}_u$，于是你写一个 LCA 然后特判一点点东西即可。

时间复杂度 $\Theta(n \log n)$，思维难度压倒性的简单。

更进一步的，维护一些单调性感觉可以做到 $\Theta(n)$。比如考虑枚举 dfs 排行一半的点之类。留给读者思考。

这里给出 $\Theta(n \log n)$ 的代码。

月亮好闪，拜谢月亮。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
using pli = pair<ll, int>;
using pq = priority_queue<int>;
using ld = double;
constexpr int maxn = 3e5 + 10, mod = 1e9 + 7; 
struct edge { int to, nxt; } nd[maxn << 1]; int h[maxn], cnt = 0;
inline void add(int u, int v) { nd[cnt].nxt = h[u], nd[cnt].to = v, h[u] = cnt++; }
int dfn[maxn], id[maxn], dct = 0, d[maxn], fa[maxn][20], sz[maxn], son[maxn], son2[maxn], n, T;
int p[maxn]; ll ans = 0; //p[i] 代表进入了 i 的哪个儿子，这样方便我们判定重儿子是否需要换，这里用到了题目直接遍历树的特殊性，但实际上再写个倍增就可以不用这个性质。
void dfs(int u, int f) {
    fa[id[dfn[u] = ++dct] = u][0] = f; sz[u] = 1; son[u] = son2[u] = 0;
    rep(i, 1, 19) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int i = h[u]; ~i; i = nd[i].nxt) {
        int v = nd[i].to;
        if (v != f) {
            dfs(v, u), sz[u] += sz[v];
            if (sz[son[u]] < sz[v]) son2[u] = son[u], son[u] = v;
            else if (sz[son2[u]] < sz[v]) son2[u] = v;
        }
    }
}
void dfs2(int u) {
    int w = u;
    for (int x = u; x; x = son[x]) {
        //求出 x 为根子树的重心
        auto D = [&](int v) { if (v == 0) return n; return max(sz[x] - sz[v], sz[son[v]]); };
        while (son[w] && sz[son[w]] > sz[x] - sz[w]) w = son[w];
        int mi = min({ D(fa[w][0]), D(w), D(son[w]) });
        if (x != 1) {
            if (D(fa[w][0]) == mi) ans += fa[w][0];
            if (D(w) == mi) ans += w;
            if (D(son[w]) == mi) ans += son[w];
        }
        for (int i = h[x]; ~i; i = nd[i].nxt) {
            int v = nd[i].to;
            if (v != son[x] && v != fa[x][0]) dfs2(v);
        }
    }
}
inline int lca(int u, int v) {
    if (d[u] < d[v]) swap(u, v);
    rep(i, 0, 19) if (d[u] - d[v] >> i & 1) u = fa[u][i];
    if (u == v) return u;
    per(i, 19, 0) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
void calc(int u) {
    if (u == 1) return; 
    int L = dfn[u] - 1, R = n - dfn[u] - sz[u] + 1, x = (L + R + 1) / 2;
    if (L < R) x -= L, x = id[dfn[u] + sz[u] + x - 1];
    else x = id[x]; int w = lca(x, u); //求出 dfn 排行一半的点和 u 跟它的 lca
    auto S = [&](int v) {
        //此时的 maxson[v] 的 siz
        if (d[v] > d[w] || p[v] != son[v]) return sz[son[v]];
        else return sz[son[v]] - sz[u] > sz[son2[v]] ? sz[son[v]] - sz[u] : sz[son2[v]];
    };
    auto rl = [&](int v) {
        if (d[v] > d[w] || p[v] != son[v]) return son[v];
        else return sz[son[v]] - sz[u] > sz[son2[v]] ? son[v] : son2[v];
    };
    auto D = [&](int v) { 
        if (v == 0) return n; 
        return max(S(v), n - sz[v] - (!p[v] ? sz[u] : 0));
    };
    for (int i = 19; i >= 0; i--) {
        int v = fa[x][i]; 
        if (v && S(v) <= n - sz[v] - (!p[v] ? sz[u] : 0)) x = v;
    }
    //cout << S(1) << " " << n - sz[v] - (!p[v] ? sz[u] : 0) << "\n";
    if (D(fa[x][0]) < D(x)) x = fa[x][0];
    if (rl(x)) x = rl(x);
    int mi = min({ D(x), D(fa[x][0]), D(fa[x][1]) });
    //cout << u << " : " << ans << "\n";
    if (D(x) == mi) ans += x; if (D(fa[x][0]) == mi) ans += fa[x][0]; if (D(fa[x][1]) == mi) ans += fa[x][1];
    //cout << u << " : " << ans << "\n";
}
void dfs3(int u, int f) {
    p[f] = u; calc(u);
    for (int i = h[u]; ~i; i = nd[i].nxt) {
        int v = nd[i].to;
        if (v != f) dfs3(v, u);
    }
    p[u] = 0;
}
void solve() {
    memset(h, -1, sizeof(h)); cnt = dct = ans = 0; scanf("%d", &n);
    for (int i = 1, u, v; i < n; i++) scanf("%d%d", &u, &v), add(u, v), add(v, u);
    dfs(1, 0); dfs2(1); dfs3(1, 0);
    printf("%lld\n", ans);
}
int main() {
	//freopen("centroid.in", "r", stdin);
	//freopen("centroid.out", "w", stdout);
    scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```

---

## 作者：皎月半洒花 (赞：16)

说一种比较无脑的主席树思路。

首先考虑部分分做法？$40pts$ 就是暴力枚举切哪一条边。$55pts$ 的链在瞎映射一通可以 $O(1)$ 求出割完之后两棵树的重心分别是谁。$75pts$ 的满二叉树大概是要先找出 $\deg_x=2$ 的 $x$ ，不难知道这个一定是根，找一波规律可以发现割掉每一条边之后，较小的那一半的重心必然是这个小连通块的根，较大的那部分的重心是对面的另一个儿子，也可能是原树的根。算一下就好了。

然后考虑满分怎么做。以下设 $x$ 为当前点，$y_k$ 为 $x$ 的第 $k$ 个孩子(顺序随便定的)，$z$ 为 $x$ 的重儿子，设 $s$ 为割下来的连通块大小。 

这个满分做法，我自己推的比较烦，不如其他人简洁。大概就是计算每个点当重心的次数。然后我分成了三部分算。对于一个点 $x$ ，他可能成为重心，当且仅当：

### Case 1 它子树内的某个子树被割了，它成为了重心

考虑此时这个小子树的子树大小需要满足什么条件。首先由于要分子树讨论，不妨设从 $y_k$ 中割掉了一棵小子树。那么考虑要满足这么几个限制：

$$
\begin{aligned}
size_{y_k}-s&\leq \lfloor \frac{n-s}{2}\rfloor\\
n-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\
g_y&\leq  \lfloor \frac{n-s}{2}\rfloor
\end{aligned}
$$

其中 $g_y$ 为除去子树 $y$ 后剩下的子树最大值。因为根据定义本质上并不关心那些较小的子树。

于是这部分就可以分子树查。发现本质上转化成了在 $dfs$ 序上求「区间 $[l,r]$ 内值域在 $[a,b]$ 内的数有多少」，可以直接上主席树。然后这部分就做完了。

### Case 2 它子树外的某个子树被割了，它成为了重心

此时还是不变，但是约束变为了

$$
\begin{aligned}
n-s-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\
z&\leq \lfloor \frac{n-s}{2}\rfloor\\
\end{aligned}
$$

这部分也是可以直接主席树来求。但是注意解出来的 $[l,r]$ 内可能会包含从 $x$ 到根路径上点(祖先)的子树信息，可以对进退栈顺序开一棵线段树来容斥掉这一部分。

### Case 3 它子树外某个不是子树的连通块被割了，它成为了重心

考虑此时割掉的一定是 $x$ 到根路径上的一条边。发现本质上依旧是

$$
\begin{aligned}
n-s-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\
z&\leq \lfloor \frac{n-s}{2}\rfloor\\
\end{aligned}
$$

于是还是维护一棵退栈顺序的线段树来维护这个。

然后以上的线段树可以换成树状数组。于是代码：

```cpp
int _bit[N] ;

#define low(x) (x & -x)

il void mdf(int p, int x){
    for (  ; p <= n ; p += low(p)) _bit[p] += x ;
}
il int ask(int p){
    int ret = 0 ;
    for ( ; p ; p -= low(p)) ret += _bit[p] ;
    return ret ;
}
il int qry(int l, int r){ return ask(r) - ask(l - 1) ; }
void dfs5(int x, int fa){
    int l = max(1, n - 2 * sz[x]), s ;
    int r = n - 2 * sz[mson[x]], k, y, g ;
    if (r >= l){//Case 2
        res[x] += query(_rt[0], _rt[dfn[x] - 1], 1, n, l, r) ;
        res[x] += query(_rt[dfn[x] + sz[x] - 1], _rt[n], 1, n, l, r) ;
        res[x] -= qry(l, r) ;
    }
    pre[0] = 0 ; s = edg[x].size() ; suf[s] = 0 ;
    for (k = 0 ; k < s ; ++ k){
        y = edg[x][k] ;
        if (y == fa){ pre[k] = pre[max(0, k - 1)] ; continue ; }
        pre[k] = max(pre[max(k - 1, 0)], sz[y]) ;
    }
    for (k = s - 1 ; ~k ; -- k){
        y = edg[x][k] ;
        if (y == fa){ suf[k] = suf[k + 1] ; continue ; }
        suf[k] = max(suf[k + 1], sz[y]) ;
    }
    for (k = 0 ; k < s ; ++ k){ //Case 1
        y = edg[x][k] ;
        if (y == fa) continue ;
        g = max(n - sz[x], suf[k + 1]) ;
        if (k > 0) g = max(pre[k - 1], g) ;
        l = max(1, 2 * sz[y] - n), r = n - 2 * g ;
        if (r >= l)
            res[x] += query(_rt[dfn[y] - 1], _rt[dfn[y] + sz[y] - 1], 1, n, l, r) ;
    }
    mdf(sz[x], 1) ;
    for (auto k : edg[x])
        if (k != fa) dfs5(k, x) ;
    mdf(sz[x], -1) ;
}
void dfs6(int x, int fa, int qwq){//Case 3
    int t = sz[x] + qwq ;
    int r = n - 2 * sz[mson[x]] ;
    int l = max(1, n - 2 * sz[x]) ;
    if (r >= l)
        res[x] += qry(l, r) ;
    for (auto k : edg[x]){
        if (k == fa) continue ;
        mdf(t - sz[k], 1) ;
        dfs6(k, x, t - sz[k]) ;
        mdf(t - sz[k], -1) ;
    }
}
int main(){
//	freopen("centroid.in", "r", stdin) ;
// 	freopen("centroid.out", "w", stdout) ;
 	qr(T) ; int i, j, k ;
	while (T --){
		qr(n), ans = tot = 0 ;
        for (i = 1 ; i <= n ; ++ i)
            edg[i].clear(), mson[i] = res[i] = _bit[i] = 0 ;
        for (i = 1 ; i < n ; ++ i)
            qr(j), qr(k), edg[j].p_b(k), edg[k].p_b(j) ;
        dfs4(1, Id = 0) ; build(_rt[0], 1, n) ;
        for (i = 1 ; i <= n ; ++ i)
            upd(_rt[i], _rt[i - 1], 1, n, sz[rev[i]]) ;
        dfs5(1, 0) ; fill(_bit + 1, _bit + n + 1, 0) ; dfs6(1, 0, 0) ;
        for (int i = 1 ; i <= n ; ++ i) ans += 1ll * res[i] * i ; qw(ans, '\n') ;
    }
}
```
然后就做完了。复杂度是 $O(n\log n)$，但就是常数巨大…不知道为什么…感觉应该挺快才对啊（



---

## 作者：Mr_Wu (赞：15)

先将树变成以 $1$ 为根的有根树，并约定 $T(u)$ 为 $u$ 的子树，$T$ 为整棵树，$p(u,T)$ 表示 $u$ 是 $T$ 的重心

----

考虑一些简单的手法：

$$ \begin{aligned} & \sum_{(fa_u,u)\in E} \big(\sum_{p(x,T(u))} x + \sum_{p(y,T-T(u))} \big) \\ & = \sum_x x\sum_{u\not= 1} [p(x,T(u))]+\sum_x x\sum_{u\not= 1} [p(x,T-T(u))] \end{aligned} $$

----

考虑研究若 $p(x,T(u))$，则 $x,u$ 满足什么性质。

设 $wson$ 为 $x$ 的 $siz$ 最大的儿子。

事实上 $p(x,T(u))$ 当且仅当：

$$ \left\{ \begin{aligned} & x\in T(u) \\ & siz_{wson}\le \lfloor \frac{siz_u}{2}\rfloor \\ & siz_u-siz_x\le \lfloor \frac{siz_u}{2}\rfloor \end{aligned} \right. $$

考虑到 $\forall x\in Z$，$x\le \lfloor a\rfloor \Leftrightarrow x\le a$，因此后两个式子直接化为

$$ 2siz_{wson}\le siz_u\le 2siz_x$$

----

考虑研究若 $p(x,T-T(u))$，则 $x,u$ 满足什么性质。

### Situation 1 

首先考虑 $u\in T(x)-\{x\}$，设 $v$ 为 $x$ 的儿子，且 $u\in T(v)$ （显然 $v$ 存在且唯一），

![](https://cdn.luogu.com.cn/upload/image_hosting/q4deau01.png)

设 $wson$ 为除去 $v$，$x$ 的 $siz$ 最大的儿子。（若没有，则认为 $siz_{wson}=0$）

$$ \left\{ \begin{aligned} & siz_{wson}\le \lfloor \frac{n-siz_u}{2}\rfloor \\ & siz_v-siz_u\le \lfloor \frac{n-siz_u}{2}\rfloor \\ & n-siz_x\le \lfloor \frac{n-siz_u}{2}\rfloor \\ \end{aligned} \right. $$

即

$$ 2siz_v-n\le siz_u\le \min\{n-2siz_{wson},2siz_x-n\} $$

### Situation 2

然后考虑 $u\in T-T(x)-\{fa|p(x,T(fa))\}$ （即 $u$ 不在 $x$ 子树里也不是 $x$ 祖先），设 $wson$ 为 $x$ 的 $siz$ 最大的儿子。

$$ \left\{ \begin{aligned} & siz_{wson}\le \lfloor \frac{n-siz_u}{2}\rfloor \\ & n-siz_u-siz_x\le \lfloor \frac{n-siz_u}{2}\rfloor \\ \end{aligned} \right. $$

也即

$$n-2siz_x \le siz_u \le n-2siz_{wson}$$

----

此时你已经有 40pts 了。

枚举 $x$，以计算 **Situation 1** 为例，你可以将这划分为两个这样的询问：问 $dfn_u\in [dfn_x,dfn_x+siz_x-1]$ 且 $siz_u\in [1,R](R \in [1,n])$ 的 $u$ 有多少个。

这已经十分显然了，将这 $2n$ 个询问直接离线，建一棵值域树状数组，并按照 $siz_x$ 升序依次加入，查询时直接查询区间和。

对于其它的给读者留作练习。

时间复杂度 $O(n\log n)$。

----

### 代码

~~开 O2 才能过~~

```cpp
#include <cstdio>
#include <algorithm>

typedef long long ll;
ll read()
{
    ll ret = 0; char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
    return ret;
}
inline int min(int a, int b) { return a < b ? a : b; }
inline int max(int a, int b) { return a > b ? a : b; }
inline int abs(int x) { return x > 0 ? x : -x; }

const int MAXN = 700005;
int T, N; ll ans;

struct node { int v, next; } E[MAXN << 1]; int head[MAXN], Elen;
void add(int u, int v) { ++Elen, E[Elen].v = v, E[Elen].next = head[u], head[u] = Elen; }

int fa[MAXN], siz[MAXN], wson[MAXN], dfn[MAXN], dfncnt;
void dfs(int u, int ff)
{
    fa[u] = ff, siz[u] = 1, dfn[u] = ++dfncnt; int i;
    for (i = head[u]; i; i = E[i].next)
    {
        if (E[i].v == ff) continue; dfs(E[i].v, u), siz[u] += siz[E[i].v];
        if (siz[E[i].v] > siz[wson[u]]) wson[u] = E[i].v;
    }
}

struct fenwick
{
    int tree[MAXN];
    inline int lowbit(int x) { return x & -x; }
    inline void insert(int pos, int k) { for (; pos <= N; pos += lowbit(pos)) tree[pos] += k; }
    inline int query(int pos) { int ret = 0; for ( ; pos; pos -= lowbit(pos)) ret += tree[pos]; return ret; }
    void clear() { for (int i = 1; i <= N; ++i) tree[i] = 0; }
} T1, T2;

struct query
{
    int typ, val, x, k;
    query() {}
    query(int typ, int val, int x, int k) : typ(typ), val(val), x(x), k(k) {}
} Q[MAXN << 4]; int Qlen;
bool cmp(query q1, query q2) { return q1.k < q2.k; }

int mxl[MAXN], mxr[MAXN];
void qaq(int pre, int id, int ff)
{
    int sz = E[id].v == ff ? 0 : siz[E[id].v];
    mxl[id] = max(mxl[pre], sz);
    if (E[id].next) qaq(id, E[id].next, ff);
    mxr[id] = max(mxr[E[id].next], sz);
}

struct data { int x, id; } D[MAXN];
bool cmpd(data d1, data d2) { return d1.x < d2.x; }

int S[MAXN];

//int answer[MAXN];
int main()
{
    #ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin), freopen("test.out", "w", stdout);
    #endif
    scanf("%d", &T); int i, j, prej, u, v;
    while (T--)
    {
        scanf("%d", &N);
        for (i = 1; i < N; ++i) scanf("%d%d", &u, &v), add(u, v), add(v, u);
        dfs(1, 0);

        for (i = 1; i <= N; ++i)
        {
            Q[++Qlen] = query(2, i, i, 2 * siz[i]), Q[++Qlen] = query(2, -i, i, 2 * siz[wson[i]] - 1);
            qaq(0, head[i], fa[i]);
            for (j = head[i], prej = 0; j; prej = j, j = E[j].next)
            {
                if (E[j].v == fa[i]) continue;
                int maxson = max(mxl[prej], mxr[E[j].next]), v = E[j].v;
                //printf("i = %d, v = %d, maxson = %d, l = %d, r = %d\n", i, v, maxson, mxl[prej], mxr[E[j].next]);
                if (min(N - 2 * maxson, 2 * siz[i] - N) >= 2 * siz[v] - N)
                {
                    Q[++Qlen] = query(1, i, E[j].v, min(N - 2 * maxson, 2 * siz[i] - N));
                    Q[++Qlen] = query(1, -i, E[j].v, 2 * siz[v] - N - 1);
                }
            }
            Q[++Qlen] = query(3, i, N - 2 * siz[i], N - 2 * siz[wson[i]]);
            Q[++Qlen] = query(2, -i, fa[i], N - 2 * siz[wson[i]]), Q[++Qlen] = query(2, i, fa[i], N - 2 * siz[i] - 1);
            Q[++Qlen] = query(1, -i, i, N - 2 * siz[wson[i]]), Q[++Qlen] = query(1, i, i, N - 2 * siz[i] - 1);
        }

        //for (i = 1; i <= Qlen; ++i) printf("query(%d, %d, %d, %d)\n", Q[i].typ, Q[i].val, Q[i].x, Q[i].k);

        for (i = 2; i <= N; ++i) ++S[siz[i]];
        for (i = 1; i <= N; ++i) S[i] += S[i - 1];
        for (i = 1; i <= N; ++i) D[i].x = siz[i], D[i].id = i;
        std::sort(D + 1, D + N + 1, cmpd);
        std::sort(Q + 1, Q + Qlen + 1, cmp);
        j = 1;
        for (i = 1; i <= Qlen; ++i)
        {
            while (j <= N && D[j].x <= Q[i].k)
            {
                if (D[j].id != 1) T1.insert(dfn[D[j].id], 1), T2.insert(dfn[D[j].id], 1), T2.insert(dfn[D[j].id] + siz[D[j].id], -1);
                ++j;
            }
            //printf("query(%d, %d, %d, %d)\n", Q[i].typ, Q[i].val, Q[i].x, Q[i].k);

            int qaq;
            if (Q[i].typ == 3)
            {
                if (Q[i].x < 1) Q[i].x = 1;
                if (Q[i].k < 0) Q[i].k = 0;
                qaq = S[Q[i].k] - S[Q[i].x - 1];
            }
            else if (Q[i].typ == 2) qaq = T2.query(dfn[Q[i].x]);
            else qaq = T1.query(dfn[Q[i].x] + siz[Q[i].x] - 1) - T1.query(dfn[Q[i].x] - 1); 
            //printf("qaq = %d\n", qaq);
            ans += (ll)Q[i].val * qaq;
            //answer[abs(Q[i].val)] += Q[i].val * qaq;
        }
        //for (i = 1; i <= N; ++i) printf("answer[%d] = %d\n", i, answer[i] / i);

        printf("%lld\n", ans);
        T1.clear(), T2.clear();
        for (i = 1; i <= N; ++i) head[i] = S[i] = wson[i] = dfn[i] = mxl[i] = mxr[i] = 0; Elen = dfncnt = Qlen = 0;
        ans = 0;
    }
    return 0;
}
```

---

## 作者：syksykCCC (赞：10)

考场上只拿到了55pts，现在来总结一下原因

同时分享一下自己一些独特的见解，用 **旋转** 的角度来看这道题目，会发现非常的巧妙

----

$n \le 1999$，暴力 $O(Tn^2 )$

特殊性质$A$（链），重心即为中点，$O(Tn)$

特殊性质$B$（完美二叉树），树的形态已经给定，可以找规律，甚至手玩

----

那么正解呢？

考虑删去边 $<u \to v>$ ，就是求以 $u$ 为根的 **新子树** 和以 $v$ 为根的原子树的重心，也就是这样：

![pic1.png](https://i.loli.net/2019/12/01/HGkoIVbp17lzna9.png)

图中以 $v$ 为根的原子树用黄框标出，**剩下** 的是以 $u$ 为根的新子树

以 $v$ 为根的子树很好处理，就是原来的子树，而以 $u$ 为根的子树似乎换根了，怎么处理呢？

使用 `Rotate` 大法……

首先我们处于 $u$ 这个点，马上要往 $v$ 走，那么我们就处理一下删去 $<u \to v>$ 的答案

先对子树 $v$ `GetCentroid`

$u$ 这边 $u$ 自己变为了根，那么它的儿子就变成了 $\text{OriginalSons}_u -v+fa_u$

为了让 $fa_u$ 成为 $u$ 的儿子，我们将 $fa_u$ `RotateDown`

![pic2.png](https://i.loli.net/2019/12/01/bBocX6gDKsqn9P2.png)

现在是不是就成了

而且在访问 $v$ 后，$dep_v$ 也只是 $2$ ，那么我们就可以再 `RotateDown` $u$ ，使得 $v$ 成为上面的根

访问 $u$ 结束后，为了不影响其它兄弟，要把 $u$ `RotateUp` 回去

![pic3.png](https://i.loli.net/2019/12/01/ahiUw2KjLuqAc73.png)

----

姑且不说 `Rotate`，来看看 `GetCentroid` 怎么写

暴力求重心是 $O(n)$ 的树形 DP，能不能预处理一下来适应多次询问呢？

定理：
> 对于 $u$ ，如果 $n - size_u > size_v (v \in \text{Sons}_u) $  ，那么 $centroid_T$ **不在**  $u$ 的儿子们的子树里，否则，如果 $u \neq centroid_T$，那么 $centroid_T$  在 $u$ 的 **重儿子** 的子树里

![pic4.png](https://i.loli.net/2019/12/01/MwPx6kCDl4aOfy1.png)

考虑在重链上 **倍增** ，用 $f_{k, u}$ 表示从 $u$ 开始，沿着以 $u$ 为根的 **重链** 的方向走 $2^k$ 所到的点，跳到最深的那个满足 $size_u - size_{f_{k,u}}  \le \left\lfloor \frac{size_u}{2}\right\rfloor $ 的，那么 **它** 和 **它的父亲** 就成为了重心的 **候选点**，$O(1)$ `check` 一下，计算贡献

这个部分是 $O(\log n)$ 的

----

`RotateDown` 的时候要更新什么呢？

* $NewSize_u \gets n - size_v$
* $NewSize_v \gets size_v$
* $NewFather_u \gets 0, NewFather_v \gets 0$
* $NewFather_{fa_u}\gets u$
* $NewMaxSon_u \gets \begin{cases} TheFirstBiggestSon_u & (v \neq TheFirstBiggestSon_u)\\ TheSecondBiggestSon_u & (v = TheFirstBiggestSon_u) \\ fa_u &(NewSize_{fa_u} > NewSize_{ ^{(Now)} NewMaxSon_u)} \end{cases}$
* $O(\log n)$ 更新 $f_{k,u }$

`RotateUp` 的时候又要更新什么呢？
* 还好，这次 **恢复原状** 就可以了……

---

总时间复杂度 $O(n \log n)$

代码就不给出了，可以参考其它巨佬们的题解，请注意常数优化

---

## 作者：EndSaH (赞：8)

[更佳阅读体验](http://endsah.tk/blog/CSP2019-S-Solution/)

下面用 $son(x)$ 表示 $x$ 的重儿子，$s _x$ 表示 $x$ 子树大小。特别的，对叶子定义其 $son(x) = 0$，且 $s _0 = 0$，减少特判。

考虑到三个重要结论：

1. 一棵树任意定根，重心一定在根节点所在的重链上。
2. 两个重心一定相邻。
3. 点 $u$ 满足 $s _u \ge \lceil \frac n 2 \rceil, s _{son(u)} \le \lfloor \frac n 2 \rfloor$，是其为重心的充要条件。

第一个结论要想到也不难，随手画一下重剖的图会发现这看上去就很对。第二个是常识。第三个实际上就是「其分裂出来的树均不超过 $\lfloor \frac n 2 \rfloor$」的另一说法。

由于第二个的存在，只需要求出深度较深的重心，$O(1)$ 地检查一下他的父亲即可统计好答案。

把问题的求解分为两个部分。同时为了简化讨论，默认以原树的某个重心为根。

### 子树内

把树重剖一下。

首先，叶子的重心肯定是他自己；从重链往上爬，容易知道其重心也会随着节点的上移而上移。暴力的把重儿子的重心向上调整即可，总复杂度 $O(n)$（因为每个重心都是在对应的重链上爬，路径不交）。

### 子树外

真正需要注意的是这一部分。

仍然考虑到「重心在根节点的重链上」这个结论，显然删除轻儿子子树内的部分点不会使根节点的重链变化。那么预处理出 $g(x)$ 表示若整个树删掉了 $x$ 大小的子树之后，重心会在这个重链的哪个位置；容易知道随着 $x$ 的减小，重心的位置会逐渐上移，直接 $O(n)$ 地处理出 $g$ 后遍历所有轻儿子统计答案即可。

再考虑删去重儿子子树内某一部分。由于**以原树重心为根**，所以如果删掉 $x$ 大小的子树之后重儿子仍然是重儿子，那么重心肯定是根（不可能删掉一部分之后重心还向该树内部移动）。若删掉之后原本的次重儿子取而代之，那么会变成和上面一样的问题，同样对次重儿子预处理出 $g$ 求答案。

总复杂度 $O(n)$，注意要时刻判断另一个重心的存在。

### 另一种思路

以上思路都是基于「考虑删掉一个子树，重心会如何变化」的；实际上也可以考虑「有多少个子树满足删掉之后，剩下的树以我为根」。

同样以重心为根。设删去的子树大小为 $S$，考虑一个非根节点 $u$ 作为重心时是什么情况：

$$
\begin{aligned}
s _u \ge \lceil \frac {n - S} 2 \rceil, s _{son(u)} \le \lfloor \frac {n - S} 2 \rfloor \\
\Rightarrow n - 2 s _u \le S \le n - 2 s _{son(u)}
\end{aligned}
$$

实际上漏了一个额外条件：删除的点不能位于其子树内。所以先做一遍全局的，统计出有多少个满足条件的 $S$；再 DFS 一遍，访问到一个节点时记录一个值，遍历完子树之后再用现在值减去之前的值，即可得到子树内的影响，用全局值减去即可。

再考虑根。这里的不同是删去重儿子的部分子树时重儿子可能变化，所以分重儿子和轻儿子求解即可。

用树状数组维护上述过程，复杂度 $O(n \log n)$。

---

## 作者：command_block (赞：8)

考场上一眼就想到了做法的核心部分OvO,但是记错结论被带偏了……

这是一个连倍增都不用写的做法,只需要两次`dfs`和暴力跳重心。复杂度分析需要链分治思想。

**题意** : 给出一棵树,求出切断每条边之后,所得到的两棵树的重心编号和。

$n\leq 3\times 10^5$, 多($5$)组数据,时限$\texttt{4s}$.

------------

首先这个切边的枚举顺序显然是可以随意的,我们考虑类似**换根DP**的套路。

我们把切断的位置做根,在切换一条边之后,考虑如下的情况:

```cpp
u,v为当前重心

    *- | -*-----*
   /     /_\     \
  /               \
 u                 v
/_\               /_\

变作↓

    *----*- | -*
   /    /_\     \
  /              \
 u                v
/_\              /_\
```

容易看出 $u$ 到根的联通块大小增加了, $v$ 到根的联通块大小减少了。

容易换根维护子树大小。到根的联通块大小$=$总大小$-$子树大小。

某次更新之后, $u,v$ 点可能会进行相应的移动。

$v$ 点到根的联通块大小减小了,可能会换成某个儿子,对儿子 $siz$ 取 $\max$ 比较即可。

然而,不能每次暴力取 $\max$ ,否则会被菊花卡爆,由于儿子的 $\max$ 不受换根影响,可以预先存着。

对于 $u$ ,由于到根的联通块大小增大了,可能向上走,同样也是判一下就好了。 $u$ 是有可能先向上后向下的。

注意以上操作都有可能重复若干次,还有双重心的情况。

一次调整的代码是这样的 : 

- 定理 : 重心满足所有的子树大小不超过 $\lfloor p/2\rfloor$

```cpp
p[u] : 重儿子
f[u] : 父亲
siz[u] : 子树大小
void upd(int &u,int c)
{
  while (siz[u]*2<c)u=f[u];
  while (siz[p[u]]*2>c)u=p[u];
  if (siz[p[u]]*2==c)ans+=p[u];
  if (siz[u]*2==c)ans+=f[u];
  ans+=u;
}
```

我们要在换根中维护重儿子,看似取 $\max$ 难以撤销贡献,但这是有一个技巧的,记录最大值和次大值即可。(具体见代码)

此外还有一些细节,如果原来的重心如下图:

```cpp
u,v为当前重心

    *- | -*-----*
   /      |    /_\
  /       v       
 u       /_\       
/_\               

变作↓

    *-----*- | -*
   /      |    /_\
  /       v       
 u       /_\       
/_\   
```

这样, $u,v$ 就在分割线同侧了,显然不合法。

容易想到令 $v$ 强制跳到分割线另一端,但是会发现 `TLE:75`。

考虑类似静态链分治的套路,对 $t$ 的儿子分割的时候:

对于轻儿子,我们可以暴力跳 $v$。

对于重儿子,有如下几种情况:

- $v$ 本身就在其子树中 : 无需操作。

- $v$ 恰好在 $t$ 处 : 暴力跳,只会移动一位。

- $v$ 在 $t$ 的祖先处 : 根据分割线的定义这种情况不存在。

- $v$ 在其他子树中 : 根据重心的定义,不存在。

我们来计算复杂度。

对于分割线上方 $u$ 的移动,容易感知是 $O(n)$ 次的,因为分割线移动时带来的 $siz$ 变化总量是 $O(n)$ 的。

对于轻儿子,暴力跳 $v$ 最差只会是 $O(siz)$ 的。

这部分的复杂度就是所有轻链头 $siz$ 的和,即为 $O(n\log n)$。

对于重儿子,由于继承了(重链)祖先的方案,而且只会单调下移,复杂度是 $O(n)$ 的。

如果把细节考虑清楚了,写起来就是个换根,没别的。

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#define ll long long
#define MaxN 300500
using namespace std;
int read(){
  int X=0;char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
vector<int> g[MaxN];
int siz[MaxN],p[MaxN],f[MaxN];
void pfs(int u)
{
  siz[u]=1;
  for (int i=0,v;i<g[u].size();i++)
    if (!siz[v=g[u][i]]){
      f[v]=u;pfs(v);
      siz[u]+=siz[v];
    }
  p[u]=0;
  for (int i=0,v;i<g[u].size();i++)
    if ((v=g[u][i])!=f[u]&&siz[v]>=siz[p[u]])
      p[u]=v;
}
ll ans;
void upd(int &u,int c)
{
  while (siz[u]*2<c)u=f[u];
  while (siz[p[u]]*2>c)u=p[u];
  if (siz[p[u]]*2==c)ans+=p[u];
  if (siz[u]*2==c)ans+=f[u];
  ans+=u;
}
int n,u1,u2,c1,c2;
void dfs(int u,int fa)
{
  upd(u1,c1);upd(u2,c2);
  if (!p[u])return ;

  f[f[fa]=u]=0;
  siz[u]+=siz[fa];
  int p1=0,p2=0,v,sp=p[u];
  
    for (int i=0;i<g[u].size();i++){
      v=g[u][i];
      if (siz[v]>=siz[p1]){p2=p1;p1=v;}
      else if (siz[v]>siz[p2])p2=v;
    }
    siz[u]-=siz[v=sp];
      if (p1==v)p[u]=p2;else p[u]=p1;
      c1=siz[u];c2=siz[v];
      if (u2==u)u2=v;
      dfs(v,u);
    siz[u]+=siz[v];
    
    int s1=u1,s2=u2;
    for (int i=0;i<g[u].size();i++)
      if ((v=g[u][i])!=fa&&v!=sp){
        siz[u]-=siz[v];
          if (p1==v)p[u]=p2;else p[u]=p1;
          c1=siz[u];c2=siz[v];
          dfs(u2=v,u);
        siz[u]+=siz[v];
      }
  siz[u]-=siz[fa];
  f[f[u]=fa]=0;
  p[u]=sp;
}
void solve()
{
  n=read();ans=0;
  for (int i=1;i<=n;i++)
    {g[i].clear();siz[i]=0;}
  for (int i=1,f,t;i<n;i++){
    f=read();t=read();
    g[f].push_back(t);
    g[t].push_back(f);
  }for (int i=1;i<=n;i++)
    if (g[i].size()==1)u1=i;
  c1=1;c2=n-1;
  f[u2=g[u1][0]]=0;pfs(u2);
  siz[u2]--;if (p[u2]==u1)p[u2]=0;
  upd(u2,c2);ans=0;
  dfs(g[u1][0],u1);
  printf("%lld\n",ans);
}
int main()
{
  freopen("centroid.in","r",stdin);
  freopen("centroid.out","w",stdout);
  int T=read();
  while(T--)solve();
  return 0;
}
```

---

## 作者：rainygame (赞：6)

第二篇题解的思路很好，但是过于简略了。

树的重心有一个性质：对于以 $u$ 为根的一颗子树，如果 $u$ 不是子树的重心，那么重心一定在 $u$ 的重儿子里面。**所以重心的方向是可以完全地确定的。**

然后就类似 LCA，我们可以设 $p_{i,k}$ 表示 $i$ 沿着重儿子一直往下走了 $2^k$ 次到达的结点。对于一颗子树，我们可以用 $p$ 来在 $O(\log n)$ 的时间复杂度内求出它的重心。具体地，我们在倍增的过程中，可以找到一个最深的重儿子 $v$，使得 $s_v \ge \lceil\frac{s_u}{2}\rceil$。那么 $v$ 和它的父亲都是重心的“候选结点”，判断并更新答案即可。

关于实现，可以通过换根的方式，维护换根后每个结点的子树大小、父亲、重儿子。

时间复杂度 $O(n \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 300000
#define MAXK 19
#define judge(x, sum) (x) * (max(siz2[son3[x]], (sum)-siz2[x]) <= (sum >> 1))  // 判断是否为重心

int t, n, u, v;
int fa[MAXN], fa2[MAXN];  // 父亲
int siz[MAXN], siz2[MAXN];  // 子树大小
int son[MAXN], son2[MAXN], son3[MAXN];  // 重儿子、次重儿子
int p[MAXN][MAXK];
list<int> e[MAXN];
long long ans;

void clear(){
    ans = 0;
    memset(son, 0, sizeof(son));
    memset(p, 0, sizeof(p));
    for (int i(1); i<=n; ++i) e[i].clear();
}

void dfs1(int x, int f){
    siz[x] = 1;
    fa[x] = f;
    for (auto i: e[x]){
        if (i ^ f){
            dfs1(i, x);
            siz[x] += siz[i];
            if (siz[son[x]] < siz[i]){
                son2[x] = son[x];
                son[x] = i;
            }else if (siz[son2[x]] < siz[i]) son2[x] = i;
        }
    }
    p[x][0] = son[x];
    for (int i(1); i<MAXK; ++i) p[x][i] = p[p[x][i-1]][i-1];
}

void dfs2(int x){
    for (auto i: e[x]){
        if (i ^ fa[x]){
            siz2[x] = n - siz[i];
            fa2[x] = fa2[i] = 0;
            son3[x] = (son[x] == i ? son2[x] : son[x]);
            if (siz2[fa[x]] > siz2[son3[x]]) son3[x] = fa[x];

            p[x][0] = son3[x];
            for (int j(1); j<MAXK; ++j) p[x][j] = p[p[x][j-1]][j-1];

            int tmp(x);  // 求出 x 的重心
            for (int j(MAXK-1); j>=0; --j){
                if (siz2[p[tmp][j]] >= ((siz2[x]+1) >> 1)) tmp = p[tmp][j];
            }
            ans += judge(tmp, siz2[x]) + judge(fa2[tmp], siz2[x]);

            tmp = i;  // 求出 i 的重心
            for (int j(MAXK-1); j>=0; --j){
                if (siz2[p[tmp][j]] >= ((siz2[i]+1) >> 1)) tmp = p[tmp][j];
            }
            ans += judge(tmp, siz2[i]) + judge(fa2[tmp], siz2[i]);
            fa2[x] = i;
            dfs2(i);
        }
    }
    son3[x] = p[x][0] = son[x];
    for (int i(1); i<MAXK; ++i) p[x][i] = p[p[x][i-1]][i-1];
    fa2[x] = fa[x];
    siz2[x] = siz[x];
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> t;
    while (t--){
        cin >> n;
        clear();
        for (int i(1); i<n; ++i){
            cin >> u >> v;
            e[u].push_back(v);
            e[v].push_back(u);
        }
        dfs1(1, 0);

        memcpy(siz2, siz, sizeof(siz));
        memcpy(son3, son, sizeof(son));
        memcpy(fa2, fa, sizeof(fa2));
        dfs2(1);

        cout << ans << '\n';
    }

    return 0;
}

```


---

## 作者：LCuter (赞：5)

### $\text{D2T3}$  树的重心

#####  $\text{Descripton}$

给定一棵树，求出删除每一条边后分裂出的两个子树的重心编号和。

##### $\text{Solution}$

考虑一个最显然的暴力，枚举删除的边，暴力求两个子树的重心，这样是 $O(n^2)$ 的。

上面的做法可以通过倍增优化至 $O(n\log n)$，但我太菜了不会。

考虑求每个点对答案的贡献。

我们先以原树的一个重心为根，这样可以有比较好的性质。

记 $x$ 为我们当前考虑贡献的节点，$s_i$ 表示以 $i$ 为根的子树大小，$S$ 为删边后不包含 $x$ 的新树，$g_i$ 表示以 $i$ 的重儿子为根的子树大小。

先考虑 $x$ 不是根的情况。

我们发现，若要使 $x$ 成为重心，删的边不可能在 $x$ 的子树里。为什么？考虑删除根（注意是重心）后 $x$ 所在的子树大小不超过 $\lfloor\dfrac{n}{2}\rfloor$，故其它子树大小的和至少是 $\lfloor\dfrac{n}{2}\rfloor$，发现其它子树会和根一起作为 $x$ 所在的新树中 $x$ 的一棵子树，显然它的大小超过了新树大小的一半，不符合定义。

根据重心的定义，还可以有：

$$g_x\le \lfloor\dfrac{n-S}{2}\rfloor$$

$$n-s_x-S\le \lfloor\dfrac{n-S}{2}\rfloor$$

事实上由于整除的性质，我们整理得到：

$$n-2s_x\le S \le n-2g_x$$

从而将问题转换为了，找到这个范围内 $S$ 的个数，同时满足删边不在 $x$ 的子树内。考虑求出满足前者的个数，然后减去满足前者但不满足后者的个数。满足前者的个数，实际上只需开一个权值树状数组，动态维护**对于** $x$ **来说** 的 $S$ 值。为什么这么说呢？因为同样是删除一条边，对于这条边以下的点，它们的 $S$ 实际上是包含根节点的新树，对于其它的点，他们的 $S$ 实际上是不包含根节点的新树。在深搜过程中，一个节点处理完马上就是它的子树内的点，利用这个去动态维护就好。

然后考虑满足前者但不满足后者的个数。线段树合并固然可做，但是引用某队爷的话：

> 用线段树合并小题大作了吧。

嗯，考虑到刚进入一个节点和准备离开这个节点时，我们多处理了以这个点为根的子树的信息，利用这个作差即可，考虑到我们只要删的边在 $x$ 的子树内，故 $S$ 实际上只能是不包含根节点的新树，这就十分简单了。

还有 $x$ 为根的情况没有解决呢。发现我们只需注意根的重儿子 $u$ 和次重儿子 $v$，考虑以下两种情况：

若删除的边不在以 $u$ 为根的子树中，那么只需满足（此处借由上文整除的性质并且整理过式子）：

$$S\le n-2s_u$$

若删除的边在以 $u$ 为根的子树中，考虑两条限制：

 $$2s_u-n\le S\le n-2s_v$$

注意到前面是个负数，无意义，那么其实就是：

$$S\le n-2s_v$$

这些可以把每个点枚举过去解决。

##### $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
#define MAXN 300005
#define LL long long
#define FORE(i,now) for(REG int i=head[now];i;i=ed[i].nxt)
using namespace std;
inline int read(){
    REG int x(0);
    REG char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x*10)+(c^48),c=getchar();
    return x;
} 
inline void Swap(int& a,int& b){int t=a;a=b,b=t;}

int T,n;
struct Edge{
    int v,nxt;
}ed[MAXN<<1];
int head[MAXN],cnt;
inline void adde(int u,int v){
    ed[++cnt]=(Edge){v,head[u]};
    head[u]=cnt;
}
inline void add(int u,int v){
    adde(u,v),adde(v,u);
}

int s[MAXN],g[MAXN],Dir[MAXN],rt,Fir,Sec;
LL ans;

struct t{
    int c[MAXN];
    inline void Clear(){memset(c,0,sizeof c);}
    inline void Upd(int pos,int k){++pos;for(;pos<=n+1;pos+=pos&-pos)c[pos]+=k;}
    inline int Ask(int pos){++pos;int ans=0;for(;pos;pos-=pos&-pos)ans+=c[pos];return ans;}
}c1,c2;

void Find_rt(int now,int fa){
    s[now]=1,g[now]=0;
    FORE(i,now){
        int v=ed[i].v;
        if(v==fa) continue;
        Find_rt(v,now);
        s[now]+=s[v];
        if(s[v]>g[now]) g[now]=s[v];
    }
    if(g[now]<=(n>>1)&&n-s[now]<=(n>>1)) rt=now;
}

void ReBuild(int now,int fa){
    s[now]=1,g[now]=0;
    FORE(i,now){
        int v=ed[i].v;
        if(v==fa) continue;
        ReBuild(v,now);
        s[now]+=s[v];
        if(s[v]>g[now]) g[now]=s[v];
    }
}

void Solve(int now,int fa){
    c1.Upd(s[now],-1),c1.Upd(n-s[now],1),c2.Upd(s[now],1);
    Dir[now]|=Dir[fa];
    if(now^rt){
        ans+=(LL)now*(c1.Ask(n-2*g[now])-c1.Ask(n-2*s[now]-1));
        ans+=(LL)now*(c2.Ask(n-2*g[now])-c2.Ask(n-2*s[now]-1));
        ans+=(LL)rt*(s[now]<=n-2*s[Dir[now]?Sec:Fir]);
    }
    FORE(i,now){
        int v=ed[i].v;
        if(v==fa) continue;
        Solve(v,now);
    }
    if(now^rt)
        ans-=(LL)now*(c2.Ask(n-2*g[now])-c2.Ask(n-2*s[now]-1));
    c1.Upd(s[now],1),c1.Upd(n-s[now],-1);
    
}

void Init(){
    memset(head,0,sizeof head);
    memset(Dir,0,sizeof Dir);
    cnt=0;
    c1.Clear(),c2.Clear();
    Fir=Sec=ans=0;
    n=read();
    for(REG int i=1;i<n;++i) add(read(),read());
    Find_rt(1,0);
    ReBuild(rt,0);
    FORE(i,rt){
        int v=ed[i].v;
        if(s[v]>s[Sec]) Sec=v;
        if(s[Sec]>s[Fir]) Swap(Fir,Sec);
    }
    for(REG int i=1;i<=n;++i) c1.Upd(s[i],1);
    Dir[Fir]=1;
    Solve(rt,0);
}

int main(){
    T=read();
    while(T--){
        Init();
        printf("%lld\n",ans);
    }
}
```

---

## 作者：OIerror (赞：2)

>为什么我的测试点里常含 TLE?
>
>因为我对 OI 爱的深沉。

[传送门](https://www.luogu.com.cn/problem/P5666)

引理一：一个节点为重心，当且仅当以这个节点为根时，各个子树大小均小于或等于 $\frac{n}{2}$（$n$ 为奇数）。

引理二：一个节点的重心，一定在这个节点的重链上。

## 思路
根据引理二，显然可以倍增跳重心，同时根据引理一，判断一个节点是否是重心，可以不用判断所有儿子，只需判断其重儿子及除当前节点及其子树外的节点数量是否满足条件即可。注意倍增终点的父亲也可能是重心，需特判。
```
int query(int now,int u)
{
	for(int i=19; i>=0; i--)
	{
		if(f[now][i]&&sz[u]-sz[f[now][i]]<=sz[u]/2)
		{
			now=f[now][i];
		}
	}
	return now;
}//这里没有特判父亲，会在dfs函数里特判
```

但是如下图所示：
![树的重心](https://cdn.luogu.com.cn/upload/image_hosting/us1ggkhw.png)

当我们割掉 $(u,v)$ 这条边时（$u=1,v=2$），$v$ 的子树可以正常跳，但是我们发现，$u$ 的重儿子被调包了啊！

我们注意到被割掉的 $v$ 仅仅是 $u$ 的一个子树，所以我们可以同时记录次重儿子，当重儿子被割掉时，用次重儿子顶替，同时更新倍增数组。但是如果我们每次都完整更新，复杂度显然萎掉。我们注意到其实大多数数据（$u$ 的子树）都是没有变动的，且 $u$ 的所有祖先显然是和这次倍增无关的，所以只需更新 $u$ 的倍增数组即可。
```
void update(int u)
{
	for(int t=1; t<=19; t++)
	{
		f[u][t]=f[f[u][t-1]][t-1];
	}
}
```
最后别忘了还原数据。
## AC Code
```
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
int T;
int n;
int all_sz;
long long ans;
int f[300001][20],second_wc[300001],temp_sz[300001],sz[300001],father[300001];
vector<int>g[300001];
void clear()
{
	for(int i=1; i<=n; i++)
	{
		g[i].clear();
		second_wc[i]=0;
		temp_sz[i]=0;
		sz[i]=0;
		father[i]=0;
		for(int t=0; t<=19; t++)
		{
			f[i][t]=0;
		}
	}
}
void init()
{
	for(int t=1; t<=19; t++)
	{
		for(int i=1; i<=n; i++)
		{
			f[i][t]=f[f[i][t-1]][t-1];
		}
	}
}
void update(int u)
{
	for(int t=1; t<=19; t++)
	{
		f[u][t]=f[f[u][t-1]][t-1];
	}
}
int query(int now,int u)
{
	for(int i=19; i>=0; i--)
	{
		if(f[now][i]&&sz[u]-sz[f[now][i]]<=sz[u]/2)
		{
			now=f[now][i];
		}
	}
	return now;
}
bool check(int u,int all)
{
	return max(sz[f[u][0]],all-sz[u])<=all/2;
}
void dfs1(int u,int fa)
{
	temp_sz[u]=1;
	father[u]=fa;
	for(int i=0; i<g[u].size(); i++)
	{
		int v=g[u][i];
		if(v!=fa)
		{
			dfs1(v,u);
			temp_sz[u]+=temp_sz[v];
			if(temp_sz[v]>temp_sz[f[u][0]])
			{
				second_wc[u]=f[u][0];
				f[u][0]=v;
			}
			else if(temp_sz[v]>temp_sz[second_wc[u]])
			{
				second_wc[u]=v;
			}
		}
	}
	sz[u]=temp_sz[u];
}
void dfs2(int u,int fa)
{
	int now;
	int WC=f[u][0];
	for(int i=0; i<g[u].size(); i++)
	{
		int v=g[u][i];
		if(v!=fa)
		{
			if(v==WC)
			{
				f[u][0]=second_wc[u];
			}
			else
			{
				f[u][0]=WC;
			}
			if(sz[fa]>sz[f[u][0]])
			{
				f[u][0]=fa;
			}
			update(u);
			now=u;
			sz[u]=all_sz-temp_sz[v];
			sz[v]=temp_sz[v];
			father[u]=father[v]=0;
			now=query(u,u);
			ans+=check(now,sz[u])*now+check(father[now],sz[u])*father[now];
			now=v;
			now=query(v,v);	
			ans+=check(now,sz[v])*now+check(father[now],sz[v])*father[now];
			father[u]=v;
			dfs2(v,u);
		}
	}
	f[u][0]=WC;
	sz[u]=temp_sz[u];
	father[u]=fa;
	update(u);
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		clear();
		scanf("%d",&n);
		for(int i=1; i<=n-1; i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			g[u].push_back(v);
			g[v].push_back(u);
		}
		ans=0;
		dfs1(1,0);
		init();
		all_sz=sz[1];
		dfs2(1,0);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Lvlinxi2010 (赞：1)

题意其实很简洁明了，求依次单独删去每条边后，分裂出的两个子树的重心编号和之和。

我们考虑求每个点成为重心的次数。

首先重心有这样一个结论：

> 以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。

那我们先把这颗树的重心拎出来作为根，记为 $rt$，我们想让它成为新树的重心的点记为 $u$。

我们先讨论 $u\ne rt$ 的情况。

我们发现一个点 $u$ 如果想作为割掉某条边后新树的重心，那这条割掉的边一定不能在 $u$ 的子树内，因为 $(n-siz_u)\ge \left\lfloor\frac{n}{2}\right\rfloor$，如果割掉 $u$ 子树内的边一定会导致 $n-siz_u$ 大于新树大小的一半。

那我们考虑被分裂出去的树需要满足什么条件。

设它的大小为 $S$，因为 $u$ 是重心所以 $(n-siz_u-S)\le\frac{n-S}{2}$，解得 $S\ge n-2siz_u$。

我们还要考虑 $u$ 本身的儿子的大小满不满足，设 $mx_u$ 表示 $u$ 最重的儿子的大小，那么有 $mx_u\le \frac{n-S}{2}$，解得 $S\le n-2mx_u$。

那么这个问题就转化为：

> 求每个节点 $u$ 的子树外，有多少棵分裂出来的树的大小满足：$n-2*siz_u\le S \le n-2mx_u$。

首先树的大小很好维护，用树状数组即可，但是子树外要怎么维护呢？我们在 dfs 遍历 $u$ 的子树之前记录一次答案，遍历后再记录一次答案，减去两次答案的差即可。

我们再讨论 $u = rt$ 的情况。

我们设 $mx1$ 表示 $u$ 最重的儿子，那分裂出的树大小  $S$ 就要满足 $siz_{mx1}\le\frac{n-S}{2}$，解得 $S\le n-2siz_{mx1}$。

那如果割掉的边在 $mx1$ 的子树中呢？我们再维护一个次大值 $mx2$，这时 $S$ 就要满足 $siz_{mx2}\le\frac{n-S}{2}$，解得 $S\le n-2siz_{mx2}$。

我们维护 $val_u$ 表示 $u$ 是否在 $mx1$ 的子树里，遍历时看 $siz_u$ 是否满足条件即可。

附上代码：


```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const int MAXN = 3e5 + 10;
/*
(n-siz[u]-siz[y])<=(n-siz[y])/2
(n-siz[y])/2<=siz[u]
siz[y]>=n-2*siz[u]
mxson[u]<=(n-siz[y])/2
siz[y]<=n-2*mxson[u]
求每个节点u的子树外，有多少个子树y满足： 
n-2*siz[u]<=siz[y]<=n-2*mxson[u]
dfs作差 
*/
int n,rt=0,mx1=0,mx2=0;
ll ans=0;
int siz[MAXN],mx[MAXN];
bool val[MAXN];//记录这个点是不是在rt最大的子树里 
vector<int>G[MAXN];
struct BIT{
	#define lowbit(x) x&(-x)
	ll c[MAXN];
	void init(){
		memset(c,0,sizeof(c));
	}
	void update(int x,ll k){
		if(x<=0) return ;
		while(x<=n){
			c[x]+=k;
			x+=lowbit(x);
		}
	}
	ll query(int x){
		if(x<=0) return 0;
		ll res=0;
		while(x){
			res+=c[x];
			x-=lowbit(x);
		}
		return res;
	}
}T1,T2;
//T1 全局计算答案，T2 dfs作差减掉子树内的答案 
void dfs(int u,int fa){
	siz[u]=1,mx[u]=0;
	for(int v:G[u]){
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		mx[u]=max(mx[u],siz[v]);
	}
	if(max(mx[u],n-siz[u])<=n/2) rt=u;
}
void dfs2(int u,int fa){
	T1.update(siz[fa],-1);
	T1.update(n-siz[u],1);
	val[u]|=val[fa];
	if(u!=rt){
		ans+=1ll*u*T1.query(n-2*mx[u]);
		ans-=1ll*u*T1.query(n-2*siz[u]-1);
		//遍历子树之前的答案，提前加上 
		ans+=1ll*u*T2.query(n-2*mx[u]);
		ans-=1ll*u*T2.query(n-2*siz[u]-1);
		ans+=1ll*rt*(siz[u]<=n-2*siz[(val[u]?mx2:mx1)]);
	}
	T2.update(siz[u],1);
	for(int v:G[u]){
		if(v==fa) continue;
		dfs2(v,u);
	}
	T1.update(siz[fa],1);
	T1.update(n-siz[u],-1);
	if(u!=rt){
		//遍历子树之后的答案，作差就减去了在u子树内满足大小要求的答案 
		ans-=1ll*u*T2.query(n-2*mx[u]);
		ans+=1ll*u*T2.query(n-2*siz[u]-1);
	}
} 
int main(){
	int Q;
	scanf("%d",&Q);
	while(Q--){
		scanf("%d",&n);
		FL(i,1,n) G[i].clear();
		T1.init(),T2.init();
		memset(val,0,sizeof(val));
		FL(i,1,n-1){
			int u,v;
			scanf("%d%d",&u,&v);
			G[u].push_back(v);
			G[v].push_back(u);
		}
		dfs(1,0);
		dfs(rt,0);
		mx1=mx2=ans=0;
		for(int v:G[rt]){
			if(siz[v]>siz[mx1]) mx2=mx1,mx1=v;
			else if(siz[v]>siz[mx2]) mx2=v;
		}
		FL(i,1,n) T1.update(siz[i],1);
		val[mx1]=1;
		dfs2(rt,0);
		printf("%lld\n",ans);
	}
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P5666)

---

# 思路：
神奇的清真树论。

首先这里有一步很妙的操作：把整棵树的重心 $rt$ 设为根。

答案可以转化成考虑每个结点的贡献，即询问有多少条边删去以后可以使 $rt$ 以外的结点 $x$ 成为重心。

显然删去的这条边不能在 $x$ 的子树内。

设 $s_u$ 为结点 $u$ 的子树大小，$g_u = \max\limits_{v \in son(u)} s_v$，其中 $son(u)$ 表示结点 $u$ 的所有子结点。根据重心的定义，令删去这条边以后另一侧的子树大小为 $S$，则 $S$ 应该满足：$2(n - S - s_x) \leq n - S, 2 g_x \leq n - S$。

如果不考虑在子树外的限制，这里可以在 ```dfs``` 的同时用树状数组维护 $S$ 的取值个数，问题转化成单点加区间求和。

对于子树外的限制。可以另外维护一个树状数组记录下所有经过的结点中 $S$ 的取值，这样回溯的时候容斥一下就行。

考虑重心的贡献。设 $u,v$ 分别是 $rt$ 的子结点中 $s$ 最大和次大的子结点。如果删去的边在 $u$ 的子树内，则要满足 $2 s_v \leq n - S$，反之要满足 $2 s_u \leq n - S$，dfs 的时候顺便查询一下就行。

时间复杂度 $O(nlogn)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int t,n,rt,u,v,head[N],sz[N],mx[N],ans;
bool vis[N];
vector<int> g[N];
struct node{
    int to,nxt;
}edge[N];
struct BIT{
    int c[N];
    void clear(){ 
        memset(c,0,(n + 2)*sizeof(int)); 
    }
    int lowbit(int x){ 
        return x&(-x);
    }
    void update(int p,int w){ 
        p++; 
        for(int i=p;i<=n+1;i+=lowbit(i)){
            c[i]+=w; 
        }
    }
    int query(int p){
        int res=0;
        p++;
        for(int i=p;i;i-=lowbit(i)){
            res+=c[i];
        }
        return res;
    }
}c1,c2;
void dfs1(int x,int f){
    bool is_rt=true;
    sz[x]=1;
    mx[x]=0;
    for(int y:g[x]){
        if(y==f){
            continue;
        }
        dfs1(y,x);
        sz[x]+=sz[y];
        mx[x]=max(mx[x],sz[y]);
        if(sz[y]>(n>>1)){
            is_rt=false;
        }
    }
    if(n-sz[x]>(n>>1)){
        is_rt=false;
    }
    if(is_rt){
        rt=x;
    }
}
void dfs2(int x,int f){
    c1.update(sz[f],-1);
    c1.update(n-sz[x],1);
    vis[x]|=vis[f];
    if(x!=rt){
        ans+=1ll*x*c1.query(n-2*mx[x]);
        ans-=1ll*x*c1.query(n-2*sz[x]-1);
        ans+=1ll*x*c2.query(n-2*mx[x]);
        ans-=1ll*x*c2.query(n-2*sz[x]-1);
        ans+=1ll*rt*(int)(sz[x]<=n-2*sz[vis[x]?v:u]);
    }
    c2.update(sz[x],1);
    for(int y:g[x]){
        if(y==f){
            continue;
        }
        dfs2(y,x);
    }
    c1.update(sz[f],1);
    c1.update(n-sz[x],-1);
    if(x!=rt){
        ans-=1ll*x*c2.query(n-2*mx[x]);
        ans+=1ll*x*c2.query(n-2*sz[x]-1);
    }
}
signed main(){
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++){
            g[i].clear();
        }
        for(int i=1,u,v;i<=n-1;i++){
            cin>>u>>v;
            g[u].push_back(v);
            g[v].push_back(u);
        }
        ans=0ll;
        dfs1(1,0);
        dfs1(rt,0);
        u=v=0;
        for(int x:g[rt]){
            if(sz[x]>sz[v]){
                v=x;
            }
            if(sz[v]>sz[u]){
                swap(u,v);
            }
        }
        c1.clear();
        c2.clear();
        for(int i=0;i<=n;i++){
            c1.update(sz[i],1);
            vis[i]=false;
        }
        vis[u]=true;
        dfs2(rt,0);
        cout<<ans<<endl;
    }
    return 0;
}
```
完结撒花~

---


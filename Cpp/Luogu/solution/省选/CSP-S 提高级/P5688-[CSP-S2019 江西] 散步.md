# [CSP-S2019 江西] 散步

## 题目背景

JXCSP-S T4

## 题目描述

公园内有 $n$ 个人正在散步，随着天色渐晚，所有人准备回家离开公园。公园的结构是一个首尾相连的环形图，它共有 $m$ 个出口，为了方便叙述，我们将人从 $1\sim n$ 编号，将出口按逆时针顺序从 $1\sim m$ 编号。

公园总长 $L$ 米，我们令 $1$ 号出口所在的位置为 $0$ 米，则 编号为 $i\ (2\le i\le m)$ 的出口在 $1$ 号出口逆时针方向 $a_i$ 米的位置上，其中 $a_i$ 严格递增 ，即 $i\ (1\le i < m)$ 号出口与 $i+1$ 号出口相邻，由于公园是环形图，故 $m$ 号出口与 $1$ 号出口也相邻。每个出口还有一个通行限制 $l_i$，表示最多有 $l_i$ 个人能从 $i$ 号出口离开。

所有人回家时将按自己的朝向，可能是顺时针方向，也可能是逆时针方向不断前行，当他们走到一个还能离开的出口时，将从该出口离开公园。特别地，当两个人同时走到一个只能允许 $1$ 个人离开的出口时，编号小的那个人能从该出口离开，编号较大的人将继续前进。

现在给定 $n$ 个人所在的起始位置与他们的前进方向，请你求出每个人从哪个出口离开，若编号为 $i$ 的 人从 $k_i$ 号出口离开，你只需要给出 $i\times k_i$ 的异或和，即：

$$ (1\times k_1) \operatorname{xor} (2\times k_2) \operatorname{xor}\cdots \operatorname{xor} (n\times k_n) $$

其中 $\operatorname{xor}$ 是位异或运算。特别地若一个人最后无法离开，则他的 $k_i = 0$。

## 说明/提示

#### 【输入输出样例 1 说明】
编号为 $1 ,2, 3$ 的人分别从 $2, 1, 1$ 号出口离开。

#### 【输入输出样例 2 说明】
编号为 $1,2$ 的人分别从 $1 ,2$ 号出口离开，编号为 $3$ 的人无法离开公园。

#### 【数据规模与约定】
对于 $12\%$ 的数据：$n, m, L \le 10$；   

对于 $32\%$ 的数据：$n, m \le 100$，$L \le 1000$；

对于 $52\%$ 的数据：$n, m \le 1000$；  

另有 $20\%$ 的数据：$n, m \le 10000$，所有 $s_i = 0$；   

对于 $100\%$ 的数据：$1 \le n,m \le 2 \times 10^5 $，$2 \le L \le 10^9$，$1\le a_i <L$，$1\le l_i \le n$，$s_i\in\{0,1\}$，$0\le b_i<L$。

## 样例 #1

### 输入

```
3 2 5
2
2 1
0 1
1 3
0 4```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2 5
2 
1 1
0 0 
0 2 
0 1```

### 输出

```
5```

# 题解

## 作者：Link_Cut_qwq (赞：34)

### 介绍一种 *dfs* + 并查集的做法。

这是目前的最优解。复杂度为排序复杂度 $O(n\log n)$，其余部分 $O(n)$。

- 大致做法

我们找到距离每个出口最近的人。这个人离该出口最近不等于从该出口出，因为这个人可能在途中另外一个出口出了。于是我们搜索他俩之间的所有出口，看看有没有出口把那个人拦下。如果没有，那个人就可以放心地从该出口出了。

- 具体实现

维护两条链表，分别是按位置递减排序过后的**逆时针走的人+出口**和按位置递增排序后的**顺时针走的人+出口**，称为 $L$ 链和 $R$ 链。在排序过程中，我们让 $type$ 作为第二关键字，$id$ 作为第三关键字。我们需要让链表里同位置的出口始终在人的左侧且同位置的 $id$ 小的人在 $id$ 大的人的左侧（代码采用的是一个倒着扫一个正着扫的方法建链表）。

再维护两个并查集 $L$ 集和 $R$ 集，把 $L$ 集定义为一些出口且任意两个出口之间没有逆时针走的人，$R$ 集定义为一些出口且任意两个出口之间没有顺时针走的人。再维护每个 $L$ 集合**最靠顺时针**的出口 $vL$ 和每个 $R$ 集合**最靠逆时针**的出口 $vR$。

任意一个点的**顺时针**侧最近的**逆时针走的人**就是这个点所在 $L$ 集合的 $vL$ 在 $L$ 链表中右侧的位置，**逆时针**侧最近的**顺时针走的人**就是这个点所在 $R$ 集合的 $vR$ 在 $R$ 链表中右侧位置（并查集就是为了干这事用的）。我们取这两个人中距离该出口最近的人作为搜索目标。

然后由距离该出口**从远到近**（也就是从该出口对应的 $vL$ 或 $vR$ 开始搜）的顺序搜索该出口与搜索目标之间的出口，这样确定一个人对应的出口只需要 $O(2)$，因为最多延伸两次就会出现该出口与最近的人之间没有别的出口的情况。

不能从近到远搜，因为这样确定一个人可能需要把所有出口都搜一遍，最坏需要 $O(n)$。

如果这个出口已经满了就标记一下，每次会取一个没有满的出口进函数，可以证明搜完以后要么这个出口满了要么没人了，因此不会有遗漏。

因为每次在达成目的后会退出，所以不会造成一个出口搜出去以后再次搜到这个出口的情况。

- 维护方法

只要一个出口满了或一个人确定了出口就把他们从 $L$ 链表或 $R$ 链表中删掉，这很容易办。

并查集的维护就繁琐一点了。若删掉的人在 $L$ 链表或 $R$ 链表中的前一个位置和后一个位置都是出口，那么将两个出口所在的 $L$ 集合或 $R$ 集合合并，并将新集合的 $vL$ 或 $vR$ 保留为**后一个位置**的集合的 $vL$ 或 $vR$，代码实现方面可以直接将前一个位置的爹连到后一个位置的爹上。

如果删掉的出口是某个集合的 $vL$ 或 $vR$，那么将该集合的 $vL$ 或 $vR$ 设为原本的 $vL$ 或 $vR$ 在 $L$ 链表或 $R$ 链表里**左侧的位置**。可以证明操作后的位置如果集合不为空一定是出口，若不是出口则这个集合为空，报废了，连的什么都无所谓。

- 复杂度

算法 $O(n)$ + 排序 $O(n\log n)$

- 代码

```cpp
#include <bits/stdc++.h>
#define N 1000010
using namespace std;

typedef long long ll;

struct Node
{
    ll data;
    int id;
    bool tp;
} bL[N], bR[N], b1[N], b2[N];

struct List
{
    ll to, la;
} tL[N], tR[N];

ll ans, a[N], w[N];
int n, m, l, fL[N], fR[N], s[N], vL[N], vR[N], cL, cR;
bool used[N], type;

int read ()
{
    int reat = 0, z = 1;
    char ch = getchar (); 
    while (ch < '0' || ch > '9')
    	ch = getchar ();
    while (ch <= '9' && ch >= '0')
        reat = reat * 10 + ch - '0', ch = getchar ();
    return z * reat; 
}

bool cmp1 (Node x, Node y)
{
    if (x.data != y.data) return x.data < y.data;
    return x.id > y.id;
}
// 排序，方便建链表 
bool cmp2 (Node x, Node y)
{
    if (x.data != y.data) return x.data < y.data;
    return x.id < y.id;
}

ll c (ll x, ll y)   //计算距离 
{
    if (x - y < 0)
        return x + l - y;
    return x - y;
}

ll findL (int x) //常规Find 
{
    if (cL <= m) return 0;
    if (fL[x] == x) return x;
    fL[x] = findL (fL[x]);
    return fL[x];
}

ll findR (int x) //常规Find 
{
    if (cR <= m) return 0;
    if (fR[x] == x) return x;
    fR[x] = findR (fR[x]);
    return fR[x];
}

bool dfs (int x, int k)
{
    while (s[x])
    {
        //逆时针集合最靠左的出口和顺时针集合最靠右的出口 
        int x0 = vL[findL(x)], x1 = vR[findR(x)]; 
        //顺时针方向第一个逆时针人和逆时针方向第一个顺时针人 
        ll a0 = tL[x0].to, a1 = tR[x1].to;
        if (cL == m && cR == m) return 0;   //如果人走完了就结束  
        if (cL > m && (c (a[x], w[a0-m]) < c (w[a1-m], a[x]) || c (a[x], w[a0-m]) == c (w[a1-m], a[x]) && a0 < a1 || cR == m))
        {
            while (x0 != x && !dfs (x0, a0))
                x0 = tL[x0].la; //从远到近爆搜每个路径上的出口 
            if (x0 == x)    //这个人被保留下来 
            {
                s[x]--;
                cL--;   //逆时针人数减一 
                ans ^= (a0 - m) * x;
                tL[tL[a0].to].la = tL[a0].la;   //链表里删掉这个人 
                tL[tL[a0].la].to = tL[a0].to;
                if (tL[a0].to <= m) //把人两侧的两个出口集合合并 
                    fL[findL(tL[a0].la)] = findL(tL[a0].to);    
            }
            if (a0 == k) return true;   //达成目的return true 
        } else
        {
            while (x1 != x && !dfs (x1, a1))
                x1 = tR[x1].la;
            if (x1 == x)
            {
                s[x]--;
                cR--;
                ans ^= (a1 - m) * x;
                tR[tR[a1].to].la = tR[a1].la;
                tR[tR[a1].la].to = tR[a1].to;
                if (tR[a1].to <= m)
                    fR[findR(tR[a1].la)] = findR(tR[a1].to);
            }
            if (a1 == k) return true;
        }
    }
    used[x] = 1;    //标记一下 
    ll x0 = findL(x), x1 = findR(x);
    tL[tL[x].la].to = tL[x].to; //链表里删掉出口 
    tL[tL[x].to].la = tL[x].la;
    tR[tR[x].la].to = tR[x].to;
    tR[tR[x].to].la = tR[x].la;
    if (x == vL[x0]) vL[x0] = tL[x].la; //这个出口作为某逆时针集合最左侧点则向右移动一格
    if (x == vR[x1]) vR[x1] = tR[x].la; //这个出口作为某顺时针集合最右侧点则向左移动一格
    return false;   //未达成return false 
}

int main ()
{
    cin >> n >> m >> l;
    b1[1].id = b2[1].id = 1;
    for (int i = 2; i <= m; i++)
    {
        a[i] = read ();
    }
    for (int i = 1; i <= m; i++)
        s[i] = read ();
    for (int i = m + 1; i <= m + n; i++)
    {
        type = read ();
        if (!type)
            b1[++cL].data = read (), b1[cL].id = i, w[i-m] = b1[cL].data;
        else
            b2[++cR].data = read (), b2[cR].id = i, w[i-m] = b2[cR].data;
    }
    sort (b1 + 1, b1 + cL + 1, cmp1);
    sort (b2 + 1, b2 + cR + 1, cmp2);
    cL += m, cR += m;
    int r1 = 1, r2 = 1;
    for (int i = 1; i <= cL; i++)	//排序常数优化，时间紧可以不加
    {
    	if (r1 <= m && a[r1] < b1[r2].data || r2 > cL - m)
    		bL[i].data = a[r1], bL[i].id = r1, bL[i].tp = 1, r1++;
    	else
    		bL[i] = b1[r2], r2++;
	}
	r1 = r2 = 1;
	for (int i = 1; i <= cR; i++)
    {
    	if (r1 <= m && (a[r1] < b2[r2].data || a[r1] == b2[r2].data) || r2 > cR - m)
    		bR[i].data = a[r1], bR[i].id = r1, bR[i].tp = 1, r1++;
    	else
    		bR[i] = b2[r2], r2++;
	}
    //以下为建链表 
    for (int i = cL; i >= 1; i--)
    {
        tL[bL[i].id].to = bL[i-1].id;
        tL[bL[i].id].la = bL[i+1].id;
        if (bL[i+1].tp && bL[i].tp)
            fL[bL[i+1].id] = bL[i].id;
        fL[bL[i].id] = bL[i].id;
        vL[bL[i].id] = bL[i].id;
    }
    tL[bL[1].id].to = bL[cL].id;
    tL[bL[cL].id].la = bL[1].id;
    if (bL[1].tp && bL[cL].tp)
        fL[bL[1].id] = bL[cL].id;
    for (int i = 1; i <= cR; i++)
    {
        tR[bR[i].id].to = bR[i+1].id;
        tR[bR[i].id].la = bR[i-1].id;
        if (bR[i-1].tp && bR[i].tp)
            fR[bR[i-1].id] = bR[i].id;
        fR[bR[i].id] = bR[i].id;
        vR[bR[i].id] = bR[i].id;
    }
    tR[bR[cR].id].to = bR[1].id;
    tR[bR[1].id].la = bR[cR].id;
    if (bR[cR].tp && bR[1].tp)
        fR[bR[cR].id] = bR[1].id;
    for (int i = 1; i <= m; i++)
    {
        if (!used[i]) dfs (i, 0);
    }
    cout << ans << endl;
    return 0;
}

```

不开 *o2* 377ms，开 *o2* 242ms。代码大多是对称的，并查集也不算毒瘤。所以~~在结尾求个赞不过分吧。。~~



---

## 作者：周子衡 (赞：24)

```
求求管理造造数据吧……
```

嗯嗯嗯感觉这是$\text{CSPJX2019}$最难的题，没有之一。

对于每个人，我们预处理出他**到达任意一个出口的最短时间**和**这个出口的编号（下称目标出口）**，不妨记为$t_i$和$id_i$。

对于一个出口，我们发现，如果它的限制$l_i$降为$0$，那么这个出口就不再有意义，直接删掉。这启发我们，用一个环形链表维护出口。不妨维护链表$nxt_j,pre_j$，分别表示当**沿逆时针**前进时，第$j$个出口的**下一个出口**和**上一个出口**。

容易想到将$t_i$按升序排序（相同时按$i$排序）。我们依次考虑每一个人。

显然，第一个人出去的出口就是他第一个到达的出口（因为不会有人跟他抢）。记他出去的出口为$j$，则$l_j=l_j-1$。

若此时$l_j>0$，则所有出口仍然可用。

若$l_j=0$，那么这个出口就不能再出人了。那么可以发现，我们要把所有原来所有目标出口为$j$的人的目标出口改掉，对于逆时针行走的人，目标出口变为$nxt_j$，到达时间也增加；对于顺时针行走的人，目标出口变为$pre_j$，同样增加到达时间。

对于后面的人，这个分析同样适用。

如果暴力更改所有人的目标出口和到达时间，时间复杂度将上升至$O(nm)$，无法承受。必须优化。

发现：如果两个人$i_1,i_2$开始时目标出口相同，那么只要他们还没有出去，他们的目标出口也一定相同。考虑对于每个出口$j$，维护一个变量，表示目标出口。

为了方便利用上文的$nxt_j,pre_j$数组进行维护，我们作如下处理：对于每个人$i$，记他的目标出口的**上一个出口**（以他的前进方向为基准）为他的**出发出口**$start_i$，那么在任何一个时刻，对于逆时针行走的人，他目前的目标出口为$nxt_{start_i}$；对于顺时针行走的人，目标出口为$pre_{start_i}$。这样，维护目标出口时仅需更改$nxt_j,pre_j$数组即可，时间复杂度降为$O(1)$。

但还有一个问题：我们要处理**到达时间**的更改。

可以发现，如果$l_j$降为$0$，那么所有以$j$为目标出口的**逆时针行走的人**，时间增加的量相同（就是$j$和$nxt_j$间的距离）；**顺时针行走的人**同理。

而我们每步要找出**到达时间最短**的人。也就是说，我们要维护一个**区间加，区间最值**的问题，想到用线段树。

为了方便进行区间修改，考虑更改排序方式。我们把**所有逆时针行走的人放在顺时针行走的人前面**；在同一段内，再**按位置排序**（不再按$t_i$的大小排序，改用线段树维护最值）。这样，每次修改的$t_i$都会尽可能相邻。

题中还有要求：同时到某一出口的人，编号小的优先。于是，设计另一个值$val_i=t_i\times n+i$，由于$1\leq i\leq n$且$t_i$都是非负整数，那么可以发现：当$t_i$不同时，一定是$t_i$小的那个$val_i$小；当$t_i$相同时，编号小的那个$val_i$小，正好符合了我们的需求。

综上，我们最终的算法是：

- 读入，预处理出数组$nxt_j,pre_j,start_i,val_i$；
- 排序，建线段树，记录每个人在树中的位置，顺便记录树中每个位置对应的人的编号；
- 每步找到$val_i$最小的人（这样的人一定唯一，因为$val_i$两两不同），确定这个人离去的出口$k_i$的值，并让$l_{k_i}=l_{k_i}-1$，在线段树中把这个人的$val_i$赋为正无穷；
- 如果$l_{k_i}=0$，在链表中删去出口$k_i$，同时在线段树中区间增加$val_i$的值（可以发现，一次最多更改$4$段区间）；
- 不断重复$3,4$步，直到所有人都找到出口（即线段树中的最小值就是正无穷），或者所有出口都满人（即修改时发现$l_{k_i}=0$且$nxt_{k_i}=pre_{k_i}=k_i$），此时终止操作；
- 根据$k_i$计算答案，输出，终止算法。

总时间复杂度$O((n+m)\log n)$。

---

## 作者：Vocalise (赞：10)

看起来这题还是不太多人知道。。。那不妨在A掉一个月之后来写一篇题解。

这题写出来可以显著提升代码能力。

---

博客阅读效果更好。

#### 1.基本思路

首先这题所有人是匀速的，并且一直一起运动。

所以可以想到，像小学奥数中多人行进多次折转的问题一样，我们只需要每次找到一个最先抵达终点的人就行了。

这道题当然没有这么简单；因为每个出口只能容纳一定量的人出去。

于是就在查询的时候带上了修改。

我们发现，如果一个出口满员了，只对其它的（两个方向）原本需要从这个出口出去的人造成影响，**且两个方向上的人新的目的地是分别相同的**。

---

#### 2.实现的方法与数据结构

于是我们想到线段树上全局查询带上区间修改。

这里有必要先提出：如何保证所修改的一个或若干个区间呢？

可以首先把人以方向不同分离开来。

然后对于两边的人，按照绝对位置 $b$ 排序即可。

然后我们考虑一下整个算法流程。

1. 初始化每个人的目的地与距离。
2. 根据距离最小建出线段树。
3. 执行 $n$ 步：
4. 取出线段树顶部结点，将其贡献加入答案。
5. 如果其目的地满员：
6. 二分找出原本打算从这个出口出去的人的区间。（这里区间最多有 $4$ 个，因为有两个方向，并且如果跨过 $0$ 原点，又可能出现 $2$ 个区间）
7. 线段树上区间修改离目的地的距离和目的地。
8. 如果出口已经被用尽，后面的人的贡献都为 $0$，直接退出循环。

这个表完整吗？明显是不够完整的。

比如说：如何找出一个出口用尽之后下一个能用的出口是哪一个？如何 $O(n\log n)$ 初始化？线段树上是怎么工作的？

关于出口的关系，容易想到用一个双向链表维护还存在的出口之间的相邻关系。

可以上一段代码：

```cpp
struct Chain
{
	int l[MAXN],r[MAXN];
	void init() {
		for(int i = 1;i <= m;i++) {
			l[i] = i - 1;
			r[i] = i + 1;
		}
		l[1] = m, r[m] = 1;
	}
	int pre(int x) {
		return l[x];
	}
	int nxt(int x) {
		return r[x];
	}
	void del(int x) {
		r[l[x]] = r[x];
		l[r[x]] = l[x];// 满员时删除
	}
};
```

关于初始化，可以直接对于每个人二分。

给出人的结构体：

```cpp
struct Person
{
	int s,b,id,tar,dis;
	// 分别是方向，绝对位置，排序前的编号，目标和距离（当然是初始状态下的）
	Person() {}
	Person(int _s,int _b,int _id,int _tar,int _dis) :
		s(_s), b(_b), id(_id), tar(_tar), dis(_dis) {} 
	friend bool operator < (const Person &x,const Person &y) {
		if(x.s != y.s) return x.s < y.s;
		return x.b < y.b;
	}
	//第一次排序的方式：先按方向，再按绝对位置
};
```

**注意：这不是线段树上结点的结构体。**

并初始化的代码：

```cpp
void init() {
	for(int i = 1;i <= n;i++) {
		if(!p[i].s) {// 顺时针
			int k = std::lower_bound(a + 1,a + 1 + m,p[i].b) - a - 1;
			if(k == m) p[i].tar = 1, p[i].dis = l - p[i].b;
			else p[i].tar = k + 1, p[i].dis = a[k + 1] - p[i].b; 
		} else {// 逆时针
			int k = std::upper_bound(a + 1,a + 1 + m,p[i].b) - a - 1;
			p[i].tar = k, p[i].dis = p[i].b - a[k];
		}
	}
	return;
}
```

注意 `lower_bound` 和 `upper_bound` 的运用及跨过 $0$ 原点的特殊情况处理。

再给出主函数开头一段：

```cpp

Person p[MAXN];
Chain c;
Segment_Tree t;

int main() {
	n = read(), m = read(), l = read();
	for(int i = 2;i <= m;i++) a[i] = read();
	for(int i = 1;i <= m;i++) lim[i] = read();
	for(int i = 1;i <= n;i++) {
		p[i].s = read(), p[i].b = read();
		p[i].id = i;
	}
	std::sort(p + 1, p + 1 + n);
	while(end <= n && !p[end].s) end++;
	init();
	t.build(1,1,n);
	c.init();
```

注意认清变量名。 `end` 记录了第一个顺时针的人的编号，是之后二分不可少的工具。

然后到了重点：线段树应该怎么工作呢？

---

#### 3.线段树上处理

因为我们不仅要询问线段树上最小距离，还要知道最小距离的点的编号。

于是我们把线段树结点封装成结构体：

```cpp
struct Segment_Tree
{
#define lc(k) k << 1
#define rc(k) k << 1 | 1
	struct node
	{
		int id,dis,tar;
		// 编号，距离，目标
		// 注意编号是排完序的编号，而不是一开始输入的编号。
		node() {}
		node(int _id,int _dis,int _tar) :
			id(_id), dis(_dis), tar(_tar) {}
		friend bool operator < (const node &x,const node &y) {
			if(x.dis != y.dis) return x.dis < y.dis;
			return ::p[x.id].id < ::p[y.id].id;
		}
		// 注意：不仅要按照距离排序，距离相等时还要考虑最原始的编号大小
	};

	node p[MAXN << 2];
```

线段树也封装结构体。

于是我们的 `pushup` 函数就可以直接取 $\min$ 拷贝了。

```cpp
	void pushup(int k) {
		p[k] = std::min(p[lc(k)],p[rc(k)]);
	}
```

关于建树，打标记，下传之类，都是在 `tag` 结构体的基础上运行的：

```cpp
	struct tag
	{
		int dis, tar;
		tag() {}
		tag(int _dis,int _tar) :
			dis(_dis), tar(_tar) {}
	};

	tag t[MAXN << 2];
```

相信大家都会，不再赘述。

值得一提的是 `upset`,因为每个结点都只能取出一次，所以我们把取出的结点 `dis` 设为 `INF`,然后 `pushup`，想当于作了一次单点修改。

```cpp
	void upset(int k,int l,int r,int x) {
		if(l == r) {
			p[k].dis = INF;
			return;
		}
		int mid = (l + r) >> 1;
		pushdown(k);
		if(x <= mid) upset(lc(k),l,mid,x);
		else upset(rc(k),mid + 1,r,x);
		pushup(k);
	}
```

然后就差不多这样了。

---

#### 4.修改

这里主要指查询之后的找出影响区间。

是本题中代码实现最为复杂，最容易出错的地方。

先上代码:

```cpp
void Modify1(int l,int r,Segment_Tree::tag tag) {
	int k1 = std::upper_bound(p + 1,p + end,Person(0,l,0,0,0)) - p;
	int k2 = std::upper_bound(p + 1,p + end,Person(0,r,0,0,0)) - p - 1;
	if(l > r) {
		if(k1 < end) t.update(1,1,n,k1,end - 1,tag);
		if(k2 >= 1) t.update(1,1,n,1,k2,tag);
	} else if(k1 <= k2) t.update(1,1,n,k1,k2,tag);
}

void Modify2(int l,int r,Segment_Tree::tag tag) {
	int k1 = std::lower_bound(p + end,p + 1 + n,Person(1,l,0,0,0)) - p;
	int k2 = std::lower_bound(p + end,p + 1 + n,Person(1,r,0,0,0)) - p - 1;
	if(l > r) {
		if(k1 <= n) t.update(1,1,n,k1,n,tag);
		if(k2 >= end) t.update(1,1,n,end,k2,tag);
	} else if(k1 <= k2) t.update(1,1,n,k1,k2,tag);
}
// int main() {
// for(int i = 1;i <= n;i++) {
		if(!--lim[tar]) {
			Modify1(a[c.pre(tar)],a[tar],Segment_Tree::tag((a[c.nxt(tar)] - a[tar] + l) % l,c.nxt(tar)));
			Modify2(a[tar],a[c.nxt(tar)],Segment_Tree::tag((a[tar] - a[c.pre(tar)] + l) % l,c.pre(tar)));
			c.del(tar); // 切记在链表中删除该出口
			if(++usdup == m) break;// 如果出口用尽，直接退出。
		}
```

大略来说，顺时针的 `Modify1` 处理，逆时针的 `Modify2` 处理。

`k1`,`k2` 在 `Person` 数组的 $[1,end)$ 或 $[end,n]$ 上进行 `lower_bound` 或 `upper_bound`，表示将要修改 $[k1,k2]$ 的区间。

如果区间左端点大于右端点，则说明跨越了原点 $0$，需要拆开两段处理。

**判断区间是否存在后**（因为如果修改区间 $k1 > k2$，会出现无法预料的错误，这是使用 `lower_bound` 和 `upper_bound` 的重点），在线段树上进行修改。

这边大概也无法更加细致地讲了。整理出坑点如下：

1. `lower_bound` 与 `upper_bound` 的使用与是否 $-1$；
2. 右端点是 $n$ 还是 $end - 1$:
3. 一个人正好在出口的位置，就得从那个出口出去，需要注意它是否在修改范围内。

于是就是这么麻烦的了。

---

#### 5.总结:

这题如果写出来，可能需要耗费一些精力；但是希望大家一定不能中途放弃（像我做题一样），**多对拍，多上 `gdb` 调试**。本人就做了 $3-4$ 天。当然大神半天都不消罢。

常见坑点如开 `long long` 也赘述了。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

typedef long long ll;
const int MAXN = 200011;
const int INF = 0x3f3f3f3f;

inline int read() {
	int x = 0; char ch = getchar();
	while(ch > '9' || ch < '0') ch = getchar();
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x;
}

int n, m, l, end;
int a[MAXN], lim[MAXN];

struct Person
{
	int s,b,id,tar,dis;
	Person() {}
	Person(int _s,int _b,int _id,int _tar,int _dis) :
		s(_s), b(_b), id(_id), tar(_tar), dis(_dis) {} 
	friend bool operator < (const Person &x,const Person &y) {
		if(x.s != y.s) return x.s < y.s;
		return x.b < y.b;
	}
};

struct Chain
{
	int l[MAXN],r[MAXN];
	void init() {
		for(int i = 1;i <= m;i++) {
			l[i] = i - 1;
			r[i] = i + 1;
		}
		l[1] = m, r[m] = 1;
	}
	int pre(int x) {
		return l[x];
	}
	int nxt(int x) {
		return r[x];
	}
	void del(int x) {
		r[l[x]] = r[x];
		l[r[x]] = l[x];
	}
};

Person p[MAXN];
Chain c;

struct Segment_Tree
{
#define lc(k) k << 1
#define rc(k) k << 1 | 1
	struct node
	{
		int id,dis,tar;
		node() {}
		node(int _id,int _dis,int _tar) :
			id(_id), dis(_dis), tar(_tar) {}
		friend bool operator < (const node &x,const node &y) {
			if(x.dis != y.dis) return x.dis < y.dis;
			return ::p[x.id].id < ::p[y.id].id;
		}
	};
	
	struct tag
	{
		int dis, tar;
		tag() {}
		tag(int _dis,int _tar) :
			dis(_dis), tar(_tar) {}
	};

	node p[MAXN << 2];
	tag t[MAXN << 2];

	void pushdown(int k) {
		if(!t[k].dis && !t[k].tar) return;
		perform(lc(k),t[k]);
		perform(rc(k),t[k]);
		t[k].dis = t[k].tar = 0;
		return;
	}
	
	void pushup(int k) {
		p[k] = std::min(p[lc(k)],p[rc(k)]);
	}

	void perform(int k,tag x) {
		p[k].dis += x.dis;
		if(x.tar) p[k].tar = x.tar;
		t[k].dis += x.dis;
		if(x.tar) t[k].tar = x.tar;
		return;
	}

	void build(int k,int l,int r) {
		if(l == r) {
			p[k] = node(l,::p[l].dis,::p[l].tar);
			return;
		}
		int mid = (l + r) >> 1;
		build(lc(k),l,mid);
		build(rc(k),mid + 1,r);
		pushup(k);
	}
	
	void update(int k,int l,int r,int x,int y,tag v) {
		if(l > y || r < x) return;
		if(l >= x && r <= y) {
			perform(k,v);
			return;
		}
		int mid = (l + r) >> 1;
		pushdown(k);
		update(lc(k),l,mid,x,y,v);
		update(rc(k),mid + 1,r,x,y,v);
		pushup(k);
		return;
	}

	void upset(int k,int l,int r,int x) {
		if(l == r) {
			p[k].dis = INF;
			return;
		}
		int mid = (l + r) >> 1;
		pushdown(k);
		if(x <= mid) upset(lc(k),l,mid,x);
		else upset(rc(k),mid + 1,r,x);
		pushup(k);
	}

	node query() {
		return p[1];
	}
};

Segment_Tree t;

void init() {
	for(int i = 1;i <= n;i++) {
		if(!p[i].s) {
			int k = std::lower_bound(a + 1,a + 1 + m,p[i].b) - a - 1;
			if(k == m) p[i].tar = 1, p[i].dis = l - p[i].b;
			else p[i].tar = k + 1, p[i].dis = a[k + 1] - p[i].b; 
		} else {
			int k = std::upper_bound(a + 1,a + 1 + m,p[i].b) - a - 1;
			p[i].tar = k, p[i].dis = p[i].b - a[k];
		}
	}
	return;
}

void Modify1(int l,int r,Segment_Tree::tag tag) {
	int k1 = std::upper_bound(p + 1,p + end,Person(0,l,0,0,0)) - p;
	int k2 = std::upper_bound(p + 1,p + end,Person(0,r,0,0,0)) - p - 1;
	if(l > r) {
		if(k1 < end) t.update(1,1,n,k1,end - 1,tag);
		if(k2 >= 1) t.update(1,1,n,1,k2,tag);
	} else if(k1 <= k2) t.update(1,1,n,k1,k2,tag);
}

void Modify2(int l,int r,Segment_Tree::tag tag) {
	int k1 = std::lower_bound(p + end,p + 1 + n,Person(1,l,0,0,0)) - p;
	int k2 = std::lower_bound(p + end,p + 1 + n,Person(1,r,0,0,0)) - p - 1;
	if(l > r) {
		if(k1 <= n) t.update(1,1,n,k1,n,tag);
		if(k2 >= end) t.update(1,1,n,end,k2,tag);
	} else if(k1 <= k2) t.update(1,1,n,k1,k2,tag);
}

int main() {
	n = read(), m = read(), l = read();
	for(int i = 2;i <= m;i++) a[i] = read();
	for(int i = 1;i <= m;i++) lim[i] = read();
	for(int i = 1;i <= n;i++) {
		p[i].s = read(), p[i].b = read();
		p[i].id = i;
	}
	std::sort(p + 1, p + 1 + n);
	while(end <= n && !p[end].s) end++;
	init();
	t.build(1,1,n);
	c.init();
	ll ans = 0; int usdup = 0;
	for(int i = 1;i <= n;i++) {
		Segment_Tree::node k = t.query();
		int id = k.id,tar = k.tar;
		ans ^= 1ll * p[id].id * tar;
		//std::printf("node = %d target = %d\n",p[id].id,tar);
		t.upset(1,1,n,id);
		if(!--lim[tar]) {
			Modify1(a[c.pre(tar)],a[tar],Segment_Tree::tag((a[c.nxt(tar)] - a[tar] + l) % l,c.nxt(tar)));
			Modify2(a[tar],a[c.nxt(tar)],Segment_Tree::tag((a[tar] - a[c.pre(tar)] + l) % l,c.pre(tar)));
			c.del(tar);
			if(++usdup == m) break;
		}
	}
	std::printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：cccgift (赞：8)

看到AC区清一色的线段树……

这里介绍一种堆+链表的做法。

基本思路是差不多的（可以参考其它题解），每次找到距离他可到出口最近的人，删除这个人，更新答案和出口。

关键就在于怎么更新一段区间的人到下一个可达出口的距离，我们可以发现，只需要关注每一个人的下一个可达出口的位置就可以了，因为人到出口的距离是固定的。

刚开始，把人分成顺时针走和逆时针走两组，再按照位于哪两个相邻出口之间分组，这可以用排序+指针扫描一遍解决。

对于每一组，按人到下一个可达出口的距离从小到大、从头到尾串成一个链表，那么用一个堆维护每一个链表表头最小值，每次取最小值删除后就将链表中下一个位置加入堆。

那么，就只剩下删除出口了。首先，也是把出口用链表串起来，删除直接在链表上删除。可以发现，每一次删除，都相当于把两个相邻的组合并，
然后把链表合并并维护到新的出口的距离的相对顺序。

设新的出口还是原来出口的组为$A$，新的出口变为$A$组原来出口的组为$B$，那么$B$组中每一个人到新的出口的距离都大于$A$组中每一个人到出口的距离，所以只要把$B$组的链表表头直接接到$A$组表尾就可以保证相对距离顺序不变了。

~~然后，就没有然后了……~~

时间复杂度$O(nlogn)$，但是常数小，而且比线段树好写（~~然而代码4k~~），很轻松就跑到了最优解……

Upd：修改了代码中一些错误（感谢@Owen_codeisking%%%）

### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define ll long long
//#define cccgift
#define lowbit(x) ((x)&-(x))
#define rep(i,l,r) for(res i=l,_r=r;i<=_r;++i)
#define per(i,r,l) for(res i=r,_l=l;i>=_l;--i)
#define mkp make_pair
#define pb push_back
#define mem0(a) memset(a,0,sizeof(a))
#define mem0n(a,n) memset(a,0,(n)*sizeof(a[0]))
#define iter(x,v) for(res v,_p=head[x];v=ver[_p],_p;_p=nxt[_p])
#ifdef cccgift //by lqh
#define SHOW(x) cerr<<#x"="<<(x)<<endl
#else
#define SHOW(x) 0
#endif
#define getchar()(ip1==ip2&&(ip2=(ip1=ibuf)+fread(ibuf,1,1<<21,stdin),ip1==ip2)?EOF:*ip1++)
char ibuf[1<<21],*ip1=ibuf,*ip2=ibuf;
template<typename T>
inline void read(T &x)
{
    static char ch;bool f=1;
    for(x=0,ch=getchar();!isdigit(ch);ch=getchar()) if(ch=='-') f=0;
    for(;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());x=f?x:-x;
}
template<typename T>
void print(T x)
{
    if (x<0) x=-x,putchar('-');
    if (x>9) print(x/10);
    putchar(x%10+48);
}
template<typename T>
inline void print(T x,char ap) {print(x);if (ap) putchar(ap);}
template<typename T>
inline void chkmax(T &x,const T &y) {x=x<y?y:x;}
template<typename T>
inline void chkmin(T &x,const T &y) {x=x<y?x:y;}
struct person{
	int x,id;
	person() {}
	person(int x,int id):x(x),id(id) {}
	bool operator <(const person &b)const {return x<b.x||(x==b.x&&id>b.id);}
} b[400010],c[400010];
struct node{
	int op,id,peo,peid,val; //op:方向，id:所属组，peo:人在组中的编号，peid:人的编号，val:人到下一个可达出口的距离。
	node() {}
	node(int op,int id,int peo,int peid,int val):op(op),id(id),peo(peo),peid(peid),val(val) {}
	bool operator <(const node &b)const {return val>b.val||(val==b.val&&peid>b.peid);}
};
priority_queue<node> q; //堆
int n,m,L,x,y,a[200010],cnt[200010],len1,len2,nxt[2][600010],pre[2][600010],nxt1[200010],pre1[200010];
ll tot;
inline void ins(int op,int id,int x) { //加入表头
	int now=nxt[op][id];
	pre[op][now]=x,nxt[op][x]=now,pre[op][x]=id,nxt[op][id]=x;
}
inline void del(int op,int x) {nxt[op][pre[op][x]]=nxt[op][x],pre[op][nxt[op][x]]=pre[op][x];}
inline int getdis(int x,int y) { //两点之间在环上的距离
	if(x<=y) return y-x;
	return L-x+y;
}
inline void hebing(int op,int x,int y) {
	int nowl=nxt[op][x+n],nowr=pre[op][n+m+x],now=pre[op][n+m+y]; //把nowl到nowr这一段插到y的链表表尾
	if(nowl==n+m+x) return;
	if(now==n+y) q.push(node(op,y,nowl,(op?c[nowl].id:b[nowl].id),getdis((op?c[nowl].x:b[nowl].x),(op?(L-a[y]):a[y])))); //如果插入y的堆中后nowl变成表头了，也要加入堆中。
	nxt[op][x+n]=n+m+x,pre[op][n+m+x]=x+n;
	pre[op][n+m+y]=nowr,nxt[op][nowr]=n+m+y;
	nxt[op][now]=nowl,pre[op][nowl]=now;
}
int main()
{
	read(n),read(m),read(L),a[1]=0;
	rep(i,2,m) read(a[i]);
	rep(i,1,m) read(cnt[i]);
	rep(i,1,n) {
		read(x),read(y);
		if(!x) b[++len1]=person(y?y:L,i);
		else c[++len2]=person(L-y,i); //b表示逆时针的人，c表示顺时针的人。
	}
	sort(b+1,b+1+len1),sort(c+1,c+1+len2);
	rep(i,1,m) nxt1[i]=i%m+1,pre1[i]=i-1;pre1[1]=m; //维护出口的链表
	rep(i,1,m) nxt[0][i+n]=nxt[1][i+n]=n+m+i,pre[0][n+m+i]=pre[1][n+m+i]=i+n; //这里维护了表头(n+1~n+m)和表尾(n+m+1~n+m+m)
	int p=1;
	rep(i,1,len1) {
		while(p<=m&&b[i].x>a[p]) ++p;
		if(p>m) ins(0,n+1,i);else ins(0,n+p,i);
	}
	p=m;
	rep(i,1,len2) {
		while(p&&c[i].x>L-a[p]) --p;
		ins(1,n+p,i);
	} //指针扫描
	rep(i,1,m) {
		int now1=nxt[0][n+i],now2=nxt[1][n+i];
		if(now1!=n+m+i) q.push(node(0,i,now1,b[now1].id,getdis(b[now1].x,a[i])));
		if(now2!=n+m+i) q.push(node(1,i,now2,c[now2].id,getdis(c[now2].x,L-a[i])));
	}
	int cntp=n,cntc=m;
	while(cntc&&cntp) {
		node now=q.top();
		while(nxt[now.op][n+now.id]==n+m+now.id) q.pop(),now=q.top();q.pop(); //懒惰删除，因为被合并之后的组不再有独立的最小值，需要在堆中删除。
		int op=now.op,id=n+now.id;
		--cntp,--cnt[now.id],del(op,now.peo);
		int h=nxt[op][id];
		if(h!=n+m+now.id) q.push(node(op,now.id,h,(op?c[h].id:b[h].id),getdis((op?c[h].x:b[h].x),(op?(L-a[now.id]):a[now.id]))));
		tot^=(ll)now.peid*now.id;
		if(!cnt[now.id]) { //删除出口
			id-=n;
			if(id!=nxt1[id]) hebing(0,id,nxt1[id]),hebing(1,id,pre1[id]);
			--cntc,nxt1[pre1[id]]=nxt1[id],pre1[nxt1[id]]=pre1[id];
		}
	}
	print(tot,'\n');
	return 0;
}
```

---

## 作者：幻影星坚强 (赞：7)

前言：和同学刷联赛题，然后看到线段树做法好长（）。

为了避免繁琐的线段树，我们考虑换一种思考方式。

我们不考虑每一个人到终点的距离，而是考虑每个出口左边与右边离他最近的人。这样我们只要在这些出口中选取一个距离最短的人而并不用更新距离，所以可以用set来解决。

那么问题就变成了如何维护每个出口它的左边和右边离他最近的人。


- **1.初始化**



对于每个方向的人和每个出口都建出一个链表，方便之后的删除操作。同时为了方便处理位置相同时的编号问题，我们可以在建链表时以编号为第二关键字进行排序。

之后先预处理出每一个出口左边与右边离他最近的人。这里以处理左边的人为例：

从任意的人开始，之后不断往左移动，直到下一个人跨过了一个出口，如果在同一个位置则从编号大的向编号小的连边。
![](https://cdn.luogu.com.cn/upload/image_hosting/ne2gca37.png)

最后看一下开始的人与结束的人之间有没有出口。

将距离和每个点的编号合起来存在set里，同时存储每个被选择的人与出口对应的关系，若出口的左边或者右边没有人对应，则将它的值设为0（后面有用）。

- **2.删除与加入**



选择出距离最近的人后，就要对它对应的出口状态进行修改。

假如出口还能出人，则对出口所对应左边最近或右边最近的人进行修改

即先找到人所对应的出口，再将它连向这个人的前驱，将对应的值存进set里。

![](https://cdn.luogu.com.cn/upload/image_hosting/sh4jcpby.png)

当然如果前驱已经有对应的出口了，那么就将它的值设为0.

![](https://cdn.luogu.com.cn/upload/image_hosting/xfuw18o0.png)

如果出口满了，那么就要修改该出口下一个出口的状态，因为该出口所对应的人一定是在下一个出口所对应的人的后面，所以只有在对应关系为0的出口要将它与这个人的前驱建立关系，并加入set。

![](https://cdn.luogu.com.cn/upload/image_hosting/1qxr3hyd.png)

假如删除了出口则要将出口从链表中删除，同时将所选到的人从链表中删除。

最后出口所对应的关系没了就退出。

然后发现细节极多，实际长度和数据结构差不多（）。

```
#include <iostream>
#include <cstdio>
#include <set>
#include <algorithm>
#define int long long
using namespace std;
const int N = 2e5 + 10;
int n, m, l;
struct people
{
	int ids, opt, b;
}p[N], zz[N], nn[N];
struct list
{
	int l, r;
}ls[N];
int a[N], L[N], num1, num2, ss[N], bb[N];
bool pd(people i, people j)
{
	return i.b < j.b || (i.b == j.b && i.ids > j.ids);
}

bool pd1(people i, people j)
{
	return i.b < j.b || (i.b == j.b && i.ids < j.ids);
}
int sf[N];
set <pair<int, int> > s;
int dl[N], dr[N];
int _l[N], _r[N];
int ans;
int next[N], pre[N]; 
int ff[N];
void re(int to, pair<int, int> now)
{
	int a1 = dl[to], a2 = dr[to];
	if(ss[now.second] == 0)
	a2 = ls[a2].l;
	else
	a1 = ls[a1].r;
	if(dr[next[to]] == 0 && a2 && L[_r[a2]] <= 0)
	{
		dr[next[to]] = a2;
		_r[a2] = next[to];
		if(ff[a2] == 0 && next[to] != to)
		if(a[next[to]] < bb[a2])
		s.insert(make_pair(l - bb[a2] + a[next[to]], a2));
		else
		s.insert(make_pair(a[next[to]] - bb[a2], a2));
	}
	if(dl[pre[to]] == 0 && a1 && L[_l[a1]] <= 0)
	{
		dl[pre[to]] = a1;
		_l[a1] = pre[to];
		if(ff[a1] == 0 && next[to] != to)
		if(a[pre[to]] > bb[a1])
		s.insert(make_pair(l + bb[a1] - a[pre[to]], a1));
		else
		s.insert(make_pair(bb[a1] - a[pre[to]], a1));
	}
	ls[ls[now.second].l].r = ls[now.second].r;
	ls[ls[now.second].r].l = ls[now.second].l;
	pre[next[to]] = pre[to];
	next[pre[to]] = next[to];
} 
signed main()
{
	freopen("walk.in","r",stdin);
	freopen("walk.out","w",stdout);
	scanf("%lld%lld%lld", &n, &m, &l);
	for (int i = 2; i <= m; ++ i)
	{
		scanf("%lld", &a[i]);
	}
	for (int i = 1; i <= m; ++ i)
	{
		scanf("%lld", &L[i]);
		pre[i] = (i - 2 + m) % m + 1;
		next[i] = i % m + 1;
	}
	for (int i = 1; i <= n; ++ i)
	{
		scanf("%lld%lld", &p[i].opt, &p[i].b);
		ss[i] = p[i].opt;
		bb[i] = p[i].b;
		p[i].ids = i;
	}
	sort(p + 1, p + 1 + n, pd);
	for (int i = 1; i <= n; ++ i)
	{
		if(p[i].opt == 0)
		{
			nn[++ num1] = p[i];
		}
		else
		{
			zz[++ num2] = p[i];
		}
	}
	sort(zz + 1, zz + 1 + num2, pd1);
	for (int i = 1; i <= num1; ++ i)
	{
		ls[nn[i].ids].l = nn[i - 1].ids;
		ls[nn[i].ids].r = nn[i + 1].ids;
	}
	ls[nn[1].ids].l = nn[num1].ids;
	ls[nn[num1].ids].r = nn[1].ids;
	for (int i = 1; i <= num2; ++ i)
	{
		ls[zz[i].ids].l = zz[i - 1].ids;
		ls[zz[i].ids].r = zz[i + 1].ids;
	}
	ls[zz[1].ids].l = zz[num2].ids;
	ls[zz[num2].ids].r = zz[1].ids;
	int now = 1, S;
	while(ss[p[now].ids] == 1 && now <= n) ++ now;
	S = ls[p[now].ids].l;
	int id = p[now].ids, qwq = 0;
	if(bb[id] == 0)
	{
		while(bb[ls[id].r] <= a[1] && id != S)
		id = ls[id].r;
		dr[1] = id;
		_r[id] = 1;
		s.insert(make_pair(0, id));
		qwq = 1;
	}
	int flag = 1;
	for (int i = 2; i <= m; ++ i)
	{
		while(bb[ls[id].r] <= a[i]&& id != S)
		id = ls[id].r, flag = 1;
		if(flag == 1 && bb[id] <= a[i] && bb[id] != 0)
		{
			flag = 0;
			dr[i] = id;
			_r[id] = i;
			s.insert(make_pair(a[i] - bb[id], id));
		}
	}
	if(qwq == 0 && _r[S] == 0)
	{
		dr[1] = S;
		_r[S] = 1;
		s.insert(make_pair(l - bb[S], S));
	}
	
	sort(p + 1, p + 1 + n, pd1);
	now = n;
	while(ss[p[now].ids] == 0 && now > 0) -- now;
	S = ls[p[now].ids].r;
	id = p[now].ids;
	flag = 1;
	for (int i = m; i >= 2; -- i)
	{
		while(bb[ls[id].l] >= a[i] && id != S)
		id = ls[id].l, flag = 1;
		if(flag == 1 && bb[id] >= a[i] && bb[id] != 0)
		{
			dl[i] = id;
			_l[id] = i;
			s.insert(make_pair(bb[id] - a[i], id));
			flag = 0;
		}
	}
	if(_l[S] == 0)
	{
		dl[1] = S;
		_l[S] = 1;
		s.insert(make_pair(bb[S], S));
	} 
	while(s.size())
	{ 
		pair<int, int> now = *s.begin();
		s.erase(s.begin());
		if(ff[now.second] || now.second == 0)
		continue;
			if(ss[now.second] == 0)
			{
				int to = _r[now.second];
				int jl = 0;
				if(a[to] < bb[now.second])
				jl = l - bb[now.second] + a[to];
				else
				jl = a[to] - bb[now.second];
				if(jl != now.first)continue;
				-- L[to];
				if(L[to] < 0)
				{
					_r[now.second] = 0;
					continue;
				}
				if(ff[now.second] == 1)continue;
				ff[now.second] = 1;
//				printf("%d %d\n", now.second, to);
				ans ^= now.second * to;
				if(L[to] == 0)
				{
					re(to, now);
				}
				else
				{
					ls[ls[now.second].l].r = ls[now.second].r;
					ls[ls[now.second].r].l = ls[now.second].l;
					if(L[_r[ls[now.second].l]] > 0 || ff[ls[now.second].l] == 1)
					{
						dr[to] = 0;
					}
					else
					{
						if(a[to] < bb[ls[now.second].l])
						s.insert(make_pair(l - bb[ls[now.second].l] + a[to], ls[now.second].l));
						else
						s.insert(make_pair(a[to] - bb[ls[now.second].l], ls[now.second].l));
						dr[to] = ls[now.second].l;
						_r[ls[now.second].l] = to;
					}
				}
			}
			else
			{
				int to = _l[now.second];
				int jl = 0;
				if(a[to] > bb[now.second])
				jl = l + bb[now.second] - a[to];
				else
				jl = bb[now.second] - a[to];
				if(jl != now.first)continue;
				-- L[to];
				if(L[to] < 0)
				{
					_l[now.second] = 0;
					continue;
				}
				if(ff[now.second] == 1)continue;
				ff[now.second] = 1;
//				printf("%d %d\n", now.second, to);
				ans ^= now.second * to;
				if(L[to] == 0)
				{
					re(to, now);
				}
				else
				{
					ls[ls[now.second].l].r = ls[now.second].r;
					ls[ls[now.second].r].l = ls[now.second].l;
					if(L[_l[ls[now.second].r]] > 0 || ff[ls[now.second].r] == 1)
					{
						dl[to] = 0;
					}
					else
					{
						if(a[to] > bb[ls[now.second].r])
						s.insert(make_pair(l + bb[ls[now.second].r] - a[to], ls[now.second].r));
						else
						s.insert(make_pair(bb[ls[now.second].r] - a[to], ls[now.second].r));
						dl[to] = ls[now.second].r;
						_l[ls[now.second].r] = to;
					}
				}
			}
	}
	printf("%lld", ans);
}
```


---

## 作者：kkkstra (赞：6)

[广告：蒟蒻的博客](https://www.cnblogs.com/newbielyx/p/12039885.html)

# Description

[传送门](https://www.luogu.com.cn/problem/P5688)

# Solution

## 算法1 32pts

枚举每个时刻，并枚举所有发生的时间，暴力进行更新。发现最多只需要枚举到第
$L$个时刻，因为是一个环，所以最多到第L个时刻，所有人就会回到原位。

## 算法2 52pts

发现在上面的过程中，并没有必要枚举每个时刻，因为很多时刻都是没有任何事件发生的。容易想到先预处理出距离每个人最近的出口，以及到出口的距离，那么每次取**到出口距离最小**的人，必定从那个出口出去。

设$rest_i$表示每个出口剩余可以通过的人数，当一个人从某个出口$i$出去后，则$rest_i-1$，那么当一个出口的$rest_i=0$时，那么这个出口就没有了存在的意义，可以直接删掉。

不难想到通过某种数据结构来维护每个出口的前驱和后继，我这里用的是环状链表，当然机房大佬也有用并查集以及$set$实现的。所以先预处理出每个出口的前驱和后继，分别记为$lst_i$和$nxt_i$

考虑当一个人从出口$i$出去后，那么对于所有原本要从$i$出去的人，逆时针走的人的出口都变成了$nxt_i$，顺时针走的人的出口都变成了$lst_i$。

于是得到一个做法，用堆维护每个人到离他最近的出口的距离和编号，堆里以距离为第一关键字、人的编号为第二关键字进行排序，每次取出堆顶。若当前记录的出口已经被删除，那么就将关于这个人的新的出口、距离信息插入到堆中；否则将这个人计入到答案的贡献中，并更新出口是否被删除以及前驱$lst_i$和后继$nxt_i$的相关信息。

因为每个人最坏情况下可能会被插入堆中$n$次，因此时间复杂度是$O(n^2\log n)$

## 算法3 100pts

考虑优化算法2，发现主要的时间都花费在更新每个人到出口的距离信息上

记出口$i$的位置为$pos_i$。可以发现，当一个出口被删除后，那么所有位置在$(pos_{lst_i},pos_{i}]$之间且逆时针行走的人，其出口都变成了$nxt_i$，且距离的增量都是$pos_{nxt_i}-pos_i$；同样的，对于所有位置在$[pos_i, pos_{nxt_i})$之间的且顺时针行走的人，其出口都变成了$lst_i$，且距离的增量都是$pos_i-pos_{lst_i}$

于是想到用线段树来维护，进行区间修改，具体实现为：在算法2的基础上，以每个人的位置为关键字进行排序，原来取堆顶的操作改成查询线段树的最小值，而距离的更新则先用二分查找查找出需要更新的位置对应的线段树区间，并按照上述过程进行更新即可。

至于区分逆时针顺时针行走的人，既可以建立两棵线段树，也可以在按每个人的位置为关键字之前先按找行走方向为关键字进行排序，然后将线段树一分为二。

具体的实现细节以及技巧可以参照下面的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int ty() {
	char ch = getchar(); int x = 0, f = 1;
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}

const int _ = 2e5 + 10;
int n, m, L, ct1, ct2, pos[_], lim[_], nxt[_], lst[_], num[_];

struct node {
	int id, dir, pos, dis, tar;
	node(int _id = 0, int _dir = 0, int _pos = 0, int _dis = 0, int _tar = 0) {
		id = _id, dir = _dir, pos = _pos, dis = _dis, tar = _tar;
	}
	bool operator<(const node &rhs) const {
		if (dir == rhs.dir) return pos < rhs.pos;
		return dir < rhs.dir;
	}
} sta[_];

#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid ((l + r) >> 1)

struct data {
	int dis, tar, id;
	data(int _dis = 0, int _tar = 0, int _id = 0) {
		dis = _dis, tar = _tar, id = _id;
	}
	bool operator<(const data &rhs) const {
		if (dis == rhs.dis) return id < rhs.id;
		return dis < rhs.dis;
	}
};

struct TAG {
	int dis, tar;
	TAG(int _dis = 0, int _tar = 0) { dis = _dis, tar = _tar; }
	TAG& operator+=(const TAG &rhs) {
		dis += rhs.dis;
		if (rhs.tar) tar = rhs.tar;
		return *this;
	}
};

struct SegmentTree {
	data val[_ << 2];
	TAG tag[_ << 2];
	void add(int p, TAG x) {
		val[p].dis += x.dis;
		if (x.tar) val[p].tar = x.tar;
		tag[p] += x;
	}
	void down(int p) {
		if (tag[p].dis || tag[p].tar) {
			add(ls, tag[p]);
			add(rs, tag[p]);
			tag[p] = TAG(0, 0);
		}
	}
	void up(int p) { val[p] = min(val[ls], val[rs]); }
	void build(int p, int l, int r) {
		if (l == r) {
			val[p] = data(sta[l].dis, sta[l].tar, sta[l].id);
			return;
		}
		build(ls, l, mid);
		build(rs, mid + 1, r);
		up(p);
	}
	data query(int p, int l, int r, int x, int y) {
		if (x <= l && r <= y) return val[p];
		down(p);
		if (y <= mid) return query(ls, l, mid, x, y);
		else if (x > mid) return query(rs, mid + 1, r, x, y);
		else return min(query(ls, l, mid, x, mid), query(rs, mid + 1, r, mid + 1, y));
	}
	void change(int p, int l, int r, int x) {
		if (l == r) {
			val[p].dis = 0x3f3f3f3f;
			return;
		}
		down(p);
		if (x <= mid) change(ls, l, mid, x);
		else change(rs, mid + 1, r, x);
		up(p);
	}
	void modify(int p, int l, int r, int x, int y, TAG z) {
		if (x <= l && r <= y) {
			add(p, z);
			return;
		}
		down(p);	
		if (y <= mid) modify(ls, l, mid, x, y, z);
		else if (x > mid) modify(rs, mid + 1, r, x, y, z);
		else modify(ls, l, mid, x, mid, z), modify(rs, mid + 1, r, mid + 1, y, z);
		up(p);
	}
} tr;

#undef ls
#undef rs
#undef mid

inline int getdis(int x, int y, int dir) {
	if (dir == 0) {
		if (pos[x] < pos[y]) return pos[y] - pos[x];
		else return L - pos[x] + pos[y];
	} else {
		if (pos[x] > pos[y]) return pos[x] - pos[y];
		else return pos[x] + L - pos[y];
	}
}

inline bool judge(int x, int y, int l, int r) {
	return sta[x].pos >= l && sta[x].pos <= r && sta[y].pos >= l && sta[y].pos <= r;
}

inline void modify(int l, int r, int dis, int tar, int dir) {
	node tmp;
	int L = (dir == 0) ? 1 : ct1 + 1;
	int R = (dir == 0) ? ct1 + 1 : n + 1;
	tmp.dir = dir, tmp.pos = l;
	int st = lower_bound(sta + L, sta + R, tmp) - sta;
	tmp.pos = r;
	int ed = upper_bound(sta + L, sta + R, tmp) - sta - 1;
	if (judge(st, ed, l, r))
		tr.modify(1, 1, n, st, ed, TAG(dis, tar));
}

inline void update1(int l, int r, int dis, int tar, int dir) {
	if (l > r) {
		modify(l + 1, L, dis, tar, dir);
		modify(0, r, dis, tar, dir);
	} else modify(l + 1, r, dis, tar, dir);
}

inline void update2(int l, int r, int dis, int tar, int dir) {
	if (l > r) {
		modify(l, L, dis, tar, dir);
		modify(0, r - 1, dis, tar, dir);
	} else modify(l, r - 1, dis, tar, dir);
}

int main() {
#ifndef ONLINE_JUDGE
	freopen("walk.in", "r", stdin);
	freopen("walk.out", "w", stdout);
#endif
	n = ty(), m = ty(), L = ty();
	pos[1] = 0, lst[1] = m, nxt[1] = 2;
	for (int i = 2; i <= m; ++i) {
		pos[i] = ty();
		nxt[i] = i == m ? 1 : i + 1;
		lst[i] = i - 1;
	}
	for (int i = 1; i <= m; ++i) lim[i] = ty();
	for (int i = 1; i <= n; ++i) {
		int s = ty(), b = ty(), d, t;
		if (s == 0) {
			++ct1;
			t = lower_bound(pos + 1, pos + m + 1, b) - pos;
			if (t > m) t = 1, d = L - b;
			else d = pos[t] - b;
		} else {
			++ct2;
			t = upper_bound(pos + 1, pos + m + 1, b) - pos;
			--t;
			d = b - pos[t];
		}
		sta[i] = node(i, s, b, d, t);
	}
	sort(sta + 1, sta + n + 1);

	for (int i = 1; i <= n; ++i) num[sta[i].id] = i;
	tr.build(1, 1, n);
	int out = m, pp = n;
	long long ans = 0;
	while (out && pp) {
		data x = tr.query(1, 1, n, 1, n);
		int id = x.id, tar = x.tar;
		tr.change(1, 1, n, num[id]);
		ans ^= (1ll * id * tar);
		--pp, --lim[tar];
		if (!lim[tar]) {
			int l = pos[lst[tar]] % L, r = pos[nxt[tar]] % L, now = pos[tar] % L;

			update1(l, now, getdis(tar, nxt[tar], 0), nxt[tar], 0);
			update2(now, r, getdis(tar, lst[tar], 1), lst[tar], 1);

			nxt[lst[tar]] = nxt[tar];
			lst[nxt[tar]] = lst[tar];
			--out;
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：XLao (赞：4)

发现题解区都实现得比较长，就来提供一份自认为比较清秀的实现。同时说明一下怎样的优先队列复杂度正确。

---

### 思路

第一思路是堆维护每个人离它最近出口的距离。

已满的出口 可能多次重复入堆（这好解决）

但快要满的出口也会重复入堆：可以想象一组数据，每个出口容量为 1，然后所有人都从起点开始逆时针走。那样所有人会在所有出口都入队一次，退化成平方对数。

### 做法

容易发现我们不一定要维护**每个人**离他最近出口的距离。我们的注意力可以只放在那些**有可能下一个离开**的人身上。

什么意思呢，就是说假设 3 位置有一个出口，1 和 2 位置各有一人向 3 走。那么我们可以不关心 1 位置的人离他最近出口有多远，等 2 位置走到了再来看 1 位置。

维护两个链表：

一个按环上逆时针顺序，存放 所有逆时针走的人 和 当前未满的出口。

另一个按环上顺时针顺序，存放 所有顺时针走的人 和 当前未满的出口。

我们堆里放的就是“nxt 为出口”的那些人。

每次删除的时候只要看看会不会新产生“nxt 为出口”的人，顺手入堆就可以了。

细节：一开始建链表的时候，要注意位置相同该是谁在前面的问题（顺逆时针略有不同）。

### 复杂度证明

这时候代码里还是有 `if(ed[x] || !b[z]) continue;` 这句话，为什么复杂是对的呢？

首先 `if(ed[x]) continue` 是因为删掉出口的时候还没删掉人，可能把 最后从该出口离开的那个人 判定成 nxt=出口。至多发生 $m$ 次，其实可以通过精细实现避开但没必要。

其次 `if(!b[z]) continue` 发生当且仅当与我反方向的那个人占走了该出口的最后一个位置。每发生一次必然伴随着一个出口的湮灭，至多发生 $m$ 次。

换句话说，每个出口湮灭的时候，堆里至多有一个人觊觎这个出口（一定是反方向的，会使那个人出堆的时候发生一次这种 `continue`），所以至多发生 $m$ 次。

要是 `continue` 没发生，堆大小 -1。所以总体复杂度是线性对数。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define pii pair<int,int>
#define mkp make_pair
#define fr first
#define sc second
#define pb emplace_back
#define data dara
int read()
{
	char c=getchar(); int res=0, f=1;
	while(!isdigit(c)) {if(c=='-') f=-1; c=getchar();}
	while(isdigit(c)) {res=(res<<3)+(res<<1)+(c^48); c=getchar();}
	return res*f;
}
const int N=4e5+1;

int n,m,L,s[N],b[N],tp[N],ed[N];
pii X[N]; int tt; vector<pii> A[2];

struct data
{
	int x,y,z;
	bool operator < (const data &y) const {
		return z==y.z ? x>y.x : z>y.z;
	}
};
priority_queue<data> q;

struct lianbiao
{
	pii nxt[N],lst[N];
	void link(int x,int y,int z) // x->y : z.
	{
		x=abs(x), y=abs(y);
		nxt[x]=mkp(y,z), lst[y]=mkp(x,z);
		if(x<=n && y>n) q.push((data){x,y,z});
	}
	void erase(int x)
	{
		link(lst[x].fr, nxt[x].fr, lst[x].sc+nxt[x].sc);
	}
} D[2];
int main()
{
	n=read(), m=read(), L=read();
	for(int i=2;i<=m;++i) s[i]=read();
	for(int i=1;i<=m;++i) b[i]=read();
	for(int i=1,k,x;i<=n;++i) k=read(), x=read(), A[k].pb(mkp(x,i)), tp[i]=k;
	
	tt=0;
	for(int i=1;i<=m;++i) X[++tt]=mkp(s[i],n+i);
	for(auto p : A[0]) X[++tt]=mkp(p.fr,-p.sc);
	sort(X+1,X+tt+1);
	for(int i=1;i<tt;++i)
		D[0].link(X[i].sc, X[i+1].sc, X[i+1].fr-X[i].fr);
	D[0].link(X[tt].sc, X[1].sc, L-X[tt].fr);
	// 逆时针链表
   
	tt=0;
	for(int i=1;i<=m;++i) X[++tt]=mkp(s[i],-n-i);
	for(auto p : A[1]) X[++tt]=p;
	sort(X+1,X+tt+1);
	for(int i=1;i<tt;++i)
		D[1].link(X[i+1].sc, X[i].sc, X[i+1].fr-X[i].fr);
	D[1].link(X[1].sc, X[tt].sc, L-X[tt].fr);
	// 顺时针链表
   
	int cnt=m;
	while(cnt && !q.empty())
	{
		data now = q.top(); q.pop();
		int x=now.x, y=now.y, z=y-n;
		if(ed[x] || !b[z]) continue;
		ed[x]=z, --b[z];
		if(!b[z]) D[0].erase(y), D[1].erase(y), --cnt;
		D[tp[x]].erase(x);
	}
	long long ans=0;
	for(int i=1;i<=n;++i) ans^=1ll*i*ed[i];
	printf("%lld\n",ans);
}
```

---

## 作者：pikiuk (赞：4)

这种题显然是在模拟过程中使用数据结构加速，因此考虑朴素的模拟过程。

一种显然的想法是，我们对每个人维护他当前的第一个出口和他距离这个出口的距离，每次取出距离最小的人，如果某个出口被删除，那么我们就重构所有以这个出口为目标出口的人的状态。

直接暴力维护的复杂度是 $\mathcal{O}(nm)$，不难发现瓶颈在于“重构”上，而更新出口间的距离和顺序状态可以容易的用链表或并查集实现。

不过“重构”是很难优化的，我们更希望把所谓“重构”改写成加法等简单运算的修改操作。很好的是，我们有如下性质：

- 按初始状态的目标出口和方向作为二元组划分等价类，那么在每一类内，相同等价类的人的目标出口相同。
- 对于每次“重构”，本质上是针对若干个等价类内的点进行整体加某个数的形式。
- 每次删除某个出口后，只会合并相邻出口代表的等价类。

不难按初始等价类进行排序，使得等价类相同的节点相邻，且出口相邻的等价类在序列上也相邻，那么每次重构相当于进行一次区间加法，且同一个等价类的人在序列上一定是一个区间。

而查询当前离目标出口距离最小的人相当于线段树上查询最小值及其位置，并删除这个点。显然我们可以把删除替代为“加无穷大”，那么至此这个问题可以用线段树简单维护。



---

## 作者：0xyz (赞：1)

这一题其实不算太难，码量也不大。

一个 $O(nm)$ 的做法是每一轮都寻找离任一出口最近的人，并且将他删掉，同时将他离开的门耐久度 $-1$，如果耐久度到了 $0$ 就把这个门也删掉。至多 $n$ 轮之后就不能再删除人了。容易发现暴力重构是 $O(n+m)$ 的，所以可以用环状双向链表优化，这样删掉一个人或门变为 $O(1)$ 的。

具体来讲，我们可以将所有门和逆时针的所有人排好序放在一个链表里，将所有门和顺时针的所有人排好序放在另一个链表里。每一轮都找到这两个链表中距离任一门最近的人中编号最小的那个，在对应连表里删掉这个人，如果门的耐久度降为 $0$，再在两个链表里均删掉这个门。

现在的瓶颈就在于如何快速地求出距离任一门最近的人。我们可以在建造两个链表时用优先队列存储在链表中下一个元素就是门的所有人。每次删除一个人或者一个门我们就考虑一下有没有让一个人的下一个元素变为一个新的门，如果有，加入优先队列即可。

注意到建造链表时优先队列中一共最多 $n$ 个元素，每次删除也至多让一个人进队，每一轮至多删除 $3$ 次，所以优先队列的进队次数不超过 $4n$，出队次数也不超过 $4n$，所以时间复杂度是 $O(n\log n)$。

代码仅 1.4kb。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int _=4e5+5,inf=2e9;
ll s;
int n,m,L,a[_],b[_],d[_],e[_],i,z;
struct nb{
	int x,y,z;
	bool operator <(const nb v)const{return x==v.x?y>v.y:x>v.x;}//这是为了让大根堆距离小的和编号小的在根
}o,w;
struct lst{
	int l[_],r[_],t;//l 存储上一个元素，r 存储下一个元素，t 存储顺逆时针
	vector<nb>p;//x 存储从 0 开始逆时针的距离，y 存储门的编号或 m+人的编号，z 存储顺逆时针
	priority_queue<nb>q;//x 存储和下一个门的距离，y 存储 m+人的编号，z 存储顺逆时针
	int dis(int x){//求出第 x-m 个人距离他下一个门的距离
		z=a[r[x]]-d[x-m];
		if(t)z=-z;
		if(z<0)z+=L;
		return z;
	}
	void build(int ot){//建立环形双向链表
		t=ot;
		for(i=1;i<=m;i++)p.push_back({a[i],i,0});
		sort(p.begin(),p.end(),[&](nb u,nb v){return u.x==v.x?u.y>v.y:(u.x<v.x)^t;});//将人和门按照顺序排好
		p.push_back(p[0]);
		for(i=0;i<p.size()-1;i++){
			r[p[i].y]=p[i+1].y;l[p[i+1].y]=p[i].y;
			if(p[i].y>m&&p[i+1].y<=m)q.push({dis(p[i].y),p[i].y,t});
		}
	}
	void del(int x){//删除一个人或者一个门
		l[r[x]]=l[x];r[l[x]]=r[x];
		if(l[x]>m&&r[x]<=m)q.push({dis(l[x]),l[x],t});
	}
	nb find(){//寻找离任一门最近的人
		while(q.size()&&(e[(w=q.top()).y-m]||r[w.y]>m||w.x!=dis(w.y)))q.pop();//看一下这个人是否已经出门或者这个门已经被删除
		return q.size()?w:(nb){inf,0,0};
	}
}P[2];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>L;
	for(i=2;i<=m;i++)cin>>a[i];
	for(i=1;i<=m;i++)cin>>b[i];
	for(i=1;i<=n;i++)cin>>z>>d[i],P[z].p.push_back({d[i],m+i,1});
	P[0].build(0);P[1].build(1);
	while((o=max(P[0].find(),P[1].find())).x!=inf){//o 就是离任一门最近的人中编号最小的，之所以用 max 是因为重载了运算符
		e[o.y-m]=P[o.z].r[o.y];P[o.z].del(o.y);//标记人对应的门并删除这个人
		if(!--b[e[o.y-m]])P[0].del(e[o.y-m]),P[1].del(e[o.y-m]);//减门的耐久，可能要删除门
	}
	for(i=1;i<=n;i++)s^=1ll*i*e[i];//求答案，要开 long long
	cout<<s<<'\n';
	return 0;
}
```

---

## 作者：chenruikai (赞：1)

### 题意
题意很简单~~但是我把顺逆时针搞反了~~，不用多说，但需要注意 01 表示的行走方向。
### 思路
第一眼暴力模拟，把每个时刻一个个枚举过来，然后就出来，复杂度 $\Theta(nmT)$，$T$ 是时间。

第二眼~~妖怪我一眼看穿你不是暴力~~发现由于各位走的距离其实是一样的，很多时刻枚举是完全没有必要的，只有在有人出去的时刻才有必要，第一个走出去的人，明显就是距离最短的那个。至此，很明显已经可以想到使用堆了。维护每个人从起点到目标出口的距离（目标在满的时候是会变的，并不坚定）与当前走的距离，就可以快速搞出结果了。

第三眼发现交上去 TLE 了。有什么可以优化的？~~卡常~~观察代码，我们可以发现，有部分时间花在了找下一个没满的出口。手模一下，就会神奇的发现假如两个出口间有多个已满的，我们会重复判断这些东东有没满，时间 $\Theta(n)$。是可忍熟不可忍！解决的办法就是使用并查集的路径压缩（如果自己手推过并查集的路径压缩优化，这个还是挺好想的）。自己看代码吧（不要在意其中一些有点抽象的写法）。

100pts
```cpp
/*
for i : peo
{
    find nearest;
}
while(have space)
{
    find nearest;//use heap
    go dis;
    for peo
    {
        if arr exit
        {
            nearest = next;
        }
    }
}
*/
#include <bits/stdc++.h>
using namespace std;

#define debug 1
#define debugpart if(debug)
#define puterr(...) if(debug)printf(__VA_ARGS__)
#define putval(a , b) if(debug)cout << #a << " = " << a << b
struct pritype{int first;long long second;};
int pn , en , len;
int expos[200005] , lim[200005] , peopos[200005] , near[200005] , res[200005] , be[200005] , af[200005];
bitset <200005> s;//true => na
long long add;
int spcnt;
typedef pair <int , long long> pii;
int disof(int p , int e)
{
    if(s[p])
    {
        if(peopos[p] <= expos[e])return expos[e] - peopos[p];
        return len - peopos[p] + expos[e];
    }
    if(peopos[p] >= expos[e])return peopos[p] - expos[e];
    return len - expos[e] + peopos[p];
}
int nexte(int pos , bool a)
{
    queue <int> w;
    for(;lim[pos] == 0;pos = a ? af[pos] : be[pos])w.push(pos);
    for(;!w.empty();w.pop())*((a ? af : be) + w.front()) = pos;
    return pos;
}
bool operator < (pritype a , pritype b)
{
    if(a.second == b.second)return a.first > b.first;
    return a.second > b.second;
}
void work()
{
    for(int i = 0;i < pn;i++)res[i] = -1;
    priority_queue <pritype> w;
    for(int i = 0;i < pn;i++)
        w.push({i , disof(i , near[i])});
    spcnt = en , add = 0;
    while(spcnt && !w.empty())
    {
        add = w.top().second;
        for(;!w.empty() && w.top().second == add;w.pop())
        {
            int pos = w.top().first;
            if(lim[near[pos]] == 0)
            {
                near[pos] = nexte(near[pos] , s[pos]);
                w.push({pos , disof(pos , near[pos])});
            }
            else
            {
                lim[near[pos]]--;
                res[pos] = near[pos];
                if(!lim[near[pos]])spcnt--;
            }
        }
    }
}
int main()
{
    cin >> pn >> en >> len;
    for(int i = 1;i < en;i++)scanf("%d" , expos + i);
    for(int *p = lim;p != lim + en;)scanf("%d" , p++);
    int input = 0;
    for(int i = 0;i < pn;i++)
    {
        scanf("%d%d" , &input , peopos + i);
        s[i] = (input != 1);
    }
    for(int i = 0;i < pn;i++)
    {
        af[i] = (i == pn - 1 ? 0 : i + 1);
        be[i] = (i == 0 ? pn - 1 : i - 1);
    }
    int l , r , mid;
    for(int i = 0;i < pn;i++)
    {
        if(peopos[i] > expos[en - 1])
        {
            if(s[i])near[i] = 0;
            else near[i] = en - 1;
            continue;
        }
        l = 0 , r = en - 1;
        while(l < r)
        {
            if(s[i])
            {
                mid = (l + r) >> 1;
                if(expos[mid] >= peopos[i])r = mid;
                else l = mid + 1;
            }
            else
            {
                mid = (l + r + 1) >> 1;
                if(expos[mid] <= peopos[i])l = mid;
                else r = mid - 1;
            }
        }
        *(near + i) = l;
    }
    work();
    long long ans = (*res) + 1;
    for(int i = 1;i < pn;i++)
        ans ^= (1LL * (i + 1) * (res[i] + 1));
    cout << ans << '\n';
    return 0;
}
```
玥玥月月如今朝。

---


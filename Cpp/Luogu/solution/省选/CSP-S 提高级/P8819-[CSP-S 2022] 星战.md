# [CSP-S 2022] 星战

## 题目描述

在这一轮的星际战争中，我方在宇宙中建立了 $n$ 个据点，以 $m$ 个单向虫洞连接。我们把终点为据点 $u$ 的所有虫洞归为据点 $u$ 的虫洞。

战火纷飞之中这些虫洞很难长久存在，敌人的打击随时可能到来。这些打击中的有效打击可以分为两类：

1. 敌人会摧毁某个虫洞，这会使它连接的两个据点无法再通过这个虫洞直接到达，但这样的打击无法摧毁它连接的两个据点。
2. 敌人会摧毁某个据点，由于虫洞的主要技术集中在出口处，这会导致该据点的所有还未被摧毁的虫洞被一同摧毁。而从这个据点出发的虫洞则**不会摧毁**。

注意：摧毁只会导致虫洞不可用，而不会消除它的存在。

为了抗击敌人并维护各部队和各据点之间的联系，我方发展出了两种特种部队负责修复虫洞：

- A 型特种部队则可以将某个特定的虫洞修复。
- B 型特种部队可以将某据点的所有损坏的虫洞修复。

考虑到敌人打击的特点，我方并未在据点上储备过多的战略物资。因此只要这个据点的某一条虫洞被修复，处于可用状态，那么这个据点也是可用的。

我方掌握了一种苛刻的空间特性，利用这一特性我方战舰可以沿着虫洞瞬移到敌方阵营，实现精确打击。

为了把握发动反攻的最佳时机，指挥部必须关注战场上的所有变化，为了寻找一个能够进行反攻的时刻。总指挥认为：

- 如果从我方的任何据点出发，在选择了合适的路线的前提下，可以进行无限次的虫洞穿梭（可以多次经过同一据点或同一虫洞），那么这个据点就可以**实现反击**。
- 为了使虫洞穿梭的过程连续，尽量减少战舰在据点切换虫洞时的质能损耗，当且仅当**只有一个从该据点出发的虫洞可用**时，这个据点可以**实现连续穿梭**。
- 如果我方所有据点都可以**实现反击**，也都可以**实现连续穿梭**，那么这个时刻就是一个绝佳的**反攻**时刻。

总司令为你下达命令，要求你根据战场上实时反馈的信息，迅速告诉他当前的时刻是否能够进行一次**反攻**。

## 说明/提示

**【样例解释 \#1】**

虫洞状态可以参考下面的图片, 图中的边表示存在且未被摧毁的虫洞：

![](https://cdn.luogu.com.cn/upload/image_hosting/giqzyc7r.png)

**【样例 \#2】**

见附件中的 `galaxy/galaxy2.in` 与 `galaxy/galaxy2.ans`。

**【样例 \#3】**

见附件中的 `galaxy/galaxy3.in` 与 `galaxy/galaxy3.ans`。

**【样例 \#4】**

见附件中的 `galaxy/galaxy4.in` 与 `galaxy/galaxy4.ans`。

**【数据范围】**

对于所有数据保证：$1 \le n \le 5 \times {10}^5$，$1 \le m \le 5 \times {10}^5$，$1 \le q \le 5 \times {10}^5$。

| 测试点 | $n \le$ | $m \le$ | $q \le$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $10$ | $20$ | $50$ | 无 |
| $4 \sim 8$ | ${10}^3$ | ${10}^4$ | ${10}^3$ | 无 |
| $9 \sim 10$ | $5 \times {10}^5$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 保证没有 $t = 2$ 和 $t = 4$ 的情况 |
| $11 \sim 12$ | $5 \times {10}^5$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 保证没有 $t = 4$ 的情况 |
| $13 \sim 16$ | ${10}^5$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 无 |
| $17 \sim 20$ | $5 \times {10}^5$ | $5\times 10^5$ | $5 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
3 6
2 3
2 1
1 2
1 3
3 1
3 2
11
1 3 2
1 2 3
1 1 3
1 1 2
3 1 3
3 3 2
2 3
1 3 1
3 1 3
4 2
1 3 2
```

### 输出

```
NO
NO
YES
NO
YES
NO
NO
NO
YES
NO
NO
```

# 题解

## 作者：dbxxx (赞：626)

[欢迎到我的博客中查看本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p8819.html)

修改日志：2023 年 7 月 7 日更改，添加一些说明。

先翻译一下题目：

$n$ 个点 $m$ 条边的有向图，每条边都有激活和失活两种状态，初始时均为激活状态。四种操作：

1. 失活某条边；
2. 失活以某个点为终点的所有边；
3. 激活某条边；
4. 激活以某个点为终点的所有边。

然后问：如果只考虑激活的边，是否满足：

- 所有的点出度均为 $1$；
- 所有的点都满足，从这个点出发，可以走到一个环中。

---

首先我们发现，如果所有点的出度均为 $1$，那么所有点都满足从这个点出发能走到一个环里。这是因为所有点的出度都是 $1$，因此一条路径可以一直走下去，而只要走 $n$ 步就一定会遇到先前走过的一个节点（总共只有 $n$ 个点），此时环就出现了。

因此压根不用判环，只用判断所有点出度是否均为 $1$。

> 事实上，所有点出度均为 $1$ 的有向图称作基环内向森林，它由若干个弱联通块（将所有有向边看成无向边后的联通块）构成，每个弱联通块称作基环内向树。对于基环内向树，它可以被认为是由有向环和长在环上的若干条链构成。这些链单向导通到环上。更多有关定义可以自行阅读 [OI Wiki 的图论相关概念](https://oi-wiki.org/graph/concept/#特殊的图)。

我们观察到，一、三操作可以用 $\mathcal{O}(1)$ 的效率修改一个点的出度（修改目标边的终点出度即可），而二、四操作只能用 $\mathcal{O}(n)$ 的效率（因为终点为 $v$ 的边有很多，对应的起点最多有 $n$ 个，它们的出度都需要被修改）。

不过，前 8 个测试点，是支持我们用最坏时间复杂度 $\mathcal{O}(nq)$ 的暴力维护出度的，所以 40 分已经到手。

然后 9 和 10 两个测试点还是保证没有二、四操作的。单次操作可以做到 $\mathcal{O}(1)$。因此这两个测试点用 $\mathcal{O}(q)$ 的复杂度解决，50 分到手。

这里是我的 [50 分代码](https://www.luogu.com.cn/paste/8j8uc74u)。

---

思考许久后我发现，容易维护的不是出度，而是入度。具体来说：

设原图上点 $u$ 的入度为 $g(u)$，当前点 $u$ 入度为 $r(u)$：

1. 失活 $(u, v)$：$r(v) \gets r(v) - 1$；
2. 失活以 $v$ 为终点的所有边：$r(v) \gets 0$；
3. 激活 $(u, v)$：$r(v) \gets r(v) + 1$；
4. 激活以 $v$ 为终点的所有边：$r(v) \gets g(v)$。

这些都可以 $\mathcal{O}(1)$ 完成。

那么入度和出度有什么关系呢？

一张图里，所有点的入度和等于出度和。我们的目标是所有出度都是 $1$，那么所有出度的和都是 $n$。因此入度的和也必须是 $n$。

于是我们得到所有出度均为 $1$ 的一个必要条件：入度和为 $n$。然而这个条件并不充分，因为入度和为 $n$ 可以推出出度和为 $n$，但不能再进一步推出所有出度均为 $1$。

比如，如果有三个点，点 $1$ 出度为 $2$，点 $2$ 出度为 $1$，点 $3$ 没有出度，我们如果单纯地去计算它的入度和，发现它等于 $n$，就判断现在每个点出度都是 $1$，这明显是错误的。

但是，我们可以利用 **哈希** 使得这个条件的充分性有极大概率是正确的，进一步使得这个条件的充要性极大概率正确，通过本题。

---

我们初始给每个点随机一个权值 $w(u)$。重新定义，一个点 $v$ 对应的 $r(v)$，表示直接连向 $v$ 的所有 $u$ 的 $w(u)$ 之和，即：
$$
r(v) = \sum_{(u, v) \in E}w(u)
$$
而 $g(v)$ 代表初始所有边都被激活时的 $r(v)$ 的值，且之后不改变（静态）。

重新设计：

1. 失活 $(u, v)$：$r(v) \gets r(v) - w(u)$；
2. 失活以 $v$ 为终点的所有边：$r(v) \gets 0$；
3. 激活 $(u, v)$：$r(v) \gets r(v) + w(u)$；
4. 激活以 $v$ 为终点的所有边：$r(v) \gets g(v)$。

这个过程中，所有点的 $r$ 值之和 $\sum r(u)$ 可以在每次操作时 $\mathcal{O}(1)$ 地维护。更进一步地：

- 设 $\{u_1, u_2, \ldots\}$ 是 $v$ 的入点集合，则 $r(v) = w(u_1) + w(u_2) + \ldots$。理由是 $r(v)$ 的定义。 
- 如果所有点 $u$ 的出度都是 $1$，那么 $u$ 只会出现在它所连向的 $v$ 的入点集合中。因此，将所有入点集合的权值加起来，即 $\sum r(u)$，我们应该恰好得到 $\sum w(u)$。也即，$\sum r(u) = \sum w(u)$。

因此，$\sum r(u) = \sum w(u)$ 是每个点出度都为 $1$ 的一个必要条件。那么，这个条件充分吗？

一般地，我们设点 $u$ 的出度为 $k(u)$，意味着 $w(u)$ 恰好在最终的 $\sum r(u)$ 中出现 $k(u)$ 次。也即 $\sum r(u) = \sum k(u) \times w(u)$。因此我们可以将判断条件 $\sum r(u) = \sum w(u)$ 改写为：$\sum k(u) \times w(u) = \sum w(u)$。

显然所有 $k(u) = 1$ 是一个解。有其它的解吗？

有，但是这样的一组 $k$ 跟 $w$ 高度相关，除非出题人精心构造数据使得目前的局面形成的 $k$ 存在一个不等于 $1$ 还恰好满足这个方程，否则你可以认为当这个方程成立的时候，目前的 $k$ 都等于 $1$。

又因为你的 $w$ 是随机的，所以数据是没法对着你的代码卡的，除非你的 $w$ 正好随机到一个能把你代码卡掉的数据，这种可能太小了基本可以忽略不计，因为随机的值域已经相当大了。

这就是哈希的原理了：判定时构造一个必要不充分条件，但这个“不充分”实际上有非常大非常大的概率充分，以至于不充分性可以忽略不计，从而达到充要判定的效果。读者应当熟悉的字符串哈希，也是同样的原理。

这种哈希似乎一般称作“和哈希”（sum hash）。

```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2022-10-31 05:16:58 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2022-10-31 05:23:44
 */
#include <bits/stdc++.h>
#define int long long
inline int read() {
    int x = 0;
    bool flag = true;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-')
            flag = false;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    if(flag)
        return x;
    return ~(x - 1);
}

const int maxn = (int)5e5 + 5;

int r[maxn], w[maxn], g[maxn];

signed main() {
    int n = read(), m = read();

    std :: mt19937 rng(time(0));
    
    for (int u = 1; u <= n; ++u)
        w[u] = rng(); // 这个函数生成随机数的范围和 unsigned int 范围一致，会爆 int。当然你也可以 % 一下
    
    int tar = std :: accumulate(w + 1, w + n + 1, 0LL);
    // 这是求和函数，注意 0 后面要加 LL （否则会爆）

    int now = 0;
    while (m--) {
        int u = read(), v = read();
        r[v] += w[u];
        g[v] = r[v];
        now += w[u];
    }

    int q = read();
    while (q--) {
        int t = read();
        if (t == 1) {
            int u = read(), v = read();
            r[v] -= w[u];
            now -= w[u];
        } else if (t == 2) {
            int v = read();
            now -= r[v];
            r[v] = 0;
        } else if (t == 3) {
            int u = read(), v = read();
            r[v] += w[u];
            now += w[u];
        } else if (t == 4) {
            int v = read();
            now += g[v] - r[v];
            r[v] = g[v];
        }

        puts(now == tar ? "YES" : "NO");
    }

    return 0;
}
```

如果觉得这篇题解写得好，请不要忘记点赞，谢谢！

---

## 作者：Cxny (赞：95)

## Preface

这是一个不配在考场上想出随机化的蒟蒻。

## Solution

发现“**可实现连续穿梭**”等价于每个点出度恰好为 $1$，而“**可实现反击**”等价于从每个点出发可以走到一个环。

每个点出度为 $1$ 使得图上恰好有 $n$ 条边，而每个点恰好能走到一个环。因此，满足条件的图是**内向基环树森林**，环外的点直接或间接地指向环上的点。

而形成内向基环树森林的充要条件是**每个点出度恰好为 $1$**。

~~所以“可实现反击”就是一句废话。~~

然后赛时到这里就不会了，打个暴力跑路。（

---

发现一个很强的性质：

由于满足条件的图只有 $n$ 条边，**所有点出度均为奇数等价于所有点出度均为 $1$**。

考虑反证法。若存在点的出度 $\ge 3$，那么 $\sum_{i=1}^ndeg_i>\sum_{i=1}^n1=n$，矛盾。

因此，我们就能将较难维护的出度恰好为 $1$ 转换成边数恰好为 $n$ 并且所有点的度数均为奇数。

边数很好维护，不再赘述。

对于奇偶性判断，自然想到**异或**。我们可以考虑维护所有**度数为偶数的点编号的异或和**，判断时直接看异或和是否为 $0$ 即可。

而直接异或编号很容易被卡，因此考虑给每个点赋上**随机权值**。

具体地，维护每个点的入度和**可以到达该点的点的权值的异或和**，动态修改并判断**出度为偶数的点的**异或和是否为 $0$ 即可。

比暴力好写。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define Fin(qwq) freopen(qwq, "r", stdin)
#define Fout(qwq) freopen(qwq, "w", stdout)
#define Fio(qwq) Fin(qwq".in"), Fout(qwq".out")
using namespace std;
const int maxn = 5e5 + 10;
mt19937 gen(time(0));
uniform_int_distribution<int> rnd(0, 1e9);
int n, m, q, deg[maxn], a[maxn];
int val[maxn], sum[maxn], qwq[maxn], cur[maxn], tot, res;
int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) a[i] = rnd(gen); // printf("%d ", a[i]); puts("");
	for(int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y);
		deg[x]++, qwq[y]++, sum[y]++, tot++, val[y] ^= a[x], cur[y] ^= a[x];
	}
	for(int i = 1; i <= n; i++) if(!(deg[i] & 1)) res ^= a[i]; 
	scanf("%d", &q);
	while(q--){
		int opt, x, y;
		scanf("%d%d", &opt, &x);
		if(opt == 1 || opt == 3) scanf("%d", &y);
		if(opt == 1){
			tot--, res ^= a[x];
			qwq[y]--, cur[y] ^= a[x];
		}else if(opt == 2){
			tot -= qwq[x], res ^= cur[x];
			qwq[x] = cur[x] = 0;
		}else if(opt == 3){
			tot++, res ^= a[x];
			qwq[y]++, cur[y] ^= a[x];
		}else if(opt == 4){
			tot += (sum[x] - qwq[x]), res ^= (cur[x] ^ val[x]);
			qwq[x] = sum[x], cur[x] = val[x];
		}
		// printf("%d - %d\n", tot, res);
		puts(tot == n && (!res) ? "YES" : "NO");
	}
	return 0;
}

```

---

## 作者：xfrvq (赞：44)

[$\tt Link$](/problem/P8819 "葬送了我的 CSP（大悲）")。

## 简要题意

有一个 $n$ 个点 $m$ 条有向边的图，每条边有可用和不可用两个状态。有 $q$ 个操作：

+ 操作 $\tt1$：让一条可用的边变得不可用
+ 操作 $\tt2$：让一个点的所有入边中，可用的变得不可用
+ 操作 $\tt3$：让一条不可用边变得重新可用
+ 操作 $\tt4$：让一个点的所有入边中，不可用的变得可用

每次操作之后，如果同时满足

+ 条件 $\tt1$：从每个点开始都可以无限的沿着可用边（有向）走下去。
+ 条件 $\tt2$：每个点只有一条出边可用

就输出 `YES`，否则输出 `NO`。

## 60 分的部分分

暴力太简单不讲。

首先我们分析条件 $\tt2$，发现这应该是一棵内向基环树。

而内向基环树是一个环上挂着若干棵儿子向父亲连有向边的树，每个点可以先沿着有向边走上环，然后在环上无限走。**所以必然满足条件 $\tt1$。**

那么最后只需要判断条件 $\tt2$ 即可。

我们维护一个出度数组。发现**操作 $\tt1$ 和 $\tt3 $ 对出度数组的改变都是 $O(1)$ 的**。于是暴力模拟出度数组的变化并动态维护出度为 $1$ 的点的个数，拿到 $\tt50pts$。

然后发现如果只有操作 $\tt2$，**$q$ 次操作一共只会最多删掉 $O(m)$ 条边，对出度数组产生最多 $O(m)$ 的改变**。所以同上，结合均摊分析，拿到 $\tt60pts$。

虽然笔者的思考止步于此，但是我拿的分可不止 $\tt60pts$。

于是靠着官方数据用脚造以及官方少爷机的神速，$\tt85pts$ 翻身了。

[评测链接](https://www.luogu.com.cn/record/93237896 "民间数据 60 分整，官方数据洛谷机 75 分")。

## 正解

对条件 $\texttt{1,2}$ 的分析还是同上。但 $\texttt{2,4}$ 操作并不是暴力模拟。

我们对每个点定义一个权值，它是一个随机数。

然后对于每一个点 $v$，记录 $a_v=\sum w_u[\text{exist }\texttt{edge}\{u\to v\}]$。

然后操作 $\texttt{1,3}$ 就让 $a_v$ 减去或加上 $w_u$。

操作 $\texttt{2,4}$ 记录原来的 $a$ 数组 $a^\prime$，然后让 $a_u\gets0$ 或者 $a_u\gets a^\prime_u$。

在更改的过程中动态维护 $\sum a_u$ 的值。

如果 $\sum a_u=\sum w_u$，那么每个点只有一个出边。

## 总结

用到了哈希的思想，正解写起来比 $\tt60pts$ 代码还短。

哈希思维难度大于部分分？但是想下来其实挺简单的。果然自己的思维还是有不足之处。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e5 + 5;

int n,m,q,a[N];
long long to[N],sum[N],tot,ans;

int main(){
	mt19937 rnd(time(0));
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;++i) ans += (a[i] = rnd());
	for(int i = 1,u,v;i <= m;++i)
		scanf("%d%d",&u,&v),to[v] += a[u],sum[v] = to[v],tot += a[u];
	scanf("%d",&q);
	for(int i = 1,t,u,v;i <= q;++i){
		scanf("%d%d",&t,&u);
		if(t == 1) scanf("%d",&v),to[v] -= a[u],tot -= a[u];
		if(t == 2) tot -= to[u],to[u] = 0;
		if(t == 3) scanf("%d",&v),to[v] += a[u],tot += a[u];
		if(t == 4) tot += sum[u] - to[u],to[u] = sum[u];
		puts(tot == ans ? "YES" : "NO");
	}
	return 0;
}
```

---

## 作者：JiaY19 (赞：15)

[更好的阅读体验](https://cjmfeitveer.github.io/2022/11/07/P8819%20%5BCSP-S%202022%5D%20%E6%98%9F%E6%88%98%20%E9%A2%98%E8%A7%A3/)

### 思路

考前练习了特别多的随机权题目，~~但是考场上考了我们整个机房都没做出来~~。

通读题目，发现如果当前可以进行反攻了，只有此时的所有点的出度均为一。

考虑它的四个操作。

1. 给某个点减一。
2. 给某个集合的点减一。
3. 给某个点加一。
4. 给某个集合的点加一。

考虑使用 $\text{sum Hash}$。

将每一个点都附一个随机的权值。

那么发现所有点的出度均为一就是所有点的权值和。

可以维护一个点的集合的权值，以及所有的总权值和。

其中每个点的集合的权值，就是所有指向他的权值的和。

我们动态的维护这两个东西，就可以 $O(n)$ 的处理操作了。

具体的看代码吧。

### Code

```cpp
#include <bits/stdc++.h>
#define N 500010

using namespace std;

int n , m , q , i;
unsigned long long sum , ans , val[N] , pos[N] , pos2[N];
pair<int , int> e[N];

int main()
{
    srand(time(0)) , cin >> n >> m;
    for(i = 1;i <= n;i++)
        val[i] = rand() , sum += val[i];
    for(i = 1;i <= m;i++)
    {
        cin >> e[i].first >> e[i].second;
        ans += val[e[i].first]; //全部的权值
        pos[e[i].second] += val[e[i].first]; //每个点的集合的权值。
    }
    for(i = 1;i <= n;i++)
        pos2[i] = pos[i];
    cin >> q;
    for(i = 1;i <= q;i++)
    {
        int opt; cin >> opt; int op = (opt == 1 || opt == 2 ? -1 : 1);
        if(opt == 1 || opt == 3) 
        { 
            int x , y; cin >> x >> y; 
            if(opt == 1) pos[y] -= val[x] , ans -= val[x];
            else pos[y] += val[x] , ans += val[x];
        }
        if(opt == 2 || opt == 4) 
        { 
            int x;  cin >> x;
            if(opt == 2) ans -= pos[x] , pos[x] = 0;
            else ans += pos2[x] - pos[x] , pos[x] = pos2[x]; 
        }
        puts(sum == ans ? "YES" : "NO"); //判断是否合法。
    }
}
```

---

## 作者：vectorwyx (赞：15)

赛时第一眼想到的思路。

首先题意等价于判断所有点的出度是否均为 $1$。那么有一个必要条件是所有点的出度之和等于点数。而这个是好维护的，记 $c_x$ 表示当前 $x$ 的入度，$d_x$ 表示最开始时 $x$ 的入度，$m'$ 表示当前所有点的出度之和。那么删除 $x,y$ 这条边带来的影响是 $m'$ 减一，$c_y$ 减一，加入 $x,y$ 这条边反之。删除 $x$ 这个点的所有入边带来的影响是 $m'$ 减 $c_x$，$c_x$ 变成 $0$，恢复 $x$ 的所有入边带来的影响是 $m'$ 增加 $d_x-c_x$，$c_x$ 变成 $d_x$。然后只需要判断 $m'$ 与 $n$ 是否相同。

但只有这一个必要条件显然不够，因为会有类似 $\{0,2\}$ 这种情况。考虑从点集中随出 $30$ 个子集，依次检验这些子集中的点的出度之和是否等于子集大小，在第一个必要条件成立的前提下，这样的正确率非常高，至少我不会卡。那么就在修改前先随出 $30$ 个集合，套用上文的维护方法即可，复杂度 $O(30(n+m+q))$。

这个方法实际上等价于哈希，感谢管理员指正。具体地，考虑如何加速这个过程，由于每个集合中一条边带来的贡献只有 $\pm 1$，我们可以把这  $30$ 个集合状压成一个，如果点 $x$ 在第 $i$ 个集合中出现了那么把涉及到它的一条边的贡献视为 $2^i$，然后直接加和。这里低位会贡献到高位，不过没太大关系，相当于对这 $30$ 个集合又做了一遍哈希。

代码如下：
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){int ch=getchar(),x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=5e5+5;
struct Graph{
int n,m,deg[N],c[N],ok[N];
//n:初始的点数
//m:目前有意义的边的数量 
//c[i]:目前有多少条有意义的边指向 i
//deg[i]:初始时有多少条有意义的边指向 i 
void outit(){
	printf("n=%d m=%d\n",n,m);
	cout<<"deg:";out(deg,1,3);
	cout<<"c:";out(c,1,3);
	cout<<"ok:";out(ok,1,3);
}
void ins(int x,int y){
	if(!ok[x]) re;
	m++,c[y]++;
}
void del(int x,int y){
	if(!ok[x]) re;
	m--,c[y]--;
}
void ban(int x){//删掉所有指向 x 的边 
	m-=c[x];
	c[x]=0;
}
void back(int x){//恢复所有指向 x 的边 
	m+=deg[x]-c[x];
	c[x]=deg[x];
}
}a[31];
int n,m;
vector<int> e[N];

signed main(){
	cin>>n>>m;//int lg=(int)log2(n)+1;//lg=0;
	int lg=30;
	fo(i,1,m){
		int x=read(),y=read();
		e[x].pb(y);
	}
	a[0].n=n;
	fo(i,1,n){
		a[0].ok[i]=1;
//		for(int j:e[i]) a[0].ins(i,j),a[0].deg[j]++;
	}
	fo(i,1,n){
		int x=rnd();
		fo(j,1,lg) if(x>>j&1){
			a[j].ok[i]=1;
			a[j].n++;
		}
	}
	fo(i,1,n) for(int j:e[i]) fo(k,0,lg) a[k].ins(i,j);
	fo(i,0,lg) fo(j,1,n) a[i].deg[j]=a[i].c[j];
//	fo(i,0,lg) printf("%d:",i),a[i].outit();
	int q=read();
	while(q--){
		int o=read(),x=read();
		if(o==1||o==3){
			int y=read();
			fo(i,0,lg){
				if(o==1) a[i].del(x,y); 				
				else a[i].ins(x,y); 				
			}
		}else fo(i,0,lg){
			if(o==2) a[i].ban(x);
			else a[i].back(x); 
		}
//		fo(i,0,lg) printf("%d:",i),a[i].outit();
		int flg=1;fo(i,0,lg) if(a[i].n!=a[i].m){flg=0;break;}
		puts(flg?"YES":"NO");
	}
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：cmk666 (赞：13)

[题目传送门](/problem/P8819)

场上没想出来，我是什么彩笔。

发现只要判定每次每个点出度为 $1$ 且从每个点出发都能走到环即可。

但其实后面那个条件是废的，因为每个点出度为 $1$ 一定是内向基环树森林，怎么可能走不到环，所以只需判断每个点出度是否为 $1$。

发现好像没什么数据结构可以维护，考虑随机权值的哈希。

但是判 $1$ 不好做，不如把条件转化成点数等于边数且所有点出度全为奇数。

这样维护当前边数和每条边起点的异或和就行了。

具体的，给每个点赋一个 $[0,2^{64})$ 的随机权值，并在每一个点上维护其完好、不完好入边的条数以及完好、不完好入边的起点的权值异或和，当更改单条边时直接修改，当更改所有边时将其中一个变为 $0$ 即可。

时间复杂度 $O(n+m+q)$。核心代码如下：
```cpp
int n, m, q, op, u, v, c[500009], d[500009];
ull a[500009], f[500009], g[500009], nw, ok; mt19937_64 rnd(time(nullptr));
int main()
{
	read(n), read(m);
	For(i, 1, n) ok ^= a[i] = rnd();
	For(i, 1, m) read(u), read(v), g[v] ^= a[u], nw ^= a[u], c[v]++;
	read(q); For(qq, 1, q)
	{
		read(op), read(u);
		if ( op == 1 )
			read(v), g[v] ^= a[u], f[v] ^= a[u], nw ^= a[u], m--, c[v]--, d[v]++;
		if ( op == 3 )
			read(v), g[v] ^= a[u], f[v] ^= a[u], nw ^= a[u], m++, c[v]++, d[v]--;
		if ( op == 2 )
			f[u] ^= g[u], nw ^= g[u], g[u] = 0, m -= c[u], d[u] += c[u], c[u] = 0;
		if ( op == 4 )
			g[u] ^= f[u], nw ^= f[u], f[u] = 0, m += d[u], c[u] += d[u], d[u] = 0;
		puts(m == n && nw == ok ? "YES" : "NO");
	}
	return 0;
}
```

---

## 作者：yzy1 (赞：11)

### 题目大意

维护有向图 $G = (V,E)$（$1 \le |V| \le 5\times 10^5$，$1 \le |E| \le 5 \times 10^5$）．每条边有「被标记」和「不被标记」两种状态，初始所有边均为「被标记」状态．维护 $q$（$0 \le q \le 5\times 10^5$）个操作，分为若干种：

- 给定一条边 $e \in E$，将 $e$ 修改为「被标记」状态．
- 给定一个结点 $v \in V$，将 $v$ 的所有入边修改为「被标记」状态．
- 给定一条边 $e \in E$，将 $e$ 修改为「未被标记」状态．
- 给定一个结点 $v \in V$，将 $v$ 的所有入边修改为「未被标记」状态．

每次操作后，判断 $G$ 中所有「被标记」的边对应的生成子图是否为一个基环内向树森林．

### 简要做法

有向图是内向基环树森林的一个充要条件是所有点出度均为 $1$．考虑维护每个结点的出边数量，发现由于有 $4$ 操作存在，较难维护．

考虑更换维护方式．维护所有被标记的边的起点的组成的可重集合，则有向图是内向基环树森林的一个充要条件是每个结点恰好在该集合种出现一次．对于每个结点 $u$，维护其所有被标记的入边的起点组成的可重集合 $S_u$，则答案集合 $A$ 为所有可重集合的 [Sum](https://en.wikipedia.org/wiki/Multiset)$^{[1]}$．此时，题目中的四种操作变为对于某个集合的添加元素、删除元素、清空、还原初始状态四种操作．

考虑采用哈希来维护答案集合．考虑对于原图中的每个结点 $u$ 创建随机的权值 $a_u$．定义对于可重点集的哈希函数 $H(S) = \sum_{u\in S} a_u$．则题目中的四种操作可转化为为对哈希值的加减运算：

- $H(A) \gets H(A) + a_{\operatorname{start}(e)}$．
- $H(A) \gets H(A) - H(S_u) + H(S'_u)$，$H(S_u) \gets H(S'_u)$．
- $H(A) \gets H(A) - a_{\operatorname{start}(e)}$．
- $H(A) \gets H(A) + H(S_u)$，$H(S_u) \gets 0$．

时间复杂度 $O(n+m+q)$．

### 注释

- \[1\]：可重集合的 Sum 运算和并运算不同，Sum 运算是将所有元素出现次数相加，而并运算为取 $\max$．具体见 [Multiset - Wikipeida](https://en.wikipedia.org/wiki/Multiset)．

---

## 作者：StayAlone (赞：10)

### 思路

容易发现，符合“反攻”时，这个图是一个内向基环树森林。

于是，判断这个图是否合法，可以转换为判断**所有边的起点构成的可重点集中，$1\sim n$ 中的每个点是否恰好出现一次。**

考虑维护这个集合的哈希值之和。具体做法是对于每一个点随机一个初始权值 $w_i$，每一次操作后计算出当前这个点集的权值和，判断它是否与 $\sum\limits_{i = 1}^n w_i$ 相等。若相等，则认为这两个集合完全相同，即输出 `YES`，否则输出 `NO`。

下面详细解释一下如何维护。

规定一些变量：

1. $w_i = \operatorname{rand}()$
1. $sumw=\sum_{i = 1}^n w_i$ 
2. $snow$ 表示对于当前的图，所有边的起点的 $w$ 之和
4. $horg_u$ 表示对于初始的图，所有终点为 $u$ 的边的起点的 $w$ 之和
5. $hnow_u$ 表示对于当前的图，所有终点为 $u$ 的边的起点的 $w$ 之和  

这里的权值使用 $\rm mt19937$ 获得，范围在 $[0, 2^{32} - 1]$，所以无需取模，开 long long 求和即可，也更能保证准确率。

#### 操作 1

摧毁 $u\to v$ 的边。这条边起点为 $u$，终点为 $v$，所以 $horg_v$ 少了一个 $w_u$，同时 $snow$ 也少了一个 $w_u$。

#### 操作 2

摧毁仍然存在的终点为 $u$ 的所有边。这就是 $hnow_u$ 的值，所以 $snow$ 减去 $hnow_u$，再 $hnow_u\leftarrow 0$。

#### 操作 3

和 操作 1 几乎没有区别，反过来即可。

#### 操作 4

修复已经摧毁的，终点为 $u$ 的边。此时 $snow$ 需要加上 $horg_u - hnow_u$，再 $hnow_u\leftarrow horg_u$。  
最后判断 $snow$ 与 $sumw$ 是否相等即可。

时间复杂度 $\Theta(n + m + q)$。  

代码中上述的变量均多了一维，表示多套哈希以提高正确率。不过实测一套即可通过。  


```cpp
#include <bits/stdc++.h>
#define rep1(i, l, r) for (int i = l; i <= int(r); ++i)
#define rep2(i, l, r) for (int i = l; i >= int(r); --i)
#define ptc putchar
#define il inline
#define eb emplace_back
#define mp make_pair
#define rout return 0
using namespace std;
typedef long long ll;
const int MAXN = 5e5 + 10, inf = ~0U >> 2, INF = ~0U >> 1;
namespace stupid_lrc {

}
using namespace stupid_lrc;
int n, m, q;
ll sumw[5], w[5][MAXN], hnow[5][MAXN], horg[5][MAXN], snow[5];

il bool check() {
	rep1(k, 0, 1) if (sumw[k] ^ snow[k]) return false;
	return true;
}

int main() {
	mt19937 rand(time(0)); read(n, m);
	rep1(i, 1, n) {
		rep1(k, 0, 1) w[k][i] = rand(), sumw[k] += w[k][i];
	}
	rep1(i, 1, m) {
		int u, v; read(u, v);
		rep1(k, 0, 1) horg[k][v] += w[k][u], snow[k] += w[k][u];
	}
	rep1(k, 0, 1) rep1(i, 1, n) hnow[k][i] = horg[k][i];
	for (int Q = read(), op, u, v; Q--; ) {
		read(op);
		if (op == 1) {
			read(u, v);
			rep1(k, 0, 1) hnow[k][v] -= w[k][u], snow[k] -= w[k][u];
		} else if (op == 2) {
			read(u);
			rep1(k, 0, 1) snow[k] -= hnow[k][u], hnow[k][u] = 0;
		} else if (op == 3) {
			read(u, v); 
			rep1(k, 0, 1) hnow[k][v] += w[k][u], snow[k] += w[k][u];
		} else {
			read(u);
			rep1(k, 0, 1) snow[k] += horg[k][u] - hnow[k][u], hnow[k][u] = horg[k][u];
		}
		puts(check() ? "YES" : "NO");
	}
	rout;
}
```

[在这个结尾，不要脸地放上我 CSP2022 的思考与汗泪。](https://www.luogu.com.cn/blog/liangruichenBlog/csp-2022-you-ji)

---

## 作者：OrezTsim (赞：7)

挺 nb 的一道题。

考场没想到，大失败。

会的都会，不会的怎么都不会了属于是。

首先看到每一个点只能恰好连一条边，也就是整张图内点的出度均为 $1$。

则最后状态为 $n$ 个点、$n$ 条边。

这是整张图为基环树森林的充分条件。

因为出度只能为 $1$，想到随机赋点权来判断整张图是否为基环树森林。

如果不为基环树森林，那么直接输出 NO。

接着，我们就保证了整张图的每一个点出度为 $1$，且其为基环树森林。

此时可以想一想，每一个子连通块内可以变为一个环和连在上面的一堆链。

考虑到出度必须为 $1$，这些链只能一致指向环的某个节点。

那么这个连通块内的每一个点都能到达一个环。

换句话说，第二个条件是第一个条件的充分条件。

即“点的出度均为 $1$” $\rightarrow$ “可以到达环”。

没了。第一个条件是诈骗。

随机权值，维护两个数组，一个表示当前剩余的权值，一个表示当前丢失的权值。

注意 $u \rightarrow v$ 的贡献 $val_u$ 要记到 $v$ 头上。

```cpp
#include <bits/stdc++.h>
using ull = unsigned long long;
using namespace std;

const int N = 5e5 + 10;
int n, m, q; mt19937_64 rnd(998244853);
ull stnd, tmp, val[N], sum[N], _sum[N];

inline void solve() {
	int op, u, v; scanf("%d%d", &op, &u);
	if (op == 1) scanf("%d", &v), tmp -= val[u], sum[v] -= val[u], _sum[v] += val[u];
	else if (op == 2) tmp -= sum[u], _sum[u] += sum[u], sum[u] = 0;
	else if (op == 3) scanf("%d", &v), tmp += val[u], sum[v] += val[u], _sum[v] -= val[u];
	else tmp += _sum[u], sum[u] += _sum[u], _sum[u] = 0;
	puts(tmp == stnd? "YES" : "NO"); return ;
}

int main() {
	scanf("%d%d", &n, &m); for (int i = 1; i <= n; ++i) stnd += (val[i] = rnd());
	for (int i = 1, u, v; i <= m; ++i) scanf("%d%d", &u, &v), sum[v] += val[u], tmp += val[u];
	scanf("%d", &q); while (q--) solve();
	return 0;
}
```

---

## 作者：蒟蒻丁 (赞：5)

[更好的体验](https://www.cnblogs.com/caijiLYC/p/16868795.html)  
首先可以观察出一个性质，只要每个点的出度都是 1，这个图就是一个内向奇环树，也就是说只要每个点出度为 1，那么该情况就是合法的。然后考虑怎么动态维护每个点的出度。  

这里我们使用一个哈希，用一个值记录当前每个点的出度大小为多少，当这个值和“每个点出度为 1”这个状态的值一样的时候就是合法的值了。设出度为 $ou$ 数组，定义哈希函数 $cur=\sum_{i=1}^n p^i \times ou_i $ ，那么目标情况的哈希值就是 $fin=\sum_{i=1}^n p^i $。  
当一条边 $e_{i,j}$ 被毁，我们就给 $cur$ 减去 $p^i$ ，同理，当 $e_{i,j}$ 被重建就给 $cur$ 加上 $p^i$ ，对于全体摧毁和全体重建，我们记录一个数组 $pas_j$ 表示每一条以 $j$ 为终点的边被摧毁时，对 $cur$ 减值的总和，即 $pas_j=\sum p^i$ ，其中边 $e_{i,j}$ 被摧毁。再记录一个数组 $in_j$ 表示一开始的时候每条以 $j$ 为终点的边对 $cur$ 的贡献的总和，即 $in_j=\sum p^i$ ，其中边 $e_{i,j}$ 存在。那么集体摧毁的时候 $cur$ 就应当减去 $in_j-pas_j$ ，集体修复同理。具体可以参考代码，代码中为了求稳使用了双哈希。  

另：由于本蒟蒻恶臭习惯，喜欢把出边和入边反过来写，所以代码里面 $in$ 和 $ou$ 含义交换。
```c++11
#include<iostream>
#include<cstdio>
#include<cstring>
typedef long long ll;
using namespace std;
const ll N=6e5,p0=23333,mod1=998244353,mod2=1e9+7;
ll n,m,in[N],qu;

struct Pair{
	ll x,y;
	Pair operator *(const ll&tmp )const{
		Pair c;
		c.x=x*tmp%mod1,c.y=y*tmp%mod2;
		return c;
	}
	Pair operator +(const Pair&tmp )const{
		Pair c;
		c.x=(x+tmp.x)%mod1,c.y=(y+tmp.y)%mod2;
		return c;
	}
	Pair operator -(const Pair&tmp )const{
		Pair c;
		c.x=(x-tmp.x+mod1)%mod1,c.y=(y-tmp.y+mod2)%mod2;
		return c;
	}
	void clear(){x=0,y=0;}
}p[N],sam,cur,pas[N],ou[N];

int main(){
	cin>>n>>m;
	p[0].x=p[0].y=1;
	for(ll i=1;i<=n;i++)p[i]=p[i-1]*p0;
	for(ll i=1;i<=m;i++){
		ll a1,a2;
		scanf("%lld%lld",&a1,&a2);
		in[a1]++,ou[a2]=ou[a2]+p[a1];
	}
	for(ll i=1;i<=n;i++)sam=sam+p[i];
	for(ll i=1;i<=n;i++)
		cur=cur+(Pair){p[i].x*in[i]%mod1,p[i].y*in[i]%mod2};
	cin>>qu;
	for(ll i=1;i<=qu;i++){
		ll a1,a2,a3;
		scanf("%lld",&a1);
		if(a1==1){
			scanf("%lld%lld",&a2,&a3);
			cur=cur-p[a2];
			pas[a3]=pas[a3]+p[a2];
		}
		if(a1==2){
			scanf("%lld",&a2);
			cur=cur-ou[a2];
			cur=cur+pas[a2];
			pas[a2]=ou[a2];
		}
		if(a1==3){
			scanf("%lld%lld",&a2,&a3);
			cur=cur+p[a2];                                                                                                                       
			pas[a3]=pas[a3]-p[a2];
		}
		if(a1==4){
			scanf("%lld",&a2);
			cur=cur+pas[a2];
			pas[a2].clear();
		}
		if(cur.x==sam.x&&cur.y==sam.y)printf("YES\n");
		else printf("NO\n");
	}
}
```

---

## 作者：tmuxvs5t (赞：4)



### Part 1

首先我们来明确一下题意。

不难发现，题里就是让我们支持几个删边和加边的操作，并且需要我们输出每次操作之后是否能满足**每个点出度均为1，并且都能到达一个环。**

就像这样：

[![xoHDmj.png](https://s1.ax1x.com/2022/10/31/xoHDmj.png)](https://imgse.com/i/xoHDmj)

通过这个图我们不难发现，只要每个点的出度都为1，最后一个点**无论指向哪**都会形成环，所以只需**每个点出度为1**即可。

-----------------------------------

### Part 2

我们发现形势仍不容乐观，因为2、4操作要求修改以v为**终点**的**所有边**。

如果我们想要维护出度，那简直是太困难了：

``` 既不连续也不单调，有科技log都做不到。 ```

但是考虑到**他们的终点**相同，我们可以很方便的 $O(1)$ 维护入度。

于是我们考虑入度在满足什么样的条件时，结论成立。

还是刚才的图：

[![xob0C6.png](https://s1.ax1x.com/2022/10/31/xob0C6.png)](https://imgse.com/i/xob0C6)

我们考虑把出度转化为入度，当然就要看看出度去哪了。可以观察到，每个点**唯一的出度去到了其他点身上**，并且这些点的入度**囊括了所有出度**。

很显然，我们可以维护每个点的入度是多少，进行桶统计。

然而。。。小样例过不去。。。

这是为什么呢。

看看这个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/giqzyc7r.png)

在**最终状态**中，我们看到每个点的入度的确都为1，但是出度呢？

有一个点的出度为2，把另一个点的出度**寄了出去**。

然后思路就假了。

然后。。就没有然后了。。。。

于是这篇题解就鸽掉了。

--------------------------------------

### Part 3

不！思路没假！！

只不过没有用这道题的精华部分——**哈希**！！

我们给每一个点**一个初始值作为出度**，这样就可以统计出**入度和**中**不同点的差别了**！

于是，我们只需要维护一个简单的哈希和，进行比对即可。

不得不说，还是比较巧妙的啊！~~领悟到了绝处逢生，柳暗花明的精辟。~~

代码：

```cpp
#define rep(a,b,c) for(int a=b;a<=c;a++)
#define per(a,b,c) for(int a=b;a>=c;a--)
#define fe(a,n) for(int a=1;a<=n;a++)
#define ef(a,n) for(int a=n;a>=1;a--)
#define pb push_back
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
#define int long long
const int N=5e5+10;
vector<int> g[N];
int n,m;
int va[N],rd[N],_rd[N];
int ans,tar;
mt19937 mt;
const int MOD=998244353;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    rep(i,1,m){
        int u,v;cin>>u>>v;
        g[u].pb(v);
    }rep(i,1,n){
        va[i]=mt()%MOD+1;
    }
    rep(i,1,n){
        for(auto k:g[i]){
            rd[k]+=va[i];
        }
    }
    rep(i,1,n)_rd[i]=rd[i];
    for_each(rd+1,rd+n+1,[](auto i){ans+=i;});
    for_each(va+1,va+n+1,[](auto i){tar+=i;});
    int q;cin>>q;
    rep(i,1,q){
        int t;cin>>t;
        int u,v;
        if(t==1){
            cin>>u>>v;
            rd[v]-=va[u];
            ans-=va[u];
        }else if(t==2){
            cin>>u;
            ans-=rd[u];
            rd[u]=0;
        }else if(t==3){
            cin>>u>>v;
            rd[v]+=va[u];
            ans+=va[u];
        }else{
            cin>>u;
            ans+=(_rd[u]-rd[u]);
            rd[u]=_rd[u];
        }
        cout<<((ans==tar)?"YES\n":"NO\n");
    }
}
```

# MT19937真牛逼，不开time(0)也不见祖宗

---

## 作者：yukimianyan (赞：4)

## problem
一个 $n$ 个点 $m$ 条边的有向图，$q$ 次操作：
- 删除一条边，保证存在；
- 增加一条边，保证不存在；
- 删除一个点的所有入边；
- 将一个点曾经有的入边全部恢复。

每次操作后判断：
- 从任意一个节点出发，是否能走无限步；
- 对于任意一个节点，是否满足这个节点只有唯一的一条出边。

$n,m,q\leq 10^6$。

## solution
首先我们发现“从任意一个节点出发，是否能走无限步”是假的。
>如果第二条“对于任意一个节点，它只有唯一的一条出边”成立，那么从一个点出发，可以沿着它的出边一直走，不可能走到一个没有出边的点。

所以我们只需要判断，$\forall out_i=1$。相当于判断：
- 若 $E$ 是当前存在的边集，则 $|E|=n$。（这个点可以保证 $\oplus$ 不会受到 $>1$ 条边的影响）
- 对于每个点 $u$，都存在 $(u\to v)\in E$。

这里对于第二个点的判断方法是 hash。给每个点赋权值 $w_i$ 后，动态维护 $\sum_{(u\to v)\in E}w_u$ 或者 $\oplus_{(u\to v)\in E}w_u$，判断每次操作后是否有 $\sum_{(u\to v)\in E}w_u=\sum_u w_u$ 即可。

观察到 $+,\oplus$ 具有可减性，那么我们可以动态维护点 $u$ 的所有入边的 hash 值 $h_u$，进行 2,4 操作时将维护的 hash 值减掉 / 加上即可。具体实现建议看代码。

## code
```cpp
#include <cstdio>
#include <cstring>
#include <random>
#include <ctime>
#include <algorithm>
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
template<int N,int M,class T=int> struct graph{
    int head[N+10],nxt[M*2+10],cnt;
    struct edge{
        int u,v;T w;
        edge(int u=0,int v=0,T w=0):u(u),v(v),w(w){}
    } e[M*2+10];
    graph(){memset(head,cnt=0,sizeof head);}
    edge operator[](int i){return e[i];}
    void add(int u,int v,T w=0){e[++cnt]=edge(u,v,w),nxt[cnt]=head[u],head[u]=cnt;}
    void link(int u,int v,T w=0){add(u,v,w),add(v,u,w);}
};
int n,m,q,tot;
mt19937_64 rng(time(0));
ULL w[500010],sum,h[500010],inn[500010],tar[500010],ind[500010];
int main(){
//	#ifdef LOCAL
//	 	freopen("galaxy4.in","r",stdin);
//	 	freopen("galaxy4.out","w",stdout);
//	#endif
	for(int i=1;i<=5e5;i++) w[i]=rng();
	scanf("%d%d",&n,&m),tot=m;
	for(int i=1,u,v;i<=m;i++) scanf("%d%d",&u,&v),sum^=w[u],h[v]^=w[u],inn[v]++;
	memcpy(tar,h,sizeof tar);
	memcpy(ind,inn,sizeof ind);
	for(int i=1;i<=n;i++) tar[0]^=w[i];
	scanf("%d",&q);
	for(int op,u,v;q--;){
		scanf("%d%d",&op,&u);
		if(op==1) scanf("%d",&v),h[v]^=w[u],sum^=w[u],inn[v]--,tot--;
		else if(op==3) scanf("%d",&v),h[v]^=w[u],sum^=w[u],inn[v]++,tot++;
		else if(op==2){
			tot-=inn[u],sum^=h[u];
			inn[u]=h[u]=0;
			tot+=inn[u],sum^=h[u];
		}else if(op==4){
			tot-=inn[u],sum^=h[u];
			inn[u]=ind[u],h[u]=tar[u];
			tot+=inn[u],sum^=h[u];
		}
		puts(tot==n&&sum==tar[0]?"YES":"NO");
	}
	return 0;
}

```


---

## 作者：Gao_yc (赞：3)

Tips:本蒟蒻在赛时没有想到这个相当简单的解法，解法是看[讲评](https://www.bilibili.com/video/BV1ne4y127S4/?spm_id_from=333.788&vd_source=ca73831f86e4b89e559701d10d9df82a)总结而来。

## Solution：

题目中“能进行反攻”的两个条件其实只有一个：每个点的出度为 $1$。

定义目前图中每条边出点构成的可重集 $A$，则符合条件时，这个可重集为 $\left \{ 1,2,3, \cdots n \right \} $（定义其为答案可重集 $R$ ）

那么怎么判断目前的可重集 $A$ 是否等于答案可重集 $R$ 呢？可以给可重集进行哈希。**随机**出数组 $h$，记录可重集中每个数在 $h$ 中映射的和与异或和（即可重集 $A$ 的哈希值为 $\sum_{x \in A}^{} h_x$ 与 $\oplus_{x \in A} h_x$）。然后只要判断这两个哈希值是否相等即可。

而由于要对于一个点的所有入边，我们还要记录所有点入边的出点的 $h$ 之和与异或和，初始与当前都要记。（$x_v= \oplus_{\left \{ u,v \right \} \in E} h_u$，$s_v = \sum_{\left \{ u,v \right \} \in E}h_u$）

然后看每种操作要如何更改。

设当前可重集的两个哈希值分别为 $xsum$ 与 $sum$，$x$、$s$ 数组的初始值为 $xx$、$ss$。

### 删边：

$xsum=xsum \oplus h_u,sum=sum - h_u$。

$x_v=x_v \oplus h_v,s_v=s_v - h_u$。

#### 删一个点的所有入边

$xsum=xsum \oplus x_u,sum=sum-s_u$。

$x_u=0,s_u=0$。

### 重建边

与删边差不多。

### 重建一个点的所有入边

$xsum=xsum \oplus xx_u \oplus x_u,sum=sum+ss_u-s_u$。

$x_u=xx_u,s_u=ss_u$。


------------

时间复杂度 $\mathcal{O}(n+m+q)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5+10;
const int mod=1e8+7;
int n,m,h[N];
ll rrrandom(){
	ll x_1=rand(),x_2=rand();
	return x_1*x_2%mod;
}//随机数。
ll xsum,sum,res_xsum,res_sum,xx[N],ss[N],x[N],s[N];
//res_xsum、res_sum表示答案可重集的哈希值；xsum、sum表示目前可重集的哈希值。
//xx、ss表示初始的；x、s表示当前的。 
int main()
{
//	freopen("galaxy.in","r",stdin);
//	freopen("galaxy.out","w",stdout);
	srand(time(NULL));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) h[i]=rrrandom();
	for(int i=1,u,v;i<=m;++i) 
	{
		scanf("%d%d",&u,&v);
		xsum^=h[u];sum+=h[u];
		x[v]^=h[u],s[v]+=h[u];
	}
	for(int i=1;i<=n;++i) res_xsum^=h[i],res_sum+=h[i],xx[i]=x[i],ss[i]=s[i];
	int q,t,u,v;scanf("%d",&q);
	while(q--){
		scanf("%d%d",&t,&u);
		if(t==1){
			scanf("%d",&v);
			xsum^=h[u];sum-=h[u];
			x[v]^=h[u],s[v]-=h[u];
		}
		else if(t==2){
			xsum^=x[u],sum-=s[u];
			x[u]=s[u]=0;
		}
		else if(t==3){
			scanf("%d",&v);
			xsum^=h[u];sum+=h[u];
			x[v]^=h[u],s[v]+=h[u];
		}
		else{
			xsum^=(xx[u]^x[u]),sum+=ss[u]-s[u];
			x[u]=xx[u],s[u]=ss[u];
		}
		puts(((xsum==res_xsum)&&(sum==res_sum))?"YES":"NO");
	}
    return 0;
}

```


---

## 作者：Mobius127 (赞：3)

[link](https://www.luogu.com.cn/problem/P8819)

~~我为什么会在赛时想图论分块。。。。~~

~~什么神仙会想到哈希维护啊~~

首先手玩一下满足条件的图，只需要满足条件二：所有点出度为 1，条件 1 会自然满足，我们必然可以顺着其出边走下去。

对于操作 2 和 4，我们无法快速维护所有点的出度是否均为 $1$，所以考虑把入度压成一个字符串，最后我们匹配是否与 $111111...$ 相等。

看到这种大修改，整体判等的操作，hash 不失为一种优秀的方法。

我们给每个点随机一个权值 $w_i$，那么整个串就是 $\sum_{i=1}^{n} w_i\times in_i$，其中 $\sum$ 可以是异或和、正常求和、$p$ 进制下和等。

对于单边修改，暴力即可。

对于修改一个点 $x$ 的所有入边，考虑先预处理出 $a_x=\sum_{(y, x)\in G} w_y$，我们将上次整体修改 $x$ 到这次操作之间所有关于 $x$ 的操作逆回去，然后减去/加上 $a_x$，这样均摊复杂度 $O(m)$。

那么这题就做完了。。。

[code](http://119.27.163.117/submission/34402) 用的是异或和。

---

## 作者：Leasier (赞：2)

第二次看到 XOR Hashing 这个技巧了，但赛时没想到 /kk

------------

首先“实现反击”等价于图上每个点都可以到达至少一个环，“实现连续穿梭”等价于图上每个点出度为 $1$。

不难想到“实现连续穿梭”等价于这张图为一个基环内向树森林，而此时这张图就一定满足“实现反击”了。

于是我们只需要满足图上每个点出度为 $1$ 即可。

赛时一直在想根号分治，但没啥思路 /kk

事实上，我们可以考虑对每个点随机一个权值，当前整个图的权值为所有边的起点的权值之和，则我们只需要判断当前全图权值是否为所有点权值之和即可。

$1, 3$ 操作是容易处理的，$2, 4$ 操作可以直接维护每个点为终点的当前权值。

时间复杂度为 $O(n + m + q)$。如果担心被卡可以多随机几次并把答案取 $\operatorname{and}$。

代码：
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef long long ll;

int val[500007];
ll full[500007], cur[500007];

inline int rand32(){
	return rand() * rand();
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

int main(){
	int n = read(), m = read(), q;
	ll goal = 0, sum = 0;
	srand(time(NULL));
	for (register int i = 1; i <= n; i++){
		val[i] = rand32();
		goal += val[i];
	}
	for (register int i = 1; i <= m; i++){
		int u = read(), v = read();
		full[v] += val[u];
	}
	for (register int i = 1; i <= n; i++){
		cur[i] = full[i];
		sum += full[i];
	}
	q = read();
	for (register int i = 1; i <= q; i++){
		int t = read(), u = read();
		if (t % 2 == 1){
			int v = read();
			if (t == 1){
				cur[v] -= val[u];
				sum -= val[u];
			} else {
				cur[v] += val[u];
				sum += val[u];
			}
		} else if (t == 2){
			sum -= cur[u];
			cur[u] = 0;
		} else {
			sum += full[u] - cur[u];
			cur[u] = full[u];
		}
		if (sum == goal){
			printf("YES\n");
		} else {
			printf("NO\n");
		}
	}
	return 0;
}
```

---


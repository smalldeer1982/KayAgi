# [HNOI2009] 有趣的数列

## 题目描述

我们称一个长度为 $2n$ 的数列是有趣的，当且仅当该数列满足以下三个条件：

- 它是从 $1 \sim 2n$ 共 $2n$ 个整数的一个排列 $\{a_n\}_{n=1}^{2n}$；

- 所有的奇数项满足 $a_1<a_3< \dots < a_{2n-1}$，所有的偶数项满足 $a_2<a_4< \dots <a_{2n}$；

- 任意相邻的两项 $a_{2i-1}$ 与 $a_{2i}$ 满足：$a_{2i-1}<a_{2i}$。

对于给定的 $n$，请求出有多少个不同的长度为 $2n$ 的有趣的数列。  
因为最后的答案可能很大，所以只要求输出答案对 $p$ 取模。

## 说明/提示

【数据范围】   
对于 $50\%$ 的数据，$1\le n \le 1000$；  
对于 $100\%$ 的数据，$1\le n \le 10^6$，$1\le p \le 10^9$。

【样例解释】   
对应的 $5$ 个有趣的数列分别为$(1,2,3,4,5,6),(1,2,3,5,4,6),(1,3,2,4,5,6),(1,3,2,5,4,6),(1,4,2,5,3,6)$。

## 样例 #1

### 输入

```
3 10```

### 输出

```
5```

# 题解

## 作者：zhzh2001 (赞：52)

> 洛谷上很多省选题都没有题解，不得不找`bzoj`的题解

# 概述


## 50%

使用递推，在$O(n^2)$的时间内得到答案，~~不过我没写对~~。


## 正解


通过暴力或者上述方法，打印出较小的答案，可能会发现规律。实际上这题就是求`Catalan数`(n-2)，有很多理解方式，常见的求法有三种（参见[百度百科](http://baike.baidu.com/link?url=FWVuxp\_2ZbEGv0Y6Ar3TjhvP4pBc-GALZCcGHaobWlC-G9ewCtX0V\_VZ2aBthUGJIY6gsJ6uyS88FC769FYhKt02eP-lkEtMm16qypxPntLmSAm8rU1TfeuITSZP2ioJ\_9z7O1-qXyR5o8YnfuTqbOgXwRb17hyyB0I5C-S0tKg2b22yiWepoyojjOl3HjZ-) ）：


1. $f_n=\sum\limits_{i=0}^{n-1}f_i*f_{n-i-1}$ ，不能使用这个公式，因为也需要$O(n^2)$

2. $f_n=f_{n-1}*\frac{4n-2}{n+1}$ ，我本来以为可以用的，但是**由于$p$不一定是一个质数**，因此无法计算逆元以进行除法运算

3. $f_n=\frac{C_{2n}^{n}}{n+1}$ ，这是可用的公式


如果不熟悉组合数的求法，可以做一下[计算系数](https://www.luogu.org/problem/show?pid=1313) ，总结中给出代码。


其中$\frac{C_{2n}^{n}}{n+1}=\frac{\prod\limits_{i=n+2}^{2n}i}{\prod\limits_{i=1}^ni}$，我们需要把所有$2n$之内的质数筛出来，同时得到每个数最小的质因数（欧拉线性筛法），进行约分再使用快速幂[^qpow]得出结果。


# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000005;
//注意是2*n
int mp[N],p[N/10],cnt[N],r;
//mp[]表示每个数最小的质因数，p[]表示质数表，cnt[]用于计算指数，r为取模数
int qpow(int a,int b)
//快速幂：计算a^b%r
{
    int ans=1;
    do
    {
        if(b&1)
            ans=(long long)ans*a%r;
        a=(long long)a*a%r;
    }
    while(b/=2);
    return ans;
}
int main()
{
    int n;
    cin>>n>>r;
    int pn=0;
    for(int i=2;i<=2*n;i++)
    {
        if(!mp[i])
        {
            p[++pn]=i;
            mp[i]=i;
        }
        for(int j=1;j<=pn&&i*p[j]<=2*n;j++)
        {
            mp[i*p[j]]=p[j];
            if(i%p[j]==0)
                break;
        }
    }
    //欧拉线性筛法
    for(int i=1;i<=n;i++)
        cnt[i]=-1;
      //需要除以分母
    for(int i=n+2;i<=2*n;i++)
        cnt[i]=1;
      //乘以分子
    for(int i=2*n;i>1;i--)
        if(mp[i]<i)
        //如果是合数，向下传递，可以保证O(n)
        {
            cnt[mp[i]]+=cnt[i];
            cnt[i/mp[i]]+=cnt[i];
        }
    int ans=1;
    for(int i=2;i<=2*n;i++)
        if(mp[i]==i)
        //如果是质数计入答案，合数已经处理过了
            ans=(long long)ans*qpow(i,cnt[i])%r;
              //防止中间过程溢出
    cout<<ans<<endl;
    return 0;
}
```

# 总结


## 组合数相关


这题需要求组合数，我总结了一下我知道的组合数取模的求法（P1313模板）：


1. 使用杨辉三角$C_n^0=C_n^n=1$ ，$C_n^i=C_{n-1}^i+C_{n-1}^{i-1}$ [代码见这里](https://www.luogu.org/record/show?rid=1845561)

2. **当$p$是质数时**可以得出$a$的逆元为$a^{p-2}$ ，$C_n^0=1$ ，$C_n^i=C_n^{i-1}\frac{k-i+1}{i}$ [代码见这里](https://www.luogu.org/record/show?rid=1845692)

3. **当$p$不是质数时**只能用上述方法，筛出质数并约分[代码见这里](https://www.luogu.org/record/show?rid=1845828)


应该不需要解释吧


## 时间复杂度分析


在添加数时，也可以先把这个数分解，但应该会降低效率.


而我用的方法筛质数、添加数、向下传递都是$O(n)$的，最后一步为$\pi(n)log n$[^pi]，而$\pi(n)\sim\frac{n}{\ln n}$ ，因此也近似与$O(n)$ .


[^qpow]: 使用分治法在$O(\log n)$的时间内计算出$a^b\mod p$

[^pi]: $\pi(n)$表示不超过$n$的质数个数



---

## 作者：thhhty (赞：43)

一个神奇的题目。。。。

发现前面基本没有讲为什么是卡特兰数的

从题意可以得到，偶数位里面一个偶数要比前面的偶数位大，而这些数位又比和他们对应的奇数位大，所以我们可以得到：**对于任意偶数位，这里放的数都大于前面的所有数**
换句话说，就算前面所有位置都放尽可能小的数，**这个位置最小也就只能放跟它下标一样大的数了**（位置4只能放大于等于4的值）

我们转换一下题意，变成1~2n一次放入这个数列里，对于每次放的数要么放在最前的奇数位，要么放在最前的偶数位。

联系前面的结论，我们可以知道：一个数列如果有偶数个数多于奇数个数的情况，就不可能满足条件了。

小证明：
(假设有对于2p+1来说刚好偶数位比奇数位多一个，这么最新放的偶数位就是第p+1个，这个偶数位在原来位置就会是2p+2,可是2p+2至少要放一个不小于2p+2的数。。。问题是我们才放到2p+1，所以这种情况不可能有解)

于是答案就是任意位都满足 **偶数位个数不超过奇数位个数** 的数列的个数

很明显----卡特兰数嘛（好比[P1044 栈](https://www.luogu.org/problemnew/show/P1044)，典型的卡特兰数，要求就是任意位置出栈<=入栈）

**公式Cat n= $C^{n}_{2n}$/n-1**

因为P不一定是质数所以我们要把它分解成若干$ci^{pi}$相乘的形式。

求出在mod每个$ci^{pi}$意义下的值。再拓展欧几里得（中国剩余定理）算到一起就是答案了~

只剩下两个问题：
1、m太大，如果是一个质数分解质因子的时候我们O（m）找过去会超时。。

2、我们mod的数也不一定是质数啊。。。

对于1、我们只需要除到**sqrt(M)**,剩下来的就是一个**单独的质数因子**。（或者就是1,没有质数了）

对于2、因为这是$ci^{pi}$,所以我们只需要把ci分离出来就可以保证互质然后计算，之后再对这些ci处理就好~

都知道$C^{m}_{n}$=n!/m!/(n-m)!，我们单独看n!,剩下两个方法差不多。

假设n=20,mod=9。我们除去3的倍数，就剩下1,2,4,5,7,8,10,11,13,14,16,17,19,20
因为是mod9意义下，所以10,11,13,14,16,17和1,2,4,5,7,8性质是一样的，那么，我们就可以看成是n/mod个1，2，4，5，7，8相乘，快速幂算出来。

剩下的19，20就单独再算上。

分出来的3,6,9,12,15,18，我们记录下6个3，就可以当作1,2,3,4,5,6再继续算。

对于n!,m!,(n-m)!分别这样弄，我们就可以分别得到两个数A=n!除去ci后的值，B=ci的个数。

因为A一定和mod互质于是我们可以使用逆元代替除，B的话直接加减就好。

最后得到的A、B，A*$ci^{B}$就是我们要的值。

**PS：mod $ci^{pi}$定义下的逆元是 $X^{mod-mod/ci-1}$**

实现代码：

**
(PS:这里我组合是直接算的不看ci的情况，然后单独再找ci个数的！)**

阶乘：
```cpp
ll jc(ll n)
{
	if(n==0)return 1;//特判
	
	ll s=1;
	if(n>=mod)//n<mod就没有必要进行这个计算了
	{	
          for(int i=2;i<mod;i++)if(i%p!=0)s=s*i%mod;
      	s=fp(s,n/mod);
	}
	for(int i=2;i<=n%mod;i++)if(i%p!=0)s=s*i%mod;
	return s*jc(n/p)%mod;
}
```
求组合：
```cpp

ll C(ll n,ll m)//n!/m!/(n-m)!
{
	return jc(n)*fp(jc(m),mod-mod/p-1)%mod*fp(jc(n-m),mod-mod/p-1)%mod;
}
```

算最后结果：
```cpp
ll xx=C(2*n,n),AA=0,BB=0,CC=0;
ll s=p;
while(s<=2*n)//找ci的个数
{
	AA+=2*n/s;
	BB+=n/s;
	CC+=n/s;
	s=s*p;
}
AA-=BB+CC;//xx*p^a=C(2n,n)
```
拓展欧几里得：
```cpp

ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	else
	{
		ll xx,yy;
		ll d=exgcd(b,a%b,xx,yy);
		x=yy;
		y=xx-(a/b)*yy;
		return d;
	}
}
```
AND
```cpp
if(a1==0&&b1==0)
{
	a1=mod,b1=xx;
	//Xa1+b1=ans
}
else
{
	a2=mod,b2=xx;		
	ll A=a1,B=a2,K=b2-b1,X,Y;//X1a1-X2a2=b2-b1
	exgcd(A,B,X,Y);
	X=X*K;//gcd(a1,a2)=1
	b1=a1*X+b1;
	a1=a1*a2;
	b1=((b1%a1)+a1)%a1;
}
```
b1就是答案~

---

## 作者：ycyaw (赞：30)

~~很好的一道思维题~~。警告：文字较多，没有耐心者勿入。

首先我们命名$a_1,a_3,...,a_{2n-1}$为奇数位，其余为偶数位。观察题目条件：奇数位与偶数位上的数字都满足从左到右递增，相邻的$a_{2i-1},a_{2i}$满足$a_{2i-1}<a_{2i}$。

首先很容易发现，一个偶数位上的数，比它左边的所有偶数位上的数要大，每个偶数位上的数又比它左相邻奇数位上的数要大。这两条信息，我们可以得出，一个偶数位上的数比它左边所有数都要大，那么再概括一下，就是一个偶数位上的数，大于等于这个偶数位的下标。

这个结论并不够我们来得出最后的答案，我们还需要一些结论。

因为数字从左到右，无论奇数位偶数位都满足递增，那么，我们考虑假如我们按$1-2n$的顺序一个一个放数字，我们应该放在哪里？

很容易发现，我们应该放在最靠左的能放的奇数位或者偶数位上，这样才能保证满足递增。

那还有什么限制呢？我们设已经放了$1-x$的数，$x_1$个放在了奇数位上，$x_2$个放在了偶数位上$(x_1+x_2=x)$。我们想起前面得出的关于偶数位上放数的结论：一个偶数位上的数，大于等于这个偶数位的下标。那什么时候会小于呢？猜想+估摸一下，感觉是$x_2>x_1$？？

猜想是很$Fake$的，让我们来简单的证一下。

反证：

假设当前情况为$x_2>x_1$，那么显然$x_2>x/2$，同时最后一个偶数位的下标是$2\times x_2$。

因为我们总共只有$x$个数，但由$x_2>x/2$我们得知，$2\times x_2>x$，所以最后一个偶数位不管放什么，都不满足条件，假设不成立。

所以得出结论，按从小到大的顺序放到任意一个数$x$，都满足放在偶数位上的数字个数小于等于放在奇数位上的数字个数。

想到什么？[This](https://www.luogu.org/problemnew/show/P1641)

这不是完全一样的卡特兰数吗？但这道题好像更麻烦一点，模数不是质数。那么就需要一些求卡特兰数的技巧，参考别的题解即可，几乎都讲了。

代码：
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define oo (1e18)
#define int long long
#define LL unsigned long long
#define hh puts("")
using namespace std;
int n,mo,cnt[2000005],pr[2000005],mn[2000005],top,ans=1;
bool v[2000005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline int ksm(int x,int y){
    int res=1;
    while(y){
        if(y&1) res=res*x%mo;
        y>>=1;
        x=x*x%mo;
    }
    return res;
}
signed main(){
    n=read(),mo=read();
    memset(v,1,sizeof(v));
    v[1]=0;
    for(int i=2;i<=2*n;i++){
        if(v[i]){
            pr[++top]=i;
            mn[i]=i;
        }
        for(int j=1;j<=top&&pr[j]*i<=2*n;j++){
            v[pr[j]*i]=0;
            mn[pr[j]*i]=pr[j];
            if(i%pr[j]==0) break;
        }
    }
    for(int i=1;i<=n;i++) cnt[i]=-1;
    for(int i=n+2;i<=2*n;i++) cnt[i]=1;
    for(int i=2*n;i>=2;i--){
        if(mn[i]<i){
            cnt[mn[i]]+=cnt[i];
            cnt[i/mn[i]]+=cnt[i];
        }
    }
    for(int i=2;i<=2*n;i++)
        if(mn[i]==i)
            ans=ans*ksm(i,cnt[i])%mo;
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：Iscream2001 (赞：20)

裸的卡特兰数。。。。

公式：C(n,2\*n)/(n+1)%p

C(n,2\*n)表示在2\*n个数中选n个，就是组合数啦。。。

公式可以展开：((2\*n)！/n!\*(n+1)!)%p

于是出现唯一的难点：取模

题目中没说p是不是质数。。。

因为(2\*n)！一定能被n!\*(n+1)!)整除

所以对于每一个小于2\*n的质因数p来说，(2\*n)！中一定存在数量更多的(或一样多)的因数p

于是可以分解质因数。。。

这是线性的，可以预处理。。。

于是此题解决。。。

代码

     
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
LL n,p;
int a[3000005],pri[3000005],cnt=0;
LL pow(LL a,LL b){
    LL s=1;
    while(b){
        if(b&1) s=s*a%p;
        b>>=1;
        a=a*a%p;
    }
    return s;
}
int main(){
    LL ans=1;
    LL m,s=0;
    scanf("%lld%lld",&n,&p);
    for(int i=2;i<=n*2;i++){
        if(a[i]==0)
            pri[++cnt]=i;
        for(int j=1;j<=cnt&&pri[j]*i<=n*2;j++){
            a[pri[j]*i]=1;
            if(i%pri[j]==0) break;
        }
    }
    for(int i=1;i<=cnt;i++){
        s=0;
        m=2*n;
        while(m>0){
            m=m/pri[i];
            s=s+m;
        }
        m=n;
        while(m>0){
            m=m/pri[i];
            s=s-m;
        }
        m=n+1;
        while(m>0){
            m=m/pri[i];
            s=s-m;
        }
        ans=ans*pow(pri[i],s)%p;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：_998344353_ (赞：10)

这题是```Catalan数```其他神仙已经说得很清楚了，在此不再赘述。

这里提供一种几乎No algorithm的算法，且不用分解质因数。

我们知道$f_n=\dfrac{C^n_{2n}}{n+1}=\dfrac{\prod_{i=n+2}^{2n}i}{\prod_{i=1}^ni}$

此算法流程是这样的：

首先筛出$1$到$2n$之间的所有质数，然后枚举每个质数，**算出1~2n，1~n，1~n+1之间包含这个因数的数量**，分别记为$s1,s2,s3$，则$s1-s2-s3$即为结果中包含这个质因数的数量。（$s1-s3$为分数线上方所含数量，$s2$为分数线下方所含数量）

所以怎么求$1$到$n$之间质因数的数量啊?

设该质数为$p$，则数量为$\frac{n}{p^1}+\frac{n}{p^2}+...+\frac{n}{p^k}$，均为下取整，其中$p^k\le n<p^{k+1}$。

所以事实上计算一个质数代价仅为$log_p$级别。

这部分代码如下：

``` cpp
for(i=1;i<=size;i++)
{
	ll s1=0,s2=0,s3=0,qwq=2*n;
	while(qwq)
	{
		s1=s1+qwq/prime[i];
		qwq/=prime[i];
	}
	qwq=n;
	while(qwq)
	{
		s2=s2+qwq/prime[i];
		qwq/=prime[i];
	}
	qwq=n+1;
	while(qwq)
	{
		s3=s3+qwq/prime[i];
		qwq/=prime[i];
	}
	b[i]=s1-s3-s2;
}
```

其中$size$是素数个数，$b_i$为每个质因数所含数量。

最后再用快速幂统计结果就好。

完整代码戳这里[link](https://www.luogu.com.cn/paste/zitgnwbn)

ps:因为是No algorithm的东西，所以筛法使用了埃氏筛。

总时间复杂度应该是$\Theta(nloglogn)$。

---

## 作者：是个汉子 (赞：8)

呜呜呜，本蒟蒻第一次做卡特兰数，实在是太菜了。写一个题解加深记忆。

### Solution

首先，题里面说明 $a_2<a_4<	\cdots <a_{2n}$ 和 $a_{2i-1}<a_{2i}$ ，可得**偶数位上的数比它前面任意一个数都要大**。

那么我们可以将题意转化为：将 $1$ ~ $2n$ 放入这个数列，每次放的数要么放在最前面的奇数位要么放在最前面的偶数位。

~~你觉得我说的可能是废话~~

现在说另一个结论：**一个数列填入偶数位的个数要时刻不超过填入奇数位的个数**

证明：设放在了偶数位上 $a$ 个数，放在奇数位上 $b$ 个数，并且 $a>b$ ，那么现在放了 $a+b$ 个数，显然 $a>\frac x2=\frac {a+b}2$ ，并且现在最后一个偶数位的**下标**是 $2\times a$ ，但是 $2\times a>x$ ，也就是说不管你在这一位放啥都是不满足条件的。

现在答案就是满足任意位偶位数不超过奇位数的数列个数

设 $f_{i,j}$ 表示填了 $i$ 个偶数位， $j$ 个奇数位的方案数。递推方程就是 $f_{i,j}=f_{i-1,j}+f_{i,j-1}$ 

最后的答案就是 $f_{n,n}$ 

~~完结撒花~~

嘿嘿嘿，如果你算了一下复杂度的话，会发现递推的复杂度是 $O(n^2)$ ，显然会T。

上面那个东西，和卡特兰数有很大的关系。其实就是求卡特兰数 $f_n$ 

所以我们要说关于卡特兰数的几个不一样的公式：

1.  $f_n=\sum\limits_{i=0}^{n-1}f_i\cdot f_{n-i-1}$ 这个也是递推的，复杂度依旧不对。
2.  $f_{n}=f_{n-1}\cdot \frac {4n-2}{n+1}$ ，如果 $p$ 是质数可以直接使用，也就是[这个题](https://www.luogu.com.cn/problem/P1641)。但是这个题没有保证，是做不了了的。
3.  $f_n=\frac {C_{2n}^n}{n+1}$ ，这个是可以的。

为什么这个就是可以的？因为 $f_n=\frac {C_{2n}^n}{n+1}=\frac {2n\times (2n-1)\times \cdots\times (n+2)}{n!}$ ，而一个数又可以表示成 $\prod p_i^{k_i}$ ，所以我们可以将每个数做质因数分解，统计每个质因子的指数即可。

### 代码

```c++
#include<bits/stdc++.h>
#define ll long long

using namespace std;
const int N=2e6+10;
int min_p[N],p[N],cnt[N],tot,mod,n;

inline int fpow(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}

inline void init(int n){
    for(int i=2;i<=n;i++){
        if(!min_p[i]) p[++tot]=i,min_p[i]=i;
        for(int j=1;j<=tot&&p[j]*i<=n;j++){
            min_p[i*p[j]]=p[j];
            if(i%p[j]==0) break;
        }
    }
}

int main(){
    scanf("%d%d",&n,&mod);
    init(2*n);
    for(int i=1;i<=n;i++) cnt[i]=-1;
    for(int i=n+2;i<=2*n;i++) cnt[i]=1;
    for(int i=2*n;i>1;i--)
        if(min_p[i]<i) cnt[min_p[i]]+=cnt[i],cnt[i/min_p[i]]+=cnt[i];
    int ans=1;
    for(int i=2;i<=2*n;i++)
        if(min_p[i]==i) ans=(ll)ans*fpow(i,cnt[i])%mod;
    printf("%lld\n",ans);
}
```



---

## 作者：说好不哭 (赞：8)

#  卡特兰数加线性筛优化
## 之前的一些题解思路也是线性优化组合公式，但我有一些新的增添。我的优化版代码注释超级详细。此题解适合被大数据卡住超时的童鞋们看。

### 原来的思路就是分解质因数后用质数表示大整数，但是时间肯定会爆的；由于题目未说明取模是质数，所以不能逆元，emm，本蒟蒻本来就不会逆元，所以就写了个超时的70分暴力算法。

## 以下为暴力算法
```cpp
#include <bits/stdc++.h>
using namespace std;
long long f[2000005];
long long sum,ans;
bool jc;
int k,kk,i;
int main(){
int n;
int con;
scanf("%d",&n);
scanf("%d",&con);
ans=1;
for (k=n+2; k<=2*n; k++){
ans=ans*k;
while (ans>1) {
jc=false;
for (i=2; i<=sqrt(ans); i++)
if (ans%i==0) {f[i]++; ans=ans/i; jc=true; break;}
if (jc==false) {f[ans]++; ans=1;}
}
}
ans=1;
for (k=2; k<=n; k++){
ans=ans*k;
while (ans>1) {
jc=false;
for (i=2; i<=sqrt(ans); i++)
if (ans%i==0) {f[i]--; ans=ans/i; jc=true; break;}
if (jc==false) {f[ans]--; ans=1;}
}
}
sum=1;
for (i=2; i<=2*n; i++)
while (f[i]!=0) {f[i]--; sum=sum*i%con;}
printf("%d",sum);
return 0;
}

```
---------------------------------------------------------------------

## 以下为AC优化代码
###  以下我要提的是线性优化思路，对于卡特兰数的发现和组合数的运用，暂时不写。
###  AC代码的总体思路是：1.线性筛选出1-2*n内的质数，边筛选边记录当前枚举到的数是被哪个数筛出来的；2.按照组合数公式进行枚举需要处理的数，处理是便可以根据之前线性的预处理进行操作（简单写一下操作，具体过程见代码和注释）;3.根据已得出的各个质数的个数进行累乘，边乘边模，得出最终答案。

### 对于以上3点，代码中分为1,2,3三段。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long i,j,n,m,ans,sum,x,a[2000005],b[2000005],p[2000005];
int main(){
	scanf("%lld%lld",&n,&m);
    
    
    
1.	for (i=2; i<=2*n; i++){
	if (a[i]==0) {sum++; p[sum]=i; a[i]=sum;}//sum累加，p数组标记第sum个质数为i ，a[i]表示i这个数是由第sum个质数筛得的
	for (j=1; j<=sum; j++) 
	if (p[j]*i<=2*n) a[p[j]*i]=j; else break; //枚举当前已得到的所有质数，用这些质数筛选出在范围内的可以被这些质数筛得合数
	//并把筛到的合数标记是被第几个质数 筛到的 
	}
	
    
    
2.	for (i=n+2; i<=2*n; i++){
	x=i;
	while (x>1) {b[a[x]]++; x=x/p[a[x]];} //a[x]表示第x个数是由第a[x]个质数筛得的， 然后把表示第a[x]个质数个数的数组累加 
	//做完上述操作后将x除以已累加的质数 
	}
	
	for (i=2; i<=n; i++){
	x=i;	
	while (x>1) {b[a[x]]--; 
	x=x/p[a[x]];}	//重复上述操作 
	}
	
    
    
    
3.	ans=1;
	for (i=1; i<=sum; i++)
	for (j=1; j<=b[i]; j++) ans=ans*p[i]%m; //p[i]表示第i个质数是什么，b[i]表示有第i个质数共有几个 
	printf("%lld",ans);
return 0;	
}

```

## 对于卡特兰数的题目，还有一些。
### 1.[P1044 栈](https://www.luogu.org/problemnew/show/P1044)卡特兰板子
### 2.[P1976 鸡蛋饼](https://www.luogu.org/problemnew/show/P1976)此题的弱化版
### 3.[P2532 [AHOI2012]树屋阶梯](https://www.luogu.org/problemnew/show/P2532)卡特兰数加高精
### 4.[P3978 [TJOI2015]概率论](https://www.luogu.org/problemnew/show/P3978)利用超强的观察能力找出和另一串数之间卡特兰数的递推关系


---

## 作者：_兰_ (赞：4)

卡特兰数相关其他神仙已经说的差不多了，在此说一个比较简单的分解质因数方法：

```cpp
void Sieve(){
	chk[0] = chk[1] = 1 ; int i, j ;
	for (i = 2 ; i < MAXN ; ++ i){
		if (!chk[i]) Pr[++ Pr[0]] = i, Mp[i] = i ;
		for (j = 1 ; j <= Pr[0] ; ++ j){
			if (i * Pr[j] >= MAXN) break ; 
			chk[Pr[j] * i] = 1, 
			Mp[i * Pr[j]] = Pr[j] ;
			if (i % Pr[j] == 0) break ; 
		}
	}
	for (i = 1 ; i <= Pr[0] ; ++ i) Id[Pr[i]] = i ; 
}
int A[MAXN], B[MAXN] ;
il LL Fuck_Com(int n, int m){
	int i, j, ret = 1 ; 
	memset(A, 0, sizeof(A)) ;
	memset(B, 0, sizeof(B)) ;
	for (j = m + 1 ; j <= n ; ++ j){
		int t = j ; 
		while (t > 1) A[Id[Mp[t]]] ++, t /= Mp[t] ;
	}
	for (j = 2 ; j <= n - m ; ++ j){
		int t = j ;
		while (t > 1) B[Id[Mp[t]]] ++, t /= Mp[t] ;	
	}
	for (i = 1 ; i <= Pr[0] ; ++ i) 
		A[i] -= B[i], ret = 1ll * ret * expow(Pr[i], A[i], P) % P ;
	return ret ; 
}
```

我们考虑直接枚举$\rm C_{n}^{m}$里面分子分母的每一个乘数，然后暴力质因数分解。注意到我们可以考虑记录最小的质因数，递归下去，做到单次分解$\log n$。

然后我们对$n\times (n-1)\cdots(m+1)$和$1\times2\cdots (n-m)$分别做一遍，然后由于组合数$\in \mathbb Z$，所以可知$\rm\forall i,A_i\geq B_i$。于是这样就完成了约分。

……说点题外话，一开始我是暴力枚举每个素数然后约分，这样因为至多会有$O(\frac{n}{ln n})$个质数，并且质数分布是稀疏的，所以复杂度并不对qwq。

简单来说就是可能并不比$n\sqrt n$快多少233



---

## 作者：EternalEpic (赞：3)

首先，解释题目。

化简一下题目的意思，就是求任意位置都满足偶数位个数不超过奇数位个数的数列的个数吗！

我们思考限制条件，寻思这不是Catalan数列吗！

我们想想还有哪些Catalan数列模型，进出栈序列就是一个很好的例子。

那一道题怎么做来着？（对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。 参考百度百科）。

那我们拍脑袋一想，这不是一回事吗？不都是求形如：$H(n) = \frac{C_n^{2n}}{n + 1}$吗。

那该如何处理组合数呢？

可以将其分解质因数，我们还知道$N!$中质因子$p$的个数为：$\sum_{p^k \leq N} \left\lfloor\frac{N}{p^k}\right\rfloor $。

那就先欧拉筛，再处理分解质因子，最后用快速幂把指数个质数乘起来就是答案。

code：

```cpp
const int Maxn = 2e6 + 5;
int vis[Maxn], prime[Maxn], cnt = 0;
inline void sieve(int n) {
	vis[1] = 0;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) prime[++cnt] = i, vis[i] = i;
		for (int j = 1; j <= cnt && prime[j] * i <= n; j++) {
			vis[prime[j] * i] = prime[j];
			if (i % prime[j] == 0) break;
		}
	}
}

inline int qpow(int a, int b, int p) {
	int ret = 1;
	for (; b; b >>= 1, a = 1ll * a * a % p)
		if (b & 1) ret = 1ll * ret * a % p;
	return ret;
}

inline int rate(int n, int p) {
	int ret = 0;
	while (n) {
		ret += n / p;
		n /= p;
	} return ret;
} int n, rat[Maxn], p, ret = 1;

signed main(void) {
//	file("");
	read(n), read(p); sieve(2 * n);
	for (int i = 1; i <= cnt; i++)
		rat[i] = rate(2 * n, prime[i]) - rate(n, prime[i]) - rate(n + 1, prime[i]);
	for (int i = 1; i <= cnt; i++) ret = 1ll * ret * qpow(prime[i], rat[i], p) % p;
	writeln(ret);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：Nero_Claudius (赞：2)

说起来这是今天第三道卡特兰数了。。。

------------

楼上的几篇题解好像都是直接看出这是卡特兰数，所以我就写一下为什么这道题可以用卡特兰数吧。

考察这样相邻的两项：$a_{2i-1}$与$a_{2i}$，根据题目的第二条原则显然有$a_{2i-1}<a_{2i}$。

而根据第一条原则又有奇数是递增的。

所以有$a_1<a_3<...<a_{2i-1}<a_{2i}$。

这个时候可以联想到[这道经典的题目](https://www.luogu.org/problemnew/show/P1044)。

我们可以将奇数项看为入栈，偶数项看为出栈。

发现和入栈次数必须大于出栈次数的条件恰好相符。

所以可以使用卡特兰数求解。

------------

直接套公式会残酷的爆10，需要加个优化。

（其实就是多推一步公式而已）

---

## 作者：Llf0703 (赞：1)

推广博客：https://llf0703.com/p/luogu-3200.html

## 题意

求满足下列要求的长度为 $2n$ 的序列 $S$ 的个数，对 $p$ 取模：

1. 是 $2n$ 的全排列
2. 奇数项、偶数项分别递增
3. $\forall i\in [1,n] \ , \ S_{2i-1} < S_{2i}$

## 题解

对于性质 $2$ ，可以考虑将 $1...2n$ 的数字按照从小到大的顺序依次放入序列。每个数字可以放在最前的奇数或偶数位。

分析性质 $3$ ，显然偶数位上的数比它前面的所有数都大，也就是偶数位 $2i$ 上放的数满足 $S_{2i}\geq 2i$ 。继续分析~~感觉~~可以得到放在偶数位的个数应该 $\le$ 奇数位上的个数。

这就是卡特兰数的模型了，答案为 $\dfrac{C_{2n}^n}{n+1}$ 。

将上式转化

$$\dfrac{C_{2n}^n}{n+1} = \dfrac{(2n)!}{(n+1)!\times n!}$$

因为 $p$ 不是质数，没法直接用逆元，所以我直接把 $\text{exLucas}$ 改了一下就交了，然后很开心的得了 $90$ 。

然后发现那组数据的 $p$ 是个 $5e8$ 级别的质数，所以我对剩下的质数进行了特判，如果 $\geq 10^{6}$ 就直接用逆元算。

这种算法在LOJ拿了最优解，洛谷上在第二页，感觉复杂度还是比较优秀。

```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

inline ll read()
{
    char ch=getchar();
    ll f=1,x=0;
    while (ch<'0' || ch>'9')
    {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return f*x;
}

ll n,p,zs[20005],ans,cnt;
bool ss[100005];

inline void get_prime()
{
    memset(ss,1,sizeof(ss));
    ss[0]=ss[1]=0;
    ll sqn=sqrt(p);
    for (ll i=2;i<=sqn;i++)
    {
        if (ss[i]) zs[++cnt]=i;
        for (ll j=1;j<=cnt && zs[j]*i<=sqn;j++)
        {
            ss[zs[j]*i]=0;
            if (i%zs[j]==0) break;
        }
    }
}

ll exgcd(ll l,ll r,ll &x,ll &y)
{
    if (r==0)
    {
        x=1; y=0;
        return l;
    }
    ll ans=exgcd(r,l%r,y,x);
    y-=l/r*x;
    return ans;
}

inline ll qpow(ll x,ll y,ll ha) //快速幂
{
    ll ans=1;
    while (y)
    {
        if (y&1) ans=ans*x%ha;
        y>>=1;
        x=x*x%ha;
    }
    return ans%ha;
}

inline ll inv(ll now,ll ha) //逆元
{
    ll x=0,y=0;
    exgcd(now,ha,x,y);
    return (x%ha+ha)%ha;
}

inline ll fac(ll x,ll pi,ll pk) //求阶乘
{
    if (!x) return 1;
    ll ans=1;
    for (ll i=2;i<=pk;i++)
    {
        if (i%pi==0) continue;
        ans=ans*i%pk;
    }
    ans=qpow(ans,x/pk,pk);
    ll len=x%pk;
    for (ll i=2;i<=len;i++)
    {
        if (i%pi==0) continue;
        ans=ans*i%pk;
    }
    return ans*fac(x/pi,pi,pk)%pk;
}

inline ll catalan(ll n,ll pi,ll pk) //求catalan数
{
    ll s=0;
    for (ll i=(n<<1);i;i/=pi) s+=i/pi;
    for (ll i=n+1;i;i/=pi) s-=i/pi;
    for (ll i=n;i;i/=pi) s-=i/pi;
    return fac(n<<1,pi,pk)*inv(fac(n+1,pi,pk),pk)%pk*inv(fac(n,pi,pk),pk)%pk*qpow(pi,s,pk)%pk;
}

inline ll C(ll n,ll ha) //大质数直接用逆元
{
    ll up=1,down=1;
    for (ll i=n+2;i<=(n<<1);i++) up=up*i%ha;
    for (ll i=n;i;i--) down=down*i%ha;
    return up*inv(down,ha)%ha;
}

inline ll exlucas(ll n)
{
    ll ans=0,p2=p;
    for (ll i=1;i<=cnt;i++)
    {
        if (p2%zs[i]) continue;
        ll pk=1;
        while (p2%zs[i]==0) p2/=zs[i],pk*=zs[i];
        ll ai=catalan(n,zs[i],pk),mi=p/pk;
        ans=(ans+ai*mi%p*inv(mi,pk)%p)%p;
    }
    if (p2>1)
    {
        ll ai=(p2>1e6) ? C(n,p2) : catalan(n,p2,p2),mi=p/p2; //特判
        ans=(ans+ai*mi%p*inv(mi,p2)%p)%p;
    }
    return ans;
}

signed main()
{
    n=read(); p=read();
    get_prime();
    return !printf("%lld",exlucas(n));
}
```

---

## 作者：_Diu_ (赞：1)

题目[传送门](https://www.luogu.com.cn/problem/P3200)

# catalan

首先，摆出结论：

### 这一题是裸的 catalan 数。

如何证明：

算了不证了。

# 如何求 catalan 数

这才是本题解的重点。

正常情况下求 catalan 数是非常简单的。

我们可以用这个柿子：

$Cat_n=\dfrac{C_{2n}^n}{n+1}$

或：

$Cat_n=C_{2n}^n-C_{2n}^{n-1}$

但是，这一题的 p 不是质数，

所以我就想到了用两种方法：

1. exlucas

- 这里不多赘述，因为会 T ，80分

2. 用分解质因数

# 分解质因数

首先我的思路是一种最朴素的分解质因数方法：

只要把分子分母的质因数分解后，对于每一个质因数进行处理就好了。



```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2000010;
int n,p,ans=1,mul=1;
int in[2][N];//0分母，1分子,2p
map<int,int> mp; 
int exgcd(int a,int b,int &x,int &y){
	if(!b){x=1,y=0;return a;}
	int d=exgcd(b,a%b,x,y);
	int tmp=x;
	x=y;
	y=tmp-a/b*y;
	return d;
}
int inv(int a,int p){
	int x,y;
	exgcd(a,p,x,y);
	if(x+p>p)return x;
	return x+p;
}
int qpow(int a,int b,int p){
	int mul=1;
	for(;b;b>>=1){
		if(b&1)mul=mul*a%p;
		a=a*a%p;
	}
	return mul;
}
void add(int k,int x){
	for(int i=2;i*i<=x;i++)
		while(x%i==0)x/=i,in[k][i]++;
	if(x!=1)in[k][x]++;
}
void addp(int x){
	for(int i=2;i*i<=x;i++)
		while(x%i==0)x/=i,mp[i]++;
	if(x!=1)mp[x]++;
}
signed main(){
	scanf("%lld%lld",&n,&p);
	for(int i=2*n;i>n;i--)add(0,i),add(1,i-n);
	add(1,n+1);
	addp(p);
	for(int i=2;i<N;i++){
		if(in[0][i]||in[1][i]){
//			printf("%lld %lld %lld %lld\n",i,ans,in[0][i],in[1][i]);
			int x=in[0][i]-in[1][i];
			if(x>0)ans=(ans*qpow(i,x,p))%p;
			else{
				x=-x;
				int y=min(x,mp[i]);
				x-=y;
				int q=qpow(i,y,p);
				mul*=q;
				p/=q;
				ans%=p;
				ans=(ans*qpow(i,x,p))%p;
			}
		}
	}
	printf("%lld\n",ans*mul);
}
```

于是又双叒叕 T 了。

但是，

这一个部分：

```cpp
else{
	x=-x;
	int y=min(x,mp[i]);
	x-=y;
	int q=qpow(i,y,p);
	mul*=q;
	p/=q;
	ans%=p;
	ans=(ans*qpow(i,x,p))%p;
}
```

完全没有必要！！！

因为 catalan 数绝对是整数，

所以一定能整除的。

---

然后，我们进行进一步优化。

我们可以联想到欧拉筛的原理，

## 整数的唯一分解

每一个大于 $1$ 的整数都可以分解成它最小的质数和另外一个数的乘积。

所以在统计和处理质因数时可以优化。

```cpp
for(int i=2;i<=2*n;i++){
	if(!mp[i])pr[++pn]=i,mp[i]=i;
	for(int j=1;j<=pn&&i*pr[j]<=2*n;j++){
		mp[i*pr[j]]=pr[j];
		if(i%pr[j]==0)break;
	}
}
```

类似于欧拉筛。

我们可以用倒序的方法处理因数。

这样可以把时间复杂度降到 $O(n)$。

```cpp
for(int i=1;i<=n;i++)cnt[i]=-1;
for(int i=n+2;i<=2*n;i++)cnt[i]=1;//cnt存的是指数
for(int i=2*n;i>1;i--)
	if(mp[i]<i)cnt[mp[i]]+=cnt[i],cnt[i/mp[i]]+=cnt[i];
```

进行多重优化后，就能 ac 了。

## code

上代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2000005;
int mp[N],pr[N/10],cnt[N],n,p;
int pow(int a,int b){
	int ans=1;
	for(;b;a=a*a%p,b>>=1)if(b&1)ans=ans*a%p;
	return ans;
}
signed main(){
	scanf("%lld%lld",&n,&p);
	int pn=0;
	for(int i=2;i<=2*n;i++){
		if(!mp[i])pr[++pn]=i,mp[i]=i;
		for(int j=1;j<=pn&&i*pr[j]<=2*n;j++){
			mp[i*pr[j]]=pr[j];
			if(i%pr[j]==0)break;
		}
	}
	for(int i=1;i<=n;i++)cnt[i]=-1;
	for(int i=n+2;i<=2*n;i++)cnt[i]=1;
	for(int i=2*n;i>1;i--)
		if(mp[i]<i)cnt[mp[i]]+=cnt[i],cnt[i/mp[i]]+=cnt[i];
	int ans=1;
	for(int i=2;i<=2*n;i++)
		if(mp[i]==i)ans=ans*pow(i,cnt[i])%p;
	printf("%lld\n",ans);
}
```

---


# [ICPC 2024 Yokohama R] Peculiar Protocol

## 题目背景

译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。

## 题目描述

_Icpca_ 王国在婚礼仪式上有一个特殊的规矩：礼金的数额必须是某个固定数量的倍数加上一个固定的额外数额。当固定数量是 $d$ 且固定额外数额是 $r$ 时，合规的礼金数额是 $k \times d + r$，其中 $k$ 是任意非负整数乘数。

最初，你有一叠 $n$ 张钞票。每次你参加婚礼仪式时，你会从当前钞票堆中取出一部分连续的钞票作为礼物，其总和为一个合规的数额，即 $d$ 的倍数加上额外的 $r$。如果没有连续的一段的钞票总和合规，你就不能再参加婚礼仪式了。取出后，剩余的钞票会被挤压形成一叠，并保持它们的相对顺序。形成的钞票堆中可能仍有总和达到该数额的部分，这允许你参加更多的仪式。

你的礼金预计会提升你的社会声誉。由于额外数额 $r$ 被认为是强制性的，乘数 $k$ 被认为是重要的。你在参加的每次仪式中，声誉都会按 $k$ 的比例提升。
例如，假设 $d = 5$ 且 $r = 1$，你拥有的钞票面值按顺序堆叠为 $2,2,2,4,4$。当你参加婚礼仪式时，有两种可能的方式可以给出合规的礼金。
- 给出由最上面三张钞票组成的礼金，总计为 $2 + 2 + 2 = 6 = 1 \times d + r$。取出它们后，你剩下两张面值为 4 和 4 的钞票。你剩余的钞票堆中没有连续的部分总和达到合规的数额。因此，你不能再参加婚礼仪式了。
- 给出由第三张和第四张钞票组成的礼金，总计为 $2 + 4 = 6 = 1 \times d + r$。取出它们后，你剩下三张面值依次为 $2,2,4$ 的钞票。你可以参加另一场婚礼仪式，因为第二张和第三张钞票的总和为 $2 + 4 = 6 = 1 \times d + r$，这是合规的。

在这个例子中，第二种方式可以通过参加两次仪式来最大化你的社会声誉，因为乘数总和为 $1 + 1 = 2$，这达到了最大可能值。

相比之下，如果第一张钞票的面值是 12，在一次仪式中给出前三张钞票后，你就无法参加更多仪式了。然而，这会最大化你的社会声誉，因为乘数总和为 $3$，这达到了最大可能值。

计算你在婚礼仪式上礼金乘数的最大可能总和。你可以假设你有很多未婚的亲戚和朋友，只要你能给出合规的礼金，你就可以参加任意数量的婚礼仪式。

## 样例 #1

### 输入

```
5 5 1
2 2 2 4 4```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5 1
12 2 2 4 4```

### 输出

```
3```

## 样例 #3

### 输入

```
5 20000 10000
5000 10000 15000 5000 25000```

### 输出

```
2```

## 样例 #4

### 输入

```
9 5 3
4 2 2 1 1 4 3 2 1```

### 输出

```
2```

# 题解

## 作者：JHPOTATO (赞：3)

存在一个显然的性质：对于任意一个区间 $\left [ l,r \right ] $，设用其中元素至多能参加 $x$ 场婚礼，那么对于任意 $y \le x$，都可以找到一种合法的方案。

所以我们可以统计每个区间能参加婚礼的最大次数，并借助这个判定一个区间能否完全利用。

转移是简易的，因为只关心最大次数，所以只需要枚举断点，判断剩下元素总和对 $d$ 取模是否为 $r$ 即可。

为了判定简便，可以事先预处理达到每个余数至少要举办几场婚礼。

其余细节可以见代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
void in(T &x){
	char c=getchar(), f=1;
	while ((c<'0' || c>'9') && c!='-') c=getchar();
	if (c=='-') f=-1, c=getchar();
	for (x=0; c>='0' && c<='9'; c=getchar())
		x=x*10+c-'0';
	x*=f;
}
const int N=505;
int n,d,r,al,dp[N][N];
long long s[N],f[N][N];
unordered_map<int,int>p;
int main(){
	in(n);in(d);in(r);
	for(int i=1;i<=n;i++){
		al+=r;if(al>=d)al-=d;
		if(p.count(al))break;
		p[al]=i;
	}
	for(int i=1;i<=n;i++){
		in(s[i]);
		if(s[i]%d==r)dp[i][i]=1,f[i][i]=s[i]/d;
		s[i]+=s[i-1];
	}
	for(int l=1;l<n;l++){
		for(int i=n-l;i;i--){
			int j=i+l,mx=0;
			for(int k=i;k<j;k++){
				f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]);
				mx=max(mx,dp[i][k]+dp[k+1][j]);
			}
			long long xx=(s[j]-s[i-1])%d;
			if(p.count(xx)&&p[xx]==mx+1)mx++;//如果res=0似乎会使mx变大(用0张巻白吃?)
			//但res=0如果出现,就一定是最后一项,也就是所有可达余数都已经能被计算出来了,多统计无影响
			dp[i][j]=mx;
			if(p.count(xx)&&mx>=p[xx])f[i][j]=max(f[i][j],(s[j]-s[i-1]-p[xx]*1ll*r)/d);
		}
	}
	cout<<f[1][n];
	return 0;
}
/*
dp[i][j]->区间[i,j]至多能参加几场婚礼
f[i][j]->区间[i,j]的答案
显然,只要需求可达且不超过dp[i][j],都能凑出来
*/
```

---


# [NERC 2020] Is It Rated?

## 题目描述

受欢迎的即兴表演网站 **Interpretation Impetus** 定期举办即兴表演竞赛，并维护最佳表演者的评分。然而，由于即兴表演常常可能出错，该网站以宣布即兴竞赛 **unrated** 而闻名。现在，每次即兴竞赛前会举行一场赌局，参与者试图预测竞赛是 rated 还是 unrated，这些赌局甚至比即兴表演本身更受欢迎。

Izzy 和其他 $n$ 名参与者参加每场赌局。首先，他们各自做出预测，用 $\texttt{1}$（"rated"）或 $\texttt{0}$（"unrated"）表示。Izzy 总是最后一个预测，因此她在做出自己的预测时知道其他参与者的预测。接着，实际的竞赛举行，并宣布为 rated 或 unrated。

你需要编写一个程序，以交互方式扮演 Izzy。2021 年将举行 $m$ 场赌局，Izzy 的目标是在所有赌局结束后，其错误预测的数量不超过 $1.3\cdot b + 100$，其中 $b$ 是其他所有赌局参与者在所有赌局结束后错误预测的**最小**数量。

数值 $b$ 事先未知。Izzy 对其他参与者一无所知——他们可能总是猜对，或者他们的预测可能相互关联。然而，Izzy 的预测不会影响其他参与者的预测或竞赛是否 rated 的决定——换句话说，在每个测试用例中，你的程序始终会接收到相同的输入，无论它输出什么。

### 交互协议

首先，解决方案必须读取两个整数 $n$（$1 \le n \le 1000$）和 $m$（$1 \le m \le 10\,000$）。接着，解决方案必须处理 $m$ 场赌局。对于每场赌局，解决方案首先读取一个由 $n$ 个 $\texttt{0}$ 和 $\texttt{1}$ 组成的字符串，其中第 $i$ 个字符表示第 $i$ 名参与者的预测。然后，解决方案必须输出 Izzy 的预测 $\texttt{0}$ 或 $\texttt{1}$。  
**注意：输出后必须刷新缓冲区！** 接着，解决方案必须读取实际结果（同样是 $\texttt{0}$ 或 $\texttt{1}$），然后继续处理下一场赌局（如果这不是最后一场）。

如果解决方案的错误预测数量不超过 $1.3\cdot b + 100$，则视为正确，其中 $b$ 是其他参与者中错误预测的最小数量。注意，如果解决方案在某场赌局中输出的不是 $\texttt{0}$ 或 $\texttt{1}$，即使没有其他错误，也会被视为不正确。  

本题共有 200 个测试用例。

## 说明/提示

在样例中，其他参与者分别犯了 1、2 和 3 次错误，因此 $b=1$（这些数字中的最小值）。Izzy 犯了 3 次错误，未超过 $1.3\cdot b + 100=101.3$，因此这些输出足以通过该测试用例（其他任何有效输出同样可以通过）。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
3 4
000

1
100

1
001

0
111

1```

### 输出

```


0


0


1


1

```

# 题解

## 作者：Sunrise_up (赞：4)

## 思路

这里提供两种策略：

- 只信任当前错误最少的参与者，若预测不同则选择多数票，平局时随机选择。但该策略在某些情况下会导致错误率高于最佳参与者，不可取。

- 为每个参与者分配权重 $\beta^x$，其中 $x$ 是该参与者的错误次数，$\beta$ 是一个介于 $0.5$ 和 $0.95$ 之间的常数。基于加权概率**随机**选择预测结果，而**非确定性选择**。

我们采用第二个策略，主要步骤包括：

1. 计算每个参与者的当前错误次数。
2. 计算选择 $0$ 和 $1$ 的加权投票和。
3. 根据加权概率随机选择预测结果。
4. 根据实际结果更新参与者的错误次数。

可以证明，在大多数情况下，结果远小于 $b\cdot1.3+100$。

## 代码

这里的 $\beta$ 取 $0.75$，你也可以取 $0.5$ 和 $0.95$ 之间的常数。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const double beta=0.75;
int n,m;
int w[1001];
string s;
char res;
int main(){
    srand(time(0));
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>m;
    while(m--){
        cin>>s;
        int y=INT_MAX;
        for(int i=0;i<n;i++){
            y=min(y,w[i]);
        }//计算选择0和1的最高错误次数 
        long double w0=0.0,w1=0.0;
        for(int i=0;i<n;i++){
            long double ww=pow(beta,w[i]-y);
            if(s[i]=='0')w0+=ww;
            else w1+=ww;
        }
        long double prob0=w0/(w0+w1);
        cout<<(((double)rand()/RAND_MAX<prob0)?'0':'1')<<endl;//基于概率随机选择
        cin>>res;//读取实际结果并更新错误次数
        for(int i=0;i<n;i++){
            if(s[i]!=res)w[i]++;
        }
    }
    return 0;
}
```

## 复杂度分析
时间复杂度：每次预测需要遍历所有参与者，时间复杂度为 $O (n)$，所以总时间复杂度为 $O (nm)$。

空间复杂度：存储每个参与者的错误次数，空间复杂度为 $O (n)$。

---


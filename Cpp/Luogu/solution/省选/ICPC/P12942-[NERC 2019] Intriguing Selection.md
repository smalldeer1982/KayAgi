# [NERC 2019] Intriguing Selection

## 题目描述

**这是一道交互题。**

你是一家国际象棋俱乐部的总教练。俱乐部共有 $2n$ 名选手，每位选手都有一个独特的**实力值**（用数字表示），但这些实力值对你来说是未知的。

你需要从中选出 $n$ 名选手代表俱乐部参加即将到来的锦标赛。自然，你希望选出实力最强的 $n$ 名选手。

为此，你可以组织选手之间的比赛。每场比赛你需要选择两名选手进行对决，之后你会知道两人中谁的实力更强。你可以根据比赛结果来决定下一场比赛的参与者。

但你不希望**完全**了解这 $n$ 名选手之间的具体实力排名，因为那样会让锦标赛本身变得不够**引人入胜**。更正式地说，你需要达到这样一种状态：根据已进行的比赛结果，恰好存在一种方式可以选出实力最强的 $n$ 名选手，但同时这些选手之间至少存在两种不同的实力排名顺序与比赛结果一致。

### 交互协议

你的程序需要处理多个测试用例。首先读取整数 $t$（$t \ge 1$）表示测试用例数量，然后依次处理每个测试用例。

在每个测试用例中：
1. 首先读取整数 $n$（$3 \le n \le 100$），表示需要从 $2n$ 名选手中选出 $n$ 名。所有测试用例的 $n$ 的平方和不超过 $10\,000$。
2. 然后可以组织若干场比赛。要组织比赛，需要输出格式为 `? i j` 的指令（问号后跟两个不同的选手编号）。选手编号为 $1$ 到 $2n$。输出后需要刷新输出缓冲区。
3. 之后读取比赛结果：`>` 表示第一个选手更强，`<` 表示第二个选手更强。
4. 最多可以组织 $4n^2$ 场比赛。结束后输出 `!` 并处理下一个测试用例（或结束程序）。输出 `!` 后也需要刷新输出缓冲区。

最终必须满足：
- 根据比赛结果，恰好有一种方式可以选出实力最强的 $n$ 名选手
- 但这些选手之间至少存在两种可能的实力排名顺序与比赛结果一致

评测系统会在程序开始前为所有选手分配不同的实力值，并根据这些值回答比赛结果。

## 说明/提示

在第一个测试用例中，选手按实力降序排列。根据示例中的比赛结果可以确定选手 1、2、3 是最强的三人，但我们无法确定选手 1 和 2 之间的具体强弱关系。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2
3

>

<

>

<

>

>

3

<

<

<

>

>
```

### 输出

```


? 1 3

? 4 2

? 4 5

? 6 5

? 3 4

? 5 6

!

? 3 4

? 4 2

? 5 3

? 6 4

? 3 1

!```

# 题解

## 作者：Iniaugoty (赞：1)

尝试将前 $n$ 大划分成两个集合 $A$ 和 $B$，对于 $x, y \in A$ 或 $x, y \in B$，我们知道 $x$ 与 $y$ 之间的大小关系；而对于 $x \in A$，$y \in B$，我们不知道 $x$ 与 $y$ 之间的大小关系。容易验证满足题意。

考虑增量构造。对于 $k \ge n$，在已经求出 $a _ 1 \dots a _ k$ 的前 $n$ 大并划分好的基础上，加入 $a _ {k + 1}$。

当 $k = n$ 时，将 $a _ 1 \dots a _ n$ 随便分成 $A$ 和 $B$ 就好了。

当 $k > n$ 时，设 $A$ 中的 $\min$ 为 $\alpha$，$B$ 中的 $\min$ 的 $\beta$。

不妨设 $\alpha < \beta$，那么分为两种情况：

- $a _ {k + 1} < \alpha$，这样 $a _ {k + 1}$ 显然不可能作为前 $n$ 大，因为至少有 $n$ 个数比它更大，那么不用管它。

- $a _ {k + 1} > \alpha$，这样 $\alpha$ 就不是前 $n$ 大了，我们把 $\alpha$ 从 $A$ 中删掉，并加入 $a _ {k + 1}$。

至于如何求出 $\alpha$ 和 $\beta$？我们在最初划分的时候就将 $A$ 和 $B$ 分别排序好，并时刻维持他们有序的状态。排序选择冒泡排序、选择排序这种即可，加入新元素时，只需要暴力地把所有比它小的数都往移动一位。这样最多有 $2 n ^ 2$ 左右的操作次数，距离上界 $4 n ^ 2$ 还差不少。

但这样依然存在一个问题。在最后，如果 $|A| = 1$，$\alpha < \beta$，这意味着我们已经知道了全部前 $n$ 大的大小关系（构造过程中我们维持了 $B$ 是有序的）。

看上去最初令 $|A| > 1$ 就好了。

但是当 $n = 3$ 时我们显然无法让 $|A|$ 和 $|B|$ 同时 $> 1$。

于是将维护 $n$ 大改成维护前 $n + 1$ 大就好了。最后再把 $\min (\alpha, \beta)$ 删掉。

实现中我取了 $|A| = n - 1$，$|B| = 2$。

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for(int i = (a); i <= (b); ++i)
#define dF(i, a, b) for(int i = (a); i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int, LL> pii;
const int N = 105;

int n, a[N], p, q;
bool cmp(int x, int y) {
  cout << "? " << x << " " << y << endl;
  char c; cin >> c; return c == '<';
}
void mian() {
  cin >> n;
  F(i, 1, n - 1) a[i] = i;
  F(i, 1, n - 1) F(j, 1, n - 2)
    if (cmp(a[j + 1], a[j]))
      swap(a[j], a[j + 1]);
  p = n, q = n + 1;
  if (cmp(q, p)) swap(p, q);
  F(i, n + 2, n << 1) {
    if (cmp(a[1], p)) {
      if (cmp(i, a[1])) continue;
      a[1] = i;
      F(j, 1, n - 2)
        if (cmp(a[j + 1], a[j]))
          swap(a[j], a[j + 1]);
    }
    else if (cmp(q, i)) p = q, q = i;
    else if (cmp(p, i)) p = i;
  }
  cmp(a[1], p);
  cout << "!" << endl;
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  int _; cin >> _; while (_--) mian();
  return 0;
}
```

---


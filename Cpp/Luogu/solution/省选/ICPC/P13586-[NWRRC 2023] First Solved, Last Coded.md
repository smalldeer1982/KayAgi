# [NWRRC 2023] First Solved, Last Coded

## 题目描述

在 ICPC 比赛中，团队合作至关重要。因此，你们队里的每个人都有明确的分工：Sol the Solver 能解决题目集中的任何问题，Codie the Coder 能实现 Sol 想出的任何解法，而你……则是把一切联系在一起的纽带。Sol 和 Codie 对于解决/实现题目的顺序都非常挑剔，你的任务就是满足他们的偏好。

即将到来的比赛中有 $n$ 道题目，你知道每道题的大致类型：贪心、几何、图论等。为简化问题，我们用 $1$ 到 $n$ 的整数来表示每种类型。这些整数不一定互不相同，也就是说，比赛中可能有多道题属于同一类型。

Sol 希望按照特定的题目类型顺序来解决问题：首先是类型为 $a_1$ 的题目，然后是 $a_2$，依此类推，最后是 $a_n$。Codie 也有自己的偏好列表：$b_1, b_2, \ldots, b_n$，只愿意按照这个题目类型顺序来实现题目。

你在比赛中的工作是从 Sol 那里接过解答纸，然后按正确的顺序交给 Codie。由于你们队只有一张桌子，你没有足够的空间把所有解答纸都整齐地摆放好。因此，你想出了如下的工作流程：你会按 $a_1, a_2, \ldots, a_n$ 的顺序向 Sol 要解答纸，并将其放在你桌子上的一个栈中，然后再按 $b_1, b_2, \ldots, b_n$ 的顺序把解答纸交给 Codie。

更正式地说，在比赛的任何时刻，你最多可以进行以下两种操作之一：

- 如果还有未解决的问题，可以向 Sol 再要一份解答纸，并将其放到你的解答纸栈顶。这个操作用字符 $\tt{S}$ 表示。
- 如果你的栈非空，可以从栈顶取出一份解答纸交给 Codie 实现。这个操作用字符 $\tt{C}$ 表示。

对于给定的 Sol 和 Codie 的偏好列表，请找出一组操作序列，保证所有题目都能按正确的顺序被解决和实现。假设解决和实现题目的时间都可以忽略不计——管理解答纸才是更难、更重要的工作。

## 说明/提示



由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
4 1 2 2
1 2 4 2```

### 输出

```
YES
SSCSCCSC```

## 样例 #2

### 输入

```
3
2 3 1
1 2 3```

### 输出

```
NO```

# 题解

## 作者：littleKtian (赞：3)

### 题意
给定入栈序列 $a$，询问是否能用一个栈达成出栈序列 $b$，如果可行则构造方案，序列中元素可重复，$n\leq 100$。

### 思路
设 $f(i,j,len)$ 表示从序列 $a$ 中下标为 $i$、序列 $b$ 中下标为 $j$ 的元素为左端点，长度均为 $len$ 的区间能否使用栈完成要求。

枚举 $a_i$ 在序列 $b$ 的区间 $[j,j+len-1]$ 所匹配的位置，有如下递推公式：

$$f(i,j,len)=\bigvee_{k=j}^{j+len-1}([a_i=b_k]\wedge f(i+1,j,k-j)\wedge f(i+k-j+1,k+1,j+len-1-k))$$

直接 dp 并根据转移过程构造方案即可，时间复杂度 $O(n^4)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,a[105],b[105],f[105][105][105];
int dp(int l1,int l2,int len){
	if(len<=0)return 1;
	if(f[l1][l2][len]!=-1)return f[l1][l2][len];
	int r1=l1+len-1,r2=l2+len-1;
	if(r1>n||r2>n)return f[l1][l2][len]=0;
	if(len==1)return f[l1][l2][len]=a[l1]==b[l2]?1:0;
	int ans=0;
	for(int i=l2;i<=r2;i++){
		int lans=(a[l1]==b[i]?1:0)&dp(l1+1,l2,i-l2)&dp(l1+i-l2+1,i+1,r2-i);
		ans|=lans;
	}
	return f[l1][l2][len]=ans;
}
void print(int l1,int l2,int len){
	if(len<=0)return;
	if(len==1){
		cout<<'S'<<'C';
		return;
	}
	int r1=l1+len-1,r2=l2+len-1;
	for(int i=l2;i<=r2;i++){
		int lans=(a[l1]==b[i]?1:0)&dp(l1+1,l2,i-l2)&dp(l1+i-l2+1,i+1,r2-i);
		if(lans==1){
			cout<<'S';
			print(l1+1,l2,i-l2);
			cout<<'C';
			print(l1+i-l2+1,i+1,r2-i);
			return;
		}
	}
}
void work(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=n;k++)f[i][j][k]=-1;
	int ans=dp(1,1,n);
	if(ans==1){
		cout<<"YES\n";
		print(1,1,n);
	}else cout<<"NO";
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T=1;
	while(T--)work();
}
```

---

## 作者：lalaouye (赞：1)

是个美难题！让我对栈结构有了新的理解。

我们对于栈，可以想到深度优先搜索，dfs 树等。。。总之都是说明了栈有着优良的性质，当然关于前缀和等的数学性质就不多说了，毕竟对这道题理解作用不大。

这题看起来很难，先找切入点。注意到数据范围很小，我们可以想到结合栈的优良性质去干一些事情。考虑从第一个入栈的东西的出栈时间入手，或者从最后一个出栈的东西枚举入栈的时间入手，我是从后者考虑的。

对于最后一次出栈的数，如果其是第 $i$ 个入栈的，则需要满足社么条件？发现对于 $[i+1,n]$ 这些入栈的数需要被 pop 干净，并且自己本身不能被 pop 出去，由于自己前面的数被 pop 只有两种可能，一种是自己没进来的时候被 pop，要么是自己被 pop 后前面被 pop，稍微分析一下就能够发现我们其实进入了两个子问题，因为前面得先全 pop 掉，$i$ 加入之后的所有数要在只后全 pop 掉，及对于出栈序列 $[1,i-1]$ 和入栈序列 $[1,i-1]$ 需要自己处理组成合法栈序列，对于出栈序列  $[i,n-1]$ 和入栈序列 $[i+1,n]$ 需要满足自己处理组成合法栈序列。

我们发现这样我们就进入了子问题，并且都是连续的区间，如果对栈很熟悉的话，这并不意外，这题也说明了栈能跟一些奇奇怪怪的区间问题扯上关系。

那么我们发现状态不多，在可接受范围，于是直接 dp 就好了，设 $f(i,j,l)$ 表示入栈序列左端点在 $i$，出栈序列左端点在 $j$，长度都为 $l$ 的子问题，转移简单枚举即可，最后利用搜索把方案搜出来就做完了。时间复杂度 $\mathcal{O}(n^4)$。

---

## 作者：UNVRS (赞：1)

## 题意

给出长度为 $n$ 的序列 $a,b$，问 $a$ 是否存在等于 $b$ 的出栈序列。构造方案或输出无解。

$n\le 100$

## 官方题解翻译

（以下称将序列 $c$ 通过入栈出栈变换为序列 $d$ 的过程称为 $c$ **匹配** $d$）

[官方题解原文](https://nerc.icpc.global/archive/2023/northern/tutorial.pdf)。

考虑 $a$ 中第一个数 $a[1]$ 的出栈情况，假设 $a[1]$ 是第 $k$ 个出栈的数，这段时间内 $a[1]$ 一直位于栈底，而且在 $a[1]$ 出栈时，栈中仅有 $a[1]$ 一个数。那么这时 $a[2\cdots k]$ 已经出栈。

下图展示了具体发生了什么：

- $a[2\cdots k]$ 将出现在 $1\cdots k-1$ 处。

- $a[k+1\cdots n]$ 将出现在 $k+1\cdots n$ 处。

![译者能力有限，无法用 LaTeX 复刻这张图](https://cdn.luogu.com.cn/upload/image_hosting/qpvkfso1.png)

两种情况均可视作 $a[i\cdots i+l]$ 匹配 $b[j\cdots j+l]$，于是我们可以使用动态规划解决此题。

我们设 $f_{i,j,l}=\texttt{true}$ 表示 $a[i\cdots i+l]$ 能匹配 $b[j\cdots j+l]$，若其为 $\texttt{true}$ 则需存在一个 $0\le k\le l$ 满足以下所有条件：

- $a[i]$ 在 $j+k$ 处出栈，故 $a[i]=b[j+k]$;

- $a[i+1\cdots i+k]$ 能匹配 $b[j\cdots j+k-1]$，故 $f_{i+1,j,k-1}=\texttt{true}$;

- $a[i+k+1\cdots i+l]$ 能匹配 $b[j+k+1\cdots j+l]$，故 $f_{i+k+1,j+k+1,l-k-1}=\texttt{true}$.

以上条件均可 $O(1)$ 计算，直接枚举 $k$ 即可得到 $O(n^4)$ 的复杂度。对于所有状态，记录下成功转移的 $k$ 即可构造出方案。

---


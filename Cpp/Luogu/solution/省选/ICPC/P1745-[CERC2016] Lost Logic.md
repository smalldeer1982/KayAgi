# [CERC2016] Lost Logic

## 题目描述

Gustav 正在阅读关于「2-可满足性」的问题，这是一个著名的问题，涉及为布尔变量分配真值以满足一系列「约束」——每个约束是涉及两个变量的简单逻辑公式。

我们使用 $n$ 个变量 $x_1, x_2, \cdots , x_n$，这些变量可以取值 $0$（假）和 $1$（真）。一个约束是形如 $a\to b$ 的公式，其中 $a$ 和 $b$ 都是可能被取反的变量。通常，$\to$ 表示逻辑蕴涵：$a \to b$ 仅在 $a$ 为 $1$ 且 $b$ 为 $0$ 时为 $0$。变量 $a$ 的取反表示为 $!a$。

给定变量的一个赋值，我们称约束在其结果为 $1$ 时被「满足」。Gustav 构建了一系列约束，并正确地得出有「恰好三种」不同的变量赋值可以满足所有约束。Gustav 写下了所有三种赋值，但不幸的是，他丢失了约束列表。
给定三个变量的 $n$ 个值的赋值，找出一个最多包含 $500$ 个约束的列表，使得这三个给定的赋值是唯一满足所有约束的赋值。



## 说明/提示

（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
3
0 0 0
0 1 0
1 0 0```

### 输出

```
3
x1 -> !x2
x3 -> x1
x3 -> x2```

## 样例 #2

### 输入

```
4
0 0 1 0
1 0 0 0
1 0 1 1```

### 输出

```
-1```

# 题解

## 作者：ix35 (赞：8)

一道非常有意思的题目。

考虑第 $i$ 位，有以下几种情况：

1. $a,b,c$ 第 $i$ 位全是 $0$；

2. $a,b,c$ 中恰有一个第 $i$ 位是 $1$；

3. $a,b,c$ 中恰有两个第 $i$ 位是 $1$；

4. $a,b,c$ 第 $i$ 位全是 $1$。

$1,4$ 和 $2,3$ 分别对称，所以我们只讨论 $1,2$。

---

1. $a,b,c$ 第 $i$ 位全是 $0$。

那么我们只要 $x_i\to !x_i$，即可保证所有满足约束的数都是第 $i$ 位为 $0$ 的。

---

2. $a,b,c$ 中恰有一个第 $i$ 位是 $1$（不妨设为 $a$）。

由于我们希望结果只有这三种，所以只要第 $i$ 位是 $1$，我们就可以立刻推出这个数一定是 $a$，也就需要 $n$ 个条件，形如 $x_i\to x_j$ 或 $x_i\to !x_j$，其中 $x_j$ 还是 $!x_j$ 取决于 $a$ 的第 $j$ 位。

---

这样一来，考虑有哪些数能够符合全部的条件：

- $a,b,c$ 肯定都是符合的；

- 假如一个不是 $a,b,c$ 的数也符合，那么考虑第 $i$ 位，如果是情况 $1$ 则这个数的第 $i$ 位一定和 $a,b,c$ 相同；如果是情况 $2$，那么这个数的第 $i$ 位一定不能和 $a$（也就是独特的那个）相同。

也就是说，这个数是取出 $a,b,c$ 每一位的众数构成的，设为 $d$。

如果 $d=a$ 或 $d=b$ 或 $d=c$，那么上面的构造可以保证满足题意。

否则，一定不存在满足题意的构造，这是因为使得 $a,b,c$ 满足的约束，也会使得 $d$ 满足，证明如下：

不妨设约束为 $x_i\to x_j$，假设 $d$ 不满足，那么有 $d$ 的第 $i$ 位为 $1$ 且第 $j$ 位为 $0$，所以 $a,b,c$ 有至少两个第 $i$ 位为 $1$，也至少有两个第 $j$ 位为 $0$，那么根据抽屉原理肯定有一个数同时满足这两个条件，也就不满足约束 $x_i\to x_j$，矛盾。

---

但是现在的构造约束数量是 $O(n^2)$，有些大，考虑优化。

如果 $a$ 中有许多“独特”的位置（和 $b,c$ 都不同的），我们钦定其中一个 $i$ 向其他所有位置限制约束，而其他独特位置只需要约束 $i$ 即可，这样就实现了 $O(n)$ 个约束。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=60;
int n,cnt,a[MAXN],b[MAXN],c[MAXN],pos[3],flg[3];
int ans1[MAXN*MAXN],flg1[MAXN*MAXN],ans2[MAXN*MAXN],flg2[MAXN*MAXN];
ll va,vb,vc,vd;
int main () {
	scanf("%d",&n);
	for (int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		if (a[i]) {va+=(1ll<<i);}
	}
	for (int i=1;i<=n;i++) {
		scanf("%d",&b[i]);
		if (b[i]) {vb+=(1ll<<i);}
	}
	for (int i=1;i<=n;i++) {
		scanf("%d",&c[i]);
		if (c[i]) {vc+=(1ll<<i);}
		if (a[i]+b[i]+c[i]>=2) {vd+=(1ll<<i);}
	}
	if (vd!=va&&vd!=vb&&vd!=vc) {
		printf("-1\n");
		return 0;
	}
	for (int i=1;i<=n;i++) {
		if (a[i]==b[i]&&a[i]==c[i]) {
			if (a[i]==1) {
				cnt++;
				ans1[cnt]=ans2[cnt]=i,flg1[cnt]=0,flg2[cnt]=1;
			} else {
				cnt++;
				ans1[cnt]=ans2[cnt]=i,flg1[cnt]=1,flg2[cnt]=0;
			}
		} else if (b[i]==c[i]) {
			if (pos[1]) {
				cnt++;
				ans1[cnt]=i,flg1[cnt]=a[i],ans2[cnt]=pos[1],flg2[cnt]=a[pos[1]];
			} else {
				for (int j=1;j<=n;j++) {
					if (j!=i) {
						cnt++;
						ans1[cnt]=i,flg1[cnt]=a[i],ans2[cnt]=j,flg2[cnt]=a[j];
					}
				}
				pos[1]=i;
			}
		} else if (a[i]==b[i]) {
			if (pos[3]) {
				cnt++;
				ans1[cnt]=i,flg1[cnt]=c[i],ans2[cnt]=pos[3],flg2[cnt]=c[pos[3]];
			} else {
				for (int j=1;j<=n;j++) {
					if (j!=i) {
						cnt++;
						ans1[cnt]=i,flg1[cnt]=c[i],ans2[cnt]=j,flg2[cnt]=c[j];
					}
				}
				pos[3]=i;
			}
		} else {
			if (pos[2]) {
				cnt++;
				ans1[cnt]=i,flg1[cnt]=b[i],ans2[cnt]=pos[2],flg2[cnt]=b[pos[2]];
			} else {
				for (int j=1;j<=n;j++) {
					if (j!=i) {
						cnt++;
						ans1[cnt]=i,flg1[cnt]=b[i],ans2[cnt]=j,flg2[cnt]=b[j];
					}
				}
				pos[2]=i;
			}
		}
	}
	printf("%d\n",cnt);
	for (int i=1;i<=cnt;i++) {
		if (!flg1[i]) {printf("!");}
		printf("x%d -> ",ans1[i]);
		if (!flg2[i]) {printf("!");}
		printf("x%d\n",ans2[i]);
	}
	return 0;
}
```


---

## 作者：MuelsyseU (赞：4)

[P1745](https://www.luogu.com.cn/problem/solution/P1745)

## 1. 关于 2-SAT 问题

其实这个题开头已经给出了是2-SAT问题变种的构造题，所以可以套用2-SAT的思想转化为图论。

2-SAT问题的思路是说，假定把一个位置 $i$ 是 $1$ 以及是 $0$ 的情况拆分成两个结点 $i$ 和 $-i$，则可以转化成如下问题：

> 给出 $n$ 个集合，每个集合有两个元素，已知若干个 $(a,b)$，表示选择 $a$ 则必须选择 $b$ 矛盾（其中 $a$ 与 $b$ 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 $n$ 个两两不矛盾的元素。

用一条边 $(u,v)$ 表示如果选择 $u$ 就必须选择 $b$，就可以在刚才建立的有 $2n$ 个结点的有向图中进行选择。其大致思路为，每次尝试选择一个可以选择的点 $x$，然后选择这个点可以到达的所有点，并且将 $-x$ 及可以到达 $-x$ 的所有点标记为不可选择。如果发生矛盾，则回溯并且尝试选择 $-x$。

容易发现，任何一条边 $(u,v)$ 存在，则相当于 $(-v,-u)$ 也存在。也就是说，图中存在**对称性**。而任何一条边 $(u,v)$ 存在且 $(v,w)$ 存在，则隐含着 $(u,w)$ 也必定存在。也就是说，图中存在**传递性**。

此时，该题目转化为：

> 构造一个 $2n$ 个结点的 2-SAT 有向图，使得该有向图恰好只能选择出给定的 $3$ 种方案。

例如：`1 0 1 0 1 1` 可以看作选择 ${1,-2,3,-4,5,6}$ 这 $6$ 个结点。

## 2. 关于本题

显然，本题内应该尽量纵向地考虑，即 $\forall i$，$a_i,b_i$ 和 $c_i$ 的关系。显然有以下三种：

1. $a_i=b_i=c_i=0$。此时可以用矛盾的办法，规定限制 `xi -> !xi`，也就是如果该位置为 $1$ 会产生矛盾，从而确保这一位的数值。
2. $a_i=b_i=c_i=1$。类似于1。
3. 三个数中有 $1$ 个$1$，$2$ 个 $0$，或者有 $1$ 个 $0$ 和 $2$ 个 $1$。

假如把某个位置 $i$ 的所需情况表示为 $a_i,b_i,c_i$，那么第三种情况可以分以下三个**类型**：

1. $1,1,0$ 和 $0,0,1$。
2. $1,0,0$ 和 $0,1,1$。
3. $0,1,0$ 和 $1,0,1$。

以第一类为例子，输入数据为：

```
5
0 1 1 0 0
1 1 1 0 0
1 0 0 1 0
```

首先对于 $0,0,0$，由于它可以自给自足，所以可以不在 2-SAT 过程中考虑这一列。之后尝试手算属于第 $1$ 类的中间 $3$ 列，发现满足条件的限制组合中可能包括以下几项：`x2 -> x3, !x2 -> !x3, x2 -> !x4, !x1 -> x4`。

转化成 2-SAT 图（注意以下图省略了边 $(u,v)$ 的对称边 $(-u,-v)$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ufcvfv2t.png)

这时，我们刚才推导的**对称性**和**传递性**就产生了作用。对于任何一个结点，它的选择取决于它的前代结点有没有被选择，而前代结点是否被选择关系到其前代结点是否被选择。以此类推，我们发现实际上 `x2 -> x3, x3 -> !x4` 这一类限制都可以转化成图中的 `x2 -> !x4`，也就是在不构造环的前提下，想要最小化限制的数目，就应该把限制都转化成 `u -> v` 的形式，且 **$u$ 没有前代结点**。

回归刚才的例子，可以联想到这样的过程就类似于**并查集**中的路径压缩，把其中一个 $1,1,0$ 对应的结点 $2$ 作为**代表节点**，统一连向所有其它形如 $1,1,0$，$0,1,1$ 的结点。这样**只要代表节点所处位置的值确定，其它形如它的位置的值都确定了**。例如在例子中，当位置 $2$ 的值为 $1$，就已经确定了位置 $3$ 为 $1$，位置 $4$ 为 $0$，反之同理。

在这一基础上，当**所有限制条件在 2-SAT 图上对称**，那么也就是说所有的可能情况实际上构成了若干个**弱联通分量**。可以发现，一共只有 $3$ 种类型，由于对称性，实际上就至多有 $6$ 个弱联通分量。

对于每个弱连通分量，很明显是一个菊花图，也就是实际上**所有其它结点都被代表结点所唯一确定**，因此得到终极推论：

**原问题和由不超过 $6$ 个代表节点所组成的 $n\le3$ 的问题等价。**

## 3. 解决

思路很简单，先在输入过程中处理出每个位置 $i$ 的**类型**，然后确定每种类型的从左往右数第一个位置为**代表结点** $u$ 的位置，按照思路向之后的每个同类结点 $v$（或 $-v$）建立限制。如果两者恰好相反（如$0,0,1$，$1,1,0$）就向 $v$ 和 $-v$ 两个结点中和自己的符号相反的那个建边。注意每个位置有 $2$ 个代表，所以每次要建立两条边 $(u,v),(-u,-v)$。

通过朴素算法测试发现，假如最后发现总共只有 $1$ 种类型的序列（除去三个元素都相同的那些序列），表示数据出现 $a,b,c$ 重复的情况，不符合题意；如果 $3$ 种都有，那么无论如何都**不可能对三个代表结点正确地互相限制**，进而会出现无解。

换言之，**只有恰好出现 $2$ 种本质不同类型序列时，才会有解**。

根据之前的分析，我们只需要考虑对代表结点进行限制，也就是问题转化成类似于：

```
2
1 0
1 1
0 0
```
显然可以把简化后的 $a',b',c'$ 看成两位二进制数，共有四种情况，其中没有出现在 $a',b',c'$ 中的就是需要排除掉的那一种，例如在本例子中，为了排除 $0,1$ 这种情况，增加限制 `!x1 -> !x2`、`x2 -> x1` 均可。

增加的这个限制加上最开始对于 $0,0,0$ 和 $1,1,1$ 的限制以及以**代表结点**为起始点建立的那些限制，即为答案。

```cpp
#include<iostream>
#include<fstream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;

int n,a[52],b[52],c[52];
int x[505],y[505],num;
bool tg[4];
//记录每个位置的类型 
int f[52],g[52];
//每个类型的代表结点位置 
int head[4];
//记录共有多少种类型、出现过的类型的编号(0,1,2) 
int cnt,s[4]; 
//一次加两条边 
inline void add(int ax,int ay){
	if(ax==ay) return;
	x[++num]=ax,y[num]=ay;
	x[++num]=-ax,y[num]=-ay;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	for(int i=1;i<=n;i++) scanf("%d",b+i);
	for(int i=1;i<=n;i++){
		scanf("%d",c+i);
		//对全0或全1加以限制 
		int t=a[i]+b[i]+c[i]; 
		if(t==0) x[++num]=i,y[num]=-i;
		else if(t==3) x[++num]=-i,y[num]=i;
		//100,010,001 
		else if(t==1) f[i]=(a[i]?0:(b[i]?1:2)),g[i]=1;
		//011,101,110 
		else f[i]=(!a[i]?0:(!b[i]?1:2)),g[i]=-1;
	}
	//从代表节点向其它结点连边 
	for(int i=1;i<=n;i++){
		if(!g[i]) continue;
		if(!head[f[i]]) cnt++,head[f[i]]=i,s[cnt]=f[i];
		//注意判断正负性 
		else add(head[f[i]],g[i]*g[head[f[i]]]*i);
	}	
	if(cnt==2&&num<=497){
		//限制没有出现在两个代表位置中的数 
		int tx=head[s[1]],ty=head[s[2]];
		tg[a[tx]*2+a[ty]]=1;
		tg[b[tx]*2+b[ty]]=1;
		tg[c[tx]*2+c[ty]]=1;
		for(int i=0;i<4;i++){
			if(!tg[i]) x[++num]=(i/2)?tx:-tx,y[num]=(i%2)?-ty:ty;
		}
	} else {
		printf("-1");
		return 0;
	}
	printf("%d\n",num);
	for(int i=1;i<=num;i++){
		if(x[i]<0) printf("!");
		printf("x%d -> ",abs(x[i]));
		if(y[i]<0) printf("!");
		printf("x%d\n",abs(y[i]));
	}
	return 0;
}
```

---

## 作者：zhylj (赞：3)

为什么大家的题解这么长，是我假了吗？

一个显然的构造是，把所有合法的限制全部加上，这样能筛掉尽可能多别的解，而保留这三个解，然后用某种方法 Check 是否恰好只有三个解，但这样边的总数是 $\mathcal O(n^2)$ 的，无法通过。

考虑在此情况下 $(v_{1,i},v_{2,i},v_{3,i})$ 完全相同的点必然连了完全相同的边，所以一个等价的构造是把相同的 $(v_{1,i},v_{2,i},v_{3,i})$ 找个代表元全部连上双向边，表示它们之间 $x_i$ 的值永远相同，然后再在代表元之间满连边就好了。

总共的边数不会超过 $2(n+(2^3)^2)$，非常轻松。

还有一个问题是如何 Check 是否只有恰好三个解，注意到我们已经连了一大堆等价关系，所以只需暴力枚举 $2^8$ 种代表元的取值，然后判断一下是否只有三种取值满足限制就好了。

[代码写的比较暴躁，谨慎参考](https://www.luogu.com.cn/paste/v007o9kz)。

---

## 作者：zichen3004 (赞：0)

很有意思的题目，就是我代码能力太差，写了很久。

> 看本题解之前，请先看懂以下的操作：
> 
> **约束** $A$ 和 $B$：进行一些操作，使当 $A$ 的值确认时，可以确认 $B$ 的值；同样地，当 $B$ 的值确认时，可以确认 $A$ 的值。
> 
> 这需要 $4$ 步，具体实现可以看代码中的 Combine 函数。

拿到手，认为给定三个序列一定有什么深意，发现如果完全相同非常好处理：

我们认为他是独立的，单独处理，具体方法如下：

假设三个序列中该项全部为 $1$，只需规定该项为 $0$ 时一定为 $1$，就可以制造矛盾，从而使该项全部为 $1$。

反之亦然，不做赘述。

否则，会出现三个数字分别为 $1, 1, 0$ 或者 $1, 0, 0$（排序不分前后）的情况。无论哪种情况，我们发现，都会有一个序列中的一项是独一无二的，我们称其为该序列的特征项，并且所有特征项组成一个该序列的特征序列。

$B$，$C$ 中与 $A$ 的特征项对应的项组成的序列一定与 $A$ 的特征序列处处相反，所以，三个序列中，对于所有 $A$ 的特征项，只有两种可能，$A$ 或反 $A$。

形象化地，假如 $A$ 的特征项组成的序列为：


```
1 1 0 0 1
```

那么，$B$ 和 $C$ 对应项一定是：

```
0 0 1 1 0
```

约束以上的第一项和其余所有项。

 _以上的约束操作本质是建立一个 SCC，使任意一项确定时其余所有项都确认，为了偷懒采用建立菊花，另一种可行的方案是建立一个环，边数会少一半。_ 

 现在我们来考虑无解，就是说，会有一个数字没有办法被约束。

 先抛一个非常简单的无解例子，建议大家手玩后看讲解：

 
```
1 0 0
0 1 0
0 0 1
```

以下这个数列无论如何都不会被限制到：

```
0 0 0
```

为什么呢？

因为假设这个位置的值为 $0$，他就不会被用来限制任何一个位置。

换而言之，无论你的做法是什么，对于以上的例子，你输出的第一项都不会带感叹号。

而本质的原因，就是三个序列都有特征值，以上的例子其实是一个元，对于其中一列全部取反，或者交换两列，这么操作若干次后，得到的都是元。

原理是，这本质是一个数独，每行每列都有一个特征值。对于一列，只有特征值可以用来限制其他值，假设这个值不是特征值，我们抽掉特征值的一行，那么对于另一列，这一行上如果是特征值，另一行就不是；如果这行不是，另一行就是，出现了：非特征值+特征值和非特征值+非特征值，无论约束哪两个都会矛盾。

所以不能三行都有特征值。此时是否一定有解呢?

不妨分类：

没有特征值，所有的项都独立处理即可。

只有一行有特征值，设特征序列 $A$，则只有 $A$ 和 $!A$，不做赘述。

两行有特征值，设特征序列 $A$、$B$，其相反序列（所有位置全部取反）为 $!A$，$!B$，则共有四种。

$A+B$，$A+!B$，$!A+B$，$!A+!B$

有特征的序列分别是 $A+!B$ 和 $!A+B$，看一下剩下的一个序列是 $A+B$ 还是 $!A+!B$ 即可，排除掉另一个。

排除的过程是半个约束，具体实现见代码。


```cpp
#include<bits/stdc++.h>
using namespace std;

int a[505][5];
int n, ans;
vector<int> ft[4];
void Combine(int Nod1, int id1, int Nod2, int id2)
{
	int v1 = a[id1][Nod1], v2 = a[id2][Nod2];
	if(v1 ^ v2 == 0)
	{
		printf("x%d -> x%d\n", id1, id2);
		printf("x%d -> x%d\n", id2, id1);
		printf("!x%d -> !x%d\n", id1, id2);
		printf("!x%d -> !x%d\n", id2, id1);
	}
	if(v1 ^ v2)
	{
		printf("x%d -> !x%d\n", id1, id2);
		printf("!x%d -> x%d\n", id2, id1);
		printf("x%d -> !x%d\n", id2, id1);
		printf("!x%d -> x%d\n", id1, id2);
	}
}

// 独立处理的部分
void DealInd()
{
	for(int i = 1; i <= n; i++)
	{
		int TYPE = a[i][1] + a[i][2] + a[i][3];
		if(TYPE == 0)
			printf("x%d -> !x%d\n", i, i);
		else if(TYPE == 3)
			printf("!x%d -> x%d\n", i, i);
	}
}

int main()
{
	cin >> n;
	for(int op = 1; op <= 3; op++)
		for(int i = 1; i <= n; i++)
			cin >> a[i][op];
	for(int i = 1; i <= n; i++)
	{
		int TYPE = a[i][1] + a[i][2] + a[i][3];
		if(TYPE == 1 || TYPE == 2)
		{
			int Feature;
			for(int j = 1; j <= 3; j++)
				if(a[i][j] == -TYPE + 2) // 这行是一点小技巧，如果有两个 1 那么就是找 0，反之亦然
					Feature = j;
			ft[Feature].emplace_back(i);
		}
		else
			ans++;
	}
	int EmpNum = ft[1].empty() + ft[2].empty() + ft[3].empty();
	if(EmpNum == 0)
	{
		cout << -1 << endl;
		return 0;
	}
	
	if(EmpNum == 3)
	{
		cout << ans << endl;
		DealInd();
		return 0;
	}

	if(EmpNum == 2)
	{
		int Em;
		for(int i = 1; i <= 3; i++)
			if(!ft[i].empty())
				Em = i;
		cout << ans + 4 * (ft[Em].size() - 1) << endl; // 独立处理的数量加菊花的边数
		DealInd();
		for(int i = 1; i < ft[Em].size(); i++)
			Combine(Em, ft[Em][0], Em, ft[Em][i]);
		return 0;
	}
	int Em, H1, H2;
	for(int i = 1; i <= 3; i++)
		if(ft[i].empty())
			Em = i, H1 = i % 3 + 1, H2 = (i % 3 + 1) % 3 + 1;
	cout << ans + 4 * (ft[H1].size() - 1) + 4 * (ft[H2].size() - 1) + 1 << endl; // 两朵菊花
	DealInd();
	for(int i = 1; i < ft[H1].size(); i++)
		Combine(H1, ft[H1][0], H1, ft[H1][i]);
	for(int i = 1; i < ft[H2].size(); i++)
		Combine(H2, ft[H2][0], H2, ft[H2][i]);
	int st1 = ft[H1][0], st2 = ft[H2][0];
// 下面就是所谓的半个约束，建议手玩，不好理解
	if(a[st1][Em] && a[st2][H2])
		printf("!x%d -> !x%d\n", st1, st2);
	if(a[st1][Em] && !a[st2][H2])
		printf("!x%d -> x%d\n", st1, st2);
	if(!a[st1][Em] && a[st2][H2])
		printf("x%d -> !x%d\n", st1, st2);
	if(!a[st1][Em] && !a[st2][H2])
		printf("x%d -> x%d\n", st1, st2);
	return 0;
}

```

最后提一嘴，题目样例有点水了，给一组精炼的样例，很适合手玩：

```
4
0 1 0 1
1 0 1 0
1 1 1 1
```

---


# [NEERC 2015] Hypercube

## 题目描述

考虑一个 $4$-超立方体，也称为四维超正方体。一个单位实心四维超正方体是一个四维图形，它等于 $16$ 个点的凸包，这些点的笛卡尔坐标为 $(\pm\frac{1}{2}, \pm\frac{1}{2}, \pm\frac{1}{2}, \pm\frac{1}{2})$，即它的顶点。它有 $32$ 条边（$1D$），$24$ 个正方形面（$2D$），以及 $8$ 个立方体 $3$-面（$3D$），也称为单元。我们研究空心四维超正方体，并将四维超正方体定义为一个实心四维超正方体的边界。因此，四维超正方体是 $8$ 个实心立方体（其单元）的连接联合，这些立方体在四维超正方体的 $24$ 个正方形面、$32$ 条边和 $16$ 个顶点之间相交。

让我们沿着四维超正方体的 $24$ 个面中的 $17$ 个面切割它，使其仍然通过剩下的 $7$ 个未被切割的面保持连接。通过沿着未被切割的面旋转其构成立方体，将四维超正方体展开到三维超平面中，直到其所有单元都位于同一三维超平面中。结果称为四维超正方体的 $3$-网。这一过程是三维立方体如何被切割并展开到二维平面上以产生由 $6$ 个正方形组成的立方体的 $2$-网的自然推广。

在这个问题中，给定一个树状的 $8$-多立方体，也称为八立方体。八立方体是由 $8$ 个单位立方单元面对面连接而成的集合。更正式地说，构成八立方体的每对立方单元的交集要么为空，要么是一个点、一个单位线（$1D$），或一个单位正方形（$2D$）。给定的八立方体在以下意义上是树状的。考虑八立方体的邻接图——一个有 $8$ 个顶点的图，对应于其 $8$ 个单元。邻接图中存在一条边连接相邻单元对。当两个八立方体的单元的交集是一个正方形时，它们被称为相邻。当它们在一个点或一条线上相交时，不被认为是相邻的。当其邻接图是树时，八立方体被称为树状。

你的任务是确定给定的树状八立方体是否构成四维超正方体的 $3$-网。也就是说，这个八立方体是否可以放置在四维空间的超平面上，并沿其单元之间的交叉正方形在四维空间中折叠成一个四维超正方体。

例如，看看下面最左边的图片。它显示了树状八立方体的线框。将单元 $GHLKG_{1}H_{1}L_{1}K_{1}$ 绕平面 $GHLK$ 旋转，将单元 $FGKJF_{2}G_{2}K_{2}J_{2}$ 绕平面 $FGKJ$ 在第四维度上旋转 $90$ 度，超出原始超平面。结果，点 $G_{1}$ 与 $G_{2}$ 结合，$K_{1}$ 与 $K_{2}$ 结合。面 $GKK_{2}G_{2}$ 粘合到面 $GKK_{1}G_{1}$。结果如右图所示。第四维度正交投影到所示的三维透视图中。那些从原始超平面移出的点用空心点标记。

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)

旋转 $EFJIE_{1}F_{1}J_{1}I_{1}$ 绕 $EFJI$，旋转 $EHLIE_{2}H_{2}L_{2}I_{2}$ 绕 $EHLI$。结果如下面左图所示。剩下的步骤如下。绕 $MNOPQRST$ 旋转，然后绕 $IJKL$ 旋转 $MNOPQRST$ 和 $IJKLMNOP$，最后绕 $EFGH$ 旋转 $ABCDEFGH$。最后一步是将所有相遇的面粘合在一起，得到右图所示的四维超正方体。

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)

## 说明/提示

时间限制：1 秒，内存限制：256 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3 3 4
...
.x.
...
.x.
xxx
.x.
...
.x.
...
...
.x.
...
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
8 1 1
xxxxxxxx
```

### 输出

```
No
```

# 题解

## 作者：zhylj (赞：3)

考虑如何判断一个二维图形是否能够折成一个正方体：随意选择一个底面放在 $Oxy$ 平面上，然后令 $z$ 轴正方向为指向正方体内部的方向。我们每次把一个面的所有相邻面都向上翻（也就是向内翻），同时递归到所有相邻面继续折，若最后没有面重合，那么就合法。

接下来考虑如何把上述做法推广到四维，假设我们放的超立方体个顶点和原点重合，其余的一些棱分别和四个坐标轴重合。记四个坐标轴分别为 $x,y,z,w$，我们随便选一个正方体放在 $Oxyz$ 空间中，然后把其它立方体向“上”翻，然后变换一下坐标系使得 $w$ 轴始终朝内，当前立方体始终在 $Oxyz$ 空间内。

维护垂直于 $x,y,z,w$ 轴的立方体，不难发现这样的立方体有两个，两两一组都垂直于其中一个坐标轴，我们只需要记一下其中离原点最近的一个的编号即可，接下来我们考虑某个坐标轴上的两个分别向内翻折的情况，以 $x$ 轴为例：

- 取的是 $x$ 轴上远离原点的向内翻折，则以新立方体为底面的内侧在 $x$ 轴的反方向，但 $x$ 轴上新的离原点最近的立方体变成了原先离原点最远的立方体。
- 取的是 $x$ 轴上靠近原点的向内翻折，则以新立方体为底面的内侧在 $x$ 轴的正方向，但 $w$ 轴也跟着转了，于是 $w$ 轴上新的离原点最近的立方体变成了原先离原点最远的立方体。

- 其他维同理。

不难写个 DFS 解决问题。

```cpp

const int N = 10;

int m, n, k, v_cnt, p[N], vis[N];
char str[N][N][N];

void Dfs(int x, int y, int z, int a, int b, int c, int d) {
	str[x][y][z] = '.';
	++vis[d];
	if(str[x + 1][y][z] == 'x') Dfs(x + 1, y, z, d ^ 1, b, c, a);
	if(str[x - 1][y][z] == 'x') Dfs(x - 1, y, z, d, b, c, a ^ 1);
	if(str[x][y + 1][z] == 'x') Dfs(x, y + 1, z, a, d ^ 1, c, b);
	if(str[x][y - 1][z] == 'x') Dfs(x, y - 1, z, a, d, c, b ^ 1);
	if(str[x][y][z + 1] == 'x') Dfs(x, y, z + 1, a, b, d ^ 1, c);
	if(str[x][y][z - 1] == 'x') Dfs(x, y, z - 1, a, b, d, c ^ 1);
}

int main() {
	rd(m, n, k);
	for(int x = 1; x <= k; ++x)
		for(int y = 1; y <= n; ++y)
			scanf("%s", str[x][y] + 1);
	for(int x = 1; x <= k; ++x)
		for(int y = 1; y <= n; ++y)
			for(int z = 1; z <= m; ++z)
				if(str[x][y][z] == 'x') {
					Dfs(x, y, z, 0, 2, 4, 6);
					bool flag = true;
					for(int i = 0; i < 8; ++i)
						if(vis[i] != 1) {
							flag = false;
							break;
						}
					if(flag) printf("Yes\n");
					else printf("No\n");
					return 0;
				}
	return 0;
}
```

---


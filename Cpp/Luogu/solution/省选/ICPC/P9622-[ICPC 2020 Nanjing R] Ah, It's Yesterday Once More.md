# [ICPC 2020 Nanjing R] Ah, It's Yesterday Once More

## 题目描述

2018 年，由南京航空航天大学（NUAA）主办的 $\textit{国际大学生程序设计竞赛}$（ICPC）区域赛在南京再次举行，这是在经过几年的间隔后再次举办。比赛中有超过 $400$ 支队伍参加，清华大学的队伍 $\textit{Power of Two}$ 获得了冠军。

两年过去了，在 2018 年和 2019 年取得巨大成功后，NUAA 继续在 2020 年举办 ICPC 南京区域赛。尽管由于疫情我们这次无法在南京聚集，但我们仍应感谢所有工作人员和志愿者为这次比赛所做的辛勤工作。感谢你们为这次比赛做出的巨大贡献！

在 2018 年的比赛中，问题 K，$\textit{袋鼠拼图}$，要求参赛者为游戏构建一个操作序列。让我们先回顾一下该问题的内容：

> 这个拼图是一个有 $n$ 行 $m$ 列的网格（$1 \le n, m \le 20$），其中有一些（至少 $2$ 只）袋鼠站在拼图中。玩家的目标是控制它们聚集在一起。某些单元格中有墙，袋鼠不能进入有墙的单元格。其他单元格是空的。袋鼠可以从一个空单元格移动到相邻的空单元格，方向有四个：上、下、左、右。保证袋鼠可以通过相邻的空单元格从任何空单元格到达任何其他空单元格。还保证拼图中没有循环——也就是说，不可能有袋鼠从一个空单元格出发，经过几个不同的空单元格，然后回到原来的单元格。

> 每个空单元格开始时恰好有一只袋鼠，玩家可以通过按键盘上的 U、D、L、R 按钮来控制袋鼠。袋鼠将根据您按下的按钮同时移动。例如，如果您按下按钮 R，袋鼠会向右移动一个单元格，如果存在且为空，否则将保持不动。

> 在这个问题中，参赛者需要构建一个最多包含 $5 \times 10^4$ 步的操作序列，只能由 U、D、L、R 组成。如果按顺序操作这些步骤后，仍然有两只袋鼠站在不同的单元格中，参赛者将得到一个 `Wrong Answer` 判定。

我们的亲爱朋友 Kotori 也参加了比赛，并提交了一段随机算法的代码。令她惊讶的是，这个简单的解决方案被判定为正确答案。我们现在展示她的解决方案如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s = "UDLR";
int main()
{
  srand(time(NULL));
  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);
  return 0;
}
```

对于不熟悉 C 和 C++ 的参赛者：上述代码将输出一个长度为 $5 \times 10^4$ 的随机字符串，仅由字符 `U`、`D`、`L` 和 `R` 组成，其中每个字符在字符串中的每个位置出现的概率相等。

Kotori 怀疑这个问题可能没有那么简单，所以现在，在这次 $\textit{2020 ICPC 南京区域赛}$ 中，你需要构造一个输入数据来破解她的解决方案。由于随机性，您的输入数据只需满足至少 $25\%$ 的成功破解率。

正式地说，我们准备了 $500$ 个随机生成的字符串，每个字符在每个位置出现的概率相等，并将它们用作控制序列来对抗您的答案。为了使您的答案被接受，在使用您的答案作为单元格地图并执行整个控制序列后，至少有 $125$ 次袋鼠仍在不同的单元格中。

请注意，您的输入数据必须完全合法。也就是说：

- 您答案中的地图不应大于 $20 \times 20$；
- 您的答案应至少包含两个空单元格；
- 您答案中的所有空单元格应从任何空单元格开始是可达的；
- 不允许存在由空单元格组成的循环。

## 说明/提示

### 注意

我们提供的示例输出（显然）是错误的。它仅用于向您展示输出格式。这是一个 $3 \times 4$ 的地图，开始时有 $4$ 墙，因此在空单元格中将有 $8$ 只袋鼠。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
(No input)```

### 输出

```
3 4
1111
1010
1100
```

# 题解

## 作者：cff_0102 (赞：6)

路径越曲折，空格越多，那么这些袋鼠就越不可能走到同一个格子上。这很容易看出，因为路径曲折说明（第一次）所有袋鼠一起移动时有大约一半原地不动，袋鼠多就说明要实现让更多的袋鼠走到一个格子上，就更难让随机程序通过。

所以尝试构建一个路线曲折、空格尽可能多的地图。

首先先搞一个全是墙的地图，接着将左上角填成 `1`。在一个 $4\times4$ 的小方格中，L 形是空格最多的，应优先使用。所以在左上角摆几个 L 形。接着继续向外延伸，延伸的过程中时刻注意不要出现环，且路径尽可能曲折即可。接下来就凭直觉搞就好了。尽量不要把多个 `0` 连在一起，尽量不要把多个 `1` 连在一条直线上。

如果不是程序生成的，那么提交上去时未免可能会有一些 bug，比如所有空洞连起来不是一棵树，出现了循环。下面是判断循环的一种方法。

![](https://cdn.luogu.com.cn/upload/image_hosting/8bim8oz6.png)

假如有 `0` 的联通块没有接到最外面，则它周围一圈就是一个循环，要将其打断。

为了不伤眼睛，有一种办法是在 Excel 里面先用给单元格涂色的方法搞好，接着再把颜色转换成 `0` 或 `1`。全选复制之后记得把 Tab 删掉。

按照上面的方法硬构造比较难把 hack 成功率凑到 $25\%$。这里提供一个符合条件的构造方法，直接搞一个像下图一样从左上折到右下又折回左上的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/eto4783s.png)

上图是一个 $10\times10$ 的示例，但是为了满足题目要求，数据规模要扩大到 $20\times20$ 才行。

一个符合要求的地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/xvc0n6my.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/r2uy14d2.png)

PHP AC 代码：

```php
20 20
11101111101111101111
10110010110010110010
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011001
11101101101101101101
10110110110110110110
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011001
11101101101101101101
10110110110110110110
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011010
11101001101001101001
10111110111110111111
```

AC 记录：<https://www.luogu.com.cn/record/137495731>。

---

## 作者：Genshin_ZFYX (赞：5)

**~~天打雷劈我也没想到我竟然写出了紫题的题解了~~**

为了让更多袋鼠存在，我们最好满足这 $2$ 个条件：

* 1.让袋鼠数量尽可能得多，这样就需要更多的聚在一起
* 2.道路要尽量曲折，这才能让袋鼠合并所需要的步数变多。

不难想到可以用蛇形的路径和阶梯形的路径：

蛇形路径（最后两行改为竖形的蛇形路径）：
```
20 20
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000100010001000100
10111011101110111011
11101110111011101110
```

阶梯型路径（在草稿纸上画一下就能得出来了）：
```
20 20
11100011100011101100
10110110110110110110
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011010
11101101101101101100
10110110110110110110
11011011011011011011
01101101101101101101
00110110110110110111
01011011011011011001
11101101101101101100
10110110110110110110
11011011011011011011
01101101101101101101
00110110110110110111
01011011011011011001
11101101101001101001
10101010100110111110
```

注：阶梯型路径成功几率略大。

---

## 作者：dinghongsen (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P9622)

#### 题目描述

在一个 $20\times20$ 的网格上，构造一棵树（边是四连通）。

满足：树上每个点上有一个人，每次随机上下左右走一格（走到树外则原地不动消耗一次），有超过 $25\%$ 的概率 $50000$ 步后所有人不会走到同一个点。

#### 解题思路

只需尽可能让路径长，就是要让空间利用率尽可能高。蛇形路径空间利用率（约
 12）（可以随机求一下概率），阶梯型路径利用率高就可以过了（约 23）。

阶梯型拿 excel 随便搞搞就弄出来了

[代码部分](https://www.luogu.com.cn/paste/dg5ks6lo)

---

## 作者：A_grasser (赞：3)

## 题意简化

一堆袋鼠在 $n\times m$ 的网格中随机向四个方向移动，请构造一种地图，使得至少 $125$ 条指令后，它们未都到同一个格子上。要求图联通且无环。

## 需要注意的地方

1. 注意满足图联通且无环的条件。

## 解法分析

如果你问这道题思路，那么还是非常简单的，只要尽力把图设计的复杂、难走，那么袋鼠越难聚集。于是就有以下几条思路：

- 图越大越好。

- 图的形状为梯形或蛇形。

- 道路尽可能窄。

选择梯形还是蛇形看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/75z70qm6.png)

显然梯形利用率更高，在越大的图中，这种优势越明显。

解决一个实际中会遇到的问题：由于是手搓的，所以不小心会造成图联通且无环的条件不成立，下面是一种可行的检查方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/80ga3vrj.png)

如图蓝色联通快（不是路）没有联通到图外面，那么它就一定不满足条件。

温馨提示：建出图来可以直接用 php 语言提交，省时省力。

## 完整代码

```php
20 20
11100011100011101100
10110110110110110110
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011010
11101101101101101100
10110110110110110110
11011011011011011011
01101101101101101101
00110110110110110111
01011011011011011001
11101101101101101100
10110110110110110110
11011011011011011011
01101101101101101101
00110110110110110111
01011011011011011001
11101101101001101001
10111000111110111110
```

---

## 作者：wflhx2011 (赞：1)

# Solution 

个人认为一道比较水的紫题。

不难想到，要让更多袋鼠存在，应该有 $2$ 个条件：

1. 袋鼠数量多，这样就需要更多袋鼠聚在一起。

1. 道路曲折，这样才能让袋鼠合并的步数多。

这里容易想到的两种一种是阶梯形，如：

```php
01
11
```
或者蛇形：

```php
01
10
```
当然，肯定阶梯形成功的几率大。

之后拿出纸和笔写写就行，注意一下需要连通和无环。

建议直接写成代码，到时候如果抄错了要查好久。

### 代码

```php
20 20
11100011100011101100
10110110110110110110
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011010
11101101101101101100
10110110110110110110
11011011011011011011
01101101101101101101
00110110110110110111
01011011011011011001
11101101101101101100
10110110110110110110
11011011011011011011
01101101101101101101
00110110110110110111
01011011011011011001
11101101101001101001
10111000111110111110
```

---

## 作者：WhitD (赞：1)

## 题目大意
要求构造一个 $m\times n$ 的迷宫，$1$ 表示路，$0$ 表示障碍。迷宫中有一群袋鼠，他们随机移动 $5\times10^4$ 次（向上下左右任意方向走一个格子），构造的迷宫要尽可能让他们最终不会走到同一个格子上。迷宫中不能存在循环（一个格子不经过重复点还能走回这个格子），并且必须是联通的。
## 思路
首先我们要明确，如果有操作是要求我们走到边界或者是障碍物，那么这次操作相当于浪费了（袋鼠不会动）。因此迷宫的路一定是越窄越好，这样就可以尽可能多的浪费操作次数；然后我们还要让迷宫尽可能的长（减少 $0$ 的出现次数），这样可以使袋鼠走到同一个格子更加困难。

分析后可以发现阶梯型的迷宫是最优的（不用回型图是因为浪费太多格子了），在表格里随便画画就得到答案了。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<"20 20\n11100011100011101100\n10110110110110110110\n11011011011011011011\n01101101101101101101\n10110110110110110111\n10011011011011011010\n11101101101101101100\n10110110110110110110\n11011011011011011011\n01101101101101101101\n00110110110110110111\n01011011011011011001\n11101101101101101100\n10110110110110110110\n11011011011011011011\n01101101101101101101\n00110110110110110111\n01011011011011011001\n11101101101001101001\n10111000111110111110\n";
    return 0;
}
```


---

## 作者：Shadow_T (赞：1)

### 简化题意

对于给定的 $n×m$ 的方格，$0$ 代表障碍，$1$ 代表袋鼠。有一串随机生成的长为 $5×10^4$ 的指令，仅包含 `LRUD` 字符，分别表示将所有袋鼠同时向某个方向移动（若能移动，即不经过障碍、不超出方格范围）。现要求构造一个 $n×m$ 方格图，使得对于随机生成的 $500$ 串指令，至少有 $125$ 个满足执行后，所有袋鼠不都在同一个方格。要求构造的袋鼠方格连通、且不含环。

by uid $1001552$。

### 题目解法

一道非常可爱（怕）的题。

尽量用蛇形路径（约 $50\%$ ），如果构造不出来了，就用阶梯型路径（约 $75\%$），这样可以减少利用率。

对于蛇形路径的解释：

```
01
10
```

很明显是 $\displaystyle  \frac{2}{4}=\frac{1}{2}$。

阶梯型路径：

```
01
11
```

是 $\displaystyle  \frac{3}{4}$。

拿出纸笔模拟下，就可打出一张表格。

大概率可以过，如果一次过不了，就交两次。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	cout<<20<<" "<<20<<"\n";
	puts("11111101111101111101");
	puts("10010110010110010111");
	puts("01011011011011011001");
	puts("11101101101101101101");
	puts("10110110110110110110");
	puts("11011011011011011011");
	puts("01101101101101101101");
	puts("10110110110110110111");
	puts("10011011011011011001");
	puts("11101101101101101101");
	puts("10110110110110110110");
	puts("11011011011011011011");
	puts("01101101101101101101");
	puts("10110110110110110111");
	puts("10011011011011011001");
	puts("11101101101101101101");
	puts("10110110110110110110");
	puts("11011011011011011011");
	puts("01001101001101001101");
	puts("11110111110111110111");
}
```

---

## 作者：Oracynx (赞：1)

## P9622 [ICPC2020 Nanjing R] Ah, It's Yesterday Once More 题解

### 题目翻译

### [Link](https://www.luogu.com.cn/paste/2z009f9f)

### 思路分析

由于本题的要求是由 $5 \times 10^4$ 个随机字符串，所以操作是无规律的。我们只需要构造一个**蜿蜒曲折**的迷宫即可，同时要让这个迷宫尽**可能的长**，而且一条路的宽度**要尽可能小**（亲测会 WA，不信你可以提交[这份代码](https://www.luogu.com.cn/paste/4lpg4j59)）。注意让所以的 $\texttt{1}$ 连通。下面是一种合适的解法。

### 代码实现

构造题，没啥好说的。

```cpp
#include <cstdio>
int main()
{
    printf("20 20\n"
           "11111011111011111011\n"
           "00101100101100101101\n"
           "10110110110110110111\n"
           "10011011011011011001\n"
           "11101101101101101101\n"
           "10110110110110110110\n"
           "11011011011011011011\n"
           "01101101101101101101\n"
           "10110110110110110111\n"
           "10011011011011011001\n"
           "11101101101101101101\n"
           "10110110110110110110\n"
           "11011011011011011011\n"
           "01101101101101101101\n"
           "10110110110110110111\n"
           "10011011011011011001\n"
           "11101101101101101100\n"
           "10110110110110110111\n"
           "11011010011010011001\n"
           "01101111101111101111\n");
    return 0;
}
```

---

## 作者：zyn_ (赞：0)

为了卡掉随机算法，考虑如下策略：

1. 地图应形如一条小路，路要又窄又长。

2. 地图中应该有尽量多的 $1$，这样袋鼠的数量较多，当然就更难聚集到一个点上。

尝试构造一条从左下到右上来回弯转的路径。

于是可以写出以下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	for(int i=1;i<=20;++i){
		for(int j=1;j<=20;++j){
			if((i+j)%3==1)putchar('0');
			else putchar('1');
		}
		puts("");
	}
	return 0;
}
```

得到输出：

```
11011011011011011011
10110110110110110110
01101101101101101101
11011011011011011011
10110110110110110110
01101101101101101101
11011011011011011011
10110110110110110110
01101101101101101101
11011011011011011011
10110110110110110110
01101101101101101101
11011011011011011011
10110110110110110110
01101101101101101101
11011011011011011011
10110110110110110110
01101101101101101101
11011011011011011011
10110110110110110110
```

然后修改一下输出，使其符合地图的要求（连通，无环），再进行一点优化（增加 $1$ 的数量）。

就做完了。

```
20 20
11111011111011111010
10100110100110100111
01101101101101101101
11011011011011011001
10110110110110110111
11101101101101101101
01011011011011011010
10110110110110110111
11101101101101101101
10011011011011011001
10110110110110110111
11101101101101101101
01011011011011011010
10110110110110110111
11101101101101101101
10011011011011011011
10110110110110110110
11101101101101101101
01011011001001011011
11101110111111101110
```

---

## 作者：封禁用户 (赞：0)

题意很清楚了，这里就不说了

这题是构造，然而乱搞也可以

虽然蛇形不如楼梯型利用率高，但是搞得好也可以

最普通的蛇形：

```
20 20
10101010101010101010
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
```

由于太朴素，只 hack 了 $112$ 个

稍微转转方向，没什么用

不过，最后一行的 $01$ 间隔只能使路径长度加一，效果不好，所以考虑最后一行再变成竖直方向的蛇形：

```
20 20
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
10111011101110111011
11101110111011101110
```

这时能 hack $123$ 个点，说明还差一点点

发现倒数第三行有几个空位，塞上 $1$：

```
20 20
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000000000000000000
11111111111111111111
00000000000000000001
11111111111111111111
10000100010001000100
10111011101110111011
11101110111011101110
```

终于过了，正好 $125$ 个点，不多不少

看到这里，恭喜你，成功的乱搞过了一道紫题

[AC 记录](https://www.luogu.com.cn/record/139243853)

---


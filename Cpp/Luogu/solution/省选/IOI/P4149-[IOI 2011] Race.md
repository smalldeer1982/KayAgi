# [IOI 2011] Race

## 题目描述

给一棵树，每条边有权。求一条简单路径，权值和等于 $k$，且边的数量最小。

## 说明/提示

对于 $100\%$ 的数据，保证 $1\leq n\leq 2\times10^5$，$0\leq k,w_i\leq 10^6$，$0\leq u_i,v_i<n$。

## 样例 #1

### 输入

```
4 3
0 1 1
1 2 2
1 3 4```

### 输出

```
2```

# 题解

## 作者：AThousandSuns (赞：57)

点分治裸题。

具体说一下做法：当前重心是 $r$ 时，计算所有经过 $r$ 的路径。因为 $k\le 10^6$，我们便可以开个桶，$mine[i]$ 表示从 $r$ 开始的权值和为 $i$ 的所有路中，边数的最小值。

更新答案时，我们用当前子树的所有距离和前面子树的桶。思想应该不难想，就是 $ans=\min(ans,cnt[v]+mine[k-dis[v]])$，具体实现可以看代码。

由于没有二分，复杂度似乎是 $O(n\log n)$？我就说怎么一看比别人快的样子……（开O2总时间2816ms，最大点396ms）

要注意的是求的是一个最小值，不满足可减性，所以不能像洛咕日报上那样把多加的减回去。

然后这题似乎卡栈空间……把递归函数中能不用的变量不用就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200020,maxk=1000100;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,k,el,head[maxn],to[maxn*2],w[maxn*2],nxt[maxn*2];
int rt,tot,sz[maxn],son[maxn],mine[maxk],ans=INT_MAX,dis1[maxn],dis2[maxn],dl;
bool vis[maxn];
inline void add(int u,int v,int w_){
	to[++el]=v;w[el]=w_;nxt[el]=head[u];head[u]=el;
}
void getrt(int u,int f){	//求重心
	sz[u]=1;son[u]=0;
	for(int i=head[u];i;i=nxt[i]){
    	//v=to[i]不是必需的，可以去掉
		if(to[i]==f || vis[to[i]]) continue;
		getrt(to[i],u);
		sz[u]+=sz[to[i]];son[u]=max(son[u],sz[to[i]]);
	}
	son[u]=max(son[u],tot-sz[u]);
	if(son[u]<son[rt]) rt=u;
}
void getdis(int u,int f,int d1,int d2){	//dfs将子树的信息记录下来（d1是权值和，d2是边数）
	if(d1>k) return;
	dis1[++dl]=d1;dis2[dl]=d2;
	for(int i=head[u];i;i=nxt[i]){
    	//同上
		if(to[i]==f || vis[to[i]]) continue;
		getdis(to[i],u,d1+w[i],d2+1);
	}
}
void getans(int u){	//计算经过u的路径的答案
	mine[0]=0;dl=0;	//mine[0]是0！因为一个端点是u的路径也要考虑，而且0不会被其它子树记录到
	for(int i=head[u];i;i=nxt[i]){
		if(vis[to[i]]) continue;
		int pdl=dl;	//前面的子树有多少元素
		getdis(to[i],u,w[i],1);	//注意调用时w[i]和1
		FOR(j,pdl+1,dl) ans=min(ans,mine[k-dis1[j]]+dis2[j]);
        //更新答案
		FOR(j,pdl+1,dl) mine[dis1[j]]=min(mine[dis1[j]],dis2[j]);
        //更新桶
	}
	FOR(i,1,dl) mine[dis1[i]]=1e9;
}
void getall(int u){	//点分治主过程
	vis[u]=true;
	getans(u);
	for(int i=head[u];i;i=nxt[i]){
		if(vis[to[i]]) continue;
		tot=sz[to[i]];rt=0;
		getrt(to[i],u);
		getall(rt);
	}
}
int main(){
	n=read();k=read();
	FOR(i,1,n-1){
		int u=read()+1,v=read()+1,w=read();	//编号从0开始
		add(u,v,w);add(v,u,w);
	}
	son[0]=(tot=n)+1;	//son[0]设为INF
	getrt(1,0);
	MEM(mine,0x3f);
	getall(rt);
	printf("%d\n",ans>=n?-1:ans);	//最短长度超过n就是无解
}
```

---

## 作者：bzy369258147 (赞：23)

这么好的题，为什么没有人用可爱的dsu on tree

第一遍dfs的时候每个点记录一下到根节点的路径长度，和到根节点的路径点数.

套路使用dsu on tree 维护一个map，保存每个长度对应的最小深度，然后在每个节点查询一下答案，最后取一下最小值即可.思维难度偏低，代码难度差不多是NOIP.

关于 dsu on tree,推荐一个[blog](http://codeforces.com/blog/entry/44351)

STL + C++11 食用最嘉.

以下代码实现

```
#include<bits/stdc++.h>
using namespace std;

int n,k;
vector<int>to [200005];
vector<int>len[200005];
long long deep[200005];
int diep[200005];
int size[200005];
int son [200005];
int nid [200005];
int id  [200005];
int cnt;

map< long long,int >dep;
int ans = 1e9;

void dfs1(int now,int last){
    size[now] = 1;
    id  [now] = ++ cnt;
    nid [cnt] = now;
    int mx = 0;
    for(int i = 0;i < to[now].size();i ++){
        int next = to[now][i];
        if( next == last )continue;
        deep[next] = deep[now] + len[now][i];
        diep[next] = diep[now] + 1;
        dfs1( next,now );
        size[now] += size[next];
        if( size[next] > mx ){
            mx = size[next];
            son[now] = next;
        }
    }
}

void updata(int x,int k){
    int dx = deep[x];
    if( k == -1 ){
        dep[ dx ] = 0;
    }else{
        int tmp = dep[dx];
        if( tmp == 0 )tmp = 1e9;
        dep[dx] = min( tmp,diep[x] );
    }
}

void dfs2(int now,int last,bool keep){
    for(auto next : to[now]){
        if( next == son[now] or next == last )continue;
        dfs2( next,now,0 );
    }
    if( son[now] )dfs2( son[now],now,1 );
    for(auto next : to[now]){
        if( next == son[now] or next == last )continue;
        for( int i = 0;i < size[next];i ++ ){
            int nxt = nid[ id[next] + i ];
            int req = k + 2 * deep[now] - deep[nxt];
            if( dep[ req ] ){
                ans = min( ans,dep[ req ] + diep[nxt] - 2 * diep[now] );
            }
        }
        for( int i = 0;i < size[next];i ++){
            updata( nid[ id[next] + i ],1 );
        }
    }
    updata( now,1 );
    if( dep[ deep[now] + k ] )ans = min( ans,dep[ deep[now] + k ] - diep[now] );
    if( keep == 0 ){
        for( int i = 0;i < size[now];i ++ ){
            updata( nid[ id[now] + i ],-1 );
        }
    }
}

int main(){
    cin >> n >> k;
    for(int i = 1;i < n;i ++){
        int u,v,w;scanf( "%d%d%d",&u,&v,&w );
        to[u].push_back(v);
        to[v].push_back(u);
        len[u].push_back(w);
        len[v].push_back(w);
    }
    diep[0] = 1;
    dfs1(0,0);dfs2(0,0,0);
    if( ans == 1e9 )ans = -1;
    cout << ans;
    return 0;
}
```

---

## 作者：Orion545 (赞：17)

# 本题截止至2018年9月4日为止，都可以通过递归实现的点分治通过。

具体而言luogu+bzoj不用扩栈，COGS需要扩栈，否则RE一个点

在这里贴出本蒟蒻更新后的代码

### 另注：原文（即分割线下方的部分）中的代码里的扩栈代码有问题，详见下文

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,K,first[200010],cnte,siz[200010],son[200010],root,sum;
struct edge{
    int to,next,w;
}a[400010];
inline void add(int u,int v,int w){
    a[++cnte]=(edge){v,first[u],w};first[u]=cnte;
    a[++cnte]=(edge){u,first[v],w};first[v]=cnte;
}
bool vis[200010];
void getroot(int u,int f){//递归找重心
    int i,v;
    siz[u]=1;son[u]=0;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;if(v==f||vis[v]) continue;
        getroot(v,u);siz[u]+=siz[v];
        if(son[u]<siz[v]) son[u]=siz[v];
    }
    son[u]=max(son[u],sum-siz[u]);
    if(son[u]<son[root]) root=u;
}
int tmp[1000010],ans=1e9;
void getinfo(int u,int f,int dis,int cnt){//统计答案
    int i,v;
    if(dis>K) return;
    ans=min(ans,tmp[K-dis]+cnt);
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;if(v==f||vis[v]) continue;
        getinfo(v,u,dis+a[i].w,cnt+1);
    }
}
void update(int u,int f,int dis,int cnt){//加回来
    int i,v;
    if(dis>K) return;
    tmp[dis]=min(tmp[dis],cnt);
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;if(v==f||vis[v]) continue;
        update(v,u,dis+a[i].w,cnt+1);
    }
}
void clear(int u,int f,int dis){//清空
    int i,v;
    if(dis>=K) return;
    tmp[dis]=1e9;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;if(v==f||vis[v]) continue;
        clear(v,u,dis+a[i].w);
    }
}
void dfs(int u,int sz){//点分治主过程
    int i,v;tmp[0]=0;vis[u]=1;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;if(vis[v]) continue;
        getinfo(v,u,a[i].w,1);
        update(v,u,a[i].w,1);
    }
    clear(u,0,0);
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;if(vis[v]) continue;
        sum=((siz[v]>siz[u])?(sz-siz[u]):siz[v]);
        root=0;son[0]=sum;
        getroot(v,0);
        dfs(root,sum);
    }
}
int main(){
    memset(first,-1,sizeof(first));
    n=read();K=read();int i,t1,t2,t3;
    for(i=1;i<n;i++){
        t1=read();t2=read();t3=read();
        add(t1+1,t2+1,t3);
    }
    for(i=0;i<=K;i++) tmp[i]=1e9;
    sum=n;root=0;son[0]=n;
    getroot(1,0);
    dfs(root,n);
    if(ans!=1e9) printf("%d\n",ans);
    else puts("-1");
}
```

---

分割线以下为原文

---

### 日常卖安利

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8401118.html)

## 思路：

统计树上路径信息，点分治啊

K<=1e6，考虑对于距离为i的点建立tmp\[i\]，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边

点分治，每次先对每棵子树遍历，求出每个点i到root的距离dis\[i\]，以及走过的边数d\[i\]

那么ans=min(ans,tmp\[k-dis\[i\]\]+d\[i\])

遍历完这棵子树再修改被访问了的tmp\[dis\[i\]\]，然后下一棵

所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf）

然后才对每一个子树找重心、递归下一步操作

 

## 注意：

tmp要开到1000000，不要开成n的大小

每次进入dfs_solve时tmp\[0\]=0，因为这个当前的根到自己距离为0，走过了0条边

注意常数优化

#### 点是从零开始的

# Code:

### 注意这份代码里面的两个扩栈操作（#pragma以及汇编）目前在64位机器上面都是无效的。编译器（至少我本机的是这样）会忽略第一条#pragma，并且第二条汇编是32位汇编语言，64位机器无法识别，只能适用于COGS这样的32位老机器，暂时没有找到解决办法，如果有汇编大神知道如何在64位下面实现相同的功能，请在评论区指正，蟹蟹！

### 第一条扩栈pragma被我删掉了，大家不用再在意qwq

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#define inf 1e9
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,cnt,sum,root,first[200010],siz[200010],son[200010];
int d[200010],dis[200010],ans=inf,tmp[1000010];
bool vis[200010];
struct edge{
    int to,next,w;
}a[400010];
inline void add(int u,int v,int w){
    a[++cnt]=(edge){v,first[u],w};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],w};first[v]=cnt;
}
inline int _max(int l,int r){return (l>r)?l:r;}
inline int _min(int l,int r){return (l<r)?l:r;}
void getroot(int u,int f){
    int i,v;
    siz[u]=1;son[u]=0;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(v==f||vis[v]) continue;
        getroot(v,u);
        siz[u]+=siz[v];son[u]=_max(son[u],siz[v]);
    }
    son[u]=_max(son[u],sum-siz[u]);
    if(son[u]<son[root]) root=u;
}
void calc(int u,int f){
    int i,v;
    if(dis[u]<=m) ans=_min(ans,tmp[m-dis[u]]+d[u]);
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(v==f||vis[v]) continue;
        dis[v]=dis[u]+a[i].w;d[v]=d[u]+1;
        calc(v,u);
    }
}
void update(int u,int f,int t){
    int i,v;
    if(dis[u]<=m){
        if(t) tmp[dis[u]]=_min(tmp[dis[u]],d[u]);
        else tmp[dis[u]]=inf;
    }
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(v==f||vis[v]) continue;
        update(v,u,t);
    }
}
void dfs(int u){
    int i,v;vis[u]=1;tmp[0]=0;//注意这里！！！！！！！！！
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(vis[v]) continue;
        dis[v]=a[i].w;d[v]=1;
        calc(v,0);update(v,0,1);
    }
    for(i=first[u];~i;i=a[i].next) if(!vis[a[i].to]) update(a[i].to,0,0);
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(vis[v]) continue;
        sum=siz[v];root=0;
        getroot(v,0);
        dfs(root);
    }
}
int main(){

    int size = 128 << 20;
    char *p = (char*)malloc(size) + size;  
    __asm__("movl %0, %%esp\n" :: "r"(p));//有些OJ上不扩栈会RE
    //目前石锤这个在64为机器上编译不了，只能在COGS这种老OJ的32位机器上才可以

//  freopen("ioi2011-race.in","r",stdin);
//  freopen("ioi2011-race.out","w",stdout);

    memset(first,-1,sizeof(first));
    int i,t1,t2,t3;
    n=read();m=read();
    for(i=1;i<=m;i++) tmp[i]=inf;
    for(i=1;i<n;i++){
        t1=read();t2=read();t3=read();//点是从零开始的
        add(t1+1,t2+1,t3);
    }
    sum=n;root=0;son[0]=n;
    getroot(1,0);
    dfs(root);
    if(ans!=inf) printf("%d\n",ans);
    else printf("-1");
}
```

---

## 作者：NaCly_Fish (赞：14)

### 人生中做的第一道IOI题 (数字三角不算，太水了)  
这题算是一个比较裸的点分治，但是实际写起来还要想很多的。 

### 解法： 
如果你把[P3806](https://www.luogu.org/problemnew/show/P3806)的模板直接搬过来，这题会T飞到只有10分。  
那处理子树的地方肯定不能$\Theta(n^2)$来搞了，要考虑优化。 

我第一想法是这样的：  
开一个数组，叫$\text{cnt}$，其中$\text{cnt}[i]$表示满足题目条件的、含有$i$条边的路径数。  
然后处理子树信息时，将其中找到的路径都在数组中打标记，然后$\Theta(n)$就能处理这棵子树了。  
然后我写到一半发现不对。。这样没办法维护最少的边数。  

那我们考虑另外一种方法：  
仍然保留第一种方法的$\text{cnt}$数组，但是处理子树时，把找到的路径用结构体打包，存到另一个数组$\text{p}$中。  
我的结构体是这么写的：   
其中记录两个量，路径长度以及边数。
```cpp
struct path{
	int dis,dep;
	path(int dis=0,int dep=0):dis(dis),dep(dep){}
	bool operator < (const path& nd) const{
		if(dis==nd.dis) return dep < nd.dep;
		return dis < nd.dis;
	}
	bool operator == (const path& nd) const{
		return dis==nd.dis&&dep==nd.dep;
	}
};
```  
你也看见了，这里面重载了运算符，作用就是排序。  
我们把$\text{p}$以`路径长度`为第一关键字，`边数`为第二关键字排序。至于为什么要这样，下面再说。  
 
排好序后，我们就可以枚举每一条路径，设其长度为$d$。   
那现在只需找出长度为$k-d$的路径就好啦！  
由于$\text{p}$是有序的，所以就可以大力二分查找。   
找到之后，将这两条路径的`边数`加起来，在$\text{cnt}$数组中$+1$或$-1$即可 (分情况讨论，若是去重的时候就$-1$)

现在也就说明了以`路径长度`为第一关键字排序的原因：  
我们只要把长度相同的路径放到一起，找到一个，其它的也就都找到了。以此来保证处理子树时间复杂度是$\Theta(n\log n)$的。  

先别急着去写，现在这个方法还不完整。考虑这样一种情况：  
在菊花图中，找到的所有路径长度都一样，而且刚好是$k/2$时，按照我们刚搞出来的方法，这就被卡到$\Theta(n^2)$了。。

至此，又揭示了以`边数`为第二关键字排序的原因：  
题目既然要求找到长度为$k$的路径，边数尽量少。那我们对于每种长度的路径，都选`边数`最少的那一条去二分，不就行了？  
具体实现也不难，如果有$\text{p}[i]=\text{p}[i-1]$，那就不用管它了。因为$\text{p}[i-1]$这条路径已经处理过，且**一定**比$\text{p}[i]$更优。  

说了这么多，也该上代码了：  
注意代码中很多变量名与文中所说不同。  
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<bitset>
#include<map>
#define N 200002
#define M 1000002
#define inf 0x3f3f3f3f
#define ll long long
using namespace std;

struct edge{
    int v,w;
    edge(int v=0,int w=0):v(v),w(w){}
};

struct node{ //这里的node就是path
    int dis,dep;
    node(int dis=0,int dep=0):dis(dis),dep(dep){}
    bool operator < (const node& nd) const{
        if(dis==nd.dis) return dep < nd.dep;
        return dis < nd.dis;
    }
    bool operator == (const node& nd) const{
        return dis==nd.dis&&dep==nd.dep;
    }
};
 
vector<edge> adj[N];
int size[N],son[N],dis[N],dep[N],minw[M]; //minw就是cnt
node nd[N]; //nd就是p
bool vis[N];
int n,m,root,s,cnt,k,ans;

inline void read(int &x);
void find_root(int u,int fa);
void partition(int u);
void get_dist(int u,int fa,int len);
void solve(int u,int len,int w,int depth);
inline void find(int l,int r,node tg,int w);

int main(){
    ans = inf;
    int u,v,w;
    read(n),read(k);
    if(k==0){ //特判k为0,直接输出0
    	putchar('0');
    	return 0;
    }
    for(int i=1;i<n;++i){
        read(u),read(v),read(w);
        ++u,++v;
        adj[u].push_back(edge(v,w));
        adj[v].push_back(edge(u,w));
    }
    s = son[root] = n;
    find_root(1,0);
    partition(root);
    for(int i=1;i<=1000000;++i){ //遍历标记数组,找到边数最少的路径
    	if(minw[i]<1) continue;
    	printf("%d",i);
    	return 0;
    }
    printf("-1");
    return 0;
}

inline void find(int l,int r,node tg,int w){
	//二分查找用的函数
    int mid,dist,depth;
    dist = k-tg.dis;
    depth = tg.dep;
    while(r-l>2){
        mid = (l+r)>>1;
        if(nd[mid].dis>dist) r = mid;
        else l = mid;
    }
    for(int i=r;i>=l;--i){
        if(nd[i].dis!=dist) continue;
        mid = i;
        break;
    }
    if(nd[mid].dis!=dist) return; //找不到长度为k-d的边，返回
    for(int i=mid;;--i){
        if(nd[i].dis!=dist) break;
        if(nd[i]==tg) continue;
        minw[nd[i].dep+depth] += w;
    }
    for(int i=mid+1;;++i){
        if(nd[i].dis!=dist) break;
        if(nd[i]==tg) continue;
        minw[nd[i].dep+depth] += w;
    }
}

void solve(int u,int len,int w,int depth){
    dis[u] = len;
    dep[u] = depth;
    cnt = 0;
    get_dist(u,0,len);
    sort(nd+1,nd+1+cnt);
    nd[0].dis = -1; //避免出锅
    for(int i=1;i<=cnt;++i){
    	if(nd[i].dis>k) break;
    	if(nd[i].dis==nd[i-1].dis) continue; //很重要的一行剪枝
    	find(0,cnt,nd[i],w);
    }
}

//以下都是点分治板子

void get_dist(int u,int fa,int len){
    nd[++cnt] = node(dis[u],dep[u]);
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i].v;
        if(v==fa||vis[v]) continue;
        dis[v] = len+adj[u][i].w;
        dep[v] = dep[u]+1;
        get_dist(v,u,dis[v]);
    }
}


void partition(int u){
    vis[u] = 1;
    solve(u,0,1,0);
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i].v;
        if(vis[v]) continue;
        solve(v,adj[u][i].w,-1,1);
        root = 0;
        son[root] = n;
        s = size[v];
        find_root(v,u);
        partition(root);
    }
}

void find_root(int u,int fa){
    size[u] = 1;
    son[u] = 0;
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i].v;
        if(v==fa||vis[v]) continue;
        find_root(v,u);
        size[u] += size[v];
        son[u] = max(son[u],size[v]);
    }
    son[u] = max(son[u],s-size[u]);
    if(son[u]<son[root]) root = u;
}

//以上都是点分治板子

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}
```

---

## 作者：zhy12138 (赞：14)

毕竟是人生第一道IOI（~~现在已经挂了~~又A了~~），就认真写一写吧。

竟然有爆栈这种操作（~~亏我花了一个多小时优化时间以为RE是TLE~~）

题面一看就是淀粉质。（感觉好裸）

~~以下是同学的挂掉做法~~
```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T>
inline void read(T &a)
{
    T s = 0, w = 1;
    char c = getchar();
    while(c < '0' || c > '9')
    {
        if(c == '-') w = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        s = (s << 1) + (s << 3) + (c ^ 48);
        c = getchar();
    }
    a = s*w;
} 
struct edge{
    int from,to,cost,net;
    edge(int f = 0, int t = 0, int c = 0, int n = 0)
    {
        from = f;
        to = t;
        cost = c;
        net = n;
    }
}edges[101010];
int head[101010],tot,k,n;
void add(int x, int y, int c)
{
    edges[++tot] = edge(x,y,c,head[x]);
    head[x] = tot;
}
int root = 0;
int vis[101010],mx[10101],size[101010],S;
void find(int x, int fa)
{
    size[x] = 1;mx[x] = 0;
    for (int i = head[x];i;i = edges[i].net)
    {
        edge v = edges[i];
        if(vis[v.to] || v.to == fa) continue;
        find(v.to,x);
        size[x] += size[v.to];
        mx[x] = max(mx[x],size[v.to]);
    }
    mx[x] = max(mx[x],S-size[x]);
    if(mx[x] < mx[root])
    {
        root = x;
    }
}
int cnt,dis[10101],deep[101010];
int minn = 0x3f3f3f3f;
int ans = 0;
void get_dis(int x,int fa,int len,int k)
{
    dis[++cnt] = len;
    deep[cnt] = k;
    for (int i = head[x];i;i = edges[i].net)
    {
        edge v = edges[i];
        if(vis[v.to]||v.to == fa) continue;
        get_dis(v.to,x,len+v.cost,k+1);
    }
}
void solve(int x,int len, int pp)
{
    cnt = 0;
    get_dis(x,0,len,0);
    sort(dis+1,dis+1+cnt);
    int l = 1,r = cnt;
    while(l <= r)
    {
        if(dis[l] + dis[r] == k)
        {
            ans += pp;
            if(deep[l] + deep[r] < minn)
            {
                minn = deep[l] + deep[r];
            }
            break;
        }
        if(dis[l] + dis[r] < k) l++;
        if(dis[l] + dis[r] > k) r--;
        
    }
    /*for (int i = 1; i <= cnt; i++)
    {
        for (int j = 1; j <= cnt; j++)
        {
            if(dis[i] + dis[j] == k) ans += pp;
        }
    }*/
}
void Divide(int x)
{
    solve(x,0,1);
    vis[x] = 1;
    for (int i = head[x];i;i = edges[i].net)
    {
    	edge v = edges[i];
    	if(vis[v.to]) continue;
    	solve(v.to,v.cost,-1);
    	S = size[v.to]; root = 0;
    	find(v.to,x);
    //	printf("%d\n",root);
    	Divide(root);
    }
}
int main()
{
    read(n); read(k);
    for (int i = 1; i < n; i++)
    {
    	int x,y,z;
    	read(x); read(y); read(z);
    	x++;y++;
    	add(x,y,z);
    	add(y,x,z);
    }
    root = 0;
    mx[root] = n+1;
    S = n;
    find(1,0);
    //printf("%d\n",root);
    Divide(root);
    printf("%d\n",ans == 0? -1 : minn);
    return 0;
}
```
该算法挂掉的主要原因在于使用计数器记录最小值时，一个元素无法处理错误路径这种骚操作。

于是蒟蒻的我想到了开一个大数组来计数（~~这TM不就是桶排吗~~）

于是我就自信地打上了如下代码
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<ctime>
#define ll long long
using namespace std;
inline ll read()
{
    ll kkk=0;
    int x=1;
    char c=getchar();
    while(c<'0' || c>'9')
    {
        if(c=='-')
            x=-1;
        c=getchar();
    }
    while(c>='0' && c<='9')
        kkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();
    return kkk*x;
}
struct sb
{
    int to,l,nextn;
}a[200001];
int n,k,num,maxn,root,z,tot,head[200001],size[200001],maxsize[200001],ans[200001],dis[200001][2];
char pd[200001];
inline int ADD(int from,int to,int l)
{
    ++tot;
    a[tot].to=to,a[tot].l=l,a[tot].nextn=head[from],head[from]=tot;
}
inline int find(int u,int fa)
{
    size[u]=1,maxsize[u]=0;
    for(register int i=head[u];i!=0;i=a[i].nextn)
    {
        int v=a[i].to;
        if(v==fa || pd[v]==1)
            continue;
        find(v,u);
        size[u]+=size[v],maxsize[u]=max(maxsize[u],size[v]);
    }
    maxsize[u]=max(maxsize[u],z-size[u]);
    if(maxsize[u]<maxn)
        root=u,maxn=maxsize[u];
}
inline int run(int u,int fa,int l,int deep)
{
    dis[++num][0]=l,dis[num][1]=deep;
    for(register int i=head[u];i!=0;i=a[i].nextn)
    {
        int v=a[i].to;
        if(v==fa || pd[v]==1)
            continue;
        run(v,u,l+a[i].l,deep+1);
    }
}
inline int fun(int Root)
{
    pd[Root]=1;
    num=0;
    run(Root,-1,0,0);
    for(register int i=1;i<=num;++i)
        for(register int j=i;j<=num;++j)
            if(dis[i][0]+dis[j][0]==k)
                ++ans[dis[i][1]+dis[j][1]];
    for(register int i=head[Root];i!=0;i=a[i].nextn)
    {
        int v=a[i].to;
        if(pd[v]==1)
            continue;
        num=0;
        run(v,Root,a[i].l,1);
        for(register int j=1;j<=num;++j)
            for(register int w=j;w<=num;++w)
                if(dis[j][0]+dis[w][0]==k)
                    --ans[dis[j][1]+dis[w][1]];
        maxn=0x7f7f7f7f,root=-1,z=size[v];
        find(v,Root);
        fun(root);
    }
}
int main()
{
    n=read(),k=read();
    for(register int i=1;i<n;++i)
    {
        int u=read(),v=read(),k=read();
        ADD(u,v,k),ADD(v,u,k);
    }
    maxn=0x7f7f7f7f,root=-1,z=n;
    find(0,-1);
    fun(root);
    for(register int i=0;i<=n;++i)
        if(ans[i]!=0)
        {
            printf("%d\n",i);
            return 0;
        }
    putchar('-');
    putchar('1');
    putchar('\n');
    return 0;
}
```
~~和之前那份代码明显码风不同吧~~

结果我尴尬地只拿了10分，蒟蒻的我开始沉思————这么高级的方法怎么会挂呢？？？（~~WTF，除了点分治高级外就全是枚举好吧~~）

其实我只是想检查算法正确性玩玩而已（~~啊啊，别打~~）

以上代码挂掉的主要原因是计数那一段太慢了，没错就是下面这一段
```cpp
    num=0;
    run(Root,-1,0,0);
    for(register int i=1;i<=num;++i)
        for(register int j=i;j<=num;++j)
            if(dis[i][0]+dis[j][0]==k)
                ++ans[dis[i][1]+dis[j][1]];
```

于是我排了个序，用用两个指针找了下合法方案，并用last记录没次二号指针的最大位置+1就过了

PS：注意路径长度之和完全可以相等，所以找到合法方案后要向下循环求解~~应该会被卡成跟之前那段一样的时间~~（离散化可以优化）
```cpp
    num=0;
    run(Root,-1,0,0);
    sort(dis+1,dis+num+1,cmp);  //为了排序，我把之前的dis[][0]和dis[][1]放在了struct里面
    int last=1;
    for(;last<=num & dis[1].l+dis[last].l<=k;++last);   //这里有个分号！！！
    for(register int i=1;i<=num & dis[i].l*2<k;++i)
    {
        int j=last-1;
        while(j>=i)
        {
            int P=dis[i].l+dis[j].l;
            if(P<=k)
            {
                last=j+1;
                if(P==k)
                {
                    ++ans[dis[i].deep+dis[j].deep];
                    while(dis[j-1].l==dis[j].l & j>i)
                        --j,++ans[dis[i].deep+dis[j].deep];
                }
                break;
            }
            --j;
        }
    }
```

不过我觉得last的初始化太暴力，就用二分查找小优化了以下，那都是后话了

好吧接下来是AC代码（~~至少以前是的~~现在也是）
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<ctime>
#define ll long long
using namespace std;
inline int read()
{
    int kkk=0;
    int x=1;
    char c=getchar();
    while(c<'0' || c>'9')
    {
        if(c=='-')
            x=-1;
        c=getchar();
    }
    while(c>='0' && c<='9')
        kkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();
    return kkk*x;
}
struct sb
{
    int to,l,nextn;
}a[400001];
int n,k,num,maxn,root,z,tot,head[400001],size[400001],maxsize[400001],ans[400001];
struct tmd
{
    int l,deep;
}dis[400001];
char pd[400001];
inline int cmp(tmd x,tmd y)
{
    return x.l<y.l;
}
inline int ADD(int from,int to,int l)
{
    ++tot;
    a[tot].to=to,a[tot].l=l,a[tot].nextn=head[from],head[from]=tot;
}
inline int find(int u,int fa)
{
    size[u]=1,maxsize[u]=0;
    for(register int i=head[u];i;i=a[i].nextn)
    {
        int v=a[i].to;
        if(v==fa | pd[v])
            continue;
        find(v,u);
        size[u]+=size[v],maxsize[u]=(maxsize[u]>size[v]?maxsize[u]:size[v]);
    }
    maxsize[u]=(maxsize[u]>z-size[u]?maxsize[u]:z-size[u]);
    if(maxsize[u]<maxn)
        root=u,maxn=maxsize[u];
}
inline int run(int u,int fa,int l,int deep)
{
    dis[++num].l=l,dis[num].deep=deep;
    for(register int i=head[u];i;i=a[i].nextn)
    {
        int v=a[i].to;
        if(v==fa | pd[v])
            continue;
        run(v,u,l+a[i].l,deep+1);
    }
}
inline int fun(int Root)
{
    pd[Root]=1,num=0,run(Root,-1,0,0),sort(dis+1,dis+num+1,cmp);
    int last,l=1,r=num;
    while(l<r)
    {
        int mid=(l+r)/2;
        if(dis[1].l+dis[mid].l<=k)
            l=mid+1;
        else
            r=mid;
    }
    last=l;
    if(last==num & dis[1].l+dis[last].l<=k)
        ++last;
    for(register int i=1;i<=num & dis[i].l*2<k;++i)
    {
        int j=last-1;
        while(j>=i)
        {
            int P=dis[i].l+dis[j].l;
            if(P<=k) 
            {
                last=j+1;
                if(P==k)
                {
                    ++ans[dis[i].deep+dis[j].deep];
                    while(dis[j-1].l==dis[j].l & j>i)
                        --j,++ans[dis[i].deep+dis[j].deep];
                }
                break;
            }
            --j;
        }
    }
    for(register int i=head[Root];i;i=a[i].nextn)
    {
        int v=a[i].to;
        if(pd[v])
            continue;
        num=0,run(v,Root,a[i].l,1),sort(dis+1,dis+num+1,cmp);
        l=1,r=num;
        while(l<r)
        {
            int mid=(l+r)/2;
            if(dis[1].l+dis[mid].l<=k)
                l=mid+1;
            else
                r=mid;
        }
        last=l;
        if(last==num & dis[1].l+dis[last].l<=k)
            ++last;
        for(register int j=1;j<=num & dis[j].l*2<k;++j)
        {
            int w=last-1;
            while(w>=j)
            {
                int P=dis[j].l+dis[w].l;
                if(P<=k)
                {
                    last=w+1;
                    if(P==k)
                    {
                        --ans[dis[j].deep+dis[w].deep];
                        while(dis[w-1].l==dis[w].l & w>j)
                            --w,--ans[dis[j].deep+dis[w].deep];
                    }
                    break;
                }
                --w;
            }
        }
        maxn=0x7f7f7f7f,root=-1,z=size[v],find(v,Root),fun(root);
    }
}
int main()
{
    n=read(),k=read();
    for(register int i=1;i<n;++i)
    {
        int u=read(),v=read(),k=read();
        ADD(u,v,k),ADD(v,u,k);
    }
    maxn=0x7f7f7f7f,root=-1,z=n;
    find(0,-1),fun(root);
    for(register int i=0;i<=n;++i)
        if(ans[i])
        {
            printf("%d\n",i);
            return 0;
        }
    putchar('-');
    putchar('1');
    putchar('\n');
    return 0;
}
```

-----------
后记：

洛谷评测姬更新以后空间好像变少了，所以我的栈空间被卡爆了，大数据连找重心都跑不过。所以还需要打手动~~膜~~模拟栈来优化，但太麻烦了。（2018.8）

我今天好像发现把能换int类型的函数换成void就能过了。（2018.10.30）

---

## 作者：wuzhaoxin (赞：6)

# 点分治裸题？
把每个节点的信息（到选定的根的距离和深度）放在pair中，丢到set里，每次直接lower_bound查找即可（注意每次要先把(0,0)加入）

~~跑得超级慢，或许手写平衡树会快许多，开O2快四倍~~

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gi() {
	register int x,op=1,c;
	while(c=getchar(),c<'0'||c>'9')if(c=='-')op=-op;
	x=c^48;
	while(c=getchar(),c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48);
	return x*op;
}
int head[200001],nxt[400001],ver[400001],val[400001],tot=0;
void add(int x,int y,int v) {
	ver[++tot]=y,val[tot]=v,nxt[tot]=head[x],head[x]=tot;
	ver[++tot]=x,val[tot]=v,nxt[tot]=head[y],head[y]=tot;
}
int n,k;
bool v[200001]={0};
int root;
int sz[200001],mx[200001];
int S;
void getroot(int x,int f) {
	sz[x]=1,mx[x]=0;
	for(int i=head[x];i;i=nxt[i])
		if(ver[i]!=f&&!v[ver[i]]) {
			getroot(ver[i],x);
			sz[x]+=sz[ver[i]];
			mx[x]=max(mx[x],sz[ver[i]]);
		}
	mx[x]=max(mx[x],S-sz[x]);
	if(mx[x]<mx[root])root=x;
}
int ans=1e9;
int cnt;
pair<int,int>a[200001];
void dfs(int x,int f,int vl,int dp) {
	if(dp>ans||vl>k)return;//剪枝
	a[++cnt]=make_pair(vl,dp);
	for(int i=head[x];i;i=nxt[i])
		if(ver[i]!=f&&!v[ver[i]])
			dfs(ver[i],x,vl+val[i],dp+1);
}
void solve(int x,int s) {
	S=s;
	root=0;
	getroot(x,x);
	v[root]=1;
	set<pair<int,int> >st;
	st.insert(make_pair(0,0));
	for(int i=head[root];i;i=nxt[i])
		if(!v[ver[i]]) {
			cnt=0;
			dfs(ver[i],root,val[i],1);
			set<pair<int,int> >::iterator it;
			for(int i=1;i<=cnt;i++) {
				it=st.lower_bound(make_pair(k-a[i].first,0));
				if(it!=st.end()&&it->first+a[i].first==k)ans=min(ans,it->second+a[i].second);
			}
			for(int i=1;i<=cnt;i++)st.insert(a[i]);
		}
	st.clear();
	for(int i=head[root];i;i=nxt[i])
		if(!v[ver[i]])solve(ver[i],sz[ver[i]]);
}
int main() {
	mx[0]=1e9;
	n=gi(),k=gi();
	for(int i=1,x,y;i<n;i++)
		x=gi()+1,y=gi()+1,add(x,y,gi());
	solve(1,n);
	if(ans==1e9)puts("-1");
	else printf("%d\n",ans);
	return 0;
}
```

---

## 作者：lemir3 (赞：4)

## 题目分析

每次找出一个重心,把树上的路径分为两类,一类是经过这个重心的,一类是不经过这个重心的,我们只考虑经过这个重心的路径,分治的思想就很明显了.

考虑每个重心的更新方式,我们记录一个che[i],表示一条权值和为i的路径的最小长度,记录路径的权值和rem[i],长度di[i],每次尝试用k-rem[i]来匹配,再用di[i]来更新che[i]即可.

代码很好懂.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cmath"
#include "cstdlib"
#include "cctype"
#include "algorithm"
#include "set"
#include "queue"
#include "map"
#include "stack"
#include "vector"
#define lxl long long
#define R register
#define INF 9223372036854775807
#define debug(x) printf("debug:%lld\n",x)
const lxl maxn=200010,maxk=1000010;
lxl n,k,EdgeSize,rt,sum,ans=INF;
lxl maxp[maxn],size[maxn],head[maxn],dis[maxn],val[maxn],che[maxk],rem[maxn],di[maxn],q[maxn];
bool vis[maxn];
struct _Edge
{
	lxl to,next,val;
}e[maxn<<1];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
inline void EdgeAdd(lxl from,lxl to,lxl val)
{
	e[EdgeSize].to=to;
	e[EdgeSize].next=head[from];
	e[EdgeSize].val=val;
	head[from]=EdgeSize++;
}
void GetRoot(lxl now,lxl from)
{
	size[now]=1,maxp[now]=0;
	for(R int i(head[now]);~i;i=e[i].next)
	{
		if(e[i].to==from||vis[e[i].to])continue;
		GetRoot(e[i].to,now);
		size[now]+=size[e[i].to];
		maxp[now]=std::max(maxp[now],size[e[i].to]);
	}
	maxp[now]=std::max(maxp[now],sum-size[now]);
	if(maxp[now]<maxp[rt])rt=now;
}
void GetDis(lxl now,lxl from)
{
	rem[++rem[0]]=val[now],di[rem[0]]=dis[now];
	for(R int i(head[now]);~i;i=e[i].next)
	{
		if(from==e[i].to||vis[e[i].to])continue;
		dis[e[i].to]=dis[now]+1,val[e[i].to]=val[now]+e[i].val;
		GetDis(e[i].to,now);
	}
}
void calc(lxl now)
{
	q[0]=0;
	for(R int i(head[now]);~i;i=e[i].next)
	{
		if(vis[e[i].to])continue;
		val[e[i].to]=e[i].val,dis[e[i].to]=1,rem[0]=0,di[0]=0;
		GetDis(e[i].to,now);
		for(R int i(1);i<=rem[0];++i)
		{
			if(k-rem[i]<0)continue;
			if(che[k-rem[i]]<INF)ans=std::min(ans,di[i]+che[k-rem[i]]);
		}
		for(R int i(1);i<=rem[0];++i)if(rem[i]<=k)che[rem[i]]=std::min(che[rem[i]],di[i]),q[++q[0]]=rem[i];
	}
	for(R int i(1);i<=q[0];++i)che[q[i]]=INF;
}
void slove(lxl now)
{
	vis[now]=true,che[0]=0;
	calc(now);
	for(R int i(head[now]);~i;i=e[i].next)
	{
		if(vis[e[i].to])continue;
		maxp[rt=0]=INF,sum=size[e[i].to];
		GetRoot(e[i].to,0),slove(rt);
	}
}
int main(void)
{
//	freopen("P4149_7.in","r",stdin);
	memset(head,-1,sizeof(head));
	n=read(),k=read();
	for(R int i(1);i<=k;++i)che[i]=INF;
	for(R int i(1),u,v,val;i<n;++i)
	{
		u=read()+1,v=read()+1,val=read();
		EdgeAdd(u,v,val),EdgeAdd(v,u,val);
	}
	maxp[rt]=sum=n;
	GetRoot(1,0);
	slove(rt);
	if(ans<=n)printf("%lld\n",ans);
	else printf("-1\n");
	return 0;
}
```

---

## 作者：妩媚的ak萝莉 (赞：3)

[Luogu4149](https://www.luogu.org/problem/P4149)

拜托，这题我是当点分治模版打，结果太着急挂了个底朝天，真是*******

## 题解：

我把本题分两个部分，一个是点分治模版，一个是本题中的处理。

### 点分治

[点分治的介绍](https://www.cnblogs.com/bztMinamoto/p/9489473.html)（大佬写的太好啦，我只补充一点实现的细节，Orz）

点分治本质上不是数据结构而是一种思想，我们可以很灵活地运用它，但一定要自己推一遍复杂度。

比如在此题中，一开始我考虑这样点分，即用重心子树和重心自己划分树（结果是重心被重复包含，但不影响答案），但在我实现过程中发现要想把树有效划分开，必须暂时删除要删除的边，等处理完这棵子树再恢复，这样的话要想保证时间复杂度必须用删除标记，造成遍历划分后的子树时必须访问所有的边而不是此时树中还没有被删除的边，如果我用包含重心的划分，可以看出复杂度发生严重退化，肯定不可取。

还有就是对删除标记的处理，如果简单地用bool数组的话，可以想见出现的问题：上一段已经说过，遍历划分后的子树时一定会访问到已经删除的边，如果划分到最后只剩两个点的树时，原来重心的儿子就可能被选为新的重心，这样当你删除又恢复当前重心与儿子的连边后，就无意间恢复了不应该恢复的原来重心和现在重心的连边，造成错误。我解决的方法是把删除标记数组开成int，删边把数组++，恢复把数组--。（删除恢复时别忘了一块处理它的反向边）

### 本题：

由于本题中是取最小，可以允许重复统计，我于是潜意识地用这种想法，把所有到重心的距离装进桶里，再枚举每一子树，用某种方法在同种把此子树的数据删去，可以这么说——就是把每个子树和不等于它的子树的数据比较，最后发现舍近求远兜了一圈。

其实，只要把每个子树和小于它的子树的数据比较就行了，这样先比较再更新数据即可，不需要删去什么。

还是那句话：换个角度

## 代码：
```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <vector>
using namespace std;
typedef pair<int,int> pii;
const int N=2e5+50;
const int K=1e6+50;
int n,k,cnt,ans=N;
int pre[2*N],head[N],to[2*N],len[2*N],shan[2*N],gsz[N],Hav[K];
vector<pii > hav[N];

void addedge(int ui,int vi,int wi){
	cnt++;
	pre[cnt]=head[ui];
	head[ui]=cnt;
	to[cnt]=vi;
	len[cnt]=wi;
}

void dfs_gsz(int now,int fa){
	gsz[now]=1;
	for(int i=head[now];i;i=pre[i])
	{
		if(shan[i] || to[i]==fa) continue;
		dfs_gsz(to[i],now);
		gsz[now]+=gsz[to[i]];
	}
}

void Find(int now,int fa,int& maxp,int& Maxv,int Ato){
	int maxv=Ato-gsz[now]+1;
	for(int i=head[now];i;i=pre[i]){
		if(shan[i] || to[i]==fa) continue;
		Find(to[i],now,maxp,Maxv,Ato);
		maxv=max(maxv,gsz[to[i]]+1);
	}
	if(maxv!=1 && maxv<Maxv) maxp=now,Maxv=maxv;
}

int findg(int now){
	int maxp=-1,maxv=N;
	dfs_gsz(now,-1);
	Find(now,-1,maxp,maxv,gsz[now]);
	return maxp;
}

void dfs_hav(int now,int fa,int dep,int root,int Add)
{
	for(int i=head[now];i;i=pre[i])
	{
		if(shan[i] || to[i]==fa) continue;
		if(Add+len[i]<=k) 
		{
			hav[root].push_back(make_pair(Add+len[i],dep+1));
			dfs_hav(to[i],now,dep+1,root,Add+len[i]);
		}
	}
}

inline int Min(int a,int b){
	if(!a) return b;
	return min(a,b);
}

void solve(int now)
{
	int G=findg(now);
	if(G==-1) return;
	for(int i=head[G];i;i=pre[i]) shan[(i&1)?(i+1):(i-1)]++,shan[i]++;
	for(int i=head[G];i;i=pre[i]) if(shan[i]==1) solve(to[i]);
/**/
	for(int i=head[G];i;i=pre[i])
		if(shan[i]==1){
			if(len[i]<=k)
			{
            	hav[to[i]].push_back(make_pair(len[i],1));
				dfs_hav(to[i],-1,1,to[i],len[i]);
			}
			for(int gg=0;gg<hav[to[i]].size();gg++)
				if(Hav[k-hav[to[i]][gg].first])
					ans=min(ans,Hav[k-hav[to[i]][gg].first]+hav[to[i]][gg].second);
			for(int gg=0;gg<hav[to[i]].size();gg++)
				Hav[hav[to[i]][gg].first]=Min(Hav[hav[to[i]][gg].first],hav[to[i]][gg].second);
		}
	if(Hav[k]) ans=min(ans,Hav[k]);
	for(int i=head[G];i;i=pre[i])
		if(shan[i]==1){
			for(int gg=0;gg<hav[to[i]].size();gg++)
				Hav[hav[to[i]][gg].first]=0;
			hav[to[i]].clear();
		}
/**/
	for(int i=head[G];i;i=pre[i]) shan[(i&1)?(i+1):(i-1)]--,shan[i]--;
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;i++)
	{
		int ui,vi,wi;	
		scanf("%d%d%d",&ui,&vi,&wi);
		ui++,vi++;
		addedge(ui,vi,wi);
		addedge(vi,ui,wi);
	}
	solve(1);
	if(ans==N) printf("-1\n");
	else printf("%d\n",ans);
	return 0;
}
```




---

## 作者：DQYdqy (赞：2)

给博客打一下广告：[QAQ](https://www.cnblogs.com/NLDQY/p/10824460.html)

## Solution:

点分治，算出点对之间的距离，记录所属子树和与跟之间的边数。

对于每个点，记录排序过后位置离自己最近的不同子树的点，记做go[x]

每次二分去更新，若遇到同一子树的点，则尝试用go[x]去更新

排序以距离为第一关键字，边数为第二关键字(这样二分出来的点一定是满足条件的最优的点)

详见代码(注意编号从0开始)

## Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 2147483647
using namespace std;
const int N=2e5+1;
int n,k,rt,szt,cnt,tot,head[N];
int ans,sz[N],mx[N],vis[N],go[N];
struct Edge{int nxt,to,val;}edge[N<<1];
struct Pos{int dis,be,u;}p[N];
inline bool cmp(Pos a,Pos b){return a.dis==b.dis?a.u<b.u:a.dis<b.dis;}
void ins(int x,int y,int z){
	edge[++cnt].nxt=head[x];
	edge[cnt].to=y;edge[cnt].val=z;
	head[x]=cnt;
}
void getrt(int x,int fa){
	mx[x]=0;sz[x]=1;
	for(int i=head[x];~i;i=edge[i].nxt){
		int y=edge[i].to;
		if(vis[y]||y==fa) continue;
		getrt(y,x);sz[x]+=sz[y];
		mx[x]=max(mx[x],sz[y]);
	}mx[x]=max(mx[x],szt-sz[x]);
	if(mx[x]<mx[rt]) rt=x;
}
void getdis(int x,int fa,int d,int s,int num){
	p[++tot].dis=d;
	p[tot].be=s;
	p[tot].u=num;
	for(int i=head[x];~i;i=edge[i].nxt){
		int y=edge[i].to;
		if(vis[y]||y==fa) continue;
		getdis(y,x,d+edge[i].val,s,num+1);
	}
}
int find(int x,int l,int r){
	while(l<r){
		int mid=(l+r)>>1;
		if(x+p[mid].dis<k) l=mid+1;
		else r=mid;
	}return l;
}
void divide(int x){
	vis[x]=1;tot=0;
	for(int i=head[x];~i;i=edge[i].nxt){
		int y=edge[i].to;
		if(vis[y]) continue;
		getdis(y,x,edge[i].val,y,1);
	}
	sort(p+1,p+tot+1,cmp);
	for(int i=1;i<=tot;i++)
		if(p[i].dis==k) ans=min(ans,p[i].u);
	for(int i=tot;i>=1;i--){
		if(p[i].be!=p[i+1].be) go[i]=i+1;
		else go[i]=go[i+1];
	}p[tot+1].dis=0;
	for(int i=1;i<=tot;i++){
		int x=find(p[i].dis,i+1,tot);
		if(p[i].dis+p[x].dis==k){
			if(p[i].be!=p[x].be) ans=min(ans,p[i].u+p[x].u);
			else if(p[i].dis+p[go[x]].dis==k) ans=min(ans,p[i].u+p[go[x]].u);
		}
	}
	for(int i=head[x];~i;i=edge[i].nxt){
		int y=edge[i].to;
		if(vis[y]) continue;
		rt=2e5;szt=sz[y];getrt(y,x);
		divide(rt);
	}
}
int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int main(){
	n=read(),k=read();
	memset(head,-1,sizeof(head));
	for(int i=1;i<n;i++){
		int x=read(),y=read(),z=read();
		ins(x,y,z);ins(y,x,z);
	}rt=2e5;
	szt=n;mx[rt]=inf;getrt(0,-1);
	ans=inf;divide(rt);printf("%d\n",ans==inf?-1:ans);
	return 0;
}
```

---

## 作者：Zechariah (赞：2)

这题其实跟[P3806【模板】点分治1](https://www.luogu.org/problemnew/show/P3806)
是一样的题，只不过统计答案的时候我们的询问只有一个$k$，而且要开一个桶$minn$记录从当前点出发距离为$x$的最少边数是$minn_x$，全局答案统计最小即可
```cpp
#include <bits/stdc++.h>
#define rg register
#define inl inline
typedef int ll;
const int N = 2e5 + 5;
using namespace std;
namespace fast_IO {
    inl ll read() {
        rg char c;
        rg ll x = 0;
        rg bool flag = false;
        while ((c = getchar()) == ' ' || c == '\n' || c == '\r');
        if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48;
        while ((c = getchar()) != ' ' && c != '\n' && c != '\r'&&~c)
            x = (x << 1) + (x << 3) + (c ^ 48);
        if (flag)return -x; return x;
    }
    inl ll max(rg ll a, rg ll b) { if (a > b)return a; return b; }
    inl ll min(rg ll a, rg ll b) { if (a < b)return a; return b; }
    void write(rg long long x) { if (x < 0)putchar('-'), x = -x; if (x >= 10)write(x / 10); putchar(x % 10 ^ 48); }
};
int minn[N * 5], ssize[N], rt, num, p[N], b[N << 1], nt[N << 1], dist[N], dis[N], w[N << 1], maxt[N], st[N * 5], sum, ans = 0x3f3f3f3f, K, edge[N];
bool vis[N];
inl void add(rg int z, rg int y, rg int x)
{
    ++x, ++y;
    b[++num] = y, w[num] = z;
    nt[num] = p[x], p[x] = num;
    b[++num] = x, w[num] = z;
    nt[num] = p[y], p[y] = num;
}
void getrt(rg int x, rg int fa)
{
    ssize[x] = 1; maxt[x] = 0;
    for (rg int e = p[x]; e; e = nt[e])
    {
        if (b[e] == fa || vis[b[e]])continue;
        getrt(b[e], x); ssize[x] += ssize[b[e]];
        maxt[x] = fast_IO::max(maxt[x], ssize[b[e]]);
    }
    maxt[x] = fast_IO::max(maxt[x], sum - ssize[x]);
    if (maxt[x] < maxt[rt])rt = x;
}
void getdist(rg int x, rg int tiao, rg int fa)
{
    if (dis[x] > K || tiao > ans)return;
    dist[++*dist] = dis[x], edge[*dist] = tiao;
    for (rg int e = p[x]; e; e = nt[e])
    {
        if (b[e] == fa || vis[b[e]])continue;
        dis[b[e]] = dis[x] + w[e];
        getdist(b[e], tiao + 1, x);
    }
}
inl void getchild(rg int x)
{
    for (rg int e = p[x]; e; e = nt[e])
    {
        rg int kk = b[e];
        if (vis[kk])continue;
        *dist = 0; dis[kk] = w[e];
        getdist(kk, 1, x);
        for (rg int j = 1; j <= *dist; ++j)
            ans = fast_IO::min(ans, edge[j] + minn[K - dist[j]]);
        for (rg int i = 1; i <= *dist; ++i)
            minn[st[++*st] = dist[i]] = fast_IO::min(minn[dist[i]], edge[i]);
    }
    while (*st)minn[st[*st]] = 0x3f3f3f3f, --*st;
}
void solve(rg int x)
{
    vis[x] = true; minn[0] = 0; getchild(x);
    for (rg int e = p[x]; e; e = nt[e])
    {
        rg int kk = b[e];
        if (vis[kk])continue;
        rt = 0; sum = ssize[kk];
        getrt(kk, x); solve(rt);
    }
}

int main(void)
{
    rg int n = fast_IO::read(); K = fast_IO::read();
    for (rg int i = 1; i != n; ++i)
    {
        rg int x = fast_IO::read(), y = fast_IO::read(), z = fast_IO::read();
        add(z, y, x);
    }
    memset(minn, 0x3f, sizeof(minn));
    sum = maxt[rt] = n;
    getrt(1, 0); solve(rt);
    if (ans >= n)puts("-1"); else fast_IO::write(ans);
    return 0;
}

```


---

## 作者：zsaskk (赞：1)

刚学完点分治，简单交流一下心得。

点分治往往枚举要进行计算的点，对它进行$divide$（$caculate$），并注意考虑不合法的情况，即在同一个子树内，路径不经过枚举的点，这样显然是不合法的，应当避免将这种情况计算入答案内。

~~虽然这么说，但还是$WA$在了上面，还发了求助帖，然后被人打回去对拍......~~

其实感觉点分治的$caculate$原理类似$dp$，但是比$dp$的思维难度更小，~~当然复杂度也更劣~~

还有一点，点分治要不断寻找重心，避免复杂度退化。

以上大概就是~~点分治入门四部曲~~的主要情节了吧。

------------

简单地讲一下这道题。

同样地，我们找到树的重心，对它进行$divide$（$caculate$）。$dfs$，整颗子树，求出子树节点到该点的$dis$，把$dis$入桶。

统计答案时，就查找是否有$K-dis$的路径，并更新答案。

似乎普遍的做法是$divide$之后统一把桶清空，但实际上我们可以采用类似$lazytag$的方法，需要使用时再清空。

另外，如果当前点的$dis>K$，就没有必要继续递归下去，可以直接$return$。

代码实现：



------------
```
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define chk_digit(c) (c>='0'&&c<='9')
inline int read() {
    reg int x=0,f=1;reg char c=getchar();
    while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
    while(chk_digit(c)) x=x*10+c-'0',c=getchar();
    return x*f;
}
#define maxsize 1000010
#define mymax(x,y) (x>=y?x:y)
#define mymin(x,y) (x>=y?y:x)
int n,k,dis[maxsize],ans=maxsize,h[maxsize],cnt,maxs[maxsize],f[maxsize],tot,root,num,alr[maxsize*3],vis[maxsize],d[maxsize*3],dfn;
struct node{ int y,next,val; }edg[maxsize<<1];
inline void add(int x,int y,int val) { edg[++cnt].next=h[x],edg[cnt].y=y,edg[cnt].val=val,h[x]=cnt; }
inline void find_root(int x,int fa) {
    f[x]=1,maxs[x]=0;
    for(reg int i=h[x];i;i=edg[i].next) {
        int y=edg[i].y;if(y==fa||vis[y]) continue;
        find_root(y,x),f[x]+=f[y],maxs[x]=mymax(maxs[x],f[y]);
    }
    maxs[x]=mymax(maxs[x],tot-f[x]);
    if(maxs[x]<maxs[root]) root=x; 
} 
inline void dfs(int x,int fa,int dep) {
    if(dis[x]==k) ans=mymin(ans,dep);
    if(dis[x]>=k) return;
    if(alr[dis[x]]!=dfn) d[dis[x]]=maxsize;//重置桶 
    if(dis[x]<k) { if(alr[k-dis[x]]==dfn) ans=mymin(ans,d[k-dis[x]]+dep); }
    for(reg int i=h[x];i;i=edg[i].next) {
        int y=edg[i].y;if(y==fa||vis[y]) continue;
        dis[y]=dis[x]+edg[i].val,dfs(y,x,dep+1);
    }
}
inline void takedown(int x,int fa,int dep) {//更新桶 
	if(dis[x]>=k) return;
	alr[dis[x]]=dfn,d[dis[x]]=mymin(d[dis[x]],dep);
	for(reg int i=h[x];i;i=edg[i].next) {
		int y=edg[i].y;if(y==fa||vis[y]) continue;
		takedown(y,x,dep+1);
	}
}
inline void divide(int x) {
    vis[x]=1,dis[x]=0,++dfn;
    for(reg int i=h[x];i;i=edg[i].next) {
        int y=edg[i].y;if(vis[y]) continue;
        dis[y]=edg[i].val,dfs(y,x,1),takedown(y,x,1);//先统计答案再记录 
    }
    for(reg int i=h[x];i;i=edg[i].next) {
        int y=edg[i].y;if(vis[y]) continue;
        tot=f[y]/*每次找重心的tot都应该更新*/,root=0,find_root(y,x),divide(root);
    }
}
int main() {
    n=read(),k=read();
    for(reg int i=1;i<n;++i) {
        int x=read()+1,y=read()+1,val=read();
        add(x,y,val),add(y,x,val);
    } 
    tot=n,maxs[root=0]=maxsize<<1/*一定要记得初始化，不然会很难发现错误之处*/,find_root(1,0),divide(root);
    if(ans>n) printf("-1\n");
    else printf("%d\n",ans);
}
```


---

## 作者：Genius_Z (赞：1)

这题细节巨多（不过也可能是因为我菜），贡献了半页的提交记录$emmm$。

点分治最容易出锅的地方就在于信息应该在统计完该子树之后再加入。

信息在到下一层分治时一定要清干净。

这题的思路基本和模板一样，把一条路径拆成两段，开一个桶记录$dis$值，唯一多了的就是要记录最少的边数（更新的时候千万别用该数组更新，否则会出现各种比标准输出小的情况。这个数组只是用来统计答案的）。

然后就是~~常数巨大的~~代码了

Code：

```cpp
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <tuple>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
struct edge {
	int next, to, w;
}e[5000001];
int focus, min_siz, ncnt, k, n, d[2000001], siz[2000001], head[2000001], tot, st[2000001], top, rem[2000001], rtop, minn[10000001], ans;
bool bucket[10000001], vis[2000001];
inl void dfs1(int x, int fa) {
	re max_sub = 0;
	siz[x] = 1;
	for (re i = head[x]; i; i = e[i].next) {
		if (fa != e[i].to && !vis[e[i].to]) {
			dfs1(e[i].to, x);
			siz[x] += siz[e[i].to];
			if (siz[e[i].to] > max_sub)max_sub = siz[e[i].to];
		}
	}
	max_sub = max(max_sub, ncnt - siz[x]);
	if (max_sub < min_siz) {
		min_siz = max_sub;
		focus = x;
	}
}
inl void dfs2(int x, int fa, int now) {
	siz[x] = 1;
	for (re i = head[x]; i; i = e[i].next) {
		if (e[i].to != fa && !vis[e[i].to]) {
			d[e[i].to] = d[x] + e[i].w;
			if (d[e[i].to] > k)d[e[i].to] = k + 1;
			dfs2(e[i].to, x, now + 1);
			siz[x] += siz[e[i].to];
		}
	}
}
inl void calc(int x, int fa, int now) {
	if (d[x] <= k)st[++top] = d[x], rem[++rtop] = d[x];
	if (d[x] <= k && bucket[k - d[x]]) {
		minn[k] = min(minn[k], now + minn[k - d[x]]);
	}
	for (re i = head[x]; i; i = e[i].next) {
		if (!vis[e[i].to] && e[i].to != fa) {
			calc(e[i].to, x, now + 1);
		}
	}
}
inl void dfs3(int x, int fa, int now) {
	minn[d[x]] = min(minn[d[x]], now);
	for (re i = head[x]; i; i = e[i].next) {
		if (!vis[e[i].to] && e[i].to != fa) {
			dfs3(e[i].to, x, now + 1);
		}
	}
}
inl void divide(int x, int fa) {
	min_siz = inf;
	dfs1(x, fa);
	x = focus, vis[x] = 1, bucket[0] = 1, minn[0] = 0, d[x] = 0, top = 0;
	dfs2(x, fa, 0);
	for (re i = head[x]; i; i = e[i].next) {
		if (!vis[e[i].to]) {
			calc(e[i].to, x, 1);
			if (e[i].next) {
				while (top) {
					if (st[top] <= k)bucket[st[top]] = 1;
					top--;
				}
				dfs3(e[i].to, x, 1);
			}
		}
	}
	ans = min(ans, minn[k]);
	while (rtop) {
		if (rem[rtop] <= k)bucket[rem[rtop]] = 0, minn[rem[rtop]] = inf;
		rtop--;
	}
	for (re i = head[x]; i; i = e[i].next) {
		if (!vis[e[i].to]) {
			ncnt = siz[e[i].to];
			divide(e[i].to, x);
		}
	}
}
inl void add(int x, int y, int w) {
	e[++tot] = edge{ head[x],y,w }, head[x] = tot;
	e[++tot] = edge{ head[y],x,w }, head[y] = tot;
}
signed main() {
	memset(minn, 0x3f, sizeof(minn)), ans = inf;
	ncnt = n = read<int>(), k = read<int>();
	for (re i = 1, x, y, w; i < n; i++)x = read<int>() + 1, y = read<int>() + 1, w = read<int>(), add(x, y, w);
	divide(1, 0);
	printf("%d\n", ans == inf ? -1 : ans);
}
```



---


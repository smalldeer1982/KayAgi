# [IOI 2019] 矩形区域

## 题目描述

19 世纪初，统治者下令在俯瞰美丽河景的高原上建造一座宫殿。这块高原被看做是一个由正方形单元格组成的 $n \times m$ 网格。网格的行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号。第 $i$ 行第 $j$ 列（$0 \le i \le n-1$，$0 \le j \le m-1$）的单元格记为单元格 $(i,j)$。每个单元格 $(i,j)$ 有特定的海拔高度，记为 $a_{i,j}$。

统治者指示他的建筑师选择一个矩形区域来建造宫殿。该区域不能包含网格边界（第 $0$ 行，第 $n-1$ 行，第 $0$ 列，以及第 $m-1$ 列）上的任何单元格。为此，建筑师应选出四个整数 $r_1$，$r_2$，$c_1$ 和 $c_2$（$1 \le r_1 \le r_2 \le n-2$ 且 $1 \le c_1 \le c_2 \le m-2$ )，对应于包括所有满足 $r_1 \le i \le r_2$ 且 $c_1 \le j \le c_2$ 的单元格 $(i,j)$ 的矩形区域。

此外，一个区域被认为是合法的，当且仅当对于该区域中的每个单元格 $(i,j)$，以下条件成立：对于与该区域相邻的、位于第 $i$ 行的两个单元格（单元格 $(i,c_1-1)$ 和 $(i,c_2+2)$），以及与该区域相邻的、位于第 $j$ 列的两个单元格（单元格 $(r_1-1)$ 和 $(r_2+2,j)$），单元格 $(i,j)$ 的海拔高度必须严格小于这四个单元格的海拔高度。

你的任务是帮助建筑师统计可建宫殿的合法区域的数量（也就是所对应区域为合法的 $r_1$，$r_2$，$c_1$ 和 $c_2$ 的数量）。



## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/p7kwnpod.png)

一共有 $6$ 个合法区域，分别为：
- $r_1=r_2=1, c_1=c_2=1$
- $r_1=1, r_2=2, c_1=c_2=1$
- $r_1=r_2=1, c_1=c_2=3$
- $r_1=r_2=4, c_1=2,c_2=3$
- $r_1=r_2=4, c_1=c_2=3$
- $r_1=3,r_2=4,c_1=c_2=3$

例如，$r_1=1, r_2=2, c_1=c_2=1$ 对应一个合法区域，原因是以下两个条件都成立：
- $a_{1,1}=4$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{1,0}=7$，和 $a_{1,2}=10$。
- $a_{2,1}=7$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{2,0}=9$，和 $a_{2,2}=20$。

**数据范围**

对于所有数据：
- $1 \le n, m \le 2500$。
- $0 \le a_{i,j} \le 7 \times 10^6 (0 \le i \le n - 1, 0 \le j \le m - 1)$。

详细子任务附加限制与分值如下表：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$n, m \le 30$|$8$|
|$2$|$n, m \le 80$|$7$|
|$3$|$n, m \le 200$|$12$|
|$4$|$n, m \le 700$|$22$|
|$5$|$n \le 3$|$10$|
|$6$|$0 \le a_{i,j} \le 1$|$13$|
|$7$|没有任何附加限制|$28$|

## 样例 #1

### 输入

```
6 5
4 8 7 5 6
7 4 10 3 5
9 7 20 14 2
9 14 7 3 6
5 7 5 2 7
4 5 13 5 6
```

### 输出

```
6
```

# 题解

## 作者：lnzwz (赞：6)

题意：
给一个$n×m$矩阵，问有多少子矩阵，对于其中任意一个数，都满足它小于它的上下左右四个方向中第一个在矩阵外面的数。

$1\leq n,m\leq 2500$。

写一个$O(nmlognm)$的做法。

首先，对于每一行，每一列，分别求出其中的合法区间。

显然，只要区间中的最大值满足条件（即它小于区间外侧的两个数）即可。

因此，我们可以枚举最大值，用单调栈求出两侧不大于它的区间$(l,r)$，那么，只有$(l-1,r+1)$可能满足条件。

这样，每个最大值只会贡献一个区间，因此总的区间数是$O(nm)$的。

求出这部分后，只要子矩阵的每行每列都能对应一个合法区间，它就是合法的了。

再求出每个子区间向下（向右）能延伸的长度，这个可以边扫描，边更新。

求答案时，我们可以枚举这个子矩阵最上边的那行，并枚举那行中的合法区间，设它的向下延伸长度为$x$，区间长度为$y$。

之后，再枚举它的左端点的列中，上端点位于这行的一个区间。

那么，只要这个区间长度不大于$x$，向右延伸长度不小于$y$，就会产生一个答案。

可以发现，这是一个类似二维数点的问题，直接扫描线+树状数组维护即可。

注意细节

代码：
```cpp
#include <stdio.h>
#include <vector>
using namespace std;
struct SJd
{
	int l,r;
	SJd(){}
	SJd(int L,int R)
	{
		l=L;r=R;
	}
};
int getlr(int sz[2502],int n,SJd jg[2502])
{
	int l[2502],r[2502],m=0;
	for(int i=0;i<n;i++)
		l[i]=r[i]=i;
	for(int i=0;i<n;i++)
	{
		while(l[i]>0&&sz[l[i]-1]<=sz[i])
			l[i]=l[l[i]-1];
	}
	for(int i=n-1;i>=0;i--)
	{
		while(r[i]+1<n&&sz[r[i]+1]<sz[i])
			r[i]=r[r[i]+1];
	}
	for(int i=0;i<n;i++)
	{
		if(l[i]>0&&r[i]+1<n&&sz[r[i]+1]>sz[i])
			jg[m++]=SJd(l[i],r[i]);
	}
	return m;
}
SJd ha[2502][2502],li[2502][2502];
int sh[2502],sl[2502],sz[2502][2502];
int dn[2502][2502],ri[2502][2502],dp[2502][2502];
bool bk[2502][2502];
struct SPx
{
	int j,ri;
	SPx(){}
	SPx(int J,int RI)
	{
		j=J;ri=RI;
	}
};
vector<SPx> ve[2502][2502];
int C[2502][2502],N;
void add(int a,int i)
{
	i+=1;
	for(int j=i;j>0;j-=j&(-j))
		C[a][j]+=1;
}
void clean(int a,int i)
{
	i+=1;
	for(int j=i;j>0;j-=j&(-j))
		C[a][j]=0;
}
int sum(int a,int i)
{
	int jg=0;i+=1;
	for(int j=i;j<=N;j+=j&(-j))
		jg+=C[a][j];
	return jg;
}
vector<int> vv[2510];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);N=m;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)
			scanf("%d",&sz[i][j]);
	}
	for(int i=0;i<n;i++)
		sh[i]=getlr(sz[i],m,ha[i]);
	for(int i=0;i<m;i++)
	{
		int jh[2502];
		for(int j=0;j<n;j++)
			jh[j]=sz[j][i];
		sl[i]=getlr(jh,n,li[i]);
	}
	for(int i=0;i<m;i++)
	{
		for(int j=0;j<m;j++)
			dp[i][j]=-1;
	}
	for(int i=n-1;i>=0;i--)
	{
		for(int j=0;j<sh[i];j++)
		{
			int l=ha[i][j].l,r=ha[i][j].r;
			dp[l][r]+=1;bk[l][r]=true;
			dn[i][j]=dp[l][r];
		}
		if(i<n-1)
		{
			for(int j=0;j<sh[i+1];j++)
			{
				int l=ha[i+1][j].l,r=ha[i+1][j].r;
				if(!bk[l][r])
					dp[l][r]=-1;
			}
		}
		for(int j=0;j<sh[i];j++)
		{
			int l=ha[i][j].l,r=ha[i][j].r;
			bk[l][r]=false;
		}
	}
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
			dp[i][j]=-1;
	}
	for(int i=m-1;i>=0;i--)
	{
		for(int j=0;j<sl[i];j++)
		{
			int l=li[i][j].l,r=li[i][j].r;
			dp[l][r]+=1;bk[l][r]=true;
			ri[i][j]=dp[l][r];
		}
		if(i<m-1)
		{
			for(int j=0;j<sl[i+1];j++)
			{
				int l=li[i+1][j].l,r=li[i+1][j].r;
				if(!bk[l][r])
					dp[l][r]=-1;
			}
		}
		for(int j=0;j<sl[i];j++)
		{
			int l=li[i][j].l,r=li[i][j].r;
			bk[l][r]=false;
		}
	}
	for(int i=0;i<m-1;i++)
	{
		for(int j=0;j<sl[i];j++)
			ve[li[i][j].l][li[i][j].r-li[i][j].l].push_back(SPx(i,ri[i][j]));
	}
	int ans=0;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
			vv[j].clear();
		for(int j=0;j<sh[i];j++)
			vv[dn[i][j]].push_back(j);
		for(int k=0;k<n;k++)
		{
			for(int s=0;s<ve[i][k].size();s++)
				add(ve[i][k][s].j,ve[i][k][s].ri);
			for(int s=0;s<vv[k].size();s++)
			{
				int j=vv[k][s],l=ha[i][j].l,r=ha[i][j].r,z=r-l;
				ans+=sum(l,z);
			}
		}
		for(int k=0;k<n;k++)
		{
			for(int s=0;s<ve[i][k].size();s++)
				clean(ve[i][k][s].j,ve[i][k][s].ri);
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：AK_Dream (赞：3)

### 题解
假设某个合法的矩形只有一行，是 $a_{1,l}\sim a_{1,r}$，那么显然有这样一个结论成立：$a_{1,l-1}$ 是 $a_{1,r+1}$ 左侧第一个大于它的 或者 $a_{1,r+1}$ 是 $a_{1,l-1}$ 右侧第一个大于它的

那么对于一个合法矩形，每一行都应该满足这个条件

每一列应该也要满足类似的条件

所以对于一行(或列)，可以通过单调栈来求出所有这样的 $[l,r]$

对于每一行都用这样的方法求出这样的 $[l,r]$，用一个`vector`: $ok[l][r]$ 来存储所有 $a_{i,l}~a_{i,r}$ 为合法段的 $i$

枚举矩形右边界 $r$，并每次更新 $lok[u][d]$ 表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 

然后枚举矩形左边界 $l$，枚举 $ok[l][r]$ 中的每一个连续段 $[u,d]$，那么矩形的上下边界在 $[u,d]$ 中时一定是满足行的限制的，只需找出有多少个左右边界为 $l,r$，上下边界在 $[u,d]$ 内的矩形满足条件即可

代码中做了注释

### 代码
```cpp
#include <bits/stdc++.h>
#define N 2520
using namespace std;

template <typename T>
inline void read(T &num) {
	T x = 0, f = 1; char ch = getchar();
	for (; ch > '9' || ch < '0'; ch = getchar()) if (ch == '-') f = -1;
	for (; ch <= '9' && ch >= '0'; ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ '0');
	num = x * f;	 
}

int n, m, a[N][N], stk[N], cnt, top, ans; 
vector<int> ok[N][N]; //ok[l][r]: a[l][i]~a[r][i]为合法段的i的集合 
pair<int, int> tmp[N]; //临时存答案 
int lok[N][N], rok[N][N]; 

void solve(int *num, int len) { //找出所有合法段 
	cnt = top = 0;
	for (int i = 1; i <= len; i++) {
		while (top && num[i] > num[stk[top]]) {
			if (i > stk[top] + 1) tmp[++cnt] = make_pair(stk[top]+1, i-1); 
			//num[l] < num[r]
			top--;
		}
		if (top) {
			if (i > stk[top] + 1) tmp[++cnt] = make_pair(stk[top]+1, i-1);
			//num[l]>num[r]
			if (num[i] == num[stk[top]]) top--;
			//特殊处理相等情况 
		}
		stk[++top] = i; 
	}
}

void calc(int l, int r, int u, int d) { 
	//左右边界为l,r;上下边界在[u,d]内 
	int len = 0;
	for (int i = u - 1; i <= d + 1; i++) {
		a[0][++len] = a[i][r];
	}
	solve(a[0], len); //找出列的合法段 
	for (int i = 1; i <= cnt; i++) {
		int tl = tmp[i].first + u - 2, tr = tmp[i].second + u - 2;
		if (lok[tl][tr] <= l) ans++;
	}
} 

int main() {
	read(n); read(m);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			read(a[i][j]);
		}
	}	
	for (int i = 2; i < n; i++) { //预处理ok集合 
		solve(a[i], m);
		for (int j = 1; j <= cnt; j++) ok[tmp[j].first][tmp[j].second].push_back(i); 
	}
	for (int r = 2; r < m; r++)  { //枚举矩形右边界 
		for (int i = 1; i <= n; i++) a[0][i] = a[i][r];
		solve(a[0], n);
		for (int i = 1; i <= cnt; i++) {
			if (rok[tmp[i].first][tmp[i].second] + 1 < r)
				lok[tmp[i].first][tmp[i].second] = r;
			rok[tmp[i].first][tmp[i].second] = r;
			//lok[u][d]表示只考虑列的限制，当矩形的上下边界为u,d，右边界为r时，左边界最左是哪里 
		} 
		for (int l = 2; l <= r; l++) { //枚举矩形左边界 
			if (!ok[l][r].size()) continue;
			int lst = ok[l][r][0];
			for (int i = 1; i < ok[l][r].size(); i++) {
				if (ok[l][r][i] > ok[l][r][i-1] + 1) {
					//找出ok[l][r]中的一个连续段 
					calc(l, r, lst, ok[l][r][i-1]);
					lst = ok[l][r][i];
				}
			} 
			calc(l, r, lst, ok[l][r][ok[l][r].size()-1]);
		} 
	} 
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Wuyanru (赞：2)

[在我的博客中查看](https://www.cnblogs.com/Wuyanru/p/luoguP5781.html)

今天打模拟赛遇到的，不得不说有点神仙，所以来写一篇题解。

因为这题是 IOI 的，IOI 的很多题子任务都提示了做法，所以本题解中对大部分 Subtask 进行了分析。

我写这篇题解主要是想要分享一下我做这道题的过程，我认为一道题的思考过程才是最重要的。

注意：

1.  由于作者的叙述习惯不同，本文中**所有矩阵的下标均从 $ 1 $ 开始计数**。

2.  如果时间复杂度中没有出现 $ m $ ,那么这个地方的时间复杂度默认 $ n,m $ 同阶。

题目链接：[P5781](https://www.luogu.com.cn/problem/P5781)

### Subtask 5

由于这个 Subtask 条件比较特殊，所以我们先来看它。

这个矩阵最多只有三行，根据题目中对子矩阵的要求，我们可以知道这些子矩阵的元素只能出现在第二行。

首先我们可以知道在这个限制下某个元素可以出现的必要条件是它严格大于它上下的元素。

然后我们将所有第二行的元素从小到大进行排序，并依次加入这些格子，加入某个格子后我们可以查看这个格子所在的连通块是否合法，然后统计答案即可。

干说不明白，不如画几个图。

假如这是那个矩阵。

[![XaHQ2R.png](https://s1.ax1x.com/2022/06/04/XaHQ2R.png)](https://imgtu.com/i/XaHQ2R)

首先我们看一下有哪些格子可能作为子矩阵中的元素，我们将他们标红

[![XaHn54.png](https://s1.ax1x.com/2022/06/04/XaHn54.png)](https://imgtu.com/i/XaHn54)

然后我们将第二行中的元素排好序，逐个加入。

首先我们加入 $ 1 $ ，就可以得到一个子矩阵（左端点下标为 $ 2 $ ，右端点下标也为 $ 2 $ ）。

[![XaHlx1.png](https://s1.ax1x.com/2022/06/04/XaHlx1.png)](https://imgtu.com/i/XaHlx1)

然后我们加入 $ 4 $ ，又可以得到一个子矩阵（左端点下标为 $ 4 $ ，右端点下标也为 $ 4 $ ）。

[![XaHMG9.png](https://s1.ax1x.com/2022/06/04/XaHMG9.png)](https://imgtu.com/i/XaHMG9)

下来我们加入 $ 6 $ ，又可以得到一个子矩阵（左端点下标为 $ 1 $ ，右端点下标为 $ 6 $ ）。

[![XaHn54.png](https://s1.ax1x.com/2022/06/04/XaHn54.png)](https://imgtu.com/i/XaHn54)

再然后我们加入 $ 9 $ ，可以发现，新形成的矩阵中没有一个满足要求(没有只包含红色方块)。

[![XaHKPJ.png](https://s1.ax1x.com/2022/06/04/XaHKPJ.png)](https://imgtu.com/i/XaHKPJ)

最后我们加入 $ 10 $ ，新形成的矩阵还是没有一个满足要求(没有只包含红色方块)。

[![XaHYVO.png](https://s1.ax1x.com/2022/06/04/XaHYVO.png)](https://imgtu.com/i/XaHYVO)

大概就是这样子的一个过程，我们就可以拿到 $ 10 $ 分的“高”分。

### Subtask1

我们可以枚举这个子矩阵的位置，然后对每个子矩阵看一下是否合法。

然后你就会发现这样子是 $ O(n^6) $ 的，虽然这题时限是 $ 5s $ ，**可能**能过。

我们可以来找一下性质。

不妨来看一眼，某个子矩阵的右边界从红色的这条线向右走到蓝色的这条线时，这个新矩阵什么情况下是合法的（加入只右移了一格）。

[![Xaqq29.png](https://s1.ax1x.com/2022/06/04/Xaqq29.png)](https://imgtu.com/i/Xaqq29)

首先我们可以预处理每一行的最大值，这样就可以 $ O(1) $ 算出某一行是否合法，然后我们对于最右边的一列，暴力求出最大值，计算最右边那一列是否合法就可以了。

这样的时间复杂度是 $ O(n^5) $ 的。

这样我们就又可以拿到 $ 8 $ 分。

### Subtask2

这个部分做法感觉和 Subtask5 有点类似。

我们可以枚举这个子矩阵的上边界和下边界，这个时候我们看哪一列有可能在这个子矩阵之中出现。（由于我们枚举的是上边界和下边界，所以某一列一定是同时出现或同时不出现。）（出现的条件也差不多，这一列中最大的那个元素比上下的元素都小。）

然后我们就会发现这次我们每一次是加入整个列，那么我们该按什么顺序加入这些列呢？

我们不妨按照这个列的最大值进行排序，最大值越小的越先加入。

我们再处理一下相邻两列的关系，再来举一个例子。

[![XaXZ4S.png](https://s1.ax1x.com/2022/06/04/XaXZ4S.png)](https://imgtu.com/i/XaXZ4S)

显然，这两列都是有可能成为某个子矩阵中的元素。

但是，如果第一列在子矩阵中出现，第二列也一定出现；如果第二列出现了，第一列也一定出现，这就形成了一些“连带关系”。

我们只要提前预处理这些“连带关系”，到时候具有连带关系的列一起加入就可以了。

这样子时间复杂度是 $ O(n^4) $ 的，我们又可以拿到 $ 7 $ 分。

### Subtask3

注意，这个地方的解法已经和满分有一定关系了（起码我的做法是这个样子）。

不妨这样想，我们要找的子矩阵，既需要满足行的条件，又需要满足列的条件。

那我们能不能找出所有满足行条件的子矩阵，再找出所有满足列条件的子矩阵呢，最后找出它们中相同的呢？

显然，不会算多，也不会算少，这个方法很可行。

我们来看一下所有满足行条件的子矩阵怎么找：

这个问题似乎不太好想，我们从简单的想起，假如说我们要找的子矩阵只有一行，怎么办。

这不就是上面提到的 Subtask5 吗？甚至还简单了亿点。

假如说这个子矩阵有两行呢？它需要满足什么条件？

稍微想一下就会发现，只需要第一行的那些元素可行，第二行的那些元素可行，这个子矩阵就是可行的。

再进一步扩展，如果一个左上角坐标为 $ (u,l) $ ，右下角坐标为 $ (d,r) $ 的子矩阵可行，就只需要第 $ l $ 行到第 $ r $ 中每一行的对应子矩阵（该行的第 $ l $ 列到第 $ r $ 列）可行就可以了。

直接算就可以了，那么时间复杂度是多少呢？

首先我们知道，对于单行来说，可行的子矩阵最多只有 $ m $ 个。

矩阵一共有 $ n $ 行，对于该行的每一个子矩阵，我们都要向下找下面所有行中能和这一行共同组成的子矩阵数量，所以这里时间复杂度是 $ O(n^2m) $ 的。

接下来我们还要进行矩阵的匹配，显然还要使用 set。

最后时间复杂度是 $ O(n^2m\log{nm}) $ 的。

事实上可以过 Subtask1,2,3,5,6。

到这里，我们就可以拿到 $ 50 $ 分，还是挺香的。

### Subtask4

我们会发现，这个 Subtask 只需要 $ O(n^3) $ 的时间复杂度就可以了，不难发现，上面那个做法的瓶颈主要在于矩阵的匹配，有什么更好的做法呢？

我们在枚举行矩阵/列矩阵的时候不妨换一种方式，下面拿行矩阵举例。

不难发现，对于一组确认的左边界、上边界与右边界，一个合法的下边界必定是连续的一段区间。

列矩阵也是一样，对于一组确认的上边界、左边界和下边界，一个合法的有边界也是连续的一段区间。

再转化一下，对于一个固定的点，我们把它作为矩阵的左上角，那么一个合法行矩阵的右下角肯定是一堆竖着的线段，一个合法的列矩阵肯定是一堆横着的线段。任何一个横着的线段和任何一个竖着的线段的交点（如果它们有交点）一定是一个合法的右下角。

我们只需要枚举一个左上角的点，然后枚举横着的和竖着的线段，看他们有没有交点就好了。

时间复杂度看起来是 $ O(n^4) $ 的，但是对于每一行来说，与之对应的横线段最多有 $ n $ 个，竖线段最多有 $ m $ 个。

所以时间复杂度是 $ O(n^2m) $ 的。

可以过 Subtask1,2,3,4,5,6，拿到了 $ 72 $ 分。

可能说的有一点难懂，这部分代码我就放一下。

[代码](https://www.luogu.com.cn/paste/6r24kgk7)

因为我们学校 OJ 比较快，比赛当时这份程序拿了 $ 72 $ 分，但是 luogu 上只拿了 $ 37 $ 分，卡一卡应该也差不多（雾

### 正解

说了这么多终于说到了。

我们首先可以发现无论是上面寻找行矩阵/列矩阵，还是下面进行匹配的过程，都是 $ n^2m $ 的，无法通过本题，所以上述两部分都需要优化。

#### 优化1

先来优化寻找行矩阵/列矩阵的部分。

我们来看瓶颈在哪里，不难发现是在加入“线段”的过程，我们需要枚举一个点( $ O(nm) $ )，然后向下/右延申线段。

不难发现，其中一部分枚举是重复的。因为当我们找到一个行矩阵时候，这个矩阵去掉最上面/最下面一行，剩下的行矩阵必定合法，列矩阵也是一样。

这个样子，我们就可以将这部分优化到 $ O(nm\log m) $。

为啥有个 $ \log $ ？因为我们在每一行/列中都要对元素进行排序。

#### 优化2

不难发现，这个部分其实就是一个找线段有多少个交点的过程。

我们直接树状数组统计一下就可以了。

其实看起来简单，实际细节还是有亿点的，具体可以看代码。

最终时间复杂度是 $ O(n^2\log n) $。

代码：

这份代码 luogu 上可过，请放心~~食用~~。

```c++
#include<algorithm>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
template<typename T>
using vc=vector<T>;
using ll=long long;
inline int lowbit(int i){ return i&(-i);}
template<typename A>
using pqueue=priority_queue<A,vector<A>,greater<A> >;
inline int read()
{
    int s=0,w=1;char ch;
    while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
struct line
{
    int l,r;
    int wh;
    line(int l=0,int r=0,int wh=0) :l(l),r(r),wh(wh){}
};
struct node
{
    int num;
    int wh;
}b[2501];
bool operator < (line a,line b)
{
    return a.r<b.r;
}
bool operator > (line a,line b)
{
    return a.r>b.r;
}
vc<line>ans1[2502][2502];
vc<line>ans2[2502][2502];
vc<int>vis[2502][2502];
int a[2502][2502];
line num1[2502];
line num2[2502];
int t[2502];
int fa[2502];
int l[2502];
int r[2502];
int n,m;
ll ans;
int find(int num)
{
    if(fa[num]==num) return num;
    return fa[num]=find(fa[num]);
}
void add(int wh)
{
    fa[wh]=l[wh]=r[wh]=wh;
    if(fa[wh-1])
    {
        int num=find(wh-1);
        fa[num]=wh,l[wh]=l[num];
    }
    if(fa[wh+1])
    {
        int num=find(wh+1);
        fa[num]=wh,r[wh]=r[num];
    }
}
void push(int i,int wh,int ma)
{
    int num=find(wh);
    if(num!=wh) return ;
    if(l[wh]==1||r[wh]==ma) return ;
    // printf("%d %d %d\n",i,l[wh],r[wh]);
    vis[l[wh]][r[wh]].push_back(i);
}
void addt(int x,int y)
{
    while(x<=n)
    {
        t[x]+=y;
        x+=lowbit(x);
    }
}
int gett(int x)
{
    int ans=0;
    while(x)
    {
        ans+=t[x];
        x-=lowbit(x);
    }
    return ans;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) a[i][j]=read();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++) b[j].num=a[i][j],b[j].wh=j;
        sort(b+1,b+m+1,[](node a,node b){ return a.num<b.num;});
        for(int j=1,k;j<=m;j=k)
        {
            for(k=j;k<=m&&b[j].num==b[k].num;k++);
            for(int y=j;y<k;y++) add(b[y].wh);
            for(int y=j;y<k;y++) push(i,b[y].wh,m);
        }
        for(int i=1;i<=m;i++) fa[i]=0;
    }
    for(int s=1;s<=m;s++) for(int e=s;e<=m;e++) for(unsigned i=0,j;i<vis[s][e].size();i=j)
    {
        for(j=i;j<vis[s][e].size()&&vis[s][e][j]-j==vis[s][e][i]-i;j++);
        for(unsigned k=i;k<j;k++) ans1[vis[s][e][k]][s].push_back(line(vis[s][e][k],vis[s][e][j-1],e));
    }
    for(int i=1;i<=m;i++) for(int j=1;j<=m;j++) vis[i][j].clear();

    for(int j=1;j<=m;j++)
    {
        for(int i=1;i<=n;i++) b[i].num=a[i][j],b[i].wh=i;
        sort(b+1,b+n+1,[](node a,node b){ return a.num<b.num;});
        for(int i=1,k;i<=n;i=k)
        {
            for(k=i;k<=n&&b[i].num==b[k].num;k++);
            for(int x=i;x<k;x++) add(b[x].wh);
            for(int x=i;x<k;x++) push(j,b[x].wh,n);
        }
        for(int i=1;i<=n;i++) fa[i]=0;
    }
    for(int s=1;s<=n;s++) for(int e=s;e<=n;e++) for(unsigned i=0,j;i<vis[s][e].size();i=j)
    {
        for(j=i;j<vis[s][e].size()&&vis[s][e][j]-j==vis[s][e][i]-i;j++);
        for(unsigned k=i;k<j;k++) ans2[s][vis[s][e][k]].push_back(line(vis[s][e][k],vis[s][e][j-1],e));
    }
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
    {
        int tot1=0,tot2=0;
        for(line k:ans1[i][j]) num1[++tot1]=k;
        for(line k:ans2[i][j]) num2[++tot2]=k;
        sort(num1+1,num1+tot1+1,[](line a,line b){ return a.wh<b.wh;});
        sort(num2+1,num2+tot2+1,[](line a,line b){ return a.l<b.l;});
        pqueue<line>que;int now=1;
        for(int k=1;k<=tot1;k++)
        {
            while(now<=tot2&&num2[now].l<=num1[k].wh) addt(num2[now].wh,1),que.push(num2[now]),now++;
            while(que.size()&&que.top().r<num1[k].wh) addt(que.top().wh,-1),que.pop();
            ans+=gett(num1[k].r)-gett(num1[k].l-1);
        }
        while(que.size()) addt(que.top().wh,-1),que.pop();
    }
    printf("%lld\n",ans);
    return 0;
}
```

感谢观看！

---

## 作者：Kubic (赞：1)

首先考虑序列怎么做。

对于一段合法的区间 $[l,r]$，如果 $a_l\le a_r$，那么 $\forall i\in (l,r),a_i<a_l$。此时可以发现 $r$ 是唯一的，它是 $l$ 往右找到的第一个 $r$ 满足 $a_r\ge a_l$。反之亦然。因此总的合法的区间只有不超过 $2n$ 个。

假设 $pos1_{i,j},pos2_{i,j}$ 分别为 $(i,j)$ 往 左/右 找第一个 $\ge a_{i,j}$ 的位置的横坐标，$pos3_{i,j},pos4_{i,j}$ 分别为 $(i,j)$ 往 上/下 找第一个 $\ge a_{i,j}$ 的位置的纵坐标。

因此我们可以考虑枚举矩形的左边界和右边界 $i,j$。对于一个 $k$，如果 $pos1_{k,i}=j$ 或 $pos2_{k,j}=i$，那么就称 $k$ 是合法的。根据上面的性质，三元组 $(i,j,k)$ 的总数不会超过 $2n^2$。

显然一个合法的矩形所包含的纵坐标一定都是合法的。我们可以在所有合法的 $k$ 中枚举一个作为矩形的一个横向边界。此时矩形的另一个横向边界一定是 $pos3_{k,i}$ 或 $pos4_{k,i}$，我们需要判断它是否合法。

预处理 $mx1_{i,j}$ 表示矩形的右边界是 $j$，一个横向边界是 $i$ 另一个横向边界是 $pos3_{i,j}$ 时的左边界的最小值，$mx2_{i,j}$ 表示矩形的右边界是 $j$，一个横向边界是 $i$ 另一个横向边界是 $pos4_{i,j}$ 时的左边界的最小值。对于一个三元组 $(i,j,k)$，如果 $mx1_{j,k}\le i$ 那么就有 $1$ 的贡献，如果 $mx2_{j,k}\le i$ 那么就又有 $1$ 的贡献。

这两个数组可以相互递推预处理出来。于是我们就做完了这道题。

如果实现精细可以做到 $O(nm)$。下面的参考代码时间复杂度是 $O(nm\log nm)$，但跑得飞快，成功拿到榜一。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2505
#define LIM 10000005
#define gc() (P1==P2 && (P2=(P1=buf)+fread(buf,1,LIM,stdin),P1==P2)?EOF:*P1++)
#define pb push_back
const int INF=1e9;char *P1,*P2,buf[LIM];
int n,m,ans,st[N],a[N][N],ps1[N][N],ps2[N][N],ps3[N][N],ps4[N][N];
int L[N],R[N],mx1[N][N],mx2[N][N];vector<int> vc[N][N];
int rd()
{
	int res=0;char c=0;while(!isdigit(c)) c=gc();
	while(isdigit(c)) res=res*10+c-48,c=gc();return res;
}
int main()
{
	n=rd();m=rd();for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) a[i][j]=rd();
	for(int i=2;i<n;++i)
	{
		st[0]=0;
		for(int j=1;j<=m;++j)
		{
			while(st[0] && a[i][j]>a[i][st[st[0]]]) --st[0];
			ps1[i][j]=st[st[0]];st[++st[0]]=j;
			if(ps1[i][j]) vc[ps1[i][j]][j].pb(i);
		}st[0]=0;
		for(int j=m;j;--j)
		{
			while(st[0] && a[i][j]>a[i][st[st[0]]]) --st[0];
			if(ps1[i][st[st[0]]]!=j) ps2[i][j]=st[st[0]];st[++st[0]]=j;
			if(ps2[i][j]) vc[j][ps2[i][j]].pb(i);
		}
	}
	for(int i=1;i<=m;++i)
	{
		st[0]=0;
		for(int j=1;j<=n;++j)
		{
			while(st[0] && a[j][i]>a[st[st[0]]][i]) --st[0];
			ps3[j][i]=st[st[0]];st[++st[0]]=j;
		}st[0]=0;
		for(int j=n;j;--j)
		{
			while(st[0] && a[j][i]>a[st[st[0]]][i]) --st[0];
			if(ps3[st[st[0]]][i]!=j) ps4[j][i]=st[st[0]];st[++st[0]]=j;
		}
	}
	for(int i=1;i<=m;++i) for(int j=1;j<=n;++j)
	{
		if(ps3[j][i] && ps3[j][i]<j-1)
		{
			if(ps3[j][i]==ps3[j][i-1]) mx1[j][i]=mx1[j][i-1];
			else if(j==ps4[ps3[j][i]][i-1]) mx1[j][i]=mx2[ps3[j][i]][i-1];
			else mx1[j][i]=i;
		}else mx1[j][i]=INF;
		if(ps4[j][i] && ps4[j][i]>j+1)
		{
			if(ps4[j][i]==ps4[j][i-1]) mx2[j][i]=mx2[j][i-1];
			else if(j==ps3[ps4[j][i]][i-1]) mx2[j][i]=mx1[ps4[j][i]][i-1];
			else mx2[j][i]=i;
		}else mx2[j][i]=INF;
	}
	for(int i=1,t,lst;i<=m;++i) for(int j=i+2;j<=m;++j)
	{
		sort(vc[i][j].begin(),vc[i][j].end());lst=-1;
		for(int k=vc[i][j].size()-1;k>=0;--k)
		{t=vc[i][j][k];if(t+1==lst) R[t]=R[t+1];else R[t]=t;lst=t;}lst=-1;
		for(auto k:vc[i][j])
		{
			if(k-1==lst) L[k]=L[k-1];else L[k]=k;lst=k;
			if(ps3[k+1][j-1]<k && ps3[k+1][j-1]>=L[k]-1 && mx1[k+1][j-1]<=i+1) ++ans;
			if(ps4[k-1][j-1]>k && ps4[k-1][j-1]<=R[k]+1 && mx2[k-1][j-1]<=i+1) ++ans;
		}
	}printf("%d\n",ans);return 0;
}
```

---


# [IOI 2013] game 游戏

## 题目背景

警告：**滥用本题评测将被封号**。

## 题目描述

Bazza 和 Shazza 正在玩游戏。游戏在一个 $R$ 行 $C$ 列的网格上进行。其中， $R$ 行编号为 $0,\cdots, R - 1 $， $C$ 列编号为 $0,\cdots, C - 1 $。我们用 $(P, Q)$ 表示位于 $P$ 行 $Q$ 列的单元格。每个单元格包含一个非负整数，游戏开始时所有单元格内的整数均为零。

游戏如下进行：任意时刻，Bazza 可以做如下动作之一：
- 修改一个单元格 $(p, q)$ 内包含的整数值；
- 要求 Shazza 计算一个给定子矩阵中所有单元格内数字的最大公约数（GCD），子矩阵的两个对角分别为 $(p, q)$ 和 $(u, v)$ （子矩阵包含给定的两个对角点）。

Bazza 会做 $N_U + N_Q$ 次动作(其中，修改单元格内数据 $N_U$ 次，询问 GCD $N_Q$ 次) 。

你的任务是对 Bazza 提出的问题给出正确答案。

## 说明/提示

**子任务**

| 子任务 | 分数 | $R$ | $C$ | $N_U$ | $N_Q$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $\le 100$ | $\le 100$ | $\le 100$ | $\le 100$ |
| $2$ | $27$ | $\le 10$ | $\le 10^5$ | $\le 10^4$ | $\le 2.5\times 10^5$ |
| $3$ | $26$ | $\le 2 \times 10^3$ | $\le 2 \times 10^3$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $4$ | $17$ | $\le 10^9$ | $\le 10^9$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $5$ | $20$ | $\le 10^9$ | $\le 10^9$ | $\le 2.2 \times 10^4$ | $\le 2.5 \times 10^5$ |

**限制**

对于 $100\%$ 的数据，$1 \le R,C \le 10^9$，$0 \le K \le 10^{18}$，$K$ 表示 Bazza 放到单元格中的数字。

## 样例 #1

### 输入

```
1 1 64
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 5352072091165800
2 0 0 0 0
1 0 0 15571253006461152
1 0 0 36204425277916896
1 0 0 80686018200191040
1 0 0 720602986354563312
2 0 0 0 0
1 0 0 90705271009665312
2 0 0 0 0
1 0 0 583803309300971760
1 0 0 3317329660750560
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 84776821924066272
1 0 0 581927323100969664
1 0 0 93139161501610224
1 0 0 28340661117472704
1 0 0 74529074218959360
2 0 0 0 0
1 0 0 462419028676725120
1 0 0 4416867915235776
1 0 0 840475934823549024
1 0 0 8247617084266560
1 0 0 117571055091706944
1 0 0 839204903894797440
1 0 0 820805176764813240
1 0 0 82688722861897152
1 0 0 136422472061715840
1 0 0 555837014267982720
1 0 0 935087613488388360
1 0 0 17770822018565616
1 0 0 10726679222715456
1 0 0 621229604181863040
1 0 0 12477973789689408
2 0 0 0 0
1 0 0 227153207069268480
1 0 0 262037449583477568
1 0 0 562837835495871936
1 0 0 131875056326325312
1 0 0 922430858108760
1 0 0 763487168205041280
2 0 0 0 0
2 0 0 0 0
1 0 0 551850903114166656
1 0 0 243713152409807808
1 0 0 306811355534716032
1 0 0 115604757169181280
2 0 0 0 0
1 0 0 29254579698314880
1 0 0 35080064244441216
1 0 0 97819409912384160
1 0 0 34259332503876480
2 0 0 0 0
2 0 0 0 0
1 0 0 159548730492191040
1 0 0 11555364984947784
2 0 0 0 0
1 0 0 3373083100427040
2 0 0 0 0
2 0 0 0 0
```

### 输出

```
0
0
0
5352072091165800
720602986354563312
90705271009665312
3317329660750560
3317329660750560
3317329660750560
74529074218959360
12477973789689408
763487168205041280
763487168205041280
115604757169181280
34259332503876480
34259332503876480
11555364984947784
3373083100427040
3373083100427040
```

# 题解

## 作者：Y25t (赞：6)

### 题目大意

二维单点修改区间求$\gcd$（~~题目描述得已经很清楚了吧qwq~~）

### 题解

这种二维问题大概什么树套树都能过，我这里用的是线段树套线段树，以下是一些需要注意的细节：

- 因为$R,C\leq10^9$，所以需要离散化（意味着不能强制在线）；

- 由于空间限制，里层线段树需要动态开点且只能开到$O(N_U)$大小，外层可以开到$O(N_U+N_Q)$；

- 注意$\gcd$只满足区间可加，于是每一次修改都必须从下往上依次合并；

- 本题约定$\gcd(0,a)=\gcd(a,0)=a$

时空效率$O(Nlog^2N)$（这里认为$N,N_U,N_Q$同级）

以下代码：
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define NU 22005
#define NQ 250005

inline void rd(int &x){
	x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
}
inline void rdll(ll &x){
	x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
}

int n;
struct query{
	int opt,x1,y1,x2,y2;
	ll val;
}qry[NU+NQ];

int Valu[NU],_Valu,Valq[NU+(NQ<<1)],_Valq;
inline void unq(){
	std::sort(Valu+1,Valu+_Valu+1);
	_Valu=std::unique(Valu+1,Valu+_Valu+1)-Valu-1;
	std::sort(Valq+1,Valq+_Valq+1);
	_Valq=std::unique(Valq+1,Valq+_Valq+1)-Valq-1;
}
inline int idu(int val){
	return std::upper_bound(Valu+1,Valu+_Valu+1,val)-Valu-1;
}
inline int idq(int val){
	return std::upper_bound(Valq+1,Valq+_Valq+1,val)-Valq-1;
}

inline ll gcd(ll x,ll y){
	while(x&&y){
		ll tmp=x%y;
		x=y;
		y=tmp;
	}
	return x+y;
}

int _t;
struct node{
	int son[2];
	ll val;
}t[NU<<9];
#define lson t[p].son[0],L,mid
#define rson t[p].son[1],mid+1,R
inline void ins(int &p,int L,int R,int pos,ll val){
	if(!p)
		p=++_t;
	if(L==R){
		t[p].val=val;
		return;
	}
	int mid=(L+R)>>1;
	if(pos<=mid)
		ins(lson,pos,val);
	else
		ins(rson,pos,val);
	t[p].val=gcd(t[t[p].son[0]].val,t[t[p].son[1]].val);
}
inline void mrg(int &p,int L,int R,int q1,int q2,int pos){
	if(!p)
		p=++_t;
	if(L==R){
		t[p].val=gcd(t[q1].val,t[q2].val);
		return;
	}
	int mid=(L+R)>>1;
	if(pos<=mid)
		mrg(lson,t[q1].son[0],t[q2].son[0],pos);
	else
		mrg(rson,t[q1].son[1],t[q2].son[1],pos);
	t[p].val=gcd(t[t[p].son[0]].val,t[t[p].son[1]].val);
}
inline ll Cal(int p,int L,int R,int l,int r){
	if(!p||Valu[L]>r||Valu[R]<l)
		return 0;
	if(l<=Valu[L]&&Valu[R]<=r)
		return t[p].val;
	int mid=(L+R)>>1;
	return gcd(Cal(lson,l,r),Cal(rson,l,r));
}
#undef lson
#undef rson

int rt[(NU+(NQ<<1))<<2];
#define lson p<<1,L,mid
#define rson p<<1|1,mid+1,R
inline void mdf(int p,int L,int R,int pos,int pos2,ll val){
	if(pos<L||pos>R)
		return;
	if(L==R){
		ins(rt[p],1,_Valu,pos2,val);
		return;
	}
	int mid=(L+R)>>1;
	mdf(lson,pos,pos2,val);
	mdf(rson,pos,pos2,val);
	mrg(rt[p],1,_Valu,rt[p<<1],rt[p<<1|1],pos2);
}
inline ll cal(int p,int L,int R,int l,int r,int l2,int r2){
	if(L>r||R<l)
		return 0;
	if(l<=L&&R<=r)
		return Cal(rt[p],1,_Valu,l2,r2);
	int mid=(L+R)>>1;
	return gcd(cal(lson,l,r,l2,r2),cal(rson,l,r,l2,r2));
}
#undef lson
#undef rson

int main(){
	rd(n),rd(n),rd(n);
	for(int i=1;i<=n;i++){
		rd(qry[i].opt);
		if(qry[i].opt==1){
			rd(qry[i].x1),rd(qry[i].y1),rdll(qry[i].val);
			Valu[++_Valu]=qry[i].y1;
			Valq[++_Valq]=qry[i].x1;
		}
		else{
			rd(qry[i].x1),rd(qry[i].y1),rd(qry[i].x2),rd(qry[i].y2);
			Valq[++_Valq]=qry[i].x1;
			Valq[++_Valq]=qry[i].x2;
		}
	}
	unq();
	for(int i=1;i<=n;i++)
		if(qry[i].opt==1)
			mdf(1,1,_Valq,idq(qry[i].x1),idu(qry[i].y1),qry[i].val);
		else
			printf("%lld\n",cal(1,1,_Valq,idq(qry[i].x1),idq(qry[i].x2),qry[i].y1,qry[i].y2));
  
  #define w 0
  return ~~('0')?(0^w^0):(0*w*0);
}
```


---

## 作者：yukari1735 (赞：1)

二维改点，询问 $\text{4-side}$ 矩形 $\gcd$。

似乎 $\text{IOI}$ 赛时是交互题所以是强制在线的，但是这里没有这个要求，不妨直接把二维坐标离散化。

$\gcd$ 不能差分所以没办法愉快扫描线，于是暴力树套树。

事实上 $O(n\log^2n)$ 空间的线段树套线段树是能过的。如果内层套平衡树，空间复杂度可以优化到 $O(n\log n)$。

算上 $\gcd$ 的复杂度，总时间复杂度 $O(n\log^3n)$。

以下是一份线段树套线段树的代码。外层 `Segment_Tree_1` 维护 $x$ 轴，内层 `Segment_Tree_2` 维护 $y$ 轴。

```cpp
# include <cstdio>
# include <iostream>
# include <algorithm>
# include <vector>

using namespace std;

typedef long long ll;

ll I(){
	ll res = 0 , z = 1;
	char c = getchar();
	while( ! isdigit( c ) ){ if( c == '-' ) z = -1; c = getchar(); }
	while( isdigit( c ) ) res = res * 10 + c - '0' , c = getchar();
	return res * z; 
}

const int N = 1e6 + 225;

struct Operation{
	int op , x1 , y1 , x2 , y2;
	ll k;
}Q[ N ];

int n , m , q , fX , fY;

vector< int >X , Y;
# define pb push_back
# define lb lower_bound 

ll GCD( ll x , ll y ){
	return y ? GCD( y , x % y ) : x;
}

struct Segment_Tree_1{
	int ls , rs , R;
}T[ N << 2 ];

struct Segment_Tree_2{
	int ls , rs;
	ll d;
}D[ N << 5 ];

int dT , dD , R;

void Push_Up( int & u , int l , int r , int p , int x , int y ){
	if( ! u ) u = ++ dD;
	if( l == r ){
		D[ u ] . d = GCD( D[ x ] . d , D[ y ] . d );
		return;
	}
	int mid = l + r >> 1;
	if( p <= mid ) Push_Up( D[ u ] . ls , l , mid , p , D[ x ] . ls , D[ y ] . ls );
	else Push_Up( D[ u ] . rs , mid + 1 , r , p , D[ x ] . rs , D[ y ] . rs );
	D[ u ] . d = GCD( D[ D[ u ] . ls ] . d , D[ D[ u ] . rs ] . d );
} 

void Modify_Y( int & u , int l , int r , int p , ll d ){
	if( ! u ) u = ++ dD; 
	if( l == r ){ D[ u ] . d = d; return; }
	int mid = l + r >> 1;
	if( p <= mid ) Modify_Y( D[ u ] . ls , l , mid , p , d );
	else Modify_Y( D[ u ] . rs , mid + 1 , r , p , d );
	D[ u ] . d = GCD( D[ D[ u ] . ls ] . d , D[ D[ u ] . rs ] . d );
}

void Modify_X( int & u , int l , int r , int x , int y , ll d ){
	if( ! u ) u = ++ dT;
	if( l == r ){
		Modify_Y( T[ u ] . R , 1 , fY , y , d );
		return;
	}
	int mid = l + r >> 1;
	if( x <= mid ) Modify_X( T[ u ] . ls , l , mid , x , y , d );
	else Modify_X( T[ u ] . rs , mid + 1 , r , x , y , d );
	Push_Up( T[ u ] . R , 1 , fY , y , T[ T[ u ] . ls ] . R , T[ T[ u ] . rs ] . R );
}

ll Query_Y( int u , int l , int r , int y1 , int y2 ){
	if( ! u ) return 0;
	if( y1 <= l && r <= y2 ) return D[ u ] . d;
	int mid = l + r >> 1;
	if( y2 <= mid ) return Query_Y( D[ u ] . ls , l , mid , y1 , y2 );
	if( y1 > mid ) return Query_Y( D[ u ] . rs , mid + 1 , r , y1 , y2 );
	return GCD( Query_Y( D[ u ] . ls , l , mid , y1 , y2 ) , Query_Y( D[ u ] . rs , mid + 1 , r , y1 , y2 ) );
}

ll Query_X( int u , int l , int r , int x1 , int y1 , int x2 , int y2 ){
	if( ! u ) return 0;
	if( x1 <= l && r <= x2 ) return Query_Y( T[ u ] . R , 1 , fY , y1 , y2 );
	int mid = l + r >> 1;
 	if( x2 <= mid ) return Query_X( T[ u ] . ls , l , mid , x1 , y1 , x2 , y2 );
 	if( x1 > mid ) return Query_X( T[ u ] . rs , mid + 1 , r , x1 , y1 , x2 , y2 );
	return GCD( Query_X( T[ u ] . ls , l , mid , x1 , y1 , x2 , y2 ) , Query_X( T[ u ] . rs , mid + 1 , r , x1 , y1 , x2 , y2 ) );
}

void Solve(){
	for( int i = 1 ; i <= q ; i ++ ){
		int op = Q[ i ] . op , x1 = Q[ i ] . x1 , y1 = Q[ i ] . y1;
		if( op == 1 ){
			ll k = Q[ i ] . k;
			Modify_X( R , 1 , fX , x1 , y1 , k );
		}
		else{
			int x2 = Q[ i ] . x2 , y2 = Q[ i ] . y2;
			if( x1 > x2 ) swap( x1 , x2 );
			if( y1 > y2 ) swap( y1 , y2 );
			printf( "%lld\n" , Query_X( R , 1 , fX , x1 , y1 , x2 , y2 ) );
		}
	}
}

void Init(){
	sort( X . begin() , X . end() );
	X . erase( unique( X . begin() , X . end() ) , X . end() );
	sort( Y . begin() , Y . end() );
	Y . erase( unique( Y . begin() , Y . end() ) , Y . end() );
	fX = X . size() + 1 , fY = Y . size() + 1;
	for( int i = 1 ; i <= q ; i ++ ){
		Q[ i ] . x1 = lb( X . begin() , X . end() , Q[ i ] . x1 ) - X . begin();
		Q[ i ] . y1 = lb( Y . begin() , Y . end() , Q[ i ] . y1 ) - Y . begin();
		if( Q[ i ] . op == 2 ){
			Q[ i ] . x2 = lb( X . begin() , X . end() , Q[ i ] . x2 ) - X . begin();
			Q[ i ] . y2 = lb( Y . begin() , Y . end() , Q[ i ] . y2 ) - Y . begin(); 
		}
	}		
}

void Input(){
	X . pb( -1 ) , Y . pb( -1 );
	n = I() , m = I() , q = I();
	for( int i = 1 ; i <= q ; i ++ ){
		int op = I() , x1 = I() + 1 , y1 = I() + 1;
		X . pb( x1 ) , Y . pb( y1 );
		if( op == 1 ){
			ll k = I();
			Q[ i ] = { op , x1 , y1 , 0 , 0 , k };
		}
		else{
			int x2 = I() + 1 , y2 = I() + 1;
			Q[ i ] = { op , x1 , y1 , x2 , y2 , 0 };
			X . pb( x2 ) , Y . pb( y2 );
		}
	}
}

int main(){
	Input();
	Init();
	Solve();
	return 0;
}
```


---


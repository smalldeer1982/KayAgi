# [IOI 2012] 理想城

## 题目描述

像许多同龄的科学家和艺术家一样，小 L 对城市规划和城区设计很感兴趣.他致力于构建一个理想城。理想城由 $N$ 个区块组成，而这些区块放在一个无限大的正方形网格上。第 $x$ 行第 $y$ 列的单元格由有序数对 $(x,y)$来标识。单元格 $(0,0)$ 位于网格的左上角。给定一个单元格 $(x,y)$，与之相邻的单元格（如果存在的话）分别为：$(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$。每个区块在网格上恰好覆盖一个单元格。一个区块能够被放置在单元格 $(x,y)$ 上，当且仅当 $1 \le x,y \le 2^{31}-2$ 。我们将使用单元格的坐标同时来代表单元格上面的区块。若两个区块被放在相邻的单元格中，则视它们为相邻区块.理想城所有的区块连在一起，里面没有“洞”存在.换言之，所有单元格必须满足下述两个条件：
- 对于任意两个空白的单元格，至少存在一连串相邻的空白单元格连接它们。
- 对于任意两个非空的单元格，至少存在一连串相邻的非空单元格连接它们。

以下 $4$ 个图中的区块放置均不满足理想城的条件。前两个图不满足第一个条件。第 $3$ 个图不满足第二个条件，第 $4$ 个图两个条件均不满足。

![](https://cdn.luogu.com.cn/upload/image_hosting/uzw8c8c8.png)

当遍历理想城时，一个**跳步**代表**从一个区块走到一个相邻的区块**。跳步时不能移进空白单元格。假设 $v_0,v_1,\cdots,v_{N-1}$ 是 $N$ 个区块的坐标。对于任意两个不同的区块 $v_i$ 和 $v_j$，它们的距离 $d(v_i,v_j)$ 是从 $v_i$ 移动到 $v_j$ 所需的最小跳步数目。

下图是一个由 $11$ 个区块组成的理想城。区块坐标分别为

![](https://cdn.luogu.com.cn/upload/image_hosting/5whsvyjh.png)

$$v_0=(2,5) \quad v_1=(2,6) \quad v_2=(3,3)$$
$$v_3=(3,6) \quad v_4=(4,3) \quad v_5=(4,4)$$
$$v_6=(4,5) \quad v_7=(4,6) \quad v_8=(5,3)$$
$$v_9=(5,4) \quad v_{10}=(5,6)$$


其中，$d(v_1,v_3)=1$，$d(v_1,v_8)=6$，$d(v_6,v_10)=2$，$d(v_9,v_10)=4$。

给定一个理想域，试求
$$S=\sum_{i=0}^{N-2}\sum_{j=i+1}^{N-1}d(v_i,v_j)$$


## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le x_i,y_i \le 2^{31}-2$ 。

## 样例 #1

### 输入

```
11
2 5
2 6
3 3
3 6
4 3
4 4
4 5
4 6
5 3
5 4
5 6
```

### 输出

```
174```

# 题解

## 作者：NDFS (赞：7)

题目大意：无限大的网格上有两种格子，满足所有黄格子四联通，所有白格子四联通，两个黄格子 $x$ 和 $y$ 的距离 $d(x,y)$ 指只走黄格子从 x 到达 y 的最短路径长度，总共 $N$ 个黄格子，求 $\sum_{1≤i<j≤N}d(i,j)$。

分析：首先把图按行剖分，连在一起的格子缩成一个点，上下相邻的点连边，由于本题中图的特殊性质，连边后不会有环，而且是一棵树。在这棵树上 DP，设节点 $i$ 子树大小为 $S_i$，则答案为 $\sum_{i=1}^N S_i(N-S_i)$，因为子树内的所有点与子树外的所有点两两都要走一遍这条边。这样就可以统计出纵向边的贡献。将图翻转 $90^{\circ}$，再做一遍统计横向边贡献。

实现：将 $N$ 个格子以 $x$ 坐标为第一关键字、以 $y$ 坐标为第二关键字排序，合并成块，要记录格子所属块的编号，建树后 DP 即可。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define ll long long
#define t(x,y) (x)*n+y
#define min(a,b) a<b?a:b
#define mod 1000000000
#define M 3200000
using namespace std;
struct node1{int x,y;}v[100005];
struct node2{int x,l,r;}s[M];
bool cmp(node1 a,node1 b){return a.x<b.x||(a.x==b.x&&a.y<b.y);}
int mx=1e9,my=1e9;
int n,h[M],ne[M*2],to[M*2],tot=0,cnt=0;
map<int,int>bz;
ll ans=0,size[M];
void add(int a,int b)
{
	to[++tot]=b,ne[tot]=h[a],h[a]=tot;
	to[++tot]=a,ne[tot]=h[b],h[b]=tot;
}
void dfs(int u,int fa)
{
	size[u]=s[u].r-s[u].l+1;
	for(int i=h[u];i;i=ne[i])
	{
		if(to[i]==fa)continue;
		dfs(to[i],u),size[u]+=size[to[i]];//统计子树大小
	}
	for(int i=h[u];i;i=ne[i])
	{
		if(to[i]==fa)continue;
		ans=(ans+(n-size[to[i]])*size[to[i]]%mod)%mod;//统计贡献
	}
}
void init()
{
	for(int i=1;i<=n;i++)v[i].x-=mx-1,v[i].y-=my-1;//将整个图平移
	sort(v+1,v+1+n,cmp),cnt=1,s[1].x=v[1].x,s[1].l=s[1].r=v[1].y,bz[t(v[1].x,v[1].y)]=1;
	for(int i=2;i<=n;i++)//分块
	{
		if(v[i-1].x==v[i].x&&v[i-1].y+1==v[i].y)
		{
			bz[t(v[i].x,v[i].y)]=cnt,s[cnt].r=v[i].y;
		}
		else s[++cnt].x=v[i].x,s[cnt].l=s[cnt].r=v[i].y,bz[t(v[i].x,v[i].y)]=cnt;
	}
	for(int i=1;i<=cnt;i++)//建树
	{
		for(int j=s[i].l;j<=s[i].r;j++)
		{
			if(bz[t(s[i].x+1,j)])add(i,bz[t(s[i].x+1,j)]),j=s[bz[t(s[i].x+1,j)]].r;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&v[i].x,&v[i].y),mx=min(mx,v[i].x),my=min(my,v[i].y);
	init();
	dfs(1,0);
	bz.clear(),tot=0,cnt=0,memset(h,0,sizeof(h)),memset(size,0,sizeof(size));
	for(int i=1;i<=n;i++)v[i].x+=mx-1,v[i].y+=my-1,swap(v[i].x,v[i].y);
	swap(mx,my);
	init();
	dfs(1,0);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：dAniel_lele (赞：4)

考虑把贡献拆开，计算两个位置横向走的步数和纵向走的步数分别是多少。

考虑这样有什么好处，对于 $(i,j),(i+1,j),(i,j+1),(i+1,j+1)$ 都是区块，计算横向走的步数时，我们可以断掉 $(i,j)$ 和 $(i,j+1)$ 之间的边，这样计算出来的答案是一样的。

这样断边以后，我们发现原图变为了树。于是我们只需要对于每个横向边记录左右两边的子树大小，乘积求和即可。

总复杂度 $O(N\log N)$，加边要用 map 维护一下。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9;
int x[100005],y[100005],siz[100005],ans,n;
map<pair<int,int>,int> mp; 
vector<pair<int,int>> vc[100005];
void dfs(int now,int fa){
	siz[now]=1;
	for(auto v:vc[now]){
		if(v.first==fa) continue;
		dfs(v.first,now);
		(ans+=siz[v.first]*(n-siz[v.first])*v.second)%=mod;
		siz[now]+=siz[v.first];
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
	}
	for(int j=0;j<=1;j++){
		mp.clear();
		for(int i=1;i<=n;i++) vc[i].clear();
		for(int i=1;i<=n;i++){
			swap(x[i],y[i]);
			mp[make_pair(x[i],y[i])]=i; 
		}
		for(int i=1;i<=n;i++){
			int v=mp[make_pair(x[i]+1,y[i])];
			if(v){
				vc[v].push_back(make_pair(i,0));
				vc[i].push_back(make_pair(v,0));
			}
			v=mp[make_pair(x[i],y[i]+1)];
			if(v){
				if(!(mp[make_pair(x[i]-1,y[i])]&&mp[make_pair(x[i]-1,y[i]+1)])){
					vc[v].push_back(make_pair(i,1));
					vc[i].push_back(make_pair(v,1));
				}
			}
		}
		dfs(1,0);
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：_maojun_ (赞：2)

一种不用建边的实现方式。

---

首先考虑两点之间的距离是什么，就是最短路径上经过的边数。

如果只考虑横边或竖边，因为白黄都四联通，所以同行/列缩点后连出来是一棵树。那么问题就变成两次树上路径长度和。

不妨考虑横边怎么做（竖边可以把图形按对角线翻转后当横边算）。

先按 $x$ 第一关键字，$y$ 第二关键字排序，然后随便钦定一个根。

设 $x_u$ 表示以 $u$ 节点的纵坐标，$[l_u,r_u]$ 表示 $u$ 节点的横坐标**范围**。（~~可能横纵坐标有点混乱，但其实反之亦然~~）

现在对于这一段极长的连续黄色节点，它的儿子是的纵坐标为 $x_u\pm1$，横坐标在 $[l_u,r_u]$ 的范围内。

那么再整一个 vector 记录每个纵坐标上的点，且横坐标递增。那么在 $[l_u,r_u]$ 范围的点就是 `lower_bound(l)` 到 `upper_bound(r)-1`。

然后得到 $siz_u$，最后答案就是 $\sum siz_u\times(n-siz_u)$。

顺嘴一提，$x_i,y_i$ 的极差不会超过 $n-1$，否则无法联通。所以给坐标减去最小值后就可以当范围是 $0\le x_i,y_i\le n-2$。

---

这种实现方式好像常数会小一点，开 O2 之后一发到次优，加一个快读就到最优解了。~~不过应该很快会被打下去。~~


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<vector>
#define pi pair<int,int>
#define fi first
#define se second
#define mp make_pair
#define pb emplace_back
#define lb(arr,val) lower_bound(arr.begin(),arr.end(),val)
#define ub(arr,val) upper_bound(arr.begin(),arr.end(),val)
#define mem(arr,val) memset(arr,val,sizeof arr)
using namespace std;

typedef long long ll;
inline void chkmin(int&x,int y){(x>y)&&(x=y);}
const int MAXN=1e5+5,MOD=1e9,INF=0x3f3f3f3f;
int n;pi a[MAXN];
vector<pi>G[MAXN];
typedef vector<pi>::iterator IT;

ll sum=0,siz[MAXN];bool vis[MAXN];
void dfs(int u){
	vis[u]=true;
	int x=a[u].fi,l=u,r=u;					// 极长连续的黄色段左右端点
	while(l-1>=1&&a[l-1].fi==a[l].fi&&a[l-1].se==a[l].se-1)vis[--l]=true;
	while(r+1<=n&&a[r+1].fi==a[r].fi&&a[r+1].se==a[r].se+1)vis[++r]=true;
	siz[u]=r-l+1;
	pi L=mp(a[l].se,0),R=mp(a[r].se,INF);	// 因为 first（横坐标）相同时允许取到，所以 L.se=0,R.se=inf
	if(!G[x-1].empty())for(IT st=lb(G[x-1],L),ed=ub(G[x-1],R);st!=ed;st++)
		{int v=st->se;if(!vis[v]){dfs(v);siz[u]+=siz[v];}}
	if(!G[x+1].empty())for(IT st=lb(G[x+1],L),ed=ub(G[x+1],R);st!=ed;st++)
		{int v=st->se;if(!vis[v]){dfs(v);siz[u]+=siz[v];}}	// 注意 st,ed 算出来是左闭右开的
	sum=(sum+siz[u]*(n-siz[u]))%MOD;		// 统计答案
}
int main(){
	scanf("%d",&n);
	int minx=INF,miny=INF;
	for(int i=1;i<=n;i++){scanf("%d%d",&a[i].fi,&a[i].se);chkmin(minx,a[i].fi);chkmin(miny,a[i].se);}
	for(int i=1;i<=n;i++){a[i].fi-=minx;a[i].se-=miny;}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)G[a[i].fi].pb(mp(a[i].se,i));
	dfs(1);
	for(int i=1;i<=n;i++){G[a[i].fi].clear();swap(a[i].fi,a[i].se);}	// 按坐上到右下的对角线翻转
	sort(a+1,a+n+1);mem(vis,false);
	for(int i=1;i<=n;i++)G[a[i].fi].pb(mp(a[i].se,i));
	dfs(1);
	printf("%lld\n",sum);
	return 0;
}
```

---

## 作者：the_Short_Path (赞：0)

## 形式化题意
给定一个平面直角坐标系，其中有若干个点，你只能在这些点之间移动，求任意两个点之间距离的和取模 $10^9$ 的结果。
## 思路
首先可能会想到搜索，但是枚举起点会超时，时间复杂度为 $O(n^3)$，尽管还能优化到 $O(n^2)$。~~那么就要想点不一样的。~~

如果把横坐标相同的点视为一个“横条”，把每个相邻的“横条”连边，那么你就得到了一棵树，在这棵树上进行树形 dp 即可，时间复杂度 $O(n\log n)$。
# 正解
```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int,int>
using namespace std;
const int mod = 1e9; // 注意奇怪的模数（没有 + 7）
int n, ans, x[100005], y[100005], dp[100005];
map <pii, int> mp; // 用 map 维护边
vector <pii> G[100005];
void dfs(int u, int fa) {
    dp[u] = 1;
    for (auto [v, id] : G[u]) {
        if (v != fa) {
            dfs(v, u);
            ans = (ans + dp[v] * (n - dp[v]) % mod * id % mod) % mod; // 答案统计
            dp[u] = (dp[u] + dp[v]) % mod; // 树形 dp
        }
    }
}
signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];
    for (int j = 0; j <= 1; j++) {
        mp.clear();
        for (int i = 1; i <= n; i++) G[i].clear();
        for (int i = 1; i <= n; i++) swap(x[i], y[i]), mp[{x[i], y[i]}] = i; // 调换横纵坐标
        for (int i = 1; i <= n; i++) {
            int a = mp[{x[i] + 1, y[i]}];
            if (a) G[a].push_back({i, 0}), G[i].push_back({a, 0}); // 不更新答案的连边
            a = mp[{x[i], y[i] + 1}];
            if (a && !(mp[{x[i] - 1, y[i]}] && mp[{x[i] - 1, y[i] + 1}])) G[a].push_back({i, 1}), G[i].push_back({a, 1}); // 更新答案的连边
        }
        dfs(1, -1);
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：GeXiaoWei (赞：0)

# P6137 [IOI 2012] 理想城
## 解析
通过读题，我们会发现这两句话：对于**任意两个**空白的单元格，至少存在一连串**相邻的空白单元格**连接它们；对于**任意两个**非空的单元格，至少存在一连串**相邻的非空单元格**连接它们。

那么它想告诉我们什么呢？

如果我们把理想城上的每一个点分别表示为一张图上的每一个点，并将同一行连在一起的格子缩成一个点，上下相邻的点连边，那么你就会发现：这张图不仅是**无向的连通图**，而且正好还是**树**！

为什么呢？就是因为题目中的这两句话。

### 详细证明

该图连通很好证，因为**对于任意两个非空的单元格，至少存在一连串相邻的非空单元格连接它们**，所以它就是连同图。

该图是无向图则是因为我们构造此图时需将它建为无向图，这在后面一个操作有极大用处，到时便说。

假如这张图上有环，那么构造出这个环的原图（理想城上对应的方块）一定也是环状，即周围一圈黄格子，围着几个白格子，但题目说了，**对于任意两个空白的单元格，至少存在一连串相邻的空白单元格连接它们**，而此时那一圈黄格子内的白格子无法与圈外其他的白格子连接，所以此图**无环**。

综上三点，我们便可证明，这是树（**证明到此结束，后文是题目解析**）。

读题，我们可发现，题目让我们求：

$\begin{aligned}
S=\sum_{i=0}^{N-2}\sum_{j=i+1}^{N-1}d(v_i,v_j)
\end{aligned}$

假如我们直接枚举 $i$ 和 $j$ 暴力硬算，必然时间超限。这时，我们便可以采用**统计贡献**的方法。

什么是统计贡献呢？就是统计每个数对最终结果的影响。

这个题我们便可以对边（缩完点的图）统计贡献，即看此时两点之间所连的这条边被走过几次。

设缩完点后，点 $i$ 所在的子树上的每一个点在缩点前的点的个数的总和为 $Size_i$，那么我们便可得出：

$\begin{aligned}
S=\sum_{i=1}^{N}Size_i(N-Size_i)
\end{aligned}$

为什么呢？因为子树内的所有点与子树外的所有点两两都要走一遍这条边。子树内有 $Size_i$ 个节点，外有 $(N-Size_i)$ 个，乘上即可。

但此时调试一下会发现**答案错误**。

为什么呢？因为我们只统计了**竖向边**，**横向边**未统计，所以需要再将同一列连在一起的格子缩成一个点，左右相邻的点连边，缩成树后重新求 $Size_i$，求出横向边后将其答案与竖向边的相加即可。

注意缩点时判断有无重边，不判会超时。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<long long,long long>
using namespace std;
const int mod=1e9;
int n,scc[100005],size[100005],belong[100005];
int cnt=1,head[100005];
int ANS;
map< pii,bool>mp;
struct node2{
	int to,nxt;
}edge[200005];
struct node{
	int x,y,id;
}a[100005],b[100005];
void add(int u,int v){//建边
	edge[cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt++;
}
bool cmp(node aaa,node bbb){
	if(aaa.x==bbb.x) return aaa.y<bbb.y;
	return aaa.x<bbb.x;
}bool cmp2(node aaa,node bbb){
	if(aaa.y==bbb.y) return aaa.x<bbb.x;
	return aaa.y<bbb.y;
}bool cmp3(node aaa,node bbb){
	if(aaa.x==bbb.x) return aaa.y<bbb.y;
	return aaa.x>bbb.x;
}
int dfs(int u,int fa){
	size[u]=scc[u];
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa) continue;
		size[u]+=dfs(v,u);
	}return size[u];
}void init(){//初始化
	cnt=1,mp.clear();
	memset(scc,0,sizeof(scc));
	memset(belong,0,sizeof(belong));
	memset(size,0,sizeof(size));
	for(int i=1;i<=n;i++){
		for(int j=head[i];j;j=edge[j].nxt) edge[j].to=0;
		head[i]=0;
	}
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&a[i].x,&a[i].y);
		b[i].x=a[i].x,b[i].y=a[i].y,b[i].id=a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);sort(b+1,b+n+1,cmp2);
	int cntt=0;
	for(int i=1;i<=n;i++){
		if(a[i].x==a[i-1].x&&a[i].y-a[i-1].y==1) scc[cntt]++;
		else scc[++cntt]=1;
		belong[a[i].id]=cntt;
	}
	for(int i=1;i<=n;i++){
		int xx=belong[b[i].id],yy=belong[b[i-1].id];
		pii z1=make_pair(xx,yy),z2=make_pair(yy,xx);
		if(b[i].y==b[i-1].y&&b[i].x-b[i-1].x==1&&!mp[z1]&&!mp[z2]){
			add(xx,yy),add(yy,xx);//建边，注意是双向
			mp[z1]=mp[z2]=1;//重边打标记
		}
	}
	dfs(belong[1],0);
	for(int i=1;i<=cnt;i++) ANS=(ANS+size[i]*(n-size[i])%mod+mod)%mod;
	cntt=0;
	init();
	sort(a+1,a+n+1,cmp2);sort(b+1,b+n+1,cmp3);
	for(int i=1;i<=n;i++){
		if(a[i].y==a[i-1].y&&a[i].x-a[i-1].x==1) scc[cntt]++;
		else scc[++cntt]=1;
		belong[a[i].id]=cntt;
	}
	for(int i=1;i<=n;i++){
		int xx=belong[b[i].id],yy=belong[b[i-1].id];
		pii z1=make_pair(xx,yy),z2=make_pair(yy,xx);
		if(b[i].x==b[i-1].x&&b[i].y-b[i-1].y==1&&!mp[z1]&&!mp[z2]){
			add(xx,yy),add(yy,xx);
			mp[z1]=mp[z2]=1;
		}
	}
	dfs(belong[1],0);
	for(int i=1;i<=cnt;i++) ANS=(ANS+size[i]*(n-size[i])%mod+mod)%mod;
	printf("%lld",ANS%mod);
	return 0;
}
```

---

## 作者：冷却心 (赞：0)

神仙题。

这里我最初考虑的是把整块的方格缩成一个点，然后发现假了。

我们注意到一个优美的性质：**对于同一行上连在一块的点，我们能发现他们到任意一个点在列上移动的步数都是相同的。**

所以我们先统计列上的贡献，我们考虑把同一行连在一块的点缩成一个，然后纵向相邻的连边，会发现这样是一颗树。我们考虑连接的这条边会造成多少贡献：只有这条边两边的点的距离会经过造成贡献。所以考虑一个 dfs 求出子树大小 $sz_u$，然后一个点到其父亲这条边的贡献即为：$sz_u\times(n-sz_u)$。然后求和即可。

*子树大小指的是原图上整块点的大小，而不是缩点后的一个点。*

然后对列上的贡献我们直接行列交换一下跑一遍即可。

这里建图部分使用了大量 STL。我是 STL 高手。注意值域比较大，但是因为连通所以考虑整个图平移，然后值域就是 $O(n)$ 的了。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e5 + 10;
const LL MOD = 1e9;
int n, X[N], Y[N], tot, sz[N]; LL Ans = 0;
vector<int> G[N], bel[N]; set<int> F[N]; vector<pair<int, int> > G1[N];
int ssz[N];
void DFS(int u, int f) {
	ssz[u] = sz[u];
	for (int v : F[u]) if (v != f) {
		DFS(v, u); ssz[u] += ssz[v];
	} Ans = (Ans + 1ll * ssz[u] * (n - ssz[u])) % MOD; return ;
} // 统计 size 和答案。
void Solve() {
	for (int i = 1; i <= n; i ++) G[i].clear(), bel[i].clear(), F[i].clear(), G1[i].clear();
	for (int i = 1; i <= n; i ++) G[X[i]].emplace_back(Y[i]);
	for (int i = 1; i <= n; i ++) sort(G[i].begin(), G[i].end());
	tot = 0;
	for (int i = 1; i <= n; i ++) if (G[i].size()) {
		int lst = 0;
		for (int j = 1; j < (int)G[i].size(); j ++) {
			if (G[i][j] != G[i][j - 1] + 1) {
				sz[++ tot] = j - lst; 
				while (lst < j) ++ lst, bel[i].emplace_back(tot);
			}
		} sz[++ tot] = (int)G[i].size() - lst;
		while (lst < (int)G[i].size()) ++ lst, bel[i].emplace_back(tot);
	} // 缩点。
	for (int i = 1; i <= n; i ++) for (int j = 0; j < (int)G[i].size(); j ++)
		G1[G[i][j]].emplace_back(make_pair(bel[i][j], i));
	for (int i = 1; i <= n; i ++) for (int j = 0; j < (int)G1[i].size() - 1; j ++) {
		if (G1[i][j].second + 1 == G1[i][j + 1].second) {
			int a = G1[i][j].first, b = G1[i][j + 1].first;
			F[a].insert(b); F[b].insert(a); // 连边。
		}
	} DFS(1, 0);
	return ;
}

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n; for (int i = 1; i <= n; i ++) cin >> X[i] >> Y[i];
	int mnx = X[1], mny = Y[1];
	for (int i = 2; i <= n; i ++) mnx = min(mnx, X[i]), mny = min(mny, Y[i]);
	for (int i = 1; i <= n; i ++) X[i] -= mnx - 1, Y[i] -= mny - 1;
	Solve();
	for (int i = 1; i <= n; i ++) swap(X[i], Y[i]);
	Solve();
	cout << Ans << "\n";
	return 0;
}
```

---


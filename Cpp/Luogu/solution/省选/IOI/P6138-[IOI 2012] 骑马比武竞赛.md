# [IOI 2012] 骑马比武竞赛

## 题目描述

1491 年公爵 Milan Lodovico Sforza 为了他与 Beatrice d'Este 的婚礼，要求Leonardo 来负责筹备婚礼的庆典。在这个庆典中包含了一个盛大的持续三天的骑马比武竞赛，但是最受欢迎的骑士迟到了...

在一骑马比武的竞赛，$N$ 个骑士一开始被排成一排然后按照他们的位置从 $0$ 到 $N-1$ 开始编号。骑马比武的主持人每一回合叫出两个位置 $S$ 跟 $E$ （其中 $0 \le S < E \le N - 1$）。所有介于 $S$ 与 $E$ （含） 这两个位置的骑士则开始进行骑马比武。最后的赢家可以留下来继续进行竞赛， 并回到他原来的位置，而输家则离开这个竞赛。在这之后，剩下的骑士按照原来排列的顺 序，往前挤掉空出来的位置。所以他们的位置编号变成从 $0$ 到 $N - (E - S) - 1$。骑马比武竞赛的主持人接着进行下一个回合的比赛，直到最后剩下唯一个骑士。

Leonardo 知道所有骑士有不同的强度，这个强度从 $0$ (最弱) 到 $N-1$ (最强)。他也知道骑马比武竞赛的主持人会下怎么样的命令来进行C回合的竞赛，毕竟他是无所不能的   Leonardo。而且他也确定在每一个回合中，拥有最大强度的骑士会获得胜利。

$N$ 个骑士中的 $N-1$ 个骑士已经排成了一排，只是最受欢迎的骑士还未出现。这个骑士的强度为 $R$ 但是他迟到了。为了让这场竞赛达到最高潮, Leonardo  想要让这个骑士能好好展现他的风采，所以想要帮他安插一个位置，而这个位置可以使得这个骑士能获得最多回合的 胜利。请注意，我们不关心与此骑士无关的回合。我们只关心包含此骑士而且由他赢得胜利的回合。

**例子**

假设有 $5$ 个骑士，其中 $4$ 个骑士已经排列好，而他们的强度分别是 $[1,0,2,4]$。而迟到骑士的强度为 $3$ 。假设要进行 $3$ 回合，骑马比武的主持人打算要叫出的位置 $(S,E)$ 分别是 $(1, 3)$，$(0, 1)$，$(0, 1)$。

假设 Leonardo  将迟到的骑士插到第一个位置而且迟到的骑士强度为 $3$。那么骑士强度的排列将会是 $[3, 1, 0, 2, 4]$。第一回合参与的骑士为位置 $1,2,3$ 的骑士，他们的强度分别是 $1,0,2$，所以由强度 $2$ 的骑士获得胜利。经过这一回合，新的骑士强度的排列变成 $[3, 2, 4]]$。下一个回合是由强度 $3$ 与强度 $2$（位置 $0,1$）的骑士进行比赛，由强度 $3$ 的骑士获得胜利。而骑士强度的排列则变成 $[3,4]$。最后一回合（位置 $0,1$）由强度 $4$ 的骑士获得胜利。那么，迟到的骑士只有获得一回合的胜利 (第二回合)。

若 Leonardo 将迟到的骑士插入强度 $1$ 与强度 $0$ 的骑士中间，骑士强度的排列将会是 $[1,3,0,2,4]$。这一次,  第一回合比赛的骑士强度为 $3,0,2$。由强度 $3$ 的骑士获胜，然后骑士强度的排列变成 $[1,3,4]$。在第二回合中由强度 $1$ 对上强度 $3$ 的骑士，由强度 $3$ 的骑士获胜。最后的一回合，骑士强度的排列变成  $[3,4]$，由强度 $4$ 的骑士获得胜利。在这个排列中，迟到的骑士获得两回合的胜利。这实际上是最佳的位置，因为没有其他的位置可以让迟到的骑士获得两回合以上的胜利。

你的任务是写一个程序来帮迟到的骑士选择最佳的位置让他能获得最多的胜利回合数，以符合 Leonardo 的期待。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le C \le N-1$，在第 $i+1$ 回合，$E[i]$ 会小于这个回合剩下的骑士数量。经过 $C$ 回合的命令之后，只会剩下一个骑士。

## 样例 #1

### 输入

```
5 3 3
1 0 2 4
1 3
0 1
0 1
```

### 输出

```
1
```

# 题解

## 作者：ppip (赞：2)

[题目传送门](/problem/P6138)

$O(n\log\log n)$ 做法。要求 practical 的话用平衡树代替 vEB 可以 $O(n\log n)$。

第一步，我们把每场比赛转化成“可能赢的所有人的范围”，显然这是一个区间。

要求出这个区间，我们其实只需要用一个数据结构维护序列，每次来一场比赛的时候查询第 $l$ 个数，然后从它开始删除 $r-l$ 个数（留一个作为胜利者）就行了。这个可以用多种数据结构维护，这里为了复杂度最优使用 vEB。

接下来考虑这样一个结论：一个骑士如果输了某一场比赛，此时我们强行让它晋级继续打（不占用），它也不可能赢。所以我们求一场比赛能不能赢，可以把区间内的所有人都拉出来比。

同时，容易发现，如果迟到参加了某场比赛，那么这场比赛原来的最后一个一定被挤掉。所以我们可以枚举比赛，判断迟到能不能赢，能赢就给比赛对应区间加一，最后对每个点的值取 max 就行了。

判断每场比赛迟到能不能赢，这个可以将能力值序列转化为一个 $01$ 序列，$0$ 表示这个数小于迟到的数，$1$ 反之。对这个序列做一次前缀和，然后判断这个区间（去尾的）是否和为 $0$ 就行了。时空 $O(n)$。

以下是树状数组（代替平衡树）实现前半部分的代码（by @GlaceonVGC）。

```cpp
#include <bits/stdc++.h> 
using namespace std;

int n, c, x, N, a, s[100001], l, r, v[100001], p, C[100001];
void mod(int p) {
	while (p < n) {
		C[p]--;
		p += p & -p;
	}
}
int ask(int p) {
	int res = 0, sum = 0;
	for (int i = N; i >= 0; i--) {
		if (res + (1 << i) < n && C[res + (1 << i)] + sum < p) {
			res += (1 << i);
			sum += C[res];
		}
	}
	return res + 1;
}
int main() {
	scanf("%d%d%d", &n, &c, &x);
	N = 32 - __builtin_clz(n);
	for (int i = 1; i < n; i++) {
		scanf("%d", &a);
		s[i] = s[i - 1] + (a > x);
		C[i] = i & -i;
	}
	while (c--) {
		scanf("%d%d", &l, &r);
		int L = l ? ask(l) : 0, R = ask(r + 1) - 1;
		for (int i = l + 1; i <= r; i++) {
			mod(ask(l + 1));
		}
		if (s[L] == s[R]) {
			v[L]++;
			v[R + 1]--;
		}
	}
	for (int i = 1; i <= n; i++) {
		v[i] += v[i - 1];
		if (v[i] > v[p]) {
			p = i;
		}
	}
	printf("%d\n", p);
}
```

---

## 作者：happybob (赞：1)

提供一个无脑做法。

考虑操作的本质是让区间最大值替代整个区间，于是我们要维护序列删掉一个区间，还要维护单点插入。这玩意可以用平衡树做，但是难以拓展到每个点求答案上。

不妨这样：对于每次操作 $[l,r]$，我们都找到 $[l,r]$ 对应的**原序列**的区间 $[l',r']$，这个可以用平衡树模拟操作维护。此时，一个人 $i$ 获胜需要满足 $i \in [l',r']$ 且 $i$ 为区间最大值。

我们不妨枚举新的人在哪，二分两边第一个大于这个数的位置，那么问题就转成了一个二维数点问题，由于我比较无脑，所以直接上了 K-D Tree，复杂度 $O(n \sqrt{n})$。

```cpp
#include <bits/stdc++.h>
#include<ext/rope>
using namespace __gnu_cxx;
using namespace std;
//#define int long long

const int N = 1e5 + 5, MOD = 1e9 + 7, HSMOD = 1610612741, HSMOD2 = 998244353; // Remember to change

long long qpow(long long a, long long b)
{
	long long res = 1ll, base = a;
	while (b)
	{
		if (b & 1ll) res = res * base % MOD;
		base = base * base % MOD;
		b >>= 1ll;
	}
	return res;
}

namespace FastIo
{
	#define QUICKCIN ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
	int read()
	{
		char ch = getchar();
		int x = 0, f = 1;
		while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();
		while (ch == '-')
		{
			f = -f;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9')
		{
			x = (x << 1) + (x << 3) + (ch ^ 48);
			ch = getchar();
		}
		return x * f;
	}
	template<class T>
	void write(T x)
	{
		if (x < 0)
		{
			putchar('-');
			x = -x;
		}
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
	template<class T>
	void writeln(T x)
	{
		write(x);
		putchar('\n');
	}
}

template<typename T>
class Bit
{
public:
	T lowbit(T x)
	{
		return x & -x;
	}
	T tr[N];
	void add(T x, T y)
	{
		while (x < N)
		{
			tr[x] += y;
			x += lowbit(x);
		}
	}
	T query(T x)
	{
		T sum = 0;
		while (x)
		{
			sum += tr[x];
			x -= lowbit(x);
		}
		return sum;
	}
};

int n, c, r, a[N], s[N], e[N], ns[N], ne[N];

struct Node
{
	int l, r;
	Node() = default;
	Node(int l, int r): l(l), r(r){}
}; 

rope<Node> f;
int nl[N], nr[N];
int ra[N];

int LG2[N];

struct Nd
{
	int x[2];
}ee[N];

class ST
{
public:
	int f[N][21];
	void Init()
	{
		for (int i = 1; i < n; i++)
		{
			f[i][0] = a[i - 1];
		}
		for (int j = 1; j <= LG2[n - 1]; j++)
		{
			for (int i = 1; i + (1 << j) - 1 <= n - 1; i++)
			{
				f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
			}
		}
	}
	int query(int l, int r)
	{
		int p = LG2[r - l + 1];
		return max(f[l][p], f[r - (1 << p) + 1][p]);
	}	
}st;

class KD_Tree
{
public:
	struct Node
	{
		int lson, rson, x[2];
		int minn[2], maxn[2], sum;
		Node()
		{
			minn[0] = minn[1] = (int)1e9;
			maxn[0] = maxn[1] = -1;
		}
	}tr[N];
	int idx;
	void pushup(int u)
	{
		tr[u].sum = tr[tr[u].lson].sum + tr[tr[u].rson].sum + 1;
		tr[u].minn[0] = min({tr[tr[u].lson].minn[0], tr[tr[u].rson].minn[0], tr[u].x[0]});
		tr[u].minn[1] = min({tr[tr[u].lson].minn[1], tr[tr[u].rson].minn[1], tr[u].x[1]});
		tr[u].maxn[0] = max({tr[tr[u].lson].maxn[0], tr[tr[u].rson].maxn[0], tr[u].x[0]});
		tr[u].maxn[1] = max({tr[tr[u].lson].maxn[1], tr[tr[u].rson].maxn[1], tr[u].x[1]});
	}
	int build(int l, int r, int g)
	{
		int u = ++idx;
		int mid = l + r >> 1;
		nth_element(ee + l, ee + mid, ee + r + 1, [&](const auto& x, const auto& y){return x.x[g] < y.x[g];});
		tr[u].x[0] = ee[mid].x[0], tr[u].x[1] = ee[mid].x[1];
		if (l == r)
		{
			pushup(u);
			return u;
		}
		if (l < mid) tr[u].lson = build(l, mid - 1, g ^ 1);
		if (r > mid) tr[u].rson = build(mid + 1, r, g ^ 1);
		pushup(u);
		return u;
	}
	int query(int u, int X1, int X2, int Y1, int Y2)
	{
		if (!u) return 0;
		if (tr[u].minn[0] >= X1 && tr[u].minn[0] <= X2 && tr[u].maxn[0] >= X1 && tr[u].maxn[0] <= X2 && tr[u].minn[1] >= Y1 && tr[u].minn[1] <= Y2 && tr[u].maxn[1] >= Y1 && tr[u].maxn[1] <= Y2) return tr[u].sum;
		if (tr[u].minn[0] > X2 || tr[u].maxn[0] < X1 || tr[u].minn[1] > Y2 || tr[u].maxn[1] < Y1) return 0;
		int res = (tr[u].x[0] >= X1 && tr[u].x[0] <= X2 && tr[u].x[1] >= Y1 && tr[u].x[1] <= Y2);
		res += query(tr[u].lson, X1, X2, Y1, Y2);
		res += query(tr[u].rson, X1, X2, Y1, Y2);
		return res;
	}
}kdt;

int main()
{
	ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> c >> r;
	for (int i = 2; i < N; i++) LG2[i] = LG2[i >> 1] + 1;
	for (int i = 0; i < n; i++)
	{
		nl[i] = nr[i] = i;
		f.push_back(Node(i, i));
	}
	for (int i = 0; i < n - 1; i++) 
	{
		cin >> a[i];
	}
	st.Init();
	for (int i = 1; i <= c; i++)
	{
		cin >> s[i] >> e[i];
		ns[i] = f[s[i]].l, ne[i] = f[e[i]].r;
		f.erase(s[i], e[i] - s[i] + 1);
		f.insert(s[i], Node(ns[i], ne[i]));
		ee[i].x[0] = ns[i], ee[i].x[1] = ne[i];
	//	cout << "!!!: " << ns[i] << " " << ne[i] << "\n";
	}
	kdt.build(1, c, 0);
//	cout << "????: " << kdt.query(1, 0, 1, 1, 2) << "\n";
	int ans = -1, pos = 0;
	for (int i = -1; i < n - 1; i++)
	{
		int nl = -1, nr = -1;
		// find nl
		/*
		for (int j = i; j >= 0; j--)
		{
			if (a[j] > r)
			{
				nl = j + 1;
				break;
			}
		}
		for (int j = i + 1; j < n - 1; j++)
		{
			if (a[j] > r) 
			{
				nr = j;
				break;
			}
		}*/
		int L = 0, R = i;
		while (L <= R)
		{
			int mid = (L + R) >> 1;
			if (st.query(mid + 1, i + 1) < r)
			{
				R = mid - 1;
				nl = mid;
			}
			else L = mid + 1;
		}
		if (nl == -1) nl = i + 1;
		// find nr
		L = i + 1, R = n - 2;
		while (L <= R)
		{
			int mid = (L + R) >> 1;
			if (st.query(i + 2, mid + 1) < r)
			{
				nr = mid + 1;
				L = mid + 1;
			}
			else R = mid - 1;
		}
		if (nr == -1) nr = i + 1;
		int X1 = nl, X2 = min(nr, i + 1), Y1 = max(nl, i + 1), Y2 = nr;
		int cnt = kdt.query(1, X1, X2, Y1, Y2);
		//cout << "!!!!!: " << X1 <<" " << X2 << " " << Y1 << " " << Y2 << " " << cnt << "\n";
		if (cnt > ans)
		{
			ans = cnt;
			pos = i;
		}
	}
	cout << pos + 1 << "\n";
	return 0;
}
```


---

## 作者：forgotmyhandle (赞：0)

[洛谷传送门](https://www.luogu.com.cn/problem/solution/P6138)

提供一个巨大难写做法。
## 分析
首先可以将骑士比赛这件事视为将一段区间缩为一个点。那么最后剩下的一段区间中每个点一定是有一个区间浓缩而来。展开这个区间，展开后的区间中的每个点也是由一个区间浓缩而来。这样逐步展开，会得到原本的有 $n$ 个元素的数组。注意，虽然迟到的还没有加入，但是各区间的包含情况是不变的。所以我们将区间的包含情况建成一棵树，且称为区间树。

接下来我们考虑一个骑士什么时候会输。显然，将这个骑士代表的叶子不断往上跳，第一次跳到一个含有比他大的能力值的区间时，他就输了。为了求出迟到的放在每个位置能赢几场，我们可以对区间树进行 dfs，同时维护一个栈，栈中存当前点的所有祖先。走到叶子，就代表我们要把迟到的放在这个叶子对应的位置。那接下来就要求他往上跳多少会挂掉。

由于我们已经维护了一个存当前点所有祖先的栈，我们就可以在栈里面二分，二分出他输掉的位置。为此，我们还需要对输入的 $n - 1$ 个元素的数组建 ST 表，以支持查区间最值。注意，由于原本的数组中并没有迟到的，所以此时查的区间会发生变化，具体细节可以看代码。

最后还剩下建区间树。发现题目实际上要支持一个区间删除，单点查值。使用平衡树维护即可。连边可以暴力。

总复杂度一个 $\log$。

## 代码
```cpp
#include <iostream>
#include <random>
#define lowbit(x) ((x) & -(x))
using namespace std;
mt19937 mtrand(3225 * 2532 + 21060621);
int n, c, X;
int L[300005], R[300005];
int head[300005], nxt[600005], to[600005], ecnt;
void add(int u, int v) { to[++ecnt] = v, nxt[ecnt] = head[u], head[u] = ecnt; }
int rt;
struct node {
    int l, r, sz, val;
    unsigned int prio;
} T[300005];
int tn[300005], tncnt;
int ncnt;
int New(int val) {
    T[++ncnt] = (node) { 0, 0, 1, val, mtrand() };
    return ncnt;
}
void pushup(int x) { T[x].sz = T[T[x].l].sz + T[T[x].r].sz + 1; }
void Split(int x, int& l, int& r, int k) {
    if (!x) 
        return l = r = 0, void();
    if (k >= T[T[x].l].sz + 1) {
        l = x;
        Split(T[x].r, T[l].r, r, k - T[T[x].l].sz - 1);
    } else {
        r = x;
        Split(T[x].l, l, T[r].l, k);
    }
    pushup(x);
}
int Merge(int x, int y) {
    if (!x || !y) 
        return x | y;
    if (T[x].prio > T[y].prio) {
        T[y].l = Merge(x, T[y].l);
        pushup(y);
        return y;
    } else {
        T[x].r = Merge(T[x].r, y);
        pushup(x);
        return x;
    }
}
int Kth(int x, int k) {
    if (k <= T[T[x].l].sz) 
        return Kth(T[x].l, k);
    else if (k > T[T[x].l].sz + 1) 
        return Kth(T[x].r, k - 1 - T[T[x].l].sz);
    return T[x].val;
}
void Adde(int x, int f) {
    add(f, tn[T[x].val]);
    if (T[x].l) 
        Adde(T[x].l, f);
    if (T[x].r) 
        Adde(T[x].r, f);
}
int mx[24][100005];
int lg2[300005];
int Query(int l, int r) {
    int k = lg2[r - l + 1];
    return max(mx[k][l], mx[k][r - (1 << k) + 1]);
}
int stk[300005], sz;
int ans = -1, pos = 2147483647;
bool chk(int x, int p) {
    x = stk[x];
    int l = L[x], r = R[x];
        --r;
    return Query(l, r) < X;
}
void dfs(int x) {
    if (!head[x]) {
        int l = 1, r = sz, mid, ans = sz + 1;
        while (l <= r) {
            mid = (l + r) >> 1;
            if (chk(mid, x)) 
                ans = mid, r = mid - 1;
            else 
                l = mid + 1;
        }
        ans = sz - ans + 1;
        if (ans > ::ans) 
            ::ans = ans, pos = x;
        if (ans == ::ans) 
            pos = min(pos, x);
        return;
    }
    stk[++sz] = x;
    for (int i = head[x]; i; i = nxt[i]) {
        int v = to[i];
        dfs(v);
    }
    --sz;
}
void dfs1(int x) {
    if (T[x].l) 
        dfs1(T[x].l);
    dfs(tn[T[x].val]);
    if (T[x].r) 
        dfs1(T[x].r);
}
int main() {
    cin >> n >> c >> X;
    for (int i = 1; i < n; i++) cin >> mx[0][i];
    lg2[0] = -1;
    for (int i = 1; i <= n; i++) rt = Merge(rt, New(tn[i] = i)), lg2[i] = lg2[i - 1] + (lowbit(i) == i), L[i] = R[i] = i;
    tncnt = n;
    while (c--) {
        int l, r;
        cin >> l >> r;
        ++l, ++r;
        int tl = Kth(rt, l), tr = Kth(rt, r);
        int a, b, c, d;
        Split(rt, a, b, l - 1);
        Split(b, b, c, r - l + 1);
        ++tncnt;
        L[tncnt] = L[tn[tl]], R[tncnt] = R[tn[tr]];
        Adde(b, tncnt);
        Split(b, b, d, 1);
        rt = Merge(a, Merge(b, c));
        tn[tl] = tncnt;
    }
    for (int i = 1; (1 << i) <= n - 1; i++) {
        for (int j = 1; j + (1 << i) - 1 <= n - 1; j++) 
            mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 << (i - 1))]);
    }
    dfs1(rt);
    cout << pos - 1 << "\n";
    return 0;
}
```

另外好像有简单无数倍的线段树做法，但是我不会。

---


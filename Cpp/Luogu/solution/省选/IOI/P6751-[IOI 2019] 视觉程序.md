# [IOI 2019] 视觉程序

## 题目背景

[评测方式](https://www.luogu.com.cn/paste/5z13bn4l)

[一些说明~~和扯淡~~](https://www.luogu.com.cn/paste/l6kcccs4)

## 题目描述

你在给机器人编写一个视觉程序。每次机器人的摄像头拍下一张照片时，图像将以黑白图像的形式存储在机器人的内存中。每张图像是由像素构成的 $H\times W$ 网格。图像的行从 $0$ 到 $H-1$ 编号，列从 $0$ 到 $W-1$ 编号。每张图像含有**恰好两个**黑色像素，其他像素均为白色。

机器人可以用简单指令构成的程序来处理图像。给出 $H$，$W$ 和一个正整数 $K$ 的值，你的目标是要编写一个函数，用来为机器人生成程序。该程序需要判定图像中两个黑色像素的距离是否正好为 $K$。这里，在第 $r_1$ 行及第 $c_1$ 列上的像素与第 $r_2$ 行及第 $c_2$ 列上的像素之间的距离定义为 $|r_1-r_2|+|c_1-c_2|$。 在这个式子中，$|x|$ 表示 $x$ 的绝对值，即当 $x\ge0$ 时，其值为 $x$，而当 $x<0$ 时，其值为 $-x$。

下面描述机器人是如何运作的。

机器人的内存有足够多的存储单元，从 $0$ 开始编号。每个存储单元可以保存 $0$ 或 $1$，且它的内容一旦设置后就不可更改。图像一行接一行地保存在存储单元里，这些存储单元的编号从 $0$ 到 $H\cdot W-1$。第一行保存在存储单元 $0$ 到 $W-1$ 里，最后一行保存在存储单元 $(H-1)W$ 到 $H\cdot W-1$ 里。特别地，如果位于第 $i$ 行第 $j$ 列上的那个像素是黑色的，则保存在存储单元 $i\cdot W+j$ 里的值为 $1$，否则为 $0$。

机器人的程序是一个**指令**的序列，这些指令用从 $0$ 开始的连续整数进行编号。在程序运行时，指令将一条一条地被执行。每条指令读取一个或多个存储单元的值（我们将这些值称为指令的**输入**），同时产生一个 $0$ 或 $1$ 的值（我们称之为指令的**输出**）。指令 $i$ 的输出将会保存在存储单元 $H\cdot W+i$ 中。指令 $i$ 的输入只能是保存图像的存储单元，或者是保存之前指令输出的存储单元，也就是编号为从 $0$ 到 $H\cdot W+i-1$ 的存储单元。

机器人共有四种指令：
- `NOT`：有唯一一个输入。若输入为 $0$ 时，其输出为 $1$，否则为 $0$。
- `AND`：有一个或多个输入。其输出为 $1$ 当且仅当输入**全部**为 $1$。
- `OR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中**至少有一个** $1$。
- `XOR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中 $1$ 的个数是**奇数**。

如果两个黑色像素之间的距离正好为 $K$，则最后一条指令的输出应为 $1$，否则输出应为 $0$。
#### 实现细节
你需要实现以下函数：
```plain
void construct_network(int H, int W, int K)
```
- $H$，$W$：机器人摄像头所拍到的图像的尺寸
- $K$：一个正整数
- 这个函数需要生成一个机器人的程序。对于机器人摄像头所拍到的每幅图像，该程序应判定图像中两个黑色像素之间的距离是否正好为 $K$。

该程序应当通过调用以下函数将指令追加到机器人的程序中（最初机器人的程序是空的）：
```plain
int add_not(int N)
int add_and(int[] Ns)
int add_or(int[] Ns)
int add_xor(int[] Ns)
```
- 分别追加一条 `NOT`，`AND`，`OR` 或 `XOR` 指令。
- $N$（对于 `add_not` 而言）：要追加的 `NOT` 指令的输入存储单元编号
- $Ns$（对于 `add_and`，`add_or`，`add_xor` 而言）：要追加的 `AND`，`OR` 或 `XOR` 指令的输入存储单元的编号的数组
- 每次函数调用都会返回追加指令的输出存储单位的编号。对这些函数的连续调用将会返回从 $H\cdot W$ 开始的连续整数。

机器人的程序最多可以包含 $10^4$ 条指令。这些指令一共最多只能读入 $10^6$ 个值。换句话说，所有 `add_and`，`add_or` 及 `add_xor` 调用中的 $Ns$ 数组的长度总和再加上 `add_not` 调用的次数不得超过 $10^6$。


当追加完最后一条指令后，函数 `construct_network` 必须返回。所产生的机器人程序会在一些图像上进行评测。对于一幅图像，程序最后一条指令的输出是 $1$ 当且仅当两个黑色像素之间的距离正好为 $K$。如果对测试点中的每幅图像，你的解答所产生的程序都可以正确地输出结果，那就通过了该测试点。

评测程序在评测你的程序时可能会出现以下错误信息：
- `Instruction with no inputs`：一个空数组被作为 `add_and`，`add_or` 或 `add_xor` 的输入。
- `Invalid index`：给 `add_not`，`add_or` 或 `add_xor` 提供了不正确（可能是负数）的存储单元编号作为输入。
- `Too many instructions`：你的函数尝试添加多于 $10^4$ 条的指令。
- `Too many inputs`：程序中的指令一共读取了多于 $10^6$ 个值。
#### 评测程序示例
评测程序示例读取下述格式的输入：
- 第 $1$ 行：$H$，$W$，$K$
- 第 $2+i$ 行（$i\ge0$）：$r1_i$，$c1_i$，$r2_i$，$c2_i$
- 最后一行：$-1$

除第一行和最后一行外，每一行都表示了一幅含有两个黑色像素的图像。记第 $2+i$ 行上的图像为图像 $i$。该图像中，一个黑色像素位于第 $r_1[i]$ 行及第 $c_1[i]$ 列上，令一个黑色像素位于第 $r_2[i]$ 行及第 $c_2[i]$ 列上。

评测程序首先调用 `construct_network(H, W, K)`。若 `construct_network` 违反了题目描述中的限制条件，评测程序示例将会输出在实现细节一节末尾所列举的某条错误信息并退出。

否则，评测程序示例将输出两部分内容。

首先，评测程序示例会以下列格式输出机器人程序所产生的输出：
- 第 $1+i$ 行（$0\le i$）：对于图像 $i$，机器人程序最后一条指令的输出（$1$ 或 $0$）。

其次，评测程序示例会以下列格式输出到当前目录下一个名为 `log.txt` 的文件中：
- 第 $1+i$ 行（$0\le i$）：$m_{i,0}$，$m_{i,1}$，$\dots$，$m_{i,c-1}$

在第 $1+i$ 行上的序列描述以图像 $i$ 作为输入时，在机器人程序运行结束后放在内存中的数据。具体来说，$m_{i,j}$ 是保存在存储单元 $j$ 里面的值。注意，$c$ 的值（序列长度）等于 $H\cdot W$ 再加上机器人程序的指令数。

## 说明/提示

#### 样例
假设 $H=2$，$W=3$，$K=3$。在此情况下，两个黑色像素之间的距离为 $3$ 的图像只有两种。

![](https://cdn.luogu.com.cn/upload/image_hosting/9fec7n4k.png)

- 情况一：黑色像素是 $0$ 和 $5$。
- 情况二：黑色像素是 $2$ 和 $3$。

一种可行的方案是通过以下调用来构造机器人程序：
1. `add_and([0, 5])`，将加入一条指令，当且仅当图像符合情况一时其输出为 $1$。输出结果将保存在存储单元 $6$ 里。
1. `add_and([2, 3])`，将加入一条指令，当且仅当图像符合情况二时其输出为 $1$。输出结果将保存在存储单元 $7$ 里。
1. `add_or([6, 7])`，将加入一条指令，当且仅当上述两种情况之一成立时其输出为 $1$。
#### 数据范围
对于所有数据：
- $1\le H,W\le200$；
- $2\le H\cdot W$；
- $1\le K\le H+W-2$。

详细子任务附加限制与分值如下表：
| 子任务编号 |                           附加限制                           | 分值 |
| :--------: | :----------------------------------------------------------: | :--: |
|    $1$     |                     $\max(H,W) \le 3$                        | $10$ |
|    $2$     |                     $\max(H,W) \le 10$                       | $11$ |
|    $3$     |                     $\max(H,W) \le 30$                       | $11$ |
|    $4$     |                     $\max(H,W) \le 100$                      | $15$ |
|    $5$     |                       $\min(H,W) = 1$                        | $12$ |
|    $6$     |     每幅图像上位于第 $0$ 行且位于第 $0$ 列的那个像素是黑色的         | $8$ |
|    $7$     |                           $K = 1$                            | $14$ |
|    $8$     |                      没有任何附加限制                           | $19$ |

# 题解

## 作者：chen_03 (赞：7)

我的做法是二进制加法器。似乎大多数人都不是这个做法？

首先，查询每一行、每一列的异或和。

以每一行为例，如果两个黑色像素在同一行，那么所有行的异或和都为 $0$；如果不在同一行，则它们所在的行的异或和为 $1$，黑色像素的竖直距离就是这两个 $1$ 之间的距离。

如果我们把这个异或和再做一遍前缀异或和，那么黑色像素的竖直距离就是前缀异或和中 $1$ 的数量。我们只要想办法统计 $1$ 的数量即可。

每一列同理。注意到行的前缀异或和中，最后一个数一定为 $0$，所以我们可以把行和列的前缀异或和放在一起统计。

那么如何统计前缀异或和中 $1$ 的数量呢？

我们想到了二进制加法器：从 $0$ 开始，把前缀异或和中的数一个一个地加上去。实现起来，就是维护每一位上的数字分别是什么，以及每一位上有没有进位。由于每次加法都是加 $0$ 或 $1$，所以每次进位操作可以只用一个指令。

我们要统计的数（距离）最多为 $H+W-2\le 398$，有 $9$ 个二进制位，所以每次加法用 $9$ 个指令维护每一位上的数字，用 $8$ 个指令维护每一位上有没有进位（最高位上一定不会进位）。每一位上的数字用异或操作维护，进位用与操作维护。

统计出 $1$ 的数量后，我们把它与 $K$ 一位一位地进行比较。把每一位都异或一下，把异或操作的结果或起来，再取非即可。此前要用某种方法搞出一个结果一定为 $0$ 的指令和一个结果一定为 $1$ 的指令。

我的代码使用的指令数最多为 $7200+$，读入值的数量最多不超过 $10^5$，可以轻松通过本题。当然这个数量可以继续优化，但没必要。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;
int add_not(int);
int add_and(vector<int> Ns);
int add_or(vector<int> Ns);
int add_xor(vector<int> Ns);
int n,m,k,cnt,zero,one;
vector<int> vec;
inline void add(int pos){
	int bg=cnt-16;
	add_xor({bg,pos});
	cnt=add_and({bg,pos});
	for(int i=1;i<8;++i){
		add_xor({bg+i*2,cnt});
		cnt=add_and({bg+i*2,cnt});
	}
	cnt=add_xor({bg+16,cnt});
}
void construct_network(int H,int W,int K){
	n=H;m=W;k=K;
	vec.resize(m);
	for(int i=0;i<m;++i)vec[i]=i;
	cnt=add_xor(vec);
	vec.resize(m+1);
	for(int i=1;i<n;++i){
		for(int j=0;j<m;++j)vec[j]=i*m+j;
		vec[m]=cnt;
		cnt=add_xor(vec);
	}
	vec.resize(n+1);
	for(int i=0;i<m;++i){
		for(int j=0;j<n;++j)vec[j]=j*m+i;
		vec[n]=cnt;
		cnt=add_xor(vec);
	}
	zero=add_xor({0,0});
	for(int i=1;i<17;++i)
		cnt=add_or({zero});
	for(int i=n*m;i<n*m+n+m;++i)add(i);
	int bg=cnt-16;
	vec.resize(9);
	one=add_not(zero);
	for(int i=0;i<9;++i)
		vec[i]=add_xor({bg+2*i,(k>>i)&1?one:zero});
	add_not(add_or(vec));
}
```


---

## 作者：A_zjzj (赞：2)

提供一种简介易懂的做法。

首先曼哈顿距离的绝对值比较难处理，所以可以转成切比雪夫距离。

具体地说，就是 $(x,y)$ 变成 $(x+y,x-y)$（接下来所述的坐标都是变换后的）。

这样 $(x,y),(a,b)$ 之间的距离就是 $\max\{|a-x|,|b-y|\}$。

虽然这里还有绝对值，但是这个我们其实是知道大小的，所以并不影响。

接下来考虑怎么构造方案。

由于现在的距离带着 $\max$，所以考虑判断两点间距离是否 $\ge d$。

也就是 $a-x\ge d$ 或 $b-y\ge d$，两维分开考虑，这里以 $x$ 一维为例；

若枚举 $x$，则只需判断是否存在 $\ge x+d$ 的 $a$ 即可。

所以先用 $O(n+m)$ 次查询，共 $O(nm)$ 个数，统计出变换后的坐标有无黑点。

再做一次后缀和，然后就直接判断存在 $\ge k$ 并且不存在 $\ge k+1$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
void construct_network(int H, int W, int K);
int add_and(std::vector<int> Ns);
int add_or(std::vector<int> Ns);
int add_xor(std::vector<int> Ns);
int add_not(int N);
using namespace std;const int N=2e2+10,M=N*2;
int n,m,k,a[M],b[M],c[M],d[M];vector<int>A[M],B[M];
int chk(int t){//判断两黑点距离是否 >= t 
	int x=add_or({add_and({a[0],c[t]}),add_and({b[0],d[t]})});
	for(int i=1;i+t<k;i++)x=add_or({x,add_and({a[i],c[i+t]})});
	for(int i=1;i+t<k;i++)x=add_or({x,add_and({b[i],d[i+t]})});
	return x;
}
void construct_network(int H,int W,int K){
	n=H;m=W;k=n+m-1;
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)A[i+j].push_back(i*m+j);//切比雪夫坐标 
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)B[i-j+m-1].push_back(i*m+j);
	for(int i=0;i<k;i++)a[i]=add_or(A[i]),b[i]=add_or(B[i]);
	c[k-1]=a[k-1];for(int i=k-2;i>=0;i--)c[i]=add_or({c[i+1],a[i]});//后缀 or 
	d[k-1]=b[k-1];for(int i=k-2;i>=0;i--)d[i]=add_or({d[i+1],b[i]});
	if(K<k-1)add_and({chk(K),add_not(chk(K+1))});else chk(K);
}
```

---

## 作者：WaReTle (赞：1)

# 好玩的做法

看到曼哈顿距离，我们当然想到把它算出来。（逃

考虑设两个点的 $x$ 坐标分别为 $x_1,x_2(1\le x_1\le x_2\le h)$。

先计算出 $x_1,x_2$，然后求出 $x_2-x_1$。$y$ 坐标同理。然后加起来再减 $k$，判断是否为 $0$ 即可。

首先我们需要常量 $0$ 和 $1$。我们发现只要 $h\times w\neq 2$ 就可以用所有位置的 ```and``` 表示出 $0$，用所有位置的 ```or``` 表示出 $1$。因此 $h\times w=2$ 的情况要特判。

考虑 ```bool``` 变量的实现。我们存下这个 ```bool``` 变量在机器人内存中的位置。运算就是用 ```add_xxx``` 操作新建一个变量然后返回它的位置。

```int``` 变量可以用 $9$ 个 ```bool``` 变量实现。

考虑加法和减法的实现。

加法：设两个加数分别为 $a,b$，它们的第 $i$ 位分别为 $a_i,b_i$。定义初值为零的辅助变量 $c$ 表示是否进位。从低到高遍历每一位，把答案的当前位设为 $a_i \operatorname{xor}b_i \operatorname{xor} c$，然后 $c$ 变为 $(a_i\operatorname{and}b_i)\operatorname{or}(b_i\operatorname{and}c)\operatorname{or}(a_i\operatorname{and}c)$。

减法：设被减数为 $a$，减数为 $b$。定义初值为零的辅助变量 $c$ 表示是否退位。从低到高遍历每一位，把答案的当前位设为 $a_i \operatorname{xor}b_i \operatorname{xor} c$，然后 $c$ 变为 $(b_i\operatorname{and}c)\operatorname{or}((b_i\operatorname{or}c)\operatorname{and}\operatorname{not}a_i)$。

然后考虑求出 $x_1$ 和 $x_2$。对每一行算出它的 ```or``` 值并存进一个序列里。显然 $x_1$ 就是编号最小的 $1$ 的位置，$x_2$ 就是编号最大的 $1$ 的位置。我们把序列进行前缀或和，然后再前缀异或差分，这样就只剩下下标最小的 $1$ 了，用 ```or``` 逐位确定即可。后缀同理。

然后算出 $x_2-x_1+y_2-y_1-k$，判断它的每一位是否都为 $0$ 即可。

```cpp
#include<bits/stdc++.h>
#include"vision.h"
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
int tot;
struct Bool
{
	int pos;
}_0,_1,a[205],b[205];
Bool operator&(Bool a,Bool b)
{
	add_and(vi{a.pos,b.pos});
	return {tot++};
}
Bool operator|(Bool a,Bool b)
{
	add_or(vi{a.pos,b.pos});
	return {tot++};
}
Bool operator^(Bool a,Bool b)
{
	add_xor(vi{a.pos,b.pos});
	return {tot++};
}
Bool operator!(Bool a)
{
	add_not(a.pos);
	return {tot++};
}
struct Int
{
	int pos[9];
};
Int operator+(Int a,Int b)
{
	Int c;
	Bool ca=_0;
	for(int i=0;i<9;++i)
	{
		Bool ai={a.pos[i]},bi={b.pos[i]};
		c.pos[i]=(ai^bi^ca).pos;
		ca=(ai&bi)|(ai&ca)|(bi&ca);
	}
	return c;
}
Int operator-(Int a,Int b)
{
	Int c;
	Bool ca=_0;
	for(int i=0;i<9;++i)
	{
		Bool ai={a.pos[i]},bi={b.pos[i]};
		c.pos[i]=(ai^bi^ca).pos;
		ca=(bi&ca)|(!ai&(bi|ca));
	}
	return c;
}
Int calc(Bool*b,int n)
{
	Int res;
	for(int i=0;i<9;++i)res.pos[i]=_0.pos;
	for(int i=0;i<8;++i)
	{
		vector<int>v;
		for(int j=0;j<n;++j)if(j>>i&1)v.push_back(b[j].pos);
		if(v.size())
			add_or(v),res.pos[i]={tot++};
		else res.pos[i]=_0.pos;
	}
	return res;
}
void construct_network(int h,int w,int k)
{
	tot=h*w;
	if(h*w==2)
	{
		assert(k==1);
		add_or({0});
		return;
	}
	if(1)
	{
		vector<int>v;
		for(int i=0;i<w*h;++i)v.push_back(i);
		add_and(v),_0={tot++};
		add_or(v),_1={tot++};
	}
	for(int j=0;j<w;++j)
	{
		vector<int>v;
		for(int i=0;i<h;++i)v.push_back(i*w+j);
		add_or(v),a[j]={tot++};
	}
	memcpy(b,a,sizeof(b));
	for(int i=1;i<w;++i)b[i]=b[i]|b[i-1];
	for(int i=w-1;i>0;--i)b[i]=b[i]^b[i-1];
	Int y1=calc(b,w);
	memcpy(b,a,sizeof(b));
	for(int i=w-2;~i;--i)b[i]=b[i]|b[i+1];
	for(int i=0;i<w-1;++i)b[i]=b[i]^b[i+1];
	Int y2=calc(b,w);
	for(int i=0;i<h;++i)
	{
		vector<int>v;
		for(int j=0;j<w;++j)v.push_back(i*w+j);
		add_or(v),a[i]={tot++};
	}
	memcpy(b,a,sizeof(b));
	for(int i=1;i<h;++i)b[i]=b[i]|b[i-1];
	for(int i=h-1;i>0;--i)b[i]=b[i]^b[i-1];
	Int x1=calc(b,h);
	memcpy(b,a,sizeof(b));
	for(int i=h-2;~i;--i)b[i]=b[i]|b[i+1];
	for(int i=0;i<h-1;++i)b[i]=b[i]^b[i+1];
	Int x2=calc(b,h);
	Int K;
	for(int i=0;i<9;++i)
		if(k>>i&1)K.pos[i]=_1.pos;
		else K.pos[i]=_0.pos;
	Int res1=x2-x1;
	Int res2=y2-y1;
	Int res3=res1+res2;
	Int res=res3-K;
	if(1)
	{
		vector<int>v;
		for(int i=0;i<9;++i)v.push_back((!Bool{res.pos[i]}).pos);
		add_and(v);
	}
}
```

这个做法的意义在于它可以算出两个点的坐标并且指令数是线性的。算出坐标的过程如下：

要么一个点是 $(x_1,y_1)$ 另一个点是 $(x_2,y_2)$，要么一个点是 $(x_1,y_2)$ 另一个点是 $(x_2,y_1)$。

因此 $x$ 坐标为 $x_1$ 的点的 $y$ 坐标为 $(\operatorname{int}(\operatorname{AND}(x_1w+y_1))\operatorname{and}y_1)\operatorname{or}(\operatorname{int}(\operatorname{AND}(x_1w+y_2))\operatorname{and}y_2)$，其中 $\operatorname{AND}$ 是题目中的 ```add_and``` 对应的操作，$\operatorname{int}$ 是将一个 ```bool``` 变量填入一个 ```int``` 的所有位的过程，$\operatorname{and}$ 和 $\operatorname{or}$ 都是对 ```int``` 的位运算。

另外一个点同理。

---


# [IOI 2022] 鲶鱼塘

## 题目背景

# 滥用评测资源者封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

原题时间限制 1s，为了节约评测资源，时间限制修改为 0.5s。

## 题目描述

Bu Dengklek 有一个鲶鱼塘。这个鲶鱼塘是由 $N \times N$ 个网格单元构成的池塘。每个单元都是相同大小的正方形。网格各列自西向东编号为从 $0$ 到 $N - 1$，各行自南向北编号为从 $0$ 到 $N - 1$。我们把坐落在网格第 $c$ 列第 $r$ 行处（$0 \le c \le N - 1$，$0 \le r \le N - 1$）的单元记为单元 $(c, r)$。

池塘里总共有 $M$ 条鲶鱼，编号为从 $0$ 到 $M - 1$，分别位于**不同的**单元中。对每个满足 $0 \le i \le M - 1$ 的 $i$，鲶鱼 $i$ 在单元 $(X_i, Y_i)$ 中，其重量为 $W_i$ 克。

Bu Dengklek 想造些长堤来抓鲶鱼。在第 $c$ 列中长度为 $k$ 的长堤（对于所有 $0 \le c \le N - 1$ 和 $1 \le k \le N$），是一个从第 $0$ 行跨到第 $k - 1$ 行的矩形，盖住单元 $(c, 0), (c, 1), \ldots, (c, k - 1)$。对于每一列，Bu Dengklek 可以按照她自己选择的某个长度造长堤，也可以不造。

鲶鱼 $i$（对所有满足 $0 \le i \le M - 1$ 的 $i$）能被抓住，如果有某个长堤紧邻它的西侧或东侧，而且没有长堤盖住它所在的单元；也就是说，如果
* 单元 $(X_i - 1, Y_i)$ 或 $(X_i + 1, Y_i)$ 中 **至少有一个** 被某个长堤盖住，而且
* 没有长堤盖住单元 $(X_i, Y_i)$。

例如，考虑尺寸为 $N = 5$，有 $M = 4$ 条鲶鱼的池塘：

* 鲶鱼 $0$ 在单元 $(0, 2)$ 中，重量为 $5$ 克。
* 鲶鱼 $1$ 在单元 $(1, 1)$ 中，重量为 $2$ 克。
* 鲶鱼 $2$ 在单元 $(4, 4)$ 中，重量为 $1$ 克。
* 鲶鱼 $3$ 在单元 $(3, 3)$ 中，重量为 $3$ 克。

Bu Dengklek 可以这样来造长堤：

| 造长堤前 | 造长堤后 |
| :---: | :---: |
| ![](https://cdn.luogu.com.cn/upload/image_hosting/2rcnqc7k.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/yesaiovt.png) |

单元中的数字表示该单元中鲶鱼的重量。
阴影单元被长堤盖住。
在该场景中，鲶鱼 $0$（在单元 $(0, 2)$ 中）和鲶鱼 $3$（在单元 $(3, 3)$ 中）能被抓住。
鲶鱼 $1$（在单元 $(1, 1)$ 中）没被抓住，因为有一个长堤盖住了它所在的单元；鲶鱼 $2$（在单元 $(4, 4)$ 中）没被抓住，因为没有长堤紧邻它的西侧或东侧。

Bu Dengklek 希望造出来的长堤能让被抓住的鲶鱼的总重量尽量大。
你的任务是求出 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。

## 说明/提示

### 约束条件

* $2 \le N \le 100\;000$
* $1 \le M \le 300\;000$
* $0 \le X_i \le N - 1$，$0 \le Y_i \le N - 1$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* $1 \le W_i \le 10^9$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* 任意两条鲶鱼都不会在同一单元中。
  换句话说，$X_i \neq X[j]$ 或 $Y_i \neq Y[j]$（对于所有满足 $0 \le i \lt j \le M - 1$ 的 $i$ 和 $j$）。

### 子任务

1. （3 分） $X_i$ 是偶数（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （6 分） $X_i \le 1$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （9 分） $Y_i = 0$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （14 分） $N \le 300$，$Y_i \le 8$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （21 分） $N \le 300$
1. （17 分） $N \le 3000$
1. （14 分） 在每列中至多有 $2$ 条鲶鱼。
1. （16 分） 没有额外限制。

### 评测程序示例

评测程序示例读取如下格式的输入：

* 第 $1$ 行：$N \; M$
* 第 $2 + i$ 行（$0 \le i \le M - 1$）：$X_i \; Y_i \; W_i$

评测程序示例将按照如下格式打印你的答案：

* 第 $1$ 行：`max_weights` 的返回值

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `int` | `int64`     | `int[]`            |
| ------- | ----- | ----------- | ------------------ |
| `void ` | `int` | `long long` | `std::vector<int>` |

| `int[][]`                       | 数组 `a` 的长度 |
| ------------------------------- | ------------------- |
| `std::vector<std::vector<int>>` | `a.size()`          |


# 题解

## 作者：WeLikeStudying (赞：11)

- 珍惜这道近年来比较简单的 IOI 题！

**题意**
- 有一个 $n\times n$ 的网格，里面有 $m$ 条鲶鱼，都有各自的重量。
- 你可以建一些从 $(x,0)$ 到 $(x,y)$ 的堤，如果鲶鱼在 $(x,y)$ 处，那么它被捕获当且仅当 $(x-1,y)$ 或 $(x+1,y)$ 处有堤且 $(x,y)$ 处没堤。
- 求可捕获鲶鱼的最大总重量，$n\le 10^5,m\le 3\times 10^5$。

**分析**
- 考虑 $O(n^2)$ 的暴力怎么做，尝试按行 DP，你发现或这个条件比较丑陋，且只考虑一种情况（对于第 $i$ 行的贡献，只考虑第 $i-1$ 行的帮助或第 $i+1$ 行的帮助）并没有影响。
- 设 $f(i,j,0/1)$ 为第 $i$ 行建 $(i,0)$ 到 $(i,j)$ 的坝，前 $i-1/i$ 行能抓到的最大重量，则（设 $g(i,j)$ 为 $(i,0)$ 到 $(i,j)$ 的鲶鱼质量之和），拆掉 DP 式子里面无用的东西，则：
$$f(i,j,0)+g(i,k)-g(i,j)\to f(i+1,k,0)$$
$$f(i,j,1)\to f(i+1,k,0)$$
$$f(i,j,1)+g(i+1,j)-g(i+1,k)\to f(i+1,k,1)$$
- 直接这样 DP 是 $O(n^3)$ 的，但是参变分离下，可以发现它是 $O(n^2)$ 的。
- 由于鲶鱼很少，本质不同的状态也很少，所以我们可以做到 $O(n+m)$，虽然没必要，[代码](https://www.luogu.com.cn/paste/b1prsixu)。

---

## 作者：EuphoricStar (赞：8)

不算很难的题，但是调起来比较恶心。

下文默认下标从 $1$ 开始。

设第 $i$ 列长堤的高度为 $h_i$。考虑观察一些性质。

#### Observation 1：若 $h_{i - 1} < h_i > h_{i + 1}$，那么 $h_i = n$ 一定不劣。

若 $h_i < n$，$[h_i + 1, n]$ 的鱼是抓不到的，并且增大 $h_i$ 还有机会让旁边两列抓到更多的鱼，所以还不如 $h_i = n$。

#### Observation 2：若 $h_{i - 1} > h_i < h_{i + 1}$，那么 $h_i = 0$ 一定不劣。

若 $h_i > 0$，$[1, h_i]$ 的鱼是抓不到的，让 $h_i = 0$ 就能抓到 $[1, h_i]$ 的鱼。

#### Observation 3：对于一组连续的长堤，其一定是单峰的，并且其中 $\max h_i = n, \min h_i = 0$。

由上面两个观察易得。

#### Observation 4：要么 $h_i \in \{0, n\}$，要么 $(i, h_i + 1)$ 一定有鱼。

如果 $(i, h_i + 1)$ 没有鱼且 $h_i \notin \{0, n\}$，那我们能够增大 $h_i$ 直到 $(i, h_i + 1)$ 有鱼，这样不会使第 $i$ 列抓到更少的鱼，而且还有机会使旁边两列抓到更多的鱼。

然后我们就可以开始设计 dp 了。设 $f_{i, j, 0/1}$ 为 $h_i = j$，$h_i$ 处在上升还是下降阶段，能抓到的鱼的价值最大和。这里我们强制规定 $h_i = n$ 时 $h_i$ 处于下降阶段，$h_i = 0$ 时 $h_i$ 处于上升阶段。

转移大概就是，$f_{i, j, 0}$ 从 $\forall k \in [0, j], f_{i - 1, k, 0}$ 转移过来，差分一下加上第 $i - 1$ 列中行坐标 $\in [k + 1, j]$ 的鱼的价值和；$f_{i, j, 1}$ 从 $\forall k \in [j, n], f_{i - 1, k, 1}$ 转移过来，仍然差分一下加上第 $i$ 列中行坐标 $\in [j + 1, k]$ 的鱼的价值和。特别地，$f_{i, 0, 0}$ 可以从任意 $f_{i - 1, j, 1}$ 转移过来，$f_{i, n, 1}$ 可以从任意 $f_{i - 1, j, 0}$ 转移过来，加上第 $i - 1$ 列行坐标 $\in [j + 1, n]$ 的鱼的价值和。

对于价值和的计算，为了方便，我们强制规定，当 $h_i$ 处于上升阶段时，$f_i$ 计算 $[1, i - 1]$ 的价值和；$h_i$ 处于下降阶段时，$f_i$ 计算 $[1, i]$ 的价值和。但是这样有个问题，就是如果 $h_{i - 1} > h_i = 0 < h_{i + 1}$ 且 $h_{i - 1} > h_{i + 1}$，我们的规定会导致第 $i$ 列行坐标 $\in [h_{i + 1} + 1, h_{i - 1}]$ 的鱼漏算进答案里面。这种情况我们直接从 $f_{i - 2}$ 转移过来即可。

有效状态数只有 $O(n + m)$ 个，因此使用 `unordered_map` 存储状态即可。

使用树状数组分别计算后缀和、前缀 $\max$、后缀 $\max$（记得每次转移完要清空），时间复杂度 $O((n + m) \log n)$。

[code](https://loj.ac/s/1838842)

---

## 作者：LJ07 (赞：3)

容易设计出一个暴力 dp：$dp_{i,j}$ 表示前 $i$ 列，第 $i$ 列所修筑的堤坝高度为 $j$ 的能抓住的鲶鱼的最大总重量。

通过观察样例和简单思考，能够发现状态总数为 $O(m)$ 的（状态总数为鱼下一格和顶满整列和整列为空的总和）。

不太会优化，于是通过简单手模只有 $3$ 列的情况，容易发现此时有一种堤坝形态一定不是最优，可以替代：中间不断开且形状是单谷。如果是单谷且中间不断开，等价于中间断开。

那么扩展到 $n$ 列，就有（下面数字均指堤坝高度）：
1. 不存在连续 $3$ 列为 $0$ 一定不劣（如果存在，中间一列随便搞都不会更劣）。
1. 被 $0$ 分隔的若干列连续段不存在谷，也就是递增，递减或单峰。

那么就可以设计 dp : $f_{i,0/1}$ 表示考虑到第 $x_i$ 行，堤坝高度为 $y_i - 1$，现在位于连续段的上升或下降段的能抓住的鲶鱼的最大总重量，$g_i$ 表示第 $i$ 行堤坝高度为 $0$ 且前一行高度不为 $0$ 的能抓住的鲶鱼的最大总重量。

那么转移：($w_i(l,r)$ 表示第 $i$ 列位于 $l\cdots r$ 行的鱼重量总和，$l>r$ 时为 $0$）

1. $f_{i,0}=\max(g_{i-1},g_{i-2}+w_i(1,y_i-1),\max_{x_j=x_i-1,y_j\le y_i}\{f_{j,0}+w_i(y_j,y_i-1)\})$
1. $f_{i,1}=\max(f_{i,0},\max_{x_j=x_i-1,y_j\ge y_i}\{f_{j,0}+w_i(y_i,y_j-1)\})$
1. $g_i=\max_{x_j=x_i-1}\{f_{j,1}+w_i(1,y_j-1)\}$

转移 $O(n+m)$ 扫一遍即可。

```cpp
#include <bits/stdc++.h>
#define U(i, l, r) for (int i(l); i <= r; ++i)
using namespace std;
long long max_weights(int n, int m, vector<int> X, vector<int> Y, vector<int> W) {
  #define ep emplace_back
  vector<int> x, y, w; 
  U(i, 0, m - 1) {
    x.ep(X[i] + 1), y.ep(Y[i] + 1), w.ep(W[i]);
  }
  U(i, 1, n) {
    x.ep(i), y.ep(n + 1), w.ep(0);
  }
  m += n;
  vector<vector<int>> vec(n + 1);
  vector<vector<long long>> f(2, vector<long long>(m));
  vector<long long> g(n + 1);
  U(i, 0, m - 1) {
    vec[x[i]].emplace_back(i);
  }
  U(i, 1, n) {
    sort(vec[i].begin(), vec[i].end(), [&](int a, int b) {
      return y[a] < y[b];
    });
  }
  U(i, 1, n) {
    const int SZ1(vec[i - 1].size()), SZ2(vec[i].size());    
    long long mx(-1e17), s(0);
    int p(0);
    for (int j : vec[i - 1]) {
      while (p < SZ2 && y[vec[i][p]] < y[j]) {
        s += w[vec[i][p++]];
      }
      g[i] = max(g[i], f[1][j] + s);
    }
    p = 0, s = 0;
    for (int j : vec[i]) {
      while (p < SZ1 && y[vec[i - 1][p]] < y[j]) {
        mx = max(mx, f[0][vec[i - 1][p]] - s);
        s += w[vec[i - 1][p++]];
      }
      f[0][j] = max({mx + s, g[i - 1], (i > 1) * (g[i - 2] + s)});
      if (p < SZ1 && y[vec[i - 1][p]] == y[j]) {
        f[0][j] = max(f[0][j], f[0][vec[i - 1][p]]);
      }
    } 
    p = SZ1 - 1, s = 0, mx = -1e17;
    for (int j(SZ2 - 1); ~j; --j) {
      while (p >= 0 && y[vec[i - 1][p]] > y[vec[i][j]]) {
        mx = max(mx, f[1][vec[i - 1][p--]] - s);
      }
      s += w[vec[i][j]];
      f[1][vec[i][j]] = max(f[0][vec[i][j]], mx + s);
      if (p >= 0 && y[vec[i - 1][p]] == y[vec[i][j]]) {
        f[1][vec[i][j]] = max(f[1][vec[i][j]], f[1][vec[i - 1][p]]);
      }
    }
  }
  long long res(g[n]);
  U(i, 0, m - 1)  {
    res = max({res, f[1][i], f[0][i]});
  }
  return res;
}
```

很好写，除开 CE 一遍 AC。

---

## 作者：Mirasycle (赞：1)

简单题，代码写起来有点细节，不过很短。

首先贪心一下，其实每列大坝在不多覆盖某条鱼的情况下肯定尽可能多覆盖一些。所以每一列可能的覆盖为 $[1,x]$，其中 $x=y_i-1$ 或者 $n$。

因此有用的覆盖位置只有 $O(n+m)$ 个点。

直接 dp，问题是如果某条鱼左右都被覆盖了怎么办？我们直接给 dp 加一个维度 0/1 钦定一侧进行贡献即可，因为左右肯定有更高的一侧，选那一侧肯定是不劣的。

直接设 $dp_{i,j,0/1}$ 表示考虑了前 $i$ 列，其中第 $j$ 列覆盖了 $[1,j]$ 的位置可以得到的最大权值，给第二维度离散化一下，然后转移就是前后缀 $\max$。



为了方便算前缀和贡献，我除了离散化 $y_i-1$ 和 $n$，还附加离散化了 $y_i$。

时间复杂度 $O(n+m\log m)$。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int maxn=1e5+10;
void cmax(ll &x,ll y){ x=x>y?x:y; }
int n,sz[maxn]; vector<int> s[maxn];
vector<ll> f[maxn][2],val[maxn];
vector<pair<int,int> > vec[maxn];
ll max_weights(int N,int M,vi X,vi Y,vi W){
	for(int i=0;i<M;i++) vec[X[i]+1].pb(Y[i]+1,W[i]);
	n=N; sz[0]=1;
	f[0][0].pb(0); f[0][1].pb(0);
	s[0].pb(0); val[0].pb(0);
	for(int i=1;i<=n;i++){
		sort(vec[i].begin(),vec[i].end());
		ll sum=0;
		if(vec[i].empty()||vec[i][0].fi>1) s[i].pb(0),val[i].pb(0);
		for(auto z:vec[i]){
			if(s[i].empty()||s[i].back()!=z.fi-1) s[i].pb(z.fi-1),val[i].pb(sum);
			sum+=z.se; s[i].pb(z.fi); val[i].pb(sum);
		}
		if(s[i].empty()||s[i].back()<n) s[i].pb(n),val[i].pb(sum); 
		sz[i]=s[i].size();
		f[i][0].resize(sz[i]+2,0); f[i][1].resize(sz[i]+2,0); ll mx=0;
		mx=0; 
		for(auto z:f[i-1][0]) cmax(mx,z);
		for(auto &z:f[i][1]) cmax(z,mx);
		mx=0;
		for(int j=sz[i-1]-1,r=sz[i]-1;j>=0;j--){ //0->0
			while(s[i][r]>s[i-1][j]&&r>=0) cmax(f[i][0][r],mx-val[i][r]),--r;
			cmax(mx,f[i-1][0][j]+val[i][r]);
		}
		cmax(f[i][0][0],mx); mx=0;
		for(int j=0,l=0;j<sz[i];j++){
			while(s[i-1][l]<=s[i][j]&&l<sz[i-1]) cmax(mx,f[i-1][1][l]-val[i-1][l]),l++;
			cmax(f[i][1][j],mx+val[i-1][l-1]); cmax(f[i][0][j],f[i][1][j]); 
		}
	}
	ll ans=0;
	for(auto z:f[n][0]) cmax(ans,z);
	for(auto z:f[n][1]) cmax(ans,z);
	return ans;
}
```

---

## 作者：Purslane (赞：1)

# Solution

~~小萌新竟然会 IOI 紫题，太感动了。 TAT~~

考虑最优结构调整。发现每一列的大坝要么填满，要么恰好在一条鲶鱼的下面。因此有用的状态很少。

假设第 $i$ 列大坝的高度为 $h_i$，我们发现 $h_{i-1} > h_i < h_{i+1}$ 的时候，第 $i$ 列的鲶鱼会被抓住两次。

不过你可以钦定每一列的鲶鱼只会被其左边或者右边的大坝抓住。容易发现最优解一定不会被你漏掉。

设 $dp_{i,j,0/1}$ 表示，第 $i$ 列大坝的高度为 $j$，且第 $i$ 列鲶鱼是否已经被抓住。

转移时枚举两列大坝的相对高度，使用前缀和优化即可。

总的复杂度为 $O((n+m) \log n)$。

这是萌新的第 $695$ 篇题解，喜欢的就点个赞吧。 /kel

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100000+10;
int n,m;
vector<pair<int,int>> fish[MAXN];
vector<pair<int,ll>> dp[MAXN][2];
inline void trans(int i) {
	vector<int> lid,rid;
	vector<ll> lpre,rpre;
	
	ll tmp=0;
	for(auto pr:fish[i-1]) lid.push_back(pr.first),tmp+=pr.second,lpre.push_back(tmp);	
	tmp=0;
	for(auto pr:fish[i]) rid.push_back(pr.first),tmp+=pr.second,rpre.push_back(tmp);
	
	int pos=0;
	ll mx=-0x3f3f3f3f3f3f3f3f,Mx=mx;
	vector<int> kp=rid;
	
	ll sum=0; int tpos=0;
	for(auto pr:dp[i-1][1]) Mx=max(Mx,pr.second);
	for(auto id:kp) {
		while(pos<dp[i-1][0].size()&&dp[i-1][0][pos].first<=id-1) {
			while(tpos<lid.size()&&lid[tpos]<=dp[i-1][0][pos].first) sum=lpre[tpos],tpos++;
			mx=max(mx,dp[i-1][0][pos].second-sum);
			pos++;
		}
		while(tpos<lid.size()&&lid[tpos]<=id-1) sum=lpre[tpos],tpos++;
		dp[i][0].push_back({id-1,max(Mx,mx+sum)});
	}
	
	reverse(kp.begin(),kp.end());
	map<int,ll> mp;
	ffor(o,0,1) {
		mx=-0x3f3f3f3f3f3f3f3f,pos=0;
		pos=(int)dp[i-1][o].size()-1;
		ll sum=rpre[rpre.size()]-1;
		int tpos=rpre.size()-1;
		for(auto id:kp) {
			while(pos>=0&&dp[i-1][o][pos].first>=id-1) {
				while(tpos>=0&&rid[tpos]>dp[i-1][o][pos].first) {
					tpos--;
					if(tpos==-1) sum=0;
					else sum=rpre[tpos];
				}
				mx=max(mx,dp[i-1][o][pos].second+sum),pos--;
			}
			while(tpos>=0&&rid[tpos]>id-1) {
				tpos--;
				if(tpos==-1) sum=0;
				else sum=rpre[tpos];
			}
			mp[id-1]=max(mp[id-1],mx-sum);
			dp[i][1].push_back({id-1,mx-sum});
		}
	}
	for(auto pr:mp) dp[i][1].push_back(pr);
	return ;
}
ll max_weights(int N,int M,vector<int> x,vector<int> y,vector<int> w) {
	n=N,m=M;
	ffor(i,0,m-1) fish[x[i]+1].push_back({y[i]+1,w[i]});
	ffor(i,1,n) fish[i].push_back({n+1,0});
	dp[0][0].push_back({0,0});
	ffor(i,1,n) sort(fish[i].begin(),fish[i].end());
	ffor(i,1,n) trans(i);
	ll ans=0;
	for(auto pr:dp[n][0]) ans=max(ans,pr.second);
	for(auto pr:dp[n][1]) ans=max(ans,pr.second);
	return ans;
}
//int main(void) {
//	cout<<max_weights(5, 4, {0, 1, 4, 3}, {2, 1, 4, 3}, {5, 2, 1, 3});	
//}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P8490)

**题目大意**

> 给定 $n\times n$ 网格，每列可以覆盖一个前缀，有 $m$ 个特殊点，如果 $(x_i\pm 1,y_i)$ 至少覆盖了一个，且 $(x_i,y_i)$ 未覆盖，获得 $w_i$ 权值，求最大可能权值。
>
> 数据范围：$n\le 10^5,m\le 3\times 10^5$。

**思路分析**

首先朴素 dp 就是 $f_{i,j}$ 表示第 $i$ 列覆盖 $j$ 个点的方案，但一个特殊点可能被左右的列同时计算。

注意到如果方案中产生单谷 $h_{i-1}>h_i<h_{i+1}$，那么我们可以调整使得 $h_i=0$，很显然这是不劣的。

那么我们把 $h_i=0$ 的点当成分界点，然后对峰和谷分别 dp，即 $f_{i,j}$ 表示上升段中 $h_{i+1}>j$ 的最大权值，$g_{i,j}$ 表示 $h_i=j$ 的最大权值。

进一步观察，如果 $h_i\ne 0$ 且 $\ne n$，$(i,h_{i}+1)$ 一定是一个关键点，否则调整到下一个关键点位置不劣。

则只要考虑 $j=0/j=n$，以及所有 $f_{x_i,y_i-1},g_{x_i,y_{i}-1}$。

转移时对相邻两列的状态双指针。

时间复杂度 $\mathcal O(n+m\log m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "fish.h"
#define ll long long
using namespace std;
const int MAXN=1e5+5,MAXM=3e5+5;
ll f[MAXM],g[MAXM],F[MAXN],G[MAXN]; //f=up g=down
vector <int> id[MAXN];
ll max_weights(int n,int m,vector<int>x,vector<int>y,vector<int>w) {
    for(int i=0;i<m;++i) id[x[i]+1].push_back(i);
    for(int i=1;i<=n;++i) {
        auto &b=id[i-1],&a=id[i];
        int sa=a.size(),sb=b.size();
        sort(a.begin(),a.end(),[&](int u,int v){ return y[u]<y[v]; });
        if(i>1) {
            ll mx=max(F[i-2],G[i-2]);
            for(int j=sa-1,k=sb-1;~j;--j) {
                int u=a[j];
                for(;~k&&y[b[k]]>y[u];--k) mx=max(mx,g[b[k]]);
                g[u]=mx+=w[u];
            }
            G[i]=max(G[i-1],mx);
        }
        if(i<n) {
            ll mx=G[i-1];
            for(int j=0,k=0;j<sa;++j) {
                int u=a[j];
                for(;k<sb&&y[b[k]]<y[u];++k) mx=max(mx,f[b[k]]);
                f[u]=mx+=w[u];
            }
            F[i]=max(F[i-1],mx);
        }
    }
    ll ans=0;
    for(int i=1;i<=n;++i) ans=max({ans,F[i],G[i]});
    for(int i=1;i<=m;++i) ans=max({ans,f[i],g[i]});
    return ans;
}
```

---

## 作者：Nygglatho (赞：0)

直接令 $f_{i,j}$ 表示前 $i$ 列，第 $i$ 列修高度为 $j$ 的长堤最大重量是很不好转移的，因为你没办法知道 $i-1$ 列的鱼是否已经计算过贡献了。

可以发现，如果钦定第 $i$ 列的鱼只能被其左边或只能被其右边的长堤抓住是不影响答案的，因为如果一个鱼被左边（或右边）的长堤抓住，则这一列高度低于这条鱼的鱼同样能被左边（或右边）的长堤抓住。

令 $f(i,j,0/1)$ 表示第 $i$ 列修的长堤长度为 $j$，钦定第 $i$ 列只能被其左边（或右边）的长堤抓住，前 $i$ 列抓住的鱼最大重量，$W_{x,y}$ 表示第 $x$ 行第 $y$ 列的鱼重量（如果没有鱼则 $W_{x,y}$ 视为 $0$）则有：
$$
\begin{aligned}
f(i,j,0)=\max\{\\
&\max(f(i-1,j,0),f(i-1,j,1))\qquad\qquad\qquad\ \ \ \ \ \mathrm{I}\\
&\max\limits_{k<j}\{f(i-1,k,0)\},\qquad\qquad\qquad\qquad\qquad\qquad\mathrm{II}\\
&\max\limits_{k>j}\{f(i-1,k,0)+\sum\limits_{j\le y<k}W_{i,y}\},\qquad\qquad\qquad\mathrm{III}\\
&\max\limits_{k<j}\{f(i-1,k,1)+\sum\limits_{k\le y<j}W_{i-1,y}\}\qquad\qquad\qquad\mathrm{IV}\\
\}\\
f(i,j,1)=\max\{\\
&f(i-1,j,1)\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\mathrm{V}\\
&\max\{f(i-1,k,0)\},\qquad\qquad\qquad\qquad\qquad\qquad\ \,\mathrm{VI}\\
&\max\limits_{k<j}\{f(i-1,k,1)+\sum\limits_{k\le y<j}W_{i-1,y}\}\qquad\qquad\qquad\mathrm{VII}\\
\}
\end{aligned}
$$
这是 $O(n^3)$ 的，考虑优化。

观察转移式子，$\mathrm{I,II,V,VI}$ 可以双指针直接维护，对于 $\mathrm{III}$，当 $j\gets j-1$ 时，对于 $k>j$ 的部分，上面这坨式子的值会增加 $W_{i,j-1}$，这个相当于后缀加求后缀 $\max$，直接上线段树总复杂度是 $O(n\log n)$ 的，实际上可以 $O(n)$，而且比线段树好写，但是做的时候犯唐了没想到（），$\mathrm{IV,VII}$ 和 $\mathrm{III}$ 思路是类似的，前缀加前缀 $\max$。

可以发现长堤要么修到 $N$，要么恰好修到鱼下面一格，证明就是如果原来第 $i$ 列长堤长度为 $j$ 且 $(i,Y)$ 有鱼且到 $(i,j)$ 到  $(i,Y-1)$ 均没有鱼，则可以让 $j\gets Y$，此时不影响第 $i$ 列抓住的鱼，但旁边两列有可能抓住更多的鱼。这样可以把 $j$ 的有效状态数减少到 $O(n+m)$，结合前面的优化，复杂度 $O((n+m)\log (n+m))$。

然后还有一点常数优化，根据 $f(i,j,0/1)$ 的定义显然 $f(i,j,0)>f(i,j,1)$，$\mathrm{I}$ 可以把 $f(i-1,j,1)$ 部分删去，$\mathrm V$ 也可以删去。

[Submission](https://loj.ac/s/2327513)

---

## 作者：紊莫 (赞：0)

似乎是不依赖什么性质的做法，但是比较难写。

---

设 $f_{i,j,0/1}$ 表示前 $i$ 列，第 $i$ 列的高度是 $h_i=j$，$0$ 表示 $h_{i+1}\ge h_i$，$1$ 表示 $h_{i+1}\le h_i$ 的最优代价。

转移如下：

$$\begin{aligned}
f_{i-1,*,0} \to f_{i,j,0}\\

f_{i-1,*,0} \to f_{i,j,1}\\

f_{i-1,*,1} \to f_{i,j,0}\\
\end{aligned}$$

加上的价值就是 $i-1$ 或者 $i$ 的对应区间的价值。

这里没有 $f_{i-1,*,1} \to f_{i,j,0}$，这种转移会形成一个“谷”，导致不知道应该选择哪一边作为答案。

我的做法是分离开两种转移，也就是把 $f_{i-1,*,1}$ 变成 $f_{i,*,0}$，留给后面转移。

但是我自己写代码的时候仍然注意到了单峰的性质，所以上述转移只在转移到 $0$ 的时候出现。

然后只需要前（后）缀优化即可，我由于使用了一些 ``lower_bound`` 计算贡献，复杂度是线性对数的。

可以结合代码理解：

1. 朴素：https://loj.ac/s/2326370
2. 优化：https://loj.ac/s/2326430

---

## 作者：huazai676 (赞：0)

提供一个和其他题解思维过程不太一样的解法。

最初的想法都差不多：$f_{i,j}$ 表示前 $i$ 列并且第 $i$ 列池塘高度为 $j$ 的最大捕获重量。但此时发现一个问题，比如当 $f_{i-1,k}$ 向 $f_{i,j}$ 转移时（$k<j$，即前一列池塘较低），我们没有保存第 $i-2$ 列的信息，所以不知道当加入当前第 $i$ 列时会有多少新的鲇鱼被捕获（因为有可能一些鱼被第 $i-2$ 列捕获了）。

这时有个想法就是再加一维 $f_{i,j,k}$ 表示第 $i-2$ 列高为 $k$，但这样复杂度直接就爆炸了。

所以我们考虑**略微更改题目**：第 $i$ 列可以选择被 $i-1$ 或者 $i+1$ 捕获，而不是一定要被更高的那列捕获。这样设 $f_{i,j,0/1}$ 表示第 $i$ 列有无做选择（或者是选择前还是后），在往后转移时再把后面的贡献加上。并且因为是最优化问题，最后也不会影响答案。

剩下就简单了：设 $c_i$ 表示第 $i$ 列的鲇鱼数量，则最优情况下第 $i$ 列只有 $c_i+1$ 种可能的池塘高度。所以状态的 $j$ 一维大小只有 $O(m)$。维度 $i$ 直接滚动数组。

复杂度 $O(n+m)$。

[代码](https://loj.ac/s/2086175)

---


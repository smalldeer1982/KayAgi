# [IOI 2022] 最罕见的昆虫

## 题目背景

# 滥用评测资源者封号

**本题为交互题。**

您**不需要也不应该**在提交的程序中包含 `insects.h` 头文件和主函数。

但是在您的程序中，需要声明以下三个函数：

```cpp
void move_inside(int i);
void move_outside(int i);
int press_button();
```

例如，您的程序可以是这样：

```cpp
#include <bits/stdc++.h>
using namespace std;

void move_inside(int i);
void move_outside(int i);
int press_button();

int min_cardinality(int N) {
	// Code Here
}
```

## 题目描述

Pak Blangkon 的房子四周有 $N$ 只昆虫，编号为 $0$ 至 $N-1$。每只昆虫有一个**类型**，以从 $0$ 至 $10^9$（包含 $0$ 和 $10^9$）的整数编号。可能有多只昆虫类型相同。

假设将昆虫按照类型分组。我们定义**最常见**昆虫类型的基数是昆虫最多的分组中的昆虫数。类似地，**最罕见**昆虫类型的基数是昆虫最少的分组中的昆虫数。

例如，假设有 $11$ 只昆虫，类型分别为 $[5, 7, 9, 11, 11, 5, 0, 11, 9, 100, 9]$。在此情形中，**最常见**昆虫类型的基数是 $3$，是因为类型 $9$ 和类型 $11$ 的分组均有最多数目的昆虫，每个分组都有 $3$ 只。**最罕见**昆虫类型的基数是 $1$，是因为类型 $7$、类型 $0$ 和类型 $100$ 的分组均有最少数目的昆虫，每个分组都有 $1$ 只。

Pak Blangkon 不知道这些昆虫的类型。他有一台单按钮的机器，可以提供昆虫类型相关的信息。刚开始时，机器是空的。在使用机器时，可以做如下三种操作：

1. 将一只昆虫放进机器。
2. 将一只昆虫取出机器。
3. 按下机器的按钮。

每种操作最多可以做 $40\;000$ 次。

每当按下按钮时，机器会报告在机器内的**最常见**昆虫类型的基数。

你的任务是使用上述机器，确定 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。此外，在某些子任务里，你的得分取决于机器执行某种操作的最大次数（详见子任务一节）。

## 说明/提示

### 约束条件

- $2 \le N \le 2000$。

### 子任务

1. （10 分） $N \le 200$；
2. （15 分） $N \le 1000$；
3. （75 分） 没有额外的约束条件。

如果在某个测试用例上，函数 `move_inside`、`move_outside` 或 `press_button` 的调用次数不符合“实现细节”中给出的约束条件，或者 `min_cardinality` 的返回值不正确，你的解答在此子任务上得分为 $0$。

令 $q$ 为以下三个值的 **最大值**：`move_inside` 的调用次数、`move_outside` 的调用次数、`press_button` 的调用次数。

在子任务 3 中，你可能会得部分分。令 $m$ 为此子任务所有测试用例的 $\frac{q}{N}$ 的最大值。你在此子任务的得分将根据以下表格计算：

|       条件       |                   得分                   |
| :--------------: | :--------------------------------------: |
|    $20 \lt m$    | $0$ （CMS 报告“`Output isn’t correct`”） |
| $6 \lt m \le 20$ |           $\frac{225}{m - 2}$            |
| $3 \lt m \le 6$  |          $81 - \frac{2}{3} m^2$          |
|    $m \le 3$     |                   $75$                   |

### 评测程序示例

令 $T$ 是长度为 $N$ 的整数数组，其中 $T[i]$ 是编号为 $i$ 的昆虫的类型。

评测程序示例按以下格式读取输入：

- 第 $1$ 行：$N$；
- 第 $2$ 行：$T[0] \; T[1] \; \ldots \; T[N - 1]$。

如果评测程序示例检测到非法行为，评测程序示例将输出 `Protocol Violation: <MSG>`，其中 `<MSG>` 为如下某种类型：

- `invalid parameter`：在函数调用 `move_inside` 或 `move_outside` 时，参数 $i$ 的值不在 $0$ 至 $N-1$ 的范围内（包括 $0$ 和 $N-1$）。
- `too many calls`：函数 `move_inside`、`move_outside` 或 `press_button` 中**某个**的调用次数超过 $40\;000$ 次。

否则，评测程序示例按以下格式输出：

- 第 $1$ 行：`min_cardinality` 的返回值；
- 第 $2$ 行：$q$。

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `bool` | `int` | `int[]`            |
| ------- | ------ | ------| ------------------ |
| `void ` | `bool` | `int` | `std::vector<int>` |

| `union(bool, int[])`                   | 数组 `a` 的长度 |
| -------------------------------------- | ------------------- |
| `std::variant<bool, std::vector<int>>` | `a.size()`          |

C++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。
一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。
以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：

```cpp
std::variant<bool, std::vector<int>> foo(int N) {
    return N % 2 == 0;
}

std::variant<bool, std::vector<int>> goo(int N) {
    return std::vector<int>(N, 0);
}

std::variant<bool, std::vector<int>> hoo(int N) {
    if (N % 2 == 0) {
        return false;
    }

    return std::vector<int>(N, 0);
}
```

# 题解

## 作者：Kubic (赞：17)

首先可以扫一遍算出有多少种昆虫，设为 $cnt$，然后二分答案。

每次判断答案是否 $\ge mid$ 只需要依次加入每个数，再进行一次询问，如果得到的结果的出现次数 $>mid$ 就把它删掉。只需判断最后留下的数的个数是否 $\ge cnt\times mid$ 即可。

分析一下询问次数：$T(n)=n+T\left(\dfrac{n}{2}\right)=2n$，再加上一开始扫的一遍是 $3n$。

但是实际上不一定能每次都递归到 $\dfrac{n}{2}$，可能会稍大一点，因此直接写会获得 $99.89$ 的好成绩。

我们可以发现如果某个时刻已经留下了 $\ge cnt\times mid$ 个数就不需要继续往下做了，可以直接 break 掉。因此考虑把序列 shuffle 一下再进行这个过程就可以过了。

参考代码：

```cpp
#include "insects.h"
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
mt19937 rand1(time(0));
int l,r,cnt,cnt1,a[MAXN];bool vs[MAXN],vs1[MAXN];
void ins(int x) {++cnt1;move_inside(x-1);}
void dlt(int x) {--cnt1;move_outside(x-1);}
int qry() {return press_button();}
int min_cardinality(int n)
{
	for(int i=1;i<=n;++i) {ins(i);if(qry()>1) dlt(i);else vs[i]=1,++cnt;}
	if(cnt==1) return n;l=2;r=n/cnt;
	while(l<=r)
	{
		int mid=(l+r)/2;for(int i=1;i<=n;++i) vs1[i]=0,a[i]=i;
		shuffle(a+1,a+n+1,rand1);
		for(int i=1;i<=n;++i) if(!vs[a[i]])
		{
			if(cnt*mid<=cnt1) break;ins(a[i]);
			if(qry()>mid) dlt(a[i]);else vs1[a[i]]=1;
		}
		if(cnt*mid<=cnt1) {l=mid+1;for(int i=1;i<=n;++i) if(vs1[i]) vs[i]=1;}
		else {r=cnt1/cnt;for(int i=1;i<=n;++i) if(vs1[i]) dlt(i);else vs[i]=1;}
	}return r;
}
```

---

## 作者：Phartial (赞：4)

# P8494 [IOI2022] 最罕见的昆虫 题解

我们可以简单的求出昆虫的种数：依次遍历每个昆虫，将其加入机器后询问众数的出现次数，如果大于 $1$ 就删去这个昆虫，否则保留。不难发现最后机器中每个类型都会出现有且仅有一次。于是机器中的昆虫数量就是昆虫的种数，且每个操作只会执行 $\le n$ 次。不妨将昆虫种数记作 $t$。

考虑二分答案。我们可以每次二分校验最罕见的昆虫的出现次数是否 $\ge C$，而这可以类似求昆虫种数的方式来求：我们只需限制机器中众数的出现次数不超过 $C$，最后看机器中的昆虫数量是否 $=Ct$ 即可。总操作次数为 $\mathcal{O}(n\log n)$，考虑优化。

容易发现这个过程可以使用之前的信息：如果最罕见的昆虫的出现次数 $\ge C$，那么我们不必清空也不必考虑机器中的数，这显然不会影响我们的校验。如果最罕见的昆虫的出现次数 $<C$，那么我们不必考虑不在机器中的数（因为这些数的出现次数 $\ge C$，不可能成为答案）。

于是每次操作都会使需要考虑的数减半，总操作次数是 $\approx n+2n=3n$ 的。

如果直接实现上面的内容，你会获得 $99$ 分的好成绩，以下是笔者使用的卡常方式：

- 答案显然不会超过 $\lfloor \frac{n}{t}\rfloor$，二分时可以直接将右边界设为它。
- 特判 $t=1$ 的情况，此时答案显然为 $n$。
- 校验的过程中，如果机器中已经有了 $Ct$ 只昆虫，可以直接返回结果。
- 校验前可以随机打乱昆虫序列。

代码：

```cpp
#include <algorithm>
#include <numeric>
#include <random>

using namespace std;

mt19937 rnd(114514);

void move_inside(int i);
void move_outside(int i);
int press_button();

const int kN = 2000;

bool b[kN], rb[kN];
int t, c, d[kN];

void Mi(int i) {
  move_inside(i), ++c, b[i] = 1;
}
void Mo(int i) {
  move_outside(i), --c, b[i] = 0;
}
bool C(int n, int k) {
  iota(d, d + n, 0);
  shuffle(d, d + n, rnd);
  fill_n(b, n, 0);
  for (int i = 0; i < n; ++i) {
    if (!rb[d[i]]) {
      Mi(d[i]);
      if (press_button() > k) {
        Mo(d[i]);
      }
      if (c == t * k) {
        break;
      }
    }
  }
  return c == t * k;
}
int min_cardinality(int n) {
  for (int i = 0; i < n; ++i) {
    Mi(i);
    if (press_button() > 1) {
      Mo(i);
    }
  }
  t = c;
  copy_n(b, n, rb);
  if (t == 1) {
    return n;
  }
  int l = 1, r = n / t;
  while (l < r) {
    int m = l + r + 1 >> 1;
    if (C(n, m)) {
      l = m;
      for (int i = 0; i < n; ++i) {
        rb[i] |= b[i];
      }
    } else {
      for (int i = 0; i < n; ++i) {
        if (b[i]) {
          Mo(i);
        } else {
          rb[i] = 1;
        }
      }
      r = m - 1;
    }
  }
  return l;
}
```


---

## 作者：Leasier (赞：4)

首先可以考虑朴素的二分，设现在正在考虑 $mid$，则我们需要判断是否每个数的出现次数都 $\geq mid$。

我们一个一个插入，若当前这个插进去后众数出现次数 $\leq mid$，则把它扔进去。最终判断现在机器里的数的个数 $x$ 是否等于 $mid \times cnt$ 即可，其中 $cnt$ 表示原来 $a$ 中不同数个数。

此时我们还需要求出 $cnt$。这里我们令 $mid = 1$ 求出机器中的数的个数即可。

但是每个函数的调用次数大概都是 $n(\lceil \log_2 (n - 1) \rceil + 1)$ 的，只有 $48$ 分。

注意到当这个 $mid$ 满足条件，则这次被新加入集合的数都在最终的集合里；当这个 $mid$ 不满足条件，则这次没有被加入集合的数都不在最终的集合里。

于是我们每次可以减少至少一半的讨论规模，于是总次数为 $T(n) = n + T(\frac{n}{2}) = 2n$，再加上一开始的 $n$ 次一共 $3n$ 次，看上去差不多能过了。

但是交上去会 PC 几个点，稍微剪一下枝再随机化讨论顺序即可。

代码：
```cpp
#include <algorithm>
#include <cstdlib>
#include <ctime>

using namespace std;

int cnt = 0;
int p[2007], push[2007];
bool vis[2007], mark[2007];

void move_inside(int i);
void move_outside(int i);
int press_button();

inline void check(int n, int m, int k){
	int goal = m * k;
	random_shuffle(p, p + n);
	for (register int i = 0; i < n && cnt < goal; i++){
		if (vis[p[i]]) continue;
		move_inside(p[i]);
		if (press_button() <= m){
			push[++cnt] = p[i];
		} else {
			move_outside(p[i]);
		}
	}
}

int min_cardinality(int n){
	int l = 2, r, unique, ans = 1;
	srand(time(NULL));
	for (register int i = 0; i < n; i++){
		p[i] = i;
	}
	random_shuffle(p, p + n);
	for (register int i = 0; i < n; i++){
		move_inside(p[i]);
		if (press_button() == 1){
			cnt++;
			vis[p[i]] = true;
		} else {
			move_outside(p[i]);
		}
	}
	r = n / cnt;
	unique = cnt;
	while (l <= r){
		int mid = (l + r) >> 1, pre = cnt;
		check(n, mid, unique);
		if (cnt == mid * unique){
			l = mid + 1;
			ans = mid;
			for (register int i = pre + 1; i <= cnt; i++){
				vis[push[i]] = true;
			}
		} else {
			r = cnt / unique;
			for (register int i = 0; i < n; i++){
				mark[i] = false;
			}
			for (register int i = pre + 1; i <= cnt; i++){
				mark[push[i]] = true;
			}
			cnt = pre;
			for (register int i = 0; i < n; i++){
				if (!mark[i]){
					vis[i] = true;
				} else {
					move_outside(i);
				}
			}
		}
	}
	return ans;
}
```

---

## 作者：Mirasycle (赞：1)

很有趣。先通过 $n$ 次操作，不断加入昆虫，删除重复种类昆虫，求出总的种类数 $c$。

这个出现的最大次数条件其实很难用，注意到我们拥有删除操作，因此我们考虑固定一个阈值 $B$，当加入某个昆虫之后，最大次数超过了 $B$ 我们就删除，这样子我们能控制所有 $>B$ 的出现次数都在 $B$。这样子我们就可以通过比较机器内的昆虫数以及 $B\times c$ 的大小来检查是否所有数都 $\ge B$。

有了以上技术，我们就可以二分答案了，直接做是 $O(n\log n)$ 的。

考虑加入以下若干优化。

首先是一些常数优化二分上界设置为 $\dfrac{n}{c}$。二分之前随机打乱加入序列，如果加入昆虫中途出现已经 $=c\times mid$ 的情况就直接合法退出二分过程。

还有一些保证复杂度的优化，假设当前二分区间为 $[l,r]$，所有数肯定已经加入了 $l$ 个在机器中，如果答案 $\ge mid$，就保留目前机器中的所有昆虫不进行删除，后续不加入这些即可。如果答案 $<mid$ 的话，每种昆虫只保留 $mid$ 种，也就是说这轮中加入失败的昆虫后续也不进行加入。这样子每次规模能接近除以 $2$，操作次数是 $T(n)=n+T(\dfrac{n}{2})=2n$，每次二分向右递归实际上会多出一些数，导致实际表现 $>3n$，配合上上一段中的常数优化可以通过本题。


```cpp
#include<bits/stdc++.h>
#include "insects.h"
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=2e3+10;
int vis[maxn],ban[maxn],p[maxn],n,tot=0,cnt=0;
void ins(int x){ cnt++; move_inside(x-1); }
void del(int x){ cnt--; move_outside(x-1); }
int min_cardinality(int N){
	n=N;
	for(int i=1;i<=n;i++){
		ins(i);
		if(press_button()==1) tot++,ban[i]=1;
		else del(i);
	}
	if(tot==1) return n;
	int l=1,r=n/tot;
	for(int i=1;i<=n;i++) p[i]=i;
	while(l<r){
		int mid=(l+r+1)>>1;
		for(int i=1;i<=n;i++) vis[i]=0;
		random_shuffle(p+1,p+1+n);
		for(int i=1;i<=n;i++){
			if(tot*mid==cnt) break;
			if(ban[p[i]]) continue;
			ins(p[i]);
			if(press_button()>mid) del(p[i]);
			else vis[p[i]]=1; 
		}
		if(tot*mid==cnt){
			l=mid;
			for(int i=1;i<=n;i++)
				if(vis[i]) ban[i]=1;
		}else{
			r=mid-1;
			for(int i=1;i<=n;i++)
				if(vis[i]) del(i);
				else ban[i]=1;
		}
	}
	return l;
}
```

---

## 作者：william555 (赞：1)

假设一共有 $m$ 种数。  
首先有一种操作 $O(nm)$ 的朴素做法，即把每种昆虫有多少个求出来，可以获得 10 分。  

很自然地往二分答案的方向想。考虑怎么判断答案是否大于等于 $mid$？

对于一次 `check`，考虑一个数一个数地往集合里加，如果当前返回值大于 $ mid $，那么就将这个数删掉，假设第 $i$ 种数有 $cnt_i$，最后集合的大小就是 $\sum \min(cnt_i,mid)$。如果每一种数都至少有 $ mid $ 个，那么集合的大小就应该是 $m\cdot mid$。

可以先用 $ n $ 次操作问出 $ m $，然后朴素地二分就可以做到操作 $ n(\log m+1)$，大概可以获得 45 分。

考虑二分的过程，假设在处理 $ [l,r] $ 区间。如果 `check(mid)` 为 true，那么现在已经在集合内的数一定在最终的集合中。如果 `check(mid)` 为 false，那么现在不在集合内的数一定不在最终的集合中。所以每一次 `check` 都可以确定一半的数是否在最终的集合中，需要在以后操作的数就会减半，询问次数 $ T(n)=T(n/2)+n =2n $。

总询问次数大概是 $3n$ 次。

结果写完一交，99 分，怎么回事？

令 $ k=\lfloor n/m \rfloor$，开始二分答案时还未确定的位有 $ (k-1) \cdot m+(n\bmod m) $ 个，如果递归每层都往右走，那么还未确定的位就会一直包含 $n \bmod m$ 个多余的位置，所以最后操作次数会略多于 $3n$。   
考虑到如果每次都往右走，那么每一轮可能很快集合大小就到了 $m \cdot mid$，将序列 shuffle 以后，每次发现集合大小已经位 $m \cdot mid$ 就 break。就可以获得 100 分。

```c++
#include "insects.h"
#include<bits/stdc++.h>
using namespace std;
int n,m,o,k;
int a[2005],b[2005];
void ins(int x){
	o++,move_inside(b[x]);
}
void del(int x){
	o--,move_outside(b[x]);
}
int ask(){return press_button();}
int ans;
void solve(int l,int r){
	if(l>r)return;
	int mid=l+r>>1;
	int c1=0,c2=0;
	for(int i=1;i<=n;i++){
		if(a[i])continue;
		ins(i);a[i]=-1;c1++;
		if(ask()>mid)del(i),a[i]=-2,c1--,c2++;
		if(o==m*mid)break;
	}
	if(o==m*mid){
		ans=mid;
		for(int i=1;i<=n;i++){
			if(a[i]==-1)a[i]=1,k--;
			if(a[i]==-2)a[i]=0;
		}
		solve(mid+1,r);
	}else{
		for(int i=1;i<=n;i++){
			if(a[i]==-1)del(i),a[i]=0;
			if(a[i]==-2)a[i]=2,k--;
		}
		solve(l,mid-1);
	}
}
int min_cardinality(int N) {
	n=N;k=n;
	for(int i=1;i<=n;i++)b[i]=i-1;
	mt19937 rd(time(0));
	shuffle(b+1,b+n+1,rd);
	for(int i=1;i<=n;i++){
		ins(i);a[i]=1;k--;
		if(ask()>1)del(i),a[i]=0,k++;
    }
	m=o;
	ans=1;
	solve(2,n/m);
    return ans;
}
```

---

## 作者：huangzirui (赞：1)

考虑类二分答案的过程。

首先容易花 $n$ 次操作算出种类。

记共有 $n$ 只昆虫，$c$ 个种类的最小步数为 $F(n,c)$。

枚举一个答案 $ans$，接下来 $O(n)$ check 它：贪心往机器不断加昆虫使得基数恰好不多于 $ans$。记第 $i$ 种昆虫有 $a_i$ 只，此时每种昆虫被加入了 $\min(a_i,ans)$ 只。

于是有这样的策略：

1. 如果机器内昆虫数为 $c\times ans$，那么就递归到没加入的昆虫的一侧即 $F(n-c\times ans,c)$。

1. 否则递归到被加入的昆虫一侧，即 $F(c\times ans,c)$。

取 $ans=\dfrac{n}{c}$，毛估估一下 $F(n,c)$ 不超过 $2n$。

调调参就能过。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P8494)

**题目大意**

> 给定 $n$ 个元素和一个集合 $S$，初始为空，每次操作可以单点插入或删除，或询问交互库 $S$ 中每种颜色出现次数的最大值。
>
> 每种操作至多进行 $3n$ 次，求出所有颜色出现次数的最小值。
>
> 数据范围：$n\le 2000$。

**思路分析**

考虑二分答案，先求颜色数 $c$，依次加入所有元素，如果加入后答案 $>1$ 就删除该元素，最终 $c=|S|$。

判断答案是否 $\ge k$，那么依次加入 $S$ 中的每个元素，如果返回答案 $>k$ 就删除该元素。

这样扫一遍能保证每种颜色的元素至多 $k$ 个，如果 $|S|=ck$ 说明答案 $\ge k$，否则答案 $<k$。

注意到答案 $\ge k$ 时可以删掉 $S$ 中元素，否则只要考虑 $S$ 中元素，因此每次操作元素数减半，次数为 $n+2n=3n$。

但由于 $ck$ 不一定恰好等于 $\dfrac n2$，因此加上一些随机化和剪枝，然后就能通过了。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#include "insects.h"
using namespace std;
mt19937 rnd(time(0));
const int MAXN=2001;
int min_cardinality(int n) {
	int siz=0,col=0;
	auto add=[&](int x) -> void { move_inside(x), ++siz; };
	auto del=[&](int x) -> void { move_outside(x),--siz; };
	auto count=[&]() -> int { return press_button(); };
	vector <int> Q,ins,ers;
	for(int i=0;i<n;++i) {
		add(i);
		if(count()>1) del(i);
		else ins.push_back(i),++col;
	}
	for(int u:ins) del(u);
	ins.clear();
	for(int i=0;i<n;++i) Q.push_back(i);
	int l=1,r=n/col,res=r;
	while(l<=r) {
		int mid=(l+r)>>1;
		ins.clear(),ers.clear();
		shuffle(Q.begin(),Q.end(),rnd);
		for(int u:Q) {
			if(siz==mid*col) ers.push_back(u);
			else {
				add(u);
				if(count()>mid) del(u),ers.push_back(u);
				else ins.push_back(u);
			}
		}
		if(siz==mid*col) res=mid,l=mid+1,Q=ers;
		else {
			Q=ins,r=mid-1;
			for(int u:ins) del(u);
		}
	}
	return res;
}
```

---

## 作者：Purslane (赞：0)

# Solution

首先这道题有一些简单的 $O(n \log n)$ 做法。比如，先求出哪些昆虫在它左边没有同种类型的昆虫，将其重标号之后，可以用 $2$ 次操作判定这只昆虫所属种类某一二进制位是否是 $1$。

这样可以直接得出昆虫的种类信息，可以获得 $50$ 分左右，依赖实现。

考虑如何判定答案是否 $\ge k$。容易想到这样的实现方式：不断往里面塞昆虫，如果此时最大数超过了 $k$ 就将其剔除。这样最后每种昆虫的个数都和 $k$ 取 $\min$。如果容器中的昆虫数量 $\ge cnt \times k$，则每种昆虫都至少有 $k$ 只。当然 $cnt$ 需要你 $n$ 次操作求出。

考虑二分答案。二分答案检验区间是 $[l,r]$ 时，显然所有昆虫都至少有 $l-1$ 只。那么我们保证容器中每种昆虫已经有了恰好 $l-1$ 只（这是我们二分的假设。我们在二分的过程中要一直保证其成立）。

检验 $mid$，执行上述流程。

如果满足要求，那么直接令 $l \leftarrow mid+1$；否则，发现现在不在容器中的昆虫都是没用的。

容易证明，每次操作都差不多只会进行 $cnt \times (r-l+1)$ 次操作。也就是说，每次检查的昆虫都会减半。这样差不多就是 $3n$ 次操作。

但是由于可能会上取整啥的，所以并不是严格 $3n$ 次。随便加一点乱搞就可以降低次数通过此题。

哎感觉这道题想到二分答案就做完了，可是我怎么想不到二分答案呢。真就连紫题都不会了。。。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2000+10;
void move_inside(int i);
void move_outside(int i);
int press_button();
int n,ok[MAXN];
int min_cardinality(int N) {
	n=N;
	int cnt=0;
	ffor(i,0,n-1) {
		move_inside(i);
		if(press_button()==1) ok[i]=1,++cnt;
		else move_outside(i);	
	}
	ffor(i,0,n-1) if(ok[i]) move_outside(i),ok[i]=0;
	int l=1,r=n,ans=0;
	mt19937 myrand(time(NULL));
	while(l<=r) {
		int mid=(l+r>>1);
		//对 mid 进行 check
		//判断答案是否 >=mid
		vector<int> vc;	
		ffor(i,0,n-1) if(!ok[i]) vc.push_back(i);
		shuffle(vc.begin(),vc.end(),myrand);
		vector<int> del,ins;
		int tot=0;
		for(auto id:vc) {
			move_inside(id);
			if(press_button()>mid) del.push_back(id),move_outside(id);
			else ins.push_back(id),tot++;
			if(tot==1ll*cnt*(mid-l+1)) break ;	
		}
		if(tot==cnt*(mid-l+1)) {
			for(auto id:ins) ok[id]=1;
			ans=mid,l=mid+1;
		}
		else {
			for(auto id:del) ok[id]=1;
			for(auto id:ins) move_outside(id);
			r=mid-1;	
		}
	}
	return ans;
}
```

---


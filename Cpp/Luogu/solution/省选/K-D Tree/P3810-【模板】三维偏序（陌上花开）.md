# 【模板】三维偏序（陌上花开）

## 题目背景

这是一道模板题，可以使用 bitset，CDQ 分治，KD-Tree 等方式解决。

## 题目描述

有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \leq a_i $ 且 $ b_j \leq b_i $ 且 $ c_j \leq c_i $ 且 $ j \ne i $ 的 $j$ 的数量。

对于 $ d \in [0, n) $，求 $ f(i) = d $ 的数量。

## 说明/提示

$ 1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。


## 样例 #1

### 输入

```
10 3
3 3 3
2 3 3
2 3 1
3 1 1
3 1 2
1 3 1
1 1 2
1 2 2
1 3 2
1 2 1
```

### 输出

```
3
1
3
0
1
0
1
0
0
1
```

# 题解

## 作者：FlashHu (赞：177)

安利蒟蒻[CDQ分治总结](https://www.cnblogs.com/flashhu/p/9381075.html)

分治就是分治，“分而治之”的思想。

那为什么会有CDQ分治这样的称呼呢？

这一类分治有一个重要的思想——用一个子问题来计算对另一个子问题的贡献。

有了这种思想，就可以方便地解决更复杂的问题。

这样一句话怎样理解好呢？还是做做题目吧。

三维偏序问题，即给出若干元素，每个元素有三个属性值$a,b,c$，询问对于每个元素$i$，满足$a_j\leq a_i,b_j\leq b_i,c_j\leq c_i$的$j$的个数

不用着急，先从简单的问题开始

试想一下二位偏序也就是$a_j\leq a_i,b_j\leq b_i$怎么做

先按$a$为第一关键字，$b$为第二关键字排序，那么我们就保证了第一维$a$的有序。

于是，对于每一个$i$，只可能$1$到$i-1$的元素会对它有贡献，那么直接查$1$到$i-1$的元素中满足$b_j\leq b_i$的元素个数。

具体实现？动态维护$b$的树状数组，从前到后扫一遍好啦，$O(n\log n)$。

那么三维偏序呢？我们只有在保证前两位都满足的情况下才能计算答案了。

仍然按$a$为第一关键字，$b$为第二关键字，$c$为第三关键字排序，第一维保证左边小于等于右边了。

为了保证第二维也是左边小于等于右边，我们还需要排序。

想到归并排序是一个分治的过程，我们可不可以在归并的过程中，统计出在子问题中产生的对答案贡献呢？

现在我们有一个序列，我们把它递归分成两个子问题，子问题进行完归并排序，已经保证$b$有序。此时，两个子问题间有一个分界线，原来第一维左边小于等于右边，所以现在分界线左边的任意一个的$a$当然还是都小于右边的任意一个。那不等于说，只有分界线左边的能对右边的产生贡献？

于是，问题降到了二维。我们就可以排序了，归并排序（左边的指针为$j$，右边的为$i$）并维护$c$的树状数组，如果当前$b_j\leq b_i$，说明$j$可以对后面加入的满足$c_j\leq c_i$的$i$产生贡献了，把$c_j$加入树状数组；否则，因为后面加入的$j$都不会对$i$产生贡献了，所以就要统计之前被给的所有贡献了，查询树状数组$c_i$的前缀和。

这是在分治中统计的子问题的答案，跟总答案有怎样的关系呢？容易发现，每个子问题统计的只有跨越分界线的贡献，反过来看，每一个能产生贡献的$i,j$，有且仅有一个子问题，两者既同时被包含，又在分界线的异侧。那么所有子问题的贡献加起来就是总答案。

算法的大致思路就是这样啦。至于复杂度，$T(n)=O(n\log k)+2T(\frac 2 n)=O(n\log n\log k)$。

当然还有不少细节问题。

最大的问题就在于，可能有完全相同的元素。这样的话，本来它们相互之间都有贡献，可是cdq的过程中只有左边的能贡献右边的。这可怎么办呢？

我们把序列去重，这样现在就没有相同的了。给现在的每个元素一个权值$v$等于出现的次数。中间的具体实现过程也稍有变化，在树状数组中插入的值是$v$而不是$1$了，最后统计答案时，也要算上相同元素内部的贡献，`ans+=v-1`。

写法上，为了防止sort和归并排序中空间移动太频繁，没有对每个元素封struct，这样的话就要膜改一下cmp函数（蒟蒻也是第一次发现cmp可以这么写）

蒟蒻还是觉得开区间好写一些吧。。。当然闭区间好理解些。。。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define RG register
#define R RG int
using namespace std;
const int N=1e5+9,SZ=2.2e6;
char buf[SZ],*pp=buf-1;//fread必备
int k,a[N],b[N],c[N],p[N],q[N],v[N],cnt[N],ans[N],*e;
inline int in(){
    while(*++pp<'-');
    R x=*pp&15;
    while(*++pp>'-')x=x*10+(*pp&15);
    return x;
}
void out(R x){
    if(x>9)out(x/10);
    *++pp=x%10|'0';
}
inline bool cmp(R x,R y){//直接对数组排序，注意三关键字
    return a[x]<a[y]||(a[x]==a[y]&&(b[x]<b[y]||(b[x]==b[y]&&c[x]<c[y])));
}
inline void upd(R i,R v){//树状数组修改
    for(;i<=k;i+=i&-i)e[i]+=v;
}
inline int ask(R i){//树状数组查前缀和
    R v=0;
    for(;i;i-=i&-i)v+=e[i];
    return v;
}
void cdq(R*p,R n){//处理一个长度为n的子问题
    if(n==1)return;
    R m=n>>1,i,j,k;
    cdq(p,m);cdq(p+m,n-m);//递归处理
    memcpy(q,p,n<<2);//归并排序
    for(k=i=0,j=m;i<m&&j<n;++k){
        R x=q[i],y=q[j];
        if(b[x]<=b[y])upd(c[p[k]=x],v[x]),++i;//左边小，插入
        else  cnt[y]+=ask(c[p[k]=y])     ,++j;//右边小，算贡献
    }
    for(;j<n;++j)cnt[q[j]]+=ask(c[q[j]]);//注意此时可能没有完成统计
    memcpy(p+k,q+i,(m-i)<<2);
    for(--i;~i;--i)upd(c[q[i]],-v[q[i]]);//必须这样还原树状数组，memset是O(n^2)的
}
int main(){
    fread(buf,1,SZ,stdin);
    R n=in(),i,j;k=in();e=new int[k+9];
    for(i=0;i<n;++i)
        p[i]=i,a[i]=in(),b[i]=in(),c[i]=in();
    sort(p,p+n,cmp);
    for(i=1,j=0;i<n;++i){
        R x=p[i],y=p[j];++v[y];//模仿unique双指针去重，统计v
        if(a[x]^a[y]||b[x]^b[y]||c[x]^c[y])p[++j]=x;
    }
    ++v[p[j++]];
    cdq(p,j);
    for(i=0;i<j;++i)
        ans[cnt[p[i]]+v[p[i]]-1]+=v[p[i]];//答案算好
    for(pp=buf-1,i=0;i<n;++i)
        out(ans[i]),*++pp='\n';
    fwrite(buf,1,pp-buf+1,stdout);
}
```


---

## 作者：Ireliaღ (赞：41)

**树状数组套值域线段树**

## 三维偏序

看到三维偏序，最简单直接的思路就是先按照$x$把元素排序，然后按顺序把每个元素放进二维数据结构，统计二维前缀和，即为$x$、$y$、$z$都不超过该元素的元素个数。

以下为二维线段树（树套树）代码

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1e5 + 5;
const int MAXK = 2e5;

int n, k, cnt[MAXN];

struct Data{
    int x, y, z;
    
    int operator < (const Data &o) const {
        return x != o.x ? (x < o.x) : (y != o.y ? (y < o.y) : (z < o.z));
    }
    
    int operator == (const Data &o) const {
        return x == o.x && y == o.y && z == o.z;
    }
}data[MAXN];

struct Seg{
    struct Node{
        int val;
        Node *ch[2];
        
        Node(int val = 0) : val(val) {
            ch[0] = ch[1] = NULL;
        }
    };
    
    Node *rt;
    
    Seg() {
        rt = NULL;
    }
    
    void Modify(Node *&now, int pos, int val = 1, int nl = 1, int nr = MAXK) {
        if (!now) now = new Node();
        if (nl == nr) {
            now->val += val;
            return;
        }
        int mid = nl + nr >> 1;
        if (pos <= mid) Modify(now->ch[0], pos, val, nl, mid);
        else Modify(now->ch[1], pos, val, mid + 1, nr);
        now->val = (now->ch[0] ? now->ch[0]->val : 0) + (now->ch[1] ? now->ch[1]->val : 0);
    }
    
    int Query(Node *now, int l, int r, int nl = 1, int nr = MAXK) {
        if (!now) return 0;
        if (l == nl && r == nr) return now->val;
        int mid = nl + nr >> 1;
        if (r <= mid) return Query(now->ch[0], l, r, nl, mid);
        else if (l > mid) return Query(now->ch[1], l, r, mid + 1, nr);
        return Query(now->ch[0], l, mid, nl, mid) + Query(now->ch[1], mid + 1, r, mid + 1, nr);
    }
};

Seg tree[MAXK * 4 + 5];

void Modify(int now, int posx, int posy, int val, int nl = 1, int nr = MAXK) {
    tree[now].Modify(tree[now].rt, posy, val);
    if (nl == nr) return;
    int mid = nl + nr >> 1;
    if (posx <= mid) Modify(now << 1, posx, posy, val, nl, mid);
    else Modify(now << 1 | 1, posx, posy, val, mid + 1, nr);
}

int Query(int now, int xl, int xr, int yl, int yr, int nl = 1, int nr = MAXK) {
    if (xl == nl && xr == nr) return tree[now].Query(tree[now].rt, yl, yr);
    int mid = nl + nr >> 1;
    if (xr <= mid) return Query(now << 1, xl, xr, yl, yr, nl, mid);
    else if (nl > mid) return Query(now << 1 | 1, xl, xr, yl, yr, mid + 1, nr);
    return Query(now << 1, xl, mid, yl, yr, nl, mid) + Query(now << 1 | 1, mid + 1, xr, yl, yr, mid + 1, nr);
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> data[i].x >> data[i].y >> data[i].z;
    sort(data + 1, data + n + 1);
    int sum = 1;
    for (int i = 1; i <= n; i++) {
        if (data[i + 1] == data[i]) {
            sum++;
            continue;
        }
        Modify(1, data[i].y, data[i].z, sum);
        int res = Query(1, 1, data[i].y, 1, data[i].z);
        cnt[res] += sum;
        sum = 1;
    }
    for (int i = 1; i <= n; i++) cout << cnt[i] << endl;
    return 0;
}
```

~~你`Ctrl+C`、`Ctrl+v`交上去，发现TLE70~~

考虑到值域不大，并且线段树常数较大，可以把外层的非动态开点线段树换成树状数组，减小常数，以下为AC代码。

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1e5 + 5;
const int MAXK = 2e5;

int n, k, cnt[MAXN];

struct Data{
    int x, y, z;
    
    int operator < (const Data &o) const {
        return x != o.x ? (x < o.x) : (y != o.y ? (y < o.y) : (z < o.z));
    }
    
    int operator == (const Data &o) const {
        return x == o.x && y == o.y && z == o.z;
    }
}data[MAXN];

struct Seg{
    struct Node{
        int val;
        Node *ch[2];
        
        Node(int val = 0) : val(val) {
            ch[0] = ch[1] = NULL;
        }
    };
    
    Node *rt;
    
    Seg() {
        rt = NULL;
    }
    
    void Modify(Node *&now, int pos, int val, int nl, int nr) {
        if (!now) now = new Node();
        if (nl == nr) {
            now->val += val;
            return;
        }
        int mid = nl + nr >> 1;
        if (pos <= mid) Modify(now->ch[0], pos, val, nl, mid);
        else Modify(now->ch[1], pos, val, mid + 1, nr);
        now->val = (now->ch[0] ? now->ch[0]->val : 0) + (now->ch[1] ? now->ch[1]->val : 0);
    }
    
    int Query(Node *now, int l, int r, int nl, int nr) {
        if (!now) return 0;
        if (l == nl && r == nr) return now->val;
        int mid = nl + nr >> 1;
        if (r <= mid) return Query(now->ch[0], l, r, nl, mid);
        else if (l > mid) return Query(now->ch[1], l, r, mid + 1, nr);
        return Query(now->ch[0], l, mid, nl, mid) + Query(now->ch[1], mid + 1, r, mid + 1, nr);
    }
};
/*
Seg tree[MAXK * 4 + 5];

void Modify(int now, int posx, int posy, int val, int nl = 1, int nr = MAXK) {
    tree[now].Modify(tree[now].rt, posy, val);
    if (nl == nr) return;
    int mid = nl + nr >> 1;
    if (posx <= mid) Modify(now << 1, posx, posy, val, nl, mid);
    else Modify(now << 1 | 1, posx, posy, val, mid + 1, nr);
}

int Query(int now, int xl, int xr, int yl, int yr, int nl = 1, int nr = MAXK) {
    if (xl == nl && xr == nr) return tree[now].Query(tree[now].rt, yl, yr);
    int mid = nl + nr >> 1;
    if (xr <= mid) return Query(now << 1, xl, xr, yl, yr, nl, mid);
    else if (nl > mid) return Query(now << 1 | 1, xl, xr, yl, yr, mid + 1, nr);
    return Query(now << 1, xl, mid, yl, yr, nl, mid) + Query(now << 1 | 1, mid + 1, xr, yl, yr, mid + 1, nr);
}
*/

Seg tree[MAXK + 5];

int LB(int x) {
    return x & (-x);
}

void Modify(int posx, int posy, int val) {
    for (int i = posx; i <= k; i += LB(i)) 
        tree[i].Modify(tree[i].rt, posy, val, 1, k);
}

int Query(int x, int y) {
    int ret = 0;
    for (int i = x; i; i -= LB(i)) ret += tree[i].Query(tree[i].rt, 1, y, 1, k);
    return ret;
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> data[i].x >> data[i].y >> data[i].z;
    sort(data + 1, data + n + 1);
    int sum = 1;
    for (int i = 1; i <= n; i++) {
        if (data[i + 1] == data[i]) {
            sum++;
            continue;
        }
        Modify(data[i].y, data[i].z, sum);
        int res = Query(data[i].y, data[i].z);
        cnt[res] += sum;
        sum = 1;
    }
    for (int i = 1; i <= n; i++) cout << cnt[i] << endl;
    return 0;
}
```

---

## 作者：panyf (赞：39)

提供一篇 bitset 的题解。

bitset 可以用来求解高维偏序问题，记 $m$ 为维数，则时间复杂度为 $O(\dfrac{n^2m}{w})$。

开 $n$ 个 bitset，$b_{i,j}=1$ 表示 $j$ 每一维都不超过 $i$。初始化所有 $b_{i,j}=1$。

先枚举每一维，然后对所有数按这一维排序。

开一个新的 bitset s，按这一维从小到大处理所有数，处理到 $i$ 时 $s_j=1$ 表示当前维 $j$ 不超过 $i$。

$j$ 是单调的，可以用一个指针维护。

每次 `b[i]&=s` 即可。

$100000$ 的 bitset 开不下，要用分组 bitset。

就是将点分为若干组，每组 $B$ 个，每次只求出这 $B$ 个点对应的 bitset，这样只需要开 $B$ 个 bitset。

可能略微卡常。

[AC 提交记录](https://www.luogu.com.cn/record/51314650)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3;
int p[3][N],a[3][N],w[N];
bitset<N>b[9999],s;
int main(){
	int*tp,*ta,n,l,r,i,j,k,o;
	for(i=1,scanf("%d%*d",&n);i<=n;++i)for(j=0;j<3;++j)scanf("%d",a[j]+i),p[j][i]=i;
	for(i=0;i<3;++i)sort(p[i]+1,p[i]+n+1,[=](int x,int y){return a[i][x]<a[i][y];});//按每一维排序
	for(l=1;l<=n;l=r+1){//分组bitset，每组9991个
		for(i=l,r=min(l+9991,n);i<=r;++i)b[i-l].set();
		for(i=0;i<3;++i)for(tp=p[i],ta=a[i],s.reset(),j=k=1;j<=n;++j){
			for(o=tp[j];k<=n&&ta[tp[k]]<=ta[o];)s[tp[k++]]=1;
			if(l<=o&&o<=r)b[o-l]&=s;
		}
		for(i=l;i<=r;++i)++w[b[i-l].count()];
	}
	for(i=1;i<=n;++i)printf("%d\n",w[i]);
	return 0;
}
```

---

## 作者：complete_binary_tree (赞：29)

本题解使用 CDQ 分治做法。

## 什么是 CDQ 分治？

CDQ 分治是由 $2008$ 年 IOI 金牌得主陈丹琦在高中时整理并总结的一种分治思想[^1]，可以用于解决偏序问题、一些动规的优化、离线按时间顺序处理等。

CDQ 分治最经典的应用就是处理一些点对 $(i,j)(i \le j)$，此时它的主要思想如下：

1. 把序列从 $mid$ 切开，分成两半；

2. 把点对分成三类：

   - 第一类是 $j \le mid$，即都在左半部分；
  
   - 第二类是 $i > mid$，即都在右半部分；
  
   - 最后一类是横跨 $mid$ 的部分。
  
3. 左右两半分别递归，处理前两类点对。

4. 想办法处理最后一类点对。

以本题为例，本题是要找到一些点对满足偏序关系。

首先我们可以对第一维 $a$ 进行排序，这样序列后面的数一定大于序列前面的数，我们就可以少处理一维。

接着，我们在处理第二维的时候进行 CDQ 分治。

对于一个 $[l,r]$ 的区间，我们可以如此做：

- 首先先处理 $[l,mid]$ 和 $(mid,r]$。（$mid$ 是区间中点）

  - 如果 $l=r$，那么一定没有贡献，可以直接返回。

- 然后，我们处理左端点在 $[l,mid]$，右端点在 $(mid,r]$ 的点对的贡献。

  - 由于我们已经按 $a$ 排好序，所以右区间 $(mid,r]$ 的点的 $a$ 值一定大于左区间。
 
  - 此时我们把两个区间分别按照 $b$ 排序。
 
    - 这样虽然会打乱区间内 $a$ 的顺序，但是我们只考虑跨区间的贡献。而且区间内的贡献我们在前面已经算完了，后面只会算更大块区间的两侧贡献，而大块之间的 $a$ 的顺序并不会被排序影响。
   
  - 然后我们用树状数组+双指针法处理 $c$ 的偏序关系。
 
    - 由于我们只要算跨区间的贡献（$b_i,c_i$ 都小于 $b_j,c_j$，且 $i$ 在左区间、$j$ 在右区间的点对 $i,j$ 个数），所以树状数组上第 $i$ 位存 $c_x=i$ 的 $x$ 在左区间出现了多少次。（需要离散化）
   
    - 我们两个指针 $x,y$ 分别扫左区间和右区间。当 $y$ 增加后，我们把满足 $b_x \le b_y$ 的 $c_x$ 都加入树状数组。由于 $b$ 是有序的，所以可以用一个指针扫。等到所有满足条件的 $c_x$ 都加入树状数组后，我们只需查询树状数组上 $1 \sim c_y$ 的前缀和即是右端点为 $y$ 的贡献。
   
- 然后我们退回上一层，继续这样操作，直到求出所有答案。

这就是本题的 CDQ 分治思路。

## 正确性 & 时间复杂度分析

由于我们开始对 $a$ 排好了序，而我们是从下到上 CDQ 分治的，所以 $a$ 这一维的偏序可以保证正确。

然后，我们对 $b$ 进行排序，使用双指针确保加入树状数组的数的 $b$ 值都小于要求贡献的数的 $b$ 值。

最后，查询树状数组中的 $1 \sim c_y$ 的前缀和，由于是把左区间的数加入树状数组，所以可以保证不重复。

时间复杂度：

- 离散化 & $a$ 排序：$O(n \log n)$

- 对于 CDQ 分治：

  - $b$ 排序 & 树状数组：$O(n \log n)$
 
  - 总时间复杂度：$T(n) = O(n \log n) + 2T(\frac n 2) = O(n \log^2 n)$
 
所以时间复杂度是 $O(n \log^2 n)$。

## 常数优化

对 $b$ 排序如果每次都用 `sort`，常数较大。我们发现因为我们在往下递归的时候完成了左右两部分的 $b$ 的排序，所以我们在这层可以直接把这两部分归并，在排序部分做到 $O(n)$，这样总时间复杂度的第二个 $\log$ 就只有树状数组的小常数 $O(n \log n)$。

## 实现细节

- **记得清空树状数组！！！** 不能使用暴力清空（时间复杂度会变成 $O(n^2 \log n)$），怎么加入的怎么清空（实在不理解你可以再来一遍双指针，但是不要再统计一遍答案）

- **要去重！！！** 重复的元素可以互相贡献，但是上述算法处理不了重复元素（只会算一次贡献）。**去重后树状数组要加上这个元素的个数**。

- 前面对 $a$ 排序时 $a$ 相等要对 $b$ 排序，$b$ 也相等要对 $c$ 排序。CDQ 内对 $b$ 排序，$b$ 相等时可以不用对 $c$ 排序。（请读者思考一下为什么[^2]）

- 还是不对？看看讨论区“警示后人”。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5, A = 2e5 + 5;

struct node{
	int ans, gs;
	int a, b, c;
};

node a[N], b[N];
int n, _n, k, bowl[N];
long long ans[N];

// 对a排序 
bool cmp(node x, node y){
	// 注意a/b相等时的处理 
	if(x.a == y.a) 
		if(x.b == y.b) 
			return x.c < y.c;
		else
			return x.b < y.b;
	return x.a < y.a;
}
// cdq内对b排序 
bool cmp2(node x, node y){ 
	/*if(x.b == y.b)
		return x.c < y.c;*/
	// 上面这个if可要可不要 
	return x.b < y.b;
}

// 树状数组 
struct treez{
	int t[A];
	int find(int x){
		int ans = 0;
		for(; x; x -= (x & (-x))) ans += t[x];
		return ans;
	}
	void add(int x, int y){
		for(; x <= 2e5; x += (x & (-x))) t[x] += y;
	}
} tr;

//cdq主体 
void cdq(int l, int r){
	if(l == r) return ;
	int mid = (l + r) >> 1;
	
	// 1.递归左右 
	cdq(l, mid), cdq(mid + 1, r);
	
	// 2.排序 
	sort(a + l, a + mid + 1, cmp2), sort(a + mid + 1, a + r + 1, cmp2);
	
	// 3.双指针求贡献 
	int i = l, j = mid + 1;
	for(; j <= r; ++j){
		while(i <= mid && a[i].b <= a[j].b) tr.add(a[i].c, a[i].gs), i++;
		a[j].ans += tr.find(a[j].c);
	}
	
	// 4.清空树状数组 
	for(int k = l; k < i; ++k){
		tr.add(a[k].c, -a[k].gs);
	}
}

int main(){
	scanf("%d%d", &n, &k);
	for(int i = 1; i <= n; ++i)
		scanf("%d%d%d", &b[i].a, &b[i].b, &b[i].c);
		
	sort(b + 1, b + n + 1, cmp);
	
	// 神秘の去重 
	int w = 0;
	for(int i = 1; i <= n; ++i){
		++w;
		if(b[i].a != b[i + 1].a || b[i].b != b[i + 1].b || b[i].c != b[i + 1].c){
			a[++_n] = b[i];
			a[_n].gs = w;
			w = 0;
		}
	}
	
	cdq(1, _n);
	
	// 相同数字可以重复贡献，别忘了加上 
	for(int i = 1; i <= _n; ++i) bowl[a[i].ans + a[i].gs - 1] += a[i].gs;
	
	for(int i = 0; i < n; ++i) printf("%d\n", bowl[i]);
	return 0;
}
```


[^1]: [从《Cash》谈一类分治算法的应用](https://www.cs.princeton.edu/~danqic/papers/divide-and-conquer.pdf)

[^2]: 前者可能导致 $b(c)$ 更大的被分在左区间，而后者由于加入树状数组的先后顺序/查询的先后顺序没有影响，所以后者不在相等时排序 $c$ 也是可以的。

---

## 作者：lao_wang (赞：22)

## 修改

2025.7.1 改了一些东西。

## 使用算法

整体二分、树状数组、排序。

## 正文

写过线段树的都知道，线段树查区间和的时候是由几段具有可加性的贡献合并得出的，这会给降维带来什么启示？

一次三维偏序的询问是否能拆成（一定条件下的三维偏序，即只要满足二维偏序条件则满足三维偏序条件）若干个具有可加性的二维偏序的贡献加起来呢？

这显然是可以的，但是这个条件该怎么找才能使得复杂度没有问题呢？

在上线段树看看。（暂时将整体二分理解为权值线段树）

在线段树上的父节点连向的两个子节点为：一段区间由 $mid$ 划分为 2 个区间：小于等于 $mid$ 的左区间；大于 $mid$ 的右区间。

那么对于任意一维条件通过与 $mid$ 的大小关系划分使得左区间的三元组该条件小于等于 $mid$，右区间的三元组该条件大于 $mid$。（之后默认划分的第一维条件）

这样划分后可以发现：

$$\forall (a_i,b_i,c_i)\in L,(a_j,b_j,c_j)\in R$$

$$a_i<a_j$$

这就消去了第一维。

再将左区间的所有三元组视为数值，右区间的左右三元组视为询问，去求解右区间在左区间中满足后两维偏序条件的贡献，直接上个二维偏序求解即可求出右区间三元组的部分答案（排序 + 树状数组）。

因为对于自己区间的三元组并没有进行贡献的转换，所以左右区间需要继续划分直至没有三元组可以视为数值（或区间左右端点重合）。（整个过程中所作为划分依据的那一维不能在途中改成其他维。）

这满足使用整体二分需要满足的性质：

1. 询问的答案具有可二分性。

2. 修改对判定答案的贡献互相独立，修改之间互不影响效果。

3. 修改如果对判定答案有贡献，则贡献为一确定的与判定标准无关的值。

4. 贡献满足交换律，结合律，具有可加性。

5. 题目允许使用离线算法。

   —— 许昊然《浅谈数据结构题几个非经典解法》

### 伪代码

```cpp

void solve(int l,int r,int L,int R){  //l、r表示当前需要划分值域，L、R表示当前需要划分的三元组下标
	if(边界) return ;
	int mid=(l+r)>>1 ;
	for(int i=L;i<=R;i++){
		if(操作1){
			 if(跟mid的关系) 划分区间;
             else 划分区间; 
		}else if(……)…… 
	}
	划分给左区间
	划分给右区间
	递归左区间 
	递归右区间 
}
```

将刚刚的思路整理一下就可以得到整体二分的写法了。

### 正确性

#### 是否会算漏？

对于第一维（二三维因为是直接套用的二维偏序故不在赘述），当 $a_i \leq a_j$ 时而三元组 $i$ 并没有参与过三元组 $j$ 的贡献计算即在递归过程中 $i$ 所划分到的区间始终在右区间或与 $j$ 同侧。

$$\because a_i<a_j$$

$$\therefore \exists mid\in [a_i,a_j)$$

此时 $a_i$ 在左区间，$a_j$ 在右区间。

故对于 $\forall a_i \leq a_j$，均存在 $a_i$ 在左区间，$a_j$ 在右区间。

#### 是否会算重？

当 $a_i \leq a_j$ 且 $i$ 对 $j$ 计算过贡献时，$i$、$j$ 在同一大区间（当前递归的值域），$i$ 一定在左区间，$j$ 一定在右区间。

而此后的递归不涉及区间合并所以 $i$、$j$ 不会再次在同一大区间。

#### 复杂度

对于一个询问需要的操作数等价于在权值线段树上查找某数值所在叶子节点，所以操作数为 $N\log V$。

又因为在每个三元组在每次操作需要调用一次数据结构（树状数组）。

所以复杂度为 $O(N\log^2V)$

### 做法说明

对于一个三元组，我们需要将其拆分为两个操作（偏序条件均为这个三元组）：插入和查询。

因为此题含有等于，所以在初始排序时（提前处理一维）需要在当前数值相等的情况下插入排在前面查询排在后面。

## 代码

```cpp
#include<bits/stdc++.h>
#define N 412345
#define lowbit(x) ((x)&(-x))
#define inf 212345
using namespace std ;
int n , K , tr[N] , cnt=0 , ans[N] , real_ans[N] , q , num[N] , chong=0 ;
void change(int x,int k) {
	while(x<=K) {
		tr[x] += k ;
		x += lowbit(x) ;
	}
}
int ask(int x) {
	int ans=0 ;
	while(x) {
		ans += tr[x] ;
		x -= lowbit(x) ;
	}
	return ans ;
}
struct node {
	int x , y , z , opt , i , k ;
} a[N],q1[N],q2[N];
bool cmp(node a,node b){
	return a.x==b.x?(a.y==b.y?(a.z==b.z?a.opt<b.opt:a.z<b.z):a.y<b.y):a.x<b.x ;
}
void solve(int l,int r,int L,int R) {
	if(L>=R||l>r) return ;
	int mid=(l+r)>>1 , tot1=0 , tot2=0 ;
	for(int i=L; i<=R; i++) {
		if(a[i].opt==1){//在此处进行上述划分的左区间数值
			if(a[i].y<=mid) change(a[i].z,a[i].k) , q1[++tot1] = a[i] ;
			else q2[++tot2] = a[i] ;
		}else{//在此处进行上述划分的右区间询问
			if(a[i].y>=mid) ans[a[i].i] += ask(a[i].z) , q2[++tot2] = a[i] ;
			else q1[++tot1] = a[i] ;
		}
	}
	for(int i=1; i<=tot1; i++) {
		a[i+L-1] = q1[i] ;
		if(q1[i].opt==1) change(q1[i].z,-q1[i].k) ;
	}
	for(int i=1; i<=tot2; i++) a[i+L+tot1-1] = q2[i] ;
	if(l!=r) solve(l,mid,L,L+tot1-1) ;
	solve(mid+1,r,L+tot1,R) ;
}
signed main() {
	cin >> n >> K ;
	for(int i=1; i<=n; i++){
		int x , y , z ;
		scanf("%d%d%d",&x,&y,&z) ;
		a[i] = node{x,y,z,1,i,1} ;
		a[i+n] = node{x,y,z,2,i,1} ;
	}
	sort(a+1,a+1+n+n,cmp) ;
	solve(1,inf,1,n+n) ;
	for(int i=1;i<=n;i++) real_ans[ans[i]-1]++ ;
	for(int i=0;i<n;i++) printf("%d\n",real_ans[i]) ;
	return 0 ;
}
```

---

## 作者：NATURAL6 (赞：19)

### [题目传送门](https://www.luogu.com.cn/problem/P3810)

### 前言

这是一篇分块题解。

## 题意

有 $n$ 个元素，每个元素有三个属性，求对于每个元素三个属性都小于等于它的元素个数。

这个题意不好处理，我们可以把它转化一下，先按 $a$ 属性为第一关键字，属性 $b$ 为第二关键字，属性 $c$ 最末排序，问题就转化成了：

有 $n$ 个元素，每个元素有两个属性，求对于每个元素它的前缀中两个元素都小于等于它的元素的个数。

## 做法

考虑对于序列分块，每处理完一个块，就重构一个数组。

对于每个元素，块内的暴力比较，时间复杂度 $O(\sqrt{n})$ 。

对于前面的元素，直接从处理出的数组中读出答案，时间复杂度 $O(1)$ 。

考虑怎么处理出一个这样的数组。

将一个元素的两个属性对应到一个二维平面上，可以看出一个元素对后面的元素做贡献，必须要它处于后面元素的右下方。

于是我们可以把每个数加到对应的点上，然后做一遍二维前缀和。

但是这样时间复杂度是 $O(n^2)$ 的，明显会超时，考虑优化。

因为这些前面的元素在这次重构后只用对后一个块中的元素做贡献，所以它们的属性大小不重要，只有与后面这些元素属性的相对大小有意义。

于是把前面的元素属性按与后面这些元素属性的相对大小经行离散化，再做上面的操作，时间复杂度是 $O(\max(n,B^2))$ 的，在 $B$ 取 $\sqrt{n}$ 时最优。

总共重构 $\sqrt{n}$ 次，总时间复杂度 $O(n\sqrt{n})$ 。

### 实现细节

对于重复的元素，他们内部会重复贡献，不好处理，于是把它们删成一个元素，公用这个元素的答案即可。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int qread()
{
	register int a=0;register char ch=getchar();
	while(ch>'9'||ch<'0'){ch=getchar();}
	while(ch>='0'&&ch<='9'){(a*=10)+=(ch^48);ch=getchar();}
	return a;
}
int n,k,f[100010],p,tot,s[100010],ans[100010],d[100010];
int cl,c[100010],st[400],ed[400],mp[500][500],cb[200010],cc[200010];
struct poit
{
	int a,b,c,id,cnt;
}a[100010];
inline bool cmp(poit x,poit y){return x.a==y.a?(x.b==y.b?x.c<y.c:x.b<y.b):x.a<y.a;}
inline void re(register int h)
{
	memset(mp,0,sizeof(mp));
	int totb=0;
	for(register int i=st[h];i<=ed[h];++i)s[++totb]=a[i].b;
	sort(s+1,s+1+totb);
	totb=unique(s+1,s+1+totb)-s-1;
	p=1;
	for(register int i=1;i<=k;++i)
	{
		if(i>s[p]&&p<=totb)++p;
		cb[i]=p;
	}
	int totc=0;
	for(register int i=st[h];i<=ed[h];++i)s[++totc]=a[i].c;
	sort(s+1,s+1+totc);
	totc=unique(s+1,s+1+totc)-s-1;
	p=1;
	for(register int i=1;i<=k;++i)
	{
		if(i>s[p]&&p<=totc)++p;
		cc[i]=p;
	}
	for(register int i=st[h]-1;i;--i)mp[cb[a[i].b]][cc[a[i].c]]+=a[i].cnt;
	for(register int i=1;i<=totb;++i)
	{
		for(register int j=1;j<=totc;++j)
		{
			mp[i][j]+=mp[i-1][j]+mp[i][j-1]-mp[i-1][j-1];
		}
	}
	return ;
}
int main()
{
	n=qread();
	k=qread();
	for(register int i=1;i<=n;++i)
	{
		a[i].a=qread();
		a[i].b=qread();
		a[i].c=qread();
		a[i].id=i;
		a[i].cnt=1;
		f[i]=i;
	}
	sort(a+1,a+1+n,cmp);
	p=0;
	for(register int i=1;i<=n;++i)
	{
		if(a[i].a==a[p].a&&a[i].b==a[p].b&&a[i].c==a[p].c)
		{
			++tot;
			f[a[i].id]=a[p].id;
			a[i].a=k+1;
			++a[p].cnt;
		}
		else p=i;
	}
	sort(a+1,a+1+n,cmp);
	n-=tot;
	cl=sqrt(n)+1;
	for(register int i=1;i<=n;++i)
	{
		c[i]=(i-1)/cl+1,ed[c[i]]=i;
		ans[a[i].id]+=a[i].cnt-1;
	}
	for(register int i=n;i;--i)st[c[i]]=i;
	for(register int i=1;i<=c[n];++i)
	{
		re(i);
		for(register int j=st[i];j<=ed[i];++j)
		{
			for(register int k=st[i];k<j;++k)
			{
				if(a[k].a<=a[j].a&&a[k].b<=a[j].b&&a[k].c<=a[j].c)ans[a[j].id]+=a[k].cnt;
			}
			ans[a[j].id]+=mp[cb[a[j].b]][cc[a[j].c]];
		}
	}
	for(register int i=1;i<=n+tot;++i)++d[ans[f[i]]];
	for(register int i=0;i<n+tot;++i)printf("%d\n",d[i]);
	return 0;
}
```
## 问题延伸

这种方法可以拓展到高维，只用将二维前缀和变为高维前缀和，调整块长即可。

### 时间复杂度分析：

设块长为 $B$，则总共重构 $\dfrac{n}{B}$ 次，每次需要做大小为 $B$ 的 $k$ 维前缀和，以及对 $n$ 个数的离散。

对每个元素的询问，需要 $O(B)$ 的比较和 $O(1)$ 的查询。

总共时间复杂度为 $O(nB+\dfrac{n}{B}(B^k+n))$。

对于最优块长，$O(nB)$ 忽略不计，取 $B^k=n$ 得到 $B=\sqrt[k]{n}$。

那么最终时间复杂度约为 $O(n^\frac{2k-1}{k})$。


---

## 作者：MCAdam (赞：19)

[题目](https://www.luogu.com.cn/problem/P3810)

名字好好听\(^o^)/~

前置芝士：[P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

注：$[flag]$类似于一个$bool$型变量，如果$flag$为真，那么$[flag]=1$，反之则为$0$。

题意：给定$n$个三元组$(a_i,b_i,c_i)$，设$f(i)=\sum_{j\neq i}[a_j\leq a_i,b_j\leq b_i,c_j\leq c_i]$，$ans[d]=\sum_{i=1}^{n}[f(i)=d]$，输出$ans[d](d\in [0,n))$。

这是一个三维偏序的题目（题目告诉我们了），考虑怎么让它变得简单点呢？我们把三元组按照 $a_i$ 从小到大排序， $a_i$ 就保证是递增的了，那就变成了二维偏序啦！这个时候，只需要一个~~树套树~~神奇的CDQ分治。

CDQ分治的主要思想大概就是，将一个问题分成同样大的两个，递归处理两个规模较小的问题，然后要把两个规模小的问题合并时，计算前一半对后一半的贡献。

举个例子，在用归并排序计算逆序对时，当前的序列 $[l,r]$，$[l,mid]$ 和 $[mid+1,r]$ 分别有序了，然后我们用两个指针 $p$ 和 $q$ 在两个序列中扫描，如果左半部分的 $val[p]$ 与右半部分的 $val[q]$ ，有 $val[p]>val[q]$，那么 $[p,mid]$ 对 $q$ 都会有逆序对的贡献，答案就累加上 $mid-p+1$。

回到这道题，我们要计算 $b_j\leq b_i$ 且 $c_j\leq c_i$ 的数量（ $a$ 已经有序了），我们将 $b$ 进行归并排序。

对于左半部分 $b[p]<b[q]$，我们把 $p$ 位置的这个三元组放入一个用来合并的数组里，那么后面放入这个数组里的三元组的$b$肯定比当前这个 $b[p]$ 大，也就当前这个三元组有可能对后面的三元组做出贡献。我们对 $c$ 建立树状数组，在 $c[p]$ 这个位置单点修改。

当 $b[p]>b[q]$ 时，要把$q$位置的这个三元组放入这个数组内，那么之前放入这个数组里的三元组的 $b$ 肯定比当前这个 $b[q]$ 小，那就在树状数组里查询 $c[q]$ 位置的前缀和，更新答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/05e82iz4.png)

大概思路就是这样，但是有很多细节要注意的：

- 三元组有可能存在完全相同的。

因为CDQ过程中只会计算左边对右边的贡献，如果有相同的话，不管按什么顺序计算都会有遗漏。考虑把这些相同的合并起来，记录一个$size$，代表这种三元组有多少个。除了CDQ计算的贡献外，还有它们自身相互之间的贡献$size-1$。

正是因为要把相同的合并，所以排序的时候，不能只按照$a$排，而是要按照$a,b,c$为第一、第二、第三关键字排，这样才能保证相同的三元组会挨在一起。

- CDQ过程中存在$b[p]=b[q]$的情况

因为要计算的是可以取等号的，如果把这种情况归到大于号那边，也就是在树状数组中查询，那么答案就会有遗漏。所以应该归到小于号里，也就是更新树状数组，对$b[q]$仍然能做出贡献。

- 结构体内变量和外部变量的关系

没有这个问题的请自行忽略。。

三元组我是用一个结构体来表示的。因为这个结构体数组在排序过程中位置在不断变化，所以结构体中应该要再存一个$pos$，这个$pos$应该为去重后，三元组所在的位置。还有$size$数组，我的写法存的也是三元组去重后的位置所对应的三元组的数量（也就是这个$size$不会因为排序而变化）。这个问题与个人的写法有关，还是看代码吧。

- 树状数组每次CDQ要清空

注意不能用$memset$，会超时，而是倒着做回去，就和点分治一样

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=1e5+10;
int n,m;
int size[N],ans[N],cnt[N],t[2*N];					  //ans存的是每个位置的答案，cnt存的是每种答案有多少个，t是树状数组 
struct node
{
	int a,b,c;
	int pos;										  //pos记录的是去重后的位置 
	bool operator != (const node &x) const
	{
		return (a!=x.a||b!=x.b||c!=x.c);
	}
}tmp[N],v[N],w[N];									  //tmp是输入的三元组，v是去重并用来排序的，w辅助排序 
inline int lowbit(int x)
{
	return x&(-x);
}
inline void change(int x,int c)
{
	for(int i=x;i<=m;i+=lowbit(i))
		t[i]+=c;
}
inline int query(int x)
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i))
		res+=t[i];
	return res;
}													  //树状数组单点修改、查询前缀和 
inline void CDQ(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)/2,p=l,q=mid+1;
	CDQ(l,mid),CDQ(mid+1,r);						  //递归解决子问题 
	for(int i=l;i<=r;i++)
	{												  //在树状数组中更新，并放入辅助排序的数组里			
		if((p<=mid&&v[p].b<=v[q].b)||q>r) change(v[p].c,size[v[p].pos]),w[i]=v[p++];
		else ans[v[q].pos]+=query(v[q].c),w[i]=v[q++];//更新答案 
	}
	for(int i=l;i<=mid;i++)
		change(v[i].c,-size[v[i].pos]);				  //清空树状数组 
	for(int i=l;i<=r;i++)
		v[i]=w[i];
}
inline bool cmp(node x,node y)						  //3关键字排序 
{
	if(x.a==y.a)
	{
		if(x.b==y.b) return x.c<y.c;
		else return x.b<y.b;
	}
	else return x.a<y.a;
}
int main()
{
	int tn;
	scanf("%d%d",&tn,&m);
	for(int i=1;i<=tn;i++)
		scanf("%d%d%d",&tmp[i].a,&tmp[i].b,&tmp[i].c);
	sort(tmp+1,tmp+tn+1,cmp);
	for(int i=1;i<=tn;i++)							  //排序后去重 
	{
		if(tmp[i]!=tmp[i-1]) v[++n]=tmp[i],v[n].pos=n;//记录pos 
		size[n]++;									  //记录size 
	}
	CDQ(1,n);
	for(int i=1;i<=n;i++)							  //同一种三元组内还有贡献size-1，这些三元组的答案都相同 
		cnt[ans[v[i].pos]+size[v[i].pos]-1]+=size[v[i].pos];
	for(int i=0;i<tn;i++)
		printf("%d\n",cnt[i]);
	return 0;
}
```
谢谢~~

---

## 作者：myee (赞：14)

### 引言

写本题解时，题解区有 $35$ 篇题解，仅俩 KDT 做法，其他人几乎都是一通 cdq 玄学（？）。

陌上花开是 KDT 求三维偏序的经典模板呀。

KDT 是个好东西，在解决高维问题时，都可以考虑；[这题](https://www.luogu.com.cn/problem/P7711)就可以用 KDT 骗分。

请先确保在学会 KDT 基操（build，find）后再阅读本题解。

### 思路

先写一个 3DT 上去。

复杂度是 $O(n^{\frac53})$ 的，毫无疑问[会 T](https://www.luogu.com.cn/record/53027731)。

咋办？

观察到各个三维点的编号不影响答案，而影响一个点 $f$ 的只有三维坐标都不比其大的点，故考虑先按第一维排序，动态插点进一个 2DT 中去（各点只有第二、三维），同期查询 $f$。

要注意的是，**第一维坐标相同时，应把之同时插入，再一并查询，以免出现像 $(1,1,1),(1,1,1),(1,1,1),\dots,(1,1,1)$ 这样的数据时挂掉**。此外，**也不应忘记在答案中删去各点自身**。

### 问题来了

动态插点咋实现？

前俩题解好像都是写了带替罪羊树式重构的 KDT，然而这又臭又长，一点不香。

我们考虑使用其他方法来搞。

由于只有插入没有删除，不用打 KDT 惰性删除标记。

但实际上插入本身也并不方便，于是采取[yk链分治](https://www.luogu.com.cn/blog/myee/yk-algorithm)技术，即二进制拆分法。

如果使用原始yk链分治算法，对每一块建一个 KDT，那么我们归并操作只能推倒重构（因为几乎没有明显单调性），在插入操作处复杂度是 $O(n\log^2n)$ 的（因为单次重构 KDT 复杂度是 $O(n\log n)$ 的），但常数太大会挂掉。

考虑：我们把原始的 $\log\operatorname{lowbit}n$ 次块归并操作，改为**推倒末 $\log\operatorname{lowbit}n$ 块并最后将删去元素与新插入元素重构一个大块**。

这样，每个点插入时只重构一次，于是就不会挂了，总插入复杂度是 $O(n\log^2n)$ 的。

查询呢？**同时维护 $O(\log n)$ 个 KDT，难道不 T**?

其实由于每块大小不会超过前一块的一半，单次查询复杂度是 $O(\sqrt n+\sqrt{\frac n2}+\sqrt{\frac n4}+\dots+\sqrt{\frac n{2^w}})=O(\sqrt n)$ 的！

因此，总时间复杂度是 $O(n\sqrt n+n\log^2n)$ 的，（好像）可以通过此题！

[不过](https://www.luogu.com.cn/record/53030941)，被卡常了QAQ，几十毫秒死活过不去。

于是加一车常数优化，待夜深人静之时，交它几发，相信你一定会A的QAQ。（来自一个第 $299$ 次才 [AC](https://www.luogu.com.cn/record/53218123) 的人）

### Code

快读快写啥的删了一车，代码更简洁，不一定保证能过，加油卡常吧（

```cpp
#include <algorithm>
#include <stdio.h>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
const uint k=2;
class kdpoint{public:uint D[k];uint&operator[](uint n){return D[n];}};
uint d;
bol operator<(const kdpoint&a,const kdpoint&b){return a.D[d]<b.D[d];}
class kdT
{
    public:
        typedef kdpoint point;
        class node;
        voi bzr(){if(rot!=NULL)delete rot;rot=NULL;}
        voi build(point*P,uint len){rot=new node,rot->build(P,P+len);}
        node*rot;
        class node
        {
            public:
                point p;node*ls,*rs;
                uint Max[k],Min[k];
                ullt sum;
                voi bzr(){ls=rs=NULL;}
                voi build(point*l,point*r,uint t=0)
                {
                    bzr();
                    register point*mid=(r-l)/2+l;
                    d=t;
                    std::nth_element(l,mid,r);
                    p=*mid,sum=1;
                    for(uint i=0;i<k;i++)Max[i]=Min[i]=p[i];
                    if(l<mid)
                    {
                        ls=new node,ls->build(l,mid,(t+1)%k);
                        for(uint i=0;i<k;i++)_min(Min[i],ls->Min[i]),_max(Max[i],ls->Max[i]);
                        sum+=ls->sum;
                    }
                    if(mid+1<r)
                    {
                        rs=new node,rs->build(mid+1,r,(t+1)%k);
                        for(uint i=0;i<k;i++)_min(Min[i],rs->Min[i]),_max(Max[i],rs->Max[i]);
                        sum+=rs->sum;
                    }
                }
                ~node(){if(ls!=NULL)delete ls;if(rs!=NULL)delete rs;}
        };
};
kdT T[30];uint tp=0,siz=0;
std::pair<uint,kdpoint>P[100005];
kdpoint K[100005];
voi insert()//yk链分治 O(n\log^2n)
{
	*K=P[siz++].second;
	uint f=siz&-siz,u=1;
	while(f>>=1)//merge过程：推倒
	{
		u<<=1;
		for(uint i=u>>1;i<u;i++)K[i]=P[siz-i-1].second;
		T[--tp].bzr();
	}
	T[tp].bzr(),T[tp++].build(K,u);//merge过程：重构
}
ullt find(kdT::node*p,uint&x,uint&y)
{
    if(p==NULL||p->Min[0]>x||p->Min[1]>y)return 0;
    if(p->Max[0]<=x&&p->Max[1]<=y)return p->sum;
    ullt ans=0;
    if(p->p[0]<=x&&p->p[1]<=y)ans=1;
    ans+=find(p->ls,x,y)+find(p->rs,x,y);
    return ans;
}
inline chr nc() //光速快读
{
    static chr buf[1000010],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000010,stdin),p1==p2)?EOF:*p1++;
}
inline ullt read()
{
    register ullt ans=0;register chr c;do c=nc();while(c>'9'||c<'0');
    do ans=c-'0'+ans*10,c=nc();while(c>='0'&&c<='9');return ans;
}
uint Time[100005];
int main()
{
	uint n=read(),m;m=read();
	for(uint i=0;i<n;i++)P[i].first=read(),P[i].second[0]=read(),P[i].second[1]=read();
	std::sort(P,P+n);
	for(uint i=0,j=0;i<n;)
    {
		for(;j<n&&P[j].first==P[i].first;j++)insert();
		while(i<j)
		{
			uint w=-1;
			for(uint k=0;k<tp;k++)w+=find(T[k].rot,P[i].second[0],P[i].second[1]);
			Time[w]++,i++;
		}
	}
    for(uint i=0;i<n;i++)printf("%u\n",Time[i]);
	return 0;
}
```


---

## 作者：Sol1 (赞：12)

因为~~CDQ分治之毒瘤超乎你想象~~，所以本题解将详细讲解CDQ分治（当然还有这道题的特殊处理辣qwq

首先，我们来把这个问题弱化一下：二维偏序。

对于每一个$(a_i,b_i)$，求所有满足$1 \leq j \leq n$且$a_j \leq a_i$且$b_j \leq b_i$的$(a_j,b_j)$的数量。

我们可以首先对所有$(a_i,b_i)$按照$a_i$从小到大排序。

然后，对$(a_i,b_i)$按照$b_i$进行归并排序（注意这里要排两次序）。对区间$[l,r]$排序时，设$mid=\frac{l+r}{2}$，假设区间$[l,mid]$和区间$[mid+1,r]$都已经以$b_i$为关键字排好序了。此时，有$\forall l \leq i \leq mid,mid<j\leq r:a_i \leq a_j$。

显然，这里的问题就可以被化解为归并排序求“顺序对”。

这个方法可以扩展至三维偏序：

对于每一个三元组$(a_i,b_i,c_i)$，先以$a_i$为关键字排序，再以$b_i$为关键字归并排序。归并之后，$b$就是有序的了，所以只需要考虑$c$对答案的影响。

具体来说，在归并过程中：

如果$b_i \leq b_j$，则在树状数组的$c_i$位置上$+1$。

否则，求出$c_i$的前缀和，并计入答案。

因为所有$(mid,r]$中的元素不会进入树状数组，而答案只在$(mid,r]$中统计，所以$a$不会影响到答案。

$b$因为是排序的优先级，所以它不会影响到答案。

所以只有$c$会影响到答案，而树状数组统计的答案保证了只可能有$c_i\leq c$会影响到答案。

所以这个算法是正确的。

注意：清空树状数组时不能简单地memset，要只删除刚刚加进树状数组的元素。因为如果直接memset可能影响到其他递归进程，导致结果错误。

最后，用另外一个数组统计每一种答案出现的次数就可以了。

这道题还需要考虑一个特殊情况，就是有$i \neq j$且$a_i=a_j,b_i=b_j,c_i=c_j$。

所以，对于每一种三元组，只保留$1$个。同时，要统计出每一种三元组的实际数量$cnt_i$。

在修改树状数组时，要对位置$c_i$加上$cnt_i$。

在统计出现次数时，位置$ans_i$要$+cnt_i$而不是$+1$。

具体的，来看代码吧~

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;

struct Node {
    int a, b, c, idx;
    //a,b,c是三维空间上的点,idx是准确下标，方便统计答案。
    //比较函数要写的稍微麻烦一点。
    bool operator < (const Node& nd) const {
        if (a != nd.a) {
            return a < nd.a;
        }
        if (c != nd.c) {
            return c < nd.c;
        }
        return b < nd.b;
    }
};
int n, m, c[200005], ans[200005], _ans[200005], cnt[200005], tmp_;
Node nd[100005], tmp[100005];
//这个是用来去重的，我用pair<pair<int,int>,int>来存三元组
map <pair <pair <int, int>, int>, int> mp;

//树状数组部分
inline int LowBit(int x) {
    return x & -x;
}

inline void Update(int i, int x) {
    for (int j = i;j <= m;j += LowBit(j)) {
        c[j] += x;
    }
}

inline int Query(int i) {
    int ans = 0;
    for (int j = i;j >= 1;j -= LowBit(j)) {
        ans += c[j];
    }
    return ans;
}

void Read() {
    scanf("%d%d", &n, &m);
    tmp_ = n;
    for (int i = 1;i <= n;i++) {
        scanf("%d%d%d", &nd[i].a, &nd[i].b, &nd[i].c);
        nd[i].idx = i;
        mp[make_pair(make_pair(nd[i].a, nd[i].b), nd[i].c)]++;
        //有重复
        if (mp[make_pair(make_pair(nd[i].a, nd[i].b), nd[i].c)] > 1) {
            i--;
            n--;
        }
    }
}

void Prefix() {
    for (int i = 1;i <= n;i++) {
    //处理一下答案，完全相同的两个球员都要+1
        cnt[i] = mp[make_pair(make_pair(nd[i].a, nd[i].b), nd[i].c)];
        ans[i] += cnt[i] - 1;
    }
    //按照a排序
    sort(nd + 1, nd + n + 1);
}

//核心，归并排序
void MergeSort(int l, int r) {
    if (l == r) {
        return;
    }
    int mid = l + r >> 1;
    MergeSort(l, mid);
    MergeSort(mid + 1, r);
    int p1 = l, p2 = mid + 1, k = l;
    while (p1 <= mid && p2 <= r) {
        if (nd[p1].b <= nd[p2].b) {
        	//更新树状数组
            Update(nd[p1].c, cnt[nd[p1].idx]);
            tmp[k++] = nd[p1++];
        } else {
        	//统计答案
            ans[nd[p2].idx] += Query(nd[p2].c);
            tmp[k++] = nd[p2++];
        }
    }
    //归并剩余部分
    while (p1 <= mid) {
        Update(nd[p1].c, cnt[nd[p1].idx]);
        tmp[k++] = nd[p1++];
    }
    while (p2 <= r) {
        ans[nd[p2].idx] += Query(nd[p2].c);
        tmp[k++] = nd[p2++];
    }
    //清空树状数组
    for (int i = l;i <= mid;i++) {
        Update(nd[i].c, -cnt[nd[i].idx]);
    }
    for (int i = l;i <= r;i++) {
        //printf("%d %d %d %d\n", tmp[i].a, tmp[i].b, tmp[i].c, ans[tmp[i].idx]);
        nd[i] = tmp[i];
    }
}

void Solve() {
    for (int i = 1;i <= n;i++) {
        _ans[ans[i]] += cnt[i];//统计最终答案
    }
    for (int i = 1;i <= tmp_;i++) {
        printf("%d\n", _ans[i - 1]);
    }
}

int main() {
    Read();
    Prefix();
    MergeSort(1, n);
    Solve();
    return 0;
}
```
顺便求dalao私信给我4维偏序解法qwq

---

## 作者：Argvchs (赞：10)

众所周知，三维偏序的一般做法是 CDQ 分治，复杂度是两只 $\log$ 的。

但是我们想要一个根号的做法。（根号信仰！）

目前根号做法有 KDT 和分块。然而 KDT 常数巨大，分块太困难了。这里介绍一种简单的莫队做法。

---

我们知道莫队是可以轻松做在线二维数点的。

考虑怎么将离线三维数点转化为在线二维数点。你可以将 $a_i$ 作为时间、$b_i$ 作为序列、$c_i$ 作为值。带修莫队套值域分块可以轻松做到 $O(n \sqrt n)$。

但是这样做是假的。为什么？因为你一个位置可能会有很多值，这样莫队移动指针的复杂度就不是 $O(1)$ 的，很容易就会被卡掉。

怎么办呢？可以把 $b_i$ 离散化成一个排列，例如：

```text
<-- 1 1 4 5 1 4
--> 1 2 4 6 3 5
```

形式化的：

$$
b'_i = \sum_{j} [b_j < b_i] + \sum_{j \le i} [b_j = b_i]
$$

那么我们修改的时候在对应位置修改，查询的时候查询最大与原序列值相等的位置。这样做就是对的！

我们发现这个带修莫队其实完全没必要。你可以对 $a_i$ 和 $b_i$ 都进行一次这样的离散化，然后像二维莫队那样维护两个指针就可以了。

你甚至可以把 $c_i$ 也离散化，但是这样复杂度就是 $n^{5/3}$ 的。

这个做法可以轻松推广到高维，复杂度和 KDT 应该是一样的，但是比 KDT 快多了。

---

三维偏序的代码：

<https://www.luogu.com.cn/record/192931488>

```cpp
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 1e5 + 5, K = 2e5 + 5, B1 = 1e3, B2 = 300;
int n, k, a[N], b[N], c[N], la[K], ra[K], lb[K], rb[K], ab[N], ba[N], ac[N], bc[N], bel[K], val[K],
    sum[N], ans[N];
struct query {
    int a, b, c;
    inline bool operator<(const query &r) {
        if (bel[a] != bel[r.a]) return bel[a] < bel[r.a];
        return bel[a] & 1 ? b < r.b : b > r.b;
    }
} q[N];
inline void insert(int x) { ++val[x], ++sum[bel[x]]; }
inline void remove(int x) { --val[x], --sum[bel[x]]; }
inline int query(int x) {
    int ret = 0;
    for (int i = 1; i <= bel[x] - 1; i++) ret += sum[i];
    for (int i = x; bel[i] == bel[x]; i--) ret += val[i];
    return ret;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> c[i], ++ra[a[i]], ++rb[b[i]];
    for (int i = 1; i <= k; i++) la[i] = ra[i - 1] + 1, ra[i] += ra[i - 1];
    for (int i = 1; i <= k; i++) lb[i] = rb[i - 1] + 1, rb[i] += rb[i - 1];
    for (int i = 1; i <= n; i++) {
        int x = la[a[i]]++, y = lb[b[i]]++;
        q[i] = {ra[a[i]], rb[b[i]], c[i]};
        ab[x] = y, ba[y] = x, ac[x] = bc[y] = c[i];
    }
    for (int i = 1; i <= n; i++) bel[i] = i / B1;
    sort(q + 1, q + n + 1);
    for (int i = 1; i <= k; i++) bel[i] = (i - 1) / B2 + 1;
    for (int i = 1, a = 0, b = 0; i <= n; i++) {
        while (a < q[i].a)
            if (ab[++a] <= b) insert(ac[a]);
        while (a > q[i].a)
            if (ab[a--] <= b) remove(ac[a + 1]);
        while (b < q[i].b)
            if (ba[++b] <= a) insert(bc[b]);
        while (b > q[i].b)
            if (ba[b--] <= a) remove(bc[b + 1]);
        ++ans[query(q[i].c) - 1];
    }
    for (int i = 0; i < n; i++) cout << ans[i] << '\n';
}
```

---

## 作者：csxx601cjy (赞：4)

### 题目链接：[P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)

### [可能更好的阅读体验](https://0xcjy.github.io/oi/other/partial-order.html)

蒟蒻不会 CDQ 分治，不会 KD-Tree，不会树套树，只能用最简单的 **bitset** 做了。

### 题目分析

多维偏序，就是求哪个元素所有的属性都比另一个元素小。三维偏序，就是属性个数为 $3$ 的情况。

$O(n^2)$ 暴力肯定是不行的，紫色的难度和 $10^5$ 的数据范围都不允许这么做。

考虑用 bitset 表示一个维度属性值小于等于一个元素的所有元素的集合，由于题目要求三个维度都要满足，所以对三个维度的集合求交集，最后交集的元素个数减一（排除自身），就求出了题目中的 $f(i)$。

下面是 bitset 相关的操作：

- 初始化：`set()` 初始化全为 $1$，`reset()` 初始化全为 $0$。
- 求交集（$A\cap B$）：`A&B` 也就是按位与。
- 求元素个数：`count()` 可以计算出所有为 $1$ 的位的个数。

为什么用 bitset？

bitset 相关的操作由于是计算机按位进行的，在 64-bit 的计算机运行自带一个 $\frac{1}{64}$ 的常数，可以高效解决集合运算等操作。

### 算法介绍

对 $a$、$b$、$c$ 分别排序，并求出排序后的数在原数组对应的下标。

由于空间限制，把所有元素分成每 $10^4$ 个元素为一组的小组来处理。

设 $10^4$ 个 bitset $B_i$，和一个辅助 bitset $S$。

$B_i$ 表示所有小于等于小组中第 $i$ 个元素的元素构成的集合，初始全为 $1$（后面要按位与）。

对于每个维度分别处理：
- 清空 $S$（初始化全为 $0$）。
- 使用指针 $ptr$ 动态构建 $S$：
	- $S$ 存储所有当前维度属性值 $\le$ 当前元素 $cur$ 的元素。
	- 指针 $prt$ 从 1 开始，当 $ptr$ 指向的属性值 $\le cur$ 的属性值时，设置对应位为 $1$（$ptr$ 同时自增）。
- 如果当前元素 $cur$ 在组内，则取交集，保留同时满足当前维度的元素。

处理完三个维度后，统计结果（记得减去自身）。

### 正确性证明

正确性是显然的。

#### 时间复杂度

排序：$O(n \log n)$。

分组处理：组数 $O(n/M) \approx O(10)$（$M$ 是组的大小 $=10^4$）。

每组内：每个维度 $O(n)$ 构建 $S$，$O(M \cdot n / w)$ bitset 交集操作（$w$ 为机器字长，通常是 $64$）。

总时间：$O(3\cdot n \log n +3 \cdot (n/M) \cdot (n + M \cdot n / w)) \approx 4.8 \times 10^8$，可以非常极限地通过本题。

#### 空间复杂度

bitset $b_i$：$10^4\times 10^5$ bit $\approx 120$ Mib。

其他数组：$O(n)$。

 ### 代码实现

看算法介绍太抽象了，还是看代码吧。

#### 详细注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010,M=10000; //N:最大元素数量,M:每组处理的最大元素数量
int n,k; //n:元素数量,k:最大属性值(没用)
int a[3][N]; //a[i][j]:第j个元素的第i维属性值(i=0,1,2对应a,b,c)
int p[3][N]; //p[i][j]:按第i维属性值排序后,第j小的元素的原始编号(索引)
int ans[N]; //ans[i]:统计f(x)=i的元素个数
bitset<N>b[M+1]; //b[i]:第i个元素对应的bitset,记录哪些元素在所有维度都比i小
bitset<N>s; //s:临时辅助bitset,用于处理当前维度的偏序
int main(){
	cin.tie(0)->sync_with_stdio(0); //优化输入输出速度
	cin>>n>>k; //k是没用的
	for(int i=1;i<=n;i++)
		cin>>a[0][i]>>a[1][i]>>a[2][i], //读入第i个元素的三维属性
		p[0][i]=p[1][i]=p[2][i]=i; //初始化索引数组
	for(int i=0;i<3;i++) //对三个维度分别排序
		sort(p[i]+1,p[i]+1+n,[i](int x,int y){ //lambda表达式,[i]表示捕获变量i的值
			return a[i][x]<a[i][y]; //按照第i维的属性值升序排序
		});
	for(int l=1,r;l<=n;l=r+1){ //分组处理，每组最多M个元素
		r=min(n,l+M-1); //确定当前组的右边界
		for(int i=1;i<=M;i++)
			b[i].set(); //set()将bitset所有位置初始化为1
		for(int i=0;i<3;i++){ //对三个维度依次处理
			s.reset(); //清空临时bitset
			int ptr=1; //指针指向当前已处理到的元素位置
			for(int j=1;j<=n;j++){ //按第i维的排序顺序处理每个元素
				int cur=p[i][j]; //当前处理的元素编号
				while(ptr<=n&&a[i][p[i][ptr]]<=a[i][cur])
					s[p[i][ptr++]]=1; //将所有在第i维上不大于cur的元素在s中标记为1
				if(l<=cur&&cur<=r) //如果当前元素在本组处理范围内
					b[cur-l+1]&=s; //按位与操作求两个集合的并集
			}
		}
		for(int i=l;i<=r;i++) //统计当前组每个元素的答案
			ans[b[i-l+1].count()-1]++; //count()返回bitset中1的个数
		//减1是因为要排除自己(j!=i)
	}
	for(int i=0;i<n;i++) //输出结果
		cout<<ans[i]<<'\n'; //ans[i]表示f(x)=i的元素个数
	return 0;
}
```

#### 无注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010,M=10000;
int n,k,a[3][N],p[3][N],ans[N];
bitset<N>b[M+1],s;
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[0][i]>>a[1][i]>>a[2][i],
		p[0][i]=p[1][i]=p[2][i]=i;
	for(int i=0;i<3;i++)
		sort(p[i]+1,p[i]+1+n,[i](int x,int y){
			return a[i][x]<a[i][y];
		});
	for(int l=1,r;l<=n;l=r+1){
		r=min(n,l+M-1);
		for(int i=1;i<=M;i++)
			b[i].set();
		for(int i=0;i<3;i++){
			s.reset();
			int ptr=1;
			for(int j=1;j<=n;j++){
				int cur=p[i][j];
				while(ptr<=n&&a[i][p[i][ptr]]<=a[i][cur])
					s[p[i][ptr++]]=1;
				if(l<=cur&&cur<=r)
					b[cur-l+1]&=s;
			}
		}
		for(int i=l;i<=r;i++)
			ans[b[i-l+1].count()-1]++;
	}
	for(int i=0;i<n;i++)
		cout<<ans[i]<<'\n';
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/224316592)（最慢的点 $900$ ms）。

### 拓展阅读

关于高维偏序，给大家推荐一个[课件](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/zdo2hke0)。

---

## 作者：T_TLucas_Yin (赞：4)

投三次审核给管理添麻烦了。这次应该没有格式错误了吧……

**我们坚定不移地认为线段树套线段树才是最优雅的 ~~暴力~~ 做法。**

所谓树套树，其实就是在第一层线段树的每一个节点上都开一棵线段树。本质上只是普通线段树的一种运用。这种算法思维难度极低，且代码不易写错。缺点是时空复杂度常数都比较大。

对于三维偏序问题：

我们通过排序解决掉第一维的限制。

再用第一层线段树存储第二维权值的信息。

每个线段树节点上的第二层线段树，存储“第二维权值在该节点对应区间内的元素”的第三维权值信息。

由此，我们就可以把每一个元素的加入看成一次区间查询加一次单点修改，直接在线段树上解决。

注意：在这种算法中，第一维线段树实际上没有存储任何信息，只是用来帮助把若干棵第二维线段树排成一个更大的线段树状结构。

下面来看具体的实现方法。

注意到，一棵普通的线段树需要 $O(n \log n)$ 的存储空间。如果将这样的复杂度再平方势必会炸。而实际上对于本题类似的数据规模，所有节点的第二维线段树中总共只需要存储最多（大约）$10^6$ 次数据，所以第二层的大多数空间都是浪费的。

为了避免内存超限，我们动态开点实现第二维的所有线段树即可。

对于如下操作：

- 加入一个第二维权值为 $b_i$，第三维权值为 $c_i$ 的元素。

我们要在第一层线段树上递归，直至找到一个对应区间为 $[b_i,b_i]$ 的线段树节点，然后把这个节点对应的第二维线段树上对应区间 $[c_i,c_i]$ 的节点存储的值 $+1$。

但还没完。注意到我们递归到节点 $[b_i,b_i]$ 的路径上经过的每一个线段树节点都存储了一个第二维权值区间的信息，而其中的每一个区间都包含 $b_i$ 这个值。所以 $c_i$ 要同步更新到上述所有节点的第二维线段树中。这样才能保证线段树的非叶子节点存储的信息也是正确的。

对于如下操作：

- 查询第二维权值在 $[b_l,b_r]$ 之间，第三维权值在 $[c_l,c_r]$ 之间的元素数量。

我们依旧在线段树上递归，把区间 $[b_l,b_r]$ 在线段树上拆成若干个节点对应的区间（即像普通线段树的区间查询一样），再依次在存储这些区间的节点上第二层线段树内查询 $[c_l,c_r]$ 区间内的答案，求和，即可。

将题目中输入的元素按 $a_i$ 从小到大排序，对于每一个 $i$ 查询线段树上 $[1,b_i]$，$[1,c_i]$ 区间的信息，将得到的数值对应的答案 $+1$，再把当前元素的 $b_i$、$c_i$ 信息加到线段树上。最后依次输出每一个数值对应的答案即可解决这个问题。

一些细节：

- 对于本题，还要有一个元素去重的小操作。详见代码。
- 第二维线段树的数组要开到 $2\times10^7$ 左右，我承认对空间限制仍然有点悬。但是卡卡能过。
- 更早的其他一些写树套树的题解好像都把第二层线段树改成树状数组才能卡过这道题。不知道是现在的评测机变快了还是我写的版本常数比较小，我的线段树套线段树很轻松地过了这道题。
- 关于二维线段树的区间修改，我还没有做到过需要用到区间修改的这类题目（如果有人找到的话可以告我一声）。


```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int x=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=x*10+(c-'0'),c=getchar();
    return x;
}
int n,m;
struct node{
    int x,y,z,k;
}a[200005];
bool cmp1(node a,node b){
    if(a.x!=b.x) return a.x<b.x;
    if(a.y!=b.y) return a.y<b.y;
    return a.z<b.z;
}
int rot[800005];
int ls[20000005],rs[20000005],f[20000005],top;
void update(int root,int l,int r,int k,int x){//第二层线段树修改
    if(l==r){ f[root]+=x;return; }
    int mid=(l+r)>>1;
    if(k<=mid){
        if(!ls[root]) ls[root]=++top;
        update(ls[root],l,mid,k,x);
    }
    else{
        if(!rs[root]) rs[root]=++top;
        update(rs[root],mid+1,r,k,x);
    }
    f[root]=f[ls[root]]+f[rs[root]];
}
void update1(int root,int l,int r,int p,int k,int x){//第一层线段树修改
    if(!rot[root]) rot[root]=++top;
    update(rot[root],1,m,k,x);
    if(l==r) return;
    int mid=(l+r)>>1;
    if(p<=mid) update1(root<<1,l,mid,p,k,x);
    else update1(root<<1|1,mid+1,r,p,k,x);
}
int Find(int root,int l,int r,int fl,int fr){//第二层线段树查找
    if(!root) return 0;
    if(fl<=l&&r<=fr) return f[root];
    int mid=(l+r)>>1,sum=0;
    if(fl<=mid) sum+=Find(ls[root],l,mid,fl,fr);
    if(fr>mid) sum+=Find(rs[root],mid+1,r,fl,fr);
    return sum;
}
int Find1(int root,int l,int r,int fl,int fr,int kl,int kr){//第一层线段树查找
    if(fl<=l&&r<=fr){
        if(!rot[root]) return 0;
        return Find(rot[root],1,m,kl,kr);
    }
    int mid=(l+r)>>1,sum=0;
    if(fl<=mid) sum+=Find1(root<<1,l,mid,fl,fr,kl,kr);
    if(fr>mid) sum+=Find1(root<<1|1,mid+1,r,fl,fr,kl,kr);
    return sum;
}
int f1[200005];
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i]={read(),read(),read(),i};
    sort(a+1,a+1+n,cmp1);
    int k=1;
    for(int i=1;i<=n;i++){
        if(i<n&&a[i+1].x==a[i].x&&a[i+1].y==a[i].y&&a[i+1].z==a[i].z)
    		{ k++;continue; }
        //元素去重，三维信息完全相同的元素一次性加到树上。
        update1(1,1,m,a[i].y,a[i].z,k);
        int t=Find1(1,1,m,1,a[i].y,1,a[i].z);
        f1[t-1]+=k,k=1;
    }
    for(int i=0;i<n;i++) printf("%d\n",f1[i]);
    return 0;
}
```

其他一些可以用线段树套线段树解决的问题：
- [P3157](https://www.luogu.com.cn/problem/P3157)
- [P3755](https://www.luogu.com.cn/problem/P3755)
- [P2487](https://www.luogu.com.cn/problem/P2487)（较难）

---

## 作者：Orina_zju (赞：3)

人生第一道CDQ分治（还是模板题，写法还贼2b）……

到目前为止题解区最笨的CDQ分治方法：

我们知道CDQ分治可以在某些特定情况下，高效地离线处理一系列单点询问或修改（下文统称为“操作”），那么对于这道题，我们就想办法往这个思路上靠：

令$\{v_i\}$为一个假想的序列，初始时所有值均为$+\infty$。我们把每个点的第一维$a$看成“操作时间”，将所有点按$a$从小到大排序。然后**依次**将每个点$(a,b,c)$转换成以下两个操作：

（1）首先，令$v_b = c$；
（2）然后，截止到当前时刻（对应$a_j \le a_i$），询问$v_0 \cdots v_b$中小于等于$c$的数有多少个。（显然自身也会被统计进去）

这样我们就将$N$个点转化成了$2N$次单点操作。实现时借助一个权值树状数组，CDQ分治可以直接套用“归并时只处理左区间的修改，只统计右区间的查询”的模板框架。

顺便安利一篇博文：https://blog.csdn.net/wu_tongtong/article/details/78785836 

不过这个思路有一个bug，处理$a$相等的情形会出现错误。考虑如下一组样例：

```
4 5
1 3 5
1 3 5
1 2 3
2 2 3
```

如果直接套用上边的思路，会发现：由于点$(1,2,3)$对应的修改操作放在了点$(1,3,5)$之后，那么进行$(1,3,5)$对应的查询时，点$(1,2,3)$并不会被统计进去。对于若干个相同的点也会出现类似的问题。

因此我们需要对模型进行修正：在对$N$个点排序时，以$a$为第一关键字，$b$为第二关键字，$c$为第三关键字。另外相等的点还要调整操作的顺序：对于$k$个相等的点，先把$k$次修改做完，然后进行$k$次查询。例如，上边的样例应该转换成如下的操作序列：

$(1,2,3)$ 修改；
$(1,2,3)$ 询问；

$(1,3,5)$ 修改；
$(1,3,5)$ 修改；

$(1,3,5)$ 询问；
$(1,3,5)$ 询问；

$(2,2,3)$ 修改；
$(2,2,3)$ 询问。

这样方能得到正确的结果（不妨以上例验证一下）。然后就是完整代码（一开始没看到K的限制还手贱写了个离散化）：

``` cpp
#include <cstdio>
#include <algorithm>
#include <functional>
#include <vector>
#include <numeric>

struct node_t
{
    int a, b, c, id;
};

enum class operation_type_t
{
    initialize = 0,
    modify = 1,
    query = 2
};

struct oper_t
{
    operation_type_t type;
    int position;
    int key;
    int ans_id;

    bool operator < (const oper_t& rhs) const
    {
        if (position != rhs.position)
            return position < rhs.position;
        return static_cast<int>(type) < static_cast<int>(rhs.type);
    }
};

template <class T, class Oper = std::plus<T>>
class binary_indexed_tree_t
{
    std::vector<T> value;
    int n;
    Oper oper;

    int lowbit(int x) { return x & -x; }
public:
    binary_indexed_tree_t() = default;
    explicit binary_indexed_tree_t(int n) { init(n); }

    void init(int n)
    {
        value.assign(n + 1, T());
        this->n = n;
    }
    void modify(int pos, const T& x)
    {
        for (pos += 1; pos <= n; pos += lowbit(pos))
            value[pos] = oper(value[pos], x);
    }
    T get_prefix(int pos, T init = T())
    {
        for (pos += 1; pos; pos -= lowbit(pos))
            init = oper(value[pos], init);
        return init;
    }
};

const int maxN = (int)1e5 + 10;

node_t node[maxN];
oper_t oper[maxN * 2];
int ans[maxN];
int N;

void cdq_divide(int left, int right)
{
    static oper_t temp[maxN * 2];
    static binary_indexed_tree_t<int> bit(N);

    if (right - left <= 1)
        return;

    int mid = (left + right) >> 1;
    cdq_divide(left, mid);
    cdq_divide(mid, right);

    for (int il = left, ir = mid, it = 0; il < mid || ir < right; )
    {
        if ((il < mid && ir < right && oper[il] < oper[ir]) ||
            (ir == right))
        {
            if (oper[il].type == operation_type_t::modify)
            {
                bit.modify(oper[il].key, 1);
            }
            temp[it++] = oper[il];
            il += 1;
        }
        else
        {
            if (oper[ir].type == operation_type_t::query)
            {
                ans[oper[ir].ans_id] += bit.get_prefix(oper[ir].key);
            }
            temp[it++] = oper[ir];
            ir += 1;
        }
    }

    for (int i = left; i < mid; i++)
        if (oper[i].type == operation_type_t::modify)
            bit.modify(oper[i].key, -1);

    for (int i = left; i < right; i++)
        oper[i] = temp[i - left];
}

template <class RAIter, class MemPtr, class Comp>
int discretize_in_place(RAIter first, RAIter last, MemPtr mp, Comp &&comp_3way)
{
    std::vector<int> idx(last - first);
    std::iota(idx.begin(), idx.end(), 0);
    std::sort(idx.begin(), idx.end(), [&comp_3way, &first] (int x, int y) {
        return comp_3way(first[x], first[y]) < 0;
    });

    int count = 0, next = 0;
    for (size_t i = 0; i + 1 < idx.size(); i++, count = next)
    {
        next = comp_3way(first[idx[i]], first[idx[i + 1]]) == 0 ? count : count + 1;
        first[idx[i]].*mp = count;
    }
    first[idx.back()].*mp = count;
    return count;
}

int main()
{
    scanf("%d%*d", &N);
    for (int i = 0; i < N; i++)
    {
        scanf("%d%d%d", &node[i].a, &node[i].b, &node[i].c);
        node[i].id = i;
    }

    auto comp_node = [] (const node_t& lhs, const node_t& rhs) {
        if (lhs.a != rhs.a)
            return lhs.a < rhs.a;
        if (lhs.b != rhs.b)
            return lhs.b < rhs.b;
        return lhs.c < rhs.c;
    };
    std::sort(node, node + N, comp_node);

    discretize_in_place(node, node + N, &node_t::b, [](const node_t &lhs, const node_t &rhs) {
        return lhs.b - rhs.b;
    });
    discretize_in_place(node, node + N, &node_t::c, [](const node_t &lhs, const node_t &rhs) {
        return lhs.c - rhs.c;
    });

    oper[0].position = -1;
    oper[0].type = operation_type_t::initialize;

    for (int qi = 1, i = 0; i < N; )
    {
        int ub = std::upper_bound(node + i, node + N, node[i], comp_node) - node;
        for (int j = i; j < ub; j++)
        {
            oper[qi++] = {.type = operation_type_t::modify,
                          .position = node[j].b,
                          .key = node[j].c,
                          .ans_id = node[j].id};
        }
        for (int j = i; j < ub; j++)
        {
            oper[qi++] = {.type = operation_type_t::query,
                          .position = node[j].b,
                          .key = node[j].c,
                          .ans_id = node[j].id};
        }
        i = ub;
    }

    cdq_divide(0, N << 1 | 1);

    std::vector<int> ans_count(maxN);
    for (int i = 0; i < N; i++)
        ans_count[ans[i]] += 1;

    for (int i = 1; i <= N; i++)
        printf("%d\n", ans_count[i]);

    return 0;
}

```


---

## 作者：BlackHoles (赞：2)

注：本文通过模板题详解 CDQ 分治，并分段附上代码以供理解。本文略长，但保证详细！

### CDQ 分治应用背景

动态规划的优化，点对有关问题，化动态问题为静态。

### CDQ 分治算法流程

以本题为例。

我们将三个属性用结构体存储。（$a$，$b$，$c$ 分别为第一、二、三关键字）

我们按关键字顺序进行排序。

排序后，我们对点对进行去重，在结构体当中记录个数。

同时，我们在结构体中记录该点对贡献的答案，即 $ans_{i}$ 表示满足 $a_j \le a_i$ 且 $b_j \le b_i$ 且 $c_j \le c_i$ 的 $j$ 的个数。（暂时不考虑自身重复贡献，去重后每个点按单独考虑）

```cpp
struct Node {
	int a, b, c;
	int ans, num; // num 为重复个数。
} ar[N], tmp[N];

bool cmp(Node x, Node y) {
	return (x.a < y.a) || (x.a == y.a && x.b < y.b) || (x.a == y.a && x.b == y.b && x.c < y.c);
}

sort(tmp + 1, tmp + m + 1, cmp);
// 去重，统计个数。
int cnt = 0;
for (int i = 1; i <= m; ++i) {
    ++cnt;
    if (i == m || check(tmp[i], tmp[i+1])) {
        ar[++n] = tmp[i], ar[n].num = cnt;
        cnt = 0;
    }
}
```

接下来是 CDQ 分治的**重点部分**。

其名为分治，必然有分治的思想。

假如此时处理区间 $[l,r]$ 的点对，我们取中间值 $mid$，将其分为 $[l, mid]$ 和 $(mid, r]$ 两个区间，分别处理其中满足条件的点对，再设计算法处理跨越两个区间的点对（$l \le i \le mid$，$mid < j \le r$）。

于是采取递归的方法：

```cpp
void CDQ(int l, int r) {
	if (l == r)
		return ;
	int mid = (l + r) >> 1;
	CDQ(l, mid), CDQ(mid + 1, r);
	// 设计算法处理跨越区间的点对。
	return ;
} 
```

那么对于这题，如何设计算法？为方便叙述，将 $[l, mid]$ 区间命名为 $A$ 区间，$(mid, r]$ 区间命名为 $B$ 区间。

首先我们已经按 $a$ 进行了排序，所以有性质：对于任意 $i \in A$，$j \in B$，都有 $a_i \le a_j$。

所以，我们需要统计的是满足 $i \in A$，$j \in B$，且满足 $b_i \le b_j$ 且 $c_i \le c_j$ 的个数。

我们接着对 $A$ 和 $B$ 这两个区间分别按 $b$ 进行排序，注意到原先的性质仍然存在。

我们使用两个双指针，$pl$ 和 $pr$ 分别指向 $A$ 和 $B$ 区间的数，初始时都指向各自区间最左边的数。注意到当 $pr$ 向右移动时，满足 $b_i \le b_{pr}$ 的 $i$ 只会向右移动，且原先的 $i$ 一定满足。于是我们得到单调性：$pr$ 向右移动时，$pl$ 也只会向右移动。

所以对于 $pr$，区间 $[l, pl]$ 的数 $i$ 都满足 $a_i \le a_{pr}$ 且 $b_i \le b_{pr}$。我们只需要统计区间 $[l, pl]$ 中有多少个数满足 $c_i \le c_{pr}$ 即可。

于是容易想到对 $c$ 建立一个权值树状数组（线段树也可以，更繁琐），$pl$ 向右移动时将 $c_{pl}$ 加入数组，对于 $pr$ 查询 $[1, c_{pr}]$ 的个数即可。

有很多细节需要注意：每次递归函数中都要清空树状数组，且不能暴力清空，否则影响复杂度，复杂度分析后面有。

代码不长。

```cpp
void CDQ(int l, int r) {
	if (l == r)
		return ;
	int mid = (l + r) >> 1;
	CDQ(l, mid), CDQ(mid + 1, r);
	sort(ar + l, ar + mid + 1, cmpb), sort(ar + mid + 1, ar + r + 1, cmpb);
	int pl = l, pr = mid + 1;
	while (pr <= r) {
		while (pl <= mid && ar[pl].b <= ar[pr].b) {
			tr.add(ar[pl].c, ar[pl].num);
			++pl;
		}
		ar[pr].ans += tr.sum(ar[pr].c);
		++pr;
	}
	for (int k = l; k < pl; ++k) // 清空树状数组。
		tr.add(ar[k].c, -ar[k].num);
	return ;
} 
```

最后统计答案时不要忘记重复点对的贡献！

好吧，差点忘记写复杂度分析了。

### 时间复杂度分析

外层排序：$O(n \log n)$。

内层 CDQ 分治：单次排序与维护树状数组 $O(n \log n)$，总时间复杂度 $T(n) = O(n \log n) + 2T(\frac{n}{2}) = O(n (\log n) ^ 2)$。

### 完整代码

```cpp
// CDQ 分治模板。
#include <bits/stdc++.h>
#define lowbit(x) (x & -x);
using namespace std;
typedef long long ll;
const int N = 100005;
const int V = 200005;
int n, m, k;
ll tot[N];
struct Node {
	int a, b, c;
	int ans, num; // num 为重复个数。
} ar[N], tmp[N];
struct Tree {
	int t[V];
	int sum(int x) {
		int res = 0;
		while (x) {
			res += t[x];
			x -= lowbit(x);
		}
		return res;
	}
	void add(int x, int val) {
		while (x < V) {
			t[x] += val;
			x += lowbit(x);
		}
		return ;
	}
} tr;
int read(void) {
	int x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch)) {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x;
}
void write(int x) {
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + 48);
	return ;
}
bool cmp(Node x, Node y) {
	return (x.a < y.a) || (x.a == y.a && x.b < y.b) || (x.a == y.a && x.b == y.b && x.c < y.c);
}
bool cmpb(Node x, Node y) {
	return x.b < y.b;
}
bool check(Node x, Node y) {
	return (x.a != y.a || x.b != y.b || x.c != y.c);
}
void CDQ(int l, int r) {
	if (l == r)
		return ;
	int mid = (l + r) >> 1;
	CDQ(l, mid), CDQ(mid + 1, r);
	sort(ar + l, ar + mid + 1, cmpb), sort(ar + mid + 1, ar + r + 1, cmpb);
	int pl = l, pr = mid + 1;
	while (pr <= r) {
		while (pl <= mid && ar[pl].b <= ar[pr].b) {
			tr.add(ar[pl].c, ar[pl].num);
			++pl;
		}
		ar[pr].ans += tr.sum(ar[pr].c);
		++pr;
	}
	for (int k = l; k < pl; ++k) // 清空树状数组。
		tr.add(ar[k].c, -ar[k].num);
	return ;
} 
int main(void) {
	m = read(), k = read();
	for (int i = 1; i <= m; ++i)
		tmp[i].a = read(), tmp[i].b = read(), tmp[i].c = read();
	sort(tmp + 1, tmp + m + 1, cmp);
	// 去重，统计个数。
	int cnt = 0;
	for (int i = 1; i <= m; ++i) {
		++cnt;
		if (i == m || check(tmp[i], tmp[i+1])) {
			ar[++n] = tmp[i], ar[n].num = cnt;
			cnt = 0;
		}
	}
	CDQ(1, n);
	// 统计重复贡献！
	for (int i = 1; i <= n; ++i) {
		int real_ans = ar[i].ans + ar[i].num - 1; // 最后统计自身的重复贡献！
		tot[real_ans] += ar[i].num;
	}
	for (int i = 0; i < m; ++i) {
		write(tot[i]);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：__staring__ (赞：1)

这是一篇**二进制分组套小波矩阵**的题解。

# 静态二维偏序

三维偏序太困难了，我不会！

不妨先来考虑一个相关的问题，静态二维偏序：

有一个 $m \times m$ 的二维平面，初始给定其上 $n$ 个点 $(x_i,y_i)$，有 $q$ 次查询每次给出 $x_0,y_0$，求满足 $x_i \le x_0 \wedge y_i \le y_0$ 的点数（$n,m,q$ 同阶）。

这题我会！用主席树即可，预处理时空复杂度 $O(n\log{m})-O(n\log{m})$，单次询问复杂度 $O(\log{m})$。

要是我不会主席树，或者主席树被卡常，或者要求 $O(n)$ 线性空间怎么办？

我们可以使用**小波矩阵 (Wavelet Matrix)**，如果你不知道小波矩阵是什么，可以查看我的 [专栏](https://www.luogu.com.cn/article/w6s63rpj) 获得详细讲解，这里只做简要说明。

小波矩阵是基于值域二进制分解的静态简洁数据结构，能在 $O(n\log{m})-O(\frac{n\log{m}}{\omega})$ 的时空复杂度预处理后，单次 $O(\log{m})$ 地回答区间 k 小或区间排名等查询（若查询信息带权，空间复杂度为 $O(n\log{m})$）。

### 预处理

假设当前要构建序列 $a_i$ 的小波矩阵 $b_{u,i}$。

初始取二进制最高位，令 $u=\log{m}$。

$b_{u,i}$ 即为当前的 $a_i$ 第 $u$ 位的值，之后将 $a_i$ 按 $(b_{u,i},i)$ 关键字排序，令 $u \larr u-1$。

可以发现当 $u \rarr u-1$ 时，1 个区间只会被拆成 2 个区间，且一个第 $u$ 位全 0，另一个第 $u$ 位全 1，下文分别称为 0/1 区间，通过维护 $b_{u,i}$ 的前缀和可以快速转移。

由于 $b_{u,i}=0/1$，排序是 $O(n)$ 的，并且可以用 `bitset` 压位存储，因此预处理时空复杂度 $O(n\log{m})-O(\frac{n\log{m}}{\omega})$。

### 查询区间排名

假设当前要求 $[L,R]$ 中 $\le v$ 的元素个数。

维护序列上的区间 $[l,r]$ 表示，此区间中的元素未被统计，且区间外的元素都被统计，初始令 $l=L,r=R$，以及二进制位 $u=\log{m}$。

若 $v$ 的第 $u$ 位为 1，那么所有 0 区间的元素都加入答案，将 $[l,r]$ 转移到 1 区间，否则直接将 $[l,r]$ 转移到 0 区间，令 $u \larr u-1$。

枚举结束后后统计的是 $<v$ 的元素个数，还需将答案加上 $r-l+1$。

每次转移通过 $O(1)$ 查询 $b_{u,i}$ 的前缀和可以做到 $O(1)$，因此单次查询复杂度 $O(\log{m})$，因此如果要查询 $b_{u,i}$ 的带权前缀和，只能 $O(n\log{m})$ 空间。

### 解决问题

将点按 $(x,y)$ 的关键字排序后，构建 $y_i$ 的小波矩阵，每次查询时二分出按 $(x,y)$ 关键字比较时，$(x_k,y_k) \le (x_0,y_0)$ 的最大 $k$，在小波矩阵上查询 $[1,k]$ 中 $\le y_0$ 的元素个数即为答案，总复杂度 $O(n\log{n}+(n+q)\log{m})$。

# 静态转动态

再考虑另一个相关问题，动态二维偏序：

有一个 $m \times m$ 的二维平面，有 $n$ 次操作：插入一个点 $(x,y)$，或查询有多少已插入的点中满足 $x_i \le X \wedge y_i \le Y$。

考虑如何用静态的小波矩阵解决动态问题。

### 分块

一个比较直接的想法是，设立阈值 $B$，每有 $B$ 次插入就令其为一组，构建这 $B$ 个点的小波矩阵。

查询时，枚举已构建的 $O(\frac{n}{B})$ 组小波矩阵进行查询，而对于还未成组的 $O(B)$ 次插入，直接暴力枚举检查，总复杂度为 $O(\frac{n}{B} \cdot B\log{m} + n \cdot (\frac{n}{B} \cdot \log{m} + B))$，取 $B=\sqrt{n\log{m}}$ 平衡查询，得到最优复杂度 $O(n\log{m} + n\sqrt{n\log{m}})=O(n\sqrt{n\log{m}})$。

### 自顶向下分组

考虑优化未成组暴力查询的部分，若每 $B_2$ 个插入重构为大组，未重构为大组的 $O(B_2)$ 个插入内每 $B_1$ 个插入重构为小组，未重构为小组的 $O(B_1)$ 个插入暴力查询，最终平衡复杂度得到 $O(n^{\frac{4}{3}}\log^{\frac{2}{3}}{m})$。

再取一次阈值呢？设每 $B_1$ 个插入重构为小组，每 $B_2$ 个插入重构为中组，每 $B_3$ 个插入重构为大组，平衡后复杂度为 $O(n^{\frac{5}{4}}\log^{\frac{3}{4}}{m})$。

通过计算可以发现，若每 $B_k$ 个插入重构为最大的组，一直到每 $B_1$ 个插入重构为最小的组，复杂度为 $O(kn\log{m}(\frac{n}{\log{m}})^{\frac{1}{k}})$。

### 二进制分组（自底向上合并）

但是这样的自顶向下散块分组很不实用，太麻烦了！不如转换思路，自底向上整块合并。

也即，设若干阈值 $B_1,B_2,\dots,B_k$，每 $B_1$ 个插入重构为 1 级组，每 $B_2$ 个 1 级组重构为 2 级组，…，每 $B_i$ 个 $i-1$ 级组重构为 $i$ 级组。

发现每个 $i$ 级组内含 $\prod_{u=1}^i B_u$ 个元素，因此直接令 $B_1=B_2=\dots=B_k=2$，得到 $k=\log{n}$，这样每个插入会参与 $O(\log{n})$ 次重构，每次查询最多有 $O(\log{n})$ 组。

这就是**二进制分组**，若已插入 $k$ 个元素，$u$ 级组存在当且仅当 $k$ 的第 $u$ 位为 1，如果画出合并树，容易发现与线段树本质相同。

# 二维转三维

对于三维偏序，我们将所有元素按 $(a,b,c)$ 关键字排序并去重，记 $v_i$ 表示有多少个元素和 $i$ 相同，这样 $i$ 统计到的元素都在 $[1,i-1]$。

随后将元素 $(a_i,b_i,c_i,v_i)$ 视为，查询此时二维平面上有多少点满足 $x \le b_i \wedge y \le c_i$，之后在平面上插入 $v_i$ 个点 $(b_i,c_i)$。

这样三维偏序就被处理成了动态二维偏序。

综上，将三维偏序转为动态二维偏序，使用二进制分组套小波矩阵，我们可在 $O(n\log^2{n})-O(\frac{n\log{n}}{\omega})$ 的时空复杂度预处理后，以 $O(\log^2{n})$ 的复杂度回答单次询问。

# 扩展

如果题目操作除了插入还有删除怎么办？插入 $2^k-1$ 个点后，重复插入删除，每次操作都要重构 $2^k-1$ 个点，那复杂度就假了。

对于数点这种有可减性的信息，我们可以对删除操作另维护一组负贡献的二进制分组，查询时两组做差。

若信息不具有可减性，但是删除操作是撤销上一次插入，那么可以考虑懒惰合并，即当有 3 个 $k-1$ 级组时合并其中 2 组至 $k$ 级，这样每 $O(2^k)$ 次操作才会重构一次 $k$ 级组，均摊复杂度还是 $O(\log{n})$ 的。

如果不想用二进制分组，可以直接把小波矩阵做成动态的吗？

可以，把内层的 `bitset` 换成平衡树即可。

# 实现

小波矩阵查询时，维护的区间可写成左闭右开 $(l,r]$，这样就无需对 $l$ 进行偏移。

合并时实际上不需要清空不存在的组别，可以只重构新出现的组别。

[提交记录](https://www.luogu.com.cn/record/221308799)，这里的实现魔改了专栏中的模板，可能常数较大（857ms），空间为线性（5.79mb）。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace staring
{
    using LL = long long;
    using ULL = unsigned long long;
    #define fir first
    #define sec second

    #define FOR(i,a,b) for(int i = (a), i##E = (b); i <= i##E; i ++)
    #define ROF(i,a,b) for(int i = (a), i##E = (b); i >= i##E; i --)

    template <typename TYPE>
    int gmax(TYPE &x, const TYPE& y) {return x < y ? x = y, 1 : 0;}
    template <typename TYPE>
    int gmin(TYPE &x, const TYPE& y) {return y < x ? x = y, 1 : 0;}

    static constexpr int SIZE = 1 << 20;
    static char buffin[SIZE]{}, *pin1{}, *pin2{};
    static char buffout[SIZE]{}, *pout{buffout};
    #define GETC() (pin1 == pin2 && (pin2 = (pin1 = buffin) + fread(buffin, 1, SIZE, stdin), pin1 == pin2)? EOF : *pin1++)
    #define PUTC(c) (pout - buffout == SIZE && (fwrite(buffout, 1, SIZE, stdout), pout = buffout), (*pout++ = c))
    template <typename TYPE>
    void read(TYPE &x)
    {
        static int signf{0}, chin{0};
        x = signf = 0, chin = GETC();
        while(chin < '0' || chin > '9') signf |= chin == '-', chin = GETC();
        while(chin >= '0' && chin <= '9') x = (x << 3) + (x << 1) + (chin ^ 48), chin = GETC();
        if(signf) x = -x;
    }
    template <typename TYPE>
    void write(TYPE x, char ch = ' ')
    {
        static int stack[64]{}, top{0};
        !x && PUTC('0'), x < 0 && (x = -x, PUTC('-'));
        while(x) stack[top++] = x % 10, x /= 10;
        while(top) PUTC(stack[--top] | 48);
        if(ch) PUTC(ch);
    }

}using namespace staring;

constexpr int N = 1e5 + 5;

tuple <int, int, int> t[N];
pair <int, int> lshy[N];
int lshz[N], tmp0[N], tmp1[N << 1];
int res[N];

struct bitSet
{
    #define ppcll __builtin_popcountll

    int n, zero;
    vector <pair <ULL, int>> bit;

    bitSet(int _n): n(_n), zero(_n)
    {
        bit.resize((n >> 6) + 1, make_pair(0, 0));
    }

    void clear()
    {
        zero = n;
        fill(begin(bit), end(bit), make_pair(0, 0));
    }

    void set(int k)
    {
        --zero;
        bit[k >> 6].fir |= 1ull << (k & 63);
    }

    void init()
    {
        FOR(i, 1, n >> 6)
            bit[i].sec = bit[i - 1].sec + ppcll(bit[i - 1].fir);
    }

    int rank1(int k)
    {
        return bit[k >> 6].sec + ppcll(bit[k >> 6].fir << (~k & 63));
    }

    int rank0(int k)
    {
        return k - rank1(k);
    }

    #undef ppcll
};

struct waveletMatrix
{
    int len, cnt;
    vector <bitSet> bit;

    void init(int _len)
    {
        len = _len;
        bit.resize(len + 1, bitSet(1 << len));
    }

    void build(int tot)
    {
        int p = tot >> len + 1 << len + 1;
        int l = p + 1, r = p + (1 << len);
        sort(lshy + l, lshy + r + 1);
        sort(lshz + l, lshz + r + 1);
        cnt = unique(lshz + l, lshz + r + 1) - lshz - l;
        FOR(i, l, l + cnt - 1) tmp1[lshz[i]] = i - l;
        FOR(i, 1, 1 << len) tmp0[i] = tmp1[lshy[i + p].sec];

        ROF(u, __lg(cnt), 0)
        {
            int x = 0, y = 0;
            bit[u].clear();
            FOR(i, 1, 1 << len)
                if(tmp0[i] >> u & 1)
                    tmp1[++y] = tmp0[i], bit[u].set(i);
                else tmp0[++x] = tmp0[i];
            bit[u].init();
            memcpy(tmp0 + x + 1, tmp1 + 1, sizeof(int[y]));
        }
    }

    int id(int u, int k, int c)
    {
        return !c ? bit[u].rank0(k) : bit[u].zero + bit[u].rank1(k);
    }

    int ranking(int tot)
    {
        int p = tot >> len + 1 << len + 1, L = p + 1, R = p + (1 << len);
        int l = 0, r = upper_bound(lshy + L, lshy + R + 1, lshy[tot + 1]) - lshy - L;
        int v = upper_bound(lshz + L, lshz + L + cnt, lshy[tot + 1].sec) - lshz - L;

        int res = 0;
        ROF(u, __lg(cnt), 0)
        {
            int c = v >> u & 1;
            if(c) res += bit[u].rank0(r) - bit[u].rank0(l);
            l = id(u, l, c), r = id(u, r, c);
        }
        return res;
    }
};

void mainSolve()
{
    int n, m;
    read(n), read(m);
    FOR(i, 1, n)
    {
        auto& [a, b, c] = t[i];
        read(a), read(b), read(c);
    }

    int d = 0;
    while(1 << d < n) ++d;
    vector <waveletMatrix> wave(d);
    FOR(i, 0, d - 1) wave[i].init(i);
    sort(t + 1, t + n + 1);
    FOR(i, 1, n)
    {
        auto [x, y, z] = t[i];
        lshy[i] = make_pair(y, z);
        lshz[i] = z;
    }

    FOR(i, 1, n)
    {
        int j = i;
        while(j < n && lshy[j + 1] == lshy[i]) ++j;

        int cur = j - i;
        for(int d = i - 1; d; d &= d - 1)
        {
            int u = __lg(-d & d);
            cur += wave[u].ranking(i - 1);
        }
        res[cur] += j - i + 1;

        for(int d = j; d; d &= d - 1)
        {
            int u = __lg(-d & d);
            if((j >> u) == (i - 1 >> u)) break;
            wave[u].build(j);
        }
        i = j;
    }

    FOR(i, 0, n - 1)
        write(res[i], '\n');
}

int main()
{
    auto fileIO = [](string file)
    {
        string In = file + ".in";
        string Out = file + ".out";
        freopen(In.c_str(), "r", stdin);
        freopen(Out.c_str(), "w", stdout);
    };
    // fileIO("");

    int testCount = 1;
    // read(testCount);
    while(testCount--) mainSolve();

    fwrite(buffout,1,pout-buffout,stdout);
    return 0;
}
```

---

## 作者：chentianmiao (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P3810)
## 前置知识：CDQ分治
‌CDQ 分治的主要作用是解决偏序问题‌。
### CDQ分治的基本原理
CDQ 分治的核心思想是将一个序列递归地分成两部分，先解决左半部分的问题，然后处理左半部分对右半部分的影响，最后解决右半部分的问题。具体步骤如下：

1.  找到范围中点 $mid‌$，递归解决 $(l,mid)$ 部分。
2.  递归解决 $(mid+1,r)$ 部分‌。
3.  处理 $mid$ 左边的修改对 $mid$ 右边查询的影响‌，计入答案‌。
### 正确性说明
*   由于所有操作按照时间顺序排序，因此在处理某个查询时，所有在此之前发生的修改操作都会被优先处理。这意味着，在递归过程中，左半部分的所有修改操作会被先应用到数据结构中，从而确保右半部分的查询能够正确反映这些修改的影响。
*   递归分解的过程保证了每个子问题的独立性和完整性。对于每个子问题，其内部的操作顺序仍然保持一致，且跨越左右两部分的查询能够在递归过程中被正确处理。这种递归分解的方式确保了全局问题的正确性。

## 思路分析

原题是三维偏序，那么先看二维偏序。

思路应该很容易想到，以 $a$ 为第一关键字排序，$b$ 为第二关键字排序，于是就去掉了一维，在第二关键字上建立 bit，复杂度 $\mathcal O (n \log n)$。

那三位偏序怎么办？此时我们可以加上 CDQ 分治。CDQ 分治，简单的来讲是一种二分，但又有些不同。

首先，以 $a$ 为第一关键字排序，$b$ 为第二关键字排序，$c$ 为第三关键字排序，此时第一维一定是有序的。

每次我们都将整个问题分割成左右两个子问题，先处理左子问题（此时左子问题的答案一定是对的），用左子问题更新右子问题，再在右子问题的内部计算，得到正确答案。

那么我们希望继续使用 bit，那么第二维也需要是有序的，于是我们可以在做完后以 $b$ 为第一关键字排序。这时问题变成了二维，仅含有 $b$ 和 $c$。于是可以按照原来的做法 bit 了。

但看看题目，两个点似乎可能重叠！

我们可以缩点解决这个问题，给每个点加属性，记录该位置点的个数。

对应也要修改细节，bit 加点时，注意是 `add(q[i].z,q[i].num)` 而不是 `add(q[i].z,1)`。同时，最后算答案时，是 `ans[q[i].id]=q[i].ans+q[i].num-1`。

### 进一步的优化

提交发现 TLE，这时每次分治的复杂度为 $\mathcal O(n \log n)$，而分治的深度为 $\mathcal O(\log n)$，因此总时间复杂度为 $\mathcal O(n \log ^2 n)$。

分析发现不需要每次在做完后以 $b$ 为第一关键字排序，可以使用临时数组来将原数组归并，虽然复杂度不变，但时间似乎减少了很多。

这样时间上就快了很多，问题解决。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100009;
struct Point{
	ll x,y,z,id,num,ans;
}p[N],q[N],tmp[N];
ll n,nUnq,mxz,cnt[N],ans[N],bit[200009];
ll lowbit(ll i){
	return i&(-i);
}
void add(ll x,ll d){
	while(x<=mxz){
		bit[x]+=d;
		x+=lowbit(x);
	}
}
ll psq(ll x){
	ll ans=0;
	while(x>0){
		ans+=bit[x];
		x-=lowbit(x);
	}
	return ans;
}
bool cmpX(const Point&a,const Point&b){
	if(a.x<b.x){
		return 1;
	}
	if(a.x>b.x){
		return 0;
	}
	if(a.y<b.y){
		return 1;
	}
	if(a.y>b.y){
		return 0;
	}
	if(a.z<b.z){
		return 1;
	}
	if(a.z>b.z){
		return 0;
	}
	return a.id<b.id;
}
void cross(ll l,ll r){
	ll mid=(l+r)>>1;
	ll i=l;
	for(ll j=mid+1;j<=r;j++){
		while(i<=mid&&q[i].y<=q[j].y){
			add(q[i].z,q[i].num);
			i++;
		}
		q[j].ans+=psq(q[j].z);
	}
	for(--i;i>=l;--i){
		add(q[i].z,-q[i].num);
	}
}
void merge(ll l,ll r){
	ll mid=(l+r)>>1;
	ll i=l,j=mid+1;
	for(ll k=l;k<=r;k++){
		if(i<=mid&&(j>r||q[i].y<=q[j].y)){
			tmp[k]=q[i++];
		}else{
			tmp[k]=q[j++];
		}
	}
	for(ll k=l;k<=r;k++){
		q[k]=tmp[k];
	}
}
void cdq(ll l,ll r){
	if(l==r){
		return;
	}
	ll mid=(l+r)>>1;
	cdq(l,mid);
	cdq(mid+1,r);
	cross(l,r);
	merge(l,r);
}
int main(){
	cin>>n>>mxz;
	for(ll i=1;i<=n;i++){
		cin>>p[i].x>>p[i].y>>p[i].z;
		p[i].id=i;
		p[i].num=1;
	}
	sort(p+1,p+n+1,cmpX);
	p[0].x=-1e9;
	for(ll i=1;i<=n;i++){
		if(p[i].x==p[i-1].x&&p[i].y==p[i-1].y&&p[i].z==p[i-1].z){
			q[nUnq].num++;
		}else{
			q[++nUnq]=p[i];
		}
	}
	cdq(1,nUnq);
	for(ll i=1;i<=nUnq;i++){
		ans[q[i].id]=q[i].ans+q[i].num-1;
	}
	for(ll i=1;i<=n;i++){
		if(p[i].x==p[i-1].x&&p[i].y==p[i-1].y&&p[i].z==p[i-1].z){
			ans[p[i].id]=ans[p[i-1].id];
		}
	}
	for(ll i=1;i<=n;i++){
		cnt[ans[i]]++;
	}
	for(ll i=0;i<n;i++){
		cout<<cnt[i]<<endl;
	}
	return 0;
}
```

---

## 作者：Wddie (赞：1)

这题的做法有很多，下面只介绍一种最简单的做法—— bitset。  
#### 算法介绍
由于题目中的条件是求一个交集，而 bitset 可以在  $O(\frac{n}{w})$ 的相对较低的复杂度内快速求出两个集合的交集，所以考虑用 bitset。  
于是乎，我们很容易地想到如下算法：

1. 将 $a$、$b$、$c$ 从小到大排序，并求出每一个数在原数组中的下标，将得到的三个下标数组定义为 $h_1$、$h_2$、$h_3$ 。  
1. 将这三个下标数组中每一个前缀所组成的、由下标构成的集合用 bitset 表示出来。
1. 同时，设一个集合数组 $b$，初始时，假设现在遍历到了 $h_0$ 中的第 $i$ 个元素，且 $h_1$ 到 $h_{i-1}$ 构成的集合为 $S$，则令：
$$  b_{h_{0_i}}=b_{h_{0_i}} \cap S
1. 更新完毕之后，维护 $S$ 集合。算法结束之后，枚举 $i$，用 $b_i$ 的大小更新答案即可。
    
这个算法有两个问题：
 * 无法处理重复的元素。
 * 空间复杂度过高。
   
上述的第一个问题比较好解决，用线性表（例如栈）来维护相同元素，遇到不同元素或到结尾的时候，一边清空栈、一边计算答案即可。  
对于第二个问题，我们可以将整个序列分成若干段，在计算交集时，只有这个段内的数字有资格被计算（即只有它们能入栈，而其它的操作仍照常进行（例如更新 $S$ 集合）。
#### 正确性证明
显然。  
由于 bitset 求一次交集的时间复杂度为 $O(\frac{n}{w})$，而总共要求 $n$ 次交集，所以总时间复杂度为 $O(\frac{n^2}{w})$。
#### 代码实现
code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,u,a[3][N],h[3][N],stk[N],tot;
int ans[N];
bitset<N>b[(N/3)+5],sum_set;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>u;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=2;j++){
			cin>>a[j][i];
			h[j][i]=i;
		}
	}
	for(int i=0;i<3;i++){
		sort(h[i]+1,h[i]+n+1,[&](int x,int y)->bool{
			return a[i][x]<a[i][y];
		});
//		for(int j=1;j<=n;j++){
//			cerr<<h[i][j]<<' ';
//		}
//		cerr<<'\n';
	}
	int len=(n/3)+1;
	for(int k=0;k<=2;k++){//分成3批计算
		for(int i=1;i<=len;i++){
			b[i].set();
		}
		for(int i=0;i<=2;i++){
			sum_set.reset();
			for(int j=1;j<=n;j++){
				while(tot&&(a[i][h[i][j]]!=a[i][stk[tot]])){
//					cerr<<i<<' '<<tot<<' '<<h[i][j]<<' '<<stk[tot]<<'\n';
//					for(int w=1;w<=10;w++){
//						cerr<<b[stk[tot]-k*len][w];	
//					}
//					cerr<<'\n';
//					for(int w=1;w<=10;w++){
//							cerr<<sum_set[w];
//					}
					b[stk[tot--]-k*len]&=sum_set;
				}
	
				if(k*len<h[i][j]&&h[i][j]<=(k+1)*len){
					stk[++tot]=h[i][j];
				}
				sum_set[h[i][j]]=1;	
			}
			while(tot){
				b[stk[tot--]-k*len]&=sum_set;
			}
		}
		for(int i=1;i<=len&&(k*len+i<=n);i++){
//			cerr<<k*len+i<<'\n';
//			for(int j=1;j<=10;j++){
//				cerr<<b[i][j];
//			}
//			cerr<<'\n'<<b[i].count()-1<<'\n';
			ans[b[i].count()-1]++;
		}
	}
	for(int i=0;i<n;i++){
		cout<<ans[i]<<'\n';
	}
	return 0;
}
```

---

## 作者：liheyang123 (赞：1)

省流：主要介绍的解法是排序处理第一维 $a_i$，分治处理第二维 $b_i$，树状数组处理第三维 $c_i$。

---

# 三维偏序的定义

## 数学定义
给定 $n$ 个三维点构成的集合 $S = \\{P_1, P_2, \dots, P_n\\}$，其中每个点 $P_i = (a_i, b_i, c_i)$。

对于任意两点 $P_i, P_j \in S$，定义偏序关系 $\preceq$ 为：
$$
P_j \preceq P_i \iff 
\begin{cases}
a_j \leq a_i \\
b_j \leq b_i \\
c_j \leq c_i \\
j \neq i
\end{cases}
$$

## 问题描述
对于每个点 $P_i$，计算满足 $P_j \preceq P_i$ 的点 $P_j$ 的数量：
$$
\operatorname{f}(i) = \left| \\{ P_j \in S \mid P_j \preceq P_i \\} \right|
$$

## 算法复杂度比较
| 方法                | 时间复杂度         | 空间复杂度 |
|---------------------|-------------------|------------|
| 暴力枚举            | $O(n^2)$          | $O(n)$     |
| CDQ分治+树状数组    | $O(n\log^2 n)$    | $O(n)$     |
| 分块                | $O(n\sqrt{n})$    | $O(n)$     |

## 示例计算
给定点集：
$$
\begin{aligned}
P_1 &= (1, 3, 2) \\
P_2 &= (1, 2, 1) \\
P_3 &= (2, 2, 3)
\end{aligned}
$$

则：
$$
\begin{aligned}
f(1) &= 1 \quad (P_2 \preceq P_1) \\
f(2) &= 0 \\
f(3) &= 2 \quad (P_1, P_2 \preceq P_3)
\end{aligned}
$$

---

# solution
## 文字解释
不难想到排序处理第一维 $a_i$，分治处理第二维 $b_i$，树状数组处理第三维 $c_i$。

首先，可以注意到按照 $a_i$ 排序后，有且仅有 $j<i$ 时，$p_j$ 可能对 $\operatorname{f}(i)$ 造成贡献。

然后分治体现在归并排序中，在处理区间 $[pl, pr]$ 时，假设 $[pl, mid]$，$(mid, pr]$ 中已经在更小的分治中变得有序（显然 $pl = pr$ 时已经有序，这也是分治边界条件），那么可以考虑双指针，对于 $\forall i \in (mid, pr]$ 找出所有 $j$ 满足 $j \in [pl, mid]\cap a_j < a_i$。

此时就可以将 $c_j$ 加入权值树状数组，然后查询即可。

## code
此处省去了头文件与 IO 部分。
```cpp
const int N = 1e5 + 10;
int n, k, p[N];
struct node{
	int a, b, c, id, cnt;
	bool operator<(const node &rhs) const {
        if (a != rhs.a) return a < rhs.a;
        if (b != rhs.b) return b < rhs.b;
        return c < rhs.c;
    }
    bool operator==(const node &rhs) const {
        return a == rhs.a && b == rhs.b && c == rhs.c;
    }
}a[N], tmp[N];
int tr[N << 1], ans[N], cnt[N];
void add(int x, int v){for(int i = x; i <= k; i += (i & -i)) tr[i] += v;}
int query(int x){int res = 0;for(int i = x; i; i -= (i & -i)) res += tr[i]; return res;}

void sol(int pl, int pr){
	if(pl == pr) return; 
	int mid = pl + pr >> 1;
	sol(pl, mid), sol(mid + 1, pr);
	int i = pl, j = mid + 1, k = pl;
    while (i <= mid && j <= pr) {
        if (a[i].b <= a[j].b) {
            add(a[i].c, a[i].cnt);
            tmp[k++] = a[i++];
        } else {
            ans[a[j].id] += query(a[j].c);
            tmp[k++] = a[j++];
        }
    }
    while (i <= mid) {
        add(a[i].c, a[i].cnt);
        tmp[k++] = a[i++];
    }while (j <= pr) {
        ans[a[j].id] += query(a[j].c);
        tmp[k++] = a[j++];
    }
    for (i = pl; i <= mid; i++) add(a[i].c, -a[i].cnt); // 清空树状数组
    for (i = pl; i <= pr; i++) a[i] = tmp[i];
} 

signed main(){
	// 1. 按照 a 排序。 
	// 2. 分治处理 b。 
	// 3. 树状数组处理 c。 
	n = read(), k = read();
	for(int i = 1; i <= n; i++) a[i].a = read(), a[i].b = read(), a[i].c = read(), a[i].cnt = 1;
	int m = 1;
	sort( a + 1, a + 1 + n );
	for (int i = 2; i <= n; i++) {
        if(a[i] == a[m]) a[m].cnt++;
        else a[++m] = a[i];
    }
    for(int i = 1; i <= m; i++) a[i].id = i;
	sol(1, m);
	for(int i = 1; i <= m; i++) ans[a[i].id] += a[i].cnt - 1;
	for(int i = 1; i <= m; i++) cnt[ans[a[i].id]] += a[i].cnt;
	for(int i = 0; i < n; i++) write(cnt[i]);
	flush();
	return 0;
}
```
## 复杂度分析
### 时间复杂度
排序 $O(n \log n)$，分治 $O(n \log n)$，树状数组操作 $O(\log k)$。
- **最优情况**：O(n log n log k)
- **最坏情况**：O(n log n log k)
  
### 空间复杂度
$O(n + k)$ 存储点和树状数组。

---


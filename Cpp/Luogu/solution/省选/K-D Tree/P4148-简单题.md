# 简单题

## 题目描述

你有一个$N \times N$的棋盘，每个格子内有一个整数，初始时的时候全部为 $0$，现在需要维护两种操作：

- `1 x y A`    $1\le x,y\le N$，$A$ 是正整数。将格子`x`,`y`里的数字加上 $A$。
- `2 x1 y1 x2 y2`    $1 \le x_1 \le x_2 \le N$，$1 \le y_1\le y_2 \le N$。输出 $x_1, y_1, x_2, y_2$ 这个矩形内的数字和
- `3`    无 终止程序


## 说明/提示

$1\leq N\leq 5\times 10^5$，操作数不超过 $2\times 10^5$ 个，内存限制 $20\texttt{MB}$，保证答案在 int 范围内并且解码之后数据仍合法。


## 样例 #1

### 输入

```
4
1 2 3 3
2 1 1 3 3
1 1 1 1
2 1 1 0 7
3```

### 输出

```
3
5```

# 题解

## 作者：litble (赞：45)

丧心病狂的强制在线!这样我们就用不了CDQ分治了,只能上KD-Tree了.

首先,对于修改操作,都可以视作插入一个点,同样,如果插入后导致KD-Tree不平衡,就要暴力重建.

对于查询操作,我们可以维护每一棵子树中所有点x和y坐标的最大/最小值,如果当前子树整棵树都在当前查询矩形内,就可以直接返回这棵子树中的权值和.如果当前子树整棵树都不在当前查询矩形内,就可以直接返回0.否则,先查询当前节点代表的点是否在查询矩形中,然后递归查询当前节点的两个子节点.

细节很多,注意不要手贱开long long,并且如果RE了,可以尝试使用开O2来A掉这题.

代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int q=0,w=1;char ch=' ';
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q*w;
}
const int N=200005;
struct point{int x[2],w;}p[N];
struct node{int mi[2],mx[2],sum,ls,rs,sz;point tp;}tr[N];
int n,ans,rt,WD,top,cur,rub[N];
int operator < (point a,point b) {return a.x[WD]<b.x[WD];}
int newnode() {//建立一个新节点,rub:垃圾回收栈
	if(top) return rub[top--];
	else return ++cur;
}
void up(int k) {//提取子树最大/最小值,子树大小,权值和
	int l=tr[k].ls,r=tr[k].rs;
	for(int i=0;i<=1;++i) {
		tr[k].mi[i]=tr[k].mx[i]=tr[k].tp.x[i];
		if(l) tr[k].mi[i]=min(tr[k].mi[i],tr[l].mi[i]);
		if(r) tr[k].mi[i]=min(tr[k].mi[i],tr[r].mi[i]);
		if(l) tr[k].mx[i]=max(tr[k].mx[i],tr[l].mx[i]);
		if(r) tr[k].mx[i]=max(tr[k].mx[i],tr[r].mx[i]);
	}
	tr[k].sum=tr[l].sum+tr[r].sum+tr[k].tp.w,tr[k].sz=tr[l].sz+tr[r].sz+1;
}
int build(int l,int r,int wd) {//重新建树
	if(l>r) return 0;
	int mid=(l+r)>>1,k=newnode();
	WD=wd,nth_element(p+l,p+mid,p+r+1),tr[k].tp=p[mid];
	tr[k].ls=build(l,mid-1,wd^1),tr[k].rs=build(mid+1,r,wd^1);
	up(k);return k;
}
void pia(int k,int num) {//把树还原成序列
	if(tr[k].ls) pia(tr[k].ls,num);
	p[tr[tr[k].ls].sz+num+1]=tr[k].tp,rub[++top]=k;
	if(tr[k].rs) pia(tr[k].rs,num+tr[tr[k].ls].sz+1);
}
void check(int &k,int wd) {//检查树是否依然平衡,不平衡则重建
	if(tr[k].sz*0.75<tr[tr[k].ls].sz||tr[k].sz*0.75<tr[tr[k].rs].sz)
		pia(k,0),k=build(1,tr[k].sz,wd);
}
void ins(int &k,point tmp,int wd) {//插入
	if(!k) {k=newnode(),tr[k].ls=tr[k].rs=0,tr[k].tp=tmp,up(k);return;}
	if(tmp.x[wd]<=tr[k].tp.x[wd]) ins(tr[k].ls,tmp,wd^1);
	else ins(tr[k].rs,tmp,wd^1);
	up(k),check(k,wd);
}
int in(int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2) {
	return (X1>=x1&&X2<=x2&&Y1>=y1&&Y2<=y2);
}//检查是否在查询矩形内
int out(int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2) {
	return (x1>X2||x2<X1||y1>Y2||y2<Y1);
}//检查是否在查询矩形外
int query(int k,int x1,int y1,int x2,int y2) {
	if(!k) return 0;
	int re=0;
	if(in(x1,y1,x2,y2,tr[k].mi[0],tr[k].mi[1],tr[k].mx[0],tr[k].mx[1])) return tr[k].sum;
	if(out(x1,y1,x2,y2,tr[k].mi[0],tr[k].mi[1],tr[k].mx[0],tr[k].mx[1])) return 0;
	if(in(x1,y1,x2,y2,tr[k].tp.x[0],tr[k].tp.x[1],tr[k].tp.x[0],tr[k].tp.x[1]))
		re+=tr[k].tp.w;//对当前点做判断
	re+=query(tr[k].ls,x1,y1,x2,y2)+query(tr[k].rs,x1,y1,x2,y2);
	return re;//递归求解
}
int main() {
	int bj,x1,y1,x2,y2;
	n=read();
	while("STO Cai Orz") {
		bj=read(); if(bj==3) break;
		if(bj==1) ins(rt,(point){read()^ans,read()^ans,read()^ans},0);
		else {
			x1=read()^ans,y1=read()^ans,x2=read()^ans,y2=read()^ans;
			ans=query(rt,x1,y1,x2,y2),printf("%d\n",ans);
		}
	}
    return 0;
}
```

---

## 作者：yy1695651 (赞：26)

### 分块+线段树

这个方法应该比K-Dtree简单的多吧。对于长度为n的x轴区间进行分块，对每一列和每一个块维护一个动态开点线段树，对于修改操作，可以直接插入当前列和块的线段树中，对于查询操作，对块上和边角上的线段树进行二分即可。

但这样复杂度肯定很高，考虑到修改十分稀疏，可以给线段树开一个lazy标记，对于子树大小只有1的子树，可以先不建出来，把目标点记录在lazy中，二分是遇到lazy可以直接返回

不用O2也可以过

```cpp
#include <bits/stdc++.h>
#define mid ((l + r) >> 1)
#define lc T[p].l
#define rc T[p].r
#define lb(x) (x & -x)
using namespace std;
inline void read(int &x) {
  x = 0; int f = 1; char ch = getchar();
  while (!(ch >= '0' && ch <= '9')) { if (ch == '-') f = -1; ch = getchar(); }
  while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + ch - 48; ch = getchar(); }
  x *= f;
}
const int N = 5e5 + 10;
const int M = 1e6 + 10;
int n, blo, bel[N], last, rt[N + 700], tot;
struct Node {int l, r, lz, val;} T[M];
inline void pushdown(int p, int l, int r) {
    if (T[p].lz) {
        if (T[p].lz <= mid) lc = ++tot, T[lc].lz = T[p].lz, T[lc].val = T[p].val;
        else rc = ++tot, T[rc].lz = T[p].lz, T[rc].val = T[p].val;
        T[p].lz = 0;
    }
}
inline void modify(int &p, int x, int v, int l = 1, int r = n) {
    if (!p) {p = ++tot; T[p].lz = x; T[p].val = v; return;}
    pushdown(p, l, r); T[p].val += v; //注意顺序
    if (l == r) return;
    if (x <= mid) modify(lc, x, v, l, mid);
    else modify(rc, x, v, mid + 1, r);
}
inline int query(int p, int x, int l = 1, int r = n) {
    if (!p || !x) return 0;
    if (l == r) return T[p].val;
    if (T[p].lz) {return (x >= T[p].lz) * T[p].val;}
    if (x <= mid) return query(lc, x, l, mid);
    else return T[lc].val + query(rc, x, mid + 1, r);
}
int main() {
    read(n);
    blo = sqrt(n) * 1.5 + 2;
    for (int i = 1; i <= n; i++) bel[i] = (i - 1) / blo + 1;
    while (true){
        int opt; read(opt);
        if (opt == 3) break;
        if (opt == 1) {
            int x, y, v; read(x), read(y), read(v);
            x ^= last, y ^= last, v ^= last;
            modify(rt[x], y, v);
            modify(rt[n + bel[x]], y, v);
        } else {
            int x1, y1, x2, y2; read(x1), read(y1), read(x2), read(y2);
            x1 ^= last, y1 ^= last, x2 ^= last, y2 ^= last;
            int mn = min(bel[x1] * blo, x2), ans = 0;
            for (int i = x1; i <= mn; i++)
                ans += query(rt[i], y2) - query(rt[i], y1 - 1);
            if (bel[x1] != bel[x2])
            for (int i = (bel[x2] - 1) * blo + 1; i <= x2; i++)
                ans += query(rt[i], y2) - query(rt[i], y1 - 1);
            for (int i = bel[x1] + 1; i <= bel[x2] - 1; i++)
                ans += query(rt[i + n], y2) - query(rt[i + n], y1 - 1);
            last = ans;
            printf("%d\n", ans);
        }
    }
    return 0;
}

```

---

## 作者：Paul·Shi (赞：19)

# 【高级数据结构】K-D Tree
K-D Tree 是用来解决K维空间中数点问题强有力的数据结构，可以在 $(NlogN)$ ——$(N\sqrt{N})$ 的时间复杂度内完成查询和修改。
## 一、K-D Tree的做法
K-D Tree当K等于 $1$ 时，就是一颗替罪羊树树（平衡树的一种）。
我们把K-D Tree扩展到 $K$ 维空间。
K-D Tree是一颗权值树，我们对于每个树的结点用一个结构体来存
```cpp
struct K_D_Tree{
	int l,r,sum,val,size,Min[K],Max[K],d[K];
}tr[MAXN];
```
$l$ $r$ 分别是该结点的左孩子和右孩子

$sum$ 为以该点为根的子树区间中点权之和

$val$ 为该点所存的点的点权

$size$ 为该树为根的数中的点数

$Min[i]$ 表示在第 $i$ 维上区间的下界

$Max[i]$ 表示在第 $i$ 维上区间的上界

$d[i]$ 表示该位置表示的点的第 $i$ 维的坐标

### 插入操作
我们对于深度为 $i$ 的位置，我们按照 第 $i%k$ 维的坐标来排序、
然后就是普通平衡树的插入即可
我们设定一个**平衡因子**，一般设定为 &0.6~0.9$ 之间
```cpp
const double alpha=0.75;
```
当在插入是发现要插入的子树的 $size$ 比整棵树的 $size$ 的 $alpha$ 倍要大，即发现树不平衡，那么我们直接暴力重建该子树。

### 查询操作
直接平衡树的查询操作即可

### 删除操作
我们直接对要删除的点打删除标记，在插入时再删除，在查询或删除时时如果发现某颗子树的的删除标记个数大于一个定值，我们对于该子树暴力重构即可。

## 二、K-D Tree的几何性质

![312](https://img2018.cnblogs.com/blog/1552746/201812/1552746-20181217134935628-1037722984.png)

可以看上面一个以 $k$ 为 $2$ 为例的图

$K-D Tree$ 相当于每个结点对于其管辖的区间平行于坐标轴分割成一半，最后整个图被分成若干个区间，但这些区间的大小是不一致的，所以 $K-D Tree$ 是很容易被卡的。

# 模板题：

三维偏序：P4148 简单题

```cpp
#include<bits/stdc++.h>
#define MAXN 100010
using namespace std;
inline int read ()
{
	int s=0,w=1;
	char ch=getchar ();
	while (ch<'0'||ch>'9'){if (ch=='-') w=-1;ch=getchar ();}
	while ('0'<=ch&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar ();
	return s*w;
}
const double alpha=0.75;
const int K=2;
struct K_D_Tree{
	int l,r,sum,val,size,Min[K],Max[K],d[K];
}tr[MAXN];
int n,ans,root,len;
int p[K],q[K][2],A;
int D,num,h[MAXN];
bool cmp (const int &a,const int &b)
{
	return tr[a].d[D]<tr[b].d[D];
}
inline void update (int x)
{
	int l=tr[x].l,r=tr[x].r;
	tr[x].size=tr[l].size+tr[r].size+1;
	tr[x].sum=tr[l].sum+tr[r].sum+tr[x].val;
	for (int i=0;i<K;i++)
	{
		if (l) tr[x].Max[i]=max (tr[l].Max[i],tr[x].Max[i]),tr[x].Min[i]=min (tr[l].Min[i],tr[x].Min[i]);
		if (r) tr[x].Max[i]=max (tr[r].Max[i],tr[x].Max[i]),tr[x].Min[i]=min (tr[r].Min[i],tr[x].Min[i]);
	}
}
inline void build (int &x,int l,int r,int k)
{
	if (l>r) return;
	int mid=(l+r)>>1;D=k;
	nth_element (h+l,h+mid+1,h+r+1,cmp);
	x=h[mid];
	tr[x].sum=tr[x].val;
	for (int i=0;i<K;i++) tr[x].Max[i]=tr[x].Min[i]=tr[x].d[i];
	build (tr[x].l,l,mid-1,(k+1)%K);
	build (tr[x].r,mid+1,r,(k+1)%K);
	update (x);
}
inline void erase (int &x)
{
	if (!x) return;
	h[++num]=x;
	erase (tr[x].l),erase (tr[x].r);
	x=0;
}
inline void rebuild (int &x,int k)
{
	h[num=1]=++len;
	tr[len].size=1;
	for (int i=0;i<K;i++) tr[len].d[i]=p[i];
	tr[len].val=tr[len].sum=A;
	erase (x),build (x,1,num,k);
}
inline void insert (int &x,int k)
{
	if (!x)
	{
		tr[x=++len].size=1,tr[x].val=tr[x].sum=A;
		for (int i=0;i<K;i++) tr[x].Max[i]=tr[x].Min[i]=tr[x].d[i]=p[i];
		return;
	}
	if (p[k]<tr[x].d[k])
	{
		if (tr[tr[x].l].size>tr[x].size*alpha) rebuild (x,k);
		else insert (tr[x].l,(k+1)%K);
	}
	else
	{
		if (tr[tr[x].r].size>tr[x].size*alpha) rebuild (x,k);
		else insert (tr[x].r,(k+1)%K);
	}
	update (x);
}
inline bool check_range (int x)
{
	if (!x) return 0;
	for (int i=0;i<K;i++)
		if (q[i][0]>tr[x].Min[i]||q[i][1]<tr[x].Max[i]) return 0;
	return 1;
}
inline bool check_point (int x)
{
	if (!x) return 0;
	for (int i=0;i<K;i++)
		if (tr[x].d[i]<q[i][0]||tr[x].d[i]>q[i][1]) return 0;
	return 1;
}
inline bool check (int x)
{
	if (!x) return 0;
	for (int i=0;i<K;i++)
		if (q[i][1]<tr[x].Min[i]||q[i][0]>tr[x].Max[i]) return 0;
	return 1;
}
inline void query (int x)
{
	if (check_range (x))
	{
		ans+=tr[x].sum;
		return;
	}
	if (check_point (x)) ans+=tr[x].val;
	if (check (tr[x].l)) query (tr[x].l);
	if (check (tr[x].r)) query (tr[x].r);
}
int main()
{
	n=read ();
	while (1)
	{
		int opt=read ();
		if (opt==1)
		{
			for (int i=0;i<K;i++) p[i]=read ()^ans;
			A=read ()^ans;
			insert (root,0);
		}
		if (opt==2)
		{
			for (int i=0;i<=1;i++)
				for (int j=0;j<K;j++) q[j][i]=read ()^ans;
			ans=0;query (root);
			printf ("%d\n",ans);
		}
		if (opt==3) break;
	}
	return 0;
}
```

---

## 作者：Tyher (赞：13)

#### 题目名字为啥要叫~~简单题~~

$K-Dtree$题解。

首先，操作数量不会超过$20w$次

那么意味着，$n*n$的矩阵有绝大部分的空间是被浪费掉的

考虑怎么把这个矩阵从我们的脑海里拿掉

首先对于修改操作，可以转化为新加入一个数

这样是不会影响答案的，可以认为在这个$(x,y)$的地方有两个点。

那么对于每一个修改操作，可以$Insert$做

对于每一个查询，只有在那一个矩阵里面的点才会产生贡献

$KDtree$维护每颗子树的权值和，覆盖的最大矩阵

对于整个子树都不在询问里面的情况，一定不会产生贡献

对于整个子树全在询问里面的情况，一定会产生贡献$te[x].tot$

就这样依次统计答案

如果$Insert$到树不平衡时重构即可

相信大佬们都会，就酱


---

## 作者：EnofTaiPeople (赞：12)

[此题](/problem/P4148)是出了名的神奇，一个强制在线卡掉了 CDQ 分治，一个内存 20MB 卡掉了树套树，只能使用 K-D Tree 或者时间不够优秀的分块来解决此题。

此题是关于 K-D Tree 的动态插入，还是要通过上下界来剪枝。

K-D Tree 如何进行动态插入？首先，我们要给每一个点指定一个 $Type$，$Type=1$ 表示以 $x$ 为标准建树，否则表示以 $y$ 为标准建树。对于每个节点维护一个 $size$，当某一个儿子的 $size$ 超过了父亲的 $size* a$，则父亲需要重构，每次插入如果有节点需要重构，选取深度最小的节点。$a$ 为重构指数，一般取 $0.75$。

通过上下界剪枝，不难得到如下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
char buf[1<<23],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2))?EOF:*p1++
inline int read(){
	int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
	do an=an*10+c-'0';while(isdigit(c=gc));return an*f;
}
int mx[N],my[N],md[N],lx[N],ly[N],rx[N],ry[N],stk[N],t,Root;
int lc[N],rc[N],d[N],siz[N],Need_Rebuild,NodeTp,ans_data;
struct Node{int x,y,d;}a[N];
bool Tp[N],nowTp;
inline bool cmpx(const Node &x,const Node &y){return x.x<y.x;}
inline bool cmpy(const Node &x,const Node &y){return x.y<y.y;}
inline int New(int id){
	int x=stk[t--];lx[x]=rx[x]=mx[x]=a[id].x;md[x]=d[x]=a[id].d;
	ly[x]=ry[x]=my[x]=a[id].y;siz[x]=1;return x;
}
bool Ins(int &x){
	if(x==0){Tp[x=New(0)]=nowTp^=1;return 1;}d[x]+=a[0].d;
	if(mx[x]==a[0].x&&my[x]==a[0].y){md[x]+=a[0].d;return 0;}
	lx[x]=min(lx[x],a[0].x);ly[x]=min(ly[x],a[0].y);
	rx[x]=max(rx[x],a[0].x);ry[x]=max(ry[x],a[0].y);bool res;
	if((Tp[x]&&a[0].x<mx[x])||((!Tp[x])&&a[0].y<my[x])){
		if((res=Ins(lc[x]))&&siz[lc[x]]>siz[rc[x]]*3+3)Need_Rebuild=x;
	}else{
		if((res=Ins(rc[x]))&&siz[rc[x]]>siz[lc[x]]*3+3)Need_Rebuild=x;
	}siz[x]+=res;return res;
}
inline void Maintain(int x){
	if(lc[x])lx[x]=min(lx[x],lx[lc[x]]),ly[x]=min(ly[x],ly[lc[x]]),d[x]+=d[lc[x]],
	rx[x]=max(rx[x],rx[lc[x]]),ry[x]=max(ry[x],ry[lc[x]]),siz[x]+=siz[lc[x]];
	if(rc[x])lx[x]=min(lx[x],lx[rc[x]]),ly[x]=min(ly[x],ly[rc[x]]),d[x]+=d[rc[x]],
	rx[x]=max(rx[x],rx[rc[x]]),ry[x]=max(ry[x],ry[rc[x]]),siz[x]+=siz[rc[x]];
}
void GetNode(const int &x){
	if(lc[x])GetNode(lc[x]);
	a[++NodeTp]={mx[x],my[x],md[x]};
	if(rc[x])GetNode(rc[x]);
	stk[++t]=x;return;
}
void asks(int x){
	if(lx[x]>=lx[0]&&rx[x]<=rx[0]&&ly[x]>=ly[0]&&ry[x]<=ry[0]){ans_data+=d[x];return;}
	if(lx[0]>rx[x]||rx[0]<lx[x]||ly[0]>ry[x]||ry[0]<ly[x])return;
	if(mx[x]>=lx[0]&&mx[x]<=rx[0]&&my[x]>=ly[0]&&my[x]<=ry[0])ans_data+=md[x];
	if(lc[x])asks(lc[x]);if(rc[x])asks(rc[x]);return;
}
double px,py,fx,fy;
#define P(x) ((x)*(x))
int build(int l,int r){
	if(r<l)return 0;int mid=l+((r-l)>>1),x;px=py=fx=fy=0;
	for(x=l;x<=r;++x)px+=a[x].x,py+=a[x].y;px/=r-l+1,py/=r-l+1;
	for(x=l;x<=r;++x)fx+=P(px-a[x].x),fy+=P(py-a[x].y);
	if(fx>fy)nth_element(a+l,a+mid,a+r+1,cmpx);
	else nth_element(a+l,a+mid,a+r+1,cmpy);
	Tp[x=New(mid)]=fx>fy;lc[x]=build(l,mid-1);
	rc[x]=build(mid+1,r);Maintain(x);return x;
}
#undef P
int main(){
	int opt=read();
	for(opt=N-1;opt;--opt)stk[++t]=opt;
	for(opt=read();opt!=3;opt=read())
		if(opt==1){
			a[0]={read()^ans_data,read()^ans_data,read()^ans_data};
			Need_Rebuild=0;Ins(Root);if(Need_Rebuild){
				NodeTp=0;GetNode(Need_Rebuild);build(1,NodeTp);
			}
		}else{
			lx[0]=read()^ans_data,ly[0]=read()^ans_data;
			rx[0]=read()^ans_data,ry[0]=read()^ans_data;
			ans_data=0;asks(Root);printf("%d\n",ans_data);
		}
	return 0;
}
```

这题数据水就不要说了，注意替罪羊式重构的查询复杂度是超过了 $O(\sqrt n)$ 的，于是可以使用 $\text{Big-small K-D Tree}$，即有一大一小两棵 $\text{K-D Tree}$，每次在小树插入，替罪羊式重构，当小树的大小达到 $\sqrt n\log_2n$ 时，将两棵树暴力合并，这样依旧保证了插入复杂度不超过 $O(n\sqrt n)$，但实际速度没有之前那样快。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
namespace fast_io{
    char bf[N+2],*p1,*p2,c,ob[N+58];
#define gc (p1==p2&&(p2=(p1=bf)+fread(bf,1,N,stdin),p1==p2))?EOF:*p1++
template<typename _Tp>
    inline void read(_Tp &x){
        for(c=gc;c<48;c=gc);
        for(x=0;c>47;x=x*10+(48^c),c=gc);
    }
template<typename _Tp,typename..._tps>
    inline void read(_Tp&x,_tps&...y){
        read(x),read(y...);
    }
    int st[58],t,ot;
template<typename _Tp>
    inline void write(_Tp x){
        if(x<0)ob[ot++]='-',x=-x;
        while(x>9)st[++t]=48^(x%10),x/=10;
        for(ob[ot++]=48^x;t;ob[ot++]=st[t--]);
        ob[ot++]='\n';
        if(ot>N)fwrite(ob,1,ot,stdout),ot=0;
    }
    inline void fls(){fwrite(ob,1,ot,stdout),ot=0;}
}using fast_io::read;
using fast_io::write;
int L[N][10],t[N][2],rt,_rt,p[N],pt,cnt,ans;
//my(x,y),mn(x,y),mx(x,y),sz,my,sm
#define X(x) L[x][0]
#define Y(x) L[x][1]
#define mnx(x) L[x][2]
#define mny(x) L[x][3]
#define mxx(x) L[x][4]
#define mxy(x) L[x][5]
#define sz(x) L[x][6]
#define my(x) L[x][7]
#define sm(x) L[x][8]
#define TP(x) L[x][9]
#define ls t[x][0]
#define rs t[x][1]
void flget(int &x){
    if(ls)flget(ls);
    if(rs)flget(rs);
    mxx(x)=mnx(x)=X(x);
    mxy(x)=mny(x)=Y(x);
    sz(x)=1,sm(x)=my(x);
    p[++pt]=x,x=0;
}
double _p[4];
mt19937 rg(167772161);
void reb(int &x,int l,int r){
    int i,md=l+r>>1,tps;
    _p[0]=_p[1]=_p[2]=_p[3]=0;
    for(i=l;i<=r;++i)_p[0]+=L[p[i]][0],_p[1]+=L[p[i]][1];
    _p[0]/=r-l+1,_p[1]/=r-l+1;
    #define pp(k) (_p[k]-L[p[i]][k])
    for(i=l;i<=r;++i)_p[2]+=pp(0)*pp(0),_p[3]+=pp(1)*pp(1);
    tps=_p[3]>_p[2];
    nth_element(p+l,p+md,p+r+1,[&](int x,int y){
        return L[x][tps]<L[y][tps];
    }),x=p[md],TP(x)=tps;
    if(l<md){
        reb(ls,l,md-1);
        mxx(x)=max(mxx(x),mxx(ls));
        mnx(x)=min(mnx(x),mnx(ls));
        mxy(x)=max(mxy(x),mxy(ls));
        mny(x)=min(mny(x),mny(ls));
        sz(x)+=sz(ls),sm(x)+=sm(ls);
    }if(md<r){
        reb(rs,md+1,r);
        mxx(x)=max(mxx(x),mxx(rs));
        mnx(x)=min(mnx(x),mnx(rs));
        mxy(x)=max(mxy(x),mxy(rs));
        mny(x)=min(mny(x),mny(rs));
        sz(x)+=sz(rs),sm(x)+=sm(rs);
    }
}
void ins(int &x,int tps=0,int de=0){
    if(!x){x=cnt,TP(x)=rg()&1;return;}
    int k=L[cnt][TP(x)]>L[x][TP(x)];
    ins(t[x][k],TP(x)^1,de+1);
    if(sz(t[x][k])>sz(t[x][!k])*3+3){
        pt=0,flget(x),reb(x,1,pt);
    }else {
        ++sz(x),sm(x)+=my(cnt);
        mxx(x)=max(mxx(x),X(cnt));
        mnx(x)=min(mnx(x),X(cnt));
        mxy(x)=max(mxy(x),Y(cnt));
        mny(x)=min(mny(x),Y(cnt));
    }
}int _cnt;
void qry(int x){++_cnt;
    if(mxx(x)<mnx(0)||mnx(x)>mxx(0)||mxy(x)<mny(0)||mny(x)>mxy(0))return;
    if(mxx(x)<=mxx(0)&&mnx(x)>=mnx(0)&&mxy(x)<=mxy(0)&&mny(x)>=mny(0))ans+=sm(x);
    else{
        if(X(x)>=mnx(0)&&X(x)<=mxx(0)&&Y(x)>=mny(0)&&Y(x)<=mxy(0))ans+=my(x);
        if(ls)qry(ls);if(rs)qry(rs);
    }
}
int main(){
    int op;read(op),read(op);
    while(op!=3){
        if(op==1){
            ++cnt,read(X(cnt),Y(cnt),sm(cnt));
            X(cnt)^=ans,Y(cnt)^=ans,sm(cnt)^=ans;
            mxx(cnt)=mnx(cnt)=X(cnt);
            mxy(cnt)=mny(cnt)=Y(cnt);
            sz(cnt)=1,my(cnt)=sm(cnt),ins(_rt);
            if(sz(_rt)>70000){
                pt=0;if(rt)flget(rt);
                flget(_rt),reb(rt,1,pt);
            }
        }else{_cnt=0;
            read(mnx(0),mny(0),mxx(0),mxy(0));
            mnx(0)^=ans,mny(0)^=ans,mxx(0)^=ans,mxy(0)^=ans;
            ans=0;if(rt)qry(rt);
            // cerr<<"cnt1:"<<_cnt<<endl;_cnt=0;
            if(_rt)qry(_rt);
            write(ans);
            // cerr<<"cnt2:"<<_cnt<<endl;
        }read(op);
    }fast_io::fls();
    return 0;
}
```

---

## 作者：H_Kaguya (赞：9)

这道题，怎么，没有 polylog 的题解。。。  
追求一下渐进复杂度。  
这里给出一种较为简单的 polylog 算法，仅供参考。  

---

首先，我们发现这是一个三维偏序，强制在线，卡空间。  
三维问题并不好处理，考虑先降掉一维。  
直接对时间进行 CDQ 分治即可。  

然而强制在线。  
不过考虑一下 CDQ 的过程，我们把递归树建出来。  
容易发现，每次可以先递归左边，然后递归右边，最后计算左右贡献。  
而我们的修改/查询是从左到右读入的。  
所以动态维护递归的过程即可。  

然而这样只能合并信息。  
查询的话，考虑任意时刻最多只有 $O(\log n)$ 个节点。遍历每个节点求解即可。  

上面的思路可能比较抽象。等效的理解方式是二进制分组。  
新加入一个点暴力进位即可。  
复杂度分析同 CDQ 分治。只考虑合并的话可以做到 $O(n \log n)$ 或 $O(n \log ^ 2 n)$。    

现在考虑，对于每个节点，我们有静态的若干个二维点，需要支持矩形求和。  

考虑常规 $O(n \sqrt n)$ 算法，对所有点按 $x$ 坐标排序，然后分块，用分散层叠优化二分。  
单次查询复杂度 $O(\sqrt n + \log n)$。可以说很差。  

如果两边差距很大，那就平衡复杂度吧。  
直接把块长开到 $O(\frac{n}{\log n})$，这样整块查询就变成了 $O(\log n)$。  

考虑散块。块长过大，显然不能再暴力扫了。  
所以使用上述结构递归处理即可。  

分析一下复杂度。  
为了方便考虑，我们假设查询都是前缀查询。  

则单次查询复杂度 $T(n) = T(\frac{n}{\log n}) + O(\log n)$，解得 $T(n) = O(\log n)$。  
由于递归树上面有 $O(\log n)$ 个节点所以总的复杂度为 $O(\log ^ 2 n)$。  

更重要的是空间复杂度。  
$T(n) = \log n \times T(\frac{n}{\log n}) + O(n)$。  
本人过菜不会解。  

下附神仙 [UnyieldingTrilobite](https://www.luogu.com.cn/user/250637) 给出的证明。  

> 由于每一层都是线性所以本质上只需要分析把 $n$ 每次除以 $\log n$ 几次能变成 1。很显然这个东西的级别不会超过 $\log_{\log n}n = \frac{\log n}{\log \log n}$，然后我们不难发现在 $n$ 变到根号规模之前每次除的东西的规模是不会变的，所以这个东西的级别不会低于 $\log_{\log n} \sqrt n$，然后就是一样的。  

事实上，在这道题的数据范围下 $\frac{\log n}{\log \log n}$ 是不大于 4 的。可以认为是个大常数吧。。。  
整体复杂度优于树套树。  

可能还能通过一些其他技巧做到更加优秀的复杂度。  
能力有限仅分析至此。  

---

上面的做法复杂度确实优秀，然而。。。。  

一方面，分散层叠的空间常数本身就不小，这道题开的 20M 属实不够用。  
另一方面，由于内存访问的原因，实际测得上述算法的效率**极低**，一点也不像是 $O(n \log ^ 2 n)$ 该有的样子。  
对于静态区间 $< k$ 的数的个数，用上述算法（去掉 CDQ）时间复杂度为 $O(n \log n)$，然而在 $10^6$ 的数据范围下需要 8s 的时间，空间约为 100M。  

所以上述算法分析一下复杂度，理论很优也就行了吧。  
我们考虑如何通过这道题。  

既然是分散层叠常数大，那就把分散层叠扔了即可。  
直接每个块暴力二分，时间复杂度 $O(n \log ^ 3 n)$，空间复杂度 $O(\frac{n \log n}{\log \log n})$。  

实际上由于常数极小跑的飞快。  
朴素实现最大的测试点也没有超过 650ms。  
同时使用的空间约为 8M。  

下附代码。有点冗长。  

```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
const int BL = 64;
const int B[12] = {1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4};
struct site
{
	int x, y, val;
	site() = default;
	site(int a, int b, int c)
	{
		x = a; y = b; val = c;
	}
};
site poi[BL];
struct asd
{
	int y, sum;
	asd() = default;
	asd(int a)
	{
		y = a;
	}
};
struct node
{
	bool flag;
	int len;
	long long sum;
	site *num;
	asd *fc;
	void div(int, int, int);
	int geta(int, int, int, int);
	int gest(asd*, int, int, int, int, int, int);
};
node work[12];
site space[277777];
asd anospace[909033];
int top, last;
int read();
void load();
void adj();
int sol(int, int, int, int);
int main()
{
	int x, y, a, b, c;
	read(); load();
	while (1)
		if ((c = read()) == 1)
		{
			x = read() ^ last; y = read() ^ last;
			poi[top++] = site(x, y, read() ^ last);
			if (top == BL)
				adj();
		}else if (c == 2)
		{
			x = read() ^ last; a = read() ^ last;
			y = read() ^ last; b = read() ^ last;
			last = sol(x, y, a, b);
			printf ("%d\n", last);
		}else
			break;
	return 0;
}

int read()
{
	int x = 0;
	char c = getchar();
	while (c < '0') c = getchar();
	do {
		x = x * 10 + (c & 15);
		c = getchar();
	}while (c >= '0');
	return x;
}

bool cmp0(const asd &a, const asd &b)
{
	return a.y < b.y;
}

bool cmp1(const site &a, const site &b)
{
	return a.x < b.x;
}

void load()
{
	int p1 = 0, p2 = 0;
	for (int i = 0, j = 64; i < 12; ++i, j <<= 1)
	{
		work[i].flag = false;
		work[i].len = j;
		work[i].num = space + p1;
		work[i].fc = anospace + p2;
		p1 += j + 1; p2 += B[i] * j + 1;
	}
}

void adj()
{
	for (int i = 0; ; ++i)
		if (!work[i].flag)
		{
			work[i].flag = true;
			work[i].sum = 0LL;
			int x = 0;
			for (int j = 0; j < i; ++j)
			{
				work[j].flag = false;
				for (int k = 0; k < work[j].len; ++k)
					work[i].num[x + k] = work[j].num[k];
				x += work[j].len;
			}
			for (int j = 0; j < top; ++j)
				work[i].num[x + j] = poi[j];
			sort(work[i].num, work[i].num + work[i].len, cmp1);
			for (int j = 0; j < work[i].len; ++j)
				work[i].sum += work[i].num[j].val;
			work[i].div(0, work[i].len - 1, 0);
			break;
		}
	top = 0;
}

int sol(int a, int b, int c, int d)
{
	int ret = 0;
	for (int i = 0; i < top; ++i)
		if (poi[i].x >= a && poi[i].x <= b && poi[i].y >= c && poi[i].y <= d)
			ret += poi[i].val;
	for (int i = 0; i < 12; ++i)
		if (work[i].flag)
			ret += work[i].geta(a, b, c, d);
	return ret;
}

void node::div(int a, int b, int c)
{
	if (b - a + 1 <= 60)
		return;
	int big = (b - a + 1) / __lg(b - a + 1);
	asd *f = fc + c * len;
	for (int i = a, j; i <= b; i = j + 1)
	{
		j = min(b, i + big - 1);
		for (int k = i; k <= j; ++k)
		{
			f[k].y = num[k].y;
			f[k].sum = num[k].val;
		}
		sort(f + i, f + j + 1, cmp0);
		for (int k = i + 1; k <= j; ++k)
			f[k].sum += f[k - 1].sum;
		div(i, j, c + 1);
	}
}

int node::geta(int a, int b, int c, int d)
{
	int x, y;
	x = lower_bound(num, num + len, site(a, a, 0), cmp1) - num;
	y = upper_bound(num, num + len, site(b, b, 0), cmp1) - num - 1;
	if (x > y)
		return 0;
	return gest(fc, 0, len - 1, x, y, c, d);
}

int node::gest(asd *s, int lf, int rt, int a, int b, int c, int d)
{
	int ret = 0;
	if (b - a + 1 <= 60)
	{
		for (int i = a; i <= b; ++i)
			if (num[i].y >= c && num[i].y <= d)
				ret += num[i].val;
		return ret;
	}
	int big = (rt - lf + 1) / __lg(rt - lf + 1);
	int oa = (a - lf) / big, ob = (b - lf) / big;
	if (oa == ob)
		return gest(s + len, oa * big + lf, min((oa + 1) * big + lf - 1, rt), a, b, c, d);
	if (a != oa * big + lf)
	{
		ret += gest(s + len, oa * big + lf, (oa + 1) * big + lf - 1, a, (oa + 1) * big + lf - 1, c, d);
		++oa;
	}
	if (b != min((ob + 1) * big + lf - 1, rt))
	{
		ret += gest(s + len, ob * big + lf, min((ob + 1) * big + lf - 1, rt), ob * big + lf, b, c, d);
		--ob;
	}
	for (int i = oa, j = oa * big + lf; i <= ob; ++i, j += big)
	{
		int x, y;
		x = lower_bound(s + j, s + min(j + big, rt + 1), asd(c), cmp0) - s - 1;
		y = upper_bound(s + j, s + min(j + big, rt + 1), asd(d), cmp0) - s - 1;
		if (y < j || x > y)
			continue;
		ret += s[y].sum;
		if (x >= j)
			ret -= s[x].sum;
	}
	return ret;
}
```

---

## 作者：lg_zhou (赞：8)

K-D tree 是可以高效处理 $k$ 维空间信息的数据结构，oi 中，一般 $k=2$。

若已知 $k$ 维空间中的 $n$ 个点坐标，将其构建成一棵 K-D tree，过程如下：

1. 若当前只有一个点，返回这个点。

2. 选择一个维度，将当前点集按照这个维度分成两个点集。

3. 选切割点，在选择的维度上选择一个点，这一维度上的值小于这个点的归入左子树，其余归入右子树。

4. 将选择的点作为这棵子树的根节点，递归左右子树并维护信息。

大概长成这样：（图来自 oi-wiki）

![](https://cdn.luogu.com.cn/upload/image_hosting/9oc6zusm.png)


![](https://cdn.luogu.com.cn/upload/image_hosting/6cq7ikki.png)


为保证复杂度，切割维度可以选择方差最大的维度，也可以随机选一个维度。第三步选切割点的时候选择该维度的中位数，可以保证层数。

第三步有个好用的函数 `nth_element(s+1,s+mid,s+r+1,cmp);` 可以找到 `s[l]` 到 `s[r]` 之间值按 `cmp` 排序后再 `s[mid]` 处的值，并 `s[mid]` 左边均小于 `s[mid]`，右边均大于。

如果维护的 k 维点集为可变的，插入删除点后为保持平衡，需要重构，可以引入一个重构常数
$\alpha$，如果 $\alpha \cdot size(x) \le \max(size(lc[x]),size(rc[x]))$，那么重构这棵子树。重构的时候先用中序遍历取出子树所有节点，然后按照上述四个步骤构建即可。

***

### P4148 简单题

直接看代码：

```cpp
#include<bits/stdc++.h>

#define fi first
#define se second
// #define endl '\n'
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef long double db;
typedef pair<db, db> pdd;

const int inf = 2e9;
const db eps = 1e-6;
const int N = 200005;


int rt,tot;
db e = 0.75;
struct kdt{
    int l,r,u,d; // 上下左右的边界
    int sum,ls,rs,sz;  // 和，左右儿子,size
    int x,y,v; // 当前点横纵坐标
    int pd; // 哪一维
    #define l(x) t[x].l
    #define r(x) t[x].r
    #define u(x) t[x].u
    #define d(x) t[x].d
    #define ls(x) t[x].ls
    #define rs(x) t[x].rs
    #define sz(x) t[x].sz
    #define sum(x) t[x].sum
}t[N];

void push_up(int x){
    sum(x) = sum(ls(x))+sum(rs(x))+t[x].v; // 和为左右子树的和和自己
    sz(x) = sz(ls(x))+sz(rs(x))+1;
    l(x) = r(x) = t[x].x; // 初值为当前点
    d(x) = u(x) = t[x].y;
    if (ls(x)){ // 如果有左子树，更新
        l(x) = min(l(x), l(ls(x))); r(x) = max(r(x), r(ls(x)));
        d(x) = min(d(x), d(ls(x))); u(x) = max(u(x), u(ls(x)));
    }
    if (rs(x)){
        l(x) = min(l(x), l(rs(x))); r(x) = max(r(x), r(rs(x)));
        d(x) = min(d(x), d(rs(x))); u(x) = max(u(x), u(rs(x)));
    }
}

bool bad(int x){
    if ((db)max(sz(ls(x)),sz(rs(x))) > (db)sz(x)*e) return 1; // 当前子树需要重构
    return 0;
}

int g[N], num;
void print(int x){ // 中序遍历取出子树所有节点
    if (!x) return;
    print(ls(x));
    g[++num] = x;
    print(rs(x));
}

bool cmpx(int a, int b){return t[a].x < t[b].x;}
bool cmpy(int a, int b){return t[a].y < t[b].y;}

void build(int &x, int l, int r){
    if (l > r){ // 当前节点序列没数了，返回空
        x = 0;
        return;
    }
    db v1 = 0, v2 = 0, av1 = 0, av2 = 0;
    for (int i = l; i <= r; i++){
        av1 += t[g[i]].x;
        av2 += t[g[i]].y;
    }
    av1 /= (r-l+1); av2 /= (r-l+1);
    for (int i = l; i <= r; i++){
        v1 += (av1-t[g[i]].x)*(av1-t[g[i]].x);
        v2 += (av2-t[g[i]].y)*(av2-t[g[i]].y);
    } // 计算方差
    
    int mid = l+r>>1;
    if (v1 > v2){
        nth_element(g+l,g+mid,g+r+1,cmpx); // 取出维度 x 的中位数当做新子树的根
        t[g[mid]].pd = 1; // 此节点切割维度为 x 
    }else{
        nth_element(g+l,g+mid,g+r+1,cmpy);
        t[g[mid]].pd = 2;
    }
    x = g[mid];
    build(ls(x), l, mid-1);
    build(rs(x), mid+1,r);
    push_up(x);
}
void rebuild(int &x){ // 重构子树
    num = 0;
    print(x);
    build(x,1,num);
}
void insert(int &x, int v){
    if (!x){
        x = v;
        push_up(x);
        return;
    }
    if (t[x].pd == 1){ // 按 x 一维插入
        if (t[v].x <= t[x].x) insert(ls(x),v);
        else insert(rs(x),v);
    }
    else{
        if (t[v].y <= t[x].y) insert(ls(x),v);
        else insert(rs(x), v);
    }
    push_up(x);
    if (bad(x)) rebuild(x);
}


int query(int x, int l, int r, int d, int u){
    if (!x || r < l(x) || l > r(x) || u < d(x) || d > u(x)) return 0; // 不在当前矩形里面，返回
    if (l <= l(x) && r >= r(x) && d <= d(x) && u >= u(x)) return sum(x);//包含当前矩形，返回
    int res = 0;
    if (t[x].x >= l && t[x].x <= r && t[x].y >= d && t[x].y <= u) res = t[x].v; // 当前点在询问范围内
    return res+query(ls(x), l,r,d,u)+query(rs(x),l,r,d,u);
}
int n,lst;
signed main(){

    // freopen("a.in","r",stdin);
    ios::sync_with_stdio(false); cin.tie(0u); cout.tie(0u);
    cin >> n;
    while(1){
        int op;
        cin >> op;
        if (op == 3) break;
        if (op == 1){
            tot++;
            cin >> t[tot].x >> t[tot].y >> t[tot].v;
            t[tot].x ^= lst;
            t[tot].y ^= lst;
            t[tot].v ^= lst;
            insert(rt,tot);
        }else{
            int l,d,r,u;
            cin >> l >> d >> r >> u;
            l ^= lst; d ^= lst;
            r ^= lst; u ^= lst;
            cout << (lst=query(rt,l,r,d,u)) << endl;
        }
    }
    return 0;
}
```




---

## 作者：Dementor (赞：5)

# K-D Tree

K-D Tree 是一种具备 BST 形态的维护 $k$ 维空间上点的信息的一种数据结构

其名称 “K-D” 也是取 $k$ 维空间这个意义

在节点数 $n >> 2^k$ 时， K-D Tree 的运行效率优秀

单次操作，最坏时间复杂度是 $O(n^{1-\frac{1}{k}})$ 的

思维清晰、代码清新的 K-D Tree 在这样的自身情况下不失为一个良好的解决问题的工具，有的题目甚至需要依赖 K-D Tree 才能解决，而有的题目则可以利用其取得一定部分分

## 建树

K-D Tree 维护的节点的位置、权值信息在绝大多数情况下都由题目给出，所以在下面的实现中，我们节点的编号和读入顺序一致，需要额外将读入的数据存储下来

下面所说 “编号” 统一先行指明是读入顺序编号

K-D Tree 的空间复杂度是 $O(n)$ 的

`int build (int l, int r)`

我们在这个函数里，需要实现：

+ 构建一颗由编号 $l..r$ 节点 K-D Tree

+ 构建好节点之间的父子关系

声明：

+ “当前节点”指 `build` 函数的返回值

+ $l..r$ 的所有节点在构建完成后构成“当前节点”为根的子树

**核心思想：根据某一维度进行划分**

我们考虑 $d$ 表示当前节点 **按照 $d$ 这一维度进行划分** ，具体地， $d$ 这一维度上，小于等于当前节点的节点作为其左子树，大于当前节点的节点作为其右子树，再分别递归左右两边进行构建

### 方差优化

可以看出，以上构建方法保证了 K-D Tree 具有 BST 的性质，但是并没有保证时间复杂度

我们接下来提出两个优化方案，以保证 K-D Tree 具有正确的复杂度

首先是 **方差优化**

我们计算当前 $l..r$ 的节点分别在 $k$ 个维度上坐标的方差，取方差最大的一维作为当前节点的 $d$

### 中位数优化

取得 $d$ 后，我们不任意取当前节点，而是将 $d$ 维上坐标的中位数节点作为当前节点

由以上两个优化，我们就可以保证 K-D Tree 的高度最高是 $O(n^{1-\frac{1}{k}})$ 的，由此做到单次操作复杂度正确

建树部分到此实现

## 插入

`void ins (int & x, int v)`

插入编号为 $v$ 的节点，当前在 K-D Tree 的 $x$ 号节点

我们查看 $d[x]$ ，按照 $d[x]$ 这一维比较，如果小于等于 $t[x][d[x]]$ 就递归左子树，否则递归右子树

$t$ 数组是坐标数组

## 删除

需要删除一个节点时，我们仿照 `ins` 先找到该节点，然后打上一个 $deltag$ ，等到我们发现一颗子树里 $deltag$ 的数目占比超过一个阈值时，我们对整颗子树直接重构，以此实现删除操作

类似线段树的 $lazytag$ 操作

## 重构

首先，我们定义一个阈值 $REVAL$ 表示：

+ 如果某种比例超过了 $REVAL$ ，那么进行重构操作

一般来说， $REVAL$ 并不需要太小，定在 $0.7 \sim 0.8$ 就可以了

### 一般重构

我们如果发现一个节点的某个子树在整颗子树种占比超过了 $REVAL$ ，那么重构

`void rebuild (int & x)`

首先，将子树压成序列，只需遍历整颗子树，存储节点编号进入一个 $g$ 数组即可

然后，假设最终发现子树里有 $tot$ 个节点，直接 `build (1, tot)` 即可，注意此时 `build` 函数内部在需要调用编号的时候都是用 `g[i]` 代替 `i`

### 删除重构

与一般重构类似地，只不过我们特殊判断一下有 $deltag$ 的节点不加入 $g$ 即可

## 领域查询

这里进行的定义只是自己为了方便叙述所做出的 `#define`

一个节点的 **领域** 即整个以其为根的子树所被包含的超长方体

所以，我们对每个节点维护 $trge[d][0/1]$ 表示 $d$ 维上最小最大值是多少，以此维护出子树的超长方体

这个在 `pushup` 中容易维护

由此，我们也能看出， K-D Tree 具有维护区间修改的能力，具有类似线段树的性质

查询领域时，我们看一下询问领域与当前节点领域是否相离、内含，根据不同情况作出不同应对即可

这部分十分类似线段树

至此，我们了解了 K-D Tree 的基本操作，并且我们发现了 K-D Tree 和 BST 以及 SegmentTree 的相似之处

## 习题

首先是可以视为模板题的 [P4148](https://www.luogu.com.cn/problem/P4148)

单点加、领域查， 2-D Tree 模板

也可以用其他的数据结构做，不对 K-D Tree 作尤其限制

上文的解释已经足以解决本题，于是放上代码便利对上文的理解

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <math.h>
using namespace std;
const int N = 200010;
int n, op, x[N], y[N], xf, yf, xs, ys, v[N], cur;
int siz[N], sum[N], d[N], lc[N], rc[N], L[N], R[N], U[N], D[N];
int g[N], tot, lst, RT;
double REVAL = 0.725;
int min (int x, int y) {return (x > y) ? y : x;}
int max (int x, int y) {return (x > y) ? x : y;}
bool cmp1 (int p, int q) {return x[p] < x[q];}
bool cmp2 (int p, int q) {return y[p] < y[q];}
void pushup (int o) {
	siz[o] = siz[lc[o]] + siz[rc[o]] + 1;
	sum[o] = sum[lc[o]] + sum[rc[o]] + v[o];
	L[o] = R[o] = x[o];
	U[o] = D[o] = y[o];
	if (lc[o]) {
		L[o] = min (L[o], L[lc[o]]), R[o] = max (R[o], R[lc[o]]);
		D[o] = min (D[o], D[lc[o]]), U[o] = max (U[o], U[lc[o]]);
	}
	if (rc[o]) {
		L[o] = min (L[o], L[rc[o]]), R[o] = max (R[o], R[rc[o]]);
		D[o] = min (D[o], D[rc[o]]), U[o] = max (U[o], U[rc[o]]);
	}
}
int build (int l, int r) {
	if (l > r) return 0;
	int mid = (l + r) >> 1;
	double a1 = 0, a2 = 0, v1 = 0, v2 = 0;
	for (int i=l;i<=r;i++) a1 += x[g[i]], a2 += y[g[i]];
	a1 /= 1.0 * (r - l + 1); a2 /= 1.0 * (r - l + 1);
	for (int i=l;i<=r;i++) v1 += pow (x[g[i]] - a1, 2), v2 += pow (y[g[i]] - a2, 2);
	if (v1 > v2) nth_element (g + l, g + mid, g + r + 1, cmp1), d[g[mid]] = 1;
	else nth_element (g + l, g + mid, g + r + 1, cmp2), d[g[mid]] = 2;
	lc[g[mid]] = build (l, mid - 1); rc[g[mid]] = build (mid + 1, r);
	pushup (g[mid]); return g[mid];
}
void plain (int o) {
	if (! o) return ;
	plain (lc[o]);
	g[++ tot] = o;
	plain (rc[o]);
}
void rebuild (int & o) {
	tot = 0; plain (o);
	o = build (1, tot);
}
bool bad (int o) {
	return REVAL * siz[o] <= (double) max (siz[lc[o]], siz[rc[o]]);
}
void ins (int & o, int v) {
	if (! o) {
		o = v;
		pushup (o);
		return ;
	}
	if (d[o] == 1) {
		if (x[v] <= x[o]) ins (lc[o], v);
		else ins (rc[o], v);
	} else {
		if (y[v] <= y[o]) ins (lc[o], v);
		else ins (rc[o], v);
	}
	pushup (o);
	if (bad (o)) rebuild (o);
}
bool out (int o) {
	if (L[o] > xs) return 1;
	if (R[o] < xf) return 1;
	if (D[o] > ys) return 1;
	if (U[o] < yf) return 1;
	return 0;
}
bool in (int o) {
	if (L[o] >= xf && R[o] <= xs && D[o] >= yf && U[o] <= ys) return 1;
	return 0;
}
int que (int o) {
	if (! o || out (o)) return 0;
	if (in (o)) return sum[o];
	int ret = 0;
	if (x[o] >= xf && x[o] <= xs && y[o] >= yf && y[o] <= ys) ret += v[o];
	return que (lc[o]) + que (rc[o]) + ret;
}
template <typename T> void read (T & x) {
	x = 0; char c = getchar ();
	while (c < 48 || c > 57) c = getchar ();
	while (c >= 48 && c <= 57) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar ();
}
void write (int x) {
	if (x > 9) write (x / 10);
	putchar (x % 10 + 48);
}
int main () {
	read (n);
	while (233) {
		read (op); if (op == 3) break ;
		if (op == 1) {
			cur ++;
			read (x[cur]); read (y[cur]); read (v[cur]);
			x[cur] ^= lst; y[cur] ^= lst; v[cur] ^= lst;
			ins (RT, cur);
		} else {
			read (xf); read (yf); read (xs); read (ys);
			xf ^= lst; yf ^= lst; xs ^= lst; ys ^= lst;
			if (xf > xs) swap (xf, xs);
			if (yf > ys) swap (yf, ys);
			lst = que (RT);
			write (lst); putchar ('\n');
		}
	}
}
```

本题不需要特殊卡常，认真书写即可

## 注意事项

包括 oi-wiki 在内许多地方都有提到 K-D Tree 查询最近最远点

但实际上 K-D Tree 的结构确实没有适应这类问题

而且这类问题已经有另外的做法体系

所以这里直接略去这一部分的学习与笔记，并且做出提示： K-D Tree 解决部分这类问题可能可以，但是大多数情况下不会作为正解出现

---

## 作者：Tenshi (赞：4)

宣传一下我介绍 K-D Tree 的[博客](https://www.cnblogs.com/Tenshi/p/15846105.html)：


## 性质

树的一棵子树可以划分出一个矩形（二维）。只要我们将每个点的坐标维护起来，那么矩形的**左下端点**就是所有点 $x,y$ 坐标的最小值，**右上端点**就是所有点 $x,y$ 坐标的最大值。






## 分析

操作 $1$ 就是 $\texttt{insert}$，也就是**插入**操作，和普通的**二叉搜索树**类似，从根节点开始比较，决定向左子树还是右子树移动，最后走到需要插入的位置。

操作 $2$ 是对**矩形**进行询问，由上面所说的**性质**。

K-D Tree 的子树正好可以划分出一个矩形，因此我们可以采取类似于线段树**区间查询**的做法：

- 从根节点出发开始查询。
- 如果当前子树所对应的矩形和查询的矩形没有交集，返回 $0$。
- 如果被当前子树所对应的矩形被查询的矩形包含，直接返回当前子树的权值和 $sum$。
- 否则向左右子树递归继续询问。



#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)

inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=5e5+5;

struct Point{
	int x[2], w;
};

struct Node{
	int l, r;
	Point P;
	int L[2], R[2], sum, sz;
	
	#define ls tr[u].l
	#define rs tr[u].r
}tr[N];

int n;

int idx, root;
int buf[N], tot;
int add(){
	if(!tot) return ++idx;
	return buf[tot--];
}

void pushup(int u){
	auto &L=tr[ls], &R=tr[rs];
	tr[u].sum=tr[u].P.w+L.sum+R.sum, tr[u].sz=L.sz+R.sz+1;

	rep(i,0,1){
		tr[u].L[i]=min(tr[u].P.x[i], min(L.L[i], R.L[i]));
		tr[u].R[i]=max(tr[u].P.x[i], max(L.R[i], R.R[i]));
	}
}

const double Al=0.72;

Point pt[N];

void getSeq(int u, int cnt){
	if(ls) getSeq(ls, cnt);
	buf[++tot]=u, pt[tr[ls].sz+1+cnt]=tr[u].P;
	if(rs) getSeq(rs, cnt+tr[ls].sz+1);
}

int rebuild(int l, int r, int k){
	if(l>r) return 0;
	int mid=l+r>>1;
	int u=add();
	
	nth_element(pt+l, pt+mid, pt+r+1, [&](Point a, Point b){
		return a.x[k]<b.x[k];
	});
	tr[u].P=pt[mid];
	
	ls=rebuild(l, mid-1, k^1), rs=rebuild(mid+1, r, k^1);
	pushup(u);
	return u;
}

void maintain(int &u, int k){
	if(tr[u].sz*Al<tr[ls].sz || tr[u].sz*Al<tr[rs].sz)
		getSeq(u, 0), u=rebuild(1, tot, k);	
}

void insert(int &u, Point p, int k){
	if(!u){
		u=add();
		tr[u].l=tr[u].r=0;
		tr[u].P=p, pushup(u);
		return;
	}
	if(p.x[k]<=tr[u].P.x[k]) insert(ls, p, k^1);
	else insert(rs, p, k^1);
	pushup(u);
	maintain(u, k);
}

bool In(Node t, int x1, int y1, int x2, int y2){
	return t.L[0]>=x1 && t.R[0]<=x2 && t.L[1]>=y1 && t.R[1]<=y2;	
}

bool In(Point p, int x1, int y1, int x2, int y2){
	return p.x[0]>=x1 && p.x[0]<=x2 && p.x[1]>=y1 && p.x[1]<=y2;
}

bool Out(Node t, int x1, int y1, int x2, int y2){
	return t.R[0]<x1 || t.L[0]>x2 || t.R[1]<y1 || t.L[1]>y2;	
}

int query(int u, int x1, int y1, int x2, int y2){
	if(In(tr[u], x1, y1, x2, y2)) return tr[u].sum;
	if(Out(tr[u], x1, y1, x2, y2)) return 0;
	
	int res=0;
	if(In(tr[u].P, x1, y1, x2, y2)) res+=tr[u].P.w;
	res+=query(ls, x1, y1, x2, y2)+query(rs, x1, y1, x2, y2);
	return res;
}

int main(){
	cin>>n;
	// init
	tr[0].L[0]=tr[0].L[1]=N+5;
	tr[0].R[0]=tr[0].R[1]=-1;
	
	int res=0, op;
	while(cin>>op, op!=3){
		if(op==1){
			int x, y, k; read(x), read(y), read(k);
			insert(root, {x^res, y^res, k^res}, 0);
		}	
		else{
			int x1, y1, x2, y2; read(x1), read(y1), read(x2), read(y2);
			cout<<(res=query(root, x1^res, y1^res, x2^res, y2^res))<<endl;
		}
	}

	return 0;
}
```



---

## 作者：Mikefeng (赞：2)

## 题意

二维单点加，矩形查询，强制在线，空间 20MB。

## 做法

kd-tree 不多的还坚守的板子题，一个强制在线卡掉 cdq 分治，一个空间 20MB 卡掉树套树和朴素分块，分块套线段树要多 $\log$。

但是喜报：有 $O(m\sqrt n+n\sqrt m)$ 的做法过掉这题。

首先对操作按 $B_1$ 分块，根号重构，同一个块内的修改暴力查，块外的用分块处理。

把 $x$ 轴按 $B$ 分块，一个询问可以查分为 $l$ 到 $r$ 中 $y\le maxn$ 的值。

散块中还是暴力查，$O(B)$，整块中排序+前缀和+二分可以 $O(B\log n)$ 查询。

但是这还没完，可以发现每次都对连续的一段区间取 lower_bound，想到分散层叠，单次查询 $O(\log n+\frac{n}{B})$。

剩下的是重构部分，分散层叠本身的预处理就是合法的，问题在于每次都要对块内重新排序，一次处理是 $O(n\log n)$ 的，并且不均摊，考虑只排序新的部分，和原有的部分 merge 起来仍然有序，均摊 $O(n\log n)$。

那么现在的复杂度是：$O(m)$ 次查询，块内 $O(B_1)$，块外 $O(\log n+B)$，$O(\frac{m}{B_1})$ 次重构，每次复杂度 $O(n)$，sort 均摊 $O(n\log n)$。

时间复杂度 $O(m\times(B_1+B+\log n+\frac{n}{B})+\frac{m}{B_1}\times n+n\log n)$，$B,B_1$ 均取 $\sqrt n$ 得 $O(m\sqrt n)$。

但实际上 $B$ 取 $\sqrt n$，$B_1$ 取 $\sqrt m$ 得 $O(m\sqrt n+n\sqrt m)$ 更快，且由于重构时使用 stl 多，常数大，$B,B_1$ 要分别开大一些。

## 代码
```cpp
bool M1;
const int N=5e5+5;
const int M=2e5+5;
const int B=360;
int n,m,len,len1,ans;
int b[N];
int opt[M],x[M],y[M],s[M],t[M];
struct node{
	int x,y,val,sum;
	node(int _x=0,int _y=0,int _val=0):x(_x),y(_y),val(_val){}
	bool operator < (const node &_)const{return y<_.y;}
};
vector<node> v[B],a[B],tmp;
struct Node{
	int y,id,nxt;
	Node(int _y=0,int _id=0,int _nxt=0):y(_y),id(_id),nxt(_nxt){}
	bool operator < (const Node &_)const{return y<_.y;}
};
vector<Node> fs[B];
inline void Merge(vector<Node> a,vector<Node> b,vector<Node> &c){
	c.clear();
	int i=0,j=0,lena=a.size(),lenb=b.size();
	while(i<lena&&j<lenb){
		if(a[i].y<=b[j].y) c.emplace_back(a[i].y,i,j),++i;
		else c.emplace_back(b[j].y,i,j),j+=2;
	}
	j=min(j,lenb);
	while(i<lena) c.emplace_back(a[i].y,i,j),++i;
	while(j<lenb) c.emplace_back(b[j].y,i,j),j+=2;
}
inline void build(int l,int r){
	F(i,l,r) if(opt[i]==1) a[b[x[i]]].emplace_back(x[i],y[i],s[i]);
	F(i,1,b[n]){
		if(a[i].empty()) continue;
		sort(a[i].begin(),a[i].end());
		tmp.resize(a[i].size()+v[i].size());
		merge(a[i].begin(),a[i].end(),v[i].begin(),v[i].end(),tmp.begin());
		v[i]=tmp;
		v[i][0].sum=v[i][0].val;
		F(j,1,v[i].size()-1) v[i][j].sum=v[i][j-1].sum+v[i][j].val;
		a[i].clear();tmp.clear();
	}
	F(i,1,b[n]){
		fs[i].resize(v[i].size());
		F(j,0,(int)fs[i].size()-1) fs[i][j]=Node(v[i][j].y,j,0);
	}
	F(i,2,b[n]) Merge(fs[i],fs[i-1],fs[i]);
}
inline int get_val(int l,int r,int y){
	int id=lower_bound(fs[r].begin(),fs[r].end(),Node(y,0,0))-fs[r].begin(),res=0;
	UF(i,r,l){
		if(id&&fs[i][id-1].y>=y) --id;
		if(id==fs[i].size()||fs[i][id].id==v[i].size()){
			if(!v[i].empty()) res+=v[i].back().sum;
		}else if(fs[i][id].id) res+=v[i][fs[i][id].id-1].sum;
		if(id==fs[i].size()) id=fs[i-1].size();
		else id=fs[i][id].nxt;
	}
	return res;
}
inline int query(int l,int r,int y,int id){
	int bl=b[l],br=b[r],res=0;
	if(bl==br){
		for(node tmp:v[bl]) if(l<=tmp.x&&tmp.x<=r&&tmp.y<=y) res+=tmp.val;
		return res;
	}
	for(node tmp:v[bl]) if(l<=tmp.x&&tmp.y<=y) res+=tmp.val;
	for(node tmp:v[br]) if(tmp.x<=r&&tmp.y<=y) res+=tmp.val;
	return res+get_val(bl+1,br-1,y+1);
}
inline int ask(int i){
	int b=(i-1)/len1+1,res=0;
	F(j,(b-1)*len1+1,i) if(opt[j]==1&&x[i]<=x[j]&&x[j]<=s[i]&&y[i]<=y[j]&&y[j]<=t[i]) res+=s[j];
	return res;
}
bool M2;
int main(){
	int Time=clock();
	look_memory;
	n=read();
	while(++m){
		opt[m]=read();
		if(opt[m]==1) x[m]=read(),y[m]=read(),s[m]=read();
		if(opt[m]==2) x[m]=read(),y[m]=read(),s[m]=read(),t[m]=read();
		if(opt[m]==3) break;
	}
	--m;
	len=2*sqrt(n);len1=2*sqrt(m);
	F(i,1,n) b[i]=(i-1)/len+1;
	F(i,1,m){
		if(opt[i]==1) x[i]^=ans,y[i]^=ans,s[i]^=ans;
		else{
			x[i]^=ans;y[i]^=ans;s[i]^=ans;t[i]^=ans;
			cout<<(ans=ask(i)+query(x[i],s[i],t[i],i)-query(x[i],s[i],y[i]-1,i))<<'\n';
		}
		if(!(i%len1)) build(i-len1+1,i);
	}
	look_time;
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

考虑 K-D Tree。              

我们在建好 K-D Tree 后考虑优化我们的暴力查找。        

我们在查找时看一个子树的矩形是否和当前查找的矩形有交，没有就直接不管；有被完全覆盖的矩形就直接返回矩形内的所有点和就好了。                   

否则我们就看当前点在不在矩形内，有的话就要把它的贡献加上，然后继续往下找。             

可以证明，在 K-D Tree 的查找中，如果所有被完全覆盖的矩形不再往下走单次最不理想时间复杂度为 $O(n ^ {1 - \frac{1}{k}})$ ，最理想时间复杂度为 $O(\log n)$ ，于是问题得到解决。              

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 5e5 + 5;
const double a = 0.6;
int rt,cur,n,m,X[Len][2],Y[Len][2],lc[Len],rc[Len],xl,yl,xr,yr,sum[Len],siz[Len],d[Len];
int g[Len],t;
struct node
{
	int x,y,w;
}s[Len];
bool cmpx(int x,int y){return s[x].x < s[y].x;}
bool cmpy(int x,int y){return s[x].y < s[y].y;}
void Print(int x)
{
	if(!x) return;
	Print(lc[x]);
	g[++ t] = x;
	Print(rc[x]);
}
void push_Up(int x,int y)
{
	X[x][0] = min(X[x][0] , X[y][0]);
	X[x][1] = max(X[x][1] , X[y][1]);
	Y[x][0] = min(Y[x][0] , Y[y][0]);
	Y[x][1] = max(Y[x][1] , Y[y][1]);
}
void maintain(int x)
{
	sum[x] = sum[lc[x]] + sum[rc[x]] + s[x].w;
	siz[x] = siz[lc[x]] + siz[rc[x]] + 1;
	X[x][0] = X[x][1] = s[x].x;
	Y[x][0] = Y[x][1] = s[x].y;
	if(lc[x]) push_Up(x , lc[x]);
	if(rc[x]) push_Up(x , rc[x]);
}
int Sqrt(int x){return x * x;}
int build(int l,int r)
{
	if(l > r) return 0;
	int mid = (l + r) >> 1;
	double avx = 0 , avy = 0 , vax = 0 , vay = 0;
	for(int i = l ; i <= r ; i ++) avx += s[g[i]].x , avy += s[g[i]].y;
	avx = avx / (1.0 * (r - l + 1));
	avy = avy / (1.0 * (r - l + 1));
	for(int i = l ; i <= r ; i ++) vax += Sqrt(s[g[i]].x - avx) , vay += Sqrt(s[g[i]].x - avy);
	if(vax >= vay) d[g[mid]] = 1 , nth_element(g + l , g + mid , g + r + 1 , cmpx);
	else d[g[mid]] = 2 , nth_element(g + l , g + mid , g + r + 1 , cmpy);
	lc[g[mid]] = build(l , mid - 1) , rc[g[mid]] = build(mid + 1 , r);
	maintain(g[mid]);
	return g[mid];
}
void rebuild(int &x)
{
	t = 0;
	Print(x);
	x = build(1 , t);
}
inline bool IsF(int x){return 1.0 * a * siz[x] <= (double)max(siz[lc[x]] , siz[rc[x]]);}
void ins(int &x,int v)
{
	if(!x)
	{
		x = v;
		maintain(x);
		return;
	}
	if(d[x] == 1) 
	{
		if(s[v].x <= s[x].x) ins(lc[x] , v);
		else ins(rc[x] , v);
	}
	else
	{
		if(s[v].y <= s[x].y) ins(lc[x] , v);
		else ins(rc[x] , v);
	}
	maintain(x);
	if(IsF(x)) rebuild(x);
}
int query(int x)
{
	if(!x || xr < X[x][0] || xl > X[x][1] || yr < Y[x][0] || yl > Y[x][1]) return 0;
	if(xl <= X[x][0] && X[x][1] <= xr && yl <= Y[x][0] && Y[x][1] <= yr) return sum[x];
	int ret = 0;
	if(xl <= s[x].x && s[x].x <= xr && yl <= s[x].y && s[x].y <= yr) ret = s[x].w;
	return query(lc[x]) + query(rc[x]) + ret; 
}
int main()
{
	scanf("%d",&n);int lstans = 0;int opt;
	while(1)
	{
		scanf("%d",&opt);
		if(opt == 1)
		{
			cur ++;scanf("%d %d %d",&s[cur].x,&s[cur].y,&s[cur].w);
			s[cur].x ^= lstans , s[cur].y ^= lstans , s[cur].w ^= lstans;
			ins(rt , cur);
		}
		else if(opt == 2)
		{
			scanf("%d %d %d %d",&xl,&yl,&xr,&yr);
			xl ^= lstans , yl ^= lstans , xr ^= lstans , yr ^= lstans;
			printf("%d\n",lstans = query(rt));
		}
		else if(opt == 3) break;
	}
	return 0;
}
```

---


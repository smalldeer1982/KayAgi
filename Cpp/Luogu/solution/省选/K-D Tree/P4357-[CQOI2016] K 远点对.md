# [CQOI2016] K 远点对

## 题目描述

已知平面内 $N$ 个点的坐标，求欧氏距离下的第 $K$ 远点对。

两个点 $P(x_1,y_1)$ 和 $Q(x_2,y_2)$ 的欧氏距离定义为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$

## 说明/提示

对于 $100\%$ 的测试点，$N \le 100000,1 \le K \le 100,K \le \dfrac {N(N-1)}{2},0 \le X,Y < 2^{31}$

## 样例 #1

### 输入

```
10 5
0 0
0 1
1 0
1 1
2 0
2 1
1 2
0 2
3 0
3 1```

### 输出

```
9```

# 题解

## 作者：FZzzz (赞：19)

整个正经做法。

每次旋转卡壳取相隔最远的两个点，把所有点和这两个点的距离丢进小根堆里，然后把这两个点删掉，这个过程重复 $k$ 次。堆的大小固定为 $k$，最后堆顶就是答案。

这样做事对的。考虑一对没有被算过的点，在每一轮中如果它的两个端点都没有被删掉，那么它必然不大于这一轮找出来的直径，否则它肯定已经被算过了。

时间复杂度大概是 $O(nk\log n)$，好像有一些神奇做法可以优化但是我懒得写了。

代码封装少比较丑。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5;
int n,k,x[maxn],y[maxn];
typedef long long ll;
ll cross(int a,int b,int c){
	return 1ll*(x[c]-x[a])*(y[b]-y[a])-1ll*(x[b]-x[a])*(y[c]-y[a]);
}
ll dist(int a,int b){
	return 1ll*(x[a]-x[b])*(x[a]-x[b])+1ll*(y[a]-y[b])*(y[a]-y[b]);
}
int s[maxn*2],tp;
bool vis[maxn];
pair<int,int> calc(){
	vector<int> ord;
	for(int i=1;i<=n;i++) if(!vis[i]) ord.push_back(i);
	sort(ord.begin(),ord.end(),[](int a,int b){
		if(x[a]!=x[b]) return x[a]<x[b];
		return y[a]<y[b];
	});
	s[0]=ord[0];
	tp=1;
	for(int i=1;i<(int)ord.size();i++){
		while(s[tp-1]!=ord[0]&&1ll*(y[ord[i]]-y[s[tp-1]])*(x[ord[i]]-x[s[tp-2]])>=1ll*(y[ord[i]]-y[s[tp-2]])*(x[ord[i]]-x[s[tp-1]])) tp--;
		s[tp++]=ord[i];
	}
	for(int i=(int)ord.size()-2;i>=0;i--){
		while(s[tp-1]!=ord.back()&&1ll*(y[s[tp-1]]-y[ord[i]])*(x[s[tp-2]]-x[ord[i]])>=1ll*(y[s[tp-2]]-y[ord[i]])*(x[s[tp-1]]-x[ord[i]])) tp--;
		s[tp++]=ord[i];
	}
	tp--;
	if(tp==2) return {s[0],s[1]};
	int cur=0;
	while(cross(s[tp-1],s[0],s[(cur+1)%tp])>cross(s[tp-1],s[0],s[cur])) cur=(cur+1)%tp;
	int a=s[cur],b;
	if(dist(s[cur],s[0])>dist(s[cur],s[tp-1])) b=s[0];
	else b=s[tp-1];
	for(int i=0;i<tp-1;i++){
		while(cross(s[i],s[i+1],s[(cur+1)%tp])>cross(s[i],s[i+1],s[cur])) cur=(cur+1)%tp;
		if(dist(s[cur],s[i])>dist(a,b)){
			a=s[cur];
			b=s[i];
		}
		if(dist(s[cur],s[i+1])>dist(a,b)){
			a=s[cur];
			b=s[i+1];
		}
	}
	return {a,b};
}
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	k=readint();
	for(int i=1;i<=n;i++){
		x[i]=readint();
		y[i]=readint();
	}
	priority_queue<ll,vector<ll>,greater<ll>> pq;
	for(int i=0;i<min(k,n/2);i++){
		auto res=calc();
		int a=res.first,b=res.second;
		pq.push(dist(a,b));
		if((int)pq.size()>k) pq.pop();
		vis[a]=vis[b]=1;
		for(int j=1;j<=n;j++) if(!vis[j]){
			pq.push(dist(a,j));
			if((int)pq.size()>k) pq.pop();
		}
		for(int j=1;j<=n;j++) if(!vis[j]){
			pq.push(dist(b,j));
			if((int)pq.size()>k) pq.pop();
		}
	}
	printf("%lld\n",pq.top());
	return 0;
}
```
另外这题 kdt 复杂度应该是错的，但是我不会卡，有没有老哥教教我啊。

---

## 作者：_szh_ (赞：5)

## [CQOI2016]K远点对
### 题意

求第 $k$ 远的点对。

$n,m \leq 1e5$ 

$1\leq k\le min(100,\frac{n*(n-1)}{2})$

$0\le x_i,y_i < 2^{31}$

----

我们可以看出这是一个 $Kd \ Tree$ 裸题

但是我并不会 $Kd \ Tree$

而 $k$ 又这么小，这代表着我们或许有其他方法。

### 做法

计算**当前最远点对** 的值和两个端点。删除这两个点,并计算贡献

贡献也就是**所有**与这两个点**相连的点**之间的距离

以上步骤**重复 $k$ 次**

我们的答案肯定是其中第 $k$ 远的点对

### 分析

这样显然是对的，答案不可能跑到别的地方。

所以每次用**旋转卡壳**计算最远点对，删点就打个标记，再用个堆维护答案。

复杂度 $O(n\log n+nk+nk\log k)$

感觉有 $O(n\log n+k^2\log k)$ 的，但是上面的已经能过了。

### 代码

```
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
#define int long long
#define N 100010
using namespace std;
inline int read()
{
	int neg=1,num=0;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')neg=-1;
	for(;isdigit(c);c=getchar())num=(num<<1)+(num<<3)+c-'0';
	return neg*num;
}
struct node
{
	int x,y,id;
}p[N],s[N];
int n,k,siz,tmp,top,ans;
bool alive[N];
priority_queue<int,vector<int>,greater<int> >q;
inline bool cmp(node a,node b){return a.x!=b.x?a.x<b.x:a.y<b.y;}
inline int dist(node a,node b){return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}
inline int cross(node a,node b,node c){return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);}
inline void Insert(int x)
{
	if(siz<k)siz++,q.push(x);
	else if(siz>=k && q.top()<x)q.pop(),q.push(x);
}
inline void Delete(int x){alive[x]=1;for(int i=1;i<=n;i++)if(!alive[i])Insert(dist(p[i],p[x]));}
inline void Init()
{
	top=0;
	for(int i=1;i<=n;i++)
	{
		if(alive[i])continue;
		for(;top>=2 && cross(s[top-1],s[top],p[i])>=0;top--);
		s[++top]=p[i];
	}
	for(int i=s[top].id-1,pre=top;i>=s[1].id;i--)
	{
		if(alive[i])continue;
		for(;top-pre>=1 && cross(s[top-1],s[top],p[i])>=0;top--);
		s[++top]=p[i];
	}
	s[0]=s[--top];
}
inline node Find()
{
	Init();int ans=0,a1,a2;
	if(top==2){return (node){s[1].id,s[2].id};}
	for(int i=0,j=2;i<top;i++)
	{
		while(cross(s[i],s[i+1],s[j])>cross(s[i],s[i+1],s[j+1]))j=(j+1)%top;
		if(dist(s[i],s[j])>ans)ans=dist(s[i],s[j]),a1=s[i].id,a2=s[j].id;
		if(dist(s[i+1],s[j])>ans)ans=dist(s[i+1],s[j]),a1=s[i+1].id,a2=s[j].id;
	}
	return (node){a1,a2};
}
signed main()
{
	n=tmp=read();k=read();
	for(int i=1;i<=n;i++)p[i].x=read(),p[i].y=read();
	sort(p+1,p+n+1,cmp);
	for(int i=1;i<=n;i++)p[i].id=i;
	for(;k && tmp>=2;k--,tmp-=2)
	{
		node a=Find();
		Delete(a.x);Delete(a.y);
	}
	printf("%lld",q.top());
	return 0;
}
```








---

## 作者：lupengheyyds (赞：3)

此题正解是旋转卡壳。虽然 KD 树过不了最后一个 Hack 但由于此题有 KD 树的标签，所以还是讲讲思路。
## KD树
对于每个点，求距离这个点的最远的 k 个点。放入容量为 k 的小根堆。堆顶为答案。

随机情况复杂度 $\mathcal O(nk\log n)$，最坏情况复杂度 $\mathcal O(n^2k)$。

代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int szl=1e5+5,K=2;
int kdnow;
struct Node{
	int mx[K],mn[K],dim[K],ls,rs;
	bool operator<(const Node &tmp)const{
		return dim[kdnow]<tmp.dim[kdnow];
	}	
	#define mx(x) kdt[x].mx
	#define mn(x) kdt[x].mn
	#define dim(x) kdt[x].dim
	#define ls(x) kdt[x].ls
	#define rs(x) kdt[x].rs
}kdt[szl];
int n,k,root;
inline void Up(int p){
	for(int i=0;i<K;i++){
		mn(p)[i]=mx(p)[i]=dim(p)[i];
		if(ls(p)){
			mn(p)[i]=min(mn(p)[i],mn(ls(p))[i]);
			mx(p)[i]=max(mx(p)[i],mx(ls(p))[i]);
		}
		if(rs(p)){
			mn(p)[i]=min(mn(p)[i],mn(rs(p))[i]);
			mx(p)[i]=max(mx(p)[i],mx(rs(p))[i]);
		}
	}
	return;
}
int Build(int l,int r,int d){
	if(l>r)return 0;
	int mid=l+r>>1;
	kdnow=d;
	nth_element(kdt+l,kdt+mid,kdt+r+1);
	ls(mid)=Build(l,mid-1,d^1);
	rs(mid)=Build(mid+1,r,d^1);
	Up(mid);
	return mid;
}
bool alrdy[szl];
int fp,ans,lns;
vector<int> tmp;
priority_queue<long long,vector<long long>,greater<long long> > pq;//只关注其中一端的有序序列 
inline long long Sqar(int val){
	return val*val;
}
inline long long Dis(int q[K],int p[K]){
	return Sqar(q[0]-p[0])+Sqar(q[1]-p[1]);
}
inline long long MaxDis(int p,int dim[K]){
	int dis=0;
	for(int i=0;i<K;i++)dis+=Sqar(max(mx(p)[i]-dim[i],dim[i]-mn(p)[i]));
	return dis;
}
inline int MinDis(int p,int dim[K]){
	int dis=0;
	for(int i=0;i<K;i++)dis+=Sqar(max(max(dim[i]-mx(p)[i],0ll),max(mn(p)[i]-dim[i],0ll)));
	return dis;
}
inline bool Ok(int p,int dim[K]){
	if(MinDis(p,dim)>lns)return false;
	if(MaxDis(p,dim)<ans)return false;
	return true;
}
void Search(int l,int r,int dim[K]){//目前最大值 
	if(l>r)return;
	int mid=l+r>>1;
	int dis=Dis(dim,dim(mid));
	if(!alrdy[mid]&&ans<Dis(dim,dim(mid)))fp=mid,ans=Dis(dim,dim(mid));
	if(Ok(ls(mid),dim))Search(l,mid-1,dim);
	if(Ok(rs(mid),dim))Search(mid+1,r,dim);
	return;
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>dim(i)[0]>>dim(i)[1];
	root=Build(1,n,0);
	for(int i=1;i<=n;i++){
		for(int tm:tmp)alrdy[tm]=false;
		lns=LONG_LONG_MAX;
		for(int j=1;j<=k;j++){
			ans=0;
			Search(1,n,dim(i));
			if(pq.size()==2*k&&ans<pq.top())break;
			pq.push(ans);
			if(pq.size()>2*k)pq.pop();
			alrdy[fp]=true;
			tmp.push_back(fp);
			lns=ans;
		}
	}
	cout<<pq.top();
	return 0;
}
```

## 旋转卡壳
每次找出最远点对，将这两个点与所有点的距离放入容量为 k 的小根堆，进行 k 次。堆顶为答案。

代码：
```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int NN=1e5+5;
struct V{
	int x,y;
	V operator+(V b){return {x+b.x,y+b.y};}
	V operator-(V b){return {x-b.x,y-b.y};}
	int operator*(V b){return {x*b.x+y*b.y};}
	int operator^(V b){return {x*b.y-y*b.x};}
	bool operator<(V b){return x!=b.x?x<b.x:y<b.y;}
	void read(int i){cin>>x>>y;return;}
	int len2(){return x*x+y*y;}
}v[NN];
int n,k;
typedef pair<V,int> pa;
struct Stack{
	pa st[NN];
	int tp;
	void push(V x,int i){st[++tp]={x,i};}
	void pop(){tp--;}
	V top(){return st[tp].first;}
	V top2(){return st[tp-1].first;}
	int size(){return tp;}
	void clear(){tp=0;}
	V&operator[](int x){return st[x].first;}
}st;
void TB(){
	st.clear();
	if(n<2)return;
	sort(v+1,v+1+n);	
	for(int i=1;i<=n;i++){
		while(st.size()>=2&&((st.top()-st.top2())^(v[i]-st.top2()))<=0)st.pop();
		st.push(v[i],i);
	}
	int sz=st.size()-1;//去掉链接重复的 
	for(int i=n;i>=1;i--){
		while(st.size()-sz>=2&&((st.top()-st.top2())^(v[i]-st.top2()))<=0)st.pop();
		st.push(v[i],i);
	}
	st.pop();//弹掉最后重复的 
	return;
}
priority_queue<int,vector<int>,greater<int> > q;
void XZQQ(){
	int ans=0,posi,posj;
	if(st.size()<2)return;
	for(int i=1,j=2;i<=st.size();i++){
		V ve=st[i%st.size()+1]-st[i];
		while((ve^(st[j%st.size()+1]-st[i]))>(ve^(st[j]-st[i])))j=j%st.size()+1;
		if((st[i]-st[j]).len2()>ans)ans=(st[i]-st[j]).len2(),posi=st.st[i].second,posj=st.st[j].second;
		if((st[i%st.size()+1]-st[j]).len2()>ans)ans=(st[i%st.size()+1]-st[j]).len2(),posi=st.st[i%st.size()+1].second,posj=st.st[j].second;
	}
	for(int i=1;i<=n;i++){
		if(i==posi||i==posj)continue;
		q.push((v[i]-v[posi]).len2()),q.push((v[i]-v[posj]).len2());
		while(q.size()>k)q.pop();
	}
	q.push(ans);while(q.size()>k)q.pop();
	if(posi>posj)swap(posi,posj);
	swap(v[n],v[posj]);n--;
	swap(v[n],v[posi]);n--;
	return;
}
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)v[i].read(i);
	for(int i=1;i<=k;i++)TB(),XZQQ();
	cout<<q.top();
	return 0;
}
```

---


# [GDCPC 2024] 腊肠披萨

## 题目背景

数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>

## 题目描述

宇宙北大街上新开了一家披萨店。这家披萨店主打使用腊肠的披萨，被顾客亲切地称为“腊肠披萨店”。这种中西合璧的做法听上去很离经叛道，但是品尝过腊肠披萨的顾客都对其称赞有加，吸引了众多食客蜂拥而至。

除了配料极具特色，腊肠披萨店的 Wi-Fi 密码也是它的流量密码。菜单上写着：“本店的 Wi-Fi 密码是

$$
\sum_{i=1}^L \sum_{j=1}^L C^{\left|LCPS\left(s_i, s_j\right)\right|} \bmod{P},
$$

其中 $LCPS\left(s_i, s_j\right)$ 表示 $s_i$ 和 $s_j$ 的最长公共前后缀，即最长的同时是 $s_i$ 前缀和 $s_j$ 后缀的字符串（可能为空，也可能为整个串）；每天的 $s_1,\cdots,s_L$ 都不一样，服务员会在点餐后提供用于当天的 Wi-Fi 密码的字符串。每天将会从前 100 名连上 Wi-Fi 的顾客中随机抽取一位免单。”

你计划下周和朋友一起来这家店聚餐，因此你想设计一个算法，快速求出这家店的 Wi-Fi 密码。

## 说明/提示

### 样例 1 解释

对于 $1\le i,j\le 4, i\ne j$，

- $LCPS($ `pizza` $,$ `shop` $ )=LCPS($ `piazza` $,$ `shop` $)=LCPS($ `pizzala` $,$ `shop` $)=$ `p`；
- $LCPS($ `pizzala` $,$ `pizza` $)=$ `pizza`；
- 其余的 $LCPS\left(s_i, s_j\right)=\varepsilon$。

因此对应的 Wi-Fi 密码为

$$
2^4 + 2^0 + 2^0 + 2^0 + 2^1 + 2^5 + 2^0 + 2^0 + 2^1 + 2^0 + 2^6 + 2^0 + 2^1 + 2^5 + 2^0 + 2^7 = 286.
$$

腊肠披萨店在制作披萨时使用了绝密配方。在没有专业人士指导的情况下，请不要轻易模仿。

## 样例 #1

### 输入

```
4 2 378323747
shop
pizza
piazza
pizzala```

### 输出

```
286```

## 样例 #2

### 输入

```
9 99 998244353
asap
peace
piece
pizza
sapiens
dazzling
andromeda
sakurasaku
kokorosaku```

### 输出

```
161369438```

# 题解

## 作者：xiezheyuan (赞：1)

> 给定 $L$ 个字符串 $s_1, \dots, s_L$ 和两个整数 $C, P$。求 $\sum_{i=1}^L \sum_{j=1}^L C^{|LCPS(s_i, s_j)|} \bmod P$ 的值。其中 $LCPS(s_i, s_j)$ 表示字符串 $s_i$ 的最长前缀和字符串 $s_j$ 的最长后缀相同且最长的字符串。
>
> $1\leq L,\sum |s_i| \leq 10^6$。

一个非常直观的做法是每次我们枚举字符串的一个前缀，然后尝试找到这 $L_i$ 个字符串中有多少个后缀，这个前缀恰好等于这个后缀，那么这个东西显然可以通过 Hash 实现。

但是这个做法会有一个问题，我们会算重。完全可能存在 $S[1,i]=T[|T|-i+1,|T|]$ 同时又有 $S[1,j]=T[|T|-j+1,|T|]$ 的情况（假设 $i<j$）。但是这样就能导出一个事实，即 $S[1,i]=T[|T|-j+1,|T|-j+i]$，或者说，$S[1,j]$ 的长度为 $i$ 的前缀与长度为 $i$ 的后缀是相等的。也就是说，$S[1,j]$ 有一个长度为 $i$ 的 Border。刻画 Border 的首选技术是 KMP / ACAM。当然这道题如果用 ACAM 就是有点大炮打蚊子的意思。

用 KMP 求出每一个字符串的前缀函数，那么我们就知道每个字符串的前缀的最长 Border 长度，直接容斥，算这一个前缀的贡献时，减去最长 Border 的贡献（因为它肯定算过了），就不会算重了。时间复杂度 $O(\sum |s_i|)$。

[Submission](https://qoj.ac/submission/1172559)。

---

## 作者：Diaоsi (赞：1)

[腊肠披萨](https://qoj.ac/contest/1692/problem/8753)

场上过了，记录一下。

枚举每个提供后缀的字符串，尝试找到能与该后缀匹配的前缀个数。

发现这个过程很像在 AC 自动机上跳 $\mathrm{fail}$ 指针。设 $u$ 为 Trie 上节点，$\mathrm{fail}[u]$ 对应的节点就是能与 $u$ 对应字符串的后缀匹配的最长前缀在 Trie 上对应的节点。

显然，能与 $u$ 匹配的字符串就是 $\mathrm{fail}[u]$ 子树中的所有串，还有 $\mathrm{fail}[\mathrm{fail}[u]]$ 对应的子树，以此类推不断跳 $\mathrm{fail}$ 然后对子树求和。

但是这样仍然存在一个问题，就是一个串可以有多个前缀与 $u$ 的后缀匹配：

```
aaabaaabccc
dddaaabaaab
```

在上面这个例子中，能产生的公共段有 ```aaabaaab``` 和 ```aaab```。这样贡献会算重，我们只需要 ```aaabaaab```。

还是考虑跳 $\mathrm{fail}$ 的过程，跳到 $\mathrm{fail}[u]$ 并计算完贡献后，$\mathrm{fail}[u]$ 子树中的字符串就不会再对 $u$ 产生贡献了，$\mathrm{fail}[\mathrm{fail}[u]]$ 等同理。把 Trie 丢到 DFS 序上，整个过程其实就是区间求和 + 区间推平，线段树可以维护。

由于这题比较卡常，所以线段树需要较为精细的实现。

时间复杂度 $\mathcal{O}\big(n(|\Sigma|+\log n)\big)$。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define fi first
#define se second
#define mp make_pair
#define pb push_back
typedef long long ll;
typedef long double ld;
using namespace std;
const int N=3000010,INF=0x3f3f3f3f;
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
inline void swap(int &x,int &y){x^=y^=x^=y;}
int n,m,p,ans,num,cnt,f[N],d[N],id[N],sz[N],pre[N],fac[N];
int ch[N][26],tr[N][26],fail[N],e[N],tot;
string s[N];
queue<int> q;
void insert(int i){
	int p=0;
	for(char c:s[i]){
		if(!ch[p][c-'a'])ch[p][c-'a']=tr[p][c-'a']=++tot;
		d[ch[p][c-'a']]=d[p]+1;
		p=ch[p][c-'a'];
	}
	e[p]++;
}
void build(){
	for(int i=0;i<26;i++)
		if(tr[0][i])q.push(tr[0][i]);
	while(q.size()){
		int u=q.front();q.pop();
		for(int i=0;i<26;i++){
			if(tr[u][i])
				fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);
			else
				tr[u][i]=tr[fail[u]][i];
		}
	}
}
void dfs(int x){
	sz[x]=1;
	id[x]=++num;
	pre[id[x]]=e[x];
	for(int i=0;i<26;i++){
		if(!ch[x][i])continue;
		dfs(ch[x][i]);
		sz[x]+=sz[ch[x][i]];
	}
}
struct SegmentTree{
	int dat,sum,tag;
	#define dat(x) tree[x].dat
	#define sum(x) tree[x].sum
	#define tag(x) tree[x].tag
}tree[N<<2];
void pushup(int x){
	dat(x)=dat(x<<1)+dat(x<<1|1);
	sum(x)=sum(x<<1)+sum(x<<1|1);
}
void build(int x,int l,int r){
	tag(x)=-1;
	if(l==r){dat(x)=sum(x)=pre[l];return;}
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	pushup(x);
}
void pushdown(int x){
	if(tag(x)<0)return;
	sum(x<<1)=tag(x)*dat(x<<1);
	sum(x<<1|1)=tag(x)*dat(x<<1|1);
	tag(x<<1)=tag(x);
	tag(x<<1|1)=tag(x);
	tag(x)=-1;
}
int query(int x,int l,int r,int L,int R){
	if(!tag(x))return 0;
	if(L<=l&&r<=R){
		int val=sum(x);
		tag(x)=sum(x)=0;
		return val;
	}
	int mid=(l+r)>>1,val=0;
	pushdown(x);
	if(L<=mid)val+=query(x<<1,l,mid,L,R);
	if(R>mid)val+=query(x<<1|1,mid+1,r,L,R);
	pushup(x);
	return val;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>p;
	fac[0]=1;
	for(int i=1;i<N;i++)
		fac[i]=1ll*fac[i-1]*m%p;
	for(int i=1;i<=n;i++)
		cin>>s[i],insert(i);
	build();
	dfs(0);
	build(1,1,num);
	for(int i=0;i<=tot;i++){
		if(!e[i])continue;
		int val=0;
		for(int u=i;;u=fail[u]){
			val=(val+1ll*fac[d[u]]*query(1,1,num,id[u],id[u]+sz[u]-1)%p)%p;
			if(!u)break;
		}
		tag(1)=1;sum(1)=dat(1);
		ans=(ans+1ll*val*e[i]%p)%p;
	}
	cout<<ans<<'\n';
	return 0;
}
```

---


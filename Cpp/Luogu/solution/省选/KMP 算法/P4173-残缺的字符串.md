# 残缺的字符串

## 题目描述

很久很久以前，在你刚刚学习字符串匹配的时候，有两个仅包含小写字母的字符串 $A$ 和 $B$，其中 $A$ 串长度为 $m$，$B$ 串长度为 $n$。可当你现在再次碰到这两个串时，这两个串已经老化了，每个串都有不同程度的残缺。

你想对这两个串重新进行匹配，其中 $A$ 为模板串，那么现在问题来了，请回答，对于 $B$ 的每一个位置 $i$，从这个位置开始连续 $m$ 个字符形成的子串是否可能与 $A$ 串完全匹配？

## 说明/提示

$100\%$ 的数据满足 $1 \le m \le n \le 3 \times 10^5$。

## 样例 #1

### 输入

```
3 7
a*b
aebr*ob```

### 输出

```
2
1 5```

# 题解

## 作者：Ebola (赞：146)

这是一道通配符匹配模板题。对于通配符的匹配，本人发表拙作如下。

# 浅谈FFT在字符串匹配中的应用

### 背景引入

字符串匹配，是OI中的一个古老为传统的问题。常见的匹配问题有：单模式串匹配、多模式串匹配、字串匹配。而对应的算法是KMP、AC自动机、后缀自动机。而我们今天要谈的问题，是单模式串匹配问题的一种：带通配符的单模式串匹配。

为了逐步解决这个问题，我们从普通的单模式串匹配开始说起。

### 普通的单模式串匹配

问题概述：给定模式串A（长度为m）、文本串B（长度为n），需要求出所有位置p，满足B串从第p个字符开始的连续m个字符，与A串完全相同

KMP是这一类问题的优秀算法，理论复杂度是线性的。但今天我们要用FFT来解决这个问题。千万不要因为FFT的复杂度高于KMP而忽略这一段，因为这一段内容对接下来我们要解决的问题而言，非常重要。

为了使问题更便于研究，我们约定所有字符串的下标从0开始

我们定义字符串的匹配函数C(x,y)=A(x)-B(y)，那么我们可以形式化地定义“匹配”：若C(x,y)=0，则称A的第x个字符和B的第y个字符匹配。再定义完全匹配函数$P(x)=\sum\limits_{i=0}^{m-1}C(i,x-m+i+1)$，若P(x)=0，则称B以第x位结束的连续m位，与A完全匹配

但有没有觉得这个完全匹配函数有什么问题？似乎，根据完全匹配函数，“ab”与“ba”是匹配的？？？问题出在我们定义的匹配函数身上。匹配函数的确可以判断某一位是否匹配，但加了一个求和符号，一切都变了，只要两个串所含的字符是一样的，不管排列如何，完全匹配函数都会返回0值。

而这一切的罪魁祸首就是匹配函数的正负号！我们现在要做的是：定义一个更好的匹配函数，只要两个字符串某一位的匹配函数非零，完全匹配函数也不可能为零。不难想到给匹配函数加一个绝对值符号。但这样似乎就只能O(nm)暴力计算，没有更好的优化方法了。于是我们给匹配函数加上一个平方符号。此时完全匹配函数就是$P(x)=\sum\limits_{i=0}^{m-1}\left[A(i)-B(x-m+i+1)\right]^2$

这样还是没什么优化方法。我们不妨翻转A串，将翻转后的结果设为S。形式化地，S(x)=A(m-x-1)。据此不难推出A(x)-S(m-x-1)。于是完全匹配函数可以写成$P(x)=\sum\limits_{i=0}^{m-1}\left[S(m-i-1)-B(x-m+i+1)\right]^2$

大力展开这个函数：$P(x)=\sum\limits_{i=0}^{m-1}\left[S(m-i-1)^2+B(x-m+i+1)^2-2S(m-i-1)B(x-m+i+1)\right]$

再将求和符号拆开：$P(x)=\sum\limits_{i=0}^{m-1}S(m-i-1)^2+\sum\limits_{i=0}^{m-1}B(x-m+i+1)^2-2\sum\limits_{i=0}^{m-1}S(m-i-1)B(x-m+i+1)$

第一项是一个定值，可以O(m)预处理出来。第二项可以O(n)预处理前缀和。现在问题就在第三项。第三项中，两个小括号里面的东西加起来，似乎能抵消很多东西？居然……刚好等于x？这是巧合吗？~~当然不是，明明是我干出来的。~~所以，第三项是不是可以写成$-2\sum\limits_{i+j=x}S(i)B(j)$呢？当然可以！（这一步不太好解释，需要自己好好理解一下）

那么，我们设$T=\sum\limits_{i=0}^{m-1}S(i)^2\qquad f(x)=\sum\limits_{i=0}^xB(i)^2\qquad g(x)=\sum\limits_{i+j=x}S(i)B(j)$

于是就有$P(x)=T+f(x)-f(x-m)-2g(x)$

观察这个g函数，发现它不就是我们熟悉的卷积形式吗？而且还是最常规的卷积——多项式乘法！于是可以用FFT计算出g函数了！然后再代入计算一下，就可以O(n)得到所有P(x)的值了！

说了那么多，其实代码很短的。下面是核心代码。~~FFT相信大家都会，就不放出来了~~

```cpp
void FFT_Match(char *s1,char *s2,int m,int n)
{
	for(int i=0;i<m;i++) A[i].r=s1[i]-'a'+1;
	for(int i=0;i<n;i++) B[i].r=s2[i]-'a'+1;
	reverse(A,A+m);double T=0;
	for(int i=0;i<m;i++) T+=A[i].r*A[i].r;
	f[0]=B[0].r*B[0].r;
	for(int i=1;i<n;i++) f[i]=f[i-1]+B[i].r*B[i].r;
	FFT(A,len,1);FFT(B,len,1);
	for(int i=0;i<len;i++) g[i]=A[i]*B[i];
	FFT(g,len,-1);
	for(int x=m-1;x<n;x++)
	{
		double P=T+f[x]-f[x-m]-2*g[x].r;
		if(fabs(P)<eps) printf("%d ",x-m+2);
	}
}
```

### 带通配符的单模式串匹配

问题概述：给定模式串A（长度为m）、文本串B（长度为n），串的某些字符是“通配符”（通配符是一种可以与任意字符匹配的字符）。需要求出所有位置p，满足B串从第p个字符开始的连续m个字符，与A串完全相同

这个问题显然用KMP就无法解决了，我们还是考虑和上面类似的方法。那么我们回顾上面的普通串匹配过程，我们可以总结出思路大概是这样的：

1. 定义匹配函数

2. 定义完全匹配函数

3. 快速计算每一位的完全匹配函数值

有了通配符，我们肯定需要重新定义一个匹配函数

我们设通配符的数值为0，定义匹配函数$C(x,y)=[A(x)-B(y)]^2A(x)B(y)$，这样就完美地解决了通配符匹配问题。那么我们的完全匹配函数就是$P(x)=\sum\limits_{i=0}^{m-1}[A(i)-B(x-m+i+1)]^2A(i)B(x-m+i+1)$

还是老套路，将A串翻转，也就是设$S(i)=A(m-i-1)$

然后完全匹配函数变成：$P(x)=\sum\limits_{i=0}^{m-1}[S(m-i-1)-B(x-m+i+1)]^2S(m-i-1)B(x-m+i+1)$

暴力展开：$P(x)=\sum\limits_{i=0}^{m-1}S(m-i-1)^3B(x-m+i+1)+\sum\limits_{i=0}^{m-1}S(m-i-1)B(x-m+i+1)^3-2\sum\limits_{i=0}^{m-1}S(m-i-1)^2B(x-m+i+1)^2$

发现所有的项，都满足两个小括号加起来等于x，所以全部写成卷积的形式：

$P(x)=\sum\limits_{i+j=x}S(i)^3B(j)+\sum\limits_{i+j=x}S(i)B(j)^3-2\sum\limits_{i+j=x}S(i)^2B(j)^2$

这样只要做6次FFT外加1次IFFT就可以得到完全匹配函数每一位的值了

核心代码其实也不长，三次多项式乘法而已，常数略大

```cpp
void FFT_match(char *s1,char *s2,int m,int n)
{
	reverse(ss1,ss1+m);
	for(int i=0;i<m;i++) A[i]=(s1[i]!='*')?(s1[i]-'a'+1):0;
	for(int i=0;i<n;i++) B[i]=(s2[i]!='*')?(s2[i]-'a'+1):0;
	
	for(int i=0;i<len;i++) a[i]=Comp(A[i]*A[i]*A[i],0),b[i]=Comp(B[i],0);
	FFT(a,len,1);FFT(b,len,1);
	for(int i=0;i<len;i++) P[i]=P[i]+a[i]*b[i];
	
	for(int i=0;i<len;i++) a[i]=Comp(A[i],0),b[i]=Comp(B[i]*B[i]*B[i],0);
	FFT(a,len,1);FFT(b,len,1);
	for(int i=0;i<len;i++) P[i]=P[i]+a[i]*b[i];
	
	for(int i=0;i<len;i++) a[i]=Comp(A[i]*A[i],0),b[i]=Comp(B[i]*B[i],0);
	FFT(a,len,1);FFT(b,len,1);
	for(int i=0;i<len;i++) P[i]=P[i]-a[i]*b[i]*Comp(2,0);
	
	FFT(P,len,-1);
	for(int i=m-1;i<n;i++) if(fabs(P[i].r)<=1e-7) printf("%d ",i-m+2);
}
```

本题直接套用上述代码即可。

---

## 作者：Ameyax (赞：34)

没人发标算，%楼下大佬  

把$*$都改成$0$  
设$dis(A,B)=\sum\limits_{i=0}^{n-1}(A[i]-B[i])^2A[i]B[i]$  

$B$以$i$结尾的串与$A$完全匹配的条件是$f[i]=dis(A,B[i-m+1,i])==0$  

翻转$A$串，并在末尾补$0$。

$$f[i]=\sum\limits_{j=0}^i(A[j]-B[i-j])^2A[j]B[i-j]$$

$$=\sum\limits_{j=0}^iA[j]^3B[i-j]-2\sum\limits_{j=0}^iA[j]^2B[i-j]^2+\sum\limits_{j=0}^iA[j]B[i-j]^3$$  

分三次$fft$出所有的$f[i]$，时间复杂度也是$O(nlogn)$但是比楼下大佬多了个$3$

代码常数巨大

```cpp
#include <bits/stdc++.h>
using namespace std;
#define pi acos(-1)
const int MAX = 1100000;
char sa[MAX], sb[MAX];
int m, n, N, top, a[MAX], b[MAX];
int rev[MAX], sta[MAX];
struct cpx
{
    double x, y;
    cpx() {}
    cpx(double xx, double yy) { x = xx, y = yy; }
    friend cpx operator * (cpx a, cpx b)
    {
        return cpx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
    }
    friend cpx operator / (cpx a, double b)
    {
        return cpx(a.x / b, a.y / b);
    }
    friend cpx operator + (cpx a, cpx b)
    {
        return cpx(a.x + b.x, a.y + b.y);
    }
    friend cpx operator - (cpx a, cpx b)
    {
        return cpx(a.x - b.x, a.y - b.y);
    }
    friend cpx operator * (cpx a, double b)
    {
        return cpx(a.x * b, a.y * b);
    }
};
cpx A[MAX], B[MAX], C[MAX];
void fft(cpx *a, int f)
{
    for (int i = 0; i < N; i++)
        if (i < rev[i])
            swap(a[i], a[rev[i]]);
    for (int i = 1; i < N; i <<= 1)
    {
        cpx wn(cos(pi / i), f * sin(pi / i));
        for (int j = 0; j < N; j += (i << 1))
        {
            cpx w(1, 0);
            for (int k = 0; k < i; k++)
            {
                cpx x = a[j + k], y = w * a[j + k + i];
                a[j + k] = x + y;
                a[j + k + i] = x - y;
                w = w * wn;
            }
        }
    }
    if (f == -1)
        for (int i = 0; i < N; i++)
            a[i] = a[i] / N;
}
int main()
{
    scanf("%d%d%s%s", &m, &n, sa, sb);
    int l = 0;
    for (N = 1; N < 2 * n; N <<= 1) l++;
    for (int i = 0; i < N; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    for (int i = 0; i < m; i++)
        if (sa[i] != '*')
            a[i] = sa[i] - 'a' + 1;
    for (int i = 0; i < n; i++)
        if (sb[i] != '*')
            b[i] = sb[i] - 'a' + 1;
    reverse(a, a + m);
    for (int i = 0; i < m; i++) A[i] = cpx(a[i] * a[i] * a[i], 0);
    for (int i = 0; i < n; i++) B[i] = cpx(b[i], 0);
    fft(A, 1); fft(B, 1);
    for (int i = 0; i < N; i++) C[i] = C[i] + A[i] * B[i];
     
    for (int i = 0; i < N; i++) A[i] = B[i] = cpx(0, 0);
    for (int i = 0; i < m; i++) A[i] = cpx(a[i] * a[i], 0);
    for (int i = 0; i < n; i++) B[i] = cpx(b[i] * b[i], 0);
    fft(A, 1); fft(B, 1);
    for (int i = 0; i < N; i++) C[i] = C[i] - A[i] * B[i] * 2.0;
     
    for (int i = 0; i < N; i++) A[i] = B[i] = cpx(0, 0);
    for (int i = 0; i < m; i++) A[i] = cpx(a[i], 0);
    for (int i = 0; i < n; i++) B[i] = cpx(b[i] * b[i] * b[i], 0);
    fft(A, 1); fft(B, 1);
    for (int i = 0; i < N; i++) C[i] = C[i] + A[i] * B[i];
     
    fft(C, -1);
    for (int i = m - 1; i < n; i++)
        if (fabs(C[i].x) < 0.5)
            sta[++top] = i - m + 2;
    printf("%d\n", top);
    for (int i = 1; i <= top; i++)
        printf("%d ", sta[i]);
    return 0;
}

这题开6秒是闹哪样，bzoj上我用std::complex<double>都T掉了
上面的代码在bzoj跑了9s卡过
```

---

## 作者：crashed (赞：16)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4173)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;蛮有意思的一道题目。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不妨考虑最简单的问题：  
### 基础字符串匹配[P3375](luogu.com.cn/problem/P3375)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们需要匹配两个串$A,B$，长度均为$n$。下标从$0$开始。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（由于在计算机中，$char$和$int$本身并没有差别，所以这里讨论的串其实是数的序列）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会说——$KMP$裸题！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们现在要换一种方法做。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数学中，判等的对应了$a=b\Rightarrow a-b=0$，也就是说，两个数相等就对应了两个数的差为$0!$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑把这个性质运用到字符串匹配上来，也就是说，我们要构造某种特殊的字符串函数$F(A,B)$，满足$F(A,B)=0\Leftrightarrow A=B,F(A,B)\not=0\Leftrightarrow A\not=B$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会想到字符串哈希，但是当哈希出来的值域太大的时候，我们必须要通过取模等方式压缩哈希值，这样之后哈希值就没有可比较性了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运用上面的性质，你也可能会想到——  
$$F(A,B)=\sum_{i=0}^{n-1}(A_i-B_i)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是会正负抵消，有可能抵消之后就变成$0$了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没关系，符号的差异可以用平方或者绝对值来消除——  
$$F(a,b)=\sum_{i=0}^{n-1}|A_i-B_i|$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这个仅仅是判等的函数，如果将判等扩展到匹配上来，由于绝对值没有什么速算的方法，我们还是得每次暴力计算匹配。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换成平方看看——  
$$F(a,b)=\sum_{i=0}^{n-1}(A_i-B_i)^2$$  
$$\Rightarrow F(a,b)=\sum_{i=0}^{n-1}(A_i^2+B_i^2)-2\sum_{i=0}^{n-1}A_iB_i$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面两个都是常量，可以用前缀和的方法预处理。后面的部分看起来比较暴力，其实如果把$B$翻转过来变成$B'$，它就是——  
$$\sum_{i=0}^{n-1}A_iB_{n-1-i}'$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这样经典的套路，它就变成了$FFT/NTT$可以解决的卷积问题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我们就可以$O(n\log_2n)$解决字符串匹配的问题！  
### 本题
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说实话，上面的方法用在常规字符串匹配的问题上真的很......没用......  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~没打上删除线的原因是~~它是事实!  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是它的优点就是，它可以拓展到这道题上面来，而常规的字符串匹配算法却不行。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑将这道题里面的特殊的通配符就给一个特殊的值，比如......什么好呢......$0$吧。在我们的$F$中，$0$就代表匹配上了！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后设计一下函数，可以发现，此时$A_i$和$B_i$匹配上有三种情况：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.A_i$为通配符。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2.B_i$为通配符。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$3.A_i=B_i$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到这两个相等就应该返回$0$，并且三个条件之间是**逻辑或**的关系，所以对于两个字符的比较方式应该是——  
$$(A_i-B_i)^2\times A_i\times B_i$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后$\sum$包起来，表示**逻辑与**的关系：  
$$F(A,B)=\sum_{i=0}^{n-1}(A_i-B_i)^2\times A_i\times B_i$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大力拆开：  
$$F(A,B)=\sum_{i=0}^{n-1}A_i^3B_i-2\sum_{i=0}^{n-1}A_i^2B_i^2-\sum_{i=0}^{n-1}A_iB_i^3$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后熟练地翻转过来：  
$$F(A,B)=\sum_{i=0}^{n-1}A_i^3B_{n-i-1}'-2\sum_{i=0}^{n-1}A_i^2(B_{n-i-1}')^2+\sum_{i=0}^{n-1}A_i(B_{n-i-1}')^3$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后它就变成了$FFT/NTT$的问题。做六次$FFT$和一次反向的$FFT$。时间是$O(n\log_2n)$。  
### 小结
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想自己想出这个方法......说实话还真得开下脑洞。~~也有可能是我太菜了~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且，这个也应该算是一个$FFT/NTT$的奇妙的应用。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要点大致有——  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.$构造匹配函数，一般用$0$来表示匹配上了，非$0$表示匹配失败。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2.$用乘法$'\times'$表示**逻辑或**，用加法$'+'$表示**逻辑与**。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$3.$运用平方等方法消除正负数影响。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$4.$运用翻转等操作将计算的式子换成卷积的形式方便$FFT/NTT$计算。  
# 代码
```cpp
#include <cmath>
#include <cstdio>

const double PI = acos( -1 ), eps = 0.1;
//误差特别大，如果代码是对的但是一直在WA，可以尝试调整eps
const int MAXN = 6e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

template<typename _T>
_T ABS( const _T a )
{
	return a < 0 ? -a : a;
}

typedef struct complex
{
	double x, y;
	complex() { x = y = 0; }
	complex( const double X, const double Y = 0 ) { x = X, y = Y; }
	complex operator + ( const complex & b ) const { return complex( x + b.x, y + b.y ); }
	complex operator - ( const complex & b ) const { return complex( x - b.x, y - b.y ); }
	complex operator * ( const complex & b ) const { return complex( x * b.x - y * b.y, x * b.y + y * b.x ); }
	complex operator / ( const double & b ) const { return complex( x / b, y / b ); }
	void operator += ( const complex & b ) { *this = *this + b; }
	void operator -= ( const complex & b ) { *this = *this - b; }
	void operator *= ( const complex & b ) { *this = *this * b; }
	void operator /= ( const double & b ) { *this = *this / b; }
}comp;

comp A[MAXN << 1], B[MAXN << 1], C[MAXN << 1];
double val[MAXN], As[MAXN], Bs[MAXN];
char S1[MAXN], S2[MAXN];
int N, M;

double sqr( const double x ) { return x * x; }
bool equal( const double x, const double y = 0 ) { return ABS( x - y ) <= eps; }
double trans( const char c ) { return c == '*' ? 0 : c - 'a' + 1; }
double getSum( const int l, const int r ) { return l == 0 ? As[r] : As[r] - As[l - 1]; }
double cube( const double x ) { return x * x * x; }

void FFT( comp *coe, int len, int type )
{
	int lg2 = log2( len );
	for( int i = 0, rev ; i < len ; i ++ )
	{
		rev = 0;
		for( int j = 0 ; j < lg2 ; j ++ ) rev |= ( ( i >> j ) & 1 ) << ( lg2 - j - 1 );
		if( rev < i ) swapp( coe[rev], coe[i] );
	}
	comp wp, w, wo, we;
	for( int s = 2, p ; s <= len ; s <<= 1 )
	{
		p = s >> 1, wp = comp( cos( type * PI / p ), sin( type * PI / p ) );
		for( int i = 0 ; i < len ; i += s )
		{
			w = comp( 1, 0 );
			for( int j = 0 ; j < p ; j ++, w *= wp )
			{
				we = coe[i + j], wo = coe[i + j + p];
				coe[i + j] = we + wo * w;
				coe[i + j + p] = we - wo * w; 
			}
		}
	}
	if( ~ type ) return ;
	for( int i = 0 ; i <= len ; i ++ ) coe[i] /= len;
}

int main()
{
	read( N ), read( M ); N --, M --;
	scanf( "%s%s", S1, S2 );
	int l = 1 << int( int( ceil( log2( N + M ) ) ) ), cnt = 0;
	if( l == N + M ) l <<= 1;
	for( int i = 0 ; i <= N ; i ++ ) A[i] = cube( trans( S1[i] ) );
	for( int i = 0 ; i <= M ; i ++ ) B[i] = trans( S2[M - i] );
	FFT( A, l, 1 ), FFT( B, l, 1 );
	for( int i = 0 ; i <= l ; i ++ ) C[i] += A[i] * B[i];
	for( int i = 0 ; i <= l ; i ++ ) A[i] = B[i] = 0;
	for( int i = 0 ; i <= N ; i ++ ) A[i] = sqr( trans( S1[i] ) );
	for( int i = 0 ; i <= M ; i ++ ) B[i] = sqr( trans( S2[M - i] ) );
	FFT( A, l, 1 ), FFT( B, l, 1 );
	for( int i = 0 ; i <= l ; i ++ ) C[i] -= A[i] * B[i] * comp( 2 );
	for( int i = 0 ; i <= l ; i ++ ) A[i] = B[i] = 0;
	for( int i = 0 ; i <= N ; i ++ ) A[i] = trans( S1[i] );
	for( int i = 0 ; i <= M ; i ++ ) B[i] = cube( trans( S2[M - i] ) );
	FFT( A, l, 1 ), FFT( B, l, 1 );
	for( int i = 0 ; i <= l ; i ++ ) C[i] += A[i] * B[i];
	FFT( C, l, -1 );	
	for( int i = N ; i <= M ; i ++ ) cnt += equal( C[i].x );
	write( cnt ), putchar( '\n' );
	for( int i = M ; i >= N ; i -- ) if( equal( C[i].x ) ) write( M - i + 1 ), putchar( ' ' );
	puts( "" );
	return 0;
}
```

---

## 作者：Orion545 (赞：9)

# 广告

### [蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8832320.html)

# 正文

我看到这道题，第一想法是跑魔改过的KMP，然后很快发现不可行

于是想换个角度思考

其实，本题最大的问题就在于通配符的存在：它可以匹配任意一个字符

那么我们考虑一个办法：令两个字符匹配成为“抵消”，那么数学上的抵消会让我们想到什么呢？

没错，0

我们令所有的通配符为0，让匹配变成两个字符相乘，那么乘出来零就“抵消”了

想到这里以后，一个非常自然的想法就是令所有的普通字符匹配也变成乘积为0的，但是这显然不可行，因为这个方法一定会导致不同字符乘起来也等于0（我们有26个字幕呢！！！）

现在这个问题就比较烦了，但是我们依然不能放弃希望

考虑0，除了作为非正非负数以外，它还有什么特性？

### 没错，零是一个整数

整数？整数......我们只要让匹配成功的字符，乘起来等于整数不就好了！

接下来的思路就比较清晰了：我们令第i种字母，在文本串（B串）中的值为i，在模式串（A串）中为$\frac 1i$，这样如果A串和B串某一位匹配，就会得到一个1

但是还有一个问题：如果遇到$4\ast\frac 12=2$这样的怎么办？

好说，我们令i等于10000+i就好了

我们把模式串A翻过来，然后让它与B串做FFT乘法

得到的第i位如果是整数，那么意味着从第i-n位开始的、长度为n的B串子串能与A匹配(n<i<=n*\2)

精度记得卡一卡，卡到1e-6就差不多了

貌似有的OJ只需要加1000？反正这是个玄学做法，总是能卡掉的吧......

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
struct complex{
    double x,y;
    complex(double xx=0,double yy=0){x=xx;y=yy;}
    complex operator +(const complex &b){return complex(x+b.x,y+b.y);}
    complex operator -(const complex &b){return complex(x-b.x,y-b.y);}
    complex operator *(const complex &b){return complex(x*b.x-y*b.y,x*b.y+y*b.x);}
}A[2000010],B[2000010];
const double pi=acos(-1.0);
int n,m,limit=1,cnt=0,r[2000010];
void fft(complex *a,double type){
    int i,j,k,mid;complex x,y,w,wn;
    for(i=0;i<limit;i++) if(i<r[i]) swap(a[i],a[r[i]]);
    for(mid=1;mid<limit;mid<<=1){
        wn=complex(cos(pi/mid),type*sin(pi/mid));
        for(j=0;j<limit;j+=(mid<<1)){
            w=complex(1,0);
            for(k=0;k<mid;k++,w=w*wn){
                x=a[j+k];y=w*a[j+k+mid];
                a[j+k]=x+y;a[j+k+mid]=x-y;
            }
        }
    }
}
vector<int>ans;
char s[300010];
int main(){
    m=read();n=read();int i,tmp;
    scanf("%s",s);
    for(i=0;i<m;i++){
        if(s[i]=='*') B[m-i].x=0;
        else B[m-i].x=(1.0/(10001.0+double(s[i]-'a')));
    }
    scanf("%s",s);
    for(i=0;i<n;i++){
        if(s[i]=='*') A[i+1].x=0;
        else A[i+1].x=(10001.0+double(s[i]-'a'));
    }
    while(limit<=(n+m)) limit<<=1,cnt++;
    for(i=0;i<limit;i++) r[i]=((r[i>>1]>>1)|((i&1)<<(cnt-1)));
    fft(A,1);fft(B,1);
    for(i=0;i<=limit;i++) A[i]=A[i]*B[i];
    fft(A,-1);
    for(i=m+1;i<=n+1;i++){
        A[i].x/=(double)limit;tmp=(int)(A[i].x+0.5);
        if(abs(A[i].x-(double(tmp)))<=1e-6) ans.push_back(i-m);
    }
    printf("%d\n",ans.size());
    for(i=0;i<ans.size();i++) printf("%d ",ans[i]);
}
```

---

## 作者：qiyue7 (赞：9)

### Shift-or字符串匹配
这个经典的通配符问题可以直接转化为朴素的非确定性多模式匹配问题，那么就可以用Shift-or算法求解。Shift-or算法是位并行算法，位并行利用了计算机机器字位运算的内在并行性，可以把多个值装入同一个长度为w的机器字内，然后只需一次运算就能更新所有值。利用位并行，一个算法所执行的运算次数最多能减少到原来的1/W，这里W是机器字的位数。我们先预处理出模板串的每个字符出现在的位置，0表示已经出现，1表示未出现，然后再出现*的地方默认26个字母全部出现，在读入匹配串时每一轮都目前已保留的状态的bitset取或，当且仅当已经匹配的长度为模板串长度时答案++，复杂度O（n^2/机器字位数），洛谷似乎是64位机器字，那么复杂度30w*30w/64=1.4^10次位运算，根据换算1Ghz的cpu1秒1^10的位运算处理能力，给6s的时限随便跑跑就过了。

```
#include <bits/stdc++.h>
using namespace std;
bitset<300005> part[26],cur;
list<int> ans2;
int main()
{
	ios::sync_with_stdio(false);
	int a, b;
	cin >> a >> b;
	string c, d;
	cin >> c >> d;
	cur.set();
	for (int i = 0; i < 26; ++i)
		part[i].set();
	for (int i = 0; i < a; ++i)
	{
		if (c[i] != '*')
			part[c[i] - 'a'].reset(i);
		else
			for (int j = 0; j < 26; ++j)
				part[j].reset(i);
	}
	int ans = 0;
	for (int i = 0; i < b; ++i)
	{
		if (d[i] != '*')
			cur = cur << 1 | part[d[i] - 'a'];
		else
			cur = cur << 1;
		if (cur[a-1] == 0)
		{
			ans++;
			ans2.push_back(i-a+2);
		}
	}
	cout << ans << '\n';
	if (ans > 0)
		for (auto &s : ans2)
			cout<<s<<" ";
	return 0;
}
```





---

## 作者：VenusM1nT (赞：7)

$\textbf{FFT}$.  
这题……恶心死我了（  
NTT 又挂，FFT 又挂，哭死  

---
我们定义两个字符串 $S,T$ 的“距离”为：
$$d(S,T)=\sum_{i=1}^{n-1}(S_i-T_i)^2\times S_i\times T_i$$
那么 $T$ 中以 $i$ 结尾的串与 $S$ 能够匹配的条件为：
$$d(S,T_{i-m+1,i})=0$$
设这个东西为 $f_i$，可以得到关于 $f_i$ 的表达式：
$$f_i=\sum_{j=0}^i(S_j-T_{i-j})^2\times S_j\times T_{i-j}\quad\quad\quad\quad\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $$
$$=\sum_{j=0}^iS_j^3\times T_{i-j}-2\times\sum_{j=0}^iS_j^2T_{i-j}^2+\sum_{j=0}^iS_j\times T_{i-j}^3$$
那么我们就可以做三次 $\textbf{FFT}$ 来求出上面这三项的和，即全部的 $f_i$，最后逐个判断是否为 $0$ 就可以了。  
（精度损失挺严重的，qaq）
```cpp
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define MAXN 2000005
#define reg register
#define inl inline
#define db double
#define eps 1e-6
using namespace std;
const int Mod=998244353;
const db Pi=acos(-1.0);
struct Complex
{
	db x,y;
	friend Complex operator + (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x+b.x,a.y+b.y});
	}
	friend Complex operator - (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x-b.x,a.y-b.y});
	}
	friend Complex operator * (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x});
	}
	friend Complex operator * (const Complex &a,const db &val)
	{
		return ((Complex){a.x*val,a.y*val});
	}
}f[MAXN],g[MAXN],p[MAXN];
int n,m,lim=1,maxn,rev[MAXN],a[MAXN],b[MAXN];
char S[MAXN],T[MAXN];
bool used[MAXN];
vector <int> v;
inl void FFT(reg Complex *A,reg int opt)
{
	for(reg int i=0;i<lim;i++) if(i<rev[i]) swap(A[i],A[rev[i]]);
	for(reg int mid=1;mid<lim;mid<<=1)
	{
		reg Complex Wn=((Complex){cos(Pi/(db)mid),(db)opt*sin(Pi/(db)mid)});
		for(reg int j=0;j<lim;j+=(mid<<1))
		{
			reg Complex W=((Complex){1,0});
			for(reg int k=0;k<mid;k++,W=W*Wn)
			{
				reg Complex x=A[j+k],y=W*A[j+k+mid];
				A[j+k]=x+y;
				A[j+k+mid]=x-y;
			}
		}
	}
}
int main()
{
	scanf("%d %d",&m,&n);
	scanf("%s",T+1);
	scanf("%s",S+1);
	for(reg int i=1;i<=m;i++) if(T[i]!='*') a[i-1]=T[i]-'a'+1;
	for(reg int i=1;i<=n;i++) if(S[i]!='*') b[i-1]=S[i]-'a'+1;
	while(lim<=(n+m))
	{
		lim<<=1;
		maxn++;
	}
	for(reg int i=0;i<lim;i++) rev[i]=((rev[i>>1]>>1)|((i&1)<<maxn-1));
	reverse(a,a+m);
	for(reg int i=0;i<m;i++) f[i]=((Complex){a[i]*a[i]*a[i],0});
	for(reg int i=0;i<n;i++) g[i]=((Complex){b[i],0});
	FFT(f,1);FFT(g,1);
	for(reg int i=0;i<lim;i++) p[i]=p[i]+f[i]*g[i];
	for(reg int i=0;i<lim;i++) f[i]=g[i]=((Complex){0,0});
	for(reg int i=0;i<m;i++) f[i]=((Complex){a[i]*a[i],0});
	for(reg int i=0;i<n;i++) g[i]=((Complex){b[i]*b[i],0});
	FFT(f,1);FFT(g,1);
	for(reg int i=0;i<lim;i++) p[i]=p[i]-f[i]*g[i]*2.0;
	for(reg int i=0;i<lim;i++) f[i]=g[i]=((Complex){0,0});
	for(reg int i=0;i<m;i++) f[i]=((Complex){a[i],0});
	for(reg int i=0;i<n;i++) g[i]=((Complex){b[i]*b[i]*b[i],0});
	FFT(f,1);FFT(g,1);
	for(reg int i=0;i<lim;i++) p[i]=p[i]+f[i]*g[i];
	FFT(p,-1);
	for(reg int i=m-1;i<n;i++) if(!(int)(p[i].x/(db)lim+0.5)) v.push_back(i-m+2);
	reg int Ans=v.size();
	printf("%d\n",Ans);
	for(reg int i=0;i<Ans;i++) printf("%d ",v[i]);
	return 0;
}
```

---

## 作者：santongding (赞：7)

好像没有题解。。。那我就说一说我的玄学做法

比较容易就能得出，如果将模板串翻转位置之后，不足的位置补零再与要匹配的串做fft，那么得出的多项式中F[ i ]是所有下标之和为i的两个字符的乘积，而由于模板串后边的位置被补零，所以能够找到n-m个F[i]表示所有匹配情况；（当然不必要真的补零，我大概觉着会好想一些吧。。。） 

接下来考虑怎么判断每个情况是否合法，将模板串中26个字母都设为一个数，再将匹配串中所有字母设为倒数，如果有“*”号那么设为0，那么得出的每个表示匹配情况的值如果是个整数，就是合法的，如果不是就不合法； 

当然这样很有可能有精度问题，所以得给每个字符一开始的值加一个数，似乎加个1000左右的数就可以，加个100以内的可能会被卡； 

至于判断是否是整数时，实测1e-6也是可以过； 

总之这个做法比较玄学，但唯一的好处是只需要做一次fft，跑得比较快

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<cstring>
#include<cstdio>
#include<cmath>
#define LL long long
#define random(a,b) (a+rand()%(b-a+1))
#define pi 3.141592653589793238460643383279
const int maxn=1048577;
int n,m;
int nn=1,tk=0;
int a[maxn],b[maxn],c[maxn];
double abs(double x)
{
    if(x<0)return -x;
    return x;
} 
struct com
{
    double r,i;
    com(){
        r=i=0.0;
    }
    com(double x,double y){
        r=x,i=y;    
    } 
    com operator +(const com &o)const{
        return com(r+o.r,i+o.i);
    }
    com operator -(const com &o)const{
        return com(r-o.r,i-o.i);
    }
    com operator *(const com &o)const{
        return com(r*o.r-i*o.i,r*o.i+i*o.r);
    }
    com operator /(const double &o)const{
        return com(r/o,i/o);
    }
}c1[maxn],c2[maxn], omega[maxn];
void read(register int *t,int len)
{
    char s;
    for(register int i=0;i<len;i++)
    {
        s=getchar();
        while(!isdigit(s))s=getchar();
        t[i]=s-'0';
    }
}
void swap(com &x,com &y)
{
    com z=x;
    x=y;
    y=z;
}
void FFT(com *p)
{
    for(register int i=0,j=0; i<nn; i++)
    {
        if(i>j)swap(p[i],p[j]);
        for(register int l=nn>>1; (j^=l)<l; l>>=1);
    }
    for(register int l=2;l<=nn;l<<=1)
    {
        int mid=l/2;
        for(com *t=p;t!=p+nn;t+=l)
        for(register int i=0;i<mid;i++)
        {
            com tp=omega[nn/l*i] * t[i+mid];
            t[i+mid]=t[i]-tp;
            t[i]=t[i]+ tp;
        }
    }
}
com f[maxn],g[maxn];
int suma=0,sumb=0;
char sb[maxn];
int ans[maxn];
int anstot=0;
int main()
{
    scanf("%d%d",&m,&n);
    scanf("%s",sb);
    for(int i=0;i<m;i++)
    {
        if(sb[i]=='*')f[m-1-i].r=0.0,sumb++;
        else f[m-1-i].r=(double)(sb[i]-'a'+1000);
    }
    scanf("%s",sb);
    for(int i=0;i<n;i++)
    {
        if(sb[i]=='*')g[i].r=0.0;
        else g[i].r=1.0/(double)(sb[i]-'a'+1000);   
    } 
    while(nn<m+n-1)nn<<=1;
    for(register int i=0;i<nn;i++)omega[i]=com(std::cos(2.0*pi/(double)nn*(double)(i)),std::sin(2.0*pi/(double)nn*(double)i));
    FFT(f);
    FFT(g);
    for(register int i=0;i<nn;i++)
    {
        omega[i].i*=-1;
        f[i]=f[i]*g[i];
    }
    FFT(f);
    for(register int i=0;i<nn;i++)
        f[i].r/=(double)nn;
    for(int i=m-1;i<n;i++)
    {
        int tmp=(int)(f[i].r+0.5);//四舍五入
        if(abs(f[i].r-(double)tmp)<=1e-6)ans[++anstot]=i-m+2;
    }
    printf("%d\n",anstot);
    for(int i=1;i<=anstot;i++)printf("%d ",ans[i]); 
        return 0;
} 
```

正解好像得拆开证一波。。。感觉我这种做法很容易被卡啊orz

UPD：本来没开o2在洛谷被前边几个开了o2的碾压，遂开一波o2强行rk1,毕竟我fft只需要做一次，手残大常数也无所谓orz

---

## 作者：devout (赞：6)

开始的时候一直在考虑魔改版kmp

后来发现不太行

结果发现是道贩毒题

我们考虑把所有`a-z`的替换成`1-26`,把`*`换成`0`

那么如果第$i$位可以匹配，意味着

$$a_ib_i(a_i-b_i)=0$$

也就是要么$a_i,b_i$里面至少有一个`*`，或者$a_ib_i$相同

我们考虑把$A$取反，表示成多项式$A(x)$，把$B$表示成多项式$B(x)$

那么我们只需要对于$A(x)$和$B(x)$求卷积，最后判断有几个是$0$就行了

但是我们还需要对于上面那个式子进行一个简单的修改

我们发现，当$a_i<b_i$的时候，最上面那个式子可能是负数

有可能一正一负最后又变回$0$了，所以我们把式子转化成

$$a_ib_i(a_i-b_i)^2=0$$

把这个东西展开，那么最后我们需要求的多项式就是

$$F(x)=A^3(x)B(x)-2A^2(x)B^2(x)+A(x)B^3(x)$$

我们使用$\text{FFT/NTT}$来进行优化就可以了

但是我$\text{FFT}$不知道为啥吸氧还T一片，所以写的$\text{NTT}$

因为代码上的一个小细节调了很久

我们在枚举做的长度的时候，$i$应枚举到$<limit$而不是$\leq$要不然会RE

但是之前好像一直这么写没有锅掉...

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=(1<<20)+5;
const double pi=acos(-1.0);
const double eps=1;
const int g=3,mod=998244353;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int A[N],B[N];
int pos[N];
int tot,out[N];
char s[N],t[N];
int a[N],b[N],c[N],ans[N];

int Qpow(int base,int ind){
	int res=1;
	while(ind){
		if(ind&1)res=1ll*res*base%mod;
		base=1ll*base*base%mod;
		ind>>=1;
	}
	return res;
}

void ntt(int limit,int *a,int opt){
	for(int i=0;i<limit;i++)c[i]=a[pos[i]];
	for(int i=0;i<limit;i++)a[i]=c[i];
	for(int i=1;i<limit;i<<=1){
		int len=i<<1;
		int vec=Qpow(g,(mod-1)/len);
		if(opt==-1)vec=Qpow(vec,mod-2);
		for(int j=0;j<limit;j+=len)
			for(int k=0,omega=1;k<i;k++,omega=1ll*omega*vec%mod){
				int x=a[j+k],y=1ll*omega*a[j+k+i]%mod;
				c[j+k]=(x+y)%mod;
				c[j+k+i]=(x-y+mod)%mod;
			}
		for(int j=0;j<limit;j++)a[j]=c[j];
	}
	if(opt==-1){
		int inv=Qpow(limit,mod-2);
		for(int i=0;i<limit;i++)a[i]=1ll*a[i]*inv%mod;	
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",s);
	scanf("%s",t);
	reverse(s,s+n);
	for(int i=0;i<n;i++)A[i]=(s[i]=='*')?0:s[i]-'a'+1;
	for(int i=0;i<m;i++)B[i]=(t[i]=='*')?0:t[i]-'a'+1;

	int limit=1;
	while(limit<=n+m)limit<<=1;
	for(int i=1;i<limit;i<<=1)for(int j=0;j<i;j++)pos[i+j]=pos[j]+limit/i/2;

	for(int i=0;i<limit;i++)a[i]=A[i]*A[i]*A[i],b[i]=B[i];
	ntt(limit,a,1),ntt(limit,b,1);	
	for(int i=0;i<limit;i++)ans[i]=ans[i]+1ll*a[i]*b[i]%mod,ans[i]%=mod;

	for(int i=0;i<limit;i++)a[i]=A[i]*A[i],b[i]=B[i]*B[i];
	ntt(limit,a,1),ntt(limit,b,1);
	for(int i=0;i<limit;i++)ans[i]=ans[i]+1ll*(mod-2)*a[i]%mod*b[i]%mod,ans[i]%=mod;

	for(int i=0;i<limit;i++)a[i]=A[i],b[i]=B[i]*B[i]*B[i];
	ntt(limit,a,1),ntt(limit,b,1);
	for(int i=0;i<limit;i++)ans[i]=ans[i]+1ll*a[i]*b[i]%mod,ans[i]%=mod;

	ntt(limit,ans,-1);
	for(int i=n-1;i<m;i++)if(!ans[i])out[++tot]=i-n+2;
	printf("%d\n",tot);
	Rep(i,1,tot)printf("%d ",out[i]);
	puts("");
	return 0;
}
```


---

## 作者：tzc_wk (赞：5)

众所周知，字符串匹配有三种方式：

1. 哈希

2. KMP/Z
3. FFT

今天我们来聊一聊第三种方法。

先考虑这题不带通配符的版本，也就是最经典的字符串匹配。

考虑设 $C(x,y)$ 为字符 $x$ 与字符 $y$ 是否匹配，如果匹配返回 $0$，否则返回一个非零的值。

再设 $f_j$ 表示以 $s_j$ 开头的长度为 $|t|$ 的子串是否与 $t$ 匹配，如果匹配返回 $0$，否则返回一个非零的值。

那么 $f_j=\sum\limits_{i=1}^{|t|}C(s_{j+i-1},t_i)$

那么究竟取怎样的 $C(x,y)$ 才合适呢？

一个很 naive 的想法是设 $C(x,y)=x-y$，但这样很显然是错误的，因为这样会导致 ab 与 ba 匹配了。 

回忆起初一时讲过的一个东西：若 $a,b,c$ 为实数，$a^2+b^2+c^2=0$ 就意味着 $a=b=c=0$。

于是思路就来了，设 $C(x,y)=(x-y)^2$，这样只有当 $s_j-t_1=0,s_{j+1}-t_2=0,s_{j+2}-t_3=0,\dots,s_{j+|t|-1}-t_{|t|}=0$ 同时满足的时候 $f_j$ 才能等于 $0$，符合条件。

那么怎么求 $f_j$ 呢？

$f_j=\sum\limits_{i=1}^{|t|}(s_{j+i-1}-t_i)^2=\sum\limits_{i=1}^{|t|}s_{j+i-1}^2+t_i^2-2s_{j+i-1}t_i$

左边两个平方项只与 $s$ 或者只与 $t$ 有关，前缀和预处理后显然可以 $\mathcal O(1)$ 地求。

而后面的交叉项又是喜闻乐见的 $\sum\limits_{x-y=i}f_xg_y$ 的形式，把 $t$（或 $s$）翻转一下预处理个卷积也可以 $\mathcal O(1)$ 求。

时间复杂度 $\mathcal O(n\log n)$。

你可能会说，FFT 字符串匹配好菜啊，时间复杂度甚至不如 hash/KMP，常数还巨大，根本没有推广的必要。

如果你这样认为那你就大错特错了，碰到像 P4173 这类含通配符的字符串就只能用 FFT 了。记得去年 3 月某场 Atcoder 的 E 是含通配符的字符串匹配，结果还想着用 Z 乱搞，搞了半天发现 Z 是假的。

为什么？~~首先含通配符的 hash 肯定搞不定，否则请给出 hash 函数怎么求。。。~~

如果你要用 KMP/Z，那么你都要用到字符串匹配的一条性质：如果字符串 $a$ 与 $b$ 匹配，$a$ 与 $c$ 匹配，那么 $b$ 与 $c$ 一定匹配。

但这个性质换到含通配符的字符串匹配就不成立了。举个很简单的栗子，$a="*",b="a",c="b"$。所以含通配符的字符串匹配也不能 KMP/Z。

那就只能 FFT 了呗。

还是设 $C(x,y)$ 为字符 $x$ 与字符 $y$ 是否匹配，如果匹配返回 $0$，否则返回一个非零的值；$f_j$ 表示以 $s_j$ 开头的长度为 $|t|$ 的子串是否与 $t$ 匹配，如果匹配返回 $0$，否则返回一个非零的值。

按照套路还是有 $f_j=\sum\limits_{i=1}^{|t|}C(s_{j+i-1},t_i)$。

那么这下子 $C(x,y)$ 该设为什么东西呢？

考虑在什么情况下字符 $x$ 与 $y$ 能匹配，要么 $x$ 为 $0$，要么 $y$ 为 $0$，要么 $x=y$。

还是联想到初一数学，若 $a,b,c$ 为实数，$abc=0$ 就意味着 $a=0\ \or\ b=0\ \or c=0$。

于是思路就有了，给每个字符赋一个权值，通配符的权值为 $0$，$a$ 的权值为 $1$，$b$ 的权值为 $2$，以此类推。

设 $X$ 为 $x$ 的权值，$Y$ 为 $y$ 的权值，那么 $C(x,y)=XY(X-Y)^2$。这样 $C(x,y)=0$ 当且仅当 $x$ 为通配符或 $y$ 为通配符或 $x=y$。

 最后就是求 $f_j$ 的问题了，设 $a_i$ 为 $s_i$ 的权值，$b_i$ 为 $t_i$ 的权值，还是将平方项拆开，$f_j=\sum\limits_{i=1}^{|t|}a_{j+i-1}b_i(a_{j+i-1}-b_i)^2=\sum\limits_{i=1}^{|t|}a_{j+i-1}^3b_i+a_{j+i-1}b_i^3-2a_{j+i-1}^2b_i^2$

发现三项都是 $\sum\limits_{x-y=i}f_xg_y$ 的形式，求三遍卷积就 ok 了。

不过似乎常数上天了啊……

感觉这题时限 1s 太紧了，把常熟巨大的 FFT 换成 NTT 还是 T 了 3 个点。。。

代码仅供参考：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MAXN=3e5;
const int MAXP=1<<20;
const int pr=5;
const int MOD=924844033;
int get(char c){return (c=='*')?0:(c^96);}
int n,m;
char s[MAXN+5],t[MAXN+5];
int a[MAXP+5],b[MAXP+5],c[MAXP+5];
int qpow(int x,int e){int ret=1;for(;e;x=1ll*x*x%MOD,e>>=1) if(e&1) ret=1ll*ret*x%MOD;return ret;}
int LEN=1,LOG=0,ipr,rev[MAXP+5],inv[MAXP+5],prs[MAXP+5][2];
int f[MAXN+5];
void NTT(int *a,int len,int type){
	int lg=log2(len);
	for(int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(lg-1));
	for(int i=0;i<len;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int i=2;i<=len;i<<=1){
		int W=prs[i][type<0];
		for(int j=0;j<len;j+=i){
			int w=1;
			for(int k=0;k<(i>>1);k++,w=1ll*w*W%MOD){
				int X=a[j+k],Y=1ll*a[(i>>1)+j+k]*w%MOD;
				a[j+k]=(X+Y)%MOD;a[(i>>1)+j+k]=(X-Y+MOD)%MOD;
			}
		}
	}
	if(type==-1) for(int i=0;i<len;i++) a[i]=1ll*a[i]*inv[len]%MOD;
}
int main(){
	scanf("%d%d%s%s",&m,&n,s+1,t+1);ipr=qpow(pr,MOD-2);
	while(LEN<=(n+m)) LEN<<=1,LOG++;
	for(int i=1;i<=LEN;i<<=1){
		inv[i]=qpow(i,MOD-2);
		prs[i][0]=qpow(pr,(MOD-1)/i);
		prs[i][1]=qpow(ipr,(MOD-1)/i);
	}
	for(int i=0;i<LEN;i++) a[i]=b[i]=0;
	for(int i=1;i<=m;i++) a[i]=get(s[i])*get(s[i])*get(s[i]);
	for(int i=0;i<n;i++) b[i]=get(t[n-i]);
	NTT(a,LEN,1);NTT(b,LEN,1);
	for(int i=0;i<LEN;i++) c[i]=1ll*a[i]*b[i]%MOD;NTT(c,LEN,-1);
	for(int i=1;i<=n-m+1;i++) f[i]=c[n-i+1];
	
	for(int i=0;i<LEN;i++) a[i]=b[i]=0;
	for(int i=1;i<=m;i++) a[i]=get(s[i])*get(s[i]);
	for(int i=0;i<n;i++) b[i]=get(t[n-i])*get(t[n-i]);
	NTT(a,LEN,1);NTT(b,LEN,1);
	for(int i=0;i<LEN;i++) c[i]=1ll*a[i]*b[i]%MOD;NTT(c,LEN,-1);
	for(int i=1;i<=n-m+1;i++) f[i]=(f[i]-2ll*c[n-i+1]%MOD+MOD)%MOD;
	
	for(int i=0;i<LEN;i++) a[i]=b[i]=0;
	for(int i=1;i<=m;i++) a[i]=get(s[i]);
	for(int i=0;i<n;i++) b[i]=get(t[n-i])*get(t[n-i])*get(t[n-i]);
	NTT(a,LEN,1);NTT(b,LEN,1);
	for(int i=0;i<LEN;i++) c[i]=1ll*a[i]*b[i]%MOD;NTT(c,LEN,-1);
	for(int i=1;i<=n-m+1;i++) f[i]=(f[i]+c[n-i+1])%MOD;
	
//	for(int i=1;i<=n-m+1;i++) printf("%d\n",f[i]);
	int tot=0;
	for(int i=1;i<=n-m+1;i++) if(f[i]==0) tot++;
	printf("%d\n",tot);
	for(int i=1;i<=n-m+1;i++) if(!f[i]) printf("%d ",i);
	return 0;
}
```

---

## 作者：ysy20021208 (赞：3)

# 残缺的字符串

道题很难想到与字符串没有关系，我们现在考虑将字符串转化为多项式，我们现在定义多项式$A[i]$表示字符串$A$的第$i$位为什么字符，我们定义下述映射方式：$A\sim Z\rightarrow 1 \sim 26$，$*\rightarrow 0$。我们这时候再定义一个多项式$T$，其中$T[i]$表示在$B$串中$A$的第一位对应$B$的第$i$为的匹配结果，$T[i]=\sum \limits _{j=0}^{j\lt len_A} (B[i+j]-A[j])^2\times B[i+j] \times A[j]$。我们发现如果匹配成功了，这个结果一定等于零。我们看上述式子$B$和$A$相乘，其角标的差一定，我们这时可以将$B$串翻转，这样我们就可以将其化成卷积。我们将这个式子拆开：
$$
T=B^3\times A+A^3\times B -2\times A^2\times B^2
$$
​	我们将其用$fft$加速一下，最后只需要判断一下就好了。

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
using namespace std;
#define N 1200010
int len,n,m,s[N],t[N]; char str1[N],str2[N];
double pi=acos(-1); int sta[N],top;
struct Cp
{
    double x,y;
    Cp(double x_=0,double y_=0) {x=x_,y=y_;}
    Cp operator + (const Cp &a) const {return Cp(x+a.x,y+a.y);}
    Cp operator - (const Cp &a) const {return Cp(x-a.x,y-a.y);}
    Cp operator * (const Cp &a) const {return Cp(x*a.x-y*a.y,x*a.y+y*a.x);}
}A[N],B[N],C[N],D[N],E[N],F[N];
void fft(Cp *a,int len,int flag)
{
    Cp tmp,w,wn;register int t;
    for(register int i=0,k=0;i<len;i++)
        {if(i>k) swap(a[i],a[k]);for(register int j=len>>1;(k^=j)<j;j>>=1);}
    for(register int k=2;k<=len;k<<=1)
    {
        wn=Cp(cos(2*pi*flag/k),sin(2*pi*flag/k)),t=k>>1;
        for(register int i=0;i<len;i+=k)
        {
            w=Cp(1,0);
            for(int j=i;j<i+t;j++)
                tmp=a[j+t]*w,a[j+t]=a[j]-tmp,a[j]=a[j]+tmp,w=w*wn;
        }
    }if(flag==-1) for(int i=0;i<len;i++) a[i].x/=len;
}
int main()
{
    scanf("%d%d%s%s",&m,&n,str2,str1),len=1;
    while(len<(n+m)) len<<=1;
    for(int i=0;i<n;i++) s[i]=(str1[i]=='*')?0:(str1[i]-'a'+1);
    for(int i=0;i<m;i++) t[m-i-1]=(str2[i]=='*')?0:(str2[i]-'a'+1);
    for(int i=0;i<n;i++) A[i].x=s[i]*s[i]*s[i],B[i].x=-2*s[i]*s[i],C[i].x=s[i];
    for(int i=0;i<m;i++) D[i].x=t[i],E[i].x=t[i]*t[i],F[i].x=t[i]*t[i]*t[i];
    fft(A,len,1),fft(B,len,1),fft(C,len,1),fft(D,len,1),fft(E,len,1),fft(F,len,1);
    for(int i=0;i<len;i++) A[i]=A[i]*D[i]+B[i]*E[i]+C[i]*F[i];
    fft(A,len,-1);
    for(int i=0;i<n-m+1;i++) if(!(int)(A[i+m-1].x+0.1)) sta[++top]=i+1;
    printf("%d\n",top);
    for(int i=1;i<top;i++) printf("%d ",sta[i]);
    if(top) printf("%d",sta[top]);
}
```


---

## 作者：hwk0518 (赞：3)

最喜欢NTT这种常数小又没精度误差的算法了。

对每个字母分别考虑。设当前考虑的字符是op。

构造生成函数：

$FA_{op}=a_0x^0+...+a_{n}x^{n}$

$FB_{op}=b_0x^0+...+b_mx^n$

其中:

$a_i=1,A_i=op,'*'$

$a_i=0,otherwise$

$b_i=1,B_{m+1-i}=op$

$b_i=0,otherwise$

用NTT求出$FA_{op}$与$FB_{op}$的卷积$FC_{op}$。

设$FC=\sum_{i=a \to z}FC_{i}=c_0x^0+...+c_{n+m}x^{n+m}$

若$c_i=B$中不是*的字符个数，则i-m合法。

这里有个优化，若B中没有op,则$C_{op}=0$，所以只要对B中有的字母卷积即可。

最大测试点$800ms$不到。

代码：

```

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const int N=2e6+5;
const int mod=998244353;
const int sqr=3;
const int sqrinv=332748118;

int n,m,a[N],b[N],r[N];
int limit=1,lg,ans[N],vis[N];
char s[N],t[N];

void write(int x)
{
	if(!x) return;
	write(x/10),putchar(x%10+'0');
}

int F_p(int x,int y)
{
	int bas=x,ret=1;
	while(y)
	{
		if(y&1) ret=1LL*ret*bas%mod;
		bas=1LL*bas*bas%mod;
		y>>=1;
	}
	return ret;
}

int solve_complex(int x,int tp)
{
	if(~tp) return F_p(sqr,x);
	else return F_p(sqrinv,x);
}

void NTT(int *A,int tp)
{
	int i;
	for(i=0;i<limit;++i)
		if(i<r[i])
			swap(A[i],A[r[i]]);
	
	int len,j,k;
	for(len=1;len<limit;len<<=1)
	{
		int wn=solve_complex((mod-1)/(2*len),tp);
		for(j=0;j<limit;j+=len<<1)
		{
			int w=1;
			for(k=0;k<len;++k,w=1LL*w*wn%mod)
			{
				int x=A[j+k];
				int y=1LL*w*A[j+k+len]%mod;
				A[j+k]=x+y,A[j+k+len]=x-y;
				if(A[j+k]>=mod) A[j+k]-=mod;
				if(A[j+k+len]<0) A[j+k+len]+=mod; 
			}
		}
	}
}

void calc(char op)
{
	int i;
	for(i=1;i<=m;++i) b[i]=(t[m+1-i]==op);
	for(i=1;i<=n;++i) a[i]=((s[i]==op)|(s[i]=='*'));
	
	for(i=m+1;i<limit;++i) b[i]=0;
	for(i=n+1;i<limit;++i) a[i]=0;
	a[0]=b[0]=0;
	
	NTT(a,1),NTT(b,1);
	for(i=0;i<limit;++i) a[i]=1LL*a[i]*b[i]%mod;
	NTT(a,-1);
	
	int tt=F_p(limit,mod-2);
	for(i=0;i<limit;++i) ans[i]+=1LL*a[i]*tt%mod;
}

void init()
{
	int i,cnt=0,totans=0;
	scanf("%d%d",&m,&n);
	scanf("%s",t+1);
	scanf("%s",s+1);
	for(i=1;i<=m;++i) vis[t[i]]=1;
	
	while(limit<=n+m) limit<<=1,++lg;
	for(i=0;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<(lg-1));
	for(i='a';i<='z';++i) if(vis[i]) calc(i);
	for(i=1;i<=m;++i) if(t[i]!='*') ++cnt;
	
	for(i=m+1;i<=n+m;++i)
		if(ans[i]==cnt)
			++totans;
	
	write(totans),putchar('\n');
	for(i=m+1;i<=n+m;++i)
		if(ans[i]==cnt)
			write(i-m),putchar(' ');
	putchar('\n');
}

int main()
{
//	freopen("string.in","r",stdin);
//	freopen("string.out","w",stdout);
	init();
	return 0;
}

```

---

## 作者：gorokokoro (赞：2)

卡常卡了一晚上 $\text{qwq}$

跟 CF 的那个 Fuzzy Search 很相似，直接做 $26$ 次 $\text{FFT}$ 即可（逃

具体来说，设文本串对应的多项式为 $f$，模板串对应的多项式为 $g$ 。

每次选出 $1$ 种字符 $k$，将文本串对应字符 $k$ 的位置与 $*$ 的位置均设为 $1$，将模板串对应字符 $k$ 的位置设为 $1$，再将 $g$ 反转，与 $f$ 做卷积。

每次卷积之后把每个位置匹配的数量累加（下面是累加到 `o[]` 里），然后搞一通即可。

```cpp
for(i = s = 0;i < m;i ++)
    s += a[i] == '*';

for(i = t = 0;i < n;i ++)
    t += o[i] + s == m;
printf("%d\n", t);
for(i = 0;i < n;i ++)
    if(o[i] + s == m)
        printf("%d ", i + 1);
        ```

常数有点大，卡卡就好了

没做过 Fuzzy Search 的可以先去看看 myy 的论文


---

## 作者：Great_Influence (赞：2)

就是。。。NTT也能做。。。（虽然跑得慢的死）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}
inline void write(int x,char k)
{
	if(!x){putchar(48),putchar(k);return;}
	static int sta[20],tp;
	for(tp=0;x;x/=10)sta[++tp]=x%10;
	for(;tp;putchar(sta[tp--]+48));
	putchar(k);
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
#endif
}
const int MAXN=(1<<20)+7;
static int p[MAXN],b[MAXN],p2[MAXN],b2[MAXN],p3[MAXN],b3[MAXN],n,m,rev[MAXN],N,M;
static char A[MAXN],B[MAXN];
inline void init()
{
	read(m);read(n);N=n;M=m;
	scanf("%s%s",A,B);
	Rep(i,0,m-1)
	{
		p[m-i-1]=(A[i]=='*'?0:A[i]-'a'+1);
		p2[m-i-1]=p[m-i-1]*p[m-i-1];
		p3[m-i-1]=p2[m-i-1]*p[m-i-1];
	}
	Rep(i,0,n-1)
	{
		b[i]=(B[i]=='*'?0:B[i]-'a'+1);
		b2[i]=b[i]*b[i];
		b3[i]=b2[i]*b[i];
	}
	m=n;
	static int len;
	for(len=1,n=4;n<=m<<1;n<<=1)++len;
	Rep(i,1,n-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<len);
}
const int mod=998244353,g=3;
inline int power(int a,int b)
{
	static int sum;
	for(sum=1;b;b>>=1,a=1ll*a*a%mod)if(b&1)
		sum=1ll*a*sum%mod;
	return sum;
}
inline void NTT(int x[],int typ)
{
	Rep(i,1,n-1)if(i<rev[i])swap(x[i],x[rev[i]]);
	static int i,j,k,kk,t,w,wn;
	for(k=2;k<=n;k<<=1)
	{
		kk=k>>1;wn=power(g,(mod-1)/k);
		if(typ==-1)wn=power(wn,mod-2);
		for(i=0;i<n;i+=k)
		{
			w=1;
			for(j=0;j<kk;++j,w=1ll*w*wn%mod)
			{
				t=1ll*w*x[i+j+kk]%mod;
				x[i+j+kk]=x[i+j]-t+mod;
				if(x[i+j+kk]>=mod)x[i+j+kk]-=mod;
				x[i+j]+=t;if(x[i+j]>=mod)x[i+j]-=mod;
			}
		}
	}
	if(typ==-1)
	{
		static int inv=power(n,mod-2);
		Rep(i,0,n)x[i]=1ll*x[i]*inv%mod;
	}
}
inline void mul(int X[],int Y[],int Z[],int k)
{
	NTT(X,1);NTT(Y,1);
	Rep(i,0,n)
	{
		Z[i]+=1ll*X[i]*Y[i]%mod*k%mod;
		if(Z[i]>mod)Z[i]-=mod;
	}
}
static int ans[MAXN],tp,sum[MAXN];
inline void solve()
{
	mul(p3,b,sum,1);mul(p,b3,sum,1);mul(p2,b2,sum,mod-2);NTT(sum,-1);
	Rep(i,M-1,N-1)if(!sum[i])ans[++tp]=i-M+2;
	printf("%d\n",tp);
	Rep(i,1,tp)write(ans[i],' ');puts("");
}
int main()
{
    file();
	init();
	solve();
	return 0;
}
```

---

## 作者：Karry5307 (赞：1)

### 题意

给一个长度为 $n$ 的带通配符的模板串 $A$ 和一个长度为 $m$ 的带通配符的文本串 $B$，通配符可以替换任意字符，求 $B$ 中从哪些位置开始的前缀能够匹配 $A$。

$\texttt{Data Range:}1\leq n,m\leq 3\times 10^5$

### 题解

这题应该不卡常的啊……

FFT 字符串匹配。

先考虑无通配符的情况。

首先需要定义一个不相似度函数 $C(s,t)$，代表 $s$ 和 $t$ 的不相似度，同时定义完全匹配函数 $P(S,T)$ 代表 $S$ 和 $T$ 两个串是否完全匹配。考虑每个字符，可以得到：

$$P(S,T)=\sum\limits_{i=0}^{\vert S\vert}C(S_i,T_i)$$

不相似度函数 $C(s,t)$ 需要满足两个性质：

- $s=t$ 时 $C(s,t)=0$，$s\neq t$ 时 $C(s,t)\neq 0$

- 对于任意字符集内的 $s,t$，$C(s,t)$ 均非正或非负。

第一个性质显然，考虑证明第二个性质。使用反证法，那么一定存在四个字符 $a,b,c,d$ 满足 $a\neq b,c\neq d,C(a,b)=p>0,C(c,d)=q<0$，则构造如下两个字符串 $S,T$：$S$ 为 $-q$ 个 $a$ 后面接 $p$ 个 $c$，$T$ 为 $-q$ 个 $b$ 后面接 $p$ 个 $d$，则 $P(s,t)=-q\times p+p\times q=0$，然而 $S$ 和 $T$ 不相同，矛盾。

所以现在考虑找 $C(s,t)$。一个最方便的想法是设 $C(s,t)=s-t$（这里的减法为 ASCII 码做减法），然而并不满足性质 2，于是考虑取绝对值。绝对值没有很好的性质，所以要平方去掉，也即 $C(s,t)=(s-t)^2$。

这个时候考虑文本串中每一个位置与模板串的匹配情况，设 $f_i$ 为文本串从第 $i$ 个字符开始的完全匹配函数值，那么有（这里字符串下标从 $0$ 开始）：

$$f_i=\sum\limits_{j=0}^{n}C(A_j,B_{i+j})$$

拆掉不相似度函数会发现这个东西是个卷积的形式，卷一下就好了。

对于通配符来讲，通配符可以跟任意字符匹配，所以设通配符的 ASCII 为 $0$，则可以设 $C(s,t)=st(s-t)^2$ 即可，卷一下就做完了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef unsigned long long int ull;
const ll MAXN=1048577,MOD=998244353,G=3,INVG=332748118;
ll fd,c,r,cnt,limit;
ll rev[MAXN],omgs[MAXN],invo[MAXN],f[MAXN],g[MAXN],res[MAXN];
ll f2[MAXN],g2[MAXN],f3[MAXN],g3[MAXN];
char s[MAXN],t[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void setupOmg(ll cnt)
{
    ll limit=log2(cnt)-1,omg;
    omg=qpow(G,(MOD-1)>>(limit+1)),omgs[cnt>>1]=1;
    for(register int i=(cnt>>1|1);i!=cnt;i++)
    {
        omgs[i]=(li)omgs[i-1]*omg%MOD;
    }
    for(register int i=(cnt>>1)-1;i;i--)
    {
        omgs[i]=omgs[i<<1]; 
    }
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    static ull tcp[MAXN];
    register ll cur=0,x,shift=log2(cnt)-__builtin_ctz(cnt);
    if(inv==-1)
    {
        reverse(cp+1,cp+cnt);
    }
    for(register int i=0;i<cnt;i++)
    {
        tcp[rev[i]>>shift]=cp[i];
    }
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1;
        for(register int j=0;j<cnt;j+=i)
        {
            for(register int k=0;k<cur;k++)
            {
                x=tcp[j|k|cur]*omgs[k|cur]%MOD;
                tcp[j|k|cur]=tcp[j|k]+MOD-x,tcp[j|k]+=x;
            }
        }
    }
    for(register int i=0;i<cnt;i++)
    {
        cp[i]=tcp[i]%MOD;
    }
    if(inv==1)
    {
        return;
    }
    x=MOD-(MOD-1)/cnt;
    for(register int i=0;i<cnt;i++)
    {
        cp[i]=(li)cp[i]*x%MOD;
    }
}
int main()
{
	c=read(),fd=read(),scanf("%s%s",s,t),cnt=1,limit=-1;
	while(cnt<(fd<<1))
	{
		cnt<<=1,limit++;
	}
	for(register int i=0;i<cnt;i++)
	{
		rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
	}
	for(register int i=0;i<c;i++)
	{
		f[i]=isalpha(s[i])?s[i]-96:0;
		f2[i]=(li)f[i]*f[i],f3[i]=(li)f2[i]*f[i];
	}
	for(register int i=0;i<fd;i++)
	{
		g[i]=isalpha(t[fd-1-i])?t[fd-1-i]-96:0;
		g2[i]=(li)g[i]*g[i],g3[i]=(li)g2[i]*g[i];
	}
	setupOmg(cnt),NTT(f,cnt,1),NTT(g,cnt,1);
	NTT(f2,cnt,1),NTT(g2,cnt,1),NTT(f3,cnt,1),NTT(g3,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		res[i]=((li)f3[i]*g[i]+(li)f[i]*g3[i])%MOD;
		res[i]=(res[i]-(li)2*f2[i]*g2[i]%MOD+MOD)%MOD;
	}
	NTT(res,cnt,-1),reverse(res,res+fd);
	for(register int i=0;i<fd-c+1;i++)
	{
		r+=!res[i];
	}
	printf("%d\n",r);
	for(register int i=0;i<fd-c+1;i++)
	{
		!res[i]?printf("%d ",i+1):1;
	}
}
```

---

## 作者：Dispwnl (赞：1)

>11.29 修改了公式和链接

> 和$xMinh$讨论这题我发现我似乎$FFT$的式子都没搞懂……？

这题暴力能得$80$……就是最暴力的那种

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
using namespace std;
const int MAX=3e5+1;
int m,n;
int A[MAX];
string a,b;
int main()
{
	cin>>m>>n>>a>>b;
	int l1=a.length(),l2=b.length();
	for(int i=0;i<=l2-l1;++i)
	  {
	  	bool fl=1;
	  	int j=i,l=0;
	  	while(l<l1)
	  	if(a[l]==b[j]||a[l]=='*'||b[j]=='*') ++j,++l;
	  	else
	  	{
	  		fl=0;
	  		break;
		}
		if(fl) A[++A[0]]=i+1;
	  }
	printf("%d\n",A[0]);
	for(int i=1;i<=A[0];++i)
	  printf("%d ",A[i]);
	return 0;
}
```
除非你的暴力复杂度是$O(wys)$，不然肯定是卡不出$AC$的

正解思路还是很妙的

首先，我们发现这题难搞的原因是有```'*'```存在

我们可以yy一下，假如能把两个字符串每个字符表示成数字，定两个字符串匹配相当于多项式相乘

然后两个字符匹配的条件就是相乘等于一个特定的数

因为```'*'```可以匹配任意字符，所以所有的字符与ta相乘值都相等

可以想到：$0$乘以任何数都等于$0$

所以我们可以把```'*'```定为$0$

那么其他匹配成功结果应该等于什么呢？

这个结果得存在一个性质，满足每个匹配成功结果累计（因为是数字所以就是相加）都满足这个性质，并且只要有一个不匹配都会破坏这个性质

因为```'*'```都定为$0$了，所以可以把成功匹配的结果定为一个整数，不匹配为小数，整数加整数还是整数，整数加小数是小数

好了，这样匹配的方式定了，那匹配的顺序呢？

一次匹配是像这样（后面省略了）：
![](http://a-failure.github.io/img/study/canque.png)

图中两条线段是两个字符串

假设匹配都还是从左向右一位一位匹配，发现是不行的，因为每一位匹配出来的指数不同，无法相加

所以我们倒着匹配，把$A$倒过来：
![](http://a-failure.github.io/img/study/canque2.png)

这样匹配就行了，相乘的结果指数相同了

所以$F(i)=\sum_{j=0}^{i}a_i\times b_{i-j}$

$FFT$的式子就出来啦（下标从$0$开始）……$F(i)$表示$B$中以$i$为结尾的前$m$项匹配结果

$a$中下标大于$m-1$的项都等于$0$，所以对结果无影响

最后$F(i)$的$m-1$到$n-1$项就是匹配的结果

[代码戳这里](https://a-failure.github.io/2018/06/20/LUOGU4173-%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/)

---


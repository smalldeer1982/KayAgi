# [EC Final 2022] Binary String

## 题目描述

给定一个排列在环上的二进制字符串 $a_0a_1a_2\dots a_{n-1}$。每一秒钟，你会同时将每个 $01$ 变为 $10$。换句话说，如果 $a_i = 0$ 且 $a_{(i+1) \bmod n} = 1$，则交换 $a_i$ 和 $a_{(i+1)\bmod n}$。例如，我们将 $\texttt{100101110}$ 变为 $\texttt{001010111}$。

你需要回答在无限秒内会出现多少种不同的字符串，取模 $998244353$。

注意：如果存在整数 $i\in \{0,1,\ldots, n-1\}$ 使得 $a_i\neq b_i$，则两个字符串 $a_0a_1\dots a_{n-1}$ 和 $b_0b_1\dots b_{n-1}$ 是不同的。因此，字符串的循环移位可能与原始字符串不同。

## 样例 #1

### 输入

```
3
1
001001
0001111```

### 输出

```
1
3
9```

# 题解

## 作者：xixihaha2021 (赞：3)

# [[EC Final 2022] Binary String](https://www.luogu.com.cn/problem/P9717)
前置知识：KMP求最小周期。
## 题意简述
给定一个字符串，首尾相接，每次操作会将所有连续的 `01` 替换成 `10`，问经过若干次操作可能出现多少种不同的字符串。

多组测试数据。
## 思路简述
一些易得的性质：

对于长度大于 $1$ 的连续段，存在以下性质：

1.$k$ 次操作后，$0$ 的连续段会整体向左移动 $k$ 位，$1$ 的连续段会整体向右移动 $k$ 位。

2.$1$ 次操作后，两个相撞的 $0,1$ 连续段的长度会分别减少 $1$，多余的字符串长度不会产生新的连续段。

首先，计算出字符串中 $0$ 的个数，如果其超过字符串长度的一半，就将字符串的每一位取反，其目的是为了保证字符串中 $1$ 的个数比 $0$ 多，方便讨论。但是这样做会让原来的 `01` 变成 `10`， `10` 变成 `01`，影响结论，所以我们需要将整个字符串倒过来，即首变尾，尾变首。

其次，因为字符串是个环，所以要破环为链。记录 $f_i$ 表示截至第 $i$ 个字符，$1$ 比 $0$ 多了多少个。记录一个类似栈的数组，倒序枚举字符串，每次将当前字符的编号加入栈，同时不断取得栈顶的两个元素 $ft,sd$，如果 $(ft,sd]$ 中 $0$ 比 $1$ 多，就把两个元素合并为 $ft$ 的编号重新入栈，直到不满足要求或栈中元素不满 $2$ 个为止。这样做的本质是制造 $0$ 的连续段。记录一个 vector，如果 $s_{i+1}$ 是 $1$，就进行判断。如果当前栈元素不满 $2$ 个，就说明跳出 while 循环的原因不是不满足要求，因此可以得出当前元素为 $0$ 的结论，所以将 $1$ 的编号加入 vector。否则，设当前栈顶的两个元素按从栈顶到栈底的顺序为 $ft,sd$，$ans$ 的贡献之一为 $tmp$，则我们更新 $tmp$ 为 $(sd - ft - 1) / 2$。这个表达式的含义是计算两个连续的 $1$ 段之间的 $0$ 的数量，然后除以 $2$。这是因为在每一秒，每个 `01` 都会变成 `10`，所以两个 $1$ 之间的 $0$ 的数量会影响它们何时会相遇并形成一个更大的 $1$ 段。通过除以 $2$，我们可以得到这个过程需要的秒数。显而易见每一秒都出现了一种新的字符串，因此我们在循环结束后将 $tmp$ 贡献给 $ans$。

然后，如果字符串中没有 $1$，显然其无法发生改变，即只有一种可能的字符串——全 $0$，故应将答案设为 $1$。否则，字符串至少存在一个 $1$。此时我们开始为 KMP 做准备。首先，将字符串清空。然后，根据性质，我们将所有 $1$ 右移 $tmp$ 位。对于所有的 $1$，在其中间以 $0101\ldots$ 的格式添加数字，随后为新构造的字符串破环为链。

最后，为字符串进行 KMP，实现查找最小整周期的目的，将其贡献到答案中。
## 复杂度分析
### 时间复杂度分析
显而易见，$O(\sum N)$。
### 空间复杂度分析
显而易见，$O(\max N)$。
### 数据范围
$1 \le \sum N \le 10^7.$

对于时间，$\sum N=10^7 \le 4 \times 10^8$，不会超时。

对于空间，$\max N=10^7 \le 3 \times 10^7$，不会超空间。
## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,n,ne[20000005],f[20000005],my_array[20000005],sum,ans,cnt,tmp,point;
vector<ll> w;
bool flag1,flag2,flag3;
char s[20000005];
int main(){
	scanf("%lld",&T);
	for(ll num = 1;num <= T;num++){
		sum = ans = cnt = tmp = 0;
		w.clear();
		flag1 = false;
		scanf(" %s",s);
		n = strlen(s);
		if(n == 1){
			printf("1\n");
			continue;
		}
		for(ll i = 0;i <= n - 1;i++)if(s[i] == '0')sum++;
		if(sum * 2 > n){
			for(ll i = 0;i <= n - 1;i++){
				if(s[i] == '0')s[i] = '1';
				else s[i] = '0';
			}
			for(ll i = 0;i <= n - i - 2;i++)swap(s[i],s[n - 1 - i]);
		}
		for(ll i = n;i <= n * 2 - 1;i++)s[i] = s[i - n];
		if(s[0] == '1')f[0] = 1;
		else f[0] = -1;
		for(ll i = 1;i <= n * 2 - 1;i++){
			if(s[i] == '1')f[i] = f[i - 1] + 1;
			else f[i] = f[i - 1] - 1;
		}
		for(ll i = n * 2 - 1;i >= 0;i--){
			my_array[++cnt] = i;
			while(cnt > 1 && f[my_array[cnt]] <= f[my_array[cnt - 1]])cnt--,my_array[cnt] = my_array[cnt + 1];
			if(i < n && s[i + 1] == '1'){
				if(cnt == 1)w.push_back((i + 1) % n);
				else tmp = max(tmp,(my_array[cnt - 1] - my_array[cnt] - 1) / 2);
			}
		}
		ans += tmp;
		if(w.size() == 0)ans = 1;
		else{
			for(ll i = 0;i <= n - 1;i++)s[i] = '?';
			for(ll i = 0;i <= w.size() - 1;i++)s[(w[i] + tmp) % n] = '1';
			point = 0;
			for(ll i = 0;i <= n - 1;i++)
				if(s[i] == '1'){
					flag3 = false;
					for(ll j = i - 1;j >= point;j--)s[j] = flag3 + '0',flag3 = !flag3;
					point = i + 1;
				}
			flag3 = false;
			for(ll i = point;i <= n - 1;i++){
				s[i] = flag3 + '0';
				flag3 = !flag3;
			}
			for(ll i = n;i <= n * 2 - 1;i++)s[i] = s[i - n];
			ne[0] = 0;
			for(ll i = 1;i <= n * 2 - 1;i++){
				ne[i] = ne[i - 1];
				while(ne[i] && s[ne[i]] != s[i])ne[i] = ne[ne[i] - 1];
				if(s[ne[i]] == s[i])ne[i]++;
			}
			ans = (ans + (n * 2 - ne[2 * n - 1]) % 998244353) % 998244353;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Elma_ (赞：2)

咕值要掉没了，水点题解。

很炫酷的题。

以下的 “段” 均指长度大于 $1$ 的 $0$ 或 $1$ 的连续段。手玩一下能够发现一些规律：

- 对于一个 $0$ 段，如果其左边不和某个 $1$ 段相邻，变换后会整体往左移动一位。
- 对于一个 $1$ 段，如果其右边不和某个 $0$ 段相邻，变换后会整体往右移动一位。
- 如果一个 $0$ 段接在一个 $1$ 段后面，那么相当于两个段相撞，变换后长度都会减 $1$。

这个过程会一直执行直到不存在 $0$ 或 $1$ 的段。每次相撞会使段的长度减 $1$，并且 $0$ 段和 $1$ 段的运动方向是相反的，所以显然变换是有限次。之后就会变成一个串在环上不断绕圈，求出这个串之后就只需要用 KMP 求一下最小整周期即可。

考虑怎么求出最后这个串。不妨假设 $1$ 段总长度不小于 $0$ 段总长度。

注意到这个过程和括号匹配很像阿，考虑如果不是环而是序列的话，实际上我们可以直接模拟一遍求出每个 $0$ 连续段会在什么时候消失，以及所有 $0$ 连续段消失后的串。而如果是环，考虑当前没有剩下的 $1$ 去和 $0$ 匹配的情况，由于是个环所以这些 $0$ 会跑到末尾的位置，看起来就很烦。

那考虑规避掉这种情况。根据 Raney 引理，我们总是能找到⼀个起点位置，使得每个前缀中 $1$ 段长度和均不小于 $0$ 段长度和。于是直接做就行了，时间复杂度 $\mathcal{O}(n)$。

---


# 最小度限制生成树

## 题目描述

给你一个有 $n$ 个节点，$m$ 条边的带权无向图，你需要求得一个生成树，使边权总和最小，且满足编号为 $s$ 的节点正好连了 $k$ 条边。

## 说明/提示

### 数据范围

对于 $20\%$ 的数据，$n \le 10$，$m \le 30$。  
对于 $50\%$ 的数据，$n \le 1000$，$m \le 5000$。  
对于 $100\%$ 的数据，$1\leq s \leq n \le 5\times 10^4$，$1\leq m \le 5\times 10^5 $，$1\leq k \le 100$，$0\leq w\leq 3\times 10^4$。

### 注意

本题设有 hack 数据（Subtask $2$），计 $0$ 分，但若没有通过 hack 数据则不算通过本题。

## 样例 #1

### 输入

```
5 7 1 1
1 3 1
2 1 5
4 2 3
2 5 4
5 1 2
3 5 7
4 1 6```

### 输出

```
15```

# 题解

## 作者：Tiw_Air_OAO (赞：54)

分享一个不用带权二分的做法吧。

---

为了方便描述，给所有非 $s$ 的点一个点权，表示该点与 $s$ 之间的所有边（虽然不知道数据造没造，但可能会有重边）的边权最小值（如果没边则点权设为无穷大）。则选中这个点相当于选它连向 $s$ 的边。

题目转化成选中恰好 $k$ 个点 + 删去若干条边，使得最终形成一个森林，且每棵树恰好选中一个点，最小化 “选中的点权值减去删边代价”。

接下来的讨论中默认不考虑 $s$。

---

可以先对所有点求最小生成森林，则不在最小生成森林里的边一定会被删除（比较显然）。这样得到一个初始的森林。

对于初始的每棵树，首先必须选中一个点，可以证明贪心地选中点权最小的点最优。

设 $f_x(i)$ 表示在连通分量 $x$ 中选中 $i$ 个点的最小答案，可以考虑贪心地使用增量法，从 $f_x(i-1)$ 对应的答案加入一个新点使得 $f_x(i)$ 最小。证明方法与上面那条贪心性质类似。

这里，设新点为 $x$，与 $x$ 同属同一连通块且已经被选中的点为 $y$。则 $x$ 的贡献等于 $x$ 的点权减去 $x\to y$ 这条路径上的最大边权。当然，加入新点 $x$ 后要删去这条最大边。

----

注意到 $f_x(i)$ 是凸的（也即该题带权二分的凸性质），那么我们可以求出所有 $f_x(i)-f_x(i-1)$ 并从小到大排序，取出前若干个即可得到答案。

而 $f_x(i)-f_x(i-1)$ 又可以看成 $f_x(i-1)\to f_x(i)$ 中新加进来的点的贡献，于是只需要尝试求出每个点的贡献，也即每个点对应需要删掉的边即可。

---

考虑到具体实现，不妨去考虑每条边会被哪个点删掉。

从大到小考虑每条边，设最大边所连接的两个连通块中分别的最小值为 $x,y$，则最大边被删掉的时刻对应的点应该是 $\max\{x, y\}$（也比较显然）。

之后删掉最大边，再考虑次大边，以此类推。

发现这个过程反过来和 kruskal 基本一样，因此在 kruskal 的时候顺便维护一下即可。

---

无解的情况：至少需要的边太多，或者最多能连的边太少（注意点权为无穷大的点不能被选中）。

时间复杂度 $O(M\log M)$，瓶颈在于 kruskal 的排序。

```cpp
#include <bits/stdc++.h>

typedef long long ll;

const int M = 500000;
const int INF = (1 << 30);

struct edge{
	int u, v, w;
	friend bool operator < (const edge &a, const edge &b) {
		return a.w < b.w;
	}
}e[M + 5]; int cnt;

int fa[M + 5], val[M + 5], key[M + 5];
int find(int x) {return (fa[x] == x ? x : fa[x] = find(fa[x]));}
bool unite(int x, int y, int k) {
	int fx = find(x), fy = find(y);
	if( fx != fy ) {
		if( val[fx] < val[fy] ) std::swap(fx, fy);
		key[fx] = k, fa[fx] = fy; return true;
	} else return false;
}

int tmp[M + 5];
int main() {
	int n, m, s, k; scanf("%d%d%d%d", &n, &m, &s, &k);
	for(int i=1;i<=n;i++) if( i != s ) fa[i] = i, val[i] = INF;
	for(int i=1,u,v,w;i<=m;i++) {
		scanf("%d%d%d", &u, &v, &w);
		if( u == s ) val[v] = std::min(val[v], w);
		else if( v == s ) val[u] = std::min(val[u], w);
		else e[++cnt] = (edge){u, v, w};
	}
	
	ll ans = 0; std::sort(e + 1, e + cnt + 1);
	for(int i=1;i<=cnt;i++) if( unite(e[i].u, e[i].v, e[i].w) ) ans += e[i].w;
	
	int p = 0;
	for(int i=1;i<=n;i++) if( i != s && find(i) == i ) {
		if( val[i] == INF ) {puts("Impossible"); return 0;}
		p++, ans += val[i], val[i] = INF;
	}
	if( p > k ) {puts("Impossible"); return 0;}
	
	int tot = 0;
	for(int i=1;i<=n;i++) if( i != s && val[i] != INF ) tmp[++tot] = val[i] - key[i];
	if( p + tot < k ) {puts("Impossible"); return 0;}
	
	std::sort(tmp + 1, tmp + tot + 1); for(int i=1;i<=k-p;i++) ans += tmp[i];
	printf("%lld\n", ans);
}
```

---

## 作者：Alex_Wei (赞：49)

### [P5633 最小度限制生成树](https://www.luogu.com.cn/problem/P5633)

不妨设 $s = 1$。

**问题描述**：给定 $k$，求点 $1$ 的度数为 $k$ 的最小生成树。

该问题有 $\mathcal{O}(m\log V\alpha (m))$ 的 WQS 二分做法，不在本文讨论范围内，感兴趣的同学可自行查阅资料。

先求出不含点 $1$ 的最小生成森林 $T$，则不在森林上的边一定无用。

> **证明**：设 $e = (u, v, w)$ 为非树边，根据最小生成树的基本性质，存在连接 $u, v$ 的树边构成的路径 $P$，且路径上每条边的权值不大于 $w$。
>
> 假设 $e$ 在最小 $k$ 度生成树上，断开 $e$，$u, v$ 不连通。因此 $P$ 上存在一条边使得其两侧不连通，加入该树边即可。$\square$

设 $2\sim n$ 每个点的点权为它和 $1$ 之间的边权，若不存在则为 $+\infty$。考虑最终生成树，将 $1$ 删去后整张图裂成 $k$ 个连通块，每个连通块会选择与 $1$ 相连的权值最小的边，即点权最小值。故一棵最小生成树可理解为：从 $T$ 删去若干条边，使图分裂为 $k$ 个连通块。在每个连通块中选择权值最小的点与 $1$ 相连。这样，可以用只含 $2\sim n$ 的森林描述最小 $k$ 度生成树。

$T$ 初始的连通块数量决定了度数的下界，而点权不为无穷大的点的数量决定了度数的上界。为方便讨论，以下设 **$T$ 连通且 $1$ 和每个点均有边**，则最小 $1\sim n - 1$ 度生成树均存在。

最小生成树可以贪心，那么最小 $k$ 度生成树是否也可以贪心呢？能否每次贪心地删去一条树边，使得 $w(T') - w(T)$ 最小？

考虑删去树边 $e$ 后树的权值如何变化：设删去 $e$ 前 $e$ 所在连通块为 $C$，最小权点为 $x$。删去 $e$ 后 $C$ 分裂为两个连通块 $C_1, C_2$，不妨设 $x$ 是 $C_1$ 的最小权点，同时设 $C_2$ 的最小权点为 $y$，则权值变化量为 $f(e) = w(T') - w(T) = w(y) - w(e)$。

> **结论**：对于初始最小生成树 $T$，考虑使得 $f(e)$ 最小的边 $e$。对于任意 $2\leq k < n$，存在最小 $k$ 度生成树 $T_k$ 删去了 $e$。
>
> **证明**：设 $x, y$ 分别为删去 $e$ 后两个连通块 $C_1, C_2$ 的最小权点，其中有一个是 $T$ 的最小权点，设为 $x$，则 $x$ 在任何连通块内都是最小权点，所以 $x$ 一定被选中。
>
> 根据 $f(e)$ 的最小性，$e$ 一定是 $T$ 的连接 $x, y$ 的路径 $P$（$P = p_0(x)\to p_1 \to \cdots \to p_c(y)$）上的最大权边。
>
> 假设 $e\in T_k$ 并从 $T_k$ 中删去点 $1$，设包含 $e$ 的连通块为 $C$。
>
> - 若 $y$ 被选中：因为 $x, y$ 均被选中，所以它们在 $T_k$ 上不连通。设 $P$ 和 $C$ 的交集为路径 $Q$。因为 $e\in Q$，所以 $Q$ 非空，设为 $p_l\rightsquigarrow p_r$（$0\leq l < r\leq c$）。
>
>   - 若 $C$ 被选中的点在 $e$ 左侧（含有 $x$ 一侧的子树），则 $y\notin C$（因为 $y$ 也被选中），即 $r < c$。加入边 $(p_r, p_{r + 1})$，删去 $e$，考虑权值变化：
>
>     - 因为 $e$ 是 $P$ 的最大权边，所以 $w(e) \geq w(p_r, p_{r + 1})$。
>     - 因为 $C$ 被选中的点不变，其它连通块没有缩小，所以被选中的点的权值之和不增。
>
>     这说明调整后权值不增。
>
>   - 若 $C$ 被选中的点在 $e$ 右侧（含有 $y$ 一侧的子树），则 $x\notin C$，即 $0 < l$。加入边 $(p_{l - 1}, p_l)$，删去 $e$，类似可证权值不增。
>
> - 若 $y$ 未被选中：因为 $y$ 是 $e$ 右侧的最小权点，所以 $y$ 所在连通块一定包含 $e$ 左侧的点，因此 $y\in C$。设任意一条与 $x$ 所在连通块 $C_x$ 相连的被删去的边为 $e'$（因为 $k\geq 2$，所以 $e'$ 存在），它连接的另一个连通块 $C'$ 的最小权点为 $y'$。在原树 $T$ 中删去 $e$ 后，另一个连通块 $C''$ 包含 $C'$，所以 $C''$ 的最小点权不大于 $w(y')$，因此 $f(e') \leq w(y') - w(e')$。
>
>   加入边 $e'$，对权值的影响为 $w(e') - w(y')$。然后删去 $e$。因为 $C$ 的最小权点在 $y$ 左边，所以 $C$ 分裂出的两个连通块 $C_1, C_2$，一个的最小权点为 $C$ 最小权点，另一个包含 $y$，最小点权不大于 $w(y)$，对权值的影响不大于 $w(y) - w(e) = f(e)$。而 $f(e) \leq f(e') \leq w(y') - w(e')$，因此权值不增。
>
> 综上，总可以调整使得 $T_k$ 权值不增且 $e\notin T_k$。$\square$

因此，在求最小 $2\leq k < n$ 度生成树之前，可直接将 $f(e)$ 最小的 $e$ 删去。注意到删去后两个子树的贡献独立，结合上述结论，我们猜测每个点的贡献都是独立的。

设 $f_k(T)$（$1\leq k\leq |T|$）表示当初始树为 $T$ 时（不含点 $1$），它的最小 $k$ 度生成树的权值。设 $T_k$ 表示对应连通块形态（不含点 $1$）。即从 $T$ 删去 $k - 1$ 条边，使其裂成 $k$ 个连通块，所有边权加上每个连通块最小点权的最小值，以及取到最小值时的形态。

> **结论**：对于 $2\leq k \leq |T|$ 和任意 $T_{k - 1}$，存在 $T_k$ 为 $T_{k - 1}$ 删去一条边，且 $f_{k}(T)$ 关于 $k$ 在 $[1, |T|]$ 上下凸。
>
> **证明**：当 $|T| = 1$ 或 $2$ 时显然成立。
>
> 若 $|T| > 2$，根据上述结论，设使得删去后新的权值最小的边为 $e$（不一定是权值最小的边），可钦定 $T_{2\sim |T|}$ 一定删去 $e$。
>
> 设删去 $e$ 后得到的两棵树为 $T'$ 和 $T''$，归纳假设 $T'$ 和 $T''$ 满足结论。
>
> 因为 $T$ 和 $T''$ 的贡献独立，所以 $f_k(T)$ 等于 $f_{k_1}(T') + f_{k_2}(T'')$ 的最小值，其中 $1\leq k_1 \leq |T'|$，$1\leq k_2\leq |T''|$，且 $k_1 + k_2 = k$。这是下凸函数的 $\min +$ 卷积，根据经典理论（闵可夫斯基和），$f_k$ 也是下凸的。而 $f_{k_1}(T')$ 和 $f_{k_2}(T'')$ 的每个差分值都对应 “删去一条边产生的贡献”，所以 $f_k(T)$ 的每个差分值都对应 “从 $T'$ 或 $T''$ 中删去一条边产生的贡献”。
>
> 另一种理解方式：结论实际上说明了在 $T_1\to T_2\to \cdots \to T_{|T|}$ 的过程中，每次删去一条使得新的权值最小的边，且权值变化量（每条边的代价）随着删边而不降（下凸即二阶导非负，$f_{k + 1}(T) - f_{k}(T)\geq f_k(T) - f_{k - 1}(T)$）。现在 $T$ 分裂成 $T'$ 和 $T''$，因为 $T'$ 和 $T''$ 独立，所以删去使得新的权值最小的边相当于初始令 $k_1, k_2 = 1$，每次选择 $f_{k_1 + 1}(T') - f_{k_1}(T')$ 和 $f_{k_2 + 1}(T'') - f_{k_2} (T'')$ 较大的那个差分值，令其为 $f_{k + 1}(T) - f_k(T)$，然后将 $k$ 和被选中的 $k_i$ 加上 $1$。
>
> 此时只需证明 $f_2(T) - f_1(T) = f(e)\leq f_3(T) - f_2(T)$。
>
> 可以证明在子图上删去一条边的代价不小于在原图上删去这条边的代价：设在原图删去 $e'$ 之后，不含 $x$ 的连通块为 $C$，新增点权为 $C$ 的最小点权 $w(C)$。在子图删去 $e'$ 之后，一定有一侧连通块 $C'$ 包含于 $C$。新增点权为两侧连通块最小点权的较大值，不小于 $C'$ 的最小点权 $w(C')$。而 $C'\subseteq C$，所以 $w(C) \leq w(C')$。
>
> 结合 $f(e)$ 的最小性，得证。$\square$

上述结论告诉我们，随着 $k$ 增大，已经删去的边不会再出现，已经加入的点不会再消失。

至此，存在 $n ^ 2$ DP 做法：对每个连通块以最小权点为根 DFS，求出每个子树的最小点权，可知删去每条边的权值变化量。取代价最小的边删去即可。

若删去 $e$ 后新增点 $y$，则称 $e$ 被 $y$ 删去。根据结论，每条边被固定的点删去。考虑求出 $e$ 被哪个点删去。

设删去 $e$ 之前所在连通块的最小权点为 $x$，则 $e$ 在 $x, y$ 的路径上，且 $e$ 是路径边权最大值（对边权相同的边任意钦定大小关系，不影响答案）。设 $C$ 为包含 $e$ 的权值不大于 $w(e)$ 的边形成的连通块，考察 $C$ 的状态。

注意到对于 $x', y'$ 至少一个不属于 $C$ 的操作，$C$ 中不可能有边被删掉，因为 $x', y'$ 之间的路径如果经过 $C$，那么一定经过权值大于 $w(e)$ 的边（由 $C$ 的定义可知）。这说明当 $C$ 的第一条边被删去时，一定有 $x', y'\in C$ 且 $x' = x$。

设 $C_x$ 为 $e$ 的 $x$ 一侧与 $C$ 的交，另一侧为 $C_y$。设 $y_{\min}$ 为 $C_y$ 的最小权点。设 $x', y'$ 删去的边为 $e'$。

- 如果 $y'\in C_y$，则 $x', y'$ 路径上的最大权边为 $e$，得 $e' = e$，推出 $y' = y_{\min}$。
- 如果 $y'\in C_x$，则 $w(e') < w(e)$（$e$ 是 $C$ 的最大边权），根据 $w(y') - w(e')$ 的最小性得 $w(y') < w(y_{\min})$。新的 $x$ 有可能变为 $y'$，但无论何种情况点权均不大于 $y_{\min}$。

因此 $y = y_{\min}$，即 $e$ 一定被 $y_{\min}$ 删去。

在 Kruskal 的过程中维护连通块的最小点权。用 $e$ 合并两个连通块时，可求出删去 $e$ 产生的贡献 $c(e)$ 等于最小点权的较大值减去 $w(e)$。将 $e$ 按 $c(e)$ 从小到大排序得 $e_{1\sim n - 1}$，则 $f_{k + 1}(T) = f_{k}(T) + c(e_k)$。

最后处理遗留的细节：之前钦定了 $T$ 连通且 $1$ 与 $2\sim n$ 每个点相连。对于 $T$ 不连通的情况是一样的，因为 $T$ 的每个连通块独立，连通块数决定了最小的 $k$，对小于 $k_{\min}$ 的 $k$ 无解。如果权值为正无穷，说明 $k$ 超过上界（上界为初始连通块数，加上 $c$ 值不为正无穷的边数），同样无解。

算法在 $\mathcal{O}(m\log m)$ 的时间复杂度内，对每个 $1\leq k \leq n - 1$ 判定最小 $k$ 度生成树是否存在，若存在则可以求出其权值。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using ull = unsigned long long;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;
// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
mt19937 rnd(1064);
int rd(int l, int r) {return rnd() % (r - l + 1) + l;}

constexpr int mod = 1e9 + 7;
void addt(int &x, int y) {x += y, x >= mod && (x -= mod);}
int add(int x, int y) {return x += y, x >= mod && (x -= mod), x;}
int ksm(int a, int b) {
  int s = 1;
  while(b) {
    if(b & 1) s = 1ll * s * a % mod;
    a = 1ll * a * a % mod, b >>= 1;
  }
  return s;
}

constexpr int Z = 1e6 + 5;
int fc[Z], ifc[Z];
int bin(int n, int m) {
  if(n < m) return 0;
  return 1ll * fc[n] * ifc[m] % mod * ifc[n - m] % mod;
}
void init_fac(int Z) {
  for(int i = fc[0] = 1; i < Z; i++) fc[i] = 1ll * fc[i - 1] * i % mod;
  ifc[Z - 1] = ksm(fc[Z - 1], mod - 2);
  for(int i = Z - 2; ~i; i--) ifc[i] = 1ll * ifc[i + 1] * (i + 1) % mod;
}

char buf[1 << 20], *p1 = buf, *p2 = buf;
#define getc() (p1 == p2 && (p2 = (p1 = buf) + \
  fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
  int x = 0;
  char s = getc();
  while(!isdigit(s)) s = getc();
  while(isdigit(s)) x = x * 10 + s - '0', s = getc();
  return x;
}

// ---------- templates above ----------

constexpr int N = 5e5 + 5;

int n, m, s, k, val[N], fa[N];
int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
struct edge {
  int u, v, w;
  bool operator < (const edge &z) const {
    return w < z.w;
  }
} e[N];
void mian() {
  cin >> n >> m >> s >> k;
  memset(val, 0x3f, N << 2);
  int cnt = 0, ans = 0;
  for(int i = 1; i <= m; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    if(u == s) val[v] = min(val[v], w);
    else if(v == s) val[u] = min(val[u], w);
    else e[++cnt] = {u, v, w};
  }
  sort(e + 1, e + cnt + 1);
  for(int i = 1; i <= n; i++) fa[i] = i;
  vector<int> dt;
  for(int i = 1; i <= cnt; i++) {
    int u = find(e[i].u);
    int v = find(e[i].v);
    if(u == v) continue;
    if(val[u] > val[v]) swap(u, v);
    fa[v] = u, ans += e[i].w;
    if(val[v] < 1e9) dt.push_back(val[v] - e[i].w);
  }
  int deg = 0;
  for(int i = 1; i <= n; i++) {
    if(fa[i] != i || i == s) continue;
    if(val[i] > 1e9) cout << "Impossible\n", exit(0);
    deg++, ans += val[i];
  }
  if(deg > k || deg + dt.size() < k) cout << "Impossible\n", exit(0);
  sort(dt.begin(), dt.end());
  for(int i = 0; i < k - deg; i++) ans += dt[i];
  cout << ans << "\n";
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) mian();
  fprintf(stderr, "%d ms\n", int(1e3 * clock() / CLOCKS_PER_SEC));
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：Lskkkno1 (赞：21)

## $wqs$ 二分

用来解决一种特定类型问题的**二分**

有 $n$ 个物品，选择每一个物品都有一个相应的权值，需要求出强制选出 $k$ 个物品时的最大/最小权值和

一般来说，没有限制条件时我们可以很轻松的求出答案

而有限制条件我们就要把它转化成一个**可行性问题**(判断是否选了 $k$ 个物品)

具体做法是**二分**一个**偏移量** $\Delta$，使每个需要强制选的物品加上这一个**偏移量**

再进行**没有限制条件**时的做法

判断是否选了 $k$ 个物品，来改变我们**偏移量**的取值范围(二分)

其实 [这道题](https://www.luogu.org/problem/P5633) 跟 [这道题](https://www.luogu.org/problem/P2619) 做法差不多，都挺板子的

不过注意在做**最小生成树**之前

可以先把边分两类排序，最后归并一下，这样复杂度可以少一个 $log$

时间复杂度 $O(m\log m + m\log V\alpha (m))$

$\color {DeepSkyBlue} {Code :}$

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#define N 50005
#define E 500005
#define inf 1e9

using namespace std;

int n, m, s, k;

int tot0, tot1;
struct edge {
	int u, v, w;
	bool isNeed;
}orig[2][E], e[E];

bool cmp_edge(const edge &lhs, const edge &rhs) { return lhs.w < rhs.w; }

inline void read(int &x) {
	x = 0; char ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
}

void mergeSort(int delta) {
	for(int i = 1; i <= tot1; ++i) orig[1][i].w += delta;
	int i, j, o;
	i = j = o = 0;
	while(i < tot0 && j < tot1) {
		if(cmp_edge(orig[0][i + 1], orig[1][j + 1])) { // w 相同, 与 s 相连的点优先
			e[++o] = orig[0][++i];
		} else {
			e[++o] = orig[1][++j];
		}
	}
	while(i < tot0) e[++o] = orig[0][++i];
	while(j < tot1) e[++o] = orig[1][++j];
	for(int i = 1; i <= tot1; ++i) orig[1][i].w -= delta;
	return;
}

namespace UFS {

int fa[N];
inline void init() { for(int i = 1; i <= n; ++i) fa[i] = i; }
inline int find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }
inline bool merge(int u, int v) {
	int x = find(u), y = find(v);
	if(x == y) return false;
	return fa[x] = y, true;
}

} using UFS :: merge;

int cnt;
long long res;
bool check(int delta) {
	mergeSort(delta);
	res = cnt = 0;
	UFS :: init();
	int block = n;
	for(int i = 1; i <= m; ++i) {
		if(!merge(e[i].u, e[i].v)) continue;
		cnt += e[i].isNeed;
		res += e[i].w;
		if(--block == 1) break;
	}
	return cnt >= k;
}

int main() {
	int u, v, w;
	read(n), read(m), read(s), read(k);
	for(int i = 1; i <= m; ++i) {
		read(u), read(v), read(w);
		if(u == s || v == s) {
			orig[1][++tot1] = (edge){u, v, w, true};
		} else {
			orig[0][++tot0] = (edge){u, v, w, false};
		}
	}
	
	// judge if it is possible
	if(tot1 < k) return puts("Impossible"), 0;
	
	// not scc
	int block = n;
	UFS :: init();
	for(int i = 1; i <= tot0; ++i) block -= merge(orig[0][i].u, orig[0][i].v);
	for(int i = 1; i <= tot1; ++i) block -= merge(orig[1][i].u, orig[1][i].v);
	if(block != 1) return puts("Impossible"), 0;
	
	// mergeSort init
	sort(orig[0] + 1, orig[0] + 1 + tot0, cmp_edge);
	sort(orig[1] + 1, orig[1] + 1 + tot1, cmp_edge);
	
	// 找到满足条件的 maxdelta
	int l = -inf, r = inf, mid, maxp = -inf;
	if(!check(l)) return puts("Impossible"), 0;
	while(l <= r) {
		mid = l + r >> 1;
		if(check(mid)) {
			if(mid > maxp) maxp = mid;
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	
	check(maxp);
	printf("%lld\n", res - 1ll * k * maxp);
	return 0;
}
```



---

## 作者：柠檬熟了 (赞：14)

## [Luogu P5633 最小度限制生成树](https://www.luogu.com.cn/problem/P5633)

### **思路部分**

先读题，蛤！

我们要求一棵最小生成树，非常咧简单。

但是这棵树上喃，有一个神秘的点 $s$，欸，这个点咧度数只能为 $k$。

这下就瓜起喽！

仔细想想蛤，如果我们在正常咧最小生成树上，把这个点 $s$ 连的边给**砍掉**，得到了啥子？

一个 **最小生成树森林**，是蛤！

所以喃，我们阔以先求出这个不含 $s$ 的 最小生成树森林，然后再加一些边上去。

找这个森林十分简单蛤！直接对砍掉 $s$ 之后每个连通块跑个 **Kruskal** 就得行喽。

难咧还是啷个**加边**，可以想到蛤，首先我们还是要单独记录下与 $s$ 相连的**所有点**。

（注意蛤，这个时候就要直接 **取最小值去重** 了蛤，不然要出问题！）

在找这个森林的时候喃，顺便将当前这棵树中 **离 $s$ 最近的点** 与 $s$ 连起来，加个权值。

那如果这棵树不止一个点和 $s$ 连通喃？

假设枚举到一个边 $(u, v)$，我们阔以钦定这个离 $s$ 更近咧连通点叫 $u$，另一个叫 $v$ 蛤！

然后这个 $u$ 按照上面咧方法，可能最后就直接和 $s$ 连喽。

但是这个 $v$ 蛤，肯定是不会作为这棵树里头离 $s$ 最近的点来和 $s$ 连喽。

但是它在后头还是可能要被连的蛤，所以我们就得把它记录一哈。

> 我们把所有生成树各自离 $s$ 最近的点连完，发现 $s$ 咧度数还是凑不够的嘛，那就要考虑 $v$ 喽！

记录啥子？

其实就是如果我不连 $(u, v)$ 这个蛤蟆，而是直接连 $(s, v), (s, u)$，我亏了好多？

显然 $(s, u)$ 本身就要连，所以记录咧这个权值实质上就是 $w(s, v) - w(u, v)$ 蛤！

> 这时候就有人要说了噻
>
> 那要是 $u$ 这个点到后头没有被连到 $s$ 上（树里头有比 $u$ 离 $s$ 更近的点），那啷个办？
>
> 莫得关系蛤！考虑我们每次加边咧时候做了一个 **并查集** 的合并，并让离 $s$ 近的点当爸爸
>
> 那就是说喃，如果后头有一个更近的点，加入的时候它就会和当前离 $s$ 最近的点比较
>
> （当前并查集的祖先噻！）
>
> 然后如果比这个点离 $s$ 还要近喽，那就记录这个点，再当它咧爸爸就完事喽
>
> 具体来讲：
>
> 我们有 $u, v, k$ 三个满足 $dis(s, v) > dis(s, u) > dis(s, k)$
>
> 还有 $(s, u), (s, v), (s, k), (u, v), (k, v)$ 五条边边
>
> 那我们就会在枚举到 $(u, v)$ 的时候记录 $v$，让 $u$ 当爸爸。
>
> 然后枚举到 $(k, v)$ 的时候发现喽 $v$ 的爸爸 $u$，比较 $u, k$ 到 $s$ 咧距离，$k$ 更近蛤！
>
> 所以再记录 $u$，让 $k$ 当爸爸就阔以喽！

最后我们就把这森林里头**所有树根**连上 $s$（记住蛤！根一直是树里头离 $s$ 最近的点！）

如果这个时候 $s$ 度数都超了 $k$，那就玩完，根本 Impossible！

如果这个时候 $s$ 度数 **加上前面记录** 的那种 $v$ 咧个数还凑不够 $k$ 喃，也玩完喽，Impossible！ 

其他情况，我们就要把刚刚记录的那一堆点拿出来，看看那个换上之后亏咧少！

排个序蛤，然后一条一条加上，到度数凑够就行。

### 实现部分

听上去很复杂喃，但是实现起来相当的快！

先开个结构体记下边，十分好用

```cpp
struct Edge {
	int u, v, w;
	inline bool operator < (const Edge &a) const {
		return w < a.w;
	}
} E[MAXM << 1];
```

然后打个我们最喜欢咧 **并查集板子**（啷个合并都行蛤，注意 **路径压缩**！）

之后先跳到读入处理，我们只直接连端点莫得 $s$ 的边，其他边 **取最小去重**。

```cpp
for (int i = 1; i <= M; ++ i) {
    cin >> u >> v >> w;
    if (u == S) Val[v] = min(Val[v], w);
    else if (v == S) Val[u] = min(Val[u], w);
    else Add_Edge(u, v, w);
}
```

最重点的东西来了蛤！魔改 **Kruskal** ，先是**找森林**的部分！

```cpp
sort(E + 1, E + tot + 1); // 边权排序！
for (int i = 1; i <= tot; ++ i) {
    fu = F(E[i].u), fv = F(E[i].v); // 找爸爸噻！
    if (fu == fv) continue; // 在一个家头就跳过

    if (Val[fu] > Val[fv]) swap(fu, fv); // 找到离 s 更近的 u
    f[fv] = fu, Ans += E[i].w; // 合并！然后直接连上 (u, v)
    if (Val[fv] < 1e9) V.push_back(Val[fv] - E[i].w);  // 记录远点的 v 蛤！
}
```

然后加边

```cpp
int Deg = 0; // 记录度数噻！
for (int i = 1; i <= N; ++ i) {
    if (f[i] != i || i == S) continue; // 非生成树根 / 源点 都不是要找的对象蛤！
    if (Val[i] > 1e9) exit(!bool(cout << "Impossible" << endl)); // 不连通喽！
    ++ Deg, Ans += Val[i]; // 直接，连，吧
}
// 判断度数可以凑得到不？
if (Deg > K || Deg + V.size() < K) exit(!bool(cout << "Impossible" << endl));
sort(V.begin(), V.end()); // 按亏得最少咧排序
for (int i = 0; i < K - Deg; ++ i) Ans += V[i]; // 凑齐度数蛤！

return Ans;
```

就结束喽！

**最后放个完整的代码，非常的规范！**

### **完整代码**

```cpp
#include <bits/stdc++.h>

const int MAXN = 50005;
const int MAXM = 500005;

using namespace std;

struct Edge {
	int u, v, w;
	inline bool operator < (const Edge &a) const {
		return w < a.w;
	}
} E[MAXM << 1];

int tot;

inline void Add_Edge (int u, int v, int w) {
	E[++ tot] = {u, v, w};
}

int f[MAXN], s[MAXN], Val[MAXN];

inline void Init (int N) {
	for (int i = 1; i <= N; ++ i) f[i] = i, s[i] = 1;
}

inline int F (int u) {
	return u == f[u] ? u : f[u] = F(f[u]);
}

inline void Merge (int u, int v) {
	u = F(u), v = F(v);
	if (u == v) return;
	if (s[u] < s[v]) swap(u, v);
	f[v] = u, s[u] += s[v];
}

int N, M, S, K;

inline int Kruskal (int Ans = 0, int Cnt = 0) {
	sort(E + 1, E + tot + 1), Init(N);
	int fu, fv;
	vector <int> V;
	
	for (int i = 1; i <= tot; ++ i) {
		fu = F(E[i].u), fv = F(E[i].v);
		if (fu == fv) continue;
		if (Val[fu] > Val[fv]) swap(fu, fv);
		f[fv] = fu, Ans += E[i].w;
		if (Val[fv] < 1e9) V.push_back(Val[fv] - E[i].w); 
	}
	int Deg = 0;
	for (int i = 1; i <= N; ++ i) {
		if (f[i] != i || i == S) continue;
		if (Val[i] > 1e9) exit(!bool(cout << "Impossible" << endl));
		++ Deg, Ans += Val[i];
	}
	if (Deg > K || Deg + V.size() < K) exit(!bool(cout << "Impossible" << endl));
	sort(V.begin(), V.end());
	for (int i = 0; i < K - Deg; ++ i) Ans += V[i];
	return Ans;
}

int u, v, w;

int main () {
	
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	memset(Val, 63, sizeof Val);
	
	cin >> N >> M >> S >> K;
	
	for (int i = 1; i <= M; ++ i) {
		cin >> u >> v >> w;
		if (u == S) Val[v] = min(Val[v], w);
		else if (v == S) Val[u] = min(Val[u], w);
		else Add_Edge(u, v, w);
	}
	
	cout << Kruskal() << endl;
	return 0;
}
```



---

## 作者：MusicBox (赞：11)

其他的题解感觉都好高级，分享一种好想且好实现的方法。

我们可以先把点 $s$ 和与其相连的边都删除，我们发现剩下的部分变成了一些连通块。

我们不难发现，当要求与 $s$ 点相连的边的个数为 $k$ 时，我们的连通块个数显然是 $k$ 的。

接下来这个问题就转化成了：$n - 1$ 个点中生成一个 $k$ 个连通块，要求边权和 + 每个块中到最小的 点到 $s$ 的边权 最小（注意断句），其实这就相当于我们生成了最小度限制生成树。

接下来的部分，我们假设 $s$ 和除 $s$ 外的每个点都有边。

我们不难发现 $k = n - 1$ 是简单的，答案就是每个点和 $s$ 的最小边的和。

我们接下来考虑合并两个连通块（单个点也是联通块），将他们变成一个连通块，我们发现将 $u$ 连通块并入 $v$ 的代价是 ${\min}(len_{u \rightarrow v}) - {\max}({\min}(len_{s \rightarrow u}),{\min}(len_{s \rightarrow v}))$。

我们令 $f_u$ 为 ${\min}(len_{u \rightarrow v})$，$g_u$ 为 ${\min}(len_{s \rightarrow u})$。

$f_u - {\max}(g_u, g_v)$ 可能很难维护，但是，如果我们换一个角度，我们认为把 $u$ 连通块并入 $v$ 的代价记作 $f_u - g_u$。当我们统计 $v$ 并入 $u$ 的时候，另外一种情况也会被统计。

接下来问题就转化成了我们要全局维护一个 $f_u - g_u$ 的最小值。

我们对于每一个连通块使用一个堆来维护 $f_u$，合并连通块就直接并查集合并，同时统计 $g_u$，堆的合并使用启发式合并，然后全局使用一个堆来维护 $f_u - g_u$，每次合并后我们取出堆顶合并两点后再对全局的堆进行更新即可。

请注意：

**更新的时候我们要注意：如果堆首所对应的 $u, v$ 已经在同一连通块内，我们要一直弹出直到堆首两个点不在同一连通块内。**

复杂度：${\rm O}(m\times \log^2\ m)$。

当然，我们也可以使用可并堆，复杂度就可以变成 ${\rm O}(m\times {\log}\ m)$。

如果每一次我们都在可并堆合并的时候启发式的删除所有两个连通块相连的边，复杂度就变成了${\rm O}(m\times {\log}\ n)$（但是我懒了，直接用 pbds，就没法做这个操作）。

我们接下来解决不够的边，如果一开始 $s$ 与一个点没有边相连，我们就连一条极大的边，最后特判一下就行了。

```cpp
int n, m, num[L], fa[L], _s, k, ww;

ll ans;

int _u[L], _v[L];

__gnu_pbds::priority_queue<pii, greater<pii>, __gnu_pbds::pairing_heap_tag> s[L], S;

int getfa(int w) {
    if(fa[w] == w) return fa[w];
    else return fa[w] = getfa(fa[w]);
}

void merge(int a, int b) {
    S.pop();
    int af = getfa(a), bf = getfa(b);
    if(s[af].size() > s[bf].size()) swap(af, bf);
    fa[af] = bf;
    num[bf] = min(num[bf], num[af]);
    s[bf].join(s[af]);
    while(!s[bf].empty() && getfa(_u[s[bf].top().second]) == getfa(_v[s[bf].top().second])) s[bf].pop();
    if(!s[bf].empty()) S.push({s[bf].top().first - num[bf], s[bf].top().second});
}

signed main() {
    n = read(), m = read(), _s = read(), k = read();
    if(k == 0) return puts("Impossible"), 0;
    rep(i, 1, n) num[i] = P, fa[i] = i;
    rep(i, 1, m) {
        int u = read(), v = read(), w = read();
        if(u == v) continue;
        if(u != _s && v != _s) s[u].push({w, i}), s[v].push({w, i});
        else num[v] = min(num[v], w), num[u] = min(num[u], w);
        _u[i] = u, _v[i] = v;
    }
    rep(i, 1, n) if(i != _s) ans += num[i];
    rep(i, 1, n) if(i != _s) if(num[i] != P) ww ++;
    if(n - 1 == k) {
        if(k > ww || S.empty()) puts("Impossible"); else cout << ans << endl;
        return 0;
    }
    rep(i, 1, n) if(i != _s) if(s[i].size()) {S.push({s[i].top().first - num[i], s[i].top().second});}
    per(_, n - 2, 1) {
        while(!S.empty() && getfa(_u[S.top().second]) == getfa(_v[S.top().second])) S.pop();
        if(!S.empty()) ans += S.top().first; 
        if(_ == k) {
            if(k > ww || S.empty()) puts("Impossible"); else cout << ans << endl;
            return 0;
        }
        merge(_u[S.top().second], _v[S.top().second]);
    } 
    return 0;
}
```

---

## 作者：Polaris_Dane (赞：11)

考虑wqs二分，给特殊的边二分一个权值加上

做一次最小生成树，然后调整这个权值，也就是用来切凸包的直线的斜率

找到最高点后，确定他是在欲求的点的左边还是右边，调整斜率

如果直接暴力排序，会的到$60$分的好成绩

将边分为两类后，使用归并排序就可以通过

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<set>
#include<queue>
#define M 501000
#define inf 0x3f3f3f3f
#define LL long long
const double eps=1e-6;
const int mod=988244353;
using namespace std;
inline int read(){
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while (isdigit(s)){x=(x<<1)+(x<<3)+(s^48),s=getchar();}
	return x*f;
}
int n,m,s,k,tot;
struct edge{
	int to,from,val,col;
	bool operator <(const edge&a)const{
		return val<a.val||(val==a.val&&col>a.col);	
	}
}e[M],cur[M];
vector<edge>st[2];
inline void add_edge(int u,int v,int w){e[++tot].to=v,e[tot].from=u,e[tot].val=w;}
int fa[M],cntcol;
inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline LL kruskal(void){
	for (int i=1;i<=n;i++) fa[i]=i;
	int x=0,y=0,cnte=0;
	for (;x<st[0].size()&&y<st[1].size();){
		if (st[0][x]<st[1][y]) cur[++cnte]=st[0][x],x++;
		else cur[++cnte]=st[1][y],y++;
	}
	for (;x<st[0].size();x++) cur[++cnte]=st[0][x];
	for (;y<st[1].size();y++) cur[++cnte]=st[1][y];
	int cnt=0;LL ans=0;cntcol=0;
	for (int i=1;i<=m;i++){
		if (find(cur[i].to)==find(cur[i].from)) continue;
		fa[fa[cur[i].to]]=cur[i].from,ans+=cur[i].val,cntcol+=cur[i].col,++cnt;
		if (cnt==n-1) return ans;
	}
}
signed main(void){
	n=read(),m=read(),s=read(),k=read();
	for (int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		add_edge(u,v,w);
		if (u==s||v==s) e[i].col=1,st[0].push_back(e[i]);
		else st[1].push_back(e[i]);
	}
	sort(st[0].begin(),st[0].end()),sort(st[1].begin(),st[1].end());
	int l=-1e9,r=1e9;
	for (int i=0;i<st[0].size();i++) st[0][i].val+=l;
	kruskal();
	if (cntcol<k){printf("Impossible");exit(0);}
	for (int i=0;i<st[0].size();i++) st[0][i].val-=l;
	for (int i=0;i<st[0].size();i++) st[0][i].val+=r;
	kruskal();
	if (cntcol>k){printf("Impossible");exit(0);}
	for (int i=0;i<st[0].size();i++) st[0][i].val-=r;
	while (l<r){
		int mid=(l+r+1)>>1;
		for (int i=0;i<st[0].size();i++) st[0][i].val+=mid;
		kruskal();
		for (int i=0;i<st[0].size();i++) st[0][i].val-=mid;
		if (cntcol>=k) l=mid;
		else r=mid-1;
	}
	for (int i=0;i<st[0].size();i++) st[0][i].val+=r;
	printf("%lld",kruskal()-(LL)k*r);
	return 0;
}

```


---

## 作者：Tenshi (赞：7)

## 分析

我们以（生成树中）**与编号 $s$ 相连的边数**（$s$ 的度数）为 $x$ 轴，生成树的最小边权和为 $y$ 轴作出函数曲线。

分析可知，此函数可以在中间**若干个点**达到最小值，这几个点的横坐标都是所有合法的最小生成树中 $s$ 的**度数**。

而沿着这最小值点的左方向，函数值会越来越大，而且增速会越来越快。

同理，沿着最小值点的右方向，函数值也越来越大，而且增速会越来越快。

作出图像就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/elf3qeiu.png)

其中 $D,E$ 就是上文所说的最小值点。

可以发现，作出的函数曲线是一个**下凸壳**，这意味着随着横坐标的增大，斜率是**递增**的。

有了递增的性质，我们就可以利用**斜率**来进行二分了。

比如说，题目要求的 $s$ 度数为 $6$，对应上图的 $C$ 点，那么通过二分斜率便可以找到一条与 $C$ 点“相切”的直线：

![](https://cdn.luogu.com.cn/upload/image_hosting/9avwvb7w.png)

因此，根据函数意义，这个切点 $C$ 的 $y$ 轴坐标就是答案了。

> 从上面的过程就可以发现 wqs 二分的思想了：
>
> 因为直接求 $C$ 的 $y$ 轴坐标是困难的，所以我们从问题所对应的函数的曲线入手，通过找到的**相应的切线**的 $y$ 轴坐标来得到答案。

最后的问题是，怎么找切线呢？

我们就让和 $s$ 相连的边都减去二分值 $mid$，跑一遍最小生成树即可，最小生成树对应的**边权和**就是上图切线与 $y$ 轴的**截距**。而我们要得到切点的 $y$ 轴坐标就只需要让**截距**加上 $cnt \times mid$ 即可，其中 $cnt$ 就是此最小生成树中 $s$ 的度数。

事实上，上面所说的**求切点过程**可以看作是将曲线进行了旋转，然后找到最小值。（个人认为这样理解最好懂）

> 而对于其它的题目，我们就根据题目来求相应的**最值**即可，方法例如：贪心，DP 等。

![](https://cdn.luogu.com.cn/upload/image_hosting/t82i6gs2.png)



### 实现

上面的讲解涉及的细节较少，不妨参考下面的代码进一步理解。

```cpp
// Problem: P5633 最小度限制生成树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5633
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;

#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define pb push_back
#define all(x) (x).begin(), (x).end()

#define x first
#define y second
using pii = pair<int, int>;
using ll = long long;

#define int long long

inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=1e5+5, M=1e6+50;

struct Edge{
	int u, v, w;
	
	bool operator < (const Edge &o)const{
		return w<o.w;
	}
}e[M], es[M], buf[M];

int tot, tots, totb;

int f[N];

int find(int x){
	return x==f[x]? x: f[x]=find(f[x]);
}

int n, m, s, k;
int res, cnt;

int cal(int x){
	rep(i,1,tots) es[i].w-=x;
	res=0, totb=0;
	rep(i,1,n) f[i]=i;
	
	for(int i=1, j=1; i<=tots || j<=tot; ){
		if(i>tots || j<=tot && e[j].w<=es[i].w) buf[++totb]=e[j++];
		else buf[++totb]=es[i++];
	}
	
	cnt=0;
	rep(i,1,totb){
		int u=buf[i].u, v=buf[i].v, w=buf[i].w;
		int pu=find(u), pv=find(v);
		if(pu!=pv){
			f[pu]=pv;
			if(u==s || v==s) cnt++;
			res+=w;
		}
	}
	rep(i,1,tots) es[i].w+=x;
	return cnt;
}

bool is_cc(){
	int g=0;
	rep(i,1,n){
		if(!g) g=find(i);
		else if(g!=find(i)) return false; 
	}
	return true;
}

signed main(){
	cin>>n>>m>>s>>k;
	rep(i,1,n) f[i]=i;
	rep(i,1,m){
		int u, v, w; read(u), read(v), read(w);
		if(u==s || v==s) es[++tots]={u, v, w};
		else e[++tot]={u, v, w};
		f[find(u)]=find(v);
	}
	if(!is_cc()) return puts("Impossible"), 0;
	
	sort(es+1, es+1+tots), sort(e+1, e+1+tot);
	
	int l=-30010, r=-l;
	if(cal(r)<k) return puts("Impossible"), 0;
	if(cal(l)>k) return puts("Impossible"), 0;
	
	while(l<r){
		int mid=l+r+1>>1;
		if(cal(mid)<=k) l=mid;
		else r=mid-1;
	}
	cal(l);

	int t=res+l*k;
	cout<<t<<endl;
	
	return 0;
}
```



---

## 作者：Foreverxxx (赞：5)

广告：[一名Blink的博客](https://www.luogu.com.cn/blog/Foreverxxx/)

感谢出题人 Inkyo 大佬，让我学到了很多。

### 正文

**暴力做法**

记录 s 连出去的所有边，每次枚举 k 条边出来，求生成树，判断是否合法并且更新答案。

**正确做法： wqs 二分**

不要被新算法吓到！很容易理解的。

关于 wqs 二分的详解，可以参考这两篇洛谷日报：

[#366 Flying2018 wqs二分&闵可夫斯基和学习笔记](https://www.luogu.com.cn/blog/Flying2018/wqs-er-fen-min-ke-fu-si-ji-hu-xue-xi-bi-ji)

[#354 Leap_Frog wqs二分 学习笔记](https://www.luogu.com.cn/blog/daniu/wqs-er-fen)

我的做法只是参考了 wqs 二分的思想，做题时想不到很正常，毕竟做题时现想出算法不容易。

既然二分有多种形式，也可以看出此题的答案具有单调性，我们可以大胆地对 s 的所有出边进行二分处理。

**怎么二分呢？**

为了满足 k 条边的限制条件，同时此题又与最小生成树有关，大胆假设以下思路：

我们可以考虑二分一个偏移量 $\Delta$，让 s 的所有出边加上 $\Delta$，然后求一边最小生成树，如果求出的生成树中 s 连的边大于等于 k 条，则调高 $\Delta$ 的值，否则降低 $\Delta$ 的值。

拿样例来辅助理解，其中要求点 1 连的边数量为 1。

这是原来的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/uwo0s4vx.png)

假设此时二分的 $\Delta$ 值为 2，那么图就为：

![](https://cdn.luogu.com.cn/upload/image_hosting/lepwhvju.png)

而我们对新图做一次 Kruskal，求得的生成树就会是这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/9sx1gn7w.png)

可以发现，节点 1 已经连了超过 1 条边，说明我们需要调高 $\Delta$ 使得连向节点 1 的边变少，假设此时二分的 $\Delta$ 值为 10，新图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/sihn2273.png)

那么求得的最小生成树便是：

![](https://cdn.luogu.com.cn/upload/image_hosting/rxai6yez.png)

此时 1 刚好连了 1 条边，我们需要再次调大 $\Delta$，重复进行，如果连边小于 1 条则调小 $\Delta$ 的值，最后输出答案。

对于判断是否有解，有以下几种情况需要考虑：

1、连向 s 的节点的边不足 k 条。

2、原图不连通。

3、**最终二分出的 $\Delta$ 求得的最小生成树连向 s 的边并不是 k 条。**（不判断会被 hack ，主要原因是可以构造数据满足权值大 1 时连了 k-1 条边，而权值小 1 时就连了 k+1 条边）

最后是 AC 代码，有些细节会在代码中提到，帮助理解最小度限制生成树。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh>'9'||chh<'0') chh=getchar();
	while(chh<='9'&&chh>='0'){
		sss=sss*10+chh-'0';
		chh=getchar();
	} 
	return sss;
}
int n,m,s,k;
struct node{
	int u,v,w;
};
int tot_s=0,tot_nots=0;
node edge_s[500004];//用来存储连向s的边 
node edge_nots[500004];//用来存储没有连向s的边 
node edge[500004];//用来存储每次二分时，连向s的边加上偏移量后所有的边，以便之后的 Kruskal求最小生成树 
vector<int> to[50004];//判断是否联通
bool vis[50004];
int fa[50004];
int sum_value=0;//统计加上偏移量之后的最小生成树的权值和，输出的答案只需要减去 k*mid即可 
bool cmp(node x,node y){//按照权值排序 
	return x.w<y.w;
}
void bfs(){
	//bfs对所有扫到的边进行标记操作，用来判断原来的图是否联通 
	queue<int> q;
	q.push(1);
	vis[1]=1;
	while(!q.empty()){
		int x=q.front(); q.pop();
		int len=to[x].size();
		for(register int i=0;i<len;i++){
			int u=to[x][i];
			if(vis[u]) continue;
			vis[u]=1;
			q.push(u);
		}
	}
}
int find(int x){//并查集基本操作 
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
void add_delta(int x){
	for(register int i=1;i<=tot_s;i++) edge_s[i].w+=x;//对所有连向 s 的边加上偏移量 
	/*
	接下来时类似于归并排序的操作
	两种边，用两个指针记录，从而 o(m) 将所有边排好序统计到 edge 中 
	*/
	int i=1,j=1,k=0;
	while(i<=tot_s&&j<=tot_nots){
		if(edge_s[i].w<=edge_nots[j].w){
			k++;
			edge[k]=edge_s[i];
			i++;
		}
		else {
			k++;
			edge[k]=edge_nots[j];
			j++;
		}
	}
	while(i<=tot_s){
		k++;
		edge[k]=edge_s[i];
		i++;
	}
	while(j<=tot_nots){
		k++;
		edge[k]=edge_nots[j];
		j++;
	}
	for(register int i=1;i<=tot_s;i++) edge_s[i].w-=x;//统计完后还原原来的图 
}
bool check(int x){
	for(register int i=1;i<=n;i++) fa[i]=i;//初始化并查集 
	add_delta(x);
	sum_value=0; 
	int cnt=0;//记录此时s有多少条连边 
	int waiting=n;//一共有n个点需要连边 
	for(register int i=1;i<=m;i++){
		if(waiting==1) break;
		int fau=find(edge[i].u),fav=find(edge[i].v);
		if(fau==fav) continue;
		if(edge[i].u==s||edge[i].v==s) cnt++;//如果这条边有节点为s，则 cnt++ 
		waiting--;//少了一个点需要加入生成树 
		sum_value+=edge[i].w;//统计生成树总的权值 
		fa[fau]=fav;//并查集合并操作 
	}
	return cnt>=k;
}
bool check_ans(int x){
	//对最终的二分结果进行判断，和上面的check函数差不多，只不过 return 条件变为了 cnt==k 
	for(register int i=1;i<=n;i++) fa[i]=i;
	add_delta(x);
	sum_value=0;
	int cnt=0;
	int waiting=n;
	for(register int i=1;i<=m;i++){
		int fau=find(edge[i].u),fav=find(edge[i].v);
		if(fau==fav) continue;
		if(edge[i].u==s||edge[i].v==s) cnt++;
		waiting--;
		sum_value+=edge[i].w;
		fa[fau]=fav;
		if(waiting<=1) break;
	}
	return cnt==k;
}
int main(){
	n=read(),m=read(),s=read(),k=read();
	int uu,vv,ww;
	for(register int i=1;i<=m;i++){
		uu=read(),vv=read(),ww=read();
		if(uu==s||vv==s){
			tot_s++;
			edge_s[tot_s].u=uu;
			edge_s[tot_s].v=vv;
			edge_s[tot_s].w=ww;
		}
		else {
			tot_nots++;
			edge_nots[tot_nots].u=uu;
			edge_nots[tot_nots].v=vv;
			edge_nots[tot_nots].w=ww;
		}
		to[uu].push_back(vv);
		to[vv].push_back(uu);//用来判断是否联通 
	}
	if(tot_s<k){
		cout<<"Impossible";
		return 0;
	}
	bfs();
	for(register int i=1;i<=n;i++){
		if(!vis[i]){//如果bfs之后有点没有被扫到，则说明图并不联通 
			cout<<"Impossible";
			return 0;
		}
	}
	sort(edge_s+1,edge_s+tot_s+1,cmp);//先初始化对两种边进行排序,能够优化掉add操作的一个log 
	sort(edge_nots+1,edge_nots+tot_nots+1,cmp);
	int l=-300001,r=300001,mid;//最小值：s所有出边权值均为0 最大值：s所有出边的权值为图中的最大
	//注意二分的区间应与题目描述对应，否则可能被卡常 
	int ans=0;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)){
			l=mid+1;  
			ans=mid;//注意每次判断可行后直接更新ans，不需要进行大小比较操作，否则会造成sum_value与ans不对应，很容易理解
			//即ans和sum_value应该同时更新 
		}
		else r=mid-1;
	}
	if(!check_ans(ans)){
		cout<<"Impossible";
		return 0;
	}
	cout<<sum_value-k*ans;
	return 0;
}
```


---

## 作者：封禁用户 (赞：4)

# P5633 最小度限制生成树题解
## 定义
在一张无向带权图中，找出一棵生成树，使得某个特定结点的度数不超过 $K$ 或者恰好等于 $K$ 的，并且权值和最小。
## 求解算法
首先我们对不与特殊结点相连的边求最小生成树，得到几个连通分量。然后找出每个连通分量到特殊结点的最短的边，把这条边添加到生成树中，这样我们就得到了一个度限制为连通分量数的最小生成树。如果有连通分量到特殊结点没有边，则说明无法构成生成树。如果连通分量数大于 $K$ ，则说明无法在度数限制下构成生成树。对于当前求得的 $K$ 度生成树，我们可以求出 $K+1$ 度生成树，方法如下。令特殊结点为根结点，首先对当前生成树进行一次树形 DP 求出任意一点到根节点的不与最长边，然后枚举当前不在树中的各条与跟结点相连的边，如果把它加到生成树中，则要去掉它指向的点到跟结点最长的一个边。这样我们就可以知道添加每条边生成树权值和的变化情况，选择令权值和最小的一条边即可。如果当前没有个替换的边对则无法得到 $K+1$ 度的生成树。

总时间复杂度 $O( E \times logE + K \times V)$
## Code
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <string>
#include <map>
using namespace std;
#define INF 0x3f3f3f3f
#define mem(a,b) memset((a),(b),sizeof(a))

const int MAXLEN=10+3;
const int MAXV=20+3;
const int MAXE=MAXV*MAXV;

struct Edge
{
    int from, to, cost;
    bool operator < (const Edge &other)const
    {
        return cost<other.cost;
    }
}edge[MAXE];//保存图中的所有边

int V, E, K;//结点数，边数，度数限制
int par[MAXV], high[MAXV];//并查集数组
int G[MAXV][MAXV];//图的邻接矩阵表示（没有边，花费为INF）
bool in_tree[MAXV][MAXV];//在生成树中标记
int the_min[MAXV];//连通块到特殊点的最近的边
Edge dp[MAXV];

int findfather(int x)
{
    return par[x]=par[x]==x?x:findfather(par[x]);
}

bool unite(int a, int b)//并查集合并
{
    int fa=findfather(a), fb=findfather(b);
    if(fa==fb)
        return false;
    if(high[fa]>high[fb])
        par[fb]=fa;
    else
    {
        par[fa]=fb;
        if(high[fa]==high[fb])
            ++high[fb];
    }
    return true;
}

void dfs(int u, int fa)
{
    for(int v=1;v<=V;++v)
        if(v!=fa && in_tree[u][v])
        {
            if(fa==-1)
                dp[v].cost=-INF;
            else
            {
                if(G[u][v]>dp[u].cost)
                {
                    dp[v].from=u;
                    dp[v].to=v;
                    dp[v].cost=G[u][v];
                }
                else dp[v]=dp[u];
            }
            dfs(v, u);
        }
}

bool degree_limit_tree()//返回是否能构成满足要求的树，形成的树保存在in_tree数组中
{
    //初始化
    for(int i=1;i<=V;++i)
    {
        par[i]=i;
        high[i]=0;
        for(int j=1;j<=V;++j)
            in_tree[i][j]=false;
    }
    //Kruskal计算求不与特殊点连接的边的最小生成树
    sort(edge+1, edge+1+E);
    for(int i=1;i<=E;++i)
    {
        if(edge[i].from>edge[i].to)
            swap(edge[i].from, edge[i].to);
        if(edge[i].from!=1 && unite(edge[i].from, edge[i].to))
            in_tree[edge[i].from][edge[i].to]=in_tree[edge[i].to][edge[i].from]=true;
    }
    //把各个连通块连接到特殊点
    for(int i=1;i<=V;++i)
        the_min[i]=-1;
    for(int i=1;i<=E;++i)
        if(edge[i].from==1)
        {
            int fa=findfather(edge[i].to);
            if(the_min[fa]==-1 || edge[i].cost<edge[the_min[fa]].cost)
                the_min[fa]=i;
        }
    int deg=0;//根节点度数
    for(int i=2;i<=V;++i)
        if(~the_min[i])
        {
            int id=the_min[i];
            in_tree[edge[id].from][edge[id].to]=G[edge[id].to][edge[id].from]=true;
            ++deg;
        }
        else if(the_min[findfather(i)]==-1)//有连通块无法连接到根节点
            return false;
    if(deg>K)//无法在限制内构成生成树
        return false;
    dp[1].cost=-INF;
    //不断增加特殊结点的度数
    for(++deg;deg<=K;++deg)
    {
        int add=INF, index=-1;
        dfs(1, -1);
        for(int v=2;v<=V;++v)
            if(G[1][v]!=INF && !in_tree[1][v] && add>G[1][v]-dp[v].cost)
            {
                add=G[1][v]-dp[v].cost;
                index=v;
            }
        if(add>=0)//不能使答案更小，跳出
            break;
        in_tree[1][index]=in_tree[index][1]=true;
        in_tree[dp[index].from][dp[index].to]=in_tree[dp[index].to][dp[index].from]=false;
    }
    return true;
}

map<string, int> to_id;

inline int get_id(char s[])
{
    int res=to_id[s];
    if(!res)
        to_id[s]=res=++V;
    return res;
}

void init()
{
    V=1;
    to_id.clear();
    to_id["Park"]=1;
    mem(G, 0x3f);
}

int main()
{
    while(~scanf("%d", &E))
    {
        init();
        for(int i=1;i<=E;++i)
        {
            char s[MAXLEN];
            scanf("%s", s);
            edge[i].from=get_id(s);
            scanf("%s", s);
            edge[i].to=get_id(s);
            scanf("%d", &edge[i].cost);
            if(G[edge[i].from][edge[i].to]>edge[i].cost)
                G[edge[i].from][edge[i].to]=G[edge[i].to][edge[i].from]=edge[i].cost;
        }
        scanf("%d", &K);
        degree_limit_tree();
        int ans=0;
        for(int i=1;i<=V;++i)
            for(int j=i+1;j<=V;++j)
                if(in_tree[i][j])
                    ans+=G[i][j];
        printf("Total miles driven: %d\n", ans);
    }

    return 0;
}
```

---

## 作者：Purslane (赞：4)

## Solution

稍微讲一下 wqs 二分 . 如果仍看不懂的话可以看一下这一篇 , 蛮不错的 : [Link](https://zhuanlan.zhihu.com/p/340514421)

设 $f(x)$ 表示点 $s$ 的出度为 $x$ 的时候的答案 .

考虑从 $x-1$ 转移过来 . 我们应当找 $s$ 的一条边 , 给它填上去 . 这时候肯定有一个环 . 我们删掉环上面的原先最大值 . 新的答案减去了那个最大值 , 加上了当前的值 . 

然后证明这个东西有凹凸性 . 考虑当前新加入一条边 , 它新产生的贡献肯定比之前变大 .

> 如果变小的话 , 那我们可以先加入这条边 , 那么 $f(x-1)$ 就会更小 , 与定义不符 . 这样还是不大严谨 , 需要考虑连通性的问题 . 可以不深究 . 如果非要深究的 , 那么 $x-1$ 次加边后 , 再 $x$ 加边 , $x$ 加的边所在的环上可能有上一次加的边 , 但是把这两次加边调换一下 , 后面那次加边删去的最大值肯定还能删 , 甚至可以删更大的 , 所以此时 $f(x-1)$ 会更优 .

wqs 二分是二分斜率 , 也就是 $f(x)-f(x-1)$ . 把 $(x,f(x))$ 这个东西放到坐标系上 , 每次找到谁的斜率是 $c$ . 画几个图可以发现 , 如果每个点画一个斜率是 $c$ 的直线 , 那么它们截距的最小的那个就是所求 .

考虑截距的实际含义 : $b=f(x)-cx$ , 相当于每条出边的大小加上 $-c$ . 那我们把每条出边加上 $-c$ , 是不是就可以跑 MST , 求出所求点 .

然后根据所求点和 $k$ 的大小关系 , 可以调整斜率 , 直到找到了 $k$ . 最后我们就可以算出来 $f(k)$ 加上某些数之后的值了 , 然后把多余的减掉 .

判断 `Impossible` : 这非常恶心 . 一下情况不可以 :

- 不连通
- 只能达到比 $k$ 小 . 这时候就是出度过少 , 容易判断 .
- 只能达到比 $k$ 大 . 就像这组数据 :

```cpp
3 2 1 1
1 2 1
1 3 1
```
我们的程序很难判断 , 所以从右边逼近它 (具体说 , 就是找出度大于等于 $k$的最小值) , 然后更具定义 , 如果能达到 $k$ , 那么将找到的斜率减小一点 , 就一定对应一个小于 $k$ 的数 . 这时候判断就可以啦 .

并且注意 , 为了降低复杂度 , 我们归并排序 .

code :

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
#define int long long
using namespace std;
const int MAXN=3e5+10;
int n,m,s,k,cnt,res,ccnt,fa[MAXN];
int find(int k) {
	return (fa[k]==k)?k:(fa[k]=find(fa[k]));	
}
vector<pair<int,pair<int,int>>> a,b;
vector<pair<int,pair<int,int>>> merge(vector<pair<int,pair<int,int>>> a,vector<pair<int,pair<int,int>>> b) {
	vector<pair<int,pair<int,int>>> res;
	int l=0,r=0;
	while(l<a.size()&&r<b.size()) {
		if(a[l]<b[r]) res.push_back(a[l]),l++;
		else res.push_back(b[r]),r++;
	}
	ffor(i,l,(int)(a.size())-1) res.push_back(a[i]);
	ffor(i,r,(int)(b.size())-1) res.push_back(b[i]);
	return res;
}
int get_ans(int k) {
	vector<pair<int,pair<int,int>>> c;
	ffor(i,0,(int)a.size()-1) c.push_back({a[i].first+k,a[i].second});
	vector<pair<int,pair<int,int>>> tmp=merge(c,b);
	ffor(i,1,n) fa[i]=i; cnt=0,res=0,ccnt=0;
	for(auto V:tmp) {
		int w=V.first,u=V.second.first,v=V.second.second;
		if(find(u)==find(v)) continue;
		if(u==s||v==s) cnt++;
		u=find(u),v=find(v);
		res+=w,ccnt++,fa[u]=v;	
	}
	if(ccnt<n-1) return -1;
	return cnt;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>s>>k;
	ffor(i,1,m) {
		int u,v,w;
		cin>>u>>v>>w;
		if(u==s||v==s) a.push_back({w,{u,v}});
		else b.push_back({w,{u,v}});	
	}
	if(a.size()<k) {cout<<"Impossible";return 0;}
	sort(a.begin(),a.end()),sort(b.begin(),b.end());
	int l=-INT_MAX,r=INT_MAX,ans=-LONG_LONG_MAX;
	if(get_ans(l)<0) {cout<<"Impossible";return 0;}
	while(l<=r) {
		int mid=(l+r>>1),v=get_ans(-mid);
		if(v>=k) ans=mid,r=mid-1;
		else l=mid+1;
	}
	if(ans==-LONG_LONG_MAX) {cout<<"Impossible";return 0;}
	ans--;get_ans(-ans);
	if(cnt>k) {cout<<"Impossible";return 0;}
	ans++;
	get_ans(-ans);
	cout<<res+ans*k;
	return 0;	
}
```

---

## 作者：FjswYuzu (赞：4)

看到对一个特殊的点进行限制，我们不难想到用 wqs 二分进行计算。对所有连向 $s$ 的边进行定量偏移，使所有连向 $s$ 的边的边权 $q$ 加上二分的定量 $\Delta$。这个问题就变成了一个可行性问题。

具体做法是，我们修改之后可以求出最小生成树，这个过程中我们显然可以计算连接到 $s$ 的边有多少条。如果连接到 $s$ 的边数大于等于 $k$，我们就提高下界；否则降低上界。接下来我们得到了一个准确的 $\Delta$，答案就是当前求出的最小生成树边权和再减去 $k \times \Delta$。

一些无解的情况：

- 图不连通；   
- 连接至 $s$ 的边不够 $k$ 条；   
- $\Delta$ 最小时不能够满足要求；   
- 二分出最后的 $\Delta$ 无法满足要求。

这样还是会 T。考虑优化，我们每次将边排序的时候分两类（是否连接 $s$）排序，连接 $s$ 的边优先级更高。然后跑 Kruskal 算法即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
struct UnionFindSet{
	LL fa[50005];
	void makeSet(LL upper){for(LL i=0;i<=upper;++i)	fa[i]=i;}
	LL findSet(LL x)
	{
		if(x==fa[x])	return fa[x];
		return fa[x]=findSet(fa[x]);
	}
	void unionSet(LL x,LL y)
	{
		LL xx=findSet(x),yy=findSet(y);
		if(xx==yy)	return ;
		fa[xx]=yy;
	}
	bool bunionSet(LL x,LL y)
	{
		LL xx=findSet(x),yy=findSet(y);
		if(xx==yy)	return false;
		fa[xx]=yy;
		return true;
	}
}ufs;
struct Edge{
	LL u,v,val;
	Edge(){u=v=val=0;}
	Edge(LL U,LL V,LL va){u=U,v=V,val=va;}
	bool operator < (Edge another) const {return val<another.val;}
}e1[500005],e2[500005],g[500005];
LL n,m,s,t1,t2,valt;
void msort(LL delta)
{
	for(LL i=1;i<=t1;++i)	e1[i].val+=delta;
	LL i=1,j=1,k=0;
	while(i<=t2 && j<=t1)
	{
		if(e2[i]<e1[j])	g[++k]=e2[i++];
		else	g[++k]=e1[j++];
	}
	while(j<=t1)	g[++k]=e1[j++];
	while(i<=t2)	g[++k]=e2[i++];
	for(LL l=1;l<=t1;++l)	e1[l].val-=delta;
}
/*
void msort(int delta)
{
	for(int i=1;i<=t1;++i)	e1[i].val+=delta;
	int i=1,j=1,k=0;
	while(i<=t1 && j<=t2)
	{
		if(e1[i]<e2[j])	g[++k]=e1[i++];
		else	g[++k]=e2[j++];
	}
	while(i<=t1)	g[++k]=e1[i++];
	while(j<=t2)	g[++k]=e2[j++];
	for(int l=1;l<=t1;++l)	e1[i].val-=delta;
}
*/
LL k;
bool check(LL delta)
{
	msort(delta);
	LL cnt=0;
	valt=0;
	ufs.makeSet(n);
	LL blk=n;
	for(LL i=1;i<=m;++i)
	{
		if(!ufs.bunionSet(g[i].u,g[i].v))	continue;
		cnt+=LL(g[i].u==s || g[i].v==s);
		valt+=g[i].val;
		--blk;
		if(blk<=1)	break;
	}
	return cnt>=k;
}
bool specialCheck(LL delta)
{
	msort(delta);
	LL cnt=0;
	valt=0;
	ufs.makeSet(n);
	LL blk=n;
	for(LL i=1;i<=m;++i)
	{
		if(!ufs.bunionSet(g[i].u,g[i].v))	continue;
		cnt+=LL(g[i].u==s || g[i].v==s);
		valt+=g[i].val;
		--blk;
		if(blk<=1)	break;
	}
	return cnt==k;
}
//bool check(LL delta)
//{
//	msort(delta);
//	ufs.makeSet(n);
//	LL cnt=0;
//	valt=0;
//	for(LL i=1;i<=m;++i)
//	{
//		if(ufs.bunionSet(g[i].u,g[i].v))
//		{
//			if(g[i].u==s || g[i].v==s)	++cnt;
//			valt+=g[i].val;
//		}
//	}
//	printf("%d\n",cnt);
//	return cnt>=k;
//}
int main(){
	scanf("%lld %lld %lld %lld",&n,&m,&s,&k);
	for(LL i=1;i<=m;++i)
	{
		LL u,v,val;
		scanf("%lld %lld %lld",&u,&v,&val);
		if(u==s || v==s)	e1[++t1]=Edge(u,v,val);
		else	e2[++t2]=Edge(u,v,val);
	}
	if(t1<k)	return puts("Impossible")&0;
	ufs.makeSet(n);
	LL blk=n;
	for(LL i=1;i<=t1;++i)	blk-=ufs.bunionSet(e1[i].u,e1[i].v);
	for(LL i=1;i<=t2;++i)	blk-=ufs.bunionSet(e2[i].u,e2[i].v);
	if(blk!=1)	return puts("Impossible")&0;
	sort(e1+1,e1+1+t1);
	sort(e2+1,e2+1+t2);
	LL l=-10000000ll,r=10000000ll,ans=-10000000ll;
	if(!check(l))	return puts("Impossible")&0;
	while(l<=r)
	{
		LL mid=(l+r)>>1;
		if(check(mid))	l=mid+1,ans=mid;
		else	r=mid-1;
	}
	check(ans);
	if(!specialCheck(ans))	return puts("Impossible")&0;
	printf("%lld",valt-k*ans);
	return 0;
}
```

---

## 作者：liaiyang (赞：3)

~~听说可以用拟阵证明下凸性。~~

感性理解一下发现有下凸性，考虑 wqs 二分。

我们将所有 $s$ 的出度 $+\Delta$ （可以为负数），然后跑 kruskal，时间复杂度大致是 $O(m\log m\log V)$ 的，无法接受。

我们发现优化并查集后瓶颈在于排序，我们就将 $s$ 的所有出边在一开始就排序，加上 $\Delta$ 后顺序不变，归并即可，最后减回去即可，记得归并时尽量将 $s$ 出边靠前。

时间复杂度 $O(m\log V)$，可以通过。

注意判掉无解的情况，就是 $\Delta=\infty$ 时选出了 $>k$ 条边或 $\Delta=-\infty$ 时选出了 $<k$ 条。

注意数据可以构造 $\Delta-1$ 时选出 $k+1$ 条边，$\Delta$ 时选出 $k-1$ 条边，这时由于下凸，$k+1$ 条边的方案一定和 $k$ 条边的方案一样，只是差了几条相等的边，直接统计即可，注意不要多减 $\Delta$。

```cpp
#include<bits/stdc++.h>
using namespace std;
// #pragma GCC optimize(1)
// #pragma GCC optimize(2)
// #pragma GCC optimize(3,"Ofast")
#define int long long
#define y0 Y0
#define y1 Y1
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define min(a,b) (a<b?a:b) 
#define max(a,b) (a>b?a:b)
#define P pair<int,int>
#define x first
#define y second
#define modd(x) (((x)%mod+mod)%mod) 
#define rd read()
#define lowbit(x) ((x)&(-x))
#define abs(x) ((x)<0?-(x):(x))
#define submod(x,y,mod) (((x-=y)<0)&&(x+=mod))
#define addmod(x,y,mod) (((x+=y)>=mod)&&(x-=mod))
mt19937 rnd(time(0));
char buf[(1<<21)+10],*p1=buf,*p2=buf,obuf[(1<<21)+10],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#define putchar(x) (O-obuf<(1<<21)?*O++=(x):(fwrite(obuf,1,1<<21,stdout),O=obuf,*O++=(x)))
inline int read(int u=0, char c=getchar(), bool f=false){
	for(;!isdigit(c);c=getchar()) f|=c=='-';
	for(;isdigit(c);c=getchar()) u=(u<<1)+(u<<3)+(c^'0');
	return f?-u:u;
}
inline void wt(int x){
	if(x<0) x=-x,putchar('-');
	if(x>9) wt(x/10);
	putchar((x%10)^'0');
}
inline void wt(int x,char k){wt(x),putchar(k);}
const int inf=~0U>>1,linf=~0ULL>>1;
const int mod=998244353,g=3,gi=332748118;
const int N=5e4+10,M=5e5+10;
int n,m,s,k,cnt1,cnt2,f[N],sz[N];
struct node{
	int u,v,w;
	bool operator<(const node v)const{return w<v.w;}
}a[M<<1],b[M<<1],c[M<<1];
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(x==y) return ;
	if(sz[x]<sz[y]) swap(x,y);
	sz[x]+=sz[y],f[y]=x,sz[y]=0;
}
P check(int x){
	for(int i=1;i<=n;i++) f[i]=i,sz[i]=1;
	int tot1=1,tot2=1;
	for(int i=1;i<=m;i++)
		if(c[tot2].w+x<=b[tot1].w) a[i]=c[tot2++],a[i].w+=x;
		else a[i]=b[tot1++];
	int cnt=0,sum=0,ct=0;
	for(int i=1;i<=m;i++){
		if(find(a[i].u)==find(a[i].v)) continue;
		merge(a[i].u,a[i].v);sum+=a[i].w;cnt+=(a[i].u==s||a[i].v==s);
		if(++ct==n-1) break;
	}
	return {cnt,sum};
}
main(){
	//freopen("wind.in","r",stdin);
	//freopen("wind.out","w",stdout);
	n=rd,m=rd,s=rd,k=rd;
	for(int i=1;i<=m;i++){
		int u=rd,v=rd,w=rd;
		if(u==s||v==s) c[++cnt2]={u,v,w};
		else b[++cnt1]={u,v,w};
	}b[cnt1+1].w=c[cnt2+1].w=1e18;
	sort(b+1,b+cnt1+1);sort(c+1,c+cnt2+1);
	int l=-1e9,r=1e9;
	while(l<r-1){
		int mid=l+r>>1;
		if(check(mid).x>=k) l=mid;
		else r=mid;
	}
	if(check(-1e9).x<k||check(1e9).x>k) return puts("Impossible"),0;
	wt(check(l).y-k*l,'\n');
	fwrite(obuf,1,O-obuf,stdout);
	return 0;
}
```

---

## 作者：bigju (赞：2)

# 题意

~~这还用说吗，题面上写的很清楚吧。~~

# 做法

提供一种不用归并排序优化的方法。我们发现朴素算法的慢主要在于进行了太多次的 Kruskal，但是我们不会归并优化，如何减少判断次数呢？

我们发现题目中 $w$ 的范围较小，因此我们可以适当的缩小二分的上下限来减少执行判断的次数，然后吸着氧就过了。

[Code](https://www.luogu.com.cn/paste/4h799mzs)

[Record](https://www.luogu.com.cn/record/60169286)

---

## 作者：_xxxxx_ (赞：1)

### 前言

看大佬们都用的是我看不懂的代码过的，我就写了一份个人认为比较易懂的代码。

### 分析


对于这种有限制的操作，考虑 wqs 二分，其实这题也挺板的。

这题与 P2619 挺像的，方式是互通的。

简化问题，如果没有 $k$ 这个限制，就仅仅是跑一遍最小生成树了。但现在我们需要 $s$ 点**正好**连上 $k$ 条边。

回想一下，在一般的 `kruskal` 算法中，我们贪心将边权小的边放在前面进行处理，我们是否可以干预一下这个操作，使得与 $s$ 相连的边在前面呢？

答案是可以的，我们二分出一个偏移量 $mid$，使得若干有限制的边加上 $mid$ 排到无限制的边前面，通过改变 $mid$，可以控制出这些有限制的边的分布，我们每次跑 `kruskal`，同时统计与 $s$ 相连的边的个数 $num$，根据 $num$ 与 $k$ 的大小二分。

具体来说，我们使与 $s$ 相连的边加上 $mid$ 后跑 `kruskal`，跑 `kruskal` 的时候记录与 $s$ 相连的边的个数 $num$。当 $num\ge k$ 时，记录答案 $ans$，可以尝试使偏移量增大，使左端点 $l=mid+1$，当 $num<k$ 时，数量不够，尝试使偏移量变小来让与 $s$ 相连的边更前，即使右端点 $r=mid-1$。

一开始将与 $s$ 相连的边置为无限大，跑一下最小生成树，如果 $num>k$ 就直接输出 `Impossible` 即可。否则会被 hack 一个点。

另外注意一下二分的值域，以及排序时应使与 $s$ 相连的边放在前面，具体也可以看代码。

### 代码

应该比较好理解吧。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, s, k;
const int N = 8e5 + 10;
struct node
{
    int x, y, w, id;
}p[N];
int fa[N];
int find(int x)
{
    return (x == fa[x] ? x : fa[x] = find(fa[x]));
}
int cnt, sum , num;
void init()
{
    cnt = sum = num = 0;
    for(int i = 1; i <= n; i++) fa[i] = i;
    //记得初始化
}
bool cmp(node a, node b)
{
    if(a.w == b.w) return a.id > b.id;//把与s相邻的边放前面，更容易取到
    return a.w < b.w;
}
int ans = -1;
void kruskal()
{
    //正常的kruskal
    sort(p + 1, p + m + 1, cmp);
    for(int i = 1; i <= m; i++)
    {
        int fx = find(p[i].x), fy = find(p[i].y);
        if(fx == fy) continue;
        fa[fx] = fy;
        cnt++;
        sum += p[i].w;
        num += p[i].id;
        if(cnt >= n - 1) return ;
    }
}
bool check()
{
    //设为无限大
    for(int i = 1; i <= m; i++) if(p[i].id) p[i].w += 1e9;
    init();
    kruskal();
    if(num > k) return 1;
    for(int i = 1; i <= m; i++) if(p[i].id) p[i].w -= 1e9;
    return 0;
}
signed main()
{
    scanf("%lld%lld%lld%lld", &n, &m, &s, &k);
    int br = 0;
    for(int i = 1; i <= m; i++)
    {
        int x, y, w;
        scanf("%lld%lld%lld", &x, &y, &w);
        p[i].x = x, p[i].y = y;
        p[i].w = w;
        p[i].id = (p[i].x == s || p[i].y == s);//记录一下
    }
    if(check())//一开始跑一遍
    {
        printf("Impossible\n");
        exit(0);
    }
    int l = -30010, r = 30010;
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        for(int i = 1; i <= m; i++) if(p[i].id) p[i].w += mid;//改变与s相邻的边
        init();
        kruskal();
        if(num >= k)
        {
            l = mid + 1;
            ans = sum - k * mid;//修改放回来，还原出原来的答案
        }
        else r = mid - 1;
        for(int i = 1; i <= m; i++) if(p[i].id) p[i].w -= mid;//记得改回来
    }
    if(ans == -1) printf("Impossible");
    else printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：_Arahc_ (赞：1)

wqs 二分，但是没有归排。

## wqs

我们考虑朴素地用 kruscal 构造一个生成树，是按照边权加边的。这种方法显然无法保证 $s$ 的度。

因此我们考虑把和 $s$ 相邻的边的边权修改一下，使得最后的生成树能让 $s$ 有那么多的度数。

具体的修改方法，我们可以 wqs 二分一个 $\Delta$，每次让和 $s$ 相邻的点的边权都加上 $\Delta$。然后用朴素地 kruscal 跑就可以了。

根据常识，如果这次尝试中 $s$ 的度多于限制，就要让边权更大使得其更不容易被选到；如果更少就同理。

无解的情况不算很多：

+ 原图不连通（没有最小生成树）。
+ $s$ 的度本身就不到 $k$。
+ 二分得到的 $\Delta$ 不能使 $s$ 的度达到 $k$。即二分到无解。

我们发现前两种情况都可以归化为第三种情况：如果原图不连通或者 $s$ 的度本身就没有达到 $k$，那么二分出来的 $\Delta$ 一定不能满足条件。

因此我们只需要判断第三种条件就可以了。

----

如果按照以上方法裸地实现，你会发现你有 T。

我们考虑上面代码的复杂度是什么，假设二分的值域范围为 $a$，本题中也就是大家的 $(-\infty,\infty)$。每次二分排序一遍所有的边，然后跑一遍 kruscal，总复杂度 $\operatorname{O}(m\log m\log a)$。

我们进一步发现，因为每次都只修改了和 $s$ 相邻的边，那么我们把这一类边单独提出来。和不与 $s$ 相邻的边分开，记为 $1$ 类边和 $2$ 类边。

两类边分别排序之后，并不需要每次归并，因为给一类边所有权值加上一个 $\Delta$ 后，相对大小不改变，因此只需要在二分前分别排好序，后面就没必要排序了。kruscal 里面直接判断此时一类边边权小还是二类边边权小即可。

复杂度 $\operatorname{O}(m\log a)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=50004,max_m=500005;
inline int read(){
    int x=0;bool w=0;char c=getchar();
    while(c<'0' || c>'9') w|=c=='-',c=getchar();
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return w?-x:x;
}
inline void write(int x){
    if(x<0){// 懒，直接在快写里面判无解
        puts("Impossible");
        return;
    }
    if(x>9) write(x/10);
    putchar(x%10^48);
}

int n,m,s,k,m1,m2;

struct edge{
    int u,v,w;
    bool operator < (const edge &b) const{
        edge a=*this;
        return a.w<b.w;
    }
}e1[max_m],e2[max_m]; // e1 一类边；e2 二类边
inline edge makee(int x,int y,int z){
    edge res;
    res.u=x,res.v=y,res.w=z;
    return res;
}

struct par{ // 习惯，手写 pair
    int x,y;
};
inline par makep(int x,int y){
    par res;
    res.x=x,res.y=y;
    return res;
}

struct Union{
    int fa[max_n],sz[max_n],n;
    inline void init(int x){
        n=x;
        for(register int i=1;i<=n;++i)
            fa[i]=i,sz[i]=1;
    }
    inline int find(int x){
        if(x==fa[x]) return x;
        return fa[x]=find(fa[x]);
    }
    inline bool merge(int x,int y){
        x=find(x),y=find(y);
        if(x==y) return 0;
        if(sz[x]>sz[y]) x^=y^=x^=y;
        sz[y]+=sz[x],fa[x]=y;
        return 1;
    }
}uf;

inline par check(int mid){ // kruscal
    if(mid) for(register int i=1;i<=m1;++i)
        e1[i].w+=mid;
    uf.init(n);
    int res1=0,res2=0;
    for(register int i=1,j1=1,j2=1;i<n;){
        if(j1>m1 && j2>m2 && i<n-1) // 两种边都用完了，还没有选够，说明图不连通，无解
            return makep(-1,-1);
        if(j1<=m1 && (j2>m2 || e1[j1].w<=e2[j2].w)){ // 选 1 类
            int u=e1[j1].u,v=e1[j1].v;
            if(uf.merge(u,v)){
                ++res1,res2+=e1[j1].w,
                ++i;
            }
            ++j1;
        }
        else if(j2<=m2 || j1>m1){ // 选 2 类
            int u=e2[j2].u,v=e2[j2].v;
            if(uf.merge(u,v)){
                res2+=e2[j2].w,
                ++i;
            }
            ++j2;
        }
    }
    if(mid) for(register int i=1;i<=m1;++i)
        e1[i].w-=mid;
    return makep(res1,res2-res1*mid);
}// res1：s 的度，res2：最小生成树大小，记得减去偏移量

inline int erfen(int l,int r){
    --l,++r;int ans=0;
    while(l<r-1){
        int mid=(l+r)>>1;par res=check(mid);
        if(res.x==k)
            l=mid,ans=mid;
        else if(res.x<k)
            r=mid;
        else
            l=mid;
    }
    par res=check(ans);
    if(res.x!=k) return -1; // 最后二分到的答案无解
    return res.y;
}

signed main(){
//  freopen(".in","r",stdin),
//  freopen(".out","w",stdout);
    n=read(),m=read(),s=read(),k=read();
    for(register int i=1;i<=m;++i){
        int u=read(),v=read(),w=read();
        if(u==s || v==s)
            e1[++m1]=makee(u,v,w);
        else
            e2[++m2]=makee(u,v,w);
    }
    sort(e1+1,e1+1+m1),sort(e2+1,e2+1+m2);
    write(erfen(-30000,30000));
    return 0;
}
```

---

## 作者：Fzrcy (赞：0)

因为题目要求编号为 $s$ 的节点**恰好**连了 $k$ 条边的最小生成树权值和 $f(k)$ 最小，所以我们考虑 wqs二分。

然后二分一个斜率 $t$，对于每个与 $s$ 相连的边权值减去 $t$（判断完后要变回去），然后对新图跑最小生成树算法即可。

>  注意：要考虑到函数 $f(k)$ 存在三点共线的情况，因此要么尽量少选与 $s$ 相连的边要么尽量多选与 $s$ 相连的边，以免出现错误。

如果你在判断函数中直接用 `sort` 的话，总时间复杂度是 $O(n\log n\log V)$ 的，正确的做法是将与 $s$ 相连的边和没有与与 $s$ 相连的边分开，跑最小生成树算法前归并排序即可。

对于无解有两种情况：

- 不存在编号为 $s$ 的节点恰好连了 $k$ 条边的生成树。
- 原图不连通。

```cpp
// qwq
#include <bits/stdc++.h>
#define RG register
#define R RG int
using ll=long long;
using namespace std;
struct Edge{
    int u,v,fl;ll w;
    bool operator < (const Edge& b)const
        {return w<b.w;}
};
constexpr int N=1e6+2;
Edge e[N],g[N],s[N];
int m1,m2;
int fa[N],n,m,rt,rtc;
ll sum;
int gf(R x){return fa[x]==x?x:fa[x]=gf(fa[x]);}
void mer(){
    R c=1,i=1,j=1;
    while(i<=m1&&j<=m2){
        if(e[i].w<g[j].w)s[c]=e[i++];
        else s[c]=g[j++];
        c++;
    }
    while(j<=m2)s[c]=g[j++],c++;
    while(i<=m1)s[c]=e[i++],c++;
}
void kru(ll mid){
    for(R i=1;i<=m1;i++)e[i].w-=mid;
    sum=rtc=0;mer();
    for(R i=1;i<=n;i++)fa[i]=i;
    for(R i=1,x,y;i<=m;i++)
        if(gf(x=s[i].u)^gf(y=s[i].v))
            fa[gf(x)]=gf(y),sum+=s[i].w,rtc+=s[i].fl;
    for(R i=1;i<=m1;i++)e[i].w+=mid;
}
int main(){
    R K;cin>>n>>m>>rt>>K;
    for(R i=1,x,y,z;i<=m;i++){
        cin>>x>>y>>z;
        if(x==rt||y==rt)e[++m1]={x,y,1,z};
        else            g[++m2]={x,y,0,z};
    }
    sort(e+1,e+m1+1),sort(g+1,g+m2+1);
    kru(4e9); if(rtc<K){puts("Impossible"),exit(0);}
    kru(-4e9);if(rtc>K){puts("Impossible"),exit(0);}
    ll l=-1e9,r=1e9,ans;
    while(l<=r){
        ll mid=l+r>>1;
        if(kru(mid),rtc<=K)ans=mid,l=mid+1;
        else r=mid-1;
    }
    kru(ans),cout<<sum+(ll)K*ans;
    return 0;
}
```



---


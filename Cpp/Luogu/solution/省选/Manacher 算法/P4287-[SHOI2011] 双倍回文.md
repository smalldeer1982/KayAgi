# [SHOI2011] 双倍回文

## 题目描述

记字符串 $w$ 的倒置为 $w^{\mathsf R}$。例如$\tt (abcd)^{\mathsf R}=dcba$，$\tt (abba)^{\mathsf R}=abba$。

对字符串 $x$，如果 $x$ 满足 $x^{\mathsf R}=x$，则称之为回文。例如 $\tt abba$ 是一个回文，而 $\tt abed$ 不是。

如果 $x$ 能够写成 $ww^{\mathsf R} ww^{\mathsf R}$ 形式，则称它是一个“双倍回文”。换句话说，若要 $x$ 是双倍回文，它的长度必须是 $4$ 的倍数，而且 $x$，$x$ 的前半部分，$x$ 的后半部分都要是回文。例如 $\tt abbaabba$ 是一个双倍回文，而 $\tt abaaba$ 不是，因为它的长度不是 $4$ 的倍数。

- $x$ 的子串是指在 $x$ 中连续的一段字符所组成的字符串。例如 $\tt be$ 是 $\tt abed$ 的子串，而 $\tt ac$ 不是。
- $x$ 的回文子串，就是指满足回文性质的 $x$ 的子串。
- $x$ 的双倍回文子串，就是指满足双倍回文性质的 $x$ 的子串。

你的任务是，对于给定的字符串，计算它的最长双倍回文子串的长度。

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le N \le 500000$。

## 样例 #1

### 输入

```
16
ggabaabaabaaball```

### 输出

```
12```

# 题解

## 作者：cosmicAC (赞：137)

楼下 or 楼上的dalao对不起，现在我成为最快且最短的一份代码了。

这道题显然不是什么<=6特判的乱搞，其实也不应该是O(n * a(n))的并查集，正确的做法是线性的：考虑所有O(n)个本质不同的回文串，对每个回文串都可以O(1)判断。具体实现中,只需要在manacher中mx更新时,判断所有新出现的回文串的前一半是否为回文串即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000010]={'?'};
int p[1000010],n,ans;
void manacher(char *s,int n){
    for(int c=0,mx=0,i=1;i<=n;i++){
        p[i]=i<mx?min(p[2*c-i],mx-i):1;
        while(s[i+p[i]]==s[i-p[i]])++p[i];
        if(i+p[i]>mx){
        	if(i&1)for(int j=max(mx,i+4);j<i+p[i];j++)
				if(!(j-i&3) && p[i-(j-i)/2]>(j-i)/2)ans=max(ans,j-i);
			mx=i+p[i],c=i;
		}
    }
}
int main(){
	scanf("%d %s",&n,s+1);
    for(int i=n;i;i--)s[i*2+1]='#',s[i*2]=s[i];s[1]='#';
    manacher(s,2*n+1);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Polaris5452830 (赞：44)

关于双倍回文这道题，可以算是一道回文自动机的板子题

但是需要稍微魔改一下，在构造回文自动机的过程中顺带求出一个 $trans$ 指针

$trans$ 指针的含义是小于等于当前节点长度一半的最长回文后缀，求法和 $fail$ 指针的求法类似

当我们新建一个节点后，如果它的长度小于等于 2，那么这个节点的 $trans$ 指针指向它的 $fail$ 节点

否则的话，我们同理从它父亲的 $trans$ 指针指向的节点开始跳   $fail$ 指针

直到跳到某一个节点所表示的回文串的两侧都能扩展这个字符

并且拓展后的长度小于等于当前节点长度的一半

那么新建节点的 $trans$ 的指针就指向该节点的儿子

有关回文自动机的介绍及 $fail$ 指针的求法，详见[我的博客](https://www.cnblogs.com/Polaris5452830/p/10498625.html)

求完这个 $trans$ 指针之后，这个题就变得非常容易了

我们考虑一个字符串满足双倍回文

当且仅当它的 $trans$ 指针指向的节点所表示的回文串长度刚好是这个字符串长度的一半，并且这个 $trans$ 指针指向的节点所表示的回文串长度为偶数

这样我们就可以枚举每个节点，不停的更新答案

代码如下

```cpp
#include<cstdio>
#include<algorithm>

const int maxn=555555;

char s[maxn];
int cnt,last;
int trans[maxn];
int son[maxn][26];
int len[maxn],fail[maxn];

int new_node(int length)
{
    len[++cnt]=length;
    return cnt;
}

int get_fail(int pre,int now)
{
    while(s[now-len[pre]-1]!=s[now])
        pre=fail[pre];
    return pre;
}

void build_PAM()
{
    cnt=1,last=0;
    len[0]=0,len[1]=-1;
    fail[0]=1,fail[1]=1;
    for(int i=1;s[i];i++)
    {
        int cur=get_fail(last,i);
        if(!son[cur][s[i]-'a'])
        {
            int now=new_node(len[cur]+2);
            fail[now]=son[get_fail(fail[cur],i)][s[i]-'a'];
            son[cur][s[i]-'a']=now;
            //顺带求出trans指针 
            if(len[now]<=2) trans[now]=fail[now];
            else
            {
                int tmp=trans[cur];
                while(s[i-len[tmp]-1]!=s[i]||((len[tmp]+2)<<1)>len[now]) tmp=fail[tmp];
                //注意拓展后的长度为len[tmp]+2
                trans[now]=son[tmp][s[i]-'a'];
            }
        }
        last=son[cur][s[i]-'a'];
    }
}

int n,ans;

int main()
{
    scanf("%d",&n);
    scanf("%s",s+1);
    build_PAM();
    for(int i=2;i<=cnt;i++)//枚举所有节点
        if(((len[trans[i]]<<1)==len[i]&&len[trans[i]]%2==0))
            ans=std::max(ans,len[i]);//更新答案
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：逆流之时 (赞：13)

提供一个可能比较好想的 manacher：

我们枚举双倍回文串右边部分的中心点时，需要找到这个中心点对应的双倍回文串的中心点。根据双倍回文串的性质，这两个点都应该是特殊符号而不是字母（满足长度为 4 的倍数），并且这两个点应该满足 $mid + \frac{p_{mid} - 1}{2} \ge i$，其中 $mid$ 是双倍回文串的中心点，$p_{mid}$ 是 $mid$ 对应的回文串长度 +1，$i$ 是双倍回文串右边部分的中心点。因为如果 $mid + \frac{p_{mid} - 1}{2} < i$，可以证明此时回文串长度还应该更长，不符合题意。然后我们查找满足这个条件的尽量靠左的 $mid$ 点就可以了，此时答案就是 $2 \times (i - mid)$，然后我们对这些值取最大值。

为了动态插入、查找符合条件的 $mid$ 点，我们需要两个 set，第一个 set 里存储按 $mid + \frac{p_{mid} - 1}{2}$ 排序元素，第二个 set 存储按 $mid$ 大小排序的元素。我们每次在第一个 set 里删除对于当前 $i$ 不满足 $mid + \frac{p_{mid} - 1}{2} \ge i$ 的元素，并在第二个 set 里删除对应的 $mid$，查找时直接在第二个 set 里用 `lower_bound()` 函数就可以了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
using namespace std;
const int N = 1e6 + 20;
int n, ans;
char s[N];
int p[N];
set<pair<int, int> > s1;
set<int> s2;
void manacher(char *s) {
	for (int i = 1, r = 0, id = 0; i < n; i++) {
		if (i < r) p[i] = min(p[id * 2 - i], r - i);
		else p[i] = 1;
		while (s[i + p[i]] == s[i - p[i]]) p[i]++;
		if (i + p[i] > r) r = i + p[i], id = i;
		if (s[i] == '$') {
			s1.insert(make_pair(i + (p[i] - 1) / 2, i));
			s2.insert(i);
			while (s1.begin()->first < i) s2.erase(s1.begin()->second), s1.erase(s1.begin());
			int t = *s2.lower_bound(i - p[i]);
			ans = max(ans, (i - t) * 2);
		}
	}
}
int main() {
	s[0] = '#';
	scanf("%d", &n);
	scanf("%s", s + 1);
	for (int i = n * 2 + 1; i >= 1; i--)
		if (i & 1) s[i] = '$';
		else s[i] = s[i >> 1];
	s[n * 2 + 2] = '\0';
	n = strlen(s);
	manacher(s);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Ryan_ (赞：11)

# 解法一：

对原串构建回文自动机

抽离fail树，从根开始dfs

设len[x]表示节点x表示的最长回文子串长度

在fail树上，x到根节点的路径上的点表示的字符串包含了x代表的回文子串的所有回文后缀/前缀

所以若dfs到了x，若len[x]为偶数，标记len[x]*2，如果在x的子树中能找到len为len[x]*2的点，那么len[x]*2*2就可以用来更新答案






# 解法二：

原串和其反串拼接，中间用两个不一样的字符隔开

然后构建回文自动机

考虑一个双倍回文的分割点i和i+1

i是前缀回文的结束位置

i+1是后缀回文的开始位置

设以i为结束位置的最长回文子串为s1，在回文自动机上的节点为a

设以i+1开始位置的最长回文子串为s2，在回文自动机上的节点为b

设前缀以i结束，后缀以i+1开始的双倍回文子串的一半为s，长度为L

那么现在有两个要求：

1、L为偶数

2、s是s1的后缀，s是s2的前缀，且s最长

对于要求2，因为开始原串和反串拼接构建了回文自动机，所以就是求a和b在fail树上的LCA

对于要求1，对每个点x记录fail树上 x的祖先中离它最近的长度为偶数的回文串即可

 

倍增求LCA会超时

不会tarjan求LCA（~~~~(>_<)~~~~）

树链剖分求LCA 会被卡空间

最后还是选了树剖。。。

回文自动机用了map存储，

注意回文自动机中有节点0，在树剖第二遍dfs的时候，重儿子初始化的编号不能是0


```
#include<map>
#include<cmath>
#include<cstdio>
#include<algorithm>
 
using namespace std;
 
#define N 1000001
 
int n,m;
char ss[N+1];
int s[N+1];
 
int tot=1,last;
int len[N],fail[N];
map<int,int>tr[N];
int p,c,np,t;
 
int use[N],pos[N];
 
int front[N],to[N],nxt[N],cnt;
 
int bl[N],dep[N],siz[N],fa[N];
 
void add(int u,int v)
{
    to[++cnt]=v; nxt[cnt]=front[u]; front[u]=cnt;
}
 
void extend(int i)
{
    p=last; c=s[i];
    while(s[i-1-len[p]]!=c) p=fail[p];
    if(!tr[p][c])
    {
        np=++tot;
        len[np]=len[p]+2;
        t=fail[p];
        while(s[i-1-len[t]]!=c) t=fail[t];
        fail[np]=tr[t][c];
        add(fail[np],np);
        use[np]=len[np]&1 ? use[fail[np]] : np;
        tr[p][c]=np;
    }
    else np=tr[p][c];
    last=np;
    pos[i]=np;
}
 
void build()
{
    s[0]=-1;
    for(int i=1;i<=n;++i) s[i]=ss[i]-'a';
    m=n;
    s[++m]=26; s[++m]=27;
    for(int i=n;i;--i) s[++m]=ss[i]-'a';
    fail[0]=1;
    len[1]=-1;
    for(int i=1;i<=m;++i) extend(i);
}
 
void dfs1(int x)
{
    siz[x]=1;
    for(int i=front[x];i;i=nxt[i])
    {
        dep[to[i]]=dep[x]+1;
        fa[to[i]]=x;
        dfs1(to[i]);
        siz[x]+=siz[to[i]];
    }
}
 
void dfs2(int x,int top)
{
    int y=-1;
    bl[x]=top;
    for(int i=front[x];i;i=nxt[i])
        if(y==-1 || siz[to[i]]>siz[y]) y=to[i];
    if(y==-1) return;
    dfs2(y,top);
    for(int i=front[x];i;i=nxt[i])
        if(to[i]!=y) dfs2(to[i],to[i]);
}
 
int get_lca(int u,int v)
{
    while(bl[u]!=bl[v])
    {
        if(dep[bl[u]]<dep[bl[v]]) swap(u,v);
        u=fa[bl[u]];
    }
    return dep[u]<dep[v] ? u : v;
}
 
void solve()
{
    add(1,0);
    dfs1(1);
    dfs2(1,1);
    int ans=0;
    int lca;
    for(int i=1;i<=n;++i)
    {
        lca=get_lca(pos[i],pos[m-i]);
    //  printf("%d %d\n",pos[i],pos[m-i]);
        ans=max(ans,len[use[lca]]<<1);
        //printf("%d\n",ans);
    }
    printf("%d",ans);
}
 
int main()
{
    scanf("%d",&n);
    scanf("%s",ss+1);
    build();
    solve();
}
```


---

## 作者：ButterflyDew (赞：8)

思路：建回文自动机PAM，不知道的可以看[这篇博客](<https://blog.csdn.net/u013368721/article/details/42100363>)（和另一篇题解的并不一样

然后对每个节点统计答案，但我们干嘛要暴力跳$fail$呢？（不过另一篇PAM的剪枝好像还行，不知道能不能卡

一个简单的思路对$fail$树进行倍增，然后直接找一半长度的就行了，但这样是$O(n\log n)$的

不妨对每个节点维护一个$f_i$数组，代表$i$这个节点小于等于ta一半长度的最长回文后缀，这个东西可以$O(n)$更新。

方法很简单，每次先跳到父亲的$f_i$那里，然后用$fail$数组继续跳出一个回文串就行了，注意在长度比较小的时候要特判。这里说的可能不太清楚，可以看一下代码。

------

**Code:**

```cpp
#include <cstdio>
#include <cstring>
const int N=5e5+10;
int ch[N][26],fail[N],f[N],len[N],tot,n;
char s[N];
int getfail(int now,int p)
{
    while(s[p]!=s[p-len[now]-1]) now=fail[now];
    return now;
}
void PAM()
{
    len[fail[0]=++tot]=-1;
    scanf("%d%s",&n,s+1);
    for(int now,las=0,i=1;i<=n;i++)
    {
        int cur=getfail(las,i),c=s[i]-'a';
        if(!ch[cur][c])
        {
            fail[now=++tot]=ch[getfail(fail[cur],i)][c];
            len[now]=len[cur]+2;
            ch[cur][c]=now;
            if(len[fail[now]]<=len[now]>>1) f[now]=fail[now];
            else
            {
                int p=f[cur];
                while((len[p]+2>len[now]>>1)||(s[i]!=s[i-len[p]-1])) p=fail[p];
                f[now]=ch[p][c];
            }
        }
        las=ch[cur][c];
    }
}
int main()
{
    PAM();int ans=0;
    for(int i=2;i<=tot;i++)
        if(len[i]%4==0&&len[f[i]]==len[i]>>1)
            ans=ans>len[i]?ans:len[i];
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：xzyxzy (赞：8)

~~我竟然是第一个发题解的？！~~
## 广告
[我的博客](https://www.cnblogs.com/xzyxzy/)

博主最近在学习字符串/FFT/退火等算法，有兴趣的同学可以进来玩玩

## 正文
考虑我们用Manacher是怎么求最长回文子串的（如果不会，[请戳我](https://www.cnblogs.com/xzyxzy/p/9150723.html)）

那么如果是双倍回文字串的话，枚举到右子回文串的中心的时候，对应地找到最长双倍回文子串的中心，然后对称地看是否符合条件

举个例子

`#b#a#a#b#b#a#a#b#`
当我枚举到第13位的时候（从1开始），将13作为右子串中心，找到双倍回文子串中心第9位，对称看第5位也满足条件，那么更新答案

我们会发现一些规律

- 左右串中心和全串中心必须要是#
- 能够被右串中心计算到的全串中心是一段区间（原来我以为是一个点，WA了Test6），可以用队列维护（但是对于全是a的会T，所以加上t-h<100）
- 答案就是(i-Centre)*2


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
const int MAXN=1500000;
int N,l,C,R,p[MAXN],Ans;
int Q[MAXN],h,t;
char s[MAXN];
int main()
{
	cin>>N;
	char ch=getchar();
	while(ch>'z'||ch<'a') ch=getchar();
	s[++l]='#';
	while(ch>='a'&&ch<='z')
	{
		s[++l]=ch;s[++l]='#';
		ch=getchar();
	}
	for(int i=1;i<=l;i++)
	{
		if(i<R)
		{
			p[i]=min(p[C*2-i],R-i);
			while(t-h>100||((i-Q[h])*2>p[Q[h]]&&h<t)) h++;
			for(int j=h;j<=t;j++)
				if(s[i]=='#'&&s[Q[j]]=='#'&&i-Q[j]+1<=p[i])
					Ans=max(Ans,(i-Q[j])*2);
		}
		else p[i]=1;
		while(s[i-p[i]]==s[i+p[i]]&&i-p[i]>=1&&i+p[i]<=l) p[i]++;
		if(i+p[i]>R) R=i+p[i],C=i,Q[++t]=i;
	}
	printf("%d\n",Ans);
	return 0;
}

```
刚才卡了一卡，发现能够转移的取6个就可以了，也就是t-h<6

~~作为最短又最快的代码，我有点飘啊。。~~

---

## 作者：约瑟夫用脑玩 (赞：6)

**引：**

trans指针看不懂？manacher看不懂？来这里看看简单易懂的回文树+Hash吧！

------------

**解法：**

注意到本质不同的回文串只有最多n个(PAM上节点最多为n)，所以只需要对于每个长度为四的倍数的回文串用Hash判断 **前一半** 与 **后一半** 是否相等即可！

------------

**证明：**

设这个回文串为 $aa'$ ( $'$ 表示翻转)，且有 $a=a'$ 所以 $a$ 为回文串，又由于这个回文串长度为四的倍数，即得其是一个双倍回文。

------------

**代码：(格式化)**

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read() {
	int gans=0,gflag=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		gflag|=(ch=='-');
		ch=getchar();
	}
	while('0'<=ch&&ch<='9') {
		gans=(gans<<1)+(gans<<3)+ch-'0';
		ch=getchar();
	}
	return gflag?-gans:gans;
}
inline void write(int x) {
	if(x>9) {
		write(x/10);
	}
	putchar(x%10^48);
}
inline void writenum(int x,char ch) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	write(x);
	putchar(ch);
}
inline int Min(int x,int y) {
	return x<y?x:y;
}
inline int Max(int x,int y) {
	return x>y?x:y;
}
const int Mx=5e5;
const int M=26;
int ans;
#define ULL unsigned long long
ULL hs[Mx+5],pw[Mx+5];
inline ULL HS(int l,int r) {
	return hs[r]-hs[l-1]*pw[r-l+1];
}
struct PT { //Palindromic_Tree
	int cnt,tot,lst,nxt[Mx+5][M+1],flt[Mx+5][M+1],fil[Mx+5],ch[Mx+5],len[Mx+5],sum[Mx+5],num[Mx+5];
	inline int New(int x) {
		memset(nxt[cnt],0,sizeof(nxt[cnt]));
		len[cnt]=x;
		sum[cnt]=0;
		num[cnt]=0;
		return cnt++;
	}
	inline void Csh() {
		cnt=0;
		tot=0;
		lst=0;
		New(0);//0:0
		New(-1);//-1:1
		ch[0]=-1;
		fil[0]=1;
		int i;
		for(i=0; i<=M; i++) {
			flt[0][i]=1;
		}
	}
	inline int Get(int x) {
		if(ch[tot-len[x]-1]!=ch[tot]) {
			return flt[x][ch[tot]];
		}
		return x;
	}
	inline int Add(int c) {
		int now,p;
		c-='a';
		pw[tot]=(tot?pw[tot-1]*27:1);
		hs[tot+1]=(tot?hs[tot]*27+c:c);
		ch[++tot]=c;
		p=Get(lst);
		if(!nxt[p][c]) {
			now=New(len[p]+2);
			fil[now]=nxt[Get(fil[p])][c];
			memcpy(flt[now],flt[fil[now]],sizeof(flt[now]));
			flt[now][ch[tot-len[fil[now]]]]=fil[now];
			nxt[p][c]=now;
			num[now]=num[fil[now]]+1;
			if(!(len[now]&3)) {
				ans=Max(ans,(HS(tot-len[now]+1,tot-len[now]/2)==HS(tot-len[now]/2+1,tot)?len[now]:0));
			}
		}
		lst=nxt[p][c];
		sum[lst]++;
		return len[lst];
	}
	inline void Cnt() {
		int i;
		for(i=cnt-1; i>=0; i--) {
			sum[fil[i]]+=sum[i];
		}
	}
} T;
int len;
char ch[Mx+5];
int main() {
	int i;
	len=read();
	scanf("%s",ch);
	T.Csh();
	for(i=0; i<len; i++) {
		T.Add(ch[i]);
	}
	writenum(ans,'\n');
	return 0;
}
/*
16
ggabaabaabaaball
*/

```

---

## 作者：酷暑一夏1 (赞：5)

## 前言
用了一种很奇怪的方法来解，即二分判断回文，再进行某些奇怪的优化。因为这个方法很奇怪，所以希望如果有问题能够 hack 一下。

## 题解
我们发现，这题中要求的是字符串 $SS'SS'$，其中 $S'$ 是 $S$的反向，那么这个串长度必定为 $4$ 的倍数。那么我们对于每个位置，寻找一组最大的 $SS'$，然后找这前面是否有一个与他相同的 $SS'$，如果有，那么这两组字符串组成一个双倍回文。但是问题在于对于某些情况，例如 `bbbbbbbbbbb`，在第 $3$ 和 $4$ 个字符中间以及第 $8$ 和 $9$ 个字符中间，都能取到长度为 $3$ 的回文 `bbb`，但是他们共用了第 $6$ 个字符，从而造成最大双倍回文子串长度为 $3$ 的假象。为了避免这种假象的发生，同时保证答案长度的最大化，我们需要将共用的部分一分为二，各执一半。

仔细思考，我们可以发现，这一共用的部分只可能是一个字符集大小为 $1$ 的字符串（语文不好不知道怎么表达）。因为我们知道，回文子串关于对称中心对称，即在该回文子串长度范围内与对称中心距离相同的两个字符相同，两个串共用的部分位于一个串 $A$ 的末尾和另一个串 $B$ 的开头，当我们把串 $B$ 的开头映射到串 $A$ 的开头（因为 $A$ 串和 $B$ 串相同）后，可以发现，只有符合字符集大小为 $1$ ，才能符合上述性质。

因此，我们预处理时把每一段字符集大小为 $1$ 的长度等信息做好标记，然后在计算完各位置为中心的最大回文子串长度后减去重复长度即可。


## 代码
```cpp
#include<cstdio>
#include<map>
#include<algorithm>
typedef unsigned long long ull;
const int MAXN=500001+5;
std::map<ull,int>map;
char str[MAXN];int tail[MAXN],n,l,rs[MAXN],r,len[MAXN],bll[MAXN],now,cnt,mid;ull cc,hash1[MAXN],hash2[MAXN],pow[MAXN];
ull GetHash1(int l,int r)
{
    if(l<1||l>n||r<1||r>n) return ++cc;
    return hash1[r]-hash1[l-1]*pow[r-l+1];
}
ull GetHash2(int l,int r)
{
    if(l<1||l>n||r<1||r>n) return ++cc;
    return hash2[l]-hash2[r+1]*pow[r-l+1];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%c",&str[i]);
        if(!(str[i]>='a'&&str[i]<='z')) i--;
    }
    for(int i=1;i<=n;i++)
    {
        if(str[i]!=str[i-1]) {tail[i-1]=1;now++;}
        rs[i]=now;
        bll[now]++;
    }
    for(int i=1;i<=n;i++)
        hash1[i]=hash1[i-1]*31+str[i]-'a'+1;
    for(int i=n;i>=1;i--)
        hash2[i]=hash2[i+1]*31+str[i]-'a'+1;
    pow[0]=1;
    for(int i=1;i<=n;i++)
        pow[i]=pow[i-1]*31;
    int ans=0,answer,aans=0,last=0;
    for(int i=1;i<=n;i++)
    {
        cnt=0;l=1;r=std::min(i-1,n-i+1);ans=0;answer=0;
        while(l<=r)
        {
            cnt++;
            if(cnt>30) break;
            mid=(l+r)>>1;
            if(GetHash1(i-mid,i-1)!=GetHash2(i,i+mid-1)) {r=mid-1;} else {l=mid+1;ans=std::max(ans,mid);}
        }
        if(tail[i+ans-1])
        ans-=std::min(ans,bll[rs[i+ans-1]])/2;
        len[i]=ans;
        int result=map[GetHash1(i-ans,i+ans-1)];
        if(GetHash1(i-ans,i+ans-1)==GetHash1(i+ans,i+ans*3-1))
        {
            aans=std::max(aans,ans*4);
        }

    }	
    printf("%d",aans);
    return 0;
}
```

---

## 作者：Fading (赞：4)

居然没有回文自动机的题解？

这好像是回文自动机的裸题啊，不会就去[这个博客](https://blog.csdn.net/YxuanwKeith/article/details/65667401)学好了，写得还蛮好的。

我们发现如果这个串如果是双倍回文串，一定满足以下条件：

```
1:长度为4的倍数
2:必然有一个长度为它的一半的回文后缀
```

然后这道题就好了。先建完回文自动机，然后枚举每一个节点，暴力跳$fail$指针（由于$fail$指针指的是最大回文后缀的位置），然后判断是否存在，更新答案就好啦！

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
struct PAT{
    long long ANS;
    int last,cnt,fail[3000001],g[3000001][27],len[3000001],size[3000001];
    inline void init(){
        last=0,cnt=1;fail[0]=1;len[1]=-1;
    }
    inline void insert(char *a,int L){
        for (int i=0;i<L;i++){
            int now=last;
            while (a[i-len[now]-1]!=a[i]) now=fail[now];
            if (!g[now][a[i]-'a']){
                len[++cnt]=len[now]+2;
                int posx=fail[now];
                while (a[i-len[posx]-1]!=a[i]) posx=fail[posx];
                fail[cnt]=g[posx][a[i]-'a'];
                g[now][a[i]-'a']=cnt;
            }
            last=g[now][a[i]-'a'];
            size[last]++;
        }
    }
    inline void sort(){
        for (int i=cnt;i;i--){
            int pos=i;
            if (len[i]%4) continue;//条件1
            if (len[i]<=ANS) continue;//如果总长度都比答案小那么没有更新的必要。
            while (2*len[pos]>len[i]) pos=fail[pos];//条件2
            if (len[pos]*2==len[i]) ANS=len[i];
        }
    }
}pat;
char s[1000001];
int N,a[1000001];
int main(){
    cin>>N;
    scanf("%s",s);
    pat.init();
    pat.insert(s,N);
    pat.sort();
    cout<<pat.ANS<<endl;
}


```

---

## 作者：huangzirui (赞：3)

题意：

求出给定字符串 $S$ 的一个最大双倍回文子串。

双倍回文串： 指一个串能被分解为两个相同的回文串且它们长度为 $2$ 的倍数。

如： $\texttt{abbaabba}\ ,\ \texttt{cccc}$

$| S | \leq 5\times 10^5$

---

考虑先建立回文自动机，那么如果一个回文串的某个回文后缀长度是 $2$ 的倍数且长度恰好为原串一半，那么它就是一个双倍回文串。

考虑怎么处理上述的条件，不妨先建立一颗回文自动机上的后缀树 ( 每个节点指向它的 ``next / fail`` ) ，然后原题目转化为在一颗树上找到长度最大一个点满足它有某个祖先长度是它一半。

于是可以直接遍历整棵树，遍历时存下来之前祖先的长度，用一个优先队列来维护即可。

复杂度 $O(n\log n)$ 可以通过此题，解法清新自然，思维难度小，代码长度较短，相信这篇题解一定能为你的 OI 之路提供有力的帮助！（笑

```cpp
#include <bits/stdc++.h>
#define ll long long
#define Mid ((L+R)>>1)
using namespace std;
typedef pair<int,int> pii;
inline int read(){
	char c;int x=0;int b=1;do{c=getchar();if(c==45)b=-1;}while(c>57||c<48);
	do x=x*10+c-48,c=getchar();while(c<=57&&c>=48);x*=b;return x;
}
const int maxn=500010;
int i,j,k,n,m,Next[maxn],is[maxn],cnt=1;
char S[maxn];
struct node{
	int C[27],len;
}a[maxn];
int getNext(int now,int len){
	while(S[len] != S[len-a[now].len-1])now=Next[now];
	return now;
}
void add(int x,int y);
void insert(){
	int len=strlen(S),now=0;
	for(int i=0;i<len;i++){
		int X=getNext(now,i),Num=S[i]-'a'+1;
		if(!a[X].C[Num]){
			a[++cnt].len=a[X].len+2;
			Next[cnt]=a[getNext(Next[X],i)].C[Num];
			a[X].C[Num]=cnt;
			add(Next[cnt],cnt);
		}now=a[X].C[Num];
		is[now]=1;
	}
}
struct edge{
	int next,to;
}e[maxn*2];
int head[maxn],len;
void add(int x,int y){
	e[++len]={head[x],y};
	head[x]=len;
}
int ans=0;
int Q[maxn],l=1,r;
void dfs(int now){
	int lastl=l,lastr=r;
	while(l<=r && Q[l]*2 < a[now].len)l++;
	if(l<=r && Q[l]*2==a[now].len && a[now].len%4==0)
		ans=max(ans,a[now].len);
	Q[++r]=a[now].len;
	for(int i=head[now];i;i=e[i].next){
		int u=e[i].to;
		dfs(u);
	}
	l=lastl;r=lastr;
}
int main() {
	freopen("P4287.in","r",stdin);
	freopen("P4287.out","w",stdout);
	cin>>n>>S;
	a[0].len=0;Next[0]=1;
	a[1].len=-1;Next[1]=1;
	add(0,1);
	insert();
	dfs(0);
	cout<<ans<<endl;
	//cerr << 1.0*clock()/CLOCKS_PER_SEC << endl;
	return 0;
}
```

---


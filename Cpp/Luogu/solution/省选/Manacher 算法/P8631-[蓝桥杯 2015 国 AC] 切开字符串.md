# [蓝桥杯 2015 国 AC] 切开字符串

## 题目描述

Pear 有一个字符串，不过他希望把它切成两段。

这是一个长度为 $N$（$ \le 10^5$）的字符串。

Pear 希望选择一个位置，把字符串不重复不遗漏地切成两段，长度分别是 $t$ 和 $N-t$（这两段都必须非空）。

Pear 用如下方式评估切割的方案：

定义“正回文子串”为：长度为奇数的回文子串。

设切成的两段字符串中，前一段中有 $A$ 个不相同的正回文子串，后一段中有 $B$ 个不相同的非正回文子串，则该方案的得分为 $A \times B$。

注意，后一段中的 $B$ 表示的是：“ ... 非正回文 ... ”，而不是：“ ... 正回文 ... ”。

那么所有的切割方案中，$A \times B$ 的最大值是多少呢？

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$。

对于 $40\%$ 的数据，$N \le 1000$。

对于 $100\%$ 的数据，$N \le 10^5$。

时限 1 秒, 512M。蓝桥杯 2015 年第六届国赛

## 样例 #1

### 输入

```
10
bbaaabcaba```

### 输出

```
38```

# 题解

## 作者：zyc070419 (赞：5)

# [P8631 [蓝桥杯 2015 国 AC] 切开字符串](https://www.luogu.com.cn/problem/P8631) 题解

### 前言

看到这题没有人写题解，就打算写一篇。这也是蒟蒻的第一篇题解。

### 前置知识

manacher，SA。如果不会可以转至 [manacher模板](https://www.luogu.com.cn/problem/P3805)，[SA模板](https://www.luogu.com.cn/problem/P3809)，以及 **[我的博客](https://www.cnblogs.com/zyc070419-blog/p/17151929.html)**。

### 题意概述

给一个长度为 $n$ 的字符串 $s$，记 $A_i$ 表示 $s_{1\ldots i}$ 中本质不同的长度为奇数的回文串个数，$B_i$ 表示 $s_{i\ldots n}$ 中本质不同的长度**不为**奇数或**不是**回文串的子串个数，求 $\max_{i=1}^{n-1}A_i\times B_{i+1}$。

$n\le 10^5$。

### 符号规定

$\operatorname{suf}(i)$ 表示从 $i$ 开始的后缀。$\operatorname{lcp}(i,j)$ 表示 $\operatorname{suf}(i),\operatorname{suf}(j)$ 的最长公共前缀。

$sa_i,rk_i,ht_i$ 分别代表排名为 $i$ 的后缀的开始位置、$\operatorname{suf}(i)$ 的排名、$\operatorname{lcp}(sa_i,sa_i-1)$。

$d_i​$ 为以 $i​$ 为中心的最长回文串半径。

### 题目分析

对于 $n\le 1000$ 我们可以暴力的 Hash 预处理出所有 $A_i$ 和 $B_i$，然后求答案即可。

那么对于 $n\le 10^5$ 来说其实也可以这样做，先预处理出 $A_i,B_i$，然后再统计答案。其实可以发现我们要求的可以分为三个部分：

1. 每个 $s$ 的后缀的本质不同子串数

2. 每个 $s$ 的前缀本质不同的长度为奇数的回文串数

3. 每个 $s$ 的后缀本质不同的长度为奇数的回文串数

首先我们来看第一个问题。因为要求本质不同子串数，所以很自然的想到 SA 来求解，可以参考 [P4070 [SDOI2016]生成魔咒](https://www.luogu.com.cn/problem/P4070) （~~其实是一模一样的题目~~），下面我讲一下具体如何做。

我们考虑一下 SA​ 求整个字符串本质不同子串数的原理：$ans=\sum_{i=1}^{n}(n-sa_i+1-ht_i)$，其实就是把所有子串先加上，再把所有重复的子串减去，那么我们求每个后缀的本质不同子串数也可以如此（记 $sum_i$ 表示 $s_{i\ldots n}$ 的本质不同子串数）：

我们倒序枚举 $s$ 的每一个字符，并维护一个 `set`，里面储存所有已经枚举过的字符 $s_i$ 的对应的后缀 $\operatorname{suf}(i)$ 的排名 $rk_i$，然后当我们枚举到 $s_j$ 时，找到 $rk_j$ 的前驱 $pre$，后继 $nxt$，则：
$$
sum_j=sum_{j+1}+(n-j+1)-\max(\operatorname{lcp}(sa_{pre},j),\operatorname{lcp}(j,sa_{nxt}))
$$
原理如下：

首先我们加入了 $s_j$，那么如果不考虑重复的子串，它会贡献 $n-j+1$ 个子串，但是由于它有重复的，所以说我们要把重复的减掉，而重复的子串其实也就是 $\operatorname{suf}(j)$ 和所有已经插入过的 $\operatorname{suf}(i)$ 的 $\operatorname{lcp}$ 的最大值，即 $\max_{i=j+1}^{n}\operatorname{lcp}(i,j)$，而根据 $height$ 数组的性质可以知道，这个最大值只有可能出现在 $\operatorname{lcp}(j,sa_{pre})$，$\operatorname{lcp}(j,sa_{nxt})$ 中，所以这样做是很正确的，下面给出这一部分的代码：

```cpp
set<int> S;
set<int> :: iterator it;

//下面用到的函数
void work(int x) {
	int lst, nxt; mx = 0;
	it = S.lower_bound(x);
	nxt = (*it); lst = (*(--it));
	if (lst >= 1 && lst <= n) mx = max(mx, lcp(lst, x));
	if (nxt >= 1 && nxt <= n) mx = max(mx, lcp(x, nxt));
	S.insert(x);
}

//主函数部分，倒序插入字符
S.clear(); S.insert(0); S.insert(n + 1); //插入 0 和 n+1 是为了防 RE
for (i = n; i >= 1; --i) {
	work(rk[i]);
	sum[i] = sum[i + 1] + 1ll * (n - i + 1 - mx);
	S.insert(rk[i]);
}
```

第一个子问题解决了，接下来考虑剩下两个子问题。

其实这两个问题是一模一样的，下面我们只讨论第三个子问题，第二个子问题只需要把字符串翻转一下再按照第三个子问题的方法再做一遍即可。

因为是找本质不同的长度为奇数的回文串的个数，可以尝试结合 manacher​ 和 SA，思路可以参考一下 [P3649 [APIO2014] 回文串](https://www.luogu.com.cn/problem/P3649)。

比较暴力的想法是先用 manacher 将所有的回文串都找出来，然后按照左端点从大到小依次枚举，按照第一个子问题的方法一模一样的做即可，复杂度 $O(n^2\log n)$。

但其实可以优化的，考虑 manacher 是如何做到 $O(n)$ 的：**$r$ 端点只变化了 $n$ 次**。那么其实可以换句话说：

> **一个字符串的本质不同回文串的个数最多只有 $O(n)$ 级别**

所以说我们只考虑暴力增加 $d_i$ 时额外增多的回文串即可（因为只有这些回文串才**有可能**成为一个新的本质不同回文串），所以在做 manacher 的时候把得到的新的回文串的长度记录在改回文串的左端点处（每个位置开一个 `vector`），然后按照第一部分方法，找到 $len=\max(\operatorname{lcp}(i,j))$，然后在 `vector` 中 `lower_bound` 一下找到长度大于 $len$，即哪些回文串未出现过即可，代码如下：

```cpp
//用 manacher 加入回文串部分
for (i = n, l = n + 1; i >= 1; --i) {
    if (i >= l) d[i] = min(d[mid * 2 - i], i - l + 1);
    while (i + d[i] <= n && i - d[i] >= 1 && s[i + d[i]] == s[i - d[i]]) {
        v[i - d[i]].push_back(2 * d[i] + 1);
        d[i]++;
    }
    if (i - d[i] + 1 < l) {
        l = i - d[i] + 1;
        mid = i;
    }
}
for (i = 1; i <= n; ++i) sort(v[i].begin(), v[i].end());

//统计处
S.clear(); S.insert(0); S.insert(n + 1);
memset(val, 0, sizeof(val));
for (i = n; i >= 1; --i) {
	work(rk[i]); val[i] = val[i + 1];	//与上文中的 work 函数相同
	if(v[i].back() <= mx) continue;
	pos = upper_bound(v[i].begin(), v[i].end(), mx) - v[i].begin();
	val[i] += 1ll * (v[i].size() - pos);	//val[i]表示s[i~n]本质不同长度奇数回文串数
}
```

到这里已经可以做了，但其实还可以优化一下，因为有一个更加优美的结论：

> 如果将回文串记录在倒序枚举时它最早出现的位置的左端点上，那么每个字符 $s_i$ 处**最多只会储存一个回文串**

证明如下：

如果位置 $i$ 存了两个不同的回文串，长度分别为 $p,q$ 且 $p>q$，那么说明在 $s_{L\ldots R}$ 处（其中 $L=2\times (i+\lfloor \dfrac{q}{2}\rfloor) - (i+p-1)$，$R=2\times (i+\lfloor \dfrac{q}{2}\rfloor) - i$）是一个与 $s_{i\ldots i+p-1}$ 完全相同的字符串，与前提 **最早出现的位置** 冲突，故结论成立。

所以说就不同开 `vector` 了，只用在每个位置对回文串长度取 $\max$ 即可，即改成这样：

```cpp
//插入回文串
for(i = n, l = n + 1; i >= 1; --i) {
    if(i >= l) d[i] = min(d[mid * 2 - i], i - l + 1);
    while(i + d[i] <= n && i - d[i] >= 1 && s[i + d[i]] == s[i - d[i]]) {
        v[i - d[i]] = max(v[i - d[i]], 2 * d[i] + 1);
        d[i]++;
    }
    if(i - d[i] + 1 < l) {
        l = i - d[i] + 1;
        mid = i;
    }
}

//统计处
S.clear(); S.insert(0); S.insert(n + 1);
for(i = n; i >= 1; --i) {
    work(rk[i]);
    val[i] = val[i + 1] + (mx < v[i]);
}
```

于是本题就完美的结束了，下面给出 **[完整代码](https://www.luogu.com.cn/paste/4c9l1dps)**。

### 后记

~~其实本蒟蒻觉得这题难度不止蓝~~，或许有更简单的方法吧。本题中给出的题目链接在 **[我的博客](https://www.cnblogs.com/zyc070419-blog/p/17151929.html)** 中都是有讲解的（~~虽然讲的有一点简略~~），但题目类型、套路挺多的（确信，如果本篇博客有哪里写的不对的地方也希望大家指出，我会及时更改。

本篇题解到这里就彻底结束了！

---

## 作者：Fzrcy (赞：1)

题意简述：

> 有一个长度为 $n$（$\le 10^5$）的字符串 $s$，一个切割方案的得分为前一段中本质不同的长度为奇数的回文子串数 $x$ 与后一段中本质不同且不为长度为奇数的回文子串的子串数 $y$ 的乘积 $x\times y$。求一个切割方案（左右子串非空）使得得分最大。

我们可以用 PAM 维护前缀和后缀的本质不同的长度为奇数的回文子串数。具体的，当回文自动机中加入一个新的节点时判断该节点代表的回文串的长度为奇数即可。

```cpp
    void ins(int c, ll *t){
        int p=last;
        S[++tot]=c+1;
        while(S[tot]!=S[tot-len[p]-1]) p=fail[p];
        if(!ch[p][c]){
            int res=++cnt;
            len[res]=len[p]+2;
            int q=fail[p];
            while(S[tot]!=S[tot-len[q]-1]) q=fail[q];
            fail[res]=ch[q][c], ch[p][c]=res;
            if(len[res]%2==1) t[tot]++;
        }
        last=ch[p][c];
        return;
    }
    void build(char *s, ll *t){
        init(); int Len=strlen(s+1);
        for(int i=1; i<=Len; i++) ins(s[i]-'a', t);
        for(int i=1; i<=tot; i++) t[i]+=t[i-1];
    }
```

然后用 SAM 维护后缀的本质不同的子串数，用类似 [P4070 生成魔咒](https://www.luogu.com.cn/problem/P4070) 的套路即可。

那么后缀中本质不同且不为长度为奇数的回文子串的子串数 $y$ 等于后缀中本质不同的子串数减去后缀中本质不同且长度为奇数的回文子串数。

总时间复杂度为 $O(n)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N=2e5+1;
ll aa[N], bb[N], cc[N];
struct PAM{
    int ch[N][26], fail[N], len[N], S[N];
    int cnt, last, tot;
    void init(){
        cnt=last=1, S[tot=0]=-1;
        fail[0]=1, len[0]=0, len[1]=-1;
    }
    void ins(int c, ll *t){
        int p=last;
        S[++tot]=c+1;
        while(S[tot]!=S[tot-len[p]-1]) p=fail[p];
        if(!ch[p][c]){
            int res=++cnt;
            len[res]=len[p]+2;
            int q=fail[p];
            while(S[tot]!=S[tot-len[q]-1]) q=fail[q];
            fail[res]=ch[q][c], ch[p][c]=res;
            if(len[res]%2==1) t[tot]++;
        }
        last=ch[p][c];
        return;
    }
    void build(char *s, ll *t){
        init(); int Len=strlen(s+1);
        for(int i=1; i<=Len; i++) ins(s[i]-'a', t);
        for(int i=1; i<=tot; i++) t[i]+=t[i-1];
    }
}p1, p2;
struct SAM{
    int ch[N][27], last, cnt, link[N], len[N];
    ll now=0;
    void upd(int x){now+=(ll) len[x]-len[link[x]];}
    void init(){last=cnt=1, now=0;}
    ll ins(int c){
        int p=last, res=++cnt;
        len[last=res]=len[p]+1;
        while(p&&!ch[p][c]) ch[p][c]=res, p=link[p];
        if(!p){link[res]=1; upd(res); return now;}
        int q=ch[p][c];
        if(len[q]==len[p]+1){link[res]=q; upd(res); return now;}
        int nq=++cnt;
        link[nq]=link[q], len[nq]=len[p]+1, link[q]=link[res]=nq;
        memcpy(ch[nq], ch[q], sizeof ch[q]);
        while(p&&ch[p][c]==q) ch[p][c]=nq, p=link[p];
        upd(res); return now;
    }
}s;
char r[N];
int n;
int main(){
    cin>>n>>r+1;
    p1.build(r, aa);
    reverse(r+1, r+n+1);
    p2.build(r, bb);
    reverse(bb+1, bb+n+1);
    s.init();
    for(int i=1; i<=n; i++)
        cc[i]=s.ins(r[i]-'a'+1);
    reverse(cc+1, cc+n+1);
    ll ans=0;
    for(int i=1; i<n; i++) ans=max(ans, aa[i]*(cc[i+1]-bb[i+1]));
    cout<<ans<<'\n';
    return 0;
}

```

---

## 作者：sunkuangzheng (赞：0)

$\textbf{P8631}$

> - 定义 $f(s)$ 为字符串 $s$ 的本质不同子串数量，$g(s)$ 是字符串本质不同的长度为奇数的回文串数量，求 $\max\limits_{i=1}^{n-1}\{g(s[1\ldots i]) \cdot (f(s[i+1\ldots n])-g(s[i+1\ldots n]))\}$
> - $1 \le n \le 10^5$。

> 热知识：这道题在昨天还是蓝的。

我们对于 $s$ 的所有前后缀 $t$，求出所有 $f(t),g(t)$ 然后暴力枚举计算答案，可以发现这道题分为两部分：

- 对于所有前后缀求 $f(s)$。

这一部分是 P4070 生成魔咒，使用 SA 或 SAM 均可。

- 对于所有前后缀求 $g(s)$。

注意到字符串本质不同回文子串数量是 $\mathcal O(n)$ 级别的，枚举回文中心 $i$ 并求出回文半径 $len$，若当前右端点 $r=i+len-1$ 比之前 $r$ 的最大值 $r'$ 还大，那么枚举右端点 $r'+1 \sim r$，如果这个回文串之前没出现过，则所有 $k \le r$ 的前缀 $[1,k]$ 的回文串数量加一，差分即可。判断有没有出现过可以哈希，但是既然我们已经写 SA 了不妨直接用 SA 判断：对于每个 $len$ 维护一个存 $rk$ 的 set，每次和前驱后继查 $\operatorname{LCP}$。回文半径也可以用后缀数组求。

那么这道题就做完了，时间复杂度 $\mathcal O(n \log n)$。

```cpp
/**
 *    author: sunkuangzheng
 *    created: 29.02.2024 08:40:22
**/
#include<bits/stdc++.h>
#ifdef DEBUG_LOCAL
#include <mydebug/debug.h>
#endif
using ll = long long;
const int N = 5e5+5;
using namespace std;
struct SA{
    int sa[N],rk[N],ok[N],h[N],st[20][N],n;
    void build(string s){
        n = s.size(); s = " " + s;
        for(int i = 1;i <= n;i ++) sa[i] = i,rk[i] = s[i];
        for(int j = 1;j < n;j *= 2){
            for(int i = 1;i <= n;i ++) ok[i] = rk[i]; int p = 0;
            sort(sa+1,sa+n+1,[&](int x,int y){return rk[x] < rk[y] || rk[x] == rk[y] && rk[x + j] < rk[y + j];});
            auto cmp = [&](int x,int y){return ok[x] == ok[y] && ok[x + j] == ok[y + j];};
            for(int i = 1;i <= n;i ++) if(cmp(sa[i],sa[i-1])) rk[sa[i]] = p; else rk[sa[i]] = ++p; if(p == n) break;
        }for(int i = 1,k = 0;i <= n;h[rk[i ++]] = k) 
        for(k --,k = max(k,0);s[i + k] == s[sa[rk[i] - 1] + k];k ++);
        for(int i = 1;i <= n;i ++) st[0][i] = h[i];
        for(int j = 1;j <= __lg(n);j ++) for(int i = 1;i + (1 << j) - 1 <= n;i ++)
            st[j][i] = min(st[j-1][i],st[j-1][i+(1<<j-1)]);
    }int lcp(int i,int j){
        if(i == j) return n - sa[i] + 1; 
        if(i > j) swap(i,j);
        int k = __lg(j - i);
        return min(st[k][i+1],st[k][j-(1<<k)+1]);
    }
}s1,s2;
int T,n; string s,t; ll f[N],g[N],ans1[N],ans2[N],ans3[N];
void los(){
    cin >> n >> s,t = s,s = s + '#' + string(s.rbegin(),s.rend());
    s1.build(s),s2.build(t);
    auto rev = [&](int i){return n + 2 + n - i;};
    set<int> fk; ll sm = 0; 
    for(int i = n;i >= 1;i --){
        auto it = fk.lower_bound(s2.rk[i]);
        if(it != fk.end()) sm -= s2.h[*it],s2.h[*it] = s2.lcp(*it,s2.rk[i]),sm += s2.h[*it];
        if(it != fk.begin()) s2.h[s2.rk[i]] = s2.lcp(s2.rk[i],*(--it)),sm += s2.h[s2.rk[i]]; 
            else s2.h[s2.rk[i]] = 0;
        fk.insert(s2.rk[i]),ans1[i] = 1ll * (n - i + 1) * (n - i + 2) / 2 - sm;
    }fk.clear(); static set<int> f[N];
    int mxr = 0; 
    for(int i = 1;i <= n;i ++){
        int d = s1.lcp(s1.rk[i],s1.rk[rev(i)]),r = i + d - 1;
        if(r > mxr){
            for(int j = mxr + 1;j <= r;j ++){
                int l = i - (j - i),len = j - l + 1,lcp = 0;
                auto it = f[len].lower_bound(s1.rk[l]);
                if(it != f[len].end()) lcp = max(lcp,s1.lcp(s1.rk[l],*it));
                if(it != f[len].begin()) lcp = max(lcp,s1.lcp(s1.rk[l],*(--it)));
                if(lcp < len) ans2[j] ++,f[len].insert(s1.rk[l]);
            }mxr = r;
        }
    }int mnl = n + 1; 
    for(int i = 1;i <= n;i ++) f[i].clear();
    for(int i = n;i >= 1;i --){
        int d = s1.lcp(s1.rk[i],s1.rk[rev(i)]),l = i - d + 1;
        if(l < mnl){
            for(int j = mnl - 1;j >= l;j --){
                int r = i + (i - j),len = r - j + 1,lcp = 0;
                auto it = f[len].lower_bound(s1.rk[j]);
                if(it != f[len].end()) lcp = max(lcp,s1.lcp(s1.rk[j],*it));
                if(it != f[len].begin()) lcp = max(lcp,s1.lcp(s1.rk[j],*(--it)));
                if(lcp < len) ans3[j] ++,f[len].insert(s1.rk[j]);
            }mnl = l;
        }
    }ll ans = 0;
    for(int i = 1;i <= n;i ++) ans2[i] += ans2[i - 1];
    for(int i = n;i >= 1;i --) ans3[i] += ans3[i + 1];
    for(int i = 1;i < n;i ++) ans = max(ans,1ll * ans2[i] * (ans1[i + 1] - ans3[i + 1]));
    cout << ans;
}int main(){
    ios::sync_with_stdio(0),cin.tie(0);
    for(T = 1;T --;) los();
}
```

---


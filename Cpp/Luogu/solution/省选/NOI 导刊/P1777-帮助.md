# 帮助

## 题目描述

Bubu 的书架乱成一团了！帮他一下吧！

他的书架上一共有 $n$ 本书。我们定义混乱值是连续相同高度书本的段数。例如，如果书的高度是 $[30,30,31,31,32]$，那么混乱值为 $3$；$[30,32,32,31]$ 的混乱度也是 $3$，但 $[31,32,31,32,31]$ 的混乱度是 $5$，这实在是太乱了。

Bubu 想尽可能地减少混乱度，但他有点累了，所以他决定最多取出 $k$ 本书，再随意将它们放到书架上。你能帮助他吗？

## 样例 #1

### 输入

```
5 2
25 25 32 32 25
5 1
25 26 25 26 25
0 0```

### 输出

```
Case 1: 2

Case 2: 3

```

# 题解

## 作者：CYJian (赞：44)

嗯。。

这道题倒是一道蛮好的~~简单~~状压DP。。

我们可以设状态f[i][j][k][l]表示考虑第i本书的时候已经选出了j本书需要取出来，之前存在的书的集合为k，最后一本没有取出来的书的编号为l。那么这样的话转移方程也比较显然了。

若不将这本书取出来: 

$f[i][j][k\ |\ h_i][h_i]\ =\ min(f[i][j][k\ |\ h_i][h_i],\ f[i-1][j][k][l]\ +\ (l\ ==\ h_i\ ?\ 0\ :\ 1))$

若将这本书取出来: 

$f[i][j + 1][k][l]\ =\ min(f[i][j + 1][k][l],\ f[i-1][j][k][l])$

直接这么爆搞就行了。。

最后的答案的话。。

首先枚举$j,\ k,\ l$。若我们设最后的答案为$res$，那么我们就要按照这样更新它:

$res = min(res,\ f[n][j][k][l] + Calc(k\ xor\ S))$

其中$Calc$是计算给出的二进制数中含1的位数，$S$表示输入中所含的书的集合。

这里$Calc$的意义在于: 之前取出来的书中有些高度是前面没有的，所以我们把它取出来后再放进去仍然有$1$的贡献，所以我们需要加上它的贡献。

最后算出来的$res$就是答案了。

~~完美结束~~

P.s. 好像不能直接开这么大的数组，空间会爆掉，需要用循环利用。

---

## 作者：vectorwyx (赞：16)

毒瘤题目。

~~（CYjian巨佬竟然说简单？他是神仙不要在意）~~

首先，我们要取肯定是把连续相同的一段都取出来，因此我们可以用一个二元数组 $(b_{i},w_{i})$ 代替 $a$，其中 $b_{i}$ 为 $a$ 中第 $i$ 段连续且相同的数的大小，$w_{i}$ 为其段长。

接下来考虑 dp。第一想法是令 $f_{i,j}$ 表示前 $i$ 段取出 $j$ 本书，但对于类似于 $25,26,25$ 的情况，取出 $26$ 后它旁边的两个 $25$ 就又凑成了一段，因此后面的那个 $25$ 并不会产生贡献。所以我们的 dp 还需要记录前 $i$ 段取出 $j$ 本书后留在书架上的最后一本书的高度是多少。也就是令 $f_{i,j,l}$ 表示前 $i$ 段取出 $j$ 本书，留在书架上且最靠后的一本书的高度为 $l$ 时的最小混乱度。
 
但事情并没有那么简单，因为我们只是取出了 $j$ 本书，我们还没有考虑把这些书按某个顺序放回书架的问题。显然，如果选出了一本高度为 $h_{i}$ 的书，我们肯定要把它放到高度和它相同的书的旁边。如果书架上没有高度与之相同的书呢？那答案就会 $+1$。因此，我们还要记录书架上还剩哪些高度的书，由于高度介于 $25$ 和 $32$ 之间，因此我们可以把高度离散化，然后状压。

令 $f_{i,j,t,l}$ 表示前 $i$ 段取 $j$ 本，留在书架上的书的高度的集合为 $t$，书架上的最后一本书的高度为 $l$ 的最小混乱度。转移方程为 $f_{i,j,t,l}=f_{i-1,j-w_{i},t,l}$（将第 $i$ 段的 $w_{i}$ 本书取出），以及 $f_{i,j,t,b_{i}}=\min_{p|(1<<b_{i})=t;l=0\sim mx}(f_{i-1,j,p,l}+[b_{i}\not=l])$（不取第 $i$ 段），其中 $<<$ 为左移位操作，$mx$ 为离散化后的 $a$ 数组的最大值 $+1$（因为还要用一个数代表没有最后一本书也就是前面的书全部被取走的情况）。最后 $dp_{m,j,t,l}$ 对应的答案就是 $dp_{m,j,t,l}+calc(S\oplus t)$，其中 $m$ 为 $a$ 数组的段数，$S$ 为最开始书架上的书的高度的集合对应的二进制数，$calc(x)$ 表示二进制数 $x$ 所含 $1$ 的个数。

每组测试数据的时空复杂度为 $O(m\times k\times mx\times 2^{mx})$。因此不需要啥滚动数组（不过最后一个点有点卡常，我是吸氧才过的）。

代码如下（点个赞再走吧QAQ，谢谢您！）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=1<<8;
int dp[101][101][N][9],a[N],b[N],w[N],top,n,k,rp; 

int cal(int x){
	int cnt=0;
	fo(i,0,7) if(x&(1<<i)) ++cnt;
	return cnt;
}

void solve(){
	int AC[10]={0};
	top=0;
	fo(i,1,n) a[i]=read()-25,AC[a[i]]++;
	fo(i,0,9) if(AC[i]) AC[i]=top++;
	fo(i,1,n) a[i]=AC[a[i]];
	int p=1<<top,mx=top;
	top=0;
	int last=1;
	a[0]=a[1];
	fo(i,1,n) if(a[i]!=a[i-1]){
		b[++top]=a[i-1];
		w[top]=i-last;
		last=i;
	}
	b[++top]=a[n];
	w[top]=n+1-last;
	//fo(i,1,top) printf("%d ",b[i]);puts("");
	//fo(i,1,top) printf("%d ",w[i]);puts("");
	//memset(dp,0x3f,sizeof dp);
	fo(i,1,top) fo(j,0,k) fo(t,0,p-1) fo(l,0,mx) dp[i][j][t][l]=3000; 
	dp[1][0][1<<b[1]][b[1]]=1;
	dp[1][w[1]][0][mx]=0;
	fo(i,2,top){
		fo(j,w[i],k){
			fo(t,0,p-1){
				//花w[i]的代价取出i这一段
				fo(l,0,mx){
					dp[i][j][t][l]=dp[i-1][j-w[i]][t][l];
				} 
			}
			fo(t,0,p-1){
				//不取出这一段
				fo(l,0,mx){
					dp[i][j][t|(1<<b[i])][b[i]]=min(dp[i][j][t|(1<<b[i])][b[i]],dp[i-1][j][t][l]+(b[i]!=l?1:0));
				}  
			}			
		}
		//不取出这一段 
		fo(j,0,w[i]-1)
			fo(t,0,p-1)
				fo(l,0,mx){
					dp[i][j][t|(1<<b[i])][b[i]]=min(dp[i][j][t|(1<<b[i])][b[i]],dp[i-1][j][t][l]+(b[i]!=l));
				}
		//fo(j,0,k) fo(t,0,p-1) fo(l,0,mx) printf("(%d,%d,%d,%d)=%d\n",i,j,t,l,dp[i][j][t][l]);
	}
	int ans=2000;
	fo(i,0,k)
		fo(j,0,p-1)
			fo(qaq,0,mx) ans=min(ans,dp[top][i][j][qaq]+cal((p-1)^j));
	printf("Case %d: %d\n\n",rp,ans);
}

int main(){
	while(1){
		n=read(),k=read();
		if(n==0&&k==0) break;
		rp++;
		solve();
	}	
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：lenlen (赞：11)

一道不错的状压 DP 题，有 UVA 账号的话甚至可以再去水一个 [黑题](https://www.luogu.com.cn/problem/UVA1659)（可惜我没有 UVA 账号 QWQ，~~赶紧注册~~）。

### Problem

题目大意：定义一个序列的混乱度为该序列的连续段的段数，你可以从一个长度为 $n$ 的序列中取 $k$ 个数出来，再插入到原序列里面去，问最小的混乱度是多少。

数据范围： $n,k \leq 100,25 \leq a_i \leq 32$。

### Solution

看到 $25 \leq a_i \leq 32$，又发现只是要考虑数字相同的连续段段数，所以跟数字大小没有关系，只要保证原序列中相同的数一直相同即可，最简单的方法就是所有 $a_i$ 减去 $25$，当然也可以离散化。

然后我们可以发现一点，如果你把 $k$ 取出来了，而序列中还有 $k$，那么显然混乱度是不会增加的，你只需要吧取出来的 $k$ 都放在序列中 $k$ 的左右就好了。

我分可以定义状态： $dp_{i,j,k}$ 表示前 $i$ 个数取了 $j$ 个且未取的（即序列中还有的数的种类，使用状态压缩）状态为 $k$ 的最小混乱度，但是很明显可以发现，若我们不取，而它正好和前面一个不取的数相同，混乱度也是不会改变的，所以我们还需要记一维 $s$ 表示前面一个没取的数为 $s$。

因为该题目枚举状态中再由前面的状态转移比较困难（当然不排除大佬这么做，反正我只是个蒟蒻），我们枚举已知状态来推出后面的状态会容易很多。

定义 $dp_{i,j,k,s}$ 表示前 $i$ 个数选了 $j$ 个数出去，且序列中（指 $[1,i]$ 未被选择出去的数）的状态为 $k$，且前一个未被选出去的数为 $s$ 的最小混乱度，初始赋值 $dp_{1,0,2^{a_1},a_1}=1,dp_{1,1,0,8}=0$，其它全为 $inf$，转移方程：

$$dp_{i+1,j,k \mid 2^{a_{i+1}},a_{i+1}}=\min(dp_{i,j,k,s}+[s \not= a_{i+1}])$$

$$dp_{i+1,j+1,k,a_{i+1}}=\min(dp_{i,j,k,s})$$

说明一下： $dp_{1,0,2^{a_1},a_1}$ 表示第一个不选，$dp_{1,1,0,8}=0$ 表示选出第一个，但我们可以发现，现在序列中是没有数的，所以下一个不选出来的数必然会增加 $1$ 的混乱度，所以我们要保证初始的 $dp_{1,1,0,s}$ 要保证 $s$ 和所有数都不相等，而 $s$ 的范围是 $25-25 \leq s \leq 32-25 \Rightarrow s \in [0,7]$，所以我们初始要不在这个范围内。上述转移中 $[A]$ 表示若 $A$ 为真就返回 $1$，否则返回 $0$，即若数不同，那么混乱值要加 $1$。

然后我们可以发现空间复杂度是 $O(m 2^{m-1} n^2)$，其中 $m=32-25+1=8$，可以发现是不会超的，不需要滚动数组。算法优秀的话也是不需要卡常的，所以这题时空其实都不需要可以卡，挺合理的。

### Code

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=102,inf=1e9+7;
int dp[N][N][1<<8|2][9],gt[1<<8],ans=inf;
int n,k,a[N],sum,tot;
int mx(int x,int y){return x>y?x:y;}
int mi(int x,int y){return x<y?x:y;}
void init()
{
	ans=inf;
	for(int i=0;i<=n;i++)
	for(int j=0;j<=k;j++)
	for(int k=0;k<(1<<8);k++)
	for(int s=0;s<=8;s++) dp[i][j][k][s]=inf;
}
int main()
{
	for(int i=0;i<(1<<8);i++)
	{
		for(int j=7;j>=0;j--)
		if((i>>j)&1) gt[i]++;//提前预处理出每种状态的选出来的个数
	}
	while(1)
	{
		scanf("%d%d",&n,&k);sum=0;//总状态
		if(!n&&!k) break;
		for(int i=1;i<=n;i++) scanf("%d",&a[i]),a[i]-=25,sum|=(1<<a[i]);
		init();//初始化
		dp[1][0][1<<a[1]][a[1]]=1;
		dp[1][1][0][8]=0;
		for(int i=1;i<n;i++)
		for(int j=0;j<=k;j++)
		for(int k=0;k<(1<<8);k++)
		for(int s=0;s<=8;s++) 
		{
			if(dp[i][j][k][s]==inf) continue;
			dp[i+1][j][k|(1<<a[i+1])][a[i+1]]=mi(dp[i+1][j][k|(1<<a[i+1])][a[i+1]],dp[i][j][k][s]+(a[i+1]==s?0:1));
			dp[i+1][j+1][k][s]=mi(dp[i+1][j+1][k][s],dp[i][j][k][s]);
		}
		for(int i=0;i<=k;i++)
		for(int j=0;j<(1<<8);j++)
		for(int k=0;k<=7;k++) 
		{
			if(dp[n][i][j][k]==inf) continue;
			ans=mi(ans,dp[n][i][j][k]+gt[sum^j]);//sum为总种类，j为当前情况下序列中未被抽出的数的种类，那么sum^j就是全部抽出来的数的种类，这些数不管放哪里混乱度都会+1
		}
		printf("Case %d: %d\n\n",++tot,ans);
	}
	return 0;
}

```
最后感谢 @EnofTaiPeople 的线下讲解。

---

## 作者：九思 (赞：8)

[题目链接](https://www.luogu.org/problem/P1777)  

stO CYJian Orz  

upd:2019/10/29 更正了几个因手残漏打的小细节

$f[i][j][k][l]$表示的是 前$i$本书 共用了$j$次取出，并将前面未取出的书状压成$k$ 且最后一个未取出的书为$l$时最小的混沌度。  

若不将$i$这本书取出来：
$f[i][j][k | h_i][h_i] = min(f[i][j][k|h_i][h_i],f[i-1][j][k][l]+(l\neq h_i))$

若将$i$这本书取出来：  
$f[i][j+1][k][l]=min(f[i][j+1][k][l],f[i-1][j][k][l])$

- $k$的作用？  
我们来看一组数据：$25,27,25,26,26$，通过转移方程我们知道$27$取出后混沌度会减少，而取出之后的书($kxorS\&\&k\leq S$，$S$为所有书的高度种类数的状压数，异或后只剩下$k$没有而$S$中有高度种类状压数)如果之前出现过，一定可以将它插入到相同高度的书旁边并不影响混沌度，而没有出现过的不管放到哪里都会增加混沌度，所以$k$在统计答案时起到了很重要的作用
- $l$的作用？  
如果我们将$last$到$i$的一些书都取出来了，这时我们如果不取$i$这本书，就需要考虑$last$位置上书的高度，所以需要保存$last$上书的高度。
- 一个坑  
这在许多类似题目中都应该注意，如果第一本书我不取出来，我用什么转移？所以我们需要一个$l\notin[25,32]$来表示第一本书的高度和第零本不一样。什么？为什么？不写试试呗 ；)（一个耿直的微笑）。
- 关于滚动数组
$100\times100\times2^8\times9\times0.5KB/intbit=10170000KB=9.6988678MB$  
如果$n$和$k$扩大个5倍呢？$242.4716949MB$(\*^__^\*) 嘻嘻……所以我们要用滚动数组。

```
#include <bits/stdc++.h>
using namespace std;
template<typename T>
inline void chkmin(T&x, T y) { x = x < y ? x : y; }
#define ge getchar()
#define Re read()
#define rep(i,x,y) for(register int i=x;i<=y;++i)
inline int read() {
	int x = 0, t = 0, ch;
	while(!isdigit(ch = ge)) t |= ch == '-';
	while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = ge;
	return t ? -x : x;
}
const int N = 500;
const int M = 1 << 8;
int T,n,K,S,a[N + 1];
int f[2][102][M][9];
int Change(int x,int sum = 0) {while(x) ++sum, x ^= x & -x;return sum;}
int main() {
    while(++T) {
		n = Re, K = Re, S = 0;
		if(!n)return 0;
		rep(i, 1, n) a[i] = Re - 25, S |= 1 << a[i];
		int o = 1, t = 0;
		memset(f[o], 63, sizeof(f[o]));
		f[o][0][1 << a[1]][a[1]] = 1;
		f[o][1][0][8] = 0;
		int res = 1 << 30, mi = 1;
		rep(i, 2, n) {
			memset(f[t], 63, sizeof(f[t]));
			mi += mi < K;
			rep(j, 0, mi) for(int k = S, tp = S; tp; tp = k, k = (k - 1) & S) rep(l, 0, 8) {
				if(f[o][j][k][l] == 0x3f3f3f3f) continue;
				chkmin(f[t][j][k | (1 << a[i])][a[i]], f[o][j][k][l] + (l != a[i]));
				chkmin(f[t][j + 1][k][l], f[o][j][k][l]);
			}
			o ^= 1, t ^= 1;
		}
		rep(i, 0, K) for(int j = S, tp = j; tp; tp = j, j = (j - 1) & S) rep(k, 0, 7)
			chkmin(res, f[o][i][j][k] + Change(S ^ j));
		printf("Case %d: %d\n\n", T, res);
    }
    return 0;
}
```

---

## 作者：非凡 (赞：6)

有n本书，最多k次操作，每次操作可以把一本书拿出来，放到一个位置去，有一个指标较mess度，他是书的高度的段数，连续的书高度一样算一段，现在给你最先开始各个位置上的书的高度，求操作后最小的mess度。

思路：由于书的高度区间是25~32，种类很少，很容易想到跟状态压缩有关；

所以设d[i][j][s][last]为前 i 本用了 j 次操作，留下的书的种类为 s ，最后一本书为 last 的最小操作数，则每本书处理过去，只有两种选择，要么留下来，要么拿走，状态方程为：

（1）留下来：d[i][j][s|book[i]][book[i]]=min(d[i-1][j-1][s][last]+(book[ i ]==last?0:1)) ；

（2）拿走：d[i][j][s][last]=min(d[i-1][j-1][s][last])。因为我们s表示的留下的书的种类，那么最后的答案就是min(d[n][j][s][last]+one(S^s))，S为总的种类,（S^s）为拿走的书里面的种类减去留下的书有的种类，拿走的书再放进来肯定是每个种类一个段，如果留下来的有这个种类，肯定是插进去，不算段数，没有的那些每个种类都+1。

先开始我自己想的时候，想到的状态量就是d[i][j][last]，每次一本书也只要两种情况，要么往前放，如果前面已经有同种类型的书，那么就不用+1，要么在原位置不动，如果和last相同就不+1，不相同就+1。状压用来判断前面出现过哪些种类的书，就这样敲完，WA。。 不解，遂去网上找了下，别人比我还多了一维 s，想了很久，发现我的DP方程有漏洞，比如：25 25 26 25 25 26 26，肯定是把第一个26往后放，但是我的方程里的状态转移都是往前去放，所以应当是像上面那样考虑先把书拿出来，再总的插进去。

注：以上解析来自[帮助bubu--willinglive--CSDN博客](http://blog.csdn.net/willinglive/article/details/38713097)

以下是我自己打的AC代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define INF 0x7f7f7f7f
#define MAXN 111
using namespace std;
int book[MAXN],d[2][MAXN][1<<8][11],one[1<<8];
int main(){
	for(int i=0;i<(1<<8);i++){
		one[i]=0;
		for(int j = 0;j<8;j++)
		if(i&(1<<j))one[i]++;
	}
	int cas=0,n,k;
	while(~scanf("%d%d",&n,&k)&&(n+k)){
		int S=0,h_max=0;
		for(int i=1;i<=n;i++){
			scanf("%d",&book[i]);book[i]-=25;
			S=S|(1<<book[i]);h_max=max(h_max,book[i]);
		}
		h_max++;
		memset(d[0],0x7f,sizeof(d[0]));
		d[0][0][(1<<book[1])][book[1]]=1;
		d[0][1][0][h_max]=0;int cur=0,pre=0;
		for(int i=1;i<n;i++){
			cur=pre^1;
			memset(d[cur],0x7f,sizeof(d[cur]));
			for(int j=0;j<=k;j++)
			for(int s=0;s<=S;s++)
			for(int last=0;last<=h_max;last++){
				if(d[pre][j][s][last]==INF)continue;
				d[cur][j][s|(1<<book[i+1])][book[i+1]]=min(d[cur][j][s|(1<<book[i+1])][book[i+1]],d[pre][j][s][last]+(book[i+1]==last? 0:1));
				d[cur][j+1][s][last] = min(d[cur][j][s][last],d[pre][j][s][last]); 
			}
			pre=cur;
		}
		int ans=INF;
		for(int j=0;j<=k;j++)
		for(int s=0;s<=S;s++)
		for(int last=0;last<h_max;last++){
			if(d[cur][j][s][last]==INF)continue;int take=S^s;
			ans=min(ans,d[cur][j][s][last]+one[take]);
		}
		printf("Case %d: %d\n\n",++cas,ans);
	}
	return 0;
}
```

---

## 作者：zhangshiyan (赞：5)

# P1777 帮助
[R179778418 记录详情](https://www.luogu.com.cn/record/179778418)

## Main Idea
问题求从书架上取出 $k$ 本书再放入，求最大化书架上连续相同高度的段数。

## Solution
### 思路
对于取出来的书，如果在没取出来的书中出现了同样高度，肯定是塞到一起最优，这样就不会增加混乱度。

如果在没取出来的书中没有出现了同样高度，就塞到整堆书最后，同时把同样高度的书塞到一起。

这样的话，每种状态的混乱度就为没取出的书的混乱度加取出的书在未取出的书中没出现过的高度的种类数（因为相同高度的书塞在一起只加 $1$）。

### 状态
又注意到每本书的高度是 $25$ 到 $32$ 间的整数，高度差不会超过 $8$，设 $h_i$ 为每本书的的高度减 $25$ 所以考虑用状态压缩动态规划。

再考虑转移时需要用到哪些状态。

1. 首先第一维决策到哪本书和第二维已经取出那本书肯定要有。

1. 在算不取出的书的混乱值时还要知道前面一本不取的书的高度。

1. 而最后放书时增加的混乱度与前面不取的书的种类有关，那么这也要定义到状态里面。

所以设状态 $dp_{i,j,k,l}$ 为选到第 $i$ 本书，不取的书的高度种类的状压状态是 $j$，已经取了 $k$ 本书，不取的书的最后一本高度是 $l$，**不取的书**的最小混乱度。

### 初始化
注意由于初始状态不好定义，对于第一本不取的书直接赋值，$dp_{i+1,1 \operatorname{shl} h_{i+1},i,h_{i+1}} \gets 1(i \le k)$。

### 转移
考虑到取书和放书是相对独立的两个操作，可以分开讨论。

不取第 $i+1$ 本书：$dp_{i+1,j \cup \{1 \operatorname{shl} h_{i+1}\},k,h_{i+1}} \gets \min (dp_{i+1,j \cup \{1 \operatorname{shl} h_{i+1}\},k,h_{i+1}}, dp_{i,j,k,l}+(l != h_{i+1}))$。

取第 $i+1$ 本书：$dp_{i+1,j,k+1,l} \gets \min( dp_{i+1,j,k+1,l},dp_{i,j,k,l}$)。

### 答案
最后，对于每个最终的状态，还要加上取出的书造成的混乱度：$ans \gets \min(ans,dp_{n,j,k,l}+cnt_{S \oplus j})$。

其中，$S$ 为所有书的高度种类的状压状态。$cnt_{i}$ 为 $i$ 二进制中 $1$ 的个数。

### 优化
所以最终的时间复杂度是 $O(n \times 2 ^ h \times k \times h)$，刚好可以过，但是会超空间限制，怎么办呢？肯定是用滚动数组来优化空间复杂度。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline ll read()
{
	ll x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 1) + (x << 3) + c - '0';
		c = getchar();
	}
	return x * f;
}

ll n, k;
ll a[505];
ll cnt[(1 << 8) + 5];
ll dp[2][(1 << 8) + 5][105][10];

int main()
{
	ll n, kkk;
	ll ca = 0;
	while(cin >> n >> kkk && n != 0 && kkk != 0)
	{
		memset(dp, 0x3f, sizeof(dp));
		for(ll i = 1; i < (1 << 8); i++)
		{
			cnt[i] = cnt[i & (i - 1)] + 1;
		}
		ll S = 0;
		for(ll i = 1; i <= n; i++)
		{
			a[i] = read();
			a[i] -= 25;
			S |= (1 << a[i]);
		}
		ll cur = 0;
		for(ll i = 1; i <= n; i++)
		{
			cur ^= 1;
			memset(dp[cur], 0x3f, sizeof(dp[cur]));
			if(i - 1 <= kkk)
			{
				dp[cur][1 << a[i]][i - 1][a[i]] = 1;
			}
			for(ll j = 1; j <= (1 << 8) - 1; j++)
			{
				for(ll k = 0; k <= kkk; k++)
				{
					for(ll l = 0; l < 8; l++)
					{
						dp[cur][j | (1 << a[i])][k][a[i]] = min(dp[cur][j | (1 << a[i])][k][a[i]], dp[cur ^ 1][j][k][l] + (l != a[i])) ;
						dp[cur][j][k + 1][l] = min(dp[cur][j][k + 1][l], dp[cur ^ 1][j][k][l]) ;
					}
				}
			}
		}
		ll ans = 1e9;
		for(ll i = 0; i < (1 << 8); i++)
		{
			for(ll j = 0; j <= kkk; j++)
			{
				for(ll l = 0; l < 8; l++)
				{
					ans = min(ans, dp[cur][i][j][l] + cnt[S ^ i]);
				}
			}
		}
		printf("Case %lld: %lld\n\n", ++ca, ans);
	}
	return 0;
}
```

---

## 作者：0Io_oI0 (赞：4)

这道题目是一道 dp 题目呦~

题目就是让我们最小化书架的混乱值，我们可以通过取出最多 $k$ 本书并重新放置来减少混乱度。

还是放上 dp 要素：

1. 使用四维动态规划来跟踪处理到第 $i$ 本书时，取出j本书后的状态，包括最后保留的书的颜色和保留的颜色集合。 
2. `dp[i][j][last][mask]` 表示前 $i$ 本书，取出 $j$ 本，最后一本的颜色是 $last$，保留的颜色集合是 $mask$ 时的最小段数。
3. 对于每本书，可以选择保留或取出。
4. 计算每个可能的颜色集合和取出书本数的最小颜色数目。

如果还没有听懂可以看看代码注释！

```cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
I AK IOI;

const int INF = 1e9;

signed main() {
    int n, k;
    int c = 0; // case 编号
    while (cin >> n >> k && (n || k)) {
        c++;
        int b[105]; // 存储书的高度
        int cnt[8] = {0}; // 记录每种高度书的数量

        for (int i = 0; i < n; i++) {
            int h;
            cin >> h;
            b[i] = h - 25;
            cnt[b[i]]++;
        }

        // 动态规划数组
        int dp[105][105][9][1 << 8];
        memset(dp, 0x3f, sizeof(dp));
        dp[0][0][8][0] = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                for (int l = 0; l <= 8; l++) {
                    for (int m = 0; m < (1 << 8); m++) {
                        if (dp[i][j][l][m] >= INF) continue;

                        int cur = dp[i][j][l][m];
                        int col = b[i];

                        // 保留当前书
                        int nm = m | (1 << col);
                        int nl = col;
                        int ns = cur + (col != l ? 1 : 0);
                        if (ns < dp[i + 1][j][nl][nm]) {
                            dp[i + 1][j][nl][nm] = ns;
                        }

                        // 取出当前书
                        if (j + 1 <= k) {
                            if (cur < dp[i + 1][j + 1][l][m]) {
                                dp[i + 1][j + 1][l][m] = cur;
                            }
                        }
                    }
                }
            }
        }

        int minC = INF; // 最小混乱度
        for (int j = 0; j <= k; j++) {
            for (int l = 0; l <= 8; l++) {
                for (int m = 0; m < (1 << 8); m++) {
                    if (dp[n][j][l][m] >= INF) continue;

                    // 计算属于 m 的书的数量
                    int sm = 0;
                    for (int col = 0; col < 8; col++) {
                        if (m & (1 << col)) sm += cnt[col];
                    }

                    int sM = min(j, n - sm);
                    int sMin = max(0, j - (sm - (n - j)));

                    if (sMin > sM) continue;

                    int notM[8];
                    int idx = 0;
                    for (int col = 0; col < 8; col++) {
                        if (!(m & (1 << col))) {
                            notM[idx++] = cnt[col];
                        }
                    }
                    sort(notM, notM + idx, greater<int>());

                    int minT = INF;
                    for (int s = sMin; s <= sM; s++) {
                        int r = s;
                        int t = 0;
                        for (int i = 0; i < idx; i++) {
                            if (r <= 0) break;
                            int take = min(notM[i], r);
                            t++;
                            r -= take;
                        }
                        if (r == 0) {
                            minT = min(minT, t);
                        }
                    }

                    if (minT != INF) {
                        int tot = dp[n][j][l][m] + minT;
                        if (tot < minC) {
                            minC = tot;
                        }
                    }
                }
            }
        }

        cout << "Case " << c << ": " << minC << endl << endl;
    }
    i_ak ioi;
}
```

亲测可过，请勿抄袭！

---

## 作者：耶梦加得 (赞：1)

这题要想到状压 DP 相对比较简单，书的高度在 $25$ 到 $32$ 之间，就差把状压写在题目里了。我们之后默认把高度（用 $a[i]$ 表示）减去 $25$。

~~结果我没看到这个条件在那儿自闭了半天。~~

这题比较麻烦的一点在于，把书拿出来之后还要再放回去。那么最后的混乱度会由两部分组成：没有被取出的书构成的序列的混乱度，以及我们把书放回去以后增加的混乱度。

容易想到，如果序列中有相同高度的书，那么把书放进去不会增加混乱度，否则混乱度就会增加 1。

那么假如我们原先的种类为 $S$（经过状压，第 $i$ 位表示高度为 $i$ 的书是否存在），留下的书的种类为 $S'$，那么放回去的时候会增加 $popcount(S \oplus S)$ 的混乱度。

又因为序列混乱度在加入一个元素时是否 $+1$ 仅与原先的最后一个元素的**种类**有关，由此我们可以设计状态：$f[i][j][s][l]$ 表示处理前 $i$ 本书时，拿走了 $j$ 本书，留下的书构成集合 $s$，最后一个没被拿走的书高度为 $l$（没有的话视作 $8$）。

~~如果没有最后一个状态，找决策的过程会是 $O(n)$ 的导致 T 飞~~。

转移也比较简单，分为第 $i$ 本书拿和不拿。

拿：$f[i][j][s |2^{a[i]}][a[i]] = min_{0\le l \le 8} (f[i - 1][j][s][l])$；

不拿：$f[i][j][s][l] = f[i][j - 1][s][l]$；

一开始都是 $inf$，边界条件为 $f[0][0][0][8] = 0$。

第一维可以滚动数组滚掉。实现上，要注意各个循环内外顺序。

```
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
int n, K, S, ans;
int f[2][107][257][11];
int a[107], pcnt[257];
signed main() {
    for(int i = 0; i < 256; ++i) {
        for(int j = 0; j <= 7; ++j) {
            if((1 << j) & i) ++pcnt[i];
        }
    } //预处理 popcount 数组防卡常
    int cT = 0;
    while(true) {
        scanf("%d %d", &n, &K);
        if(!n && !K) break;
        S = 0; ans = 0x3f3f3f3f;
        for(int i = 1; i <= n; ++i) {
            scanf("%d", a + i);
            a[i] -= 25;               //别忘了 -25
            S |= (1 << a[i]);
        }
        memset(f, 0x3f, sizeof(f));
        f[0][0][0][8] = 0;
        for(int i = 1; i <= n; ++i) {
            int p = i % 2, l = p ^ 1;
            memset(f[p], 0x3f, sizeof(f[p])); 
            //别忘了把原来的数据滚掉
            for(int k = 0; k <= K; ++k) {
                for(int s = 0; s <= S; ++s) {
                    for(int j = 0; j <= 8; ++j) {
                        if(f[l][k][s][j] == 0x3f3f3f3f)continue;
                        //亲测必须加上这行否则不开O2会T
                        f[p][k][s | (1 << a[i])][a[i]] = min(f[p][k][s | (1 << a[i])][a[i]], f[l][k][s][j] + (a[i] == j ? 0 : 1));
                        f[p][k + 1][s][j] = f[l][k][s][j];
                    }
                }
            }
        }
        for(int j = 0; j < 8; ++j) {
            for(int s = 0; s <= S; ++s) {
                for(int k = K; k >= 0; --k) {
                    ans = min(ans, pcnt[S ^ s] + f[n % 2][k][s][j]);
                }
            }
        }
        printf("Case %d: %d\n\n", ++cT, ans);
        //没有#
    }
    return 0;
}
   
```


---

## 作者：zach0914 (赞：1)

# [帮助](https://www.luogu.com.cn/problem/P1777)

---

这道题好题，接下来我们从头到尾详细地分析一遍这道题的做法以及给我们以后做题目的启发。

---

考虑到 $25$ 到 $32$ 这一值域很小，并且可以整体平移到 $0$ 到   $7$，这是原始想法。

---

接下来积累一个比较好的想法：**将一个数抽出来再放回去相当于仅仅把抽出来的数一股脑取出来，最后再进行插入操作**。

该转化有何好处呢？
1. 可以将复杂的问题分步解决；2. 转化为较为通用的问题：也即，我们将原问题转化为了从一个序列删一些数，再加一些数求最值。

该转化可以被广泛地应用。

回到本道题，我们可以将问题视作：先从这一堆数中取走若干个数，再将这若干个数插回去，在该过程中，如果取出的一些在数值上相等，按照贪心来讲，插入回去的时候必定在一起，因为这样最优。

---

有了这样的想法，我们不妨定义状态：
$$
dp(i,j,0/1)
$$
分别代表前 $i$ 个数，还剩 $j$ 次操作能使用，是否被取走的最小混乱度。

接着我们转移，发现：

1. 诶？如果我们选择取走，那么直接转移，但是最小混乱度还需要加上我们取走的数重新加入原序列中造成的混乱度；
2. 那若我们不取走，就会发现若上一个数选择取走，我们整个状态转移没办法进行。

因此，我们不难想到可以更加**细致化**状态。

---

再考虑数据范围，诶？$1$~$8$？这么小。

我们可以给原来的状态加一个维度.
$$
dp(i,j,S)
$$
其中 $S$ 代表**包括$i$在内**前面被取走数的集合。

那么我们有：
$$
dp(i+1,j+1,S\cup\{a_{i+1}\})=min(dp(i,j,S))\\dp(i+1,j,S)=min(dp(i,j,S))+w
$$
第一个方程很容易理解，而第二个方程中的$w$是啥？

我们考虑，当 $a_{i+1}$ 与 $a_i$ 数值相同时，$w$ 就等于 $0$ ，如果不相同，$w$ 就等于 $1$。

且慢

如果 $a_i$ 这个数被取走了呢？？？我们便不是这么好办了。

因而，我们需要再加一维进行描述。

所以，我们能这样吗：
$$
dp(i,j,S,0/1)
$$
~~集百家之所短~~

它的问题出在了我们没办法直接确定上一个保留的数是否与之相等。

那么，我们这样呗：
$$
dp(i,j,S,pre)
$$
$pre$ 代表上一个被保留的数的位置。

已经可以搞了。

---


$$
dp(i+1,j+1,S\cup\{a_{i+1}\},pre)=min(dp(i,j,S,pre))\\dp(i+1,j,S,i+1)=min(dp(i,j,S,pre))+(if\ (a_{pre}\not=a_{i+1})1;\ else\ 0)
$$
那么，这个式子就可以通过了吗？别忘了**滚动数组**啦。

那最终答案怎么表示呢？

好问题，不太好解决——保留的数的混乱度加上取走的数重新排队的混乱度，我们记录的集合 $S$ 好像不能记录保留的数中有与之相等的数。因为如果原序列中有相等的数，那么取出来的数最优的情况是和该数接在一起生活。

第二个思想：补集转化。

既然我们知道取出来的数集合作为状态的一维不利于统计答案，那么我们可不可以使保留的数作为状态的一维？

这是可以实现的。并且答案就是所有数值的集合减去未被取出来的数值集合剩下的数各成一峰。

总的时间复杂度为：$O(n^2*k*2^7)$，卡一卡常就过了。

---

其实进一步优化：

考虑到我们最后那一维其根本我们是来解决上一个未取出的数的数值是否与当前不取出的数相等。

因为数的值域那么小，我们仅记录上一个数的数值是多少即可。$O(n*k*2^{11})$

---

我们总结一下：

1. 我们考虑到原问题的值域较小，因此我们平移该值域；
2. 将取出一个数再放回去的动作转化；
3. 将状态精细化，这也是DP常见的做法；
4. 补集转化思想，将取出来转化为不取出来；
5. 状态精简。

这个问题就这样迎刃而解了。
```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define RE register
#define CLR(x, y) memset(x,y,sizeof x)
#define FOR(i, x, y) for(RE int i=x;i<=y;++i)
#define ROF(i, x, y) for(RE int i=x;i>=y;--i)
#define lowbit(x) (x&(-x))
using namespace std;

const int S = 555 + 5, MAXN = 100 + 5, MAXK = 100 + 5, INF = 1 << 30;

int n, k, a[MAXN], num[S] = {};

void init()
{
	int tmp;
	for(RE int i = 0; i < S; ++ i)
	{
		tmp = i;
		while(tmp)
		{
			++ num[i];
			tmp -= lowbit(tmp);
		}
	}
	return;
}

int solve(int mask)
{
	static int dp[MAXK][S][10], new_dp[MAXK][S][10];
	int res = INF;
	CLR(dp, 0x3f), CLR(new_dp, 0x3f);
	FOR(i, 0, k) dp[i][0][0] = 0;
	FOR(i, 0, n - 1)
	{
		FOR(j, 0, k)
			FOR(s, 0, mask) 
				FOR(l, 0, 8) 
					{
						int &ans = dp[j][s][l];
						new_dp[j][s | (1 << a[i + 1] - 1)][a[i + 1]] = min(new_dp[j][s | (1 << a[i + 1] - 1)][a[i + 1]], ans + (l != a[i + 1]));
						new_dp[j + 1][s][l] = min(new_dp[j + 1][s][l], ans);
				 	} 
		FOR(j, 0, k)
			FOR(s, 0, mask)
				FOR(l, 0, 8)
					dp[j][s][l] = new_dp[j][s][l], new_dp[j][s][l] = INF;
	}
	FOR(s, 0, mask) 
		FOR(l, 0, 8) res = min(res, dp[k][s][l] + num[s ^ mask]);
		
	return res;
}

int main()
{
	int state, cnt = 0;
	init();
	while(233)
	{
		scanf("%d %d", &n, &k);	
		if(!n && !k) return 0;
		state = 0;
		FOR(i, 1, n) 
		{
			scanf("%d", &a[i]); 
			a[i] -= 24, state |= (1 << (a[i] - 1));
		}
		printf("Case %d: %d\n\n", ++ cnt, solve(state));
	}
	return 0;
}
```


---

## 作者：GalwayGirl (赞：1)

## Solution

状态比较复杂，我们慢慢来分析。

万事开头难。首先，我们可以套路的去设 $f_{i,j}$ 表示到第 $i$ 本书取走了 $j$ 本的最小段数，然后发现根本就无法转移，因为不知道是否要增加混乱度。

那就再开一维，设 $f_{i,j,l}$ 这里的 $l$ 表示上一次没有取走的书的高度，这样如果接下来要保留的书的高度与 $l$ 不一样，混乱度就可以加 $1$。

是不是感觉做完了，其实还没有。因为取走书的操作就是将书放入相同的一段中这样就不用加上混乱度，但试想一下，如果取走的这种高度的书只有一本，那插在哪里混乱度都会加上 $1$。可以观察到书的高度范围为 $25 \sim32$  离散化一下高度就成了 $0\sim7$，就只有 $8$ 本，这也给了我们提示：状压。我们可以把先前没有取走的书集合压入状态，这样就能知道被取走的书是不是单独一本了，那就再加一维，设 $f_{i,j,k,l}$ 这里的 $k$ 就表示保留书的高度的集合，然后就可以考虑转移：

1. 取走这本书：

$$f_{i+1,j+1,k,l}=\min f_{i,j,k,l}$$

2. 不取：
					
 $$f_{i+1,j,k|h_{i+1},h_{i+1}}=\min f_{i,j,k,l}+[h_{i+1}\neq l] $$

最后贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=101;
int n,K,tot,h[N],f[N][N][1<<8][9],min_,goal;
void solve(){tot++;min_=1e9;	
	memset(f,0x3f3f3f,sizeof(f));goal=0;
	for(int i=1;i<=n;i++)cin>>h[i],h[i]-=25,goal|=(1<<h[i]);
	f[0][0][0][8]=0;
	for(int i=0;i<n;i++){
		for(int j=0;j<=K;j++){
			for(int k=0;k<(1<<8);k++){
				for(int l=0;l<=8;l++){
					if(i==0)l=8;
					if(l==8&&k)continue;
					if(l!=8&&!(k&(1<<l)))continue;
					f[i+1][j+1][k][l]=min(f[i+1][j+1][k][l],f[i][j][k][l]);
					f[i+1][j][k|(1<<h[i+1])][h[i+1]]=min(f[i+1][j][k|(1<<h[i+1])][h[i+1]],f[i][j][k][l]+(h[i+1]!=l));
				}
			}
		}
	}
	for(int j=0;j<=K;j++){
		for(int k=0;k<(1<<8);k++){
			bool flag=false;int cnt=0;
			for(int yi=0;yi<8;yi++){
				if((k&(1<<yi))&&!(goal&(1<<yi))){
					flag=true;break;
				}
				if(!(k&(1<<yi))&&(goal&(1<<yi)))cnt++;
			}
			if(flag)continue;
			for(int l=0;l<=7;l++)min_=min(min_,f[n][j][k][l]+cnt);
		}
	}
	cout<<"Case "<<tot<<": "<<min_<<endl<<endl;
}
int main(){
	ios::sync_with_stdio(false);
	while(cin>>n>>K){if(n==0&&K==0)return 0;solve();}
}
```
最后祝大家 NOIP RP++。

---


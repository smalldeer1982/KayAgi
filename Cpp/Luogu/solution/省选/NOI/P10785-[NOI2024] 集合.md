# [NOI2024] 集合

## 题目描述

小 Y 和小 S 在玩一个游戏。

给定正整数 $m$，定义**基本集合**为大小为 $3$，元素在 $1\sim m$ 内的集合。例如：给定 $m=4$，则集合 $\{1,2,3\}$ 与集合 $\{2,3,4\}$ 都是基本集合。

定义**集合序列**为由基本集合构成的序列，例如，$A=[\{1,2,3\},\{2,3,4\}]$ 是一个集合序列，其中 $A[1]=\{1,2,3\}$，$A[2]=\{2,3,4\}$ 都是基本集合。

对于一个 $1\sim m$ 的排列 $p[1],p[2],\dots,p[m]$ 与集合 $S\subseteq \{1,2,\dots,m\}$，定义 $f_p(S)$ 为将 $S$ 内每一个元素 $x$ 置换为 $p[x]$ 后所得到的集合，即 $f_p(S)=\{p[x]|x\in S\}$。

对于两个长度为 $k$ 的集合序列 $A,B$，定义 $A$ 和 $B$ **等价**当且仅当存在一个 $1\sim m$ 的排列 $p$，使得 $A$ 置换排列 $p$ 后得到 $B$，即对于所有 $1\leq i\leq k$，$f_p(A[i])=B[i]$。

给定两个长度为 $n$ 的集合序列 $A,B$，有 $q$ 次询问。每次小 S 会询问小 Y，在给定 $l,r$ 的情况下，判断集合序列 $[A[l],A[l+1],\dots,A[r]]$ 与集合序列 $[B[l],B[l+1],\dots,B[r]]$ 是否等价。

时光荏苒，小 S 和小 Y 也会散去。而我们和一个人保持连接的方式就是记住，仅此而已。

## 说明/提示

**【样例 1 解释】**

以下用 $(l,r)$ 表示对 $l,r$ 的询问：
- 对于询问 $(1,1)$，令排列 $p=[1,2,4,3]$，则 $f_p(A_1)=\{p[1],p[2],p[3]\}=\{1,2,4\}=B[1]$，因此该询问对应的两个序列等价。
- 对于询问 $(1,2),(1,3),(1,4)$，由于 $A[1]=A[2]$ 但 $B[1]\neq B[2]$，因此这些询问对应的两个序列都不等价。
- 对于询问 $(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)$，令排列 $p=[2,3,4,1]$，则 $f_p(A_2)=\{p[1],p[2],p[3]\}=\{2,3,4\}=B_2$，$f_p(A_3)=\{p[1],p[2],p[4]\}=\{1,2,3\}=B_3$，$f_p(A_4)=\{p[1],p[2],p[3]\}=\{2,3,4\}=B_4$，因此这些询问对应的两个序列都等价。

**【数据范围】**

对于所有测试数据保证：$1\leq n\leq 2\times 10^5$，$3\leq m\leq 6\times 10^5$，$1\leq q\leq 10^6$，$1\leq l\leq r\leq n$。

::cute-table{tuack}

| 测试点编号 | $n\leq$ | $m\leq$ | $q\leq$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $50$ | $4$ | $50$ |
| $4\sim 6$ | $50$ | $5$ | $50$ |
| $7$ | $200$ | $4$ | $200$ |
| $8$ | $200$ | $5$ | $200$ |
| $9$ | $200$ | $4$ | $2\times 10^5$ |
| $10$ | $200$ | $5$ | $2\times 10^5$ |
| $11$ | $2\times 10^5$ | $4$ | $2\times 10^5$ |
| $12$ | $2\times 10^5$ | $5$ | $2\times 10^5$ |
| $13,14$ | $2\,000$ | $6\,000$ | $10^3$ |
| $15,16$ | $2\,000$ | $6\,000$ | $10^6$ |
| $17,18$ | $2\times 10^4$ | $6\times 10^4$ | $10^2$ |
| $19,20$ | $2\times 10^5$ | $6\times 10^5$ | $10^6$ |


## 样例 #1

### 输入

```
4 4 10
1 2 3 1 2 3 1 2 4 1 2 3
1 2 4 2 3 4 1 2 3 2 3 4
1 1
1 2
1 3
1 4
2 2
2 3
2 4
3 3
3 4
4 4```

### 输出

```
Yes
No
No
No
Yes
Yes
Yes
Yes
Yes
Yes```

## 样例 #2

### 输入

```
见 set2.in/ans
这个样例满足测试点 1-3 的约束条件。```

### 输出

```
```

## 样例 #3

### 输入

```
见 set3.in/ans
这个样例满足测试点 8 的约束条件。```

### 输出

```
```

## 样例 #4

### 输入

```
见 set4.in/ans
这个样例满足测试点 15、16 的约束条件。```

### 输出

```
```

# 题解

## 作者：ty_mxzhn (赞：34)

免责声明：场外选手纯凑热闹。我只是一个 CSP-S 2= 的准退役选手别骂我呜呜呜

注：本题解中哈希是广义的，把一些信息**压缩或转化**成另一些信息的方式。

看到**排列对应**，想起自己之前做过的一道题。在看到**判定相等**，就发现本题可能可以使用哈希解决。[2022 年也考了](https://www.luogu.com.cn/problem/P8499)。

作为一道哈希题，第一步肯定需要思考一种可能的哈希方案。容易想到记 $S_{x}$ 为颜色 $x$ 在**集合出现时集合的编号**所构成的集合。例如：$a_1=\{1,2,3\},a_2=\{2,1,4\},a_3=\{1,3,4\}$ 中，$S_1=\{1,2,3\},S_2=\{1,2\}$。再记多重集合 $H$ 为所有颜色的 $S_x$ 构成的集合。通过手玩发现 $a \cong b \Leftrightarrow H_a =H_b$。

众所周知的，判定两个集合相等可以使用哈希。容易想到，$\displaystyle \prod_{i=1}^m G(\sum_{j=1}^n [i \in S_j] \times p^j) \bmod p_0$ 是一种非常优秀的哈希方式。其中 $G$ 是一个你自己任选的哈希函数。

其实做到这一步已经**有可能**可以实现了。但是注意到题目中并不需要你对任意的两个数组哈希，而是 $a[l,r]$ 和 $b[l,r]$。这意味着判定具有单调性。我们可以移动 $r$ 然后找最小的 $l$ 满足 $[l,r]$ 被判定为 $\texttt{Yes}$。（双指针）

双指针时哈希值可以支持删除和插入。于是这道题就做完了。

总结：哈希和双指针两个关键点挺难想的。个人感觉板回了去年 [NOI 2023 Day1 T1 方格染色](https://www.luogu.com.cn/problem/P9478)较水的局面。

但是作者太菜了，而且怕给其他人带来不便，所以不放代码了。

---

## 作者：rzh123 (赞：25)

对于一组询问 $[l,r]$，$x\in [1,m]$，设“出现位置集合” $\text{posa}_{l,r,x}=\{i\in[l,r]\vert x\in A_i \}$， $\text{posb}_{l,r,x}=\{i\in[l,r]\vert x\in B_i \}$。

排列 $p$ 就是把每一个数 $x$ 匹配到 $p_x$，如果 $\text{posa}_{l,r,x}=\text{posb}_{l,r,y}$ 则 $x$ 可以匹配到 $y$。

$A[l\ldots r]$ 和 $B[l\ldots r]$ 等价当且仅所有 $\text{posa}_{l,r,x}$ 构成的多重集和所有 $\text{posb}_{l,r,x}$ 构成的多重集相等。相等时每一个数 $x$ 可以匹配到不同的 $y$，不相等时一定匹配不完。  

对于同一个 $l$，$r$ 越大则限制越严，一定存在一个分界线 $\text{tor}_l$，使得所有 $[l,\text{tor}_l]$ 的 $r$ 对应答案是 `Yes`，$(\text{tor},n]$ 的 $r$ 答案是 `No`，可以双指针求出每个 $\text{tor}_l$，$O(1)$ 回答每个询问。   

考虑双指针过程中如何判断 $[l,r]$ 是否合法，需要支持：插入一个下标，删除一个下标，查询当前两个多重集是否等价，可以用和哈希判断。定义两个函数 $f,g$，$f$ 把下标映射成随机数，$g$ 把一个随机数映射成另一个随机数，$f,g$ 最好都是非多项式函数，用 $F(\text{pos})=\sum\limits_{i\in\text{pos}} f(i) \bmod P$ 表示一个出现位置集合，$G(T)=\sum\limits_{S\in T} g(F(S)) \bmod P$ 表示出现位置集合构成的多重集，如果两个多重集的 $G$ 相等则它们很大概率是相等的，模数可以直接用 `long long unsigned` 自然溢出，可以多随机几次判断，插入删除都比较简单。  
  
时间复杂度 $O(n+q)$。  
  
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N=2e5+5,M=6e5+5;
using llu=long long unsigned;
int n,m,q,tor[N];
int a[N][3],b[N][3];
mt19937_64 rnd(chrono::system_clock::now().time_since_epoch().count());
llu mp[N];
llu ap[M],bp[M],s1,s2;
llu msk;
llu shf(llu x){
    if(!x) return x;
    x^=msk,x^=x<<7,x^=x>>11,x^=x<<13;
    return x;
}
void add(int i,int d){
    for(int j:a[i]){
        s1-=shf(ap[j]);
        if(d>0) ap[j]+=mp[i];
        else ap[j]-=mp[i];
        s1+=shf(ap[j]);
    }
    for(int j:b[i]){
        s2-=shf(bp[j]);
        if(d>0) bp[j]+=mp[i];
        else bp[j]-=mp[i];
        s2+=shf(bp[j]);
    }
}
int main(){
    // freopen("set.in","r",stdin);
    // freopen("set.out","w",stdout);
    cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m>>q;
    for(int i{1};i<=n;++i){
        cin>>a[i][0]>>a[i][1]>>a[i][2];
    }
    for(int i{1};i<=n;++i){
        cin>>b[i][0]>>b[i][1]>>b[i][2];
    }
    for(int i{1};i<=n;++i) tor[i]=n;
    int tt=10;
    while(tt--){
        msk=rnd();
        for(int i{1};i<=n;++i) mp[i]=rnd();
        add(1,1);
        for(int i{1},j{1};i<=n;add(i,-1),++i){
            while(j<=n&&s1==s2){
                ++j;
                if(j<=n) add(j,1);
            }
            tor[i]=min(tor[i],j-1);
        }
    }
    while(q--){
        int l,r; cin>>l>>r;
        if(r<=tor[l]) cout<<"Yes\n";
        else cout<<"No\n";
    }
    return 0;
}
```  

赛时能过。

---

## 作者：未来姚班zyl (赞：17)

## 题目大意

题面十分详细。

## 题目分析

我们要相信官方数据的强度，并开始发扬人类智慧。

首先瞪出来一个结论：区间 $[l,r]$ 合法，当且仅当对于每一个子区间 $[l',r']$,$A$ 和 $B$ 中出现的数的**次数**构成的可重集相等。

考场时我莫名其妙地认为这个结论是对的，也莫名奇妙地发现确实是对的，它和正确的结论有冥冥中的相似，欢迎大佬来证明。

然后只需要维护每个左端点 $l$ 能够延伸到的最靠右的右端点 $r$，使得对于所有 $l\le r'\le r$，区间 $[l,r']$ 中数的出现次数构成的可重集相等，查询只需 RMQ 即可。然而这显然是无法双指针的。

但是聪明的我们可以知道，CCF 的数据是很厉害的，厉害到可以送很多分。

我们做一个亚双指针：每次右移左指针 $l$ 时，将右指针 $r$ 往左移 $\frac{\sqrt l}{2}$。

只要出题人没有想到这个做法，就卡不掉。

结果果然没卡，虽然连 pretest 都没过，但过了正式数据。

完全不用 Hash，复杂度 $O(n\sqrt n)$。

---

## 作者：Register_int (赞：10)

场外选手口胡。

首先有说句废话：一个区间 $[l,r]$ 是好的，当且仅当对于 $a_{[l,r]}$ 中的每一个元素 $x$，都存在 $b_{[l,r]}$ 中的另一个元素 $y$ 与其匹配，使得 $x,y$ 出现的位置相同。

不妨对于每一个左端点 $l$，求出最大的合法的右端点 $r$。可以尺取，用 sum hash 记录每个数在当前区间内的位置集合，再记录每一种位置集合在 $a$ 中出现的数量减去在 $b$ 中出现的数量。在差全为 $0$ 判断有解，否则判断无解即可。这部分复杂度是 $O(n+m)$，预处理后就能 $O(1)$ 回答每个询问，复杂度 $O(n+m+q)$。

# 不知死活的代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int MAXN = 6e5 + 10;

mt19937_64 eng(time(0));

int n, m, q, ans; unordered_map<ull, int> cnt;

ull w[MAXN], ha[MAXN], hb[MAXN]; int a[MAXN][3], b[MAXN][3], p[MAXN];

inline void add(ull x) { cnt[x]++ && --ans, cnt[x] && ++ans; }
inline void del(ull x) { cnt[x]-- && --ans, cnt[x] && ++ans; }

inline 
void upd(int i, int t) {
	del(ha[a[i][0]]), del(ha[a[i][1]]), del(ha[a[i][2]]);
	if (t == 1) ha[a[i][0]] += w[i], ha[a[i][1]] += w[i], ha[a[i][2]] += w[i];
	else ha[a[i][0]] -= w[i], ha[a[i][1]] -= w[i], ha[a[i][2]] -= w[i];
	add(ha[a[i][0]]), add(ha[a[i][1]]), add(ha[a[i][2]]);
	
	add(hb[b[i][0]]), add(hb[b[i][1]]), add(hb[b[i][2]]);
	if (t == 1) hb[b[i][0]] += w[i], hb[b[i][1]] += w[i], hb[b[i][2]] += w[i];
	else hb[b[i][0]] -= w[i], hb[b[i][1]] -= w[i], hb[b[i][2]] -= w[i];
	del(hb[b[i][0]]), del(hb[b[i][1]]), del(hb[b[i][2]]);
}

int main() {
	scanf("%d%d%d", &n, &m, &q);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &a[i][0], &a[i][1], &a[i][2]);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &b[i][0], &b[i][1], &b[i][2]);
	for (int i = 1; i <= n; i++) w[i] = eng();
	for (int i = 1, j = 0; i <= n; i++) { for (; j <= n && !ans; upd(++j, 1)); p[i] = j, upd(i, -1); }
	for (int l, r; q--;) scanf("%d%d", &l, &r), puts(p[l] > r ? "Yes" : "No");
}
```

---

## 作者：Gaode_Sean (赞：6)

考虑两个序列等价的充要条件是什么。

(以下 $a$ 序列和 $b$ 序列指的是询问中的两个序列)

可以得出，对于 $a$ 序列中每个数出现的位置所组成的集合，一定能在 $b$ 序列找到一个与其对应的数，出现的位置组成的集合与前者相同。

考虑使用 hash 判定该条件是否成立。具体地，对于每个位置赋一个随机权值，并定义在 $a,b$ 序列中出现的数的权值为其出现的位置的权值之和。维护 $a$ 序列中出现的数的立方和与 $b$ 序列中出现的数的立方和的差。当差为 $0$ 时，条件成立。

考虑使用莫队，复杂度 $\mathcal{O}(q\sqrt{n})$，可以获得 $80$ 分。

注意到我们要回答的是一个判定性问题，可以想到用双指针优化，即对于每一个左端点 $l$，求出最大的合法的右端点 $r$。

时间复杂度 $\mathcal{O}(n+q)$。

代码写得有点丑。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5,M=6e5+5;
int n,m,q;
int a[N][4],b[N][4],mx[N];
ll res;
ll w[N],rs[5],ca[M][5],cb[M][5],mod[5]={0,998244353,1000000001,1000000003,1000000007};
void add_a(int pos,int x,ll val)
{
	for(int i=1;i<=4;i++)
	{
		rs[i]=(rs[i]-ca[a[pos][x]][i]*ca[a[pos][x]][i]%mod[i]*ca[a[pos][x]][i]%mod[i]+mod[i])%mod[i];
		ca[a[pos][x]][i]=(ca[a[pos][x]][i]+val*w[pos]+mod[i])%mod[i];
		rs[i]=(rs[i]+ca[a[pos][x]][i]*ca[a[pos][x]][i]%mod[i]*ca[a[pos][x]][i]%mod[i]+mod[i])%mod[i];
	}
	res=0;
	for(int i=1;i<=4;i++) res+=rs[i];
}
void add_b(int pos,int x,ll val)
{
	for(int i=1;i<=4;i++)
	{
		rs[i]=(rs[i]+cb[b[pos][x]][i]*cb[b[pos][x]][i]%mod[i]*cb[b[pos][x]][i]%mod[i]+mod[i])%mod[i];
		cb[b[pos][x]][i]=(cb[b[pos][x]][i]+val*w[pos]+mod[i])%mod[i];
		rs[i]=(rs[i]-cb[b[pos][x]][i]*cb[b[pos][x]][i]%mod[i]*cb[b[pos][x]][i]%mod[i]+mod[i])%mod[i];
	}
	res=0;
	for(int i=1;i<=4;i++) res+=rs[i];
}
void calc(int pos,int val)
{
	for(int i=1;i<=3;i++) add_a(pos,i,val),add_b(pos,i,val);
}
int rando(){return (1ll*rand()*rand()+1ll*rand()*rand()*rand())%998244353;}
int main()
{
	scanf("%d%d%d",&n,&m,&q),srand((unsigned)time(0));
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=3;j++) scanf("%d",&a[i][j]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=3;j++) scanf("%d",&b[i][j]);
	}
	for(int i=1;i<=n;i++) w[i]=rando();
	for(int l=1,r=0;l<=n;l++)
	{
		while(r<=n&&!res) calc(++r,1);
		mx[l]=r-1,calc(l,-1);
	}
	for(int i=1,l,r;i<=q;i++) scanf("%d%d",&l,&r),puts(mx[l]>=r?"Yes":"No");
	return 0;
}
```

---

## 作者：Undead2008 (赞：6)

场上写了个大常数险些没过去的小丑做法，这里写一下主流做法。

下文中，我们记区间 $[l,r]$ 合法当且仅当集合序列 $[A_l,A_{l+1}\dots A_r]$ 与 $[B_l,B_{l+1}\dots B_r]$ 等价。

我们设 $f(x,i)=1/0$ 表示元素 $x$ 是否在 $A_i$ 中出现过，设 $g(x,i)=1/0$ 表示元素 $x$ 是否在 $B_i$ 中出现过。

一个区间 $[l,r]$ 合法的条件是存在排列 $p$ 使得对于每个 $i\in [1,m]$ 都有 $[f(i,l),f(i,l+1)\dots f(i,r)]=[g(p_i,l),g(p_i,l+1)\dots g(p_i,r)]$。其中的等号代表两个序列每一位都相等。

换句话说，对于每一个 $i\in [1,m]$，序列 $[f(i,l),f(i,l+1)\dots f(i,r)]$ 构成的可重集合和对于每一个 $i\in [1,m]$，序列 $[g(i,l),g(i,l+1)\dots g(i,r)]$ 构成的可重集合相等。

接着注意到如果区间 $[l,r]$ 合法，则区间 $[l+1,r]$ 和 $[l,r-1]$ 也合法；如果区间 $[l,r]$ 不合法，则区间 $[l,r+1]$ 和 $[l-1,r]$ 也不合法。

也就是说，对于每个左端点 $l$，存在一个 $r$ 使得对于所有的 $i\in [l,r-1]$，$[l,i]$ 合法，且对于所有 $i\in [r,n]$，$[l,i]$ 不合法。

考虑双指针维护每一个 $l$ 对应的 $r$。在双指针扫描的过程中使用动态开点线段树维护每个 $i\in [1,m]$，序列 $[f(i,l),f(i,l+1)\dots f(i,r)]$ 和序列 $[g(i,l),g(i,l+1)\dots g(i,r)]$ 的哈希值。将哈希值扔进 map 中判断区间是否合法即可。

区间合法的条件是对于每个哈希值 $X$，满足序列 $[f(i,l),f(i,l+1)\dots f(i,r)]$ 的哈希值为 $X$ 的 $i$ 的个数等于满足序列 $[g(i,l),g(i,l+1)\dots g(i,r)]$ 的哈希值为 $X$ 的 $i$ 的个数。

---

## 作者：MspAInt (赞：4)

[portal](https://www.luogu.com.cn/problem/P10785)

观察到颜色数很少的部分分，可以想见判定条件：对于 $A_{l\dots r}$ 中的每个颜色（元素值），其所有出现位置 所在集合位置 的集合，都恰有另外一个 $B_{l\dots r}$ 中的颜色的所在集合位置的集合与其等价。

这个信息量有点太庞大了，考虑到哈希可以胜任。

给每个基本集合 $i$ 赋随机权值 $w_i$，则对于颜色 $c$ 出现在 ${p_{c,1},p_{c,2},\dots,p_{c,k}}$ 基本集合，若 $A_{l\dots r}$ 中的 $ac$ 和 $B_{l\dots r}$ 中的 $bc$ 是对应的（$p_{ac}=p_{bc}$），则很大可能有 $(\sum_{i\in p_{ac}}w_i)^3-(\sum_{i\in p_{bc}}w_i)^3=0$，这里使用立方是为了防止出现 $[\{1,1,1\},\{1,1,1\}]=[\{2,2,2\},\{3,3,3\}]$，不然不是一一对应的。

为什么不用平方？因为过不去。事实上，使用平方即使是四哈希也过不了大样例。

显然我们已经可以在端点单位移动的时候维护答案（哈希值的立方和之差）了，由于在固定左端点、右端点右移时答案单调，使用双指针线性维护。

Code（目前可以通过 qoj 数据）：

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int N=6e5+10;
int n,m,q,a[N][3],b[N][3],ha[N],hb[N],w[N],ans[N],mod=998244353,now;

void plua(int i,int k){
	for(int j=0;j<3;j++){
		now=(now-1ll*ha[a[i][j]]*ha[a[i][j]]%mod*ha[a[i][j]]%mod+mod)%mod;
		ha[a[i][j]]=((ha[a[i][j]]+k*w[i])%mod+mod)%mod;
		now=(now+1ll*ha[a[i][j]]*ha[a[i][j]]%mod*ha[a[i][j]]%mod)%mod;
	}
}
void plub(int i,int k){
	for(int j=0;j<3;j++){
		now=(now+1ll*hb[b[i][j]]*hb[b[i][j]]%mod*hb[b[i][j]]%mod)%mod;
		hb[b[i][j]]=((hb[b[i][j]]+k*w[i])%mod+mod)%mod;
		now=(now-1ll*hb[b[i][j]]*hb[b[i][j]]%mod*hb[b[i][j]]%mod+mod)%mod;
	}
}
void add(int i,int k){
	plua(i,k),plub(i,k);
}

signed main(){
	scanf("%d%d%d",&n,&m,&q);
	mt19937 rnd(random_device{}());
	for(int i=1;i<=n;i++)scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
	for(int i=1;i<=n;i++)scanf("%d%d%d",&b[i][0],&b[i][1],&b[i][2]);
	for(int i=1;i<=n;i++)w[i]=(1ll*rnd()*rnd()%mod+rnd())%mod;
	for(int l=1,r=0;l<=n;l++){
		while(r<=n&&!now)add(++r,1);
		ans[l]=r-1;
		add(l,-1);
	}
	while(q--){int l,r;scanf("%d%d",&l,&r);puts(ans[l]>=r?"Yes":"No");}
	return 0;
}
```

---

## 作者：ECEG (赞：4)

## [NOI2024] 集合题解

设 $S_x$ 数字 $x$ 在三元组所出现的编号所构成的集合，设 $H$ 为所有 $S$ 集合构成的集合。

原条件等价于 $H_A=H_B$。感性理解：若相等了，则找到 $H$ 中相等的集合所对应的点，然后对应即可。

集合相等可以用 $\operatorname{hash}$ 来判断。乱搞就可以了。

详细点 $\operatorname{hash}(S_x)=\sum\limits_{v\in S_x} p^v$，$\operatorname{hash}(H)=\sum\operatorname{hash2}(\operatorname{hash}(S_x))$。

$\operatorname{hash2}$ 就是防止冲突。

你会 $O(1)$ 判断后就简单了，你维护一个双指针，记录最长的满足的区间。

类似一个莫队，当你加入或删除一个数 $x$ 时，把 $\operatorname{hash}(S_x)$ 重新算一下，对于 $\operatorname{hash}(H)$ 先把以前的 $\operatorname{hash}(S_x)$ 删去，再把新的加入进来。

时间复杂度 $O(n+q)$。

评价：转化不容易想到但正确性十分显然，$\operatorname{hash}$ 十分典，但没遇过就着了。双指针挺显然的。

为什么不是 $\operatorname{hash(H)}$ 不是乘积呢？因为用的自然溢出，除法不好搞。

```cpp
void change(int x,int loc,bool op,int val){
	unsigned long long &tmp=hash[op][x];
	if(tmp&&mp.find(tmp)!=mp.end())H[op]-=pw[mp[tmp]];
	unsigned long long shi=pw[loc]*val;
	tmp+=shi;
	if(tmp&&mp.find(tmp)==mp.end())mp[tmp]=++tot;
	if(tmp)H[op]+=pw[mp[tmp]];
}
void work(int i,int op){
	change(a[i].x,i,0,op),change(b[i].x,i,1,op),
	change(a[i].y,i,0,op),change(b[i].y,i,1,op),
	change(a[i].z,i,0,op),change(b[i].z,i,1,op);
}
signed main(){
	read(n,m,q);pw[0]=1;
	for(int i=1;i<=12*n;++i)pw[i]=pw[i-1]*P;
	for(int i=1;i<=n;++i)read(a[i].x,a[i].y,a[i].z);
	for(int i=1;i<=n;++i)read(b[i].x,b[i].y,b[i].z);
	for(int l=1,r=0;l<=n;){
		for(;r<l;)++r,work(r,1);
		for(;r<=n&&H[0]==H[1];)r++,work(r,1);
		work(r,-1);r--;ans[l]=r;work(l,-1);l++;
	}
	for(;q--;){
		int x,y;read(x,y);
		puts(ans[x]>=y?"Yes":"No");
	}
	return 0;
}
```

---

## 作者：D0000 (赞：3)

[NOI2024 D1 T1](https://www.luogu.com.cn/problem/P10785)

## 思路

先看询问 $10^6$，大概就是把表先打好然后 $O(1)$ 输出。

再来看题目，设 $C_{l,r},D_{l,r}$ 分别表示由 $A_l$ 到 $A_r$ 及 $B_l$ 到 $B_r$ 组成的集合序列。可以容易得出若两个集合序列等价，则删去它们第一个基本集合也等价，因此对于每个 $r$ 存在一个 $k$ 使得 $l<k$ 时 $C_{l,r}$ 与 $D_{l,r}$ 不等价，而 $l\ge k$ 时 $C_{l,r}$ 与 $D_{l,r}$ 等价。因此我们只需找出每个 $r$ 对应的 $k$ 即可。

题目中的集合序列置换可以理解为映射，即将 $A$ 中唯一元素对应到 $B$ 中唯一元素，而题目要求就是要让映射关系发生在基本集合内部，即 $A_i$ 中每一个元素的映射恰好在 $B_i$ 中。

考虑已经求出了前 $r-1$ 个基本集合对应的 $k$。要求第 $r$ 个的。那么首先 $A_r$ 是肯定等价于 $B_r$ 的，因为集合中元素互补重复，而要将 $A_r$ 每个元素对应到 $B_r$ 的每个元素，一共就有 $|A_r|!=6$ 种，即 $B_r$ 的每一个排列 $\{b'_1,b'_2,b'_3\}$ 并将 $A=\{a_1,a_2,a_3\}$ 中的每一个 $a_i$ 对应到 $b'_i$。

分别处理所有排列得到的答案。在聚焦到 $A$ 中第一个元素 $a_1$ ，它对应着 $b_1'$。也就是说，$A_k$ 到 $A_r$ 的每一个集合 $A_i$ 若包含 $a_1$ 则 $B_i$ 应包含 $b_i'$。

而要处理这个其实上就是要解决：判断上一次出现 $a_i$ 与 $b_i'$ 的地方是否是上一次出现 $a_i$ 的地方，若为真则答案（可以理解为临时的 $k$，之后可能有更优的）为出现 $a_i$ 的地方的答案，否则就是出现 $a_i$ 的地方的后边。所有 $i$ 算出来的值取最大值。证明见后面。另外，此处做法有不完整的地方，也请看后面。

对于其它位置同理，最后 $B_r$ 算出来的所有 $k$ 求最小值再对上一位的答案取最大值即可。

想想如何维护，我用 $last_j$ 存上一个 $a_i=j$ 的地方。又开了个动态开点线段树来维护 $a_i\times m+b_i'$，就代表了 $a_i$ 和 $b_i'$，里面存放了上一次的答案和出现的位置，若上一次出现的位置不等于 $last_{a_i}$ 了，就要将答案变为 $last_{a_i+1}$。感觉用线段树没啥用，有点浪费空间，但我还是用了。

现在来证明刚才没证明的做法的正确性，顺便说一说几个容易写错的地方。

因为我们的做法使得区间中每一个基本集合要么不出现 $a_i$ 要么 $a_i$ 和 $b_i'$ 都出现，对于前者，随便映射（按照上一位的答案）；对于后者，我们担心是否 $a_i$ 可以映射到别的地方，答案是有可能的，有可能前面的答案 $b_i'$ 被别的元素对应上了。所以在前面还得记个 $last2_j$  表示上一个 $B$ 中出现的 $b_j$ 在何处，对答案更新和 $last_j$ 一致。这样假设上一位的答案中若有 $a_i$ 对应了 $c$，又有 $d$ 对应了 $b_i'$，根据我们维护的性质包含 $a_i,b_i',c,d$ 中任意一个则必然包含其他三个，不会对答案有影响。

时间复杂度 $O(n\log n)$，但常数有一点点大。

---

## 作者：SafariMo (赞：3)

记 $s_l$ 表示最长的 $r$，使得询问 $[l,r]$ 回答是 `Yes`。

任务转为求出 $s_i$。

显然，对于 $l<n$，$s_l\le s_{l+1}$。

使用双指针算法。

进一步的，我们把同样的 $a_{i,j,0/1/2}$ （$j$ 为下标） 放到一起，维护 $c_{i,j}$ 表示现在的限制（$i$ 表示两个序列中的哪一个，$j$ 表示元素大小，**限制指 $a_{i,k,0/1/2}=j$ 的 $i$ 组成的集合**），暴力开 set 用  map 维护显然是不可取的，采用 Xor Hash 即可，当限制相同（$c_{0,i}=c_{1,j}$ 可以全部匹配）时才可以保证合法。

令 $cnt$ 表示不匹配的 $x$ 的个数。

先构造随机序列 $s_{1\sim n}$，每次消除原先的贡献，异或上 $s_x$，并加入新的贡献，注意：两个序列的贡献是**恰好相反的**（用 $\pm1$ 来表示），对于一个限制，如果贡献此时不为 $0$，则对 $cnt$ 产生 $1$ 的贡献。

开 umap 可以做到 $\mathcal O(n+q)$。

---

## 作者：Genius_Star (赞：2)

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18385044)

### 思路：

容易发现，区间 $[l,r]$ 中 $A$ 与 $B$ 等价的充分必要条为：

- 两个序列中所有元素对于在区间 $[l,r]$ 内的出现集合组成的集合相等。

- 这样才可以使得存在一种对应的映射方案使得等价。

考虑哈希判定。

设 $S_i$ 表示 $i$ 出现的位置的集合，则设 $\operatorname{Hash}(S_x) = \sum\limits_{i \in S_x} base^i$，$\operatorname{Hash}(A/B) = \sum\limits_{i=1}^m \operatorname{Hash}(S_i)$。

固定左端点 $l$ 时，容易发现 $r$ 具有单调性，考虑求出 $len_l$ 表示以 $l$ 为左端点的最长等价区间，使用双指针算法；

设当前加入的数为 $a_i$，则重新计算下 $\operatorname{Hash}(S_{a_i})$ 即可，删除同理。

因为当前是单哈希，且基本都是加法哈希，可以双哈希 $\operatorname{Hash}(S_i)$ 稳固一下。

时间复杂度为 $O(N+Q)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=2e5+10,M=6e5+10;
const ull base=127;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
mt19937_64 R(time(0));
ull h1,h2;
int n,m,q,p,l,r;
int len[N],a[N][3],b[N][3];
ull f[N],s1[M],s2[M];
inline ull Hash(ull x){
	return x*f[x%(N-1)+1];	
}
inline void insert1(int x,int id){
	h1-=Hash(s1[x]);
	s1[x]+=f[id];
	h1+=Hash(s1[x]);
}
inline void insert2(int x,int id){
	h2-=Hash(s2[x]);
	s2[x]+=f[id];
	h2+=Hash(s2[x]);
}
inline void del1(int x,int id){
	h1-=Hash(s1[x]);
	s1[x]-=f[id];
	h1+=Hash(s1[x]);
}
inline void del2(int x,int id){
	h2-=Hash(s2[x]);
	s2[x]-=f[id];
	h2+=Hash(s2[x]);
}
inline void insert(int x){
	For(i,0,2){
		insert1(a[x][i],x);
		insert2(b[x][i],x);
	}
}
inline void del(int x){
	For(i,0,2){
		del1(a[x][i],x);
		del2(b[x][i],x);
	}
}
bool End;
int main(){
	//open("A.in","A.out");
	n=read(),m=read(),q=read();
	f[0]=1;	
	For(i,1,N-1)
	  f[i]=f[i-1]*base;
	For(i,1,n)
	  For(j,0,2)
	    a[i][j]=read();
	For(i,1,n)
	  For(j,0,2)
	    b[i][j]=read();
	for(int l=1,r=0;l<=n;){
		while(r<l){
			++r;
			insert(r);
		}
		while(r<=n&&h1==h2){
			r++;
			insert(r);
		}
		del(r--);
		len[l]=r;
		del(l++);
	}
	while(q--){
		l=read(),r=read();
		if(r>len[l])
		  puts("No");
		else
		  puts("Yes");
	}
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}
```

---

## 作者：Galois_Field_1048576 (赞：2)

> 设基本集合为 $\{0, \dots, m-1\}$ 的三元子集。
> 设 $\alpha, \beta$ 是由基本集合构成的序列，若存在 $\pi \in S_m$ 使得 $\alpha_i = \pi(\beta_i)$，则记 $\alpha \sim \beta$。（$\pi(\beta_i) = \{\pi(s) : s \in \beta_i\}$）
> 现在给定序列 $\alpha, \beta$，求是否有 $(\alpha_l, \alpha_{l+1}, \dots, \alpha_{r-1}) \sim (\beta_l, \beta_{l+1}, \dots, \beta_{r-1})$。

$n \le 2 \times 10^5$, $m \le 6 \times 10^5$, $q \le 10^6$。

令 $S_x = \{i \mid x \in \alpha_i\}$，$T_x = \{i \mid x \in \beta_i\}$，而 $S^I_x, T^I_x$ 是 $\alpha_I, \beta_I$ 的类似集合。

**重要性质.** $\alpha \sim \beta \iff \bigsqcup_x \{S_x\} = \bigsqcup_x \{T_x\}$。

（证明：取得 $\alpha_i = \pi(\beta_i)$，则 $S_x = T_{\pi(x)}$，由 $\pi$ 是排列立得；反过来，对于 $S_x = T_y$，令在 $\pi$ 中 $y \mapsto x$，得到一个排列 $\pi$，可以验证它满足条件。）

设 $\Theta[l, r)$ 为 $[l, r)$ 是否满足条件。显然有 $S \subseteq T \wedge \Theta T \implies \Theta S$（决策单调性）。

因此考虑双指针。注意到若已知 $\Theta[l, r)$，即我们已知
$$
\bigsqcup_x \{S^{[l, r)}_x\} = \bigsqcup_x \{T^{[l, r)}_x\},
$$
则
$$
\Theta[l, r] \iff \bigsqcup_{x} \{S^{[l, r]}_x\} = \bigsqcup_{x} \{T^{[l, r]}_x\}
$$
注意到 $S^{[l, r]}_x$ 和 $S^{[l, r)}_x$ 的唯一区别就是 $x \in \alpha_r$ 处，所以只需在多重集中删除/加入一个集合，判断是否相等。

利用哈希：设 $H(S)$ 是 $S$ 的哈希值，对于多重集 $M$，考虑 $M$ 的哈希值为
$$
\sum_{S \in M} H(S).
$$
则增删一个集合的操作是显然的。

实现可知时间复杂度 $\mathrm{O}(n + m + q)$，依赖随机性。

*据传言，exSAM 可以得到确定性做法。*

---

## 作者：qiaozh (赞：1)

定义两个集合序列 $S_a$ 和 $S_b$ ，长度为 $m$ （和值域一一对应），初始元素都为空集。

对于所有 $i\in[l，r]$ ， $j\in\{0,1,2\}$ ， $S_a[a_{i,j}]$ 和 $S_b[b_{i,j}]$ 都加入 $i$ 。

如果能把 $S_a$ 中的集合重新进行排列得到 $S_b$ ，那么可知 $a$ 和 $b$ 在 $[l,r]$ 是等价的。这个 $1$ 到 $m$ 的排列就是所求的 $p$ 。

还是考虑双指针 $l$ 和 $r$ ，需要一种有点像字典树的森林通过维护 $S_a$ 或 $S_b$ 中不同集合的相同前缀，支持判断 $S_a$ 重新排列能否得到 $S_b$ ， $l$ 和 $r$ 的后移。

从一棵树的根节点到节点 $node$ 的路径表示 $S_a$ 或 $S_b$ 中的一种集合。每一节点有两个权值， $ord$ 是集合里的元素，路径上所有节点的 $ord$ 组成的集合就是 $S_a$ 或 $S_b$ 中的一种集合。 $num$ 代表这种集合在 $S_a$ 或 $S_b$ 中有几个。两片森林同构且对应权值相等当且仅当 $S_a$ 重排后就是 $S_b$ 。因为双指针区间 $[l,r]$ 都满足这个条件，所以只用建一片森林，每次指针改变就检查对森林影响是否相同。

每次 $r$ 后移时找到 $a_{r,0,1,2}$ 对应的节点（必须和 $b_{r,0,1,2}$ 对应相同节点，否则 $l$ 后移），在其下方增加一个节点，权值相应变化。 $l$ 后移就涉及到把 $ord$ 最小的根结点删除，再合并子树到 $ord$ 相同的根结点的那棵树上去。因为只有 $ord$ 相同的节点间才能合并，所以被合并加上被删的节点最多 $3n$ 个，所有 $l$ 的后移均摊 $O(n)$ ，加上每次 $r$ 后移是 $O(1)$ ，总共复杂度 $O(n+q)$ 。

代码很丑，因为是cqyc退役oier几年后目击noi有感而发写的

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,q,ind=0;
int a[300010][3],b[300010][3],pa[600010],pb[600010],s[300010];
vector<int> G[900010];
int fa[900010],ord[900010],num[900010],to[900010];
int root[600010];
void he(int node1,int node2) {
    num[node2]+=num[node1];
    to[node1]=node2;
    for(int i=0;i<G[node1].size();i++) {
        bool boo=0;
        for(int j=0;j<G[node2].size();j++) {
            if(ord[G[node1][i]]==ord[G[node2][j]]) {
                boo=1;he(G[node1][i],G[node2][j]);break;
            }
        }
        if(!boo) {
            G[node2].push_back(G[node1][i]);
            fa[G[node1][i]]=node2;
        }
    }
}
int cmpa[3],cmpb[3];
void sortt(int i,bool boo) {
    if(boo) {
        if(cmpa[0]>cmpa[1]) swap(cmpa[0],cmpa[1]),swap(a[i][0],a[i][1]);
        if(cmpa[1]>cmpa[2]) swap(cmpa[1],cmpa[2]),swap(a[i][1],a[i][2]);
        if(cmpa[0]>cmpa[1]) swap(cmpa[0],cmpa[1]),swap(a[i][0],a[i][1]);
    } else {
        if(cmpb[0]>cmpb[1]) swap(cmpb[0],cmpb[1]),swap(b[i][0],b[i][1]);
        if(cmpb[1]>cmpb[2]) swap(cmpb[1],cmpb[2]),swap(b[i][1],b[i][2]);
        if(cmpb[0]>cmpb[1]) swap(cmpb[0],cmpb[1]),swap(b[i][0],b[i][1]);
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++) scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
    for(int i=1;i<=n;i++) scanf("%d%d%d",&b[i][0],&b[i][1],&b[i][2]);
    for(int i=0;i<=3*n+2;i++) to[i]=-1;
    int l=1,r=0;
    while(l<=n) {
       if(r==n) {
           s[l]=r;break;
       }
       r++;
       bool boo=0;
       for(int i=0;i<3;i++) {
           while(to[pa[a[r][i]]]!=-1) pa[a[r][i]]=to[pa[a[r][i]]];
           while(to[pb[b[r][i]]]!=-1) pb[b[r][i]]=to[pb[b[r][i]]];
           cmpa[i]=pa[a[r][i]],cmpb[i]=pb[b[r][i]];
       }
        sortt(r,1);sortt(r,0);
       for(int i=0;i<3;i++) if(cmpa[i]!=cmpb[i]) boo=1;
       if(!boo) {
           s[l]=r;
           for(int i=0;i<3;i++) {
               if(i>0) {if(cmpa[i]==cmpa[i-1]) {
                   pa[a[r][i]]=ind;pb[b[r][i]]=ind;
                   num[cmpa[i]]--;num[ind]++;continue;
               }}
               G[cmpa[i]].push_back(++ind);
               if(cmpa[i]==0) root[r]=ind;
               fa[ind]=cmpa[i];pa[a[r][i]]=ind;pb[b[r][i]]=ind;
               num[cmpa[i]]--;num[ind]=1;ord[ind]=r;
           }
        } else {
           r--;
           to[root[l]]=0;
           for(int i=0;i<G[root[l]].size();i++) {
               int yu=G[root[l]][i];
               if(root[ord[ yu ]]==0) {
                   root[ord[yu]]=yu;continue;
               } else {
                   he(yu,root[ord[yu]]);
               }
           }
           l++;s[l]=r;
       }
   }
   while(l<=n) {s[l]=r;l++;}
   for(int i=1;i<=q;i++) {
        scanf("%d%d",&l,&r);
        if(s[l]>=r) cout << "Yes" << endl;
        else cout << "No" << endl;
   }
   return 0;
}
```

---

## 作者：Iratis (赞：1)

你说的对，但是只过了 d1t1 有点搞笑了。

先考虑如何判定两个序列是否等价。

记 $ T_A(x) $ 为 $ x $ 在 $ A $ 中出现位置构成的集合，$ T_B(x) $ 同理，发现序列等价即为 $ T_A(x)=T_B(p[x]) $。

不妨考虑累加一个计数器，对于每个 $ x $，都对 $ cnt[T_A(x)] $ 做 $ 1 $ 的贡献，对 $ cnt[T_B(x)] $ 做 $ -1 $ 的贡献，则序列等价即为所有 $ cnt[S] $ 都为 $ 0 $，那么使用 hash+哈希表 即可做到 $ O(n) $。

再推一下，发现大区间如果满足，小区间必定满足，故考虑记录 $ f_l $ 表示最大的 $ r $ 使得 $ [l,r] $ 满足条件，询问时直接判定 $ f_l $ 是否 $ \geq r $。

因为区间存在包含性，考虑双指针，综上，时间复杂度 $ O(n) $。

---

## 作者：strcmp (赞：1)

左右两边的人都有牌子了，而我因为 `strcmp` 成为了场外选手，哈哈哈。

------------

非常显然的，如果两个区间满足包含关系，那么大区间满足条件则小区间满足，否则小区间不满足则大区间不满足。

接下来考虑集合序列等价的充要条件，排列置换之后是一个双射，所以考虑从 $[l,\,r]$ 的 $a$ 集合序列中任意拿出一个元素 $x$，比如 $x$ 在 $a_{c_i},\,1 \le i \le k$ 中出现。则必须存在另外一个元素 $y$ 在 $b_{c_i}$ 中都出现。

我们由此得到一个必要条件，对于 $a$ 中任意一个元素 $x$，$x$ 在 $a_{c_i},\,1 \le i \le k$ 中出现。则有对应的 $y$ 在且仅在 $b_{c_i}$ 中出现。

这个条件是否充分呢？充分的，因为如果满足条件我们可以直接构造出排列。

接下来考虑如何维护，首先根据区间包含的单调性我们显然使用双指针维护，即对于每个 $l$ 求取 $R_l$ 代表 $l$ 为左端点的，最大能满足条件的区间右端点，显然 $R$ 单调不减。

然后一个想法是双指针维护 $[l,\,r]$ 区间内每个元素 $x$ 所在的 $a$ 集合，显然直接存不方便直接 hash 成一个数。具体就是开个 $h1_x$ 代表 $x$ 所在的 $a$ 集合 出现位置序列 按最小表示法排序后的 hash 值，$h2_y$ 类似但是是在 $b$ 集合的出现位置序列。

那么如果 $h1$ 和 $h2$ 能匹配则满足条件。注意到我们也不好比较 $h1$ 和 $h2$，那么直接考虑它们异或起来，如果相等则很大概率 $h1$ 和 $h2$ 是匹配的。

为了防止被卡，可以考虑对每个集合随机一个权值出来，比如 $a_7 = \{1,\,4,\,5\}$，随机一个权值 $w_7 = 114514$，我们采用一个简单的和哈希。则我们相当于 $h1_1 \leftarrow h1_1 + 114514$ 而不是 $h1_1 \leftarrow h1_1 + 7$，$h1_4$ 和 $h1_5$ 同理。这样极大减少了哈希冲突的可能。（实际也是一个很经典的 trick，比如 CSP-S2022 T3）

考虑到我们做一次哈希的时间复杂度是 $\Theta(n)$ 的，常数不大可以考虑多做几次增加正确性。

由于现在还没有民间或官方数据，而且我是场外选手，故先将代码云剪切板上，如果正确性出问题会更改。

[参考代码](https://www.luogu.com.cn/paste/air57bq6)

---

## 作者：zxh923 (赞：0)

给个链接：[集合](https://www.luogu.com.cn/problem/P10785)。

很神秘的题目。基本上看到之后就可以想到哈希。

首先想到一个比较神秘的暴力。就是对于每个询问，扫一遍所有 $a$ 中的数出现的位置，把它弄成一个哈希值（具体怎么弄随意）存到一个集合里，然后看看是不是和 $b$ 中的数出现的位置这样操作后的集合完全相等。事实上就是判断是否对于所有在 $a$ 中这个区间内出现的数 $x$，都存在一个在 $b$ 中出现的**不同的数** $y$，使得 $x,y$ 出现的位置完全相同。这样做应该是有 $70$ 分的，但是显然不够。

然后我们考虑一个事情，$\forall i,[i,j]$ 这个区间合法在 $j$ 尽可能小的时候最有可能成立。换句话说有单调性，可以二分。

但是，二分是没有必要的，我们可以用双指针做的更好。因为，如果 $[i,j]$ 合法且 $[i+1,j]$ 存在，那么 $[i+1,j]$ 合法。

所以我们对每个 $i$ 找出最靠右的 $j$ 且满足 $[i,j]$ 合法，然后就可以 $O(1)$ 回答询问。时间复杂度 $O(n+q)$。

这里为了保险，把每个位置的值也做了哈希，用 $p_i$ 存储。

给个代码：

```
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define N 600005
using namespace std;
int n,m,q,a[N][3],b[N][3];
ull nowa[N],nowb[N],suma,sumb,p[N];
int ri[N];//使[i,j]合法的最靠右的j
ull get_rnd(ull x){
	return x*x*x;//随便变换一下
}
void work(int id,int type){
	for(int j=0;j<3;j++){
		ull i=a[id][j];
		suma-=get_rnd(nowa[i]);//把原来的值减掉
		nowa[i]+=type*p[id];//看情况加上或减去这个位置的哈希值
		suma+=get_rnd(nowa[i]);//加上现在的值
	}
	for(int j=0;j<3;j++){//这里同理
		ull i=b[id][j];
		sumb-=get_rnd(nowb[i]);
		nowb[i]+=type*p[id];
		sumb+=get_rnd(nowb[i]);
	}
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
	srand(time(0));
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++){
		for(int j=0;j<3;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<3;j++){
			cin>>b[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		ri[i]=n;
	}
	for(int i=1;i<=n;i++){
		p[i]=rand()*rand()+923;
	}
	work(1,1);
	for(int i=1,j=1;i<=n;i++){
		while(j<=n&&suma==sumb){//如果当前仍然合法
			j++;
			if(j>n)break;
			work(j,1);
		}
		ri[i]=min(ri[i],j-1);
		work(i,-1);//i要右移，所以撤掉这一位的贡献
	}
	while(q--){
		int l,r;
		cin>>l>>r;
		cout<<(ri[l]>=r?"Yes\n":"No\n");
	}
	return 0;
}
```

---

## 作者：Redshift_Shine (赞：0)

## 题面

[here](https://www.luogu.com.cn/problem/P10785)

[民间数据](https://qoj.ac/problem/9155)

## 思路

首先，考虑一个满足要求的区间有什么性质。

等价的定义非常复杂，这里翻译一下。

一个区间是符合要求的，当且仅当我们可以将区间内 $a$ 集合中的每个数替换成一个 $[1,m]$ 区间内的整数，且满足操作前相等的数在操作后仍然相等，操作前不相等的数在操作后仍然不相等，使得最后的集合与 $b$ 在区间内的集合完全相同。

换句话说，如果存在一个集合 $S$ 和一个整数 $x$，使得 $S$ 中的任意一个元素 $i$ 满足 $x$ 在集合 $a_i$ 中出现过，且 $S$ 为 $x$ 在 $a$ 中出现的所有位置，那么必然存在另一个整数 $y$，使得 $S$ 中的任意一个元素 $i$ 满足 $y$ 在集合 $b_i$ 中出现过，且 $S$ 为 $y$ 在 $b$ 中出现的所有位置。$x$ 可以等于 $y$。

也就是说，如果对于出现在区间内 $a$ 集合中的任意一个整数 $x$ 都有一个整数 $y$ 使得它们在 $a$ 和 $b$ 中出现的集合位置一样，那么区间满足条件。

## 解法

考虑哈希+双指针。

为 $1$ 到 $n$ 的每个整数 $i$ 赋一个随机值 $h_i$。

定义一个整数 $x$ 出现在一个集合组 $a$ 中的所有位置 $i$ 的 $h_i$ 之和为 $x$ 对于集合组 $a$ 的**位值** $v_{a,x}$。

如果用数学语言来写的话，

$$
v_{a,x}=\sum_{i=1}^n h_i[x\in a_i]
$$

同时，定义一个集合组 $a$ 的**位值集合** $s_a$ 为所有 $[1,m]$ 范围内整数 $i$ 的 $v_{a,i}$ 组成的可重集。

如果用数学语言来写的话，

$$
s_a=\set{v_{a,i}|1\le i\le m}
$$

不难发现，按照上述方式计算区间内的 $s_a$ 和 $s_b$ 后，若 $s_a=s_b$，则区间内 $a$ 中出现的每个数都可以在 $b$ 中找到满足条件的映射，则区间满足条件，否则不满足。

同时，注意到区间越大 $s_a=s_b$ 的概率越小，即 $s_a=s_b$ 具有单调性，考虑通过双指针贪心地对于每一个区间右端点 $r$ 找到最小的 $l$ 使得 $[l,r]$ 满足题目条件，设定此时的 $l$ 为 $q_r$。若在后续询问中，对于区间 $[l,r]$ 满足 $l\ge q_r$，则该区间一定满足 $s_a=s_b$。

故题目解决。

视使用 `map` 或 `unordered_map` 作为哈希值储存容器时间复杂度分别为 $O(n\log n)$ 和 $O(n)$。

## 代码

```c++
#include <iostream>
#include <map>
#include <random>
using namespace std;
const int N = 2e5 + 10, M = 6e5 + 10;
int n, m, q, x, y, a[N][3], b[N][3], cur, req[N];
using ull = unsigned long long;
map<ull, int> mp;
random_device rd;
mt19937 mt(rd());
ull sg[N], pa[M], pb[M];
void upd(ull x, int v)
{
   cur += !mp[x];
   mp[x] += v;
   cur -= !mp[x];
}
void acs(int x, int v)
{
   for (int i = 0; i < 3; i++)
   {
      upd(pa[a[x][i]], -1);
      pa[a[x][i]] += v * sg[x];
      upd(pa[a[x][i]], 1);

      upd(pb[b[x][i]], 1);
      pb[b[x][i]] += v * sg[x];
      upd(pb[b[x][i]], -1);
   }
}
int main()
{
   scanf("%d%d%d", &n, &m, &q);
   for (int i = 1; i <= n; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         scanf("%d", a[i] + j);
      }
   }
   for (int i = 1; i <= n; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         scanf("%d", b[i] + j);
      }
   }
   for (int i = 1; i <= n; i++)
   {
      sg[i] = mt();
   }
   for (int i = 1, j = 1; i <= n; i++)
   {
      acs(i, 1);
      while (cur)
         acs(j, -1), j++;
      req[i] = j;
   }
   for (int i = 1; i <= q; i++)
   {
      scanf("%d%d", &x, &y);
      puts(req[y] <= x ? "Yes" : "No");
   }
}
```

---

## 作者：Usada_Pekora (赞：0)

当值 $i$ 在 $A_{[l,r]}$ 中出现的下标集合与值 $j$ 在 $B_{[l,r]}$ 中出现的下标集合相同时，置换 $f_i=j$ 便是合法的。那么，当所有在 $A_{[l,r]}$ 中出现的值 $i$ 都可以在 $B_{[l,r]}$ 中不重复地找到这样一个 $j$，答案就是 `Yes`。

想办法维护下标集合的出现次数，对下标集合 hash 一下就好做了，给每个位置赋一个 $2^{64}$ 范围的随机值，规定下标集合的 hash 值是里面所有位置的赋值的 `xor`，冲突的概率是 $2^{-64}$，可以假设两个不同集合的 hash 值不同。

到这里可以莫队，用 `unordered_map` 维护，$A$ 里面的下标集合的权是 1，$B$ 里面的是 -1，那么所有 hash 值的权和都是 0 就是 `Yes`。

但 $O(n\sqrt q)$ 跑过去很难，显然，对于所有 $l$，答案是 `Yes` 存在分界点 $p_l$，且 $p_l$ 是随着 $l$ 单调不减的，双指针就好了。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
#define mkp make_pair
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
template<typename T> inline bool chkmin(T &x, const T &y) {
	return (y < x) && (x = y, true);
}
template<typename T> inline bool chkmax(T &x, const T &y) {
	return (x < y) && (x = y, true);
}
constexpr int N = 1e6 + 5;
int n, m, q, a[N][3], b[N][3], p[N], tot;
ull A[N], B[N], rd[N];
mt19937 rng(1u * time(NULL));
inline void ins(ull x, int opt) {
	static unordered_map<ull, int> cnt;
	if (cnt[x] != 0)
		tot--;
	if ((cnt[x] += opt) != 0)
		tot++;
}
inline void work(int i) {
	for (int j = 0; j < 3; j++) {
		ins(A[a[i][j]], -1), A[a[i][j]] ^= rd[i], ins(A[a[i][j]], 1);
		ins(B[b[i][j]], 1), B[b[i][j]] ^= rd[i], ins(B[b[i][j]], -1);
	}
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> m >> q;
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < 3; j++)
			cin >> a[i][j];
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < 3; j++)
			cin >> b[i][j];
	for (int i = 1; i <= n; i++)
		rd[i] = rng();
	for (int l = 1, r = 0; l <= n; l++) {
		while (r <= n && tot == 0)
			work(++r);
		p[l] = r;
		work(l);
	}
	while (q--) {
		int l, r;
		cin >> l >> r;
		cout << ((p[l] > r) ? "Yes\n" : "No\n");
	}
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

考虑假若基本集合中只有 $1$ 个元素，显然只需要判断每个元素 $u$ 的出现位置集合 $S_u$ 在两个序列上组成的集合（这个集合的元素也是集合）是否相同即可。

我们发现，假若基本集合中有 $3$ 个元素，那么实际上情况是**一模一样**的，我们只需要将一个位置同时插入三个元素的出现位置集合并将集合看作可重集即可，然后我们发现，假若对于区间 $[l,r]$ 存在一个合法置换，其所有子区间必定也存在一个合法置换，这表明固定区间左端点后，右端点在是否存在合法置换这件事上存在单调性，于是我们考虑哈希套哈希，先对每个元素出现位置集合做哈希，得到的所有哈希值再去哈希，并用双指针扫一遍维护每个左端点最靠右的合法右端点即可，时间复杂度 $O(n+m+q)$。

注意不要被卡哈希了。

[这里是代码。](https://www.luogu.com.cn/record/174074309)

---


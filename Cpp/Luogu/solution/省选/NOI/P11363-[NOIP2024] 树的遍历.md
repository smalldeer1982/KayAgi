# [NOIP2024] 树的遍历

## 题目描述

小 Q 是一个算法竞赛初学者，正在学习图论知识中的树的遍历。一棵由 $n$ 个结点，$n - 1$ 条边构成的树，初始时所有结点都未被标记，它的遍历过程如下：

1. 选择一个结点 $s$ 作为遍历起始结点，并把该结点打上标记。
2. 假设当前访问的结点为 $u$，寻找任意一个与 $u$ 相邻且未标记的结点 $v$，将 $v$ 作为新的当前访问结点并打上标记。之后再次进入第 $2$ 步。
3. 假设在第 $2$ 步中，与 $u$ 相邻的结点都已被标记，如果 $u = s$ 则遍历过程结束，否则将 $u$ 设为遍历 $u$ 之前的上一个结点并再进入第 $2$ 步。

例如在下面的树中，一种可能的遍历过程如下：
- 选取 $1$ 作为遍历起始结点，并把 $1$ 打上标记；
- $2$ 与 $1$ 相邻且未标记，将 $2$ 设为当前访问结点，并把 $2$ 打上标记。
- $2$ 与 $3$ 相邻且未标记，将 $3$ 设为当前访问结点，并把 $3$ 打上标记。
- $3$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $3$ 之前的结点 $2$。
- $2$ 与 $4$ 相邻且未标记，将 $4$ 设为当前访问结点，并把 $4$ 打上标记。
- $4$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $4$ 之前的结点 $2$。
- $2$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $2$ 之前的结点 $1$。
- $1$ 所有相邻的结点都被标记，且 $1$ 是遍历起始结点，故遍历结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/qsjiky0g.png)

作为一个奇思妙想的学生，小 Q 在学习完上述知识后不满足于以结点为基础的遍历方式，于是开始研究以边为基础的遍历方式。定义两条边**相邻**，当且仅当它们有一个公共的结点。初始时，所有的边都未被标记。这种以边为基础的遍历过程如下：

1. 选择一条边 $b$ 作为遍历起始边，并把该边打上标记。
2. 假设当前访问边为 $e$，寻找任意一条与 $e$ 相邻且未标记的边 $f$，将 $f$ 作为新的当前访问边并打上标记。之后再次进入第 $2$ 步。
3. 假设在第 $2$ 步中，与 $e$ 相邻的边都已被标记，如果 $e = b$ 则遍历过程结束，否则将 $e$ 设为遍历 $e$ 之前的上一条边并再进入第 $2$ 步。

例如在上面的树中，一种可能的遍历过程如下（定义 $\{u, v\}$ 表示连接结点 $u$ 和 $v$ 的边）：

- 选取 $\{1, 2\}$ 作为遍历起始边，并把 $\{1, 2\}$ 打上标记；
- $\{1, 2\}$ 与 $\{2, 3\}$ 相邻且未标记，将 $\{2, 3\}$ 设为当前访问边，并把 $\{2, 3\}$ 打上标记。
- $\{2, 3\}$ 与 $\{2, 4\}$ 相邻且未标记，将 $\{2, 4\}$ 设为当前访问边，并把 $\{2, 4\}$ 打上标记。
- $\{2, 4\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\{2, 4\}$ 之前的边 $\{2, 3\}$。
- $\{2, 3\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\{2, 3\}$ 之前的边 $\{1, 2\}$。
- $\{1, 2\}$ 所有相邻的边都被标记，且 $\{1, 2\}$ 是遍历起始边，故遍历结束。

小 Q 惊奇的发现，在这个新的树的遍历过程中，如果将每条边看作一个新的结点，将步骤 $2$ 中的所有新结点 $e$ 和 $f$ 连接一条新边，就会生成一棵由 $n-1$ 个新结点和 $n-2$ 条新边连接成的新树。例如上述遍历过程得到的新树如下（新的结点和新边都用红色表示）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mld0xpqg.png)

现在小 Q 在 $n - 1$ 条边中选择了 $k$ 条关键边。小 Q 想知道，以任意一条关键边作为起始遍历边，通过上述遍历过程能够生成多少种不同的新树。这里两棵树被认为是不同的，当且仅当至少存在某一对新的结点，它们仅在其中一棵树中连有新边。

**由于结果可能很大，你只需要输出其对 $10^9+7$ 取模的结果即可。**

## 说明/提示

**【样例 1 解释】**

两种可能的新树如下：
- 新结点 $\{1, 2\}$ 和新结点 $\{2, 3\}$ 连新边，新结点 $\{2, 3\}$ 和新结点 $\{2, 4\}$ 连新边。
- 新结点 $\{1, 2\}$ 和新结点 $\{2, 4\}$ 连新边，新结点 $\{2, 4\}$ 和新结点 $\{2, 3\}$ 连新边。

**【样例 2 解释】**

三种可能的新树如下：
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 4\}$，$\{2, 4\}$ 和 $\{2, 5\}$ 之间分别连新边。该新树可以选择 $\{1, 2\}$ 作为起始遍历边得到。
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 5\}$，$\{2, 5\}$ 和 $\{2, 4\}$ 之间分别连新边。该新树可以选择 $\{1, 2\}$ 或 $\{2, 4\}$ 作为起始遍历边得到。
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 4\}$，$\{1, 2\}$ 和 $\{2, 5\}$ 之间分别连新边。该新树可以选择 $\{2, 4\}$ 作为起始遍历边得到。

**【样例 3】**

见附件的 traverse/traverse3.in 与 traverse/traverse3.ans。

该组样例满足 $c = 4$。

**【样例 4】**

见附件的 traverse/traverse4.in 与 traverse/traverse4.ans。

该组样例满足 $c = 7$。

**【样例 5】**

见附件的 traverse/traverse5.in 与 traverse/traverse5.ans。

该组样例满足 $c = 11$。

**【样例 6】**

见附件的 traverse/traverse6.in 与 traverse/traverse6.ans。

该组样例满足 $c = 13$。

**【样例 7】**

见附件的 traverse/traverse7.in 与 traverse/traverse7.ans。

该组样例满足 $c = 15$。

**【样例 8】**

见附件的 traverse/traverse8.in 与 traverse/traverse8.ans。

该组样例满足 $c = 16$。

**【样例 9】**

见附件的 traverse/traverse9.in 与 traverse/traverse9.ans。

该组样例满足 $c = 18$。

**【样例 10】**

见附件的 traverse/traverse10.in 与 traverse/traverse10.ans。

该组样例满足 $c = 19$。

**【样例 11】**

见附件的 traverse/traverse11.in 与 traverse/traverse11.ans。

该组样例满足 $c = 22$。

**【样例 12】**

见附件的 traverse/traverse12.in 与 traverse/traverse12.ans。

该组样例满足 $c = 24$。

**【数据范围】**

对于所有的测试数据，保证：
- $1 \leq T \leq 10$；
- $2 \leq n \leq 10^5$；
- $1 \leq k < n$；
- 对于任意的 $i(1 \leq i \leq n - 1)$，都有 $1 \leq u_i, v_i \leq n$，且构成一颗合法的树。
- 对于任意的 $i(1 \leq i \leq k)$，都有 $1 \leq e_i < n$，且两两不同。

::cute-table{tuack}

| 测试点编号 | $n$ | $k$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $\leq 5$ | $\leq 1$ | 无 |
| $4\sim 6$ | $\leq 10^5$ | ^ | ^ |
| $7\sim 10$ | ^ | $\leq 2$ | ^ |
| $11,12$ | $\leq 500$ | $\leq 8$ | ^ |
| $13,14$ | $\leq 10^2$ | $<n$ | ^ |
| $15$ | $\leq 500$ | ^ | ^ |
| $16,17$ | $\leq 10^5$ | $\leq 500$ | ^ |
| $18$ | ^ | $<n$ | A |
| $19\sim 21$ | ^ | ^ | B |
| $22,23$ | $\leq 2\times 10^4$ | ^ | 无 |
| $24,25$ | $\leq 10^5$ | ^ | ^ |

- 特殊性质 A：对于任意的 $i(1 \leq i \leq n - 1)$，都有 $u_i = i, v_i = i + 1$。
- 特殊性质 B：对于任意的 $i(1 \leq i \leq n - 1)$，都有 $u_i = 1, v_i = i + 1$。

**【提示】**

数据输入的规模可能较大，请选手注意输入读取方式的效率。

## 样例 #1

### 输入

```
1 1
4 1
1 2
2 3
2 4
1```

### 输出

```
2```

## 样例 #2

### 输入

```
7 1
5 2
1 2
1 3
2 4
2 5
1 3```

### 输出

```
3```

# 题解

## 作者：wangsiyuanZP (赞：133)

### 前言

T1 做了超过一个半小时，还好有这道题让我逆天改命。

为什么都要什么容斥啊，感觉顺着做很自然啊，讲一下我的赛时简单做法。

### $k=1$

我们已经知道是从那条边开始了，每一个点的过程就是从一条边来，以任意顺序，以一条链的形态走完自己后续的边，顺便访问自己子树的情况，答案就是：

$$\prod (d_i-1)!$$

这里 $0!=1$，$d_i$ 代表 $i$ 的度数。

### 朴素情况

接下来考虑 $k>1$ 的情况，显然从不同的边开始可能生成相同的树，我在考场里认为不可能进行容斥，遂有如下观察：

**什么情况会生成相同的树？**

考虑一个已经生成的新树，它可能由哪些根节点生成出来（后文中的根节点均指代“遍历起始边”）。

![](https://cdn.luogu.com.cn/upload/image_hosting/hxos5ogw.png)

其中，蓝色边是新生成的树（对不起它是一条链，但是没有影响），红色边是可能作为根节点的原始边。

**猜想：可能的根节点一定恰好是一条从原树的叶子到叶子的链。**

证明也很简单，考虑一个点周围的所有黑边，这些边内部的蓝边一定是一条链，而只有链的两个端点可以作为根的方向。

一颗新树一定恰好有一条这样的链，所以我们可以根据链的形态来统计答案。

当链确定时，答案即为：

$$\prod (d_i-1)!\times\prod (d_v-1)^{-1}$$

其中 $i$ 是所有节点，$v$ 是链上节点，这里认为 $0^{-1}=1$。

问题转化为：**有一棵树，边有 $0/1$ 权值，点有点权，求所有叶子到叶子的链，满足这条链上有一条 $1$ 边，点权的乘积的和是多少。**

这很简单，$n=2$ 特判一下，否则取一个非叶子节点当做根，dfs 一遍，记录每个节点的子树内，叶子到它有 $1$ / 没有一个 $1$ 的乘积总和 $sum_{u,0/1}$，计算对答案的贡献即可。

这是考完重写的代码，通过了民间数据，如有错误请指出。

```cpp
// Calm down.
// Think TWICE, code ONCE.
#include<bits/stdc++.h>
#define pb push_back

using namespace std;
typedef long long ll;
typedef pair<int, int> PII;

template<typename T> inline void read(T &x){
	x = 0; bool F = 0; char c = getchar();
	for (;!isdigit(c);c = getchar()) if (c == '-') F = 1;
	for (;isdigit(c);c = getchar()) x = x*10+(c^48);
	if (F) x = -x;
}

template<typename T1, typename... T2> inline void read(T1 &x, T2 &...y){read(x); read(y...);}

template<typename T> inline void checkmax(T &a, const T &b){if (a<b) a = b;}

template<typename T> inline void checkmin(T &a, const T &b){if (a>b) a = b;}

const int N = 1e5+5;
const ll MOD = 1e9+7;
int n, m, u[N], v[N], flag_edge[N], d[N];
vector<PII> to[N];
ll sum[N][2], inv[N], ans;

void dfs(int u, int fa){
	sum[u][0] = sum[u][1] = 0;
	int v;
	ll val = 0;
	for (auto x: to[u]){
		v = x.first; if (v == fa) continue;
		dfs(v, u);
		if (x.second) sum[v][1] += sum[v][0], sum[v][0] = 0;
		(val += sum[v][1]*(sum[u][0]+sum[u][1]) + sum[v][0]*sum[u][1]) %= MOD;
		(sum[u][0] += sum[v][0]) %= MOD;
		(sum[u][1] += sum[v][1]) %= MOD;
	}
	ll INV = inv[d[u]];
	(ans += val*INV) %= MOD;
	if (!d[u]) sum[u][0]++;
	(sum[u][0] *= INV) %= MOD;
	(sum[u][1] *= INV) %= MOD;
}

inline void solve(){
	read(n, m); for (int i = 1;i<=n;i++) d[i] = -1, to[i].clear(); ans = 0;
	for (int i = 1;i<n;i++) read(u[i], v[i]), flag_edge[i] = 0, d[u[i]]++, d[v[i]]++;
	int t; while (m--) read(t), flag_edge[t] = 1;
	if (n == 2){printf("1\n"); return;}
	for (int i = 1;i<n;i++) to[u[i]].pb({v[i], flag_edge[i]}), to[v[i]].pb({u[i], flag_edge[i]});
	int rt = 0; for (int i = 1;i<=n;i++) if (d[i]) rt = i;
	dfs(rt, 0);
	for (int i = 1;i<=n;i++){
		for (int j = 1;j<=d[i];j++) (ans *= j) %= MOD;
	}
	printf("%lld\n", ans);
}

int main(){
//	freopen("traverse.in", "r", stdin);
//	freopen("traverse.out", "w", stdout);
	inv[0] = inv[1] = 1; for (int i = 2;i<N;i++) inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;
	int c, t; read(c, t); while (t--) solve();
	return 0;
}
```

---

## 作者：喵仔牛奶 (赞：32)

超级简洁的容斥做法。

# Solution

可以发现，$k=1$ 时答案为 $\prod(d_i-1)!$。考虑对于一个点，它的邻边形成了一条新树上的链。进入它的边确定了，剩下的边的顺序可以随意排列。

对于 $k=2$，把两条边连成一条链，链上的点（不包括端点）进入和出去的边都确定了，这些点只有 $(d_i-2)!$ 种方案。

我们考虑容斥，钦定一个边集 $S$，求可以同时以这些边为根的新树个数。记个数为 $g(S)$，答案为 $\sum_{S}(-1)^{\lvert S\rvert+1}g(S)$。

对于原树，如果以某个点为根有三个子树里有钦定的边，答案为 $0$。原因是这些边必须从开头或结尾走来，三条中必然有一条不行。**所以钦定的边必然构成原树上的一条链。**

考虑确定这条链，链上的点（不包括端点）只有 $(d_i-2)!$ 种方案，其他点有 $(d-1)!$ 中方案。记这条链上的点构成的集合（不包括端点）为 $L$，新树的个数为
$$\prod_{i=1}^{n}(d_i-1)!\times\prod_{i\in L}(d_i-1)^{-1}$$

前面的不变，可以提出最后乘。记 $i$ 的点权 $c_i=(d_i-1)^{-1}$，记链的贡献为链上点权之和（不包括端点）。设 $f_u$ 为 $u$ 子树**恰好存在一个链的端点**的贡献和。

- 若 $(u,fa_u)$ 可以为起点：
  - 三种情况：只选 $(u,fa_u)$；只选子树中的链；同时选两者。
  - $f_u=(-1)+\left(c_i\sum_{v}f_v\right)+\left(-c_i\sum_{v}f_v\right)=-1$。
- 否则:
  - 一种情况：只选子树中的链。
  - $f_u=c_i\sum_{v}f_v$。

考虑算答案，枚举链上最浅的点 $u$。设 $s$ 为当前链的贡献和，初始为 $0$。
- 若 $(u,fa_u)$ 可以为起点，$ans\gets ans+1$（只选这条边），$s=-1$。
- 枚举儿子 $v$：
  - $ans\gets ans-c_i\times s\times f_v$。减法是因为 $-1$ 的指数上有个 $+1$。
  - $s\gets s+f_v$。

预处理逆元，复杂度线性。

# Code

```cpp
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
// modint ...
namespace Milkcat {
	typedef long long LL;
	typedef pair<int, int> pii;
	const int N = 1e6 + 5, mod = 1e9 + 7;
	typedef math::mint<mod> MI;
	int n, k, x, y, vs[N]; MI rs, f[N], fac[N], inv[N]; vector<pii> G[N];
	void dfs(int u, int fa, int chk) {
		MI co = inv[SZ(G[u]) - 1], s = -chk;
		f[u] = -chk, rs += chk;
		for (auto [v, i] : G[u]) { 
			if (v == fa) continue;
			dfs(v, u, vs[i]);
			rs -= co * s * f[v], f[u] += (chk ? 0 : f[v]) * co, s += f[v];
		}
	}
	int main() {
		cin >> n >> k, rs = 0;
		REP(i, 1, n - 1)
			cin >> x >> y, G[x].pb(y, i), G[y].pb(x, i);
		REP(i, 1, k) cin >> x, vs[x] = 1;
		fac[0] = inv[0] = 1;
		REP(i, 1, n) {
			fac[i] = fac[i - 1] * i;
			inv[i] = (i > 1 ? inv[mod % i] * (mod - mod / i) : 1);
		}
		dfs(1, 0, 0);
		REP(i, 1, n) rs *= fac[SZ(G[i]) - 1];
		cout << rs << '\n';
		REP(i, 1, n) vs[i] = 0, G[i].clear();
		return 0;
	}
}

---

## 作者：Register_int (赞：31)

$k=1$ 的情况是简单的，每个点出边的遍历顺序都可以任意钦定。答案为 $\prod_i(d_i-1)!$。

考虑 $k>1$ 怎么做。先看 $k=2$，设两条边分别为 $x,y$，你发现对应 $x$ 到 $y$ 的路径，$x$ 会钦定掉一条入边，$y$ 会钦定掉一条出边，因此我们会算重 $\prod_{u\in\text{path(x,y)}}(d_u-2)!$ 这么多次，而路径外的任意一种方案两个点都能做到。所
扣掉算重的方案即可。

考虑推广这个做法，为 $k$ 个点钦定一个顺序，每次将方案数加上 $x_i$ 的方案数，再扣掉与 $x_{1\sim i-1}$ 算重的方案。容易想到按 dfn 钦定。假设我们枚举到 $u$ 点与 $v$ 这个儿子，那么需要扣除的贡献有 $u$ 的父亲这部分与在 $v$ 之前的子树这部分。子树是好算的，设 $f_u$ 表示 $u$ 子树内的总方案数，$g_u$ 表示子树内会算重的方案数。你发现要跟一个子树算重，这个点必须要最后一个遍历这条树边，所以情况没有交集！可以直接加起来。容易得到转移：

$$
g_u\gets g_u+
\begin{cases}
g_v(d_u–2)!&(u,v)不是关键边\\
f_v(d_u–2)!&else
\end{cases}
$$

记得乘上子树外面的所有东西。

来自父亲的贡献也是好算的，从上往下递推，若是关键边则为 $f_1/f_u$，否则从父亲的父亲乘上 $(d_u-2)!$。

鲜花：你怎么知道我赛时算父亲贡献算成了 $u$ 到根的贡献浪费两小时还没看出来？

时间复杂度 $O(n)$。

---

## 作者：TruchyR (赞：20)

赛时似乎打出来了的样子。

下文称关键边为起始边，设 $d_i$ 为点 $i$ 的度数。

## 第一步
先考虑 $k=1$ 的情况。

思考这个深搜的过程，对于每个点连出的 $d_i$ 条边，它们见一定是有连边的。

由于 dfs 树的优良性质，把这 $d_i$ 条边连起来后一定是条链。

规定了一个起始边后每个点连出的边中作为链起点的边是固定的，其余的边连接顺序可以随意安排。

答案即 $\prod_{i=1}^{n} (d_i-1)!$。  

## 第二步
当起始点变多后直接把这个答案乘上 $k$ 显然是错误的，我们要减去重复的方案。

先设 $f_i$ 表示钦定了 $i$ 条边后满足同时可以以这 $i$ 条边作为起始边的 dfs 树的方案数，最终答案就是 $\sum_{i=1}^{k} (-1)^{i-1}f_i$。  

考虑一个方案满足同时以多条边作为起始边需要满足什么条件。

根据第一步的推导，一个点连出的 $d_i$ 条边连起来后一定是链。

那么链只有两个端点，那么从那些起始边深搜过来一定也只能是两个方向来的。  

由此，条件就是**这些边都在一条链上**。

考虑找到一条链满足第一条边和最后一条边都是关键边。

对于链中间的点，确定了两个作为链起点或终点的边，所以贡献会变为 $(d_i-2)!$，也就是相比于原来除以了 $d-1$。  

假如这么算出的方案数为 $w$，这条链上一共有 $l$ 个关键边，那么对于 $f_i$ 的贡献就是 $C_{l-2}^{i-2}\times w$。

这里第一条边和最后一条边一定要选上，这样才不会算多。  

这样做下去应该可以做到 $O(n^{2}k)$ 或者 $O(nk)$。

## 第三步
考虑上一步算出的贡献对总答案造成的贡献。

代入前文的式子可得到 $(-1)^{i-2}C_{l-2}^{i-2}\times w$。

根据组合数的一个性质我们发现一个重要的事实，所有 $l\geq 3$ 的链对答案都是没有贡献的。

所以我们算 $l=2$ 的链对答案的贡献即可。

对于怎么快速的算出来，可以断开每条关键边，然后对于每棵树进行换根 dp。

注意预处理逆元即可，时间复杂度是 $O(Tn)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define MX 100005
#define GP pair<int,int>
#define MP make_pair
using namespace std;int read();
const int mod=1000000007;
GP e[MX];vector<int> v[MX],g[MX];
int n,k,d[MX],fa[MX],w[MX],kid[MX];
int frc[MX],inv[MX],cnt,ans,cal[MX];
void init(int o){
	frc[0]=frc[1]=inv[0]=inv[1]=1;
	for(int i=2;i<=o;i++){
		frc[i]=frc[i-1]*i%mod;
		inv[i]=inv[i-(mod%i)]*(mod/i+1)%mod;
	}
}
void dfs(int t){
	cal[t]=w[t];kid[t]=1;
	for(auto i:g[t]){
		if(fa[t]==i) continue;
		fa[i]=t;dfs(i);
		cal[t]=(cal[t]+cal[i])%mod;
	}cal[t]=cal[t]*d[t]%mod;
}
void Solve(int t,int bs){
	int ww=w[t]*(cal[t]+bs+mod-d[t])%mod;
	ans=(ans+mod-ww)%mod;
	//cout<<t<<' '<<ww<<'\n';
	for(auto i:g[t]){
		if(fa[t]==i) continue;
		int upd=(cal[t]+mod-(d[t]*cal[i]%mod))%mod;
		Solve(i,d[i]*(bs+upd)%mod);
	}
}
void solve(int t){
	fa[t]=0;
	dfs(t);Solve(t,0);
}
signed main(){
	//freopen("traverse.in","r",stdin);
	//freopen("traverse.out","w",stdout);
	init(MX-5);
	int C=read();int T=read();while(T--){
		n=read();k=read();
		for(int i=1;i<=n;i++){
			v[i].clear();g[i].clear();
			d[i]=w[i]=kid[i]=0;
		}
		for(int i=1;i<n;i++){
			int x=read();int y=read();
			e[i]=MP(x,y);d[x]++;d[y]++;
			v[x].push_back(y);
			v[y].push_back(x);
		}
		cnt=1,ans=k*2;
		for(int i=1;i<=n;i++){
			cnt=cnt*frc[d[i]-1]%mod;
			d[i]=inv[d[i]-1];
		}
		for(int i=1;i<=k;i++){
			int x=read();
			w[e[x].first]++;
			w[e[x].second]++;
			kid[x]=1;
		}
		for(int i=1;i<n;i++){
			if(kid[i]){kid[i]=0;continue;}
			int x=e[i].first,y=e[i].second;
			g[x].push_back(y);
			g[y].push_back(x);
		}
		for(int i=1;i<=n;i++){
			if(kid[i]) continue;
			solve(i);
		}
		//printf("%lld %lld / ",cnt,ans);
		cnt=cnt*ans%mod;
		cnt=cnt*500000004%mod;
		printf("%lld\n",cnt);	
	}
	return 0;
}
int read(){
	int Ca=0,Cf=1;char Cr=' ';
	while(Cr<'0' || Cr>'9'){Cr=getchar();if(Cr=='-'){Cf=-Cf;}}
	while(Cr>='0' && Cr<='9'){Ca=Ca*10+Cr-48;Cr=getchar();}
	return Ca*Cf;
}
```

---

## 作者：CarroT1212 (赞：18)

25-2-7 upd：修改了一些表述比较迷惑的地方。不过现在写得貌似还是有亿点绕。

这题还是很厉害的，计数不行只能甘拜下风了，写详细点记录一下。

先看 $k=1$。

+ 手画一下新树的形态。
+ 原图中的每一个点连接的边在新树里形成一条链，称其为环绕链。
+ 有一条起点边。
+ 设原图中有个点 $x$，它连接的边在新树里形成一条环绕链，这条环绕链里除了第一个点（原图里的边）之外，后面的点都可以随意重排，而第一个点对应的边一定是从原图中的 $x$ 走到起点边会经过的那一条边。
+ 只要能确定每条这样的环绕链的排列顺序就可以确定整棵新树，所以 $k=1$ 的答案即为 $\prod(d_i-1)!$，$d_i$ 是度数，每个原图中的点恰好有一条边被钦定在第一个遍历，所以每个点的环绕链排列数是 $(d_i-1)!$。

获得 $24$ 分，再手玩一下链和菊花还能再拿 $16$ 分。

然后我们看 $k=2$。

+ 现在的问题在于，有一些新树，可以同时由两条边作为起点边走出来。
+ 考虑什么树是能由输入给的两条起点边同时走出来的。设这两条起点边为 $l_1,l_2$。到时候直接把 $k=1$ 的答案乘二然后减去这个值即可。
+ （赛时死这儿了）
+ $k=1$ 时，一个点的环绕链排列方法是否合法，判定方法是看环绕链上的第一个点对应的原图边离起点边是不是最近的。
+ 如果一个点在原树中不在 $l_1,l_2$ 之间的链上，那么它的环绕链上的第一个点如果离 $l_1$ 最近，也会离 $l_2$ 最近，所以没有影响，排列顺序数还是 $(d_i-1)!$。
+ 如果一个点在的话，貌似不太合法？意识到链除了第一个点还有最后一个点，只要以另一条起点边开始的时候我们将链反过来就是一样的。所以限制是，环绕链上的第一个点离 $l_1$ 最近，最后一个点离 $l_2$ 最近，剩下的随便排（记住这里环绕链上的“点”始终对应的是原图上的“边”）。方案数是 $(d_i-2)!$。
+ 把这两种贡献乘起来就是答案。

获得 $56$ 分。

考虑 $k>2$。

+ 还是考虑去重，能把重复条件简单地分析出来的话，后面套个容斥应该就好。
+ 所以现在考虑，如果一棵新树能同时被三条（甚至更多）起点边走出来会发生什么？
+ 要是原图有一个点，在三条起点边方向上的出边互不相同，那么这个点的环绕链就不存在任何合法的，能同时由三条起点边走出来的排列方式。
+ 所以要让每个点在三条起点边方向的出边最多只有不同的两条。
+ 再意会一下，发现这个限制等价于三条边在原树的同一条链上。所以新树方案数，只和这条链上最两端的两条起点边有关，直接按 $k=2$ 的方法算即可。更多的起点边也一样。

所以要去重的话，只用考虑所有算重的起点边都在同一条链上的情况。称这条链为关键链。

以下注意区分关键边和起点边。前者是输入给定的，后者是对于新树的生成方案而言的。

+ 我们正式开始容斥。由容斥式子可知我们目标是对于每个 $i$，求出每 $i$ 条关键边作为起点边可以同时生成的新树数量的和，设其为 $f_i$。令 $f_1$ 为 $k=1$ 时的答案 $\times k$。
+ 我们尝试去分别计算每条关键链对这些 $f_i$ 的贡献。
+ 枚举两条关键边 $l_1,l_2$，假设它们是一条关键链上最靠两端的起点边，这时新树数只和它们有关。现在计算这条关键链中，所有可能的起点边选取方案对 $f_i$ 的贡献。
+ 显然如果要再多取关键边作为起点边的话，一定要取在 $l_1,l_2$ 中间的链上。
+ 求出 $l_1,l_2$ 中间链上的关键边数 $v$（包括 $l_1,l_2$），那么枚举中间的关键边取了几条作为起点边，用这些选取方案更新 $f_i$，有 $f_i\gets f_i+\binom{v-2}{i-2}val$。
+ $-2$ 是因为限制两侧必取 $l_1,l_2$，$val$ 是能由 $l_1,l_2$ 生成的新树数，之前说过每一种取法的新树数都是一样的，用之前的方法求出来就好。
+ 对每对 $(l_1,l_2)$ 这么更新一遍即可， 答案是容斥的 $\sum\limits_{i=1}^n(-1)^{i-1}f_i$。
+ [$O(nk^2)$ 的代码](https://www.luogu.com.cn/paste/2rsrxla3)。这里精细实现枚举每一个 $l_1$ 算所有 $l_2$ 可以做到 $O(nk)$。

到这里理论最高能直接拿 $84$ 分，当然常数很大。如何不带这个 $k$？

+ 如果你对容斥性质的理解较为深刻，你会发现这个容斥比较多余。
+ 具体来说，如果两条关键边 $l_1,l_2$ 中间的 $v\ge 3$，即它们中间隔了另一条关键边，那么这两条关键边作为关键链上的两端时，它们对答案的所有贡献，会被容斥系数消成 $0$。
+ 用人话说就是，不考虑中间隔了其它关键边的 $l_1,l_2$，对答案没有影响。
+ 大致解释：容斥状式子有个性质就是 $\sum\limits_{i=0}^m(-1)^i\binom{m}{i}=[m=0]$。
+ 上面那个 $f_i$ 的更新式中，我们每次枚举 $l_1,l_2$ 相当于给最终答案加上了 $\sum\limits_{i=0}^{v-2}(-1)^i\binom{v-2}{i}val$，但 $val$ 不会随 $l_1,l_2$ 中间关键边选取的情况而变化，所以本质上只是给 $\sum\limits_{i=0}^{v-2}(-1)^i\binom{v-2}{i}$ 这个容斥状式子乘了个系数加到答案里。所以只有在 $v-2=0$ 的时候，对答案的贡献是 $val$，否则是 $0$。
+ 另一种比较玄学的理解是，显然我往一条关键链的中间多加多少条关键边，我都不影响它的方案数，那不如直接只算不加的情况了。

所以，我们只用考虑中间没有其它关键边的 $l_1,l_2$ 带来的贡献，相当于是只用对它们做 $k=2$ 的情况。看起来就好做了啊。

+ 这里可以把关键边断开，变成一堆森林，然后对森林里的每一棵树，跑一个换根 DP，对每一个跟关键边相接的点统一计算它连的关键边和其它关键边之间的贡献。此处细节看代码。
+ 大致原理是先预先乘个 $\prod(d_i-1)!$，然后遇到一个点就乘上 $(d_i-1)^{-1}$。

精细实现复杂度 $O(Tn)$。

```cpp
ll qp(ll x,ll y=P-2) { return y?(y&1?x:1)*qp(x*x%P,y>>1)%P:1; }
ll fac[N],fnv[N];
struct init { init() {
	fac[0]=1;
	for (ll i=1;i<N;i++) fac[i]=fac[i-1]*i%P;
	fnv[N-1]=qp(fac[N-1]);
	for (ll i=N-1;i;i--) fnv[i-1]=fnv[i]*i%P;
} } A;
ll type;
ll n,k,is[N],a[N];
ll del[N],st,ww,vis[N],dp[N],pd[N],ans;
pll b[N];
vector<pll> e[N];
void dfs(ll p,ll f) {
	vis[p]=1;
	for (pll i:e[p]) if (i.fi!=f) {
		if (is[i.se]) (dp[p]+=st)%=P;
		else dfs(i.fi,p),(dp[p]+=dp[i.fi])%=P;
	}
	(dp[p]*=del[p])%=P;
}
void dfs1(ll p,ll f) {
	ll cnt=0;
	for (pll i:e[p]) {
		if (!is[i.se]) {
			if (i.fi!=f) (pd[p]+=dp[i.fi])%=P;
			else (pd[p]+=pd[i.fi])%=P;
		}
		else cnt++;
	}
	(ans+=(cnt*pd[p]%P+st*cnt%P*(cnt-1)%P)*del[p])%=P,(pd[p]+=st*cnt)%=P;
	ll tmp=pd[p];
	for (pll i:e[p]) if (i.fi!=f&&!is[i.se]) {
		pd[p]=(pd[p]+P-dp[i.fi])*del[p]%P;
		dfs1(i.fi,p);
		pd[p]=tmp;
	}
	(pd[p]*=del[p])%=P;
}
void mian() {
	rd(n),rd(k),ans=0;
	for (ll i=1;i<=n;i++) e[i].clear(),dp[i]=pd[i]=is[i]=vis[i]=0;
	for (ll i=1,x,y;i<n;i++)
		rd(x),rd(y),e[x].pb({y,i}),e[y].pb({x,i}),b[i]={x,y};
	for (ll i=1;i<=k;i++) rd(a[i]),is[a[i]]=i;
	st=1;
	for (ll i=1;i<=n;i++)
		(st*=fac[(ll)e[i].size()-1])%=P,
		del[i]=e[i].size()==1?1:qp((ll)e[i].size()-1);
	for (ll i=1;i<=n;i++) if (!vis[i]) dfs(i,0),dfs1(i,0);
	cout<<(st*k+P-ans*qp(2)%P)%P<<"\n";
}
```

---

## 作者：yuanruiqi (赞：17)

**菊花图且 $k=1$**：所有的边都相邻，所以答案为 $(n-2)!$。

**链**：边的邻接关系同样构成链，所有只有一种生成树，答案为 $1$。

**$k=1$**：观察下图的关键边和一种可能的连接方案，考虑每个点连接的边集，令其中最先访问的边为 $e$，则该点的邻边的连接情况一定是某种以 $e$ 为端点的链，由 dfs 生成树无横叉边可证，而且 $(\deg-1)!$ 种都可以取到。答案则是 $\prod_{i}(\deg i-1)!$。

![](https://cdn.luogu.com.cn/upload/image_hosting/d2pxigdy.png)

**$k=2$**：我们考察某条起始边的意义，令该边的一个端点为根，如上图所示，根以外的每个点首先被访问的邻边为它连向根的边，即邻边集的连接情况对应的链一定有一个端点是连向根的边。

考虑有多少种答案同时满足两个起始边的条件，令 $X,Y$ 为各自的一个端点，且 $X\ne Y$，考虑取出树链 $X-Y$，在链之外的点的情况是平凡的，因为无论以 $X$ 还是 $Y$ 为根，朝向根的邻边不变。链上的中间点则需要保证链的两个端点恰好为朝向 $X$ 和 $Y$ 的，方案数由 $(\deg-1)!$ 变为 $(\deg-2)!$。对于 $X$ 和 $Y$，则需要根据它们代表的起始边的另一个端点的位置特殊讨论。

![](https://cdn.luogu.com.cn/upload/image_hosting/hcf2a311.png)

**正解**：可以先以 $1$ 为根转化为有根树，对于每条关键边，可以用深度较大的端点唯一表示，下面可能会用“起始点”来描述对应的“起始边”。如果一组连接情况同时满足多个起始点，则它们一定在一条链上，否则会出现下图的不合法情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/2eschfbz.png)

容易发现中间点处无解。

于是我们可以考虑树上 DP。先进行容斥，令 $g(s)$ 为钦定了同时满足集合 $s$ 中的起始点的方案数，答案显然是 $\sum_{s}(-1)^{|s|+1}g(s)$。故设计 DP 状态 $f(u)$ 表示钦定的关键点集构成的链经过 $u$，且其中一个端点在 $u$ 子树内的带权方案数，为了方便转移，可以对于每个点的方案都除以 $(\deg-1)!$。令 $c=\frac{1}{\deg u-1}$（当 $\deg u=1$ 时 $c=1$）。则转移为：

$$
f(u)=\left\{
\begin{aligned}
&\sum_{v}cf(v) \ \ \ \ (u\text{是某个起始点}) \\
&-1 \ \ \ \ else
\end{aligned}
\right.
$$

贡献答案则是枚举两棵子树，或者当前点为起始点连向子树内某个点，是容易的。

最后答案应该乘以 $\prod_{i}(\deg i-1)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
constexpr int mod = 1000000000 + 7;
constexpr int maxn = 100000 + 10;
i64 qp(i64 a, i64 b)
{
    i64 c = 1;
    for (; b; b>>=1, a=a*a%mod)
        if (b & 1) c=c*a%mod;
    return c;
}
i64 fac[maxn], inv[maxn];
vector<int> g[maxn];
i64 f[maxn];
int o[maxn];
i64 ans;
void dp(int u, int fa)
{
    i64 s = 0, p = 0;
    for (int v : g[u]) if (v != fa)
    {
        dp(v, u);
        p = (p + s * f[v]) % mod;
        s = (s + f[v]) % mod;
    }
    i64 c = g[u].size() == 1 ? 1 : inv[g[u].size() - 1] * fac[g[u].size() - 2] % mod;
    ans = (ans - p * c % mod + mod) % mod;
    if (o[u])
    {
        f[u] = mod - 1;
        for (int v : g[u]) if (v != fa)
        {
            ans = (ans + f[v] * c % mod + mod) % mod;
        }
    }
    else f[u] = s * c % mod;
}
int d[maxn];
void dfs(int u, int fa)
{
    d[u] = d[fa] + 1;
    for (int v : g[u]) if (v != fa) dfs(v, u);
}
int u[maxn], v[maxn];
void solve()
{
    int n, k;
    cin >> n >> k;
    for (int i=1;i<=n;++i) g[i].clear();
    memset(f, 0, sizeof(f));
    memset(o, 0, sizeof(o));
    for (int i=1;i<n;++i)
    {
        cin >> u[i] >> v[i];
        g[u[i]].emplace_back(v[i]);
        g[v[i]].emplace_back(u[i]);
    }
    dfs(1, 0);
    for (int i=1;i<=k;++i)
    {
        int x;
        cin >> x;
        o[d[u[x]] < d[v[x]] ? v[x] : u[x]] = 1;
    }
    ans = k;
    dp(1, 0);
    for (int i=1;i<=n;++i) ans = ans * fac[g[i].size() - 1] % mod;
    cout << ans << '\n';
}
int main()
{
    fac[0] = 1;
    for (int i=1;i<maxn;++i) fac[i] = fac[i - 1] * i % mod;
    inv[maxn - 1] = qp(fac[maxn - 1], mod - 2);
    for (int i=maxn-2;i>=0;--i) inv[i] = inv[i + 1] * (i + 1) % mod;
    ios::sync_with_stdio(0);
    cin.tie(0);
    int c, t;
    cin >> c >> t;
    while (t--) solve();
    return 0;
}
```

---

## 作者：TernaryTree (赞：14)

鉴定为比 T1 简单。T1 做了 2h，场上没时间了正解没写出来，发怒。

考虑 $k=1$ 咋做，手摸一下，不难发现答案应该是 $\prod_{i=1}^n (deg_i-1)!$。

考虑 $k=2$ 咋做。

首先你可以得到两倍的 $k=1$ 的答案，然后你要减去一些同时可以成为两条边为根的 dfs 树。

你发现实际上你的树是在原树的每个点上面给每条边钦定了一个遍历的顺序。

然后这个顺序告诉你什么，告诉你开头的那个和结尾的那个子树里边，里面必须有一个关键边。并且所有点你钦定完顺序之后，要存在一个关键边满足所有点有上面那个性质。（**关键性质**）

于是 $k=2$ 实际上，找到两条边之间的这条链，里面所有点相邻的边的顺序，一定要有“某一个是开头，某一个是结尾”的限制。所以这条链上点的方案数是 $\prod (deg_i-2)!$。其余的点贡献相同。

然后你就可以考虑 $k=8$ 怎么做；仍然是容斥。如果容斥到的边数 $\ge 3$，我们看看会发生什么：

如果有一个点有三个子树里面都有关键边，答案为 $0$。（**关键性质**）

所以被算到贡献里的边集必须能被一条链覆盖。

继续考虑，设这条链最左边的边与最右边的边中间有 $x$ 条选中的关键边。

那么包含最左边的边与最右边的边的边集总贡献应该是

$$\sum_{i=0}^x \dbinom xi (-1)^i=[x=0]$$

哦，那你就发现只有“相邻”的关键边是需要容斥的，也就是 $|S|\ge 3$ 的贡献都不用算了。

然后贡献的形式可以看做是 $k=1$ 的答案乘了链上所有点的 $\dfrac{1}{deg_i-1}$ 之积。

然后就可以 dp 了。设 $f_u$ 表示考虑了 $u$ 子树和 $u$ 往父亲的一条边，容斥要减掉的那个积的和是多少，记 $g_u$ 表示子树里能直接到 $u$ 的边到 $u$ 的积的总和。

然后就可以转移了，复杂度是线性。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fs first
#define sc second
#define ls (u << 1)
#define rs (u << 1 | 1)
#define mid ((l + r) >> 1)
#define lc ls, l, mid
#define rc rs, mid + 1, r
#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
#define per(i, r, l) for (int i = (r); i >= (l); --i)
#define gc getchar
#define pc putchar

using namespace std;
using pii = pair<int, int>;
using vi = vector<int>;

const int maxn = 1e6 + 10;
const int mod = 1e9 + 7;
const int inv2 = 5e8 + 4;
const bool multidata = 1;

template<typename T = int>
T read() {
	T x = 0, f = 1; char c = gc();
	while (c < '0' || c > '9') { if (c == '-') f = -f; c = gc(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc();
	return x * f;
}

template<typename T = int>
void write(T x) {
	if (x < 0) pc('-'), x = -x;
	if (x < 10) return void (pc(x + '0'));
	write<T>(x / 10), pc(x % 10 + '0');
}

int power(int a, int b, int p = mod) {
	int t = 1; a %= p;
	while (b) {
		if (b & 1) t = t * a % p;
		a = a * a % p, b >>= 1;
	}
	return t;
}

int n, k;
vector<pii> tr[maxn];
pii e[maxn];
int id[maxn], bk[maxn];
int fac[maxn], ifac[maxn];
int a[maxn], b[maxn];
int f[maxn], g[maxn];

void dfs(int u, int fa, int fw) {
	int s = 0, t = 0; 
	for (pii i : tr[u]) {
		int v = i.fs, w = i.sc;
		if (v == fa) continue;
		dfs(v, u, w);
		(f[u] += f[v]) %= mod;
		(s += g[v]) %= mod;
		(t += g[v] * g[v] % mod) %= mod;
	}
	(f[u] += (s * s % mod - t + mod) * inv2 % mod * b[u] % mod) %= mod;
	if (bk[fw]) {
		(f[u] += s * b[u] % mod) %= mod;
		g[u] = 1;
	} else {
		g[u] = s * b[u] % mod;
	}
//	cout << u << " " << f[u] << " " << g[u] << endl;
}

void fake_main() {
	n = read(), k = read();
	fac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;
	ifac[n] = power(fac[n], mod - 2);
	per(i, n - 1, 0) ifac[i] = ifac[i + 1] * (i + 1) % mod; 
	rep(i, 1, n - 1) {
		int u = read(), v = read();
		tr[u].push_back({v, i});
		tr[v].push_back({u, i});
		e[i] = {u, v};
	}
	rep(i, 1, k) bk[id[i] = read()] = 1;
	int tot = 1;
	rep(i, 1, n) {
		a[i] = fac[tr[i].size() - 1];
		if (tr[i].size() >= 2) b[i] = ifac[tr[i].size() - 1] * fac[tr[i].size() - 2] % mod;
		tot = tot * a[i] % mod;
	}
	dfs(1, 0, 0);
	write((k - f[1] + mod) * tot % mod), pc('\n');
	rep(i, 1, n) tr[i].clear(), id[i] = bk[i] = f[i] = g[i] = 0;
}

signed main() {
//	freopen("traverse.in", "r", stdin);
	int c = read(), T = multidata ? read() : 1;
	while (T--) fake_main();
	return 0;
}

```

---

## 作者：AKiWo (赞：10)

题解区很多精妙的做法，但思维难度略高。这里提供一个大力出奇迹的方法。

我们定义原来的点是圆点，原来的边是方点，那么新的树将会是方点之间的连边。

根据类似 Tarjan 算法的分析思路，我们可以得到一个圆点周围的方点之间的连边必定会形成一条链。这条链的两个终点我们称为端点。不难发现从关键方点出发的任意路径，第一次进入一个圆点对应的方点组成的集合时所在方点，必定是一个端点。这样，如果两个圆点之间不是端点与端点相连，那么关键方点必定不在以端点相连的那一半树中。

通过这一个性质，我们可以在新树的形态固定时得到关键方点只可能处于一条两端为叶子的链中。也即，两个可能的关键方点必定处于一条链上。

现在考虑统计答案。首先每个节点 $u (\text{deg}_{u} > 1)$ 都会对答案造成 $(\text{deg}_{u} - 2)!$ 的贡献，表示除了端点之外的点连边的方案数。现在只需要确定两个端点即可。

如果只有一个关键方点，那么一个端点已经确定了。剩下的可以随便选，故方案数为 $\text{deg}_{u} - 1$。

但如果有多个关键方点，我们需要考虑去重。比较套路的想法是，我们可以考虑对每种树的形态，把它分配给所有可能的关键方点中优先级最高的（虽然大多数题解都是直接容斥）。

一种好写的优先级是 dfs 序。然后我们可以使用换根 dp，处理出每个儿子的方案数。具体分为两类：其所在的链会连接到比接下来会连接到的关键方点优先级更高的关键方点与其所在的链没有连接到关键方点或连接到的关键方点必定比接下来会连接到的关键方点优先级低。转移的时候只需要考虑另一个端点在哪里就可以了。具体的，非端点需要乘上一二类方案的和，而另一个端点则需要分类讨论需要乘什么。

统计答案的时候将关键边两边的 dp 结果（第二类）相乘后相加即可。时间复杂度 $O(n)$。

思维简单，但代码很长（不知道算不算最长写法）：

```c++
#include <bits/stdc++.h>

namespace MINE {

const int maxn = 1e5;
const int mod = 1e9 + 7;
int fac[maxn + 5];
int n, k;
int head[maxn + 5], nxt[maxn * 2 + 5], to[maxn * 2 + 5], ecnt;
int deg[maxn + 5];
bool imp[maxn * 2 + 5];

void add(int u, int v) {
    ++ ecnt;
    nxt[ecnt] = head[u];
    to[ecnt] = v;
    head[u] = ecnt;
    return;
}

int A(int aa, int bb) {
    return aa + bb >= mod ? aa + bb - mod : aa + bb;
}

int M(int aa, int bb) {
    return 1ll * aa * bb % mod;
}

int f[2][maxn + 5];
int tmp[maxn + 5];
void dfs0(int u, int fa) {
    if(deg[u] == 1 && u != 1) {
        f[0][u] = 0;
        f[1][u] = 1;
        return;
    }

    f[0][u] = f[1][u] = 0;
    for(int e = head[u]; e; e = nxt[e]) {
        if(to[e] == fa) {
            continue;
        }

        dfs0(to[e], u);
    }

    int i = 0;
    for(int e = head[u]; e; e = nxt[e]) {
        if(to[e] == fa) {
            continue;
        }

        ++ i;
        tmp[i] = A(f[0][to[e]], f[1][to[e]]);
    }

    tmp[u == 1 ? deg[u] + 1 : deg[u]] = 1;
    for(i = deg[u] - 1; i >= 1; -- i) {
        tmp[i] = M(tmp[i], tmp[i + 1]);
    }

    i = 0;
    int res = 1;
    for(int e = head[u]; e; e = nxt[e]) {
        if(to[e] == fa) {
            continue;
        }

        ++ i;
        if(imp[e]) {
            f[0][u] = A(f[0][u], tmp[1]);
        } else {
            f[0][u] = A(f[0][u], M(M(res, tmp[i + 1]), f[0][to[e]]));
            f[1][u] = A(f[1][u], M(M(res, tmp[i + 1]), f[1][to[e]]));
        }
        res = M(res, A(f[0][to[e]], f[1][to[e]]));
    }

    return;
}

int ans, hh0[maxn * 2 + 5], hh1[maxn * 2 + 5];
void dfs1(int u, int fa, int g0, int g1, int *h0, int *h1, bool im) {
    if(deg[u] == 1 && u != 1) {
        return;
    }

    int i = 0;
    for(int e = head[u]; e; e = nxt[e]) {
        if(to[e] == fa) {
            continue;
        }

        ++ i;
        tmp[i] = A(f[0][to[e]], f[1][to[e]]);
    }

    tmp[u == 1 ? deg[u] + 1 : deg[u]] = 1;
    for(i = deg[u] - 1; i >= 1; -- i) {
        tmp[i] = M(tmp[i], tmp[i + 1]);
    }

    i = 0;
    int res = 1, sum0 = 0, sum1 = 0;
    for(int e = head[u]; e; e = nxt[e]) {
        if(to[e] == fa) {
            continue;
        }

        ++ i;
        h0[i - 1] = h1[i - 1] = 0;
        if(u != 1) {
            if(im) {
                h0[i - 1] = A(h0[i - 1], M(M(res, tmp[i + 1]), A(g0, g1)));
            } else {
                h0[i - 1] = A(h0[i - 1], M(M(res, tmp[i + 1]), g0));
                h1[i - 1] = A(h1[i - 1], M(M(res, tmp[i + 1]), g1));
            }
        }
        h0[i - 1] = A(h0[i - 1], M(M(sum0, tmp[i + 1]), A(g0, g1)));
        h1[i - 1] = A(h1[i - 1], M(M(sum1, tmp[i + 1]), A(g0, g1)));
        h1[i - 1] = A(h1[i - 1], M(u == 1 ? deg[u] - i : deg[u] - i - 1, M(M(res, tmp[i + 1]), A(g0, g1))));
        if(u == 1 && deg[u] == 1) {
            h1[i - 1] = 1;
        }

        if(imp[e]) {
            ans = A(ans, M(A(f[0][to[e]], f[1][to[e]]), h1[i - 1]));
            sum0 = A(M(sum0, A(f[0][to[e]], f[1][to[e]])), M(res, A(f[0][to[e]], f[1][to[e]])));
            sum1 = M(sum1, A(f[0][to[e]], f[1][to[e]]));
        } else {
            sum0 = A(M(sum0, A(f[0][to[e]], f[1][to[e]])), M(res, f[0][to[e]]));
            sum1 = A(M(sum1, A(f[0][to[e]], f[1][to[e]])), M(res, f[1][to[e]]));
        }

        res = M(res, A(f[0][to[e]], f[1][to[e]]));
    }

    i = 0;
    for(int e = head[u]; e; e = nxt[e]) {
        if(to[e] == fa) {
            continue;
        }

        ++ i;
        dfs1(to[e], u, h0[i - 1], h1[i - 1], u == 1 ? h0 + deg[u] : h0 + deg[u] - 1, u == 1 ? h1 + deg[u] : h1 + deg[u] - 1, imp[e]);
    }

    return;
}

void solve() {
    scanf("%d%d", &n, &k);

    ecnt = 0;
    memset(head, 0, sizeof(head));
    memset(deg, 0, sizeof(deg));
    for(int i = 1; i < n; ++ i) {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v);
        add(v, u);
        ++ deg[u]; ++ deg[v];
    }

    memset(imp, false, sizeof(imp));
    for(int i = 1; i <= k; ++ i) {
        int id;
        scanf("%d", &id);
        imp[id * 2 - 1] = imp[id * 2] = true;
    }

    dfs0(1, 0);
    ans = 0;
    dfs1(1, 0, 0, 1, hh0, hh1, true);

    for(int i = 1; i <= n; ++ i) {
        if(deg[i] > 1) {
            ans = M(ans, fac[deg[i] - 2]);
        }
    }

    printf("%d\n", ans);
    return;
}

void main() {
    fac[0] = 1;
    for(int i = 1; i <= maxn; ++ i) {
        fac[i] = M(fac[i - 1], i);
    }

    int c, t;
    scanf("%d%d", &c, &t);
    while(t --) {
        solve();
    }
    return;
}

}//namespace MINE

int main() {
    MINE::main();
    return 0;
}
```

---

## 作者：Iniaugoty (赞：10)

好题啊 T3，感觉比 T4 的 CNOI 传统 DS 质量高。

考虑这样连边能得到什么。对于原树上某个点 $u$，它的所有邻边 $(u, v)$ 之间会两两连边，于是就得到了一个新图中的大小为 $deg _ u$ 的完全子图。原树上每条边 $(u, v)$ 都有两个端点 $u$ 和 $v$，说明在新图中它只会同时出现在 $u$ 和 $v$ 的完全子图，并且两部分仅能通过 $(u, v)$ 这个点相连。有点仙人掌。

考虑这样遍历能得到什么。是一个 dfs，就是能走多远走多远的那种，如果通过 $(u, v)$ 从 $u$ 的完全子图走到 $v$ 的完全子图，会先把后面 $v$ 子树内所有边都遍历完再回溯回来，再走另一个 $(u, w)$，然后生成树连一条 $(u, v) - (u, w)$ 的边。很难不发现这会在 $u$ 的完全子图中得到一个 长为 $deg _ u$ 的短链。最终的生成树是 $n$ 个这样的短链拼起来的。

再考虑从 $(u, v)$ 开始遍历的话，先进入 $v$ 的完全子图，那很明显 $(u, v)$ 会是短链的一个链头。如果另一个链头是 $(v, w)$ 的话，从 $(v, w)$ 进入到 $w$ 的完全子图，同时 $(v, w)$ 成为了 $w$ 短链的链头……反过来 $u$ 这边也一样。于是注意到有且仅有一条极长的链，由一堆完全子图的短链首尾相接构成，而其他完全子图的短链都通过一个链头直接或者间接地挂在这条极长链上。进一步注意到，一条边能生成一棵树，当且仅当这颗树存在这样的极长链，并且这条边在极长链上。(否则无论如何，生成出来的树的极长链都不是这条)。

挂在这条极长链上计数！回到原树，一条极长链就是原树上一对叶子结点之间的最短路径，显然当路径上存在关键边时才会对答案有贡献。

考虑这个贡献是什么。对于路径上的非叶子结点 $u$ 只会有两条邻边 $(u, v)$ 和 $(u, w)$ 在路径上，并且他们会作为新图中 $u$ 的短链的两个链头，剩下邻边的顺序可以随意钦定，方案数为 $(deg _ u - 2)!$。对于不在路径上的点 $u$，设它距离路径最近的一条临边为 $(v, u)$，显然遍历会从 $(v, u)$ 进入到 $u$ 的完全子图，剩下的邻边顺序随意钦定，方案数为 $(deg _ u - 1)!$。
这道看起来很不可做的题得到了一个 $O(n ^ 3)$ 做法！

很难不发现对于每对叶子 $\prod (deg _ u - 1)!$ 是一样的于是提出来。于是贡献变成了路径上的非叶子节点的 $\frac {1} {deg _ u - 1}$ 之积。随便做有 $O(n ^ 2)$ 或者 $O(n ^ 2 \log n)$。

再看一下这个形式，如果定义一对点的距离是路径上点权之积的话，这题就是对于每对路径上存在关键边的叶子，求出距离和。

~~点分治秒了~~！于是我赛时不知道怎么想的直接写了点分治，时间复杂度 $O(n \log n)$，本机大样例最慢点 0.9s，洛谷最慢点 1.2s，CCF 应该能卡过。

实际上赛后发现把贡献挂在 LCA 上 dfs 扫一下统计就行了，就是维护每个点到达子树内经过/不经过关键边的叶子的距离和。时间复杂度 $O(n)$。

赛前一周我试图把 300th 紫留到联赛场切，于是我真的成功了！

---

## 作者：是青白呀 (赞：7)

一个关键性质是，一个点连接的所有边在最终的树上会形成一条链，且链与链之间的结构不互相影响。注意这并不意味着你可以把每个点的合法链方案乘起来，因为一个方案是否合法与你选定的起点有关。博主因为这个问题虚空调试 1h 并最终直接导致爆炸。

对于 $k=1$ 的情况，我们发现链的端点一定是来源方向的边，其他边任意。方案数就显然了：$\prod_{i=1}^n(deg_i-1)!$。

对于 $k=2$ 的情况，假设两个关键边为 $x,y$，先分别计算以每个边为起点的树的数量和（其实就是 $k=1$ 的答案乘 $2$），然后我们需要考虑哪些树是算重的。由于我们要求链的起点是来源方向的边，因此 $x,y$ 之间的所有点的链的两端都固定了；其它点由于两个关键边对应点上的同一条边，答案仍然不变。于是算重的树的个数为 $\prod_{i\in S}(deg_i-2)!\prod_{i\notin S}(deg_i-1)!$，其中 $S$ 是 $x,y$ 之间的点的集合。

对于 $k$ 更大的情况，我们发现，若一棵树被边集 $S$ 里的关键边同时算重，则 $S$ 内的边一定形成在同一条链内。否则一定会存在一个点，要求其至少三条邻边都在链的端点。这是不合法的。基于这个性质，我们只需要**枚举任意两个关键边，使得它们之间没有关键边**，然后计算同时被这两个关键边算到的方案数，从总答案中减去这些方案即可。

不难发现，对于一棵这样的树，他会在初始时被算到 $|S|$ 次，然后被减去 $|S|-1$ 次，故这样的容斥是正确的。

对于第二部分的计算，我们可以设 $f_{i,0/1/2}$ 表示 $i$ 子树内无**选定的**关键边；有一个选定的关键边；有两个选定的关键边的方案数。设 $j$ 是 $i$ 的儿子转移如下：

- $f_{i,0}=\prod f_{j,0}\times (deg_i-1)!$
- 对于有一个边的情况，考察 $(i,j)$ 是否是关键边：
  - 若不是，则 $f_{i,1}\gets f_{j,1}\times \prod_{v\neq j}f_{v,0}\times (deg_i-2)!$
  - 否则，由于我们要求两个关键边之间没有其他边，则选定的关键边只能是 $(i,j)$，有 $f_{i,1}\gets \prod f_{j,0}\times (deg_i-2)!$。
- 对于有两个边的情况，分下面几种情况讨论：
  - 在某个儿子内就已经完成了合并：$f_{i,2}\gets f_{j,2}\times \prod_{v\neq j}f_{v,0}\times (deg_i-1)!$。
  - 两个不同的子树内各选了一个：此时另设 $g_{0/1/2}$ 表示选了多少个的方案数，根据每条边是否是关键边以及选不选讨论，做背包合并即可，有 $f_{i,2}\gets g_2$。
  - 选了某个关键边 $(i,j)$，另一个在 $j$ 的子树内：此时有 $f_{i,2}\gets f_{j,1}\times \prod_{v\neq j}f_{v,0}\times (deg_i-1)!$。

通过预处理 $\prod f_{j,0}$ 可以做到 $O(\log n)$，瓶颈在求逆元。总复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define lowbit(i) (i&-i)
#define int long long
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=1e5+5,inf=(ll)1e18+7,mo=1e9+7;
void read(int &p){
    int w=1,x=0;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    p=w*x;
}
int T;
int n,m;
vector<pii>e[N];
int deg[N],jc[N],qj[N],f[N][3],g[3];
int quick_power(int base,int x){
    int res=1;
    while(x){
        if(x&1)res*=base,res%=mo;
        base*=base,base%=mo;
        x>>=1;
    }
    return res;
}
bool imp[N];
void dfs(int x,int p){
    int prod=1,sum2=0;
    for(auto j:e[x])
        if(j.fir!=p)dfs(j.fir,x),prod*=f[j.fir][0],prod%=mo;
    rep(i,0,2)
        f[x][i]=g[i]=0;
    g[0]=1;
    f[x][0]=prod*jc[deg[x]-1]%mo;
    for(auto j:e[x]){
        if(j.fir==p)continue;
        int inv0=quick_power(f[j.fir][0],mo-2);
        if(deg[x]>=2){
            if(imp[j.sec])f[x][1]++,f[x][1]%=mo;
            else f[x][1]+=f[j.fir][1]*inv0%mo,f[x][1]%=mo;
        }
        repp(k,2,0){
            g[k]=g[k]*f[j.fir][0]%mo;
            if(k){
                if(imp[j.sec])g[k]+=g[k-1]*f[j.fir][0]%mo;
                else g[k]+=g[k-1]*f[j.fir][1]%mo;
            }
            g[k]%=mo;
        }
        if(imp[j.sec])f[x][2]+=f[j.fir][1]*inv0%mo,f[x][2]%=mo;
        sum2+=f[j.fir][2]*inv0%mo,sum2%=mo;
    }
    f[x][2]*=prod*jc[deg[x]-1]%mo,f[x][2]%=mo;
    if(deg[x]>=2){
        f[x][1]*=prod*jc[deg[x]-2]%mo,f[x][1]%=mo;
        f[x][2]+=g[2]*jc[deg[x]-2]%mo;
    }
    if(e[x].size()>=2||x==1)f[x][2]+=sum2*prod%mo*jc[deg[x]-1],f[x][2]%=mo;
}
void solve(){
    read(n),read(m);
    rep(i,1,n)
        deg[i]=0,e[i].clear(),imp[i]=0;
    rep(i,1,n-1){
        int x,y;
        read(x),read(y);
        e[x].push_back(mp(y,i)),e[y].push_back(mp(x,i));
        deg[x]++,deg[y]++;
    }
    rep(i,1,m){
        int x;
        read(x),imp[x]=1;
    }
    int ans=1;
    rep(i,1,n)
        ans*=jc[deg[i]-1],ans%=mo;
    ans*=m,ans%=mo;
    dfs(1,0);
    ans=ans+mo-f[1][2],ans%=mo;
    printf("%lld\n",ans);
}
int cid;
signed main(){
    jc[0]=qj[0]=1;
    rep(i,1,100000)
        jc[i]=jc[i-1]*i%mo,qj[i]=quick_power(jc[i],mo-2);
    read(cid),read(T);
    while(T--)
        solve();
    return 0;
}
```

---

## 作者：irris (赞：7)

## Preface

差点以为要活不下去了。

还好，调出来了。

## Solution

以 $(x, y)$ 代指 $x, y$ 两个点之间的连边，$d_u$ 表示点 $u$ 的度数。

首先固定一个 $u$，考虑所有边 $(u, v)$ 组成的集合 $S_u$。我们提取出这棵 边-生成树 关于点集 $S_u$ 的导出子图，注意到：**这张导出子图是一条链**。

证明是容易的。首先我们知道，假如有一条边 $(x, u)$ 第一次访问了 $u$，如果点 $u$ 的度数不为 $1$，显然我们可以将 $(x, u)$ 改为某个 $(u, y)$ 继续 DFS 向下。在 $(u, y)$ 子树内其它点遍历完后，回溯到 $(u, y)$ 处时，又会接着在点 $u$ 处遍历其它边，比如说 $(u, z)$。

此外，如果我们额外记录一下每条边被 DFS 到的顺序，那么链上的这个顺序是单调的，也就是 **链的某一端最先被访问**。这一端，不妨设为 $(u, v)$，即表明，

- 要么：$(u, v)$ 是初始边，
- 要么：以 $u$ 为根时，初始边的两个端点均在 $v$ 的子树内。

容易证明，若给定了一条初始边，只要对于每个 $1 \leq u \leq n$ 其邻边导出子图均为链结构，且其中一端指向初始边，那么就是一种合法的 DFS 序。

根据这个结论，我们已经可以做 $k = 1$ 了。

因为一条链有两个端点，所以一个点 $u$ 相当于 **能确定 $\bm{\min(d_u, 2)}$ 个方向内有初始边**，设它确定的边集为 $S_u$。我们只需要 $S_1 \cap S_2 \cap \dots \cap S_n$ 内，包含 $k$ 条特殊边中的任意一个，这便是一个符合要求的方案。事实上对于每个点 $u$，我们也最多需要两个 $v$，所以其它的边可以在链中任意排列，答案乘上系数 $\prod_{i=1}^n \max(d_u - 2, 0)!$ 即可。

这样，直接暴搜，就得到了一个非常好写的对拍。

考虑优化，不难想到 dp：$f_{u, 0/1, 0/1}$ 表示，考虑到点 $u$，当前点 $u$ 子树内 $S$ 的并是 / 否包含 $u$ 子树外的所有边；当前点 $u$ 子树内 $S$ 的并是 / 否包含点 $u$ 子树内的任何特殊边。

~~转移需要巨量讨论，先不写了。等我拿到解码的压缩包再写。~~ 其实还没拿到，但是先写一下。

假设 $u \neq 1$，$u = 1$ 时只需要做一点小小的修改即可。

### Case 1：$u$ 的一个方向向上，一个方向向下

- 枚举向下方向的儿子 $v$，和状态 $U \in \{0, 1\}, D \in \{0, 1\}$，令 $t_v$ 表示 $(u, v)$ 是否为特殊边，那么

$$f_{u, U, D \lor (U \land t_v)} \gets^+ f_{v,U,D} \cdot \prod_{x \in son(u), x \neq v} (f_{x,1,0} + f_{x,1,1})$$

实际实现中，可能需要用到逆元。如果对于某个 $x$ 有 $f_{x,1,0} + f_{x,1,1} = 0$，说明有贡献的 $v$ 必定为 $x$，于是剩下的部分就平凡了；否则，可以安全使用逆元。

### Case 2：$u$ 的两个方向均向下

这时的所有值都贡献给 $f_{u, 0, 1}$，省去这一部分。

枚举 $u$ 的两个儿子 $v, w$，枚举 $v, w$ 的状态。合法当且仅当两个状态都向上，且 $(u, v)(u, w)$ 中存在特殊边；或一个状态向上，一个状态向下。可以得到 

$$[t_v \lor t_w]f_{v,1,0}f_{w,1,0} + f_{v,1,0}(f_{w,0,1} + f_{w,1,1}) + f_{v,0,1}(f_{w,1,0} + f_{w,1,1}) + f_{v,1,1}(f_{w,1,0} + f_{w,0,1} + f_{w,1,1}) \cdot \prod_{x \in son(u), x \neq v, x \neq w} (f_{x,1,0} + f_{x,1,1})$$

将其优化是简单的，上述式子中已经将 $v, w$ 整理，只需要钦定 $w$ 的访问顺序在 $v$ 前，对每个含 $w$ 的部分维护一个当前的前缀和即可。

实际实现中，可能需要用到逆元。如果对于某个 $x$ 有 $f_{x,1,0} + f_{x,1,1} = 0$，说明有贡献的 $v, w$ 中必定有一个为 $x$，于是剩下的部分就平凡了；否则，可以安全使用逆元。

时间复杂度 $\mathcal O(Tn(\log n + \log p))$。

---

## 作者：lsj2009 (赞：6)

## Problem

较复杂，详见原题。

## Solution

**闲话：**

考场上写出了本题 $\mathcal{O}(n+k^2)$ 的做法，然而因为一些细节并没有调出来，最后估计只能过 $k=1$，$k=2$ 不一定能拿几分，，，

看起来像是在题解区中 **唯一和 dp 无关的做法**！并且 **代码非常简洁**！（去除码头和 Modint，仅有 **不到 1.8KB**！）

### Part 1：$k=1$

手摸一下可以发现 **在原树上所有和一个点 $u$ 有关的边 $(u,v_1),(u,v_2),\cdots,(u,v_k)$ 在新树上恰好是一条链** $(u,v_{p_1})\to (u,v_{p_2})\to \cdots \to(u,v_{p_k})$。

考虑以一条边 $(x,y)$ 开始 dfs 会有什么限制。我们考虑先 cut 掉这条边，然后分别拿出两棵分别以 $x,y$ 为根的树，这样子边就有方向。

我们发现其实对于边遍历顺序的唯一约束就是对于形如 $x\to y\to z$，得要求 $(x,y)$ 必须在 $(y,z)$ 之前。进一步考虑 $x\to y\to \{z_1,z_2,\cdots,z_k\}$ 就是要求 **$(x,y)$ 必须是这 $k+1$ 个点组成的链上的第一个点**，而剩下 $k$ 个点就可以任意排列。

注意到对于 $k=1$，每个点恰好会受到一个这样子的约束，那么答案就是 $t=\prod\limits_{i=1}^n (deg_u-1)!$，其中 $deg_u$ 是 $u$ 的度数。

### Part 2：$\mathcal{O}(n+k^2)$

考虑 $k>1$。我们定义符合第 $i$ 个条件的树组成的集合是 $T_i$，则答案就是

$$
\left|\bigcup_{i=1}^{k} T_i\right| 
$$

容斥：

$$
\begin{aligned}
& \left|\bigcup_{i=1}^{k} T_i\right|\\
= & \sum\limits_{S\subseteq\{1,2,\cdots,k\}} (-1)^{|S|-1}\left|\bigcap_{i\in S} T_i\right|\\
= & kt-\sum\limits_{S\subseteq\{1,2,\cdots,k\},|S|>1} (-1)^{|S|}\left|\bigcap_{i\in S} T_i\right|\\
\end{aligned}
$$

考虑如何计算若干个约束的交集大小。我们不妨先只考虑 $|T|=2$ 的情况，我们发现似乎再根据前面“某条边必须是一个链上的第一条边”这个约束必然无解！但这显然是错的。

**关键在于其实链不是有向的，而是无向的**，也就是这个“某条边”不一定是打头的，也可以是结尾的（只需要是一个端点即可）！

根据这个观察，我们 **发现 $S$ 在树上必须位于一条链上**（否则考虑分叉的那个点，至少会有三条边对他产生约束，一条链怎么可能有三个端点呢？？？）

设树上极小的覆盖 $S$ 的链为 $\operatorname{path}(S)$（如果不存在说明 $S$ 对答案贡献就是 $0$），**注意这里的链是开的**，也就是其实他是不含两个端点的，因为这两个端点其实是只受到了一条边的约束，而在 $\operatorname{path}(S)$ 的点收到了两个约束。

也就是：

$$
\begin{aligned}
& \left|\bigcup_{i=1}^{k} T_i\right|\\
= & kt-\sum\limits_{S\subseteq\{1,2,\cdots,k\},|S|>1} (-1)^{|S|}\left|\bigcap_{i\in S} T_i\right|\\
= & kt-\sum\limits_{S\subseteq\{1,2,\cdots,k\},|S|>1} (-1)^{|S|}\left(t\prod\limits_{i\in \operatorname{path}(S)} \left(\frac{deg_i-2}{deg_i-1}\right)\right)
\end{aligned}
$$

**注意到 $\operatorname{path}(S)$ 其实之和链上两个端点对应的边有关**，剩下的点选不选值都是一样的，记为 $(u_1,v_1),(u_2,v_2)$，在 $\operatorname{path}(S)$ 上的关键边集合设为 $\operatorname{key}(S)$，则答案即为：

$$
\begin{aligned}
& \left|\bigcup_{i=1}^{k} T_i\right|\\
= & kt-\sum\limits_{S\subseteq\{1,2,\cdots,k\},|S|>1} (-1)^{|S|}\left(t\prod\limits_{i\in \operatorname{path}(S)} \left(\frac{deg_i-2}{deg_i-1}\right)\right)\\
= & kt-\sum\limits_{1\le i<j\le k}(-1)^2\left(t\prod\limits_{i\in \operatorname{path}(e_i\to e_j)} \left(\frac{deg_i-2}{deg_i-1}\right)\right)\left(\sum\limits_{S\subseteq\operatorname{key}(e_i\to e_j)}(-1)^{|S|}\right)\\
= & kt-\sum\limits_{\substack{1\le i<j\le k\\\operatorname{key}(e_i\to e_j)=\emptyset}}\left(t\prod\limits_{i\in \operatorname{path}(e_i\to e_j)} \left(\frac{deg_i-2}{deg_i-1}\right)\right)\\
\end{aligned}
$$

最后两行用到了 $\sum\limits_{T\subseteq S} (-1)^{|T|}=[S=\emptyset]$。

里面那个 $\prod$ 以及判断 $\operatorname{key}(e_i\to e_j)=\emptyset$ 可以树上前缀和算。

这样子我们已经拥有了一个 $\mathcal{O}(n+k^2)$ 的做法（忽略了求 lca 和逆元的复杂度）。

[code link](https://www.luogu.com.cn/record/192168168)。

### Part 3：$\mathcal{O}(n+k)$

先继续来分析上面那个做法的具体细节。

**需要注意的是，由于边点转换带来的影响，下面很多文字描述是并不准确，只是说个大概，详细的还请看代码。**

对于树上前缀和，记：
- $f_u=\prod\limits_{x\in (1\to u)} (deg_u-1)!$。
- $g_u=\prod\limits_{x\in (1\to u)} \max(deg_u-2,0)!$。**注意这里为啥要对 $0$ 取 $\max$，因为根节点的 $deg$ 可能是 $1$**，我们做树上前缀和的时候如果判断成 $0$ 就爆了！！！场上就是因为这个没调出来！！！

考察满足 $\operatorname{key}(u\to v)=\emptyset$ 的点对 $(u,v)$ 对答案贡献的形式（记 $\operatorname{lca}(u,v)=x$）：

$$
t\times \frac{f_x\times f_{fa_x}}{f_u\times f_v}\times \frac{g_u\times g_v}{g_x\times g_{fa_x}}
$$

前面那部分是把原来路径上 $(deg_u-1)!$ 扣掉，后面是把 $(deg_u-2)!$ 加上。

整理成：

$$
t\times \frac{f_x\times f_{fa_x}}{g_x\times g_{fa_x}}\times \frac{g_u}{f_u}\times \frac{g_v}{f_v}
$$

套路地，我们考虑钦定 $x$ 来计算贡献。不妨记录 $h_u=\sum\limits_{\substack{(v,w)\text{is key}\\\operatorname{key}(v\to u)=\emptyset}} \frac{f_v}{g_v}$，这其实是在做一个 **子树和**，每次汇总上来是简单的。

则 $\operatorname{lca}(u,v)=x$ 的贡献就是（记 $x$ 儿子集合为 $p_1,p_2,\cdots p_m$）：

$$
\frac{f_x\times f_{fa_x}}{g_x\times g_{fa_x}}\sum\limits_{i=1}^m h_{p_i}\sum\limits_{j=i+1}^m h_{p_j}
$$

后面那两个 $\sum$ 的计算就非常简单了。当然还需要特殊处理 $(x,u)$ 这种点对的情况，详见代码。

总复杂度 $\mathcal{O}(n+k)$（忽略求逆元复杂度）。

## Code

```cpp
#include<bits/stdc++.h>
// #define int long long
// #pragma GCC optimize(3,"Ofast","inline")
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ll long long
#define bint __int128
#define ull unsigned long long
#define uint unsigned int
#define ld double
#define PII pair<int,int>
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
#define pcnt(x) __builtin_popcount(x)
#define lg(x) (31-__builtin_clz(x))
using namespace std;
void file_IO() {
    freopen("traverse.in","r",stdin);
    freopen("traverse.out","w",stdout);
}
bool M1;
const int INF=0x3f3f3f3f;
const ll INFLL=0x3f3f3f3f3f3f3f3f;
const ld eps=1e-9;
template<int p>
struct mint {
	int x;
	mint() {
		x=0;
	}
	mint(int _x) {
		x=_x;
	}
	friend mint operator + (mint a,mint b) {
		return a.x+b.x>=p? a.x+b.x-p:a.x+b.x;
	}
	friend mint operator - (mint a,mint b)  {
		return a.x<b.x? a.x-b.x+p:a.x-b.x;
	}
	friend mint operator * (mint a,mint b) {
		return 1ll*a.x*b.x%p;
	}
	friend mint operator ^ (mint a,ll b) {
		mint res=1,base=a;
		while(b) {
			if(b&1)
				res*=base;
			base*=base; b>>=1;
		}
		return res;
	}
	friend mint operator ~ (mint a) {
		return a^(p-2);
	}
	friend mint operator / (mint a,mint b) {
		return a*(~b);
	}
	friend mint & operator += (mint& a,mint b) {
		return a=a+b;
	}
	friend mint & operator -= (mint& a,mint b) {
		return a=a-b;
	}
	friend mint & operator *= (mint& a,mint b) {
		return a=a*b;
	}
	friend mint & operator /= (mint& a,mint b) {
		return a=a/b;
	}
	friend mint operator ++ (mint& a) {
		return a+=1;
	}
	friend mint operator -- (mint& a) {
		return a-=1;
	}
};
const int MOD=1e9+7;
#define mint mint<MOD>
const int N=1e5+5;
int head[N],deg[N],len;
struct node {
    int to,w,nxt;
}; node edge[N<<1];
void add_edge(int u,int v,int w) {
    edge[++len]={v,w,head[u]}; head[u]=len;
    ++deg[v];
}
mint pre1[N],pre2[N],ipre1[N],ipre2[N],tot,jc[N],res;
void init(int n=1e5) {
    jc[0]=1;
    rep(i,1,n)
        jc[i]=jc[i-1]*i;
}
bool used[N];
int pre3[N],a[N],b[N],c[N],n,k,pa[N];
void dfs(int u,int fa) {
    pa[u]=fa;
    pre1[u]=pre1[fa]*jc[deg[u]-1];
    pre2[u]=pre2[fa]*(deg[u]>1? jc[deg[u]-2]:1);
    for(int i=head[u];i;i=edge[i].nxt) {
        int v=edge[i].to,w=edge[i].w;
        if(v!=fa) {
            pre3[v]=pre3[u]+(int)used[w];
            dfs(v,u);
        }
    }
}
mint f[N],g[N];
void dfs1(int u) {
    f[u]=g[u]=0;
    for(int i=head[u];i;i=edge[i].nxt) {
        int v=edge[i].to,w=edge[i].w;
        if(v!=pa[u]) {
            dfs1(v);
            if(used[w]) {
                res-=tot*f[v]*pre1[u]*ipre2[u];
                g[v]=pre2[u]*ipre1[u];
            } else
                g[v]=f[v];
            f[u]+=g[v];
        }
    }
    mint t=f[u];
    for(int i=head[u];i;i=edge[i].nxt) {
        int v=edge[i].to;
        if(v!=pa[u]) {
            t-=g[v];
            res-=tot*t*g[v]*pre1[u]*pre1[pa[u]]*ipre2[u]*ipre2[pa[u]];
        }
    }
}
void solve() {
    scanf("%d%d",&n,&k);
    rep(i,1,n) {
        head[i]=deg[i]=0;
        used[i]=false;
    }
    len=0;
    rep(i,1,n-1) {
        scanf("%d%d",&a[i],&b[i]);
        add_edge(a[i],b[i],i);
        add_edge(b[i],a[i],i);
    }
    rep(i,1,k) {
        scanf("%d",&c[i]);
        used[c[i]]=true;
    }
    pre1[0]=pre2[0]=1;
    dfs(1,0);
    rep(i,0,n) {
        ipre1[i]=~pre1[i];
        ipre2[i]=~pre2[i];
    }
    tot=1;
    rep(i,1,n)
        tot*=jc[deg[i]-1];
    res=k*tot;
    dfs1(1);
    printf("%d\n",res.x);
}
bool M2;
// g++ traverse.cpp -std=c++14 -Wall -O2 -o traverse
signed main() {
    file_IO();
    int _,testcase=1;
    init();
    scanf("%d%d",&_,&testcase);
    while(testcase--)
        solve();
    debug("used time = %dms\n",(signed)(1000*clock()/CLOCKS_PER_SEC));
    debug("used memory = %dMB\n",(signed)((&M1-&M2)/1024/1024));
    return 0;
}
```

---

## 作者：xuanxuan001 (赞：5)

做法好像不太一样，发篇题解。

dfs 树没有横向边，所以每个点周围的所有边在新树上的这些点一定是祖先关系，继续画一下发现一定是一条连续的链。

由于最终要对无根树统计，所以可以认为是每个点周围的这些边要按某个顺序连接成一条链。接着发现这条链中间是怎么样的并不重要，会对这个方案是否合法造成影响的其实就是两个端点是什么。因此可以直接对这个进行统计，之后将答案乘上 $\prod (d_i-2)!$ 即可，$d_i$ 是点 $i$ 的度数。下设点 $u$ 周围的边中被选做端点的两条边是 $A_u$ 和 $B_u$，并且只有在 $d_u = 1$ 时会出现 $A_u = B_u$ 的情况。

考虑限制，如果要从边 $s$ 开始的话，那么 $s$ 一定在它连接的两个节点中都是端点的边之一，进一步推广，以 $s$ 连接的这两个点分别为根 dfs，那么每个点 $u$ 连向父亲的边一定是 $A_u$ 或 $B_u$。相当于确定了一个端点（不用管它是哪个）而另一个端点可以任选，因此方案数一直是 $d_u - 1$。

但枚举 $s$ 显然会算重，而考虑限制祖先的边不合法也不太行，因为上面可能就没有被标记的边。

这时考虑如果需要保证两条边 $s,t$ 都能作为起始边会是什么情况。那么此时它们之间的这个路径上的点的两个端点都被确定了，因为以 $s,t$ 为起始时它们的父亲边不一样，而其他的点依然一样只被确定一个。

这时继续推广，比如说边 $s$，考虑它远离边 $t$ 方向的节点 $v$，那么在 $v$ 上 $s$ 一定是端点之一，考虑另一个端点，发现它一定也可以作为起始边，那么可以将 $s$ 改为这个边，然后不断推广，这样最终会推到 $s,t$ 都是连接着一个叶子的边为止。而这两个叶子之间的路径上的所有边恰好就是可以作为起始边的集合，路径上的点的两端点都被确定，而其他点只被确定一个。

因此，枚举最终的这个路径，满足路径上有至少一个被标记的边即可统计答案。枚举其中一个端点并 dfs 即可做到 $O(n^2)$。

但显然可以优化，考虑找到一个 $d_u > 1$ 的点 $u$ 作为根，把 $n = 2$ 特判掉就行。这时树形 dp，在合并的时候就可以更新跨子树的答案。

具体的，设 $dp_{u,0/1}$ 表示从 $u$ 向下到某个叶子并且有/没有被标记的边的点权乘积的和。转移就考虑 $u$ 的每个儿子 $v$，如果这条边被标记了就将 $0$ 上的答案全部改到 $1$ 上即可，合并的过程中就可以更新 LCA 在 $u$ 上的所有路径的答案。

感觉是很优雅的思路，主要是前面的结论很巧妙，但感觉用文字很难讲清楚。

---

## 作者：_fairytale_ (赞：5)

## 前言

来点魔怔点分治做法。

考场上最后五分钟胡出 $k=1$ 做法，没测大样例就结束了，最后发现一个地方没取模。在重做这题的时候模数又写成 $998244353$，我真无敌了。

## 观察性质

首先 $k=1$ 的答案是 $P=\prod_u (deg_u-1)!$。这是因为，当我们第一次走到与点 $u$ 相连的边时，我们还剩下 $(deg_u-1)$ 条边可以走，而它们的顺序是可以任意排的。

接下来我们容斥，用 $k\times P$ 减掉算重的。

我们先尝试研究，新图的 dfs 树有什么样的性质。

**性质 1：原树中交于同一点的边在 dfs 树中必然是一条连续的链。**

![](https://cdn.luogu.com.cn/upload/image_hosting/8qcxwk3o.png)

这是因为，如果 dfs 过程中从当前蓝边进入了其他子树，那么不可能通过它们回到蓝边，所以只能把其他蓝边作为当前蓝边在 dfs 树上的儿子继续遍历。

我们记这种链为“特殊链”。

这个性质告诉我们：一条边可以作为根生成某棵 dfs 树的充要条件是这条边是所有包含它的特殊链的端点；在交于同一点的边中，最多有两条可以同时作为根生成同一棵 dfs 树。

**性质 2：若两条边可以作为根生成同一棵 dfs 树，那么原树中这两条边之间的所有边都可以作为根生成这棵 dfs 树。**

![](https://cdn.luogu.com.cn/upload/image_hosting/640sf036.png)

这是因为，当蓝边作为根时，那么必然从蓝边进入 $1$ 号点，从绿边进入 $2$ 号点，从橙边进入 $3$ 号点，也就是说，蓝边、绿边、橙边分别是 $1,2,3$ 号点的特殊链的一个端点。同理，当红边作为根时，红边、橙边、绿边分别是 $3,2,1$ 号点的特殊链的一个端点。红边，蓝边是我们钦定的根，而绿边，橙边同时作为包含它们的两条特殊链的端点，所以它们也是这棵 dfs 树的根。

因此，我们可以总结出，如果一个边集中的边可以同时作为根生成某棵 dfs 树，那么它们在原树中的虚树必须是一条链。因为假如不是，虚树中必定存在一个 $\ge 3$ 度点，与“在交于同一点的边中，最多有两条可以同时作为根生成同一棵 dfs 树”矛盾。

## $\mathcal O(nk^2)$ 的做法

我们由此得到了一个 $\mathcal O(nk^2)$ 的做法：

我们枚举一对关键边，满足它们之间没有其它关键边，计算同时以这一对边为根的 dfs 树的数量，然后减掉。这样做的正确性在于，考虑一棵 dfs 树，它能被 $m$ 条关键边作为根生成出来，这 $m$ 条关键边形成了一条链，我们一开始把这棵树算了 $m$ 次，而这样做把它减掉了 $(m-1)$ 次。

如何计算同时以某对边为根的 dfs 树的数量？设在这对边之间的点（不包括两个相距最远的点）构成的点集为 $S$，对于某个 $u\in S$，它的特殊链的两个端点都被固定，所以只能将相连的 $(deg_u-2)$ 条边的顺序任意重排，因此答案为 $\prod_{u\in S}(deg_u-2)!\prod_{u\notin S}(deg_u-1)!=\dfrac{P}{\prod_{u\in S}(deg_u-1)}$。

## 优化

我觉得 DP 写起来很麻烦啊！！！注意到我们要计算的问题是树上满足条件的路径的贡献之和，不难想到点分治。

考虑把当前重心 $u$ 拉出来当根，计算所有包含 $u$ 的路径的贡献。注意这里的路径为了不算漏，包括了这对边相距最远的那一对点，但是计算 $\sum\dfrac{1}{deg-1}$ 的时候不要算上。

设 $u$ 的儿子为 $v_1\dots v_c$，讨论 $u$ 是否作为端点：

- 若 $u$ 为端点，则 $(u,v)$ 需要为关键边，另一条关键边需要出现在 $v$ 的子树中，可以通过一次 dfs 求出。
- 若 $u$ 不为端点，则两条关键边分属不同的子树，我们只需计算 $f_v$ 表示 $u$ 到 $v$ 子树中所有满足以出现过的第一条关键边结束的路径中点的 $\dfrac{1}{deg-1}$ 之和，同时维护 $f$ 的前缀和 $pre$，每次让 `sum+=f[v]*pre,pre+=f[v]` 即可。

时间复杂度 $\mathcal O(Tn\log n)$，我的点分治被卡常了，去掉找到重心后重新计算 $siz$ 就过了（

```cpp
#include<bits/stdc++.h>
bool Mst;
#define ll long long
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define rep(x,qwq,qaq) for(int x=(qwq);x<=(qaq);++x)
#define per(x,qwq,qaq) for(int x=(qwq);x>=(qaq);--x)
using namespace std;
#define m107 1000000007
template<class _T>
void ckmax(_T &x,_T y) {
	x=max(x,y);
}
int ri() {
	int x;
	cin>>x;
	return x;
}
#define inf 0x3f3f3f3f
#define mod m107
template<int MOD>
struct modint{
    int x;
    modint(){x=0;}
    template<typename T>
    int norm(T y){return (y%MOD+MOD)%MOD;}
    template<typename T>
	modint(T y){x=norm(y);}
	friend modint operator +(modint a,modint b){return a.x+b.x;}
	friend modint operator -(modint a,modint b){return a.x-b.x;}
	friend modint operator *(modint a,modint b){return 1ll*a.x*b.x;}
	modint& operator +=(modint b){return x=norm(x+b.x),*this;}
	modint& operator -=(modint b){return x=norm(x-b.x),*this;}
	modint& operator *=(modint b){return x=norm(1ll*x*b.x),*this;}
	friend istream& operator >>(istream&is,modint &x){
		ll v;
		return is>>v,x.x=norm(v),is;
	}
	friend ostream& operator <<(ostream&os,modint &x){
		return os<<x.x,os;
	}
};
using mint=modint<m107>;
mint inv(int v) {
	auto exgcd=[&](auto &exgcd,int a,int b,int &x,int &y)->int {
		if(b==0)return x=1,y=0,a;
		int g=exgcd(exgcd,b,a%b,y,x);
		y-=a/b*x;
		return g;
	};
	int x,y,g=exgcd(exgcd,v,mod,x,y);
	assert(g==1);
	return x;
}
mint fac[101000],iv[101000];
void Solve_() {
	int n,k;
	cin>>n>>k;
	vector<int>deg(n+1);
	vector<pii>G(n+n+2);
	vector<int>bg(n+1),ed(n+1);
	{
		vector<vector<pii>>g(n+1);
		for(int i=1,u,v; i<=n-1; ++i) {
			cin>>u>>v;
			g[u].pb({v,i}),g[v].pb({u,i});
			++deg[u],++deg[v];
		}
		int cnt=0;
		rep(i,1,n) {
			bg[i]=cnt+1,ed[i]=bg[i]+deg[i]-1;
			for(pii t:g[i])G[++cnt]=t;
		}
	}
	vector<int>e(n+1);
	rep(i,1,k)e[ri()]=1;
	mint P=1,ans=k;
	rep(i,1,n)P*=fac[deg[i]-1];
	ans*=P;
	vector<int>siz(n+1),vis(n+1);
	int rt,maxp;
	auto getrt=[&](auto &getrt,int u,int in,int s,int &maxp)->void {
		siz[u]=1;
		int nw=0;
		rep(j,bg[u],ed[u]) {
			int v=G[j].fi,i=G[j].se;
			if(i==in||vis[v])continue;
			getrt(getrt,v,i,s,maxp);
			siz[u]+=siz[v];
			ckmax(nw,siz[v]);
		}
		ckmax(nw,s-siz[u]);
		if(nw<maxp)rt=u,maxp=nw;
	};
	auto calc=[&](int u,int in)->mint {
		mint res=0;
		auto dfs=[&](auto &dfs,int u,int in,mint prd)->void{
			if(e[in])return void(res+=prd);
			prd*=iv[deg[u]-1];
			rep(j,bg[u],ed[u]) {
				int v=G[j].fi,i=G[j].se;
				if(i==in||vis[v])continue;
				dfs(dfs,v,i,prd);
			}
		};
		dfs(dfs,u,in,1);
		return res;
	};
	auto calc2=[&](int u)->mint {
		mint res=0;
		auto dfs=[&](auto &dfs,int u,int in,mint prd)->void{
			if(e[in])return void(res+=prd);
			prd*=iv[deg[u]-1];
			rep(j,bg[u],ed[u]) {
				int v=G[j].fi,i=G[j].se;
				if(i==in||vis[v])continue;
				dfs(dfs,v,i,prd);
			}
		};
		dfs(dfs,u,0,1);
		return res;
	};
	auto solve=[&](auto &solve,int u)->void {
		getrt(getrt,u,0,siz[u],maxp=inf);
		vis[u=rt]=1;
		mint sum=0,pre=0;
		rep(j,bg[u],ed[u]) {
			int v=G[j].fi,i=G[j].se;
			if(vis[v])continue;
			mint f=calc(v,i);
			sum+=pre*f*iv[deg[u]-1];
			pre+=f;
			if(e[i])sum+=calc2(v);
		}
		ans-=P*sum;
		rep(j,bg[u],ed[u]) {
			int v=G[j].fi;
			if(vis[v])continue;
			solve(solve,v);
		}
	};
	siz[1]=n;
	solve(solve,1);
	cout<<ans<<'\n';
}
bool Med;
signed main() {
	fac[0]=1;
	rep(i,1,100000)fac[i]=fac[i-1]*i,iv[i]=inv(i);
	cerr<<(&Mst-&Med)/1024.0/1024.0<<" MB\n";
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int c,Testcases=1;
	cin>>c>>Testcases;
	while(Testcases--)Solve_();
	return 0;
}
```

---

## 作者：20_200 (赞：3)

### NOIP2024 T3题解

第一次在正式比赛中场切紫题，写篇题解纪念一下。

这里的原树表示题目给出的树，新树表示通过边 dfs 得到的树。

先看 $k=1$ 的情况，容易发现连接到原树同一个点的边在新树上构成一条链，其中父亲边在第一个，儿子边的顺序任意，每个儿子边下面还挂着自己的子树，于是 $k=1$ 的答案就是原树上以该关键边为根，每个点的儿子个数的阶乘的乘积。

以任意一条关键边为起点遍历，看到这个很容易想到容斥。考虑统计**钦定若干条关键边为根都合法的树**，可以发现一个点上如果连了三条或以上关键边，那么直接不存在合法的树。进一步观察发现如果存在合法的树，那么所有关键边都必须在一条链上。

现在可以开始 dp 了，设为 $y$ 的 $x$ 父节点，**注意这里 $x$ 的子树为传统意义上的子树加上 $(x,y)$ 的边**，设计如下状态：

$d_x$：$x$ 的子树外有被钦定的关键边时，节点 $x$ 的子树内的方案数。

$f_x$：$x$ 的子树外有被钦定的关键边时，子树内已经有**非零条**被钦定的关键边的所有方案的贡献之和，即 $(-1)^{子树内钦定的关键边数量}$ 之和。

$g_x$：$(x,y)$ 为被钦定的关键边时，子树内已经有的被钦定的关键边的所有方案的贡献之和。

$b_x$：$x$ 的子树内有被钦定的关键边时，子树外的方案数。

设 $son_x$ 表示 $x$ 的子节点集合，$deg_x$ 表示 $x$ 的度数。

容易推出以上三个状态的转移：

$d_x=|son_x|!\prod\limits_{i\in son_x}d_i$

$g_x=-[(x,y)为关键边](d_x+\sum\limits_{i\in son_x}\frac{f_id_x}{d_i|son_x|})$

$f_x=g_x+\sum\limits_{i\in son_x}\frac{f_id_x}{d_i|son_x|}$

$b_x=\frac{b_yd_y[(deg_y-1)!]}{d_x|son_y|!}$

初始条件为 $d_x=b_x=1$ 。

最后考虑统计答案。

注意实际的容斥系数是 $(-1)^{子树内钦定的关键边数量-1}$，所以统计答案应将对应贡献乘以 $-1$ 。

链可以分为两类，直链和弯链。

对于直链，在最高的被钦定的关键边处统计答案，所以有：

$ans\gets-g_xb_x$

对于弯链，考虑在 LCA 处统计答案，对于一个点 $x$ 的两个不同的儿子 $i,j$ 组成的**无序对**：

$ans\gets-\frac{f_if_jd_xb_x(deg_x-2)!}{d_id_j|son_x|!}$

因为 $i,j$ 独立，所以这个东西可以直接用前缀和优化。

然后就做完了。

代码不难写，细节有点多但上面基本都说了（等赛场代码发了再放）。

时间复杂度 $O(Tn\log P)$，可以预处理逆元优化到线性，~但是应该避免对程序常系数因子的考察，要是被卡了那素质真差~。

update：在 CCF 机子上过了，但是 T1 挂了 20。赛时代码在 LG 评测机上只有 56pts，以下是卡常后能 AC 的代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define pii pair<ll,ll>
#define ve vector<ll>
#define pb push_back
#define fi first
#define se second
#define mid (l+r>>1)
using namespace std;
const ll N=2e5+2,P=1e9+7;
ll T,n,m,ans,a[N],b[N],c[N],d[N],f[N],g[N],h[N],fc[N],ivf[N],iv[N],D[N];
vector<pii>e[N];
void dfs(ll x,ll y){
	d[x]=D[x]=1;
	for(pii i:e[x])
		if(i.se!=y)
			dfs(i.fi,i.se),h[x]++,
			(d[x]*=d[i.fi])%=P,(D[x]*=D[i.fi])%=P;
	(d[x]*=fc[h[x]])%=P,(D[x]*=ivf[h[x]])%=P;
	for(pii i:e[x])
		if(i.se!=y)
			(f[x]+=f[i.fi]*d[x]%P*D[i.fi]%P*iv[h[x]])%=P;
	if(c[y])a[x]=1,g[x]=(P+P-f[x]-d[x])%P,(f[x]+=g[x])%=P;
}
void Dfs(ll x,ll y){
	if(y){
		b[x]=b[y]*d[y]%P*fc[e[y].size()-1]%P*D[x]%P*ivf[h[y]]%P;
		if(a[x])(ans-=g[x]*b[x])%=P;
	}
	else b[x]=1;
	for(pii i:e[x])
		if(i.fi!=y)Dfs(i.fi,x);
	ll s=0;
	for(pii i:e[x])
		if(i.fi!=y){
			ll z=f[i.fi]*D[i.fi]%P;
			if(e[x].size()>=2)
				(ans-=z*s%P*d[x]%P*b[x]%P*ivf[h[x]]%P*fc[e[x].size()-2])%=P;
			(s+=z)%=P;
		}
}
void slv(){
	cin>>n>>m,fc[0]=ivf[0]=1,ans=0;
	for(ll i=1;i<=n;i++)
		e[i].clear(),a[i]=b[i]=c[i]=d[i]=f[i]=g[i]=h[i]=D[i]=0;
	for(ll i=1,x,y;i<n;i++)
		cin>>x>>y,e[x].pb({y,i}),e[y].pb({x,i});
	for(ll i=1,x;i<=m;i++)cin>>x,c[x]=1;
	dfs(1,0),Dfs(1,0);
	cout<<(ans+P)%P<<'\n';
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>T>>T; 
	fc[0]=iv[0]=iv[1]=ivf[0]=1;
	for(int i=2;i<N;i++)
		iv[i]=(P*P-P/i*iv[P%i])%P;
	for(int i=1;i<N;i++)
		fc[i]=fc[i-1]*i%P,
		ivf[i]=ivf[i-1]*iv[i]%P;
	while(T--)slv();
	cerr<<clock();
	return 0;
}
```

---

## 作者：不知名用户 (赞：3)

场上最后 40min 才意识到这是好做的。但是最后写一半细节不会放弃了。

### 题意

$n$ 个节点的树，选一个边开始每次选有共同的点的且未访问的边遍历，每条边对应一个点，每次把连续访问的边对应的点连接，得到 $n-1$ 个节点 $n-2$ 条边的新树。如果从给定的 $k$ 条边开始，可以得到多少个不同的新树。

### 做法

#### 64 分（48 分+特殊性质）

发现每个节点连的边在新树上对应的点之间的连边是一条链，按访问顺序从左往右连边。

$k=1$ 时，访问每个节点第一条边是固定的，其余边顺序自选，而且不难发现点之间是独立的。所以答案是 $\prod\limits_{i=1}^n(deg_i-1)!$。$deg_i$ 表示点 $i$ 的度数。

进一步看部分分，发现 $k$ 很小，于是想到容斥：给定一些边（必须有边），求有多少个新树满足可以有指定的边生成。

不难发现如果一个节点某条连边的部分（以该点为根，除去其余边对应的子树后剩下的树）有指定的边，那么这条边对应的节点在该点对应的链上是一个端点。所以答案为：$\prod\limits_{i=1}^nf(deg_i,c_i)$。$f(i,j)$ 表示 $(i-j)![j\le2]$。$c_i$ 表示 $i$ 这个点有多少个连边的部分有边。原因很显然：一条链只有两个端点。所以 $c_i>2$ 显然无解。剩下除了端点给定其余可以自由排列（显然 $c_i>0$，因为指定了一条边）。$c$ 可以一次 DFS 得出。

复杂度 $\Theta(2^kn)$ 48pts。A 性质输出 1，B 性质最多枚举两条边（方案数还要成个组合数）就 64pts 了。

#### 100 分

注意到容斥可以转成 DP，每加一条边状态值要乘 -1。考虑树形 DP：$f_x$ 表示 $x$ 子树内有边，要求 $x$ 子树外有边，此时所有情况对应的 $x$ 子树内的点的 $\prod\limits_{i\in subtree(x)} f(i,c_i)$ 乘上 -1 的边数次幂（因为要容斥）。怎么计算答案下文会说。

记录两个数组：$cf_x=\sum\limits_{i\in subtree(x)}(deg_i-1)!,cv_x=\sum\limits_{i\in subtree(x)}\frac{1}{(deg_x-1)!}$。

考虑 DP 到点 $x$，那么记入 $f_x$ 只能选一个子树有边（只选 $x$ 和那棵子树的根节点之间的边也算）。即 $f_x=\sum\limits_{i\in subtree(x)}f_icf_xcv_i\frac{(deg_x-2)!}{(deg_x-1)!}$，注意 $f_i$ 以外还要记录子树内其它点的贡献。但是如果 $(x,i)$ 是指定的 $k$ 条边，那么有三种情况：

- $i$ 子树选边 $(x,i)$ 不选
- $i$ 子树选边 $(x,i)$ 选
- $i$ 子树不选边 $(x,i)$ 选

容易发现前两个抵消了（因为有 -1 容斥系数），所以此时 $f_i$ 只有第三种情况，为 $-cf_i$。

怎么计算答案？$f_x$ 要求了子树外有边，那么要计算的就是子树外没边的。于是考虑选了一个/两个子树。

只选一个子树的贡献是 $\sum\limits_{i\in subtree(x)}f_icv_icf_1$，要记录 $i$ 子树以外的贡献。如果 $(x,i)$ 有边则 $f_i$ 视作 $-f_i-cf_i$ 注意 $f_x$ 的定义要求子树外有边，所以第一种情况不能算所以原来的 $f_i$ 不会抵消。

选两个子树 $i,j$ 的贡献是 $f_if_jcf_1cv_icv_j\frac{(deg_x-2)!}{(deg_x-1)!}$。注意到 $f_icv_i$ 可以看作整体！所以 $x$ 的贡献是 $cf_1\frac{(deg_x-2)!}{(deg_x-1)!}\prod\limits_{i,j\in subtree(x)}(f_icv_i)(f_jcv_j)$，DP 的时候动态记录 $f_icv_i$ 的前缀和不难维护！一样的，$(x,i)$ 有边时 $f_i$ 视作 $-cv_i$（一个子树内的边可以看作另一个子树外的边）。

做完！单次 $\Theta(n)$！

没看懂可以参考下面的代码，赛后花 90min 写+调的。调了很长时间是因为一直在动态调参。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 10, mod = 1e9 + 7;
vector<int>g[N];
int fac[N], inv[N], u[N], v[N], d[N], dep[N], is[N], f[N], ans, cf[N], cv[N];

int power(int a, int b)
{
	int c = 1;
	while(b)
	{
		if(b&1) c = c * a % mod;
		b >>= 1, a = a * a % mod;
	}
	return c;
}

void dfs(int x, int f)
{
	dep[x] = dep[f] + 1, cf[x] = fac[(int)g[x].size()-1], cv[x] = inv[(int)g[x].size()-1];
	for(auto j:g[x]) if(j!=f) dfs(j,x), cf[x] = cf[x] * cf[j] % mod, cv[x] = cv[x] * cv[j] % mod;
}

void dp(int x, int fa)
{
	f[x] = 0;
	int s = 0, t = 0;
	if((int)g[x].size()>1) s = fac[(int)g[x].size()-2] * cf[1] % mod * inv[(int)g[x].size()-1] % mod;
	for(auto j:g[x]) if(j!=fa) dp(j,x);
	for(auto j:g[x]) if(j!=fa)
	{
		int a = f[j];
		if(is[j]) f[j] = (-cf[j] - a) % mod;
		if(is[j]) ans = (ans + f[j] * cv[j] % mod * cf[1] % mod) % mod;
		if(is[j]) f[j] = -cf[j];
		int m = f[j] * cv[j] % mod;
		ans = (ans + s * t % mod * m % mod) % mod;
		t = (t + m) % mod;
		if(is[j]) f[j] = (-cf[j]) % mod;
		f[x] = (f[x] + f[j] * cf[x] % mod * cv[j] % mod * inv[(int)g[x].size()-1] % mod) % mod;
	}
	if((int)g[x].size()>1) f[x] = f[x] * fac[(int)g[x].size()-2] % mod;
	else f[x] = 0;
}

int Main()
{
	int n, k, i, a;
	scanf("%lld%lld", &n, &k);
	for(i=1;i<n;i++)
		scanf("%lld%lld", &u[i], &v[i]), g[u[i]].emplace_back(v[i]), g[v[i]].emplace_back(u[i]);
	dfs(1,0);
	for(i=1;i<n;i++) if(dep[u[i]]<dep[v[i]]) d[i] = v[i];else d[i] = u[i];
	for(i=1;i<=n;i++) is[i] = 0;
	for(i=1;i<=k;i++) scanf("%lld", &a), is[d[a]] = 1;
	ans = 0, dp(1,0);
	printf("%lld\n", (-ans+mod)%mod);
	for(i=1;i<=n;i++) g[i].clear();
	return 0;
}

signed main()
{
	int c, t, i;
	fac[0] = 1;for(i=1;i<=N-10;i++) fac[i] = fac[i-1] * i % mod;
	inv[N-10] = power(fac[N-10],mod-2);for(i=N-11;i>=0;i--) inv[i] = inv[i+1] * (i + 1) % mod;
	scanf("%lld%lld", &c, &t);
	while(t--) Main();
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：3)

以此题解纪念我终结在 $k\leq 2$，忘了去除中间有关键边而功亏一篑的 NOIP2024。

考虑 $k=1$ 做法，手玩一下发现对于一条起始边而言两侧是独立的，进而发现根度数最多为 $2$。以其中一侧来研究，其子节点对应的子树是按序选取的，第一个子树的顶端会被起始边连，接着这个子树完会引出一条出边到下一个子树，发现形成子问题递归，不难发现答案就是 $all=\prod_{i=1}^n(\text{deg}_i-1)!$。其中 $\text{deg}_i$ 表示点 $i$ 的度数。

考虑 $k=2$ 做法，我们发现固定了两条边之后中间连接它们的链要做到两侧尽量等价，也就是说对于中间点我们必须将连接链的边放到最后，此时记录连接这两条边的链的点集（不包含两个关键边外端点）为 $S$，此时答案为 $all\prod_{i\in S}\frac{(\text{deg}_i-2)!}{(\text{deg}_i-1)!}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/t1k0vexd.png)

可以理解一下为什么要是“等价”的，圆点代表原树上的点，方点代表原树上的边。

注意到 $k\leq 2$ 分值高达 $40$ 分，我们宣称这个与正解强相关，可以推广 $k=2$ 的做法。我们可以联想到经典的 $|V|-|E|$ 容斥。注意到三个不共链的关键点无法造成贡献，因为中间无法做到全等价（感性理解），那么有贡献的只能是共链的关键点。我们可以在每个中间无关键边的关键边对计算 $-1$ 的贡献，在每个关键点单独计入 $1$ 的贡献。那么对于一个链其贡献系数就恰好为 $1$。直接模拟该过程可以做到 $\mathcal O(nk^2)$。

考虑进一步优化，有两种优化方向。第一种是进行换根 dp，第二种是对树上路径问题直接套用点分治。本题的模型格外适合点分治，该做法细节相对较少。时间复杂度分别为 $\mathcal O(Tn)$ 以及 $\mathcal O(Tn\log n)$。需要预处理阶乘以及阶乘的逆。

---

## 作者：Union_of_Britain (赞：3)

> upd：修改转移错误。附上代码。

考场做法，思路和代码比较简易。感觉题解区没有类似的做法？转移有误请指出。

省流：设子树关键边方案和子树关键边在上侧的交集入状态。

dfs 树的意思是没有横叉边，于是一个点连出去的边构成的团必定是一条链。整个的 dfs 树就是把这些团每个选链再合法地组合起来。这些团也是构成自然的树结构。

那么考虑选定出发边合法的条件：若把这个边提到根，对于每个团记链头尾为 $u,v$，则 $u,v$ 必有一个是来自父亲团遍历的边（或者就是出发边）。

因此，在原树上把每个边挂在他的深度较大的节点上；自然地记 $h_u$ 为 $u$ 点（带来的团）及其子树在出发边在 $u$ 上侧的时候的选链方案数；设 $f_u$ 为考虑在 $u$ 的子树的出发边时，这些在 $u$ 子树选链方案的并集。那么答案即为 $f_1$。$h$ 是容易预处理的：即为子树的 $(deg-1)!$ 积。

先写出不去重（即把链视为有向）的转移：设 $p_{1:c}$ 是 $u$ 的儿子；

$$\forall i,f_{u}\gets f_u+f_{p_i}(deg_u-1)!\prod_{j\neq i}h_{p_j}$$

如果 $u$ 上面挂了关键边，还有

$$f_u\gets f_u+(deg_u-1)!\prod_i h_{p_i}$$

观察转移形式，为了去重，设 $g_u$ 是 $f_u$ 和 $h_u$ 代表集合的交集大小。去重需要去掉被正反两次计算的链，可以利用 $g$ 转移，即：

$$\forall i,f_{u}\gets f_u+f_{p_i}(deg_u-1)!\prod_{j\neq i}h_{p_j}-g_{p_i}(deg_u-2)!\sum_{j<i}g_{p_j}\prod_{k\neq i,k\neq j}h_{p_k}\\
g_{u}\gets g_u+g_{p_i}(deg_u-2)!\prod_{j\neq i}h_{p_j}
$$

如果 $u$ 上面挂了关键边，还有转移

$$
f_u\gets f_u+(deg_u-1)!\prod_i h_{p_i}-(deg_u-2)!\sum _i g_{p_i} \prod_{j\neq i} h_{p_j}\\
g_u\gets g_u+(deg_u-1)!\prod_i h_{p_i}-(deg_u-2)!\sum _i g_{p_i} \prod_{j\neq i} h_{p_j}
$$

上述转移式显然可以前缀和优化，可以做到 $O(Tn\log n)$，逆元 $\log$ 也许可以去掉。

```cpp
// Problem: P11363 [NOIP2024] 树的遍历（民间数据）
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P11363
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// UOB Koala
// 
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int maxn=2e5+5,mod=1e9+7;
int qp(int a,int b){
	if(b==0)return 1;
	int T=qp(a,b>>1);T=T*T%mod;
	if(b&1)T=T*a%mod;
	return T;
}
int c,T;
int f[maxn],g[maxn],h[maxn],n,k,deg[maxn],fac[maxn];
vector<pair<int,int> > e[maxn];
void dfs1(int u,int fa){
	h[u]=fac[deg[u]-1];
	for(auto [v,id]:e[u]){
		if(v==fa)continue;
		dfs1(v,u);
		h[u]=h[u]*h[v]%mod;
	}
}
int S[maxn],H[maxn],cs[maxn],flg[maxn];
void dfs2(int u,int fa){
	vector<int> p={0};int ch=0,fid=0;
	for(auto [v,id]:e[u]){
		if(v==fa){fid=id;continue;}
		dfs2(v,u);p.push_back(v);++ch;
	}
	S[0]=1;for(int i=1;i<=ch;i++)S[i]=S[i-1]*h[p[i]]%mod;
	H[ch+1]=1;for(int i=ch;i>=1;i--)H[i]=H[i+1]*h[p[i]]%mod;
	for(int i=1;i<=ch;i++)cs[i]=(cs[i-1]+g[p[i]]*qp(h[p[i]],mod-2))%mod;
	for(int i=1;i<=ch;i++){
		// cerr<<p[i]<<" -> "<<u<<endl;
		(f[u]+=f[p[i]]*fac[deg[u]-1]%mod*S[i-1]%mod*H[i+1])%=mod;
		if(deg[u]>1){
			(g[u]+=g[p[i]]*fac[deg[u]-2]%mod*S[i-1]%mod*H[i+1])%=mod;
			(f[u]+=mod-g[p[i]]*fac[deg[u]-2]%mod*S[i-1]%mod*H[i+1]%mod*cs[i-1]%mod)%=mod;
		}
	}
	if(flg[fid]){
		(f[u]+=fac[deg[u]-1]*S[ch])%=mod;
		(g[u]+=fac[deg[u]-1]*S[ch])%=mod;
		for(int i=1;i<=ch;i++){
			(f[u]+=mod-fac[deg[u]-2]*S[i-1]%mod*H[i+1]%mod*g[p[i]]%mod)%=mod;
			(g[u]+=mod-fac[deg[u]-2]*S[i-1]%mod*H[i+1]%mod*g[p[i]]%mod)%=mod;
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>c>>T;
	while(T--){
		cin>>n>>k;
		fac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
		for(int i=1,u,v;i<n;i++)cin>>u>>v,e[u].push_back({v,i}),e[v].push_back({u,i}),deg[u]++,deg[v]++;
		for(int i=1,x;i<=k;i++)cin>>x,flg[x]=1;
		dfs1(1,0);
		dfs2(1,0);
		// cerr<<n<<" "<<deg[1]<<endl;
		cout<<f[1]<<endl;
		for(int i=1;i<=n;i++)e[i].clear(),flg[i]=f[i]=g[i]=h[i]=deg[i]=0;
	}
	return 0;
}
```

突然发现考场上好像 `fac[deg[u]-2]` 没判 $\deg=1$，消息了！

---

## 作者：cancan123456 (赞：2)

为什么又是赛后想出来的正解？？？

首先考虑 $k=1$。设 $e_1=(u,v)$，首先你得选个子树选条边走进去吧，比如我们选 $u$ 子树内的 $(u,w)$，然后有两种操作：

1. 深入 $w$ 的子树。
2. 看一看 $u$ 其余的邻边。

我们发现，因为我们只关心树的形态，而这两种操作其实没啥区别，先 1 操作能生成的树先 2 操作也行，反之亦然。

所以我们规定先把子树探索完再看相邻的边，然后设 $f_u$ 表示当前遍历到 $u$ 连向（未确定的）$u$ 子节点的一条边，将 $u$ 子树遍历完有多少种方案，不难得到转移：

$$f_u=|\operatorname{son}(u)|!\prod_{v\in\operatorname{son}(u)}f_v$$

注意第一步先选 $u$ 子树和先选 $v$ 子树是一样的，没啥区别，所以直接算 $f_uf_v$ 就对了。

好考察一下我们刚刚建出来的树长什么样，对于 $u$ 不包含 $v$ 的所有子树中的子节点都是：

1. 有一条链串起来 $u$ 向所有子节点的边对应的节点。
2. $u$ 向父节点的边对应的节点连接到链的一个端点（不妨钦定是起点）。

所以我们考虑 $k=2$，不妨设 $v_{e_1},v_{e_2}$ 均不在从 $u_{e_1}$ 到 $u_{e_2}$ 的路径 $P$ 上。

那么我们考虑不在 $P$ 上的点，以 $e_1$ 和 $e_2$ 为起点的贡献一样，而每个在 $P$ 上的点 $u$，如果其度数为 $d_u$，画个图就发现贡献是 $(d_u-2)!$（可以理解为从在 $P$ 上的一条出边开始到另一条出边结束）。

> 考场上推出了这个做法写挂了，考后一遍过样例 4。

现在我们考虑容斥，设 $f(S)$ 为能被每一个 $S$ 中的边生成的树的数量，答案变为：

$$\sum_{\varnothing\ne S\subseteq[1,k]}(-1)^{|S|+1}f(S)$$

现在考虑怎么算 $f(S)$，首先如果 $S$ 不在一条路径上，$f(S)=0$：取 $S$ 的虚树，一定存在一个度数 $\ge3$ 的点，则这个点的邻边的顺序无论怎么安排都会出现矛盾。

现在，如果 $|S|\ge3$，那么这个 $f(S)$ 的贡献会被容斥成 $0$，所以我们只需要考虑 $|S|=1$ 和 $|S|=2$。

$|S|=1$ 的贡献就是 $k\cdot\prod_{u=1}^n(d_u-1)!$，好算。

考虑 $|S|=2$，设树上完全包含两条 $|S|$ 中的边的路径去掉端点构成路径 $P$（可能为空，此时 $S$ 中两条边共用端点），则 $f(S)=\prod_{u\notin P}(d_u-1)!\prod_{u\in P}(d_u-2)!$。

由于我们只想关注 $P$ 上的顶点，我们将 $f(S)$ 写成 $\prod_{u=1}^n(d_u-1)!\cdot\prod_{u\in P}\dfrac1{d_u-1}$，然后写个换根 DP 就做完了。

```cpp
#include <cstdio>
#include <vector>
using namespace std;
typedef long long ll;
const int N = 100005;
const ll mod = 1000000007, inv2 = 500000004;
ll fac[N], inv[N], cnt[N];
vector < pair < int, int > > G[N];
int u[N], v[N], d[N];
bool vis[N];
ll f[N], cur[N];
void dfs1(int u, int fa) {
	f[u] = 0;
	for (pair < int, int > edge : G[u]) {
		int v = edge.first, id = edge.second;
		if (v != fa) {
			dfs1(v, u);
			if (vis[id]) {
				f[u]++;
			} else {
				f[u] += f[v];
				cur[u] = (cur[u] + cnt[u] * f[v]) % mod;
			}
		}
	}
	f[u] = f[u] % mod * inv[d[u] - 1] % mod;
}
void dfs2(int u, int fa, int fa_id, ll g_fa) {
	ll g_u;
	if (vis[fa_id]) {
		g_u = (f[u] + inv[d[u] - 1]) % mod;
	} else {
		g_u = (f[u] + g_fa * inv[d[u] - 1]) % mod;
	}
	for (pair < int, int > edge : G[u]) {
		int v = edge.first, id = edge.second;
		if (v != fa) {
			ll g_v;
			if (vis[id]) {
				g_v = (g_u - inv[d[u] - 1] + mod) % mod;
			} else {
				g_v = (g_u - f[v] * inv[d[u] - 1] % mod + mod) % mod;
			}
			if (!vis[id]) {
				cur[v] = (cur[v] + cnt[v] * g_v) % mod;
			}
			dfs2(v, u, id, g_v);
		}
	}
}
int main() {
	fac[0] = fac[1] = inv[1] = 1;
	for (int i = 2; i < N; i++) {
		fac[i] = fac[i - 1] * i % mod;
		inv[i] = inv[mod % i] * (mod - mod / i) % mod;
	}
	int T;
	scanf("%*d %d", &T);
	for (int n, k; T != 0; T--) {
		scanf("%d %d", &n, &k);
		for (int i = 1; i < n; i++) {
			scanf("%d %d", &u[i], &v[i]);
			G[u[i]].push_back(make_pair(v[i], i));
			G[v[i]].push_back(make_pair(u[i], i));
			vis[i] = false;
		}
		for (int u = 1; u <= n; u++) {
			d[u] = G[u].size();
			cnt[u] = 0;
		}
		for (int e, i = 1; i <= k; i++) {
			scanf("%d", &e);
			vis[e] = true;
		}
		for (int u = 1; u <= n; u++) {
			for (pair < int, int > edge : G[u]) {
				if (vis[edge.second]) {
					cnt[u]++;
				}
			}
		}
		ll val = 1;
		for (int u = 1; u <= n; u++) {
			val = val * fac[d[u] - 1] % mod;
		}
		ll part1 = val * k % mod;
		ll sum = 0;
		for (int u = 1; u <= n; u++) {
			sum += cnt[u] * (cnt[u] - 1) % mod * inv[d[u] - 1] % mod;
			cur[u] = 0;
		}
		sum %= mod;
		dfs1(1, 0);
		dfs2(1, 0, 0, 0);
		for (int u = 1; u <= n; u++) {
			sum = (sum + cur[u] * inv[d[u] - 1]) % mod;
		}
		ll part2 = sum * val % mod * inv2 % mod;
		printf("%lld\n", (part1 - part2 + mod) % mod);
		for (int u = 1; u <= n; u++) {
			G[u].clear();
		}
	}
	return 0;
}
```

诸位，省选再见。

---

## 作者：IvanZhang2009 (赞：2)

来一个考场上半个小时不到会了但是花了将近一个小时实现的复杂做法。

这个题面看着就很吓人，把边当点连出一堆边，给定若干个特殊点作为根，求本质不同 dfs 生成树个数。乍一看好像很像 NOI2023 D1T3，但是这个题看上去有很强的特殊性质。

考虑菊花图的部分分，这相当于把边集连成完全图。经过小量手玩可以发现最终的生成树一定形如一条链。而树根的限制则相当于必然存在一个链的端点恰好是一个特殊点。因为从根遍历下去如果还没访问完所有的点则一定没访问完当前最后一个点的邻点，于是形成一条链。答案容易用容斥计算，钦定两个端点都不是特殊点即可。于是答案只和 $n,k$ 相关。

考虑一般图，建出边代表的图可以发现，这个图缩点之后大概很有性质。点双缩点之后可以发现得到了原树（把原来的点作为方点，边作为圆点得到了新图的圆方树）。同菊花一样考虑，可以发现每个点双内（即每个点周围的所有边）在生成树中一定连通且导出子图形如一条链。

考虑对于一个非叶子节点刻画它的 $dg$ 条邻边形成的链，可以发现只需要确定链的两个端点，其余的方案数是任意排布 $dg-2$ 个点的顺序，方案数 $(dg-2)!$。于是只需要对于每个点选择周围的两条边即可。

考虑一条边如何可以成为 dfs 树的根。注意到我们从根出发进入一个点双的入口是唯一的，也就是要求必须选择那条指向根的边。于是任意得到 $k=1$ 的答案，除了一条必选边其余随便选，方案数 $\prod (dg-1)$，再乘上刚才的阶乘积。

$k$ 更大的时候，我们可以考虑正难则反，求出没有一个特殊边可以作为根的情况即可。考虑树形 dp，设 $f(x,p,q)$，其中 $p,q=0,1$ 表示 $x$ 的子树内，是否存在特殊边“还没有点没指向它”，是否存在点不指向根。我们试图用背包的方式合并儿子的 dp 值以及枚举选择的两条边。

先考虑到父亲的边要选择的情况，设令一条边连接 $y$，则合并所有状态 $f(son_i,p_i,q_i)$ 可以得到的 $p=1$ 当且仅当：
- 到父亲的边是特殊边或到 $y$ 的边是特殊边。
- 且除了 $y$ 的其他儿子的 $q=0$。

得到的 $q$ 是所有儿子的 $q_i$ 的或。考虑背包合并，$g(0/1,0/1,0/1)$ 表示当前是否选择了点 $y$，以及当前合并得到的 $p,q$ 的值。

再考虑父亲的边不选择的情况，此时一定有 $q=1$，用类似上述的背包同样可以转移：$h(0/1/2,0/1,0/1)$ 表示当前钦定了的儿子个数，两个儿子是否分别满足限制。

两个转移仅仅带了一百多的常数，在 $\sum n\le 10^6$ 的情况下可以轻松通过，时间复杂度是 $O(n)$ 的。

可以发现这个做法代码超级难写，又没有代码公示，所以贴不了了。

---

## 作者：2020HZ06 (赞：1)

一点题外话：场下胡出来的，通过了民间数据。

首先把每条边建虚点，称为**方点**。原图中的点称为**圆点**。方点和圆点连边，最后形成一棵 $2n-1$ 个点的新树 $T$。关键边对应的方点称为**关键点**。

考虑 $k=1$ 怎么做。注意对于一个度数 $\ge 2$ 的**圆点** $u$，它周围连了一圈方点，称为**邻接方点**。假设**邻接方点** $v$ 是最先被遍历到的，称为**起始点**。那么根据遍历顺序的不同，共有 $(deg_u-1)!$ 种方案排列方点被遍历的顺序，也就是连边情况。因为遍历顺序中相邻的两个方点会连边。每个**圆点**的方案数乘起来就是答案了。

再考虑 $k=2$，假设 $u,v$ 是关键点。那么注意到除了 $u\to v$ 路径上的圆点，其他圆点的**起始点**在 $u,v$ 的方案中都相同。如果 $u\to v$ 路径上的方点排列也**完全**相同，那么要去掉这种**重复**的方案。

换个角度，指定起始点相当于指定了一条链的链头。如果 $u\to v$ 路径上的每个圆点的方点顺序是 $(u...p_1),(p_1...p_2),...,(p_m...v)$，那么它在 $u,v$ 的方案中都会被计算到。这里总共有 $\prod (deg_i-2)!$ 种方案，再乘上不在 $u\to v$ 路径上的圆点的 $\prod (deg_i-1)!$ 就是要去掉的部分了。

接下来如果不限制 $k$，给每个关键点编号，表示加入顺序。每次加入一个关键点 $u$ 时，它的每棵子树里都有一些关键点。$u$ 的方案**不可能**同时和两个同子树且**没有祖先-后代关系**的关键点 $v_1,v_2$ 算重。每棵子树 $i$ 的方案数就是 $w_i-w_i\sum_v\prod (deg_j-2)!w_{u,v}^{-1}=w_i(1-\sum_v\prod (deg_j-1))$。其中 $j$ 是 $v$ 到 $u$ 路径上的圆点，$w_i$ 是 $i$ 子树内 $\prod (deg_i-1)$，$w_{u,v}$ 则是 $u\to v$ 上的 $\prod (deg_i-1)$ 。这是可以做到 $O(kn)$ 的。

加点的思路似乎难以优化，不妨一起处理，树形 DP。随便找一个点作为根。令每个关键点的 DFS 序为编号。这样每个点不可能被子树内关键点贡献。

当 $u$ 本身为关键点时，直接贡献到每棵子树。否则，每棵子树会贡献到它后面的子树，递归处理即可。时间复杂度 $O(n\log \bmod)$，因为要计算逆元。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mid (l+r)/2
#define ll long long
const int N=200005;
const ll mod=1e9+7;
vector<int>v[N];
ll fac[N],s[N],f[N],c[N],w[N];
int C,t,n,k,e[N],b[N],deg[N];
ll inv(ll x){
	ll r=1,y=mod-2;
	while(y){
		if(y&1) r=r*x%mod;
		x=x*x%mod,y>>=1;
	}
	return r;
}
void dfs1(int u,int fa){
	ll mul; 
	if(u<=n&&deg[u]>=2) f[u]=fac[deg[u]-1],mul=inv(deg[u]-1);
	else f[u]=mul=1;
	ll sum=0;
	for(int i:v[u]){
		if(i==fa) continue;
		dfs1(i,u);f[u]=f[u]*f[i]%mod;
		(sum+=w[i])%=mod;
	}
	if(b[u]) w[u]=1;
	else w[u]=sum*mul%mod;
}
void dfs2(int u,int fa,ll s){
	c[u]=s;
	ll sum=0,mul;
	if(u<=n&&deg[u]>=2) mul=inv(deg[u]-1);
	else mul=1;
	for(int i:v[u]){
		if(i==fa) continue;
		dfs2(i,u,b[u]?1:(s+sum)*mul%mod);
		(sum+=w[i])%=mod;
	}
}
inline int read(){
	int x=0;
	char c;
	while((c=getchar())&&(c<'0'||c>'9'));
	x=c-'0';
	while((c=getchar())&&c>='0'&&c<='9') x=x*10+c-'0';
	return x;
}
int main(){
	int x,y;
	C=read(),t=read();
	while(t--){ 
		n=read(),k=read();
		fac[0]=1;
		for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
		for(int i=1;i<=2*n;i++) v[i].clear(),b[i]=c[i]=0;
		for(int i=1;i<n;i++){
			x=read(),y=read();
			v[i+n].pb(x),v[i+n].pb(y);
			v[x].pb(i+n),v[y].pb(i+n);
		}
		for(int i=1;i<=2*n;i++) deg[i]=v[i].size(); 
		for(int i=1;i<=k;i++){
			e[i]=read();
			b[e[i]+n]=i;
		}
		dfs1(1,0);
		dfs2(1,0,0);
		ll ans=0;
		for(int i=1;i<=2*n;i++){
			if(b[i]){
				ll res=f[i]*((f[1]*inv(f[i])%mod*(mod+1-c[i])%mod)%mod)%mod;
				(ans+=res)%=mod;
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：takanashi_mifuru (赞：1)

首先考虑一下这个 $k=1$ 的时候 搜索树会长成什么样子，容易发现大概就是，与一个点串在一起的所有边都会变成一条链。

容易发现确定了起点的边之后，对于每一条链的起点是全部确定了的，而链剩下的点的搜索顺序就随便了，所以 $k=1$ 的时候有一个优秀的做法，那就是直接把所有点的度数减一的阶乘乘起来。

然后 $k=2$ 就不能够这么做，为啥呢，因为有一种情况可能是两个关键边都能够到达的，以起点来刻画这个搜索树非常的不牛，我们考虑换一个更牛的刻画。

有的人想到，既然我们能够构造小链，那我们为什么不直接通过记录每个连痛块里面有没有关键边来计数对于每个节点能够构造出来的本质不同的链的数量呢，实际上是不行的，因为起点是限定的连续的，直接乘起来肯定不行。

起点刻画不行是因为会重复，会重复那就是因为有的链既能正着跑也能反着跑，然后你发现我们不能做的根源就是因为这条链的形态，那我们考虑把链拉下来计数。

容易发现，每个点的链是可以首尾相接在一起直到最后到度数为 $1$ 的点上，形成一条大链，这条链是否能够达成，那就相当于是询问这条链中间有没有关键边，如果有的话，对于这条大链的计数是容易的（具体地，链上节点贡献度数减二的阶乘，其余节点贡献度数减一的阶乘），而这就是本质不同的生成树个数，原因很显然，如果要重复那么必然在这条包含起点的链上重复（也就是开头和结尾搜出了重复的节点），那么我们直接对这条链计数就解决掉了这个问题。

然后具体实现就比较简单，考虑直接合并子节点状态就可以了。

---

## 作者：Coffins (赞：0)

一篇题解来记录第一道正式比赛**想**出来的紫吧。

直接跟着考场思路来讲一讲吧。

首先进行一些初步思考：某些生成树不能被生成是因为在遍历过程中你第一次遍历到某个点旁边的一条边 $e$，只能向其他这个点旁边的边连一条边。

然后就可以发现，一个点旁边的所有边在生成的树中是一条链结构，不妨称点 $u$ 旁边的链为 $L(u)$。

考虑 $k=1$ 的时候，对于一个点 $u$，在唯一关键边那一侧的边 $e_u$ 一定是 $L(u)$ 的一个端点，其它的边顺序可以随意排，于是 $k=1$ 就完成了。

然后一个很容易想到的思路是直接求每个 $L(u)$ 有多少种形态，然后直接乘起来。

然而这其实不对，因为可能存在一种 $L_0(u),L_0(v)$ 无法同时取到。

于是自然想到去做树形 dp 去解决性质问题。

不妨设 $f_u$ 表示 $u$ 子树内如果关键点在子树外可以有多少种方案数，$g_u$ 表示 $u$ 子树如果关键点在子树内有多少种方案数。

于是我写写写，然后就 WA 了。

原因也很简单，因为可能有一些方案既在 $f_u,g_u$ 中同时被取到。

于是自然想到再设一个 $h_u$ 表示既能在 $f_u$ 中算到又能在 $g_u$ 中算到的方案数。

考场在还剩 1h 的时候想到这里，按道理来讲应该能切掉。

但是出于各种原因，包括对自己做法的不自信，本身码力比较弱，因为担心又假了的紧张，以及还没有打暴力担心此题爆蛋的担忧，总之我甚至自己就觉得我的做法是错的。

然后写出来，简单 debug 又无果。

于是我更加没自信了。

最后还剩 20min 放弃了，写了 $k=1$ 跑路，因为各种原因甚至没注意到 链/菊花 等等简单部分分。

遗憾离场。

其实就是有一个地方忘记减掉算重了。

无话可说，技不如人，省选再战。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define beg begin
#define All(x) A.beg(),A.end()
#define pb(x,y) x.push_back(y)
#define fst first
#define sec second
using ull=unsigned long long;
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
using vi=vector<int>;
using gi=greater<int>;
using str=string;
using bqi=priority_queue<int>;
using lqi=priority_queue<int,vi,gi>;
using qi=queue<int>;
using si=set<int>;
const int N=1e5+5;
const int p=1e9+7;
int n,k,d[N],deg[N];
vi edge[N];int X[N],Y[N];
void dfs1(int u,int f)
{
    d[u]=d[f]+1;
    for(int v:edge[u])
    if(v^f)dfs1(v,u);
}bool tg[N];
ll fc[N],f[N],g[N],h[N];
ll ksm(ll a,ll b)
{
    ll ans=1;while(b)
    {
        if(b&1)ans=ans*a%p;
        a=a*a%p,b>>=1;
    }return ans;
}
void dfs2(int u,int fa)
{
    f[u]=1,g[u]=h[u]=0;ll s=0;
    if(fa&&deg[u]==1)
    {
        if(tg[u])g[u]=h[u]=1;
        return;
    }if(deg[u]==1)
    {
        int v=edge[u][0];dfs2(v,u);
        f[u]=f[v],g[u]=g[v],h[u]=h[v];
        return;
    }for(int v:edge[u])
    {
        if(v==fa)continue;dfs2(v,u);
        f[u]=f[u]*f[v]%p;
        h[u]=(h[u]+h[v]*ksm(f[v],p-2))%p;
        g[u]=(g[u]+g[v]*ksm(f[v],p-2))%p;
    }h[u]=h[u]*f[u]%p*fc[deg[u]-2]%p;
    g[u]=g[u]*f[u]%p*fc[deg[u]-1]%p;
    for(int v:edge[u])
    {
        if(v==fa)continue;ll iv=ksm(f[v],p-2);
        g[u]=(g[u]+p-h[v]*iv%p
        *s%p*fc[deg[u]-2]%p*f[u]%p)%p;
        s=(s+h[v]*iv)%p;
    }if(tg[u]){
    ll d=0;
    for(auto v:edge[u])
    {
        if(v==fa)continue;
        d=(d+h[v]*ksm(f[v],p-2)%p
           *fc[deg[u]-2]%p*f[u])%p;
    }d=(f[u]*fc[deg[u]-1]+p-d)%p;
    g[u]=(g[u]+d)%p,h[u]=(h[u]+d)%p;
    }f[u]=f[u]*fc[deg[u]-1]%p;
}
void solve()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    edge[i].clear(),deg[i]=tg[i]=0;
    for(int i=1;i<n;i++)
    {
        int x,y;cin>>x>>y;
        pb(edge[x],y),pb(edge[y],x);
        deg[x]++,deg[y]++;
        X[i]=x,Y[i]=y;
    }dfs1(1,0);for(int i=1;i<=k;i++)
    {
        int id;cin>>id;
        int x=X[id],y=Y[id];
        if(d[x]<d[y])swap(x,y);
        tg[x]=1;
    }fc[0]=1;for(int i=1;i<=n;i++)
    fc[i]=fc[i-1]*i%p;dfs2(1,0);
    cout<<g[1]<<'\n';
}
int main()
{
    freopen("traverse.in","r",stdin);
    freopen("traverse.out","w",stdout);
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int o,t=1;cin>>o>>t;while(t--)solve();return 0;
}

```

赛后也一度认为自己假掉了（因为没有相同思路），直到看到 Union_of_Britain 的同思路题解才重新思考，复刻一遍。

赛时因为考虑不周到所以 $f_u,g_u$ 的定义是减掉 $h_u$ 的，进一步增加了代码难度，可能也是没调出来的原因之一？总之还是菜了，希望不要再有这样的遗憾了。

---


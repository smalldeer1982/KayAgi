# [NOI2013] 树的计数

## 题目描述

我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)

现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \ldots, h_K$，那么请你输出：

$$
\frac{h_1+h_2+\ldots+h_K}K
$$

## 说明/提示

如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。

### 数据范围

- 对于 $20\%$ 的测试数据，满足：$n \le 10$；
- 对于 $40\%$ 的测试数据，满足：$n \le 100$；
- 对于 $85\%$ 的测试数据，满足：$n \le 2 \times 10^3$；
- 对于 $100\%$ 的测试数据，满足：$2 \le n \le 2 \times 10^5$。

## 样例 #1

### 输入

```
5 
1 2 4 5 3 
1 2 3 4 5
```

### 输出

```
3.500
```

# 题解

## 作者：一只绝帆 (赞：62)

### P1232 [NOI2013] 树的计数

> 定义 $\rm dfs$ 是每个点按照儿子顺序依次递归，$\rm bfs$ 是取出队首将队首的儿子加入队列。
> 
> （两种搜索的”儿子顺序“这个量已经确定。）
> 
> 给定 $\rm dfs$ 序和 $\rm bfs$ 序，求出满足二者的所有树的高度的平均数。
> 
> 保证存在一棵树满足条件。
> 
> $n\le 2\times 10^5$。

首先把平均数变成所有合法树中随一个，期望高度。

高度其实就是将 $\rm bfs$ 序分成若干段作为若干层，段数就是高度，所以就是期望分段次数 $+1$。

期望线性性拆成每个点后面分段的概率和。

先把点们重新标号，按照 $\rm bfs$ 序变为 $1\sim n$，$\rm dfs$ 序相应变化，令 $d_i$ 表示点 $i$ 什么时候被 $\rm dfs$ 到（$\rm dfs$ 序的逆排列）。

考虑 $i$ 与 $i+1$：

- 若 $d_i+1=d_{i+1}$，则 $i+1$ 可以是 $i$ 的儿子或兄弟（此时 $i$ 为叶子），没有什么限制。
- 若 $d_i+1<d_{i+1}$，则 $i+1$ 必定是 $i$ 的兄弟，因为 $\rm bfs$ 完可以立即到达但 $\rm dfs$ 去找别人了，该间隔被分段的概率是 $0$。
- 若 $d_{i}+1>d_{i+1}$，则 $i+1$ 必定与 $i$ 分层，因为 $\rm dfs$ 先走到 $i+1$ 再走到 $i$，因为儿子顺序固定所以二者不可能同层，该间隔被分段的概率是 $1$。

想象一棵树每个点的儿子都已经按照儿子顺序从左到右排好了，那么第三种情况就是走到一层的结尾，跑到了下一层的开头，只要 $x$ 所在层的前面有其他的非叶子节点，那就会导致该点的儿子先被 $\rm dfs$ 到。

而第一种情况说的是所有爷爷——父亲——独生儿子的情况 与 所有 父亲（原爷爷）——儿子 1（作为叶子，原父亲）——儿子 2（原独生儿子，不一定是叶子）的情况是对偶的，即树上所有的这两种结构可以相互转化，而不影响其他任何结构以及 $\rm dfs,bfs$ 序。

（注意后种情况仍需保证原爷爷的其他儿子顺序不变，仅仅是把原父亲这个位置换成了先”原父亲“再”原独生儿子“这个结构。）

继续发掘，你发现两序确定后唯一符合两序的调整就是该调整，进一步地讲：将这些结构全部调整为第一种形式，那考虑所有最高链上的该结构每个结构可以自由选择是否调整为第二种形式让高度减小 $1$，所以每个”不确定是否分段“的间隔实质上产生了 $0.5$ 的贡献，即两种情况各占所有合法情况的一半。

此时我们确定了一些概率，考虑接着找找条件，考虑 $x={\rm dfs}_i$ 与 $y={\rm dfs}_{i+1}$：

- 若 $x+1>y$，说明 $x>y$，也就是说情况必然为 $x$ 是某个叶子，递归完 $x$ 到了 $y$，不能得到什么有用结论。
- 若 $x+1=y$，这种就是上面的 $d_i+1=d_{i+1}$，同样考虑过了。
- 若 $x+1<y$，由于二者之间是先后递归的关系，且回溯的情况被上两种统计到了，所以 $y$ 是 $x$ 的一个儿子，二者深度相差不超过 $1$，这说明 $[x,y-1]$ 中有且仅有一个元素后面可以放分段。

不难发现上文中 $d_i+1>d_{i+1}$ 的情况一定发生在符合第三种情况的这段区间中间，其实就是因为 $x$ 这个节点有同层的、更靠后的节点还没有 $\rm bfs$ 到，所以 $\rm bfs$ 的过程需要过一会儿才到下一层。

既然这个”有且仅有一个元素“已经确定是哪个元素了，不妨我们视作将 $[x,y-1]$ 这段区间禁止起来，全部不能产生贡献，而在上文产生 $1$ 的贡献时直接加到答案中。

题解中有人不会证充要（似乎所有人都没证），为什么这样可以 $\rm ban$ 掉所有不可能分段的点？

![](https://cdn.luogu.com.cn/upload/image_hosting/o0sgr8yb.png)

其实你可以参考上图，本层 （下称第 $d$ 层）的每个节点都与它的第一个儿子产生了这样的 $\rm banpair$，这首先保证了 $d+1$ 层除了（第 $d$ 层最后一个节点的儿子）的所有点后面不能分层。

那第 $d+1$ 层的最后那些点怎么限制？其实仔细思索一下你发现它们**不应限制**，如果它们中的一个节点没有儿子（且不是已经判断过的必须分割点且没有被 $\rm ban$），那说明它符合上文提到过的可调整结构，所以它是应当贡献 $0.5$ 的。

而如果它有儿子，你惊喜地发现它符合上图中 $x$ 的地位，它实质上得到了应有的限制。

---

## 作者：javalyc (赞：35)

[在博客食用效果更佳（洛谷图片太大了qwq）](https://www.cnblogs.com/LLTYYC/p/10818845.html)

神仙题...

和树的深度有关，由于 $BFS$ 序的性质，显然可以通过把 $BFS$ 序分成若干段来求出深度，每一段就对应某一深度从左到右的所有节点，那么如果确定了分的段数就确定了树的深度（分的段数 $+1$）

为了方便，先把 $BFS$ 序变成从 $1$ 到 $n$ 的序列， $DFS$ 序当然也要随着变一下

考虑每个位置是否可以分段，无非 $3$ 种情况：

$1.$ 此位置必须分，那么对树的深度贡献就是 $1$

$2.$ 此位置不能分，那么贡献就是 $0$

$3.$ 此位置可分可不分，那么贡献就是 $0.5$（此位置分的树的方案数和不分的树的方案数是一样的，如果分贡献 $1$，不分贡献 $0$，那么平均贡献就是 $0.5$）

考虑用 $BFS$ 序和 $DFS$ 序之间的关系求出每个位置的限制，设节点 $i$ 的 $BFS$ 序为 $bfn[i]$，$DFS$ 序为 $dfn[i]$

 

对于 $BFS$ 序连续的两点 $x,y=x+1$（此时已经按 $bfn$ 重新标号了），如果 $dfn[x]>dfn[y]$ ，说明 $y$ 在 $x$ 的下一层

大概图长这样：

![](https://cdn.luogu.com.cn/upload/pic/58145.png)

可以发现只有这种情况才会出现 $dfn[x]>dfn[y]$ 的情况，因为如果 $x$ 和 $y$ 在同一层那么显然 $y$ 会更晚被 $dfs$ 到

所以如果 $dfn[x]>dfn[x+1]$，那么 $x$ 和 $x+1$ 之间必须分层

那么如果 $dfn[x]<dfn[x+1]$ ，是否意味着 $x$ 和 $x+1$ 之间不能分层呢，显然是不一定的，对于这种情况我们仍然无法确定是否要分层

可能有两种情况，$x$ 没有儿子， $x+1$ 是 $x$ 的兄弟；$x+1$ 是 $x$ 的儿子，还是没办法确定，而且发现不管是哪种情况都不会对之后的序列产生影响，这保证了无法确定的位置贡献是 $0.5$（这个位置不管切不切方案数都是一样的）

 

对于 $DFS$ 序连续的两点 $x,y$，情况比较多

如果 $x>y-1$ （$bfn[x]>bfn[y-1]$），那么说明 $y$ 是 $x$ 某个祖先的儿子：

![](https://cdn.luogu.com.cn/upload/pic/58146.png)

对限制并没有影响

如果 $x==y-1$，那么 $y$ 作为 $x$ 兄弟或者儿子都是合法的

![](https://cdn.luogu.com.cn/upload/pic/58147.png)![](https://cdn.luogu.com.cn/upload/pic/58148.png)

所以仍然无法确定贡献，但是同样可以发现不管是哪种情况对后面的序列都没有影响（里后面节点可以接到 $y$ 下面或者作为 $y$ 的下一个兄弟）

但是第三种情况有点意思：$x<y-1$

说明 $y$ 一定是 $x$ 的儿子：

![](https://cdn.luogu.com.cn/upload/pic/58151.png)

那么就是说，编号从 $x$ 到 $y-1$ 的所有节点深度差不超过1

而且可以发现，如果有分割那么在之前就被计算过了

（一定存在 $k$ 使得 $dfn[x+k]>dfn[x+k+1]$ ,$x+k \in [x+1,y-1]$ ）

所以对于 $x<y-1$ 的情况，区间 $[x,y)$ 的位置都不能产生贡献

这个限制可以用一个差分数组维护

最后剩下的都不能确定了，贡献就是 $0.5$

最后一个问题，这些限制是必要的，但是，充分吗？

感性理解一下，很充分，如果怀疑的话打个暴力拍它几个小时，发现没问题，所以是充分的...

并不会证明限制充分 $qwq$

代码很短，但是并不好想...

设 $pos[i]$ 表示 $dfn$ 为 $i$ 的节点（其实就是 $dfn$ 的反数组）

那么对于前面最后一个限制，$x<y-1$，其实就是 $pos[i]<pos[i+1]-1$

注意一开始那些一定要分割的位置已经算过就不会再产生 $0.5$ 的贡献了

还有第一个节点一定单独要分一层

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
    return x*f;
}
const int N=2e6+7;
int n;
double ans;
int dfn[N],pos[N],sum[N];//sum是差分数组
//dfn是节点的dfs序，pos是dfn的反数组，所以有 pos[dfn[i]]=i,dfn[pos[i]]=i
inline void mark(int x,int y) { sum[x]++,sum[y+1]--; }//打差分标记
int main()
{
	// freopen("1.in","r",stdin);
	n=read();
	ans=1; mark(1,1);//第一个节点一定要分一层
	for(int i=1;i<=n;i++) dfn[read()]=i;//读入初始dfs序
	for(int i=1;i<=n;i++) pos[dfn[read()]]=i;//用初始dfs序更新变化后的pos
	//上面一行不太好想。因为bfs序重标号了，原来的节点read()就变成了i，所以pos[dfn[read()]]=i
	for(int i=1;i<=n;i++) dfn[pos[i]]=i;//用更新后的pos更新dfn
	for(int i=1;i<n;i++)//注意i不取n
	{
		if(dfn[i]>dfn[i+1]) ans++,mark(i,i);//注意这里也要打标记，之后不会再产生0.5的贡献
		if(pos[i]<pos[i+1]-1) mark(pos[i],pos[i+1]-1);//打标记
	}
	int now=0;
	for(int i=1;i<n;i++) now+=sum[i],ans+=(now ? 0 : 0.5);//如果这个位置不确定则贡献为0.5
	//注意上一行i不取n,因为切的位置只有n-1个
	ans+=1;//深度等于分的段数+1
	// printf("%.3lf\n%.3lf\n%.3lf",ans-0.001,ans,ans+0.001);//BZOJ上要这样输出...
	printf("%.3lf\n",ans);
	return 0;
}
```


---

## 作者：香风智乃 (赞：28)

[[NOI2013]树的计数 ](https://www.luogu.org/problemnew/solution/P1232)

~~目前讲的最清楚的solution？（大雾）~~

[Click here for a better reading experience（人话：myblog）](https://www.cnblogs.com/kafuuchino/p/10815044.html)

给定树的$dfs$序和$bfs$序，显然是通过它们之间的**互相约束**以得出答案。

为了方便，对编号做修改（不影响答案）。

$dfs$序改为：$bfs$序为$1,2,...,n$时的$dfs$序（设为$d[i]$）

$bfs$序改为：$dfs$序为$1,2,...,n$时的$bfs$序（设为$b[i]$）

树高$h$如何表示？假设将$bfs$序分成$i$段，$h=i$，每段内的所有点都在同一层


------------

而任意点$k$后，分段/不分段，对平均树高$H$的贡献为$1/0$

每个$k$有$3$种情况：

①只能分段，$H+=1$

②分不分都行，$H+=0.5$

③不能分，$H+=0$

对于②、③，我们用一个差分数组$s[i]$表示状态。

累计$s[i]$的前缀和$ts$，$ts=0$为②，$ts>0$为③

至于①，我们可以直接处理掉，下面会讲

**注意，对于根节点$1$，它只能分成单独的一段（一种①）**

 

------------


有个问题，$bfs$序并不能能随意分段，要受到$dfs$序的限制（用$s[i]$表示）

观察发现，假设我们将$bfs$序中的$[l,r]$分成一段，必须满足$b[l]<b[l+1]<...<b[r]$

因为在同一层内，$dfs$扫点一定是从左到右

所以$dfs$序一定是从左到右递增的（$dfs$序已经为$1...n$）。

**于是得出一个约束条件：$b[i]>b[i+1]$时，$i$和$i+1$显然不能分到同一层内，必须断开。（另一种①）
**

------------

接下来考虑$bfs$序对$dfs$序的限制

还是考虑$dfs$序上两个相邻的点$i,i+1$

发现它们之间有3种关系（红点为$i$，蓝点为$i+1$）

![](https://cdn.luogu.com.cn/upload/pic/58119.png)

1.$i$和$i+1$是兄弟（$i$没有儿子）

2.$i+1$是$i$的祖先的某个儿子（$i$没有儿子）

**3.$i+1$是$i$的儿子**

发现第3种情况有点东西：

$bfs$序上$d[i]$~$d[i+1]$之间最多只能切一次段，因为$i$和$i+1$之间只差一层

而且切这一段的贡献已经在①中被算过了

于是$d[i]$~$d[i+1]$就不能再贡献啥了，也就是总贡献$=0$，$H+=0$

然鹅怎么把第1,2种情况筛掉呢

发现对于第1种，$d[i]>d[i+1]$

对于第2种，$d[i]+1=d[i+1]$

（或者第3种的一层只有$i$，下一层只有$i+1$。把它筛掉没有影响）

$d[i]+1<d[i+1]$时，只能是第3种情况

**于是我们又得出了一个约束条件：$d[i]+1<d[i+1]$时，$bfs$序中的$[d[i],d[i+1]]$不会再产生贡献（③）**

 

------------


**剩下不被约束的点都属于②，**$H+=0.5$，表示取/不取产生贡献的平均值$(0+1)/2$

 

------------


再注意一些小细节（见code）于是就可以搞定这个思维题辣

 

------------


参考博客：[①](https://blog.csdn.net/qq_30974369/article/details/80945779)，[②](https://www.cnblogs.com/lcf-2000/p/6387918.html)



```cpp
#include<iostream>
#include<cstdio>
#define rint register int
using namespace std;
#define N 200005
int read(){
    char c=getchar();int x=0;
    while(c<'0'||c>'9') c=getchar();
    while('0'<=c&&c<='9') x=x*10+(c^48),c=getchar();
    return x;
}
int n,s[N],b[N],d[N],a[N],c[N];
double ans;
int main(){
    n=read(); ans=2; ++s[1];--s[2];//ans=2：根节点算1层+最下面的1层=2层
    for(rint i=1;i<=n;++i) a[d[i]=read()]=i;
    for(rint i=1;i<=n;++i) c[b[i]=read()]=i;
    for(rint i=1;i<=n;++i) d[i]=c[d[i]],b[i]=a[b[i]];
    for(rint i=1;i<n;++i) if(b[i]>b[i+1]) ++s[i],--s[i+1],++ans;//ans没有算到最下面的一层，先加上去
    for(rint i=1;i<n;++i) if(d[i]+1<d[i+1]) ++s[d[i]],--s[d[i+1]];
    for(rint i=1,w=0;i<n;++i) w+=s[i],ans+=w?0:0.5;//第n个点后面都是空的给它分段有什么意义吗
//    printf("%.3f\n%.3f\n%.3f",ans-0.001,ans,ans+0.001);
//     bzoj需要输出以上ans-0.001,ans,ans+0.001（大雾）
    printf("%.3f",ans);
    return 0;
}
```


---

## 作者：CXY07 (赞：16)

> 题目链接：[\[NOI2013\] 树的计数](https://www.luogu.com.cn/problem/P1232)

> **本题解同步发布于 [My Blog](http://www.cxy07.blog/index.php/archives/124/)**

题意：

> 给定长度为 $n$ 的排列 $\{d_n\},\{b_n\}$，他们分别是一棵有根树的 $\text{DFS}$ 序和 $\text{BFS}$ 序（儿子有顺序）。

> 求所有满足上述 $\text{DFS}$ 序和 $\text{BFS}$ 序的树的深度的平均值。

> $1\le n\le 2\times 10^5$。

看到 $\text{BFS}$ 序，自然想到按照 $\text{BFS}$ 序来分段。把 $b,d$ 按照 $\text{BFS}$ 序重新编号，即使得 $b_i=i$，$d_i$ 相应变化。

观察一下有了 $\text{DFS}$ 序和 $\text{BFS}$ 序后，每个节点的深度 $\text{dep}_i$ 需要满足什么限制。

- 根据 $\text{BFS}$ 序的限制，$\text{dep}_{b_i}\le \text{dep}_{b_{i+1}}$ 。
- 根据 $\text{DFS}$ 序的限制，$\text{dep}_{d_{i+1}}\le \text{dep}_{d_i}+1$ 。这是因为 $d_{i+1}$ 一定是 $d_i$ 到根之间的链上的某个节点的儿子。


发现需要计算的是深度，而深度恰好等于 $\text{BFS}$ 序中 $\text{dep}$ 相同取值的段数 $+1$。求平均数等价于求合法的树的深度的期望，根据期望的线性性，可以将每个点作为分段点的概率分开考虑。

考虑 $i$ 与 $i+1$ 之间什么时候一定会分段。

首先，$1$ 后面必定会分段（根只有一个）；若 $i,i+1$ 同深度，那么 $\text{DFS}$ 序中 $i$ 在 $i+1$ 前面。因此，$\text{DFS}$ 序中若 $i$ 在 $i+1$ 后面，则 $i$ 后一定要分段。

再考虑什么情况下 $i,i+1$ 之间不能分段。根据 $\text{dep}_{d_{i+1}}\le \text{dep}_{d_i}+1$，我们可以得到：当 $d_i<d_{i+1}$，则 $[d_i,d_{i+1})$ 之间至多一个分段点。

这是因为，当 $d_i<d_{i+1}$，就说明了 $\text{dep}_{d_i}\le \text{dep}_{d_{i+1}}$，又有 $\text{dep}_{d_{i+1}}\le \text{dep}_{d_i}+1$，所以 $\text{dep}_{d_i}\le \text{dep}_{d_{i+1}}\le \text{dep}_{d_i}+1$。

那么若 $[d_i,d_{i+1})$ 之间，有一个必须分段的点，那么区间中剩下的点都不能作为分段点了。

因此，可以通过差分的方法，求出每一个点是否能作为分段点。

- 若一个点必须成为分段点，则对答案的贡献为 $1$。
- 若一个点没有被限制，则可以是分段点，也可以不是。由于每个点是否分段独立，所以贡献是 $0.5$。
- 若一个点不能分段，则贡献为 $0$。

时间复杂度 $\mathcal{O}(n)$。

```cpp
//Code By CXY07
#include<bits/stdc++.h>
using namespace std;

//#define FILE
//#define int long long
#define file(FILENAME) freopen(FILENAME".in", "r", stdin), freopen(FILENAME".out", "w", stdout)
#define randint(l, r) (rand() % ((r) - (l) + 1) + (l))
#define LINE() cout << "LINE = " << __LINE__ << endl
#define debug(x) cout << #x << " = " << x << endl
#define abs(x) ((x) < 0 ? (-(x)) : (x))
#define inv(x) qpow((x), mod - 2)
#define lowbit(x) ((x) & (-(x)))
#define ull unsigned long long
#define pii pair<int, int>
#define LL long long
#define mp make_pair
#define pb push_back
#define scd second
#define vec vector
#define fst first
#define endl '\n'

const int MAXN = 2e5 + 10;
const int INF = 2e9;
const double eps = 1e-6;
const double PI = acos(-1);
//const int mod = 1e9 + 7;
//const int mod = 998244353;
//const int G = 3;
//const int base = 131;

int n, m;
int d[MAXN], b[MAXN], ib[MAXN], pos[MAXN];
int cut[MAXN], cover[MAXN];
double Ans = 1;

template<typename T> inline bool read(T &a) {
	a = 0; char c = getchar(); int f = 1;
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') {a = a * 10 + (c ^ 48); c = getchar();}
	return a *= f, true;
}

template<typename A, typename ...B>
inline bool read(A &x, B &...y) {return read(x) && read(y...);}

signed main () {
#ifdef FILE
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
#endif
	read(n);
	for(int i = 1; i <= n; ++i) read(d[i]);
	for(int i = 1; i <= n; ++i) read(b[i]), ib[b[i]] = i;
	for(int i = 1; i <= n; ++i) d[i] = ib[d[i]], b[i] = ib[b[i]], pos[d[i]] = i;
	for(int i = 1; i < n; ++i) cut[i] = cut[i - 1] + (pos[i] > pos[i + 1] || i == 1);
	for(int i = 1; i < n; ++i) {
		if(d[i] < d[i + 1] && cut[d[i + 1] - 1] - cut[d[i] - 1] > 0) {
			if(cut[d[i + 1] - 1] - cut[d[i] - 1] > 1) return puts("0.000"), 0;
			cover[d[i]]++, cover[d[i + 1]]--;
		}
		if(cut[d[i + 1] - 1] - cut[d[i] - 1] == 0) assert(d[i + 1] == d[i] + 1);
	}
	for(int i = 1; i < n; ++i) {
		cover[i] += cover[i - 1];
		if(!cover[i]) Ans += 0.5;
		else if(cut[i] - cut[i - 1]) Ans += 1;
	}
	printf("%.3lf\n", Ans);
	return 0;
}
```

---

## 作者：Vector_Mingfan (赞：9)

**思路分析**

**用期望的线性性拆成点对的贡献**

**我们发现：**
- 如果点对 ($x$ ,$y$ ) 必须处在不同层,那么期望 +1, 必须在相同层则没有贡献
    
- 如果不确定是否在同层,则为 0.5

------------


**现在只需要把点分类即可:**
     
- 1.如果两个点在 bfs 序中相邻, $\mathcal{BFS}$[a] <$\mathcal{DFS}$[b],且满足 $\mathcal{DFS}$[a]>$\mathcal{DFS}$[b],那么就必须不同层

- 2.如果两个点在 dfs 序中相邻, $\mathcal{DFS}$[a]<$\mathcal{DFS}$[b],且满足 $\mathcal{BFS}$[a]<$\mathcal{BFS}$[b],代表这两个点的深度差不超过 1,就意味着 $\mathcal{BFS}$ 序中,a 到 b 之间的点必须同层

**考虑怎么满足这些约束:**

- 条件 1 比较好判断；

- 对于条件 2 ,当一个点对确定深度差不超过一时,在 $\mathcal{BFS}$ 序中这两个点的中间一段必须同层,贡献已经确定是 0,我们把中间的点打上一个标记,表示已经确定了贡献,可以用差分实现。


------------
那代码就好写了

```cpp
#include <iostream>
#include <cstdio>
#define MAXX 200005
using namespace std;

struct Nice {
	int a , b , c , p , s , t;
}g[MAXX];
int n;
double Ans;

void Read() {
	scanf("%d",&n);
	for (int i=1 , x; i<=n; i++) {
		scanf("%d",&x);
		g[x].p = i;
	}
	for (int i=1 , x; i<=n; i++) {
		scanf("%d",&x);
		g[g[x].p ].a = i;
		g[i].b = g[x].p ;
	}
}

void Work() {
	g[1].t ++;
	g[1].c ++;
	g[2].c --;
	for (int i=2; i<=n; i++) {
		if (g[i].b > g[i + 1].b ) {
			g[i].t ++;
			g[i].c ++;
			g[i + 1].c --;
		}
	}
	for (int i=1; i<=n; i++) {
		g[i].s = g[i - 1].s + g[i].t ;
	}
	for (int i=1; i<=n; i++) {
		if (g[i].a < g[i + 1].a && g[g[i + 1].a - 1].s - g[g[i].a - 1].s ) {
			g[g[i].a ].c ++;
			g[g[i + 1].a ].c --;
		}
	}
}

int main() {
	Read();
	Work();
	for (int i=1; i<=n; i++) {
		g[i].c += g[i - 1].c ;
		if (g[i].c ) Ans += g[i].t ;
		else Ans += 0.5;
	}
	printf("%.3lf",Ans);
}
```
~~最近在复习图论，数组g用惯了。。。~~

---

## 作者：2014吕泽龙 (赞：7)

### 分析

强烈吐槽一下这道题不采用取模的方式，害我被卡精度卡了半天。

~~因为毕竟是是自己yy的一种垃圾做法~~

手玩几组数据 ~~（或者左转看看题解）~~ 发现按层划分BFS序很科学。

然后就可以发现一个结论：**一种合法的BFS序的划分对应一棵树**。

**证明**：考虑递归构造对应关系。对于某个BFS序，如果我们已经构造出了$i$层以内的树，考虑第$i+1$层，因为已经划分好了，所以这一层有那些节点我们是知道的。如果我们将$i$层以内的节点在DFS序中全部删掉，剩下的一定是DFS序中的若干个区间。DFS序可以看成子树根+子树的形式，那么每个区间就对应一个子树，并且子树根就是区间左端点前一个节点。这样的话$BFS$序中第$i+1$层的节点就可以去对应区间找他们的父亲。

那么现在问题转化成合法地划分$BFS$序。考虑$Dp$

$f_{i,d}$表示划分到第$i$个数，一共划分了$d$层的方案。

$f_{i,d}=\sum_{j=1}^{i-1}f_{j,d-1}[can(j,i)]$

$can(j,i)$表示$[j+1,i]$这个划分是合法的。

考虑如何求出$can(j,i)$

在构造的时候实际上已经初步得出了一个层划分合法性的判定方法。

首先将BfS序中$j$以前的点删掉。

根据题目的要求，第一个条件就是BfS序中$[j+1,i]$中的点在DFS序中的位置递增。

而构造的时候发现，删去的区间左端点一定是子树根，所以必须出现在划分中。

如果暴力枚举$i,j$，然后$O(n)$判断，这样的求$can$复杂度是$O(n^3)$的，而$Dp$也是$O(n^3)$的，这样就得到了一个$O(n^3)$的算法，接下来考虑优化。

首先，往$O(n^2)$进发，先优化预处理$can(j,i)$。

先枚举一个$j$，然后枚举$i$,对于第2个条件，我们对于$DFS$序中每个区间左端点在$BFS$序中的最大位置$l$，那么合法的$i$一定在$l$之后。

然后从$l$开始扫描一段区间，这段区间满足条件1，也就是位置递增即可。假设扫到了$r$，那么合法$i$在$[l,r]$之间。

对于$f$，一种比较有技巧性的做法是用生成函数优化。

$F_i(x)=\sum f_{i,d}x^d$

这样的话方程可以写成$F_i=\sum xF_j[can(j,i)]$

事实上，我们要求的东西是$\frac{F'_n(1)}{F_n(1)}$

求个导看看：

$F_i'=x\sum F_j'[can(j,i)]+\sum F_j[can(j,i)]$

将$x=1$带入：

$F_i(1)=\sum F_j(1)[can(j,i)]$

$F'_i(1)=\sum F'_j(1)[can(j,i)]+\sum F_j(1)[can(j,i)]$

设$f_i=F_i(1),g_i=F'_i(1)$转移就行了。

其实这个东西可以直接用期望去推，但是人菜就只好用笨方法推方程咯!

所以成功地把$Dp$也优化到了$O(n^2)$

还可以优化吗？

之前发现的一个性质是，对于一个$j$，它仅仅会转移到一段特定区间$[l,r]$内的$i$。而且贡献是线性的。

那么显然$Dp$部分差分打标记前缀和就$O(n)$了。

而$can(j,i)$怎么办？

对于某个$j$，显然$r$是可以用指针扫过去的。除非当前的$j$越过了$r$，不然$r$不会动。

而$l$可以在删除数的时候记录一下删除位置的下一个位置对应BFS序的位置，取个$max$即可。

这样的话两把指针扫一扫也是线性的了。这道题就这么被胡乱优化一波搞定了！

结果被卡精度了？！！！

开__float128也不行？！！！！

我搞了一波骚操作，把某个数科学计数法表示，然后重载加减法，忽略数量级超过一百的运算，然后就过了。。。。

### 代码

```cpp
#include<bits/stdc++.h>
const int N = 2e5 + 10;
int ri() {
	char c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
	for(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;
}
struct Data {
	double x; int e;
}g[N], f[N];
Data operator + (Data a, Data b) {
	if(a.e < b.e)
		std::swap(a, b);
	int d = a.e - b.e; double l = b.x;
	if(d > 100) l = 0;
	else {
		for(;d--;)
			l /= 10;
	}
	a.x += l;
	if(fabs(a.x) > 10) a.x /= 10, ++a.e;
	return a;
}
void operator += (Data &a, Data b) {a = a + b;}
void operator -= (Data &a, Data b) {
	b.x = -b.x;
	a = a + b;
}
int a[N], b[N], psa[N], psb[N], n, must;
int main() {
	n = ri();
	for(int i = 1;i <= n; ++i)
		a[i] = ri(), psa[a[i]] = i;
	for(int i = 1;i <= n; ++i)
		b[i] = ri(), psb[b[i]] = i;
	int l = 0, r = 0;
	f[1].x = g[1].x = 1;
	f[2].x = g[2].x = -1;
	for(int j = 1, i;j <= n; ++j) {
		f[j] += f[j - 1]; g[j] += g[j - 1];
		if(j == n) break;
		l = std::max(l, psb[a[psa[b[j]] + 1]]);
		for(r = std::max(r, j + 2);r <= n; ++r)
			if(psa[b[r]] < psa[b[r - 1]])
				break;
		--r;
		if(l <= r) {
			f[l] += f[j]; f[r + 1] -= f[j];
			g[l] += f[j] + g[j]; g[r + 1] -= f[j] + g[j];
		}
	}
	int d = g[n].e - f[n].e; double x = g[n].x / f[n].x;
	for(;d--;)
		x *= 10;
	printf("%.3lf\n", x);
	return 0;
}

```



---

## 作者：SunsetSamsara (赞：5)

## 前置知识
树，树的遍历，数学
## 分析
题意十分简明，给定 dfs 序与 bfs 序，求这棵树树高的平均值。

首先从 bfs 入手，因为 bfs 序可以的一段可以对应树的一层。

记 $dfn$ 为 $i$ 在 dfs 序中的位置，

记 $bfn$ 为 $i$ 在 bfs 序中的位置。

那么对于每一个点 $i$，接下来考虑这三种情况：

+ 只能分成 $2$ 层：贡献为 $1$

+ $1,2$ 层都可以：贡献为 $0.5$

+ 只能分成 $1$ 层：贡献为 $0$

思考情况 $2,3$：

利用 dfs 序和 bfs 序的关系求出每个点的限制：

1. 对于 bfs 序连续的两点 $x , y (bfn_x < bfn_y)$：

+ 如果 $dfn_y < dfn_x$，说明 $x,y$ 必定分层，因为如果 $x,y$ 在同一层则 $x$ 一定会 dfs 到，所以一定分层，贡献为 $1$。

+ 如果 $dfn_x < dfn_y$，则不能确定是否要分层。

接下来有两种情况：

+ $x$ 没有子节点， dfs 序中的下一个为 $x$ 的兄弟

+ $x$ 有子节点， dfs 序中的下一个为 $x$ 的儿子

发现无法确定，说明这种情况贡献为 $0.5$

2. 对于 dfs 序连续的两点 $x , y (dfn_x < dfn_y)$：

如果 $bfn_x > bfn_{y  - 1}$，说明 $x$ 的一个祖先是 $y$ 的父亲，贡献为 $0$

如果 $bfn_x = bfn_{y - 1}$，说明 $y$ 可以作为儿子或者兄弟，无法确定贡献。

如果 $bfn_x < bfn_{y - 1}$，说明 $y$ 一定是 $x$ 的儿子。同时，如果中间有分割则一定被计算过了。所以， **区间 $[x,y - 1]$ 对答案无贡献**。

这个使用差分数组维护。

实现细节：为了求 dfs 序的前一个，需要数组 `revd`，
为了求 bfs 序的前一个，需要数组 `revb`。

最后放上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int d[300001];
int bfn[300001];
int dfn[300001];
int revd[300001];
int revb[300001];
double ans;
int main(){
	scanf("%d", &n);
	ans = 2;
	++ d[1];
	-- d[2];
    for (int i = 1; i <= n; ++ i) {
		scanf("%d", dfn + i);
		revd[dfn[i]] = i;
	}
    for (int i = 1; i <= n; ++ i) {
		scanf("%d", bfn + i);
		revb[bfn[i]] = i;
	}
    for (int i = 1; i <= n; ++ i) {
		dfn[i] = revb[dfn[i]];
		bfn[i] = revd[bfn[i]];
	}
    for (int i = 1; i < n; ++ i)
		if(bfn[i] > bfn[i + 1])
			++ d[i], -- d[i + 1], ++ ans;
    for (int i = 1; i < n; ++ i)
		if(dfn[i] + 1 < dfn[i + 1])
			++ d[dfn[i]], -- d[dfn[i + 1]];
	int w = 0;
    for (int i = 1; i < n; ++ i) {
		w += d[i];
		if(!w) ans += 0.5;
	}
	printf("%.3f", ans);
}
```

---

## 作者：OI_killer (赞：4)

对bfs序分层  考虑同时符合dfs和bfs序的树满足什么条件


1.对于bfs连续的ab两点，假如a的bfs序小于b的bfs序，且a的dfs序大于b的，那么他们之间肯定是要分层的


2.另外 dfs序连续的ab两点，假如a的dfs序小于b的，且a的bfs序也小于b，那么显然它们的深度差不超过1，也就是说它们的bfs序区间之间最多分一层


3.第一个点要强制分层


所以考虑先把13条件都判一下，求出分层数的前缀和数组，然后把第2个条件判一下(如果它们之间已经分层了，那么就强制其他的不分层)


最后还没确定的点可分层可不分，贡献是0.5，答案是分层数加1再加上没确定的点的数量乘以0.5


复杂度O(n)

```cpp
#include<iostream>
#include<cstdio>
#define getchar() (*S++)
#define MN 200000
char BB[1<<26],*S=BB;
using namespace std;
inline int read()
{
    int x = 0; char ch = getchar();
    while(ch < '0' || ch > '9') ch = getchar();
    while(ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x;
}

int D[MN+5],P[MN+5],B[MN+5],n,ans=0,x[MN+5],y[MN+5],q[MN+5],top=0;
inline void mark(int a,int b){++y[a];--y[b];}

int main()
{
    fread(BB,1,1<<26,stdin);
    n=read();int j;
    for(register int i=1;i<=n;++i) P[j=read()]=i;
    for(register int i=1;i<=n;++i) D[B[i]=P[j=read()]]=i;
    for(register int i=1;i<n;++i)
        x[i]=x[i-1],(i==1||B[i]>B[i+1])?(ans+=2,++x[i],mark(i,i+1),0):0;
    for(register int i=1;i<n;++i) D[i]<D[i+1]?(x[D[i+1]-1]>x[D[i]-1]?(mark(D[i],D[i+1]),0):q[++top]=D[i]):0;
    for(register int i=1;i<=n;++i) y[i]+=y[i-1];
    for(register int i=1;i<=top;++i) ans+=y[q[i]]==0;
    double Ans=(double)ans/2+1;
    printf("%0.3lf\n",Ans);
    return 0;
}
```

---

## 作者：傅思维666 (赞：3)

## 题解：

一开始看到这道题还是没什么思路的。因为感觉没什么办法来通过序列来还原树。反正就是不知道咋暴力。

既然不知道暴力，就去想正解吧。没办法了。

发现，虽然序列还原树没什么思路，但是可以显然地发现一个性质：BFS序分几层，树的高度就是多少。也就是说在BFS序上枚举断点即可。

兴冲冲地去做，发现还不是那么的简单，因为情况大抵有三种：必须分，必须部分，可分可不分。

然后想想如何判断这三种情况。

首先，对于bfs序连续的两个点，不是在同一层，就是在下一层。那么这个条件可以用DFS序约束，如果BFS序连续，但是较大BFS序的DFS序反而较小，那么就一定被挪到下一层去了，这个断点位置的贡献为1.反之，贡献不一定为0，也有可能是0.5，所以确定不了。

想到这里兴高采烈了好半天，但是其实还远远未结束。

因为只考虑了DFS对BFS序的约束，BFS序必然也会对DFS序有约束。

那么，对于DFS序连续的两个点，有可能是父子关系，也有可能都是叶子，是兄弟关系。甚至有可能，是其一个点某一个祖先的儿子。

如果是兄弟关系或者父子关系，那么其BFS序也应该是连续的。也就是它们的深度差不能大于1。它们的BFS序之间最多分1层。这样的话，可以用一个差分来维护区间的这个信息。

差分维护的是分多少层。

但是如果是祖先关系，那么其BFS序就会出现逆序的情况。也就是较大DFS序的BFS序反而较小。

代码：

```cpp
#include<cstdio>
using namespace std;
const int maxn=3e5+5;
int n;
int bfn[maxn],dfn[maxn],bp[maxn],dp[maxn],s[maxn];
double ans;
int main()
{
	freopen("average.in","r",stdin);
	freopen("average.out","w",stdout);
	scanf("%d",&n);
	ans=2; 
    ++s[1];
    --s[2];
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&dfn[i]);
		dp[dfn[i]]=i;
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&bfn[i]);
		bp[bfn[i]]=i;
	}
	for(int i=1;i<=n;i++)
	{
		dfn[i]=bp[dfn[i]];
		bfn[i]=dp[bfn[i]];
	}
	for(int i=1;i<n;++i) 
      	if(bfn[i]>bfn[i+1]) 
        	++s[i],--s[i+1],++ans;
    for(int i=1;i<n;++i) 
      	if(dfn[i]+1<dfn[i+1]) 
        	++s[dfn[i]],--s[dfn[i+1]];
	int w=0;
    for(int i=1;i<n;++i) 
      	w+=s[i],ans+=w?0:0.5;
	printf("%.3lf\n",ans);
	return 0;
}
```

---

## 作者：orz_z (赞：2)


### 题目大意
给你一个 dfs 序和一个 bfs 序，求所有满足这两个序的树的高的平均值（ 保留三位小数 ），输入保证至少存在一棵树符合给定的两个序列。

### 解题思路
首先可以从 bfs 序入手，因为更具 bfs 序的性质，可以发现 bfs 序可以分成 $x$ 个段，每一段中的节点都是在同一行中，而这棵树 $i$ 的树高 $h_i$ 又恰好与 $x$ 相等。

这里为了方便 ,

记 $d_i$ 为点 $i$ 在 dfs 序的位置。

记 $b_i$ 为点 $i$ 在 bfs 序的位置。

那就可以设有一任意点 $k$，则 $k$ 有 $3$ 种情况： 

 1. 只能分段，$ans+1$；
 2. 分不分都行，$ans+0.5$；
 3. 不能分，$ans$ 不变。

对于情况 $2$ 和情况 $3$，我们可以用一个差分数组 $c$，记录点 $i$ 是情况 $2$ 还是情况 $3$，
* 若 $c_i$  不为 $0$，则说明这个地方不设断点或设了断点，若不设断点，则贡献为 $0$；若设了断点，贡献为 $1$，但 $c_i$ 依旧为 $0$，因为断点的个数记录在 $ans$ 里就行了 。
* 若 $c_i$ 为 $0$，说明这个地方可以分层也可以不分层，则对平均树高（也就是答案）的贡献为 $0.5$，因为如果分层，则贡献为 $1$；如果不分层，则贡献为 $0$，综合起来贡献就为 $\frac{(1+0)}{2}=0.5$。

再思考情况 $1$ ，如果有一个断点，说明满足条件的所有树都应该在这里分层，则对平均树高（也就是答案）的贡献为 $1$。

对于情况 $1$，我们可以从 bfs 序连续的两点和 dfs 序连续的两点这两个方向入手。

此时显然可以得到一个约束条件，对于 bfs 序连续的两点 $x=bfn_i,y=bfn_{i+1}$，
* 如果 $d[x]>d[y]$，说明 $y$ 在 $x$ 的下一层，属于情况 $1$。
* 如果 $d[x]<d[y]$，说明 $y$ 在 $x$ 的下一层 或  $\ x$ 和 $y$ 在同一层，属于情况 $2$。

再思考 dfs 序连续的两点 $x=dfn_i,y=dfn_{i+1}$，有 $3$ 种情况：

 1. $b_x+1=b_y$，$x$ 和 $y$ 是兄弟（ $x$ 没有儿子 ）；
 2. $b_x>b_y$，$y$ 是 $x$ 的某个祖先的某个儿子（ $x$ 没有儿子）；
 3. $y$ 是 $x$ 的儿子，属于情况 $1$。

分析情况 $3$ ，发现编号从 $x$ 到 $y-1$ 的所有节点深度差不超过 $1$，而情况 $3$ 的贡献在上面已经计算过了，所以情况 $3$ 在这里的贡献为 $0$，要在差分数组里面记录一下。另外，记录时要把情况 $1$ 和情况 $2$ 筛掉，当然也可以不筛，单独判断 $b[x]+1<b[y]$ 就行了。

### AC CODE
```cpp
#include <bits/stdc++.h>
#define int long long
#define _ (int)2e5 + 5
using namespace std;

int n;
int cc;
int x, y;
double ans = 2.0;
array<int, _> bfn, dfn, b, d, c;

signed main()
{
	scanf("%lld", &n);
	c[1]++, c[2]--;
	for (int i = 1; i <= n; ++i)
	{
		scanf("%lld", &dfn[i]);
		d[dfn[i]] = i;
	}
	for (int i = 1; i <= n; ++i)
	{
		scanf("%lld", &bfn[i]);
		b[bfn[i]] = i;
	}
	for (int i = 1; i < n; ++i)
	{
		x = bfn[i], y = bfn[i + 1];
		if (d[x] > d[y])
		{
			c[i]++, c[i + 1]--;
			ans++;
		}
		x = dfn[i], y = dfn[i + 1];
		if ((!(b[x] > b[y])) && (!(b[x] + 1 == b[y]))) //b[x] + 1 < b[y]
		{
			c[b[x]]++, c[b[y]]--;
		}
	}
	for (int i = 1; i < n; ++i)
	{
		cc += c[i];
		if (!cc)
		{
			ans += 0.5;
		}
	}
	printf("%.3lf\n", ans);
	return 0;
}
```


---


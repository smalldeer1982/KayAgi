# 公共子序列

## 题目描述

求 $3$ 个字符序列有多少个不同的公共子序列，不包括空序列。

## 说明/提示

#### 样例 1解释

对于唯一的一个样例，有 $5$ 种子序列，分别是 `a`，`ab`，`aa`，`bb`，`b`。

#### 数据范围与约定

- 对于 $30\%$ 的数据，保证 $1 \le n \le 10$；
- 对于 $70\%$ 的数据，保证 $1 \le n \le 50$；
- 对于 $100\%$ 的数据，保证 $1 \le n \le 150$。

## 样例 #1

### 输入

```
4   
aabb   
abab   
baba
```

### 输出

```
5```

# 题解

## 作者：神之右大臣 (赞：26)

这道题有点坑人啊~

首先，它需要取模，模数是100000000；(窝在这里死了好久好久，看了别人的代码才发现这一点)

然后我发现题解中没有序列自动机的方法，于是就来一发

首先，虽然序列自动机在定义上与后缀自动机、回文自动机等听起来比较高大上的算法同属于自动机的范畴，但它仅仅是个**普及-**算法

为何？因为你不学都有可能会(逃)

自动机，就是把一个字符串通过某种关系构成一幅有向无环图，这样可以方便我们进行图上dp

### [或许更好的阅读体验](https://www.cnblogs.com/kamimxr/p/11823052.html)
## 序列自动机的构造方法：

设一个字符集S，nxt[i][j]表示第i个位置往后第一个j元素出现的位置；

这个nxt数组可以O(n)的求出来，可以自行验证；

```cpp


for(int i=n-1;i>=0;--i){
    for(int j=1;j<=26;++j) nxt[i][j]=nxt[i+1][j];
    nxt[i][s[i+1]-'a'+1]=i+1;
}


```
## 她能干什么事情呢？(应用)

#### 1.判断是否是原字符串的子序列

当我们构造出nxt数组之后，可以贪心的寻找子序列；



#### 2.求一个序列的子序列个数；(可以限定序列的长度)

我们在DAG上跑拓扑DP，f[v][j]表示从1~v寻找j个元素的方案数；

显然的：f[v][j]+=f[u][j-1];

```cpp
#include <bits/stdc++.h>
#define inc(i,a,b) for(register int i=a;i<=b;i++)
#define dec(i,a,b) for(register int i=a;i>=b;i--)
using namespace std;
char s[3010];
int nxt[3010][40];
int n,m;
long long f[3010][3010];
int rudu[3010];
const int p=998244353;
queue<int> qwq;
void tp()
{
    qwq.push(0);
    f[0][0]=1;
    while(qwq.size()){
        int u=qwq.front();
        qwq.pop();
        inc(i,0,25){
            if(!nxt[u][i]) continue;
            inc(j,0,u) f[nxt[u][i]][j+1]=(f[nxt[u][i]][j+1]+f[u][j])%p;
            --rudu[nxt[u][i]];
            if(rudu[nxt[u][i]]==0) qwq.push(nxt[u][i]);
        }
    }
}
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);cin>>m;
    dec(i,n-1,0){
        inc(j,0,25) nxt[i][j]=nxt[i+1][j];
        nxt[i][s[i+1]-'a']=i+1;
        inc(j,0,25) if(nxt[i][j]!=0) rudu[nxt[i][j]]++;
    }
    tp();  
    long long ans=0;
    inc(i,1,n) ans=(ans+f[i][m])%p;
    cout<<ans%p;
}
/*
addeade
3
 
aa
1
*/
```

#### 3.求两串的公共子序列个数(就是这道题)

```cpp
#include <bits/stdc++.h>
#define inc(i,a,b) for(register int i=a;i<=b;i++)
#define dec(i,a,b) for(register int i=a;i>=b;i--)
using namespace std;
char a[160],b[160],c[160];
int nxta[160][30],nxtb[160][30],nxtc[160][30];
long long f[160][160][160];
const int mod=100000000;
long long dfs(int x,int y,int z)
{
	if(f[x][y][z]) return f[x][y][z];
	inc(i,0,26){
		if(nxta[x][i]&&nxtb[y][i]&&nxtc[z][i]){
			f[x][y][z]=(f[x][y][z]+dfs(nxta[x][i],nxtb[y][i],nxtc[z][i]))%mod;
		}
	}
	if(x||y||z) ++f[x][y][z];
	return f[x][y][z]%mod;
}
int main()
{
	int x,y,z;
	int n;
	cin>>n;
	scanf("%s %s %s",a+1,b+1,c+1);
	x=strlen(a+1); y=strlen(b+1); z=strlen(c+1);
	dec(i,x-1,0){
		inc(j,0,25) nxta[i][j]=nxta[i+1][j];
		nxta[i][a[i+1]-'a']=i+1;		
	}
	dec(i,y-1,0){
		inc(j,0,25) nxtb[i][j]=nxtb[i+1][j];
		nxtb[i][b[i+1]-'a']=i+1;				
	}
	dec(i,z-1,0){
		inc(j,0,25) nxtc[i][j]=nxtc[i+1][j];
		nxtc[i][c[i+1]-'a']=i+1;		
	}
	cout<<dfs(0,0,0)%mod;
}
```

#### 4.求字符串的回文子序列个数

首先原串与反串都建一遍；

就相当于从左右端点向中间跑自动机；

显然：x+y<=n+1才会合法；

但要注意，我们只能统计偶数长度的字符串，而不能统计奇数个数的字符串；

因为我们永远都是两个两个地串；

```cpp
long long Dfs(int x,int y){
    if(f[x][y]) return f[x][y];
    for(int i=1;i<=a;++i)
        if(nxt1[x][i]&&nxt2[y][i]){
            if(nxt1[x][i]+nxt2[y][i]>n+1) continue;
            if(nxt1[x][i]+nxt2[y][i]<n+1) f[x][y]++;
            f[x][y]=(f[x][y]+Dfs(nxt1[x][i],nxt2[y][i]))%mod;
        }
    return ++f[x][y];
}
```




---

## 作者：楯山文乃 (赞：19)

我们先思考，当只有一个序列时，如何求出其有多少个不重复的子序列？显然可以定义F[I]表示这个序列的前I位有多少个不同的子序列，转移方程很简单，因为第I个字母可以接在某序列的后面，也可以不接，自然就是F[I]=F[I-1]\*2。这样我们会发现答案就是2^长度。但是，这显然是错的。因为我们没有判重！


要知道如何去重，就必须知道出现重复序列的原因！


设当前位S[I]=’a’，并且存在一个最大的J，使得J<I且S[J]=‘a’，那么当阶段在J的时候，我们可以选择是够让F[J-1]个序列接上S[J]。同理，阶段在I的时候，可以选择是否让F[I-1]个序列接上S[I]。显然，F[I-1]包含了所有F[J-1]的序列，如果F[J-1]个序列在J选择了接的那一部分在I时选择不接，在J选择不接的那部分在I选择了接，这样就产生了重复的串！所以我们要做的就是让同一个序列不要同时面临两个一样的决策！所以，当阶段在I的时候，我们得到F[I]=F[I-1]\*2，其中是包括了个F[J-1]个序列的重复决策，所以需要减去这些重复的序列，最终得到正确的转移方程：F[I]=F[I-1]\*2-F[J-1]。


现在我们可以将问题扩展到复杂情况了，有类似的思想，可以轻易想到转移方程，当A[I]=B[J]=C[K]时，显然


F[I,J,K]=F[I-1，J-1，K-1]\*2-F[II-1，JJ-1，KK-1]，其中II、JJ、KK分别为三个序列在I、J、K位前的最靠近该位的位置，并且A[I]=A[II],B[J]=B[JJ],C[K]=C[KK]。貌似到此问题得到解决了，但是写程序的时候会发现，多序列和单序列还是有不同的！


多序列和单序列不同之处在于：多序列需要考虑字符不相等的时候的转移！必须将前面的状态全部转移过来，又不能重复，有什么思想可以解决？？


容斥原理！！


所以可以得到状态转移方程：



F[I,J,K]=

F[I-1,J,K]+F[I,J-1,K]+F[I,J,K-1]


-F[I-1,J-1,K]-F[I-1,J,K-1]-F[I,J-1,K-1]


+F[I-1,J-1,K-1]。


---

## 作者：超级玛丽王子 (赞：17)

[在窝的博客食用更佳](https://www.luogu.com.cn/blog/LXLDuliu-IAKIOI/solution-p1819)

大家好，本蒟蒻又来写题解了。本题解可以看做对 @神之右大臣 巨佬的[题解](https://www.luogu.com.cn/blog/_post/201841)的补充。（注：本文部分内容引用自[此文](https://www.cnblogs.com/codancer/p/12232389.html)）

这次这道题目所使用的算法是**序列自动机**，其最直接的作用是查找某个字符串是否是另一个字符串的子序列。下面给大家普及一下。

首先要清楚的是，序列自动机完全不像 `AC 自动机`，`后缀自动机` 那样高大上，本质上就是一个牺牲空间换时间的字符串记忆。~~百度百科甚至都没有这个词条~~

我们定义 $nxt_{i,j}$ 表示从字符串第 $i$ 个位置开始，第 $j$ 个字符首次出现的位置。可以粗略的理解成一下 C艹 代码：
```cpp
string s="abcdefg",s2=s.substr(i,c.end-c-i);
nxt[i][j]=s2.find(j+'a')+i;
```
那么我们的预处理就很清晰了，倒着遍历更新即可：
```cpp
const int inf=0x3f3f3f3f;
int nxt[N][27];
void init(char *s) {
	int l=strlen(s);
    for(int i=0;i<26;i++) nxt[l][i]=inf;
    for(int i=l-1;i>=0;i++) { //倒着枚举起点
    	for(int j=0;j<26;j++) //枚举字母
        	nxt[i][j]=nxt[i+1][j];
        nxt[i][s[i]-'a']=i //更新当前位置的nxt
    }
}
```
查询时，我们令指针 $p=-1$，然后每次 $p$ 都跳转到 $nxt_{p+1,j}$ 的位置。如果 $p$ 所在的 $nxt$ 值为 $inf$，说明母串中不存在子串这一个字符，故返回 `false`：
```cpp
bool find(char *t) {
	int p=-1,l=strlen(t);
    for(int i=0;i<l;i++) {
    	p=nxt[p+1][t[i]-'a'];
        if(p==inf) return false;
    }
    return true;
}
```

那么在这道题里怎么办呢？答案是记忆化搜索。

我们令 $dp[x][y][z]$ 为三个字符串中分别从 $x,y,z$ 为起点的相同子序列个数。那么我们就可以枚举每一个字母，如果三个字符串中都能找到这个字母，那么记忆化，进一步 `dfs` 即可。也就是说，如果字母为 $i$ 且 `nxta[x][i]&nxtb[y][i]&nxtc[z][i]` 那么就可以 `dfs`。最后，只要当前 $x,y,z$ 不全为 $0$，就将 $dp[x][y][z]$ 增加一（即当前位置这个子序列）。

# 最后提醒大家，千万别忘了取模！

完结撒花~

看我写的这么详细，**不点个赞再走嘛？~**

---

## 作者：DarkClever (赞：5)

## 问题引入

> 如果我们需要一种算法，使其可以将一个字符串的所有子序列表示为一个 DAG（即有向无环图），我们该如何构建？

## 构建

钦定 $n$ 为字符串的长度，$\Sigma$ 为字符集，$S$ 为字符串，且 $S$ 只会包含小写字母。

我们定义 $nxt_{i,j} (i \leq n,j \in \Sigma)$ 为在 $i$ 位置之后第一个 $j$ 字符出现的位置。

那么我们很容易得出构建方法：

```cpp
struct SequentialAutomaton {
    int nxt[N][M];
    void init(string s){
        for(int i=s.length()-1;i>=0;i--){//从后往前遍历
            for(int j=1;j<=26;j++)nxt[i][j] = nxt[i+1][j];//将nxt数组从 i+1 转移至 i
            if(s[i] <= 'z' && 'a' <= s[i])nxt[i][s[i] - 'a' + 1] = i + 1;//并且更新状态，从下一个字符转移过来
            //我的nxt数组是从 1 开始的，所以从 s_i（对应了字符串第 i+1 个字符）转移
        }
    }
};
```


时间复杂度为 $O(n|\Sigma|)$，空间复杂度亦为 $O(n|\Sigma|)$。

显然，$nxt_i$ 只会指向 $j(j>i)$，所以这是一个 DAG。

构建完这个 DAG 后，它能做什么呢？

## 应用

### 寻找子序列/子序列匹配

这个十分简单，只需要在 DAG 上贪心的往后跳即可，因为如果 $i$ 无法跳到 $k$，那么 $j(j>i)$ 也一定无法跳到 $k$。

```cpp
vector<int> Find(string x){
    int pt = 0,i = 0;//pt为当前匹配到的子序列中的位置，i当前字符串s1中跳到的位置
    vector<int> xl;//储存答案的vector
    while(pt!=x.length()){
        if(s1.nxt[i][x[pt] - 'a' + 1])//如果能跳，就贪心的跳 
            i = s1.nxt[i][x[pt] - 'a' + 1],pt++,xl.push_back(i);
        else
            return vector<int>();//如果找不到返回一个空的vector
    }
    return xl;//返回答案
}
```


时间复杂度为 $O(l)$，其中 $l$ 为 $x$ 的长度。

### 寻找一个子序列的出现次数

很简单，只要我们除了向后跳之外，我们也可以向下一个相同的找，就可以遍历到他每一个出现的情况。

```cpp
int dfs(string x,int i = 0,int pt = 0){
    int anss = 0;
    //有两种可能
    //第1种，向后跳，此时将pt++
    if(pt != x.length() && s1.nxt[i][x[pt] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt] - 'a' + 1],pt+1);
    }
    //第2种，跳到下一个跟自己一样的
    if(pt>0 && s1.nxt[i][x[pt - 1] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt - 1] - 'a' + 1],pt);
    }
    if(pt == x.length()){
        //找完了
        return anss+1;
    }
    //此处注意到自己是由 pt-1 跳过来的
    return anss;
}
```


然后呢，我们发现时间复杂度是极高的，很容易**超出时间限制**，所以我们需要进行优化。

这个时候，我们就需要使用——记忆化搜索！

借助记忆化搜索，我们只用多开一个 $O(nl)$ 的数组，就可以将时间复杂度压缩到 $O(nl)$ 以下。

```cpp
int dfs(string x,int i = 0,int pt = 0){
    if(f[i][pt]){
        return f[i][pt];
    }
    int anss = 0;
    //有两种可能
    //第1种，向后跳，此时将pt++
    if(pt != x.length() && s1.nxt[i][x[pt] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt] - 'a' + 1],pt+1);
    }
    //第2种，跳到下一个跟自己一样的
    if(pt>0 && s1.nxt[i][x[pt - 1] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt - 1] - 'a' + 1],pt);
    }
    if(pt == x.length()){
        //找完了
        return anss+1;
    }
    //此处注意到自己是由 pt-1 跳过来的
    f[i][pt] = anss;//记忆答案
    return anss;
}
```


### 统计本质不同子序列数量

我们可以考虑直接深搜，统计所有可能的子序列，并且使用记忆化搜索即可。

```cpp
int f[N];
int dfs(int x){
    if(f[x])//还是记忆化搜索
        return f[x];
    for(int i=1;i<=26;i++)
        if(s1.nxt[x][i]) 
            f[x] += dfs(s1.nxt[x][i]);//进行转移即可
    if(x)//这里的判断是为了不统计空序列
        f[x]++;
    return f[x];
}
```


时间复杂度是 $O(n|\Sigma|)$，非常简单。

### 统计多个字符串之间公共子串数量

例题：P1819 和 P3856

终于进入正题了，这两道题除了取模和有一题要多输入一个长度之外没有区别，就一起讲了。

我们考虑直接对**统计本质不同子序列数量**进行改造，如果 $s1.nxt_{x,i} \land s2.nxt_{y,i} \land s3.nxt_{z,i}$，则将 $x,y,z$ 分别跳向 $s1.nxt_{x,i},s2.nxt_{y,i},s3.nxt_{z,i}$ 即可。

当然，我们仍然要使用记忆化搜索优化，空间复杂度为 $O(n^3)$，时间复杂度为 $O(n^3|\Sigma|)$。

```cpp
int f[N][N][N];
int dfs(int x,int y,int z){
    if(f[x][y][z])//记~忆~化~搜~索~
        return f[x][y][z];
    for(int i=1;i<=26;i++)
        if(s1.nxt[x][i] && s2.nxt[y][i] && s3.nxt[z][i]) 
            f[x][y][z] += dfs(s1.nxt[x][i] , s2.nxt[y][i] , s3.nxt[z][i]);
    if(x && y && z)//为了不统计空序列（当然你也可以在输出答案时减一）
        f[x][y][z]++;
    return f[x][y][z];
}
```


好了，序列自动机以及这道题目就讲到这里 byebye~

---

## 作者：jyz666 (赞：5)

# 题解 P1819 【公共子序列】

[传送门](https://www.luogu.com.cn/problem/P1819)

~~文末有小彩蛋~~

------------

这是我们机房模拟赛的一道题。
~~当时花了3个小时就写了这题QAQ~~

这道题一开始我还想把它分作两组来求公共子序列，发现~~我不会~~不如直接并作一个三维$dp$，也就是楼上大佬说的序列自动机！

在这里，序列自动机的构造方法的继承我用了memcpy函数来写。

什么是memcpy？

**memcpy指的是C和C++使用的内存拷贝函数，函数原型为**
```cpp
void *memcpy(void *destin, void *source, unsigned n)；
```
**函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中，即从源source中拷贝n个字节到目标destin中。**

——来自百度百科

这样写显然短了许多，也更明了了。

再写一下状态转移方程

```cpp
dp[a[i][p]][b[j][p]][c[k][p]]+=dp[i][j][k]
```

### 》》上代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>

using namespace std;
typedef long long ll;
#define INF 1e19
#define inf 0x7fffffff

inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
inline void read(ll &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
const int maxn=5e6+10;
const int mod=1e8;
ll n;
char s[250],ss[250],sss[250];
ll dp[250][250][250];
ll a[250][26],b[250][26],c[250][26];
ll ans;
int main(){
//	freopen("zwieback.in","r",stdin);
//	freopen("zwieback.out","w",stdout);
	read(n);
	scanf("%s%s%s",s+1,ss+1,sss+1);
	for(int i=0;i<26;++i)a[n][i]=b[n][i]=c[n][i]=n+1;//补全有向图
	for(int i=n-1;i>=0;i--){
		memcpy(a[i],a[i+1],sizeof(a[i]));//对前一个i位置的继承
		memcpy(b[i],b[i+1],sizeof(b[i]));
		memcpy(c[i],c[i+1],sizeof(c[i]));		
		a[i][s[i+1]-'a']=i+1;//第i个位置往后第一个元素出现的位置
		b[i][ss[i+1]-'a']=i+1;
		c[i][sss[i+1]-'a']=i+1;
	}
	dp[0][0][0]=1;
	for(int i=0;i<n;++i){
		for(int j=0;j<n;++j){
			for(int k=0;k<n;++k){
				for(int p=0;dp[i][j][k] && p<26;++p){
					(dp[a[i][p]][b[j][p]][c[k][p]]+=dp[i][j][k])%=mod;
				}
			}
		}
	}
	ans=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			for(int k=1;k<=n;++k){
				(ans+=dp[i][j][k])%=mod;
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

双倍经验：[小彩蛋](https://www.luogu.com.cn/problem/P3856)

 _**私の歩みは遅くとも、引き返すことは決してない。**_ 

---

## 作者：XiaoQuQu (赞：2)

一道萌萌题。

设 $f_{i,j,k}$ 表示从第一个字符串的 $i$ 位置开始，第二个字符串的 $j$ 位置开始，第三个字符串的 $k$ 位置开始，剩下的公共子序列的个数。

对于每个字符串，预处理 $nxt_{i,ch}$ 表示在 $i$ 之后，字符 $ch$ 第一次出现的位置，这个东西的预处理是简单的：

1. $s_{i+1}=ch$，有 $nxt_{i,ch}=i+1$；
2. $s_{i+1}\ne ch$，有 $nxt_{i,ch}=nxt_{i+1,ch}$。

如果当 $i$ 后无 $ch$ 字符，则认为 $nxt_{i,ch}=+\infty$。

这样，我们就可以很方便的转移，对于 $f_{i,j,k}$，枚举下一个相同的字符 $ch$，有 $f_{i,j,k}=\sum\limits_{ch}f_{nxt1_{i,ch},nxt2_{j,ch},nxt3_{k,ch}}$。

实际实现中推荐使用记忆化搜索。

```cpp
const int MAXN = 155, mod = 1e8, inf = 1e18;
char s[4][MAXN];
int nxt[4][MAXN][26], n, dp[MAXN][MAXN][MAXN];

void mknxt(int x) {
	for (int i = 0; i < 26; ++i) nxt[x][n][i] = inf;
	for (int i = n - 1; i >= 0; --i) {
		for (int j = 0; j < 26; ++j) nxt[x][i][j] = nxt[x][i + 1][j];
		nxt[x][i][s[x][i + 1] - 'a'] = i + 1;
	}
}

int dfs(int x, int y, int z) {
	if (dp[x][y][z]) return dp[x][y][z];
	int ret = 1;
	for (int i = 0; i < 26; ++i) {
		int p1 = nxt[1][x][i], p2 = nxt[2][y][i], p3 = nxt[3][z][i];
		if (p1 == inf || p2 == inf || p3 == inf) continue;
		ret = (ret + dfs(p1, p2, p3)) % mod;
	}
	return dp[x][y][z] = ret;
}

void work() {
	cin >> n;
	for (int i = 1; i <= 3; ++i) cin >> (s[i] + 1);
	mknxt(1); mknxt(2); mknxt(3);
	cout << (dfs(0, 0, 0) - 1 + mod) % mod << endl;
}
```


---

## 作者：xiezheyuan (赞：2)

## 简要题意

给出三个由小写英文字母组成的字符串 $A,B,C$。求这三个字符串的本质不同公共子序列个数。

$n=|A|=|B|=|C|,1 \leq n \leq 150$，答案对 $10^8$ 取模。

## 思路

对于子序列问题，我们先建出子序列自动机。这里简单介绍一下子序列自动机是什么：

对于一个字符串 $S$，令 $F(i,j)$ 为 $[i+1,|S|]$ 中最小的 $k$，使得 $S_k=j$。则 $F(i,j)$ 就是我们要求的子序列自动机。

$F(i,j)$ 有一个 $O(|S|W)$ 的做法（$W$ 为 $S$ 中字符集大小）。我们逆推，不难发现以下结论：

$$
F(i,j)=\begin{cases}
0&i=|S|\\
i+1&(j=S_{i+1})\\
F(i+1,j)&(j\neq S_{i+1})
\end{cases}
$$

注意 $i$ 可以为 $0$。此时指向的是最前的为 $j$ 的位置。可以在字符串开头字符不同时充当相同的开头。

然后就可以 $O(|S|W)$ 递推了。

然后我们回到本题。考虑 dp，令 $f(i,j,k)$ 表示考虑到 $A[i:|A|],B[j:|B|],C[k:|C|]$ 的公共子序列数。那么答案就是 $f(0,0,0)$。

考虑如何转移。如果 $i,j,k$ 后继都有一个相同的字符（至于如何判断相同的字符，可以构造 $A,B,C$ 的子序列自动机 $F,G,H$），那么就是一个公共子序列，可以转移。最后自己本身也是一个子序列（注意当 $i,j,k$ 为 $0$ 时这不是一个子序列）也就是：

$$
f_{i,j,k}=[ijk \neq 0]+\sum_{s=\texttt{a}}^{\texttt{z}}[F(i,s)G(i,s)K(i,s) \neq 0]f(F(i,s),G(i,s),K(i,s))
$$

然后这道题就做完了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 155;
int n;
string a,b,c;
int f[N][27],g[N][27],h[N][27],dp[N][N][N];
const int MOD = 1e8;

inline int M(const int &x){
	return (x%MOD+MOD)%MOD;
}

inline void build(){
	for(int i=n;i;i--){
		for(int j=1;j<=26;j++){
			f[i-1][j]=f[i][j];
			g[i-1][j]=g[i][j];
			h[i-1][j]=h[i][j];
		}
		f[i-1][a[i]-'a'+1]=i;
		g[i-1][b[i]-'a'+1]=i;
		h[i-1][c[i]-'a'+1]=i;
	}
}

int F(int i,int j,int k){
	if(dp[i][j][k]) return dp[i][j][k];
	for(int s=1;s<=26;s++){
		if(f[i][s] && g[j][s] && h[k][s]) dp[i][j][k]=M(dp[i][j][k]+F(f[i][s],g[j][s],h[k][s]));
	}
	if(i || j || k) dp[i][j][k]++;
	return dp[i][j][k]=M(dp[i][j][k]);
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>a>>b>>c;
	a=" "+a;b=" "+b;c=" "+c;
	build();
	cout<<F(0,0,0)<<'\n';
	return 0;
}
```

---

## 作者：SAMSHAWCRAFT (赞：2)

关键词：子序列，动态规划。

题意是给定三个长度均为 $n$ 的字符串，求三个字符串中相同非空子序列的个数，$n\le 150$，记字符集为 $V$，$V$ 为小写字母集。

我们考虑用 DP 解决序列问题，设计状态 $f(i,j,k)$ 表示 $a$ 串前 $i$ 个字母、$b$ 串前 $j$ 个字母、$c$ 串前 $k$ 个字母对应的三个序列的相同非空子序列个数。我们在进行转移时，发现只要在三个串后面跟上同一个字符即可，如果我们维护一个 $\mathtt{nxt(}a,i,p\mathtt{)}$ 表示 $a$ 串第 $i$ 个字母后面（不含第 $i$ 个字符）部分对应串中第一次出现的 $p$ 的位置，那么可以用填表法的思想写出下面的转移（方程不好用数学语言描述，就放上代码吧）：

```cpp
dp[0][0][0]=1;
for(int cx=0;cx<n;++cx)
  for(int cy=0;cy<n;++cy)
    for(int cz=0;cz<n;++cz)
      for(int p=0;dp[cx][cy][cz]!=0&&p<vsz;++p)
        (dp[nxta(p,cx)][nxtb(p,cy)][nxtc(p,cz)]+=dp[cx][cy][cz])%=mod;
```

注意这里的串是以 $1$ 为字符串首位下标的。有人可能会问，为什么一定要选第一次出现的位置呢？这里用到了一点贪心思想，我们要求的是所有的相同非空子序列，我们只要从串的后面选一个出现的位置就可以，但是如果我们选了第一个，那么转移后的 $\mathtt{nxt(}a,i,p\mathtt{)}$ 会最小化，这样以后转移的时候留下的空间会更大，如果选择了第二次出现及以后出现的位置，则一定不优于选第一次出现的位置。

最后统计答案就是这样的了：

```cpp
for(int cx=1;cx<=n;++cx)
  for(int cy=1;cy<=n;++cy)
    for(int cz=1;cz<=n;++cz)
      (ans+=dp[cx][cy][cz])%=mod;
```

之前 $\mathtt{nxt}$ 的维护没有讲到，这里提一下，我们给每个字符串开 `std::vector` 的数组，一个位置 $i$ 上如果出现字母 $c$，就给 $c$ 对应的 `std::vector` 添加一个 $c$ 就好了，也就是下面这样：

```cpp
for(int cx=1;cx<=n;++cx)
  exa[a[cx]-'a'].push_back(cx),
  exb[b[cx]-'a'].push_back(cx),
  exc[c[cx]-'a'].push_back(cx);
```

然后查询 $\mathtt {nxt}$ 的时候只需要在 `std::vector` 上二分就好啦：

```cpp
inline int nxta(int ch,int id){
  auto it=std::lower_bound(exa[ch].begin(),exa[ch].end(),id+1);
  return (it==exa[ch].end())?n+1:*it;
}
```

另附：[提交记录](https://www.luogu.com.cn/record/76777736)，想要完整代码可以找我要。

---

## 作者：Furina_Saikou (赞：0)

# 序列自动机

听上去挺高大上的，其实就是个很简单的东西，对于一个字符串 $s$，$f_{i,j}$ 表示 $s$ 的第 $i$ 个字符往后（不包括 $i$）第一个字符 $j$ 的位置，若没有则为 $n+1$。

我们可以通过逆序处理出这个 $f$ 数组：

```cpp
int x[26];
for(int i=0;i<26;i++)x[i]=n+1;
for(int i=n;i;i--)
{
	for(int j=0;j<26;j++)f[i][j]=x[j];
	x[a[i]-'a']=i;
}
for(int i=0;i<26;i++)
{
	f[0][i]=x[i];//将0设为所有字母第一次出现的位置，方便作为dp的起点。
}
```

通过这个序列自动机，我们把序列变成了一个有向无环图，于是我们就可以在上面跑动规了。

# 动规思路

计算三个字符串 $a,b,c$ 的公共子序列数，考虑递推的方法，$dp_{i,j,k}$ 表示以 $a_i,b_j,c_k$ 为结尾的公共子序列的数量，显然应有 $a_i=b_j=c_j$。

- 对于边界，设 $dp_{0,0,0}=1$，在预处理三个字符串的序列自动机后，我们可以轻松的将初始状态转移。

- 对于转移状态，我们枚举三个字符串的下标 $i,j,k$，再枚举下一个要接上的字母 $l$，通过 $f$ 数组，我们能够知道当前状态要转移到的下一个状态的三个下标并完成转移，详见代码。

最后统计答案时只要将所有的 $dp_{i,j,k}$ 加和即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200,mod=1e8;
int n,s1[N][26],s2[N][26],s3[N][26],dp[N][N][N],ans;
char a[N],b[N],c[N];
inline void build(char a[N],int s[N][26])
{
	int x[26];
	for(int i=0;i<26;i++)x[i]=n+1;
	for(int i=n;i;i--)
	{
		for(int j=0;j<26;j++)s[i][j]=x[j];
		x[a[i]-'a']=i;
	}
	for(int i=0;i<26;i++)
	{
		s[0][i]=x[i];
	}
}
signed main()
{
	cin>>n>>(a+1)>>(b+1)>>(c+1);
	build(a,s1),build(b,s2),build(c,s3);
	dp[0][0][0]=1;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			for(int k=0;k<n;k++)
			{
				for(int l=0;l<26;l++)
				{
					dp[s1[i][l]][s2[j][l]][s3[k][l]]=(dp[s1[i][l]][s2[j][l]][s3[k][l]]+dp[i][j][k])%mod;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=n;k++)
			{
				ans=(ans+dp[i][j][k])%mod;
			}
		}
	}
	cout<<ans;
}
```

- 关于以上代码中枚举的细节，在状态转移时，从 $0$ 开始枚举三个下标只是为了方便将初始状态从 $dp_{0,0,0}$ 转移，仅此而已，可以通过改变边界设置的方法来改为从 $1$ 开始枚举。在转移时我选择通过当前状态转移到下一个状态，而不是从上一个状态转移到当前状态，否则需改变序列自动机的方向。

- 为什么程序可以自动避免重复的子序列？因为初始值只会给到第一次出现的那些字母，再根据转移的方法，我们只会在已有的子序列后面接上新字母，所以已经出现过的子序列是不会再出现的。

---

## 作者：OldDriverTree (赞：0)

# Solution

对三个串建出子序列自动机，考虑在子序列自动机上 $\text{DP}$，设 $f_{x,y,z}$ 表示子序列当前在三个子序列自动机上分别走到了 $x,y,z$ 这三个状态，继续走能形成多少种子序列。

转移就为 $f_{x,y,z}=1+\sum\limits_{c\in\Sigma} f_{nxt_{0,x,c},nxt_{1,y,c},nxt_{2,z,c}}$。

注意这个值是包含空子序列的，所以最后答案要减去 $1$。

时间复杂度为 $O(n^3\vert\Sigma\vert)$。
# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
const int N=151,mod=1e8;
int nxt[3][N][26];
int n,f[N][N][N];
char s[3][N];

int read() {
	int x=0; bool f=true; char c=0;
	while (!isdigit(c) ) f&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?x:-x;
}
int solve(int x,int y,int z) {
	if (f[x][y][z]) return f[x][y][z]; f[x][y][z]=1;
	for (int i=0;i<26;i++) if (nxt[0][x][i]&&nxt[1][y][i]&&nxt[2][z][i])
	f[x][y][z]=(f[x][y][z]+solve(nxt[0][x][i],nxt[1][y][i],nxt[2][z][i]) )%mod;
	return f[x][y][z];
}
main()
{
	n=read();
	for (int i=0;i<3;i++)
	{
		scanf("%s",s[i]+1);
		for (int j=n;j;j--) {
			for (int k=0;k<26;k++)
			nxt[i][j-1][k]=nxt[i][j][k];
			nxt[i][j-1][s[i][j]-'a']=j;
		}
	}
	printf("%lld",(solve(0,0,0)+mod-1)%mod);
	return 0;
}
```

---

## 作者：happybob (赞：0)

我们建立出序列自动机后，令 $f_{x,y,z}$ 表示在三个子序列自动机分别到达 $x,y,z$ 后，能往后走子序列的数量。

容易发现对于现在在 $x,y,z$ 的三个点，我们只需要往外枚举 $26$ 个节点，并且记忆化即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 155, MOD = 1e8;

long long dp[N][N][N];
int nxt[26];
string a, b, c;
vector<int> v[26];

class Dag
{
public:
	int son[N][26];
}g1, g2, g3;

void build(string &s, Dag& d)
{
	int n = s.size();
	for (int i = 0; i < 26; i++) nxt[i] = 1, v[i].clear();
	for (int i = 0; i <= n; i++)
	{
		for (int j = 0; j < 26; j++)
		{
			for (int k = nxt[j]; k <= n; k++)
			{
				nxt[j] = k;
				if (k <= i) continue;
				if (s[k - 1] - 'a' == j)
				{
					d.son[i][j] = k;
					//cout << i << " " << j << " " << k << "\n";
					break;
				}
			}
		}
	}
}

long long dfs(int x, int y, int z)
{
	if (dp[x][y][z]) return dp[x][y][z];
	dp[x][y][z] = 1;
	for (int i = 0; i < 26; i++)
	{
		int nx = g1.son[x][i], ny = g2.son[y][i], nz = g3.son[z][i];
		if (nx && ny && nz)
		{
			dp[x][y][z] += dfs(nx, ny, nz);
			dp[x][y][z] %= MOD;
		}
	}
	return dp[x][y][z];
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
	cin >> a >> a >> b >> c;
	build(a, g1);
	build(b, g2);
	build(c, g3);
	cout << dfs(0, 0, 0) - 1 << "\n";
	return 0;
}
```


---


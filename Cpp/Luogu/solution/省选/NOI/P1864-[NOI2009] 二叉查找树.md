# [NOI2009] 二叉查找树

## 题目描述

已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。

另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。

已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。

一个结点在树中的深度定义为它到树根的距离加 $1$。因此树的根结点的深度为 $1$。

每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。

现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出 $K$ 的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/10bjubxe.png)

输入的原图是左图，它的访问代价是 $1 \times 1+2 \times 2+3 \times 3+4 \times 4=30$。

最佳的修改方案是把输入中的第 $3$ 个结点的权值改成 $0$，得到右图，访问代价是：$1 \times 2+2 \times 3+3 \times 1+4 \times 2=19$，加上额外修改代价 $10$，一共是 $29$。

### 数据范围

- 对于 $40\%$ 的数据，满足 $N \leq 30$；
- 对于 $70\%$ 的数据，满足 $N \leq 50$；
- 对于 $100\%$ 的数据，满足：$1 \leq N \leq 70$，$1 \leq K \leq 3 \times 10^7$。


## 样例 #1

### 输入

```
4 10
1 2 3 4
1 2 3 4
1 2 3 4
```

### 输出

```
29```

# 题解

## 作者：ωαηg (赞：52)

感觉前面的几篇题解讲得不是很清晰啊，那么我根据前面几篇题解的意思（主要是@ [吴逊](https://www.luogu.org/space/show?uid=39597) 的题解），来补一发大家都能看懂的。

----

### 性质

拿到这道题，我们首先来发掘性质。

>  你可以把结点的权值改为任何**实数**。

>  输入的权值**各不相同**。

> 我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。（也就是说，访问代价与结点的权值**无关**。）

以上三点，说明了什么？

这条规则：

>  但是修改后所有结点的权值必须仍保持互不相同。

**无效。**

读入的权值不会相同，这就说明：如果我们在最终得到的状态中有两个结点的权值是一样的，那么肯定有一个是修改过来的。而实数完全是可以搞出无限接近但是不相同这种操作的，又因为最终的答案与结点的权值是无关的，所以如果我们把权值相同的那个改成无限接近但不相同，还是可以得到一样的结果。如果最终得到的状态中有多个权值相同，也是同理。所以这条规则有和没有是一样的，没有任何约束力，我们可以直接把它无视掉。



再来发掘一个性质：

学过平衡树的同志们应该很清楚了，题目中给我们的是一棵**Treap**，而我们修改权值的操作会导致Treap的**旋转**。我们的目标就是通过恰当的旋转方法使得最后得到的代价总和最小。

而二叉查找树又有一个性质：**二叉查找树的中序遍历是其代表的序列从小到大排序的结果。**

而无论Treap如何旋转，其都是一棵二叉查找树，因此，**无论我们怎么改变数的权值，这棵树的中序遍历还是不会变的。**

根据“中序遍历不变”这一原理，我们的DP就可以写出来了。

----

### DP

首先我们要把每个节点的权值给离散化了，方便等下的处理。

然后，我们求出这棵树的中序遍历——也就是把所有节点按照数据值从小到大排序。

1 状态 $f[i][j][k]$表示将中序遍历中$i..j$这段节点形成一棵树，要求所有节点的权值$\geq k$，这棵树的修改代价+访问代价最小是多少

2 转移 我们考虑让哪一个节点做根节点

我们从$i$到$j$枚举一个$t$，表示我们假设让$t$做这棵树的根节点

那么，我们再来考虑是否要修改$t$这个节点的权值。

如果不要修改：（前提是$t$这个点的权值本来就$\geq k$）

$$f[i][j][k]=min(f[i][j][k],f[i][t-1][\text{t的权值}]\text{（左子树）}+f[t+1][j][\text{t的权值}]\text{（右子树）}+\text{i..j所有节点的访问频度之和})$$

注意，那个规则已经无效了，所以我们方程里写的是t的权值而不是t的权值+$1$

稍微解释一下那个“$\text{i..j所有节点的访问频度之和}$"：

这个其实是访问代价。

我们知道，访问代价的计算方法是深度$\times$访问频度

我们可以转化一下，随着我们计算时树的深度步步提高，我们在计算每一深度时将所有深度$\geq$当前深度的节点的访问频度全部加一遍。最后把每个深度加上的访问频度合起来就是所有节点的深度$\times$访问频度的总和。我们当前这棵树是由$i..j$这些节点构成的，而我们现在在第一层，因为所有节点的深度都$\geq 1$，所以我们加上所有节点的访问频度。等会我们去DP$i..t-1$子树的时候，就又会再把$i..t-1$这些结点的访问频度再加一遍。。。以此类推，最后我们就会得到所有节点的深度$\times $访问频度之和了。

~~我好啰嗦啊。~~

如果要修改：

$$f[i][j][k]=min(f[i][j][k],f[i][t-1][k]+f[t+1][j][k]+K+\text{i..j所有节点的访问频度之和})$$

因为整棵树中所有节点的权值都比$t$要大，而且要大于等于$k$，所以直接把$t$的权值修改为$k$是最优的。

3 初始 除了$f[i][i-1][k]=0$之外，全部都是$inf$

4 答案 显然是$f[1][n][1]$

**问：为什么不是$f[1][n][0]$或者$f[1][n][2]$之类的东西？**

**答：$f[1][n][0]$是可以的，因为$0\leq 1$，但是$f[1][n][2]$不一定可行。因为我们在将权值离散化之后权值的范围是$[1,n]$，你不能强制地让它们都$\geq 2$。**

**问：那$f[1][n][-1]$是不是也可以？**

**答：可以。但是像$f[1][n][0]$、$f[1][n][-1]$这种完全没有必要，会增加计算复杂度。**

**问：为什么你那么啰嗦？**

**答：。。。**

时间复杂度是$O(n^4)$，可以通过本题$70$的数据范围。

----

### 代码

啊哈，我的代码看起来会和@[吴逊](https://www.luogu.org/space/show?uid=39597)和@[18811162081lyh](https://www.luogu.org/space/show?uid=65531)的代码很像。

~~因为我是看了他们的题解才做出来的。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
    int sum=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)){
        sum=sum*10+(c^48);
        c=getchar();
    }
    return sum;
}
int const maxn=75;
struct node{
    int num, quan, pin;
    //数据值  权值 访问频度
}a[maxn];
inline bool cmp(node x,node y){
    return x.num<y.num;
}
int n,K,b[maxn],sum[maxn],f[maxn][maxn][maxn];
signed main(){
    n=read(),K=read();
    for(int i=1;i<=n;i++)
      a[i].num=read();
    for(int i=1;i<=n;i++)
      b[i]=a[i].quan=read();
    for(int i=1;i<=n;i++)
      a[i].pin=read();
    sort(a+1,a+n+1,cmp);//按照数据值从小到大排序，得到中序遍历
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++){
        a[i].quan=lower_bound(b+1,b+n+1,a[i].quan)-b;
        sum[i]=sum[i-1]+a[i].pin;
    }
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n+1;i++)
      for(int k=1;k<=n;k++)
        f[i][i-1][k]=0;
    for(int i=n;i>=1;i--)
      for(int j=i;j<=n;j++)
        for(int k=1;k<=n;k++)
          for(int t=i;t<=j;t++){
              if(a[t].quan>=k) 
                f[i][j][k]=min(f[i][j][k],f[i][t-1][a[t].quan]+f[t+1][j][a[t].quan]+sum[j]-sum[i-1]);
              f[i][j][k]=min(f[i][j][k],f[i][t-1][k]+f[t+1][j][k]+K+sum[j]-sum[i-1]);
          }
    cout<<f[1][n][1]<<endl;
    return 0;
}
```

---

## 作者：吴逊 (赞：17)

这题的条件非常多也非常乱，所以我们要先挖掘一些性质，尽量的找到一个解决问题的顺序。可以发现所谓的数据值和权值其实就是一棵treap，改变权值相当于treap的旋转，由于数据值不变，所以中序遍历是不变的，所以我们可以按数据值排序，得到树的中序遍历。并且我们发现权值可以取所有实数，而且权值的大小与最后的答案无关，所以可以离散权值到[1,n]内。

然后我们考虑用fi,j,w表示i..j节点构成的树，且树中所有点的权值都≥w，然后我们考虑转移，枚举根k。

若k的权值Wk≥w，那么可以不用修改，有



fi,j,w=min{fi,j,w,fi,k−1,Wk+fk+1,j,Wk+sumi..j}

或者可以直接把k的权值修改为w，有


fi,j,w=min{fi,j,w,fi,k−1,w+fk+1,j,w+K+sumi,,j}

其中sumi..j表示i到j的访问频率之和。


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 100
using namespace std;
struct node {int x,y,z;} a[N];
pair<int,int> b[N];
int f[N][N][N];
int n,K;
inline int read()
{
    int a=0,f=1; char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}
    while (c>='0'&&c<='9') {a=a*10+c-'0'; c=getchar();}
    return a*f;
}
inline bool cmp(node a,node b)
{
    return a.x<b.x;
}
int main()
{
    n=read(); K=read();
    for (int i=1;i<=n;i++) a[i].x=read();
    for (int i=1;i<=n;i++) a[i].y=read();
    for (int i=1;i<=n;i++) a[i].z=read();
    sort(a+1,a+n+1,cmp);
    for (int i=1;i<=n;i++)
        b[i]=make_pair(a[i].y,i);
    sort(b+1,b+n+1);
    for (int i=1;i<=n;i++)
        a[b[i].second].y=i;
    for (int i=1;i<=n;i++)
        a[i].z+=a[i-1].z;
    memset(f,0x3f,sizeof(f));
    for (int i=1;i<=n+1;i++)
        for (int w=0;w<=n;w++)
            f[i][i-1][w]=0;
    for (int w=n;~w;w--)
        for (int i=n;i;i--)
            for (int j=i;j<=n;j++)
                for (int k=i;k<=j;k++)
                {
                    if (a[k].y>=w)
                        f[i][j][w]=min(f[i][j][w],f[i][k-1][a[k].y]+f[k+1][j][a[k].y]+a[j].z-a[i-1].z);
                    f[i][j][w]=min(f[i][j][w],f[i][k-1][w]+f[k+1][j][w]+K+a[j].z-a[i-1].z);
                }
    cout << f[1][n][0] << endl;
    return 0;
}
```

---

## 作者：18811162081lyh (赞：7)

```
/*首先，题目给出的数据结构是个treap，修改权值等价于treap的旋转，
题目相当于给出一个treap，通过改变其权值，求一个形态+修改代价的最小值 
由于旋转操作不改变树的中序遍历结果，所以我们先按照数据值排序，得到中序遍历 
然后考虑区间dp，令dp[i][j][k]表示区间[i,j]的所有权值都>=k的访问代价+修改代价最小值 
状态转移的时候要考虑根的情况，枚举根的所有可能性来转移：
dp[i][j][k] = min dp[i][x-1][k] + dp[x+1][j][k] + K + c(i,j)   修改x的权值为k 
                  dp[i][x-1][v[x]] + dp[x+1][j][v[x]] + c(i,j) 根节点x的权值>=k 
其中c(i,j)表示区间[i,j]内所有点的访问频度之和，可以用前缀和O(1)得出 
注意本题权值的取值范围是40万，太大了，要进行离散化以降低时空复杂度 */
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstirng>
#define MAXN 75
using namespace std;
typedef long long ll;
int n,K,sum[MAXN];
ll dp[MAXN][MAXN][MAXN];
struct node{
	int val,wei,fre;
}a[MAXN];//val是数据值，wei表示权值，fre是访问频度 
bool cmp1(const node &x,const node &y){
	return x.wei<y.wei;
}
bool cmp2(const node &x,const node &y){
	return x.val<y.val;
}
inline int Sum(int l,int r){
	return sum[r]-sum[l-1];
}
int main () {
	cin>>n>>K;
	for(int i=1;i<=n;i++){
		cin>>a[i].val;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].wei;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].fre;
	}
	sort(a+1,a+n+1,cmp1); //以权值排序 
	for(int i=1;i<=n;i++){
		a[i].wei=i;//对权值离散化
	}
	sort(a+1,a+n+1,cmp2);//以数据值排序，得到中序遍历 
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i].fre;
	}
	memset(dp,0x3f,sizeof(dp)); //初始化为INF
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n+1;i++){
			dp[i][i-1][k]=0;
		}
	}
	for(int i=1;i<=n;i++){  //i为区间长度 
		for(int l=1,r=l+i-1;r<=n;l++,r++){ //l,r是区间端点 
			for(int k=1;k<=n;k++){//[l,r]区间内的所有权值>=k 
				for(int x=l;x<=r;x++){//x为根节点 
					dp[l][r][k]=min(dp[l][r][k],dp[l][x-1][k]+dp[x+1][r][k]+Sum(l,r)+K);
					int v=a[x].wei;
					if(v>=k){
						dp[l][r][k]=min(dp[l][r][k],dp[l][x-1][v]+dp[x+1][r][v]+Sum(l,r));
					}
				}
			}
		}
	}
	cout<<dp[1][n][1]<<endl;
	return 0;
}
```

---

## 作者：PrimoPan (赞：5)

按数据值排序之后可得到中序遍历，把权值离散化到1~n中

然后区间dp

dp[i][j][k]表示i到j组成的树每个节点权值都>=k的最小代价

枚举x为根

则dp[i][j][k]=min((dp[i][x-1][k]+dp[x+1][j][k]+sump[j]-sump[i]+K))

(m需要修改权值）

dp[i][j][k]=min(dp[i][x-1][v(x)]+dp[x+1][j][v(x)]+sump[j]-sump[i])


---

## 作者：Randolph、 (赞：3)

```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
#define rint register int
#define min(a,b) (a<b? a:b)
using namespace std;
struct node{int x,y,z;}a[100];
int f[100][100][100];
int n,K;
inline int read()
{
    int w=1,ans=0;
    char ch=getchar();
    while(!isdigit(ch)) {if (ch=='-') w=-1; ch=getchar();}
    while(isdigit(ch)) {ans=(ans<<3)+(ans<<1)+(ch^48); ch=getchar();}
    return ans*w;
}
inline bool cmp(node a,node b)
{
    return a.y<b.y;
}
inline bool cmp2(node a,node b)
{
    return a.x<b.x;
}
int main()
{
    //freopen("tree.in","r",stdin);
    //freopen("tree.out","w",stdout);
    n=read();K=read();
    for (int i=1;i<=n;i++) a[i].x=read();//数据
    for (int i=1;i<=n;i++) a[i].y=read();//权值
    for (int i=1;i<=n;i++) a[i].z=read();//访问频度
    sort(a+1,a+n+1,cmp);//按权值排序，离散化
    for (int i=1;i<=n;i++) a[i].y=i;//将权值离散化
    sort(a+1,a+n+1,cmp2);
    for (int i=1;i<=n;i++) a[i].z+=a[i-1].z;//前缀和 
    memset(f,0x7f,sizeof f);
    for (int i=1;i<=n+1;i++)
     for (int w=0;w<=n;w++)
      f[i][i-1][w]=0;
      
    for (rint w=n;~w;w--)//~w指w非零，区间内所有权值大于w 
     for (rint i=n;i;i--)
      for (rint j=i;j<=n;j++)
       for (rint k=i;k<=j;k++)//区间dp枚举根节点位置
       {
         if (a[k].y>=w) 
          f[i][j][w]=min(f[i][j][w],f[i][k-1][a[k].y]+f[k+1][j][a[k].y]+a[j].z-a[i-1].z);
          //a[j].z-a[i-1].z：当树深加1，把每个访问频度都再加一次 
         f[i][j][w]=min(f[i][j][w],f[i][k-1][w]+f[k+1][j][w]+a[j].z-a[i-1].z+K);
       }
    printf("%d",f[1][n][1]);
    return 0;    
}
```

---

## 作者：翼德天尊 (赞：2)

第一眼看这个建树过程就有点类似于笛卡尔树。

回想一下笛卡尔树是怎么建树的？我们先将节点按照数据值排序，然后挑选当前区间内权值最小的节点作为根节点，再递归建左右子树。中序遍历序列已经有了，那么其实每一个区间都可以对应一棵子树。

我们不妨设 $dp_{l,r}$ 表示以中序遍历序列区间 $[l,r]$ 内的节点建成的子树中，代价的最小值。则转移显然就可以枚举一个中值作为根节点，两边区间作为左右子树进行转移，此时我们将整棵子树整体向下挪了一个深度，**额外代价**就是这个区间的访问频度之和。

但是我们发现这样会出现一个问题，我们不知道左右子树根节点的修改后的权值是多少，所以我们也无法确定当前根节点是否需要修改。

不知道，设出来就好了啊。不妨将 dp 数组的状态再加一维，设 $dp_{l,r,p}$ 表示以 $[l,r]$ 内的节点建成的子树中，**节点权值大于等于 $p$** 的最小代价，其中 $p$ 是可以离散化的。故我们在转移过程中，除了需要枚举根节点 $k$，还需要枚举 $p$，如果 $p$ 小于 $k$ 的权值，则可以不修改根节点权值进行转移；而修改根节点权值的转移则可以发生在任何情况。

时间复杂度 $O(n^4)$.

注意我们状态设计的是 **大于等于 $p$**，为什么不是等于 $p$ 呢？显然等于 $p$ 时我们在转移的过程中还需要枚举左右子树的权值具体是多少，大大浪费了时间复杂度，而大于等于 $p$ 的状态设计则**更加泛化**，转移时更加方便。这告诉我们设计状态时除了要关注**当前需要添加什么状态**，还需要关注**转移时需要考虑什么状态**，两者哪个时间复杂度更低就将哪个设进状态里。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=75;
int n,m,dp[N][N][N],s[N],lsh[N],ltot;
struct node{
	int shu,quan,pin;
}p[N];
int read(){
	int w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
bool cmp(node x,node y){
	return x.shu<y.shu;
}
int getsum(int l,int r){
	return s[r]-s[l-1];
}
signed main(){
	memset(dp,0x3f,sizeof(dp));
	n=read(),m=read();
	for (int i=1;i<=n;i++) p[i].shu=read();
	for (int i=1;i<=n;i++) lsh[i]=p[i].quan=read();
	for (int i=1;i<=n;i++) p[i].pin=read();
	sort(p+1,p+1+n,cmp);
	for (int i=1;i<=n;i++) s[i]=s[i-1]+p[i].pin;
	sort(lsh+1,lsh+1+n);
	ltot=unique(lsh+1,lsh+1+n)-lsh-1;
	for (int i=1;i<=n;i++){
		p[i].quan=lower_bound(lsh+1,lsh+1+ltot,p[i].quan)-lsh;
	}
	for (int i=1;i<=n+1;i++)
		for (int j=1;j<=n;j++)
			dp[i][i-1][j]=0;
	for (int len=1;len<=n;len++){
		for (int l=1;l<=n-len+1;l++){
			int r=l+len-1,sum=getsum(l,r);
			for (int k=l;k<=r;k++){
				for (int q=1;q<=p[k].quan;q++)
					dp[l][r][q]=min(dp[l][r][q],dp[l][k-1][p[k].quan]+dp[k+1][r][p[k].quan]+getsum(l,r));
				for (int q=1;q<=n;q++)
					dp[l][r][q]=min(dp[l][r][q],dp[l][k-1][q]+dp[k+1][r][q]+getsum(l,r)+m);
			}
		}
	}
	int ans=1e9;
	for (int i=1;i<=n;i++) ans=min(ans,dp[1][n][i]);//cout<<dp[1][n][i]<<"\n";
	cout<<ans<<'\n';
	return 0;
} 
```

---

## 作者：程门立雪 (赞：1)


#### 题解：

通过题目中，对树的描述：按照权值从小到大顺序插入结点所得到的按照数据值排序的二叉查找树，可以想到这是一棵 treap。改变权值相当于 treap 的左旋右旋，通过旋转会使结点的深度发生改变，从而影响最终的答案。

根据 treap 的性质，因为数据值不变，那么树的中序遍历也不会变， 而二叉搜索树的的中序遍历，就是数据值从小到大排序的结果。

接下来就可以 dp 了。

因为权值可以取任意的实数，而且最后的答案与权值无关，方便之后的处理可以将权值离散化。

**状态** ：设 $f(i,j,k)$​​​​​ 表示 $i$​​​​ 到 $j$​​​ ​​​节点组成了一棵树，其中权值都 $>= k$​​​, 所需要的代价为多少。
(第三维的权值是有离散化的，具体看代码)，答案就是 $f(1,n,1)$​。

**转移**：从 $i$ 到 $j$ 枚举一个 $t$,假设让 $t$ 来做根节点, $t$ 结点的权值都比它的儿子结点的权值要小 (题目性质)。

接下来考虑 $t$ 这个节点的权值是否需要改变。

如果 $t$​ 结点已经 $ >= k$​ 了，不需要修改：

设 $V_t$ 为 $t$ 的权值，$S$ 表示 $i$ 到 $j$ 的访问频率之和。

$f(i, j, k) = \min(f(i,j,k), f(i,t - 1,V_t ) + f(t + 1,j, V_t ) + S)$

关于这个转移方程：

1. 虽然题目中说，“所有结点的权值必须仍保持互不相同”，但权值为实数类型，两个权值可以无限接近而不相同，所以这个条件并无约束作用，转移方程中写的是“ $t$ 的权值”。

2. 转移方程之中“ $i$ 到 $j$ 的访问频率之和”，计算的是访问代价。

   访问代价 = 深度 $\times $​​ 访问频率。当我们一层层计算时，每次都会将当前子树内的访问频率加一遍，累积起来就是访问代价。

如果要修改：

$f(i,j,k) = \min(f(i,j,k), f(i,t - 1,k) + f(t + 1,j,k) + S)$

```c
/*
Date:2021.8.2
Source:luogu 1864
konwledge:对treap的理解 + dp 
*/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define orz cout << "AK IOI"

using namespace std;
const int maxn = 80;
const int maxm = 4e5 + 10;

inline int read()
{
	int f = 0, x = 0; char ch = getchar();
	while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
	return f ? -x : x;
}
inline void print(int X)
{
	if(X < 0) {X = ~(X - 1); putchar('-');}
	if(X > 9) print(X / 10);
	putchar(X % 10 + '0');
}
int n, K, val[maxn], sum[maxn], f[maxn][maxn][maxn]; 
struct node{
	int num, val, sum;
}a[maxn];
bool cmp(node a, node b)
{
	return a.num < b.num;
}
int main()
{
	n = read(), K = read();
	for(int i = 1; i <= n; i++) a[i].num = read();
	for(int i = 1; i <= n; i++) val[i] = a[i].val = read();
	for(int i = 1; i <= n; i++) a[i].sum = read();
	sort(a + 1, a + n + 1, cmp);
	sort(val + 1, val + n + 1);
	for(int i = 1; i <= n; i++)
	{
		a[i].val = lower_bound(val + 1, val + n + 1, a[i].val) - val;//离散化
		sum[i] = sum[i - 1] + a[i].sum; 
	}
	memset(f, 63, sizeof f);
	for(int i = 1; i <= n + 1; i++)
		for(int j = 1; j <= n; j++) f[i][i - 1][j] = 0;
	for(int i = n; i >= 1; i--)
    	for(int j = i; j <= n; j++)
        	for(int k = 1; k <= n; k++)
          		for(int t = i; t <= j; t++)
				{
              		if(a[t].val >= k) 
                	f[i][j][k] = min(f[i][j][k], f[i][t - 1][a[t].val] + f[t + 1][j][a[t].val] + sum[j] - sum[i - 1]);
              		f[i][j][k] = min(f[i][j][k], f[i][t - 1][k] + f[t + 1][j][k] + K + sum[j] - sum[i - 1]);
          		}
	printf("%d", f[1][n][1]);
	return 0;
}
```


感谢 https://www.luogu.com.cn/blog/wangwangwangwangwang/solution-p1864

---

## 作者：咯咯咯 (赞：1)

其实这题我一开始想的是二维DP来着，后来发现不行。。然后一直改才改成这样

说说我的思路吧，我用dp[i][j][k]表示子树区间为i到j，堆顶的权值无限逼近s[rank[i][j][k](区间中排名为k的位置，从0开始）].weigh时，最小代价和


然后枚举两边的根的值，才判断当前节点不改变权值能否成为堆顶，如果可以就加入答案，并且还要更新一定要它成为堆顶时的答案 

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define LL long long
const LL N=100,INF=0x3f3f3f3f3f3f3f3f;
LL n,K,temp;
struct DATA 
{
	LL val,weigh,cnt;
	bool operator <(const DATA &other) const 
	{
		return val<other.val ;
	}
}s[N];
LL rank[N][N][N],val[N][N][N],dp[N][N][N],sum[N];
int main()
{
//	freopen("treapmod.in","r",stdin);
//	freopen("treapmod.out","w",stdout);
	scanf("%lld%lld",&n,&K);
	For(i,1,n) scanf("%lld",&s[i].val);
	For(i,1,n) scanf("%lld",&s[i].weigh);
	For(i,1,n) scanf("%lld",&s[i].cnt);
	std::sort(s+1,s+1+n);s[n+1].weigh=INF;
	For(i,1,n) sum[i]=sum[i-1]+s[i].cnt ;
	For(i,0,n) val[i+1][i][0]=n+1,rank[i+1][i][n+1]=0;
	For(i,1,n) For(j,i,n) 
	{
		For(k1,i,j)
		{
			For(k2,i,j) if (s[k1].weigh>s[k2].weigh) rank[i][j][k1]++;
			val[i][j][rank[i][j][k1]]=k1;
		}
		val[i][j][j-i+1]=n+1;rank[i][j][n+1]=j-i+1;
	}
	For(l,1,n) For(i,1,n-l+1)
	{
		int j=i+l-1;
		For(k,0,j-i+1) dp[i][j][k]=INF; //当前i到j的这个区间，根节点的值逼近  i到j排名为k的值  的最小代价 
		if (l==1) dp[i][j][0]=s[i].cnt,dp[i][j][1]=s[i].cnt+K;
		else
		{
			For(k,i,j) 
			{
				For(k1,0,k-i) For(k2,0,j-k) 
				{
					if (s[val[i][k-1][k1]].weigh<s[val[k+1][j][k2]].weigh) temp=val[i][k-1][k1];
					else temp=val[k+1][j][k2]; //取两个孩子的最小值 所在的编号 
					if (s[k].weigh<s[temp].weigh) 
						dp[i][j][rank[i][j][k]]=std::min(dp[i][j][rank[i][j][k]],dp[i][k-1][k1]+dp[k+1][j][k2]+sum[j]-sum[i-1]);
					dp[i][j][rank[i][j][temp]]=std::min(dp[i][j][rank[i][j][temp]],dp[i][k-1][k1]+dp[k+1][j][k2]+sum[j]-sum[i-1]+K);
				}
			}
		}
	}
	LL ans=INF;For(i,0,n) ans=std::min(ans,dp[1][n][i]);
	printf("%lld\n",ans);
	fclose(stdin);fclose(stdout);
	return 0;
}
```


---

## 作者：QAQ_陌上花开 (赞：1)

这题条件较为复杂，大意是给你一棵treap，你可以通过改变树的形态使得树上所有节点子树访问次数和的和最小。

我们发现你每次只能修改树的形态，那么显然无论你如何修改 ，整棵树的中序遍历显然是不会改变的，那么应先求出这棵树的中序遍历（毕竟你只能修改权值，不能修改数据值）

于是我们应该先枚举根节点，同时考虑是否需要改变权值，之后递归处理左子树和右子树，将得到的最小值合并

T(l,r,w)= 

当k的权值>=w时
T(l,k-1,w)+T(k+1,r,w)+sum[l][r]

当k的权值<w时
T(l,k-1,w)+T(k+1,r,w)+sum[l][r]+K
(sum[l][r]表示点l~r的访问次数,l<=k<r)

从上方的分治式来看，显然具有重叠子问题性质，同时因为每次分治都会把区间分治的更小，所以具有最优子结构性质

那么就可以设计状态了

F[i][j][w]表示在由结点i~j所构成的treap在根结点的权值>=w时的最小代价

状态空间 n^2*400000，显然GG

我们发现对于权值我们可以是其变为实数，也就是说权值相同对题目没有影响，不妨对权值离散化，将其压入[1,n]的区间中,那么状态数就会变为n^3,这样就可以接受了

转移：f[i][j][w]=
当k的权值>=w时 

min(f[i][j][w],f[i][k-1][w]+f[k+1][j][w]+sum[j]-sum[i-1])

当k的权值<w是  

min(f[i][j][w],f[i][k-1][w]+f[k+1][j][w]+sum[j]-sum[i-1]+K)

答案：f[1][n][1]

时间复杂度：n^4

标程如下：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
struct node{
	long long a,b,c;
}data[100];
struct node1{
	long long id,a;
}b[100];
long long f[200][200][200],sum[200];
long long read()
{
	long long ret(0);
	char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch>='0'&&ch<='9')
	{
		ret=(ret<<1)+(ret<<3)+ch-48;
		ch=getchar();
	}
	return ret;
}
bool cmp(node x,node y)
{
	return x.a<=y.a;
}
bool cmp1(node1 x,node1 y)
{
	return x.a<=y.a;
}
int main()
{
	int n=read(),K=read();
	for (int i=1;i<=n;i++) data[i].a=read(),b[i].id=i;
	for (int i=1;i<=n;i++) data[i].b=read();
	for (int i=1;i<=n;i++) data[i].c=read();
	sort(data+1,data+n+1,cmp);
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+data[i].c,b[i].a=data[i].b;
	sort(b+1,b+1+n,cmp1);
	for (int i=1;i<=n;i++) data[b[i].id].b=i;
	memset(f,0x3f,sizeof(f));
	for (int i=1;i<=n+1;i++)
	for (int j=1;j<=n;j++) f[i][i-1][j]=0;
	for (int l=0;l<n;l++)
	{
		for (int i=1;i<=n-l;i++)
		{
			int j=i+l;
			for (int w=1;w<=n;w++)
				for (int k=i;k<=j;k++)
				{
					f[i][j][w]=min(f[i][j][w],f[i][k-1][w]+f[k+1][j][w]+K+sum[j]-sum[i-1]);
					int v=data[k].b;
					if (v>=w) f[i][j][w]=min(f[i][j][w],f[i][k-1][v]+f[k+1][j][v]+sum[j]-sum[i-1]);
				}
		}
	}
	printf("%lld",f[1][n][1]);
	return 0;
}
```


---

## 作者：MortisM (赞：0)

## 前言
这个题是看了题解才会做的，总的来说感觉非常妙，要抓住一些关键的性质，**“以不变应万变”**。

## 思路
首先，这个题让人感觉无从下手。那么我们需要分析这个题的难点，发现此题改了权值以后整棵树就会乱动，非常难受。那么我们可以在万变中找不变，**寻找不变量**是此题的关键。

**那么这道题的不变量就是二叉查找树的中序遍历。**

> Q：为什么中序遍历不变？

> A：因为二叉查找树的定义是*左儿子的权值<自己的权值<右儿子的权值*

虽然这一步看起来很显然，但却是整道题的关键所在。（~~我当时就是没想到这一步所以一直卡住的~~）

知道了这个以后，事情就变得轻松起来。先按中序遍历排序，即按数据值排序。容易想到使用区间 DP，具体来说：设 $f_{i,j,k}$ 表示在中序遍历 $[i,j]$ 的区间内，所有权值都 $\ge k$ 的最小代价。（其中权值需要离散化）

那么每次转移考虑将 $l$ 当做 $[i,j]$ 里的根，考虑修改或者不修改两种情况。

设点 $p$ 出现的频度为 $F_p$，不修改：若 $v_l\ge k$，$f_{i,j,k}\leftarrow f_{i,l-1,v_l}+f_{l+1,j,v_l}+\sum\limits_{p=i}^jF_p$

解释一下，$\sum\limits_{p=i}^jF_p$ 的意思就是 $i$ 到 $j$ 所有 频度的和。你只要一层一层往下加，每一层都除去当前的根，最后得到的就是答案。

修改：$f_{i,j,k}\leftarrow f_{i,l-1,k}+f_{l+1,j,k}+K+\sum\limits_{p=i}^jF_p$

初始值是 $f_{i,i-1,k}=0$，最终的答案是 $f_{1,n,1}$。

时间复杂度 $O(n^4)$。

## 代码
[完整代码](https://www.luogu.com.cn/paste/y9c8wfcw)

核心代码如下：

```cpp
struct node{
	int data,val,freq;
	bool operator<(const node &x)const{
		return data<x.data;
	}
}a[maxn];
vector<int> v;
int sum(int l,int r){
	return presum[r]-presum[l-1];
}
int main(){
	scanf("%d%d",&n,&K);
	for(int i=1;i<=n;i++)scanf("%d",&a[i].data);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].val);
		v.pb(a[i].val);
	}
	for(int i=1;i<=n;i++)scanf("%d",&a[i].freq);
	sort(a+1,a+1+n);
	sort(v.begin(),v.end());
	v.resize(unique(v.begin(),v.end())-v.begin());//range in [1,n]
	for(int i=1;i<=n;i++)a[i].val=lower_bound(v.begin(),v.end(),a[i].val)-v.begin()+1;
	for(int i=1;i<=n;i++)presum[i]=presum[i-1]+a[i].freq;
	memset(dp,0x3f,sizeof(dp));
	for(int i=1;i<=n+1;i++)for(int k=1;k<=n;k++)dp[i][i-1][k]=0;
	for(int len=1;len<=n;len++){
		for(int i=1;i+len-1<=n;i++){
			int j=i+len-1;
			for(int k=1;k<=n;k++){
				for(int l=i;l<=j;l++){
					if(a[l].val>=k)chmin(dp[i][j][k],dp[i][l-1][a[l].val]+dp[l+1][j][a[l].val]+sum(i,j));
					chmin(dp[i][j][k],dp[i][l-1][k]+dp[l+1][j][k]+K+sum(i,j));
				}
			}
		}
	}
	printf("%d\n",dp[1][n][1]);
	return 0;
}
```

---


# Local Maxima

## 题目描述

给出一个排列。如果其中一个数比它前面的数都大，则称为**局部最大值**（Local Maxima）。

现在问在一个长度为 $n$ 的随机生成的排列中，期望有多少个数为局部最大值。

## 说明/提示

长度为 $2$ 的排列共 $2$ 种，为 $(1,2)$ 和 $(2,1)$。前者两个数都为局部最大值，后者仅有第一个数 $2$ 为局部最大值。


### 数据范围及约定 

- 对于 $30\%$ 的数据，$n \leq 10$；
- 对于 $80\%$ 的数据，$n \leq 10^6$；
- 对于 $100\%$ 的数据，$1\leq n < 2^{31}$。


## 样例 #1

### 输入

```
2```

### 输出

```
1.50000000```

# 题解

## 作者：Jelefy (赞：8)

鄙人证明此题的方法。

计算$n$排列的答案时，考虑在$(n-1)$排列的末尾加入一个$1\sim n$之间的数$x$（前面$n-1$个数中若有$≥x$的数默认$+1$）。  
显然当$x$分别取不同值时，方案数是相等的【即$(n-1)!$】。  
当新加入的数$x∈[1,n-1]$时，答案不变，只有当$x=n$时，才会在原来的基础上产生一个新的贡献。因此，$x=1\sim n-1$时的答案皆为$f_{n-1}$，$x=n$时的答案为$f_{n-1}+1$，故
$$f_n=\frac{(n-1)×f_{n-1}+f_{n-1}+1}n=f_{n-1}+\frac1n$$
因此$f_n=1+\frac12+\frac13+...+\frac1n$，证毕（$f_n$的名字叫调和级数）。

---
调和级数没有通项公式，数学上有近似公式$\sum_{i=1}^n\frac1i=\ln(n)+γ$，$γ$为欧拉常数，其值为$0.577215664...$  
鄙人很废，背不下来这么个数字，所以就用分段打表法咯o(TヘTo)

分段打表是什么意思呢？就这题来说，比如你要求$n=10^8$时的答案，那么你先把$n=9×10^7$的答案，即$f_{9×10^7}$，求出来存到程序里，在询问时，直接从$f_{9×10^7}$开始$+\frac1{9×10^7+1}+\frac1{9×10^7+2}+...+\frac1{10^8}$，就可以将复杂度降到$O(10^7)$啦！

所以，我们只需要隔一段距离预处理出一个答案，询问时从已经求出的答案开始计算，就可以降低复杂度。以下给出我的代码，包括题目程序以及打表的辅助程序。

## $Sol$
```cpp
#include <cstdio>
using namespace std;
const int L = 1 << 26; //每隔1 << 26预处理一个答案
const long long data[1 << 5] = {
0x0000000000000000,
0x4032995ad72ecae3,
0x40334accef169efe,
0x4033b2997ec44843,
0x4033fc3f0706710f,
0x4034355ef6940cd4,
0x4034640b96b6c4f6,
0x40348b8201f6859f,
0x4034adb11efa431d,
0x4034cbd82667fc2d,
0x4034e6d10e88ab5c,
0x4034ff374e019d2a,
0x4035157daeabec2d,
0x403529fb5c77752c,
0x40353cf419ec0e29,
0x40354e9d9e3a9914,
0x40355f2336f014bc,
0x40356ea84f4fffb4,
0x40357d4a3e5e0699,
0x40358b2197d1130f,
0x40359843267ee387,
0x4035a4c0a99e4992,
0x4035b0a965f7fa74,
0x4035bc0a96ca6793,
0x4035c6efc6a269ae,
0x4035d163160dc644,
0x4035db6d746e0dd3,
0x4035e516ce106fe7,
0x4035ee6631e2be36,
0x4035f761f089a6be,
0x4036000fb63157f4,
0x40360874a021f9bc,
};
const double *list = (double*) data;

int n;

int main(){
	scanf("%d", &n);
	register double ans = list[n / L];
	for(register int i = n / L * L + 1; i <= n; i++)
		ans += 1.0 / i;
	printf("%.08f", ans);
	return 0;
}
```
## 打表机
```cpp
#include <cstdio>
using namespace std;
const int L = 1 << 26;

double ans;

int main(){
	printf("0x%08x%08x,\n", *((int*)&ans + 1), ans);
	for(int i = 1; i < (1u << 31); i++){
		ans += 1.0 / i;
		if(i % L == 0) printf("0x%08x%08x,\n", *((int*)&ans + 1), ans);
	}
	return 0;
}
```


---

## 作者：Nepenthe (赞：6)

## **Hint**
这肯定是道数学题了
**期望的拆分**
首先回顾[期望](https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/5362790?fr=aladdin&fromid=10318906&fromtitle=%E6%9C%9F%E6%9C%9B "@百度百科")的求法:
[离散型随机变量](https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E6%80%A7%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/5977114?fr=aladdin&fromid=9980865&fromtitle=%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F "@百度百科")$x$的取值可以是$$x_{1},x_{2},x_{3}...x_{n}$$取到这些值的概率分别为$$P(x_{1}),P(x_{2}),P(x_{3})...P(x_{n})$$
则$x$取值的期望$$E(x)=x_{1}*P(x_{1})+x_{2}*P(x_{2})+x_{3}*P(x_{3})+...+x_{n}*P(x_{n})$$即$$\sum _{k=1}^{n} x_{k}*P(x_{k})$$
通常情况下我们求期望需要列[分布列](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%88%97/6815651?fr=aladdin "@百度百科"),但实际上分布列是一个综合统计的产物,不方便我们思考,我们这次换一种思路,我们分开来思考

以$n=3$为例

|   排列   |   local数   |   权   |
|   :-:   |   :-:   |   :-:   |
| 1 2 3 | 3 |   ${1}\over{6}$   |
| 1 3 2 |2 | ${1}\over{6}$ |
| 2 1 3 |2 | ${1}\over{6}$ |
| 2 3 1 |2 | ${1}\over{6}$ |
| 3 1 2 |1 | ${1}\over{6}$ |
| 3 2 1 |1 | ${1}\over{6}$ |

local数数量就是随机变量$x$的可能取值,每一种排列的权都为${1}\over{6}$,所以合并同类项后

$E=(3+2+2+2+1+1)* {{1}\over{6}}$

它与分布列本质是一样的 (其实我就是用蹩脚的语文解释了贡献的含义)

3+2+2+2+1+1实际上的意义是什么? 

local数数量的总量

所以我们得出了本题期望的公式:

![](https://cdn.luogu.com.cn/upload/pic/24774.png)

而排列数即为 $A_{n}^{n}=n!$ ,所以我们考虑local数的数量

此处的local数数量即是 $1$~$n$ 成为local数的情况总数

于是我们考虑某一个数成为local数的情况数

可以想到,对于一个数 $x$ ,比它小的数有 $1,2,3,4...x-1$ ,所以排在它前面的数必须都要是这之中的数它才会成为local数,而 $x$ 顶多排到第 $x$ 位

当 $x$ 排在第 $i(i\leq x)$ 位时,它前面有 $i-1$ 个数,后面有 $n-i$ 个数,所以这时它成为local数的情况数 $$T_i=A_{x-1}^{i-1}*A_{n-i}^{n-i}=A_{x-1}^{i-1}*(n-i)!$$
所以 $x$ 是local数的情况总数$$sum=\sum_{k=1}^{x-1}A_{x-1}^{k-1}*(n-k)$$
~~现在就是考验数学能力的时候了,要知道这只是一个用符号表示的求和式,你要推出简单而普适性的结论,需要严谨的数学推理,这需要你具有卓越的联想能力,优秀的推理能力,高超的计算功底以及夯实的数学积累,要知道当年欧拉失明时就是靠着.....~~

所以我们选择打表

但是我们拿这这个公式打表并看不出来什么

我们想到我们最后的结果是每一个元素的情况数除以 $n!$ ,所以我们打表对 $n$ , $i(i\leq n)$ 成为local的总情况数除以 $n!$ 的结果,然后我们奇迹般地发现$$ans_n={\sum_{i=1}^{n} {{1}\over{i}}}$$
至于打表的具体情况,这里有我一个[学长的博客](http://liaoy148.lofter.com/post/1da8a74e_a3d612e "%%%liaoy大佬")

我们可以轻松过80分,所以只有一个困难了,对于 100% 的数据 $n$ 在 $int$ 范围,这部分要用到[调和级数](https://baike.baidu.com/item/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0?fr=aladdin "点击畅游数学海洋"),至于这个调和级数是个什么我也不懂,但知道它的公式即可过这一题了$$\sum_{i=1}^{n} {{1}\over{i}}=ln(n+1)+r (n→∞)$$其中$r$是欧拉常数,我们知道$r\approx 0.5772156649$(而且我们只知道这些,我们甚至连它是有理数还是无理数都不知道)

所以100分就是这么拿到了,代码很短,但是数学很美妙

##**code**
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int n;
double ans;
int main() {

    scanf("%d",&n);
    if(n<=1000000)
     for(int i=1;i<=n;++i) ans+=((1.0)/i);
    else ans=log(n+1) +0.5772156649;
    printf("%.8lf",ans);
    return 0;
}
```


　　

---

## 作者：Aw顿顿 (赞：5)

Update：修正了有小问题的内容。

实在是不想打代码就颓一颓推式子了。

## 期望递推

考虑现在有 $n-1$ 个数，在这个数末尾加上一个 $x\in[1,n]$，它的贡献会是多少呢？

显然，只有在 $x=n$ 的时候，才会让答案 $+1$，其他的时候都只能继承原有的答案。

不妨设 $f(i)$ 表示长度为 $i$ 的排列的期望值，那么：

$$f(n)=\dfrac{(n-1)\times f(n-1)+(f(n-1)+1)}{n}$$

很容易化简出递推式：

$$f(n)=f(n-1)+\dfrac{1}{n}$$

显然，我们可以写出一个展开的表达式：

$$f(n)=\sum\limits_{i=1}^{n}\dfrac{1}{i}$$

实际上，有一点数学基础就会发现，$f$ 实际上就是调和级数，即：

$$H_n=\sum\limits_{i=1}^{n}\dfrac{1}{i}$$

那么，这样的调和级数有没有计算的方法呢？


## 近似解

$$H_n=\sum\limits_{i=1}^{n}\dfrac{1}{i}$$

$$\sum\limits_{i=1}^{n}\int_i^{i+1}\dfrac{1}{\lfloor x\rfloor}\text{d}x$$

$$\int_1^{n+1}\dfrac{1}{\lfloor x\rfloor}\text{d}x$$

$$\int_1^{n+1}\left(\dfrac{1}{x}+\dfrac{1}{\lfloor x\rfloor}-\dfrac{1}{x}\right)\text{d}x$$

$$\int_1^{n+1}\dfrac{1}{x}\text{d}x+\int_1^{n+1}\left(\dfrac{1}{\lfloor x\rfloor}-\dfrac{1}{x}\right)\text{d}x$$

这个式子，可以看出，近似值是：

$$\ln(n+1)+\gamma$$

其中 $\gamma$ 是欧拉常数。这个式子在数据小的时候有一定误差，在实现上，加上 $\dfrac{1}{2n}$ 会被认为是一个更优秀的近似。

因此我们在 $5\times 10^7$ 用正常累加即可，代码如下：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
long double res,Gamma=0.5772156649015328;
int n;
int main(){
	scanf("%d",&n);
	if(n<=50000000)for(int i=1;i<=n;++i)res+=1.0/i;
	else res=Gamma+log(n)+1.0/(2.0*n);
	printf("%.8Lf",res);
	return 0;
}
```

Reference：[**更深入的关于调和级数的内容**](https://www.luogu.com.cn/blog/LinearExpectation/Harmonization-levels)



---

## 作者：白鲟 (赞：5)

## 前言
若出现公式问题可以到[博客](https://www.luogu.com.cn/blog/bzlz-zdx/solution-p1943)阅读。  

感动于自己推出来一道期望题的式子……

## 题意简述
求 $1$~$n$ 的排列中满足大于所有位置在它前面的数的期望个数。

## 题目分析
首先根据样例盲猜结论：
$$
\operatorname{E}(n)=\sum_{i=1}^n\dfrac{1}{i}
$$
~~然后我们就可以开始写代码了~~然后我们需要对这个式子进行证明。易知：
$$
\operatorname{E}(n)=\sum_{i=1}^n\operatorname{P}(i)
$$
其中 $\operatorname{P}(i)$ 表示 $i$ 大于排在它前面的所有数的概率。那么我们要求的就转化为了 $\operatorname{P}(i)$。  

$\operatorname{P}(i)$ 表示 $i$ 大于排在它前面的所有数的概率，也可以说是所有比 $i$ 大的数都在它后面的概率。这意味着只需要考虑不小于 $i$ 的数的排列。容易得知，只有当 $i$ 位于不小于 $i$ 的数的排列的第一个位置时才满足条件。不小于 $i$ 的数的排列一共有 $(n-i+1)!$ 种，而其中满足条件的排列有 $(n-i)!$ 种，故有：
$$
\operatorname{P}(i)=\dfrac{(n-i)!}{(n-i+1)!}=\dfrac{1}{n-i+1}
$$
于是
$$
\operatorname{E}(n)=\sum_{i=1}^n\operatorname{P}(i)=\sum_{i=1}^{n}\dfrac{1}{n-i+1}=\sum_{i=1}^{n}\dfrac{1}{i}
$$
也就是说我们所要求的答案即为第 $n$ 个调和数。但若是直接求和，时间复杂度为 $\operatorname{O}(n)$，对于本题的数据范围而言会超时。我们需要快速计算这个式子。  

对于调和数，有一个实用的性质：第 $n$ 个调和数与 第 $n$ 个自然对数的差值收敛于欧拉-马歇罗尼常数 $\gamma$（也叫欧拉常数）。该常数的近似值为 $0.57721566490153285$。这一性质可以记作
$$
\gamma=\lim_{n \to \infty}(\sum_{i=1}^{n}\dfrac{1}{i}-\ln n)
$$
在 $n$ 足够大的时候，我们可以近似地认为
$$
\sum_{i=1}^{n}\dfrac{1}{i}=\gamma+\ln n
$$
那么可以我们根据输入的 $n$ 的大小来选择计算方法，当 $n$ 较小时（可取 $n \le 10^8$）直接计算；当 $n$ 较大时运用这一式子求近似值。
## 代码
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
const long double Gamma=0.5772156649015328;
int n;
long double ans;
int main()
{
	scanf("%d",&n);
	if(n<=1e8)
		for(int i=1;i<=n;++i)
			ans+=1.0/i;
	else ans=Gamma+log(n);
	printf("%.8Lf",ans);
	return 0;
}
```

---

## 作者：Rachel_in (赞：5)

**UPD:增加了分块图示**

先膜一波调和级数爷%%%

欧拉常数什么的我都还没学过。但是我可以**分块打表**呀！

题意就是让我们求：

$$\sum_{i=1}^n 1/i$$

就是:

$$\frac {1}{1}+\frac {1}{2}+\frac {1}{3}+\frac {1}{4}+....+\frac {1}{n}$$

然后$n<=1000000$那部分可以直接$O(n)$做，但是$n$的最大范围是$2147483647$,显然用$O(n)$做会超时，这时我们就可以分块打表，每隔$10000000(1e7)$个数输出一次。这样我们就只需输出$214$个数，那么剩下来我们也就最多只需加上$10000000$个数就行了，复杂度正确。

举个例子：如果我们要求$n=31.7*1e7$时，我们已经把$31*1e7$给预处理出来了，那么我们只需再计算$(31*1e7,31.7*1e7]$即可。

如图所示，只需多计算红色部分即可。
![](https://cdn.luogu.com.cn/upload/pic/61561.png)

那么接下来就是**打表程序**，每六个换一行。（打表时建议开一些优化开关来加速，我打出这些表大概只需要5秒）

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define R register
using namespace std;
double sum;
int cnt;
const int size=10000000;
int main(){	
	freopen("biao.out","w",stdout);
	for(R int i=1;i<=2140000000;i++){
		sum+=1.0/(double)i;
		if(i%size==0){
			cnt++;
			if(cnt==1) printf("	  ");//手动TAB
			printf("bol[%d]=%.8lf; ",i/size,sum);
			if(cnt==6){//每六个换行
				puts("");
				cnt=0;
			}
		}
	}
	return 0;
}
```

然后**提交代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int size=10000000;
double bol[300];
int n;
int main(){
	  scanf("%d",&n);
	  bol[1]=16.69531137; bol[2]=17.38845852; bol[3]=17.79392362; bol[4]=18.08160569; bol[5]=18.30474924; bol[6]=18.48707079; 
	  bol[7]=18.64122147; bol[8]=18.77475286; bol[9]=18.89253590; bol[10]=18.99789641; bol[11]=19.09320659; bol[12]=19.18021797; 
	  bol[13]=19.26026068; bol[14]=19.33436865; bol[15]=19.40336152; bol[16]=19.46790004; bol[17]=19.52852466; bol[18]=19.58568308; 
	  bol[19]=19.63975030; bol[20]=19.69104359; bol[21]=19.73983376; bol[22]=19.78635377; bol[23]=19.83080553; bol[24]=19.87336515; 
	  bol[25]=19.91418714; bol[26]=19.95340786; bol[27]=19.99114818; bol[28]=20.02751583; bol[29]=20.06260715; bol[30]=20.09650870; 
	  bol[31]=20.12929852; bol[32]=20.16104722; bol[33]=20.19181888; bol[34]=20.22167184; bol[35]=20.25065938; bol[36]=20.27883026; 
	  bol[37]=20.30622923; bol[38]=20.33289748; bol[39]=20.35887296; bol[40]=20.38419077; bol[41]=20.40888338; bol[42]=20.43298094; 
	  bol[43]=20.45651143; bol[44]=20.47950095; bol[45]=20.50197381; bol[46]=20.52395271; bol[47]=20.54545892; bol[48]=20.56651233; 
	  bol[49]=20.58713161; bol[50]=20.60733432; bol[51]=20.62713695; bol[52]=20.64655504; bol[53]=20.66560323; bol[54]=20.68429536; 
	  bol[55]=20.70264450; bol[56]=20.72066301; bol[57]=20.73836258; bol[58]=20.75575433; bol[59]=20.77284876; bol[60]=20.78965588; 
	  bol[61]=20.80618518; bol[62]=20.82244570; bol[63]=20.83844604; bol[64]=20.85419440; bol[65]=20.86969859; bol[66]=20.88496606; 
	  bol[67]=20.90000394; bol[68]=20.91481902; bol[69]=20.92941782; bol[70]=20.94380656; bol[71]=20.95799119; bol[72]=20.97197744; 
	  bol[73]=20.98577076; bol[74]=20.99937641; bol[75]=21.01279943; bol[76]=21.02604466; bol[77]=21.03911674; bol[78]=21.05202014; 
	  bol[79]=21.06475917; bol[80]=21.07733795; bol[81]=21.08976047; bol[82]=21.10203056; bol[83]=21.11415192; bol[84]=21.12612812; 
	  bol[85]=21.13796257; bol[86]=21.14965861; bol[87]=21.16121944; bol[88]=21.17264813; bol[89]=21.18394769; bol[90]=21.19512099; 
	  bol[91]=21.20617082; bol[92]=21.21709989; bol[93]=21.22791081; bol[94]=21.23860610; bol[95]=21.24918821; bol[96]=21.25965951; 
	  bol[97]=21.27002230; bol[98]=21.28027880; bol[99]=21.29043117; bol[100]=21.30048150; bol[101]=21.31043183; bol[102]=21.32028413; 
	  bol[103]=21.33004030; bol[104]=21.33970222; bol[105]=21.34927167; bol[106]=21.35875041; bol[107]=21.36814015; bol[108]=21.37744254; 
	  bol[109]=21.38665920; bol[110]=21.39579168; bol[111]=21.40484152; bol[112]=21.41381019; bol[113]=21.42269914; bol[114]=21.43150976; 
	  bol[115]=21.44024344; bol[116]=21.44890151; bol[117]=21.45748525; bol[118]=21.46599594; bol[119]=21.47443481; bol[120]=21.48280306; 
	  bol[121]=21.49110186; bol[122]=21.49933236; bol[123]=21.50749567; bol[124]=21.51559288; bol[125]=21.52362505; bol[126]=21.53159322; 
	  bol[127]=21.53949840; bol[128]=21.54734158; bol[129]=21.55512372; bol[130]=21.56284577; bol[131]=21.57050864; bol[132]=21.57811324; 
	  bol[133]=21.58566044; bol[134]=21.59315112; bol[135]=21.60058609; bol[136]=21.60796620; bol[137]=21.61529224; bol[138]=21.62256500; 
	  bol[139]=21.62978525; bol[140]=21.63695374; bol[141]=21.64407121; bol[142]=21.65113837; bol[143]=21.65815595; bol[144]=21.66512462; 
	  bol[145]=21.67204506; bol[146]=21.67891794; bol[147]=21.68574390; bol[148]=21.69252359; bol[149]=21.69925762; bol[150]=21.70594661; 
	  bol[151]=21.71259115; bol[152]=21.71919184; bol[153]=21.72574924; bol[154]=21.73226392; bol[155]=21.73873643; bol[156]=21.74516732; 
	  bol[157]=21.75155712; bol[158]=21.75790635; bol[159]=21.76421552; bol[160]=21.77048513; bol[161]=21.77671568; bol[162]=21.78290765; 
	  bol[163]=21.78906152; bol[164]=21.79517774; bol[165]=21.80125679; bol[166]=21.80729910; bol[167]=21.81330513; bol[168]=21.81927530; 
	  bol[169]=21.82521003; bol[170]=21.83110975; bol[171]=21.83697487; bol[172]=21.84280579; bol[173]=21.84860291; bol[174]=21.85436662; 
	  bol[175]=21.86009729; bol[176]=21.86579531; bol[177]=21.87146105; bol[178]=21.87709487; bol[179]=21.88269712; bol[180]=21.88826817; 
	  bol[181]=21.89380835; bol[182]=21.89931800; bol[183]=21.90479747; bol[184]=21.91024707; bol[185]=21.91566714; bol[186]=21.92105799; 
	  bol[187]=21.92641993; bol[188]=21.93175328; bol[189]=21.93705833; bol[190]=21.94233539; bol[191]=21.94758474; bol[192]=21.95280669; 
	  bol[193]=21.95800151; bol[194]=21.96316948; bol[195]=21.96831087; bol[196]=21.97342598; bol[197]=21.97851505; bol[198]=21.98357835; 
	  bol[199]=21.98861614; bol[200]=21.99362868; bol[201]=21.99861622; bol[202]=22.00357901; bol[203]=22.00851730; bol[204]=22.01343131; 
	  bol[205]=22.01832130; bol[206]=22.02318749; bol[207]=22.02803011; bol[208]=22.03284940; bol[209]=22.03764557; bol[210]=22.04241885; 
	  bol[211]=22.04716945; bol[212]=22.05189759; bol[213]=22.05660348; bol[214]=22.06128733; 
	  int gs=n/size;//现在向下是哪一块
	  double ans=bol[gs];
	  for(long long i=gs*size+1;i<=n;i++){//剩下的暴力算
          	ans+=1.0/(double)i;
	  }
	  printf("%.8lf",ans);
	  return 0;
}
```


---

## 作者：封禁用户 (赞：3)

没人写题解？

其实这道题还是很容易想的，我们先找找规律

```cpp
n=1,ans=1
n=2,ans=2/3
n=3,ans=6/11
n=4,ans=35/44
```
......
我们可以发现ans=1/1+1/2+1/3+1/4+...+1/n

对于80%的数据，我们可以直接暴力算。

对于极大数据可以参考[欧拉-马斯刻若尼常数](https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E9%A6%AC%E6%96%AF%E5%88%BB%E8%8B%A5%E5%B0%BC%E5%B8%B8%E6%95%B8)

维基百科如果打不开请参考[百度知道](https://zhidao.baidu.com/question/1734141496708026667.html)

1+1/2+1/3+...+1/n这个数被称为调和级数，

n很大的时候结果十分趋近于log(n)+欧拉-马斯刻若尼常数

因为欧拉-马斯刻若尼常数=调和级数-e(自然常数)

而且题目要求保留八位小数，完全没问题。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <stack>
#include <map>
#include <vector>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;i++)
#define dop(i,m,n) for(int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int n;
double ans;
int main(){
    n=read();
    if(n>10000000) ans=log(n)+0.57721566490153286060651209;
    else rep(i,1,n) ans+=1.0/i*1.0;
    printf("%.8lf",ans);
    return 0;
}
```

---

## 作者：Dawn_Chase (赞：2)

# P党来一发
### 看楼下诸位大佬都只给了公式，让我这个蒟蒻来推一推是怎么来的吧。
- 我们先从最简单的开始。
- 当n=1时，有多少种可能的呢？
- 显而易见，当然是**1**了啊。
- 那2呢？
- 显然，比2小的只有1。所以我们可以分两种情况：
- First，2放在第一位，有**(n-1)!**种可能。
- Second，2放在第二位，因为2之前的数只可能是1才会让2成为localmaxima，所以有**(n-2)!**种可能。
- 如果2摆在第二位以后，就必定会有一个比2大的数在2的前面，所以就不符合要求了。
- 综上所述，**2成为LocalMaxima的可能一共有(n−1)!+(n−2)!种**。
- 以此我们可知，对于一个数k，只需要考虑k放在第1至k位就可以了。
- 那3呢？
- 显然，我们只需考虑3放在第1至3位就可以了。
- First，3放在第一位，共**(n-1)!**种。
- Second，，3放在第二位，这个时候比3小的有两个，1和2，所以就是**A(1,2)∗(n−2)!**种~~(竖的打不出来）~~。
- Third，3放在第三位，就是**A(2,2)∗(n−3)!**种。
- 综上所述，**3成为LocalMaxima的可能一共有(n−1)!+A(1,2)∗(n−2)!+A(2,2)∗(n−3)!种**。
## 诶，这样的~~如此可怕的~~答案，我们该怎么办呢？
~~通过一顿乱搞，~~我们得出了这样一个~~恐怖的~~规律
- 对于一个数k，它成为LocalMaxima的可能是：**A(0，k)∗(n−1)!+A(1,k)∗(n−2)!+A(2,k)∗(n−3)!+···+A(k−1,k−1)∗(n−k)!**。
- 于是，这个公式有什么用呢？
- ~~开始懵逼模式。~~
- 嗯，让我们来试试。
- 这个公式/n!后(也就是答案)会怎么样呢？
## 神奇的事情发生了！！！
- 我们得出了最后的答案：1/1+1/2+···+1/n
- 然后，我们就要使用另一个公式了
- 1/1+1/2+···+1/n=log(n)(以自然对数为底)+γ(欧拉常数)
- 欧拉常数可以自己去百度下。
- 80分可以直接枚举下，上公式估计会卡精度。
- 100分就上公式吧。

~~丢代码~~
``` pascal
var n,i:longint;s:double;
begin
  read(n);
  if n>1000000 then
   begin
    writeln(ln(n)+0.57721566490153286060651209:0:8);
    halt;
   end;
  for i:=1 to n do
   s:=s+1/i;
  writeln(s:0:8);
end.
```

~~代码极短，思想确实有些复杂。~~

代码巨丑，大佬勿喷。

---

## 作者：Cocoly1990 (赞：1)

考虑最后的期望值会是多少，设 $f\left(x\right)$ 表示 $n=x$ 时的期望值，那么考虑 $f\left(x\right)$ 如何得到。我们考虑其为 $f\left(x-1\right)$ 多添加 $x$ 得到，那么计算 $x$ 的贡献。显然除非 $x$ 在最后一个，否则不会有任何贡献，$x$ 生成在 $n$ 个位置的概率是相等的，那么有

$$f\left(x\right)=\frac{\left(n-1\right)\times f\left(x-1\right)+f\left(x-1\right)+1}{n}= f\left(x-1\right)+\frac{1}{n}$$

显然将递推式化简有

$$f\left(x\right)=\sum_{i=1}^x \frac{1}{i}$$

显然的调和级数，但考虑极限数据 $n=2^{31}$，$\mathcal{O}\left(n\right)$ 的计算会 T 成傻逼。

考虑 $\mathcal{O}\left(1\right)$ 计算调和级数

$$\sum_{i=1}^n \frac{1}{i}=\sum_{i=1}^n \int_{i}^{i+1}\frac{1}{\lfloor x \rfloor }dx$$

$$=\int_{1}^{n+1}\frac{1}{x}+\frac{1}{\lfloor x \rfloor }-\frac{1}{x}dx$$

$$=\int_{1}^{n+1}\frac{1}{x}dx+\int_{1}^{n+1}\frac{1}{\lfloor x \rfloor }-\frac{1}{x}dx$$

$$\approx \ln\left(n+1\right)+\gamma$$

以上内容转载自[该博客](https://blog.csdn.net/ezoiHQM/article/details/82961266)。

$\gamma$ 是欧拉常数，其值 $\gamma\approx0.57721566490153286060651209$.

考虑到近似值在数据较小时有精度问题，我们不妨在 $n\leq10^7$ 时 $\mathcal{O}\left(n\right)$ 计算。

```cpp
#include<bits/stdc++.h>
#define Euler 0.57721566490153286060651209 ;

using namespace std ;
int n ;
double ans ;
int main()
{
	cin >> n ;
	cout << fixed << setprecision(8) ; 
	if(n <= 1e7) 
	{
		for(int i = 1 ; i <= n ; i ++) ans += (1.0 / i) ;
		cout << ans ;
	}
	else cout << log(n + 1) + Euler ;
	return 0 ;
}
```

---

## 作者：Priestess_SLG (赞：0)

一个按值插入 dp 的做法，感觉更好想到。

把 $1\sim n$ 中的元素从大到小依次插入到 dp 中。设 $f_i$ 表示当前数组中有 $n-i+1\sim n$ 的值，局部最大值的期望是多少。那么显然有初始值 $f_1=1$。设当前要转移 $f_i$，那么考虑 $n-i+1$ 这个值插入到由 $n-i+2\sim n$ 组成的排列会带来的贡献：共有 $i$ 种不同的插入方案，其中若 $n-i+1$ 插入到了排列的开头，则其会在原来排列的基础上额外带来 $1$ 的贡献，否则其不会带来额外的贡献。因此有 simple 的 dp 转移式：$f_i=\frac{if_{i-1}+1}{i}$。

改写上面的 dp 形式得到 $f_i=f_{i-1}+\frac1i$，即 $f_i=\sum\limits_{j=1}^i\frac1j$。该式为调和级数形式，记作 $H(n)$，其有近似公式 $H(n)\approx\ln(n)+\gamma$，其中 $\gamma$ 为欧拉-马歇罗尼常数，近似为 $0.57721566490153286060651209$。$|H(n)-\ln(n)-\gamma|$ 的值随 $n$ 增大呈减小的趋势，当 $n>10^7$ 时值远远小于精度要求 $10^{-8}$，而若 $n\le 10^7$ 直接 $O(n)$ 递推即可。

```cpp
// #pragma GCC optimize(3, "Ofast", "inline", "unroll-loops")
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 10000010;
double f[N];
signed main() {
    cin.tie(0)->sync_with_stdio(false);
    cout << fixed << setprecision(8);
    int n;
    cin >> n;
    if (n < N) {
        for (int i = 1; i <= n; ++i) f[i] = f[i - 1] + 1. / i;
        cout << f[n] << '\n';
    } else {
        cout << log(n) + 0.57721566490153286060651209 << '\n';
    }
    return 0;
}
```

---


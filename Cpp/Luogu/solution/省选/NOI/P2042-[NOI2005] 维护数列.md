# [NOI2005] 维护数列

## 题目描述


请写一个程序，要求维护一个数列，支持以下 $6$ 种操作：

| 编号 | 名称 | 格式 | 说明 |
| :-----------: | :-----------: | :-----------: | :----------- |
| 1 | 插入 | $\operatorname{INSERT}\ posi \ tot \ c_1 \ c_2 \cdots c_{tot}$ | 在当前数列的第 $posi$ 个数字后插入 $tot$ 个数字：$c_1, c_2 \cdots c_{tot}$；若在数列首插入，则 $posi$ 为 $0$ |
| 2 | 删除 | $\operatorname{DELETE} \ posi \ tot$ | 从当前数列的第 $posi$ 个数字开始连续删除 $tot$ 个数字 |
| 3 | 修改 | $\operatorname{MAKE-SAME} \ posi \ tot \ c$ | 从当前数列的第 $posi$ 个数字开始的连续 $tot$ 个数字统一修改为 $c$ |
| 4 | 翻转 | $\operatorname{REVERSE} \ posi \ tot$ | 取出从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字，翻转后放入原来的位置 |
| 5 | 求和 | $\operatorname{GET-SUM} \ posi \ tot$ | 计算从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字的和并输出 |
| 6 | 求最大子列和 | $\operatorname{MAX-SUM}$ | 求出当前数列中和最大的一段子列，并输出最大和 |

## 说明/提示

#### 数据规模与约定

- 你可以认为在任何时刻，数列中至少有 $1$ 个数。
- 输入数据一定是正确的，即指定位置的数在数列中一定存在。
- 对于 $50\%$ 的数据，任何时刻数列中最多含有 $3 \times 10^4$ 个数。
- 对于 $100\%$ 的数据，任何时刻数列中最多含有 $5 \times 10^5$ 个数，任何时刻数列中任何一个数字均在 $[-10^3, 10^3]$ 内，$1 \le M \le 2 \times 10^4$，插入的数字总数不超过 $4 \times 10^6$。

题面由 @syksykCCC 提供。

## 样例 #1

### 输入

```
9 8 
2 -6 3 5 1 -5 -3 6 3 
GET-SUM 5 4
MAX-SUM
INSERT 8 3 -5 7 2
DELETE 12 1
MAKE-SAME 3 3 2
REVERSE 3 6
GET-SUM 5 4
MAX-SUM```

### 输出

```
-1
10
1
10```

# 题解

## 作者：I_AM_HelloWord (赞：263)

## 问题解析

### 做题思路预备

首先，要有一点splay维护区间操作的基础。

splay维护区间的基本原理，就是将区间[l,r]的端点l-1,和r+1不断的通过伸展操作即splay到根，将l-1伸展到根，将r+1伸展到根的右儿子，那么[l,r]这段区间就在根的右儿子的左儿子上了。

特别要注意的是，==**这里的l,r不是给出的区间端点的编号，而是我们在平衡树的中序遍历中区间端点的编号。即在平衡树中排名(rank)为l,r的两个节点的真实编号，而对于l=1或r=n的情况就非常特殊了，我们有两种解决方案，一种就是分类讨论，将这4种情况枚举，然后进行操作，这么做固然可行，但是当操作变多时，会使整个程序显得繁琐，并且难于调试。另一种解决方案就是建立虚拟节点，我们把需要维护的区间全部变成[l+1,r+1]，那么我们虚拟出一个1号节点和一个n+2号节点，那么整个操作就显得十分自然了**==。

那么问题就明显是一个splay的基本模板题了。而维护区间翻转，在洛谷的P3391文艺平衡树中有更裸的题目。

这里，一个操作一个操作的解决。

### 初始化

首先，对于原序列，我们不应该一个一个读入，然后插入，那么效率就是O(nlogn),而splay的常数本身就很大，所以考虑一个优化，就是把原序列一次性读入后，直接类似线段树的build，搞一个整体建树，即不断的将当前点维护的区间进行二分，到达单元素区间后，就把对应的序列值插入进去，这样，我们一开始建的树就是一个非常平衡的树，可以使后续操作的常数更小，并且建树整个复杂度只是O(2n)的。

### Insert操作

其次，我们来考虑一下如何维护一个insert操作。我们可以这么做，首先如上将需要insert的区间变成节点数目为tot的平衡树,然后把k+1（注意我们将需要操作的区间右移了一个单位，所以题目所给k就是我们需要操作的k+1）移到根节点的位置，把原树中的k+2移到根节点的右儿子的位置。然后把需要insert的区间，先build成一个平衡树，把需要insert的树的根直接挂到原树中k+1的左儿子上就行了。

### Delete操作

再然后，我们来考虑一下delete操作，我们同样的，把需要delete的区间变成[k+1,k+tot]（注意，是删去k后面的tot个数，那么可以发现我们需要操作的原区间是[k,k+tot-1]!），然后把k号节点移到根节点的位置，把k+tot+2移到根节点的右儿子位置，然后直接把k+tot+2的左儿子的指针清为0，就把这段区间删掉了。可以发现，比insert还简单一点。

### Reverse操作

接下来，这道题的重头戏就要开始了。splay的区间操作基本原理还类似于线段树的区间操作，即延迟修改，又称打懒标记。

对于翻转（reverse）操作，我们依旧是将操作区间变成[k+1,k+tot]，然后把k和k+tot+1分别移到对应根的右儿子的位置，然后对这个右儿子的左儿子打上翻转标记即可。

### Make-Same操作

对于Make-Same操作，我们同样需要先将需要操作的区间变成[k+1,k+tot]，然后把k和k+tot+1分别移到根和右儿子的位置，然后对这个右儿子的左儿子打上修改标记即可。

### Get-Sum操作

对于Get-Sum操作，我们还是将操作区间变成[k+1,k+tot],然后把k和k+tot+1分别移到根和右儿子的位置，然后直接输出这个右儿子的左儿子上的sum记录的和。

### Max-Sum操作

对于这个求最大子序列的操作，即Max-Sum操作，我们不能局限于最开始学最大子序列的线性dp方法，而是要注意刚开始，基本很多书都会介绍一个分治的O(nlogn)的方法，但是由于存在O(n)的方法，导致这个方法并不受重视，但是这个方法确实很巧妙，当数列存在修改操作时，线性的算法就不再适用了。

这种带修改的最大子序列的问题，最开始是由线段树来维护，具体来说就是，对于线段树上的每个节点所代表的区间，维护3个量：lx表示从区间左端点l开始的连续的前缀最大子序列。rx表示从区间右端点r开始的连续的后缀最大子序列。mx表示这个区间中的最大子序列。

那么在合并[l,mid]和[mid+1,r]时，就类似一个dp的过程了！其中

$lx[l,r]=max(lx[l,mid],sum[l,mid]+lx[mid+1,r])$

$rx[l,r]=max(rx[mid+1,r],sum[mid+1,r]+rx[l,mid])$

$mx[l,r]=max(mx[l,mid],mx[mid+1,r],lx[mid+1,r]+rx[l,mid+1])$

这个还是很好理解的。就是选不选mid的两个决策。但是其实在实现的时候，我们并不用[l,r]的二维方式来记录这三个标记，而是用对应的节点编号来表示区间，这个可以看程序，其实是个很简单的东西。

那么最大子序列这个询问操作就可以很简单的解决了，还是类比前面的方法，就是把k和k+tot+1移到对应的根和右儿子的位置，然后直接输出右儿子的左儿子上的mx标记即可

### 懒标记的处理

最后，相信认真看了的童鞋会有疑问，这个标记怎么下传呢？首先，我们在每次将k和k+tot+1移到对应的位置时，需要一个类似查找k大值的find操作，即找出在平衡树中，实际编号为k在树中中序遍历的编号，这个才是我们真正需要处理的区间端点编号，那么就好了，我们只需在查找的过程中下传标记就好了！（其实线段树中也是这么做的），因为我们所有的操作都需要先find一下，所以我们可以保证才每次操作的结果计算出来时，对应的节点的标记都已经传好了。而我们在修改时，直接修改对应节点的记录标记和懒标记，因为我们的懒标记记录的都是已经对当前节点产生贡献，但是还没有当前节点的子树区间产生贡献！然后就是每处有修改的地方都要pushup一下就好了。

### 一些细节

另外，由于本题数据空间卡的非常紧，我们就需要用时间换空间，直接开4000000\*logm的数据是不现实的，但是由于题目保证了同一时间在序列中的数字的个数最多是500000，所以我们考虑一个回收机制，把用过但是已经删掉的节点编号记录到一个队列或栈中，在新建节点时直接把队列中的冗余编号搞过来就好了。

### 后言

**实现时还有诸多细节，务必要细看代码，加深了解。**


## 参考代码：


``` cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#define rint register int
#define For(i,a,b) for (rint i=a;i<=b;++i)
using namespace std;
const int inf=0x3f3f3f3f;
const int N=1e6+17;
int n,m,rt,cnt;
int a[N],id[N],fa[N],c[N][2];
int sum[N],sz[N],v[N],mx[N],lx[N],rx[N];
bool tag[N],rev[N];
//tag表示是否有统一修改的标记，rev表示是否有统一翻转的标记
//sum表示这个点的子树中的权值和，v表示这个点的权值
queue<int> q;
inline int read(){
    rint x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
inline void pushup(rint x){
    rint l=c[x][0],r=c[x][1];
    sum[x]=sum[l]+sum[r]+v[x];
    sz[x]=sz[l]+sz[r]+1;
    mx[x]=max(mx[l],max(mx[r],rx[l]+v[x]+lx[r]));
    lx[x]=max(lx[l],sum[l]+v[x]+lx[r]);
    rx[x]=max(rx[r],sum[r]+v[x]+rx[l]);
}
//上传记录标记
inline void pushdown(rint x){
    rint l=c[x][0],r=c[x][1];
    if (tag[x]){
        rev[x]=tag[x]=0;//我们有了一个统一修改的标记，再翻转就没有什么意义了
        if (l)tag[l]=1,v[l]=v[x],sum[l]=v[x]*sz[l];
        if (r)tag[r]=1,v[r]=v[x],sum[r]=v[x]*sz[r];
        if (v[x]>=0){
            if (l)lx[l]=rx[l]=mx[l]=sum[l];
            if (r)lx[r]=rx[r]=mx[r]=sum[r];
        }else{
            if (l)lx[l]=rx[l]=0,mx[l]=v[x];
            if (r)lx[r]=rx[r]=0,mx[r]=v[x];
        }
    }
    if (rev[x]){
        rev[x]=0;rev[l]^=1;rev[r]^=1;
        swap(lx[l],rx[l]);swap(lx[r],rx[r]);
        //注意，在翻转操作中，前后缀的最长上升子序列都反过来了，很容易错
        swap(c[l][0],c[l][1]);swap(c[r][0],c[r][1]);
    }
}
//下传标记
inline void rotate(rint x,rint &k){
    rint y=fa[x],z=fa[y],l=(c[y][1]==x),r=l^1;
    if (y==k)k=x;else c[z][c[z][1]==y]=x;
    fa[c[x][r]]=y;fa[y]=x;fa[x]=z;
    c[y][l]=c[x][r];c[x][r]=y;
    pushup(y);pushup(x);
    //旋转操作，一定要上传记录标记
}
inline void splay(rint x,rint &k){
    while (x!=k){
        int y=fa[x],z=fa[y];
        if (y!=k){
            if (c[z][0]==y ^ c[y][0]==x)rotate(x,k);
                else rotate(y,k);
        }
        rotate(x,k);
    }
}
//这是整个程序的核心之一，毕竟是伸展操作嘛
inline int find(rint x,rint rk){
    pushdown(x);
    //因为所有的操作都需要find，所以我们只需在这里下传标记就行了
    rint l=c[x][0],r=c[x][1];
    if (sz[l]+1==rk)return x;
    if (sz[l]>=rk)return find(l,rk);
        else return find(r,rk-sz[l]-1);
}
//这个find是我们整个程序的核心之二
//因为我们的区间翻转和插入及删除的操作的存在
//我们维护的区间的实际编号并不是连续的
//而，我们需要操作的区间又对应着平衡树的中序遍历中的那段区间
//所以这个find很重要
inline void recycle(rint x){
    rint &l=c[x][0],&r=c[x][1];
    if (l)recycle(l);
    if (r)recycle(r);
    q.push(x);
    fa[x]=l=r=tag[x]=rev[x]=0;
}
//这就是用时间换空间的回收冗余编号机制，很好理解
inline int split(rint k,rint tot){
    rint x=find(rt,k),y=find(rt,k+tot+1);
    splay(x,rt);splay(y,c[x][1]);
    return c[y][0];
}
//这个split操作是整个程序的核心之三
//我们通过这个split操作，找到[k+1,k+tot]，并把k,和k+tot+1移到根和右儿子的位置
//然后我们返回了这个右儿子的左儿子，这就是我们需要操作的区间
inline void query(rint k,rint tot){
    rint x=split(k,tot);
    printf("%d\n",sum[x]);
}
inline void modify(rint k,rint tot,rint val){
    rint x=split(k,tot),y=fa[x];
    v[x]=val;tag[x]=1;sum[x]=sz[x]*val;
    if (val>=0)lx[x]=rx[x]=mx[x]=sum[x];
        else lx[x]=rx[x]=0,mx[x]=val;
    pushup(y);pushup(fa[y]);
    //每一步的修改操作，由于父子关系发生改变
    //及记录标记发生改变，我们需要及时上传记录标记
}
inline void rever(rint k,rint tot){
    rint x=split(k,tot),y=fa[x];
    if (!tag[x]){
        rev[x]^=1;
        swap(c[x][0],c[x][1]);
        swap(lx[x],rx[x]);
        pushup(y);pushup(fa[y]);
    }
    //同上
}
inline void erase(rint k,rint tot){
    rint x=split(k,tot),y=fa[x];
    recycle(x);c[y][0]=0;
    pushup(y);pushup(fa[y]);
    //同上
}
inline void build(rint l,rint r,rint f){
    rint mid=(l+r)>>1,now=id[mid],pre=id[f];
    if (l==r){
        mx[now]=sum[now]=a[l];
        tag[now]=rev[now]=0;
        //这里这个tag和rev的清0是必要，因为这个编号可能是之前冗余了
        lx[now]=rx[now]=max(a[l],0);
        sz[now]=1;
    }
    if (l<mid)build(l,mid-1,mid);
    if (mid<r)build(mid+1,r,mid);
    v[now]=a[mid]; fa[now]=pre;
    pushup(now);
    //上传记录标记
    c[pre][mid>=f]=now;
    //当mid>=f时，now是插入到又区间取了，所以c[pre][1]=now，当mid<f时同理
}
inline void insert(rint k,rint tot){
    For(i,1,tot)a[i]=read();
    For(i,1,tot)
        if (!q.empty())id[i]=q.front(),q.pop();
        else id[i]=++cnt;//利用队列中记录的冗余节点编号
    build(1,tot,0);//将读入的tot个树建成一个平衡树
    rint z=id[(1+tot)>>1];//取中点为根
    rint x=find(rt,k+1),y=find(rt,k+2);
    //首先，依据中序遍历，找到我们需要操作的区间的实际编号
    splay(x,rt);splay(y,c[x][1]);
    //把k+1(注意我们已经右移了一个单位）和(k+1)+1移到根和右儿子
    fa[z]=y;c[y][0]=z;
    //直接把需要插入的这个平衡树挂到右儿子的左儿子上去就好了
    pushup(y);pushup(x);
    //上传记录标记
}
//对于具体在哪里上传标记和下传标记
//可以这么记，只要用了split就要重新上传标记
//只有find中需要下传标记
//但其实，你多传几次是没有关系的，但是少传了就不行了
int main(){
    n=read(),m=read();
    mx[0]=a[1]=a[n+2]=-inf;
    For(i,1,n)a[i+1]=read();
    For(i,1,n+2)id[i]=i;//虚拟了两个节点1和n+2，然后把需要操作区间整体右移一个单位
    build(1,n+2,0);//建树
    rt=(n+3)>>1;cnt=n+2;//取最中间的为根
    rint k,tot,val;char ch[10];
    while (m--){
        scanf("%s",ch);
        if (ch[0]!='M' || ch[2]!='X') k=read(),tot=read();
        if (ch[0]=='I')insert(k,tot);
        if (ch[0]=='D')erase(k,tot);
        if (ch[0]=='M'){
            if (ch[2]=='X')printf("%d\n",mx[rt]);
            else val=read(),modify(k,tot,val);
        }
        if (ch[0]=='R')rever(k,tot);
        if (ch[0]=='G')query(k,tot);
    }
    return 0;
}
```

---

## 作者：Ofnoname (赞：107)

## FHQ treap 详细做法
尽管题解巨多，`FHQ treap`却并没有多少人用，所以还是可以写题解的。

在阅读本文之前，你应该学过`FHQ treap`，会打`split`和`merge`函数
```cpp
#define i0 a[i].L//左子树
#define i1 a[i].R//右子树
struct Node
{
	int L, R, se, z, f0, f, size;
	int sum, max, max0, max1;
}a[MAX];

void split(int i, int &x, int &y, int k)
{
	if (!i)
	{
		x = y = 0;
		return;
	}
	pushtag(i);
	if (a[i0].size < k)
		x = i, split(i1, i1, y, k-a[i0].size-1);
	else
		y = i, split(i0, x, i0, k);
	update(i);
}

int merge(int x, int y)
{
	if (!x || !y) return x + y;
	if (a[x].se < a[y].se)
	{
		pushtag(x);
		a[x].R = merge(a[x].R, y);
		return update(x), x;
	}
	pushtag(y);
	a[y].L = merge(x, a[y].L);
	return update(y), y;
}
```

### 1. 平衡树进行区间操作的本质。
在做平衡树模板时，只涉及到了“插入数”和“删除数”，并没有具体的序列（除非你用数组做）。

而进行区间操作时，区间的下标满足`BST`性质，整棵树的中序遍历直接构成这个序列，序列的权值存在点里，而节点本身的编号什么也不代表。

所以对区间`[pos, pos+len-1]`进行操作时，只需要`split`两次，将`treap`裂为三段，并对中间一段进行操作，然后再`merge`即可。
```cpp
split(root, x, y, pos);//将整棵树的前pos给x
split(y, y, z, len-1)//将后半段的前len-1给y，剩下的是z
//对y进行操作
root = merge(merge(x, y), z)//将三段合并
```
### 2. 内存问题
本题操作数为4e6，如果开`4e6`的数组，由于每个节点信息很多，会`MLE`。

但是序列里最多只有`5e5`个数，我们可以在删除时将删掉的节点存储下来（放进栈里），再创建新节点时，如果栈中有数就再用一次这个数，可以省下内存。注意先将节点清空。
```cpp
int top, S[MAX];
int New(int z)
{
    int id = top ? S[top--] : ++nc;//取栈中节点
    memset(a+id, 0, sizeof(Node));
    a[id].sum = a[id].z = a[id].max = z;
    a[id].max0 = a[id].max1 = max(0, z);//max可以参见后文
    a[id].size = 1, a[id].se = rand();
    return id;
    
}
```
### 3. 插入数
首先，无论是初始化还是中途的`INSERT`都是一次插入多个数，我们知道插入一个数是需要`split`一次，`merge`一次的，如果一个一个插入将会很浪费。

我们可以在`pos`处直接断开，然后在前一半添加一个包含所有待添加数的新`treap`，再把两段合并。这样就只用`split`一次。

如何用数列构造新`treap`呢？可以折半递归，分别申请新节点，再往上合并，这`merge`只用执行`log`级别的次数。
```cpp
int add(int L, int R)
{
    if (L != R)
    {
        int mid = (L + R) >> 1;
        return merge(add(L,mid), add(mid+1,R));
    }return New(t[L]);
}

for (int i = 1; i <= N; i++)//Init
    scanf("%d", &t[i]);
root = merge(root, add(1, N));

if (op[2] == 'S')//Insert
{
    split(root, x, y, pos);
    for (int i = 1; i <= len; i++)
        scanf("%d", &t[i]);
    root = merge(merge(x, add(1, len)), y);
}
```
### 4. 删除数
很简单，按照**1**里的代码将`treap`拆解为3段，将中间一段删除即可。

由于要将删掉的数不可能再用到，要立即存入回收站以供使用，没有必要使用懒标记，直接递归删除即可。
```cpp
void rmv(int i)
{
    S[++top] = i;
    if (i0) rmv(i0);
    if (i1) rmv(i1);
}
if (op[2] == 'L')//Delete
{
    split(root, x, y, pos-1), split(y, y, z, len);
    rmv(y)， root = merge(x, z);
}
```
### 5. 区间推平

把要推平的区间拿出来，取第一个点打上懒标记。懒标记与线段树的相同（即要先更新自己，再打标记）。
```cpp
void cover(int i, int c)
{
	a[i].z =  c;//更新自己的权值
	a[i].sum = a[i].size * c;//更新区间和
	a[i].max0 = a[i].max1 = max(0, a[i].sum);
	a[i].max = max(c, a[i].sum);//max可参见后文
	a[i].f0 = 1;//懒标记
}
if (op[2] == 'K')//Make_Same
{
    scanf("%d", &c);
    split(root, x, y, pos-1), split(y, y, z, len);
    cover(y, c);
    root = merge(merge(x, y), z);
}
```
### 6. 翻转

同上，要打懒标记。但是懒标记可以写作`f ^= 1`。这是因为翻转两次就相当于没有翻转，所以`f = 1`时在打标记就是0。
```cpp
void reverse(int i)
{
	swap(i0, i1), swap(a[i].max0, a[i].max1);//max参见后文
	a[i].f ^= 1;
}

if (op[2] == 'V')//Reverse
{
    split(root, x, y, pos-1), split(y, y, z, len);
    reverse(y);
    root = merge(merge(x, y), z);
}
```
### 7. 懒标记下推
推平和翻转的标记都要推，先后顺序没关系。清楚标记，并将左右节点调用`reverse/cover`即可，左右子树`cover`的值显然应该是本节点的权值。
```cpp
void pushtag(int i)
{
    if (!i) return;
    if (a[i].f)
    {
        if (i0) reverse(i0);
        if (i1) reverse(i1);
        a[i].f = 0;
    }
    if (a[i].f0)
    {
        if (i0) cover(i0, a[i].z);
        if (i1) cover(i1, a[i].z);
        a[i].f0 = 0;
    }
}
```
### 8. 查询区间和

中等简单。`a[i].sum`代表自己和自己子树构成区间的权值总和。

每个点在创建时的`sum`显然应赋值为自己的权值。（参见前文`New()`）

而`update`时显然有`a[i].sum = a[i0].sum + a[i1].sum + a[i].z`。（参见后文）

将给定区间拆解输出即可。

```cpp
if (op[2] == 'T')//GET_SUM
{
    split(root, x, y, pos-1), split(y, y, z, len);
    printf("%d\n", a[y].sum);
    root = merge(merge(x, y), z);
}
```

### 9. 查询最大子段和

最难最麻烦。本题的子段和至少选一个数。

维护每个点及其子树构成区间的最大前缀和`max0`，最大后缀和`max1`和最大子段和`max`。

显然每个点在创建时这些都应赋值为自己的权值（参见前文`New()`）

`update`时，一段`[L,R]`最大前缀和可以有“终点在`mid`左端（`a[i0].max0`）”和“终点在`mid`右（`a[i0].sum + a[i].z + a[i1].max0`）`”两种情况，取最大值即可。

最小后缀和同理，有`a[i].max1 = max(a[i1].max1, a[i1].sum + a[i].z + a[i0].max1`

而最大子段和`max`就是左端和最大后缀和与右端的最大前缀和之和。或者不经过`i`点，取两边的`max`值
```cpp
a[i].max = a[i0].max1 + a[i1].max0 + a[i].z;
a[i].max = max(a[i].max, max(a[i0].max, a[i1].max));
```

翻转区间时，显然后缀和，前缀和反了，所以要`swap(a[i].max0, a[i].max1)`。

需要注意的是，由于不能有空段，所以`max`赋值时不能与0取最大，但是当拼接`a[i].max`时，我们发现`i`自己的权值是必选的，即使`max0`，`max1`为空，整个序列也是有一个`i`点的。因此可以让`max0`，`max1`计算时与0取最大（即什么都不选）。

有了**8，9**两点，`update`函数不难写出：
```cpp
void update(int i)
{
	if (!i) return;
	a[i].size = a[i0].size + a[i1].size + 1;
	a[i].sum = a[i0].sum + a[i1].sum + a[i].z;
	a[i].max0 = max(max(a[i0].max0, a[i0].sum + a[i].z + a[i1].max0), 0);
	a[i].max1 = max(max(a[i1].max1, a[i1].sum + a[i].z + a[i0].max1), 0);
	a[i].max = max(a[i0].max1 + a[i1].max0, 0) + a[i].z;
	if (i0) a[i].max = max(a[i].max, a[i0].max);
	if (i1) a[i].max = max(a[i].max, a[i1].max);
}

else printf("%d\n", a[root].max);//MAX-SUM
```
至此问题已经全部解决。

谢谢观看，完结撒花。

---

## 作者：x义x (赞：74)

众所周知这是一道非常恶心的题目……坑点实在太多……

本人使用fhqtreap实现。150行左右，也只是``Merge``和``Split``里稍微压了几行，比起一般的splay还是要短不少的。

先分析一下，此题需要维护区间和以及区间最大子段和。显然按size分裂不用多说。区间和非常简单，区间最大子段和则稍微有点麻烦，需要额外维护区间最大前缀，区间最大后缀。``pushup``时实现如下：

```
T[x].maxqz=max(max(T[T[x].l].maxqz,T[T[x].l].sum+T[x].val+T[T[x].r].maxqz),0);
T[x].maxhz=max(max(T[T[x].r].maxhz,T[T[x].r].sum+T[x].val+T[T[x].l].maxhz),0);
T[x].maxzd=max(T[x].val,T[x].val+T[T[x].l].maxhz+T[T[x].r].maxqz);
if(T[x].l) T[x].maxzd=max(T[x].maxzd,T[T[x].l].maxzd);
if(T[x].r) T[x].maxzd=max(T[x].maxzd,T[T[x].r].maxzd);
```

注意这里和线段树维护区间最大子段和的代码有细微区别：我们有些地方要加上``T[x].val``。原因显然，父节点不仅仅是该区间的代表，也包括了对应单个位置的信息，区间加法应是：左区间+该节点对应位置+右区间=整个区间。

同时我们还要维护两个lazytag：翻转区间和区间赋值。

区间赋值很好搞（然而也有需要注意的点，见下），区间翻转的实现方式则是交换一个节点的左右儿子。整颗子树的左右儿子都交换了区间就成功翻转了。当然实际上我们要使用lazytag，而不是在翻转的时候直接搜进子树全部交换掉。（具体怎么操作，见下）

然后是~~一些~~很多实现上的坑点……

### 坑点一：空间问题

数据范围里说了，最多插入``4*1e6``个数，任何时候数列里最多``5*1e5``个数。然而因为此题要维护的tag实在太多，我维护了9个``int``类型和2个``bool``类型，如果直接开``4.5*1e6``个节点是肯定开不下的。

注意到序列里最多``5*1e5``个数，所以肯定会有很多，但不会太多（最多``4.5*1e6``）的节点被删掉，我们想到可以把废掉的节点重复利用。所以当执行区间删除操作时，我们要遍历被删除的那棵树并把所有节点的编号放入一个“垃圾场”（我使用了一个栈），创建新节点的时候到“垃圾场”里去取可用的编号。这样空间就比较健康了。

### 坑点二：关于区间修改

（其实这个坑点是我自己sb了）

区间修改不能用“删除原区间再插入一大段相同的数”来实现，否则你的第9个点会跑将近半分钟。原因是显然的：如果有一大堆赋值操作，你就会删除一大堆节点（可能远远超过``4.5*1e6``），于是复杂度就假了。

还是老老实实用lazytag吧。

### 坑点三：区间翻转会导致前缀变成后缀，后缀变成前缀

如题。

### 坑点四：此题中，区间最大子段不.能.为.空.

是我做题太少还是其他题目真的都规定可以选空段……

所以：

- 新建节点的时候强制最大字段和为该位置权值

- 进行区间赋值的时候，如果赋值为一个负数，区间最大字段和也必须得选**一个**。

然而最大前缀后缀还是可以取空段的。原因大约可以解释为“左儿子后缀+父亲权值+右儿子前缀”合并成区间子段的时候，显然必选一个父亲节点，所以就算左儿子前缀、右儿子后缀都为空也不会选到空段。

### 坑点五：多push_down，push_up

虽然我的写法并没有遇到这个问题，但是有些写法可能会遇到，还是注意一下吧。

### 坑点六：打lazytag的时候建议这么搞

比如区间翻转，我们这样搞：

```cpp
void Reverse(int x){
	if(!x) return;
	swap(T[x].l,T[x].r);
	swap(T[x].maxhz,T[x].maxqz);
	T[x].lzy^=1;
}
```

并不在下传lazytag的时候交换左右儿子而是现在就交换。``push_down``的时候，则``Reverse``左儿子，右儿子。

区间赋值类似。

实际调试的时候每个人还会遇到一些比较个人性的错误，此处没法展开讲了。我的代码如下。

不开O2的话3.41s，开O2的话1.08s，果然还是太菜了。

```cpp
#include<bits/stdc++.h>
using namespace std;

int stk[500005],len; 

int inline read(){
	int num=0;bool neg=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') neg=1;c=getchar();}
	while(c>='0'&&c<='9') num=num*10+c-'0',c=getchar();
	return neg?-num:num; 
}

struct fhqtreap{
	int l,r,s,val,cov;bool lzy,cov_flg;
	int sum,maxqz,maxhz,maxzd;
}T[500005];int idx,rt;
int NewNode(int v){
	idx=stk[len--];T[idx].l=T[idx].r=T[idx].lzy=T[idx].cov=0;
	T[idx].s=1;
	T[idx].val=T[idx].sum=v;
	T[idx].maxqz=T[idx].maxhz=max(0,v);T[idx].maxzd=v;
	return idx;
}
void push_up(int x){
	if(!x) return;
	T[x].s=T[T[x].l].s+T[T[x].r].s+1;
	T[x].sum=T[T[x].l].sum+T[T[x].r].sum+T[x].val;
	T[x].maxqz=max(max(T[T[x].l].maxqz,T[T[x].l].sum+T[x].val+T[T[x].r].maxqz),0);
	T[x].maxhz=max(max(T[T[x].r].maxhz,T[T[x].r].sum+T[x].val+T[T[x].l].maxhz),0);
	T[x].maxzd=max(T[x].val,T[x].val+T[T[x].l].maxhz+T[T[x].r].maxqz);
	if(T[x].l) T[x].maxzd=max(T[x].maxzd,T[T[x].l].maxzd);
	if(T[x].r) T[x].maxzd=max(T[x].maxzd,T[T[x].r].maxzd);
}
void Reverse(int x){
	if(!x) return;
	swap(T[x].l,T[x].r);
	swap(T[x].maxhz,T[x].maxqz);
	T[x].lzy^=1;
}
void Cover(int x,int ci){
	T[x].val=T[x].cov=ci;T[x].sum=T[x].s*ci;
	T[x].maxqz=T[x].maxhz=max(0,T[x].sum);
	T[x].maxzd=max(ci,T[x].sum);
	T[x].cov_flg=1;
}
void push_down(int x){
	if(!x) return;
	if(T[x].lzy){
		if(T[x].l) Reverse(T[x].l);
		if(T[x].r) Reverse(T[x].r);
		T[x].lzy=0;
	}
	if(T[x].cov_flg){
		if(T[x].l) Cover(T[x].l,T[x].cov);
		if(T[x].r) Cover(T[x].r,T[x].cov);
		T[x].cov=T[x].cov_flg=0;
	}
}
void Del(int x){
	if(!x) return;
	stk[++len]=x;
	if(T[x].l) Del(T[x].l);if(T[x].r) Del(T[x].r);
}
void Split(int x,int &L,int &R,int K){
	if(x) push_down(x);
	if(!x){L=R=0;return;}
	if(T[T[x].l].s+1<=K) L=x,Split(T[x].r,T[L].r,R,K-T[T[x].l].s-1);
	else				 R=x,Split(T[x].l,L,T[R].l,K);
	push_up(x);
}
void Merge(int x,int y,int &M){
	if(!x||!y){M=x+y;return;}
	if(90000008%(T[x].s+T[y].s)<T[x].s)
		 push_down(x),M=x,Merge(T[x].r,y,T[M].r),push_up(x);
	else push_down(y),M=y,Merge(x,T[y].l,T[M].l),push_up(y);
}

int N,M;
int A[500005];
int Build(int l,int r){
	if(l==r){
		return NewNode(A[l]);
	}
	int x,mid=(l+r)>>1;
	Merge(Build(l,mid),Build(mid+1,r),x);
	return x;
}

char opt[10];
int main(){
	N=read(),M=read();
	for(int i=1;i<=500000;++i) stk[++len]=i;
	for(int i=1;i<=N;++i) A[i]=read();
	Merge(rt,Build(1,N),rt);
	while(M--){
		scanf("%s",opt);
		if(opt[0]=='I'){
			int pos=read(),tot=read();
			int x,y;
			Split(rt,x,y,pos);
			for(int i=1;i<=tot;++i) A[i]=read();
			Merge(x,Build(1,tot),x);
			Merge(x,y,rt);
		}
		else if(opt[0]=='D'){
			int pos=read(),tot=read();
			int x,y,z;
			Split(rt,x,y,pos-1);
			Split(y,y,z,tot);
			Del(y);
			Merge(x,z,rt);
		}
		else if(opt[0]=='M'&&opt[2]=='K'){
			int pos=read(),tot=read(),ci=read();
			int x,y,z;
			Split(rt,x,y,pos-1);
			Split(y,y,z,tot);
			Cover(y,ci);
			Merge(x,y,x);
			Merge(x,z,rt);
		}
		else if(opt[0]=='R'){
			int pos=read(),tot=read();
			int x,y,z;
			Split(rt,x,y,pos-1);
			Split(y,y,z,tot);
			Reverse(y);
			Merge(x,y,y);
			Merge(y,z,rt);
		}
		else if(opt[0]=='G'){
			int pos=read(),tot=read();
			int x,y,z;
			Split(rt,x,y,pos-1);
			Split(y,y,z,tot);
			printf("%d\n",T[y].sum);
			Merge(x,y,y);
			Merge(y,z,rt);
		}
		else if(opt[0]=='M'&&opt[2]=='X'){
			printf("%d\n",T[rt].maxzd);
		}
	}
	
	return 0;
}
```


---

## 作者：hyfhaha (赞：61)



区间树这玩意真TM玄学。我是不是也应该说一声.

# 无指针超详细Splay讲解

## 学这东西你必须要拥有的

1.通过[【模板】文艺平衡树（Splay）](https://www.luogu.org/problemnew/show/P3391)，[【模板】普通平衡树](https://www.luogu.org/problemnew/show/P3369)，[GSS3 - Can you answer these queries III](https://www.luogu.org/problemnew/show/SP1716).

2.学会Splay，学会求最大子段和并知道怎么维护信息和下传标记，及会有区间修的最大子段和.

3.~~多年的编程技巧~~，以及一颗写数据结构的良好心态.

4.攒够~~两个月的~~肝，这很重要！

## 如果你不会上面东西的解决方法

1.看以下博客[Splay入门解析](https://www.cnblogs.com/cjyyb/p/7499020.html)，[文艺平衡树Splay题解](https://www.luogu.org/blog/cjyyb/solution-p3391)，[GSS系列题解——最大子段和系列](https://www.luogu.org/blog/juruohyfhaha/gss-ji-lie-ti-xie-zui-tai-zi-duan-hu-ji-lie)。

2.看上面.

3.别管，瞎逼的.

4.好好养生，如果不够肝的话千万别写这道题.

# 那么现在就可以开始了

既然你已经会了上面的前置技能，那么我们就可以开始**分步**解决这道题了。

先给出我们需要存的全部信息：

```cpp
struct kkk{
	int ch[2];			//左右儿子
	int size;			//子树大小
	int fa;				//父亲
	int tag;			//赋值标记
	int val;			//权值
	int rev;			//翻转标记			
	int sum;			//区间权值和
	int left;			//左区间，指区间最大前缀和
	int right;			//右区间，指区间最大后缀和
	int middle;			//中区间，指区间最大子段和
	void clear(){ch[0]=ch[1]=fa=rev=0;tag=TAGNONE;}	//清空节点信息
}tree[maxn];
```

存的东西很多，大家务必要理解清楚每一个信息所表达的含义。

# 区间树Splay介绍

做过“普通平衡树”的都知道，在“普通平衡树”里，Splay是按照权值来排序的，所以能维护数的关系。那么现在到了维护区间上的操作了，也就不能按权值来排序了。

区间树，我们按照的是序列中的**编号**来排序。

我们可以发现，序列中的第**k**个点，在Splay中也是第**k**大的。（按编号排序嘛.

所以我们想要查找序列中第**k**个位置，就直接找**Splay**中的第**k**大就可以了。

所以“普通平衡树”里的**Splay**操作，**rotate**操作和**kth**操作都是可以直接照搬的（一样的，只是维护编号而已.

那么我们怎么在Splay中找到一个区间[x,y]呢？

我们可以考虑Splay的性质，将 **x** Splay上根，再将 **y** Splay上到x的右节点，那么我们得出的 **y** 的左子树就是我们要的[x,y]区间。

之后我们想对这个区间做什么就可以直接对那颗子树做了。 

上面就是区间树的一些介绍.

### 代码中的一些宏定义

```cpp
#define TAGNONE 10000001				//没有赋值tag的标志
#define L(node) (tree[node].ch[0])		//替左儿子
#define R(node) (tree[node].ch[1])		//替右儿子
#define F(node) (tree[node].fa)			//替父亲
#define V(node) (tree[node].val)		//替权值
#define S(node) (tree[node].size)		//替子树大小
#define compare(node,x) (tree[node].val<x)	//比较node是权值x的左儿子还是右儿子
```
# 操作剖析

## 1.基本操作 Splay,rotate,kth

这个就不用怎么说了吧，大家在做平衡树Splay都写过的啦！

## 2.将指定区间找出来 split操作

和上面讲的区间树一样，先找到区间[l,r]的kth，计**l**的kth为**x**，**r**的kth为**y**。

然后Splay(x,0);Splay(y,x); （直接上代码解释).

最后返回**y**的**左儿子**就是指定区间.

代码：

```cpp
int split(int k,int len){	//找到那个区间的位置
	int x=kth(k),y=kth(k+len+1);
	Splay(x,0);Splay(y,x);
	return L(y);
}
```

## 3.建一颗平衡的Splay，build操作

一开始我们要构造一颗有初始信息的Splay，一个一个insert显然很慢，所以我们写一个build，可以将一段序列建成一颗平衡的Splay的操作。

其实写起来和线段树差不多，注意是以**编号**排序来建树。

```cpp
void New(int node,int x){                       //新建节点
	tree[node].middle=tree[node].sum=x;         //赋值信息
	tree[node].tag=TAGNONE;tree[node].rev=0;    //标记初始化
	tree[node].left=tree[node].right=max(x,0);  //区间赋值
	tree[node].size=1;          //大小赋值
}
void build(int begin,int end,int fa){			//建树
	int mid=(begin+end)>>1;int node=id[mid],pre=id[fa];
	if(begin==end)			//到达底部
		New(node,a[begin]);	//新建一个节点
	if(begin<mid)build(begin,mid-1,mid);	//建左子树
	if(mid<end)build(mid+1,end,mid);		//建右子树
	tree[node].val=a[mid];tree[node].fa=pre;tree[node].tag=TAGNONE;	//基本信息赋值
	pushup(node);			//维护信息
	tree[pre].ch[mid>=fa]=node;
}
```

## 4.插入操作 insert

这里题目要求的是在x位置后插入一段长为len的序列.

如果我们还是一个一个插入，仍然很慢，所以我们可以直接把插入的序列build成一颗平衡的子树，最后直接在x后插入建成的子树就可以了。

```cpp
void insert(int k,int len){			//插入区间
	for(int i=1;i<=len;i++)scanf("%d",&a[i]);	//输入区间
	for(int i=1;i<=len;i++)
		id[i]=rublish();			//从垃圾桶里找一个编号
	build(1,len,0);					//将输入的区间建成一个完全二叉树
	int z=id[(1+len)>>1];
	int x=kth(k+1),y=kth(k+2);		//找到要插入的位置
	Splay(x,0);Splay(y,x);
	tree[z].fa=y; tree[y].ch[0]=z;	//将新建的子树插入树中
	pushup(y);pushup(x);			//维护信息
}
```

## 5.删除操作 eraser

这个就更简单了，直接找到那个区间，然后让那个子树的父亲将左儿子清为0就可以了。

但是，为了节省空间，我们加入了一个垃圾回收的操作，就是将删除的节点重新利用起来，以节省空间.

所以我们还要遍历一遍子树将那颗子树的节点扔进垃圾桶里.

```cpp
int rublish(){				//垃圾回收
	if(top==0)return ++cnt;
	int node=rub[top--];
	return node;
}
void remove(int node){		//将一个子树清空
	if(L(node))remove(L(node));		//继续清空左子树
	if(R(node))remove(R(node));		//继续清空右子树
	rub[++top]=node; tree[node].clear();	//清空并仍进垃圾桶，定义里有
}
void eraser(int x,int len){			//删除区间
	int node=split(x,len),y=F(node);//找到该区间
	remove(node);tree[y].ch[0]=0;	//删除该区间，子树清空
	pushup(y);pushup(F(y));			//维护信息
}
```

## 6.修改操作 update

一样的，先找到指定区间的子树，然后直接修改信息，打上赋值标记.

```cpp
void change_val(int node,int val){          //更新点值
	if(!node)return ;   //空节点返回
	tree[node].tag=tree[node].val=val;      //打赋值标记，更新权值
	tree[node].sum=val*tree[node].size;     //更新区间权值和
	tree[node].left=tree[node].right=max(tree[node].sum,0); //左右区间更新
	tree[node].middle=max(tree[node].sum,val);  //最大子段和更新
}
void update(int x,int len,int val){	//更新区间的指
	int node=split(x,len),y=F(node);	//找到该区间
	change_val(node,val);			//更新该区间
	pushup(y);pushup(F(y));			//维护信息
}
```

## 7.翻转操作 reverse

一样的，先找到指定的区间的子树，然后直接翻转，打上翻转标记.

```cpp
void change_rev(int node){                  //更新翻转
	swap(tree[node].ch[0],tree[node].ch[1]);//交换左右儿子
	swap(tree[node].left,tree[node].right); //交换左右区间
	tree[node].rev^=1;						//打翻转标记
}
void reverse(int x,int len){			//翻转区间
	int node=split(x,len),y=F(node);//找到该区间
	if(tree[node].tag!=TAGNONE)return ;	//如果已经有赋值标记就不用管了
	change_rev(node);				//翻转该区间
	pushup(y);pushup(F(y));			//维护信息
}
```

## 8.求和操作 query

这就更简单了，找到指定区间的子树，然后直接输出那颗子树的sum就OK了.

```cpp
void query(int x,int len){	//查询区间权值和
	int node=split(x,len);	//找到该区间
	printf("%d\n",tree[node].sum);	//输出答案
}
```

## 9.求最大子段和

直接输出root的middle最大子段和.

```cpp
printf("%d\n",tree[root].middle);
```

# 难点

## 10.维护信息和下传标记

这玩意是真毒瘤，不过主要还是难在最大子段和上面，只要我们能理解“GSS3”中的求法，其实也很简单。

维护信息，所以除了这个最大子段和之外，好像还挺简单的。最大子段和那几个更新方法这里就不讲了，不知道可以看上面的博客。

```cpp
void pushup(int node){					//维护信息
	kkk &x=tree[L(node)],&y=tree[R(node)];int val=tree[node].val;	//实质是将左右儿子合并，x代替左儿子，y代替右儿子
	kkk &res=tree[node];				//res代替tree[node]
	res.sum=x.sum+y.sum+val; res.size=x.size+y.size+1;	//权值和更新，子树大小更新
	res.middle=max(max(x.middle,y.middle),x.right+y.left+val);	//最大子段和更新
	res.left=max(x.left,x.sum+y.left+val);			//区间最大前缀和更新
	res.right=max(y.right,y.sum+x.right+val);		//区间最大后缀和更新
}
```

下传标记，这本来是比较得毒瘤，我们要先更新赋值操作，左右儿子有很多信息需要更新，其中就有tag，sum，left，right和middle，更新起来十分的繁琐。但是在之前的赋值操作update中，我们引入了一个叫change_val的函数，所以这里，我们可以直接调用那个函数。于是代码就被减短了很多。

最后将tag标记为TAGNONE就OK了.

然后要更新翻转操作，一样的，在之前翻转操作revrese中，我们引入了一个叫change_rev的函数，所以这里，我们还是可以直接调用。于是代码又被减了……

最后将rev标记为0就OK了。

代码：

```cpp
void pushdown(int node){				//标记下传
	if(tree[node].tag!=TAGNONE){		//判断有没有赋值标记
		change_val(L(node),tree[node].tag);	//更新左儿子
		change_val(R(node),tree[node].tag);	//更新右儿子
		tree[node].tag=TAGNONE;			//除去标记
	}
	if(tree[node].rev){					//判断有没有翻转标记
		change_rev(L(node));			//更新左儿子
		change_rev(R(node));			//更新右儿子
		tree[node].rev=0;				//除去标记
	}
}
```

看，多简短!

## 11.主函数

注意边界！注意边界！注意边界！ 主要的事情说三遍！

其他就没什么了，都是输入嘛。

# 总代码

```cpp
#include<bits/stdc++.h>
#define TAGNONE 10000001
#define maxn 1000010
#define inf 100000001
#define L(node) (tree[node].ch[0])		//替左儿子
#define R(node) (tree[node].ch[1])		//替右儿子
#define F(node) (tree[node].fa)			//替父亲
#define V(node) (tree[node].val)		//替权值
#define S(node) (tree[node].size)		//替子树大小
#define compare(node,x) (tree[node].val<x)	//比较node是权值x的左儿子还是右儿子
using namespace std;
int root,cnt,a[maxn],id[maxn],rub[maxn],top,n,m;
struct kkk{
	int ch[2];			//左右儿子
	int size;			//子树大小
	int fa;				//父亲
	int tag;			//赋值标记
	int val;			//权值
	int rev;			//翻转标记			
	int sum;			//区间权值和
	int left;			//左区间，指区间最大前缀和
	int right;			//右区间，指区间最大后缀和
	int middle;			//中区间，指区间最大子段和
	void clear(){ch[0]=ch[1]=fa=rev=0;tag=TAGNONE;}	//清空节点信息
}tree[maxn];
int rublish(){				//垃圾回收
	if(top==0)return ++cnt;
	int node=rub[top--];
	return node;
}
void change_val(int node,int val){          //更新点值
	if(!node)return ;   //空节点返回
	tree[node].tag=tree[node].val=val;      //打赋值标记，更新权值
	tree[node].sum=val*tree[node].size;     //更新区间权值和
	tree[node].left=tree[node].right=max(tree[node].sum,0); //左右区间更新
	tree[node].middle=max(tree[node].sum,val);  //最大子段和更新
}
void change_rev(int node){                  //更新翻转
	swap(tree[node].ch[0],tree[node].ch[1]);//交换左右儿子
	swap(tree[node].left,tree[node].right); //交换左右区间
	tree[node].rev^=1;						//打翻转标记
}
void pushup(int node){					//维护信息
	kkk &x=tree[L(node)],&y=tree[R(node)];int val=tree[node].val;	//实质是将左右儿子合并，x代替左儿子，y代替右儿子
	kkk &res=tree[node];				//res代替tree[node]
	res.sum=x.sum+y.sum+val;res.size=x.size+y.size+1;	//权值和更新，子树大小更新
	res.middle=max(max(x.middle,y.middle),x.right+y.left+val);	//最大子段和更新
	res.left=max(x.left,x.sum+y.left+val);			//区间最大前缀和更新
	res.right=max(y.right,y.sum+x.right+val);		//区间最大后缀和更新
}
void pushdown(int node){				//标记下传
	if(tree[node].tag!=TAGNONE){		//判断有没有赋值标记
		change_val(L(node),tree[node].tag);	//更新左儿子
		change_val(R(node),tree[node].tag);	//更新右儿子
		tree[node].tag=TAGNONE;			//除去标记
	}
	if(tree[node].rev){					//判断有没有翻转标记
		change_rev(L(node));			//更新左儿子
		change_rev(R(node));			//更新右儿子
		tree[node].rev=0;				//除去标记
	}
}
void rotate(int node){                      //rotate 模板
	int fa=F(node);
	int gfa=F(fa);
	int z=tree[fa].ch[1]==node;
	tree[gfa].ch[tree[gfa].ch[1]==fa]=node; tree[node].fa=gfa;
	tree[fa].ch[z]=tree[node].ch[z^1];tree[tree[node].ch[z^1]].fa=fa;
	tree[node].ch[z^1]=fa;tree[fa].fa=node;
	pushup(fa); pushup(node);
}
void Splay(int node,int goal){              //Splay 模板
	while(tree[node].fa!=goal){
		int fa=F(node);
		int gfa=F(fa);
		if(gfa!=goal)
		(compare(fa,tree[node].val))!=(compare(gfa,tree[fa].val))
		?rotate(node) : rotate(fa);
		rotate(node);
	}
	if(!goal)root=node;
}
void New(int node,int x){                       //新建节点
	tree[node].middle=tree[node].sum=x;         //赋值信息
	tree[node].tag=TAGNONE;tree[node].rev=0;    //标记初始化
	tree[node].left=tree[node].right=max(x,0);  //区间赋值
	tree[node].size=1;          //大小赋值
}
void build(int begin,int end,int fa){			//建树
	int mid=(begin+end)>>1;int node=id[mid],pre=id[fa];
	if(begin==end)			//到达底部
		New(node,a[begin]);	//新建一个节点
	if(begin<mid)build(begin,mid-1,mid);	//建左子树
	if(mid<end)build(mid+1,end,mid);		//建右子树
	tree[node].val=a[mid];tree[node].fa=pre;tree[node].tag=TAGNONE;	//基本信息赋值
	pushup(node);			//维护信息
	tree[pre].ch[mid>=fa]=node;
}
int kth(int x){				//kth模板
	int node=root;
	while(1){
		pushdown(node);
		if(tree[L(node)].size>=x)node=L(node);
		else
		if(tree[L(node)].size+1==x)return node;
		else x-=tree[L(node)].size+1,node=R(node);
	}
}
void remove(int node){		//将一个子树清空
	if(L(node))remove(L(node));		//继续清空左子树
	if(R(node))remove(R(node));		//继续清空右子树
	rub[++top]=node; tree[node].clear();	//清空并仍进垃圾桶
}
int split(int k,int len){	//找到那个区间的位置
	int x=kth(k),y=kth(k+len+1);
	Splay(x,0);Splay(y,x);
	return L(y);
}
void query(int x,int len){	//查询区间权值和
	int node=split(x,len);	//找到该区间
	printf("%d\n",tree[node].sum);	//输出答案
}
void update(int x,int len,int val){	//更新区间的指
	int node=split(x,len),y=F(node);	//找到该区间
	change_val(node,val);			//更新该区间
	pushup(y);pushup(F(y));			//维护信息
}
void rever(int x,int len){			//翻转区间
	int node=split(x,len),y=F(node);//找到该区间
	if(tree[node].tag!=TAGNONE)return ;	//如果已经有赋值标记就不用管了
	change_rev(node);				//翻转该区间
	pushup(y);pushup(F(y));			//维护信息
}
void eraser(int x,int len){			//删除区间
	int node=split(x,len),y=F(node);//找到该区间
	remove(node);tree[y].ch[0]=0;	//删除该区间，子树清空
	pushup(y);pushup(F(y));			//维护信息
}
void insert(int k,int len){			//插入区间
	for(int i=1;i<=len;i++)scanf("%d",&a[i]);	//输入区间
	for(int i=1;i<=len;i++)
		id[i]=rublish();
	build(1,len,0);					//将输入的区间建成一个完全二叉树
	int z=id[(1+len)>>1];
	int x=kth(k+1),y=kth(k+2);		//找到要插入的位置
	Splay(x,0);Splay(y,x);
	tree[z].fa=y; tree[y].ch[0]=z;	//将新建的子树插入树中
	pushup(y);pushup(x);			//维护信息
}
int main(){
	scanf("%d%d",&n,&m);
	tree[0].middle=a[1]=a[n+2]=-inf;	//边界
	for(int i=1;i<=n;i++)scanf("%d",&a[i+1]);	//输入
	for(int i=1;i<=n+2;i++)id[i]=i;
	build(1,n+2,0);					//建成一颗Splay
	root=(n+3)>>1;cnt=n+2;			//指根，更新点数
	for(int i=1;i<=m;i++){
		string s; int x,len,y;  
		cin>>s;
		if(s!="MAX-SUM")scanf("%d%d",&x,&len);
		else printf("%d\n",tree[root].middle);
		if(s=="INSERT")insert(x,len);
		if(s=="DELETE")eraser(x,len);
		if(s=="MAKE-SAME")
			scanf("%d",&y),update(x,len,y);
		if(s=="REVERSE")rever(x,len);
		if(s=="GET-SUM")query(x,len);
	}
}
```

## 后记

学习时有参考[I_AM_HelloWord](https://www.luogu.org/space/show?uid=54916)大佬的题解。所以有的地方和他的代码很像。

希望大家都能掌握区间树QwQ。

# 谢谢观赏

---

## 作者：陈琛 (赞：25)

看了一下题解，都是打两个tag的。然而由于我太菜了，实在不会，所以此处给出一种只需要打翻转一个tag的做法。

然后我们考虑不用tag怎么推平。推平实际上就是把一段数删掉再插入一大段相同的数。然而朴素的做法肯定是会T飞的。

先来看删除。我们可以使用一个垃圾桶，每次删除一个子树，就把这棵子树的**根节点**放入垃圾桶。需要新建节点时，取出垃圾桶里的一棵子树的根节点，**然后把这个节点的左右子树（如果有的话）放回垃圾桶**。这样每次复杂度就变成了O(1)的。

再看插入。我们采取一种类似于珂朵莉树的方法，每个节点存储一段区间。然后这样在Split的时候就要改一下：

```cpp
IL void Split_(RG int root,RG int k,RG int &a,RG int &b){
	Pushdown(root); a=Create(k,M[root].val); b=Create(M[root].len-k,M[root].val);
	M[a].ls=LS; M[b].rs=RS; LS=RS=0;
	Delete(root); Update(a); Update(b);
}
static void Split(RG int root,RG int k,RG int &a,RG int &b){
	if(!root) a=b=0;
	else{
		Pushdown(root);
		if(M[LS].sz>=k) b=root, Split(M[root].ls,k,a,M[root].ls);
		else if(M[LS].sz+M[root].len>k) Split_(root,k-M[LS].sz,a,b);
		else a=root, Split(M[root].rs,k-M[LS].sz-M[root].len,M[root].rs,b);
		Update(a); Update(b);
	}
}

```

其中Split_是把一段相同的区间裂成两端。

在Split中，要判断分裂的地方在当前节点的左子树、右子树**或它自己的区间**里。

然后推平就做完了。看一下代码：

```cpp
pos=Read(), tot=Read(); int num=Read();
Split(root,pos-1,a,b), Split(b,tot,b,c);
Delete(b); b=Create(tot,num);
root=Merge(a,Merge(b,c));
```

其余的地方，就和普通的没有什么区别了。一个节点维护前缀、后缀和中间的最大值，翻转的时候Split开打上tag即可。

然后，就没有然后了。

上代码：

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define MAXN 4000001
#define LS M[root].ls
#define RS M[root].rs
#define IL inline
#define RG register
IL int Read(){
	RG int ret=0,fl=1; RG char ch=getchar();
	while(ch<'0' || ch>'9') fl=((ch=='-')?-1:fl), ch=getchar();
	while(ch>='0' && ch<='9') ret=ret*10+ch-'0', ch=getchar();
	return ret*fl;
}
struct FHQ{ int ls,rs,sz,len,val,sum,mx,ml,mr; bool flag; };
static FHQ M[MAXN];
IL void Reverse(RG int root){ std::swap(LS,RS); std::swap(M[root].ml,M[root].mr); }
IL void Pushdown(RG int root){
	if(M[root].flag){
		M[root].flag=false;
		if(LS) M[LS].flag^=true, Reverse(LS);
		if(RS) M[RS].flag^=true, Reverse(RS);
	}
}
IL void Update(RG int root){
	M[root].sz=M[LS].sz+M[RS].sz+M[root].len;
	RG int V=M[root].val*M[root].len;
	M[root].sum=M[LS].sum+M[RS].sum+V;
	M[root].ml=std::max(std::max(M[LS].ml,M[LS].sum+V+M[RS].ml),0);
	M[root].mr=std::max(std::max(M[RS].mr,M[RS].sum+V+M[LS].mr),0);
	M[root].mx=std::max(M[LS].mr+V+M[RS].ml,V);
	if(LS) M[root].mx=std::max(M[root].mx,M[LS].mx);
	if(RS) M[root].mx=std::max(M[root].mx,M[RS].mx);
	M[root].mx=std::max(M[root].mx,M[root].val);
}
static int stack[MAXN],top,cnt;
IL int Create(RG int len,RG int val){
	RG int root;
	if(top){ root=stack[top--]; if(LS) stack[++top]=LS; if(RS) stack[++top]=RS; }
	else root=++cnt;
	LS=RS=0; M[root].flag=false;
	M[root].len=M[root].sz=len; M[root].val=M[root].mx=val; M[root].sum=val*len;
	M[root].ml=M[root].mr=0;
	Update(root);
	return root;
}
IL void Delete(RG int root){ stack[++top]=root; }
static int Merge(RG int a,RG int b){
	Pushdown(a); Pushdown(b);
	if(!a || !b) return a|b;
	if((M[a].sum+M[b].sum)&1){ M[a].rs=Merge(M[a].rs,b); Update(a); return a; }
	else{ M[b].ls=Merge(a,M[b].ls); Update(b); return b; }
}
IL void Split_(RG int root,RG int k,RG int &a,RG int &b){
	Pushdown(root); a=Create(k,M[root].val); b=Create(M[root].len-k,M[root].val);
	M[a].ls=LS; M[b].rs=RS; LS=RS=0;
	Delete(root); Update(a); Update(b);
}
static void Split(RG int root,RG int k,RG int &a,RG int &b){
	if(!root) a=b=0;
	else{
		Pushdown(root);
		if(M[LS].sz>=k) b=root, Split(M[root].ls,k,a,M[root].ls);
		else if(M[LS].sz+M[root].len>k) Split_(root,k-M[LS].sz,a,b);
		else a=root, Split(M[root].rs,k-M[LS].sz-M[root].len,M[root].rs,b);
		Update(a); Update(b);
	}
}
static int Build(RG int l,RG int r,RG int *a){
	if(l>r) return 0;
	RG int m=l+r>>1, root=Create(1,a[m]);
	LS=Build(l,m-1,a); RS=Build(m+1,r,a);
	Update(root);
	return root;
}
static int S[MAXN],root;
int main(){
	int n=Read(),m=Read();
	for(RG int i=1;i<=n;i++) S[i]=Read();
	root=Build(1,n,S);
	char s[12];
	while(m--){
		RG int pos,tot,a,b,c; scanf("%s",s);
		if(s[0]=='I'){
			pos=Read(), tot=Read();
			for(RG int i=1;i<=tot;i++) scanf("%d",&S[i]);
			c=Build(1,tot,S);
			Split(root,pos,a,b);
			root=Merge(a,Merge(c,b));
		}else if(s[0]=='D'){
			pos=Read(), tot=Read();
			Split(root,pos-1,a,b), Split(b,tot,b,c);
			root=Merge(a,c), Delete(b);
		}else if(s[0]=='M' && s[3]=='E'){
			pos=Read(), tot=Read(); int num=Read();
			Split(root,pos-1,a,b), Split(b,tot,b,c);
			Delete(b); b=Create(tot,num);
			root=Merge(a,Merge(b,c));
		}else if(s[0]=='M' && s[3]=='-'){
			printf("%d\n",M[root].mx);
		}else if(s[0]=='R'){
			pos=Read(), tot=Read();
			Split(root,pos-1,a,b), Split(b,tot,b,c);
			M[b].flag^=true; Reverse(b);
			root=Merge(a,Merge(b,c));
		}else if(s[0]=='G'){
			pos=Read(), tot=Read();
			Split(root,pos-1,a,b), Split(b,tot,b,c);
			printf("%d\n",M[b].sum); root=Merge(a,Merge(b,c));
		}
	}
	return 0;
}
```

---

## 作者：AutumnKite (赞：18)

[题目传送门](https://www.luogu.org/problemnew/show/P2042)

## 题意

维护一个序列，支持插入序列、区间删除、区间覆盖、区间翻转、区间求和、求序列最大子段和（至少包含一个元素）。

插入总数$\le 4\times 10^6$，任意时刻序列长度$\le 5\times 10^5$。

## 题解

$Splay$板子题。

不会$Splay$的同学出门左转[文艺平衡树](https://www.luogu.org/problemnew/show/P3391)。

由于插入数量太大，直接开4000000的数组显得不显示，我们考虑建立回收栈（雾），删除时遍历子树，回收被删除的节点，新建节点时优先从回收栈里取点，但是要注意各个数组都要初始化。

总体思路是，对每个节点维护：$val,sz,sum,la,ra,ma$，分别表示这个点本身的值、子树大小、子树的$val$之和、该区间（以这个点为根的子树所表示的区间，下同）中包含最左边元素的最长子段和（**可以不包含元素**）、包含最右边元素的最长子段和（**可以不包含元素**）、整个区间的最大子段和（**至少包含一个元素**，即答案）；懒标记$cov=0/1,rev=0/1$，分别表示该区间是否被覆盖、是否被翻转。

接下来我们仔细分析每一步操作。

### 新建节点

已经讲过，若回收栈里有点，则优先拿来用，否则新建节点。

```cpp
int new_node(int _val){
	int x = top ? rb[top--] : ++cnt; // rb即回收栈
	son[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1; // 注意别忘记初始化
	val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0); // la,ra可以不包含元素
	return x;
}
```

### 上传

主要是$la,ra,ma$的更新。$la$和$ra$同理，以$la$为例，当前节点的$la$值就是`max(左子树的la,左子树的sum+当前节点的val+右子树的la)`，分别表示跨过当前节点和不跨过当前节点两种情况。对于$ma$，也差不多，不跨过的情况是`max(左子树的ma,右子树的ma)`，跨过的情况是`左子树的ra+当前节点的val+右子树的la`，在这两种情况中再取个$max$即可。

```cpp
void up(int u){
	int ls = son[u][0], rs = son[u][1];
	sz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u];
	la[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]);
	ra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]);
	ma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);
}
```

### 下传懒标记

比较简单，不需要考虑标记下传的顺序。

对于$cov$标记，直接把左右儿子的$val$设为当前节点的$val$，$sum$设为$val\times sz$。而$la,ra,ma$则需要分类讨论，若$val>0$，显然直接把整个区间选上更优，否则$la,ra$不选，$ma$只选一个点。

对于$rev$标记，直接交换**左右儿子**的左右子树、**左右儿子**的$la,ra$（注意不是交换当前节点的左右子树、$la,ra$，这种写法在[文艺平衡树](https://www.luogu.org/problemnew/show/P3391)可以过，但是在本题中会出错）。

```cpp
void down(int u){
	int ls = son[u][0], rs = son[u][1];
	if (cov[u]){
		if (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u];
		if (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u];
		if (val[u] > 0){ // 分类讨论
			if (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];
			if (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];
		}
		else{
			if (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u];
			if (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u];
		}
		cov[u] = 0;
	}
	if (rev[u]){
		if (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]);
		if (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]);
		// 交换左右儿子的左右子树和la,ra
		rev[u] = 0;
	}
}
```

### 建树

直接按照原序列的顺序建树（注意不是按数的大小建树）。

可是直接插入是$\mathcal O(n\log n)$的，且常数较大。我们直接取序列中点作为根，然后递归调用左边和右边，分别作为根的左儿子和右儿子。

这样我们可以做到$\mathcal O(n)$建树，$n$是序列长度。

```cpp
int build(int l, int r, int *a){
	if (l > r) return 0;
	if (l == r) return new_node(a[l]);
	int mid = (l + r) >> 1, u = new_node(a[mid]);
	// 以mid为该子树的根，递归处理左右两边
	son[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a);
	fa[son[u][0]] = fa[son[u][1]] = u;
	return up(u), u; // 注意更新
}
```

### Splay的基本操作：$rotate(x)$和$splay(x,g)$

$rotate(x)$表示将$x$向上旋转，$splay(x,g)$表示将$x$旋转到$g$的儿子。

注意$rotate(x)$时需要上传操作，且要注意操作顺序。$splay(x,g)$需要双旋。

```cpp
int dir(int x){ return son[fa[x]][1] == x; } // 返回x是他父亲的哪个儿子
void set(int x, int k, int y){ son[x][k] = y, fa[y] = x; } // 将x的k儿子变成y
void rotate(int x){
	int y = fa[x], d = dir(x);
	set(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y);
	up(y), up(x); // 注意上传以及上传的顺序
}
void splay(int x, int g = 0){ // g=0相当于旋转到根上
	while (fa[x] != g){
		int y = fa[x];
		if (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x);
		rotate(x); // 双旋
	}
	if (!g) rt = x; // 更新rt
}
```

### 求当前序列中第$k$个位置在Splay中对应的节点

这是下面前五个操作中必需的一个操作，即把序列中的位置转化为树上的节点编号。

这是一个经典的求第$k$小的问题，直接按照左子树的$sz$和当前的$k$的大小关系决定往左、往右还是直接返回当前节点。

注意，此时由于需要用到儿子的信息，我们必须把$u$的标记下传。

且因为这样做会把根到要求的那个节点的路径上的所有节点都$down$一遍，所以在其余操作中不需要再进行$down$操作。

```cpp
int kth(int u, int k){
	down(u); // 下传标记
	int ls = son[u][0], rs = son[u][1];
	if (k == sz[ls] + 1) return u; // 直接返回
	else if (k <= sz[ls]) return kth(ls, k); // 向左走
	else return kth(rs, k - sz[ls] - 1); // 向右走
}
```

### 插入操作

对于插入操作，我们直接把$pos$对应的节点$splay$到根上（记为$u$），把$pos+1$的位置旋转到根下面（记为$v$，即此时$fa[v]=u$）。此时$v$的左子树一定为空（不存在一个整数$x$满足$pos<x<pos+1$）。那么直接把需要插入的序列$\mathcal O(n)$建树，把根节点连到$v$上，作为$v$的左子树即可。

```cpp
void insert(int x, int tot, int *a){
	int t = build(1, tot, a);
	int u = kth(rt, x); splay(u);
	int v = kth(rt, x + 1); splay(v, u);
	son[v][0] = t, fa[t] = v, up(v), up(u);
	// 注意别忘记fa[t]=v和上传标记，不要习惯性打成up(u),up(v)
}
```

### 删除操作

假设我们要删除的是区间$[l,r]$，那么同理，我们把$l-1$对应的节点旋转到根上（记为$u$），把$r+1$的位置旋转到根下面（记为$v$，即此时$fa[v]=u$）。

此时$v$的左子树所表示的区间即为$[l,r]$，那么我们直接把$v$的左子树删除即可。

```cpp
void recycle(int u){ // 回收以u为根的子树
	int ls = son[u][0], rs = son[u][1];
	if (ls) recycle(ls);
	if (rs) recycle(rs);
	rb[++top] = u;
}
void erase(int l, int r){
	int u = kth(rt, l - 1); splay(u);
	int v = kth(rt, r + 1); splay(v, u); // 提区间操作
	recycle(son[v][0]), son[v][0] = 0, up(v), up(u); // 更新
}
```

### 覆盖操作

与删除同理，提取区间$[l,r]$，打上$cov$标记，更新即可。

```cpp
void cover(int l, int r, int c){
	int u = kth(rt, l - 1); splay(u);
	int v = kth(rt, r + 1); splay(v, u);
	int t = son[v][0]; // 提区间
	val[t] = c, cov[t] = 1, sum[t] = sz[t] * c;
	if (c > 0) la[t] = ra[t] = ma[t] = sum[t];
	else la[t] = ra[t] = 0, ma[t] = c; // 打标记，与down中同理
	up(v), up(u); // 更新
}
```

### 翻转操作

同理，提取区间后，打上$rev$标记并更新。

```cpp
void reverse(int l, int r){
	int u = kth(rt, l - 1); splay(u);
	int v = kth(rt, r + 1); splay(v, u);
	int t = son[v][0]; // 提区间
	rev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]);
	// 打标记，与down中同理
	up(v), up(u); // 更新
}
```

### 求和操作

提取区间后直接输出$sum$值即可，不需要更新。

```cpp
void query_sum(int l, int r){
	int u = kth(rt, l - 1); splay(u);
	int v = kth(rt, r + 1); splay(v, u);
	printf("%d\n", sum[son[v][0]]);
}
```

### 最大子段和

直接输出$ma[rt]$即可。

### 一些细节

1. 由于$pos,l-1$可能会$<1$，$pos+1,r$可能会$>n$，所以要考虑边界问题。我的代码中是直接把整个数组向右移动一位，并且使$a[1]=a[n+2]=-\text{INF}$。个人觉得这个方法比较简单，只要在主程序中做一些简单的处理即可。
2. 由于$up$中没有判断左儿子或右儿子为空的情况（判起来会变得很鬼畜），所以我们令$ma[0]=-\text{INF}$。

## 代码实现

总的再发一次吧。吸氧后~~最快的一次~~共1111ms。[评测记录](https://www.luogu.org/recordnew/show/15406481)

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
int read(){
	register int x = 0, f = 1;
	register char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f;
	for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return f ? x : -x;
}
#define N 500005
#define INF 500000000
int n, m, a[N];
char opt[15];
int k, x, tot, c[N];
struct Splay{
	int rt, cnt, son[N][2], fa[N], sz[N], val[N];
	int rev[N], cov[N], sum[N], la[N], ra[N], ma[N];
	int top, rb[5000005];
	Splay(){
		rt = 0, cnt = 0, top = 0;
		fa[0] = son[0][0] = son[0][1] = sz[0] = rev[0] = cov[0] = 0;
		val[0] = sum[0] = la[0] = ra[0] = 0, ma[0] = -INF;
	}
	int new_node(int _val){
		int x = top ? rb[top--] : ++cnt;
		son[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1;
		val[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0);
		return x;
	}
	void recycle(int u){
		int ls = son[u][0], rs = son[u][1];
		if (ls) recycle(ls);
		if (rs) recycle(rs);
		rb[++top] = u;
	}
	void up(int u){
		int ls = son[u][0], rs = son[u][1];
		sz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u];
		la[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]);
		ra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]);
		ma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);
	}
	void down(int u){
		int ls = son[u][0], rs = son[u][1];
		if (cov[u]){
			if (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u];
			if (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u];
			if (val[u] > 0){
				if (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];
				if (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];
			}
			else{
				if (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u];
				if (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u];
			}
			cov[u] = 0;
		}
		if (rev[u]){
			if (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]);
			if (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]);
			rev[u] = 0;
		}
	}
	int dir(int x){ return son[fa[x]][1] == x; }
	void set(int x, int k, int y){ son[x][k] = y, fa[y] = x; }
	void rotate(int x){
		int y = fa[x], d = dir(x);
		set(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y);
		up(y), up(x);
	}
	void splay(int x, int g = 0){
		while (fa[x] != g){
			int y = fa[x];
			if (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x);
			rotate(x);
		}
		if (!g) rt = x;
	}
	int build(int l, int r, int *a){
		if (l > r) return 0;
		if (l == r) return new_node(a[l]);
		int mid = (l + r) >> 1, u = new_node(a[mid]);
		son[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a);
		fa[son[u][0]] = fa[son[u][1]] = u;
		return up(u), u;
	}
	int kth(int u, int k){
		down(u);
		int ls = son[u][0], rs = son[u][1];
		if (k == sz[ls] + 1) return u;
		else if (k <= sz[ls]) return kth(ls, k);
		else return kth(rs, k - sz[ls] - 1);
	}
	void insert(int x, int tot, int *a){
		int t = build(1, tot, a);
		int u = kth(rt, x); splay(u);
		int v = kth(rt, x + 1); splay(v, u);
		son[v][0] = t, fa[t] = v, up(v), up(u);
	}
	void erase(int l, int r){
		int u = kth(rt, l - 1); splay(u);
		int v = kth(rt, r + 1); splay(v, u);
		recycle(son[v][0]), son[v][0] = 0, up(v), up(u);
	}
	void cover(int l, int r, int c){
		int u = kth(rt, l - 1); splay(u);
		int v = kth(rt, r + 1); splay(v, u);
		int t = son[v][0];
		val[t] = c, cov[t] = 1, sum[t] = sz[t] * c;
		if (c > 0) la[t] = ra[t] = ma[t] = sum[t];
		else la[t] = ra[t] = 0, ma[t] = c;
		up(v), up(u);
	}
	void reverse(int l, int r){
		int u = kth(rt, l - 1); splay(u);
		int v = kth(rt, r + 1); splay(v, u);
		int t = son[v][0];
		rev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]);
		up(v), up(u);
	}
	void query_sum(int l, int r){
		int u = kth(rt, l - 1); splay(u);
		int v = kth(rt, r + 1); splay(v, u);
		printf("%d\n", sum[son[v][0]]);
	}
	void query_max_sum(){ printf("%d\n", ma[rt]); }
}T;
int main(){
	n = read(), m = read(), n += 2, a[1] = a[n] = -INF;
	for (register int i = 2; i < n; ++i) a[i] = read(); // 整体右移
	T.rt = T.build(1, n, a);
	while (m--){
		scanf("%s", opt);
		if (opt[0] == 'M' && opt[2] == 'X') T.query_max_sum();
		else x = read() + 1, tot = read(); // +1是因为数组整体右移
		if (opt[0] == 'I'){
			for (register int i = 1; i <= tot; ++i) c[i] = read();
			T.insert(x, tot, c);
		}
		if (opt[0] == 'D') T.erase(x, x + tot - 1);
		if (opt[0] == 'M' && opt[2] == 'K') T.cover(x, x + tot - 1, read());
		if (opt[0] == 'R') T.reverse(x, x + tot - 1);
		if (opt[0] == 'G') T.query_sum(x, x + tot - 1);
	}
}
```

如发现代码有问题请在评论中指出，谢谢啦！

---

## 作者：ez_lcw (赞：10)

# Splay 文艺平衡树

#### 前言：

这是一道好板子，可我却调了2天……

又觉得其他题解看不懂（比如指针党的代码，本蒟蒻实在不习惯），就来水一发。

#### 前置知识：$Splay$、$rotate$（旋转）、$kth$（求树中的第$k$名的操作）。

## 先讲一下文艺平衡树的基本思路和操作吧：

### 建树：

普通平衡树的建树方法是一个一个点地$insert$进树里。

而像这种开始就给你序列的就可以递归建树（像**线段树**一样）

而某个节点所对应的数应该为$a[(l+r)/2]$（也就是中间的数，$a[]$为输入的数组）

代码和详细注释如下：

```cpp
int build(int l,int r,int fa)
{
	if(l>r)return 0;//注意边界
	int mid=(l+r)>>1,now;//now为节点编号
    if(tot2)now=s[tot2--];//资源回收来建立节点编号（等会会讲）
	else now=++tot;
	t[now].fa=fa;//记录粑粑
	t[now].val=a[mid];//记录这个点所对应的值
	t[now].tag=t[now].lazy=t[now].laz=0;//初始化
	t[now].ch[0]=build(l,mid-1,now);//记录左儿子
	t[now].ch[1]=build(mid+1,r,now);//记录右儿子
	up(now);
	return now;//返回当前节点编号
}
```

具体的$up()$操作等会再说。

### 提出区间：

假设现在要求区间$[l,r]$，我们得怎么处理呢？

**我们可以先通过$Splay$把第$l-1$位的点$a$旋转到根，再把$r+1$位的点$b$旋转到$a$下方。**

**此时点$b$的左子树的每个点$x$满足：$l-1<x<r+1$，如图：**

![](https://cdn.luogu.com.cn/upload/pic/49296.png)

那么我们就可以~~轻而易举~~地把$[l,r]$这段区间给提出来操作了。（尽管求$kth$、$splay$和$rotate$代码都很长）

但是如果题目要求$[1,n]$，那$l-1$和$r+1$是什么？

所以我们就要手动在整棵树的最前面加上一个值为$-INF$点，在最后面加上一个值为$INF$的点。

这样整棵树就有$n+2$个点。

因为$a[1]$是$-INF$，所以整个序列都往后移了一位

也就是说，本来题目给出数列的第$k$个数，本应是整棵树的第$k$位，现在变成了第$k+1$位。

所以输入这个序列时应该：

```cpp
a[1]=-INF;
a[n+2]=INF;
for(int i=1;i<=n;i++)scanf("%lld",&a[i+1]);
```

然后找$[l,r]$的过程如下：

```cpp
scanf("%d%d",&l,&r);
l++;r++;//数列整体位置后移一位，所有的以后都是这样
l=kth(l-1);r=kth(r+1);//找到l-1和r+1的位置
splay(l,0);splay(r,l);//把l旋转到根，r旋转到l下面
//现在t[r].ch[0]就是[l,r]的根了
```

## 现在说一下题目给的每个操作怎么实现

### 结构体说明：

```cpp
struct Splay
{
	int fa;//粑粑
    int ch[2]//儿子
    int size;//以这个点为根的树的节点总数
    int tag;//题目中翻转用懒标记
	long long val;//节点所对应的值
    long long sum;//题目要求的sum
    long long maxn;//题目要求的max_sum
    long long lazy;//题目中make_same用懒标记
    long long ls;//以当前序列的左端点为头的max_sum
    long long rs;//以当前序列的右端点为头的max_sum
	bool laz;//题目中make_same用的懒标记识别码
}t[N];
```

### 一、$insert$操作

首先，我们先把$l$设为$pos$，$r$设为$pos+1$，并把$[l,r]$提出来（提出后$r$的左子树为空）

然后我们将输入的数据递归建树。

最后连接$r$与建的树的根。

具体代码如下：

```cpp
void insert(int l,int x)
{
	int r=l+1;
	l=kth(l+1);r=kth(r+1);
	splay(l,0);splay(r,l);
	for(int i=1;i<=x;i++)scanf("%lld",&a[i]);
	t[r].ch[0]=build(1,x,r);//建树并连接父子关系
	n+=x;//将总点数加上x
	up(r);up(l);
}
```

### 二、$delete$操作

同样，我们先将要删除的区间提取出来。

然后断绝整棵树与区间所对应的树的父子关系~~断子绝孙~~。

注意：由于空间不够，我们需要进行~~垃圾~~**“资源回收”**，也就是把删去的节点的编号存起来，以便$insert$的时候用。

具体可以用数组、队列或栈来实现：

```cpp
void erase(int k)
{
	if(!k)return;
	s[++tot2]=k;//记录编号
	erase(t[k].ch[0]);
	erase(t[k].ch[1]);
}
```

删除操作代码：

```cpp
void delet(int l,int r)//r要提前算出来
{
	n-=r-l+1;//修改总点数
	l=kth(l);r=kth(r+2);
	splay(l,0);splay(r,l);
	erase(t[r].ch[0]);//资源回收
	t[r].ch[0]=0;//断绝父子关系
	up(r);up(l);
}
```

### 三、$make\_same$操作

同样，我们先把$[l,r]$提出来。

这时，我们就要用到线段树的一个重要操作——$lazy$懒标记。

但是有一个细节——就是$lazy$的初始化。

如果当$lazy$为0时就视为没有懒标记，那万一题目真的要把某段区间全改为0怎么办。

所以我就设了另一个$bool$的$laz$，来记录是否需要下传懒标记

那么下传的代码如下：

```cpp
int l=t[k].ch[0],r=t[k].ch[1];
if(t[k].laz)//如果需要下传
{
	t[k].lazy=t[k].laz=0;
	if(l)
	{
		t[l].laz=true;
		t[l].val=t[k].val;
		t[l].sum=t[k].val*t[l].size;
	}
	if(r)
	{
		t[r].laz=true;
		t[r].val=t[k].val;
		t[r].sum=t[k].val*t[r].size;
	}
	if(t[k].val>=0)
	{
		if(l)t[l].ls=t[l].rs=t[l].maxn=t[l].sum;//因为修改后的序列每一个数都一样，所以如果这个数大于0，那么max_sum就是这个序列的sum
		if(r)t[r].ls=t[r].rs=t[r].maxn=t[r].sum;
	}
	else 
	{
		if(l)t[l].ls=t[l].rs=0,t[l].maxn=t[k].val;//因为这个数小于0但是子列不能为空，所以max_sum只能去这个数（但是ls和rs可以取0，他们并不会影响到他们粑粑，让他们的粑粑取0）
		if(r)t[r].ls=t[r].rs=0,t[r].maxn=t[k].val;
	}
}
```

具体的修改过程如下：

```cpp
void make_same(int l,int r,int x)
{
	l=kth(l);r=kth(r+2);
	splay(l,0);splay(r,l);
    int k=t[r].ch[0];
    t[k].val=x;
	t[k].sum=t[k].size*x;
	if(x<=0)t[k].ls=t[k].rs=0,t[k].maxn=x;
	else t[k].ls=t[k].rs=t[k].maxn=t[k].size*x;
	t[k].lazy=x;
	t[k].laz=true;
	up(r);up(l);
}
```

### 四、$reverse$翻转操作

翻转操作，说白了就是把一棵树的每一个节点的儿子都$swap$一下

但我们注意到：同一个序列，如果翻转2次，那么还是没有变动。

所以我们可以设一个像$lazy$一样的懒标记$tag$，用来记录一个序列的翻转次数。

下传懒标记的过程如下:

```cpp
if(t[k].tag)
{
	t[k].tag=0;t[l].tag^=1;t[r].tag^=1;
	swap(t[l].ls,t[l].rs);swap(t[r].ls,t[r].rs);//注意，如果一个序列被翻转了，那么这个序列的ls和rs也要翻转
	swap(t[l].ch[0],t[l].ch[1]);swap(t[r].ch[0],t[r].ch[1]);//swap儿子
}
```

最后修改的过程在这里：

```cpp
void reverse(int l,int r)
{
	l=kth(l);r=kth(r+2);
	splay(l,0);splay(r,l);
	int k=t[r].ch[0];
	if(!t[k].laz)
	{
		t[k].tag^=1;//记录懒标记（0^1=1,1^1=0）
		swap(t[k].ch[0],t[k].ch[1]);.//swap儿子
		swap(t[k].ls,t[k].rs);//swap ls、rs
		up(r);up(l);
	}
}
```

### 五、$get\_sum$求和操作

比较简单，每个节点记录一下就好了（记得$up$）：

```cpp
long long query_sum(int l,int r)
{
	l=kth(l);r=kth(r+2);
	splay(l,0);splay(r,l);
	return t[t[r].ch[0]].sum;
}
```

### 六、$max\_sum$求和最大子列的操作

求答案的函数：

```cpp
long long max_sum()
{
	int l=kth(1),r=kth(n+2);//注意，需要把[1,n]提出来
	splay(l,0);splay(r,l);
	return t[t[r].ch[0]].maxn;
}
```
怎么$up$？

$up$的三个类似于状态转移方程的东东：

$$t[k].ls=\max(t[l].ls,t[l].sum+t[k].val+t[r].ls)$$

$$t[k].rs=\max(t[r].rs,t[r].sum+t[k].val+t[l].rs)$$

$$t[k].maxn=\max(t[l].maxn,t[r].maxn,t[l].rs+t[k].val+t[r].ls)$$

还是很好理解的，画画图就好了。（实在想不通可以看一下[和这种操作差不多的我的题解的解释](https://www.luogu.org/blog/lc-2018-Canton/solution-p4513)）

------------

最后完整的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>

#define N 500001
#define INF 0x7fffffffffffffff

using namespace std;

struct Splay
{
	int fa,ch[2],size;
	long long val,sum,maxn,lazy,tag,ls,rs;
	bool laz;
}t[N];

long long n,m,tot,root,tot2,a[N],s[N];

void down(int k)
{
	int l=t[k].ch[0],r=t[k].ch[1];
	if(t[k].laz)
	{
		t[k].lazy=t[k].laz=0;
		if(l)
		{
			t[l].laz=true;
			t[l].val=t[k].val;
			t[l].sum=t[k].val*t[l].size;
		}
		if(r)
		{
			t[r].laz=true;
			t[r].val=t[k].val;
			t[r].sum=t[k].val*t[r].size;
		}
		if(t[k].val>=0)
		{
			if(l)t[l].ls=t[l].rs=t[l].maxn=t[l].sum;
			if(r)t[r].ls=t[r].rs=t[r].maxn=t[r].sum;
		}
		else 
		{
			if(l)t[l].ls=t[l].rs=0,t[l].maxn=t[k].val;
			if(r)t[r].ls=t[r].rs=0,t[r].maxn=t[k].val;
		}
	}
	if(t[k].tag)
	{
		t[k].tag=0;t[l].tag^=1;t[r].tag^=1;
		swap(t[l].ls,t[l].rs);swap(t[r].ls,t[r].rs);
		swap(t[l].ch[0],t[l].ch[1]);swap(t[r].ch[0],t[r].ch[1]);
	}
}

void up(int k)
{
	int l=t[k].ch[0],r=t[k].ch[1];
	t[k].size=t[l].size+t[r].size+1;
	t[k].sum=t[l].sum+t[r].sum+t[k].val;
	t[k].maxn=max(max(t[l].maxn,t[r].maxn),t[l].rs+t[k].val+t[r].ls);
	t[k].ls=max(t[l].ls,t[l].sum+t[k].val+t[r].ls);
	t[k].rs=max(t[r].rs,t[r].sum+t[k].val+t[l].rs);
}

bool get(int k)
{
	return t[t[k].fa].ch[1]==k;
}

void rotate(int k)
{
	int fa=t[k].fa,gfa=t[fa].fa;
	int d1=get(k),d2=get(fa);
	t[fa].ch[d1]=t[k].ch[d1^1];
	t[t[k].ch[d1^1]].fa=fa;
	t[fa].fa=k;
	t[k].ch[d1^1]=fa;
	t[k].fa=gfa;
	t[gfa].ch[d2]=k;
	up(fa);up(k);
}


void splay(int x,int y)
{
	while(t[x].fa!=y)
	{
		int fa=t[x].fa,gfa=t[fa].fa;
		int d1=get(x),d2=get(fa);
		if(gfa!=y)
		{
			if(d1==d2)rotate(fa);
			else rotate(x);
		}
		rotate(x);
	}
	if(!y)root=x;
}

int kth(int k)
{
	int now=root;
	while(1)
	{
		down(now);
		if(k<=t[t[now].ch[0]].size)now=t[now].ch[0];
		else if(k==t[t[now].ch[0]].size+1)return now;
		else 
		{
			k-=t[t[now].ch[0]].size+1;
			now=t[now].ch[1];
		}
	}
}

int build(int l,int r,int fa)
{
	if(l>r)return 0;
	int mid=(l+r)>>1,now;
	if(tot2)now=s[tot2--];
	else now=++tot;
	t[now].fa=fa;
	t[now].val=a[mid];
	t[now].tag=t[now].lazy=t[now].laz=0;
	t[now].ch[0]=build(l,mid-1,now);
	t[now].ch[1]=build(mid+1,r,now);
	up(now);
	return now;
}

void insert(int l,int x)
{
	int r=l+1;
	l=kth(l+1);r=kth(r+1);
	splay(l,0);splay(r,l);
	for(int i=1;i<=x;i++)scanf("%lld",&a[i]);
	t[r].ch[0]=build(1,x,r);
	n+=x;
	up(r);up(l);
}

void erase(int k)
{
	if(!k)return;
	s[++tot2]=k;
	erase(t[k].ch[0]);
	erase(t[k].ch[1]);
}

void delet(int l,int r)
{
	n-=r-l+1;
	l=kth(l);r=kth(r+2);//(l+1)-1=l,(r+1)+1=r+2
	splay(l,0);splay(r,l);
	erase(t[r].ch[0]);
	t[r].ch[0]=0;
	up(r);up(l);
}

void make_same(int l,int r,int x)
{
	l=kth(l);r=kth(r+2);
	splay(l,0);splay(r,l);
	int k=t[r].ch[0];
    t[k].val=x;
	t[k].sum=t[k].size*x;
	if(x<=0)t[k].ls=t[k].rs=0,t[k].maxn=x;
	else t[k].ls=t[k].rs=t[k].maxn=t[k].size*x;
	t[k].lazy=x;
	t[k].laz=true;
	up(r);up(l);
}

void reverse(int l,int r)
{
	l=kth(l);r=kth(r+2);
	splay(l,0);splay(r,l);
	int k=t[r].ch[0];
	if(!t[k].laz)
	{
		t[k].tag^=1;
		swap(t[k].ch[0],t[k].ch[1]);
		swap(t[k].ls,t[k].rs);
		up(r);up(l);
	}
}

void write(int k)
{
	if(k)
	{
		down(k);
		write(t[k].ch[0]);
		if(t[k].val!=-INF&&t[k].val!=INF)printf("%lld ",t[k].val);
		write(t[k].ch[1]);
	}
}

long long query_sum(int l,int r)
{
	l=kth(l);r=kth(r+2);
	splay(l,0);splay(r,l);
	return t[t[r].ch[0]].sum;
}

long long max_sum()
{
	int l=kth(1),r=kth(n+2);
	splay(l,0);splay(r,l);
	return t[t[r].ch[0]].maxn;
}

int main()
{
	scanf("%lld%lld",&n,&m);
	t[0].maxn=-INF;//注意
	a[1]=-INF;
	a[n+2]=INF;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i+1]);
	root=build(1,n+2,0);
	while(m--)
	{
		char ch[9];
		int x,y,z;
		scanf("%s",ch);
		if(ch[0]=='I')
		{
			scanf("%d%d",&x,&y);
			insert(x,y);
		}
		if(ch[0]=='D')
		{
			scanf("%d%d",&x,&y);
			delet(x,x+y-1);
		}
		if(ch[0]=='M'&&ch[2]=='K')
		{
			scanf("%d%d%d",&x,&y,&z);
			make_same(x,x+y-1,z);
		}
		if(ch[0]=='R')
		{
			scanf("%d%d",&x,&y);
			reverse(x,x+y-1);
		}
		if(ch[0]=='G')
		{
			scanf("%d%d",&x,&y);
			printf("%lld\n",query_sum(x,x+y-1));
		}
		if(ch[0]=='M'&&ch[2]=='X')
		{
			printf("%lld\n",max_sum());
		}
	}
	return 0;
}
```

##### 共创和谐洛谷，拒绝copy

# 最后祝大家$Splay$做得顺利！

---

## 作者：远航之曲 (赞：9)

发一个fhq Treap版的代码

想学习非旋转Treap的欢迎来[博客](http://www.yhzq-blog.cc/fhq-treap总结/)


前几个操作都很好搞，最后一个的话每一个节点维护一个最大子段和，和从左右子段最大，这样就可以愉快的合并了。

要找到pos的区间，先split(root,pos-1,x,y)再split(x2,len,y1,y1)区间就是y1


代码

```cpp
#include <cstdio>
#include <cstring>
#include <ctime>
#include <queue>
#include <cstdlib>
#define N 500010
#define inf 0x3f3f3f3f
using namespace std;
int ch[N][2],f[N],siz[N],val[N],tmx[N],lmx[N],rmx[N],rev[N],sum[N],cov[N],tar[N];
int inline read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int max(int x,int y){if (x>y) return x;return y;}
int min(int x,int y){if (x<y) return x;return y;}
void swap(int &a,int &b){a^=b,b^=a,a^=b;}
queue<int>trashcan;
int root,cnt;
int new_node(int v)
{
    int x;
    if (!trashcan.empty())
        x=trashcan.front(),trashcan.pop();
    else
        x=++cnt;
    ch[x][0]=ch[x][1]=f[x]=rev[x]=0;
    cov[x]=inf,tar[x]=rand(),siz[x]=1;
    val[x]=sum[x]=tmx[x]=v;
    lmx[x]=rmx[x]=max(v,0);
    return x;
}
void update(int x)
{
    if (ch[x][0] && ch[x][1])
    {
        siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
        sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];
        tmx[x]=max(tmx[ch[x][0]],tmx[ch[x][1]]);
        tmx[x]=max(tmx[x],rmx[ch[x][0]]+val[x]+lmx[ch[x][1]]);
        lmx[x]=max(lmx[ch[x][0]],sum[ch[x][0]]+val[x]+lmx[ch[x][1]]);
        rmx[x]=max(rmx[ch[x][1]],sum[ch[x][1]]+val[x]+rmx[ch[x][0]]);
    }
    else
    if (ch[x][0])
    {
        siz[x]=siz[ch[x][0]]+1;
        sum[x]=sum[ch[x][0]]+val[x];
        tmx[x]=max(tmx[ch[x][0]],rmx[ch[x][0]]+val[x]);
        lmx[x]=max(lmx[ch[x][0]],sum[ch[x][0]]+val[x]);
        lmx[x]=max(0,lmx[x]);
        rmx[x]=max(0,val[x]+rmx[ch[x][0]]);
    }
    else
    if (ch[x][1])
    {
        siz[x]=siz[ch[x][1]]+1;
        sum[x]=sum[ch[x][1]]+val[x];
        tmx[x]=max(tmx[ch[x][1]],lmx[ch[x][1]]+val[x]);
        rmx[x]=max(rmx[ch[x][1]],sum[ch[x][1]]+val[x]);
        rmx[x]=max(0,rmx[x]);
        lmx[x]=max(0,lmx[ch[x][1]]+val[x]);
    }
    else
    {
        siz[x]=1,sum[x]=tmx[x]=val[x];
        lmx[x]=rmx[x]=max(val[x],0);
    }
}
void reverse(int x)
{
    swap(ch[x][0],ch[x][1]);
    swap(lmx[x],rmx[x]);
    rev[x]^=1;
}
void cover(int x,int v)
{
    val[x]=v,sum[x]=siz[x]*v;
    lmx[x]=rmx[x]=max(sum[x],0);
    tmx[x]=max(sum[x],val[x]);
    cov[x]=v;
}
void pushdown(int x)
{
    if (rev[x])
    {
        if (ch[x][0]) reverse(ch[x][0]);
        if (ch[x][1]) reverse(ch[x][1]);
    }
    if (cov[x]!=inf)
    {
        if (ch[x][0]) cover(ch[x][0],cov[x]);
        if (ch[x][1]) cover(ch[x][1],cov[x]);
    }
    rev[x]=0;cov[x]=inf;
}
int build(int *data,int n)
{
    int x,last=0;static int sta[N],top;
    for(int i=1;i<=n;i++)
    {
        x=new_node(data[i]),last=0;
        while(top && tar[sta[top]]>tar[x])
            update(sta[top]),last=sta[top],
            sta[top--]=0;
        if (top)
            ch[sta[top]][1]=x;
        ch[x][0]=last,sta[++top]=x;
    }
    while(top)
        update(sta[top--]);
    return sta[1];
}
void split(int now,int k,int &x,int &y)
{
    if (!now) x=y=0;
    else
    {
        pushdown(now);
        if (siz[ch[now][0]]>=k)
            y=now,split(ch[now][0],k,x,ch[now][0]);
        else
            x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y);
        update(now);
    }
}
int merge(int x,int y)
{
    if (x) pushdown(x);
    if (y) pushdown(y);
    if (x*y==0) return x+y;
    if (tar[x]<tar[y])
    {
        ch[x][1]=merge(ch[x][1],y);
        update(x);return x;
    }
    else
    {
        ch[y][0]=merge(x,ch[y][0]);
        update(y);return y;
    }
}
void trash(int x)
{
    if (!x) return;
    trashcan.push(x);
    trash(ch[x][0]);
    trash(ch[x][1]);
}
void insert()
{
    int pos=read(),len=read(),x,y;
    static int datas[N];
    for (int i=1;i<=len;i++)
        datas[i]=read();
    int rt=build(datas,len);
    split(root,pos,x,y);
    root=merge(merge(x,rt),y);
}
void delet()
{
    int pos=read(),len=read(),x1,x2,y1,y2;
    split(root,pos-1,x1,x2);
    split(x2,len,y1,y2);
    root=merge(x1,y2);
    trash(y1);
}
void covers()
{
    int pos=read(),len=read(),v=read(),x1,x2,y1,y2;
    split(root,pos-1,x1,x2);
    split(x2,len,y1,y2);
    cover(y1,v);
    root=merge(x1,merge(y1,y2));
}
void reverses()
{
    int pos=read(),len=read(),x1,x2,y1,y2;
    split(root,pos-1,x1,x2);
    split(x2,len,y1,y2);
    reverse(y1);
    root=merge(x1,merge(y1,y2));
}
void sums()
{
    int pos=read(),len=read(),x1,x2,y1,y2;
    split(root,pos-1,x1,x2);
    split(x2,len,y1,y2);
    printf("%d\n",sum[y1]);
    root=merge(x1,merge(y1,y2));
}
void maxs()
{
    printf("%d\n",tmx[root]);
}
int main() 
{ 
    srand(513);
    static int n=read(),m=read(),a[N]; 
    for (int i=1;i<=n;i++) 
        a[i]=read();
    root=build(a,n); 
    static char s[20]; 
    while (m--) 
    {
        scanf("%s",s); 
        if (s[0]=='I') insert();  
        else if (s[0]=='D') delet(); 
        else if (s[0]=='M' && s[2] =='K') covers();
        else if (s[0]=='R') reverses();
        else if (s[0]=='G') sums();
        else maxs(); 
    }     
}
```

---

## 作者：木木！ (赞：8)

来一篇fhq treap QwQ

为了这题调了一个上午+一个下午，交了11次，~~低于你谷平均AC率~~（我果然太蒻了。

前置知识：这里假设各位已经熟练掌握fhq treap的基本操作（主要是`split`和`merge`），以及明白怎么用平衡树维护序列（如果不明白，出门右转[P3391 文艺平衡树](https://www.luogu.org/problemnew/show/P3391)）（大致概括就是用序列下表作键值，分裂时按大小分裂）

## 1.INSERT

INSERT一个数的时候，将tot个数全部读入一个数组，然后直接$\Theta(tot)$建平衡树，与原树合并。

由于在合并的时候使用现场生成随机值而非赋予节点随机标记，可以更加灵活地使用treap。如果采用赋予随机标记的方法的话，需要设计插入树的标记大小，平添复杂度（时空上和编程上）。

时间复杂度$\Theta(logn+tot)$

详见代码。

## 2.DELETE

DELETE也很灵活。只需要将原树分割出相应区间，然后直接丢掉。

~~壮哉我大fhq！~~

时间复杂度$\Theta(logn)$

## 3.MAKE-SAME

只要分出相应区间，然后打个标记再合回去就好啦。

$\Theta(logn)$

## 4.REVERSE

本身是个人畜无害的操作，但是加上操作6就成了幕后大BOSS……咳咳。

观察到reverse前后的区间最大字段和不变，但是如果reverse标记下传的话就会变成一种“半翻转”的状态，这时候如果不做出任何改变的话就容易WA。

首先，一下将标记下传到底肯定不予考虑（废话），所以考虑在节点持有标记的时候，交换前缀和和后缀和，~~装作已经翻转好了的样子~~。

可以验证，这种做法即使传一半、传得参差不齐、边传边疯狂`pushup`都可以保证答案的正确性。

（如果没有看懂可以考虑先看完操作6再看本节）

## 5.GET-SUM

直接维护每个节点的相应和，记得`pushup`的时候顺手更新就好了。

## 6.MAX-SUM

显然我们不能用每次$\Theta(n)$扫一遍的贪心来解决。

由于树结构自带递归，所以考虑如何用分治法解决这个问题。

这个问题在《算法导论》里面被用作分治法的例题之一。流程是这样的：

1. 分。
2. 治，求出左右字段内的最大字段和。
3. 合，跨中间求和。

在跨中间求和的时候，实质上是将左序列的最大后缀和和右序列最大前缀和加到一起。

所以，我们维护每个区间的最大子段和`mms`、最大前缀和`mls`和最大后缀和`mrs`。

## 坑点

1. 暂时没有测试过如果把0节点pushup或pushdown了之后的后果，但是不知道会不会WA。
2. 必须用taged\[\]数组来记录节点有没有被更改。如果直接`if(tag[x])`的话会在修改成0的时候出错（可能只有我才会犯这种错误）
3. 注意全负的情况。这里用的解决方法是将`mms`强制定义成必须选一个，而`mls`和`mrs`可以为0。

## AC代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;

int max3(int a,int b,int c)
{
	return max(a,max(b,c));
}

int vi[4000005];
int lt[4000005];
int rt[4000005];
int siz[4000005];
int sum[4000005];
int mls[4000005];
int mrs[4000005];
int mms[4000005];
int rev[4000005];
int tag[4000005];
int taged[4000005];
int top;

int build(int x)
{
	++top;
	siz[top] = 1;
	sum[top] = vi[top] = x;
	mms[top] = x;
	mls[top] = mrs[top] = max(x,0);
	return top;
}

inline void pushup(int x)
{
	if(!x)
	{
		return;
	}
	if(taged[x])
	{
		siz[x] = siz[lt[x]]+siz[rt[x]]+1;
		sum[x] = tag[x]*siz[x];
		
		if(tag[x]>0)
		{
			mls[x] = mrs[x] = mms[x] = sum[x];
		}
		else
		{
			mms[x] = tag[x];
			mls[x] = mrs[x] = 0;
		}
		
		return;
	}
	
	sum[x] = sum[lt[x]] + sum[rt[x]] + vi[x];
	siz[x] = siz[lt[x]] + siz[rt[x]] + 1;

	mls[x] = max(sum[lt[x]]+vi[x]+mls[rt[x]], mls[lt[x]]);
	mrs[x] = max(sum[rt[x]]+vi[x]+mrs[lt[x]], mrs[rt[x]]);
	mms[x] = max3(mls[rt[x]]+vi[x]+mrs[lt[x]],mms[lt[x]],mms[rt[x]]);
	
	if(rev[x])
	{
		swap(mls[x],mrs[x]);
	}
}

inline void pushdown(int x)
{
	if(x)
	{
		if(rev[x])
		{
			swap(lt[x],rt[x]);
			rev[lt[x]] = !rev[lt[x]];
			rev[rt[x]] = !rev[rt[x]];
			swap(mls[lt[x]],mrs[lt[x]]);
			swap(mls[rt[x]],mrs[rt[x]]);
		}
		if(taged[x])
		{
			tag[lt[x]] = tag[rt[x]] = tag[x];
			taged[lt[x]] = taged[rt[x]] = 1;
			vi[x] = tag[x];
			pushup(lt[x]);
			pushup(rt[x]);
		}
	}
	taged[x] = rev[x] = 0;
}

void split(int t,int x,int& l,int& r)
{
	if(!t)
	{
		l = r = 0;
		return;
	}
	
	pushdown(t);
	
	if(siz[lt[t]] >= x)
	{
		r = t;
		split(lt[t],x,l,lt[t]);
		pushup(r);
	}
	else
	{
		l = t;
		split(rt[t],x-siz[lt[t]]-1,rt[t],r);
		pushup(l);
	}
}

int merge(int l,int r)
{
	if(!l || !r)
	{
		pushup(l);
		pushup(r);
		return l+r;
	}
	
	pushdown(l);
	pushdown(r);
	
	if(rand()%(siz[l]+siz[r]) <= siz[l])
	{
		rt[l] = merge(rt[l],r);
		pushup(l);
		return l;
	}
	else
	{
		lt[r] = merge(l,lt[r]);
		pushup(r);
		return r;
	}
}

int ai[500005];

int buildarr(int l,int r)
{
	if(l>r)
	{
		return 0;
	}
	if(l==r)
	{
		return build(ai[l]);
	}
	int mid = (l+r)>>1;
	int t = build(ai[mid]);
	lt[t] = buildarr(l,mid-1);
	rt[t] = buildarr(mid+1,r);
	pushup(t);
	return t;
}

char cmd[25];

int main()
{
	srand(20040703);
	
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",ai+i);
	}
	
	mms[0] = 0x80808080;
	int fhq = buildarr(1,n);
	
	for(int i=1; i<=m; ++i)
	{
		scanf("%s",cmd);
		if(!strcmp(cmd,"INSERT")) //strcmp在相等时返回0
		{
			int l,tot;
			scanf("%d%d",&l,&tot);
			for(int i=1; i<=tot; ++i)
			{
				scanf("%d",ai+i);
			}
			
			int ll,rr;
			split(fhq,l,ll,rr);
			
			fhq = merge(ll,merge(buildarr(1,tot),rr));
		}
		else if(!strcmp(cmd,"DELETE"))
		{
			int l,tot;
			scanf("%d%d",&l,&tot);
			
			int ll,ans,rr;
			split(fhq,l-1,ll,rr);
			split(rr,tot,ans,rr);
			
			fhq = merge(ll,rr);
		}
		else if(!strcmp(cmd,"MAKE-SAME"))
		{
			int l,tot,c;
			scanf("%d%d%d",&l,&tot,&c);
			
			int ll,ans,rr;
			split(fhq,l-1,ll,rr);
			split(rr,tot,ans,rr);
			
			tag[ans] = c;
			taged[ans] = 1;
			pushup(ans);
			
			fhq = merge(ll,merge(ans,rr));
		}
		else if(!strcmp(cmd,"REVERSE"))
		{
			int l,tot;
			scanf("%d%d",&l,&tot);
			
			int ll,ans,rr;
			split(fhq,l-1,ll,rr);
			split(rr,tot,ans,rr);
			
			rev[ans] = !rev[ans];
			swap(mls[ans],mrs[ans]);
			
			fhq = merge(ll,merge(ans,rr));
		}
		else if(!strcmp(cmd,"GET-SUM"))
		{
			int l,tot;
			scanf("%d%d",&l,&tot);
			
			int ll,ans,rr;
			split(fhq,l-1,ll,rr);
			split(rr,tot,ans,rr);
			
			printf("%d\n",sum[ans]);
			
			fhq = merge(ll,merge(ans,rr));
		}
		else
		{
			printf("%d\n",mms[fhq]);
		}
	}
}
```

---

## 作者：wrpwrp (赞：8)

本蒟蒻写的第一道平衡树大题，发个题解纪念一下。    
## 前言：
本蒟蒻使用的是fhq_treap，相对来说可能会短一点(~~但是由于我太菜了所以看起来还是很长~~）  
本篇题解实现参考了 @x义x 大佬的代码（~~窝太菜了自己写不出~~）  
## 正题:
 看题：惊人的时间限制——1s，于是可以先做一手卡常的准备了。再看空间上的限制和本题目中那一堆操作，想都不用想就知道肯定要维护一大堆东西，4e6的数据范围128MB开得下我觉得比较难，题目又保证了同一时间内节点数小于等于5e5，所以节点回收是肯定的。然后我们开始一步步解决这个题目。
先把节点定义放出来：
```cpp
struct Node
{
	int lson,rson,siz,val,cov,rnd;   //cov为区间覆盖操作所要使用的值
	int lazy_rev,lazy_cov;  //这两个标记很显然吧emmm...
	int sum,pre_mx,suc_mx,all_mx;  //前缀最大值，后缀最大值，总最大值，和
}t[MAXN];int rt;

#define ls(x) t[x].lson //宏定义——偷懒专用
#define rs(x) t[x].rson
```

### 一、如何回收节点？
考虑开一个栈来存没有用的节点，删除节点的时候就把那些被删的节点堆进去就行，在代码里有清楚的体现  

### 二、如何维护答案？
对于最大子段和的维护考虑维护一个前缀最大和，后缀最大和 和 自身这棵树内的最大和，如何合并呢？
```cpp
inline void Update(int x)
{
	if(!x) return ;
	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;
	t[x].sum=t[ls(x)].sum+t[rs(x)].sum+t[x].val;
	t[x].pre_mx=max(t[ls(x)].pre_mx,t[ls(x)].sum+t[x].val+t[rs(x)].pre_mx,0);
	t[x].suc_mx=max(t[rs(x)].suc_mx,t[rs(x)].sum+t[x].val+t[ls(x)].suc_mx,0);
	t[x].all_mx=max(t[x].val,t[x].val+t[ls(x)].suc_mx+t[rs(x)].pre_mx);
	if(ls(x)) t[x].all_mx=max(t[x].all_mx,t[ls(x)].all_mx);
	if(rs(x)) t[x].all_mx=max(t[x].all_mx,t[rs(x)].all_mx);
}
```
就这个样子。因为前缀后缀都是可以不取的所以可以为0，但是自身不能取0，因为题目强制必须取一个(~~有毒.....~~)

### 三、如何下放标记？
是不是fhq_treap的题目都只要在split的时候丢标记啊......  
(~~反正它过了~~）

### 四、这份代码有锅吗，可以抄吗
~~显然你是可以抄的~~  
但是这个代码有一个很神奇事情就是开不了O2，一开O2就RE，有没有哪位大佬告诉我这是为啥呀5555.   
Orz Orz Orz  

### 五、关于代码里的max
我比较懒，就重载了一个三个参数的max

### 六、code  
```cpp
#include <cstdio>

#define R register
const int MAXN=5e5+10;
const int RAND_1=1e9+7;
const int RAND_2=1e9+9;

inline int read()
{
	char a=getchar();int x=0,f=1;
	for(;a>'9'||a<'0';a=getchar()) if(a=='-') f=-1;
	for(;a>='0'&&a<='9';a=getchar()) x=x*10+a-'0';
	return x*f;
}

int Seed='L'+'C'+'N'+'B'+171098569;
inline int swap(int &x,int &y) { x^=y;y^=x;x^=y; }
inline int max(int x,int y) { return x>y?x:y;}
inline int max(int x,int y,int z) { return max(x,max(y,z)); }
inline int rand() { return Seed=(Seed*RAND_1+0x7f7f7f7f)*RAND_2*Seed; }

int n,m;
int stk[MAXN],cnt;

struct Node
{
	int lson,rson,siz,val,cov,rnd;
	int lazy_rev,lazy_cov;
	int sum,pre_mx,suc_mx,all_mx;
}t[MAXN];int rt;

#define ls(x) t[x].lson
#define rs(x) t[x].rson

inline int New(int k)
{
	int x=stk[cnt--];
	ls(x)=rs(x)=t[x].cov=t[x].lazy_rev=t[x].lazy_cov=0;
	t[x].siz=1;
	t[x].val=t[x].sum=k;
	t[x].pre_mx=t[x].suc_mx=max(0,k);
	t[x].all_mx=k;
	t[x].rnd=rand();
	return x;
}

inline void Update(int x)
{
	if(!x) return ;
	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;
	t[x].sum=t[ls(x)].sum+t[rs(x)].sum+t[x].val;
	t[x].pre_mx=max(t[ls(x)].pre_mx,t[ls(x)].sum+t[x].val+t[rs(x)].pre_mx,0);
	t[x].suc_mx=max(t[rs(x)].suc_mx,t[rs(x)].sum+t[x].val+t[ls(x)].suc_mx,0);
	t[x].all_mx=max(t[x].val,t[x].val+t[ls(x)].suc_mx+t[rs(x)].pre_mx);
	if(ls(x)) t[x].all_mx=max(t[x].all_mx,t[ls(x)].all_mx);
	if(rs(x)) t[x].all_mx=max(t[x].all_mx,t[rs(x)].all_mx);
}

inline void Reverse(int x)
{
	if(!x) return ;
	swap(ls(x),rs(x));
	swap(t[x].pre_mx,t[x].suc_mx);
	t[x].lazy_rev^=1;
}

inline void Cover(int x,int col)
{
	t[x].val=t[x].cov=col;
	t[x].sum=t[x].siz*col;
	t[x].pre_mx=t[x].suc_mx=max(0,t[x].sum);
	t[x].all_mx=max(col,t[x].sum);
	t[x].lazy_cov=1;
}

inline void Pushdown(int x)
{
	if(!x) return ;
	if(t[x].lazy_rev)
	{
		if(ls(x)) Reverse(ls(x));
		if(rs(x)) Reverse(rs(x));
		t[x].lazy_rev=0;
	}
	if(t[x].lazy_cov)
	{
		if(ls(x)) Cover(ls(x),t[x].cov);
		if(rs(x)) Cover(rs(x),t[x].cov);
		t[x].lazy_cov=t[x].cov=0;
	}
}

inline void Delete(int x)
{
	if(!x) return;
	stk[++cnt]=x;
	if(ls(x)) Delete(ls(x));
	if(rs(x)) Delete(rs(x));
}

inline void Split(int now,int k,int &x,int &y)
{
	if(!now) { x = y = 0; return ; }
	Pushdown(now);
	if(t[ls(now)].siz+1<=k)
	{
		x=now;
		Split(rs(now),k-t[ls(now)].siz-1,rs(now),y);
	} 
	else
	{
		y=now;
		Split(ls(now),k,x,ls(now));
	}
	Update(now);
}

inline int Merge(int x,int y)
{
	if(!x||!y) return x|y;
	if(t[x].rnd<t[y].rnd)
	{
		Pushdown(x);
		rs(x)=Merge(rs(x),y);
		Update(x); return x;
	}
	else
	{
		Pushdown(y);
		ls(y)=Merge(x,ls(y));
		Update(y); return y;
	}
}

int array[MAXN];

inline int Build(int l,int r)
{
	if(l==r) return New(array[l]);
	int mid=l+r;mid>>=1;
	return Merge(Build(l,mid),Build(mid+1,r));
}

char opt[10];

int main()
{
	n=read();m=read();
	for(R int i=1;i<MAXN;i++) stk[++cnt]=i;
	for(R int i=1;i<=n;i++) array[i]=read();
	rt=Build(1,n);
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			int pos=read(),tot=read();
			int x,y;
			Split(rt,pos,x,y);
			for(R int i=1;i<=tot;i++) array[i]=read();
			x=Merge(x,Build(1,tot));
			rt=Merge(x,y);
		}
		if(opt[0]=='D')
		{
			int pos=read(),tot=read();
			int x,y,z;
			Split(rt,pos-1,x,y);
			Split(y,tot,y,z);
			Delete(y);
			rt=Merge(x,z);
		}
		if(opt[2]=='K')
		{
			int pos=read(),tot=read(),col=read();
			int x,y,z;
			Split(rt,pos-1,x,y);
			Split(y,tot,y,z);
			Cover(y,col);
			rt=Merge(Merge(x,y),z);
		}
		if(opt[0]=='R')
		{
			int pos=read(),tot=read();
			int x,y,z;
			Split(rt,pos-1,x,y);
			Split(y,tot,y,z);
			Reverse(y);
			rt=Merge(Merge(x,y),z);
		}
		if(opt[0]=='G')
		{
			int pos=read(),tot=read();
			int x,y,z;
			Split(rt,pos-1,x,y);
			Split(y,tot,y,z);
			printf("%d\n",t[y].sum);
			rt=Merge(Merge(x,y),z);
		}
		if(opt[2]=='X')
		{
			printf("%d\n",t[rt].all_mx);
		}
	}
	return 0;
}
```


---

## 作者：shadyqwq (赞：7)

考虑用fhqtreap来写，最大子段和维护起来比线段树要方便，建树的时候利用笛卡尔树的建树方法就行了。。。

以前的时候我写的是暴力插入建树。非常之蠢。。。

注意，答案必须至少选一个数。

那么在upd的时候利用uls.mx,urs.mx更新的时候注意是否有左右儿子就行了。

然后的问题就是区间修改，实际上和线段树的打标记一样，注意merge和split的时候要先pushdown。

建树的时候不要忘了把栈里的所有元素都清空upd。

```cpp
# include <bits/stdc++.h>

using namespace std;

# define REP(i, a, b) for(int i = a; i <= b; ++ i)
# define REPD(i, a, b) for(int i = a; i >= b; -- i)
# define CLR(i, a) memset(i, a, sizeof(i))
# define REPG(i, h, x) for(int i = h[x]; ~i; i = edge[i].next)
# define QAQ puts("*")

const int N = 5e5 + 3, INF = 0x7fffffff;

int n, a[N];
char buf[20];

# define gc getchar
inline int rd() {
	char ch = gc(); int ret = 0, sgn = 1;
	while(ch < '0' || ch > '9') { if(ch == '-') sgn = -1; ch = gc(); }
	while(ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = gc();
	return ret * sgn;
}

struct Treap {
	# define u tr[x]
	# define o tr[y]
	# define uls tr[u.ls]
	# define urs tr[u.rs]
	
	struct node {  
		int lmx, rmx, mx, sum, ls, rs, sz, co, val;
		bool re;
		int prio;
		node() { lmx = rmx = mx = sum = re = prio = ls = rs = sz = val = 0, co = INF; }
		void init(int _l, int _r, int _m, int _s, int _sz, int _val) { 
			lmx = _l, rmx = _r, mx = _m, sum = _s, prio = rand(), sz = _sz, val = _val;
		}
		void rev() { re ^= 1, swap(ls, rs), swap(lmx, rmx); }
		void cov(int c) {
			co = val = c;
			sum = co * sz;
			lmx = max(0, sum), rmx = max(0, sum);
			mx = max(sum, co);
		}

	} tr[N];

	int tot, mptp;
	# define pb push
	queue<int> memp;
	void del(int x) {
		memp.pb(x);
		if(u.ls) del(u.ls);
		if(u.rs) del(u.rs);
	}

	inline int malloc() { 
		int x;
		return (!memp.empty()) ? (tr[x = memp.front()] = node(), memp.pop(), x) : (tr[++ tot] = node(), tot); 
	}
	int rt;

	# define pii pair<int, int>
	# define mp make_pair
	# define sec second
	# define fir first

	void pd(int x) {
		if(!x) return ;
		if(u.re) {
			if(u.ls) uls.rev();
			if(u.rs) urs.rev();
			u.re ^= 1;
		}
		if(u.co != INF) {
			if(u.ls) uls.cov(u.co);
			if(u.rs) urs.cov(u.co);
			u.co = INF;
		}
	}

	void upd(int x) {
		if(!x) return ;
		u.sz = uls.sz + 1 + urs.sz;
		u.sum = uls.sum + urs.sum + u.val;
		u.mx = max(uls.rmx + u.val + urs.lmx, u.val);
		if(u.ls) u.mx = max(u.mx, uls.mx);
		if(u.rs) u.mx = max(u.mx, urs.mx);
		u.lmx = max(max(uls.sum + u.val + urs.lmx, uls.lmx), 0);
		u.rmx = max(max(urs.sum + u.val + uls.rmx, urs.rmx), 0);
	}

	int merge(int x, int y) {
		if(x) pd(x); 
		if(y) pd(y);
		if(x == 0 || y == 0) return (x ? x : y);
		if(u.prio < o.prio) return o.ls = merge(x, o.ls), upd(y), y;
		else return u.rs = merge(u.rs, y), upd(x), x;
	}

	pii split(int x, int k) {
		if(!k) return mp(0, x); // ---------
		pd(x); 
		if(uls.sz + 1 <= k) {
			pii tmp = split(u.rs, k - uls.sz - 1);
			u.rs = tmp.fir, upd(x);
			return mp(x, tmp.sec);
		}
		else {
			pii tmp = split(u.ls, k);
			u.ls = tmp.sec, upd(x);
			return mp(tmp.fir, x);
		}
	}

	int stk[N], tp;
	int build(int *b, int l) {	
		tp = 0;
		int tmp = malloc();
		tr[tmp].init(max(0, b[1]), max(0, b[1]), b[1], b[1], 1, b[1]);
		stk[++ tp] = tmp;
		REP(i, 2, l) {
			int x = malloc(), pre = 0;
			u.init(max(0, b[i]), max(0, b[i]), b[i], b[i], 1, b[i]);
			while(tp && tr[stk[tp]].prio < u.prio) pre = stk[tp --], upd(pre);
			if(tp) tr[stk[tp]].rs = x;
			u.ls = pre, stk[++ tp] = x;
			if(tp == 1) tmp = x; // !!!!!!!!!!
//			printf("%d %d %d %d\n", stk[tp], x, u.ls, pre);
		}
		while(tp) upd(stk[tp --]);
		return tmp;
	} 

	void ins_seq() {
		int k = rd(), m = rd();
    	    	REP(i, 1, m) a[i] = rd();
    	    	int y = build(a, m);
    	    	pii tmp = split(rt, k);
    	    	y = merge(tmp.fir, y);
    	    	rt = merge(y, tmp.sec);
	}

	void del_seq() {
		int k = rd(), m = rd();
    	    	pii pt1 = split(rt, k - 1);
    	    	pii pt2 = split(pt1.sec, m);
    	    	del(pt2.fir);
    	    	rt = merge(pt1.fir, pt2.sec);
	}

	void cov_seq() {
		int k = rd(), m = rd(), c = rd();
    	    	pii pt1 = split(rt, k - 1);
    	    	pii pt2 = split(pt1.sec, m);
    	    	tr[pt2.fir].cov(c);
    	    	rt = merge(merge(pt1.fir, pt2.fir), pt2.sec);
	}

	void rev_seq() {
		int k = rd(), m = rd();
    	    	pii pt1 = split(rt, k - 1);
    	    	pii pt2 = split(pt1.sec, m);
    	    	tr[pt2.fir].rev();
    	    	rt = merge(merge(pt1.fir, pt2.fir), pt2.sec);
	}

	int get_sum() {
		int k = rd(), m = rd();
    	    	pii pt1 = split(rt, k - 1);
    	    	pii pt2 = split(pt1.sec, m);
    	    	printf("%d\n", tr[pt2.fir].sum);
    	    	rt = merge(merge(pt1.fir, pt2.fir), pt2.sec);
	}
	void print(int x) {
		if(u.ls) print(u.ls);
		printf("[%d: %d]\n", x, u.val);
		if(u.rs) print(u.rs);	
		
	}

} t;


int main() {
	srand(233);
	n = rd();
	int q = rd(); 
	REP(i, 1, n) a[i] = rd();
	t.rt = t.build(a, n);    
	while(q --) {
    	    	scanf("%s", buf + 1); 
    	    	if(buf[1] == 'I') t.ins_seq();
    	    	else if(buf[1] == 'D') t.del_seq();
    	    	else if(buf[1] == 'M' && buf[3] == 'K') t.cov_seq();
    	    	else if(buf[1] == 'R') t.rev_seq();
    	    	else if(buf[1] == 'G') t.get_sum();
    	    	else printf("%d\n", t.tr[t.rt].mx);
    	}   
	return 0;
}
```

---

## 作者：rvalue (赞：5)

直接抄一段刚刚写的博客好了憋打我(逃

首先简单梳理一下,题目要求支持的操作有:Reverse/Set/Sum/MaxSum/Delete/Insert.


其中需要下传标记的是Set和Reverse,分别使用两个bool型标记即可.其中Set操作标记的处理优先于Reverse因为Set操作会将整个区间设置为同一个值,翻转不翻转都一样233


我们注意到有MaxSum操作,这时我们需要分析一下.我们可以使用三个变量来存储有关信息:lmax存储以该区间左端开始向右的最大和,rmax存储以该区间右端为结尾向左的最大和,maxSum存储该区间内的最大连续和的值.这样就可以将maxSum分为三种情况:左子树的maxSum;右子树的maxSum;左子树rmax,右子树lmax和该节点的键值之和.分别代表完全位于左区间/完全位于右区间/跨越中间的最大连续和(此部分的分治策略可参见算法导论第三版中文版的4.1节).lmax和rmax则分别对应两种情况,以lmax为例,对应左子树的lmax值与左子树的sum值,该结点的键值和右子树的lmax值之和的最大值.rmax同理.


对于空结点要注意maxSum为-INF,其他值为0.


更新时对于sum<0的情况要更新lmax与rmax为0,maxSum为键值.


对于调试可以参考一下我在下面代码中的 class SplayTree 里写的Print函数,按前序遍历顺序打印整棵树并按深度缩进...调试的时候帮了我不少忙来着w

```cpp
/**************************************
      Judge Result: Accepted

**************************************/
#include <cstdio>
#include <vector>
#include <cstring>
#include <cstring>
#include <iostream>
#include <algorithm>

#define lch chd[0]
#define rch chd[1]
#define kch chd[k]
#define xch chd[k^1]

const int INF=0x2FFFFFFF;

class SplayTree{
private:
    struct Node{
        int k;
        int sz;
        int sm;
        int lm;
        int rm;
        int ms;
        bool set;
        bool rev;
        Node* prt;
        Node* chd[2];
        Node(const int& key){
            this->k=key;
            this->sm=key;
            this->ms=key;
            this->lm=key>=0?key:0;
            this->rm=key>=0?key:0;
            this->sz=1;
            this->prt=NULL;
            this->lch=NULL;
            this->rch=NULL;
            this->rev=false;
            this->set=false;
        }
        ~Node(){
            if(this->lch!=NULL)
                delete this->lch;
            if(this->rch!=NULL)
                delete this->rch;
        }
        inline void Maintain(){
            if(this!=NULL){
                this->sz=this->lch->size()+this->rch->size()+1;
                this->sm=this->lch->sum()+this->rch->sum()+this->k;
                this->lm=std::max(this->lch->lmax(),this->lch->sum()+this->k+this->rch->lmax());
                this->rm=std::max(this->rch->rmax(),this->rch->sum()+this->k+this->lch->rmax());
                this->ms=std::max(std::max(this->lch->maxSum(),this->rch->maxSum()),this->lch->rmax()+this->k+this->rch->lmax());
            }
        }
        inline void Swap(){
            if(this!=NULL){
                this->rev=!this->rev;
                std::swap(this->lm,this->rm);
                std::swap(this->lch,this->rch);
            }
        }
        inline void Set(const int& key){
            if(this!=NULL){
                this->set=true;
                this->k=key;
                this->sm=key*this->sz;
                this->lm=std::max(this->sm,0);
                this->rm=std::max(this->sm,0);
                this->ms=std::max(this->sm,this->k);
            }
        }
        inline void PushDown(){
            if(this->set){
                this->set=this->rev=false;
                this->lch->Set(this->k);
                this->rch->Set(this->k);
            }
            if(this->rev){
                this->rev=false;
                this->lch->Swap();
                this->rch->Swap();
            }
        }
        inline int sum(){
            return this==NULL?0:this->sm;
        }
        inline int maxSum(){
            return this==NULL?-INF:this->ms;
        }
        inline int key(){
            return this==NULL?0:this->k;
        }
        inline int lmax(){
            return this==NULL?0:this->lm;
        }
        inline int rmax(){
            return this==NULL?0:this->rm;
        }
        inline int size(){
            return this==NULL?0:this->sz;
        }
    }*root;
    inline void Rotate(Node* root,int k){
        Node* tmp=root->xch;
        root->PushDown();
        tmp->PushDown();
        tmp->prt=root->prt;
        if(root->prt==NULL)
            this->root=tmp;
        else if(root->prt->lch==root)
            root->prt->lch=tmp;
        else
            root->prt->rch=tmp;
        root->xch=tmp->kch;
        if(tmp->kch!=NULL)
            tmp->kch->prt=root;
        tmp->kch=root;
        root->prt=tmp;
        root->Maintain();
        tmp->Maintain();
    }
    void Splay(Node* root,Node* prt=NULL){
        while(root->prt!=prt){
            int k=root->prt->lch==root;
            if(root->prt->prt==prt){
                Rotate(root->prt,k);
            }
            else{
                int d=root->prt->prt->lch==root->prt;
                Rotate(k==d?root->prt->prt:root->prt,k);
                Rotate(root->prt,d);
            }
        }
    }
    Node* Build(const std::vector<int>& v,int l,int r){
        if(l>r)
            return NULL;
        int mid=(l+r)>>1;
        Node* tmp=new Node(v[mid]);
        tmp->lch=Build(v,l,mid-1);
        tmp->rch=Build(v,mid+1,r);
        if(tmp->lch!=NULL)
            tmp->lch->prt=tmp;
        if(tmp->rch!=NULL)
            tmp->rch->prt=tmp;
        tmp->Maintain();
        return tmp;
    }
    void PrintTree(Node* root,int deep){
        for(int i=0;i<deep;i++)
            fputc(' ',stderr);
        fprintf(stderr, "(root=0x%X,key=%d,sum=%d,size=%d,lmax=%d,rmax=%d,maxSum=%d)\n", root,root->key(),root->sum(),root->size(),root->lmax(),root->rmax(),root->maxSum());
        if(root==NULL)
            return;
        PrintTree(root->lch,deep+1);
        PrintTree(root->rch,deep+1);
    }
public:
    SplayTree(){
        this->root=new Node(-INF);
        this->root->rch=new Node(-INF);
        this->root->rch->prt=this->root;
    }
    SplayTree(const std::vector<int>& v){
        this->root=Build(v,0,v.size()-1);
    }
    ~SplayTree(){
        delete this->root;
    }
    Node* Kth(int pos){
        ++pos;
        Node* root=this->root;
        while(root!=NULL){
            root->PushDown();
            int k=root->lch->size()+1;
            if(pos<k)
                root=root->lch;
            else if(pos==k)
                return root;
            else{
                pos-=k;
                root=root->rch;
            }
        }
        return NULL;
    }
    inline int Sum(const int& pos,const int& len){
        this->Splay(this->Kth(pos-1));
        this->Splay(this->Kth(pos+len),this->root);
        return this->root->rch->lch->sum();
    }
    inline void Reverse(const int& pos,const int& len){
        this->Splay(this->Kth(pos-1));
        this->Splay(this->Kth(pos+len),this->root);
        this->root->rch->lch->Swap();
        this->root->rch->Maintain();
        this->root->Maintain();
    }
    inline void Set(const int& pos,const int& len,const int& d){
        this->Splay(this->Kth(pos-1));
        this->Splay(this->Kth(pos+len),this->root);
        this->root->rch->lch->Set(d);
        this->root->rch->Maintain();
        this->root->Maintain();
    }
    inline void Insert(const int& pos,SplayTree* data){
        this->Splay(this->Kth(pos));
        this->Splay(this->Kth(pos+1),this->root);
        Node* tmp=data->root;
        data->root=NULL;
        this->root->rch->lch=tmp;
        tmp->prt=this->root->rch;
        this->root->rch->Maintain();
        this->root->Maintain();
    }
    inline void Delete(const int& pos,const int& len){
        this->Splay(this->Kth(pos-1));
        this->Splay(this->Kth(pos+len),this->root);
        delete this->root->rch->lch;
        this->root->rch->lch=NULL;
        this->root->rch->Maintain();
        this->root->Maintain();
    }
    inline int MaxSum(){
        return this->root->maxSum();
    }
    void Print(){
        this->PrintTree(this->root,0);
    }
};

int FastRead();

int main(){
    SplayTree* tree=new SplayTree();
    std::vector<int> v;
    int n=FastRead();
    int m=FastRead();
    int a,b;
    char buf[20];
    for(int i=0;i<n;i++){
        v.push_back(FastRead());
    }
    tree->Insert(0,new SplayTree(v));
    for(int i=0;i<m;i++){
        scanf("%s",buf);
        if(*buf!='M'||buf[2]!='X'){
            a=FastRead();
            b=FastRead();
        }
        if(*buf=='G'){
            printf("%d\n",tree->Sum(a,b));
        }
        else if(*buf=='D')
            tree->Delete(a,b);
        else if(*buf=='R')
            tree->Reverse(a,b);
        else if(*buf=='I'){
            v.clear();
            while(b--)
                v.push_back(FastRead());
            tree->Insert(a,new SplayTree(v));
        }
        else if(*buf=='M'){
            if(buf[2]=='K')
                tree->Set(a,b,FastRead());
            else
                printf("%d\n",tree->MaxSum());
        }
        // tree->Print();
    }
    return 0;
}

int FastRead(){
    int ans=0;
    bool neg=false;
    register char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')
            neg=true;
        ch=getchar();
    }
    while(isdigit(ch)){
        ans=ans*10+ch-'0';
        ch=getchar();
    }
    if(neg)
        ans=-ans;
    return ans;
}
```

---

## 作者：dengyaotriangle (赞：3)

这道题的解法其他题解说的已经很清楚了

如果大家会splay/fhq-treap这道题的做法是很显然的，这道题主要考验的是码力/debug能力/肝

但是这道题卡空间，也就是需要垃圾回收（delete掉的点的空间需要再利用）   
很多人会习惯开一个队列/栈来记录垃圾,之后优先从队列/栈里取点，如果没有再新开点,其它题解也都是这么写的

这种做法有两个缺点，一是那个队列/栈本身是占空间的，如果有超毒瘤的人卡你就会gg,二是要写好多行代码

所以我使用了另外一种方法（只能在指针版的实现方式中使用）
```cpp

#include<new>

node* nw = new node;
delete nw;

```
很多人觉得指针版的东西不好,容易RE,但写个百八十遍就很容易看出来是哪里错了  
而且，指针版的还可以用new(也就是这里我用的垃圾回收的东西)

这种技巧是可以在c++98中使用的，只要引用那个库就行

new是c++自带的一个内存分配的东西,可以替代你们之前熟悉的
```cpp
node pool[maxn];
int ps;

node* nw=pool+ps++;

```
而删除就直接delete那个指针就行了

但这种做法的缺点是慢,如果你被卡时间而不是空间的话还是要换回传统写法

所以，奉上我用了new/delete的指针版fhq-treap代码，如果还不明白new/delete的用法的话可以看代码中的实现

```cpp
#include<iostream>
#include<new>
#include<cstring>
#include<cstdlib>

using namespace std;

const int maxn=500005;

struct node{
    int tgr,tgc;
    int lm,rm,tm,sum;
    int rnd,sze,val;
    node* c[2];
};

node* nwnode(int v){
    node* nw=new node;
    nw->tgr=0;nw->tgc=0x3fff3fff;nw->lm=nw->rm=nw->tm=nw->sum=nw->val=v;nw->rnd=rand();nw->sze=1;
    return nw;
}

int gsz(node* rt){
    return rt?rt->sze:0;
}
int gsm(node* rt){
    return rt?rt->sum:0;
}
int glm(node* rt){
    return rt?rt->lm:0xd0c0c0c0;
}
int grm(node* rt){
    return rt?rt->rm:0xd0c0c0c0;
}
int gtm(node* rt){
    return rt?rt->tm:0xd0c0c0c0;
}
void pu(node* rt){
    if(!rt) return;
    rt->sze=gsz(rt->c[0])+gsz(rt->c[1])+1;
    rt->sum=gsm(rt->c[0])+rt->val+gsm(rt->c[1]);
    rt->lm=max(glm(rt->c[0]),gsm(rt->c[0])+rt->val+max(0,glm(rt->c[1])));
    rt->rm=max(grm(rt->c[1]),gsm(rt->c[1])+rt->val+max(0,grm(rt->c[0])));
    rt->tm=max(max(gtm(rt->c[0]),gtm(rt->c[1])),rt->val+max(0,grm(rt->c[0]))+max(0,glm(rt->c[1])));
}
void pd(node* rt){
    if(!rt) return;
    if(rt->tgc!=0x3fff3fff){
        rt->sum=rt->sze*rt->tgc;
        rt->val=rt->tgc;
        if(rt->tgc<0){
            rt->lm=rt->rm=rt->tm=rt->tgc;
        }else{
            rt->lm=rt->rm=rt->tm=rt->tgc*rt->sze;
        }
        if(rt->c[0]) rt->c[0]->tgc=rt->tgc;
        if(rt->c[1]) rt->c[1]->tgc=rt->tgc;
        rt->tgc=0x3fff3fff;
    }
    if(rt->tgr){
        swap(rt->c[0],rt->c[1]);
        swap(rt->lm,rt->rm);
        if(rt->c[0]) rt->c[0]->tgr^=1;
        if(rt->c[1]) rt->c[1]->tgr^=1;
        rt->tgr=0;
    }
}
void del(node* rt){
    if(!rt) return;
    del(rt->c[0]);
    del(rt->c[1]);
    delete rt;
}

void spk(node* rt,int k,node*& a,node*& b){
    if(!rt){
        a=b=NULL;
        return;
    }
    pd(rt);
    if(k>gsz(rt->c[0])){
        a=rt;
        spk(rt->c[1],k-gsz(rt->c[0])-1,a->c[1],b);
        pd(a->c[0]);pd(a->c[1]);pu(a);
    }else{
        b=rt;
        spk(rt->c[0],k,a,b->c[0]);
        pd(b->c[0]);pd(b->c[1]);pu(b);
    }
}

node* mrg(node* a,node* b){
    if(!a){
        pd(b);return b;
    }
    if(!b){
        pd(a);return a;
    }
    pd(a);pd(b);
    if(a->rnd>b->rnd){
        a->c[1]=mrg(a->c[1],b);
        pd(a->c[0]);pd(a->c[1]);pu(a);
        return a;
    }else{
        b->c[0]=mrg(a,b->c[0]);
        pd(b->c[0]);pd(b->c[1]);pu(b);
        return b;
    }
}

int a[maxn];
int n,m;

node* bt(int l,int r){
    if(r<l) return NULL;
    int m=(l+r)/2;
    node* rt=nwnode(a[m]);
    rt->c[0]=bt(l,m-1);
    rt->c[1]=bt(m+1,r);
    pu(rt);
    return rt;
}

void dfs(node* rt){
    if(!rt) return;
    pd(rt);
    cout<<"{";
    dfs(rt->c[0]);
    cout<<'('<<rt->val<<','<<rt->sum<<','<<rt->tm<<')';
    dfs(rt->c[1]);
    cout<<"}";
}
int main(){
    ios::sync_with_stdio(0);
    srand(time(0));
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    node* rt=bt(1,n);
    while(m--){
        char op[20];
        int p;
        cin>>op;
        if(op[2]=='S'){
            cin>>p>>n;
            if(n==0) continue;
            for(int i=1;i<=n;i++)cin>>a[i];
            node* nw=bt(1,n);
            node *a,*b;
            spk(rt,p,a,b);
            rt=mrg(mrg(a,nw),b);
        }else if(op[2]=='L'){
            cin>>p>>n;
            if(n==0) continue;
            node *a,*b,*c,*d;
            spk(rt,p-1,a,b);
            spk(b,n,c,d);
            rt=mrg(a,d);
            del(c);
        }else if(op[2]=='K'){
            int cl;cin>>p>>n>>cl;
            if(n==0) continue;
            node *a,*b,*c,*d;
            spk(rt,p-1,a,b);
            spk(b,n,c,d);
            c->tgc=cl;
            pd(c);
            rt=mrg(a,mrg(c,d));
        }else if(op[2]=='V'){
            cin>>p>>n;
            if(n==0) continue;
            node *a,*b,*c,*d;
            spk(rt,p-1,a,b);
            spk(b,n,c,d);
            c->tgr^=1;
            pd(c);
            rt=mrg(a,mrg(c,d));
        }else if(op[2]=='T'){
            cin>>p>>n;
            if(n==0){
                cout<<0<<'\n';continue;
            }
            node *a,*b,*c,*d;
            spk(rt,p-1,a,b);
            spk(b,n,c,d);
            cout<<c->sum<<'\n';
            rt=mrg(a,mrg(c,d));
        }else if(op[2]=='X'){
            cout<<rt->tm<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：xukuan (赞：3)

## 注意事项

1. 本题解最大的一个点（\#9）跑了851ms，在实际比赛里是无法通过的（CCF老爷机2009年正式投入使用）

2. 本题fhqtreap的代码风格：新建节点时记录随机权值在合并时使用

## 题目分析

本题共有6种操作：区间插入，区间删除，区间推平，区间翻转，区间求和，区间最大子段和

考虑fhqtreap或splay解法，本题解使用fhqtreap

### operation 1 区间插入

以pos位置为界分裂成x,y两段，然后新建一颗树并合并回去

伪代码：

```cpp
split(root,pos,x,y)
init(a)
root=merge(x,merge(build(a),y)
```

### operation 2 区间删除

以pos和pos+tot为界分裂成x,y,z三段，然后把x,z合并回去

伪代码：

```cpp
split(root,pos-1,x,y)
split(y,tot,y,z)
root=merge(x,z)
```

### operation 3 区间推平

以pos和pos+tot为界分裂成x,y,z三段，给区间y打上区间推平标记，然后把x,y,z合并回去

伪代码：
```cpp
split(root,pos-1,x,y)
split(y,tot,y,z)
cover(y)
root=merge(x,merge(y,z))
```

### operation 4 区间反转

以pos和pos+tot为界分裂成x,y,z三段，给区间y打上区间反转标记，然后把x,y,z合并回去

伪代码：
```cpp
split(root,pos-1,x,y)
split(y,tot,y,z)
reverse(y)
root=merge(x,merge(y,z))
```

### operatino 5 区间求和

以pos和pos+tot为界分裂成x,y,z三段，给区间y算求和，然后把x,y,z合并回去

伪代码：
```cpp
split(root,pos-1,x,y)
split(y,tot,y,z)
write(tree[y].sum)
root=merge(x,merge(y,z))
```

### operation 6 区间最大子序列

以pos和pos+tot为界分裂成x,y,z三段，给区间y算最大子序列（不会的去做SPOJ GSS3），然后把x,y,z合并回去

伪代码：
```cpp
split(root,pos-1,x,y)
split(y,tot,y,z)
write(tree[y].sum)
root=merge(x,merge(y,z))
```

------------


看split和merge两个操作，我们现在要处理pushup和pushdown，另外还有cover和reverse要处理

### 关于pushup：

pushup需要传这几个量：

子树大小和维护区间最大子段和所需的四个量。

### 关于pushdown：

这里有cover和reverse两个标记。

我们发现，**标记下传的顺序不影响最终结果**，换句话说，先传cover和先传reverse都可以。

另外注意reverse的时候不能以标记的值是否为某个数来判断有没有数字，要再开一个变量tag来表示

### 关于建树

仿照线段树的二分建树即可

### 内存问题

暴力的话，这题的内存是不够用的。

我们发现一个很反常的地方：

- $100%$的数据中，$M \leq 20000$，插入的数字总数不超过$4000000$。
- $100%$的数据中，任何时刻数列中最多含有$500000$个数。

因此我们需要一个垃圾回收系统来节省内存，具体就是记下用过的坐标，用的时候从未用过的里边找一个作为坐标，这样就可以了

### 代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=500010;
ll n,m,root,cnt,a[N],top,st[N];
struct fhqtreap{
    ll lson,rson,rev,cov,size,val,sum,Lmax,Rmax,Mmax,tag,rnd;
}tree[N];

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

inline void write(ll x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<3)+(y<<1);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}

inline ll New(ll val){
    ll p=st[top--];
    tree[p].rnd=rand();
    tree[p].lson=tree[p].rson=tree[p].rev=tree[p].cov=0;
    tree[p].size=1;
    tree[p].val=tree[p].sum=tree[p].Mmax=val;
    tree[p].Lmax=tree[p].Rmax=max(0ll,val);
    return p;
}

inline void pushup(ll p){
    tree[p].size=tree[tree[p].lson].size+tree[tree[p].rson].size+1;
    tree[p].sum=tree[tree[p].lson].sum+tree[tree[p].rson].sum+tree[p].val;
    tree[p].Lmax=max(max(tree[tree[p].lson].Lmax,tree[tree[p].lson].sum+tree[p].val+tree[tree[p].rson].Lmax),0ll);
    tree[p].Rmax=max(max(tree[tree[p].rson].Rmax,tree[tree[p].rson].sum+tree[p].val+tree[tree[p].lson].Rmax),0ll);
    tree[p].Mmax=max(tree[p].val,tree[tree[p].lson].Rmax+tree[p].val+tree[tree[p].rson].Lmax);
    if(tree[p].lson) tree[p].Mmax=max(tree[p].Mmax,tree[tree[p].lson].Mmax);
    if(tree[p].rson) tree[p].Mmax=max(tree[p].Mmax,tree[tree[p].rson].Mmax);
}

inline void reverse(ll p){
    swap(tree[p].lson,tree[p].rson);
    swap(tree[p].Lmax,tree[p].Rmax);
    tree[p].rev^=1;
}

inline void cover(ll p,ll val){
    tree[p].val=tree[p].cov=val;
    tree[p].sum=tree[p].size*val;
    tree[p].Lmax=tree[p].Rmax=max(0ll,tree[p].sum);
    tree[p].Mmax=max(val,tree[p].sum);
    tree[p].tag=1;
}

inline void pushdown(ll p){
    if(tree[p].rev){
        if(tree[p].lson) reverse(tree[p].lson);
        if(tree[p].rson) reverse(tree[p].rson);
        tree[p].rev=0;
    }
    if(tree[p].tag){
        if(tree[p].lson) cover(tree[p].lson,tree[p].cov);
        if(tree[p].rson) cover(tree[p].rson,tree[p].cov);
        tree[p].cov=tree[p].tag=0;
    }
}

void split(ll p,ll k,ll &x,ll &y){
    if(!p){
        x=y=0;
        return;
    }
    pushdown(p);
    if(tree[tree[p].lson].size+1<=k){
        x=p;
        split(tree[p].rson,k-tree[tree[p].lson].size-1,tree[p].rson,y);
    }
    else{
        y=p;
        split(tree[p].lson,k,x,tree[p].lson);
    }
    pushup(p);
}

ll merge(ll x,ll y){
    if(!x||!y) return x|y;
    if(tree[x].rnd<tree[y].rnd){
        pushdown(x);
        tree[x].rson=merge(tree[x].rson,y);
        pushup(x);
        return x;
    }
    else{
        pushdown(y);
        tree[y].lson=merge(x,tree[y].lson);
        pushup(y);
        return y;
    }
}

inline ll build(ll l,ll r){
    if(l==r) return New(a[l]);
    ll mid=(l+r)>>1;
    return merge(build(l,mid),build(mid+1,r));
}

void erase(ll p){
    st[++top]=p;
    if(tree[p].lson) erase(tree[p].lson);
    if(tree[p].rson) erase(tree[p].rson);
}

int main(){
    for(ll i=1; i<=N-10; i++) st[++top]=i;
    srand(time(NULL));
    n=read(); m=read();
    for(ll i=1; i<=n; i++) a[i]=read();
    root=build(1,n);
    while(m--){
        char op[10]; scanf("%s",op);
        ll x,y,z;
        switch(op[0]){
            case 'I':{
                ll pos=read(),tot=read();
                split(root,pos,x,y);
                for(ll i=1; i<=tot; i++) a[i]=read();
                root=merge(merge(x,build(1,tot)),y);
                break;
            }
            case 'D':{
                ll pos=read(),tot=read();
                split(root,pos-1,x,y);
                split(y,tot,y,z);
                erase(y);
                root=merge(x,z);
                break;
            }
            case 'R':{
                ll pos=read(),tot=read();
                split(root,pos-1,x,y);
                split(y,tot,y,z);
                reverse(y);
                root=merge(x,merge(y,z));
                break;
            }
            case 'G':{
                ll pos=read(),tot=read();
                split(root,pos-1,x,y);
                split(y,tot,y,z);
                write(tree[y].sum); putchar('\n');
                root=merge(x,merge(y,z));
                break;
            }
            case 'M':{
                switch(op[2]){
                    case 'K':{
                        ll pos=read(),tot=read(),val=read();
                        split(root,pos-1,x,y);
                        split(y,tot,y,z);
                        cover(y,val);
                        root=merge(x,merge(y,z));
                        break;
                    }
                    case 'X':{
                        write(tree[root].Mmax);
                        putchar('\n');
                        break;
                    }
                    default:{
                        printf("FUCK %s\n",op);
                        break;
                    }
                }
                break;
            }
            default:{
                printf("FUCK %s\n",op);
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：RainAir (赞：3)

本文同步发表于 [RainAir's Blog](https://blog.aor.sd.cn/archives/457)

# 如何维护区间
我们都知道平衡树是一种很神奇的东西，可以用于维护动态的序列总信息，但是如果想维护其中的某一个区间的信息，我们该怎么做好呢？

我们考虑换一种维护方式：平衡树的结构不是按照节点的值的大小来进行建树，而是以这个节点在序列中的位置为关键字来维护。也就是说对于平衡树中任意一个节点 $x$ ，左子树中的元素永远在它前面，右子树的元素永远在它后面。显然一个区间可以对应一个子树，所以我们要使用能提取子树的数据结构，比如 Splay 和 非旋 Treap。

比如我们考虑提取 $[l,r]$ 的区间信息：我们首先将 $l-1$ 节点旋转到根，Splay 变成了这样：

![](https://i.loli.net/2019/02/03/5c55bef42cf75.png)

然后我们接着把 $r+1$ 旋转到 $l-1$ 的下方，也就变成了这样：


![](https://i.loli.net/2019/02/03/5c55bef4bb11c.png)

我们发现 $R+1$ 节点的左子树就是我们要的区间！所以我们直接对这个子树进行想要的操作即可，复杂度是旋转的复杂度即**均摊**$O(logn)$。

接下来我们来看一道例题。
# 「NOI2005」维修数列
题目大意：要求你维护一个数列，支持以下操作：

![](https://i.loli.net/2019/02/03/5c55befe7d36e.png)

任何时刻数列中最多含有 $5\times 10^5$ 个数，数列中任何一个数字均在 $[-10^3, 10^3]$ 内。

插入的数字总数不超过 $4 \times 10^6$个，输入文件大小不超过 $\text{20M}$。

显然这就是用 Splay 维护区间信息的裸题，接下来我们对于每个操作都分析一遍。
## Insert 操作
看起来暴力插入所有的数非常不可取。。。随便就能卡掉的样。

我们不妨考虑一下如果我们有了一个序列里的所有的树，想得到这个序列对应的 Splay 可以有什么方便的方法。显然我们可以直接暴力递归建树，这样不仅快 ($O(nlogn)$) 得到的树也十分平衡。具体建树过程就是每次选择中点作为当前的根，然后递归处理中点左边和右边。

我们不妨把输入的序列先搞个 Splay 出来，然后我们发现在 $x$ 后插入，如果我们按照上面的方法提取出区间 $[x,x+1]$，那么 $x+1$ 的左子树不久应该是我们新建出来的 Splay 吗。。。直接接上去就可以了。

## Delete 操作
和 Insert 操作相同的思路：我们直接把这段区间提取出来，不过我们发现现在我们是要删除，所以直接断开这个区间代表的子树与父节点的连接就可以了。但是在这题中为了节省运行空间建议写一个内存回收池来回收这些被删除的节点，这个操作甚至比插入还简单。

## MAKE-SAME 操作
考虑把这一段区间修改成同一个数。在线段树上区间操作我们有 lazy-tag 可用，在平衡树上也可以。我们提取出这个区间，然后在根节点打个区间覆盖的标记就行了。注意每次访问这个区间前标记**必须**要下放。
## 翻转
学过 LCT 的都会，没学过的参考一下文艺平衡树的做法就可以了。

我们发现建出的 Splay 同时保留了原来序列的性质：如果我们中序遍历这棵 Splay，那么得到的序列就是原序列！我们考虑区间翻转意味着什么：是不是就是对于这个区间里的每一个节点左右儿子都互换啊（因为互换后现在先遍历的是原来后遍历的，并且子树也都交换了）。所以我们同时维护一下翻转标记就可以了。

注意到下放标记的时候如果又有区间覆盖的标记又有翻转的标记，这时候我们可以忽略翻转标记（因为你都是一个数了翻转没有意义），这样能优化不少常数。
## 求和
我们对于 Splay 的每一个节点，维护它及其它子树中所有节点代表的原序列中的元素的和。查询的时候提取区间直接输出就可以了。
## 求最大子列
我们考虑一种基于分治的求最大子列方法：对于每个区间都维护从左边开始的最大子列，从右边开始的最大子列和该区间的最大子列，分别记为 $ls,rs,ans$。

对于 ls 的维护：我们考虑从左边开始的最大子列是否覆盖了整个左儿子代表的区间，rs 同理。

对于 ans 就有多种可能了：全都在左儿子区间的，全都在右儿子区间的，跨过中间点的。

pushup 的时候分别维护即可，可以 $O(1)$ 维护。

于是这题的代码也就可以轻松写出来啦：
```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <map>
#include <set>

#define fi first
#define lc (ch[x][0])
#define se second
#define U unsigned
#define rc (ch[x][1])
#define Re register
#define LL long long
#define MP std::make_pair
#define CLR(i,a) memset(i,a,sizeof(i))
#define FOR(i,a,b) for(Re int i = a;i <= b;++i)
#define ROF(i,a,b) for(Re int i = a;i >= b;--i)
#define SFOR(i,a,b,c) for(Re int i = a;i <= b;i+=c)
#define SROF(i,a,b,c) for(Re int i = a;i >= b;i-=c)
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl

const int MAXN = 500000+5;

int f[MAXN],ch[MAXN][2],size[MAXN],val[MAXN],sum[MAXN],ls[MAXN],rs[MAXN],max[MAXN];
int rev[MAXN],tag[MAXN];

int a[MAXN],bin[MAXN],cnt,top,N,M;

inline void pushup(int x){
    size[x] = size[lc] + size[rc] + 1;
    sum[x] = sum[lc] + sum[rc] + val[x];
    max[x] = std::max(std::max(max[lc],max[rc]),rs[lc]+ls[rc]+val[x]);
    ls[x] = std::max(ls[lc],sum[lc]+val[x]+ls[rc]);
    rs[x] = std::max(rs[rc],sum[rc]+val[x]+rs[lc]);
}

inline void pushdown(int x){
    if(tag[x]){
        tag[x] = rev[x] = false;
        if(lc){
            tag[lc] = true;val[lc] = val[x];sum[lc] = val[x]*size[lc];
        }
        if(rc){
            tag[rc] = true;val[rc] = val[x];sum[rc] = val[x]*size[rc];
        }
        if(val[x] >= 0){
            if(lc) ls[lc] = rs[lc] = max[lc] = sum[lc];
            if(rc) ls[rc] = rs[rc] = max[rc] = sum[rc];
        }
        else{
            if(lc) ls[lc] = rs[lc] = 0,max[lc] = val[x];
            if(rc) ls[rc] = rs[rc] = 0,max[rc] = val[x];
        }
    }
    if(rev[x]){
        rev[x] = 0;rev[lc] ^= 1;rev[rc] ^= 1;
        std::swap(ls[lc],rs[lc]);std::swap(ls[rc],rs[rc]);
        std::swap(ch[lc][0],ch[lc][1]);std::swap(ch[rc][0],ch[rc][1]);
    }
}

inline void rotate(int x){
    int y = f[x],z = f[y],k = ch[y][1] == x,w = ch[x][!k];
    ch[z][ch[z][1] == y] = x;f[x] = z;
    ch[x][!k] = y;f[y] = x;
    ch[y][k] = w;f[w] = y;
    pushup(y);pushup(x);
}
int root;
inline void splay(int x,int v){
    int y,z;
    while((y = f[x]) != v){
        if((z = f[y]) != v) rotate((ch[z][1] == y)^(ch[y][1] == x) ? x : y);
        rotate(x);
    }
    if(!v) root = x;
}

int getkth(int rk){
    int x = root;
    while(233){
        pushdown(x);
        if(rk <= size[lc]) x = lc;
        else if(rk == size[lc]+1) return x;
        else rk -= size[lc]+1,x = rc;
    }
}

inline int build(int l,int r,int fa){
    if(l > r) return 0;
    int mid = (l + r) >> 1,x;
    x = top ? bin[top--] : ++cnt;
    f[x] = fa;val[x] = a[mid];
    rev[x] = tag[x] = 0;
    lc = build(l,mid-1,x);rc = build(mid+1,r,x);
    pushup(x);return x;
}

inline void insert(int l,int tot){
    int r = l+1;
    l = getkth(r);r = getkth(r+1);
    splay(l,0);splay(r,l);
    FOR(i,1,tot) scanf("%d",a+i);
    ch[r][0] = build(1,tot,r);
    N += tot;pushup(r);pushup(l);
}

inline void erase(int x){
    if(!x) return;
    bin[++top] = x;
    erase(lc);erase(rc);
}

inline void del(int l,int r){
    N -= r-l+1;
    l = getkth(l);r = getkth(r+2);
    splay(l,0);splay(r,l);
    erase(ch[r][0]);ch[r][0] = 0;
    pushup(r);pushup(l);
}

inline void modify(int l,int r,int v){
    l = getkth(l);r = getkth(r+2);
    splay(l,0);splay(r,l);
    int x = ch[r][0];
    val[x] = v;sum[x] = v*size[x];
    if(v <= 0) ls[x] = rs[x] = 0,max[x] = v;
    else ls[x] = rs[x] = max[x] = sum[x];
    tag[x] = 1;
    pushup(r);pushup(l);
}

inline void reverse(int l,int r){
    l = getkth(l);r = getkth(r+2);
    splay(l,0);splay(r,l);
    int x = ch[r][0];
    if(!tag[x]){
        rev[x] ^= 1;std::swap(lc,rc);std::swap(ls[x],rs[x]);
        pushup(r);pushup(l);
    }
}

inline int querysum(int l,int r){
    l = getkth(l);r = getkth(r+2);
    splay(l,0);splay(r,l);
    return sum[ch[r][0]];
}

inline int calc(){
    int l = getkth(1),r = getkth(N+2);
    splay(l,0);splay(r,l);
    return max[ch[r][0]];
}

int main(){
    scanf("%d%d",&N,&M);
    max[0] = a[1] = a[N+2] = INT_MIN;
    FOR(i,1,N) scanf("%d",a+i+1);
    root = build(1,N+2,0);
    while(M--){
        char opt[10];
        int x,y,z;
        scanf("%s",opt);
        if(opt[0] == 'I'){
            scanf("%d%d",&x,&y);
            insert(x,y);
        }
        if(opt[0] == 'D'){
            scanf("%d%d",&x,&y);
            del(x,x+y-1);
        }
        if(opt[0] == 'M' && opt[2] == 'K'){
            scanf("%d%d%d",&x,&y,&z);
            modify(x,x+y-1,z);
        }
        if(opt[0] == 'R'){
            scanf("%d%d",&x,&y);
            reverse(x,x+y-1);
        }
        if(opt[0] == 'G'){
            scanf("%d%d",&x,&y);
            printf("%d\n",querysum(x,x+y-1));
        }
        if(opt[0] == 'M' && opt[2] == 'X'){
            printf("%d\n",calc());
        }
    }
    return 0;
}
```
## 写在最后
至于我为什么不写听起来更简单的 fhq treap，因为我们机房里的人天天吹它，于是我就不想学了。。。可能以后接触到可持久化的时候才会学QAQ

---

## 作者：iodwad (赞：3)

[Welcome to my Blog](https://zcdhj.org)

一道毒瘤的数据结构题。。。

总共写了我一个下午+一个晚上

主要思路就是用 Splay 维护序列

这里有几个需要注意的地方

- 最大子串是不能为空的
- 如果有了区间 `set` 操作就不用再进行 `reverse` 操作了

我阵亡了。。。

希望这里的代码能帮助到指针党 qwq

```cpp
#include <iostream>
#include <cstdio>

const int MAXN = 500000;
const int INF = -1e5;

int n, m;
int a[MAXN + 3];

inline int read() {
    register int x = 0, v = 1;
    register char ch = getchar();
    while(!isdigit(ch)) {
        if(ch == '-') v = -1;
        ch = getchar();
    }
    while(isdigit(ch)) {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * v;
}

namespace Splay {
    struct Tree {
        struct Splay {
            int val, sumv, lmax, rmax, ansv, setv, size;
            bool rev;
            Splay *ch[2], *father;
            Splay() {}
            Splay(int _val, Splay *_father) : val(_val), sumv(_val), lmax(std::max(0, _val)), rmax(std::max(0, _val)), ansv(_val), setv(1e9), size(1), rev(0), father(_father) { ch[0] = ch[1] = NULL; }
        } *root;
        inline int sumv(Splay *o) { return o ? o -> sumv : 0; }
        inline int lmax(Splay *o) { return o ? o -> lmax : 0; }
        inline int rmax(Splay *o) { return o ? o -> rmax : 0; }
        inline int ansv(Splay *o) { return o ? o -> ansv : INF; }
        inline int size(Splay *o) { return o ? o -> size : 0; }
        inline void pushup(Splay *o) {
            Splay *ls = o -> ch[0], *rs = o -> ch[1];
            o -> sumv = sumv(ls) + o -> val + sumv(rs);
            o -> lmax = std::max(lmax(ls), sumv(ls) + o -> val + lmax(rs));
            o -> rmax = std::max(rmax(rs), sumv(rs) + o -> val + rmax(ls));
            o -> ansv = std::max(std::max(ansv(ls), ansv(rs)), rmax(ls) + o -> val + lmax(rs));
            o -> size = size(ls) + 1 + size(rs);        
        }
        inline void pushdown(Splay *o) {
            Splay *ls = o -> ch[0], *rs = o -> ch[1];
            if(o -> setv != 1e9) {
                if(ls) {
                    ls -> val = o -> setv;
                    ls -> sumv = size(o -> ch[0]) * o -> setv;
                    ls -> lmax = std::max(ls -> sumv, 0);
                    ls -> rmax = std::max(ls -> sumv, 0);
                    ls -> ansv = std::max(ls -> sumv, o -> setv);
                    ls -> setv = o -> setv;
                }
                if(rs) {
                    rs -> val = o -> setv;
                    rs -> sumv = size(o -> ch[1]) * o -> setv;
                    rs -> lmax = std::max(rs -> sumv, 0);
                    rs -> rmax = std::max(rs -> sumv, 0);
                    rs -> ansv = std::max(rs -> sumv, o -> setv);
                    rs -> setv = o -> setv;
                }
                o -> setv = 1e9;
                o -> rev = 0;
            } else if(o -> rev) {
                if(ls) {
                    std::swap(ls -> lmax, ls -> rmax);
                    ls -> rev ^= 1;
                }
                if(rs) {
                    std::swap(rs -> lmax, rs -> rmax);
                    rs -> rev ^= 1;
                }
                std::swap(o -> ch[0], o -> ch[1]);
                o -> rev = 0;
            }
        }
        inline int relation(Splay *o) { return o -> father ? o -> father -> ch[1] == o : 0; }
        inline void connect(Splay *x, Splay *y, int relation) {
            if(x) x -> father = y;
            if(y) y -> ch[relation] = x;
        }
        inline void rotate(Splay *o) {
            Splay *p = o -> father, *q = p -> father;
            int wson = relation(o);
            connect(o, q, relation(p));
            connect(o -> ch[wson ^ 1], p, wson);
            connect(p, o, wson ^ 1);
            pushup(p);
            pushup(o);
        }
        inline void splay(Splay *o, Splay *goal) {
            if(!o) return;
            while(o -> father != goal) {
                Splay *p = o -> father;
                if(p -> father != goal) relation(o) ^ relation(p) ? rotate(o) : rotate(p);
                rotate(o);
            }   
            if(!goal) root = o;
        }
        inline Splay *kth(int k) {
            Splay *o = root;
            while(1) {
                pushdown(o);
                if(size(o -> ch[0]) + 1 == k) return o;
                else if(size(o -> ch[0]) >= k) o = o -> ch[0];
                else {
                    k -= size(o -> ch[0]) + 1;
                    o = o -> ch[1];
                }
            }
            return NULL;
        }
        inline void build(Splay *&o, Splay *fa, int l, int r) {
            if(l > r) return;
            int mid = (l + r) >> 1;
            o = new Splay(a[mid], fa);
            build(o -> ch[0], o, l, mid - 1);
            build(o -> ch[1], o, mid + 1, r);
            pushup(o);
        }
        inline void remove(Splay *&o) {
            if(!o) return;
            remove(o -> ch[0]);
            remove(o -> ch[1]);
            delete o;
            o = NULL;
        }
        inline void out(Splay *o) {
            if(!o) return;
            pushdown(o);
            out(o -> ch[0]);
            if(o -> val != INF) printf("%d ", o -> val);
            out(o -> ch[1]);
        }
        inline void Insert() {
            int pos = read() + 1, tot = read();
            for(int i = 1; i <= tot; ++i) a[i] = read();    
            Splay *o1 = kth(pos), *o2 = kth(pos + 1);
            splay(o1, NULL);
            splay(o2, o1);
            Splay *ptr;
            build(ptr, NULL, 1, tot);
            connect(ptr, root -> ch[1], 0);
            pushup(root -> ch[1]);
            pushup(root);
        }
        inline void Delete() {
            int pos = read() + 1, tot = read();
            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);
            splay(o1, NULL);
            splay(o2, o1);
            remove(root -> ch[1] -> ch[0]);
            pushup(root -> ch[1]);
            pushup(root);
        }
        inline void makeSame() {
            int pos = read() + 1, tot = read(), val = read();
            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);
            splay(o1, NULL);
            splay(o2, o1);
            Splay *o = root -> ch[1] -> ch[0];
            o -> val = val;
            o -> sumv = size(o) * val;
            o -> lmax = std::max(o -> sumv, 0);
            o -> rmax = std::max(o -> sumv, 0);
            o -> ansv = std::max(o -> sumv, val);
            o -> setv = val;
            o -> rev = 0;
            pushup(root -> ch[1]);
            pushup(root);
        }
        inline void Reverse() {
           // puts("Rese");
            int pos = read() + 1, tot = read();
            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);
            splay(o1, NULL);
            splay(o2, o1);
            root -> ch[1] -> ch[0] -> rev = 1;
            pushdown(root -> ch[1] -> ch[0]);
            pushup(root -> ch[1] -> ch[0]);
            pushup(root -> ch[1]);
            pushup(root);
        }
        inline void getSum() {
            int pos = read() + 1, tot = read();
            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);
            splay(o1, NULL);
            splay(o2, o1);
            printf("%d\n", sumv(root -> ch[1] -> ch[0]));
        }
        inline void maxSum() {
            printf("%d\n", ansv(root));
        }
    } tree;
}

using namespace Splay;

int main() {
    // freopen("in.in", "r", stdin);
    n = read();
    m = read(); 
    a[1] = a[n + 2] = INF;
    for(int i = 1; i <= n; ++i) a[i + 1] = read();
    tree.build(tree.root, NULL, 1, n + 2);
    while(m--) {
        char opt[10];
        scanf("%s", opt);
        if(*opt == 'I') tree.Insert();
        else if(*opt == 'D') tree.Delete();
        else if(*opt == 'M' && opt[2] == 'K') tree.makeSame();
        else if(*opt == 'R') tree.Reverse();
        else if(*opt == 'G') tree.getSum();
        else if(*opt == 'O') tree.out(tree.root), putchar('\n');
        else tree.maxSum();
    }   
    return 0;
}
```



---

## 作者：Great_Influence (赞：3)

因为$leafytree$支持快速合并分裂，因此可以做与区间相关的几乎所有平衡树题。

这道题目基本上是一个平衡树区间操作裸题了。你只需要写一个提取区间即可完成除最后一个以外所有操作。

至于最后一个，你可以再额外维护前缀和后缀最大连续和，以及区间答案。然后在$pushup$中间上传即可。

具体操作:

### 1.内存管理:
这道题目的总点数极多，但是同时存在的点数不多。因此你需要写一个内存池管理内存。你只需要写几个申请内存和回收内存的函数即可。

代码部分:
```cpp

	inline int newnode()
	{
		laz[sta[tp]]=1111;
		return sta[tp--];
	}

	inline void del(int u)
	{
    sz[u]=sm[u]=pr[u]=sf[u]=ans[u]=ls(u)=rs(u)=fa[u]=0;
		rev[u]=laz[u]=0,sta[++tp]=u;
	}

	inline void dfdel(int h)//这个在后面的区间删除要用
	{
		if(ls(h))dfdel(ls(h)),dfdel(rs(h));
		del(h);
	}
```

### 2.合并分裂
这个与$FHQ$的差不多，但是需要同时维护平衡，因此有更多分类讨论。

你可以看[这篇](https://www.luogu.org/blog/user7035/solution-P3391-leafytree)。

代码部分:
```cpp
	int merge(int u,int v)
	{
		if(!u||!v)return u|v;
		if(sz[u]>=sz[v]&&sz[v]>=mlim*sz[u]
			||sz[u]<=sz[v]&&sz[u]>=mlim*sz[v])
		{
			register int cur=newnode();
			fa[ls(cur)=u]=fa[rs(cur)=v]=cur;
			pushup(cur);
			return cur;
		}
		if(sz[u]>=sz[v])
		{
			pushdown(u);
			int Ls=ls(u),Rs=rs(u);
			del(u);
			if(sz[Ls]>=alp*(sz[Ls]+sz[Rs]+sz[v]))
				return merge(Ls,merge(Rs,v));
			else
			{
				pushdown(Rs);
				int LS=ls(Rs),RS=rs(Rs);
				del(Rs);
				return merge(merge(Ls,LS),merge(RS,v));
			}
		}
		else
		{
			pushdown(v);
			int Ls=ls(v),Rs=rs(v);
			del(v);
			if(sz[Rs]>=alp*(sz[Ls]+sz[Rs]+sz[u]))
				return merge(merge(u,Ls),Rs);
			else
			{
				pushdown(Ls);
				int LS=ls(Ls),RS=rs(Ls);
				del(Ls);
				return merge(merge(u,LS),merge(RS,Rs));
			}
		}
	}
	typedef pair<int,int>PII;
#define fi first
#define se second

	PII split(int h,int x)
	{
		if(!h||!x)return mp(0,h);
		if(x==sz[h])return mp(h,0);
		PII y;
		pushdown(h);
		int Ls=ls(h),Rs=rs(h);
		del(h);
		if(x<=sz[Ls])
		{
			y=split(Ls,x);
			return mp(y.fi,merge(y.se,Rs));
		}
		else
		{
			y=split(Rs,x-sz[Ls]);
			return mp(merge(Ls,y.fi),y.se);
		}
	}
```

### 3.建树与插入

因为$leafytree$的形态与线段树相同，因此可以直接按照线段树建树的方法直接建出一棵完全平衡的树。

至于插入，直接将原树分成两部分，再将新建的树插入即可。

代码部分:
```cpp
	void make_tree(int&h,int l,int r,int*a)//利用a[]中的元素建树
	{
		h=newnode();
		if(l==r)
		{
			sz[h]=1;
			pr[h]=sf[h]=ans[h]=sm[h]=a[l];
			return;
		}
		int mid=(l+r)>>1;
		make_tree(son[h][0],l,mid,a);
		make_tree(son[h][1],mid+1,r,a);
		pushup(h);
	}

	inline void ins(int ps,int RT)
	{
		register PII y=split(rt,ps);
		rt=merge(y.fi,merge(RT,y.se));
	}
```

### 4.提取区间

这个简单。直接将整棵树分裂成几部分就可以了。为了方便，我把它单独写成了一个函数，分成的$3$棵树存在$nd$内。

代码部分:
```cpp
	static int nd[3];

	inline void getseg(int l,int r)
	{
		register PII y=split(rt,l-1),z=split(y.se,r-l+1);
		nd[0]=y.fi,nd[1]=z.fi,nd[2]=z.se;
	}
```

### 5.所有其余区间操作

利用上面的提取区间提取区间后，直接对中间的树打上标记，然后再合并。

区间翻转为了保证正确性，应该先翻转一层，再打上标记。

代码部分:
```cpp
	inline void sakuzyo(int l,int len)//删除
	{
		getseg(l,l+len-1);
		dfdel(nd[1]);
		rt=merge(nd[0],nd[2]);
	}

	inline void modify(int l,int len,int x)//区间修改
	{
		getseg(l,l+len-1);
		laz[nd[1]]=x;
		pr[nd[1]]=sf[nd[1]]=ans[nd[1]]
			=max(sm[nd[1]]=sz[nd[1]]*laz[nd[1]],x);
		rt=merge(nd[0],merge(nd[1],nd[2]));
	}

	inline void reverse(int l,int len)//区间翻转
	{
		getseg(l,l+len-1);
		if(ls(nd[1]))
		{
			swap(pr[nd[1]],sf[nd[1]]);
			swap(ls(nd[1]),rs(nd[1]));
			rev[nd[1]]^=1;
		}
		rt=merge(nd[0],merge(nd[1],nd[2]));
	}

	inline int getsm(int l,int len)//区间求和
	{
		static int as;
		getseg(l,l+len-1);
		as=sm[nd[1]];
		rt=merge(nd[0],merge(nd[1],nd[2]));
		return as;
	}
```

### 6.最大子段和

在维护大小和区间和以外，我们再额外维护区间最大非空前缀和区间最大飞空后缀以及区间最大非空子段和。然后这个东西就可以直接动态利用平衡树进行维护了。

代码部分:
```cpp
	inline void pushup(int h)
	{
		if(ls(h))
		{
			sz[h]=sz[ls(h)]+sz[rs(h)];
			sm[h]=sm[ls(h)]+sm[rs(h)];
			ans[h]=max(max(ans[ls(h)],ans[rs(h)]),sf[ls(h)]+pr[rs(h)]);
			pr[h]=max(sm[ls(h)]+pr[rs(h)],pr[ls(h)]);
			sf[h]=max(sm[rs(h)]+sf[ls(h)],sf[rs(h)]);
		}
	}
```

### 7.小细节
记得及时回收内存，然后标记维护时注意一些细节。

代码部分:
```cpp
	inline void pushdown(int h)
	{
		if(ls(h))
		{
			if(laz[h]<=1000)
			{
				pr[ls(h)]=sf[ls(h)]=ans[ls(h)]
					=max(sm[ls(h)]=sz[ls(h)]*laz[h],laz[h]);
				pr[rs(h)]=sf[rs(h)]=ans[rs(h)]
					=max(sm[rs(h)]=sz[rs(h)]*laz[h],laz[h]);
				laz[ls(h)]=laz[rs(h)]=laz[h];
				laz[h]=1111;
			}
			if(rev[h])
			{
				if(ls(ls(h)))
				{
					swap(ls(ls(h)),rs(ls(h)));
					swap(pr[ls(h)],sf[ls(h)]);
					rev[ls(h)]^=1;
				}
				if(ls(rs(h)))
				{
					swap(ls(rs(h)),rs(rs(h)));
					swap(pr[rs(h)],sf[rs(h)]);
					rev[rs(h)]^=1;
				}
				rev[h]=0;
			}
		}
	}
```

总代码:
```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define eb emplace_back
#define ef emplace_front
#define ob pop_back
#define of pop_front
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;

using namespace std;
using namespace __gnu_pbds;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
    {
        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
    }
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
    {
        x=0;static char ch;T f=1;
        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
        x*=f;
    }

    template<typename T>inline void write(T x,char ch='\n')
    {
        if(!x)*nowps++='0';
        if(x<0)*nowps++='-',x=-x;
        static uint32 sta[111],tp;
        for(tp=0;x;x/=10)sta[++tp]=x%10;
        for(;tp;*nowps++=sta[tp--]^48);
        *nowps++=ch;
    }
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
    FILE*DSA=freopen("leafytree2.in","r",stdin);
    FILE*SDU=freopen("leafytree2.out","w",stdout);
#endif
}

const int MAXN=1e6+7;

namespace BST
{
	const double alp=1-sqrt(2)/2,lim=(1-2*alp)/(1-alp),mlim=alp/(1-alp);

	static int rt,son[MAXN][2],fa[MAXN],sz[MAXN],sta[MAXN],tp;
	static int sm[MAXN],pr[MAXN],sf[MAXN],ans[MAXN],rev[MAXN],laz[MAXN];

#define ls(u) son[u][0]
#define rs(u) son[u][1]

	inline int newnode()
	{
		laz[sta[tp]]=1111;
		return sta[tp--];
	}

	inline void del(int u)
	{
		sz[u]=sm[u]=pr[u]=sf[u]=ans[u]=ls(u)=rs(u)=fa[u]=0;
		rev[u]=laz[u]=0,sta[++tp]=u;
	}

	inline void pushup(int h)
	{
		if(ls(h))
		{
			sz[h]=sz[ls(h)]+sz[rs(h)];
			sm[h]=sm[ls(h)]+sm[rs(h)];
			ans[h]=max(max(ans[ls(h)],ans[rs(h)]),sf[ls(h)]+pr[rs(h)]);
			pr[h]=max(sm[ls(h)]+pr[rs(h)],pr[ls(h)]);
			sf[h]=max(sm[rs(h)]+sf[ls(h)],sf[rs(h)]);
		}
	}

	inline void pushdown(int h)
	{
		if(ls(h))
		{
			if(laz[h]<=1000)
			{
				pr[ls(h)]=sf[ls(h)]=ans[ls(h)]
					=max(sm[ls(h)]=sz[ls(h)]*laz[h],laz[h]);
				pr[rs(h)]=sf[rs(h)]=ans[rs(h)]
					=max(sm[rs(h)]=sz[rs(h)]*laz[h],laz[h]);
				laz[ls(h)]=laz[rs(h)]=laz[h];
				laz[h]=1111;
			}
			if(rev[h])
			{
				if(ls(ls(h)))
				{
					swap(ls(ls(h)),rs(ls(h)));
					swap(pr[ls(h)],sf[ls(h)]);
					rev[ls(h)]^=1;
				}
				if(ls(rs(h)))
				{
					swap(ls(rs(h)),rs(rs(h)));
					swap(pr[rs(h)],sf[rs(h)]);
					rev[rs(h)]^=1;
				}
				rev[h]=0;
			}
		}
	}

	void make_tree(int&h,int l,int r,int*a)
	{
		h=newnode();
		if(l==r)
		{
			sz[h]=1;
			pr[h]=sf[h]=ans[h]=sm[h]=a[l];
			return;
		}
		int mid=(l+r)>>1;
		make_tree(son[h][0],l,mid,a);
		make_tree(son[h][1],mid+1,r,a);
		pushup(h);
	}

	int merge(int u,int v)
	{
		if(!u||!v)return u|v;
		if(sz[u]>=sz[v]&&sz[v]>=mlim*sz[u]
			||sz[u]<=sz[v]&&sz[u]>=mlim*sz[v])
		{
			register int cur=newnode();
			fa[ls(cur)=u]=fa[rs(cur)=v]=cur;
			pushup(cur);
			return cur;
		}
		if(sz[u]>=sz[v])
		{
			pushdown(u);
			int Ls=ls(u),Rs=rs(u);
			del(u);
			if(sz[Ls]>=alp*(sz[Ls]+sz[Rs]+sz[v]))
				return merge(Ls,merge(Rs,v));
			else
			{
				pushdown(Rs);
				int LS=ls(Rs),RS=rs(Rs);
				del(Rs);
				return merge(merge(Ls,LS),merge(RS,v));
			}
		}
		else
		{
			pushdown(v);
			int Ls=ls(v),Rs=rs(v);
			del(v);
			if(sz[Rs]>=alp*(sz[Ls]+sz[Rs]+sz[u]))
				return merge(merge(u,Ls),Rs);
			else
			{
				pushdown(Ls);
				int LS=ls(Ls),RS=rs(Ls);
				del(Ls);
				return merge(merge(u,LS),merge(RS,Rs));
			}
		}
	}
	typedef pair<int,int>PII;
#define fi first
#define se second

	PII split(int h,int x)
	{
		if(!h||!x)return mp(0,h);
		if(x==sz[h])return mp(h,0);
		PII y;
		pushdown(h);
		int Ls=ls(h),Rs=rs(h);
		del(h);
		if(x<=sz[Ls])
		{
			y=split(Ls,x);
			return mp(y.fi,merge(y.se,Rs));
		}
		else
		{
			y=split(Rs,x-sz[Ls]);
			return mp(merge(Ls,y.fi),y.se);
		}
	}

	static int nd[3];

	inline void ins(int ps,int RT)
	{
		register PII y=split(rt,ps);
		rt=merge(y.fi,merge(RT,y.se));
	}
	
	inline void getseg(int l,int r)
	{
		register PII y=split(rt,l-1),z=split(y.se,r-l+1);
		nd[0]=y.fi,nd[1]=z.fi,nd[2]=z.se;
	}

	inline void dfdel(int h)
	{
		if(ls(h))dfdel(ls(h)),dfdel(rs(h));
		del(h);
	}

	inline void sakuzyo(int l,int len)
	{
		getseg(l,l+len-1);
		dfdel(nd[1]);
		rt=merge(nd[0],nd[2]);
	}

	inline void modify(int l,int len,int x)
	{
		getseg(l,l+len-1);
		laz[nd[1]]=x;
		pr[nd[1]]=sf[nd[1]]=ans[nd[1]]
			=max(sm[nd[1]]=sz[nd[1]]*laz[nd[1]],x);
		rt=merge(nd[0],merge(nd[1],nd[2]));
	}

	inline void reverse(int l,int len)
	{
		getseg(l,l+len-1);
		if(ls(nd[1]))
		{
			swap(pr[nd[1]],sf[nd[1]]);
			swap(ls(nd[1]),rs(nd[1]));
			rev[nd[1]]^=1;
		}
		rt=merge(nd[0],merge(nd[1],nd[2]));
	}

	inline int getsm(int l,int len)
	{
		static int as;
		getseg(l,l+len-1);
		as=sm[nd[1]];
		rt=merge(nd[0],merge(nd[1],nd[2]));
		return as;
	}
}
using namespace BST;

static int n,m,a[MAXN];

inline void getstr(char*q)
{
	register char ch;
	for(ch=getc();!isgraph(ch);ch=getc());
	for(;isgraph(ch);ch=getc())*q++=ch;
	*q='\0';
}

const int MXNODE=1e6;

void init()
{
	read(n),read(m);
	Rep(i,1,MXNODE)sta[++tp]=MXNODE-i+1;
	Rep(i,1,n)read(a[i]);
	make_tree(rt,1,n,a);
}

static int RT;

static char s[111];

inline void solve()
{
	static int tot,ps,x;
	Rep(i,1,m)
	{
		getstr(s+1);
		if(s[1]=='I')
		{
			read(ps),read(tot);
			Rep(j,1,tot)read(a[j]);
			make_tree(RT,1,tot,a);
			ins(ps,RT);
		}
		else if(s[1]=='D')
		{
			read(ps),read(tot);
			sakuzyo(ps,tot);
		}
		else if(s[1]=='M')
		{
			if(s[3]=='K')
			{
				read(ps),read(tot),read(x);
				modify(ps,tot,x);
			}
			else write(ans[rt]);
		}
		else if(s[1]=='R')
		{
			read(ps),read(tot);
			reverse(ps,tot);
		}
		else if(s[1]=='G')
		{
			read(ps),read(tot);
			write(getsm(ps,tot));
		}
		if(i%100000==0)flush();
	}flush();
}

int main()
{
	file();
    init();
    solve();
    return 0;
}
```

---

## 作者：不存在之人 (赞：3)

分析

这种带翻转、插入、删除操作的维护序列的问题，很容易想到splay

用splay维护区间[l,r]的以下几个数： 
sum（表示区间和） 
ls（表示以l为左端的子列的和的最大值） 
rs（表示以r为右端的子列的和的最大值） 
ms（表示此区间所有子列的和的最大值）

然后看每个操作：

插入、删除和一般没什么区别，先选取区间，然后操作。

make_same：选取区间，然后打个标记。

翻转：同样是打标记。下传时，把对应区间的ls和rs交换，其它不变（因为翻转后，维护的ls,rs,ms,sum对应的是该区间从右到左遍历出来的数列，其中总和、ms是不会变的，ls,rs也只是换到了另一边）

求和：也是和一般的没什么区别。

求和最大的子列：当在splay旋转时进行update(x)操作时，我们把节点son[x][0],x,son[x][1] 分别看成一个区间，先合并son[x][0]和x，再与son[x][1]合并。注意：要把区间[1..n]（n为当前序列数的个数）选取出来再输出（或者把维护序列时前后加的数赋值为一个很小的数），否则会影响答案。

空间

开4000000的数组会爆空间，但是题目限制的每一时刻数的数量最多为500000，那么可以回收删除操作后多出的空间。具体是用一个栈来存当前可用的空间，插入时从栈顶弹出，删除时加入栈。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn=500010,Null=500002;
int m,n,root,top,son[maxn][2],fa[maxn],mask[maxn],sum[maxn],size[maxn],ls[maxn],rs[maxn],ms[maxn],a[maxn],st[maxn],A[maxn],data[maxn];
bool flip[maxn],bz;
char c;
int read()
{
    int x=bz=0;
    for (c=getchar();(c<'0' || c>'9') && c!='-';c=getchar());
    if (c=='-')
    {
        bz=1; c=getchar();
    }
    for (;c>='0' && c<='9';c=getchar()) x=x*10+c-48;
    if (bz) x=-x;
    return x;
}
void make_same(int x,int y)
{
    a[x]=mask[x]=y; sum[x]=y*size[x];
    if (y>0) ls[x]=rs[x]=ms[x]=sum[x];//子列不能为空
    else ls[x]=rs[x]=ms[x]=y;
}
void push_down(int x)//下传标记
{
    if (flip[x])
    {
        son[x][0]^=son[x][1]^=son[x][0]^=son[x][1];
        flip[son[x][0]]^=1; flip[son[x][1]]^=1;
        ls[son[x][0]]^=rs[son[x][0]]^=ls[son[x][0]]^=rs[son[x][0]];
        ls[son[x][1]]^=rs[son[x][1]]^=ls[son[x][1]]^=rs[son[x][1]];
        flip[x]=0;
    }
    if (mask[x]!=Null)
    {
        if (son[x][0]!=Null) make_same(son[x][0],mask[x]);
        if (son[x][1]!=Null) make_same(son[x][1],mask[x]);
        mask[x]=Null;
    }
}
void calc(int ll,int lr,int lm,int ls,int rl,int rr,int rm,int rs,int &l,int &r,int &m)
{
    l=max(ll,ls+rl);
    r=max(rr,rs+lr);
    m=max(max(lm,rm),lr+rl);
}//合并两个区间的ls,rs,ms
void update(int x)
{
    if (son[x][0]==Null)
    {
        if (son[x][1]==Null)
        {
            ls[x]=rs[x]=ms[x]=a[x];
        }else calc(a[x],a[x],a[x],a[x],ls[son[x][1]],rs[son[x][1]],ms[son[x][1]],sum[son[x][1]],ls[x],rs[x],ms[x]);
    }else
    {
        if (son[x][1]==Null)
        calc(ls[son[x][0]],rs[son[x][0]],ms[son[x][0]],sum[son[x][0]],a[x],a[x],a[x],a[x],ls[x],rs[x],ms[x]);
        else
        {
            calc(ls[son[x][0]],rs[son[x][0]],ms[son[x][0]],sum[son[x][0]],a[x],a[x],a[x],a[x],ls[x],rs[x],ms[x]);
            calc(ls[x],rs[x],ms[x],sum[son[x][0]]+a[x],ls[son[x][1]],rs[son[x][1]],ms[son[x][1]],sum[son[x][1]],ls[x],rs[x],ms[x]);
        }
    }
    sum[x]=sum[son[x][0]]+sum[son[x][1]]+a[x];
    size[x]=size[son[x][0]]+size[son[x][1]]+1;
}
void Rotate(int x,int t)
{
    int y=fa[x];
    if (y!=root)
    {
        if (son[fa[y]][0]==y) son[fa[y]][0]=x;else son[fa[y]][1]=x;
    }else root=x;
    fa[x]=fa[y]; fa[y]=x; son[y][t]=son[x][1-t]; son[x][1-t]=y; if (son[y][t]!=Null) fa[son[y][t]]=y;
    update(y);
}
void splay(int x,int f)
{
    while (fa[x]!=f)
    {
        int y=fa[x];
        if (fa[y]==f)
        {
            push_down(y); push_down(x);
            if (son[y][0]==x) Rotate(x,0); else Rotate(x,1);
        }else
        {
            int z=fa[y];
            push_down(z); push_down(y); push_down(x);
            if (son[y][0]==x)
            {
                if (son[z][0]==y)
                {
                    Rotate(y,0); Rotate(x,0);
                }else
                {
                    Rotate(x,0); Rotate(x,1);
                }
            }else
            {
                if (son[z][0]==y)
                {
                    Rotate(x,1); Rotate(x,0);
                }else
                {
                    Rotate(y,1); Rotate(x,1);
                }
            }
        }
    }
    update(x);
}
void Select(int x,int f)
{
    int i=root;
    while (size[son[i][0]]!=x)
    {
        if (size[son[i][0]]>x) i=son[i][0];
        else
        {
            x-=size[son[i][0]]+1; i=son[i][1];
        }
        push_down(i);
    }
    splay(i,f);
}
void Delete(int x,int t)
{
    int tot=1; data[1]=son[x][t];
    for (int i=1;i<=tot;i++)
    {
        st[++top]=data[i];//回收
        if (son[data[i]][0]!=Null) data[++tot]=son[data[i]][0];
        if (son[data[i]][1]!=Null) data[++tot]=son[data[i]][1];
    }
    son[x][t]=Null;
    splay(x,Null);
}
void build(int l,int r,int &root)
{
    int mid=(l+r)/2;
    a[root=st[top--]]=A[mid];//在栈顶得到它的编号
    if (l<mid)
    {
        build(l,mid-1,son[root][0]);
        fa[son[root][0]]=root;
    }else son[root][0]=Null;
    if (mid<r)
    {
        build(mid+1,r,son[root][1]);
        fa[son[root][1]]=root;
    }else son[root][1]=Null;
    update(root); mask[root]=Null; flip[root]=0;
}
int main()
{
    n=read(); m=read();
    for (int i=Null-1;i>=0;i--) st[++top]=i;
    for (int i=1;i<=n;i++) A[i]=read();
    build(0,n+1,root); fa[root]=Null;
    while (m--)
    {
        for (c=getchar();c<'A' || c>'R';c=getchar());
        if (c=='G')
        {
            for (c=getchar();c!='-';c=getchar());
            int l=read(),tot=read(),r=l+tot;
            Select(l-1,Null); Select(r,root);
            printf("%d\n",sum[son[son[root][1]][0]]);
        }else if (c=='I')
        {
            int x=read(),tot=read(); n+=tot;
            for (int i=1;i<=tot;i++) A[i]=read();
            Select(x,Null); Select(x+1,root);
            build(1,tot,son[son[root][1]][0]); fa[son[son[root][1]][0]]=son[root][1];
            splay(son[son[root][1]][0],Null);
        }else if (c=='D')
        {
            int l=read(),tot=read(),r=l+tot; n-=tot;
            Select(l-1,Null); Select(r,root);
            Delete(son[root][1],0);
        }else if (c=='R')
        {
            int l=read(),tot=read(),r=l+tot;
            Select(l-1,Null); Select(r,root);
            int t=son[son[root][1]][0];
            flip[t]^=1;
            ls[t]^=rs[t]^=ls[t]^=rs[t];
            splay(t,Null);
        }else
        {
            c=getchar(); c=getchar();
            if (c=='K')
            {
                for (c=getchar();c!='-';c=getchar());
                int l=read(),tot=read(),r=l+tot,C=read();
                Select(l-1,Null); Select(r,root);
                make_same(son[son[root][1]][0],C);
                splay(son[son[root][1]][0],Null);
            }else
            {
                for (c=getchar();c!='-';c=getchar());
                for (c=getchar();c>='A' && c<='Z';c=getchar());
                Select(0,Null); Select(n+1,root);//
                printf("%d\n",ms[son[son[root][1]][0]]);
            }
        }
    }
    return 0;
}
```

---

## 作者：KobeBeanBryantCox (赞：2)

# P2042 [NOI2005] 维护数列 题解

---------------

[题目传送门](https://www.luogu.com.cn/problem/P2042)。

# 块状链表！！！

虽然是块状链表但是比大多数平衡树都跑得快！

-------------

## 题意

略。

-------------

## 思路

首先我们想到了平衡树。

但是~~为了显得与众不同一点~~，我偏偏就要用块状链表。

首先块状链表的常规操作读者们在[这里](https://blog.csdn.net/qq_30115697/article/details/90046629)看吧，我参考了这里的写法（这篇文章不是我写的，侵权请联系删除）。

考虑剩下几个操作。

首先根据[这个题](https://www.luogu.com.cn/problem/SP1716)类似的操作，每个块要记录 $\texttt{sum,lis,llis,rlis}$，表示块和、LIS、从左往右的 LIS 和从右往左的 LIS。

分裂和合并的时候需要对块暴力重新计算上述东西，复杂度正确是因为我们一次修改只会至多两次分裂和合并。

然后要给每一个块打上 $\texttt{rev}$ 和 $\texttt{cov}$ 标记，下传的时候规定 $\texttt{cov}$ 优先级高。

考虑翻转。

把散块分裂成两个，然后就变成全部都是整块了。

整块打翻转标记，并且颠倒顺序即可。

考虑求 LIS（这里我们假装查询的是区间 LIS）。

同样的把散块分裂成两个，然后就变成全部都是整块了。

然后不是很好描述，看代码吧（其中所有整块的编号保存在 $vec$ 中，$ans$ 即为答案）：

```cpp
int ans=a[vec[0]].lis,maxx=a[vec[0]].rlis;
for(int i=1;i<vec.size();i++)
{
	ans=max(ans,max(a[vec[i]].lis,maxx+a[vec[i]].llis));
	maxx=max(maxx+a[vec[i]].sum,a[vec[i]].rlis);
}
return ans;
```

求和和查询区间和就是整块加，散块暴力即可，不需要分裂块。

然后注意特判每一个操作，在同一个块内的情况，暴力修改即可。

块的大小取 $B=\sqrt n$，时间复杂度大约是 $O(n\sqrt n)$，常数比平衡树小得多。

------------

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=5e5+10,B=707;
struct block_list
{
	struct node
	{
		int siz,nex;int s[B<<2];
		int sum,lis,llis,rlis;
		int rev,cov;
		node(){cov=1e9;} // 注意不能设成 0
	}a[B<<2];
	int bin[N],tot;
	int newnode(){return bin[tot--];}
	void del(int x)
	{
		bin[++tot]=x;
		a[x].siz=a[x].sum=a[x].lis=a[x].llis=a[x].rlis=0,a[x].nex=-1;
		a[x].rev=0,a[x].cov=1e9;
	}
	block_list()
	{
		for(int i=1;i<N;i++)bin[++tot]=N-i;
		a[0].nex=-1;
	}
	int pos(int &p)
	{
		int x=0;
		for(;x!=-1&&a[x].siz<p;x=a[x].nex)p-=a[x].siz;
		return x;
	}
	void pushdown(int x)
	{
		if(a[x].cov!=1e9)
		{
			for(int i=0;i<a[x].siz;i++)a[x].s[i]=a[x].cov;
			a[x].cov=1e9,a[x].rev=0;
			return;
		}
		if(!a[x].rev)return;
		for(int i=0,j=a[x].siz-1;i<j;i++,j--)swap(a[x].s[i],a[x].s[j]);
		a[x].rev=0;
	}
	void pushup(int x)
	{
		a[x].sum=a[x].lis=a[x].llis=a[x].rlis=0;
		int n=a[x].siz;
		if(n==0)return; // 下面是暴力计算
		for(int i=0;i<n;i++)a[x].sum+=a[x].s[i];
		a[x].llis=a[x].s[0];
		for(int i=1,ss=a[x].s[0]+a[x].s[1];i<n;i++,ss+=a[x].s[i])a[x].llis=max(a[x].llis,ss);
		a[x].rlis=a[x].s[n-1];
		for(int i=n-2,ss=a[x].s[n-1]+a[x].s[n-2];i>=0;i--,ss+=a[x].s[i])a[x].rlis=max(a[x].rlis,ss);
		a[x].lis=a[x].s[0];
		for(int i=1,ss=a[x].s[0];i<n;i++)ss=max(ss,0)+a[x].s[i],a[x].lis=max(a[x].lis,ss);
	}
	void add(int x,int y,int len,int *s)
	{
		if(y!=-1)
		{
			pushdown(y);
			a[y].siz=len,a[y].nex=a[x].nex;
			memcpy(a[y].s,s,len*sizeof(int));
			pushup(y);
		}
		a[x].nex=y;
	}
	void merge(int x,int y)
	{
		pushdown(x),pushdown(y);
		memcpy(a[x].s+a[x].siz,a[y].s,a[y].siz*sizeof(int));
		a[x].siz+=a[y].siz,a[x].nex=a[y].nex,pushup(x),del(y);
	}
	void split(int x,int pos)
	{
		if(x==-1||pos==a[x].siz)return;
		int t=newnode();
		pushdown(x);
		add(x,t,a[x].siz-pos,a[x].s+pos);
		a[x].siz=pos,pushup(x);
	}
	void insert(int x,int len,int *s)
	{
		if(len==0)return;
		int now=pos(x),nex=now,tot=0,t=-1;
		split(now,x);
		for(;tot+B<=len;tot+=B)
		{
			t=newnode();
			add(nex,t,B,s+tot);
			nex=t;
		}
		if(tot<len)t=newnode(),add(nex,t,len-tot,s+tot);
		if(nex!=0&&t!=-1&&a[nex].siz+a[t].siz<=B)merge(nex,t);
		if(t!=-1&&a[t].nex!=-1&&a[t].siz+a[a[t].nex].siz<=B)merge(t,a[t].nex);
		if(now!=0&&a[now].nex!=-1&&a[now].siz+a[a[now].nex].siz<=B)merge(now,a[now].nex);
	}
	void erase(int x,int len)
	{
		if(len==0)return;
		int now=pos(x);split(now,x-1);
		int nex=a[now].nex;len--;
		for(;nex!=-1&&len>=a[nex].siz;nex=a[nex].nex)len-=a[nex].siz;
		if(nex!=-1)split(nex,len+1),nex=a[nex].nex;
		for(int i=a[now].nex;i!=nex;i=a[now].nex)a[now].nex=a[i].nex,del(i);
		for(;nex!=-1&&a[now].siz+a[nex].siz<=B;nex=a[nex].nex)merge(now,nex);
	}
	void modify(int p1,int len,int v)
	{
		if(len==0)return;
		int p2=p1+len-1;
		int bl=pos(p1),br=pos(p2);
		if(bl==br)
		{
			pushdown(bl);
			for(int i=p1-1;i<p2;i++)a[bl].s[i]=v;
			pushup(bl);return;
		}
		for(int i=a[bl].nex;i!=br;i=a[i].nex)
		{
			a[i].cov=v;
			a[i].sum=v*a[i].siz;
			if(v<0)a[i].lis=a[i].llis=a[i].rlis=v;
			else a[i].lis=a[i].llis=a[i].rlis=a[i].sum;
		}
		pushdown(bl),pushdown(br);
		for(p1--;p1<a[bl].siz;p1++)a[bl].s[p1]=v;
		for(p2--;p2>=0;p2--)a[br].s[p2]=v;
		pushup(bl),pushup(br);
	}
	void reverse(int p1,int len)
	{
		if(len==0)return;
		int p2=p1+len-1;
		int bl=pos(p1),br=pos(p2);
		if(bl==br)
		{
			pushdown(bl);
			for(int i=p1-1,j=p2-1;i<j;i++,j--)swap(a[bl].s[i],a[bl].s[j]);
			pushup(bl);return;
		}
		split(bl,p1-1),split(br,p2);
		int nowl=a[bl].nex,nowr=br;br=a[br].nex;
		vector<int>vec;
		a[bl].nex=-1;
		for(int i=nowl;i!=br;)
		{
			a[i].rev^=1;
			swap(a[i].llis,a[i].rlis);
			vec.push_back(i);
			int t=a[i].nex;
			a[i].nex=-1,i=t;
		}
		for(int i=bl,j=vec.size()-1;j>=0;i=a[i].nex,j--)a[i].nex=vec[j];
		a[vec[0]].nex=br;
		if(a[bl].siz+a[a[bl].nex].siz<=B)merge(bl,a[bl].nex);
		if(!vec.empty()&&br!=-1&&a[vec[0]].siz+a[br].siz<=B)merge(vec[0],br);
	}
	int querysum(int p1,int len)
	{
		if(len==0)return 0;
		int p2=p1+len-1,ans=0;
		int bl=pos(p1),br=pos(p2);
		if(bl==br)
		{
			pushdown(bl);
			for(int i=p1-1;i<p2;i++)ans+=a[bl].s[i];
			return ans;
		}
		for(int i=a[bl].nex;i!=br;i=a[i].nex)ans+=a[i].sum;
		pushdown(bl),pushdown(br);
		for(p1--;p1<a[bl].siz;p1++)ans+=a[bl].s[p1];
		for(p2--;p2>=0;p2--)ans+=a[br].s[p2];
		return ans;
	}
	int querylis() // 这里我就没有写成区间的形式了
	{
		vector<int>vec;
		for(int i=a[0].nex;i!=-1;i=a[i].nex)vec.push_back(i);
		if(vec.empty())return 0;
		if(vec.size()==1)return a[vec[0]].lis;
		int ans=a[vec[0]].lis,maxx=a[vec[0]].rlis;
		for(int i=1;i<vec.size();i++)
		{
			ans=max(ans,max(a[vec[i]].lis,maxx+a[vec[i]].llis));
			maxx=max(maxx+a[vec[i]].sum,a[vec[i]].rlis);
		}
		return ans;
	}
}seq;
int tmp[N];
int main()
{
	int n=in(),m=in();
	for(int i=0;i<n;i++)tmp[i]=in();
	seq.insert(0,n,tmp);
	while(m--)
	{
		string s="";char c=getchar();
		while(!isalpha(c))c=getchar();
		while(isalpha(c)||c=='-')s.push_back(c),c=getchar();
		int pos=0,tot=0;
		if(s!="MAX-SUM")pos=in(),tot=in();
		if(s=="INSERT")
		{
			for(int i=0;i<tot;i++)tmp[i]=in();
			seq.insert(pos,tot,tmp);
		}
		else if(s=="DELETE")seq.erase(pos,tot);
		else if(s=="MAKE-SAME")seq.modify(pos,tot,in());
		else if(s=="REVERSE")seq.reverse(pos,tot);
		else if(s=="GET-SUM")out(seq.querysum(pos,tot)),putchar('\n');
		else out(seq.querylis()),putchar('\n');
	}
	return 0;
}
```

挺[难调](https://www.luogu.com.cn/record/list?pid=P2042&user=865625)的，细节超多，放一个有调试信息的[版本](https://www.luogu.com.cn/record/207210064)。

有个[双倍经验](https://www.luogu.com.cn/article/7h372xv6)，也差不多。

--------------

如果有错误或者不清楚欢迎评论或私信指出。

---

## 作者：C20203030 (赞：2)

## 一、题目

[点此看题](https://www.luogu.com.cn/problem/P2042)

## 二、解法

写一发无旋$\text{treap}$的题解吧，我重构了足足三遍，讲一下所有坑点。

如果你对$\text{treap}$不是很了解，可以看[这个](https://blog.csdn.net/C202044zxy/article/details/103244047)。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191130142557256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0MyMDIwNDR6eHk=,size_16,color_FFFFFF,t_70)

**操作1 insert**

- 这道题不能$O(n\log n)$无脑插入，要考虑$O(n)$建树，我们维护一个$heap$递增的单调栈，每次加入一个点弹出比它$heap$大的，最后一个被弹出的点是他的左儿子，他是弹栈后的栈顶的右儿子，修改儿子后再跑一边整棵树，我们最开始是建一个$heap$最小的超级根，真正的根是超级根的右儿子，插入的话我们就把建出来的树与原来的树合并。
- 还有一个问题就是空间开不下，由于数列的长度是限定的，可以写一个内存池，动态拿空间。

**操作2 delete**

- 把删除的区间分裂出来，然后合并。

**操作3 modify**

- 把区间拆出来打懒标记，注意他有可能让你区间赋$0$，所以要用$inf$当没有标记时赋的值。

**操作4 reverse**

- 以后要维护一个区间最大字段和，翻转时只有左边开始的最大子段和右边开始的最大子段会受影响，应该交换左边开始和右边开始。

**操作5 get-sum**

- 把要求的区间拆出来，然后输出$\text{sum}$即可。

**操作6 最大子段和**

- 维护一个左起最大子段，右起最大子段，区间最大子段，讲一讲更新区间最大子段吧，区间最大子段可以从三个地方转移：左儿子最大子段，右儿子最大子段，中间值+左儿子右起最大子段+右儿子左起最大子段，仔细想想这种更新方法可以涵盖所有情况。
- 子段不能为空，所以最大子段有时需要为负，需要判断为负是选不选。

那我就放个代码吧，可以看看加深理解。

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#define inf 0x3f3f3f3f
using namespace std;
const int MAXN = 500005;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,m,rt,top;char str[20];
int ch[MAXN][2],siz[MAXN],hp[MAXN],fl[MAXN],q[MAXN];
int sum[MAXN],val[MAXN],ml[MAXN],mr[MAXN],mx[MAXN],la[MAXN];
struct Memory_Pool
{
	int top,p[MAXN];
	Memory_Pool()
	{
		top=MAXN-1;
		for(int i=1;i<=top;i++)
			p[i]=i;
	}
	int New() {return p[top--];}
	void Rec(int x) {p[++top]=x;} 
}M;//内存池
struct node
{
	int p[2];
	node() {p[0]=p[1]=0;}
}emp;//两个根的结构体
void up(int x)
{
	siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
	sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];
	ml[x]=max(ml[ch[x][0]],sum[ch[x][0]]+val[x]+max(0,ml[ch[x][1]]));
	mr[x]=max(mr[ch[x][1]],sum[ch[x][1]]+val[x]+max(0,mr[ch[x][0]]));
	mx[x]=max(max(mx[ch[x][0]],mx[ch[x][1]]),val[x]+max(0,mr[ch[x][0]])+max(0,ml[ch[x][1]]));
}//push_up
void modify(int x,int c)
{
	val[x]=c;sum[x]=c*siz[x];
	if(c<0)
		ml[x]=mr[x]=mx[x]=c;
	else
		ml[x]=mr[x]=mx[x]=sum[x];
}//区间修改
void flip(int x)
{
	swap(ch[x][0],ch[x][1]);
	swap(ml[x],mr[x]);
}//区间翻转
void down(int x)
{
	if(fl[x])
	{
		fl[ch[x][0]]^=1;fl[ch[x][1]]^=1;
		flip(ch[x][0]);flip(ch[x][1]);
		fl[x]=0;
	}
	if(la[x]!=inf)
	{
		la[ch[x][0]]=la[ch[x][1]]=la[x];
		modify(ch[x][0],la[x]);modify(ch[x][1],la[x]);
		la[x]=inf;
	}
}//下传标记
node split(int x,int s)
{
	if(!x) return emp;
	down(x);
	node y;
	if(siz[ch[x][0]]>=s)
	{
		y=split(ch[x][0],s);
		ch[x][0]=y.p[1];
		y.p[1]=x;
	}
	else
	{
		y=split(ch[x][1],s-siz[ch[x][0]]-1);
		ch[x][1]=y.p[0];
		y.p[0]=x;
	}
	up(x);
	return y;
}//分裂
int merge(int x,int y)
{
	if(!x || !y) return x+y;
	if(hp[x]<hp[y])
	{
		down(x);
		ch[x][1]=merge(ch[x][1],y);
		up(x);
		return x;
	}
	down(y);
	ch[y][0]=merge(x,ch[y][0]);
	up(y);
	return y;
}//合并
void reuse(int x)
{
	if(!x) return ;
	reuse(ch[x][0]);reuse(ch[x][1]);
	M.Rec(x);
}//回收空间
void init(int x)
{
	if(!x) return ;
	init(ch[x][0]);init(ch[x][1]);
	up(x);
}//跑一遍新建的树
int build(int n)
{
	q[top=1]=1;hp[1]=-inf;
	for(int i=1;i<=n;i++)
	{
		int x=M.New(),t=0;
		ch[x][0]=ch[x][1]=fl[x]=0;la[x]=inf;siz[x]=1;
		hp[x]=rand();val[x]=sum[x]=ml[x]=mr[x]=mx[x]=read();
		while(top && hp[q[top]]>=hp[x]) t=q[top--];
		ch[q[top]][1]=x;ch[x][0]=t;
		q[++top]=x;
	}
	init(1);
	return ch[1][1];
}//O(n)建树，返回根
int main()
{
	srand(time(0));
	ml[0]=mr[0]=mx[0]=val[0]=-inf;
	n=read();m=read();
	rt=build(n);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",str);
		if(str[0]=='I')
		{
			int pos=read(),t=read();
			node x=split(rt,pos);
			rt=merge(merge(x.p[0],build(t)),x.p[1]);
		}
		if(str[0]=='D')
		{
			int pos=read(),t=read();
			node x=split(rt,pos-1),y=split(x.p[1],t);
			reuse(y.p[0]);
			rt=merge(x.p[0],y.p[1]);
		}
		if(str[0]=='M' && str[2]=='K')
		{
			int pos=read(),t=read(),c=read();
			node x=split(rt,pos-1),y=split(x.p[1],t);
			la[y.p[0]]=c;
			modify(y.p[0],c);
			rt=merge(x.p[0],merge(y.p[0],y.p[1]));
		}
		if(str[0]=='R')
		{
			int pos=read(),t=read();
			node x=split(rt,pos-1),y=split(x.p[1],t);
			fl[y.p[0]]^=1;
			flip(y.p[0]);
			rt=merge(x.p[0],merge(y.p[0],y.p[1]));
		}
		if(str[0]=='G')
		{
			int pos=read(),t=read();
			node x=split(rt,pos-1),y=split(x.p[1],t);
			printf("%d\n",sum[y.p[0]]);
			rt=merge(x.p[0],merge(y.p[0],y.p[1]));
		}
		if(str[0]=='M' && str[2]=='X')
		{
			printf("%d\n",mx[rt]);
		}
	}
}
```


---

## 作者：Creeper_LKF (赞：2)

# 指针版非旋Treap

本来写的好好的，然后调指针调的......大概是我太弱了

然后就拿了@曦月__OFN 大佬的代码来对着调

然后代码就长得极其相似......

似乎楼下题解还有一篇差不多的，但是我们不在意这些细节

指针的好处:

1. 写多了其实就好调了
    
1. ~~锻炼代码能力~~

1. 方便递归

1. 可以回收内存

1. 有些操作方便

指针的坏处：

1. 同一个程序在不同机子下的表现不同（例如32位和64位）

1. 蒟蒻杀手，不方便调试

1. 分配内存略慢（当然可以开内存池）

1. 莫名RE

1. 有些操作不方便

然后接下来是代码部分，最后一段的system是用来检测内存大小：

```
#include <cstdio>
#include <cctype>
#include <cstdlib>
using namespace std;
#define MAXN 500050
#define INF 0x3f3f3f3f
#define Finline __inline__ __attribute__ ((always_inline))

const int MODS = 5371321, PRI = 832211;

Finline char get_char(){
    static char buf[10000001], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 10000000, stdin), p1 == p2) ? EOF : *p1 ++;
}
inline int read(){
    int num = 0;
    char c, sf = 1;
    while (!isdigit(c = get_char()) && c != '-');
    if(c == '-') c = get_char(), sf = -1;
    while (num = num * 10 + c - 48, isdigit(c = get_char()));
    return num * sf;
}
inline void swap(int &x, int &y){
    int t = x;
    x = y;
    y = t;
}
Finline int max(int a, int b){
    int c = (a - b) >> 31;
    return (a & ~ c) | (b & c);
}
Finline int min(int a, int b){
    int c = (a - b) >> 31;
    return (a & c) | (b & ~ c);
}
Finline void upmin(int &a, const int &b){
    if(a > b) a = b;
}
Finline void upmax(int &a, const int &b){
    if(a < b) a = b;
}

struct Node{
    int size, val, wv, cov;
    int sum, lm, rm, sm;
    bool rev;
    Node *lc, *rc;
};

int top, cnt;
Node* root, *stack[MAXN];

inline void swap(Node* &x, Node* &y){
    Node* t = x;
    x = y;
    y = t;
}

inline Node* NewNode(int val){
    Node *ret;
    if((ret = (Node*)malloc(sizeof(Node))) == NULL) return NULL;
    if(cnt) cnt--;
    ret -> rev = false;
    ret -> size = 1;
    ret -> val = ret -> sum = ret -> sm = val;
    ret -> wv = rand();
    ret -> cov = INF;
    ret -> lm = ret -> rm = max(val, 0);
    ret -> lc = ret -> rc = NULL;
    return ret;
}

int n, m;

inline int rand(){
    static int sed = 15;
    return sed = 1ll * sed * PRI % MODS;
}

inline void Del(Node *node){
    if(node == NULL) return ;
    Del(node -> lc), Del(node -> rc);
    free(node);
    cnt++;
}

inline void Cover(Node *node, int val){
    node -> val = val;
    node -> sum = (node -> size) * val;
    node -> lm = node -> rm = max(node -> sum, 0);
    node -> sm = max(node -> sum, node -> val);
    node -> cov = val;
}

inline void Reverse(Node* &node){
    swap(node -> lc, node -> rc);
    swap(node -> lm, node -> rm);
    node -> rev ^= 1;  
}

inline void Push_Up(Node *node){
    bool l = node -> lc == NULL, r = node -> rc == NULL;
    node -> size = (l ? 0 : node -> lc -> size) + (r ? 0 : node -> rc -> size) + 1;
    node -> sum = (l ? 0 : node -> lc -> sum) + (r ? 0 : node -> rc -> sum) + node -> val;
    node -> sm = max(max((l ? -INF : node -> lc -> sm), (r ? -INF : node -> rc -> sm)), (l ? 0 : node -> lc -> rm) + (r ? 0 : node -> rc -> lm) + node -> val);
    node -> lm = max((l ? 0 : node -> lc -> lm), (l ? 0 : node -> lc -> sum) + (r ? 0 : node -> rc -> lm) + node -> val);
    node -> rm = max((r ? 0 : node -> rc -> rm), (r ? 0 : node -> rc -> sum) + (l ? 0 : node -> lc -> rm) + node -> val);
}

inline void Push_Down(Node *node){
    if(node -> rev){
        node -> rev = false;
        if(node -> lc != NULL) Reverse(node -> lc);
        if(node -> rc != NULL) Reverse(node -> rc);
    }
    if(node -> cov != INF){
        if(node -> lc != NULL) Cover(node -> lc, node -> cov);
        if(node -> rc != NULL) Cover(node -> rc, node -> cov);
        node -> cov = INF;
    }
}

inline Node* Merge(Node* x, Node* y){
    if(x != NULL) Push_Down(x);
    if(y != NULL) Push_Down(y);
    if(x == NULL || y == NULL) return x == NULL ? y : x;
    if(x -> wv < y -> wv){
        x -> rc = Merge(x -> rc, y);
        Push_Up(x);
        return x;
    } else {
        y -> lc = Merge(x, y -> lc);
        // if(y == y -> lc) printf("Dead in line %d of %d\n", __LINE__, y -> wv);
        Push_Up(y);
        return y;
    }
}

inline void Split(Node* node, int k, Node* &x, Node* &y){
    if(node == NULL){
        x = y = NULL;
        return;
    }
    Push_Down(node);
    if((node -> lc == NULL ? 0 : node -> lc -> size) >= k){
        y = node;
        Split(node -> lc, k, x, node -> lc);
    } else {
        x = node;
        Split(node -> rc, k - 1 - (node -> lc == NULL ? 0 : node -> lc -> size), node -> rc, y);
    }
    Push_Up(node);
}

int main(){
    // freopen("in.in", "r", stdin);
    // freopen("out.out", "w", stdout);
    n = read(), m = read();
    for(int i = 1; i <= n; i++){
        int val = read();
        Node *p = NewNode(val), *tmp = NULL;
        if(top) stack[top] -> rc = p;
        p -> lc = tmp, stack[++top] = p;
    }
    while(top) Push_Up(stack[top--]);
    root = stack[1];
    while(m--){
        char cons;
        while(!isalpha(cons = get_char()));
        if(cons == 'I'){
            int st = read(), tot = read();
            for(int i = 1; i <= tot; i++){
                int val = read();
                Node *p = NewNode(val), *tmp = NULL;
                while(cnt && stack[top] != NULL && stack[top] -> wv > p -> wv){
                    Push_Up(stack[top]);
                    tmp = stack[top];
                    stack[top--] = NULL;
                }
                if(top) stack[top] -> rc = p;
                p -> lc = tmp, stack[++top] = p;
            }
            Node *ls = NULL, *rs = NULL, *tmp;
            while(top) Push_Up(stack[top--]);
            tmp = stack[1];
            Split(root, st, ls, rs);
            root = Merge(Merge(ls, tmp), rs);
        } else if(cons == 'D'){
            int st = read(), k = read();
            Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;
            Split(root, st - 1, ls, rs);
            Split(rs, k, xs, ys);
            root = Merge(ls, ys);
            cnt += xs == NULL ? 0 : xs -> size;
            Del(xs);
        } else if(cons == 'R'){
            int st = read(), k = read();
            Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;
            Split(root, st - 1, ls, rs);
            Split(rs, k, xs, ys);
            Reverse(xs);
            root = Merge(ls, Merge(xs, ys));
        } else if(cons == 'G'){
            while(!isspace(get_char()));
            int st = read(), k = read();
            Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;
            Split(root, st - 1, ls, rs);
            Split(rs, k, xs, ys);
            if(xs == NULL) puts("0");
            else printf("%d\n", xs -> sum);
            root = Merge(ls, Merge(xs, ys));
        } else {
            cons = get_char(), cons = get_char();
            while(!isspace(get_char()));
            if(cons == 'X') printf("%d\n", root -> sm);
            else {
                int st = read(), k = read(), val = read();
                Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;
                Split(root, st - 1, ls, rs);
                Split(rs, k, xs, ys);
                Cover(xs, val);
                root = Merge(ls, Merge(xs, ys));
            }
        }
    }
    // Debug Get Running Memery
    // system("wmic process where name=\"a.exe\" get WorkingSetSize");
    return 0;
}
```
    

---

## 作者：Running_Coder (赞：2)

PS：某大佬讲，当心情特别好or特别不好的时候，可以来攻略这个题。。。果然萌新足足被这题恶心了半个月。。。

进入正题：

这道题题意如此之裸-Splayの究极进化，那么就没有什么好讲的，直接说搞法好了。。。

为了代码写起来方便，萌新封装得可能有些过，若不合诸位大佬的口味还请见谅~


###节点node结构体定义：

key：节点原值；size：子树大小；ch[2]：子树指针；

set\_pd：记录是否打了MAKE-SAME的懒标记；setv：MAKE-SAME的修改值；turn：记录是否旋转；

sum：子树元素总和；lmax,rmax,zdh：当前节点所控制区间的最大前缀和、最大后缀和、最大子段和。

成员函数：


```cpp
maintain()：维护节点信息；
update_same()：打MAKE-SAME的懒标记；
update_rev()：打REVERSE的懒标记；
pushdown()：下放懒标记；
cmp(int x)：求在当前节点所控制区间中，排名为x的元素相对于当前节点的位置，0为左，1为右，-1为当前节点自身；
son_order(int x,bool d)：求在当前节点所控制区间中，排名为x的元素在d指向的子树中的排名。
```
主程序函数：
rotate()：萌新采用了先下放再考虑如何旋转的写法，所以不必考虑改变旋转方向之类的东西。。。注意下放、维护就好了；

splay()：此函数，萌新的自行研制写法，相对大佬们的代码，看上去长了许多。。。不过也可以放心食用啦~无父指针Splay赛高~

build()：建立完全平衡的BST，此题中应用这种建树方式，可极大地提高代码速度；

recycle()：回收删除的区间所占用的空间，如果没有这个，会导致个别点MLE；


get\_range()：这个函数的功能是抽取区间。。。

为什么要写这个呢？因为萌新太弱了。。。

我们知道，在抽取区间时，对边界情况，直接Splay就解决不了了；

这时一般会用“在头和尾加虚拟节点”的方法；

萌新曾试着这样写过。。。但最终没能解决虚拟节点的信息维护问题，尤其是最大子段和什么的。。。

于是放弃，采用了略为繁琐的分类讨论写法，具体如下：

1.若区间为整个序列，则不作任何操作，root即可代表整个序列；

2.若区间为[1,x]，其中x<n，则将x+1号元素splay至root，则root->ch[0]即为该区间；

3.若区间为[x,n]，其中x>1，则采取类似上面的操作；

4.若区间为[l,r]，其中1<l<=r<n，那么将l-1、r+1分别splay至root、root->ch[1]，则root->ch[1]->ch[0]即为该区间。

操作完后，返回一个值，用于在后续操作中进行对不同情况的识别。


work()：依据不同的区间情况和不同的指令，进行相应操作。

change()：依据不同的区间情况进行对相关节点的信息维护。


#大坑警示！！！个别点中，操作的区间可能长度为0！！！

萌新就是因为这个问题而莫名RE了好久。。。后来终于对照某大佬的代码才发现了问题。。。


###代码如下：





    
    
    

    
    
    
    
        
        
    
        
        
        
    
        
    
            
            
            
    
        
    






    
    
        
                
                
                
            
                
                
            
                
                
            
                
                
            
                
                
            
                
    

    
    
    
    

    
    
    
        
        

    
    
    

    


    

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cstdlib>
#include<string>
#include<stack>
#include<queue>
#include<vector>
#include<algorithm>
#include<map>
#define inf 2147483647
using namespace std;
void read(int &x){
    x=0;
    char t=getchar();
    bool f=0;
    while(t<'0' || t>'9'){
        if(t=='-')f=1;
        t=getchar();
    }
    while(t>='0' && t<='9'){
        x=(x<<3)+(x<<1)+t-'0';
        t=getchar();
    }
    if(f)x=-x;
}
struct node{
    int key;
    int size;
    node *ch[2];
    bool set_pd;
    int setv;
    bool turn;
    int sum;
    int lmax;
    int rmax;
    int zdh;
    void maintain(){
        size=1;
        if(ch[0]!=NULL)size+=ch[0]->size;
        if(ch[1]!=NULL)size+=ch[1]->size;
        sum=key;
        if(ch[0]!=NULL)sum+=ch[0]->sum;
        if(ch[1]!=NULL)sum+=ch[1]->sum;
        if(ch[0]==NULL && ch[1]==NULL){
            lmax=rmax=max(0,key);
            zdh=key;
        }
        else if(ch[1]==NULL){
            lmax=max(ch[0]->lmax,ch[0]->sum+key);
            rmax=max(0,key+ch[0]->rmax);
            zdh=max(ch[0]->zdh,ch[0]->rmax+key);
        }
        else if(ch[0]==NULL){
            lmax=max(0,key+ch[1]->lmax);
            rmax=max(ch[1]->rmax,ch[1]->sum+key);
            zdh=max(ch[1]->zdh,key+ch[1]->lmax);
        }
        else{
            lmax=max(ch[0]->lmax,ch[0]->sum+key+ch[1]->lmax);
            rmax=max(ch[1]->rmax,ch[1]->sum+key+ch[0]->rmax);
            zdh=max(max(ch[0]->zdh,ch[1]->zdh),ch[0]->rmax+key+ch[1]->lmax);
        }
    }
    void update_same(int fix){
        set_pd=1;
        key=setv=fix;
        sum=fix*size;
        lmax=rmax=max(0,sum);
        zdh=max(sum,key);
        turn=0;  //打了MAKE-SAME之后就可以无视旋转了
    }
    void update_rev(){
        turn^=1;
        lmax^=rmax;
        rmax^=lmax;
        lmax^=rmax;  //在上层节点抽取本节点信息时，要求必须在旋转时交换lmax和rmax
    }
    void pushdown(){
        if(set_pd){
            if(ch[0]!=NULL)ch[0]->update_same(setv);
            if(ch[1]!=NULL)ch[1]->update_same(setv);
            set_pd=0;
            turn=0;
        }
        if(turn){
            node *t=ch[0];
            ch[0]=ch[1];
            ch[1]=t;
            if(ch[0]!=NULL)ch[0]->update_rev();
            if(ch[1]!=NULL)ch[1]->update_rev();
            turn=0;
        }
    }
    int cmp(int x){
        int s=0;
        if(ch[0]!=NULL)s=ch[0]->size;
        if(x<=s)return 0;
        else if(x==s+1)return -1;
        else return 1;
    }
    int son_order(int x,bool d){
        if(d==0)return x;
        else{
            if(ch[0]==NULL)return x-1;
            else return x-ch[0]->size-1;
        }
    }
};
void rotate(node* &,bool);  //没有自带对当前根节点的懒标记下放 
void splay(node* &,int);  //按照排名伸展 
void build(node* &,int,int,int);
void recycle(node *);
int get_range();
void work(int);
void change();
node *root=NULL;
node *temp;
int longtao[500010];
char s[15];
int n,m,i,j;
int pos,tot,fix,kind;
int main(){
    read(n);read(m);
    for(i=1;i<=n;i++)read(longtao[i]);
    build(root,1,n,(1+n)>>1);
    for(i=1;i<=m;i++){
        scanf("%s",s);
        switch(s[2]){
            case 'S':{
                read(pos);read(tot);
                if(tot==0)break;
                for(j=1;j<=tot;j++)read(longtao[j]);
                temp=NULL;
                build(temp,1,tot,(1+tot)>>1);
                if(pos==0){
                    splay(root,1);
                    root->ch[0]=temp;
                    root->maintain();
                }
                else if(pos==root->size){
                    splay(root,inf);
                    root->ch[1]=temp;
                    root->maintain();
                }
                else{
                    splay(root,pos);
                    splay(root->ch[1],1);
                    root->ch[1]->ch[0]=temp;
                    root->ch[1]->maintain();
                    root->maintain();
                }
                break;
            }
            case 'L':{
                read(pos);read(tot);
                if(tot==0)break;
                kind=get_range();
                work(2);
                change();
                break;
            }
            case 'K':{
                read(pos);read(tot);read(fix);
                if(tot==0)break;
                kind=get_range();
                work(3);
                change();
                break;
            }
            case 'V':{
                read(pos);read(tot);
                if(tot==0)break;
                kind=get_range();
                work(4);
                change();
                break;
            }
            case 'T':{
                read(pos);read(tot);
                if(tot==0){
                    printf("0\n");
                    break;
                }
                kind=get_range();
                work(5);
                break;
            }
            case 'X':{
                printf("%d\n",root->zdh);
                break;
            }
        }
    }
    return 0;
}
void rotate(node* &p,bool f){
    node *t=p->ch[f^1];
    t->pushdown();
    p->ch[f^1]=t->ch[f];
    t->ch[f]=p;
    p->maintain();
    t->maintain();
    p=t;
}
void splay(node* &p,int x){
    p->pushdown();
    int d1=p->cmp(x);
    if(d1==-1 || p->ch[d1]==NULL)return;
    p->ch[d1]->pushdown();
    int x2=p->son_order(x,d1);
    int d2=p->ch[d1]->cmp(x2);
    if(d2==-1 || p->ch[d1]->ch[d2]==NULL){
        rotate(p,d1^1);
        return;
    }
    else{
        int x3=p->ch[d1]->son_order(x2,d2);
        splay(p->ch[d1]->ch[d2],x3);
        if(d1==d2){
            rotate(p,d1^1);
            rotate(p,d2^1);
        }
        else{
            rotate(p->ch[d1],d1);
            rotate(p,d2);
        }
    }
}
void build(node* &p,int l,int r,int mid){
    p=(node *)malloc(sizeof(node));
    p->key=longtao[mid];
    p->ch[0]=p->ch[1]=NULL;
    p->set_pd=0;
    p->turn=0;
    if(mid-1>=l)build(p->ch[0],l,mid-1,(l+mid-1)>>1);
    if(mid+1<=r)build(p->ch[1],mid+1,r,(mid+1+r)>>1);
    p->maintain();
}
void recycle(node *p){
    if(p->ch[0]!=NULL)recycle(p->ch[0]);
    if(p->ch[1]!=NULL)recycle(p->ch[1]);
    free(p);
}
int get_range(){
    if(tot==root->size)return 1;
    else if(pos==1){
        splay(root,pos+tot);
        return 2;
    }
    else if(pos+tot-1==root->size){
        splay(root,pos-1);
        return 3;
    }
    else{
        splay(root,pos-1);
        splay(root->ch[1],tot+1);
        return 4;
    }
}
void work(int f){
    node **t;
    if(kind==1)t=&root;
    if(kind==2)t=&(root->ch[0]);
    if(kind==3)t=&(root->ch[1]);
    if(kind==4)t=&(root->ch[1]->ch[0]);
    if(f==2){
        recycle(*t);
        (*t)=NULL;
    }
    else if(f==3)(*t)->update_same(fix);
    else if(f==4)(*t)->update_rev();
    else printf("%d\n",(*t)->sum);
}
void change(){
    if(kind==2 || kind==3)root->maintain();
    else if(kind==4){
        root->ch[1]->maintain();
        root->maintain();
    }
}
```

---

## 作者：Alear (赞：1)

# 吹一波fhq
[维护数列](https://www.luogu.org/problemnew/show/P2042)

貌似没什么题解是用fhq写的，大多是splay，让蒟蒻的我发一波fhq（话说明明fhq这么强大，为什么没什么人写呢？）

建树需要模仿斐波那契堆来做到线性建树，不然会T掉两道三个点。嗯，貌似fhq treap这一点有点麻烦，需要用单调栈来加快建树，看看别人splay只需要递归建树就好了。

用一个单调维护最右链，保证rnd值单调递增，如果不能继续插入则弹出，注意一边弹出一边更新，再将弹出的链接在即将插入的节点的左子节点上。

最后处理一下栈内剩下元素，此时栈底元素必为这颗新树的根。

```cpp

int build(int a[],int l,int r){
    int top=0,p=0;
    for(int i=l;i<=r;i++)
        a[i]=New(a[i]);
    for(int i=l;i<=r;i++){
    	p=0;
    	while(top and c[s[top]].rnd>c[a[i]].rnd){
    		update(s[top]);
    		p=s[top];
    		top--;
        }
        s[++top]=a[i];
        c[a[i]].ls=p;
        if(top>1)
            c[s[top-1]].rs=s[top];
    }
    while(top)
        update(s[top--]);
    return s[1];
}
```

update的时候要注意一下左右子节点的存在性

每次对区间操作的时候就要将该节点除了左右子节点指针之外的所有信息都给更新好，因为在父节点的更新中会用到这些信息，没有更新的话会导致一些玄学错误

其他都是正常操作了

### Talk is cheap,show you the code

```cpp
#include<bits/stdc++.h>
#define Max(x,y,z) max(max(x,y),z)
#define Merge(x,y,z) merge(merge(x,y),z)
using namespace std;
int read(){
    int c,nx,sign=1;
    do{
        c=getchar()-'0';
        if(c=='-'-'0')
            sign=-1;
    }while(c<0 or c>9);
    while(0<=(nx=getchar()-'0') and nx <= 9)
        c=c*10+nx;
    return sign*c;
}
const int N=5e5+10;
struct fhq{
    int dat,lm,rm,sm,val;
    int ls,rs;
    int size;
    int rev,tag;
    int rnd;
}c[N];
int root;
queue<int>rub;
inline int New(int n){
    static int now=0;
    int s;
    if(rub.size()){
        s=rub.front();
        rub.pop();
    }else
        s=++now;
    c[s].rnd=((rand()<<15)|rand());
    c[s].val=c[s].sm=c[s].dat=c[s].lm=c[s].rm=n;
    c[s].ls=c[s].rs=0;
    c[s].size=1;
    c[s].rev=0;
    c[s].tag=INT_MAX;
    return s;
}
void Delete(int s){
    if(c[s].ls)
        Delete(c[s].ls);
    if(c[s].rs)
        Delete(c[s].rs);
    rub.push(s);
}
inline void fs(int s,int rev,int tag){
    int size=c[s].size;
    if(tag!=INT_MAX){
        c[s].val=tag;
        c[s].dat=tag*size;
        c[s].lm=c[s].rm=c[s].sm= tag>0 ? tag*size : tag;
        c[s].tag=tag;
        rev=0;
    }
    if(rev){
        c[s].rev^=rev;
        swap(c[s].lm,c[s].rm);
    }
}
inline void down(int s){
    int &rev=c[s].rev,&tag=c[s].tag;
    if(!rev and tag==INT_MAX or !s)
        return ;
    if(c[s].ls)
        fs(c[s].ls,rev,tag);
    if(c[s].rs)
        fs(c[s].rs,rev,tag);
    if(rev)
        swap(c[s].ls,c[s].rs);
    rev=0;
    tag=INT_MAX;
}
inline void update(int s){
    if(!s)
        return ;
    c[s].dat=c[s].sm=c[s].lm=c[s].rm=c[s].val;
    c[s].size=1;
    if(c[s].ls){
        int ls=c[s].ls;
        c[s].sm=Max(c[ls].sm,c[s].sm,c[ls].rm+c[s].lm);
        c[s].lm=max(c[ls].lm,c[ls].dat+c[s].lm);
        c[s].rm=max(c[s].rm,c[s].dat+c[ls].rm);
        c[s].dat+=c[ls].dat;
        c[s].size+=c[ls].size;
    }
    if(c[s].rs){
        int rs=c[s].rs;
        c[s].sm=Max(c[s].sm , c[rs].sm , c[s].rm + c[rs].lm);
        c[s].lm=max(c[s].lm , c[s].dat + c[rs].lm);
        c[s].rm=max(c[rs].rm , c[rs].dat + c[s].rm);
        c[s].dat+=c[rs].dat;
        c[s].size+=c[rs].size;
    }
}
int merge(int x,int y){
    down(x),down(y);
    if(!x or !y)
        return x|y;
    if(c[x].rnd<c[y].rnd){
        c[x].rs=merge(c[x].rs,y);
        update(x);
        return x;
    }else{
        c[y].ls=merge(x,c[y].ls);
        update(y);
        return y;
    }
}
void split(int s,int n,int &x,int &y){
    down(s);
    int ls=c[s].ls;
    if(!s)
        x=y=0;
    else if(c[ls].size>=n){
        y=s;
        split(c[s].ls,n,x,c[y].ls);
        update(y);
    }else{
        x=s;
        split(c[s].rs,n-c[ls].size-1,c[x].rs,y);
        update(x);
    }
}
int s[N];
int build(int a[],int l,int r){
    int top=0,p=0;
    for(int i=l;i<=r;i++)
        a[i]=New(a[i]);
    for(int i=l;i<=r;i++){
    	p=0;
    	while(top and c[s[top]].rnd>c[a[i]].rnd){
    		update(s[top]);
    		p=s[top];
    		top--;
        }
        s[++top]=a[i];
        c[a[i]].ls=p;
        if(top>1)
            c[s[top-1]].rs=s[top];
    }
    while(top)
        update(s[top--]);
    return s[1];
}
inline void insert(int a[],int len,int pos){
    int y=build(a,1,len);
    int x,z;
    split(root,pos,x,z);
    root=Merge(x,y,z);
}
inline void del(int pos,int len){
    int x,y,z;
    split(root,pos-1,x,y);
    split(y,len,y,z);
    Delete(y);
    root=merge(x,z);
}
inline void change(int f,int pos,int len){
    int x,y,z;
    split(root,pos-1,x,y);
    split(y,len,y,z);
    fs(y,0,f);
    root=Merge(x,y,z);
}
inline void reverse(int pos,int len){
    int x,y,z;
    split(root,pos-1,x,y);
    split(y,len,y,z);
    fs(y,1,INT_MAX);
    root=Merge(x,y,z);
}
inline int maxsum(){
    return c[root].sm;
}
inline int getsum(int pos,int len){
    int x,y,z;
    split(root,pos-1,x,y);
    split(y,len,y,z);
    int ans=c[y].dat;
    root=Merge(x,y,z);
    return ans;
}
int a[N];
int main(){
    int n=read(),m=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    root=build(a,1,n);
    while(m--){
        char ord[10];
        scanf("%s",ord);
        int pos,len,x;
        switch(ord[0]){
            case 'I':
                pos=read();
                len=read();
                for(int i=1;i<=len;i++)
                    a[i]=read();
                insert(a,len,pos);
                break;
            case 'D':
                pos=read();
                len=read();
                del(pos,len);
                break;
            case 'M':
                if(ord[2]=='X'){
                    printf("%d\n",c[root].sm);
                    break;
                }
                pos=read();
                len=read();
                x=read();
                change(x,pos,len);
                break;
            case 'R':
                pos=read();
                len=read();
                reverse(pos,len);
                break;
            case 'G':
                pos=read();
                len=read();
                printf("%d\n",getsum(pos,len));
                break;
        }
    }
}
```


---

## 作者：风随逐影 (赞：1)

## Splay 模板题

简而言之就是个区间操作的全家桶，代码里的注释很详细了

```
#include<bits/stdc++.h>
#pragma GCC optimize(3)
using namespace std;
#define go(i,a,b) for(int i=(a);i<=(b);++(i))
#define com(i,a,b) for(int i=(a);i>=(b);--(i))
#define mem(a,b) memset((a),(b),sizeof(a))
#define inf 0x3f3f3f3f
#define fin freopen("input.txt","r",stdin)
#define fout freopen("output.txt","w",stdout)
#define debug printf("行号：%d 函数名：%s \n", __LINE__, __FUNCTION__)
typedef long long ll;
const int maxn=800005;
int sz,root,n,l,r,m;
int ch[maxn][2],d[maxn],v[maxn],f[maxn],size[maxn],sum[maxn],tot,mx[maxn],lx[maxn],rx[maxn],id[maxn],flag[maxn];
bool used[maxn];
void read(int &x){
    int f=1;char c=getchar();x=0;
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    x*=f;
}//读入优化
queue<int>s;

void update(int x){
	//v表示节点本身的值 
	int l=ch[x][0],r=ch[x][1];
	size[x]=size[l]+size[r]+1;
	sum[x]=sum[l]+sum[r]+v[x];
	mx[x]=max(mx[l],mx[r]);
	mx[x]=max(mx[x],lx[r]+v[x]+rx[l]);
	//lx,rx分别表示区间内最大前缀和与后缀和，他们可以为0（不选）
	//从而帮助计算出区间最值
	lx[x]=max(lx[l],sum[l]+v[x]+lx[r]);
	rx[x]=max(rx[r],sum[r]+v[x]+rx[l]);
	//更新最大前缀和与后缀和
}
inline bool get(int x){
	return ch[f[x]][1]==x;
}
void pushdown(int now){
	int l=ch[now][0],r=ch[now][1];
	if(flag[now]){//赋值标记 
		flag[now]=0;
		if(l) v[l]=v[now],flag[l]=1,sum[l]=size[l]*v[now];
		if(r) v[r]=v[now],flag[r]=1,sum[r]=size[r]*v[now];
		if(v[now]>=0){
			if(l)lx[l]=rx[l]=mx[l]=sum[l];
			if(r)lx[r]=rx[r]=mx[r]=sum[r];
		}
		else{
			if(l)lx[l]=rx[l]=0,mx[l]=v[now];
			if(r)lx[r]=rx[r]=0,mx[r]=v[now];
		}
	}
	if(used[now]){
		swap(lx[l],rx[l]);swap(lx[r],rx[r]);
		swap(ch[l][0],ch[l][1]);swap(ch[r][0],ch[r][1]);
		used[now]^=1;
		used[l]^=1,used[r]^=1;
		//懒标记下传 
	}
}
void move(int now,int &k){
	int fa=f[now],cnt=get(now),faa=f[fa];//cnt=1->lson,or->rson
	pushdown(fa);
	if(fa==k) k=now;//我们要把now转上去
	else if(faa) ch[faa][get(fa)]=now;//我，代替父亲，过继给爷爷
	ch[fa][cnt]=ch[now][cnt^1];//我把儿子过继给父亲，代替我
	f[ch[now][cnt^1]]=fa;
	ch[now][cnt^1]=fa;//认父作子，代替我被过继走的的儿子
	f[fa]=now;
	f[now]=faa;
	update(fa);update(now);//注意顺序哦 
}
void splay(int x,int &k){
	int y,z;
	pushdown(x);
	while(x!=k){//一直转 
		y=f[x],z=f[y];//父亲与爷爷
		if(y!=k){
			if((ch[y][0]==ch[z][0])^(ch[y][1]==ch[z][1]))move(y,k);
			//若x与y方向相同,否则转自己 
			 else move(x,k);
		}
		move(x,k);
	}
}
void build(int l,int r,int fa){//fa表示平衡树上的父节点 
	if(l>r) return;
	int mid=(l+r)>>1,now=id[mid],last=id[fa];//id表示位置为i的节点编号（不是原图的位置） 
	if(l==r){
		sum[now]=d[l];size[now]=1;//更新sum和size
		if(d[l]>=0) lx[now]=rx[now]=mx[now]=d[l];//维护最大值和最大前缀和与后缀和，前缀和与后缀和可以为0 
		else lx[now]=rx[now]=0,mx[now]=d[l];
	}
	else build(l,mid-1,mid),build(mid+1,r,mid);//建出左右儿子 
	v[now]=d[mid];
	f[now]=last;update(now);
	ch[last][mid>=fa]=now;//维护父子关系 ,下标比父亲的下标小的是左儿子 
}
int find(int k,int x){//查询区间内下标为x的根 
	pushdown(k);//懒标记下传
	if(x<=size[ch[k][0]]) return find(ch[k][0],x);
	if(x==size[ch[k][0]]+1) return k;
	return find(ch[k][1],x-size[ch[k][0]]-1); 
}
void ins(int k,int b){
	go(i,1,b) read(d[i]);//d[i]不过是个临时数组
	go(i,1,b)
		if(!s.empty())id[i]=s.front(),s.pop();
		else id[i]=++tot;//用了回收空间的写法
	build(1,b,0);//建立一棵新树 
	int now=id[1+b>>1];//取中点 
	int x=find(root,k+1),y=find(root,k+2);//准备插到x，y中间
	splay(x,root);splay(y,ch[root][1]);//y的左儿子必定为空 
	ch[y][0]=now;f[now]=y;
	update(y),update(x);//注意顺序 
}
void change(int k,int b,int num){
	int x=find(root,k),y=find(root,b+1);
	splay(x,root),splay(y,ch[root][1]);//老套路了
	int g=ch[y][0];//（x+1,y-1)
	flag[g]=1;//区间赋值懒标记 
	sum[g]=num*size[g];v[g]=num;
	if(num>=0)lx[g]=rx[g]=mx[g]=sum[g];//前提当然是num>=0啦，不然不如不选
	else lx[g]=rx[g]=0,mx[g]=num;
	update(y),update(x); 
}
void rec(int x){
	if(!x)return;
	int l=ch[x][0],r=ch[x][1];
	rec(l);rec(r);s.push(x);//扔进回收站 
	f[x]=ch[x][0]=ch[x][1]=0;//删去与她相连的所有边 
	flag[x]=used[x]=0;//防止被还原后出问题 
}
void del(int l,int r){
	int x=find(root,l),y=find(root,r+1);
	splay(x,root),splay(y,ch[root][1]);
	rec(ch[y][0]);//删去l+1,r 
	ch[y][0]=0;
	update(y),update(x);//注意顺序 
}
int main(){
	read(n),read(m);
	d[1]=d[n+2]=mx[0]=-9999999;
	//开头结尾有两个辅助节点 
	go(i,1,n) read(d[i+1]);//初始数列 
	go(i,1,n+2) id[i]=i;//保存位置
	build(1,n+2,0);
	int k,x,a,b,c;tot=n+2;
	root=n+3>>1;//取一个中间数为根
	char p[13];
	while(m--){//翻转 
		scanf("%s",p+1);
		if(p[3]=='V'){
			read(a),read(b);b=b+a;
			int x=find(root,a),y=find(root,b+1);
			splay(x,root);//整棵树被划分为1到a-1,a,a+1到n+2
			splay(y,ch[root][1]);//右子树被划分为a+1到b,b+1,b+2到n+2
			//a，b实际代表a-1和b-1 
			c=ch[y][0];//待修改区间 
			used[c]^=1;swap(lx[c],rx[c]);swap(ch[c][0],ch[c][1]);
			update(y),update(x);
		}
		if(p[3]=='S')
			read(a),read(b),ins(a,b);
		if(p[3]=='L'){
			read(a),read(b);b=a+b;
			del(a,b);
		}
		if(p[3]=='K'){//区间修改 
			read(a),read(b),read(c);b=a+b;
			change(a,b,c);
		}
		if(p[3]=='T'){
			read(a),read(b);b=a+b;
			splay(find(root,a),root);
			splay(find(root,b+1),ch[root][1]);//老套路 
			printf("%d\n",sum[ch[ch[root][1]][0]]);
		}
		if(p[3]=='X'){
			printf("%d\n",mx[root]);
		}
	} 
	return 0;
}
```


---

## 作者：Sor4 (赞：1)

注意开内存池就可以了，最大子序和为max{左子树最大子序和，右子树最大子序和，max{左子树右边最大子序和,0}+根节点元素+max{右子树左边最大子序和,0}}。


...cpp






























```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int Size = 500000+100;
const int inf = 0x3f3f3f3f;
int ch[Size][2],pre[Size],size[Size],mx[Size],lx[Size],rx[Size];
int sum[Size],rev[Size],same[Size],data[Size];
int root;
int Stack[Size],top;
int a[Size];
char type[20];
void Read(int &);
void NewNode(int &,int,int);
void Build(int &,int,int,int);
void Splay(int,int);
void Rotate(int,int);
void Updata(int);
int Order(int);
void PushDown(int);
void PushSame(int,int);
void PushRev(int);
void Insert(int,int);
void Delete(int,int);
void Rec(int);
void MakeSame(int,int,int);
void Reverse(int,int);
int GetSum(int,int);
int MaxSum();
void Display(int);
void Debug();
int main(){
    for(int i=Size-1;--i;) Stack[++top] = i;
    NewNode(root,0,-inf);NewNode(ch[root][1],root,-inf);Updata(root);
    int t,n,pos,tot,c;
    Read(n);Read(t);
    for(int i=0;i<n;++i) Read(a[i]);
    Build(ch[ch[root][1]][0],0,n-1,ch[root][1]);
    Updata(ch[root][1]);Updata(root);
    while( t-- ){
        scanf("%s",type);
        if(type[2]!='X') Read(pos),Read(tot);
        if(type[2]=='S') Insert(pos,tot);
        else if(type[2]=='L') Delete(pos,tot);
        else if(type[2]=='K') Read(c),MakeSame(pos,tot,c);
        else if(type[2]=='V') Reverse(pos,tot);
        else if(type[2]=='T') printf("%d\n",GetSum(pos,tot));
        else printf("%d\n",MaxSum());
    }
    return 0;
}
void Read(int &in){
    char ch;int f=1;
    for(ch=getchar();ch>'9'||ch<'0';ch=getchar()) if(ch=='-') f=-1;
    for(in=0;ch>='0'&&ch<='9';ch=getchar()) in=in*10+ch-'0';
    in *= f;
}
void NewNode(int &r,int father,int key){
    pre[r=Stack[top--]] = father;
    sum[r] = data[r] = lx[r] = mx[r] = rx[r] = key;
    size[r] = 1;
    ch[r][0] = ch[r][1] = same[r] = rev[r] = 0;
}
void Build(int &node,int l,int r,int father){
    if(l > r) return ;
    int mid = (l+r)>>1;
    NewNode(node,father,a[mid]);
    Build(ch[node][0],l,mid-1,node);
    Build(ch[node][1],mid+1,r,node);
    Updata(node);
}
void Splay(int r,int goal){
    int x,y,kind;
    while(pre[r] != goal)
        if(pre[pre[r]]==goal) Rotate(r,ch[pre[r]][0]==r);
        else{
            x=pre[r];y=pre[x];kind=ch[y][1]==x;
            if(ch[x][kind]==r) Rotate(x,!kind),Rotate(r,!kind);
            else Rotate(r,kind),Rotate(r,!kind);
        }
    if(!goal) root=r;
}
void Rotate(int r,int way){
    int t = pre[r];
    pre[ch[t][!way]=ch[r][way]] = t;
    if(pre[t]) ch[pre[t]][ch[pre[t]][1]==t] = r;
    pre[r] = pre[t];
    pre[ch[r][way]=t] = r;
    Updata(t);Updata(r);Updata(pre[r]);
}
void Updata(int r){
    if(!r) return ;
    size[r] = size[ch[r][0]]+size[ch[r][1]]+1;
    sum[r] = sum[ch[r][0]]+sum[ch[r][1]]+data[r];
    lx[r] = sum[ch[r][0]]+data[r]+max(0,lx[ch[r][1]]);
    if(ch[r][0]) lx[r] = max(lx[r],lx[ch[r][0]]);
    rx[r] = sum[ch[r][1]]+data[r]+max(0,rx[ch[r][0]]);
    if(ch[r][1]) rx[r] = max(rx[r],rx[ch[r][1]]);
    mx[r] = max(0,rx[ch[r][0]])+data[r]+max(0,lx[ch[r][1]]);
    if(ch[r][0]) mx[r] = max(mx[r],mx[ch[r][0]]);
    if(ch[r][1]) mx[r] = max(mx[r],mx[ch[r][1]]);
}
int Order(int k){
    int now = root;
    while(true){
        PushDown(now);
        if(size[ch[now][0]]>=k) now=ch[now][0];
        else if(size[ch[now][0]]+1==k) return now;
        else k-=(size[ch[now][0]]+1),now=ch[now][1];
    }
}
void PushDown(int r){
    if(same[r]){
        PushSame(ch[r][0],data[r]);
        PushSame(ch[r][1],data[r]);
        same[r] = 0;
    }
    if(rev[r]){
        PushRev(ch[r][0]);
        PushRev(ch[r][1]);
        rev[r] = 0;
    }
}
void PushSame(int r,int c){
    if(!r) return ;
    data[r] = c;
    sum[r] = c*size[r];
    lx[r] = mx[r] = rx[r] = max(sum[r],c);
    same[r] = 1;
}
void PushRev(int r){
    if(!r) return ;
    swap(lx[r],rx[r]);
    swap(ch[r][0],ch[r][1]);
    rev[r] ^= 1;
}
void Insert(int pos,int tot){
    for(int i=0;i<tot;++i) Read(a[i]);
    Splay(Order(pos+1),0);
    Splay(Order(pos+2),root);
    Build(ch[ch[root][1]][0],0,tot-1,ch[root][1]);
    Updata(ch[root][1]);Updata(root);
}
void Delete(int pos,int tot){
    Splay(Order(pos),0);
    Splay(Order(pos+tot+1),root);
    Rec(ch[ch[root][1]][0]);
    ch[ch[root][1]][0] = 0;
    Updata(ch[root][1]);Updata(root);
}
void Rec(int r){
    if(!r) return ;
    Stack[++top] = r;
    Rec(ch[r][0]);Rec(ch[r][1]);
}
void MakeSame(int pos,int tot,int c){
    Splay(Order(pos),0);
    Splay(Order(pos+tot+1),root);
    PushSame(ch[ch[root][1]][0],c);
    Updata(ch[root][1]);Updata(root);
}
void Reverse(int pos,int tot){
    Splay(Order(pos),0);
    Splay(Order(pos+tot+1),root);
    PushRev(ch[ch[root][1]][0]);
    Updata(ch[root][1]);Updata(root);
}
int GetSum(int pos,int tot){
    Splay(Order(pos),0);
    Splay(Order(pos+tot+1),root);
    return sum[ch[ch[root][1]][0]];
}
int MaxSum(){
    return mx[root];
}
void Display(int r){
    if(!r) return ;
    Display(ch[r][0]);
    printf("%d ",data[r]);
    Display(ch[r][1]);
}
void Debug(){
    Display(root);
    putchar(10);
}
...
```

---

## 作者：Uniecho1 (赞：1)

做法的话，别的题解说的很清楚了。这里只讲一下易错点。

1. upt**不能直接用来表示要把这个区间清成什么**，而是要表示这个区间是不是都被刷成一个值了（这个破题可以把一段区间刷成0）
2. 区间翻转的时候一定要记得把当前区间左边最大连续和和右边最大连续和交换了（否则就是反的）

嗯就这样吧？边界处理好就是了。

---

## 作者：wycissilly (赞：1)

短Splay


序列翻转就递归交换左右子树即可。


节点node的信息：


$\large{data:权值}$


$\large{sum:以这个点为根的子树的权值和}$


$\large{maxsum:以这个点为根的子树的权值的最大子段和}$


$\large{lazr:序列翻转懒标}$


$\large{lazs:序列赋值懒标}$


$\large{lx\&rx:以这个点为根的子树所代表的序列从右（左）往左（右）数的最大值}$


$\large{siz:以这个点为根的子树的节点数}$


更新公式：


$\Large{a_{sum}=l_{sum}+a_{data}+r_{sum}}$


$\Large{a_{maxsum}=\scriptstyle{max} \textstyle\left\{ l_{maxsum},r_{maxsum},l_{rx}+a_{data}+r_{lx} \right\} }$


$\Large{a_{siz}=l_{siz}+1+r_{siz}}$


$\Large{a_{lx}=\scriptstyle{\max} \textstyle\left\{ l_{lx},l_{sum}+a_{data}+r_{lx} \right\} }$


$\Large{a_{rx}=\scriptstyle{\max} \textstyle\left\{ r_{rx},r_{sum}+a_{data}+l_{rx} \right\} }$


另外，在旋转左右子树时，同时要交换lx,rx;


在进行区间赋值时，要更新lx,rx,maxsum;


$\LARGE{注意：在这种题当中，满足二叉搜索树的是在序列中的位置，而不是权值！！！}$


其他细节详见代码。


``` javascript
#include<iostream>
#include<cstdio>
#define now root->ch[1]->ch[0]
using namespace std;
inline int read(){
    int x=0,f=1;
    int ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int ans;
bool flag;
char ch[11];
typedef int T;
struct node{
    T data,sum,maxsum;
    node *ch[2];
    int siz,lazr,lazs,lx,rx;
    node(T x,node *nu){data=sum=maxsum=x;ch[0]=ch[1]=nu;siz=1;lazr=lazs=0;lx=rx=(x>=0)?x:0;if(nu==NULL){siz=0;maxsum=-0x80000000;}}
    inline void maintain(){
        sum=ch[0]->sum+data+ch[1]->sum;
        siz=ch[0]->siz+1+ch[1]->siz;
        maxsum=max(ch[0]->maxsum,max(ch[1]->maxsum,ch[0]->rx+data+ch[1]->lx));
        lx=max(ch[0]->lx,ch[0]->sum+data+ch[1]->lx);
        rx=max(ch[1]->rx,ch[1]->sum+data+ch[0]->rx);
    }
    inline void pushdown(node *no){
        if(lazs){
            lazs=lazr=0;
            if(ch[0]!=no){ch[0]->lazs=1;ch[0]->data=data;ch[0]->sum=data*ch[0]->siz;}
            if(ch[1]!=no){ch[1]->lazs=1;ch[1]->data=data;ch[1]->sum=data*ch[1]->siz;}
            if(data>=0){
                if(ch[0]!=no)ch[0]->lx=ch[0]->rx=ch[0]->maxsum=ch[0]->sum;
                if(ch[1]!=no)ch[1]->lx=ch[1]->rx=ch[1]->maxsum=ch[1]->sum;
            }else{
                if(ch[0]!=no){ch[0]->lx=ch[0]->rx=0;ch[0]->maxsum=data;}
                if(ch[1]!=no){ch[1]->lx=ch[1]->rx=0;ch[1]->maxsum=data;}
            }
        }
        if(lazr){
            lazr=0;
            if(ch[0]!=no){ch[0]->lazr^=1;swap(ch[0]->lx,ch[0]->rx);swap(ch[0]->ch[0],ch[0]->ch[1]);}
            if(ch[1]!=no){ch[1]->lazr^=1;swap(ch[1]->lx,ch[1]->rx);swap(ch[1]->ch[0],ch[1]->ch[1]);}
        }
    }
}null(0,NULL),*Null=&null,*root;
class Splay{
    private:
        inline void rotate(node *&bt,int d){
            node *tmp=bt->ch[d^1];
            if(bt->lazr)d^=1;
            bt->pushdown(Null);
            tmp->pushdown(Null);
            bt->ch[d^1]=tmp->ch[d];
            tmp->ch[d]=bt;
            bt->maintain();
            tmp->maintain();
            bt=tmp;
        }
        bool splay(node *&to,int x,node *&bt=root,node *&fa=Null){
            if(bt==Null){flag=false;return true;}
            bt->pushdown(Null);
            int d,s=bt->ch[0]->siz;
            bool b;
            if(x<=s)b=splay(to,x,bt->ch[d=0],bt);
            else if(x>s+1)b=splay(to,x-s-1,bt->ch[d=1],bt);
            else{if(bt==to)flag=false;return true;}
            if(!flag)return true;
            if(bt==to)flag=false;
            if(!b)return true;
            if(fa==Null||!flag)rotate(bt,d^1);
            else if(fa->ch[d]==bt){rotate(fa,d^1);rotate(fa,d^1);}
            else{rotate(bt,d^1);rotate(fa,d);}
            return false;
        }
        void insert(T x,node *&bt){
            if(bt==Null){bt=new node(x,Null);return;}
            bt->pushdown(Null);
            insert(x,bt->ch[1]);
            bt->maintain();
        }
        inline void split(int k,node *&bt){flag=true;splay(bt,k);}
        void removetree(node *&bt=now){
            if(bt==Null)return;
            removetree(bt->ch[0]);
            removetree(bt->ch[1]);
            delete bt;
            bt=Null;
        }
        void build(node *&bt,int l,int r){
            int mid=(l+r)>>1;
            bt=new node(0,Null);
            if(l!=mid)build(bt->ch[0],l,mid-1);
            bt->data=read();
            if(mid!=r)build(bt->ch[1],mid+1,r);
            bt->maintain();
        }
    public:
        inline void cut(int l,int n){split(l,root);split(l+n+1,root->ch[1]);}
        inline void insert(int tot){build(now,1,tot);root->ch[1]->maintain();root->maintain();}
        inline void remove(int l,int n){cut(l,n);removetree();root->ch[1]->maintain();root->maintain();}
        inline void reverse(int l,int n){
            cut(l,n);
            if(now->lazs)return;
            now->lazr^=1;
            swap(now->lx,now->rx);
            swap(now->ch[0],now->ch[1]);
            root->ch[1]->maintain();
            root->maintain();
        }
        inline void memset(int l,int n,int c){
            cut(l,n);
            now->lazs=1;
            now->lazr=0;
            now->data=c;
            now->sum=now->siz*c;
            if(c>=0){now->lx=now->rx=now->maxsum=now->sum;}
            else{now->lx=now->rx=0;now->maxsum=c;}
            root->ch[1]->maintain();
            root->maintain();
        }
        inline T getsum(int l,int n){cut(l,n);return now->sum;}
        inline T getmaxsum(){cut(1,root->siz-2);return now->maxsum;}
        Splay(){root=new node(-0x80000000,Null);root->ch[1]=new node(0x7fffffff,Null);root->maintain();}
}sp;
int main(){
    int n=read(),m=read();
    sp.cut(1,0);
    sp.insert(n);
    for(int i=1;i<=m;i++){
        int l,s,c;
        scanf("%s",ch);
        if(ch[0]=='M'&&ch[2]=='X')printf("%d\n",sp.getmaxsum());
        else{
            l=read();
            s=read();
            if(!n){if(ch[0]=='G')printf("0\n");continue;}
            if(ch[0]=='I'){
                sp.cut(l+1,0);
                sp.insert(s);
            }else if(ch[0]=='D')sp.remove(l,s);
            else if(ch[0]=='M'){
                c=read();
                sp.memset(l,s,c);
            }else if(ch[0]=='R')sp.reverse(l,s);
            else if(ch[0]=='G')printf("%d\n",sp.getsum(l,s));
        }
    }
}
```

---


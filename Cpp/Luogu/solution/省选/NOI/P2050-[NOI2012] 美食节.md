# [NOI2012] 美食节

## 题目描述

CZ 市为了欢迎全国各地的同学，特地举办了一场盛大的美食节。

作为一个喜欢尝鲜的美食客，小 M 自然不愿意错过这场盛宴。他很快就尝遍了美食节所有的美食。然而，尝鲜的欲望是难以满足的。尽管所有的菜品都很可口，厨师做菜的速度也很快，小 M 仍然觉得自己桌上没有已经摆在别人餐桌上的美食是一件无法忍受的事情。于是小 M 开始研究起了做菜顺序的问题，即安排一个做菜的顺序使得同学们的等待时间最短。

小 M 发现，美食节共有 $n$ 种不同的菜品。每次点餐，每个同学可以选择其中的**一个菜品**。总共有 $m$ 个厨师来制作这些菜品。当所有的同学点餐结束后，菜品的制作任务就会分配给每个厨师。然后每个厨师就会同时开始做菜。**厨师们会按照要求的顺序进行制作，并且每次只能制作一人份**。

此外，小 M 还发现了另一件有意思的事情——虽然这 $m$ 个厨师都会制作全部的 $n$ 种菜品，但**对于同一菜品，不同厨师的制作时间未必相同**。他将菜品用 $1, 2, \ldots, n$ 依次编号，厨师用 $1, 2, \ldots, m$ 依次编号，将第 $j$ 个厨师制作第 $i$ 种菜品的时间记为 $t_{i,j}$。

小 M 认为：每个同学的等待时间为**所有厨师开始做菜起，到自己那份菜品完成为止**的时间总长度。换句话说，如果一个同学点的菜是某个厨师做的第 $k$ 道菜，则他的等待时间就是这个厨师制作前 $k$ 道菜的时间之和。而**总等待时间**为**所有同学的等待时间之和**。

现在，小 M 找到了所有同学的点菜信息——有 $p_i$ 个同学点了第 $i$ 种菜品（$i=1, 2, \ldots, n$）。他想知道的是最小的总等待时间是多少。


## 说明/提示

厨师 $1$ 先制作 $1$ 份菜品 $2$，再制作 $2$ 份菜品 $1$。点这 $3$ 道菜的 $3$ 个同学的等待时间分别为 $3$，$3+5=8$，$3+5+5=13$。

厨师 $2$ 先制作 $1$ 份菜品 $1$，再制作 $1$ 份菜品 $3$。点这 $2$ 道菜的 $2$ 个同学的等待时间分别为 $7$，$7+9=16$。

总等待时间为 $3+8+13+7+16=47$。

虽然菜品 $1$ 和菜品 $3$ 由厨师 $1$ 制作更快，如果这些菜品都由厨师 $1$ 制作，总等待时间反而更长。如果按上述的做法，将 $1$ 份菜品 $1$ 和 $1$ 份菜品 $3$ 调整到厨师 $2$ 制作，这样厨师 $2$ 不会闲着，总等待时间更短。

可以证明，没有更优的点餐方案。

每组数据的 $n,m$ 和 $p$ 值如下：  

|测试点编号| $n$| $m$| $p$|   
|:------:|:----:|:----:|:----:|    
|$1$|$n = 5$| $m = 5$| $p = 10$|   
|$2$| $n = 40$| $m = 1$ |$p = 400$ |  
|$3$| $n = 40$| $m = 2$ |$p = 300$ |
|$4$| $n = 40$| $m = 40$| $p = 40$ |
|$5$| $n = 5$| $m = 40$| $p = 100$ |
|$6$| $n = 10$| $m = 50$| $p = 200$ |
|$7$| $n = 20$| $m = 60$| $p = 400$ |
|$8$| $n = 40$| $m = 80$| $p = 600$ |
|$9$| $n = 40$| $m = 100$| $p = 800$ |
|$10$| $n = 40$| $m = 100$| $p = 800$ |


对于 $100\%$ 的数据，$n \leq 40$，$m\leq 100$，$p\leq 800$，$t_{i,j}\leq 1000$（其中 $p = \sum p_i$）。


## 样例 #1

### 输入

```
3 2 
3 1 1 
5 7 
3 6 
8 9```

### 输出

```
47```

# 题解

## 作者：Froggy (赞：46)

这是一道非常好的**动态加点**的费用流题目。

是这道题目：[ P2053 [SCOI2007]修车](https://www.luogu.com.cn/problem/P2053) 的加强版。

---

## 建模：

我们先按那道题的思路：**把“厨师”分层**。



如果第 $j$ 个厨师先后做了第 $a_1,a_2,\cdots,a_w$ 种菜，那么等待时间之和就是：

$$t_{a_1,j}w+t_{a_2,j}(w-1)+\cdots+t_{a_w,j}$$

第 $k$ 项的意思是做了第 $k$ 道菜让后面的 $w-k$ 道菜每个都等了 $t_{a_k,j}$ 的时间。

那么我们让第 $j$ 个厨师的第 $w$ 层表示第 $j$ 个厨师做了倒数 $w$ 道菜。方便起见，把它用 $(j,w)$ 表示。$(w\in [1,p])$

它与第 $i$ 道菜连边就表示第 $j$ 个厨师做的倒数第 $t$ 道菜是第 $i$ 种菜。

设源点为 $S$ ，汇点为 $T$ ，菜的编号为 $1\sim n$，”分层厨师“ 就用上面说的 $(j,w)$ 表示。

- 从源点向每道菜连一条流量为 $p_i$，费用为 $0$ 的边，表示第 $i$ 中菜需要做 $p_i$ 道。

- 每个 $(j,w)$ 向汇点连一条流量为 $1$，费用为 $0$ 的边，表示第 $j$ 个厨师做倒数第 $w$ 道菜。

- 每道菜向每个 $(j,w)$ 连一条边权为 $1$，费用为 $t_{i,j}\times w$ 的边，表示第 $i$ 种菜的其中一道是第 $j$ 个厨师做的倒数第 $w$ 道菜，根据开头给出的那个式子可知，它贡献的费用是 $t_{i,j}\times w$。

这样连为什么正确呢？

根据贪心的思想，设第 $j$ 个厨师做了 $w_j$ 道菜，那么被用到的点一定是 $(j,1)\sim (j,w_j)$ 连续的。

假设是断续的，由于中间没有被用到的层需要的费用一定比后面的层所需要的费用小，所以断续的情况一定不是最优的。

这样做点数的规模是 $\mathcal{O}(mp+n)$ 的，边数的规模是 $\mathcal{O}(nmp)$ 的。

根据这个建图，就能获得 $60pts$ 的好成绩！-> [code](https://www.luogu.com.cn/paste/sd9gtsy9)

---

## 优化建图：

其实根据上面的建模可以发现，好多 $(j,w)$ 的点是没有用到的。

根据上述的贪心证明可知：被用到的一定是从 $(j,1)$ 开始的连续的几个层。

那么我们为什么不一边跑流一边加点呢？这样我们就能省去很多无用的点。

我们设第 $j$ 个厨师已经加到了第 $top_j$ 层。若再一次跑流之后，$(j,top_j)$ 被用掉了，那么我们直接把 $(j,top_j+1)$ 加进图里面就好了。

这样点数的规模就降到了 $\mathcal{O}(n+m+p)$，边数的规模降到了 $\mathcal{O}(np)$。

**现在的重点就是怎么判断 $(j,top_j)$ 是否被跑过了：**

我看大部分人写的都是KM，每次只增广一条路，这样很容易判断被用掉的”分层厨师“ 的位置。

其实，多路增广的Dinic也很好判断。有两种方法：

1.直接看与汇点 $T$ 相连的边的流是否被跑满。

2.直接看 $(j,top_j)$ 是否被某一条增广路经过。

第2种实现起来更简单，并且常数小，直接在跑流的时候打标记就好了。

**注意：** 不能类似二分图一样用经过 $(j,top_j)$ 的流的走向去判断，因为可能存在增广路满足经过 $(j,top_j)$ 但下一个节点不是 $T$。所以无论这条增广路的走向如何，只要经过了 $(j,top_j)$ 那么 $(j,top_j)$ 一定被用过。

~~这样说的话是不是方法1更好理解呢qwq~~

Dinic跑费用流超快的呢！开O2时候还不到 1.3s！ [评测记录](https://www.luogu.com.cn/record/30833129)

(我很奇怪为什么现在大部分人跑费用流喜欢用KM）

***code:***

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int inf=0x3f3f3f3f;
#define N 103234
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int m,n,cnt,vis[N],dis[N],c[55][105],p[N],sum,top[N],nxt[N];
int head[N],mincost,S,T;
queue<int> q;
struct Edge{
	int to,nxt,val,cost;
}edge[N<<5];
inline void add(int a,int b,int c,int d){
	++cnt;
	edge[cnt].to=b;
	edge[cnt].val=c;
	edge[cnt].cost=d;
	edge[cnt].nxt=head[a];
	head[a]=cnt;
}
bool SPFA(){
	memset(dis,0x3f,sizeof(dis));
	q.push(S);
	dis[S]=0;
	vis[S]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].to;
			if(edge[i].val&&dis[v]>dis[u]+edge[i].cost){
				dis[v]=dis[u]+edge[i].cost;
				if(!vis[v]){
					q.push(v),vis[v]=1;
				}
			}
		}
	}
	return dis[T]<inf;
}
int dfs(int u,int limit){
	if(u==T)return limit;
	int flow=0;
	vis[u]=1;
	for(int i=head[u];i&&limit;i=edge[i].nxt){
		int v=edge[i].to;
		if(edge[i].val&&!vis[v]&&dis[v]==dis[u]+edge[i].cost){
			int k=dfs(v,min(limit,edge[i].val));
			if(k>0){
				edge[i].val-=k;
				edge[i^1].val+=k;
				limit-=k;
				flow+=k;
				mincost+=k*edge[i].cost;
				nxt[u]=v;
			}
		}
	}
	if(!flow)dis[u]=inf;
	vis[u]=0;
	return flow;
}
inline int ID(int x,int y){
	return (x-1)*sum+y;
}
int Dinic(){
	int maxflow=0;
	while(SPFA()){
		maxflow+=dfs(S,inf);
		for(int j=1;j<=m;j++){
			if(nxt[n+ID(j,top[j])]&&top[j]<sum){//判断是否被一条增广路经过
				++top[j];
				int now=n+ID(j,top[j]);
				for(int i=1;i<=n;i++){
					add(i,now,1,c[i][j]*top[j]);
					add(now,i,0,-c[i][j]*top[j]);
				}
				add(now,T,1,0);
				add(T,now,0,0);
			}
		} 
	}
	return maxflow;
}
int main(){
	n=read(),m=read(),cnt=1;
	for(int i=1;i<=n;i++){
		p[i]=read();sum+=p[i];
	}
	S=m*sum+n+1,T=m*sum+n+2;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			c[i][j]=read();
		}
	}
	for(int i=1;i<=n;i++){
		add(S,i,p[i],0),add(i,S,0,0);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			add(i,n+ID(j,1),1,c[i][j]);
			add(n+ID(j,1),i,0,-c[i][j]);
		}
	}
	for(int i=1;i<=m;i++){
		top[i]=1;
		add(n+ID(i,1),T,1,0);
		add(T,n+ID(i,1),0,0);
	}
	Dinic();
	printf("%d\n",mincost);
	return 0;
}

```


[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!





---

## 作者：litble (赞：42)

# 题目分析

## 建图模型

这题就是P2053修车的数据加强版，那么建图方式也差不多。

对于每个菜建立一个点，源点向其连一条流量为需求量费用为０的边。

然后再建一层点，分别表示第j个厨师做第倒数i道菜。向汇点连一条流量为１费用为０的边。

假设有一个点表示第j个厨师做第倒数k道菜，那么对于菜i，向其连一条流量为１，费用为k×a(i,j)的边。这表示第j个厨师做的倒数第k道菜是菜i，那么就要做a(i,j)这么长的时间，有k个人要等这么长的时间。

意会一下可以发现，这个模型能解决“同时做”问题。

## 优化

由于此题数据量很大，把所有边连完后再跑费用流是一定会GG的（60分）

由于我们跑一次spfa只能找出一次增广路，所以我们可以暂时不连不需要的边。一开始，我们把所有厨师做倒数第１道菜与所有菜连好，然后找一条增广路，这条增广路上一定经过了一个点，表示第j个厨师做倒数第１道菜，于是我们添加点（第j个厨师做倒数第２道菜），与汇点和所有菜连边，以此类推。

意会一下可以发现，这样每次spfa的时候，需要的边都被连上了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005,M=1e7+5,inf=0x3f3f3f3f;//边一定要开大
int m,n,tot=1,sum,S,T,ans;
int p[44],a[44][105],dish[N],cook[N];
int h[N],ne[M],to[M],flow[M],w[M],dis[N],liu[N],pre[N],inq[N];
void add(int x,int y,int z,int c) {
    to[++tot]=y,ne[tot]=h[x],h[x]=tot,flow[tot]=z,w[tot]=c;
    to[++tot]=x,ne[tot]=h[y],h[y]=tot,flow[tot]=0,w[tot]=-c;
}
int bfs() {//费用流：主干部分
    for(int i=S;i<=T;++i) dis[i]=inf,inq[i]=pre[i]=0;
    queue<int>q;int x;
    liu[S]=inf,dis[S]=0,q.push(S);
    while(!q.empty()) {
        x=q.front(),q.pop(),inq[x]=0;
        for(int i=h[x];i;i=ne[i])
            if(flow[i]>0&&dis[x]+w[i]<dis[to[i]]) {
                dis[to[i]]=dis[x]+w[i],pre[to[i]]=i;
                liu[to[i]]=min(liu[x],flow[i]);
                if(!inq[to[i]]) inq[to[i]]=1,q.push(to[i]);
            }
    }
    if(!pre[T]) return 0;
    x=T;
    while(x!=S) {
        int kl=pre[x];
        flow[kl]-=liu[T],flow[kl^1]+=liu[T];
        ans+=w[kl]*liu[T],x=to[kl^1];
    }
    return 1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d",&p[i]),sum+=p[i];
    for(int i=1;i<=n;++i) add(0,i+sum*m,p[i],0);
    S=0,T=sum*m+n+1;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
        scanf("%d",&a[i][j]),add(i+sum*m,(j-1)*sum+1,1,a[i][j]);//预先加上所有菜被厨师倒数第１个做
    for(int i=1;i<=m;++i) add((i-1)*sum+1,T,1,0);//预先加上所有厨师做倒数第１道菜
    for(int i=1;i<=m;++i)
        for(int j=1;j<=sum;++j) {
            int tmp=(i-1)*sum+j;
            dish[tmp]=j,cook[tmp]=i;
            //这是本蒟蒻为了方便解码而写的，表示tmp这个点代表cool[tmp]做倒数第dish[tmp]道菜
        }
    while(bfs()) {
        int tmp=to[pre[T]^1];
        add(tmp+1,T,1,0);//添加新的边，说明见上
        for(int i=1;i<=n;++i)
            add(i+m*sum,tmp+1,1,a[i][cook[tmp]]*(dish[tmp]+1));
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：天泽龟 (赞：28)

# 配合本博客的举例食用口感更佳。

~~一开始标程贴错了，感谢@guodong 指出~~

**题目描述：**

有N个厨师M道菜，每个厨师烧第I道菜要C[I]分钟，问所以菜至少一共等多久？

**题解：**

为了做过的方便回忆所以题面写得大概这样，有很多小细节还要读者自行注意。

先确定基本框架：一个人在不同的状态下可以做不同菜，但是时间会因为你越往后做而累加，这容易让人望分层图上靠，但具体做法又不是很清楚。。

### 我们先考虑不同的顺序造成不同的影响：

	假设有三道菜1，2，3；有一位厨师X，做菜时间分别为C1,C2,C3。
	若这位厨师以213顺序做菜，则总贡献为C2*3+C1*2+C3；
	若这位厨师以321顺序做菜，则总贡献为C3*3+C2*2+C1；
	....
通过以上例子应该就能想到，越在前面做的菜贡献越多，本文章把那个系数定义为`时间戳`。

也就是说在一个时间戳`I`做要花费`C`的菜造成的贡献为`I*C`，那我们就可以对时间戳分层啦！


其他建图都是常规，我们连菜的时候注意流量为菜的数量即可；我们将一个厨师拆成N个点，分别表示在第i个时间戳的厨师。每个厨师都可以向所有菜连边，容量1，然后费用就是`i*c[j]`，均连向超汇。

所以上述样例应该长这样：

![](https://cdn.luogu.com.cn/upload/pic/55493.png)

因为容量是1，所以每个时间戳都只会经过一次，这样就OK啦！

#### 但是这道题要优化？

我们发现这题的点也太多了，开了O2才跑60分~~，这咋爆裂啊？？~~

我们发现之所以这么慢都怪连点太多了，而且太多的状态浪费掉了。

我们依然举例子：
	
	假设有2道菜{1,2,3}，2个厨师{A,B}，分别时间是C[I][J]，让他们比个赛。
	1.假如我们只考虑整个厨房的第一道菜的状况，发现第一个做完第一道菜的是我们的A，他做了1号菜，于是我们继续往后跑A在第二个时间戳的情况。
	但我们发现，此时B还没开始做菜呢！于是此时我们先不急着把B的第二个时间戳加上，还是让他跑第一个时间戳。

	2.于是让比赛继续，我们发现整个厨房做完第二道菜还是A，他又把2号菜给做了。
	你可能会问为啥B到现在都没开始做菜？可能是因为他太菜了，所以做啥菜都慢。。所以我们给A加到第三个时间戳，B仍是第一个。
	
	3.比赛继续，我们发现第三道菜终于是B做了！他做的是3号菜！
	裁判很是感动但并没有给他加上第二个时间戳，因为3道菜全做完了比赛结束，B从头到尾就没有加过新的时间戳。。

![](https://cdn.luogu.com.cn/upload/pic/55494.png)

由上例子我们可看出，本来应该`2*3`个时间戳，如今只剩下了3个，而那便是菜的总数！！

这是多么优良的优化！用图论的说法就是：我们每次跑费用流找增广路的时候，仅增加当前厨师的时间戳，其他厨师等你把当前时间戳的菜做完了再加，这样节点数减少到菜的总数，就可以大大减少不必要的浪费了！

当然也很显然的可以看出，这是基于EK分析的，但如果是Dinic的多路增广也同样适用。

然后就可以AC啦！上丑陋的代码：
```cpp
#include <iostream>
#include <iomanip>
#include <cstring>
#include <map>
#include <queue>
#define inf 2147483646
#define N 10000
using namespace std;

struct ed{
    int u,w,next,f;
}e[1000000];
int g[1000][2000],a[2000];
int n,m,st=1,ans,cost,sm,fir[30000],c[30000],d[30000];
int vis[30000],sp[30000];
queue<int> q; bool v[30000]; 
map<int,int> ha;

void add(int x,int y,int w,int f)
{
    e[++st].u=y; e[st].next=fir[x]; e[fir[x]=st].w=w; e[st].f=f;
    e[++st].u=x; e[st].next=fir[y]; e[fir[y]=st].w=0; e[st].f=-f;
}

bool spfa()
{
    for (int i=0;i<=N;i++) d[i]=inf/2,c[i]=fir[i],v[i]=0;
    q.push(0); v[0]=1; d[0]=0;
    while (!q.empty())
    {
        int k=q.front(); q.pop();  v[k]=0;
        for (int i=fir[k];i;i=e[i].next){
            int u=e[i].u,w=e[i].f;
            if (d[u]>d[k]+w&&e[i].w){
                d[u]=d[k]+w; if (!v[u]) v[u]=1,q.push(u);
            }
        }
    } 
    return (d[N]<inf/2);
}

int dfs(int p,int now)
{
    if (p==N){v[N]=1; return now;}
    int mw=0;  v[p]=1;
    for (int i=fir[p];i;i=e[i].next)
    {
        int u=e[i].u,w=e[i].f; 
        if (d[u]==d[p]+w&&e[i].w&&(!v[u]||u==N))
        if (mw=dfs(u,min(e[i].w,now)))
        {
            e[i].w-=mw; e[i^1].w+=mw; 
            cost+=mw*w; return mw;
        }
    }
}

void dinic()
{
    while (spfa()) {
         ans+=dfs(0,inf);
         for (int i=fir[N];i;i=e[i].next){
         	int u=e[i].u,w=e[i].w;
         	if (w&&!vis[u]) {
         		vis[u]=1; int co=ha[u]; sp[co]++;
         		add(++sm,N,1,0); ha[sm]=co;
         		for (int i=1;i<=n;i++) add(i,sm,1,sp[co]*g[i][co]);
             }
         }
    }
}

int main()
{
    cin>>n>>m; int sum=0;
    for (int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
    for (int i=1;i<=n;i++) 
    for (int j=1;j<=m;j++) cin>>g[i][j];
    
    for (int i=1;i<=n;i++) add(0,i,a[i],0);
    sm=n;
    //for (int k=1;k<=n;k++) 时间K(总数不为n了） 
    for (int j=1;j<=m;j++) {//厨师j 
    	add(++sm,N,1,0); ha[sm]=j; sp[j]=1;
    	for (int i=1;i<=n;i++) add(i,sm,1,g[i][j]); //菜i 
    }
    dinic();
    cout<<cost<<endl; 
}



```

---

## 作者：瞬间。。 (赞：11)

建图别的题解也说得差不多了，我也是看的题解 /dog  

## 我主要想说一下 思路和负环 ##  

noi的题多数是一个比较裸的的东西，加上巧妙的优化就成了一道有区分度的~~好题~~  
这道题也是一样的，先考虑一下每个人的等待时间是什么？？？  
**其实**假如一个厨师一共做了4个菜，花费依次是$c1,c2,c3,c4$,那我现在的等待时间其实就是$4*c1+3*c2+2*c3+c4$,所以我可以得到一个性质，就是每个厨师做菜花费的时间是$1*c1+2*c2+3*c3+...+n*cn$  
那有了这个性质，我显然可以把一个厨师拆成若干个，这样我知道这个厨师的系数k，我把这个厨师的当前状态记为$(i,k)$，我就可以优美且明确的连出一条$c=1,w=cost*k$的一条边给每个菜，因为一个厨师在一个系数的情况下只能用一次，直接从源点来一条$c=1,w=0$即可  
题中说了每种菜有多少个，那我就把每个种类建一个点，再把这个点连给汇点一条$c=p[i],w=0$  

### 这样图就建好了 ###

下来就是模板时间，讲到这里[P2053 修车](https://www.luogu.com.cn/record/43867988)这道题你就会做了，但在这道题中你会拿到60分的tle，常规操作，我现在要考虑如何优化  
tips:如果一个厨师现在$(i,1)$的状态还没用，他会使用$(i,2)$这个状态吗？？？  

显然他不会，但我在建完静态图之后，我傻不拉几的把这些状态都搜了一遍，这样不好，那我是否可以不把这个图全部建出来，而是在每个厨师把$(i,j)$这个状态用完之后再把$(i,j+1)$这个状态建出来,显然可以，那我就先把初始的图建出来，暴力增广，每次增广完之后再把当前用掉的点分裂出新节点。  

然后这道题就完了，我下来主要讲一下如何避免**负环**出现  

我加点的时候如果会出现负环会是什么情况呢
![来自Yazhi很丑的图片](https://cdn.luogu.com.cn/upload/image_hosting/7a986vgs.png)  
显然我的$c1>c2$,如果不满足这个性质，我肯定先增广$c1$,所以其实这样一次一次找增广路动态加边是不会出现负环的

评论区里还有一些错，比如**第三个数据**出现了负环，因为第三个数据把一个厨师的跑满了，它默认把(1,p+1)建出来了，如果你把每个种类的点当作m*p+i，就可能重点导致错误

---

## 作者：xht (赞：11)

题目地址：[P2050 [NOI2012]美食节](https://www.luogu.org/problemnew/show/P2050)

先来讲一下[P2053 [SCOI2007]修车](https://www.luogu.org/problemnew/show/P2053)（如果会做请跳过）

> 同一时刻有 $N$ 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 $M$ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 $M$ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。
> 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。
> $2 \leq M \leq 9,1 \leq N \leq 60,1 \leq T \leq 1000$ 。

#### 费用提前计算

注意到每位车主的等待时间除了跟自己的车所需的维修时间有关之外，还跟同一位技术人员之前维修所花的时间有关，这导致我们很难直观地建模。

但是仔细观察可以发现，一个人维修所花的时间，对同一位技术人员之后的维修造成的影响是已知且固定的。

那么，我们将费用提前计算，即，把第 $i$ 位车主的车由第 $j$ 位维修人员倒数第 $k$ 个维修所花的时间（费用）当作 $k \times t_{i,j}$ 。

从源点向每位车主连边，容量为 $1$ ，费用为 $0$ 。

每位维修人员拆成 $n$ 个点，向汇点连边，容量为 $1$ ，费用为 $0$ 。

第 $i$ 位车主向第 $j$ 位维修人员拆成的第 $k$ 个点连边，容量为 $1$ ，费用为 $k \times t_{i,j}$ 。

求最小费用最大流即可。

回到[P2050 [NOI2012]美食节](https://www.luogu.org/problemnew/show/P2050)

> 此题为 **P2053 [SCOI2007]修车** 的数据加强版。
> $N \leq 40,M \leq 100$ 。

同 **P2053 [SCOI2007]修车** 的建图方式，但是硬求最小费用最大流只能拿到 $60$ 分。

#### 动态开点

起初每个厨师只拆成一个点，每次增广时，把当下的厨师拆出一个新点。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 6, M = 4e7 + 6, inf = 0x3f3f3f3f;
int n, m, s, t, ans, d[N], pre[N], now[N], num, p[N];
int Head[N], Edge[M], Leng[M], Cost[M], Next[M], tot = 1;
bitset<N> v;
int a[46][106];

inline void add(int x, int y, int z, int w) {
	Edge[++tot] = y;
	Leng[tot] = z;
	Cost[tot] = w;
	Next[tot] = Head[x];
	Head[x] = tot;
}

inline bool spfa() {
	v.reset();
	memset(d, 0x3f, sizeof(d));
	queue<int> q;
	q.push(s);
	v[s] = 1;
	d[s] = 0;
	now[s] = inf;
	while (q.size()) {
		int x = q.front();
		q.pop();
		v[x] = 0;
		for (int i = Head[x]; i; i = Next[i]) {
			int y = Edge[i], z = Leng[i], w = Cost[i];
			if (!z || d[y] <= d[x] + w) continue;
			d[y] = d[x] + w;
			now[y] = min(now[x], z);
			pre[y] = i;
			if (!v[y]) {
				q.push(y);
				v[y] = 1;
			}
		}
	}
	return d[t] != inf;
}

inline void upd() {
	ans += d[t] * now[t];
	int x = t;
	while (x != s) {
		int i = pre[x];
		Leng[i] -= now[t];
		Leng[i^1] += now[t];
		x = Edge[i^1];
	}
	x = Edge[pre[t]^1];
	p[++num] = p[x];
	add(num, t, 1, 0);
	add(t, num, 0, 0);
	for (int i = Head[x]; i; i = Next[i]) {
		int y = Edge[i], w = Cost[i^1];
		if (y == t) continue;
		w += a[y][p[x]];
		add(y, num, 1, w);
		add(num, y, 0, -w);
	}
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		int x;
		scanf("%d", &x);
		add(0, i, x, 0);
		add(i, 0, 0, 0);
	}
	num = t = n + m + 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			int x;
			scanf("%d", &x);
			a[i][j] = x;
			add(i, n + j, 1, x);
			add(n + j, i, 0, -x);
		}
	for (int i = 1; i <= m; i++) {
		add(n + i, t, 1, 0);
		add(t, n + i, 0, 0);
		p[n+i] = i;
	}
	while (spfa()) upd();
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Orion545 (赞：7)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8735179.html)

# 正文

先看看这道题

[修车](https://www.luogu.org/problemnew/show/P2053)

仔细理解一下，这两道题是不是一样的？

### 这道题的不同之处

但是有一个区别：本题中每一种车有多个需求，但是这个好办，连边的时候容量涨成$p\lbrack i\rbrack$就好了

但是还有一个区别：数据量变大了-_-

这直接导致了费用流裸做，TLE60分，因为有超过6e6条边

我们得想个办法改进一下

观察可得，这道题里，按照我们的模型，最多出现800条增广路，而且每次增广都是一的流量

也就是说我们实际上跑800次spfa即可

但是spfa和边唯一相关，我们全建好的图中6e6\*800\*k肯定会T

那我们就要想个办法优化边数

### 优化

我们观察发现，第一次spfa得出的最短路肯定是~~某人倒数第一个修某车~~某厨师倒数第一个做某菜，因为倒数第一个肯定比倒数第二个距离短

那么我们可以在一开始建图的时候，只把所有“倒数第一个做的菜”的那些边加上

一旦一条增广路被用掉了（也就是一个厨师-做菜顺序二元组$\left(j,k\right)$被用掉了），那么我们就把所有代表二元组$\left(j,k+1\right)$加上去（一共有n条），再跑spfa

这样我们图中的总边数不会超过$n\ast\sum_{i=1}^n p\lbrack i\rbrack$

也就是总时间在$O\left(np^2\ast k\right)$左右，k是spfa常数

这样就可以过了

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define inf 1e9
#define id(i,j) ((i-1)*p+j+n)
#define left(x) ((x-n-1)/p+1)
#define right(x) ((x-n-1)%p+1)
using namespace std;
inline int read(){
	int re=0,flag=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
} 
int n,m,cnt=-1,first[100010],dis[100010],vis[100010],pre[100010],limit[100010];
struct edge{
	int to,next,w,cap;
}a[10000010];
inline void add(int u,int v,int w,int cap){
	a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
	a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
int q[200010],ans,cost[50][110],p;
bool spfa(int s,int t){
	int head=0,tail=1,u,v,w,i;
	memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
	memset(pre,-1,sizeof(pre));memset(limit,0,sizeof(limit));
	q[0]=s;vis[s]=1;dis[s]=0;limit[s]=inf;
	while(head<tail){
		u=q[head++];vis[u]=0;
		for(i=first[u];~i;i=a[i].next){
			v=a[i].to;w=a[i].w;
			if(a[i].cap&&((dis[v]==-1)||(dis[v]>dis[u]+w))){
				dis[v]=dis[u]+w;
				pre[v]=i;limit[v]=min(limit[u],a[i].cap);
				if(!vis[v]) q[tail++]=v,vis[v]=1;
			}
		}
	}
	return ~dis[t];
}
void mcmf(int s,int t){
	int u,i;
	while(spfa(s,t)){//这里最多sigma(p[i])次
		for(u=t;~pre[u];u=a[pre[u]^1].to){
			a[pre[u]].cap-=limit[t];a[pre[u]^1].cap+=limit[t];
			ans+=limit[t]*a[pre[u]].w;
		}//跑完一次更新答案
		u=a[pre[t]^1].to;//u就是当前消耗的二元组，u+1就是下一个二元组
		add(u+1,t,0,1);
		for(i=1;i<=n;i++) add(i,u+1,cost[i][left(u+1)]*right(u+1),1);//加上对应的下一组边
	}
}
int main(){
	memset(first,-1,sizeof(first));int i,j,t1;
	n=read();m=read();
	for(i=1;i<=n;i++){
		t1=read();p+=t1;
		add(0,i,0,t1);
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			cost[i][j]=read();
			add(i,id(j,1),cost[i][j],1);//初始边
		}
	}
	for(j=1;j<=m;j++) add(id(j,1),n+p*m+1,0,1);
	mcmf(0,n+p*m+1);
	cout<<ans<<endl;
}
```

---

## 作者：qwaszx (赞：5)

神仙题...

前置题目:[修车](https://www.luogu.org/problemnew/show/P2053)

设$p=\sum p_i$即总共需要的菜数

连边方式是把每个厨师拆成$p$个点，从菜$i$向厨师$j$拆成的第$k$个点连一条流量为$1$费用为$k\times t[i][j]$的边.

这个就相当于每个厨师只处理自己做的菜，如果他倒数第$k$个做某菜那么就有$k$个还没吃上菜的人需要等.

然后从$S$向菜$i$连一条$(p[i],0)$的边，从厨师拆成的所有点向$T$连一条$(1,0)$的边.

但是这样复杂度太大了，因为$spfa$的时候很多边是没有用的，你最多只需要增广$p$条路即可，于是我们动态加边，即一开始只把厨师拆成$1$个点，当某个厨师满流的时候，就再拆出一个点，进行连边.

实现上卡了我很久...转了一圈题解没发现什么多路增广+动态加点的...后来自己写居然1A了...提供一种写法吧233

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=7e6,inf=2e9;
int ans=0,vis[N],dis[N],q[N],nxt[N],fst[N],mm,n,m,S,T,x,cur[N],sum,num[N],t[500][500];
struct Edge{int v,w,c;}e[N];
void ade(int u,int v,int w,int c){e[mm]=(Edge){v,w,c};nxt[mm]=fst[u],fst[u]=mm++;}
void Link(int u,int v,int w,int c){ade(u,v,w,c),ade(v,u,0,-c);}
int SPFA(int S,int T)
{
	for(int i=1;i<=T;i++)dis[i]=inf,vis[i]=0;
	dis[S]=0,vis[S]=1,q[1]=S;int head=0,tail=1;
	while(head<tail)
	{
		int u=q[++head];vis[u]=0;
		for(int i=fst[u];i!=-1;i=nxt[i])
		{
			if(!e[i].w)continue;
			int v=e[i].v;
			if(dis[u]+e[i].c<dis[v])
			{
				dis[v]=dis[u]+e[i].c;
				if(!vis[v])q[++tail]=v,vis[v]=1;
			}
		}
	}
	return dis[T]!=inf;
}
int dfs(int S,int T,int lim)
{
	if(S==T||!lim)return lim;
	vis[S]=1;int add=0;
	for(int &i=cur[S];i!=-1&&lim;i=nxt[i])
	{
		int v=e[i].v;
		if(!e[i].w||vis[v]||dis[v]!=dis[S]+e[i].c)continue;
		int f=dfs(v,T,min(lim,e[i].w));
		if(f)add+=f,lim-=f,e[i].w-=f,e[i^1].w+=f,ans+=f*e[i].c;
	}
	vis[S]=0;
	return add;
}
void primal_dual(int S,int T)//事实上我一直不知道我写的费用流叫什么东西...大概不是原始对偶...
{
	int maxflow=0;
	while(maxflow<sum)//所有菜都做完了
	{
		SPFA(S,T);
		for(int i=S;i<=T;i++)cur[i]=fst[i];
		maxflow+=dfs(S,T,inf);//照常写
		for(int i=fst[T];i!=-1;i=nxt[i])//因为终点为T的边不好枚举，所以枚举反向边
		{
			int v=e[i].v;
			if(e[i^1].w)continue;//要满流
			int x=(v-n-1)/sum+1,y=(v-n-1)%sum+1;//把厨师和k找出来
			if(y==num[x]&&num[x]<sum)
			{
				++num[x],++v;Link(v,T,1,0);
				for(int j=1;j<=n;j++)
					Link(j,v,1,(y+1)*t[j][x]);//新边
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<=n;i++)fst[i]=-1;
	for(int i=1;i<=n;i++)scanf("%d",&x),sum+=x,Link(0,i,x,0);
	T=n+m*sum+1;for(int i=n+1;i<=T;i++)fst[i]=-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);t[i][j]=x;
			Link(i,n+(j-1)*sum+1,1,x);num[j]=1;
		}
	for(int i=1;i<=m;i++)Link(n+(i-1)*sum+1,T,1,0);
	primal_dual(0,T);
	printf("%d",ans);
}
```

---

## 作者：Adove (赞：2)

这道题的简化版在 p2035 修车，做完那道题之后再来看这道题吧qwq。

与那道题类似，我们先将厨师拆点，将源点同拆点后的厨师相连，权1费0，将每道菜同汇点相连，权为点菜人数，费用为0。

然后就是最关键的动态加边了——我们先考虑动态加边（切记，不是断边重建，是加边！）的方式。

毫无疑问我们需要对链式前向星进行操作（啥？你问我链式前向星是什么？啊，就是一种连NOI、IOI图论题都会用到的一种非常高效的~~叫做邻接表的~~数据结构。）我们设置数组**num[i]**表示第**i**个厨师做到了倒数第**num[i]**道菜，如果原点到这个点的边流出去了，就连接**s**与**a[i].nx+1**即厨师倒数第**num[i]+1**道菜，连接**a[i].nx+1**与全部的菜，**++num[i]**。

开始循环dinic，当所有菜通往汇点的边流满时，终止循环并输出。

可以证明不存在比终止循环时更优的解（就是**贪心证明**啊qwq，如果存在的话这道菜放在前面做时间肯定会比耽搁一会更优，所以~~是不是有点草率~~不存在）。
上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,m,x,y,s,t,np=1,mct,mfl;
int h[84045],ln[84045],q[550005],w[105][45],cup[45],num[105];
bool vis[84045];
struct rpg{
	int li,nx,ln,ct;
}a[550005];

void add(int ls,int nx,int ln,int ct){
	a[++np]=(rpg){h[ls],nx,ln,ct};
	h[ls]=np;
	a[++np]=(rpg){h[nx],ls,0,-ct};
	h[nx]=np;
}

bool spfa(){
	memset(vis,0,sizeof(vis));
	for(int i=s;i<=t;++i) ln[i]=INF;
	int hd=1,tl=1;
	q[hd]=t;
	ln[t]=0;
	vis[t]=1;
	while(hd<=tl){
		int nw=q[hd++];
		vis[nw]=0;
		for(int i=h[nw];i;i=a[i].li){
			if(a[i^1].ln&&ln[a[i].nx]>ln[nw]-a[i].ct){
				ln[a[i].nx]=ln[nw]-a[i].ct;
				if(!vis[a[i].nx]){
					vis[a[i].nx]=1;
					q[++tl]=a[i].nx;
				}
			}
		}
	}return ln[s]<INF;
}

int dfs(int u,int maxn){
	if(u==t||!maxn) return maxn;
	vis[u]=1;
	int sum=0;
	for(int i=h[u];i;i=a[i].li){
		if(a[i].ln&&!vis[a[i].nx]&&ln[a[i].nx]==ln[u]-a[i].ct){
			int f=dfs(a[i].nx,min(maxn,a[i].ln));
			if(f){
				maxn-=f;
				sum+=f;
				a[i].ln-=f;
				a[i^1].ln+=f;
				if(!maxn) break;
			}
		}
	}return sum;
}

void dnc(){
	while(spfa()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof(vis));
			int d=dfs(s,INF);
			mfl+=d;
			mct+=d*ln[s];
			for(int i=h[0];i;i=a[i].li){
				int tmp1=(a[i].nx-1)/cup[0]+1,tmp2=(a[i].nx-1)%cup[0]+1;
				if(!a[i].ln&&tmp2==num[tmp1]){
					++num[tmp1];
					add(s,a[i].nx+1,1,0);
					for(int j=1;j<=n;++j){
						add(a[i].nx+1,j+m*cup[0],1,w[tmp1][j]*num[tmp1]);
					}
				}
			}
		}
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&cup[i]);
		cup[0]+=cup[i];
	}for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf("%d",&w[j][i]);
		}
	}
	t=m*cup[0]+n+1;
	for(int i=1;i<=n;++i){
		add(i+m*cup[0],t,cup[i],0);
	}for(int i=1;i<=m;++i){
		add(s,(i-1)*cup[0]+1,1,0);
		++num[i];
		for(int j=1;j<=n;++j){
			add((i-1)*cup[0]+1,j+m*cup[0],1,w[i][j]);
		}
	}while(mfl<cup[0]){
		dnc();
	}
	printf("%d\n",mct);
	return 0;
}
```

---

## 作者：至尊无敌 (赞：2)

**【题解】**

费用流+动态加边

刚开始写的单纯的费用流TLE了。

于是只能用一些高大上的东西——动态加点。

其实这道题除了数据范围，与 scoi 2007 修车就是一个题。

建图 源点->所有厨师拆成的点（一个厨师sigma pi ）容量为1，费用为0

每种菜->汇点 容量为1，费用为0

本来应该一个厨师拆成的每个点都与不同的菜连容量为1，费用为t[i][j]×k 的边（k表示倒数第几个做，因为倒数第一做只有这个人需要等,做这个菜的时间不会其他菜） ，但是我们发现其实这些边最后一定有很多是不会走到的。

于是我们刚开始的时候只需要把倒数第一人，即t[i][j]连好就可以了。

每次增广的时候，其实只要一个是做菜的其余都是退菜，所以我们需要找出源点的后一个点，然后计算出他属于哪个厨师做的第几道菜，比如是第一个厨师的第2道菜，那么我们就把所有菜到第一个厨师的第3道菜的边联通，再继续增广就可以了。

摘自https://www.2cto.com/kf/201605/507369.html\*/


**【代码】**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define RepD(i,n) for(int i=n;i>=0;i--)
#define MEM(a) memset(a,0,sizeof(a))
#define MEMI(a) memset(a,127,sizeof(a))
#define MEMi(a) memset(a,128,sizeof(a))
#define INF (2139062143)
#define F (1000000009)
#define MAX_N (400+10)
#define MAX_M (100+10)
#define MAX_P (800+10)
#define MAXN (80400+10)
#define MAXM (720000+2600+10)
#define read(x) { \
                while (!isdigit(c=getchar())); \
                x=c-48; \
                while (isdigit(c=getchar())) x=x*10+c-48; \
                }
typedef long lodefine read(x) { \
                while (!isdigit(c=getchar())); \
                x=c-48; \
                while (isdigit(c=getchar())) x=x*10+c-48; \
                }ng ll;
char c;
int n1,n,s,t,n2,p[MAX_N],tim[MAX_N][MAX_M];
int edge[MAXM],next[MAXM]={0},pre[MAXN]={0},size=1;
ll weight[MAXM],cost[MAXM];
void addedge(int u,int v,int w,int c)
{
   edge[++size]=v;
   weight[size]=w;
   cost[size]=c;
   next[size]=pre[u];
   pre[u]=size;
}
void addedge2(int u,int v,int w,int c){addedge(u,v,w,c),addedge(v,u,0,-c);}
int pre2[MAXN],q[MAXN*8];
int d[MAXN];
int who_cook_num[MAXN][2];
bool b[MAXN]={0};
void SPFA(int s)
{
   memset(d,127,sizeof(d));
   d[s]=0;
   int head=1,tail=1;
   q[1]=s;pre2[s]=0;
   while (head<=tail)
   {
      int now=q[head];b[now]=0;head++;
      Forp(now)
      {
         int &v=edge[p];
         if (weight[p]>0&&edge[p]^s&&d[now]+cost[p]<d[v])
         {
            d[v]=d[now]+cost[p];
            pre2[v]=p;
            if (b[v]) continue;b[v]=1;
            q[++tail]=v;
         }
      }
   }
}
ll costflow(int s)
{
   ll totcost=0,totflow=0;
   while(1)
   {
      SPFA(s);if (d[t]==INF) break;
      ll fl=INF,nowcost=0;
      for(int i=t;i^s;i=edge[pre2[i]^1]) fl=min(fl,weight[pre2[i]]),nowcost+=cost[pre2[i]];
      for(int i=t;i^s;i=edge[pre2[i]^1]) weight[pre2[i]]-=fl,weight[pre2[i]^1]+=fl;
      int whos=edge[pre2[t]^1];
      who_cook_num[++n][0]=who_cook_num[whos][0],who_cook_num[n][1]=who_cook_num[whos][1]+1;
      For(i,n1) addedge2(i,n,1,tim[i][who_cook_num[n][0]]*who_cook_num[n][1]);
      addedge2(n,t,1,0);
      totcost+=fl*nowcost;totflow+=fl;
   }
   return totcost;
}
int main()
{
   read(n1) read(n2)
   int S=0;
   For(i,n1)
   {
      read(p[i]);
      S+=p[i];
   }
   n=n1+n2+2,s=n-1,t=n;
   For(i,n1)
   {
      addedge2(s,i,p[i],0);
   }
   For(i,n2)
   {
      addedge2(n1+i,t,1,0);
      who_cook_num[n1+i][0]=i,who_cook_num[n1+i][1]=1;
   }
   For(i,n1)
      For(j,n2)
      {
         read(tim[i][j]);
         addedge2(i,j+n1,1,tim[i][j]);
      }
   cout<<costflow(s)<<endl;
return 0;
}
```

---

## 作者：Moeebius (赞：1)

## Preface

费用流建模好题！

## Analysis
对于这种 一眼望过去不可做 的神题，我们的第一反应就是网络流/状压 DP。

但是瞅一眼数据范围似乎不是很能状压，我们决定思考网络流。

题目给出了 **容量限制** 和 **权值**，故使用费用流求解。

1. 对于第 $i$ **种**菜，从源点向其连一条「容量为 $p_i$，费用为0」的边，表示这种菜共要做 $p_i$ 份。
2. 仔细思考同一厨师处，每**道**菜对总等待时间的贡献。可以发现，最后一道菜就贡献了 $t'$ 的时间，倒数第二道菜贡献了 $2·t'$，……，倒数第 $k$ 道菜贡献了 $k·t'$ 的时间。（此处 $t'$ 表示在某一厨师处制作这道菜所需的时间）。
3. 所以，对于「交给第 $i$ 位厨师，排在倒数第 $j$ 道菜」这一方案（下简写为 $(i,j)$），从每道菜 $x$ 向其连一条「容量为 $1$，费用为 $t_{x,i}\times j$」的边，表示一种烹饪方案。
4. 最后，对于每种方案 $(i,j)$，向汇点连一条「容量为 $1$，费用为 $0$」的边，表示每位厨师在同一时刻只能做一道菜。

然后跑 MCMF 即可。

> 略讲一下正确性：很显然，MCMF 会跑费用最小的增广路，而越靠前的时间费用也越小，这也意味着跑出来的时间一定是从 $1$ 开始的一段连续区间。

## Optimize

然后你会发现只有 $60$ 分。

发现这样边太多了，考虑优化。

> 「跑出来的时间一定是从 $1$ 开始的一段连续区间」

我们发现，既然需要用到的边都是连续的，而且会有一大堆边用不到，那么为什么不**动态加边**呢？

于是我们每跑完增广路就判断一下走了哪条边，将其「后面」的一条边加上即可。

这样点数是 $O(n+m+p)$ 的，边数是 $O(np)$ 的，即使使用 EK 实现的 SSP 也可以通过本题。

## Code
```cpp
int N,M;
int p[41],P=0,ti[41][101]; // 此处 ti 即题目中的 t

class MCMF // 网络流基本操作
{
	public:
	struct Edge
	{
		int u,v,cap,flow,cost,nxt;
	};
	Edge e[1000001];
	int head[200001],cnt,n,t,s;
	int max_layer[200001],bl[200001];
	void operator() (int __n=0, int __s=0, int __t=0) { n=__n,s=__s,t=__t,cnt=1;  memset(head,0,sizeof(head)); }
	il void __add(int u, int v, int cap, int flow, int cost)
	{
		e[++cnt]=(Edge){u,v,cap,flow,cost,head[u]};
		head[u]=cnt;
	}
	il void add(int u, int v, int cap, int cost)
	{
		__add(u,v,cap,0,cost);
		__add(v,u,cap,cap,-cost);
	}

	int inque[200001],dis[200001],q[200001],front,tail,pre[200001];
	il int spfa()
	{
		memset(inque,0,sizeof(inque));
		memset(dis,-1,sizeof(dis));
		front=tail=1,q[1]=s,inque[s]=1,dis[s]=0;
		while(front<=tail)
		{
			int u=q[front++];inque[u]=0;
			for(int i=head[u]; i; i=e[i].nxt)
			{
				if(e[i].cap-e[i].flow<=0) continue;
				int v=e[i].v,w=e[i].cost;
				if(dis[v]!=-1 && dis[v]<=dis[u]+w) continue;
				dis[v]=dis[u]+w,pre[v]=i;
				// cerr<<v<<" > "<<pre[v]<<' '<<e[pre[v]].u<<endl;
				if(!inque[v]) q[++tail]=v,inque[v]=1;
			}
		}
		// cerr<<" - "<<dis[t]<<endl;
		return dis[t];
	}
	il void print_graph() // 调试用，不用管他
	{
		for(int i=2; i<=cnt; i+=2)
		{
			printf("#%d edge-1 : %d->%d cap %d flow %d cost %d\n",i,e[i].u,e[i].v,e[i].cap,e[i].flow,e[i].cost);
			printf("#%d edge-2 : %d->%d cap %d flow %d cost %d\n\n",i+1,e[i+1].u,e[i+1].v,e[i+1].cap,e[i+1].flow,e[i+1].cost);
		}
	}
	il pii solve()
	{
		// print_graph();
		int ans=0,cost=0,dlt;
		while((dlt=spfa())!=-1)
		{
			int flow=0x7fffffff,cur=t;
			while(cur!=s) flow=min(flow,e[pre[cur]].cap-e[pre[cur]].flow),cur=e[pre[cur]].u;
			ans+=flow,cost+=dlt*flow;
			cur=t;
			while(cur!=s) e[pre[cur]].flow+=flow,e[pre[cur]^1].flow-=flow,cur=e[pre[cur]].u;

			int id=e[pre[t]].u;
			// cerr<<id<<' '<<bl[id]<<endl;
			++max_layer[bl[id]];
			bl[id+1]=bl[id];
			add(id+1,t,1,0);
			For(i,1,N) add(i,id+1,1,ti[i][bl[id+1]]*max_layer[bl[id+1]]); // 动态加边
			// cerr<<endl;
		}
		return mkp(ans,cost);
	}

};

MCMF netGraph;

#define cook(i,j) (N+(i-1)*P+j) // 烹饪方案的二元组

signed main()
{
	read(N,M);
	For(i,1,N) read(p[i]),P+=p[i];
	For(i,1,N) For(j,1,M) read(ti[i][j]);
	netGraph(N+M*P+1,0,N+M*P+1);
	For(i,1,N) netGraph.add(0,i,p[i],0);
	For(i,1,M)
	{
		netGraph.add(cook(i,1),N+M*P+1,1,0);
		netGraph.max_layer[i]=1;
		netGraph.bl[cook(i,1)]=i;
		For(k,1,N) netGraph.add(k,cook(i,1),1,ti[k][i]); // 一开始把第一条边加上去
	}
	cout<<netGraph.solve().second;
	return 0;
}
```

---

## 作者：crashed (赞：1)

# 题目

[点这里](https://www.luogu.com.cn/problem/P2050)看题目。  

# 分析

本题的弱化版便是[[SCOI2007]修车](https://www.luogu.com.cn/problem/P2053)。

考虑现在有 $n$ 份菜给一位厨师做，时间分别为 $t_1,t_2,\dots,t_n$，总等待时间为：  
$$
\sum_{i=1}^n\sum_{j=1}^it_{j}=\sum_{j=1}^nt_j(n-j+1)=\sum_{j=1}^nj\times t_{n-j+1}
$$
由于 $t$ 的顺序任意，所以我们可以将时间分摊到每份菜上面，即可以直接认为第 $i$ 份菜的花费为 $i\times t_i$。

注意到费用同时收菜的种类，厨师身份和做菜顺序三个影响，于是可以想到如下建图方式：

- 对于 $m$ 位厨师，每位厨师拆成 $p$ 个点，点 $(i,j)$ 表示厨师 $i$ 正在做第 $j$ 道菜；对于每个点 $(i,j)$ 连向汇点，容量为 1，费用为 0。 
- 对于 $n$ 道菜，建立 $n$ 个点，源点向第 $i$ 道菜连接边，容量为 $p_i$，费用为 0。
- 对于第 $i$ 道菜和任意个厨师点 $(x,y)$，连接 $i\rightarrow (x,y)$，容量为 1，费用为 $y\times t_{i,x}$。

注意到一个重要的性质：**在费用最小的情况下**，每道菜的制作时间必然会尽量地靠前，因此不会出现做菜中断的情况。

---

但是这里，这种暴力建图方法会......直接 T 飞。

问题很明显，点太多，导致边也太多。我们需要减少点数。

回到性质，可以得出：如果第 $i$ 个厨师都还没有做第 $j$ 道菜，那么他也不可能做 $j+1$ 道， $j+2$ 道以及更多的菜。也即，我们只需要**在图上加入第 $i$ 个厨师的第一道未做的菜**，而剩余的点，则完全可以在做完一道菜之后再加入到图中。

注意本题的 " 做菜 " 实际上就是在图上推流量为 1 的流，所以我们每次推流之后都需要加点。可以发现这样的点数就是 $O(m+p)$，边数就是 $O(n(m+p))$，~~再加上玄学的网络流复杂度~~就可以通过了。

# 代码

```cpp
#include <cstdio>

#define rep( i, a, b ) for( int (i) = (a) ; (i) <= (b) ; ++ (i) )
#define per( i, a, b ) for( int (i) = (a) ; (i) >= (b) ; -- (i) )

typedef long long LL;

const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 5, MAXM = 1e6 + 5;
const int MAXS = 1e3 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ); s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) putchar( '-' ), x = -x;
	if( 9 < x ) write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct Edge
{
	int to, nxt, w, c;
}Graph[MAXM << 1];

int q[MAXN], fro, rea;

int tim[MAXS][MAXS];
int id[MAXS][MAXS], len[MAXS];

int head[MAXN], dist[MAXN], cur[MAXN], bel[MAXN], prev[MAXN];
int N, M, cnt = 1, tot, source, sink;
bool vis[MAXN];

void AddEdge( const int from, const int to, const int C, const int W )
{
	Graph[++ cnt].to = to, Graph[cnt].nxt = head[from];
	Graph[cnt].c = C, Graph[cnt].w = W, head[from] = cnt;
}

void AddE( const int from, const int to, const int C, const int W ) { AddEdge( from, to, C, W ), AddEdge( to, from, 0, -W ); }

#define Nxt( x ) ( x = ( x + 1 ) % MAXN )

bool SPFA( const int S, const int T )
{
	int u, v; fro = rea = 0;
	rep( i, 1, tot ) dist[i] = INF, prev[i] = 0;
	dist[q[rea] = S] = 0, vis[S] = true, Nxt( rea );
	while( fro ^ rea )
	{
		vis[u = q[fro]] = false, Nxt( fro );
		for( int i = head[u] ; i ; i = Graph[i].nxt )
			if( Graph[i].c && dist[v = Graph[i].to] > dist[u] + Graph[i].w )
			{
				dist[v] = dist[u] + Graph[i].w, prev[v] = i;
				if( ! vis[v] ) vis[q[rea] = v] = true, Nxt( rea );
			}
	}
	return dist[T] < INF;
}

void Add( const int j )
{
	bel[id[j][++ len[j]] = ++ tot] = j;
	rep( i, 1, N ) AddE( i, id[j][len[j]], 1, tim[i][j] * len[j] );
	AddE( id[j][len[j]], sink, 1, 0 );
}

int main()
{
	read( N ), read( M ), tot = N, source = ++ tot, sink = ++ tot;
	rep( i, 1, N ) { int p; read( p ), AddE( source, i, p, 0 ); }
	rep( i, 1, N ) rep( j, 1, M ) read( tim[i][j] );
	rep( j, 1, M ) Add( j );
	
	LL cost = 0; int delt;
	while( SPFA( source, sink ) )
	{
		delt = INF;
		for( int u = sink ; u ^ source ; u = Graph[prev[u] ^ 1].to ) delt = MIN( delt, Graph[prev[u]].c );
		for( int u = sink ; u ^ source ; u = Graph[prev[u] ^ 1].to ) Graph[prev[u]].c -= delt, Graph[prev[u] ^ 1].c += delt;
		cost += delt * dist[sink], Add( bel[Graph[prev[sink] ^ 1].to] );
	}
	write( cost ), putchar( '\n' );
	return 0;
}
```



---

## 作者：kkxhh (赞：1)

假设第 $i$ 个厨师总共做 $s$ 道菜，那么做这些菜的总花费时间为 $\sum_{j=1}^{s} (s-j+1)t_{i,j}$

于是我们可以将每个厨师拆成 $p$ 个节点，每个节点到 $t$ 连一条容量为 $1$，费用为 $0$ 的边，其中连到第 $i$ 个点的边的费用乘上 $i$。同时对每道菜从 $s$ 连过来一条容量为需求的边，然后连上菜肴和厨师之间的边

这样建图肯定是可以得出正确答案的，然而我们看一下数据范围，这样总点数将会是 $n * m * p$ 个，同时还要跑 $p$ 遍 $spfa$，显然是会超时的

于是我们考虑怎么优化这个过程

可以发现每次 $spfa$ 的时候，我们都是找到一条最短的路径然后推流，而显然厨师后面的点在前面的点被使用之前是不可能在最短路上的，于是我们可以考虑一边跑 $spfa$ 一边加边，只在一个厨师被使用后我们才加上他的下一个节点

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;

typedef struct edge{
    int from,to,cap,cost,next,chef;
}edge;

const int INF=100000000;
edge e[2000010];
int n,m,s=40001,t=40002,head[40010],tot=1,c[40010],p[40010],f[40010],inque[40010],flow,cost,ti[50][110],w[50],cnt,r[110];

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

void addedge(int u,int v,int cap,int cost,int chef){
    e[++tot].from=u; e[tot].to=v; e[tot].cap=cap; e[tot].cost=cost; e[tot].chef=chef; e[tot].next=head[u]; head[u]=tot;
    e[++tot].from=v; e[tot].to=u; e[tot].cap=0; e[tot].cost=-cost; e[tot].chef=chef; e[tot].next=head[v]; head[v]=tot;
}

int spfa(){
    for(int i=1;i<=cnt;i++) p[i]=f[i]=0,c[i]=INF;
    p[t]=f[t]=0; c[t]=INF;
    queue<int> q;
    q.push(s); inque[s]=1; c[s]=0; f[s]=INF;
    while(!q.empty()){
        int x=q.front(); q.pop(); inque[x]=0;
        for(int i=head[x],to=e[i].to;i;i=e[i].next){
            to=e[i].to;
            if(e[i].cap && e[i].cost+c[x]<c[to]){
                c[to]=e[i].cost+c[x]; p[to]=i; f[to]=min(f[x],e[i].cap);
                if(!inque[to]) {q.push(to); inque[to]=1;}
            }
        }
    }
    return f[t];
}

void solve(){
    for(int i=1;i<=n;i++) addedge(s,++cnt,w[i],0,0);
    cnt++;
    for(int i=1;i<=m;i++,cnt++){
        for(int j=1;j<=n;j++) addedge(j,cnt,1,ti[j][i],0);
        addedge(cnt,t,1,0,i); r[i]=1;
    }
    while(spfa()){
        flow+=f[t]; cost+=f[t]*c[t];
        for(int i=p[t];i;i=p[e[i].from]) e[i].cap-=f[t],e[i^1].cap+=f[t];
        int chef=e[p[t]].chef; cnt++; r[chef]++;
        for(int i=1;i<=n;i++) addedge(i,cnt,1,ti[i][chef]*r[chef],0);
        addedge(cnt,t,1,0,chef);
    }
    return;
}

int main(){
    n=read(); m=read();
    for(int i=1;i<=n;i++) w[i]=read();
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) ti[i][j]=read();
    solve();
    printf("%d",cost);
    return 0;
}

```

---

## 作者：CmsMartin (赞：0)

## 思路

[题目传送门](https://www.luogu.com.cn/problem/P2050)

[更好的阅读体验](http://www.cmsblog.top/archives/noi2012-mei-shi-jie)

考虑费用流。

首先费用提前计算，第 $j$ 个厨师倒数第 $k$ 个做第 $i$ 道菜的费用是 $k \times t_{i,j}$，因为最后的 $k$ 个人都需要等待这一道菜。

开始建图。

1. 每道菜向源点连一条容量为 $p_i$ 费用为 $0$ 的边；

2. 每个厨师拆成 $n$ 个点，向汇点连一条容量为 $1$ 费用为 $0$ 的点。

3. 第 $i$ 道菜向第 $j$ 个初始所拆出来的第 $k$ 个点连一条容量为 $1$ 费用为 $k \times t_{i,j}$ 的边。

然后跑一次 MCMF。

这样子可以获得 $60$ 分的高分。

这里有一个 trick 叫做**动态开点**。

由于我们每次跑 SPFA 增广，只能找出一条增广路，所以我们可以暂时不连不需要的边。一开始我们将每个厨师拆成一个点进行连边，在遍历增广路的时候我们对每个厨师添加下一个点，并按照上述第 $3$ 个连边方式连边。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 10, MAXM = 4e7 + 10;
const int INF = 0x3f3f3f3f;

int N, M;

struct _ {
    int To, Next, Flow, Cost;
} G[MAXN];
int Head[MAXN], Cnt = 1;

void _add(int u, int v, int w, int c) {
    G[++Cnt] = {v, Head[u], w, c};
    Head[u] = Cnt;
}

void Add(int u, int v, int w, int c) {
    _add(u, v, w, c);
    _add(v, u, 0, -c);
}

int Dist[MAXN], Pre[MAXN], Incf[MAXN];
bool Vis[MAXN];
int T, S;

bool SPFA() {
    memset(Dist, 0x3f, sizeof Dist);
    queue<int> q;
    q.push(S);
    Vis[S] = true;
    Dist[S] = 0;
    Incf[S] = INF;
    Incf[T] = 0;
    while (q.size()) {
        int u = q.front();
        q.pop();
        Vis[u] = false;
        for (int i = Head[u]; i; i = G[i].Next) {
            const int &v = G[i].To, &w = G[i].Flow, &c = G[i].Cost;
            if (!w || Dist[v] <= Dist[u] + c) continue;
            Dist[v] = Dist[u] + c;
            Incf[v] = min(w, Incf[u]);
            Pre[v] = i;
            if (!Vis[v]) {
                q.push(v);
                Vis[v] = true;
            }
        }
    }
    return Incf[T];
}

int MaxFlow, MinCost;
int P[MAXN], A[50][150], CYB;

void UpDate() {
    MaxFlow += Incf[T];
    MinCost += Dist[T] * Incf[T];
    int x = T;
    while (x != S) {
        int i = Pre[x];
        G[i].Flow -= Incf[T];
        G[i ^ 1].Flow += Incf[T];
        x = G[i ^ 1].To;
    }
    x = G[Pre[T] ^ 1].To;
    P[++CYB] = P[x];
    Add(CYB, T, 1, 0);
    for (int i = Head[x]; i; i = G[i].Next) {
        int v = G[i].To, w = G[i ^ 1].Cost;
        if (v == T) continue;
        w += A[v][P[x]];
        Add(v, CYB, 1, w);
    }
}

void MCMF() {
    while (SPFA()) UpDate();
}

int main() {
    scanf("%d %d", &N, &M);
    S = 0, T = CYB = N + M + 1;
    for (int i = 1, x; i <= N; i++) {
        scanf("%d", &x);
        Add(S, i, x, 0);
    }
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            scanf("%d", &A[i][j]);
            Add(i, N + j, 1, A[i][j]);
        }
    }
    for (int i = 1; i <= M; i++) {
        Add(N + i, T, 1, 0);
        P[N + i] = i;
    }
    MCMF();
    cout << MinCost << endl;
}
```

---

## 作者：你祖奶我很ok (赞：0)

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define inf 1e9
#define id(i,j) ((i-1)*p+j+n)
#define left(x) ((x-n-1)/p+1)
#define right(x) ((x-n-1)%p+1)
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
} 
int n,m,cnt=-1,first[100010],dis[100010],vis[100010],pre[100010],limit[100010];
struct edge{
    int to,next,w,cap;
}a[10000010];
inline void add(int u,int v,int w,int cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
int q[200010],ans,cost[50][110],p;
bool spfa(int s,int t){
    int head=0,tail=1,u,v,w,i;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    memset(pre,-1,sizeof(pre));memset(limit,0,sizeof(limit));
    q[0]=s;vis[s]=1;dis[s]=0;limit[s]=inf;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i].cap&&((dis[v]==-1)||(dis[v]>dis[u]+w))){
                dis[v]=dis[u]+w;
                pre[v]=i;limit[v]=min(limit[u],a[i].cap);
                if(!vis[v]) q[tail++]=v,vis[v]=1;
            }
        }
    }
    return ~dis[t];
}
void mcmf(int s,int t){
    int u,i;
    while(spfa(s,t)){//这里最多sigma(p[i])次
        for(u=t;~pre[u];u=a[pre[u]^1].to){
            a[pre[u]].cap-=limit[t];a[pre[u]^1].cap+=limit[t];
            ans+=limit[t]*a[pre[u]].w;
        }//跑完一次更新答案
        u=a[pre[t]^1].to;//u就是当前消耗的二元组，u+1就是下一个二元组
        add(u+1,t,0,1);
        for(i=1;i<=n;i++) add(i,u+1,cost[i][left(u+1)]*right(u+1),1);//加上对应的下一组边
    }
}
int main(){
    
        for(j=1;j<=m;j++){
            cost[i][j]=read();
            add(i,id(j,1),cost[i][j],1);//初始边
        }
    }
    for(j=1;j<=m;j++) add(id(j,1),n+p*m+1,0,1);
    mcmf(0,n+p*m+1);
    cout<<ans<<endl;
}
```
30分
```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define inf 1e9
#define id(i,j) ((i-1)*p+j+n)
#define left(x) ((x-n-1)/p+1)
#define right(x) ((x-n-1)%p+1)
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
} 
int n,m,cnt=-1,first[100010],dis[100010],vis[100010],pre[100010],limit[100010];
struct edge{
    int to,next,w,cap;
}a[10000010];
inline void add(int u,int v,int w,int cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
int q[200010],ans,cost[50][110],p;
bool spfa(int s,int t){
    int head=0,tail=1,u,v,w,i;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    memset(pre,-1,sizeof(pre));memset(limit,0,sizeof(limit));
    q[0]=s;vis[s]=1;dis[s]=0;limit[s]=inf;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i].cap&&((dis[v]==-1)||(dis[v]>dis[u]+w))){
                dis[v]=dis[u]+w;
                pre[v]=i;limit[v]=min(limit[u],a[i].cap);
                if(!vis[v]) q[tail++]=v,vis[v]=1;
            }
        }
    }
    return ~dis[t];
}
void mcmf(int s,int t){
    int u,i;
    while(spfa(s,t)){//这里最多sigma(p[i])次
        for(u=t;~pre[u];u=a[pre[u]^1].to){
            a[pre[u]].cap-=limit[t];a[pre[u]^1].cap+=limit[t];
            ans+=limit[t]*a[pre[u]].w;
        }//跑完一次更新答案
        u=a[pre[t]^1].to;//u就是当前消耗的二元组，u+1就是下一个二元组
        add(u+1,t,0,1);
        for(i=1;i<=n;i++) add(i,u+1,cost[i][left(u+1)]*right(u+1),1);//加上对应的下一组边
    }
}
int main(){
    memset(first,-1,sizeof(first));int i,j,t1;
    n=read();m=read();
    for(i=1;i<=n;i++){
        t1=read();p+=t1;
        add(0,i,0,t1);
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            cost[i][j]=read();
            add(i,id(j,1),cost[i][j],1);//初始边
        }
    }
    for(j=1;j<=m;j++) add(id(j,1),n+p*m+1,0,1);
    mcmf(0,n+p*m+1);
    cout<<ans<<endl;
}
```
100分


---


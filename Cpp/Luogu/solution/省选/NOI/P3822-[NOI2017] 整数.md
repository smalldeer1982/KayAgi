# [NOI2017] 整数

## 题目背景

在人类智慧的山巅，有着一台字长为 $1\,048\,576$ 位（此数字与解题无关）的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你...


## 题目描述

P 博士将他的计算任务抽象为对一个整数的操作。

具体来说，有一个整数 $x$，一开始为 $0$。

接下来有 $n$ 个操作，每个操作都是以下两种类型中的一种：

- `1 a b`：将 $x$ 加上整数 $a\cdot 2^b$，其中 $a$ 为一个整数，$b$ 为一个非负整数

- `2 k` ：询问 $x$ 在用二进制表示时，位权为 $2^k$ 的位的值（即这一位上的 $1$ 代表 $2^k$）

保证在任何时候，$x\geqslant 0$。

## 说明/提示

在所有测试点中，$1\leqslant t_1 \leqslant 3, 1 \leqslant t_2 \leqslant 4, 1 \leqslant t_3 \leqslant 2$。不同的 $t_1, t_2, t_3$ 对应的特殊限制如下：

- 对于 $t_1 = 1$ 的测试点，满足 $a = 1$；
- 对于 $t_1 = 2$ 的测试点，满足 $|a| = 1$；
- 对于 $t_1 = 3$ 的测试点，满足 $|a| \leqslant 10^9$；
- 对于 $t_2 = 1$ 的测试点，满足 $0 \leqslant b, k \leqslant 30$；
- 对于 $t_2 = 2$ 的测试点，满足 $0 \leqslant b, k \leqslant 100$；
- 对于 $t_2 = 3$ 的测试点，满足 $0 \leqslant b, k \leqslant n$；
- 对于 $t_2 = 4$ 的测试点，满足 $0 \leqslant b, k \leqslant 30n$；
- 对于 $t_3 = 1$ 的测试点，保证所有询问操作都在所有修改操作之后；
- 对于 $t_3 = 2$ 的测试点，不保证询问操作和修改操作的先后顺序。

本题共 25 个测试点，每个测试点 4 分。各个测试点的数据范围如下：

::cute-table{tuack}

| 测试点编号 | $n \le$ | $t_1$ | $t_2$ | $t_3$ |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $3$ | $1$ | $2$ |
| $2$ | $100$ | $3$ | $2$ | $2$ |
| $3$ | $2000$ | $3$ | $2$ | $2$ |
| $4$ | $4000$ | $1$ | $3$ | $2$ |
| $5$ | $6000$ | $3$ | $3$ | $1$ |
| $6$ | $8000$ | $2$ | $3$ | $2$ |
| $7$ | $9000$ | $3$ | $4$ | $2$ |
| $8$ | $10000$ | $3$ | $3$ | $2$ |
| $9$ | $30000$ | $3$ | $4$ | $2$ |
| $10$ | $50000$ | $3$ | $4$ | $1$ |
| $11$ | $60000$ | $3$ | $3$ | $2$ |
| $12$ | $65000$ | $2$ | $4$ | $2$ |
| $13$ | $70000$ | $3$ | $4$ | $2$ |
| $14$ | $200000$ | $3$ | $4$ | $2$ |
| $15$ | $300000$ | $2$ | $4$ | $2$ |
| $16$ | $400000$ | $3$ | $4$ | $2$ |
| $17$ | $500000$ | $3$ | $3$ | $2$ |
| $18$ | $600000$ | $3$ | $4$ | $2$ |
| $19$ | $700000$ | $3$ | $4$ | $2$ |
| $20$ | $800000$ | $1$ | $4$ | $2$ |
| $21$ | $900000$ | $2$ | $4$ | $2$ |
| $22$ | $930000$ | $3$ | $3$ | $2$ |
| $23$ | $960000$ | $3$ | $4$ | $1$ |
| $24$ | $990000$ | $3$ | $3$ | $2$ |
| $25$ | $1000000$ | $3$ | $4$ | $2$ |

## 样例 #1

### 输入

```
10 3 1 2
1 100 0
1 2333 0
1 -233 0
2 5
2 7
2 15
1 5 15
2 15
1 -1 12
2 15```

### 输出

```
0
1
0
1
0```

# 题解

## 作者：shadowice1984 (赞：34)

先膜一波楼下用2^30，2^60,2^16进制的julao
_________________

其实我们发现有个神奇的东西叫unsinged int，通过这个神奇的东西我们可以轻而易举的绕开高精度的乱七八糟的分类讨论，那么介绍在这里介绍一个非常神奇的算法好了……
_____________
## 本题题解

### 前置芝士:二进制计数器的均摊复杂度

在《算法导论》的摊还分析一节举了一个小栗子，一个二进制计数器，如果暴力的每次给它加1，每次做高精度加法的话，我们会发现它的均摊复杂度是$O(1)$而不是$O(logn)$具体证明是考虑每个对于每个二的整次幂我们其实仅仅做了$O(n)$次操作，只是多了一个大概是2的常数，而一个任意数和最接近它的二的整次幂最多差2倍，因此我们可以证明n次暴力高精加1的单次复杂度是均摊$O(1)$的

_____________

### 局限性

但是如果你对均摊的复杂度略有了解的话，会知道均摊的复杂度有一个问题，它不支持回撤……，因为均摊复杂度意味着有一步或者多步的复杂度将会很高，高出了平均复杂度，而如果我们反复回撤这几步我们就会华丽的T飞掉

但问题这道题就是让我们支持减去一个数，而这和回撤没什么区别……

此时继续使用暴力，先不管空间的问题，我们会发现减去的数可能会让我们反复回撤几个非常高复杂度的步骤，此时我们就T飞了

或者还有更坏的情况，考虑下面这个操作，先让第$10^6$位加1，然后在第一位减1，这会立即导致我们做$10^6$个操作，如果我们接下来的$10^6$个操作里每次反复加1或者减1的话我们会反复重复这些操作……然后我们就会T的飞起

---------------------------

## 解决

所以我们唯一的做法就是对于加法和减法分别用暴力维护它们的绝对值，这样才能保证复杂度的正确性

但是我们发现这样每一次加法需要拆成$O(log{10^9})$的加1，显然复杂度还是带一个$log$会T飞……e

所有我们需要想一些奇技淫巧来帮助我们加速……

于是我们想到了神奇的unsigned int，我们可以将这个非常大的数使用unsigned int 每32位分成一个小块，这样原来的第b位就变成了第$b/32$个数的第$b\%32$位，然后我们发现因为a的值不是很大，因此每次最多对两个unsigned int数进行暴力的高精度加法，复杂度变成了均摊$O(1)$，或者你可以理解成进行进行了$2^{32}$进制表示也可以。

那么具体实现的时候我们直接对unsigned int进行无脑加法使其自然溢出即可，然后对于判断进位这个有一个奇技淫巧，因为加的数不超过unsigned int，因此我们直接判断加之前和之后的大小，如果越加越小就可以认为是进了一位，跳到下一个块去做加法，然后我们就可以以均摊$O(n)$的复杂度分别维护正的部分和负的部分

现在我们要处理询问了……

显然我们是不可以无脑提取出来正的这一位01值与负的这一位01值然后无脑相减的……，因为这样我们会少考虑一个非常关键的问题，借位，如果发生了借位，那么0会变成1，1会变成0……

是否发生借位当然也非常简单了，只需要比较这个位置之后的后缀数字是正的大还是负的大就行了……

等等……$10^6$长度的数你让我比较大小？

所以我们比较两个后缀的大小其实有点像比较字符串大小，找到第一个在位置b之后不等的位置然后比较大小即可了……

问题来了，如何找到第一个不等的位置呢？

这个问题有点像lower\_bound的查找，但是我们要支持动态的维护不等的位置

好像set就可以维护？

因为我们修改的32位块最多O(n)个，所以我们大可以修改一个块就检查一下是否和对应的正块或者负块相等，然后在set里erase或者insert这个块的编号，然后我们查找第一个不等位置的时候直接lower\_bound出这个块的编号，然后两个unsigned int进行大小比较即可

注意我们可能需要特判一下不是整块的部分，这个时候我们直接膜一下提取出这个部分就可以啦~

另外不知道为什么我不支持>>32这个操作……，所以我是通过>>31然后>>1实现的^

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;const int N=1e6+10;typedef unsigned int uit;
uit inc[N];uit dec[N];set <int> s;int n;int t1;int t2;int t3;
int main()
{
	scanf("%d%d%d%d",&n,&t1,&t2,&t3);set <int>::iterator it;
	for(int i=1,t,a,b;i<=n;i++)
	{
		scanf("%d",&t);
		if(t==1)
		{
			scanf("%d%d",&a,&b);int p=b/32;int q=b%32;//先转换成块上位置 
			if(a>0)
			{
				uit st=(uit)a<<q;uit ic=(uit)a>>(31-q);ic>>=1;//无脑高精加 
				uit od=inc[p];inc[p]+=st;ic+=(od>inc[p]);//处理下set 
				if(inc[p]^dec[p])s.insert(p);else if(s.count(p))s.erase(p);p++;
				while(ic!=0)
				{
					od=inc[p];inc[p]+=ic;ic=(od>inc[p]);//判断进位 
					if(inc[p]^dec[p])s.insert(p);else if(s.count(p))s.erase(p);p++;
				}
			}
			else if(a<0)//负的是一样的 
			{
				a=-a;
				uit st=(uit)a<<q;uit ic=(uit)a>>(31-q);ic>>=1;//这里提取不出来>>32可以>>31然后>>1 
				uit od=dec[p];dec[p]+=st;ic+=(od>dec[p]);
				if(inc[p]^dec[p])s.insert(p);else if(s.count(p))s.erase(p);p++;
				while(ic!=0)
				{
					od=dec[p];dec[p]+=ic;ic=(od>dec[p]);
					if(inc[p]^dec[p])s.insert(p);else if(s.count(p))s.erase(p);p++;
				}
			}
		}
		else 
		{
			scanf("%d",&b);int p=b/32;int q=b%32;int ans=((inc[p]>>q)^(dec[p]>>q))&1;//两个位置无脑相减 
			uit v1=inc[p]%(1<<q);uit v2=dec[p]%(1<<q);//提取非整段部分 
			if(v1<v2){printf("%d\n",ans^1);}//需要借位 
			else if(v1>v2||s.empty()||p<=*(s.begin())){printf("%d\n",ans);}//判断下无需借位的情况 
			else 
			{
				it=s.lower_bound(p);--it;//lower_bound出前驱(自己的不严格后继--) 
				if(inc[*it]>dec[*it]){printf("%d\n",ans);}//比较大小 
				else {printf("%d\n",ans^1);}//输出 
			}
		}
	}return 0;//拜拜程序~ 
}
```









---

## 作者：大头 (赞：27)

首先将加和减分开统计，只要比较后缀大小就行

如何比较后缀大小？暴力找到下一个不等的位置。

于是我们用set维护不等的位置，每次查找以下就可以了。

时间复杂度是O（L log L）

其中L表示数字最大位数

然后我们发现时间复杂度在于修改。

我们考虑二进制优化。

我们将数字每16个分成一位。

每次修改是修改块内是为不同的数字个数

然后用set维护每一块内是否有不同的数字

每次询问我们先在当前块中查询。

如果没有则在上一个有不同数字的块中查找。

时间复杂度：修改：O（N\*30）

查询：O（N\*（16+logN））

总体时间复杂度O（NlogN）

在发帖时bzoj排rk4，UOJ排rk3,洛谷rk1

··· cpp

```cpp
#include<bits/stdc++.h>
#define N 30000005
using namespace std;
const int L=200005;
char LZH[L],*S=LZH,*T=LZH;
inline char gc(){
    if (S==T){
        T=(S=LZH)+fread(LZH,1,L,stdin);
        if (S==T) return EOF;
    }
    return *S++;
}
inline int read(){
    int x=0,f=1;
    char c=gc();
    for (;c<'0'||c>'9';c=gc())
        if (c=='-') f=-1;
    for (;c>='0'&&c<='9';c=gc())
        x=(x<<1)+(x<<3)+c-48;
    return x*f;
}
int n,x,y;
bool fl,a[N],b[N];
struct ZYY_CMP{
    bool operator ()(const int &x,const int &y){
        return x>y;
    }
};
struct ZYY_SET{
    int cnt[2000005];
    set<int,ZYY_CMP> S;
    ZYY_SET(){
        S.insert(-1);
        memset(cnt,0,sizeof(cnt));
    }
    void insert(int x){
        x+=16;
        if (!cnt[x>>4]) S.insert(x>>4);
        cnt[x>>4]++;
    }
    void erase(int x){
        x+=16;
        cnt[x>>4]--;
        if (!cnt[x>>4]) S.erase(x>>4);
    }
    int query(int x){
        if (x<0) return -2;
        x+=16;
        for (int i=x;i>=((x>>4)<<4)&&i>=16;i--)
            if (a[i-16]^b[i-16]) return i-16;
        int y=*S.lower_bound((x>>4)-1);
        if (y==-1) return -2;
        for (int i=(y<<4)+15;i>=(y<<4)&&i>=16;i--)
            if (a[i-16]^b[i-16]) return i-16;
        return -2;
    }
}Set;
inline void add(){
    bool tg=1;
    for (int i=y;i<=n*30&&((tg^1)||x);i++,x/=2){
        if ((tg^1)^(x&1)){
            if (a[i]^b[i]) Set.erase(i);
            else Set.insert(i);
            if (fl) tg=(a[i]^=1);
            else tg=(b[i]^=1);
        }
        else
            tg=((tg^1)&&(x&1))^1;
    }
}
int main(){
    n=read(); read(); read(); read();
    Set.insert(-2);
    for (int i=1;i<=n;i++){
        if (read()==1){
            x=read(); y=read();
            fl=(x>0); x=x<0?-x:x;
            add();
        }
        else{
            x=read(); y=Set.query(x-1);
            putchar((a[x]^b[x]^(y!=-2&&!a[y]))+'0'); puts("");
        }
    }
}
···
```

---

## 作者：UnyieldingTrilobite (赞：17)

参考资料：<https://codeforc.es/blog/entry/115626>。代码实现上比文中示例更加精细，从而得到了更优的复杂度。

这是一个只需要 `std::map` 的低门槛单 $\log$ 代码不到 1k 的做法，作为代价，常数会~~略~~巨大。

我们考虑直接暴力维护这个二进制数，暴力加，暴力进位，查询就直接查，那么在加法不带负数的情况下实际上复杂度是很对的——为什么？我们考虑 $a$ 恒为 1 的情况，那么唯一复杂度可能出问题的点就是触发连续进位，但问题是每次连续进位的触发会恰消耗一个二进制位上的 1，而每次暴力加会恰增加一个二进制位上的 1。换而言之，连续进位的代价摊下来仅仅是常数而已。回到 $a$ 不一定等于 1，我们发现进位的过程其实可以看成是仅仅把 $a$ 拆成了 $\log$ 个不同位上的 1 加过去了而已。复杂度一个 $\log$，非常便捷。

那么我们回到原题，$a$ 可以是负数了。我们发现退位是可以批量产生二进制位上的 $1$ 的，而消耗同样可以批量产生的 0，这会破坏我们的时间复杂度。我们希望，不要有两个可以批量产出的对象可以互相转化，那我们的做法就对了。我们考虑到原来的做法，可能并不希望 0 成为消耗品。那么我们考虑把 0 减去 1 的时候，不要对整个数的结构产生过大的影响。于是我们可以扩展一下每一位的值，从 $\{0,1\}$ 扩展到 $\{0,1,-1\}$。这个时候，我们连续进位消耗 1，连续退位消耗 -1，而这两者都是不可以批量产出的。于是我们的时间复杂度已经没有问题（指低于平方）了。

至于求给定位上的值，这个事情是显而易见的，我们只需要关心一下给定位上的数码和他的低位中最高位的那一个非 0 数码就可以了。我们可以用 `std::map` 维护非 0 数码集合，这样就可以快速找到前驱了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, t1, t2, t3;
map<int, int> mp;
void add(int v, int p) {
  mp[p] += v;
  while (true) {
    int d = mp[p] / 2;
    if (!(mp[p] %= 2)) mp.erase(p);
    if (!d) return;
    mp[++p] += d;
  }
}
int query(int p) {
  auto it = mp.lower_bound(p);
  int v = it != mp.end() && it->first == p ? it->second & 1 : 0;
  if (it != mp.begin()) v ^= !~prev(it)->second;
  return v;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> t1 >> t2 >> t3;
  for (int op, x, y; n; --n)
    if (cin >> op >> x, op == 1)
      cin >> y, add(x, y);
    else
      cout << query(x) << '\n';
  return cout << flush, 0;
}
```

现在我们发现查询的复杂度已经控制在了一个 $\log$，但修改依然是两个（或许写得好已经能过了，但我的实现太拉，搞不定）。我们注意到所有涉及到的迭代器一定都是连续的，那么我们使用迭代器的自增而不是每次重新查询来降低这一部分的复杂度（连续访问 $n$ 个迭代器的复杂度是 $O(n+\log)$ 的）。至于还涉及到可能插入原本不存在的迭代器，这个我们可以使用成员函数 `emplace_hint` 解决，单次插入的均摊复杂度是常数的。

于是我们的代码就优化到一个 $\log$ 了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, t1, t2, t3;
map<int, int> mp;
void add(int v, int p) {
  auto it = mp.emplace(p, 0).first;
  it->second += v;
  while (true) {
    auto [d, f] = div(it->second, 2);
    auto nit = it;
    if (d) {
      it = mp.emplace_hint(it, ++p, 0);
      it->second += d;
    }
    if (!f)
      mp.erase(nit);
    else
      nit->second = f;
    if (!d) return;
  }
}
int query(int p) {
  auto it = mp.lower_bound(p);
  int v = it != mp.end() && it->first == p ? it->second & 1 : 0;
  if (it != mp.begin()) v ^= !~prev(it)->second;
  return v;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> t1 >> t2 >> t3;
  for (int op, x, y; n; --n)
    if (cin >> op >> x, op == 1)
      cin >> y, add(x, y);
    else
      cout << query(x) << '\n';
  return cout << flush, 0;
}
```

~~建议降蓝。~~

---

## 作者：xyz32768 (赞：11)

NOI2017 Day1 T1。

首先，在记录的时候，把每连续60个二进制位压位，使得与每个修改操作相关的2^60进制位数不会超过2。并用线段树维护，叶子节点表示的是用2^60进制表示时某一位的值。

同时对于线段树每个节点，再维护三个值：

pre：当前的数用2^60进制表示时，对应区间最低位的值。

suf：当前的数用2^60进制表示时，对应区间最高位的值。

len：当前的数用2^60进制表示时，从对应区间的最低位往高位计数最多能数到的与最低位的值相同的数位的个数。

对于每个修改操作，分成x为正和负两种情况考虑。

x为正时，把与之相关的2^60进制位进行单点修改。然后如果有进位，则询问从当前位的下一位开始，最多能数到多少个2^60进制位的值为2^60-1，把这些位的值改为0，并把再下一位的值加上1。

x为负时，同样处理。如果有退位，则询问从当前位的下一位开始，最多能数到多少个2^60进制位的值为0，把这些位的值改为2^60-1，并把再下一位的值减去1。

对于询问操作就是简单的单点询问。

代码（在BZOJ上AC，在洛谷上7个点TLE，NOI原题中的时限是2s而不是1s）：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define p2 p << 1
#define p3 p << 1 | 1
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 6e5;
const ll CYX = 1ll << 60;
int n, V[(N << 2) + 5]; ll T[(N << 2) + 5], add[(N << 2) + 5],
pre[(N << 2) + 5], suf[(N << 2) + 5];
void build(int l, int r, int p) {
    if (l == r) {
        T[p] = pre[p] = suf[p] = 0;
        V[p] = r - l + 1; add[p] = 0;
        return;
    }
    int mid = l + r >> 1;
    build(l, mid, p2); build(mid + 1, r, p3);
    pre[p] = pre[p2];
    suf[p] = suf[p3]; V[p] = r - l + 1; add[p] = 0;
}
void down(int p) {
    add[p2] += add[p]; add[p3] += add[p];
    add[p] = 0;
}
void calc(int l, int r, int p) {
    ll r3, r4, r5, r6; int r7, r8, mid = l + r >> 1;
    r3 = pre[p2] + add[p2]; r4 = pre[p3] + add[p3];
    r5 = suf[p2] + add[p2]; r6 = suf[p3] + add[p3];
    r7 = V[p2]; r8 = V[p3]; pre[p] = r3;
    suf[p] = r6; V[p] = (r7 == mid - l + 1 && r4 == r5) ? r7 + r8 : r7;
} 
void change(int l, int r, int s, int e, ll v, int p) {
    if (l == s && r == e) return (void) (add[p] += v);
    int mid = l + r >> 1; down(p);
    if (e <= mid) change(l, mid, s, e, v, p2);
    else if (s >= mid + 1) change(mid + 1, r, s, e, v, p3);
    else change(l, mid, s, mid, v, p2),
        change(mid + 1, r, mid + 1, e, v, p3);
    calc(l, r, p);
}
bool modify1(int l, int r, int pos, ll v, int p) {
    if (l == pos && pos == r) {
        ll val = T[p] + add[p] + v;
        if (val >= CYX) add[p] += v - CYX;
        else add[p] += v;
        return val >= CYX;
    }
    int mid = l + r >> 1; down(p); bool res = 0;
    if (pos <= mid) res = modify1(l, mid, pos, v, p2);
    else res = modify1(mid + 1, r, pos, v, p3);
    calc(l, r, p); return res;
}
bool modify2(int l, int r, int pos, ll v, int p) {
    if (l == pos && pos == r) {
        ll val = T[p] + add[p] - v;
        if (val < 0) add[p] -= v - CYX;
        else add[p] -= v;
        return val < 0;
    }
    int mid = l + r >> 1; down(p); bool res = 0;
    if (pos <= mid) res = modify2(l, mid, pos, v, p2);
    else res = modify2(mid + 1, r, pos, v, p3);
    calc(l, r, p); return res;
}
int ask1(int l, int r, int s, int e, ll v, int p) {
    if (l == s && r == e) return pre[p] + add[p] == v ? V[p] : 0;
    int mid = l + r >> 1; down(p); int res = 0;
    if (e <= mid) res = ask1(l, mid, s, e, v, p2);
    else if (s >= mid + 1) res = ask1(mid + 1, r, s, e, v, p3);
    else {
        int cc = ask1(l, mid, s, mid, v, p2),
            ff = ask1(mid + 1, r, mid + 1, e, v, p3);
        if (cc == mid - s + 1 && pre[p3] + add[p3] == v
            && suf[p2] + add[p2] == v)
                res = cc + ff;
        else res = cc;
    }
    calc(l, r, p); return res;
}
ll ask2(int l, int r, int pos, int p) {
    if (l == pos && pos == r) return T[p] + add[p];
    int mid = l + r >> 1; down(p); ll res = 0;
    if (pos <= mid) res = ask2(l, mid, pos, p2);
    else res = ask2(mid + 1, r, pos, p3);
    calc(l, r, p); return res;
}
int main() {
    int i, op, x, y; n = read(); read(); read(); read();
    build(1, N, 1);
    for (i = 1; i <= n; i++) {
        op = read();
        if (op == 1) {
            x = read(); y = read();
            if (x == 0) continue;
            if (x > 0) {
                int pos1, pos2; pos1 = pos2 = y / 60 + 1;
                if (1ll * x >> 60 - y % 60) pos2 = pos1 + 1;
                else pos2 = pos1;
                if (pos1 == pos2) {
                    bool flag = modify1(1, N, pos1, 1ll * x << y % 60, 1);
                    if (flag) {
                        int tt = ask1(1, N, pos1 + 1, N, CYX - 1, 1);
                        if (tt) change(1, N, pos1 + 1, pos1 + tt, 1ll - CYX, 1);
                        modify1(1, N, pos1 + tt + 1, 1, 1);
                    }
                }
                else {
                    int le = (pos1 << 6) - (pos1 << 2) - y;
                    bool flag0 = modify1(1, N, pos1,
                        1ll * (x & ((1 << le) - 1)) << 60 - le, 1), flag;
                    flag = flag0 ? modify1(1, N, pos2, (x >> le) + 1, 1)
                        : modify1(1, N, pos2, x >> le, 1);
                    if (flag) {
                        int tt = ask1(1, N, pos2 + 1, N, CYX - 1, 1);
                        if (tt) change(1, N, pos2 + 1, pos2 + tt, 1ll - CYX, 1);
                        modify1(1, N, pos2 + tt + 1, 1, 1);
                    }
                }
            }
            else {
                x = ~x + 1; int pos1, pos2; pos1 = pos2 = y / 60 + 1;
                if (1ll * x >> 60 - y % 60) pos2 = pos1 + 1;
                else pos2 = pos1;
                if (pos1 == pos2) {
                    bool flag = modify2(1, N, pos1, 1ll * x << y % 60, 1);
                    if (flag) {
                        int tt = ask1(1, N, pos1 + 1, N, 0, 1); if (tt)
                        change(1, N, pos1 + 1, pos1 + tt, CYX - 1, 1);
                        modify2(1, N, pos1 + tt + 1, 1, 1);
                    }
                  }
                else {
                    int le = (pos1 << 6) - (pos1 << 2) - y;
                    bool flag0 = modify2(1, N, pos1,
                        1ll * (x & ((1 << le) - 1)) << 60 - le, 1), flag;
                    flag = flag0 ? modify2(1, N, pos2, (x >> le) + 1, 1)
                        : modify2(1, N, pos2, x >> le, 1);
                    if (flag) {
                        int tt = ask1(1, N, pos2 + 1, N, 0, 1); if (tt)
                        change(1, N, pos2 + 1, pos2 + tt, CYX - 1, 1);
                        modify2(1, N, pos2 + tt + 1, 1, 1);
                    }
                }
            }
        }
        else {
            x = read(); ll res = ask2(1, N, x / 60 + 1, 1);
            printf("%d\n", (res >> x % 60) & 1);
        }
    }
    return 0;
}
```

---

## 作者：kyEEcccccc (赞：6)

这题难点在于维护高精度数的时候解决进退位的高复杂度问题。现在我们有高论！使用 Trygub Number，可以做到 $\mathrm O(\log_B V\log_2 n)$ 在某一位加或者减一个大小 $\mathrm O(V)$ 的数，支持判断正负和取特定位的值。

怎么做呢。很简单，我们的数每一位的数值域原本是 $[0, B)$，其中 $B$ 是进制，现在我们将其改成 $(-B, B)$（也就是实现的时候除法直接向 0 取整）。你会发现：这样一个数的正负性只和最高非零位置有关；某一位的具体值，只会受到上一个非零位的退位影响。那么用一个 `set` 存下所有非零位置即可。在这道题，加的数绝对值不超过 $10^9$。如果我们进行一个位的压，那么可以把 $V$ 搞到 $\Theta(B)$，于是单 $\log$ 就暴力过了这个题。关键在于证明为啥加减这么快。下面我们来证明！

考虑当前我们在某一位要加上一个数 $X$。如果 $|X| \ge B$ 那么它会除以 $B$ 下取整以后再被扔到下一位；由于当前位可能原本有数，所以它的大小还可能增加 1，但是每一位产生的 1 在不断被除的过程中，产生的最终贡献形如级数 $\sum\limits_{i=0}^{\infty}B^{-i}$，这个东西狠狠地收敛，所以并不影响 $|X|$ 在 $\log_B V$ 时间内快速变小到 $[0, B)$。这一部分消耗的复杂度也就是 $\log_B V\log_2 n$。

那么考虑 $|X| < B$ 的时候会发生啥。容易得出你会往前进位，每次进的数只可能是 $\pm 1$，单次进位消耗复杂度是 $\log_2 n$。一般的时候，你进一次位就停下来了，但有时候也可能不停进位，发生链式反应！考虑什么时候会连续进位，也就是当某一位恰好是 $\pm(B-1)$ 的时候。定义这样的位是“临界状态”。注意到我们的值域是 $(-B, B)$，发生连续进位以后，中间的位的值会从 $\pm(B-1)$ 变成 0，也就不再是临界位！那么发生一次额外的进位会恰好消耗掉一个临界状态的位。考虑均摊分析。什么时候我们会增加临界状态的位呢？容易得出，前面当 $|X| \ge B$ 的时候，在每一个地方都可能增加一个临界位；而在后面的连续进位过程中只会消耗不会增加位，顶多在最后一次进位停下来的时候产生一个临界位。所以最后临界位的总个数是均摊 $m \log_B V$ 的。均摊复杂度正确，完全胜利！

贴一下 [CF 上的原文](https://codeforces.com/blog/entry/115626)。

代码，跑的很快！

```cpp
// Author: kyEEcccccc

#include <bits/stdc++.h>

using namespace std;

using LL = long long;
using ULL = unsigned long long;

#define F(i, l, r) for (int i = (l); i <= (r); ++i)
#define FF(i, r, l) for (int i = (r); i >= (l); --i)
#define MAX(a, b) ((a) = max(a, b))
#define MIN(a, b) ((a) = min(a, b))
#define SZ(a) ((int)((a).size()) - 1)

namespace IO
{
	const int BUF = 1000000;
 
	char ibuf[BUF];
	int ilen = 0, icur = 0;
 
	int rc(void)
	{
		if (icur == ilen)
		{
			icur = 0;
			ilen = fread(ibuf, sizeof (char), BUF, stdin);
			if (icur == ilen) return -1;
		}
		return ibuf[icur++];
	}
 
	LL rll(void)
	{
		LL x = 0, s = 1, c = rc();
		while (c < '0' || c > '9')
		{
			if (c == -1) return 0;
			s = c == '-' ? -1 : 1;
			c = rc();
		}
		do {
			x = (x << 1) + (x << 3) + c - '0';
			c = rc();
		} while (c >= '0' && c <= '9');
		return x * s;
	}
 
	char obuf[BUF], ostk[20];
	int olen = 0, otop;
 
	void flush(void)
	{
		fwrite(obuf, sizeof (char), olen, stdout);
		olen = 0;
	}
 
	void wc(char c)
	{
		if (olen == BUF) flush();
		obuf[olen++] = c;
	}
 
	void wll(LL x)
	{
		if (x == 0) return wc('0');
		if (x < 0) x = -x, wc('-');
		otop = 0;
		while (x) ostk[++otop] = x % 10 + '0', x /= 10;
		while (otop) wc(ostk[otop--]);
	}
}

const int K = 30, B = 1 << K;

struct TrygubNumber
{
	vector<int> dig;
	set<int> pos;

	void add(int p, LL x)
	{
		while (x)
		{
			if (SZ(dig) < p) dig.resize(p + 1);
			x += dig[p];
			if (dig[p] == 0 && x % B != 0) pos.insert(p);
			if (dig[p] != 0 && x % B == 0) pos.erase(p);
			dig[p] = x % B;
			x /= B;
			++p;
		}
	}

	int getdig(int p)
	{
		if (p > SZ(dig)) return 0;
		int ans = dig[p];
		if (!pos.empty() && *pos.begin() < p
			&& dig[*prev(pos.lower_bound(p))] < 0) --ans;
		return (ans + B) % B;
	}
} num;

int n, t1, t2, t3;

signed main(void)
{
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(nullptr);
	
	n = IO::rll(), t1 = IO::rll(), t2 = IO::rll(), t3 = IO::rll();
	F(i, 1, n)
	{
		int op = IO::rll();
		if (op == 1)
		{
			LL a = IO::rll(); int b = IO::rll();
			if (a < 0) a = -((-a) << b % K);
			else a = a << b % K;
			num.add(b / K, a);
		}
		else
		{
			int p = IO::rll();
			cout << (num.getdig(p / K) >> p % K & 1) << '\n';
		}
	}

	IO::flush();
	return 0;
}
```

---

## 作者：NeosKnight (赞：6)

为什么我什么优化都没加一个大暴力 set 就过了?

用 set 维护一段一段的 1 , 然后修改拆成对每一位分别修改 , 这样每次修改最多30个位置。

对于正负就都大力讨论一下就行了，都很简单，能够卡的常数就卡卡。
~~（mutable大法好）~~

复杂度上界 $O(30nlog(10^7))$ 反正非常不满。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Set(a,b) memset(a,b,sizeof(a))
template<class T>inline void init(T&x){
	x=0;char ch=getchar();bool t=0;
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);
	if(t) x=-x;return;
}typedef long long ll;
const int N=1e6+10;
int n,t1,t2,t3;
struct interval{
	mutable int l,r;
	interval(){}
	interval(int _l,int _r){l=_l,r=_r;}
	inline bool operator <(const interval b)const{return l<b.l||(l==b.l&&r<b.r);}
};
set<interval> S;
set<interval>::iterator iter;
inline void Change(int x,bool fl){
	iter=S.upper_bound(interval(x,1e9));
	if(iter==S.begin()) {
		if(fl) {// -
			const interval I=*iter;
			int r=I.l-1;
			if(I.l==I.r) S.erase(iter);
			else         ++(*iter).l;
			S.insert(interval(x,r));
		}else  {// +
			if(iter!=S.end()&&(*iter).l==x+1) --(*iter).l;
			else S.insert(interval(x,x));
		}
	}else {
		set<interval>::iterator it=iter;--it;
		const interval I=*it;
		if(fl) {// -
			if(I.r>=x) {
				if(I.l<x) {
					(*it).r=x-1;
					if(I.r>x) S.insert(interval(x+1,I.r));
				}else{
					if(I.r>x) (*it).l=x+1;
					else S.erase(it);
				}
			}else{
				const interval II=*iter;
				int r=II.l-1;
				if(II.l==II.r) S.erase(iter);else ++(*iter).l;
				if(I.r==x-1) (*it).r=r;
				else S.insert(interval(x,r));
			}
		}else  {// +
			int r;
			if(I.r>=x) {
				r=I.r+1;
				if(iter!=S.end()) {
					const interval II=*iter;
					if(II.l==r+1) --(*iter).l;
					else S.insert(interval(r,r));
				}else S.insert(interval(r,r));
				if(x==I.l) S.erase(it);
				else (*it).r=x-1;
			}else {
				bool Linkl=0,Linkr=0;
				int R;
				if(iter!=S.end()) {
					const interval II=*iter;R=II.r;
					if(II.l==x+1) Linkr=1;
					if(I.r==x-1)  Linkl=1;
				}else {
					R=x;
					if(I.r==x-1) Linkl=1;
				}
				if(Linkl&&Linkr) {S.erase(iter);(*it).r=R;}
				else if(Linkr) --(*iter).l;
				else if(Linkl) ++(*it).r;
				else S.insert(interval(x,x));
			}
		}
	}
}
inline void Solve(int a,int b){
	bool fl=0;if(a<0) fl=1,a=-a;
	for(register int i=0;a;a>>=1,++i) {
		register int c=a&1;if(!c) continue;
		Change(i+b,fl);
	}return;
}

int main()
{
	init(n),init(t1),init(t2),init(t3);
	for(int i=1;i<=n;++i) {
		int tp;init(tp);
		if(tp==1) {
			int a,b;init(a),init(b);
			Solve(a,b);
		}else{
			int k;init(k);
			iter=S.upper_bound(interval(k,1e9));
			if(iter!=S.begin()) {
				--iter;
				if((*iter).r>=k) puts("1");
				else puts("0");
			}else puts("0");
		}
		
	}
	return 0;
}

```

---

## 作者：gcwixsxr (赞：5)

这里给出一种线段树的思路

### 题目分析

注意到题目中给出的两个参数 $a,b$，其中我们要维护的是二进制第 $b$ 位上的系数。这是我们不免想到高精。

显然直接朴素维护高精不可取。每次直接更改可能会修改 $O(n)$ 位。如当前 $x=2^{10^6}$ ，此时我们反复进行 $+1$ 和 $-1$ 操作，每一位上都会发生改变。

但这并不意味着维护高精的方法不可取。我们可以观察每一次修改对 $x$ 每一位上的影响，如设 $x=(1100011110010111)_ 2$，我们对它进行加 $a=(111100000)_ 2$ 操作，不妨竖式来观察

$$
\begin{aligned}
& x&=&&1100011110010111\\
& a&=&&111100000\\
& x^\prime&=&&1100100101110111
\end{aligned}
$$

我们可以将 $x^\prime$ 分为 $5$ 个部分：

$$
\begin{aligned}
& x&=&&{\color{red}{1100}}{\color{Purple}{0}}{\color{Goldenrod}11}{\color{Magenta}{1100}}{\color{lightblue}{10111}}\\
& a&=&&{\color{Magenta}1111}{\color{lightblue}00000}\\
& x^\prime&=&&{\color{red}{1100}}{\color{Purple}{1}}{\color{Goldenrod}00}{\color{Magenta}{1011}}{\color{lightblue}{10111}}
\end{aligned}
$$

红色：加法进位没有影响到的位置。

紫色：加法进位影响到的位置，使之加 $1$。

黄色：加法进位影响到的位置，使变为 $0$。

粉色：加法直接影响到的位置，直接计算，对应 $a\times2^b$ 的部分。

蓝色：加法没有影响到的位置，对应后 $b-1$ 位。

### 思路

注意到有区间修改，单点查询，查询当前往左第一个 $0$ 的位置，当前往左第一个 $1$ 的位置。显然可以使用线段树进行操作。

单次要修改 $O(\log a)$ 位，那么到线段树上时间复杂度为 $O(\log ^2n)$ ，显然还不够优秀。考虑压位，设每 $w$ 位压为一位。那么单次修改时间复杂度为 $O(\log n+\dfrac {\log^2 n} w)$，当 $w$ 取到 $\log n$ 时最佳。注意叶节点的区间覆盖对应按位与运算。

代码略。

---

## 作者：Hope2075 (赞：4)

给一种不同的~~极速~~做法

首先，要把加法和减法分别处理，用一个二进制高精存

对于操作1，就在对应位置加上这个数

这样可以保证复杂度

假设我们用的是不压位的二进制高精

那么进位的时候，会发现有一大堆为1的位变成了0

而执行每次操作最多把$\log a_i$个位变为1

这样，总复杂度不会高于$n\log a_i$，而压位只会变快

如果不分开统计，那么就会导致出现一大堆为0的位变成了1，这样就可能TLE

接下来考虑操作2

这步实际就是将两个高精整数低位取出相减

直接减肯定不行，但我们只关心某一位的结果

首先，取出两个高精整数中的对应位，取异或

然后，比较剩余部分的大小，决定是否取反

实质上，就是低位相减，然后借位，再把高位相减

然而，不加优化直接比较肯定不行，会TLE

但是发现，比较的时候，只有一段需要比较其中某几位，其它部分只需要比较整段（也就是一个ull）

这样，可以采用以下方法：

构造两个新的整数，每一位对应原来的一段

如果加法操作数较大，则第一个整数这位为1，第二个整数这位为0

如果减法操作数较大，则第一个整数这位为0，第二个整数这位为1

如果相等，则均为0（均为1也可以）

这时发现只需要比较新的整数中某几位即可

而且，这个问题和原问题等价，只是规模减小了

于是递归处理即可

递归结束条件是：

1.某一次比较不相等，这时就能得出大小关系

2.没有可比较的位，这时表示两部分相等

于是，在操作1的时候把影响到的部分更新一下，就可以了

这样时间复杂度$n \log k$，$k$就是最大会影响到的位

然而每次递归会把问题规模减少到$1/64$，也就意味着有一个超小常数

这个做法应该是倍增思想，不过每次是64倍

~~于是就成最优解了，953ms，比第二快了300ms~~

代码：
```cpp
#include<cstdio>
const int N=1001007;
#define u64 unsigned long long
long long read(){
    long long n=0;char c=getchar();bool f=0;
    while(c!='-'&&(c<'0'||c>'9'))c=getchar();
    if(c=='-'){f=1;c=getchar();}
    while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
    if(f)return -n;
    else return n;
}
u64 num1[N*2],num2[N*2];
void upd(u64 *s1,u64 *s2,int sz,int pl){
    if(sz==0)return;
    int t=pl%64;
    int r=pl/64;
    u64 *sn1=s1+sz+1,*sn2=s2+sz+1;
    if(s1[pl]>s2[pl]){
        sn1[r]|=(1ull<<t);
        sn2[r]&=(~(1ull<<t));
    }else if(s1[pl]<s2[pl]){
        sn1[r]&=(~(1ull<<t));
        sn2[r]|=(1ull<<t);
    }else{
        sn1[r]&=(~(1ull<<t));
        sn2[r]&=(~(1ull<<t));
    }
    upd(sn1,sn2,sz/64,r);
}
int cmp(u64 *s1,u64 *s2,int sz,int pl){
    if(pl==-1)return 0;
    int t=pl%64;
    int r=pl/64;
    u64 a,b,m;
    m=((1uLL<<(t+1))-1);
    if(t==63)m=-1;
    a=(s1[r]&m);
    b=(s2[r]&m);
    if(a>b)return 1;
    if(a<b)return -1;
    if(sz==0)return 0;//注意这句要放在后面，否则80分
    return cmp(s1+sz+1,s2+sz+1,sz/64,r-1);
}

int n,sz,t;
int opt;
long long a,b;
u64 num;
int main(){
    n=read();t=read();t=read();t=read();
    sz=1001000;
    while(n--){
        opt=read();
        if(opt==1){
            a=read();b=read();
            
            if(a==0)continue;
            if(a>0){
                num=a;
                int t=b%64;
                int r=b/64;
                num1[r]+=(num<<t);
                upd(num1,num2,sz,r);
                if(num1[r]<(num<<t)){
                    num>>=(64-t);
                    if(t==0)num=0;
                    num++;
                }else{
                    num>>=(64-t);
                    if(t==0)num=0;
                }
                if(num==0)continue;
                r++;
                num1[r]+=num;
                upd(num1,num2,sz,r);
                while(num1[r]==0){
                    r++;
                    num1[r]++;
                    upd(num1,num2,sz,r);
                }
            }else{
                num=-a;
                int t=b%64;
                int r=b/64;
                num2[r]+=(num<<t);
                upd(num1,num2,sz,r);
                if(num2[r]<(num<<t)){
                    num>>=(64-t);
                    if(t==0)num=0;
                    num++;
                }else{
                    num>>=(64-t);
                    if(t==0)num=0;
                }
                if(num==0)continue;
                r++;
                num2[r]+=num;
                upd(num1,num2,sz,r);
                while(num2[r]==0){
                    r++;
                    num2[r]++;
                    upd(num1,num2,sz,r);
                }
            }
        }else{
            a=read();
            int t=a%64;
            int r=a/64;
            int bit=0;
            if(num1[r]&(1uLL<<t))bit^=1;
            if(num2[r]&(1uLL<<t))bit^=1;
            if(a!=0&&cmp(num1,num2,sz,a-1)==-1)bit^=1;
            if(bit)puts("1");
            else puts("0");
        }
    }
}
```
~~其实是因为我不想写数据结构才想出的这个方法~~

---

## 作者：聊机 (赞：2)

本文主要是对 gcwixsxr 大佬线段树思路的**程序实现**，使用 zkw 线段树实现的。

蒟蒻第一次写 zkw，程序架构实际上有很多缺陷，希望大佬指正。

思路重述：

对于加减操作在 $a$ 直接加减的那几位暴力修改，对于进退位，使用线段树找到往高位的第一个 0 或 1，然后区间翻转修改，压位。

细节非常多，重点在代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e7+50;
inline int qr() {
	int k=0,f=1;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)) {k=(k<<1)+(k<<3)+(ch^48);ch=getchar();}
	return k*f;
}
struct zkwseg{
	int lz[N/2],l0[N/2],l1[N/2];
	//lz是翻转的标记，对于叶子节点lz表示的是值
	//l0是往高位上最低的0，l1同理 
	const int p=1<<22,mi=p*16;
	//26位一压，p是zkw线段树最后一层的第一个节点 
	inline void push(int u) {
		//由于标记永久化，所以需要考虑孩子是不是会翻转，如果翻转，那么l0和l1正好相反 
		if(u<<1>=p||!lz[u<<1|1]) {
			l0[u]=l0[u<<1|1];
			l1[u]=l1[u<<1|1];
		}
		else {
			l0[u]=l1[u<<1|1];
			l1[u]=l0[u<<1|1];
		}
		//先用右儿子更新，再用左儿子，因为左儿子如果有值，那一定比右儿子更优 
		if(u<<1>=p||!lz[u<<1]) {
			if(~l0[u<<1]) l0[u]=l0[u<<1];//-1还不如不修改 
			if(~l1[u<<1]) l1[u]=l1[u<<1];
		}
		else {
			if(~l0[u<<1]) l1[u]=l0[u<<1];
			if(~l1[u<<1]) l0[u]=l1[u<<1];
		}		
	}
	inline void pushup(int u) {
		u>>=1;
		while(u) push(u),u>>=1;
	}
	int ask0(int u) {
		bool c=0;
		for(int x=u>>1;x;x>>=1) if(lz[x]) c^=1;//询问的是真实值，所以必须对标记永久化处理 
		if((~l0[u])&&!c) return l0[u];
		if((~l1[u])&&c) return l1[u];		
		while(u) {
			if((u&1)==0) {//只有当u是左儿子的时候，才会更新u的兄弟 
				if(u<p&&lz[u+1]) c^=1;//看看兄弟本身有没有标记 
				if((~l0[u+1])&&!c) return l0[u+1];
				if((~l1[u+1])&&c) return l1[u+1];
				if(u<p&&lz[u+1]) c^=1;//得把兄弟的标记删除 
			}
			u>>=1;if(lz[u]) c^=1;
		}
	}
	int ask1(int u) {//跟上面几乎一样 
		bool c=0;
		for(int x=u>>1;x;x>>=1) if(lz[x]) c^=1;
		if((~l1[u])&&!c) return l1[u];
		if((~l0[u])&&c) return l0[u];
		while(u) {
			if((u&1)==0) {
				if(u<p&&lz[u+1]) c^=1;
				if((~l0[u+1])&&c) return l0[u+1];
				if((~l1[u+1])&&!c) return l1[u+1];
				if(u<p&&lz[u+1]) c^=1;
			}
			u>>=1;if(lz[u]) c^=1;
		}
		exit(-1);//题目保证一定合法，所以不会出现找不到退位的1 
	}
	void reves(int u,int o) {
		//左端点u一定是从第0位开始（因为刚进位或退位） 
		int v=p+o/26,i=o%26;
		lz[v]^=(1<<(i+1))-1;
		find(v);
		if(u==v) {pushup(v);return ;}
		lz[u]^=mi-1;
		swap(l1[u],l0[u]);
		while(u^v^1) {
			if((u&1)==0) {//这个位运算恶心死我了，&必须加括号 
				if(u>=p) lz[u+1]^=mi-1,swap(l0[u+1],l1[u+1]);//叶子节点特判 
				else lz[u+1]^=1;
			}
			if(v&1) {
				if(v>=p) lz[v-1]^=mi-1,swap(l0[v-1],l1[v-1]);
				else lz[v-1]^=1;
			}
			u>>=1,v>>=1;push(u),push(v);//每次必须pushup，因为l0和l1改变了 
		}
		pushup(u);//记得整体翻转完以后pushup 
	}
	inline void find(int u) {//这个函数是更新加减完以后的l数组 
		//注意这里不用考虑标记永久化，因为是在标记之下进行更新 
		l0[u]=l1[u]=-1;
		for(int i=1<<25,j=25;j>=0;j--,i>>=1) 
			if(lz[u]&i) l1[u]=(u-p)*26+j;
			else l0[u]=(u-p)*26+j;
	}
	void change(int a,int b) {
		bool fu=0;int j=0;//j表示进退位 
		if(a<0) fu=1,a=-a;
		int u=p+b/26,i=b%26;
		//整个程序都一样，u表示压完位在线段树所在的叶子节点，i表示在这个节点的第几位 
		while(a) {
			bool c=0;
			for(int x=u>>1;x;x>>=1) if(lz[x]) c^=1;
			if(c) lz[u]^=mi-1;//查询真实值，标记永久化 
			lz[u]+=j,j=0;
			int y=(26-i);
			if(fu) {
				lz[u]-=(a-(a>>y<<y))<<i;
				if(lz[u]<0) lz[u]+=mi,j=-1;
			}
			else {
				lz[u]+=(a-(a>>y<<y))<<i;
				if(lz[u]>=mi) j=1,lz[u]-=mi; 
			}
			if(c) lz[u]^=mi-1;
			find(u);pushup(u);
			a>>=y,++u,i=0;
		}
		if(j==1) reves(u,ask0(u));
		else if(j==-1) reves(u,ask1(u));
	}
	void ask(int x) {
		int u=p+x/26,i=x%26;
		bool o=lz[u]&(1<<i);
		u>>=1;
		while(u) {
			if(lz[u]) o^=1;
			u>>=1;
		}
		if(o) puts("1");
		else puts("0");
	}
}T;
int n,op,a,b;
int main() {
	memset(T.l1,-1,sizeof T.l1);
	for(int i=T.p;i<T.p*2;i++) T.l0[i]=(i-T.p)*26;
	for(int y=T.p>>1;y;y>>=1) {
		for(int i=y;i<y*2;i++)
			T.l0[i]=T.l0[i<<1];
	}//初始化，我开始忘了（ 
	n=qr();qr(),qr(),qr();
	while(n--) {
		op=qr(),a=qr();
		if(op==1) {
			b=qr();
			T.change(a,b);
		}
		else T.ask(a);
	}
	return 0;
}
```
应该是我是实现的太差，常数非常大，很慢。

---

## 作者：elijahqi (赞：2)

 http://www.elijahqi.win/archives/2919
https://blog.csdn.net/elijahqi/article/details/79832161


考虑利用线段树进行模拟这个过程 因为位数太多 我选择在线段树上一个节点压30位  然后每个节点记录len0,len1表示最长延伸的1或0的长度 我的线段树左边低位右边高位 在左加法的时候将a拆分成两个先加后半部分 如果有进位 那么我就加到前半部分然后再去线段树上加这个节点 如果还有进位我就查询一下最长的连续1延伸到哪里中间全部改成0前面改成1  在查询的时候就类似update的时候一样 如果位置在左边我判断下右边是否连续 如果连续那么我的连续长度就要加上他 然后一路找下去即可

负数的情况 类似整数 首先取绝对值 然后每次改的时候往里面改负数即可

写的时候卡了卡常 然而还是这么慢qwq

感谢pickupwin巨佬帮忙查错 做题debug一天 问了巨佬一下，巨佬就帮我看出来错误了
```
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
#define N 1000010
#define lc (x<<1)
#define rc (x<<1|1)
int n0=30;
const int full=(1<<n0)-1;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while(!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}
    while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
    return x*f;
}
const int OUT_LEN = 1024 * 1024;
char obuf[OUT_LEN], *oh = obuf;
inline void write_char(char c) {
    if (oh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), oh = obuf;
    *oh++ = c;
}
template<class T>
inline void W(T x) {
    static int buf[30], cnt;
    if (x == 0) write_char('0');
    else {
        if (x < 0) write_char('-'), x = -x;
        for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
        while (cnt) write_char(buf[cnt--]);
    }
}
inline void flush() {
    fwrite(obuf, 1, oh - obuf, stdout);
}
struct node{
    int len0,len1,v,tag;//tag=-1->0 tag=1->full
}tree[N<<2];
inline void update(int x,int l,int r,int mid){
    int len=mid-l+1;
    tree[x].len0=(tree[lc].len0==len)*tree[rc].len0+tree[lc].len0;
    tree[x].len1=(tree[lc].len1==len)*tree[rc].len1+tree[lc].len1;
}
inline void dochange(int x,int l,int r,int v){
    if (v==full){
        tree[x].v=full;tree[x].len0=0;tree[x].len1=r-l+1;tree[x].tag=2;return;
    }tree[x].v=0;tree[x].len1=0;tree[x].len0=r-l+1;tree[x].tag=-1;
}
inline void pushdown(int x,int l,int r){
    if (!tree[x].tag) return;int mid=l+r>>1;
    dochange(lc,l,mid,tree[x].tag==-1?0:full);
    dochange(rc,mid+1,r,tree[x].tag==-1?0:full);
    tree[x].tag=0;
}
inline bool modify(int x,int l,int r,int l1,int r1,int v){
    if (l1<=l&&r1>=r){
        tree[x].v+=v;bool flag=0;tree[x].len0=tree[x].len1=0;
        if (tree[x].v>full) tree[x].v&=full,flag=1;
        if (tree[x].v<0) tree[x].v+=full+1,flag=1;
        if (tree[x].v==full) tree[x].tag=2,tree[x].len1=r-l+1;
        if (!tree[x].v) tree[x].tag=-1,tree[x].len0=r-l+1;return flag;
    }int mid=l+r>>1;pushdown(x,l,r);bool tmp=0;
    if (l1<=mid) tmp|=modify(lc,l,mid,l1,r1,v);
    if (r1>mid) tmp|=modify(rc,mid+1,r,l1,r1,v);update(x,l,r,mid);return tmp;
}
inline void change(int x,int l,int r,int l1,int r1,int v){
    if (l1>r1) return;
    if (l1<=l&&r1>=r) {dochange(x,l,r,v);return;}
    int mid=l+r>>1;pushdown(x,l,r);
    if (l1<=mid) change(lc,l,mid,l1,r1,v);
    if (r1>mid) change(rc,mid+1,r,l1,r1,v);update(x,l,r,mid);
}
inline bool query(int x,int l,int r,int p,int k){
    if(l==r) return (tree[x].v>>k)&1;int mid=l+r>>1;pushdown(x,l,r);
    if (p<=mid) return query(lc,l,mid,p,k);
    else return query(rc,mid+1,r,p,k);
}
inline int lg(int x){
    static int cnt;cnt=0;while(x) ++cnt,x>>=1;return cnt;
}
inline int qr1(int x,int l,int r,int p,int len){
    if (l==r) return tree[x].len1==0?0:tree[x].len1+len;int mid=l+r>>1;pushdown(x,l,r);
    if(p<=mid){
        if (tree[rc].len1==r-mid) return qr1(lc,l,mid,p,len+tree[rc].len1);
        return qr1(lc,l,mid,p,tree[rc].len1);
    }return qr1(rc,mid+1,r,p,len);      
}
inline int qr0(int x,int l,int r,int p,int len){
    if (l==r) return tree[x].len0==0?0:tree[x].len0+len;int mid=l+r>>1;pushdown(x,l,r);
    if(p<=mid){
        if (tree[rc].len0==r-mid) return qr0(lc,l,mid,p,len+tree[rc].len0);
        return qr0(lc,l,mid,p,tree[rc].len0);
    }return qr0(rc,mid+1,r,p,len);
}
inline int abs(int x){return x<0?-x:x;}
int n,t1,t2,t3,bin[30];
int main(){
    //freopen("bzoj4942.in","r",stdin);
    //freopen("bzoj4942.out","w",stdout);
    n=read();t1=read();t2=read();t3=read();dochange(1,0,1e6,0);
    for (int i=0;i<=29;++i) bin[i]=(1<<i+1)-1;
    for (int i=1;i<=n;++i){
        static int op,a,b,k,b1,r,b2;static bool tmp;op=read();
        if (op==1){
            a=read(),b=read();b1=b/n0,b2=b%n0;
            if (a>0){
                tmp=modify(1,0,1e6,b1,b1,(a&(bin[n0-b2-1]))*(1<<b2));
                a>>=n0-b2;a+=tmp;if (!a) continue;
                tmp=modify(1,0,1e6,b1+1,b1+1,a);if (!tmp) continue;
                r=qr1(1,0,1e6,b1+2,0);change(1,0,1e6,b1+2,b1+2+r-1,0);
                modify(1,0,1e6,b1+2+r,b1+2+r,1);
            }else{a=abs(a);
                tmp=modify(1,0,1e6,b1,b1,-(a&(bin[n0-b2-1]))*(1<<b2));
                a>>=n0-b2;a+=tmp;if (!a) continue;
                tmp=modify(1,0,1e6,b1+1,b1+1,-a);if (!tmp) continue;
                r=qr0(1,0,1e6,b1+2,0);change(1,0,1e6,b1+2,b1+2+r-1,full);
                modify(1,0,1e6,b1+2+r,b1+2+r,-1);
            }
        }else{
            k=read();static int tmp;
            tmp=k/n0;k%=n0;W(query(1,0,1e6,tmp,k));write_char('\n');
        }
    }flush();
    return 0;
}
```

---

## 作者：yyyyxh (赞：1)

提供一个来自 CF 大佬 adament 的[有趣思路](https://codeforces.com/blog/entry/115626)。

首先我们知道的是一个只增加的 $b$ 进制整数计数器，如果 $b$ 是常数那么复杂度是均摊 $O(1)$ 的。证明只需要考虑将 $b$ 进制中为 $b-1$ 的所有位的位数当成势能，那么每一次进位一定是 $b-1\to 0$ 一定会消耗势能函数。

但这道题有加又有减，问题出在了可能有“退位” $0\to b-1$，这时导致了势能函数的增加，这也是为什么均摊算法通常不能支持撤回。常规的做法是把加减分开考虑变成只加的情况。其实还有一种更简单的做法：我们不限制一个位上的值一定是 $[0,b)$ 的，而是 $(-b,b)$。此时的进位/退位的形式都是 $1-b\to 0$ 或 $b-1 \to 0$。我们将**非零位**的个数当成势能，这样进位/退位都会减小势能，而势能函数的总量就是 $O(n)$ 的了。

然而现在要查询原数某一位，如何来还原原数的一位呢？我们发现进位对于下一位的影响总是 $\pm 1$ 的，我们只需要找到我们当前查询的位的严格非零前驱，判断一下它是否为负，如果是当前位就需要 $-1$ 然后输出。

具体到这题，我们需要将数 $T$ 个压成一位，我实现压了 $62$ 位。维护动态前驱用了 zkw 线段树上 finger search（只是减小常数）。输出时有个小技巧，负数的补码实际上就是它在二进制下的表示，所以提取负数的某一维可以直接跟正数一起位运算就可以了。

代码非常好写，跑得也飞快，复杂度 $O(\frac{30n\log n}{T})$。


```cpp
#include <cstdio>
#include <bitset>
using namespace std;
int read(){
	char c=getchar();int x=0;bool f=0;
	while(c<48||c>57) f|=(c=='-'),c=getchar();
	do x=(x<<1)+(x<<3)+(c^48),c=getchar();
	while(c>=48&&c<=57);
	if(f) return -x;
	return x;
}
const int lT=62,sT=30;
typedef long long ll;
const ll Base=(1ll<<lT);
int q,dlt;
namespace ds{
	bitset<1<<20> f;
	void ins(int x){
		x+=dlt;
		while(!f[x]) f[x]=1,x>>=1;
	}
	void del(int x){
		x+=dlt;
		while(f[x]){
			f[x]=0;
			if(f[x^1]) return;
			x>>=1;
		}
	}
	int pre(int x){
		if(!x) return -1;
		x+=dlt-1;
		if(f[x]) return x-dlt;
		while(x>1){
			if((x&1)&&f[x^1]) break;
			x>>=1;
		}
		x^=1;
		if(!x) return -1;
		while(x<dlt){x<<=1;if(f[x^1]) x^=1;}
		return x-dlt;
	}
}
ll a[500003];
void upd(int x,ll v){
	if(!v) return;
	if(!a[x]) ds::ins(x);
	a[x]+=v;
	if(!a[x]) ds::del(x);
}
void inc(int x,int t){
	bool sig=0;
	if(x<0) sig=1,x=-x;
	int bl=t/lT,wid=lT*(bl+1)-t;
	if(wid>sT) wid=sT;
	if(sig){
		upd(bl,-((ll)(x&((1ll<<wid)-1))<<(t-bl*lT)));
		upd(bl+1,-(x>>wid));
	}
	else{
		upd(bl,(ll)(x&((1ll<<wid)-1))<<(t-bl*lT));
		upd(bl+1,(x>>wid));
	}
	ll tmp=0;
	int fl=0;
	do{
		upd(bl,tmp);
		tmp=a[bl]/Base;
		upd(bl,-Base*tmp);
		++bl;++fl;
	}while(fl<2||tmp);
}
bool qry(int x){
	int bl=x/lT,p=ds::pre(bl);x%=lT;
	if(p>=0&&a[p]<0) return (a[bl]-1)>>x&1;
	else return a[bl]>>x&1;
}
int main(){
	q=read();read();read();read();
	for(dlt=1;dlt<=(q>>1)+1;dlt<<=1);
	while(q--){
		int op=read(),x=read();
		if(op==1) inc(x,read());
		else printf("%d\n",qry(x));
	}
	return 0;
}

```



---

## 作者：MuelsyseU (赞：1)

考虑单点加 $\pm1$，以 $+1$ 为例，直接线段树查找前驱 $0$ 变为 $1$，将这之后的 $1$ 区间推平为 $0$，就是 $O(\log n)$ 的。

若多点增加，但是注意到这里的操作是推平，而多次加 $1$ 的距离不超过 $\log_2V$，所以可以考虑对这 $O(\log V)$ 长度的区间暴力更新，再暴力重构其所在区间的子树。然后剩下最多就只需要跑一个推平操作，其左端点超出这个区间，直接更新，就仍为 $O(\log n+\log V)$。

> 其实考虑到这里就容易想到压位了，这样时间和空间都直接满足了。

最后一个点是关于空间，开 $30n$ 的值域十分危险，考虑到上述操作的端点最多只有：每个操作所在的位置及其高一位的位置，因此离散化即可 $O(n)$ 空间。

---

## 作者：RainWetPeopleStart (赞：0)

一个神秘的 $\log^2$ 做法。

首先考虑处理加减，先拆成 $\log V$ 个对一位的 $+1/-1$ 操作，然后维护 $v_i$ 表示当前第 $i$ 位加了多少，如果 $v_i$ 为 $2/-2$ 就往前进位，即 $v_{i+1}=v_{i+1}+\frac{v_i}{2},v_i=0$。

设计一个势能 $\phi$ 为 $v$ 中不为 $0$ 的个数，记每次操作的代价为 $c$，这会导致 $\phi$ 至少减 $c$，所以对 $v_i$ 的修改次数为 $n\log V$。

使用树状数组维护非 $0$ 位置，对于查询，设查询第 $i$ 位，且 $i$ 后面第一个 $v$ 非 $0$ 的位置为 $ps$。

- 如果 $v_i=0$，答案是否为 $1$ 取决于 $v_{ps}$ 是否为 $-1$。
- 否则，答案是否为 $1$ 取决于 $v_{ps}$ 是否不为 $-1$。

使用树状数组上二分求 $ps$，复杂度 $O(n\log n\log V)$，已经能过了。

优化就是发现每次修改都是对区间内的每一个数修改，即对 $l\le i\le r,v_i=a_i$，我们从底向上去更新树状数组，这应该能分析到单次修改 $O(len+\log n)$，总复杂度 $O(n\log V+n\log n)$。

这个做法应该也能压位优化，做到 $O(\dfrac{n\log n+n\log V}{w})$。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e7+100;
inline int lb(int x){return x&(-x);}
int v[N],LM;
struct bit{
    int T[N];
    void upd(int x,int v){
        for(int i=x;i<=LM;i+=lb(i)) T[i]+=v;
    }int qry(int x){
        int res=0;
        for(int i=x;i>0;i-=lb(i)) res+=T[i];
        return res;
    }int bin(int x){
        int ps=0,sum=0,qs=qry(x);
        for(int i=24;i>=0;i--){
            if(ps+(1<<i)>LM) continue;
            if(sum+T[ps+(1<<i)]<qs){
                ps+=(1<<i);
                sum+=T[ps];
            }
        }return ps+1;
    }
}b;
int n;
int Query(int x){
    int pos=b.bin(x-1);
    if(x==1) pos=0; 
    if(v[x]==0){
        return (v[pos]==-1);
    }else{
        return (v[pos]!=-1);
    }
}
void updpos(int x,int vl){
    int tvl=-(v[x]!=0);
    v[x]+=vl;
    if(abs(v[x])==2){
        updpos(x+1,v[x]/2);
        v[x]=0;
    }tvl+=(v[x]!=0);
    if(tvl) b.upd(x,tvl);
}
void Update(int a,int b){
    int sgn=1;if(a<0) sgn=-1,a=-a;
    for(int i=0;i<=30;i++){
        if((a>>i)&1) updpos(b+i,sgn);
    }
    //for(int i=1;i<=15;i++) cout<<v[i]<<' ';cout<<endl;
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int o1,o2,o3;
    cin>>n>>o1>>o2>>o3;LM=n*30+50;
    for(int i=1;i<=n;i++){
        int op,a,b;
        cin>>op;
        if(op==1){
            cin>>a>>b;b++;
            Update(a,b);
        }else{
            cin>>a;a++;
            cout<<Query(a)<<'\n';
        }
    }cout.flush();
    return 0;
}
```

---

## 作者：yuanruiqi (赞：0)

直接在 bitset 上暴力维护加法的复杂度可以做到 $O(n\log V)$。但是反复的执行加法和减法可能会导致复杂度错误，所以考虑分别维护加减操作分别的和 $x,y$。对于查询某个二进制位，容易发现只和 $x,y$ 的第 $k$ 位以及前 $k-1$ 位数字的大小关系有关。判断大小可以使用 `set` 维护出 $x \ xor\  y$，查询前 $k-1$ 位里最大的不同数位。

---

## 作者：小木虫 (赞：0)

### Preface  
绝世“好”题。  
### Problem  
给一个 $n$ 位二进制数 $v$，$q$ 次操作，支持加减 $n$ 位二进制数 $x$，$x$ 可以被表示为 $a\times 2^b$，支持动态查询 $v$ 某一位的比特值。  
$|a|\leq 10^9,b\leq 3\times 10^7,n\leq 3\times 10^7,q\leq 10^6$。  

### Solution  
发现如果 $a$ 始终是正数的话这题就很呆，暴力均摊分析一下就是 $O(q\log a)$ 的，但是有负数的话均摊分析就失效了（补码的 $1$ 很多）。  

那么考虑一下 $|a|=1$ 的情况怎么做，然后尝试推广到全体。  

设 $s$ 为 $v$ 的位数组，即 $s$ 的每一个元素均为 $0$ 或 $1$，且 $\sum_{i=0}^ns_i\times 2^i = v$。  
显然，如果不需要进位或退位的话直接改，否则：  
如果执行的是加法操作，设 $c=\min_{s_i=0,i>b}i$，反转 $[b,c]$ 内的所有数。  
如果执行的是减法操作，设 $c=\min_{s_i=1,i>b}i$，反转 $[b,c]$ 内的所有数。  

于是 $|a|=1$ 这部分的分数可以用线段树+线段树上二分做到 $O(q\log n)$。

然后我们考虑推广到全部情况。  
如果直接暴力拆位然后套用上述方法是 $O(q\log n\log a)$ 的，鬼都知道过不了。  

但是如果这么看的话这两个 $\log$ 似乎消不去任意一个。  
考虑操作本质为二进制高精度运算，而其中有一个 $\log$ 是逐位运算得到的，容易联想到压位高精度，由于 $a\times 2^b$ 中的 $1$ 靠的都很近，所以很容易被压到一起。  

我们将 $v$ 每 $32$ 位压成一个 unsigned int，此时我们就不需要暴力拆每一位，可以直接把 $a\times 2^n$ 拆成至多两份，每一份在一个 unsigned int 里，最终的复杂度即为 $O(q\log n)$，可以轻松不卡常通过此题。  

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+10;
const int maxn=1e6;
int n,t1,t2,t3,op,a,b,k,flg;
ll OR[N<<2],AND[N<<2],lazy[N<<2],Max;
void pushdown(int rt){
	if(lazy[rt]){
		lazy[rt<<1]=lazy[rt];
		lazy[rt<<1|1]=lazy[rt];
		OR[rt<<1]=AND[rt<<1]=OR[rt];
		OR[rt<<1|1]=AND[rt<<1|1]=OR[rt];
		lazy[rt]=0;
	}
}
void ins(int rt,int left,int right,int x){
	if(left<right)pushdown(rt);
	if(left==right){
		OR[rt]+=x;AND[rt]+=x;
		//cout<<"pos: "<<left<<endl;
		//if(OR[rt]<0||OR[rt]>Max){
		//	cout<<OR[rt]<<" "<<x<<endl;
		//}
		assert(OR[rt]>=0&&OR[rt]<=Max);
		return;
	}
	int mid=(left+right)>>1;
	if(x==1){
		if(AND[rt<<1]!=Max){
			ins(rt<<1,left,mid,1);
		}else{
			OR[rt<<1]=AND[rt<<1]=0;
			lazy[rt<<1]=-1;
			ins(rt<<1|1,mid+1,right,1);
		}
	}else{
		if(OR[rt<<1]!=0){
			ins(rt<<1,left,mid,-1);
		}else{
			OR[rt<<1]=AND[rt<<1]=Max;
			lazy[rt<<1]=1;
			ins(rt<<1|1,mid+1,right,-1);
		}
	}
	OR[rt]=OR[rt<<1]|OR[rt<<1|1];
	AND[rt]=AND[rt<<1]&AND[rt<<1|1];
}
void update(int rt,int left,int right,int x,ll y){
	if(left<right)pushdown(rt);
	if(rt==1)flg=0;
	if(left==right){
		//cout<<"apos: "<<left<<endl;
		AND[rt]+=y;OR[rt]+=y;
		if(AND[rt]>Max){
			AND[rt]-=(Max+1);
			OR[rt]-=(Max+1);
			flg=1;
		}
		if(AND[rt]<0){
			AND[rt]+=(Max+1);
			OR[rt]+=(Max+1);
			flg=-1;
		}
		return;
	}int mid=(left+right)>>1;
	if(x<=mid)update(rt<<1,left,mid,x,y);
	else update(rt<<1|1,mid+1,right,x,y);
	if(flg){
		if(flg==1){
			if(mid>=x){
				if(AND[rt<<1|1]!=Max){
					ins(rt<<1|1,mid+1,right,1);
					flg=0;
				}else{
					lazy[rt<<1|1]=-1;
					AND[rt<<1|1]=OR[rt<<1|1]=0;
				}
			}
		}else{
			if(mid>=x){
				if(OR[rt<<1|1]!=0){
					ins(rt<<1|1,mid+1,right,-1);
					flg=0;
				}else{
					lazy[rt<<1|1]=1;
					AND[rt<<1|1]=OR[rt<<1|1]=Max;
				}
			}
		}
	}
	OR[rt]=OR[rt<<1]|OR[rt<<1|1];
	AND[rt]=AND[rt<<1]&AND[rt<<1|1];
}
ll query(int rt,int left,int right,int x){
	if(left<right)pushdown(rt);
	if(left==right)return AND[rt];
	int mid=(left+right)>>1;
	if(x<=mid)return query(rt<<1,left,mid,x);
	else return query(rt<<1|1,mid+1,right,x);
}
void upd(int a,int b){
	int pos=b/32;
	int d=b%32;
	ll now=0;
	if(a>=0){
		now=(1ll*a)<<d;
		if(now>Max){
			update(1,0,maxn,pos,now&Max);
			update(1,0,maxn,pos+1,now>>32);
		}else{
			update(1,0,maxn,pos,now);
		}
	}else{
		a=-a;
		now=(1ll*a)<<d;
		if(now>Max){
			update(1,0,maxn,pos,-(now&Max));
			update(1,0,maxn,pos+1,-(now>>32));
		}else{
			update(1,0,maxn,pos,-now);
		}
	}
}
int ask(int k){
	int pos=k/32;
	int d=k%32;
	unsigned int ans=query(1,0,maxn,pos);
	//cout<<ans<<"\n";
	return (ans>>d)&1;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>t1>>t2>>t3;
	Max=(1ll<<32)-1;int cnt=0;
	while(n--){
		//cout<<++cnt<<endl;
		cin>>op;
		if(op==1){
			cin>>a>>b;
			upd(a,b);
		}else{
			cin>>k;
			cout<<ask(k)<<"\n";
		}
		//for(int i=12;i>=0;i--)
		//	cout<<ask(i);
		//cout<<"\n";
	}
	return 0;
}

```

---

## 作者：Unnamed114514 (赞：0)

$O(n\log^2n)$ 超绝超爽算法！

发现问题和二进制相关，考虑模拟。

考虑拿 `set` 维护 $1$ 的位置。

- 减法

在某一位 $i$ 减去 $1$：

注意到这个时候这个时候应该向高位找到一个离它最近的 $1$，向这一位 $j$ 借位。

那么 $j$ 这一位借位，变成 $0$，后面的位都得到了，变成 $1$。

那么相当于 $i$ 到 $j-1$ 位都变成了 $1$。

那么直接一个一个插入肯定是不行的。

于是可以想到拿 `set` 维护 $1$ 的区间。

注意：这些区间是彼此不相交，不可合并的，具体来说就是 $r_1+1<l_2$。（这是个很重要的实现细节）

- 加法

在某一位 $i$ 加上 $1$：

考虑的是进位。

于是我们直接在 `set` 里面找到覆盖了 $i$ 的区间，如果没有就插入一个 $[i,i]$ 的区间，注意要和左右区间合并。

注意到加入是 $[l,r]$ 覆盖了 $i$，那么 $[l,i-1]$ 无影响，直接插入回 `set`。$[i,r]$ 进位就进到了 $r+1$。那么插入 $[r+1,r+1]$ 的区间即可，注意仍然要和左右合并。

- 查询

思路基本同上。

找到覆盖 $k$ 的区间，不存在就是 $0$，存在就是 $1$。

时间复杂度 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r;
	inline bool operator <(const node &o) const{ return l<o.l; }
};
set<node> s;
int q,t1,t2,t3,len=-1;
inline void ins(int pos){
	auto it=s.upper_bound(node({pos,pos}));
	int l=pos,r=pos;
	if(it!=s.begin()&&(it->l)==pos+1) r=(it->r);
	if(it==s.begin()){
		if(r!=pos) s.erase(it);
		s.insert(node({pos,r}));
		return;
	}
	--it;
	if((it->r)==pos-1) l=(it->l);
	if(l!=pos) s.erase(it);
	if(r!=pos) s.erase(s.find(node({pos+1,r})));
	s.insert(node({l,r}));
}
inline char gc(){
    static char buf[1000010],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000010,stdin),p1==p2)?EOF:*p1++;
}
inline void read(int &x){
    int f=1;
	x=0;
    static char s=gc();
    while(s<'0'||s>'9') f=(s=='-'?-1:1),s=gc();
    while(s>='0'&&s<='9') x=(x<<3)+(x<<1)+(s^48),s=gc();
    x*=f;
}
static char buf[1000010];
inline void flush(){
    fwrite(buf,1,len+1,stdout);
    len=-1;
}
inline void __PC(const char x){
    if(len == 1000000) flush();
    buf[++len]=x;
}
int main(){
	freopen("P3822_3.in","r",stdin);
	read(q),read(t1),read(t2),read(t3);
	while(q--){
		int op;
		read(op);
		if(op==1){
			int a,b;
			read(a),read(b);
			cout<<a<<endl;
			if(!a) continue;
			if(a>0){
				for(int i=0,mx=log2(a);i<=mx;++i) if((a>>i)&1){
					auto it=s.upper_bound(node({i+b,i+b}));
					if(it==s.begin()){
						ins(i+b);
						continue;		
					}						
					--it;
					int l=(it->l),r=(it->r);
					if(i+b>r){
						ins(i+b);
						continue;		
					}
					s.erase(it);
					if(i+b!=l) s.insert(node({l,i+b-1}));
					ins(r+1);
				} 
			} else{
				a=-a;
				for(int i=log2(a);~i;--i) if((a>>i)&1){
					auto it=s.upper_bound(node({i+b,i+b}));
					int l,r;
					if(it!=s.begin()){
						--it;
						l=(it->l),r=(it->r);
						if(r>=i+b){
							s.erase(it);
							if(i+b!=l) s.insert(node({l,i+b-1}));	
							if(i+b!=r) s.insert(node({i+b+1,r}));
							continue;
						}
						++it;
					}
					l=(it->l),r=(it->r);
					int L=i+b;
					s.erase(it);
					it=s.upper_bound(node({i+b-1,i+b-1}));
					if(it!=s.begin()){
						--it;
						if((it->r)==i+b-1) L=(it->l),s.erase(it);
					}
					if(l!=r) s.insert(node({l+1,r}));
					s.insert(node({L,l-1}));
				}
			}
		} else{
			int k;
			read(k);
			auto it=s.upper_bound(node({k,k}));
			if(it==s.begin()){
				__PC('0'),__PC('\n');
				continue;
			}
			--it;
			if(k>(it->r)) __PC('0'),__PC('\n');
			else __PC('1'),__PC('\n');
		}
	}
	flush();
	return 0;
}
```

---

## 作者：lgswdn_SA (赞：0)

一个无任何思考难度的解法，就是常数有点大。

考虑 $\pm 2^b$ 怎么做。我们一定是在线段树上二分到 $b$ 开始的一段连续 $0$ 或者 $1$ 段，然后 flip 一下。

然后考虑 $\pm a$ 怎么做。$a$ 最多是 $V=10^9$ 的，那么我们考虑暴力取出 $[b,b+29]$ 位的线段树上的叶节点，修改后 pushup。这个操作需要用到的节点数是 $\log V+\log n$ 的。然后可能会有到 $b+30$ 位的进位或退位，这就是一个 $\pm 2^b$ 的问题了。

复杂度 $O(n\log V)$。线段树可能需要卡卡空间，不过实际上只需要维护一个 tag（可以用 bitset 存），子树内 $1$ 个数还有左儿子（右儿子设为左儿子加一）就可以了。

唯一的缺点是跑的确实比较慢，但是正常写肯定能过。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define fi first
#define se second
#define eb emplace_back
#define popc __builtin_popcount
#define clz __builtin_clz
#define ctz __builtin_ctz
#define sgn(x) ((x)&1?-1:1)
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef tuple<int,int,int> tiii;
typedef vector<int> vi;
typedef vector<pii> vp;
typedef unsigned long long ull;
typedef long double ld;
 
int read() {
	int x=0,w=1; char c=getchar(); 
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) {x=x*10+c-'0'; c=getchar();}
	return x*w;
}

const int N=30000100,lim=30000052;
int n,t1,t2,t3,y;

namespace SegT {
	int t[N<<1],ls[N<<1],tot=1,st[5009],top,f[5009],cnt,p[5009];
	#define rs(p) (ls[p]+1)
	bitset<N*2>tag;
	void flip(int p,int l,int r) {t[p]=r-l+1-t[p], tag[p]=tag[p]^1;}
	void psu(int p) {t[p]=t[ls[p]]+t[ls[p]+1];}
	void psd(int p,int l,int r) {
		int mid=l+r>>1;
		if(tag[p]) flip(ls[p],l,mid), flip(ls[p]+1,mid+1,r), tag[p]=0;
	}
	void build(int p,int l,int r) {
		if(l==r) {t[p]=0; return;} int mid=l+r>>1;
		++tot, ++tot, build(ls[p]=tot-1,l,mid), build(ls[p]+1,mid+1,r);
		psu(p);
	}
	int qry(int p,int l,int r,int x) {
		if(l==r) return t[p]; psd(p,l,r); int mid=l+r>>1;
		if(x<=mid) return qry(ls[p],l,mid,x);
		else return qry(ls[p]+1,mid+1,r,x);
	}
	void get(int p,int l,int r,int x,int y) {
		if(l==r) {f[++cnt]=p; return;}
		psd(p,l,r); int mid=l+r>>1; st[++top]=p;
		if(y<=mid) get(ls[p],l,mid,x,y);
		else if(x>mid) get(ls[p]+1,mid+1,r,x,y);
		else get(ls[p],l,mid,x,mid), get(ls[p]+1,mid+1,r,mid+1,y);
	}
	void flip(int p,int l,int r,int x,int y) {
		if(l==x&&r==y) {flip(p,l,r); return;}
		psd(p,l,r); int mid=l+r>>1;
		if(y<=mid) flip(ls[p],l,mid,x,y);
		else if(x>mid) flip(ls[p]+1,mid+1,r,x,y);
		else flip(ls[p],l,mid,x,mid), flip(ls[p]+1,mid+1,r,mid+1,y);
		psu(p);
	}
	bool add(int p,int l,int r,int x) {
		if(!(r-l+1-t[p])) return 0;
		if(l==r) {flip(1,0,lim,x,l); return 1;} int mid=l+r>>1; psd(p,l,r);
		if(x>mid||!(r-l+1-t[ls[p]])) return add(ls[p]+1,mid+1,r,x);
		else if(!add(ls[p],l,mid,x)) return add(ls[p]+1,mid+1,r,x);
		else return 1;
	}
	bool mns(int p,int l,int r,int x) {
		if(!t[p]) return 0;
		if(l==r) {flip(1,0,lim,x,l); return 1;} int mid=l+r>>1; psd(p,l,r);
		if(x>mid||!t[ls[p]]) return mns(ls[p]+1,mid+1,r,x);
		else if(!mns(ls[p],l,mid,x)) return mns(ls[p]+1,mid+1,r,x);
		else return 1;
	}
	void modify(int a,int b) {
		cnt=0, top=0, get(1,0,lim,b,b+29);
		rep(i,1,31) p[i]=0;
		rep(i,1,30) p[i]=t[f[i]];
		int tp=0; if(a<0) tp=1, a=-a;
		rep(i,1,30) {
			int x=a&1; a>>=1;
			if(tp==0) p[i]+=x;
			else p[i]-=x;
			if(p[i]>=2) p[i]-=2, p[i+1]++;
			else if(p[i]<0) p[i]+=2, p[i+1]--;
		}
		rep(i,1,30) if(p[i]!=t[f[i]]) flip(f[i],b+i-1,b+i-1);
		per(i,top,1) psu(st[i]);
		if(p[31]>0) add(1,0,lim,b+30);
		else if(p[31]<0) mns(1,0,lim,b+30);
	}
}

signed main() {
	n=read(), t1=read(), t2=read(), t3=read();
	SegT::build(1,0,lim);
	rep(i,1,n) {
		int op=read();
		if(op==1) {
			int a=read(), b=read();
			SegT::modify(a,b);
		} else {
			int res, k=read();
			printf("%d\n",res=SegT::qry(1,0,lim,k));
		}
	}
	return 0;
}
```

---

## 作者：天南星魔芋 (赞：0)

首先考虑暴力，用布尔型数组储存每个位置上的值（$0$ 或 $1$），暴力按位修改。

但是碰到加负数时就不好办了，于是正负分开记录，然后考虑如何判断每一位的数：

1. 若当前位相同，后缀非负则答案为 $0$，否则为 $1$。

2. 若当前位不同，后缀非负则答案为 $1$，否则为 $0$。

但是暴力比较后缀肯定超时，我们可以用 STL set 记录正负数组不同的位置，达到 $\log(n)$ 级别的查询。

考虑到内存问题，我们可以将布尔型数组该改为 bitset。

时间复杂度约 $O(n(\log(n))^2)$。

$code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
set<int>SET;
bitset<30005000>aa,bb;
void insert(int x){
	SET.insert(x);
}
void erase(int x){
	SET.erase(x);
}
void aa_add(int x,int v){
	int zz=v,l=v+1,r=0;
	while(x){
		int ad=(x&1);++zz;
		if(ad){
			if(aa[zz]){aa.set(zz,0);x++;}
			else aa.set(zz,1);
		}
		x>>=1;
	}
	r=zz;
	for(int i=l;i<=r;i++){
		(aa[i]^bb[i])? insert(i):erase(i);
	}
}
void bb_add(int x,int v){
	int zz=v,l=v+1,r=0;
	while(x){
		int ad=(x&1);++zz;
		if(ad){
			if(bb[zz]){bb.set(zz,0);x++;}
			else bb.set(zz,1);
		}
		x>>=1;
	}
	r=zz;
	for(int i=l;i<=r;i++){
		(aa[i]^bb[i])? insert(i):erase(i);
	}
}
void add(int x,int v){
	(x>0)? aa_add(x,v):bb_add(-x,v); 
}
void ask(int x){
	int pd1,pd2;
	auto zz=SET.lower_bound(x);
	zz--;
	pd1=(aa[x]^bb[x])? 1:0;
	pd2=(aa[*zz]<bb[*zz])? 1:0;
	puts((pd1^pd2)? "1":"0");
}
int main(){
	//freopen("integer.in","r",stdin);
	//freopen("integer.out","w",stdout);
	int n,opt,a,b;
	cin>>n>>opt>>opt>>opt;
	SET.insert(0);
	SET.insert(30*n+50);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&opt,&a);
		if(opt==1){
			scanf("%d",&b);
			add(a,b);
		}
		else{
			ask(++a);
		}
	}
}
```


---


# [NOI2017] 游戏

## 题目背景

【本题原题时限 1s】

狂野飙车是小 L 最喜欢的游戏。与其他业余玩家不同的是，小 L 在玩游戏之余，还精于研究游戏的设计，因此他有着与众不同的游戏策略。


## 题目描述

小 L 计划进行 $n$ 场游戏，每场游戏使用一张地图，小 L 会选择一辆车在该地图上完成游戏。

小 L 的赛车有三辆，分别用大写字母 $A$、$B$、$C$ 表示。地图一共有四种，分别用小写字母 $x$、$a$、$b$、$c$ 表示。

其中，赛车 $A$ 不适合在地图 $a$ 上使用，赛车 $B$ 不适合在地图 $b$ 上使用，赛车 $C$ 不适合在地图 $c$ 上使用，而地图 $x$ 则适合所有赛车参加。

适合所有赛车参加的地图并不多见，最多只会有 $d$ 张。

$n$ 场游戏的地图可以用一个小写字母组成的字符串描述。例如：$S=\texttt{xaabxcbc}$ 表示小 L 计划进行 $8$ 场游戏，其中第 $1$ 场和第 $5$ 场的地图类型是 $x$，适合所有赛车，第 $2$ 场和第 $3$ 场的地图是 $a$，不适合赛车 $A$，第 $4$ 场和第 $7$ 场的地图是 $b$，不适合赛车 $B$，第 $6$ 场和第 $8$ 场的地图是 $c$，不适合赛车 $C$。

小 L 对游戏有一些特殊的要求，这些要求可以用四元组 $ (i, h_i, j, h_j) $ 来描述，表示若在第 $i$ 场使用型号为 $h_i$ 的车子，则第 $j$ 场游戏要使用型号为 $h_j$ 的车子。

你能帮小 L 选择每场游戏使用的赛车吗？如果有多种方案，输出任意一种方案。

如果无解，输出 `-1`。

## 说明/提示

### 样例 1 解释

小 $L$ 计划进行 $3$ 场游戏，其中第 $1$ 场的地图类型是 $x$，适合所有赛车，第 $2$ 场和第 $3$ 场的地图是 $c$，不适合赛车 $C$。

小 $L$ 希望：若第 $1$ 场游戏使用赛车 $A$，则第 $2$ 场游戏使用赛车 $B$。

那么为这 $3$ 场游戏分别安排赛车 $A$、$B$、$A$ 可以满足所有条件。

若依次为 $3$ 场游戏安排赛车为 $BBB$ 或 $BAA$ 时，也可以满足所有条件，也被视为正确答案。

但依次安排赛车为 $AAB$ 或 $ABC$ 时，因为不能满足所有条件，所以不被视为正确答案。

### 样例 2

详见附加文件。

### 数据范围

| 测试点编号 |        $n$         |   $d$   |    $m$     |        其他性质         |
| :--------: | :----------------: | :-----: | :--------: | :---------------------: |
|    $1$     |      $\le 2$       |   $0$   |  $\le 4$   |           无            |
|    $2$     |      $\le 2$       | $\le n$ |  $\le 4$   |           无            |
|    $3$     |      $\le 5$       |   $0$   |  $\le 10$  |           无            |
|    $4$     |      $\le 5$       | $\le n$ |  $\le 10$  |           无            |
|    $5$     |      $\le 10$      |   $0$   |  $\le 20$  |           无            |
|    $6$     |      $\le 10$      | $\le 8$ |  $\le 20$  |           无            |
|    $7$     |      $\le 20$      |   $0$   |  $\le 40$  |    $S$ 中只包含 $c$     |
|    $8$     |      $\le 20$      |   $0$   |  $\le 40$  |           无            |
|    $9$     |      $\le 20$      | $\le 8$ |  $\le 40$  | $S$ 中只包含 $x$ 或 $c$ |
|    $10$    |      $\le 20$      | $\le 8$ |  $\le 40$  |           无            |
|    $11$    |     $\le 100$      |   $0$   | $\le 200$  |    $S$ 中只包含 $c$     |
|    $12$    |     $\le 100$      |   $0$   | $\le 200$  |           无            |
|    $13$    |     $\le 100$      | $\le 8$ | $\le 200$  | $S$ 中只包含 $x$ 或 $c$ |
|    $14$    |     $\le 100$      | $\le 8$ | $\le 200$  |           无            |
|    $15$    | $\le 5\times 10^3$ |   $0$   | $\le 10^4$ |           无            |
|    $16$    | $\le 5\times 10^3$ | $\le 8$ | $\le 10^4$ | $S$ 中只包含 $x$ 或 $c$ |
|    $17$    | $\le 5\times 10^3$ | $\le 8$ | $\le 10^4$ |           无            |
|    $18$    | $\le 5\times 10^4$ |   $0$   | $\le 10^5$ |           无            |
|    $19$    | $\le 5\times 10^4$ | $\le 8$ | $\le 10^5$ | $S$ 中只包含 $x$ 或 $c$ |
|    $20$    | $\le 5\times 10^4$ | $\le 8$ | $\le 10^5$ |           无            |

## 样例 #1

### 输入

```
3 1
xcc
1
1 A 2 B```

### 输出

```
ABA```

# 题解

## 作者：xyz32768 (赞：81)

$NOI2017 Day2 T1$。

$2-SAT$。

我那时候一看发现是NOI/NOI+/CTSC的难度我没敢去做，但是一看，过的人还是比较多的，就试着做了一下...不多说了，讲一讲做法：

可以发现，除了x地图之外，其余的地图只适合两种赛车。而在这里，我们先假设所有的地图都适合且只适合两种赛车，这样就是$2-SAT$裸题了。

对于每场游戏用两个点$i$和$i'$，分别表示第$i$场游戏使用该地图适合的第一种赛车和第二种赛车（举例：如果第$i$场游戏的地图不适合A赛车，那么点$i$表示第$i$场游戏使用B赛车，点$i'$表示第$i$场游戏使用C赛车）。

对于每个限制条件，设$u$为表示「第$i$场游戏使用型号为$hi$的赛车」的点（在第$i$场游戏的地图适合型号为$hi$的赛车的情况下），$v$为表示「第$j$场游戏使用型号为$hj$的赛车」的点（在第$j$场游戏的地图适合型号为$hj$的赛车的情况下），

那么，

如果第$i$场游戏的地图不适合型号为$hi$的赛车，那么不做任何操作。

如果第$i$场游戏的地图适合型号为$hi$的赛车，但第$j$场游戏的地图不适合型号为$hj$的赛车，那么建边$u->u'$，表示如果第$i$场游戏使用了型号为$hi$的赛车则一定无解。

如果第$i$场游戏的地图适合型号为$hi$的赛车，第$j$场游戏的地图适合型号为$hj$的赛车，那么建边$u->v$，表示如果第$i$场游戏使用了型号为$hi$的赛车则第$j$场游戏必须使用型号为$hj$的赛车，再建边$v'->u'$，表示如果第$j$场游戏不使用型号为$hj$的赛车则第$i$场游戏不得使用型号为$hi$的赛车。

所有边都建完之后跑一遍$Tarjan$强连通分量缩点。对于任意一个$i$，如果$i$和$i'$在同一个强连通分量里面，那么此时无解。

否则输出方案。$2-SAT$输出方案的方法为：先把缩点之后的新图进行拓扑排序，然后判断每个点$i$，如果$i$所在强连通分量的拓扑序在$i'$所在的强连通分量的拓扑序之后，那么第$i$场游戏使用该地图适合的第一种赛车，否则使用第二种赛车。但是由于$Tarjan$求强连通分量就是按拓扑排序的逆序给出的，所以直接使用强连通分量编号判断即可。即如果$bel[]$为每个点的所在强连通分量编号，那么判断为：如果$bel[i]<bel[i']$，那么使用该地图适合的第一种赛车，否则使用第二种赛车。

现在考虑x地图，考虑到只有8张x地图，如果假设它也只适合两种赛车，那么暴力枚举每个x地图不适合赛车A或不适合赛车B（因为不适合赛车A就是适合赛车BC，不适合赛车B就是适合赛车AC，这样就包含了ABC三种赛车），这样每种地图就都只适合两种赛车了。判断时，如果已经枚举遍了所有的$2^d$种状态都是无解，则原问题无解，否则输出任意一种方案。

复杂度$O((n+m)*2^d)$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get() {
    char c; while ((c = getchar()) != 'A' && c != 'B' && c != 'C');
    return c;
}
const int N = 2e5 + 5;
int n, d, m, a1[N], b1[N], ecnt, nxt[N], adj[N], go[N], dfn[N], low[N],
times, num, bel[N], top, stk[N], cyx[N];
char s[N], a2[N], b2[N], orz[N];
bool ins[N], flag;
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
int neg(int x) {return x > n ? x - n : x + n;}
int tran(int x, char c) {
    if (s[x] == 'a') return c == 'B' ? x : x + n;
    if (s[x] == 'b' || s[x] == 'c') return c == 'A' ? x : x + n;
    if (c == 'C') return x + n; return x;
}
void Tarjan(int u) {
    dfn[u] = low[u] = ++times; ins[stk[++top] = u] = 1;
    for (int e = adj[u], v; e; e = nxt[e])
        if (!dfn[v = go[e]]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    if (dfn[u] == low[u]) {
        int v; bel[u] = ++num; ins[u] = 0;
        while (v = stk[top--], v != u) bel[v] = num, ins[v] = 0;
    }
}
bool solve() {
    int i; ecnt = times = num = 0;
    for (i = 1; i <= (n << 1); i++) bel[i] = adj[i] = dfn[i] = 0;
    for (i = 1; i <= m; i++) if (s[a1[i]] != 'x' && s[b1[i]] != 'x') {
        if (a2[i] == s[a1[i]] - 32) continue;
        int u = tran(a1[i], a2[i]), v;
        if (b2[i] == s[b1[i]] - 32) {add_edge(u, neg(u)); continue;}
        v = tran(b1[i], b2[i]); add_edge(u, v);
        add_edge(neg(v), neg(u));
    }
    else {
        char o = s[a1[i]], p = s[b1[i]];
        int u, v, x = cyx[a1[i]], y = cyx[b1[i]];
        if (o == 'x' && p == 'x') {
            if (a2[i] == orz[x]) continue;
            u = tran(a1[i], a2[i]), v;
            if (b2[i] == orz[y]) {add_edge(u, neg(u)); continue;}
            v = tran(b1[i], b2[i]); add_edge(u, v);
            add_edge(neg(v), neg(u));
        }
        else if (o == 'x' && p != 'x') {
            if (a2[i] == orz[x]) continue;
            u = tran(a1[i], a2[i]), v;
            if (b2[i] == s[b1[i]] - 32) {add_edge(u, neg(u)); continue;}
            v = tran(b1[i], b2[i]); add_edge(u, v);
            add_edge(neg(v), neg(u));
        }
        else {
            if (a2[i] == s[a1[i]] - 32) continue;
            u = tran(a1[i], a2[i]), v;
            if (b2[i] == orz[y]) {add_edge(u, neg(u)); continue;}
            v = tran(b1[i], b2[i]); add_edge(u, v);
            add_edge(neg(v), neg(u));
        }
    }
    for (i = 1; i <= (n << 1); i++) if (!dfn[i]) Tarjan(i);
    for (i = 1; i <= n; i++) if (bel[i] == bel[i + n]) return 0;
    for (i = 1; i <= n; i++) {
        if (bel[i] < bel[i + n]) {
            if (s[i] == 'a') putchar('B');
            else if (s[i] == 'b' || s[i] == 'C') putchar('A');
            else if (orz[cyx[i]] == 'A') putchar('B');
            else putchar('A');
        }
        else {
            if (s[i] == 'a' || s[i] == 'b') putchar('C');
            else if (s[i] == 'c') putchar('B');
            else if (orz[cyx[i]] == 'A') putchar('C');
            else putchar('B');
        }
    }
    return 1;
}
void dfs(int dep) {
    if (dep > d) {
        if (!flag) flag = solve();
        if (flag) exit(0);
        return;
    }
    orz[dep] = 'A'; dfs(dep + 1);
    orz[dep] = 'B'; dfs(dep + 1);
}
int main() {
    int i; n = read(); read();
    scanf("%s", s + 1); m = read();
    for (i = 1; i <= n; i++) if (s[i] == 'x') cyx[i] = ++d;
    for (i = 1; i <= m; i++) a1[i] = read(), a2[i] = get(),
        b1[i] = read(), b2[i] = get(); dfs(1);
    if (!flag) puts("-1");
    return 0;
}
```

---

## 作者：Fading (赞：51)

真心感觉其他题解有一点误人子弟...


------------


显然，对于$a,b,c$类型的跑道，只有两种取值。所以可以转换为$2-SAT$。

那么有$x$型跑道怎么办呢？

别的题解会讲：搜索枚举每一个$x$是选$AB$还是选$AC$，$BC$不用枚举，因为已经**包含**了。

这里着重讲一下$x$型跑道为什么只用枚举两次。

### 算法$1:$

注意到$d$很小，所以我们可以爆搜枚举$x$到底选什么。

我们可以考虑枚举每一个$x$的取值范围——跑道类型。

假设我们现在枚举第$i$个$x$类型跑道。

如果我们当前枚举它是$a$类型跑道（当前$x$赛道开的车是$B$或$C$）

所以这个$x$一定不选$A$。所以对于每一个关于这个$x$的限制：

#### 第一种：如果第$i$个跑道$A$，则第$j$个跑道选...

由于这个跑道不选$A$，所以这条限制作废。

#### 第二种：如果第$j$个跑道选$X$类型，则第$i$个跑道选$A$，

由于这个跑道不选$A$，所以第$j$个跑道一定不选$X$类型。

注意这两种可能是**搭配**的，可能第$j$个跑道和第$i$个跑道都是$x$型。

我们成功断绝了$A$对于这个点的影响（$m$个限制）。

这样子我们就可以用$2-SAT$求解，来判断选$B$或选$C$是否可行了（即是否有解）。

枚举第$i$个$x$类型跑道是$b,c$型也是一样的。

时间复杂度$O(3^d(n+m))$。无法通过此题。

### 算法$2:$

讲了个错解有什么用呢？

发现算法$1$是枚举：

- 只有$A,B$两种选择（绝对不选$C$），是否有解。

- 只有$B,C$两种选择（绝对不选$A$），是否有解。

- 只有$A,C$两种选择（绝对不选$B$），是否有解。

最终$x$选择的赛车类型是**固定**的。

所以在枚举只有$B,C$两种选择的时候，由于断绝了$A$对于$i$的所有联系（如果你不明白可以看看处理$A$赛车的方式，上述方式使得枚举过程和$A$变得毫无关系，即绝对不选$A$），所以我们相当于判断了第$i$个位置选$B$是否可行，以及选$C$是否可行。

综上所述，若枚举“只有$A,C$两种选择”“只有$B,C$两种选择”两种情况，我们就遍历了三种情况：选$B$是否可行，选$C$是否可行，以及选$A$是否可行。

复杂度将降为$O(2^d(n+m))$，可以通过此题。

代码：

```
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#define gc getchar
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
struct edge{
    int to,nxt;
}g[2000001];
int tot,head[2000001],len,n,A,B,m,col[2000001];
int pre[1000001],id,a1[1000001],b1[1000001];
int vis[2000001],pos[11],all,d,dfn[2000001],low[2000001];
char s[1000001],a2[1000001],b2[1000001];
stack<int> S;
inline void made(int from,int to){
    g[++tot].to=to;g[tot].nxt=head[from];head[from]=tot;
}
void tarjan(int u){
    low[u]=dfn[u]=++id;S.push(u);vis[u]=1;
    for (int i=head[u];i;i=g[i].nxt){
        int v=g[i].to;
        if (!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }else if (vis[v]){
            low[u]=min(low[u],dfn[v]);
        }
    }
    if (low[u]==dfn[u]){
        len++;
        while (S.top()!=u){
            int x=S.top();S.pop();
            col[x]=len;vis[x]=0;
        }
        col[u]=len;S.pop();vis[u]=0;
    }
}
inline int trans(int a,char B){
	char A=s[a];
	if (A=='c'){
		if (B=='A') return 0;
		else return 1;
	}else if (A=='b'){
		if (B=='A') return 0;
		else return 1;
	}else if (A=='a'){
		if (B=='B') return 0;
		else return 1;
	}else{
		if (B=='C') return 1;
		return 0;
	}
}
inline char upr(char y){
	return (char)(y-32);
}
signed main(){
	n=read(),d=read();
	for (int i=1;i<=n;i++){
		char ch=gc();
		while (!isalpha(ch)) ch=getchar();
		s[i]=ch;
		if (s[i]=='x') pre[i]=++all;
	}
	m=read();
	for (int i=1;i<=m;i++){
		a1[i]=read();char ch=gc();
		while (!isalpha(ch)) ch=getchar();
		a2[i]=ch;b1[i]=read();ch=gc();
		while (!isalpha(ch)) ch=getchar();
		b2[i]=ch;
	}
	int MX=(1<<d)-1;
	for (int zt=0;zt<=MX;zt++){
		//0 AC    1 BC
		tot=id=len=0;
		while (!S.empty()) S.pop();
		for (int i=1;i<=2*n;i++){
			head[i]=low[i]=col[i]=dfn[i]=vis[i]=0;
		}
		for (int i=1;i<=m;i++){
			if (s[a1[i]]=='x'&&s[b1[i]]=='x'){
				int zta=(zt&(1<<(pre[a1[i]]-1)));
				int ztb=(zt&(1<<(pre[b1[i]]-1)));
				if (!zta&&a2[i]=='B') continue;
				if (zta&&a2[i]=='A') continue;
				int I=trans(a1[i],a2[i]),J=trans(b1[i],b2[i]);
				if (!ztb&&b2[i]=='B'){
					made(a1[i]+n*I,a1[i]+n*(I^1));continue;
				}
				if (ztb&&b2[i]=='A'){
					made(a1[i]+n*I,a1[i]+n*(I^1));continue;
				}
				made(a1[i]+n*I,b1[i]+n*J);made(b1[i]+n*(J^1),a1[i]+n*(I^1));
			}else if (s[a1[i]]!='x'&&s[b1[i]]=='x'){
				int ztb=(zt&(1<<(pre[b1[i]]-1)));
				int I=trans(a1[i],a2[i]),J=trans(b1[i],b2[i]);
				if (upr(s[a1[i]])==a2[i]) continue;
				if (!ztb&&b2[i]=='B'){
					made(a1[i]+n*I,a1[i]+n*(I^1));continue;
				}
				if (ztb&&b2[i]=='A'){
					made(a1[i]+n*I,a1[i]+n*(I^1));continue;
				}
				made(a1[i]+n*I,b1[i]+n*J);made(b1[i]+n*(J^1),a1[i]+n*(I^1));
			}else if (s[a1[i]]=='x'&&s[b1[i]]!='x'){
				int zta=(zt&(1<<(pre[a1[i]]-1)));
				int I=trans(a1[i],a2[i]),J=trans(b1[i],b2[i]);
				if (!zta&&a2[i]=='B') continue;
				if (zta&&a2[i]=='A') continue;
				if (upr(s[b1[i]])==b2[i]){
					made(a1[i]+n*I,a1[i]+n*(I^1));continue;
				}
				made(a1[i]+n*I,b1[i]+n*J);made(b1[i]+n*(J^1),a1[i]+n*(I^1));
			}else{
				int I=trans(a1[i],a2[i]),J=trans(b1[i],b2[i]);
				if (upr(s[a1[i]])==a2[i]) continue;
				if (upr(s[b1[i]])==b2[i]){
					made(a1[i]+n*I,a1[i]+n*(I^1));continue;
				}
				made(a1[i]+n*I,b1[i]+n*J);made(b1[i]+n*(J^1),a1[i]+n*(I^1));
			}
		}
		for (int i=1;i<=2*n;i++){
			if (!dfn[i]) tarjan(i);
		}
		bool flag=1;
		for (int i=1;i<=n;i++){
			if (col[i]==col[i+n]){
				flag=0;break;
			}
		}
		if (!flag) continue;
		for (int i=1;i<=n;i++){
			int op=(col[i]>col[i+n]);
			if (s[i]=='x'){
				int ZT=(zt&(1<<(pre[i]-1)));
				if (!ZT){
					if (op)	printf("C");
					else printf("A");
				}else{
					if (op)	printf("C");
					else printf("B");
				}
			}else{
				if (s[i]=='a'){
					if (op)	printf("C");
					else printf("B");
				}else if (s[i]=='b'){
					if (op)	printf("C");
					else printf("A");
				}else{
					if (op)	printf("B");
					else printf("A");
				}
			}
		}
		return 0;
	}
	printf("-1");
    return 0;
}

```




---

## 作者：SpXace (赞：43)

$2 - SAT$

研究前面$Dalao$的题解半天， 但是感觉对初学$2 - SAT$的蒟蒻并不是很友好，$Dalao$们重点都在强调$x$地图的处理方法，但本蒟蒻在建立关系数组就彻底自闭了，所以希望通过此题解，讨论一下如何建立关系数组。~~(是我太菜了$QWQ$)~~


所以对于$2 - SAT$而言，关键在于构建各种情况关系的数组

对于这道题，表示关系的数组被分为 $1 - N$ 以及$(N+1) - 2*N$， 分别表示此比赛可行的两辆车。

下面讨论这两块的意义:


$~~~~~~$若可以选择的两辆车是$A$和$B$，那么$A$存在于第一块，$B$在第二块；

$~~~~~~$若选择的是$A$和$C$，那么$A$存在于第一块，$C$在第二块；

$~~~~~~$若选择的是$B$和$C$，那么$B$存在于第一块，$C$在第二块；

换言之，对于选择的两辆，按照字典序分别存在于第一块和第二块。

那么如何构建呢？

$Knock~~ the ~~black ~~ board ~~!!!$

对于每个关系 $(i, h_i, j, h_j)$ 如果$i$场比赛根本不能用$h_i$， 显然这个关系无论如何都不能成立，$continue$即可， 见程序中$(1)$。

如果第$j$场比赛不能用$h_j$， 那么这条关系不能成立，即$i$ 不能选$h_i$，只能选择另一辆可行的车， 此时根据前面关系数组的建立，判断$h_i$是第一辆还是第二辆可行的车，将其连到另一个（意为必须选另一个），然后$continue$即可， 见程序中$(2)$。


剩下的情况，就是该关系可以成立：那么需要建立$(i, h_i)$->$(j, h_j)$， 以及$(j, h_j')$ - >$(i, h_i')$ ， 这里的$h_j'  $和$h_i'$都表示不选，之所以建这两条边，具体参考高中数学$X$修$X$ $???$ 逆否命题 (本蒟蒻还没学) ，见程序中$(3)$。

对于$x$的选择问题，可以$2^d$枚举，前面$Dalao$们以及解释清楚，在此不再赘述。

值得注意的还有在计算答案的时候，按照$2-SAT$的习惯，拓扑序小的会被我们选择，而在此题中，则变成了选择第一个地图还是第二个地图的问题。那么显然当$scc[i] < scc[i+N]$时， 我们选择第一个地图只有$A ~~or ~~B$两种情况，反之选择第二个地图，有$B ~~or~~C$两种情况，见程序中$(4)$。至此，问题得解。

小结：对于$2-SAT$算法而言，关键和难点在于设计每组的两个状态，不一定是想经典模型中的选与不选，也可能是如此题的两种选择，要根据题目灵活变化，并将题面加以抽象理解，方能熟练使用。
```
/*
time:2018年10月23日18:35:53
Author:飞马の幻想
place:lzyz
type:2-SAT
from:https:https://www.luogu.org/problemnew/show/P3825
input:
3 1
xcc
1
1 A 2 B
output:
ABA
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#define LL long long
#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define per(i, a, b) for(int i = a; i >= b; --i)
#define clr(a,b)  memset((a),b,sizeof(a))
using namespace std;
inline int Read(){
    int s = 0, w = 1; char ch = getchar();
    while(ch < '0' || ch > '9')   { if(ch == '-') w = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') { s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar(); }
    return s * w;
}
const int MX = 2e5 + 50;
int N, d, y[MX], x[MX], M, k, dfn[MX], low[MX], ins[MX], stc[MX], top, cnt, num;
int to[MX << 1], nxt[MX << 1], head[MX], tot, scc[MX], pos[MX];
char c[MX], p1[MX], p2[MX], res[MX];
inline void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; }
void pre() {
    clr(head, 0); clr(dfn, 0); tot = num = cnt = top = 0;
    clr(low, 0); clr(ins, 0); clr(stc, 0);clr(scc, 0); clr(nxt, 0);
}
void tarjan(int x) {
    dfn[x] = low[x] = ++num;
    ins[x] = 1;
    stc[++top] = x;
    for(int i = head[x]; i; i = nxt[i]) {
        int y = to[i];
        if(!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if(ins[y]) 
            low[x] = min(low[x], dfn[y]);
    }
    if(low[x] == dfn[x]) {
        ++cnt;
        while(top) {
            scc[stc[top]] = cnt;
            ins[stc[top]] = 0;
            if(stc[top --] == x) break;
        }
    }
}
bool check() {
    rep(i, 1, (N << 1)) 
        if(!dfn[i]) tarjan(i);
    rep(i, 1, N) {
        if(scc[i] == scc[i + N]) return false;
        if(scc[i] < scc[N + i]) res[i] = (c[i] == 'A') ? 'B' : 'A';
        else res[i] = (c[i] == 'C') ? 'B' : 'C';
    }
    rep(i, 1, N) printf("%c", res[i]); 
    return true;
}
void solve() {
    rep(i, 0, (1 << d) - 1) { //2^d 枚举状态
        pre();
        rep(j, 1, d) c[pos[j]] = (i & (1 << (j - 1))) ? 'A' : 'B';  //判断每个x地图的情况
        rep(j, 1, M) {
            if(p1[j] == c[x[j]]) continue;//（1）
            if(p2[j] == c[y[j]]) {
                if(p1[j] == 'C' || (p1[j] == 'B' && c[x[j]] == 'C'))  //（2）
                    add(x[j] + N, x[j]);
                else add(x[j], x[j] + N);
                continue;
            }
            //（3）
            int add1 , add2;
            if(p1[j] == 'C' || (p1[j] == 'B' && c[x[j]] == 'C')) add1 = N;
            else add1 = 0;
            if(p2[j] == 'C' || (p2[j] == 'B' && c[y[j]] == 'C')) add2 = N;
            else add2 = 0;
            add(x[j] + add1, y[j] + add2);  //注意建正反两条边
            add(y[j] - add2 + N, x[j] - add1 + N); //从正边到反边可以用-add + N 得到，可手模理解一下
        }
        if(check()) exit(0);
    }
    printf("-1");
    return;
}
int main() {
    N = Read(), d = Read();
    scanf("%s", (c + 1)); M = Read();
    rep(i, 1, M) scanf("%d %c %d %c", &x[i], &p1[i], &y[i], &p2[i]);
    rep(i, 1, N) if((c[i] -= 32) && c[i] == 'X') pos[++k] = i; //小写转化大写，找出x地图
    solve();
    return 0;
}


```








---

## 作者：scallop (赞：26)

这道题很多人的提交交到uoj上会获得97分。

这是因为实际上 $O(2^d\times N)$ 如果被一组无解的数据卡的话就会跑满。

很多人的常数比较大就会TLE(当然你常数小就不会)。

所以我们考虑随机化。每次DFS时随机枚举当前 $x$ 是 $a$ 还是 $b$ 。然后如果次数超过一定程度就直接输出无解。

可以证明这样出错的概率是极低的。

---

## 作者：StudyingFather (赞：22)

先考虑 $d=0$ 的情况，此时每场游戏都有恰好两种车可用，符合 [2-SAT](https://oi-wiki.org/graph/2-sat) 的模型。

对于第 $i$ 场游戏，我们建两个点 $i$ 和 $i'$，其中 $i$ 表示第 $i$ 场游戏使用第一种车（此处第一种指该场游戏中，可用的两种车中的第一种车），$i'$ 表示第 $i$ 场游戏使用第二种车。

我们接下来根据已有信息建立图论模型求解。

1. 若第 $i$ 场游戏本来就不能用 $h_i$ 型车，则这条信息无用，不执行任何操作。
2. 否则，若第 $j$ 场游戏不能用 $h_j$ 型车，则第 $i$ 场游戏也不能使用 $h_i$ 型车，否则无法满足该约束条件。
3. 否则，这意味着：
    - 若在第 $i$ 场游戏使用了 $h_i$ 型车，则第 $j$ 场游戏必须使用 $h_j$ 型车；
    - 若在第 $j$ 场游戏没有使用 $h_j$ 型车，则第 $i$ 场游戏也不能使用 $h_i$ 型车。

根据上面的讨论连边即可。

2-SAT 问题的解法可以参考 OI Wiki，这里不再展开。

现在考虑有 $x$ 地图的情况，一种暴力的想法是枚举 $x$ 地图不用哪一种车，将 $x$ 地图转化为一般地图求解。这样状态总数将达到 $3^d$，无法承受。

注意到上面的枚举过程中，我们没有必要枚举所有三种普通地图，只用枚举两种地图即可。因为任意两种普通地图的组合，都能完整覆盖三种可用的车。

从而总时间复杂度为 $O(2^d\times (n+m))$。

```cpp
// Problem: P3825 [NOI2017]游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3825
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cstring>
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
struct rule
{
 int i,j;
 char hi[5],hj[5];
}a[100005];
int dfn[100005],low[100005],vis[100005],col[100005],colc,cnt;
char S[50005],ns[50005];
const char ma[5][5]={"BC","AC","AB"};
int n,d,m;
vector<int> pos;
vector<int> e[100005];
stack<int> s;
void dfs(int u)
{
 dfn[u]=low[u]=++cnt;
 vis[u]=1,s.push(u);
 for(auto v:e[u])
 {
  if(!dfn[v])
  {
   dfs(v);
   low[u]=min(low[u],low[v]);
  }
  else if(vis[v])
   low[u]=min(low[u],dfn[v]);
 }
 if(dfn[u]==low[u])
 {
  colc++;
  while(!s.empty())
  {
   int x=s.top();
   s.pop();
   col[x]=colc,vis[x]=0;
   if(x==u)break;
  }
 }
}
int main()
{
 cin>>n>>d;
 cin>>(S+1);
 cin>>m;
 for(int x=1;x<=m;x++)
  cin>>a[x].i>>a[x].hi>>a[x].j>>a[x].hj;
 memcpy(ns,S,sizeof(S));
 for(int i=1;i<=n;i++)
  if(S[i]=='x')pos.push_back(i);
 for(int s=0;s<(1<<d);s++)
 {
  for(int i=1;i<=2*n;i++)
   e[i].clear();
  memset(dfn,0,sizeof(dfn));
  memset(low,0,sizeof(low));
  cnt=colc=0;
  for(int i=0;i<d;i++)
   if(s&(1<<i))ns[pos[i]]='a';
   else ns[pos[i]]='b';
  for(int x=1;x<=m;x++)
  {
   int i=a[x].i,j=a[x].j;
   int mai=ns[i]-'a',maj=ns[j]-'a';
   int u1=i+n*(a[x].hi[0]!=ma[mai][0]),v1=j+n*(a[x].hj[0]!=ma[maj][0]);
   int u2=(u1>n?u1-n:u1+n),v2=(v1>n?v1-n:v1+n);
   if(a[x].hi[0]-'A'==mai)continue;
   if(a[x].hj[0]-'A'==maj)
    e[u1].push_back(u2);//同一游戏内的两个点连边，表示该点不能被纳入到合法解当中
   else
   {
    e[u1].push_back(v1);
    e[v2].push_back(u2);
   }
  }
  for(int i=1;i<=2*n;i++)
   if(!dfn[i])dfs(i);
  bool flag=true;
  for(int i=1;i<=n;i++)
   if(col[i]==col[i+n])flag=false;
  if(flag)
  {
   for(int i=1;i<=n;i++)
    if(col[i]<col[i+n])
    {
     if(ns[i]=='a')cout<<'B';
     else cout<<'A';
    }
    else
    {
     if(ns[i]!='c')cout<<'C';
     else cout<<'B';
    }
   return 0;
  }
 }
 cout<<-1<<endl;
 return 0;
}
```

---

## 作者：Kelin (赞：12)

### 题意

有三种数,每个位置只能填一种数,有$d\in[0,8]$个位置有三种选择,其他位置只有两种选择

给你一些限制,表示第$i$个位置选了某种数,那么第$j$个位置就只能选规定的数

输出一组合法的选数方案,无解输出$-1$

---

### 题解

##### ①考虑$d=0$,那么就是每个位置都只有两种选择和一堆限制

那么这就是一道$2-sat$的裸题了

假设限制的四元组是$(i,h_i,j,h_j)$,令$u=[$第$i$个位置填$h_i$的编号$]$,$v=[$第$j$个位置填$h_j$的编号$]$,那么连边$(u,v),(v',u')$

注意如果$v$是不存在的(也就是第$j$个位置不能填$h_j$)那么$u$就不能选,那么就连边$(u,u')$

然后如果$u$是存在的话,这个限制就废了(可以稍微快一点$?$)

输出方案就是~~建反图然后拓扑排序然后染色~~

其实可以直接$for$一遍就好了,设$belong_i$表示$i$所属的强连通分量

按照原来的做法,如果反图$belong_i$的拓扑序小于$belong_{i'}$那么这个位置就选能选的第一种数,否则就是第二种

考虑到$tarjan$求出来的强连通分量就是按照反图的逆序给出的

原来的方法等价一下就是如果$belong_i<belong_{i'}$就选这个位置能选的第一种,否则就是第二种

##### ②考虑$d\gt0$怎么做,就是有些位置是$3-sat?$

显然不可能是$3-sat$,毕竟$NPC$

一个简单的想法就是$3^d$的$dfs$枚举这个位置填什么

而且这样也没法优化了,考虑正难则反,枚举这一位不填什么

比如:

$1.$假设这个位置不能选$A$数,那么就只能选$B,C$数;

$2.$假设这个位置不能选$B$数,那么就只能选$A,C$数;

$3.$假设这个位置不能选$C$数,那么就只能选$A,B$数;

我们可以发现第$3$种情况已经在前两种里面讨论过了,这样我们就能做到$2^d$了

总时间复杂度$O(2^d(n+m))$

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,M=2e5;
typedef int arr[N];
struct eg{int nx,to;}e[M];
struct da{int x,y;}a[N],b[N];
int n,m,ce,dft,Cnt,Top,pos[N][3];arr p,f,nt,fi,bl,dfn,low,vis,S,Ch;
void tarjan(int u){
    dfn[u]=low[u]=++dft;vis[u]=1,S[++Top]=u;
    go(u)if(!dfn[v])tarjan(v),cmin(low[u],low[v]);
        else if(vis[v])cmin(low[u],dfn[v]);
    if(dfn[u]==low[u]){
        ++Cnt;int v;
        do{vis[v=S[Top--]]=0,bl[v]=Cnt;}while(Top&&v^u);
    }
}
inline void add(int u,int v){e[++ce]={fi[u],v},fi[u]=ce;}
#define clr(x) memset(x,0,sizeof x)
inline void sol(){
    ce=Cnt=dft=0;clr(fi),clr(dfn),clr(low);
    fp(i,1,n)nt[nt[i]=i+n]=i;
    fp(i,1,m)if(p[a[i].x]^a[i].y){
    	int u=pos[a[i].x][a[i].y],v=pos[b[i].x][b[i].y];
		if(p[b[i].x]==b[i].y)add(u,nt[u]);
    	else add(u,v),add(nt[v],nt[u]);
    }
    fp(i,1,2*n)if(!dfn[i])tarjan(i);
    fp(i,1,n)if(bl[i]==bl[i+n])return;
        else nt[bl[i+n]]=bl[i],nt[bl[i]]=bl[i+n];
    fp(i,1,n)putchar('A'+Ch[i+(bl[i]<bl[i+n]?0:n)]);
    exit(0);
}
void dfs(int d){
    if(d==f[0]+1)return sol();int i=f[d];
    p[i]=0,pos[i][Ch[i]=1]=i;dfs(d+1);pos[i][1]=0;
    p[i]=1,pos[i][Ch[i]=0]=i;dfs(d+1);
}char s[N];
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%*d%s",&n,s+1);
    fp(i,1,n){
        p[i]=s[i]-'a';
        if(p[i]>2)f[++f[0]]=i,pos[i][2]=i+n,Ch[i+n]=2;
        else{
            if(p[i]==0)pos[i][1]=i,pos[i][2]=i+n,Ch[i]=1,Ch[i+n]=2;
            else if(p[i]==1)pos[i][0]=i,pos[i][2]=i+n,Ch[i]=0,Ch[i+n]=2;
            else pos[i][0]=i,pos[i][1]=i+n,Ch[i]=0,Ch[i+n]=1;
        }
    }scanf("%d",&m);int k=0;char c1,c2;
    fp(i,1,m){
        scanf("%d %c%d %c",&a[i].x,&c1,&b[i].x,&c2);
        if(s[a[i].x]==c1)continue;
        a[++k]={a[i].x,c1-'A'},b[k]={b[k].x,c2-'A'};
    }m=k;dfs(1);puts("-1");
return 0;
}
```
如果你不想写$spj$的话戳[这里](https://loj.ac/problem/2305/testdata/download/spj_cpp.cpp)$(by\ $[$loj$](https://loj.ac/problem/2305/testdata)$)$

---

## 作者：laoliu12345 (赞：9)

# 洛谷 P3825
[题目传送门](https://www.luogu.com.cn/problem/P3825)
## 解法说明
### 题目理解
本题有  $n$  个地图，每次要求选择一辆车跑，地图分四种即   a  ，  b  ，  c  ，  x  ，车分三种 A ， B ， C ， a 型地图不能放  A  ，  b  型地图不能放 B ， c 型地图不能放  C  ，  x 型地图能放任何车  ，  但是只有 $d$ 张 x 型地图。
### 题目思路
显而易见，对于任意的  a   ， b  ，  c  型地图，我们都能很容易的建立出推导关系，不看  x  型地图的话是一个很简单的  2-SAT  裸题。

但是...   x   地图并不能按照普通的建立方式建立，那该怎么办？？

观察数据   $k$   的范围，可以发现  x  图最多只有  $8$  张，那就简单了，**直接暴力枚举，一种情况是不选   A ，一种情况是不选   B  ， A  型车被包含在情况   1  中， B  型车被包含在情况  2  中， C  两种情况都有**。

通过上述操作，我们将 x 种地图转化为 a 种和 b 种图,
本题的时间复杂度为     $O(2^k⋅(M+N))$    ，并不会超时。

那就可以愉快的写代码了！！！


## 题目代码
```cpp
#include<iostream>
#include<cstring>
#define ch getchar
#define in getint
#define ts timestamp
#define ins in_stack
using namespace std;
const int N=100010,M=200010;
int n,d,m;
char s[N];
int h[N],e[M],ne[M],idx;//邻接表 
int dfn[N],low[N],timestamp;// tarjan 算法数组
int stk[N],top;//栈 
bool in_stack[N]; //记录是否在栈中
int id[N],cnt;//纪录每个点所在的强连通分量 
int pos[10];//记录 x 的位置
struct Op
{
	int x,y;
	char a,b;
}op[M];//记录条件
void add(int a,int b)
{
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int in(int x,char b,int t)//返回 x 选 b 时的编号，t 为 1 表示选 -b，t 为 0 表示选 b 
{
	char a=s[x]-'a';
	b-='A';
	if(((a+1)%3!=b)^t) return x+n;
	return x;
}
char ch(int x,int t)
{
	int y=s[x]-'a';
	return 'A'+(y+3+(t? -1 :1))%3;
}
void tarjan(int u)
{
	dfn[u]=low[u]=++ts;
	stk[++top]=u,ins[u]=true;
	for(int i=h[u];~i;i=ne[i])//枚举邻接点
	{
		int j=e[i];
		if(!dfn[j])
		{
			tarjan(j);
			low[u]=min(low[u],low[j]);
		}
		else if(ins[j])
		    low[u]=min(low[u],dfn[j]);
	}
	if(dfn[u]==low[u])
	{
		cnt++;//强连通分量编号
		int y;
		do{
			y=stk[top--];
			ins[y]=false;//出栈 
			id[y]=cnt;
		} while(y!=u);
	}
}
bool launch()
{
	memset(h,-1,sizeof h);
	memset(dfn,0,sizeof dfn);
	idx=ts=cnt=0;
	for(int i=0;i<m;i++)
	{
		int x=op[i].x-1,y=op[i].y-1;//下标改为从 0 开始 
		char a=op[i].a,b=op[i].b;
		if(s[x]!=a-'A'+'a')
		{
			//第 y 张图能取 b 时，即 x 选 a 时 y 必须选 b，得出推导公式 a -> b, -b -> a
			if(s[y]!=b-'A'+'a') add(in(x,a,0),in(y,b,0)),add(in(y,b,1),in(x,a,1));
			//第 y 张图不能取 b 时，即 x 选 a 时 y 无法选 b，则 x 不能选 a，得出推导公式 a -> -a
		    else add(in(x,a,0),in(x,a,1));
		}
	}
	for(int i=0;i<n*2;i++)
	    if(!dfn[i])
	        tarjan(i);
	for(int i=0;i<n;i++)
	    if(id[i]==id[i+n])
		    return false;
	for(int i=0;i<n;i++)
	    if(id[i]<id[i+n]) printf("%c",ch(i,0));
	    else printf("%c",ch(i,1));
	return true;   
}
int main()
{
	scanf("%d%d%s",&n,&d,s);
	for(int i=0,j=0;i<n;i++)
	    if(s[i]=='x')
	        pos[j++]=i;//记录 x 的位置 
	scanf("%d",&m);
	for(int i=0;i<m;i++) scanf("%d %c %d %c",&op[i].x,&op[i].a,&op[i].y,&op[i].b);
	for(int k=0;k<1<<d;k++)//枚举所有可能的 x 的情况 
	{
		for(int i=0;i<d;i++)
		    if(k>>i&1) s[pos[i]]='a';// 0 则转变成 a，1 则转变成 b 
		    else s[pos[i]]='b';
		if(launch()) return 0;//有解直接退出即可 
	}
	//无解 
	puts("-1");
	return 0;
}
```

---

## 作者：lhm_ (赞：7)

从题面中四元组$(i,h_i,j,h_j)$限制选择车子型号，不难想到这题要用$2-SAT$解决。

考虑转化为$2-SAT$模型，发现除地图$x$外，其他地图都只有两种车子型号可以参加，那么就把这两种型号转化为两种状态。

若$S_i=a$，则状态为$B$和$C$。

若$S_i=b$，则状态为$A$和$C$。

若$S_i=c$，则状态为$A$和$B$。

然后讨论四元组的情况，设$i$为输入的状态，$i^\prime$为另一个状态。

若在第$i$场，$h_i$不可用，则不进行连边。

若在第$i$场，$h_i$可用，在第$j$场，$h_j$不可用，则从$i$向$i^\prime$连边，表示不能选$i$。

若两个都可用，则从$i$向$j$连边，表示若选$i$，则一定选$j$，同时从$j^\prime$向$i^\prime$连边，这里表示若没有选$j$，则一定没有选$i$。

继续考虑如何处理地图$x$，发现其数量$d\leqslant8$，数据规模很小，那么我们就可以用$dfs$将其所有可能的情况枚举一遍，再检查是否合法。

我们只需考虑地图$x$等价于地图$a$和地图$b$两种情况，因为此时已经包括$A,B,C$三种车型了。

时间复杂度为$O(2^d(n+m))$。

实现细节还是蛮多的，不清楚的就看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 1000010
using namespace std;
template<typename T> inline void read(T &x)
{
	x=0;char c=getchar();bool flag=false;
	while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	if(flag)x=-x;
}
int n,d,m,x_cnt;
bool flag;
char s[maxn],a[5],b[5],c1[maxn],c2[maxn];
int pos[maxn];
struct node
{
    int x,y;
    char a,b;
}t[maxn];
struct edge
{
    int to,nxt;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to)
{
    e[++edge_cnt]=(edge){to,head[from]};
    head[from]=edge_cnt;
}
int dfn_cnt,co_cnt,top;
int dfn[maxn],low[maxn],co[maxn],st[maxn];
bool vis[maxn];
void tarjan(int x)
{
    dfn[x]=low[x]=++dfn_cnt;
    st[++top]=x;
    vis[x]=true;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(!dfn[y])
        {
            tarjan(y);;
            low[x]=min(low[x],low[y]);
        }
        else if(vis[y])
            low[x]=min(low[x],dfn[y]);
    }
    if(low[x]==dfn[x])
    {
        co_cnt++;
        int now;
        do
        {
            now=st[top--];
            vis[now]=false;
            co[now]=co_cnt;
        }while(now!=x);
    }
}
bool check()
{
    for(int i=1;i<=2*n;++i)
        if(!dfn[i])
            tarjan(i);
    for(int i=1;i<=n;++i)
        if(co[i]==co[i+n])
            return false;
    return true;
}
void clear()
{
    edge_cnt=dfn_cnt=co_cnt=top=0;
    memset(st,0,sizeof(st));
    memset(co,0,sizeof(co));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(vis,0,sizeof(vis));
    memset(head,0,sizeof(head));
}
void work()
{
    clear();
    for(int i=1;i<=m;++i)
    {
        int x=t[i].x,y=t[i].y;
        char a=t[i].a,b=t[i].b;
        if(s[x]==a) continue;
        if(s[y]==b)
        {
            add(x+(a==c2[x])*n,x+(a==c1[x])*n);
            continue;
        }
        add(x+(a==c2[x])*n,y+(b==c2[y])*n);
        add(y+(b==c1[y])*n,x+(a==c1[x])*n);
    }
    if(check())
	{
        flag=true;
        for(int i=1;i<=n;i++)
        {   
            if(co[i]<co[i+n]) printf("%c",c1[i]);
            else printf("%c",c2[i]);
        }
    }
}
void dfs(int x)
{
    if(flag) return;
    if(x==d+1)
    {
        work();
        return;
    }
    int now=pos[x];
    s[now]='A',c1[now]='B',c2[now]='C',dfs(x+1);
    s[now]='B',c1[now]='A',c2[now]='C',dfs(x+1);
}
int main()
{
	read(n),read(d);
    scanf("%s",s+1);
    for(int i=1;i<=n;++i)
    {
        s[i]+='A'-'a';
        if(s[i]=='A') c1[i]='B',c2[i]='C';
        if(s[i]=='B') c1[i]='A',c2[i]='C';
        if(s[i]=='C') c1[i]='A',c2[i]='B';
        if(s[i]=='X') pos[++x_cnt]=i;
    }
    read(m);
    for(int i=1;i<=m;++i)
    {
        read(t[i].x),scanf("%s",a),read(t[i].y),scanf("%s",b);
        t[i].a=a[0],t[i].b=b[0];
    }
    dfs(1);
    if(!flag) printf("-1");
	return 0;
}
```

---

## 作者：lgswdn_SA (赞：4)

[我的2-SAT](https://www.luogu.com.cn/blogAdmin/article/edit/213094)

> 有三种车A,B,C,有$n$个地图，每个地图用一个字符表示。若字符为```a```那么车A就不能在这个地图上开，若是```b```，那么车B就不能在这个地图上开，若是```c```，那么车C就不能在这个地图上开，若是```x```，那么三种车都可以在这个地图上开。（x的数量最多为8）  
有$m$个约束，用$(i,h_i,j,h_j)$表示，代表若第$i$个地图用车$h_i$，那么第$j$个地图必须用车$h_j$ ($h_i,h_j$为A或B或C)  
问有没有合法分配方案。若有，输出一组(有spj), 否则输出```-1```.


乍一看一个3-SAT问题  
不过当然不是  

有三个主要问题：  
1 地图用车限制  
2 约束条件  
3 地图为x  

#### 第一个问题：**地图用车限制**（不考虑x）

我们发现其实由于每个地图**只能有两种**选车方案，所以就是一个**2-SAT**问题Orz  
那么稍加记录即可（比如$(2i-1,2i)$或$(i,i+n)$等等），然后再判断这是哪两个地图  

比如对于字符为'b'的地图$i$，假设地图$i$的可选的两个选项为$2i-1$和$2i$，那么可以判断得出，代表车A的选项是$2i-1$,代表车C的选项是$2i$，或者说$2i-1$是车A，$2i$是车C  

#### 第二个问题：**约束条件**  

我们假设地图$i$的两个选项为$i_0$和$i_1$

分三种情况：  
不妨假设$h_i$是$i_0$代表的车，$h_j$是$j_0$代表的车

```if``` 第$i$张地图**没法选**$h_i$，那么就代表这个约束就是一句废话  

```else if``` 第$j$张地图**没法选**$h_j$，那么就代表第$i$张地图不能选$h_i$(否则$j$就必须选$h_j$)，连接有向边$i_0\Rightarrow i_1$  

```else``` **同模板的思想**，连$i_0\Rightarrow j_0, i_1\Rightarrow j_1$ 

#### 第三个问题：**地图为x**

地图为x代表可以是AB或AC或BC  

由于x的数量非常小，于是可以dfs爆搜枚举x支持哪两辆车，一旦方案可行，就return  

发现x选A或C已经再x选AB和BC中包含了，那么便不用枚举AC这种方案

#### 总复杂度：$2^d(n+m)$ （d为x的个数）

代码：强行压行后也要68行而且细节贼多  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100009,M=100009;
struct edge{int to,nxt;}e[M*4]; int hd[N],tot,nmw;
void add(int u,int v){
	//cout<<"add("<<u<<" "<<v<<")\n";
	nmw++;
	e[++tot]=(edge){v,hd[u]}; hd[u]=tot;
} 
int tick,dfn[N],low[N],cnt,scc[N]; stack<int>st; bool in[N];
void tarjan(int u){
	dfn[u]=low[u]=++tick; st.push(u); in[u]=1;
	for(int i=hd[u],v;i;i=e[i].nxt)
		if(dfn[v=e[i].to]&&in[v]) low[u]=min(low[u],low[v]);
		else if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
	if(low[u]==dfn[u]){
		scc[u]=++cnt;
		while(st.top()!=u) in[st.top()]=0,scc[st.top()]=cnt,st.pop();
		in[u]=0,st.pop();
	}
}
int n,d,m,ni[M],nj[M],xt,cx[N]; char c[N],hi[M],hj[M]; bool wx[N];
int getn(int u,char hu){
	if(hu=='A'||(hu=='B'&&c[u]=='a')) return 2*u-1;
	if(hu=='C'||(hu=='B'&&c[u]=='c')) return 2*u;
}
char getc(int u,int nu){
	if(nu==2*u-1) return c[u]=='a'?'B':'A';
	else return c[u]=='c'?'B':'C';
}
int rev(int p){return p%2?p+1:p-1;};
void init(){
	memset(hd,0,sizeof(hd)),memset(e,0,sizeof(e));
	memset(dfn,0,sizeof(dfn)),tot=0;
	memset(in,0,sizeof(in)),memset(scc,0,sizeof(scc));
	tick=0,cnt=0,nmw=0;
}
bool solve(){
	init(); bool ret=1;
	for(int i=1;i<=m;i++){
		if(hi[i]!=c[ni[i]]-'a'+'A'&&hj[i]==c[nj[i]]-'a'+'A'){
			if(getn(ni[i],hi[i])==2*ni[i]) add(2*ni[i],2*ni[i]-1);
			else add(2*ni[i]-1,2*ni[i]);
		}
		else if(hi[i]!=c[ni[i]]-'a'+'A')
			add(getn(ni[i],hi[i]),getn(nj[i],hj[i])),
			add(rev(getn(nj[i],hj[i])),rev(getn(ni[i],hi[i])));
	}
	for(int i=1;i<=n*2;i++) if(!dfn[i]) tarjan(i);
	for(int i=1;i<=n;i++) if(scc[2*i-1]==scc[2*i]) ret=0;
	return ret;
}
bool flag=0;
void dfs(int i){
	if(i==d+1){if(solve()) flag=1;return;}
	c[cx[i]]='a',dfs(i+1); if(flag) return;
	c[cx[i]]='c',dfs(i+1);
}
int main(){
	scanf("%d%d%s%d",&n,&d,c+1,&m);
	for(int i=1;i<=m;i++) cin>>ni[i]>>hi[i]>>nj[i]>>hj[i];
	for(int i=1;i<=n;i++) if(c[i]=='x') wx[i]=1,cx[++xt]=i;
	dfs(1);
	if(flag)
		for(int i=1;i<=n;i++) putchar(getc(i,2*i-(scc[2*i-1]<scc[2*i])));
	else printf("%d",-1);
	return 0;
}
```

#### 一些Debug要素：  

1 TARJAN千万不能写错！  
2 对于2SAT问题，一个很好的debug就是打印加的边然后手动算问题出在哪里  
3 如果是细节问题（反正我没犯），从加边这里一点一点往里推

---

## 作者：_JF_ (赞：2)

[Link](https://www.luogu.com.cn/problem/P3825)

不禁让人加深了对 2-SAT 的感知度。

先考虑 $d=0$ 的情况，这时候发现每个赛道其实只有两种取值，所以可以考虑 2-SAT，具体的，把每个点能取的两种取值看成 $0$ 和 $1$，然后按照题目的限制连边即可。

然后发现 $d$ 的范围很小，不难想到暴力取 `x` 的点应该用什么赛车，时间复杂度是 $O(3^d \times (n+m))$ 的，难以通过。

不妨想到我们最开始 $d=0$ 的时候，我们定义了一个点是有两种取值的，比如说当前赛道是 `a`，实际上我们就已经把使用了赛车 `B` 和 `C` 都考虑进去了，所以我们只需要枚举两种赛道，这样就能覆盖到取三种赛车的情况。

这样的话时间复杂度就被优化到了 $O(2^d \times (n+m))$，可以通过本题。

细节不少，注意每次跑的时候清空要完全，以及在连边的时候的判断情况要想清楚。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =2e5+10;
vector<int> g[N];
char s[N],ans[N],ch[N],ch1[N];
int low[N],dfn[N],vis[N],F[N],tot,SCC;
int n,m,d,op[N],op1[N];
stack<int> sta;
bool f=false;
int change(char Ch,int dis){
	if(s[dis]=='a')	return ((Ch=='B')?dis:dis+n);
	else if(s[dis]=='b')	return ((Ch=='A')?dis:dis+n);
	else	return ((Ch=='A')?dis:dis+n);
}
void build(){
	for(int i=1;i<=m;i++){
		int u=change(ch[i],op[i]),v=change(ch1[i],op1[i]);
		if(ch[i]==s[op[i]]-'a'+'A')	continue;
		if(ch1[i]==s[op1[i]]-'a'+'A')	g[u].push_back(((u>n)?u-n:u+n));
		else 	g[u].push_back(v),g[((v>n)?v-n:v+n)].push_back((u>n)?u-n:u+n);
	}
}
void Clear(){
	for(int i=1;i<=2*n;i++)	g[i].clear(),low[i]=dfn[i]=0,F[i]=0,vis[i]=0;
	SCC=tot=0; 
}
void Tarjan(int u){
	dfn[u]=low[u]=++tot,vis[u]=1,sta.push(u);
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(!dfn[v])	Tarjan(v),low[u]=min(low[u],low[v]);
		else if(vis[v]==1)	low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		SCC++;
		while(!sta.empty()&&sta.top()!=u)	F[sta.top()]=SCC,vis[sta.top()]=2,sta.pop();
		F[sta.top()]=SCC,vis[sta.top()]=2,sta.pop();
	}
}
void Slove(){
	build();
	for(int i=1;i<=2*n;i++)	if(!dfn[i])	Tarjan(i);
	for(int i=1;i<=n;i++)	if(F[i]==F[i+n])	{Clear();return ;}
	for(int i=1;i<=n;i++){
		if(s[i]=='a')	ans[i]=((F[i]>F[i+n])?'C':'B');
		else if(s[i]=='b')	ans[i]=((F[i]>F[i+n])?'C':'A');
		else	ans[i]=((F[i]>F[i+n])?'B':'A');
	}
	Clear(),f=true;
}
void dfs(int dis){
	if(dis==n+1){Slove();return ;}
	if(s[dis]=='x')	s[dis]='a',dfs(dis+1),s[dis]='b',dfs(dis+1),s[dis]='x';
	else	dfs(dis+1);
}
int main(){
	cin>>n>>d,scanf("%s",s+1),cin>>m;
	for(int i=1;i<=m;i++)	cin>>op[i]>>ch[i]>>op1[i]>>ch1[i];
	dfs(1);	
//	Slove();
//	for(int i=1;i<=2*n;i++)	cout<<F[i]<<" ";
	if(f==false)	cout<<-1<<endl,exit(0);
	else	for(int i=1;i<=n;i++)	cout<<ans[i];
}
```

---

## 作者：crashed (赞：1)

# 题目

[点这里](https://www.luogu.com.cn/problem/P3825)看题目。  

# 分析

注意到，非 `x` 的赛道只有两种赛车可选，所以如果只有 `a,b,c` ，那么限制可以转化为 2-SAT 的边。下面我们用 $\neg h_i$ 表示在 $i$ 号位上不选择 $h_i$ 这辆车。我们可以如下转化：   

1. 如果 $(i,h_i,j,h_j)$ 中， $h_i$ 本身不可选，该限制自然作废。   
2. 如果 $(i,h_i,j,h_j)$ 中， $h_j$ 本身不可选，那么 $h_i$ 也不可选，即 $h_i\rightarrow \neg h_i$ 。
3. 如果 $(i,h_i,j,h_j)$ 中， 两种车各自都可以选，那么显然连接 $h_i\rightarrow h_j$ 和 $\neg h_j\rightarrow \neg h_i$ 。   

现在考虑处理 `x` 。虽然我们不难想到 $O(3^d\times m)$ 进行枚举，但是实际上我们只需要考虑 `x` 上选取 $A,B,C$ 的情况。而 `a` 已经包含了选 $B,C$ ， `b` 已经包含了选 $A,C$ 。如果我们将 `x` 均替换为 `a` 或 `b` ，那么我们已经考虑了所有的情况。因此只需要 $O(2^d\times m)$ 便可以。   


# 代码

```cpp
#include <cstdio>

#define Opp( x ) ( x <= N ? x + N : x - N )

const int MAXN = 1e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) putchar( '-' ), x = -x;
	if( 9 < x ) write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct Edge
{
	int to, nxt;
}Graph[MAXN * 10];

struct Ristriction
{
	int x, y; char hx, hy;
	
	void Read() 
	{ 
		scanf( "%d %c %d %c", &x, &hx, &y, &hy );
		hx += 'a' - 'A', hy += 'a' - 'A';
	}
}R[MAXN];

int stk[MAXN], top;

int id[MAXN];
char S[MAXN], fir[3] = { 'b', 'a', 'a' }, avail[3][2] = { { 'b', 'c' }, { 'a', 'c' }, { 'a', 'b' } };
int seq[10], xtot;

int head[MAXN], DFN[MAXN], LOW[MAXN], bel[MAXN];
int N, M, D, cnt, tot, ID;
bool in[MAXN];

void AddEdge( const int from, const int to )
{
	Graph[++ cnt].to = to, Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void Tarjan( const int u )
{
	DFN[u] = LOW[u] = ++ ID;
	in[stk[++ top] = u] = true;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ! DFN[v = Graph[i].to] ) Tarjan( v ), LOW[u] = MIN( LOW[u], LOW[v] );
		else if( in[v] ) LOW[u] = MIN( LOW[u], DFN[v] );
	if( DFN[u] == LOW[u] )
	{
		int v; tot ++;
		do in[v = stk[top --]] = false, bel[v] = tot;
		while( v ^ u );
	}
}

void Clean()
{
	ID = tot = top = cnt = 0;
	for( int i = 1 ; i <= N * 2 ; i ++ ) 
		head[i] = LOW[i] = DFN[i] = bel[i] = 0;
}

bool Chk()
{
	Clean();
	for( int i = 1 ; i <= N ; i ++ ) id[i] = S[i] - 'a';
	for( int i = 1 ; i <= M ; i ++ )
	{
		if( R[i].hx == S[R[i].x] ) continue;
		if( R[i].hy == S[R[i].y] ) 
		{
			int t = ( R[i].hx == fir[id[R[i].x]] ? R[i].x : Opp( R[i].x ) );
			AddEdge( t, Opp( t ) );
		}
		else 
		{
			int u = ( R[i].hx == fir[id[R[i].x]] ? R[i].x : Opp( R[i].x ) ),
				v = ( R[i].hy == fir[id[R[i].y]] ? R[i].y : Opp( R[i].y ) );
			AddEdge( u, v ), AddEdge( Opp( v ), Opp( u ) );
		}
	}
	for( int i = 1 ; i <= N * 2 ; i ++ ) if( ! DFN[i] ) Tarjan( i );
	for( int i = 1 ; i <= N ; i ++ ) if( bel[i] == bel[i + N] ) return false;
	return true;
}

int main()
{
	bool flg = false;
	read( N ), read( D );
	scanf( "%s", S + 1 ), read( M );
	for( int i = 1 ; i <= M ; i ++ ) R[i].Read();
	for( int i = 1 ; i <= N ; i ++ ) if( S[i] == 'x' ) seq[++ xtot] = i;
	for( int s = 0 ; s < ( 1 << xtot ) ; s ++ )
	{
		for( int i = 1 ; i <= xtot ; i ++ )
			S[seq[i]] = 'a' + ( s >> ( i - 1 ) & 1 );
		if( flg = Chk() ) break;
	}
	if( ! flg ) { puts( "-1" ); return 0; }
	for( int i = 1 ; i <= N ; i ++ )
		putchar( avail[id[i]][bel[i + N] < bel[i]] - 'a' + 'A' );
	putchar( '\n' );
	return 0;
}
```



---

## 作者：TTpandaS (赞：1)

对于不是 $x$ 的点，每个点只有两种取值，可以 2-SAT 解决。

对于是 $x$ 的点，由于数量只有 $8$ 个，所以直接枚举每个点不取 A 或不取 B，这样可以保证这个点可能取到 A，B，C 三种取值。

时间复杂度 $O(2^d(n+m))$。

---

## 作者：hl666 (赞：1)

这道题看上去**NPC**啊，超级不可做的样子。

我们先分析一下简单的情形：**没有$x$地图**

此时每个地图由于限制掉一种汽车，那么显然只会有两种选择。

再考虑到限制的情况，那么大致做法就很显然了——**2-SAT**

首先是拆点，对于每张地图$i$拆成$2i-1$与$2i$表示这张地图选择**能用的车**的第一辆还是第二辆。

比如如果$s_i=b$，那么$2i-1$表示选择$A$车，$2i$表示选择$B$车。

现在开始考虑选择的限制，对于每一个限制$(u,x,v,y)$，我们分情况讨论：

- 当$s_u=x$，说明这个限制没有意义，直接无视即可。
- 当$s_u\not=x$且$s_v=y$时，说明这时$u$是绝对不能选$x$对应的点的。为了在建图中体现出来我们直接从$x$对应的点向另一个点连边即可。
- 当$s_u\not=x$且$s_v\not= y$时，显然讲$x$对应的点向$y$对应的点连边。但是不要忘了2-SAT建图的**对称性**，我们还要从$y$对应的点的**反点**向$x$对应的点的**反点**连边。这样的意义也十分明确了吧，因为每个地图都**必须做出选择**，选择$y$对应的点的反点就使得$u$没有其他选择了。

然后就是用**Tarjan**跑**SCC**的过程了，这里不再赘述。值得一提的是Tarjan的标号顺序是按照**拓扑序的逆序**（因为是DFS）跑出来的，所以可以直接用标号来输出方案。

那么接下来就是考虑万恶的$x$地图了

我们发现这样并没有什么好的建图方法，然后翻到下面一看数据范围**$d\le8$**

然后一种特别naive的想法就是$3^d$枚举每个$x$地图是什么类型。然后再乘上Tarjan的复杂度直接爆炸。

我们想一下我们枚举的本质：

- 如果对于一个$x$地图取$a$即意味这只能用车$B,C$
- 如果对于一个$x$地图取$b$即意味这只能用车$A,C$
- 如果对于一个$x$地图取$c$即意味这只能用车$A,B$

然后我们惊奇地发现第三种情况已经被前两种情况包含掉了，所以复杂度变为$2^d(n+m)$

如果对于爆搜会被无解的数据卡满的同志们可以直接**随机**跑，实测这样也可以过。

不过实践的时候**细节巨多**，还是挺烦人的。

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<cstdlib>
#include<cstring>
#define RI register int
#define Ms(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=50005;
struct ques
{
    int x,y; char p1,p2;
}q[N<<1]; int n,m,d,tot,c[N],ukn[10],pt; char ch;
inline int T(char ch)
{
    if (ch>='a'&&ch<='c') return ch-'a'+1;
    else return ch-'A'+1;
}
inline int Id(int x,int y)
{
    switch (x)
    {
        case 1:return y!=3?1:0;break;
        case 2:return y!=3?1:0;break;
        case 3:return y!=2?1:0;break;
    }
}
inline char C(int x,int y)
{
    switch (x)
    {
        case 1:return y!=2?'B':'C';break;
        case 2:return y!=2?'A':'C';break;
        case 3:return y!=2?'A':'B';break;
    }
}
class FileInputOutput
{
    private:
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define S 1<<21
        char Fin[S],Fout[S],*A,*B; int Ftop;
    public:
        FileInputOutput() { Ftop=0; A=B=Fin; }
        inline void gc(char &ch)
        {
            while (!isalpha(ch=tc()));
        }
        inline void pc(char ch) 
        { 
            Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch);
        }
        inline void read(int &x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef S
        #undef tc
}F;
class Two_SAT_Solver
{
    private:
        #define add(x,y) e[++cnt]=(edge){y,head[x]},head[x]=cnt
        struct edge
        {
            int to,next;
        }e[N<<2]; int head[N<<1],cnt,dfn[N<<1],low[N<<1],scc,col[N<<1],stack[N<<1],top,tot; bool vis[N];
        inline int min(int a,int b)
        {
        	return a<b?a:b;
        }
        #define to e[i].to
        inline void Tarjan(int now)
        {
        	dfn[now]=low[now]=++tot; stack[++top]=now; vis[now]=1;
        	for (RI i=head[now];i;i=e[i].next)
        	if (!dfn[to]) Tarjan(to),low[now]=min(low[now],low[to]);
        	else if (vis[to]) low[now]=min(low[now],dfn[to]);
        	if (low[now]==dfn[now])
        	{
        		col[now]=++scc; vis[now]=0; while (stack[top]!=now)
        		col[stack[top]]=scc,vis[stack[top--]]=0; --top;
        	}
        }
        #undef to
    public:
        inline void build(void)
        {
            for (RI i=1;i<=m;++i)
            {
                int x=q[i].x,y=q[i].y,p1=T(q[i].p1),p2=T(q[i].p2);
                if (c[x]==p1) continue; int numx=x<<1,numy=y<<1;
                if (c[y]==p2) add(numx-Id(c[x],p1),numx-(Id(c[x],p1)^1)); else 
                add(numx-Id(c[x],p1),numy-Id(c[y],p2)),add(numy-(Id(c[y],p2)^1),numx-(Id(c[x],p1)^1));
            }
        }
        inline void check(void)
        {
            RI i; int lim=n<<1; for (i=1;i<=lim;++i) if (!dfn[i]) Tarjan(i);
            for (i=1;i<=n;++i) if (col[(i<<1)-1]==col[i<<1]) return;
            for (i=1;i<=n;++i) if (col[(i<<1)-1]<col[i<<1]) F.pc(C(c[i],1)); else F.pc(C(c[i],2));
            F.Fend(); exit(0);
        }
        inline void clear(void)
        {
            cnt=tot=scc=0; Ms(head,0); Ms(dfn,0);
        }
}S;
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i,j; for (F.read(n),F.read(d),i=1;i<=n;++i) 
    {
        F.gc(ch); if (ch!='x') c[i]=T(ch); else ukn[++pt]=i;
    }
    for (F.read(m),i=1;i<=m;++i) F.read(q[i].x),F.gc(q[i].p1),F.read(q[i].y),F.gc(q[i].p2);
    for (tot=(1<<d)-1,i=0;i<=tot;++i)
    {
        for (j=1;j<=d;++j) c[ukn[j]]=((i>>j-1)&1)+1;
        S.build(); S.check(); S.clear();
    }
    return F.pc('-'),F.pc('1'),F.Fend(),0;
}
```

---

## 作者：Jiangkp (赞：0)

2-sat问题解法：

为每个点建立true、false两个节点，方便起见称为互斥节点。根据约束条件连代表推导关系的有向边。

tarjan缩点，若有一对互斥节点在同一强连通分量中则无解

将得到的森林中的每条边反向，按照dfs序进行如下操作：

    若当前节点未被染色，染成红色，然后将所有互斥点所在子树染成蓝色。

    否则什么都不做。

最终所有红色节点构成解集。

**本题需要先枚举‘x’节点，注意到最多只有8个，先假定为‘a’，再假定为‘b’**

btw：3-sat问题是NPC问题

---


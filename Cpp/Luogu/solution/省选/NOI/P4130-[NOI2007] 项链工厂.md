# [NOI2007] 项链工厂

## 题目背景

T 公司是一家专门生产彩色珠子项链的公司，其生产的项链设计新颖、款式多样、价格适中，广受青年人的喜爱。

最近 T 公司打算推出一款项链自助生产系统，使用该系统顾客可以自行设计心目中的美丽项链。该项链自助生产系统包括硬件系统与软件系统，软件系统与用户进行交互并控制硬件系统，硬件系统接受软件系统的命令生产指定的项链。该系统的硬件系统已经完成，而软件系统尚未开发，T 公司的人找到了正在参加全国信息学竞赛的你，你能帮助 T 公司编写一个软件模拟系统吗？

## 题目描述

一条项链包含 $N$ 个珠子，每个珠子的颜色是 $1,2,…,c$ 中的一种。项链被固定在一个平板上，平板的某个位置被标记位置 $1$ ，按顺时针方向其他位置被记为 $2,3,…,N$。

 ![](https://cdn.luogu.com.cn/upload/pic/13560.png) 

你将要编写的软件系统应支持如下命令：

 ![](https://cdn.luogu.com.cn/upload/pic/13561.png) 

![](https://cdn.luogu.com.cn/upload/pic/13562.png)

## 说明/提示

【数据规模和约定】

对于 60% 的数据，$N \le 1000$，$Q \le 1000$；

对于 100% 的数据，$N \le 500000$，$Q \le 500000$，$c \le 1000$。

关于旋转和翻转


注意旋转命令旋转“珠子”但不改变“位置”的编号，而反转命令始终以位置 1 为对称轴。例如当 $N=10$ 时，项链上的位置编号如图 1：


但注意此时项链上的位置编号仍然如图 1 所示，于是翻转的对称轴不变。因而再执行一次“F”命令时，项链的颜色如图 4 所示。

 ![](https://cdn.luogu.com.cn/upload/pic/13244.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/13245.png) 

关于 CountSegment 命令


CS 命令表示查询一个“线段”中有多少个“部分”。尤其注意当查询的长度等于 $N$ 时，我们仍然将查询部分作为“线段”理解。


例如在图 4 所示的情况中，执行“CS 1 10”命令，查询从位置 1 开始到位置 10 结束的这个长度为 10 的线段中有多少个“部分”，于是得到返回值 3。与之形成对照的是，若执行“C”命令，返回值则为 2。

## 样例 #1

### 输入

```
5 3
1 2 3 2 1
4
C
R 2
P 5 5 2
CS 4 1```

### 输出

```
4
1```

# 题解

## 作者：Jμdge (赞：11)

我去，这题居然没人写ODT？ 虽说ODT跑的确实慢...（最后一个点卡时过，960ms+，所以可能要卡点常吧）


于是贡献一发ODT。

本来想了很久的标记处理（就是顺时针转以及翻转）

后来想不出来，本来想弃坑跳线段树的，然后想了想借(co)鉴(py)一下网上的标记处理不就行了？线段树操作用珂朵莉带一带，秒解。然后又肝了很久珂朵莉。

最后还是肝出来了，就是两个小细节注意一下就好了。其他地方没什么亮点，都是珂朵莉基操。

~~标记处理以及修改的边界维护全是抄的QvQ~~


```
//by Judge
#include<set>
#include<cstdio>
#include<iostream>
#define IT set<node>::iterator
using namespace std;
const int M=2e5+5;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline int cread(){ char c=getchar(); static int x;
	while(!isupper(c)) c=getchar();
	switch(c){
		case 'R': x=1; break;
		case 'F': x=2; break;
		case 'S': x=3; break;
		case 'P': x=4; break;
		case 'C': x=5; break;
	} c=getchar(); if(isupper(c)) x=6; return x;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
}
inline void cmax(int& a,int b) { if(a<b) a=b; }
struct node { int l,r; mutable int v; //都是基操
	node(int l,int r=-1,int v=0):l(l),r(r),v(v){} node() {}
	bool operator < (const node& b) const { return l<b.l; }
}; set<node> s; IT it,lit,rit; int n,m,mov,rev;
inline IT split(int pos) { //都是基操
	it=s.lower_bound(node(pos));
	if(it!=s.end()&&it->l==pos) return it;
	--it; int l=it->l,r=it->r,v=it->v;
	s.erase(it),s.insert(node(l,pos-1,v));
	return s.insert(node(pos,r,v)).first;
}
inline void update(int l,int r,int v) { //都是基操
	rit=split(r+1),lit=split(l);
	s.erase(lit,rit),s.insert(node(l,r,v));
}
inline int query(int l,int r) { //人类的本质竟然是____
	int res=0,las=0;
	rit=split(r+1),lit=split(l);
	for(; lit!=rit; las=lit->v,++lit)
		res+=lit->v!=las;
	return res;
}
inline int col(int x) { //这里直接split
	return it=split(x),it->v;
}
inline int chg(int x) { //借(chao)来的
	if(rev) x=n-x+2;
	x-=mov;
	for(; x>n; x-=n);
	for(; x<1; x+=n);
	return x;
}
int main() {
	n=read(),m=read();
	for(int i=1,x; i<=n; ++i)
		x=read(),s.insert(node(i,i,x));
	int op,l,r,k,a,b,ans;
	for(int i=1,m=read(); i<=m; ++i) {
		op=cread();
		if(op==1) {
			k=read();
			mov+=(rev)?(-k):k;
			for(; mov>n; mov-=n);
			for(; mov<0; mov+=n);
		} else if(op==2) rev^=1;
		else if(op==3) {
			l=read(),r=read();
			l=chg(l),r=chg(r);
			a=col(l),b=col(r);
			update(l,l,b);
			update(r,r,a);
		} else if(op==4) {
			l=read(),r=read(),k=read();
			l=chg(l),r=chg(r);
			if(rev) swap(l,r);
			if(l<=r) update(l,r,k);
			else update(l,n,k),update(1,r,k);
		} else if(op==5) {
			ans=query(1,n);
			if(ans>1) ans-=col(1)==col(n); //这里要特判啊
			print(ans);
		} else if(op==6) {
			l=read(),r=read();
			l=chg(l),r=chg(r);
			if(rev) swap(l,r);
			if(l<=r) ans=query(l,r);
			else {
				ans=query(l,n)+query(1,r);
				if(ans>1) ans-=col(1)==col(n); //这里也是
			}
			print(ans);
		}
	} return Ot(),0;
}
```

---

## 作者：djh123 (赞：9)

这道题竟然没有平衡树的题解！

考虑用Splay维护颜色序列。

维护左右端点颜色，当前节点颜色，当前区间的答案。

对于Rotate操作，就是把最后k个搬到最前面。

对于Flip操作，对[2,n]进行区间翻转，注意维护翻转后左右两端点颜色变化。

对于Swap操作，交换两个节点的颜色，把这两个节点Splay到根，更新祖先节点信息。

对于Paint操作，直接提取区间打标记，要注意区间可能分成[1,j],[i,n]两段。

对于Count操作，提取区间判是否首尾颜色相同。

对于CountSegment操作，提取区间，若分成两段考虑连接处颜色是否相同。

注意Splay哨兵节点。

下面是愉快的上代码时间

~~Splay超慢，细节超多，码量超大~~

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 5e5 + 50;

char opt[10];

int col[N];
int n, m, k, i, j;
int rt, tot;
struct node { int son[2], tag, fa, lc, rc, val, col, siz, cov; }t[N];

void rev(int x) {
	swap(t[x].son[0], t[x].son[1]);
	swap(t[x].lc, t[x].rc);
	t[x].tag ^= 1;
}

void cover(int x, int color) {
	t[x].col = t[x].lc = t[x].rc = color;
	t[x].val = 1; t[x].cov = color;
}

void pushdown(int x) {
	if(!x) return ;
	if(t[x].tag) rev(t[x].son[0]), rev(t[x].son[1]), t[x].tag = 0;
	if(t[x].cov != -0x3f3f3f3f) cover(t[x].son[0], t[x].cov), cover(t[x].son[1], t[x].cov), t[x].cov = -0x3f3f3f3f;
}

void updata(int x) {
	t[0].lc = t[0].rc = -2;
	int ls = t[x].son[0], rs = t[x].son[1];
	t[x].val = 1;
	t[x].lc = ls ? t[ls].lc : t[x].col;
	t[x].rc = rs ? t[rs].rc : t[x].col;
	t[x].siz = t[ls].siz + t[rs].siz + 1;
	if(ls) t[x].val += t[ls].val;
	if(rs) t[x].val += t[rs].val;
	t[x].val -= ((t[ls].rc == t[x].col) + (t[rs].lc == t[x].col));
	
}

int build(int l, int r, int f) {
	if(l > r) return 0;
	if(l == r) {
		int x = ++ tot;
		t[x].lc = t[x].rc = t[x].col = col[l]; t[x].fa = f;
		t[x].cov = -0x3f3f3f3f;
		t[x].val = 1, t[x].siz = 1; return x;
	}	
	int mid = (l + r) >> 1, x = ++ tot;
	t[x].col = col[mid], t[x].fa = f, t[x].cov = -0x3f3f3f3f;
	t[x].son[0] = build(l, mid - 1, x);
	t[x].son[1] = build(mid + 1, r, x);
	updata(x);
	return x;
}

void rotate(int x) {
	int y = t[x].fa, z = t[y].fa, tmp = (t[y].son[1] == x);
	t[z].son[t[z].son[1] == y] = x, t[x].fa = z;
	t[y].son[tmp] = t[x].son[tmp ^ 1], t[t[y].son[tmp]].fa = y;
	t[x].son[tmp ^ 1] = y, t[y].fa = x;
	updata(y), updata(x);
}

void splay(int x, int to) {
	while(t[x].fa != to) {
		int y = t[x].fa, z = t[y].fa;
		if(z != to) rotate(((t[y].son[0] == x) ^ (t[z].son[0] == y)) ? x : y);
		rotate(x);
	}
	if(!to) rt = x;
}

int find(int k) {
	int x = rt;
	while(1) {
		pushdown(x);
		if(t[t[x].son[0]].siz + 1 < k) {
			k -= (t[t[x].son[0]].siz + 1);
			x = t[x].son[1];
		}
		else if(t[t[x].son[0]].siz < k) return x;
		else x = t[x].son[0];
	}
}

void Rotate(int k) {
	int num = n - k + 1;
	int L = find(num), R = find(n + 2);
	splay(L, 0), splay(R, L);
	int x = t[R].son[0];
	t[x].fa = 0, t[R].son[0] = 0;
	updata(R), updata(L);
	L = find(1), R = find(2);
	splay(L, 0), splay(R, L);
	t[R].son[0] = x, t[x].fa = R;
	updata(R), updata(L);
}

void Flip() {
	int L = find(2), R = find(n + 2);
	splay(L, 0), splay(R, L);
	rev(t[R].son[0]);
	updata(R), updata(L);
}

void Swap(int l, int r) {
	int L = find(l), R = find(r);
	swap(t[L].col, t[R].col);
	splay(L, 0), splay(R, 0);
}

void Paint(int l, int r, int color) {
	int L = find(l - 1), R = find(r + 1);
	splay(L, 0), splay(R, L);
	cover(t[R].son[0], color);
	updata(R), updata(L);
}

int CountSegment(int l, int r) {
	int L = find(l - 1), R = find(r + 1);
	splay(L, 0), splay(R, L);
	return t[t[R].son[0]].val;
}

int Count() {
	int L = find(2), R = find(n + 1);
	int ans = t[rt].val - 2;
	if(ans > 1 && t[L].col == t[R].col) -- ans;
	return ans;
}

int main() {
	scanf("%d%*d", &n);
	col[1] = col[n + 2] = -1;
	for(int i = 2; i <= n + 1; ++ i) scanf("%d", &col[i]);
	rt = build(1, n + 2, 0);
	scanf("%d", &m);
	while(m --) {
		scanf("%s", opt);
		if(opt[0] == 'R') { scanf("%d", &k); Rotate(k); }
		else if(opt[0] == 'F') { Flip(); }
		else if(opt[0] == 'S') { scanf("%d%d", &i, &j); Swap(i + 1, j + 1); }
		else if(opt[0] == 'P') {
			scanf("%d%d%d", &i, &j, &k);
			if(j >= i) Paint(i + 1, j + 1, k);
			else Paint(2, j + 1, k), Paint(i + 1, n + 1, k);
		}
		else if(opt[0] == 'C' && opt[1] == 'S') {
			scanf("%d%d", &i, &j);
			if(j >= i) printf("%d\n", CountSegment(i + 1, j + 1));
			else {
				int ans = CountSegment(2, j + 1);
				ans += CountSegment(i + 1, n + 1);
				int L = find(2), R = find(n + 1);
				if(t[L].col == t[R].col) -- ans;
				printf("%d\n", ans);
			}
		}
		else printf("%d\n", Count());
	}
}


```

---

## 作者：_Diu_ (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P4130)

**upd：修改了题解中的部分内容。**

## 线段树

如果没有旋转对称操作，这题就是一道线段树水题了，因此先不考虑这两个操作。

因为我们只在意区间不同颜色段数，所以这段这段区间中间的颜色我们不需要知道，只需要知道左右两端颜色就可以合并了。

我们对于线段树，维护一下几个值：

$l,r$ 表示这段区间左右端点颜色，

$ans$ 表示这段区间已有的不同颜色段数，

$tag$ 懒标记，用于支持区间修改区间查询操作。

那么，很容易就能写出来这棵线段树。

```cpp
struct tree{
	int l,r,ans,tag;
}tr[N<<2];
void pushdown(int o){
	if(tr[o].tag==0)return;
	tr[ls].l=tr[ls].r=tr[ls].tag=
	tr[rs].l=tr[rs].r=tr[rs].tag=tr[o].tag;
	tr[ls].ans=tr[rs].ans=1;//若这个区间被整体赋值，那么这个区间就是一整个颜色段
	tr[o].tag=0;
}
void pushup(int o){
	tr[o].l=tr[ls].l,tr[o].r=tr[rs].r;
	tr[o].ans=tr[ls].ans+tr[rs].ans-(int)(tr[ls].r==tr[rs].l);//若中间两个点（左儿子右端点和有儿子左端点）颜色相同，那么合并时答案-1，因为这个颜色段被统计了两次
}
void build(int o,int l,int r){
	if(l==r)return (void)(tr[o].l=tr[o].r=a[l],tr[o].ans=1);
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(o);
}
void update(int o,int l,int r,int x,int y,int c){
	if(x<=l&&r<=y)return (void)(tr[o].l=tr[o].r=tr[o].tag=c,tr[o].ans=1);
	int mid=l+r>>1;
	pushdown(o);
	if(x<=mid)update(ls,l,mid,x,y,c);
	if(y>mid)update(rs,mid+1,r,x,y,c);
	pushup(o);
}
tree query(int o,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr[o];
	int mid=l+r>>1;
	pushdown(o);
	tree v1={0,0,0,0},v2={0,0,0,0};
	if(x<=mid)v1=query(ls,l,mid,x,y);
	if(y>mid)v2=query(rs,mid+1,r,x,y);
	return (tree){v1.l==0?v2.l:v1.l,v2.r==0?v1.r:v2.r,v1.ans+v2.ans-(v1.r==v2.l),0};
}
```

## 旋转

接下来问题就是转换了。

旋转操作还比较简单，直接整体加 $k$。

但对称操作稍微有~~亿点点~~麻烦。

建设当前我们旋转了 $k$ 个单位，

进行对称操作后，对于原来的位置 $i$，

旋转后是 $(i+k-1)\%n+1$，

对称后是 $(n-i-k)\%n+1$。

易发现，对称一次，$i,k$ 的系数就乘以了 $-1$,

因此，只要维护两个变量，一个表示是否对称过，一个表示旋转了多少个单位即可。

## code

注意刚才是从原来的位置转换到当前的位置，而我们需要实现的才做是从当前的位置转换到原来的位置。

还要注意一下，查询整个项链的时候注意两边的情况，但如果这个项链原本就是一个大的颜色段就不能 $-1$ 了。

具体见代码。

```cpp
#include<bits/stdc++.h>
#define ls (o<<1)
#define rs (o<<1|1)
using namespace std;
const int N=5e5+10;
int n,c,q,a[N],x,y;
struct tree{
	int l,r,ans,tag;
}tr[N<<2];
char ch[10];
//线段树模板，上面有了，这里不展开
int turn(int s){
	if(x)s=y-s+2;
	else s=s-y;
	s=(s%n+n)%n;
	if(s==0)s=n;
	return s;
}
int main(){
//	freopen("data.in","r",stdin);
	scanf("%d%d",&n,&c);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	build(1,1,n);
	scanf("%d",&q);
	for(int l,r,k;q--;){
		scanf("%s",ch);
		if(ch[0]=='R'){
			scanf("%d",&k);
			y=(y+k)%n;
		}else if(ch[0]=='F')x^=1,y=(n-y+n)%n;
		else if(ch[0]=='S'){
			scanf("%d%d",&l,&r);
			int nl=turn(l);
			int nr=turn(r);
			int cl=query(1,1,n,nl,nl).l;
			int cr=query(1,1,n,nr,nr).l;
			if(cl!=cr)update(1,1,n,nl,nl,cr),update(1,1,n,nr,nr,cl);
		}else if(ch[0]=='P'){
			scanf("%d%d%d",&l,&r,&k);
			int nl=turn(l);
			int nr=turn(r);
			if(x)swap(nl,nr);
			if(nl<=nr)update(1,1,n,nl,nr,k);
			else update(1,1,n,nl,n,k),update(1,1,n,1,nr,k);
		}else if(ch[1]=='S'){
			scanf("%d%d",&l,&r);
			int nl=turn(l);
			int nr=turn(r);
			if(x)swap(nl,nr);
			int ans=0;
			if(nl<=nr){
				ans=query(1,1,n,nl,nr).ans;
//				if(nl==1&&nr==n)ans-=(int)(tr[1].l==tr[1].r);
			}else{
				ans=query(1,1,n,nl,n).ans+query(1,1,n,1,nr).ans;
				ans-=(int)(tr[1].l==tr[1].r);
//				if(nr+1==nl)ans-=query(1,1,n,nr,nl).ans-1;
			}
			printf("%d\n",ans);
		}else printf("%d\n",max(tr[1].ans-(int)(tr[1].l==tr[1].r),1));
	}
}
```

总结：本题最主要的思想是用两个变量维护整个区间的偏移，避免大规模修改，像这样类似整体修改的题目就可以用类似的方法，做一个整体标记即可。

---

## 作者：不存在之人 (赞：3)

题解：这道题如果没有旋转和翻转的话，那这就是一道裸的线段树了，所以就可以想，如何将旋转和翻转过滤掉，使它真正成为一道线段树的题。 

因为无论如何旋转或是翻转，都不会影响这条项链的位置变化，所以我们可以考虑记录初始时位于位置1的珠子在经过变换后的位置，和这个项链是否经过翻转，这样就可以在每次修改或查询时，从现在的位置推算出这个位置的珠子原来的位置，之后在线段树上进行查询和修改即可。 

虽然很好想，但是做起来很麻烦，一大堆的小细节TvT
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 500010
#define ls rt<<1
#define rs rt<<1|1
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
using namespace std;
struct node
{
    int l,r,sum;
};
node f[N<<2];
int n,m,q,t;
bool k;
int lazy[N<<2];

void PushUp(node l,node r,node &rt)
{
    rt.l=l.l,rt.r=r.r,rt.sum=l.sum+r.sum;
    if(l.r==r.l)rt.sum--;
}

void PushDown(int rt)
{
    if(lazy[rt])
    {
        lazy[ls]=lazy[rs]=lazy[rt];
        f[ls].l=f[rs].l=f[ls].r=f[rs].r=lazy[rt];
        f[ls].sum=f[rs].sum=1;
        lazy[rt]=0;
    }
}

void build(int l,int r,int rt)
{
    if(l==r)
    {
        scanf("%d",&f[rt].l);
        f[rt].r=f[rt].l;
        f[rt].sum=1;
        return ;
    }
    int mid=(l+r)>>1;
    build(lson);
    build(rson);
    PushUp(f[ls],f[rs],f[rt]);
}

void updata(int l,int r,int rt,int L,int R,int c)
{
    if(l>=L&&r<=R)
    {
        f[rt].l=f[rt].r=c;
        f[rt].sum=1;
        lazy[rt]=c;
        return ;
    }
    PushDown(rt);
    int mid=(l+r)>>1;
    if(mid>=L)updata(lson,L,R,c);
    if(mid<R)updata(rson,L,R,c);
    PushUp(f[ls],f[rs],f[rt]);
}

node query(int l,int r,int rt,int L,int R)
{
    if(l>=L&&r<=R)return f[rt];
    PushDown(rt);
    int mid=(l+r)>>1;
    node a1,a2,a;
    if(mid>=L&&mid>=R)return query(lson,L,R);
    if(mid<R&&mid<L)return query(rson,L,R);
    if(mid>=L&&mid<R)
    {
        a1=query(lson,L,R);
        a2=query(rson,L,R);
        PushUp(a1,a2,a);
    }
    return a;
}

void doing(int &x,int &y)
{
    if(!k)
    {
        if(x>=t+1)x=x-t;
        else x=n-t+x;
        if(y>=t+1)y=y-t;
        else y=n-t+y;
    }else
    {
        if(x<=t+1)x=t-x+2;
        else x=t+n-x+2;
        if(y<=t+1)y=t-y+2;
        else y=t+n-y+2;
    }
}

int main()
{
    cin>>n>>m;
    build(1,n,1);
    cin>>q;
    for(int i=1;i<=q;i++)
    {
        int x,y,z;
        char s[10];
        scanf("%s",s);
        if(s[0]=='R')
        {
            scanf("%d",&x);
            t=(t+x)%n;
        }else if(s[0]=='F')
        {
            k=!k;
            t=(n-t)%n;
        }else if(s[0]=='S')
        {
            scanf("%d%d",&x,&y);
            doing(x,y);
            node a1=query(1,n,1,x,x);
            node a2=query(1,n,1,y,y);
            updata(1,n,1,x,x,a2.l);
            updata(1,n,1,y,y,a1.l);
        }else if(s[0]=='P')
        {
            scanf("%d%d%d",&x,&y,&z);
            doing(x,y);
            if(k)swap(x,y);
            if(x<=y)updata(1,n,1,x,y,z);
            else updata(1,n,1,x,n,z),updata(1,n,1,1,y,z);
        }else if(s[0]=='C'&&s[1]!='S')
        {
            int p=f[1].sum;
            if(f[1].l==f[1].r)p--;
            if(p)printf("%d\n",p);
            else puts("1");
        }else
        {
            scanf("%d%d",&x,&y);
            doing(x,y);
            node s1,s2,p;
            if(k)swap(x,y);
            if(x<=y)p=query(1,n,1,x,y);
            else{
                s1=query(1,n,1,x,n);
                s2=query(1,n,1,1,y);
                if(k)
                {
                    swap(s1.l,s1.r);
                    swap(s2.l,s2.r);
                    swap(s1,s2);
                }
                PushUp(s1,s2,p);
            }
            printf("%d\n",p.sum);
        }
    }
    return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

注意到一条链不同颜色段数是相邻颜色不同的个数加一。

一个环可以在此基础上修正一下。

那么开线段树维护即可。

为了方便，维护 $\rm pos$ 表示哪个珠子现在在 $1$，并且维护 $\rm dir = \pm 1$ 表示顺方向还是反方向。

代码二十分钟很容易写完。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=500000+10;
int n,c,q,col[MAXN],a[MAXN],pos,dir;
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
struct INFO {int fcol,lcol,cnt;}t[MAXN];
INFO operator +(INFO A,INFO B) {return {A.fcol,B.lcol,A.cnt+B.cnt+(A.lcol!=B.fcol)};}
void build(int k,int l,int r) {
	if(l==r) return t[k]={a[l],a[l],0},void();
	build(lson,l,mid),build(rson,mid+1,r),t[k]=t[lson]+t[rson];
}
void push_down(int k,int l,int r) {
	if(col[k]) col[lson]=col[rson]=col[k],t[lson]=t[rson]={col[k],col[k],0},col[k]=0;
	return ;	
}
void assign(int k,int l,int r,int x,int y,int c) {
	if(x<=l&&r<=y) return col[k]=c,t[k]={c,c,0},void();
	push_down(k,l,r);
	if(x<=mid) assign(lson,l,mid,x,y,c);
	if(y>mid) assign(rson,mid+1,r,x,y,c);
	return t[k]=t[lson]+t[rson],void();
}
int query(int k,int l,int r,int pos) {
	if(l==r) return t[k].fcol;
	push_down(k,l,r);
	if(pos<=mid) return query(lson,l,mid,pos);
	return query(rson,mid+1,r,pos);	
}
int kmod(int v) {
	v=(v%n+n)%n;
	if(v==0) return n;
	return v;	
}
INFO Query(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) return t[k];
	push_down(k,l,r);
	if(y<=mid) return Query(lson,l,mid,x,y);
	if(x>mid) return Query(rson,mid+1,r,x,y);
	return Query(lson,l,mid,x,y)+Query(rson,mid+1,r,x,y);
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>c; ffor(i,1,n) cin>>a[i];
	cin>>q;
	build(1,1,n),pos=1,dir=1;
	ffor(i,1,q) {
		string op; cin>>op;
		if(op=="R") {
			int k; cin>>k;
			if(dir==1) pos=kmod(pos-k);
			else pos=kmod(pos+k);	
		}
		else if(op=="F") dir=-dir;
		else if(op=="S") {
			int p1,p2; cin>>p1>>p2;
			p1=kmod(pos+dir*(p1-1)),p2=kmod(pos+dir*(p2-1));
			int col1=query(1,1,n,p1),col2=query(1,1,n,p2);
			assign(1,1,n,p1,p1,col2),assign(1,1,n,p2,p2,col1);
		}
		else if(op=="P") {
			int p1,p2,c;cin>>p1>>p2>>c;
			p1=kmod(pos+dir*(p1-1)),p2=kmod(pos+dir*(p2-1));
			if(dir==-1) swap(p1,p2);
			if(p1<=p2) assign(1,1,n,p1,p2,c);
			else assign(1,1,n,p1,n,c),assign(1,1,n,1,p2,c);
		}
		else if(op=="C") {
			int ans=t[1].cnt;
			if(t[1].fcol!=t[1].lcol) ans++;
			if(ans==0) ans=1;
			cout<<ans<<'\n';	
		}
		else {
			int p1,p2,c;cin>>p1>>p2;
			p1=kmod(pos+dir*(p1-1)),p2=kmod(pos+dir*(p2-1));
			if(dir==-1) swap(p1,p2);
			if(p1<=p2) cout<<Query(1,1,n,p1,p2).cnt+1<<'\n';
			else cout<<(Query(1,1,n,p1,n)+Query(1,1,n,1,p2)).cnt+1<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：2)

众所周知，2007 年珂朵莉还没有出生，所以我们可以用珂朵莉树。

每个操作，暴力去做颜色段就好了，先看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define iter set<node>::iterator
int n,m;
struct node{
	long long l,r;
	mutable long long val;
	node(long long _l,long long _r,long long _val){
//		if(_l>_r) swap(_l,_r);
		this->l=_l;
		this->r=_r;
		this->val=_val;
	}
};
bool operator < (node x,node y){
	return x.l<y.l;
}
set<node>odt;
iter split(int pos){
	if(pos>n) return odt.end();
	iter it=odt.lower_bound(node(pos,0,0));
	if(it!=odt.end() && it->l==pos) return it;
	it--;
	long long l=it->l,r=it->r,val=it->val;
	odt.erase(it);
	odt.insert(node(l,pos-1,val));
	return odt.insert(node(pos,r,val)).first;
}
inline void rorate(int k){
	iter e=split(n-k+1);
	set<node>s;
	for(iter it=odt.begin();it!=e;it++) s.insert(node(it->l+k,it->r+k,it->val));
	for(iter it=e;it!=odt.end();it++) s.insert(node((it->l+k-1)%n+1,(it->r+k-1)%n+1,it->val));//推的
	odt=s;
}
inline void flip(){
	iter b=split(2);
	set<node>s;
	s.insert(*odt.begin());
	int l=n;
	for(iter it=b;it!=odt.end();it++) s.insert(node(l-it->r+it->l,l,it->val)),l-=(it->r-it->l+1);
	odt=s;
}
inline void Swap(int x,int y){
	iter b1=split(x+1),b2=split(x),e1=split(y+1),e2=split(y);
	swap(b2->val,e2->val);
}
inline void Paint(int l,int r,int k){
	if(l<=r){
		iter e=split(r+1),b=split(l);
		odt.erase(b,e);
		odt.insert(node(l,r,k));
	}
	else{
		if(l==r+1){
			odt.clear();
			odt.insert(node(1,n,k));
		}
		else{
			iter b=split(l),e=split(r+1);
			odt.erase(b,odt.end());
			odt.insert(node(l,n,k));
			odt.erase(odt.begin(),e);
			odt.insert(node(1,r,k));
		}
	}
}
inline int Count(int l=1,int r=n){
	if(l<=r){
		iter e=split(r+1),b=split(l);
		int cnt=0,L=0,t=(odt.begin()->val==prev(odt.end())->val);
		for(iter it=b;it!=e;it++) if(it->val!=L) L=it->val,cnt++;
		if(cnt==1 || r!=n || l!=1) t=0;
		return cnt-t;
	}
	else{
		iter b=split(l),e=split(r+1);
		int cnt=0,L=0,t=(odt.begin()->val==prev(odt.end())->val);
		for(iter it=b;it!=odt.end();it++) if(it->val!=L) L=it->val,cnt++;
		L=0;
		for(iter it=odt.begin();it!=e;it++) if(it->val!=L) L=it->val,cnt++;
		cnt-=t;
		return cnt;
	}
}
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		odt.insert(node(i,i,x));
	}
//	odt.insert(node(n+1,n+1,0));
	int q;
	cin>>q;
	while(q--){
		string opt;
		cin>>opt;
		if(opt=="R"){
			int k;
			cin>>k;
			rorate(k);
		}
		if(opt=="F") flip();
		if(opt=="S"){
			int x,y;
			cin>>x>>y;
			Swap(x,y);
		}
		if(opt=="P"){
			int l,r,k;
			cin>>l>>r>>k;
			Paint(l,r,k);
		}
		if(opt=="C") cout<<Count()<<"\n";
		if(opt=="CS"){
			int l,r;
			cin>>l>>r;
			cout<<Count(l,r)<<"\n";
		}
//		for(iter it=odt.begin();it!=odt.end();it++) 
//cout<<it->l<<" "<<it->r<<" "<<it->val<<"\n";
//		for(int i=it->l;i<=it->r;i++) cout<<it->val<<" ";
//		cout<<"\n";
	}
	return 0;
}
```
没啥好讲的。

然后 90 pts。

又发现前两个操作耗时高。

一看 ODT 的题解。

哇，前两个操作可以直接维护偏移量与是否反转。

所以，直接维护两个信息。

每次计算一个坐标所对应在 ODT 上的坐标,就可以 AC。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define iter set<node>::iterator
int n,m,mov;
struct node{
	long long l,r;
	mutable long long val;
	inline node(long long _l,long long _r,long long _val){
//		if(_l>_r) swap(_l,_r);
		this->l=_l;
		this->r=_r;
		this->val=_val;
	}
};
inline bool operator < (node x,node y){
	return x.l<y.l;
}
set<node>odt;
inline iter split(int pos){
	if(pos>n) return odt.end();
	iter it=odt.lower_bound(node(pos,0,0));
	if(it!=odt.end() && it->l==pos) return it;
	it--;
	long long l=it->l,r=it->r,val=it->val;
	odt.erase(it);
	odt.insert(node(l,pos-1,val));
	return odt.insert(node(pos,r,val)).first;
}
inline void rorate(int k){
	iter e=split(n-k+1);
	set<node>s;
	for(iter it=odt.begin();it!=e;it++) s.insert(node(it->l+k,it->r+k,it->val));
	for(iter it=e;it!=odt.end();it++) s.insert(node((it->l+k-1)%n+1,(it->r+k-1)%n+1,it->val));
	odt=s;
}
inline void flip(){
	iter b=split(2);
	set<node>s;
	s.insert(*odt.begin());
	int l=n;
	for(iter it=b;it!=odt.end();it++) s.insert(node(l-it->r+it->l,l,it->val)),l-=(it->r-it->l+1);
	odt=s;
}
inline int get(int x){
	int t=split(x)->val;
	return t;
}
inline void Paint(int l,int r,int k){
	if(l<=r){
		iter e=split(r+1),b=split(l);
		odt.erase(b,e);
		odt.insert(node(l,r,k));
	}
	else{
		if(l==r+1){
			odt.clear();
			odt.insert(node(1,n,k));
		}
		else{
			iter b=split(l),e=split(r+1);
			odt.erase(b,odt.end());
			odt.insert(node(l,n,k));
			odt.erase(odt.begin(),e);
			odt.insert(node(1,r,k));
		}
	}
}
inline int Count(int l=1,int r=n){
	vector<node>v;
	if(l<=r){
		iter e=split(r+1),b=split(l);
		int cnt=0,L=0,Left=0,t=(odt.begin()->val==prev(odt.end())->val);
		for(iter it=b;it!=e;it++) if(it->val!=L) v.push_back(node(Left,it->l-1,L)),L=it->val,Left=it->l,cnt++;
		for(int i=1;i<v.size();i++) Paint(v[i].l,v[i].r,v[i].val);
		if(cnt==1 || r!=n || l!=1) t=0;
		return cnt-t;
	}
	else{
		iter b=split(l),e=split(r+1);
		int cnt=0,L=0,t=(odt.begin()->val==prev(odt.end())->val);
		for(iter it=b;it!=odt.end();it++) if(it->val!=L) L=it->val,cnt++;
		L=0;
		for(iter it=odt.begin();it!=e;it++) if(it->val!=L) L=it->val,cnt++;
		cnt-=t;
		return cnt;
	}
}
int rev=1;
inline int RL(int x){
	if(rev==-1) x=n-x+2;//反转 
	x-=mov;//移动 
	if(x>n) x-=n;//回正 
	if(x<=0) x+=n;
	return x;
}
int main() {
	ios::sync_with_stdio(0);
//	freopen("necklace10.in","r",stdin);
//	freopen("O.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		odt.insert(node(i,i,x));
	}
//	odt.insert(node(n+1,n+1,0));
	int q;
	cin>>q;
	while(q--){
		string opt;
		cin>>opt;
		if(opt=="R"){
			int k;
			cin>>k;
			mov+=k*rev;//维护偏移量 
			if(mov>n) mov-=n;
			if(mov<=0) mov+=n;//让 mov 好一点 
//			rorate(k);
		}
		if(opt=="F") rev*=-1;
		if(opt=="S"){
			int x,y;
			cin>>x>>y;
			x=RL(x),y=RL(y);
			int p=get(x),q=get(y);
			Paint(x,x,q),Paint(y,y,p);
		}
		if(opt=="P"){
			int l,r,k;
			cin>>l>>r>>k;
			l=RL(l),r=RL(r);
			if(rev==-1) swap(l,r);
			Paint(l,r,k);
		}
		if(opt=="C") cout<<Count()<<"\n";
		if(opt=="CS"){
			int l,r;
			cin>>l>>r;
			l=RL(l),r=RL(r);
			if(rev==-1) swap(l,r);
			cout<<Count(l,r)<<"\n";
		}
//		for(iter it=odt.begin();it!=odt.end();it++) 
//cout<<it->l<<" "<<it->r<<" "<<it->val<<"\n";
//		for(int i=it->l;i<=it->r;i++) cout<<it->val<<" ";
//		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：CzxingcHen (赞：2)

	今天是2018年3月12日植树节，按照传统，做一个线段树，看到还没有题解，来贡献一发（~~逃~~）
    odk那么这个题看一眼之后可以发现，每一次操作并没有改变所有点在整个序列中的位置，所以我们可以开两个变量，（我开的是）k记录整个序列左移了几位，rev（bool）记录是否翻转，我们在所有的操作中只要通过k和rev找到它在原来序列中的位置，然后再进行所述操作即可。
    那么对于所有的F操作，rev^=1即可；
    对于所有的M操作（详情请见代码…输入的数据是x）
     if(rev) k-=x；else k+=x;
     很好然后通过一些加减n的操作使它的值在1到n中即可（请看代码）
    对于其他的查询操作，线段树的操作可以参见   P2486染色这道题，这里不多赘述
    但是此题许注意一个坑点，因为题目中给出的序列其实是一个环，所以我们每次查询到答案后要判断是否根节点的左颜色与右颜色相同，等效于判断环首和环尾是否相等，然后将查询到的答案减一
    在得到了输入的区间（x，y）之后我们进行操作得到了这两个点在原序列中的位置，在这里坑点又来了，因为操作之后是可以得到x>y的，所以需要判断（请看代码）是否将一个区间拆成两个（就是环拉）（P.S.大家可以看到我被这个东西坑了好久。。。。）
    请看代码吧（感觉奇丑无比……蒟蒻瑟瑟发抖……）
    
    ```cpp
 	#include <cstdio>
	using namespace std;
	const int N=500005;
	int n,C,Q,a[N]={},k=0;
	struct node{
		int sum,lC,rC,col;
	}s[N<<2];
	bool rev=0;
	inline void read(int &X){
		X=0;char ch=0;int op=1;
		for(;ch>'9'||ch<'0';){if(ch=='-')op=-1;ch=getchar();}
		for(;ch>='0'&&ch<='9';){X=(X<<3)+(X<<1)+ch-48;ch=getchar();}
	X*=op;
	}
	inline void swap(int &x,int &y){int _=x;x=y;y=_;}
	inline void Seg(int &x){
		if(rev) x=n-x+2;
	x-=k;
	for(;x<1;x+=n);
	for(;x>n;x-=n);
	}
	inline void down(int p){
		if(s[p].col){
		s[p*2].lC=s[p*2].rC=s[p*2+1].lC=s[p*2+1].rC=s[p*2].col=s[p*2+1].col=s[p].col;
		s[p*2].sum=s[p*2+1].sum=1;
		s[p].col=0;
	}
	}
	inline void up(int p){
		if(p){
	//		down(p*2);
	//		down(p*2+1);
			s[p].sum=s[p*2].sum+s[p*2+1].sum;
			if(s[p*2].rC==s[p*2+1].lC)s[p].sum--;
			s[p].lC=s[p*2].lC;
			s[p].rC=s[p*2+1].rC;
		}
	}	
	void build(int p,int l,int r){
		s[p].col=0;
		if(l==r){
			s[p].lC=s[p].rC=a[l];
			s[p].sum=1;
			return;
		}
		int mid=(l+r)/2;
		build(p*2,l,mid);
		build(p*2+1,mid+1,r);
		up(p);
	}
	void modify(int p,int l,int r,int x,int y,int v){
		if(x<=l&&y>=r){
			s[p].col=v;
			s[p].lC=s[p].rC=v;
			s[p].sum=1;
			return;
		}
		down(p);
		int mid=(l+r)/2;
		if(x<=mid)modify(p*2,l,mid,x,y,v);
		if(y>mid)modify(p*2+1,mid+1,r,x,y,v);
		up(p);
	}
	int query(int p,int l,int r,int x,int y){
		if(x<=l&&y>=r)return s[p].sum;
		down(p);
		int mid=(l+r)/2,res=0;
		if(x<=mid)res+=query(p*2,l,mid,x,y);
		if(y>mid)res+=query(p*2+1,mid+1,r,x,y);
		if(x<=mid&&y>mid)if(s[p*2].rC==s[p*2+1].lC)return res-1;
		return res;
	}
	int queryC(int p,int l,int r,int x){
		if(l==r&&l==x)return s[p].lC;
		down(p);
		int mid=(l+r)/2;
		if(x<=mid)return queryC(p*2,l,mid,x);
		else return queryC(p*2+1,mid+1,r,x);
	}
	int main(){
		read(n);read(C);
		for(int i=1;i<=n;i++)read(a[i]);
		build(1,1,n);
		read(Q);
		for(char op[5];Q--;){
			scanf("%s",op);
			if(op[0]=='C')
			if(op[1]){
				int x,y;
				read(x);read(y);
				Seg(y);
				Seg(x);
				if(rev)swap(x,y);
				if(x<=y){
					int ans=query(1,1,n,x,y);
					if(x==1&&y==n&&s[1].lC==s[1].rC&&ans>1)ans--;
					printf("%d\n",ans);
				}else{
					int ans=query(1,1,n,x,n)+query(1,1,n,1,y);
					if(s[1].lC==s[1].rC)ans--;
					printf("%d\n",ans);
				}
			}else{
				int ans=query(1,1,n,1,n);
				if(s[1].lC==s[1].rC&&ans>1)ans--;
				printf("%d\n",ans);
			}
			else if(op[0]=='R'){
				int x;
				read(x);
				if(rev)k-=x;
				else k+=x;
				for(;k<0;k+=n);
				for(;k>n;k-=n);
			}else if(op[0]=='F')rev^=1;
			 else if(op[0]=='S'){
			 	int x,y,xC,yC;
			 	read(x);read(y);
			 	Seg(x);
				Seg(y);
			 	xC=queryC(1,1,n,x);
			 	yC=queryC(1,1,n,y);
			 	modify(1,1,n,x,x,yC);
			 	modify(1,1,n,y,y,xC);
			 }else if(op[0]=='P'){
			 	int x,y,v;
			 	read(x);read(y);read(v);
			 	Seg(y);
				Seg(x);
				if(rev)swap(x,y);
				if(x<=y)modify(1,1,n,x,y,v);
				else modify(1,1,n,x,n,v),modify(1,1,n,1,y,v);
			 }
		}
		return 0;
	}
```
    



---

## 作者：lyhqwq (赞：1)

# Solution

首先我们可以把题目中的操作分为两种，后四个操作是经典的线段树操作，我们可以用线段树进行维护。

对于旋转操作，我们发现 $n$ 颗珠子的相对位置不会改变，即查询的答案不会改变，所以我们可以每次操作时可以在原来的数列上进行修改。考虑记录一个 $delta$，表示当前旋转了多少个位置，每次旋转将 $delta+k$，之后的每次操作将位置编号改变为在原序列上对应的编号即可。

对于翻转操作，我们发现，如果进行两次翻转操作，就相当于什么也不做，所以我们可以打一个翻转标记 $flip$，每次翻转时将 $flip \oplus 1$。对于翻转下的每次旋转操作，其实相当于对原来的序列逆时针进行旋转，所以要将 $delta-k$。

至于如何去找要操作的编号在原序列上对应的编号，如果当前进行了翻转，那么要将 $x$ 变为 $n-x+2$。之后再把 $x$ 变为 $x-delta$，如果处理后的编号大于 $n$ 或者小于 $1$ ，那么就要相应的 $+n$ 或 $-n$。

特殊的，对于区间操作，如果当前进行了反转操作，那么需要将 $x$ 和 $y$ 交换。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005;
int n,q,delta,flip;
int lyhqwq;
int c[N];
int t(int x){
	if(flip) x=n-x+2;
	x-=delta;
	while(x<1) x+=n;
	while(x>n) x-=n;
	return x;
}
namespace SegTree{
	struct node{
		int l,r;
		int ans;
		int lco,rco;
		int lazy;
	}tree[N<<2];
	node operator + (node a,node b){
		node c;
		c.l=a.l;
		c.r=b.r;
		c.lco=a.lco;
		c.rco=b.rco;
		c.ans=a.ans+b.ans-(a.rco==b.lco);
		return c;
	}
	int lc(int x){return x<<1;}
	int rc(int x){return x<<1|1;}
	void push_up(int rt){
		tree[rt].lco=tree[lc(rt)].lco;
		tree[rt].rco=tree[rc(rt)].rco;
		tree[rt].ans=tree[lc(rt)].ans+tree[rc(rt)].ans-(tree[lc(rt)].rco==tree[rc(rt)].lco);
	}
	void push_down(int rt){
		if(tree[rt].lazy){
			tree[lc(rt)].lazy=tree[rc(rt)].lazy=tree[rt].lazy;
			tree[lc(rt)].ans=tree[rc(rt)].ans=1;
			tree[lc(rt)].lco=tree[lc(rt)].rco=tree[rt].lazy;
			tree[rc(rt)].lco=tree[rc(rt)].rco=tree[rt].lazy;
		}
		tree[rt].lazy=0;
	}
	void build(int rt,int l,int r){
		tree[rt].l=l,tree[rt].r=r;
		if(l==r){
			tree[rt].ans=1;
			tree[rt].lco=tree[rt].rco=c[l];
			return;
		}
		int mid=(l+r)>>1;
		build(lc(rt),l,mid);
		build(rc(rt),mid+1,r);
		push_up(rt);
	}
	void update(int rt,int L,int R,int v){
		int l=tree[rt].l,r=tree[rt].r;
		if(L<=l&&r<=R){
			tree[rt].ans=1;
			tree[rt].lco=tree[rt].rco=v;
			tree[rt].lazy=v;
			return;
		}
		push_down(rt);
		int mid=(l+r)>>1;
		if(L<=mid) update(lc(rt),L,R,v);
		if(R>mid) update(rc(rt),L,R,v);
		push_up(rt); 
	}
	node query(int rt,int L,int R){
		int l=tree[rt].l,r=tree[rt].r;
		if(L<=l&&r<=R){
			return tree[rt];
		}
		push_down(rt);
		int mid=(l+r)>>1;
		if(R<=mid) return query(lc(rt),L,R);
		if(L>mid) return query(rc(rt),L,R);
		return query(lc(rt),L,R)+query(rc(rt),L,R);
	}
}
using namespace SegTree;
int main(){
	scanf("%d%d",&n,&lyhqwq);
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	build(1,1,n);
	scanf("%d",&q);
	while(q--){
		string str;
		cin>>str;
		if(str=="R"){
			int x;
			scanf("%d",&x);
			if(flip)  delta-=x;
			else delta+=x;
			while(delta<1) delta+=n;
			while(delta>n) delta-=n; 
		}
		if(str=="F") flip^=1;
		if(str=="S"){
			int x,y;
			scanf("%d%d",&x,&y);
			x=t(x);
			y=t(y);
			if(flip) swap(x,y);
			int cx=query(1,x,x).lco,cy=query(1,y,y).lco;
			update(1,x,x,cy);
			update(1,y,y,cx);
		}
		if(str=="P"){
			int x,y,k;
			scanf("%d%d%d",&x,&y,&k);
			x=t(x);
			y=t(y);
			if(flip) swap(x,y);
			if(y<x){
				update(1,x,n,k);
				update(1,1,y,k);
			}
			else update(1,x,y,k);
		}
		if(str=="C") printf("%d\n",max(1,query(1,1,n).ans-(query(1,1,1).lco==query(1,n,n).lco)));
		if(str=="CS"){
			int x,y;
			scanf("%d%d",&x,&y);
			x=t(x);
			y=t(y);
			if(flip) swap(x,y);
			if(y<x) printf("%d\n",(query(1,x,n)+query(1,1,y)).ans);
			else printf("%d\n",query(1,x,y).ans);
		}
	}
	return 0;
}
```




---

## 作者：StaroForgin (赞：1)

过来看了一下，竟然没有用FHQ_Treap的，赶紧来发一篇。
# 题解
虽说这是一个环，但我们还是可以采取链的方式维护，最后再特判两端的情况即可。

先来分析一下每个操作的情况。

对于P操作，我们可以将其分为前n-k个与后k个两棵子树，将其反过来合并即可。

对于F操作，没必要去想那些奇偶性判断，直接将后n-1个倒置过来即可。

对于S操作，将i点与j点单独分出来，交换位置后再合并就可以了。

对于P操作，需分x小于等于y与x大于y两种情况来判断，覆盖掉分出来的部分即可。

对于C操作，直接输出过程中维护的和即可。

对于CS操作，我们可以也需分x小于等于y与x大于y两种情况来处理，输出需要求的一块或两块和即可。

至于反转与覆盖需要用懒标记来维护，否则会超时。

记住！！！不要在外面单独判断C或CS中需要求出整段和时两端相同的情况，尽量在updata中。笔者因为的特判WA了半天，最后全放在updata中维护就没事儿了。
# 代码
真的难调
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#define MAXN 1000005
using namespace std;
typedef long long LL;
const int INF=0x7f7f7f7f;
#define gc() getchar()
int son[MAXN][2],tot,rt;
int rnd[MAXN],siz[MAXN],q,n,c;
bool tag[MAXN];
int val[MAXN],ad[MAXN],cov[MAXN];
int pre[MAXN],re[MAXN],sum[MAXN];
template<typename _T>
inline void read(_T &x){
	_T f=1;x=0;char s=gc();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=gc();}
	while(s>='0'&&s<='9'){x=(x<<3)+(x<<1)+(s^48);s=gc();}
	x*=f;
} 
template<typename _T>
void write(_T x)
{
	if(x<0) x=~x+1,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int newnode(int v){
	int x=++tot;
	siz[x]=1;rnd[x]=rand();sum[x]=1;
	pre[x]=re[x]=val[x]=v;cov[x]=0;
	tag[x]=son[x][0]=son[x][1]=0;
	return x;
}
void reverse(int x){
	swap(son[x][0],son[x][1]);
	swap(pre[x],re[x]);
	tag[x]^=1;
}
void updata(int x){
	siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
	if(son[x][0]) pre[x]=pre[son[x][0]];
	else pre[x]=val[x];
	if(son[x][1]) re[x]=re[son[x][1]];
	else re[x]=val[x];
	sum[x]=1;
	if(re[son[x][0]]!=val[x]) sum[x]+=sum[son[x][0]];
	else sum[x]+=sum[son[x][0]]-1;
	if(pre[son[x][1]]!=val[x]) sum[x]+=sum[son[x][1]];
	else sum[x]+=sum[son[x][1]]-1;
	if(siz[x]==n&&pre[x]==re[x]&&sum[x]!=1) sum[x]--;
}
void covered(int x,int d){
	cov[x]=val[x]=d;
	pre[x]=re[x]=d;sum[x]=1;
}
void downdata(int x){
	if(tag[x]){
		if(son[x][0]) reverse(son[x][0]);
		if(son[x][1]) reverse(son[x][1]);
		tag[x]^=1;
	}
	if(cov[x]){
		if(son[x][0]) covered(son[x][0],cov[x]);
		if(son[x][1]) covered(son[x][1],cov[x]);
		cov[x]=0;
	}
}
void build(int &p,int l,int r){
	if(l>r) return ;
	int mid=(l+r)>>1;p=newnode(ad[mid]);
	build(son[p][0],l,mid-1);
	build(son[p][1],mid+1,r);
	updata(p);
	//printf("%d %d %d\n",l,r,minn[p]);
}
int merge(int a,int b){
	if(!a||!b) return a+b;
	downdata(a);downdata(b);
	if(rnd[a]<rnd[b]){
		son[a][1]=merge(son[a][1],b);
		updata(a);return a;
	}	
	son[b][0]=merge(a,son[b][0]);
	updata(b);return b;
}
void split(int now,int k,int &x,int &y){
	if(!now){
		x=y=0;
		return ;
	}
	downdata(now);
	if(k<=siz[son[now][0]]) 
		y=now,split(son[now][0],k,x,son[now][0]);
	else x=now,split(son[now][1],k-siz[son[now][0]]-1,son[now][1],y);
	updata(now);
}
signed main()
{
	read(n);read(c);
	for(int i=1;i<=n;i++) read(ad[i]);
	build(rt,1,n);read(q);
	for(int i=1;i<=q;i++){
		char opt[15]={};scanf("%s",opt);
		if(opt[0]=='F'){
			int xa,ya;split(rt,1,xa,ya);
			reverse(ya);rt=merge(xa,ya);
		}
		if(opt[0]=='R'){
			int k,xa,ya;read(k);
			split(rt,n-k,xa,ya);rt=merge(ya,xa);
		}
		if(opt[0]=='S'){
			int x,y,xa,xb,ya,yb,xc,yc,xd,yd;read(x);read(y);
			if(x>y) swap(x,y);
			if(x==y) continue;
			split(rt,y,xa,ya);split(xa,y-1,xb,yb);
			split(xb,x,xc,yc);split(xc,x-1,xd,yd);
			rt=merge(merge(merge(xd,yb),yc),merge(yd,ya));
		}
		if(opt[0]=='P'){
			int x,y,z;read(x);read(y);read(z);
			if(x<=y){
				int xa,ya,xb,yb;
				split(rt,y,xa,ya);split(xa,x-1,xb,yb);
				covered(yb,z);rt=merge(merge(xb,yb),ya);
			}
			else{
				int xa,ya,xb,yb;
				split(rt,x-1,xa,ya);split(xa,y,xb,yb);
				covered(xb,z);covered(ya,z);rt=merge(merge(xb,yb),ya);
			}
		}
		if(opt[0]=='C'&&opt[1]!='S') printf("%d\n",sum[rt]);
		if(opt[0]=='C'&&opt[1]=='S'){
			int x,y;read(x);read(y);
			if(x<=y){
				int xa,ya,xb,yb;
				if(x!=1||y!=n) {
					split(rt,y,xa,ya);split(xa,x-1,xb,yb);
					printf("%d\n",sum[yb]);
					rt=merge(merge(xb,yb),ya);
				}
				else printf("%d\n",sum[rt]);
			}
			else{
				int xa,ya,xb,yb;
				split(rt,x-1,xa,ya);split(xa,y,xb,yb);
				if(re[ya]!=pre[xb]) printf("%d\n",sum[ya]+sum[xb]);
				else printf("%d\n",sum[ya]+sum[xb]-1);
				rt=merge(merge(xb,yb),ya);
			}
		}
	}
	return 0;
}
```
## 谢谢！！！
csdn原文链接：[项链工厂](https://blog.csdn.net/Tan_tan_tann/article/details/103325747)

---

## 作者：This_Rrhar (赞：0)

珂朵莉树。

做法是很显然的暴力，我们考虑怎么执行操作。

- 对于 R 操作，考虑维护一个偏移量 offset，每次把旋转的距离加在该偏移量上，进行区间操作时再通过偏移量解密出区间在珂朵莉树中的位置。

- 对于 F 操作，容易发现旋转后 $1\to1,x\to n+2-x$，每次对操作取出树所有节点进行翻转即可，做好之后再赋值回原树。

- 对于 S 操作，把 $i,j$ 两个位置分裂出来直接交换即可。

- 对于 P 操作，等价于区间赋值。

- 对于 C 操作，暴力计数即可，将区间解密后，对是否跨位置 $n$ 进行分类讨论即可。

- 对于 CS 操作，暴力计数即可。

注意颜色段数不能用 `distance`，因为一个连续的颜色段可能会分裂成多个节点。

这题细节其实很少，实现也很简单，数据也很水。未经卡常下最大点跑了 3.37s，~~喜提最劣解~~。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll=long long;
using pii=pair<ll,ll>;

const ll N=5e5+1;

ll n,q,offset;

string op;
ll l,r,v;

struct node
{
	mutable ll l,r,v;
	node(ll l=0,ll r=0,ll v=0):l(l),r(r),v(v){}
	bool operator<(const node&B)const{return l<B.l;}
};
set<node>odt,tmp;
set<node>::iterator split(ll pos)
{
	set<node>::iterator it=odt.lower_bound(node(pos));
	if(it!=odt.end()&&it->l==pos)return it;
	if((--it)->r<pos)return odt.end();
	ll l=it->l,r=it->r,v=it->v;
	return odt.erase(it),odt.insert(node(l,pos-1,v)),odt.insert(node(pos,r,v)).first;
}
void assign(ll l,ll r,ll v)
{
	set<node>::iterator itr=split(r+1),itl=split(l);
	odt.erase(itl,itr),odt.insert(node(l,r,v));
}
void exchange(ll x,ll y)
{
	if(x>y)swap(x,y);
	split(y+1),split(x+1);
	set<node>::iterator itr=split(y),itl=split(x);
	swap(itl->v,itr->v);
}
#define mov(i)(((i)-1+offset)%n+1)
#define bck(i)(((i)-1-offset+n)%n+1)
ll rev(ll i){return i==1?1:(n-i+2);}
void flip()
{
	tmp.clear();
	for(set<node>::iterator it=odt.begin();it!=odt.end();it++)
	{
		ll l=rev(mov(it->r)),r=rev(mov(it->l));
		if(l<=r)tmp.insert(node(l,r,it->v));
		else tmp.insert(node(l,n,it->v)),tmp.insert(node(1,r,it->v));
	}
	odt=tmp,offset=0;
}
ll cntr()
{
	ll s=0,v=0;
	for(set<node>::iterator it=odt.begin();it!=odt.end();it++)if(it->v!=v)s++,v=it->v;
	return max(s-(odt.begin()->v==v),1ll);
}
ll cnt1(ll l,ll r)
{
	ll s=0,v=0;
	set<node>::iterator itr=split(r+1),itl=split(l);
	while(itl!=itr)
	{
		if(itl->v!=v)s++,v=itl->v;
		itl++;
	}
	return s;
}
ll cnt2(ll l,ll r)
{
	ll s=0,v=0;
	set<node>::iterator itl=split(l);
	while(itl!=odt.end())
	{
		if(itl->v!=v)s++,v=itl->v;
		itl++;
	}
	set<node>::iterator itr=split(r+1);
	for(itl=odt.begin();itl!=itr;itl++)if(itl->v!=v)s++,v=itl->v;
	return s;
}

int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>q,odt.insert(node(i,i,q));
	cin>>q;
	while(q--)
	{
		cin>>op;
		if(op=="R")cin>>v,(offset+=v)%=n;
		else if(op=="F")flip();
		else if(op=="S")cin>>l>>r,exchange(bck(l),bck(r));
		else if(op=="P")
		{
			cin>>l>>r>>v,l=bck(l),r=bck(r);
			if(l<=r)assign(l,r,v);
			else assign(l,n,v),assign(1,r,v);
		}
		else if(op=="C")cout<<cntr()<<"\n";
		else
		{
			cin>>l>>r,l=bck(l),r=bck(r);
			if(l<=r)cout<<cnt1(l,r)<<"\n";
			else cout<<cnt2(l,r)<<"\n";
		}
	}
}
```

---

## 作者：XuYueming (赞：0)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P4130)；[Hydro & bzoj](https://hydro.ac/d/bzoj/p/1493)。

[更好的体验](https://www.cnblogs.com/XuYueming/p/18311407)。

## 题意简述

yzh 喜欢写 DS 题！你要维护一个环：

1. 顺时针移动 $k$ 位；
1. 翻转 $2 \sim n$；
1. 交换 $i$ 与 $j$；
1. 区间覆盖；
1. 查询整个环有几个颜色段；
1. 查询 $i \sim j$ 有几个颜色段。

## 题目分析

平衡树板子啊，[代码](https://www.luogu.com.cn/paste/3lol7xdz)很好写，$273$ 行。但是为什么不使用线段树呢？

发现，顺时针移位，原本该连续的区间也还在一块（这里指的是环上，在序列上可能一个在首一个在尾，但这对分析问题并不重要）。所以遇到移位操作，只用记录一个偏移量，查询的时候对下表进行相应处理即可。同理，翻转操作也不必真的进行翻转，只用记一个翻转标记，每次让它异或 $1$ 即可。我们可以轻松写出如下转换函数。

```cpp
auto trans = [&mov, &flip] (int x) -> int {
	if (flip) x = mov - x + 2;
	else x = x - mov;
	x = (x % n + n) % n;
	return x ? x : n;
};
```

接下来考虑线段树如何实现。我们发现，问题变成了区间覆盖、单点查询颜色、区间查询颜色段数。很套路，在信息中记录左右端点的颜色以及区间内的颜色段数。合并的时候把两个自区间颜色段数相加，如果左边的右端点和右边的左端点颜色相同，再减去一次重复算的这一次。

```cpp
struct Info {
	int l, r, cnt;
	friend Info operator + (const Info& a, const Info& b) {
		return { a.l, b.r, a.cnt + b.cnt - (a.r == b.l) };
	}
};
```

剩下的板子不展开。

## 代码

```cpp
// #pragma GCC optimize(3)
// #pragma GCC optimize("Ofast", "inline", "-ffast-math")
// #pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main() { return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

int n, m, col[500010];

struct Segment_Tree {
	#define lson (idx << 1    )
	#define rson (idx << 1 | 1)
	
	struct Info {
		int l, r, cnt;
		friend Info operator + (const Info& a, const Info& b) {
			if (a.l == -1) return b;
			if (b.l == -1) return a;
			return { a.l, b.r, a.cnt + b.cnt - (a.r == b.l) };
		}
	};
	
	struct node {
		int l, r;
		int tag;
		Info info;
	} tree[500010 << 2];
	
	void build(int idx, int l, int r) {
		tree[idx] = {l, r, -1, {0, 0, 0}};
		if (l == r) return tree[idx].info = {col[l], col[r], 1}, void();
		int mid = (l + r) >> 1;
		build(lson, l, mid);
		build(rson, mid + 1, r);
		tree[idx].info = tree[lson].info + tree[rson].info;
	}
	
	void pushtag(int idx, int tag) {
		tree[idx].tag = tag;
		tree[idx].info = {tag, tag, 1};
	}
	
	void pushdown(int idx) {
		if (tree[idx].tag == -1) return;
		pushtag(lson, tree[idx].tag);
		pushtag(rson, tree[idx].tag);
		tree[idx].tag = -1;
	}
	
	void modify(int idx, int l, int r, int tag) {
		if (tree[idx].l > r || tree[idx].r < l) return;
		if (l <= tree[idx].l && tree[idx].r <= r) return pushtag(idx, tag);
		pushdown(idx);
		modify(lson, l, r, tag);
		modify(rson, l, r, tag);
		tree[idx].info = tree[lson].info + tree[rson].info;
	}
	
	Info query(int idx, int l, int r) {
		if (tree[idx].l > r || tree[idx].r < l) return {-1, -1, 0};
		if (l <= tree[idx].l && tree[idx].r <= r) return tree[idx].info;
		pushdown(idx);
		return query(lson, l, r) + query(rson, l, r);
	}
	
	#undef lson
	#undef rson
} yzh;

#ifdef XuYueming
#define printf printf(">>> "), printf
#endif

signed main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		scanf("%d", &col[i]);
	scanf("%d", &m), yzh.build(1, 1, n);
	for (int i, j, c, k, mov = 0, flip = 0; m--; ) {
		static char op[10];
		static auto trans = [&mov, &flip] (int x) -> int {
			if (flip) x = mov - x + 2;
			else x = x - mov;
			x = (x % n + n) % n;
			return x ? x : n;
		};
		scanf("%s", op);
		if (*op == 'R') {
			scanf("%d", &k);
			mov = (mov + k) % n;
		} else if (*op == 'F') {
			flip ^= 1, mov = (n - mov) % n;
		} else if (*op == 'S') {
            scanf("%d%d", &i, &j);
			i = trans(i), j = trans(j);
			int ci = yzh.query(1, i, i).l, cj = yzh.query(1, j, j).l;
			yzh.modify(1, i, i, cj), yzh.modify(1, j, j, ci);
        } else if (*op == 'P') {
            scanf("%d%d%d", &i, &j, &c);
			i = trans(i), j = trans(j);
			if (flip) swap(i, j);
			if (i <= j) {
				yzh.modify(1, i, j, c);
			} else {
				yzh.modify(1, i, n, c);
				yzh.modify(1, 1, j, c);
			}
        } else if (op[1] == '\0') {
			printf("%d\n", max(1, yzh.tree[1].info.cnt - (yzh.tree[1].info.l == yzh.tree[1].info.r)));
        } else {
            scanf("%d%d", &i, &j);
			i = trans(i), j = trans(j);
			if (flip) swap(i, j);
			if (i <= j) {
				printf("%d\n", yzh.query(1, i, j).cnt);
			} else {
				printf("%d\n", (yzh.query(1, i, n) + yzh.query(1, 1, j)).cnt);
			}
        }
	}
	return 0;
}
```

## 后记 & 反思

没有敏锐地发现连续段在操作后还是连续的这一性质，导致没秒掉这道水题。

---

## 作者：船酱魔王 (赞：0)

# P4130 [NOI2007] 项链工厂 题解

## 题意回顾

对于长度为 $ n $ 的环形序列 $ a $，你需要支持顺时针旋转若干格、$ [2,n] $ 翻转、两点交换、区间染色、查询环上同色块数、查询区间同色块数几种操作共 $ q $ 次。

$ 1 \le n \le 5 \times 10^5 $，$ 1 \le q \le 5 \times 10^5 $。

## 分析

先不考虑旋转、翻转操作，单考虑交换、染色、区间或全环同色块数查询几种操作。

我们可以用线段树维护，线段树上节点信息为 $ (st,ed,ct) $，分别代表区间起始颜色、结束颜色、颜色个数。

合并方式显然为 $ (st_{fa},ed_{fa},ct_{fa})=(st_{l},ed_{r},ct_{l}+ct_{r}-[st_{r}=ed_{l}]) $。

注意特判环上只有一种颜色的情况。

区间覆盖打懒标记即可。

考虑加入旋转、翻转操作，我们可以发现对于旋转操作，无需真正旋转序列，而可以将操作区间平移；对于翻转操作，将操作区间对称即可。

当两种操作同时存在时，我们先翻转再旋转，旋转在翻转的基础上进行。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 5e5 + 5;
int n, m, q;
int a[N];
struct node {
	int st;
	int ed;
	int ct;
} d[N * 4];
int c[N * 4];
node make(int s0, int e0, int c0) {
	node res;
	res.st = s0;
	res.ed = e0;
	res.ct = c0;
	return res;
}
void out(node p1) {
	printf("(start=%d,end=%d,color=%d)\n", p1.st, p1.ed, p1.ct);
}
node operator+(node p1, node p2) {
	node res;
	res.ct = p1.ct + p2.ct - (p1.ed == p2.st);
	res.st = p1.st;
	res.ed = p2.ed;
	if(p1.st == 0 && p1.ed == 0 && p1.ct == 0) {
		return p2;
	}
	//out(p1);cout<<"+";out(p2);cout<<"=";out(res);
	return res;
}
void build(int s, int t, int p) {
	if(s == t) {
		d[p] = make(a[s], a[s], 1);
		return;
	}
	int mid = (s + t) >> 1;
	build(s, mid, p * 2);
	build(mid + 1, t, p * 2 + 1);
	d[p] = d[p * 2] + d[p * 2 + 1]; 
}
void pushdown(int s, int t, int p) {
	if(c[p] != 0) {
		d[p * 2] = make(c[p], c[p], 1);
		d[p * 2 + 1] = make(c[p], c[p], 1);
		c[p * 2] = c[p];
		c[p * 2 + 1] = c[p];
		c[p] = 0;
	}
}
void update(int l, int r, int v, int s, int t, int p) {
	if(l <= s && t <= r) {
		c[p] = v;
		d[p] = make(v, v, 1);
		return;
	}
	pushdown(s, t, p);
	int mid = (s + t) >> 1;
	if(l <= mid) {
		update(l, r, v, s, mid, p * 2);
	}
	if(mid < r) {
		update(l, r, v, mid + 1, t, p * 2 + 1);
	}
	d[p] = d[p * 2] + d[p * 2 + 1];
}
node query(int l, int r, int s, int t, int p) {
	if(l <= s && t <= r) {
		return d[p];
	}
	pushdown(s, t, p);
	int mid = (s + t) >> 1;
	node res = make(0, 0, 0);
	if(l <= mid) {
		res = res + query(l, r, s, mid, p * 2);
	}
	if(mid < r) {
		res = res + query(l, r, mid + 1, t, p * 2 + 1);
	}
	d[p] = d[p * 2] + d[p * 2 + 1];
	return res;
}
int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	build(1, n, 1);
	string str;
	int l, r, x;
	int rot = 0;
	int pls = 0;
	cin >> q;
	for(int i = 1; i <= q; i++) {
		cin >> str;
		if(str == "R") {
			cin >> l;
			if(rot) {
				pls -= l;
			} else {
				pls += l;
			}
			pls = (pls % n + n) % n;
		} else if(str == "F") {
			rot = rot ^ 1;
		} else if(str == "S") {
			cin >> l >> r;
			if(rot) {
				l = n + 2 - l;
				r = n + 2 - r;
				swap(l, r);
				l = (l % n + n) % n;
				r = (r % n + n) % n;
			}
			l = ((l - 1 - pls) % n + n) % n + 1;
			r = ((r - 1 - pls) % n + n) % n + 1;
			int col1 = query(l, l, 1, n, 1).st;
			int col2 = query(r, r, 1, n, 1).st;
			update(l, l, col2, 1, n, 1);
			update(r, r, col1, 1, n, 1);
		} else if(str == "P") {
			cin >> l >> r >> x;
			
			if(rot) {
				l = n + 2 - l;
				r = n + 2 - r;
				swap(l, r);
				l = (l % n + n) % n;
				r = (r % n + n) % n;
			}
			l = ((l - 1 - pls) % n + n) % n + 1;
			r = ((r - 1 - pls) % n + n) % n + 1;
			if(l <= r) {
				update(l, r, x, 1, n, 1);
			} else {
				update(l, n, x, 1, n, 1);
				update(1, r, x, 1, n, 1);
			}
		} else if(str == "C") {
			node ans = query(1, n, 1, n, 1);
			if(ans.st == ans.ed) {
				if(ans.ct > 1) {
					ans.ct--;
				}
			}
			cout << ans.ct << endl;
		} else if(str == "CS") {
			cin >> l >> r;
			
			if(rot) {
				l = n + 2 - l;
				r = n + 2 - r;
				swap(l, r);
				l = (l % n + n) % n;
				r = (r % n + n) % n;
			}
			l = ((l - 1 - pls) % n + n) % n + 1;
			r = ((r - 1 - pls) % n + n) % n + 1;
			//cout << l << "~" << r << endl;
			if(l <= r) {
				cout << query(l, r, 1, n, 1).ct << endl;
			} else {
				cout << (query(l, n, 1, n, 1) + query(1, r, 1, n, 1)).ct << endl;
			}
		}
	}
	return 0;
}
```

## 总结与评价

很巧妙的处理方式，把难以解决的操作记录下来，考虑对其他操作的影响。

码量略显恶心。

感谢机房同级大佬 lyhqwq 帮我调了代码（

---

## 作者：3a51_ (赞：0)

线段树。总体思路为记录一下 rotate/flip 的情况然后就是普通线段树了。

### swap

单查 $2$ 次得到 $i,j$ 的颜色，然后赋值单修两次。

### paint

赋值区修，要懒标记。

### count / countsegment

区查，记录一下一个区间内的“部分”的个数，左界颜色，右界颜色。

合并：若左子树的右界颜色和右子树的左界颜色一样，那么答案为左子树“部分” $+$ 右子树“部分” $-1$ 。否则答案为左子树“部分” $+$ 右子树“部分”。

### rotate/flip

开两个变量 $R,F$ 记录 rotate/flip。

更新 rotate 时，$R$ 变为 $R+k$。

更新 flip 时，rotate 会变换方向，所以 $R=n-R$。

这里注意对 $n$ 取模时候的一些特殊情况。

### 将 $x$ 变为原环上的下标

说白了就是往回转 $R$ 步。存在 flip 取个反。注意对 $n$ 取模。

---


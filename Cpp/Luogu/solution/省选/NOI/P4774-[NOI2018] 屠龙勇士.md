# [NOI2018] 屠龙勇士

## 题目描述

小 D 最近在网上发现了一款小游戏。游戏的规则如下：

- 游戏的目标是按照编号 $1 \rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ，直至生命值非负。只有在攻击结束后且当生命值 **恰好** 为 $0$ 时它才会死去。
- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。

小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：

- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 **攻击力最低** 的一把剑作为武器。
- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少 $x \times ATK$ 。
- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$ ，则巨龙死亡，玩家通过本关。

那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？

当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

### 样例 2

见附加文件中的 `dragon2.in` 与 `dragon2.ans`。

### 样例 1 解释

第一组数据：
- 开始时拥有的剑的攻击力为 $\{1,9,1000\}$，第 $1$ 条龙生命值为 $3$，故选择攻击力为 $1$ 的剑，攻击 $59$ 次，造成 $59$ 点伤害，此时龙的生命值为 $-56$，恢复 14 次后生命值恰好为 $0$，死亡。

- 攻击力为 $1$ 的剑消失，拾取一把攻击力为 $7$ 的剑，此时拥有的剑的攻击力为
$\{7,9,1000\}$，第 2 条龙生命值为 $5$，故选择攻击力为 $7$ 的剑，攻击 $59$ 次，造成 $413$ 点伤害，此时龙的生命值为 $-408$，恢复 $68$ 次后生命值恰好为 $0$，死亡。

- 此时拥有的剑的攻击力为 $\{3,9,1000\}$，第 $3$ 条龙生命值为 $7$，故选择攻击力为 $3$ 的剑，攻击 $59$ 次，造成 $177$ 点伤害，此时龙的生命值为 $-170$，恢复 $17$ 次后生命值恰好为 0，死亡。

- 没有比 $59$ 次更少的通关方法，故答案为 $59$。

第二组数据：
不存在既能杀死第一条龙又能杀死第二条龙的方法，故无法通关，输出 $-1$。

### 子任务

测试点编号 |　　　$n$　　　|　　　$m$　　　|　　　$p_i$　　　|　　　$a_i$　　　| 　　攻击力　　 | 其他限制
-|-|-|-|-|-|-
1|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$=1$| 无
2|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$=1$| 无
3|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$\le 10^5$| 无
4|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$\le 10^5$| 无
5|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
6|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
7|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
8|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
9|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
10|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
11|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
12|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
13|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
14|$=10^5$|$=10^5$|$=1$|$\le 10^8$|$\le 10^6$| 无特殊限制
15|$=10^5$|$=10^5$|$=1$|$\le 10^8$|$\le 10^6$| 无特殊限制
16|$\le 10^5$|$\le 10^5$| 所有 $p_i$ 是质数 |$\le 10^{12}$|$\le 10^6$| 特性 1
17|$\le 10^5$|$\le 10^5$| 所有 $p_i$ 是质数 |$\le 10^{12}$|$\le 10^6$| 特性 1
18|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1
19|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1
20|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1

特性 1 是指：对于任意的 $i$，$a_i \le p_i$。

特性 2 是指：$\operatorname{lcm}(p_i) \le 10^6$，即所有 $p_i$ 的 **最小公倍数** 不大于 $10^6$。

对于所有的测试点，$T \le 5$，所有武器的攻击力 $\le 10^6$，所有 $p_i$ 的最小公倍数 $\le 10^{12}$。

保证 $ T, n, m $ 均为正整数。

### 提示

你所用到的中间结果可能很大，注意保存中间结果的变量类型。

## 样例 #1

### 输入

```
2
3 3
3 5 7
4 6 10
7 3 9
1 9 1000
3 2
3 5 6
4 8 7
1 1 1
1 1```

### 输出

```
59
-1```

# 题解

## 作者：emptysetvvvv (赞：157)

## 背景

>感觉这题还是比较清晰的。

## 思路

### Part I

很明显每条龙对应的剑是确定的，用平衡树处理出第 $i$ 条龙对应的剑的攻击力是 $b_i$，为了方便展示，我就偷懒用 `multiset<long long>` 实现了。

那么现在题意就转化为，对同余方程组

$$\begin{cases}b_1x\equiv a_1\pmod {p_1}\\b_2x\equiv a_2\pmod {p_2}\\\qquad\cdots\\b_nx\equiv a_n\pmod {p_n}\end{cases}$$

求最小非负整数解。

需要注意的是，要保证可以把龙血砍成负的，即 $x$ 不能小于**将每条龙砍成负血的最小刀数**。

### Part II

在此之前，不妨先想想普通的扩展中国剩余定理是怎么做的，即所有 $b_i=1$ 的情况。

1. 假设已经得到了前 $i-1$ 组同余方程的解，记为 $ans$；
2. 设 $M=\operatorname{lcm}(p_1,p_2,\ldots,p_{i-1})$，则对于任意的整数 $x$，$ans+Mx$ 是前 $i-1$ 组同余方程的通解；
3. 我们想得到前 $i$ 组同余方程的解，就是想找到一个 $x$，满足 $ans+Mx\equiv a_i\pmod {p_i}$；
4. 移项得 $Mx\equiv a_i-ans\pmod{p_i}$；
5. 这类式子一看就是老扩欧了，转化成 $Ax+By=C$ 的形式用扩展欧几里得求解，即：

$$(M)x+(p_i)y=(a_i-ans)$$

### Part III

那么有系数 $b_i$ 怎么搞呢？逆元是不可能逆元的，又不互质，在模 $p_i$ 意义下 $b_i$ 未必有逆元。

害，其实还是换汤不换药呗。

1. 假设已经得到了前 $i-1$ 组同余方程的解，记为 $ans$；
2. 设 $M=\operatorname{lcm}(p_1,p_2,\ldots,p_{i-1})$，则对于任意的整数 $x$，$ans+Mx$ 是前 $i-1$ 组同余方程的通解；
3. 想得到前 $i$ 组同余方程的解，就是想找到一个 $x$，满足 $b_i(ans+Mx)\equiv a_i\pmod {p_i}$；
4. 移项得 $b_iMx\equiv a_i-b_ians\pmod{p_i}$；
5. 这类式子一看就是老扩欧了，转化成 $Ax+By=C$ 的形式用扩展欧几里得求解，即：

$$(b_iM)x+(p_i)y=(a_i-b_ians)$$

### Part IV

几点注意事项：

1. 判无解就跟平常扩欧的判解一样，若 $C$ 不是 $\gcd(A,B)$ 的倍数，则无解，即若 $a_i-b_ians$ 不是 $\gcd(b_iM,p_i)$ 的倍数，则无解；
2. 看下数据范围，明显有两处需要龟速乘的，鉴于大家都会，我就偷懒用 `__int128` 实现了。

## 代码

```cpp
#include <set>
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 100005;
int T, n, m, b[maxn], t[maxn];
long long a[maxn], p[maxn], mx;
multiset<long long> s;
void exgcd(long long A, long long B, long long &x, long long &y, long long &gcd) {
	if(!B) x = 1, y = 0, gcd = A;
	else exgcd(B, A%B, y, x, gcd), y -= (A/B) * x;
}
long long ExCRT() {
	long long ans = 0, lcm = 1, x, y, gcd, A, B, C;
	for(int i = 1; i <= n; ++i) {
		A = (__int128)b[i] * lcm % p[i];
		B = p[i];
		C = (a[i]-b[i]*ans%p[i]+p[i]) % p[i];
		exgcd(A, B, x, y, gcd), x = (x%B+B) % B;
		if(C % gcd) return -1;
		ans += (__int128)(C/gcd) * x % (B/gcd) * lcm % (lcm*=B/gcd);
		ans %= lcm;
	}
	if(ans < mx) ans += ((mx-ans-1)/lcm+1) * lcm;
	return ans;
}
int main() {
	scanf("%d", &T);
	while(T--) {
		s.clear(), mx = 0;
		scanf("%d %d", &n, &m);
		for(int i = 1; i <= n; ++i) scanf("%lld", &a[i]);
		for(int i = 1; i <= n; ++i) scanf("%lld", &p[i]);
		for(int i = 1; i <= n; ++i) scanf("%d", &t[i]);
		for(int i = 1, x; i <= m; ++i) scanf("%d", &x), s.insert(x);
		for(int i = 1; i <= n; ++i) {
			auto u = s.upper_bound(a[i]);
			if(u != s.begin()) u--;
			b[i] = *u, s.erase(u), s.insert(t[i]);
			mx = max(mx, (a[i]-1)/b[i]+1);
		}
		printf("%lld\n", ExCRT());
	}
}
```

## P.S.

其实 emptyset 不懒，只是这样比较方便在题解区展示啦。

emptyset 自己 yy 的做法，有 hack 数据可以叫她（有点担心溢出的问题）。

觉得还不错的话点个赞吧。

---

## 作者：shadowice1984 (赞：81)

场外选手休闲做题……

拓展中国剩余定理板子题
_______________

## 本题题解

### 一些性质

首先我们会发现宰第i条龙时玩家的攻击力是一定的，因为每次使用的剑是确定的，每次得到的剑也是一定的。，因此我们可以使用$std::multiset$手动模拟宰龙的过程每次upper_bound出当前轮次的攻击力

接下来是求解最小的攻击次数的过程

我们发现龙在血量成为负数之后会自动定量回血这个设定十分像对负数取模

那么我们是否可以确定，一条龙被杀死当且仅当它的受到的伤害值模p为自己的血量呢？

或者说，我们能不能列出一个像这样的含n个同余方程的同余方程组，求出这个同余方程组的最小正整数解x,然后说这就是最小的攻击次数呢？

## $C_{i}x \equiv A_{i}(mod P_{i})$

其中$C_{i}$是杀第i条龙时的攻击力，$A_{i}$是第i条龙初始的血量，$P_{i}$是第i条龙的恢复能力

然后我们发现并不是，因为题目当中并没保证$A_{i} \leq P_{i}$

这样的话我们的同余限制条件只能保证攻击x次之后所有龙的血量模自身的恢复力都是0

但是如果$A_{i} > P_{i}$的话我们会发现我们攻击之后可能龙的血量从来没有到过负值，但是血量却的确模p为0了

~~情况开始变得辣手~~

此时是考验大家阅读理解能力的时刻了！

仔细阅读出题人给出的数据表格，如果这个测试点不保证$A_{i} \leq P_{i}$的话，它一定会满足一个条件就是$P_{i}=1$

这意味这我们可以大力特判掉这种情况，显然，在$P_{i}=1$的情况下，答案是

## $Max_{i=1}^{n}( \lceil \frac{A_{i}}{C_{i}} \rceil )$

就是所有龙血量为负的最小刀数取一个max就可以了

下面让我们集中精力解决$A_{i} \leq P_{i}$的情况
___________________

## 化简同余方程

在$A_{i} \leq P_{i}$这种情况下，大部分情况(除了几个臭名昭著的特例)，我们的同余方程都是生效的

换句话我们现在唯一要做的就是解下面同余方程组的最小正整数解

## $C_{i}x \equiv A_{i}(mod P_{i})$

你会发现这和标准中国剩余定理的方程不是非常一样，即使是可以处理模数不两两互质的拓展中国剩余定理，也只能处理这样的同余方程

## $x \equiv A_{i}(mod P_{i})$

换句话说x的系数必须是1

而且更加辣手的是$C_{i}$在模$P_{i}$意义下极有可能不存在逆元，所以我们也不能把$C_{i}$除掉

那么有什么办法可以化简这个东西吗？

(作为一名敢写noi2018的选手，理论上应该是会exgcd解一般的不定方程的，但是为了避免你的式子有些部分推错，这里还是介绍一下如何解一般的不定方程)

熟练的话可以跳过这一部分
________________________

### 前置知识:使用exgcd算法求解一般的不定方程

换句话说这里解决的问题是如何求方程$Ax+By=C (A,B,C >0)$的通解

但是众所周知，exgcd算法只能计算出方程$Ax+By=(A,B)$的一组特殊解

但是这里有一个结论是这个方程有解当且仅当 $C|(a,b)$

所以我们可以稍稍换个元

令 $\frac{C}{(a,b)}x^{'}=x$,$\frac{C}{(a,b)}y^{'}=y$的话我们会发现我们的方程变成了这样

## $A\frac{C}{(a,b)}x^{'} +B \frac{C}{(a,b)}y^{'}=(a,b)\frac{C}{(a,b)}$

所以我们可以这样除掉了$\frac{C}{(a,b)}$

于是方程就变成了可爱的$Ax^{'}+By^{'}=(A,B)$

使用exgcd算法求出他的一个特解$sx^{'}$那么原方程的特解就是$\frac{C}{(a,b)}x^{'}$

所以我们就得到了原方程的两个特解，可以借此构造原方程出所有的通解

___________________________

言归正传我们现在化简同余方程了,想办法把方程

## $C_{i}x \equiv A_{i}(mod P_{i})$

变成

## $x \equiv A_{i}(mod P_{i})$

第一个方程可以写成这样的不定方程的形式

## $C_{i}x+P_{i}y = A_{i}$

使用exgcd求出他的一组特解 $Sx,Sy$

根据通解公式可以轻松的得到

## $x=sx+k\frac{P_{i}}{(C_{i},P_{i})}$

两边同时对$\frac{P_{i}}{(C_{i},P_{i})}$取模

## $x \equiv sx (mod \frac{P_{i}}{(C_{i},P_{i})})$

好了我们愉快的将同余方程化成了标准式，现在该考虑怎么解同余方程组了

____________________________

## Extended CRT:拓展中国剩余定理

我们现在要做的事情很简单，求同余方程组

## $x \equiv C{i}(mod P_{i})$

的最小正整数解，不保证两两互质

那么我们的思路事实上也是非常暴力的，将这些同余方程两两合并成一个同余方程，使得最后只剩下一个同余方程

所以我们的目标就是合并两个同余方程

## $x \equiv C_{1}(mod P_{1})$

## $x \equiv C_{2}(mod P_{2})$

首先我们可以把同余方程写成不定方程

## $x=C_{1}+ P_{1}y_{1}$

## $x=C_{2}+ P_{2}y_{2}$

由于事实上x同时满足两个方程，所以我们将两个方程联立

## $P_{1}y_{1}=P_{2}y_{2}+C_{2}-C_{1}$

根据不定方程的一些基本知识我们可以知道这个不定方程有解当且仅当$C_{2}-C_{1}|(P_{1},P_{2})$

所以我们还是使用古老的套路两边同时除$(P_{1},P_{2})$这样的话，我们会发现式子变成了这样

## $\frac{P_{1}}{(P_{1},P_{2})}y_{1}=\frac{P_{2}}{(P_{1},P_{2})}y_{2}+\frac{C_{2}-C_{1}}{(P_{1},P_{2})}$

此时采用另一个老套路，两边同时对$\frac{P_{2}}{(P_{1},P_{2})}$取模

可以得到

## $\frac{P_{1}}{(P_{1},P_{2})}y_{1}\equiv \frac{C_{2}-C_{1}}{(P_{1},P_{2})} (mod \frac{P_{2}}{(P_{1},P_{2})})$

好的我们来看一下此时$\frac{P_{1}}{(P_{1},P_{2})}$和模数一定互质了，这意味着我们可以除逆元了

所以

## $y_{1}\equiv inv(\frac{P_{1}}{(P_{1},P_{2})},\frac{P_{2}}{(P_{1},P_{2})})\frac{C_{2}-C_{1}}{(P_{1},P_{2})} (mod \frac{P_{2}}{(P_{1},P_{2})})$

重新把这个同余方程写成不定方程

## $y_{1}= inv(\frac{P_{1}}{(P_{1},P_{2})},\frac{P_{2}}{(P_{1},P_{2})})\frac{C_{2}-C_{1}}{(P_{1},P_{2})} +k\frac{P_{2}}{(P_{1},P_{2})}$

然后代入到x的式子里

## $x=C_{1}+ P_{1}y_{1}$

得到的大概是这样的式子

## $x=(inv(\frac{P_{1}}{(P_{1},P_{2})},\frac{P_{2}}{(P_{1},P_{2})})\frac{C_{2}-C_{1}}{(P_{1},P_{2})})\%\frac{P_{2}} {(P_{1},P_{2})} ×P_{1}+k\frac{P_{1}P_{2}}{(P_{1},P_{2})}+C_{1}$

依旧是老套路，两边同时对$\frac{P_{1}P_{2}}{(P_{1},P_{2})}$取模消掉烦人的k


我们得到了

## $x \equiv (inv(\frac{P_{1}}{(P_{1},P_{2})},\frac{P_{2}}{(P_{1},P_{2})})\frac{C_{2}-C_{1}}{(P_{1},P_{2})})\%\frac{P_{2}} {(P_{1},P_{2})} ×P_{1}+C_{1} (mod \frac{P_{1}P_{2}}{(P_{1},P_{2})})$

此时我们发现这两个同余方程合并成了一个同余方程，此时我们就可以不停的合并同余方程来求解整个同余方程组的最小正整数解了

然后我们做完了这道题？

__________________________________

## 一些小特例

如果所有的$P_{i}=A_{i}$的话我们解同余方程的结果将会是0

但是事实上这是不对的

直接求出杀死每条龙所需的刀数然后所有刀数求一个lcm即可

另一个小特例是我们的$C_{i}$是$P_{i}$的倍数时一般情况时杀不掉这条龙的

但是呢，如果$A_{i}=P_{i}$就很有趣了

此时这个方程等于没用，需要把它扔掉，换成一个没啥用的方程，比如$X\equiv 0(mod 1)$就行了

________________________

## 温馨提示

你的模数全部是longlong范围的，直接乘会爆longlong，请使用龟速乘法进行运算


上代码~

```C
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;const int N=1e5+10;typedef long long ll;
multiset <ll> s;int n;int m;ll mod[N];ll xs[N];ll cs[N];ll st[N];ll gif[N];int T;
inline void exgcd(ll a,ll& x,ll b,ll& y)//exgcd 
{if(b==0){x=1;y=0;return;}exgcd(b,x,a%b,y);ll t=x;x=y;y=t-(a/b)*y;}
inline ll gcd(ll a,ll b){if(a<b)swap(a,b);while(b){ll c=a%b;a=b;b=c;}return a;}
inline ll inv(ll a,ll p){a%=p;ll x;ll y;exgcd(a,x,p,y);return ((x<0)?x+p:x);}
inline ll mul(ll a,ll b,const ll& md)//龟速乘 
{ll ret=0;b=b%md;b=(b>0)?b:b+md;for(;b;b>>=1,a=(a+a)%md)(ret+=a*(b&1))%=md;return ret;}
inline void cfil(){printf("-1\n");return;}
inline void spsolve()//特判 
{
	ll res=0;
	for(int i=1;i<=n;i++)res=max(res,((cs[i]+xs[i]-1)/xs[i]));
	printf("%lld\n",res);
}
inline void spsolve2()//特判 
{
	ll lc=1;
    for(int i=1;i<=n;i++)
        {ll ds=mod[i]/gcd(mod[i],xs[i]);lc=lc/gcd(lc,ds)*ds;}
    printf("%lld\n",lc);
} 
inline void solve()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&cs[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&mod[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&gif[i]);
	for(int i=1;i<=m;i++)scanf("%lld",&st[i]);
	for(int i=1;i<=m;i++)s.insert(st[i]);
	multiset <ll>:: iterator it;
	for(int i=1;i<=n;i++)//预处理方程的系数 
	{
		it=(cs[i]<(*s.begin()))?s.begin():(--s.upper_bound(cs[i]));
		xs[i]=*it;s.erase(it);s.insert(gif[i]);
	}
	for(int i=1;i<=m;i++)if(mod[i]!=cs[i])goto ski;spsolve2();return;ski:;//判一下p=a的情况 
	for(int i=1;i<=n;i++)if(mod[i]!=1)goto skp;spsolve();return;skp:;//判一下p=1的情况 
	for(int i=1;i<=n;i++)xs[i]%=mod[i];
	for(int i=1;i<=n;i++)//检测是否有无用的方程 
		if(xs[i]==0){if(mod[i]==cs[i]){xs[i]=1;mod[i]=1;cs[i]=0;}else {cfil();return;}}
	for(int i=1;i<=n;i++)//化简同余方程 
	{
		ll sx;ll sy;ll g=gcd(xs[i],mod[i]);if(cs[i]%g!=0){cfil();return;}
		exgcd(xs[i],sx,mod[i],sy);
		mod[i]=mod[i]/g;sx=(sx%mod[i]+mod[i])%mod[i];cs[i]=mul(sx,cs[i]/g,mod[i]);
	}
	for(int i=1;i<=n-1;i++)//合并同余方程 
	{
		ll g=gcd(mod[i],mod[i+1]);if((cs[i+1]-cs[i])%g!=0){cfil();return;}
		ll ncs=mul(inv(mod[i]/g,mod[i+1]/g),(cs[i+1]-cs[i])/g,mod[i+1]/g);
		ll nmod=mod[i]/g*mod[i+1];
		ncs=mul(ncs,mod[i],nmod);(ncs+=cs[i])%=nmod;cs[i+1]=ncs;mod[i+1]=nmod;
	}printf("%lld\n",cs[n]);return;
}
inline void clear(){s.clear();}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++)solve(),clear();return 0;}//拜拜程序~ 
```














---

## 作者：FlashHu (赞：22)

也可以去[蒟蒻的blog](https://www.cnblogs.com/flashhu/p/9346078.html)上看

### 前言

我们熟知的中国剩余定理，在使用条件上其实是很苛刻的，要求模线性方程组$x\equiv c(\mod m)$的模数两两互质。

于是就有了扩展中国剩余定理，其实现方法大概是通过扩展欧几里德把两个同余方程合并，具体会在下面提到。

但是，使用仍有限制，那就是$x$的系数必须为$1$。

~~没关系，把它再扩展一下~~

## 题目及实现

### 题意分析

显然，如果我们能干掉所有龙，那么每一次使用的剑的攻击力是已知的，设为$k$。那么对于每一条龙，攻击次数$x$必须满足$kx\equiv a(\mod p)$（变量名都是原题中的）；当然别忘记要先把生命值降到非正数，也就是说还要满足$kx\geq a$即$x\geq\lceil\frac a k\rceil$。

可以看出不能直接用扩展中国剩余定理，但不妨碍先介绍一下它。

### 扩展中国剩余定理

如果有一个模线性方程组，每个形如$x\equiv c(\mod m)$，而且不保证$m$两两互质，就用不了中国剩余定理了。

扩展中国剩余定理是这样做的。

我们先把问题简化到一个方程组只有两个方程的情况，形如

$$\begin{cases}x\equiv c_1(\mod m_1)\\x\equiv c_2(\mod m_2)\end{cases}$$

把它写成不定方程的形式

$$\begin{cases}x=c_1+m_1x_1\\x=c_2+m_2x_2\end{cases}$$

这样就可以合并了，解一下$x_1$，所以$x_2$可变号

$$c_1+m_1x_1=c_2+m_2x_2$$

$$m_1x_1+m_2x_2=c_1-c_2$$

发现变成了一个二元一次不定方程的样子，设$g=gcd(m_1,m_2)$，用扩展欧几里德求$m_1x_1+m_2x_2=g$中$x_1$的一个解$x'$，于是用$\frac{c_1-c_2}gx'+\frac{m_2}gt(t\in\mathbb Z)$可以表示$x_1$的解集（关于一般二元一次不定方程的解法和解的周期性证明可以看看蒟蒻之前写的一篇[题解](https://www.cnblogs.com/flashhu/p/9149119.html)）

把解集带回$x=c_1+m_1x_1$得到

$$x=c_1+\frac{m_1(c_1-c_2)}gx'+\frac{m_1m_2}gt$$

$$x\equiv c_1+\frac{m_1(c_1-c_2)}gx'(\mod {\frac{m_1m_2}gt})$$

这样，我们设初始方程为$x\equiv 0(\mod1)$，每次合并两个方程得到新的方程。当然中途如果有一次出现$\frac{c_1-c_2}g$不为整数则整个方程组无解。

### 再扩展

那么模线性方程组，每个形如$kx\equiv a(\mod p)$该怎么解好呢？

还是要合并方程。仍然设一个总方程$x\equiv c(\mod m)$，将它与当前方程合并。

~~下面是同步赛上手推的式子，请直接跳过这一段，因为式子是错的，只有45分。说不定有些Dalao和我的想法一样？~~

~~直接合并~~

$$\begin{cases}x=c+mx_0\\kx+py_0=a\end{cases}$$

$$k(mx_0+c)+py_0=a$$
$$kmx_0+py_0=a-kc$$

~~设$g=gcd(km,p)$，解不定方程得到一个解$x'$，有~~

$$x_0=\frac{a-kc}gx'+\frac p gt$$
$$x=c+\frac{m(a-kc)}gx'+\frac{mp}gt$$

$$x=c+\frac{m(a-kc)}gx'(\mod\frac{mp}g)$$

为什么不能直接合并呢？因为连当前$kx\equiv a(\mod p)$能不能解都没有考虑。

所以正确的方法应该是先解当前方程$kx+py=a$。

设$g=gcd(k,p)$，解$x'$，得$x=\frac a gx'+\frac p gt$即$x\equiv\frac a gx'(\mod\frac p g)$

方程里$x$的系数被去掉了！可以从求逆元的角度来理解这一个过程。

当然，会有一些特殊情况。如果$p\mid k$且$p\mid a$，方程恒成立，我们不把它与总方程合并。如果$p\mid k$且$p\nmid a$，显然无解。

最后就是用扩展中国剩余定理合并啦。

### 具体实现

确定每次攻击使用的剑，直接用multiset解决，二分找到满足要求的剑（比较舒服的是upper_bound找第一个比要求大的剑，如果等于begin-iterator的话就说明没有不大于要求值的，直接选它，否则--iterator就是满足要求的），把它删掉，再加入当前奖励的剑。注意删的时候删的是iterator而不是数字。

再次提醒要注意$x\geq\lceil\frac a k\rceil$。可以求出$\max\{\lceil\frac a k\rceil\}$，如果最后总方程的$c$小于它，则要补至满足条件的最小值，用式子写一下大概是$c+m\lceil\frac{\max-c}{m} \rceil$。

注意数据范围，会爆longlong的地方用快速乘。注意处理负数。

多组数据，注意清空和初始化。
```cpp
#include<cstdio>
#include<set>
#define RG register
#define R RG LL
#define GC c=getchar()
using namespace std;
typedef long long LL;
const int N=1e5+9;
LL a[N],p[N],b[N],X,Y,G;
multiset<LL>s;
inline LL in(){
	RG char GC;
	while(c<'-')GC;
	R x=c&15;GC;
	while(c>'-')x*=10,x+=c&15,GC;
	return x;
}
void exgcd(R a,R b){
	if(!b){X=1;Y=0;G=a;return;}
	exgcd(b,a%b);
	(Y^=X^=Y^=X)-=a/b*X;
}
inline LL mul(R b,R k,R m){//快速乘
	R a=0;
	for(;k;k>>=1,b=(b<<1)%m)
		if(k&1)a=(a+b)%m;
	return a;
}
int main(){
	freopen("dragon.in","r",stdin);
	freopen("dragon.out","w",stdout);
	R T=in(),n,m,i,c,k,mx;
	RG multiset<LL>::iterator it;
	E:while(T--){
		n=in();m=in();
		for(i=1;i<=n;++i)a[i]=in();
		for(i=1;i<=n;++i)p[i]=in();
		for(i=1;i<=n;++i)b[i]=in();
		s.clear();//注意清空
		for(i=1;i<=m;++i)s.insert(in());
		mx=c=0;m=1;//初始总方程
		for(i=1;i<=n;++i){
			it=s.upper_bound(a[i]);//谨慎选择lower_bound和upper_bound
			if(it!=s.begin())--it;
			k=*it;s.erase(it);s.insert(b[i]);//小心手一滑erase(*it)(居然还有90分)
			mx=max(mx,(a[i]-1)/k+1);//更新限制
			k%=p[i];a[i]%=p[i];//开始解方程，去掉系数
			if(!k&&a[i]){puts("-1");goto E;}
			if(!k&&!a[i])continue;//这两个要特判
			exgcd(k,p[i]);
			if(a[i]%G){puts("-1");goto E;}
			p[i]/=G;
			a[i]=mul(a[i]/G,(X%p[i]+p[i])%p[i],p[i]);
			exgcd(m,p[i]);//开始合并，X和a-c都可能是负数
			if((a[i]-c)%G){puts("-1");goto E;}
			m=m/G*p[i];
			c=(c+mul(mul(m/p[i],((a[i]-c)%m+m)%m,m),(X%m+m)%m,m))%m;
		}
		printf("%lld\n",c>=mx?c:c+m*((mx-c-1)/m+1));//满足限制
	}
	return 0;
}
```

---

## 作者：ωαηg (赞：16)

### 心路历程

第一眼看此题：

不就是一excrt裸题么！想不到我这个蒟蒻居然能秒切NOI2018 Day2 T1！

第二眼看此题：

什么鬼东西，还要用multiset。没关系，麻烦一点而已。

写完代码后：

轻松通过样例！此题即将被我秒切！

第一次提交：
RE 30 

数组怎么开小了？

第二次提交：WA 40

什么？我再仔细检查一下

第三次提交：WA 40

这。。。怎么可能

第四次提交：TLE 0

第五次提交：WA 70

第六次提交：WA 70

第七次提交：WA 70

第八次提交：WA 70


。。。。。

在下载了数据和玩命地调试之后：

第十三次提交：AC 100

爱我苏联

----
### 进入正题

显然，我们可以发现每次攻击所使用的剑都是固定的。

因此我们可以用一个multiset来维护每一次攻击所使用的剑。（当然巨佬可以手写平衡树）

注意题目里是“不高于巨龙初始生命值”，而不是“低于巨龙初始生命值”，所以我们应当使用upper_bound来查找元素而不是lower_bound。（真 · noi毒瘤）

然后我们来打龙。

如果只有一只龙，假设我们攻击的次数为A，当前使用的剑的攻击力为atk[i],那么我们求解的方程即为：
$$A×atk[i]-a[i]\equiv 0\pmod{p[i]}$$
移项：
$$A×atk[i]\equiv a[i]\pmod{p[i]}$$
变形：
$$atk[i]*A+p[i]*y=a[i]$$
显然，我们可以用扩展欧几里得（exgcd），来求出A的最小值，或证明无解$(a[i]\ mod \gcd(atk[i],p[i])!=0)$。

接下来我们来打很多条龙。

相当于我们要解一个方程组。

那么这就需要用到扩展中国剩余定理（excrt）了。

我们知道，根据扩展欧几里得原理，A的通解为：

A的特解$+i×(p[i]\div \gcd(atk[i],p[i]))(i\in$整数$)$

我们设$q[i]=p[i]÷gcd(atk[i],p[i])$

如果我们当前已经求出了前$k-1$个方程的解$A=x$，我们当前要求第$k$个方程的解。

我们可设$e=\operatorname{lcm}(p[1],p[2]...p[k-1])$

那么根据拓展中国剩余定理原理，第$k$个方程的解为：$x+i×e(i\in$整数$)$

把这个带入上面的式子，就可以得到：

$$(x+i×e)×atk[i]\equiv a[i]\pmod{p[i]}$$

我们可以把它化简为：

$$e*atk[i]*i\equiv a[i]-x×atk[i] \pmod{p[i]}$$

我们继续用扩展欧几里得求出$i$的最小解即可。

一步步这样下去，我们就可以得到整个方程的最优解了。

----

### 一个棘手的东西

为什么WA了？

如果你仔细读题，你会惊讶地发现：数据中并不保证$a[i] \le p[i] $。

这样的话我们的excrt就会萎掉。

但是你又会发现，数据中虽然有$a[i] \le p[i] $的点，但是所有$a[i] \le p[i] $的点都保证$p[i]=1$。

p[i]=1?那不是很好算？所有龙求一下$\left\lceil\dfrac{a[i]}{atk[i]}\right\rceil$然后取个最大值就可以了。

所以，如果遇到$a[i] \le p[i] $的情况，我们特殊处理。

还有一个，要爆long long，请使用快速乘。

----

### 代码

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define x0 xx0//防止和头文件重名
#define y0 yy0
#define int long long
using namespace std;
inline int read(){
    int sum=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)){
        sum=(sum<<1)+(sum<<3)+(c^48);
        c=getchar();
    }
    return sum;
}
int const maxn=1e5+5;
int n,m,x,e,x0,y0,d,a[maxn],p[maxn],atk[maxn],new_atk[maxn];
multiset<int> s;
void exgcd(int a,int b,int &d,int &x0,int &y0){//扩展欧几里得
    if(b==0){
        d=a,x0=1,y0=0;
        return;
    }
    else{
        exgcd(b,a%b,d,x0,y0);
        int t=x0;
        x0=y0,y0=t-a/b*x0;
    }
}
int gcd(int a,int b){//普通的求公约数
    return a%b==0?b:gcd(b,a%b);
}
inline void spsolve(){//特判（我绝对不会告诉你我还看了题解）
    int res=0;
    for(int i=1;i<=n;i++){
        int x=(a[i]+atk[i]-1)/atk[i];//上取整
        res=max(res,x);
    }
    printf("%lld\n",res);
}
inline int ksc(int a,int b,int p){//快速乘
    int res=0;
    while(b>0){
        if(b&1) res=(res+a)%p;
        b>>=1;
        a=(a+a)%p;
    }
    return res;
}
signed main(){
    int T=read();
    while(T--){
        n=read(),m=read();
        for(int i=1;i<=n;i++)
          a[i]=read();
        for(int i=1;i<=n;i++)
          p[i]=read();
        for(int i=1;i<=n;i++)
          new_atk[i]=read();
        s.clear();//记得清空
        for(int i=1;i<=m;i++){
            int aattkk=read();
            s.insert(aattkk);//先把所有初始拥有的剑加入集合
        }
        for(int i=1;i<=n;i++){
            if(a[i]<(*s.begin())){//如果没有攻击力不大于自己的剑，取攻击力最小的
                atk[i]=*s.begin();
                s.erase(s.begin());//这把剑消失了
            }
            else{
                multiset<int>::iterator it=s.upper_bound(a[i]);
                //寻找不大于自己的剑中攻击力最大的
                it--;
                atk[i]=*it;
                s.erase(it);
            }
            s.insert(new_atk[i]);
        }
        for(int i=1;i<=n;i++){//特判
            if(p[i]!=1) break;
            if(i==n){
                spsolve();
                goto wangzhijian;
            }
        }
        //求出第一个方程的解
        exgcd(atk[1],p[1],d,x0,y0);
        if(a[1]%d!=0){//无解
            printf("-1\n");
            goto wangzhijian;
        }
        x=(ksc(x0,a[1]/d,p[1]/d)+p[1]/d)%(p[1]/d);
        //模上剩余类的模数，使其大小控制在模数以内，从而取出剩余类中的最小非负元
        e=p[1]/gcd(atk[1],p[1]);
        for(int i=2;i<=n;i++){
            int A=ksc(e,atk[i],p[i]),B=p[i],C=((a[i]-ksc(x,atk[i],p[i]))%p[i]+p[i])%p[i];
            exgcd(A,B,d,x0,y0);
            if(C%d!=0){
                printf("-1\n");
                goto wangzhijian;
            }
            x0=(ksc(x0,C/d,B/d)+B/d)%(B/d);
            //扩展欧几里得基本操作
            int temp=e;
            e=e/gcd(e,p[i]/gcd(atk[i],p[i]))*(p[i]/gcd(atk[i],p[i]));//更新最小公倍数
            x=((x+ksc(x0,temp,e))%e+e)%e;
            //更新当前的解
        }
        printf("%lld\n",x); 
        //搞定，输出答案
        wangzhijian:;
    }
    return 0;
}
```

----

### 经验与教训

1. 我还是太菜了；

2. noi的题目都很毒瘤；

3. 很多题目看起来是裸题，其实是神题，不要一眼看见就主观臆断；

4. 如果你WA的都是大数据，请不要紧张，赶快去看题解；

5. 在写不出来，心态崩溃时，请不要放弃。你要坚信，希望的曙光，就在不远之处。

---

## 作者：niiick (赞：12)

由题意可得式子$a_i-AT_i*x\mod p_i=0$

并化为$ax\equiv c(\mod b)$的形式

得$AT_i*x_i\equiv a_i(\mod p_i)$
记$gcd=gcd(a,b)$

上式可由**扩展欧几里得**最小非负整数解 $x_i$

以及通解$x_i^{'}=x_i+\frac{b}{gcd}*k,k\in Z$

题目所求答案$x$与上述$x_i$关系为$x=x_i+\frac{b}{gcd}*k,k\in Z$

化为同余方程$x\equiv a(\mod b)$的形式
得$x \equiv x_i(\mod \frac{b}{gcd})$

也就是说每条巨龙都可以由上述转化得到一个同余方程，
最后组成一个同余方程组，
直接**扩展中国剩余定理 EXCRT**求解

不过要特别注意，
**EXCRT所求出的最小非负整数解并不是我们要的答案**

由于每条龙都有固定的剑，
所以对于每条龙**至少要砍几下是已知的**

我们要记录下**每条龙至少要砍的次数中的最大值mi**，
然后EXCRT求出的答案应该是
**通解中大于等于mi且最小的解**

另外由于本蒟蒻实在太蒟，
根本不会什么multiset，
于是手写了一个treap，代码可能略长=_=

还有还有，一定要用**龟速乘**！！！
*******************

```
//niiick
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long lt;

lt read()
{
    lt f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const lt inf=1e12;
const int maxn=500010;
int t,n,m;
lt ai[maxn],pi[maxn],at[maxn],atk[maxn];
lt a[maxn],b[maxn],mi;

struct node
{
    node* ch[2];
    lt v,r,sum,cnt;
    node(lt v) :v(v) {r=rand();sum=cnt=1;ch[0]=ch[1]=NULL;}
    int cmp(lt x){if(x==v)return -1;return x<v?0:1;}
    void update()
    {
        sum=cnt;
        if(ch[0])sum+=ch[0]->sum;
        if(ch[1])sum+=ch[1]->sum;
    }
};
node* rt;

void rotate(node* &p,int d)
{
    node* k=p->ch[d^1];
    p->ch[d^1]=k->ch[d];
    k->ch[d]=p;
    p->update(); k->update();
    p=k;
}

void ins(node* &p,lt x)
{
    if(p==NULL){ p=new node(x); return;}
    if(x==p->v){ ++p->sum; ++p->cnt; return;}
    int d=p->cmp(x);
    ins(p->ch[d],x);
    if(p->ch[d]->r < p->r)rotate(p,d^1);
    p->update();
}

void del(node* &p,lt x)
{
    if(p==NULL) return;
    if(x==p->v)
    {
        if(p->cnt>1){ p->sum--; p->cnt--; return;}
        if(p->ch[0]==NULL){node *k=p; p=p->ch[1]; delete(k); }
        else if(p->ch[1]==NULL){node *k=p; p=p->ch[0]; delete(k); }
        else
        {
            int dd=p->ch[0]->r < p->ch[1]->r ?1 :0;
            rotate(p,dd); del(p->ch[dd],x);
        }
    }
    else if(x < p->v)del(p->ch[0],x);
    else del(p->ch[1],x);
    if(p!=NULL)p->update();
}

lt pre(node* p,lt x)
{
    if(p==NULL)return -inf;
    if(x==p->v) return p->v;
    else if(x<p->v) return pre(p->ch[0],x);
    else return max(p->v,pre(p->ch[1],x));
}

lt qmin(node* p)
{
    if(p->ch[0]) return qmin(p->ch[0]);
    else return p->v;
}

lt mul(lt a,lt b,lt mod)
{
    lt res=0;
    while(b>0)
    {
        if(b&1) res=(res+a)%mod;
        a=(a+a)%mod;
        b>>=1;
    }
    return res;
}

lt exgcd(lt aa,lt bb,lt &x,lt &y)
{
    if(bb==0){x=1;y=0;return aa;}
    lt gcd=exgcd(bb,aa%bb,x,y);
    lt tp=x;
    x=y; y=tp-aa/bb*y;
    return gcd;
}

lt excrt()
{
    lt M=b[1],ans=a[1],x,y;
    for(int i=2;i<=n;i++)
    {
        lt aa=M,bb=b[i],c=(a[i]-ans%bb+bb)%bb;
        lt gcd=exgcd(aa,bb,x,y),bg=bb/gcd;
        if(c%gcd!=0) return -1; 

        x=mul(x,c/gcd,bg);
        ans+=x*M;
        M*=bg;
        ans=(ans%M+M)%M;
    }
    if(ans>=mi) return ans;//注意答案不一定是最小非负整数解
    else return ans+((mi-ans)/M+((mi-ans)%M ? 1 : 0))*M;
}

int main()
{
    t=read();
    while(t--)
    {
        rt=NULL; mi=0;
        n=read();m=read(); int judge=0;
        for(int i=1;i<=n;++i)ai[i]=read();
        for(int i=1;i<=n;++i)pi[i]=read();
        for(int i=1;i<=n;++i)at[i]=read();
        for(int i=1;i<=m;++i)
        {
            lt x=read();
            ins(rt,x);
        }
        for(int i=1;i<=n;++i)//查找对应每条龙的剑
        {
        	atk[i]=pre(rt,ai[i]);
        	if(atk[i]==-inf) atk[i]=qmin(rt); 
        	del(rt,atk[i]); ins(rt,at[i]);
        	mi=max(mi,ai[i]/atk[i]+(ai[i]%atk[i]?1:0));
        	//记录每头龙最少要砍的次数的最大值
        }
        for(int i=1;i<=n;++i)//扩欧求ATK*x≡ai(mod pi)
        {
            lt x,y,c=ai[i];
            lt gcd=exgcd(atk[i],pi[i],x,y),bg=pi[i]/gcd;
            
            if(c%gcd!=0){ judge=1; break;}//无解
            
            x=(mul(x,c/gcd,bg)+bg)%bg;
            a[i]=x; b[i]=bg;
        }
        if(judge)printf("-1\n");
        else printf("%lld\n",excrt());
    }
    return 0;
}
```



---

## 作者：StudyingFather (赞：11)

首先，根据题意，我们可以很容易预处理出面对第 $i$ 条龙时使用的剑，记其伤害值为 $c_i$。

做完了这样一步预处理过后，会发现我们实际上要解若干个形如 $c_ix\equiv a_i \pmod{p_i}$ 这样的同余方程组联立后的最小解。

解这样的方程组，第一个前提条件是 $a_i \leq p_i$，如果不满足这个条件的话，可能会出现龙的血量在 $\bmod\ p_i$ 意义下为零，但实际血量不为零的问题。

不过好在不满足 $a_i \leq p_i$ 的测试数据都满足 $p_i=1$，这意味着这种情况下的答案将直接为 $\max \left \lceil \dfrac{a_i}{c_i} \right \rceil $。

排除这种情况后，我们下面的讨论均在 $a_i \leq p_i$ 的前提下进行。

这个方程组看起来像是可以应用扩展中国剩余定理（EXCRT）的样子。但是 EXCRT 要求 $x$ 前面的系数必须为 $1$。

将方程组两边同时除 $c_i$？不行，模 $p_i$ 意义下 $c_i$ 的逆元不一定存在。

考虑将线性同余方程改写成不定方程的形式。

像 $c_ix\equiv a_i \pmod{p_i}$ 就可以改写为：$c_ix+p_iy=a_i$。

接下来用扩展欧几里得算法来解这个方程组即可。

等等！扩展欧几里得算法解的是形如 $ax+by=\gcd(a,b)$ 形式的不定方程，上面的方程显然不满足这个形式，不能直接用 exgcd 来解。

换个元后稍微推一下：

我们设 $x=\dfrac{a_i}{\gcd(c_i,p_i)}x'$，$y=\dfrac{a_i}{\gcd(c_i,p_i)}y'$。

则原来的方程可以改写为：

$$
c_ix'+p_iy'=\gcd(c_i,p_i)
$$

现在方程变成了标准形式，可以直接解了。

设上面方程的一组解是 $x'=x'_0$，$y'=y'_0$，则原方程与之对应的解为 $x_0=\dfrac{a_i}{\gcd(c_i,p_i)}x'_0$，$y_0=\dfrac{a_i}{\gcd(c_i,p_i)}y'_0$。

这是一个方程组的解，对于多个方程组，我们需要用 ExCRT（本质上还是扩展欧几里得）来合并它们。

简单来说，对于两个线性同余方程：

$$
\begin{cases}
x \equiv a_1 \pmod {p_1}\\
x \equiv a_2 \pmod {p_2}\\
\end{cases}
$$

我们还是把它们改写成不定方程的形式：

$$
\begin{cases}
x = a_1 +p_1y_1\\
x = a_2 +p_2y_2\\
\end{cases}
$$

联立后消去 $x$，用扩展欧几里得解 $y_1,y_2$ 即可合并两个方程。

## 几个特殊情况

1. 恒成立的方程。当 $a_i \equiv c_i \equiv 0 \pmod{p_i}$ 时，方程恒成立。
2. 无解的方程。当 $c_i \equiv 0\pmod{p_i}$ 而 $a_i \not \equiv 0\pmod{p_i}$ 时，方程是无解的。

```cpp
// Problem : P4774 [NOI2018]屠龙勇士
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P4774
// Memory Limit : 500 MB
// Time Limit : 2000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#include <set>
#include <algorithm>
using namespace std;
long long a[100005],p[100005];
long long nswd[100005],c[100005];
multiset<long long> swd;
int n,m;
long long exgcd(long long a,long long b,long long&x,long long&y)
{
 if(b==0)
 {
  x=1,y=0;
  return a;
 }
 long long g=exgcd(b,a%b,x,y);
 int t=x;
 x=y;
 y=t-a/b*y;
 return g;
}
long long mul(long long x,long long y,long long p)
{
 long long ans=0;
 while(y)
 {
  if(y&1)ans=(ans+x)%p;
  x=(x+x)%p;
  y>>=1;
 }
 return ans;
}
namespace sub1//p_i maybe greater than a_i, but guaranteed p_i=1
{
 bool check()
 {
  bool flag=true;
  for(int i=1;i<=n;i++)
   flag&=(p[i]==1);
  return flag;
 }
 void solve()
 {
  long long ans=0;
  for(int i=1;i<=n;i++)
   ans=max(ans,(long long)((a[i]/c[i])+(a[i]%c[i]!=0)));
  cout<<ans<<endl;
 }
}
int main()
{
 int t;
 cin>>t;
 while(t--)
 {
  bool flag=true;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
   cin>>a[i];
  for(int i=1;i<=n;i++)
   cin>>p[i];
  for(int i=1;i<=n;i++)
   cin>>nswd[i];
  swd.clear();
  for(int i=1;i<=m;i++)
  {
   long long x;
   cin>>x;
   swd.insert(x);
  }
  for(int i=1;i<=n;i++)
  {
   auto it=swd.upper_bound(a[i]);
   if(it!=swd.begin())it--;
   c[i]=*it;
   swd.erase(it);
   swd.insert(nswd[i]);
  }
  long long ans=0,z=1;
  if(sub1::check())
  {
   sub1::solve();
   continue;
  }
  for(int i=1;i<=n;i++)
  {
   c[i]%=p[i],a[i]%=p[i];
   if(!c[i]&&a[i])
   {
    cout<<-1<<endl;
    flag=false;break;
   }
   if(!c[i]&&!a[i])continue;
   long long x,y;
   long long g=exgcd(c[i],p[i],x,y);
   if(a[i]%g)
   {
    cout<<-1<<endl;
    flag=false;break;
   }
   p[i]/=g;
   a[i]=mul(a[i]/g,(x%p[i]+p[i])%p[i],p[i]);
   g=exgcd(z,p[i],x,y);
   if((a[i]-ans)%g)
   {
    cout<<-1<<endl;
    flag=false;break;
   }
   z=z/g*p[i];
   ans=(ans+mul(mul(z/p[i],((a[i]-ans)%z+z)%z,z),(x%z+z)%z,z))%z;
  }
  if(flag)cout<<ans<<endl;
 }
 return 0;
}
```

---

## 作者：Hongse_Fox (赞：8)

[题目链接](https://www.luogu.com.cn/problem/P4774)
# 零.前记
一个upper_bound和lower_bound的问题卡了我一天，大家要引以为戒
# 一.大体思路
假设我们砍第i条龙的攻击力为$atk_i$，第i条龙的血量为$a_i$，一次恢复的血量为$p_i$，不难发现题目就是让我们求最小的正整数$x$，使得它同时满足n条下面的等式：
$$atk_i\times x \equiv a_i(\bmod p_i)$$
因此不难想到要用excrt
# 二.实现方法
## 1.$atk_i$
在题目中出现了选择剑的情况

我们可以用一个multiset维护当前所有的剑，按照题目要求再用upper_bound得到所需的剑

实现代码：
```cpp
for(register int i=1;i<=m;i++){//一开始就有的m把剑
	int q=R();s.insert(q);
}
multiset<ll>::iterator it;
for(register int i=1;i<=n;i++){//按照题目要求取满足条件的剑
	it=*s.begin()>a[i] ? s.begin():--s.upper_bound(a[i]);
	atk[i]=*it;s.erase(it);s.insert(c[i]);//即为atk_i，删剑再得新剑
}
```
~~当然也可以手打平衡树维护，不过码量本来就大何必呢~~
## 2.转化一般式
我们得到的式子是:
$$atk_i \times x \equiv a_i(\bmod p_i)$$
可是我们想要的式子是excrt的一般式:$x\equiv na(\bmod nb)$

遇到这样的情况我们可以利用exgcd的通解公式来转化

我们把原来的式子转成:
$$atk_i\times x+p_i\times y=a_i$$
通过exgcd解的x的特解$x_0$

我们可以由通项公式可知：
$$x=x_0+k\times \dfrac{p_i}{gcd(atk_i,p_i)}$$
因此可以得到:
$$x \equiv x_0(\bmod \dfrac {p_i}{gcd(atk_i,p_i)})$$
这样就变得可excrt了

实现代码:
```
for(register int i=1;i<=n;i++){//将同余方程变得可excrt
	ll gc=gcd(atk[i],p[i]);//atk_i和p_i的gcd
	if(a[i]%gc!=0) return -1;
	exgcd(atk[i],p[i],x,y);
	nb[i]=p[i]/gc;
	x=(x%nb[i]+nb[i])%nb[i];//把x0变成正数
	na[i]=ksc(a[i]/gc,x,nb[i]);//x=na(mod nb)
}
```
## 3.excrt
我们已经将题目转化为非常标准的excrt的题目

即有$n$条形如这样的式子:
$$x \equiv na_i(\bmod nb_i)$$
我们要求最小的正整数x

我们考虑把两个式子合并:
$$
\begin{cases}
x \equiv na_1(\bmod nb_1)\\
x \equiv na_2(\bmod nb_2)
\end{cases}
$$
转化成等式为
$$
\begin{cases}
x=na_1-nb_1\times k_1\\
x=na_2-nb_2\times k_2
\end{cases}
$$
因此将两个式子合在一起就是:
$$na_1-nb_1\times k_1=na_2-nb_2\times k_2$$
$$nb_1\times k_1-nb_2\times k_2=na_1-na_2$$
其中$k_1$和$k_2$是要求的未知量，其余都是常数

我们就可以再用一次exgcd把最小的$k_1$求出来，值为$k_0$

我们因此得到了$x$最小值为$x_0=na_1-nb_1\times k_0$

而通解公式应该为:
$$x=x_0+lcm(nb_1,nb_2)$$

因此满足两条式子的式子是:
$$x\equiv x_0 (\bmod lcm(nb_1,nb_2))$$
然后一直这样合并下去就可以得到答案

实现代码:
```
for(register int i=1;i<n;i++){//excrt模板，合并i和i+1条式子 
	ll gc=gcd(nb[i],nb[i+1]);
	if((na[i+1]-na[i])%gc!=0) return -1;//无解的情况 
	exgcd(nb[i]/gc,nb[i+1]/gc,x,y);//跑一遍exgcd 
	ll nna=ksc(x,(na[i+1]-na[i])/gc,nb[i+1]/gc);//新的na 
	ll nmod=lcm(nb[i],nb[i+1]);//新的nb 
	nna=ksc(nna,nb[i],nmod);nna=(nna+na[i])%nmod;
	na[i+1]=nna;nb[i+1]=nmod;
}
```

# 三.特殊情况&细节
## 1.p=1
对于这种情况，不难发现只要把龙砍到非正血就赢定了

因此答案为:
## $Max_{i=1}^n \lceil \frac {a_i}{atk_i} \rceil$

## 2.无解
在任何一次exgcd中，若存在无解的情况，此题无解
## 3.快速乘
本题中存在爆long long的风险，因此要用快速乘

# 四.代码汇总
```
#include<cstdio>
#include<cctype>
#include<set>
using namespace std;
#define ll long long
inline ll max(ll a,ll b){return a>b? a:b;}
inline ll abs(ll a){return a<0? -a:a;}
const int maxn=1e5+5;
inline ll gcd(ll a,ll b){
	if(a%b==0) return b;
	return gcd(b,a%b);
}
inline ll lcm(ll a,ll b){return a/gcd(a,b)*b;}
inline ll R(){
	ll r=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r;
}
int t,n,m,flag;//n:龙 m:剑 
inline void exgcd(ll a,ll b,ll &x,ll &y){//扩展欧几里得 
	if(b==0){x=1;y=0;return ;}
	exgcd(b,a%b,x,y);
	ll t=y;y=x-a/b*y;x=t;//用x1,y1更新x,y,注意弄一个新变量t 
    return ;
}
multiset <ll> s;
ll a[maxn],p[maxn],c[maxn],atk[maxn],ans;//c[i]:i龙死后掉剑攻击力,atk[i]攻击i号龙的剑的攻击力 
ll na[maxn],nb[maxn],x,y;//新的x 同余于na(mod nb) 
inline ll solve1(){
	ans=0;
	for(register int i=1;i<=n;i++){
		ans=max(ans,(a[i]-1)/atk[i]+1);
	}
	return ans;
}
inline ll ksc(ll x,ll y,ll mod){//快速乘 
    x=x%mod,y=y%mod;
    return ((x*y-(ll)(((long double)x*y+0.5)/mod)*mod)%mod+mod)%mod;
}
inline ll work(){
	s.clear();flag=0;
	n=R();m=R();
	for(register int i=1;i<=n;i++) a[i]=R();
	for(register int i=1;i<=n;i++) p[i]=R();
	for(register int i=1;i<=n;i++) c[i]=R();
	for(register int i=1;i<=m;i++){//一开始就有的m把剑
		int q=R();s.insert(q);
	}
	multiset<ll>::iterator it;
	for(register int i=1;i<=n;i++){//按照题目要求取满足条件的剑
		it=*s.begin()>a[i] ? s.begin():--s.upper_bound(a[i]);
		atk[i]=*it;s.erase(it);s.insert(c[i]);//即为atk_i，删剑再得新剑
	}
	for(register int i=1;i<=n;i++) if(p[i]!=1) flag=1;//特殊情况 
	if(!flag) return solve1();
	for(register int i=1;i<=n;i++){//将同余方程变得可excrt
		ll gc=gcd(atk[i],p[i]);//atk_i和p_i的gcd
		if(a[i]%gc!=0) return -1;
		exgcd(atk[i],p[i],x,y);
		nb[i]=p[i]/gc;
		x=(x%nb[i]+nb[i])%nb[i];//把x0变成正数
		na[i]=ksc(a[i]/gc,x,nb[i]);//x=na(mod nb)
	}
	for(register int i=1;i<n;i++){//excrt模板，合并i和i+1条式子 
		ll gc=gcd(nb[i],nb[i+1]);
		if((na[i+1]-na[i])%gc!=0) return -1;//无解的情况 
		exgcd(nb[i]/gc,nb[i+1]/gc,x,y);//跑一遍exgcd 
		ll nna=ksc(x,(na[i+1]-na[i])/gc,nb[i+1]/gc);//新的na 
		ll nmod=lcm(nb[i],nb[i+1]);//新的nb 
		nna=ksc(nna,nb[i],nmod);nna=(nna+na[i])%nmod;
		na[i+1]=nna;nb[i+1]=nmod;
	}
	return na[n];//答案就是最后的na 
} 
int main(){
	t=R();
	for(register int qwq=1;qwq<=t;qwq++){
		printf("%lld\n",work());
	}
	return 0;
}
```
# 五.后记
本题考查了大家对于构造excrt的方法是否熟悉

我们要善于将题目一步步转化为我们可以解的情况

对于可以偷懒的地方，我们可以用一些特判偷懒，也许会因此多a几个点

Finally，谢谢大家

[更好的阅读体验](https://www.luogu.com.cn/blog/HongseFox/solution-p4774)

---

## 作者：梦那边的美好ET (赞：6)

# NOI 2018 屠龙勇士

*(中国剩余定理+exgcd)*

*题目大意：略*

把取出的宝剑攻击力设为T，可得
Ti*x=ai(mod pi)，这显然是ax=c(mod
b)的形式这部分用exgcd求解x的最小正整数解先把a,b,c除以gcd(a,b)，如果c不能整
除gcd(a,b)那么无解。此时a,b互质，用
exgcd求得a的逆元，逆元乘回来gcd(a,b)就是x的最小正整数解，注意可
能爆long long要用龟速乘那么此时求得x是仅仅对于这一个方程的，我们要把它带到excrt的板子中求得x关于所有方程都成立的最小正整数解即可

```cpp
#include<iostream>  
#include<cstdio>
#include<cmath>
#include<cstring>  
#include<algorithm>
#include<set>
using namespace std;
typedef long long ll;
const int maxn = 100005;
int T, n, m;
ll a[maxn], p[maxn], atk[maxn], sword[maxn];
void upd(ll &x, ll y, ll mod) {
    if ((x += y) >= mod) {
        x -= mod;
    }
}
ll mult(ll a, ll b, ll mod) {
    a = (a % mod + mod) % mod;
    b = (b % mod + mod) % mod;
    ll res = 0;
    for (; b; b >>= 1, upd(a, a, mod)) {
        if (b & 1) {
            upd(res, a, mod);
        }
    }
    return res;
}
ll gcd(ll a, ll b) {
    return b ? gcd(b, a % b) : a;
}
void exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}
ll inverse(ll a, ll mod) {
    ll x, y;
    exgcd(a, mod, x, y);
    return (x % mod + mod) % mod;
}
ll excrt(ll *A, ll *B, ll *M, ll &res) {
    res = 0;
    ll lcm = 1;
    for (int i = 1; i <= n; i++) {
        ll a = mult(A[i], lcm, M[i]);
        ll b = B[i] - mult(A[i], res, M[i]);
        ll d = gcd(a, M[i]);
        if (b % d != 0) {
            res = -1;
            return 0;
        }
        ll x = mult(b / d, inverse(a / d, M[i] / d), M[i] / d);
        res += lcm * x, lcm *= M[i] / d;
    }
    res = (res % lcm + lcm) % lcm;
    return lcm;
}
int main() {
    for (scanf("%d", &T); T--; ) {
        multiset<ll> S;
        scanf("%d %d", &n, &m);
        for (int i = 1; i <= n; i++) {
            scanf("%lld", a + i);
        }
        for (int i = 1; i <= n; i++) {
            scanf("%lld", p + i);
        }
        for (int i = 1; i <= n; i++) {
            scanf("%lld", atk + i);
        }
        for (int i = 1; i <= m; i++) {
            ll x;
            scanf("%lld", &x);
            S.insert(x);
        }
        ll mx = 0;
        for (int i = 1; i <= n; i++) {
            multiset<ll>::iterator it = S.upper_bound(a[i]);
            if (it != S.begin()) {
                it--;
            }
            sword[i] = (*it), S.erase(it), S.insert(atk[i]);
            mx = max(mx, (a[i] + sword[i] - 1) / sword[i]);
        }
        ll x, lcm = excrt(sword, a, p, x);
        if (x != -1 && x < mx) {
            x += lcm * ((mx - x + lcm - 1) / lcm);
        }
        printf("%lld\n", x);
    }
    return 0;
}
```

---

## 作者：Space_Gold_Trash (赞：4)

## 前置知识

平衡树(或者```multiset<long long>```)

扩展中国剩余定理

扩展欧几里得

## 开始

我们对于每一条龙,都要杀,并且全部按顺序杀

所以对于一条龙用的剑可以O(nlogn)平衡树搞出来(~~STL不香??~~)

那么我们便可以列举出一堆方程组

$\begin{cases} A_1x\equiv a_1\pmod{m_1} \\ A_2x\equiv a_2\pmod{m_2} \\ \dots \\ A_nx\equiv a_n\pmod{m_n}\end{cases} $

是不是有点似曾相识?

这就是扩展中国剩余定理!!!

但是他带了系数,咋办?

我们得把左边$A_i$弄无

那么

$\because A_ix \equiv a_i \pmod{m_n}$

$\therefore A_ix=a_i-m_nk$

$\therefore A_ix+m_nk=a_i$

这就是扩展欧拉定理模板呗

如果无解输出 ``-1``

我们搞出$x,k$的值

定义
$ \begin{cases} lcm_1=m_1 \\ lcm_i=\operatorname lcm(lcm_{i-1},m_i) \end{cases} $

很显然
$ x $ 可以加上或减去任意 $ lcm_{i-1} $

于是有了$ x\equiv x_0+k'lcm_{i-1},k'\in Z $

即$x\equiv x_0 \pmod{lcm_{i-1}} $

于是就可以扩展中国剩余定理搞出来了

贴上代码

```
#include<bits/stdc++.h>
#define N 100011
#define ll long long
using namespace std;
multiset<ll>q;
int n,m;
inline ll mul(ll a,ll b,ll mod){
	if(b<0)a=-a,b=-b;
	ll ans(0);
	while(!!b){
		if(b&1)ans=(ans+a)%mod;
		a=(a<<1)%mod;
		b>>=1;
	}
	return (ans%mod+mod)%mod;
}
inline void exgcd(ll a,ll b,ll &x,ll &y,ll &d){
	if(!b){d=a;x=1;y=0;return;}
	exgcd(b,a%b,y,x,d);
	y-=a/b*x;
}
ll a[N],p[N],c[N];
inline void init( ){
	q.clear( );
	scanf("%d%d",&n,&m);
	int i;
	int op(0);
	ll g;
	for(i=1;i<=n;++i)
	scanf("%lld",&a[i]);
	for(i=1;i<=n;++i)scanf("%lld",&p[i]);
	for(i=1;i<=n;++i)
	scanf("%lld",&c[i]);
	while(m--){scanf("%lld",&g);q.insert(g);}
}
inline multiset<ll>::iterator find(ll k){
	multiset<ll>::iterator op;
	op=q.upper_bound(k);
	if(op!=q.begin( ))--op;
	return op;
}
inline ll gcd(ll a,ll b){
	return !b?a:gcd(b,a%b);
}
inline ll ceil(ll a,ll b){
	return (a+b-1)/b;
}
inline ll maxx(ll a,ll b){
	return a>b?a:b;
}
ll X,lcm;
inline void work( ){
	init( );
	int i;
	multiset<ll>::iterator k;
	ll x,y,d,QWQ(0);
	ll P,A;
	for(i=1;i<=n;++i){
		k=find(a[i]);
		exgcd(*k,p[i],x,y,d);
		if(a[i]%d!=0){puts("-1");return;}
		QWQ=maxx(QWQ,ceil(a[i],*k));
		A=mul(x,a[i]/d,p[i]/d);
		P=p[i]/d;
		if(i==1){
			lcm=P;
			X=A;
		}else{
			exgcd(lcm,P,x,y,d);
			if((A-X)%d!=0){puts("-1");return;}
			x=mul((A-X)/d,x,P/d);
			ll qwq(lcm);
			lcm=lcm/d*P;
			X=(X+(mul(x,qwq,lcm)%lcm+lcm)%lcm)%lcm;
		}
		q.erase(k);
		q.insert(c[i]);
	}
	if(!X)X=QWQ;
	printf("%lld\n",X);
}
int main( ){
	int t;
//	freopen("dragon2.in","r",stdin);
//	freopen("ans.out","w",stdout);
	scanf("%d",&t);
	while(t--)work( );
} 
```

---

## 作者：Great_Influence (赞：4)

扩展欧几里得。

首先，可以先预处理出杀每条龙时所用的剑。设为$q_i$。

那么，我们要求的其实是这个东西:

$$\min x(xq_i\equiv a_i\pmod{p_i},x\ge\lceil\frac{a_i}{q_i}\rceil)$$

后半部分可以直接通过$Chkmax$来解决。考虑求解前半部分。

通过简单的扩展欧几里得定理，可以对每头龙解出$x\equiv x_i\pmod{p_i}$。

那么，我们就得到了$n$个线形方程组。我们需要将它们全部合并。

可以选择使用$exCRT$来解决，但是其实$exGCD$就可以合并了。

具体方法:

设要合并的两个方程为:

$$x=X+k_1P$$

$$x=x_i+k_2p_i$$

那么，相减并移项得:

$$Pk_1-p_ik_2=x_i-X$$

通过$exGCD$解出$k_1=k_0+z*\displaystyle\frac{p_i}{gcd(P,p_i)}$。

那么回代得

$$x=X+k_0P+z*\displaystyle\frac{Pp_i}{gcd(P,p_i)}$$

即

$$x=X+k_0P+z lcm(P,p_i)$$

其中$z$为任意整数。

那么，我们就成功将两个同余方程组合并成了一个。

时间复杂度为$O(n\log n)$,但是大部分情况都跑不满。注意判断出各种无解和爆$long\ long$的情况。

代码:
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmax(a,b) a=a>b?a:b
template<typename T>inline void read(T &x)
{
	T f=1;x=0;char c;
	for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+(c^48);
	x*=f;
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
	freopen("dragon.in","r",stdin);
	freopen("dragon.out","w",stdout);
#endif
}

const int MAXN=1e5+7;

static int n,m;

typedef long long uint64;

static uint64 a[MAXN],p[MAXN],w[MAXN],q[MAXN];

multiset<uint64>G;

inline void init()
{
	read(n);read(m);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n)read(p[i]);
	Rep(i,1,n)read(w[i]);
	static uint64 x;
	G.clear();
	Rep(i,1,m)read(x),G.insert(x);
	Rep(i,1,n)
	{
		if(*G.begin()>a[i])q[i]=*G.begin(),G.erase(G.begin());
		else q[i]=*(--G.upper_bound(a[i])),G.erase(G.lower_bound(q[i]));
		G.insert(w[i]);
	}
}

inline uint64 gcd(uint64 a,uint64 b){return b?gcd(b,a%b):a;}

inline void exGCD(uint64 a,uint64 b,uint64 &x,uint64 &y)
{
	if(!b){x=1,y=0;return;}
	exGCD(b,a%b,x,y);
	swap(x,y),y-=(a/b)*x;
}

static uint64 ans,mx;

inline uint64 ad(uint64 a,uint64 b,uint64 mod){return (a+=b)>=mod?a-mod:a;}

inline uint64 mul(uint64 a,uint64 b,uint64 mod)
{
	uint64 sm;b%=mod;b=ad(b,mod,mod);a%=mod;
	for(sm=0;b;b>>=1,a=ad(a,a,mod))if(b&1)
		sm=ad(sm,a,mod);
	return sm;
}

inline void solve()
{
	static uint64 c,x,y,P,lcm;mx=0;
	Rep(i,1,n)
	{
		c=gcd(q[i],p[i]);
		if(a[i]%c)return (void)puts("-1");
		p[i]/=c;
		exGCD(q[i]/c,p[i],x,y);
		x=x%p[i]+p[i];x%=p[i];
		w[i]=mul(x,a[i]/c,p[i]);
		Chkmax(mx,(a[i]+q[i]-1)/q[i]);
	}
	P=p[1];ans=w[1];
	Rep(i,2,n)
	{
		c=gcd(P,p[i]);
		if((w[i]-ans)%c)return (void)puts("-1");
		p[i]/=c;
		exGCD(P/c,p[i],x,y);
		x=x%p[i]+p[i];x%=p[i];
		x=mul(x,(w[i]-ans)/c%p[i],p[i]);
		x=x%p[i]+p[i];x%=p[i];
		lcm=P*p[i];
		ans=(mul(x,P,lcm)+ans)%lcm;
		P=lcm;
	}
	if(ans<mx)ans+=P*((mx-ans+P-1)/P);
	printf("%lld\n",ans);
}

int main()
{
	file();
	static int _;
	read(_);
	while(_--)
	init(),
	solve();
	return 0;
}
```

---

## 作者：llmmkk (赞：3)

##### 链接：

[P4774](https://www.luogu.com.cn/problem/P4774)

---

##### 前言：

交了18遍最后发现是多组数据没清空/ll

---

##### 题意：

其实就是个不定方程组求最小非负整数解。

---
##### 分析过程：

首先发现根据题目描述的选择剑的方式，每条龙对应的剑都是固定的，有查询前驱，后继（在该数不存在前驱时，最小值即为后继），和插入，删除操作，所以想到平衡树维护每条龙的剑的攻击力，记为 `b[i]`。建议使用非旋 treap，非常之好写。



根据题目描述，`a[i]` 为每条龙生命值，`p[i]` 为每条龙回复量。发现能够击杀这条龙的条件可以列成一个方程：

$xb[i]-yp[i]=a[i]$

$x$ 为攻击次数，$y$ 为回复次数，转化为同余方程的形式为：

$xb[i]\equiv a[i]\pmod {p[i]}$

所以题目就被我们转化成了一个一元 $n$ 次的不定方程组：

$\begin{cases}xb[1]\equiv a[1]\pmod {p[1]} \\ xb[2]\equiv a[2]\pmod {p[2]}\\ \cdots\\ xb[n]\equiv a[n]\pmod {p[n]}\end{cases}$

求 $x$ 的最小非负整数解。

这样的形式虽然不满足 CRT 和 exCRT 的形式，但我们可以从exCRT的思想得到启发。我们记录下前 $m-1$ 个方程的通解 $x=x_0+t*M$，也就是说我们已知 $x_0$ 和 $M$。

对于第 $m$ 个方程 $xb[m]-yp[m]=a[m]$ ，将上述 $x$ 带入，有

$(x_0+t*M)b[i]-yp[i]=a[i]$  

即 $x_0b[i]+t*M*b[i]-yp[i]=a[i]$   

由于 $x_0,b[i],M,p[i],a[i]$ 全部都已知，所以化为

$t*Mb[i]-y*p[i]=a[i]-x_0b[i]$

设 $ta=Mb[i],tb=p[i],tc=a[i]-x_0b[i]$

就有 $t*ta-y*tb=tc$

可以用扩展欧几里得求解 $t=t_0+q*\dfrac{tb}{\gcd(ta,tb)}$。

如果 $t$ 无解那显然此题就无解。

为了这里看起来简洁一些，设 $r=\dfrac{tb}{\gcd(ta,tb)}$。

则 $t=t_0+q*r$

发现我们不停带入化简求出了前 $m-1$ 个方程的解 $x=x_0+t*M$  中 $t$的范围，所以再将 $t$ 带入该式，有：

$x=x_0+(t_0+q*r)*M$  

即 $x=x_0+t_0*M+q*r*M$

还看不出来吗？那就再括起来：

$x=(x_0+t_0*M)+q*(r*M)$

这个写法是不是和 $x=x_0+t*M$ 有点像？没错，这就是合并了两个方程之后的解。

发现我们完全通过柿子和推导得出了合并方程的方法，只需要做一次扩展欧几里得。那么对于第一个方程怎么办呢，我们当然可以特殊处理第一个方程，求出它的解。还有另一种巧妙的办法，就是将 $x$ 一开始的取值范围设为  $\mathbb{Z}$，只需将 $M$ 设为 $1$，即 $x=x_0+t*1$  ,这里的 $x_0$ 对结果~~应该~~没有影响，我测试了几个不同的初值都能过，这样就不用单独处理第一个方程了。



**坑1：**

注意我们转化方程 $xb[i]-yp[i]=a[i]$ 的过程是有缺陷的，根据题意，这里的 攻击次数 $x$ 和回复次数 $y$ 显然都应该是非负数而且有一定限制，翻译成人话就是说你砍出来的伤害至少要大于这条龙的血量。再翻译成数学语言就是：

$\forall i\ (i\in \left [ 1,n \right ]),xb[i]\geq a[i]$

转化不等式：$x\geq \dfrac{a[i]}{b[i]}$

所以用`double`类型记录最大的 $\dfrac{a[i]}{b[i]}$，把最后的解处理一下即可。

**坑2：**

因为此题数据范围较大，`long long` 会溢出，所以需要在各种地方取模并使用龟速乘防止溢出。由于我们记录的一直是通解，所以 $x_0$ 的值并不要求最小，只是为了避免溢出所以让 $x_0$ 每次对 $M$ 取模。


**坑3：**

~~就是我亲身踩了17次的~~注意平衡树每次会有剩下的剑还在树中，注意清空。

---

##### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e5+5;

int read(){//快读
	int p=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
	return p*f;
}

//这里我写的是平衡树，也可以用STL
//treap-------------------
#define v(x) kin[x].v
#define lc(x) kin[x].lc
#define rc(x) kin[x].rc
#define siz(x) kin[x].siz
#define rnd(x) kin[x].rnd
struct k{
	int v,lc,rc,siz,rnd;
}kin[2*maxn];
int rt,cnt;
int newnode(int x){
	rnd(++cnt)=rand();
	siz(cnt)=1;
	v(cnt)=x;
	lc(cnt)=rc(cnt)=0;
	return cnt;
}
void pushup(int x){
	siz(x)=siz(lc(x))+siz(rc(x))+1;
}
int merge(int x,int y){
	if(!x||!y)return x|y;
	if(rnd(x)<rnd(y)){
		rc(x)=merge(rc(x),y);
		pushup(x);
		return x;
	}
	else{
		lc(y)=merge(x,lc(y));
		pushup(y);
		return y;	
	}
}
void split(int p,int k,int &x,int &y){
	if(!p){x=y=0;return ;}
	if(v(p)<=k){
		x=p;
		split(rc(p),k,rc(p),y);
		pushup(p);
	}
	else{
		y=p;
		split(lc(p),k,x,lc(y));
		pushup(p);
	}
}
void insert(int v){
	int x,y,z;
	x=y=z=0;
	split(rt,v,x,z);
	y=newnode(v);
	rt=merge(merge(x,y),z);
}
void del(int v){
	int x,y,z;
	x=y=z=0;
	split(rt,v,x,z);
	split(x,v-1,x,y);
	y=merge(lc(y),rc(y));
	rt=merge(merge(x,y),z);	
}
int getb(int a){//根据题意，有前驱求前驱，没有前驱求后继
	int x,y;
	x=y=0;
	split(rt,a,x,y);
	if(x){
		int now=x;
		while(rc(now))now=rc(now);
		now=v(now);
		rt=merge(x,y);
		del(now);
		return now;		
	}
	else{
		int now=y;
		while(lc(now))now=lc(now);
		now=v(now);
		rt=merge(x,y);
		del(now);
		return now;
	}
}
//treap----------------------------

int exgcd(int a,int b,int &x,int &y){//扩展欧几里得
	if(a<b)return exgcd(b,a,y,x);
	if(a%b==0){
		x=0;y=1;
		return b;
	}
	else{
		int tx,ty;
		int d=exgcd(b,a%b,tx,ty);
		x=ty;
		y=tx-a/b*ty;
		return d;
	}
}
int gsc(int ta,int tb,int mod){//龟速乘
	if(!ta||!tb)return 0;
	int ans=0,f=1;
	if(ta<0)ta=-ta,f*=-1;
	if(tb<0)tb=-tb,f*=-1;
	ta%=mod;
	tb%=mod;
	while(tb){
		if(tb&1)ans=(ans+ta)%mod;
		ta=(ta+ta)%mod;
		tb>>=1;
	}
	return ans*f;
}
int T;
int n,m;
int a[maxn],p[maxn],q[maxn],b[maxn];
int x0,M;
signed main(){
	T=read();
	while(T--){
		cnt=0,rt=0;//清空平衡树
		n=read(),m=read();
		for(int i=1;i<=n;i++)
			a[i]=read();
		for(int i=1;i<=n;i++)
			p[i]=read();	
		for(int i=1;i<=n;i++)
			q[i]=read();
		for(int i=1;i<=m;i++){
			int temp=read();
			insert(temp);
		}
		for(int i=1;i<=n;i++){
			b[i]=getb(a[i]);
			insert(q[i]);
		}//预处理每条龙的剑
		x0=0,M=1;
		int ta,tb,tc,t,y,d,flag=1;
		double mx=0;
		for(int i=1;i<=n;i++){
			ta=M*b[i],tb=p[i],tc=a[i]-x0*b[i];
			d=exgcd(ta,tb,t,y);
			if(tc%d!=0){//判断无解
				printf("-1\n");
				flag=0;
				break;
			}
			ta/=d,tb/=d,tc/=d;
			t=(t%tb+tb)%tb;
			x0+=gsc(gsc(tc,t,M*tb),M,M*tb);
			M*=tb;
			x0=(x0%M+M)%M;//这里多次取模主要为了防止溢出
			if(double(a[i])/b[i]>mx)
				mx=double(a[i])/b[i];
		}
		while(x0<mx)x0+=M;//最后处理坑1
		if(flag)
			printf("%lld\n",x0);
	}
	return 0;
}
```


---

##### 题外话：

~~做完感觉自己就是屠龙勇士，另外感觉这道题很好的揭示了平衡树这一工具人的作用~~



---

## 作者：Kinesis (赞：1)

### 【NOI2018】屠龙勇士

看到很多大佬都是把带系数同余方程转化成一般式再合并方程组啊、、鉴于百花齐放的精神，放一个直接合并模方程组的做法。

关于第$i$局拿什么剑其他大佬讲的比较清楚了，这里不讲细节。预处理第$i$局会使用的剑的攻击力$Atk[i]$,解决模线性方程：

$\left\{\begin{aligned}
Atk[1]x & \equiv a[1]\left(\bmod n[1]\right) \\
Atk[1]x & \equiv a[2]\left(\bmod n[2]\right) \\
& \vdots \\
Atk[1]x & \equiv a[k]\left(\bmod n[k]\right)
\end{aligned}\right.$

考虑两个方程的合并：

$Atk[1]x = a[1] + p*n[1]\Rightarrow x = \frac{a[1]+p*n[1]}{Atk[1]}$
$Atk[2]x = a[2] + q*n[2]\Rightarrow x = \frac{a[2]+q*n[2]}{Atk[2]}$

即解关于$(q,p)$的不定方程$n[1]*Atk[2]*p - n[2]*Atk[1]*q = a[2]*Atk[1] - a[1]*Atk[2]$

令$a = n[1]*Atk[2],b = - n[2]*Atk[1],c = a[2]*Atk[1] - a[1]*Atk[2]$

$ap+bq = c$解得一组特解$(q',p')$，（当然前提$d=gcd(a,b)|c$）

将$p'$带回原式，$Atk[1]x = a[1] + p'* n[1]$，由于$p'$的通解最小正间距为$b/d$，故$Atk[1]x$最小正间距为$n[1]*b/d。$

得$Atk[1]x\equiv a[1]+p'*n[1](\%(n[1]*b/d))$

若干式子合并n-1次即可、、

最后得到$Atk[1]x\equiv a[1](\%n[1])$（程序中习惯将$j\in[2,n]$的式子与式子1合并，结果存在$a[1]$与$n[1]$），同余方程转化为$Atk[1]*x+n[1]*y = a[1]$,套一个exgcd求一个非负特解（严格意义上是$x\geq mi,mi = max(\left\lceil \frac{a[1]}{Atk[1]}\right\rceil$,但数据能水过）、、

对了，还有特判、、单看一条方程，这道题在取模前先想清楚条件，$Atk[1]*x - k*n[1] = a[1]\Rightarrow Atk[1] * x\equiv a[1](\%n[1])$，如果不保证$a[1]\leq n[1],$则会出现攻击x次后血条并无变非正，而存在恢复至0的情况，故数据得保证$a[1]\leq n[1]$。好在$a[1]>n[1]$的情况的数据都有$n[1]=1$,则答案为$x = max(\left\lceil \frac{a[1]}{Atk[1]}\right\rceil)$

最后放个代码、、

```cpp
//code sourced from kinesis
#include<bits/stdc++.h>
using namespace std;

#define _REP(i,a,b) for(int i = (a) ; i >= (int)(b) ; --i )
#define REP(i,a,b) for(int i = (a) ; i <= (int)(b) ; ++i )
#define UREP(i,u) for(int i = p[(u)] ; i + 1 ; i = edge[i].next)
//iterator: for(int u:x),x is container
#define x(p) (p).first
#define y(p) (p).second
#define pii pair<int,int>
#define mp(x,y) make_pair((x), (y))
#define ll long long
#define ull unsigned long long
const int inf = 0x3f3f3f3f;
const ll inff = 0x3f3f3f3f3f3f3f3f;
const int mod = 998244353;
const double eps = 1e-9;
#define mem(x,v) memset((x), (v), sizeof (x))
#define ri1(x) scanf("%d", &(x))
#define ri2(x,y) scanf("%d%d", &(x), &(y))
#define ri3(x,y,z) scanf("%d%d%d", &(x), &(y), &(z))
#define ri4(a,b,c,d) scanf("%d%d%d%d", &(a), &(b), &(c), &(d))
#define pi1(a) printf("%d\n", (a))
#define pi2(a,b) printf("%d%d\n", (a), (b))
//#define Debug
#ifdef Debug
#endif // debug
const int maxn = 1e5 + 5;

namespace ExCRT
{
    __int128 ex_gcd(__int128 a, __int128 b, __int128& x, __int128& y)
    {
        if (b == 0) {
            x = 1;
            y = 0;
            return a;
        }
        __int128 d = ex_gcd(b, a % b, x, y);
        __int128 temp = x;
        x = y;
        y = temp - a / b * y;
        return d;
    }
    bool liEu(__int128 a, __int128 b, __int128 c, __int128& x, __int128& y)
    {
        __int128 d = ex_gcd(a, b, x, y);
        if (c % d != 0) return 0;
        __int128 k = c / d;
        x *= k;//得到组特解，求最小非负整数，则$x = (x % (b / d) + b / d) % (b / d)$
        x = (x % (b / d) + b / d) % (b / d);
        y *= k;
        return 1;
    }
    __int128 a[maxn],n[maxn],N,Atk[maxn];
    __int128 ex_CRT()
    {
        REP(i,2,N){
            __int128 x,y;
            if(!liEu(n[1]*Atk[i],-(n[i]*Atk[1]),Atk[1]*a[i]-Atk[i]*a[1],x,y)) return -1;
            __int128 lcm = n[1] * n[i] * Atk[1] / __gcd(n[1] * Atk[i],n[i] * Atk[1]);
            (a[1] = a[1] + n[1] * x) %= lcm;
            n[1] = lcm;
        }
        __int128 x,y;
        if(!liEu(Atk[1],n[1],a[1],x,y)) return -1;
        return x;
    }
}

__int128 read()
{
   __int128 X=0,w=0; char ch=0;
   while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
   while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
   return w?-X:X;
}

void print(__int128 x)
{
   if(x<0){putchar('-');x=-x;}
   if(x>9) print(x/10);
   putchar(x%10+'0');
}

__int128 mi;
ll wp[maxn];
multiset<ll> S;

int main()
{
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);//cf needn't delete this
    #endif // ONLINE_JUDGE
    int T;
    ri1(T);
    while(T--){
        S.clear();
        mi = 0;//mi是最小需攻击的次数
        int N,m,flag = 0;
        ri2(N,m);
        ExCRT::N = N;
        REP(i,1,N) ExCRT::a[i] = read();
        REP(i,1,N) ExCRT::n[i] = read(),flag |= (ExCRT::n[i] != 1);
        REP(i,1,N) wp[i] = read();
        ll x;
        REP(i,1,m) scanf("%lld",&x),S.insert(x);
        REP(i,1,N){//预处理Atk[]
            multiset<ll>::iterator it = S.upper_bound(ExCRT::a[i]);
            if(it!=S.begin()) it--;
            ExCRT::Atk[i] = *it;
            S.erase(it);
            mi = max(mi,ExCRT::a[i] / ExCRT::Atk[i] + (ExCRT::a[i] % ExCRT::Atk[i] > 0));
            S.insert(wp[i]);
        }
        if(!flag){print(mi),printf("\n");continue;}
        REP(i,1,N) if(ExCRT::a[i]==ExCRT::n[i]) ExCRT::Atk[i] = 1,ExCRT::a[i] = 0,ExCRT::n[i] = 1;
        __int128 ans = ExCRT::ex_CRT();
        print(ans),printf("\n");
    }
    return 0;
}
```

部分思路参考洛谷大佬，在此%%%

---

## 作者：suxxsfe (赞：1)

[可以到我的blog中阅读](https://www.cnblogs.com/suxxsfe/p/12683280.html)  

[P4774 [NOI2018]屠龙勇士](https://www.luogu.com.cn/problem/P4774)  
**exCRT**  

# 题目描述  
小 D 最近在网上发现了一款小游戏。游戏的规则如下：  

- 游戏的目标是按照编号 $1 \rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$，直至生命值非负。只有在攻击结束后且当生命值**恰好**为 $0$ 时它才会死去。  

- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格， 于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：  

- 每次面对巨龙时，机器人会选择当前拥有的，攻击力**不高于**巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择**攻击力最低**的一把剑作为武器。  

- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少$x \times ATK$。  

- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$生命值。若在使用恢复能力前或某一次恢复后其生命值为$0$，则巨龙死亡，玩家通过本关。  

那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。  
小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？  

当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。  

多测，$T\le 5$  
$n,m\le 10^5,\operatorname{lcm}(p_i)\le 10^{12},a_i\le 10^{12},a_i\le p_i,\text{攻击力}\le 10^6$  
但有两个测试点，$p_i=1$ ，不保证 $a_i\le p_i$  

--------------  

将题目分成多个步骤去做  

# 计算每次选择的剑的攻击力  

很显然，每次用的剑是确定的  
我直接用的线段树，所以常数上可能有些差  
因为攻击力是很小的，所以直接让攻击力当线段树叶子节点的下标  
然后每个区间维护当前最小和最大的，**有对应的剑**的攻击力  
也就是说，在处理叶子节点的时候，如果当前攻击力没有对应的剑，那么此节点的最小攻击力设为极大值，最大攻击力设为极小值  

查询时，如果能查到$[1,\min(a_i,10^6)]$中最大的攻击力的剑，那肯定就选这个剑  
如果不能，那么就查询$[1,10^6]$中的最小攻击力的剑  
然后单点修改，用去的剑的对应攻击力减一，得到的剑的攻击力加一  

# 整理同余方程  

设我们对每次攻击选出的剑的攻击力分别是$ATK_i$  
则根据题目中杀死龙的条件，并将这$n$个式子都放在$\bmod p_i$的意义下构成同余方程：  

$$x\cdot ATK_i-a_i=kp_i$$  
$$x\cdot ATK_i-a_i\equiv 0\pmod {p_i}$$
$$x\cdot ATK_i\equiv a_i\pmod{p_i}$$  

如果我们想用 exCRT 去解决这个同余方程组，$x$的系数要为 $1$  
由 exgcd 的原理，我们可以找到$x',y'\in Z$，使得：  

$$x'\cdot ATK_i+y'p_i=\gcd(ATK_i,p_i)$$  

那么可以以此做变形  

$$\frac{x'\cdot ATK_i}{\gcd(ATK_i,p_i)}+\frac{y'\cdot p_i}{\gcd(ATK_i,p_i)}=1$$  

此时，已经可以用 exgcd 求得$x',y'$的值  

$$\frac{x'\cdot ATK_i}{\gcd(ATK_i,p_i)}\equiv 1\pmod{\frac{p_i}{\gcd(ATK_i,p_i)}}$$  

那么，则可以得知：  

$$x\equiv a_i\frac{x'}{\gcd(ATK_i,p_i)}\pmod {\frac{p_i}{\gcd(ATK_i,p_i)}}$$  

相当于求了个逆元  
以上，也可以作为一个用 exgcd 求$ax+by=c$的一组解的过程，在这里其实就是$x\cdot ATK_i+y\cdot p_i=a_i$  
很显然，这要求$\gcd(ATK_i,p_i)\mid a_i$，对于上一行那个式子也就是$\gcd(a,b)\mid c$，这是有解的充要条件（斐蜀定理）  

那么此时系数就化为 $1$ 了  
要注意在此过程中要让$p_i=\dfrac{p_i}{\gcd(ATK_i,p_i)}$

# exCRT 求解  

[看这里，应该比较详细了](https://www.cnblogs.com/suxxsfe/p/12527101.html)  

# 特判  

个人感觉特判在数论题里也比较恶心  
~~而且你特判完一个地方以后永远不知道有没有其它需要特判的地方~~  

- $p_i=1$，这两个点要特判掉，每次恢复一个生命，那么只要将他打到生命为非正就行了，答案是：$\max(\lceil\dfrac{a_i}{ATK_i}\rceil)$  
- $p_i=a_i$，直接解同余方程结果是$0$，不对  
初始生命和恢复生命相等，那么应该把它打到生命为$ka_i$就行，$k$为非正整数，具体用$\gcd$实现，见 `work_p_a` 函数  
- 如果攻击力$\bmod p_i$以后为 $0$，则无解  
特别的，如果此时初始生命就等于恢复能力$(a_i=p_i)$，那么显然有解，且此时 $x$ 可以为任意大于 $0$ 的整数（可以理解为随便打一下就行了），此时这个方程就没用了，要标记一下，exCRT 的时候跳过  

# 细节

- 用快速乘  
- 线段树一定要把$a_i$和$10^6$取$\min$  
~~我因为这个RE了~~  

------------  

$\texttt{code.}$  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline LL read(){
	register LL x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
struct tr{
	tr *ls,*rs;
	int maxatk,minatk;
}dizhi[2000006],*root=&dizhi[0];
int tot;
int sword[1000006],extra[100006];
LL a[100006],p[100006],ATK[100006];
int no[100006];//标记一个方程是否有用 
inline void pushup(tr *tree){
	tree->maxatk=max(tree->ls->maxatk,tree->rs->maxatk);
	tree->minatk=min(tree->ls->minatk,tree->rs->minatk);
}
void build(tr *tree,int l,int r){
	if(l==r){
		if(sword[l]) tree->maxatk=tree->minatk=l;
		else tree->maxatk=0,tree->minatk=1e9;
		return;
	}
	tree->ls=&dizhi[++tot];tree->rs=&dizhi[++tot];
	int mid=(l+r)>>1;
	build(tree->ls,l,mid);build(tree->rs,mid+1,r);
	pushup(tree);
}
void change(tr *tree,int l,int r,int pos){
//		std::printf("change : %d %d\n",l,r);
	if(l==r){
//			std::puts("return !");
		if(sword[l]) tree->maxatk=tree->minatk=l;
		else tree->maxatk=0,tree->minatk=1e9;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid) change(tree->ls,l,mid,pos);
	else change(tree->rs,mid+1,r,pos);
	pushup(tree);
}
int findmax(tr *tree,int l,int r,int ql,int qr){
//		std::printf("find_max : %d %d %d %d\n",l,r,ql,qr);
	if(ql<=l&&r<=qr) return tree->maxatk;
	int mid=(l+r)>>1;
	if(qr<=mid) return findmax(tree->ls,l,mid,ql,qr);
	if(ql>mid) return findmax(tree->rs,mid+1,r,ql,qr);
	return max(findmax(tree->ls,l,mid,ql,qr),findmax(tree->rs,mid+1,r,ql,qr));
}
int findmin(tr *tree,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return tree->minatk;
	int mid=(l+r)>>1;
	if(qr<=mid) return findmin(tree->ls,l,mid,ql,qr);
	if(ql>mid) return findmin(tree->rs,mid+1,r,ql,qr);
	return min(findmin(tree->ls,l,mid,ql,qr),findmin(tree->rs,mid+1,r,ql,qr));
}
inline LL mul(LL a,LL b,LL p){
	reg LL ans=0;
	while(b){
		if(b&1) ans=(ans+a)%p;
		b>>=1;a=(a+a)%p;
	}
	return ans;
}
LL exgcd(LL a,LL b,LL &x,LL &y){
	if(!b) return x=1,y=0,a;
	LL gcd=exgcd(b,a%b,x,y);
	LL xx=x;x=y;
	y=xx-(a/b)*y;
	return gcd;
}
inline void get_atk(int n){//calc ATK
//		std::puts("begin to get_atk");
	build(root,1,1000000);
	for(reg int i=1;i<=n;i++){
		if(a[i]==1) ATK[i]=findmin(root,1,1000000,1,1000000);
		else{
			ATK[i]=findmax(root,1,1000000,1,std::min(a[i],1000000ll));
			if(!ATK[i]) ATK[i]=findmin(root,1,1000000,1,1000000);
		}
		sword[ATK[i]]--;change(root,1,1000000,ATK[i]);
		sword[extra[i]]++;change(root,1,1000000,extra[i]);
	}
//		std::printf("ATK :  ");for(reg int i=1;i<=n;i++) std::printf("%lld ",ATK[i]);EN;
//		std::puts("finish getint_atk");
}
inline int pre(int n){//处理同余方程系数化为 1 
//		std::puts("begin to pre");
	LL x,y;
//		EN;EN;EN;
	for(reg int i=1;i<=n;i++){
		ATK[i]%=p[i];
		if(!ATK[i]){
			//特判，如果攻击力模完以后为 0，则无解
			//特别的，如果此时初始生命就等于恢复能力，那么显然有解，且此时 x 可以为任意大于 0 的整数 
			if(a[i]==p[i]) no[i]=1;
			else{
//				std::puts("!ATK[i] & a[i]!=p[i]");
				return 0;
			}
		}
		else{
			LL gcd=exgcd(ATK[i],p[i],x,y);
//				std::printf("(%lld %lld->%lld) ",ATK[i],p[i],gcd);
			if(a[i]%gcd){
//				std::puts("! a[i]%gcd");
				return 0;
			}
			//此处应放在 mod p[i]/gcd 意义下进行 
			p[i]/=gcd;
			x=(x+p[i])%p[i];
			a[i]=mul(x,a[i]/gcd,p[i]);
		}
	}
	return 1;
}
inline int p_1(int n){
	for(reg int i=1;i<=n;i++)if(p[i]!=1) return 0;
	return 1;
}
inline int p_a(int n){
	for(reg int i=1;i<=n;i++)if(p[i]!=a[i]) return 0;
	return 1;
}
inline void work_p_1(int n){
	LL ans=0;
	for(reg int i=1;i<=n;i++) ans=max(ans,std::ceil((double)a[i]/ATK[i]));
	std::printf("%lld\n",ans);
}
inline void work_p_a(int n){
	LL ans=0;
	for(reg int i=1;i<=n;i++){
		LL tmp=a[i]/std::__gcd(a[i],ATK[i]);
		ans=(ans/std::__gcd(tmp,ans))*tmp;
	}
	std::printf("%lld\n",ans);
}
int main(){
//	std::freopen("dragon18.in", "r", stdin);
//	std::freopen("dragon.out", "w", stdout);
int T=read();while(T--){
	int n=read(),m=read();
	for(reg int i=1;i<=n;i++) a[i]=read();
	for(reg int i=1;i<=n;i++) p[i]=read();
	for(reg int i=1;i<=n;i++) extra[i]=read();
	std::memset(sword,0,sizeof sword);tot=0;
	for(reg int i=1;i<=m;i++) sword[read()]++;
	get_atk(n);
	if(p_a(n)){work_p_a(n);continue;}
	if(p_1(n)){work_p_1(n);continue;}
	LL ans=1,x,y,M;
	if(!pre(n)) goto FAIL;
	{
	reg int i=1;
	for(;i<=n;i++)if(!no[i]){//找第一个有效方程 
		ans=a[i];M=p[i];break;
	}
	for(i++;i<=n;i++){
		if(no[i]) continue;
		LL b=((a[i]-ans)%p[i]+p[i])%p[i];
		LL gcd=exgcd(M,p[i],x,y);
//			gcd=std::__gcd(M,p[i]);
		if(b%gcd){
//			std::puts("! b%gcd");
			goto FAIL;
		}
		x=mul(x,b/gcd,p[i]);
		ans+=mul(x,M,M/gcd*p[i]);
		M=M/gcd*p[i];
		ans=(ans+M)%M;
	}
	}
	std::printf("%lld\n",ans);continue;
	FAIL:;
	std::puts("-1");
}
	return 0;
}
```

---

## 作者：Tari (赞：1)

昨天晚上快走时看了这题：不是exgcd+excrt吗？  
旁边张大佬默默看了我一眼(觉得我会死)  
然后于是我今天中午才调出来Orz

 ***

### 思路：exgcd+excrt
### 提交：5次
#### 错因：龟速乘传进去了负数，并且用的int；之前写过的excrt的板子有问题
### 题解：
先要特判一种情况：若 $p[i]=1$ ，答案显然就是 $\max(\lceil\frac{a[i]}{stk[i]}\rceil)$ ，只需要把龙打成负血他就死了。

先是这样的一些方程：设 $atk[i]$ 表示对于第 $i$ 只龙使用攻击力为 $atk[i]$ 的剑
$$atk[i]*x_i \equiv a[i] \mod p[i] $$
好的这样我们可以 exgcd 解出 $X_i=x_i*\frac{a[i]}{gcd(atk[i],p[i])}$  

我们知道，对于上面的方程来说，$X_i+k*\frac{p[i]}{gcd(atk[i],p[i])},k\in Z$  

设 $b[i]=\frac{p[i]}{gcd(atk[i],p[i])}$ ,所以对于最终答案$ans$有：
$$ans\equiv X_i \mod b[i]$$
这个 $ans$ 是可以用 excrt 合并的。
## 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define R register int
using namespace std;
namespace Luitaryi {
template<class I> inline I g(I& x) { x=0; register I f=1;
	register char ch; while(!isdigit(ch=getchar())) f=ch=='-'?-1:f;
	do x=x*10+(ch^48); while(isdigit(ch=getchar())); return x*=f;
} 
template<class I> inline I ps(I x) { if(x<0) putchar('-'),x=-x;
	static char s[40]; register int sz=0; 
	while(x!=0) s[++sz]=x%10,x/=10; 
	while(sz) putchar(s[sz]+'0'),--sz;
}
const int N=100010;
inline ll exgcd(ll& x,ll& y,ll a,ll b) {
	if(!b) {x=1,y=0; return a;} 
	register ll d=exgcd(y,x,b,a%b); y-=a/b*x; 
	return d;
}
int T,n,m;
ll s[N],b[N],c[N],a[N],mx;
multiset<ll> ss; bool flg;
multiset<ll>::iterator it;
inline ll mul(ll a,ll b,ll p) { register ll ret=0; 
	for(;b;b>>=1,a=(a+a)%p) if(b&1) ret=(ret+a)%p; 
	ret=(ret+p)%p; return ret;
}
inline void main() { 
	g(T); while(T--) { mx=0,flg=true;
    register ll ans=0,sum=1,x,y;
		g(n),g(m); for(R i=1;i<=n;++i) g(s[i]);
		for(R i=1;i<=n;++i) g(b[i]),flg&=b[i]==1;
		for(R i=1;i<=n;++i) g(c[i]);
		for(R i=1;i<=m;++i) g(x),ss.insert(x);
		for(R i=1;i<=n;++i) {
			it=ss.upper_bound(s[i]);
			if(it!=ss.begin()) --it; 
			a[i]=*it,ss.erase(it),ss.insert(c[i]);
			mx=max((s[i]+a[i]-1)/a[i],mx);
		} if(flg) { 
			printf("%lld\n",mx);
			goto end;
		}
		for(R i=1;i<=n;++i) { register ll x,y;
			register ll d=exgcd(x,y,a[i],b[i]);
			if(s[i]%d) {puts("-1"); goto end;}
			b[i]/=d,x=(x%b[i]+b[i])%b[i]; 
			s[i]=mul(x,((s[i]/d)%b[i]+b[i])%b[i],b[i]);
		}
		for(R i=1;i<=n;++i) {
			register ll d=exgcd(x,y,sum,b[i]);
			if((s[i]-ans)%d) {puts("-1"); goto end;}
			b[i]/=d; 
			x=mul(x,((s[i]-ans)/d%b[i]+b[i])%b[i],b[i]);
			ans+=x*sum,sum=sum*b[i];
		} printf("%lld\n",(ans%sum+sum)%sum);
		end:ss.clear();
	}
}
} signed main() {Luitaryi::main(); return 0;}
```
***
2019.09.03  
66

---

## 作者：Aegir (赞：1)

### excrt模板题

使用$multset$，我们可以快速求出每次砍龙的剑是哪一把。

这样问题就比较转化成了：给定一个同余方程组：

$$a_i ≡ b_i (mod\ c_i)$$

求这个方程组的最小正整数解$x$。

注意到存在$a_i>c_i$的情况，此时求出来的解可能不符合题意。

观察一波数据范围，发现只有$c_i=1$时，才存在$a_i>c_i$的情况。答案即为：

$$max_{1≤i≤n}\{\lceil \frac{b_i}{a_i} \rceil\}$$

经过上述处理后，此题就成为了一个板子题。

假设我们现在正在处理第$i$个方程，并且已经求出前$i-1$个方程的通解为：$x+km$。（最开始的$x,m$可以设为$0,1$）

那么我们就是要求：$a_i(x+km) ≡ b_i (mod\ c_i)$

拆开后移项：$a_im * k ≡ b_i - a_ix (mod\ c_i)$

式子中唯一的未知项就是$k$，令：$A=a_im,\ B = b_i-a_ix,\ C = c_i$

那么就相当于是求同余方程：$Ak ≡ B (mod\ C)$

即不定方程：$Ak = B + Cy\  =>\  Ak - Cy = B$

用$exgcd$求解即可（做这题的人应该都会吧）

如果此不定方程无解，则说明整个方程组无解。

显然时间复杂度是$O(nlogn)$的。

#### 几个坑点：

乘法可能会爆$long\ long$，写一个龟速乘即可。

我们解出来的$x$是最小非负整数解，所以要特判一下$x$是否为0

#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int MAXN = 100010;

int T, n, m;
int val[MAXN], atk[MAXN];
int a[MAXN], b[MAXN], c[MAXN];
multiset<int> S;

void init()
{
    S.clear(); multiset<int>:: iterator it;
    for(int i = 1; i <= m; ++i) S.insert(atk[i]);
    for(int i = 1; i <= n; ++i)
    {
        it = S.upper_bound(b[i]);
        if(it != S.begin()) --it;
        a[i] = *it; S.erase(it); S.insert(val[i]);
    }
}

int mul(int a, int b, int p)
{
    a = (a % p + p) % p, b = (b % p + p) % p;
    int ans = 0;
    for(; b; b >>= 1)
    {
        if(b & 1) ans = (ans + a) % p;
        a = (a + a) % p; 
    }
    return ans;
}

int exgcd(int a, int b, int &x, int &y)
{
    int d;
    if(b) d = exgcd(b, a % b, y, x), y -= a / b * x;
    else x = 1, y = 0, d = a;
    return d;
}

int solve()
{
    int x = 0, m = 1, A, B, C, D, X, Y;
    for(int i = 1; i <= n; ++i)
    {
        if(c[i] == 1) {x = max(x, (b[i] % a[i] ? b[i] / a[i] + 1 : b[i] / a[i])); continue;}
        A = a[i] * m % c[i], B = ((b[i] - a[i] * x) % c[i] + c[i]) % c[i], C = c[i];
        D = exgcd(A, C, X, Y); if(B % D) return -1; C /= D;
        X = mul(X, B / D, C); x += X * m; m *= C; x %= m;
    }
    return (x ? x : m);
}

signed main()
{
    scanf("%lld", &T);
    while(T--)
    {
        scanf("%lld %lld", &n, &m);
        for(int i = 1; i <= n; ++i) scanf("%lld", &b[i]);
        for(int i = 1; i <= n; ++i) scanf("%lld", &c[i]);
        for(int i = 1; i <= n; ++i) scanf("%lld", &val[i]);
        for(int i = 1; i <= m; ++i) scanf("%lld", &atk[i]);
        init(); printf("%lld\n", solve());
    }
    return 0;
}
```

---

## 作者：asuldb (赞：1)

发现好像都是化掉系数之后套上$ExCrt$的板子

这好像是一个真正的扩展扩展中国剩余定理

我们要处理的方程是这样的形式

$$c_ix\equiv b_i(mod\ a_i)$$

其中$c$用一个$std::multiset$处理就好了

好像不是普通$excrt$可以处理的形式啊

思考一下这个方程的本质是什么，$c_ix=k_ia_i+b_i$

所以如果我们有两个方程

$$c_1x\equiv b_1(mod\ a_1)$$

$$c_2x\equiv b_2(mod\ a_2)$$

我们需要像$crt$那样合并起来

我们开始化柿子了

$$x=\frac{k_1a_1+b_1}{c_1}=\frac{k_2a_2+b_2}{c_2}$$

所以就有

$$a_2c_1k_2+b_2c_1=a_1c_2k_1+b_1c_2$$

$$a_2c_1k_2=a_1c_2k_1+b_1c_2-b_2c_1$$

根据贝祖定理，这个方程有解条件是$gcd(a_2c_1,a_1c_2)|(b_1c_2-b_2c_1)$

如果有解的话，我们设$t=gcd(a_2c_1,a_1c_2)$，两边除以$t$

$$\frac{a_2c_1k_2}{t}=\frac{a_1c_2k_1}{t}+\frac{b_1c_2-b_2c_1}{t}$$

显然我们可以写成一个同余式

$$\frac{a_2c_1k_2}{t}\equiv \frac{b_1c_2-b_2c_1}{t}\ (mod\ \frac{a_1c_2}{t})$$

之后设$inv=(\frac{a_2c_1}{t},\frac{a_1c_2}{t})$，即$\frac{a_2c_1}{t}$在$mod$ $\frac{a_1c_2}{t}$意义下的乘法逆元

两边乘以$inv$

$$k_2\equiv inv*\frac{b_1c_2-b_2c_1}{t}\ (mod\ \frac{a_1c_2}{t})$$

改写成等式

$$k_2= inv*\frac{b_1c_2-b_2c_1}{t}+y\times\frac{a_1c_2}{t}$$

我们把$k_2$回带到$c_2x=k_2a_2+b_2$

$$c_2x=inv*\frac{b_1c_2-b_2c_1}{t}*a_2+y\times\frac{a_1c_2a_2}{t}+b_2$$

再改写成同余式

$$c_2x\equiv inv*\frac{b_1c_2-b_2c_1}{t}\%(\frac{a_1c_2}{t})*a_2+b_2(mod\ \frac{a_1c_2a_2}{t})$$

我们只需要顺次合并这些方程就好了，一旦出现无解就输出$-1$好了

一个坑点是$a=1$时解出来会是$0$，好像和实际要求不太一样，所以对于这样情况直接模拟特判就好了

之后因为非常的懒没用快速乘，用了__int128

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<set>
#define re register
#define maxn 100005
#define LL __int128
#define min(a,b) ((a)<(b)?(a):(b))
#define INF 9999999999999
#define max(a,b) ((a)>(b)?(a):(b))
#define set_it std::multiset<LL>::iterator
std::multiset<LL> s;
int n,m;
LL a[maxn],b[maxn],c[maxn],res[maxn];
LL gcd(LL a,LL b){ return !b?a:gcd(b,a%b);}
LL exgcd(LL a,LL b,LL &x,LL &y)
{
	if(!b) return x=1,y=0,a;
	LL r=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return r;
}
inline LL pre(LL x)
{
	s.insert(x);
	set_it i=s.find(x);
	if(i==s.begin()) return -INF;
	--i;return *i;
}
inline void del(LL x)
{
	set_it i=s.find(x);
	s.erase(i);
}
inline int check(LL x)
{
	if(s.find(x)!=s.end()) return 1;
	return 0;
}
inline LL read()
{
	char c=getchar();
	LL x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
inline LL inv(LL a,LL b)
{
	LL x,y;
	LL r=exgcd(a,b,x,y);
	return (x%b+b)%b;
}
void write(LL x)
{
    if(x>9) write(x/10);
    putchar(x%10+48);
}
inline LL did(LL a,LL b)
{
	if(a%b==0) return a/b;
	return a/b+1;
}
inline void tepan()
{
	LL ans=0;
	for(re int i=1;i<=n;i++)
		ans=max(ans,did(b[i],c[i]));
	write(ans),puts("");
}
inline void solve()
{
	s.clear();
	LL x;
	int flag=0;
	n=read(),m=read();
	for(re int i=1;i<=n;i++) b[i]=read();
	for(re int i=1;i<=n;i++) a[i]=read(),flag|=(a[i]!=1);
	for(re int i=1;i<=n;i++) res[i]=read();
	for(re int i=1;i<=m;i++) x=read(),s.insert(x);
	for(re int i=1;i<=n;i++)
	{
		if(check(b[i])) c[i]=b[i],del(b[i]);
		else
		{
			LL now=pre(b[i]);
			del(b[i]);
			if(now==-INF)
			{
				set_it it=s.begin();
				c[i]=*it;
				s.erase(it);
			}
			else c[i]=now,del(now);
		}
		s.insert(res[i]);
	}
	if(!flag)
	{
		tepan();
		return;
	}
	LL a1=a[1],b1=b[1],c1=c[1];
	for(re int i=2;i<=n;i++)
	{
		LL a2=a[i],b2=b[i],c2=c[i];
		LL r=gcd(c2*a1,c1*a2);
		if((b1*c2-b2*c1)%r) 
		{
			puts("-1");
			return;
		}
		if((c2*a1/r)<(c1*a2/r)) std::swap(a1,a2),std::swap(b1,b2),std::swap(c1,c2);
		LL P=a1*c2/r,Inv=inv(c1*a2/r,a1*c2/r);
		b1=((Inv*(((b1*c2-b2*c1)/r)%P+P)%P*a2))+b2;
		a1=a1*a2*c2/r;
		c1=c2;
	}
	LL y;
	if(b1%gcd(a1,c1))
	{
		puts("-1");
		return;
	}
	LL r=exgcd(c1,a1,x,y);
	LL t=a1/r;
	x=(x*(b1/r)%t+t)%t;
	write(x);
	puts("");
}
int main()
{
	int T;
	T=read();
	while(T--) solve();
	return 0;
}
```

---

## 作者：ascchrvalstr (赞：0)

 我们先假设所有的巨龙都被杀掉。由题意可知杀掉巨龙所用的剑的杀伤力是固定的，和$x$无关。
 
 我们发现，杀掉一条龙等价于$x \cdot ATK \ge a_i$且$a_i-x \cdot ATK \equiv 0 \pmod{p_i}$
 
 即$x \ge \lceil \frac{a_i}{ATK} \rceil$且$x \cdot ATK \equiv a_i \pmod{p_i}$
 
 对于所有$p_i$，第二个式子构成了一个线性同余方程组。解出一个$x$并寻找满足第一个式子的最小的$x$即可。
 
 注意：这里的数可能达到$10^{12}$级别，解方程组时需要用到快速乘。
 
 ```cpp
#include <stdio.h>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;
long long gcd(long long a,long long b)
{
    return b?gcd(b,a%b):a;
}
long long extgcd(long long a,long long b,long long &x,long long &y)
{
    long long d=a;
    if (b)
    {
        d=extgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else
    {
        x=1;
        y=0;
    }
    return d;
}
long long mod_inverse(long long a,long long m)
{
    long long x,y;
    extgcd(a,m,x,y);
    return (m+x%m)%m;
}
long long qmul(long long a,long long b,long long mod)
{
    long long ret=0;
    for (;b;a=(a+a)%mod,b>>=1)
        if (b&1)
            (ret+=a)%=mod;
    return ret;
}
pair<long long,long long> linear_congruence(const vector<long long> &A,const vector<long long> &B,const vector<long long> &M)
{
    long long x=0,m=1;
    for (size_t i=0;i<A.size();++i)
    {
        long long a=A[i]*m,b=B[i]-qmul(A[i],x,M[i]),d=gcd(M[i],a);
        if (b<0)
            b+=M[i];
        if (b%d)
            return make_pair(0,-1);
        long long t=qmul(b/d,mod_inverse(a/d,M[i]/d),M[i]/d);
        x+=m*t;
        m*=M[i]/d;
        x%=m;
    }
    return make_pair(x,m);
}
long long bonus[100001];
int main()
{
    int T;
    freopen("dragon.in","r",stdin);
    freopen("dragon.out","w",stdout);
    scanf("%d",&T);
    while (T--)
    {
        int n,m;
        scanf("%d%d",&n,&m);
        vector<long long> a(n);
        for (int i=0;i<n;++i)
            scanf("%lld",&a[i]);
        vector<long long> p(n);
        for (int i=0;i<n;++i)
            scanf("%lld",&p[i]);
        for (int i=0;i<n;++i)
            scanf("%lld",bonus+i);
        multiset<long long> swords;
        for (int i=1;i<=m;++i)
        {
            long long x;
            scanf("%lld",&x);
            swords.insert(x);
        }
        vector<long long> atk(n);
        long long maxa=0;
        for (int i=0;i<n;++i)
        {
            multiset<long long>::iterator it=swords.upper_bound(a[i]);
            if (it!=swords.begin())
                --it;
            atk[i]=*it;
            maxa=max(maxa,a[i]/atk[i]+(a[i]%atk[i]?1:0));
            swords.erase(it);
            swords.insert(bonus[i]);
            a[i]%=p[i];
            atk[i]%=p[i];
        }
        pair<long long,long long> res=linear_congruence(atk,a,p);
        if (res.second==-1)
            printf("-1\n");
        else
        {
            long long tmp=(maxa-res.first)/res.second;
            if (tmp>0)
                res.first+=tmp*res.second;
            if (res.first<maxa)
                res.first+=res.second;
            printf("%lld\n",res.first);
        }
    }
    return 0;
}

```

---

## 作者：liuzhangfeiabc (赞：0)

因为没a掉此题而cu滚粗的菜鸡来报个到。

首先我们可以显然地发现对于每条龙，攻击它用到的剑是唯一确定的，用一个multiset预处理即可，记作di。

需要强调两点：第一是不要用成set，第二是虽然里面存的元素是int但是你会用ll去查询所以还是要开ll，没错我的25分就是这么丢的……

首先pi=1的点很好处理，因为此时只要打到血量<=0就死定了，所以答案就是max((ai / di)上取整)

然后我们考虑对于最后的答案x，一定满足如下限制：

对于任意i，均有 di * x % pi == ai

也就是n个同余方程的形式。

我们可以对于每个同余方程，用exgcd解出一个x的通解。

注意得到x的最小非负整数解qi后，加上任意整数倍的ki =（pi / gcd(di,pi)）也一定是一个合法解

因此我们的同余方程可以化成如下形式：

对于任意i，满足x % pi == qi

然后合并这n个同余方程组就是经典的扩展crt啦

等等……我不会扩展crt！

于是我在考场上推了两个多小时的式子，最后得出了一个玄学做法：

假设我们有两个同余方程：

x % a1 == b1

x % a2 == b2

我们要将其合并为

x % lcm(a1,a2) == b3

b3即为我们的所求。

我们考虑写成不定方程的形式

x == b1 + k1 * a1

x == b2 + k2 * a2

先“钦定”k1 = 0，看一下带入第二个不定方程的结果与a1相差多少，记作q1。

然后考虑k1++，会使得第二个不定方程的结果变化多少，记作q2。

于是我们就有

k1 * q2 % a2 == q1

可以exgcd解出k1，然后就可以还原回b3的值啦。

（并不知道正经的扩展crt是怎么写的，也许跟这个思路类似？）

如果上面任意一个exgcd或扩展crt的步骤无解，则直接返回无解即可。

于是这题就做完了，复杂度O（n log n），是不是很休闲？（逃）

哦对了，由于1e12直接相乘会爆ll，因此需要写快速乘。 

由于是自己一边推一边写的，代码极丑请原谅~

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<set>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
li read(){
	li x = 0,c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)){
		x = x * 10 + (c ^ '0');
		c = gc;
	}
	return x;
}
void print(li x){
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
int t,n,m;
li a[100010],b[100010],c[100010];
int d[100010];
multiset<li> s;
li gcd(li x,li y){
	return !y ? x : gcd(y,x % y);
}
li lcm(li x,li y){
	return x / gcd(x,y) * y;
}
li exgcd(li a,li b,li &x,li &y){
	if(!b){
		x = 1;y = 0;return a;
	}
	li p = exgcd(b,a % b,x,y);
	li t = x;x = y;y = t - a / b * y;
	return p;
}
li ksc(li q,li w,li p){
	q %= p;w %= p;
	if(q < w) swap(q,w);
	if(p <= 10000000000000ll){
		li as = 0;
		while(w){
			(as += w % 100000 * q) %= p;
			q = q * 100000 % p;
			w /= 100000;
		}
		return as;
	}
	li as = 0;
	while(w){
		if(w & 1) (as += q) %= p;
		(q += q) %= p;
		w >>= 1;
	}
	return as;
}
int main(){
	int i,j,k,l;
	li x,y,p,q,r,a1,a2,b1,b2,c1,c2,tp;
	t = read();
	while(t--){
		s.clear();
		li mx = 0;
		n = read();m = read();
		for(i = 1;i <= n;++i) a[i] = read();
		for(i = 1;i <= n;++i) b[i] = read(),mx = max(mx,b[i]);
		for(i = 1;i <= n;++i) c[i] = read();
		for(i = 1;i <= m;++i){
			j = read();
			s.insert(j);
		}
		for(i = 1;i <= n;++i){
			multiset<li>::iterator it = s.upper_bound(a[i]);
			if(it != s.begin()) --it;
			d[i] = *it;
			s.erase(it);
			s.insert(c[i]); 
		}
		if(mx == 1){
			li as = 0;
			for(i = 1;i <= n;++i) as = max(as,(a[i] - 1) / d[i] + 1);
			print(as);pc('\n');continue;
		}
		p = exgcd(d[1],b[1],x,y);
		if(a[1] % p){
			puts("-1");continue;
		}
		q = b[1] / p;r = a[1] / p % q;
		if(x < 0) x += q;
		b1 = q;b2 = ksc(r,x,q);
		bool fg = 0;
		for(i = 2;i <= n;++i){
			p = exgcd(d[i],b[i],x,y);
			if(a[i] % p){
				puts("-1");fg = 1;break;
			}
			q = b[i] / p;r = a[i] / p % q;
			if(x < 0) x += q;
			a1 = q;a2 = ksc(r,x,q);
			tp = ((b2 - a2) % b1 + b1) % b1;
			p = exgcd(a1 % b1,b1,x,y);
			if(tp % p || a2 % p != b2 % p){
				fg = 1;puts("-1");break;
			}
			c1 = a1 / p * b1;
			q = b1 / p;r = tp / p % q;
			if(x < 0) x += q;
			x = ksc(r,x,q);
			c2 = (a2 + ksc(x,a1,c1)) % c1;
			b1 = c1;b2 = c2;
		}
		if(fg) continue;
		print(!b2 ? b1 : b2);pc('\n');
	}
	return 0;
}
```

---

## 作者：Rubyonly (赞：0)

首先很容易将题意转化为

> 给定若干个如下式的不定方程，解出最小解 $x$
> $$ATK_i\times x\equiv a_i \mod p_i$$

对于单个不定方程，我们可以化简一下

为什么化简？

如果 $\gcd (ATK_i,p_i) \neq 1$，会发现，可以解出 $\gcd (ATK_i,p_i)$ 个解使得这个不定方程成立

但是我们最后要求解的是一个不定方程组，无法得知取那个解是正确的，所以两边同除 $\gcd (ATK_i,p_i)$，使得不定方程解出一个解，从而利于不定方程组的求解

然后用 $ExGCD$ 来求解，化成若干个同余方程的形式，最后 $ExCRT$ 合并一下就好了

但是上述做法并不能处理 $p_i=1$ 的情况，所以要特判一下，其实就是 $\max \{\frac{a_i}{ATK_i}\}$，注意上取整

作为 $NOI\; 2018$ 的签到题，~~还是挺水的吧~~

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>

typedef long long ll;
typedef unsigned long long ull;

using namespace std;

const int maxn = 1e5 + 50, INF = 0x3f3f3f3f;

inline ll read () {
	register ll x = 0, w = 1;
	register char ch = getchar ();
	for (; ch < '0' || ch > '9'; ch = getchar ()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar ()) x = x * 10 + ch - '0';
	return x * w;
}

inline void write (register int x) {
	if (x / 10) write (x / 10);
	putchar (x % 10 + '0');
}

int T, n, m;
bool ALLONE = 1;
vector <int> vec;
ll maxx, a[maxn], b[maxn], c[maxn], p[maxn], atk[maxn];

inline ll Mul (register ll a, register ll b, register ll mod) {
	register ll tmp = (long double) a / mod * b, res = (ull) a * b - (ull) tmp * mod;
	return (res % mod + mod) % mod;
}

inline ll ExGCD (register ll a, register ll b, register ll &x, register ll &y) {
	if (! b) return x = 1, y = 0, a;
	register ll d = ExGCD (b, a % b, x, y), tmp = x;
	return x = y, y = tmp - a / b * y, d;
}

inline ll ExCRT () {
	register ll ans = c[1], lcm = p[1], maxx = 0;
	for (register int i = 2; i <= n; i ++) {
		register ll res = ((c[i] - ans) % p[i] + p[i]) % p[i], x = 0, y = 0, gcd = ExGCD (lcm, p[i], x, y), tmp = p[i] / gcd;
		if (res % gcd) return -1;
		x = Mul (x, res / gcd, tmp), ans += x * lcm, lcm *= tmp, ans = (ans % lcm + lcm) % lcm, maxx = max (maxx, p[i]);
	} 
	return (ans % lcm + lcm) % lcm;
}

int main () {
	T = read();
	while (T --) {
		n = read(), m = read(), vec.clear (), ALLONE = 1, maxx = 0;
		for (register int i = 1; i <= n; i ++) a[i] = read();
		for (register int i = 1; i <= n; i ++) {
			p[i] = read();
			if (p[i] != 1) ALLONE = 0;
		}
		for (register int i = 1; i <= n; i ++) atk[i] = read();
		for (register int i = 1; i <= m; i ++) vec.push_back (read ());
		sort (vec.begin (), vec.end ());
		for (register int i = 1, res; i <= n; i ++) {
			res = upper_bound (vec.begin (), vec.end (), a[i]) - vec.begin ();
			if (res) res --;
			b[i] = vec[res], vec.erase (vec.begin () + res);
			res = lower_bound (vec.begin (), vec.end (), atk[i]) - vec.begin ();
			vec.insert (vec.begin () + res, atk[i]);
		}
		if (ALLONE) {
			for (register int i = 1; i <= n; i ++) maxx = max (maxx, (ll) ceil (1.0 * a[i] / b[i]));
			printf ("%lld\n", maxx);
		} else {
			for (register int i = 1; i <= n; i ++) {
				register ll x = 0, y = 0, res = ExGCD (b[i], p[i], x, y);
				x = 0, y = 0, res = ExGCD (res, a[i], x, y), b[i] /= res, p[i] /= res, a[i] /= res, x = 0, y = 0;
				register ll gcd = ExGCD (b[i], p[i], x, y), tmp = p[i] / gcd;
				if (a[i] % gcd) { puts ("-1"); goto end; }
				else x = (x % tmp + tmp) % tmp, c[i] = Mul (x, a[i] / gcd, tmp);
			}
			printf ("%lld\n", ExCRT ()); end:;
		}
	}
	return 0;
}
```

---


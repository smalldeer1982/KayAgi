# [NOI2019] 回家路线

## 题目背景

本题原题数据强度较低，若想要测试较强数据可以去 [P6302](https://www.luogu.com.cn/problem/P6302)，除数据范围外均与原题相同。

## 题目描述

猫国的铁路系统中有 $n$ 个站点，从 $1 - n$ 编号。小猫准备从 $1$ 号站点出发，乘坐列车回到猫窝所在的 $n$ 号站点。它查询了能够乘坐的列车，这些列车共 $m$ 班，从$1 - m$编号。小猫将在 $0$ 时刻到达 $1$ 号站点。对于 $i$ 号列车，它将在时刻 $p_i$ 从站点 $x_i$ 出发，在时刻 $q_i$ 直达站点 $y_i$，小猫只能在时刻 $p_i$ 上 $i$ 号列车，也只能在时刻 $q_i$ 下 $i$ 号列车。小猫可以通过多次换乘到达 $n$ 号站点。一次换乘是指对于两班列车，假设分别为 $u$ 号与 $v$ 号列车，若 $y_u = x_v$ 并且 $q_u \leq p_v$，那么小猫可以乘坐完 $u$ 号列车后在 $y_u$ 号站点等待 $p_v - q_u$ 个时刻，并在时刻 $p_v$ 乘坐 $v$ 号列车。

小猫只想回到猫窝并且减少途中的麻烦，对此它用烦躁值来衡量。

- 小猫在站点等待时将增加烦躁值，对于一次 $t (t \geq 0)$ 个时刻的等待，烦躁值将增加 $At^2 + Bt + C$，其中 $A, B,C$ 是给定的常数。注意：小猫登上第一班列车前，即从 $0$ 时刻起停留在 $1$ 号站点的那些时刻也算作一次等待。

- 若小猫最终在时刻 $z$ 到达 $n$ 号站点，则烦躁值将再增加 $z$。

形式化地说，若小猫共乘坐了 $k$ 班列车，依次乘坐的列车编号可用序列 $s_1, s_2, \cdots , s_k$表示。该方案被称作一条可行的回家路线，当且仅当它满足下列两个条件：

1. $x_{s1} = 1$ , $y_{sk} = n$

2. 对于所有 $j (1 \leq j < k)$，满足 $y_{sj} = x_{s_{j+1}}$ 且 $q_{sj}\leq p_{s_{j+1}}$

对于该回家路线，小猫得到的烦躁值将为：

$$q_{s_k}+(A\times p_{s_1}^2+B\times p_{s_1}+C)+\sum_{j=1}^{k-1}(A(p_{s_{j+1}}-q_{s_j})^2+B(p_{s_{j+1}}-q_{s_j})+C)$$

小猫想让自己的烦躁值尽量小，请你帮它求出所有可行的回家路线中，能得到的最
小的烦躁值。题目保证至少存在一条可行的回家路线。


## 说明/提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 3

见附加文件的 `route/route3.in` 与 `route/route3.ans`。

该样例的数据类型与最终测试点 $5 \sim 8$ 一致。

#### 样例 4

见附加文件的 `route/route4.in` 与 `route/route4.ans`。

该样例的数据类型与最终测试点 $11 \sim 14$ 一致。

#### 样例 5

见附加文件的 `route/route5.in` 与 `route/route5.ans`。

该样例的数据类型与最终测试点 $18 \sim 20$ 一致。

### 样例 1 解释

共有三条可行的回家路线：

- 依次乘坐 1，4 号列车，得到的烦躁值为：$10 + (1 \times 3^2 + 5 \times 3 + 10) + (1 \times (9 - 4)^2 + 5 \times (9 - 4) + 10)= 104$
- 依次乘坐 2，4 号列车，得到的烦躁值为：$10 + (1 \times 5^2 + 5 \times 5 + 10) + (1 \times (9 - 7)^2 + 5 \times (9 - 7) + 10)= 94$
- 依次乘坐 3，4 号列车，得到的烦躁值为：$10 + (1 \times 6^2 + 5 \times 6 + 10) + (1 \times (9 - 8)^2 + 5 \times (9 - 8) + 10)= 102$

第二条路线得到的烦躁值最小为 $94$。

### 数据范围

对于所有测试点：$2\le n\le 10^5,1\le m\le 2\times 10^5,0 \le A \le 10 , 0 \le B, C \le 10^6,1 \le x_i, y_i \le n , x_i \neq y_i , 0 \le p_i < q_i \le 10^3$。

每个测试点的具体限制见下表：

| 测试点编号  |        $n$         |          $m$          | $A,B,C$ 的特殊限制 | 其他特殊条件 |
| :---------: | :----------------: | :-------------------: | :----------------: | :----------: |
|  $1\sim 2$  |     $\le 100$      |        $=n-1$         |         无         | $y_i=x_i+1$  |
|  $3\sim 4$  |     $\le 100$      | $\le 100$ |     $A=B=C=0$      | $y_i=x_i+1$  |
|  $5\sim 8$  | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |     $A=B=C=0$      |  $x_i<y_i$   |
|     $9$     | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |      $A=B=0$       |  $x_i<y_i$   |
|    $10$     | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |       $A=0$        |  $x_i<y_i$   |
| $11\sim 14$ | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |         无         |      无      |
|    $15$     |     $\le 10^5$     |  $\le 2\times 10^5$   |      $A=B=0$       |      无      |
| $16\sim 17$ |     $\le 10^5$     |  $\le 2\times 10^5$   |       $A=0$        |      无      |
| $18\sim 20$ |     $\le 10^5$     |  $\le 2\times 10^5$   |         无         |      无      |

## 样例 #1

### 输入

```
3 4 1 5 10
1 2 3 4
1 2 5 7
1 2 6 8
2 3 9 10```

### 输出

```
94```

## 样例 #2

### 输入

```
4 3 1 2 3
1 2 2 3
2 3 5 7
3 4 7 9```

### 输出

```
34```

# 题解

## 作者：Great_Influence (赞：170)

这题就是[这道题](https://loj.ac/problem/6520)的加强版。

首先，我们不考虑位置的限制，只考虑过程。

我们可以设 $dp[i]$ 表示在时刻 $i$ 时的最小烦躁值减去 $q_{s_k}$  ，则有:

对于一条路径 $(p_r,q_r)$(我们此时不考虑 $x$ 和 $y$ ):

$$dp[q_r]=\min_{j\le p_r}dp[j]+A(p_r-j)^2+B(p_r-j)+C$$

明显可以利用斜率优化加速转移。

但是问题在于路径是一个持续性的过程，即 $p_i$ 和 $q_i$ 之间可能相距很远。不过我们完全可以将 $p_i$ 和 $q_i$ 拆成 **一次询问** 和 **一次尾部插入** 两个事件，这样事件就可以通过排序变成时间单调递增的了。

接下来考虑 $x$ 和 $y$ ，也就是起点和终点。不过这可以用上面一样的方法处理，也就是将起点和终点拆成两个操作。我们依然维护单调队列，但是因为每个事件对应的地点有区别，因此我们对每个点开一个 $vector$ ，分别维护即可。

记得在 $1$ 号点预先放一个 $0$ 时刻 $0$ 代价的点作为起点。答案可以在路径终点是 $n$ 的时候直接统计，$n$ 号点就没必要再开 $vector$ 了。

时间复杂度瓶颈在排序上。因为数据范围特别小，因此可以直接采用统排。时间复杂度 $O(M+T)$，其中 $T$ 是时间范围的最大值。

代码就不贴了。

---

## 作者：yzhang (赞：48)

[原题传送门](https://www.luogu.org/problemnew/show/P5468)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11198638.html)

前置芝士：斜率优化 不会的可以去[杜神博客](https://www.luogu.org/blog/top-oier/qian-tan-xie-shuai-you-hua)学

这道题我考场上只会差点跑最短路的70pts做法

后来回家后发现错误的爆搜都能拿满分（刀片）

还有很多人$O(mt)$过的，~~还是要坚持写正解好不好~~

我们先考虑$O(mt)$的暴力dp，先不考虑总时间对烦躁值的影响，设$dp[id]$表示走完第$id$条边最小的代价：

$$dp[id]=Min(dp[j]+A(p_{id}-q_j)^2+B(p_{id}-q_j)+C)(id,j \in [1,m],q_j<=p_{id},v[j]=u[id])$$

看着这个方程有平方项考虑展开，展开后会发现能转化成斜率优化标准形式

$$dp[j]+Aq_j^2-Bq_j=2Ap_iq_j-dp[i]-Ap_i^2-Bp_i-C$$

其中$y=dp[j]+Aq_j^2-Bq_j,k=2Ap_i,x=q_j,b=-dp[i]-Ap_i^2-Bp_i-C$

每条边进出一次队列，所以复杂度为$O(m)$

完整代码

```cpp
#include <bits/stdc++.h>
#define N 200005
#define ll long long
#define db double
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register ll x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int Max(register int a,register int b)
{
    return a>b?a:b;
}
inline ll Min(register ll a,register ll b)
{
    return a<b?a:b;
}
struct node{
    ll x,y;
    int id;
};
int n,m,A,B,C,maxT=0;
int x[N],y[N],p[N],q[N],head[N];
ll ans=1926081700000000ll,dp[N];
vector<int> d[1005];
vector<node>que[N];
queue<int> res[1005];
inline db gslope(register node a,register node b)
{
    return 1.0*(a.y-b.y)/(1.0*(a.x-b.x));
}
inline void ins(register int id)
{
    int pos=y[id];
    node now=(node){q[id],dp[id]+A*q[id]*q[id]-B*q[id],id};
    while(que[pos].size()-head[pos]>=2)
    {
        int len=que[pos].size();
        if(gslope(que[pos][len-1],que[pos][len-2])<gslope(que[pos][len-2],now))
            break;
        que[pos].pop_back();
    }
    que[pos].push_back(now);
}
inline void del(register db slpe,register int pos)
{
    while(que[pos].size()-head[pos]>=2)
    {
        if(gslope(que[pos][head[pos]],que[pos][head[pos]+1])>slpe)
            return;
        ++head[pos];
    }
}
int main()
{
    n=read(),m=read(),A=read(),B=read(),C=read();
    for(register int i=1;i<=m;++i)
        x[i]=read(),y[i]=read(),p[i]=read(),q[i]=read(),maxT=Max(maxT,q[i]);
    for(register int i=1;i<=m;++i)
        d[p[i]].push_back(i);
    que[1].push_back((node){0,0,0});
    for(register int t=0;t<=maxT;++t)
    {
        while(!res[t].empty())
            ins(res[t].front()),res[t].pop();
        int len=d[t].size();
        for(register int k=0;k<len;++k)
        {
            int id=d[t][k];
            int pos=x[id];
            if(que[pos].size()==head[pos])
                continue;
            db slpe=2.0*A*p[id];
            del(slpe,pos);
            int j=que[pos][head[pos]].id;
            dp[id]=dp[j]+1ll*A*(p[id]-q[j])*(p[id]-q[j])+1ll*B*(p[id]-q[j])+C;
            res[q[id]].push(id);
            if(y[id]==n)
                ans=Min(ans,dp[id]+q[id]);
        }
    }
    write(ans);
    return 0;
}
```


---

## 作者：情非昔比 (赞：31)

# ~~好水的一道NOI题~~
## 题目大意：
现在有n个城市，城市之间有m条火车可以到达。

第i条火车是从第$x_i$出发并到达$y_i$，是在$p_i$时间出发，并在$q_i$时间到达。

火车只能够在前一辆到达后才能乘坐。

设共乘坐了k辆火车，那么他的代价是$(q_{s_{k}}+\left(A \times p_{s_{1}}^{2}+B \times p_{s_{1}}+C\right)+\sum_{j=1}^{k-1}\left(A\left(p_{s j+1}-q_{s_{j}}\right)^{2}+B\left(p_{s_{j+1}}-q_{s_{j}}\right)+C\right) $

求最小代价。
## 解题思路：
一个DP题。

我们先将火车按照出发时间排序。

然后我们就可以进行DP了

我们用$f_{i,j}$表示时间$j$到达站点$i$的最小代价。

那我们有转移为$f_{y_i,q_i}=min(f_{x_i,j}+calc(p_i,j))$

其中$calc(x)=Ax^2+Bx+C$

然后转移即可。
# Code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define inf 0x3f3f3f3f
struct node{
	int x,y,p,q;
	bool operator<(node a)const{
		return p<a.p;
	}
}a[200100];
int n,m,A,B,C,T,ans;
int f[100100][1010];
int calc(int x){
	return x*x*A+x*B+C;
}
int main(){
	scanf("%d%d%d%d%d",&n,&m,&A,&B,&C);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&a[i].x,&a[i].y,&a[i].p,&a[i].q);
		T=max(T,a[i].q);
	}
	memset(f,0x3f,sizeof(f));
	f[1][0]=0;
	sort(a+1,a+m+1);
	for(int i=1;i<=m;i++)
		for(int j=0;j<=a[i].p;j++){
			if(f[a[i].x][j]==inf)continue;
			f[a[i].y][a[i].q]=min(f[a[i].y][a[i].q],f[a[i].x][j]+calc(a[i].p-j));
		}
	int ans=inf;
	for(int i=0;i<=T;i++)
		ans=min(ans,f[n][i]+i);
	printf("%d\n",ans);	
}
```

---

## 作者：Shallowy (赞：25)

### ~~强烈谴责出题人用脚造数据~~
我判断斜率大于小于号打反还怒过大样例...

强行搞了半天拆点，最后连一开始随手写的暴力$spfa$都只要改一改就能过???


------------
正解应该还是顺延了之前$spfa$或者暴力$dp$的思想，容易想到**用$dp[u][i]$表示在$i$时刻到达$u$点时的最小烦躁值**(无法到达设为无穷大)，这样每一班车$(x,y,p,q)$都对应了一个转移：

$$dp[y][q]=\mathop{min}\limits_{0\leq i\leq p}(dp[x][i]+A(p-i)^2+B(p-i)+C)$$

最后$ans=\mathop{min}\limits_{1\leq i\leq q_{max}}(dp[n][i]+i).$

我们看到转移方程右边有平方和一大堆乘积，容易想到可以试着考虑**斜率优化**，我们先**把$min$和$i\leq p$的限制去掉**，再把乘积展开：


$$\begin{aligned}dp[y][q]&=dp[x][i]+A(p-i)^2+B(p-i)+C\\ dp[y][q]&=dp[x][i]+Ap^2-2Api+Ai^2+Bp-Bi+C\end{aligned}$$

其中$x,y,p,q$都是已知确定的，而我们要使$dp[y][q]$最小，于是可以把它放在截距里，再把$i$作为自变量进行斜率优化。意会一下就是这样：

$$\mathop{\underline{(dp[x][i]+Ai^2-Bi)}}\limits_y =\mathop{\underline{(2Ap)}}\limits_k\mathop{\underline{(i)}}\limits_x+\mathop{\underline{(dp[y][q]-Ap^2-Bp-C)}}\limits_b$$

这里我们把$(i,dp[x][i]+Ai^2-Bi)$视为平面上的一个点，截距最小时，相当于有一条斜率为$2Ap$的直线从平面下方无限远处往上蹦，撞到第一个点时形成的转移。那么我们对每个$x$都维护一个下凸包，即**维护$n$个下凸包**。转移时二分找到转移点(即第一个碰到的点)，加点时同一般套路，在栈顶弹出失去贡献的点后再加点即可。

但是我们发现我们只满足了之前$min$的限制，还没有满足$i\leq p$的限制。换而言之，直接做的话凸包后面有很多不满足限制的点被提前加入了，不能够进行转移。

我们考虑枚举四元组$(x,y,p,q)$时的处理方式，其实是分成了两个操作：**计算并更新$dp[y][q]$的值、加入$(y,dp[y][q]+Aq^2-Bq)$这个点**。显然计算$dp[y][q]$时我们要做完所有$p$时刻之前的答案，并且$p$时刻之后的答案都是无用的。于是考虑将读入的四元组按$p$排序，每次计算完答案的时候不立刻加入点，而是暂存下来。**在枚举到$(x,y,p,q)$时我们先把暂存下来的$\leq p$时刻的点加入各自的凸包中，再计算$dp[y][q]$，然后暂存下新一轮的点**即可解决问题。

另外，可以发现排序后直线斜率$2Ap$是递增的，所以转移时可以不用二分，直接上单调队列。(然鹅因为要排序，复杂度没变，而且我写的$deque$比二分不知道慢到哪里去了...)

算一下复杂度：排序$O(mlog_2n)$，所有凸包加起来顶多$m$个点，每个点最多进出凸包一次$O(m)$，又由于时刻$p,q\leq 1000$，所以单个凸包里最多$1000$个点，二分$m$次，复杂度$O(mlog_2q_{max})$，最大为$O(mlog_21000)$。**总复杂度$O(mlog_2n+mlog_2q_{max})$**。

还有，因为$a^2+b^2<=(a+b)^2$以及一系列计算可以知道此题答案在$int$范围内。

总结几个斜率优化细节注意事项：
>1. 判断斜率大小时尽量把除转换成乘，防止爆精度；
>2. 加点时考虑两点横坐标相同的情况，此时不存在斜率，需特判；
>3. 凸包里有至少两个点才可进行二分，注意特判凸包中最左点或最右点。


我曾经出现过一个错误的做法：
>将四元组$(x,y,p,q)$按$q$排序，每次计算时先二分出$x$的凸包里时刻$p$之前的点，再来一次二分进行转移，加点时不用暂存，直接加即可。

然后惨烈地被第$9$个和第$19$个测试点打爆了...
>问题在于我们在做$(x,y,p,q)$的时候把时刻$q$的$dp$值加入了凸包，极有可能使得凸包中前面的点被弹出，但是后面四元组的$p$不一定大于这时的$q$，也就是说，我们可能会把有用的转移点弹走，导致答案错误。

好了，下面是代码。用$vector$实现了栈的功能来维护凸包。

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <vector>
#include <utility>
#define il inline
#define vd void
#define rg register
#define mn 100005
#define mp make_pair
#define fr first
#define sd second
#define rep(i,x,y) for(rg int i=x;i<=y;++i)
#define drp(i,x,y) for(rg int i=x;i>=y;--i)
using namespace std;
const int Len=2333333;
char buf[Len],*p1=buf,*p2=buf,duf[Len],*q1=duf;
il char gc(); il int rd(); il vd pc(char c); il vd rt(int x); il vd flush();
template<class T> il T Max(T a,T b){return a>b?a:b;}
template<class T> il T Min(T a,T b){return a<b?a:b;}
int n,m,A,B,C,cry,ans=0x7fffffff;
vector <pair<int,int> > Q[mn<<1],K[1005];
il int Wind(int y,int o,int q,int ny){
    return 1ll*(Q[y][o].sd-Q[y][o-1].sd)*(q-Q[y][o].fr)>=1ll*(ny-Q[y][o].sd)*(Q[y][o].fr-Q[y][o-1].fr);
}
il vd Push(int y,int q,int ny){
    if(!Q[y].empty()&&q==Q[y][Q[y].size()-1].fr){
        if(ny<Q[y][Q[y].size()-1].sd) Q[y].pop_back(); else return;
    }
    while(Q[y].size()>1&&Wind(y,Q[y].size()-1,q,ny)) Q[y].pop_back(); //特判横坐标相同
    Q[y].push_back(mp(q,ny));
}
struct L{
    int x,y,p,q;
    il int operator <(const L &pp)const{return p<pp.p;}
    il vd in(){x=rd(),y=rd(),p=rd(),q=rd();}
    il int Check(int o){return Q[x][o+1].sd-Q[x][o].sd>=A*p*(Q[x][o+1].fr-Q[x][o].fr)<<1;}
    il vd Work(){
        while(cry<p){
            ++cry;
            for(rg int i=0;i<(int)K[cry].size();++i) Push(K[cry][i].fr,cry,K[cry][i].sd);
        } //加点
        if(Q[x].empty()) return;
        int l=0,r=Q[x].size()-2,ps=r+1,mid;
        while(l<=r) if(Check(mid=(l+r)>>1)) ps=mid,r=mid-1; else l=mid+1; //二分
        int d=Q[x][ps].sd-(A*p*Q[x][ps].fr<<1)+A*p*p+B*p+C;
        K[q].push_back(mp(y,d+A*q*q-B*q)); // 暂存在该时刻的vector里
        if(y==n) ans=Min(ans,d+q);
    }
}l[mn<<1];
int main(){
    n=rd(),m=rd(),A=rd(),B=rd(),C=rd();
    rep(i,1,m) l[i].in();
    sort(l+1,l+m+1),Q[1].push_back(mp(0,0)); //0时刻在1号点
    rep(i,1,m) l[i].Work();
    rt(ans);
    return flush(),0;
}

il char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,Len,stdin),p1==p2)?-1:*p1++;}
il int rd(){char c;
    while(!isdigit(c=gc())&&c!='-');
    int f=c=='-'?c=gc(),1:0,x=c^48;
    while(isdigit(c=gc())) x=((x+(x<<2))<<1)+(c^48);
    return f?-x:x;
}
il vd pc(char c){q1==duf+Len&&fwrite(q1=duf,1,Len,stdout),*q1++=c;}
il vd rt(int x){x<0?pc('-'),x=-x:0,pc((x>=10?rt(x/10),x%10:x)+48);}
il vd flush(){fwrite(duf,1,q1-duf,stdout);}
```

---

## 作者：Froggy (赞：20)

## NOI数据出锅了！！

打了个玄学暴力(搜索)，大样例0.1s!

卡卡常，惊现AC

这里讲一下：

[(优秀的暴力也是一种能力)](https://www.luogu.org/recordnew/show/20948227)

跑得飞快！

edge用于存边，t二维数组用于记录第j秒跑到第i个点最少需要的烦躁值(大小约为1e8，不会炸）

把图跑一遍就行啦！！（好像是O(mt)的，但跑得真快）

上代码：：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
#define N 100010
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
const int inf=0x3fffffff;
typedef long long ll;
#define re register
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
int n,m,A,B,C,t[N][1001];
int ans=inf;
struct route{
	int to,p,q;
};
inline bool cmp(route x,route y){
	return x.p>y.p;
}
vector<route> edge[N];
inline int eva(int x,int y){
	return A*(y-x)*(y-x)+B*(y-x)+C;
}
void dfs(int u,int tim,int anger){//u记录当前节点，tim记录目前时间，anger记录目前烦躁值
	if(anger>t[u][tim])return;
	t[u][tim]=anger;
	for(re int i=0;i<edge[u].size();i++){
		int v=edge[u][i].to;
		if(edge[u][i].p<tim)break;//剪枝操作
		int an=eva(tim,edge[u][i].p);
		dfs(v,edge[u][i].q,anger+an);
	}
}
int main(){
	freopen("testdata.in","r",stdin);
	freopen("route.out","w",stdout);
	n=read();m=read();
	A=read(),B=read(),C=read();
	for(re int i=1;i<=m;i++){
		int u=read(),v=read(),p=read(),q=read();
		route r;
		r.to=v;
		r.p=p,r.q=q;
		edge[u].push_back(r);
	}
	for(re int i=1;i<=n;i++){
		sort(edge[i].begin(),edge[i].end(),cmp);//按p值排序，用于以后的剪枝
	}
	for(re int i=1;i<=n;i++){
		for(re int j=0;j<=1000;j++){
			t[i][j]=inf;
		}
	}
	dfs(1,0,0);
	for(int i=0;i<=1000;i++){
		ans=min(ans,t[n][i]+i);
	}
	cout<<ans<<endl;//快乐的输出
	return 0;
}


```

代码短了一匹，

###### 呵呵。。

据说正解是斜率优化dp，反正窝不会qwq


---

## 作者：一扶苏一 (赞：13)


## Solution

好像正解是以时间为状态DP来着……然而拿到这个题的第一反应是DP每条边到 $n$ 的贡献。

考虑设 $f_i$ 是第 $i$ 条边开始出发，到达 $n$ 号节点对烦躁值的最小贡献。于是有转移方程：

$$f_i = \min_{p_j \geq q_i} ^{x_j = y_i} \{f_j + A (p_j - q_i)^2 + B(p_j - q_i) + C + p_j - q_i\} + q_i - p_i$$

即

$$f_i = \min_{p_j \geq q_i} ^{x_j = y_i} \{f_j + A p_j^2 - 2Ap_jq_i + Aq_i^2 + Bp_j - Bq_i + C + p_j - q_i\} + q_i - p_i$$

将与 $j$ 无关的项提出大括号，得到

$$f_i = \min_{p_j \geq q_i} ^{x_j = y_i} \{f_j + A p_j^2 - 2Ap_jq_i  + Bp_j + p_j \} + q_i - p_i+ Aq_i^2- q_i- Bq_i + C $$

整理得

$$f_i = \min_{p_j \geq q_i} ^{x_j = y_i} \{f_j + A p_j^2 - 2Ap_jq_i  + (B+1)p_j\} + Aq_i^2- Bq_i + C- p_i $$

设 $g_i = A q_i^2 - Bq_i - p_i + C$，$h_i = Ap_i^2 + (B+1)p_j$

上式即为

$$f_i = f_j + h_j - 2Ap_jq_i + g_i$$

移相得到

$$f_j + h_j = 2Aq_iq_j + f_i - g_i$$

注意到 $g_i$ 是一个与 $i$ 有关的常数，那么最小化 $f_i$ 只需要最小化 $f_i + g_i$

如果将 $f_j + h_j$ 看作纵坐标， $q_j$ 看作横坐标，上述方程可以看成一条斜率为常数 $2Aq_i$ 的直线，在所有满足条件的 $j$ 中选择一个点，使得直线过这个点，最小化直线在 $y$ 轴上的截距 $f_i + g_i$。

那么所有满足条件的点显然在一个下突壳上，证明上可以考虑如果一个点不在下突壳上那么能找到一个更优的 $j$。

然后考虑如果 $i$ 会从 $j$ 转移过来，那么一定有 $q_i \leq p_j$，又因为 $p_j < q_j$，因此 $q_i < q_j$，于是按照 $q$ 的不升序进行排序即可。

在转移时，只需要在每个点维护一个凸壳表示所有可能被选择的点，然后再维护一个 ``set`` 记录该点上已经被计算但是没有插入凸壳的点。``set`` 内部按照 $p$ 的不升序排序，每次要转移一条边 $i$ 的时候先将终点中 $p$ 不小于 $q_i$ 的边插入凸壳，由于转移是按照 $q_i$ 的顺序进行的，已经被插入凸壳的点一定是合法可以转移的。

另外注意到 $q_i$ 是单调不升的，于是斜率 $2Aq_i$ 也是单调升的，再考虑到插入的横轴 $p_j$ 也是单调不升的，因此可以使用单调队列维护每个点的凸壳即可。

需要注意的一点细节是凸壳的横轴是从大到小插入的，在维护的时候不要把大于号小于号写反。

一共进行了 $m$ 次转移，每次转移复杂度 $O(1)$，因此 DP 过程的时间复杂度是 $O(m)$，但是由于进行了排序，且每条边插入在 ``set`` 中 1 次，所以整个算法的时间复杂度 $O(m \log m)$。

## Code

```cpp
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>

const int maxn = 200005;
const ll INF = 1ll << 50;

int n, m;
ll A, B, C, ans;
ll frog[maxn], g[maxn], h[maxn];

struct M {
  int x, y, p, q;

  inline bool operator<(const M &_others) const {
    return this->q > _others.q;
  }
};
M MU[maxn];

struct Cmp {
  inline bool operator() (const int &_a, const int &_b) {
    if (MU[_a].p != MU[_b].p) {
      return MU[_a].p > MU[_b].p;
    } else {
      return _a < _b;
    }
  }
};

std::deque<int>Q[maxn];
std::set<int, Cmp>s[maxn];

int query(const int x);
void free(const int x, const int y);
void insert(const int x, const int y);

signed main() {
  freopen("route.in", "r", stdin);
  freopen("route.out", "w", stdout);
  qr(n); qr(m); qr(A); qr(B); qr(C);
  for (int i = 1; i <= m; ++i) {
    qr(MU[i].x); qr(MU[i].y); qr(MU[i].p); qr(MU[i].q);
  }
  frog[m + 1] = 1ll << 50;
  std::sort(MU + 1, MU + 1 + m);
  for (int i = 1; i <= m; ++i) {
    g[i] = A * MU[i].q * MU[i].q - B * MU[i].q -  MU[i].p + C;
    h[i] = A * MU[i].p * MU[i].p + (B + 1) * MU[i].p;
  }
  for (int i = 1; i <= m; ++i) if (MU[i].y == n) {
    frog[i] = MU[i].q - MU[i].p;
    s[MU[i].x].insert(i);
  } else {
    int y = MU[i].y;
    free(y, MU[i].q);
    int j = query(i);
    if (!j) {
      frog[i] = INF;
      continue;
    }
    frog[i] = frog[j] + g[i] + h[j] - ((A * MU[i].q * MU[j].p) << 1);
    s[MU[i].x].insert(i);
  }
  ans = 1ll << 50;
  for (int i = 1; i <= m; ++i) if (MU[i].x == 1) {
    ans = std::min(frog[i] + A * MU[i].p * MU[i].p + B * MU[i].p + C + MU[i].p, ans);
  }
  qw(ans, '\n', true);
  return 0;
}

void free(const int x, const int y) {
  while (!s[x].empty()) {
    auto u = *s[x].begin();
    if (MU[u].p >= y) {
      insert(x, u);
      s[x].erase(u);
    } else {
      break;
    }
  }
}

inline std::pair<ll, ll> calc(const int x) {
  return std::make_pair(frog[x] + h[x], 1ll * MU[x].p);
}

inline bool judge(const int x, const int y, const int z) {
  auto i = calc(x), j = calc(y), k = calc(z);
  return (k.first <= j.first) && ((i.first - k.first) * (i.second - j.second) < (i.first - j.first) * (i.second - k.second));
}

void insert(const int x, const int y) {
  while (Q[x].size() > 1) {
    int i = Q[x].back(); Q[x].pop_back(); int j = Q[x].back();
    if (judge(j, i, y)) {
      Q[x].push_back(i); break;
    }
  }
  Q[x].push_back(y);
}

int query(const int p) {
  int x = MU[p].y;
  while (Q[x].size() > 1) {
    int i = Q[x].front(); Q[x].pop_front(); int j = Q[x].front();
    auto s = calc(i), t = calc(j); ll k = ((A * MU[p].q) << 1);
    if ((k * (s.second - t.second)) > (s.first - t.first)) {
      Q[x].push_front(i);
      break;
    }
  }
  return Q[x].size () ? Q[x].front() : 0;
}
```

---

## 作者：BFqwq (赞：10)

### 暴力

首先，看到这个题我们可以很轻松的想到一个暴力。

令 $f_i$ 为如果要经过第 $i$ 条边则在此之前需要的花费最少为多少。

一个显然的方程式是：

$$f_i=\min(f _j+A\times (p_i-q_j)^2+B\times (p_i-q_j)+C)$$

其中 $j$ 是满足 $y_j=x_i$ 且 $q_j\le p_i$ 的边。

（这边的 $x,y,p,q,A,B,C$ 变量含义全部与题目相同）

我们可以通过将一条边分为出和入两步来更新，从而消除时间顺序的问题。

理论复杂度为 $\operatorname{O}(m^2)$ ，实际上卡不满。

### 决策单调性

当我们看到这样的一个转移方程式时，我们一定会想到：这个题与决策单调性有关。

令 $w_{q_j,p_i}$ 为从 $j$ 转移到 $i$ 的费用，即 $A\times (p_i-q_j)^2+B\times (p_i-q_j)+C)$。

我们可以证明，对于边 $i_1,i_2$ 如果有 $x_{i1}=x_{i2}$ 且 $p_{i1}\le p_{i2}$，

设两条边的最优决策点分别为 $j_1,j_2$，则 $q_{j1}\le q_{j2}$。

决策单调性的证明一般使用四边形不等式，但在考场上更多使用打表或是盲猜的方法。

对于不知道四边形不等式的同学，建议阅读[这篇博客]( https://www.cnblogs.com/a1b3c7d9/p/10984353.html )。

当然也可以选择直接记住一个结论：

若某个方程式 $f_i=\min(f_j+w_{i,j})$的转移费用满足 $w_{a,b}+w_{a+1,b+1}\le w_{a+1,b}+w_{a,b+1}$ 时，

该方程的最优决策点（即最佳的 $j$）随 $i$ 非严格单调递增，即满足决策单调性。

那么接下来，我们来证明一下这个题的决策单调性。

$$w_{a,b}+w_{a+1,b+1}\le w_{a+1,b}+w_{a,b+1}$$

$$\Leftrightarrow A\times(a-b)^2+B\times(a-b)+C+A\times(a+1-b-1)^2+B\times(a+1-b-1)+C$$

$$\le A\times (a+1-b)^2+B\times (a+1-b)+C+a\times (a-b-1)^2+B\times (a-b-1)+C$$

$$\Leftrightarrow 2\times A(a-b)^2\le A\times (a+1-b)^2+A\times (a-b-1)^2$$

令 $t=a-b$ 

$$\Leftrightarrow 2\times At^2\le A(t+1)^2+A(t-1)^2$$

$$RHS=2At^2+2A\ge 2At^2=LHS$$ 

证毕。

顾可知，这一方程满足决策单调性，即满足对于边 $i_1,i_2$ 如果有 $x_{i1}=x_{i2}$ 且 $p_{i1}\le p_{i2}$，

设两条边的最优决策点分别为 $j_1,j_2$，则有 $q_{j1}\le q_{j2}$。

### 斜率优化

斜率优化是决策单调性的一个高级应用，一般在 $f$ 方程仅有一个维度时有效。

不会斜率优化的同学这里推荐一下[辰星凌大佬的博客]( https://www.cnblogs.com/Xing-Ling/p/11210179.html )。

我们来考虑对于 $ f_i$ 而言，决策点 $j_1$ 比 $j_2$ （$q_{j_1}\ge q_{j_2}$）更优需要满足什么条件。

将方程式展开后移项，得到

$$f_i-Ap_i^2-Bp_i-C=f_j+Aq_j^2-2Ap_iq_j-Bq_j$$

这样移项的好处是，有关于 $j$ 的项全部被移到了右边。

由于 $i$ 是我们已经确定的，所以 $p_i$ 可以看作常量。

根据方程式可知，若 $j_1$ 比 $j_2$ 更优，则需满足

$$f_{j_1}+Aq_{j_1}^2-2Ap_iq_{j_1}-Bq_{j_1} \le f_{j_2}+Aq_{j_2}^2-2Ap_iq_{j_2}-Bq_{j_2}$$

$$\Leftrightarrow 2Ap_i(q_{j_1}-q_{j_2})\ge (f_{j_1}+Aq_{j_1}^2-Bq_{j_1})-(f_{j_2}+Aq_{j_2}^2-Bq_{j_2})$$

令

$$X(a)=q_a$$

$$Y(a)=f_{a}+Aq_{a}^2-Bq_{a}$$

$$K(a)=2\times A\times p_i$$

$$B(a)=f_i-Ap_i^2-Bp_i-C$$

于是我们就得到了一个斜率优化的形式。

当 $i$ 固定时，我们 $K(i)$ 也就固定了。

而我们的目标就是让  $B(i)$ 越小越好。

因此，只要 $j_1,j_2 $ 满足

$$K(i)\ge \frac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$$

也就是 $K(i )$ 大于 $(X(j_1),Y(j_1))$ 与 $(X(j_2),Y(j_2))$ 组成的直线，则 $j_1$ 优于 $j_2 $。

这其实非常好理解。当 $K(i)<\frac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$ 时，设 $B$ 点为 $(X(j_1),Y(j_1))$，$A$ 点为 $(X(j_2),Y(j_2))$，

则我们画出来的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/xx5epmov.png)

显然此时让直线经过 $A$ 点更优。

而当 $K(i)\ge \frac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$ 时，图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/nok4ca8p.png)

显然选择 $B$ 点更优。

又由于我们证明了决策单调性，因此从此以后 $A$ 点（也就是 $j_2$） 再无用处。

如果我们用一个双端队列来维护也许有效的决策点，那么这时我们就可以将 $j_2$ 出队。

接着，我们再来考虑什么样的点需要放入队列中。

![](https://cdn.luogu.com.cn/upload/image_hosting/dfhsh30p.png)

对于这样的情况，我们发现，无论所求直线的 $K(i)$ 是多少，$B$ 都不会成为最优决策点，

因此我们就可以将 $B$ 出队。

准确的说，当 $\frac{Y(A)-Y(B)}{X(A)-X(B)}\ge \frac{Y(A)-Y(C)}{X(A)-X(C)}$ 时，$B$ 点就不会成为最优决策点，

因为当 $K(i)<\frac{Y(A)-Y(C)}{X(A)-X(C)}$ 时 $A$ 比 $B$ 更优，否则 $C$ 比 $B$ 更优。

其实如果我们把队列中的所有点画出来，应该是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/fqdq93by.png)

### Code

```cpp
#include <bits/stdc++.h>
#define ll long long
#define X(T) (q[T])
#define Y(T) (f[T]+a*q[T]*q[T]-b*q[T])
#define K(T) (2*a*p[T])
#define B(T) (f[T]-a*p[T]*p[T]-b*p[T]-c)
//一个好习惯，也方便直接调用
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(register ll x,register char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=200001;
int n,m,a,b,c,mx;
int p[maxn],q[maxn],u[maxn],v[maxn];
ll f[maxn],ans=114514191981000000ll;
int tl,tl2,he,he2,sz;
deque<int> d[maxn];
//stl 自带双端队列，也可以用 vector 实现
deque<int>::iterator it;
vector<int> st[1001];
vector<int> ed[1001];
//st,ed 分别为某一时刻的出发与到达数组
double slope(int qa,int qb){
    return (1.0*(Y(qa)-Y(qb)))/(1.0*(X(qa)-X(qb)));
    //求斜率
}
signed main(){
//	freopen("route.in","r",stdin);
//	freopen("route.out","w",stdout);
	n=read();m=read();a=read();b=read();c=read();
	for(int i=1;i<=m;++i){
		u[i]=read();v[i]=read();p[i]=read();q[i]=read();
		if(u[i]==n) continue;
		mx=max(mx,q[i]);
		st[p[i]].push_back(i);
		f[i]=1233333333ll;
        //初始化
	}
	d[1].push_back(0);
	f[1]=0;
	for(int i=0;i<=mx;i++){
		for(int j:ed[i]){
            //枚举第 i 时刻到达的边
			sz=d[v[j]].size();
			if(sz==0) {
				d[v[j]].push_back(j);
				continue;
			}
			it=d[v[j]].end();
			it--;
			tl=*it;
			while(sz>1){
				it--;tl2=*it;
                //tl 为队尾，tl2 为队尾第二个数
				if(slope(tl,tl2)<slope(j,tl2)){
					break;
                    //tl2 可能更优
				}
                //j 一定更优，弹出 tl2
				tl=tl2;sz--;
				d[v[j]].pop_back();
			}
			d[v[j]].push_back(j);
		}
		for(int j:st[i]){
            //枚举第 i 时刻出发的边
			sz=d[u[j]].size();
			if(sz==0) continue;
            //这条边出发之前无法到达该点，故这条边无效
			it=d[u[j]].begin();he=*it;
			while(sz>1){
				it++;he2=*it;
                //he 为队首，he2 为队首第二个数
				if(slope(he2,he)>K(j)){
					break;
				}
                //比较一下那条边更优，如果 he2 可以取代 he 则出队
                //此时队首就是最优决策点了
				he=he2;sz--;
				d[u[j]].pop_front();
			}
			f[j]=f[he]+a*(p[j]-q[he])*(p[j]-q[he])+b*(p[j]-q[he])+c;
            //更新 f 函数
			if(v[j]==n) ans=min(ans,f[j]+q[j]);
			ed[q[j]].push_back(j);
		}
	}
	print(ans);
	return 0;
}
```



---

## 作者：zwjdd (赞：6)

蒟蒻竟然能过一题，可能数据比较水qwq

我们选择dp

$f[i][j]$ 表示 在 时间 $j$ 到达 $i$ 点 最小的烦躁值

所以$f[edge[i].y][edge[i].q]=min$($f[edge[i].x][j]+val(edge[i].p-j$ ) )

记得按结束时间排序，不然会出现继承问题

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
const int maxn = 4001;
const int INF = 2147483647;
const int maxtime = 1001;

struct node
{
	int from,to,next,st,en;
}edge[2*maxn];
int cnt;
int n,m,a,b,c;
long long f[maxn][maxtime];
int tmax = -INF;

void add(int from,int to,int st,int en)
{
	edge[++cnt].to=to;
	edge[cnt].from=from;
	edge[cnt].st=st;
	edge[cnt].en=en;
}

bool cmp1(node a,node b){return a.en<b.en;}

int val(int x){return a*x*x+b*x+c;}

int main()
{
	scanf("%d%d%d%d%d",&n,&m,&a,&b,&c);
	memset(f,-1,sizeof(f));
	for(int i=1;i<=m;i++)
	{
		int x,y,st,en;
		scanf("%d%d%d%d",&x,&y,&st,&en);
		
		if(x==1)
			f[y][en]=val(st);
		else add(x,y,st,en);
		tmax=max(tmax,en);
	}
	sort(edge+1,edge+1+cnt,cmp1);
	
	for(int i=1;i<=m;i++)
	{
		
		int from=edge[i].from,to=edge[i].to，st=edge[i].st，en=edge[i].en;
		for(int j=1;j<=st;j++)
		{
			if(f[from][j]!=-1)
			{
				if(f[to][en]!=-1)f[to][en]=min(f[to][en],f[from][j]+val(st-j));
				else f[to][en]=f[from][j]+val(st-j);
			}
		}
	}
	int ans=INF;
	for(int i=1;i<=tmax;i++)
	{
		if(f[n][i]!=-1)
		ans=min(ans,f[n][i]+i);
	}
	cout<<ans;
}
```


---

## 作者：水库中的水库 (赞：6)

安利一下博客:[戳我](http://ljf-cnyali.cn/2019/07/16/NOI2019%E5%9B%9E%E5%AE%B6%E8%B7%AF%E7%BA%BF-DP/)

### 思路历程

* 首先看到题目立刻想到最短路，可以建边然后在正常的最短路上加一维$dis[i][j]$表示到达站点$i$时间为$j$的最小烦躁值，然后想了一下建边最差$m^2$，再加上一个最短路会跑得很慢一点都不稳定(我们机房有人写了~~85~~或~~95~~，一脸忧郁)
* 接下来发现DFS可能很优秀...(谁知道可以跑~~满分~~)，但是因为复杂度太玄学不敢乱搞

* 考虑DP，我们令$dp[i][j]$同样表示站点$i$时间为$j$的最小烦躁值，然后考虑枚举$i$从$[1,m]$，$j$从$[0,a[i].p)$，然后对于有方程$dp[a[i].y][a[i].q]=min(dp[a[i].x][j]+js(j,a[i].p))$其中$js$为题目中的方程
* 发现这个算法显然是有后效性的，因为可以从后面的站点移动到前面的站点，即$a[i].x>a[i].y$
* 可以思考以$a[i].q$从小到大排序，这样就不会有后效性的问题，因为前面的时间不会对后面的造成影响，时空复杂度均为$O(mt)$，这样就完美的获得70分的好成绩
* 考虑算法瓶颈在于空间复杂度过高，开$long long$会导致$800MB$的空间，我们需要优化空间复杂度
* 因为发现会有很多无效的空间损耗($dp$数组中有很多点是$INF$的)，则使用$vector$进行数组优化，我们开一个$10^5$的$vector$，对于每一个$vector$存两个值$pos$和$val$，$pos$表示原$dp[i][j]$中的$j$，而$val$表示原$dp[i][j]$的值，在枚举$j$从$[p,a[i].p)$的时候修改为枚举$dp[i].size()$，然后进行修改即可

接下来喷一下这道题，刚刚发现这道题不会爆$int$，所以70分算法就是正解了，然后再次发现dijsktra它死了，spfa它活了(dijkstra爆栈什么鬼)，再然后我也不知道放DFS过什么鬼，菊花图不会造？今年NOI真的太令人失望了，真的鬼畜...

### 代码

```cpp
// luogu-judger-enable-o2
/***************************************************************
    File name: route.cpp
    Author: ljfcnyali
    Create time: 2019年07月16日 星期二 08时46分17秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( register LL i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 
typedef long long LL;

const int maxn = 100010;
const LL INF = 10000000000000;

LL n, m, A, B, C, s, t, Max, ans;

struct node
{
    LL x, y, p, q;
    bool operator < (const node &a) const { return q < a.q; }
} a[maxn << 1];

struct Node
{
    LL pos, val;
} p1, p2;

vector<Node> dp[maxn];

inline LL js(LL x, LL y) { LL t = y - x; return t * t * A + t * B + C; }

int main()
{
#ifndef ONLINE_JUDGE
    freopen("route.in", "r", stdin);
    freopen("route.out", "w", stdout);
#endif
    scanf("%lld%lld%lld%lld%lld", &n, &m, &A, &B, &C);
    REP(i, 1, m) { scanf("%lld%lld%lld%lld", &a[i].x, &a[i].y, &a[i].p, &a[i].q); Max = max(Max, a[i].q); }
    sort(a + 1, a + m + 1);
    REP(i, 1, m) 
        if ( a[i].x == 1 ) 
        {
            bool flag = false;
            REP(j, 0, dp[a[i].y].size() - 1)
            {
                p1 = dp[a[i].y][j];
                if ( p1.pos == a[i].q ) 
                {
                    p1.val = min(p1.val, a[i].p * a[i].p * A + a[i].p * B + C);
                    dp[a[i].y][j] = p1;
                    flag = true;
                    break ;
                }
            }
            if ( flag == false ) 
            {
                p1.pos = a[i].q; p1.val = a[i].p * a[i].p *A + a[i].p * B + C;
                dp[a[i].y].push_back(p1);
            }
        }
    REP(i, 1, m)
    {
        if ( a[i].x == 1 ) continue ;
        bool flag = false;
        REP(j, 0, dp[a[i].y].size() - 1)
        {
            p1 = dp[a[i].y][j];
            if ( p1.pos == a[i].q ) 
            {
                REP(k, 0, dp[a[i].x].size() - 1)
                {
                    p2 = dp[a[i].x][k];
                    if ( p2.pos > a[i].p ) continue ;
                    p1.val = min(p1.val, p2.val + js(p2.pos, a[i].p));
                }
                dp[a[i].y][j] = p1;
                flag = true; break ;
            }
        }
        if ( flag == false ) 
        {
            p1.pos = a[i].q; p1.val = INF;
            REP(k, 0, dp[a[i].x].size() - 1) 
            {
                p2 = dp[a[i].x][k];
                if ( p2.pos > a[i].p ) continue ;
                p1.val = min(p1.val, p2.val + js(p2.pos, a[i].p));
            }
            dp[a[i].y].push_back(p1);
        }
        // dp[a[i].y][a[i].q] = min(dp[a[i].y][a[i].q], dp[a[i].x][j] + js(j, a[i].p));
    }
    ans = INF;
    REP(i, 0, dp[n].size() - 1) ans = min(ans, dp[n][i].val + dp[n][i].pos);
    printf("%lld\n", ans);
    return 0;
}
```


---

## 作者：封禁用户 (赞：5)

**[$NOI2019D1T1$回家路线](https://www.luogu.org/problem/P5468)**

[此处阅读体验更佳哦](https://www.cnblogs.com/wo-shi-zhen-de-cai/p/11015133.html)

据说……这道题被许多人嘲讽为水题，可我不这么想啊（果真是因为我太弱了吗……

但考场上就真的要……$WOC$你给我解释一下$O_{(mt)}$都能过是什么情况啊！！

你确定你真的不是用脚在造数据？！

**正解**（你别给老子想什么暴力卡常）：斜率优化$DP$，推方程完全不难，设$f[i]$为最后乘编号为$i$的车的最小烦躁值，转移方程为：$f[i]=min(f[j]+A*(p_i-q_j)^2+B*(p_i-q_j)+C)$

决策点为$(q_i,f[j]+A*q_j^2-B*q_j)$，当$j$比$k$更优时，满足：$\frac{f[j]-f[k]+A*(q_j^2-q_k^2)-B*(q_j-q_k)}{q_j-q_k}<2*A*p_i$

但是，我们转移时要满足$p_i>=q_j,y_j=x_i$，所以我们不能像以前一样维护一个凸包，从所有的决策中转移。

仔细思考一下，我们的决策来自部分满足条件的前面已经做出的决策，不妨我们对决策按$i$到达的位置分个组。

即在每个节点处维护一个凸包（这样一定满足单调性，不解释了），凸包中的点为$f[j]$（$j$为目的地为该节点的列车编号），这样我们转移时就可以满足空间限制了。

再考虑时间限制怎么做，我们可以枚举时间，再开一个等待队列，存在$q[i]$时到的列车$i$，但他们不能被利用，因为还没枚举到他们的到达时间，然后枚举到时间$t$时，将等待队列中所有到达时间为$t$的列车加进相应的凸包中（并维护凸包的单调性），说明他们可以被利用来转移。

最后在每次转移后将该次转移加入等待队列中，判断是否到达$n$，如果到达，就更新答案（记得加上$q_i$）

给泥萌看我丑陋的代码：

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define S(x) ((x)*(x))
inline int read()
{
    int f=1,w=0;char x=0;
    while(x<'0'||x>'9') {if(x=='-') f=-1; x=getchar();}
    while(x!=EOF&&x>='0'&&x<='9') {w=(w<<3)+(w<<1)+(x^48);x=getchar();}
    return w*f;
}
const int N=200010,M=1001;
queue<int> res[M];
int n,m,A,B,C,MaxT,ans=1e18;
vector<int> Tbg[M],Q[N];
int q[N],p[N],x[N],y[N],head[N],f[N];
inline double K(int j,int k)
{
	return (double)(f[j]-f[k]+A*(S(q[j])-S(q[k]))-B*(q[j]-q[k]))/(double)(q[j]-q[k]);
}
main(){
#ifndef ONLINE_JUDGE
    //freopen("A.in","r",stdin);//Ans=94;
	freopen("B.in","r",stdin);//Ans=34;
#endif
	n=read(),m=read(),A=read(),B=read(),C=read();
	for(int i=1;i<=m;i++)
	{
		x[i]=read(),y[i]=read(),p[i]=read();
		q[i]=read(),Tbg[p[i]].push_back(i);
		MaxT=max(MaxT,q[i]);
	}
	Q[1].push_back(0);
	for(int t=0;t<=MaxT;t++)
	{
		while(!res[t].empty())
		{
			int pos=y[res[t].front()];
			while(Q[pos].size()-head[pos]>=2)
			{
				int len=Q[pos].size();
				if(K(Q[pos][len-1],Q[pos][len-2])<K(Q[pos][len-2],res[t].front())) break;
				Q[pos].pop_back();
			}
			Q[pos].push_back(res[t].front()),res[t].pop();
		}
		for(int i=0;i<(int)Tbg[t].size();i++)
			if((int)Q[x[Tbg[t][i]]].size()>head[x[Tbg[t][i]]])
			{
				int id=Tbg[t][i],pos=x[id];
				while((int)Q[pos].size()-head[pos]>=2)
				{
					if(K(Q[pos][head[pos]],Q[pos][head[pos]+1])>2.0*A*p[id]) break ;
					head[pos]++;
				}
				int j=Q[pos][head[pos]];
				f[id]=f[j]+A*S(p[id]-q[j])+B*(p[id]-q[j])+C;
				res[q[id]].push(id);if(y[id]==n) ans=min(ans,f[id]+q[id]);
			}
	}
	printf("%lld",ans);
}
```



---

## 作者：Yanzy2333 (赞：5)

当时打同步赛时用的暴力dfs，才95分，WA掉1个点。后来想了想，这题可以用SPFA最短路过。

设$dis[x][y]$表示在$x$时间，从$1$站点到$y$站点的最小烦躁值，就可以用SPFA来做啦~

具体分析看代码：

---

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int n,m,aa,bb,cc;
int anss=999999999;
struct T{
	int u;
	int v;
	int st;
	int ed;//st是开始时间，ed是到达时间
	bool operator <(const T& a) const {
		return u<a.u;
	}//暴力时用的，懒得删掉。
}tr[200010];
int nxt[200010],fst[100010];
bool bo[1001][100001];//标记时间x，站点y有没有到达过。
int dis[1001][100001];//
queue<int>q;//spfa队列，存点
queue<int>tim;//存时间
inline int hs(int x){
	return aa*x*x+bb*x+cc;
}//算烦躁值
int main() {
	memset(dis,0x7f,sizeof(dis));
	scanf("%d%d%d%d%d",&n,&m,&aa,&bb,&cc);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&tr[i].u,&tr[i].v,&tr[i].st,&tr[i].ed);
		nxt[i]=fst[tr[i].u];
		fst[tr[i].u]=i;//邻接表存图
	}
	q.push(1);
	tim.push(0);
	bo[0][1]=1;
	dis[0][1]=0;//初始化
	while(!q.empty()){
		int x=q.front();
		int ti=tim.front();
		q.pop();
		tim.pop();
		bo[ti][x]=0;
		for(int k=fst[x];k;k=nxt[k]){
			if(tr[k].st<ti) continue;
			if(tr[k].v==n){//判断一下，如果到达n站点还要加上当前时间
				if(dis[tr[k].ed][tr[k].v]>dis[ti][x]+hs(tr[k].st-ti)+tr[k].ed){
					dis[tr[k].ed][tr[k].v]=dis[ti][x]+hs(tr[k].st-ti)+tr[k].ed;
					if(!bo[tr[k].ed][tr[k].v]){
						bo[tr[k].ed][tr[k].v]=1;
						q.push(tr[k].v);
						tim.push(tr[k].ed);
					}
				} 
			}
			else {
				if(dis[tr[k].ed][tr[k].v]>dis[ti][x]+hs(tr[k].st-ti)){//如果在当前火车到达的时间到tr[k].v站点的最小烦躁值大于当前站点的烦躁值，就可以松弛。
					dis[tr[k].ed][tr[k].v]=dis[ti][x]+hs(tr[k].st-ti);
					if(!bo[tr[k].ed][tr[k].v]){
						bo[tr[k].ed][tr[k].v]=1;
						q.push(tr[k].v);
						tim.push(tr[k].ed);
					}
				} 	
			}
		}
	}
	anss=999999999;
	for(int k=1;k<=m;k++){
		if(tr[k].v==n){
			anss=min(anss,dis[tr[k].ed][n]);
		}//判断一下，因为可能有很多个时刻都可以到达终点，需要取最小值。
	}
	cout<<anss;//输出
	return 0;
}

```

---

---

## 作者：xgzc (赞：3)

同步赛时看到$m \leq 2\times 10 ^ 5, q_i \leq 1000$的我灵光一闪，交了个$\mathrm{O}(mt)$的大暴力然后$\mathrm{AC}$此题

设$f[i][j]$表示当前在第$i$个站点，时刻为$j$的最小烦躁度，$F(x) = Ax^2 + Bx + C$。

然后枚举每一条边$i$，可以得到：$f[y_i][j] = \min\{f[x_i][p_i] + F(j - q_i)\}$。

直接$\mathrm{DP}$即可。

```cpp
#include <cstdio>
#include <algorithm>

inline int read()
{
	int data = 0, w = 1; char ch = getchar();
	while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if (ch == '-') w = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();
	return data * w;
}

const int maxn(1e5 + 10), maxm(2e5 + 10), T(1010), INF(0x3f3f3f3f);
int n, m, A, B, C, maxQ, f[maxn][T];
struct node { int x, y, p, q; } L[maxm];
inline int operator < (const node &lhs, const node &rhs) { return lhs.q < rhs.q; }
inline int F(int x) { return x * x * A + x * B + C; }

void solve()
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= maxQ; j++) f[i][j] = INF;
	for (int j = 0; j <= maxQ; j++) f[1][j] = F(j);
	for (int i = 1; i <= m; i++)
	{
		int x = L[i].y;
		for (int j = L[i].q; j <= maxQ; j++)
			f[x][j] = std::min(f[x][j], f[L[i].x][L[i].p] + F(j - L[i].q));
	}
	int ans = INF;
	for (int j = 1; j <= maxQ; j++)
		ans = std::min(ans, f[n][j] + j - C);
	printf("%d\n", ans);
}

int main()
{
	n = read(), m = read(), A = read(), B = read(), C = read();
	for (int i = 1; i <= m; i++) L[i] = (node) {read(), read(), read(), read()};
	for (int i = 1; i <= m; i++) maxQ = std::max(maxQ, L[i].q);
	std::sort(L + 1, L + m + 1), solve();
	return 0;
}
```

---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P5468)看题目。  
# 分析
### 暴力方法1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于时间比较小，所以我们建分层图跑$Dijkstra$，一层图就是时间刻度上的一个剖面。据说在考场上可以过（！！！），但是洛谷.....太狠了。  
### 暴力方法2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也许你想到了$DP$？  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于时间比较小，所以我们可以这样写状态：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP(j, i)$：$j$时刻在$i$站上的最小的烦躁值。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难看出，由于$\forall i, p_i<q_i$，所以我们先把列车按照终止时间排一波序，这样$DP$就是有序的了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移方程长这个样子：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\forall i\in[1,m],\forall j\in[0,p_i], DP(j,x_i)=\min\{DP(q_i,y_i)+A(p_i-j)^2+B(p_i-j)+C\}$  
### 可行的暴力解法  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;交上去之后你就会发现$DP\ MLE$了。空间复杂度是$O(nt)$的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而我们发现，$DP$中其实有非常多的无用的状态。考察我们的$DP$方程，只有列车的发车时间和到站时间是有用的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们只需要对这些时间进行$DP$就可以了。计算一下，空间降到了$O(2m)$......吧。~~我算不清楚这种东西~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间还是$O(m\log_2m+mt)$。  
### 正解  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP$方程中的花费比较特殊，是二次结构，所以可以考虑斜率优化。时间是$O(m\log_2m)$（全是排序的时间）。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~于是我还是写的可行的暴力。~~  
# 代码
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long LL;

#ifdef _DEBUG
const int MAXN = 15, INF = 1e3;
#else
const int MAXN = 1e5 + 5, INF = 0x3f3f3f3f;
#endif
const int MAXT = 1e3 + 5, MAXM = 2e5 + 5; 

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

vector<int> vec[MAXN], t[MAXN];

vector<int> DP[MAXN];
int seq[MAXM];
int x[MAXM], y[MAXM], p[MAXM], q[MAXM];
int N, M, A, B, C;

bool cmp( const int &x, const int &y ) { return p[x] < p[y]; }
int f( const int x ) { return 1ll * A * x * x + 1ll * B * x + C; }

int main()
{
	int mx = -1;
	read( N ), read( M ), read( A ), read( B ), read( C );
	for( int i = 1 ; i <= M ; i ++ )
		seq[i] = i, read( x[i] ), read( y[i] ), read( p[i] ), read( q[i] ), mx = MAX( mx, q[i] ), 
		vec[x[i]].push_back( p[i] ), vec[y[i]].push_back( q[i] );
	sort( seq + 1, seq + 1 + M, cmp );
	vec[1].push_back( 0 );
	for( int i = 1 ; i <= N ; i ++ )
	{
		sort( vec[i].begin(), vec[i].end() );
		if( vec[i].empty() ) continue;
		t[i].push_back( vec[i][0] );
		for( int j = 1 ; j < vec[i].size() ; j ++ )
			if( vec[i][j] ^ vec[i][j - 1] )
				t[i].push_back( vec[i][j] );
//		for( int j = 0 ; j < t[i].size() ; j ++ )
//			write( t[i][j] ), putchar( ' ' );
//		puts( "" );
	}
	for( int i = 0 ; i < t[N].size() ; i ++ ) 
		DP[N].push_back( t[N][i] );
	for( int i = 1 ; i < N ; i ++ )
		for( int j = 0 ; j < t[i].size() ; j ++ )
			DP[i].push_back( INF );
	for( int i = M, u, z ; i ; i -- )
	{
		u = seq[i];
		for( z = 0 ; z < t[y[u]].size() && t[y[u]][z] < q[u] ; z ++ );
		for( int j = 0 ; j < t[x[u]].size() && t[x[u]][j] <= p[u] ; j ++ )
			DP[x[u]][j] = MIN( DP[x[u]][j], DP[y[u]][z] + f( p[u] - t[x[u]][j] ) );
	}
	write( DP[1][0] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：nofind (赞：2)

第一篇NOI题解,思路讲的很明白,求过了~
------------
题意：https://www.luogu.org/problemnew/show/P5468

做法分层图最短路

首先如果没有这句就可以直接spfa：若小猫最终在时刻z到达n号站点，则烦躁值将再增加z

然而有了这句话我们的答案就和到达时间T和路上烦躁值和W两个变量相关,使得问题无法处理

这时我想到了一道考试DP题,也是答案和两个变量相关,做法是把第二个变量的取值另开一维记录下来,最后枚举第二个变量的取值更新答案

我们应用到这道题上：

将dis数组扩展：dis[i][j]表示从1到i,用了j时间的最小烦躁值,最后将连向n的边枚举,ans=min(ans,dis[n][e[i].q]+e[i].q)

转移就是正常的松弛操作,注意判一下开车时间与当前时间的大小,如果到之前就开车了就continue

这其实是分层图最短路,可理解为将最短扩展到二维,这时dis[i][j]数组就记录了到第j层第i点的最短路

分层图最短路例题：P4568 [JLOI2011]飞行路线

这个时间复杂度应该是（kNL）因为N<=1e5,L(最大的q)<=1e3，总的最大为K* 1e8 大力卡了常 最慢 949ms过了这道题

ps:正解斜率优化DP，快的飞起

code:

```
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
#define F first 
#define S second
#define mp make_pair
const int maxn=1e5+10;
const int maxm=2*1e5+10;
struct Edge
{
	int u,v,p,q;
	int nxt;
}e[maxm];
int n,m,A,B,C,ans=482302323;
int head[maxn];
int dis[maxn][1010];
bool vis[maxn][1010];
inline int read()
{
	char c=getchar();int res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') res=res*10+c-'0',c=getchar();
	return res*f;
}
inline int calc(int x){return A*x*x+B*x+C;}
void spfa()
{
	memset(dis,0x3f,sizeof(dis));
	queue<pii> q;
	dis[1][0]=0;q.push(mp(1,0));vis[1][0]=1;
	while(!q.empty())
	{
		int x=q.front().F,w=q.front().S;
		q.pop();vis[x][w]=0;
		for(int i=head[x];i;i=e[i].nxt)
		{
			if(e[i].p<w) continue;
			int y=e[i].v;
			if(dis[y][e[i].q]>dis[x][w]+calc(e[i].p-w))
			{
				dis[y][e[i].q]=dis[x][w]+calc(e[i].p-w);
				if(!vis[y][e[i].q]) vis[y][e[i].q]=1,q.push(mp(y,e[i].q));
			}
		}
	}
}
int main()
{
	n=read();m=read();A=read();B=read();C=read();
	for(register int i=1;i<=m;i++)
	{
		e[i].u=read();e[i].v=read();e[i].p=read();e[i].q=read();
		e[i].nxt=head[e[i].u];head[e[i].u]=i;
	}
	spfa();
	/*for(int i=0;i<=maxq;i++) printf("%d ",dis[n][i]+i);
	puts("");*/
	for(register int i=1;i<=m;i++)
	{
		if(e[i].v==n) ans=min(ans,dis[n][e[i].q]+e[i].q);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：LZDQ (赞：2)

作为新初二的OIer，第一次参加NOI同步赛。以前只听过别人说NOI有多紧张，结果我们学校就几个参加同步赛的，我和同学还带零食进机房，机房就跟美食街一样。没错，一点都不紧张！

T1，真是到好题！我看完全部题目，再看一遍T1，不就是dij吗！

你可能会问我为什么没想到斜率？

因为我没学过！

------------

我们考虑一下以焦躁值作为边权的最短路。

但是焦躁值是在等车的时候才会产生的，我们很容易想到将边看成点，以点连边。

但是不用想都知道，一个点很可能不止一条边相连（原题中的点和边），这样，连的边数就会变成近似 $m^2$ 了。

中间部分就不讲了，看下边。

不用管这么多，能拿分就是！于是本蒟蒻就真这样打了，第三个大样例就T了（严重怀疑是打错了，复杂度不可能那么高的）

### 大概得分：20

------------

那么，能不能不把边看成点呢？

当然可以。以原题中的火车为边，dij的时候枚举一个点连出去的边。dij的时候可以传一个到达的时间到下一个点，以传过来的时间来判断**从上一条边到达该点（火车到站）** 到 **下辆车到达下一个点**这段路程累计的焦躁值，也就是边权。

具体一点（也就是20分解法的中间部分）

样例1中，坐2号车从1到2，再坐4号车从2到3

我们看 从2到3，这里有几个参数：

1. 什么时候到2号点的
2. 在2号点等了多久
3. 什么时候到3号点

令上面1为t1，2为t2，3为t3

在2号点等的时间要套一个二次函数：$A*t2^2+B*t2+C$

为了求最终到达的时间（题目里面焦躁值还要加上总用时），我们必须把总用时放到每一步上。于是还要加上： $t3-t1$

再加一点预处理就行了。统计答案也比较简单。

看到这里，有没有什么不对劲的？

$$

$$

$$

$$

没错，dij的时候不能有附加状态！

就是说，dij的时候，既然是单元最短路，就不应该有附加的**到达时间**

然而，本蒟蒻这样打，过了几个大样例吧，后来恍然大悟～

#### 这分明是出题人想坑我啊

这种东西很可能会WA得（自行脑补）

------------

觉醒吧，少年！

这时的我已经耗了2.5小时了（已经过去3.5小时了）

两次弄错了，A题似乎已经无望（不是还有1.5h吗）

但是，失败乃成功之母

我已经看透这题（的50分）了！

不能加附加状态，那就把每个状态都弄出来嘛！

一看，p、q都是1e3以内

于是，50分应该是到手的了

搜的时候还是以点搜，但这个时候的到达时间就不是附加条件了。最短路不是以点为单位，而是每个点对应1000个状态，以这些状态跑最短路。

在刚才的程序上改一点就好了。

### 得分：50

------------

我平时就打spfa，dij嫌那priority_queue不好重载，要重载还要弄结构体。看看人家sort，直接写一个比较函数名就好了。

这就导致我在代码方面花的时间太多，本来改一点就好了，却改了40分钟。这也跟前面事倍功半有关。心情还是很重要！不能太坏，也不能太好！

------------

最后半小时，终于开始打T3的暴力了。

打暴力之前，我终于看透T1了

这么多状态，其实也就 边数*2 个状态是有用的

因为每条边都只会连接两个状态

你可能会问，就算两个状态在同一个点上，那它们也要连边啊

我就死在这了

T1已经给我留下了心理阴影，我现在可不敢轻举妄动

还是乖乖地回去打暴力吧

------------

总算进入正解了！

如果两个状态在同一个点上，那么直接搜就好了啊！它们之间的边权是固定的，直接求就好了。就当是每次O(1)算边权。

我们用一个map来存所有出现过的状态，初始化的时候，map里面存的是压缩前的状态，用一个数组来存压缩后的状态。

还有一些优化，自行脑补吧。

# 得分：$\color{green}{AC}$

------------


好了，那还叫dij吗（真的不是dij啊）

当然不是，但是这题就是这么神奇，不如弄个算法叫homing（回家）

有些东西讲得不清楚，看代码更好理解

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<map>
#include<queue>
using namespace std;
typedef long long ll;
inline ll minn(ll a,ll b){
	if(a<b) return a;
	return b;
}
inline void swp(int &x,int &y){
	int t=x;
	x=y,y=t;
}
const int MAXN=1e5+5,MAXM=2e5+5;
const ll INF=0x7fffffffffffffff;
int n,m,a,b,c;
int cnte,h[MAXN],nx[MAXM],to[MAXM],p[MAXM],q[MAXM],nd[MAXM];
inline void adde(int u,int v,int x,int y,int z){
	cnte++;
	nx[cnte]=h[u];
	to[cnte]=v;
	p[cnte]=x;
	q[cnte]=y;
	nd[cnte]=z;	//优化 
	h[u]=cnte;
}
int dx,indx[MAXM<<1];	//被两次压缩的状态 
map<int,int> mp;		//被一次压缩的状态 
ll dis[MAXM<<1];	//下标均为被两次压缩的数 
ll ans;
struct priorityq{	//自定义堆 
	int len,a[1000000];
	inline void Init(){
		len=0;
		memset(a,0,sizeof(a));
	}
	void push(int x){
		a[++len]=x;
		int w=len;
		while(w>1){
			if(dis[a[w>>1]]<=dis[a[w]]) break;
			swp(a[w>>1],a[w]);
			w>>=1;
		}
		return ;
	}
	void pop(){
		if(len==1){
			a[1]=0;
			len=0;
			return ;
		}
		a[1]=a[len--];
		int w=1;
		while(w<=len){
			if(w<<1>len) break;
			if((w<<1|1)>len){
				if(dis[a[w<<1|1]]<dis[a[w]]) swp(a[w],a[w<<1|1]);
				break;
			}
			int &x=a[w<<1],&y=a[w<<1|1];
			if(dis[x]<dis[y]) swp(x,a[w]),w=w<<1;
			else swp(y,a[w]),w=w<<1|1;
		}
		return ;
	}
	inline int top(){
		return a[1];
	}
}que;
void dij(){
	ans=INF;
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;
	que.Init();
	que.push(1);
	//初始化完毕 
	while(que.len){
		int hd=que.top();	//head是被两次压缩的 
		que.pop();
		int u=indx[hd]/1001,tm=indx[hd]%1001;	//得到当前的点和时间 
		for(int i=h[u];i;i=nx[i]){	//看这里，这是dij吗 
			if(p[i]<tm) continue;
			int t=p[i]-tm;
			int x=a*t*t+b*t+c+q[i]-tm;	//新增的焦躁值 
			int v=nd[i];	//优化，不用每次在map里找 
			if(dis[v]>dis[hd]+x){
				dis[v]=dis[hd]+x;
				que.push(v);
			}
		}
	}
	for(int i=1;i<=m;i++)
		if(to[i]==n) ans=minn(ans,dis[nd[i]]);	//统计答案 
	return ;
}
int main(){
//	freopen("route5.in","r",stdin);
	scanf("%d%d%d%d%d",&n,&m,&a,&b,&c);
	indx[dx=1]=1001;
	//indx[]里存的是对应的状态
	//如果一个状态的点为 u，时间为 tm,那么压缩后就是 u*1001+tm 
	for(int i=1;i<=m;i++){
		int u,v,p,q;
		scanf("%d%d%d%d",&u,&v,&p,&q);
		int t1=u*1001+p,t2=v*1001+q,t3;	//得到两个状态，t3是一点优化 
		if(!mp.count(t1)) indx[++dx]=t1,mp[t1]=dx;
		if(!mp.count(t2)) indx[++dx]=t2,t3=mp[t2]=dx;
		else t3=mp[t2];
		adde(u,v,p,q,t3);
	}
	dij();
	printf("%lld\n",ans);
//	fclose(stdin);
	return 0;
}
```



---

## 作者：hehelego (赞：1)

有点技巧的斜率优化问题(并么有没有横坐标不单调/动态凸包qwq...技巧不是在计算几何那里的).  

-----
*****

$from/to(s)$某条边的起点/终点位置.  
$S/T(S)$发车/到站时间.  
$trans(i)$某条边/某个转移.

### 一个观察
> 题外话,就算是多两个log也是可以过的,玄学的复杂度有锅的也是可以AC...但是我们现在毕竟不是赛时,还是写靠谱的东西吧qwq.

- 乘坐线路序列不会成环,就是没法找$(s_1,s_2\dots s_k)$使得$to(s_k)=from(s_1)$并且$S(i)\geq T(i-1)$.原因在于$S(s)\lt T(s)$. 这是非常容易观察到的性质,也是最为重要的性质,它告诉我们如果想要做最短路的话,这个图里面没有环.

### 这个最短路啊,也许可以dp
刚才的观察,启发我们使用的边是一个不会重复出现的状态,乘坐$trans_i$之后,一切都是确定的,位置,时间,代价.  
我们先按照发车时间对边排序...

我们考虑$dp_i$为乘坐完$trans_i$最小化的cost.枚举从哪个车转过来的.
$$
dp_i=\min_{T(j)\leq S(i),from(i)=to(j)}(dp_j+A(S_i-T_j)^2+B(S_i-T_j)+C)
$$
于是得到优秀的$O(m^2)$做法.  

随便加一个$trans(0)=(1,1,0,0)$方便统一转移方程...  
init:$dp(0)=0$  
ans:$\min(dp_i+T(i))\,where\, to(i)=n$.


-----

### 一些常规优化
我们转移的顺序按照发车时间顺序的话,一定不会用到未计算的状态.并且,考虑一些$from$相同的$trans$,它们可用的转移集合是随着$S$增大而扩大的.  

(开始尝试转化成定斜率切凸包问题)对于转移式子,拆开平方,按照变量数量分类,找几何意义.
$$
(dp_j+AT_j^2-BT_j)-(2AS_i)T_j+(C+BS_i+AS_i^2)
$$

令$Y_j=(dp_j+AT_j^2-BT_j)$,  
$k_i=(2AS_i)$,  
$X_j=T_j$

转移变成了$Y_j-k_i\times X_j+(QAQ)$就是一个斜率确定的直线,过一些点划线,使得纵截距最小化.  
这是个经典问题,我们维护$(X,Y)$点集的下凸壳,考虑相邻两点的连线斜率,拿着$k_i$上去二分就行了qwq.画个图会很清晰.  

然后就需要写动态凸包了(大雾)

我们是按照$S_i$排序进行转移的,但是横坐标是$T$并不是单调的...但是起始这问题不存在...考虑一个$(from,to,S,T)$它只会被$S(i)=T$的$i$用到,把这些点存在$convex\_hull(T)$处即可,刚刚说过,可用的转移对于起点确定的一些状态而言,是不断扩大的,所以这个东西并没有删除...  


剩下的东西就是实现技巧了...think twice,code once,把东西封装好...不要满屏幕飞着不明所以的数组下标,不然很容易搞出`a[b[x]+1],a[b[x+1]]`的问题...




```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
typedef long long Int;
const int N=200000+10;
const Int INF=Int(1e18);
int n,m,cur[N]; std::vector<int> at[N];
struct T{ int x,y,s,t;
	bool operator<(const T&rhs)const{return s<rhs.s;}
}tr[N];
Int dp[N],A,B,C;
Int cost(Int t){ return A*t*t+B*t+C; }
bool cmp_end_time(int a,int b){ return tr[a].t<tr[b].t; }

struct Vec{ Int x,y; Vec(Int a,Int b):x(a),y(b){} };
Vec operator-(const Vec&a,const Vec&b){ return Vec(a.x-b.x,a.y-b.y); }
Int cross(const Vec&a,const Vec&b){ return a.x*b.y-a.y*b.x; }
Vec get(int i){Int t=tr[i].t; return Vec(t,dp[i]-B*t+A*t*t); }

typedef std::vector<int> Con;
Con q[N];int ql[N],qr[N];
int size(int pos){ return qr[pos]-ql[pos]; }
void push(int pos,int i){
	if(dp[i]>=INF) return;
	Con &qq=q[pos]; int &r=qr[pos];
	while(size(pos)>0&&tr[qq[r-1]].t==tr[i].t){
		if(get(i).y<get(qq[r-1]).y) r--;
		else return ;
	}
	while(size(pos)>1&&cross(get(qq[r-1])-get(qq[r-2]),get(i)-get(qq[r-1]))<=0) r--;
	if(qq.size()<=r) qq.push_back(0);
	qq[r++]=i;
}

Int calc(int i,int j){ return dp[j]+cost(tr[i].s-tr[j].t); }

int main(){
	freopen("route.in","r",stdin); freopen("route.out","w",stdout);
	n=read();m=read(); A=read();B=read();C=read();
	tr[0].x=tr[0].y=1; tr[0].s=tr[0].t=0;
	for(int i=1;i<=m;i++){
		tr[i].x=read(); tr[i].y=read();
		tr[i].s=read(); tr[i].t=read();
	} std::sort(tr,tr+m+1);
	for(int i=0;i<=m;i++){ at[tr[i].y].push_back(i); dp[i]=INF; }
	for(int i=1;i<=n;i++) std::sort(at[i].begin(),at[i].end(),cmp_end_time);

	dp[0]=0; for(int id=1;id<=m;id++){
		int x=tr[id].x,s=tr[id].s;
		Con &qq=q[x];
		for(int &i=cur[x];i<at[x].size()&&tr[at[x][i]].t<=s;i++) push(x,at[x][i]);
		while(size(x)>1&&cross(get(qq[ql[x]+1])-get(qq[ql[x]]),Vec(1,2*A*s))>=0) ql[x]++;
		if(size(x)>0){ int j=qq[ql[x]]; dp[id]=dp[j]+cost(s-tr[j].t); }
	}
	Int ans=INF;
	for(int i=0;i<at[n].size();i++) ans=std::min(ans,dp[at[n][i]]+tr[at[n][i]].t);
	std::cout<<ans<<std::endl;
	std::cerr<<ans<<std::endl;
	return 0;
}

```





---

## 作者：serverkiller (赞：1)

感觉根本没有其他题解说的那么复杂，直接搜就好了

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node
{
    int from;
    int to;
    int from_time;
    int to_time;
    node()
    {
    }
    node(int _a,int _b,int _c,int _d)
    {
        from=_a,to=_b,from_time=_c,to_time=_d;
    }
}q[200005];
bool cmp(node x,node y)
{
    if (x.from_time==y.from_time) return x.to_time<y.to_time;
    return x.from_time<y.from_time;
}
int read()
{
    int x=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c))
    {
        if(c=='-')f=1;
        c=getchar();
    }
    while(isdigit(c))
    {
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
    return x;
}
long long n,m,A,B,C,vis[100005][55],sum[100005][55],cnt[100005];
long long ans=1e18;
int main() {
    memset(vis,0x7fffffffffffffff,sizeof(vis));
    memset(sum,0x7fffffffffffffff,sizeof(sum));
    vis[1][1]=0;
    sum[1][1]=0;
    cnt[1]=1;
    cin>>n>>m>>A>>B>>C;
    for (int i=0;i<m;i++)
    {
        int a=read(),b=read(),c=read(),d=read();
        q[i]=node(a,b,c,d);
    }
    sort(q,q+m,cmp);
    for (int i=0;i<m;i++)
    {
        long long minn=0x7fffffffffffffff;
        for (int j=1;j<=cnt[q[i].from];j++)
        {
            if (vis[q[i].from][j]>q[i].from_time) continue;
            int y=q[i].from_time-vis[q[i].from][j];
            minn=min(minn,(long long)sum[q[i].from][j]+(long long)A*y*y+(long long)B*y+C);
        }   
        if (minn!=(long long)0x7fffffffffffffff)
        {
            sum[q[i].to][++cnt[q[i].to]]=minn;
            vis[q[i].to][cnt[q[i].to]]=q[i].to_time;
        }
    }
    for (int i=1;i<=cnt[n];i++)
    {
        ans=min(ans,sum[n][i]+vis[n][i]);
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：feecle6418 (赞：1)

暴力。

因为空间限制改小，空间复杂度 $O(mt)$ 的暴力是不能 AC 的。但是，dp 数组里面存的二元组 $(\text{位置，到达时间})$ 又只有 $O(m)$ 种。因此，将 dp 数组按照某种方式重编号，得到的编号最多只有 $O(m)$ 种。这样我们就把空间复杂度优化到了 $O(m)$。

但是需要注意，每个点的到达列车可能远超过 $t$ 次，因此需要去重。不去重的话就只能得到 $70$ 分，时间复杂度为 $O(nm)$。去了重，复杂度即为 $O(mt)$。

不是很懂为什么要卡暴力……既然题目上说了 $m\le 2\times 10^5,t\le 10^3$ 并且空间 512MB 就相当于告诉我们暴力本来就 **应该** 过这道题。那再去无谓地卡空间（而且也起不到应有的不让暴力通过的作用）有何意义呢？

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n,m,A,B,C,cnt=0;
struct Thing{
	int x,y,p,q;
	bool operator <(const Thing yy) const {
		return p<yy.p;
	}
}a[200005];
vector<int> rl[200005],id[200005];
long long f[200005],ans=0x3f3f3f3f3f3f3f3fll;
int F(int x){
	return A*x*x+B*x+C;
}
int main() {
	cin>>n>>m>>A>>B>>C;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&a[i].x,&a[i].y,&a[i].p,&a[i].q);
		rl[a[i].y].push_back(a[i].q);
	}
	rl[1].push_back(0);
	for(int i=1;i<=n;i++){
		sort(rl[i].begin(),rl[i].end());
		int tmp=unique(rl[i].begin(),rl[i].end())-rl[i].begin();
		rl[i].resize(tmp);
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<rl[i].size();j++){
			id[i].push_back(++cnt);
		}
	}
	memset(f,0x3f,sizeof(f));
	f[1]=0;
	sort(a+1,a+m+1);
	for(int i=1;i<=m;i++){
		int fr=a[i].x,to=a[i].y,now;
		for(int j=0;j<rl[to].size();j++)if(rl[to][j]==a[i].q)now=id[to][j];
		for(int j=0;j<rl[fr].size();j++){
			if(rl[fr][j]>a[i].p)break;
			int ps=id[fr][j];
			f[now]=min(f[now],f[ps]+F(a[i].p-rl[fr][j]));
		}
	}
	for(int i=0;i<rl[n].size();i++){
		ans=min(ans,f[id[n][i]]+rl[n][i]);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Thinking (赞：1)

**只会$O(mt)$的菜鸡前来搞事**

首先这个题有点，有时间，便套路地想到拆点 ~~（或许我网络流做多了）~~ ，设最大时间为$t$，那么把每个点拆成$t$个，连上原图的边和等待即可。

**恭喜拿到$70pts$**

在这个思（bao）路（li）的基础上，我们发现，每个点拆成$t$个是毫无意义的，只要保留所有进出的时间点就可以了，于是总点数从$nt$下降为$2m$，用$dijkstra$复杂度下降到$O(m(t+logn))$，大约$2 \times 10^8$，轻松跑过一点都不虚233

~~你们说dij死了我偏要用dij~~

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
typedef long long ll;
const int N=100050;
char rB[1<<21],*S,*T;
inline char gc(){return S==T&&(T=(S=rB)+fread(rB,1,1<<21,stdin),S==T)?EOF:*S++;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
int G[N],p[N<<1],q[N<<1],to[N<<1],nxt[N<<1],n,m,A,B,C;
struct node{
	int p,t;
	ll d;
	bool go;  //上一步是坐车则为1，等待则为0
	node(){}
	node(int p,int t,ll d,bool go):p(p),t(t),d(d),go(go){}
	inline bool operator <(const node &b)const{return d>b.d;}
};
priority_queue<node> Q;
vector<int> tim[N],tmp;  //tim对时刻离散化
vector<vector<int> > id[N];  //记录u结点t时刻出发的边的编号
vector<ll> d[2][N];
int main(){
	int i,u;
	node h;
	ll ans=0x3f3f3f3f3f3f3f3f;
	n=rd();m=rd();A=rd();B=rd();C=rd();
	for(i=1;i<=m;++i){
		u=rd();to[i]=rd();p[i]=rd();q[i]=rd();
		nxt[i]=G[u];G[u]=i;
	}
	tim[1].push_back(0);
	for(u=1;u<=n;++u)
		for(i=G[u];i;i=nxt[i]){
			tim[u].push_back(p[i]);
			tim[to[i]].push_back(q[i]);
		}
	for(u=1;u<=n;++u){
		sort(tim[u].begin(),tim[u].end());
		vector<int>::iterator it=unique(tim[u].begin(),tim[u].end());
		tim[u].erase(it,tim[u].end());  //去重
		for(i=0;i<tim[u].size();++i){
			id[u].push_back(tmp);
			d[0][u].push_back(ans);d[1][u].push_back(ans);
		}
	}
	for(u=1;u<=n;++u)
		for(i=G[u];i;i=nxt[i]){
			id[u][p[i]=lower_bound(tim[u].begin(),tim[u].end(),p[i])-tim[u].begin()].push_back(i);
			q[i]=lower_bound(tim[to[i]].begin(),tim[to[i]].end(),q[i])-tim[to[i]].begin();
		}
	Q.push(node(1,0,d[1][1][0]=0ll,1));
	while(!Q.empty()){
		h=Q.top();Q.pop();
		if(d[h.go][u=h.p][h.t]!=h.d)continue;
		if(h.d>ans)break;  //剪枝
		if(u==n&&h.d+tim[n][h.t]<ans)ans=h.d+tim[n][h.t];
		if(h.go)for(i=h.t;i<tim[u].size();++i)if(h.d+A*(tim[u][i]-tim[u][h.t])*(tim[u][i]-tim[u][h.t])+B*(tim[u][i]-tim[u][h.t])+C<d[0][u][i])Q.push(node(u,i,d[0][u][i]=h.d+A*(tim[u][i]-tim[u][h.t])*(tim[u][i]-tim[u][h.t])+B*(tim[u][i]-tim[u][h.t])+C,0));  //等待
        else;
        else for(i=0;i<id[u][h.t].size();++i)if(h.d<d[1][to[id[u][h.t][i]]][q[id[u][h.t][i]]])Q.push(node(to[id[u][h.t][i]],q[id[u][h.t][i]],d[1][to[id[u][h.t][i]]][q[id[u][h.t][i]]]=h.d,1));  //坐车
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Sym_Je (赞：1)

# P5468 [NOI2019]回家路线    

## $solution$
直接爆搜 $95$ ,信仰的加上优化 ，我们玄学枚举下线 $limit$ .   
就可以了 。   
虽然卡起来很容易 ， 但是要相信出题人总是懒得 $qwq$

* $code$   

```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;

const ll maxn=3e6+10;

struct Node
{
	ll x,y,p,q;
}t[maxn];

ll n,m,A,B,C;
vector<ll> v1[maxn],v2[maxn];
ll ans=1e16;
int limit;
void dfs(ll wz,ll ti,ll w) {
	if(w+ti>limit) return ;
	if(w+ti>=ans) return ;
	if(wz==n) {
		ans=w+ti;return ;
	}
	for(ll i=0;i<v1[wz].size();++i) {
		Node v=t[v1[wz][i]];
		if(v.p>=ti){
			ll T=v.p-ti;
			dfs(v.y,v.q,w+A*T*T+B*T+C);
		}
	}
}

int main() 
{
	//freopen("a.in","r",stdin);
	//freopen("a.out","w",stdout);
	scanf("%lld%lld%lld%lld%lld",&n,&m,&A,&B,&C);//cout<<"2333";
	for(ll i=1;i<=m;++i) {
		scanf("%lld%lld%lld%lld",&t[i].x,&t[i].y,&t[i].p,&t[i].q);
	}
	for(ll i=1;i<=m;++i) {
		v1[t[i].x].push_back(i);v2[t[i].y].push_back(i);
	}dfs(1,0,0);
	for(limit=1;limit<=10000000;limit<<=1){
		dfs(1,0,0);
	}
	cout<<ans<<"\n";
	return 0;
}


```

---

## 作者：orecic (赞：0)

~~出题人太懒了~~

## 非正解做法
虽然打的是同步赛，但是心态依然很蹦。看了三道题后觉得这道题是最简单的，然后就刚上了。


前五十分很好打，没有环的话就是个$\ DAG$，拓扑一下随便写。
$\ f_{i,j}$代表$\ j$时刻跑到$\ i$的最小烦躁值。

$\ f_{to,p_{k}}=\min(f_{from,p_{j}}+At^{2}+Bt+C)$



我们观察发现如果我们把边拆点的话，是几乎不会出现环的，所以我们可以直接记忆化搜索。（不然就超过时间了）

复杂度的上界是$\ O(m^{2})$，菊花图可以直接卡掉。讨论中的大佬造的数据已经直接卡掉了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long aa,bb,cc;
struct node
{
	long long x,y,p,q,i;
}a[300300];
vector<node> to[300300];
long long f[300300];
long long sum(node &x,node &y)
{
	long long t=y.p-x.q;
	return aa*t*t+bb*t+cc+y.p-x.p;
}
inline int read()
{
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
bool vis[300300];
long long dfs(node &x)
{
	if(x.i==0) return 0;
	if(vis[x.i]) return f[x.i];
	vis[x.i]=1;
	int i=0;
	while(i<to[x.x].size())
	{
		node &y=to[x.x][i];
		if(y.q<=x.p) f[x.i]=min(f[x.i],dfs(y)+sum(y,x));
		++i;
	}
	return f[x.i];
}
int main()
{
// 	freopen("route.in","r",stdin);
// 	freopen("route.out","w",stdout);
	n=read();
	m=read();
	aa=read();
	bb=read();
	cc=read();
	int i=1;
	while(i<=m)
	{
		a[i].x=read();
		a[i].y=read();
		a[i].p=read();
		a[i].q=read();
		a[i].i=i;
		to[a[i].y].push_back(a[i]);
		++i;
	}
	to[1].push_back(a[0]);
	memset(f,63,sizeof(f));
	f[0]=0;
	long long ans=1e18;
	i=0;
	while(i<to[n].size())
	{
		ans=min(ans,dfs(to[n][i])+to[n][i].q-to[n][i].p);
		++i;
	}
	printf("%lld\n",ans);
	return 0;
}

```


---


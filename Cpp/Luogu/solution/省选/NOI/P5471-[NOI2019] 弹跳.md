# [NOI2019] 弹跳

## 题目背景

原题时限 2s

内存 128MB

## 题目描述

跳蚤国有 $n$ 座城市，分别编号为 $1 - n$，$1$ 号城市为首都。所有城市分布在一个$w \times h$ 范围的网格上。每座城市都有一个整数坐标 $(x, y) (1 \leq x \leq w, 1 \leq y \leq h)$，不同城市的坐标不相同。

在跳蚤国中共有 $m$ 个弹跳装置，分别编号为 $1 - m$，其中 $i$ 号弹跳装置位于 $p_i$ 号城市，并具有参数 $t_i, L_i, R_i, D_i, U_i$。利用该弹跳装置，跳蚤可花费 $t_i (t_i > 0)$ 个单位时间，从 $p_i$ 号城市跳至坐标满足 $L_i \leq x \leq R_i, D_i \leq y \leq U_i (1 \leq L_i \leq R_i \leq w, 1 \leq D_i \leq U_i \leq h)$ 的任意一座城市。需要注意的是，一座城市中可能存在多个弹跳装置，也可能没有弹跳装置。

由于城市间距离较远，跳蚤们必须依靠弹跳装置出行。具体来说，一次出行将经过
若干座城市，依次经过的城市的编号可用序列 $a_0, a_1, \cdots , a_k$ 表示；在此次出行中，依次利用的弹跳装置的编号可用序列 $b_1, b_2, \cdots , b_k$ 表示。其中每座城市可在序列 $\{a_j\}$ 中出现任意次，每个弹跳装置也可在序列 $\{b_j\}$ 中出现任意次，且满足，对于每个 $j (1 \leq j \leq k)$，编号为 $b_j$ 的弹跳装置位于城市 $a_{j-1}$，且跳蚤能通过该弹跳装置跳至城市 $a_j$。我们称这是一次从城市 $a_0$ 到城市 $a_k$ 的出行，其进行了 $k$ 次弹跳，共花费 $\sum^k_{i=1} t_{b_{i}}$ 个单位时间。

现在跳蚤国王想知道，对于跳蚤国除首都（$1$ 号城市）外的每座城市，从首都出发，到达该城市最少需要花费的单位时间。跳蚤国王保证，对每座城市，均存在从首都到它的出行方案。


## 说明/提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见附加文件中的 `jump/jump2.in` 与 `jump/jump2.ans`。

这组样例的数据范围为 $n = 10^4 , m = 2\times 10^4 , w = 10^4 , h = 1$。

#### 样例 3

见附加文件中的 `jump/jump3.in` 与 `jump/jump3.ans`。

这组样例的数据范围为 $n = 10^4 , m = 2\times 10^4 , w = 10^4 , h = 10^4$。

### 数据范围

对于所有测试点和样例满足：

$1 \leq n \leq 70000 , 1 \leq m \leq 150000 , 1 \leq w, h \leq n , 1 \leq t_i \leq 10000$。

每个测试点的具体限制见下表。

| 测试点编号 | $1\le n\le$ | $1\le m\le$ | 特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim8$ | $100$ | $100$ | 无 |
| $9\sim13$ | $5\times 10^4$ | $10^5$ | 每个弹跳装置恰好可达一座城市，且 $L_i=R_i$，$D_i=U_i$ |
| $14\sim18$ | $5\times 10^4$ | $10^5$ | $h=1$ | 
| $19\sim22$ | $2.5\times 10^4$ | $5\times 10^4$ | 无 | 
| $23\sim25$ | $7\times 10^4$ | $1.5\times 10^5$ | 无 | 

## 样例 #1

### 输入

```
5 3 5 5
1 1
3 1
4 1
2 2
3 3
1 123 1 5 1 5
1 50 1 5 1 1
3 10 2 2 2 2```

### 输出

```
50
50
60
123
```

# 题解

## 作者：Ireliaღ (赞：50)

**看到各路大佬又是优化建图打标记，又是一次松弛一个矩形，又是树上删点之类的，看不懂，这里提供一个更加简单的思路**

## 基本思路

NOI同步赛我打了个KDTree优化建图，当场MLE爆炸，40分。但是通过最基本的KDTree优化建图思路可以想出正解，我们可以大概了解一下。

- 首先，KDTree的每个节点维护着一个坐标和一个矩形的信息。所以我们把原图上的点就叫做实点，编号范围为$[1, n]$，KDTree上的节点叫做虚点，编号范围为$[n + 1, 2n]$

- 我们对于每一个实点，遍历装在这个位置的所有弹跳机，假设当前弹跳机的时间为$t$，起点为$u$，我们上树查询。

- 对于在树上的一个节点$x$

  - 如果$x$管辖的矩形完全在弹跳机的目标矩形外，`return`
  
  - 如果$x$管辖的矩形完全在弹跳机的目标矩形内，从$u$向$x$建边，权值为$t$，`return`
  
  - 两区间交叉情况
  
    - 如果$x$上维护的坐标在目标矩形内，从$u$向$x - n$建边，权值为$t$
    
    - 递归查询两个儿子
    
- 最后对于$\forall x \in [1, n]$，从$x + n$向$x$建边即可
    
以上为KDTree优化建图的基本思路。代码如下（如果有铁憨憨把这份代码粘上去交了我也拦不住

```cpp
// luogu-judger-enable-o2
#include <algorithm>
#include <iostream>
#include <cstring>
#include <utility>
#include <cstdio>
#include <vector>
#include <queue>

using namespace std;

const int MAXN = 7e4 + 5;
const int INF = 0x3f3f3f3f;

int n, m, W, H;

int ID(int x, int y) {
    if (y == 0) return x;
    else return x + n;
}

struct Edge{
    int to, val;
    
    Edge(int v, int w) {
        to = v;
        val = w;
    }
};

vector<Edge> g[MAXN << 1];
int vis[MAXN << 1], dis[MAXN << 1];

typedef vector<Edge> :: iterator ITE;
typedef pair<int, int> POI;

void AddEdge(int u, int v, int w) {
    g[u].push_back(Edge(v, w));
}

void Dijkstra(int s) {
    priority_queue<POI> q;
    memset(dis, INF, sizeof(dis));
    dis[s] = 0; vis[s] = true; q.push(make_pair(dis[s], s));
    while (!q.empty()) {
        int u = q.top().second; q.pop(); vis[u] = false;
        for (ITE it = g[u].begin(); it != g[u].end(); it++) {
            int v = it->to;
            if (dis[v] > dis[u] + it->val) {
                dis[v] = dis[u] + it->val;
                if (!vis[v]) {
                    q.push(make_pair(dis[v], v));
                    vis[v] = true;
                }
            }
        }
    }
}

struct Data{
    int pos[2];
    int id;
};

int Cmp0(Data x, Data y) {
    return x.pos[0] != y.pos[0] ? (x.pos[0] < y.pos[0]) : (x.pos[1] < y.pos[1]);
}

int Cmp1(Data x, Data y) {
    return x.pos[1] != y.pos[1] ? (x.pos[1] < y.pos[1]) : (x.pos[0] < y.pos[0]);
}

Data data[MAXN];

struct Node{
    Data data;
    int mn[2], mx[2], d;
    Node *ch[2];
    
    Node() {}
    
    Node(Data data, int d) : data(data), d(d) {
        ch[0] = NULL;
        ch[1] = NULL;
        for (int i = 0; i < 2; i++) {
            mn[i] = data.pos[i];
            mx[i] = data.pos[i];
        }
    }
}pool[MAXN << 1];

Node *NewNode(Data data, int d) {
    static int p = 0;
    pool[p] = Node(data, d);
    return pool + p++;
}

Node *rt = NULL;

void Update(Node *now) {
    for (int i = 0; i < 2; i++) {
        if (now->ch[i]) {
            for (int j = 0; j < 2; j++) {
                now->mn[j] = min(now->mn[j], now->ch[i]->mn[j]);
                now->mx[j] = max(now->mx[j], now->ch[i]->mx[j]);
            }
        }
    }
}

void Build(Node *&now, int l, int r, int d) {
    if (l > r) return;
    int mid = l + r >> 1;
    if (d == 0) {
        nth_element(data + l, data + mid, data + r + 1, Cmp0);
        now = NewNode(data[mid], d);
    } else {
        nth_element(data + l, data + mid, data + r + 1, Cmp1);
        now = NewNode(data[mid], d);
    }
    Build(now->ch[0], l, mid - 1, (d + 1) % 2);
    Build(now->ch[1], mid + 1, r, (d + 1) % 2);
    Update(now);
    if (now->ch[0]) AddEdge(ID(now->data.id, 1), ID(now->ch[0]->data.id, 1), 0);
    if (now->ch[1]) AddEdge(ID(now->data.id, 1), ID(now->ch[1]->data.id, 1), 0);
}

void Jump(Node *now, int u, int mn[], int mx[], int w) {
    if (!now) return;
    int allin = true, allout = false, insq = true;
    for (int i = 0; i < 2; i++) {
        if (now->mx[i] < mn[i] || now->mn[i] > mx[i]) allout = true;
        if (now->mx[i] > mx[i] || now->mn[i] < mn[i]) allin = false;
        if (now->data.pos[i] < mn[i] || now->data.pos[i] > mx[i]) insq = false;
    }
    if (allout) return;
    if (allin) {
        AddEdge(ID(u, 0), ID(now->data.id, 1), w);
        //cerr << '#';
        return;
    }
    if (insq) {
        AddEdge(ID(u, 0), ID(now->data.id, 0), w);
        //cerr << '$';
    }
    Jump(now->ch[0], u, mn, mx, w);
    Jump(now->ch[1], u, mn, mx, w);
}

void Init() {
    cin >> n >> m >> W >> H;
    for (int i = 1; i <= n; i++) {
        cin >> data[i].pos[0] >> data[i].pos[1];
        data[i].id = i;
    }
    for (int i = 1; i <= n; i++) AddEdge(ID(i, 1), ID(i, 0), 0);
    Build(rt, 1, n, 0);
    //cerr << '*';
    int mn[2], mx[2], x, y;
    for (int i = 1; i <= m; i++) {
        cin >> x >> y;
        cin >> mn[0] >> mx[0];
        cin >> mn[1] >> mx[1];
        Jump(rt, x, mn, mx, y);
        //cerr << '*';
    }
    //cerr << '*';
}

void Work() {
    Dijkstra(1);
    for (int i = 2; i <= n; i++) cout << dis[ID(i, 0)] << endl;
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    //freopen("jump.in", "r", stdin);
    //freopen("jump.out", "w", stdout);
    Init();
    Work();
    return 0;
}
```

## 优化

这里提供可以优化的两条锦囊妙计。

1. **首先，我们可以假装我们把图建了出来，不建边**

假装把图建出来？你可能要问了，我们都没有建边，怎么知道从一个点出发，能到达哪些点？

我们当然可以知道！就像在赛场上切掉此题的某位银牌大佬 @龙之吻—水货 所说：

> 首先你有一棵树

> 你要把这棵树完全变成你的工具

> 你建边的目的是要知道从一个点出发能到达哪些点

想通了就OK了，根据刚才建图的思路，我们完全知道从一个节点出发能到达哪些节点。

- 对于一个虚点$u$，能到达的节点如下

  - 它的两个儿子对应的虚点
  
  - 它所对应的实点
  
- 对于一个实点$u$

  - 在跑`SPFA`最短路时，如果从队列中拿出实点，直接遍历从$x$出发的弹跳机，上树查询
  
  - 对于在树上的一个虚点$x$
  
    - 如果$x$管辖的区间完全在目标区间外，`return`
    
    - 如果$x$管辖的区间完全在目标区间内，松弛$x$
    
    - 对于区间交叉情况
    
      - 如果$x$对应的坐标在目标区间内，松弛$x - n$
      
      - 递归查询两个儿子
      
    - 松弛时加上的距离为弹跳机用时
    
你看完这个思路，感觉有点眼熟，返回去看了一眼40分思路

完全一样？是的。

代码如下

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int MAXN = 7e4 + 5;
const int MAXM = 15e4 + 5;
const int INF = 0x3f3f3f3f;

int n, m, W, H;

struct Edge{
	Edge *nxt;
	int val;
	int mn[2], mx[2];
	
	Edge() {}
	
	Edge(int val, int l[], int r[], Edge *nxt) : val(val), nxt(nxt) {
		memcpy(mn, l, sizeof(mn));
		memcpy(mx, r, sizeof(mx));
	}
}epool[MAXM];

Edge *NewEdge(int val, int l[], int r[], Edge *nxt) {
	static int ecnt = 0;
	epool[ecnt] = Edge(val, l, r, nxt);
	return &epool[ecnt++];
}

Edge *head[MAXN];

void AddEdge(int u, int w, int l[], int r[]) {
	head[u] = NewEdge(w, l, r, head[u]);
}

struct Point{
	int id;
	int x[2];
	
	Point() {}
	
	Point(int id, int a, int b) : id(id) {
		x[0] = a;
		x[1] = b;
	}
}data[MAXN];

int Comp0(Point a, Point b) {
	return (a.x[0] == b.x[0]) ? (a.x[1] < b.x[1]) : (a.x[0] < b.x[0]);
}

int Comp1(Point a, Point b) {
	return (a.x[1] == b.x[1]) ? (a.x[0] < b.x[0]) : (a.x[1] < b.x[1]);
}

struct Node{
	Point pos;
	Node *ch[2];
	int mn[2], mx[2];
	
	Node() {}
	
	Node(Point pos) : pos(pos) {
		ch[0] = ch[1] = NULL;
		for (int i = 0; i < 2; i++) mn[i] = mx[i] = pos.x[i];
	}
}npool[MAXN];

void Update(Node *now) {
	for (int i = 0; i < 2; i++) {
		if (now->ch[i]) {
			for (int j = 0; j < 2; j++) {
				now->mn[j] = min(now->mn[j], now->ch[i]->mn[j]);
				now->mx[j] = max(now->mx[j], now->ch[i]->mx[j]);
			}
		}
	}
}

Node *NewNode(Point pos) {
	static int ncnt = 0;
	npool[ncnt] = Node(pos);
	return &npool[ncnt++];
}

Node *rt = NULL;
Node *ima[MAXN];

void Build(Node *&now, int l, int r, int d) {
	if (l > r) return;
	int mid = l + r >> 1;
	if (d == 0) nth_element(data + l, data + mid, data + r + 1, Comp0);
	else nth_element(data + l, data + mid, data + r + 1, Comp1);
	now = NewNode(data[mid]);
	ima[now->pos.id] = now;
	Build(now->ch[0], l, mid - 1, d ^ 1);
	Build(now->ch[1], mid + 1, r, d ^ 1);
	Update(now);
}

int q[MAXN << 1], hd, tl, len;
int dis[MAXN << 1];
int vis[MAXN << 1];

void Relax(int v, int w) {
	if (dis[v] > w) {
		dis[v] = w;
		if (!vis[v]) {
			q[++tl % len] = v;
			vis[v] = 1;
		}
	}
}

int AllIn(Node *now, int mn[], int mx[]) {
	for (int i = 0; i < 2; i++) {
		if (now->mn[i] < mn[i] || now->mx[i] > mx[i]) return 0;
	}
	return 1;
}

int AllOut(Node *now, int mn[], int mx[]) {
	for (int i = 0; i < 2; i++) {
		if (now->mn[i] > mx[i] || now->mx[i] < mn[i]) return 1;
	}
	return 0;
}

int Inside(Node *now, int mn[], int mx[]) {
	for (int i = 0; i < 2; i++) {
		if (now->pos.x[i] < mn[i] || now->pos.x[i] > mx[i]) return 0;
	}
	return 1;
}

void Jump(Node *now, int mn[], int mx[], int w) {
	if (!now) return;
	if (AllOut(now, mn, mx)) return;
	if (AllIn(now, mn, mx)) {
		Relax(now->pos.id + n, w);
		return;
	}
	if (Inside(now, mn, mx)) Relax(now->pos.id, w);
	Jump(now->ch[0], mn, mx, w);
	Jump(now->ch[1], mn, mx, w);
}

void Spfa(int s) {
	memset(dis, INF, sizeof(dis));
	dis[s] = 0;
	hd = 1; tl = 0; q[++tl % len] = s; vis[s] = 1;
	while (hd <= tl) {
		int u = q[hd++ % len]; vis[u] = 0;
		if (u > n) {
			Relax(u - n, dis[u]);
			if (ima[u - n]->ch[0]) Relax(ima[u - n]->ch[0]->pos.id + n, dis[u]);
			if (ima[u - n]->ch[1]) Relax(ima[u - n]->ch[1]->pos.id + n, dis[u]);
		} else {
			for (Edge *e = head[u]; e; e = e->nxt) {
				Jump(rt, e->mn, e->mx, dis[u] + e->val);
			}
		}
	}
}

void Init() {
	cin >> n >> m >> W >> H;
	len = n * 2;
	for (int i = 1; i <= n; i++) {
		data[i].id = i;
		cin >> data[i].x[0] >> data[i].x[1];
	}
	Build(rt, 1, n, 0);
	int l[2], r[2], u, t;
	for (int i = 1; i <= m; i++) {
		cin >> u >> t >> l[0] >> r[0] >> l[1] >> r[1];
		AddEdge(u, t, l, r);
	}
}

void Work() {
	Spfa(1);
//	for (int i = 1; i <= n * 2; i++) cerr << dis[i] << " ";
//	cerr << "\n";
	for (int i = 2; i <= n; i++) cout << dis[i] << "\n";
}

int main() {
	Init();
	Work();
	return 0;
}
```

88分到手，（如果有铁憨憨抄上去我也没啥说的

我们可以使用第二条锦囊妙计：

2. **关于SPFA，它死了**

van♂van♂没想到，NOI2018卡了SPFA，NOI2019竟然还要卡

行了不墨迹了，直接换Dijkstra，以下为AC代码

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#include <utility>

using namespace std;
typedef pair<int, int> POI;
const int MAXN = 7e4 + 5;
const int MAXM = 15e4 + 5;
const int INF = 0x3f3f3f3f;

int n, m, W, H;

struct Edge{
    Edge *nxt;
    int val;
    int mn[2], mx[2];
	
    Edge() {}
	
    Edge(int val, int l[], int r[], Edge *nxt) : val(val), nxt(nxt) {
        memcpy(mn, l, sizeof(mn));
        memcpy(mx, r, sizeof(mx));
    }
}epool[MAXM];

Edge *NewEdge(int val, int l[], int r[], Edge *nxt) {
    static int ecnt = 0;
    epool[ecnt] = Edge(val, l, r, nxt);
    return &epool[ecnt++];
}

Edge *head[MAXN];

void AddEdge(int u, int w, int l[], int r[]) {
    head[u] = NewEdge(w, l, r, head[u]);
}

struct Point{
    int id;
    int x[2];
	
    Point() {}
	
    Point(int id, int a, int b) : id(id) {
        x[0] = a;
        x[1] = b;
    }
}data[MAXN];

int Comp0(Point a, Point b) {
    return (a.x[0] == b.x[0]) ? (a.x[1] < b.x[1]) : (a.x[0] < b.x[0]);
}

int Comp1(Point a, Point b) {
    return (a.x[1] == b.x[1]) ? (a.x[0] < b.x[0]) : (a.x[1] < b.x[1]);
}

struct Node{
    Point pos;
    Node *ch[2];
    int mn[2], mx[2];
	
    Node() {}
	
    Node(Point pos) : pos(pos) {
        ch[0] = ch[1] = NULL;
        for (int i = 0; i < 2; i++) mn[i] = mx[i] = pos.x[i];
    }
}npool[MAXN];

void Update(Node *now) {
    for (int i = 0; i < 2; i++) {
        if (now->ch[i]) {
            for (int j = 0; j < 2; j++) {
                now->mn[j] = min(now->mn[j], now->ch[i]->mn[j]);
                now->mx[j] = max(now->mx[j], now->ch[i]->mx[j]);
            }
        }
    }
}

Node *NewNode(Point pos) {
    static int ncnt = 0;
    npool[ncnt] = Node(pos);
    return &npool[ncnt++];
}

Node *rt = NULL;
Node *ima[MAXN];

void Build(Node *&now, int l, int r, int d) {
    if (l > r) return;
    int mid = l + r >> 1;
    if (d == 0) nth_element(data + l, data + mid, data + r + 1, Comp0);
    else nth_element(data + l, data + mid, data + r + 1, Comp1);
    now = NewNode(data[mid]);
    ima[now->pos.id] = now;
    Build(now->ch[0], l, mid - 1, d ^ 1);
    Build(now->ch[1], mid + 1, r, d ^ 1);
    Update(now);
}

//int q[MAXN << 1], hd, tl, len;
priority_queue<POI, vector<POI>, greater<POI> > q;
int dis[MAXN << 1];
int vis[MAXN << 1];

void Relax(int v, int w) {
    if (dis[v] > w) {
        q.push(make_pair(dis[v] = w, v));
    }
}

int AllIn(Node *now, int mn[], int mx[]) {
    for (int i = 0; i < 2; i++) {
        if (now->mn[i] < mn[i] || now->mx[i] > mx[i]) return 0;
    }
    return 1;
}

int AllOut(Node *now, int mn[], int mx[]) {
    for (int i = 0; i < 2; i++) {
        if (now->mn[i] > mx[i] || now->mx[i] < mn[i]) return 1;
    }
    return 0;
}

int Inside(Node *now, int mn[], int mx[]) {
    for (int i = 0; i < 2; i++) {
        if (now->pos.x[i] < mn[i] || now->pos.x[i] > mx[i]) return 0;
    }
    return 1;
}

void Jump(Node *now, int mn[], int mx[], int w) {
    if (!now) return;
    if (AllOut(now, mn, mx)) return;
    if (AllIn(now, mn, mx)) {
        Relax(now->pos.id + n, w);
        return;
    }
    if (Inside(now, mn, mx)) Relax(now->pos.id, w);
    Jump(now->ch[0], mn, mx, w);
    Jump(now->ch[1], mn, mx, w);
}

void Dijkstra(int s) {
    memset(dis, INF, sizeof(dis));
    dis[s] = 0;
    //	hd = 1; tl = 0; q[++tl % len] = s; vis[s] = 1;
    q.push(make_pair(dis[s], s));
    int cnt = 0;
    while (!q.empty()) {
        if (q.top().first != dis[q.top().second]) {
            q.pop();
            continue;
        }
        int u = q.top().second; q.pop();
        if (u > n) {
            Relax(u - n, dis[u]);
            if (ima[u - n]->ch[0]) Relax(ima[u - n]->ch[0]->pos.id + n, dis[u]);
            if (ima[u - n]->ch[1]) Relax(ima[u - n]->ch[1]->pos.id + n, dis[u]);
        } else {
            for (Edge *e = head[u]; e; e = e->nxt) {
                Jump(rt, e->mn, e->mx, dis[u] + e->val);
            }
        }
    }
}

void Init() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n >> m >> W >> H;
    //	len = n * 2;
    for (int i = 1; i <= n; i++) {
        data[i].id = i;
        cin >> data[i].x[0] >> data[i].x[1];
    }
    Build(rt, 1, n, 0);
    int l[2], r[2], u, t;
    for (int i = 1; i <= m; i++) {
        cin >> u >> t >> l[0] >> r[0] >> l[1] >> r[1];
        AddEdge(u, t, l, r);
    }
}

void Work() {
    Dijkstra(1);
    //	for (int i = 1; i <= n * 2; i++) cerr << dis[i] << " ";
    //	cerr << "\n";
    for (int i = 2; i <= n; i++) cout << dis[i] << "\n";
}

int main() {
    Init();
    Work();
    return 0;
}
```

---

## 作者：hsfzLZH1 (赞：40)

## 题目大意

给出二维平面上的 $n$ 个整点 $(x_i,y_i)$ ，满足 $1\le x_i\le w,1\le y_i\le h$ 。按给出顺序编号为 $1,2,...,n$ 。有 $m$ 次连边操作，每次操作给定 $p,t,L,R,D,U$ ，从结点 $p$ 到满足条件 $L\le x_i\le R,D\le y_i\le U$ 的所有这样的结点 $i$ 连接一条边权为 $t$ 的有向边。求在所有连边操作结束后，从编号为 $1$ 的点到其他点的最短路长度。

$1\le w,h\le n\le 70000,1\le m\le 150000,1\le t_i\le 10000$

### 32pts

暴力连边，边数最多为 $O(nm)$ ，跑最短路。

~~暴力分还挺多~~

### $L_i=R_i,D_i=U_i$

观察到每次连边操作只会连接两个结点，暴力连边，边数为 $O(m)$ ，跑最短路。

什么，还有其他最短路算法？

### $h=1$

开题一看，这不是 **线段树优化建图** 的题吗？

线段树优化建图，是图论问题中的经典技巧。将所有点按照 $x$ 坐标排序，观察到每次连边操作连接到的点都是连续的一段。

![](https://cdn.luogu.com.cn/upload/pic/53229.png)

（图片来源： NaCly_Fish ）

我们对排序后的序列建一棵线段树，线段树上的每个结点向其左右儿子连一条边权为 $0$ 的边，每个叶子结点向其对应位置的点连一条边权为 $0$ 的边。在进行连边操作时，用类似于线段树上区间查询的方式向所有对应的点连一条边。根据线段树的经典结论，这样所连的边数最多是 $O(\log_2 n)$ 的。

![](https://cdn.luogu.com.cn/upload/pic/53230.png)

总点数为 $O(n)$ ，总边数为 $O(n+m\log_2 n)$ ，可以存下所有的边，跑最短路即可。

线段树优化建图的经典题目：

[CF786B Legacy](https://codeforces.com/problemset/problem/786/B)

[P5025 \[SNOI2017\]炸弹](https://www.luogu.org/problemnew/show/P5025)

### 100pts

现在连边从原来的一维变成二维的了。

在做这题时，我考虑了分块套分块，分块套线段树，线段树套线段树等多种方法，最后发现线段树套动态开点线段树比较优秀。

外层 $x$ 坐标用普通线段树，这棵线段树上每个结点都对应一个关于 $y$ 坐标的线段树，线段树上存储的是所有 $x$ 坐标在范围内的点。由于内层动态开点线段树插入一个值的空间复杂度为 $O(\log_2 n)$ ，外层线段树有 $O(\log_2 n)$ 层，所以总的点数为 $O(n\log_2^2 n)$ 。

连边时，先找到 $O(\log_2 n)$ 个关于 $x$ 坐标的区间对应的点，然后对这 $O(\log_2 n)$ 棵线段树查询下标范围在 $y$ 坐标范围内的值。单次连接的边数为 $O(\log_2^2 n)$ ，总的边数为 $O(m\log_2^2 n)$ 。

然而，这种写法的内存使用超过了限制。一般的实现可以得到 $64$ 到 $72$ 分。有以下两个优化方法：

1. 树套树内层使用 $n$ 个结点时空间复杂度是 $O(n)$ 的 `set` 容器；

2. **不直接连边** 。回顾 Dij 的算法流程，有如下写法：用线段树套 `set` 维护一个矩阵中存在的整点，开始时扩展 $1$ 号结点的所有出边（直接连接到一个矩阵），每次取出优先队列中时间最小的一个矩阵，遍历矩阵中的每一个存在的整点，记录到这些点的最短路，扩展这些结点，然后在线段树套 `set` 上删除这些结点。由于每个结点只会被删除和扩展一次，所以这样做的时间复杂度是 $O(n\log_2^2 n)$ 的。

同时使用两种优化，时间复杂度是 $O(n\log_2^2 n)$ ，空间复杂度是 $O(n\log_2 n+m)$ 的，可以通过本题。

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<vector>
#include<queue>
using namespace std;
const int maxn=150010;
int n,m,W,H;
struct city{int id,x,y;bool operator<(city a)const{return y==a.y?id<a.id:y<a.y;};}s[maxn];
set<city>st[maxn*2];
#define lc (o<<1)
#define rc (o<<1|1)
void update(int o,int l,int r,int v)
{
	st[o].insert(s[v]);
	if(l==r)return;
	int mid=(l+r)>>1;
	if(s[v].x<=mid)update(lc,l,mid,v);
	else update(rc,mid+1,r,v);
}
void deleet(int o,int l,int r,int v)
{
	st[o].erase(s[v]);
	if(l==r)return;
	int mid=(l+r)>>1;
	if(s[v].x<=mid)deleet(lc,l,mid,v);
	else deleet(rc,mid+1,r,v);
}
struct jumpy{int p,t,l,r,d,u;}e[maxn];
vector<int>g[maxn];
struct node{int x,v;bool operator<(node a)const{return v>a.v;};}x;
priority_queue<node>q;
queue<int>tag;
int dist[maxn];
bool tf[maxn];
void erasse(int o,int l,int r,int id,int v)
{
	int ql=e[id].l,qr=e[id].r;
	if(r<ql||l>qr)return;
	if(ql<=l&&r<=qr)
	{
		set<city>::iterator lb=lower_bound(st[o].begin(),st[o].end(),(city){0,n+1,e[id].d});
		for(;lb!=st[o].end()&&(lb->y)<=e[id].u;lb++)
		{
			dist[lb->id]=v;tag.push(lb->id);
			for(vector<int>::iterator it=g[lb->id].begin();it!=g[lb->id].end();it++)q.push({*it,v+e[*it].t});
		}
		while(!tag.empty())deleet(1,1,n,tag.front()),tag.pop();
		return;
	}
	int mid=(l+r)>>1;
	erasse(lc,l,mid,id,v);erasse(rc,mid+1,r,id,v);
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&W,&H);
	for(int i=1;i<=n;i++)scanf("%d%d",&s[i].x,&s[i].y),s[i].id=i,update(1,1,n,i);
	for(int i=1;i<=m;i++)scanf("%d%d%d%d%d%d",&e[i].p,&e[i].t,&e[i].l,&e[i].r,&e[i].d,&e[i].u),g[e[i].p].push_back(i);
	e[0].l=e[0].r=s[1].x;e[0].d=e[0].u=s[1].y;
	q.push({0,0});
	while(!q.empty())
	{
		x=q.top();q.pop();
		if(tf[x.x])continue;
		tf[x.x]=true; 
		erasse(1,1,n,x.x,x.v);
		//for(vector<int>::iterator it=g[x.x].begin();it!=g[x.x].end();it++)q.push({e[*it].p,x.v+e[*it].t});
	}
	for(int i=2;i<=n;i++)printf("%d\n",dist[i]);
	return 0;
}
```

---

## 作者：lg_zhou (赞：17)

不知道为什么大家将此方法描述为“时空优化的线段树优化建图”。我认为正解其实和“线段树优化建图，数据结构优化建图”已经没有关系了，反而是利用的是 dijkstra 的性质，数据结构只是辅助找点。

首先题目描述给出的是，一个点的一类边连向一个矩形，也就是连向很多点一个相同的边，如果直接跑最短路会爆炸。这个图跑 dijkstra 有一个很好的性质，就是当前和源点最近的点的集合一定是某个点一类边所松弛的矩形，这个很容易证明。 

而 dijkstra 中每一个节点一定只被更新一次，所以我们可以直接把每个矩形都当做一个点就做完了，且称之为虚点，在虚点上直接跑最短路，和普通的 dijkstra 一模一样，因为虚点里面的所以点在最短路的大小上没有本质区别。现在要处理的问题是，当我们正在处理一个虚点，怎么快速松弛所有和这个虚点相邻的所有虚点。

首先注意到一个个取出虚点里面的点，找到这个点所指向的虚点，再把虚点加进来，这样暴力搞是不可取的，这样复杂度会爆炸。考虑怎么优化这个过程。考虑如果当前虚点中的点已经存在于之前的已处理过的虚点中，我们就不用处理它了，因为根据 dijkstra 的原理，我们每次找的都是最近的点，那再处理它一定不会更优。所以我们要找到一个数据结构快速找到并删除在当前虚点里，且没有在之前虚点中存在的所有点。

拿一个线段树维护横轴方向，每个节点里套一个 `set` 维护所有点，这样每个虚点所对应的所有点可以快速找到，而且删除直接在 `set` 上删就好了。

代码：

```cpp
#include<bits/stdc++.h>

#define fi first
#define se second
#define endl '\n'
// #define int long long
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef long double db;
typedef pair<db, db> pdd;

const int N = 700007;

int n,m,w,h;
set<pii> s[N];

pii a[N];

void insert(int x, int l, int r, int id){ // set 中插入点
    s[x].insert({a[id].se,id});
    if (l == r) return;
    int mid = l+r>>1;
    if (a[id].fi <= mid) insert(x*2,l,mid,id);
    else insert(x*2+1,mid+1,r,id);
}

struct rec{
    int l,r,d,u;
}b[N];

vector<pii> v[N];
priority_queue<pii> q;

int dis[N],ans[N];
bool vis[N];
void erase(int x, int l, int r, int id){ // 松弛一个虚点
    if (l >= b[id].l && r <= b[id].r){
        auto it = s[x].lower_bound((pii){b[id].d, 0}); // 二分找到y轴对应区间
        while(it != s[x].end() && (*it).fi <= b[id].u){
            for (pii y:v[(*it).se]){
                if (vis[y.se]) continue;
                if (dis[y.se] > dis[id]+y.fi){ // 普通 dij 松弛
                    dis[y.se] = dis[id]+y.fi;
                    q.push({-dis[y.se], y.se});
                }
            }
            ans[(*it).se] = min(dis[id], ans[(*it).se]);
            auto tmp = it;
            it++;
            s[x].erase(tmp); // 删点
        }
        return;
    }
    int mid = l+r>>1;
    if (b[id].l <= mid) erase(x*2,l,mid,id);
    if (b[id].r > mid) erase(x*2+1,mid+1,r,id);
}
signed main(){
    // freopen("a.in","r",stdin);
    // freopen("a.out","w",stdout);
    ios::sync_with_stdio(false); cin.tie(0u); cout.tie(0u);
    cin >> n >> m >> w >> h;
    for (int i = 1; i <= n; i++){
        cin >> a[i].fi >> a[i].se;
        insert(1,1,n,i);
    }
    for (int i = 1; i <= m; i++){
        int p,t,l,r,d,u;
        cin >> p >> t >> b[i].l >> b[i].r >> b[i].d >> b[i].u;
        v[p].push_back({t,i});
    }
    memset(dis,0x3f3f3f3f,sizeof dis);
    memset(ans,0x3f3f3f3f,sizeof ans);

    for (pii y:v[1]){
        q.push({-y.fi,y.se});
        dis[y.se] = y.fi;
    }

    while (!q.empty()){
        pii x = q.top();
        q.pop();
        vis[x.se] = 1;
        erase(1,1,n,x.se);
    }
    for (int i = 2; i <= n; i++) cout << ans[i] << endl;

    return 0;
}        
```


---

## 作者：Owen_codeisking (赞：17)

卡空间还行。

那我把自己的思路讲讲吧。

### 算法 $1$：暴力

直接暴力，时间 $O(nm)$，期望得分 $32pts$

### 算法 $2$：线段树优化建图

不难发现这是一个二维的线段树优化建图。

我比较垃圾，不会线段树套 $Treap$，我讲一个动态开点线段树的做法。

先对于每个 $x$ 坐标相同的数建一棵线段树，然后像普通线段树 $id_{lson}=id_{x}\times 2,id_{rson}=id_{x}\times 2+1$ 的方式把这些点找出来，对于这些点再建一棵线段树，询问时左右端点要在 $vector$ 上二分一下。（可能比较抽象，最好自己画图理解一下）

不难发现这样时间 $O(n\log^2 n)$，空间 $O(n\log^2 n)$，完美被卡，期望得分 $88pts$

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define mp make_pair
#define pb push_back
using namespace std;
const int maxn=70000+10;
const int inf=0x3f3f3f3f;
int n,m,w,h,x[maxn],y[maxn],rt[maxn],ls[maxn*20],rs[maxn*20],sz,cnt;
int dis[maxn*40];bool vis[maxn*40];vector<pii> G[maxn*40];
vector<pii> P[maxn],p[maxn<<2];

inline int read()
{
    register int x=0,f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
    return (f==1)?x:-x;
}

inline void addedge(int x,int y,int w)
{
   G[x].pb(mp(y,w));
}

void update(int &x,int l,int r,int pos,int city)
{
    if(!x) x=++sz;
    if(l == r) {addedge(x,city,0);return;}
    int mid=(l+r)>>1;
    if(pos <= mid) update(ls[x],l,mid,pos,city);
    else update(rs[x],mid+1,r,pos,city);
}
void dfs(int x,int rt,int line)
{
    p[rt].pb(mp(line,x));
    if(ls[x]) addedge(x,ls[x],0),dfs(ls[x],rt<<1,line);
    if(rs[x]) addedge(x,rs[x],0),dfs(rs[x],rt<<1|1,line);
}
int T[maxn<<2],lc[maxn*60],rc[maxn*60],L,R,D,U,Pos,Time;
void buildtree(int x,int rt,int l,int r)
{
    if(l == r) {addedge(x,p[rt][l].second,0);return;}
    lc[x-cnt]=++sz,rc[x-cnt]=++sz;
    addedge(x,lc[x-cnt],0),addedge(x,rc[x-cnt],0);
    int mid=(l+r)>>1;
    buildtree(lc[x-cnt],rt,l,mid);
    buildtree(rc[x-cnt],rt,mid+1,r);
}
void build(int l,int r,int rt)
{
    if(!p[rt].empty())
    {
        T[rt]=++sz;
        buildtree(T[rt],rt,0,(int)p[rt].size()-1);
    }
    if(l == r) return ;
    int mid=(l+r)>>1;
    build(l,mid,rt<<1);
    build(mid+1,r,rt<<1|1);
}
void getrow(int x,int L,int R,int l,int r)
{
    if(L <= l && r <= R) {addedge(Pos,x,Time);return;}
    int mid=(l+r)>>1;
    if(L <= mid) getrow(lc[x-cnt],L,R,l,mid);
    if(R > mid) getrow(rc[x-cnt],L,R,mid+1,r);
}
void getline(int l,int r,int rt)
{
    if(D <= l && r <= U)
    {
        if(!p[rt].empty())
        {
            int left=lower_bound(p[rt].begin(),p[rt].end(),mp(L,0))-p[rt].begin();
            int right=lower_bound(p[rt].begin(),p[rt].end(),mp(R+1,0))-p[rt].begin()-1;
            if(left<=right) getrow(T[rt],left,right,0,(int)p[rt].size()-1);
        }
        return ;
    }
    int mid=(l+r)>>1;
    if(D <= mid) getline(l,mid,rt<<1);
    if(U > mid) getline(mid+1,r,rt<<1|1);
}
inline void spfa()
{
    memset(dis,inf,sizeof(dis));
    queue<int> q;
    dis[1]=0;vis[1]=1;q.push(1);
    int u,v;
    vector<pii>::iterator it;
    while(!q.empty())
    {
        u=q.front(),q.pop();vis[u]=0;
        for(it=G[u].begin();it!=G[u].end();it++)
        {
            v=it->first;
            if(dis[v]>dis[u]+it->second)
            {
                dis[v]=dis[u]+it->second;
                if(!vis[v]) vis[v]=1,q.push(v);
            }
        }
    }
}

int main()
{
    freopen("jump.in","r",stdin);
    freopen("jump.out","w",stdout);
    n=read(),m=read(),w=read(),h=read();
    for(int i=1;i<=n;i++) x[i]=read(),y[i]=read(),P[x[i]].pb(mp(y[i],i));
    sz=n;
    vector<pii>::iterator it;
    for(int i=1;i<=w;i++)
    {
        for(it=P[i].begin();it!=P[i].end();it++)
            update(rt[i],1,h,it->first,it->second);
        if(rt[i]) dfs(rt[i],1,i);
    }
    cnt=sz;
    build(1,h,1);
    for(int i=1;i<=m;i++)
    {
        Pos=read(),Time=read(),L=read(),R=read(),D=read(),U=read();
        getline(1,h,1);
    }
    spfa();
    for(int i=2;i<=n;i++) printf("%d\n",dis[i]);
    return 0;
}
```

至于为什么我写了 $spfa$。。。主要是图是你自己建的，不是出题人给的，一般不会卡，直接头铁准没错。

### 算法 $3$：$KD$ 树优化建图

如果用 $KD$ 树优化建图，点数 $O(n)$ ，边数 $O(m\sqrt n)$，直接爆炸，期望得分 $88pts$

~~虽然我不知道为什么我直接暴力 KD 树 WA 了 3 个点~~

### 算法 $4$：优化算法 $3$

其实就是把空间降下来。

我们考虑用 $dijkstra$。一个点只会被更新一次，这样的话就好做了。

我们在 $KD$ 树上维护两个标记 $tag,val$，分别表示全局更新的最小值和当前点的最小值，两个标记取个 $min$ 就是当前点的答案。

然后我们在每个点再维护一个 $mn,id$，表示子树内的最小答案和最小答案所在的编号。

难道我们用 $KD$ 树打一下标记就做完了？

那还是有一些细节/剪枝的。

- 若当前点已被清空，子树内还有其他值，那么上传标记的时候最小答案要对当前点的 $tag$ 取 $min$

- 在对一个子树取 $min$ 的时候，要重新上传一次。

- 若当前点的 $tag$ 小于要更新的值，直接返回

时间 $O(m\sqrt n)$，空间 $O(n)$，期望得分 $100pts$

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define mp make_pair
using namespace std;
const int maxn=70000+10;
const int inf=0x3f3f3f3f;
int n,m,w,h,rt,D,L,R,X,Y,Pos,Time,ans[maxn],sta[maxn],top;

struct Edge
{
	int t,l,r,x,y;
};
vector<Edge> G[maxn];

inline int read()
{
	register int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return (f==1)?x:-x;
}

struct node
{
    int d[2],id;
}a[maxn];
inline bool operator < (const node &a,const node &b) {return a.d[D]<b.d[D];}

struct KD_Tree
{
    int Max[2],Min[2],d[2],ch[2],fa,id,w,tag,val;pii mn;
    inline void get(const node &a)
	{
    	Max[0]=Min[0]=d[0]=a.d[0];
    	Max[1]=Min[1]=d[1]=a.d[1];
    	fa=0;id=a.id;w=1;tag=val=inf;mn=mp(inf,inf);
    }
}t[maxn];

template <class T> inline void chkmax(T &x,T y) {x=(x>y)?x:y;}
template <class T> inline void chkmin(T &x,T y) {x=(x<y)?x:y;}
inline void update(int x,int y)
{
    chkmax(t[x].Max[0],t[y].Max[0]);
    chkmax(t[x].Max[1],t[y].Max[1]);
    chkmin(t[x].Min[0],t[y].Min[0]);
    chkmin(t[x].Min[1],t[y].Min[1]);
}
inline void pushup(int x)
{
	t[x].mn=mp(t[x].w?min(t[x].tag,t[x].val):inf,t[x].w?x:inf);
	if(t[x].ch[0]) chkmin(t[x].mn,t[t[x].ch[0]].mn);
	if(t[x].ch[1]) chkmin(t[x].mn,t[t[x].ch[1]].mn);
	if(t[x].mn.second!=inf) chkmin(t[x].mn.first,t[x].tag);
}
inline void pushdown(int x)
{
	if(t[x].ch[0]) chkmin(t[t[x].ch[0]].tag,t[x].tag);
	if(t[x].ch[1]) chkmin(t[t[x].ch[1]].tag,t[x].tag);
}
int build(int l,int r,int now)
{
    int mid=(l+r)>>1,x=mid;D=now;
    nth_element(a+l,a+mid,a+r+1);t[x].get(a[mid]);
    if(l<mid) t[x].ch[0]=build(l,mid-1,now^1),t[t[x].ch[0]].fa=x;
    if(mid<r) t[x].ch[1]=build(mid+1,r,now^1),t[t[x].ch[1]].fa=x;
    if(t[x].ch[0]) update(x,t[x].ch[0]);
    if(t[x].ch[1]) update(x,t[x].ch[1]);
	pushup(x);return x;
}
void query(int x)
{
	if(!x || t[x].tag < Time) return ;
	if(t[x].Max[0] < L || t[x].Min[0] > R
	|| t[x].Max[1] < X || t[x].Min[1] > Y) return ;
	if(L <= t[x].Min[0] && t[x].Max[0] <= R
	&& X <= t[x].Min[1] && t[x].Max[1] <= Y)
	{
		chkmin(t[x].tag,Time);
		pushup(x);
		return ;
	}
	pushdown(x);
	if(L <= t[x].d[0] && t[x].d[0] <= R
	&& X <= t[x].d[1] && t[x].d[1] <= Y) chkmin(t[x].val,Time);
    query(t[x].ch[0]);query(t[x].ch[1]);pushup(x);
}

int main()
{
	freopen("jump.in","r",stdin);
	freopen("jump.out","w",stdout);
    n=read(),m=read(),w=read(),h=read();
    for(int i=1;i<=n;i++) a[i].d[0]=read(),a[i].d[1]=read(),a[i].id=i;
    rt=build(2,n,0);
    for(int i=1;i<=m;i++)
    {
    	Pos=read(),Time=read(),L=read(),R=read(),X=read(),Y=read();
    	G[Pos].push_back((Edge){Time,L,R,X,Y});
	}
	int x,y;
	vector<Edge>::iterator it;
	for(int i=1;i<=n;i++)
	{
		if(i==1) x=1,y=0;
		else
		{
			y=t[rt].mn.second;t[y].w=0;
			x=t[y].id;ans[x]=t[rt].mn.first;top=0;
			for(;y;y=t[y].fa) sta[++top]=y;
			for(int j=top;j;j--) pushdown(sta[j]);
			for(int j=1;j<=top;j++) pushup(sta[j]);
		}
		for(it=G[x].begin();it!=G[x].end();it++)
		{
			Time=ans[x]+it->t,L=it->l,R=it->r,X=it->x,Y=it->y;
			query(rt);
		}
	}
	for(int i=2;i<=n;i++) printf("%d\n",ans[i]);
    return 0;
}
```

总结：如果空间比较松的话，这题算是一道裸题。不过这题线性空间的做法还是值得思考的。

---

## 作者：yzhang (赞：14)

[原题传送门](https://www.luogu.org/problemnew/show/P5471)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11211581.html)

先考虑部分分做法：

### subtask1：

暴力$O(nm)$枚举，跑最短路

### subtask2:

吧一行的点压到vector中并排序，二分查找每一个弹跳装置珂以到达的城市，跑最短路

### subtask3：

看见是一个链，自然而然的可以想到线段树优化建图，跑最短路

### 100pts

上面是72pts的暴力做法，其中subtask3的做法给了我们了一些提示，这题要用数据结构优化建图：

在横轴上开一颗线段树，线段树每个节点上是一个存pair的set，存的是$[l,r]$区间内有第$id$个点($px[id] \in [l,r]$)，这个点的纵坐标是$py[id]$（pair要把纵坐标放前面）

类似线段树优化建图，我们要创建一些虚拟节点：对于第$i$个弹跳装置，我们创建一个编号为$i+n$的虚拟点，且到虚拟点的距离为所用时间$T[i]$

我们从$1$号点跑最短路。假如现在对顶是$x$号节点，当$x \leq n$时，我们更新起点为$x$的弹跳装置的虚拟点的dis，并扔进堆；否则就在线段树上先找到$[L[x-n],R[x-n]]$这个区间($x-n$就是该虚拟点所对应弹跳装置的编号)，在这个区间所含的线段树节点上二分出$D[x-n] \leq py[id] \leq U[x-n]$中的节点，尝试更新dis，如果成功加入队列，不管成不成功，都从set中删除（根据dij的特性）。

这样最后输出dis[2~n]就行了

这个算法的复杂度是$O((n+m)\log(n+m)+n\log^2 n)$,常数略(da)大(dao)一(mei)点(jiu)

($(n+m)\log(n+m)$是$n+m$个点dij的复杂度，$n\log^2 n$是$n$个节点，每个拆成$\log n$个，在set中insert,lowerbound,erase的复杂度)

```cpp
#include <bits/stdc++.h>
#define N 70005
#define M 150005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
int n,m,w,h;
int px[N],py[N];
int P[M],T[M],L[M],R[M],D[M],U[M];
set<pair<int,int> > s[N<<2];
vector<int> nv[N];
struct node{
    int dis,pos;
    bool operator < (const node &x) const{
        return x.dis<dis;
    }
};
priority_queue<node> q;
int dis[N+M],vis[N+M];
inline void modify(register int x,register int l,register int r,register int id)
{
    s[x].insert(make_pair(py[id],id));
    if(l==r)
        return;
    int mid=l+r>>1;
    if(px[id]<=mid)
        modify(x<<1,l,mid,id);
    else
        modify(x<<1|1,mid+1,r,id);
}
inline void change(register int x,register int l,register int r,register int id)
{
    if(L[id]<=l&&r<=R[id])
    {
        set<pair<int,int> >::iterator it;
        while(19260817)
        {
            it=s[x].lower_bound(make_pair(D[id],-1));
            if(it==s[x].end()||it->first>U[id])
                break;
            int to=it->second;
            if(dis[to]>dis[id+n])
            {
                dis[to]=dis[id+n];
                q.push((node){dis[to],to});
            }
            s[x].erase(it);
        }
        return;
    }
    int mid=l+r>>1;
    if(L[id]<=mid)
        change(x<<1,l,mid,id);
    if(R[id]>mid)
        change(x<<1|1,mid+1,r,id);
}
int main()
{
    n=read(),m=read(),w=read(),h=read();
    for(register int i=1;i<=n;++i)
    {
        px[i]=read(),py[i]=read();
        if(i!=1)
            modify(1,1,w,i);
    }
    for(register int i=1;i<=m;++i)
    {
        P[i]=read(),T[i]=read(),L[i]=read(),R[i]=read(),D[i]=read(),U[i]=read();
        nv[P[i]].push_back(i+n);
    }
    for(register int i=1;i<=n;++i)
        dis[i]=1926081700,vis[i]=0;
    dis[1]=0;
    q.push((node){0,1});
    while(!q.empty())
    {
        node tmp=q.top();
        q.pop();
        int x=tmp.pos;
        if(vis[x])
            continue;
        vis[x]=1;
        if(x<=n)
        {
            for(register int i=0;i<nv[x].size();++i)
            {
                int y=nv[x][i];
                dis[y]=dis[x]+T[y-n];
                q.push((node){dis[y],y});
            }
        }
        else
            change(1,1,w,x-n);
    }
    for(register int i=2;i<=n;++i)
        write(dis[i]),puts("");
	return 0;
}
```

---

## 作者：StudyingFather (赞：11)

## 测试点 $1 \sim 13$

这些测试点中，暴力连边跑最短路的时间和空间复杂度（当然前提是你得用最坏复杂度可以通过的最短路算法）可以接受。

建图的时间复杂度：

- 测试点 $1 \sim 8$：$O(n^2)$；
- 测试点 $9 \sim 13$：$O(n \log n)$。

## 测试点 $14 \sim 18$

平面退化成了直线，而我们连边总是从某个点连向在某个区间内的所有点。考虑使用**线段树优化建图**。

我们先建出线段树，其中树上的每个点向其两个子节点各连一条边权为 $0$ 的边，每个叶子节点向其对应的真实节点连一条边权为 $0$ 的边。

建图的方式和线段树维护区间信息差不多，我们只需向线段树上能覆盖对应区间的点连边即可。和线段树维护区间信息一样，我们一次最多连 $O(\log n)$ 条边。

因此我们连的总边数为 $O(n+m \log n)$。

## 满分做法

现在考虑二维平面上的问题。

考虑在线段树套线段树上建图。和一维的情况类似，我们先在外层查询满足 $x$ 范围的点，再在内层查询满足 $y$ 范围的点来建图即可。

树套树的空间复杂度为：$O(n \log^2 n)$。连边的总数为 $O(m \log^2 n)$。因为本题空间限制较小，上面的做法无法通过本题。

如何优化空间？

可以将内层的线段树换成 set。从而数据结构的空间复杂度为 $O(n \log n)$。

更棒的是，我们实际上可以不将边连出来，从而省下了建图的空间。

不建图怎么求最短路？直接利用已有的弹跳装置的信息来更新最短路。

我们回想一下 Dijkstra 求最短路的性质。我们每次从堆顶取出的点，其最短路已经是确定的，不会再更新。

设从 $1$ 号点经过第 $i$ 个弹跳装置的最短路为 $w_i$，我们先将从 $1$ 开始的所有装置扔进堆里。

从堆中取出 $w_i$ 最小的装置（根据上文所述，这个装置的 $w_i$ 不会再更新），在线段树套 set 里查询当前装置能到达的点，将这些点的最短路更新为 $w_i$，随后将这些点从数据结构里删除（根据上面的描述，这些点的最短路不会再更新）。与此同时，我们更新经过当前装置能直接到达的装置的 $w_i$ 值。

```cpp
// Problem : P5471 [NOI2019]弹跳
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P5471
// Memory Limit : 125 MB
// Time Limit : 2200 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#include <vector>
#include <set>
#include <queue>
using namespace std;
struct point
{
 int x,y,id;
 bool operator<(const point&a)const
 {
  return y<a.y||(y==a.y&&x<a.x);
 }
}p[70005];
struct edge
{
 int p,t,l,r,d,u;
}e[150005];
struct node
{
 int u,dis;
 bool operator>(const node&a)const
 {
  return dis>a.dis;
 }
};
vector<int> f[70005];
set<point> s[300005];
priority_queue<node,vector<node>,greater<node> > q;
int dis[70005],vis[150005];
int n,m,w,h;
void add(int root,int l,int r,int x)
{
 s[root].insert(p[x]);
 if(l==r)return;
 int mid=(l+r)>>1;
 if(p[x].x<=mid)add(root<<1,l,mid,x);
 else add(root<<1|1,mid+1,r,x);
}
void del(int root,int l,int r,int x)
{
 s[root].erase(p[x]);
 if(l==r)return;
 int mid=(l+r)>>1;
 if(p[x].x<=mid)del(root<<1,l,mid,x);
 else del(root<<1|1,mid+1,r,x);
}
void modify(int root,int cl,int cr,int x,int d)
{
 queue<int> dq;
 int l=e[x].l,r=e[x].r;
 if(cr<l||r<cl)return;
 if(l<=cl&&cr<=r)
 {
  auto it=s[root].lower_bound((point){0,e[x].d,0});
  //在线段树套 set 里找每个装置能到达的点
  for(;it!=s[root].end()&&it->y<=e[x].u;it++)
  {
   int u=it->id;
   dis[u]=d;//更新这些点的最短路
   dq.push(u);
   for(auto v:f[u])//将经过当前装置能到达的下一个装置插入堆
    q.push({v,d+e[v].t});
  }
  while(!dq.empty())//将这些点从数据结构中删除
  {
   int u=dq.front();
   dq.pop();
   del(1,1,n,u);
  }
  return;
 }
 int mid=(cl+cr)>>1;
 modify(root<<1,cl,mid,x,d);
 modify(root<<1|1,mid+1,cr,x,d);
}
int main()
{
 ios::sync_with_stdio(false);
 cin>>n>>m>>w>>h;
 for(int i=1;i<=n;i++)
 {
  cin>>p[i].x>>p[i].y;
  p[i].id=i;
  add(1,1,n,i);//将所有点扔进线段树套 set 里
 }
 for(int i=1;i<=m;i++)
 {
  cin>>e[i].p>>e[i].t>>e[i].l>>e[i].r>>e[i].d>>e[i].u;
  f[e[i].p].push_back(i);//维护从 i 号点出发的装置列表
 }
 e[0].l=e[0].r=p[1].x;
 e[0].d=e[0].u=p[1].y;
 q.push({0,0});
 while(!q.empty())
 {
  int u=q.top().u,d=q.top().dis;
  q.pop();
  if(vis[u])continue;//和 Dijkstra 一样，已经走过的装置不必再走
  vis[u]=1;
  modify(1,1,n,u,d);
 }
 for(int i=2;i<=n;i++)
  cout<<dis[i]<<endl;
 return 0;
}
```

---

## 作者：Great_Influence (赞：10)

首先，观察数据范围，发现很适合一个根号算法，因此采用 kd-tree 解决问题。

但是如果我们直接建边的话，边数会达到 $O(m\sqrt n)$ 级别，约等于 $4e7$ ，显然空间开多少都不够。

但是这张图显然是有特性的：即没有负边。这很适合采用 $dijkstra$ 算法。

因此，我们不去建边，而是直接 **在kd-tree上进行最短路**。

具体来说，我们建一个堆，和一个 kd-tree 。一开始，堆中间只有 $1$ 号点。

每轮，我们取出堆顶元素，然后利用堆顶的连边情况在 kd-tree 上打区间 $chkmin$ 标记。注意，这个标记不需要下传。

可以发现这样做无法快速更新堆中元素到 $1$ 号点距离，难以取点。不过，可以注意到，只有被更新过的点才有可能产生贡献。因此我们每次更新过后向堆中放入 **kd-tree对应区间的节点** ，即一次性将整个区间都丢进去。

然后我们每次从堆中提出堆顶元素，再找到这个元素对应区间中 **还没有作为起点更新过其他节点的所有节点** ，然后将这些节点放到操作序列中按序更新。

容易发现这样做的话 kd-tree 上的每个节点都只会被提出来 $1$ 次，每次更新复杂度为 $O(\sqrt n)$ ，因此总复杂度为 $O(n\log n+m\sqrt n)$ 。

顺便一提，为了更方便地提出 kd-tree 上的整个区间以及在整个区间上打 tag ，可以将 kd-tree 建成实际信息只在叶子上的样子。

为了节省时间，其实可以将更新过的节点直接从 kd-tree 上删掉并向上合并。这样可以方便快速找到适合的堆顶元素。

代码没得。

---

## 作者：LZDQ (赞：10)

前天发了篇D1T1的题解，今天我又来了

看完全部题目，T2T3是啥啊，还是回来看T1吧

哈哈哈，又是最短路！

------------

dij的性质就是**每个点只会被标记一次**，并且权值非负。

这是个很好的性质！就是说，我们dij的时候只要把新增的矩形内**没有被标记过的点**标记就好了。

转化：每次把一个矩形内的点全部去掉，并赋值。

看到这里，如果你做过线段树的拓展，就很容易想到线段树！

类似线段树题目：bzoj4127 Abs  luogu4145 花神游历各国

~~其实我只是听过二维线段树而已，根本没写过，当场瞎敲一通就过了~~

------------

dij部分就不多说了，转化后怎么实现？

这里，我们不用考虑树套树，因为直接用二维线段树就行了。

好像很多人都不知道二维线段树？

二维线段树，就是用每个点表示一个正方形，这个正方形还可以分为4个子正方形。（类似二维st表）

我们用sum来表示一个线段树的正方形内剩下**没被标记过的点的总数**。

我们用递归来标记点，这样当一个正方形内没有未标记的点时就可以剪掉很多枝。

也就是，当递归到sum=0时，直接返回。

如果当前线段树矩形和dij里更新的矩形没有重合部分，也返回。

否则，继续递归四个子矩形。

当矩形缩成一个点时，在dij那边处理，并将sum清零。

回溯时更新sum值，就这么简单。

不过w和h最大都是n，没关系！用动态开点（就是用到一个区间再开一个区间）！

如果用动态开点，初始化就得一个一个城市加入。反正时限2秒，复杂度也对。

好像跑得挺快？虽然我不会算二维的复杂度

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int MAXN=7e4+5,MAXM=1.5e5+5;
int n,m,w,h;
struct node{
    int x,y;
    int h;
    int bgnid;	//用来输出
}city[MAXN];
inline bool cmp_city(node a,node b){
    if(a.x==b.x) return a.y<b.y;
    return a.x<b.x;
}
int GetID(int x,int y){	//根据坐标找城市编号（先排好序）
    node f;
    f.x=x,f.y=y;
    int l=1,r=n;
    while(l<r){
        int mid=l+r>>1;
        if(cmp_city(city[mid],f)) l=mid+1;
        else r=mid;
    }
    return r;
}
struct edge{
    int t,l1,r1,l2,r2;	//存一个矩形
    int d;
    inline void Init_bgn(){
        d=0;
        for(int i=1;i<=n;i++)
            if(city[i].bgnid==1){
                l1=l2=city[i].x;
                r1=r2=city[i].y;
                return ;
            }
    }
}ed[MAXM];
int cnte,nx[MAXM];
inline void adde(int &h,int t,int a,int b,int c,int d){
    cnte++;
    ed[cnte].t=t;
    ed[cnte].l1=a;
    ed[cnte].l2=b;
    ed[cnte].r1=c;
    ed[cnte].r2=d;
    nx[cnte]=h;
    h=cnte;
}
bool operator <(edge a,edge b){
    return a.d>b.d;	//dij里给优先队列重载
}
int dis[MAXN];
priority_queue<edge> que;
edge hd;
const int SIZ=1e7+5;
int cntseg,c1[SIZ],c2[SIZ],c3[SIZ],c4[SIZ];
#define getc1 c1[k],l1,r1,midx,midy		//4个子正方形的宏定义（降低代码量）
#define getc2 c2[k],l1,midy+1,midx+1,r2
#define getc3 c3[k],midx+1,r1,l2,midy
#define getc4 c4[k],midx+1,midy+1,l2,r2
int sum[SIZ];
inline void pushup(int k){
    sum[k]=sum[c1[k]]+sum[c2[k]]+sum[c3[k]]+sum[c4[k]];	//标记上传
}
void modify1(int &k,int l1,int r1,int l2,int r2,const node &ct){	//初始化用的函数
    if(!k) k=++cntseg;
    if(l1==l2&&r1==r2){
        sum[k]=1;
        return ;
    }
    int midx=l1+l2>>1,midy=r1+r2>>1;
    if(ct.x<=midx){
        if(ct.y<=midy) modify1(getc1,ct);
        else modify1(getc2,ct);
    }
    else{
        if(ct.y<=midy) modify1(getc3,ct);
        else modify1(getc4,ct);
    }
    pushup(k);
    return ;
}

void modify2(int k,int l1,int r1,int l2,int r2,const edge &e){	//dij更新一个矩形内的点
    if(l1>e.l2||r1>e.r2||l2<e.l1||r2<e.r1) return ;	//没有重合部分
    if(!sum[k]) return ;
//	printf("mdf2 %d %d %d %d\n",l1,r1,l2,r2);
    if(l1==l2&&r1==r2){
    	//缩成一个点，直接修改dij里面用的优先队列
        sum[k]=0;
        int p=GetID(l1,r1);
        dis[p]=e.d;
        for(int i=city[p].h;i;i=nx[i]){
            edge t=ed[i];
            t.d=e.d+t.t;
            que.push(t);
        }
        return ;
    }
    int midx=l1+l2>>1,midy=r1+r2>>1;
    modify2(getc1,e);	//递归4个子正方形
    modify2(getc2,e);
    modify2(getc3,e);
    modify2(getc4,e);
    pushup(k);
    return ;
}

inline void Print(){//调试用
    for(int i=1;i<=n;i++)
        printf("u %d dis %d\n",city[i].bgnid,dis[i]);
    puts("");
    return ;
}

void dij(){
    cntseg=1;
    int one=1;
    for(int i=1;i<=n;i++)
        modify1(one,1,1,n,n,city[i]);	//线段树初始化
    
    memset(dis,0x3f,sizeof(dis));
//	dis[1]=0;
    edge bgn;
    bgn.Init_bgn();
    que.push(bgn);
    while(!que.empty()){
        edge hd=que.top();
        que.pop();	//dij没什么好讲的吧
//		printf("Start mdf2 %d %d %d %d dis %d\n",hd.l1,hd.r1,hd.l2,hd.r2,hd.d);
        modify2(1,1,1,n,n,hd);
//		Print();
    }
    return ;
}
/*

5 3 5 5
1 1
3 1
4 1
2 2
3 3
1 123 1 5 1 5
1 50 1 5 1 1
3 10 2 2 2 2


*/
int ans[MAXN];
int main(){
//	freopen("jump.in","r",stdin);
//	freopen("jump.out","w",stdout);
    scanf("%d%d%d%d",&n,&m,&w,&h);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&city[i].x,&city[i].y),city[i].bgnid=i;
    for(int i=1;i<=m;i++){
        int p,t,a,b,c,d;
        scanf("%d%d%d%d%d%d",&p,&t,&a,&b,&c,&d);
        adde(city[p].h,t,a,b,c,d);
    }
    sort(city+1,city+n+1,cmp_city);
    dij();
    for(int i=1;i<=n;i++)
        ans[city[i].bgnid]=dis[i];
    for(int i=2;i<=n;i++)
        printf("%d\n",ans[i]);
//	fclose(stdin);
//	fclose(stdout);
    return 0;
}
```


------------

### 总结

轻松水过T1！相比Day1，只花了2h做T1，还能AC，进步真大！

看来，有时候得分与目标是成正比的。Day1老是想打部分分，结果与正解擦边而过。今天想A题，不仅不用管部分分，还节省了时间。

今年NOI，spfa基本死地彻彻底底了，因为dij有一个被OIer们遗忘很久的性质。

一些算法看似浅显，却像海绵一样（大家都知道我想说什么了）

OI里面到底有没有像文化课里的套路，这真是个谜。谁也说不清算法里面有多少性质可以用，谁知道明年会不会考个spfa把dij卡掉呢？其实人家spfa还是有很多性质的（比如说很不稳定）


---

## 作者：EnofTaiPeople (赞：9)

K-D Tree 既然是处理高维数据的利器，自然也有着优化建图的功能，这题一看就知道是裸的最短路板子，但由于边数过多，又与二维数点矩形查询相关，可以使用 K-D Tree。有一定经验的同学一定知道，很多时候时间与空间并不均等，这道题更是略微卡常数，如果真的将边连起来，就不知道是 MLE 还是 TLE 了，当将一个节点进行松弛时，将从他出发的每一个弹跳机在 K-D Tree 上修改，最短路需要使用 Dijkstra 算法！由于瓶颈不在于堆，所以 SPFA 在这一年又死了一次。

代码很好写，只用了半小时：
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
#define ns __gnu_pbds
using namespace std;
const int T=70004,N=150005;
char buf[N+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
inline int read(){
	int x,f=1;for(c=gc;c<'0'||c>'9';c=gc)if(c=='-')f=-f;
	for(x=0;c>='0'&&c<='9';x=x*10+(48^c),c=gc);
	return x*f;
}
struct Dat{int w,lx,rx,ly,ry;}g[N];
vector<int>lk[T];
int n,m,lx[N],rx[N],ly[N],ry[N],mx[N],my[N],lc[N],rc[N],ax[N],ay[N],a[N],lt[N],rt[N];
bool cmptp;
inline bool cmpI(const int &x,const int &y){
	return cmptp?ay[x]<ay[y]:ax[x]<ax[y];
}
typedef long long ll;
typedef pair<ll,int>Tp;
long long d[T],ds[T];
ns::priority_queue<Tp,greater<Tp>,ns::pairing_heap_tag>pq;
double px,py,fx,fy;
bitset<N>vs;
int cnt;
int build(int l,int r){
	int x=l+r>>1,i;ds[x]=1e15;lt[x]=l,rt[x]=r;
	px=py=0;for(i=l;i<=r;++i)px+=ax[a[i]],py+=ay[a[i]];
	fx=fy=0;for(i=l;i<=r;++i)fx+=(px-ax[a[i]])*(px-ax[a[i]]),fy+=(py-ay[a[i]])*(py-ay[a[i]]);
	cmptp=fx<fy,nth_element(a+l,a+x,a+r+1,cmpI);
	lx[x]=rx[x]=mx[x]=ax[a[x]],ly[x]=ry[x]=my[x]=ay[a[x]];
	if(l<x)lc[x]=build(l,x-1),lx[x]=min(lx[x],lx[lc[x]]),rx[x]=max(rx[x],rx[lc[x]]),
	ly[x]=min(ly[x],ly[lc[x]]),ry[x]=max(ry[x],ry[lc[x]]);
	if(x<r)rc[x]=build(x+1,r),lx[x]=min(lx[x],lx[rc[x]]),rx[x]=max(rx[x],rx[rc[x]]),
	ly[x]=min(ly[x],ly[rc[x]]),ry[x]=max(ry[x],ry[rc[x]]);return x;
}
void ask(int l,int r){
	int x=l+r>>1;if(ds[x]<d[0])return;
	if(lx[x]>=g[0].lx&&rx[x]<=g[0].rx&&ly[x]>=g[0].ly&&ry[x]<=g[0].ry){
		ds[x]=d[0];pq.push(Tp(ds[x],x+n));return;
	}if(d[a[x]]>d[0]&&mx[x]>=g[0].lx&&mx[x]<=g[0].rx&&my[x]>=g[0].ly&&my[x]<=g[0].ry)
		d[a[x]]=d[0],pq.push(Tp(d[a[x]],a[x]));
	if(lx[x]>g[0].rx||rx[x]<g[0].lx||ly[x]>g[0].ry||ry[x]<g[0].ly)return;
	if(l<x)ask(l,x-1);if(x<r)ask(x+1,r);return;
}
int main(){
	n=read(),m=read();read(),read();int i,x;
	for(i=1;i<=n;++i)ax[i]=read(),ay[i]=read(),a[i]=i;
	for(i=1;i<=m;++i){
		x=read();g[i]={read(),read(),read(),read(),read()};
		lk[x].push_back(i);
	}build(1,n);
	for(i=2;i<=n;++i)d[i]=1e15;
	pq.push(Tp(d[1],1));
	while(!pq.empty()){
		x=pq.top().second,pq.pop();
		if(vs[x])continue;
		else vs[x]=1;
		if(x>n){
			for(x-=n,i=lt[x];i<=rt[x];++i)
				if(d[a[i]]>ds[x])pq.push(Tp(d[a[i]]=ds[x],a[i]));
		}else{
			for(int y:lk[x])
				g[0]=g[y],d[0]=d[x]+g[y].w,ask(1,n);
		}
	}for(i=2;i<=n;++i)printf("%lld\n",d[i]);
	return 0;
}
```

---

## 作者：qwaszx (赞：9)

处理这类特殊连边的套路方法(边权非负):

以下边的含义都是特殊边，形如从集合 $S_1$ 中的所有点连向集合 $S_2$ 中的所有点.

直接使用某种数据结构连边之后跑 dijkstra，复杂度 $O((n+\text{边数})\times \log (n+\text{边数}))$.(实际上使用斐波那契堆可以做到$O(\text{边数}+n\log n)$，但为了方便还是使用 stl 的优先队列来完成).一般来说边数就是 $m\times \text{数据结构单次复杂度}$.

然而可以把到边和点的最短路一起用 dijkstra 维护.具体地，定义到一条边的最短路为其所有起点的最短路的最小值加上边长，每次从堆中取出长度最短的元素，如果该元素为点那么就更新所有起点包含它的边的最短路，否则的话就更新该边的所有终点的最短路.那么由于每次堆中取出的都是最短路，所以每个元素都只会被更新一次.事实上我们通常写的 dijkstra 是省略了边的做法.

那么看一下我们需要做什么:取出所有起点包含某个点的边，取出某条边的所有终点，删除一条边或一个点.找一个数据结构维护即可.这样复杂度是 $O((n+m)\times \text{数据结构单次复杂度}+(n+m)\log)$.一般点和边的操作可能不是通过一个数据结构来完成的，但为了方便姑且这样写.

具体到这道题，发现找边的操作可以直接用 vector 进行，找/删点的操作可以使用树套树或者 kdtree 完成，删边没有必要因为起点总在边之前删掉.边和点的松弛可以放在一起进行.

以下是常数巨大的线段树套 set 的代码.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#include<set>
using namespace std;
const int N=300005;
struct Edge{int w,x1,x2,y1,y2;}tmpe[N];
vector<int>e[N];
struct Point{int x,y;}pos[N];
struct Node{int id,dis;bool operator <(const Node &a)const{return dis>a.dis;}};
set<pair<int,int> >a[N];
priority_queue<Node>q;
int dis[N],n,m,tmp[N],vis[N],W,H;
void ins(int rot,int lt,int rt,int x,pair<int,int>w)
{
    a[rot].insert(w);
    if(lt==rt)return;
    int mid=(lt+rt)>>1;
    if(x<=mid)ins(rot<<1,lt,mid,x,w);
    else ins(rot<<1|1,mid+1,rt,x,w);
}
void del(int rot,int lt,int rt,int x,pair<int,int>w)
{
    a[rot].erase(w);
    if(lt==rt)return;
    int mid=(lt+rt)>>1;
    if(x<=mid)del(rot<<1,lt,mid,x,w);
    else del(rot<<1|1,mid+1,rt,x,w);
}
void update(int rot,int lt,int rt,int x1,int x2,int y1,int y2,int w)
{
    if(lt>=x1&&rt<=x2)
    {
        if(!a[rot].size())return;
        set<pair<int,int> >::iterator L=a[rot].lower_bound(make_pair(y1,0)),R=a[rot].upper_bound(make_pair(y2,114514));
        int tn=0;
        for(set<pair<int,int> >::iterator i=L;i!=R;i++)
        {
            int u=i->second;dis[u]=w;tmp[++tn]=u;
            for(vector<int>::iterator it=e[u].begin();it!=e[u].end();it++)
                q.push((Node){*it,tmpe[*it].w+w});
        }
        for(int i=1;i<=tn;i++)del(1,1,W,pos[tmp[i]].x,make_pair(pos[tmp[i]].y,tmp[i]));
        return;
    }
    int mid=(lt+rt)>>1;
    if(x1<=mid)update(rot<<1,lt,mid,x1,x2,y1,y2,w);
    if(x2>mid)update(rot<<1|1,mid+1,rt,x1,x2,y1,y2,w);
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&W,&H);
    for(int i=1,x,y;i<=n;i++)scanf("%d%d",&pos[i].x,&pos[i].y),ins(1,1,W,pos[i].x,make_pair(pos[i].y,i));
    for(int i=1,x,t,L,R,D,U;i<=m;i++)
    {
        scanf("%d%d%d%d%d%d",&x,&t,&L,&R,&D,&U);
        e[x].push_back(i);tmpe[i]=(Edge){t,L,R,D,U};
    }
    dis[1]=0;for(int i=2;i<=n;i++)dis[i]=1e9;
    for(vector<int>::iterator it=e[1].begin();it!=e[1].end();it++)q.push((Node){*it,tmpe[*it].w});
    while(!q.empty())
    {
        Node t=q.top();q.pop();
        if(vis[t.id])continue;vis[t.id]=1;
        update(1,1,W,tmpe[t.id].x1,tmpe[t.id].x2,tmpe[t.id].y1,tmpe[t.id].y2,t.dis);
    }
    for(int i=2;i<=n;i++)printf("%d\n",dis[i]);
}
```

---

## 作者：Fading (赞：8)

这道题目：

刚开始看，不是裸题吗？***优化建图随便水。

但是空间限制$128MB$...

当我准备放弃这道题的时候，我...

发现洛谷上有人问我可不可以不把边建出来？？？

~~听君一席话胜读十年书~~我茅塞顿开 ~~，马上就切了此题~~

然后，这道题就写了我$4$个多小时...

------------

这题充分考察了对 dijkstra 算法的理解。

首先我们发现，这个弹跳装置，就是把起点对这个子矩形内的所有点连一条边。

然后跑最短路，就 ok 了。

由于毒瘤出题人卡空间，我们不可以用花式建图方式来切此题。所以我们考虑**不建出边**。

~~然后我sb的去想一个log的建图方法了。~~

如果不建出边，怎么跑最短路？

发现 spfa ~~已死，不是一个好算法~~显然不能搞，我们去想 dijkstra 。

每一次找到最短路最小的点增广原图的过程，等价于把所有和这个点相邻的点的最短路和 它到原点的最短路长度+边权 取$\min$。

什么？发现了什么？敏锐的你想到这一步一定发现，对于一个点，它同过弹跳装置向外连的边的边权都是相同的，而且它本身到原点的最短路长度也是固定的...

所以只需要对整个矩形里所有的点的最短路值 和这个数 取$\min$ 不就好了？

然后 dijkstra 打 vis 标记，每一个节点只能被取出一次...

删除这个节点不就好了？

我想到这里以后，马上就有了思路——原问题等价于一个~~czx最喜欢的~~数据结构题：

给定一个矩形，上面有$n(n \leq 70000)$个点，一开始点权均为$\infty$。支持以下三个操作：

- 矩形里所有的点的点权和$x$取$\min$。

- 求所有的点的点权最小值（以及编号）。

- 删除一个点。

怎么做呢？

------------

发现可以树套树，当然我一开始没往这想，我想了 KD 树。

我们维护一些节点信息：

flag 表示这个点有没有被删除。

flz 表示这个点子树有多少个节点被删除。

tag 表示懒标记（取$\min$）

w 表示最小值。

mw 表示子树最小值。

sz 表示有多少个子节点（包括自己）

pushup,pushdown 都不算麻烦，关键是删除操作怎么搞？

我们让这个被删除的节点打上一个标记$(\text{flag})$，以后 pushup 的时候，如果这个点被打了标记，其权值就是$\infty$。

如果一个点被删除了，其子树仍有节点，那么其$\text{mw}$表示的是其子树内部的点权最小值。若其子树全部被删除，其$\text{mw}$就是$\infty$。

我们只需要通过判断$\text{flz}$是否$=\text{sz}$即可。

还有一个细节，就是打标记的时候，如果这个点被删除了，就不更新其$w$。如果这个点被删除了而其子树仍有点没被删除，不更新$w$而更新$\text{mw}$。如果其子树被删光了，什么都不更新。否则都更新。

我这里没考虑清楚，所以一直$8$分...

### 实现细节

注意我们还需要得知这个点的位置。所以需要用 pair 来存$\text{w},\text{mw}$。


pushup:

```cpp
inline void pushup(int rt){
    g[rt].flz=g[g[rt].l].flz+g[g[rt].r].flz+g[rt].flag;
    if (g[rt].flag) g[rt].w.first=inf,g[rt].w.second=inf;
    g[rt].mw=g[rt].w;
    chkmin(g[rt].mw,min(g[g[rt].l].mw,g[g[rt].r].mw));
}
```

pushdown:

```cpp
inline void pushdown(int rt){
    if (g[rt].tag==inf) return;
    int ls=g[rt].l,rs=g[rt].r;
    if (ls){
        chkmin(g[ls].tag,g[rt].tag);
        if (!g[ls].flag) chkmin(g[ls].w.first,g[rt].tag);
        if (g[ls].sz!=g[ls].flz) chkmin(g[ls].mw.first,g[rt].tag);
    }
    if (rs){
        chkmin(g[rs].tag,g[rt].tag);
        if (!g[rs].flag) chkmin(g[rs].w.first,g[rt].tag);
        if (g[rs].sz!=g[rs].flz) chkmin(g[rs].mw.first,g[rt].tag);
    }
    g[rt].tag=inf;
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int n,m,T,W,dis[200001],H,D,cnt,L,root,xma,yma,xmi,ymi;//x->0,y->1
#define P pair<int,int>
inline P min(const P &x,const P &y){return (x>y?y:x);}
inline void chkmin(P &x,const P &y){if (x>y) x=y;}
inline void chkmin(int &x,const int &y){if (x>y) x=y;}
inline void chkmax(int &x,const int &y){if (x<y) x=y;}
struct point{
    int x,y,id;
}a[100001];
inline bool cmp(const point &a, const point &b){
    if (D){
        if (a.x!=b.x) return a.x<b.x;
        return (a.y<b.y); 
    }else{
        if (a.y!=b.y) return a.y<b.y;
        return (a.x<b.x); 
    }
}
struct KD{
    int xmin,xmax,ymin,ymax;
    int l,r,x,y,sz,flz;
    P w,mw;
    int flag,tag;
}g[100001];
#define mid ((lb+rb)>>1) 
#define inf (0x3f3f3f3f)
void build(int &rt,int lb,int rb,int det){
    if (lb>rb) return (void)(rt=0);
    rt=++cnt;g[rt].tag=inf;D=det;nth_element(a+lb,a+mid,a+rb+1,cmp);
    g[rt].x=a[mid].x;g[rt].y=a[mid].y;g[rt].w=make_pair(inf,a[mid].id);
    if (a[mid].id==1) g[rt].w.first=0;
    build(g[rt].l,lb,mid-1,det^1);build(g[rt].r,mid+1,rb,det^1);
    int ls=g[rt].l,rs=g[rt].r;g[rt].xmax=g[rt].xmin=g[rt].x;
    g[rt].ymax=g[rt].ymin=g[rt].y,g[rt].mw=g[rt].w;
    if (ls) chkmin(g[rt].xmin,g[ls].xmin),chkmin(g[rt].ymin,g[ls].ymin);
    if (ls) chkmax(g[rt].xmax,g[ls].xmax),chkmax(g[rt].ymax,g[ls].ymax);
    if (rs) chkmin(g[rt].xmin,g[rs].xmin),chkmin(g[rt].ymin,g[rs].ymin);
    if (rs) chkmax(g[rt].xmax,g[rs].xmax),chkmax(g[rt].ymax,g[rs].ymax);
    chkmin(g[rt].mw,min(g[ls].mw,g[rs].mw));
    g[rt].sz=1+g[ls].sz+g[rs].sz;
}
inline bool all_in_it(const KD &rt){
    return (rt.xmax<=xma)&&(rt.xmin>=xmi)&&(rt.ymax<=yma)&&(rt.ymin>=ymi);
}
inline bool in_it(const int &x,const int &y){
    return (x>=xmi&&x<=xma&&y>=ymi&&y<=yma);
}
inline bool pd(const KD &rt){
    return !((rt.xmin>xma)||(rt.xmax<xmi)||(rt.ymin>yma)||(rt.ymax<ymi));
}
inline void pushdown(int rt){
    if (g[rt].tag==inf) return;
    int ls=g[rt].l,rs=g[rt].r;
    if (ls){
        chkmin(g[ls].tag,g[rt].tag);
        if (!g[ls].flag) chkmin(g[ls].w.first,g[rt].tag);
        if (g[ls].sz!=g[ls].flz) chkmin(g[ls].mw.first,g[rt].tag);
    }
    if (rs){
        chkmin(g[rs].tag,g[rt].tag);
        if (!g[rs].flag) chkmin(g[rs].w.first,g[rt].tag);
        if (g[rs].sz!=g[rs].flz) chkmin(g[rs].mw.first,g[rt].tag);
    }
    g[rt].tag=inf;
}
inline void pushup(int rt){
	g[rt].flz=g[g[rt].l].flz+g[g[rt].r].flz+g[rt].flag;
    if (g[rt].flag) g[rt].w.first=inf,g[rt].w.second=inf;
    g[rt].mw=g[rt].w;
    chkmin(g[rt].mw,min(g[g[rt].l].mw,g[g[rt].r].mw));
}
void Update(int rt,int W){
    if (!rt||!pd(g[rt])||g[rt].tag<=W) return;
    if (all_in_it(g[rt])){
        chkmin(g[rt].tag,W);
        if (!g[rt].flag) chkmin(g[rt].w.first,W);
        if (g[rt].sz!=g[rt].flz) chkmin(g[rt].mw.first,W);
        return;
    }
    if (in_it(g[rt].x,g[rt].y)) if (!g[rt].flag) chkmin(g[rt].w.first,W);
    pushdown(rt);Update(g[rt].l,W);Update(g[rt].r,W);pushup(rt);
 }
void Del(int rt,int x,int y,int det){
    if (!rt) return;
    pushdown(rt);D=det;
    if (g[rt].x==x&&g[rt].y==y) return (void)(g[rt].flag=1,pushup(rt)); 
    if (det){
        if (cmp((point){x,y},(point){g[rt].x,g[rt].y})) Del(g[rt].l,x,y,det^1);
        else Del(g[rt].r,x,y,det^1);
    }else{
        if (cmp((point){x,y},(point){g[rt].x,g[rt].y})) Del(g[rt].l,x,y,det^1);
        else Del(g[rt].r,x,y,det^1);
    }
    pushup(rt);
}
inline void update(int xmia,int ymia,int xmaa,int ymaa,int W){
    xma=xmaa;yma=ymaa;xmi=xmia;ymi=ymia;Update(1,W);
}
inline void del(int x,int y){
    Del(1,x,y,0);
}
struct Jumper{
    int t,lx,rx,ly,ry;
};
inline Jumper init(int t,int lx,int rx,int ly,int ry){
    return (Jumper){t,lx,rx,ly,ry};
}
vector<Jumper> e[100001];
inline bool cmpid(point a,point b){
    return a.id<b.id;
}
signed main(){
    n=read(),m=read();W=read();H=read();
    for (int i=1;i<=n;i++){
        a[i].x=read(),a[i].y=read();a[i].id=i;
    }
    g[0].mw=g[0].w=make_pair(inf,inf);
    build(root,1,n,0);
    sort(a+1,a+1+n,cmpid);
    for (int i=1;i<=m;i++){
        int p=read(),t=read(),lx=read(),rx=read(),ly=read(),ry=read();
        e[p].push_back(init(t,lx,rx,ly,ry));
    }
    for (int i=1;i<=n;i++){
        P now=g[1].mw;
        dis[now.second]=now.first;
        del(a[now.second].x,a[now.second].y);
        for (int j=0;j<(int)e[now.second].size();j++){
            Jumper v=e[now.second][j];
            update(v.lx,v.ly,v.rx,v.ry,now.first+v.t);
        }
    }
    for (int i=2;i<=n;i++){
        printf("%d\n",dis[i]);
    }
}
```



---

## 作者：米奇 (赞：7)

## 做法：思维+动态开点线段树+分块

首先我们考虑最短路做法，发现边数是$n^2$级别的。一维的情况我们能用线段树优化建边，但二维呢？反正我不会。

我们想到Dijkstra的思想，每次找到dis最小的点，并用这个点去更新其他点。

我们把矩形看成点，相当于每次找出dis最小的矩形，然后更新矩形中的点。

但一次性更新矩形中的全部点肯定不现实，我们就可以每次更新矩形中的一个点即可。

现在的问题就是如何找矩形中的一个点。发现有点难办啊。

一开始我想到是用树套树找点，结果被卡空间（QAQ），两只log的空间刚好被卡，舒适。

然后我们就考虑如何优化空间。大家都知道时间换空间吧，我就是这么想的。

我们可以分块套动态开点线段树。我们对每x轴上的每一个点建一颗动态开点线段树，空间为$nlogn$。再维护$\sqrt{n}$个动态开点线段树记录每一块的情况，空间为$\sqrt{n} \times \sqrt{n} \times logn=nlogn$。

总算是把空间卡进去了。

每次查询我们先找到目标的块，然后在块上的动态开点线段树上二分找到一个点即可。

由于只要找一个点，找到了就可以return。所以时间复杂度不到极限的$n \times \sqrt{n} \times logn$，卡卡常就能过。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define next Next
#define mid (l+r)/2
const int N=70285;
int n,m,size,num,cnt,top,gs,ID,w,h,x[N],y[N],LL[N],RR[N],bel[N],Ans[N],tree[N],L[(N<<6)+1000000],R[(N<<6)+1000000],sum[(N<<6)+1000000];
multiset<int>xu[2*N];
int mp[(N<<6)+1000000];
char buf[1<<21],*p1=buf,*p2=buf;
inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
inline int read()
{
	int ret=0,f=0;char c=gc();
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){ret=ret*10+c-48;c=gc();}
	if(f)return -ret;return ret;
}
struct node{
	int val,l,r,d,u;
};
vector<node>g[N];
bool operator < (node a,node b)
{
	return a.val>b.val;
}
priority_queue<node>q;
void update(int &rt,int l,int r,int x,int id,int val)
{
	if(!rt)rt=++cnt;
	sum[rt]+=val;
	if(l==r)
	{
		int xjh=0;
		if(mp[rt])xjh=mp[rt];
		else{
			xjh=++top;
			mp[rt]=top;
		}
		if(val==1)xu[xjh].insert(id);
		else xu[xjh].erase(id);
		return;
	}
	if(x<=mid)update(L[rt],l,mid,x,id,val);
	else update(R[rt],mid+1,r,x,id,val);
}
void change(int x,int y,int id,int val)
{
	update(tree[x],1,h,y,id,val);
	update(tree[n+bel[x]],1,h,y,id,val);
}
void Zhao(int rt,int l,int r)
{
	if(l==r)
	{
		int xjh=mp[rt];
		ID=*xu[xjh].begin();
		return;
	}
	if(sum[L[rt]])Zhao(L[rt],l,mid);
	else Zhao(R[rt],mid+1,r);
}
void query(int &rt,int l,int r,int x,int y)
{
	if(!rt)return;
	if(sum[rt]==0)return;
	if(ID!=-1)return;
	if(l==x&&r==y)
	{
		Zhao(rt,l,r);
		return;
	}
	if(y<=mid)query(L[rt],l,mid,x,y);
	else if(x>mid)query(R[rt],mid+1,r,x,y);
	else{
		query(L[rt],l,mid,x,mid);
		query(R[rt],mid+1,r,mid+1,y);
	}
}
void find(int l,int r,int d,int u)
{
	if(bel[l]==bel[r]||bel[l]+1==bel[r])
    {
        for(int i=l;i<=r;i++)
        {
			query(tree[i],1,h,d,u);
			if(ID!=-1)return;
        }
        return;
    }
    for(int i=bel[l]+1;i<=bel[r]-1;i++)
    {
    	query(tree[n+i],1,h,d,u);
    	if(ID!=-1)return;
    }
    if(LL[bel[l]]==l)
    {
     	query(tree[n+bel[l]],1,h,d,u);
    	if(ID!=-1)return;   	
    }
    else{
	    for(int i=l;i<=RR[bel[l]];i++)
	    {
			query(tree[i],1,h,d,u);
			if(ID!=-1)return;
	    }
	}
    if(RR[bel[r]]==r)
    {
     	query(tree[n+bel[r]],1,h,d,u);
    	if(ID!=-1)return;   	
    }
    else{
	    for(int i=LL[bel[r]];i<=r;i++)
	    {
			query(tree[i],1,h,d,u);
			if(ID!=-1)return;
	    }
	}
}
void write(int x)
{
	if(x<10)
	{
		putchar('0'+x);
		return;
	}
	write(x/10);
	putchar('0'+x%10);
}
signed main()
{
	freopen("jump.in","r",stdin);
	freopen("jump.out","w",stdout);
	n=read();m=read();w=read();h=read();w=h=0;
	for(int i=1;i<=n;i++)x[i]=read(),y[i]=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),l=read(),r=read(),d=read(),u=read();
		w=max(w,r);
		h=max(h,u);
		g[x].push_back((node){y,l,r,d,u});
	}
	size=sqrt(w);
	num=w/size;
    if(w%size)num++;
    for(int i=1;i<=num;i++)LL[i]=w+1;
    for(int i=1;i<=w;i++)
    {
        bel[i]=(i-1)/size+1;
        LL[bel[i]]=min(LL[bel[i]],i);
        RR[bel[i]]=max(RR[bel[i]],i);
    }
	for(int i=2;i<=n;i++)change(x[i],y[i],i,1);
	gs=1;
	for(int i=0;i<g[1].size();i++)
	{
		node u=g[1][i];
		q.push((node){u.val,u.l,u.r,u.d,u.u});
	}
	while(gs<n)
	{
		if(q.empty())break;
		node u=q.top();
		ID=-1;
		find(u.l,u.r,u.d,u.u);
		if(ID==-1)
		{
			q.pop();
			continue;
		}
		Ans[ID]=u.val;
		change(x[ID],y[ID],ID,-1);
		for(int i=0;i<g[ID].size();i++)
		{
			node x=g[ID][i];
			q.push((node){u.val+x.val,x.l,x.r,x.d,x.u});
		}
		gs++;
	}
	for(int i=2;i<=n;i++)write(Ans[i]),putchar('\n');
	return 0;
}
```

---

## 作者：pipiispig (赞：5)

本题优化建图的数据结构为 —— 四分树(二维线段树？)

显然， 这个题是个用数据结构优化建图然后跑最短路的套路题， 其中大致可以分以下分数段

1、暴力连边 -- 32分的~~高分~~

2、数据结构暴力连边 -- 用四分树的话可以得到72的高分

3、有技巧的用数据结构连边 -- AC啦 ！好开心(*^▽^*)！

下面我讲分别讲一下第2种连边和第3种连边， 第一种默认大家都会,~~不会的请出门右拐去做dij板子QwQ~~

先放第2种方法的代码吧， 以下代码为72分， 因为被卡空间了
```c++
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
const int N = 1500005;
const int M = 2000005; 
inline int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') {x = x * 10 + c - 48; c = getchar();}
	return x * f;
}
int ch[M][4], tot = 1;
bool vis[M];
struct node {
	int f;
	int s;
};
struct cmp {
	bool operator()(node x, node y) {
		return x.f > y.f;
	}
};
priority_queue<node, vector<node>, cmp> q;
vector<int> v[N];
int ver[M], nexts[M], head[M], edge[M], e = 0;
int p[N], t[N], l[N], r[N], d[N], u[N];
int n, m, w, h, dis[M], Dis;
inline void add(int x, int y, int z) {
	ver[++ e] = y;
	nexts[e] = head[x];
	head[x] = e;
	edge[e] = z;
}
void ins(int from, int t, int &num, int l, int r, int d, int u, int x, int y) {
	if(x < l || x > r || y < d || y > u) return;
	if(num == 0) num = ++tot;
	if(!vis[num] && from != 0) add(from + n, num + n, 0), vis[num] = true;
	if(l == r && d == u) {add(num + n, t, 0);return;}
	int midx = l + r >> 1, midy = d + u >> 1;
	ins(num, t, ch[num][0], l, midx, d, midy, x, y); 
	ins(num, t, ch[num][1], l, midx, midy + 1, u, x, y); 
	ins(num, t, ch[num][2], midx + 1, r, d, midy, x, y); 
	ins(num, t, ch[num][3], midx + 1, r, midy + 1, u, x, y); 
}
void Push(int p, int from, int l, int r, int d, int u, int ll, int rr, int dd, int uu) {

	if(p ==0 || rr < l ||  ll > r || uu < d || dd > u) return;
	if( ll <= l && rr >= r && uu >= u && dd <= d) {add(from, p + n, Dis);return;}
	int midx = l + r >> 1, midy = d + u >> 1;
	Push(ch[p][0], from, l, midx, d, midy, ll, rr, dd, uu); 
	Push(ch[p][1], from, l, midx, midy + 1, u, ll, rr, dd, uu); 
	Push(ch[p][2], from, midx + 1, r, d, midy, ll, rr, dd, uu); 
	Push(ch[p][3], from, midx + 1, r, midy + 1, u, ll, rr, dd, uu); 
}

int main() {
	n = read(), m = read(), w = read(), h = read();
	for(int i = 1; i <= n; i ++) {
		int x = read(), y = read(), k = 1;
		ins(0, i, k, 1, w, 1, h, x, y);
	} 
	for(int i = 1; i <= m; i ++) {
		p[i] = read(), t[i] = read(), l[i] = read(), r[i] = read(),
		d[i] = read(), u[i] = read();  v[p[i]].push_back(i);
		int V = p[i]; Dis = t[i];
		Push(1, V,  1, w, 1, h, l[i], r[i], d[i], u[i]);
	}
	memset(dis, 0x7f, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	dis[1] = 0;
	q.push((node){0, 1});
	while(!q.empty()) {
		int x = q.top().s; q.pop();
		if(vis[x]) continue; vis[x] = 1;
		for(int i = head[x]; i; i = nexts[i]) {
			int V = ver[i];
			if(dis[V] > dis[x] + edge[i]) {
				dis[V] = dis[x] +edge[i];
				q.push((node){dis[V], V});
			}
		}
	}
	for(int i = 2; i <= n; i ++)
		printf("%d\n", dis[i]);	
	return 0;
}
```
可以看出， 上面代码中的ins操作， 是用大区间向小区间连边的， 小区间再向城市位置连边， 边权都为0；这一个操作， 我们是不好优化的， 因为显然每一个小区间都是必要的， 所以上面的连边是没有多余的边的， 优化难度很大；

继续看第2个操作， 即为push, 是用来让城市连到他能控制的所有区间中的， 这一部分的操作看起来好像也不好优化， 于是我们喜提72分， 得到~~~MLE的好结果~~

然而实际上， 第2个操作是可以优化的， 因为显然有很多的边是不需要练的，因为跑最短路的时候根本不会用到这些边， 但是怎么判断这些边需不需要是个很难得操作，于是我们可以换一种想法， 我们得不了满分的原因是MLE,我们需要缩小空间，于是我们干脆不连第2种边， 而是直接通过第2种操作让更优的路径入队

以下为*AC*代码！
```c++
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
const int N = 1500005;
const int M = 1000005; 
inline int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') {x = x * 10 + c - 48; c = getchar();}
	return x * f;
}
int ch[M][4], tot = 1;
bool vis[M];
struct node {
	int f;
	int s;
};
struct cmp {
	bool operator()(node x, node y) {
		return x.f > y.f;
	}
};
priority_queue<node, vector<node>, cmp> q;
vector<int> v[N];
int ver[M], nexts[M], head[M], edge[M], e = 0;
int p[N], t[N], l[N], r[N], d[N], u[N];
int n, m, w, h, dis[M], Dis;
inline void add(int x, int y, int z) {
	ver[++ e] = y;
	nexts[e] = head[x];
	head[x] = e;
	edge[e] = z;
}
void ins(int from, int t, int &num, int l, int r, int d, int u, int x, int y) {
	if(x < l || x > r || y < d || y > u) return;
	if(num == 0) num = ++tot;
	if(!vis[num] && from != 0) add(from + n, num + n, 0), vis[num] = true;
	if(l == r && d == u) {add(num + n, t, 0);return;}
	int midx = l + r >> 1, midy = d + u >> 1;
	ins(num, t, ch[num][0], l, midx, d, midy, x, y); 
	ins(num, t, ch[num][1], l, midx, midy + 1, u, x, y); 
	ins(num, t, ch[num][2], midx + 1, r, d, midy, x, y); 
	ins(num, t, ch[num][3], midx + 1, r, midy + 1, u, x, y); 
}
void Push(int p, int l, int r, int d, int u, int ll, int rr, int dd, int uu) {

	if(p ==0 || rr < l ||  ll > r || uu < d || dd > u || dis[p + n] <= Dis) return;
	if( ll <= l && rr >= r && uu >= u && dd <= d) {dis[p + n] = Dis;q.push((node){Dis, p + n}); return;}
	int midx = l + r >> 1, midy = d + u >> 1;
	Push(ch[p][0], l, midx, d, midy, ll, rr, dd, uu); 
	Push(ch[p][1], l, midx, midy + 1, u, ll, rr, dd, uu); 
	Push(ch[p][2], midx + 1, r, d, midy, ll, rr, dd, uu); 
	Push(ch[p][3], midx + 1, r, midy + 1, u, ll, rr, dd, uu); 
}

int main() {
	n = read(), m = read(), w = read(), h = read();
	for(int i = 1; i <= n; i ++) {
		int x = read(), y = read(), k = 1;
		ins(0, i, k, 1, w, 1, h, x, y);
	} 
	for(int i = 1; i <= m; i ++) {
		p[i] = read(), t[i] = read(), l[i] = read(), r[i] = read(),
		d[i] = read(), u[i] = read();  v[p[i]].push_back(i);
	}
	memset(dis, 0x7f, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	dis[1] = 0;
	q.push((node){0, 1});
	while(!q.empty()) {
		int x = q.top().s; q.pop();
		if(vis[x]) continue; vis[x] = 1;
			for(int i = 0; i < v[x].size(); i ++) {
				int V = v[x][i];
				Dis = dis[x] + t[V];
				Push(1, 1, w, 1, h, l[V], r[V], d[V], u[V]);
		}
		for(int i = head[x]; i; i = nexts[i]) {
			int V = ver[i];
			if(dis[V] > dis[x] + edge[i]) {
				dis[V] = dis[x] +edge[i];
				q.push((node){dis[V], V});
			}
		}
	}
	for(int i = 2; i <= n; i ++)
		printf("%d\n", dis[i]);	
	return 0;
}
```
可以看出这次的代码和上次的代码差别只在于push函数的定义， 这个代码，直接在跑最短路的时候通过push函数进行松弛操作， 并且通过三角形不等式可以排除很大一部分区间， 通过这种神奇的操作， 你会惊奇的发现， 你的空间比第2种方法优秀，并且时间也要优秀， 因为排除了很多无用的下传操作， 然后你就可以ac此题了

本代码在不开o2情况下时间为2.82s，可以轻松通过此题

如果不了解四分树的话，可以去做一下 [POI2006] TET-Tetris 3D ，这道题有非常好的四分树讲解， 也是四分树入门题！


---

## 作者：Star_Cried (赞：4)

## P5471- K-D tree优化建图-弹跳

> 优化建图是一种思想。

### 题意

有$n$个城市分布在小鸟岛上，有$m$个弹弓分布在这些城市里。因为弹弓体积大，固定麻烦，所以每个弹弓只能把小鸟弹飞到一块固定的矩形范围内的城市，同时小鸟会在空中滞留$t_i$的时间。闪电黄的家在1号城市，追求速度的它想知道，若只使用弹弓出行，它从家到其他所有城市的最短时间花费是多少。

~~抱歉魔改了题面，但是这个题意真的太像愤怒的小鸟了好吗~~

### 思路

暴力：枚举每两个城市间是否能转移进行建图跑最短路。

太浪费了，这么大的矩形有很多点肯定连不上的呀。根据套路，我们想个数据结构优化建图。

* 二维线段树优化建图
* 树套树优化建图
* **K-D tree优化建图**

~~前两个我不会~~

首先我们把这n个城市建成2-D tree，然后跑Dijkstra:

若当前结点位置在转移的范围内，插入队列，递归查找子节点并更新覆盖范围。

若弹跳的范围与树上结点覆盖的范围有交，查找之，否则不查找。

就这么简单。怎么说K-D tree就是优雅的暴力呢。

### 实现

我们用一个结构体`node`存储树上节点信息，用一个结构体`data`表示一个转移（边）。

对于一个转移，每次从根开始查找，根据以上策略遍历整棵树。时间复杂度O(能过)。事实上，我还跑了目前luogu榜一（醒醒啊你只是因为评测机最近变快了）

把查找单独拉出来：

```cpp
inline bool cross(node a,data b){return a.l[0]<=b.r[0] and a.r[0]>=b.l[0] and a.l[1]<=b.r[1] and a.r[1]>=b.l[1];}
void solve(node& x,data& p){
    if(!x.del and x.in(p)){//若该点坐标在覆盖范围内
        if(x.id!=1){
            dis[x.id]=p.v;
            for(int i=head[x.id];i;i=nxt[i]){//遍历所有能到的位置
                data u=to[i];
                u.v+=p.v;
                q.push(u);
            }
        }
        x.del=1;//根据dijkstra的贪心策略，该点不再入队
        x.clear();//为了保留结点查询的作用。下面会更新范围
    }
    if(x.son[0]){
        node &now=e[x.son[0]];
        if(cross(now,p)) solve(now,p);//注意这里判断的是矩形是否有交而非城市坐标
        if(x.del) x.copy(now);
        else x.update(now);//更新范围
    }
    if(x.son[1]){
        node &now=e[x.son[1]];
        if(cross(now,p)) solve(now,p);
        if(x.del and !x.son[0]) x.copy(now);
        else x.update(now);//更新范围
    }
}
```

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=7e4+10,maxm=15e4,INF=0x3f3f3f3f;
	int n,m,w,h,root,dis[maxn];
	struct data{
		int v,l[2],r[2];
		inline bool operator < (const data &zp) const{return v>zp.v;}
	};
	int ecnt,head[maxm],nxt[maxm];
	data to[maxm];
	inline void add(int a,data b){
		to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;
	}
	struct node{
		int x[2],l[2],r[2],son[2],id;
		static int d;//“只是声明我要用这个变量，但是它现在还不存在”
		bool del;
		inline void clear(){
			for(int i=0;i<2;i++) x[i]=0,l[i]=INF,r[i]=-INF;
		}
		inline void init(int zp){
			for(int i=0;i<2;i++) x[i]=l[i]=r[i]=read();
			id=zp;
		}
		inline void update(const node &zp){
			for(int i=0;i<2;i++) l[i]=min(l[i],zp.l[i]),r[i]=max(r[i],zp.r[i]);
		}
		inline void copy(const node &zp){
			for(int i=0;i<2;i++) l[i]=zp.l[i],r[i]=zp.r[i];
		}
		inline bool operator < (const node &zp) const{return x[d]<zp.x[d];};
		inline bool in(const data &zp) const {return x[0]>=zp.l[0] and x[0]<=zp.r[0] and x[1]>=zp.l[1] and x[1]<=zp.r[1];}
	}e[maxn];
	int node::d;//现在这个变量存在了，并且每个node都会用它
	int build(int l,int r,int d){
		node::d=d;
		int mid=l+r>>1;
		nth_element(e+l,e+mid,e+r+1);
		if(l<mid) e[mid].update(e[e[mid].son[0]=build(l,mid-1,d^1)]);
		if(r>mid) e[mid].update(e[e[mid].son[1]=build(mid+1,r,d^1)]);
		return mid;
	}
	priority_queue<data> q;
	inline bool cross(node a,data b){return a.l[0]<=b.r[0] and a.r[0]>=b.l[0] and a.l[1]<=b.r[1] and a.r[1]>=b.l[1];}
	void solve(node& x,data& p){
		if(!x.del and x.in(p)){
			if(x.id!=1){
				dis[x.id]=p.v;
				for(int i=head[x.id];i;i=nxt[i]){
					data u=to[i];
					u.v+=p.v;
					q.push(u);
				}
			}
			x.del=1;
			x.clear();
		}
		if(x.son[0]){
			node &now=e[x.son[0]];
			if(cross(now,p)) solve(now,p);
			if(x.del) x.copy(now);
			else x.update(now);
		}
		if(x.son[1]){
			node &now=e[x.son[1]];
			if(cross(now,p)) solve(now,p);
			if(x.del and !x.son[0]) x.copy(now);
			else x.update(now);
		}
	}
	inline void work(){
		n=read(),m=read(),w=read(),h=read();
		for(int i=1;i<=n;i++) e[i].init(i);
		root=build(1,n,0);
		memset(dis,INF,sizeof dis);
		dis[1]=0;
		for(int i=1;i<=m;i++){
			data zp;
			int x=read();
			zp.v=read(),zp.l[0]=read(),zp.r[0]=read(),zp.l[1]=read(),zp.r[1]=read();
			add(x,zp);
		}
		for(int i=head[1];i;i=nxt[i]) q.push(to[i]);
		while(!q.empty()){
			data x=q.top();q.pop();
			solve(e[root],x);
		}
		for(int i=2;i<=n;i++) printf("%d\n",dis[i]);
	}
}
signed main(){
	star::work();
	return 0;
}
```

PS：据银牌学姐推荐，方差建树常数大，K维循环建树虽然有时候会被卡但实际可能比前者优秀。

~~为啥题面那么喜欢跳蚤用小鸟们不可爱吗owo~~

~~自己吃别人嚼过的馒头为啥还敢写题解？因为觉得自己的马蜂太好看了所以来分享一下~~

---

## 作者：Leianha (赞：3)

## KDtree

[博客阅读](https://www.cnblogs.com/wljss/p/12620295.html)

我们观察题目后发现这很明显是一道有关最短路的题，首先可以无脑打一个最短路模板上去。

36分
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define pr pair<int,int>
using namespace std;
int n, m, w, h, tot;
const int N = 70010, M = 150000;
int head[N], dis[N], vis[N], to[M], nt[M], val[M];
priority_queue<pr >q;
struct dian {int x, y;} d[N];
struct tiao {int p, t, l, r, d, u;} t[M];
inline int read()
{
	int res = 0; char ch = getchar(); bool XX = false;
	for (; !isdigit(ch); ch = getchar())(ch == '-') && (XX = true);
	for (; isdigit(ch); ch = getchar())res = (res << 3) + (res << 1) + (ch ^ 48);
	return XX ? -res : res;
}
void add(int f, int t, int d)
{
	to[++tot] = t; val[tot] = d; nt[tot] = head[f]; head[f] = tot;
}
void DIJ()
{
	int x;
	memset(dis, 0x3f, sizeof(dis));
	q.push(pr(0, 1)); dis[1] = 0;
	while (!q.empty())
	{
		x = q.top().second; q.pop();
		if (vis[x])continue; vis[x] = 1;
		for (int i = head[x]; i; i = nt[i])
			if (dis[to[i]] > dis[x] + val[i])
			{
				dis[to[i]] = dis[x] + val[i];
				q.push(pr(-dis[to[i]], to[i]));
			}
	}
}
int main()
{
	cin >> n >> m >> w >> h;
	for (int i = 1; i <= n; ++i)d[i].x = read(), d[i].y = read();
	for (int i = 1; i <= m; ++i)
	{
		t[i].p = read(), t[i].t = read(), t[i].l = read(), t[i].r = read(), t[i].d = read(), t[i].u = read();
		for (int j = 1; j <= n; ++j)
			if (j != t[i].p && t[i].l <= d[j].x && d[j].x <= t[i].r && t[i].d <= d[j].y && d[j].y <= t[i].u)add(t[i].p, j, t[i].t);
	}
	DIJ();
	for (int i = 2; i <= n; ++i)printf("%d\n", dis[i]);
	return 0;
}
```
思考对于 $h=1$ 的数据，我们可以用线段树优化建图水过。

那 $h！=1$ 的话，我们用二维数据结构优化建图就行，这里我用的是 $KDtree$

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define lson ch[k][0]
#define rson ch[k][1]
#define pr pair<int,int>
using namespace std;
int n, m, w, h, tot, num, root, nowk;
const int N = 140010, M = 3000010;
int head[N], dis[N], vis[N], to[M], nt[M], val[M], s[N], ch[N][2], minx[N], miny[N], maxx[N], maxy[N];
priority_queue<pr >q;
struct dian {int x, y, id;} d[N];
struct tiao {int p, t, l, r, d, u;} t[M];
inline int read()
{
	int res = 0; char ch = getchar(); bool XX = false;
	for (; !isdigit(ch); ch = getchar())(ch == '-') && (XX = true);
	for (; isdigit(ch); ch = getchar())res = (res << 3) + (res << 1) + (ch ^ 48);
	return XX ? -res : res;
}
void add(int f, int t, int d)
{
	to[++tot] = t; val[tot] = d; nt[tot] = head[f]; head[f] = tot;
}
void pushup(int k)
{
	minx[k] = maxx[k] = d[k - n].x; miny[k] = maxy[k] = d[k - n].y; add(k, k - n, 0);
	if (lson)minx[k] = min(minx[k], minx[lson]), maxx[k] = max(maxx[k], maxx[lson]), miny[k] = min(miny[k], miny[lson]), maxy[k] = max(maxy[k], maxy[lson]), add(k, lson, 0);
	if (rson)minx[k] = min(minx[k], minx[rson]), maxx[k] = max(maxx[k], maxx[rson]), miny[k] = min(miny[k], miny[rson]), maxy[k] = max(maxy[k], maxy[rson]), add(k, rson, 0);
}
int my(int a, int b) {return nowk ? d[a].x < d[b].x : d[a].y < d[b].y;}
void build(int &k, int l, int r, int d)
{
	if (l > r)return;
	int mid = (l + r) >> 1; nowk = d;
	nth_element(s + l, s + mid, s + r + 1, my); k = s[mid] + n;
	build(lson, l, mid - 1, k ^ 1); build(rson, mid + 1, r, k ^ 1);
	pushup(k);
}
void ADD(int k, int now)
{
	if (maxx[k] < t[now].l || t[now].r < minx[k] || maxy[k] < t[now].d || t[now].u < miny[k] )return;
	if (t[now].l <= minx[k] && maxx[k] <= t[now].r && t[now].d <= miny[k] && maxy[k] <= t[now].u) {add(t[now].p, k, t[now].t); return;}
	if (t[now].l <= d[k - n].x && d[k - n].x <= t[now].r && t[now].d <= d[k - n].y && d[k - n].y <= t[now].u)add(t[now].p, k - n, t[now].t);
	if (lson)ADD(lson, now); if (rson)ADD(rson, now);
}
void DIJ()
{
	int x;
	memset(dis, 0x3f, sizeof(dis));
	q.push(pr(0, 1)); dis[1] = 0;
	while (!q.empty())
	{
		x = q.top().second; q.pop();
		if (vis[x])continue; vis[x] = 1;
		for (int i = head[x]; i; i = nt[i])
			if (dis[to[i]] > dis[x] + val[i])
			{
				dis[to[i]] = dis[x] + val[i];
				q.push(pr(-dis[to[i]], to[i]));
			}
	}
}
int main()
{
	cin >> n >> m >> w >> h;
	for (int i = 1; i <= n; ++i)d[i].x = read(), d[i].y = read(), d[i].id = i, s[i] = i;
	build(root, 1, n, 0);
	for (int i = 1; i <= m; ++i)
	{
	        t[i].p = read(), t[i].t = read(), t[i].l = read(), t[i].r = read(), t[i].d = read(), t[i].u = read();
		ADD(root, i);
	}
	DIJ();
	for (int i = 2; i <= n; ++i)printf("%d\n", dis[i]);
	return 0;
}
```
被卡空间.jpg。边数太多了，我们无法把边全都建出来，又因为 $Dij$ 的特性，一个点只会遍历一次和它相连的边，所以我们只需要用到边的时候再去找就行。

根据实现60~80不等
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#define lson ch[k][0]
#define rson ch[k][1]
#define pr pair<int,int>
using namespace std;
int n, m, w, h, num, root, nowk, now;
const int N = 140010, M = 150010;
int dis[N], vis[N], s[N], ch[N][2], minx[N], miny[N], maxx[N], maxy[N];
priority_queue<pr >q;
vector<int>v[N];
struct dian {int x, y;} d[N];
struct tiao {int p, t, l, r, d, u;} t[M];
inline int read()
{
	int res = 0; char ch = getchar(); bool XX = false;
	for (; !isdigit(ch); ch = getchar())(ch == '-') && (XX = true);
	for (; isdigit(ch); ch = getchar())res = (res << 3) + (res << 1) + (ch ^ 48);
	return XX ? -res : res;
}
inline void pushup(int k)
{
	minx[k] = maxx[k] = d[k - n].x; miny[k] = maxy[k] = d[k - n].y;
	if (lson)minx[k] = min(minx[k], minx[lson]), maxx[k] = max(maxx[k], maxx[lson]), miny[k] = min(miny[k], miny[lson]), maxy[k] = max(maxy[k], maxy[lson]);
	if (rson)minx[k] = min(minx[k], minx[rson]), maxx[k] = max(maxx[k], maxx[rson]), miny[k] = min(miny[k], miny[rson]), maxy[k] = max(maxy[k], maxy[rson]);
}
inline int my(int a, int b) {return nowk ? d[a].x < d[b].x : d[a].y < d[b].y;}
void build(int &k, int l, int r, int d)
{
	if (l > r)return;
	int mid = (l + r) >> 1; nowk = d;
	nth_element(s + l, s + mid, s + r + 1, my); k = s[mid] + n;
	build(lson, l, mid - 1, k ^ 1); build(rson, mid + 1, r, k ^ 1);
	pushup(k);
}
inline void geng(int y, int val)
{
	if (dis[y] > val)dis[y] = val, q.push(pr(-dis[y], y));
}
void ADD(int k)
{
	if (vis[k])return;
	if (maxx[k] < t[now].l || t[now].r < minx[k] || maxy[k] < t[now].d || t[now].u < miny[k] )return;
	if (t[now].l <= minx[k] && maxx[k] <= t[now].r && t[now].d <= miny[k] && maxy[k] <= t[now].u) {geng(k, dis[t[now].p] + t[now].t); return;}
	if (t[now].l <= d[k - n].x && d[k - n].x <= t[now].r && t[now].d <= d[k - n].y && d[k - n].y <= t[now].u)geng(k - n, dis[t[now].p] + t[now].t);
	if (lson)ADD(lson); if (rson)ADD(rson);
}
inline void DIJ()
{
	int x;
	memset(dis, 0x3f, sizeof(dis));
	q.push(pr(0, 1)); dis[1] = 0;
	while (!q.empty())
	{
		x = q.top().second; q.pop();
		if (vis[x])continue; vis[x] = 1;
		if (x <= n)
		{
			for (int i = 0, siz = v[x].size(); i < siz; ++i)now = v[x][i], ADD(root);
		}
		else
		{
			if (ch[x][0])geng(ch[x][0], dis[x]);
			if (ch[x][1])geng(ch[x][1], dis[x]);
			geng(x - n, dis[x]);
		}
	}
}
signed main()
{
	cin >> n >> m >> w >> h;
	for (int i = 1; i <= n; ++i)d[i].x = read(), d[i].y = read(), s[i] = i;
	build(root, 1, n, 0);
	for (int i = 1; i <= m; ++i)
		t[i].p = read(), t[i].t = read(), t[i].l = read(), t[i].r = read(), t[i].d = read(), t[i].u = read(), v[t[i].p].push_back(i);
	DIJ();
	for (int i = 2; i <= n; ++i)printf("%d\n", dis[i]);
	return 0;
}
```
我们发现 $Dij$ 每次是 $1$ .取出dis最小的点 $2$ .更新和它相连的点 $3$.删去该点。

这些 $KDtree$ 本身都可以完成，直接在 $KDtree$ 上维护就行了。

$shu$ 里的变量 

$p,val,id,vis$ ：该点对应的点的坐标， $dis$ ，编号，是否取出过

$l,r,mn,mx,tag$ :区间的坐标最大/小值， $dis$ 的最大/小值，对区间打的标记。

100分
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<vector>
#define lson tr[k].ls
#define rson tr[k].rs
using namespace std;
int n, m, w, h, p, t, l, r, d, u, root, nowk, cnt;
const int N = 70010, inf = 0x3f3f3f3f;
int s[N], dis[N];
struct dian {int x, y;} di[N];
struct bian {dian l, r; int dis;};
struct shu {dian p, l, r; int ls, rs, mn, mx, val, id, tag, vis;} tr[N];
vector<bian>v[N];
inline int read()
{
	int res = 0; char ch = getchar(); bool XX = false;
	for (; !isdigit(ch); ch = getchar())(ch == '-') && (XX = true);
	for (; isdigit(ch); ch = getchar())res = (res << 3) + (res << 1) + (ch ^ 48);
	return XX ? -res : res;
}
void pushup(int k)
{
	if (tr[k].vis)tr[k].l = (dian) {inf, inf}, tr[k].r = (dian) { -inf, -inf};
	else tr[k].l = tr[k].r = tr[k].p;
	if (lson)tr[k].l.x = min(tr[k].l.x, tr[lson].l.x), tr[k].l.y = min(tr[k].l.y, tr[lson].l.y), tr[k].r.x = max(tr[k].r.x, tr[lson].r.x), tr[k].r.y = max(tr[k].r.y, tr[lson].r.y);
	if (rson)tr[k].l.x = min(tr[k].l.x, tr[rson].l.x), tr[k].l.y = min(tr[k].l.y, tr[rson].l.y), tr[k].r.x = max(tr[k].r.x, tr[rson].r.x), tr[k].r.y = max(tr[k].r.y, tr[rson].r.y);
}
void upd(int k)
{
	if (tr[k].vis)tr[k].mn = inf, tr[k].mx = -inf;
	else tr[k].mn = tr[k].mx = tr[k].val;
	if (lson)tr[k].mn = min(tr[k].mn, tr[lson].mn), tr[k].mx = max(tr[k].mx, tr[lson].mx);
	if (rson)tr[k].mn = min(tr[k].mn, tr[rson].mn), tr[k].mx = max(tr[k].mx, tr[rson].mx);
}
int my(int a, int b)
{
	return nowk ? di[a].x < di[b].x : di[a].y < di[b].y;
}
void build(int &k, int l, int r, int now)
{
	if (l > r)return; k = ++cnt; nowk = now;
	int mid = (l + r) >> 1;
	nth_element(s + l, s + mid, s + r + 1, my);
	tr[k].id = s[mid]; tr[k].p = di[s[mid]]; tr[k].val = tr[k].tag = inf;
	if (tr[k].id == 1)tr[k].val = 0;
	build(lson, l, mid - 1, now ^ 1); build(rson, mid + 1, r, now ^ 1);
	pushup(k); upd(k);
}
void work(int k, int v)
{
	if (v < tr[k].mx && v < tr[k].tag)
	{
		tr[k].mx = tr[k].tag = v; tr[k].mn = min(tr[k].mn, v);
		if (!tr[k].vis)tr[k].val = min(tr[k].val, v);
	}
}
void pushdown(int k)
{
	if (tr[k].tag == inf)return;
	if (lson)work(lson, tr[k].tag); if (rson)work(rson, tr[k].tag);
	tr[k].tag = inf;
}
int find(int k, int v)
{
	int res;
	pushdown(k);
	if (!tr[k].vis && v == tr[k].val) {tr[k].vis = 1; pushup(k); upd(k); return k;}
	if (lson && tr[lson].mn == v)res = find(lson, v);
	else res = find(rson, v);
	pushup(k); upd(k);
	return res;
}
void change(int k, int v, dian l, dian r)
{
	pushdown(k);
	if (v >= tr[k].mx)return;
	if (r.x < tr[k].l.x || tr[k].r.x < l.x || r.y < tr[k].l.y || tr[k].r.y < l.y)return;
	if (l.x <= tr[k].l.x && tr[k].r.x <= r.x && l.y <= tr[k].l.y && tr[k].r.y <= r.y) {work(k, v); return;}
	if (!tr[k].vis && l.x <= tr[k].p.x && tr[k].p.x <= r.x && l.y <= tr[k].p.y && tr[k].p.y <= r.y)tr[k].val = min(tr[k].val, v);
	if (lson)change(lson, v, l, r); if (rson)change(rson, v, l, r);
	pushup(k); upd(k);
}
signed main()
{
	cin >> n >> m >> w >> h;
	for (int i = 1; i <= n; ++i)di[i].x = read(), di[i].y = read(), s[i] = i;
	for (int i = 1; i <= m; ++i)
	{
		p = read(), t = read(), l = read(), r = read(), d = read(), u = read();
		v[p].push_back((bian) {(dian) {l, d}, (dian) {r, u}, t});
	}
	build(root, 1, n, 0);
	for (int i = 1, pos, x; i <= n; ++i)
	{
		x = tr[pos = find(root, tr[root].mn)].id; dis[x] = tr[pos].val;
		for (int j = 0, siz = v[x].size(); j < siz; ++j)change(root, dis[x] + v[x][j].dis, v[x][j].l, v[x][j].r);
	}
	for (int i = 2; i <= n; ++i)printf("%d\n", dis[i]);
	return 0;
}
```

---

## 作者：ljc1301 (赞：3)

今年$NOI$两天的$t1$都是最短路……

单源最短路应该就是$dijkstra$吧……

但是又个问题，这个题如果把所有单向边都搞出来是不现实的（可能会达到$nm$）怎么办呢？

注意到，从一个点出发，虽然可以到一个矩形，但需要的时间都是一样的。考虑$dijkstra$的过程，每次从一个点扩展，就可以把一个矩形放到优先队列里，每次把到达时间最短的矩形拿出来，把这个矩形中没有访问标记的点全都更新，然后在把这些点能到的矩形放到优先队列里。重复上述过程即可。

理论上来说应该也可以把点放到优先队列里，每次取出到达时间最小的，这样要注意每次要先更新花费更少时间能到达的矩形，然后标记那些点，再更新花费更更大时间能到达的矩形。（好像比较复杂，我就不写了……

总结一下，我们发现要实现这样的东西：每次询问一个矩形中没访问过的点；访问一个点（就是相当于把这个点删掉）。（注意第一个操作一定不能把所有的点都取出来，这样时间复杂度是不对的。）这样，每个点只会访问一次。

关于这个东西的实现，用二维数据结构即可，我用的线段树套$treap$，不知道$K-D\ Tree$可不可以（因为我没学过）。注意不要用二维线段树这种空间复杂度是$O(n\log^2n)$的，这样空间根本开不下。

然后，就把这道题解决了呢。时间复杂度$O(m\log m+n\log^2n)$，空间复杂度$O(n\log n)$。

代码（常数可能过大？~~能过就行~~）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=70005;
const int maxm=150005;
const int maxlogn=19;
const int maxnode=maxn*maxlogn;
int n,m,w,h,he[maxn],t[maxm],L[maxm],R[maxm],D[maxm],U[maxm],ne[maxm],x[maxn],y[maxn],f[maxn];
int rt_[maxn<<2],tot,out[maxn],cnt;
struct cmp { bool operator ()(int a,int b) { return t[a]>t[b]; } };
priority_queue<int,vector<int>,cmp> que; // 按照到达的时间弹出
struct node { int lc,rc,id,y; unsigned int pri; }p[maxnode];
unsigned int aaa=19260817;
inline unsigned int myrand()
{
    aaa^=aaa>>15;
    aaa+=aaa<<12;
    aaa^=aaa>>3;
    return aaa;
}
inline int newnode(int y,int id) { return p[tot].lc=p[tot].rc=-1,p[tot].y=y,p[tot].id=id,p[tot].pri=myrand(),tot++; }
void merge(int &rt,int l,int r)
{
    if(l==-1 || r==-1) { rt=l^r^-1; return; }
    if(p[l].pri<p[r].pri) rt=l,merge(p[rt].rc,p[l].rc,r);
    else rt=r,merge(p[rt].lc,l,p[r].lc);
}
void split(int rt,int &l,int &r,int y,int id)
{
    if(rt==-1) { l=r=-1; return; }
    if(p[rt].y<y || (p[rt].y==y && p[rt].id<=id)) l=rt,split(p[rt].rc,p[l].rc,r,y,id); // 注意有可能在线段树的一个节点中会有y坐标相同的情况，可以通过比较id解决
    else r=rt,split(p[rt].lc,l,p[r].lc,y,id);
}
void print(int rt)
{
    if(rt==-1) return;
    print(p[rt].lc),out[cnt++]=p[rt].id,print(p[rt].rc);
}
void build(int rt,int l,int r) // 初始化（似乎直接memset-1也行……
{
    rt_[rt]=-1;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(rt<<1,l,mid),build((rt<<1)|1,mid+1,r);
}
void ins(int rt,int l,int r,int x,int y,int id) // 线段树中插入节点，维护每个关于x的区间内的所有点
{
    int a;
    split(rt_[rt],rt_[rt],a,y,id);
    merge(rt_[rt],rt_[rt],newnode(y,id));
    merge(rt_[rt],rt_[rt],a);
    if(l==r) return;
    int mid=(l+r)>>1;
    if(x<=mid) ins(rt<<1,l,mid,x,y,id);
    else ins((rt<<1)|1,mid+1,r,x,y,id);
}
void del(int rt,int l,int r,int x,int y,int id) // 删除，就是使访问过的点不在被访问
{
    int a,b;
    split(rt_[rt],rt_[rt],a,y,id-1);
    split(a,a,b,y,id);
    merge(rt_[rt],rt_[rt],b);
    if(l==r) return;
    int mid=(l+r)>>1;
    if(x<=mid) del(rt<<1,l,mid,x,y,id);
    else del((rt<<1)|1,mid+1,r,x,y,id);
}
void query(int rt,int l,int r,int x,int y,int d,int u)
{
    if(x<=l && r<=y)
    {
        int a,b;
        split(rt_[rt],rt_[rt],a,d-1,n);
        split(a,a,b,u,n);
        merge(rt_[rt],rt_[rt],b);
        print(a); // 强行把所有满足的点存下来
        return;
    }
    int mid=(l+r)>>1;
    if(x<=mid) query(rt<<1,l,mid,x,y,d,u);
    if(mid<y) query((rt<<1)|1,mid+1,r,x,y,d,u);
}
inline void solve(int u) // 把u能到的所有矩形放到优先队列中
{
    int i;
    for(i=he[u];i!=-1;i=ne[i])
    {
        t[i]+=f[u]; // 这里t[i]就是到达的时间
        que.push(i);
    }
}
int main()
{
    int i,u;
    freopen("jump.in","r",stdin),freopen("jump.out","w",stdout);
    scanf("%d%d%d%d",&n,&m,&w,&h);
    for(i=1;i<=n;i++) he[i]=-1;
    for(i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
    for(i=0;i<m;i++)
        scanf("%d%d%d%d%d%d",&u,&t[i],&L[i],&R[i],&D[i],&U[i]),ne[i]=he[u],he[u]=i;
    build(1,1,w);
    for(i=2,tot=0;i<=n;i++) ins(1,1,w,x[i],y[i],i);
    for(i=2;i<=n;i++) f[i]=0x7fffffff;
    while(!que.empty()) que.pop();
    f[1]=0,solve(1);
    while(!que.empty())
    {
        u=que.top(),que.pop();
        cnt=0,query(1,1,n,L[u],R[u],D[u],U[u]);
        for(i=0;i<cnt;i++) del(1,1,w,x[out[i]],y[out[i]],out[i]),f[out[i]]=t[u],solve(out[i]); // 访问每个能到达的点
    }
    for(i=2;i<=n;i++) printf("%d\n",f[i]);
    fclose(stdin),fclose(stdout);
    return 0;
}
```

---

## 作者：lzqy_ (赞：2)

应该是首篇分块题解。

-------

首先这道题最显然的做法是二维线段树优化建图，但是会被卡空间。

同时这道题较宽松的数据范围提示着要用时间换空间。

所以考虑线性空间的分块。

------------

## 做法

首先不能将图直接建下来，因为这会意味着时间和空间等阶，这是不优的。考虑直接在数据结构上维护 Dijstra 的过程。发现需要维护的操作有：

- 全局求 $\min$（取出堆顶元素）

- 删除单点（弹栈）

- 矩阵取 $\min$（更新最短路）

将 $x$ 轴分块，对于每一块内再按照 $y$ 轴排序，用 $\sqrt n$ 棵线段树维护每一个块。

对于操作一，取每个块的线段树的根取 $\min$ 即可，时间复杂度 $O(B)$。

对于操作二，$O(\log n)$ 直接改就行。注意不需要真正删点，标记一下即可。

对于操作三，整块内是区间修改，散块内是若干次单点修改，时间复杂度 $O(B\log n+\frac{n}{B}\log n)$。

当 $B$ 取 $\sqrt n$ 时时间复杂度最优，即 $O(m\sqrt n \log n)$。

## 优化一

这样显然是过不去的，考虑时间复杂度上的优化。

- 考虑对点分块而不是对 $x$ 轴分块，这样每棵线段树里只有 $\sqrt n$ 个点，时间复杂度降至 $O(m\sqrt n\log \sqrt n)$。

- 线段树里的点降至 $O(\sqrt n)$ 后，对于散块的修改，就可以直接遍历整个线段树，时间复杂度降至 $O(m(B+\frac n B\log B))$，在 $B=\frac n B \log B$ 时取到最小值，但我不会解这个方程，反正比 $O(m\sqrt n\log \sqrt n)$ 优就对了。

## 优化二

接着考虑常数上的优化。

- 散块修改遍历整颗线段树时，若递归区间和修改区间无交集时，直接 return。

- 在所有的修改内，若区间内所有点都有删除标记，直接 return。

## 代码

不会分析块长，在 $B$ 取 $500$ 时跑到 $7.58s$。

但拥有非常优的空间复杂度。

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
const int maxqn=1010;
const int maxn=70010;
const int inf=2e9;
const int N=maxn<<2;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x; 
}
struct Node{
	int id,x,y;
}a[maxn];
struct Imf{
	int w,xl,xr,yl,yr;
}; 
il bool cmp1(Node x,Node y){return x.x<y.x;}
il bool cmp2(Node x,Node y){return x.y<y.y;}
il void chkmin(int &x,int y){if(y<x)x=y;}
int loc[maxn],rt[maxqn];
int d1[N],d2[N],lz[N];
vector<Imf>v[maxn];
int Lid[maxn],Rid[maxn];
int L[maxqn],R[maxqn]; 
int bl[maxn],n,m,w,h,cnt;
int d[maxn],qn;
void pushdown(int i,int t){
	if(d1[(i<<1)+t]<=inf) chkmin(d1[(i<<1)+t],lz[i+t]),chkmin(lz[(i<<1)+t],lz[i+t]);
	if(d1[(i<<1|1)+t]<=inf) chkmin(d1[(i<<1|1)+t],lz[i+t]),chkmin(lz[(i<<1|1)+t],lz[i+t]);
}
void M_all(int i,int l,int r,int xl,int xr,int yl,int yr,int k,int t){
	if(d1[i+t]>inf) return ;
	if(a[l].y>yr||a[r].y<yl) return ;
	if(l==r){
		if(a[l].x>=xl&&a[l].x<=xr)
			if(a[l].y>=yl&&a[l].y<=yr)
				if(d1[i+t]<=inf) chkmin(d1[i+t],k);
		return ; 
	}pushdown(i,t);
	int mid=l+r>>1;
	M_all(i<<1,l,mid,xl,xr,yl,yr,k,t);
	M_all(i<<1|1,mid+1,r,xl,xr,yl,yr,k,t);
	if(d1[(i<<1)+t]<d1[(i<<1|1)+t]) d2[i+t]=d2[(i<<1)+t];
	else d2[i+t]=d2[(i<<1|1)+t];
	d1[i+t]=min(d1[(i<<1)+t],d1[(i<<1|1)+t]);
}
void M(int i,int l,int r,int L,int R,int k,int t){
	if(a[l].y>R||a[r].y<L) return ;
	if(d1[i+t]>inf) return ;
	if(a[l].y>=L&&a[r].y<=R){
		if(d1[i+t]<=inf) chkmin(lz[i+t],k),chkmin(d1[i+t],k);
		return ; 
	}int mid=l+r>>1;
	pushdown(i,t);
	if(a[mid].y>=L) M(i<<1,l,mid,L,R,k,t);
	if(a[mid+1].y<=R) M(i<<1|1,mid+1,r,L,R,k,t);
	if(d1[(i<<1)+t]<d1[(i<<1|1)+t]) d2[i+t]=d2[(i<<1)+t];
	else d2[i+t]=d2[(i<<1|1)+t];
	d1[i+t]=min(d1[(i<<1)+t],d1[(i<<1|1)+t]);
}
void D(int i,int l,int r,int x,int t){
	if(l==x&&r==x){
		d[a[l].id]=d1[i+t];
		d1[i+t]=inf+1;
		return ;
	}int mid=l+r>>1;
	pushdown(i,t);
	if(mid>=x) D(i<<1,l,mid,x,t);
	else D(i<<1|1,mid+1,r,x,t);
	if(d1[(i<<1)+t]<d1[(i<<1|1)+t]) d2[i+t]=d2[(i<<1)+t];
	else d2[i+t]=d2[(i<<1|1)+t];
	d1[i+t]=min(d1[(i<<1)+t],d1[(i<<1|1)+t]);
}
il void Add(int xl,int xr,int l1,int r1,int l2,int r2,int v){
//	printf("Add : %d,%d,%d,%d\n",l1,r1,l2,r2);
	int Bl=bl[l1],Br=bl[r1];
	M_all(1,L[Bl],R[Bl],xl,xr,l2,r2,v,rt[Bl]);
	if(Bl!=Br) M_all(1,L[Br],R[Br],xl,xr,l2,r2,v,rt[Br]);
	for(int i=Bl+1,l,r;i<Br;i++)
		M(1,L[i],R[i],l2,r2,v,rt[i]);
}  
il void Del(int x){D(1,L[bl[loc[x]]],R[bl[loc[x]]],loc[x],rt[bl[loc[x]]]);}
il int Q(){
	int Mn=inf,id=0;
	for(int i=1;i<=bl[n];i++)
		if(d1[rt[i]+1]<Mn) Mn=d1[rt[i]+1],id=d2[rt[i]+1];
	return a[id].id;
}
void Dijstra(){
	for(int i=1;i<=n;i++)
		if(a[i].id==1) Add(a[i].x,a[i].x,i,i,a[i].y,a[i].y,0);
	int cn=0,t;
	for(int cas=1;cas<=n;cas++){
		t=Q();Del(t);
//		printf("[%d]:%d\n",t,d[t]);
		for(int i=0;i<v[t].size();i++)
			Add(v[t][i].xl,v[t][i].xr,Lid[v[t][i].xl],Rid[v[t][i].xr],v[t][i].yl,v[t][i].yr,d[t]+v[t][i].w);
	}
}
void build(int i,int l,int r,int t){
	cnt=max(cnt,i+t),lz[i+t]=d1[i+t]=inf,d2[i+t]=l;
	if(l==r) return ;
	int mid=l+r>>1;
	build(i<<1,l,mid,t);
	build(i<<1|1,mid+1,r,t);
}
void init(){
	for(int i=1;i<=bl[n];i++)
		rt[i]=cnt,build(1,L[i],R[i],rt[i]);
} 
int main(){
//	freopen("a (2).in","r",stdin);
	n=read(),m=read();
	w=read(),h=read();
	qn=500;
	for(int i=1;i<=n;i++){
		a[i].x=read(),a[i].y=read();
		a[i].id=i,bl[i]=(i-1)/qn+1;
	}
	sort(a+1,a+1+n,cmp1);
	for(int i=1,j=1;i<=n;i++){
		while(j<=n&&a[j].x<i) j++;
		Lid[i]=j;
	}
	for(int i=n,j=n;i;i--){
		while(j&&a[j].x>i) j--;
		Rid[i]=j;
	}
	for(int i=1;i<=bl[n];i++){
		L[i]=(i-1)*qn+1,R[i]=min(i*qn,n);
		sort(a+L[i],a+R[i]+1,cmp2);
	}
	for(int i=1;i<=n;i++) loc[a[i].id]=i;
	Imf t;int x;
	for(int i=1;i<=m;i++){
		x=read(),t.w=read();
		t.xl=read(),t.xr=read();
		t.yl=read(),t.yr=read();
		v[x].push_back(t);	
	}init(),Dijstra();
	for(int i=2;i<=n;i++)
		printf("%d\n",d[i]);
	return 0;
}
```

---


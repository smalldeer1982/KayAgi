# [NOI2000] 古城之谜

## 题目描述

著名的考古学家石教授在云梦高原上发现了一处古代城市遗址。让教授欣喜的是在这个他称为冰峰城 (Ice-Peak City) 的城市中有 $12$ 块巨大石碑，上面刻着用某种文字书写的资料，他称这种文字为冰峰文。然而当教授试图再次找到冰峰城时，却屡屡无功而返。

幸好当时教授把石碑上的文字都拍摄了下来，为了解开冰峰城的秘密，教授和他的助手牛博士开始研究冰峰文，发现冰峰文只有陈述句这一种句型和名词 (n) 、动词 (v) 、辅词 (a) 这三类单词，且其文法很简单：

![](https://cdn.luogu.com.cn/upload/image_hosting/fj2tbbqd.png)

在研究了大量资料后，他们总结了一部冰峰文词典，由于冰峰文恰好有 $26$ 个字母，为了研究方便，用字母 $a$ 到 $z$ 表示它们。

冰峰文在句子和句子之间以及单词和单词之间没有任何分隔符，因此划分单词和句子令石教授和牛博士感到非常麻烦，于是他们想到了使用计算机来帮助解决这个问题。假设你接受了这份工作，你的第一个任务是写一个程序，将一篇冰峰文文章划分为最少的句子，在这个前提下，将文章划分为最少的单词。


## 说明/提示

**样例说明**

（为了阅读方便，划分的单词用空格分隔，在单词的右上角标出它的词性，每行写一个句子，用句号表示句子结束。）

输出对应的划分：

$ sillysnoopy^n \quad isnot^v \quad big^a \quad table^n. \\
baleine^n \quad kick^v \quad snoopy^n \quad silly^a \quad cry^v. $

如果用下面的划分：

$ silly^a \quad snoopy^n \quad isnot^v \quad big^a \quad table^n. \\
baleine^n \quad kick^v \quad snoopy^n \quad silly^a \quad cry^v.$

则划分的句子数仍为 $2$ 个，但单词数却多了 $1$ 个，为 $10$ 个，显然应该按前者而不是后者划分。


## 样例 #1

### 输入

```
11
n.table
n.baleine
a.silly
n.snoopy
n.sillysnoopy
v.is
v.isnot
n.kick
v.kick
a.big
v.cry
sillysnoopyisnotbigtablebaleinekicksnoopysillycry.
```

### 输出

```
2
9
```

# 题解

## 作者：Illusory_dimes (赞：9)

### 题目描述
给定 n 和 n 个信息，每个信息包含一个词性 a （只有三种：名，动，辅）和对应的词 mot ，形为“ $a.mot$ ”。（一次可能多词性）

最后给一个长度不大于 $5KB$ 的冰峰文文章，将这篇冰峰文文章划分为最少的句子，在这个前提下，将文章划分为最少的单词时，求划分的句子数量和单词数量。

划分标准：
![](https://cdn.luogu.com.cn/upload/image_hosting/fj2tbbqd.png)
（别问我为什么盗图。。

$1\leq n\leq 10^3\ \ \ \ mot.len\leq 20$

### $solution$
首先要搞懂题目中的图是什么玩意（我真的看了好久都没看懂。。）

所有语法简述下来就是：

------------

1.名词短语是许多个辅词加一个名词组成的。

2.动词短语是许多个辅词加一个动词组成的。

3.一个句子以名词短语开头，名词短语和动词短语交替出现而组成的。

4.文章为多句话组成。

------------

所以对于任意词，有四种类型：

------------

1.名词。

2.动词。

3.辅名词的辅词。

4.辅动词的辅词。

------------

状态应该很自然了。。（要什么设什么呗）

$f[j][i][0]$ 指前 $i$ 个字母，最后一个单词是名词，构成了 $j$ 个句子的最小单词数。

$f[j][i][1]$ 指前 $i$ 个字母，最后一个单词是动词，构成了 $j$ 个句子的最小单词数。

$f[j][i][2]$ 指前 $i$ 个字母，最后一个单词是辅词，后面要接动词，构成了 $j$ 个句子的最小单词数。

$f[j][i][3]$ 指前 $i$ 个字母，最后一个单词是辅词，后面要接名词，构成了 $j$ 个句子的最小单词数。

状态转移方程就按照语法看能否转移就行

$f[j][i][0] \Longrightarrow \min{(f[j][k][1/3],f[j-1][k][0/2])}$

$f[j][i][1] \Longrightarrow \min{(f[j][k][0/2])}$

$f[j][i][2] \Longrightarrow \min{(f[j][k][0/2])}$

$f[j][i][3] \Longrightarrow \min{(f[j][k][1/3],f[j-1][k][0/1])}$

实际上看式子的话， $j$ 那一维可以滚动起来。（虽然不滚掉好像问题不大，但省空间多好。。）

最后答案就是按题目来，求一个最小的 $ans$ ，存在 $f[ans][len][0/1]$ ，如果都存在，取较小值。

$DP$ 这里就结束了，考虑如何实现。

明显 $DP$ 的复杂度不允许我们每次枚举所有单词再去比较。

所以想到了用一个比较实用的东西 $trie$ 可以把速度拉起来。

基本上这题就搞定了，就是注意一定把数组开稍微大点（我因为忽略数组大小而傻乎乎地去调了半个小时程序了）
### $code$
```cpp
#include<bits/stdc++.h>
#define reg register
using namespace std;
typedef long long ll;
const int N=1e3+10,M=6e3+10,K=3e4+10;
const int INF=0x3f3f3f3f;
int n,m,mlth,f[2][M][4],tri[M][24],tot,op,ans1,ans2;
char sw[M],sd[M];
struct trie{
	int tr[26],opt,it;
	inline void clear(){
		memset(tr,0,sizeof(tr));
		it=-1;opt=0;
	}
}trie[K];
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void insert(char s[],int lth,int opt){
	int id=0,val;
	for(int i=2;i<lth;++i){
		val=s[i]-'a';
		if(!trie[id].tr[val]){
			trie[++tot].clear();
			trie[tot].it=val;
			trie[id].tr[val]=tot;
		}
		id=trie[id].tr[val];
	}
	trie[id].opt|=opt;
}
inline int find(int lt,int rt){
	int id=0,val;
	for(int i=lt;i<=rt;++i){
		val=sd[i]-'a';
		if(!trie[id].tr[val])return 0;
		id=trie[id].tr[val];
	}
	return trie[id].opt;
}
inline void mian(){
	ans1=0;ans2=INF;
	trie[0].clear();
	memset(tri,-1,sizeof(tri));
	memset(f,INF,sizeof(f));
	for(int i=1;i<=n;++i){
		scanf("%s",sw);m=strlen(sw);
		mlth=max(m,mlth);
		if(sw[0]=='n')insert(sw,m,1);
		else if(sw[0]=='v')insert(sw,m,2);
		else if(sw[0]=='a')insert(sw,m,4);
	}
	scanf("%s",sd+1);m=strlen(sd+1)-1;
	f[0][0][0]=0;
	for(int lin=1;lin<=m;++lin){
		int now=op^1,pre=op;
		for(int i=1;i<=m;++i){
			memset(f[now][i],INF,sizeof(f[now][i]));
			int lim=max(i-mlth,0);
			for(int j=i-1;j>=lim;--j){
				if(tri[j+1][i-j]==-1)
					tri[j+1][i-j]=find(j+1,i);
				int opti=tri[j+1][i-j],nowi,prei;
				if(opti&1){
					nowi=min(f[now][j][1],f[now][j][3]);
					prei=min(f[pre][j][0],f[pre][j][2]);
					f[now][i][0]=min(f[now][i][0],nowi+1);
					f[now][i][0]=min(f[now][i][0],prei+1);
				}//不能有else
				if(opti&2){
					nowi=min(f[now][j][0],f[now][j][2]);
					f[now][i][1]=min(f[now][i][1],nowi+1);
				}//不能有else
				if(opti&4){
					nowi=min(f[now][j][0],f[now][j][2]);
					f[now][i][2]=min(f[now][i][2],nowi+1);

					nowi=min(f[now][j][1],f[now][j][3]);
					prei=min(f[pre][j][0],f[pre][j][1]);
					f[now][i][3]=min(f[now][i][3],nowi+1);
					f[now][i][3]=min(f[now][i][3],prei+1);
				}//不能有else
			}
		}
		ans2=min(f[now][m][0],f[now][m][1]);
		if(ans2!=INF){ans1=lin;break;}
		op^=1;
	}
	printf("%d\n%d\n",ans1,ans2);
}
int main(){
	n=read();
	mian();
	return 0;
}
```
（话说为什么没题解呀。。

---

## 作者：Daniel1234 (赞：1)

# 思路

$dp_{i,0/1}$ 表示以 $i$ 结尾，动词或名词短语的长度和所需单词。

先预处理出所有 $l\sim r$ 组成动词短语和名词短语的最小单词数。

转移：枚举最后一个短语的长度，再枚举上一个短语的性质。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bitset<65536>mp1[3], mp2[3], mp3[3];
string s;
short dong[5005][5005], ming[5005][5005];
pair<int, int> dp[5005][2];
void fu(pair<int, int> &x, pair<int, int> y){
	if(x.first > y.first){
		x = y;
	}else if(x.first == y.first && x.second > y.second){
		x = y;
	}
	return;
}
signed main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> s;
		char op = s[0];
		s = s.substr(2);
		int s1 = 0, s2 = 0, s3 = 0;
		for(int j = 0; j < s.size(); j++){
			s1 = s1 * 23 + s[j] - '0';
			s2 = s2 * 37 + s[j] - '0';
			s3 = s3 * 11 + s[j] - '0';
			s1 &= 65535;
			s2 &= 65535;
			s3 &= 65535;
		}
		if(op == 'a'){
			mp1[0][s1] = 1;
			mp2[0][s2] = 1;
			mp3[0][s3] = 1;
		}else if(op == 'n'){
			mp1[1][s1] = 1;
			mp2[1][s2] = 1;
			mp3[1][s3] = 1;
		}else{
			mp1[2][s1] = 1;
			mp2[2][s2] = 1;
			mp3[2][s3] = 1;
		}
	}
	cin >> s;
	int len = s.size() - 1;
	for(int i = 0; i < 5000; i++){
		for(int j = 0; j < 5000; j++){
			dong[i][j] = 1e4;
			ming[i][j] = 1e4;
		}
	}
	for(int le = 1; le <= len; le++){
		for(int l = 0; l + le - 1 < len; l++){
			int r = l + le - 1;
			int s1 = 0, s2 = 0, s3 = 0;
			for(int k = l; k <= min(r, l + 19); k++){
				s1 = s1 * 23 + s[k] - '0';
				s2 = s2 * 37 + s[k] - '0';
				s3 = s3 * 11 + s[k] - '0';
				s1 &= 65535;
				s2 &= 65535;
				s3 &= 65535;
				if(mp1[0][s1] && mp2[0][s2] && mp3[0][s3]){
					if(dong[k+1][r]<1e4)dong[l][r] = min(dong[l][r], (short)(dong[k+1][r] + 1));
					if(ming[k+1][r]<1e4)ming[l][r] = min(ming[l][r], (short)(ming[k+1][r] + 1));
				}
			}
			if(r - l + 1 <= 20){
				s1 = 0, s2 = 0, s3 = 0;
				for(int k = l; k <= r; k++){
					s1 = s1 * 23 + s[k] - '0';
					s2 = s2 * 37 + s[k] - '0';
					s3 = s3 * 11 + s[k] - '0';
					s1 &= 65535;
					s2 &= 65535;
					s3 &= 65535;
				}
				if(mp1[1][s1] && mp2[1][s2] && mp3[1][s3])ming[l][r] = 1;
				if(mp1[2][s1] && mp2[2][s2] && mp3[2][s3])dong[l][r] = 1;
			}
		}
	}
	for(int i = 0; i < len; i++){
		dp[i][0] = dp[i][1] = make_pair(1e4, 0);
		for(int j = 1; j <= i; j++){
			if(ming[i - j + 1][i] < 1e4)fu(dp[i][0], make_pair(dp[i - j][0].first + 1, dp[i - j][0].second + ming[i - j + 1][i]));
			if(ming[i - j + 1][i] < 1e4)fu(dp[i][0], make_pair(dp[i - j][1].first, dp[i - j][1].second + ming[i - j + 1][i]));
			if(dong[i - j + 1][i] < 1e4)fu(dp[i][1], make_pair(dp[i - j][0].first, dp[i - j][0].second + dong[i - j + 1][i]));
		}
		if(ming[0][i] < 1e4)fu(dp[i][0], make_pair(1, ming[0][i]));
		// cout << i << " " << dp[i][0].first << " " << dp[i][0].second << endl;
		// cout << i << " " << dp[i][1].first << " " << dp[i][1].second << endl;
	}
	fu(dp[len - 1][0], dp[len - 1][1]);
	cout << dp[len - 1][0].first << endl << dp[len - 1][0].second << endl;
	return 0;
}
```

一些小技巧：

1.哈希用 `map` 或者 `unordered_map` 会超时，所以可以尝试开数组，并将哈希模数调小，但这样又会导致重复率变高，所以可以开多个哈希数组，最后取最小值即可。

2.预处理数组开 `short`。

---

## 作者：Dehydration (赞：1)

### 前言

我是照着[这个](https://byvoid.com/zhs/blog/noi-2000-solution/#%3ch2%3e%3cspan%20class%3d%22mw-headline%22%3e%e5%8f%a4%e5%9f%8e%e4%b9%8b%e8%b0%9c%20%3c%2fspan%3e%3c%2fh2%3e)打的，发现不错（暂时最优解）便来发一波题解，让谷民享受到更低的复杂度。

### 思路

主要算法：DP 和 TRIE 。

主要思路：

先将那些单词用 TRIE 存起来，再用 DP 。

TRIE 代码：

```
//简单的Trie代码，近乎模板，可以在网上搜Trie来更深入了解
struct TTrie
{
	struct Trie_node
	{
		Trie_node *c[26];
		int Wm;
		Trie_node():Wm(0){memset(c,0,sizeof(c));}
	};
	Trie_node *root;
	void ins(Trie_node *&p,int *S,int L,int Wm)
	{
		if (!p) p=new Trie_node();
		if (L==0) p->Wm|=Wm;
		else ins(p->c[*S],S+1,L-1,Wm);
	}
	int find(Trie_node *p,int *S,int L)
	{
		if (!p) return 0;
		if (L==0) return p->Wm;
		else return find(p->c[*S],S+1,L-1);
	}
}Trie;
```

下面再仔细讲一下 DP :

#### 1.状态设定,边界和初始化

定义三位数组 $F[i][j][k]$ 。

$F[i][j][k]$表示，前 $i$ 个字母，末尾单词词性为 $j$，组成第 $k$ 个句子的最少单词数,文章长度为 $M$。

$F[0][0][0]=0$ 。

初始化：

```
//码风较丑
int i,j,k,p;
for (p=0;p<=1;p++)
	for (i=0;i<4;i++)
		for (j=0;j<=m;j++)
			F[j][i][p]=ImP;
//其中，ImP为：

#define Imp 0x7FFFFFF
```

#### 2.状态转移
满足文章中第 $[a+1,i]$ 可以匹配一个单词，则可以状态转移。$i-L\le a\le i-1 $ 且 $ 0 \le a$ , $L$ 为所有单词最大长度。

代码中 $p$ 值只能为 $0$ 或 $1$。

如果匹配的单词为名词
```
F[i][0][p]=min(F[i][0][p],F[j][1][p]+1);
F[i][0][p]=min(F[i][0][p],F[j][3][p]+1);
F[i][0][p]=min(F[i][0][p],F[j][0][!p]+1);
F[i][0][p]=min(F[i][0][p],F[j][1][!p]+1);
```

如果匹配的单词为动词
```
F[i][1][p]=min(F[i][1][p],F[j][0][p]+1);
F[i][1][p]=min(F[i][1][p],F[j][2][p]+1);//注意加1
```

如果匹配的单词为辅词
```
F[i][2][p]=min(F[i][2][p],F[j][0][p]+1);
F[i][2][p]=min(F[i][2][p],F[j][2][p]+1);
//分开
F[i][3][p]=min(F[i][3][p],F[j][1][p]+1);
F[i][3][p]=min(F[i][3][p],F[j][3][p]+1);
F[i][3][p]=min(F[i][3][p],F[j][0][!p]+1);
F[i][3][p]=min(F[i][3][p],F[j][1][!p]+1);
```
DP 完美撒花！

这样只需吸氧就能 [$\color{GREEN}AC$](https://www.luogu.com.cn/paste/zfqcr8nx) 了！

---

## 作者：mystic_qwq (赞：0)

题目大意：
```
xx 文语法规则

词性：n. 名词，v. 动词，a. 形容词
名词短语：n. + a. + a. + ...
动词短语：v. + a. + a. + ...
句子：名词短语 + 动词短语 + 名词短语 + 动词短语 + ...
```
先给定一个字典，包含词性和单词。数量 $N\le 1000$，长度 $\le 20$。

之后给定一段没有空格，句号的话（$|S|\le 5120$），要求加上空格，句号，使得构成的句子数量最少，在此基础上，使得总空格数量最少。只需要输出句子数量，和空格隔出来的单词数。
***

考虑用 DP 解决此问题。  
一个位置的 DP 值有两个参数，其一是文章数量，其二是单词数量，用个 pair 来刻画。  
设 $dp[i][.]$ 表示由 $S[1\cdots i]$ 一段，构成的答案。  
$dp[.][0]$ 表示，新一句话形式如 $\cdots N. V.$。  
$dp[.][1]$ 表示，新一句话形式如 $\cdots V. N.$。  
$dp[.][2]$ 表示，可以在 $.$ 后，新开一句话。

然后转移就可以了。最终答案就是 $dp[L][2]$。

转移的部分，可以简单推出。然后用 trie 加速判断词性，就行了。

code: 
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 6000
#define F(i,x,y) for(int i=x;i<=y;++i)
#define ck(x,y) x=min(x,y)
#define ck1(x,y,z) x=min(x,z),y=min(y,z)
using pi=pair<int,int>;
int n,j,L;
char s[N],T[N];
pi f[N][3];
struct Trie {
  int cnt=1,rt=1;
  struct node {
    int son[26];
    bool tag[3];
  } p[N<<5];
#define Gi i=&p[u].son[*s-'a']
  void ins(char *s,int v) {
    int u=rt,*i;
    for(;*s;++s,u=*i) 
      !*(Gi)&&(*i=++cnt);  
    p[u].tag[v]=1;
  }
  bool *qry(char *s,int len) {
    int u=rt,*i;
    for(;len;++s,u=*i,--len)
      if(!*(Gi)) return p[0].tag;
    return p[u].tag;
  }
} trie;
pi A(pi x,bool as=0) {
  return {x.first+as,x.second+1};
}
main() {
  cin>>n;
  F(i,1,n) {
    cin>>s;
    for(j=0;*s^"nva"[j];) ++j;
    trie.ins(s+2,j);
  }
  cin>>T+1,L=strlen(T+1)-1;
  memset(f,0x3f,sizeof f),f[0][2]={0,0};
  F(i,1,L) F(j,max(i-20,0),i-1) {
    bool *B=trie.qry(T+j+1,i-j);
    pi newl=min(A(f[j][0]),A(f[j][2],1));
    if(B[0]) ck1(f[i][1],f[i][2],newl);
    if(B[1]) ck1(f[i][0],f[i][2],A(f[j][1]));
    if(B[2]) ck(f[i][0],newl),ck(f[i][1],A(f[j][1]));
  }
  auto[x,y]=f[L][2];
  cout<<x<<endl<<y;
}
```

---

## 作者：CrTsIr400 (赞：0)

# NOI2000 古城之谜

## 首先，要看懂题

给你一个词典（有 $n\le 1000$ 个单词），并且给你每个单词的词性。**一个同样的单词可能有不同的词性**，处理时候我们视为不同的单词。

给你一篇文章，长度 $\le 5000$，要求把这篇文章划分为**最少的句子**，在最少的句子之上，再划分为**最少的单词**。

讲一下这道题中的**语法**。

**单词**要求出现在字典里过，有 **名词，动词，辅词** 三种不同的类型。

（**辅词**相当于英语语境之中的 副词 或者 形容词）。

**动词短语** 为 **若干个辅词** + **动词**。

**名词短语** 为 **若干个辅词** + **名词**。

**句子** 为 名词短语 + 动词短语 + 名词短语 + 动词短语 …… 的结构，要求至少有一个名词短语，**两种词性的短语必须交替出现**。

---

## 考虑用 DP 处理

设 $f[i][j][p]$ 为：有 $i$ 个句子，到了第 $j$ 位，词性为 $p$，有最少多少个单词。

为了方便分清楚动词短语、名词短语，我们把**辅词**分为**副词**和**形容词**。

那么讨论一下，能转移到什么状态：

+ **名词**：($p=0$)
  + 接下一个**副词**；
  + 接下一个**动词**；
  + 结束句子，接下一个**形容词**；
  + 结束句子，接下一个**名词**；
+ **动词**：($p=1$)
  + 接下一个**形容词**；
  + 接下一个**名词**；
+ **形容词**：($p=2$)
  + 接下一个**形容词**；
  + 接下一个**名词**；
+ **副词**：($p=3$)
  + 接下一个**副词**；
  + 接下一个**动词**。

我们可以先滚动一波空间，然后暴力枚举 $k$（因为单词长度不超过 $20$，所以 $j<k\le j+20$），所以 暴力+Trie 即可通过此题。（虽然是 $20\times ans\times 5000\times 16$ 的运算量，但是开了开 O2，稍加剪枝之后完全可以过）。

```cpp
#include<bits/stdc++.h>
#define fo(i,a,b) for(I i(a),_ed(b);i<=_ed;++i)
using namespace std;using I=int;using LL=long long;using V=void;
const I NL=25005;
struct trie{
	I tr[NL][26],cnt=1;bool end[NL];
	V ins(string s){I p=1;
		for(I i:s)if(I&q=tr[p][i-'a'])p=q;
		else p=q=++cnt;
		end[p]=1;
	}
}v,n,a;
I m,lens;string s;
const I N=5005;
I f[2][N][4];
const I turn[4][4]={
{2,1,2,1},
{1,0,1,0},
{1,0,1,0},
{0,1,0,1}};
const I inf=0x3f3f3f3f;
V ckm(I&x,I y){
	if(x>y)x=y;}
I main(){ios::sync_with_stdio(0);cin.tie(0);
	cin>>m;
	fo(i,1,m){char cx,c;string nam;
		cin>>cx>>c>>nam;
		if(cx=='a')a.ins(nam);
		if(cx=='v')v.ins(nam);
		if(cx=='n')n.ins(nam);
	}cin>>s;
	lens=s.size()-1;s='#'+s;
	memset(f,0x3f,sizeof(f));
	f[0][0][2]=0;
	fo(t,0,lens){
		I cur=t&1,pv,pn,pa;bool chkv,chkn,chka;
		fo(i,0,lens-1){
			pv=pn=pa=1;
			fo(j,i+1,min(i+20,lens)){
				I c=s[j]-'a';
				pv=v.tr[pv][c];chkv=v.end[pv];
				pn=n.tr[pn][c];chkn=n.end[pn];
				pa=a.tr[pa][c];chka=a.end[pa];
				if(!pv&&!pn&&!pa)break;
				fo(lasid,0,3)if(f[cur][i][lasid]!=inf)
				fo(curid,0,3){
					I num=turn[lasid][curid];
					if(!num||(curid==0&&!chkn)||
					(curid==1&&!chkv)||
					(curid>=2&&!chka))continue;
					I nexp=cur^(num>1||t==0);
					ckm(f[nexp][j][curid],f[cur][i][lasid]+1);
				}
			}
		}
		I ans=min(f[cur][lens][0],f[cur][lens][1]);
		if(ans<inf){
			printf("%d\n",t);
			printf("%d\n",ans);
			break;
		}
		memset(f[cur],0x3f,sizeof(f[cur]));
	}
	return 0;}
```





---


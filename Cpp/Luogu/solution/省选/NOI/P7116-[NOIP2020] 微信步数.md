# [NOIP2020] 微信步数

## 题目描述

小 C 喜欢跑步，并且非常喜欢在微信步数排行榜上刷榜，为此他制定了一个刷微信步数的计划。

他来到了一处空旷的场地，处于该场地中的人可以用 $k$ 维整数坐标 $(a_1, a_2, \ldots , a_k)$ 来表示其位置。场地有大小限制，第 $i$ 维的大小为 $w_i$，因此处于场地中的人其坐标应满足 $1 \le a_i \le w_i$（$1 \le i \le k$）。

小 C 打算在接下来的 $P = w_1 \times w_2 \times \cdots \times w_k$ 天中，每天从场地中一个新的位置出发，开始他的刷步数计划（换句话说，他将会从场地中每个位置都出发一次进行计划）。

他的计划非常简单，每天按照事先规定好的路线行进，每天的路线由 $n$ 步移动构成，每一步可以用 $c_i$ 与 $d_i$ 表示：若他当前位于 $(a_1, a_2, \ldots , a_{c_i}, \ldots, a_k)$，则这一步他将会走到 $(a_1, a_2, \ldots , a_{c_i} + d_i, \ldots , a_k)$，其中 $1 \le c_i \le k$，$d_i \in \{-1, 1\}$。小 C 将会不断重复这个路线，直到他走出了场地的范围才结束一天的计划。（即走完第 $n$ 步后，若小 C 还在场内，他将回到第 $1$ 步从头再走一遍）。

小 C 对自己的速度非常有自信，所以他并不在意具体耗费的时间，他只想知道 $P$ 天之后，他一共刷出了多少步微信步数。请你帮他算一算。

## 说明/提示

**【样例 #1 解释】**

从 $(1, 1)$ 出发将走 $2$ 步，从 $(1, 2)$ 出发将走 $4$ 步，从 $(1, 3)$ 出发将走 $4$ 步。  
从 $(2, 1)$ 出发将走 $2$ 步，从 $(2, 2)$ 出发将走 $3$ 步，从 $(2, 3)$ 出发将走 $3$ 步。  
从 $(3, 1)$ 出发将走 $1$ 步，从 $(3, 2)$ 出发将走 $1$ 步，从 $(3, 3)$ 出发将走 $1$ 步。  
共计 $21$ 步。

**【数据范围】**

| 测试点编号 | $n \le$ | $k \le$ | $w_i \le$ |
|:-:|:-:|:-:|:-:|
| $1 \sim 3$ | $5$ | $5$ | $3$ |
| $4 \sim 6$ | $100$ | $3$ | $10$ |
| $7 \sim 8$ | ${10}^5$ | $1$ | ${10}^5$ |
| $9 \sim 12$ | ${10}^5$ | $2$ | ${10}^6$ |
| $13 \sim 16$ | $5 \times {10}^5$ | $10$ | ${10}^6$ |
| $17 \sim 20$ | $5 \times {10}^5$ | $3$ | ${10}^9$ |

对于所有测试点，保证 $1 \le n \le 5 \times {10}^5$，$1 \le k \le 10$，$1 \le w_i \le {10}^9$，$d_i \in \{-1, 1\}$。

## 样例 #1

### 输入

```
3 2
3 3
1 1
2 -1
1 1
```

### 输出

```
21
```

## 样例 #2

### 输入

```
5 4
6 8 6 5
3 1
2 1
1 1
2 1
2 -1
```

### 输出

```
10265
```

## 样例 #3

### 输入

```
见附件中的 walk/walk3.in```

### 输出

```
见附件中的 walk/walk3.ans```

## 样例 #4

### 输入

```
见附件中的 walk/walk4.in```

### 输出

```
见附件中的 walk/walk4.ans```

# 题解

## 作者：OMG_wc (赞：114)

 称 $n$ 步为一轮，首先 $-1$ 的情况很好判断：一轮后回到原地且在第一轮里存在某个起点走不出去。

我们把要求的答案转换一下：原本是考虑每个起点各自走多少步出界，现在转换成同时考虑所有起点，把每天还 **存活的起点** 数量计入贡献。（这里存活就是指从该起点出发到某天还没出界）

显然，只要把第 $0$ 天活着的起点算进去（也就是 $\prod w_i$），就和要算的答案等价了。

一共 $m$ 个维度，每个维度存活的位置是独立的，并且应是一段区间（只有开头、结尾的一部分会死亡）。

如果第 $j$  维存活的区间是 $[l_j,r_j]$，那总共存活的数量就为 $\prod\limits_{j=1}^m(r_j-l_j+1)$ 。

根据这个想法，可以得到一个 $O(nmT)$ 的算法，其中 $T$ 最长轮数，最坏情况下为 $\max(w_j)$ 。

以下代码实测可以拿 $45$ 分：

```c++
int w[20], e[20], l[20], r[20];
int c[N], d[N];
int n, m;

int main() {
    scanf("%d%d", &n, &m);
    LL ans = 1;
    for (int i = 1; i <= m; i++) {
        scanf("%d", &w[i]);
        ans = ans * w[i] % mod;
    }
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &c[i], &d[i]);
    }
    while (1) {
        for (int i = 1; i <= n; i++) {
            e[c[i]] += d[i];
            l[c[i]] = min(l[c[i]], e[c[i]]);
            r[c[i]] = max(r[c[i]], e[c[i]]);
            LL s = 1;
            for (int j = 1; j <= m; j++) {
                if (r[j] - l[j] >= w[j]) goto M1;
               s = s * (w[j] - r[j] + l[j]) % mod;
            }
            ans = (ans + s) % mod;
        }
        bool lose = 1;
        for (int j = 1; j <= m; j++) {
            if (e[j] != 0) lose = 0;
        }
        if (lose) {
            ans = -1;
            break;
        }
    }
M1:
    printf("%lld\n", ans);
    return 0;
}
```

下面考虑第 $j$ 维：

在第一轮第 $i$ 步时，历史移动最大位移为 $[l_i,r_i]$，那么死亡的起点数量应该为 $r_i-l_i$ 个。

这是因为 $[1,-l_i]$ 和 $[n-r_i+1,n]$  范围内的起点已经死了。

假设第一轮总偏移量为 $e_j$，在第二轮第 $i$ 步时，历史移动最大位移应为 $[\min(l_i,e_j+l_i),\max(r_i,e_j+r_i)]$。

只要 $e_j\neq 0$，无论 $e_j$ 的正负，会有起点在第二轮是新死的。

把第一轮结束时的最大位移 $[l_n,r_n]$ 作为边界，求第二轮第 $i$ 步时的左右扩张范围 $[l'_i,r'_i]$，只需如下计算：

```c++
r[i][j] = max(0, r[i][j] + e[j] - r[n][j]);
l[i][j] = min(0, l[i][j] + e[j] - l[n][j]);
```

那么 $r'_i-l'_i$ 就是第二轮中 $1\sim i$ 步里新死的人。

 容易发现一个事实：第 $2，3，4\cdots$ 轮里每步的死亡情况是一致的，只有第一轮是特殊的。（可以画个图理解下，除了第一轮外，其他轮都存在被上一轮已经扩张过的地方，死过的起点不会再死一次）



有了这个周期规律就可以优化了：

首先第一轮单独算，只考虑第二轮开始的。

设第一轮后还活着 $a_j$ 个起点，接下来每轮结束都有 $b_j$ 个起点死亡，最后一轮的 $1\sim i$ 步一共死了 $f_i=r'_i-l'_i$ 个点。

那么可以得到在 $x+2$ 轮的第 $i$ 步时，第 $j$ 维还活着 $a_j-x\times b_j-f_i$ 个点，贡献为 $\prod\limits_{j=1}^m a_j-x\times b_j-f_i$。

设 $T=\min\limits_{j=1}^m\frac{a_j-f_i}{b_j}$，那么我们需要外层枚举 $i$ ，内层枚举 $x=0,1,2,\ldots,T$ 。

（注意这里可能出现 $a_j-f_i\le 0$ 的情况，说明第二轮这个维度的起点就死光了，那后面就不用算了）

如果老老实实这样枚举 $x$ ，和之前做法就一样了。

要算的其实是 $\sum\limits_{i=1}^n\sum\limits_{x=0}^T\prod\limits_{j=1}^m a_j-x\times b_j-f_i$

内层 $\prod$ 展开后，得到一个关于 $x$ 的 $m$ 次多项式 $G(x)$，这个多项式系数可以暴力 $O(m^2)$ 来算（我这里没有优化）

然后对多项式每项 $p_ix^k$，只要单独算 $\sum\limits_{x=0}^T x^k$  即可。

关于计算 $\sum\limits_{i=1}^n i^k$ 参考 [传送门](https://www.luogu.com.cn/problem/CF622F)。

而对本题而言， $k\le 3$ 直接用公式，而 $k > 3$ 时，$n$ 不超过 $10^6$ 直接预处理也可以。

时间复杂度 $O(nm^2)$，代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
const int N = 500005;

LL pow_mod(LL x, LL n) {
    LL res = 1;
    while (n) {
        if (n & 1) res = res * x % mod;
        n >>= 1;
        x = x * x % mod;
    }
    return res;
}

LL fac[N];
// 计算 1^m+2^m+3^m+...+n^m
LL cal(LL n, LL m) {
    LL res = 0;
    if (n <= m + 2) {
        for (int i = 1; i <= n; i++) {
            res = (res + pow_mod(i, m)) % mod;
        }
    } else {
        fac[0] = 1;
        for (int i = 1; i <= m + 1; i++) {
            fac[i] = fac[i - 1] * i % mod;
        }
        LL t = 1;
        for (int i = 1; i <= m + 2; i++) {
            t = t * (n - i) % mod;
        }
        LL y = 0;
        int flag = (m + 2) % 2 ? 1 : -1;
        for (int i = 1; i <= m + 2; i++) {
            y = (y + pow_mod(i, m)) % mod;
            res += flag * y * t % mod * pow_mod(n - i, mod - 2) % mod * pow_mod(fac[i - 1] * fac[m + 2 - i] % mod, mod - 2) % mod;
            flag = -flag;
        }
        res = (res % mod + mod) % mod;
    }
    return res;
}

int w[20], e[20], l[N][20], r[N][20];
int a[20], b[20], h[20];
LL f[20][20];
int c[N], d[N];
int n, m;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d", &w[i]);
    }
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &c[i], &d[i]);
        e[c[i]] += d[i];
        for (int j = 1; j <= m; j++) {
            l[i][j] = l[i - 1][j];
            r[i][j] = r[i - 1][j];
        }
        l[i][c[i]] = min(l[i][c[i]], e[c[i]]);
        r[i][c[i]] = max(r[i][c[i]], e[c[i]]);
    }
    bool lose = 1;
    for (int i = 1; i <= m; i++) {
        if (e[i] != 0 || r[n][i] - l[n][i] >= w[i]) {
            lose = 0;
        }
    }
    if (lose) return puts("-1"), 0;
    for (int j = 1; j <= m; j++) {
        a[j] = w[j] - (r[n][j] - l[n][j]);
    }
    LL ans = 0;
    // 第一轮贡献
    for (int i = 0; i <= n; i++) {
        LL s = 1;
        for (int j = 1; j <= m; j++) {
            s = s * max(0, (w[j] - (r[i][j] - l[i][j]))) % mod;
        }
        ans = (ans + s) % mod;
    }
    // 第二轮的死亡范围更新
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            r[i][j] = max(0, r[i][j] + e[j] - r[n][j]);
            l[i][j] = min(0, l[i][j] + e[j] - l[n][j]);
        }
    }
    for (int j = 1; j <= m; j++) {
        b[j] = r[n][j] - l[n][j];
    }
    // 第二轮开始的贡献

    int last = -1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) f[0][j] = 0;
        f[0][0] = 1;
        int t = INF;
        for (int j = 1; j <= m; j++) {
            int x = a[j] - r[i][j] + l[i][j];
            if (x <= 0) goto M1;  // 第二轮就暴毙了
            if (b[j] > 0) t = min(t, x / b[j]);
            for (int k = 0; k <= m; k++) {
                f[j][k] = f[j - 1][k] * x % mod;
                if (k > 0)
                    f[j][k] = (f[j][k] + f[j - 1][k - 1] * -b[j]) % mod;
            }
        }
        ans += f[m][0] * (t + 1) % mod;
        if (t != last) {
            last = t;
            for (int j = 1; j <= m; j++) h[j] = cal(t, j);
        }
        for (int j = 1; j <= m; j++) {
            ans += h[j] * f[m][j] % mod;
        }
    }
M1:;
    ans = (ans % mod + mod) % mod;
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：xtx1092515503 (赞：42)

考场上想到了正解但没时间写了\kk

------------

我们考虑，假如一个人在第 $i$ 步后恰好离开场地，那么合法的坐标有何限制？

第 $i$ 步时，此人向 $c_i$ 方向走了 $d_i$ 步。

则，如果其此时关于 $c_i$ 方向距原点的距离（有向），设为 $u_{c_i}$，并非从开始行动以来的最大值或最小值，明显第 $i$ 步便不可能成为恰好离开场地的一步——因为如果第 $i$ 步离开了场地，必然是从 $c_i$ 方向离开的场地，但是 $c_i$ 方向上所有到边界的距离介于最大值和最小值之间的坐标已经全部离开场地了，而离边界的距离为 $u_{c_i}$ 的坐标，因为其并非最大值或最小值，也被包括在了那些已经离开的坐标里。

那么，假如 $u_{c_i}$ 真的是某个最值，那么有哪些坐标会随着这一步离开边界呢？

首先，到边界距离为 $u_{c_i}$ 的坐标，必须仍在边界范围内。我们设 $up_{c_i}$ 表示在第 $i$ 步后 $c_i$ 这一维仍在边界范围内的最大坐标，$dw_{c_i}$ 表示最小坐标。则如果 $up_{c_i}<dw_{c_i}$，明显此时已经没有合法的坐标，也就没有坐标会随着这一步离开边界了。于是我们设 $len_i=up_{c_i}-dw_{c_i}+1$，则必须满足 $len_i\geq 0$（$len_i=0$ 时，标志着最后一批合法的坐标也随着这一步离开了边界，在统计这一步的答案后就可以 `break` 了）。

同时，合法的坐标，必须满足它在其它维度上也没有离开过场地，即它在其它某维 $j$ 上的坐标，必须 $\in[dw_j,up_j]$，共 $len_j$ 种方案。

于是，此时会随着第 $i$ 步离开边界的点，共有 $\prod\limits_{j\neq c_i} len_j$ 个。

对于某一个特定的 $i$，我们已经可以在 $O(k)$ 的时间内找出所有在这一步内离开的点的数量了。但是这个 $i$ 会很大，如何减少枚举的量呢？

我们考虑设 $\vec{v}$ 表示一轮中全部 $n$ 步结束后的位移向量。则无解，当且仅当第一轮中还有没有离开边界的点，并且 $\vec{v}=\vec{0}$。

那现在有解了，必然有 $\vec{v}\neq\vec{0}$。但是如何找出所有新的最值步呢？

我们考虑再枚举第二轮。假如某步在第二轮中成为了最值，因为其在第一轮中必定也是最值（不然第二轮中最值会提前出现），则我们发现两轮中这一步间的坐标差刚好为 $\vec{v}$。然后，我们就会发现，第一轮到第三轮间坐标差就是 $2\vec{v}$，第四轮就是 $3\vec{v}$……

我们会发现，因为第一轮到第二轮间两次都是最值，这就证明了一个 $\vec{v}$ 无法改变这一步是最值的事实，那么经过无论多少个 $\vec{v}$，它都会是最值。

我们考虑设 $v_i$ 表示 $\vec{v}$ 在维度 $i$ 上的位移。则一个第二轮的最值步在第 $k$ 轮里仍是最值，此时其它维度 $j$ 上剩余的合法坐标区间的长度全都变成了

$$len_j-(k-2)|v_j|$$

则只要对于所有的维度 $j$（包括 $c_i$ 维度本身）都有 $len_j-(k-2)|v_j|>0$，就仍有剩余的点未移出边界，也即轮数 $k$ 合法。

则上述第 $k$ 轮时（应保证第 $k$ 轮合法），第二轮中最值步 $i$（应有 $n<i\leq 2n$，因为 $i$ 在第二轮中）的贡献便是

$$\Big(i+(k-2)n\Big)\prod\limits_{j\neq c_i}len_j-(k-2)|v_j|$$

考虑枚举上述 $k$，复杂度玄学（但易于理解），就得到了我的考场代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,a[11],c[1000100],d[1000100],dw[11],up[11],len[11],res,qwq[11];
vector<int>v,u;
bool cheimp(){
	for(int i=0;i<m;i++)if(v[i])return false;
	for(int i=0;i<m;i++)if(dw[i]>up[i])return false;
	return true;
}
int main(){
	freopen("walk.in","r",stdin);
	freopen("walk.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=0;i<m;i++)scanf("%d",&a[i]),up[i]=a[i]-1,dw[i]=0,len[i]=a[i];
	v.resize(m);
	for(int i=1,x,y;i<=n;i++){
		scanf("%d%d",&x,&y),x--,v[x]+=y;
		c[i]=x,d[i]=y;
		if(v[x]>=0)up[x]=min(up[x],a[x]-v[x]-1);
		else dw[x]=max(dw[x],-v[x]);
	}
	if(cheimp()){puts("-1");return 0;}
	for(int i=0;i<m;i++)up[i]=a[i]-1,dw[i]=0,len[i]=a[i];
	u.resize(m);
	for(int i=1;i<=2*n;i++){
		if(i>n)c[i]=c[i-n],d[i]=d[i-n];
		u[c[i]]+=d[i];
		if(u[c[i]]>=0)up[c[i]]=min(up[c[i]],a[c[i]]-u[c[i]]-1);
		else dw[c[i]]=max(dw[c[i]],-u[c[i]]);
		int TTT=max(0,up[c[i]]-dw[c[i]]+1);
		if(TTT<len[c[i]]){
			bool ok=true;
			int tmp=i;
			for(int j=0;j<m;j++){
				if(j==c[i])continue;
				if(len[j]<=0){tmp=ok=0;break;}
				tmp=1ll*tmp*len[j]%mod;
			}
			(res+=tmp)%=mod;
			if(i>n){
				for(int j=0;j<m;j++)qwq[j]=len[j];
				int ini=i;
				while(ok){
					(ini+=n)%=mod;
					tmp=ini;
					for(int j=0;j<m;j++){
						qwq[j]-=abs(v[j]);
						if(qwq[j]<=0){tmp=ok=0;break;}
						if(j==c[i])continue;
						tmp=1ll*tmp*qwq[j]%mod;
					}
					(res+=tmp)%=mod;
				}				
			}
			len[c[i]]=TTT;
		}
	}
	printf("%d\n",res);
	return 0;
}
```

下面考虑优化。

我们回到上述式子

$$\Big(i+(k-2)n\Big)\prod\limits_{j\neq c_i}len_j-(k-2)|v_j|$$

考虑令 $x=k-2$，则有其等价于

$$(xn+i)\prod\limits_{j\neq c_i}-|v_j|x+len_j$$

我们发现它是一个关于 $x$ 的多项式形式。考虑令 $f(x)$ 表示上述多项式（具体可以把上面所有东西直接卷一起得到多项式）。

则，如果设最大的合法轮为 $X$，则我们要求的，就是

$$\sum\limits_{x=1}^Xf(x)$$

考虑将 $f(x)$ 换成系数表达的形式 $\sum\limits_{i=0}a_ix^i$，则有

$$\sum\limits_{x=1}^X\sum\limits_{i=0}a_ix^i$$

考虑交换枚举顺序，便得到

$$\sum\limits_{i=0}a_i\sum\limits_{x=1}^Xx^i$$

我们发现后半段的东西是一个前 $X$ 个自然数的 $i$ 次幂的形式，即[这题](https://www.luogu.com.cn/problem/CF622F)。

我们可以直接上链接中题目的解法了。例如，猜想可得如果设 $g_i(X)=\sum\limits_{x=1}^Xx^i$ 是一个 $i+1$ 次多项式，故我们挑出 $i+2$ 个点暴力拉格朗日插一个值即可。当然，还有其它做法，这里看链接中题目的题解即可，不再赘述。

则我们便可以预处理自然数幂的和的多项式形式来达到 $O(k^2)$ 进行单次计算。时间复杂度 $O(nk^2)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,a[11],c[1000100],d[1000100],dw[11],up[11],len[11],res,qwq[11],tms[20],lim,val[20][20],mal[20][20],lam[20][20],mil[20];
vector<int>v,u;
bool cheimp(){
	for(int i=0;i<m;i++)if(v[i])return false;
	for(int i=0;i<m;i++)if(dw[i]>up[i])return false;
	return true;
}
int ksm(int x,int y=mod-2){
	int z=1;
	for(;y;y>>=1,x=1ll*x*x%mod)if(y&1)z=1ll*z*x%mod;
	return z; 
}
void Involution(int *arr,int &sz,int slop,int cons){
//	printf("%d %d\n",slop,cons);
	for(int i=sz;i>=0;i--){
		(arr[i+1]+=1ll*arr[i]*slop%mod)%=mod;
		arr[i]=1ll*cons*arr[i]%mod;
	}
	if(arr[sz+1])sz++;
}
void Revolution(int *arr,int &sz,int slop,int cons){
	if(!cons){
		for(int i=0;i<sz;i++)arr[i]=arr[i+1];
		arr[sz]=0;
	}else{
		cons=ksm(cons);
		for(int i=0;i<sz;i++){
			arr[i]=1ll*arr[i]*cons%mod;
			(arr[i+1]+=mod-1ll*arr[i]*slop%mod)%=mod;
		}
	}
	sz--;
}
int Calc(int *arr,int sz,int x){
	int ret=0;
	for(int i=0,j=1;i<=sz;i++,j=1ll*j*x%mod)(ret+=1ll*j*arr[i]%mod)%=mod;
	return ret;
}
void Lagrange(){
	for(int i=0;i<=m;i++){
		for(int j=1;j<=i+1;j++)val[i][j]=(val[i][j-1]+ksm(j,i))%mod;
		mal[i][0]=1,mil[i]=0;
		for(int j=0;j<=i+1;j++)Involution(mal[i],mil[i],1,(mod-j)%mod);
		for(int j=0;j<=i+1;j++){
			Revolution(mal[i],mil[i],1,(mod-j)%mod);
			int lambda=val[i][j];
			for(int k=0;k<=mil[i];k++)if(k!=j)lambda=1ll*lambda*ksm((j-k+mod)%mod)%mod;
			for(int k=0;k<=mil[i];k++)(lam[i][k]+=1ll*mal[i][k]*lambda%mod)%=mod;
			Involution(mal[i],mil[i],1,(mod-j)%mod);
		}
	}
}
int main(){
//	freopen("walk.in","r",stdin);
//	freopen("walk.out","w",stdout);
	scanf("%d%d",&n,&m);
	Lagrange();
	for(int i=0;i<m;i++)scanf("%d",&a[i]),up[i]=a[i]-1,dw[i]=0,len[i]=a[i];
	v.resize(m);
	for(int i=1,x,y;i<=n;i++){
		scanf("%d%d",&x,&y),x--,v[x]+=y;
		c[i]=x,d[i]=y;
		if(v[x]>=0)up[x]=min(up[x],a[x]-v[x]-1);
		else dw[x]=max(dw[x],-v[x]);
	}
	if(cheimp()){puts("-1");return 0;}
	for(int i=0;i<m;i++)up[i]=a[i]-1,dw[i]=0,len[i]=a[i];
	u.resize(m);
	for(int i=1;i<=2*n;i++){
		if(i>n)c[i]=c[i-n],d[i]=d[i-n];
		u[c[i]]+=d[i];
		if(u[c[i]]>=0)up[c[i]]=min(up[c[i]],a[c[i]]-u[c[i]]-1);
		else dw[c[i]]=max(dw[c[i]],-u[c[i]]);
		int TTT=max(0,up[c[i]]-dw[c[i]]+1);
		if(TTT<len[c[i]]){
			bool ok=true;
			int tmp=i;
			for(int j=0;j<m;j++){
				if(j==c[i])continue;
				if(len[j]<=0){tmp=ok=0;break;}
				tmp=1ll*tmp*len[j]%mod;
			}
			(res+=tmp)%=mod;
			if(i>n){
				for(int j=0;j<=lim;j++)tms[j]=0;
				tms[1]=n,tms[0]=i,lim=1;
				for(int j=0;j<m;j++){
					if(j==c[i])continue;
					Involution(tms,lim,(mod-abs(v[j]))%mod,len[j]);
				}
				int x=0x3f3f3f3f;
				for(int j=0;j<m;j++){
					if(len[j]<=0){x=0;continue;}
					if(v[j])x=min(x,(len[j]-1)/abs(v[j]));
				}
				for(int j=0;j<=lim;j++)(res+=1ll*tms[j]*Calc(lam[j],mil[j]-1,x)%mod)%=mod;
			}
			len[c[i]]=TTT;
		}
	}
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：tzc_wk (赞：11)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7116)

~~我竟然独立切掉了这道题！incredible！~~

纪念我逝去的一上午（NOIP 总时长 4.5h，这题做了我整整 4.5h）

首先讲一下现场我想的 80 分的做法，虽然最后挂成了 65 分，但大概率是被卡常了（

注意到虽然点数高达 $\prod\limits_{i=1}^kw_i$，但每一维我们都可以单独考虑，具体来说，我们设 $tim_{i,j}$ 表示**只考虑 $c_k=i$ 的 $k$，当前第 $i$ 维坐标是 $j$，最少需要多少步才能离开场地**，$tim_{i,j}$ 显然 xjb 分类讨论就能求出。那么由于每一维的独立性，对于一个坐标 $(x_1,x_2,\cdots,x_k)$，它所需要的离开场地的最小时间就是对应每一维所需时间取 $\min$，即 $\min\limits_{i=1}^ktim_{i,x_i}$，也就是说我们要求的东西就是 $\sum\limits_{x_i\le w_i}\min\limits_{i=1}^ktim_{i,x_i}$，我们考虑将 $tim_{i,j}$ 全部揉在一起从大到小排序并枚举 $\min\limits_{i=1}^ktim_{i,x_i}=tim_{x,y}$，那么此时合法的坐标数目就是 $\prod\limits_{j\ne x}cnt_j$，其中 $cnt_j=\sum\limits_{k=1}^{w_j}[tim_{j,k}>tim_{x,y}]$，这个值可以通过预处理逆元在枚举的过程中 $\mathcal O(1)$ 求得。那么，加上排序的复杂度，总复杂度大概是 $nk\log nk$。~~然鹅这个复杂度不开 O2 是过不去的，有我现场写的程序为证~~。因此考虑加点小小的剪枝，注意到 $tim_{i,j}$ 随着 $j$ 的增大是一个凸函数，因此咱考虑找到该函数的峰点，然后将两部分归并起来即可在 $\mathcal O(w_i)$ 的时间内将某个 $tim_{i}$ 从大到小排序，然后再将所有 $tim_i$ 再归并起来即可。然鹅有一个让人非常哭笑不得的细节，就是在对全部 $k$ 个数组归并时，找最小值用 `priority_queue`，时间复杂度 $\mathcal O(nk\log k)$ 反而 TLE，改成暴力 $\mathcal O(k)$ 找反而就过了，大概是常数的问题吧。

附：80 分的代码：

```cpp
const int MAXN=5e5;
const int MAXK=10;
const int MOD=1e9+7;
int n,k,c[MAXN+5],d[MAXN+5],w[MAXK+2];
namespace sub1{
	bool check(){
		int flg=1;
		for(int i=1;i<=k;i++) flg&=(w[i]<=1e6);
		return flg;
	}
	const int MAXW=1e6;
	const ll INF=0x3f3f3f3f3f3f3f3fll;
	ll tim[MAXK+2][MAXW+5];
	int lft[MAXW+5],rit[MAXW+5];
	void calc(int x){
		memset(lft,0,sizeof(lft));memset(rit,0,sizeof(rit));
		int mn=0,mx=0,cur=0;
		for(int i=1;i<=n;i++) if(c[i]==x) cur+=d[i];
		if(cur<0){
			for(int i=1;i<=n;i++) if(c[i]==x) d[i]=-d[i];
		} cur=0;
		for(int i=1;i<=n;i++) if(c[i]==x){
			cur+=d[i];
			if(cur>mx) rit[cur]=i,mx=cur;
			if(cur<mn) lft[-cur]=i,mn=cur;
		}
		for(int i=1;i<=w[x];i++){
			tim[x][i]=INF;
			if(i+mn<=0) chkmin(tim[x][i],(ll)lft[i]);
			if(i+mx>w[x]) chkmin(tim[x][i],(ll)rit[w[x]+1-i]);
			if(cur){
				int bound=w[x]-mx+1;
				int tt=max((bound-i+cur-1)/cur,0);
				chkmin(tim[x][i],1ll*tt*n+rit[w[x]+1-(i+tt*cur)]);
			}
		}
	} ll A[MAXW+5],B[MAXW+5];
	int inv[MAXW+5];
	void mergesort(int x){
		int ps=0,c1=0,c2=0;
		for(int i=1;i<=w[x];i++) if(tim[x][i]>tim[x][i+1]){ps=i;break;}
		for(int i=ps;~i;i--) A[++c1]=tim[x][i];A[c1+1]=0;
		for(int i=ps+1;i<=w[x];i++) B[++c2]=tim[x][i];B[c2+1]=0;
		for(int i=1,p1=1,p2=1;i<=w[x];i++){
			if(A[p1]>B[p2]) tim[x][i]=A[p1++];
			else tim[x][i]=B[p2++];
		}
	}
	int cnt[MAXK+5];
	void solve(){
		for(int i=1;i<=k;i++) calc(i);
		for(int i=1;i<=k;i++) mergesort(i);
		for(int i=(inv[0]=inv[1]=1)+1;i<=MAXW;i++)
			inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
		int sm=0;for(int i=1;i<=k;i++) sm+=w[i];
		bool flg=1;
		for(int i=1;i<=k;i++) flg&=(tim[i][1]==INF);
		if(flg) return puts("-1"),void();
		int res=1,cnt0=k,ans=0;
		for(int i=1;i<=sm;i++){
			int x=0;
			for(int j=1;j<=k;j++) if(tim[j][cnt[j]+1]>tim[x][cnt[x]+1]) x=j;
			if(!cnt[x]) cnt0--;
			else res=1ll*res*inv[cnt[x]]%MOD*(cnt[x]+1)%MOD;
			++cnt[x];
			if(!cnt0&&tim[x][cnt[x]]) ans=(ans+tim[x][cnt[x]]%MOD*res%MOD*inv[cnt[x]])%MOD;
		} printf("%d\n",ans);
	}
}
int main(){
	freopen("walk.in","r",stdin);
	freopen("walk.out","w",stdout);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++) scanf("%d",&w[i]);
	for(int i=1;i<=n;i++) scanf("%d%d",&c[i],&d[i]);
	if(sub1::check()) sub1::solve();
	return 0;
}
```

接下来考虑正解，也就是这个~~脑子不太好使的人~~今早~~灵机一动~~想出来的做法。

我们考虑预处理出这样几个量：

- $x_i$：在一整个长度为 $n$ 周期中，如果我们将起点视为源点，那么在一个周期中第 $i$ 维坐标的**最小值**是多少。
- $y_i$：在一整个长度为 $n$ 周期中，如果我们将起点视为源点，那么在一个周期中第 $i$ 维坐标的**最大值**是多少。
- $t_i$：在一整个长度为 $n$ 周期中，如果我们将起点视为源点，那么在一个周期结束后第 $i$ 维的坐标是多少。方便起见我们假设 $t_i\ge 0$，如果 $t_i<0$ 那我们只需将 $c_j=i$ 的 $d_j$ 都变为其相反数即可。
- $mn_{i,j}$：在一整个长度为 $n$ 周期中，如果我们将起点视为源点，那么执行完前 $j$ 个命令后，在一个周期中第 $i$ 维坐标的**最小值**是多少，不难发现 $x_i=mn_{i,n}$。
- $mx_{i,j}$：在一整个长度为 $n$ 周期中，如果我们将起点视为源点，那么执行完前 $j$ 个命令后，在一个周期中第 $i$ 维坐标的**最大值**是多少，同样地有 $y_i=mx_{i,n}$。
- $sum_{i,j}$：在一整个长度为 $n$ 周期中，如果我们将起点视为源点，那么执行完前 $j$ 个命令后，第 $i$ 维的坐标是多少。

首先我们思考一下对于某一维 $i$ 上的某个坐标 $x$，最少需要多少步才能离开这一维的范围（即，这一维的坐标 $\notin[1,w_i]$）。一个比较显然但非常关键的性质是，由于 $t_i\ge 0$，因此如果第一个周期内不能从左边离开场地，那么第二周期起点位置肯定比第一周期更靠右，也就更不可能从右边离开场地，也就是说如果离开时走的步数 $>n$，那么我们必定是从右边离开场地的。因此我们考虑枚举小 C 最后一步是在这个长度为 $n$ 的周期中**哪个指令下离开场地**，记为第 $i$ 个命令。那么此时此刻已经执行的命令必定是若干个长度为 $n$ 的完整的周期加上前 $i$ 个命令构成的这段前缀，我们记当前位于第 $K$ 个周期（方便起见我们不妨设 $K\ge 2$，$K=1$ 的情况后面再说），那么根据之前的推论，这一步肯定是第 $c_i$ 维坐标达到了 $w_{c_i}+1$。又因为第一周期内无法离开场地，因此如果我们记 $s_i$ 为第 $i$ 起点的坐标，必定有 $s_j\in[-x_j+1,w_j]$，又因为在前 $(K-1)n+i-1$ 步内不能离开场地，因此对于每一维 $j$ 可以列出以下四个不等式：
$$
\begin{cases}
s_j+(K-2)t_j+mn_{j,i-1}\in[1,w_j]\\
s_j+(K-2)t_j+mx_{j,i-1}\in[1,w_j]\\
s_j+(K-1)t_j+x_j\in[1,w_j]\\
s_j+(K-1)t_j+y_j\in[1,w_j]
\end{cases}
$$
再加上第 $i$ 步第 $c_i$ 维坐标需达到 $w_{c_i}+1$，因此还有 $s_{c_i}+(K-1)t_{c_i}+sum_{c_i,i-1}=w_{c_i}+1$。

总共是 $5k+1$ 个限制，每个限制都可以表示为 $s_j\in[L,R]$ 的形式，因此我们可以解出 $s_j$ 的范围，如果存在某个 $s_j$ 的范围为空则表明不可能恰好在第 $(K-1)n+i$ 步离开场地，否则合法的坐标数就是 $s_j$ 范围的乘积。

但是直接枚举 $K$ 复杂度过高，无法接受。不过注意到一个性质就是如果存在某个坐标经过 $Kn+i$ 步离开场地，就必定存在某个坐标经过 $(K-1)n+i$ 步离开场地，因此考虑二分最大的 $K$ 满足存在某个坐标经过 $(K-1)n+i$ 步离开场地，那么我们要求的值就是 $\sum\limits_{j=2}^K\text{calc}((j-1)n+i)·((j-1)n+i)$，其中 $\text{calc}(x)$ 为满足恰好经过 $x$ 步离开场地的坐标个数。暴力算还是 T，不过我们还可以发现，每次解出来的 $s_j(j\ne c_i)$ 的范围区间的左端点都是固定不变的值 $-x_j+1$，因此区间长度可以写成关于右端点的一次函数，又区间非空，因此右端点可以写成关于 $K$ 的一次函数，因此 $\text{calc}((j-1)n+i)$ 可以看作关于 $j$ 的 $k-1$ 次函数，再加上前缀和与后面的系数，$\sum$ 里的东西为关于 $K$ 的 $k+1$ 次函数，因此可以考虑求出 $2,3,\cdots,k+3$ 处的函数值然后把多项式插出来即可。

接下来考虑 $K=1$ 的情况，相信聪明的读者们如果理解了 $K\ge 2$ 的情况，那么 $K=1$ 的情况想必是易如反掌了，我们还是可以列出一些关于 $s_j$ 的不等式，也就能解出对应 $s_j$ 的范围，然后可以乘法原理对应的坐标个数，如果还是不懂那就看代码吧。

上述算法复杂度是 $nk\log n+nk^2$，不开 O2 只能获得 80 分的好成绩。

附：不开 O2 80pts，开 O2 AC 的代码：

```cpp
namespace sub2{
	int x[MAXK+2],y[MAXK+2],t[MAXK+2];
	int mn[MAXK+2][MAXN+5],mx[MAXK+2][MAXN+5],sum[MAXK+2][MAXN+5];
	void calc(int r){
		for(int i=1;i<=n;i++) if(c[i]==r) t[r]+=d[i];
		if(t[r]<0){
			t[r]=-t[r];
			for(int i=1;i<=n;i++) if(c[i]==r) d[i]=-d[i];
		} int cur=0;
		for(int i=1;i<=n;i++){
			if(c[i]==r) cur+=d[i];sum[r][i]=cur;
			mn[r][i]=min(mn[r][i-1],cur);
			mx[r][i]=max(mx[r][i-1],cur);
		} x[r]=mn[r][n];y[r]=mx[r][n];
//		printf("%d %d\n",x[r],y[r]);
	}
	struct itvl{
		ll l,r;
		itvl(ll _l=0,ll _r=0):l(_l),r(_r){}
		itvl operator &(const itvl &rhs){
			return itvl(max(l,rhs.l),min(r,rhs.r));
		}
	};
	int calc(int mid,int id){
		static itvl it[MAXK+2];
		for(int i=1;i<=k;i++) it[i]=itvl(-x[i]+1,w[i]);
		for(int i=1;i<=k;i++){
			it[i]=it[i]&itvl(1-1ll*(mid-2)*t[i]-y[i],w[i]-1ll*(mid-2)*t[i]-y[i]);
			it[i]=it[i]&itvl(1-1ll*(mid-1)*t[i]-mx[i][id-1],w[i]-1ll*(mid-1)*t[i]-mx[i][id-1]);
		} it[c[id]]=it[c[id]]&itvl(w[c[id]]+1-1ll*(mid-1)*t[c[id]]-sum[c[id]][id],w[c[id]]+1-1ll*(mid-1)*t[c[id]]-sum[c[id]][id]);
//		printf("checking %d %d\n",mid,id);
//		for(int i=1;i<=k;i++) printf("%lld %lld\n",it[i].l,it[i].r);
		int res=1;
		for(int i=1;i<=k;i++){
			if(it[i].l>it[i].r) return 0;
			res=1ll*res*(it[i].r-it[i].l+1)%MOD;
		} return res;
	}
	int ff[10],inv[10];
	void solve(){
		for(int i=(inv[0]=inv[1]=1)+1;i<=6;i++) inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
		for(int i=1;i<=k;i++) calc(i);
//		for(int i=1;i<=k;i++) printf("%d %d %d\n",x[i],y[i],t[i]);
		int res=0;
		for(int i=1;i<=n;i++) if(d[i]==1){
			int l=2,r=1e9,p=-1;
			if(calc(1e9+1,i)) return puts("-1"),void();
			while(l<=r){
				int mid=l+r>>1;
				if(calc(mid,i)) p=mid,l=mid+1;
				else r=mid-1;
			} //printf("%d\n",p);
			if(~p){
				for(int j=2;j<=min(p,6);j++){
//					printf("%d %d %d\n",j,i,calc(j,i));
					ff[j]=1ll*calc(j,i)*(1ll*(j-1)*n%MOD+i)%MOD;
					ff[j]=(ff[j-1]+ff[j])%MOD;
				} if(p<=6) res=(res+ff[p])%MOD;
				else{
					for(int j=2;j<=6;j++){
						int ss=1;
						for(int k=2;k<=6;k++) if(j^k){
							int mul=1ll*(p-k+MOD)*inv[abs(j-k)]%MOD;
							if(j<k) mul=MOD-mul;ss=1ll*ss*mul%MOD;
						} res=(res+1ll*ss*ff[j])%MOD;
					}
				}
			}
		}
		for(int i=1;i<=n;i++){
			static itvl it[MAXK+2];
			for(int j=1;j<=k;j++) it[j]=itvl(1,w[j]);
			for(int j=1;j<=k;j++){
				it[j]=it[j]&itvl(1-mn[j][i-1],w[j]-mn[j][i-1]);
				it[j]=it[j]&itvl(1-mx[j][i-1],w[j]-mx[j][i-1]);
			} if(!~d[i]){
				it[c[i]]=it[c[i]]&itvl(0-sum[c[i]][i],0-sum[c[i]][i]);
			} else {
				it[c[i]]=it[c[i]]&itvl(w[c[i]]+1-sum[c[i]][i],w[c[i]]+1-sum[c[i]][i]);
			} int mul=i;
//			printf("%d:\n",i);
//			for(int j=1;j<=k;j++) printf("%lld %lld\n",it[j].l,it[j].r);
			for(int j=1;j<=k;j++){
				if(it[j].l>it[j].r) mul=0;
				else mul=1ll*mul*(it[j].r-it[j].l+1)%MOD;
			} res=(res+mul)%MOD;
		}
		printf("%d\n",res);
	}
}
int main(){
//	freopen("walk4.in","r",stdin);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++) scanf("%d",&w[i]);
	for(int i=1;i<=n;i++) scanf("%d%d",&c[i],&d[i]);
	if(sub1::check()) sub1::solve();
	else sub2::solve();
	return 0;
}
```

接下来考虑加点优化，显然复杂度瓶颈在于二分，注意到在二分检验的过程中，我们要用到很多不等式，不过这些不等式都可以写成 $s_j\in[1-Kt_j+B,w_j-Kt_j+B]$ 的形式，又根据之前的推理这些区间的交的左端点恰好是 $-x_j+1$，因此我们只用考虑右端点的限制，即 $B$ 最小的限制即可，由于这些区间的交集非空，必然可以得到 $w_j-Kt_j+B\ge -x_j+1$，移个项可以得到 $Kt_j\le w_j+B+x_j-1$，解得 $K\le\lfloor\dfrac{w_j+B+x_j-1}{t_j}\rfloor$，也就是说这些限制归结到底都可以写成 $K\le X$ 的形式，然后对这些 $X$ 取个 $\min$ 即可得到 $K$ 的最大值，这样就省去了二分的 $\log$。

还有就是上面的代码中插值用了暴力 $k^2$ 的插值方法，不过由于下标连续，可以 $\mathcal O(k)$ 插值，这样常数会小不少。

最后附上我最后一次提交的完整代码，开了 O2 只需 947ms：

```cpp
const int MAXN=5e5;
const int MAXK=10;
const int MOD=1e9+7;
int n,k,c[MAXN+5],d[MAXN+5],w[MAXK+2];
namespace sub1{
	bool check(){
		int flg=1;
		for(int i=1;i<=k;i++) flg&=(w[i]<=1e6);
		return flg;
	}
	const int MAXW=1e6;
	const ll INF=0x3f3f3f3f3f3f3f3fll;
	ll tim[MAXK+2][MAXW+5];
	int lft[MAXW+5],rit[MAXW+5];
	void calc(int x){
		memset(lft,0,sizeof(lft));memset(rit,0,sizeof(rit));
		int mn=0,mx=0,cur=0;
		for(int i=1;i<=n;i++) if(c[i]==x) cur+=d[i];
		if(cur<0){
			for(int i=1;i<=n;i++) if(c[i]==x) d[i]=-d[i];
		} cur=0;
		for(int i=1;i<=n;i++) if(c[i]==x){
			cur+=d[i];
			if(cur>mx) rit[cur]=i,mx=cur;
			if(cur<mn) lft[-cur]=i,mn=cur;
		}
		for(int i=1;i<=w[x];i++){
			tim[x][i]=INF;
			if(i+mn<=0) chkmin(tim[x][i],(ll)lft[i]);
			if(i+mx>w[x]) chkmin(tim[x][i],(ll)rit[w[x]+1-i]);
			if(cur){
				int bound=w[x]-mx+1;
				int tt=max((bound-i+cur-1)/cur,0);
				chkmin(tim[x][i],1ll*tt*n+rit[w[x]+1-(i+tt*cur)]);
			}
		}
	} ll A[MAXW+5],B[MAXW+5];
	int inv[MAXW+5];
	void mergesort(int x){
		int ps=0,c1=0,c2=0;
		for(int i=1;i<=w[x];i++) if(tim[x][i]>tim[x][i+1]){ps=i;break;}
		for(int i=ps;~i;i--) A[++c1]=tim[x][i];A[c1+1]=0;
		for(int i=ps+1;i<=w[x];i++) B[++c2]=tim[x][i];B[c2+1]=0;
		for(int i=1,p1=1,p2=1;i<=w[x];i++){
			if(A[p1]>B[p2]) tim[x][i]=A[p1++];
			else tim[x][i]=B[p2++];
		}
	}
	int cnt[MAXK+5];
	void solve(){
		for(int i=1;i<=k;i++) calc(i);
		for(int i=1;i<=k;i++) mergesort(i);
		for(int i=(inv[0]=inv[1]=1)+1;i<=MAXW;i++)
			inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
		int sm=0;for(int i=1;i<=k;i++) sm+=w[i];
		bool flg=1;
		for(int i=1;i<=k;i++) flg&=(tim[i][1]==INF);
		if(flg) return puts("-1"),void();
		int res=1,cnt0=k,ans=0;
		for(int i=1;i<=sm;i++){
			int x=0;
			for(int j=1;j<=k;j++) if(tim[j][cnt[j]+1]>tim[x][cnt[x]+1]) x=j;
			if(!cnt[x]) cnt0--;
			else res=1ll*res*inv[cnt[x]]%MOD*(cnt[x]+1)%MOD;
			++cnt[x];
			if(!cnt0&&tim[x][cnt[x]]) ans=(ans+tim[x][cnt[x]]%MOD*res%MOD*inv[cnt[x]])%MOD;
		} printf("%d\n",ans);
	}
}
namespace sub2{
	int x[MAXK+2],y[MAXK+2],t[MAXK+2];
	int mn[MAXK+2][MAXN+5],mx[MAXK+2][MAXN+5],sum[MAXK+2][MAXN+5];
	void calc(int r){
		for(int i=1;i<=n;i++) if(c[i]==r) t[r]+=d[i];
		if(t[r]<0){
			t[r]=-t[r];
			for(int i=1;i<=n;i++) if(c[i]==r) d[i]=-d[i];
		} int cur=0;
		for(int i=1;i<=n;i++){
			if(c[i]==r) cur+=d[i];sum[r][i]=cur;
			mn[r][i]=min(mn[r][i-1],cur);
			mx[r][i]=max(mx[r][i-1],cur);
		} x[r]=mn[r][n];y[r]=mx[r][n];
	}
	struct itvl{
		ll l,r;
		itvl(ll _l=0,ll _r=0):l(_l),r(_r){}
		itvl operator &(const itvl &rhs){
			return itvl(max(l,rhs.l),min(r,rhs.r));
		}
	};
	int calc(int mid,int id){
		static itvl it[MAXK+2];
		for(int i=1;i<=k;i++) it[i]=itvl(-x[i]+1,w[i]);
		for(int i=1;i<=k;i++){
			it[i]=it[i]&itvl(1-1ll*(mid-2)*t[i]-y[i],w[i]-1ll*(mid-2)*t[i]-y[i]);
			it[i]=it[i]&itvl(1-1ll*(mid-1)*t[i]-mx[i][id-1],w[i]-1ll*(mid-1)*t[i]-mx[i][id-1]);
		} it[c[id]]=it[c[id]]&itvl(w[c[id]]+1-1ll*(mid-1)*t[c[id]]-sum[c[id]][id],w[c[id]]+1-1ll*(mid-1)*t[c[id]]-sum[c[id]][id]);
		int res=1;
		for(int i=1;i<=k;i++){
			if(it[i].l>it[i].r) return 0;
			res=1ll*res*(it[i].r-it[i].l+1)%MOD;
		} return res;
	}
	int ff[15],ifac[15],pre[15],suf[15];
	void solve(){
		for(int i=(ifac[0]=ifac[1]=1)+1;i<=k+3;i++) ifac[i]=1ll*ifac[MOD%i]*(MOD-MOD/i)%MOD;
		for(int i=1;i<=k+3;i++) ifac[i]=1ll*ifac[i-1]*ifac[i]%MOD;
		for(int i=1;i<=k;i++) calc(i);
		bool flg=1;
		for(int i=1;i<=k;i++) flg&=(!t[i]&&y[i]-x[i]+1<=w[i]);
		if(flg) return puts("-1"),void();
		int res=0;
		for(int i=1;i<=n;i++) if(d[i]==1){
			if(!calc(2,i)) continue;
			int p=1e9+1;
			for(int j=1;j<=k;j++){
				if(t[j]){
					chkmin(p,(w[j]+2*t[j]-y[j]+x[j]-1)/t[j]);
					chkmin(p,(w[j]+t[j]-mx[j][i-1]+x[j]-1)/t[j]);
				}
			}
//			while(l<=r){
//				int mid=l+r>>1;
//				if(calc(mid,i)) p=mid,l=mid+1;
//				else r=mid-1;
//			}
			for(int j=2;j<=min(p,k+3);j++){
				ff[j]=1ll*calc(j,i)*(1ll*(j-1)*n%MOD+i)%MOD;
				ff[j]=(ff[j-1]+ff[j])%MOD;
			} if(p<=k+3) res=(res+ff[p])%MOD;
			else{
				pre[1]=suf[k+4]=1;
				for(int j=2;j<=k+3;j++) pre[j]=1ll*pre[j-1]*(p-j+MOD)%MOD;
				for(int j=k+3;j>>1;j--) suf[j]=1ll*suf[j+1]*(p-j+MOD)%MOD; 
				for(int j=2;j<=k+3;j++){
					int mul=1ll*pre[j-1]*suf[j+1]%MOD;
					mul=1ll*mul*ifac[j-2]%MOD*ifac[k+3-j]%MOD;
					if((k+3-j)&1) mul=MOD-mul;
					res=(res+1ll*mul*ff[j])%MOD;
				}
			}
		}
		for(int i=1;i<=n;i++){
			static itvl it[MAXK+2];
			for(int j=1;j<=k;j++) it[j]=itvl(1,w[j]);
			for(int j=1;j<=k;j++){
				it[j]=it[j]&itvl(1-mn[j][i-1],w[j]-mn[j][i-1]);
				it[j]=it[j]&itvl(1-mx[j][i-1],w[j]-mx[j][i-1]);
			} if(!~d[i]) it[c[i]]=it[c[i]]&itvl(0-sum[c[i]][i],0-sum[c[i]][i]);
			else it[c[i]]=it[c[i]]&itvl(w[c[i]]+1-sum[c[i]][i],w[c[i]]+1-sum[c[i]][i]);
			int mul=i;
			for(int j=1;j<=k;j++){
				if(it[j].l>it[j].r) mul=0;
				else mul=1ll*mul*(it[j].r-it[j].l+1)%MOD;
			} res=(res+mul)%MOD;
		}
		printf("%d\n",res);
	}
}
int main(){
//	freopen("walk4.in","r",stdin);
	freopen("walk.in","r",stdin);
	freopen("walk.out","w",stdout);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++) scanf("%d",&w[i]);
	for(int i=1;i<=n;i++) scanf("%d%d",&c[i],&d[i]);
	if(sub1::check()) sub1::solve();
	else sub2::solve();
	return 0;
}
```

~~啊啊啊啊啊啊啊我的 E 队怎么就没了呢~~



---

## 作者：Calculatelove (赞：10)

## Solution

### 算法一

部分分：$w_i \leq 10^6$。

不难想到，可以考虑计算 " 走完了第 $i$ 步后恰好走出场地 " 的所有点对答案的贡献。

为了方便叙述，约定：

- 一个周期：前 $n$ 步组成的路线。
- $L_i$：在第 $i$ 个维度上，当前仍然在场地内的点的坐标的最小值。
- $R_i$：在第 $i$ 个维度上，当前仍然在场地内的点的坐标的最大值。
- $\overrightarrow{v}$：经过了一个周期后的位移向量；$v_i$：位移向量 $\overrightarrow{v}$ 在第 $i$ 个维度上的位移。

> #### 引理 1
>
> 若会出现某一个点死循环，则满足以下两个条件。

> （1）：经过了一个周期后，存在一个点没有走出场地。  

> （2）：$\overrightarrow{v} = \overrightarrow{0}$。

> #### 证明
>
> 必要性：显然。

> 充分性：考虑满足（$1$）的点，因为 $\overrightarrow{v} = \overrightarrow{0}$，所以无论走了多少个周期，该点始终呆在原地，也不会在走周期的过程中走出场地。故出现死循环。

> 故命题得证，QED。

考虑一下什么情况下会对答案造成贡献。

> #### 引理 2
>
> 若第 $i$ 步对答案有贡献，则当前在第 $c_i$ 维上的位移，一定是向 " 正方向 " 走或向 "反方向 " 走的历史位移最大值（即可以更新 $L_{c_i}$ 或 $R_{c_i}$）。

> #### 证明
>
> 考虑 $L_i$ 和 $R_i$ 的定义，不难发现：在第 $c_i$ 维中，所有离开场地的点的坐标一定在 $[1, L_{c_i}) \ \bigcup \ (R_{c_i}, w_{c_i}]$ 内。

> 那么，若第 $i$ 步后 $L_{c_i}$ 或 $R_{c_i}$ 没有得到更新，那么 $[1, L_{c_i}) \ \bigcup \ (R_{c_i}, w_{c_i}]$ 是不会变的，故离开场地的点的集合也没变。故在该种情况下，第 $i$ 步不对答案造成贡献。

> 进一步分析可知：若第 $i$ 步后 $L_{c_i}$ 或 $R_{c_i}$ 得到了更新，那么这一批离开场地的点的坐标均为更新后的 $L_{c_i} - 1$ 或 $R_{c_i} + 1$。

> 故命题得证，Q.E.D

考虑一下该种情况下会造成多少贡献。

> #### 引理 3
>
> 若第 $i$ 步对答案有贡献，则该贡献值为 $i \times \prod\limits_{j \neq c_i} (R_j - L_j + 1)$。

> #### 证明
>
> 对于第 $c_i$ 维，这一批离开场地的点的坐标均为更新后的 $L_{c_i} - 1$ 或 $R_{c_i} + 1$。

> 对于除了第 $c_i$ 维的任意一个维度，现在考虑第 $p$ 维。  
> 显然，这一批离开场地的点的坐标可以在 $[L_p, R_p]$ 中任意做选择。

> 根据乘法原理，这一批离开场地的点共有：
> $$
> (R_1 - L_1 + 1) \times \cdots \times (R_{c_i - 1} - L_{c_i - 1} + 1) \times 1 \times (R_{c_i + 1} - L_{c_i + 1} + 1) \times \cdots \times (R_k - L_k + 1)
> $$

> 即为：
> $$
> \prod\limits_{j \neq c_i} (R_j - L_j + 1)
> $$
>
> 将上式乘上 $i$，即为第 $i$ 步对答案的贡献值。

> 故命题得证，Q.E.D

至此，我们已经有方法可以计算出正确的答案。只不过，要是直接枚举 $i$ 的话，时间复杂度是不能接受的。

我们还没有利用到移动路线的 " 周期性 "，接下来就来讨论一下 " 周期性 " 在本题中的特殊效果。为了方便叙述，我们称可以对答案造成贡献的一步为 **" 特殊步 "**。

> #### 引理 4
>
> （1）：当第一周期中的第 $i$ 步为 " 特殊步 " 时：
>
> - 则第二周期中的第 $i + n$ 步，第三周期中的第 $i + 2n$ 步，...，均**不一定**为 " 特殊步 "。

> （2）：当第一周期中的第 $i$ 步为 " 特殊步 "，且第二周期中的第 $i + n$ 步也为 " 特殊步 " 时：
>
> - 第三周期中的第 $i + 2n$ 步，第四周期中的第 $i + 3n$ 步，...，**一定**均为 " 特殊步 "。

> #### 引理 4 的推论
>
> 第一周期中 " 特殊步 " 的分布是特殊的； 第二、三、四、... 周期中 " 特殊步 " 的分布是相同的。

根据引理 $4$ 的推论，我们可以先计算出第一周期中 " 特殊步 " 对答案的贡献。 

对于第二、三、四、... 周期，**考虑步数模 $n$ 的结果**，对于模 $n$ 的所有同余类 $\overline{1}, \overline{2}, \cdots, \overline{n - 1}, \overline{0}$，我们可以分别计算每个同余类对答案的贡献。

> #### 引理 5
>
> 设当前进行到了第 $i$ 步，若进行到了第 $i + n$ 步时，该点还在场地内，对于第 $j$ 维的变化是：

> （1）：若 $v_j > 0$，则 $L_j \gets L_j + |v_j|$。

> （2）：若 $v_j < 0$，则 $R_j \gets R_j - |v_j|$。

> （3）：对于 $R_j - L_j + 1$，其值将会变化为：
> $$
> (R_j - L_j + 1) - |v_j|
> $$

> #### 证明
>
> 不难发现，若 " 进行到第 $i + n$ 步时，该点还在场地内 "。

> 则 " 前 $i$ 步组成的路径 " 与 " 前 $i + n$ 步组成的路径 " 之间只差了一个周期位移向量 $\overrightarrow{v}$。  
> （在该情况下，位移的先后顺序不影响最终结果）

> 那么，在只考虑第 $j$ 维的情况下。 

> 相当于进行到了第 $i$ 步，然后又经过了一个周期后，坐标值被加上了 $v_j$。

> 故命题得证，Q.E.D

> #### 引理 5 的推论
>
> 对于第二周期中的第 $i$ 步（其中 $n < i \leq 2n$），若第 $i$ 步是一个 " 特殊步 "。 

> 考虑第 $n \ast x + (i - n)$ 步，若该步也是一个 " 特殊步 "，则该步对答案的贡献为：
>
> $$
> [n \times (x - 1) + i] \prod \limits_{j \neq c_i} [-|v_j| \times (x - 1) + (R_j - L_j + 1)]
> $$

> 即：
> $$
> [n \times x + (i - n)] \prod\limits_{j \neq c_i}[-|v_j| \times x + (R_j - L_j + 1 + |v_j|)]
> $$

至此，已经有了一个初步的做法。

枚举 $i = 1 \to n$，先计算出第一周期中 " 特殊步 " 对答案的贡献。 

再枚举 $i = (n + 1) \to 2n$，计算每个模 $n$ 的同余类 $\overline{i - n}$ 对答案的贡献。具体地，根据引理 $5$ 的推论，在循环内部再枚举一个 $x$ 即可。

时间复杂度玄学，上界是 $\mathcal{O}(nk \times \max\limits_{1\leq i\leq k} \left\{w_i\right\})$，但实际上远不能达到上界，所以可以拿到可观的 $80$ 分。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

inline int read() {
	int x = 0, f = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') f = -f; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * f;
}

const int N = 500100, SIZE = 11;
const int mod = 1e9 + 7;

int n, k;

int w[SIZE];
int c[N], d[N];

int L[SIZE], R[SIZE];

int v[SIZE];
int u[SIZE];

int cur[SIZE];

int ans;

int main() {
	n = read(), k = read();

	for (int i = 1; i <= k; i ++)
		w[i] = read();

	for (int i = 1; i <= n; i ++)
		c[i] = read(), d[i] = read();

	// judgment has no answer.

	for (int i = 1; i <= k; i ++)
		L[i] = 1, R[i] = w[i];

	for (int i = 1; i <= n; i ++) {
		v[c[i]] += d[i];

		if (v[c[i]]) {
			if (v[c[i]] > 0) {
				int val = v[c[i]];
				if (w[c[i]] - val < R[c[i]]) R[c[i]] = w[c[i]] - val; 
			} else {
				int val = -v[c[i]];
				if (val + 1 > L[c[i]]) L[c[i]] = val + 1;
			}
		}
	}

	bool flag1 = 1;
	for (int i = 1; i <= k; i ++)
		if (L[i] > R[i]) flag1 = 0;

	bool flag2 = 1;
	for (int i = 1; i <= k; i ++)
		if (v[i]) flag2 = 0;

	if (flag1 && flag2) {
		puts("-1");
		return 0;
	}

	// work

	for (int i = 1; i <= k; i ++)
		L[i] = 1, R[i] = w[i];

	for (int i = 1; i <= n; i ++) {
		int C = c[i], D = d[i];

		u[C] += D;

		bool great = 0;

		if (u[C]) {
			if (u[C] > 0) {
				int val = u[C];
				if (w[C] - val < R[C])
					R[C] = w[C] - val, great = 1;
			} else {
				int val = -u[C];
				if (val + 1 > L[C])
					L[C] = val + 1, great = 1;
			}
		}

		if (great) {
			int val = 1;
			for (int j = 1; j <= k; j ++) {
				if (j == C) continue;
				val = 1ll * val * (R[j] - L[j] + 1) % mod;
			}

			ans = (ans + 1ll * val * i) % mod;

			if (L[C] > R[C]) {
				printf("%d\n", ans);
				return 0;
			}
		}
	}

	for (int i = n + 1; i <= 2 * n; i ++) {
		int C = c[i - n], D = d[i - n];

		u[C] += D;

		bool great = 0;

		if (u[C]) {
			if (u[C] > 0) {
				int val = u[C];
				if (w[C] - val < R[C])
					great = 1;
			} else {
				int val = -u[C];
				if (val + 1 > L[C])
					great = 1;
			}
		}

		if (great) {
			int mul = i;
			for (int j = 1; j <= k; j ++) cur[j] = R[j] - L[j] + 1;

			bool keep = 1;
			while (keep) {
				int val = 1;
				for (int j = 1; j <= k; j ++) {
					if (j == C) continue;
					val = 1ll * val * cur[j] % mod;
				}

				ans = (ans + 1ll * val * mul) % mod;

				mul = (mul + n) % mod;
				for (int j = 1; j <= k; j ++) {
					cur[j] -= abs(v[j]);

					if (cur[j] <= 0) {
						keep = 0;
						break;
					}
				}
			}
		}

		if (u[C]) {
			if (u[C] > 0) {
				int val = u[C];
				if (w[C] - val < R[C])
					R[C] = w[C] - val;
			} else {
				int val = -u[C];
				if (val + 1 > L[C])
					L[C] = val + 1;
			}
		}

		if (L[C] > R[C]) {
			printf("%d\n", ans);
			return 0;
		}
	}

	printf("%d\n", ans);

	return 0;
}

// I hope changle_cyx can pray for me. 
```

### 算法二

特殊性质：$w_i \leq 10^9$。

看起来「算法一」非常有前途，考虑优化。优化的重点其实在于计算模 $n$ 的所有同余类 $\overline{1}, \overline{2}, \cdots, \overline{n - 1}, \overline{0}$ 对答案的贡献。

对于第二周期中的第 $i$ 步（其中 $n < i \leq 2n$），若第 $i$ 步是一个 " 特殊步 "。

考虑第 $n \ast x + (i - n)$ 步，若该步也是一个 " 特殊步 "，则不难发现，该步对答案的贡献是一个与 $x$ 有关的多项式，可以考虑用 $f(x)$ 表示：
$$
f(x) = [n \times x + (i - n)] \prod\limits_{j \neq c_i}[-|v_j| \times x + (R_j - L_j + 1 + |v_j|)]
$$

注意到 $f(x)$ 的每个乘积项，都是关于 $x$ 的一次二项式。 

可以考虑将这 $k$ 个乘积项卷在一起，即可得到一个 $k$ 次多项式 $f(x)$。至于计算出 $f(x)$ 的系数，直接暴力卷即可，因为 $k$ 很小，所以复杂度肯定是可以接受的。

> 多项式乘法（卷积）：
>
> - 给定两个多项式 $f(x)$ 与 $g(x)$：
>
> $$
> f(x) = \sum\limits_{i = 0}^n a_i \times x^i
> $$
>
> $$
> g(x) = \sum\limits_{j = 0}^m b_j \times x^j
> $$
>
> - 要计算多项式 $Q(x) = f(x) \times g(x)$：
>
> $$
> Q(x) = \sum\limits_{i = 0}^n \sum\limits_{j = 0}^m a_i \times b_j \times x^{i + j}
> $$

考虑计算贡献。设模 $m$ 的同余类 $\overline{i}$ 从第二周期开始，最多要计算到第 $E$ 轮，不难得到：
$$
E = \min\limits_{1 \leq i \leq k, v_i \neq 0} \left\{ \left\lfloor\frac{R_i - L_i}{|v_i|}\right\rfloor + 1 \right\}
$$

此时贡献为：
$$
\sum\limits_{x = 1}^E f(x)
$$

将 $f(x)$ 用 $\sum\limits_{i = 0}^k a_i \times x^i$ 替换，得：
$$
\sum\limits_{x = 1}^E \sum\limits_{i = 0}^k a_i \times x^i
$$

交换枚举顺序，得：
$$
\sum\limits_{i = 0}^k \left(  a_i \times \sum\limits_{x = 1}^E x^i \right)
$$

至于要快速计算函数 $S_k(n) = \sum\limits_{i = 1}^n i^k$，是一个非常经典的问题。详见 [CF622F The Sum of the k-th Powers](https://codeforces.com/problemset/problem/622/F)。

本篇题解中，代码给出的是 " 拉格朗日插值 "。

代码中并没有直接拉格朗日插值，而是使用拉格朗日插值先预处理出 $S_k(n)$ 所对应的关于 $n$ 的 $k + 1$ 次多项式，然后再代入 $x$ 进行计算。

时间复杂度 $\mathcal{O}(nk^2)$。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

inline int read() {
	int x = 0, f = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') f = -f; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * f;
}

int power(int a, int b, int p) {
	int ans = 1;
	for (; b; b >>= 1) {
		if (b & 1) ans = 1ll * ans * a % p;
		a = 1ll * a * a % p; 
	}
	return ans;
}

const int N = 500100, SIZE = 20;
const int mod = 1e9 + 7;

int n, k;

int w[SIZE];
int c[N], d[N];

int L[SIZE], R[SIZE];

int v[SIZE];
int u[SIZE];

struct polynomial {
	int m;
	int num[SIZE];

	polynomial() {
		m = 0;
		memset(num, 0, sizeof(num));
	}

	polynomial(int a, int b, int c) { m = a, num[0] = b, num[1] = c; }
};

polynomial operator + (polynomial a, polynomial b) {
	polynomial c;

	c.m = a.m;
	for (int i = 0; i <= a.m; i ++)
		c.num[i] = (a.num[i] + b.num[i]) % mod;

	return c;
}

polynomial operator * (polynomial a, polynomial b) {
	polynomial c;

	c.m = a.m + b.m;
	for (int i = 0; i <= a.m; i ++)
		for (int j = 0; j <= b.m; j ++)
			c.num[i + j] = ((c.num[i + j] + 1ll * a.num[i] * b.num[j]) % mod + mod) % mod;

	return c;
}

int calc(polynomial a, int x) {
	int ans = 0;
	for (int i = 0, val = 1; i <= a.m; i ++, val = 1ll * val * x % mod)
		ans = (ans + 1ll * a.num[i] * val) % mod;
	return ans;
}

polynomial g[SIZE];

int val[SIZE];

void Lagrange(int K) {
	val[0] = 0;
	for (int i = 1; i <= K + 2; i ++) val[i] = (val[i - 1] + power(i, K, mod)) % mod;

	g[K].m = K + 1;

	for (int i = 1; i <= K + 2; i ++) {
		polynomial p = polynomial(0, 1, 0);
		int q = 1;

		for (int j = 1; j <= K + 2; j ++) {
			if (i == j) continue;
			p = p * polynomial(1, mod - j, 1);
			q = 1ll * q * (((i - j) + mod) % mod) % mod;
		}

		p = p * polynomial(0, power(q, mod - 2, mod), 0);
		p = p * polynomial(0, val[i], 0);

		g[K] = g[K] + p;
	}
}

int ans;

int main() {
	n = read(), k = read();

	for (int i = 1; i <= k; i ++)
		w[i] = read();

	for (int i = 1; i <= n; i ++)
		c[i] = read(), d[i] = read();

	// judgment has no answer.

	for (int i = 1; i <= k; i ++)
		L[i] = 1, R[i] = w[i];

	for (int i = 1; i <= n; i ++) {
		v[c[i]] += d[i];

		if (v[c[i]]) {
			if (v[c[i]] > 0) {
				int val = v[c[i]];
				if (w[c[i]] - val < R[c[i]]) R[c[i]] = w[c[i]] - val; 
			} else {
				int val = -v[c[i]];
				if (val + 1 > L[c[i]]) L[c[i]] = val + 1;
			}
		}
	}

	bool flag1 = 1;
	for (int i = 1; i <= k; i ++)
		if (L[i] > R[i]) flag1 = 0;

	bool flag2 = 1;
	for (int i = 1; i <= k; i ++)
		if (v[i]) flag2 = 0;

	if (flag1 && flag2) {
		puts("-1");
		return 0;
	}

	// work

	for (int i = 1; i <= k; i ++)
		L[i] = 1, R[i] = w[i];

	for (int i = 1; i <= n; i ++) {
		int C = c[i], D = d[i];

		u[C] += D;

		bool great = 0;

		if (u[C]) {
			if (u[C] > 0) {
				int val = u[C];
				if (w[C] - val < R[C])
					R[C] = w[C] - val, great = 1;
			} else {
				int val = -u[C];
				if (val + 1 > L[C])
					L[C] = val + 1, great = 1;
			}
		}

		if (great) {
			int val = 1;
			for (int j = 1; j <= k; j ++) {
				if (j == C) continue;
				val = 1ll * val * (R[j] - L[j] + 1) % mod;
			}

			ans = (ans + 1ll * val * i) % mod;

			if (L[C] > R[C]) {
				printf("%d\n", ans);
				return 0;
			}
		}
	}

	for (int i = 0; i <= k; i ++)
		Lagrange(i);

	for (int i = n + 1; i <= 2 * n; i ++) {
		int C = c[i - n], D = d[i - n];

		u[C] += D;

		bool great = 0;

		if (u[C]) {
			if (u[C] > 0) {
				int val = u[C];
				if (w[C] - val < R[C])
					great = 1;
			} else {
				int val = -u[C];
				if (val + 1 > L[C])
					great = 1;
			}
		}

		if (great) {
			int Round = 0x3f3f3f3f;

			for (int j = 1; j <= k; j ++) {
				if (!v[j]) continue;
				Round = min(Round, ((R[j] - L[j]) / abs(v[j])) + 1);
			}

			polynomial f = polynomial(0, 1, 0);

			f = f * polynomial(1, i - n, n);

			for (int j = 1; j <= k; j ++) {
				if (j == C) continue;
				f = f * polynomial(1, R[j] - L[j] + 1 + abs(v[j]), mod - abs(v[j]));
			}

			for (int j = 0; j <= k; j ++)
				ans = (ans + 1ll * f.num[j] * calc(g[j], Round)) % mod;
		}

		if (u[C]) {
			if (u[C] > 0) {
				int val = u[C];
				if (w[C] - val < R[C])
					R[C] = w[C] - val;
			} else {
				int val = -u[C];
				if (val + 1 > L[C])
					L[C] = val + 1;
			}
		}

		if (L[C] > R[C]) {
			printf("%d\n", ans);
			return 0;
		}
	}

	printf("%d\n", ans);

	return 0;
}

// I hope changle_cyx can pray for me. 
```

---

## 作者：xiaolilsq (赞：6)

# 题解 微信步数

[题目链接](https://www.luogu.com.cn/problem/P7116)

[假装更好的阅读体验](https://www.cnblogs.com/lsq147/p/14186642.html)

如果 $\LaTeX$ 有锅请到博客内查看。

## 题目分析

如果将每一维度都合在一起考虑，复杂度貌似无论如何都需要带上一个 $\prod_{i=1}^kw_i$ ，类似 [CSP2020T3](https://www.luogu.com.cn/problem/P7077) 的思路，如果把每一维都分开考虑可能可以降低一点复杂度。

对于维度 $i$ 的某一个位置 $p(1\le p\le w_i)$ ，我们可以求出一个值 $\operatorname{time}_i(p)$ 表示在**仅考虑维度 $i$ 时**小 C 走出场地需要的最少步数，如果小 C 无论如何都无法走出场地那么 $\operatorname{time}_i(p)=+\infty$ ，求出 $\operatorname{time}$ 这个函数之后，小 C 从 $(a_1,a_2,\dots,a_k)$ 走出场地需要的步数就是 $\min_{i=1}^k\operatorname{time}_i(a_i)$ 。

对于某一维度 $i$ ，我们并不关心 $\operatorname{time}_i(1\dots w_i)$ 这个数列所有值之间的顺序，所以我们可以给 $\operatorname{time}_i(1\dots w_i)$ 先排个序。

我们需要求的东西是：

$$
\sum_{1\le a_i\le w_i}\min_{i=1}^k\operatorname{time}_i(a_i)=\sum_{i\ge 1}\prod_{j=1}^k(\sum_{t=1}^{w_j}[\operatorname{time}_j(t)\ge i])
$$

直接求出所有的 $\operatorname{time}_i(j)$ ，然后从小到大枚举每一个 $\operatorname{time}_i(j)$ 就可以很容易求出上面这个式子的值了，此时我们就成功地将 $\prod_{i=1}^kw_i$ 的复杂度降为了 $\sum_{i=1}^kw_i$ 了，按照实现不同复杂度此时可以达到 $\mathcal O((\sum_{i=1}^kw_i)\log_2(\sum_{i=1}^kw_i))$ 或 $\mathcal O(k(\sum_{i=1}^kw_i))$ 或 $\mathcal O((\sum_{i=1}^kw_i)\log_2 k)$ ，应该可以拿到 $80\rm pts$ 。

要拿更高的分数，需要进一步观察 $\operatorname{time}_i(1\dots w_i)$ 这个数列的性质，可以找到两个数列 $\operatorname{num}_i(1\dots p_i)$ 以及 $\operatorname{sum}_i(1\dots s_i)$ 使得 $\operatorname{time}_i(1\dots w_i)$ 是数列 $\operatorname{num}_i(1\dots p_i)$ 和数列 $\operatorname{sum}_i(1\dots s_i)$ 不断重复同时加上若干倍的 $n$ 得到的：

$$
\operatorname{num}_i(1),\dots,\operatorname{num}_i(p_i),\operatorname{sum}_i(1)+n,\dots,\operatorname{sum}_i(s_i)+n,\operatorname{sum}_i(1)+2n,\dots,\operatorname{sum}_i(s_i)+2n,\operatorname{sum}_i(1)+3n,\dots,\operatorname{sum}_i(1)+tn,\dots
$$

并且上面这个序列是排好序的，有 $\operatorname{num}_i(j)\le n,\operatorname{sum}_i(j)\le n$ 。

由于 $\sum_{i=1}^kp_i\le n$ ，所以我们可以用上面的方法求出 $\operatorname{num}_i()$ 数列这一段的值，即这个式子的值：

$$
\sum_{i=1}^n\prod_{j=1}^k(\sum_{t=1}^{w_j}[\operatorname{time}_j(t)\ge i])
$$

需要注意的是 $\operatorname{sum}_i()$ 这个数列重复是一直重复到 $w_i$ 为止的，如果把 $\operatorname{sum}_i(1)+tn,\dots \operatorname{sum}_i(s_i)+tn$ 称作是一轮的话，那么可能最后并不能凑成一整轮，由于 $\sum_{i=1}^ks_i\le n$ ，所以无法凑够一整轮的这一部分也可以单独算，关键是算中间重复着的若干轮。

中间重复着的若干轮数列之间的 $\operatorname{sum}_i()$ 的大小关系都是固定的，所以我们只需要模拟第一轮其实就已经模拟了所有轮了。

假设重复的轮数为 $r$ ，对于当前枚举的某一个 $i$ ， $c_j=\sum_{t=1}^{w_j}[\operatorname{time}_j(t)\ge i]$ ，那么此时造成贡献需要乘以的系数应该是这个：

$$
\sum_{t=0}^{r-1}\prod_{j=1}^k(c_j-t\cdot s_i)=\sum_{t=0}^{r-1}\sum_{S}(-t)^{| S |}\prod_{j\in S}s_j\prod_{j\notin S}c_j=\sum_{S}\prod_{j\in S}s_j\prod_{j\not\in S}c_j(-1)^{|S|}\sum_{t=0}^{r-1}t^{|S|}
$$

令：

$$
f(x)=(-1)^x\sum_{t=0}^{r-1}t^x,dp(x)=\sum_{|S|=x}\prod_{j\in S}s_j\prod_{j\not\in S}c_j
$$

那么要求的就是：

$$
\sum_{x=0}^kf(x)dp(x)
$$

如何求 $f(x)$ ？自然数幂求和，设 $S_k(n)=\sum_{i=0}^ni^k$ ：

$$
S_k(n)=\sum_{i=0}^ni^k=\sum_{i=0}^n\sum_{j=0}^k{i\choose j}{k\brace j}j!=\sum_{j=0}^k{k\brace j}j!{n+1\choose j+1}
$$

直接 $\mathcal O(k^2)$ 求即可（当然可以用一些其它的方式求，这里不多说）。

如何求 $dp(x)$ ？显然可以 $dp$ 求，设 $dp(i,x)$ 表示仅考虑前 $i$ 个数的答案，那么转移就是考虑当前这个数是否包含在集合内：

$$
dp(i,x)=dp(i-1,x)\times c_i+dp(i-1,x-1)\times s_i
$$

最后的 $dp(x)=dp(k,x)$ 。

如果每次都做一次 $dp$ ，单次时间复杂度是 $\mathcal O(k^2)$ 的，总的时间复杂度就是 $\mathcal O(nk^2)$ 的，应该可以过，但是可以更优，不难发现这个 $dp$ 是可撤销的，也就是我们可以删除一个数，即：

$$
dp(i-1,x)=(dp(i,x)-dp(i-1,x-1)\times s_i)\div c_i
$$

由于每次我们只会更改某一个位置 $v$ ，即令 $c_v\gets c_v-1$ ，所以我们可以先撤销 $v$ 造成的影响，然后更新完 $c_v$ 后再加上 $v$ 造成的影响，这样就不需要每次都 $dp$ 一遍，单词时间复杂度降为 $\mathcal O(k)$ ，总时间复杂度为 $\mathcal O(nk)$ 。

如果算上所有操作，总时间复杂度就是 $\mathcal O(k^2+n(k+\log_2w))$ 的。

~~总感觉自己把挺简单的一个东西讲得好复杂啊。~~

## 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define ch() getchar()
#define pc(x) putchar(x)
template<typename T>void read(T&x){
	static char c;static int f;
	for(c=ch(),f=1;c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c>='0'&&c<='9';c=ch())x=x*10+(c&15);x*=f;
}
template<typename T>void write(T x){
	static char q[64];int cnt=0;
	if(x==0)return pc('0'),void();
	if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10+'0',x/=10;
	while(cnt--)pc(q[cnt]);
}
const int mod=1000000007,maxn=500006,maxk=12;
int mo(const int x){
	return x>=mod?x-mod:x;
}
int power(int a,int x){
	int re=1;
	while(x){
		if(x&1)re=1ll*re*a%mod;
		a=1ll*a*a%mod,x>>=1;
	}
	return re;
}
int cnto[maxk][maxn],cntr[maxk][maxn];
int pos[maxk],w[maxk];
int ABS(int x){
	return x<0?-x:x;
}
int num[maxk][maxn],p[maxk],pn[maxk];
int sum[maxk][maxn],s[maxk],cn[maxk];
int _s[maxk][maxk],f[maxk];
int dp[maxk];
void chkmin(int&x,int y){
	x=min(x,y);
}
int main(){
	freopen("walk.in","r",stdin);
	freopen("walk.out","w",stdout);
	int n,k;read(n),read(k);
	for(int i=1;i<=k;++i)read(w[i]);
	memset(cnto,0x3f,sizeof cnto);
	memset(cntr,0x3f,sizeof cntr);
	for(int i=1;i<=n;++i){
		int c,d;read(c),read(d);pos[c]+=d;
		if(pos[c]<0&&      -pos[c]<=w[c])chkmin(cnto[c][-pos[c]],i);
		if(pos[c]>0&&w[c]-pos[c]+1>=1   )chkmin(cntr[c][ pos[c]],i);
	}
	int ok=true,rd=0x3f3f3f3f;
	for(int i=1;i<=k;++i){
		int no=1,nr=1;
		while(cnto[i][no]<0x3f3f3f3f)++no;--no;
		while(cntr[i][nr]<0x3f3f3f3f)++nr;--nr;
		s[i]=ABS(pos[i]);
		if(no+nr>=w[i]){
			int l=1,r=w[i];
			int vl=min(cnto[i][l],cntr[i][w[i]-l+1]),
				vr=min(cnto[i][r],cntr[i][w[i]-r+1]);
			while(l<=r){
				if(vl<vr)num[i][++p[i]]=vl,++l,vl=min(cnto[i][l],cntr[i][w[i]-l+1]);
				else     num[i][++p[i]]=vr,--r,vr=min(cnto[i][r],cntr[i][w[i]-r+1]);
			}
			for(int j=1;j<=s[i];++j)
				sum[i][j]=0x3f3f3f3f;
			ok=false;rd=0;
		}
		else{
			int l=1,r=1;
			while(l<=no||r<=nr){
				if(r>nr||(l<=no&&cnto[i][l]<cntr[i][r]))
					num[i][++p[i]]=cnto[i][l],++l;
				else
					num[i][++p[i]]=cntr[i][r],++r;
			}
			if(pos[i]>0){
				for(int j=1;j<=s[i];++j)
					sum[i][j]=cntr[i][nr-s[i]+j];
			}
			if(pos[i]<0){
				for(int j=1;j<=s[i];++j)
					sum[i][j]=cnto[i][no-s[i]+j];
			}
		}
		if(s[i]>0){
			ok=false;
			rd=min(rd,(w[i]-p[i])/s[i]);
		}
	}
	if(ok)return puts("-1"),0;
	f[0]=rd;_s[0][0]=1;
	for(int i=1;i<=k;++i){
		_s[i][0]=0;
		for(int j=1;j<=i;++j)
			_s[i][j]=mo(_s[i-1][j-1]+mo(mod-1ll*(i-1)*_s[i-1][j]%mod));
		f[i]=1;int tp=false;
		for(int j=0;j<=i;++j){
			if((rd-j)%(i+1)==0&&!tp)
				f[i]=1ll*f[i]*((rd-j)/(i+1))%mod,tp=true;
			else
				f[i]=1ll*f[i]*(rd-j)%mod;
		}
		for(int j=0;j<i;++j)
			f[i]=mo(f[i]+mo(mod-1ll*f[j]*_s[i][j]%mod));
	}
	for(int i=1;i<=k;i+=2)
		f[i]=mo(mod-f[i]);
	int ans=0;
	int all=1;
	for(int i=1;i<=k;++i)
		all=1ll*all*w[i]%mod;
	int pre=0;
	while("Imakf ak ioi"){
		int mn=0x3f3f3f3f,mp=0;
		for(int i=1;i<=k;++i)
			if(pn[i]<p[i]&&num[i][pn[i]+1]<mn)
				mn=num[mp=i][pn[i]+1];
		if(!all||mn>=0x3f3f3f3f){
			ans=mo(ans+1ll*(n-pre)*all%mod);
			pre=n;break;
		}
		ans=mo(ans+1ll*(mn-pre)*all%mod);
		all=1ll*all*power(w[mp]-pn[mp],mod-2)%mod;
		++pn[mp];all=1ll*all*(w[mp]-pn[mp])%mod;
		pre=mn;
	}
	dp[0]=1;
	for(int i=1;i<=k;++i){
		cn[i]=w[i]-p[i];pn[i]=0;
		for(int j=i;j>=1;--j)
			dp[j]=mo(1ll*dp[j]*s[i]%mod+1ll*dp[j-1]*cn[i]%mod);
		dp[0]=1ll*dp[0]*s[i]%mod;
	}
	pre=0;
	while("Imakf ak ioi"){
		int mn=0x3f3f3f3f,mp=0;
		for(int i=1;i<=k;++i)
			if(pn[i]<s[i]&&sum[i][pn[i]+1]<mn)
				mn=sum[mp=i][pn[i]+1];
		int add=0;
		for(int i=0;i<=k;++i)
			add=mo(add+1ll*dp[i]*f[k-i]%mod);
		if(mn>=0x3f3f3f3f){
			ans=mo(ans+1ll*(n-pre)*add%mod);
			pre=n;break;
		}
		ans=mo(ans+1ll*(mn-pre)*add%mod);
		++pn[mp];int I=power(cn[mp],mod-2);
		for(int i=k;i>=1;--i)
			dp[i]=1ll*mo(mod-1ll*dp[i+1]*s[mp]%mod+dp[i])*I%mod;
		--cn[mp];
		for(int i=1;i<=k;++i)
			dp[i]=mo(1ll*dp[i]*cn[mp]%mod+1ll*dp[i+1]*s[mp]%mod);
		pre=mn;
	}
	all=1;
	for(int i=1;i<=k;++i){
		w[i]-=(p[i]+rd*s[i]);
		all=1ll*all*w[i]%mod;
		if(s[i]&&w[i]<=s[i])
			s[i]=w[i];
		pn[i]=0;
	}
	pre=0;
	while("Imakf ak ioi"){
		int mn=0x3f3f3f3f,mp=0;
		for(int i=1;i<=k;++i)
			if(pn[i]<s[i]&&sum[i][pn[i]+1]<mn) 
				mn=sum[mp=i][pn[i]+1];
		if(!all||mn>=0x3f3f3f3f)break;
		ans=mo(ans+1ll*(mn-pre)*all%mod);//puts("ok");
		all=1ll*all*power(w[mp]-pn[mp],mod-2)%mod;
		++pn[mp];all=1ll*all*(w[mp]-pn[mp])%mod;
		pre=mn;
	}
	write(ans),pc('\n');
	return 0;
}
```







---

## 作者：MCAdam (赞：6)

以后面的数据范围来看，我们不能去枚举这一维平面上的每个点

不妨反过来考虑，计算每一个操作作为最后一步操作的点数

显然只需要考虑这一步操作影响的维度，然后最后才去计算对所有维度的贡献

设$l_t(i),r_t(i)$表示在$t$这个维度上经过了$i$步后还没有离开这个维度的点的范围，其中$1\leq l_t(i)\leq r_t(i)\leq w_t$

显然最先离开某个维度的点肯定是在边上的，所以在每一步操作后这个区间只有可能缩小，并且只会缩小一个点（左边界或者右边界）或者不缩小

为了方便，把这些能够使区间缩小的操作称之关键操作

所以一步一步进行下去，每一步可以快速找出离开的点，并求出其贡献：

如果在第$i$步在$c_i$维度使其区间缩小了，那么其贡献为：$\displaystyle i\times \prod_{j\neq c_i}(r_j(i)-l_j(i)+1)$

也就是从这每个维度的区间中挑出一个点构成的$k$维点都需要走$i$步才能离开

这样只需要枚举每一步直到每个维度的区间都缩为$0$就可以计算出答案了

然后容易想到，每一轮操作都是循环的，考虑到有以下性质：

- 如果第$i$步不是关键的，那么第$i+a\times n$都不是关键的

- 如果第$i$步是关键的，那么第$i+a\times n$不一定是关键的

- 如果第$i$步和第$i+n$步都是关键的，那么第$i+a\times n(a>1)$都是关键的

挺显然的，关键就是要考虑一轮的变化。有了这些结论就可以统一去计算关键步数的贡献了

首先找到第二轮中的关键步数，这样既可以统一计算后面轮数的贡献了

- 设一轮操作后第$t$的位移为$v_i$，那么每一轮操作后区间都会缩$|v_i|$

所以第$i$步操作（$n<i\leq 2n$）在第$a$论操作的贡献是：

$\displaystyle i+(a-2)n\prod_{j\neq c_i}(r_j(i)-l_j(i)+1-(a-2)|v_j|)$

时间复杂度$O(n\times k\times \max\{w_i\})$

这样就能够得到$80$分的好成绩

慢就慢在要枚举这个$a$上，考虑能不能也处理掉？

观察这个式子，其实就是$k$个$a$的一次二项式相乘得到

可以使式子偏移一下，使得$a$的范围为$[0,lim],i\in[1,n]$

设$f_i(a)=\displaystyle i+(a+1)n\prod_{j\neq c_i}(r_j(i+n)-l_j(i+n)+1-a|v_j|)=\sum_{j=0}^{k}b_i[j]a^j$

其系数可以直接暴力把这$k$个多项式卷起来得到

那么要求的就是$\displaystyle \sum_{a=0}^{lim}f_i(a)=\sum_{a=0}^{\lim}\sum_{j=0}^{k}b_i[j]a^j=\sum_{j=0}^{k}b_i[j]\sum_{a=0}^{lim}a^j$

然后最后的问题就是快速计算后面的自然数幂和了，用斯特林数或者拉格朗日插值都可以$O(k^2)$计算出来，代码中用了第二类斯特林数

最后总的时间复杂度$O(nk^2)$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
using namespace std;
const int N=5e5+10,M=12,INF=1e9+10;
const int mod=1e9+7;
int n,k;
int w[M],pos[N],dir[N],l[M],r[M],stp[M],s[M],S[M][M],inv[M],b[M];
inline bool check_cir()
{
	int maxn[M],minn[M];
	for(int i=1;i<=k;i++) 
		stp[i]=maxn[i]=minn[i]=0;
	for(int i=1;i<=n;i++)
	{
		stp[pos[i]]+=dir[i];
		maxn[pos[i]]=max(maxn[pos[i]],stp[pos[i]]);
		minn[pos[i]]=min(minn[pos[i]],stp[pos[i]]);
	}
	for(int i=1;i<=k;i++)
		if(1-minn[i]>w[i]-maxn[i]||stp[i]) return false;
	return true;
}
inline int calc(int lim,int idx)
{
	int fac=lim+1,ans=0;
    for(int i=0;i<=idx;i++)
    {
        ans=(ans+1ll*S[idx][i]*fac%mod*inv[i+1]%mod)%mod;
        fac=1ll*fac*(lim-i)%mod;
    }
    return ans;
}
int main()
{
	int ans=0;
	scanf("%d%d",&n,&k);
	S[0][0]=1;
	for(int i=1;i<=k+1;i++)
	  for(int j=1;j<=i;j++)
		S[i][j]=(S[i-1][j-1]+1ll*S[i-1][j]*j%mod)%mod;
	inv[1]=1; for(int i=2;i<=k+1;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=1;i<=k;i++) 
		scanf("%d",&w[i]);
	for(int i=1;i<=n;i++) 
		scanf("%d%d",&pos[i],&dir[i]);
	if(check_cir()){ printf("-1\n"); return 0; }
	for(int i=1;i<=k;i++) 
		l[i]=1,r[i]=w[i],stp[i]=0;
	for(int i=1;i<=n;i++)
	{
		if(l[pos[i]]>r[pos[i]]) continue;
		int flag=0,res=1;
		stp[pos[i]]+=dir[i];
		if(r[pos[i]]+stp[pos[i]]>w[pos[i]]) r[pos[i]]--,flag=1;
		if(l[pos[i]]+stp[pos[i]]<1) l[pos[i]]++,flag=1;
		if(flag^1) continue;
		for(int j=1;j<=k;j++)
			if(j^pos[i]) res=1ll*res*(r[j]-l[j]+1)%mod;
		ans=(ans+1ll*res*i%mod)%mod;
	}
	for(int i=1;i<=k;i++)
		s[i]=(stp[i]>0?stp[i]:-stp[i]);
	for(int i=1;i<=n;i++)
	{
		if(l[pos[i]]>r[pos[i]]) continue;
		int flag=0,lim=INF;
		stp[pos[i]]+=dir[i];
		if(r[pos[i]]+stp[pos[i]]>w[pos[i]]) r[pos[i]]--,flag=1;
		if(l[pos[i]]+stp[pos[i]]<1) l[pos[i]]++,flag=1;
		if(flag^1) continue;
		for(int j=1;j<=k;j++)
			if(s[j]) lim=min(lim,(r[j]-l[j]+1<0)?-1:(r[j]-l[j]+1)/s[j]);
		memset(b,0,sizeof(b));
		b[0]=i+n,b[1]=n;
		for(int j=1;j<=k;j++)
		{
			if(j==pos[i]) continue;
			int zero=r[j]-l[j]+1,one=mod-s[j];
			for(int t=k;t>=0;t--)
			{
				if(t>=0) b[t]=1ll*b[t]*zero%mod;
				if(t>=1) b[t]=(b[t]+1ll*b[t-1]*one%mod)%mod;
			}
		}
		for(int j=0;j<=k;j++)
			ans=(ans+1ll*b[j]*calc(lim,j)%mod)%mod;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：OIerAlbedo (赞：5)

## Introduction

傻逼卡常题。

## Solution

### Part 1 

我们要求的是每一个坐标最多可以走多少步，我们发现这个东西极难维护，但是我们可以把问题转化一下，变成走 $ x $ 步的时候，有哪些坐标还合法，这样我们只要每个 $ x $ 所对应的值加起来就好了。

### Part 2

那么我们首先可以得出一个暴力的做法，就是我们每走一步，计算每个维度最多会增加多少，记为 $ up $，最多会减少多少，记为 $ down $。那么这一次的答案就是 $ \prod_{i=1}^{k} (w_i-up_i-down_i) $ ，然后知道存在一个 $ i $ 满足 $ w_i-up_i-down_i\ge 0 $，退出，因为没有办法走了，这时候我们已经有了做出此题的基础。

### Part 3

我们发现走路是会循环的，我们假设最开始的一轮为第 $ 0 $ 轮，那么假设现在是第 $ fre $ 轮多了 $ G $ 步，我们怎么推出那个 $ up_i $ 和 $ down_i $ 呢？

我们记一轮的每一维整体走的为 $ row_i $，那么我们考虑分类讨论。

- 如果 $ row_i $ 大于 $ 0 $，那么每一轮这一维整体是向前走的，而向前走的最大值可能诞生在这一轮，那么 $ up $ 就是 $ up_{G,i}+row_i\times fre $，但是最大值也有可能是在上一轮，这是的答案就是 $ upmax_i+row_i\times (fre-1) $，而我们发现因为整体向前，所以 $ downmax $ 是不会变的。

- 同时 $ row_i $ 小于 $ 0 $ 的也是同理，只是 $ up $ 和 $ down $ 的顺序换了一下。

  我们记我们刚才算出的答案减去 $ row_i\times fre $ 是 $ ccf_{G,i} $ 。

  然后我们可以发现，对于 $ (fre,G) $ 如果他们的 $ G $ 是相同的，那么他们其实就都相差了一个 $ row[i]\times fre $，那么我们要满足的就是 $ ccf_{G,i}+row_i\times fre\ge 1 $。那么我们就可以算出，在 $ G $ 相同时 $ fre $ 的最大值。

  然后考虑枚举这个 $ fre $，那么答案就是:
  $$
  \sum_{i=1}^{fre}\prod_{j=1}^{k} (ccf_{i,j}-row_i\times fre)
  $$

### Part 4

 我们考虑展开上面的式子：

```
ccf[i][1]-row[1]*fre
(ccf[i][1]-row[1]*fre)*(ccf[i][2]-row[2]*fre)=ccf[i][1]*ccf[i][2]-row[1]*ccf[i][2]-row[2]*ccf[i][1]+row[1]*row[2]*fre*fre
```

然后就可以发现我们的答案总是 $ fre^x $ 乘上一个系数，那么我们就要算出这个系数，而我们发现 $ -row_i $ 带了 $ 1 $ 个 $ fre $，$ ccf_{i,j} $ 带了 $ 0 $ 个 $ fre $，那我们就可以考虑 $ Rg_{i,j} $ 表示前 $ i $ 个选择中选了 $ j $ 个 $ -row_i $，$ i-j $ 个 $ ccf_{i,j} $，那么我们就可以发现，$ Rg_{k,j} $ 就是  $ fre^j $ 的系数。然后这道题的问题就只剩下了一个，如何计算下面的式子：
$$
\sum_{i=1}^{n} fre^x
$$
我们发现题目中给了两档部分分，那么 $ w_i $ 小的哪一个部分分，我们可以直接暴力预处理，而 $ w_i $ 那个点直接套用公式即可。

## Code

```c++
long long calc1(long long x){return x*(x+1) % MOD*inv2 % MOD;}
long long calc2(long long x){return x*(x+1) % MOD*(2*x+1) % MOD*inv6 % MOD;}
long long calc3(long long x){return x*(x+1) % MOD*inv2 % MOD*x % MOD*(x+1) % MOD*inv2 % MOD;}
long long calc4(long long x){return x*(x+1) % MOD*inv2 % MOD*x % MOD*(x+1) % MOD*inv2 % MOD;}
int main() {
	//freopen("testdata.in","r",stdin);
	//freopen("ans.out","w",stdout);
	cin>>n>>K;fst=1;MOD=1e9+7;
    for (i=1;i<=K;i++) cin>>id[i],fst=fst*id[i] % MOD;
	for (now=1;now<=n;now++)
	    {
	    	if (now<=n) cin>>L>>R,LL[now]=L,RR[now]=R;
	    	else LL[now]=LL[(now-1) % n+1],RR[now]=RR[(now-1) % n+1];
	    	L=LL[now];R=RR[now];
	    	row[L]+=R;
	    	if (row[L]>0) up[L]=max(up[L],row[L]);else down[L]=min(down[L],row[L]);
	    	for (j=1;j<=K;j++) U[now][j]=up[j],D[now][j]=down[j];
	    	fuc=1;
	    	for (i=1;i<=K;i++)
	    	     {
	    	     	len=id[i]-U[now][i]+D[now][i];
	    	     	F[i]=len;
	    	     	if (len<0) fuc=0;
	    	     	else fuc*=len;
	    	     	fuc%=MOD;
				 }
			if (fuc==0) break;
			fst+=fuc;fst%=MOD;
		 } 
	if (fuc==0) {cout<<fst<<endl;return 0;}
			     	flag=true;
			     	for (i=1;i<=K;i++)
			     	   if (row[i]!=0) flag=false;
			     	if (flag)
			     	    {
			     	    	cout<<-1<<endl;return 0;
						 }
	//row[j]>0-->id-(row[j]*fre+up[i][j])+down[j];id-(row[j]*(fre-1)+up[j])+down[j]
	//id-row[j]*fre+row[j]-up[j]+down[j]>=1
	//id-row[j]*fre-up[i][j]+down[j]>=1
	//
	//row[j]<0-->id-(up[j])+(D[i][j]+row[j]*fre)>=1
	//id-up[j]+D[i][j]-1>=-row[j]*fre
	//id-up[j]+(down[j]+row[j]*(fre-1))>=1
	//id-up[j]+down[j]+row[j]*fre-row[j]>=1
	//id-
	for (i=1;i<=n;i++)
	   for (j=1;j<=K;j++)
	      if (row[j]>0) ccf[i][j]=min(id[j]+row[j]-up[j]+down[j],id[j]-U[i][j]+down[j]);
	else ccf[i][j]=min(id[j]-up[j]+D[i][j],id[j]-up[j]+down[j]-row[j]);
	for (i=1;i<=K;i++) row[i]=abs(row[i]);
//	cout<<ccf[1][1]<<" "<<ccf[2][1]<<" "<<ccf[3][1]<<" "<<ccf[4][1]<<" "<<ccf[5][1]<<endl;
	//cout<<row[1]<<endl;
	inv6=166666668;inv2=500000004;
	//ccf[i][j]>0
	//fre个整轮，第G步,ccf[G][j]-row[j]*fre
	//fre max可以轻松算出
	//ccf[G][1]-row[1]*fre>=1
	//ccf[G][1]-1>=row[1]*fre
	//F[1]-row[1]*(fre-1)>=1
	//F[1]-row[1]*fre+row[1]>=1
	//F[1]+row[1]-1>=row[1]*fre
	//ccf[G][1]-row[1]*0+ccf[G][1]-row[1]*1
	//(ccf[G][1]-row[1]*fre)*(ccf[G][2]-row[2]*fre)=(ccf[G][1]*ccf[G][2]-ccf[G][1]*row[2]*fre-ccf[G][2]*row[1]*fre+row[1]*row[2]*fre*fre)*(ccf[G][3]-row[3]*fre)
	//
	//(ccf[G][1]
	for (i=1;i<=1000000;i++) val[i]=Mul(Mul(i,i),Mul(i,i));
	for (j=4;j<=10;j++)
	    for (i=1;i<=1000000;i++)
	         {
	         	pre[j][i]=Add(pre[j][i-1],val[i]);
	         	val[i]=Mul(val[i],i);
			 }
	for (G=1;G<=n;G++)
	     {
	     	fre=1e9;
	     	for (i=1;i<=K;i++) 
	     	   if (row[i]!=0) fre=min(fre,(ccf[G][i]-1)/row[i]);
	       Rg[0][0]=1;//R[i][j]表示前i个数选择j个-row产生的总贡献 
	       for (i=1;i<=K;i++)
	             {
	             	Rg[i][0]=Rg[i-1][0]*ccf[G][i] % MOD;
	             	for (j=1;j<=i;j++)
	             	    {
	             	    	Rg[i][j]=Rg[i-1][j]*ccf[G][i] % MOD;
	             	    	Rg[i][j]=(Rg[i][j]+Rg[i-1][j-1]*(-row[i]+MOD) % MOD) % MOD;
						 }
				 }
	       /* for (j=1;j<=fre;j++)
	            {
	            	GG=1;
	            	for (k=1;k<=K;k++)
	            	   GG=GG*(ccf[G][k]-row[k]*j) % MOD;
	                fst+=GG;fst%=MOD;
				}*/
	        if (K==2)
	          {
	          	fst+=Rg[K][0]*fre;fst%=MOD;
	          	fst+=Rg[K][1]*calc1(fre);fst%=MOD;
	          	fst+=Rg[K][2]*calc2(fre);fst%=MOD;
			  }
			if (K==1) 
	        {
	        	fst+=Rg[K][0]*fre;fst%=MOD;
	        	fst+=Rg[K][1]*calc1(fre);fst%=MOD;
			}
		if (K==3)
		    {
	          	fst+=Rg[K][0]*fre;fst%=MOD;
	          	fst+=Rg[K][1]*calc1(fre);fst%=MOD;
	          	fst+=Rg[K][2]*calc2(fre);fst%=MOD;
	          	fst+=Rg[K][3]*calc3(fre);fst%=MOD;
			}
		if (K==4)
		   { 
	          	fst+=Rg[K][0]*fre;fst%=MOD;
	          	fst+=Rg[K][1]*calc1(fre);fst%=MOD;
	          	fst+=Rg[K][2]*calc2(fre);fst%=MOD;
	          	fst+=Rg[K][3]*calc3(fre);fst%=MOD;
	          	fst+=Rg[K][4]*calc4(fre);fst%=MOD;
		   }
		 }
	cout<<fst<<endl;
```



---

## 作者：Leasier (赞：4)

前置芝士：[拉格朗日插值](https://oi-wiki.org/math/poly/lagrange/)

设 $\Delta_{i, j}, \Delta{\operatorname{neg}}_{i, j}, \Delta{\operatorname{pos}}_{i, j}$ 表示第一个周期的第 $i$ 步走完后在第 $j$ 维中的位移、向负方向走的最大位移（为了方便，我们让 $\Delta{\operatorname{neg}}_{i, j}$ 为非负数）和向正方向走的最大位移。

首先判掉无解的情况。若 $\forall 1 \leq i \leq k, \Delta_{n, i} = 0, \Delta{\operatorname{neg}}_{n, i} + \Delta{\operatorname{pos}}_{n, i} \leq w_i$，则存在一个位置，使得可以一直走下去，此时无解。

注意到题目中刚好走出场地的一步是要考虑的，不妨将答案加上 $P$ 后转化为在场地内的步数之和。

直接考虑每个起点的贡献是没法去掉时间复杂度中的 $P$ 的，不妨转而考虑能走完第 $j$ 周期的第 $i$ 步的起点数量之和，其中 $1 \leq i \leq n$，$j \geq 1$。

容易发现每一维之间互不影响，设 $f(i, j, x)$ 表示第 $x$ 维中的上述结果，则答案为 $\displaystyle\sum_{i = 1}^n \sum_{j = 1} \prod_{x = 1}^k f(i, j, x)$。现在问题转化为求出 $f(i, j, x)$ 的表达式。

1. $j = 1$

容易发现此时 $f(i, j, x) = \max(w_x - \Delta{\operatorname{pos}}_{i, x} - \Delta{\operatorname{neg}}_{i, x}, 0)$。

2. $j > 1$

此时我们对 $\Delta_{n, i}$ 的符号分类讨论。

- $\Delta_{n, x} < 0$

容易发现，此时一个合法的坐标 $y$ 需要满足以下条件。

- $y + \Delta{\operatorname{pos}}_{n, x} \leq w_x$
- $y + \Delta_{n, x}(j - 2) - \Delta{\operatorname{neg}}_{n, x} \geq 1$
- $y + \Delta_{n, x}(j - 1) - \Delta{\operatorname{neg}}_{i, x} \geq 1$

整理后可得：$1 - \Delta_{n, x}(j - 2) + \min(\Delta{\operatorname{neg}}_{n, x}, \Delta{\operatorname{neg}}_{i, x} - \Delta_{n, x}) \leq y \leq w_x - \Delta{\operatorname{pos}}_{n, x}$。

据此我们可以求出合法 $y$ 的个数为 $f(i, j, x) = \max(w_x + \Delta_{n, x}(j - 2) - \Delta{\operatorname{pos}}_{n, x} - \min(\Delta{\operatorname{neg}}_{n, x}, \Delta{\operatorname{neg}}_{i, x} - \Delta_{n, x}), 0)$。

为了避免 $\max$ 带来的问题，我们需要给 $j$ 规定范围。下同。

容易发现，这是一个关于 $j$ 的一次函数。

- $\Delta_{n, x} = 0$

容易发现，此时一个合法的坐标 $y$ 需要满足以下条件。

- $y - \Delta{\operatorname{neg}}_{n, x} \geq 1$
- $y + \Delta{\operatorname{pos}}_{n, x} \leq w_x$

整理后可得：$\Delta{\operatorname{neg}}_{n, x} + 1 \leq y \leq w_x - \Delta{\operatorname{pos}}_{n, x}$。

据此我们可以求出合法 $y$ 的个数为 $f(i, j, x) = \max(w_x - \Delta{\operatorname{pos}}_{n, x} - \Delta{\operatorname{neg}}_{n, x}, 0)$。

容易发现，这是一个关于 $j$ 的常函数。

- $\Delta_{n, x} > 0$

容易发现，此时一个合法的坐标 $y$ 需要满足以下条件。

- $y - \Delta{\operatorname{neg}}_{n, x} \geq 1$
- $y + \Delta_{n, x}(j - 2) + \Delta{\operatorname{pos}}_{n, x} \leq w_x$
- $y + \Delta_{n, x}(j - 1) + \Delta{\operatorname{pos}}_{i, x} \leq w_x$

整理后可得：$\Delta{\operatorname{neg}}_{n, x} + 1 \leq y \leq w_x - \Delta_{n, x}(j - 2) - \max(\Delta{\operatorname{pos}}_{n, x}, \Delta_{n, x} + \Delta{\operatorname{pos}}_{i, x})$。

据此我们可以求出合法 $y$ 的个数为 $f(i, j, x) = \max(w_x - \Delta_{n, x}(j - 2) - \max(\Delta{\operatorname{pos}}_{n, x}, \Delta_{n, x} + \Delta{\operatorname{pos}}_{i, x}) - \Delta{\operatorname{neg}}_{n, x}, 0)$。

容易发现，这是一个关于 $j$ 的一次函数。

综上，$\displaystyle\prod_{x = 1}^k f(i, j, x)$ 是一个关于 $j$ 的不超过 $k$ 次的多项式，于是其前缀和为一个关于 $j$ 的不超过 $k + 1$ 次的多项式。

在排除前面特判的 $j = 1$ 的情况后对其前缀和拉格朗日插值即可。时间复杂度为 $O(nk^2)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int mod = 1e9 + 7;

typedef struct Line_tag {
	int a;
	int b;
	
	Line_tag(){}
	
	Line_tag(int a_, int b_){
		a = a_;
		b = b_;
	}
	
	inline ll calc(int x){
		return ((ll)a * x + b) % mod;
	}
} Line;

int w[17], c[500007], d[500007], delta[500007][17], delta_neg[500007][17], delta_pos[500007][17];
ll fac[17], inv_fac[17], b[17], y[17], pre[17], suf[17];
Line line[17];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int n){
	fac[0] = 1;
	for (register int i = 1; i <= n; i++){
		fac[i] = fac[i - 1] * i % mod;
	}
	inv_fac[n] = quick_pow(fac[n], mod - 2, mod);
	for (register int i = n - 1; i >= 0; i--){
		inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
	}
	for (register int i = 0; i <= n; i++){
		b[i] = inv_fac[i] * inv_fac[n - i] % mod;
		if ((n - i) % 2 != 0) b[i] = (mod - b[i]) % mod;
	}
}

inline int read(){
	int sign = 1, ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		if (ch == '-') sign = -sign;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return sign * ans;
}

inline int max(int a, int b){
	return a > b ? a : b;
}

inline int min(int a, int b){
	return a < b ? a : b;
}

inline ll calc(int k, int x){
	ll ans = 1;
	for (register int i = 1; i <= k; i++){
		ans = ans * line[i].calc(x) % mod;
	}
	return ans;
}

inline ll lagrange(int n, ll y[], int k){
	ll ans = 0;
	for (register int i = 0; i <= n; i++){
		pre[i] = suf[i] = ((k - i) % mod + mod) % mod;
		if (i > 0) pre[i] = pre[i] * pre[i - 1] % mod;
	}
	for (register int i = n - 1; i >= 0; i--){
		suf[i] = suf[i] * suf[i + 1] % mod;
	}
	for (register int i = 0; i <= n; i++){
		ll a = 1;
		if (i > 0) a = pre[i - 1];
		if (i < n) a = a * suf[i + 1] % mod;
		ans = (ans + y[i] * a % mod * b[i] % mod) % mod;
	}
	return ans;
}

int main(){
	int n = read(), k = read();
	bool flag = true;
	ll ans = 1;
	for (register int i = 1; i <= k; i++){
		w[i] = read();
		ans = ans * w[i] % mod;
	}
	for (register int i = 1; i <= n; i++){
		c[i] = read();
		d[i] = read();
	}
	for (register int i = 1; i <= n; i++){
		for (register int j = 1; j <= k; j++){
			delta[i][j] = delta[i - 1][j];
			delta_neg[i][j] = delta_neg[i - 1][j];
			delta_pos[i][j] = delta_pos[i - 1][j];
		}
		delta[i][c[i]] += d[i];
		if (delta[i][c[i]] < 0){
			delta_neg[i][c[i]] = max(delta_neg[i][c[i]], -delta[i][c[i]]);
		} else if (delta[i][c[i]] > 0){
			delta_pos[i][c[i]] = max(delta_pos[i][c[i]], delta[i][c[i]]);
		}
	}
	for (register int i = 1; i <= k; i++){
		if (delta[n][i] != 0 || delta_neg[n][i] + delta_pos[n][i] > w[i]){
			flag = false;
			break;
		}
	}
	if (flag){
		printf("-1");
		return 0;
	}
	int ki = k + 1;
	init(ki);
	for (register int i = 1; i <= n; i++){
		int limit = 0x7fffffff;
		ll mul = 1;
		for (register int j = 1; j <= k; j++){
			mul = mul * max(w[j] - delta_pos[i][j] - delta_neg[i][j], 0) % mod;
			if (delta[n][j] < 0){
				line[j] = Line(delta[n][j], w[j] - delta[n][j] * 2 - max(delta_neg[n][j], delta_neg[i][j] - delta[n][j]) - delta_pos[n][j]);
				limit = min(limit, -line[j].b / delta[n][j]);
			} else if (delta[n][j] == 0){
				line[j] = Line(0, max(w[j] - delta_pos[n][j] - delta_neg[n][j], 0));
			} else {
				line[j] = Line(-delta[n][j], w[j] + delta[n][j] * 2 - max(delta_pos[n][j], delta_pos[i][j] + delta[n][j]) - delta_neg[n][j]);
				limit = min(limit, line[j].b / delta[n][j]);
			}
		}
		if (limit > 0){
			for (register int j = 1; j <= ki; j++){
				y[j] = (y[j - 1] + calc(k, j + 1)) % mod;
			}
			ans = (ans + mul + lagrange(ki, y, limit - 1)) % mod;
		}
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Emertyst (赞：4)

# 思路

首先，~~开始你的模拟秀~~ 对于每个点模拟会 T 飞，所以考虑所有点一起走。

设：$x_{i, j} = \displaystyle\sum_{i' = 1}^i d_{i'} [c_{i'} = j]$，即表示走完 $i$ 步第 $j$ 维的位移；$l_{i, j} = \displaystyle\min_{i' = 0}^i \{x_{i', j}\}$，即表示左移的最大位移；$r_{i, j} = \displaystyle\max_{i' = 0}^i \{x_{i', j}\}$，即表示左移的最大位移；$v_i = \displaystyle\sum_{i' = 1}^n d_{i'} [c_{i'} = i]$，即表示完整走完一轮之后第 $i$ 维的位移，${v_i}' = |v_i|$，即位移的绝对值。

可以看出，无解的情况就是任意 $v_i = 0$。

这时，第 $i$ 步之后存活的点数为 $\displaystyle\prod_{j = 1}^k w_j + l_{i, j} - r_{i, j}$；如果总的步数为 $t$ 则答案为 $\displaystyle\sum_{i = 0}^{t - 1} \prod_{j = 1}^k w_j + l_{i, j} - r_{i, j}$。

~~当然现在你还会 T 飞~~

# 一些结论

**-1.每一轮走完之后每一维在这一轮中的位移与下一轮一样。**

~~感性理解一下，不用证明了~~

**0.第 $i$ 轮第 $j + 1$ 步到第 $i + 1$ 轮第 $j$ 步在第 $y$ 维的位移等于 $v_y$。**

第 $i$ 轮第 $j + 1$ 步到第 $i + 1$ 轮第 $j$ 步正好是完整的一轮。

**1.除了第一轮，剩下的所有完整的一轮中第 $i$ 维失效的点数都等于 ${v_i}'$。**

对于第 $i(i \ge 2)$ 轮 $v_y < 0$ 时，对于 $x_{j, y} = l_{in, y}$，由结论 0 ，$x_{j + 1, y} = x_{j, y} - {v_y}', l_{(i + 1)n, y} = x_{j, y} - {v_y}'$，而此时任意 $x_{j, y} \leq r_{in, y}$，因此 $x_{j + 1, y} = x_{j, y} - {v_y}' < r_{in, y}$，也就是说 $l_{(i + 1)n, y} = l_{in, y} - {v_y}', r_{(i + 1)n, y} = r_{in, y}$，这时第 $i + 1$ 轮中第 $y$ 维失效的点数为 $(w_y + l_{in, y} - r{in, y}) - (w_y + l_{(i + 1)n, y} + r_{(i + 1)n, y}) = {v_i}'$。$v_y > 0$ 时同理。

为什么第一轮和其他轮不一样呢？

~~容易看出~~ 如果 $i = 1, v_y < 0$，不满足 $r_{(i + 1)n, y} = r_{in, y}$，$v_y > 0$ 同理。

**2.如果 $v_i < 0$，则只有 $c_j = i, d_j = -1$ 的一步才会有可能使第 $i$ 维的点失效；如果 $v_i > 0$，则只有 $c_j = i, d_j = 1$ 的一步才会有可能使第 $i$ 维的点失效。**

在结论 1 的证明中，对于 $v_y < 0, i \ge 2$，有 $r_{(i + 1)n, y} = r_{in, y}$，所以与位移反向的移动不会使点失效。

**3.如果第 $i(i \ge 2)$ 轮中的第 $j$ 步在 $y$ 维使一个点失效（$y = c_j$），则第 $i + 1$ 轮中的第 $j$ 步也在 $c_j$ 维使一个点失效；如果第 $i$ 轮中的第 $j$ 步在 $c_j$ 维没有使一个点失效，则第 $i + 1$ 轮中的第 $j$ 步也没有在 $c_j$ 维使一个点失效。**

当 $v_j < 0$ 时，如果第 $i(i \ge 2)$ 轮中的第 $j$ 步在 $y$ 维使一个点失效（$y = c_j$）,则 $x_{in + j, y} = l_{in + j - 1, y} - 1$，由结论 0，$x_{(i + 1)n + j, y} = l_{(i + 1)n + j - 1, y} - 1$，于是结论的前一半成立。后一半同理，$x_{in + j, y} > l_{in + j - 1, y} - 1$，由结论 0，$x_{(i + 1)n + j, y} > l_{(i + 1)n + j - 1, y} - 1$。$v_j > 0$ 同理。

# 正解

设 $f_{i, j}$ 为第二轮以后的每一轮的前 $i$ 步后，第 $j$ 维失效的点数。

首先，暴力模拟第一轮和最后不满一轮的步数。令 $a_i = w_i + l_{n, i} - r_{n, i}$，即一轮之后每一维有效的点数；$t = \displaystyle\min_{i = 1}^k \left\{\left\lfloor\dfrac{a_i}{v_i}\right\rfloor\right\}$，即完整的轮数。那么，这 $t$ 轮的答案为：

$$
\begin{aligned}
ans &= \sum_{i = 0}^{t - 1} \sum_{j = 1}^n \prod_{y = 1}^k a_y - i v_y - f_{j, y} \\
&= \sum_{i = 0}^{t - 1} \sum_{j = 1}^n \prod_{y = 1}^k a_y - f_{j, y} - i v_y \\
\end{aligned}
$$

如果以 $i$ 为变量，$a_y - f_{j, y}$为常量， $O(k^2)$ 地展开后面的连乘可以得到一个 $k$ 次多项式，如果令 $y$ 次方项的系数为 $b_{j, y}$（$j$ 与上面公式的含义相同），则：

$$
\begin{aligned}
ans &= \sum_{i = 0}^{t - 1} \sum_{j = 1}^n \sum_{y = 0}^k b_{j, y} i^y \\
&= \sum_{j = 1}^n \sum_{y = 0}^k b_{j, y} \sum_{i = 0}^{t - 1} i^y
\end{aligned}
$$

值得注意的是，需要令 $0^0 = 1$ 才能使变换等价。

这样，问题转化为了求 $f(x, y) = \displaystyle\sum_{i = 1}^y i^x$（由于 $0^0 = 1$，$x = 0$ 的情况需要特殊处理）（[其实就是这个](https://www.luogu.com.cn/problem/CF622F)）。

对于 $f(x)$，$f(0, n) = n, f(1, n) = \dfrac{n(n + 1)}{2}, f(2, n) = \dfrac{n(n + 1)(2n + 1)}{6}$，瞪眼法得 $f(x)$ 是一个 $x + 1$ 次多项式，于是可以考虑使用[拉格朗日插值法](https://www.luogu.com.cn/problem/P4781)解决。

如果 $t - 1 \leq x + 2$，则暴力处理答案，否则使用拉格朗日插值法解决。首先预处理 $f(i, t - 1),(i \leq t + 1)$，再代入公式：

$$
\begin{aligned}
f(x, y) &= \sum_{i = 1}^y i^x \\
&= \sum_{i = 1}^{y + 2} f(x_i) \prod_{i \ne j} \frac{n - x_j}{x_i - x_j} \\
&= \sum_{i = 1}^{y + 2} f(i) \prod_{j = 1,i \ne j}^{y + 2} \frac{n - j}{i - j} \\
&= \sum_{i = 1}^{y + 2} f(i) \frac{\prod_{j = 1,i \ne j}^{y + 2} (n - j)}{\prod_{j = 1,i \ne j}^{y + 2} (i - j)} \\
&= \sum_{i = 1}^{y + 2} f(i) \frac{\prod_{j = 1}^{y + 2} (n - j)}{n - i} \times \frac{(-1)^{y + 2 - i}}{(i - 1)!(y + 2 - i)!} \\
&= \left[\prod_{j = 1}^{y+2} (n - j) \right] \sum_{i = 1}^{y + 2} \frac{(-1)^{y - i} f(i)}{(n - i)(i - 1)!(y + 2 - i)!} \\
\end{aligned}
$$

$f(i, t - 1),(i \leq k)$ 即为所求，时间复杂度 $O(nk^2)$。

# 注意事项

- 计算 $t$ 时，${v_i}' = 0$ 的情况需要特殊处理。

- 处理 $f(i, t - 1)$ 时，只需一次处理完所有的 $f(i, t - 1),(i \leq k)$ 并记录下来，如果枚举 $j, k$ 的时候每一次都插值重新求，则会超时。

- 预处理出阶乘、阶乘逆元，在插值的时候可以直接使用。

# 代码

（代码中 $mov, v$ 数组为题解中的 $x, v'$）

```cpp
#include <cstring>
#include <iostream>
using namespace std;
const int MAXN1 = 15, MAXN2 = 5e5 + 5, MOD = 1e9 + 7;
int inc(int a, int b) { return a + b >= MOD ? a + b - MOD : a + b; }
int dec(int a, int b) { return a < b ? a - b + MOD : a - b; }
int mul(int a, int b) { return 1ll * a * b % MOD; }
int power(int a, int b) {
    int ans = 1;
    for (; b; b >>= 1, a = mul(a, a))
        if (b & 1)
            ans = mul(ans, a);
    return ans;
}
int n, k, t = 0x7f7f7f7f, ans, c[MAXN2], d[MAXN2], l[MAXN1], r[MAXN1];
int f[MAXN2][MAXN1], v[MAXN1], w[MAXN1], x[MAXN1][MAXN1];
int invFac[MAXN1], mov[MAXN1], num1[MAXN1], num2[MAXN1], sum[MAXN1];
bool nice = false;
void init() {
    int fac = 1, temp = 0;
    for (int i = 1; i <= k + 1; ++i)
        fac = mul(fac, i);
    invFac[k + 1] = power(fac, MOD - 2);
    for (int i = k + 1; i; --i)
        invFac[i - 1] = mul(invFac[i], i);
    // 处理阶乘及阶乘逆元
    for (int i = 1; i <= k + 2; ++i)
        for (int j = 0; j <= k; ++j)
            x[i][j] = inc(x[i - 1][j], power(i, j));
    // 处理 x[i][j] = f(j, i)
    sum[0] = t;
    // 特殊处理
    for (int i = 1; i <= k; temp = 0, ++i) {
        if (t <= i + 3)
            sum[i] = x[t - 1][i];
        else {
            for (int j = 1; j <= i + 2; ++j)
                temp = mul(mul(x[j][i], power(t - 1 - j, MOD - 2)), mul(invFac[j - 1], invFac[i - j + 2])),
                sum[i] = inc(sum[i], i - j & 1 ? MOD - temp : temp);
            for (int j = 1; j <= i + 2; ++j)
                sum[i] = mul(sum[i], t - 1 - j);
        }
    }
    // 处理 sum[i] = f(i, t - 1)
}
int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= k; ++i)
        cin >> w[i];
    for (int i = 1; i <= n; ++i)
        cin >> c[i] >> d[i];
    for (int i = 1, temp = 1; i <= n; temp = 1, ++i) {
        for (int j = 1; j <= k; ++j)
            temp = mul(temp, w[j] + l[j] - r[j]);
        ans = inc(ans, temp), mov[c[i]] += d[i], l[c[i]] = min(l[c[i]], mov[c[i]]),
        r[c[i]] = max(r[c[i]], mov[c[i]]);
        if (w[c[i]] + l[c[i]] - r[c[i]] == 0)
            return cout << ans << "\n", 0;
    }
    // 模拟第一轮
    for (int i = 1; i <= k; ++i)
        v[i] = w[i] + l[i] - r[i];
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= k; ++j)
            f[i][j] = f[i - 1][j];
        mov[c[i]] += d[i], f[i][c[i]] += mov[c[i]] > r[c[i]] || mov[c[i]] < l[c[i]],
            l[c[i]] = min(l[c[i]], mov[c[i]]), r[c[i]] = max(r[c[i]], mov[c[i]]);
    }
    // 处理 f[][], v[]
    for (int i = 1; i <= k; ++i)
        v[i] -= w[i] + l[i] - r[i], w[i] += l[i] - r[i] + v[i], nice |= v[i];
    // 将 v[] 恢复成第一轮结束时的 v[]
    // 往下的 w[i] 即为题解中的 a[i]
    if (!nice)
        return cout << "-1\n", 0;
    for (int i = 1; i <= k; ++i)
        t = min(t, v[i] ? w[i] / v[i] : 0x7f7f7f7f);
    if (t) {
        init();
        for (int i = 0; i < n; ++i) {
            memset(num1, 0, sizeof(num1)), num1[0] = 1;
            for (int j = 1; j <= k; ++j) {
                memcpy(num2, num1, sizeof(num1)), memset(num1, 0, sizeof(num1));
                for (int _ = 0; _ < j; ++_)
                    num1[_] = inc(num1[_], mul(num2[_], w[j] - f[i][j])),
                    num1[_ + 1] = inc(num1[_ + 1], mul(num2[_], MOD - v[j]));
            }
            // 多项式乘法
            for (int j = 0; j <= k; ++j)
                ans = inc(ans, mul(num1[j], sum[j]));
        }
        for (int i = 1; i <= k; ++i)
            w[i] -= t * v[i];
    }
    for (int i = 0, temp = 1; true; temp = 1, ++i) {
        for (int j = 1; j <= k; ++j)
            temp = mul(temp, w[j] - f[i][j]);
        if (!temp)
            break;
        ans = inc(ans, temp);
    }
    // 处理最后不满一轮的移动
    cout << ans << "\n";
}
```

---

## 作者：bai_tang (赞：2)

只要有信念，就一定会成功！

### [题意](https://www.luogu.com.cn/problem/P7116)
在 $k$ 维长方体中你规划了一个行进路线，循环往复，直到走出这 $k$ 维长方体，才算走完。

问以这 $k$ 维长方体中的每一个位置为起点，你是否都能走完，如果能，输出你走的步数之和。

### 分析
长方体实在是太大了！如果直接枚举复杂度 $O(w^k)$ 起步十分低效。

因此不难想到应该枚举路径长度，根据每个维度的位移，不仅可以判断是否循环，还可以直接判断有多少个位置可以走这么多步。

但是你发现循环之后可能还有位移，所以步数的上界可达 $O(nw)$，只能写出 $O(nwk)$ 的暴力，[代码](https://www.luogu.com.cn/paste/w6jlv2r7)，可得 $45$ 分，利用逆元或许可以达到 $O(nw)$，但是已经无关紧要。

考虑如何优化，应该严谨地形式化问题，设 $l(i,j)$ 为走 $i$ 步，第 $j$ 维走到的相对最低位置，$r(i,j)$ 为走 $i$ 步，第 $j$ 维走到的相对最高位置，$a_j$ 为走 $n$ 步，第 $j$ 维的位移与 $0$ 取 $\min$，$b_j$ 为走 $n$ 步，第 $j$ 维的位移与 $0$ 取 $\max$。

那么对于走 $m$ 步的情况，如果没有特判得到方案数为 $0$，那么一定有方案数为：
$$F(m)=\prod_{i\ne c_m}(w_i-r(m,i)+l(m,i))$$
而由于走的向量关于 $n$ 循环，则一定有：
$$r(kn+i,j)=(k-1)\cdot b_j+\max(r(i,j)+b_j,r(n,j))$$
$$l(kn+i,j)=(k-1)\cdot a_j+\min(l(i,j)+a_j,l(n,j))$$
而且容易发现，如果走 $n+i$ 步有方案，那么 $i$ 步也一定有其方案贡献，因此设：
$$G(x,y)=\sum_{i=0}^x(in+y)F(in+y)$$
直接暴力算这个可以得到 $80$ 分，令我很疑惑，[代码](https://www.luogu.com.cn/paste/1j2gex5l)。

那么对于单个 $i$ 而言，$F(in+y)$ 可以理解为关于 $i$ 的 $k-1$ 次多项式，而对于 $G(x,y)$ 而言，在 $x$ 为非负整数的时候，可以将 $G(x,y)$ 理解为关于 $x$ 的 $k+1$ 次多项式，因此只需要求出 $x$ 在 $0$ 到 $k+1$ 处的点值即可使用拉格朗日插值插出 $G(x,y)$ 的取值，复杂度为 $O(nk^2)$，[代码](https://www.luogu.com.cn/paste/lgwdhybb)。

---

## 作者：SDNetFriend (赞：2)

## P7116 [NOIP2020] 微信步数 题解

#### 题意这里不再赘述啦

[P7116 [NOIP2020] 微信步数](https://www.luogu.com.cn/problem/P7116)

#### 整体情况

部分借鉴了 OMG_wc 大佬的思路，并在插值处理方面进行了优化，总体复杂度 $O(nk)$。

#### 朴素分析

也是一年前我在考场上的想法，显然这个问题比较关键的两个一个是每轮相对起点每一维偏移了多少，另一个是每一轮相对起点偏移的最大、最小值。

明白了这一点便可以直接 $O(n)$ 预处理出这两个信息，跑完第一轮后求出能跑多少个整轮，最后跑掉散轮。

简单进行优化，可以求出 $f_{i,j}$ 表示第 $i$ 维相对当前轮起点走出 $j$ 的距离的步数是多少，预处理这些之后对于每一个起点我们都可以 $O(1)$ 地得到答案，这样总体复杂度就是 $O(n+w^k)$，期望得分 $40$。

#### 优化暴力

对于 $60$ 分那个点，可以写一个平衡树，暴力枚举第一维，因为最终步数是要在两维里面取最小，所以可以查比第一维步数小的步数和，比第一维步数大的点数，算算复杂度大概是 $O(n+w\log w)$，可以通过。

#### 转换角度

刚才我们一直都是以一种枚举起点的方式进行，那如果继续优化我们就应转为考虑每一步有多少起点可以走这一步，即产生贡献。

我们可以证明，或者说显然地每一步仍然可以走的起点每一维坐标都是一个连续的区间。

假设第 $i$ 维走到当前步左边最多走出去 $l$ 步，右边最多走出去 $r$ 步，那么合法的起点第 $i$ 维坐标一定是在 $[l+1,w_i-r]$ 里面的。

那考虑怎么去算这个东西，我们依旧要利用上文的那两个信息。我们设 $l_i,r_i$ 表示每一轮第 $i$ 维相对起点坐标偏移的最小、最大值。设  $a_i$ 表示每一轮第 $i$ 维相对起点的偏移距离。设 $f_{i,j}$ 表示**当前轮走到第 $i$ 步，第 $j$ 维相对上一轮最小/最大偏移量的偏移距离**。

比较重点就是这个 $f$，因为我们发现除了第 $1$ 轮，每一轮边界都会推出 $a_i$ 的距离，但这个并不是每时每刻都在推，我们就可以存下每一步边界推出去了多少。

并且除了第一轮，每一轮边界推出的方向都是和整体偏移方向一致的。不论怎样每轮都会使当前维区间减小 $|a_i|$，故为了方便计算时 $a_i$ 可以直接取绝对值。

#### 推式子

假设 $w_i$ 表示**处理过第一轮后**合法起点区间的长度，那么我们可以得到这些整轮的贡献为：

$$
\sum_{x=1}^t\sum_{j=1}^n\prod_{i=1}^k w_i-(x-1)a_i-f_{j,i}
$$

其中 $t$ 表示最多可以走多少个整轮，表达式即为 $\min_{i=1}^k \lfloor\frac{w_i}{a_i}\rfloor$。

然后观察式子我们发现这实际上是一个关于 $x$ 的 $k+1$ 次多项式，便可以直接求出 $x$ 为 $0,1,...,k+1$ 时的取值进行拉格朗日插值即可。这里并不需要算多项式乘法并分开考虑每一项，直接一起算就可以了。

#### 算法流程

1. 暴力跑第一轮，更新 $w$ 并求出 $a,l,r,f$。
2. 用拉格朗日插值处理掉剩下可以跑的整轮。
3. 暴力跑掉最后一轮。

#### 贴代码

代码中变量含义与上文基本相同。

```cpp
#include <bits/stdc++.h>
#define lint long long
#define rint register int
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const lint md=1e9+7,K=15,N=5e5+5,inf=1e18;
lint w[K],n,k,c[N],d[N];
lint a[K],l[K],r[K],f[N][K],ans=0;
//走一轮后的相对位置 左右极值点
//f[i][j]第j维在走了i步之后的突破距离
inline bool init(){
	ans=1;
	for(rint i=1;i<=k;++i)
		ans=ans*w[i]%md;
	lint p[K]={0};
	for(rint i=1;i<=n;++i){
		p[c[i]]+=d[i];
		l[c[i]]=min(l[c[i]],p[c[i]]);
		r[c[i]]=max(r[c[i]],p[c[i]]);
		if(r[c[i]]-l[c[i]]<=w[c[i]]){
			lint upd=1;
			for(rint j=1;j<=k;++j)
				upd=upd*(w[j]-(r[j]-l[j]))%md;
			ans+=upd;ans%=md;
		}else return false;
	}
	memcpy(a,p,sizeof a);
	bool flg=false;//特判-1
	for(rint i=1;i<=k;++i){
		if(a[i]){flg=true;break;}
		if(r[i]-l[i]>=w[i])
			{flg=true;break;}
	}
	if(!flg)return ans=-1,false;
	for(rint i=1;i<=n;++i){
		p[c[i]]+=d[i];
		memcpy(f[i],f[i-1],sizeof f[i]);
		if(a[c[i]]>0)
			f[i][c[i]]=max(f[i][c[i]],p[c[i]]-r[c[i]]);
		else if(a[c[i]]<0) 
			f[i][c[i]]=max(f[i][c[i]],l[c[i]]-p[c[i]]);
	}
	for(rint i=1;i<=k;++i)
		w[i]-=r[i]-l[i];
	for(rint i=1;i<=k;++i)
		a[i]=abs(a[i]);
	//第一轮走后的范围,此后每轮都将该维范围缩小a
	return true; 
}
inline lint qpow(lint x,lint y){
	if(y<0)x=qpow(x,md-2),y*=-1;
	lint res=1;
	while(y){
		if(y&1)res=res*x%md;
		x=x*x%md;y>>=1;
	}return res;
}
lint g[K];
inline lint calc(lint x){
	if(x<=k+1)return g[x];
	//暴力拉格朗日插值不进行任何优化 
	lint res=0;
	for(rint i=0;i<=k+1;++i){
		lint upd=g[i];
		for(rint j=0;j<=k+1;++j)
			if(i!=j)
				upd=(upd*(x-j)%md*qpow(i-j,-1)%md+md)%md;
		res+=upd;res%=md;
	}return res;
}
inline void solve(){
	lint t=inf;
	for(rint i=1;i<=k;++i)
		if(a[i])t=min(t,w[i]/a[i]);
	//最多走几个整轮 处理整轮
	/*
	内两层为k次多项式函数
	则整体为k+1次多项式函数
	预处理x为0-k+1的结果,使用拉格朗日插值处理 
	*/
	for(rint x=1;x<=k+1;++x){
		lint sum=0;
		for(rint j=1;j<=n;++j){
			lint upd=1;
			for(rint i=1;i<=k;++i)
				upd=(upd*(w[i]-(x-1)*a[i]%md-f[j][i])%md+md)%md;
			sum+=upd;sum%=md;
		}
		g[x]=(g[x-1]+sum)%md;
	}
	ans+=calc(t);ans%=md; 
	//处理散轮
	for(rint i=1;i<=k;++i)
		w[i]-=t*a[i];
	lint p[K]={0};
	for(rint i=1;i<=n;++i){
		if(f[i][c[i]]<=w[c[i]]){
			lint upd=1;
			for(rint j=1;j<=k;++j)
				upd=upd*(w[j]-f[i][j])%md;
			ans+=upd;ans%=md;
		}else break;
	}
}
int main(){
	n=read();k=read();
	for(rint i=1;i<=k;++i)
		w[i]=read();
	for(rint i=1;i<=n;++i)
		c[i]=read(),d[i]=read();
	if(!init())
		return printf("%lld",ans),0;
	else solve();
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Purslane (赞：1)

# Solution

当时我在考场上貌似只打了 $25$ 分。

首先说一说 $80$ 分做法。

考虑每一维实际上是独立的。因此你对于第 $i$ 维是 $j$ 的情况下可以算出它第一次走出这一维边界所用的时间 $t_{i,j}$。然后考虑对于坐标 $(x_1,x_2,\dots,x_n)$ 它要用的时间是 $\min\{t_{1,x_1},t_{2,x_2},t_{3,x_3},\dots,t_{n,x_n}\}$。因此你可以写成

$$
\sum_{1 \le x_i \le w_i} \min\{t_{1,x_1},t_{2,x_2},t_{3,x_3},\dots,t_{n,x_n}\} 
$$

考虑到这里面没有一个数是重复的，因此你可以枚举哪个数是最小值，乘上其他每一维里面比他大的数的个数的乘积（这个可以排序后用一个指针扫描，而排序可能会带 $\log$，个人觉得 $t_{i}$ 应该是单峰排列的，可以使用归并省去 $\log$ 但是非常难写）。总的复杂度大概是 $O(nk+k \sum w_i)$。没有尝试去写。~~考场上写了这么多就可以去卡常然后跑路了。真希望有这样简单的暴力分。~~

然后尝试去写 $100$ 分的做法。

不妨换一种思路，我们记录每个时刻活下来的人的数量。比如你让第一维在第一秒加一，下一秒能活下来的人就是第一维起始坐标在 $[1,w_1-1]$ 中的人。（特别地，第一秒所有人都活着。）为了方便起见，我们把所有时刻前移一位，就是说让第零秒是所有人都活着，第一秒只有 $[1,w_1-1]$ 中的人活着。下文称每 $n$ 次的循环为一轮，一轮中每一次操作为一局。

考虑一维的增加减少的前缀和，当前最大是 $\alpha$，最小是 $\beta$，那么只有 $[1-\beta,w_i-\alpha]$ 的人活着。考察这个 $\alpha$ 和 $\beta$ 的变化具有周期性。

我们画一个曲线图，记录 $\pm 1$ 的前缀和。我们发现，第二轮的曲线可能和上一轮有重叠，第三轮的曲线也可能和第二轮的曲线有重叠，**但是重叠的部分形状一样！** 也就是说如果第二轮的某一局 $\alpha$ 增加 $1$ 了，在第三轮的同一局 $\alpha$ 也会增加 $1$！（宏观上反映了可供选择的人减少 $1$。）因此我们可以先把第一轮暴力跑掉，然后后面就有周期性了。

> 补充一下为什么不会受到上上轮的影响。比如一轮下来这一维总量是增的，那么我们只会修改最大值；而关心当前前缀和变大的时候有没有已经访问过，我们需要看之前的最大值：之前的最大值其实就是上一轮的最大值，因为上上轮的最大值肯定比上一轮的最大值小。另一种情况同理。

我们可以记录每一轮中每一维 $j$ 在第 $i$ 局时的从这一轮开始已经减少的人数 $\Delta_{i,j}$。然后可以算出来第一次存在一维使得每一个起始坐标都被迫离场的轮数，这一轮之前的我们用某种方式算，这最后零零散散的一轮还是可以暴力算。

再设一局下来第 $i$ 维一共减员 $\delta_i$ 人。那么第 $x$ 轮第 $i$ 局的情况是（假设第一轮暴力之后我们更新了 $w_i$）

$$\prod_{j=1}^k (w_j-(x-1)\delta_j-\Delta_{i,j})$$

我们再对 $i$ 求和。

$$\sum_{i=1}^n \prod_{j=1}^k (w_j-(x-1)\delta_j-\Delta_{i,j})$$

这个东西可以展开成关于 $x$ 的 $k$ 次式（还是可以暴力硬钢），不妨设为 $f(x)=\sum_{i=0}^k a_ix^i$。然后我们再对 $x$ 在 $1$ 到某一上限（设为 $H$）求和。那么我们只需要知道 $\sum_{x=1}^H x^i$ 即可。这个直接拉格朗日插值可以解决问题。

好像，没有那么困难。注意特判 $-1$ 的情况。

> 补充：我在写的时候，发现我们没必要把 $f(x)$ 的解析式求出来。这大抵是一个 $k+1$ 次式（因为每个求和内的都是 $k$ 次，在和一次就是 $k+1$ 次），因此你只需要求出 $f(1,2,\dots,k+2)$ 插值即可。这样非常好写。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10,MOD=1e9+7,MAXK=15;
int n,k,w[MAXN],c[MAXN],d[MAXN],Delta[MAXN][MAXK],delta[MAXK],mn[MAXK],mx[MAXK],val[MAXK];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int f(int x) {
	int ans=0;
	ffor(i,1,n) {
		int mul=1;
		ffor(j,1,k) mul=mul*(w[j]-(x-1)*delta[j]%MOD-Delta[i][j])%MOD;
		ans=(ans+mul)%MOD;
	}
	return ans;
}
int get_val(int mx) {
	int ans=0,sum=0;
	ffor(i,1,k+2) {
		sum=(sum+f(i))%MOD;
		int mul=sum,div=1;
		ffor(j,1,k+2) if(i!=j) mul=mul*(mx-j)%MOD,div=div*(i-j)%MOD;
		mul=mul*qpow(div,MOD-2)%MOD,ans=(ans+mul)%MOD;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k; ffor(i,1,k) cin>>w[i]; ffor(i,1,n) cin>>c[i]>>d[i];
	int ans=1; ffor(i,1,k) ans=ans*w[i]%MOD;
	ffor(i,1,n) {
		val[c[i]]+=d[i];
		if(val[c[i]]>mx[c[i]]) w[c[i]]--,mx[c[i]]=val[c[i]];	
		else if(val[c[i]]<mn[c[i]]) w[c[i]]--,mn[c[i]]=val[c[i]];
		int mul=1;
		ffor(j,1,k) mul=mul*w[j]%MOD;
		if(mul==0) return cout<<ans,0;
		ans=(ans+mul)%MOD;
	}
	ffor(i,1,n) {
		val[c[i]]+=d[i];
		ffor(j,1,k) Delta[i][j]=Delta[i-1][j];
		if(val[c[i]]>mx[c[i]]) Delta[i][c[i]]++,mx[c[i]]=val[c[i]];	
		else if(val[c[i]]<mn[c[i]]) Delta[i][c[i]]++,mn[c[i]]=val[c[i]];
	}
	ffor(i,1,k) delta[i]=Delta[n][i];
	int ed=LONG_LONG_MAX;
	ffor(i,1,k) {
		if(delta[i]==0) continue;
		ed=min(ed,w[i]/delta[i]+(w[i]%delta[i]!=0));	
	}
	if(LONG_LONG_MAX==ed) return cout<<-1,0;
	if(ed-1>0) ans=(ans+get_val(ed-1))%MOD;
	ffor(i,1,k) w[i]=w[i]-delta[i]*(ed-1);
	ffor(i,1,n) {
		ffor(j,1,k) if(Delta[i][j]!=Delta[i-1][j]) w[j]--;
		int mul=1;	
		ffor(j,1,k) mul=mul*w[j]%MOD;
		if(mul==0) return cout<<(ans%MOD+MOD)%MOD,0;
		ans=(ans+mul)%MOD;
	}
	cout<<ans;
	return 0;
}
```

代码中变量名和题解中一致。

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P7116)

---


# 思路：

要求的是步数，其实相当于方案数加权，在它不太好算的情况下我们来考虑算方案数。我们记录某一维已经走过的步往左最多走了 $l$（是负数），往右最多走了 $r$，那么一维暂时不会走出去的位置数量可以表示成可以表示成 $m[i]=w[i]-r[i]+l[i]$，那么这种情况下不会走出去的方案数是：$\sum_{t=0}^{lim}\prod_{i=1}^k m[i]-t\times dt[i]$，其中 $dt[i]$ 是第 $i$ 维经过一轮的变化量，$lim$ 是一个上界表示走了 $lim$ 轮以后再走就出去了，所以只能够枚举到它，现实告诉我们不能枚举轮数，所以必须要优化。从多项式的角度看，我们把轮数当前自变量去推他的多项式：$\sum_{i=0}^k dp[i]\times\sum_{t=0}^{lim} t^i$。

$dp[i]$ 就是把所有 $-dt[i]\times t+m[i]$ 乘起来得到的多项式系数，我们把 $t$ 看作了自变量，但是系数是一定的。求系数可以暴力多项式乘法，后面的那个东西是老套路的。这样就很舒服了，算这个方案数是 $O(k^2)$ 的。

然后我们枚举是第 $i$ 步走了出去，可以用差分，也就是第 $i−1$ 步没有走出去的方案数减去第 $i$ 步走出去的方案数，再乘上 $i$ 就是消耗的步数。

但是还没有考虑大轮的贡献啊，考虑上面我们的计算方式，其本质是前缀和，在第 $i$ 轮走出去的方案数会在 $t\in [0,i)$ 时都被算一遍，所以我们直接算一遍方案数然后乘上 $n$ 就可以了。

第一轮之内是需要单独讨论的，但只是增加了实现的难度，对整体算法影响不大，时间复杂度 $O(nk^2)$

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int M=15;
const int N=500005;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
int n,k,fl=1,inv[M],s[M][M],w[M],a[M],dt[M],ans,c[N],d[N],l[M],r[M],z[M];
int Abs(int x){
	if(x>0){
        return x;
    }
	return -x;
}
int walk(int x,int y){
    z[x]+=y;
    if(l[x]>z[x]||r[x]<z[x]){
        l[x]=min(l[x],z[x]);
        r[x]=max(r[x],z[x]);
        return 1;
    }
    return 0;
}
int cal(int k,int n){
	int sum=0,C=1;
	for(int i=0;i<=k;i++){
		C=C*max(0ll,n-i)%MOD;
		sum=(sum+C*inv[i+1]%MOD*s[k][i])%MOD;
	}
	return sum;
}
int work(){
	int lim=MOD,res=0;
	for(int i=1;i<=k;i++){
		if(dt[i]){
            lim=min(lim,(a[i]+dt[i]-1)/dt[i]);
        }
    }
    int dp[M]={1};
    for(int i=1;i<=k;i++){
        for(int j=i;j>=0;j--){
            dp[j+1]=(dp[j+1]-dt[i]*dp[j])%MOD;
            dp[j]=dp[j]*a[i]%MOD;
        }
    }
    for(int i=0;i<=k;i++){
        res=(res+dp[i]*cal(i,lim))%MOD;
    }
    return res;
}
signed main(){
	cin>>n>>k;
	s[0][0]=inv[0]=inv[1]=1;
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++){
			s[i][j]=(s[i-1][j-1]+s[i-1][j]*j)%MOD;
        }
    }
	for(int i=2;i<=k+1;i++){
		inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
    }
	for(int i=1;i<=k;i++){
        cin>>w[i];
    }
    for(int i=1;i<=n;i++){
        cin>>c[i]>>d[i];
        if(walk(c[i],d[i])&&r[c[i]]-l[c[i]]<=w[c[i]]){
            int x=1;
            for(int j=1;j<=k;j++){
                if(j!=c[i]){
                    x=(x*max(0ll,w[j]-r[j]+l[j]))%MOD;
                }
            }
            ans=(ans+i*x)%MOD;
        }
    }
    for(int i=1;i<=k;i++){
        fl&=(z[i]==0);
        dt[i]=Abs(z[i]);
    }
    if(fl==1){
        for(int i=1;i<=k;i++){
            fl|=(r[i]-l[i]>=w[i]);
        }
        if(fl){
            cout<<-1<<endl;
        }else{
            cout<<ans<<endl;
        }
        return 0;
    }
    for(int i=1;i<=k;i++){
        a[i]=max(0ll,w[i]-r[i]+l[i]);
    }
    ans=(ans+n*work())%MOD;
    for(int i=1;i<=n;i++){
        if(walk(c[i],d[i])&&r[c[i]]-l[c[i]]<=w[c[i]]){
        	fl=1;
			for(int j=1;j<=k;j++){
				if(j!=c[i]){
					fl&=(w[j]-r[j]+l[j]>0);
                }
            }
			if(!fl){
                continue;
            }
            for(int j=0;j<k;j++){
            	if(j!=c[i]){
                    a[j]=max(0ll,w[j]-r[j]+l[j]);
                }
            }
            a[c[i]]=w[c[i]]-r[c[i]]+l[c[i]]+1;
            ans=(ans+i*work())%MOD;
            a[c[i]]=w[c[i]]-r[c[i]]+l[c[i]];
            ans=(ans-i*work())%MOD;
        }
    }
    cout<<(ans+MOD)%MOD<<endl;
    return 0;
}
```
完结撒花~

---

## 作者：Otomachi_Una_ (赞：0)

我都能秒。。。

考虑把所有点向某个方向的行为看成这个场馆往反方向平移。每次操作后答案加上当前剩余的点数。显然没次剩余的点数都应该是一个 $k$ 维立方体。具体的对于第 $t$ 次而言，其中第 $i$ 维长度为 $w_i+\min_{j\leq t} P_{j,i}-\max_{j\leq t} P_{j,i}$，其中 $P_j$ 表示经过 $j$ 次操作后场馆偏移的 $k$ 维向量。如果一次偏移之后某一位长度变为 $0$ 就退出。

至此我们有了一个 $\mathcal O(nkw)$ 的算法，可以获得 $30$ 分左右。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=5e5+5;
const int MOD=1e9+7;
int n,k;
ll le[15],ri[15],now[15],w[15];
ll c[MAXN],d[MAXN];
ll calc(){
	ll ans=1;
	for(int i=1;i<=k;i++) ans=ans*(w[i]-le[i]-ri[i])%MOD;
	return ans;
}
bool allend(){
	for(int i=1;i<=k;i++) if(le[i]+ri[i]>=w[i]) return true;
	return false;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=1;i<=k;i++) cin>>w[i];
	for(int i=1;i<=n;i++)
		cin>>c[i]>>d[i];
	ll sum=calc(),t=0;
	while(1){
		for(int i=1;i<=n;i++){
			now[c[i]]+=d[i];
			le[c[i]]=max(le[c[i]],-now[c[i]]);
			ri[c[i]]=max(ri[c[i]],now[c[i]]);
			if(allend()){cout<<sum%MOD<<endl;return 0;}
			else sum+=calc(); 
		}
		sum%=MOD;
	}
	
}
```

考虑优化。我们发现我们在循环所给的操作很浪费时间，不妨设一次操作后的偏移量所有位都 $\geq 0$（否则给这位所有元素取反）。那么 $\min P_{?,i}$ 在 $n$ 次后是不会变的了，这是因为每次偏移量都加上了 $P_{n,i}\geq 0$，肯定不会更小。

其次，$\max P_{?,i}$ 每 $n$ 次会增大 $P_{n,i}$，即 $\max P_{?,i}=P_{n,i}+\max P_{?-n,i}$。那么你会发现每个 $P_{xn+j,i}$ 都可以写成关于 $x$ 的一次函数。我们要求的是 $n$ 次 $k$ 个 $1$ 次函数的乘积，答案肯定是一个关于 $x$ 的不超过 $k$ 次的多项式。前缀和就是 $k+1$ 次的多项式。

那么做法是很显然的，暴力找出前 $k$ 轮，然后拉格朗日插值得到前 $n$ 的倍数次的和，最后处理余数部分即可。

时间复杂度：$\mathcal O(nk^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=5e5+5;
const int MOD=1e9+7;
int n,k;
ll le[15],ri[15],now[15],w[15];
ll _le[15],_ri[15],_now[15];
ll c[MAXN],d[MAXN];
ll val[15];
ll ksm(ll a,int b){ll res=1;while(b){if(b&1)res=res*a%MOD;a=a*a%MOD,b>>=1;}return res;} 
ll calc(){
	ll ans=1;
	for(int i=1;i<=k;i++) ans=ans*(w[i]-le[i]-ri[i])%MOD;
	return ans;
}
bool allend(){
	for(int i=1;i<=k;i++) if(le[i]+ri[i]>=w[i]) return true;
	return false;
}
bool notend(){
	for(int i=1;i<=k;i++) if(now[i]!=0) return false;
	return true;
}
ll laug(int n,ll x){
	ll sum=0;
	for(int i=0;i<=n;i++){
		ll res=val[i];
		for(int j=0;j<=n;j++) if(i!=j)
			res=res*(x-j+MOD)%MOD*ksm(i-j+MOD,MOD-2)%MOD;
		sum+=res;
	}
	return sum%MOD;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=1;i<=k;i++) cin>>w[i];
	for(int i=1;i<=n;i++)
		cin>>c[i]>>d[i];
	ll sum=calc();
	for(int i=1;i<=n;i++){
		now[c[i]]+=d[i];
		le[c[i]]=max(le[c[i]],-now[c[i]]);
		ri[c[i]]=max(ri[c[i]],now[c[i]]);
		if(allend()){cout<<sum%MOD<<endl;return 0;}
		else sum+=calc(); 
	}
	if(notend()){cout<<"-1";return 0;}
	for(int i=1;i<=k;i++) if(now[i]<0){
		now[i]*=-1;
		for(int j=1;j<=n;j++) if(c[j]==i) d[j]*=-1;
		swap(le[i],ri[i]);
	}
	for(int i=1;i<=k;i++) _le[i]=le[i],_ri[i]=ri[i],_now[i]=now[i];
	val[0]=sum%MOD;
	ll sp=1e18;
	for(int i=1;i<=k;i++) if(now[i]>0) sp=min(sp,(w[i]-le[i]-ri[i])/now[i]);
	for(int i=1;i<=k+1;i++){
		for(int j=1;j<=n;j++){
			now[c[j]]+=d[j];
			le[c[j]]=max(le[c[j]],-now[c[j]]);
			ri[c[j]]=max(ri[c[j]],now[c[j]]);
			if(allend()){cout<<sum%MOD<<endl;return 0;}
			else sum+=calc(); 
		}
		sum%=MOD;
		val[i]=sum%MOD;
	}
	sum=laug(k+1,sp);
	for(int i=1;i<=k;i++){
		le[i]=_le[i];
		ri[i]=_ri[i]+sp*_now[i];
		now[i]=_now[i]*(sp+1);
	}
	for(int i=1;i<=n;i++){
		now[c[i]]+=d[i];
		le[c[i]]=max(le[c[i]],-now[c[i]]);
		ri[c[i]]=max(ri[c[i]],now[c[i]]);
		if(allend()){cout<<sum%MOD<<endl;return 0;}
		else sum+=calc(); 
	}
}

```

---

## 作者：FireBladeMaster (赞：0)

oh 题。

对路径长度求和可以显然转换到对每一步求和，  
考虑有多少位置能走到第 $i$ 步，是 $\prod w_i-(mx_i-mn_i)$，$mx,mn$ 是在这一维走到过的最大和最小位置。

然后这个怎么求和呢？

我们考虑第 $i$ 步和第 $i+n$ 步的那个 $mx-mn$ 的关系，你会发现这个 $mx-mn$ 的变化量恰好是我 $n$ 步在这一维走过的长度 $F$。

那这样你先算出第一轮的答案，后面的第 $x$ 轮就形如 $(\prod L_i-xF_i)$ 这个东西了。

那你把完整的轮数算出来，给他求个和，这样就得到了一个 $O(w+nk^2)$  的算法，过了官方数据但是显然能 hack。

然后你发现这个就是个自然数幂前缀和，预处理下就能把 $w$ 消掉了。

但是还有一部分，因为你最后还有不完整的轮，这个也要算一遍，然后就做完了。

但是我很懒，所以这份代码还是用的暴力自然数幂前缀和。
```cpp
inline int mae(int &a,int b){a+=b;if(a>=mod)a-=mod;return a;}
inline int mle(int &a,int b){a=a*b%mod;return a;}
inline int mxe(int &a,int b){return a=a>b?a:b;}
inline int mne(int &a,int b){return a=a<b?a:b;}
inline int ae(int a,int b){int c=a+b;return c>=mod?c-mod:c;}
inline int de(int a,int b){return ae(a,mod-b);}
inline int me(int a,int b){return a*b%mod;}
int TT[1000005][11],Q[1000005][11],P[11][1000005],C[11][1000005],Cx[11][1000005],Cn[11][1000005],a[1000005],b[1000005],w[10005],mx[102],mn[102],c[105],r[105],poly[16],p2[16],p[16];
signed main()
{
	initprog();
	int n=read(),k=read(),ans=1;
	for(int i=1;i<=k;i++)w[i]=read(),mle(ans,w[i]);
	
	int N=inf;
	for(int i=1;i<=n;i++)
	{
		if(i<=n)a[i]=read(),b[i]=read();
		else a[i]=a[i-n],b[i]=b[i-n];
		for(int d=1;d<=k;d++)
			P[d][i]=P[d][i-1];
		for(int d=1;d<=k;d++)
			C[d][i]=C[d][i-1];
		C[a[i]][i]+=b[i];
		for(int d=1;d<=k;d++)
			Cx[d][i]=max(Cx[d][i-1],C[d][i]),
			Cn[d][i]=min(Cn[d][i-1],C[d][i]);
		c[a[i]]+=b[i];
		mxe(mx[a[i]],c[a[i]]);
		mne(mn[a[i]],c[a[i]]);
		P[a[i]][i]=mx[a[i]]-mn[a[i]];
		int mul=1;
		for(int d=1;d<=k;d++)mle(mul,max(w[d]-P[d][i],0));
		mae(ans,mul);
		if(mul==0)return fprintf(stdout,"%d",ans),0;
	}
	for(int i=1;i<=n;i++)
	{
		memset(poly,0,sizeof(poly));poly[0]=1;
		for(int d=1;d<=k;d++)
		{
			memcpy(p2,poly,sizeof(p2));
			int FF=min(w[d]-P[d][n],w[d]-(
			
			max(c[d]+Cx[d][i],mx[d])-min(c[d]+Cn[d][i],mn[d])
			
			
			));
			if(FF<0)mne(N,0);
			else if(c[d])mne(N,FF/abs(c[d])+1);
			for(int j=0;j<=10;j++)mle(p2[j],FF);
			for(int j=1;j<=10;j++)mae(p2[j],me(poly[j-1],de(0,abs(c[d]))));
			memcpy(poly,p2,sizeof(p2));
		}
		for(int i=0;i<=k;i++)mae(p[i],poly[i]);
	}
	int flag=0;
	if(N==inf)ans=-1,flag=1,N=0;
	for(int i=0;i<N;i++)
	{
		int j=0;
		for(int d=k;d>=0;d--)j=ae(me(i,j),p[d]);
		mae(ans,j);
	}
	if(flag){return odl(ans),0;}
	for(int d=1;d<=k;d++)w[d]-=abs(c[d])*N;
	for(int i=1;i<=n;i++)
	{
		memset(poly,0,sizeof(poly));poly[0]=1;
		int R=1;
		for(int d=1;d<=k;d++)
		{
			int FF=min(w[d]-P[d][n],w[d]-(
			max(c[d]+Cx[d][i],mx[d])-min(c[d]+Cn[d][i],mn[d])
			));
			if(FF<0)
			{
				R=-1;
				break;
			}
			mle(R,FF);
		}
		if(R==-1)break;
		mae(ans,R);
	}
	odl(ans);
	
	return 0;
}
```

---


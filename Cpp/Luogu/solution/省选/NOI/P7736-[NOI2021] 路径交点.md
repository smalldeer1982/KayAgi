# [NOI2021] 路径交点

## 题目描述

小 L 有一个有向图，图中的顶点可以分为 $k$ 层，第 $i$ 层有 $n_i$ 个顶点，第 $1$ 层与第 $k$ 层**顶点数相同**，即 $n_1 = n_k$，且对于第 $j$（$2 \leq j \leq k-1$）层，$n_1 \leq n_j \leq 2n_1$。对于第 $j$（$1 \leq j < k$）层的顶点，以它们为起点的边只会连向第 $j + 1$ 层的顶点。没有边连向第 $1$ 层的顶点，第 $k$ 层的顶点不会向其他顶点连边。

现在小 L 要从这个图中选出 $n_1$ 条路径，每条路径以第 $1$ 层顶点为起点，第 $k$ 层顶点为终点，并要求**图中的每个顶点至多出现在一条路径中**。更具体地，把每一层顶点按照 $1,2,\ldots,n_i$ 进行编号，则每条路径可以写为一个 $k$ 元组 $(p_1,p_2,\ldots,p_k)$，表示这条路径依次经过第 $j$ 层的 $p_j$（$1 \leq p_j \leq n_j$）号顶点，并且第 $j$（$1 \leq j < k$）层的 $p_j$ 号顶点有一条边连向第 $j+1$ 层的第 $p_{j+1}$ 号顶点。

小 L 把这些路径画在了纸上，发现它们会产生若干个交点。对于两条路径 $P,Q$，分别设它们在第 $j$ 层与第 $j+1$ 层之间的连边为 $(P_j,P_{j+1})$ 与 $(Q_j,Q_{j+1})$，若，

$$(P_j-Q_j)\times(P_{j+1}-Q_{j+1})<0$$

则称它们在第 $j$ 层后产生了一个交点。两条路径的交点数为它们在第 $1, 2,\ldots,k - 1$ 层后产生的交点总数。对于整个路径方案，它的交点数为**两两不同路径间交点数之和**。例如下图是一个 $3$ 条路径，共 $3$ 个交点的例子，其中红色点是交点。

![](https://cdn.luogu.com.cn/upload/image_hosting/pvr0iwkt.png)

小 L 现在想知道有偶数个交点的路径方案数比有奇数个交点的路径方案数多多少个。两个路径方案被视为相同的，当且仅当它们的 $n_1$ 条路径按第一层起点编号顺序写下的 $k$ 元组能对应相同。由于最后的结果可能很大，请你输出它对 $998244353$（一个大质数）取模后的值。

## 说明/提示

**【样例解释 #1】**

偶数个交点的方案有 $2$ 个，奇数个交点的方案有 $1$ 个，所以答案为 $1$。

将下表中路径 $1$ 和路径 $2$ 的方案交换，将会得到相同的方案，例如路径 $1$ 为 $(2, 3, 1)$ 且路径 $2$ 为 $(1, 1, 2)$ 的方案与方案 $1$ 是相同的方案，所以不会被计入答案。

| 路径方案 | 路径 $1$  | 路径 $2$  | 交点总数 |
| :------: | :-------: | :-------: | :------: |
|   $1$    | $(1,1,2)$ | $(2,3,1)$ |   $1$    |
|   $2$    | $(1,2,1)$ | $(2,1,2)$ |   $2$    |
|   $3$    | $(1,2,1)$ | $(2,3,2)$ |   $0$    |

**【样例 #2】**

见附件 `xpath2.in` 与 `xpath2.ans`。

该样例约束与测试点 $7 \sim 8$ 一致。

**【样例 #3】**

见附件 `xpath3.in` 与 `xpath3.ans`。

该样例约束与测试点 $9 \sim 10$ 一致。

**【样例 #4】**

见附件 `xpath4.in` 与 `xpath4.ans`。

该样例约束与测试点 $14 \sim 15$ 一致。

**【数据范围】**

对于所有测试数据：$2 \leq k \leq 100$，$2 \leq n_1 \leq 100$，$1 \leq T \leq 5$。

每个测试点中，保证 $n_1 > 10$ 的数据只有 $1$ 组。

|  测试点编号  | $k=$  | $n_1 \leq$ | 特殊性质 |
| :----------: | :---: | :--------: | :------: |
|  $1 \sim 4$  |  $2$  |    $10$    |    无    |
|  $5 \sim 6$  | $10$  |    $10$    |   A，B    |
|  $7 \sim 8$  | $10$  |    $10$    |    A     |
| $9 \sim 10$  | $10$  |    $10$    |    无    |
| $11 \sim 13$ |  $2$  |   $100$    |    无    |
| $14 \sim 15$ | $100$ |   $100$    |   A，B    |
| $16 \sim 17$ | $100$ |   $100$    |    A     |
| $18 \sim 20$ | $100$ |   $100$    |    无    |

特殊性质 A：对于所有 $i$（$2 \leq i \leq k-1$）满足 $n_i = n_1$。

特殊性质 B：保证路径方案总数至多为 $1$。

## 样例 #1

### 输入

```
1
3
2 3 2
4 4
1 1 
1 2
2 1
2 3
1 2
2 1
3 1
3 2```

### 输出

```
1```

# 题解

## 作者：SSerxhs (赞：40)

先考虑 $k=2$ 的情况．容易发现一条路径（或称为一组匹配）$(i,p_i)$ 对应一个排列 $\{p\}$，那么两条边 $(i,p_i),(j,p_j)~(i<j)$ 有交点等价于 $p_i>p_j$，这说明交点个数等于逆序对数．由于待求的是交点个数为偶数的减去交点个数为奇数的，容易联想到行列式．因此 $k=2$ 时答案即为邻接矩阵行列式的值．

对于 $k>2$ 但 $n_1=n_i=n_k$ 的情况，注意到一个结论：设 $f_i$ 表示第 $i$ 层和第 $i+1$ 层交点数为偶数的方案数，$g_i$ 表示第 $i$ 层和第 $i+1$ 层交点数为奇数的方案数，有 $(f_i-g_i)(f_{i+1}-g_{i+1})=(f_if_{i+1}+g_ig_{i+1})-(f_ig_{i+1}+g_if_{i+1})$，可以发现正好是第 $i$ 层到第 $i+2$ 层的答案（因为偶数依然是正的，奇数依然是负的）．这表明答案即为每层邻接矩阵对应行列式的乘积．

对于一般情况，考虑类似思路合并相邻两层．容易想到将邻接矩阵相乘即可计算第 $i$ 层到第 $i+2$ 层的邻接矩阵．可以画图证明，将两条边缩为一条边后，交点奇偶性不变．故答案即为邻接矩阵依次相乘后所得 $n_1\times n_k$ 矩阵的行列式．从 $n_1=n_k$ 以及上一做法结合结论 $|\mathrm {AB}|=|\mathrm A||\mathrm B|$ 可以看出这一结论十分自然．

```cpp
int cal(int a[][N],register int n)
{
	register int i,j,k,r=1,fh=0,l;
	for (i=1;i<=n;i++)
	{
		for (j=i;j<=n;j++) if (a[j][i]) break;
		if (j>n) return 0;
		if (i!=j) {swap(a[j],a[i]);fh^=1;}
		r=(ll)r*a[i][i]%p;
		k=ksm(a[i][i],p-2);
		for (j=i;j<=n;j++) a[i][j]=(ll)a[i][j]*k%p;
		for (j=i+1;j<=n;j++)
		{
			a[j][i]=p-a[j][i];
			for (k=i+1;k<=n;k++) a[j][k]=(a[j][k]+(ll)a[j][i]*a[i][k])%p;
			a[j][i]=0;
		}
	}
	if (fh) return (p-r)%p;
	return r;
}
char s[N];
int a[N][N],c[N][N],d[N][N],b[N],f[N];
int T,n,m,i,j,k,x,y,z,ans,la,ksiz,ks;
void mul(int n,int m,int l)
{
	int i,j,k;
	for (i=1;i<=n;i++) for (j=1;j<=l;j++) d[i][j]=0;
	for (i=1;i<=n;i++) for (k=1;k<=m;k++) for (j=1;j<=l;j++) d[i][j]=(d[i][j]+(ll)a[i][k]*c[k][j])%p;
	for (i=1;i<=n;i++) for (j=1;j<=m;j++) a[i][j]=0;
	for (i=1;i<=m;i++) for (j=1;j<=l;j++) c[i][j]=0;
	for (i=1;i<=n;i++) for (j=1;j<=l;j++) a[i][j]=d[i][j];
}
int main()
{
	read(T);
	while (T--)
	{
		read(k);
		for (i=1;i<=k;i++) read(b[i]);
		for (i=1;i<k;i++) if (b[i]!=b[i+1]) break;
		memset(a,0,sizeof a);
		memset(c,0,sizeof c);
		read(f,k-1);m=f[1];
		while (m--) read(x,y),a[x][y]=1;n=b[1];
		for (i=2;i<k;i++)
		{
			m=f[i];
			while (m--) read(x,y),c[x][y]=1;
			mul(n,b[i],b[i+1]);
		}
		enter(cal(a,n));
	}
}
```

---

## 作者：ix35 (赞：35)

LGV 引理模板。

大部分 LGV 题的模型中有一个特别的性质：符合要求的匹配只有一组，因此按照匹配的顺序列矩阵求出的就是不交路径数量。

从本题的得分来看，也许有很多人因此并没有真正理解 LGV 原本的描述：

有向无环图 $G$ 中，有点 $a_1,\ldots,a_n$ 和  $b_1,\ldots,b_n$，定义路径组为 $n$ 条 $a_i\to b_j$ 的路径，**这些路径不交**，这 $2\times n$ 个点各在一条路径中，定义其**权值为 $(-1)^{\sigma(p)}$**，其中 $\sigma(p)$ 是 $a_i$ 与 $b_j$ 匹配的排列的逆序对数。

设矩阵 $M$，其中 $M_{i,j}$ 为 $a_i\to b_j$ 路径数量，则 $M$ 的行列式等于所有路径组的权值和。

本题问的无非是第一排的点到最后一排点的路径组权值和，所以我们只需要求出路径数量后套用 LGV 引理的结论即可。

路径数量只需要 $n_1$ 次 BFS 就都可以求出，当然也可以直接递推。

这种做法不需要脑子，考场上 $2$ 分钟就能想出来，而且常数显著小于思想类似的矩阵乘法。

---

## 作者：_LHF_ (赞：17)

# 题解
如果你不会别的什么东西的话……

首先，看到题目，发现可以打一个状压dp，但是转移复杂……

可以先考虑一个简化版的问题：不考虑别的，选出 $n$ 条路径有多少种方案。

但你发现你还是不会做。

说明我们必须利用奇偶差这个条件。

说说我考场上是怎么想出来的吧。

## 1. 观察数据
可以猜到，时间复杂度大致是 $O(n^3k)$ 的。
## 2. 大胆猜想
我们直接暴力做时间复杂度是指数级的，而且也想不到什么优化的办法。

先看特殊性质 A，我们可以发现答案就是相邻两层的转移的奇偶差相乘。

我们现在就是要找一种算法将指数级算法优化到 $O(n^3)$。

于是就自然而然想到了行列式。

确实，行列式也是这样，可是这两个有什么关系呢？

不难发现，我们现在就是要枚举一个排列，然后算一下交点数。

交点数不就是逆序对吗？

啊？你问为什么，画个图就知道了。

于是……咦，这不是行列式吗？

求一下所有相邻的邻接矩阵的行列式，乘起来即可。

恭喜你拿到了75分。
## 3. 推理分析
接下来可以分成两条路来走。

### 第一条
相信大家都知道 $|A|\times|B|=|A\times B|$。

恭喜你，成功猜出结论。

答案就是所有相邻的邻接矩阵乘起来，再求行列式。

不难发现乘完之后还是一个 $n_1\times n_1$ 的矩阵。

### 第二条
我学过容斥原理。

不难发现，所有邻接矩阵乘起来后 $(i,j)$ 位置表示从第 $1$ 层的 $i$ 号点走到第 $k$ 层的 $j$ 号点的总路径数。

我们同样是枚举最后 $i$ 号点走到哪个点了，枚举一个排列。

等等，题目规定了路径不能相交。

其实并不用担心，比如像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/ocy5ahsh.png)

它其实还会被再枚举一次，像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/5hhgx3rc.png)

两次枚举到的排列的逆序对差为 $1$，所以会被减掉，不用担心算重。

---

其实学过LGV引理的同学应该都能看出来吧……

顺便说一下，LGV引理是我昨天刚学的。

最后，祝大家
## NOI2021 RP++

---

## 作者：liuzhangfeiabc (赞：12)

很容易观察到题目考察的内容——交点数的奇偶性——只与两条路径的起点与终点有关系。

更进一步，不妨设这 $n$ 条路径的起点是 $1,2,...,n$ ，终点是 $p_1,...,p_n$ （一个 $1\thicksim n$ 的排列），那么这组路径的交点数的奇偶性就恰好是排列 $p$ 的逆序对个数的奇偶性（或者直接称为排列 $p$ 的奇偶性）。

而“偶排列比奇排列多多少个”这种问题我们再熟悉不过了：行列式！显然，如果 $k=2$ ，那么直接对着邻接矩阵求行列式就是答案。

如果 $k$ 更大？一个简单的想法当然是，如果我求出 $f_{ij}$ 表示从第一层第 $i$ 个点到最后一层第 $j$ 个点的路径条数（容易想到 $f$ 的求法就是把每一层的邻接矩阵乘起来），然后对着这个矩阵做行列式不就完了？

然后你就去写了一发，并且过了看起来人畜无害的几组样例，就在你点击“提交”的一瞬间，突然一个激灵：“要求所有路径在中间不经过重复的顶点”这个条件怎么没用上？

你已经打算重新开始推式子了，再一抬头，“？？？怎么AC了？”（如果你没有不幸被卡常的话）

没错，直接这么做就是对的！接下来我不去讲LGV引理、柯西比内定理之类的东西（说实话我之前也没听说过LGV引理这个东西），我就从直观上描述：

如果我们允许道路在中间节点处交叉，会发生什么？

假设有两条路径，一条从第一层 $x_i$ 连向最后一层 $y_i$ ，另一条从第一层 $x_j$ 连向最后一层 $y_j$ 。两条路径在中间某层某个点 $p$ 处相交。

那么对于任意包含这两条路径的一组路径，一定会有另一组路径与之对应：这两组路径的其他路径完全相同，只有这两条路径不一样——在第二组中，这两条路径在点 $p$ 后互相交换，于是第一条路径从第一层 $x_i$ 连向最后一层 $y_j$ ，第二条路径从第一层 $x_j$ 连向最后一层 $p_i$ 。

容易看出这两组路径的交点数一定一奇一偶（容易证明下列引理：对于任意排列 $p$ ，交换其中任意两个位置之后，排列的奇偶性一定改变）。

于是，我们很容易在所有含有相交路径的路径组之间建立一一配对的关系，从而所有这样的路径组对于答案的贡献会被全部抵消！

想明白这一点，这个题就极其简单了。

顺带一提， [CF167E](http://codeforces.com/problemset/problem/167/E) 跟这道题几乎是一模一样的思路和做法。~~今年NOI怎么这么多原题啊qwq~~

最后说一句，如果你不幸被卡常了，你可以注意到矩阵乘法过程中，每次乘的邻接矩阵的元素只有 $0$ 和 $1$ ，因此你完全不需要每次做乘法就取一次模，而是每做完一次（甚至 $4$ 次其实都可以）矩阵乘法之后整体取一次模。

如果还不行，你可以试试fread读入或者改变枚举顺序（从 $ijk$ 改成 $ikj$ ）之类的，不过这就挺玄学了，而且个人感觉加上取模优化就完全够用了。

复杂度显然是 $O(n^3k)$ 。

代码如下：

```cpp
#include<bits/stdc++.h>
char buf[100000],*buff = buf + 100000;
#define gc ((buff == buf + 100000 ? (fread(buf,1,100000,stdin),buff = buf) : 0),*(buff++))
#define li long long
#define pc putchar
using namespace std;
const int mo = 998244353;
inline int read(){
	int x = 0,c = gc;
	while(c < '0' || c > '9') c = gc;
	while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = gc;
	return x;
}
inline void print(int x){
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
int T,k,n[105],m[105];
struct mtx{
	li a[205][205];
	int x,y;
	inline li* operator [](int x){return a[x];}
	inline mtx(){x = y = 0;memset(a,0,sizeof(a));}
	inline void init(){x = y = 0;memset(a,0,sizeof(a));}
}a[105];
inline mtx operator * (mtx x,mtx y){
	assert(x.y == y.x);
	mtx as;as.x = x.x;as.y = y.y;
	li tmp;
	register int i,j,k;
	for(i = 1;i <= x.x;++i) for(k = 1;k <= x.y;++k){
		tmp = x[i][k];
		for(j = 1;j <= y.y;++j)
			as[i][j] += tmp * y[k][j];
	} 
	for(i = 1;i <= x.x;++i) for(j = 1;j <= y.y;++j) if(as[i][j] > 4e16l) as[i][j] %= mo;
	return as;
}
inline li ksm(li q,li w){
	li as = 1;
	while(w){
		if(w & 1) as = as * q % mo;
		q = q * q % mo;
		w >>= 1;
	}
	return as;
} 
inline li det(mtx x){
	assert(x.x == x.y);
	int n = x.x,i,j,k;
	for(i = 1;i <= n;++i) for(j = 1;j <= n;++j) x[i][j] %= mo;
	li tmp = 1;
	for(i = 1;i <= n;++i){
		if(!x[i][i]){
			for(j = i + 1;j <= n;++j) if(x[j][i]){
				tmp = (mo - tmp) % mo;
				for(k = i;k <= n;++k) swap(x[i][k],x[j][k]);
				break;
			}
		}
		if(!x[i][i]) return 0;
		(tmp *= x[i][i]) %= mo;
		li tp = ksm(x[i][i],mo - 2);
		for(j = i;j <= n;++j) (x[i][j] *= tp) %= mo;
		for(j = i + 1;j <= n;++j){
			tp = x[j][i];
			for(k = i + 1;k <= n;++k) (x[j][k] += mo - x[i][k] * tp % mo) %= mo;
			x[j][i] = 0;
		}
	}
	return tmp;
}
int main(){
	int i,j,u,v;
	T = read();
	while(T--){
		k = read();
		for(i = 1;i < k;++i) a[i].init();
		for(i = 1;i <= k;++i) n[i] = read(),a[i].x = a[i - 1].y = n[i];
		for(i = 1;i < k;++i) m[i] = read();
		for(i = 1;i < k;++i){
			for(j = 1;j <= m[i];++j){
				u = read();v = read();
				a[i][u][v] = 1;
			}
		}
		for(i = 2;i < k;++i) a[1] = a[1] * a[i];
		print(det(a[1]));pc('\n');
	}
	return 0;
}
```

---

## 作者：RioBlu (赞：5)

远闻这个是 ``LGV`` 引理 的模板题

但看到题目后，发现不对劲，怎么还有一个奇怪的限制，怎么还有一个交点个数，还要求偶数个交点减奇数个交点的方案数的个数

想了良久，我们就可以发现，最终的奇偶性只和起点和对应的终点有关

___

大概胡一下：

假设有2个起点走向终点，如图

![](https://cdn.luogu.com.cn/upload/image_hosting/gajnq6f1.png)

似乎不明显？把中间的点划掉！

![](https://cdn.luogu.com.cn/upload/image_hosting/16amtbzu.png)

可以发现，如果两个点产生了偶数个交点，必然起点对应原编号的终点；而奇数个交点，必然起点对应不同编号的终点

三个点的话，发现：逆序对数为奇数，就有奇数个交点，而偶数个交点，就有偶数个交点。往后推，发现这个方法似乎有普适性

所以我们大概来证明一下：

有 $10$ 个如果一个数字（下标） $3$ 对应数字 $7$ ，再来一个数（下标） $4$ 对应 $2$，我们就产生了一个逆序对，而这个就可以运用我们之前研究两个点的思想，如果产生了偶数个交点，那么上面的点还在上面，下面的点还在下面，示意图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ubvzea0s.png)

所以说这两个一定会产生奇数个交点，然后中和一下，要是是奇数个逆序对，就有奇数个交点，偶数个逆序对，就有偶数个交点

___

我们要求：偶数个交点方案数 $-$ 奇数个交点方案数

而此时我们发现这于逆序对奇偶性挂钩，回忆一下 ``LGV`` 引理，似乎也和逆序对奇偶性挂钩！

在本题中，如果一个映射（类似于起点 $1,2,3$ 分别对应终点 $3,1,2$，$3,1,2$ 就是一种映射）是有偶数个逆序对数会被算成正贡献，奇数个逆序对数会被算成负贡献， ``LGV`` 的定义亦然！

___

但我们似乎还忘记了一个东西，**所有路径在中间不经过重复的顶点**，怎么没有用到？加上这个定义似乎不好想 $...$

索性就不想了，说不定能对，我们来想想这样做答案会不会变

假设我们有起点 $x_i,x_j$ 对应终点 $y_i,y_j$，在某个点 $p$ 相交

我们此时一定会有一个路径与之对应：让 $x_i,x_j$ 以原来的路走向 $p$，但之后 $x_i$ 走向 $y_j$ ，$x_j$ 走向 $y_i$ ，此时我们因为交换了一个数对，其逆序对奇偶性必然会改变（下面将会给证明），所以我们一正一负，恰好被容斥了

证明：

* 如果有一个排列$P$，交换任意两个数，逆序对奇偶性就会改变

不妨我们交换下标为 $i,j$ 的两个数，我们可以发现我们改变的逆序对只有三种形式：

1. $i,j$ 相互产生的影响，变化量为$1$或$-1$

2. $i$ 对 $i,j$ 中间元素的贡献，$i,j$ 中间元素大于 $P_i$ 的个数为 $(>Pi)$，小于同理，那么我们会增加 $-(<P_i)+(>P_i)$ 个逆序对，这和$i,j$ 中间元素个数是同奇偶的

3. $j$ 对 $i,j$ 中间元素的贡献 ，我们会增加 $(<P_j)-(>P_j)$ 个逆序对，这也和 $i,j$ 中间元素个数是同奇偶的

那么$i,j$ 对 $i,j$ 中间元素的贡献是偶数，而 $i,j$ 相互产生的影响是奇数

所以加起来必然是奇数，奇偶性必然改变

---

## 作者：囧仙 (赞：5)

## 题解

（~~考场上没学过LGV引理于是成了暴力选手的屑爪巴了~~）

考虑一个的LGV引理的一种特殊情形：

> 对于一张有向无环图，有点集 $A$ 和点集 $B$ ，满足 $|A|=|B|$ 。假如我们求出了一个大小为 $|A|\times |B|$ 的矩阵 $M$，其中第 $i$ 行第 $j$ 列表示 $A_i$ 到 $B_j$ 的方案数。我们可以用LGV引理，计算出这样一个式子的值：  
$$\det(M)=\sum_{S:A\to B}(-1)^{N(\sigma(S))}$$  
> 其中， $\det$ 表示行列式； $S$ 表示一组**从 $\bm A$ 到 $\bm B$ 的不相交路线**（其中 $A_i$ 到达 $B_{\sigma(S)_i}$）； $N$ 表示一个排列的逆序对数。

对于这题，有个非常重要的结论：**一组合法的路线 $\bm S$，交点个数的奇偶性，恰好是 $\bm{N(\sigma(S))}$ 的奇偶性**。考虑任取两个点 $a,b$ 。假设它们从第 $i$ 层到了第 $i+1$ 层，相对位置发生了变化（即原来 $a$ 在 $b$ 的上方，后来 $b$ 跑到了 $a$ 的上方。反过来同理）那么必然会产生一个交点，使得交点总数的奇偶性发生改变；同时它们对逆序对的贡献也是 $1$ ，无论是 $+1$ 还是 $-1$ ，都会使奇偶性发生改变。于是能够发现，交点个数的奇偶性总是和逆序对个数的奇偶性同步发生改变的。

在本题的答案中，有奇数个交点的路径组的贡献是 $-1$ ，有偶数个交点的路径组的贡献是 $+1$ 。可以发现，在刚刚给出的这个特殊的LGV引理中，逆序对的奇偶性对式子的结果的贡献同样也是 $-1$ 与 $+1$ 。

显然本题给的图就是一个有向无环图，而且第一层的点就是公式里用到的 $A$ 
，第 $k$ 层的点就是公式里用到的 $B$ （题目还保证了 $n_1=n_k$ ，这不就是明摆着要用LGV引理嘛……）

---

于是，我们的任务是求出 $M$ 的值，以及求出 $\det(M)$ 。后者可以直接套行列式的板子，而前者可以使用**矩阵乘法**。

考虑 $A\to P$ ，以及 $P\to B$ 的两个邻接矩阵 $X$ 和 $Y$（其中第 $i$ 行第 $j$ 列表示对应两点到达的方案数），并且点集 $A$ 中的点不能不经过 $P$ 直接到达 $B$。计算 $Z=X\times Y$ ，根据矩阵乘法的定义，可以发现，

$$Z_{i,j}=\sum_kX_{i,k}\times Y_{k,j}$$

如果使用 dp 的方式去理解，那就是枚举 $P$ 中的点作为中介点，然后用乘法原理算出 $A$ 里的点经过这个中介点到达 $B$ 里的点的方案数。用加法原理把所有中介点的情况加起来。

于是第 $1$ 层的点到第 $k$ 层的点，对应的方案数就是这 $k-1$ 个邻接矩阵相乘的结果。然后套行列式板子，这题就做完了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int SIZ =300+3;
const int MOD =998244353;
struct Matx{
    int r,c,W[SIZ][SIZ]; Matx(int _r=0,int _c=0):r(_r),c(_c){memset(W,0,sizeof(W));}
    Matx operator *(Matx t){
        Matx w(r,t.c);
        up(1,c,k) up(1,r,i) up(1,t.c,j)
            w.W[i][j]=(1ll*w.W[i][j]+1ll*W[i][k]*t.W[k][j])%MOD;
        return w;
    }
};
namespace Mth{
    int pwr(int x,int y){
        int r=1; while(y){if(y&1)r=1ll*r*x%MOD;x=1ll*x*x%MOD,y>>=1;}
        return r;
    }
}
namespace Det{
    int det(int n,Matx X){
        int r=1; bool o=0; up(1,n,i){
            int f=0; up(i,n,j) if(X.W[j][i]){f=j;break;}
            if(f!=i) swap(X.W[i],X.W[f]),o^=1;
            up(i+1,n,j) if(X.W[j][i]){
                int x=1ll*X.W[j][i]*Mth::pwr(X.W[i][i],MOD-2)%MOD,r=1ll*r*x%MOD;
                up(i,n,k) X.W[j][k]=(X.W[j][k]-1ll*x*X.W[i][k]%MOD+MOD)%MOD;
            }
        }
        r=Mth::pwr(r,MOD-2); up(1,n,i) r=1ll*r*X.W[i][i]%MOD;
        return o?(MOD-r)%MOD:r;
    }
}
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
namespace Slv{
    int n,m,t; Matx A,O;
    void add(int u,int v,int w){A.W[u][v]=(A.W[u][v]+w)%MOD;}
    int N[SIZ],M[SIZ];
    void mian(){
        int k=qread(); up(1,k,i) N[i]=qread(); up(1,k-1,i) M[i]=qread();
        up(1,k-1,i){
            A=Matx(N[i],N[i+1]); up(1,M[i],j){
                int u=qread(),v=qread(); add(u,v,1);
            }
            if(i==1) O=A; else O=O*A;
        }
        printf("%d\n",Det::det(N[1],O));
    }
}
int main(){up(1,qread(),T) Slv::mian();}
```

---

## 作者：liyixin0514 (赞：4)

# [P7736 [NOI2021] 路径交点](https://www.luogu.com.cn/problem/P7736)

[可能更好的阅读体验](https://www.cnblogs.com/liyixin0514/p/18648852)

## 题意

给一个分层 DAG，起点和终点（第一层和最后一层）数量相同，要求路径没有公共点。问所有路径方案中，$偶数交点方案数-奇数交点方案数$ 是多少。

## 思路

对于相邻两层，我们每层各选择 $n$ 个点。题目说的“交点数”其实就是排列的逆序对数。建邻接矩阵，边权为 $1$。对邻接矩阵生成的所有 $n\times n$ 的子方阵，套 [LGV 引理](https://www.cnblogs.com/liyixin0514/p/18648738)，求行列式。然后相加。

然后你发现你不能枚举选择哪 $n$ 个点啊，因此这里我们规定相邻两层的节点数都恰好是 $n$。

对于多层的，使用[比内柯西公式](https://www.cnblogs.com/liyixin0514/p/18648007)解决，题目保证第一层和最后一层都是 $n$ 个点，使得题目可做。

在第一层和最后一层之间加一层，分别构造两个邻接矩阵 $A,B$，表示第一层和中间层，最后一层和中间层的连边关系。

思考 $|AB|$ 的含义。等于所有在 $A$ 中选择 $n$ 列（中间层选择 $n$ 个点），在 $B$ 中选择对应的 $n$ 行（中间层选择对应的 $n$ 个点）。两个方阵的行列式相乘，就是一个卷积形式，就是每种方案的贡献相乘，发现是对的。（过几天我将会看不懂我在说什么）

然后由于矩阵乘法满足结合律，因此所有邻接矩阵连乘，的行列式，就是答案！

时间复杂度 $O(n^4)$。常数小吧。

## code

[警示后人](https://www.luogu.com.cn/discuss/1032162)

```cpp
#include<bits/stdc++.h>
#define sf scanf
#define pf printf
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
typedef long long ll;
namespace pragmatic {
    constexpr int N=205,mod=998244353;
    int add(int a,int b) { return a+b>=mod ? a+b-mod : a+b; }
    void _add(int &a,int b) { a=add(a,b); }
    int mul(int a,int b) { return 1ll*a*b%mod; }
    void _mul(int &a,int b) { a=mul(a,b); }
    int t,k;
    int n,m[N];
    int u,v;
    struct juzhen {
        int n,m;
        int x[N][N];
        void clear() { memset(x,0,sizeof(x)); }
        juzhen operator * (const juzhen b) const {
            juzhen c={n,b.m};
            c.clear();
            rep(i,1,c.n) rep(j,1,c.m) {
                rep(k,1,m) _add(c.x[i][j],mul(x[i][k],b.x[k][j]));
            }
            return c;
        }
    }a[N];
    int f;
    int ksm(int a,int b=mod-2) {
        int s=1;
        while(b) {
            if(b&1) _mul(s,a);
            _mul(a,a);
            b>>=1;
        }
        return s;
    }
    void _swap(juzhen &a,int x,int y) {
        f^=1;
        rep(i,1,a.n) swap(a.x[x][i],a.x[y][i]);
    }
    void gauss(juzhen &a) {
        rep(i,1,a.n) {
            if(!a.x[i][i]) 
                rep(j,i+1,a.n) {
                    if(a.x[j][i]) {
                        _swap(a,i,j);
                        break;
                    }
                }
            int inv=ksm(a.x[i][i]);
            rep(j,i+1,a.n) {
                if(!a.x[j][i]) continue;
                int t=mul(inv,a.x[j][i]);
                rep(k,i,a.n) _add(a.x[j][k],mod-mul(t,a.x[i][k]));
            }
        }
    }
    int det(juzhen &a) {
        f=0;
        gauss(a);
        int ans=1;
        rep(i,1,a.n) {
            _mul(ans,a.x[i][i]);
        }
        if(f) return add(mod,-ans);
        return ans;
    }
    void main() {
        sf("%d",&t);
        while(t--) {
            sf("%d",&k);
            rep(i,1,k) sf("%d",&n), a[i].n=n;
            rep(i,1,k-1) a[i].m=a[i+1].n;
            rep(i,1,k-1) sf("%d",&m[i]);
            rep(i,1,k-1) a[i].clear();
            rep(i,1,k-1) {
                rep(j,1,m[i]) {
                    sf("%d%d",&u,&v);
                    a[i].x[u][v]=1;
                }
            }
            rep(i,2,k-1) a[1]=a[1]*a[i];
            pf("%d\n",det(a[1]));
        }
    }
}
int main() {
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("my.out","w",stdout);
    #endif
    pragmatic :: main();
}
```

---

## 作者：wsyhb (赞：4)

注：本题为 NOI2021 D1T2。

## 题解

首先有一个很麻烦的限制，就是 $n_j \; (2 \le j \le k-1)$ 不一定等于 $n_1$——这似乎使我们不得不枚举每一层选了哪些以合并信息。

但由于题目只考虑交点的奇偶性，我们不妨大胆猜测：**两条路径交点个数的奇偶性，与将其起点和终点直接相连的交点个数的奇偶性相同。**

------------

其实**证明**也很简单：

考虑任意两条不相交路径在任意三层之间的交点个数。

设其中一条路径依次经过这三层的 $a_1,x,b_1$，另一条路径依次经过这三层的 $a_2,y,b_2$，不妨设 $x<y$，则有如下四种情况：

| 编号 | 1 | 2 | 3 | 4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $a_1$ 和 $a_2$ | $a_1<a_2$ | $a_1<a_2$ | $a_1>a_2$ | $a_1>a_2$ |
| $b_1$ 和 $b_2$ | $b_1<b_2$ | $b_1>b_2$ | $b_1<b_2$ | $b_1>b_2$ |
| 交点个数 | 0 | 1 | 1 | 2 |
| $a_1,b_1$ 与 $a_2,b_2$ 分别直接相连的交点个数 | 0 | 1 | 1 | 0 |

故任意相邻两段合并成一段后，交点个数奇偶性不变。（一段即指两层之间）

进一步有，所有段合并成一段后，交点个数奇偶性不变。

------------

至此，我们可以直接通过两条路径的起点和终点，判断它们之间交点个数的奇偶性。

更形式化地说，**设以第 $1$ 层的 $i$ 号点为起点的路径的终点为第 $k$ 层的 $p_i$ 号点，那么一种方案的交点个数的奇偶性，与其对应的排列 $p$ 的逆序对数量的奇偶性相同**。

由于问题是“偶数个交点的路径方案数比有奇数个交点的路径方案数多多少个”，即**偶数个逆序对的方案数带有系数 $+1$，奇数个逆序对的方案数带有系数 $-1$**，因此可以联想到**行列式**。

设 $M[i][j]$ 表示以第 $1$ 层的 $i$ 号点为起点，以第 $k$ 层的 $j$ 号点为终点的路径数。

考虑 $M$ 的行列式：

$$det(M)=\sum_{\sigma}(-1)^{\tau(\sigma)}\prod_{i=1}^{n_{_1}}M_{i,\sigma(i)}$$

（其中 $\sigma$ 表示一个 $1$ 到 $n_1$ 的排列，$\tau(\sigma)$ 表示 $\sigma$ 的逆序对数）

我们发现，虽然行列式中的系数满足奇偶性的要求，但这其中包含了存在路径相交的情况。

尽管如此，**每一个存在路径相交的偶数个逆序对的方案，与每一个存在路径相交的奇数个逆序对的方案一一对应**。（注意这里的路径相交不包括：起点/终点相同）

对应方法有很多种，此处举个例子：对于一个存在路径相交的偶数个逆序对的方案，选出其中与其他路径相交的起点编号最小的路径 $x$，再选出与 $x$ 相交的起点编号最小的路径 $y$，然后选出 $x$ 和 $y$ 的公共点中层数编号最大的一个点，记其层数编号为 $p$，将 $x$ 和 $y$ 在第 $p$ 层到第 $k$ 层之间的部分交换，易证这样的逆序对个数会变成奇数。

**故答案即为 $M$ 行列式的值。**

至于怎么求 $M$，邻接矩阵求矩阵乘法/分层递推/BFS均可。

## 代码

注意一个坑点：中间层的点数最大为 $200$。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_k=100+5;
int n[max_k],m[max_k];
const int mod=998244353;
inline void add(int &a,int b)
{
	a=a+b-(a+b>=mod?mod:0); 
}
inline int qpow(int a,int n)
{
	int res=1;
	while(n)
	{
		if(n&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		n>>=1;
	}
	return res;
}
const int max_n=200+5;
int f[max_n][max_n],g[max_n][max_n];
inline int det(int n)
{
	int val=1;
	bool flag_neg=false;
	for(int i=1;i<=n;++i)
	{
		int k=i;
		while(k<=n&&!f[k][i])
			++k;
		if(k>n)
			return 0;
		if(k!=i)
		{
			for(int j=i;j<=n;++j)
				swap(f[i][j],f[k][j]);
			flag_neg^=1;
		}
		val=1ll*val*(f[i][i]+mod)%mod;
		int t=qpow(f[i][i],mod-2);
		for(int k=i+1;k<=n;++k)
		{
			int t0=1ll*t*f[k][i]%mod;
			for(int j=i;j<=n;++j)
				f[k][j]=(f[k][j]-1ll*f[i][j]*t0)%mod;
		}
	}
	return flag_neg?mod-val:val;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int k;
		scanf("%d",&k);
		for(int i=1;i<=k;++i)
			scanf("%d",n+i);
		for(int i=1;i<=k-1;++i)
			scanf("%d",m+i);
		for(int i=1;i<=n[1];++i)
			for(int j=1;j<=n[1];++j)
				f[i][j]=(i==j);
		for(int i=1;i<=k-1;++i)
		{
			for(int j=1;j<=m[i];++j)
			{
				int p,q;
				scanf("%d%d",&p,&q);
				for(int x=1;x<=n[1];++x)
					add(g[x][q],f[x][p]);
			}
			for(int p=1;p<=n[1];++p)
				for(int q=1;q<=n[i+1];++q)
					f[p][q]=g[p][q],g[p][q]=0;
		}
		printf("%d\n",det(n[1]));
	}
    return 0;
}
```

---

## 作者：Mihari (赞：3)



# 题目描述

[传送门 to Luogu](https://www.luogu.com.cn/problem/P7736).

# 题解

## 前言

如果 $\LaTeX$ 炸了就去[这里](https://www.cnblogs.com/Arextre/p/15063245.html)吧。

本篇题解并没有使用 $\rm LGV$ 引理 ~~毕竟我也不会那东西~~，但是涉及 $\rm Binet-Cauchy$ 公式。

## 从简单想起

想一个简单的问题 —— 如果 $k=2$，也就是我们只有两边的点怎么处理？

似乎还不是很好求，那么我们继续简化 —— 如果我们只求合法的方案数而并非奇偶作差怎么办？

似乎没什么正解的思路？—— 那就想一想暴力一点的。

好，于是我们有一个很简单的暴力思路 —— 使用 $\mathcal O(n!)$ 枚举全排列 $p$，对于每一位 $i$，假设填数 $p(i)$，表示这个方案有一条 $i\rightarrow p_i$ 的边（第一层连向第二层），然后检查这个方案是否合法。

设 $G$ 为这两层图之间的邻接矩阵，那么这个最简化的问题就是
$$
\sum_{\sigma\text{ is a permutation}}\prod_{i=1}^n G(i,\sigma_i)
$$
>这个东西的本质是矩阵 $G$ 的积和式，目前面对求解一个一般矩阵的积和式的问题，我们只有对矩阵使用拉布拉斯展开在复杂度 $\mathcal O(n!)$​ 下计算......所以这个问题从本质上说是变难了，不过却有助于我们向正解靠拢。

设 $f(\sigma)$ 为排列 $\sigma$ 这个方案交点个数，那么奇偶交点的方案数作差就是
$$
\sum_{\sigma\text{ is a permutation}}(-1)^{f(\sigma)}\prod_{i=1}^n G(i,\sigma_i)
$$
发现这东西和行列式有点像？现在我们希望的是满足：
$$
f(\sigma)=\tau(\sigma)
$$
事实上，这俩确实满足这个等式，这就不必我多说了吧.......

我们重新观察这个式子，根据行列式的定义，这事实上就是 $\det(G)$.

## 再多一层？

我们已经成功解决 $k=2$ 的情形，那么，如果 $k=3$，我们会面临什么更多的问题？

- 相邻两层的点数或将不同；

设 $G_i$ 为第 $i$ 层与第 $i+1$​ 层的邻接矩阵，此时我们想要将简单版的思路推广，即我们希望能够证明，在这个问题下，存在
$$
Ans=\det\left(G_1\times G_2\right)
$$
其中 $G_1$ 为 $n_1\times n_2$ 的矩阵，$G_2$ 为 $n_2\times n_3=n_1\times n_1$  的矩阵。

由于 $G_1,G_2$ 并非完美的方阵，而我们又要求行列式，这不禁让我们想到 $\rm Binet-Cauchy$​ 公式，使用该公式对此行列式进行展开，得到：
$$
\det(G_1\times G_2)=\sum_{i_1<i_2<i_3<\cdots<i_{n_1}}\det G_1(123\cdots n;i_1,i_2,i_3,\cdots,i_n)\times \det G_2(i_1,i_2,i_3,\cdots,i_n;123\cdots n)
$$
其中 $\det G_1(123\cdots n;i_1,i_2,i_3,\cdots,i_n)$ 表示由 $G_1$ 的第 $1,2,3,\cdots,n$ 行以及 $i_1,i_2,i_3,\cdots i_n$ 列构成的子矩阵。

分析这个式子的含义，第一项即连接第一层中所有 $(x,i_x)$​，并且带上这一层中交点的奇偶性，第二项即连接所有 $(i_y,y)$​，并且带上这一层的交点的奇偶性，那么他们俩乘起来？就是这个方案是否存在（满足所有 $(x,i_x)$​ 以及 $(i_y,y)$​ 边都存在）以及交点的奇偶性！

显然，这就是我们想求的，通过含义进行分析，我们可以得到
$$
Ans=\det(G_1\times G_2)
$$

## 结论！

有三层，那么我们可以推广到多层的情况，此时显然有
$$
Ans=\det\left(\prod_{i=1}^{k-1}G_i\right)
$$
令人害怕的是，该算法复杂度达到惊人的 $\mathcal O(T(kn^3+n^2\log))$​，不过跑得还蛮快的嘛......

## 多说一句

为什么该题让我们求偶数方案减去奇数方案呢？其实上文提到过，如果是求方案之和的话，那转化的方向就是矩阵的积和式了，然而目前只能使用 $\mathcal O(n!)$​ 的算法解决......并不比暴力优秀多少，甚至还更难打。

# 参考代码

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

#define NDUBUG
#include<cassert>

namespace Elaina{
    #define rep(i, l, r) for(int i=(l), i##_end_=(r); i<=i##_end_; ++i)
    #define drep(i, l, r) for(int i=(l), i##_end_=(r); i>=i##_end_; --i)
    #define fi first
    #define se second
    #define mp(a, b) make_pair(a, b)
    #define Endl putchar('\n')
    #define mmset(a, b) memset(a, b, sizeof a)
    // #define int long long
    typedef long long ll;
    typedef unsigned long long ull;
    typedef pair<int, int> pii;
    typedef pair<ll, ll> pll;
    template<class T>inline T fab(T x){ return x<0? -x: x; }
    template<class T>inline void getmin(T& x, const T rhs){ x=min(x, rhs); }
    template<class T>inline void getmax(T& x, const T rhs){ x=max(x, rhs); }
    template<class T>inline T readin(T x){
        x=0; int f=0; char c;
        while((c=getchar())<'0' || '9'<c) if(c=='-') f=1;
        for(x=(c^48); '0'<=(c=getchar()) && c<='9'; x=(x<<1)+(x<<3)+(c^48));
        return f? -x: x;
    }
    template<class T>inline void writc(T x, char s='\n'){
        static int fwri_sta[1005], fwri_ed=0;
        if(x<0) putchar('-'), x=-x;
        do fwri_sta[++fwri_ed]=x%10, x/=10; while(x);
        while(putchar(fwri_sta[fwri_ed--]^48), fwri_ed);
        putchar(s);
    }
}
using namespace Elaina;

const int maxk=100;
const int Mod=998244353;

template<class T>struct matrix{
    vector< vector<T> >a; int n, m;
    inline matrix(){ n=m=0; a.clear(); }
    inline matrix(int N, int M, T v=0): n(N), m(M){
        a.resize(n);
        for(int i=0; i<n; ++i)
            a[i].resize(m, v);
    }
    inline matrix Epsilon(const int N){
        (*this)=matrix<T>(N, N, 0);
        for(int i=0; i<n; ++i) a[i][i]=1;
        return (*this);
    }
    inline matrix operator *(const matrix rhs) const{
        assert(m==rhs.n);
        matrix<T>ret(n, rhs.m);
        for(int i=0; i<n; ++i) for(int j=0; j<m; ++j) if(a[i][j])
            for(int k=0; k<rhs.m; ++k)
                ret.a[i][k]=(ret.a[i][k]+1ll*a[i][j]*rhs.a[j][k]%Mod)%Mod;
        return ret;
    }
    inline int det(){
        assert(n==m); int ret=1;
        vector< vector<T> >Mat=a;
        for(int i=0; i<n; ++i){
            for(int j=i+1; j<n; ++j) while(Mat[j][i]){
                int t=Mat[i][i]/Mat[j][i];
                for(int k=i; k<n; ++k)
                    Mat[i][k]=(Mat[i][k]+Mod-1ll*Mat[j][k]*t%Mod)%Mod;
                swap(Mat[i], Mat[j]), ret=-ret;
            }
            if(!Mat[i][i]) return 0;
            ret=1ll*ret*Mat[i][i]%Mod;
        }
        return (ret+Mod)%Mod;
    }
};

matrix<int>ans, G;

int n[maxk+5], m[maxk+5], k;

inline void solve(){
    k=readin(1);
    for(int i=0; i<k; ++i)
        n[i]=readin(1);
    for(int i=1; i<k; ++i)
        m[i]=readin(1);
    ans=matrix<int>().Epsilon(n[0]);
    int u, v;
    for(int i=1; i<k; ++i){
        G=matrix<int>(n[i-1], n[i], 0);
        for(int j=1; j<=m[i]; ++j){
            u=readin(1)-1, v=readin(1)-1;
            G.a[u][v]=1;
        }
        ans=ans*G;
    }
    writc(ans.det());
}

signed main(){
    // freopen("xpath.in", "r", stdin);
    // freopen("xpath.out", "w", stdout);
    rep(_, 1, readin(1)) solve();
    return 0;
}
```

---

## 作者：TernaryTree (赞：2)

行列式简单题，但是没有想出来，难过。

首先我们要知道如何求出从每个第一层的点到每个最后一层的点的路径数。这个是简单的，因为我们有一个经典的 trick，就是邻接矩阵的 $k$ 次幂中的每个点，等于其行列所表示点对之间经过长度恰好为 $k$ 的路径数。联想一下即可得到，将第 $i$ 层与第 $i+1$ 层的邻接矩阵与第 $i+1$ 与 $i+2$ 层的相乘即为 $i$ 到 $i+2$ 的方案数。这也可以通过矩乘的定义（类 floyd）得到。

我们注意到题目要求偶数方案数减去奇数方案数，结合前面的线性代数部分，容易联想到行列式中 $(-1)^{\pi(p)}$ 的部分。可是我们找不到一个合适的东西表示 $\pi(p)$，你就被卡住了。

然而我们有性质：交点数的奇偶性仅与起点与终点有关。不妨设起点味为 $i$ 时终点为 $p_i$，则交点数的奇偶性与 $\pi(p)$ 的奇偶性相同。

感性证明之：假设我们不考虑中间的点，直接把 $i\to p_i$ 看做一条绳子，则任意 $i<j$ 且 $p_i> p_j$ 会构成一个交点，这个交点是无法除去的，也就是说交点数量 $\ge \pi(p)$。那我们现在如果在中间加了一些点，相当于让绳子弯曲，因为一条绳子最终仍要回到自己的终点，所以一旦与其他绳子有不必要的相交，那么一定存在一个点让这个绳子回到下面。这说明，剩余的不必要交点是两个两个成对增加的，不影响其奇偶性。

这时我们就已经可以对 $\prod G_i$ 求行列式得到答案了，但是还存在一个问题，就是如果中间存在一个点被两条路径共用，会不会导致答案错误。

事实上并不会。我们假设两条路径分别为 $s_0\to p\to t_0$，$s_1\to p\to t_1$。那么显然，$s_0\to p\to t_1$，$s_1\to p\to t_0$ 也会被被计入行列式。并且这两种不同的路径对的逆序对数一定不同，所以我们会 $+1-1$ 将其消去，对答案没有影响。

复杂度 $\Theta(kn^3)$。

```cpp
matrix g[maxn];

signed main() {
	cin >> T;
	while (T--) {
		cin >> k;
		for (int i = 1; i <= k; i++) cin >> n[i];
		for (int i = 1; i < k; i++) g[i].n = n[i], g[i].m = n[i + 1], g[i].clear();
		for (int i = 1; i < k; i++) cin >> m[i];
		for (int i = 1; i < k; i++) {
			for (int j = 1, u, v; j <= m[i]; j++) {
				cin >> u >> v;
				g[i][u][v] = 1;
			}
		}
		for (int i = 2; i < k; i++) g[i] = g[i - 1] * g[i];
		cout << g[k - 1].det() << endl;
	}
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

讲个笑话：昨天有个关系很好的同学问我如何证明 $\det(AB) = \det(A)\det(B) $，$A,B \in \mathbb R^{n \times n}$。当时脑抽，直接暴力展开借鉴 $\rm LGV$ **引理的证明**。

其中有一个恒等式：考虑置换 $p_1$ 和 $p_2$，定义 $p_1$ 作用在 $p_2$ 上的结果为 $p_1 \circ p_2$。则：

$$
(-1)^{\tau(p_1) + \tau(p_2)} = (-1)^{\tau(p_1 \circ p_2)}
$$

证明：提供一个很唐的想法。考虑枚举 $i$ 和 $j$（$i < j$）。$p_{2,i}$ 和 $p_{2,j}$ 在最终的 $p_1 \circ p_2$ 中能产生逆序对，当且仅当 $[p_{2,i} < p_{2,j}] \oplus [p_{1,i}^{-1} < p_{1,j}^{-1}] =1$。在 $(-1)$ 的幂次中，我们可以直接改为加法。而显然 $\tau(p_1^{-1}) = \tau(p_1)$，得证。

所以本题中，所有置换的逆序对之和的奇偶性等于他们作用在一起中逆序对个数的奇偶性。

那么这是 $\rm LGV$ 引理的模板。

不得不说，$\rm NOI 2021$ 的 $\rm Day 1$ 确实有点。不过这是我开上帝视角的结论：毕竟 $\rm LGV$ 引理是在这一场考试之后才大范围普及的，让我这种低水平算法竞赛选手都了解过。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=200+10,MOD=998244353; 
int T,n,len[MAXN],m[MAXN],dp[MAXN][MAXN][MAXN],f[MAXN][MAXN];
vector<int> G[MAXN][MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int det(void) {
	int mul=1; int n=len[1];
	ffor(i,1,n) {
		if(!f[i][i]) ffor(j,i+1,n) if(f[j][i]) {swap(f[j],f[i]),mul=-mul;break;}
		if(!f[i][i]) return 0;
		int inv=qpow(f[i][i],MOD-2);
		ffor(j,i+1,n) {
			int mul=inv*f[j][i]%MOD;
			ffor(k,i,n) f[j][k]=(f[j][k]-mul*f[i][k])%MOD;
		}
	}
	ffor(i,1,n) mul=mul*f[i][i]%MOD;
	return (mul%MOD+MOD)%MOD;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		cin>>n;
		ffor(i,1,n) cin>>len[i];
		ffor(i,1,n) ffor(j,1,len[i]) G[i][j].clear();
		memset(dp,0,sizeof(dp));
		ffor(i,1,n-1) cin>>m[i];
		ffor(i,1,n-1) {
			ffor(j,1,m[i]) {
				int u,v;
				cin>>u>>v;
				G[i][u].push_back(v);	
			}
		}
		ffor(i,1,len[n]) ffor(j,1,len[n]) dp[n][j][i]=(i==j);
		roff(i,n-1,1) ffor(k,1,len[i]) for(auto nxt:G[i][k]) ffor(des,1,len[n]) dp[i][k][des]=(dp[i][k][des]+dp[i+1][nxt][des])%MOD;
		ffor(i,1,len[1]) ffor(j,1,len[1]) f[i][j]=dp[1][i][j];
//		cout<<'\n';
//		ffor(i,1,len[1]) {
//			ffor(j,1,len[1]) cout<<f[i][j]<<' ';
//			cout<<'\n';	
//		}
		cout<<det()<<'\n';
	}
	return 0;
}
```

---

## 作者：喵仔牛奶 (赞：1)

## Solution

记 $A_{i}$ 为第 $i$ 层到第 $i+1$ 层的邻接矩阵，大小为 $n_i\times n_{i+1}$。记 $R_A,C_A$ 分别为 $A$ 的行列集合，$A[R,C]$ 为保留 $R,C$ 中的行列的矩阵 $A$。

$k=2$ 时是经典的 LGV 引理，答案为 $\det(A_1)$。

考虑 $k=3$，考虑枚举 $1,2,3,\cdots,n$ 在第二层经过了 $p_1,p_2,p_3,\cdots,p_n$，答案为 $\sum_p\det(A_1[R_{A_1},p])\det(A_2[p,C_{A_2}])$。根据柯西-比内公式，这个式子等于 $\det(A_1A_2)$。

对于所有情况，可以看做枚举 $p_{(1)},p_{(2)},\cdots,p_{(k-2)}$，使用柯西-比内公式依次合并求和号，答案即为 $\det(A_1A_2\cdots A_k)$。

---


# [NOI2021] 庆典

## 题目描述

C 国是一个繁荣昌盛的国家，它由 $n$ 座城市和 $m$ 条有向道路组成，城市从 $1$ 到 $n$ 编号。如果从 $x$ 号城市出发，经过若干条道路后能到达 $y$ 号城市，那么我们称 $x$ 号城市可到达 $y$ 号城市，记作 $x\Rightarrow y$。C 国的道路有一个特点：对于三座城市 $x$，$y$，$z$，若 $x\Rightarrow z$ 且 $y\Rightarrow z$，那么有 $x\Rightarrow y$ 或 $y\Rightarrow x$。

再过一个月就是 C 国成立的千年纪念日，所以 C 国的人民正在筹备盛大的游行庆典。目前 C 国得知接下来会有 $q$ 次游行计划，第 $i$ 次游行希望从城市 $s_i$ 出发，经过若干个城市后，在城市 $t_i$ 结束，且在游行过程中，**一个城市可以被经过多次**。为了增加游行的乐趣，每次游行还会**临时**修建出 $k$（$0 \le k \le 2$）条有向道路专门供本次游行使用，即其它游行计划不能通过本次游行修建的道路。

现在 C 国想知道，每次游行计划可能会**经过多少座城市**。

注意：临时修建出的道路**可以不满足 C 国道路原有的特点**。

## 说明/提示

**【样例解释 #1】**

第 $1$ 次计划，起点为 $1$ 号点，终点为 $4$ 号点，临时修建道路为 $5\rightarrow1$，最终可能经过的城市编号为 $\{1,2,4,5\}$。

第 $2$ 次计划，起点为 $2$ 号点，终点为 $3$ 号点，临时修建道路为 $5\rightarrow3$，最终可能经过的城市编号为 $\{2,3,4,5\}$。

第 $3$ 次计划，起点为 $1$ 号点，终点为 $2$ 号点，临时修建道路为 $5\rightarrow2$，最终可能经过的城市编号为 $\{1,2,4,5\}$。

第 $4$ 次计划，起点为 $3$ 号点，终点为 $4$ 号点，临时修建道路为 $5\rightarrow1$，最终从 $3$ 号点出发无法到达 $4$ 号点。

**【样例 #2】**

见附件 `celebration/celebration2.in` 与 `celebration/celebration2.ans`。

该样例约束与测试点 $5 \sim 7$ 一致。

**【样例 #3】**

见附件 `celebration/celebration3.in` 与 `celebration/celebration3.ans`。

该样例约束与测试点 $10 \sim 11$ 一致。

**【样例 #4】**

见附件 `celebration/celebration4.in` 与 `celebration/celebration4.ans`。

该样例约束与测试点 $15 \sim 16$ 一致。

**【样例 #5】**

见附件 `celebration/celebration5.in` 与 `celebration/celebration5.ans`。

该样例约束与测试点 $20 \sim 25$ 一致。

**【数据范围】**

对于所有测试点，$1 \le n,q \le 3 \times {10}^5$，$n - 1 \le m \le 6 \times {10}^5$，$0 \le k \le 2$。

| 测试点编号 | $n, q \le$ | $k$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $5$ | $= 0$ | 无 |
| $5 \sim 7$ | $1000$ | $\le 2$ | 无 |
| $8 \sim 9$ | $3 \times {10}^5$ | $= 0$ | $m = n - 1$ |
| $10 \sim 11$ | $3 \times {10}^5$ | $= 1$ | $m = n - 1$ |
| $12 \sim 14$ | $3 \times {10}^5$ | $= 2$ | $m = n - 1$ |
| $15 \sim 16$ | $3 \times {10}^5$ | $= 0$ | 无 |
| $17 \sim 19$ | $3 \times {10}^5$ | $= 1$ | 无 |
| $20 \sim 25$ | $3 \times {10}^5$ | $= 2$ | 无 |

## 样例 #1

### 输入

```
5 6 4 1
1 2
1 3
1 4
2 5
4 5
5 4
1 4 5 1
2 3 5 3
1 2 5 2
3 4 5 1
```

### 输出

```
4
4
4
0
```

# 题解

## 作者：lndjy (赞：43)

这里提供一个虚树的做法，比起其他做法细节少了很多，并且可以扩展到 $\sum k\le 10^5$。

前面的部分和其他做法一样，先 tarjan 转 DAG，然后拓扑排序变成叶向树，变成树上问题。

随着 $k$ 的增长，分类讨论变得麻烦，考虑虚树。

将 $s,t$ 以及所有新边的两个端点拿出来，建立虚树，从祖先到后代连单向边（因为是叶向树）。同时点带点权为树上的点权，边带边权为两点之间不含两个端点的点权和。对于新加的边，根据定义在虚树上面多连一个边权为 0 的边。

现在变成和一开始一样的问题：给定一个的有向图，求 $s$ 到 $t$ 可能经过的权值和，只不过点边较少。

既然点边较少，那么原来的 35 分暴力做法就派上用场了：建原图跑出 $s$ 到达的点边，建反图跑出 $t$ 到达的点边，最后取一个交累加进答案。

代码较长，但是各部分互相独立比较好调，调试时只需要检查各种新图是不是对的就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<unordered_map>
#include<map>
using namespace std;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
const int N=3e5+5;
int n,m,q,k,head[N],cnt,d[N];
struct Graph
{
	int head[N],cnt;
	struct edge
	{
		int to,nxt;
	}e[N*2];
	void add(int u,int v)
	{
		e[++cnt].to=v;
		e[cnt].nxt=head[u];
		head[u]=cnt;
	}
}G1,G2;
struct graph
{
	int head[20],cnt;
	struct edge
	{
		int to,nxt,v;
	}e[30*2];
	void add(int u,int v,int w)
	{
//		cout<<u<<" "<<v<<" "<<w<<endl;
		e[++cnt].to=v;
		e[cnt].nxt=head[u];
		head[u]=cnt;
		e[cnt].v=w;
	}
	void clear()
	{
		cnt=0;
		memset(head,0,sizeof head);
	}
}G3,G4;
struct edge
{
	int to,nxt;
}e[N*2];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int dfn[N],low[N],v[N],col[N],colw[N],tot,s[N],top,Sum,st,ed,h[15],sum[N],lg[N],f[N][20],dep[N],Tot,L[N],ind[N];
#define sum Sum
void dfs(int now)//原图 tarjan 
{
	dfn[now]=low[now]=++tot;
	s[++top]=now;
	v[now]=1;
	for(int i=head[now];i;i=e[i].nxt)
	if(!dfn[e[i].to]) dfs(e[i].to),low[now]=min(low[now],low[e[i].to]);
	else if(v[e[i].to]) low[now]=min(low[now],dfn[e[i].to]);
	if(low[now]==dfn[now])
	{
		int x;
		sum++;
		do
		{
			x=s[top--];
			col[x]=sum;
			v[x]=0;
			colw[sum]++;
		}while(now!=x);
	}
}
void topo()//G1DAG->G2 tree 
{
	queue<int> q;
	for(int i=1;i<=sum;i++)
	if(!d[i]) q.push(i);
	while(!q.empty())
	{
		int now=q.front();q.pop();
		for(int i=G1.head[now];i;i=G1.e[i].nxt)
		{
			d[G1.e[i].to]--;
			if(d[G1.e[i].to]==0)
			{
				G2.add(now,G1.e[i].to);
				ind[G1.e[i].to]++;
			//	cout<<now<<" "<<G1.e[i].to<<endl;
				q.push(G1.e[i].to);
			}
		}
	}
}
#undef sum
struct Hash
{
	unordered_map<int,int> mp;
	int cnt;
	void clear()
	{
		mp.clear();
		cnt=0;
	}
	int get(int x)
	{
		if(mp[x]==0) mp[x]=++cnt;
		return mp[x];
	}
}H;
void dfs1(int now,int fa)//G2 tree dfs ：lca，dfn（L），权值前缀和（sum） 
{
	f[now][0]=fa;
	L[now]=++Tot;
	dep[now]=dep[fa]+1;
	for(int i=1;i<=lg[dep[now]];i++)
	f[now][i]=f[f[now][i-1]][i-1];
	sum[now]=sum[fa]+colw[now];
	for(int i=G2.head[now];i;i=G2.e[i].nxt)
	{
		if(G2.e[i].to!=fa)
		dfs1(G2.e[i].to,now);
	}
}
int LCA(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y]) x=f[x][lg[dep[x]-dep[y]]-1];
	if(x==y) return x;
	for(int i=lg[dep[x]];i>=0;i--) 
	if(f[x][i]!=f[y][i])
	x=f[x][i],y=f[y][i];
	return f[x][0];
}
bool cmp(int x,int y)
{
	return L[x]<L[y];
}
int vis[30],vis2[30],vp[30],val[30];
int work()
{
	memset(vis,0,sizeof vis);
	memset(vp,0,sizeof vp);
	queue<int> q;
//	cout<<H.get(st)<<" "<<H.get(ed)<<endl;
	q.push(H.get(st));
	while(!q.empty())//G3 bfs
	{
		int now=q.front();q.pop();
		vp[now]=1;
		for(int i=G3.head[now];i;i=G3.e[i].nxt)
		{
			if(!vis[i])
			{
				vis[i]=1;
				q.push(G3.e[i].to);
			}
		}
	}
	int ans=0;
	memset(vis2,0,sizeof vis2);
	q.push(H.get(ed));
	while(!q.empty())//G4 bfs
	{
		int now=q.front();q.pop();
		if(vp[now]) ans+=val[now],vp[now]=0;
		for(int i=G4.head[now];i;i=G4.e[i].nxt)
		{
			if(!vis2[i])
			{
				vis2[i]=1;
				if(vis[i]) ans+=G4.e[i].v,vis[i]=0; 
				q.push(G4.e[i].to);
			}
		}
	}
	memset(val,0,sizeof val);
	return ans;
}
int main()
{
	n=read();m=read();q=read();k=read();
	for(int i=1;i<=n;i++)
	lg[i]=lg[i/2]+1;
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		add(u,v);
	}
	for(int i=1;i<=n;i++)
	if(!dfn[i]) dfs(i);
	for(int i=1;i<=n;i++)
	for(int j=head[i];j;j=e[j].nxt)
	if(col[i]!=col[e[j].to])
	G1.add(col[i],col[e[j].to]),d[col[e[j].to]]++;
	topo();
	int root=0;
	for(int i=1;i<=Sum;i++)
	if(ind[i]==0) root=i;
	dfs1(root,0);
	for(int i=1;i<=q;i++)
	{
		G3.clear();G4.clear();H.clear();
		st=read();ed=read();
		st=col[st];ed=col[ed];
		h[1]=st;h[2]=ed;
		top=0;
		for(int j=1;j<=k;j++)
		{
			int u=read(),v=read();
			u=col[u];v=col[v];
			if(u==v) continue;
			G3.add(H.get(u),H.get(v),0);
			G4.add(H.get(v),H.get(u),0);
			h[j*2+1]=u;h[j*2+2]=v;
		}
		sort(h+1,h+(k+1)*2+1,cmp);
		int qwq=unique(h+1,h+(k+1)*2+1)-h-1;
		for(int j=1;j<=qwq;j++)
		val[H.get(h[j])]=colw[h[j]];
		s[++top]=h[1];
		for(int j=2;j<=qwq;j++)
		{
			int lca=LCA(h[j],s[top]);
			val[H.get(lca)]=colw[lca];
			while(1)
			{
				if(dep[lca]>=dep[s[top-1]])
				{
					if(lca!=s[top])
					{
						G3.add(H.get(lca),H.get(s[top]),sum[f[s[top]][0]]-sum[lca]);
						G4.add(H.get(s[top]),H.get(lca),sum[f[s[top]][0]]-sum[lca]);
						if(lca!=s[top-1])
						s[top]=lca;
						else top--;
					}
					break;
				}
				else
				{
					G3.add(H.get(s[top-1]),H.get(s[top]),sum[f[s[top]][0]]-sum[s[top-1]]);
					G4.add(H.get(s[top]),H.get(s[top-1]),sum[f[s[top]][0]]-sum[s[top-1]]);
					top--;
				}
			}
			s[++top]=h[j];
		}
		while(top-1)
		{
	//		cout<<"qwq";
			G3.add(H.get(s[top-1]),H.get(s[top]),sum[f[s[top]][0]]-sum[s[top-1]]);
			G4.add(H.get(s[top]),H.get(s[top-1]),sum[f[s[top]][0]]-sum[s[top-1]]);
			top--;
		}
		printf("%d\n",work());
	}
	return 0;
}
/*
7 6 1 1
1 2
1 3
2 4
3 5
2 6
6 7
6 4 7 1
*/
/*
5
*/
```


---

## 作者：ix35 (赞：33)

史上最简单 D1T3，也许又是和其他人做法都不同。

显然 SCC 缩点后是一个树，注意构造树的细节：采用 tarjan 算法算出 SCC 后从零入度点 DFS，优先加入编号大的儿子可以保证正确。

$k=0$ 只需统计树上路径和。

$k=1$ 只需分几类讨论。

但是 $k$ 较大时分类讨论显著乏力，我们需要一个更好的刻画。

如果对于 $2\times k$ 个点中的某个点 $p$，满足 $s$ 可以到达 $p$，$p$ 可以到达 $t$，就称它为好点，$s,t$ 也是好点。

结论：一个点可以被经过，当前仅当有一个好点是它的祖先，且有一个好点是它的后代。

证明：考虑 $s$ 到它再到 $t$ 的路径，它上面和下面都会有一个好点。

所以我们只需要找出好点，然后用一个类似虚树构造的东西（但如果栈为空就不统计当前贡献），就可以轻松算出答案。

$k=2$ 时的好点可以分类讨论（情况数比直接分类少了一个数量级），$k>2$ 时也可以用 $O(k^2)$ 的做法求出，更好的办法没有仔细思考过。

使用 $O(1)$ LCA，时间复杂度为 $O(n\log n+q)$。

---

## 作者：唐一文 (赞：27)

首先缩点把环缩掉，变成一个有向无环图，然后再看一下题目：

> 对于三座城市 $x$，$y$，$z$，若 $x\Rightarrow z$ 且 $y\Rightarrow z$，那么有 $x\Rightarrow y$ 或 $y\Rightarrow x$。

对于一个点 $x$，假设有两条与之相连的边 $(a,x)$ 和 $(b,x)$，不妨设 $b\Rightarrow a$，那么将 $(b,x)$ 删去，$b$ 也能先走向 $a$ 再走到 $x$。

因此在拓扑排序时对每个点保留最后一条与之相连的入边不会对原图连通性有影响。

此时就变成了一棵树，注意是有向图，所以能从 $u$ 到达 $v$ 的前提是 $v$ 在 $u$ 子树中。

然后考虑询问操作：

发现每次新增的边数 $k$ 很小，感觉可以暴力，考虑 bfs。

从起点开始向外扩展能走到的新增的边的端点，并记录下走过的路径。

每次扩展前先判断此时能不能到达终点，若能走到，就先将走过的路径丢入桶中，后面再求并集。

然而发现会走很多次重复的路径，所以将扩展的次数记录下来，超过一定次数就不继续扩展。

可以先树剖一遍并记录下 dfs 序，走过的路径就可以拆成一些链求并。

到这里就基本上可以过了，只不过要注意一些优化：

- 如果能走到终点，就将之前记录下的路径清空，优化后面扩展时记录路径的时间。

- 如果一条路径已经在桶中，就没必要再加一遍。

实测扩展次数等于 $4$ 时可过，小于 $4$ 无法找到所有路径，大于 $4$ 会超时。

但是下面这个优化可以直接过：

- 新增的边的起点不需要入队，只需要终点入队。

实测扩展次数等于 $4$ 时可以过，如果三个优化都加上扩展次数在 $4\sim 7$ 时都可以过。

[代码](https://www.luogu.com.cn/paste/hize4p0o)也比较好写。

---

## 作者：feecle6418 (赞：23)

先观察题目给的条件，显然缩了点不影响可达性，那就先缩点。

设有两条边（缩了点之后）$(y,x),(z,x)$，那根据题目要么 $y$ 能到 $z$ 要么 $z$ 能到 $y$。不妨设 $y$ 能到 $z$，则此时删去 $(y,x)$ 一定不影响连通性。

因此，设一个点 $x$ 有几条入边 $(a,x),(b,x),\dots$，**只保留起点拓扑序最后的入边一定不影响连通性。**

根据以上性质，可以把整个图缩成一个有向图，每个点入度都至多为 $1$，这就是树。因此只需要解决 $m=n-1$ 的情况即可。

-  $K=0$：直接判断 $y$ 在不在 $x$ 子树里，在就输出 $x,y$ 链上强联通分量大小之和。
-  $K=1$：设加了 $(p,q)$，分两种情况，走了这条边或者不走这条边，稍微讨论下，留作练习。
-  $K=2$：可以证明要走过每个可能走过的点，每条新加的边至多走两次。分类讨论是怎么走的，及走的顺序。具体地有以下几种情况：
    - 不走新加的边。
    - $x$ 经过某一条新加的边走到 $y$。
    - $x$ 按顺序经过第一条新边、第二条新边（或相反）走到 $y$。
    - $x$ 先走到 $y$，然后经过 $1$ 或 $2$ 条新边绕一圈走回 $x$ 再走到 $y$。
    - $x$ 先走到 $y$，然后经过 $1$ 或 $2$ 条新边不经过 $x$ 绕一圈。
    - $x$ 先经过 $1$ 或 $2$ 条新边不经过 $y$ 绕一圈，然后走到 $y$。
    - $x$ 先走到某个新边的起点，在这个点经过 $1$ 或 $2$ 条新边不经过 $x,y$ 绕一圈，然后走到 $y$。
    
把以上所有情况可能经过的链求并，并上的点数就是答案。使用虚树/树剖都可以做到 $O(n\log n)$，常数不大。

---

## 作者：OUYE2020 (赞：14)


我们先想想暴力做法怎么做。一个城市如果可以被算入答案里面，那么它一定既可以被起点通过正向边到达，又可以被终点通过反向边到达。所以我们每次可以走正向边标记起点可达的顶点，再走反向边标记终点可达的顶点，答案即为拥有双重标记的点的数量。

题目特别说了这个道路是有特点的，说明此处一定有性质，所以我们稍稍挖掘一下。如果我们把有向图缩点，就可以发现此图一定不存在 $u\rightarrow y,v\rightarrow y$ 这样的路径，所以这个图一定有且仅有一个入度为 $0$ 的点。以这个点为根，会发现整个图长得像一棵树，所有路径要么从父亲指向儿子，要么从祖先跨代指向儿孙。由于我们需要知道的是正图反图中起点和终点最多可以到达的节点，所以这种跨代的边显然没有任何用，删去或忽略即可。

关于如何建这棵树和去掉多余边，可以用拓扑排序，最后一条删掉的入边对应顶点即为父亲节点。

![手稿1](https://img-blog.csdnimg.cn/df7fd59e44424745a4717adf7f7eee3a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2MDI4Nw==,size_16,color_FFFFFF,t_70)

把这棵树建出来以后，起点可达的范围和终点跑反边可达的范围都十分规范了。起点可以到达的范围就是它的子树，终点跑反边可以到达的范围就是它到根节点的一条路径。

所以对于不额外加边的询问，我们就有了单次 $O(1)$ 的解决办法：预处理每个点到根的路径上的节点总数（注意缩过点的一个节点可以包含多个原图上的点），然后每次先用DFS序判断终点是否在起点的子树内，然后简单地减一下即可。

那么对于额外加边的询问呢？假设加的一条边为 $u\rightarrow v$，如果 $u$ 在起点的子树内，那么 $v$ 所在的子树也可以从起点到达，也就是说，起点可达的范围可能会变成不包含的两棵子树。反过来对于终点，如果 $v$ 在终点到根的路径上，那么点 $u$ 到根的路径也会变为终点可达的范围，最终就有两条路径的范围。

我们通过这种添加范围的方法处理加入的两条边，并且把范围去重过后，起点可达的范围最多为三棵子树，终点可达的范围最多为三条到根的路径。这显然可以暴力枚举，把每棵子树下与路径重合的部分的贡献都算上。一次询问算上求 $\rm LCA$ 的时间，最坏也就 $O(27\cdot\log n)$，好的话可以通过优化循环和 $O(1)\,\rm LCA$ 做到 $O(9)$。

![手稿2](https://img-blog.csdnimg.cn/870830b711f742648002762e96c53be7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2MDI4Nw==,size_16,color_FFFFFF,t_70)

但是如果遇到上图的情况，先加入边 $b$ 再加入边 $a$ 的话，由于开始时 $U_b$ 不在起点可达的范围，$V_b$ 的子树不会算进去。这个好办，你把两条边来回多加入几次。反正只有两条边，做法多暴力都过得去。

总复杂度 $O(n\log n+q\cdot 9)\sim O(n\log n+q\log n\cdot 27)$。

# 代码

```cpp
#include<bits/stdc++.h>//JZM yyds!!
#define ll long long
#define MAXN 300005
#define uns unsigned
using namespace std;
inline ll read(){
	ll x=0;bool f=1;char s=getchar();
	while((s<'0'||s>'9')&&s>0){if(s=='-')f^=1;s=getchar();}
	while(s>='0'&&s<='9')x=(x<<1)+(x<<3)+s-'0',s=getchar();
	return f?x:-x;
}
int n,m,Q,k;
int u1,v1,u2,v2;
vector<int>G[MAXN],G_[MAXN],G__[MAXN];

int dfn[MAXN],NN,low[MAXN],bl[MAXN];
bool ist[MAXN];
stack<int>st;
int du[MAXN],num,siz[MAXN];

int fa[MAXN],f[MAXN][25],hd[MAXN],tl[MAXN],dp[MAXN],dep[MAXN],IN;

inline void tarjan(int x){
	low[x]=dfn[x]=++NN,st.push(x),ist[x]=1;
	for(uns i=0;i<G__[x].size();i++){
		int v=G__[x][i];
		if(!dfn[v])tarjan(v),low[x]=min(low[x],low[v]);
		else if(ist[v])low[x]=min(low[x],dfn[v]);
	}
	if(low[x]==dfn[x]){num++;
		while(!st.empty()&&dfn[st.top()]>=dfn[x])
			bl[st.top()]=num,ist[st.top()]=0,st.pop();
	}
}
queue<int>q;
int root;
inline void topu(){
	for(int i=1;i<=num;i++)if(!du[i])q.push(i),root=i;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(uns i=0;i<G_[u].size();i++){
			int v=G_[u][i];du[v]--;
			if(!du[v])
				G[u].push_back(v),fa[v]=u,q.push(v);
		}
	}
}
inline void dfs(int x){
	hd[x]=++IN,f[x][0]=fa[x];
	dp[x]=dp[fa[x]]+siz[x],dep[x]=dep[fa[x]]+1;
	for(int i=1;i<20;i++)f[x][i]=f[f[x][i-1]][i-1];
	for(uns i=0;i<G[x].size();i++)dfs(G[x][i]);
	tl[x]=IN;
}
inline int lca(int u,int v){
	if(dep[u]<dep[v])swap(u,v);
	for(int i=19;i>=0;i--)if(dep[f[u][i]]>=dep[v])u=f[u][i];
	if(u!=v){
		for(int i=19;i>=0;i--)
			if(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];
		u=fa[u];
	}
	return u;
}
vector<int>a,b;
inline void addedge(int u,int v){
	bool ok=0;
	for(uns i=0;i<a.size();i++)
		if(hd[u]>=hd[a[i]]&&hd[u]<=tl[a[i]])ok=1;
	if(ok){
		int h=0;
		for(uns i=0;i<a.size()&&h>=0;i++){
			if(hd[v]>=hd[a[i]]&&hd[v]<=tl[a[i]])h=-1;
			if(h>=0&&hd[a[i]]>hd[v]&&hd[a[i]]<=tl[v])h=1,a[i]=v;
		}
		for(uns i=0;i<a.size();i++){
			bool ok=1;
			for(uns j=0;j<i;j++)if(a[j]==a[i])ok=0;
			if(!ok)a.erase(a.begin()+i,a.begin()+i+1),i--;
		}
		if(h==0)a.push_back(v);
	}
	
	ok=0;
	for(uns i=0;i<b.size();i++)
		if(hd[b[i]]>=hd[v]&&hd[b[i]]<=tl[v])ok=1;
	if(ok){
		int h=0;
		for(uns i=0;i<b.size()&&h==0;i++){
			if(hd[b[i]]>=hd[u]&&hd[b[i]]<=tl[u])h=-1;
			if(h==0&&hd[u]>hd[b[i]]&&hd[u]<=tl[b[i]])h=1,b[i]=u;
		}
		if(h==0)b.push_back(u);
	}
}
signed main()
{
// 	freopen("celebration.in","r",stdin);
// 	freopen("celebration.out","w",stdout);
	n=read(),m=read(),Q=read(),k=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		G__[u].push_back(v);
	}
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	for(int x=1;x<=n;x++){
		siz[bl[x]]++;
		for(uns i=0;i<G__[x].size();i++){
			int v=G__[x][i];
			if(bl[v]!=bl[x])
				G_[bl[x]].push_back(bl[v]),du[bl[v]]++;
		}
	}
	topu(),dfs(root);
	for(int D=1;D<=Q;D++){
		int s=read(),t=read();
		a.clear(),b.clear(),u1=v1=u2=v2=0;
		a.push_back(bl[s]),b.push_back(bl[t]);
		if(k>0)u1=bl[read()],v1=bl[read()];
		if(k>1)u2=bl[read()],v2=bl[read()];
		if(u1==v1)u1=v1=0;
		if(u2==v2)u2=v2=0;
		if(u1)addedge(u1,v1);
		if(u2)addedge(u2,v2);
		if(u1)addedge(u1,v1);
		int ans=0;
		for(uns i=0;i<a.size();i++){
			for(uns j=0;j<b.size();j++){
				int c=a[i],d=b[j];
				if(hd[d]>=hd[c]&&hd[d]<=tl[c]){
					int lc=fa[c],glc;
					for(uns l=0;l<j;l++){
						glc=lca(b[l],d);
						if(dep[glc]>dep[lc])lc=glc;
					}
					ans+=dp[d]-dp[lc];
				}
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：wsyhb (赞：11)

注：本题为 NOI2021 D1T3。

## 题解

首先，本题只考虑可达关系，因此毫不犹豫地缩点+拓扑排序。

记所得图为 $G$，显然 $G$ 是一个有向无环图。

然后考虑题目条件：

1. 将 C 国原有的有向道路视为无向道路后，所有城市可以互达。
2. 若 $x \Rightarrow z$ 且 $y \Rightarrow z$，则 $x \Rightarrow y$ 或 $y \Rightarrow x$。

可知：**$G$ 中必然存在一个点，它能到达其它所有点，即 $G$ 形成一棵外向树**。

------------

### 证明

取 $G$ 中入度为 $0$ 的任意一个点为 $root$。

由条件 1 知，对于不同于 $root$ 的任意一个点 $x$，有以下四种情况：

1. $root \Rightarrow x$
1. $x \Rightarrow root$
1. 存在点 $y$ 满足 $x \Rightarrow y$ 且 $root \Rightarrow y$。
1. 存在点 $y$ 满足 $y \Rightarrow x$ 且 $y \Rightarrow root$。

由于 $root$ 入度为 $0$，第 2,4 种情况不可能出现。

对于第 3 种情况，由条件 2 知 $x \Rightarrow root$ 或 $root \Rightarrow x$。

因此一定有 $root \Rightarrow x$，即 $root$ 能到达其它所有点。

------------

（下文不再讨论原图，只讨论所得的外向树）

再考虑题目所求：额外加入 $k$ 条有向边，问有多少个点 $x$，满足 $s \Rightarrow x$ 且 $x \Rightarrow t$。

设 $S=\{x|s\Rightarrow x\}$，$T=\{x|x\Rightarrow t\}$，问题即求 $|S \cap T|$。

记 $x$ 的子树中点组成的集合为 $Sub_x$，$x$ 到根路径上点组成的集合为 $R_x$。

对于 $k=0$，有 $S=Sub_s$，$T=R_t$。

考虑新加入一条边 $a \to b$：

- 若 $a \in S$，则令 $S \leftarrow S \cup Sub_b$。
- 若 $b \in T$，则令 $T \leftarrow T \cup R_a$。

注意：**由于无法确定边的顺序，需要 $O(k^2)$ 尝试加入每条边。**

------------

那么如何记录 $S,T$ 并求解 $|S \cap T|$ 呢？

**$S$ 和 $T$ 其中一个在树剖线段树上打标记，另一个用数组记录点编号，在树剖线段树上查询即可。**

当然需要**处理重复计算**的问题，处理方式有三种：

1. （适用于 $S$ 在树剖线段树上打标记）处理到根路径的并集：记 $T$ 中点按树剖序从小到大排序依次为 $T_1,T_2,\cdots,T_{|T|}$，则答案为 $\sum_{i=1}^{|T|}R_{T_i}-\sum_{i=1}^{|T|-1}R_{\operatorname{LCA}(T_i,T_{i+1})}$。
2. （适用于 $T$ 在树剖线段树上打标记）处理子树的并集：记 $S$ 中点的子树的树剖序区间，按第一关键字为左端点升序，第二关键字为右端点降序排序，依次为 $[l_1,r_1],[l_2,r_2],\cdots,[l_{|S|},r_{|S|}]$。由于任意两个区间之间要么是包含关系，要么交集为空，因此答案为 $\sum_{i=1}^{|S|}[i=1 \lor l_i>r_{i-1}]Sub_i$。
3. （两者都适用）每次查询后将所查询区间赋值为 $0$。

三种方式**时间复杂度**均为 $O(m+(k^3+k^2\log{n}+k\log^2{n})q)$。

## 代码

P.S. 

1. 本题读入量是真的大，强烈建议加 fread/fwrite。
2. 由于代码巨长，所以都丢在剪贴板里了。
3. 为了让读者感受三种处理方式的效率差异，还附上了对应的提交记录。
4. 请注意：**在第三种处理方式中，12~14 及 20~25 这 9 个测试点用时均超过了 1s，即不保证第三种处理方式能在原题 1s 的时限下通过。**

[第一种：处理到根路径的并集](https://www.luogu.com.cn/paste/n14ln4pb)

[第二种：处理子树的并集](https://www.luogu.com.cn/paste/mnd4vzws)

[第三种：每次查询后将所查询区间赋值为 $0$](https://www.luogu.com.cn/paste/o9664fr0)

---

## 作者：warzone (赞：10)

# 题意
有点长，就不放了。
# 题解
考虑缩点：我们称 $x=y$，当且仅当 $x\Rightarrow y$ 且 $y\Rightarrow x$。

对于题目给出的性质：若 $x\Rightarrow z$ 且 $y\Rightarrow z$，则 $x\Rightarrow y$ 或 $y\Rightarrow x$。  
我们有两个与之对应的逆命题：
- 若 $x\Rightarrow y$ 且 $y\Rightarrow z$，则 $x\Rightarrow z$ 。
- 若 $y\Rightarrow x$ 且 $x\Rightarrow z$，则 $y\Rightarrow z$ 。

也就是说，题目给出的性质相当于以上两个逆命题必满足其一。  
推得，对于图上所有点 $z$，能到达 $z$ 的所有点必定按 $\Rightarrow$ 形成一条链，记为 $l_z$。

考虑该链上某个点 $x$，则能到达 $x$ 的所有点也形成一条链 $l_x$，且 $l_x$ 为 $l_z$ 的前缀。

“原有的有向道路视为无向道路后，所有城市可以互达”，因此，  
所有点必定会按照 $\Rightarrow$ 形成**一棵外向树**，可以缩点后一次拓扑排序，将多余的边剪掉后求出。

------------------------------------------------
回答询问是本题的第二个难点，这里采用一种不一样的分类讨论思路。  

设点 $u$ 所在强连通分量的大小为 $\mathrm{value}_u$，其子树为 $\mathrm{sub}_u$。

要输出的是 $s$ 到 $t$ 可能经过的所有点，考虑找出 $s$ 可以到达的所有点（组成点集 $\mathrm{begin}$），  
及所有可以到达 $t$ 的点（组成点集 $\mathrm{end}$），对两个点集取并即可。

若 $k=0$，$\mathrm{begin}$ 为 $s$ 的子树 $\mathrm{sub}_s$，  
$\mathrm{end}$ 为 $t$ 及其祖先（即链 $l_t$）,答案即 $\displaystyle\sum_{u\in\mathrm{sub}_s\cap l_t}\mathrm{value}_u$

取并过程可以树剖解决，分为如下两步：
- 对 $l_t$ 上所有点打上标记。
- 查询子树 $s$ 上所有打标记点的和。  
  
用线段树维护如上两个操作即可。

若 $k\not =0$，考虑“拓展”这两个点集：
- 对于 $\mathrm{end}$，有：
  - 若 $b\in\mathrm{end}$，则 $l_a\subseteq\mathrm{end}$ 。

  每次找出一个未加入且 $b\in\mathrm{end}$ 的边 $(a,b)$，对 $l_a$ 打上标记即可。  
  $b\in\mathrm{end}$ 即线段树上查询 $b$ 是否有标记。
- 对于 $\mathrm{begin}$，有：
  - 若 $a\in\mathrm{begin}$，则 $\mathrm{sub}_b\subseteq\mathrm{begin}$ 。
    
  $a\in\mathrm{begin}$ 可以树剖后直接 $\Theta(1)$ 查询。  

  此处要处理交集的情况。但我们有如下定理：
  - 对于树上两点 $u,v$，要么 $\mathrm{sub}_u\subseteq\mathrm{sub}_v$ 或 $\mathrm{sub}_u\supseteq\mathrm{sub}_v$，  
    要么 $\mathrm{sub}_u\cap\mathrm{sub}_v=\varnothing$ 。  

  因此待查询的必定是若干棵子树。插入 $\mathrm{sub}_b$ 时，
  - 若 $\exist u\in\mathrm{begin},\mathrm{sub}_b\subseteq\mathrm{sub}_u$，则 $b$ 被包含，插入失败。
  - 否则，插入成功，抹去所有被 $b$ 包含的待查询子树。  
  
  最后求出每个子树内答案的和即可。

# Code
```cpp
/*
this code is made by warzone
2021-7-27 13:57
*/
#include<stdio.h>
#include<string.h>
typedef unsigned int word;
typedef unsigned char byte;
const word siz=300005;
struct READ{//快读快写
    char c,w;
    inline READ(){c=getchar();}
    template<typename type>
    inline READ& operator >>(register type& num){
        for(w=1;'0'>c||c>'9';c=getchar())
            w=c=='-'? -1:1;
        for(num=0;'0'<=c&&c<='9';c=getchar())
            num=num*10+(c-'0');
        return num*=w,*this;
    }
}cin;
word n,m,q_,k,step,root;
word head[siz],tail[siz];
word to[siz<<1],next[siz<<1];
word in[siz],fa[siz];
word value[siz],segid[siz];
struct GRAPH{//原来的图
	word dfn[siz],low[siz];
	word stack[siz],stacksize;
	word tosize[siz];
	inline void tarjan(word id){
		dfn[id]=low[id]=++step;
		stack[++stacksize]=id;
		for(register word i=head[id];i;i=next[i]){
			if(dfn[to[i]]==0){
				tarjan(to[i]);
				if(low[id]>low[to[i]]) low[id]=low[to[i]];
			}else if(in[to[i]]==0&&low[id]>dfn[to[i]])
				low[id]=dfn[to[i]];
		}
		if(dfn[id]==low[id]){
			while(stack[stacksize]!=id)
				in[stack[stacksize--]]=id;
			in[stack[stacksize--]]=id;
		}
	}
	inline void connect(){//缩点
		for(register word id=1;id<=n;++value[in[id++]])
			if(in[id]==0) tarjan(id);
		for(register word id=1;id<=n;++id)
			if(in[id]!=id){
				next[tail[in[id]]]=head[id];
				tail[in[id]]=tail[id];	
			}
		for(register word id=1;id<=n;++id)
			if(in[id]==id) for(register word *i=head+id;*i;){
				while(*i&&id==in[to[*i]]) *i=next[*i];
				if(*i) ++tosize[to[*i]=in[to[*i]]],i=next+*i;
			}
	}
	struct queue{//队列
		word list[siz],head,tail;
		inline void flush(){head=tail=0;}
		inline void push(word in){
			list[tail]=in;
			if(++tail==300000) tail=0;
		}
		inline void pop(){
			if(++head==300000) head=0;}
		inline word& top(){return list[head];}
		inline bool empty(){return head==tail;}
	}q;
	inline void bfs(){//拓扑排序
		for(register word id=1;id<=n;++id)
			if(in[id]==id&&tosize[id]==0) root=id;
		fa[root]=0,q.flush(),q.push(root);
		for(register word id;!q.empty();){
			id=q.top(),q.pop();
			for(register word *i=head+id;*i;)
				if(--tosize[to[*i]]) *i=next[*i];
				else fa[to[*i]]=id,q.push(to[*i]),i=next+*i;
                //仅保留拓扑序最后的边
		}
	}
	inline void operator()(){
		cin>>n>>m>>q_>>k;
		for(register word i=1,from;i<=m;++i){
			cin>>from>>to[i];
			if(head[from]==0) head[from]=i;
			else next[tail[from]]=i;
			tail[from]=i;
		}
		connect(),bfs();
	}
};
template<word size>
struct segment_tree{//维护的线段树
	segment_tree<(size>>1)> l,r;
	word sum,max;
	byte tag;
	inline void operator()(word id){//初始化
		l(id<<1),r(id<<1|1);
		sum=0,tag=0xff;
		max=l.max+r.max;
	}
	inline void operator()(word f,word t,byte num){//打标记
		if(sum==max*num) return;
		if(f==0&&t==(size<<1)-1)
			return sum=max*num,void(tag=num);
		if(tag!=0xff){
			l(0,size-1,tag);
			r(0,size-1,tag);
			tag=0xff;
		}
		if(f&size) r(f&~size,t&~size,num);
		else if((t&size)^size) l(f,t,num);
		else l(f,size-1,num),r(0,t&~size,num);
		sum=l.sum+r.sum;
	}
	inline word operator()(word f,word t){//查询
		if(f==0&&t==(size<<1)-1) return sum;
		if(tag!=0xff){
			l(0,size-1,tag);
			r(0,size-1,tag);
			tag=0xff;
		}
		if(f&size) return r(f&~size,t&~size);
		else if((t&size)^size) return l(f,t);
		return l(f,size-1)+r(0,t&~size);
	}
};
template<>
struct segment_tree<0>{//特化最底层结点
	word sum,max;
	inline void operator()(word id){
		if(1<=id&&id<=step) sum=0,max=value[segid[id]];
		else sum=max=0;}
	inline void operator()(word f,word t,byte num){sum=max*num;}
	inline word operator()(word f,word t){return sum;}
};
struct TREE{//外向树
	word size[siz],floor[siz];
	word son[siz],topid[siz];
	word newid[siz];
	segment_tree<(1<<18)> tree;
	inline void dfs1(word id){//树剖求重儿子
		size[id]=1,son[id]=0;
		for(register word i=head[id];i;i=next[i]){
			floor[to[i]]=floor[id]+1;
			dfs1(to[i]),size[id]+=size[to[i]];
			if(size[son[id]]<size[to[i]]) son[id]=to[i];
		}
	}
	inline void dfs2(word id){//树剖重标号
		segid[newid[id]=++step]=id;
		if(son[id]) topid[son[id]]=topid[id],dfs2(son[id]);
		for(register word i=head[id];i;i=next[i])
			if(to[i]!=son[id]) topid[to[i]]=to[i],dfs2(to[i]);
	}	
	inline void operator()(){
		step=0,dfs1(root);
		topid[root]=root,dfs2(root);
		tree(0);
	}
#define isin(rt,ch) (newid[rt]<=newid[ch]&&newid[ch]<newid[rt]+size[rt])
#define ans(rt) tree(newid[rt],newid[rt]+size[rt]-1)
	inline void flush(word id){//标记链
		while(id){
			tree(newid[topid[id]],newid[id],1);
			id=fa[topid[id]];
		}
	}
	word a[2],b[2],use;
	word out[3],outsize;
	inline bool can(word id){//查询是否在 begin 中
		for(register word i=0;i<outsize;++i)
			if(isin(out[i],id)) return 1;
		return 0;
	}
	inline void insert(word id){//插入子树至 begin
		for(register word i=0;i<outsize;++i)
            if(isin(out[i],id)) return;//若 b 被包含，插入失败
            else if(isin(id,out[i])) out[i]=0;//抹去 b 包含的子树
		out[outsize++]=id;
	}
	inline word operator()(word s,word t){//回答询问
		s=in[s],flush(t=in[t]),use=0;
		for(register word i=0;i<k;++i)
			cin>>a[i]>>b[i],a[i]=in[a[i]],b[i]=in[b[i]];

		for(register word i=0;i<k;) for(i=0;i<k;++i)
			if(((use>>i&1)^1)&&tree(newid[b[i]],newid[b[i]])){
				flush(a[i]),use|=1<<i;break;}
                //处理 end
		out[0]=s,outsize=1,use=0;
		for(register word i=0;i<k;) for(i=0;i<k;++i)
			if(((use>>i&1)^1)&&can(a[i])){
				insert(b[i]),use|=1<<i;break;}
                //处理 begin
		register word get=0;
		for(register word i=0;i<outsize;++i)
			if(out[i]) get+=ans(out[i]);
		return tree(1,step,0),get;
	}
};
union{
	GRAPH graph;
	TREE tree;
}block;
int main(){
	block.graph();
	block.tree();
	for(word s,t;q_;--q_)
		cin>>s>>t,printf("%u\n",block.tree(s,t));
    return 0;
}
```

---

## 作者：JoyJoyGang (赞：9)

前置知识（后续依次使用到）：

[tarjan缩点](https://www.luogu.com.cn/problem/B3609)

[拓扑排序](https://www.luogu.com.cn/problem/P4017)

[tarjan缩点 + 拓扑排序](https://www.luogu.com.cn/problem/P3387)

[LCA](https://www.luogu.com.cn/problem/P3379)（树剖，倍增都可以）

[虚树](https://www.luogu.com.cn/problem/P2495)

题意描述
 
一开始我以为只能走一条路，就相当于有一队队伍，走到终点就结束。然而他是所有能从起点走到终点路都要算上。相当于很多队伍一起走，然后就卡了好久，暴力也写不出了。

剩下的题意就容易理解了。

开始进入正题

因为每个城市可以重复的走，一看就需要缩点，将互相可以走到的城市缩为一个点，记录点权为点集内城市的个数。此时，我们的图变为了一个有向无环图。

我们注意到这么一段话

- 如果从 $x$ 号城市出发，经过若干条道路后能到达 $y$ 号城市，那么我们称 $x$ 号城市可到达 $y$ 号城市，记作 $x\Rightarrow y$。C 国的道路有一个特点：对于三座城市 $x$，$y$，$z$，若 $x\Rightarrow z$ 且 $y\Rightarrow z$，那么有 $x\Rightarrow y$ 或 $y\Rightarrow x$。

这意味这什么呢？其实多画几个图就可以发现了，我们的有向无环图因为这个性质可以变成一棵树！

因为我们想要让队伍走过的点尽可能的多，那么当有 $x\Rightarrow z$ 且 $y\Rightarrow z$ 的时候，必定有 $x\Rightarrow y$ 或 $y\Rightarrow x$，那我们把图存为 $x \Rightarrow y\Rightarrow z$ 或者 $y \Rightarrow x\Rightarrow z$ 一定比直接存 $x\Rightarrow z$ 和 $y\Rightarrow z$ 两条边更好。所以每个点只可能有一个父亲节点，而每个点的父亲就是删边拓扑排序的时候最后删去的入度对应的点。再存一个新图，为一棵树。

注意在拓扑排序的时候顺道处理好从根结点到每个节点最多可以经过多少个点（注意：此时加上的是缩点后的点，有点权）。相当于一个树上的前缀和。这样储存好，要是 $x$ 和 $y$ 的 $LCA$ 为 $x$，那么 从 $x$ 到 $y$ 就最多经过 $dp[y]-dp[x]+si[x]$ 个点，$si[x]$ 为 $x$ 的点权。

这个时候
有两个选择

1. 我只拿部分分 $36$ 分

2. 还是写正解吧！

如果选择 1，那么我们就只写 $k=0$ 的情况，因为现在我们已经有一棵树了，显然可以知道一棵树两个点之间只有一条路径。而且这是一个叶向树，因此当 $x$ 可以走到 $y$，必须满足 $x$ 和 $y$ 的 $LCA$ 为 $x$，因此我们先利用我们的在线 $LCA$ 算法判断上述条件是否成立，然后利用树上前缀和就可以求出解了。这样 $36$ 分轻松到手！

[36 分代码](https://www.luogu.com.cn/paste/tganq0mv)
 

然后我们思考正解

有一个简单的暴力思路，分别建立正向的图对起点进行 $bfs$，建立反向图对终点进行 $bfs$ ，（记得新加的边也要反向加进去！），记录从起点可以走到哪些点，从终点可以走到哪些点，然后统计起点终点都可以走到的点就是答案。

没写过，不知道可以拿多少暴力分 qwq。

但是显然会超时

这个时候我们发现其实特殊点很少，其实最多就 $6$ 个，起点和终点，新加的边的起点和终点。因此我们考虑建立虚树

虚树的边权就是加到虚树两点之间的所有点权，（不包括两点的点权）通过树上前缀 $dp$ 可以轻松得到 $dp[y]-dp[x]-si[y]$。加上新加的 $k$ 边，然后跑上面的暴力就可以了。

最后清空虚树，因为我们两次 $bfs$ 都无法保证可以遍历到虚树上的所有点，（因为询问起点，不一定是虚树的根），无法在 $bfs$ 的时候去清空虚树，而如果要是用 memeset ,直接炸裂 $TLE$ 。因此我们再单独写一个清空的 $dfs$，从虚树的根遍历，不过此时我们加入了 $k$ 边，其实现在的图不一定是一棵树，因此我们 $dfs$ 的时候只遍历到标号 $i > k$ 的边，因为其他的边都是都是后加 $k$ 边。因为我们先加的 $k$ 边。

然后就 AC 了。还是很快的，不加快读也就 8.5s 多，加了快读可以 6.5s 多。

代码:

```cpp
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int MA=300005;
int n,m,q,k,head[MA],cnt=0,hed[MA],cn=0,hd[MA],co=0,hui[MA],cui=0,hei[MA],cei=0,dui[MA],sie;
struct zh{
	int x,y;
}a[MA*2],b[MA*2],c[MA*2],f[MA*2];
struct zhh{
	int x,y,z;
}g[MA*2];
void cua(int x,int y){
	a[++cnt].x=head[x];a[cnt].y=y;head[x]=cnt;
}
void cub(int x,int y){
	b[++cn].x=hed[x];b[cn].y=y;hed[x]=cn; 
}
void cuc(int x,int y){
	c[++co].x=hd[x];c[co].y=y;hd[x]=co;
}
void cud(int x,int y){
	f[++cui].x=hui[x];f[cui].y=y;hui[x]=cui;
}
void cue(int x,int y,int z){
	g[++cei].x=hei[x];g[cei].y=y;g[cei].z=z;hei[x]=cei;
}
struct qwq{
	int x,y;
}e[MA];
bool pei(qwq x,qwq y){
	if(x.y!=y.y){
		return x.y<y.y;
	}
}
int dfn[MA],lo[MA],dei[MA],bia[MA],si[MA],ci=0,ke=0,zu=0;
bool bol[MA];
void suo(int x){
	dfn[x]=lo[x]=++ci;dei[++ke]=x;bol[x]=1;
	for(int i=head[x];i;i=a[i].x){
		int j=a[i].y;
		if(dfn[j]==0){
			suo(j);lo[x]=min(lo[x],lo[j]);
		}
		else{
			if(bol[j]==1){
				lo[x]=min(lo[x],dfn[j]);
			}
		}
	}
	if(dfn[x]==lo[x]){
		++zu;int wo=0;
		while(dei[ke]!=x){
			++wo;int wu=dei[ke];bol[wu]=0;bia[wu]=zu;--ke;
		}
		int ki=dei[ke];bol[ki]=0;bia[ki]=zu;--ke;si[zu]=wo+1;
	}
}
int ru[MA],she[MA];
queue<int> p;
void tuo(){
	for(int i=1;i<=zu;i++){
		if(ru[i]==0){
			sie=i;p.push(i);she[i]=si[i];
		}
	}
	while(p.empty()==0){
		int x=p.front();p.pop();
		for(int i=hed[x];i;i=b[i].x){
			int j=b[i].y;--ru[j];
			if(ru[j]==0){
				cuc(x,j);she[j]=she[x]+si[j];p.push(j);
			}
		}
	}
}
struct tre{
	int shen,nu,topa,zhong,siz,fa;
}d[MA];
void dfa(int x,int fa){
	d[x].fa=fa;d[x].shen=d[fa].shen+1;d[x].siz=1;int maxn=0;
	for(int i=hd[x];i;i=c[i].x){
		int j=c[i].y;dfa(j,x);
		if(d[j].siz>maxn){
			maxn=d[j].siz;d[x].zhong=j;
		}
		d[x].siz+=d[j].siz;
	}
}
int kop=0;
void dfb(int x,int topa){
	d[x].topa=topa;d[x].nu=++kop;
	if(d[x].zhong!=0){
		dfb(d[x].zhong,topa);
		for(int i=hd[x];i;i=c[i].x){
			int j=c[i].y;
			if(j!=d[x].zhong){
				dfb(j,j); 
			}
		}		
	}
}
int cha(int x,int y){
	while(d[x].topa!=d[y].topa){
		if(d[d[x].topa].shen<d[d[y].topa].shen){
			swap(x,y);
		}
		x=d[d[x].topa].fa;
	}
	if(d[x].shen>d[y].shen){
		swap(x,y);
	}
	return x;
}
bool bda[MA],bba[MA],bdb[MA],bbb[MA];
void bfsa(int x){
	queue<int> qw;qw.push(x);
	while(qw.empty()==0){
		int ding=qw.front();qw.pop();bda[ding]=1;
		for(int i=hui[ding];i;i=f[i].x){
			int j=f[i].y;bba[i]=1;
			if(bda[j]==0){
				bda[j]=1;qw.push(j);
			}
		}
	}
}
void bfsb(int x){
	int ans=0;queue<int> qw;qw.push(x);
	while(qw.empty()==0){
		int ding=qw.front();qw.pop();
		if(bda[ding]==1){
			ans+=si[ding];bda[ding]=0;
		}
		bdb[ding]=1;
		for(int i=hei[ding];i;i=g[i].x){
			int j=g[i].y;bbb[i]=1;
			if(bba[i]==1){
				ans+=g[i].z;bba[i]=0;
			}
			if(bdb[j]==0){
				bdb[j]=1;qw.push(j);
			}
		}
	}
	printf("%d\n",ans);
}
int pan1=0,pan2=0;
void qing(int x){
	for(int i=hui[x];i;i=f[i].x){
		bba[i]=0;bbb[i]=0;int j=f[i].y;
		if(i>k){
			qing(j);
		}
	}
	hui[x]=hei[x]=bol[x]=bda[x]=bdb[x]=0;
}
void kk(){
	cui=cei=pan1=pan2=0;int s,t,le=0;scanf("%d%d",&s,&t);s=bia[s];t=bia[t];
	e[++le].x=s;e[le].y=d[s].nu;bol[s]=1;
	if(bol[t]==0){
		e[++le].x=t;e[le].y=d[t].nu;bol[t]=1;
	}
	for(int i=1;i<=k;i++){
		int x,y;scanf("%d%d",&x,&y);x=bia[x];y=bia[y];
		if(bol[x]==0){
			e[++le].x=x;e[le].y=d[x].nu;bol[x]=1;
		}
		if(bol[y]==0){
			e[++le].x=y;e[le].y=d[y].nu;bol[y]=1;
		}
		cud(x,y);cue(y,x,0);
	}
	sort(e+1,e+1+le,pei);int top=1;dui[1]=e[1].x;
	for(int i=2;i<=le;i++){
		int xian=e[i].x;int gon=cha(xian,dui[top]);
		while(1){
			if(d[gon].shen>=d[dui[top-1]].shen){
				if(gon!=dui[top]){
					cud(gon,dui[top]);
					cue(dui[top],gon,she[dui[top]]-she[gon]-si[dui[top]]);
					if(gon!=dui[top-1]){
						dui[top]=gon;
					}
					else{
						--top;
					}
				}
				break;
			}
			else{
				cud(dui[top-1],dui[top]);
				cue(dui[top],dui[top-1],she[dui[top]]-she[dui[top-1]]-si[dui[top]]);
				--top;
			}
		}
		dui[++top]=xian;
	}
	while(--top){
		cud(dui[top],dui[top+1]);
		cue(dui[top+1],dui[top],she[dui[top+1]]-she[dui[top]]-si[dui[top+1]]);
	}
	bfsa(s);bfsb(t);qing(dui[1]);
}
int main(){
	scanf("%d%d%d%d",&n,&m,&q,&k);
	for(int i=1;i<=m;i++){
		int x,y;scanf("%d%d",&x,&y);cua(x,y);
	}
	for(int i=1;i<=n;i++){
		if(dfn[i]==0){
			suo(i); 
		}
	}
	for(int i=1;i<=n;i++){
		int hu=bia[i];
		for(int j=head[i];j;j=a[j].x){
			int hy=bia[a[j].y];
			if(hu!=hy){
				cub(hu,hy);++ru[hy];
			}
		}
	}
	tuo();dfa(sie,0);dfb(sie,sie);
	for(int i=1;i<=q;i++){
		if(k==0){
			int s,t;scanf("%d%d",&s,&t);
			int he=bia[s],ha=bia[t];int oo=cha(he,ha);
			if(oo==he){
				if(oo==he){
					printf("%d\n",she[ha]-she[he]+si[he]);
				}
			}
			else{
				printf("0\n");
			}			
		}
		else{
			kk();
		}
	}
	return 0;
}
```




---

## 作者：EnofTaiPeople (赞：8)

对于这道题，由于只需要考虑连通性，还是有向图，所以先缩点。

缩完点之后，根据图的特殊性质，我们可以将一些删去不影响连通性的边删除，具体的，每一个点只保留拓扑序最靠后的入边，于是这样就将原图变成了一棵树。

树剖之后，可以方便地找到某一个点是否是另一个点的祖先，于是我们可以大胆地暴搜，找到每一条符合要求的路径，对路径进行覆盖：
1. 将有关点能否到达终点的信息求出来，可以从终点反向广搜；
2. 从起点出发广搜，一条路径被使用需要要求它的终点可以到达路程 的终点。

路径覆盖可以使用珂朵莉树，总复杂度 $O(qk^2\log_2n\log_2\log_2n)$，并没有虚树那样优秀，但是可以通过：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ST static
#define STL ST inline
const int N=3e5+5;
STL char gc(){
    ST char buf[N+5];ST int it,ed;
    return (it==ed&&(ed=(it=0)+fread(buf,1,N,stdin),it==ed))?EOF:buf[it++];
}
template<typename _T_p>
STL void read(_T_p &x){
    bool f=0;char c=gc();
    while(c<48){if(c=='-')f=!f;c=gc();}
    for(x=0;c>47;x=x*10+(48^c),c=gc());
    if(f)x=-x;
}
namespace celebration{
    int n,m,Q,k,dfn[N],low[N],inc[N],dlt,f[N];
    int scc,sg[N],stk[N],t,sf[N],sct[N],ans;
    vector<int>lk[N],eg[N];
    void tarjan(int x){
        dfn[x]=low[x]=++dlt,stk[++t]=x;
        for(int y:lk[x])
            if(dfn[y]){
                if(!inc[y]&&dfn[y]<low[x])low[x]=dfn[y];
            }else{
                tarjan(y);if(low[y]<low[x])low[x]=low[y];
            }
        if(dfn[x]==low[x]){
            ++scc;do inc[stk[t]]=scc,++sct[scc];
                while(stk[t--]!=x);
        }return;
    }
#define g(x) dfn[x]
#define t(x) stk[x]
#define s(x) sg[x]
#define h(x) low[x]
    void dfs1(int x=scc){
        s(x)=1,h(x)=0;
        for(int y:lk[x]){
            f[y]=x,dfs1(y),s(x)+=s(y);
            if(s(y)>s(h(x)))h(x)=y;
        }
    }
    void dfs2(int x=scc){
        g(x)=++dlt;
        if(h(x)){
            t(h(x))=t(x),dfs2(h(x));
            for(int y:lk[x])
                if(y!=h(x))
                    t(y)=y,dfs2(y);
        }
    }
    STL bool In(int x,int y){
        return g(x)>=g(y)&&g(x)<g(y)+s(y);
    }
    struct ODT{
        int l,r;mutable int d;
        inline bool operator<(const ODT &z)
        const{return l<z.l;}
    };
    set<ODT>st;
    set<ODT>::iterator it,L,R;
    inline void del(){
        st.clear(),st.insert({1,scc,0});
    }
    inline set<ODT>::iterator split(int x){
        if(x>scc)return st.end();
        it=st.lower_bound({x});
        if(it!=st.end()&&it->l==x)return it;
        --it;int l=it->l,r=it->r,d=it->d;
        st.erase(it);st.insert({l,x-1,d});
        return st.insert({x,r,d}).first;
    }
    inline void mak(int l,int r){
        R=split(r+1),L=split(l);
        st.erase(L,R),st.insert({l,r,1});
    }
    inline void cg(int x,int y){
        while(t(y)!=t(x))
            mak(g(t(y)),g(y)),y=f[t(y)];
        mak(g(x),g(y));
    }
    vector<int>tmp;
    inline void sol(int x){
        int i;for(i=1;i<x;i+=2)
            if(!In(tmp[i],tmp[i-1]))return;
        for(i=1;i<x;i+=2)cg(tmp[i-1],tmp[i]);
    }
    bitset<5>cn,vs;
    int q[50],l,r;
    int main(){
        read(n),read(m),read(Q),read(k);
        int i,x,y,u1,v1,u2,v2,p;
        for(i=1;i<=m;++i){
            read(x),read(y);
            lk[x].push_back(y);
        }
        for(x=1;x<=n;++x)
            if(!dfn[x])tarjan(x);
        for(x=1;x<=n;++x){
            for(int y:lk[x])
                if(inc[y]<inc[x])
                    eg[inc[x]].push_back(inc[y]),++sg[inc[y]];
            lk[x].clear();
        }
        for(x=scc;x;--x)
            for(int y:eg[x])
                if(!--sg[y])lk[x].push_back(y);
        dlt=0,dfs1(),t(scc)=scc,dfs2();
        for(x=1;x<=scc;++x)
            sf[g(x)]=sct[x];
        for(x=2;x<=scc;++x)sf[x]+=sf[x-1];
        while(Q--){
            read(x),read(y),del();
            x=inc[x],y=inc[y],u1=v1=u2=v2=1;
            if(k){
                read(u1),read(v1),u1=inc[u1],v1=inc[v1];
                if(k==2)read(u2),read(v2),u2=inc[u2],v2=inc[v2];
            }
            q[l=r=1]=2,cn.reset(),cn[2]=1;
            while(l<=r){
                p=q[l++];
                switch(p){
                    case 1:if(!cn[3]&&In(x,v1))cn[q[++r]=3]=1;
                        if(!cn[4]&&In(x,v2))cn[q[++r]=4]=1;break;
                    case 2:if(In(y,x))cn[q[++r]=1]=1;
                        if(In(y,v1))cn[q[++r]=3]=1;
                        if(In(y,v2))cn[q[++r]=4]=1;break;
                    case 3:if(!cn[1]&&In(u1,x))cn[q[++r]=1]=1;
                        if(!cn[4]&&In(u1,v2))cn[q[++r]=4]=1;break;
                    case 4:if(!cn[1]&&In(u2,x))cn[q[++r]=1]=1;
                        if(!cn[3]&&In(u2,v1))cn[q[++r]=3]=1;
                    default:break;
                }
            }q[l=r=1]=1,vs.reset();
            while(l<=r){
                if(vs[p=q[l++]])continue;
                else vs[p]=1;
                switch(p){
                    case 1:if(cn[3]&&In(u1,x))q[++r]=3,cg(x,u1);
                        if(cn[4]&&In(u2,x))q[++r]=4,cg(x,u2);
                        if(cn[2]&&In(y,x))cg(x,y),q[++r]=2;break;
                    case 2:if(cn[3]&&In(u1,y))q[++r]=3,cg(y,u1);
                        if(cn[4]&&In(u2,y))q[++r]=4,cg(y,u2);
                        if(cn[1]&&In(x,y))cg(y,x),q[++r]=1;break;
                    case 3:if(cn[1]&&In(x,v1))q[++r]=1,cg(v1,x);
                        if(cn[2]&&In(y,v1))q[++r]=2,cg(v1,y);
                        if(cn[4]&&In(u2,v1))q[++r]=4,cg(v1,u2);break;
                    case 4:if(cn[1]&&In(x,v2))q[++r]=1,cg(v2,x);
                        if(cn[2]&&In(y,v2))q[++r]=2,cg(v2,y);
                        if(cn[3]&&In(u1,v2))q[++r]=3,cg(v2,u1);
                    default:break;
                }
            }ans=0;
            for(ODT it:st)
                if(it.d)ans+=sf[it.r]-sf[it.l-1];
            printf("%d\n",ans);
        }
        return 0;
    }
}
int main(){
    return celebration::main();
}
```

---

## 作者：jun头吉吉 (赞：8)

## 题意
能出 $\rm NOI$ 的神仙题意讲得肯定比蒟蒻好，就不自取其辱了
## 题解
小蒟蒻做这道题场上只会 $1\sim 14$ 差一点就做出来了，果然技不如人。

### $1\sim 7$
有个比较显然的想法，算出 $s$ 能到的点，在反图上跑出 $t$ 能到的点，于是取交集就是答案了。$\mathcal O(nq)$ 能过。
### $8\sim 9$ 是一棵树并且 $k=0$
冷静分析一下一个节点入度不可能大于 $1$，考虑若 $a\to u,b\to u$，按照题意 $a\Rightarrow b\lor b\Rightarrow a$，但在树上当两者都与 $u$ 有边时不珂能到达。于是我们可以得出这棵树一定是一棵外向树了。

于是如果 $t$ 在 $s$ 的子树内输出深度差，否则就是 $0$。
### $10\sim 14$ 是一棵树，没有其他限制
外向树的结论不变，但是会加边。有一个比较显然的想法，用一个树剖去维护 $s$ 现在能到那些点，$t$ 在反图上能到那些点。对于 $x\to y$，如果 $s$ 能到 $x$，那么 $y$ 的子树也能到达。$t$ 同理，是一条到根的链。

可以不用分类讨论，感觉是只要跑 $k$ 遍一定能把该到的点全部找出来。

有一个 $\rm Naive$ 的想法是直接用树剖暴力维护上面的操作，在线段树上区间修改。是 $\mathcal O(n\log^2n)$ 的，因为要跑好几次常数巨大，在 $\rm luogu$ 的 $\rm 2s$ 宽松的时限下只能得到 $\rm 44pts$。

换一种思路，不需要用线段树，因为修改和查询的区间其实不多，但是每一次查询都是 $\mathcal O(\log n)$ 的，感觉血亏。把区间保存下来，得到一些不交区间，然后暴力计算得到交集。

于是就能过了。得到了 $\rm 56pts$
### $15\sim 20$ 没有任何限制
现在没有树了，考虑刚才的做法，唯一的依赖就是入度唯一，是一颗外向树。先缩一波点那么肯定是 $\rm DAG$，根据题目中的条件，如果一个点有两个入度 $x\to u,y\to u$，假设 $x\Rightarrow y$，那么 $x\to u$ 就被 $x\Rightarrow y,y\to u$ 打爆了！换句话说，完全可以删去 $x\to u$ 而不影响图的连通性。

现在只需要能判断是 $x\Rightarrow y$ 还是 $y\Rightarrow x$ 就做完了。因为是 $\rm DAG$ 所以可以拓扑排序，比一下拓扑序就可以判断是从谁到谁了。

于是 $\rm NOI2021D1T3$ 就被完全攻克了！
## 代码
跑得很慢仅供参考
```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T>
void read(T&x){
	x=0;char c=getchar();for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
}
template<class T>void write(T x){if(x>=10)write(x/10);putchar(x%10+'0');}
template<class T>void write(T x,char end){write(x);putchar(end);}
const int N=300000+100;
int n,m,q,k;
namespace Tarjan{
	vector<int>e[N];bool ins[N];stack<int>s;
	int dfn[N],low[N],col[N],sz[N];int cnt,tot;
	void dfs(int u){
		dfn[u]=low[u]=++cnt;s.push(u);ins[u]=1;
		for(auto v:e[u]){
			if(!dfn[v])dfs(v),low[u]=min(low[u],low[v]);
			else if(ins[v])low[u]=min(low[u],dfn[v]);
		}
		if(low[u]==dfn[u]){
			tot++;int tmp=0;
			while(tmp!=u){
				tmp=s.top();s.pop();ins[tmp]=0;
				col[tmp]=tot;sz[tot]++;
			}
		}
	}
}


int deg[N],dep[N],dfn[N],cnt=1;
int sz[N],top[N];int fa[N];
int x[3],y[3];
set<int>G[N],GG[N];int si[N];

void dfs1(int u){
	dep[u]=dep[fa[u]]+1;sz[u]=1;si[u]=Tarjan::sz[u];
	for(auto v:G[u])
		fa[v]=u,dfs1(v),sz[u]+=sz[v],si[u]+=si[v];
}
void dfs2(int u){
	if(!top[u])top[u]=u;
	dfn[u]=cnt;cnt+=Tarjan::sz[u];
	if(sz[u]==1)return;
	pair<int,int>mx={0,0};
	for(auto v:G[u])mx=max(mx,make_pair(sz[v],v));
	top[mx.second]=top[u];
	dfs2(mx.second);
	for(auto v:G[u])if(v!=mx.second)dfs2(v);
}
int rt;
vector<pair<int,int>>S,T;vector<int>SP,TP;
bool in(int x,int y){
	return dfn[y]<=dfn[x]&&dfn[x]<=dfn[y]+si[y]-1;
}
void upd(int x){
	while(x){
		T.push_back({dfn[top[x]],dfn[x]+Tarjan::sz[x]-1});
		x=fa[top[x]];
	}
}
void deal(vector<pair<int,int>>&A){
	//对A变成不交区间
	sort(A.begin(),A.end());
	int l=A.front().first,r=A.front().second;
	vector<pair<int,int>>res;
	for(int i=1;i<A.size();i++){
		assert(A[i].first<=A[i].second);
		if(r<A[i].first){
			res.push_back({l,r});
			l=A[i].first,r=A[i].second;
		}else if(A[i].second>r)r=A[i].second;
	}
	res.push_back({l,r});
	A=res;
}
int rk[N];
void work(){
	for(int i=1;i<=m;i++){
		int x,y;read(x);read(y);
		Tarjan::e[x].push_back(y);
	}
	for(int i=1;i<=n;i++)if(!Tarjan::dfn[i])Tarjan::dfs(i);
	for(int i=1;i<=n;i++)
		for(auto j:Tarjan::e[i])
			if(Tarjan::col[i]!=Tarjan::col[j])
				G[Tarjan::col[i]].insert(Tarjan::col[j]),
				GG[Tarjan::col[j]].insert(Tarjan::col[i]);
	n=Tarjan::tot;
	for(int i=1;i<=n;i++)
		for(auto j:G[i])deg[j]++;
	int rt=0;for(int i=1;i<=n;i++)if(!deg[i])rt=i;
	queue<int>Q;Q.push(rt);int now=0;
	while(Q.size()){
		int u=Q.front();Q.pop();rk[u]=++now;
		for(auto v:G[u]){
			deg[v]--;if(deg[v]==0)Q.push(v);
		}
	}
	for(int i=1;i<=n;i++){
		while(GG[i].size()>=2){
			int u=*GG[i].begin();GG[i].erase(GG[i].begin());
			int v=*GG[i].begin();GG[i].erase(GG[i].begin());
			if(rk[u]<rk[v])
				GG[i].insert(v),G[u].erase(i);
			else
				GG[i].insert(u),G[v].erase(i);
		}
	}
	dfs1(rt);
	dfs2(rt);
	while(q--){
		int s,t;read(s);read(t);s=Tarjan::col[s];t=Tarjan::col[t];
		for(int i=1;i<=k;i++)read(x[i]),read(y[i]),x[i]=Tarjan::col[x[i]],y[i]=Tarjan::col[y[i]];
		S.clear();T.clear();SP.clear();TP.clear();
		
		S.push_back({dfn[s],dfn[s]+si[s]-1});SP.push_back(s);
		TP.push_back(t);upd(t);
		
		static bool flag[10];
		
		memset(flag,0,sizeof flag);
		for(int SJYAKNOI=1;SJYAKNOI<=k;SJYAKNOI++){
			for(int i=1;i<=k;i++){
				if(flag[i])continue;
				for(auto A:SP)if(in(x[i],A)){
					SP.push_back(y[i]),S.push_back({dfn[y[i]],dfn[y[i]]+si[y[i]]-1});
					flag[i]=1;break;
				}
			}
		}
		memset(flag,0,sizeof flag);
		for(int SJYAKNOI=1;SJYAKNOI<=k;SJYAKNOI++){
			for(int i=1;i<=k;i++){
				if(flag[i])continue;
				for(auto A:TP)if(in(A,y[i])){
					TP.push_back(x[i]),upd(x[i]);
					flag[i]=1;break;
				}
			}
		}
		deal(S);deal(T);
		int ans=0;
		for(auto [l,r]:T)
			for(auto [ql,qr]:S)
				if(r>=ql&&qr>=l)
					ans+=min(r,qr)-max(ql,l)+1;
		write(ans,'\n');
	}
}
signed main(){
	//freopen("celebration.in","r",stdin);
	//freopen("celebration.out","w",stdout);
	read(n);read(m);read(q);read(k);
	work();
}
```

---

## 作者：Leasier (赞：3)

前置芝士：[强连通分量](https://oi-wiki.org/graph/scc/)、[拓扑排序](https://oi-wiki.org/graph/topo/)、[虚树](https://oi-wiki.org/graph/virtual-tree/)

看到有向图不妨先缩个点，不难发现缩点后的 DAG 仍满足题述条件。注意到原图是弱连通图，显然缩点后的 DAG 仍为弱连通图。

感觉现在不是很好做了，考虑 $m = n - 1$ 的部分分。

考虑对于一个入度 $> 1$ 的点 $z$，假设有两条边 $x \to z, y \to z$，不妨假设 $x \Rightarrow y$，而此时原图为一棵“弱连通树”，于是显然矛盾。因而我们有结论：**当原图为一棵“弱连通树”，原图所有节点的入度 $\leq 1$，即原图为一棵树。**

对于一棵树，我们容易找出其根。现在考虑如何回答询问。注意到 $k$ 很小，不妨尝试分类讨论。

$k = 0$ 时，当 $s$ 不为 $t$ 的祖先，答案为 $0$；否则，答案为 $depth_s - depth_t + 1$。

$k = 1, 2$ 时，可以分类讨论，但我 $k = 2$ 讨论挂了，所以考虑不需要分类讨论怎么做。

为了减小讨论规模，我们将根、$s, t$ 和所有 $u, v$ 抓出来当关键点建虚树。此时树的规模减小到了 $O(k)$。

为了方便，我们拆掉虚树上的树边，将 $u \to v$ 拆成 $u \to w \to v$，并给原树上的点赋权为 $1$，给拆出来的点赋权为 $u, v$ 之间（不含 $u, v$）的点数，因为中间那些点要么都可以走到，要么都不可以走到。

现在我们把那 $k$ 条非树边扔到虚树里，问题转变为求在现在的图上从 $s$ 走到 $t$ 所能经过的点数。这可以缩点后拓扑排序解决。

回到一般情况来，直接在 DAG 上处理原问题是困难的，但我们已经解决了树的情况，不妨考虑将 DAG 转化为一棵树并沿用上述方法。

不妨仿照前文讨论。考虑对于一个入度 $> 1$ 的点 $z$，假设有两条边 $x \to z, y \to z$，不妨假设 $x \Rightarrow y$，则我们可以**认为 $x \to z$ 这条边是无意义的，因为我们可以只保留第二条边达成跟也保留第一条边一样的连通性**。

有了这个结论，我们可以删掉一些边使得原图变成一棵树，从而沿用前述方法。

根据题给条件可知，我们可以找到**恰好**一个点 $R$，使得其入度 $= 1$。我们先以它为我们希望得到的树的根。

现在考虑对于一个点 $z$，我们需要保留哪条边，也就是它的父亲节点是谁。

考虑用拓扑排序建树。$\forall u \neq R$，令 $fa_u$ 为所有 $v \to u$ 中拓扑序最大的 $v$。显然这是一棵树，且不存在上文提到的 $x = u$ 时对应的 $y$。

出于常数原因，建议使用 $O(1)$ LCA。时间复杂度为 $O(n \log n + m + qk \log k)$。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
#include <cstdio>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int start;
	int end;
	int dis;
} Edge;

typedef struct Node_tag {
	int pos;
	int dfn;
	Node_tag(){}
	Node_tag(int pos_, int dfn_){
		pos = pos_;
		dfn = dfn_;
	}
} Node;

int cnt1 = 0, cnt2 = 0, cnt3 = 0;
int u[600007], v[600007], head1[300007], dfn[300007], low[300007], belong1[300007], size1[300017], head2[300007], deg[300007], head3[300007], depth[300007], in[300007], fst[300007], euler[600007], out[300007], fa[300007], sum[300007], _log2[600007], st[600007][27], rnk[300017], size2[27], mark[27], belong2[27];
bool vis1[300007], vis2[300007], vis3[300007], vis4[27];
Edge edge1[600007], edge2[600007], edge3[300007];
Node a[27];
stack<int> stk;
queue<int> que;

bool operator <(const Node a, const Node b){
	return a.dfn < b.dfn;
}

bool operator ==(const Node a, const Node b){
	return a.pos == b.pos;
}

inline int shallow(int u, int v){
	return depth[u] < depth[v] ? u : v;
}

inline void init1(int n){
	int m;
	for (register int i = 2; i <= n; i++){
		_log2[i] = _log2[i >> 1] + 1;
	}
	m = _log2[n];
	for (register int i = 1; i <= n; i++){
		st[i][0] = euler[i];
	}
	for (register int i = 1; i <= m; i++){
		int id = i - 1, t1 = n - (1 << i) + 1, t2 = 1 << id;
		for (register int j = 1; j <= t1; j++){
			st[j][i] = shallow(st[j][id], st[j + t2][id]);
		}
	}
}

inline void init2(int n){
	cnt1 = cnt2 = 0;
	for (register int i = 1; i <= n; i++){
		head1[i] = head2[i] = size2[i] = deg[i] = 0;
		mark[i] = 1 << (i - 1);
		vis1[i] = false;
	}
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline void add_edge1(int start, int end){
	cnt1++;
	edge1[cnt1].nxt = head1[start];
	head1[start] = cnt1;
	edge1[cnt1].start = start;
	edge1[cnt1].end = end;
}

void tarjan(int u, int &id, int &scc_cnt){
	dfn[u] = low[u] = ++id;
	vis1[u] = vis2[u] = true;
	stk.push(u);
	for (register int i = head1[u]; i != 0; i = edge1[i].nxt){
		int x = edge1[i].end;
		if (!vis1[x]){
			tarjan(x, id, scc_cnt);
			low[u] = min(low[u], low[x]);
		} else if (vis2[x]){
			low[u] = min(low[u], dfn[x]);
		}
	}
	if (dfn[u] == low[u]){
		int cur;
		scc_cnt++;
		do {
			cur = stk.top();
			stk.pop();
			vis2[cur] = false;
			belong1[cur] = scc_cnt;
			size1[scc_cnt]++;
		} while (cur != u);
	}
}

inline void add_edge2(int start, int end){
	cnt2++;
	edge2[cnt2].nxt = head2[start];
	head2[start] = cnt2;
	edge2[cnt2].end = end;
}

inline void add_edge3(int start, int end){
	cnt3++;
	edge3[cnt3].nxt = head3[start];
	head3[start] = cnt3;
	edge3[cnt3].end = end;
}

void dfs1(int u, int father, int &id1, int &id2){
	depth[u] = depth[father] + 1;
	in[u] = ++id1;
	id2++;
	fst[u] = id2;
	euler[id2] = u;
	fa[u] = father;
	sum[u] = sum[father] + size1[u];
	for (register int i = head3[u]; i != 0; i = edge3[i].nxt){
		dfs1(edge3[i].end, u, id1, id2);
		euler[++id2] = u;
	}
	out[u] = id1;
}

inline int lca(int u, int v){
	int t;
	u = fst[u];
	v = fst[v];
	t = _log2[v - u + 1];
	return shallow(st[u][t], st[v - (1 << t) + 1][t]);
}

inline bool check(int u, int v){
	return in[u] <= in[v] && in[v] <= out[u];
}

void tarjan2(int u, int &id, int &scc_cnt){
	dfn[u] = low[u] = ++id;
	vis1[u] = vis2[u] = true;
	stk.push(u);
	for (register int i = head1[u]; i != 0; i = edge1[i].nxt){
		int x = edge1[i].end;
		if (!vis1[x]){
			tarjan2(x, id, scc_cnt);
			low[u] = min(low[u], low[x]);
		} else if (vis2[x]){
			low[u] = min(low[u], dfn[x]);
		}
	}
	if (dfn[u] == low[u]){
		int cur;
		scc_cnt++;
		do {
			cur = stk.top();
			stk.pop();
			vis2[cur] = false;
			belong2[cur] = scc_cnt;
		} while (cur != u);
	}
}

void dfs2(int u){
	for (register int i = head2[u]; i != 0; i = edge2[i].nxt){
		int x = edge2[i].end;
		if (!vis4[i]){
			vis4[i] = true;
			deg[x]++;
			dfs2(x);
		}
	}
}

int main(){
	int n = read(), m = read(), q = read(), k = read(), dfn_id = 0, euler_id = 0, scc_cnt = 0, root;
	for (register int i = 1; i <= m; i++){
		u[i] = read();
		v[i] = read();
		add_edge1(u[i], v[i]);
	}
	for (register int i = 1; i <= n; i++){
		if (!vis1[i]) tarjan(i, dfn_id, scc_cnt);
	}
	for (register int i = 1; i <= m; i++){
		if (belong1[u[i]] != belong1[v[i]]){
			deg[belong1[v[i]]]++;
			add_edge2(belong1[u[i]], belong1[v[i]]);
		}
	}
	for (register int i = 1; i <= scc_cnt; i++){
		if (deg[i] == 0){
			root = i;
			break;
		}
	}
	que.push(root);
	while (!que.empty()){
		int cur = que.front();
		que.pop();
		for (register int i = head2[cur]; i != 0; i = edge2[i].nxt){
			int x = edge2[i].end;
			if (--deg[x] == 0){
				add_edge3(cur, x);
				que.push(x);
			}
		}
	}
	dfn_id = 0;
	dfs1(root, 0, dfn_id, euler_id);
	init1(euler_id);
	for (register int i = 1; i <= q; i++){
		int s = belong1[read()], t = belong1[read()], dot_cnt1 = 0, dot_cnt2, dot_cnt3, ans = 0;
		a[++dot_cnt1] = Node(s, in[s]);
		a[++dot_cnt1] = Node(t, in[t]);
		vis3[s] = vis3[t] = true;
		for (register int j = 1; j <= k; j++){
			u[j] = belong1[read()];
			v[j] = belong1[read()];
			a[++dot_cnt1] = Node(u[j], in[u[j]]);
			a[++dot_cnt1] = Node(v[j], in[v[j]]);
			vis3[u[j]] = vis3[v[j]] = true;
		}
		sort(a + 1, a + dot_cnt1 + 1);
		dot_cnt1 = dot_cnt2 = unique(a + 1, a + dot_cnt1 + 1) - a - 1;
		for (register int j = 1; j < dot_cnt1; j++){
			int cur = lca(a[j].pos, a[j + 1].pos);
			if (!vis3[cur]){
				vis3[cur] = true;
				a[++dot_cnt2] = Node(cur, in[cur]);
			}
		}
		if (!vis3[root]){
			vis3[root] = true;
			a[++dot_cnt2] = Node(root, 1);
		}
		dot_cnt3 = dot_cnt2 * 2 - 1;
		init2(dot_cnt3);
		sort(a + 1, a + dot_cnt2 + 1);
		while (!stk.empty()) stk.pop();
		for (register int j = 1, x = dot_cnt2, y = n; j <= dot_cnt2; j++){
			rnk[a[j].pos] = j;
			while (!stk.empty() && !check(stk.top(), a[j].pos)) stk.pop();
			if (!stk.empty()){
				int cur = stk.top();
				x++;
				y++;
				a[x].pos = y;
				rnk[y] = x;
				size1[y] = sum[fa[a[j].pos]] - sum[cur];
				add_edge1(rnk[cur], x);
				add_edge1(x, j);
			}
			stk.push(a[j].pos);
		}
		for (register int j = 1; j <= k; j++){
			add_edge1(rnk[u[j]], rnk[v[j]]);
		}
		dfn_id = scc_cnt = 0;
		for (register int j = 1; j <= dot_cnt3; j++){
			if (!vis1[j]) tarjan2(j, dfn_id, scc_cnt);
		}
		for (register int j = 1; j <= dot_cnt3; j++){
			size2[belong2[j]] += size1[a[j].pos];
		}
		for (register int j = 1; j <= cnt1; j++){
			int x = edge1[j].start, y = edge1[j].end;
			if (belong2[x] != belong2[y]) add_edge2(belong2[x], belong2[y]);
		}
		dfs2(belong2[rnk[s]]);
		que.push(belong2[rnk[s]]);
		while (!que.empty()){
			int cur = que.front();
			que.pop();
			for (register int j = head2[cur]; j != 0; j = edge2[j].nxt){
				int x = edge2[j].end;
				mark[x] |= mark[cur];
				if (--deg[x] == 0) que.push(x);
			}
		}
		if (mark[belong2[rnk[t]]] >> (belong2[rnk[s]] - 1) & 1){
			for (register int j = 1; j <= scc_cnt; j++){
				if (mark[belong2[rnk[t]]] >> (j - 1) & 1) ans += size2[j];
			}
		}
		cout << ans << endl;
		for (register int j = 1; j <= dot_cnt2; j++){
			vis3[a[j].pos] = false;
		}
		for (register int j = 1; j <= cnt2; j++){
			vis4[j] = false;
		}
	}
	return 0;
}
```

---

## 作者：ZillionX (赞：2)

# Description

给定一张 $n$ 个点 $m$ 条边的有向图，满足特殊性质：对于三座城市 $x,y,z$，若 $x\Rightarrow z$ 且 $y\Rightarrow z$，那么有 $x\Rightarrow y$ 或 $y\Rightarrow x$（$x \Rightarrow y$ 表示从 $x$ 出发经过若干边可到达 $y$）。

有 $q$ 次询问，每次询问临时加上 $k$ 条有向边（询问之间互相独立），问从 $s_i$ 出发到达 $t_i$ 可能被经过的点数，一个点可以被重复经过。

$n,q \le 3 \times 10^5, m \le 6 \times 10^5, k \le 2$，时限 2s。

# Solution

显然可以用 Tarjan 把强连通分量缩成点，并给新图中的点赋一个点权表示该点（强连通分量）在原图中包含的点数，计算答案时统计点权即可。

观察题目性质：若 $x\Rightarrow z$ 且 $y\Rightarrow z$，则 $x\Rightarrow y$ 或 $y\Rightarrow x$。不妨假设此时 $x \Rightarrow y$，且 $x,y,z$ 间的连通都是直接有边相连，那么可以发现删去边 $(x,z)$ 后，$x$ 仍然可以通过中转点 $y$ 间接到达 $z$，不影响图的连通性。

可以考虑继续简化新图，对新图跑一遍拓扑排序，对每个点只保留另一端点拓扑序最大的入边，这样每个点有且仅有一条入边，不难知道得到的是一棵外向树。

先考虑最暴力的做法：从起点做一次 BFS 把能到达的点打上一个标记，再在反图上从终点做一次 BFS 打上一个新标记，最后统计被标记了两次的点的点权和。

可以发现这样会多出很多无用点的遍历。不妨把 $s_i,t_i$ 以及这次询问加上的每个新边的端点拿出来建一棵虚树。这样点数的规模变为了 $\mathcal O(k)$。

我们把虚树上的点权定义为原图的点权，把边权定义为原图上两点路径上所经过的点的点权和（不含两端点）。最后再加上边权为 $0$ 的新边。这样再用原先的暴力做法计算答案，复杂度就可以做到 $\mathcal O(qk \log k)$。

注意必须要先建虚树上的边再添加新边，否则可能会因为重边的情况计算少了答案，被下面这组数据 hack 掉。

```cpp
7 6 1 1
1 2
1 3
3 4
3 5
2 6
2 7
1 4 1 4
```

我代码中用的是邻接链表建图，遍历顺序是反过来的，所以可以通过。如果用 ```vector``` 建图，而且不把建边顺序反过来的话，就会 WA on #5。

另外，出于常数原因，尽量不要用倍增 LCA，最好使用 ST 表 LCA 或者树剖 LCA，否则会 TLE on #12。

# Code

```cpp
#define bg begin
#define ed end
#define pb emplace_back
#define clr clear
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define ers erase
#define umap unordered_map
#define unq unique
#define sze size
const int N=3e5+5;
int n,m,Q,k,rt,sr,en,df[N],lo[N],in[N],tp,st[N],tim,bn,nw[15],ee[15],ttp[N],ee2[15],co[N],id[N],rrd[N],w[N],rd2[N],fa[N],d[N],s[N],zs[N],pr[N];
inline char gc() {
    static char buf[100],*p1(buf),*p2(buf);
    return p1==p2 && (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++; 
}
inline int rd() {
	int x(0);
	char ch(gc());
	while (ch<'0' || ch>'9') ch=gc();
	while (ch>='0' && ch<='9') {
		x=(x<<3)+(x<<1)+(ch^48);
		ch=gc();
	}
	return x;
}
struct grp {
	int ne,fir[N];
	struct edg {
		int v,w,nxt;
	}e[N*2];
	void clr() {
		for (int i=1;i<=ne;i++) e[i]=(edg){0,0,0};
		ne=0;
	}
	void ade(int u,int v,int w=0) {
		e[++ne]=(edg){v,w,fir[u]};
		fir[u]=ne;
	}
}g1,g2,g3;
struct grp2 {
	int ne,fir[15];
	struct edg {
		int v,w,nxt;
	}e[15];
	void clr() {
		ne=0;
		memset(fir,0,sizeof(fir));
	}
	void ade(int u,int v,int w=0) {
		e[++ne]=(edg){v,w,fir[u]};
		fir[u]=ne;
	}
}g4,g5;
umap<int,int> o;
int idn;
void hclr() {
	o.clr(),idn=0;
}
int I(int x) {
	if (!o[x]) o[x]=++idn;
	return o[x];
}
vector<int> p;
bool e[15];
void trj(int x) {
	df[x]=lo[x]=++tim,st[++tp]=x,in[x]=1;
	for (int i=g1.fir[x];i;i=g1.e[i].nxt) {
		int v=g1.e[i].v;
		if (!df[v]) trj(v),lo[x]=min(lo[x],lo[v]);
		else if (in[v]) lo[x]=min(lo[x],df[v]);
	}
	if (df[x]==lo[x]) {
		bn++;
		while (st[tp+1]!=x) co[st[tp]]=bn,in[st[tp--]]=0,w[bn]++;
	}
}
queue<int> q;
void tops() {
	for (int i=1;i<=bn;i++)
		if (!rrd[i]) q.push(i);
	while (!q.empty()) {
		int u=q.front();
		q.pop();
		for (int i=g2.fir[u];i;i=g2.e[i].nxt) {
			int v=g2.e[i].v;
			rrd[v]--;
			if (!rrd[v]) {
				g3.ade(u,v);
				rd2[v]++;
				q.push(v);
			}
		}
	}
}
void dfs1(int x,int ft) {
	pr[x]=pr[ft]+w[x];
	fa[x]=ft,s[x]=1,d[x]=d[ft]+1;
    for (int i=g3.fir[x];i;i=g3.e[i].nxt) 
    	if (g3.e[i].v!=ft) {
    		dfs1(g3.e[i].v,x);
			s[x]+=s[g3.e[i].v];
        	if (s[zs[x]]<s[g3.e[i].v]) zs[x]=g3.e[i].v;
		}
}
void dfs2(int x,int ft) {
	ttp[x]=ft;
	id[x]=++tim;
    if (!zs[x]) return;
	dfs2(zs[x],ft);
    for (int i=g3.fir[x];i;i=g3.e[i].nxt)
      	if (g3.e[i].v!=fa[x] && g3.e[i].v!=zs[x])
			dfs2(g3.e[i].v,g3.e[i].v);
}
int LCA(int x,int y) {
	while (ttp[x]!=ttp[y]) {
		if (d[ttp[x]]<d[ttp[y]]) swap(x,y);
		x=fa[ttp[x]];
	}
	if (d[x]>d[y]) swap(x,y);
	return x;
}
bool cmp(int x,int y) {
	return id[x]<id[y];
}
int calc() {
	memset(ee,0,sizeof(ee));
	memset(ee2,0,sizeof(ee2));
	memset(e,0,sizeof(e));
	while (!q.empty()) q.pop();
	q.push(I(sr));
	while (!q.empty()) {
		int u=q.front();
		q.pop();
		e[u]=1;
		for (int i=g4.fir[u];i;i=g4.e[i].nxt) {
			int v=g4.e[i].v;
			if (!ee[i]) {
				ee[i]=1;
				q.push(v);
			}
		}
	}
	int ans=0;
	q.push(I(en));
	while (!q.empty()) {
		int u=q.front();
		q.pop();
		if (e[u]) ans+=nw[u],e[u]=0;
		for (int i=g5.fir[u];i;i=g5.e[i].nxt) {
			int v=g5.e[i].v,w=g5.e[i].w;
			if (ee2[i]) continue;
			ee2[i]=1;
			if (ee[i]) ans+=w,ee[i]=0;
			q.push(v);
		}
	}
	return ans;
}
int main() {
	n=rd(),m=rd(),Q=rd(),k=rd();
	for (int i=1;i<=m;i++) {
		int u(rd()),v(rd());
		g1.ade(u,v);
	}
	for (int i=1;i<=n;i++)
		if (!df[i]) trj(i);
	for (int i=1;i<=n;i++)
		for (int j=g1.fir[i];j;j=g1.e[j].nxt) {
			int v=g1.e[j].v;
			if (co[i]!=co[v])
				g2.ade(co[i],co[v]),rrd[co[v]]++;
		}
	tops();
	for (int i=1;i<=bn;i++)
		if (!rd2[i]) {
			rt=i;
			break;
		}
	tim=0;
	dfs1(rt,0),dfs2(rt,rt);
	for (int tt=1;tt<=Q;tt++) {
		memset(nw,0,sizeof(nw));
		hclr();
		p.clr();
		sr=co[rd()],en=co[rd()];
		p.pb(sr),p.pb(en);
		for (int i=1;i<=k;i++) {
			int u(co[rd()]),v(co[rd()]);
			if (u==v) continue;
			p.pb(u),p.pb(v);
			g4.ade(I(u),I(v),0);
			g5.ade(I(v),I(u),0);
		}
		sort(p.bg(),p.ed(),cmp);
		p.ers(unq(p.bg(),p.ed()),p.ed());
		int pn=p.sze();
		for (int i=1;i<pn;i++) p.pb(LCA(p[i],p[i-1]));
		sort(p.bg(),p.ed(),cmp);
		p.ers(unq(p.bg(),p.ed()),p.ed());
		for (int v:p) nw[I(v)]=w[v];
		for (int i=1;i<p.sze();i++) {
			int t=LCA(p[i-1],p[i]);
			nw[I(t)]=w[t];
			g4.ade(I(t),I(p[i]),pr[fa[p[i]]]-pr[t]);
			g5.ade(I(p[i]),I(t),pr[fa[p[i]]]-pr[t]);
		}
		printf("%d\n",calc());
		g4.clr(),g5.clr();
	}
	return 0;
}
```


---

## 作者：huayucaiji (赞：2)

## 前言

调了 2 天才过掉。。。

仔细想想，整个思考过程还是很有借鉴意义的。

## 解题思路

我们拿到的是一个有意思图，我们考虑一步一步将图转化。最好处理的图类型是什么？是树，我们能否把原图转化为在叶向树上的问题呢？

### step 1

我们容易想到将一个有向图通过缩点转化为 DAG。我们跑一遍 tarjan 就可以了。

容易证明，缩点后的 DAG 还满足原图所满足的那个奇怪的条件。

### step 2

我们现在有了一个 DAG，可以拓扑排序了。这有什么用呢？我们回顾题目中有一个奇怪的条件：

> 若 $x\Rightarrow z$ 且 $y\Rightarrow z$，那么有 $x\Rightarrow y$ 或 $y\Rightarrow x$。

假设有 $x\Rightarrow y$，也就是说，如果我们现在通过 $x$ 有一条直接的边可以到达 $z$，且 $y$ 可以到达 $z$。我们排序肯定先排 $x$ 后 $y$，最后 $z$。我们可以考虑删掉 $x\Rightarrow z$ 这条边，因为，这对答案没有任何影响。由此我们可以得到一颗叶向树。

### step 3

我们现在得到了一颗树，已经可以暴力了，但是时间复杂度太高了，由于 $k$ 很小，我们考虑建造虚树。

我们对 $s,t$ 和每条边涉及的点建造虚树（注意可能有重复，要去重）。虚树的边权为这个边上出两个端点有多少个点。我们再把临时边加到虚树里，边权为 $0$，顺手建个反向图。让 $s,t$ 双向奔赴一下，计算出有多少边点可以被同时遍历到即可。

## 代码

本题难点之一可能在于如何清空虚树和如何理清每个图之间的关系，理解了后就很简单了。

（代码又长又臭）

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}
char read_char() {
	char ch=getchar();
	while(!isalpha(ch)) {
		ch=getchar();
	}
	return ch;
}

const int MAXN=3e5+10;

int n,m,q,k,rt,tms,tot,top,colcnt,ans;
int ind[MAXN],f[MAXN][21],lst[15],mrk[15],dfn[MAXN],stk[MAXN],val[MAXN],sum[MAXN],cal[MAXN],dep[MAXN],dis[MAXN];
int low[MAXN],col[MAXN],sz[MAXN],bel[MAXN];
bool vis[MAXN];
stack<int> s;
struct edge {
	int u,v,id,nxt;
};

struct graph {
	edge e[MAXN<<2];
	int cnt,h[MAXN];
	
	void addedge(int u,int v,int w) {
		e[++cnt].v=v;
		e[cnt].id=w;
		e[cnt].nxt=h[u];
		h[u]=cnt;
	}
}g0,g1,g2;

struct small_graph {
	edge e[500];
	int cnt,h[MAXN];
	bool vis[MAXN];
	
	void addedge(int u,int v,int w) {
		e[++cnt].v=v;
		e[cnt].id=w;
		e[cnt].u=u;
		e[cnt].nxt=h[u];
		h[u]=cnt;
	}
	
	void dfs(int u) {
		cal[u]++;
		if(cal[u]==2) {
			ans+=sz[u];
		}
		vis[u]=1;
		for(int i=h[u];i;i=e[i].nxt) {
			sum[e[i].id]++;
			if(!vis[e[i].v])
				dfs(e[i].v);
		}
	}
	void clear() {
		for(int i=1;i<=cnt;i++) {
			h[e[i].u]=0;
			cal[e[i].u]=0;
			cal[e[i].v]=0;
			vis[e[i].u]=0;
			vis[e[i].v]=0;
			e[i]=e[0];
		}
		cnt=0;
	}
}g3,g4;

bool cmp(int a,int b) {
	return dfn[a]<dfn[b];
}
void get(int x,int y) {
	if(dis[y]<dis[x]) {
		swap(x,y);
	}
	val[++tot]=dis[y]-dis[x]-sz[y];
}
void tarjan(int u) {
	dfn[u]=low[u]=++tms;
	vis[u]=1;
	s.push(u);
	for(int i=g0.h[u];i;i=g0.e[i].nxt) {
		int v=g0.e[i].v;
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(vis[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]) {
		colcnt++;
		while(!s.empty()&&low[s.top()]==dfn[u]) {
			int v=s.top();
			s.pop();
			vis[v]=0;
			col[v]=colcnt;
			sz[colcnt]++;
			bel[v]=colcnt;
		}
	}
}
void topo() {
	queue<int> q;
	for(int i=1;i<=colcnt;i++) {
		if(!ind[i]) {
			q.push(i);
			rt=i;
		}
	}
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		for(int i=g1.h[u];i;i=g1.e[i].nxt) {
			int v=g1.e[i].v;
			ind[v]--;
			if(!ind[v]) {
				g2.addedge(u,v,0);
				q.push(v);
			}
		}
	}
}

void dfs(int u,int fa) {
	f[u][0]=fa;
	dep[u]=dep[fa]+1;
	dis[u]=dis[fa]+sz[u];
	dfn[u]=++tms;
	for(int i=g2.h[u];i;i=g2.e[i].nxt) {
		int v=g2.e[i].v;
		if(v!=fa) {
			dfs(v,u);
		}
	}
} 
void lca_init() {
	for(int i=1;i<=20;i++) {
		for(int j=1;j<=n;j++) {
			f[j][i]=f[f[j][i-1]][i-1];
		}
	}
}

int LCA(int u,int v) {
	if(dep[u]<dep[v]) {
		swap(u,v);
	}
	for(int i=20;i>=0;i--) {
		if(dep[f[u][i]]>=dep[v]) {
			u=f[u][i];
		}
	}
	if(u==v) {
		return u;
	}
	for(int i=20;i>=0;i--) {
		if(f[u][i]!=f[v][i]) {
			u=f[u][i];
			v=f[v][i];
		}
	}
	return f[u][0];
}

void build(int n) {
	sort(lst+1,lst+n+1,cmp);
	stk[++top]=lst[1];
	for(int i=2;i<=n;i++) {
		int p=lst[i];
		int lca=LCA(lst[i],stk[top]);
		while(1) {
			if(dep[lca]<=dep[stk[top]]&&dep[lca]>=dep[stk[top-1]]) {
				if(lca==stk[top]) {
					;
				}
				else if(lca==stk[top-1]) {
					get(stk[top-1],stk[top]);
					g3.addedge(stk[top-1],stk[top],tot);
					g4.addedge(stk[top],stk[top-1],tot);
					top--;
				}
				else {
					get(lca,stk[top]);
					g3.addedge(lca,stk[top],tot);
					g4.addedge(stk[top],lca,tot);
					stk[top]=lca;
				}
				break;
			}
			else {
				get(stk[top-1],stk[top]);
				g3.addedge(stk[top-1],stk[top],tot);
				g4.addedge(stk[top],stk[top-1],tot);
				top--;
			}
		}
		stk[++top]=lst[i];
	}
	for(int i=1;i<top;i++) {
		get(stk[i+1],stk[i]);
		g3.addedge(stk[i],stk[i+1],tot);
		g4.addedge(stk[i+1],stk[i],tot);
	}
	for(int i=1;i<=k;i++) {
		g3.addedge(mrk[i*2-1],mrk[i*2],0);
		g4.addedge(mrk[i*2],mrk[i*2-1],0);
	}
}

void clear1() {
	for(int i=1;i<=n;i++) {
		dfn[i]=ind[i]=low[i]=0;
	}
	tms=0;
}
void clear2(int n) {
	for(int i=0;i<=tot;i++) {
		sum[i]=0;
		val[i]=0;
	}
	top=tot=ans=0;
	g3.clear();
	g4.clear();
	for(int i=1;i<=n;i++) {
		cal[lst[i]]=0;
		g3.vis[lst[i]]=0;
		g4.vis[lst[i]]=0;
		g3.h[lst[i]]=0;
		g4.h[lst[i]]=0;
	}
}

int main() {
	freopen("temp.in","r",stdin);
	//freopen("temp.out","w",stdout);

	cin>>n>>m>>q>>k;
	for(int i=1;i<=m;i++) {
		int u,v;
		u=read(),v=read();
		ind[v]++;
		g0.addedge(u,v,0);
	}
	for(int i=1;i<=n;i++) {
		if(!dfn[i]) {
			tarjan(i);
		}
	}
	clear1();
	for(int u=1;u<=n;u++) {
		for(int i=g0.h[u];i;i=g0.e[i].nxt) {
			int v=g0.e[i].v;
			if(bel[u]!=bel[v]) {
				g1.addedge(bel[u],bel[v],0);
				ind[bel[v]]++;
			}
		}
	}
	topo();
	dfs(rt,0);
	lca_init();
	
	for(int i=1;i<=q;i++) {
		int s,t;
		s=bel[read()];t=bel[read()];
		for(int j=1;j<=k;j++) {
			lst[j*2-1]=mrk[j*2-1]=bel[read()];
			lst[j*2]=mrk[j*2]=bel[read()];
		}
		lst[k*2+1]=s;
		lst[k*2+2]=t;
		int nm=k*2+2;
		sort(lst+1,lst+nm+1);
		nm=unique(lst+1,lst+nm+1)-lst-1;
		
		build(nm);
		g3.dfs(s);
		g4.dfs(t);
		for(int j=1;j<=tot;j++) {
			ans+=(sum[j]==2? 1:0)*val[j];
		}
		printf("%d\n",ans);
		
		clear2(nm);
	}

	//fclose(stdin);
	//fclose(stdout);
	return 0;
}
/*
5 6 3 0
5 2
3 5
3 2
2 4
2 5
3 1 
3 2 
4 5 
4 3 
*/
```



---

## 作者：jia_shengyuan (赞：2)

## 放在前面
本蒟蒻在本题卡了一天半才做出来（原因是做法伪了然而自己却浑然不知，看题解也没太说清楚，最后照着别人的代码才看出自己的错误）

因此打算写一篇比较易懂的树剖题解（因此也会比较啰嗦）

## 步入正题
首先缩点自不必说。

之后，不难发现图的特点很关键。如果 $x$ 能到 $z$ 且 $y$ 能到 $z$，那么 $x$ 和 $y$ 中，一定可以从一个走到另一个。同时，这道题显然是要尽可能走到更多的点，而不关心从哪条边走。所以说，如果缩完点后有三条边 $x\rightarrow z,y\rightarrow z,x\rightarrow y$，那么 $x\rightarrow z$ 这条边显然是可以删的，因为我们无论如何都不会走这条边。

更广泛地说，每个点只有拓扑序的最后一条边才是有用的，剩下的都可以删了，反正我们也不会走那些边。如下图，红色的边都是可以删掉的。

![红色的边都是可以删的](https://cdn.luogu.com.cn/upload/image_hosting/77r5dspf.png)

这样搞完之后，剩下的就是一棵树。不妨先考虑 $k=0$ 的情况，这时 $x\Rightarrow y$ 的充要条件就是 $y$ 在 $x$ 的子树内，这一点可以用树剖的编号 $O(1)$ 判断。同时，我们可以前缀和求出每一段重路径上点的 $\text{size}$ 之和，而对于每一组询问 $s,t$，就是先看是否满足 $s\Rightarrow t$，满足的话就在树上走一遍。

### 然后，本蒟蒻的噩梦开始了……
考虑 $k>0$ 的情况。以 $k=1$ 举例，本蒟蒻天真地以为，只需要讨论是否经过新加的边就行了，即记新加边为 $u\rightarrow v$，则我们只需讨论 $s\Rightarrow t$（不经过 $u\rightarrow v$）与 $(s\Rightarrow u , v\Rightarrow t)$ 两种情况。然而在调了一天后，本蒟蒻才发现这个结论是错的……反例如图

![反例](https://cdn.luogu.com.cn/upload/image_hosting/3rzxozc4.png)

如果这样讨论，节点 $x$ 就不会被经过。

为了解决这个问题，我们可以从 $s$ 开始 $\text{BFS}$ 并记录走过的路径，如果能走到终点，那么就把自己走过的路径全部加进数组。搜索结束之后统一树剖，记录哪些区间被走过了，最后求出这些区间的并集，用前缀和计算这些区区间中点的数量即可。

为了防止无限的搜索，我们需要计算每条路径在 $\text{BFS}$ 中被更新次数的上限，因为 $k\le 2$，凭感觉我们可以把上界设为 $5\sim6$（至于严谨的证明，我太菜了，不会）

这个题实现起来比较复杂，所以代码尽量写漂亮点会比较好。为了防止一堆变量引起的命名困难，全局变量前面基本都加了下划线。为了节省篇幅，部分简单函数已省略内容。

```cpp
#include <functional>
#include <algorithm>
#include <cstring>
#include <cctype>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#define gc getchar()

const int MAXN=3e5+9;
using namespace std;

struct Path {
    int u,v;
    inline bool operator < (const Path& other) const {
        return (u==other.u)?(v<other.v):u<other.u;
    }
    inline Path(int U=0, int V=0){ u=U,v=V;}
};
struct Node {
    int pos, updated;
    vector<Path> path;
    inline Node()=default;
    inline Node(int POS, int UPDATED, vector<Path> PATH){
        pos=POS, updated=UPDATED;
        path=PATH;
    }
};

vector<int> G1[MAXN],G2[MAXN],G3[MAXN];
int _dfn[MAXN],_low[MAXN],_team[MAXN],_teamSize[MAXN],_in[MAXN],_teamCnt=0,N,M,Q,K,_root;
bool _insta[MAXN];
stack<int> _stack;

int _fa[MAXN],_top[MAXN],_size[MAXN],_son[MAXN],_dep[MAXN],_seg[MAXN],_segtot=0;
int _sum[MAXN];

vector<Path> _paths;
Path _tmp[2];

inline int read(); //快读
inline void Read(){
    N=read(), M=read(), Q=read(), K=read();
    for(int i=0,u,v; i<M; i++){
        u=read(),v=read();
        G1[u].push_back(v);
    }
}

void Tarjan(int now); //Tarjan缩点（应该都会吧）
inline void ZipNodes(){ //缩点，把原图缩成DAG
    for(int u=1; u<=N; u++){
        for(int v:G1[u]){
            if(_team[u]!=_team[v]) {
                _in[_team[v]]++;
                G2[_team[u]].push_back(_team[v]);
            }
        }
    }
}
inline void Topo(){ //删去无用边，把图弄成树
    queue<int> q;
    for(int i=1; i<=_teamCnt; i++){
        if(!_in[i]) {
            _root=i;
            q.push(i);
            break;
        }
    }
    for(int now; !q.empty(); q.pop()){
        now=q.front();
        for(int to:G2[now]){
            if(!--_in[to]){
                G3[now].push_back(to);
                q.push(to);
            }
        }
    }
}
inline void RebuildGraph(){ //重新建图
    for(int i=1; i<=N; i++){
        if(!_dfn[i]) Tarjan(i);
    }
    ZipNodes();
    Topo();
}

void Dfs1(int now, int fa); //树剖基操
inline void AddSeg(int now){ //向前缀和中添加节点。习惯了叫seg，虽然不是线段树
    _seg[now]=++_segtot;
    _sum[_segtot]=_sum[_segtot-1]+_teamSize[now]; //计算前缀和
}
void Dfs2(int now);
inline void TreeSeperate(){ //树链剖分
    Dfs1(_root,0);
    AddSeg(_root);
    _top[_root]=_root;
    Dfs2(_root);
}

inline bool CanGo(int s, int t){ //从s能不经过临时边到达t，即t在s子树内
    return _seg[s]<=_seg[t] && _seg[t]<_seg[s]+_size[s];
}
inline void Walk(int s, int t){ //从s走到t，把经过的路径拆成链
    while(_top[s]!=_top[t]){
        _paths.push_back(Path(_seg[_top[t]], _seg[t]));
        t=_fa[_top[t]];
    }
    _paths.push_back(Path(_seg[s],_seg[t]));
}
inline int Sum(int l, int r); //前缀和
int Solve(int s, int t){
    _paths.clear();
    set<Path> pathsSet;
    queue<Node> q; q.push(Node(s,0,vector<Path>()));
    for(Node now; !q.empty(); q.pop()){ //BFS
        now=q.front();
        now.updated++;
        if(CanGo(now.pos,t)){ //能到终点就更新答案
            now.path.push_back(Path(now.pos,t));
            for(Path p:now.path){
                if(!pathsSet.count(p)){ //优化，防止一条路径被反复添加
                    pathsSet.insert(p);
                    Walk(p.u,p.v);
                }
            }
            now.path.clear(); //到终点了，后面怎么走与前面无关，可以删了来优化时间
        }
        if(now.updated >= 5) continue; //超过上界就跳过
        for(int i=0; i<K; i++){ //模拟走过临时道路
            if(CanGo(now.pos, _tmp[i].u)){
                vector<Path> newpath=now.path;
                newpath.push_back(Path(now.pos, _tmp[i].u));
                q.push(Node(_tmp[i].v,now.updated,newpath));
            }
        }
    }
    sort(_paths.begin(),_paths.end()); //所有区间按L排序
    int r=0, sum=0;
    for(Path p : _paths){ //计算链所在区间的并集，并计算答案
        if(p.v <= r) continue;
        if(p.u <= r){
            sum += Sum(r+1,p.v);
        } else {
            sum += Sum(p.u,p.v);
        }
        r=p.v;
    }
    return sum;
}

int main(){
    Read();
    RebuildGraph();
    TreeSeperate();
    int s,t;
    while(Q--){
        s=_team[read()],t=_team[read()];
        for(int i=0; i<K; i++){
            _tmp[i].u=_team[read()], _tmp[i].v=_team[read()];
        }
        printf("%d\n",Solve(s,t));
    }
    return 0;
}
```


---


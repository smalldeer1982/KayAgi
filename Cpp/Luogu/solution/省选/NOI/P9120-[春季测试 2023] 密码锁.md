# [春季测试 2023] 密码锁

## 题目描述

寒假过后，小 I 回到学校，发现自己忘记了自行车锁的密码，于是请你帮忙。

小 I 自行车上的密码锁有 $n$ 个拨圈，每个拨圈有 $k$（$k \leq 4$）格。密码锁上的每一格都包含一个正整数，其中第 $j$ 个拨圈的第 $i$ 格上的正整数为 $a _ {i, j}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0owivo0l.png)

（一个锁的例子，其中 $k = n = 3$，每列表示一个拨圈，拨圈的格子从上往下编号。）

你可以对每个拨圈拨若干次（也可以不拨），每拨一次拨圈，它的格子就会进行一次轮换。形式化地，拨第 $j$ 个拨圈一次，则会让第 $j$ 个拨圈上第 $i$ 格的数字移动到第 $((i \bmod k) + 1)$ 格，其他拨圈不动。

![](https://cdn.luogu.com.cn/upload/image_hosting/9d3g6b74.png)

（一个拨动拨圈的例子，对左侧的锁拨一次第二个拨圈得到右侧的锁。）

为了方便记忆，小 I 设定密码时要求同一行上的数字尽可能靠近。
形式化地，对于 $1 \leq i \leq k$，定义密码锁第 $i$ 行的松散度为

$$
c(i) = \max \limits _ {j = 1} ^ n a _ {i, j} - \min \limits _ {j = 1} ^ n a _ {i, j} 
$$

同时定义整个密码锁的松散度为

$$
C = \max \limits _ {1 \leq i \leq k} c(i)
$$

因为能开锁的状态满足 $C$ 尽可能小，因此小 I 希望你找出最小的 $C$ 值。

## 说明/提示

**【样例 1 解释】**

第一组样例对应题目描述中的例子。
在拨第二个拨圈一次后，每个拨圈都是 $\{1, 2, 3\}$，此时松散度为 $0$。
容易证明无论如何松散度都不可能小于 $0$，因此输出 $0$。

以下四个样例分别对应 $k = 1, 2, 3, 4$ 的情况，且样例中 $n$ 的取值有一定梯度。

**【数据范围】**

设 $\sum n$ 为一个测试点中所有测试数据的 $n$ 的和。

对于所有数据，保证 $1 \leq T$，$1 \leq k \leq 4$，$1 \leq a _ {i ,j} \leq  3 \times 10 ^ 4$。


本题分为两类测试点。


第一类测试点共有十二个，保证 $k \leq 3$，$n \leq 5 \times 10 ^ 4$，$\sum n \leq 1.5 \times 10 ^ 5$。

| 测试点编号 | $n \leq$ | $\sum n \leq $ | $k = $ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $20$ | $100$ | $1$ |
| $2$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $1$ |
| $3$ | $20$ | $100$ | $2$ |
| $4$ | $100$ | $1000$ | $2$ |
| $5$ | $2000$ | $10 ^ 4$ | $2$ |
| $6$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $2$ |
| $7$ | $10$ | $50$ | $3$ |
| $8$ | $50$ | $500$ | $3$ |
| $9$ | $300$ | $3000$ | $3$ |
| $10$ | $3000$ | $2 \times 10 ^ 4$ | $3$ |
| $11$ | $3 \times 10 ^ 4$ | $1.2 \times 10 ^ 5$ | $3$ |
| $12$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $3$ |

第二类测试点共有八个，保证 $k = 4$，$n \leq 10 ^ 4$，
$\sum n \leq 3 \times 10 ^ 4$。

| 测试点编号 | $n \leq$ | $\sum n \leq $ | $k = $ |
| :----------: | :----------: | :----------: | :----------: |
| $13$ | $10$ | $50$ | $4$ |
| $14$ | $50$ | $500$ | $4$ |
| $15$ | $200$ | $2000$ | $4$ |
| $16$ | $500$ | $4000$ | $4$ |
| $17$ | $2500$ | $10 ^ 4$ | $4$ |
| $18$ | $5000$ | $2 \times 10 ^ 4$ | $4$ |
| $19$ | $10 ^ 4$ | $3 \times 10 ^ 4$ | $4$ |
| $20$ | $10 ^ 4$ | $3 \times 10 ^ 4$ | $4$ |

**【后记】**

你花了九牛二虎之力算出 $C$ 的值之后，小 I 却告诉你他已经找开锁师傅用锤子暴力破解了。在你的百般劝说下，小 I 承诺以后锁车不用有大于等于一万个拨圈的密码锁。

## 样例 #1

### 输入

```
2 3
3
1 2 1
2 3 2
3 1 3
2
1 2
2 1
1 2```

### 输出

```
0
1```

## 样例 #2

### 输入

```
见选手目录下的 lock/lock2.in。```

### 输出

```
见选手目录下的 lock/lock2.ans。```

## 样例 #3

### 输入

```
见选手目录下的 lock/lock3.in。```

### 输出

```
见选手目录下的 lock/lock3.ans。```

## 样例 #4

### 输入

```
见选手目录下的 lock/lock4.in。```

### 输出

```
见选手目录下的 lock/lock4.ans。```

## 样例 #5

### 输入

```
见选手目录下的 lock/lock5.in。```

### 输出

```
见选手目录下的 lock/lock5.ans。```

# 题解

## 作者：AL8624 (赞：31)

## 注意，如果你想要学习正解的话请略过本篇题解，本篇题解仅说明如何随机化乱搞过这道题

upd: 上传了代码

## part 1 贪心

首先你可以想到一个显然假的贪心：从 $1 \sim n$ 考虑，对于每个转圈枚举出转多少对总答案的影响最小。

但是这个贪心有后效性，所以会得到错误的解。

## part 2 随机化

你发现拼合多个错误的贪心和 dp 可以得到近似解。

你考虑这个错误的贪心算法的正确性和顺序有关 ~~，一个好的顺序可以瞬间帮你得到正确答案~~。

于是你考虑随机化这个序列，然后你发现随机 $300$ 次的时候 $1 \leq k \leq 3$ 能得到正解，但是 $k=4$ 的时候似乎会得到错误的解。

通过调参，可以发现随机 $600$ 次的时候 $k=4$ 可以得到正确的解，但是前面会被卡常，于是考虑数据点分治

然后喜提最劣解（10s）


~~如果 WA 了可以尝试改变随机数种子多交几发，应该是很稳定基本能过的~~

## part 3 代码

~~可能有略微压行，见谅~~

```cpp

#include<bits/stdc++.h>
using namespace std;
int n,T,k,a[200010][10];//为了随机化时连续访问所以把10开在后面
int mn[10],mx[10];
int main(){
	freopen("lock.in","r",stdin),freopen("lock.out","w",stdout);
	srand(1679057163);//此随机种子可以通过infoj的民间数据
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>T>>k;
	while(T--){
		cin>>n;
		for(int i(1);i<=k;++i)for(int j(1);j<=n;++j)cin>>a[j][i];
		int ans(1e9),en(k==4?600:300);//可以发现k=4的时候n比较小
		for (int i=1;i<=en;++i) {
			random_shuffle(a+1,a+n+1);
			memset(mx,-0x3f,sizeof(mx));
			memset(mn,0x3f,sizeof(mn));
			for(int j(1);j<=n;++j){
				int v(1e9),p;
				for(int x(0);x^k;++x) {
					int tmp(0);
					for(int y(1);y<=k;++y){
						const int Tmp=(y+x-1)%k+1;
						tmp=max(tmp,max(mx[y],a[j][Tmp])-min(mn[y],a[j][Tmp]));
					}
					v=tmp<v?(p=x,tmp):v;
				}
				for(int y=1;y<=k;++y) {
					const int Tmp=(y+p-1)%k+1;
					mx[y]=max(mx[y],a[j][Tmp]);
					mn[y]=min(mn[y],a[j][Tmp]);
				}
				if(ans<=v)break;//如果无法更新答案了就退出
			}
			int ret(0);
			for(int i=1;i<=k;++i)ret=max(ret,mx[i]-mn[i]);
			ans=min(ans,ret);
		}
		cout<<ans<<'\n';
	}
	return 0;

```

---

## 作者：zhiyangfan (赞：29)

## [春季测试 2023] 密码锁
upd: 被指出 $k=3$ 的写法有问题，已经换上了新写法。

$k=1,2$ 的思路非常简单。

我们考虑 $k=3$，首先显然可以二分答案，然后在 $k=2$ 的时候，我们提到了 $\max,\min$，我们考虑扩展一下思路。首先显然全局最大值和最小值在同一行中的情况一定是不优的。所以我们来枚举它们分别在哪两行。注意，这里有可能会出现一些奇怪的情况，比如极值不止一个，或者因为全局最大值和最小值在同一列导致无法达成目标。不过因为我们这样放，只是假设某两行的极值是给定值，而这个假设值比事实上的值带来的限制一定不会更松。所以只要能在这样的限制下找到解，一定是合法的，并且由于最终解中一定可以存在在不同行的 $\max,\min$，所以我们也不会遗漏情况。

然后说完这些东西剩下的就很简单了。考虑二分的值确定了这两行数的范围，从而每一列能在不确定的第三行放哪个数也是可以确定的。然后问题就转化为了，有 $n$ 个数，每个数可以有不超过 $3$ 种的选择，问极差能不能不超过某个数。这当然可以用卡牌游戏做，不过有一个更具有扩展性的做法。

考虑对于每个数 $x$，它对于 $\min$ 的限制是 $[x-k,x]$，其中 $k$ 是我们二分的极差。然后我们对于每一列可能的数，我们把它对应的限制求并后加入统计。看看是否存在一个点被 $n$ 个限制同时覆盖即可。线段求并只需按照 $l$ 排序后扫一遍，覆盖次数可以用线段树求解。时间复杂度 $\mathcal{O}(kn\log^2 a)$。

然后我们来看看 $k=4$ 的情况。钦定完 $\max,\min$ 后思路是类似的，只不过这次我们对于 $\min$ 的限制变成了 $2$ 维的。模仿上面的思路，我们需要矩阵并和在矩阵并后的图形上整体 $+1$。因为矩阵并之后不像线段依然能保持一个好维护的形状，所以我们考虑把并后的图形拆成若干矩形，然后再用扫描线维护矩形加。这个拆我们可以考虑容斥。考虑矩阵集合的一个子集 $S$，我们求出这个集合的交，如果 $|S|$ 为奇数，就矩阵 $+1$，否则就 $-1$，原因显然。如果你还不太理解可以看看这幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xbkg3txj.png)

蓝色，绿色，黄色矩形直接加，然后红色矩形减，即可。然后就做完了。时间复杂度 $\mathcal{O}(k2^kn\log^2 a)$。

我们来考虑其他常数更小的做法。发现在扫描线矩阵求并的过程中，我们要做的事情是对于若干高度一样的矩阵求并。本质上就是线段求并，这启发我们抛弃容斥，用类似扫描线的思路来做这个东西。

考虑把所有端点都离散化，然后离散化后相邻的两个位置，它们之间的矩形结构是相同的，可以一起处理。（还有一种理解思路就是 $k=3$ 的情况长高了）找到应该加的矩形后，后面就一模一样了，具体实现可以见代码，或者可以看看这幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wh9uwc4v.png)

我们分别把绿色红色蓝色黄色一条条加进去即可。

代码中是把 $x,y$ 坐标一起离散化，这样单次 `work4` 的线段树修改次数是 $4nk$ 的，如果 $x,y$ 分别离散化可以做到 $2nk$，但我懒得写了。时间复杂度 $\mathcal{O}(nk\log^2a)$。
```cpp
#include <cstdio>
#include <vector>
#include <cassert>
#include <algorithm>
const int N = 1e5 + 10; int a[5][N]; 
std::vector<int> v3[N]; int d[N], mx, mn;
struct IO
{
    static const int N = 1 << 22;
    char buf[N], pbuf[N], *p1 = buf, *p2 = buf, *pp = pbuf;
    #define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++)  
    template <typename T>
    void read(T& x)
    {
        x = 0; char ch; int f = 0;
        while ((ch = gc()) < '0' || ch > '9') f |= (ch == '-');
        while (x = (x << 1) + (x << 3) + (ch ^ 48), (ch = gc()) >= '0' && ch <= '9') ;
        if (f) x = ~x + 1;
    }
    void putc(char c)
    {
        if (pp - pbuf == N) fwrite(pbuf, 1, N, stdout), pp = pbuf;
        *pp++ = c;
    }
    void puts(const char* s) { while (*s) putc(*s), ++s; putc('\n'); }
    template <typename T>
    void print(T x)
    {
        static int st[20]; int tp = 0;
        if (x < 0) putc('-'), x = ~x + 1;
        do st[++tp] = x % 10, x /= 10; while (x);
        while (tp) putc(st[tp--] + '0');
    }
    ~IO() { fwrite(pbuf, pp - pbuf, 1, stdout); }
}io;
struct SegTree
{
    #define ls(k) (k << 1)
    #define rs(k) (k << 1 | 1)
    struct node{ int mx, tag, clr; }h[N << 2];
    void pushup(int k) { h[k].mx = std::max(h[ls(k)].mx, h[rs(k)].mx); }
    void add(int k, int v) { h[k].mx += v; h[k].tag += v; }
    void clr(int k) { h[k].clr = 1; h[k].mx = h[k].tag = 0; }
    void pushdown(int k)
    {
        if (h[k].clr) clr(ls(k)), clr(rs(k)), h[k].clr = 0;
        if (h[k].tag) add(ls(k), h[k].tag), add(rs(k), h[k].tag), h[k].tag = 0;
    }
    void change(int k, int l, int r, int x, int y, int v)
    {
        if (x <= l && r <= y) return add(k, v);
        int mid = (l + r) >> 1; pushdown(k);
        if (x <= mid) change(ls(k), l, mid, x, y, v);
        if (mid < y) change(rs(k), mid + 1, r, x, y, v);
        pushup(k);
    }
    #undef ls
    #undef rs
}sgt;
bool work3(int n, int k)
{
   	sgt.clr(1);
    for (int i = 1; i <= n; ++i)
    {
        std::pair<int, int> seg[3];
        for (int j = 0; j < (int)v3[i].size(); ++j)
            seg[j].first = std::max(mn, v3[i][j] - k), seg[j].second = v3[i][j];
        std::sort(seg, seg + v3[i].size());
		sgt.change(1, mn, mx, seg[0].first, seg[0].second, 1);
        ++d[seg[0].first]; --d[seg[0].second + 1];
        for (int j = 1; j < (int)v3[i].size(); ++j) 
        {
            if (seg[j].first > seg[j - 1].second)
				sgt.change(1, mn, mx, seg[j].first, seg[j].second, 1);
            else if (seg[j - 1].second + 1 <= seg[j].second)
				sgt.change(1, mn, mx, seg[j - 1].second + 1, seg[j].second, 1);
        }
    }
	return (sgt.h[1].mx == n);
}
bool check3(int n, int l, int r, int k)
{
    bool flg = 1; for (int i = 1; i <= n; ++i) v3[i].clear();
    for (int i = 1; i <= n; ++i)
    {
        if (a[1][i] >= l && a[2][i] <= r) v3[i].push_back(a[3][i]);
        if (a[2][i] >= l && a[3][i] <= r) v3[i].push_back(a[1][i]);
        if (a[3][i] >= l && a[1][i] <= r) v3[i].push_back(a[2][i]);
        if (v3[i].empty()) { flg = 0; break; }
    }
    if (flg && work3(n, k)) return true;
    flg = 1; for (int i = 1; i <= n; ++i) v3[i].clear();
    for (int i = 1; i <= n; ++i)
    {
        if (a[1][i] >= l && a[3][i] <= r) v3[i].push_back(a[2][i]);
        if (a[2][i] >= l && a[1][i] <= r) v3[i].push_back(a[3][i]);
        if (a[3][i] >= l && a[2][i] <= r) v3[i].push_back(a[1][i]);
        if (v3[i].empty()) { flg = 0; break; }
    }
    if (flg && work3(n, k)) return true;
    return false;
}
std::vector<std::pair<int, int>> vec[N]; std::pair<int, int> v4[N][4]; int siz[N];
int bkt[N * 16], tp, t[20], cnt; 
std::vector<std::pair<int, int>> ad[20], dl[20];
bool work4(int n, int k)
{
    tp = 0; int flg = 0;
    for (int i = 1; i <= n; ++i)
    {
        cnt = 0;
        for (int j = 0; j < siz[i]; ++j)
        {
            t[++cnt] = std::max(v4[i][j].first - k, mn);
            t[++cnt] = std::max(v4[i][j].second - k, mn);
            t[++cnt] = v4[i][j].first + 1; 
            t[++cnt] = v4[i][j].second + 1;
        }
        std::sort(t + 1, t + cnt + 1); cnt = std::unique(t + 1, t + cnt + 1) - t - 1;
        for (int j = 1; j <= cnt; ++j) ad[j].clear(), dl[j].clear();
        for (int j = 0; j < siz[i]; ++j)
        {
            int lef = std::lower_bound(t + 1, t + cnt + 1, std::max(v4[i][j].first - k, mn)) - t,
                dw = std::lower_bound(t + 1, t + cnt + 1, std::max(v4[i][j].second - k, mn)) - t,
                rig = std::lower_bound(t + 1, t + cnt + 1, v4[i][j].first + 1) - t,
                up = std::lower_bound(t + 1, t + cnt + 1, v4[i][j].second + 1) - t;
            ad[dw].emplace_back(lef, rig);
            dl[up].emplace_back(lef, rig);
        }
        for (int j = 1; j <= cnt; ++j) d[j] = 0, bkt[++tp] = t[j];
        for (int j = 1; j <= cnt; ++j)
        {
            int sum = 0, las = -1;
            for (auto p : ad[j]) ++d[p.first], --d[p.second];
            for (auto p : dl[j]) --d[p.first], ++d[p.second];
            for (int k = 1; k <= cnt; ++k)
            {
                sum += d[k];
                if (!sum)
                {
                    if (las == -1) continue;
                    vec[t[j]].emplace_back(t[las], 1);
                    vec[t[j]].emplace_back(t[k], -1);
                    vec[t[j + 1]].emplace_back(t[las], -1);
                    vec[t[j + 1]].emplace_back(t[k], 1);
                    las = -1;
                } else if (las == -1) las = k;
            }
        }
    }
    std::sort(bkt + 1, bkt + tp + 1);
    tp = std::unique(bkt + 1, bkt + tp + 1) - bkt - 1;
    for (int i = 1; i <= tp; ++i)
    {
        vec[bkt[i]].emplace_back(mn, 0);
        vec[bkt[i]].emplace_back(mx + 1, 0);
    }
    sgt.clr(1);
    for(int i = 1; i <= tp; ++i)
    {
        auto& v = vec[bkt[i]];
        std::sort(v.begin(), v.end()); int sum = v[0].second;
        for (int j = 1; j < (int)v.size(); ++j)
        {
            if (v[j - 1].first < v[j].first && sum)
                sgt.change(1, mn, mx, v[j - 1].first, v[j].first - 1, sum);
            sum += v[j].second;
        }
        if (sgt.h[1].mx == n) { flg = 1; break; }
    }
    for (int i = 1; i <= tp; ++i) vec[bkt[i]].clear();
    return flg;
}
bool check4(int n, int l, int r, int k)
{
    bool flg = 1; 
    for (int i = 1; i <= n; ++i)
    {
        siz[i] = 0;
        if (a[1][i] >= l && a[2][i] <= r) v4[i][siz[i]++] = std::make_pair(a[3][i], a[4][i]);
        if (a[2][i] >= l && a[3][i] <= r) v4[i][siz[i]++] = std::make_pair(a[4][i], a[1][i]);
        if (a[3][i] >= l && a[4][i] <= r) v4[i][siz[i]++] = std::make_pair(a[1][i], a[2][i]);
        if (a[4][i] >= l && a[1][i] <= r) v4[i][siz[i]++] = std::make_pair(a[2][i], a[3][i]);
        if (!siz[i]) { flg = 0; break; }
    }
    if (flg && work4(n, k)) return true;
    flg = 1;
    for (int i = 1; i <= n; ++i)
    {
        siz[i] = 0;
        if (a[1][i] >= l && a[3][i] <= r) v4[i][siz[i]++] = std::make_pair(a[4][i], a[2][i]);
        if (a[2][i] >= l && a[4][i] <= r) v4[i][siz[i]++] = std::make_pair(a[1][i], a[3][i]);
        if (a[3][i] >= l && a[1][i] <= r) v4[i][siz[i]++] = std::make_pair(a[2][i], a[4][i]);
        if (a[4][i] >= l && a[2][i] <= r) v4[i][siz[i]++] = std::make_pair(a[3][i], a[1][i]);
        if (!siz[i]) { flg = 0; break; }
    }
    if (flg && work4(n, k)) return true;
    flg = 1;
    for (int i = 1; i <= n; ++i)
    {
        siz[i] = 0;
        if (a[1][i] >= l && a[4][i] <= r) v4[i][siz[i]++] = std::make_pair(a[2][i], a[3][i]);
        if (a[2][i] >= l && a[1][i] <= r) v4[i][siz[i]++] = std::make_pair(a[3][i], a[4][i]);
        if (a[3][i] >= l && a[2][i] <= r) v4[i][siz[i]++] = std::make_pair(a[4][i], a[1][i]);
        if (a[4][i] >= l && a[3][i] <= r) v4[i][siz[i]++] = std::make_pair(a[1][i], a[2][i]);
        if (!siz[i]) { flg = 0; break; }
    }
    if (flg && work4(n, k)) return true;
    return false;
}
int main()
{ 
    int qwq, k; io.read(qwq); io.read(k);
    while (qwq--)
    {
        int n; mx = 0, mn = 2e9; io.read(n);
        for (int i = 1; i <= k; ++i)
            for (int j = 1; j <= n; ++j) 
                io.read(a[i][j]), mx = std::max(mx, a[i][j]), mn = std::min(mn, a[i][j]);
        if (k == 1) io.print(mx - mn);
        else if (k == 2)
        {
            for (int i = 1; i <= n; ++i)
                if (a[1][i] < a[2][i]) std::swap(a[1][i], a[2][i]);
            int ans = 0;
            for (int i = 1; i <= 2; ++i)
            {
                int mx = 0, mn = 2e9;
                for (int j = 1; j <= n; ++j)
                    mx = std::max(mx, a[i][j]), mn = std::min(mn, a[i][j]);
                ans = std::max(ans, mx - mn);
            }
            io.print(ans);
        }
        else if (k == 3)
        {
            int l = 0, r = mx - mn, mid, ans = -1;
            while (l <= r)
            {
                mid = (l + r) >> 1;
                if (check3(n, mx - mid, mn + mid, mid)) ans = mid, r = mid - 1;
                else l = mid + 1;
            }
            io.print(ans);
        }
        else if (k == 4)
        {
            int l = 0, r = mx - mn, mid, ans = -1;
            while (l <= r)
            {
                mid = (l + r) >> 1;
                if (check4(n, mx - mid, mn + mid, mid)) ans = mid, r = mid - 1;
                else l = mid + 1;
            }
            io.print(ans);
        }
        io.puts("");
    }
    return 0;
}
```

---

## 作者：Graphcity (赞：7)

分四种情况考虑：

- $k=1$

输出最大值减最小值。

- $k=2$

注意到答案的上界为最大值减最小值，要想低于这个上界就必须让最大值与最小值不在同一行。

不妨令最大值 $mx$ 在第一行，最小值 $mn$ 在第二行，二分极差最大值 $mid$。对于第一行，判定条件为 $mx-a_i\le mid$，第二行则是 $a_i-mn\le mid$。

时间复杂度 $O(n\log n)$。

- $k=3$

现在除了最大值和最小值所在的行外又多出了一行。首先固定最大值在第一行，通过转锁的方式调整最小值所在的行号，对每个行号依次处理。

同样二分极差最大值 $mid$。除最大最小值外的锁通过转锁能得到这一行的所有可选值。对于这些可选值，我们希望找到一个长度 $\le mid$ 的区间使得每一把锁都有至少一个可选值在区间内。

先将所有可选值排序，再通过双指针滑动窗口的方式依次枚举区间。设 $cnt_i$ 为每一把锁可选值在区间中的出现次数，那么判定条件即为 $\sum_{i=1}^n[cnt_i>0]=n$。每次移动指针时 $cnt$ 的变化量是 $O(1)$ 的，很好维护。

时间复杂度 $O(n\log^2n)$。

- $k=4$

还是一样二分 $mid$，不过这种情况可选值变成了一个二维点对 $(x,y)$。

我们放在二维平面上来考虑。设一种合法构造中第一维的最大值为 $x_0$，第二维最大值为 $y_0$，那么点 $(x_0,y_0)$ 就可以表示一种方案。

对于一个点 $(a,b)$，最大值点对应该在 $x_0\in[a,a+mid],y_0\in[b,b+mid]$ 的正方形中。一把锁构成的合法点集就是这些正方形的并。

考虑使用扫描线转化为数轴问题，合法点集在扫描线上的投影就变成了若干个区间的并。注意正方形，也就是扫描线中的区间个数对于每一把锁是 $O(1)$ 的，可以对每一把锁建立一棵珂朵莉树来维护区间并。

具体而言，珂朵莉树维护的东西形如 $(l,r,x)$，表示区间 $[l,r]$ 被覆盖了 $x$ 次。每次增删区间时，暴力修改这些三元组即可。

最后用一棵线段树维护当前每个位置被多少的合法点集包含。这棵线段树需要支持区间加减和区间查询最大值。如果存在位置被所有锁的合法点集包含，那么就有解。

时间复杂度 $O(n\log^2n)$。

- **细节问题**

1. 多测清空：注意我们开的是值域线段树，不能直接暴力清空，需要打一个清空标记。同样的，扫描线也是基于值域的，需要记录哪些位置有操作。
2. 关于最大最小值：需要特判它们在同一把锁，或者最大值等于最小值（也就是所有数均相同）的情况。
3. 关于转锁：注意二分时不要去转最大最小值所在的锁。

[Code](https://www.luogu.com.cn/paste/1x11d24y) ~~（10KB，慎点）~~

---

## 作者：cyffff (赞：6)

[$\text{Link}$](https://www.luogu.com.cn/problem/P9120)
## 题意
有一个 $k\times n$ 的矩阵，对于每一列，你可以任意旋转，求每行的极差的最大值的最小值。多组数据。

$T\ge 1$，$1\le a_{i,j}\le3\times10^4$，$1\le k\le 4$。

对于 $1\le k\le 3$，$1\le n\le 5\times 10^4$，$\sum n\le 1.5\times 10^5$。

对于 $k=4$，$1\le n\le 10^4$，$\sum n\le 3\times 10^4$。

## 思路
对每个 $k$ 处理。

### $k=1$
直接求极差，时间复杂度 $O(\sum nk)$。

### $k=2$

考虑将小的数放上面，大的数放下面。

思考一下这样为什么是对的？考虑全局最小值和全局最大值所在的行，显然放在两行不劣于放在同一行，设最小值放上面，最大值放下面，那么要想让上面的数尽量小，下面的数尽量大，就是上面的方法。

时间复杂度 $O(\sum nk)$。

```cpp
namespace Sub12{
	const int N=5e4+10;
	int n,a[3][N];
	inline void main(){
		while(T--){
			n=read();
			for(int i=1;i<=k;i++)
				for(int j=1;j<=n;j++)
					a[i][j]=read();
			if(k==2){
				for(int i=1;i<=n;i++)
					if(a[1][i]>a[2][i])
						swap(a[1][i],a[2][i]);
			}
			int ans=0;
			for(int i=1;i<=k;i++){
				int mn=3e4+10,mx=0;
				for(int j=1;j<=n;j++)
					mn=min(mn,a[i][j]),mx=max(mx,a[i][j]);
				ans=max(ans,mx-mn);
			}
			write(ans),putc('\n');
		}
		flush();
	}
}
```

### $k=3$

让最大值最小，可以先考虑二分答案，检验答案 $x$ 是否可行。

考虑沿用上面的想法，先固定全局最小值在第一行，枚举全局最大值在第几行。

对于第 $i$ 列，我们枚举转了几次，判断是否满足最小值和最大值所在两行的限制（即在那一行上的数和那一行的最小值/最大值相差超不超过 $x$），如果满足限制，我们设剩下一行上的数为 $a$。

假设有一条数轴，我们可以在 $a$ 位置放上一个颜色为 $i$ 的点（每个颜色的点显然只有 $O(k)$ 个），我们要判断剩下一行的极差是否可以不超过 $x$，就是问是否有一条长度为 $x$ 的线段覆盖了所有 $n$ 种颜色。

我们维护 $[mn,mx]$ 内每个点作为左端点时，可以覆盖几种颜色，对于每种颜色，对于左端点 $l$，如果 $[l,l+x]$ 内有这个颜色的点就可以让这个左端点加一，我们考虑对每个这个颜色的点 $a$ 将 $[a-x,a]$ 内的左端点加一。

注意到不能重复加，对于每个颜色，我们开个 `set` 存这个颜色已经加入了的点，设要加入 $a$，$a$ 在集合内的前驱后继分别为 $p,q$，则需要将 $[\max(p+1,a-x),\min(a,q-x-1)]$ 加一。注意左端点大于右端点的时候。

差分即可，判断最大值是否等于 $n$，注意到不能给单次复杂度带上 $v$，需要维护有哪些位置被加了。

用并查集加上标记清空可做到时间复杂度为 $O(\sum nk^2\log v)$。

实现的代码由于排序有二 $\log$。

```cpp
namespace Sub3{
	const int N=5e4+10,M=3e4+10;
	int n,a[3][N],mn,mx;
	struct Delta{
		struct File{
			int p,v;
			inline friend bool operator<(const File &a,const File &b){
				return a.p<b.p;
			}
		}f[M];
		int f[M],top,nxt[],g[M];
		inline void clear(){
			for(int i=1;i<=top;i++)
				g[f[i].p]=0;
			top=0;
		}
		inline void add(int p,int v){
			if(!g[p]) g[p]=++top,f[top].p=p,f[top].v=0;
			f[g[p]].v+=v;
		}
		inline void modify(int l,int r,int v){
			if(l>r) return ;
			add(r+1,-v),add(l,v);
		}
		inline int query(){
			int mx=0;
			sort(f+1,f+top+1);
			for(int i=1,s=0;i<=top;i++){
				s+=f[i].v;
				mx=max(mx,s);
			}
			return mx;
		}
	}tr;
	struct node{
		int c,x;
	};
	multiset<int>ip[N];
	vector<node>p;
	inline int pre(int col,int x){
		auto tmp=ip[col].upper_bound(x);
		if(tmp==ip[col].begin()) return 0;
		return *(--tmp);
	}
	inline int nxt(int col,int x){
		auto tmp=ip[col].upper_bound(x);
		if(tmp==ip[col].end()) return 3e5;
		return *tmp;
	}
	inline void add(int col,int x,int mid,int v){
		int pr=pre(col,x),nx=nxt(col,x);
		if(pr==x) return ;
		tr.modify(max({pr+1,x-mid,mn}),min(x,max(0,nx-mid-1)),v);
		ip[col].insert(x);
	}
	inline void cl(int id){
		if(id==0){
			vector<node>op;
			swap(p,op);
		}else{
			multiset<int>op;
			swap(ip[id],op);
		}
	}
	inline bool check(int mid){
		cl(0);
		tr.clear();
		for(int i=1;i<=n;i++){
			cl(i);
			for(int j=0;j<=2;j++){
				int x=a[(0+j)%3][i],y=a[(1+j)%3][i],
					z=a[(2+j)%3][i];
				if(x-mn<=mid&&mx-y<=mid)
					p.push_back((node){i,z});
			}
		}
		for(auto tmp:p){
			int col=tmp.c,x=tmp.x;
			add(col,x,mid,1);
		}
		int tmp=tr.query();
		if(tmp==n) return 1;
		cl(0);
		tr.clear();
		for(int i=1;i<=n;i++){
			cl(i);
			for(int j=0;j<=2;j++){
				int x=a[(0+j)%3][i],y=a[(1+j)%3][i],
					z=a[(2+j)%3][i];
				if(mx-x<=mid&&y-mn<=mid)
					p.push_back((node){i,z});
			}
		}
		for(auto tmp:p){
			int col=tmp.c,x=tmp.x;
			add(col,x,mid,1);
		}
		tmp=tr.query();
		return tmp==n;
	}
	inline void main(){
		while(T--){
			n=read();
			mn=3e4,mx=0;
			for(int i=0;i<k;i++)
				for(int j=1;j<=n;j++)
					a[i][j]=read(),
					mn=min(a[i][j],mn),
					mx=max(a[i][j],mx);
			int l=0,r=mx-mn,ans=3e4;
			while(l<=r){
				int mid=l+r>>1;
				if(check(mid)) r=mid-1,ans=mid;
				else l=mid+1;
			}
			write(ans),putc('\n');
		}
		flush();
	}
}
```
### $k=4$

沿用上面的想法，设二分到 $x$，先固定全局最小值在第一行，枚举全局最大值在第几行。

对于第 $i$ 列，我们枚举转了几次，判断是否满足最小值和最大值所在两行的限制，如果满足限制，我们设剩下两行上的数为 $a,b$。我们在平面上 $(a,b)$ 位置放一个颜色为 $i$ 的点。判断是否有一个 $x\times x$ 的矩形能覆盖 $n$ 种颜色。

对于每一行维护有哪些点。考虑枚举矩形的下边界 $d$，上边界就是 $d-x$，考虑下移下边界，需要删掉 $d-x$ 行的所有点，加入 $d+1$ 行的所有点。删除方法和加入方法类似。

同样维护左边界 $x$ 坐标为 $l$ 的时候能覆盖几种颜色，需要动态修改，查询全局最大值，可以用线段树维护。

实现上，我们不能带上 $v$ 的复杂度，需要维护有哪些行有点，当前上下范围内有哪些行有点，可以用队列维护。注意清空只能清空有点的行，线段树也不能整棵树搜索清空，要一步步撤销操作。具体实现可以参考以下代码。

时间复杂度 $O(\sum nk^2\log^2v)$。

```cpp
namespace Sub4{
	const int N=1e4+10,M=3e4+10;
	int n,a[4][N],mn,mx;
	struct Segment_Tree{
		#define ls (rt<<1)
		#define rs (rt<<1|1)
		int tag[M<<2],mx[M<<2];
		inline void pushup(int rt){
			mx[rt]=max(mx[ls],mx[rs]);
		}
		inline void pushadd(int rt,int v){
			tag[rt]+=v,mx[rt]+=v; 
		}
		inline void pushdown(int rt){
			if(tag[rt]){
				pushadd(ls,tag[rt]);
				pushadd(rs,tag[rt]);
				tag[rt]=0;
			}
		}
		inline void modify(int rt,int l,int r,int L,int R,int v){
			if(L>R) return ;
			if(L<=l&&r<=R){
				pushadd(rt,v);
				return ;
			}
			pushdown(rt);
			int mid=l+r>>1;
			if(L<=mid) modify(ls,l,mid,L,R,v);
			if(R>mid) modify(rs,mid+1,r,L,R,v);
			pushup(rt);
		}
		inline int query(){
			return mx[1];
		}
	}tr;
	struct node{
		int c,x;
	};
	multiset<int>ip[N];
	vector<node>p[M];
	inline int pre(int col,int x){
		auto tmp=ip[col].upper_bound(x);
		if(tmp==ip[col].begin()) return 0;
		return *(--tmp);
	}
	inline int nxt(int col,int x){
		auto tmp=ip[col].upper_bound(x);
		if(tmp==ip[col].end()) return 3e5;
		return *tmp;
	}
	struct DEL{
		int l,r,v;
	};
	vector<DEL>del;
	set<int>mdp,mbp;
	inline void add(int col,int x,int mid,int v){
		if(v==-1) ip[col].erase(ip[col].find(x));
		int pr=pre(col,x),nx=nxt(col,x);
		tr.modify(1,mn,mx,max({pr+1,x-mid,mn}),min(x,max(0,nx-mid-1)),v);
		del.push_back((DEL){max({pr+1,x-mid,mn}),min(x,max(0,nx-mid-1)),-v});
		if(v==1) ip[col].insert(x);
	}
	inline void cl(int id){
		multiset<int>op;
		swap(ip[id],op);
	}
	inline void CLEAR(){
		for(auto tmp:del)
			tr.modify(1,mn,mx,tmp.l,tmp.r,tmp.v);
		vector<DEL>det;
		swap(del,det);
		for(auto tmp:mdp){
			vector<node>mdq;
			swap(p[tmp],mdq);
		}
		set<int>mdq;
		swap(mdp,mdq);
		set<int>mbq;
		swap(mbp,mbq);
	}
	inline int beg(){
		if(mbp.empty()) return 1e9;
		return *mbp.begin();
	}
	inline void dbeg(){
		mbp.erase(mbp.begin());
	}
	inline int nxt(int x){
		auto tmp=mdp.upper_bound(x);
		if(tmp==mdp.end()) return 3e5;
		return *tmp;
	}
	inline bool check(int A,int B,int mid){
		for(int i=1;i<=n;i++){
			cl(i);
			for(int j=0;j<=3;j++){
				int x=a[(0+j)%4][i],y=a[(1+j)%4][i],
					z=a[(2+j)%4][i],f=a[(3+j)%4][i];
				if(A) swap(y,z);
				if(B) swap(x,y);
				if(x-mn<=mid&&mx-y<=mid)
					p[z].push_back((node){i,f}),mdp.insert(z);
			}
		}
		mbp=mdp;
		for(int i=beg();i<=mid;i=nxt(i)){
			for(auto tmp:p[i]){
				int col=tmp.c,x=tmp.x;
				add(col,x,mid,1);
			}
		}
		int tmp=tr.query();
		if(tmp==n) return CLEAR(),1;
		for(int i=nxt(mid);i<=mx;i=nxt(i)){
			for(auto tmp:p[i]){
				int col=tmp.c,x=tmp.x;
				add(col,x,mid,1);
			}
			for(int id=beg();id<=i-mid-1;id=beg()){
				for(auto tmp:p[id]){
					int col=tmp.c,x=tmp.x;
					add(col,x,mid,-1);
				}
				dbeg();
			}
			int tmp=tr.query();
			if(tmp==n) return CLEAR(),1;
		}
		return CLEAR(),0;
	}
	inline bool check(int mid){
		int tmp=check(0,0,mid);
		if(tmp) return 1;
		tmp=check(0,1,mid);
		if(tmp) return 1;
		tmp=check(1,0,mid);
		if(tmp) return 1;
		return 0;
	}
	inline void main(){
		while(T--){
			n=read();
			mn=3e4,mx=0;
			for(int i=0;i<k;i++)
				for(int j=1;j<=n;j++)
					a[i][j]=read(),
					mn=min(a[i][j],mn),
					mx=max(a[i][j],mx);
			int l=0,r=mx-mn,ans=3e4;
			while(l<=r){
				int mid=l+r>>1;
				if(check(mid)) r=mid-1,ans=mid;
				else l=mid+1;
			}
			write(ans),putc('\n');
		}
		flush();
	}
}
```

[提交记录（7.39KB）](https://www.luogu.com.cn/record/104652553)

---

## 作者：luogu_gza (赞：3)

今天刚刚好在补春测的题目，来一发随机化的题解。

首先一个普通的贪心是很好想的，你考虑每一次移动对于答案的贡献，然后怎么计算都行。

**这个贪心是错误的！**

但是你考虑钦定贪心的顺序，就会发现，其实只要顺序正确，我们就一定可以找到答案！原因很简单，因为答案就是一个操作序列嘛，我们只要和答案的操作序列一样，求出的答案就是正确的捏！

再者，我们需要一个好的种子！

我选择了 $114514$。

我发现我的程序只要 $260$ 次就可以稳定求出答案！

[record](https://www.luogu.com.cn/record/122783964)

考场随机需谨慎，提防爆零两行泪。

---

## 作者：_Ch1F4N_ (赞：3)

暴力容斥复活之路！

# $k=1$

这个你肯定会。

# $k=2$

大的放上去，小的放下来。简单贪心。

# $k=3$

考虑二分答案。

然后考虑判断是否合法。

令当前答案为 $val$。

首先钦定最小值在第一行。

然后枚举最大值在哪一行。

现在我们就确定了两行可以填的数的范围。

剩下一行的选择就出来了。

现在问题是怎么判断剩下一行是否合法。

考虑把是否有一个长度为答案的区间覆盖所有点的问题转变为把每个点 $x$ 对区间 $[x,x+val]$ 做贡献。

然后看有没有点被贡献了 $n$ 遍。

但是同一个选择的点会重复贡献。

所以我们直接暴力容斥去除重复贡献。

这里由于值域很小，直接用差分维护。

# $k=4$

和 $k=3$ 的做法差不多。

一样的做法，把每个点对一个正方形，然后暴力容斥。

但是问题变成了二维数点。所以离线用线段树维护。

但是被贡献 $n$ 次的点有 $V^2$ 种情况，怎么办？

发现被贡献 $n$ 次的点一定是被贡献最多的点，所以在线段树上维护前缀和极值就可以了。

# 卡常

上面的做法复杂度是 $O(k^2 \times 2^k \times n \times \log^{k-2} (n \times 2^k))$。

那么开始卡常：

1. 大量使用位运算。

2. 记录最大访问到的位置，减少对没有访问的数组的清空。

3. 因为线段树只用维护单点修改，所以使用非递归线段树。

上面是核心的卡常思路，剩下一些小优化就看代码吧（15KB 慎入）。

# 代码

```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
using namespace std;
namespace IO{
    const int SIZE=1<<21;
    static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
    #define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
    #define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
    #define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
    #define puts(x) IO::Puts(x)
    template<typename T>
    inline void read(T&x){
        for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
        for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15); 
        x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
        for(int i=0;s[i];++i)
            putchar(s[i]);
        putchar('\n');
    }
    struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
const int maxk = 5,maxn = 5e4+14,maxv=3e4+10;
int a[maxn][maxk];
int k;
int ans(int j,int n){
    int mx=0,mi=65535;
    for(int i=1;i<=n;++i) mx=max(mx,a[i][j]),mi=min(mi,a[i][j]);
    return mx-mi;
}
vector<int> ch[maxn];//剩下一行可能的选择
int sum[maxv];//差分数组
int n;
int lwx;
inline void add(int l,int r,int val){//差分数组上修改
    r=min(r,maxv-7);
    sum[l]+=val;
    sum[r+1]-=val;
    lwx=max(lwx,r+1);
}
inline void maintain(){//统计差分数组
    for(register int i=1;i<=lwx;i=-~i) sum[i]+=sum[i-1];
}
bool check(int pos,int mx,int mi,int val){//最大值放在第 1 行，最小值放在第 pos 行 k=3 极值为 val 是否合法
    for(register int i=0;i<=lwx;i=-~i) sum[i]=0;
    lwx=0;
    for(register int i=1;i<=n;i=-~i) ch[i].clear();
    int r1=mx,l1=r1-val;
    int l2=mi,r2=l2+val;
    for(register int i=1;i<=n;i=-~i){
        if(l1<=a[i][1]&&a[i][1]<=r1&&l2<=a[i][pos]&&a[i][pos]<=r2){//确定区间的行填的数合法合法
            ch[i].push_back(a[i][((pos-2)^1)+2]);
        }
        a[i][1]=a[i][1]^a[i][2];
        a[i][2]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][3];
        a[i][3]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][3];
        //转锁调整数组
        if(l1<=a[i][1]&&a[i][1]<=r1&&l2<=a[i][pos]&&a[i][pos]<=r2){//确定区间的行填的数合法合法
            ch[i].push_back(a[i][((pos-2)^1)+2]);
        }
        a[i][1]=a[i][1]^a[i][2];
        a[i][2]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][3];
        a[i][3]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][3];
        if(l1<=a[i][1]&&a[i][1]<=r1&&l2<=a[i][pos]&&a[i][pos]<=r2){//确定区间的行填的数合法合法
            ch[i].push_back(a[i][((pos-2)^1)+2]);
        }
        if(ch[i].size()==0) return false;
        if(ch[i].size()==1){
            add(ch[i][0],ch[i][0]+val,1);
        }
        else if(ch[i].size()==2){
            add(ch[i][0],ch[i][0]+val,1);
            add(ch[i][1],ch[i][1]+val,1);
            int l=max(ch[i][0],ch[i][1]),r=min(ch[i][0]+val,ch[i][1]+val);
            if(l<=r)
                add(l,r,-1);
            //容斥处理
        }
        else {
            int l=min(ch[i][0],min(ch[i][1],ch[i][2])),r=mx;
            add(l,r,1);
        }
    }
    maintain();
    for(register int i=1;i<=n;i=-~i){
        if(ch[i].size()==0) continue;
        for(register int u:ch[i])
            if(sum[u]==n)//被所有区间包含，也就是区间 [u-val,u] 包含所有点
                return true;
    }   
    return false;
}
vector<int> wyb;
int tree[65536+10][2];//sum ans 和：最大前缀和 
vector< pair<int,int> > opt[maxn]; //pos:val
int top;
inline void add_p(pair<int,int> A,pair<int,int> B,int val){
    B.first=min(B.first,top);
    B.second=min(B.second,top);
    opt[B.first].push_back(make_pair(B.second,val));
    opt[A.first-1].push_back(make_pair(B.second,-val));
    opt[B.first].push_back(make_pair(A.second-1,-val));
    opt[A.first-1].push_back(make_pair(A.second-1,val));
    wyb.push_back(B.first);
    wyb.push_back(A.first-1);
    //二维差分 
}
//值域平移 1 
vector< pair<int,int> > chifan[maxn];
bool Check(int pos,int mx,int mi,int val){//最大值放在第 1 行，最小值放在第 pos 行 k=4 极值为 val 是否合法
    for(int u:wyb) opt[u].clear();
    wyb.clear();
    top=mx+2;
    memset(tree,0,sizeof(tree));
    for(register int i=1;i<=n;i=-~i) chifan[i].clear();
    int r1=mx,l1=r1-val;
    int l2=mi,r2=l2+val;
    int last;
    for(register int i=1;i<=n;i=-~i){
        if(l1<=a[i][1]&&a[i][1]<=r1&&l2<=a[i][pos]&&a[i][pos]<=r2){//确定区间的行填的数合法合法
            if(pos==2){
                chifan[i].push_back(make_pair(a[i][3],a[i][4]));
            }
            else if(pos==3){
                chifan[i].push_back(make_pair(a[i][2],a[i][4]));    
            }
            else{
                chifan[i].push_back(make_pair(a[i][2],a[i][3]));
            }
        }
        a[i][1]=a[i][1]^a[i][2];
        a[i][2]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][3];
        a[i][3]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][4];
        a[i][4]=a[i][1]^a[i][4];
        a[i][1]=a[i][1]^a[i][4];
        if(l1<=a[i][1]&&a[i][1]<=r1&&l2<=a[i][pos]&&a[i][pos]<=r2){//确定区间的行填的数合法合法
            if(pos==2){
                chifan[i].push_back(make_pair(a[i][3],a[i][4]));

            }
            else if(pos==3){
                chifan[i].push_back(make_pair(a[i][2],a[i][4]));

            }
            else{
                chifan[i].push_back(make_pair(a[i][2],a[i][3]));
            }
        }
        a[i][1]=a[i][1]^a[i][2];
        a[i][2]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][3];
        a[i][3]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][4];
        a[i][4]=a[i][1]^a[i][4];
        a[i][1]=a[i][1]^a[i][4];
        if(l1<=a[i][1]&&a[i][1]<=r1&&l2<=a[i][pos]&&a[i][pos]<=r2){//确定区间的行填的数合法合法
            if(pos==2){
                chifan[i].push_back(make_pair(a[i][3],a[i][4]));

            }
            else if(pos==3){
                chifan[i].push_back(make_pair(a[i][2],a[i][4]));

            }
            else{
                chifan[i].push_back(make_pair(a[i][2],a[i][3]));
            }
        }
        a[i][1]=a[i][1]^a[i][2];
        a[i][2]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][2];
        a[i][1]=a[i][1]^a[i][3];
        a[i][3]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][3];
        a[i][1]=a[i][1]^a[i][4];
        a[i][4]=a[i][1]^a[i][4];
        a[i][1]=a[i][1]^a[i][4];
        if(l1<=a[i][1]&&a[i][1]<=r1&&l2<=a[i][pos]&&a[i][pos]<=r2){//确定区间的行填的数合法合法
            if(pos==2){
                chifan[i].push_back(make_pair(a[i][3],a[i][4]));    
            }
            else if(pos==3){
                chifan[i].push_back(make_pair(a[i][2],a[i][4]));        
            }
            else{
                chifan[i].push_back(make_pair(a[i][2],a[i][3]));
            }
        }
        //下面开始容斥处理贡献 
        if(chifan[i].size()==0) return false;
        if(chifan[i].size()==1){
            add_p(chifan[i][0],make_pair(chifan[i][0].first+val,chifan[i][0].second+val),1);
        }
        else if(chifan[i].size()==2){
            add_p(chifan[i][0],make_pair(chifan[i][0].first+val,chifan[i][0].second+val),1);
            add_p(chifan[i][1],make_pair(chifan[i][1].first+val,chifan[i][1].second+val),1);
            pair<int,int> l=make_pair(max(chifan[i][0].first,chifan[i][1].first),max(chifan[i][0].second,chifan[i][1].second)),r=make_pair(min(chifan[i][0].first+val,chifan[i][1].first+val),min(chifan[i][0].second+val,chifan[i][1].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);              
            //容斥处理
        }
        else if(chifan[i].size()==3){
            add_p(chifan[i][0],make_pair(chifan[i][0].first+val,chifan[i][0].second+val),1);
            add_p(chifan[i][1],make_pair(chifan[i][1].first+val,chifan[i][1].second+val),1);
            add_p(chifan[i][2],make_pair(chifan[i][2].first+val,chifan[i][2].second+val),1);
            pair<int,int> l=make_pair(max(chifan[i][0].first,chifan[i][1].first),max(chifan[i][0].second,chifan[i][1].second)),r=make_pair(min(chifan[i][0].first+val,chifan[i][1].first+val),min(chifan[i][0].second+val,chifan[i][1].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][0].first,chifan[i][2].first),max(chifan[i][0].second,chifan[i][2].second)),r=make_pair(min(chifan[i][0].first+val,chifan[i][2].first+val),min(chifan[i][0].second+val,chifan[i][2].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][1].first,chifan[i][2].first),max(chifan[i][1].second,chifan[i][2].second)),r=make_pair(min(chifan[i][1].first+val,chifan[i][2].first+val),min(chifan[i][1].second+val,chifan[i][2].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][0].first,max(chifan[i][1].first,chifan[i][2].first)),max(chifan[i][0].second,max(chifan[i][1].second,chifan[i][2].second))),r=make_pair(min(chifan[i][0].first+val,min(chifan[i][1].first+val,chifan[i][2].first+val)),min(chifan[i][0].second+val,min(chifan[i][1].second+val,chifan[i][2].second+val)));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,1);
        }
        else{
            add_p(chifan[i][0],make_pair(chifan[i][0].first+val,chifan[i][0].second+val),1);
            add_p(chifan[i][1],make_pair(chifan[i][1].first+val,chifan[i][1].second+val),1);
            add_p(chifan[i][2],make_pair(chifan[i][2].first+val,chifan[i][2].second+val),1);
            add_p(chifan[i][3],make_pair(chifan[i][3].first+val,chifan[i][3].second+val),1);
            pair<int,int> l=make_pair(max(chifan[i][0].first,chifan[i][1].first),max(chifan[i][0].second,chifan[i][1].second)),r=make_pair(min(chifan[i][0].first+val,chifan[i][1].first+val),min(chifan[i][0].second+val,chifan[i][1].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][0].first,chifan[i][2].first),max(chifan[i][0].second,chifan[i][2].second)),r=make_pair(min(chifan[i][0].first+val,chifan[i][2].first+val),min(chifan[i][0].second+val,chifan[i][2].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][1].first,chifan[i][2].first),max(chifan[i][1].second,chifan[i][2].second)),r=make_pair(min(chifan[i][1].first+val,chifan[i][2].first+val),min(chifan[i][1].second+val,chifan[i][2].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][0].first,chifan[i][3].first),max(chifan[i][0].second,chifan[i][3].second)),r=make_pair(min(chifan[i][0].first+val,chifan[i][3].first+val),min(chifan[i][0].second+val,chifan[i][3].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][1].first,chifan[i][3].first),max(chifan[i][1].second,chifan[i][3].second)),r=make_pair(min(chifan[i][1].first+val,chifan[i][3].first+val),min(chifan[i][1].second+val,chifan[i][3].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][2].first,chifan[i][3].first),max(chifan[i][2].second,chifan[i][3].second)),r=make_pair(min(chifan[i][2].first+val,chifan[i][3].first+val),min(chifan[i][2].second+val,chifan[i][3].second+val));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
            l=make_pair(max(chifan[i][0].first,max(chifan[i][1].first,chifan[i][2].first)),max(chifan[i][0].second,max(chifan[i][1].second,chifan[i][2].second))),r=make_pair(min(chifan[i][0].first+val,min(chifan[i][1].first+val,chifan[i][2].first+val)),min(chifan[i][0].second+val,min(chifan[i][1].second+val,chifan[i][2].second+val)));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,1);
            l=make_pair(max(chifan[i][1].first,max(chifan[i][2].first,chifan[i][3].first)),max(chifan[i][1].second,max(chifan[i][2].second,chifan[i][3].second))),r=make_pair(min(chifan[i][1].first+val,min(chifan[i][2].first+val,chifan[i][3].first+val)),min(chifan[i][1].second+val,min(chifan[i][2].second+val,chifan[i][3].second+val)));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,1);
            l=make_pair(max(chifan[i][0].first,max(chifan[i][2].first,chifan[i][3].first)),max(chifan[i][0].second,max(chifan[i][2].second,chifan[i][3].second))),r=make_pair(min(chifan[i][0].first+val,min(chifan[i][2].first+val,chifan[i][3].first+val)),min(chifan[i][0].second+val,min(chifan[i][2].second+val,chifan[i][3].second+val)));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,1);
            l=make_pair(max(chifan[i][0].first,max(chifan[i][1].first,chifan[i][3].first)),max(chifan[i][0].second,max(chifan[i][1].second,chifan[i][3].second))),r=make_pair(min(chifan[i][0].first+val,min(chifan[i][1].first+val,chifan[i][3].first+val)),min(chifan[i][0].second+val,min(chifan[i][1].second+val,chifan[i][3].second+val)));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,1);
            l=make_pair(max(chifan[i][0].first,max(chifan[i][1].first,max(chifan[i][2].first,chifan[i][3].first))),max(chifan[i][0].second,max(chifan[i][1].second,max(chifan[i][2].second,chifan[i][3].second)))),r=make_pair(min(chifan[i][0].first+val,min(chifan[i][1].first+val,min(chifan[i][2].first+val,chifan[i][3].first+val))),min(chifan[i][0].second+val,min(chifan[i][1].second+val,min(chifan[i][2].second+val,chifan[i][3].second+val))));
            if(l.first<=r.first&&l.second<=r.second)
                add_p(l,r,-1);
        }
    }
    for(register int i=top;i>=0;i=-(-~(-~(~(i))))){
        if(opt[i].size()==0) continue;
        for(pair<int,int> u:opt[i]){
            int x=u.first+32768;
            tree[x][0]+=u.second;
            tree[x][1]+=u.second;
            x>>=1;
            while(x!=0){
                tree[x][0]=tree[x<<1][0]+tree[x<<1|1][0];
                tree[x][1]=min(tree[x<<1][1],tree[x<<1][0]+tree[x<<1|1][1]);
                x>>=1;
            }
        }
        if(tree[1][0]-tree[1][1]>=n) return true;
    }
    return false;
}
void work(){
    read(n);
    int mx=0,mi=maxv;
    for(register int i=1;i<=k;++i){
        for(register int j=1;j<=n;++j){
            read(a[j][i]);
            mx=max(mx,a[j][i]);
            mi=min(mi,a[j][i]);
        }
    }
    if(k==1){
        write(ans(1,n));
        putchar('\n');
    }
    else if(k==2){
        for(register int i=1;i<=n;++i){
            if(a[i][1]<a[i][2]) swap(a[i][1],a[i][2]);
        }
        write(max(ans(1,n),ans(2,n)));
        putchar('\n');
    }
    else if(k==3){
        int l=-1,r=(mx-mi);
        while(l+1<r){
            int mid=(l+r)>>1;
            if(check(2,mx,mi,mid)==true||check(3,mx,mi,mid)==true){
                r=mid;
            }
            else{
                l=mid;
            }
        }
        write(r);
        putchar('\n');
    }
    else{
        int l=-1,r=(mx-mi);
        while(l+1<r){
            int mid=(l+r)>>1;
            if(Check(4,mx,mi,mid)==true||Check(3,mx,mi,mid)==true||Check(2,mx,mi,mid)==true){
                r=mid;
            }
            else{
                l=mid;
            }
        }
        write(r);
        putchar('\n');
    }
    return ;
}
signed main(){
    int t;
    read(t);
    read(k);
    while(t--) work();
}
```


---

## 作者：Jsxts_ (赞：3)

好题。

以下默认 $k=4$。$k=1,2$ 都可以简单贪心在 $O(n)$ 时间内得出答案，这里不多解释。$k=3$ 后面会讲。

考虑二分答案，然后判断答案是否可能为 $\text{mid}$。

首先考虑整个矩形中最大的数 $\text{mx}$ 和最小的数 $\text{mn}$，假设它们不在同一行，那么考虑钦定 $\text{mx}$ 在第一行，枚举 $\text{mn}$ 在 $2,3,4$ 行的情况（在同一行肯定不优），现在假设在第 $2$ 行。之后对于每一列，枚举这一列所有可能的排列方式（即转若干下），如果这一列的第一行与 $\text{mx}$ 的差 $\le \text{mid}$ 并且第二行与 $\text{mn}$ 的差 $\le \text{mid}$，说明这一列在 $1,2$ 行满足 $\text{mid}$ 的限制。

考虑在剩下的两行，我们把两行的数抽象成一个点 $(x,y)$ 加入集合中，其中 $x$ 是这列第三行的数，$y$ 是第四行的。并且把同一列在集合里的点都染上同一种颜色（一列有 $4$ 个排列方式，也就有至多 $4$ 个点）。那么现在问题就转化为：在一个平面直角坐标系上，有一些有颜色的点，现在问能否找到一个 边长为 $\text{mid}$ 的正方形，使每种颜色都被覆盖至少一个点（可以自己想想为什么）。而对于 $k=3$，这里就少掉一维，变成了数轴上的问题（即每个点纵坐标都为 $1$）。

考虑解决转换后的问题。注意到值域为 $3e4$，考虑枚举正方形上边界，则下边界已经定好。那么对于夹在中间的点，每个点（设横坐标为 $x$）对 $[x-mid,x]$ 这个区间的左端点有 $1$ 的贡献。这样最后若有左端点权值为 $n$，证明以 $x$ 为左边界的横坐标，当前枚举的为上边界的一个正方形，就能覆盖 $n$ 个不同颜色的点。
也就是对于夹在中间的每个点，在 $[x-mid,x]$ 区间加 $1$，最后看是否有一个点的值为 $n$，即全局最大值为 $n$，用线段树很好维护。将上边界移动就是加入一行的点并删除一行的点，总共会加/删 $2kn$ 个点。

但是这样很明显是错的，因为同种颜色对同一个左端点不能有重复贡献，所以我们可以对每种颜色维护一个 $\text{multiset}$ 维护之前修改过的区间，然后新加一个区间修改时就把左右第一个之前修改过的区间找出来，使左右端点缩短到不会重复覆盖。

至此，整个问题就解决了，时间复杂度每组数据为 $O(nk\log^2n)$，勉强能跑。但是由于这题的 $T$ 可以达到很大，所以任何清空的操作都不能整个清空，只能把修改过的下标位置清空。

因为这题细节诸多，加上当时以为很快能写完就没注意实现，写了 7.7k，优化之后肯定可以短很多。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 2e9;
inline int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
int n,k,a[5][50010],mx,mn,xx,xy,nx,ny;
void roll(int c) {
	int t = a[k][c];
	for (int i = k;i;i -- ) a[i][c] = a[i - 1][c];
	a[1][c] = t;
}
void lock(int r,int x,int c) {
	while (x != r) roll(c), x = x % k + 1;
}
vector<pair<int,int> > vc[30010];
struct Seg {
	int l,r,mx,tag;
}t[120010];
void pushup(int x) {
	t[x].mx = max(t[x<<1].mx,t[x<<1|1].mx);
}
void build(int x,int l,int r) {
	t[x].l = l, t[x].r = r, t[x].mx = t[x].tag = 0;
	if (l == r) return;
	int mid = l + r >> 1;
	build(x<<1,l,mid), build(x<<1|1,mid+1,r);
}
void pushdown(int x) {
	t[x<<1].tag += t[x].tag, t[x<<1].mx += t[x].tag;
	t[x<<1|1].tag += t[x].tag, t[x<<1|1].mx += t[x].tag;
	t[x].tag = 0;
}
void modify(int x,int l,int r,int s) {
	if (l > r) return;
	if (t[x].l >= l && r >= t[x].r) {
		t[x].mx += s, t[x].tag += s;
		return;
	}
	pushdown(x);
	int mid = t[x].l + t[x].r >> 1;
	if (mid >= l) modify(x<<1,l,r,s);
	if (mid < r) modify(x<<1|1,l,r,s);
	pushup(x);
}
void print() {
	for (int i = 1;i <= k;i ++ , puts(""))
		for (int j = 1;j <= n;j ++ ) printf("%d ",a[i][j]);
	puts("");
}
struct node {
	int l,r;
	bool operator < (const node &x) const {
		return r < x.r;
	}
};
multiset<node> S[50010];
set<int> rub;
int b[50010],tot;
bool solve(int mid) {
	int res = 0;
	if (k == 3) {
//			cout << vc[1].size() << endl;
		for (int l = 0;l < vc[1].size();l ++ ) {
			int tl = vc[1][l].first,tj = vc[1][l].second,xl = max(tl - mid,1),xr = tl;
//				cout << tl << endl;
			if (!S[tj].size()) modify(1,xl,xr,1);
			else {
				auto x = S[tj].upper_bound({xl,xr});
				if (x != S[tj].end()) xr = min(xr,(*x).l - 1);
				if (x != S[tj].begin()) {
					x --;
					xl = max(xl,(*x).r + 1);
				}
				modify(1,xl,xr,1);
			}
//			cout << xl << ' ' << xr << endl;
			S[tj].insert({max(tl - mid,1),tl});
		}
		res = t[1].mx == n;
		for (int l = 0;l < vc[1].size();l ++ ) {
			int tl = vc[1][l].first,tj = vc[1][l].second,xl = max(tl - mid,1),xr = tl;
			S[tj].erase(S[tj].find({max(tl - mid,1),tl}));
			auto x = S[tj].upper_bound({xl,xr});
			if (x != S[tj].end()) xr = min(xr,(*x).l - 1);
			if (x != S[tj].begin()) {
				x --;
				xl = max(xl,(*x).r + 1);
			}
			modify(1,xl,xr,-1);
//			cout << xl << ' ' << xr << endl;
		}
		vc[1].clear();
		return res;
	}
	else {
		int r = tot;
		for (int i = tot;i;i -- ) {
			for (int l = 0;l < vc[b[i]].size();l ++ ) {
				int tl = vc[b[i]][l].first,tj = vc[b[i]][l].second,xl = max(tl - mid,1),xr = tl;
//				cout << tl << endl;
				if (!S[tj].size()) modify(1,xl,xr,1);
				else {
					auto x = S[tj].upper_bound({xl,xr});
					if (x != S[tj].end()) xr = min(xr,(*x).l - 1);
					if (x != S[tj].begin()) {
						x --;
						xl = max(xl,(*x).r + 1);
					}
					modify(1,xl,xr,1);
				}
				S[tj].insert({max(tl - mid,1),tl});
			}
			while (b[r] - mid > b[i]) {
				for (int l = 0;l < vc[b[r]].size();l ++ ) {
					int tl = vc[b[r]][l].first,tj = vc[b[r]][l].second,xl = max(tl - mid,1),xr = tl;
	//				cout << tl << endl;
					S[tj].erase(S[tj].find({max(tl - mid,1),tl}));
					auto x = S[tj].upper_bound({xl,xr});
					if (x != S[tj].end()) xr = min(xr,(*x).l - 1);
					if (x != S[tj].begin()) {
						x --;
						xl = max(xl,(*x).r + 1);
					}
					modify(1,xl,xr,-1);
				}
				r --;
			}
			res = max(res,t[1].mx);
		}
		while (r) {
			for (int l = 0;l < vc[b[r]].size();l ++ ) {
				int tl = vc[b[r]][l].first,tj = vc[b[r]][l].second,xl = max(tl - mid,1),xr = tl;
	//				cout << tl << endl;
				S[tj].erase(S[tj].find({max(tl - mid,1),tl}));
				auto x = S[tj].upper_bound({xl,xr});
				if (x != S[tj].end()) xr = min(xr,(*x).l - 1);
				if (x != S[tj].begin()) {
					x --;
					xl = max(xl,(*x).r + 1);
				}
				modify(1,xl,xr,-1);
			}
			r --;
		}
		return res == n;
	}
}
bool check(int mid) {
//	cout << mid << endl;
	ll ans = 0,res = 0;
	if (ny == xy) {
		if (k == 3) vc[1].push_back({a[nx ^ 1][ny],ny});
		else {
			if (nx == 2)
			vc[a[3][ny]].push_back({a[4][ny],ny}), rub.insert(a[3][ny]);
			if (nx == 3)
			vc[a[2][ny]].push_back({a[4][ny],ny}), rub.insert(a[2][ny]);
			if (nx == 4)
			vc[a[2][ny]].push_back({a[3][ny],ny}), rub.insert(a[2][ny]);
		}
		for (int j = 1;j <= n;j ++ ) {
			if (j == ny) continue;
			for (int i = 0;i < k;i ++ ) {
				roll(j);
//				cout << a[1][xy] - a[1][j]  << ' ' << a[nx][j] - a[nx][ny] << endl;
				if (a[1][xy] - a[1][j] <= mid && a[nx][j] - a[nx][ny] <= mid) {
//				print();
					if (k == 4) {
						if (nx == 2)
						vc[a[3][j]].push_back({a[4][j],j}), rub.insert(a[3][j]);
						if (nx == 3)
						vc[a[2][j]].push_back({a[4][j],j}), rub.insert(a[2][j]);
						if (nx == 4)
						vc[a[2][j]].push_back({a[3][j],j}), rub.insert(a[2][j]);
					}
					else vc[1].push_back({a[nx ^ 1][j],j});
				}
			}
		}
		if (k == 4)
		for (auto x : rub) b[++tot] = x;
		int res = solve(mid);tot = 0;
		if (k == 4)
		for (auto x : rub) vc[x].clear();rub.clear();
		return res;
	}
//	cout << 1;
	for (int T = 2;T <= 3 + (k == 4);T ++ ) {
		lock(T,nx,ny);
		nx = T;
		for (int i = 1;i <= k;i ++ )
			if (abs(a[i][xy] - a[i][ny]) > mid) goto bre;
//		print();
		if (k == 4) {
			if (T == 2)
			vc[a[3][ny]].push_back({a[4][ny],ny}), rub.insert(a[3][ny]),
			vc[a[3][xy]].push_back({a[4][xy],xy}), rub.insert(a[3][xy]);
			if (T == 3)
			vc[a[2][ny]].push_back({a[4][ny],ny}), rub.insert(a[2][ny]),
			vc[a[2][xy]].push_back({a[4][xy],xy}), rub.insert(a[2][xy]);
			if (T == 4)
			vc[a[2][ny]].push_back({a[3][ny],ny}), rub.insert(a[2][ny]),
			vc[a[2][xy]].push_back({a[3][xy],xy}), rub.insert(a[2][xy]);
		}
		else vc[1].push_back({a[T ^ 1][xy],xy}), vc[1].push_back({a[T ^ 1][ny],ny});
		for (int j = 1;j <= n;j ++ ) {
			if (j == ny || j == xy) continue;
			for (int i = 0;i < k;i ++ ) {
				roll(j);
				if (a[1][xy] - a[1][j] <= mid && a[T][j] - a[T][ny] <= mid) {
					if (k == 4) {
						if (T == 2)
						vc[a[3][j]].push_back({a[4][j],j}), rub.insert(a[3][j]);
						if (T == 3)
						vc[a[2][j]].push_back({a[4][j],j}), rub.insert(a[2][j]);
						if (T == 4)
						vc[a[2][j]].push_back({a[3][j],j}), rub.insert(a[2][j]);
					}
					else vc[1].push_back({a[T ^ 1][j],j});
				}
			}
		}
		if (k == 4)
		for (auto x : rub) b[++tot] = x;
		res = solve(mid);tot = 0;
		if (k == 4)
		for (auto x : rub) vc[x].clear();rub.clear();
		if (res) return 1;
		bre:;
	}
	return 0;
}
int main() {
//	freopen("lock5.in","r",stdin);
	int T = read();
	k = read();
	while (T -- ) {
		n = read();
		mx = 0,mn = inf,xx = 0,xy = 0,nx = 0,ny = 0;
		for (int i = 1;i <= k;i ++ )
			for (int j = 1;j <= n;j ++ ) {
				a[i][j] = read();
				if (mx < a[i][j]) mx = a[i][j], xx = i, xy = j;
				if (mn > a[i][j]) mn = a[i][j], nx = i, ny = j;
			}
		if (k == 1) {
			printf("%d\n",mx - mn);
			continue;
		}
		if (k == 2) {
			int mx1 = 0,mx2 = 0,mn1 = inf,mn2 = inf;
			for (int i = 1;i <= n;i ++ ) {
				if (a[1][i] > a[2][i]) swap(a[1][i],a[2][i]);
				mx1 = max(mx1,a[1][i]), mn1 = min(mn1,a[1][i]), mx2 = max(mx2,a[2][i]), mn2 = min(mn2,a[2][i]);
			}
			printf("%d\n",max(mx1 - mn1,mx2 - mn2));
			continue;
		}
		int f = xy == ny;
		while (xx != 1) {
			roll(xy), xx = xx % k + 1;
			if (f) nx = nx % k + 1;
		}
	build(1,1,mx);
//		print();
//		cout << nx << ' ' << ny << ' ' << xx << ' ' << xy << endl;
		int l = 0,r = mx - mn;
		while (l < r) {
			int mid = l + r >> 1;
			if (check(mid)) r = mid;
			else l = mid + 1;
		}
		printf("%d\n",l);
	}
	return 0;
}
/*
19 3
3
20614 19730 1512
10536 6776 21382
7158 19188 5477
*/
```


---

## 作者：x383494 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9120)

[cnblogs](https://www.cnblogs.com/x383494/p/17737657.html)

## 闲话

duliu 题，写了 10k。

## 题意

形式化地，对于 $1 \leq i \leq k$，定义密码锁第 $i$ 行的松散度为

$$
c(i) = \max \limits _ {j = 1} ^ n a _ {i, j} - \min \limits _ {j = 1} ^ n a _ {i, j} 
$$

同时定义整个密码锁的松散度为

$$
C = \max \limits _ {1 \leq i \leq k} c(i)
$$

求拨动若干次后最小的 $C$ 值。

第一类测试点共有十二个，保证 $k \leq 3$，$n \leq 5 \times 10 ^ 4$，$\sum n \leq 1.5 \times 10 ^ 5$。

第二类测试点共有八个，保证 $k = 4$，$n \leq 10 ^ 4$，
$\sum n \leq 3 \times 10 ^ 4$。

## 做法

对 $k$ 的大小分类讨论。

$k=1,2$ 做法显然，略。

### $k=3$

思路：

$$
\left\{ 
\begin{aligned}
& \text{dp} \\
& \text{转为二分判定} \\
& \text{模拟退火}
\end{aligned}
\right.
$$

看起来转为二分判定比较靠谱。

二分时钦定最大值在第一行，枚举最小值在哪一行。

有最大值/最小值的行容易判断是否合法。对于剩下一行，问题转化为：数轴上多个带颜色的点，求是否有一个长度为（当前二分的答案）的区间覆盖每个颜色的点至少一个。

设目前二分的答案为 $x$，将每个点 $i$ 替换为 $[i, i+x+1)$ 的区间，则这些区间的交即为上述问题区间的右端点。问题再次转化为：数轴上多个区间，求是否存在至少被 $n$ 个区间覆盖的点。注意，对于同种颜色的点，区间要先取并。

区间覆盖即区间加，可以用差分维护。最后将差分数组做一个前缀和，途中顺便检查是否有点的值等于 $n$ 即可。

时间复杂度 $O((n+a) \log a)$。

```cpp
bool check3(int x, int mn, int mx, bool dmn){ // mx on first{{{
    std::fill(delta, delta+A+1, 0); // 差分数组
    static std::vector<std::pair<int, int>> segs(3); // 使用类珂树维护区间并
    UP(i, 0, in){
        bool valid = false;
        segs.clear();
        UP(j, 0, 3){
            if(mx-ia[i][j] <= x && ia[i][(1+dmn+j)%3]-mn <= x){
                valid = true;
                int pl = ia[i][(1+!dmn+j)%3];
                segs.push_back({ pl, std::min(A, pl+x+1) }); // [l, r)
            }
        }
        if(!valid) return false;
        std::sort(segs.begin(), segs.end());
        for(auto k=segs.begin();;){
            auto j = k; j++;
            if(j == segs.end() || j->first > k->second){
                delta[k->first]++;
                delta[k->second]--;
                if(j == segs.end()) break;
                k = j;
            } else {
                k->second = j->second;
                segs.erase(j);
            }
        }
    }
    if(delta[0] == in) return true;
    UP(i, 1, A){
        delta[i] += delta[i-1];
        if(delta[i] == in) return true;
    }
    return false;
}/*}}}*/
```

### $k=4$

与 $k=3$ 类似，但区间交换成了矩形交。

问题是，二维差分数组的规模达到了 $\Theta(n^2)$，必定超时。

我会 KDT！对所有单点离线建树，跑 $\Theta(n)$ 次查询矩阵和。

然而结果是 TLE。

考虑扫描线，用线段树维护动态的最值。

```cpp
bool check4(int x, int mn, int mx, int dmn){ // mx on first{{{
    static std::vector< std::tuple<int, int, int, int >> pts; // x, delta, yl, yr
    static std::vector<std::tuple<int, int, int, int>> lines; // x, yl, yr, delta
    static std::multiset<std::pair<int, int>> segs; // x, yl, yr, delta
    pts.clear();
    UP(i, 0, in){
        bool valid = false;
        lines.clear();
        UP(j, 0, 4){
            if(mx-ia[i][j] <= x && ia[i][(1+dmn+j)%4]-mn <= x){
                valid = true;
                int xx = ia[i][(1+(dmn+1)%3+j)%4], 
                    yy = ia[i][(1+(dmn+2)%3+j)%4];
                lines.push_back({ xx, yy, std::min(A, yy+x+1), 1 });
                lines.push_back({ std::min(A, xx+x+1), yy, std::min(A, yy+x+1), -1 });
            }
        }
        if(!valid) return false;
        segs.clear();
        std::sort(lines.begin(), lines.end());
        int lastx = -1;
        for(auto j:lines){
            if(lastx != -1 && !segs.empty()){
                int lasty = segs.begin()->first;
                for(auto k=segs.begin(); ;){
                    auto add = [&](){
                        pts.push_back({lastx, 1, lasty, k->second});
                        pts.push_back({std::get<0>(j), -1, lasty, k->second});
                    };
                    auto l=k; l++;
                    if(l==segs.end() || l->first > k->second){
                        add();
                        lasty = l->first;
                        if(l == segs.end()) break;
                        k=l;
                    } else {
                        k=l;
                    }
                }
            }
            if(std::get<3>(j) == -1){
                segs.erase(segs.find({std::get<1>(j), std::get<2>(j)}));
            } else {
                segs.insert({std::get<1>(j), std::get<2>(j)});
            }
            lastx = std::get<0>(j);
        }
    }
    std::sort(pts.begin(), pts.end());
    segt::nodcnt = 0;
    segt::Node *rt = segt::build(segt::nnod(), 0, A);
    for(auto i:pts){
        segt::add(rt, std::get<2>(i), std::get<3>(i), std::get<1>(i));
        if(rt->mx == in) return true;
    }
    return false;
}/*}}}*/
```

然而这样做开了 `-O3` 仍然会在 LOJ 上 TLE 四个点，获得 80 pts 的好成绩。

注意到每次线段树的形态都是不变的，可以打 tag 标记线段树的清空。可以获得 100 pts 的好成绩。

时间复杂度 $O(n \log^2 a)$。

由于你谷 Blog 不支持 <details>，这里直接放出 10 KiB 完整代码：

```cpp
#include <set>
#include <vector>
#include <iostream>
#include <functional>
#include <tuple>
#include <algorithm>
#define UP(i,s,e) for(auto i=s; i<e; ++i)
#define USE_SEGT 1
#define DEBUG_SEGT 0
namespace IO{
    struct IOer{
        IOer& operator>>(int& x){
            x=0; static char c = getchar();
            while(!isdigit(c)) c = getchar();
            while(isdigit(c)){
                x = x*10 + c-'0';
                c = getchar();
            }
            return *this;
        }
        IOer& operator<<(int x){
            printf("%d", x);
            return *this;
        }
        IOer& operator<<(char x){
            putchar(x);
            return *this;
        }
    };
}
IO::IOer cin, cout;
//using std::cin; using std::cout;
constexpr int N = 5e4, A = 3e4+1;
namespace KDT{ // }{{{
constexpr int SIZ = 24*N;
struct Point{
    int x, y, delta;
    bool operator<(Point b){
        if(x != b.x) return x < b.x;
        return y < b.y;
    }
};
bool cmpx(Point a, Point b){ return a.x < b.x; }
bool cmpy(Point a, Point b){ return a.y < b.y; }
std::function<bool(Point, Point)> cmps[] = {cmpx, cmpy};
struct Node{
    Node *ls, *rs;
    int xl, xr, yl, yr, sum;
} nil_, *nil=&nil_, nds[SIZ];
int nodcnt=0;
Node *nnod(){ return nds+nodcnt++; }
void upd(Node *rt){
    if(rt->ls == nil) return;
    rt->xl = std::min(rt->ls->xl, rt->rs->xl);
    rt->xr = std::max(rt->ls->xr, rt->rs->xr);
    rt->yl = std::min(rt->ls->yl, rt->rs->yl);
    rt->yr = std::max(rt->ls->yr, rt->rs->yr);
    rt->sum = rt->ls->sum + rt->rs->sum;
}
Node *build(Node *rt, int l, int r, Point *data, int dim=0){
    if(l == r-1){
        rt->xl = data[l].x;
        rt->yl = data[l].y;
        rt->sum = data[l].delta;
        rt->xr = rt->xl+1;
        rt->yr = rt->yl+1;
        rt->ls = rt->rs = nil;
        return rt;
    }
    int mid = (l+r)/2;
    std::nth_element(data+l, data+mid, data+r, cmps[dim]);
    rt->ls = build(nnod(), l, mid, data, dim^1);
    rt->rs = build(nnod(), mid, r, data, dim^1);
    upd(rt);
    return rt;
}
int querysum(Node *rt, int xl, int xr, int yl, int yr){
    if(rt->xl >= xr || rt->xr <= xl || rt->yl >= yr || rt->yr <= yl){
        return 0;
    }
    if(rt->xl >= xl && rt->xr <= xr && rt->yl >= yl && rt->yr <= yr){
        return rt->sum;
    }
    return querysum(rt->ls, xl, xr, yl, yr) +
        querysum(rt->rs, xl, xr, yl, yr);
}
} // {}}}
namespace segt{ // }{{{
constexpr int SIZ = A*2;
struct Node{
    Node *ls, *rs;
    int l, r;
    int lazy;
    int mx;
    bool cleartag;
} nil_, *nil=&nil_, nds[SIZ];
int nodcnt = 0;
Node *nnod(){ return nds+nodcnt++; }
void upd(Node *rt){
    if(rt->ls == nil){
        rt->mx = rt->lazy;
        return;
    }
    rt->mx = std::max(rt->ls->mx, rt->rs->mx) + rt->lazy;
}
void pushd(Node *rt){
    if(!rt->cleartag) return;
    rt->cleartag = false;
    rt->lazy = rt->mx = 0;
    if(rt->ls == nil) return;
    rt->ls->cleartag = rt->rs->cleartag = true;
    rt->ls->mx = rt->rs->mx = 0;
}
Node *build(Node *rt, int l, int r){
    rt->l = l; rt->r = r;
    rt->lazy = rt->mx = 0;
    if(l == r-1){
        rt->ls = rt->rs = nil;
        return rt;
    }
    int mid = (l+r)/2;
    rt->ls = build(nnod(), l, mid);
    rt->rs = build(nnod(), mid, r);
    return rt;
}
void add(Node *rt, int l, int r, int delta){
    if(rt->r <= l || rt->l >= r) return;
    pushd(rt);
    if(rt->l >= l && rt->r <= r){
        rt->lazy += delta;
        upd(rt);
        return;
    }
    add(rt->ls, l, r, delta);
    add(rt->rs, l, r, delta);
    upd(rt);
}
} // {}}}
namespace m{ // }{{{
int ia[N][4], in;
int delta[A+1];
void init(int k){
    cin >> in;
    UP(j, 0, k) UP(i, 0, in){
        cin >> ia[i][j];
    }
}
int calcc(int k){
    int mn = ia[0][k], mx = ia[0][k];
    UP(i, 0, in){
        mn = std::min(mn, ia[i][k]); 
        mx = std::max(mx, ia[i][k]);
    }
    return mx-mn;
}
bool check3(int x, int mn, int mx, bool dmn){ // mx on first{{{
    std::fill(delta, delta+A+1, 0);
    static std::vector<std::pair<int, int>> segs(3);
    UP(i, 0, in){
        bool valid = false;
        segs.clear();
        UP(j, 0, 3){
            if(mx-ia[i][j] <= x && ia[i][(1+dmn+j)%3]-mn <= x){
                valid = true;
                int pl = ia[i][(1+!dmn+j)%3];
                segs.push_back({ pl, std::min(A, pl+x+1) }); // [l, r)
                //delta[ia[i][(1+!dmn+j)%3]] += 1;
                //delta[std::min(in, ia[i][(1+!dmn+j)%3]+x+1)] -= 1;
            }
        }
        if(!valid) return false;
        std::sort(segs.begin(), segs.end());
        for(auto k=segs.begin();;){
            auto j = k; j++;
            if(j == segs.end() || j->first > k->second){
                delta[k->first]++;
                delta[k->second]--;
                if(j == segs.end()) break;
                k = j;
            } else {
                k->second = j->second;
                segs.erase(j);
            }
        }
    }
    if(delta[0] == in) return true;
    UP(i, 1, A){
        delta[i] += delta[i-1];
        if(delta[i] == in) return true;
    }
    return false;
}/*}}}*/
bool check4(int x, int mn, int mx, int dmn){ // mx on first{{{
#if USE_SEGT
    static std::vector<
        std::tuple<int, int, int, int
#if DEBUG_SEGT
        , int
#endif
        >> pts; // x, delta, yl, yr
#else
    static std::vector<KDT::Point> pts; // x, y, delta
#endif
    static std::vector<std::tuple<int, int, int, int>> lines; // x, yl, yr, delta
    static std::multiset<std::pair<int, int>> segs;
    // x, yl, yr, delta
    pts.clear();
    UP(i, 0, in){
        bool valid = false;
        lines.clear();
        UP(j, 0, 4){
            if(mx-ia[i][j] <= x && ia[i][(1+dmn+j)%4]-mn <= x){
                valid = true;
                int xx = ia[i][(1+(dmn+1)%3+j)%4], 
                    yy = ia[i][(1+(dmn+2)%3+j)%4];
                lines.push_back({
                        xx,
                        yy,
                        std::min(A, yy+x+1),
                        1
                        });
                lines.push_back({
                        std::min(A, xx+x+1),
                        yy,
                        std::min(A, yy+x+1),
                        -1
                        });
            }
        }
        if(!valid) return false;
        segs.clear();
        std::sort(lines.begin(), lines.end());
        int lastx = -1;
        for(auto j:lines){
            if(lastx != -1 && !segs.empty()){
                int lasty = segs.begin()->first;
                for(auto k=segs.begin(); ;){
                    auto add = [&](){
#if USE_SEGT
#if DEBUG_SEGT
                        pts.push_back({lastx, 1, lasty, k->second, i});
                        pts.push_back({std::get<0>(j), -1, lasty, k->second, i});
#else
                        pts.push_back({lastx, 1, lasty, k->second});
                        pts.push_back({std::get<0>(j), -1, lasty, k->second});
#endif
#else
                        pts.push_back({lastx, lasty, 1});
                        pts.push_back({lastx, k->second, -1});
                        pts.push_back({std::get<0>(j), lasty, -1});
                        pts.push_back({std::get<0>(j), k->second, 1});
#endif
                    };
                    auto l=k; l++;
                    if(l==segs.end() || l->first > k->second){
                        add();
                        lasty = l->first;
                        if(l == segs.end()) break;
                        k=l;
                    } else {
                        k=l;
                    }
                }
            }
            if(std::get<3>(j) == -1){
                segs.erase(segs.find({std::get<1>(j), std::get<2>(j)}));
            } else {
                segs.insert({std::get<1>(j), std::get<2>(j)});
            }
            lastx = std::get<0>(j);
        }
    }
    std::sort(pts.begin(), pts.end());
#if USE_SEGT
    // segt::nodcnt = 0;
    static segt::Node *rt = segt::build(segt::nnod(), 0, A);
    rt->cleartag = true;
    for(auto i:pts){
        segt::add(rt, std::get<2>(i), std::get<3>(i), std::get<1>(i));
        if(rt->mx == in) return true;
    }
#else
    for(auto i=pts.begin(); ; ){
        auto j=i; j++;
        if(j == pts.end()) break;
        if(i->x == j->x && i->y == j->y){
            i->delta += j->delta;
            pts.erase(j);
        } else {
            if(i->delta == 0) pts.erase(i);
            i=j;
        }
    }
    KDT::nodcnt = 0;
    KDT::Node *rt = KDT::build(KDT::nnod(), 0, pts.size(), pts.data());
    for(auto i:pts){
        if(KDT::querysum(rt, 0, i.x+1, 0, i.y+1) == in) return true;
    }
#endif
    return false;
}/*}}}*/
void work1(){ init(1); cout << calcc(0) << '\n'; }
void work2(){ init(2); UP(i, 0, in){ if(ia[i][0] > ia[i][1]) std::swap(ia[i][0], ia[i][1]); } cout << std::max(calcc(0), calcc(1)) << '\n'; }
void work3(){
    init(3);
    int mx=ia[0][0], mn=ia[0][0];
    UP(i, 0, in) UP(j, 0, 3){
        mx = std::max(mx, ia[i][j]);
        mn = std::min(mn, ia[i][j]);
    }
    int l=-1, r=mx-mn+0; // (l, r]
    while(r-l>1){
        int mid=(l+r)/2;
        if(check3(mid, mn, mx, true) || check3(mid, mn, mx, false)){
            r=mid;
        } else l=mid;
    }
    cout << r << '\n';
}
void work4(){
    init(4);
    int mx=ia[0][0], mn=ia[0][0];
    UP(i, 0, in) UP(j, 0, 4){
        mx = std::max(mx, ia[i][j]);
        mn = std::min(mn, ia[i][j]);
    }
    int l=-1, r=mx-mn+0; // (l, r]
    while(r-l>1){
        //int mid= (r-l) > 100 ? r-(r-l)/4 : (l+r)/2;
        int mid = (l+r)/2;
        if(check4(mid, mn, mx, 0) || check4(mid, mn, mx, 1) || check4(mid, mn, mx, 2)){
            r=mid;
        } else l=mid;
    }
    cout << r << '\n';
}
} // {}}}
using namespace m;
int main(){
    int it, ik;
    cin >> it >> ik;
    UP(i, 0, it){
        if(ik == 1) work1();
        else if(ik == 2) work2();
        else if(ik == 3) work3();
        else work4();
    }
    return 0;
}
```



---

## 作者：赵悦岑 (赞：2)

[我的博客](https://2745518585.github.io/post/NOI-spring-test-T4-solution/)

## 题意

给你一个 $k$ 行 $n$ 列的矩阵（$k \leq 4$），每次可以选定一列进行一次循环位移，定义 $c(i)$ 为任意次操作后第 $i$ 行的最大值与最小值之差，求 $\max c(i)$ 的最小值。

## 提示

尝试二分答案。

考虑全局最大值一定是某一行的最大值，全局最小值一定是某一行最小值。

最大值和最小值在不同行一定不劣于在同一行。

## 思路

最大值最小，考虑二分答案。

接下来我们要判定 $\forall i,c(i)\leq x$。我们按 $k$ 从小到大解决。

$k=1$ 显然等于最大值减最小值。

假如我们已经钦定了某一行的最大值 $mx_i$，显然在这一行的每一数应该大于等于 $mx_i-x$。但是直接枚举显然不优。我们发现全局最大值 $mx$ 一定是某一行的最大值，由于行与行之间没有区别，我们直接钦定 $mx_1 = mx$。

同理，我们也可以发现全局最小值 $mn$ 也一定是某一行的最小值。如果把 $mx$ 和 $mn$ 放在同一行，答案 $mx-mn$ 显然达到了上界，所以把 $mx$ 和 $mn$ 不同行一定不劣。所以我们钦定 $mx_1 = mx,mn_2 = mn$，就可以判断每一列是否可能满足限制。至此，我们已经解决了 $k=2$。

对于 $k=3$ 的情况，我们可以钦定 $mx_1 = mx$，但是最小值在第二行或第三行实际上是不同的情况，所以我们需要枚举最小值所在的行，令剩下没有钦定的行为 $i$，钦定最小值为 $mn_i$。对于某一列，总共有三种情况，首先要去除不满足全局最大最小限制的情况，还要满足 $a_i \leq mn_i + x$，即
$$
a_i-x \leq mn_i \leq a_i
$$
总共有 $O(n)$ 个这样的式子，$mn_i$ 必须要满足每一列至少有一个式子成立。显然如果存在这样一个 $mn_i$，一定可以找到一个这一行的数满足每一列至少成立一个式子（即向上找到第一个上界）。问题转化为有 $n$ 种区间，求是否存在一个点使得每种区间都存在一个区间包含这个点。我们只需要使用扫描线，用一个数组记录当前点被第 $i$ 种区间包含了多少次即可。

对于 $k=4$ 的情况，我们用一样的方法，发现变量变成了两个，即有 $O(n)$ 组

$$
\left\{
\begin{aligned}
a_i-x \leq mn_i \leq a_i\\
a_j-x \leq mn_j \leq a_j
\end{aligned}
\right.
$$

这样的式子，$mn_i$ 与 $mn_j$ 必须满足每一列至少有一组式子成立。转换过来就变成了二维的，有 $n$ 种矩阵，求平面上是否存在一个点使得每种矩阵都存在一个矩阵包含这个点。同样考虑扫描线，用线段树维护当前高度的一条线上每个点被多少种区间覆盖，和这个的全局最大值，但是这里不好去重，我采用的比较暴力的方法：由于每种矩阵最多只有 $4$ 个，所以我们可以容斥一下变成至多 $15$ 个矩阵。我们只需要判断被覆盖的区间数的最大值是不是 $n$ 即可。

## code

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1000001;
int n,m,k,q,mx,mn,a[N][4],e[N];
struct node
{
    int x1,x2,y1,y2;
    node() {}
    node(int x1,int x2,int y1,int y2):x1(x1),x2(x2),y1(y1),y2(y2) {}
}b[N][4];
struct line
{
    int x1,x2,h,u;
    line() {}
    line(int x1,int x2,int h,int u):x1(x1),x2(x2),h(h),u(u) {}
}c[N<<5];
bool cmp(line a,line b)
{
    return a.h<b.h;
}
struct tree
{
    int l,r,s,k;
}T[N<<2];
void pushup(int x)
{
    T[x].s=max(T[x<<1].s,T[x<<1|1].s);
}
void pushdown(int x)
{
    if(T[x].k==0) return;
    T[x<<1].s+=T[x].k;
    T[x<<1].k+=T[x].k;
    T[x<<1|1].s+=T[x].k;
    T[x<<1|1].k+=T[x].k;
    T[x].k=0;
}
void build(int x,int l,int r)
{
    T[x].l=l;
    T[x].r=r;
    T[x].s=T[x].k=0;
    if(l==r) return;
    int z=l+r>>1;
    build(x<<1,l,z);
    build(x<<1|1,z+1,r);
    pushup(x);
}
void add(int x,int l,int r,int k)
{
    if(l>r) return;
    if(T[x].l>=l&&T[x].r<=r)
    {
        T[x].s+=k;
        T[x].k+=k;
        return;
    }
    pushdown(x);
    int z=T[x].l+T[x].r>>1;
    if(l<=z) add(x<<1,l,r,k);
    if(r>z) add(x<<1|1,l,r,k);
    pushup(x);
}
void add_node(int u,node p1=node(1,3e4,1,3e4),node p2=node(1,3e4,1,3e4),node p3=node(1,3e4,1,3e4),node p4=node(1,3e4,1,3e4))
{
    int x1=max(max(p1.x1,p2.x1),max(p3.x1,p4.x1));
    int x2=min(min(p1.x2,p2.x2),min(p3.x2,p4.x2));
    int y1=max(max(p1.y1,p2.y1),max(p3.y1,p4.y1));
    int y2=min(min(p1.y2,p2.y2),min(p3.y2,p4.y2));
    if(x1<=x2&&y1<=y2)
    {
        c[++q]=line(x1,x2,y1,u);
        c[++q]=line(x1,x2,y2+1,-u);
    }
}
bool check()
{
    q=0;
    for(int i=1;i<=n;++i)
    {
        add_node(1,b[i][0]);
        add_node(1,b[i][1]);
        add_node(1,b[i][2]);
        add_node(1,b[i][3]);
        add_node(-1,b[i][0],b[i][1]);
        add_node(-1,b[i][0],b[i][2]);
        add_node(-1,b[i][0],b[i][3]);
        add_node(-1,b[i][1],b[i][2]);
        add_node(-1,b[i][1],b[i][3]);
        add_node(-1,b[i][2],b[i][3]);
        add_node(1,b[i][0],b[i][1],b[i][2]);
        add_node(1,b[i][0],b[i][1],b[i][3]);
        add_node(1,b[i][0],b[i][2],b[i][3]);
        add_node(1,b[i][1],b[i][2],b[i][3]);
        add_node(-1,b[i][0],b[i][1],b[i][2],b[i][3]);
    }
    sort(c+1,c+q+1,cmp);
    build(1,1,m);
    int x=1;
    for(int i=1;i<=m;++i)
    {
        while(x<=q&&c[x].h==i)
        {
            add(1,c[x].x1,c[x].x2,c[x].u);
            ++x;
        }
        if(T[1].s==n) return true;
    }
    return false;
}
int find(int x)
{
    return lower_bound(e+1,e+m+1,x)-e;
}
bool solve(int x)
{
    for(int i=1;i<=3;++i)
    {
        for(int j=1;j<=n;++j)
        {
            for(int k=0;k<=3;++k) b[j][k]=node(1,1,0,0);
        }
        for(int j=1;j<=n;++j)
        {
            for(int k=0;k<=3;++k)
            {
                if(mx-a[j][k]>x||a[j][(k+i)%4]-mn>x) continue;
                int z1=0,z2=0;
                if(i==1) z1=a[j][(k+2)%4],z2=a[j][(k+3)%4];
                if(i==2) z1=a[j][(k+1)%4],z2=a[j][(k+3)%4];
                if(i==3) z1=a[j][(k+1)%4],z2=a[j][(k+2)%4];
                b[j][k]=node(find(max(1,z1-x)),find(z1),find(max(1,z2-x)),find(z2));
            }
        }
        if(check()) return true;
    }
    return false;
}
namespace Solve2
{
    bool solve(int x)
    {
        for(int i=1;i<=n;++i)
        {
            bool u=false;
            for(int j=0;j<=1;++j)
            {
                if(mx-a[i][j]>x||a[i][(j+1)%2]-mn>x) continue;
                u=true;
            }
            if(!u) return false;
        }
        return true;
    }
}
namespace Solve3
{
    int c[N],q;
    struct str
    {
        int x,h,u;
        str() {}
        str(int x,int h,int u):x(x),h(h),u(u) {}
    }b[N];
    bool cmp(str a,str b)
    {
        return a.h<b.h;
    }
    bool check()
    {
        sort(b+1,b+q+1,cmp);
        for(int i=1;i<=n;++i) c[i]=0;
        int x=1,s=0;
        for(int i=1;i<=m;++i)
        {
            while(x<=q&&b[x].h==i)
            {
                if(c[b[x].x]==0) ++s;
                c[b[x].x]+=b[x].u;
                if(c[b[x].x]==0) --s;
                ++x;
            }
            if(s==n) return true;
        }
        return false;
    }
    bool solve(int x)
    {
        for(int i=1;i<=2;++i)
        {
            q=0;
            for(int j=1;j<=n;++j)
            {
                for(int k=0;k<=2;++k)
                {
                    if(mx-a[j][k]>x||a[j][(k+i)%3]-mn>x) continue;
                    int z=0;
                    if(i==1) z=a[j][(k+2)%3];
                    if(i==2) z=a[j][(k+1)%3];
                    b[++q]=str(j,find(max(1,z-x)),1);
                    b[++q]=str(j,find(z+1),-1);
                }
            }
            if(check()) return true;
        }
        return false;
    }
}
void abc()
{
    scanf("%d",&n);
    mx=1,mn=3e4;
    m=0;
    for(int i=0;i<=k-1;++i)
    {
        for(int j=1;j<=n;++j)
        {
            scanf("%d",&a[j][i]);
            e[++m]=a[j][i];
            mx=max(mx,a[j][i]);
            mn=min(mn,a[j][i]);
        }
    }
    if(k==1)
    {
        printf("%d\n",mx-mn);
        return;
    }
    sort(e+1,e+m+1);
    m=unique(e+1,e+m+1)-e-1;
    auto chk=[&](int x)
    {
        if(k==2) return Solve2::solve(x);
        if(k==3) return Solve3::solve(x);
        if(k==4) return solve(x);
        return false;
    };
    int l=0,r=3e4;
    while(l<r)
    {
        int z=l+r>>1;
        if(chk(z)) r=z;
        else l=z+1;
    }
    printf("%d\n",l);
}
int main()
{
    int T;
    scanf("%d%d",&T,&k);
    while(T--) abc();
    return 0;
}
```



---

## 作者：Nightingale_OI (赞：1)

## P9120

### 大意

给定 $k \times n$ 的二维数组，你可以任意次让任意一列循环位移，求最后每行极差的最大值最小是多少。

### 思路

$k=1$ 时，无法更改数组，输出最大值减最小值。

最大值最小，二分最大的极差，并把整个数组的最大值换到第一行。  
记整个数组的最大值为 $X$，最小值为 $Y$，二分的值为 $C$，值域为 $V$。

$k=2$ 时，最小值一定在第二行（在第一行时不影响），第一行的取值范围是 $[X-C,X]$，第二行的取值范围是 $[Y,Y+C]$。

$k=3$ 时，枚举最小值在哪一行，同样可以确定两行的取值范围。  
枚举每一列如何循环位移，找出对于剩下那一行，每一列可以取哪些值。  
问题变为是否有一个长度为 $C$ 的区间使得每一列有至少一种取值在里面。  
顺序枚举最靠右在里面的点，注意不要写成 $\mathcal{O}(V)$。

$k=4$ 时，类比上面做法，枚举最小值在哪一行，每一列 $i$ 记录若干个数对 $(x,y)$ 表示第一行（未确定取值范围的行，下同）和第二行分别可以取的值。  
问题变为是否有一个边长为 $C$ 的正方形覆盖每一列的点（数对）至少一次。  
再进行一下转化，把每个数对变为以其为左下角边长为 $C$ 颜色为 $i$ 的正方形，是否有一个点同时被所有颜色的正方形覆盖（该点相当于原问题正方形的右上角）。

![如图（图不会挂了吧）](https://cdn.luogu.com.cn/upload/image_hosting/nyhm4p3c.png)

只有 $m$ 种不同的循环位移，则每列（每种颜色）最多 $m$ 个正方形。  
先通过容斥把所有相同颜色的正方形的并用若干个矩形的和差表示，将同颜色的并里面点值都加 $1$，求是否有位置等于 $n$。  
用扫描线维护这个平面（后有详细做法），每次更改时看最大值是否为 $n$。

此做法复杂度为 $\mathcal{O}(2^kn\log n\log V) $，需要非常优秀的常数，我乱来，理论能过。

在扫描线对于一行修改时可以差分把区间改拆成前缀改，保证相同的只用数据结构改一次，这样容斥得到的 $2^k$ 个矩形会变为 $\mathcal{O}(k)$ 个不同的前缀改，同时减少线段树常数。

若是还过不去，发现正方形的数量和 $C$ 正相关，即 $C$ 越大每次判断时间越多，尝试调整二分（比如前几次每次跳 $\frac34$ 处）。

------------

#### 扫描线

$N$ 次将一个矩形内所有整点加 $w_i$，并求最后全局最大值是否等于 $n$。

枚举矩形**边缘**的 $y$ 坐标，每个矩形看成在上边界被扫到前区间加 $w_i$，在下边界被扫到后区间减 $w_i$。  
一整行所有区间加算完后求全局最大值，线段树维护即可。


### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
// #define int long longs
#define f(i,j,k) for(register int i=j;i<=k;++i)
#define g(i,j,k) for(register int i=j;i>=k;--i)
int n,m,s,l;
const int N=3e5+7;
int a[N][5],b[N],c[N],d[N],u[N],v[N];
int o,p,q,r,tot,cnt,all,ex,xx,yy,zz;
vector<int>xw[N];
struct Dusk{
	struct xds{
		int l,r,c,t;
	}a[N];
	void bt(int id,int l,int r){
		a[id]=(xds){l,r,0,0};
		if(l<r)bt(id<<1,l,(l+r)/2),bt(id<<1|1,(l+r)/2+1,r);
	}
	void add(int id,const register int&r,const register int&c){
		if(a[id].r<=r)return a[id].c+=c,a[id].t+=c,void();
		if(a[id<<1].r<r)add(id<<1|1,r,c);add(id<<1,r,c);
		a[id].c=max(a[id<<1].c,a[id<<1|1].c)+a[id].t;
	}
}T;
struct Flametail{
	int a,b,c,d;
	inline bool operator<(const Flametail&y)const{return c==y.c?d<y.d:c<y.c;}
	inline Flametail operator*(const Flametail&y)const{return (Flametail){max(a,y.a),min(b,y.b),max(c,y.c),min(d,y.d)};}
}ls;
vector<Flametail>e[N],f[N];
const Flametail ____=(Flametail){1,N,1,N};
void ycl(){cin>>m;T.bt(1,1,6e4);}
int In(int l,int r,int x){return l<=x&&x<=r;}
void rol(int i){f(j,1,m)a[i][j-1]=a[i][j];a[i][m]=a[i][0];}
void su(int*a,int&n){sort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;}
void cg(int x,int w,int&ans){if(v[x])--ans;v[x]+=w;if(v[x])++ans;}
void doing(){
	cin>>n;
	f(j,1,m)f(i,1,n)scanf("%d",&a[i][j]);
	s=l=a[1][1];
	f(i,1,n)f(j,1,m)s=max(s,a[i][j]),l=min(l,a[i][j]);
	if(m==1)return printf("%d\n",s-l),void();/////////////////////////k=1//////////
	f(i,1,n){
		f(j,1,m)if(a[i][j]==s)p=1;
		if(p){
			f(j,1,m)swap(a[1][j],a[i][j]);
			break;
		}
	}
	f(j,1,m)if(a[1][j]==s)p=j;
	f(_,2,p)rol(1);
	register int L=0,R=s-l,C;
	if(m==4){
		all=0;
		f(i,1,n)f(j,1,m)u[++all]=a[i][j];
		su(u,all);
	}
	while(L<R){
		C=(L+R)>>1;p=0;
		if(L+200<R)C=L+(R-L)/4*3;
		if(m==2){/////////////////////////////////////////////////////k=2//////////
			p=1;q=0;
			f(i,1,n){
				f(_,1,m){
					q|=(In(s-C,s,a[i][1])&&In(l,l+C,a[i][2]));
					rol(i);
				}
				p&=q;q=0;
			}
		}else if(m==3){///////////////////////////////////////////////k=3//////////
			f(lp,2,3){
				q=tot=0;cnt=1;
				f(i,1,n)f(_,1,m){
					if(In(s-C,s,a[i][1])&&In(l,l+C,a[i][lp]))xw[b[++tot]=a[i][5-lp]].push_back(i);
					rol(i);
				}
				su(b,tot);
				f(i,1,tot){
					for(int x:xw[b[i]])cg(x,1,q);
					for(;b[cnt]+C<b[i];++cnt)for(int x:xw[b[cnt]])cg(x,-1,q);
					if(q==n)p=1;
				}
				f(i,cnt,tot)for(int x:xw[b[i]])cg(x,-1,q);
				f(i,1,n)f(j,1,m)xw[a[i][j]].clear();
			}
		}else{////////////////////////////////////////////////////////k=4//////////
			f(lp,2,4)if(!p){
				tot=0;
				f(i,1,n)e[i].clear();
				f(i,1,n)f(_,1,m){
					if(In(s-C,s,a[i][1])&&In(l,l+C,a[i][lp])){
						if(lp==2)xx=a[i][3],yy=a[i][4];
						if(lp==3)xx=a[i][2],yy=a[i][4];
						if(lp==4)xx=a[i][2],yy=a[i][3];
						e[i].push_back((Flametail){xx,xx+C+1,yy,yy+C+1});
					}
					rol(i);
				}
				f(i,1,n){
					ex=e[i].size();cnt=(1<<ex)-1; 
					f(S,1,cnt){
						ls=____;zz=1;
						f(w,0,ex-1)if((S>>w)&1)ls=ls*e[i][w],zz=-zz;
						if(ls.a>=ls.b||ls.c>=ls.d)continue;
						f[ls.c].push_back((Flametail){ls.a,ls.b,-zz,0});
						f[ls.d].push_back((Flametail){ls.a,ls.b,zz,0});
					}
				}
				f(i,1,all)c[i]=u[i],c[i+all]=u[i]+C+1;
				inplace_merge(c+1,c+all+1,c+(tot=all*2)+1);o=0;
				f(i,1,tot)if(f[q=c[i]].size()){
					for(auto w:f[q])d[b[++o]=w.a]-=w.c,d[b[++o]=w.b]+=w.c;
					f(i,1,o)if(d[r=b[i]])T.add(1,r,d[r]),d[r]=0;
					if(T.a[1].c==n)p=1;f[q].clear();o=0;
				}
			}
		}
		if(p)R=C;
		else L=C+1;
	}
	printf("%d\n",R);
}
signed main(){
	int t;
	cin>>t;
	ycl();
	while(t--)doing();
	return 0; 
}
```

---


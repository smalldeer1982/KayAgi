# [NOI2023] 方格染色

## 题目描述

有一个 $n$ 列 $m$ 行的棋盘，共 $n \times m$ 个方格，我们约定行、列均从 $1$ 开始标号，且第 $i$ 列、第 $j$ 行的方格坐标记为 $(i, j)$。初始时，所有方格的颜色均为白色。现在，你要对这个棋盘进行 $q$ 次染色操作。

染色操作分为三种，分别为：

1. 将一条横线染为黑色。具体地说，给定两个方格 $(x_1, y_1)$ 和 $(x_2, y_2)$，保证 $x_1 \le x_2$，$y_1 = y_2$，将这两个方格之间的所有方格（包括这两个方格）染为黑色。
2. 将一条竖线染为黑色。具体地说，给定两个方格 $(x_1, y_1)$ 和 $(x_2, y_2)$，保证 $x_1 = x_2$，$y_1 \le y_2$，将这两个方格之间的所有方格（包括这两个方格）染为黑色。
3. 将一条斜线染为黑色。具体地说，给定两个方格 $(x_1, y_1)$ 和 $(x_2, y_2)$，保证 $x_1 \le x_2$，$x_2 - x_1 = y_2 - y_1$，将这两个方格之间斜线上所有形如 $(x_1 + i, y_1 + i)$（$0 \le i \le x_2 - x_1$）的方格染为黑色。**这种染色操作发生的次数不超过 $5$ 次。**

现在你想知道，在经过 $q$ 次染色后，棋盘上有多少个黑色的方格。

## 说明/提示

**【样例解释 #1】**

在这组样例中，我们一共做了三次染色操作，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ojo6cs1.png)

第一次操作时，将 $(1, 3), (2, 3), (3, 3), (4, 3), (5, 3)$ 染为黑色。

第二次操作时，将 $(3, 1), (3, 2), (3, 3), (3, 4), (3, 5)$ 染为黑色。

第三次操作时，将 $(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)$ 染为黑色。

**【样例解释 #2】**

这个样例满足测试点 $1 \sim 5$ 的条件限制。

**【样例解释 #3】**

这个样例满足测试点 $6 \sim 9$ 的条件限制。

**【样例解释 #4】**

这个样例满足测试点 $10 \sim 13$ 的条件限制。

**【样例解释 #5】**

这个样例满足测试点 $14 \sim 17$ 的条件限制。

**【样例解释 #6】**

这个样例满足测试点 $18 \sim 19$ 的条件限制。

**【样例解释 #7】**

这个样例满足测试点 $20$ 的条件限制。

**【数据范围】**

对于所有测试数据保证：$1 \le n, m \le 10 ^ 9$，$1 \le q \le 10 ^ 5$，$1 \le x_1, x_2 \le n$，$1 \le y_1, y_2 \le m$，**且最多有 $5$ 次第三种染色操作**。

|测试点编号|$n, m \le$|$q \le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1 \sim 5$|$300$|$300$|无|
|$6 \sim 9$|$10 ^ 5$|$2,000$|无|
|$10 \sim 13$|$10 ^ 5$|$10 ^ 5$|A|
|$14 \sim 17$|$10 ^ 5$|$10 ^ 5$|B|
|$18 \sim 19$|$10 ^ 5$|$10 ^ 5$|无|
|$20$|$10 ^ 9$|$10 ^ 5$|无|

特殊性质 A：保证只有第一种染色操作。

特殊性质 B：保证只有第一种和第二种染色操作。

Update on 2023-08-04: 更新一组 Hack 数据，该 Hack 数据的 $c = 0$。

## 样例 #1

### 输入

```
0
5 5 3
1 1 3 5 3
2 3 1 3 5
3 1 1 5 5
```

### 输出

```
13
```

## 样例 #2

### 输入

```
见附件中的 color/color2.in。```

### 输出

```
见附件中的 color/color2.ans。```

## 样例 #3

### 输入

```
见附件中的 color/color3.in。```

### 输出

```
见附件中的 color/color3.ans。```

## 样例 #4

### 输入

```
见附件中的 color/color4.in。```

### 输出

```
见附件中的 color/color4.ans。```

## 样例 #5

### 输入

```
见附件中的 color/color5.in。```

### 输出

```
见附件中的 color/color5.ans。```

## 样例 #6

### 输入

```
见附件中的 color/color6.in。```

### 输出

```
见附件中的 color/color6.ans。```

## 样例 #7

### 输入

```
见附件中的 color/color7.in。```

### 输出

```
见附件中的 color/color7.ans。```

# 题解

## 作者：pikiuk (赞：14)

考虑直接求覆盖面积不好求，转而求直线两两相交的点数，再用总的减掉。

先把可以合并的直线/斜线合并起来，并对其端点离散化，下文默认不存在重叠的线，且直线端点的值域是 $\mathcal{O}(q)$ 级别的。

对于斜线的处理是简单的，我们可以对于每条斜线，枚举每条直线，$\mathcal{O}(1)$ 计算交点个数。

对于直线和直线之间的相交，我们发现只有横线和竖线之间能产生贡献，因此对横线的 $y$ 坐标做扫描线，竖线的贡献相当于单点加，区间查询，用 BIT 维护即可。如果不愿意离散化直线端点，可以考虑可持久化线段树维护。

综合时间复杂度 $\mathcal{O}(q\log q)$。

---

## 作者：12345678hzx (赞：13)

## 闲话
这是应该是这几年最简单的题了，连我这个菜鸡都会 $95$ 分做法。
## 思路
前面 $95$ 分其实就是一个扫描线模板，不懂的可以[左转题目](https://www.luogu.com.cn/problem/P5490)。

这题与扫描线模板有些不同，此题给出的是格子的坐标，而扫描线模板给出的是点的坐标，我们在读入时只需将它们的右下角坐标都加 $1$ 即可。

对于斜线，由于最多只有 $5$ 条，且长度不超过 $10^5$，只需将斜线暴力拆成一个一个点即可。

接下来讲满分做法。

如果只有横线或竖线，那么总面积是好求的，如果只有斜线也可以将它们暴力合并，算出总面积，考虑如何将这两部分合并。

事实上，由于斜线的性质，一条斜线最多只会与一条横线或竖线的一个点相交，显然这个点是好求的，但是如果一条斜线与多条横线或竖线相交在同一个位置就会算重，所以可以用一个 $\operatorname{map}$ 记录哪些点已经被算过了，答案就是这两部分的面积和减去重叠部分。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<vector>
#include<map>

using namespace std;

struct node{
	int cnt;
	long long x,X,y;
}l[1000005],e[15];
struct tree{
	int l,r,lazy;
	long long val;
}t[4000005];
bool cmp(node a,node b) {
	return a.y<b.y;
}
long long n,tot,TOT,sum,a[1000005],ans;
map<pair<int,int>,int>Map;
void build(int p,int l,int r) {
	if(l>r) return;
	t[p].l=l,t[p].r=r,t[p].lazy=t[p].val=0;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(p*2,l,mid),build(p*2+1,mid+1,r);
}
void update(int p) {
	if(t[p].lazy) t[p].val=a[t[p].r+1]-a[t[p].l];
	else t[p].val=t[p*2].val+t[p*2+1].val;
}
void change(int p,int L,int R,int cnt) {
	if(t[p].l==L&&t[p].r==R) {
		t[p].lazy+=cnt;
		update(p);
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(R<=mid) change(p*2,L,R,cnt);
	else if(L>mid) change(p*2+1,L,R,cnt);
	else change(p*2,L,mid,cnt),change(p*2+1,mid+1,R,cnt);
	update(p);
}
int main() {
	cin>>n>>n>>n>>n;
	for(int i=1;i<=n;i++) {
		int op,x,X,y,Y;
		cin>>op>>x>>y>>X>>Y;
		if(op==3) e[++sum].x=x,e[sum].X=X,e[sum].y=y;
		else l[++tot*2-1].x=x,l[tot*2-1].X=X,l[tot*2-1].y=y,l[tot*2-1].cnt=1,l[tot*2].x=x,l[tot*2].X=X,l[tot*2].y=Y,l[tot*2].cnt=-1,a[tot*2-1]=x,a[tot*2]=X;
	}
	int cnt=1;
	while(cnt) {
		cnt=0;
		for(int i=1;i<=sum;i++) 
		for(int j=1;j<=sum;j++) 
		if(j!=i&&e[i].y&&e[j].y&&e[i].y-e[i].x==e[j].y-e[j].x) 
		if(e[j].x>=e[i].x&&e[j].X<=e[i].X||e[i].x<=e[j].x&&e[j].x<=e[i].X&&e[i].X<=e[j].X) cnt++,e[i].x=min(e[i].x,e[j].x),e[i].X=max(e[i].X,e[j].X),e[i].y=min(e[i].y,e[j].y),e[j].y=0;
	}
	for(int i=1;i<=sum;i++) {
		if(!e[i].y) continue;
		ans+=e[i].X-e[i].x+1;
		for(int j=1;j<=2*tot;j+=2) {
			long long x=l[j].y-e[i].y+e[i].x,y=l[j].x+e[i].y-e[i].x;
			if(l[j].x==l[j].X&&l[j].x>=e[i].x&&l[j].x<=e[i].X&&y>=l[j].y&&y<=l[j+1].y) {
				if(!Map[make_pair(l[j].x,y)]) Map[make_pair(l[j].x,y)]=1,ans--;
			}
			else if(l[j].y==l[j+1].y&&l[j].y>=e[i].y&&l[j].y<=e[i].y+e[i].X-e[i].x&&x>=l[j].x&&x<=l[j].X) if(!Map[make_pair(x,l[j].y)]) Map[make_pair(x,l[j].y)]=1,ans--;
		}
	}
	for(int i=1;i<=2*tot;i++) {
		l[i].x--;
		if(i&1) l[i].y--,a[i]--;
	}
	sort(a+1,a+1+2*tot),sort(l+1,l+1+2*tot,cmp),TOT=unique(a+1,a+1+2*tot)-a-1,build(1,1,TOT);
	for(int i=1;i<2*tot;i++) {
		int L=lower_bound(a+1,a+TOT+1,l[i].x)-a,R=lower_bound(a+1,a+TOT+1,l[i].X)-a-1;
		change(1,L,R,l[i].cnt),ans+=t[1].val*(l[i+1].y-l[i].y);
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：Gaode_Sean (赞：7)

近七年来最简单的 D1T1。

考虑**分别**算出所有直线和斜线的面积并。前者可以用扫描线，后者暴力求解即可。

此时我们还要减掉斜线和直线的交点数。我们可以对于每条斜线，枚举每一条直线，判断两者是否有交点。

由于某些交点可能会被扫描两次，所以用一个 map 维护交点是否被计算过。

时间复杂度 $\mathcal{O}(q \log q)$。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
typedef long long ll;
struct node
{
	int cnt;
	ll x1,x2,y;
}l[N*2],line[1000];
bool cmp(node a,node b){return a.y<b.y;}
struct tree
{
	int l,r,lz; ll val;
}t[N*8];
int c,n,ca,m,q,tot,tott,s,tota;
ll a[2*N],ans;
vector<int> vec[N];
map< pair<int,int> ,int> mp;
void build(int p,int l,int r)
{
	t[p].l=l,t[p].r=r,t[p].lz=t[p].val=0;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
int work(ll t)
{
	int l=1,r=tott;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(a[mid]>=t) r=mid;
		else l=mid+1;
	}
	return l;
}
void update(int p){if(t[p].lz>0){t[p].val=a[t[p].r+1]-a[t[p].l];}else{t[p].val=t[p*2].val+t[p*2+1].val;}}
void change(int p,int L,int R,int cnt)
{
	if(t[p].l==L&&t[p].r==R){t[p].lz+=cnt;update(p);return;}
	int mid=(t[p].l+t[p].r)>>1;
	if(R<=mid) change(p*2,L,R,cnt);
	else if(L>mid) change(p*2+1,L,R,cnt);
	else
	{
		change(p*2,L,mid,cnt);
		change(p*2+1,mid+1,R,cnt);
	}
	update(p);
}
int main()
{
	scanf("%d%d%d%d",&c,&n,&m,&q);
	for(int i=1;i<=q;i++)
	{
		int id; scanf("%d",&id);
		ll x1,x2,y1,y2;
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
		if(x1!=x2&&y1!=y2)
		{
			line[++s].x1=x1,line[s].x2=x2,line[s].y=y1;
			continue;
		}
		tot++;
		l[tot*2-1].x1=x1,l[tot*2-1].x2=x2,l[tot*2-1].y=y1,l[tot*2-1].cnt=1;
		l[tot*2].x1=x1,l[tot*2].x2=x2,l[tot*2].y=y2,l[tot*2].cnt=-1;
		a[tot*2-1]=x1,a[tot*2]=x2;
	}
	while(1)
	{
		int cnt=0;
		for(int i=1;i<=s;i++)
		{
			for(int j=1;j<=s;j++)
			{
				if(j!=i&&line[i].y&&line[j].y&&line[i].y-line[i].x1==line[j].y-line[j].x1)
				{
					if(line[j].x1>=line[i].x1&&line[j].x2<=line[i].x2||line[i].x1<=line[j].x1&&line[j].x1<=line[i].x2&&line[i].x2<=line[j].x2)
					{
						cnt++;
						line[i].x1=min(line[i].x1,line[j].x1);
						line[i].x2=max(line[i].x2,line[j].x2);
						line[i].y=min(line[i].y,line[j].y);
						line[j].y=0;
					}
				}
			}
		}
		if(!cnt) break;
	}
	for(int i=1;i<=s;i++) if(line[i].y) ans+=line[i].x2-line[i].x1+1;
	for(int i=1;i<=2*tot;i+=2)
	{
		if(l[i].y==l[i+1].y)
		{
			if(!mp[make_pair(l[i].y,0)]) mp[make_pair(l[i].y,0)]=++tota;
			vec[mp[make_pair(l[i].y,0)]].push_back(i);
		}
		else if(l[i].x1==l[i].x2)
		{
			if(!mp[make_pair(0,l[i].x1)]) mp[make_pair(0,l[i].x1)]=++tota;
			vec[mp[make_pair(0,l[i].x1)]].push_back(i);
		}
	}
	for(int i=1;i<=s;i++)
	{
		if(!line[i].y) continue;
		for(int j=1;j<=2*tot;j+=2)
		{    
		    ll xx=l[j].y-line[i].y+line[i].x1,yy=l[j].x1+line[i].y-line[i].x1;
			if(l[j].x1==l[j].x2&&l[j].x1>=line[i].x1&&l[j].x1<=line[i].x2&&yy>=l[j].y&&yy<=l[j+1].y)
			{
				if(!mp[make_pair(l[j].x1,yy)]) mp[make_pair(l[j].x1,yy)]=1,ans--;
			}
			else if(l[j].y==l[j+1].y&&l[j].y>=line[i].y&&l[j].y<=line[i].y+line[i].x2-line[i].x1&&xx>=l[j].x1&&xx<=l[j].x2)
			{
				if(!mp[make_pair(xx,l[j].y)]) mp[make_pair(xx,l[j].y)]=1,ans--;
			}
		}
	}
	for(int i=1;i<=2*tot;i++)
	{
		l[i].x1--;
		if(i&1) l[i].y--,a[i]--;
	}
	sort(a+1,a+1+2*tot);
	sort(l+1,l+1+2*tot,cmp);
	tott=unique(a+1,a+1+2*tot)-a-1;
	build(1,1,tott);
	for(int i=1;i<2*tot;i++)
	{
	    int L=work(l[i].x1),R=work(l[i].x2)-1;
	    change(1,L,R,l[i].cnt);
	    ans+=t[1].val*(l[i+1].y-l[i].y);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Purslane (赞：5)

# Solution

NOI 为什么会出这么简单的题目。不过我省队都进不了，管这些干什么。

考虑没有斜线应该怎么做。这个坐标定义不符合我的直觉，我转化为从上到下从左到右的吧。

很容易知道是把同一行同一列有重叠的线段合并成一条，现在我们就只有可能一横一纵重合的线段了，而且重合部分肯定是单个格子。这一部分可以使用扫描线完成。

>> 具体地，你把横线当做修改，把竖线当做询问，每次查询有多少条横线穿过这条竖线。可以离散化之后树状数组，也可以直接动态开点线段树。

然后考虑斜线的影响。由于斜线的数量很少很少，可以直接容斥。具体的，我们枚举斜线的集合，看看他们有没有交，假设斜线的个数是 $z$。这一对斜线的交集有可能是一条直线，长度为 $p$；当然还有可能是交集。

答案要先加上 $(-1)^{p-1}$，这是被覆盖 $p$ 次的线段；然后再加上交集和之前横线竖线的交点的贡献，假设有 $h$ 个，那么答案加上 $(-1)^ph$，因为它们被覆盖了 $p+1$ 次。注意可能和横线和竖线都有交，我们要用哈希或者 `set` 去重。

总的复杂度是 $O(n \log n + 2^k n \log n)$，足以通过本题。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int T,n,m,q,ans,op[MAXN],x[MAXN],y[MAXN],X[MAXN],Y[MAXN];
int tot3,xx[6],yy[6],XX[6],YY[6];
map<int,vector<pair<int,int>>> h,v;
int tot1,tot2; map<int,vector<pair<int,int>>> upd,qr; set<int> occur;
struct Segment {int x,y,X,Y;}s1[MAXN],s2[MAXN];
int tot,rt,sum[MAXN*30],lson[MAXN*30],rson[MAXN*30];
#define mid (l+r>>1)
void update(int &u,int l,int r,int pos,int v) {
	if(u==0) u=++tot;
	if(l==r) return sum[u]+=v,void();
	if(pos<=mid) update(lson[u],l,mid,pos,v);
	else update(rson[u],mid+1,r,pos,v);
	sum[u]+=v;
	return ;
}
int query(int u,int l,int r,int x,int y) {
	if(u==0) return 0;
	if(x<=l&&r<=y) return sum[u];
	if(y<=mid) return query(lson[u],l,mid,x,y);
	if(x>mid) return query(rson[u],mid+1,r,x,y);
	return query(lson[u],l,mid,x,y)+query(rson[u],mid+1,r,x,y);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T>>n>>m>>q;
	ffor(i,1,q) {
		cin>>op[i]>>x[i]>>y[i]>>X[i]>>Y[i];
		if(op[i]==1) v[y[i]].push_back({x[i],X[i]});
		else if(op[i]==2) h[x[i]].push_back({y[i],Y[i]});
		else xx[++tot3]=x[i],yy[tot3]=y[i],XX[tot3]=X[i],YY[tot3]=Y[i];
	}
	for(auto pr:h) {
		int x=pr.first; auto vc=pr.second;
		map<int,int> pre;
		for(auto seg:vc) pre[seg.first]++,pre[seg.second+1]--;
		int lstl=-1,sum=0;
		for(auto val:pre) {
			int id=val.first,v=val.second;
			sum=sum+v;
			if(sum==0) {
				if(lstl!=-1) s1[++tot1]={x,lstl,x,id-1},occur.insert(lstl),occur.insert(id),upd[lstl].push_back({x,1}),upd[id].push_back({x,-1}),ans+=id-lstl;
				lstl=-1;
			}
			else if(lstl==-1) lstl=id;
		}
	}
	for(auto pr:v) {
		int x=pr.first,pos; auto vc=pr.second;
		auto it=occur.upper_bound(x); if(it!=occur.begin()) pos=*(--it); else pos=-1;
		map<int,int> pre;
		for(auto seg:vc) pre[seg.first]++,pre[seg.second+1]--;
		int lstl=-1,sum=0;
		for(auto val:pre) {
			int id=val.first,v=val.second;
			sum+=v;
			if(sum==0) {
				if(lstl!=-1) s2[++tot2]={lstl,x,id-1,x},ans+=id-lstl,qr[pos].push_back({lstl,id-1});
				lstl=-1;
			} else if(lstl==-1) lstl=id;
		}
	}
	for(auto pr:upd) {
		int x=pr.first; auto vc=pr.second;
		for(auto seg:vc) {
			int pos=seg.first,v=seg.second;
			update(rt,1,n,pos,v);
		}
		vc=qr[x];
		for(auto seg:vc) {
			int x=seg.first,y=seg.second;
			ans-=query(rt,1,n,x,y);
		}
	}
	ffor(i,1,(1<<tot3)-1) {
		int mul=-1;
		int dt=-INT_MAX,l=1,r=n,err=0;
		ffor(j,1,tot3) if(i&(1<<j-1)) {
			mul=-mul;
			if(dt==-INT_MAX) dt=yy[j]-xx[j];
			else if(dt!=yy[j]-xx[j]) err=1;
			l=max(l,xx[j]),r=min(r,XX[j]);
		}
		//y=x+dt
		if(err||l>r) continue;
		int tot=r-l+1,cnt0=0;
		map<pair<int,int>,int> mp; //Dont calculate it two times , stupid !
		ffor(j,1,tot1) {
			//x=k
			int dx=s1[j].x,dy=dx+dt;
			if(dy<=s1[j].Y&&dy>=s1[j].y&&dx>=l&&dx<=r) {
				if(mp[make_pair(dx,dy)]==0) ans+=-mul,cnt0++;
				mp[make_pair(dx,dy)]=1;
			}
		}
		ffor(j,1,tot2) {
			//y=k
			int dy=s2[j].y,dx=dy-dt;
			if(dx>=s2[j].x&&dx<=s2[j].X&&dx>=l&&dx<=r) {
				if(mp[make_pair(dx,dy)]==0) ans+=-mul,cnt0++;
				mp[make_pair(dx,dy)]=1;
			}
		}
		ans+=mul*tot;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：FireBladeMaster (赞：5)

没有斜线的时候是一个经典的扫描线问题，我们把一条横线或者竖线直接当成一个矩形做矩形并面积，这是一个经典的扫描线问题，复杂度为 $O(q\log q)$。

有斜线的时候，我们先把重叠的斜线合并起来，剩余的斜线互相平行所以不会相交。

我们先画所有横竖线，然后统计每条斜线会让多少个点变黑，也就是统计一条斜线上有多少个点已经被染黑，用斜线长度减去这个值就是这条斜线的贡献。

只要枚举直线，由于每条直线与斜线最多有一个交点，求出有多少不同的交点即可。这部分复杂度为 $O(kq\log q)$，$k$ 为斜线数量。

```cpp
// wo shi huahua
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <queue>
#include <assert.h>
#include <math.h>
#include <set>
#define odb(x) printf("%lld ",x)
#define odl(x) printf("%lld\n",x)
#define odp(x,y) printf("%lld %lld\n",x,y)
#define int long long
inline int read()
{
    int num=0,f=1;char c=getchar();
    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
    while(c>47&&c<58)num=num*10+(c^48),c=getchar();
    return num*f;
}
int lx[1234567],ly[1234567];
struct op{
	int x,y,z,w,tp;
}a[1234567];
int cx,cy;
void FX(int &x){x=std::lower_bound(lx+1,lx+1+cx,x)-lx;}
void FY(int &y){y=std::lower_bound(ly+1,ly+1+cy,y)-ly;}
struct qwq{
	int l,r;
};
std::vector<qwq>s[1234567][2];
namespace segt{
	int mn[1234567],cc[1234567],tag[1234567];
	int Q(){return mn[1]==0?cc[1]:0;}
	#define lc o*2
	#define rc o*2+1
	void pd(int o){tag[lc]+=tag[o],tag[rc]+=tag[o],mn[lc]+=tag[o],mn[rc]+=tag[o],tag[o]=0;}
	void pu(int o)
	{
		mn[o]=std::min(mn[lc],mn[rc]);
		cc[o]=0;
		if(mn[o]==mn[lc])cc[o]+=cc[lc];
		if(mn[o]==mn[rc])cc[o]+=cc[rc];
	}
	void add(int o,int l,int r,int L,int R,int v)
	{
		if(L<=l&&r<=R)
		{
			tag[o]+=v;
			mn[o]+=v;
			return;
		}
		pd(o);
		int m=l+r>>1;
		if(L<=m)add(lc,l,m,L,R,v);
		if(m<R)add(rc,m+1,r,L,R,v);
		pu(o);
	}
	void add(int l,int r,int v)
	{
		add(1,1,cy-1,l,r,v);
	}
	void build(int o,int l,int r)
	{
		if(l==r)
		{
			cc[o]=ly[l+1]-ly[l];
			mn[o]=tag[o]=0;
			return;
		}
		int m=l+r>>1;
		build(lc,l,m);
		build(rc,m+1,r);
		pu(o);
	}
}
using namespace segt;
int tmp[1234567];
op b[9];
int ss;
void wugecu()
{
	// for(int q=1;q<=ss;q++)
	// puts("SDSADASD");
	while(1)
	{
		for(int i=1;i<=ss;i++)
			for(int j=1;j<=ss;j++)
				if(j!=i)
				{
					if(b[i].y-b[i].x==b[j].y-b[j].x)
					{
						// puts("yye");
						if(b[i].x<=b[j].x&&b[j].x<b[i].z)
						
						{
							b[i].z=std::max(b[i].z,b[j].z);
							b[i].w=std::max(b[i].w,b[j].w);
							if(j!=ss)std::swap(b[j],b[ss]);
							ss--;
							goto cu;
						}
					}
				}
		break;
		cu:;
	}
}
signed main()
{
	// freopen("color.in","r",stdin);
	// freopen("color.out","w",stdout);
	int ID=read();
	int n=read(),m=read(),q=read();cx=0,cy=0;
	for(int i=1;i<=q;i++)
	{
		int tp=read(),x=read(),y=read(),z=read(),w=read();
		if(x>z)std::swap(x,z);
		if(y>w)std::swap(y,w);
		z++,w++;
		a[i]={x,y,z,w,tp};
		if(tp==3)
		{
			// printf("%d %d %d\n",y-x,x,z);
			b[++ss]={x,y,z,w,tp};
			continue;
		}
		lx[++cx]=x;lx[++cx]=z;ly[++cy]=y;ly[++cy]=w;
	}
	wugecu();
	lx[++cx]=1,lx[++cx]=n+1;ly[++cy]=1,ly[++cy]=m+1;
	std::sort(lx+1,lx+1+cx);cx=std::unique(lx+1,lx+1+cx)-lx-1;
	std::sort(ly+1,ly+1+cy);cy=std::unique(ly+1,ly+1+cy)-ly-1;
	for(int i=1;i<=q;i++)
	{
		if(a[i].tp==3)continue;
		FX(a[i].x);FX(a[i].z);
		FY(a[i].y),FY(a[i].w);
		if(a[i].tp==1)
		{
			s[a[i].x][0].push_back({a[i].y,a[i].w-1});
			s[a[i].z][1].push_back({a[i].y,a[i].w-1});
		}
		else if(a[i].tp==2)
		{
			s[a[i].x][0].push_back({a[i].y,a[i].w-1});
			s[a[i].z][1].push_back({a[i].y,a[i].w-1});
		}
	}
	build(1,1,cy-1);
	int ans=0;
	for(int i=1;i<=cx;i++)
	{
		// printf("%d ",lx[i]);
		ans+=(m-Q())*(lx[i]-lx[i-1]);
		for(qwq t:s[i][0])add(t.l,t.r,1);
		for(qwq t:s[i][1])add(t.l,t.r,-1);
	}
	for(int i=1;i<=q;i++)if(a[i].tp!=3)
		a[i].x=lx[a[i].x],
		a[i].z=lx[a[i].z],
		a[i].y=ly[a[i].y],
		a[i].w=ly[a[i].w];
	for(int i=1;i<=ss;i++)a[q+i]=b[i];
	for(int i=q+1;i<=q+ss;i++)
	{
		int cc=0;
		for(int j=1;j<=q;j++)
		{
			if(a[j].tp==1)
			{
				int fx=a[j].y-a[i].y+a[i].x;
				if(a[i].y<=a[j].y&&a[j].y<a[i].w&&a[j].x<=fx&&fx<a[j].z)
					tmp[++cc]=fx-a[i].x;
			}
			else if(a[j].tp==2)
			{
				int fy=a[j].x-a[i].x+a[i].y;
				if(a[i].x<=a[j].x&&a[j].x<a[i].z&&a[j].y<=fy&&fy<a[j].w)
					tmp[++cc]=fy-a[i].y;
			}
			else
			{
				// 
			}
		}
		std::sort(tmp+1,tmp+cc+1);
		cc=std::unique(tmp+1,tmp+cc+1)-tmp-1;
		ans+=(a[i].z-a[i].x-cc);
	}
	odl(ans);
}	
```

---

## 作者：StarLbright40 (赞：3)

这个题要我们求至少被染色一次的格子数量，看上去就很像容斥啊。

但是我们肯定没法直接对着 $q$ 次操作搞容斥。

发现题面已经帮你把操作分类好了，沿行沿列和沿主对角线方向三类。每类分别考虑，以按行的情况为例。

显然不同行之间的操作是互不干扰的，不可能有交，不需要考虑容斥。而同一行之内即相当于区间求并，这是经典问题，我用 [P2161](/problem/P2161) 最高赞题解的技巧实现。列的情况同理。

```cpp

struct seg{
	int l,r;
	bool operator <(const seg &b)const{
		return r<b.l;
	}
	seg operator +(const seg &b)const{
		return {min(l,b.l),max(r,b.r)};
	}
};
set<seg> px[Q*2],py[Q*2];
void ins(set<seg> &s,seg p){
	for(;;){
		auto it=s.find(p);
		if(it==s.end()) break;
		p=p+*it;
		s.erase(it);
	}
	s.insert(p);
}
```
主对角线的情况略有不同，因为最多只有 $5$ 个，所以两两枚举判断能否合并即可。这里用 $k$ 表示主对角线的操作数量。

```cpp
	sort(b+1,b+k+1,[](const node &a,const node &b){
		return make_pair(a.sy-a.sx,a.sx)<make_pair(b.sy-b.sx,b.sx);});
	for(int i=k-1;i>0;--i) if(b[i].sy-b[i].sx==b[i+1].sy-b[i+1].sx
		&&b[i].tx>=b[i+1].sx){
			b[i].tx=max(b[i].tx,b[i+1].tx);
			b[i].ty=max(b[i].ty,b[i+1].ty);
			for(int j=i+1;j<k;++j) b[j]=b[k];
			--k;
		}
```

如此处理后，三类中每类内部就不会产生交。于是这三类即可视为一个经典的三维韦恩图，答案即为：

1. 被行操作覆盖的格数 $\text{+}$ 被列操作覆盖的格数 $\text{+}$ 被主对角线操作覆盖的格数

2. $\text{-}$ 同时被行操作和列操作覆盖的格数

3. $\text{-}$ 同时被行操作和主对角线操作覆盖的格数

4. $\text{-}$ 同时被列操作和主对角线操作覆盖的格数

5. $\text{+}$ 同时被三类操作覆盖的格数

项 $1$ 是容易的。项 $2$ 是经典的扫描线问题，一维离线一维树状数组即可解决。

由于题目限制，项 $3$ 和项 $4$ 可以对于每个操作，暴力枚举每个主对角线操作是否与其有交，显然若有交则交点格的数量最多为 $1$。

对于项 $5$，考虑它一定同时属于项 $3$ 和项 $4$。于是可以在项 $3$ 中枚举到交点时将其存入一个 $\text{set}$，在项 $4$ 中枚举到交点时检查其是否在 $\text{set}$ 中出现过即可。

然后做完了，显而易见细节一堆。今年查分时电脑不给插 U 盘了，很不牛。所以放的是凭记忆复现的考场代码。把 $k$ 视为常数的话，时间复杂度 $\mathcal O(q\log q)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Q=1e5+5;
int n,m,q,k,bokx[Q*2],boky[Q*2];long long ans;
struct node{
	int sx,sy,tx,ty;
}a[Q],b[7];
struct BIT{
	int n,c[Q*2];
	void init(){n=*::bokx;}
	void add(int x,int k){
		for(;x<=n;x+=x&-x) c[x]+=k;
	}
	int ask(int x){
		int tmp=0;
		for(;x;x-=x&-x) tmp+=c[x];
		return tmp;
	}
}bit;
struct seg{
	int l,r;
	bool operator <(const seg &b)const{
		return r<b.l;
	}
	seg operator +(const seg &b)const{
		return {min(l,b.l),max(r,b.r)};
	}
};
set<seg> px[Q*2],py[Q*2];
set<pair<int,int>> pnt;
vector<pair<int,int>> e[Q*2];
void ins(set<seg> &s,seg p){
	for(;;){
		auto it=s.find(p);
		if(it==s.end()) break;
		p=p+*it;
		s.erase(it);
	}
	s.insert(p);
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>k>>n>>m>>q;k=0;
	for(int i=1,op,sx,sy,tx,ty;i<=q;++i){
		cin>>op>>sx>>sy>>tx>>ty;
		if(sx>tx) swap(sx,tx);
		if(sy>ty) swap(sy,ty);
		bokx[++*bokx]=sx,boky[++*boky]=sy;
		bokx[++*bokx]=tx,boky[++*boky]=ty;
		if(sx<tx&&sy<ty){
			b[++k]={sx,sy,tx,ty};
			--i,--q;
		}
		else a[i]={sx,sy,tx,ty};
	}
	sort(bokx+1,bokx+*bokx+1);
	*bokx=unique(bokx+1,bokx+*bokx+1)-bokx-1;
	sort(boky+1,boky+*boky+1);
	*boky=unique(boky+1,boky+*boky+1)-boky-1;
	for(int i=1;i<=q;++i){
		a[i].sx=lower_bound(bokx+1,bokx+*bokx+1,a[i].sx)-bokx;
		a[i].sy=lower_bound(boky+1,boky+*boky+1,a[i].sy)-boky;
		a[i].tx=lower_bound(bokx+1,bokx+*bokx+1,a[i].tx)-bokx;
		a[i].ty=lower_bound(boky+1,boky+*boky+1,a[i].ty)-boky;
	}
	sort(b+1,b+k+1,[](const node &a,const node &b){
		return make_pair(a.sy-a.sx,a.sx)<make_pair(b.sy-b.sx,b.sx);});
	for(int i=k-1;i>0;--i) if(b[i].sy-b[i].sx==b[i+1].sy-b[i+1].sx
		&&b[i].tx>=b[i+1].sx){
			b[i].tx=max(b[i].tx,b[i+1].tx);
			b[i].ty=max(b[i].ty,b[i+1].ty);
			for(int j=i+1;j<k;++j) b[j]=b[j+1];
			--k;
		}
	for(int i=1;i<=k;++i) ans+=b[i].tx-b[i].sx+1;
	for(int i=1;i<=q;++i)
		if(a[i].sx==a[i].tx) ins(px[a[i].sx],{a[i].sy,a[i].ty});
		else ins(py[a[i].sy],{a[i].sx,a[i].tx});
	bit.init();
	for(int i=1;i<=*bokx;++i)
		for(auto x:px[i]){
			ans+=boky[x.r]-boky[x.l]+1;
			e[x.l].push_back({i,1}),e[x.r+1].push_back({i,-1});
			for(int j=1;j<=k;++j) if(b[j].sx<=bokx[i]&&b[j].tx>=bokx[i]
				&&boky[x.l]-bokx[i]<=b[j].sy-b[j].sx
				&&boky[x.r]-bokx[i]>=b[j].sy-b[j].sx){
					--ans;
					pnt.insert({bokx[i],bokx[i]+b[j].sy-b[j].sx});
				}
		}
	for(int i=1;i<=*boky;++i){
		for(auto x:e[i]) bit.add(x.first,x.second);
		for(auto x:py[i]){
			ans+=bokx[x.r]-bokx[x.l]+1;
			ans-=bit.ask(x.r)-bit.ask(x.l-1);
			for(int j=1;j<=k;++j) if(b[j].sy<=boky[i]&&b[j].ty>=boky[i]
				&&boky[i]-bokx[x.l]>=b[j].sy-b[j].sx
				&&boky[i]-bokx[x.r]<=b[j].sy-b[j].sx){
					--ans;
					if(pnt.find({boky[i]-b[j].sy+b[j].sx,boky[i]})
						!=pnt.end()) ++ans;
				}
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Mobius127 (赞：3)

[题传](https://www.luogu.com.cn/problem/P9478)

应该刷新了 D1T1 的难度下限。

首先双指针将同类的有交集的线段合并，然后先考虑斜线段独立覆盖的部分，由于 $cnt_{slash}\le 5$，因此我们可以直接枚举其它线段，找到交点后用 map 直接去重即可得到斜线独立覆盖的点数。

考虑横线与竖线，一个简单的办法是容斥，将横线与竖线的交点计算出来。

考虑对 $y$ 进行扫描线，设当前扫到了 $p$，对于一条上端点为 $y$ 的竖线，在 $x$ 处 +1，对于在 $y=p$ 的横线，查询 $[x1, x2]$ 的和就可以统计交点了。单点加，区间查询，离散化后树状数组即可做到时间 $O(n\log n)$。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <vector>
#include <queue>
#include <map>
#include <bitset>
#define vi vector<int>
#define pb push_back
#define mp make_pair
#define st first
#define nd second
using namespace std;
typedef long long ll;
typedef pair <int, int> Pii;
const int INF=0x3f3f3f3f;
const int cp=998244353;
inline int mod(int x){if(x>=cp) x-=cp;if(x<0) x+=cp;return x;}
inline void plust(int &x, int y){x=mod(x+y);return ;}
inline void minut(int &x, int y){x=mod(x-y);return ;}
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int ksm(int a, int b=cp-2){
	int ret=1;
	for(; b; b>>=1, a=1ll*a*a%cp)
		if(b&1) ret=1ll*ret*a%cp;
	return ret;
}
const int N=1e5+5;
int n, m, q;
struct line{int l, r, x, y;void print(){printf("[%d %d] [%d %d]\n", l, r, x, y);}};
vector <line> tmp[3], row, col, sla;
bool rowcmp(line a, line b){return a.r==b.r?(a.l==b.l?a.x>b.x:a.l<b.l):a.y<b.y;}
bool colcmp(line a, line b){return a.l==b.l?(a.r==b.r?a.y>b.y:a.r<b.r):a.x<b.x;}
bool slacmp(line a, line b){return (a.r-a.l)==(b.r-b.l)?(a.l==b.l?a.y>b.y:a.r<b.r):(a.r-a.l)<(b.r-b.l);}
inline bool inr(int x, int l, int r){return l<=x&&x<=r;}
map <Pii, bool> Mp;
int top, posr[N<<1], posl[N], plt;
vi cad[N<<1], cdl[N<<1], rw[N<<1];
#define lbd(a, len, x) (lower_bound(a+1, a+(len)+1, (x))-a)
#define ubd(a, len, x) (upper_bound(a+1, a+(len)+1, (x))-a)
#define lowbit(x) (x&(-x))
int bit[N];
void add(int x, int v){for(; x<=plt; x+=lowbit(x)) bit[x]+=v;}
int qry(int x, int t=0){for(; x; x-=lowbit(x)) t+=bit[x];return t;}
int query(int l, int r){return qry(r)-qry(l-1);}
void calc(){
	ll ans=0;
	for(auto L:sla){
		int res=(L.x-L.l+L.y-L.r+2)>>1;
		for(auto R:row) if(inr(R.y, L.r, L.y)&&inr(L.l+R.y-L.r, R.l, R.x)) Mp[{L.l+R.y-L.r, R.y}]=1;
		for(auto C:col) if(inr(C.x, L.l, L.x)&&inr(L.r+C.x-L.l, C.r, C.y)) Mp[{C.x, L.r+C.x-L.l}]=1;
		ans+=res-Mp.size();Mp.clear();
	}
	// printf("%lld\n", ans);
	for(auto R:row) posr[++top]=R.r, ans+=R.x-R.l+1;
	for(auto C:col) posr[++top]=C.r, posr[++top]=C.y, ans+=C.y-C.r+1, posl[++plt]=C.l;
	sort(posr+1, posr+top+1);top=unique(posr+1, posr+top+1)-posr-1;
	sort(posl+1, posl+plt+1);plt=unique(posl+1, posl+plt+1)-posl-1;
	for(int i=0, p; i<row.size(); ++i) 
		p=lbd(posr, top, row[i].r), rw[p].pb(i);
	for(int i=0, p; i<col.size(); ++i) 
		p=lbd(posr, top, col[i].r), cad[p].pb(i), 
		p=lbd(posr, top, col[i].y), cdl[p].pb(i); 
	// for(int i=1; i<=plt; ++i) printf("%d ", posl[i]);puts("");
	for(int i=1; i<=top; ++i){
		int p, q;for(auto v:cad[i]) p=lbd(posl, plt, col[v].x), add(p, 1);
		for(auto v:rw[i]){
			p=lbd(posl, plt, row[v].l), q=ubd(posl, plt, row[v].x)-1;
			if(p<=q) ans-=query(p, q);// printf("del %d[%d %d]\n", query(p, q), p, q);
		}
		for(auto v:cdl[i]) p=lbd(posl, plt, col[v].x), add(p, -1);
	}
	printf("%lld\n", ans);
}
signed main(){
	int c=read();
	n=read(), m=read(), q=read();
	for(int i=1, t; i<=q; ++i)
		t=read()-1, tmp[t].pb((line){read(), read(), read(), read()});
	sort(tmp[0].begin(), tmp[0].end(), rowcmp);
	for(int i=0, j, r, y; i<tmp[0].size(); i=j+1){
		j=i, r=tmp[0][i].x, y=tmp[0][i].y;
		while(j+1<tmp[0].size()&&tmp[0][j+1].y==y&&r>=tmp[0][j+1].l) r=max(r, tmp[0][++j].x);
		tmp[0][i].x=r;row.pb(tmp[0][i]);
		// printf("a row");tmp[0][i].print();
	}
	sort(tmp[1].begin(), tmp[1].end(), colcmp);
	for(int i=0, j, r, x; i<tmp[1].size(); i=j+1){
		j=i, r=tmp[1][i].y, x=tmp[1][i].x;
		while(j+1<tmp[1].size()&&tmp[1][j+1].x==x&&r>=tmp[1][j+1].r) r=max(r, tmp[1][++j].y);
		tmp[1][i].y=r;col.pb(tmp[1][i]);
		// printf("a col");tmp[1][i].print();
	}
	sort(tmp[2].begin(), tmp[2].end(), slacmp);
	for(int i=0, j, rx, ry, p; i<tmp[2].size(); i=j+1){
		j=i, rx=tmp[2][i].x, ry=tmp[2][i].y, p=tmp[2][i].r-tmp[2][i].l;
		while(j+1<tmp[2].size()&&tmp[2][j+1].r-tmp[2][j+1].l==p&&rx>=tmp[2][j+1].l&&ry>=tmp[2][j+1].r)
			++j, rx=max(rx, tmp[2][j].x), ry=max(ry, tmp[2][j].y);
		tmp[2][i].x=rx, tmp[2][i].y=ry;sla.pb(tmp[2][i]);
		// printf("a sla");tmp[2][i].print();
	}
	calc();
	return 0;
}
```

---

## 作者：_yjh (赞：3)

最 trash 的 NOI Day1T1 之一。

既然线段会有交，那么无非分为两种情况，同类型交或不同类型交。对于同类型交不妨直接离线下来，合并一下即可。

假设只有横竖线是简单的，离散化并经过合并处理后一个交点最多只会被一横一竖经过，使用类似矩形面积并的处理方式算一下就好了（甚至只有单点修改，严格弱于矩形面积并）。

加上斜线依然简单，斜线个数太少，将斜线合并之后对每一条斜线算一下其与所有横竖线交点个数，去重后计数即可。

代码很好写就不放了。

---

## 作者：Arghariza (赞：2)

upd 2023/10/17 : 被人叉了，改了一下。/kk

[更优质的阅读体验。](https://www.cnblogs.com/Ender32k/p/17589928.html)

大概就是容斥一下，令：

- 至少被 $1$ 种操作覆盖的格子数为 $S_1$（允许算重，即一个格子对 $S_1$ 的贡献是它被覆盖的次数，下同）。
- 至少被 $2$ 种操作覆盖的格子数为 $S_2$。
- 至少被 $3$ 种操作覆盖的格子数为 $S_3$。

答案显然就是 $S_1-S_2+S_3$。

$S_1$ 是好求的，考虑 $S_2$ 和 $S_3$。

对于 $S_2$，分类讨论格子被哪两种操作覆盖。令 $H$ 为覆盖行操作，$L$ 为覆盖列操作，$X$ 为覆盖斜线操作，只需枚举 $(A,B)$ 的无序操作二元组：

1. $(H/L,X)$：由于 $X$ 操作不超过 $5$ 次，直接对于每次 $X$ 操作枚举所有的 $H,L$ 操作，然后判断是否有交点即可。判断交点需要满足 $2$ 个条件，斜线的两个端点在水平/竖直线的两侧，以及解出来的交点在水平/竖直线的覆盖范围内。
2. $(H,L)$：即求所有行操作和列操作的交点个数，直接扫描线即可。

对于 $S_3$，类似 $S_2(H/L,X)$ 的做法，枚举 $X$ 操作，枚举 $L$ 操作，算出 $X,L$ 两个操作的交点，我们求出有多少个 $H$ 操作经过这个交点即可。也可以用扫描线解决。

复杂度 $O(q\log q)$。

注意第三种操作排序要双关键字。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    #if ONLINE_JUDGE
    #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    #else
    #define gh() getchar()
    #endif
    #define mt make_tuple
    #define mp make_pair
    #define fi first
    #define se second
    #define pc putchar
    #define pb emplace_back
    #define ins insert
    #define era erase
    typedef tuple<int, int, int> tu3;
    typedef pair<int, int> pi;
    inline int rd() {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void wr(ll x) {
        if (x < 0) x = ~(x - 1), pc('-');
        if (x > 9) wr(x / 10);
        pc(x % 10 + '0');
    }
}
using namespace vbzIO;

const int Q = 1e5 + 100;

int n, m, tq;
ll ans;
vector<tu3> q[3], t;
set<tu3> st;
map<int, int> ctx, cty;

#define gt(x, y) (get<x>(y))

void dl(int op) {
    t.clear();
    for (int i = 0; i < q[op].size(); i++) {
        int r = i;
        if (op <= 1) while (r < q[op].size() - 1 && gt(0, q[op][r + 1]) == gt(0, q[op][i])) r++;
        else while (r < q[op].size() - 1 && gt(0, q[op][r + 1]) - gt(1, q[op][r + 1]) == gt(0, q[op][i]) - gt(1, q[op][i])) r++;
        st.clear();
        for (int j = i; j <= r; j++) {
            auto [y, xl, xr] = q[op][j];
            xr = xl + xr - 1;
            if (st.empty()) st.ins(mt(xr, xl, y));
            else if (gt(0, *st.rbegin()) >= xl) {
                auto [tr, tl, tt] = *st.rbegin();
                st.era(mt(tr, tl, tt)), st.ins(mt(max(xr, tr), min(tl, xl), min(tt, y)));
            } else st.ins(mt(xr, xl, y));
        }
        for (auto [tr, tl, tt] : st) t.pb(mt(tt, tl, tr - tl + 1));
        i = r;
    }
    q[op] = t;
}

struct BIT {
    int tr[Q * 3], n;
    BIT () { }
    BIT (int len) { memset(tr, 0, sizeof(int) * (len + 10)), n = len; }
    int lb(int x) { return x & (-x); }
    void upd(int x, int y) { for (int i = x; i <= n; i += lb(i)) tr[i] += y; }
    int qry(int x) { int res = 0; for (int i = x; i; i -= lb(i)) res += tr[i]; return res; }
    int qlr(int l, int r) { return qry(r) - qry(l - 1); }
};

int Sub1() {// x, h, l
    static int tp[Q << 1], ts[Q];
    int res = 0, len = 0, k = 0;
    vector<pi> qr;
    vector<tu3> op;
    for (auto [x, y, le] : q[2]) 
        for (auto [ty, xl, xr] : q[0]) 
            if (1ll * (y - ty) * (y + le - 1 - ty) <= 0 && xl <= x + ty - y && x + ty - y <= xl + xr - 1) 
                qr.pb(mp(ty, x + ty - y)), tp[++len] = x + ty - y;
    for (auto [x, l, r] : q[1]) op.pb(mt(l, x, 1)), op.pb(mt(l + r, x, -1)), tp[++len] = x;
    sort(qr.begin(), qr.end()), sort(op.begin(), op.end());
    sort(tp + 1, tp + len + 1), len = unique(tp + 1, tp + len + 1) - tp - 1;
    for (auto &[x, y] : qr) y = lower_bound(tp + 1, tp + len + 1, y) - tp;
    for (auto &[x, y, z] : op) y = lower_bound(tp + 1, tp + len + 1, y) - tp;
    memset(ts, 0, sizeof(int) * (len + 10));
    for (auto [x, y] : qr) {
        while (k < op.size() && gt(0, op[k]) <= x) ts[gt(1, op[k])] += gt(2, op[k]), k++;
        res += ts[y];
    }
    return res;
}

int Sub2() {// x, l
    int res = 0;
    for (auto [x, y, len] : q[2]) 
        for (auto [ty, xl, xr] : q[0]) 
            if (1ll * (y - ty) * (y + len - 1 - ty) <= 0 && xl <= x + ty - y && x + ty - y <= xl + xr - 1) res++;
    return res;
}

int Sub3() {// x, h
    int res = 0;
    for (auto [x, y, len] : q[2]) 
        for (auto [tx, yl, yr] : q[1]) 
            if (1ll * (x - tx) * (x + len - 1 - tx) <= 0 && yl <= y + tx - x && y + tx - x <= yl + yr - 1) res++;
    return res;
}

ll Sub4() {// h, l
    static int tp[Q * 3];
    ll res = 0, len = 0, k = 0;
    vector<tu3> qr, op;
    for (auto [ty, xl, xr] : q[0]) qr.pb(mt(ty, xl, xl + xr - 1)), tp[++len] = xl, tp[++len] = xl + xr - 1;
    for (auto [tx, yl, yr] : q[1]) op.pb(mt(yl, tx, 1)), op.pb(mt(yl + yr, tx, -1)), tp[++len] = tx;
    sort(qr.begin(), qr.end()), sort(op.begin(), op.end());
    sort(tp + 1, tp + len + 1), len = unique(tp + 1, tp + len + 1) - tp - 1;
    for (auto &[x, y, z] : qr) y = lower_bound(tp + 1, tp + len + 1, y) - tp, z = lower_bound(tp + 1, tp + len + 1, z) - tp;
    for (auto &[x, y, z] : op) y = lower_bound(tp + 1, tp + len + 1, y) - tp;
    BIT B = BIT(len);
    for (auto [x, y, z] : qr) {
        while (k < op.size() && gt(0, op[k]) <= x) B.upd(gt(1, op[k]), gt(2, op[k])), k++;
        res += B.qlr(y, z);
    }
    return res;
}

signed main() {
    rd(), n = rd(), m = rd(), tq = rd();
    while (tq--) {
        int op = rd(), xa = rd(), ya = rd(), xb = rd(), yb = rd();
        if (op == 1) {
            if (xa > xb) swap(xa, xb), swap(ya, yb);
            q[0].pb(mt(ya, xa, xb - xa + 1));
        } else if (op == 2) {
            if (ya > yb) swap(xa, xb), swap(ya, yb);
            q[1].pb(mt(xa, ya, yb - ya + 1));
        } else {
            if (xa > xb) swap(xa, xb), swap(ya, yb);
            q[2].pb(mt(xa, ya, xb - xa + 1));
        }
    }
    for (int i = 0; i <= 1; i++) sort(q[i].begin(), q[i].end()), dl(i);
    sort(q[2].begin(), q[2].end(), [](tu3 &x, tu3 &y) { 
        return gt(0, x) - gt(1, x) == gt(0, y) - gt(1, y) ? gt(0, x) < gt(0, y) : 
        gt(0, x) - gt(1, x) < gt(0, y) - gt(1, y); 
    }), dl(2);
    for (int i = 0; i <= 2; i++)
        for (auto [x, l, r] : q[i]) ans += r;
    ans = ans - Sub2() - Sub3() + Sub1() - Sub4();
    wr(ans);
    return 0;
}


```

---

## 作者：D2T1 (赞：2)

我会 cdq！

考虑总面积减掉重合面积。

发现斜线操作次数很少啊，就可以把它拆成一行一行，最后一个点可以判一判不全部转成行。然后就只剩行列了。

考虑把行看做操作，列看做查询，时间维是每个操作或查询最左边的列坐标，问题变为支持插入删除平面内点（行操作右端点），查询行坐标在一个区间内点数。这个区间可以差分一下就变成了二维数点。

整个做法相当于三维偏序。

---

## 作者：船酱魔王 (赞：2)

# P9478 [NOI2023] 方格染色 题解

## 题意回顾

$ n $ 列 $ m $ 行的矩阵，初始全是空白的。$ q $ 次染色，每次染色可以染一条横线段的格子、一条竖线段的格子或一条斜率为 $ 1 $ 的斜线的格子。求染色后被染黑的格子数量。

$ 1 \le n,m \le 10^9 $，$ 1 \le q \le 10^5 $，斜线染色操作最多 $ 5 $ 次。

## 分析

我们先只考虑横线和竖线染色，显然不能暴力。

我们考虑有一条垂直于 $ x $ 轴的直线从 $ x=0 $ 的位置向 $ x $ 轴正方向行进，这条线在每时每刻黑格子总数显然就是答案。对于每次横线染色，我们的线显然会在横线起点时在一个位置上会被横线染色，在横线结束后的同一个位置上横线染色结束。因此我们只需要单点修改。

对于竖线染色，显然都会同时被直线扫描到。我们先把竖线上都染一遍，答案增加竖线长度，再减去重复染色的即竖线范围内已经染的，我们需要区间求和。

单点修改区间求和可以用树状数组和线段树解决，本题解的代码实现是树状数组。

注意处理横线染色间相交和竖线染色间相交的情况，横线相交可以维护一个普通数组考虑值染色总数是由一次变零次还是由零次变一次，竖线相交可以将所有事件排序后对于类型相同且范围相交的事件合并。

考虑斜线，看起来很难处理，但是注意题目条件：斜线染色最多 $ 5 $ 次。因此对于每次斜线染色都可以遍历一遍之前的所有染色，找到斜线和所有非斜线染色的交点，放进 ```set``` 去重即可。

斜线相交的处理方式类似于竖线相交。我们找交点使用直线找交点的方式，因此交点可能在线段外，因此要判断交点是否在线段上。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#include <set>
using namespace std;
const int N = 1e5 + 5;
int qwq;
int n, m, q;

int yxj[3] = {1, 3, 2};
struct things {
	int tim;
	int pos1, pos2;//L, R
	int typ;//-1 - del, 1 - plus, 0 - query
} a[N * 2], b[6];
bool operator<(things p1, things p2) {
	if(p1.tim != p2.tim) {
		return p1.tim < p2.tim;
	}
	if(p1.typ == 0 && p2.typ == 0) {
		if(p1.pos1 != p2.pos1) {
			return p1.pos1 < p2.pos1;
		}
		return p1.pos2 < p2.pos2;
	}
	return yxj[p1.typ + 1] < yxj[p2.typ + 1];
}
things make(int t0, int p0, int p1, int t1) {
	things res;
	res.tim = t0;
	res.pos1 = p0;
	res.pos2 = p1;
	res.typ = t1;
	return res;
}
int ca = 0;
int cb = 0;
int tp[N * 2];
int ct = 0;
map<int, int> mp;

int c[N * 2];
int lowbit(int x) {
	return x & (-x);
}
void update(int x, int v) {
	for(int i = x; i <= ct; i += lowbit(i)) {
		c[i] += v;
	}
}
int query(int x) {
	int res = 0;
	for(int i = x; i >= 1; i -= lowbit(i)) {
		res += c[i];
	}
	return res;
}

int d[N * 2];

bool cmp(things x, things y) {
	if(x.tim != y.tim) {
		return x.tim < y.tim;
	} 
	if(x.pos1 != y.pos1) {
		return x.pos1 < y.pos1;
	}
	return x.pos2 < y.pos2;
}

struct Point {
	int x, y;
};
Point makep(int x0, int y6) {
	Point res;
	res.x = x0;
	res.y = y6;
	return res;
}
set<Point> se;
bool operator<(Point p1, Point p2) {
	if(p1.x != p2.x) {
		return p1.x < p2.x;
	}
	return p1.y < p2.y;
}

int t[N];
int x4[N];
int y4[N];
int x5[N];
int y5[N];

int main() {
	scanf("%d", &qwq);
	scanf("%d%d%d", &n, &m, &q);
	int op, x2, y2, x3, y3;
	long long ans = 0;
	for(int i = 1; i <= q; i++) {
		scanf("%d%d%d%d%d", &op, &x2, &y2, &x3, &y3);
		t[i] = op, x4[i] = x2, y4[i] = y2, x5[i] = x3, y5[i] = y3;
		if(op == 1) {
			a[++ca] = make(x2, y2, 0, 1);
			a[++ca] = make(x3 + 1, y2, 0, -1);
			tp[++ct] = y2;
		} else if(op == 2) {
			a[++ca] = make(x2, y2, y3, 0); 
			tp[++ct] = y2 - 1;
			tp[++ct] = y3;
		} else {
			b[++cb] = make(y2 - x2, x2, x3, 2);
		}
	}
	sort(tp + 1, tp + ct + 1);
	for(int i = 1; i <= ct; i++) {
		mp[tp[i]] = i;
	}
	sort(a + 1, a + ca + 1);
	int ca1 = ca;
	ca = 0;
	a[ca].typ = -114514;
	for(int i = 1; i <= ca1; i++) {
		if(a[i].typ == 0 && a[ca].typ == 0) {
			if(a[i].tim == a[ca].tim && a[i].pos1 <= a[ca].pos2) {
				a[ca].pos2 = max(a[ca].pos2, a[i].pos2);
				continue;
			}
		}
		ca++;
		a[ca] = a[i];
	}
	int lst = 0;
	for(int i = 1; i <= ca; i++) {
		ans += (long long)(a[i].tim - lst) * query(ct);
		lst = a[i].tim;
		if(a[i].typ != 0) {
			a[i].pos1 = mp[a[i].pos1];
			d[a[i].pos1] += a[i].typ;
			if(d[a[i].pos1] == 0 && a[i].typ == -1) {
				update(a[i].pos1, -1);
			}
			if(d[a[i].pos1] == 1 && a[i].typ == 1) {
				update(a[i].pos1, 1);
			}
		} else {
			ans += a[i].pos2 - a[i].pos1 + 1 - (query(mp[a[i].pos2]) - query(mp[a[i].pos1 - 1]));
		}
	}
	sort(b + 1, b + cb + 1, cmp);
	int cb1 = cb;
	cb = 0;
	b[0].tim = -1e9 - 5;
	for(int i = 1; i <= cb1; i++) {
		if(b[i].tim == b[cb].tim) {
			if(b[i].pos1 <= b[cb].pos2) {
				b[cb].pos2 = max(b[cb].pos2, b[i].pos2);
				continue;
			}
		}
		cb++;
		b[cb] = b[i];
	}
	for(int bi = 1; bi <= cb; bi++) {
		se.clear();
		for(int i = 1; i <= q; i++) {
			if(t[i] == 1) {
				if(y4[i] - x4[i] >= b[bi].tim && y5[i] - x5[i] <= b[bi].tim && b[bi].pos1 + b[bi].tim <= y4[i] && b[bi].pos2 + b[bi].tim >= y5[i]) {
					se.insert(makep(y4[i] - b[bi].tim, y4[i]));
				}
			} else if(t[i] == 2) {
				if(y4[i] - x4[i] <= b[bi].tim && y5[i] - x5[i] >= b[bi].tim && b[bi].pos1 <= x4[i] && b[bi].pos2 >= x5[i]) {
					se.insert(makep(x4[i], x4[i] + b[bi].tim));
				}
			}
		}
		ans += b[bi].pos2 - b[bi].pos1 + 1 - se.size();
	}
	printf("%lld\n", ans);
	return 0;
}
```

## 总结与评价

基础扫描线+容斥思想练习题，放在 NOI D1T1 较简单。

---

## 作者：听取MLE声一片 (赞：1)

前 $95$ 分是【模板】矩形面积并。

来想想正解。

首先把横线、竖线、斜线分别有交的都合并在一起。

横线竖线的面积是容易求的，离散化然后维护一下就行。可以用扫描线，也可以直接树状数组维护。

因为斜线的个数很少，所以可以求斜线和横线竖线有多少个交点，然后把斜线总面积减交点个数就是斜线的面积。

时间复杂度 $O(q\log q)$。



---

## 作者：EXODUS (赞：0)

# Part 1：前言
很难想象 NOI 有朝一日会出现这么简单的题，但是细节还是有一些的。

# Part 2：正文

首先考虑没有斜线怎么做，那么是直接矩形面积并。

然后考虑加上斜线。斜线不太能直接和直线一起扫描线，因此我们考虑算出所有斜线的面积，然后再算出其与所有直线相交的面积，接下来我们将这两步分开考虑。

- 斜线面积。

  注意到斜线之间相交我们是可以暴力将其合并成一条斜线的，具体而言，每次拉出两条位于同一主对角线的斜线，判断其横坐标是否相交，前者可以用 $x$ 和 $y$ 的差值判断。

- 斜线直线相交面积。

  注意到斜线和直线只会有至多一个交点，因此可以考虑枚举每一条斜线和直线，然后计算其是否有交，并 ban 掉斜线上的交点。一个细节是可能有一个点被直线多次覆盖，那么用一个 map 记一下当前有那些点已经被 ban 掉即可。

一个减少细节的方法是扫描线的时候直接动态开点线段树，这样在扫描线修改后维护答案的时候能减少不小的代码量。	

# Part 3：代码

代码是 vp 的时候写的，可能有点混乱。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define ls(k) t[k].ls
#define rs(k) t[k].rs
#define rep(i,l,r) for(int i(l);i<=(r);++i)
#define per(i,r,l) for(int i(r);i>=(l);--i)
#define eb emplace_back
#define Debug(...) fprintf(stderr,__VA_ARGS__)
int read(){
	int ans=0,flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	return ans*flg;
}
template<typename T>
void read(T &x){
	x=0;T flg=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flg=-1;ch=getchar();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	x*=flg;
}
template<typename T,typename... Args>
void read(T &x,Args &...args){read(x),read(args...);}
const int N=4e5+7;
int R,L,n,tot,node,cnt,tp,rt;
ll x[N],ans;
struct ScanLine{
	ll l,r,h;int mark;
	bool operator<(const ScanLine &X)const{return h<X.h;}
}line[N<<1];
struct Line{
	int xl,xr,yl,yr;
	bool mark;
}lin[10];
struct Tree{int ls,rs,sum;ll len;}t[N<<5];
void chg(int l,int r,int k,int v){
	t[k].sum+=v;
	if(t[k].sum==0){
		t[k].len=t[ls(k)].len+t[rs(k)].len;
	}else{
		t[k].len=r-l+1;
	}
}
void update(int l,int r,int &k,int ql,int qr,int v){
	// cerr<<l<<" "<<r<<" "<<ql<<" "<<qr<<endl;
	if(!k)k=++node;
	if(ql<=l&&r<=qr)return chg(l,r,k,v);
	int mid=(l+r)>>1;
	if(ql<=mid)update(l,mid,ls(k),ql,qr,v);
	if(mid<qr)update(mid+1,r,rs(k),ql,qr,v);
	return chg(l,r,k,0);
}
int main(){
	read(tp,R,L,n);
	for(int i=1,xl,xr,yl,yr;i<=n;i++){
		read(tp,xl,yl,xr,yr);
		if(tp!=3){
			x[++tot]=xl;line[tot]=(ScanLine){xl,xr,yl,1};
			x[++tot]=xr;line[tot]=(ScanLine){xl,xr,yr,-1};
		}else{
			lin[++cnt]=(Line){xl,xr,yl,yr,true};
		}
	}
	// for(int i=1;i<=cnt;i++){
	// 	cout<<lin[i].xl<<"-"<<lin[i].yl<<"-"<<lin[i].xr<<"-"<<lin[i].yr<<endl;
	// }
	auto chk=[&](int l,int p,int r){return (l<=p)&(p<=r);};
	for(int flg=1;flg;flg=0){
		for(int i=1;i<=cnt;i++){
			if(!lin[i].mark)continue;
			for(int j=1;j<=cnt;j++){
				if(!lin[j].mark)continue;
				if(i==j)continue;
				if(lin[i].xl-lin[i].yl!=lin[j].xl-lin[j].yl)continue;
				if(chk(lin[j].xl,lin[i].xl,lin[j].xr)||chk(lin[j].xl,lin[i].xr,lin[j].xr)){
					flg=1;
					lin[i].xl=min(lin[i].xl,lin[j].xl);
					lin[i].xr=max(lin[i].xr,lin[j].xr);
					lin[i].yl=min(lin[i].yl,lin[j].yl);
					lin[i].yr=max(lin[i].yr,lin[j].yr);
					lin[j].mark=0;
				}
			}
		}
	}
	int tmp=0;
	for(int i=1;i<=cnt;i++){
		if(lin[i].mark)lin[++tmp]=lin[i],ans+=lin[i].xr-lin[i].xl+1;
	}
	cnt=tmp;
	// cerr<<cnt<<endl;
	for(int i=1;i<=cnt;i++){
		map<pair<int,int>,bool>pnt;
		// cout<<lin[i].xl<<"-"<<lin[i].yl<<"-"<<lin[i].xr<<"-"<<lin[i].yr<<endl;
		for(int j=1;j<=tot;j+=2){
			int xl=line[j].l,xr=line[j].r,yl=line[j].h,yr=line[j+1].h;
			if(xl==xr){
				if(chk(yl,xl-lin[i].xl+lin[i].yl,yr)&&chk(lin[i].xl,xl,lin[i].xr)){
					// cout<<xl<<" "<<yl<<" "<<xr<<" "<<yr<<endl;
					if(!pnt.count(make_pair(xl,xl-lin[i].xl+lin[i].yl))){
						// cout<<xl<<"+"<<xl-lin[i].xl+lin[i].yl<<endl;
						pnt[make_pair(xl,xl-lin[i].xl+lin[i].yl)]=1,ans--;
					}
				}
			}else if(yl==yr){
				if(chk(xl,yl+lin[i].xl-lin[i].yl,xr)&&chk(lin[i].yl,yl,lin[i].yr)){
					// cout<<xl<<" "<<yl<<" "<<xr<<" "<<yr<<endl;
					if(!pnt.count(make_pair(yl+lin[i].xl-lin[i].yl,yl))){
						// cout<<yl+lin[i].xl-lin[i].yl<<"+"<<yl<<endl;
						pnt[make_pair(yl+lin[i].xl-lin[i].yl,yl)]=1,ans--;
					}
				}
			}
		}
		// cout<<pnt.size()<<endl;
	}
	// cout<<ans<<endl;
	for(int i=1;i<=tot;i++){
		if(line[i].mark==-1)line[i].h++;
	}
	sort(line+1,line+tot+1);
	// for(int i=1;i<=tot;i++)cout<<line[i].l<<" "<<line[i].r<<" "<<line[i].h<<" "<<line[i].mark<<endl;
	// ans=0;
	for(int i=1;i<tot;i++){
		update(1,1e9,rt,line[i].l,line[i].r,line[i].mark);
		ans+=t[1].len*(line[i+1].h-line[i].h);
		// cout<<t[1].len<<endl;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：2018ljw (赞：0)

萌萌题。

首先合并有重叠的横、列、斜线操作，这样处理后同方向的操作两两不交。

考虑容斥，总的减去覆盖两次加上覆盖三次。

总的直接算长度和。

覆盖两次分为【横斜】、【纵斜】、【横纵】三类。

覆盖三次只能是【横纵斜】。

对于【横斜】、【纵斜】、【横纵斜】三类，我们发现交点只有 $O(kq)$ 个，$k$ 为斜线操作个数，因此直接暴力求出所有交点，出现两次的就是【横纵斜】的点。

对于【横纵】，我们可以将问题转化为如下：

有两类线段 $(x,ly,ry)$ 和 $(lx,rx,y)$，求有多少对一二类线段相交。

枚举一类线段，转化为有多少 $ly\le y\le ry$ 的二类线段满足 $lx\le x\le rx$。

做下减法，变为 $(x\le rx)-(x\lt lx)$。

发现这是个经典的二维偏序了。

两类线段按 $x$ 排序（第二类拆成 $rx$ 和 $lx-1$），单点加减区间求和，直接树状数组即可。

复杂度 $O(kq+q\log q)$。

---


# [NOIP2023] 天天爱打卡

## 题目描述

小 T 同学非常热衷于跑步。为了让跑步更加有趣，他决定制作一款叫做《天天爱打卡》的软件，使得用户每天都可以进行跑步打卡。

开发完成后，小 T 同学计划进行试运行，他找了大 Y 同学来帮忙。试运行共 $n$ 天，编号为从 $1$ 到 $n$。

对大 Y 同学来说，如果某天他选择跑步打卡，那么他的能量值会减少 $d$。初始时，他的能量值是 $0$，并且试运行期间他的**能量值可以是负数**。

而且大 Y 不会**连续**跑步打卡**超过** $k$ 天；即不能存在 $1\le x\le n-k$，使得他在第 $x$ 到第 $x+k$ 天均进行了跑步打卡。

小 T 同学在软件中设计了 $m$ 个挑战，第 $i$（$1\le i \le m$）个挑战可以用三个正整数 $(x_i,y_i,v_i)$ 描述，表示如果在第 $x_i$ 天时，用户已经连续跑步打卡至少 $y_i$ 天（即第 $x_i-y_i+1$ 到第 $x_i$ 天均完成了跑步打卡），那么小 T 同学就会请用户吃饭，从而使用户的能量值提高 $v_i$。

现在大 Y 想知道，在软件试运行的 $n$ 天结束后，他的能量值**最高**可以达到多少？

## 说明/提示

**【样例解释 #1】**

在第 $1,2$ 天跑步打卡，第 $3$ 天不跑步打卡，最终会获得 $(-1)+(-1)+4=2$ 的能量值。

**【样例解释 #2】**

该组样例满足测试点 $3$ 的条件。

**【样例解释 #3】**

该组样例满足测试点 $5$ 的条件。

**【样例解释 #4】**

该组样例满足测试点 $15$ 的条件。

**【样例解释 #5】**

该组样例满足测试点 $17$ 的条件。

**【样例解释 #6】**

该组样例满足测试点 $19$ 的条件。

**【数据范围】**

记 $l_i=x_i-y_i+1$，$r_i=x_i$​；

对于所有测试数据，保证：$1\le t\le 10$，$1\le k\le n\le 10^9$，$1\le m\le 10^5$，$1\le l_i\le r_i\le n$，$1\le d,v_i\le 10^9$。

|测试点编号|$n \le$|$m \le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1, 2$|$18$|$10 ^ 2$|无|
|$3, 4$|$10 ^ 2$|$10 ^ 2$|无|
|$5 \sim 7$|$10 ^ 3$|$10 ^ 3$|无|
|$8, 9$|$10 ^ 3$|$10 ^ 5$|无|
|$10, 11$|$10 ^ 5$|$10 ^ 3$|无|
|$12 \sim 14$|$10 ^ 5$|$10 ^ 5$|无|
|$15, 16$|$10 ^ 9$|$10 ^ 5$|A|
|$17, 18$|$10 ^ 9$|$10 ^ 5$|B|
|$19 \sim 21$|$10 ^ 9$|$10 ^ 5$|C|
|$22 \sim 25$|$10 ^ 9$|$10 ^ 5$|无|

特殊性质 A：$k\le 10^2$；

特殊性质 B：$\forall 1\le i<m$，$r_i<l_{i+1}$；

特殊性质 C：$\forall 1\le i<j\le m$，$l_i<l_j$，$r_i<r_j$。

## 样例 #1

### 输入

```
1 1
3 2 2 1
2 2 4
3 2 3
```

### 输出

```
2
```

# 题解

## 作者：未来姚班zyl (赞：325)

## 前言

本人在赛时可以说是按照出题人设计的部分分一步一步想到正解，思维过程应该算非常标准，且很多部分分的代码也在赛时打出来了。

所以这篇题解肯定能做到流畅，详细，具体。

## 题目大意

一共有 $n$ 天，大 Y 可以花费 $d$ 的能量在任何一天跑步，但大 Y 不能在连续的 $k$ 天跑步。

此外，将给出 $m$ 段任务区间 $[l_i,r_i]$。如果在这段区间的每一天都跑了步，则会获得 $v_i$ 的能量。

大 $Y$ 的初始能量为 $0$，请你最大化跑完步后大 Y 最终的能量。

## 题目分析

以下复杂度均省略了 $T$，即数据组数。

- 我会暴力枚举！

直接枚举每一天是否跑了步，然后计算贡献即可。

复杂度 $O(2^n(n+m))$，期望得分 $8$ 分。

这一部分没什么太大用处，代码也很好写，故不给出代码。

- 我会 dp ！

如果我们知道了在一段区间内都跑了步，我们则可以直接枚举 $m$ 个区间并计算出对答案的贡献。所以我们设计状态 $dp_{i}$，表示只考虑前 $i$ 天的最大答案。首先有转移 $dp_i=dp_{i-1}$。其次，我们考虑右端点为 $i$ 的区间。暴力枚举左端点 $j$（注意区间长度不能超过 $k$），则我们有转移：

$dp_i=\max(dp_i,dp_{j-2}-(i-j+1)d+w_{j,i})$。

其中 $w_{l,r}$ 表示任务区间对 $[l,r]$ 的贡献，可以 $O(m)$ 单次计算。加上 $O(n)$ 枚举左端点，可以做到 $O(nmk)$。

期望得分 $16$ 分。

这一部分代码如下：

```cpp
ll dp[N];
inline ll get(int l,int r){
	ll ans=0;
	rep(i,1,m)if(a[i].l>=l&&a[i].r<=r)ans+=a[i].k;
	return ans;
}//计算贡献
inline ll got(int x){
	//由于 j-2 可能越界，但并非无法转移，故我们额外写一个函数表示 dp 的值
	if(x>=0)return dp[x];
	return 0;
}
inline void subtask1(){
	rep(i,0,n)dp[i]=0;
	//初始化
	rep(i,1,n){
		rep(j,max(i-k+1,1),i)dp[i]=max(dp[i],get(j,i)+got(j-2)-1LL*d*(i-j+1));//状态转移
		dp[i]=max(dp[i],dp[i-1]);
	}
	cout <<dp[n]<<'\n';
}
```

- 我会扫描线和树状数组！

我们考虑优化计算贡献的方式。

可以想到，对于枚举的区间 $[j,i]$，能够贡献答案的任务区间 $[l_k,r_k]$ 一定满足 $j\le l_k\le r_k\le i$。

那么我们按照右端点顺序把任务区间加入，则 $r_k\le i$ 的条件就能天然满足。计算贡献时，我们就只需要查询满足 $l_k\ge j$ 的任务区间的权值和即可，这个可以用树状数组维护，单次计算贡献的复杂度降至 $O(\log m)$。

复杂度 $O(nk \log m)$，期望得分 $36$ 分。

这一部分代码如下：

```cpp
vector<Pi >p[N];//这个存的任务区间 
ll t[N];
inline void add(int x,int k){
	x=n-x+1;//这里直接倒着存，写的时候就不用差分了，下面一样的道理
	while(x<=n)t[x]+=k,x+=x&-x;
}
inline ll query(int x){
	ll ans=0;
	x=n-x+1;
	while(x)ans+=t[x],x-=x&-x;
   return ans;
}//树状数组
#define E(x) for(auto y:p[x])
inline void subtask2(){
	rep(i,1,m)p[a[i].r].pb({a[i].l,a[i].k});
	rep(i,0,n)dp[i]=0;//初始化
	rep(i,1,n){
		E(i)add(y.first,y.second);
		rep(j,max(i-k+1,1),i)dp[i]=max(dp[i],query(j)+got(j-2)-1LL*d*(i-j+1));
		dp[i]=max(dp[i],dp[i-1]);
	}
	rep(i,1,n)p[i].clear(),t[i]=0;//多测要清空哦！
	cout <<dp[n]<<'\n';
}
```

- 我会离散化！

当 $n$ 变得特别大，有用的端点也就只有 $O(m)$ 个，所以直接把 $n$ 按照任务区间的端点离散化，计算贡献依旧正常，就是要注意离散化后相邻两个值是否相差 $1$。复杂度 $O(mk\log m)$。

期望得分 $52$ 分。

这一部分代码如下：

```cpp
//b 数组是离散化数组，ln 是离散化数组的长度，其它部分都一样
inline void subtask3(){
	n=ln;
	rep(i,1,m){
		a[i].l=lower_bound(b+1,b+ln+1,a[i].l)-b;
		a[i].r=lower_bound(b+1,b+ln+1,a[i].r)-b;
		p[a[i].r].pb({a[i].l,a[i].k});
	}
	rep(i,0,ln)dp[i]=0;
	rep(i,1,ln){
		E(i)add(y.first,y.second);
		for(int j=i;j>=1&&b[i]-b[j]+1<=k;j--){
			int pos=j-2;
			if(b[j-1]!=b[j]-1)pos=j-1;
			dp[i]=max(dp[i],query(j)+got(pos)-1LL*(b[i]-b[j]+1)*d);
		}
		dp[i]=max(dp[i],dp[i-1]);
	}
	cout <<dp[ln]<<'\n';
	rep(i,1,ln)t[i]=0,p[i].clear();
}
```

- 我会线段树！

考虑我们的复杂度始终无法摆脱一个类似 $O(n^2)$ 的瓶颈。显然在于我们每次转移都是暴力枚举左端点。而不难发现，每次枚举的左端点是一个区间，只要能够满足一个查询区间最大值的数据结构就能把复杂度降下去。但中途加入任务区间又会带来区间修改。等等，区间修改和区间最大值？这直接线段树不就行了！使用线段树来处理，每次二分最靠左的满足条件的 $j$（当然也可以双指针），复杂度 $O(m\log m)$，足以通过此题！

赛时满分代码如下（去掉文件输入输出）：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid (l+r>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define Pi pair<int,int>
#define pb push_back
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57){if(c=='-')w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-'0',c=getchar();return s*w;}
const int N=2e5+5,M=1e6+5,inf=(1LL<<31)-1;
const ll llf=1e18; 
using namespace std;
int n,m,k,d,lsh[N],b[N],ln,testid,T;//days,tasks,limits,costs
struct node{
	int l,r,k;
}a[N];
inline void init(){
	ln=0;
	n=read(),m=read(),k=read(),d=read();
	lsh[m*2+1]=0;
	rep(i,1,m){
		a[i].r=read(),a[i].l=a[i].r-read()+1,a[i].k=read();
		lsh[(i<<1)-1]=a[i].l,lsh[i<<1]=a[i].r;
	}
	sort(lsh+1,lsh+m*2+1);
	rep(i,2,m*2+1)if(lsh[i]^lsh[i-1])b[++ln]=lsh[i-1];//离散化
}
ll dp[N];
inline ll got(int x){
	if(x>=0)return dp[x];
	return 0;
} 
vector<Pi >p[N];
#define E(x) for(auto y:p[x])
#define L x<<1
#define R L|1
#define lc L,l,mid
#define rc R,mid+1,r
#define OK Ll<=l&&r<=Rr
struct seg{
	ll w,laz;
}xd[N<<2];
inline void insert(int x,ll k){
	xd[x].w+=k,xd[x].laz+=k;
}
inline void pushdown(int x){
	insert(L,xd[x].laz),insert(R,xd[x].laz),xd[x].laz=0;
}
inline void getup(int x){
	xd[x].w=max(xd[L].w,xd[R].w);
}
inline void build(int x,int l,int r){
	xd[x]={0,0};
	if(l==r)return;
	build(lc),build(rc);
}
inline void modify(int x,int l,int r,int Ll,int Rr,ll k){
	if(OK)return insert(x,k),void();
	pushdown(x);
	if(Ll<=mid&&Rr>=l)modify(lc,Ll,Rr,k);
	if(Ll<=r&&Rr>mid)modify(rc,Ll,Rr,k);
	getup(x);
}
inline ll query(int x,int l,int r,int Ll,int Rr){
	if(Ll>Rr)return 0;
	if(OK)return xd[x].w;
	pushdown(x);
	if(Rr<=mid)return query(lc,Ll,Rr);
	if(Ll>mid)return query(rc,Ll,Rr);
	return max(query(lc,Ll,Rr),query(rc,Ll,Rr));
}
//线段树
#define Root 1,1,ln
inline int find(int x){
	int l=1,r=ln,ans=r;
	while(l<=r)if(b[mid]>=x)ans=mid,r=mid-1;
	else l=mid+1;
	return ans;
}//手写二分
inline void subtaskall(){
	build(Root);
	rep(i,0,ln)dp[i]=0;
	rep(i,1,m){
		a[i].l=lower_bound(b+1,b+ln+1,a[i].l)-b;
		a[i].r=lower_bound(b+1,b+ln+1,a[i].r)-b;
		p[a[i].r].pb({a[i].l,a[i].k});
	}
	rep(i,1,ln){
		E(i)modify(Root,1,y.first,y.second);
		int j=find(b[i]-k+1);
		dp[i]=max(dp[i],query(Root,j,i-1))-1LL*b[i]*d-1LL*d;
		int pos=i-2;
		if(b[i-1]!=b[i]-1)pos=i-1;
		dp[i]=max(dp[i],query(Root,i,i)+got(pos)-d);
		dp[i]=max(dp[i],dp[i-1]);
		modify(Root,i,i,got(pos)+1LL*b[i]*d);
	}
	cout <<dp[ln]<<'\n';
	rep(i,1,ln)p[i].clear();
}//dp
inline void solve(){
	subtaskall();
}
int main(){
	testid=read(),T=read();
	while(T--){
		init();
		solve();
	}
	return 0;
}
```
写的那么用心，点个赞再走吧 ！awa

#### update 2024/11/5：
- 修改了一处评论区指出的笔误。
- 一晃一年过去，又一年的 NOIP 又要开始了，如果在备战 NOIP 时感到迷茫，可以从[这篇专栏](https://www.luogu.com.cn/article/r244u201)获取一些建议，祝大家的 OI 生涯一帆风顺！

---

## 作者：lsj2009 (赞：117)

### 闲话

为什么都只评论不给赞啊/fn

场切了，但可能被卡常了（？

这个题和我们某场模拟赛的一个题 dp 方程长得几乎一样/jy

### Problem

link：<https://www.luogu.com.cn/problem/P9871>。

### Solution

一眼 dp，考虑设 dp 状态 $f_i$ 为考虑前 $i$ 天且强制第 $i$ 天跑步的最大值，同样设 $g_i=\max\limits_{j=1}^{i} f_j$。

易得一个转移方程：

$$f_i=\max\limits_{j=i-k}^{i-1} \{g_{j-1}-(i-j)\cdot d+\sum\limits_{[l_p,r_p]\subseteq(j,i]} v_p\}$$

也就是强制第 $j+1\sim i$ 天跑步，且第 $j$ 天不跑。

这个 dp 方程典中典了属于是，一眼考虑使用线段树优化。

先考虑如何做到 $\Theta(n\log{n})$。

我们考虑线段树下标是 $j$ 的决策点，存的东西是决策对应的值（记为 $h_j$），考虑当 $i-1\to i$ 时不同决策点的代价如何变化。

首先每一个决策点 $j$ 到 $i$ 都比到 $i-1$ 要多跑一天的步，所以 $\forall j\in[0,i)$ 的 $h_j\gets h_j-d$。

然后这时候满足 $r_p=i$ 的挑战 $(l_p,r_p,v_p)$ 变得可以选择（因为随着 $i$ 的不断右移，只要满足 $l_p>j$ 这些挑战就始终能选择），也就是对于所有的 $r_p=i,j\in[0,l_p)$ 的 $h_j\gets h_j+v_p$。

然后就得到了 $f_{i}=\max\limits_{j=i-k}^{i-1} h_j$，$g_i=\max (g_{i-1},f_i)$，而 $g_i$ 对比转移方程恰好在 $j=i+1$ 时取到，所以 $h_{i+1}\gets h_{i+1} +g_i$。

那么这就是一个 $\Theta(n\log{n})$ 的做法。

然后考虑如何优化到 $\Theta(m\log{m})$。容易发现的是，我们在转移过程中，只有 $j=l_p-1$ 和 $i=r_p$ 是有用的，所以我们考虑离散化，把 $l_p-1,r_p$ 丢到离散化数组 $\{t_{len}\}$ 里，然后就做完了。

复杂度 $\Theta(m\log{m})$。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll long long
#define ull unsigned long long
#define PII pair<int,int>
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define INFLL 0x3f3f3f3f3f3f3f3f
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=3e5+5;
namespace IO {
	char Is[(1<<21)+10],Os[(1<<21)+10];
	int Ipt,Opt;
	inline char gc() {
		if(Ipt==1<<21)
			Ipt=0;
		if(!Ipt)
			Is[fread(Is,1,1<<21,stdin)]=0;
		return Is[Ipt++];
	}
	inline void flush() {
		fwrite(Os,1,Opt,stdout);
		Opt=0;
	}
	inline void pc(char x) {
		if(Opt==1<<21)
			flush();
		Os[Opt++]=x;
	}
	inline int read() {
		int x=0;
		char ch=gc();
		while(ch<'0'||ch>'9')
			ch=gc();
		while(ch<='9'&&ch>='0')
			x=x*10+ch-'0',ch=gc();
		return x;
	}
}
using IO::read;
struct SGT {
	struct node {
		int l,r,val,tag;
	}; node tree[N<<2];
	#define ls(k) (k<<1)
	#define rs(k) (k<<1|1)
	inline void push_up(int k) {
		tree[k].val=max(tree[ls(k)].val,tree[rs(k)].val);
	}
	void build(int k,int l,int r) {
		tree[k]={l,r,0ll,0ll};
		if(l==r)
			return;
		int mid=(l+r)>>1;
		build(ls(k),l,mid);
		build(rs(k),mid+1,r);
		push_up(k);
	}
	inline void upd(int k,int val) {
		tree[k].val+=val; tree[k].tag+=val;
	}
	inline void push_down(int k) {
		int &t=tree[k].tag;
		if(t) {
			upd(ls(k),t); upd(rs(k),t);
			t=0;
		}
	}
	void update(int k,int ql,int qr,int val) {
		if(ql<=tree[k].l&&tree[k].r<=qr) {
			upd(k,val);
			return;
		}
		push_down(k);
		if(ql<=tree[ls(k)].r)
			update(ls(k),ql,qr,val);
		if(qr>=tree[rs(k)].l)
			update(rs(k),ql,qr,val);
		push_up(k);
	}
	int query(int k,int ql,int qr) {
		if(ql<=tree[k].l&&tree[k].r<=qr)
			return tree[k].val;
		push_down(k);
		int res=-INFLL;
		if(ql<=tree[ls(k)].r)
			chkmax(res,query(ls(k),ql,qr));
		if(qr>=tree[rs(k)].l)
			chkmax(res,query(rs(k),ql,qr));
		return res;
	}
}; SGT T;
int t[N],len;
inline int get_id(int x) {
	return lower_bound(t+1,t+len+1,x)-t;
}
struct seg {
	int l,r,val;
	bool operator < (const seg &tmp) const {
		return r<tmp.r;
	}
}; seg a[N];
inline void solve() {
	int n=read(),m=read(),k=read(),d=read();
	len=0;
	rep(i,1,m) {
		int r=read(),x=read(),val=read();
		a[i]={r-x,r,val};
		t[++len]=a[i].l;
		t[++len]=a[i].r;
	}
	sort(t+1,t+len+1);
	len=unique(t+1,t+len+1)-t-1;
	T.build(1,0,len-1);
	rep(i,1,m) {
		a[i].l=get_id(a[i].l); 
		a[i].r=get_id(a[i].r);
	}
	sort(a+1,a+m+1);
	int res=0,p=1;
	rep(i,1,len) {
		T.update(1,0,i-1,-d*(t[i]-t[i-1]));
		while(p<=m&&a[p].r==i)
			T.update(1,0,a[p].l,a[p].val),++p;
		chkmax(res,T.query(1,get_id(t[i]-k),i-1));
		if(i+1<len)
			T.update(1,i+1,i+1,res); 
	}
	printf("%lld\n",res);
}
//pretest at 12:44 , used time = 3.8s
signed main() {
//	freopen("run.in","r",stdin);
//	freopen("run.out","w",stdout);
	int _=read(),testcase=read();
	while(testcase--)
		solve();
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：50)

哈哈。考场上没 rush 出来，拿了本题大众暴力分跑路了。然而赛后发现本题其实并没有往年题目难。

这种问题肯定去想 dp，可以考虑对时间轴上 dp，令
$dp_i$
表示第 $i$ 天**不**打卡的最大能量，显然从上一天不打卡的位置转移，不妨设为 $j$，那么转移可以写成 

$$dp_i\leftarrow dp_j+w(j+1,i-1)-(i-j-1)d$$

的形式，要求 $i-j-1\le k$。其中 $w(l,r)$ 表示所有被 $[l,r]$ 完全包含的线段的价值之和。直接暴力做是 $O(nk)$ 的。线段树优化一下可以做到 $O(n\log n)$。

如果 $n\leq 10^9$，假设你真的把所有的 $dp_i$ 求出来了，你会发现有一堆连续段，换而言之就是 $dp$ 有用的决策点并不多。我们观察到是不打卡的。如果决策点有效，那么第 $i-1$ 天是要打卡的。所以，我们只需要记录一部分 $dp_i$ 的值，不难发现 $i$ 就是所有的 $l_i-1$ 以及 $r_i+1$。即下一天打卡，上一天打卡的所有点。

于是，我们可以直接离散化掉所有的 $l_i-1,r_i+1$。把 $dp$ 数组放到线段树上，重新考虑转移：


$$dp_i\leftarrow dp_j+w(j+1,i-1)-(i-j-1)d$$

$k$ 的限制在离散化后的作用显然是限制 $j$ 的转移点，考虑将所有线段发配到右端点上，在之前的 dp 的转移点上更新 $w_i$。换句话说，我们可以扫描线地更新每条线段的贡献。而 $d$ 的限制是比较烦人的，可以考虑**参变分离**。对于 $d$ 的话，可以在求 $dp_i$ 的步骤上解决。线段树重新维护为 $dp_i+i\times d$ 的区间最大值。直接转移即可，这样搞完之后恰好就会让 $(i,j)$ 的 $d$ 被减掉。

时间复杂度 $O(m\log m)$。尽量别写动态开点。同机房有人没有离散化导致常数太大挂成 $76$。
```cpp
//维护区间加，区间查询最大值的线段树已跳过
void solve(){
	cin>>n>>m>>k>>p;
	int tot=0;
	F(i,1,m){
		int x,y; cin>>x>>y;
		a[i]=x-y+1,b[i]=x;
		cin>>w[i];
		lsh[++tot]=a[i]-1;
		lsh[++tot]=b[i]+1;
	}
	sort(lsh+1,lsh+tot+1);
	int len=unique(lsh+1,lsh+tot+1)-lsh-1;
	F(i,1,m) c[i]=lower_bound(lsh+1,lsh+len+1,a[i]-1)-lsh; 
	F(i,1,m) d[i]=lower_bound(lsh+1,lsh+len+1,b[i]+1)-lsh; 
	vector<vector<int>>qr(len+1,vector<int>()); 
	F(i,1,m) qr[d[i]].push_back(i);
	// F(i,1,m) cout<<c[i]<<' '<<d[i]<<' '<<w[i]<<'\n';
	seg::clear(len);
	lsh[0]=0;
	seg::update(1,1,len,1,1,lsh[1]*p);
	int ans=0,lim=0;
	F(i,2,len){
		for(int j:qr[i]) seg::update(1,1,len,1,c[j],w[j]);
		for(;lsh[i]-lsh[lim]-1>k;++lim);
		chkmax(ans,seg::query(1,1,len,lim,i-1)-(lsh[i]-1)*p);
		if(i==len) cout<<ans<<'\n';
		seg::update(1,1,len,i,i,ans+lsh[i]*p);
	}
}
```

---

## 作者：tzl_Dedicatus545 (赞：45)

本题和 AT_dp_w 几乎一致，有兴趣的可以去看看。

因为本题要求 $1$ 必须连续才有贡献，也就是说：**跨过 $0$ 的区间不会产生贡献**，这启示我们进行以下状态设计：

$f_i$ 表示第 $i$ 天不跑步（为 $0$）的情况下，所产生的最大贡献。

注意到该状态无后效性，因为一定不会出现 $i$ 之前的某一天对 $i$ 之后产生贡献，因为我们已经钦定了第 $i$ 天不跑步，据此，我们可以写出 $\Theta(n^2)$ 的状态，可获得 36pts。

$$f_i=\max(f_{i-1},\max_{i-k-1\leq j\leq i-2}{f_j+val(j,i)-d\times(i-j-1)})$$

其中 $val(i,j)$ 表示 $i\sim j$ 中如果全部跑步，能产生多少贡献。

注意到对于某个挑战 $(l,r,w)$，如果我们在计算 $f_r$ 后，将 $l-1$ 之前所有的 $f_i$ 加上 $w$，就可以消除 $val(i,j)$ 的影响，因为在之后的转移之中，**我们在从 $f_{l-1}$ 及之前的位置转移时，一定会钦定 $l\sim r$ 全部为 $1$，从而产生了 $w$ 的贡献。**

对于 $d\times(i-j-1)$ 一项，我们只需将其拆开，变为 $d\times i$ 和 $d\times (j-1)$ 即可。

我们不妨令 $g_i=f_i+i\times d$，我们的转移式就变为如下的样子：

$$g_i=\max(g_{i-1}+d,\max_{i-k-1\leq j\leq i-2}{g_j+val(j,i)+d})$$

那个 $\max(g_{i-1})$ 项显然是搞笑的。

注意到我们实际上需要支持的操作即为：区间加，区间 $\max$，此时，我们便可以使用线段树维护了，期望得分 56pts。

注意到此时，对于所有 $l-1$ 到下一个 $r+1$，$g_j$ 值事实上是**本质相同的**，这启示我们进行离散化，将需要枚举的转移点降至 $m$ 的量级，时间复杂度 $\Theta(m \log m)$，就可以通过本题了。

考场上常数太大，挂到 76 了，哈哈。

我 NOIP2023 是怎么打成这种分的？

**代码：<https://www.luogu.com.cn/paste/zigrrkm9>**

**Upd on 2023/11/18 15:14：改了一个错字**

**Upd on 2024/11/24 22:31：又做了一遍这个题，同时修复若干问题。强烈谴责将本题升紫的管理员！！！**

---

## 作者：Phartial (赞：22)

设 $l_i=x_i-y_i+1,r_i=x_i$。

设 $f_{i,0/1}$ 表示前 $i$ 天中第 $i$ 天不跑/跑时的最大收益。有转移方程：

- $f_{i,0}=\max\limits_{j<i}(f_{j,1})$；
- $f_{i,1}=\max\limits_{i-k\le j<i}(f_{j,0}+dj+\sum\limits_{j<l_u\le r_u\le i}v_u)-di$；

$f_{i,0}$ 转移中的前缀 $\max$ 不难 $\mathcal{O}(1)$ 维护。

对于 $f_{i,1}$ 的转移，为方便，我们可以将在转移 $f_{j,0}$ 的时候就将 $dj$ 加入其中，而对于 $\sum\limits_{j<l_u\le r_u\le i}v_u$，我们可以在转移前将所有满足 $r_u=i$ 的 $(l_u,r_u,v_u)$ 的贡献加入 $f_{j,0}$（即对所有 $j<l_u$ 的 $f_{j,0}$ 加上 $v_u$）。于是 $f_{i,1}$ 的转移就变成了简单的区间 $\max$，使用线段树维护 $f_{j,0}$ 即可，时间复杂度 $\mathcal{O}(n\log n)$，考虑优化。

注意到最终答案中我们必然只在形如 $[r_i+1,l_j-1]$ 的区间中不跑，且只在形如 $[l_i,r_j]$ 的区间中跑，因此决策点只可能是所有 $l_j-1$ 和 $r_j$，对所有 $l_i-1$ 和 $r_i$ 离散化，并只考虑这 $\mathcal{O}(m)$ 个位置即可。时间复杂度 $\mathcal{O}(m\log m)$。

```cpp
#include <algorithm>
#include <iostream>

using namespace std;
using LL = long long;

const int kM = 1e5 + 1, kN = kM * 2;

struct C {
  int l, r, v;

  bool operator<(const C &o) const { return r < o.r; }
} a[kM];
struct E {
  LL mx, ta;
} e[kN << 2];
int cid, tt;
int n, m, k, v, b[kN];
LL d, f[kN];

void Pu(int x) { e[x].mx = max(e[x * 2].mx, e[x * 2 + 1].mx); }
void Pa(int x, LL v) { e[x].mx += v, e[x].ta += v; }
void Pd(int x) { Pa(x * 2, e[x].ta), Pa(x * 2 + 1, e[x].ta), e[x].ta = 0; }
void B(int x, int l, int r) {
  e[x].ta = 0;
  if (l == r) {
    e[x].mx = (l ? -1e18 : 0);
    return;
  }
  int m = l + r >> 1;
  B(x * 2, l, m), B(x * 2 + 1, m + 1, r);
  Pu(x);
}
void U(int x, int l, int r, int t, LL v) {
  if (l == r) {
    e[x].mx = v;
    return;
  }
  Pd(x);
  int m = l + r >> 1;
  if (t <= m) {
    U(x * 2, l, m, t, v);
  } else {
    U(x * 2 + 1, m + 1, r, t, v);
  }
  Pu(x);
}
void A(int x, int l, int r, int tl, int tr, LL v) {
  if (l == tl && r == tr) {
    Pa(x, v);
    return;
  }
  Pd(x);
  int m = l + r >> 1;
  if (tl <= m) {
    A(x * 2, l, m, tl, min(m, tr), v);
  }
  if (m < tr) {
    A(x * 2 + 1, m + 1, r, max(m + 1, tl), tr, v);
  }
  Pu(x);
}
LL Q(int x, int l, int r, int tl, int tr) {
  if (l == tl && r == tr) {
    return e[x].mx;
  }
  Pd(x);
  int m = l + r >> 1;
  LL s = -1e18;
  if (tl <= m) {
    s = max(s, Q(x * 2, l, m, tl, min(m, tr)));
  }
  if (m < tr) {
    s = max(s, Q(x * 2 + 1, m + 1, r, max(m + 1, tl), tr));
  }
  return s;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  for (cin >> cid >> tt; tt--;) {
    cin >> n >> m >> k >> d;
    v = 0;
    for (int i = 1; i <= m; ++i) {
      cin >> a[i].r >> a[i].l >> a[i].v;
      a[i].l = a[i].r - a[i].l;
      b[++v] = a[i].l, b[++v] = a[i].r;
    }
    sort(b + 1, b + v + 1);
    v = unique(b + 1, b + v + 1) - b - 1;
    for (int i = 1; i <= m; ++i) {
      a[i].l = lower_bound(b + 1, b + v + 1, a[i].l) - b;
      a[i].r = lower_bound(b + 1, b + v + 1, a[i].r) - b;
    }
    sort(a + 1, a + m + 1);
    B(1, 0, v);
    LL pm = 0;
    for (int i = 1, j = 1, u = 0; i <= v; ++i) {
      U(1, 0, v, i, pm + d * b[i]);
      for (; j <= m && a[j].r == i; ++j) {
        A(1, 0, v, 0, a[j].l, a[j].v);
      }
      for (; u < i && b[u] < b[i] - k; ++u) {
      }
      if (u < i) {
        f[i] = Q(1, 0, v, u, i - 1) - d * b[i];
      } else {
        f[i] = -1e18;
      }
      pm = max(pm, f[i]);
    }
    cout << pm << '\n';
  }
  return 0;
}
```

---

## 作者：不知名用户 (赞：16)

题意：有 $n$ 天，每天可以选择跑步或者不跑步，若跑步能量会减少 $d$（能量中途可以为负）。不能连续跑超过 $k$ 天。有 $m$ 个任务：如果在 $[L,R]$ 天连续跑步，那么就会得到 $v$ 个能量。求最后能量最大值。

暴力 DP：设 $f_{i,j}$ 表示到第 $i$ 天，$j$ 到 $i$ 天都打卡，$j-1$ 天不打卡的最大能量（特别地，$j=i+1$ 表示第 $i$ 天休息）。则 $f_{i,j}=f_{i-1,j};f_{i,i+1}=\max\{f_{i-1,\{1,2,\cdots,i\}}\}$，同时加上任务的贡献（前缀和一下，不然复杂度有亿点点大）。这里就可以拿到 $\Theta(n^2)$ 的 36pts 啦！

发现式子很像可以线段树优化的，具体地，如果想求 $f_{i,\{1,2,\cdots,i+1\}}$，现在已经得到了 $i-1$ 的 $f$：

0. 继承（啥也不用做）
1. 赋值 $f_{i,i+1}$
2. 对全局（1 到 $i$）减 $d$
3. 对于任务提供的能量区间加
4. 对于打卡超过 $k$ 天的状态赋值 `-inf`

然后就可以 $(n+m)\log n$ 56pts 啦！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 10;

vector<pair<int,int> >g[N];

struct node
{
	int mx, add, zero;
}st[N*4];
inline void jia(int p, int x){st[p].add += x;st[p].mx += x;}
inline void Zero(int p){st[p].mx = -1e18;st[p].add = 0;st[p].zero = 1;}
inline void upd(int p){st[p].mx = max(st[p*2].mx,st[p*2+1].mx);}
inline void spd(int p)
{
	if(st[p].zero) Zero(p*2),Zero(p*2+1);
	st[p].zero = 0;
	jia(p*2,st[p].add);jia(p*2+1,st[p].add);
	st[p].add = 0;
}
void build(int p, int L, int R)
{
	st[p].mx = -1e18;st[p].add = st[p].zero = 0;
	if(L==R) return;
	int mid = L + R >> 1;
	build(p*2,L,mid);build(p*2+1,mid+1,R); 
}
void add(int p, int l, int r, int L, int R, int x)
{
//	for(int i=l;i<=r;i++)
//		st[i].mx += x;
	if(l<=L&&R<=r) return jia(p,x), void();
	int mid = L + R >> 1;
	spd(p);
	if(l<=mid) add(p*2,l,r,L,mid,x);
	if(mid<r) add(p*2+1,l,r,mid+1,R,x);
	upd(p);
} 
void ze(int p, int l, int r, int L, int R)
{
//	for(int i=l;i<=r;i++) st[i].mx = -1e18;
	if(l<=L&&R<=r) return Zero(p), void();
	int mid = L + R >> 1;
	spd(p);
	if(l<=mid) ze(p*2,l,r,L,mid);
	if(mid<r) ze(p*2+1,l,r,mid+1,R);
	upd(p);
} 
int ask(int p, int l, int r, int L, int R)
{
//	int ans = -1e18;
//	for(int i=l;i<=r;i++) ans = max(ans,st[i].mx);
//	return ans;
	if(l<=L&&R<=r) return st[p].mx;
	int mid = L + R >> 1;
	spd(p);
	if(l>mid) return ask(p*2+1,l,r,mid+1,R);
	if(mid>=r) return ask(p*2,l,r,L,mid);
	return max(ask(p*2,l,r,L,mid),ask(p*2+1,l,r,mid+1,R));
}

int Main()
{
	int n, m, k, d, i;
	cin>>n>>m>>k>>d;
	for(i=1;i<=n;i++) g[i].clear();
	while(m--)
	{
		int x, y, v;
		cin>>x>>y>>v;
		g[x].emplace_back(y,v);
	}
	build(1,1,n+1);
	add(1,1,1,1,n+1,1e18);
	for(i=1;i<=n;i++)
	{
		int x = ask(1,1,i,1,n+1);
		add(1,i+1,i+1,1,n+1,(int)1e18+x);
		add(1,1,i,1,n+1,-d);
		for(auto j:g[i])
			add(1,1,i-j.first+1,1,n+1,j.second);
		if(i>k) ze(1,1,i-k,1,n+1);
	}
	cout<<ask(1,1,n+1,1,n+1)<<'\n';
	return 0;
}

signed main()
{
	int c, t;
	cin>>c>>t;
	while(t--) Main();
	return 0;
} 
```

进一步，发现 $m$ 很小，所以有用的点很少。具体地，由每个任务的端点截得的一些区间要么选或不选。

端点截区间的套路是把每个线段的左端点和右端点加一离散化到数组 $x$，则 $[x_i,x_{i+1})$ 是一个基本区间。

其实在刚刚 56pts 的代码上改改就行了，主要改了这几处：

- 离散化（废话）
- 减的 $d$ 还要乘上区间的长度
- 对于跑步超过 $k$ 天的要二分找端点赋值 `-inf`

然后就 $\Theta(m\log m)$ 完结散花！

常数由亿点点大的代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 10;

vector<pair<int,int> >g[N*2];

struct node
{
	int mx, add, zero;
}st[N*8];
inline void jia(int p, int x){st[p].add += x;st[p].mx += x;}
inline void Zero(int p){st[p].mx = -1e18;st[p].add = 0;st[p].zero = 1;}
inline void upd(int p){st[p].mx = max(st[p*2].mx,st[p*2+1].mx);}
inline void spd(int p)
{
	if(st[p].zero) Zero(p*2),Zero(p*2+1);
	st[p].zero = 0;
	jia(p*2,st[p].add);jia(p*2+1,st[p].add);
	st[p].add = 0;
}
void build(int p, int L, int R)
{
	st[p].mx = -1e18;st[p].add = st[p].zero = 0;
	if(L==R) return;
	int mid = L + R >> 1;
	build(p*2,L,mid);build(p*2+1,mid+1,R); 
}
void add(int p, int l, int r, int L, int R, int x)
{
	if(l<=L&&R<=r) return jia(p,x), void();
	int mid = L + R >> 1;
	spd(p);
	if(l<=mid) add(p*2,l,r,L,mid,x);
	if(mid<r) add(p*2+1,l,r,mid+1,R,x);
	upd(p);
} 
void ze(int p, int l, int r, int L, int R)
{
	if(l<=L&&R<=r) return Zero(p), void();
	int mid = L + R >> 1;
	spd(p);
	if(l<=mid) ze(p*2,l,r,L,mid);
	if(mid<r) ze(p*2+1,l,r,mid+1,R);
	upd(p);
} 
int ask(int p, int l, int r, int L, int R)
{
	if(l<=L&&R<=r) return st[p].mx;
	int mid = L + R >> 1;
	spd(p);
	if(l>mid) return ask(p*2+1,l,r,mid+1,R);
	if(mid>=r) return ask(p*2,l,r,L,mid);
	return max(ask(p*2,l,r,L,mid),ask(p*2+1,l,r,mid+1,R));
}

int n, x[N], y[N], v[N], t[N*2], cur;

int pos(int x){return lower_bound(&t[1],&t[n]+1,x) - t;}

int Main()
{
	int m, k, d, i;
	cin>>n>>m>>k>>d;
	cur = 0;
	for(i=1;i<=m;i++)
	{
		cin>>x[i]>>y[i]>>v[i];
		y[i] = x[i] - y[i] + 1;
		t[++cur] = x[i] + 1, t[++cur] = y[i];
	}
//	for(i=1;i<=n+1;i++) t[i] = i;n++;
	sort(&t[1],&t[cur]+1);
	n = unique(&t[1],&t[cur]+1) - t - 1;
	for(i=1;i<=n;i++) g[i].clear();//用 i 表示区间 t[i]~t[i+1]-1，实际上只有 n-1 个区间 
	for(i=1;i<=m;i++)
		g[pos(x[i]+1)-1].emplace_back(pos(y[i]),v[i]);
	build(1,1,n);
	add(1,1,1,1,n,1e18);
	for(i=1;i<n;i++)
	{
		int x = ask(1,1,i,1,n);
		add(1,i+1,i+1,1,n,(int)1e18+x);
		add(1,1,i,1,n,-d*(t[i+1]-t[i]));
		for(auto j:g[i])
			add(1,1,j.first,1,n,j.second);
		if(t[i+1]-t[1]>k)
		{
			int l = 1, r = i, mid;
			while(l < r)
			{
				mid = l + r + 1 >> 1;
				if(t[i+1]-t[mid]>k) l = mid;
				else r = mid - 1;
			}
			ze(1,1,l,1,n);
		}
	}
	cout<<ask(1,1,n,1,n)<<'\n';
	return 0;
}

signed main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); 
	int c, t;
	cin>>c>>t;
	while(t--) Main();
	return 0;
} 
```

后言：

- 考场上我把第二维 $j$ 想成了连续的天数，所以看不出线段树优化，ImSB
- 调试的时候可以把离散化数组改成 1 到 $n+1$
- 这题算个水蓝（个人感觉），56pts 已经很线段树优化的板，还有对于区间的离散化，我因为离散化写的时候卡了好久，其它还算顺利。我觉得降绿也不算稀奇
- 感觉这题思维难度还好

---

## 作者：听取MLE声一片 (赞：15)

考虑 dp，设 $f_i$ 表示考虑到第 $i$ 个位置，已有的最大贡献。

转移即为从 $i$ 前面转移出价值最大的，用一个数据结构维护。当前位置为 $i$，对于前面的每个位置 $j$ 上存的值 $a_j$ 为从 $j$ 到 $i$ 连续跑步的最大价值。

对于一个挑战，更改其定义为 $l$，$r$，$x$，表示若从第 $l$ 天锻炼到第 $r$ 天，对答案产生 $x$ 的贡献。

利用扫描线思想，对于每个 $i$ 事先存下以其为右端点的挑战。

从小到大枚举 $i$，对于每个 $i$ 把以 $i$ 为右端点的挑战加入数据结构。具体的，操作为对 $[1,l]$ 区间加 $x$。


则转移为 $f_i=\max (f_{i-1},\max\limits_{j=i-k+1}\limits^{i}{a_j})$。

因为中间要空一个位置才能分为两个连续跑步过程，所以 $f_i$ 的贡献要加到 $a_{i+2}$ 上。

处理完第 $i$ 个位置后，要处理消耗，即为对 $[1,i]$ 区间减 $d$。

天数是在 $10^9$ 范围内，考虑离散化。

对于每一个挑战，把 $l$，$r$，$r+1$，$r+2$ 加入离散化数组。

转移的区间，即为找到最大的位置满足 $k$ 的限制即可。

设从第 $i$ 个位置到第 $i+1$ 个位置差了 $x$，则区间减 $x\times d$ 即可。

---

## 作者：CarroT1212 (赞：10)

24-10-22 upd：补充了一些细节。

以下的 $[l,r]$ 都表示 $[x_i-y_i+1,x_i]$。

### 解 1

首先是 $36$ 分的 DP：$dp_{i,j}$ 表示到第 $i$ 天时已经连续跑了 $j$ 天的最大能量值。则有

$$dp_{i,j}=\begin{cases}\max\limits_{o\le i-2,1\le p\le k}dp_{o,p}-d,&j=1\\dp_{i,j}=dp_{i-1,j-1}-d,&2\le j \le k\end{cases}$$

分别表示休息若干天后重新开跑和接上上一天的进度。至于吃饭，在 $i$ 等于某个 $r$ 的时候将 $j\ge l$ 的所有 $dp_{i,j}$ 加上 $v$ 即可。

继续优化。注意到 $dp_{i,j}=dp_{i-1,j-1}-d$ 这个式子，似乎非常适合进行整体处理。这相当于是 $i$ 每次加一，整个 DP 数组都向右平移一位后全部减 $d$，然后扔掉最右边超过 $k$ 的数，在左边塞一个 $\max\limits_{o\le i-2,1\le p\le k}dp_{o,p}-d$。

发现这个东西也可以转化成 DP 数组不动，起始点左移，每次空出来的一位用 $\max\limits_{o\le i-2,1\le p\le k}dp_{o,p}-d$ 补上。于是可以使用线段树维护：补起始点需要单点改+整体 $\max$，整体减 $d$ 和吃饭需要区间加，还挺好写。于是你获得了 $56$ 分。

又发现从某个 $l$ 起跑，正好跑到某个 $r$，不做无用功是最优的，于是你完全可以只考虑 $i=l_i$ 时的 $dp_{i,1}$ 和 $i=r_i$ 时候的 $dp_{i,j}$ 值。启用动态开点线段树仅在 $l_i,r_i$ 位置上进行统一维护即可。$100$ 到手。

$O(Tn\log V)$，但这个做法常数挺大，在 $10$ 组数据的压迫下似乎比较难飞过去，所以我写的是下面一种。

### 解 2

还有一种 DP 设法：$dp_{i,0}$ 表示只跑到第 $i$ 天，后面不跑时的最大能量值，$dp_{i,1}$ 为第 $i-1$ 天不跑，从 $i$ 开始时的最大能量值（单独拎出来方便表示用），$\operatorname{calc}(l,r)$ 表示跑第 $[l,r]$ 天能吃几次饭。则有

$$dp_{i,p}=\begin{cases}\max\limits_{i-j+1\le k}\{dp_{j,1}-(i-j+1)d+\operatorname{calc}(j,i)\},&p=0\\\max\limits_{o\le i-2}dp_{o,0},&p=1\end{cases}$$

$O(n^2)$ 预处理 $\operatorname{calc}(l,r)$ 并 DP 有 $36$，发现瓶颈在于 $dp_{i,0}$ 那坨东西过于丑了，考虑在线维护转移值，打包到 $dp_{i,1}$ 上处理（注意后面 $dp_{i,1}$ 的定义和暴力稍微有点差别，因为要在线维护所以把从 $i$ 开始的能量值也算上了）。

遍历天数，设现在是第 $i$ 天，相当于初始是 $dp_{i,1}=\max\limits_{o\le i-2}dp_{o,0}$，然后每过一天就把所有 $dp_{j,1}$ 减 $d$。$\operatorname{calc}$ 的维护就是如果遇到 $r=i$，那就把 $j$ 不大于这个 $r$ 对应的 $l$ 的所有 $dp_{j,1}$ 加上 $v$。同时改了之后 $dp_{i,0}=\max\limits_{i-j+1\le k} dp_{j,1}$。可以线段树，区间加、单点改、区间 $\max$ 有 $56$。

推广。$n\le 10^9$ 的话就不需要动态开点了，同解 1，直接把 $l_i,r_i$ 离散化出来，只计算这些位置上的值即可。

$O(Tn\log n)$，比上面一种做法容易过一些，写的丑的话需要做一些常数优化，比如下面的代码就通过懒标记下传不开单独函数压进了 1.95s。

```cpp
struct tB { int x,y,z; } a[N];
int type;
int n,m,k,d;
ll t[N<<2],tg[N<<2],dp[N],mx[N];
vector<pii > ch[N];
int lsh[N],nn;
int upb(int x) { return lower_bound(lsh+1,lsh+nn+1,x)-lsh; }
int lwb(int x) { return upper_bound(lsh+1,lsh+nn+1,x)-1-lsh; } // 离散化用的
void add(int p,int l,int r,int x,int y,ll z) {
	if (x<=l&&r<=y) return t[p]+=z,tg[p]+=z,vo;
	int mid=l+r>>1;
	if (tg[p]) t[p<<1]+=tg[p],t[p<<1|1]+=tg[p],tg[p<<1]+=tg[p],tg[p<<1|1]+=tg[p],tg[p]=0;
	if (x<=mid) add(p<<1,l,mid,x,y,z);
	if (y>mid) add(p<<1|1,mid+1,r,x,y,z);
	t[p]=max(t[p<<1],t[p<<1|1]);
}
ll que(int p,int l,int r,int x,int y) {
	if (x<=l&&r<=y) return t[p];
	int mid=l+r>>1; ll ret=-I;
	if (tg[p]) t[p<<1]+=tg[p],t[p<<1|1]+=tg[p],tg[p<<1]+=tg[p],tg[p<<1|1]+=tg[p],tg[p]=0;
	if (x<=mid) ret=max(ret,que(p<<1,l,mid,x,y));
	if (y>mid) ret=max(ret,que(p<<1|1,mid+1,r,x,y));
	return ret;
}
void mian() {
	scanf("%d%d%d%d",&n,&m,&k,&d);
	for (int i=1;i<=nn;i++) ch[i].clear();
	nn=0;
	for (int i=1;i<=m;i++)
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z),
		lsh[++nn]=a[i].x,lsh[++nn]=a[i].x-a[i].y+1;
	sort(lsh+1,lsh+nn+1),nn=unique(lsh+1,lsh+nn+1)-1-lsh;
	for (int i=1;i<=m;i++) ch[upb(a[i].x)].pb({a[i].y,a[i].z});
	memset(t,0,sizeof(t)),memset(tg,0,sizeof(tg));
	for (int i=1;i<=nn;i++) {
		add(1,0,nn,i,i,mx[lwb(max(lsh[i]-2,0))]-d);
		add(1,0,nn,0,i-1,-d*(lsh[i]-lsh[i-1]));
		for (pll j:ch[i]) add(1,0,nn,0,lwb(lsh[i]-j.first+1),j.second);
		dp[i]=que(1,0,nn,upb(max(lsh[i]-k+1,0)),i),mx[i]=max(mx[i-1],dp[i]);
	}
	printf("%lld\n",mx[nn]);
}
```

其它几个部分分的代码看[这里](https://www.luogu.com.cn/paste/e7yi37gl)。

提一句，这题的 B 性质理论上也需要数据结构维护解 2 里面的 DP 才能过，但是似乎由于宇宙射线的力量，你只需要对于每个吃饭区间看吃饭的能量值是否大于消耗的，完全不管 $k$ 的问题也可以得到官方数据的 $8$ 分。别问我怎么知道的。

---

## 作者：popossible (赞：9)

首先，看到题后马上想到此问题是可以用 dp 解决的，考虑设 $dp_{i,j}$ 表示在第 $i$ 天已经连续跑步了 $j$ 天的最高能量值，则有如下转移， 
$$
dp_{i,j}=
\begin{cases} 

\max \limits_{j=0}^{k} dp_{i-1,j},j=0 \\
dp_{i-1,j-1}-d,1\leq j \leq k

\end{cases}
$$
再加上吃饭获得的能量值，于是立即得到 $36$ 分暴力 dp 做法。

我们观察这个转移，发现其可以归咎为以下操作，

+ 取第 $i$ 天全局 $\max$ 并填到 $i+1$ 的 $dp_{i+1,0}$ 中；
+ 将第 $i$ 天向右平移一位，并去掉最后一位；
+ 对第 $i$ 天的一段后缀加上一个数。

发现这可以简单的使用平衡树维护，于是可以获得 $56$ 分，~~考场拿这分数差不多了因为在写就调不出来了~~。

再进一步，我们考虑 $n \leq 10^9$ 该怎么做。

进一步观察 dp 式子，我们可以发现如下规律，

+ $dp_{i,0}$ 只可能在每次吃饭的下一天更新，如果吃饭后再跑一天则一定比吃完饭就更新劣；
+ 在两顿饭之间，只有可能把数组向右平移一个位置，不会更新 $dp_{i,0}$，证明同上。

于是我们有以下想法，

+ 将吃饭按 $x$ 从小到大排序，每次取出 $x$ 相同的一段处理最新的 $dp$ 数组。

我们考虑如何维护这样一个 $dp$ 数组。

我们使用两棵树，一颗记录所有可能的 $dp_{i,0}$，记为 $T_0$；一颗记录当前的 $dp_i$，记为 $T$。

我们先列出所有需要的操作，

+ 将所有元素的下标增加一个数；
+ 删去下标大于某个值的所有元素；
+ 对一段区间的某一元素加减一个数；
+ 取一段区间的某一元素 $\max$；
+ 取一段区间的每一元素的和；
+ 删除某个区间。

我们先考虑维护要维护哪些位置，以下图为例，

![](https://cdn.luogu.com.cn/upload/image_hosting/jz1r7ut6.png)

考虑这样两次吃饭，$x_1=8,y_1=3,v_1=a_1$ 和 $x_2=10,y_2=7,v_2=a_2$，

当第 $8$ 天时，$dp$ 变成了以下的样子，

![](https://cdn.luogu.com.cn/upload/image_hosting/csykpq68.png)

当第 $10$ 天时，$dp$ 变成了以下样子，

![](https://cdn.luogu.com.cn/upload/image_hosting/4y57blz3.png)

发现，$dp$ 其实可以被以下情况概括，

![](https://cdn.luogu.com.cn/upload/image_hosting/7dx2ppb1.png)

即连续跑 $5\sim 6$ 天，获得 $a_1$ 能量值；连续跑 $7\sim 11$ 天，获得 $a_1+a_2$ 能量值。而且可以获知，最大值只会在这些位置和连续跑 $0$ 天的位置取到，于是只维护吃饭获得能量的开始位置即可。

考虑如何算出总的能量值。

首先，发现从 $0\sim k$ 这些位置 $-d$ 的贡献是一定的，于是只用在平移时全局加上 $平移距离\times (-d)$ 即可。

其次，我们考虑每个位置由哪个 $dp_{i,0}$ 转移而来。我们在每次吃完饭加入最大值时，在 $T_0$ 的最前面加入下标为 $-1$，权值为 $T$ 中最大能量值的元素，每次加上 $v$ 时，在 $T_0$ 中查找从其对应的 $y$ 开始的一段后缀的最大值加到当前位置的能量值即可。

最后，我们考虑每次加入新的 $v$ 时如何维护，发现，只要取位置小于等于 $y$ 的所有 $v$ 之和加到自己位置的能量值即可。当然，还要对位置大于 $y$ 的能量值加上 $v$。

将算好的能量值添加到 $T$ 中即可，下标为 $y$。

当然，最开始在 $T_0$ 中加入下标为 $0$，权值为 $0$ 的元素与下标为 $n+1$，权值为 $-\infty$ 的元素。

维护即可，可以得到 $100$ 分，略有卡常。

[代码](https://www.luogu.com.cn/paste/2b8lhge1) 比较丑，请见谅。

---

## 作者：operator_ (赞：6)

# P9871 [NOIP2023] 天天爱打卡

[题目传送门](https://www.luogu.com.cn/problem/P9871)

## 题解

T4 天天爱打卡(run)

考察：$dp$、线段树

先考虑 $n=10^5$ 的部分分。动态规划是显然的：记 $f_{i,0/1}$ 表示前 $i$ 位，最后一位选/不选的最大能量。转移： $f_{i,0}=\max(f_{i-1,0},f_{i-1,1})$，$f_{i,1}=\max_{i-j+1\le k}(f_{j-1,0}+val(j,i))$。也是显然的线段树优化，把 $val$ 拆成加减两部分，减的部分是简单的，而加的部分对挑战按结束时间排序，然后指针扫描即可。

接下来考虑满分做法，基于一个贪心理念：跑步的目的是为了完成挑战，所以显然就是对所有挑战的起始与终止点进行离散化，但是转移就有点不同了。

记 $f_{i,0/1}$ 表示前 $i$ 个关键点，最后一个选/不选的最大能量。

$f_{i,0}=\max(f_{i-1,0},f_{i-1,1})$ 是同理的，但 $f_{i,1}$ 稍微有点不同，首先，我们枚举最后一段跑步之后，在上文中我们只能从 $f_{j-1,0}$ 转移，这是为了使跑步不再连续，但在这儿，我们是可能可以从 $f_{j-1,1}$ 转移的，因为两个关键点之间也许有空隙，我们只要在空隙中不跑步那么依然是不连续的，所以要特判关键点是否连续。然后转移的范围可以使用另一个指针来扫描，$val$ 中加的部分与上文相同（因为所有起始终止点都是作为关键点参与离散化的），可减的部分就有点不同了：我们把其拆为 $-d(p_i-p_{i-1})-d(p_{i-1}-p_{i-2})-\dots-d(p_{j+1}-p_j)-d$，然后考虑贡献，但是千万注意最后的那个 $-d$！被坑了好久，，，

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
#define inf ((int)1e12)
int c,t,n,m,k,d,b[200005],cnt,f[200005][2];
struct QWQ {int l,r,v;} a[100005];
bool cmp(QWQ a1,QWQ a2) {return a1.r<a2.r;}
struct Node {int l,r,d,laz;};
struct Segment_Tree {
  	Node t[4*200005];
	int ls(int p) {return p<<1;}
	int rs(int p) {return p<<1|1;}
	void pushup(int p) {t[p].d=max(t[ls(p)].d,t[rs(p)].d);}
	void pushdown(int p) {
		t[ls(p)].d+=t[p].laz,t[rs(p)].d+=t[p].laz;
		t[ls(p)].laz+=t[p].laz,t[rs(p)].laz+=t[p].laz;t[p].laz=0;
	}
	void clear(int p,int l,int r) {
		t[p].l=l,t[p].r=r,t[p].d=-inf,t[p].laz=0;
		if(l==r) return;int m=(l+r)>>1;
		clear(ls(p),l,m);clear(rs(p),m+1,r);
	}
	void update(int p,int l,int r,int v) {
		if(l>r) return;
		if(l<=t[p].l&&t[p].r<=r) {t[p].d+=v,t[p].laz+=v;return;}
		pushdown(p);int m=(t[p].l+t[p].r)>>1;
		if(l<=m) update(ls(p),l,r,v);
		if(r>m) update(rs(p),l,r,v);pushup(p);
	}
	int query(int p,int l,int r) {
		if(l<=t[p].l&&t[p].r<=r) return t[p].d;
		pushdown(p);int s=-inf,m=(t[p].l+t[p].r)>>1;
		if(l<=m) s=max(s,query(ls(p),l,r));
		if(r>m) s=max(s,query(rs(p),l,r));return s;
	}
} tt;
signed main() {
	cin>>c>>t;
	while(t--) {
		cin>>n>>m>>k>>d;
		b[cnt=1]=n;
		for(int i=1;i<=m;i++) {
			int x=read(),y=read();
			b[++cnt]=a[i].l=x-y+1,b[++cnt]=a[i].r=x,a[i].v=read();
		}
		sort(b+1,b+cnt+1);int q=unique(b+1,b+cnt+1)-b-1;
		tt.clear(1,1,200002);
		memset(f,-0x3f,sizeof(f));f[0][0]=0;tt.update(1,1,1,inf);
		for(int i=1;i<=m;i++)
			a[i].l=lower_bound(b+1,b+q+1,a[i].l)-b,a[i].r=lower_bound(b+1,b+q+1,a[i].r)-b;
		sort(a+1,a+m+1,cmp);
		for(int i=1,j=1,r=1;i<=q;i++) {
			tt.update(1,1,i-1,-d*(b[i]-b[i-1]));
			while(b[i]-b[j]+1>k) j++;
			while(r<=m&&a[r].r==i)
				tt.update(1,1,a[r].l,a[r].v),r++;
			f[i][0]=max(max(f[i-1][0],f[i-1][1]),0ll);
			f[i][1]=tt.query(1,j,i)-d;
			if(b[i+1]-b[i]==1) tt.update(1,i+1,i+1,inf+f[i][0]);
			else tt.update(1,i+1,i+1,inf+max(f[i][0],f[i][1]));
		}
		printf("%lld\n",max(f[q][0],f[q][1]));
	}
	return 0;
}
```

时间复杂度 $O(m\log m)$。

---

## 作者：N2MENT (赞：6)

P9871

---

#### 这段是鲜花

还没开题解通道（吗）。

纪念一下简单到能让笨蛋切掉的 T4。

考试前一天跟 dhf 立 flag 说明天最长代码 $\texttt{3KB}$，考完一看 $\texttt{2.99KB}$。

连续两年都是线段树板子，对于我这种啥也不会滴十分友好。

不知道会不会退役，反正现在我只负责睡觉，写篇题解应付一下正在逝去的青春。

---

#### 这段是题解

忘记什么时候了，考场发现自己不会 T3，果断开 T4。

一个很长的序列，很多区间的贡献，一些奇怪的限制，以及电脑前的笨蛋，一看就是线段树优化 dp（吗），不知道，猜的，于是乱糊一个 $O(nm)$ 暴力 dp，发现过了三个样例，套上线段树就过了全部大样例。

总之就是非常简单，先按照右端点为第一关键字，左端点为第二关键字排个序。设 $f_i$ 表示最后一次从 $i$ 开始打卡到 $r$ 的答案（为了方便处理没有算上最后一次的代价）。

我们看看从上一个区间转移过来会改变什么，首先从 $\forall i \in (r - k,l],f_i\longleftarrow f_i + v$，对应了必须走这段区间，顺便更新我们的答案，即钦定这是最后一个走的区间，那么 $ans \longleftarrow \max\{ans,\max_{i\in(r - k,l]}\{f_i - d(r - i + 1)\}\}$。但我们也可能新开始一段打卡，或者不走这段区间，所以我们更新的时候也要更新 $[r+2,n]$ 的这段区域，让 $f_i \longleftarrow \max\{f_i,\max_{i\in(r - k,l]}\{f_i - d(r - i + 1)\}\}$，表示我们要新开始一个段。

于是我们存一下 $f_i + d\cdot i$，实现区间求最大值，区间加，由于我们右端点一直右移，所以后面的取 $\max$ 操作也只需要区间加法。

总之就是看起来很对，离散化一下就变成了 $O(m\log m)$，不知道为啥同学说 $O(n\log n)$ 之类的神必东西是一眼的。

---

#### 这段是代码

考场写的，有些地方实现很奇怪。

```cpp
//terrible! it passed all samples 
//i hope it can get 100pts
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int maxm = 1e5 + 10;
const int maxn = 3 * maxm;
class SegTree {//modify range add, query range max
public:
	ll tr[maxn << 2], lazy[maxn << 2];
	void __getmax(ll& x, ll y) {
		if(x < y) x = y;
	}
	void __update(int k) {
		tr[k] = max(tr[k << 1], tr[k << 1 | 1]);
	}
	void __push(int k) {
		if(!lazy[k]) return;
		tr[k << 1] += lazy[k];
		tr[k << 1 | 1] += lazy[k];
		lazy[k << 1] += lazy[k];
		lazy[k << 1 | 1] += lazy[k];
		lazy[k] = 0;
		return;
	}
	void modify(int k, int l, int r, int L, int R, ll val) {
		if(L <= l && r <= R) {
			tr[k] += val;
			lazy[k] += val;
			return;
		}
		__push(k);
		int mid = (l + r) >> 1;
		if(L <= mid) modify(k << 1, l, mid, L, R, val);
		if(R > mid) modify(k << 1 | 1, mid + 1, r, L, R, val);
		__update(k);
	}
	ll query(int k, int l, int r, int L, int R) {
		if(L <= l && r <= R) return tr[k];
		__push(k);
		int mid = (l + r) >> 1;
		ll res = INT64_MIN;
		if(L <= mid) __getmax(res, query(k << 1, l, mid, L, R));
		if(R > mid) __getmax(res, query(k << 1 | 1, mid + 1, r, L, R));
		return res;
	}
	void build(int k, int l, int r, const vector<int>& num, int d) {
		lazy[k] = 0;
		if(l == r) {
			tr[k] = (ll)d * num[l - 1];
			return;
		}
		int mid = (l + r) >> 1;
		build(k << 1, l, mid, num, d);
		build(k << 1 | 1, mid + 1, r, num, d);
		__update(k);
	}
}sgt;
int n, m, k, d;
class Rew {
public:
	int l, r, w;
	Rew() = default;
	Rew(int l, int r, int w) : l(l), r(r), w(w) {}
};
vector<Rew> q;
vector<int> num;
ll ans;
void Solve() {
	q.clear();
	num.clear();
	cin >> n >> m >> k >> d;
	for(int i = 1; i <= m; i++) {
		int x, y, v;
		cin >> x >> y >> v;
		if(y > k) continue;
		q.emplace_back(x - y + 1, x, v);
		int l = x - y + 1;
		int r = x;
		num.emplace_back(max(1, r - k + 1));
		num.emplace_back(l);
		if(r + 2 <= n) num.emplace_back(r + 2);
	}
	num.emplace_back(n);
	sort(q.begin(), q.end(), [](Rew a, Rew b) {
		if(a.r != b.r) return a.r < b.r;
		return a.l < b.l;
	});
	sort(num.begin(), num.end());
	num.resize(unique(num.begin(), num.end()) - num.begin());
	int lim = num.size();
	sgt.build(1, 1, lim, num, d);
	ans = 0;
	for(auto cur : q) {
		int& l = cur.l, & r = cur.r, & w = cur.w;
		int xl = lower_bound(num.begin(), num.end(), max(1, r - k + 1)) - num.begin() + 1;
		int xr = lower_bound(num.begin(), num.end(), l) - num.begin() + 1;
		sgt.modify(1, 1, lim, xl, xr, w);
		ll res = sgt.query(1, 1, lim, xl, xr);
		ll mx = res - (ll)d * (r + 1);
		ans = max(ans, res - (ll)d * (r + 1));
		if(r + 2 > n) continue;
		xl = lower_bound(num.begin(), num.end(), r + 2) - num.begin() + 1;
		xr = lower_bound(num.begin(), num.end(), n) - num.begin() + 1;
		res = sgt.query(1, 1, lim, xr, xr) - (ll)d * n;
		if(mx > res) sgt.modify(1, 1, lim, xl, xr, mx - res);
	}
	cout << ans << '\n';
}
int main() {
// 	freopen("run.in", "r", stdin);
// 	freopen("run.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int c, t;
	cin >> c >> t;
	while(t--) Solve();
}
```




---

## 作者：strcmp (赞：5)

来自同机房场切 T4 的 dalao 的做法Orz。

不妨考虑一个 1d/1d dp。

设 $f_i$ 为考虑前 $i$ 个位置的最高能量值。

考虑枚举上一次中止跑步的断点 $j$，则 $f_i \leftarrow \max\limits_{j = i - k + 1}^{i}\{f_{j - 1} + c(j + 1,\,i)\}$。

其中 $c(l,\,r)$ 代表在 $[l,\,r]$ 这个区间一直跑步能获得的能量值。

$c$ 的快速计算是容易的，可以考虑在每个 $x_i - y_i + 1$ 的位置标记一个 $v$ 的贡献，表示在这之前一直跑步到 $x_i$ 位置就能获得 $v$ 的能量值。那么对它做一个前缀和 $s_i$ 就容易 $\Theta(1)$ 算了。$c(l,\,r) = (l - 1) \times d - r \times d + s_r - s_{l - 1}$。

这种对一个区间内的 dp，不妨考虑线段树优化。

线段树下标 $j$ 维护 $f_{j - 1} + c(j + 1,\,i)$。

那么考虑之前的 $f$ 已经固定了，改变的是 $c$ 这一部分。

然后我们发现取值不同的 $c$ 只有 $\Theta(m)$ 个，而每次扩展类似于对 $f_{j - 1} + c(j + 1,\,i)$ 做一个区间加。

线段树直接做即可，时间复杂度 $\Theta(Tm \log m)$。

说句闲话，这题是真的卡常，线段树换成 zkw 树才在各大 OJ 上过掉民间数据。（最大点 1.3s，对于 zkw 树真的很卡）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 3e5 + 10;
ll d[maxn << 2], f[maxn], sum[maxn];
int c, t, n, m, k, M = 1; ll D;
inline void upd(int x) {
    ll tmp = max(d[x << 1], d[x << 1 | 1]);
    d[x << 1] -= tmp; d[x << 1 | 1] -= tmp;
    d[x] += tmp;
}
inline void mdf(int l, int r, ll k) {
    for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {
        if (~l & 1) d[l ^ 1] += k;
        if (r & 1) d[r ^ 1] += k;
        upd(l >> 1), upd(r >> 1);
    }
    for (; l != 1; l >>= 1) upd(l >> 1);
}
inline ll qry(int l, int r) {
    ll la = 0, ra = 0; l += M, r += M;
    for (; (l ^ r) > 1; l >>= 1, r >>= 1) {
		la += d[l], ra += d[r];
		if (~l & 1) la = max(la, d[l ^ 1]);
		if (r & 1) ra = max(ra, d[r ^ 1]);
	}
	ll ans = max(la + d[l], ra + d[r]);
	while (l > 1) ans += d[l >>= 1];
    return ans;
}
struct Node { int x, y; ll v; }a[maxn];
int p = 0; int b[maxn];
inline int rvs(int x) { return lower_bound(b + 1, b + p + 1, x) - b; }
int main() {
    scanf("%d%d", &c, &t);
    while (t--) {
        memset(d, 0, sizeof(d));
        scanf("%d%d%d%lld", &n, &m, &k, &D); p = 0;
        for (int i = 1; i <= m; i++) {
            scanf("%d%d%lld", &a[i].x, &a[i].y, &a[i].v);
            b[++p] = a[i].x, b[++p] = a[i].x - a[i].y + 1, b[++p] = a[i].x - a[i].y;
        }
        b[++p] = 0; M = 1;
        while (M <= p + 1) M <<= 1;
        sort(b + 1, b + p + 1);
        p = unique(b + 1, b + p + 1) - b - 1;
        sort(a + 1, a + m + 1, [=](Node p1, Node p2){ return p1.x < p2.x; });
        for (int i = 1; i <= p + 1; i++) mdf(i, i, 1LL * b[i] * D), sum[i] = f[i] = 0;
        for (int i = 1, l = 1, r = 1; i <= p; i++) {
            f[i] = f[i - 1], sum[i] = sum[i - 1];
            if (l <= m && rvs(a[l].x) == i) {
                r = l;
                while (r < m && a[l].x == a[r + 1].x) ++r;
                for (int j = l; j <= r; j++) {
                    Node c = a[j]; int now = c.x - c.y + 1;
                    if (now < 1) continue;
                    mdf(rvs(now), p, -c.v);
                    sum[i] += c.v;
                }
                l = r + 1;
            }
            int now = rvs(b[i] - k); ll c = 1LL * b[i] * D;
            f[i] = max(f[i], -c + sum[i] + qry(now, i));
            mdf(i, i, f[i - 1]);
        }
        printf("%lld\n", f[p]);
    }
    return 0;
}
```

---

## 作者：_yjh (赞：4)

首先发现对每组数据可以 $O(nk)$ dp。具体地，不妨设 $f_{i,j}$ 表示只考虑结束时间在前 $i$ 天的挑战，到第 $i$ 天时连续打卡了 $j$ 天能量值最高时多少，转移是平凡的。期望获得 $36$ 分。

写出这个 dp 就会发现转移包含以下部分：在所有 dp 值前插入一个 dp 值，单点修改，区间加 $d$。显然可以简单的用线段树维护，于是可以获得 $56$ 分。

注意到只有挑战端点上的 dp 值是有用的，于是可以使用动态开点线段树维护上述转移。时间复杂度 $O(Tm \log n)$，期望获得 $100$ 分。


---

## 作者：Moeebius (赞：3)

> [full version](https://www.luogu.com.cn/blog/Moeebius/noip-2023-sol)

考虑一个显然的 $O(\sum n^2)$ DP：记 $f_i$ 表示第 $i$ 天结束最后一轮跑步所得到的最大能量值，然后从 $[1,i-k-1]$ 进行转移。

考虑在值域与 $m$ 同阶的情况下进行优化：对于 $f_i$ 的转移，我们只需要知道 $[1, i-k-1]$ 中 $f$ 的最大值，以及对应的起始时间所对应的 **跑步减少的能量值** 和 **吃饭增加的能量值**。

把所有贡献都挂到最后一次跑步的起始点上：

- $f$ 的贡献是好维护的，搞个前缀 $\max$ 就行；

- 吃饭增加的能量值也是好维护的；

- 唯一略显困难的是跑步减少的能量值，注意到其是一个等差数列的形式，因此可以先把每个位置赋上一个基准值，第 $i$ 个位置为 $di$，查的时候只要减去末位置的基准值即可。

因此我们只需要单点改区间 $\max$，线段树即可，时间复杂度 $O(\sum n \log n)$。

---

但是值域很大，发现只有 $m$ 个挑战涉及到的位置以及前后 $\pm 1$ 的位置有用，离散化即可。时间复杂度 $O(\sum m \log m)$。

```cpp
constexpr ll MAXN = 4e5 + 5;
int n, m;
ll K, d, f[MAXN];
tuple<ll, ll, ll> a[MAXN];
vector<ll> pool;
struct Node {
    int l, r;
    ll val, tag;
    Node() : l(0), r(0), val(0), tag(0) {}
} T[MAXN << 2];
#define lc(p) ((p) << 1)
#define rc(p) ((p) << 1 | 1)
il void pushUp(int p) { T[p].val = max(T[lc(p)].val, T[rc(p)].val); }
il void __f(int p, ll tg) { T[p].val += tg, T[p].tag += tg; }
il void pushDown(int p) {
    __f(lc(p), T[p].tag);
    __f(rc(p), T[p].tag);
    T[p].tag = 0;
}
void build(int p, int l, int r) {
    T[p] = {};
    T[p].l = l, T[p].r = r;
    if (l == r) {
        T[p].val = pool[l - 1] * d; // 基准值
        return;
    }
    int mid = (l + r) >> 1;
    build(lc(p), l, mid), build(rc(p), mid + 1, r);
    pushUp(p);
}
void update(int p, ll ql, ll qr, ll val) {
    int l = T[p].l, r = T[p].r;
    if (ql <= l && qr >= r)
        return __f(p, val), void();
    int mid = (l + r) >> 1;
    pushDown(p);
    if (ql <= mid)
        update(lc(p), ql, qr, val);
    if (qr > mid)
        update(rc(p), ql, qr, val);
    pushUp(p);
}
ll query(int p, ll ql, ll qr) {
    int l = T[p].l, r = T[p].r;
    if (ql <= l && qr >= r)
        return T[p].val;
    int mid = (l + r) >> 1;
    ll ans = 0;
    pushDown(p);
    if (ql <= mid) ans = max(ans, query(lc(p), ql, qr));
    if (qr > mid) ans = max(ans, query(rc(p), ql, qr));
    return ans;
}
il ll trans(ll x) {
    return lower_bound(pool.begin(), pool.end(), x) - pool.begin() + 1;
}
il ll trans2(ll x) {
    return upper_bound(pool.begin(), pool.end(), x) - pool.begin();
} // 处理边界问题

il void solve() {
    pool.clear(), pool.eb(1);
  read(n, m, K, d);
  For(i, 1, m) {
    ll x, y, v;
    read(x, y, v);
    a[i] = {x, y, v};
    pool.eb(x), pool.eb(x - y + 1), pool.eb(max(x - K + 1, 1ll));
  }
  sort(pool.begin(), pool.end());
  pool.erase(unique(pool.begin(), pool.end()), pool.end());

  sort(a + 1, a + 1 + m);
  build(1, 1, pool.size());
  fill(f + 1, f + 1 + pool.size(), 0);
  int id = 1;
  for (int _i = 0; _i < pool.size(); _i++) {
    ll cur = pool[_i];
    while (id <= m && get<0>(a[id]) == cur) {
      update(1, 1, trans(get<0>(a[id]) - get<1>(a[id]) + 1), get<2>(a[id]));
      id++;
    }
    if (cur > 2) update(1, _i + 1, _i + 1, f[trans2(cur - 2)]);
    f[_i + 1] = query(1, trans(max(1ll, cur - K + 1)), _i + 1) - 1ll * (cur + 1) * d;
    f[_i + 1] = max(f[_i], f[_i + 1]);
  }
  cout << f[pool.size()] << endl;
}
il void Main() {
  freopen("run.in", "r", stdin);
  freopen("run.out", "w", stdout);
  int c, T;
  read(c, T);
  while (T--) solve();
}
```

---

## 作者：zifanwang (赞：3)

$\large\textbf{Statement.}$

题意，即求出选择若干个互不相交且互不相邻的区间，每个区间的大小不超过 $k$，每个区间覆盖到的挑战的权值和 $-\sum (r-l+1)\cdot d$ 的最大值。

---

$\large\textbf{Solution.}$

直接 $\tt dp$，令 $f_n$ 表示前 $n$ 天的答案，枚举一个 $r=n$ 的区间的左端点对当前状态进行更新，最后再与 $f_{n-1}$ 取个最大值。

这样就得到了一个 $O(tn^2)$ 的做法，离散化以后可以做到 $O(tm^2)$。

然后就是线段树优化 $\tt dp$ 板子题，时间复杂度 $O(tm\log m)$，可以轻松通过。

参考代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 100003
#define md 1000000007
#define ld long double
#define pb push_back
#define mkp make_pair
#define umap unordered_map
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
#define pq priority_queue
using namespace std;
struct node{
    int x,y,z;
}a[mxn];
int C,T,n,m,k,d,rt,tot,f[mxn<<1];
ll t[mxn<<3],dp[mxn<<1],ad[mxn<<3];
inline void push_down(int p){
    if(ad[p]){
        ad[p<<1]+=ad[p],t[p<<1]+=ad[p];
        ad[p<<1|1]+=ad[p],t[p<<1|1]+=ad[p];
        ad[p]=0;
    }
}
void build(int p,int l,int r){
    ad[p]=0;
    if(l==r){
        t[p]=(ll)f[l+1]*d;
        return;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    t[p]=max(t[p<<1],t[p<<1|1]);
}
void add(int p,int l,int r,int x,int L,int R){
    if(l>r)return;
    if(l<=L&&R<=r){
        ad[p]+=x,t[p]+=x;
        return;
    }
    push_down(p);
    int mid=(L+R)>>1;
    if(l<=mid)add(p<<1,l,r,x,L,mid);
    if(r>mid)add(p<<1|1,l,r,x,mid+1,R);
    t[p]=max(t[p<<1],t[p<<1|1]);
}
ll ask(int p,int l,int r,int L,int R){
    if(l>r)return -1e18;
    if(l<=L&&R<=r)return t[p];
    push_down(p);
    int mid=(L+R)>>1;
    if(l<=mid&&r>mid)return max(ask(p<<1,l,r,L,mid),ask(p<<1|1,l,r,mid+1,R));
    if(l<=mid)return ask(p<<1,l,r,L,mid);
    return ask(p<<1|1,l,r,mid+1,R);
}
void change(int p,int x,ll y,int l,int r){
    if(l==r){t[p]=y;return;}
    push_down(p);
    int mid=(l+r)>>1;
    if(x<=mid)change(p<<1,x,y,l,mid);
    else change(p<<1|1,x,y,mid+1,r);
    t[p]=max(t[p<<1],t[p<<1|1]);
}
signed main(){
    scanf("%d%d",&C,&T);
    while(T--){
        scanf("%d%d%d%d",&n,&m,&k,&d);
        f[tot=1]=0;
        rep(i,1,m){
            scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
            swap(a[i].x,a[i].y);
            a[i].x=a[i].y-a[i].x+1;
            f[++tot]=a[i].x,f[++tot]=a[i].y;
        }
        sort(f+1,f+tot+1);
        tot=unique(f+1,f+tot+1)-f-1;
        build(1,1,tot);
        rt=1;
        sort(a+1,a+m+1,[](node x,node y){
            return x.y<y.y;
        });
        rep(i,2,tot){
            while(rt<=m&&a[rt].y<=f[i]){
                add(1,1,lower_bound(f+1,f+tot+1,a[rt].x)-f-1,a[rt].z,1,tot);
                rt++;
            }
            dp[i]=max(ask(1,lower_bound(f+1,f+tot+1,f[i]-k+1)-f-1,i-1,1,tot)-(ll)(f[i]+1)*d,dp[i-1]);
            if(f[i]+1==f[i+1])change(1,i,dp[i-1]+(ll)f[i+1]*d,1,tot);
            else change(1,i,dp[i]+(ll)f[i+1]*d,1,tot);
        }
        printf("%lld\n",dp[tot]);
    }
    return 0;
}
```

---

## 作者：Coffee_zzz (赞：1)

记 $l_i=x_i-y_i+1$，$r_i=x_i$。

设 $f_{i,j}$ 表示考虑到第 $i$ 天，第 $j$ 天不跑且第 $(j+1)$ 天至第 $i$ 天均跑的最大能量值。

容易得到转移方程：

$$
\begin{aligned}
& f_{i,i}=\max_{i-1-k \le s \le i-1} f_{i-1,s}\\
& f_{i,j}=f_{i-1,j}-d+\sum_{j \lt l_s \land r_s=i} v_s \ (i-k \le j \lt i)
\end{aligned}
$$

把所有 $l_s-1$ 和 $r_s$ 作为关键点拎出来进行离散化，因为显然只有这些点能影响最优解。设离散化数组为 $t$，则转移方程可以化为：

$$
\begin{aligned}
& f_{i,i}=\max_{t_{i-1}-k \le t_s\le t_{i-1}} f_{i-1,s}\\
& f_{i,j}=f_{i-1,j}-d\cdot(t_i-t_{i-1})+\sum_{t_j \lt l_s \land r_s=i} v_s\ (t_i-k \le t_j \lt t_i)
\end{aligned}
$$

注意到 $f_{i,i}$ 的转移只需要求区间最大值，且每组 $(l_s,r_s,v_s)$ 可以转化为区间加的形式，于是我们只需要把第一维压掉，上线段树优化，按照 $r_s$ 的顺序利用二分转移即可。

记得开 `long long`，注意卡常。

```cpp
#include <bits/stdc++.h>

#define ll long long
#define ull unsigned long long
#define i128 __int128
#define endl '\n'
#define pb push_back
#define pii pair<int,int>
#define fi first
#define se second
#define vei vector<int>
#define pq priority_queue
#define lb lower_bound
#define ub upper_bound
#define yes puts("yes")
#define no puts("no")
#define Yes puts("Yes")
#define No puts("No")
#define YES puts("YES")
#define NO puts("NO")
#define In(x) freopen(x".in","r",stdin)
#define Out(x) freopen(x".out","w",stdout)
#define File(x) (In(x),Out(x))
using namespace std;
static char buf[100000],*pa=buf,*pd=buf;
#define gc pa==pd&&(pd=(pa=buf)+fread(buf,1,100000,stdin),pa==pd)?EOF:*pa++
inline int read(){
    register int x(0);
	register char c(gc);
    while(c<'0'||c>'9') c=gc;
    while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=gc;
    return x;
}
const int N=1e5+5;
const ll inf=4e18;
vector <pii> ve[N<<1];
int n,m,k,d,x[N],y[N],v[N],w[N<<1],t[N<<1],tot,pos[N<<1];
ll val[N<<3],tag[N<<3];
void upd(int g){
	val[g]=max(val[g<<1],val[g<<1|1]);
}
void down(int g){
	if(!tag[g]) return;
	tag[g<<1]+=tag[g];
	val[g<<1]+=tag[g];
	tag[g<<1|1]+=tag[g];
	val[g<<1|1]+=tag[g];
	tag[g]=0;
}
void modify(int g,int l,int r,int x,ll k){
	if(x==l&&r==x){
		val[g]=k;
		return;
	}
	if(x<l||r<x) return;
	int m=(l+r)>>1;
	down(g);
	modify(g<<1,l,m,x,k);
	modify(g<<1|1,m+1,r,x,k);
	upd(g);
}
void add(int g,int l,int r,int x,int y,ll k){
	if(x<=l&&r<=y){
		val[g]+=k;
		tag[g]+=k;
		return;
	}
	if(y<l||r<x) return;
	int m=(l+r)>>1;
	down(g);
	add(g<<1,l,m,x,y,k);
	add(g<<1|1,m+1,r,x,y,k);
	upd(g);
}
ll ask(int g,int l,int r,int x,int y){
	if(x<=l&&r<=y) return val[g];
	if(y<l||r<x) return -inf;
	int m=(l+r)>>1;
	down(g);
	return max(ask(g<<1,l,m,x,y),ask(g<<1|1,m+1,r,x,y));
}
void solve(){
	for(int i=0;i<(N<<3);i++) val[i]=-inf,tag[i]=0;
	n=read(),m=read(),k=read(),d=read();
	for(int i=1;i<=m;i++){
		x[i]=read(),y[i]=read(),v[i]=read();
		w[i*2-1]=x[i]-y[i],w[i*2]=x[i];
	}
	sort(w+1,w+1+m*2);
	w[0]=t[1]=0,tot=1;
	for(int i=1;i<=m*2;i++) if(w[i]!=w[i-1]) t[++tot]=w[i];
	for(int i=1;i<=tot;i++) ve[i].clear();
	for(int i=1;i<=m;i++){
		int c=lb(t+1,t+1+tot,x[i])-t;
		ve[c].pb({x[i]-y[i]+1,v[i]});
	}
	modify(1,1,tot,1,0);
	for(int i=1;i<=tot;i++) pos[i]=lb(t+1,t+1+tot,t[i]-k)-t;
	for(int i=2;i<=tot;i++){
		modify(1,1,tot,i,ask(1,1,tot,pos[i-1],i-1));
		add(1,1,tot,pos[i],i-1,-1ll*d*(t[i]-t[i-1]));
		for(auto p:ve[i]){
			int r=lb(t+1,t+1+tot,p.fi)-t-1;
			if(pos[i]<=r) add(1,1,tot,pos[i],r,p.se);
		}
	}
	int l=lb(t+1,t+1+tot,t[tot]-k)-t;
	cout<<ask(1,1,tot,l,tot)<<endl;
}
signed main(){
	signed c,T=1;
	c=read(),T=read();
	while(T--) solve();
	return 0;
}
```

---

## 作者：Diaоsi (赞：1)

[[NOIP2023] 天天爱打卡](https://www.luogu.com.cn/problem/P9871)

线段树优化 $\mathtt{dp}$ 

弱化版的题目：[CF115E Linear Kingdom Races](https://www.luogu.com.cn/problem/CF115E)

先不考虑 $k$ 的限制，设 $f_i$ 表示跑到第 $i$ 天时能量的最高值是多少，$c(l,r)$ 表示跑完 $l\sim r$ 天获得的能量值，$w(l,r)$ 表示跑完 $l\sim r$ 天花费的能量值，有如下转移：

$$f_i\leftarrow\max\left(f_{i-1},\max_{j=0}^{i-1}\big\{f_j+c(j+1,i)-w(j+1,i)\big\}\right)$$

若 $f_i\leftarrow f_{i-1}$ 则表示第 $i$ 天不跑步。令 $s_j=f_j+c(j+1,i)-w(j+1,i)$，考虑用线段树去维护 $s_j$，从 $i-1$ 转移 $i$ 时我们需要更新前面所有 $s_j$ 的状态。

首先将 $s_j\ (0 \leq j< i)$ 全部减去 $d$，因为从第 $i-1$ 天跑到第 $i$ 天需要花费 $d$ 的能量值。

然后找到以 $i$ 为右端点的所有区间（也就是题目中的挑战），假设其对应的左端点为 $l$，然后将 $s_j\ (0 \leq j< l)$ 全部加上 $v$。因为若从这些点转移，则会完成当前挑战而获得 $v$ 的能量值。

上述两个操作可以用线段树的区间加法实现，转移的时候只需要查询 $[0,i-1]$ 的最大值即可，最后需要更新 $s_i\ (s_i\leftarrow f_i)$。 



------------


接下来考虑 $k$ 的限制，首先有一个 naive 的想法，就是把直接最后查询的区间改成 $[i-k,i-1]$。

但这个做法是**错误的**，注意到一种情况，两个区间 $p,q$ 紧贴在一起（也就是 $r_p+1=l_q$，后文简称为贴边），$q$ 区间长度小于 $k$ 且两个区间长度之和大于 $k$ 时，$r_q$ 对应的 $f_i$ 可能从 $r_p$ 对应的 $f_j$ 转移而来，导致两个区间都跑了，从而使答案变大。

不难发现，只有上述的这种情况会导致答案变大，于是我们考虑单独处理一下上面的这种情况。

对于一个 $i$ ，要找到和以 $i$ 为右端点的区间的左端点贴边的所有区间非常困难，并且这样非常难转移。正难则反，直接考虑以 $i$ 为右端点的区间会不会和其他区间左贴边，也就是考虑 $i+1$ 是否是任意一个区间的左端点。

若 $i+1$ 是任意区间的左端点，则最后更新 $s_i$ 时直接将其赋值为 $f_{i-1}$，也就是说这个点的 $f_i$ 直接由 $f_{i-1}$ 转移而来，这样在后续的转移中若要从 $i$ 转移，则一定对应的是第 $i$ 天没跑的状态。

那要是两个贴边的区间之和小于 $k$ 怎么办呢？这时候 $l_{p}-1$ **一定**还落在区间 $[i-k,i-1]$ 内，也就是说此时两个区间都跑的情况是能够从 $l_p-1$ 对应的 $f$ 值转移的。

我们就得到了一个 $\mathcal{O}(n\log n)$ 的做法，需要继续优化。



------------



注意到 $m$ 非常小，而在上述讨论中我们发现转移只需要用到 $r$ 和 $l-1$，所以我们只需要把每个区间对应的 $r$ 和 $l-1$ 离散化一下丢到线段树上就行。

但是新的问题来了，上面的 $\mathtt{dp}$ 中我们的 $d$ 是逐天逐天减的，也就是每经过一天就将前面的 $s_j$ 全部减去 $d$，但是离散化之后可能一次就跳了很多天，而要在一个维护区间信息的线段树上实现区间加等差数列貌似比较困难，我们需要别的方法去维护 $d$。

还是考虑正难则反，对于位置 $i$ 我们发现当 $n$ 天都转移完后，$s_i$ 被减了 $n-i$ 次 $d$，而转移到 $i+k$ 时 $s_i$ 被减了 $(n-i)-(n-i-k)$ 次 $d$ 。

对于初始时所有的 $s_j$ 都减去 $d\cdot(n-j)$，转移到 $i$ 时只修改挑战区间带来的贡献，查询最大值时将得到的答案直接加上 $d\cdot(n-i)$ 进行转移即可。

时间复杂度 $\mathcal{O}(m\log m)$。

由于本题严重卡常，故此处只贴部分代码，建议使用较为精细的实现方式，**不要开** ```std::unordered_map```。

[完整代码](https://www.luogu.com.cn/paste/6lj66ay8)


```Code:```
```cpp
int c,t,n,m,k,d,tot,cnt,s[N],pre[N];
ll ans;
vector<pair<int,int> > h[N];
gp_hash_table<int,int> ls,rs;
struct SegmentTree{
	int l,r;
	ll dat,tag;
	#define l(x) tre[x].l
	#define r(x) tre[x].r
	#define dat(x) tre[x].dat
	#define tag(x) tre[x].tag
}tre[N<<2];
inline void pushup(int x){
	dat(x)=max(dat(x<<1),dat(x<<1|1))+tag(x);
}
inline void build(int x,int l,int r){
	l(x)=l;r(x)=r;
	dat(x)=-INFF;tag(x)=0;
	if(l==r){pre[l]=x;dat(x)=-1ll*d*(n-s[l]);return;}
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	pushup(x);
}
inline void insert(int pos,ll val){
	int x=pre[pos];dat(x)+=val;
	while(x>1){x>>=1;pushup(x);}
}
inline void change(int x,int L,int R,ll val){
	int l=l(x),r=r(x);
	if(L<=l&&r<=R){
		dat(x)+=val;tag(x)+=val;
		return;
	}
	int mid=(l+r)>>1;
	if(L<=mid)change(x<<1,L,R,val);
	if(R>mid)change(x<<1|1,L,R,val);
	pushup(x);
}
inline ll query(int x,int L,int R){
	int l=l(x),r=r(x);
	if(L<=l&&r<=R)return dat(x);
	int mid=(l+r)>>1;ll val=-INFF;
	if(L<=mid)val=max(val,query(x<<1,L,R));
	if(R>mid)val=max(val,query(x<<1|1,L,R));
	return val+tag(x);
}
inline void add(int x){
	if(x<=0)return;
	if(!rs[x])s[++tot]=x,rs[x]=tot;
}
int main(){
	qio>>c>>t;
	while(t--){
		ans=cnt=tot=0;
		ls.clear();rs.clear();
		qio>>n>>m>>k>>d;
		for(int i=1;i<=m;i++){
			int x,y,v;
			qio>>x>>y>>v;
			if(y<=k){
				ls[x-y+1]=1;
				add(x);add(x-y);
				h[rs[x]].push_back(make_pair(x-y+1,v));
			}
		}
		sort(s+1,s+tot+1);
		build(1,0,tot);
		int ql=0;
		for(int i=1;i<=tot;i++){
			ll r=s[i],lst=ans;
			for(pair<int,int> z:h[rs[r]])
				change(1,0,lower_bound(s,s+tot+1,z.fi-1)-s,z.se);
			while(ql<=tot&&s[ql]<r-k)ql++;
			ans=max(ans,query(1,ql,i-1)+1ll*d*(n-r));
			insert(i,ls[r+1]?lst:ans);
		}
		qio<<ans<<'\n';
		for(int i=1;i<=tot;i++)h[i].clear();
	}
	return 0;
}
```


---


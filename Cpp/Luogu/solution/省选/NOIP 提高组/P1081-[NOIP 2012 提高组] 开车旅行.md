# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# 题解

## 作者：yangrunze (赞：137)

为了通过[提高试炼场](https://www.luogu.com.cn/paste/c6a97wup)的倍增关，被迫做紫题/kel……（[yrz菜菜……](https://www.luogu.com.cn/paste/jsj7y3zb)）

（特别鸣谢：本题解由《算法竞赛进阶指南》赞助播出，《算法竞赛进阶指南》，一本你值得拥有的算法好书！）

刚才一不小心把这个题的方法暴露了呢……没错，这个题的main idea就是：**倍增**！

倍增，字面意思就是“**成倍增长**”，也许你听说过在国际象棋棋盘上摆放麦粒的故事，体验了指数函数爆炸级别的恐怖，也在[快速幂](https://www.luogu.com.cn/problem/P1226)，[ST表](https://www.luogu.com.cn/problem/P3865)和[最近公共祖先LCA](https://www.luogu.com.cn/problem/P3379)中领略到这些高效的算法的神奇

没错，上面的东西都是倍增思想的具体体现

那这个题到底是怎么跟倍增的技巧扯上关系的呢？？？别急，咱们一步一步来，从分析题目开始！

------------
## Part I
>记城市 $i$ 的海拔高度为$h_i$
 ，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$
  恰好是**这两个城市海拔高度之差的绝对值**，即 $d_{i,j}=|h_i-h_j|$。
  
>小 $\text{B}$ 总是**沿着前进方向**选择一个**最近的城市**作为目的地，而小 $\text{A}$ 总是**沿着前进方向**选择**第二近的城市**作为目的地 。

看来，**小$\text{A}$和小$\text{B}$下次到达的城市**是非常重要的，赶紧把它预处理出来！

也就是说，我们要预处理出在城市$i$的时候，**小$\text{A}$要走的城市$ga_i$**和**小$\text{B}$要走的城市$gb_i$**

$gb_i$就是要找一个$j(i<j\le n)$，使得$|h_i-h_j|$最小，而$ga_i$就是使得$|h_i-h_j|$次小

那怎么预处理呢？？？不难想到，$gb_i$就是**离当前的$i$的高度最接近的城市**，我们先给每个城市按高度排个序，这样的话，排序之后**要求的$gb_i$就是$i-1$和$i+1$中，和$i$的高度差更小的那个**

而$ga_i$就同理啦，根据刚才的思路，$ga_i$肯定是$i-1,i-2,i+1,i+2$其中之一，这四个里面肯定有一个是$gb_i$，再从剩下三个里面找个小的就是$ga_i$了

怎么找的问题解决了，但还有一个重要的事情没考虑——每次必须去往**前进方向**的城市，这该怎么办呢？

咱们先从城市$1$来考虑，毕竟从城市$1$出发，哪个城市都能到嘛！找到排序后城市$1$的位置，然后按照刚才说的比较大小，就可以找到$gb_1$和$ga_1$

那$i=2$的时候呢？

$i=2$时，除了城市$1$是不能走的，其它都能畅通无阻，那要不……我们在处理完$i=1$的情况后把城市$1$删掉？问题不就解决了？

完全没有问题！我们就用这种**弄完一个删一个**的方式，这样就可以保证当前要考虑的城市里只有前进方向的城市，因为当一个城市处理过去之后，它就再也不能到达了

那这波操作具体怎么实现呢？既然**要资瓷频繁的删除操作**，开动脑筋想一想，用**双向链表**是更好不过了（没学过双向链表的同学们可以去 [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)）

接下来，让我们开始愉快地写代码吧！虽然双向链表的实现还是挺基础的，但是**要注意的细节和坑还是挺多的**（要不然我为啥光双向链表就调了一晚上），尤其是要注意**判定当前元素的前驱和后继不存在的情况**

```cpp
struct qwq{//存储城市的结构体
	int hi,id;//hi为城市的海拔高度，id为城市的序号
	int pre,nxt;//pre和next是链表的象征！
}h[100005];
bool cmp(qwq x,qwq y){//排序用的cmp函数
	return x.hi<y.hi;//按高度从小到大排
}
int pos[100005],ga[100005],gb[100005];//pos为城市排序后所在的位置，ga和gb就是我们要求的东西
```
```cpp
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&h[i].hi);//输入就不用说了吧
		h[i].id=i;//城市的编号
	}
	sort(h+1,h+1+n,cmp);//排个序
	for(int i=1;i<=n;i++){
		pos[h[i].id]=i;//把pos数组整出来
		h[i].pre=i-1;//用链表把城市串一串
		h[i].nxt=i+1;
	}
	h[1].pre=h[n].nxt=0;//把头部的前驱和尾部的后继（边界部分）搞成0
	for(int i=1;i<n;i++){
		int p=pos[i],p1=h[p].pre,p2=h[p].nxt;  //把当前的城市以及它的前驱和后继都找出来，方便后续操作                                
		if(p1&&(h[p].hi-h[p1].hi<=h[p2].hi-h[p].hi||!p2))//如果当前城市i到p1的距离比到p2的小，或者干脆没有p2只能选p1（选择p1必须保证p1是存在的，切记注意）      
		gb[i]=h[p1].id,ga[i]=choose(h[p1].pre,p2,p);//那gb就当然选p1啦，ga的话就从那两个里面选（怎么选马上就讲）
		else gb[i]=h[p2].id,ga[i]=choose(p1,h[p2].nxt,p);//否则呢，就反过来，gb选p2，ga从p1和p2的后继中选	
		del(p);//弄完了就把它删掉，反正以后都到不了了
	}
```

  ```cpp
int choose(int a,int b,int i){//当前城市为i，从a与b中选择一个更优的
	if(!a)return h[b].id;//如果其中一个城市没有，那就只能被迫选另一个了
	if(!b)return h[a].id;//俺也一样，注意返回的是id
	if(h[i].hi-h[a].hi<=h[b].hi-h[i].hi)//如果城市i与a的高度差比i与b的小
	return h[a].id;//那就选a咯
	else return h[b].id;//要不就是b
}
void del(int pos){//双向链表基本操作——删除链表中的元素
	if(h[pos].nxt)h[h[pos].nxt].pre=h[pos].pre;//连这个都不会的话可以去双向链表入门题回炉重造了
	if(h[pos].pre)h[h[pos].pre].nxt=h[pos].nxt;//如果实在理解不了的话可以画个图，还是很好理解的
}
```
（话说这一步的实现用STL大法中的**set+迭代器**也珂以实现，（~~据说你甚至可以手写平衡树~~），由于本人写set迭代器屡屡出锅，这里就不给大家展示了）

------------
## Part II
对题目分析的第一步完美结束，我们接着来看：
>1、 对于一个给定的 $x=x_0$	
 ，**从哪一个城市出发**，**小 $\text{A}$ 开车行驶的路程总数**与**小 $ \text{B}$ 行驶的路程总数**的比值最小

>2、对任意给定的 $x=x_i$
  和**出发城市 $s_i$** 
 ，**小 $\text{A}$ 开车行驶的路程总数**以及**小 $\text {B}$ 行驶的路程总数**。
 
我们发现，题目中要求的东西跟**到达的城市**，**小 $\text{A}$ 走的路程**和**小 $\text{B}$ 走的路程**

那怎么搞到这些信息呢？我们只需要知道**出发的城市**和**行驶的天数**，哦对了，还有**轮到谁开车**

那我们就一天一天的开，去模拟开车过程？

别忘了数据范围辣么大，他俩有时候开上十天半个月也开不完，怎么办呢？

反手一个**倍增**，闷声发大财！

为啥用倍增就可以呢？因为通过倍增枚举，是将每次把一个数变成它相应的两倍，也就是说：

$\boxed{\begin{aligned}\text{普通的枚举：}1,2,3,4,5,6,7,8,9,10\cdots \qquad\qquad\qquad\ \ \\
\text{用倍增枚举：}1,2,4,8,16,32,64,128,256,512,1024\cdots\end{aligned}}$

这简直快的不是一点半点啊！

领教到倍增的威力之后，我们来看看接下来怎么做，根据刚才说的，我们是**通过已知条件推出新的状态**，也就是说，这是一个**dp**，或者说是**递推**的过程

>**动态规划**需要考虑三件事：**数组**、**方程**、**初始化**
				
> ——  $\text{v\color{red}ectorwyx}$

首先是考虑**状态定义**的问题，根据刚才推出的关键信息，我们分别要定义三个数组——$f$表示走到的城市，$da$表示小$A$走过的距离，$db$表示小$\text{B}$走过的距离

并且，决定这三者的因素在前面也说过了，我们就用$f_{i,j,k}$表示开车$2^i$天（说好的倍增呐），从城市$j$出发到达的城市，$k=0$表示轮到小$\text{A}$先开车，$k=1$表示轮到小$\text{B}$先开车

同样，$da_{i,j,k}$和$db_{i,j,k}$也是这么定义的！

接下来，咱们来考虑**初始化**的问题：

- 对于$f$数组：

$$f_{0,j,0}=ga_j$$

$$f_{0,j,1}=gb_j$$

（很好理解，$2^0$是$1$，开一天之后到达的就是我们刚才预处理出的$ga$和$gb$）

- 对于$da$数组：

$$da_{0,j,0}=|h_j-h_{ga_j}|$$
（第一次会走到$ga_j$，路程就是它俩的距离）
$$da_{0,j,1}=0$$
（小$\text{B}$压根啥也没走）

- 对于$db$数组：
$$db_{0,j,0}=0$$
$$db_{0,j,1}=|h_j-h_{gb_j}|$$
（和刚才$da$的思路完全一样）

我们再来考虑**状态转移方程**：

其实倍增的状态转移还是比较套路的，无非就是**对“前一半”和“后一半”进行处理**

当然这里还有一个坑点：**特判 $i=1$ 的情况**

为啥呢？咱以$f$数组为例分析一下分析一下

当$i=1$时，$2^i=2$，所以我们要分析前$1$天和后$1$天的情况，这两天是由不同的人开，所以：

$$f_{i,j,k}=f_{i-1,(f_{i-1,j,k}),k \mathrm{xor} 1}(i=1)$$

（$\mathrm{xor}$就是异或啦，用来把$k$变成相反的）

当$i>1$时，$2^{i-1}$是个偶数，所以**前后两段是同一个人开车**，因此：

$$f_{i,j,k}=f_{i-1,(f_{i-1,j,k}),k}(i>1)$$

这样我们就把$f$数组的转移写完了，$da$和$db$可以如法炮制：**行驶的总路程=前半段走的路程+后半段走的路程**

$$da_{i,j,k}=\begin{cases}da_{i-1,j,k}+da_{i-1,({f_{i-1,j-1,k}),k \mathrm{xor} 1}}(i=1)\\da_{i-1,j,k}+da_{i-1,({f_{i-1,j-1,k}),k }}(i>1)\end{cases}$$

$$db_{i,j,k}=\begin{cases}db_{i-1,j,k}+db_{i-1,({f_{i-1,j-1,k}),k \mathrm{xor} 1}}(i=1)\\db_{i-1,j,k}+db_{i-1,({f_{i-1,j-1,k}),k }}(i>1)\end{cases}$$

我们发现，$i=1$的时候，除了$k$要取相反，其它压根没啥区别，所以写代码的时候，特判$i=1$时取反，其它照写就行啦！

```cpp
	int f[25][100005][2];
	long long da[25][100005][2],db[25][100005][2];//十年OI一场空，不开long long见祖宗！
    for(int i=1;i<=n;i++){
		if(ga[i]){//预处理的时候一定要注意只有这个东西存在的时候才能预处理
			f[0][i][0]=ga[i];
			da[0][i][0]=abs(h[pos[i]].hi-h[pos[ga[i]]].hi);//注意我们在前面已经将h数组排好了序，所以别忘了取pos
			db[0][i][0]=0;	
		}
		if(gb[i]){//另一边的初始化对称过来即可
			f[0][i][1]=gb[i];
			da[0][i][1]=0;
			db[0][i][1]=abs(h[pos[i]].hi-h[pos[gb[i]]].hi);
		}	
	}
	t=(int)(log(1.0*n)/log(2)+1);//倍增时只需要枚举到log2n就可以，所以要先把它算出来，用的是对数的换底公式：logab=logcb/logca
	for(int i=1;i<=t;i++){//循环顺序很重要！一定要先枚举天数，再枚举城市，这样才能保证后面要用的东西前面已经推出来了
		for(int j=1;j<=n;j++){
			for(int k=0;k<=1;k++){
				int l=(i==1)?k^1:k;//当k=1时，别忘了取相反
				if(f[i-1][j][k])f[i][j][k]=f[i-1][f[i-1][j][k]][l];//递推f数组
				if(f[i][j][k]){//别忘了必须保证存在
					da[i][j][k]=da[i-1][j][k]+da[i-1][f[i-1][j][k]][l];//按照刚才推出的转移方程递推
					db[i][j][k]=db[i-1][j][k]+db[i-1][f[i-1][j][k]][l];
				}
			}
		}
	}
```


------------
## Part III

该推的都推完啦，我们接下来要考虑的，就是如何用我们推出的东西，得到最终的答案

也就是说，我们的首要任务就是计算出$calc(s,x)$，也就是从城市$s$出发，最多走$x$的距离，小$\text{A}$和小$\text{B}$能走的距离$la$和$lb$

那咋办呢？我们可以借鉴倍增求LCA的思路：**从大到小往上跳**

也就是说：我们**按照$i$从大到小枚举**，如果**走完$2^i$天，总路程还是不超过$x$呢**，那就**走过去，更新$la$和$lb$的答案**

没错，就这么简单，我们来把代码写出来！
```cpp
long long da[25][100005][2],db[25][100005][2],la,lb;//再次提醒：十年OI一场空，不开long long见祖宗！
void calc(int s,long long x){
	la=lb=0;//不要忘了初始化哦！
	int k=0;//k依然表示谁先开车
	for(int i=t;i>=0;i--){//从大往小枚举，看看能不能跳
		if(f[i][s][k]&&da[i][s][k]+db[i][s][k]<=x){//如果当前城市存在，并且走完这些天还是超不过x
			x-=da[i][s][k]+db[i][s][k];//剩余路程减去走了的路程
			la+=da[i][s][k],lb+=db[i][s][k];//把新走的路程加到统计的答案里去
			if(!i)k^=1;//别忘了i=0的时候依然要取相反
			s=f[i][s][k];//跳的终点的城市里去
		}
	}
}
```
回到题目，第一问就是要求出对于给定的$x$，从哪个$s$出发，$la$和$lb$的比值最小，而第二问呢，实际上就是让你计算$calc(s,x)$时$la$和$lb$的值

```cpp
	long long x;
	int s;
	scanf("%lld",&x);//第一问：找到一个s使la:lb最小
	int p=0;//p代表最后找到的城市s
	long long ansa=1,ansb=0;//ansa和ansb是找到的比值最小的la和lb
	for(int i=1;i<=n;i++){//枚举每个城市
		calc(i,x);//计算出小A和小B的路程
		if(!lb)la=1;//题目要求：如果lb为0，那就变成1
		if(la*ansb<lb*ansa||(la*ansb==lb*ansa&&h[pos[i]].hi>h[pos[p]].hi))//由于比例的分数算除法会产生玄学的精度问题，所以我们把它换成乘积的形式，除此以外，比值相等时选择高度较高的一个
		ansa=la,ansb=lb,p=i;//更新答案
	} 
	printf("%d\n",p);//找到答案输出
	int m;
	scanf("%d",&m);
	while(m--){
		scanf("%d%lld",&s,&x);
		calc(s,x);//直接计算calc(s,x)就行
		printf("%lld %lld\n",la,lb);
	}
	return 0;
```


------------
## Part IV

上完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
struct qwq{//存储城市的结构体以及cmp
	int hi,id,pre,nxt;
}h[100005];
bool cmp(qwq x,qwq y){
	return x.hi<y.hi;
}
int choose(int a,int b,int i){//选择更优解
	if(!a)return h[b].id;
	if(!b)return h[a].id;
	if(h[i].hi-h[a].hi<=h[b].hi-h[i].hi)
	return h[a].id;
	else return h[b].id;
}
void del(int pos){//删除链表元素
	if(h[pos].nxt)h[h[pos].nxt].pre=h[pos].pre;
	if(h[pos].pre)h[h[pos].pre].nxt=h[pos].nxt;
}
int n,t;
int pos[100005],ga[100005],gb[100005];//一堆变量
int f[25][100005][2];
long long da[25][100005][2],db[25][100005][2],la,lb;
void calc(int s,long long x){//calc函数
	la=lb=0;
	int k=0;
	for(int i=t;i>=0;i--){
		if(f[i][s][k]&&da[i][s][k]+db[i][s][k]<=x){
			x-=da[i][s][k]+db[i][s][k];
			la+=da[i][s][k],lb+=db[i][s][k];
			if(!i)k^=1;
			s=f[i][s][k];
		}
	}
}
int main(){
//Part I——预处理ga和gb                                                   
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&h[i].hi);
		h[i].id=i;
	}
	sort(h+1,h+1+n,cmp);
	for(int i=1;i<=n;i++){
		pos[h[i].id]=i;
		h[i].pre=i-1;
		h[i].nxt=i+1;
	}
	h[1].pre=h[n].nxt=0;
	for(int i=1;i<n;i++){
		int p=pos[i],p1=h[p].pre,p2=h[p].nxt;                                  
		if(p1&&(h[p].hi-h[p1].hi<=h[p2].hi-h[p].hi||!p2))      
		gb[i]=h[p1].id,ga[i]=choose(h[p1].pre,p2,p);
		else gb[i]=h[p2].id,ga[i]=choose(p1,h[p2].nxt,p);	
		del(p);
	}
//Part II——用倍增推出f,da,db                                                         
	for(int i=1;i<=n;i++){
		if(ga[i]){
			f[0][i][0]=ga[i];
			da[0][i][0]=abs(h[pos[i]].hi-h[pos[ga[i]]].hi);
			db[0][i][0]=0;	
		}
		if(gb[i]){
			f[0][i][1]=gb[i];
			da[0][i][1]=0;
			db[0][i][1]=abs(h[pos[i]].hi-h[pos[gb[i]]].hi);
		}	
	}
	t=(int)(log(1.0*n)/log(2)+1);
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			for(int k=0;k<=1;k++){
				int l=(i==1)?k^1:k;
				if(f[i-1][j][k])f[i][j][k]=f[i-1][f[i-1][j][k]][l];
				if(f[i][j][k]){
					da[i][j][k]=da[i-1][j][k]+da[i-1][f[i-1][j][k]][l];
					db[i][j][k]=db[i-1][j][k]+db[i-1][f[i-1][j][k]][l];
				}
			}
		}
	}
// Part III——计算calc得到答案                                  
	long long x;
	int s;
	scanf("%lld",&x);
	int p=0;
	long long ansa=1,ansb=0;
	for(int i=1;i<=n;i++){
		calc(i,x);
		if(!lb)la=1;
		if(la*ansb<lb*ansa||(la*ansb==lb*ansa&&h[pos[i]].hi>h[pos[p]].hi))
		ansa=la,ansb=lb,p=i;
	} 
	printf("%d\n",p);
	int m;
	scanf("%d",&m);
	while(m--){
		scanf("%d%lld",&s,&x);
		calc(s,x);
		printf("%lld %lld\n",la,lb);
	}
	return 0;
}
```
$\color{#4275f5}{\text{yrz 是小珂愛！！！}}$

---

## 作者：shadow__ (赞：77)

###这个题和楼下大佬们所说的一样，难点就在初始化。

首先要把距离每个点的最小点和次小点找出。

然后对于跑图我们用倍增处理一下即可。

同样的A[i][j]记得是A走2^j轮之后的距离。（B一样）

f[i][j]记得是从i走2^j个两步之后点（重点）


#预处理出最小点和次小点。

这个题其实我一开始想的是暴力求点，然后没看到数据范围（滑稽），后来有大佬告诉我这样的时间复杂度时O（n^2），我就放弃了。

我们用双向链表。

先不管方向，将所有城市排序之后，它的最小和次小点一定在i-1,i-2,i+1,i+2的位置，所以说如果排序我们的处理会方便很多。

##关于方向

首先我们记下每个城市排序之后的位置。

然后从第一个城市开始向i-1,i-2,i+1,i+2处找点。

很显然，由于是第一个点，这个时候找到的任何点一定在它东边。

###同样的，找完第一个点后将第一个点删除，那么第二个点自然成为了第一个点，同理。

这样我们便在O（n）的复杂度内完成了预处理。

#倍增的初始化要注意的的地方。

对于f，记得一定是2^j个两步之后所到达的点，与A,B谁开车无关。

对于B，由于开始一定是A先跑，所以我们要用次小点的最小点之间的距离初始化。

具体倍增思路与楼下差不多，这里我就只贴出初始化的代码。

#最小点与次小点

```cpp
inline void prepare(int u,int i){//u记得是排序后的位置，i为排序前的位置
    if(pre[u])min1[i]=H[pre[u]].p;
    if((nxt[u]&&H[u].h-H[pre[u]].h>H[nxt[u]].h-H[u].h)||!pre[u])min1[i]=H[nxt[u]].p;
    if(min1[i] == H[pre[u]].p){
        if(pre[pre[u]])min2[i]=H[pre[pre[u]]].p;
        if((nxt[u]&&H[u].h-H[pre[pre[u]]].h>H[nxt[u]].h-H[u].h)||!pre[pre[u]])min2[i]=H[nxt[u]].p;
    }
    else {
        if(pre[u])min2[i]=H[pre[u]].p;
        if((nxt[nxt[u]]&&H[u].h-H[pre[u]].h>H[nxt[nxt[u]]].h-H[u].h)||!pre[u])min2[i]=H[nxt[nxt[u]]].p;
    }
    nxt[pre[u]]=nxt[u];
    pre[nxt[u]]=pre[u];
}
```
#倍增初始化

```cpp
void Init(){
    for(int i=1;i<=N;i++){
        if(min2[i])A[i][0]=abs(data[min2[i]]-data[i]);
        if(min1[i])B[i][0]=abs(data[min2[i]]-data[min1[min2[i]]]);//走一轮B是从次近点向次近点的最近点走 
        f[i][0]=min1[min2[i]];
    }
}
```

---

## 作者：star_fish (赞：5)

[原题链接](https://www.luogu.com.cn/problem/P1081)
##### 第一道不看题解写出来的紫题。写篇题解纪念一下。

25.1.23 update：优化重写了建链表部分的代码。

### 大致思路：

先考虑模拟。对于每一个城市，我们可以预先处理出每一个城市向东的最近与次近点，建成一个链表。
然后对于每次询问进行递归模拟，最后输出小 A 和小 B 行驶的路程。

### 代码实现一

先实现链表部分。

注：这部分中双指针的做法有点问题，已在后文优化。

暴力查找必定超时，我们可以先对 $h$ 数组进行从小到大排序，对于每一个城市 $x$，使用双指针找出绝对值小于 $x$ 的最近与次近城市、绝对值大于 $x$ 的最近、次近城市。由于旅行方向向东，排序之后满足条件的城市应为数组中 $x$ 左、右边序号小于 $x$ 序号的城市。题面中提到对于距离相同的城市，我们应该将高度较小的当做更近的，因此我们可以按照高度顺序调用更新函数，以满足条件。

对于第一问，我们对每一个起点进行一次模拟并更新答案，最终输出最大值对应的城市。注意转 double 并且比值相同取 $h$ 值小的。

对于第二问，我们同样对每一个问题进行模拟，输出两个答案。

这样就可以在洛谷上获得 80pts。听说可以直接跑过当年的数据而且比标程还快。

贴出我的代码，附注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 100100
const int inf=1e17;
const double eps=1e-12;
int n,m,h[N],x[N],s[N],id[N],pos[N],to[N][2],f[N][2],ans[2],maxn,maxi;
double d=inf;
//to数组记录i后的最小值与次小值 以及前往的城市编号 
bool cmp(int x,int y){ return h[x]<h[y];}
void update(int i,int x){//更新最小值与次小值 
	if(x==0||x==n+1||x<=i) return ;
	int w=abs(h[x]-h[i]);//0为最小值,即为B要去的城市 
	if(w<=f[i][0])
		f[i][1]=f[i][0],f[i][0]=w,
		to[i][1]=to[i][0],to[i][0]=x;
	else if(w<=f[i][1]) f[i][1]=w,to[i][1]=x;	
		
}
void init(){
	for(int s=1;s<=n;s++){//初始化处理,建立 
		int l=pos[s],r=pos[s],R,L;
		while(l&&id[l]<=s) l--; 
		while(r<=n&&id[r]<=s) r++;   
		R=r,L=l;
		if(l){l--;while(l&&id[l]<=s) l--;}
		if(r<=n){r++;while(r<=n&&id[r]<=s) r++;}
		if(r!=R)update(s,id[r]);
		update(s,id[R]),update(s,id[L]);
		if(l!=L) update(s,id[l]);
	}
}
void check(int s,int fl,int sum){//进行模拟 
	if(!to[s][fl]||sum+f[s][fl]>maxn) return ;
	ans[fl]+=f[s][fl];
	check(to[s][fl],1-fl,sum+f[s][fl]);
	return ;
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;h[0]=-inf;
	for(int i=1;i<=n;i++) 
		cin>>h[i],id[i]=i,
		f[i][0]=f[i][1]=inf,
		to[i][0]=to[i][1]=0;
	sort(id+1,id+1+n,cmp);
	for(int i=1;i<=n;i++) pos[id[i]]=i;
	init();
	cin>>maxn>>m;
	for(int i=1;i<=n;i++){
		ans[0]=ans[1]=0;
		check(i,1,0);
		if(!ans[0]&&!ans[1]) continue;
		double dd;
		if(ans[0]==0) dd=inf;
		else dd=(double)ans[1]/(double)ans[0];
		if(!maxi||dd<d) d=dd,maxi=i;
		else if(abs(dd-d)<eps&&h[i]>h[maxi]) maxi=i;
	}
	cout<<maxi<<'\n';
	for(int i=1;i<=m;i++){
		cin>>s[i]>>maxn;
		ans[0]=ans[1]=0;
		check(s[i],1,0);
		cout<<ans[1]<<' '<<ans[0]<<'\n';
	}
	return 0;
}
```

### 代码实现二 （倍增优化）

接下来我们在原来的代码上用倍增加快模拟的过程。

在 $to$ 数组中，我们使用 $to_{i,0}$ 记录 $i$ 城市的次近点，即小 A 走一步要去的点；用 $to_{i,1}$ 记录城市的**次近点的最近点**（与上面的代码不同）。这么做的意义是将两步捆做一步，以便于后面的倍增数组更新。$f$ 数组也是同理。与此同时，我们也要用一个额外的 $fA$ 数组来记录总路程中小 A 走的路程，以得到答案。

这里贴出倍增代码与修改后的初始化代码。当然你也可以按照上面的思路重新写一份。

```cpp
for(int i=1;i<=n;i++)
	swap(to[i][1],to[i][0]),swap(f[i][1],f[i][0]);
	//此时用to[i][0]表示次近，用to[i][1]表示最近 
for(int i=1,j;i<=n;i++){
	//在这之后，我们要用to[i][1]表示走两步 
	//即为先走一个次近,再走一个最近 
	j=to[i][0];//次近 
	f[i][1]=f[i][0]+f[j][1];
	to[i][1]=to[j][1];
	fA[i][0]=f[i][0],fA[i][1]=f[i][0];
}
for(int k=2;k<=30;k++){
	for(int i=1;i<=n;i++){
		int j=to[i][k-1];
		if(!j) continue;
		to[i][k]=to[j][k-1];
		f[i][k]=f[i][k-1]+f[j][k-1];
		fA[i][k]=fA[i][k-1]+fA[j][k-1];
	}
}
```

```cpp
void check(int s){
	sum=0,suma=0;
	for(int k=30;k>=0;k--)
		if(to[s][k]&&sum+f[s][k]<=maxn) 
			sum+=f[s][k],suma+=fA[s][k],s=to[s][k];
	return ;
}
```
### DLC 链表部分的优化

其实写题解的时候总是有两个点差100ms，本来以为是常数问题，卡了半天不得不承认是自己链表部分复杂度假了。因此在期末考后重新添加了后半部分题解。

在之前的链表实现中，我们通过双指针来向前和向后找下一个前往的节点。这个过程中需要在数组的左边和右边分别找两个满足条件（即编号小于 $i$ ）的节点，可以用大根堆优化。

以找右端点为例，在遍历排序后的 $id$ 数组时，我们用两个小根堆已经遍历过的节点，第一个小根堆记录“还没有找到第一个右端点”的节点，第二个小根堆记录“还没有找到第二个右端点”的节点。遍历到编号为 $i$ 的节点时，通过弹出并更新堆中编号比 $i$ 小的节点建立链表。

为了省脑子我这里等找完后再更新。

优化后的链表代码：
```cpp
priority_queue<int> q,q1,p,p1;
//枚举到一个数时,将更新前面所有编号比i小的节点的右边端点 
for(int i=1;i<=n;i++){
	while(!p1.empty()&&-p1.top()<id[i]) R[-p1.top()]=id[i],p1.pop();
	while(!p.empty()&&-p.top()<id[i]) r[-p.top()]=id[i],p1.push(p.top()),p.pop();
	p.push(-id[i]);
}
//枚举到一个数时,将更新后面所有编号比i小的节点的左边端点 
for(int i=n;i>=1;i--){
	while(!q1.empty()&&-q1.top()<id[i]) L[-q1.top()]=id[i],q1.pop();
	while(!q.empty()&&-q.top()<id[i]) l[-q.top()]=id[i],q1.push(q.top()),q.pop();
	q.push(-id[i]);
}
for(int i=1;i<=n;i++){
	update(i,R[i]),update(i,r[i]);
	update(i,l[i]),update(i,L[i]);
}
```


------------

### AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 100100
const int inf=1e18;
const double eps=1e-12;
int n,m,h[N],x[N],s[N],id[N],pos[N],to[N][40],f[N][40],fA[N][40],ans[2],maxn,maxi;
int sum,suma;
double d=inf;
bool cmp(int x,int y){ return h[x]<h[y];}
void update(int i,int x){//更新最小值与次小值 
	if(x==0) return ;
	int w=abs(h[x]-h[i]);//0为最小值,即为B要去的城市,走1<<0步 
	if(w<=f[i][0])// ,走1<<1步 
		f[i][1]=f[i][0],f[i][0]=w,
		to[i][1]=to[i][0],to[i][0]=x;
	else if(w<=f[i][1]) f[i][1]=w,to[i][1]=x;	
	
}
int R[N],L[N],l[N],r[N];
priority_queue<int> q,q1,p,p1;
void init(){
	//枚举到一个数时,将更新前面所有编号比i小的节点的右边端点 
	for(int i=1;i<=n;i++){
		while(!p1.empty()&&-p1.top()<id[i]) R[-p1.top()]=id[i],p1.pop();
		while(!p.empty()&&-p.top()<id[i]) r[-p.top()]=id[i],p1.push(p.top()),p.pop();
		p.push(-id[i]);
	}
	//枚举到一个数时,将更新后面所有编号比i小的节点的左边端点 
	for(int i=n;i>=1;i--){
		while(!q1.empty()&&-q1.top()<id[i]) L[-q1.top()]=id[i],q1.pop();
		while(!q.empty()&&-q.top()<id[i]) l[-q.top()]=id[i],q1.push(q.top()),q.pop();
		q.push(-id[i]);
	}
	for(int i=1;i<=n;i++){
		update(i,R[i]),update(i,r[i]);
		update(i,l[i]),update(i,L[i]);
	}
	for(int i=1;i<=n;i++)
		swap(to[i][1],to[i][0]),swap(f[i][1],f[i][0]);
	for(int i=1,j;i<=n;i++){
		j=to[i][0];//次近 
		f[i][1]=f[i][0]+f[j][1];
		to[i][1]=to[j][1];
		fA[i][0]=f[i][0],fA[i][1]=f[i][0];
	}
	for(int k=2;k<=30;k++){
		for(int i=1;i<=n;i++){
			int j=to[i][k-1];
			if(!j) continue;
			to[i][k]=to[j][k-1];
			f[i][k]=f[i][k-1]+f[j][k-1];
			fA[i][k]=fA[i][k-1]+fA[j][k-1];
		}
	}
}
void check(int s){
	sum=0,suma=0;
	for(int k=30;k>=0;k--)
		if(to[s][k]&&sum+f[s][k]<=maxn) 
			sum+=f[s][k],suma+=fA[s][k],s=to[s][k];
	return ;
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	h[0]=-inf;
	for(int i=1;i<=n;i++) 
		cin>>h[i],id[i]=i,
		memset(f[i],0x3f,sizeof f[i]),
		memset(fA[i],0x3f,sizeof fA[i]);
	sort(id+1,id+1+n,cmp);
	init();
	cin>>maxn>>m;
	for(int i=1;i<=n;i++){
		check(i);
		ans[0]=sum-suma,ans[1]=suma;
		if(!ans[0]&&!ans[1]) continue;
		double dd;
		if(ans[0]==0) dd=inf;
		else dd=(double)ans[1]/(double)ans[0];
		if(!maxi||dd<d) d=dd,maxi=i;
		else if(abs(dd-d)<eps&&h[i]>h[maxi]) maxi=i;
	}
	cout<<maxi<<'\n';
	for(int i=1;i<=m;i++){
		cin>>s[i]>>maxn;
		check(s[i]);
		cout<<suma<<' '<<sum-suma<<'\n';
	}
	return 0;
}
```

---

## 作者：Shadow_Soldier (赞：3)

# 前言

本文中的对数函数默认底数为 $2$。  
2025 年 5 月 17 日，发现代码贴错了，已改正。  
2025 年 5 月 17 日，人名字体更改了。  
2025 年 5 月 18 日，时间复杂度的符号更改了。

# 题意概述
有 $n(1 \le n \le 10^5)$ 座城市，从西至东依次编号 $1,2,\cdots,n$，**海拔各不相同**，为 $h_1,h_2,\cdots,h_n(|h_i| \le 10^9)$。城市 $i$ 与城市 $j$ 的距离为 $d_{i,j} = |h_i - h_j|$。旅行中，小 A 与小 B 依次开车，第一天小 A 开车，之后每天轮换一次，一直向东行驶。小 A 总是开往前进方向上第二近的城市，小 B 总是开往前进方向上第一近的城市（如果距离相同，则认为海拔更低的城市是更近的）。当任何一人无法按自己的策略前进，或前进后的行驶总距离大于 $x$，则不继续前进，结束旅行。  
问：

1. 对于给定的 $x$，从哪个城市出发小 A 行驶的总距离与小 B 行驶的总距离的比值最小（若小 B 行驶的总距离为 $0$，则比值为无穷大；若多个比值相等，则答案为海拔最高的城市）？（共询问 $1$ 次）  
2. 对于给定的出发城市 $s$ 与 $x$，求小 A 行驶的总距离与小 B 行驶的总距离。（共询问 $m(1 \le m \le 10^5)$ 次）

想看题目点这里：[题目链接](https://www.luogu.com.cn/problem/P1081)。
# 正解思路
首先，这道题是一道静态查询的题目，解决这类问题有一个很好的方法——预处理。很显然，要想解决这道题，小 A 和小 B 的行驶策略是很重要的。我们需要知道，已知当前的城市，小 A 和小 B 行驶到的下一个城市是哪一座以及这次行驶的距离（先不管得知之后该如何用，至少在目前的思路还是需要知道的）？  
为了解决这个问题，首先就需要了解小 A 与小 B 的策略。
## 小 A 与 小 B 的行驶策略
先看小 B，小 B 总是开往前进方向上第一近的城市编号。即：若当前城市编号为 $i$，则寻找满足 $|h_i - h_j|$ 最小的 $j$，且满足 $i < j \le n$（当然，如有多个，选取 $h_j$ 最大的）。题目中有一句“各个城市的海拔高度各不相同”，这就说明，满足 $|h_i - h_j|$ 最小，且满足 $i < j \le n$ 的 $j$，最多有两个（一个 $h_j < h_i$，另一个 $h_j > h_i$）。  
更进一步，这样的 $j$ 会出现在哪儿呢？不难发现，若将满足 $i < j \le n$ 的 $j$ 分成两组，一组是满足 $i < j \le n$ 且 $h_j < h_i$（第一组），另一组是满足 $i < j \le n$ 且 $h_j > h_i$（第二组），则答案要么是第一组中的 $h_j$ 的最大值所对应的 $j$（如果有的话），要么是第二组中的 $h_j$ 的最小值所对应的 $j$（如果有的话）。所以，寻找小 B 行驶的下一个城市，就需要寻找满足 $i < j \le n$ 且 $h_j < h_i$ 中的 $h_j$ 的最大值所对应的 $j$ 和满足 $i < j \le n$ 且 $h_j > h_i$ 中的 $h_j$ 的最小值所对应的 $j$ 后再比较一下，选出距离最小的 $j$。  
再看小 A，同理可得：寻找小 A 行驶的下一个城市，就需要寻找满足 $i < j \le n$ 且 $h_j < h_i$ 中的 $h_j$ 的最大值与次大值所对应的 $j$ 和满足 $i < j \le n$ 且 $h_j > h_i$ 中的 $h_j$ 的最小值与次小值所对应的 $j$ 后再比较一下，选出距离次小的 $j$。
## 输入及预处理小 A 与小 B 行驶的下一个城市
方法是有了，但是要如何去做呢？输入完了之后，如果直接循环 $i$ 后再去循环 $j$ 的话，时间复杂度是 $O(n^2)$ 级的。那该怎么办呢？我们想到，可以直接全部按 $h_i$ 的大小排序（做结构体保留原下标），然后上面（小 A 与小 B 的策略）的四个数就都在它所在的左边和右边了两个（如果存在的话）——吗？还有一个问题，就是要满足 $i < j \le n$，可是在它旁边的可不一定是满足 $i < j$ 的。那怎么办？要保证序列有序，又不能考虑 $j < i$ 的情况，怎么办呢？  
我们发现，当 $i = 1$ 时，不存在 $j < i$ 的情况，所以显然当 $i = 1$ 时答案是正确的。当 $i > 1$ 时，相比于 $i$ 是此时的 $i - 1$ 的时候，可选的序列再加上此时的 $i$ 本身少了 $i - 1$。所以是不是只要把 $i - 1$ 对应的元素删掉就好了呢？当然，直接删除的时间复杂度是 $O(n)$，所以不可以直接删除。但是有一种线性数据结构，支持常数级的删除操作，它就是链表！所以将 $h_i$ 排序后再建一个链表（可以手写，如果不是手写的话，那就要令存一个 $h$ 数组，因为数组模拟的链表删除元素并没有将其真的删除，即便它已经不在链表中了，但它的值还在数组中，在后面回答问题一的时候，若两个比值相等，还要判断哪个城市的高度更高），每次将此次的 $i$ 处理完存到数组中后将对应的元素删掉就好了（上面的 $i$，$j$ 都指的是原数组的下标）。  
这部分只剩下一件事了：如何常数级地找到原来下标 $i$ 所对应的元素呢？这也很简单，建一个数组，表示原数组的这个下标在排序后的数组里的下标，遍历一遍链表，每次将值储存好就行了。  
所以，这部分的时间复杂度就是：输入 $O(n)$，排序 $O(n \log n)$，遍历 $O(n)$，求出小 A 与小 B 的下一个城市序号及距离 $O(n)$，所以这部分总的时间复杂度就是 $O(n \log n)$。  
贴上相关部分代码：
```cpp
cin >> n;
for(int i = 1; i <= n; i ++) {
    cin >> h[i].hh;
    h[i].ix = i;
}
sort(h + 1, h + n + 1, cmp1);//对 h 数组排序
for(int i = 1; i <= n; i ++) {
    h[i].prv = i - 1;
    h[i].nxt = i + 1;
    ixh[h[i].ix] = i;//方便 O(1) 找到原数组编号为 h[i].ix 的元素在排序后数组的下标（i）
}
h[n].nxt = 0;
for(int i = 1; i <= n; i ++) {
    top = 0;
    temp = ixh[i];
    Work(h[temp].prv);
    Work(h[h[temp].prv].prv);
    Work(h[temp].nxt);
    Work(h[h[temp].nxt].nxt);
    sort(t + 1, t + top + 1, cmp2);//排序
    if(top >= 1) {//至少有一个可以到达的城市，则小 B 的策略可以满足
        b[i] = h[t[1]].ix;
        disb[i] = Abs(h[t[1]].hh - h[temp].hh);
    }
    if(top >= 2) {//至少有两个可以到达的城市，则小 A 的策略可以满足
        a[i] = h[t[2]].ix;
        disa[i][0] = Abs(h[t[2]].hh - h[temp].hh);
    }
    if(h[temp].nxt) h[h[temp].nxt].prv = h[temp].prv;
    if(h[temp].prv) h[h[temp].prv].nxt = h[temp].nxt;
}
``````
相关函数：
```cpp
int Abs(int u) {
    return (u > 0) ? u : (-u);
}
bool cmp1(node u, node v) {//排序比较函数 1
    return u.hh < v.hh;//按高度从小往大排序
}
bool cmp2(int u, int v) {//排序比较函数 2
    if(Abs(h[u].hh - h[temp].hh) != Abs(h[v].hh - h[temp].hh)) return Abs(h[u].hh - h[temp].hh) < Abs(h[v].hh - h[temp].hh);//如果差的绝对值不相等，就按差的绝对值从小往大排序
    return h[u].hh < h[v].hh;//否则，高度小的距离更近，按高度从小往大（虽然最多只有两个）
}
void Work(int u) {
    if(u) t[++top] = u;
}
``````
相关数据结构：
```cpp
int n, ixh[100010], t[100010], top, temp, a[100010], disa[100010][17], b[100010], disb[100010];
struct node {
    int hh, ix, prv, nxt;//高度、原数组下标、前驱、后继
}h[100010];
``````
## 计算倍增数组
那接下来，该如何用呢？假设在城市 $i$ 小 A 的行驶目标为 $a_i$、行驶路程为 $disa_i$，小 B 的行驶目标为 $b_i$、行驶路程为 $disb_i$。那么就模拟吧，小 A 行驶一天、小 B 行驶一天为一组，一组一组地行驶，最后特判一下小 A 单独行驶一天，然后求出答案即可。但是，时间复杂度：问题一的时间复杂度是 $O(n^2)$，问题二的时间复杂度是 $O(nm)$，共 $O((n+m)n)$。显然，超时了。  
接下来考虑优化，一组一组地行驶太慢了，能不能使用二进制的方式从大往小枚举呢？但是这样就需要预处理从城市 $i$ 开始行驶 $2^j$ 天后的城市编号与行驶的距离。倍增的思想已经呼之欲出了。定义 $ab_{i,j}$、$disab_{i,j}$ 分别表示从城市 $i$ 开始两人一起行驶 $2^j$ 组后所在的城市编号与一共行驶的距离。那么 $ab_{i,j}$ 的求法如下：  
$$
ab_{i,j} = 
\begin{cases}
  b_{a_i} & j = 0 \\
  ab_{ab_{i,j-1},j-1} & j > 0 
\end{cases}
$$
相应地，$disab_{i,j}$ 的求法如下：  
$$
disab_{i,j} = 
\begin{cases}
  disa_i + disb_{a_i} & j = 0 \\
  disab_{i,j-1} + disab_{ab_{i,j-1},j-1} & j > 0
\end{cases}
$$
当然，以上 $disab_{i,j}$ 求法针对的都是能够行驶的情况，所以使用的时候记得要判断 $ab_{i,j-1}$ 是否存在（不为初值 $0$，因为凡是能够到达的，数组中一定是一个正整数）。  
但是我们发现，使用的时候需要同时求出小 A 与小 B 的行驶路程，但是显然小 A 行驶的路程加上小 B 行驶的流程就是他们两个总共行驶的路程。所以只需要存小 A 的路程就足够了（当然，你要存小 B 的也不是不可以）。改一下定义。原来的 $disa_i$ 改成 $disa_{i,j}$，定义 $disa_{i,j}$ 表示从城市 $i$ 开始两人一起行驶 $2^j$ 组后小 A 的行驶的距离（这次改完定义后，前面所有的 $disa_i$ 都要改成 $disa_{i,0}$），则经过刚才链表那部分的操作后，已经求出了 $disa_{i,0}$（即原来的“$disa_i$”）。所以 $disa_{i,j}=disa_{i,j-1}+disa_{ab_{i,j-1},j-1}(j>0)$。  
时间复杂度显然就是 $O(n \log n)$。但是要注意，循环的时候要先循环 $j$（外循环）、再循环 $i$（内循环），否则数组里的数据就会出问题。  
贴上相关部分代码：
```cpp
for(int i = 1; i <= n; i ++) {
    ab[i][0] = b[a[i]];
    disab[i][0] = disa[i][0] + disb[a[i]];
}
k = log2(n);//提前存储一下
for(int j = 1; j <= k; j ++) {
    for(int i = 1; i <= n; i ++) {
        ab[i][j] = ab[ab[i][j - 1]][j - 1];
        disab[i][j] = disab[i][j - 1] + disab[ab[i][j - 1]][j - 1];
        disa[i][j] = disa[i][j - 1] + disa[ab[i][j - 1]][j - 1];
    }
}
``````
相关数据结构：
```cpp
int n, k, a[100010], disa[100010][17], b[100010], disb[100010], ab[100010][17], disab[100010][17];
``````
## 回答询问
倍增数组都预处理完了，接下来就可以回答询问了。其实前面也提到过回答询问的方法。其实询问核心只有一种，就是给定出发城市 $s$ 与路程限制 $x$，求小 A 的行驶路程与小 B 的行驶路程。问题一只不过是这种问题（问题二）的一种变体。所以，问题二是关键。  
先看问题二，其实倍增数组预处理完了之后就很简单了，只要从大往小尝试行驶的组数以二为底数的幂指数，满足条件就行驶，累加总路程与小 A 行驶的路程，最后记得特判小 A 单独再行驶一天的情况，总路程减去小 A 行驶的路程就是小 B 行驶的路程。  
那么问题一就很简单了，枚举出发城市 $s$，每次按照问题二的方式进行求解，在按照题目的要求比较比值大小即可。这里有两种方式，一种是相除（用 `double` 或 `long double` 来存储）后比较大小，另一种是分子与分母分别交叉相乘，比较大小。但是第二种方式的乘积可能要用 `int128` 的类型来存储，因为乘积的极限是 $10^{28}$ 次方级的，`long long` 存不下（说起存储，温馨提示：本题建议大部分变量用 `long long` 存储）。一定要注意，不论是哪一种方法，都要先判断分母是 $0$ 的情况（方法一要相除，所以要判断分母是否是 $0$；方法二要分子分母交叉相乘，则如果两个分数是 $\frac{p}{q}$（$p \ge 0$，$q > 0$）和 $\frac{0}{0}$ 的形式的话，此时的两个乘积就都是 $0$，但是显然在题目的要求下 $\frac{p}{q} < \frac{0}{0}$，所以要先判断分母是 $0$ 的情况）。  
那时间复杂度就是：问题一 $O(n \log n)$，问题二 $O(m \log n)$，总的回答询问的时间复杂度就是 $O((n + m) \log n)$。  
最后，总的时间复杂度就是 $O((n + m) \log n)$，空间复杂度就是 $O(n \log n)$，通过！  
贴上相关部分代码：
```cpp
cin >> x;
for(int i = 1; i <= n; i ++) {
    Calc(i, x);
    if(i == 1) Ans(i, lena, lenb);//目前还没有任何答案，直接记录下来
    else {
        if(!lenb) {
            if((!ansb) && h[ixh[i]].hh > h[ixh[ansi]].hh) Ans(i, lena, lenb);//两个比值都是无穷大，比高度
        }
        else {
            if(!ansb) Ans(i, lena, lenb);//新的比值不是无穷大，而目前的答案的比值是无穷大
            else {//两个比值都不是无穷大
                __int128 answ = __int128(ansa) * __int128(lenb);
                __int128 lenw = __int128(lena) * __int128(ansb);
                if(lenw < answ) Ans(i, lena, lenb);//新的比值比目前的答案的比值更小
                else if(lenw == answ && h[ixh[i]].hh > h[ixh[ansi]].hh) Ans(i, lena, lenb);//两个比值相等，比高度
            }
        }
    }
}
cout << ansi << endl;
cin >> m;
while(m --) {
    cin >> s >> x;
    Calc(s, x);
    cout << lena << " " << lenb << endl;
}
``````
相关函数：
```cpp
void Calc(int ss, int xx) {//计算从城市 ss 出发，在总路程不超过 xx 的情况下小 A 行驶的路程与小 B 行驶的路程
    lena = lenb = 0;//小 A 的路程与小 B 的路程（先计算一共的路程，再减去小 A 的路程得出小 B 的路程）初值为 0
    for(int i = k; i >= 0; i --) {
        if(ab[ss][i] && lenb + disab[ss][i] <= xx) {
            lenb += disab[ss][i];
            lena += disa[ss][i];
            ss = ab[ss][i];
        }
    }
    if(a[ss] && lenb + disa[ss][0] <= xx) {//特判小 A 最后单独行驶一天的情况
        lenb += disa[ss][0];
        lena += disa[ss][0];
        ss = a[ss];
    }
    lenb -= lena;//求出小 B 的路程
}
void Ans(int u, int v, int w) {//记录答案
    ansi = u;
    ansa = v;
    ansb = w;
}
``````
相关数据结构：
```cpp
int n, k, ixh[100010], a[100010], disa[100010][17], ab[100010][17], disab[100010][17], m, x, s, lena, lenb, ansa, ansb, ansi;
``````
## 思路梳理
最后梳理一下思路：

- 预处理
  - 输入 $n$ 并循环输入原数组，保留原数组下标，按高度排序
  - 用数组模拟双向链表，并存储原数组元素在排序后数组中的下标
  - 循环从 $1$ 到 $n$ 枚举原数组的下标 $i$
    - 找到原数组中下标为 $i$ 的元素在排序后数组中的下标
    - 找到它在链表中的前驱、前驱的前驱、后继、后继的后继（如果有的话），并对找到它们中距离循环枚举的城市最短和次短的城市（如果有的话），并将这个城市与其与循环枚举的城市的距离存储下来
    - 将循环所枚举的元素从用数组模拟的链表中删除
  - 循环城市编号 $i$，从 $1$ 到 $n$
    - 处理出 $ab_{i,0}=b_{a_i}$，$disab_{i,0}=disa_{i,0}+disb_{a_i}$
  - 循环倍增数组中的第二维 $j$，从 $1$ 到 $\lfloor \log n \rfloor$
    - 循环倍增数组的第一维 $i$，从 $1$ 到 $n$
      - 处理出 $disa_{i,j}=disa_{i,j-1}+disa_{ab_{i,j-1},j-1}$，$ab_{i,j} = ab_{ab_{i,j-1},j-1}$，$disab_{i,j} = disab_{i,j-1}+disab_{ab_{i,j-1},j-1}$
- 回答询问
  - 问题一
    - 输入 $x$
    - 循环枚举出发城市 $i$
      - 循环枚举行驶的组数的幂指数（底数为 $2$）
        - 尝试两人行驶 $2^j$ 组（在满足条件的情况下），并记录小 A 的行驶路程与两人的行驶路程
      - 特判小 A 单独行驶一天的情况
      - 计算小 B 行驶的路程，即两人的行驶路程减去小 A 的行驶路程
      - 按题目要求比较答案，与现有答案比较，选出使小 A 与小 B 行驶的路程的比值最小的出发城市（若相等，则比较高度），如果是这次新的答案，就将其记录在现有的答案中
  - 问题二
    - 共有 $m$ 次询问，循环 $m$ 次
      - 循环枚举行驶的组数的幂指数（底数为 $2$）
        - 尝试两人行驶 $2^j$ 组（在满足条件的情况下），并记录小 A 的行驶路程与两人的行驶路程
      - 特判小 A 单独行驶一天的情况
      - 输出答案
# 代码
我们发现在思路中，有一些重复的步骤，比如：

- 循环枚举行驶的组数的幂指数（底数为 $2$）
  - 尝试两人行驶 $2^j$ 组（在满足条件的情况下），并记录小 A 的行驶路程与两人的行驶路程
- 特判小 A 单独行驶一天的况

所以，可以将这样的步骤封装成一个函数。  
好了，贴代码。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k, ixh[100010], t[100010], top, temp, a[100010], disa[100010][17], b[100010], disb[100010], ab[100010][17], disab[100010][17], m, x, s, lena, lenb, ansa, ansb, ansi;
struct node {
    int hh, ix, prv, nxt;//高度、原数组下标、前驱、后继
}h[100010];
int Abs(int u) {
    return (u > 0) ? u : (-u);
}
bool cmp1(node u, node v) {//排序比较函数 1
    return u.hh < v.hh;//按高度从小往大排序
}
bool cmp2(int u, int v) {//排序比较函数 2
    if(Abs(h[u].hh - h[temp].hh) != Abs(h[v].hh - h[temp].hh)) return Abs(h[u].hh - h[temp].hh) < Abs(h[v].hh - h[temp].hh);//如果差的绝对值不相等，就按差的绝对值从小往大排序
    return h[u].hh < h[v].hh;//否则，高度小的距离更近，按高度从小往大（虽然最多只有两个）
}
void Work(int u) {
    if(u) t[++top] = u;
}
void Calc(int ss, int xx) {//计算从城市 ss 出发，在总路程不超过 xx 的情况下小 A 行驶的路程与小 B 行驶的路程
    lena = lenb = 0;//小 A 的路程与小 B 的路程（先计算一共的路程，再减去小 A 的路程得出小 B 的路程）初值为 0
    for(int i = k; i >= 0; i --) {
        if(ab[ss][i] && lenb + disab[ss][i] <= xx) {
            lenb += disab[ss][i];
            lena += disa[ss][i];
            ss = ab[ss][i];
        }
    }
    if(a[ss] && lenb + disa[ss][0] <= xx) {//特判小 A 最后单独行驶一天的情况
        lenb += disa[ss][0];
        lena += disa[ss][0];
        ss = a[ss];
    }
    lenb -= lena;//求出小 B 的路程
}
void Ans(int u, int v, int w) {//记录答案
    ansi = u;
    ansa = v;
    ansb = w;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        cin >> h[i].hh;
        h[i].ix = i;
    }
    sort(h + 1, h + n + 1, cmp1);//对 h 数组排序
    for(int i = 1; i <= n; i ++) {
        h[i].prv = i - 1;
        h[i].nxt = i + 1;
        ixh[h[i].ix] = i;//方便 O(1) 找到原数组编号为 h[i].ix 的元素在排序后数组的下标（i）
    }
    h[n].nxt = 0;
    for(int i = 1; i <= n; i ++) {
        top = 0;
        temp = ixh[i];
        Work(h[temp].prv);
        Work(h[h[temp].prv].prv);
        Work(h[temp].nxt);
        Work(h[h[temp].nxt].nxt);
        sort(t + 1, t + top + 1, cmp2);//排序
        if(top >= 1) {//至少有一个可以到达的城市，则小 B 的策略可以满足
            b[i] = h[t[1]].ix;
            disb[i] = Abs(h[t[1]].hh - h[temp].hh);
        }
        if(top >= 2) {//至少有两个可以到达的城市，则小 A 的策略可以满足
            a[i] = h[t[2]].ix;
            disa[i][0] = Abs(h[t[2]].hh - h[temp].hh);
        }
        if(h[temp].nxt) h[h[temp].nxt].prv = h[temp].prv;
        if(h[temp].prv) h[h[temp].prv].nxt = h[temp].nxt;
    }
    for(int i = 1; i <= n; i ++) {
        ab[i][0] = b[a[i]];
        disab[i][0] = disa[i][0] + disb[a[i]];
    }
    k = log2(n);//提前存储一下
    for(int j = 1; j <= k; j ++) {
        for(int i = 1; i <= n; i ++) {
            ab[i][j] = ab[ab[i][j - 1]][j - 1];
            disab[i][j] = disab[i][j - 1] + disab[ab[i][j - 1]][j - 1];
            disa[i][j] = disa[i][j - 1] + disa[ab[i][j - 1]][j - 1];
        }
    }
    cin >> x;
    for(int i = 1; i <= n; i ++) {
        Calc(i, x);
        if(i == 1) Ans(i, lena, lenb);//目前还没有任何答案，直接记录下来
        else {
            if(!lenb) {
                if((!ansb) && h[ixh[i]].hh > h[ixh[ansi]].hh) Ans(i, lena, lenb);//两个比值都是无穷大，比高度
            }
            else {
                if(!ansb) Ans(i, lena, lenb);//新的比值不是无穷大，而目前的答案的比值是无穷大
                else {//两个比值都不是无穷大
                    __int128 answ = __int128(ansa) * __int128(lenb);
                    __int128 lenw = __int128(lena) * __int128(ansb);
                    if(lenw < answ) Ans(i, lena, lenb);//新的比值比目前的答案的比值更小
                    else if(lenw == answ && h[ixh[i]].hh > h[ixh[ansi]].hh) Ans(i, lena, lenb);//两个比值相等，比高度
                }
            }
        }
    }
    cout << ansi << endl;
    cin >> m;
    while(m --) {
        cin >> s >> x;
        Calc(s, x);
        cout << lena << " " << lenb << endl;
    }
    return 0;
}
``````
当然，在上面代码中，比较比值的部分你也可以这样写：
```cpp
if(i == 1 || (lenb && ((!ansb) || (ansb && (lenw < answ || (lenw == answ && h[ixh[i]].hh > h[ixh[ansi]].hh)))) || ((!lenb) && (!ansb) && h[ixh[i]].hh > h[ixh[ansi]].hh))) Ans(i, lena, lenb);
``````
# 我的提交记录
[我的提交记录](https://www.luogu.com.cn/record/206784925)
# 后记
本题代码较长，实现细节较多，但还是自己手打，不要抄代码。  
最后祝愿大家在美好的绿色方块中通过此题！

---

## 作者：Neumann (赞：3)

by WNSGB（这是我的常用ID..以前的号好像丢了）终于调过啦！

一开始只觉得搞定了pre这个题随随便便就能过了但后来发现这个题倍增还是有很多技巧****

比如：1.我们实际上是把题目中小A小B开车的两天看做”一天“所以fa[i][0]=Fb[Fa[i]];（先A后B）

fa[i][0]指的是从第i个城市走一次操作（即上面的“一天”）到达的下一个城市。Fa[i]和Fb[i]是在预处理中得到的从第i个城市出发a能到达的和b能到达的城市这样我们就避免了分别考虑今天该谁走的这种情况，大大简化了程序实现的细节。只需要在查询的时候判断是否存在A能走而B不能走的情况并在计算路程时加上就好了。同样的根据上面的思路（A和B两天的行走看成是一次操作（即“一天”））DDa[i][k]表示走2^k天（这里的天指之前我们定义的一次操作）A走的路程。DDb同理。

虽然无论怎么写在oj上都秒过但是不得不承认set常数极大，用学校机房的cena要调成两秒还是卡过，所以有些可以用abs现算的地方全都在pre中用Da和Db存好了（不然cena最后一个点过不了，不知道要是联赛会怎么样，让正解和暴力一个分吗...）

2.倍增的查询方式和lca的跳表到deep相同后一起跳的思想差不多，大家可以体会一下。

好吧，这个题最难的还是pre部分

等下稍微吐槽一下这个题，noipT3都是靠不断扩大数据范围优化暴力得到正解的吗0.0

考虑如何优化一个n\*n的预处理

因为在第二重循环中有些点是没必要考虑的经过分析可得最近和次近的城市一定是在当前城市的两侧（肯定是按海拔排序假如城市为i，只需要考虑i+1，i+2，i-1，i-2即可），实现这步操作除了双向链表以外，就是我用的set（充当了平衡树）（听说还有用离散化+线段树的）

还有set查找的时候没有必要用lower\_bound或是upper\_bound直接find之后对指针++--就行了

不知不觉细节都说完了0.0管理员给通过吧...这是原创题解啊0.0

还有提醒一下看题解的同志们：一定仔细地看完上面的题解，不然不可能完全理解代码及其细节！

附AC代码：









    



    
        
    
    
    
```cpp
#include<set>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define INF 2147483647
using namespace std;
const int maxn=100000+10;
int n,q,X0;
struct node{
    int height,id;
    bool operator < (const node &a)const{//重载sort中的小于号 
        return height<a.height;
    }
}h[maxn];
struct node2{
    int delt,id;
    bool operator < (const node2 &a)const{//重载set中的小于号 
        if(delt!=a.delt)
            return delt<a.delt;
        else
            return h[id].height<h[a.id].height;
    }
}temp[10];
set<node>s;
set<node>::iterator it;
int Fa[maxn],Fb[maxn];
int Da[maxn],Db[maxn];
int fa[maxn][20],DDa[maxn][20],DDb[maxn][20];
int inline read(){
    int num=0;
    char c;
    bool plus=true;
    while((c=getchar())==' '||c=='\n'||c=='\r');
    if(c=='-')plus=false;
    else num=c-'0';
    while(isdigit(c=getchar()))
        num=num*10+c-'0';
    return num*(plus?1:-1);
}
void pre(){
    int cnt;
    for(int i=n;i>=1;i--){//使用set实现的平衡树来预处理要根据顺序逆向插入  双向链表也可以 
        s.insert(h[i]);
        it=s.find(h[i]);
        cnt=0;
        if(it!=s.begin()){
            it--;
            temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
            if(it!=s.begin()){
                it--;
                temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
                it++;
            }
            it++;
        }
        if((++it)!=s.end()){//end指向最后一个元素的后一位所以先++
            temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
            if((++it)!=s.end()){
                temp[++cnt]=(node2){abs((*it).height-h[i].height),(*it).id};
                it--;//这里不减也可
            }
            it--;
        }
        sort(temp+1,temp+cnt+1);
        if(temp[1].id){
            Db[i]=temp[1].delt;
            Fb[i]=temp[1].id;
        }
        if(temp[2].id){
            Da[i]=temp[2].delt;
            Fa[i]=temp[2].id;
        }
    }
    for(int i=1;i<=n;i++){
        int f1=Fa[i],f2=Fb[Fa[i]];
        DDa[i][0]=f1!=0?Da[i]:0;
        DDb[i][0]=f2!=0?Db[f1]:0;
        fa[i][0]=f2;
    }
    for(int k=1;k<=16;k++)
        for(int i=1;i<=n;i++){
            if(fa[fa[i][k-1]][k-1]){
                fa[i][k]=fa[fa[i][k-1]][k-1];
                DDa[i][k]=DDa[i][k-1]+DDa[fa[i][k-1]][k-1];
                DDb[i][k]=DDb[i][k-1]+DDb[fa[i][k-1]][k-1];
            }
        }
}
double task1(int s,int x){
    long long xa=0,xb=0;
    for(int i=16;i>=0;i--){//倒着来和lca差不多
        if(fa[s][i]&&DDa[s][i]+DDb[s][i]<=x){
            xa+=DDa[s][i];
            xb+=DDb[s][i];
            x-=DDa[s][i]+DDb[s][i];
            s=fa[s][i];
        }
    }
    if(Fa[s]&&DDa[s][0]<=x){
        xa+=DDa[s][0];
    }
    if(xb==0)return (double)INF;
    else return double(xa)/(double)xb;
}
void task2(int s,int x){
    long long xa=0,xb=0;
    for(int i=16;i>=0;i--){
        if(fa[s][i]&&DDa[s][i]+DDb[s][i]<=x){
            xa+=DDa[s][i];
            xb+=DDb[s][i];
            x-=DDa[s][i]+DDb[s][i];
            s=fa[s][i];    
        }
    }
    if(Fa[s]&&DDa[s][0]<=x){
        xa+=DDa[s][0];
    }
    cout<<xa<<" "<<xb<<endl;
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        h[i].height=read();
        h[i].id=i;
    }
    pre();
    X0=read();
    double ans=(double)INF+(double)INF;
    int ansi;
    for(int i=1;i<=n;i++){
        double tmp=task1(i,X0);
        if(ans>tmp||(ans==tmp&&h[i].height>h[ansi].height)){
            ans=tmp;
            ansi=i;
        }
    }
    printf("%d\n",ansi);
    q=read();
    int x,s;
    for(int i=1;i<=q;i++){
        s=read(); x=read();
        task2(s,x);
    }
    return 0;
}

```

---

## 作者：穼柗° (赞：2)

如果知道了每个人在每个城市会走到哪，可以直接倍增：求出三个数组，分别表示在每个人在每个城市走 $2^j$ 会走到哪、小 $A$ 会走几步、小 $B$ 会走几步。我觉得难点是求每个人在每个城市会走到哪。

因为他们永远只会往右走，所以可以从右往左把城市海拔放到平衡树里，最近、次近必然是前驱、前驱的前驱、后继、后继的后继中的两个。但是我们没必要手写一个平衡树（谁懂啊我手写 72 行 Treap 然后 [30 分](https://www.luogu.com.cn/record/219576601)），利用 `map` 维护一个递增的双向链表，依然可以 $O(1)$ 时间求前驱与后继。

具体实现看代码。
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#define inf 1000000001ll
#define int long long
using namespace std;
const int N=100001;
int pblc; // h[i]=pblc，tmpcmp()会用到
bool tmpcmp(const pair<int,int>& x,const pair<int,int>& y) { // 用于后面求离城市最近与次近
	if(!x.second) return 0;
	if(!y.second) return 1;
	if(abs(x.first-pblc)!=abs(y.first-pblc))
		return abs(x.first-pblc)<abs(y.first-pblc);
	else return x.first<y.first;
}
struct info {
	int a,b;
	info(const int __a=0,const int __b=0): a(__a),b(__b) {}
	info operator +(const info &o) const { // 距离相加
		return info(a+o.a,b+o.b);
	}
} dis[2][N][20];
int n,m,x0,h[N],st[2][N][20];
// dis[0/1][i][j].a 表示【0为小A，1为小B】从城市i走2^j步后小A走的步数
// dis[0/1][i][j].b 表示【0为小A，1为小B】从城市i走2^j步后小B走的步数
// st[0/1][i][j] 表示【0为小A，1为小B】从城市i走2^j步后到达的位置
int gcd(int x,int y) { // 简单快速GCD
	if(x<y) x^=y^=x^=y;
	while(y^=x^=y^=x%=y);
	return x;
}
void beizeng(int s,int x,int &sa,int &sb) {
	// 小A从城市s出发，给定x，最后小A走了sa步，小B走了sb步
	int now=sa=sb=0;
	for(int i=19;i>=0;i--) {
		if(st[now][s][i]&&dis[now][s][i].a+dis[now][s][i].b<=x) { // 能到达且路程不超
			x-=dis[now][s][i].a+dis[now][s][i].b; // 剩下能走的路少了
			sa+=dis[now][s][i].a,sb+=dis[now][s][i].b; // 两个人走得更多了
			if(!i) now^=1; // 走2^0步要换人
			s=st[now][s][i]; // 位置变了
		}
	}
}
map<int,int> mp;
int top,lft[N],rit[N]; // 双向链表，top为最后面的结点编号，lft为前驱，rit为后继
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>h[i];
	for(int i=n;i>=1;i--) {
		mp[h[i]]=i; // 放到平衡树里
		auto tt=mp.upper_bound(h[i]); // 找后继
		if(tt==mp.end()) { // 没有比它高的，说明它最大，放到链表最后面
			if(top) { // 如果链表有最后面（即有元素）
				rit[top]=i;
				lft[i]=top;
			}
			top=i; // 更新最后面
		} else {
			const int pos=tt->second; // pos为后继城市的编号
			rit[i]=pos; // 插到它左边
			if(lft[pos]) {
				lft[i]=lft[pos];
				rit[lft[pos]]=i;
			}
			lft[pos]=i;
		}
		vector<pair<int,int> > tmp;
// 把前驱、前驱的前驱、后继、后继的后继放到 tmp 里。first为海拔，second为城市编号
		tmp.push_back(make_pair(h[lft[i]],lft[i]));
		tmp.push_back(make_pair(h[lft[lft[i]]],lft[lft[i]]));
		tmp.push_back(make_pair(h[rit[i]],rit[i]));
		tmp.push_back(make_pair(h[rit[rit[i]]],rit[rit[i]]));
		pblc=h[i]; // 全局变量，用于比较
		sort(tmp.begin(),tmp.end(),tmpcmp); // 按离城市i的距离升序排序
		if(tmp[0].second) // 如果存在最近
			st[1][i][0]=tmp[0].second,dis[1][i][0].b=abs(h[i]-tmp[0].first);
		if(tmp[1].second) // 如果存在次近
			st[0][i][0]=tmp[1].second,dis[0][i][0].a=abs(h[i]-tmp[1].first);
	}
	for(int j=1;j<=n;j++) { // 走2^1步的倍增，走2^0步后会换人所以要特别处理
		st[0][j][1]=st[1][st[0][j][0]][0];
		st[1][j][1]=st[0][st[1][j][0]][0];
		dis[0][j][1]=dis[0][j][0]+dis[1][st[0][j][0]][0]; // 重载了“+”
		dis[1][j][1]=dis[1][j][0]+dis[0][st[1][j][0]][0];
	}
	for(int i=2;i<20;i++)
		for(int j=1;j<=n;j++) { // i>=2，走2^i步的倍增，走2^(i-1)步后依然是本人
			st[0][j][i]=st[0][st[0][j][i-1]][i-1];
			st[1][j][i]=st[1][st[1][j][i-1]][i-1];
			dis[0][j][i]=dis[0][j][i-1]+dis[0][st[0][j][i-1]][i-1];
			dis[1][j][i]=dis[1][j][i-1]+dis[1][st[1][j][i-1]][i-1];
		}
	cin>>x0>>m;
	int ans1=0,mo=0,hb=-inf,son=1;
	// ans1为当前第一问的答案，mo为比值的分母，son为分子，hb是当前答案对应城市的海拔
	for(int i=1;i<n;i++) { // 找第一问的答案（不可能是n，因为没得走）
		int s=i,x=x0,sa,sb;
		beizeng(s,x,sa,sb);
		if(!sb) { // 比值无穷大。
			if(!mo&&h[i]>hb) ans1=i,hb=h[i]; // 比海拔
			continue;
		}
		const int gg=gcd(sa,sb);
		sa/=gg,sb/=gg; // 约分
		if(!mo) // 当前答案的比值为无穷大
			son=sa,mo=sb,ans1=i,hb=h[i];
		else if(sa*mo<sb*son)
			// sa/sb<son/mo <=> sa/sb*(sb*mo)<son/mo*(sb*mo) <=> sa*mo<sb*son
			son=sa,mo=sb,ans1=i,hb=h[i];
		else if(sa*mo==sb*son&&h[i]>hb) // 比值相同，看海拔
			son=sa,mo=sb,ans1=i,hb=h[i];
	}
	cout<<ans1<<'\n';
	for(int s,x,sa,sb;m--;) { // 找第二个问题的答案
		cin>>s>>x;
		beizeng(s,x,sa,sb);
		cout<<sa<<' '<<sb<<'\n';
	}
	return 0;
}
```
这是我第三道独自 AC 的紫题。

---

## 作者：jur10n (赞：2)

## [P1081 [NOIP 2012 提高组] 开车旅行](https://www.luogu.com.cn/problem/P1081)

这里提供一种基于 STL `set` 的**预处理到达城市**方法。

> 建议结合其他题解看其他部分的代码和整体思路。
> 
> 对于这个预处理，不会链表的可以试试这个暴力且容易的思路。
>

同类练习题，可用 `set` 或者链表解决：[P10466 邻值查找](https://www.luogu.com.cn/problem/P10466)

## 思路

根据题意，我们预处理到达城市（计算 ga 和 gb 数组）的目标为：对于每个城市 $i$，找出**在它后面的城市中**，离它最近或者次近的城市并记录。

因此，我们可以利用 `set` 的性质：插入集合的元素会自动排序，且支持查找某个元素的位置并利用迭代器获取比它小或者大的元素（通过 `++s.find(x)` 等操作就可以）。

----

### 考虑如何达成我们的目的：

只需要动态维护一个 `set` 用来排后面几个城市的高度的序，可以用结构体，顺带记录城市的序号，重载运算符 `<` 即可。

然后对于每个城市，找出比它高的海拔最低的两个城市，以及比他低的海拔最高的两个城市。容易证明这**四个**城市之中将会诞生最近和次近的城市。

----

### 考虑边界处理问题：

由于迭代器的边界处理不好写，采用生硬的判定如 `s.end()` 这样的方法需要考虑很多特判情况，太繁琐麻烦了。而且由于我们不仅要判前到顶还要看后是否到顶，且我们需要 `++` 或 `--` 两次，因此由于美妙的玄学迭代器方法，非常容易写炸。

解决方案：人为造边界。

实现方法：提前插入两个无限大和无限小的海拔到集合中，将他们作为人为的边界，这样就不用考虑边界问题了。

定义无限大为 `0x3f3f3f3f` 就可满足本题目要求。

## 代码

这里采用暴力优先队列维护最小和次小城市。

省略了其余部分。


```cpp
#define inf 0x3f3f3f3f

struct node	//城市信息
{
	int h, id;
};
bool operator < (node a, node b)
{
	return a.h < b.h;
}

struct node2
{
	int dis, high, id;
};
bool operator < (node2 a, node2 b) //优先队列反着写符号
{
	if (a.dis == b.dis) return a.high > b.high;
	return a.dis > b.dis;
}

int n, m;
int H[N], ga[N], gb[N];
set<node> City;

pair<int, int> GetCity(node C[], int h)	//获取最近的两个城市信息
{
	int a = 0, b = 0;
	priority_queue<node2> Q;
	for (int i = 1; i <= 4; i++)
	{
		if (C[i].h >= inf || C[i].h <= -inf) continue;
		Q.push({abs(h - C[i].h), C[i].h, C[i].id});
	}
	while (!Q.empty())
	{
		if (!b) b = Q.top().id;
		else
		{
			a = Q.top().id;
			break;
		}
		Q.pop();
	}
	return {a, b};
}

void Init()	//初始化ga和gb
{
	City.insert({inf, 0}), City.insert({-inf, 0}), City.insert({inf + 1, 0}), City.insert({- inf - 1, 0});
	for (int i = n, h; i >= 1; i--)
	{
		h = H[i];
		City.insert({h, i});
		node C[5] = {};
		C[1] = *++City.find({h, i});
		C[2] = *--City.find({h, i});
		C[3] = *++++City.find({h, i});
		C[4] = *----City.find({h, i});
		auto res = GetCity(C, h);
		ga[i] = res.first, gb[i] = res.second;
	}
}

signed main()
{
	io.read(n);
	for (int i = 1; i <= n; i++) io.read(H[i]);
	Init();

	//省略其他部分...
	return 0;
}
```

---

## 作者：切格瓦·星 (赞：2)

这道题其实难就难在它的预处理上，后面的倍增只要前面与处理好了基本上就是板子

所以我们考虑如何预处理

先定义我们的主要倍增数组：f[i][j]表示从第i个城市出发走2的j次方趟所到达的城市，这里的趟指的是A与B各走一次，因为AB是轮流走的，所以行走路线是确定的，最后再判一下A单独能不能走一次就行了。

根据我们定义的倍增数组，不难看出我们要求出离每个城市最近的城市和次近的城市。

### 这要怎么求呢？

我的方法是用一个结构体来存每个城市的高度和城市一开始的编号，再对城市按高度进行排序，同时开一个数组rank[i]表示编号为i的城市的排名。接下来再用双向链表将所有城市连接起来，按标号的从小到大去做，每做到一个点就找出它的最近城市和次近城市，接着把做好了的城市从链表中删除，这样就可以保证每做到一个城市时链表中的其他城市的标号都是比它大的，这样就符合了题目要一直向东走的条件，这部分代码如下：
```cpp
sort(h+1,h+1+n,cmp);//h数组存城市，按高度从小到大排序;
for(int i=1;i<=n;i++) pre[i]=i-1,nxt[i]=i+1;//pre为链表中的前一个，nxt为下一个
for(int i=1;i<=n;i++) rank[h[i].num]=i;//记录编号与排名的对应关系
for(int i=1;i<=n;i++){
	c[i].fi=getf(rank[i]),c[i].se=gets(c[i].fi,rank[i]);
	//getf：找最近，gets：找次近；
	//本人因为思维不够敏捷所以这两个函数写得十分繁琐，各位自己写个简单的吧
	//c存最近与次近；
	c[i].fi=h[c[i].fi].num,c[i].se=h[c[i].se].num;
	pre[nxt[rank[i]]]=pre[rank[i]];
	nxt[pre[rank[i]]]=nxt[rank[i]];
	//记得将做好的点删除
}
```
~~这就是这道题的核心代码部分~~后面就是一些倍增的常规操作

对于第一问：
我们只需要枚举起点跳到不能跳为止，依次记录A，B的距离即可，为此我们需要多开几个倍增数组：A[i][j]:A从i号城市出发，走2的j次方次的距离，B[i][j]:B从i城市出发，走2的j次方次的距离，way[i][j]:总起点为i，走2的j次方趟的距离(趟的定义如上)。算出A,B分别的距离后求个GCD再判断大小即可，注意特判B的距离为0的情况哦，该部分代码：

```cpp
double minn=2147483647,zc;
for(int i=1;i<=n;i++){//枚举起点
	int x=i,suma=0,sumb=0,sum_all=0;
	for(int j=20;j>=0;j--){
		if(sum_all+way[x][j]<=x0&&f[x][j]!=0){
			suma+=A[x][j],sumb+=B[x][j];
			sum_all+=way[x][j];
			x=f[x][j];
		}
	}
	if(sum_all+A[x][0]<=x0&&a[x][0]!=0) suma+=A[x][0];
	int G=gcd(suma,sumb);
	if(suma!=0) suma/=G;
	if(sumb!=0) sumb/=G;//求最大公约数便于求比值
	if(sumb==0){//不判零的话会因为除零而运行错误
		zc=2147483647;
		if(minn==zc&&(h[ans1].val<h[i].val||!ans1)) minn=zc,ans1=i;
	}//比值相同求编号较小的
	else{
		zc=1.0*(double)(suma)/(double)(sumb);
		if(minn>zc) minn=zc,ans1=i;
		else if(minn==zc&&(h[ans1].val<h[i].val||!ans1)) minn=zc,ans1=i;
	}
}
```
（注意a[x][0]表示A从x城市出发走1次（2的零次方）到达的城市，b[x][0]表示B从x城市出发走1次到达的城市）

对于第二问：这一问就更简单了，直接跳即可，就不专门放代码了。

Ac代码完全版：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+7;
int n,m,pre[N],nxt[N],x0,ans1,ans2[N],ans3[N],rank[N];
struct city{ int fi,se; } c[N];
struct high{ int val,num; } h[N];
int f[N][22],way[N][22],A[N][22],B[N][22],a[N][22],b[N][22];
bool cmp(high a,high b){ return a.val<b.val; }
bool amp(high a,high b){ return a.num<b.num; }
int gcd(int a,int b){ return b?gcd(b,a%b):a; }
int getf(int x){
	if(pre[x]==0) return nxt[x];
	if(nxt[x]==n+1) return pre[x];
	if(abs(h[pre[x]].val-h[x].val)<abs(h[nxt[x]].val-h[x].val)) return pre[x];
	else if(abs(h[pre[x]].val-h[x].val)>abs(h[nxt[x]].val-h[x].val)) return nxt[x];
	else if(abs(h[pre[x]].val-h[x].val)==abs(h[nxt[x]].val-h[x].val)){
		if(h[pre[x]].val<h[nxt[x]].val) return pre[x];
		else return nxt[x];
	}
}
int gets(int fir,int x){
	if(fir==pre[x]){
		if(pre[pre[x]]==0) return nxt[x];
		if(nxt[x]==n+1) return pre[pre[x]];
		if(abs(h[pre[pre[x]]].val-h[x].val)<abs(h[nxt[x]].val-h[x].val)) return pre[pre[x]];
		else if(abs(h[pre[pre[x]]].val-h[x].val)>abs(h[nxt[x]].val-h[x].val)) return nxt[x];
		else if(abs(h[pre[pre[x]]].val-h[x].val)==abs(h[nxt[x]].val-h[x].val)){
			if(h[pre[pre[x]]].val<h[nxt[x]].val) return pre[pre[x]];
			else return nxt[x];
		}
	}
	else if(fir==nxt[x]){
		if(pre[x]==0) return nxt[nxt[x]];
		if(nxt[nxt[x]]==n+1) return pre[x];
		if(abs(h[pre[x]].val-h[x].val)<abs(h[nxt[nxt[x]]].val-h[x].val)) return pre[x];
		else if(abs(h[pre[x]].val-h[x].val)>abs(h[nxt[nxt[x]]].val-h[x].val)) return nxt[nxt[x]];
		else if(abs(h[pre[x]].val-h[x].val)==abs(h[nxt[nxt[x]]].val-h[x].val)){
			if(h[pre[x]].val<h[nxt[nxt[x]]].val) return pre[x];
			else return nxt[nxt[x]];
		}	
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&h[i].val);
		h[i].num=i;
	}
	sort(h+1,h+1+n,cmp);
	for(int i=1;i<=n;i++) pre[i]=i-1,nxt[i]=i+1;
	for(int i=1;i<=n;i++) rank[h[i].num]=i;
	for(int i=1;i<=n;i++){
		c[i].fi=getf(rank[i]),c[i].se=gets(c[i].fi,rank[i]);
		c[i].fi=h[c[i].fi].num,c[i].se=h[c[i].se].num;
		pre[nxt[rank[i]]]=pre[rank[i]];
		nxt[pre[rank[i]]]=nxt[rank[i]];
	}
	sort(h+1,h+1+n,amp);//按照编号排序使h的顺序回到原来
	for(int i=1;i<=n;i++){
		f[i][0]=c[c[i].se].fi;
		way[i][0]=abs(h[c[i].se].val-h[i].val)+abs(h[c[c[i].se].fi].val-h[c[i].se].val);
		A[i][0]=abs(h[c[i].se].val-h[i].val);
		B[i][0]=abs(h[c[c[i].se].fi].val-h[c[i].se].val);
		a[i][0]=c[i].se,b[i][0]=c[i].fi;
	}
	for(int i=1;i<=20;i++)
	for(int j=1;j<=n;j++){
		f[j][i]=f[f[j][i-1]][i-1];
		way[j][i]=way[j][i-1]+way[f[j][i-1]][i-1];
		A[j][i]=A[j][i-1]+A[f[j][i-1]][i-1];
		B[j][i]=B[j][i-1]+B[f[j][i-1]][i-1];
	}
	scanf("%d",&x0);
	double minn=2147483647,zc;
	for(int i=1;i<=n;i++){
		int x=i,suma=0,sumb=0,sum_all=0;
		for(int j=20;j>=0;j--){
			if(sum_all+way[x][j]<=x0&&f[x][j]!=0){
				suma+=A[x][j],sumb+=B[x][j];
				sum_all+=way[x][j];
				x=f[x][j];
			}
		}
		if(sum_all+A[x][0]<=x0&&a[x][0]!=0) suma+=A[x][0];
		int G=gcd(suma,sumb);
		if(suma!=0) suma/=G;
		if(sumb!=0) sumb/=G;
		if(sumb==0){
			zc=2147483647;
			if(minn==zc&&(h[ans1].val<h[i].val||!ans1)) minn=zc,ans1=i;
		}
		else{
			zc=1.0*(double)(suma)/(double)(sumb);
			if(minn>zc) minn=zc,ans1=i;
			else if(minn==zc&&(h[ans1].val<h[i].val||!ans1)) minn=zc,ans1=i;
		}
	}
	printf("%d\n",ans1);
	scanf("%d",&m);
	int x;
	while(m--){
		scanf("%d %d",&x,&x0);
		int suma=0,sumb=0,sum_all=0;
		if(a[x][0]==0||a[x][0]>n||b[x][0]==0||b[x][0]>n){
			printf("%d %d\n",suma,sumb);
			continue;
		}
		for(int j=20;j>=0;j--){
			if(sum_all+way[x][j]<=x0&&f[x][j]!=0&&f[x][j]<=n){
				suma+=A[x][j],sumb+=B[x][j];
				sum_all+=way[x][j];
				x=f[x][j];
			}
		}
		if(sum_all+A[x][0]<=x0&&a[x][0]!=0&&a[x][0]<=n)
			suma+=A[x][0];
		printf("%d %d\n",suma,sumb);
	}
	return 0;
}
```


---

## 作者：Tgotp (赞：2)

好难呀。。。


花了一早上来肝这道题，我认为真心不好做。


首先思路是倍增：


令F[I][J]表示以I出发2^J个点所到达的点


令A[I][J]表示以I出发2^J个点a所行驶的距离


令B[I][J]表示以I出发2^J个点b所行驶的距离


首先，你需要找到n个点距离他最近的点与次近的点。


显而易见，我们不能使用n^2的暴力来枚举，一个想法是二叉搜索树来搞搞。


但是明显太复杂，考虑，因为只需寻找次近与最近，所以可以先排序，用链表连起来。


然后链表的点也要对应回来，因为我们必须由这个点得到i所对应链表的位置。


然后因为是只有从后面往前面走，那么我们就顺次寻找，找完一个删除一个。


值得注意的是，对于一个点 x ，他的最近的点肯定只可能是相邻的任意一个点。


然后我们暂时删除最近的点，此时次近的点依旧是相邻的点。


另外，因为可能越界，即左右两边没有城市了，那么我们还需要进行两次判断，这里具体见代码（就是这里坑了我）。


找完了次近与最近，这时候就可以倍增处理了，倍增处理完了以后，就是一般的倍增问题了。


从高位往低位枚举，然后可以的话就跳。


最后还必须看看a能不能再单独跳一次。


输出答案。


[蒟蒻的题解传送门](http://tgotp.science/noip2012-%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C/ )


c++代码如下：

 
 
 
 
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#define abs(x) x >= 0? x : -(x)
#define rep(i,x,y) for(register int i = x;i <= y;++i)
#define repd(i,x,y) for(register int i = x;i >= y;--i)
using namespace std;
typedef long long ll;
template<typename T>void read(T&x)
{
    x = 0;char c;int sign = 1;
    do { c = getchar(); if(c == '-') sign = -1; }while(c < '0' || c > '9');
    do { x = x * 10 + c - '0'; c = getchar(); }while(c <= '9' &&  c >= '0');
    x *= sign;
}
const int N = 1e5 + 500,inf = (1<<31-1);
int head[N],pre[N],nxt[N],fi[N],se[N];
int n,f[N][32],a[N][32],b[N][32];
struct H
{
    ll num;
    int id;
}h[N];
bool cmp(H a,H b) { return a.num < b.num; }
void solve(int x)
{
    fi[x] = pre[x] && (h[x].num - h[pre[x]].num <= h[nxt[x]].num - h[x].num || !nxt[x]) ? pre[x]:nxt[x];
    if(fi[x] == pre[x])
        se[x] = pre[pre[x]] && (h[x].num - h[pre[pre[x]]].num <= h[nxt[x]].num - h[x].num || !nxt[x]) ? pre[pre[x]] : nxt[x];
    else
        se[x] = pre[x] && (h[x].num - h[pre[x]].num <= h[nxt[nxt[x]]].num - h[x].num || !nxt[nxt[x]]) ? pre[x] : nxt[nxt[x]];
    nxt[pre[x]] = nxt[x];
    pre[nxt[x]] = pre[x];
}
int main()
{
    read(n);
    rep(i,1,n) read(h[i].num),h[i].id = i;
    sort(h+1,h+1+n,cmp);
    rep(i,1,n) {
        head[h[i].id] = i;
        pre[i] = i - 1;
        nxt[i] = i + 1;
        if(i == n) nxt[i] = 0;
    }
    rep(i,1,n)
        solve(head[i]);
    rep(i,1,n)
    {
        int x = head[i];
        if(se[x]) a[x][0] = abs(h[x].num - h[se[x]].num);
        if(fi[x]) b[x][0] = abs(h[se[x]].num - h[fi[se[x]]].num);
        f[x][0] = fi[se[x]];
    }
    rep(i,1,30)
        rep(u,1,n)
            f[u][i] = f[f[u][i-1]][i-1],
            a[u][i] = a[u][i-1] + a[f[u][i-1]][i-1],
            b[u][i] = b[u][i-1] + b[f[u][i-1]][i-1];
    int x,ans_num;
    double ans = inf,temp;
    read(x);
    rep(j,1,n)
    {
        int u = head[j]; int z = x;
        int xa = 0, xb = 0;
        repd(i,30,0)
        {
            if(f[u][i] && z >= a[u][i] + b[u][i])
            {
                z = z - a[u][i] - b[u][i];
                xa += a[u][i];
                xb += b[u][i];
                u = f[u][i];
            }
        }
        if( a[u][0] <= z && se[u])
            xa += a[u][0];
        if(xb == 0) temp = inf;
        else temp = (double)xa/xb;
        if(temp < ans || (temp == ans && h[head[j]].num > h[head[ans_num]].num))
            ans_num = j,ans = temp;
    }
    printf("%d\n",ans_num);
    int m;read(m);
    while(m--)
    {
        int u,z;
        read(u),read(z);
        u = head[u];
        int xa = 0, xb = 0;
        repd(i,30,0)
        {
            if(f[u][i] && z >= a[u][i] + b[u][i])
            {
                z = z - a[u][i] - b[u][i];
                xa += a[u][i];
                xb += b[u][i];
                u = f[u][i];
            }
        }
        if( a[u][0] <= z && se[u] )
            xa += a[u][0];
        printf("%d %d\n",xa,xb);
    }
    return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：2)

这是一篇写的比较详细的题解，借鉴了《算法竞赛指南进阶》的内容，笔者会引导读者从多种角度思考问题的解（luan）决 (gao) 方法，希望对你有所帮助。

## 分析问题

仔细读题后，我们通过对第二类问题的形式分析，可以发现题目给出的两类问题本质上都可以**转化**为以下形式再解决：

如果两人从城市 $s$ 为起点最多行驶长为 $X$ 的距离，他们开车行驶的距离分别是多少？

在这里，我们用 $da(s,X)$ 与 $db(s,X)$ 表示此时小 A 与小 B 行驶过的路程，以便以后续分析。

做了这样的转化后，两类问题本质如下：

- 询问从每个城市 $i$ 开始 $\Large \frac{da(i,X_0)}{db(i,X_0)}$ 的最大值。

- 多次询问 $da(s,X)$ 与 $db(s,X)$ 的值。

所以我们解决本题的关键在于**快速计算** $da(s,X)$ 与 $db(s,X)$ 的值。

## 预处理

我们通过对问题的分析，知道了两类问题的本质。现在摆在面前的问题有两个：

1. 小 A 和小 B 在城市 $i$ 时行驶到的下一座城市是什么。

2. 某组问题下，两人行驶的距离分别是多少。

要解决第二个问题，就绕不开第一个问题。所以我们首先需要预处理出两人在城市 $i$ 分别行驶的下一座城市是什么，这里记作 $ga_i$ 与 $gb_i$.

解决这个问题其实有一个力大砖飞的做法，我们开个 set 倒序处理问题，每次查找前驱和后继，但是这里介绍一个比较精妙的链表做法。

首先我们分析 $|h_i-h_j|$ 的性质，对于一个确定的 $i$，实际上能成为它最小值的数只有两个：第一个小于等于 $h_i$ 的数与第一个大于等于 $h_i$ 的数。这里把他们分别设为前驱 $pre_i$ 与后继 $nxt_i$。

为了求出前驱 $pre_i$ 与后继 $nxt_i$。我们不妨将 $h$ 升序排序，然后记 $rnk_i$ 表示第 $i$ 座城市的排名。

考虑求 $ga_i$ 与 $gb_i$ 的过程，此时前驱和后继都可能成为 $gb_i$，采用比较距离谁更小的方法进行判断。而对于 $ga_i$ 的求法就稍微复杂一点了，它的决策和 $gb_i$ 的取值有关，所以采用分类讨论来进行求解：

- 当 $gb_i = pre_i$ 时，说明此时的候选点可以是后继 $nxt_i$ 或者 $pre_i$ 的前驱，需要进行比较判断。

- 当 $gb_i = nxt_i$ 时，说明此时的候选点可以是前驱 $pre_i$ 或者 $nxt_i$ 的后继，需要进行比较判断。

```cpp
int getid(int id,int x,int y){//这个函数实现了判断对应定点id，x,y两个点谁更优 
	if(!x||!y)return a[x+y].id;//注意需要判断是否存在 
	if(a[id].val-a[x].val<=a[y].val-a[id].val)return a[x].id;
	return a[y].id;
}
```

这样就大功告成了？其实不然，因为两人只能去往 $i$ 后面的城市 $j$，而刚刚的算法没有考虑到这个问题，这样就影响了答案的正确性。

这个问题其实很好解决。实际上我们需要的只是在计算第 $i$ 个城市的答案后把它的影响撤销掉，这样就可以消除对答案的影响，所以这里我们采用更为简单的**双向链表**的方式实现。

```cpp
	for(int i = 1;i <= n;i++)pos[a[i].id]=i,a[i].pre=i-1,a[i].nxt=i+1;a[1].pre=a[n].nxt=0;//预处理rnk(这里是pos),以及链表 
	for(int i = 1;i < n;i++){//这里采用分数通分的方法解决问题 
		int id=pos[i],l=a[id].pre,r=a[id].nxt;
		if(l&&(a[id].val-a[l].val<=a[r].val-a[id].val||!r))gb[i]=a[l].id,ga[i]=getid(id,a[l].pre,r);//gb(i)=pre[i] 
		else gb[i]=a[r].id,ga[i]=getid(id,l,a[r].nxt);//gb(i)=nxt[i]
		if(l)a[l].nxt=r;//删除 
		if(r)a[r].pre=l;
	}
```

这个算法流程的时间复杂度为 $O(n)$。**注意**，因为我们这里排了序，所以我们求 $i$ 的答案时，链表上对应的位置实际上为 $rnk_i$，不要搞混了。

## 动态规划

现在需要求解 $da(s,X)$ 与 $db(s,X)$ 的值，这里我们考虑采用动态规划。

以 $da(s,X)$ 的转移为例，我们设 $da_{i,j,0/1}$ 表示从第 $i$ 座城市开始，行驶时间是 $j$ 天，现在是小 A 还是小 B 在开车。我们设上一座城市为 $k$，转移如下：

- $da_{i,j,0} = da_{k,j-1,1}+|h_i-h_k|(j>1)$。这里表示此时小 B 和小 A 换班，然后加上城市的距离。

- $da_{i,j,1} = da_{k,j-1,0}+|h_i+h_k|(j>1)$。这里表示此时小 A 和小 B 换班，然后加上城市的距离。

这个 dp 显然是 $O(n^2)$ 量级的，而我们查询一组 $(s,X)$ 的答案所花费的时间是 $O(n)$ 的，这并不够优秀。

优化动态规划一般我们就只从两个方向入手：优化状态设计与加速状态转移。这里我们先分析加速状态转移的做法，可以考虑采纳矩阵加速法，但是由于上一个城市的量级为 $O(n)$，直接使用使得这个算法反而还更劣。笔者并没有想到对应的优化方法，有方法的读者可以提出。

既然优化转移不行，那我们就从优化状态设计的角度下功夫。首先发现这三维状态好像都不省不掉的，但是可以优化表达方式。

我们考虑第一维 $i$ 和第三维 $k$，发现好像都不太能简化，但是第二维 $j$ 似乎可以。我们发现 $j$ 的大小与行驶的路程的大小相关，所以我们可以考虑**二进制拆分**的思想计算答案。

把 $j$ 改写为二进制位的形式，这样状态设计就变为了：现在行驶到了第 $i$ 座城市，行驶时间是 $2^j$ 天，现在是小 A 还是小 B 在开车。

这样我们同时需要知道 $2^j$ 天后所跳跃到的城市。同理我们也可以设 $f_{i,j,k}$ 表示对应状态所跳跃到的城市。此时三个数组的转移稍有不同，需要分析 $j=1$ 时 $k$ 的取值，这里请读者根据上述分析自行推导，后文会写出对应转移。

你推出来了吗？仔细看看是不是这样。~~对推不出来的读者还是挺有恶趣味的。~~

$f_{i,j,k} = \begin{cases}
 f_{i,0, 1-k} &j=1 \\f_{i,f_{i,j-1,k},k} & j>1 \end{cases}$

$da_{i,j,k} = \begin{cases}
 da_{i,0, k}+da_{f_{i,0,k},0,1-k} &j=1 \\da_{i,j-1,k}+da_{f_{i,j-1,k},j-1,k}& j>1 \end{cases}$

$db_{i,j,k} = \begin{cases}
 db_{i,0, k}+db_{f_{i,0,k},0,1-k} &j=1 \\db_{i,j-1,k}+db_{f_{i,j-1,k},j-1,k}& j>1 \end{cases}$

当 $j=0$ 需要初始化，这部分代码如下。

```cpp
	for(int i = 1;i <= n;i++){
		f[0][i][0]=ga[i],f[0][i][1]=gb[i];
		if(ga[i])da[0][i][0]=abs(a[pos[i]].val-a[pos[ga[i]]].val);
		if(gb[i])db[0][i][1]=abs(a[pos[i]].val-a[pos[gb[i]]].val);
	}//初始化 
	for(int j = 1;j <= 30;j++){
		for(int i = 1;i <= n;i++){
			for(int k = 0;k <= 1;k++){
				int num=(j==1?k^1:k);
				f[j][i][k]=f[j-1][f[j-1][i][k]][num];
				if(!f[j][i][k])continue;
				da[j][i][k]=da[j-1][i][k]+da[j-1][f[j-1][i][k]][num];
				db[j][i][k]=db[j-1][i][k]+db[j-1][f[j-1][i][k]][num];
			}
		}
	}//状态转移 
```

实际上这就是**倍增**的过程，像这样利用二进制分组来动态规划的方法我们称之为**倍增优化 dp**。

## 查询答案

查询答案就好办了。对于一组 $(s,X)$，我们从高到低枚举二进制位，在路程不超过 $X$ 的情况下直接跳跃即可。具体实现可以采用一个结构体存储 $da(s,X)$ 与 $db(s,X)$ 的值，此时这里需要注意转移到第 $0$ 位时开车的人。

```cpp
ques calc(int st,int X){
	int dis1=0,dis2=0,op = 0;
	for(int i = 30;i >= 0;i--){
		if(dis1+dis2+da[i][st][op]+db[i][st][op]<=X&&f[i][st][op]){
			dis1+=da[i][st][op],dis2+=db[i][st][op];
			st=f[i][st][op],op=(!i?op^1:op);//注意这里由于i=0说明是另一个人开车
		}
	}return (ques){dis1,dis2};
}
```

这样我们单次处理一组 $(s,X)$ 的答案的复杂度为 $O(\log n)$。总体的时间复杂度就是 $O((n+q)\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
struct Point{
	int val,id,nxt,pre;
}a[N];
struct ques{
	int x,y;
};
int n,m,st,X,l,lg[N],r,ga[N],gb[N],f[31][N][2],da[31][N][2],db[31][N][2];
bool cmp(Point x,Point y){
	return x.val<y.val;
}int pos[N];
int getid(int id,int x,int y){//这个函数实现了判断对应定点id，x,y两个点谁更优 
	if(!x||!y)return a[x+y].id;//注意需要判断是否存在 
	if(a[id].val-a[x].val<=a[y].val-a[id].val)return a[x].id;
	return a[y].id;
}
ques calc(int st,int X){
	int dis1=0,dis2=0,op = 0;
	for(int i = 30;i >= 0;i--){
		if(dis1+dis2+da[i][st][op]+db[i][st][op]<=X&&f[i][st][op]){
			dis1+=da[i][st][op],dis2+=db[i][st][op];
			st=f[i][st][op],op=(!i?op^1:op);
		}
	}return (ques){dis1,dis2};
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;lg[0]=-1;
	for(int i = 1;i <= n;i++)cin >> a[i].val,a[i].id=i,lg[i]=lg[i>>1]+1;sort(a+1,a+1+n,cmp);
	for(int i = 1;i <= n;i++)pos[a[i].id]=i,a[i].pre=i-1,a[i].nxt=i+1;a[1].pre=a[n].nxt=0;//预处理rnk(这里是pos),以及链表 
	for(int i = 1;i < n;i++){//这里采用分数通分的方法解决问题 
		int id=pos[i],l=a[id].pre,r=a[id].nxt;
		if(l&&(a[id].val-a[l].val<=a[r].val-a[id].val||!r))gb[i]=a[l].id,ga[i]=getid(id,a[l].pre,r);//gb(i)=pre[i] 
		else gb[i]=a[r].id,ga[i]=getid(id,l,a[r].nxt);//gb(i)=nxt[i]
		if(l)a[l].nxt=r;//这里也需要需要判断是否存在 
		if(r)a[r].pre=l;
	}
	for(int i = 1;i <= n;i++){
		f[0][i][0]=ga[i],f[0][i][1]=gb[i];
		if(ga[i])da[0][i][0]=abs(a[pos[i]].val-a[pos[ga[i]]].val);
		if(gb[i])db[0][i][1]=abs(a[pos[i]].val-a[pos[gb[i]]].val);
	}//初始化 
	for(int j = 1;j <= 30;j++){
		for(int i = 1;i <= n;i++){
			for(int k = 0;k <= 1;k++){
				int num=(j==1?k^1:k);
				f[j][i][k]=f[j-1][f[j-1][i][k]][num];
				if(!f[j][i][k])continue;
				da[j][i][k]=da[j-1][i][k]+da[j-1][f[j-1][i][k]][num];
				db[j][i][k]=db[j-1][i][k]+db[j-1][f[j-1][i][k]][num];
			}
		}
	}//状态转移 
	cin >> X >> m;
	ques ans1=calc(1,X);int id=1;
	for(int i = 2;i <= n;i++){
		ques tmp=calc(i,X);if(!tmp.y)tmp.x=1;
		if(ans1.y*tmp.x<tmp.y*ans1.x||(ans1.y*tmp.x==tmp.y*ans1.x&&a[pos[i]].val>a[pos[id]].val))id=i,ans1=tmp;
	}cout << id << "\n";
	for(int i = 1;i <= m;i++){
		cin >> st >>X;ans1=calc(st,X);
		cout << ans1.x << " " << ans1.y << "\n";
	}
	return 0;
}

```

---

## 作者：algo_h (赞：2)

本题解借助 STL `map` 维护每个城市后续所有城市的海拔和编号，来预处理 A 和 B 二人各自对旅途中每个城市下一站的决策（分别对应变量 $A$ 和 $B$），总开销 $O(n\log n)$，虽然常数稍大，但实现较为简单方便。

具体地，设 $\mathrm{heights}$ 为当前城市后续所有城市的海拔向编号的映射，类型为 `map<int, int>`，初始化为空。
从右向左遍历每个城市，根据当前城市的海拔，利用 `upper_bound` 方法找到后续城市中海拔更高且最接近的城市（或因找不到而得到 $\mathrm{heights.end()}$），然后在边界范围内扩展至左右长度（以增减迭代器计）均不超过 $2$ 的邻域，此时可以确定该邻域一定包含了可能的最近和次近城市，在其范围内搜索即可确定答案。以上流程处理完毕后将当前城市加入 $\mathrm{heights}$ 中，以供后续迭代步骤使用。

在此基础上，可以从 $i = 0$ 开始倍增出由 A 先开车，连续访问后续 $2^i$ 个城市，最终将到达的城市以及 A 和 B 各自行驶的距离。后续只需借助倍增结果进行模拟和简单枚举，便可快速得到答案，总的复杂度是 $O((n + m)\log n)$。

```c++
#include <algorithm>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

#define long long long

int n;
vector<int> H;  // 海拔
vector<int> A;  // 第二近的后续城市下标
vector<int> B;  // 最近的后续城市下标

// 存储终点和 A, B 各自行驶的距离
vector<vector<tuple<int, long, long>>> AD;  // [i, j] -> A 从 j 出发，走 2^i 步
vector<vector<tuple<int, long, long>>> BD;  // [i, j] -> B 从 j 出发，走 2^i 步

void init()
{
  // 预处理 A 和 B 在每个位置处的选择
  A.resize(n), B.resize(n);
  A[n - 1] = B[n - 1] = -1;

  // 维护当前城市所有后续城市海拔的有序集合
  map<int, int> heights;  // [height] -> index
  heights.emplace(H[n - 1], n - 1);

  for(int i = n - 2; i >= 0; --i) {
    // 寻找距离最近和第二近的可达位置
    vector<pair<long, int>> cands;              // 最近和次近候选 (dist, index)
    cands.reserve(4);                           // 最多搜索 4 个元素
    auto r = heights.upper_bound(H[i]), l = r;  // 确定搜索邻域中心
    if(r != heights.end()) ++r;                 // 确定搜索范围
    if(r != heights.end()) ++r;
    if(l != heights.begin()) --l;
    if(l != heights.begin()) --l;
    for(; l != r; ++l) {
      long dist = (labs(l->first - H[i]) << 1) | (l->first > H[i]);  // 低海拔优先
      cands.emplace_back(dist, l->second);
    }
    if(cands.size() > 1) nth_element(cands.begin(), cands.begin() + 1, cands.end());
    B[i] = cands[0].second;
    A[i] = cands.size() > 1 ? cands[1].second : -1;
    //cout << "A: " << i + 1 << " -> " << A[i] + 1 << endl;
    //cout << "B: " << i + 1 << " -> " << B[i] + 1 << endl;
    heights.emplace(H[i], i);
  }

  // 倍增起点：走 2^0 步
  int log_l = 31 - __builtin_clz(max(n - 1, 1));
  AD.resize(log_l + 1), BD.resize(1);  // BD 在后续不会用到，不需倍增
  AD[0].assign(n, { -1, 0, 0 }), BD[0].assign(n, { -1, 0, 0 });
  for(int j = 0; j < n - 1; ++j) {
    if(A[j] >= 0) AD[0][j] = { A[j], abs(H[j] - H[A[j]]), 0 };
    if(B[j] >= 0) BD[0][j] = { B[j], 0, abs(H[j] - H[B[j]]) };
  }

  // 倍增
  for(int i = 1; i <= log_l; ++i) {
    AD[i].assign(n, { -1, 0, 0 });
    for(int j = 0; j < n - (1 << i); ++j) {
      auto [at, aa, ab] = AD[i - 1][j];
      if(at < 0) continue;
      auto [bt, ba, bb] = i == 1 ? BD[i - 1][at] : AD[i - 1][at];
      AD[i][j] = { bt, aa + ba, ab + bb };
    }
  }
}

// 给定起点和最长行驶距离，计算 A 和 B 各自的行驶距离
pair<long, long> compute(int s, int x)
{
  long ca = 0, cb = 0;
  for(int i = AD.size() - 1; i >= 0; --i) {  // 走 2^i 步
    auto [t, a, b] = AD[i][s];               // 保证永远都到 A 开车
    if(t < 0) continue;
    if(a + b > x) continue;
    x -= a + b;
    s = t;
    ca += a, cb += b;
  }
  return { ca, cb };
}

void solve(int x)
{
  int sm = 0;
  auto [cam, cbm] = compute(sm, x);
  //cout << sm << ": " << cam << " : " << cbm << endl;
  for(int s = 1; s < n; ++s) {
    auto [ca, cb] = compute(s, x);
    //cout << s << ": " << ca << " : " << cb << endl;
    if(cb == 0 && cbm == 0) {  // 均为正无穷
      if(H[s] > H[sm]) sm = s, cam = ca, cbm = cb;
    } else if(cb == 0) {  // 原来非正无穷，现在为正无穷
      // 空
    } else if(cbm == 0) {  // 原来为正无穷，现在非正无穷
      sm = s, cam = ca, cbm = cb;
    } else {  // 均非正无穷
      __int128_t u = (__int128_t)ca * cbm, v = (__int128_t)cb * cam;
      if(u < v || (u == v && H[s] > H[sm])) sm = s, cam = ca, cbm = cb;
    }
  }
  cout << sm + 1 << endl;
}

void solve(int s, int x)
{
  auto [ca, cb] = compute(s, x);
  cout << ca << " " << cb << endl;
}

int main()
{
  cin.tie(0)->sync_with_stdio(0);
  cin >> n;
  H.resize(n);
  for(int &h : H) cin >> h;
  int x;
  cin >> x;
  init();
  solve(x);
  int m;
  cin >> m;
  while(m--) {
    int s;
    cin >> s >> x, --s;
    solve(s, x);
  }
  return 0;
}
```

---

## 更新记录

### 25/1/9 01:26 更新对“正无穷”比例的特判

感谢 [这篇帖子](https://www.luogu.com.cn/discuss/881261) 提供的参考。注意题目中所规定的“正无穷”比例，包括任意整数比零，特别是包括零比零。

给审核人员添麻烦了。

---

## 作者：qhr2023 (赞：2)

## solution

一道麻烦的倍增优化 dp，在算法竞赛进阶指南里作为倍增优化 dp 的例题。

### 分析

题目说，小 A 和小 B 轮流走，其中小 A 先走，每次走到与当前城市次近的城市，小 B 每次走到与当前城市最近的城市，所以只要起点固定，路线就一定固定。

再看一下设问。
* 第一问是给定总里程 $X$ 求能使小 A 和小 B 路程比最小的起点 $S$。
* 第二问是给 $m$ 组起点 $S$ 和总里程 $X$，求两人各自走过的距离。

对于第一问我们枚举起点就好了。这样两个问题就都变成了起点为 $S$ 里程 $X$ 时小 $A$ 和小 $B$ 分别走过的距离。

由于每个 $S$ 都有唯一的路线，路线是好预处理的，所以我们只要对 $X$ 处理一下降低复杂度，问题就可以做了。

对于这个 $X$ 我们可以二进制拆分。假设我们知道路线，也就是走 $2^i$ 步到哪个城市，并且知道走了 $2^i$ 步两人各自走过的距离。对于每组 $S$ 和 $X$，只要行驶路程没到 $X$ 且不到边界，也就是保证合法，那两人的路程一直加就好，同时更新起点。这样就可以以 $\log$ 级别的复杂度解决单词询问。

总结一下我们要用到的数组。

* $GA_i$ 表示从城市 $i$ 出发，小 A 会走到的城市，即当前城市的次近城市。
* $GB_i$ 表示从城市 $i$ 出发，小 B 会走到的城市，即当前城市的最近城市。
* $f_{i, j, k}$ 表示 $k$ 先出发，从城市 $j$ 走 $2^i$ 后到达的城市编号，$k=0/1$ 表示小 A 或小 B。
* $DA_{i, j, k}$ 表示 $k$ 先出发，从城市 $j$ 走 $2^i$ 步后，小 A 走过的总距离。
* $DB_{i, j, k}$ 表示 $k$ 先出发，从城市 $j$ 走 $2^i$ 步后，小 B 走过的总距离。

难点在想到倍增，和预处理这些数组。下面详细讲解预处理部分。

### 预处理 $GA$ 和 $GB$

这个过程可以看成[邻值查找](https://www.luogu.com.cn/problem/P10466)问题，要在一个有序数列中求出和 $i$ 最接近和次接近的值。

![](https://cdn.luogu.com.cn/upload/image_hosting/apa1s2hx.png)

若 $a<b<c<d$，且 $b$ 是最大的小于等于 $i$ 的值，$c$ 是最小的大于等于 $i$ 的值，那么最接近 $i$ 的一定是 $b$ 或 $c$。
* 当 $b$ 最接近 $i$ 时，同理与 $i$ 次接近的就应是与 $b$ 相邻的 $a$ 或 $c$。
* 当 $c$ 最接近 $i$ 时，同理与 $i$ 次接近的就应是与 $c$ 相邻的 $b$ 或 $d$。

所以我们知道，不管是哪种情况，与 $i$ 最近和次近的值一定在这四个里，所以我们可以找到这四个点，然后遍历一遍找最近和次近。

对于实现，可以用一个 ```set``` 维护该城市的高度和编号，记作 $S$。因为要从前往后走，所以我们从后往前预处理，每次处理完当前，就把当前点加入 $S$。找四个点，可以先找最大的小于等于 $i$ 的，然后相邻的几个就是了。

$S$ 最开始要加进去两个极小值和两个极大值，避免第一次找的时候出问题。

### 预处理 $f$

初始化 $f_{0, j, 0}=ga_j$，也就是小 A 从城市 $j$ 走了 $1$ 步后到达的城市。那么类似的，小 B 从城市 $j$ 走了 $1$ 步后到达的城市就是 $gb_j$，即 $f_{0, j, 1}=gb_j$。

考虑转移，经典的倍增。
* $i=1$ 时，即 $k$ 从城市 $j$ 开始走 $2$ 步，就相当于 $k$ 从城市 $j$ 开始先走 $1$ 步，到达城市 $f_{0, j, k}$，此时应该换下一个人 $1-k$ 走了，$1-k$ 从 $f_{0, j, k}$ 出发再走 $1$ 步，那么也就走到了 $f_{0, f_{0, j, k}, 1-k}$。所以转移就是，$f_{1, j, k}=f_{0, f_{0, j, k}, 1-k}$。
* $i>1$ 时，即从城市 $j$ 开始走 $2^i$ 步，就相当于从城市 $j$ 开始先走 $2^{i-1}$ 步，到达城市 $f_{i-1, j, k}$，此时 $2^{i-1}$ 一定是偶数，由于两人是一人走一次这么轮着走的，那么走了偶数步后就相当于还是同一个人，从 $f_{i-1, j, k}$ 出发再走 $2^{i-1}$ 步，那么就走到了 $f_{i-1, f_{i-1, j, k}, k}$。所以转移就是，$f_{i, j, k}=f_{i-1, f_{i-1, j, k}, k}$。

为了方便观看，整理了一下转移。

* 当 $i=0$ 时，$f_{0, j, 0/1}=GA_j/GB_j$。

* 当 $i=1$ 时，$f_{1, j, k}=f_{0, f_{0, j, k}, 1-k}$。

* 当 $i>1$ 时，$f_{i, j, k}=f_{i-1, f_{i-1, j, k}, k}$。

### 预处理 $DA$ 和 $DB$

初始化和转移类似前面 $f$ 的处理，这里就不再赘述了。核心就是走 $2^i$ 就相当于先走 $2^{i-1}$ 步，再走 $2^{i-1}$ 步。

我们记 $dis(i, j)$ 表示城市 $i$ 和 $j$ 的距离。

* 当 $i=0$ 时的初始化：
  * $DA_{0, j, 0}=dis(j, GA_j)$。
  * $DA_{0, j, 1}=0$。
  * $DB_{0, j, 0}=0$。
  * $DB_{0, j, 1}=dis(j, GB_j)$。

* 当 $i=1$ 时的转移（此时要注意 $k$ 的变化）：
  * $DA_{1, j, k}=DA_{0, j, k}+DA_{0, f_{0, j, k}, 1-k}$。
  * $DB_{1, j, k}=DB_{0, j, k}+DB_{0, f_{0, j, k}, 1-k}$。

* 当 $i>1$ 时的转移： 
  *  $DA_{i, j, k}=DA_{i-1, j, k}+DA_{i-1, f_{i-1, j, k}, k}$。
  *  $DB_{i, j, k}=DB_{i-1, j, k}+DB_{i-1, f_{i-1, j, k}, k}$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+5;
const ll INF=1e12;
int n, m, h[N], ga[N], gb[N], f[20][N][2];
ll da[20][N][2], db[20][N][2];
void iint_g () {
	set<pair<ll, int>> s;
	s.insert({INF, 0}), s.insert({INF+1, 0});
	s.insert({-INF, 0}), s.insert({-INF-1, 0});
	for (int i=n; i; --i) {
		auto j=s.lower_bound({h[i], i});
		j++;
		vector<pair<ll, int>> v;
		for (int i=0; i<4; ++i, --j)
			v.push_back(*j);
		ll d1=INF, d2=INF;
		int p1=0, p2=0;
		for (int k=3; k>=0; k--) {
			ll d=abs(h[i]-v[k].first);
			if (d<d1)
				d2=d1, p2=p1, d1=d, p1=v[k].second;
			else if (d<d2)
				d2=d, p2=v[k].second;
		}
		ga[i]=p2, gb[i]=p1;
		s.insert({h[i], i});
	}
}
void iint_f () {
	for (int j=1; j<=n; ++j)
		f[0][j][0]=ga[j], f[0][j][1]=gb[j];
	for (int i=1; i<18; ++i) 
		for (int j=1; j<=n; ++j) 
			for (int k=0; k<2; ++k)
				if (i==1) 
					f[1][j][k]=f[0][f[0][j][k]][1-k];
				else 
					f[i][j][k]=f[i-1][f[i-1][j][k]][k];
}
void iint_d () {
	for (int j=1; j<=n; ++j)
		da[0][j][0]=abs(h[j]-h[ga[j]]), da[0][j][1]=0,
		db[0][j][0]=0, db[0][j][1]=abs(h[j]-h[gb[j]]);
	for (int i=1; i<18; ++i) 
		for (int j=1; j<=n; ++j) 
			for (int k=0; k<2; ++k)
				if (i==1) 
					da[1][j][k]=da[0][j][k]+da[0][f[0][j][k]][1-k],
					db[1][j][k]=db[0][j][k]+db[0][f[0][j][k]][1-k];
				else 
					da[i][j][k]=da[i-1][j][k]+da[i-1][f[i-1][j][k]][k],
					db[i][j][k]=db[i-1][j][k]+db[i-1][f[i-1][j][k]][k];
}
void calc (int s, int x, int &la, int &lb) {
	la=lb=0;
	for (int i=17; i>=0; --i) 
		if (f[i][s][0]&&la+lb+da[i][s][0]+db[i][s][0]<=x) 
			la+=da[i][s][0], 
			lb+=db[i][s][0],
			s=f[i][s][0];
}
int main () {
	cin >> n;
	for (int i=1; i<=n; ++i)
		cin >> h[i];
	iint_g(); iint_f(); iint_d();
	int s, x, res=0, mx=0, la=0, lb=0;
	double mi=INF;
	cin >> x;
	for (int i=1; i<=n; ++i) {
		calc(i, x, la, lb);
		double t=(lb?(double)la/lb:INF);
		if (t<mi||(t==mi&&h[i]>mx))
			mi=t, mx=h[i], res=i;
	}
	cout << res << '\n';
	for (cin >> m; m--; ) 
		cin >> s >> x,
		calc(s, x, la, lb),
		cout << la << ' ' << lb << '\n';
	return 0;
}
```

---

## 作者：Swirl (赞：1)

如此经典的题目现在才做，惭愧，惭愧。

---

倍增。

后文用 $a$ 数组代替 $h$ 数组，~~这样方便点~~。


### 壹

不难发现这题不带修而且每次轮流驾车的终点都是可以确定的。

可以对每一个城市都预处理出 A 驾车的目的地和 B 驾车的目的地，记为 $na$、$nb$。

也就是对于每一个 $i$ 都确定 $a_{i + 1}$ 到 $a_n$ 中 $a_i$ 的前驱、后继、前驱的前驱、后继的后继。

~~一个 splay 解决了好吧。~~

不要用暴力的平衡树，尝试用线性做法。

将 $a$ 排序后放到**双向链表**中，此时链表中任意一个数的前驱便是原数组中该数的前驱，后继同理，非常简单。

而因为前驱后继的范围在 $i + 1$ 到 $n$，所以第 $i$ 个数算完就删掉。

### 贰

因为每个城市的下一个城市都已确定好，所以可以通过倍增的方式加速。

记 $dp_{i, j, k}$ 为从 $j$ 开始，走 $2^i$ 次，由 $k$ 先走（$k \in \{ 0, 1 \}$，$0$ 代表 A，$1$ 代表 B）到达的城市。

同理，记 $A_{i, j, k}$ 和 $B_{i, j, k}$ 代表 A 走的距离和 B 走的距离。

---

先赋初值：

$$
dp_{0, i, 0} = na_i\\
dp_{0, i, 1} = nb_i
$$

很显然不赘述。

同理：

$$
\begin{align*}
A_{0, i, 0} &= d_{i, na_i}\\
A_{0, i, 1} &= 0\\
B_{0, i, 0} &= d_{i, nb_i}\\
B_{0, i, 1} &= 0
\end{align*}
$$

### 叁

考虑如何转移。

像普通的倍增一样，有：

$$
dp_{i, j, k} = 
\left\{
\begin{align*}
%\nonumber
dp_{i - 1, dp_{i - 1, j, k}, \~k} &, i = 1\\
dp_{i - 1, dp_{i - 1, j, k}, k} &, \text{others}
\end{align*}
\right.
$$

因为 $2^1 - 2^0 = 1$，是奇数，会反转驾车的人，所以要特判 $i = 1$ 的情况。

同理：

$$
A_{i, j, k} = 
\left\{
\begin{align*}
%\nonumber
A_{i - 1, j, k} + A_{i - 1, dp_{i - 1, j, k}, \~k} &, i = 1\\
A_{i - 1, j, k} + A_{i - 1, dp_{i - 1, j, k}, k} &, \text{others}
\end{align*}
\right.
$$

类似带权 LCA，将其拆成两段处理。

$$
B_{i, j, k} = 
\left\{
\begin{align*}
%\nonumber
B_{i - 1, j, k} + B_{i - 1, dp_{i - 1, j, k}, \~k} &, i = 1\\
B_{i - 1, j, k} + B_{i - 1, dp_{i - 1, j, k}, k} &, \text{others}
\end{align*}
\right.
$$

（因为懒得写异或，所以干脆把 $\~k$ 拿来表示取反）

### 肆

定义一个计算从 $s$ 出发且总距离不超过 $x$ 的函数 calc，返回 A 和 B 分别的驾车距离。

没啥好说的，枚举拆位然后跳即可。

---

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

inline void cmax(int &x, int c) {
	x = max(x, c);
}
inline void cmin(int &x, int c) {
	x = min(x, c);
}

int _test_ = 1;

const int N = 1e5 + 5;

int n, nA[N], nB[N], id[N], dp[18][N][2], A[18][N][2], B[18][N][2];
// id 为原数组对应到链表上的编号
struct node {
	int prev, next, id; // 前驱后继和编号
	int v; // 值
	node() {}
	node(int V) {
		v = V;
	}
	node(int a, int b, int c) {
		prev = a, next = b, v = c;
	}
} l[N];

int c(int x, int y, int i) { // 从 x 和 y 中选一个更小的
	if (!x)
		return l[y].id;
	if (!y)
		return l[x].id;
	if (l[x].v > l[y].v)
		swap(x, y);
	if (abs(l[x].v - l[i].v) <= abs(l[y].v - l[i].v))
		return l[x].id;
	return l[y].id;
}
void del(int x) { // 删点
	int pre = l[x].prev, nxt = l[x].next;
	l[pre].next = nxt, l[nxt].prev = pre;
}
pii calc(int s, int x) { // 计算
	int a = 0, b = 0, k = 0;
	for (int i = 17; i >= 0; i--) {
		if (dp[i][s][k] && A[i][s][k] + B[i][s][k] <= x) {
			x -= A[i][s][k] + B[i][s][k];
			a += A[i][s][k], b += B[i][s][k];
			if (i == 0)
				k ^= 1;
			s = dp[i][s][k];
		}
	}
	return {a, b};
}

void init() {}

void clear() {}

void solve() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> l[i].v;
		l[i].id = i;
	}
	sort(l + 1, l + n + 1, [&](node x, node y) {
		return x.v < y.v;
	});
	for (int i = 1; i <= n; i++) {
		l[i].prev = i - 1, l[i].next = i + 1;
		id[l[i].id] = i;
	}
	l[n].next = 0;
	for (int i = 1; i <= n; i++) {
		int x = id[i], pre = l[x].prev, nxt = l[x].next;
		if (pre && (!nxt || abs(l[pre].v - l[x].v) <= abs(l[nxt].v - l[x].v))) {
			nB[i] = l[pre].id;
			nA[i] = c(l[pre].prev, nxt, x);
		} else {
			nB[i] = l[nxt].id;
			nA[i] = c(l[nxt].next, pre, x);
		}
		del(x);
		dp[0][i][0] = nA[i];
		dp[0][i][1] = nB[i];
		A[0][i][0] = abs(l[id[i]].v - l[id[nA[i]]].v);
		B[0][i][1] = abs(l[id[i]].v - l[id[nB[i]]].v);
		A[0][i][1] = 0;
		B[0][i][0] = 0;
	}
	for (int i = 1; i <= 17; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 0; k <= 1; k++) {
				int sta = (i == 1) ? (k ^ 1) : k;
				dp[i][j][k] = dp[i - 1][dp[i - 1][j][k]][sta];
				A[i][j][k] = A[i - 1][j][k] + A[i - 1][dp[i - 1][j][k]][sta];
				B[i][j][k] = B[i - 1][j][k] + B[i - 1][dp[i - 1][j][k]][sta];
			}
		}
	}
	int x;
	cin >> x;
	pii ans = {1, 0};
	int ans_id = 0;
	for (int i = 1; i <= n; i++) { // 枚举起点
		auto p = calc(i, x);
		if (!p.second)
			p.first = 1;
		if (l[id[i]].v > l[id[ans_id]].v && p.first * ans.second == p.second * ans.first) {
			ans_id = i;
		}
		if (p.first * ans.second < p.second * ans.first) { // 避免分数计算
			ans = p;
			ans_id = i;
		}
	}
	cout << ans_id << "\n";
	int m;
	cin >> m;
	while (m--) {
		int s, x;
		cin >> s >> x;
		auto p = calc(s, x);
		cout << p.first << " " << p.second << "\n";
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	//	cin >> _test_;
	init();
	while (_test_--) {
		clear();
		solve();
	}
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：1)

上古老题。

第一步显然是要预处理出在每一个位置上时小 A 和小 B 分别会去哪里。

如何处理呢？考虑使用 `set` 或者链表倒着删处理出前驱和后继，这样就可以在 $O(n\log n)/O(n)$ 的时间内预处理。

第二步显然是根据刚才的预处理回答两个问题。考虑倍增，预处理出 $f_{i,j}$ 表示从 $i$ 走 $2^j$ 步到哪，预处理出 $A_{i,j}$ 和 $B_{i,j}$ 表示走 $2^j$ 途中小 A 小 B 行驶的路程。

查询时直接 $O(\log n)$ 直接跳就好了。

总时间复杂度为 $O(n\log n)$。

---

## 作者：CRH_Beijingzhan (赞：0)

[P1081 [NOIP 2012 提高组] 开车旅行](https://www.luogu.com.cn/problem/P1081)

### 解题思路

首先考虑这道题的暴力做法，对于第一问，枚举每个起始点，暴力计算每个点之后最近和第二近的位置，计算答案，最后取最大值。对于第二问，对每个询问独立模拟即可。复杂度较高，无法通过此题。

既然无法通过，那就优化！

**第一个优化**： 考虑到对于固定的当前点和当前驾驶者，接下来的路径是一定的，可以利用倍增来处理。

**第二个优化**： 可以利用 ```set``` 预处理出每个点之后最近和第二近的节点、到达下一个节点的距离。注意需要逆序插入点。如果不希望用如此多的迭代器操作也可以手写平衡树。复杂度为 $O(n \log n)$。

预处理部分代码如下，$dp_{i,j,k}$ 表示 $k$ 从点 $j$ 继续走 $2^i$ 次小 A 的距离。$disb_{i,j,k}$ 表示 $k$ 从点 $j$ 继续走 $2^i$ 次小 B 行驶的距离。

其中 $k=1$ 为小 A，$k=2$ 为小 B。


```
for (int i = n; i; i--)
{
    st.insert({h[i], i});//插入当前点
    auto pos = st.lower_bound({h[i], i});
    --pos;
    // 更小的第一个 位置 / 距离
    int li = pos->second, lh = pos->first;
    ++pos;
    ++pos;
    // 更大的第一个 位置 / 距离
    int nx = pos->second, nh = pos->first;
    --pos;
    int pa, pb;
 
    // 小的更近
    if (abs(nh - h[i]) >= abs(h[i] - lh))
    {
        pb = li;
        --pos;
        --pos;
        // 第二小的和大的比较
        if (abs(nh - h[i]) >= abs(h[i] - pos->first))
        {
            pa = pos->second;
        }
        else
        {
            pa = nx;
        }
    }
    else //大的更近
    {
        pb = nx;
        ++pos;
        ++pos;
        // 第二大和小的比较
        if (abs(pos->first - h[i]) >= abs(h[i] - lh))
        {
            pa = li;
        }
        else
        {
            pa = pos->second;
        }
    }
    dp[0][i][0] = pa;
    dp[0][i][1] = pb;
    disa[0][i][0] = abs(h[i] - h[pa]);
    disb[0][i][1] = abs(h[i] - h[pb]);
}
```

接下来处理出所有值，需要注意的是 $2^0=1$ 为奇数，结束时开车的人会改变，需要特判。


```
for (int i = 1; i <= 18; i++)
{
    for (int j = 1; j <= n; j++)
    {
        for (int k = 0; k <= 1; k++)
        {
            if (i == 1)
            {
                dp[1][j][k] = dp[0][dp[0][j][k]][1 - k];
                disa[1][j][k] = disa[0][j][k] + disa[0][dp[0][j][k]][1 - k];
                disb[1][j][k] = disb[0][j][k] + disb[0][dp[0][j][k]][1 - k];
            }
            else
            {
                dp[i][j][k] = dp[i - 1][dp[i - 1][j][k]][k];
                disa[i][j][k] = disa[i - 1][j][k] + disa[i - 1][dp[i - 1][j][k]][k];
                disb[i][j][k] = disb[i - 1][j][k] + disb[i - 1][dp[i - 1][j][k]][k];
            }
            // cout << "disa[" << i << "][" << j << "][" << k << "]=" << disa[i][j][k] << endl;
            // cout << disa[1][1][0] << endl;
        }
    }
}
```

求对于给定的 $x$ 和 $s$ 两人分别走的距离，很典型的倍增套路。


```
void solution(int ss, int xx)
{
    int now = ss;
    la = lb = 0;
    for (int i = 18; ~i; i--)
    {
        if (dp[i][now][0] && la + lb + disa[i][now][0] + disb[i][now][0] <= xx)
        {
            la += disa[i][now][0];
            lb += disb[i][now][0];
            now = dp[i][now][0];
        }
    }
}
```

回答第一问：枚举起点，取最小值。


```
double ans = 2010000000.000;
int ansid = 0;
for (int i = 1; i <= n; i++)
{
    solution(i, x0);
    double ans__ = (double)la / (double)(lb);
    if (ans__ < ans)
    {
        ans = ans__;
        ansid = i;
    }
    else if (ans__ == ans && h[ansid] < h[i])
    {
        ansid = i;
    }
}
writeln(ansid);
```

回答第二问：直接调用函数。


```
for (int i = 1; i <= m; i++)
{
    solution(querys[i].first, querys[i].second);
    writesp(la), writeln(lb);
}
```


### CODE


```cpp
#include <bits/stdc++.h>
using namespace std;
#define max_n 110101
void read(int &p)
{
    p = 0;
    int k = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
        {
            k = -1;
        }
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        p = p * 10 + c - '0';
        c = getchar();
    }
    p *= k;
    return;
}
void write_(int x)
{
    if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    if (x > 9)
    {
        write_(x / 10);
    }
    putchar(x % 10 + '0');
}
void writesp(int x)
{
    write_(x);
    putchar(' ');
}
void writeln(int x)
{
    write_(x);
    putchar('\n');
}
int n, h[max_n], x0, m;
set<pair<int, int>> st;
pair<int, int> querys[max_n];
int dp[19][max_n][3];
int disa[19][max_n][3];
int disb[19][max_n][3];
int la, lb;
void solution(int ss, int xx)
{
    int now = ss;
    la = lb = 0;
    for (int i = 18; ~i; i--)
    {
        if (dp[i][now][0] && la + lb + disa[i][now][0] + disb[i][now][0] <= xx)
        {
            // cout << i << " " << now << " " << disa[1][1][0] << endl;
            la += disa[i][now][0];
            lb += disb[i][now][0];
            now = dp[i][now][0];
        }
    }
    // cout << "#" << la << " " << lb << endl;
}
signed main()
{
#if _clang_
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
#endif
    read(n);
    for (int i = 1; i <= n; i++)
    {
        read(h[i]);
    }
    read(x0), read(m);
    for (int i = 1; i <= m; i++)
    {
        read(querys[i].first);
        read(querys[i].second);
    }
    h[0] = 2000000000;
    h[n + 1] = -2000000000;
    st.insert({h[0], 0});
    st.insert({h[n + 1], n + 1});
    for (int i = n; i; i--)
    {
        st.insert({h[i], i});
        auto pos = st.lower_bound({h[i], i});
        --pos;
        int li = pos->second, lh = pos->first;
        ++pos;
        ++pos;
        int nx = pos->second, nh = pos->first;
        --pos;
        int pa, pb;
        //   cout << "@" << li << " " << lh << " " << nx << " " << nh << endl;
        if (abs(nh - h[i]) >= abs(h[i] - lh))
        {
            //   cout << "A" << endl;
            pb = li;
            --pos;
            --pos;
            if (abs(nh - h[i]) >= abs(h[i] - pos->first))
            {
                pa = pos->second;
            }
            else
            {
                pa = nx;
            }
        }
        else
        {
            // cout << "B" << endl;
            pb = nx;
            ++pos;
            ++pos;
            if (abs(pos->first - h[i]) >= abs(h[i] - lh))
            {
                pa = li;
            }
            else
            {
                pa = pos->second;
            }
        }
        dp[0][i][0] = pa;
        dp[0][i][1] = pb;
        disa[0][i][0] = abs(h[i] - h[pa]);
        disb[0][i][1] = abs(h[i] - h[pb]);
        //  cout << dp[0][i][0] << " " << dp[0][i][1] << " " << disa[0][i][0] << " " << disb[0][i][1] << endl;
    }
    for (int i = 1; i <= 18; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            for (int k = 0; k <= 1; k++)
            {
                if (i == 1)
                {
                    dp[1][j][k] = dp[0][dp[0][j][k]][1 - k];
                    disa[1][j][k] = disa[0][j][k] + disa[0][dp[0][j][k]][1 - k];
                    disb[1][j][k] = disb[0][j][k] + disb[0][dp[0][j][k]][1 - k];
                }
                else
                {
                    dp[i][j][k] = dp[i - 1][dp[i - 1][j][k]][k];
                    disa[i][j][k] = disa[i - 1][j][k] + disa[i - 1][dp[i - 1][j][k]][k];
                    disb[i][j][k] = disb[i - 1][j][k] + disb[i - 1][dp[i - 1][j][k]][k];
                }
                // cout << "disa[" << i << "][" << j << "][" << k << "]=" << disa[i][j][k] << endl;
                // cout << disa[1][1][0] << endl;
            }
        }
    }
    double ans = 2010000000.000;
    int ansid = 0;
    for (int i = 1; i <= n; i++)
    {
        solution(i, x0);
        // cout << la << " " << lb << endl;
        double ans__ = (double)la / (double)(lb);
        if (ans__ < ans)
        {
            ans = ans__;
            ansid = i;
        }
        else if (ans__ == ans && h[ansid] < h[i])
        {
            ansid = i;
        }
    }
    writeln(ansid);
    for (int i = 1; i <= m; i++)
    {
        solution(querys[i].first, querys[i].second);
        writesp(la), writeln(lb);
    }
    return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

首先进行预处理。

用一种你喜欢的数据结构维护每个城市的海拔，容易求出从每个城市出发，小 A 和小 B 开一天能到达的城市。

因为小 A 开一天，小 B 开一天，所以设每两天为一个周期。用一个倍增数组 $f_{i,j}$ 维护从第 $i$ 个城市出发，行驶 $2j$ 个周期，能到达的城市，用数组维护这段路程的长度、小 A 开的路程和小 B 开的路程。

对于第一个问题，我们枚举每一个城市，通过求出从这里出发所能到达最远的城市，即可得到小 A 和小 B 分别行驶的路程，就能在 $O(n\log ⁡n)$ 的时间内得到答案。
对于第二个问题，我们仿照上一问直接求解，时间复杂度 $O(m\log n)$。


关于预处理，由于海拔各不相同，所以可选的数据结构较多。

因为要求第二近的，所以在需要在 ```vector``` 中遍历每个城市前后两个城市的海拔。

关于求解，需要注意，可能真正最远的城市不一定是通过 $f_{i,j}$ 数组求出的城市，需要判断能不能让小 A 再走一天。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int ma=1e9,mb=1,mi=-1,n,m,a[N],d[N],sd[N],x0,f[N][22],g[N][22],ga[N][22],gb[N][22],li[N],b[N];
vector<int>vc;
int dis(int x,int y){
	if(x==-1||y==-1){
        return 1e9;
    }
	return abs(a[x]-a[y]);
}
bool cmp(int x,int y){
    return a[x]<a[y];
}
void dmin(int k,int l,int r){
	int mi=-1;
	if(l<0){
        l=0;
    }
	if(r>=vc.size()){
        r=vc.size()-1;
    }
	for(int i=l;i<=r;i++){
		if(mi==-1||dis(k,li[vc[i]])<dis(k,mi)){
            mi=li[vc[i]];
        }
    }
	if(mi==-1){
        d[k]=sd[k]=-1;
        return;
    }
	d[k]=mi;
    int mi2c=-1;
	for(int i=l;i<=r;i++){
        if(li[vc[i]]!=mi&&(mi2c==-1||dis(k,li[vc[i]])<dis(k,mi2c))){
            mi2c=li[vc[i]];
        }
    }
	if(mi2c==-1){
        sd[k]=-1;
    }else{
        sd[k]=mi2c;
    }
}
void getd(){
	for(int i=1;i<=n;i++){
        li[i]=i;
    }
	sort(li+1,li+n+1,cmp);
	for(int i=1;i<=n;i++){
        b[li[i]]=i;
    }
	for(int i=n;i>=1;i--){
		if(i<n){
			int pos=lower_bound(vc.begin(),vc.end(),b[i])-vc.begin()-1;
			dmin(i,pos-1,pos+3);
		}
		vc.insert(lower_bound(vc.begin(),vc.end(),b[i]),b[i]);
	}
	d[n]=-1;
    sd[n]=sd[n-1]=-1;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
        cin>>a[i];
    }
	getd();
	for(int i=1;i<=n;i++){
		if(sd[i]!=-1){
            f[i][0]=d[sd[i]];
        }else{
            f[i][0]=-1;
        }
		ga[i][0]=dis(i,sd[i]);
		gb[i][0]=dis(sd[i],d[sd[i]]);
		g[i][0]=ga[i][0]+gb[i][0];
	}
	for(int i=1;(1<<i-1)<=n;i++){
        for(int j=1;j<=n;j++){
            if(f[j][i-1]!=-1){
                f[j][i]=f[f[j][i-1]][i-1];
                g[j][i]=g[j][i-1]+g[f[j][i-1]][i-1];
                ga[j][i]=ga[j][i-1]+ga[f[j][i-1]][i-1];
                gb[j][i]=gb[j][i-1]+gb[f[j][i-1]][i-1];
            }else{
                f[j][i]=-1;
                g[j][i]=ga[j][i]=gb[j][i]=1e9;
            }
        }
    }
	cin>>x0;
	for(int i=1;i<=n;i++){
		int s=i,sum=0,sa=0,sb=0;
		for(int j=20;j>=0;j--){
            if(f[s][j]>0&&sum+g[s][j]<=x0){
                sum+=g[s][j];
                sa+=ga[s][j];
                sb+=gb[s][j];
                s=f[s][j];
            }
        }
		if(s<n-1&&sum+dis(s,sd[s])<=x0){
            sa+=dis(s,sd[s]);
        }
		if(mi==-1||1ll*ma*sb>1ll*mb*sa){
            ma=sa;
            mb=sb;
            mi=i;
        }
		if((sb||mi==-1)&&1ll*ma*sb==1ll*mb*sa&&a[i]>a[mi]){
            mi=i;
        }
	}
	cout<<mi<<endl;
	cin>>m;
	while(m--){
		int s,x,sum=0,sa=0,sb=0;
		cin>>s>>x;
		for(int j=20;j>=0;j--){
            if(f[s][j]>0&&sum+g[s][j]<=x){
                sum+=g[s][j];
                sa+=ga[s][j];
                sb+=gb[s][j];
                s=f[s][j];
            }
        }
		if(s<n-1&&sum+dis(s,sd[s])<=x){
            sa+=dis(s,sd[s]);
        }
		cout<<sa<<" "<<sb<<endl;
	}
    return 0;
}
```

---


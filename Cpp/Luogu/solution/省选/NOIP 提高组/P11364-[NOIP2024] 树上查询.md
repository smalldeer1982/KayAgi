# [NOIP2024] 树上查询

## 题目描述

有一天小 S 和她的朋友小 N 一起研究一棵包含了 $n$ 个结点的树。

这是一棵有根树，根结点编号为 $1$，每个结点 $u$ 的深度 $\text{dep}_ u$ 定义为 $u$ 到 $1$ 的简单路径上的**结点数量**。

除此之外，再定义 $\text{LCA*}(l, r)$ 为编号在 $[l, r]$ 中所有结点的最近公共祖先，即 $l, l + 1, \dots , r$ 的公共祖先结点中深度最大的结点。

小 N 对这棵树提出了 $q$ 个询问。在每个询问中，小 N 都会给出三个参数 $l, r, k$，表示他想知道 $[l, r]$ 中任意长度大于等于 $k$ 的连续子区间的最近公共祖先深度的最大值，即

$$\max_{l\le l'\le r'\le r \land r'-l'+1\ge k}\text{dep}_ {\text{LCA*}(l', r')}$$

你的任务是帮助小 S 来回答这些询问。

## 说明/提示

**【样例 1 解释】**

![图 3](https://cdn.luogu.com.cn/upload/image_hosting/ktoq3ogh.png)

+ 对于第一组询问，$\text{LCA*}(2, 3) = 2, \text{LCA*}(3, 4) = 2, \text{LCA*}(4, 5) = 6$，$2$ 的深度为 $3$，$6$ 的深度为 $2$，因此答案为 $\max\{3, 3, 2\} = 3$。

+ 对于第二组询问，答案为 $1, 2, 3, 4$ 四个结点的最大深度，因此答案为 $4$。

+ 对于第三组询问，$\text{LCA*}(1, 3) = 1, \text{LCA*}(2, 4) = 2, \text{LCA*}(3, 5) = 6, \text{LCA*}(4, 6) = 6$，依旧是 $2$ 的深度最大，因此答案为 $3$。

**【样例 2】**

见附件的 query/query2.in 与 query/query2.ans。

该样例满足 $n, q ≤ 500$。

**【样例 3】**

见附件的 query/query3.in 与 query/query3.ans。

该样例满足 $n, q ≤ 10^5$ 且树符合链的形态。

**【样例 4】**

见附件的 query/query4.in 与 query/query4.ans。

该样例满足 $n, q ≤ 5 × 10^5$。

**【数据范围】**

对于所有的测试数据，保证：$1 ≤ n, q ≤ 5 × 10^5
, 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ r - l + 1$

::cute-table{tuack}

| 测试点编号 | $n,q\le$ | 特殊限制 |
| :-: | :-: | :-: |
| $1\sim2$ | $500$ | 无 |
| $3\sim5$ | $5000$ | ^ |
| $6\sim9$ | $10^5$ | 满足性质 A |
| $10\sim13$ | $5\times10^5$ | ^ |
| $14\sim16$ | ^ | 满足性质 B |
| $17\sim20$ | $10^5$ | 无 |
| $21\sim25$ | $5\times10^5$ | ^ |

性质 A：保证输入的树符合链的形态，且根结点的度数为 $1$。

性质 B：对于每个询问保证 $k = r - l + 1$。

## 样例 #1

### 输入

```
6
5 6
6 1
6 2
2 3
2 4
3
2 5 2
1 4 1
1 6 3
```

### 输出

```
3
4
3
```

# 题解

## 作者：_Yonder_ (赞：182)

死于交集关系推导。

首先，区间 $\text{LCA}$ 的深度为：

$$\min_{l\le i<r}{\text{dep}_{\text{LCA}(i,i+1)}}$$

可以用虚树的方法证。


我们找出以 $\text{LCA}(i,i+1)$ 为最近公共祖先的最大区间 $[x_i,y_i,v_i]$，$v_i$ 为 $\text{dep}_{\text{LCA}(i,i+1)}$。

显然，查询是求与 $[l,r]$ 交集至少为 $k$，且最大的 $v_i$。可列出两个不等式。

$$
y_i\ge r\land x_i\le r-k+1 \\
l+k-1\le y_i\le r\land y_i-x_i+1\ge k
$$

第一个对 $r$ 扫描线，第二个对 $k$ 扫描线，时间复杂度 $O(n\log n)$。

---

## 作者：Rainbow_qwq (赞：41)

一个硬维护的做法，居然没人是这样做的（

特判掉 $k=1$ 的询问，对于 $k\ge 2$，区间 LCA 的深度为 $\min_{l\le i < r} \operatorname{dep}_{\operatorname{LCA}(i,i+1)}$。（证明考虑一下虚树，这里不再赘述）

那么问题可以转化为：有一个序列 $a$，询问 $l,r,k$，求 $\max_{p\in [l,r]} (\min_{i\in [p,p+k-1]} a_i)$。

这可以看作：把 $a$ 数组进行 $k-1$ 次 $a_i = \min(a_i,a_{i+1})$ 的操作，然后求 $a$ 的区间最大值。

把询问按照 $k$ 排序，问题转化为：

- 把 $a$ 数组进行 $a_i = \min(a_i,a_{i+1})$ 的操作，操作完长度减一
- 求 $a$ 数组区间最大值

假设 $a$ 的所有元素不同，否则给 $a$ 的相同元素也钦定大小顺序。

考虑直接维护 $a$ 中的每个值域连续段。每次进行 $a_i = \min(a_i,a_{i+1})$ 的操作后，每个连续段长度可能变化 $-1/0/1$。

如果连续段的值比两边都小，长度会加 $1$；比两边都大，长度会减 $1$；否则长度不变。

具体的：设 $l,r$ 为 $i$ 这个段左边和右边的连续段。考虑设 $d_i = [a_i < a_l] + [a_i < a_r] - 1$，在每一次变化后，$a_i$ 这个值的连续段长度加上 $d_i$。（如果 $a_l/a_r$ 不存在则设 $a_l/a_r=-\infty$）

如果一个连续段长度变为 $0$，则这个连续段要删掉，并且更新左边、右边连续段的 $d_i$。

可以在线段树上维护每个连续段的 $a_i,d_i$ 和长度，以及当前 $d_i=-1$ 的连续段的长度最小值，用链表维护删除。

查询在线段树上二分一下，修改需要打标记，然后不断删除长度变为 $0$ 的连续段。

时间复杂度 $O((n+q)\log n)$。

[Code](https://uoj.ac/submission/726604)

---

## 作者：lsj2009 (赞：29)

## Problem

给定一棵 $n$ 个点的树，$q$ 次询问，每次给定 $l,r,k$，查询：

$$
\max\limits_{\substack{[l',r']\subseteq [l,r]\\r'-l'+1\ge k}} dep_{\operatorname{lca}([l',r'])}
$$

的值。

$1\le n,q\le 5\times 10^5$。

## Solution

**闲话：**

场上 40min 写完，没调试，一发通过大样例！！！

杭师大机子极限数据 1.9s，应该能过吧？？？

### Part 1

考虑一个类似于支配点对的东西，具体的，我们对于每个点 $u$，我们**找出他子树内的每一个极长连续段 $[l,r]$，并且满足 $\operatorname{lca}([l,r])=u$**。

我们断言：这样子的点对 $[l,r]$ **只有 $\mathcal{O}(n)$ 个**。

- 证明：从子树合并角度来看太困难，我们不妨视作有一张图，每次子树合并的时候相当于**会连接若干个 $(i,i+1)$**（也就是 $\operatorname{lca}(i,i+1)=u$），**每连接一条会新产生一个极长段**，我们会恰好连接 $n-1$ 次，所以最多只会有 $n+n-1=2n-1$ 个点对。

~~实时维护子树内的极长连续段，使用 **dsu on tree** 容易在 $\mathcal{O}(n\log{n})$ 复杂度内找出所有点对。~~

上面那个是本人在考场上写的东西，但是**根据上面的证明**，我们注意到其实存在更简单地找连续段地方法：

- 我们将一个操作 $\operatorname{link}(i,i+1)$ 挂在 $dep_{\operatorname{lca}(i,i+1)}$ 处，**然后倒着扫描 $dep$，每次执行挂在这个深度的操作**，时刻 **维护连续段并加入支配点对集合** 即可。

连续段可以使用并查集或者 ``set`` 维护，复杂度 $\mathcal{O}(n\log{n})$。

或者有更简单地做法：构造序列 $a_i=dep_{\operatorname{lca}(i,i+1)}$，求 $a$ 的笛卡尔树则每个节点管辖的区间就是一个支配对。

### Part 2

接下来问题变为：

- 给定若干个线段，线段带权，每次询问给定一个线段，查询和该**线段交集不小于 $k$ 的所有线段中的权值最大值**。

考虑所有能对询问 $[l,r]$ 产生贡献的线段 $[l',r']$ 长什么样子：

1. $l\le l'\le r\le r'$。
2. $l'\le l\le r'\le r$。
3. $l'\le l\le r\le r'$。
4. $l\le l'\le r'\le r$。

最后一种可以拍入前两种中，下面略去不谈，第三种显然合法，所以**偏序关系只有 $l,r$ 两维**，扫描线即可；剩下两种（**下面以第一种为例**）除了 $l$ 和 $r$ 外还有交集不小于 $k$ 的偏序关系，看起来像是三维偏序，但我们仔细分析：

- 如果我们保证 $r'-l'+1\ge k$，则交集不小于 $k$ 实际上是 $r-l'+1\ge k\Rightarrow l'\le r-k+1$。

我们考虑**从大到小扫描 $k$**，每次把 $([l',r'],d)$ 的值挂在左端点 $l'$ 处，每次就是询问 $[l,r-k+1]$ 的区间 $\max$。

同理处理第二种情况，并且我们发现其实这样子顺手把第四种算好了。

这样子复杂度就是 $\mathcal{O}((n+q)\log{n})$ 了。

## Code

```cpp
#include<bits/stdc++.h>
// #define int long long
// #pragma GCC optimize(3,"Ofast","inline")
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ll long long
#define bint __int128
#define ull unsigned long long
#define uint unsigned int
#define ld double
#define PII pair<int,int>
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
#define pcnt(x) __builtin_popcount(x)
#define lg(x) (31-__builtin_clz(x))
using namespace std;
void file_IO() {
    freopen("query.in","r",stdin);
    freopen("query.out","w",stdout);
}
bool M1;
namespace IO {
	char Is[(1<<21)+10],Os[(1<<21)+10];
	int Ipt,Opt;
	char gc() {
		if(Ipt==1<<21)
			Ipt=0;
		if(!Ipt)
			Is[fread(Is,1,1<<21,stdin)]=0;
		return Is[Ipt++];
	}
	void flush() {
		fwrite(Os,1,Opt,stdout);
		Opt=0;
	}
	void pc(char x) {
		if(Opt==1<<21)
			flush();
		Os[Opt++]=x;
	}
	int read() {
		int x=0,f=1;
		char ch=gc();
		while(ch<'0'||ch>'9') {
			if(ch=='-')
				f=-1;
			ch=gc();
		}
		while(ch<='9'&&ch>='0')
			x=(x<<3)+(x<<1)+ch-'0',ch=gc();
		return x*f;
	}
	int tt[100];
	void write(int x) {
		if(x<0)
			pc('-'),x=-x;
		if(!x) {
			pc('0');
			return;
		}
		int len=0;
		while(x)
			tt[++len]=x%10,x/=10;
		per(i,len,1)
			pc(tt[i]+48);
	}
}
using namespace IO;
const int INF=0x3f3f3f3f;
const ll INFLL=0x3f3f3f3f3f3f3f3f;
const ld eps=1e-9;
const int N=5e5+5;
int head[N],len;
struct node {
    int to,nxt;
}; node edge[N<<1];
void add_edge(int u,int v) {
    edge[++len]={v,head[u]}; head[u]=len;
}
int d[N],pa[N],max_son[N],siz[N];
void dfs(int u,int fa) {
	d[u]=d[fa]+1; pa[u]=fa;
	siz[u]=1;
	for(int i=head[u];i;i=edge[i].nxt) {
		int v=edge[i].to;
		if(v!=fa) {
			dfs(v,u);
			if(siz[v]>siz[max_son[u]])
				max_son[u]=v;
			siz[u]+=siz[v];
		}
	}
}
int top[N],dfn[N],p;
void dfs1(int u,int w) {
	top[u]=w; dfn[u]=++p;
	if(max_son[u])
		dfs1(max_son[u],w);
	for(int i=head[u];i;i=edge[i].nxt) {
		int v=edge[i].to;
		if(v!=max_son[u]&&v!=pa[u])
			dfs1(v,v);
	}
}
int lca(int u,int v) {
	while(top[u]!=top[v]) {
		if(d[top[u]]>d[top[v]])
			swap(u,v);
		v=pa[top[v]];
	}
	return d[u]<d[v]? u:v;
}
struct info {
    int l,r,k;
}; vector<info> vec[N],upd[N],ask[N],assk[N];
void ins(int l,int r,int v) {
    vec[r].push_back({l,r,v});
    upd[r-l+1].push_back({l,r,v});
}
struct dsu {
    int fa[N];
    void init(int n) {
        rep(i,1,n)
            fa[i]=i;
    }
    int find(int x) {
        if(fa[x]!=x)
            fa[x]=find(fa[x]);
        return fa[x];
    }
    void merge(int u,int v) {
        u=find(u); v=find(v);
        if(u!=v)
            fa[u]=v;
    }
    bool same(int u,int v) {
        return find(u)==find(v);
    }
}; dsu pre,suf;
void link(int k,int v) { //link(k,k+1)
    int l=pre.find(k),r=suf.find(k+1);
    ins(l,r,v);
    pre.merge(k+1,k);
    suf.merge(k,k+1);
}
vector<int> tmp[N];
struct SGT {
	struct node {
		int l,r,val;
	}; node tree[N<<2];
	#define ls(k) (k<<1)
	#define rs(k) (k<<1|1)
	void push_up(int k) {
		tree[k].val=max(tree[ls(k)].val,tree[rs(k)].val);
	}
	void build(int k,int l,int r) {
		tree[k].l=l; tree[k].r=r;
		if(l==r)
			return;
		int mid=(l+r)>>1;
		build(ls(k),l,mid);
		build(rs(k),mid+1,r);
	}
	void update(int k,int qx,int val) {
		if(tree[k].l==tree[k].r) {
			chkmax(tree[k].val,val);
			return;
		}
		if(qx<=tree[ls(k)].r)
			update(ls(k),qx,val);
		else
			update(rs(k),qx,val);
		push_up(k);
	}
	int query(int k,int ql,int qr) {
        if(ql>qr)
            return 0;
		if(ql<=tree[k].l&&tree[k].r<=qr)
			return tree[k].val;
		int res=0;
		if(ql<=tree[ls(k)].r)
			chkmax(res,query(ls(k),ql,qr));
		if(qr>=tree[rs(k)].l)
			chkmax(res,query(rs(k),ql,qr));
		return res;
	}	
	#undef ls
	#undef rs
}; SGT T1,T2,T3;
int ans[N];
void solve() {
    int n=read();
    rep(i,2,n) {
        int u=read(),v=read();
        add_edge(u,v);
        add_edge(v,u);
    }
    dfs(1,0);
    dfs1(1,1);
    rep(i,1,n-1)
        tmp[d[lca(i,i+1)]].push_back(i);
    pre.init(n);
    suf.init(n);
    rep(i,1,n)
        ins(i,i,d[i]);
    per(i,n,1) {
        for(auto x:tmp[i])
            link(x,i);
    }
    int q=read();
    rep(i,1,q) {
        int l=read(),r=read(),k=read();
        assk[r].push_back({l,r,i});
        ask[k].push_back({l,r,i});
    }
    T1.build(1,1,n);
    T2.build(1,1,n);
    per(i,n,1) {
        for(auto x:upd[i]) {
            int l=x.l,r=x.r,k=x.k;
            T1.update(1,l,k);
            T2.update(1,r,k);
        }
        for(auto x:ask[i]) {
            int l=x.l,r=x.r,k=x.k;
            chkmax(ans[k],T1.query(1,l,r-i+1));
            chkmax(ans[k],T2.query(1,l+i-1,r));
        }
    }
    T3.build(1,1,n);
    per(i,n,1) {
        for(auto x:vec[i])
            T3.update(1,x.l,x.k);
        for(auto x:assk[i])
            chkmax(ans[x.k],T3.query(1,1,x.l));
    }
    rep(i,1,q)
        write(ans[i]),pc('\n');
    flush();
}
bool M2;
// g++ query.cpp -std=c++14 -Wall -O2 -o query
signed main() {
    file_IO();
    int testcase=1;
    // scanf("%d",&testcase);
    while(testcase--)
        solve();
    debug("used time = %dms\n",(signed)(1000*clock()/CLOCKS_PER_SEC));
    debug("used memory = %dMB\n",(signed)((&M1-&M2)/1024/1024));
    return 0;
}
```

---

## 作者：ppip (赞：23)

考虑对序列直接分治，然后计算贡献。

先预处理出线段树上每个结点表示的区间的全部答案，一共有 $O(n\log n)$ 个值。

然后对于每个询问，把它放在线段树上。现在我们只需要对于每个线段树上的结点，一些跨越线段树中点的询问，并且我们只需要考虑子区间也跨越中点的贡献。

设左儿子区间 $[l,m]$ 右儿子 $[m+1,r]$，可以发现有贡献的区间一定跨越 $m$ 和 $m+1$。换句话说，它是 $\text{LCA}(m,m+1)$ 的祖先。所以可以将每个点替换为它和 $\text{LCA}(m,m+1)$ 的 $\text{LCA}$，于是 $[l,r]$ 的所有点都构成祖先后代关系，求 $\text{LCA}$ 深度我们只需要对两个点的深度取较小值就可以了。

那这个问题就是简单的了：我们建立一个平面，$x,y$ 轴分别是子区间左端点到 $m$ 的距离，以及右端点到 $m+1$ 的距离，且每个点有个权值 $a_i$ 表示 $[i,m+1]$ （这里指左侧，右侧为 $[m,i]$）范围内的点的 $\text{LCA}$ 的深度。

则区间 $[l',r']$ 的 $\text{LCA}$ 深度为 $\min(a_{l'},a_{r'})$。$[l,r]$ 关于某一个 $k$ 的答案就是 $0\le x\le m-l, 0\le y\le r-m+1$ 的矩形内，斜线 $x+y=k$ 上的最大权值。

考察权值 $\ge k$ 的点集的形状：因为 $a$ 在两维上都单调，所以这样的点是 $x,y$ 轴上分别取一个前缀合法，即一个包含原点的子矩形，且这些矩形互相包含。我们称这样的矩形为关键的。每个关键的矩形 $(x',y')$，都能对 $k=0\sim x'+y'$ 产生贡献。依此，就可以线性地求出每个斜线的答案了。预处理的复杂度就是 $O(n\log n)$。

现在来考虑询问。一个询问在线段树上递归时，与上面的问题形式相同，只是在合并答案时，并非能取到所有的 $x+y=k$ 的点，它还对 $x,y$ 有一个上界限制。具体地，设询问为 $(L,R,k)$ 则，$m-x\ge L,m+1+y\le R$。也就是说，询问的是一个斜的线段的最小值。

考虑关键矩形对询问的贡献。显然我们要求出最小的与该线段有交的关键矩形。由于关键矩形互相包含，所以如果一个矩形和线段有交，则比它大的都和线段有交。所以我们预处理出所有关键矩形，然后二分寻找。每个询问会在线段树上发生 $O(\log n)$ 次合并，如果每次都二分，复杂度为 $O(\log^2n)$，不可接受。

不过注意到一个区间在线段树上递归时，仅会发生一次左右端点都不取到线段树结点的左右端点的情况（$l<L\le R<r$），剩下的每次合并，都满足 $L=l$ 或 $r=R$。考虑对于前者，使用二分计算，对于后者优化复杂度。

不妨设 $L=l$，则这条线段应该长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/6jx7o3gy.png)

设线段的“断头”处为 $(x_0,y_0)$，考察这两个矩形：

- 最小的和该线段所在的直线有交的关键矩形；
- 最小的和 $x\ge x_0$ 区域有交的关键矩形。

这两个有如下两种位置关系（前者为红色，后者为蓝色）：


![](https://cdn.luogu.com.cn/upload/image_hosting/p2puk8kt.png)


![](https://cdn.luogu.com.cn/upload/image_hosting/xircibfz.png)

可以发现，无论哪种情况，这两个矩形中较大的一定是最优解。所以我们也预处理一下这两种矩形即可。

另外一种线段 $R=r$ 显然做法相同。

此处合并的复杂度变为 $O(1)$，所以整道题的复杂度为 $O(n\log n)$。

实现中，无需比较矩形大小，显然权值 $\min(a_x,a_y)$ 更小的矩形更大，记录这个权值即可。

**因为洛谷评测机较慢，我的考场代码在洛谷上会 TLE，仅供参考。我在官方成绩中已通过。**

```cpp
// this is my noip.
#include <bits/stdc++.h>
using namespace std;
constexpr int Spp{1<<20};
char buf[Spp],*p1,*p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,Spp,stdin),p1==p2)?EOF:*p1++)
template<typename T>
void read(T &x) {
	char c;int f{1};
	do x=(c=getchar())-'0';
	while (!isdigit(c)&&c!='-');
	if (c=='-') x=0,f=-1;
	while (isdigit(c=getchar()))
		x=x*10+(c-'0');
	x*=f;
}
template <typename T,typename ...Args>
void read(T &x,Args &...args) { read(x);read(args...);}
constexpr int N(5e5),LG{18};
vector<int> e[N+5];
int fz[N+5],fa[N+5],dep[N+5],lda,dfn[N+5];
int st[LG+1][N+5];
void init(int u,int fa) {
	::fa[u]=fa;
	dfn[u]=++lda;
	fz[lda]=u;
	dep[u]=dep[fa]+1;
	for (auto v:e[u])
		if (v!=fa)
			init(v,u);
}
int Max(int u,int v) {
	return dep[fz[u]]<dep[fz[v]]?u:v;
}
int LCA(int u,int v) {
	if (u==v) return u;
	u=dfn[u];v=dfn[v];
	if (u>v) swap(u,v);
	int z{__lg(v-u)};
	return fa[fz[Max(st[z][v],st[z][u+(1<<z)])]];
}
vector<int> ans[N*4],ans2[N*4];
vector<pair<int,int>> lo[N*4],ro[N*4],oo[N*4],lr[N*4],nl[N*4],nr[N*4];
int LC[N*4];
void build(int p,int L,int R) {
	ans[p].resize(R-L+2);
	ans2[p].resize(R-L+2);
	if (L==R) {
		ans[p][1]=dep[L];
		lo[p].emplace_back(L,L);
		ro[p].emplace_back(R,R);
		LC[p]=L;
		return;
	}
	int mid{L+R>>1};
	build(p<<1,L,mid);
	build(p<<1|1,mid+1,R);
	LC[p]=LCA(LC[p<<1],LC[p<<1|1]);
	for (int i{1};i<=mid-L+1;++i) ans[p][i]=ans[p<<1][i];
	for (int i{1};i<=R-mid;++i) ans[p][i]=max(ans[p][i],ans[p<<1|1][i]);
	lo[p]=lo[p<<1];
	ro[p]=ro[p<<1|1];
	for (auto [x,y]:lo[p<<1|1]) nr[p].emplace_back(LCA(x,mid),y),lo[p].emplace_back(LCA(x,LC[p<<1]),y);
	for (auto [x,y]:ro[p<<1]) nl[p].emplace_back(LCA(x,mid+1),y),ro[p].emplace_back(LCA(x,LC[p<<1|1]),y);
	merge(nl[p].begin(),nl[p].end(),nr[p].begin(),nr[p].end(),back_inserter(oo[p]),[](auto x,auto y){return dep[x.first]>dep[y.first];});
	int l{mid},r{mid+1},an{N};
	for (auto [x,y]:oo[p]) {
		l=min(l,y);
		r=max(r,y);
		lr[p].emplace_back(l,r);
		an=min(an,dep[x]);
		ans2[p][r-l+1]=max(ans2[p][r-l+1],an);
	}
	ans[p][R-L+1]=max(ans[p][R-L+1],ans2[p][R-L+1]);
	for (int i{R-L};i>=1;--i) ans[p][i]=max({ans[p][i],ans2[p][i],ans[p][i+1]});
	lo[p<<1].clear();lo[p<<1].shrink_to_fit();
	ro[p<<1|1].clear();ro[p<<1|1].shrink_to_fit();
}
int n;
int qry(int p,int l,int r,int k,int L,int R) {
	if (l<=L&&R<=r)
		return k>(R-L+1)?0:ans[p][k];
	int mid{L+R>>1};
	int res{0};
	if (l<=mid) res=max(res,qry(p<<1,l,r,k,L,mid));
	if (r>mid) res=max(res,qry(p<<1|1,l,r,k,mid+1,R));
	if (k<=R-L+1&&l<=mid&&r>mid) {
		if (l<=L) {
			if (r-k+1>=L)
				res=max(res,min(ans2[p][k],dep[nl[p][max(0,mid-(r-k+1))].first]));
		} else if (r>=R) {
			if (l+k-1<=R)
				res=max(res,min(ans2[p][k],dep[nr[p][max(0,(l+k-1)-mid-1)].first]));
		} else {
			int ll{0},rr{R-L};
			int l1{l},l2{r-k+1};
			int r2{r},r1{l+k-1};
			while (ll<=rr) {
				int md{ll+rr>>1};
				auto [LL,RR]{lr[p][md]};
				if (RR-LL+1<k) {
					ll=md+1;
					continue;
				}
				if (LL<=l1&&RR>=r1||LL<=l2&&RR>=r2||LL>=l&&LL+k-1<=r||RR<=r&&RR-k+1>=l) {
					res=max(res,dep[oo[p][md].first]);
					rr=md-1;
				} else ll=md+1;
			}
		}
	}
	return res;
}
int main() {
	// freopen("query.in","r",stdin);
	// freopen("query.out","w",stdout);
	read(n);
	for (int i{1};i<n;++i) {
		int u,v;read(u,v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	init(1,0);
	iota(st[0]+1,st[0]+1+n,1);
	for (int i{1};i<=LG;++i)
		for (int j{1<<i};j<=n;++j)
			st[i][j]=Max(st[i-1][j],st[i-1][j-(1<<i-1)]);
	build(1,1,n);
	int q;read(q);
	while (q--) {
		int l,r,k;read(l,r,k);
		cout<<qry(1,l,r,k,1,n)<<"\n";
	}
	return 0;
}
```

---

## 作者：Larunatrecy (赞：22)

首先不难证明 $\operatorname{LCA}(l,r)=\min\limits_{i=l}^{r-1}{dep_{\operatorname{LCA}(i,i+1)}}$，考虑相邻两个点的 LCA 深度构成的序列，我们就是要查询这个序列上某个区间内所有长度至少为 $k-1$ 的区间的最小值的最大值。

建出笛卡尔树后，我们可以求出以每个数作为最小值的极长区间 $[l_i,r_i]$，那么如果把 $(l,r)$ 看成二维平面上的点，极长区间 $[l_i,r_i]$ 的子区间就是 $(l_i,r_i)$ 的右下矩形。

而查询的则是 $(l,l+k-1) \to (r-k+1,r)$ 这一条斜率为 $1$ 的线段。

那么容易转化为：

- 有 $O(n)$ 个点，每个点会对其右下矩形取 $\max$；有 $m$ 个询问，每个询问给一个斜率为 $1$ 的线段，查询线段上的最大值。

![](https://cdn.luogu.com.cn/upload/image_hosting/lfv5vg1n.png)

如图，蓝色为查询线段，我们将其左上区域拆分成红色，绿色，黄色区域的并集，这三个区域都是一个前缀矩形，直接做三次扫描线维护区间最大值即可。

黄色区域只需要将平面旋转 $45$ 度就变成普通扫描线了。

复杂度 $O(n\log n)$。

---

## 作者：mskqwq (赞：20)

纪念这场把我创飞的 NOIP，为什么考场上写那么久还写不出来呢？

baka。

做过 [P7880](https://www.luogu.com.cn/problem/P7880) 应该很容易想到离线然后使用树上启发式合并预处理。设当前遍历到了点 $u$，对于所有 $u$ 轻子树中的结点 $x$，我们希望知道两个 $p,q$ 使得 $x \in [p,q]$，且 $[p,q]$ 中的点都在 $u$ 子树内，当然 $p$ 要尽量小，$q$ 要尽量大。于是 $x$ 的贡献就可以写成 $(p,q,dep_u)$ 这样的形势，对于一组询问 $(l,r,k)$，如果 $[l,r] \cap [p,q]$ 的大小 $\ge k$，那么就有 $dep_u$ 的贡献。

如何找出所有的 $(p,q,dep_u)$？考虑二分，我们需要知道一段区间内的数的 dfs 序的最大和最小值，以便判断这些数是否都在 $u$ 子树内，st 表预处理即可。

然后处理询问，通过分讨交在左边，交在右边，以及包含的情况，不难发现限制是一个二维偏序，简单处理即可。

这样做时间复杂度是 $O(n \log^2 n)$，不够优秀，尝试优化寻找三元组的部分。发现本质不同的 $[p,q]$ 连续段实际上只有 $O(n)$ 个，因为它一定是由若干个小的连续段拼起来的。考虑用并查集代替二分，记 $pre_x$ 和 $nxt_x$ 表示 $x$ 所在的连续段的左右端点，合并两段时并查集维护即可。

不算并查集的话复杂度 $O(n\log n)$，本地拍了几千组小数据，极限数据 2.5s。瓶颈在二维偏序，启发式合并只花了 0.6s，应该是线段树太慢了，被卡常再改吧。

upd：云斗上过了，应该没事。

```cpp
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <ctime>
#include <cstdio>
#include <random>
#include <vector>
#include <bitset>
#include <cassert>
#include <cstring>
#include <algorithm>
#define fi first
#define se second
#define MISAKA main
#define ll long long
#define eb emplace_back
#define pii pair<int,int>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _rep(i,a,b) for(int i=(a);i>=(b);--i)
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define FIO(FILE) freopen(FILE".in","r",stdin),freopen(FILE".out","w",stdout)
using namespace std;
bool __st;
inline int read(){
    char ch=getchar();int f=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
const int N=5e5+10,mod=998244353;
int n,q,dfn[N],id[N],siz[N],tim,son[N],dep[N],ans[N],nxt[N],pre[N];
vector<int> g[N];set<int> s;
struct node{int x,y,k,id;
    node(int a=0,int b=0,int c=0,int d=0){x=a,y=b,k=c,id=d;}
};vector<node> v1,v2;
bool cmp(node a,node b){return a.k>b.k;}
vector<pii> Q[N],v[N];
int gn(int x){return nxt[x]=x==nxt[x]?x:gn(nxt[x]);}
int gp(int x){return pre[x]=x==pre[x]?x:gp(pre[x]);}
void solve(int x,int L,int R,int d){
    int p=gp(x),q=gn(x),flag=0;
    while(L<=dfn[q+1]&&dfn[q+1]<=R) nxt[q]=q+1,pre[q+1]=q,q=gn(q+1),flag=1;
    while(L<=dfn[p-1]&&dfn[p-1]<=R) pre[p]=p-1,nxt[p-1]=p,p=gp(p-1),flag=1;
    if(flag) v1.eb(p,q,q-p+1,d),v[q].eb(p,d);
}
void dfs(int u,int f){
    dep[u]=dep[f]+1,siz[u]=1;id[dfn[u]=++tim]=u;
    for(int v:g[u])if(v!=f){
        dfs(v,u),siz[u]+=siz[v];
        if(siz[v]>siz[son[u]]) son[u]=v;
    }
}
void dfs(int u,int f,int tp){
    for(int v:g[u])if(v!=f&&v!=son[u]) dfs(v,u,0);
    if(son[u]) dfs(son[u],u,1);
    for(int v:g[u])if(v!=f&&v!=son[u])
        rep(i,dfn[v],dfn[v]+siz[v]-1) 
            solve(id[i],dfn[u],dfn[u]+siz[u]-1,dep[u]);
    solve(u,dfn[u],dfn[u]+siz[u]-1,dep[u]);
}
struct segtree{int l,r,mx;}t[N<<2];
void bd(int x,int l,int r){
    t[x]={l,r,0};int mid=l+r>>1;
    if(l^r) bd(2*x,l,mid),bd(2*x+1,mid+1,r);
}
void upd(int x,int p,int k){
    t[x].mx=max(t[x].mx,k);
    if(t[x].l^t[x].r) upd(2*x+(p>t[2*x].r),p,k);
}
int qry(int x,int l,int r){
    if(t[x].r<l||t[x].l>r) return 0;
    if(l<=t[x].l&&t[x].r<=r) return t[x].mx;
    return max(qry(2*x,l,r),qry(2*x+1,l,r));
}
void misaka(){
    n=read();
    rep(i,2,n){
        int u=read(),v=read();
        g[u].eb(v);g[v].eb(u);
    }
    dfs(1,0);
    rep(i,1,n) pre[i]=i,nxt[i]=i,v1.eb(i,i,1,dep[i]);
    dfs(1,0,1);q=read();
    rep(i,1,q){
        int l=read(),r=read(),k=read();
        Q[r].eb(l,i);v2.eb(l,r,k,i);
    }
    sort(v1.begin(),v1.end(),cmp);
    sort(v2.begin(),v2.end(),cmp);
    bd(1,1,n);
    int j=0;rep(i,0,v2.size()-1){
        while(j<v1.size()&&v1[j].k>=v2[i].k) 
            upd(1,v1[j].y,v1[j].id),j++;
        int id=v2[i].id,l=v2[i].x+v2[i].k-1,r=v2[i].y;
        ans[id]=max(ans[id],qry(1,l,r));
    }
    bd(1,1,n);
    j=0;rep(i,0,v2.size()-1){
        while(j<v1.size()&&v1[j].k>=v2[i].k) 
            upd(1,v1[j].x,v1[j].id),j++;
        int id=v2[i].id,l=v2[i].x,r=v2[i].y-v2[i].k+1;
        ans[id]=max(ans[id],qry(1,l,r));
    }
    bd(1,1,n);
    _rep(i,n,1){
        for(auto [x,y]:v[i]) upd(1,x,y);
        for(auto [x,y]:Q[i]) ans[y]=max(ans[y],qry(1,1,x));
    }
    rep(i,1,q) printf("%d\n",ans[i]);
}
bool __ed;
signed MISAKA(){
    #ifdef LOCAL_MSK
    atexit([](){
    debug("\n%.3lfs ",(double)clock()/CLOCKS_PER_SEC);
    debug("%.3lfMB",abs(&__st-&__ed)/1024./1024);});
    #endif
    int T=1;
    while(T--) misaka();
    return 0;
}

```

---

## 作者：Fishing_Boat (赞：16)

我们称一个区间有贡献，当且仅当不存在一个更大的区间包含该区间，且这两个区间的 $\text{LCA}$ 相同。

一个有贡献的区间，要么是单独的一个点，要么是由两段连续且有贡献的区间合并来的。

因为区间只会合并 $n-1$ 次，所以有贡献的区间不超过 $2n$ 个。如果特判掉长度为 $1$ 的区间，那就降到 $n$ 以下了。

$\text{dfs}$ 记录每个区间左端点及右端点，通过启发式合并加并查集来维护，时间复杂度 $O(n\log n)$。（我用的是 $\text{map}$，多了个 $\log$，希望不要被卡）。

上述步骤也能使用笛卡尔树实现，可以看别的题解。

问题转化为有若干修改区间和查询区间，对于每一个查询区间，求与它的并集大小大于等于 $k_i$ 的修改区间中的最大值。

记修改区间为 $[L_i,R_i]$，查询区间为 $[l_i,r_i]$。

将修改区间对查询区间的贡献分为两类，一类为修改区间没有被查询区间包含，一类被包含。

对于前一类，等价于求出所有形如 $L_j\le l_i$ 的贡献，以及形如 $R_j\ge r_i$ 的贡献，后者可视为将前者翻转后重做一遍。

对于每个查询区间 $[l_i,r_i]$，所有 $L_j\le l_i \wedge R_j \ge l_i+k_i-1$ 的修改区间对其产生贡献。可以根据左端点排序，双指针加线段树即可。

对于后一类，对于每个查询区间 $[l_i,r_i]$，所有 $L_j\in [l_i,r_i-k_i+1] \ \wedge R_j-L_j+1\ge k_i$ 的修改区间对其产生贡献。可以根据修改区间长度以及 $k_i$ 排序，双指针加线段树亦可。总的时间复杂度 $O(n\log n)$。

> **update**: 其实第一类中 $R_j\ge r_i$ 在第二类中已经算过了，所以没必要再做一遍，可将分类改为修改区间的左端点是否被查询区间包含。

代码（基本还原的考场代码，时间复杂度 $O(n\log^2n)$，[民间数据评测记录](https://www.luogu.com.cn/record/192243538)）：

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define ll long long
#define cmax(a,b) a=max(a,b)
#define cmin(a,b) a=min(a,b)
#define rst(a,x) memset(a,x,sizeof(a))
#define ls p<<1
#define rs p<<1|1
#define lowbit(x) ((x)&-(x))
#define FAST ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define file(filename) FAST;freopen(filename ".in","r",stdin);freopen(filename ".out","w",stdout);
#define Test(filename,number) FAST;freopen(filename number ".in","r",stdin);freopen(filename ".out","w",stdout);

using namespace std;

const int N(5e5+5);

struct segment_tree{
	int t[N<<2];
	void build(int l,int r,int p){
		t[p]=0;
		if(l==r) return ;
		int mid=l+r>>1;
		build(l,mid,ls);build(mid+1,r,rs);
	}
	void update(int l,int r,int p,int x,int v){
		if(l==r) return cmax(t[p],v),void();
		int mid=l+r>>1;
		if(x<=mid) update(l,mid,ls,x,v);
		else update(mid+1,r,rs,x,v);
		t[p]=max(t[ls],t[rs]);
	}
	int query(int l,int r,int p,int L,int R){
		if(L<=l&&r<=R) return t[p];
		int mid=l+r>>1,res=0;
		if(L<=mid) res=query(l,mid,ls,L,R);
		if(R>mid) cmax(res,query(mid+1,r,rs,L,R));
		return res;
	}
}T;

int n,m,q,dep[N],ans[N];
struct node{
	int l,r,v,id;
}a[N<<1],b[N];
vector <int> G[N]; 
map <int,int> mp[N];

void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	a[++m]={u,u,dep[u],1};
	mp[u][u]=u;
	for(int v:G[u]){
		if(v==fa) continue;
		dfs(v,u);
		if(mp[v].size()>mp[u].size()) swap(mp[u],mp[v]);
		for(auto x:mp[v]){
			int l=x.first,r=x.second;bool flag=0;
			auto it=mp[u].upper_bound(r);
			if(it!=mp[u].end()&&it->first==r+1){
				r=it->second;
				mp[u].erase(it);
				flag=1;
			}
			it=mp[u].upper_bound(r);
			if(it!=mp[u].begin()){
				it--;
				if(it->second==l-1){
					l=it->first;
					mp[u].erase(it);
					flag=1;
				}
			}
			mp[u][l]=r;
			if(flag) a[++m]={l,r,dep[u],r-l+1};
		}
	}
}

void solve(){
	T.build(1,n,1);
	sort(a+1,a+m+1,[&](node x,node y){
		return x.l<y.l;	
	});
	sort(b+1,b+q+1,[&](node x,node y){
		return x.l<y.l;
	});
	for(int i=1,j=1;i<=q;i++){
		while(j<=m&&a[j].l<=b[i].l){
			T.update(1,n,1,a[j].r,a[j].v);
			j++;
		}
		cmax(ans[b[i].id],T.query(1,n,1,b[i].l+b[i].v-1,n));
	}
}

int main(){
	FAST
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1,0);
	cin>>q;
	for(int i=1;i<=q;i++){
		cin>>b[i].l>>b[i].r>>b[i].v;
		b[i].id=i;
	}
	sort(a+1,a+m+1,[&](node x,node y){
		return x.id>y.id;
	});
	sort(b+1,b+q+1,[&](node x,node y){
		return x.v>y.v;
	});
	for(int i=1,j=1;i<=q;i++){
		while(j<=m&&a[j].id>=b[i].v){
			T.update(1,n,1,a[j].l,a[j].v);
			j++;
		}
		ans[b[i].id]=T.query(1,n,1,b[i].l,b[i].r-b[i].v+1);
	}
	solve();
    //-----------------------------------------------------
	for(int i=1;i<=m;i++){
		swap(a[i].l,a[i].r);
		a[i].l=n-a[i].l+1,a[i].r=n-a[i].r+1;
	}
	for(int i=1;i<=q;i++){
		swap(b[i].l,b[i].r);
		b[i].l=n-b[i].l+1,b[i].r=n-b[i].r+1;
	} 
	solve();
    //----------------以上代码可以删除------------------------
	for(int i=1;i<=q;i++){
		cout<<ans[i]<<'\n';
	}
	return 0;
}

/*
things to check:
* Will it MLE?
* Is array big enough?
* Do you need long long?
* Is inf big enough?
* max or min?
* Yes,No or YES,NO?
* Is there anything extra to output?
* Did you Countershoot?
* Have you measured the limit data?
* More measurements should be cleared!!!
*/
```

---

## 作者：是青白呀 (赞：15)

首先，我们希望求出每个点作为 LCA 时的所有极长标号连续段。不妨做一个类似 dsu on tree（基于轻重链分治的那个算法，若做启发式合并会多一个 log），对于每个点，先遍历其所有子节点计算子节点答案，同时维护一个并查集，表示哪些标号的连续段已经找到了 LCA。注意这个并查集无需清空。所有儿子都走完后，枚举每一个轻子树内的点，观察其所在连通块左右两侧的点是否也在当前点的子树范围内，是则合并，此时可以得到 $O(n)$ 个连续段（每次合并都会消除一个空隙）。这部分总复杂度是 $O(n\log n)$。

然后问题变为：你有若干个线段 $[L,R,v]$，其中 $v$ 是其权值。每次询问给定一个 $(l,r,k)$，求与 $[l,r]$ 交集至少为 $k$ 的线段中，权值的最大值。考虑分类讨论：

- 若 $L\le l\le r\le R$，此时不必考虑 $k$ 的限制，把每一个线段挂在 $L$ 上，扫描左端点维护右端点，等价于查询 $[r,n]$ 内的权值最大值。
- 若 $L\le l\le R\le r$，此时有额外限制 $l\le R-k+1$。考虑从大到小扫描 $k$，则可以去除 $L\le l$ 的限制（此时同样考虑了 $l\le L\le R\le r$ 的情况），问题变为查询所有 $l\le R-k+1$ 且 $R\le r$ 的线段的权值最大值。不难发现需要满足的条件就是 $R\in[l+k-1,r]$，仍然是区间维护最大值。
- 若 $l\le L\le r\le R$，此时有额外限制 $r\geq L+k-1$。仍然扫描 $k$ 去掉 $R$ 的限制，此时需要满足的条件就是 $L\in [l,r-k+1]$，仍然是区间维护最大值。

因此做三次扫描线即可。复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define lowbit(i) (i&-i)
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=5e5+5,inf=1e9+7,mo=1e9+7;
void read(int &p){
    int w=1,x=0;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    p=w*x;
}
int n,m;
struct query{
    int l,r,k;
}q[N];
struct segs{
    int l,r,v;
}s[N*2];
int cnts;
vector<int>e[N];
int dep[N],sz[N],hson[N],dfn[N],nw[N],cntp;
struct bcj{
    int fa[N];
    void init(){
        rep(i,1,n)
            fa[i]=i;
    }
    int find(int x){
        if(fa[x]==x)return x;
        return fa[x]=find(fa[x]);
    }
    void merge(int x,int y){//y->x
        x=find(x),y=find(y);
        if(x==y)return;
        fa[y]=x;
    }
}B[2];
void dfs1(int x,int f){
    dep[x]=dep[f]+1;
    sz[x]=1,dfn[x]=++cntp,nw[cntp]=x;
    for(auto j:e[x]){
        if(j==f)continue;
        dfs1(j,x),sz[x]+=sz[j];
        if(sz[j]>sz[hson[x]])hson[x]=j;
    }
}
void merge(int x,int nwp){
    int le=B[0].find(x),ri=B[1].find(x),yl=le,yr=ri;
    while(le>1&&dfn[le-1]>=dfn[nwp]&&dfn[le-1]<=dfn[nwp]+sz[nwp]-1)
        B[0].merge(le-1,le),B[1].merge(le,le-1),le=B[0].find(le);
    while(ri<n&&dfn[ri+1]>=dfn[nwp]&&dfn[ri+1]<=dfn[nwp]+sz[nwp]-1)
        B[1].merge(ri+1,ri),B[0].merge(ri,ri+1),ri=B[1].find(ri);
    if(le!=yl||ri!=yr)s[++cnts]=(segs){le,ri,dep[nwp]};
}
void dfs2(int x,int f){
    for(auto j:e[x])
        if(j!=f)dfs2(j,x);
    for(auto j:e[x]){
        if(j==f||j==hson[x])continue;
        rep(i,dfn[j],dfn[j]+sz[j]-1)
            merge(nw[i],x);
    }
    merge(x,x);
}
struct seg{
    int t[N*4];
    void build(int x,int le,int ri){
        t[x]=0;
        if(le==ri)return;
        int mid=(le+ri)>>1;
        build(ls(x),le,mid),build(rs(x),mid+1,ri);
    }
    void pushup(int x){
        t[x]=max(t[ls(x)],t[rs(x)]);
    }
    void modify(int x,int le,int ri,int p,int v){
        if(le==ri){
            t[x]=max(t[x],v);
            return;
        }
        int mid=(le+ri)>>1;
        if(p<=mid)modify(ls(x),le,mid,p,v);
        else modify(rs(x),mid+1,ri,p,v);
        pushup(x);
    }
    int query(int x,int le,int ri,int ql,int qr){
        if(ql<=le&&qr>=ri)return t[x];
        int mid=(le+ri)>>1,res=0;
        if(ql<=mid)res=max(res,query(ls(x),le,mid,ql,qr));
        if(qr>mid)res=max(res,query(rs(x),mid+1,ri,ql,qr));
        return res;
    }
}T;
vector<int>vq[N],vs[N];
int ans[N];
signed main(){
    read(n);
    rep(i,1,n-1){
        int x,y;
        read(x),read(y);
        e[x].push_back(y),e[y].push_back(x);
    }
    dfs1(1,0);
    rep(i,0,1)
        B[i].init();
    rep(i,1,n)
        s[++cnts]=(segs){i,i,dep[i]};
    dfs2(1,0);
    read(m);
    rep(i,1,m)
        read(q[i].l),read(q[i].r),read(q[i].k);
    //1.
    rep(i,1,cnts)
        vs[s[i].l].push_back(i);
    rep(i,1,m)
        vq[q[i].l].push_back(i);
    rep(i,1,n){
        for(auto j:vs[i])
            T.modify(1,1,n,s[j].r,s[j].v);
        for(auto j:vq[i])
            ans[j]=max(ans[j],T.query(1,1,n,q[j].r,n));
        vs[i].clear(),vq[i].clear();
    }
    //2.
    T.build(1,1,n);
    rep(i,1,cnts)
        vs[s[i].r-s[i].l+1].push_back(i);
    rep(i,1,m)
        vq[q[i].k].push_back(i);
    repp(i,n,1){
        for(auto j:vs[i])
            T.modify(1,1,n,s[j].r,s[j].v);
        for(auto j:vq[i])
            ans[j]=max(ans[j],T.query(1,1,n,q[j].l+q[j].k-1,q[j].r));
    }
    //3.
    T.build(1,1,n);
    repp(i,n,1){
        for(auto j:vs[i])
            T.modify(1,1,n,s[j].l,s[j].v);
        for(auto j:vq[i])
            ans[j]=max(ans[j],T.query(1,1,n,q[j].l,q[j].r-q[j].k+1));
    }
    rep(i,1,m)
        printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：lzyqwq (赞：15)

感谢这题给我送退役了。

题意很简洁了，这里不再概括。

考虑到 $\text{dfn}$ 最小值和最大值两个点求一下 $\text{LCA}$ 的做法和我一样没有前途，因此换一条路冲，注意到一个结论：

> 记 $a_i=\text{dep}_{\text{LCA}(i,i+1)}$，则当 $l\ne r$ 时 $\text{dep}_{\text{LCA}^*(l,r)}=\min\limits_{i=l}^{r-1}a_i$。

证明：

- 随着区间的扩展 $\text{LCA}$ 深度一定不升，因此 $\text{LHS} \le \text{RHS}$。
- 考虑区间 $\text{LCA}=x$，则一定存在区间内两个点 $i,j(i<j)$ 来自于 $x$ 的不同子树。此时 $[i,j)$ 中一定存在一个位置 $p$ 满足 $p$ 和 $p+1$ 来自不同子树，则 $a_p$ 会取到 $\text{dep}_x$。

因此把 $k=1$ 的询问判掉之后，令 $r\leftarrow r-1,k
\leftarrow k-1$。则问题变成求一个子区间 $[l',r']\sube [l,r]$ 满足 $r'-l'+1\ge k$ 且区间最小值最大。

$\mathcal{O}\left(n\log^2 n\right)$ 已经随便做了，但我们姑且认为她是过不了的。

考虑枚举答案 $v$，找到所有 $a_i\ge v$ 的极长连续段，则只要询问区间 $[l,r]$ 和极长连续段交集对应的区间长度 $\ge k$，那么答案就可以 $\ge v$。因此答案是最大的 $v$ 使得存在一个 $a_i\ge v$ 的极长连续段 $[l',r'] $ 和 $[l,r]$ 的交集区间长度 $\ge k$。

极长连续段可以这样找：从大到小加入 $a_i$，每次尝试和左右相邻的极长连续段合并。这样一定会找到极长连续段，还会找到一些非极长的。但是没关系，跟非极长交出来区间长度 $\ge k$ 则和极长的交出来的区间长度也一定 $\ge k$。这个过程可以 `set` 维护。

此时如果你考虑两个区间的关系为包含、被包含、左边相交、右边相交四类，会搞出三维偏序来，无法接受。但是可以不这么拆。

考虑将答案分成以下有重叠且并集为全集的部分，重叠显然不影响最大值：

- $l\le l'$。
- $r\ge r'$。
- $l'\le l\le r\le r'$。

第三种交集是整个区间肯定合法，因此是求这个范围内的极长连续段的 $v$ 最大值，扫描线 + BIT 维护即可。

至于前两种是类似的，以第一种为例。

此时要求 $l'\in[l,r-k+1]$ 才能交出长度 $\ge k$ 的子区间。我们发现剩下仅需要满足 $r'-l'+1\ge k$ 就够了。这个是充要的，可以讨论 $r',r$ 的大小关系证。

那么看成关于 $l'$ 和 $r'-l'+1$ 两维的二维偏序即可。由于是 $3-\text{side}$ 因此用线段树 + 扫描线维护。

时间复杂度为 $\mathcal{O}(n\log n)$，空间复杂度为 $\mathcal{O}(n)$。

[AC Link](https://www.luogu.com.cn/record/192259871) & [Code](https://www.luogu.com.cn/paste/m07y8lze)

> 知不可乎骤得，托遗响于悲风。你不能只在进省队的时候才热爱 OI。你不能只在切出 DS 的时候才热爱 DS。

---

## 作者：_•́へ•́╬_ (赞：13)

## 思路

我是先考虑了链的性质再得到这个做法的。

考虑对于一个点（即一棵子树）找他能贡献到哪些询问。这个贡献显然就是这个点（子树根）的深度。找出该子树的所有编号值域连续段。当然应该找极长的。

设 $u$ 为 $v$ 的父亲。如果某个连续段，$u$ 也有，$v$ 也有，那么 $u$ 的这个连续段就完全没用，显然 $v$ 的深度更大，答案更优。故不在 $u$ 处记录这个连续段。

根据上面一段话，考虑树上启发式合并，儿子的连续段直接给到父亲的，父亲无须记录；儿子给到父亲的时候发生了多个儿子的多个连续段合并，产生了新的大连续段，则记录下来。

编号 $i$ 与 $i+1$ 之间只会合并一次，故合并只会有至多 $n-1$ 次，再加上 $n$ 个单点，总共是至多 $2n-1$ 个记录下来的段。

这些段记录下来怎么贡献到询问呢？

设我有一个段 $[L,R]$，一个询问 $[l,r,k]$。

当 $L\leq l\leq R\leq r$ 时，有贡献当且仅当 $R-l+1\geq k$。此时 $\operatorname{LCA^*}(l,R)$ 就是这个段的来源的那个点。

当 $l\leq L\leq r\leq R$ 时，同理。

这两种二维偏序贡献一下即可。

当 $l\leq L\leq R\leq r$ 时，有贡献当且仅当 $R-L+1\geq k$。

根据 stcm 的结论，注意到所有的段 $[L,R]$ 只包含或相离，不交叉。把所有的段按 $R-L$ 从大到小排序，所有询问按 $k$ 从大到小排序。加入小的段的时候删除大的段，线段树一下即可。

贡献复杂度 $\mathcal O(n\log n)$。前面的找出连续段的过程，我场上写的启发式合并 $\mathcal O(n\log^2 n)$，也可以优化到 $\mathcal O(n\log n)$，但是没写。

## Implementation

```cpp
#include<stdio.h>
#include<map>
#include<string.h>
#include<algorithm>
#define N 500009
#define lc ((i)<<1|1)
#define rc ((i)+1<<1)
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int n,m,q,h[N],e[N<<1],nxt[N<<1],ans[N],szsz[N],tre[N<<2];
map<int,int>mmp;
struct node{int l,r,k,id;}a[N<<1],b[N];
inline bool cmp1(const node&x,const node&y){return x.l<y.l;}
inline bool cmp2(const node&x,const node&y){return x.r>y.r;}
inline bool cmp3(const node&x,const node&y){return x.r-x.l>y.r-y.l;}
inline bool cmp4(const node&x,const node&y){return x.k>y.k;}
inline map<int,int>dfs(int i,int f,int dep)
{
	map<int,int>u;u[i]=i;a[m++]=(node){i,i,dep};
	for(int j=h[i];j;j=nxt[j])if(e[j]^f)
	{
		map<int,int>v=dfs(e[j],i,dep+1);
		if(u.size()<v.size())u.swap(v);
		for(map<int,int>::iterator it=v.begin();it!=v.end();++it)
		{
			map<int,int>::iterator i=u.emplace(*it).first,j=i;
			bool ok=0;
			if(j!=u.begin())
			{
				--j;
				if(j->second+1==i->first)
				{
					ok=1;
					j->second=i->second;
					u.erase(i);i=j;
				}
			}
			j=i;++j;
			if(j!=u.end())if(i->second+1==j->first)
			{
				ok=1;
				i->second=j->second;
				u.erase(j);
			}
			if(ok)a[m++]=(node){i->first,i->second,dep};
		}
	}
	return u;
}
inline void max(int&x,int y){if(x<y)x=y;}
inline void upd(int i,int x){for(;i<=n;max(szsz[i],x),i+=i&-i);}
inline int qry(int i){int ans=0;for(;i;max(ans,szsz[i]),i&=i-1);return ans;}
inline void upd(int i,int l,int r,int p,int x)
{
	max(tre[i],x);
	if(l==r)return;
	int mid=l+r>>1;
	if(p<=mid)upd(lc,l,mid,p,x);
	else upd(rc,mid+1,r,p,x);
}
inline int qry(int i,int l,int r,int ql,int qr)
{
	if(qr<l||r<ql)return 0;
	if(ql<=l&&r<=qr)return tre[i];
	int mid=l+r>>1;
	int x=qry(lc,l,mid,ql,qr);
	max(x,qry(rc,mid+1,r,ql,qr));
	return x;
}
main()
{
	freopen("query.in","r",stdin);freopen("query.out","w",stdout);
	read(n);
	for(int i=1,u,v;i<n;++i)read(u),read(v),--u,--v,
		e[i]=v,nxt[i]=h[u],h[u]=i,
		e[i+n]=u,nxt[i+n]=h[v],h[v]=i+n;
	dfs(0,0,1);

	read(q);
	for(int i=0;i<q;++i)read(b[i].l),--b[i].l,read(b[i].r),--b[i].r,
		read(b[i].k),b[i].id=i;

	sort(a,a+m,cmp1);sort(b,b+q,cmp1);
	for(int i=0,j=0;j<q;)if(i<m&&a[i].l<b[j].l)
		upd(n-a[i].r,a[i].k),++i;
	else max(ans[b[j].id],qry(n-(b[j].l+b[j].k-1))),++j;

	sort(a,a+m,cmp2);sort(b,b+q,cmp2);memset(szsz,0,sizeof(szsz));
	for(int i=0,j=0;j<q;)if(i<m&&a[i].r>b[j].r)
		upd(a[i].l+1,a[i].k),++i;
	else max(ans[b[j].id],qry(b[j].r-b[j].k+1+1)),++j;

	sort(a,a+m,cmp3);sort(b,b+q,cmp4);
	for(int i=0,j=0;j<q;)if(i<m&&a[i].r-a[i].l+1>=b[j].k)
	{
		map<int,int>::iterator it=mmp.upper_bound(a[i].l);
		if(it!=mmp.begin())
		{
			--it;
			if(it->first<=a[i].l&&a[i].r<=it->second)mmp.erase(it);
		}
		mmp[a[i].l]=a[i].r;
		upd(0,0,n-1,a[i].r,a[i].k);++i;
	}
	else
	{
		map<int,int>::iterator it=mmp.lower_bound(b[j].l);
		if(it!=mmp.end())
			max(ans[b[j].id],qry(0,0,n-1,it->first,b[j].r));
		++j;
	}

	for(int i=0;i<q;printf("%d\n",ans[i++]));
}
```

---

## 作者：VainSylphid (赞：13)

献给我死去的 NOIP2024。考场上没写出来纯自己作的，哈哈。

---

不用观察小样例，注意到这个 $\text{dep}_{\text{LCA*}(l', r')}$ 实际上可以用 $\min_{l\leq i\leq r-1}dep_{\text{lca}(i,i+1)}$ 计算，考场打个暴力过一下样例二就行了，证明也很简单，在树上手玩一下即可。

现在我们就可以把那棵树扔掉了。记 $w_i$ 为 $dep_{\text{lca}(i,i+1)}$，原问题就变成了在 $[l,r-1]$ 中找一个长度大于等于 $k-1$ 的子区间 $[l',r']$ 使得 $\min_{l'\leq i\leq r'}w_i$ 尽可能大。

这个问题有三千八百万种做法，考场上为什么对着一种假做法写一个小时呢？？？

考虑对每个 $w_i$ 计算它的贡献区间。它的贡献区间应该是形如 $\text{pre}_i+1\leq l\leq i,i\leq r\leq \text{nxt}-1$ 的区间 $[l,r]$，其中 $\text{pre}_i$ 和 $\text{nxt}_i$ 容易使用单调栈计算。

考虑询问的东西和贡献区间在二维平面上都长什么样。没观察样例容易发现答案肯定在 $r'-l'+1=k-1$ 的时候取到，这在二维平面上是一条斜率为 $1$ 的线段。

每个 $w_i$ 的贡献区间则是一个矩形，纵轴上是 $[\text{pre}_i+1,i]$，横轴上是 $[i,\text{nxt}_i-1]$。

![考场都想出来这玩意了不想想怎么优化？？？](https://cdn.luogu.com.cn/upload/image_hosting/64u96mh1.png)

接下来有一个弱智的观察是，如果条斜线段被某个矩形完全覆盖了，那么我们随便取线段上的一点计算答案。否则它一定经过矩形的四条边，我们只要保留每个矩形的四条边算贡献就行了。

对于所有有贡献的水平线段和询问的斜线段，做一次平移就可以变成非常弱智的二维数点问题。竖直线段同理。于是我们就用 $O((n+q)\log n)$ 的复杂度解决了这个问题。

代码还在写，如果要退役了就不写了。细节应该就是 $k=1$ 需要单独写一个 $\text{RMQ}$ 处理，以及实现的时候不需要判询问线段和矩形的边界是否有交，取更优的就行了。

---

## 作者：sidekick257 (赞：8)

> 由于某些原因，某字已被替换为"萌"。

显然的，区间 $lca$ 就是相邻数对 $lca$ 中 $dep$ 最小的，所以问题转化为最大化区间内问长度为 $k$ 的子区间的最小值。

直接二分这个最小值，把大于等于的当作 $1$，小于的当作 $0$，相当于询问区间内是否存在长度为 $k$ 的 $1$ 的连续段，可以用线段树维护区间最长连续段判断是否大于等于 $k$ 即可，这个是可以整体二分的，注意要把相同的值离散化成不同的值，不然会同一个点有多次指针移动，时间复杂度 $O(n\log^2 n)$。

loj 可过，目测 ccf 机子也能过。


```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
void print(int x){
    if(x>9) print(x/10);
    *O++=x%10+'0';
}
const int N=5e5+4,K=20;
int n,q,fa[N],dep[N],cd[N],dfn[N],nfd[N],idx,st[N][K],lg[N],sz[N];
vector<int> g[N];
struct ququ{
    int l,r,k,id;
}qu[N];
ququ qq[N],qqq[N];
void dfs1(int x){
    dep[x]=dep[fa[x]]+1;
    nfd[dfn[x]=++idx]=x;
    sz[x]=1;
    for(auto y:g[x]){
        if(y==fa[x]) continue;
        fa[y]=x;
        dfs1(y);
        sz[x]+=sz[y];
    }
}
int get(int x,int y){return dep[x]<dep[y]?x:y;}
void init(){
    for(int i=1;i<=n;i++) st[dfn[i]][0]=i;
    for(int i=1;i<K;i++)
        for(int j=1;j+(1<<i)-1<=n;j++) st[j][i]=get(st[j][i-1],st[j+(1<<(i-1))][i-1]);
}
int qst(int l,int r){
    int len=lg[r-l+1];
    return get(st[l][len],st[r-(1<<len)+1][len]);
}
int lca(int x,int y){
    if(x==y) return x;

    if(dfn[x]>dfn[y]) swap(x,y);
    return fa[qst(dfn[x]+1,dfn[y])];
}
int ans[N];
struct node{
    int l,r,v,len;
    node operator +(const node b)const{
        node c;
        if(l==len) c.l=len+b.l;
        else c.l=l;
        if(b.r==b.len) c.r=b.len+r;
        else c.r=b.r;
        c.v=max(max(v,b.v),r+b.l);
        c.len=len+b.len;
        return c;
    }
}t[N<<1];
int a[N],b[N],d[N],e[N],cnt[N],f[N],m,qqqq;
void out(node x){
    cerr<<x.l<<" "<<x.r<<" "<<x.v<<" "<<x.len<<"\n";
}
int query(int l,int r){
    node ansl,ansr;
    bool fl=0,fr=0;
    for(l+=m-1,r+=m;l<r;l>>=1,r>>=1){
        if(l&1){
            if(!fl) ansl=t[l++],fl=1;
            else ansl=ansl+t[l++];
        }
        if(r&1){
            if(!fr) ansr=t[--r],fr=1;
            else ansr=t[--r]+ansr;
        }
    }
    if(!fl) return ansr.v;
    if(!fr) return ansl.v;
    return (ansl+ansr).v;
}
void update(int x,int v){
    x+=m-1;
    t[x]={v,v,v,1};
    for(x>>=1;x;x>>=1)
        t[x]=t[x<<1]+t[x<<1|1];
}
int last;
void ef(int l,int r,int L,int R){
    if(L>R) return;
    if(l==r){
        for(int i=L;i<=R;i++)
            ans[qq[i].id]=f[l];
        return;
    }
    int mid=(l+r+1)>>1;
    while(last>mid)
        update(e[--last],1);
    while(last<mid)
        update(e[last++],0);
    int M=L,rr=R;
    for(int i=L;i<=R;i++){
        int res=query(qq[i].l,qq[i].r);
        if(res<qq[i].k) qqq[M++]=qq[i];
        else qqq[rr--]=qq[i];
    }
    for(int i=L;i<=R;i++) qq[i]=qqq[i];
    ef(l,mid-1,L,M-1);
    ef(mid,r,rr+1,R);
}
void solve(){
    last=1;
    for(int i=1;i<=m;i++) t[i+m-1]={1,1,1,1};
    for(int i=m-1;i;i--) t[i]=t[i<<1]+t[i<<1|1];
    ef(1,n-1,1,qqqq);
    for(int i=1;i<=q;i++) print(ans[i]),*O++=10;
}
namespace sgt{
    int t[N<<1];
    void init(){
        for(int i=1;i<=n;i++) t[i+n-1]=dep[i];
        for(int i=n-1;i;i--) t[i]=max(t[i<<1],t[i<<1|1]);
    }
    int query(int l,int r){
        int ans=0;
        for(l+=n-1,r+=n;l<r;l>>=1,r>>=1){
            if(l&1) ans=max(ans,t[l++]);
            if(r&1) ans=max(ans,t[--r]);
        }
        return ans;
    }
}
signed main(){
    // freopen("query.in","r",stdin);
    // freopen("query.out","w",stdout);
    n=read();
    for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
    for(int i=1,x,y;i<n;i++){
        x=read(),y=read();
        g[x].push_back(y),g[y].push_back(x);
    }
    dfs1(1);
    init();
    for(int i=1;i<n;i++) b[i]=a[i]=dep[lca(i,i+1)];
    m=n-1;
    sort(b+1,b+m+1);
    m=unique(b+1,b+m+1)-b-1;
    for(int i=1;i<=m;i++)
        d[b[i]]=i;
    for(int i=1;i<n;i++) cnt[d[a[i]]]++;
    for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];
    for(int i=1;i<n;i++){
        int k=d[a[i]];
        a[i]=cnt[d[a[i]]]--;
        f[a[i]]=b[k];
    }
    m=n-1;
    sgt::init();
    for(int i=1;i<n;i++) e[a[i]]=i;
    q=read();
    for(int i=1;i<=q;i++){
        int l=read(),r=read(),k=read();
        if(l==r){
            ans[i]=dep[l];
            continue;
        }
        if(k==1){
            ans[i]=sgt::query(l,r);
            continue;
        }
        r--,k--;
        qq[++qqqq]={l,r,k,i};
    }
    solve();
    fwrite(obuf,O-obuf,1,stdout);
    return 0;
}
```

---

## 作者：Xy_top (赞：8)

差一步没想出来也是没想出来，没想出来就是菜。

场上各花了 $40$ 分钟把 ``T1`` ``T2`` 切掉，感觉自己数据结构能力比较强，然后 ``T3`` 看上去就不太好欺负的样子于是直接开这题，然而最后只拿了 $32$ 分/kk。

正难则反，考虑统计每个点作为 ``LCA`` 可以在哪些询问时贡献答案，发现一定是子树中有至少两个连续编号节点，这些节点的 ``LCA`` 是它，然后下标向左向右扩展。

这就启发我们把 $(i,i+1)$ 挂到它们的 ``LCA`` 下面，这个数对也只有可能在这个点被统计，再向上这两个点将来自同一个子树，再向下这两个点就不在子树内。

此外，我们可以考虑线段树合并（不会的去看 [Alex_wei 大神的博客](https://www.cnblogs.com/alex-wei/p/18356369/SegmentTreePart1)），这样方便统计每个子树内某个节点是否存在，以及维护连续存在的节点向左向右扩张最远能到哪里，不会的去看 [P2572](https://www.luogu.com.cn/problem/P2572)。

那么接下来怎么做呢？我们假设扩展出来的最大连续区间为 $[L,R]$，此时在节点 $u$，其中连续点对为 $[x,x+1]$（显然，$x$ 与 $x+1$ 的 ``LCA`` 为 u，注意可能有多个，那就都跑一遍），分为两种情况：

case1：

询问区间 $[l,r] \in [L,R]$ 且 $[x,x+1]\in[l,r]$，此时的答案一定可以为 $dep_u$（全选），当时到这里就不会了。现在一想，显然不必要求 $[x,x+1] \in [l, r]$，这样统计到的区间，它们的 ``LCA`` 可能深度更大，我们却把它当成 $dep_u$ 统计。但是这样的区间又会各自在它们的 ``LCA`` 处被统计一遍，所以我们可以大胆的统计。总结一下，此时的区间 $[l,r,k]$ 满足 $l \geq L$ 并且 $R\geq r$，按照左端点排序消掉一维，右端点加在线段树上即可。

case 2：

$[L,R]$ 与 $[l, r]$ 交集不为空，且交集长度 $\geq k$，此时要求 $l\leq R - k + 1$，此时可以钦定 $r> R$，因为 $r\leq R$ 时已经被统计过了。也可以 $r \geq L + k-1$，此时有 $l< L$。同理这个是必要条件，如果我们每个都统计一遍绝对能找到最小的答案。（这个考场上也想到了）这种情况对于区间长度从大到小排序然后依次加入也可以用 $O(n\log n)$ 复杂度维护。


代码：

```cpp
#include <bits/stdc++.h>
#define For(i, a, b) for (register int i = (a); i <= (b); i ++)
#define foR(i, a, b) for (register int i = (a); i >= (b); i --)
#define getchar() (S==T&&(T=(S=B)+fread(B,1,1<<19,stdin),S==T)?EOF:*S++)
char B[1<<20],*S=B,*T=B;
using namespace std;
int n, q, k, k_, cnt, ccnt;
int faa[500005][19], ans[500005], dep[500005], pre[20], head[500005], Head[500005];
int ls[10000005], rs[10000005], root[500005], lmax[10000005], rmax[10000005];
int mx[2000005], st[19][500005], lg[500005];
struct Edge {int v, nxt;}e[1000005];
struct node {int v, nxt;}nn[500005];
inline void add (int u, int v) {
	e[++ k] = {v, head[u]};
	head[u] = k;
}
inline void Add (int u, int v) {
	nn[++ k_] = {v, Head[u]};
	Head[u] = k_;
}
struct Node {int L, R, len, res;}a[1000005];
inline bool cmp1 (Node n1, Node n2) {return n1.L < n2.L;};
inline bool cmp2 (Node n1, Node n2) {return n1.len > n2.len;}
struct Query {int l, r, k, id;}u[500005];
inline bool cmpq1 (Query q1, Query q2) {return q1.l < q2.l;}
inline bool cmpq2 (Query q1, Query q2) {return q1.k > q2.k;}
inline int read () {
	char ch = getchar ();
	int x = 0;
	while (ch < 48 || ch > 57) ch = getchar ();
	while (ch >= 48 && ch <= 57) {
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar ();
	}
	return x;
}
inline void dfs1 (int u) {
	st[0][u] = dep[u];
	For (i, 1, 18) faa[u][i] = faa[faa[u][i - 1] ][i - 1];
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].v;
		if (v == faa[u][0]) continue;
		faa[v][0] = u;
		dep[v] = dep[u] + 1;
		dfs1 (v);
	}
}
inline int lca (int u, int v) {
	if (dep[u] < dep[v]) swap (u, v);
	foR (i, 18, 0) if (dep[faa[u][i] ] >= dep[v]) u = faa[u][i];
	if (u == v) return u;
	foR (i, 18, 0) if (faa[u][i] != faa[v][i]) {
		u = faa[u][i];
		v = faa[v][i];
	}
	return faa[u][0];
}
inline void pushup (int l, int r, int k) {
	int mid = l + r >> 1;
	if (rmax[rs[k] ] == r - mid) rmax[k] = r - mid + rmax[ls[k] ];
	else rmax[k] = rmax[rs[k] ];
	if (lmax[ls[k] ] == mid - l + 1) lmax[k] = lmax[ls[k] ] + lmax[rs[k] ];
	else lmax[k] = lmax[ls[k] ];
}
inline int merge (int l, int r, int k1, int k2) {
	if (!k1 || !k2) return k1 | k2;
	if (l == r) {
		lmax[k2] = max (lmax[k1], lmax[k2]);
		rmax[k2] = max (rmax[k1], rmax[k2]);
		return k2;
	}
	int mid = l + r >> 1;
	ls[k2] = merge (l, mid, ls[k1], ls[k2]);
	rs[k2] = merge (mid + 1, r, rs[k1], rs[k2]);
	pushup (l, r, k2);
	return k2;
}
inline int query (int l, int r, int k, int x, int y, int type) {
	if (!k) return 0;
	if (x <= l && y >= r) return (type == 1 ? lmax[k] : rmax[k]);
	int mid = l + r >> 1;
	if (y <= mid) return query (l, mid, ls[k], x, y, type);
	if (x > mid) return query (mid + 1, r, rs[k], x, y, type);
	if (type == 1) {
		int xx = query (l, mid, ls[k], x, y, type);
		if (xx == mid - x + 1) return xx + query (mid + 1, r, rs[k], x, y, type);
		return xx;
	}
	int xx = query (mid + 1, r, rs[k], x, y, type);
	if (xx == y - mid) return xx + query (l, mid, ls[k], x, y, type);
	return xx;
}
inline void update (int l, int r, int k, int x) {
	if (l == r) return void (lmax[k] = rmax[k] = 1);
	int mid = l + r >> 1;
	if (x <= mid) {
	    if (!ls[k]) ls[k] = ++ cnt;
	    update (l, mid, ls[k], x);
	}
	else {
	    if (!rs[k]) rs[k] = ++ cnt;
	    update (mid + 1, r, rs[k], x);
	}
	pushup (l, r, k);
}
inline void dfs2 (int u) {
	update (1, n, root[u], u);
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].v;
		if (v == faa[u][0]) continue;
		dfs2 (v);
		root[u] = merge (1, n, root[v], root[u]);
	}
	for (int j = Head[u]; j; j = nn[j].nxt) {
		int i = nn[j].v;
		a[++ ccnt] = {i - query (1, n, root[u], 1, i, 2) + 1, i + query (1, n, root[u], i + 1, n, 1), 0, dep[u]};
		a[ccnt].len = a[ccnt].R - a[ccnt].L + 1;
	}
}
inline void modify (int l, int r, int k, int x, int y) {
	if (l == r) return void (mx[k] = max (mx[k], y) );
	int mid = l + r >> 1;
	if (x <= mid) modify (l, mid, k << 1, x, y);
	else modify (mid + 1, r, k << 1 | 1, x, y);
	mx[k] = max (mx[k << 1], mx[k << 1 | 1]);
}
inline int qmax (int l, int r, int k, int x, int y) {
	if (x > y) return 0;
	if (x <= l && y >= r) return mx[k];
	int mid = l + r >> 1, res = 0;
	if (x <= mid) res = qmax (l, mid, k << 1, x, y);
	if (y > mid) res = max (res, qmax (mid + 1, r, k << 1 | 1, x, y) );
	return res;
}
inline void func1 () {
	sort (a + 1, a + ccnt + 1, cmp1);
	sort (u + 1, u + q + 1, cmpq1);
	int tail = 0;
	For (i, 1, q) {
		if (u[i].k == 1) continue;
		while (tail != ccnt && a[tail + 1].L <= u[i].l) modify (1, n, 1, a[tail + 1].R, a[tail + 1].res), ++ tail;
		ans[u[i].id] = max (ans[u[i].id], qmax (1, n, 1, u[i].r, n) );
	}
}
inline void func2 () {
	sort (a + 1, a + ccnt + 1, cmp2);
	sort (u + 1, u + q + 1, cmpq2);
	For (i, 1, 2000000) mx[i] = 0;
	int tail = 0;
	For (i, 1, q) {
		if (u[i].k == 1) continue;
		while (tail != ccnt && a[tail + 1].R - a[tail + 1].L + 1 >= u[i].k) modify (1, n, 1, a[tail + 1].R, a[tail + 1].res), ++ tail;
		ans[u[i].id] = max (ans[u[i].id], qmax (1, n, 1, u[i].l + u[i].k - 1, u[i].r - 1) );
	}
	For (i, 1, 2000000) mx[i] = 0;
	tail = 0;
	For (i, 1, q) {
		if (u[i].k == 1) continue;
		while (tail != ccnt && a[tail + 1].R - a[tail + 1].L + 1 >= u[i].k) modify (1, n, 1, a[tail + 1].L, a[tail + 1].res), ++ tail;
		ans[u[i].id] = max (ans[u[i].id], qmax (1, n, 1, u[i].l + 1, u[i].r - u[i].k + 1) );
	}
}
inline void write (int x) {
	if (x < 10) {
		putchar (x + 48);
		return;
	}
	write (x / 10);
	putchar (x % 10 + 48);
}
signed main () {
	lg[1] = 0;
	For (i, 2, 500000) lg[i] = lg[i / 2] + 1;
	For (i, 0, 20) pre[i] = 1 << i;
	n = read ();
	For (i, 1, n) root[i] = i;
	cnt = n;
	For (i, 2, n) {
		int u = read (), v = read ();
		add (u, v);
		add (v, u);
	}
	dep[1] = 1;
	dfs1 (1);
	For (i, 1, n - 1) Add (lca (i, i + 1), i);
	dfs2 (1);
	q = read ();
	For (j, 1, 18) For (i, 1, n - pre[j] + 1) st[j][i] = max (st[j - 1][i], st[j - 1][i + pre[j - 1] ]);
	For (i, 1, q) {
		u[i] = {read (), read (), read (), i};
		if (u[i].k == 1) {
			int l = lg[u[i].r - u[i].l + 1];
			ans[u[i].id] = max (st[l][u[i].l], st[l][u[i].r - pre[l] + 1]);
		}
	}
	func1 ();
	func2 ();
	For (i, 1, q) {
	    write (ans[i]);
	    printf ("\n");
	}
	return 0;
}
```

后话：常数巨大，交了 $200$ 发才过。。。

---

## 作者：IvanZhang2009 (赞：8)

来一个考场做法和后续优化。

首先有一个 $O(1)$ 求 lca 的前置知识：我们在 dfs 序上考虑，设求点 $x,y$（$x\neq y$）的 lca，不妨设 $dfn_x<dfn_y$，则 lca 为 $[dfn_x+1,dfn_y]$ 区间上深度最小的点的父亲。手玩一下就可以证明了。

可以发现多个点的 lca 是可合并可重信息，于是可以用 st 表维护区间 lca。

于是可以得到一个 $O(nq)$ 的暴力，由于只要考虑长度恰好等于 $k$ 的区间，我们枚举 $O(n)$ 个区间，然后求出 lca，比较即可。可以获得 $32$ 的好成绩。

看到剩下的除了正解就是链了，于是考虑链。我们不妨直接把链考虑成序列：$a_i$ 表示点 $i$ 的深度。则询问相当于最大化子区间内所有长度 $\ge k$ 的区间的 $\max$。一个直接的想法是二分答案 $x$，则我们把值 $\ge x$ 的称为可行点，其它称为断点。注意到除了包含区间边界的时候，只有极长的可行点区间是有用的。即区间 $[l,r]$ 有用当且仅当 $\min^r_{i=l}a_i\ge x$ 且 $a_{l-1}<x$，$a_{r+1}<x$。其余只需要考虑特判区间 $[L,L+k-1]$ 和 $[R-k+1,R]$ 即可（$L,R,k$ 为题面中的询问参数）。

这种区间一看就非常符合直觉，看上去非常有优化前途啊！我们不妨设 $a_{l-1}\ge a_{r+1}$，则可以发现 $[l,r]$ 的所有数都 $>a_{l-1}$，则 $a_{r+1}$ 是 $l-1$ 右边的第一个 $\le a_{l-1}$ 的；同理，当 $a_{l-1}\le a_{r+1}$ 时，$a_{l-1}$ 是 $a_{r+1}$ 左边第一个更小的。也就是说，最多只有这样 $2n$ 个区间是有用的。

朴素做，对于一个有用区间 $(l,r,x)$，其中 $x$ 表示 $[l,r]$ 区间的 lca 深度，则要求 $l\ge L$，$r\le R$，$r-l+1\ge k$。这就是三维数点板子了，我们里先后随便找一维排序，然后用树套树解决。时间复杂度 $O((n+q)\log^2n)$，使用线段树套 treap 空间复杂度 $O((n+q)\log n)$。考场上我花了半小时实现了该做法（虽然还调了半小时），期望得分最好有 $64$。

考虑是否可以扩展到树上。注意到链可做的原因是，lca 可以表示为区间 $\min$。我们脑洞大开，用前置知识中 $O(1)$ lca 来考虑。在 dfn 序列中，区间 lca 相当于钦定了若干单点（区间内所有点的 dfn 序），然后求所有点形成的左开右闭区间的 $\min$ 的最小值，可以发现就是 dfn 序列上最大最小值区间的最小值。同时考虑这个拆法，为了模仿链的做法，我们也类似地把这个大区间拆成若干个小区间的并，其中每个小区间是**原序列**中相邻两点在 dfn 序列上表示的左开右闭区间。也就是说，令 $a_i$ 表示 $\min^{\max(dfn_i,dfn_{i+1})}_{j=\min(dfn_i,dfn_{i+1})+1}dep_j-1$，则区间 lca 的深度即为 $\min^{r-1}_{i=l}a_i$，因为这些小区间一定能覆盖整个大区间。也就是说我们在令 $a_i$ 为 $dep_{lca(i,i+1)}$ 时可以用和链一样的做法做，即找到 $2n$ 个有用区间尝试。注意这个做法需要特判 $k=1$。时间复杂度 $O((n+q)\log^2n)$，不知道能不能过，感觉常数不大。

[zhuzhu2891](luogu.com.cn/user/515385) 告诉我每个区间只需要保留前后缀即可。具体地，在三维偏序的 $l,r,len$ 三个限制中，我们分别只考虑 $l,len$ 和 $r,len$ 的限制，令新区间被原区间包含即可。从刚才二分答案的角度思考可以感性理解只保留前后缀的正确性。注意到虽然长度缩小后区间 $\min$ 可能会改变，但是按原来的值算只会更劣，一定会被更优的区间前后缀覆盖，所以这个做法可以仅用二维偏序实现，按 $len$ 排序之后实现单点修改区间求 $\max$ 即可。时间复杂度 $O((n+q)\log n)$。

```cpp
#include<bits/stdc++.h>
#define REP(i,a,n) for(int i=(a);i<(int)(n);++i)
#define pb push_back
using namespace std;
int read(){
	int res=0;char c=getchar();
	while(c<48||c>57)c=getchar();
	do res=(res<<1)+(res<<3)+(c^48),c=getchar();while(c>=48&&c<=57);
	return res;
}
struct queries{
    int l,r,id;
};
struct ds{
    int seg[2000005];
    void build(int l,int r,int p){
        seg[p]=0;
        if(l==r)return;
        int m=(l+r)>>1;
        build(l,m,p*2+1);build(m+1,r,p*2+2);
    }
    void update(int pos,int l,int r,int p,int val){
        seg[p]=max(seg[p],val);
        if(l==r)return;
        int m=(l+r)>>1;
        if(m>=pos)update(pos,l,m,p*2+1,val);
        else update(pos,m+1,r,p*2+2,val);
    }
    int query(int l,int r,int s,int t,int p){
        if(l<=s&&t<=r)return seg[p];
        int m=(s+t)>>1,res=0;
        if(m>=l)res=query(l,r,s,m,p*2+1);
        if(m<r)res=max(res,query(l,r,m+1,t,p*2+2));
        return res;
    }
}s1,s2;
int n,q;
vector<int>v[500005];
int an[22][500005],fa[500005],dep[500005],a[500005];
int st[22][500005],mx[22][500005],dfn[500005];
int tot;
int ans[500005];
vector<queries>qr[500005],add[500005];
int getmax(int x,int y){return dep[x]<dep[y]? x:y;}
void dfs(int x,int pre,int d){
	fa[x]=pre;dfn[x]=tot++;an[0][dfn[x]]=pre;dep[x]=d;
	for(auto i:v[x])if(i!=pre)dfs(i,x,d+1);
}
int getlca(int x,int y){
	if(x==y)return x;
	x=dfn[x];y=dfn[y];if(x>y)swap(x,y);
	int s=__lg(y-x);
	return getmax(an[s][x+1],an[s][y-(1<<s)+1]);
}
int query(int l,int r){
	int s=__lg(r-l+1);
    return dep[getlca(st[s][l],st[s][r-(1<<s)+1])]+1;
}
int qmax(int l,int r){
    int s=__lg(r-l+1);
    return max(mx[s][l],mx[s][r-(1<<s)+1]);
}
signed main(){
	freopen("query.in","r",stdin);
	freopen("query.out","w",stdout);
	n=read();
	REP(i,1,n){
		int x=read()-1,y=read()-1;
		v[x].pb(y);v[y].pb(x);
	}
	dfs(0,-1,0);
	REP(j,0,__lg(n-1)){
		REP(i,1,n-(1<<(j+1))+1)an[j+1][i]=getmax(an[j][i],an[j][i+(1<<j)]);
	}
	REP(i,0,n)st[0][i]=i,mx[0][i]=dep[i]+1;
	REP(j,0,__lg(n)){
		REP(i,0,n-(1<<(j+1))+1)st[j+1][i]=getlca(st[j][i],st[j][i+(1<<j)]);
		REP(i,0,n-(1<<(j+1))+1)mx[j+1][i]=max(mx[j][i],mx[j][i+(1<<j)]);
	}
    REP(i,0,n-1)a[i]=dep[getlca(i,i+1)];
    stack<int>st;
    REP(i,0,n-1){
        while(!st.empty()&&a[st.top()]>a[i])st.pop();
        if(!st.empty()){
            int x=st.top()+1;
            if(x<i){
                queries y={x,i-1,query(x,i)};
                add[i-x].pb(y);
            }
        }
        st.push(i);
    }
    while(!st.empty())st.pop();
    for(int i=n-2;i>=0;--i){
        while(!st.empty()&&a[st.top()]>a[i])st.pop();
        if(!st.empty()){
            int x=st.top()-1;
            if(x>i){
                queries y={i+1,x,query(i+1,x+1)};
                add[x-i].pb(y);
            }
        }
        st.push(i);
    }
    q=read();
    REP(i,0,q){
        int l=read()-1,r=read()-1,k=read();
        if(k==1)ans[i]=qmax(l,r);
        else{
        	ans[i]=max(query(l,l+k-1),query(r-k+1,r));
            --r;--k;
            qr[k].pb({l,r,i});
        }
    }
    --n;
    s1.build(0,n-1,0);s2.build(0,n-1,0);
    for(int i=n;i>=1;--i){
        for(auto j:add[i]){
            s1.update(j.l,0,n-1,0,j.id);
            s2.update(j.r,0,n-1,0,j.id);
        }
        for(auto j:qr[i]){
            ans[j.id]=max(ans[j.id],s1.query(j.l,j.r-i+1,0,n-1,0));
            ans[j.id]=max(ans[j.id],s2.query(j.l+i-1,j.r,0,n-1,0));
        }
    }
    REP(i,0,q)cout<<ans[i]<<"\n";
    cerr<<clock()<<endl;
	return 0;
}
```

---

## 作者：立柱已选162534 (赞：7)

纪念场切题目。

显然直接求 lca 不太容易优化，考虑对每个 lca 计算贡献。

考虑一个点 $x$，将它子树中的节点按编号排序，会形成若干个极长连续段，这些段与它们的贡献是容计算的。

具体地，使用树上启发式合并计算连续段，每次加入一个点 $a$ 时用并查集合并 $(a,a-1)$ 与 $(a,a+1)$ 对应的极长连续段。显然只需计算新产生的极长连续段的贡献，因此只需考虑新加入的点对应的段，时间复杂度 $O(n\log n\ \alpha(n))$。

由于一开始只有 $n$ 个段，一个新产生的段必定由之前的几个段合并而成，因此总段数不超过 $2n-1$。\
需要注意的是，在实现过程中要在尝试加入 $a$ 对应的连续段时判断这个段 $[l_a,r_a]$ 是否出现过。\
首先需要使用 bool 数组判断这个连续段是否在考虑 $x$ 时出现，同时需要储存 $a$ 对应的前一个极长连续段 $[L_a,R_a]$ 以判断是否是新的极长连续段。（虽然使用 map 直接存连续段也能达到相同的效果，但常数过大可能超时）

显然一个极长连续段 $[x,y]$ 对询问 $(l,r,k)$ 能产生贡献的条件为区间 $[l,r]$ 与区间 $[x,y]$ 的交的长度不小于 $k$，考虑如何维护。

- 若 $x<l$，则区间交为 $[l,\text{min}(r,y)]$，满足条件当且仅当 $y\ge l+k-1$，分别按左端点升序排序后双指针，线段树维护即可。

- 否则，区间交为 $[x,\text{min}(r,y)]$，显然有充要条件 $y-x+1\ge k$ 且 $x\le r-k+1$，分别按区间长度与 $k$ 降序排序后同样线段树维护即可。

时间复杂度 $O((n+q)\log n)$，总时间复杂度 $O(n\log n\ \alpha(n)+(n+q)\log n)$ 。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
vector<int> t[500005];
int Sz[500005],z[500005],l[500005],ord[500005],dep[500005],dfn;
bool vis[500005];
void dfs1(int c,int f){
	Sz[c]=1,dep[c]=dep[f]+1;
	for(auto i:t[c])
	if(i!=f)dfs1(i,c),Sz[c]+=Sz[i],z[c]=(Sz[z[c]]<Sz[i]?i:z[c]);
}
int la[500005],ne[500005],sz[500005],f[500005],L[500005],R[500005];
int find(int c){
	while(f[c]!=c)c=f[c]=f[f[c]];
	return c;
}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(sz[x]>sz[y])swap(x,y);
	f[x]=y,sz[y]+=sz[x];
	if(L[x]<L[y])L[y]=L[x];
	else R[y]=R[x];
}
void ins(int x){
	vis[x]=1;
	if(vis[x-1]){
		ne[x-1]=x,la[x]=x-1;
		merge(x-1,x);
	}
	if(vis[x+1]){
		ne[x]=x+1,la[x+1]=x;
		merge(x,x+1);
	}
}
struct tg{
	int l,r,s;
}a[1000005];
int top,L0[500005],R0[500005];
bool vvv[500005];
int st[500005],T;
void dfs2(int c,int fa,bool p){
	++dfn,l[c]=dfn,ord[dfn]=c;
	for(auto i:t[c])
	if(i!=fa&&i!=z[c])dfs2(i,c,1);
	if(z[c])dfs2(z[c],c,0);
	ins(c);
	for(int i=l[c];i<l[z[c]];++i)ins(ord[i]);
	int lgx=find(c);
	T=0;
	L0[c]=L[lgx],R0[c]=R[lgx];
	++top,a[top]=(tg){L[lgx],R[lgx],dep[c]};
	vvv[lgx]=1,st[++T]=lgx;
	for(int i=l[c];i<l[z[c]];++i){
		lgx=find(ord[i]);
		if(L[lgx]==L0[ord[i]]&&R[lgx]==R0[ord[i]])continue;
		L0[ord[i]]=L[lgx],R0[ord[i]]=R[lgx];
		if(vvv[lgx])continue;
		++top,a[top]=(tg){L[lgx],R[lgx],dep[c]};
		vvv[lgx]=1,st[++T]=lgx;
	}
	for(int i=1;i<=T;++i)vvv[st[i]]=0;
	if(p){
		for(int i=l[c];i<=dfn;++i){
			vis[ord[i]]=0;
			ne[ord[i]]=la[ord[i]]=ord[i],f[ord[i]]=ord[i];
			L[ord[i]]=R[ord[i]]=ord[i];
			sz[ord[i]]=1;
		}
	}
} 
int q;
struct qwq{
	int l,r,k,num;
}b[500005];
int tr[1000005];
void add(int l,int r,int c,int kr,int s){
	if(r<=kr){
		tr[c]=max(tr[c],s);
		return;
	}
	int mid=(l+r)>>1;
	add(l,mid,mid<<1,kr,s);
	if(kr>mid)add(mid+1,r,mid<<1|1,kr,s);
}
int query(int l,int r,int c,int k){
	if(l==r)return tr[c];
	int mid=(l+r)>>1;
	if(k<=mid)return max(tr[c],query(l,mid,mid<<1,k));
	return max(tr[c],query(mid+1,r,mid<<1|1,k));
}
void a1(int l,int r,int c,int k,int s){
	if(l==r){
		tr[c]=max(tr[c],s);
		return;
	}
	int mid=(l+r)>>1;
	if(k<=mid)a1(l,mid,mid<<1,k,s);
	else a1(mid+1,r,mid<<1|1,k,s);
	tr[c]=max(tr[mid<<1],tr[mid<<1|1]);
}
int q1(int l,int r,int c,int kl,int kr){
	if(l>kr||r<kl)return 0;
	if(l>=kl&&r<=kr)return tr[c];
	int mid=(l+r)>>1;
	return max(q1(l,mid,mid<<1,kl,kr),q1(mid+1,r,mid<<1|1,kl,kr));
}
int out[500005];
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	la[n+1]=n+1;
	for(int i=1;i<=n;++i)ne[i]=la[i]=f[i]=L[i]=R[i]=i,sz[i]=1;
	for(int i=1,x,y;i<n;++i){
		cin>>x>>y;
		t[x].emplace_back(y),t[y].emplace_back(x);
	}
	cin>>q;
	for(int i=1;i<=q;++i)
		cin>>b[i].l>>b[i].r>>b[i].k,b[i].num=i; 
	dfs1(1,1);
	dfs2(1,1,0);
	sort(a+1,a+1+top,[](tg a,tg b){
		return a.l<b.l;
	});
	sort(b+1,b+1+q,[](qwq a,qwq b){
		return a.l<b.l;
	});
	for(int i=1,j=1;i<=q;++i){
		while(j<=top&&a[j].l<=b[i].l)add(1,n,1,a[j].r,a[j].s),++j;
		out[b[i].num]=query(1,n,1,b[i].l+b[i].k-1);
	}
	sort(a+1,a+1+top,[](tg a,tg b){
		return a.r-a.l>b.r-b.l;
	});
	sort(b+1,b+1+q,[](qwq a,qwq b){
		return a.k>b.k;
	});
	memset(tr,0,sizeof(tr));
	for(int i=1,j=1;i<=q;++i){
		while(j<=top&&a[j].r-a[j].l+1>=b[i].k)a1(1,n,1,a[j].l,a[j].s),++j;
		out[b[i].num]=max(out[b[i].num],q1(1,n,1,b[i].l,b[i].r-b[i].k+1));
	}
	for(int i=1;i<=q;++i)
		cout<<out[i]<<'\n';
	return 0;
}
```

---

## 作者：Genius_Star (赞：5)

### 思路：

考场写了一个基于树随机的单 log 的做法，希望能水点分qwq。

这里来说正解，考虑对于每个子树 $u$，求出所有的极长连续段 $[l, r]$ 使得区间 $[l, r]$ 内的点的 LCA 是点 $u$。

考虑使用并查集维护 $pre_i, nxt_i$ 表示 $i$ 所在连续段的左端点和右端点；然后考虑 dsu on tree，这里可以不需要撤销；即每次插入 $x$ 时，找到 $x$ 所在的连续段 $[L, R]$，然后看能不能往 $[L - 1, R]$ 或 $[L, R + 1]$ 拓展即可（如果拓展能当前仅当往外拓展的点也在 $u$ 子树内）。

所有的极长连续段 $(l, r, v)$ 的数量是 $O(N)$ 级别的；现在来考虑询问；即要找到一个 $(l', r', v)$ 使得 $[l', r']$ 与 $[l, r]$ 的交集大小 $\ge k$。

这个问题很眼熟啊，很像 P10281；明显可以三维偏序（cdq、树套树）$\log^2$ 的复杂度解决，但是本题是 $5 \times 10^5$，继续考虑优化。

两个区间 $[l, r]$ 与 $[l', r']$ 有交集有以下四种情况：

$$l \le l' \le r' \le r$$

$$l' \le l \le r \le r'$$

$$l \le l' \le r \le r'$$

$$l' \le l \le r' \le r$$

对于第二种情况，是包含关系（故肯定满足交集 $\ge k$），解决方法如下：

- 将询问 $[l, r]$ 挂到 $r$ 处，按照 $r$ 扫描线，从后往前扫，扫描到 $(l, r, v)$ 时在 $l$ 处算上 $v$ 的贡献；询问即 $[1, l]$ 的最大值（算的是 $[l, r]$ 被 $[l', r']$ 包含的贡献）。

然后再来考虑后面两个情况，先来看第三种 $l \le l' \le r \le r'$，需要满足 $r - l' + 1 \ge k$，即 $l' \le r - k + 1$；此时还需要保证 $r' - l' + 1 \ge k$。

故可以从大到小扫描 $k$，对于 $(l', r', v)$ 在扫描到 $r' - l' + 1$ 时在 $l'$ 处加入 $v$ 的贡献；则询问 $[l, r, k]$ 相当于查询 $[l, r - k + 1]$ 的最大值。

然后再来看第四种 $l' \le l \le r' \le r$，需要满足 $r' - l + 1 \ge k$，即 $r' \ge l + k - 1$，同时满足 $r' - l' + 1 \ge k$；故可以和第一种类似在扫描到 $r' - l' + 1$ 时在 $r'$ 处加入 $v$ 的贡献，询问相当于查询 $[l + k - 1, r]$ 的最大值。

最后来看第一种，需要满足 $l \le l' \le r' \le r$ 且 $r' - l' + 1 \ge k$，诶，我们发现其实在算第三种和第四种的时候已经把它给算了。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 5e5 + 10; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Node{
	int l, r, len, v;
};
int n, u, v, q, l, r, k, cnt;
int fa[N], id[N], ans[N], dfn[N], dep[N], siz[N], son[N], nxt[N], pre[N];
vector<Node> T;
vector<int> E[N];
inline void add(int u, int v){
	E[u].push_back(v);
	E[v].push_back(u); 
}
inline int getnxt(int x){
	if(x != nxt[x])
	  return nxt[x] = getnxt(nxt[x]);
	return nxt[x];
}
inline int getpre(int x){
	if(x != pre[x])
	  return pre[x] = getpre(pre[x]);
	return pre[x];
}
inline void work(int x, int l, int r, int v){
	bool F = 0;
	int L = getpre(x), R = getnxt(x);
	while(l <= dfn[L - 1] && dfn[L - 1] <= r){
		pre[L] = L - 1;
		nxt[L - 1] = L;
		L = getpre(L - 1);
		F = 1;
	}
	while(l <= dfn[R + 1] && dfn[R + 1] <= r){
		nxt[R] = R + 1;
		pre[R + 1] = R;
		R = getnxt(R + 1);
		F = 1;
	}
	if(F)
	  T.push_back({L, R, R - L + 1, v});
}
inline void dfs1(int u, int f){
	dfn[u] = ++cnt;
	id[cnt] = u;
	siz[u] = 1;
	for(auto v : E[u]){
		if(v == f)
		  continue;
		fa[v] = u;
		dep[v] = dep[u] + 1;
		dfs1(v, u);
		siz[u] += siz[v];
		if(siz[v] > siz[son[u]])
		  son[u] = v;
	}
}
inline void dfs2(int u){
	for(auto v : E[u]){
		if(v == fa[u] || v == son[u])
		  continue;
		dfs2(v);
	}
	if(son[u])
	  dfs2(son[u]);
	for(auto v : E[u]){
		if(v == fa[u] || v == son[u])
		  continue;
		for(int i = dfn[v]; i <= dfn[v] + siz[v] - 1; ++i)
		  work(id[i], dfn[u], dfn[u] + siz[u] - 1, dep[u] + 1);
	}
	work(u, dfn[u], dfn[u] + siz[u] - 1, dep[u] + 1);
}
class Seg{
public:
	struct Node{
		int l, r;
		int Max;
	}X[N << 2];
	inline void pushup(int k){
		X[k].Max = max(X[k << 1].Max, X[k << 1 | 1].Max);
	}
	inline void build(int k, int l, int r){
		X[k].l = l, X[k].r = r;
		if(l == r)
		  return ;
		int mid = (l + r) >> 1;
		build(k << 1, l, mid);
		build(k << 1 | 1, mid + 1, r);
	}
	inline void update(int k, int i, int v){
		if(X[k].l == i && i == X[k].r){
			X[k].Max = v;
			return ;
		}
		int mid = (X[k].l + X[k].r) >> 1;
		if(i <= mid)
		  update(k << 1, i, v);
		else
		  update(k << 1 | 1, i, v);
		pushup(k);
	}
	inline int query(int k, int l, int r){
		if(X[k].l == l && r == X[k].r)
		  return X[k].Max;
		int mid = (X[k].l + X[k].r) >> 1;
		if(r <= mid)
		  return query(k << 1, l, r);
		else if(l > mid)
		  return query(k << 1 | 1, l, r);
		else
		  return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));
	}
}Tr[3];
vector<pair<pair<int, int>, int>> Q[N], Q_[N];
vector<pair<pair<int, int>, int>> C[N], C_[N];
bool End;
int main(){
	open("query.in", "query.out");
	n = read();
	for(int i = 1; i < n; ++i){
		u = read(), v = read();
		add(u, v);
	}
	for(int i = 1; i <= n; ++i)
	  pre[i] = nxt[i] = i;
	dfs1(1, 1);
	dfs2(1);
	for(int i = 1; i <= n; ++i)
	  T.push_back({i, i, 1, dep[i] + 1});
	q = read();
	for(int l, r, k, i = 1; i <= q; ++i){
		l = read(), r = read(), k = read();
		Q[k].push_back({{l, r}, i});
		Q_[r].push_back({{l, r}, i});
	}
	for(auto t : T){
		C[t.len].push_back({{t.l, t.r}, t.v});
		C_[t.r].push_back({{t.l, t.r}, t.v});
	}
	Tr[0].build(1, 1, n), Tr[1].build(1, 1, n), Tr[2].build(1, 1, n);
	for(int r = n; r >= 1; --r){
		for(auto t : C_[r])
		  Tr[0].update(1, t.fi.fi, t.se);
		for(auto t : Q_[r])
		  ans[t.se] = max(ans[t.se], Tr[0].query(1, 1, t.fi.fi));
	}
	for(int k = n; k >= 1; --k){
		for(auto t : C[k]){
			Tr[1].update(1, t.fi.fi, t.se);
			Tr[2].update(1, t.fi.se, t.se);
		}
		for(auto t : Q[k]){
			ans[t.se] = max(ans[t.se], Tr[1].query(1, t.fi.fi, t.fi.se - k + 1));
			ans[t.se] = max(ans[t.se], Tr[2].query(1, t.fi.fi + k - 1, t.fi.se));
		}
	}
	for(int i = 1; i <= q; ++i){
		write(ans[i]);
		putchar('\n');
	} 
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：strcmp (赞：5)

我们有：

$$
\max_{l \le l' \le r' \le r \wedge r' - l' + 1 \ge k} d_{\text{LCA}(l',\,l'+1,\,\dots,\,r')} = \max_{l \le l' \le r' \le r \wedge r' - l' + 1 \ge k} \min\{ d_{\text{LCA}(l',\,l'+1)},\,d_{\text{LCA}(l'+1,\,l'+2)},\,\dots,\,d_{\text{LCA}(r' - 1,\,r')}\}
$$

人话讲，区间所有点 LCA 的深度，等于相邻点 LCA 的深度最小值。

证明的话，考虑 $l,\,l + 1,\,l + 2,\,\dots,\,r$ 连成一条链 $X$，并且考虑总 LCA $u$。

发现这些点一定分布在了 $u$ 的不同子树，不然总 LCA 不会是 $u$。

那么分布在不同子树，而它们又在 $X$ 上形成了一个联通的链，那么必然 $X$ 会有两个相邻的点在不同的子树，不然肯定所有点都在一个子树。

两个相邻的点在 $u$ 的不同子树，那么就可以直接得到总 LCA $u$。

问题转化为求出 $[l,\,r]$ 内长度为 $k$ 的最小值最大的区间。

最小值最大，显然考虑二分 $w$，小于 $w$ 的都不选，然后考虑是否存在大小 $\ge k$ 的连续段。

这个东西显然可以建立主席树，可以把 $< w$ 的都设置成 $-\infty$ 然后跑持久化区间最大子段和，判定是否存在 $\ge k$ 的子段即可。

时间复杂度 $\Theta(n \log^2 n)$，代码放剪切板里，等数据出来了再看吧。

[参考代码](https://www.luogu.com.cn/paste/k4xo3119)。

---

## 作者：thomaswmy (赞：5)

首先按照线段树结构分治。那么只要算跨过中点的答案。

注意到跨过中点的区间 LCA 一定是 $\texttt{LCA}(mid,mid+1)$ 的祖先，可以先求出 $\texttt{LCA}(i,\cdots,mid+1),\texttt{LCA}(mid,\cdots,i)$ ，然后双指针得出 $O(len)$ 个可能的区间更新答案。（求 LCA 可以使用 dfs 序做到 $O(n\log n)-O(1)$，但是直接树剖求就是均摊正确的了，常数还小/fn。）

注意到如果答案不在这里的话一定顶到了左右端点，使用自己喜欢的方法更新一下即可。例如找到 dfs 序最小和最大值取 LCA。

对于完全包含当前这个区间的情况，只要把小区间长度为 i 的时候的答案记录下来即可，可以用这个区间的 $O(len)$ 个答案和左右的答案合并。

按照线段树的分析可以得到时空复杂度 $O(n\log n)$。

代码暂时没有。

---

## 作者：SegTree (赞：4)

2log 做法，北师附机子跑了 1.8s，应该能过，如果挂成只能过 1e5 就成最大小丑了。

我们尝试找出一些有意义的连续段（指三元组 $(d_i,l_i,r_i)$ 表示 $\text{LCA}^*(l_i,r_i)=d_i$），具体来说使用树上启发式合并的思想，每次插入一个新点就找出新段，因为旧段已经在更深的位置被考虑了，所以无需考虑。可以使用 `set` 维护。

找出这样的段之后，问题等价于找到最大的 $d$ 满足存在 $\min(r_i,r)-\max(l_i,l)\ge k,d_i=d$。可以离线下来做整体二分，check 的时候问题等价于：

有若干个区间，$q$ 次查询判断是否存在区间满足 $[l,r]$ 的交 $\ge k$。

对于这个问题，如果大区间包含小区间就删除小区间，此时 $l_i$ 和 $r_i$ 都单调递增，单独算一下边角中间就是区间 $\max$，可以单次 $\log$。

由于启发式合并和整体二分，所以复杂度 $O((n+q)\log^2 n)$。

---

## 作者：可爱的小棉羊 (赞：4)

笑点解析：在考场距离正解只差一个扫描线，不然就切了。

下面我通过我考场的思路回家路上的思考解决这个题。

#### 我会求 LCA！

考虑暴力将每个长度为 $k$ 的连续段 $LCA$ 算出，$O(n^2\log n+mn^2\log n)$。

#### 我会数据结构！

注意到这个问题具有幂等性，考虑 ST 表，$$O(n\log^2n+mn\log n)$$

#### 我会欧拉环游序！

终于接近正解了。

设 $id_i$ 为编号为 $i$ 的点在环游序上出现的位置，$E_i$ 为环游序上第 $i$ 个编号所对应深度。

考虑求出欧拉环游序，那么一个区间的最近公共祖先深度变成了。

$$\max_{i=l}^{r-k+1}\min_{l=\min_{j=i}^{i+k-1}id_j}^{\max_{j=i}^{i+k-1}id_j}E_l$$

维护三个 $ST$ 表可过性质 B($O(n\log n+m)$)，$n\le 5000$($O(n\log n+mn)$)。

#### 我会扫描线！

令 $f_{\max/\min}(l,r)$ 为 $[l,r]$ 的 $id$ 的最大/小值。

考虑如下结论：

$$\min_{j=f_{\min}(i,i+k-1)}^{f_{max}(i,i+k-1)}E_j=\min_{j=i}^{i+k-2}\min_{l=\min(id_j,id_{j+1})}^{\max(id_j,id_{j+1})}E_l$$

考虑预处理 $\min_{l=\min(id_j,id_{j+1})}^{\max(id_j,id_{j+1})}E_l$，为 $B_j$。

这样我们就丢掉了欧拉序啦！

问题写成：

$$\max_{R-L+1\ge k,R\le R,l\le L}\min_{i=L}^{R-1}B_i$$

$R-1$ 看起来烦，改一下：

$$\max_{R-L+1\ge k-1,R\le r-1,l\le L}\min_{i=L}^{R}B_i$$

我们考虑每个 $B_i$ 什么时候可以是最小值，考虑单调栈求出左右两边第一个比他小的数，那么它取得最小值的条件可以描述成一个区间 $[l,r]$，不妨描述成三元组 $(l,r,v)$，想象成一个带权的区间。

一次询问是不是相当于询问**所有与我现在给定区间交集不小于 $k$ 的区间的权值最大值**，假设询问 $[L,R,k]$。

那么一个区间什么时候可以与他交集不小于 $k$ 呢？

$$(R\le r\wedge l\le R-k+1)\vee(r-l+1\ge k\wedge L+k-1\le r\le R)$$

对两个条件分别离线二维数点，做完了。

---

## 作者：gdf_yhm (赞：2)

[P11364](https://www.luogu.com.cn/problem/P11364)

[my blog](https://yhddd123.github.io/post/p11364-ti-jie/)

### 思路

考虑一个节点 $u$，和 $u$ 的叶子 $v$ 合并，贡献是若干个连续段对 $[l1,r1]$ 到 $[r1+1,r2]$ 的答案为 $dep_u$。由于 $[l1,r1]$ 内任选两点一定在 $u$ 子树中的某个点被贡献过，所以可以当成 $[l1,r2]$ 有 $dep_u$ 的贡献。对每个 $u$ 维护子树内连续段，启发式合并。因为每个贡献区间都是两个连续段合并起来，所以只有 $n-1$ 个长度 $>1$ 的区间和 $n$ 个单点。

单点可以用 st 表维护区间最大值，对 $k=1$ 的询问贡献。对于有贡献的区间和询问区间，分三类考虑。有贡献的区间左端点小于询问区间左端点，按 $l$ 从小到大扫描线，贡献加在 $r$ 上，查询 $l\le ql,r\in [ql+qk-1,qr]$ 的答案。有贡献的区间右端点大于询问区间右端点同理。否则 $ql\le l\le r\le qr$，按 $r-l+1$ 从大到小扫描线，贡献加在 $l$ 上，查询 $k\ge qk,l\in [ql,qr-qk+1]$ 的答案。

复杂度 $O(n\log^2n)$，跑的飞快。

### code

```cpp
int n,q;
int head[maxn],tot;
struct nd{
	int nxt,to;
}e[maxn<<1];
void add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}
int ll[maxn],rr[maxn],kk[maxn],ans[maxn];
int dep[maxn];
set<pii> s[maxn];
struct node{
	int l,r,x;
}upd[maxn];
void ins(int u,pii p){
	auto it=s[u].lower_bound(p);
	pii del1,del2;
	if(it!=s[u].end()){
		pii pp=(*it);
		if(p.se+1==pp.fi){
			upd[p.se]={p.fi,pp.se,dep[u]};
			del1=pp;p.se=pp.se;
		}
	}
	if(it!=s[u].begin()){
		it--;pii pp=(*it);
		if(pp.se+1==p.fi){
			upd[pp.se]={pp.fi,p.se,dep[u]};
			del2=pp;p.fi=pp.fi;
		}
	}
	if(del1.fi)s[u].erase(del1);
	if(del2.fi)s[u].erase(del2);
	s[u].insert(p);
}
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==fa)continue;
		dfs(v,u);
	}
	ins(u,{u,u});
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==fa)continue;
		if(s[u].size()<s[v].size())swap(s[u],s[v]);
		for(pii p:s[v])ins(u,p);
	}
}
#define mid (l+r>>1)
#define ls lc[nd]
#define rs rc[nd]
int rt[maxn],idx;
int lc[maxn*100],rc[maxn*100],tree[maxn*100];
void modif(int &nd,int l,int r,int p,int w){
	int lst=nd;nd=++idx;tree[nd]=max(tree[lst],w),ls=lc[lst],rs=rc[lst];
	if(l==r)return ;
	if(p<=mid)modif(ls,l,mid,p,w);
	else modif(rs,mid+1,r,p,w);
}
int query(int nd,int l,int r,int ql,int qr){
	if(!nd||ql>qr)return 0;
	if(l>=ql&&r<=qr)return tree[nd];
	if(qr<=mid)return query(ls,l,mid,ql,qr);
	if(ql>mid)return query(rs,mid+1,r,ql,qr);
	return max(query(ls,l,mid,ql,qr),query(rs,mid+1,r,ql,qr));
}
vector<int> id[maxn];
int mx[20][maxn];
int quemx(int l,int r){
	int k=__lg(r-l+1);
	return max(mx[k][l],mx[k][r-(1<<k)+1]);
}
void work(){
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	q=read();
	for(int i=1;i<=q;i++)ll[i]=read(),rr[i]=read(),kk[i]=read();
	dfs(1,0);
	for(int i=1;i<=n;i++)mx[0][i]=dep[i];
	for(int j=1;j<20;j++){
		for(int i=1;i+(1<<j)-1<=n;i++)mx[j][i]=max(mx[j-1][i],mx[j-1][i+(1<<j-1)]);
	}
	for(int i=1;i<=q;i++)if(kk[i]==1)ans[i]=quemx(ll[i],rr[i]);
	for(int i=1;i<n;i++)id[upd[i].l].pb(i);
	for(int i=1;i<=n;i++){
		rt[i]=rt[i-1];
		for(int j:id[i])modif(rt[i],1,n,upd[j].r,upd[j].x);
	}
	for(int i=1;i<=q;i++){
		int l=ll[i],r=rr[i],k=kk[i];
		ans[i]=max(ans[i],query(rt[l],1,n,l+k-1,n));
	}
	while(idx)tree[idx]=lc[idx]=rc[idx]=0,idx--;
	for(int i=1;i<=n;i++)rt[i]=0;
	for(int i=1;i<=n;i++)id[i].clear();
	for(int i=1;i<n;i++)id[upd[i].r].pb(i);
	for(int i=n;i;i--){
		rt[i]=rt[i+1];
		for(int j:id[i])modif(rt[i],1,n,upd[j].l,upd[j].x);
	}
	for(int i=1;i<=q;i++){
		int l=ll[i],r=rr[i],k=kk[i];
		ans[i]=max(ans[i],query(rt[r],1,n,1,r-k+1));
	}
	while(idx)tree[idx]=lc[idx]=rc[idx]=0,idx--;
	for(int i=1;i<=n;i++)rt[i]=0;
	for(int i=1;i<=n;i++)id[i].clear();
	for(int i=1;i<n;i++)id[upd[i].r-upd[i].l+1].pb(i);
	for(int i=n;i;i--){
		rt[i]=rt[i+1];
		for(int j:id[i])modif(rt[i],1,n,upd[j].l,upd[j].x);
	}
	for(int i=1;i<=q;i++){
		int l=ll[i],r=rr[i],k=kk[i];
		ans[i]=max(ans[i],query(rt[k],1,n,l,r-k+1));
	}
	for(int i=1;i<=q;i++)printf("%lld\n",ans[i]);
}
```

---


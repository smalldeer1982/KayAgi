# [NOIP 2013 提高组] 华容道

## 题目背景

NOIP2013 提高组 D2T3

## 题目描述

`小 B` 最近迷上了华容道，可是他总是要花很长的时间才能完成一次。于是，他想到用编程来完成华容道：给定一种局面， 华容道是否根本就无法完成，如果能完成， 最少需要多少时间。

`小 B` 玩的华容道与经典的华容道游戏略有不同，游戏规则是这样的：

1.   在一个 $n \times m$ 棋盘上有 $ n \times m$ 个格子，其中有且只有一个格子是空白的，其余 $ n \times m-1$ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $1 \times 1$ 的；
2.  有些棋子是固定的，有些棋子则是可以移动的；
3.  任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。   

游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。

给定一个棋盘，游戏可以玩 $q$ 次，当然，每次棋盘上固定的格子是不会变的， 但是棋盘上空白的格子的初始位置、 指定的可移动的棋子的初始位置和目标位置却可能不同。第 $i$ 次玩的时候， 空白的格子在第 $EX_i$ 行第 $EY_i$ 列，指定的可移动棋子的初始位置为第 $SX_i$ 行第 $SY_i$列，目标位置为第 $TX_i$ 行第 $TY_i$ 列。

假设 `小 B` 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉 `小 B` 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。


## 说明/提示

**输入输出样例说明**

棋盘上划叉的格子是固定的，红色格子是目标位置，圆圈表示棋子，其中绿色圆圈表示目标棋子。

1.   第一次游戏，空白格子的初始位置是 $(3,2)$（图中空白所示），游戏的目标是将初始位置在 $(1, 2)$ 上的棋子（图中绿色圆圈所代表的棋子）移动到目标位置 $(2, 2)$（图中红色的格子）上。

移动过程如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/n0q385tw.png)

2.  第二次游戏，空白格子的初始位置是 $(1, 2)$（图中空白所示），游戏的目标是将初始位置在 $(2, 2)$ 上的棋子（图中绿色圆圈所示）移动到目标位置  $(3, 2)$ 上。

![](https://cdn.luogu.com.cn/upload/image_hosting/aq9apos0.png)

要将指定块移入目标位置，必须先将空白块移入目标位置，空白块要移动到目标位置，必然是从位置 $(2,2)$ 上与当前图中目标位置上的棋子交换位置，之后能与空白块交换位置的只有当前图中目标位置上的那个棋子，因此目标棋子永远无法走到它的目标位置， 游戏无法完成。

**数据范围**

对于 $ 30\%$ 的数据，$1 ≤ n, m ≤ 10,q = 1$；

对于 $60\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 10$；

对于 $100\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 500$。


## 样例 #1

### 输入

```
3 4 2
0 1 1 1
0 1 1 0
0 1 0 0
3 2 1 2 2 2
1 2 2 2 3 2```

### 输出

```
2
-1```

# 题解

## 作者：Starlight_Glimmer (赞：10)

[博客食用效果更佳](https://www.cnblogs.com/lyttt/p/11831400.html)

看到这道题的第一反应就是直接上$bfs$啦，也没有想到什么更加优秀的算法。
然后就是$15$分钟打了$70$分，有点震惊，纯暴力诶，这么多白给分嘛，太划算了，这可是$D2T3$诶。


------------


切入正题：

纯暴力的$bfs$会超时，是因为搜索了很多无用状态：真正有用的状态其实是起点格子走的状态，但是这道题用搜索方便转移的却是空白格子，因为题目的规则是空白格子可以移动（相当于和旁边的格子交换位置）。

只有起点格子在空白格子四周起点格子才能动，所以应该是尽量让空白格子往起点格子周围跑，而不是毫无目的地乱跑，空白格子在乱跑的时候实际上拓展了很多无用节点。

那么，就先用一个$bfs$预处理出空白格子到达起点格子四周的距离，然后再从四周分别开始走，取最小的。

从四周开始走的时候还是不考虑暴搜（会产生多余状态），我们只管有用的状态。还是这个道理：起点格子是要依托于空白格子才能够移动的，所以状态要保持空白格子一直在起点格子四周。

那么定义状态$(i,j,k)$表示起点格子的坐标为$(i,j)$，空白格子在它的$k$方向（也即是坐标为$(i+dx[k],j+dy[k])$）。

考虑转移到后继状态：

1.可以是起点格子通过空白格子进行移动（就是俩格子交换位置）

2.可以是空白格子在起点格子四周移动，可以看成转方向。如果只用上面那种转移，也就是用起点格子自己换方向，可能没那么优秀，因为换来换去要绕一绕 。而且起点格子有可能会跑到一个离终点的地方去了，更不优。而只动空白格子可能会优秀一些 因为空白格子最优(到处都是活动格子)只用走2~4步。

然后我们发现，对于多组数据，棋盘的形状是没有改变的，所以大概可以预处理一下然后再询问。

怎么预处理呢？有一个比较实用的技巧，就是把状态当成图的节点，状态之间转移的代价当做边权，然后求从一个状态到另一个状态的最小步数就是从一个点到另一个点的最短路啦（其实本来$bfs$也和最短路有关系（强行沾边））

所以只需要处理出一些可行状态（可以将他们编号，以便进行最短路），然后用上面的两种转移关系连边：对于第一种，边权就是$1$，对于第二种，边权就是两点之间的最短路（可以$bfs$预处理，此时的最短路相当于边权为$1$）。由于边权不是全为$1$，不能用$bfs$，要写最短路算法，只要不是$floyd$，随便写哪个都可以的。

每次询问的时候，求出空白格子不经过起点格子（如果经过，起点格子位置就变啦）到起点格子四周的最短距离(可$bfs$)，再从那四个状态出发（可以同时压进去的，因为答案没有叠加部分，都是一直不停更新最短距离，相当于取$min$），跑到终点格子。终点格子的四个状态都可以，取$min$就是答案。

果然吧，还是暴力好写，正解调了一个下午，考试的时候写暴力真的太划算了。


暴力代码：


```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<queue>
#include<map>
#include<iostream>
#include<cmath>
using namespace std;
#define ll long long
#define INF 0x3f3f3f3f
#define N 35
int rd()
{
    int f=1,s=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9'){s=(s<<3)+(s<<1)+(c^48);c=getchar();}
    return f*s;
}
struct node{
    int mx,my,nx,ny;//空格的位置，初始棋子现在的位置
    int stp;//步数 
};
int n,m,q;
int mp[N][N];
int ex,ey,sx,sy,tx,ty;
queue<node>Q;
const int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
bool vis[N][N][N][N];
bool check(int xx,int yy)
{
    if(xx<0||xx>n||yy<0||yy>m||mp[xx][yy]==0) return 0;
    return 1;
}
int main() 
{
    n=rd(),m=rd(),q=rd();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            mp[i][j]=rd();
    while(q--)
    {
        ex=rd(),ey=rd(),sx=rd(),sy=rd(),tx=rd(),ty=rd();
        if(sx==tx&&sy==ty)
        {//下面村答案是在拓展节点之后存 所以这里要特判 
            puts("0");//如果取出时存答案就不用特判(好像也不用break很多层了 
            continue; 
        }
        memset(vis,0,sizeof(vis));
        bool flag=0;
        while(!Q.empty()) Q.pop();
        node s;s.mx=ex,s.my=ey,s.nx=sx,s.ny=sy,s.stp=0;
        vis[ex][ey][sx][sy]=1;
        Q.push(s);
        while(!Q.empty())
        {
            s=Q.front();Q.pop();
            for(int i=0;i<4;i++)
            {
                node nxt;
                nxt.mx=s.mx+dx[i],nxt.my=s.my+dy[i];
                if(!check(nxt.mx,nxt.my)) continue;
                if(nxt.mx==s.nx&&nxt.my==s.ny) nxt.nx=s.mx,nxt.ny=s.my;
                else nxt.nx=s.nx,nxt.ny=s.ny;
                nxt.stp=s.stp+1;
                if(nxt.nx==tx&&nxt.ny==ty)
                {
                    flag=1;
                    printf("%d\n",nxt.stp);
                    break;
                }
                if(vis[nxt.mx][nxt.my][nxt.nx][nxt.ny]) continue;
                Q.push(nxt);
                vis[nxt.mx][nxt.my][nxt.nx][nxt.ny]=1;
            }
            if(flag) break;
        }
        if(flag) continue;
        else puts("-1");
    }
    return 0;
}

Code
```

满分代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<queue>
#include<map>
#include<iostream>
using namespace std;
#define ll long long
#define INF 0x3f3f3f3f
#define N 35
int rd()
{
	int f=1,s=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'){s=(s<<3)+(s<<1)+(c^48);c=getchar();}
	return f*s;
}
const int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
//下上右左 
int n,m,q;
int mp[N][N];
int ex,ey,sx,sy,tx,ty;
int cnt[N][N][5];
bool check(int xx,int yy)
{
	if(xx<=0||xx>n||yy<=0||yy>m||mp[xx][yy]==0) return 0;
	return 1;
}
int tot;
struct node{
	int x,y,stp/*广搜的时候用 存步数*/;
};
bool vis[N][N],mark[N*N]/*spfa的标记数组*/;
vector<pair<int,int> >G[N*N];
void add(int u,int v,int w)
{
	G[u].push_back(make_pair(v,w));
}
int bfs(int ax,int ay,int bx,int by,int cx,int cy)
{//a到b不经过点c的最短距离 
	if(ax==bx&&ay==by) return 0;//起点就是终点
	memset(vis,0,sizeof(vis)); 
	queue<node>Q;
	while(!Q.empty()) Q.pop();
	node s;s.x=ax,s.y=ay,s.stp=0;
	Q.push(s);
	vis[ax][ay]=1;
	while(!Q.empty())
	{
		node now=Q.front();Q.pop();
		if(now.x==bx&&now.y==by) return now.stp;
		for(int i=0;i<4;i++)
		{
			node nxt;
			nxt.x=now.x+dx[i],nxt.y=now.y+dy[i];
			if(!check(nxt.x,nxt.y)) continue;
			if(nxt.x==cx&&nxt.y==cy) continue;
			if(vis[nxt.x][nxt.y]) continue;
			nxt.stp=now.stp+1;
			Q.push(nxt);
			vis[nxt.x][nxt.y]=1;
		}
	}
	return INF;//不能到达 
}
void Init()
{
	//cnt存状态标号 spfa的时候是把点看成状态 用边来表示状态的转移 
	//[i][j][k]是表示开始的那个点的坐标是(i,j) 空格在它的k方向 
	tot=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<4;k++)
				if(mp[i][j]&&check(i+dx[k],j+dy[k]))
					cnt[i][j][k]=++tot;//给状态标号 没有标号的就是不可行的状态 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<4;k++)
				if(cnt[i][j][k])
				{
					int tmp;
					if(k==0) tmp=1;
					if(k==1) tmp=0;
					if(k==2) tmp=3;
					if(k==3) tmp=2;
					add(cnt[i][j][k],cnt[i+dx[k]][j+dy[k]][tmp],1);
					//连单向边就可以了 后面会遍历到旁边状态连回来的
					//交换空白格子和起点格子 只需要一步  
				}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<4;k++)
				for(int p=0;p<4;p++)//枚举起点格子相邻一圈的两个格子 
					if(k!=p&&cnt[i][j][k]&&cnt[i][j][p])
						add(cnt[i][j][k],cnt[i][j][p],bfs(i+dx[k],j+dy[k],i+dx[p],j+dy[p],i,j));
	//可以起点格子不动 而空白格子绕着它转(换方向)
	//如果用起点格子自己换方向 可能没那么优秀因为要绕一绕 
	//而且起点格子有可能会跑到一个离终点的地方去了 更不优 
	//而只动空白格子可能会优秀一些 因为空白格子最优(到处都是活动格子)只用走2~4步 
	
	//经过其他格子没有任何影响 因为都是1 只是空白格子变了而已
	//而经过起点格子则会改变起点格子的坐标 
}
int dis[N*N];
int spfa()
{
	queue<int>Q;
	while(!Q.empty()) Q.pop();
	if(sx==tx&&sy==ty) return 0;
	memset(dis,INF,sizeof(dis));
	memset(mark,0,sizeof(mark));
	for(int k=0;k<4;k++)
	{//空格先走到起点的四周 初始状态 以空格从起点四周开始 
		if(cnt[sx][sy][k])
		{
			dis[cnt[sx][sy][k]]=bfs(ex,ey,sx+dx[k],sy+dy[k],sx,sy);
			Q.push(cnt[sx][sy][k]);
			mark[cnt[sx][sy][k]]=1; 
		}
	}
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();
		mark[u]=0;
		for(int i=0;i<G[u].size();i++)
		{
			int v=G[u][i].first,w=G[u][i].second;
			if(dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				if(!mark[v])
				{
					Q.push(v);
					mark[v]=1;
				}
			}
		}
	}
	//空格在哪里不用管 起点格子到了就可以 
	//从空格在起点格子四周随便哪个地方的状态到空格在终点格子四周随便哪个地方的状态
	int res=INF;
	for(int k=0;k<4;k++)
		if(cnt[tx][ty][k])
			res=min(res,dis[cnt[tx][ty][k]]);
	if(res==INF) return -1;//走不到
	return res; 	
}
int main() 
{
	n=rd(),m=rd(),q=rd();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			mp[i][j]=rd();
	Init();
	while(q--)
	{
		ex=rd(),ey=rd(),sx=rd(),sy=rd(),tx=rd(),ty=rd();
		printf("%d\n",spfa());
	}
	return 0;
}

```


---

## 作者：叶ID (赞：9)

**纯属玄学做法，要学正解的请跳过这篇**

有一次集训模拟赛，直接拿了NOIp原题卷当试卷。我看到这道题，就打了个纯BFS暴力，交洛谷60分，结果真正评测的时候我以最后一个点`1.000s`的时间获得了100分的好成绩。

于是我意识到这可以是一道**卡常练习题**。所谓卡常，就是通过优化复杂度中的常数因子使原本超出时间或空间限制（本题是时间）的算法能通过。

### 普通暴力

我们可以考虑在搜索时用下面的的结构来存储状态：

```cpp
struct Status{
    int ex,ey,sx,sy;
    // ex,ey是空格的位置，sx,sy是当前绿色棋子的位置。
    signed step;
    // 记录步骤数
    inline signed toInt() {
        return (ex<<15)|(ey<<10)|(sx<<5)|sy;
    }
    // 使用这个toInt函数，可以将当前状态转化为一个整数，这样就可以使用一个数组来判重。
    // 由于n和m只有30，显然用32做进制非常好。不难证明只需一个1048576大小的数组
}
```

搜索时我们枚举空白格子周边的4个格子，并考虑将空白格子移动到这4个格子（即，将这个棋子移到空白格子中）。

如果枚举到的周边的格子坐标是`(sx,sy)`，那么要交换`sx和ex`，`sy和ey`。否则只需移动`ex`和`ey`即可。

然后bfs就很容易写出来了。这是我们最初的纯暴力版本。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,q;
int a[31][31];

struct Status{
    int ex,ey,sx,sy;
    int step;
    Status() {
    }
    Status(int _ex,int _ey,int _sx,int _sy):
        ex(_ex),ey(_ey),sx(_sx),sy(_sy)
    {
        
    }
    
    int toInt() {
        return
            ex*31*31*31+
            ey*31*31+
            sx*31+
            sy;
    }
}que[810010]; //数组模拟队列
int tx,ty;
int h,t; //首尾下标
bool vis[1048576];

//定义“相邻的4个格子”相对当前格子的位置
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};

int bfs() {
    while(h<t) {
        h++;
        if(que[h].sx==tx && que[h].sy==ty) {
            return que[h].step;
        }
        for(int i=0;i<4;i++) {
            int ex2=que[h].ex+dx[i];
            int ey2=que[h].ey+dy[i];
            if(ex2<1 || ex2>n || ey2<1 || ey2>m) continue;
            if(a[ex2][ey2]==0) continue;
            Status tmp;
            tmp.ex=ex2;
            tmp.ey=ey2;
            tmp.sx=que[h].sx;
            tmp.sy=que[h].sy;
            tmp.step=que[h].step+1;
            if(ex2==que[h].sx && ey2==que[h].sy) {
                tmp.sx=que[h].ex;
                tmp.sy=que[h].ey;
            }
            if(vis[tmp.toInt()]) continue;
            vis[tmp.toInt()]=1;
            t++;
            que[t]=tmp;
            if(que[t].sx==tx && que[t].sy==ty) {
                return que[t].step;
            }
        }
    }
    return -1;
}

int main() {
    //freopen("puzzle.in","r",stdin);
    //freopen("puzzle.out","w",stdout);
    
    scanf("%d%d%d",&n,&m,&q);
    
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {
            cin>>a[i][j];
        }
    }
    
    for(int i=1;i<=q;i++) {
        scanf("%d%d%d%d%d%d",
            &que[1].ex,&que[1].ey,&que[1].sx,&que[1].sy,
            &tx,&ty);
        que[1].step=0;
        h=0;
        t=1;
        for(int i=0;i<=1048575;i++) {
            vis[i]=0;
        }
        printf("%d\n",bfs());
    }
}

```

这个程序能够获得60分的成绩。

很容易发现，进行一次`bfs`的时间复杂度为$O(n^2m^2)$，因为最多有$n^2m^2$种状态，此时最坏时间复杂度为$30^4$，即$810000$。再乘上$q=500$，就是$4,0500,0000‬$。再加上`bfs`有较大的常数，不死就怪。

但是显然$4,0500,0000‬$是跑不满的，因此只需优化一下常数，就能获得更好的成绩。

### 进行常数优化

仔细观察程序，不难发现，很多地方可以优化常数。

**手动O3+Ofast**

```cpp
%:pragma GCC optimize("inline,Ofast",3)
或
#pragma GCC optimize("inline,Ofast",3)
```

一定要加载头文件前面！

**避免初始化清空vis数组**

显然vis数组很大，清空浪费时间。

我们考虑维护当前在进行第几次`BFS`。如果vis数组中的值等于当前次数，才认为这个状态出现过。同样，标记`vis`时标记为当前次数。

这样就可以不清空vis数组。

**使用快读快写。**

```cpp
inline void read(int &ret) {
    ret=0;
    register char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) {ret=ret*10+(c-'0');c=getchar();}
}

void __write(signed x) {
    if(!x) return;
    __write(x/10);
    putchar('0'+x%10);
}

inline void write(const signed &x,char e='\0') {
    if(x>0) __write(x);
    else if(x==0) putchar('0');
    else {putchar('-');__write(-x);}
    if(e) putchar(e);
}

主程序中：
read(n);read(m);read(q);
write(bfs(),'\n');
等等...
```

**使用指针来完成队列操作**

实际上，指针比数组下标访问更快。假设有一个`int`数组`arr`，那么我们可以定义一个指针`int *ptr = arr`，此时`ptr`指向`arr[0]`，`ptr+1`指向`arr[1]`，以此类推。

```cpp
取值：
cout<<(*ptr)<<endl;

赋值：
(*ptr) = 25

假设ptr指向的是Status类型，对其step赋值和取值
ptr->size = 12
cout<<(ptr->size)<<endl
```

我们可以将队列的首尾下标变成首尾指针。那么我们仍然可以使用`++h`，`++t`这种方式进行队列模拟。

**加register, inline**

`inline`可以用在非递归函数的类型前，防止不必要的进栈操作。

`register`可以用在局部变量的类型前，这样可以定义将变量存在寄存器中，加快访问速度。但是寄存器容量小，不宜使用太多register，否则系统会花时间将较早定义的元素扔出寄存器，放入内存，造成负优化。

**修改dx, dy数组，防止搜索时单步回退**

我们注意到，BFS扩展（转移）部分常数较大

```
int dx[4]={0,1,-1,0};
int dy[4]={-1,0,0,1};
```

这样定义的`dx,dy`有个性质，即，dx和dy中分别取下标相加等于3的两个元素，相加必等于0。

我们可以给`Status`结构添加一个属性`tp`，即，上次使用的`dx和dy`中的哪个元素。

下一次扩展时，若枚举的`i`与上次的`tp`相加得3，说明这样扩展必将退回到上一个状态。显然这个状态是没用的（判重时会`continue`掉）

对于初始化，只需初始化`tp=-1`即可（因为没有任何`i`会与`-1`相加为3）

最后的代码长这样

```cpp
// status: [status_undefined]
// oj:     [luogu]
%:pragma GCC optimize("inline,Ofast",3)
#include<stdio.h>
#include<ctype.h>
#define int short // short卡常

int n,m,q;
int a[31][31];

struct Status{
    int ex,ey,sx,sy;
    signed step; // 步骤数等地方不可以使用short，可能会爆
    int tp;
    inline signed toInt() { 
        return (ex<<15)|(ey<<10)|(sx<<5)|sy;
    }
}que[810010];
int tx,ty;
Status *h,*t; //用指针
int vis[1048576];
int vis_t=0;

int dx[4]={0,1,-1,0};
int dy[4]={-1,0,0,1};

inline signed bfs() {
    ++vis_t;
    while(h!=t) {
        ++h;
        if(h->sx==tx && h->sy==ty) {
            return h->step;
        }
        for(register int i=0;i<4;i++) {
            if(i+h->tp==3) continue; //相加等于3的优化
            register int ex2=h->ex+dx[i];
            register int ey2=h->ey+dy[i];
            if(ex2<1 || ex2>n || ey2<1 || ey2>m) continue;
            if(!a[ex2][ey2]) continue;
            ++t;
            t->ex=ex2;
            t->ey=ey2;
            t->sx=h->sx;
            t->sy=h->sy;
            if(ex2==h->sx && ey2==h->sy) {
                t->sx=h->ex;
                t->sy=h->ey;
            }
            register signed _t=t->toInt();
            if(vis[_t]==vis_t) {--t;continue;}
            t->step=h->step+1;
            t->tp=i;
            vis[_t]=vis_t;
            if(t->sx==tx && t->sy==ty) {
                return t->step;
            }
        }
    }
    return -1;
}

inline void read(int &ret) {
    ret=0;
    register char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) {ret=ret*10+(c-'0');c=getchar();}
}

void __write(signed x) {
    if(!x) return;
    __write(x/10);
    putchar('0'+x%10);
}

inline void write(const signed &x,char e='\0') {
    if(x>0) __write(x);
    else if(x==0) putchar('0');
    else {putchar('-');__write(-x);}
    if(e) putchar(e);
}

signed main() {
    read(n);read(m);read(q);
    
    for(int i=1;i<=n;i++) {
        register int *tt = a[i];
        for(int j=1;j<=m;j++) {
            ++tt;
            read(*tt);
        }
    }
    
    t=que+1;
    t->tp = -1;
    t->step = 0; // 无需每次初始化的东西放到循环外
    for(register int i=1;i<=q;i++) {
        h=que;
        t=que+1;
        read(t->ex);read(t->ey);read(t->sx);read(t->sy);
        read(tx);read(ty);
        write(bfs(),'\n');
    }
}

```


---

## 作者：Noah2022 (赞：6)

看到楼上的大佬们说 bfs 不能过，但我的广搜能过。
### 思路
对于每一个询问，我们直接开跑搜索，有一点要注意，如果我们搜到的那一个新的空白格的位置 $(x,y)$ 与那个指定棋子的初始位置相同的话，就要做出一些特判即可，809 毫秒 AC。
**注：尽量不要卡常，我越卡越慢**。

### Code and [AC Link](https://www.luogu.com.cn/record/199408728)
```cpp
#include<bits/stdc++.h>
#define N 32
using namespace std;
int n, m, q,g[N][N],dx[]={0,0,1,-1},dy[]={1,-1,0,0};
struct node {int a, bj, c, d, step;};
node qq[N * N * N * N];
int hd, tl;
bool bj[N][N][N][N];
int main(){
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	cin >> n >> m >> q;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			cin >> g[i][j];
		}
	}
	int a, b, c, d, e, f;
	while(q--){
		memset(bj, 0, sizeof(bj));
		cin >> a >> b >> c >> d >> e >> f;
		hd = 1, tl = 0;
		qq[++tl] = (node){a, b, c, d, 0};
		bj[a][b][c][d] = 1;
		int ans = -1;
		while(hd <= tl){
			node tmp = qq[hd];
			hd++;
			if(tmp.c == e && tmp.d == f){
				ans = tmp.step;
				break;
			}
			for(register int i = 0; i < 4; i++){
				int xx = tmp.a + dx[i], yy = tmp.bj + dy[i];
				if(xx < 1 || xx > n || yy < 1 || yy > m || g[xx][yy] == 0) continue;
				if(xx == tmp.c && yy == tmp.d){
					if(!bj[xx][yy][tmp.a][tmp.bj]){
						qq[++tl] = (node){xx, yy, tmp.a, tmp.bj, tmp.step + 1};
						bj[xx][yy][tmp.a][tmp.bj] = 1;
					} 
				}else{
					if(!bj[xx][yy][tmp.c][tmp.d]){
						qq[++tl] = (node){xx, yy, tmp.c, tmp.d, tmp.step + 1};
						bj[xx][yy][tmp.c][tmp.d] = 1;
					}
				}
			}
		}
		cout << ans << endl;
	}
}
```

---

## 作者：Erutsiom (赞：5)

### 洛谷P1979 华容道 题解

#####  距离NOIP2018还有7天qwq写篇题解积攒下人品
##### （第一次写紫题题解还有些小激动）

**一些说明**

1、本题解与代码中的0/1/2/3分别代表上/下/左/右

2、为了清晰表述，题解中记目标棋子（题目中的 $SX,SY$ ）为 $B$ ，目标格子（题目中的 $TX,TY$ 为 ）$C$，空白格为$E$


【思路分析】
如几位dalao所说，这道题的建图就是把可行的状态连边，对于每次询问跑最短路即可。

我用 $ ok[i][j][0/1/2/3] $表示 $B$位于点$(i,j)$时，四个方向是否可能有空白格（先不考虑每组询问中空白格是否可以到达，只考虑该格子是否为固定格，或越界。）

此部分代码如下：

```
//判断哪些状态是合法的 
	for(int i=1;i<=n;i++)//空白格在棋子上下左右 
	for(int j=1;j<=m;j++){
		if(!mapp[i][j])continue;//不可能有此状态 
		for(int k=0;k<4;k++)//四个方向 
		if(judge(i+xx[k],j+yy[k]))ok[i][j][k]=1;
		}
```
judge函数用来判断是否为空白格或越界：
```
bool judge(int ax,int ay){
	if(ax<=0||ax>n||ay<=0||ay>m)return 0;//边界 
	return mapp[ax][ay];
}
```
为了建图方便，我将状态存到一维数组里：
格子的编号：从上到下从左到右编

$e.g.$
- 1 2 3 4
- 5 6 7 8
- ……

状态的编号：$e.g.$ 

1号格子的四个状态编号为0123 

于是得到如下编号函数：
```
int getnum(int ax,int ay,int t){
	return ((ax-1)*m+ay)*4-(4-t);
}//t=0/1/2/3
```
由于$q$组询问的地图情况是相同的，我们可以先建图。

什么样的两个状态可以连边呢？

考虑两种情况：

**·空白格子绕着$B$上下左右乱转**

可以用bfs求出乱转最少多少次可以从上转到下，从左转到右...

需要注意的是，乱转时$B$是不能动的！！！（这个地方卡了好久QAQ）

**·空白格子和$B$交换位置**

必须保证两个状态都存在。

连上距离为1的边即可。
```
int bfs(int dx,int dy,int sx,int sy,int tx,int ty){//空白格子乱转的最小次数 
	//(sx,sy)出发到(tx,ty)，不能经过(dx,dy)
	queue<white>q;
	memset(vis,0,sizeof vis);
	white st;st.x=sx;st.y=sy;
	st.step=0;vis[sx][sy]=1;
	q.push(st);
	while(!q.empty()){
		white noww=q.front();
		q.pop();
		if(noww.x==tx&&noww.y==ty)//到达目标格子 
		return noww.step;
		for(int i=0;i<4;i++){//四个方向乱转 
			if(judge(noww.x+xx[i],noww.y+yy[i])){//如果合法 
				if(vis[noww.x+xx[i]][noww.y+yy[i]])continue;//正在访问 
				if(noww.x+xx[i]==dx&&noww.y+yy[i]==dy)continue;//不能碰到目标棋子 
				white nxt;
				nxt.x=noww.x+xx[i];
				nxt.y=noww.y+yy[i];
				nxt.step=noww.step+1;
				q.push(nxt);vis[noww.x+xx[i]][noww.y+yy[i]]=1;
			}
		}
	}
	return inf;//到不了 
}
```
#### 棋子不动，空白格乱转的情况 ：

```
    for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
    for(int k=0;k<4;k++)
	for(int l=k+1;l<4;l++){
		if(ok[i][j][k]&&ok[i][j][l]){//必须都要合法 
			int aa=getnum(i,j,k);
			int bb=getnum(i,j,l);
			int cc=bfs(i,j,i+xx[k],j+yy[k],i+xx[l],j+yy[l]);
			if(cc==inf)continue;
			add(aa,bb,cc);add(bb,aa,cc);
		}
	}
```
qwq
```
	for(int i=1;i<=n;i++)//空白与目标棋子左右互换 
	for(int j=1;j<m;j++){
		if(ok[i][j][3]&&ok[i][j+1][2]){ //注意谁左谁右
			int aa=getnum(i,j,3);//别问我怎么知道的orz
			int bb=getnum(i,j+1,2);
			add(aa,bb,1);add(bb,aa,1);
		}
	}
	for(int i=1;i<n;i++)//上下互换 
	for(int j=1;j<=m;j++){
		if(ok[i][j][1]&&ok[i+1][j][0]){
			int aa=getnum(i,j,1);
			int bb=getnum(i+1,j,0);
			add(aa,bb,1);add(bb,aa,1);
		}
	}
```

这样我们的初始化就完成啦！
（加边的操作就和普通图论一样了w）


#### 对于每一组询问，先特判一下：

```
while(q--){
		scanf("%d%d%d%d%d%d",&ex,&ey,&bx,&by,&cx,&cy);
		if(bx==cx&&by==cy){
			puts("0");
			continue;
		}
		if(!mapp[cx][cy]){
			puts("-1");
			continue;
		}
		if(!mapp[bx][by]){
			puts("-1");
			continue;
		}
		work();
	}
```

#### 然后考虑，怎样把一开始的状态转移到图上呢？

因为图上只存在空白格与$B$ 相邻的状况，so暴力尝试让空白格跑到$B$的四个方向就好啦
```
    for(int i=0;i<4;i++){//空白走到目标棋子旁边 
		if(judge(bx+xx[i],by+yy[i])){//这个点可以走 
			int nw=bfs(bx,by,ex,ey,bx+xx[i],by+yy[i]);
			if(nw==inf)continue;//走不到 
			int nq=getnum(bx,by,i);
			d[nq]=nw;
			Q.push(nq);
			viss[nq]=1;
		}
	}
```
#### 然后，愉快地跑SPFA

```
    while(!Q.empty()){
		int noww=Q.front();Q.pop();viss[noww]=0;
		for(int j=head[noww];j;j=b[j].nxt){
			int vv=b[j].to;
			if(d[vv]>d[noww]+b[j].dis){
				d[vv]=d[noww]+b[j].dis;
				if(!viss[vv])Q.push(vv),viss[vv]=1;
			}
		}
	}
```
#### 最后，愉快地检查是否能到$C$
```
    int ans=inf;
	for(int i=0;i<4;i++){
		int qaq=getnum(cx,cy,i);
		ans=min(ans,d[qaq]);
	}
	if(ans==inf)puts("-1");
	else printf("%d\n",ans);
```

## 贴无注释代码QWQ

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=35;
const int inf=99999999;
int n,m,q,ex,ey,bx,by,cx,cy;
bool mapp[MAXN][MAXN];
int xx[4]={-1,1,0,0};
int yy[4]={0,0,-1,1};
int getnum(int ax,int ay,int t){
	return ((ax-1)*m+ay)*4-(4-t);
} 
struct white{
	int x,y;
	int step;
};
bool judge(int ax,int ay){
	if(ax<=0||ax>n||ay<=0||ay>m)return 0;
	return mapp[ax][ay];
}
bool vis[MAXN][MAXN];
int bfs(int dx,int dy,int sx,int sy,int tx,int ty){
	queue<white>q;
	memset(vis,0,sizeof vis);
	white st;st.x=sx;st.y=sy;
	st.step=0;vis[sx][sy]=1;
	q.push(st);
	while(!q.empty()){
		white noww=q.front();
		q.pop();
		if(noww.x==tx&&noww.y==ty)
		return noww.step;
		for(int i=0;i<4;i++){
			if(judge(noww.x+xx[i],noww.y+yy[i])){
				if(vis[noww.x+xx[i]][noww.y+yy[i]])continue;
				if(noww.x+xx[i]==dx&&noww.y+yy[i]==dy)continue; 
				white nxt;
				nxt.x=noww.x+xx[i];
				nxt.y=noww.y+yy[i];
				nxt.step=noww.step+1;
				q.push(nxt);vis[noww.x+xx[i]][noww.y+yy[i]]=1;
			}
		}
	}
	return inf;
}
struct edge{
	int to,nxt,dis;
}b[5005];
int head[5005],tot;
void add(int u,int v,int w){
	b[++tot].to=v;b[tot].nxt=head[u];
	b[tot].dis=w;head[u]=tot;
}
bool ok[MAXN][MAXN][5];
void init(){
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		if(!mapp[i][j])continue;
		for(int k=0;k<4;k++)
		if(judge(i+xx[k],j+yy[k]))ok[i][j][k]=1;
		}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
    for(int k=0;k<4;k++)
	for(int l=k+1;l<4;l++){
		if(ok[i][j][k]&&ok[i][j][l]){
			int aa=getnum(i,j,k);
			int bb=getnum(i,j,l);
			int cc=bfs(i,j,i+xx[k],j+yy[k],i+xx[l],j+yy[l]);
			if(cc==inf)continue;
			add(aa,bb,cc);add(bb,aa,cc);
		}
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<m;j++){
		if(ok[i][j][3]&&ok[i][j+1][2]){ 
			int aa=getnum(i,j,3);
			int bb=getnum(i,j+1,2);
			add(aa,bb,1);add(bb,aa,1);
		}
	}
	for(int i=1;i<n;i++)
	for(int j=1;j<=m;j++){
		if(ok[i][j][1]&&ok[i+1][j][0]){
			int aa=getnum(i,j,1);
			int bb=getnum(i+1,j,0);
			add(aa,bb,1);add(bb,aa,1);
		}
	}
}
queue<int>Q;
bool viss[5005];
int d[5005];
void work(){
	memset(d,128/3,sizeof d);
	memset(viss,0,sizeof viss);
	for(int i=0;i<4;i++){
		if(judge(bx+xx[i],by+yy[i])){
			int nw=bfs(bx,by,ex,ey,bx+xx[i],by+yy[i]);
			if(nw==inf)continue; 
			int nq=getnum(bx,by,i);
			d[nq]=nw;
			Q.push(nq);
			viss[nq]=1;
		}
	}
	while(!Q.empty()){
		int noww=Q.front();Q.pop();viss[noww]=0;
		for(int j=head[noww];j;j=b[j].nxt){
			int vv=b[j].to;
			if(d[vv]>d[noww]+b[j].dis){
				d[vv]=d[noww]+b[j].dis;
				if(!viss[vv])Q.push(vv),viss[vv]=1;
			}
		}
	}
	int ans=inf;
	for(int i=0;i<4;i++){
		int qaq=getnum(cx,cy,i);
		ans=min(ans,d[qaq]);
	}
	if(ans==inf)puts("-1");
	else printf("%d\n",ans);
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)cin>>mapp[i][j];
	init();
	while(q--){
		scanf("%d%d%d%d%d%d",&ex,&ey,&bx,&by,&cx,&cy);
		if(bx==cx&&by==cy){
			puts("0");
			continue;
		}
		if(!mapp[cx][cy]){
			puts("-1");
			continue;
		}
		if(!mapp[bx][by]){
			puts("-1");
			continue;
		}
		work();
	}
	return 0;
}

```
# 完结撒花！！！

##  _by   Erutsiom _ 


---

## 作者：ZHR100102 (赞：3)

[Blog](https://www.cnblogs.com/zhr0102/p/18881350)

很 trivial 的图论建模。

注意到 $n,m$ 较小，直接考虑**暴力**思路：状态 $(a,b,c,d)$ 表示棋子位置在 $(a,b)$，空白在 $(c,d)$ 的最小花费。把一个状态看做一个节点，跑 **BFS** 即可。时间复杂度 $O(qn^2m^2)$，小常数可以卡过去。

套路地，进一步**观察路径**，发现最终路径一定是两段：
- 空白格子移动到棋子旁边。
- 空白格子和棋子一起移动到终点。

先考虑第一段路径怎么做，因为给定的网格是固定不变的，所以考虑**预处理**。直接跑 $O(n^2m^2)$ 的全源 BFS 是不可行的，因为第一段路线中棋子是不能移动的；但是 $O(n^3m^3)$ 枚举棋子位置又会 TLE。继续观察，发现棋子的位置不需要枚举这么多，因为我们实际用的时候**只需要用到棋子在与目标四连通的格子里时，空白格子与目标点的距离**。于是只需要枚举与目标四连通的格子，然后预处理即可。时间复杂度 $O(n^2m^2)$。

继续考虑第二段怎么做，注意到**移动棋子的时候棋子和空白格子总是相邻的**，所以考虑记录空白格子相对棋子的方位即可做到 $O(nm)$ 级别的状态数。建边有两种类型：
- 交换空白格子与棋子，边权为 $1$。
- 改变空白格子相对棋子的方位，边权为空白格子移动的距离。

发现第二种建边方式恰好在前面预处理完了，于是跑一遍**单源最短路**即可。时间复杂度 $O(nm\log nm)$。

总体时间复杂度 $O(n^2m^2+qnm\log nm)$，可以轻松通过。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=35;
const int inf=0x3f3f3f3f;
int n,m,q,kdis[N][N][4][N][N],dis[N][N][4];
int gox[]={0,0,1,-1};
int goy[]={1,-1,0,0};
bitset<N>a[N];
bool legal(int x,int y)
{
    return (1<=x&&x<=n&&1<=y&&y<=m);
}
void caldis(int bx,int by,int sx,int sy,int tp)
{
    if(bx==sx&&by==sy)return;
    queue<pi>q;
    q.push({sx,sy});
    kdis[bx][by][tp][sx][sy]=0;
    while(!q.empty())
    {
        pi u=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int tx=u.fi+gox[i],ty=u.se+goy[i];
            if(legal(tx,ty)&&a[tx][ty]==1&&(tx!=bx||ty!=by)&&kdis[bx][by][tp][tx][ty]>=inf)
            {
                q.push({tx,ty});
                kdis[bx][by][tp][tx][ty]=kdis[bx][by][tp][u.fi][u.se]+1;
            }
        }
    }
}
void init()
{
    memset(kdis,0x3f,sizeof(kdis));
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int x=0;x<4;x++)
                if(legal(i+gox[x],j+goy[x]))
                    caldis(i,j,i+gox[x],j+goy[x],x);
}
struct Node{
    int x,y,tp,dis;
    bool operator>(const Node &t)const{
        return dis>t.dis;
    }
};
void solve()
{
    int ex,ey,sx,sy,px,py;
    cin>>ex>>ey>>sx>>sy>>px>>py;
    if(sx==px&&sy==py)
    {
        cout<<0<<'\n';
        return;
    }
    memset(dis,0x3f,sizeof(dis));
    priority_queue<Node,vector<Node>,greater<Node> >q;
    bitset<4>vis[N][N];
    for(int i=0;i<4;i++)
    {
        int tx=sx+gox[i],ty=sy+goy[i];
        if(legal(tx,ty)&&a[tx][ty]==1&&kdis[sx][sy][i][ex][ey]<inf)
        {
            q.push({tx,ty,i^1,kdis[sx][sy][i][ex][ey]+1});
            dis[tx][ty][i^1]=kdis[sx][sy][i][ex][ey]+1;
            q.push({sx,sy,i,kdis[sx][sy][i][ex][ey]});
            dis[sx][sy][i]=kdis[sx][sy][i][ex][ey];
        }
    }
    while(!q.empty())
    {
        Node u=q.top();
        q.pop();
        if(vis[u.x][u.y][u.tp]==1)continue;
        vis[u.x][u.y][u.tp]=1;
        if(legal(u.x+gox[u.tp],u.y+goy[u.tp])&&dis[u.x+gox[u.tp]][u.y+goy[u.tp]][u.tp^1]>u.dis+1)
        {
            dis[u.x+gox[u.tp]][u.y+goy[u.tp]][u.tp^1]=u.dis+1;
            q.push({u.x+gox[u.tp],u.y+goy[u.tp],u.tp^1,u.dis+1});
        }
        for(int i=0;i<4;i++)
        {
            if(i==u.tp)continue;
            int tx=u.x+gox[i],ty=u.y+goy[i];
            if(legal(tx,ty)&&u.dis+kdis[u.x][u.y][u.tp][tx][ty]<dis[u.x][u.y][i])
            {
                dis[u.x][u.y][i]=u.dis+kdis[u.x][u.y][u.tp][tx][ty];
                q.push({u.x,u.y,i,dis[u.x][u.y][i]});
            }
        }
    }
    int ans=inf;
    for(int i=0;i<4;i++)
        ans=min(ans,dis[px][py][i]);
    if(ans>=inf)
        cout<<-1<<"\n";
    else
        cout<<ans<<'\n';
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            char c;
            cin>>c;
            a[i][j]=(c=='0'?0:1);
        }
    }
    init();
    while(q--)
        solve();
    return 0;
}
```

---

## 作者：hkr04 (赞：2)

[题目链接](https://www.luogu.org/problem/P1979)  
 _说在前面：_ 首先这道题比较冗杂，如果因为您不太接受我的码风/表达方式而带来了不太好的阅读效果，我向您道歉（鞠躬  

题面请戳链接，请您在确保对这道题目的背景和做这道题的大致方向有了一定的掌握后，再食用这篇博客，以确保较好的阅读效果  

除去多次询问不谈，这道题大致的框架是非常明显的搜索。但是虽然是多次询问，棋盘的状态是不会变的，并且只有部分的位置是真正有价值的。那么就可以考虑图论建模，在这些有价值的状态上跑从终态到末态的最短路。因为棋子要移动的时候，空白块一定要移到它的周围，所以我们可以为这种周围的位置编号。$f[x][y][i]$表示在点$(x, y)$的方向$i(0\le i \le 3)$上的位置的编号。这里我们有两个数组表示方向的偏移量，不同的$i$分别配对左、右、上、下：$dx[4]={0, 0, -1, 1},dy[4]={-1, 1, 0, 0}$。这样编号的好处是，$i \ xor\ 1$即可表示相反的方向  

点建好了，接下来考虑怎么连边。显然的一点是，为了使目标棋子更快地前进，空白格移动到棋子旁的路上不应该与棋子发生交换。对于一个在棋子旁边的空白格，它有以下的选择：  
1. 绕到棋子的另一个方向上，使得棋子向该方向前进，即:$f[x][y][i]\to f[x][y][j](i\not= j) $  
2. 直接和棋子交换位置，让棋子向原本的空白格的方向前进，即:$f[x][y][i]\to f[x+dx[i]][y+dy[i]][i \ xor \ 1]$  

由于第一种选择不能受到各种元素限制，所以需要bfs来确定边权。作完这些预处理之后，这些点之间就构成了一个图论模型。对于每次询问，对移动的棋子周围的4个位置做一次bfs，得到让空白格（在不移动该棋子的情况下）移动到棋子四周的最小代价。再把这四个初状态压入队列中，跑一遍$SPFA$，最后枚举末状态取一个$dis$的$min$就是答案了  

还有一些细节：
1. 起点和终点相同时记得特判  
2. 正确估计模型中最多会有多少个点来开数组

具体请结合代码理解：  
```cpp
//从main开始看
#include <cstdio>
#include <cstring>
const int maxn=50;
const int maxm=1000000;
const int INF=0x3f3f3f3f;
int a[maxn][maxn],f[maxn][maxn][4];
int dx[4]={0, 0, 1, -1},dy[4]={1, -1, 0, 0};
int head[maxn*maxn*4],to[maxm],nxt[maxm],val[maxm];
int dis[maxn*maxn];
int cnt,tot;
int n,m,Q;
bool vis[maxn][maxn],inq[maxn*maxn];
struct node
{
	int x,y,w;
	node() {}
	node(int a,int b,int c) {x=a,y=b,w=c;}
};
struct Queue
{
	int l,r;
	node a[maxn*maxn];
	Queue() {l=1,r=0;}
	void push(node x) {a[++r]=x;}
	void pop() {l++;}
	node front() {return a[l];}
	bool empty() {return l>r;}
};//这两个手写队列分别给bfs和SPFA用= =，直接用STL也差不多的
struct Que
{
	int l,r;
	int a[maxn*maxn];
	Que() {l=1,r=0;}
	void push(int x) {a[++r]=x;}
	void pop() {l++;}
	int front() {return a[l];}
	bool empty() {return l>r;}
};

int min(int x,int y) {return x<y?x:y;}
bool valid(int x,int y) {return a[x][y];}
void add(int u,int v,int w)
{
	nxt[++tot]=head[u];
	head[u]=tot;
	to[tot]=v;
	val[tot]=w;
}
int bfs(int target_x,int target_y,int sx,int sy,int tx,int ty)
{
	if (sx==tx&&sy==ty)
		return 0;
	memset(vis, 0, sizeof(vis));
	Queue q;
	vis[sx][sy]=1;
	vis[target_x][target_y]=1;//特殊标记一下，就当作走过了，反正不能走
	q.push(node(sx, sy, 0));
	while(!q.empty())
	{
		int ux=q.front().x,uy=q.front().y,uw=q.front().w;
		q.pop();
		for (int i=0;i<4;i++)
		{
			int vx=ux+dx[i],vy=uy+dy[i];
			if (!valid(vx, vy)||vis[vx][vy])
				continue;
			if (vx==tx&&vy==ty)
				return uw+1;
			vis[vx][vy]=1;
			q.push(node(vx, vy, uw+1));
		}
	}
	return INF;
}
int SPFA(int ex,int ey,int sx,int sy,int tx,int ty)
{
	if (sx==tx&&sy==ty)//特判一下
		return 0;
	memset(dis, 0x3f, sizeof(dis));
	memset(inq, 0, sizeof(inq));
	Que q;
	for (int i=0;i<4;i++)
	{
		int vx=sx+dx[i],vy=sy+dy[i];
		if (!valid(vx, vy))
			continue;
		dis[f[sx][sy][i]]=bfs(sx, sy, ex, ey, vx, vy);
		q.push(f[sx][sy][i]);
		inq[f[sx][sy][i]]=1;
	}
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		inq[u]=0;
		for (int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if (dis[v]>dis[u]+val[i])
			{
				dis[v]=dis[u]+val[i];
				if (!inq[v])
					inq[v]=1,q.push(v);
			}
		}
	}
	int ans=INF;
	for (int i=0;i<4;i++)
		ans=min(ans, dis[f[tx][ty][i]]); 
	return ans==INF?-1:ans;
}
int main()
{
	scanf("%d%d%d",&n,&m,&Q);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	
	for (int x=1;x<=n;x++)
		for (int y=1;y<=m;y++)
			for (int i=0;i<4;i++)
			{
				int vx=x+dx[i],vy=y+dy[i];
				if (!valid(vx, vy))
					continue;
				f[x][y][i]=++cnt;//给有用状态编号 
			}
            
	for (int x=1;x<=n;x++)
		for (int y=1;y<=m;y++)
			for (int i=0;i<4;i++)
				for (int j=0;j<4;j++)
				{
					if (i==j||!valid(x+dx[i], y+dy[i])||!valid(x+dx[j], y+dy[j]))
						continue;
					add(f[x][y][i], f[x][y][j], bfs(x, y, x+dx[i], y+dy[i], x+dx[j], y+dy[j]));
				}//选择1
                
	for (int x=1;x<=n;x++)
		for (int y=1;y<=m;y++)
			for (int i=0;i<4;i++)
			{
				if (!valid(x+dx[i], y+dy[i]))
					continue;
				add(f[x][y][i], f[x+dx[i]][y+dy[i]][i^1], 1);//选择2，交换空白格与棋子的位置，将这两个状态连边 
			}
	
	while(Q--)
	{
		int ex,ey,sx,sy,tx,ty;
		scanf("%d%d%d%d%d%d",&ex,&ey,&sx,&sy,&tx,&ty);
		printf("%d\n",SPFA(ex, ey, sx, sy, tx, ty)); 
	}
	return 0;
}
```

---

## 作者：ztz_cpp (赞：2)

# 华容道（NOIP2013 Day2 T3

## 题意：

游戏规则如下

1. 在一个 $n \times m$ 棋盘上有 $n \times m$ 个格子，其中有且只有一个格子是空白的，其余 $n \times m-1$ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $1 \times 1$ 的；
2. 有些棋子是固定的，有些棋子则是可以移动的；
3. 任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。

游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。

给定一个棋盘，进行 $q$ 次游戏，固定的格子不会变化，但是初始格子，目标格子，初始空白格子会发生变化。

求出移动时最小的步数。

对于 $100\%$ 的数据，$1 \le n, m \le 30,q \le 500$ 。

## 分析

首先我们来考虑棋盘的状态是如何决定的。

比较显然的发现，一个局面只对应了不同位置的 **空白格子** 和 **给定棋子** 。

但是，状态是不是太多了……直接暴搜可能会挂……

那么，我们来考虑如何让给定棋子发生移动。

当且仅当，**空白格子** 在 **给定棋子** 旁边，这样才能使得 **空白格子** 和**给定棋子**交换位置。

而且在交换前和交换后，**空白格子** 总是和 **给定棋子** 相邻。

那么 **给定棋子** 要怎么移动呢？脑补一下，应该是 **空白格子** 带着 **给定棋子** 到处跑，移动后，**空白格子** 再包一圈到 **给定棋子** 需要继续移动的方向。

这样我们就可以只考虑  **空白格子** 和 **给定棋子** 相邻的状态，这样状态数就变少了，可以试着进一步考虑如何处理。

首先，我们可以通过 **给定棋子** 的坐标和 **空白格子** 在  **给定棋子** 的方向来决定一个状态。

在开始给代码前，关于变量名称的解释：

```cpp
const int fx[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//方向，f和f^2是对立方向（自己算算）（一开始我还算错了写成f^1然后调了一天……）
const int maxn=30;//如题
const int maxs=maxn*maxn;//一张图最多的点
const int maxp=maxs<<2;//最多的状态数（每个点都有四个方向可能存在空白格子）
const int inf=0x3f3f3f3f;

int n,m,q;

bool ma[maxn+5][maxn+5];//读入时可以移动的格子
```



```cpp
inline int point(int x,int y,int f){
	return (x-1)*m+y-1+f*maxs;
}
```



那么，一个状态就被处理成一个整数来表示了。

既然转移是在不同状态间发生的，我们考虑在不同状态间建边。

当交换相邻的 **空白格子** 和**给定棋子**时

```cpp
for(register int f=0;f<4;f++){
    int kx=x+fx[f][0];
    int ky=y+fx[f][1];
    if(!ma[kx][ky])
		continue;
    add(point(x,y,f),point(kx,ky,f^2),1);
}
```

这样，我们就建立好移动棋子时的代价了。

但是，我们还要考虑 ”**空白格子** 再包一圈到 **给定棋子** 需要继续移动的方向“ 的代价。

可以通过广搜搜到最近的距离，当然这个路径不能通过 **给定棋子** 不能造成 **给定棋子** 的移动。

```cpp
inline int dis_to(int sx,int sy,int tx,int ty){//标准广搜
	bool use[maxn+5][maxn+5];
	memset(use,0,sizeof use);
	queue<pair<pair<int,int>,int> >q;
	q.push(make_pair(make_pair(sx,sy),0));
	while(!q.empty()){
		int x=q.front().first.first;
		int y=q.front().first.second;
		int d=q.front().second;
		use[x][y]=1;
		q.pop();
		if(x==tx && y==ty)
			return d;
		for(register int f=0;f<4;f++){
			int xx=x+fx[f][0];
			int yy=y+fx[f][1];
			if(!use[xx][yy] && ma[xx][yy])
				q.push(make_pair(make_pair(xx,yy),d+1));
		}
	}
	return inf;
}

inline void add_edge(int x,int y){
	for(register int f=0;f<4;f++){
		int kx=x+fx[f][0];
		int ky=y+fx[f][1];
		if(!ma[kx][ky])
			continue;
		add(point(x,y,f),point(kx,ky,f^2),1);//合并上文的加边
		for(register int ff=0;ff<4;ff++){
			int xx=x+fx[ff][0];
			int yy=y+fx[ff][1];
			if(!ma[xx][yy] || f==ff)
				continue;
			ma[x][y]=0;
			add(point(x,y,f),point(x,y,ff),dis_to(kx,ky,xx,yy));
            //(kx,ky) 空白格子的一个方向 (xx,yy)空白格子的另外一个方向。
			ma[x][y]=1;
		}
	}
	return;
}
```

建好边后，就成为一个图了，怎么计算最小代价？`spfa，它又活了`

直接跑最短路计算最小代价，起飞。初始空白格子到给定棋子的步数可以再次使用 `dis_to`  先计算出来再加上。



```cpp
inline int work(int sx,int sy,int tx,int ty,int ex,int ey){
	if(sx==tx && sy==ty)//细节！！！
		return 0;
	int ans=inf;
	queue<int>q;
	bool vis[maxp+5];
	int dis[maxp+5];
	for(register int f=0;f<4;f++){//开始spfa时空白格子的方向
		int xx=sx+fx[f][0];
		int yy=sy+fx[f][1];//空白格子的坐标
		if(!ma[xx][yy])
			continue;
		memset(vis,0,sizeof vis);
		memset(dis,0x3f,sizeof dis);
		ma[sx][sy]=0;//一样的先标记为不能经过
		int ddd=dis_to(ex,ey,xx,yy);//这里先计算空白点到给定位置的代价。
		ma[sx][sy]=1;
		int s=point(sx,sy,f);
		dis[s]=0;
		q.push(s);
		while(!q.empty()){//标准spfa
			int x=q.front();
			q.pop();
			vis[x]=0;
			for(register int i=head[x];i;i=e[i].next){
				int y=e[i].to;
				int z=e[i].v;
				if(dis[y]>dis[x]+z){
					dis[y]=dis[x]+z;
					if(!vis[y]){
						q.push(y);
						vis[y]=1;
					}
				}
			}
		}
		for(register int ff=0;ff<4;ff++)
			ans=min(ans,dis[point(tx,ty,ff)]+ddd);//计算结束点的代价
	}
	return ans==inf ? -1 : ans;
}
```

## 完整代码

真的这题为什么时紫的我真的觉得大部分时代码的问题……

```cpp
#include<bits/stdc++.h>
using namespace std;

const int fx[4][2]={{0,-1},{-1,0},{0,1},{1,0}};
const int maxn=30;
const int maxs=maxn*maxn;
const int maxp=maxs<<2;
const int inf=0x3f3f3f3f;

int n,m,q;

bool ma[maxn+5][maxn+5];

inline int point(int x,int y,int f){
	return (x-1)*m+y-1+f*maxs;
}

struct edge{
	int next,to,v;
}e[maxp<<4];
int head[maxp+5],etot;
inline void add(int x,int y,int z){
	etot++;
	e[etot].next=head[x];
	e[etot].to=y;
	e[etot].v=z;
	head[x]=etot;
	return;
}

inline int dis_to(int sx,int sy,int tx,int ty){
	bool use[maxn+5][maxn+5];
	memset(use,0,sizeof use);
	queue<pair<pair<int,int>,int> >q;
	q.push(make_pair(make_pair(sx,sy),0));
	while(!q.empty()){
		int x=q.front().first.first;
		int y=q.front().first.second;
		int d=q.front().second;
		use[x][y]=1;
		q.pop();
		if(x==tx && y==ty)
			return d;
		for(register int f=0;f<4;f++){
			int xx=x+fx[f][0];
			int yy=y+fx[f][1];
			if(!use[xx][yy] && ma[xx][yy])
				q.push(make_pair(make_pair(xx,yy),d+1));
		}
	}
	return inf;
}

inline void add_edge(int x,int y){
	for(register int f=0;f<4;f++){
		int kx=x+fx[f][0];
		int ky=y+fx[f][1];
		if(!ma[kx][ky])
			continue;
		add(point(x,y,f),point(kx,ky,f^2),1);
		for(register int ff=0;ff<4;ff++){
			int xx=x+fx[ff][0];
			int yy=y+fx[ff][1];
			if(!ma[xx][yy] || f==ff)
				continue;
			ma[x][y]=0;
			add(point(x,y,f),point(x,y,ff),dis_to(kx,ky,xx,yy));
			ma[x][y]=1;
		}
	}
	return;
}

inline void make_gragh(){
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=m;j++)
			if(ma[i][j])
				add_edge(i,j);
	return;
}

inline int work(int sx,int sy,int tx,int ty,int ex,int ey){
	if(sx==tx && sy==ty)
		return 0;
	int ans=inf;
	queue<int>q;
	bool vis[maxp+5];
	int dis[maxp+5];
	for(register int f=0;f<4;f++){
		int xx=sx+fx[f][0];
		int yy=sy+fx[f][1];
		if(!ma[xx][yy])
			continue;
		memset(vis,0,sizeof vis);
		memset(dis,0x3f,sizeof dis);
		ma[sx][sy]=0;
		int ddd=dis_to(ex,ey,xx,yy);
		ma[sx][sy]=1;
		int s=point(sx,sy,f);
		dis[s]=0;
		q.push(s);
		while(!q.empty()){
			int x=q.front();
			q.pop();
			vis[x]=0;
			for(register int i=head[x];i;i=e[i].next){
				int y=e[i].to;
				int z=e[i].v;
				if(dis[y]>dis[x]+z){
					dis[y]=dis[x]+z;
					if(!vis[y]){
						q.push(y);
						vis[y]=1;
					}
				}
			}
		}
		for(register int ff=0;ff<4;ff++)
			ans=min(ans,dis[point(tx,ty,ff)]+ddd);
	}
	return ans==inf ? -1 : ans;
}

inline int read(){
	int x=0,c=getchar();
	while(!isdigit(c))
		c=getchar();
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return x;
}

int main(){
#ifdef ZTZ_CPP
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	scanf("%d%d%d",&n,&m,&q);
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=m;j++)
			ma[i][j]=read();
	make_gragh();
	for(register int i=1;i<=q;i++){
		int ex=read();
		int ey=read();
		int sx=read();
		int sy=read();
		int tx=read();
		int ty=read();
		printf("%d\n",work(sx,sy,tx,ty,ex,ey));
	}
	return 0;
}
```

---

## 作者：Jayun (赞：1)

## 题目大意

一个 $n\times m$ 的棋盘上填充着棋子，其中有一个空格。除了一些固定的棋子，空格相邻的棋子可以移动到空格上。一个棋盘上固定的棋子是确定的，给出 $q$ 个询问，对于每个询问回答，空格一开始在 $(ex,ey)$ 时，$(sx,sy)$ 上的指定棋子能否移动到 $(tx,ty)$ 和最少操作数。

$n,m\le30,q\le500$.

## 思路

优先考虑初始位置就是目的地的特殊情况，操作数为零。再考虑通常情况，不难从“其实是空格在移动”的方向思考。

指定棋子到目的地的操作示例如图：

![图片挂了见 https://gitee.com/JAYUN-0695/competition-solution/raw/master/%5BNOIP%202013%20%E6%8F%90%E9%AB%98%E7%BB%84%5D%20%E5%8D%8E%E5%AE%B9%E9%81%93/ChessBoardAnimation_ManimCE.gif](https://tc.z.wiki/autoupload/yErhptZDcyvSqeYsqujnlTzGH33Ave9sHPolTaaFBMCyl5f0KlZfm6UsKj-HyTuv/20250621/ZHd7/470X270/ChessBoardAnimation-ManimCE.gif)

不难发现，路径其实分为两段：

1. 空格移动到与指定棋子相邻处。若没有空格相邻，棋子肯定动不了，所以第一阶段必然是空格靠近指定棋子；
2. 指定棋子与空格一起移动到目的地。由图，它们移动的方式是类似转着圈移动。

对于第一段，由于空格和指定棋子都不确定，每次询问时 BFS 即可。

对于第二段，它们运动的轨迹较为复杂，加之以固定棋子为障碍，或许不好直接“呆板的暴力”。注意到，两者的“一大步”是指定棋子替代空格的位置后，空格再找到合适的相邻处，这“一大步”的操作对于棋盘来说是确定的（可以预处理）。

以此为基础，我们以这“一大步”作为边，**两者的位置**一并看作点，**“一大步”所需操作数**为边权建立图论模型。这样，最短路即为第二段的答案。

复杂度 $\mathcal{O}(n^2m^2+qnm\log nm)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 40, mod = 998244353, inf = 1010580540;

inline ll read() {
	ll x = 0, f = 1;
	char c = getchar();
	while (c != '-' && (c < '0' || c > '9')) c = getchar();
	if (c == '-') f = -f, c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x * f;
}

inline int add (int a, int b) { return a + b > mod? a + b - mod: a + b; }
inline int dec (int a, int b) { return a < b? a - b + mod: a - b; }
inline int mul (int a, int b) { return 1ll * a * b % mod; }

namespace Main {	
	int n, m;
	bool a[N][N];

	int rots[2][4] = {{0, 1, -1, 0}, {1, 0, 0, -1}};
	bool border(int x, int y) { return 1 <= x && x <= n && 1 <= y && y <= m; }
	bool able(int x, int y) { return border(x, y) && a[x][y]; }

	int head[N * N * 4], etot;
	struct edge { int to, nxt, w; } e[N * N * 32];
	void add(int u, int v, int w) { e[++etot] = (edge){v, head[u], w}, head[u] = etot; }
	struct node { int x, y, rot; };
	int id[N][N][4];

	int dis[N][N];
	bool vis[N][N];
	void bfs(int ix, int iy) {
		queue<node> q;
		q.push({ix, iy, -1});
		memset(vis, 0, sizeof vis);
		vis[ix][iy] = 1;
		while (!q.empty()) {
			node u = q.front(); q.pop();
			for (int rot = 0; rot < 4; ++rot) {
				int x = u.x + rots[0][rot], y = u.y + rots[1][rot];
				if (able(x, y) && dis[x][y] > dis[u.x][u.y] + 1) {
					dis[x][y] = dis[u.x][u.y] + 1;
					if (vis[x][y]) continue; vis[x][y] = 1;
					q.push({x, y, -1});
				}
			}
			vis[u.x][u.y] = 0;
		}
	}

	void prework() {
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				if (able(i, j))
					for (int rot = 0; rot < 4; ++rot) {
						int x = i + rots[0][rot], y = j + rots[1][rot];
						if (able(x, y)) {
							int u = (id[i][j][rot]? id[i][j][rot]: (id[i][j][rot] = ++etot));
							a[x][y] = 0;
							memset(dis, 60, sizeof dis);
							dis[i][j] = 1;
							// printf ("DEBUG P=(%d,%d)\n", i,j);
							bfs(i, j);
							for (int rot2 = 0; rot2 < 4; ++rot2) {
								int nx = x + rots[0][rot2], ny = y + rots[1][rot2];
								if (border(nx, ny) && dis[nx][ny] <= inf) {
									int v = (id[x][y][rot2]? id[x][y][rot2]: (id[x][y][rot2] = ++etot));
									add(u, v, dis[nx][ny]);
								}
							}
							a[x][y] = 1;
						}
					}
	}

	bool vs[N * N * 4];
	int dt[N * N * 4];
	void spfa(int x, int y) {
		queue<int>q;
		memset(vs, 0, sizeof vs);
		memset(dt, 60, sizeof(int) * (etot + 5));
		
		for (int rot = 0, u; rot < 4; ++rot)
			if (u = id[x][y][rot]) {
				q.push(u);
				dt[u] = dis[x + rots[0][rot]][y + rots[1][rot]];
				vs[u] = 1;
			}

		while(!q.empty()) {
			int u = q.front(); q.pop();
			for (int i = head[u]; i; i = e[i].nxt) {
				int v = e[i].to;
				if (!(dt[v] > dt[u] + e[i].w)) continue;
				dt[v] = dt[u] + e[i].w;
				q.push(v);
			}
			vs[u] = 0;
		}
	}

	int main () {
		n = read(), m = read(); int T = read();
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j) a[i][j] = read();

		// puts("DEBUG #1");
		prework();
		// puts("DEBUG #2");

		for (; T--; ) {
			int ex = read(), ey = read(), sx = read(), sy = read(), tx = read(), ty = read();
			
			if (sx == tx && sy == ty) { puts("0"); continue;}

			a[sx][sy] = 0;
			memset (dis, 60, sizeof dis);
			dis[ex][ey] = 0;
			bfs(ex, ey);
			a[sx][sy] = 1;

			spfa(sx, sy);

			int ans = inf;
			for (int rot = 0; rot < 4; ++rot) ans = min(ans, dt[id[tx][ty][rot]]);
			printf ("%d\n", (ans == inf? -1: ans));
		}
		return 0;
	}
}

int main () {
	string str = "";
//	freopen((str + ".in").c_str(), "r", stdin);
//	freopen((str + ".out").c_str(), "w", stdout);
	Main::main();
	return 0;
}
```

---

## 作者：TsReaper (赞：1)

考验状态记录技巧的一道好题！因为我们只要考虑指定块的位置，而指定块位置的移动和空白块有关，我们可以记录(x1,y1,x2,y2)表示指定块在(x1,y1)，空白块在(x2,y2)的状态。由于空白块可以四方向移动，所以每个状态会向四个状态连边。这样共有(nm)^2个状态，总复杂度为O(q(nm)^2)，只能通过60%的数据。

但是我们可以发现：只有空白块位于指定块的四方向上，指定块才可以移动。所以，我们可以记(x1,y1,dir)表示指定块在(x1,y1)，空白块在指定块的dir方向（0表示上，1表示下什么的......）的状态。这样状态只有4nm个。

接下来我们考虑各个状态之间的连边。首先，空白块和指定块可以交换位置，这两个状态连边的边权为1；其次，假定空白块在指定块上方，空白块可以通过若干步移动来到空白块下/左/右方。这些状态连边的边权我们可以通过BFS计算出来。

这样就构造出了一张图，先把空白块移动到目标块旁边，之后向目标状态（空白块可以位于指定块的四个方向）做最短路即可。用spfa复杂度为O(qknm)，可以通过100%的数据。

```cpp

#include <stdio.h>
#include <string.h>
#define QLEN 4000
int n,m,qq;
int e[20010][3],p[4010],tot = 0,ans;
int q[1010][2],dis[35][35],sq[4010],sdis[4010],head,tail;
short vis[4010],map[35][35],dir[4][2] = {-1,0,1,0,0,-1,0,1};
int min(int a,int b)
{
    return a<b?a:b;
}
void adde(int sn,int fn,int val)
{
    e[++tot][0] = fn; e[tot][1] = val; e[tot][2] = p[sn]; p[sn] = tot;
}
void bfs(int si,int sj,int bi,int bj,int id)
{
    int i,j,k,ii,jj;
    memset(dis,0,sizeof(dis));
    head = 1; tail = 2;
    q[1][0] = si; q[1][1] = sj; dis[si][sj] = 1;
    while(head != tail)
    {
        i = q[head][0]; j = q[head++][1];
        for(k=0;k<4;k++)
        {
            ii = i+dir[k][0]; jj = j+dir[k][1];
            if(!map[ii][jj] || (ii==bi&&jj==bj) || dis[ii][jj]) continue;
            dis[ii][jj] = dis[i][j]+1;
            q[tail][0] = ii; q[tail++][1] = jj;
        }
    }
    if(id == 4) return;
    for(k=0;k<4;k++)
    {
        i = bi+dir[k][0]; j = bj+dir[k][1];
        if((i == si && j == sj) || !dis[i][j]) continue;
        adde(bi*30*4+bj*4+id,bi*30*4+bj*4+k,dis[i][j]-1);
    }
    adde(bi*30*4+bj*4+id,si*30*4+sj*4+(id^1),1);
}
void spfa(int si,int sj)
{
    int i,sn,fn,val;
    memset(sdis,60,sizeof(sdis));
    head = 1; tail = 1;
    for(i=0;i<4;i++)
    {
        if(!dis[si+dir[i][0]][sj+dir[i][1]]) continue;
        sn = si*30*4+sj*4+i;
        sq[tail++] = sn; sdis[sn] = dis[si+dir[i][0]][sj+dir[i][1]]-1; vis[sn] = 1;
    }
    while(head != tail)
    {
        sn = sq[head++];
        for(i=p[sn];i;i=e[i][2])
        {
            fn = e[i][0]; val = e[i][1];
            if(sdis[fn]<=sdis[sn]+val) continue;
            sdis[fn] = sdis[sn]+val;
            if(vis[fn]) continue;
            vis[fn] = 1; sq[tail++] = fn;
            if(tail>QLEN) tail = 1;
        }
        vis[sn] = 0;
        if(head>QLEN) head = 1;
    }
}
int main()
{
    int i,j,bi,bj,si,sj,fi,fj;
    scanf("%d%d%d",&n,&m,&qq);
    for(i=1;i<=n;i++) for(j=1;j<=m;j++) scanf("%hd",&map[i][j]);
    for(i=1;i<=n;i++) for(j=1;j<=m;j++)
    {
        if(!map[i][j]) continue;
        if(map[i-1][j]) bfs(i-1,j,i,j,0);
        if(map[i+1][j]) bfs(i+1,j,i,j,1);
        if(map[i][j-1]) bfs(i,j-1,i,j,2);
        if(map[i][j+1]) bfs(i,j+1,i,j,3);
    }
    while(qq--)
    {
        scanf("%d%d%d%d%d%d",&bi,&bj,&si,&sj,&fi,&fj);
        if(si == fi && sj == fj) { printf("0\n"); continue;}
        bfs(bi,bj,si,sj,4); spfa(si,sj); ans = 999999;
        for(i=0;i<4;i++) ans = min(ans,sdis[fi*30*4+fj*4+i]);
        if(ans<999999) printf("%d\n",ans);
        else printf("-1\n");
    }
    return 0;
}

```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P1979)

---


# 思路：

发现显然应该是要预处理什么东西然后对于每组询问再做。然后发现其实这个游戏就是用空格铺路让棋子按照合法的最短距离一步一步走。

手玩一下可以发现先按照最短距离将空格移动到初始位置之后就可以开始移动了。发现如果要移动一个棋子到一个方向就需要在不移动原棋子的情况下移动空格。

之后就可以写一个移动的函数了，用宽搜 $f(cx,cy,sx,sy,ex,ey)$ 表示空格一开始在 $(sx,sy)$，在不经过 $(cx,cy)$ 时移动到 $(ex,ey)$ 的最短步数。

但是如果我们预处理出所有的 $f$ 就可以以它为边权跑最短路就可以了。但是发现预处理的时间复杂度是 $O(n^8)$ 的，无法接受。

观察到其实每一次的移动除了一开始移动空格到起点四周外只会在四个方向动。于是通过跑 $f()$ 来算新的 $v(x,y,a,b)$，其中 $a,b\in[0,4)$ 表示四个方向。这样我们可以通过 $T(16n^4)$ 的方法求助这个棋盘移动任意一个位置的步数。

发现对于每一组询问跑最短路即可。但是对于状态我设置的与普通最短路略有不同，设了 $d(x,y,a),a\in[0,4)$ 表示目前在 $(x,y)$，空格在 $(x,y)$ 的 $a$ 方向时的最短步数即可。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e2+10;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int n,m,Q,dx[]={0,0,1,-1},dy[]={1,-1,0,0},val[N][N][4][4],dis[N][N][4],ex,ey,sx,sy,tx,ty;
bool vs[N][N][4],gd[N][N],vis[N][N];
bool cg(int x,int y){
	return x>0&&x<=n&&y>0&&y<=m&&gd[x][y];
}
struct node{
	int x,y,tm;
};
int bfs(int cx,int cy,int sx,int sy,int ex,int ey){
	queue<node>q;
	memset(vis,false,sizeof vis);
	q.push({sx,sy,0});
	vis[sx][sy]=true;
	if(sx==cx&&sy==cy){
		return 1e9;
	}
	while(!q.empty()){
		int x=q.front().x,y=q.front().y,tm=q.front().tm;
		q.pop();
		if(x==ex&&y==ey){
			return tm;
		}
		for(int i=0;i<4;i++){
			int u=x+dx[i],v=y+dy[i];
			if(cg(u,v)&&!vis[u][v]&&!(u==cx&&v==cy)){
				vis[u][v]=true;
				q.push({u,v,tm+1});
			}
		}
	}
	return 1e9;
}
struct node1{
	int qx,qy,lst,tm;
	bool operator<(const node1&K)const{
        if(tm==K.tm){
            if(qx==K.qx){
                if(qy==K.qy){
                    return lst<K.lst;
                }
                return qy<K.qy;
            }
            return qx<K.qx;
        }
		return tm>K.tm;
	}
};
void dijkstra(int ex,int ey,int sx,int sy,int tx,int ty){
	priority_queue<node1>pq;
	memset(vs,false,sizeof vs);
	memset(dis,0x3f,sizeof dis);
	for(int i=0;i<4;i++){
		int u=sx+dx[i],v=sy+dy[i];
		if(!cg(u,v)){
			continue;
		}
		int w=bfs(sx,sy,ex,ey,u,v);
		if(w>=1e8){
			continue;
		}
		pq.push({sx,sy,i,w});
		dis[sx][sy][i]=w;
	}
	while(!pq.empty()){
		node1 sta=pq.top();
		pq.pop();
		int x=sta.qx,y=sta.qy,lst=sta.lst;
		if(vs[x][y][lst]){
			continue;
		}
		vs[x][y][lst]=true;
		for(int i=0;i<4;i++){
			int u=x+dx[i],v=y+dy[i],w=val[x][y][lst][i],nlst;
			if(w>1e8){
				continue;
			}
			if(i==0){
				nlst=1;
			}else if(i==1){
				nlst=0;
			}else if(i==2){
				nlst=3;
			}else{
				nlst=2;
			}
			if(dis[x][y][lst]+w+1<dis[u][v][nlst]){
				dis[u][v][nlst]=dis[x][y][lst]+w+1;
				pq.push({u,v,nlst,dis[u][v][nlst]});
			}
		}
	}
}
signed main(){
	cin>>n>>m>>Q;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>gd[i][j];
		}
	}
	memset(val,0x3f,sizeof val);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!cg(i,j)){
				continue;
			}
			for(int k=0;k<4;k++){
				int x=i+dx[k],y=j+dy[k];
				if(!cg(x,y)){
					continue;
				}
				for(int l=0;l<4;l++){
					if(k==l){
						val[i][j][k][l]=0;
						continue;
					}
					int u=i+dx[l],v=j+dy[l];
					if(!cg(u,v)){
						continue;
					}
					val[i][j][k][l]=bfs(i,j,x,y,u,v);
				}
			}
		}
	}
	while(Q--){
		cin>>ex>>ey>>sx>>sy>>tx>>ty;
		if(sx==tx&&sy==ty){
			cout<<0<<endl;
			continue;
		}
		if(!cg(sx,sy)||!cg(tx,ty)){
			cout<<-1<<endl;
			continue;
		}
		dijkstra(ex,ey,sx,sy,tx,ty);
        int ans=min({dis[tx][ty][0],dis[tx][ty][1],dis[tx][ty][2],dis[tx][ty][3]});
		if(ans>1e8){
			cout<<-1<<endl;
		}else{
			cout<<ans<<endl;
		}
	}
	return 0;
}
```
完结撒花~

---

## 作者：PDAST (赞：0)

学校模拟赛出了这道题，赛时写的 bfs 一直 TLE，~~卡常卡了半小时~~。
## 思路
### 思路一
发现数据范围很小，容易想到广搜，我们发现虽然复杂度没超，但是一旦有常数，就过不了后面的测试点，所以尽量在无法开 O2 时使用数组模拟队列并使用快读，如果还是不行可以试着将循环展开，一定记得要把所有状态标记防止重复搜索，代码比较简单，相信大家都会打，就不放了，最坏复杂度应该是四次方级的。
### 思路二
机房大佬讲的，先 bfs 将空白格移到起点格旁边，再将空白格相对于起点格的位置以及起点格的位置作为一个点存状态,再将状态之间连边，使用 dijkstra 或者其他复杂度较低的跑一遍最短路，选取空白格在起点格附近的状态到空白格在终点格附近的状态，输出就行了，一定要事先估计好数据量，防止空间超限，代码楼下大佬也讲了，我就不再赘述了。

---


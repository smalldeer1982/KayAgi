# [NOIP 2017 提高组] 宝藏

## 题目背景

NOIP2017 D2T2

## 题目描述

参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。

小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。

小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。

在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。

新开发一条道路的代价是 $\mathrm{L} \times \mathrm{K}$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。

请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/10868.png) 

【样例解释 $1$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。还开发了道路 $4 \to 3$，挖掘了 $3$ 号宝藏。

工程总代价为 $1 \times 1 + 1 \times 1 + 1 \times 2  = 4 $。

【样例解释 $2$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 3$，挖掘了 $3$ 号宝藏。还开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。

工程总代价为 $1 \times 1 + 3 \times 1 + 1 \times 1  = 5$。


【数据规模与约定】

对于 $ 20\%$ 的数据： 保证输入是一棵树，$1 \le n \le 8$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $40\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $ 70\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le  5\times 10^3$。

对于 $ 100\%$ 的数据： $1 \le n \le 12$，$0 \le m \le 10^3$，$v \le  5\times 10^5$。

---

$\text{upd 2022.7.27}$：新增加 $50$ 组 Hack 数据。

## 样例 #1

### 输入

```
4 5
1 2 1
1 3 3
1 4 1
2 3 4
3 4 1```

### 输出

```
4```

## 样例 #2

### 输入

```
4 5
1 2 1
1 3 3
1 4 1
2 3 4
3 4 2```

### 输出

```
5```

# 题解

## 作者：FlashHu (赞：66)

Dalao的题解多数是什么模拟退火、DFS剪枝、$O(3^nn^2)$的状压DP之类。蒟蒻尝试着把状压改进了一下使复杂度降到$O(3^nn)$。

考虑到每条边的贡献跟它所在的层有关，所以如果我们能够将一层的边一起加进去，计算就会方便许多。于是想办法把这个转移过程状压一下。

设$f_{i,j}$为当前已选点集为$i$，下一层加入的点集为$j$时，新加入的所有点与原有点之间最小的边权之和。计算的具体实现，我们$O(2^n)$枚举$i$，再枚举$i$的补集的子集$j$，把$j$的$lowbit$挑出来，$f_{i,j}$等于$f_{i,j-lowbit(j)}$加上$\log lowbit(j)$与$i$之间的最小边权。

这一部分的复杂度是$O(3^nn)$（$n$元素集合的所有子集的子集大小之和是$3^n$可以证）

接着就可以开始转移了。设$g_{l,i}$为总层数为$l$，已选点集为$i$的最小答案。参考$f$的定义我们可以很快的写出转移方程（式中的$i-j$为集合意义，代码中写`i^j`）

$$g_{l,i}=\sum\limits_{j\in i}g_{l-1,i-j}+l*f_{i-j,j}$$

也是一遍枚举子集，复杂度还是$O(3^nn)$。最后$\max\limits_{l=0}^ng_{l,2^n-1}$就是答案。

当然，为了实际复杂度和理论一致，我们枚举子集不能这样暴枚
```cpp
	for(i=0;i<=S;++i)
    	if(i&S)//do something
```
而应该这样
```cpp
	for(i=S;i;i=(i-1)&S)
    	//do something
```
跟队爷Anson学的，具体原理蒟蒻也策不清楚啊qwq

代码十分简洁，注意INF的设置
```cpp
#include<bits/stdc++.h>
#define R register int
using namespace std;
const int N=13,M=4096,INF=0x01010101;
int a[N][N],f[M][M],g[N][M],ne[M],lg[M];
inline void chkmn(R&x,R y){
	if(x>y)x=y;
}
int main(){
	memset(a,1,sizeof(a));
	memset(g,63,sizeof(g));//貌似需要区别对待
	R n,m,S,s,i,j,l,x,y,v;
	cin>>n>>m;
	S=(1<<n)-1;
	for(i=0;i<n;++i)
		lg[1<<i]=i;//log预处理
	while(m--){
		cin>>x>>y>>v;
		if(a[--x][--y]>v)//邻接矩阵存边
			a[x][y]=a[y][x]=v;
	}
	for(i=1;i<=S;++i){
		v=0;
		for(j=s=S^i;j;j=(j-1)&s)
			ne[j]=v,v=j;//为了更新顺序需要反向枚举
		for(j=v;j;j=ne[j]){
			x=lg[j&-j];v=INF;
			for(y=0;y<n;++y)//找到可以连接的最小边权
				if(1<<y&i)chkmn(v,a[x][y]);
			f[i][j]=f[i][j^(j&-j)]+v;
		}
	}
	for(i=1;i<=S;i<<=1)
		g[0][i]=0;//状态预处理
	for(l=1;l<n;++l)
		for(i=1;i<=S;++i)
			for(j=i;j;j=(j-1)&i)
				chkmn(g[l][i],g[l-1][i^j]+f[i^j][j]*l);
	v=0x7fffffff;
	for(l=0;l<=n;++l)
		chkmn(v,g[l][S]);
	cout<<v<<endl;
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：40)

前置：状压 dp。

# 思路分析

首先注意到数据规模：$n\le 12$。显然可以依据此设计指数级算法。

显然**最后拓展的道路和藏宝室构成一棵有根树**，根节点为最先确定的藏宝室；如果最终答案不是树，就会出现环，我们可以将环上任意一条边去掉，均可以得到一个代价更小的方案。

我们考虑这样的一个过程：枚举最先打通的是那个藏宝室，将这个节点作为一棵树，然后不断加入新的节点，统计答案。

假定我们最终确定的方案中含有边 $(x,y)$（在树中 $x$ 是 $y$ 的父亲），根据题意，扩展这条道路的代价与两个因素有关：

- $x$ 的在树中的深度。

- $(x,y)$ 的长度，下文记为 $w(x,y)$。

记连接这棵树深度为 $i$ 和深度为 $i+1$ 的节点构成的边集为 $D_i$，则扩展这些边的总代价为 $i\times \sum_{(u,v)\in D_i}w(u,v)$。

通过上面的思考，可以发现，对于这些边，可以按照“深度”划分为若干个集合。据此启发，可以以“**当前树的深度”为阶段，“已经有哪些点加入到了树中”为附加的状态**来设计 dp。

设 $dp_{i,S}$ 表示树的深度为 $i$，且点集 $S$ 中的点均已加入这棵树，在此基础上代价的最小值。我们可以从第 $i$ 层拓展到第 $i+1$ 层，且 $i+1$ 层新加入了节点构成的点集为 $T$。

可以列出转移方程：

$$\large{dp_{i+1,S\cup T}\gets dp_{i,S}+i\times \text{cost}(S,T)}$$

$\text{cost(S,T)}$ 只考虑 $w(x,y)$，最小的能将 $T$ 中的节点与 $S$ 中节点相连的打通道路的方案的代价

转移的前提是：$S\cap T=\varnothing$，即 $S,T$ 无交。目标状态：当 $S=\{1,2,\dots,n\}$ 时，$dp_{k,S}$ 的 $\min$。

这个转移方程的实际含义：枚举第 $i+1$ 层节点 $T$ 和前 $i$ 层节点 $S$，然后将他们产生的代价和累加的前 $i$ 层的答案上。

## 注意到一个问题

$S$ 表示前 $i$ 层的节点，$T$ 表示第 $i+1$ 层的节点，怎样保证 $T$ 中所连接的节点都是第 $i$ 层的节点？如果 $S$ 中还包含 $i-1,i-2$ 层的节点，而计算花费时，却将 $T$ 和 $i-1,i-2$ 层的节点连接，并因此计算出错误的代价，这种情况如何避免？

在写这题时，这个问题也曾困扰过我。在蓝书中，有这样一句话让我恍然大悟。我们思考，假如 $\text{cost}(S,T)$ 计算的花费是不合法的花费，那么 $dp_{i+1,S\cup T}$ 会将 $dp_{i,S}$ 作为最优决策吗？

答案是否定的的，因为这样的转移会导致算得的答案比正确的 dp 值偏大，而正确的方案一定可以转移到，从而把错误的更新。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/ehrvzt0b.png)

记最后的树的形态如上图，则当 $S=\{1,2,3,4\},T=\{5,6\}$ 时，则计算的总费用为：
$$w(1,2)+w(1,3)+w(2,4)\times 2+w(2,5)\times {\color{Red}3}+w(4,6)\times 3$$

但当 $S'=\{1,2,3,4,5\},T'=\{6\}$，此时计算的总费用为：

$$w(1,2)+w(1,3)+w(2,4)\times 2+w(2,5)\times {\color{Red}2}+w(4,6)\times 3$$

容易发现 $dp_{3,S},T$ 和 $dp_{3,S'},T'$ 这两种组合均可以更新出 $dp_{4,S\cup T}$，且后者的转移一定会比前者更优。所以不合法的转移一定对最终的答案没有影响。

# Code

关于代码实现：

关于集合的运算可以用状压。

显然 $\text{cost}(S,T)$ 可以通过预处理实现，借助子集枚举的技巧，可以做到 $O(3^n)$ 枚举集合并枚举其子集，预处理时间复杂度 $O(3^n)$。虽然题目给出的边数很多，但可以用链接矩阵保留有用的边。

dp 部分，枚举初始点，枚举层数均为 $O(n)$，枚举状态并转移可以做到 $O(3^n)$，总时间复杂度 $O(n^23^n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int M=(1<<12),inf=0x3f3f3f3f;
int cost[M][M],n,m,c[12][12];
long long dp[12][M],ans=inf;
void init(){
	for(int i=1;i<(1<<n);i++){
		for(int j=i;j;j=(j-1)&i){
			if(j==i)continue;
			for(int t=0,tmp;t<n;t++,tmp=inf){
				if(!(((i^j)>>t)&1))continue;
				for(int l=0;l<n;l++)if((j>>l)&1)tmp=min(tmp,c[l][t]);
				if(tmp>=inf){cost[j][i]=inf;break;}
                else cost[j][i]+=tmp;
			}
		}
	}
	return;
}
long long DP(int x){
    for(int i=0;i<12;i++)for(int j=0;j<M;j++)dp[i][j]=inf;//dp值取min,所以先清空
	dp[0][1<<x]=0;
	long long res=inf;
	for(int i=1;i<n;i++){
		for(int j=1;j<(1<<n);j++){
			for(int k=j;k;k=(k-1)&j){//枚举前i-1层的k和第i层的j
				if(k==j)continue;
				dp[i][j]=min(dp[i][j],dp[i-1][k]+1ll*i*cost[k][j]);
			}
			if(j==(1<<n)-1)res=min(res,dp[i][j]);
		}
	}
	return res;
}
int main(){
	scanf("%d %d",&n,&m);
	if(n==1){
		printf("0\n");
		return 0;
	}
	for(int i=0;i<n;i++)for(int j=0;j<n;j++)c[i][j]=inf;
	for(int i=1,u,v,w;i<=m;i++){
		scanf("%d %d %d",&u,&v,&w),u--,v--;
		c[v][u]=c[u][v]=min(c[u][v],w);
	}
	init();
	for(int i=0;i<n;i++)ans=min(ans,DP(i));
	printf("%lld\n",ans);
	return 0;
}
```

如有错误，请指出。

---

## 作者：nekko (赞：26)

设 $f_{i,j,S}$ 表示从 $i$ 开始打通集合 $S$，且 $i$ 的深度为 $j$ 时的最小代价

显然有：

$$f_{i,j,S}=\min\limits_{(i,k,w) \in E \wedge k \not\in T \subseteq S}f_{k,j+1,T}+f_{i,j,S-T-\{k\}}+w \times j$$

注意一开始的边比较多，可以用邻接矩阵来存图

``` cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f, N = 15;
int a[N][N], n, m, f[N][N][1 << N], vis[N][N][1 << N];

int to(int x) { return 1 << (x - 1); }

int dfs(int u, int dep, int S) {
	int &x = f[u][dep][S]; if(vis[u][dep][S]) return x; vis[u][dep][S] = 1; if(!S) return x = 0; x = inf;
	for(int v = 1 ; v <= n ; ++ v)
		if(a[u][v] != inf && (S & to(v)))
			for(int T = S ; T ; T = (T - 1) & S)
				if(T & to(v))
					x = min(x, dfs(v, dep + 1, T - to(v)) + dfs(u, dep, S - T) + dep * a[u][v]);
	return x;
}

int main() {
	memset(a, 0x3f, sizeof a);
	scanf("%d%d", &n, &m);
	for(int i = 1, u, v, w ; i <= m ; ++ i) scanf("%d%d%d", &u, &v, &w), a[u][v] = a[v][u] = min(a[u][v], w);
	int ans = inf;
	int all = to(n + 1) - 1;
	for(int i = 1 ; i <= n ; ++ i) ans = min(ans, dfs(i, 1, all - to(i)));
	printf("%d\n", ans);
}
```

---

## 作者：轮回之终末 (赞：17)

官方数据出来了，重新调参后AC的模拟退火。

根据题目可以发现，每一条边都对最后的答案有影响。

考虑到答案比较连续，可以考虑模拟退火。

首先要枚举起点，每次先用prim/bfs贪心找近似解，再进行n次退火。

记b[i]为i号节点是从哪一个节点上转移过来的，每次随机调整一个节点的先置节点，O（n）计算答案。

调参比较玄学。

ps：我srand了10十个数，只有一个过了，而且这个数……

ps：考场得分95，被卡了一个点。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=110;
const int maxm=2010;
int mp[maxn][maxn],n,m,i,j,k,x,y,z,ans,s;
int a[maxn],b[maxn],c[maxn],ha[maxn],oldf,newf,vis[maxn];
double T;
int read(){
    int tot=0,fh=1;
    char c=getchar();
    while((c-'0'<0)||(c-'0'>9)){if(c=='-')fh=-1;c=getchar();}
    while((c-'0'>=0)&&(c-'0'<=9)){tot=tot*10+c-'0';c=getchar();}
    return tot*fh;
}
int dfs(int x,int dep){
    if (dep>13) return 0;
    if (x!=s){vis[x]=dfs(c[x],dep+1);return vis[x];}
    else return 1;
}
int check(){
    int i;
    memset(vis,0,sizeof(vis));
    for (i=1;i<=n;i++){
        if (vis[i]==0) vis[i]=dfs(i,1);
        if (vis[i]==0) return 0;
    }
    return 1;
}
int dfs2(int x){
    if ((s==x)||(vis[x]!=0)) return vis[x];
    int t1=dfs2(c[x])+1;
    vis[x]=t1;
    newf=newf+t1*mp[c[x]][x];
    return t1;
}
void getnewf(){
    int i;
    newf=0;
    memset(vis,0,sizeof(vis));
    for (i=1;i<=n;i++){
        if (vis[i]==0) dfs2(i);
    }
}
void bfs(int x){
    int l=1,r=1,i; a[l]=x; oldf=0; b[x]=0;
    memset(ha,-1,sizeof(ha)); ha[x]=0;
    while (l<=r){
        for (i=1;i<=n;i++){
            if ((ha[i]==-1)&&(mp[a[l]][i]!=1e9)){
                ha[i]=ha[a[l]]+1;
                r++; a[r]=i;
                b[i]=a[l];
                oldf=oldf+mp[a[l]][i]*ha[i];
            }
        }
        l++;
    }
    ans=min(ans,oldf);
}
int main(){
    n=read(); m=read();
    for (i=1;i<=n;i++){
        for (j=1;j<=n;j++){
            if (i==j) mp[i][j]=0;
            else mp[i][j]=1e9;
        }
    }
    for (i=1;i<=m;i++){
        x=read(); y=read(); z=read();
        mp[x][y]=min(mp[x][y],z);
        mp[y][x]=min(mp[y][x],z);
    }
    ans=1e9;
    srand(19260817);
    for (i=1;i<=n;i++){
        s=i; bfs(i);
        if (n<=2) continue;
        for (T=10000;T>=0.00001;T=T*0.9999){
            x=(rand()%(n-1))+1; if (x>=i) x++;
            y=(rand()%(n-1))+1;
            if (y>=x) y++;
            if (mp[x][y]==1e9) continue;
            for (j=1;j<=n;j++) c[j]=b[j];
            c[x]=y;
            if (check()==0) continue;
            getnewf();
            if ((newf<=oldf)||( exp((oldf-newf)/T))>=((rand()%1000000)/1000000.0) ){
                ans=min(ans,newf);
                for (j=1;j<=n;j++) b[j]=c[j];
                oldf=newf;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：HenryHuang (赞：9)

 [博客阅读效果更佳](https://www.cnblogs.com/HenryHuang-Never-Settle/p/11529900.html)

----

又到了一年一度~~NOIP~~CSP-S 赛前复习做真题的时间

于是就遇上了这道题

---

首先观察数据范围 $1 \le n \le 12$ ,那么极大可能性是状压 $\texttt{DP}$ 或者 $\texttt{DFS}$ 爆搜

但由于这题放在了 $\texttt{DP}$ 列表里面，于是优先考虑状压

简化题意：

> 从给定的 $n$ 个点，$m$ 条边的**有重边的**无向联通图中，找出一棵生成树，使得题目所求价值最小

从题目给出的建边价值来看，我们发现一条边的价值跟以下几点有关：

* 根的位置
* 当前状态下的树的高度
* 该边的长度

边的长度不能改变，根的位置并不能很好的作为 $\texttt{DP}$ 时候的阶段，所以我们考虑以树的高度作为DP的阶段

设根的深度为1

设  $\texttt{f[i][j]}$ 表示 当前树的高度为 $i$ ,已经选了的点集的集合为 $j$,那么状态转移方程即为
$$
f[i][j]=\min_{k\  \in \ j}(f[i-1][j \ \mathrm{xor} \ k]+dis[j \ \mathrm{xor} \ k][k]\cdot(i-1))
$$
其中异或操作在这里是取补集的意思，$\texttt{dis[i][j]}$ 表示从 $i$ 这个已选点集加上下一层将要选的 $j$ 这个点集所需要的最小花费

那我们应该如何完善 $\texttt{dis}$ 数组呢

先给出递推式
$$
dis[i][j]=dis[i][j \ \mathrm{xor} \ \mathrm{lowbit}(j)]+\min_{k=1}^{n\ \&\& \ (1<<k)\&i}(d[\log_2\mathrm{lowbit}(j)+1][k])
$$
其中 $d$ 数组表示第 $i$ 个点到 第 $j$ 个点的道路长度（没有则为 $\infty$ ），$j$ 为 $i$ 的补集的任一子集

然后从小到大枚举 $j$ ，就能够保证顺序正确（因为 $j \ \mathrm{xor} \ \mathrm{lowbit}(j)$ 一定比 $j$ 要小）

因为每一次更新只涉及到一个点的更改，所以不难得出这样预处理 $dis$ 数组的正确性

然后，这题就完了

另外还有几点需要注意的

* 边最好使用邻接矩阵储存，因为有重边，而且请不要将初值赋得太大，这样会导致在进行动态规划求解的同时溢出，从而导致答案错误

* 如果按照上面那种朴素的做法来进行求解复杂度有可能不能承受，观察发现我们枚举了许多不必要的子集，所以我们可以换一个方式：

  ```cpp
  for(int i=S;i;i=(i-1)&S)
  ```

  这样的话所有的 $i$ 就一定是 $S$ 的子集

  蒟蒻的理解：不等于 $S$ 的 $S$ 的子集一定在 $[0,S)$ 中

  然后或运算可以求出在这当中**十进制下数字最大的子集** ,设其为 $P$,然后其余所有的十进制表示比他小的子集都在$[0,P)$ 当中，如此循环求解，自然能够得到所有的子集

* 关于状态的一点点优化

  容易发现，当树高为 $i$ 时，至少需要 $i$ 个节点，所以所有状态中点的个数小于 $i$ 的（即二进制位上 $1$ 的个数小于 $i$ 的），全部可以不用枚举子集，直接跳过，这对时间复杂度又有了进一步的~~常数~~优化。 这可以通过预处理得到。

最后贴一下代码，变量名与上面提到的略有不同

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=12;
int d[maxn+5][maxn+5];
int g[maxn+5][(1<<maxn)+5];
int f[(1<<maxn)+5][(1<<maxn)+5];
int lg[(1<<maxn)+5];//懒 
int q[(1<<maxn)+5],cnt;
int sum[(1<<maxn)+5];
int main()
{
	memset(g,63,sizeof g);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=0;i<n;++i)
		lg[1<<i]=i;//预处理，因为懒
	for(int i=0;i<12;++i)
		for(int j=0;j<12;++j)
			d[i][j]=1000000;//赋最大值
	for(int i=1;i<=m;++i)
	{
		int a,b,c;
		cin>>a>>b>>c;
		--a,--b,d[a][b]=d[b][a]=min(d[a][b],c); 
	}
	int x,S=(1<<n)-1;//全集定义
	for(int i=1;i<=S;++i)
	{
		x=i;
		while(x) x&=(x-1),++sum[i];
	}//预处理每一个状态上点的个数
	for(int i=1;i<=S;++i)
	{
		cnt=0;
		for(int j=S^i;j;j=(j-1)&(S^i)) q[++cnt]=j;//由于这样做子集的顺序是从大到小的，不符合DP的顺序，所以要逆序 
		for(int j=cnt;j>=1;--j)
		{
			int u=lg[q[j]&-q[j]],e=1000000;
			for(int v=0;v<n;++v)
				if(1<<v&i) e=min(d[u][v],e);
			f[i][q[j]]=f[i][q[j]^(q[j]&-q[j])]+e;
		}
	}
	for(int i=0;i<n;++i) g[1][1<<i]=0;//初始状态
	for(int i=2;i<=n;++i)
		for(int j=(1<<i)-1;j<=S;++j)//剪枝，这里i的初始状态跳过了肯定不符合的状态
		{
			if(sum[j]<i) continue;//剪枝，不满足直接跳过
			for(int k=j;k;k=(k-1)&j)
				g[i][j]=min(g[i][j],g[i-1][j^k]+f[j^k][k]*(i-1));
		}
		int ans=(1<<30);
	for(int i=1;i<=n;++i) ans=min(ans,g[i][S]);//取最小值
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：w9095 (赞：7)

[P3959 [NOIP2017 提高组] 宝藏](https://www.luogu.com.cn/problem/P3959)

不难发现最后的路径一定会构成一棵树。由于每条路的贡献与与其深度有关，故考虑设计与深度有关的状态。由于数据范围很小，考虑状态压缩 DP，每次扩展一层。

设状态 $f[i][j]$ 表示目前扩展到第 $i$ 层，所有节点的状态为 $j$。若第 $k$ 位为 $1$，则表示节点 $k$ 已经被打通；若第 $k$ 位为 $0$，则表示节点 $k$ 未被打通。记状态 $k$ 转移到状态 $j$ 经过的边权之和为 $cost(k,j)$，不难得到如下转移方程：

$$f[i][j]=\min(f[i][j],f[i-1][k]+cost(k,j)\times(i-1))$$

接下来，考虑预处理出两个数组 $cost(k,j)$ 与 $pos(k,j)$，表示状态 $k$ 转移到状态 $j$ 经过的边权之和为 $cost(k,j)$ 与可行性。再预处理一个数组 $ex(i)$，表示状态 $i$ 可以扩展的所有点(包括原有点)的状态集合。若第 $k$ 位为 $1$，则表示节点 $k$ 可以被扩展；若第 $k$ 位为 $0$，则表示节点 $k$ 不可以被扩展。

$ex(i)$ 并不难预处理，只需要枚举已有节点的每一条边，能扩展到的标记为 $1$ 即可。有了 $ex(i)$ 后，我们发现 $pos(k,j)$ 也不难预处理。当且仅当 $k$ 是 $j$ 的子集且 $j$ 是 $ex(k)$ 的子集时，$pos(k,j)=1$。判断子集可以用位运算来实现，若 $j\&k=k$，则 $k$ 是 $j$ 的子集。

接下来，考虑求出满足 $pos(k,j)$ 的 $cost(k,j)$。考虑枚举状态 $j$ 中未扩展的点，枚举从 $k$ 中的点到这一个点的边，取边权最小值为贡献。最后，将每一个未扩展的点的贡献加和，即为 $cost(k,j)$。预处理之后，转移也比较显然。

时间复杂度为 $O(m2^{n}+n3^n)$，其中 $3^n$ 是枚举子集的时间复杂度。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,u,v,d,h[30000],ex[5000],cst[5000][5000],f[20][5000],ans=1e9;
vector<int>to[20],dis[20];
bool pos[5000][5000];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	    {
	    	scanf("%d%d%d",&u,&v,&d);
	    	to[u].push_back(v),dis[u].push_back(d);
	    	to[v].push_back(u),dis[v].push_back(d);
		}
	for(int i=0;i<=(1<<n)-1;i++)
	    {
	    	ex[i]=i;
	    	for(int j=0;j<n;j++)
	    	    if(i&(1<<j))
	    	       {
	    	       int s=to[j+1].size();
	    	       for(int k=0;k<s;k++)ex[i]|=(1<<(to[j+1][k]-1));
	    	       }
		}
	for(int i=0;i<=(1<<n)-1;i++)
	    for(int j=0;j<=(1<<n)-1;j++)
	        if((j|ex[i])==ex[i]&&(i|j)==j&&i!=j)
	           {
	           	pos[i][j]=1;
	           	for(int k=0;k<n;k++)
	           	    if(!(i&(1<<k))&&(j&(1<<k)))
		           	    {
		    	        int mi=1e9,s=to[k+1].size();
		    	        for(int l=0;l<s;l++)
						    if((i&(1<<(to[k+1][l]-1))))mi=min(mi,dis[k+1][l]);
						cst[i][j]+=mi;
						}
			   }
	for(int i=0;i<=n;i++)
	    for(int j=0;j<=(1<<n)-1;j++)
	        f[i][j]=1e9;
	for(int i=1;i<=n;i++)
	    f[0][(1<<(i-1))]=0;
	for(int i=1;i<=n;i++)
	    for(int j=0;j<=(1<<n)-1;j++)
	        for(int k=0;k<=(1<<n)-1;k++)
	            if(pos[k][j]&&f[i-1][k]!=1e9)f[i][j]=min(f[i][j],f[i-1][k]+cst[k][j]*i);
	for(int i=0;i<=n;i++)ans=min(ans,f[i][(1<<n)-1]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Coding的二营长 (赞：6)

# 第一篇题解纪念！

这题给人第一反应肯定是往图论方面想
然而“爆搜大法好”
我们变换一下思路，这只是一个需要标准深搜模板以及几个if来剪枝的搜索题！

首先，小明只会开凿可以使各个宝藏点联通的最少条路径，所以最后这个图将会是一棵树，而深搜图形化后也是一棵树，所以顺理成章的想到深搜（雾。

以此为依据，我们可以用深搜一步一步构建树，每个不同形态的树必有一个总代价，枚举树的构成形态即可枚举不同的总代价，各个总代价的最小值就是答案。

### 如何去一步步构建树呢？

我们可以按层来讨论

每层都对所有点讨论，讨论是否把这个点放在该层

分析题目后我们会发现，每增加一个点，这棵树的分数是：
前面已经得到的分数+该点连接上一层的点的边的权值 × 该层层数，所以分数会随着点的加入而线性增长，且增加的分数不与前面层的点的结构有关

这样，我们就可以用贪心的思想，我们总希望边新加的分数最小，这样总分数才会小，所以对于要讨论的一个点，我们找到他与上层的最小距离，即他与上层点（无论哪个）的最小边（如果有），即是他加入这棵树后，与上层连接的点；

而对于这棵树，我们只用在乎他的得分多少，并不会在乎每层的详细结构。因为影响树的分数的因素只有：在一步一步构建树的过程中，新加入的点与上一层的点相连的边的边权，我们可以直接理解成这个点与上一层的距离

所以，在构建一棵树的时候，我们只需要记录他不断增加的得分，对于其结构，只需要知道每一层有哪些点，顺序如何，而不需要记录具体的点边相连状况


### 以此得出大致搜索思路

枚举每一层，每一层都枚举每个点是否放入该层

当所有点都构建进了树中，树的可能形态其一就构建完成

枚举每一种可能的树的形态，然后讨论得分最小值


**总的来说
搜的是树的每种可能状态
由于每点加分满足不被前态影响
所以我们用枚举每个点的方式一步步构建出树，并在这过程中得出这种可能树的得分
最后所有树的形态都列出过，所有可能的总得分也都求过了
求个最小值OK**


AC代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int INF=1000000;
int map[15][15];
int n,m;
int lay[15][15];//每层第i个是哪个点
int nlay[15];//每层多少个点
bool used[15];//每个点是否被用过
int ans=INF;


void dfs(int ceng,int k,int cnt,int sum)//现在是在第ceng层，在讨论编号是k的点，总共用了cnt个点，现在这棵树价值sum
{
	if(sum>=ans)return ;//最优性剪枝   ！！！最重要！！！只要现阶段的得分已经不是最小的了就没有继续的必要了
	
	if(nlay[ceng-1]==0)return ;//上一层没有选入点（上层为空），树不可能继续构建，该可能不合法，直接跳过
	
	if(cnt==n)
	{
		ans=sum<ans?sum:ans;//所有点都已经被构建进树中，比对答案
		return ;//结束这种可能
	}
	
	
	if(k>n)
	{
	
	dfs(ceng+1,1,cnt,sum);//该层所有点都讨论过一遍，继续下一层
	return ;
	}
	
	if(used[k]==1)
	{
	dfs(ceng,k+1,cnt,sum);//该点已用，直接讨论下一个点
	return ;
	}
	if(used[k]==0)//该点没用过，讨论一下
	{
		used[k]=1;
		int mini=INF;//找到该点与上层的最小联系
		for(int i=1;i<=nlay[ceng-1];i++)//若没有联系（即与上层所有点不连通），则mini是INF,会被最优性剪枝减去
		{
			if(map[k][lay[ceng-1][i]]<mini)mini=map[k][lay[ceng-1][i]];
		}
		nlay[ceng]++;//这层又多一个点啦
		lay[ceng][nlay[ceng]]=k;//这点是哪个？存在   lay[哪层][第几个]   中
		dfs(ceng,k+1,cnt+1,sum+mini*ceng);//选用此点（可能1）
		nlay[ceng]--;
		used[k]=0;
		dfs(ceng,k+1,cnt,sum);//不用此点（可能2）
		
	}
	
}

















int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)map[i][j]=INF;//数组初始化

for(int i=1;i<=m;i++)
{
int a,b,c;
cin>>a>>b>>c;

if(c<map[a][b])map[a][b]=map[b][a]=c;//无向图双向赋值
}

for(int i=1;i<=n;i++)//每个点都当一次根
{
used[i]=1;//点已用
lay[0][1]=i;//根看做第0层
nlay[0]=1;//0层有一个根节点
dfs(1,1,1,0);//从第一层开始搜索
used[i]=0;//以该点为根的数搜索完毕



}

cout<<ans;


return 0;
}
//感谢julao zzk      ORZ
```


---

## 作者：bianshiyang (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P3959)

本题解参考《算法竞赛进阶指南》的做法，完善了一些书中不易懂的部分。另外发现题解区 $3$ 进制状压 DP 的做法几乎没有，于是本蒟蒻补了一篇，其实两种做法都写啦~（~~所以篇幅长，大佬们体谅一下~~）。

在题解之前先强调一个事实，以免有些读者会有点懵，对于任意一个数 $x$ 的 $k$ 进制都是从第 $0$ 位开始存储，而本题中点的编号从 $1$ 开始，所以 $x$ 的第 $y$ 位的信息实际上表示的是节点 $y+1$ 的信息。

# 分析
首先关注到题目中一句很重要的话：

> 另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。

这句话告诉我们最终形成的**连通图不存在环**，即它是一棵**树**（之所以是连通图是因为题目要求最小代价意味一定有解，即一定连通）。我们可以把赞助商帮小明打通的宝藏屋作为树根，一个简单的想法就是直接 DFS 枚举所有可能求解答案，但是肯定会超时。

这时候考虑剪枝：

1. 因为对于每一个特定的树形图（根一定的情况下），对于每一个遍历到的节点，到此节点的代价只由路径权值大小和节点深度决定，这意味着代价与遍历到这个点的时间无关。换句话讲，我们可以先遍历浅的节点，再考虑深的（即按层遍历）。

2. 对于已经遍历到的节点集合 $S$，若要新加入节点，那么代价只与 $S$ 的轮廓有关，而与其如何形成无关。

此处引用蓝书上一段话来说明为什么这道题可以考虑状压 DP 的解法：

> 不难观察到，第一点限制从浅到深形成了动态规划的“阶段”，而第二点限制正是动态规划的“最优子结构”性质。为了把“集合”作为动态规划的“状态”，可以采取状态压缩的方法。这启发我们使用状态压缩动态规划算法解决本题。

# 解法一：二进制状压
首先容易想到一个朴素状压 DP，即用 $f_{i,j,k}$ 表示已经扩展了的最大深度为 $i$，第 $i$ 层状态为 $j$，第 $i-1$ 层状态为 $k$ 的情形下，取得的最小代价（这里的 $j$ 和 $k$ 都是二进制，第 $x$ 位为 $1$ 表示节点 $x+1$ 已经遍历到，否则没有遍历到）。但是这样空间和时间都无法承受，考虑优化掉一维，由于一定要知道当前深度是多少才知道每打通一条路的代价是多少，故第一维无法优化，需从**后两维**状态入手。

回顾一下这个状态设计的初衷，按照题目要求，由于要知道第 $i$ 层是由怎么样的 $i-1$ 层转移而来，于是需要保留两层状态。但是如果第 $i$ 层可以由前 $i-1$ 层转移且答案不变，那么我们没有必要保留 $i-1$ 层的信息，直接取第 $i$ 层的状态 $j$ 的子集就可以得到前 $i-1$ 层的所有信息。

那么只需要证明由第 $i-1$ 层产生的最小值和前 $i-1$ 层产生的最小值相等即可，也就是说前 $i-1$ 层所产生的最小值一定出现在第 $i-1$ 层。换句话讲，只需要证明前 $i-2$ 层的最小值比第 $i-1$ 层的最小值大即可。而这是比较容易说明的，因为深度小于 $i-1$ 的节点产生的贡献已经在之前更早遍历时在**其他状态**计算过，而此时将其**深度代价**作为 $i-1$ 一定不优（往上移更优，可以使得这个节点所在子树贡献都少 $1$）。

所以我们可以修改一下状态：设 $f_{i,j}$ 表示已经扩展的最大深度为 $i$，第 $i$ 层状态为 $j$ 的代价最小值。记 $valid(k,j)$ 表示状态 $k$ 是否可通过仅扩展一层而达到 $j$，是一个 bool 类型函数，$cost(k,j)$ 表示从状态 $k$ 扩展到状态 $j$ 所需的最小代价。

而为了计算 $valid(k,j)$ 和 $cost(k,j)$ 我们还需要引入两个函数，$expand(k)$ 表示状态 $k$ 仅扩展一层所形成的集合，$road(k,x)$ 表示从状态 $k$ 扩展到不在状态 $k$ 中的新节点 $x$ 所需的最小代价。这两者都可以预处理得到，具体见代码实现。那么 $valid(k,j)=(k \subseteq j)\wedge(j\subseteq expand(k))$，也就是 $k$ 是 $j$ 的子集，$j$ 是 $expand(k)$ 的子集。而 $cost(k,j)$ 则是对于 $k$ 和 $j$ 二进制不同的位置 $x$ 进行对 $road(k,x)$ 求和的结果。

转移比较好理解了 $f_{i,j}=\min_{vilid(k,j)}(f_{i-1,k}+(i-1)cost(k,j))$，初始值就是每一个节点 $x$ 为根的状态即 $\forall x\in[1,n],f_{1,2^{x-1}}=0$，其余为正无穷，答案就是 $\min_{1\le i\le n}{f_{i,2^n-1}}$。

预处理和转移的复杂度均为 $O(n^2\cdot2^n)$，求解合法的 $k$ 和 $cost(j,k)$ 的复杂度为 $O(n\cdot3^n)$ ，原因是 $2^n$ 个状态的子集总数为 $3^n$，可由二项式定理 $2^n+C_{n}^{1}\cdot2^{n-1}+C_{n}^{2}\cdot2^{n-2}+\cdots+1=(1+2)^n=3^n$ 得到，所以总复杂度是 $O(n^2\cdot2^n+n\cdot3^n)$。

代码都放末尾了，有需要的自取。

# 解法二：三进制状压
还是考虑我们最早想到的那个朴素算法，假如说我们没有想到能够把 $i-1$ 的最小值等效到前 $i-1$ 的最小值，我们可以采用三进制同时记录两行的信息，也可以优化掉一维。

考虑状态 $f_{i,j}$，表示扩展的最大深度为 $i$，且节点状态为 $j$ 的代价最小值。对于一个三进制数 $j$，若 $j$ 的第 $x$ 位为 $0$ 则表示 $x+1$ 这个节点**没有**被遍历过；第 $x$ 位为 $1$ 则表示 $x+1$ 这个节点在前 $i$ 层被遍历了，且**可以转移**；第 $x$ 位为 $2$ 则表示 $x+1$ 这个节点是第 $i$ 层通向第 $i+1$ 层被打通的，此时刚被打通，**不能转移**。

简单来讲，$0$ 表示没有遍历，$1$ 表示出于前 $i$ 层且被遍历，$2$ 表示在第 $i+1$ 层刚被遍历到。所以说 $0$ 要先经过 $2$ 才可以到 $1$，第 $i$ 层的 $2$ 对于第 $i+1$ 层来说就是 $1$，希望大家好好理解一下这句话，这句话理解了后面就简单了。

肯定有读者好奇，为什么不存储第 $i$ 层和第 $i-1$ 层，而是存储第 $i$ 层和第 $i+1$ 层，这是因为转移的原因。如果我们用三进制设计状态，不易得到哪些状态可以转移到 $f_{i,j}$，而是容易得到 $f_{i,j}$ 可以转移到哪些状态，第 $i$ 层到第 $i+1$ 层合法的都可以转移，而第 $i$ 层只能由**更小的** $j$ 转移到**更大的** $j$，避免冗余。

通过上面这段话我们知道，对于一个已经求解完毕的 $f_{i,j}$，其可转移到的状态有三种：

1. 把第 $i$ 层的 $2$ 转移到第 $i+1$ 层的 $1$，记把三进制数 $j$ 的所有 $2$ 换成 $1$ 的新数为 $s$，之前说过第 $i$ 层的 $2$ 对于第 $i+1$ 层来说就是 $1$，所以说直接用 $f_{i,j}$ 更新 $f_{i+1,s}$ 即可。

2. 把第 $i$ 层的 $0$ 更新为 $2$，也就是打通了一条从第 $i$ 层到第 $i+1$ 层的路。取状态 $j$ 最高位为 $1$ 的位置 $x$，扫描节点 $x+1$ 的所有连边，如果找到点 $y$ 满足 $j$ 的第 $y-1$ 位为 $0$，则用 $f_{i,j}+i\cdot dis_{x+1,y}$ 更新 $f_{i,j+2\times 3^{y-1}}$。

3. 把第 $i$ 层的 $1$ 更新为 $2$，即让某个点不在可以扩展，这时候又有人要问了，不是说从 $0$ 到 $2$ 再到 $1$ 吗。像这样说是节点的**遍历**顺序，但是我们要满足每一层内只能由小状态转移到大状态，$2$ 更新到 $1$ 明显不符，所以说这一步其实是一步逆更新，因为 $2$ 是无论如何都无法更新到 $1$ 的，所以只能 $1$ 更新 $2$。其实 DP 的更新不一定要满足实际，只要保证拓扑序，一层一层更新就是合法的。取状态 $j$ 最高位为 $1$ 的位置 $x$ 把它直接替换成 $2$ 没有任何贡献生成（因为 $2$ 在第 $i$ 层是不可被转移的），所以直接用 $f_{i,j}$ 更新 $f_{i,j+3^x}$。

至于为什么第 $2$、$3$ 种转移中每次只转移最高位，是因为每次只能由小状态转移到大状态，所以说只有最高位需要转移。那就有人会不禁发问，会不会有些状态没有被更新到，这是不必担心的，因为我们通过循环枚举了**所有**状态，更小的状态在之前已经**被枚举到**，也就是说不涉及最高位的转移在之前就已经完成。以 $(12120110)_3$ 举例，第二个 $1$ 已经在状态 $(02120110)_3$ 等其他让它是最高位的状态完成转移，其他位也是一样的道理就不再赘述。

初始值是，答案是 $f_{n+1,(111\cdots1)_3}$，解释一下为什么答案是这个，因为不清楚不同的图所形成的树如何，所以说不清楚到第几层全部节点就都遍历过了，本来要像解法一一样取 $\min$ 的，但是我们发现解法二的转移为我们带来了遍历。假设第 $k$ 层就已经遍历完整棵树，且 $f_{k,(111\cdots1)_3}$ 已经存储了答案，根据第一条转移，$f_{k,(111\cdots1)_3}$ 会直接转移到 $f_{k+1,(111\cdots1)_3}$，而每次转移已经帮我们取了 $\min$，以此类推。从而 $n$ 次循环结束后，$f_{n+1,(111\cdots1)_3}$ 就是答案。时间复杂度为 $O(n^2\cdot3^n)$。

有一点需要注意的就是此方法无法使用移位运算和逻辑运算来完成三进制的处理，同时除法和取余又是**常数极大**的运算，所以说要预处理一些数组方便转移，具体实现见代码。

# 代码实现

[放剪贴板了](https://www.luogu.com.cn/paste/z8tuz8qa)

# 后记

这篇题解也算是学完蓝书的一个总结和心得，有写的不好的和有错误的地方也欢迎大家提出和指正！

完结撒花！！！

---

## 作者：suzhikz (赞：4)

状压模版题。

先思考下什么东西会对答案有影响，一个是深度，一个是题目给的权值。

那我们可以直接枚举层。

那状压的东西就很明了了，一个是深度，一个是走过的点。我们预处理下能到的点，直接做即可。

转移方程式为 $dp_{i,j}=\min_{v\in to_i}dp_{v\oplus i,j-1}+k\times w(v\oplus i,i)$。第一维是遍历过的点，第二维是层数。枚举子集的子集的时间复杂度是 $O(3^n)$ 的，具体原因[推荐一篇博客](https://www.cnblogs.com/CDOI-24374/p/15876755.html)，总的时间复杂度是 $O(3^n\times n^2)$。

```cpp
for(int i=1;i<(1<<n);i++){
	for(int j=0;j<n;j++){
		for(int k=0;k<n;k++){
			if(((1<<k)&i)&&g[j][k]!=g[13][13]){
				to[i]|=(1<<j);
			}
		}
	}
}
```

这一部分是预处理能到的点。


```cpp
for(int i=2;i<(1<<n);i++){//枚举深度
	for(int j=i-1;j;j=(j-1)&i){//枚举子集的常见方式
		if((to[j]|i)==to[j]){//能到
			int summ=0;
			int book=i^j;
			for(int k=0;k<n;k++){
				if((1<<k)&book){//如果是新增的点
					int tmp=998244353;
					for(int l=0;l<n;l++){//枚举最小的边
						if((1<<l)&j){
							tmp=min(tmp,g[l][k]);
						}
					}
					summ+=tmp;
				}
			}
			for(int k=1;k<n;k++)
			dp[k][i]=min(dp[k][i],dp[k-1][j]+summ*k);//记得乘上深度
		}
	}
}
```

这是 dp 的主体部分。

---

## 作者：ZHR100102 (赞：4)

# 普通状压做法

参考了蓝书的做法。

观察到 $n\le 12$，首先想到状压。

但考虑到普通的状压不太行，因为 $K$ 这个数算在代价里，会导致这个 dp 有后效性。同时也观察到最终形成的方案**一定是一棵树**。

因此，我们尝试把 $K$ 加入状态中。

定义 $dp_{K,i}$ 表示这棵树扩展到第 $K$ 层，状态为 $i$ 时的最小花费。

那么我们在转移的时候枚举一下 $i$ 的子集 $j$，从 $dp_{K-1,j}+cost\times(K-1)$ 转移就好了。

所以我们预处理的时候要把每个状态的能转移到该状态的子集列出来。

这个操作，我们可以先列出每个状态拓展所有点的边后的状态 $expd_i$，并且记录下每个状态 $i$ 扩展第 $j$ 个点的最小花费 $road_{i,j}$，目的是便于计算 $cost$ 的值。
于是我们枚举每一个状态的子集，判断这个状态是否是该子集的 $expd$ 的子集。如果是，则可以转移，枚举所有需要扩展的点，加上它的 $road$ 即可。

## 细节

### 枚举某个状态的子集

枚举 $i$ 这个状态的**非空**子集，可以通过如下代码实现：

```
for(int j=i;j!=0;j=((j-1)&i))
```

如果要枚举 $0$，必须特判；如果不能枚举自身，那么把 $j$ 初始化重设一下：`int j=((i-1)&i)`。

例子：枚举 $14$ 的非空子集（包括自己）。

![](https://cdn.luogu.com.cn/upload/image_hosting/jeah80kr.png)


因为每次都从某个子集减 $1$，并且还与了自身，所以保证每次都是子集，且比以前都小，保证了不重、不漏。

### 位运算

注意优先级，很容易被坑，多打括号。


### 时间复杂度分析

二项式定理：

$$(a+b)^n=C_{n}^{0} a^nb^0 +C_{n}^{1} a^{n-1}b^1 +\dots+C_{n}^{k} a^{n-k}b^k +\dots+C_{n}^{n} a^0b^n$$

其中，组合数的系数可以看作是杨辉三角里的数。其实这个定理初二就学过，且该定理可以逆用。

那么我们用此来解决本题枚举子集部分的复杂度分析：

$$2^n+C_{n}^{1}2^{n-1}+C_{n}^{2}2^{n-2}+...+1=(2+1)^n=3^n$$

这就是 dp 部分复杂度，预处理的复杂度为 $O(m\times2^n)$。

总体复杂度 $O(n\times3^n+m\times2^n)$。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pi;
int n,m,expd[4505];
ll d[15][15],road[4505][15],dp[15][4505],ans=0x3f3f3f3f3f3f3f3f;
vector<pi>frm[4505];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	memset(d,0x3f,sizeof(d));
	memset(road,0x3f,sizeof(road));
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		d[u][v]=d[v][u]=min(1ll*w,d[u][v]);
	}
	for(int i=1;i<=n;i++)d[i][i]=0;
	//初始化expand和road函数
	for(int i=0;i<(1<<n);i++)
	{
		expd[i]=i;
		for(int j=1;j<=n;j++)
		{
			if(((i>>(j-1))&1)==0)continue;//位运算不要偷懒，这里写 !(i>>(j-1))&1 是错的！
			road[i][j]=0;
			for(int k=1;k<=n;k++)
			{
				if(((i>>(k-1))&1)==1)continue;
				if(d[j][k]>=(0x3f3f3f3f/2))continue;
				expd[i]=expd[i]|(1<<(k-1));
				road[i][k]=min(road[i][k],d[j][k]);
			}
		}
	}
	//初始化每个状态的子集们
	for(int i=0;i<(1<<n);i++)
	{
		for(int j=i;j!=0;j=((j-1)&i))
		{
			if((i&expd[j])!=i)continue;
			ll cst=0;
			for(int k=1;k<=n;k++)
			{
				if(((i^j)>>(k-1))&1)cst+=road[j][k];
			}
			frm[i].push_back({j,cst});
		}
	}
	//状压dp
	memset(dp,0x3f,sizeof(dp));
	for(int i=0;i<n;i++)dp[1][1<<i]=0;
	for(int i=1;i<=n;i++)//层数
	{
		for(int j=0;j<(1<<n);j++)//当前状态
		{
			for(auto tmp:frm[j])
			{
				int st=tmp.first;
				ll cst=tmp.second;
				dp[i][j]=min(dp[i][j],dp[i-1][st]+cst*(i-1));// i要-1 ，不要读错题
			}
		}
	}
	for(int i=1;i<=n;i++)ans=min(ans,dp[i][(1<<n)-1]);
	cout<<ans;
	return 0;
}
```


# 三进制状压做法

口胡一下，有点难写。

三进制数，该位为 $0$ 代表没有开辟，$1$ 代表早就开辟，可以转移；$2$ 表示刚开辟，不能转移。

这种做法依然要记录层数。除此之外还要记录 $3$ 的次幂之类的东西，常数极大。

注意转移时只要转移最高位的 $1$，因为其他位的 $1$ 以后一定会循环到，避免了重复枚举。跟愤怒的小鸟那题挺像的。

复杂度 $O(n^2\times3^n)$，代码就不放了。

---

## 作者：FZY_CZY (赞：3)

本题解以《算法竞赛进阶指南》作为参考资料。
# 题意
[题目](https://www.luogu.com.cn/problem/P3959)

题意其实并没有那么简单，想要读清楚还是有些难的。

就是说有许多的点，我们需要把它们组合在一起，构造成一棵树的形状（其实就是图，只是实际上可以进一步分类为树），这棵树并不是可以随便添加边，只有几个固定的边可供选择，然后现在问我们如何将边分配（安排节点的深度），使得我们最后开发边的代价最小（这个代价不仅仅是权值，在题目中有详细的计算方法）。
# 思路
## 做法
我们可以发现一件事情，就是我们在开发一条新边的时候，我们的各个边状态是可以通过一个数表示出来的，那么，我们就找到了状压的思路，又考虑到 $n\le12$，这样很明显是可以状压的，所以这个思路目前来说是没有问题的。

大的方向已经把握住了，然后就可以进一步延申，看一下如何实现。
## 从暴力中找正解
在一切进行前，我认为需要先打一个暴力，观察暴力，然后思考正解怎么写，暴力怎么优化。暴力打完后，我们发现我们的空间是 $2$ 的 $n$ 次方的 $3$ 次方（不知道这样怎么打 Latex），很明显是 MLE 的，但是通过对于题解的观察，我们可以发现一件事情，那就是我们 $f_{i,j,k}$ 中的 $k$ 是可以省略的，但是省略后会有一些信息无法表述完整，那么最后的答案就是不合法的，所以我们要思考一下如何证明答案可以是合法的。
## 通过转化简化问题
我们可以看到每一次将一个点和它的上一层连接起来是具有一个费用的，我们把这些费用设为集合 $A$，这个时候，我们做一个大胆的假设，改变一下题意，假设当前的这个点可以与之前的任意一个点相连，我们将这些费用设为集合 $B$。

这个时候，我们就可以去证明一下 $A_{\min}=B_{\min}$，我们在初二的数学中学过：若 $a\le b,a\ge b$，则 $a=b$。这里也可以用相同的思想，我们先考虑怎么证明 $A_{\min}\ge B_{\min}$，很明显，集合 $B$ 的取值范围是严格不小于集合 $A$ 的，所以 $A_{\min}\ge B_{\min}$，然后考虑证明 $A_{\min}\le B_{\min}$，我们可以构建一棵树，如果这棵树的这个节点可以往上一层以前去连边，那么，这个节点可以直接往上一层以前练，不需要考虑上一层，这样的话，这个点的子树不变，可以发现，开通的费用的系数都减一了，所以 $A_{\min}\le B_{\min}$，综合起来，就是 $A_{\min}=B_{\min}$。

那么，我们设每一个状态为 $f_{i,j}$，$i$ 表示当前选择的状态，$i$ 是一个二进制数，$j$ 表示深度。

因为我们已经将集合 $A$ 的最小值（也就是答案）可以用集合 $B$ 来表示，那我们直接依照我们 $f_{i,j}$ 的计算方式来 DP 就 OK 了，当问题转换完了之后，问题就简单许多，至少不是紫（蓝绿吧）。
## 转化问题后的实现
我们来简单描述一下计算集合 $B$ 的 DP 方法。

我们通过状压表示当前的状态，每次拓展一层，那么就有状态转移方程：
$$
f_{i,j}=\min {f_{i\oplus k,j-1}+(i-1)\times cost(k,j)}
$$

我们来解释一下，$i\oplus k$ 的意思就是 $j-1$ 层中有多少个节点已经选择，$j-1$ 的意思就是上一层，后面的就是计算费用的公式，题面中已经给出，并且，这个 $cost$ 函数是可以通过预处理先处理出来的。

我们的预处理是 $O(M\times 2^N)$ 的时间复杂度，然后 DP 的过程是 $3^N$ 的，这个由二项式定理就可以得到。

综上所述，这个做法是 $O(M\times 2^N+3^N)$ 的，不会 TLE。

至此，我们算是完成了这道题。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=12,M=1<<12,INF=0x3f3f3f3f;
int n, m;
int d[N][N];
int f[M][N],g[M];
int main(){
    scanf("%d%d", &n,&m);
    memset(d,0x3f,sizeof d);
    for (int i=0;i<n;i++) d[i][i]=0;
    while (m--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        a --,b --;
        d[a][b]=d[b][a]=min(d[a][b],c);
    }
    for (int i=1;i<1<<n;i++)
        for (int j=0;j<n;j++)
            if (i>>j&1)
            {
                for (int k=0;k<n;k++)
                    if (d[j][k]!=INF)
                        g[i]|=1<<k;
            }
    memset(f,0x3f,sizeof f);
    for (int i=0;i<n;i++) f[1<<i][0]=0;
    for (int i=1;i<1<<n;i++)
        for (int j=(i-1);j;j=(j-1)&i)
            if ((g[j]&i)==i)
            {
                int remain=i^j;
                int cost=0;
                for (int k=0;k<n;k++)
                    if (remain>>k&1)
                    {
                        int t=INF;
                        for (int u=0;u<n;u++)
                            if (j>>u&1)
                                t=min(t,d[k][u]);
                        cost+=t;
                    }
                for (int k=1;k<n;k++) f[i][k]=min(f[i][k],f[j][k-1]+cost*k);
            }
    int res=INF;
    for (int i=0;i<n;i++) res=min(res,f[(1<<n)-1][i]);
    printf("%d",res);
    return 0;
}
``````
完结撒花！！！

---

## 作者：pengyirui (赞：2)

# 分析
观察数据范围，$n\le 12$，并且 $n$ 为集合大小，考虑使用状态压缩动态规划。             
一个比较简单的思路是把树的高，也就是道路的长度加到状态里。那么就可以有 $f_{s,h}$，表示现在选的点集为 $s$，树高为 $h$ 的最小花费。    
状态转移方程如下：    
$$f_{s,i}=\min_{t\in s}(f_{t,i-1}+cost_{t\to s})$$
$cost_{t\to s}$ 表示的花费应当在可接受的复杂度内预处理出来，而使用 Floyd 算法求解最短路径时的时间复杂度为 $O(n^3)$，在这道题目中是完全可以接受的。因此最终的时间复杂度就是 $O(3^nn^2)$。                       
其中 $t$ 就会遍历 $s$ 的全部子集。此时的运算上限为 $531441\times 12^2=76527504$，这对于时间限制来说有点勉强。       
考虑进行优化。不难发现同一树高的所有节点可以同时转移。不妨设 $f_{s,t}$，表示已选点集为 $s$，下一层要加入的点集为 $t$ 时，新加入的所有点与原有点之间最小的边权之和。    
状态转移方程如下：
$$f_{s,t}=\min\{f_{s,t-lowbit(j)}+ cost_{k,s}\},k=\log_{2}(lowbit(j))$$
其中 $cost_{k,s}$ 表示点 $k$ 到连通块 $s$ 的最短距离。    
同时考虑对 $f$ 预处理的动态规划。设 $g_{s,h}$ 表示已选点集为 $s$，当前树高为 $h$ 的最小花费。那么有转移：
$$g_{s,h}=\sum_{i\in s} g_{s-t,h-1}+hf_{s-t,t}$$
所以最后的时间复杂度就是 $O(3^n\times n)$。而最终答案应当是对所有 $g_{2^n-1,h},h\in[1,n]$ 取最小值。
# 代码

```cpp
#include<bits/stdc++.h>
#define MAX 5005
#define MAXN 105
#define int long long
using namespace std;
int cnt,T,d[MAX][MAX],a,b,c;
int n,m,i,j,k,Log[MAX],maxn,A[MAXN][MAXN],f[MAXN][MAX],Next[MAX],ans,sup,now;
signed main()
{
	memset(A,63,sizeof(A));
	memset(f,63,sizeof(f)),ans=45121999;
	cin>>n>>m;
	maxn=(1<<n)-1;
	for(i=1;i<=m;i++)
	{
		cin>>a>>b>>c;
		A[a][b]=A[b][a]=min(c,A[a][b]);
	}
	for(i=0;i<=n;i++)Log[1<<i]=i;
	for(i=0;i<=n;i++)f[0][1<<i]=0;
	for(i=1;i<=maxn;i++)
	{
		cnt=0;
		for(j=sup=maxn^i;j;j=(j-1)&sup)Next[j]=cnt,cnt=j;
		for(j=cnt;j;j=Next[j])
		{
			now=Log[j&(-j)]+1,T=45121999;
			for(k=1;k<=n;k++)if(1<<(k-1)&i)T=min(T,A[now][k]);
			d[i][j]=d[i][j^(j&-j)]+T;
		}
	}
	for(i=1;i<n;i++)
	    for(j=1;j<=maxn;j++)
	        for(k=j;k;k=(k-1)&j)
	            f[i][j]=min(f[i][j],f[i-1][j^k]+i*d[j^k][k]);
	for(i=0;i<=n;i++)ans=min(ans,f[i][maxn]);
	cout<<ans;
	return 0;
}
```

---

## 作者：CommandSR (赞：1)

## 题意简化

给定一个包含 $n$ 个节点和 $m$ 条边的带权无向图，选择一个根节点并构造一棵生成树，使得总代价 $\sum_{k = 1}^{m}L \times K$ 最小，其中 $L$ 是边的长度而 $K$ 是根节点到该边起点路径上的节点数。

## 基本思路

注意到 $1 \le n \le 12$ 考虑状压 DP。

设 $f_{i, s}$ 表示前 $i$ 层，状态为 $s$ 的最小总代价，其中 $s$ 是状压下的二进制数，每一位表示每一个节点有没有被取到。

显然最后答案在对于每一个 $i$ 的 $f_{i, 2^n}$ 的最小值中。

考虑状态转移。

假设当前的状态 $s$ 从上一层的状态 $t$ 转移而来，当前层数为 $i$，花费代价为层数*边权，即 $calc(t, s) \times i$，则状态转移方程 $f_{i, s} = \min{f_{i-1, t}+calc(t, s) \times i}$。

那么如何实现 $calc$ 函数呢？

记 $calc(u, v)$ 为从 $u$ 状态转移到 $v$ 状态的代价（这里的“代价”是不考虑层数的，边权的代价），显然我们需要得到从 $u$ 状态转移到 $v$ 状态的过程中新访问到了哪些点，即 $s = u \oplus v$。

取出 $s$ 的每一位 $1$，再对于每一位 $1$，在 $u$ 中取出每一位 $1$，取距离最小值就是 $s$ 的这一位更新所需的代价，如果觉得我表达不清可以看代码：

```cpp
int calc(int u, int v) {
	int res = 0;
	int s = u ^ v;
	for (int i = 0; i < n; i++) {
		if (!(s & (1 << i))) continue ;
		int mn = 1e9;
		for (int j = 0; j < n; j++) {
			if (!(u & (1 << j))) continue ;
			mn = min(mn, g[i+1][j+1]);
		}
		res += mn;
	}
	return res;
}
```

还有最后一个问题，对于原状态 $t$ 和新状态 $s$ 显然 $t$ 是 $s$ 的子集，枚举子集在这里不展开讲，代码如下：

```cpp
for (int s = 3; s < NN; s++)
    for (int t = s; t; t = (t-1) & s)
```

根据二项式定理，枚举子集时间复杂度 $O(3^n)$。

算法整体时间复杂度 $O(n^2 \times 3^n)$。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 13;
int n, m, g[N][N], NN;
int f[N][1<<N];
int lowbit(int x) {return x & -x;}
int calc(int u, int v) {
	int res = 0;
	int s = u ^ v;
	for (int i = 0; i < n; i++) {
		if (!(s & (1 << i))) continue ;
		int mn = 1e9;
		for (int j = 0; j < n; j++) {
			if (!(u & (1 << j))) continue ;
			mn = min(mn, g[i+1][j+1]);
		}
		res += mn;
	}
	return res;
}
signed main() {
	cin >> n >> m;
	NN = (1 << n);
	memset(g, 0x3f, sizeof g);
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= m; i++) {
		int u, v, w; cin >> u >> v >> w;
		if (u == v) continue ;
		g[u][v] = min(g[u][v], w);
		g[v][u] = min(g[v][u], w);
	}
	f[0][0] = 0;
	for (int i = 0; i < n; i++) f[0][1 << i] = 0;
	for (int i = 1; i <= n-1; i++) {
		for (int s = 3; s < NN; s++) {
			for (int t = s; t; t = (t-1) & s) {
				if (t == s) continue ;
				f[i][s] = min(f[i][s], f[i-1][t] + calc(t, s) * i);
			}
		}
	}
	int ans = 0x3f3f3f3f;
	for (int i = 0; i <= n; i++) ans = min(ans, f[i][NN-1]);
	cout << ans << '\n';
	return 0;
}
```

拒绝抄袭！

---

## 作者：2022dyx (赞：0)

一句话题意：

求一个有 $n$ 个点，$m$ 条边且带边权的无向图的最小外向生成树。定义生成树 $T$ 的权值为：
$$$\sum_{(u,v)\in T} dep_v \times val_{(u,v)}$$$

数据范围：$n \leq 12,\ m \leq {10}^4$。

$n$ 超级小的范围提示了我们上状压，我们还会发现这题的 $dep$ 十分重要，因此我们猜测这题的状态会包含节点状态 $S$ 和一个深度相关的 $i$。

总之，定义 $dp_{i,S}$ 为目前生成树深度为 $i$，包含节点状态为 $S$ 应该是不难想到的。这个东西要怎么转移呢？

$$$dp_{i,S}=\min_{T \in S} dp_{i-1,T}+i \times \sum_{j \in S \setminus T} \min_{k \in T \wedge dep_k=i-1} dis_{j,k}$$$

啊呀，那难道我们还要在状态中记录 $dep$ 为 $i$ 的节点状态？那光是状态数就至少是 $O(n \times 3^n)$ 了，再加上指数的转移，显然是不行的。这里有一个很妙的东西：

仔细想想，哪怕我们不做 $dep$ 的约束，不是从 $i-1$ 转移而来的部分也不可能成为最优答案，因为这一定不如在 $i$ 更小的时候就进行转移。所以说，这样的状态和转移就是正确的了。借助子集枚举，目前我们的复杂度为 $O(n^3 \times 3^n)$，难以通过。

因为在状态 $S$ 上合并 $T$ 时的代价与 $i$ 成正比，于是我们可以直接预处理这个比值，记为 $pre_{S,T}$，即 :
$$$pre_{S,T}=\sum_{i \in T} \min_{j \in S} dis_{i,j}$$$
由于 $S,T$ 一定无交，这里的复杂度为 $O(n^2 \times 3^n)$。

虽然已经好了很多，但是我们还可以优化吗？

是可以的。这里的 $pre$ 同样可以动态规划求解，设状态 $T$ 中最低的一位为 $i$，我们有转移式：
$$$pre_{S,T}=pre_{S,T \setminus i}+\min_{j \in S} dis_{i,j}$$$
$$$pre_{S,\emptyset}=0$$$
复杂度 $O(n \times 3^n)$。

在这之后，状态的转移就非常简单了，有：
$$$dp_{i,S}=\min_{T \in S}dp_{i-1,T}+i \times pre_{T,S \setminus T}$$$
这也是 $O(n \times 3^n)$ 的，于是我们用 $O(n \times 3^n)$ 的优秀复杂度通过了本题。

---

## 作者：_Ch1F4N_ (赞：0)

贡献不是特别好转化，我们直接考虑按照贡献定义计算，由于涉及了根到起始点的距离，我们一层层加入所有点，设 $dp_{i,S,T}$ 表示当前考虑第 $i$ 层，已经加入的点集为 $S$，深度为 $i$ 的点集合为 $T$ 的最小代价，设 $w_{S,T}$ 表示 $S$ 中每个点选一个到 $T$ 中的最小边，选出来的边的权值和，转移形如 $dp_{i,S,T} \to dp_{i+1,S \cup Z,Z} + w_{T,Z} \times (i-1)$。$w_{S,T}$ 容易在 $O(3^n \times n)$ 的时间复杂度内处理出来，问题是 $dp_{i,S,T}$ 的转移是 $O(4^n \times n)$ 的。

你发现复杂度太高是因为转移过程中对状态设下的限制太多，考虑去掉对状态的一些限制，也就是去掉状态的一些维。

注意到第 $i$ 层的点被算作第 $j$ 层（$j>i$）的点只会使得答案变劣，所以实际上不用限制新加入的第 $i$ 层的点一定要连向第 $i-1$ 层的点，允许其连向所有前面已经加入的所有点都不会使得答案更优，因此状态精简为 $dp_{i,S}$，转移变为 $dp_{i,S} \to dp_{i+1,S \cup T} + w_{T,S}$，时间复杂度 $O(3^n \times n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv = (1<<12);
int w[maxv][maxv];//w[S][T] S 中每个点向 T 中点连边
int dp[maxv];
int f[12][maxv];//f[i][S] i 向 S 中点连边
int n,m;
const int inf = 5e7;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    for(int i=0;i<12;i++){
        for(int j=0;j<maxv;j++) f[i][j]=inf;
    }
    for(int i=0;i<maxv;i++){
        dp[i]=inf;
    }
    cin>>n>>m;
    if(n==1){
        cout<<0<<'\n';
        return 0;
    }
    for(int i=1;i<=m;i++){
        int u,v,c;
        cin>>u>>v>>c;
        u--,v--;
        f[u][1<<v]=min(f[u][1<<v],c);
        f[v][1<<u]=min(f[v][1<<u],c);
    }
    for(int i=0;i<n;i++){
        for(int v=0;v<(1<<n);v++){
            for(int p=0;p<n;p++){
                if((1<<p)&v) f[i][v]=min(f[i][v],f[i][v-(1<<p)]);
            }
        }
    }
    for(int S=0;S<(1<<n);S++){
        for(int T=(1<<n)-1-S;T>0;T=(T-1)&((1<<n)-1-S)){
            for(int i=0;i<n;i++){
                if((1<<i)&S) w[S][T]+=f[i][T];
            }            
        }
    }
    for(int S=0;S<(1<<n);S++){
        for(int T=(1<<n)-1-S;T>0;T=(T-1)&((1<<n)-1-S)) w[S][T]=min(w[S][T],inf);
    }
    for(int i=0;i<n;i++){
        dp[1<<i]=0;
    }
    int ans=inf;
    for(int p=2;p<=n;p++){
        for(int S=(1<<n)-1;S>0;S--){
            for(int T=(S-1)&S;T>0;T=(T-1)&S){
                dp[S]=min(dp[S],dp[S-T]+w[T][S-T]*(p-1));
            }          
        }
        for(int S=1;S<(1<<n);S++){
            ans=min(ans,dp[(1<<n)-1]);
        }
    }
    cout<<ans<<'\n';
    return 0;
}

```

---

## 作者：Eterna (赞：0)

## 乱搞

对每个点为根的情况进行一次 `bfs`。

`bfs` 有一个性质，就是题目描述中的 $\mathrm{K}$ 是单调不减的，所以我们直接按 $\mathrm{L}$ 贪心扩展节点即可。

时间复杂度 $O(n^2)$，得分 $40$。

## 更强的乱搞

模拟赛时的做法。

上述做法的正确性太差了，稍微大一点的数据就会错。原因就是我们考虑的树的形态太少了，只有 $n$ 种。可所有形态的数量大约是 $C_{n^2}^n$ 级别的东西。

考虑加入随机化的成分。`bfs` 扩展时并非一定接受，而是按一定概率 $B$ 接受，这样做 $T$ 次。

时间复杂度 $O(Tn^2)$，取 $T=5 \times 10^4,B=0.5$，得分 $70$。

## 正解

首先看到 $n \le 12$，猜测是指数级算法。

考虑状压 `dp`，设 $f_{i,j}$ 中 $i$ 表示当前树的深度， $j$ 表示当前已选点所构成的集合。

另有 $d_{i,j}$ 表示在 $i$ 的已选点集的基础上选择 $j$ 的最小花费，$v_{i,j}$ 表示 $i$ 到 $j$ 的距离。

则转移方程为：

$$f_{i,j}=\min _{k \subseteq j} (f_{i-1,j-k}+i \times d_{j-k,j})$$

$d$ 可以预处理，转移为：

$$d_{i,j}=d_{i,j-\min\{j\}}+ v_{i,\min\{j\}}$$

枚举子集复杂度为 $O(3^n)$，则本算法的时间复杂度为 $O(3^n n^2)$。得分 $100$。

---


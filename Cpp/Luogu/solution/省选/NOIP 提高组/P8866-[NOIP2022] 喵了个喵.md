# [NOIP2022] 喵了个喵

## 题目描述

小 E 喜欢上了一款叫做《喵了个喵》的游戏。这个游戏有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1, a_2,\dots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。
- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。

这个游戏一共有 $T$ 关，小 E 一直无法通关。请你帮小 E 设计一下游戏方案，即对于游戏的每一关，给出相应的操作序列使得小 E 可以把所有的卡牌消去。


## 说明/提示

**【样例 1 解释】**

下图是初始状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/iidvwekz.png)

下图是前两次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/hrcdl51d.png)

下图是第三次和第四次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/ju6b9dep.png)

下图是第五次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/djpqtzfr.png)

**【样例 2】**

见选手目录下的 $\texttt{meow/meow2.in}$ 与 $\texttt{meow/meow2.ans}$。

**【数据范围】**

设 $S$ 为所有 $T$ 组数据中 $m$ 的总和。

对于所有数据，保证 $S \leq 2 \times 10^6$，$1 \leq n  \leq 300$，$1 \leq a_i \leq k$。

| 测试点 | $T=$ | $n$ | $k=$ | $m \leq$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $1001$ | $\leq 300$ | $2n-2$ | 无限制 |
| $4\sim 6$ | $1002$ | $=2$ | $2n-1$ | 无限制 |
| $7\sim 10$ | $3$ | $=3$ | $2n-1$ | $14$ |
| $11\sim 14$ | $1004$ | $=3$ | $2n-1$ | 无限制 |
| $15\sim 20$ | $1005$ | $\leq 300$ | $2n-1$ | 无限制 |


**【评分方式】**

对于每一组数据，若在按顺序进行所有操作后，牌堆为空且所有的栈均为空，则认为你的答案正确。

**【提示】**

你可以通过 $T$ 的个位数来判断这个测试点是属于哪一类数据。

你的输出不需要与样例输出一致，输出任意一个合法解即可得分。

## 样例 #1

### 输入

```
1
2 4 2
1 2 1 2```

### 输出

```
5
1 1
1 1
1 2
2 1 2
1 1```

# 题解

## 作者：dapingguo8 (赞：257)

### 消除的基本策略

假定当前牌堆顶的牌的种类为 $x$，现在场上也有至少一张种类为 $x$ 的牌，然后我们想把这张牌直接消掉。

在以下的策略中如果场上有两张相同的牌，我们一定会立刻将它们消掉，所以同种类的牌于此条件下在场上只能出现一次。假定场上另一张种类为 $x$ 的牌位于栈 $p_x$ 中。

- 如果 $p_x$ 的顶端卡牌种类为 $x$，则将当前牌堆顶的牌放到栈 $p_x$ 上，它们会自动被消掉。
- 如果 $p_x$ 的底端卡牌种类为 $x$，则将当前牌堆顶的牌放到一个空栈 $sp$ 上，然后对栈 $sp$ 和 $p_x$ 执行一次操作二，它们也会被消掉。

（以下同颜色代表同种类的牌）

第一种操作示例：

![操作1](https://cdn.luogu.com.cn/upload/image_hosting/ky1hipe1.png)

第二种操作示例：

![操作2](https://cdn.luogu.com.cn/upload/image_hosting/wvsbdwvw.png)

不难发现如果一个栈里有不少于三张牌的话，那么位于中间的那一张是不容易被消掉的，而 $k$ 的范围在 $2n$ 左右，这启发我们尽可能使每个栈含有不超过两张牌。

### $k=2n-2$

#### 策略1：存在一个编号为 $sp$ 的空栈，且当前牌堆顶的牌在场上存在 或 其余栈中存在至少一个栈大小不超过 $1$：

- 如果当前牌堆顶的牌在场上出现过，按上述消除基本策略执行（将栈 $sp$ 第二种消除操作的空栈）。
- 否则将其放到任意一个其中大小不超过 $1$ 的栈的栈顶 **（$sp$ 号栈除外）**。



由于只有 $k=2n-2$ 种卡牌，我们可以保证即使前 $n-1$ 个栈均含有两张卡牌时，牌堆顶的牌也一定会在场上出现过，可以重复按照策略1执行。令 $n$ 号栈为 $sp$ 空栈，便可保证第二种消除基本策略的执行。



### $k=2n-1$

现在多了一种牌，所以策略1不一定每次都能奏效了。

那么考虑如何安置多出来的这一种牌。我们再看牌堆顶的下一张牌，如果这张牌的同类牌出现在栈底（不妨设对应栈编号为 $p$），那么不难得出可以将牌堆顶的牌放到栈 $p$ 上，然后将下一张牌放到栈 $sp$ 里，最后对栈 $p$ 和 $sp$ 执行一次操作2便可安置。

![](https://cdn.luogu.com.cn/upload/image_hosting/le9p0fu1.png)

但是如果下一张牌的同类牌在栈顶的话，我们可以无脑将牌堆顶的牌放到栈 $sp$ 上吗？显然不可以：

![](https://cdn.luogu.com.cn/upload/image_hosting/gss3eqmu.png)

既然消除的关键还是栈底的牌，所以我们可不可以拓宽一下视野，往后看有没有位于底部的牌，然后将牌堆顶的牌放到对应栈顶呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/xy1g3sgy.png)

貌似很行，对吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/6i8exa0v.png)

还是不行。牌堆顶的牌阻挡了原栈顶的牌，使得它们不能互相消除。

但如果我们改为将牌堆顶的牌放到 $sp$ 里....

![](https://cdn.luogu.com.cn/upload/image_hosting/jvk4sqyv.png)

这样反而行得通了，唯一的区别就是 $sp$ 换了一下。

那么两者的区别是什么呢？仔细观察就可以发现：

- 前者第一张位于底部的牌所在栈的栈顶牌没有被消去，后者被消去了。

什么情况下栈顶元素会被消去？结合上述图思考一下便可得知：

- 在牌堆顶和其后第一张位于栈底的牌之间，与栈顶牌同类的牌出现了奇数次。

至于这两张牌之间的所有牌，由于它们都出现在栈顶出现，所以直接将其分别放在对应栈上即可。（当然一些牌会出现多次，在这种情况下为了方便，可以每次都将其放在同样的位置。）

于是策略便逐渐明朗起来：

#### 策略 Meow：存在一个编号为 $sp$ 的空栈，且不满足策略1条件。

首先记录**此时**每类牌所在的栈编号和是否位于栈顶，记 $p_i$ 此时牌 $i$ 同类的牌所位于的栈编号，$t_i=1$ 代表此时牌 $i$ 同类的牌位于栈顶。

然后从牌堆顶的下一张开始，逐个向后判断。设当前判断的牌为 $x$。

- 若 $t_x=1$，则将 $x$ 放到栈 $p_x$ 的栈顶，然后判断下一张。

- 否则若 $x$ 与牌堆顶的牌同类，将这两张牌放到 $sp$ 里，然后更换使用策略1或重新使用策略 Meow。

- 否则：

  - 若与栈 $p_x$ 的栈顶牌同类的牌在牌堆顶至 $x$ 这些牌之间出现了奇数次，则将此时牌堆顶的牌放置于栈 $sp$，将 $x$ 放置于栈 $p_x$，然后将 $sp$ 改为 $p_x$。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/jvk4sqyv.png)

  - 若与栈 $p_x$ 的栈顶牌同类的牌在牌堆顶至 $x$ 这些牌之间出现了偶数次，则将此时牌堆顶的牌放置于栈 $p_x$，将 $x$ 放置于栈 $sp$，然后在栈 $sp$ 和 $p_x$ 上执行一次操作 $2$。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/xy1g3sgy.png)

    执行以上两种操作之一后更换使用策略1或重新使用策略 Meow 即可。



当然，由于将牌加入至栈的过程是有序的，所以在实现上会有些许不同。（例如，可以先找到 $x$ 在哪里，然后根据信息判断牌堆顶的牌应放置在哪里，最后将牌堆顶之后的牌加入栈。）



重复执行策略1和策略 Meow，最终所有的牌均可以被消掉。这样我们也可以证明所有合法的初始配置均有解。

[整体操作示例](https://www.luogu.com.cn/paste/wexeffk8)

对于操作次数：我们会执行恰好 $m$ 次操作1，而每次操作2会消除两张牌，由于操作1执行过程中也会消去牌，因此 $2m$ 张牌至多使用 $m$ 次操作2即可全部消除，于是总操作次数不超过 $m+m=2m$，符合条件。



数据范围较大（$\sum m\le 2\times 10^6$），所以需要注意复杂度和常数。



### 代码实现的细节和注意事项

#### 维护信息

你需要维护：

- 大小不超过1的栈有哪些
- 每种牌在场上出现的次数
- 每种牌所在的栈的编号

当然你也可以维护更多的信息，例如每种牌是否位于栈顶或栈底等。

#### 操作函数

由于需要涉及到很多情况，所以建议将操作写进一个函数以减少代码量。

以下为一种写法：

```c++
void change(int x,int y){
	ans.push_back({x,y});
	if(y==0){//y=0代表为操作1
		...//操作1
	}
	else{
		...//操作2
	}
}
...
change(4,0);//将牌堆顶的牌加入栈4
change(1,2);//对栈1和栈2执行操作2

```

你也可以在这个函数里进行对维护信息的修改。

```cpp
#include<bits/stdc++.h>
using namespace std;
ifstream fin("meow.in");
ofstream fout("meow.out");
#define cin fin
#define cout fout
int a[2000005],p[1000],b[1005];
deque<int>q[1000];
vector<pair<int,int>>ans;
int pos=1,sz;
int cnt[1005];
queue<int>pq0;
void change(int x,int y){
	ans.push_back({x,y});
	if(y==0){
		pq0.push(x);
		if(!q[x].empty() and q[x].back()==a[pos]){
			q[x].pop_back();
			cnt[a[pos]]--;
			if(cnt[a[pos]]==0)sz--,p[a[pos]]=0;
			if(q[x].empty())b[a[pos]]=0;
		}
		else{
			q[x].push_back(a[pos]);
			if(cnt[a[pos]]==0){
				sz++,p[a[pos]]=x;
			}
			cnt[a[pos]]++;
			if(q[x].size()==1)b[a[pos]]=1;
		}
		pos++;
	}
	else{
		pq0.push(x);
		pq0.push(y);
		if(q[x].front()==q[y].front()){
			b[q[x].front()]=0;
			cnt[q[x].front()]-=2;
			if(cnt[q[x].front()]==0){
				sz--,p[q[x].front()]=0;
				b[q[x].front()]=0;
			}
			q[x].pop_front();
			q[y].pop_front();
			
			if(!q[x].empty())b[q[x].front()]=1;
			if(!q[y].empty())b[q[y].front()]=1;
		}
	}
}
int main(){
	int t;
	cin>>t;
	while(t--){
		pos=1;
		sz=0;
		memset(p,0,sizeof p);
		memset(b,0,sizeof b);
		ans.resize(0);
		int n,m,k;
		cin>>n>>m>>k;
		int sp=n;
		
		while(!pq0.empty())pq0.pop();
		for(int i=1;i<=n;i++){
			if(i!=sp)pq0.push(i);
		}
		int ap[k+5]={0};
		for(int i=1;i<=m;i++){
			cin>>a[i];
			a[i+1]=0;
		}
		for(int i=1;i<=m;i++){
			if(sz==2*(n-1) and !cnt[a[i]]){
				int ti=i;
				for(int j=i+1;j<=m;j++){
					if(a[j]==a[i]){
						for(int w=i+1;w<=j;w++){
							ap[a[w]]=p[a[w]];
						}
						change(sp,0);
							for(int w=i+1;w<=j;w++){
								if(a[w]==a[i])change(sp,0);
								else change(ap[a[w]],0);
							}
							
						i=j;
						break;
					}
					if(b[a[j]]){
						if(ap[q[p[a[j]]].back()]){
							for(int w=i+1;w<=j;w++){
								ap[a[w]]=p[a[w]];
							}
							change(sp,0);
							sp=p[a[j]];
							for(int w=i+1;w<=j;w++){
								change(ap[a[w]],0);
							}
							
							
						}
						else{
							for(int w=i+1;w<=j;w++){
								ap[a[w]]=p[a[w]];
							}
							change(p[a[j]],0);
							for(int w=i+1;w<j;w++){
								change(ap[a[w]],0);
							}
							change(sp,0);
							change(sp,p[a[j]]);
						}
						i=j;
						break;
					}
					else{
						ap[a[j]]^=1;
					}
				}
				for(int j=ti;j<=i;j++){
					ap[a[j]]=0;
				}
				continue;
			}
			if(p[a[i]]){
				if(q[p[a[i]]].back()==a[i]){
					change(p[a[i]],0);
				}
				else{
					change(sp,0);
					change(sp,p[a[i]]);
				}
			}
			else{
				while(!pq0.empty() and (pq0.front()==sp or q[pq0.front()].size()>=2)){
					pq0.pop();
				}
				change(pq0.front(),0);
			}
		}
		
		cout<<ans.size()<<endl;
		
		for(auto it:ans){
			if(it.second==0)cout<<1<<' '<<it.first<<'\n';
			else cout<<2<<' '<<it.first<<" "<<it.second<<'\n';
		}
		assert(pos==m+1);
		for(int i=1;i<=n;i++){
			assert(q[i].empty());
		}
	}
}
```



---

## 作者：dbxxx (赞：179)

本篇题解将细致讲解本题的思路，并给出一种长度短而可读性高的解法。

[您可在我的博客中查看本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p8866.html)

[P8866 NOIP2022 喵了个喵 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P8866)。

本题解中我们将图案为 $x$ 的卡牌看做数字 $x$，将本题对于卡牌的操作看做对数字的操作。

观察到数据范围，$k \in \{2n - 2, 2n - 1\}$，那么做法肯定跟 $k$ 强相关。~~很难不联想 2018 年的旅行。但是那个 $m = n - 1$ 给了 60 分，这个呢？~~

## $k = 2n - 2$

首先发现 $op$ 的限制其实是假的：我们一定恰好进行了 $m$ 次操作 $1$，最多进行了 $0.5m$ 次操作 $2$，所以 $op$ 一定天然满足 $m \le op \le 1.5m$。

观察 $k$ 和 $n$ 的关系，发现是近似二倍，而且 $k = 2(n - 1)$，也就是我们如果把每两种数字考虑到一个栈，这样分配将恰好剩下一个空栈。

考虑将数字 $2i - 1$ 和 $2i$ 分配到第 $i$ 个栈中，第 $n$ 个栈就可以作为空辅助栈了。稍作思考可以给出以下的解法：

遇到一个数字 $x$，我们查看这个数字所分配到栈 $s$ 的情况：

- 如果 $s$ 为空，直接入栈；
- 如果 $s$ 有 $1$ 个元素，和 $x$ 相同，将 $x$ 入栈 $s$ 并将这两个 $x$ 消除；
- 如果 $s$ 有 $1$ 个元素，和 $x$ 不同，将 $x$ 入栈 $s$ ；
- 如果 $s$ 有 $2$ 个元素，栈顶和 $x$ 相同，将 $x$ 入栈 $s$ 并将这两个 $x$ 消除；
- 如果 $s$ 有 $2$ 个元素，栈顶和 $x$ 不同，那么栈底一定和 $x$ 相同。将 $x$ 入辅助栈 $n$，对栈 $n$ 和栈 $s$ 栈底相消。

容易看出，我们第偶数次遇到 $x$ 的时候，总能立刻将它和上一个 $x$ 抵消，所以一定能报告出解。

> 另外，可以注意到本题的操作只对栈顶和栈底有效，所以如果栈中某时元素很多就会造成大量的滞留，非常不优。这也和本做法中栈的大小始终不超过 $2$ 有关系（达到 $3$ 之后可以马上通过相消降为 $2$）。

这样 15 分就到手了。~~是 60 分的四分之一。~~

## $k = 2n - 1$

一种比较显然的想法是，对于数字 $x \le 2n - 2$ 我们暂时仍然考虑上面的处理方式，然后考虑如何处理 $x = 2n - 1$。发现遇到 $x = 2n-1$ 的时候局面的结构比较参差不定，不好想（后来发现好像也不是不可以，读者可以自己试试？）。

我选择了另一种想法，那就是抛开栈 $i$ 和数字 $2i$，$2i - 1$ 的绑定关系，采用先来后到的思想，按照 $k = 2n-2$ 的策略尽可能走下去。具体来说：

- 如果我们当前遇到的数 $x$ 在所有栈中还没出现过，就把 $x$ 射入一个**还没满两个元素**的栈，但如果已经有 $n-1$ 个栈全都满了，说明我们按照 $k= 2n-2$ 的策略已经**走不下去**了（我们必须留一个空栈作为辅助栈，用来栈底相消）。
- 如果 $x$ 在某个栈中出现了，直接使用 $k = 2n-2$ 的策略直接让当前的 $x$ 和栈中出现的那个 $x$ 消除。

当走不下去的时候，一定是局面上的 $n-1$ 个栈全部被填满各两个元素，每种元素恰出现一次，且接下来要填的数还是一个没有在这 $n-1$ 个栈中出现过的数 $P$。

> 提一嘴，我感觉在剩下的 85 分中，应该是有部分数据可以按照上述策略成功走完整个游戏的，毕竟随机数据下，出现走不下去的概率不是特别高（当然也不难构造）。所以也不失为一个骗分好办法。不过这题有多测，所以也有可能会卡。
>
> 更新：官方数据卡了这一点，只能拿到 15 pts。民间数据可以拿到 30 pts。

直接把 $P$ 放到辅助栈显然是错的：假如 $P$ 后面跟了一个被压在栈底的数字，那么这两个数字可能很难再抵消，很不优。

我们考虑离线：也就是说，我们开始预知这个数后面都是什么数。依据后面数的情况，我们考虑 $P$ 放在哪里。

考虑紧跟在 $P$ 后方最长的一串数，满足这些数都在栈顶。如果不考虑当前 $P$ 的去向，那么直接将这些数放到对应的栈，和栈顶相消即可，如果再来就仍然放置原来的栈顶。比如 $5$ 是某个栈的栈顶，如果 $P$ 后面来了个 $5$ 就让它和 $5$ 相消，如果再来一个 $5$ 就放在原来的栈顶，如果再来就继续相消。因此我们发现，这些数还是相当自由的，我暂且称之为自由相消。

因此发现，如果 $P$ 后面第一个不在栈顶上的数是 $P$，那么我们就把当前的 $P$ 放入辅助栈，然后接下来的数自由相消，最后在第二个 $P$ 来时，将它也放入辅助栈，栈顶相消即可。这种情况比较简单。


现在讨论 $P$ 后面第一个不在栈顶上的数是一个栈底 $X$ 的情况。我们记其对应栈为 $S$。此时未来的数列是 $(P, \cdots, X)$，其中 $\cdots$ 都是某个栈的栈顶。我们讨论 $S$ 当前的栈顶 $Y$。

- 如果未来数列的 $P$ 和 $X$ 之间，$Y$ 出现了奇数次：把 $P$ 放入辅助栈，接下来一直自由相消，直到将处理 $X$ 为止。由于 $Y$ 的数量是奇数，加上一开始的一个 $Y$，此时 $Y$ 一定被消除光，现在 $S$ 的栈顶变成 $X$，将 $X$ 放入 $S$ 栈顶相消，$S$ 变成了空栈。
- 如果 $Y$ 出现了偶数次：把 $P$ 放入 $S$，未来所有不为 $Y$ 的栈顶自由相消，对于 $Y$，我们将其全部放入辅助栈相消，直到将处理 $X$ 为止。由于 $Y$ 的数量是偶数，这些 $Y$ 一定都被消除光，辅助栈仍为空，我们将 $X$ 放入辅助栈，和 $S$ 栈底相消，辅助栈仍为空。

经过上述操作后，局面总会保持：

- 存在一个空栈；
- 所有数都在栈中最多出现一次；
- 所有栈最多只有两个元素。

直接让新的空栈作为辅助栈即可。

如何证明这种做法一定可以报告出解？其实很简单：在最后，每种元素在所有栈中最多只能出现一次；每种数字数量均为偶数，相消永远是同种元素两两相消，所以到最后，某种数出现奇数次是不可能的。综合来看，每种元素到最后只能出现零次，也就是必定不会出现。

一个实现问题：怎么找当前还没满两个元素的栈？我们维护一个队列，存储栈的编号，使得始终满足：

- 如果一个栈当前存满两个元素，队列中不存在当前栈的编号；
- 如果一个栈当前只存了一个元素，让队列中该栈的编号出现一次；
- 如果一个栈当前为空，让队列中该栈的编号出现两次。
- **辅助栈的编号在队列中不能出现**。

一开始，我们直接让 $1 \sim n - 1$ 都推入队列各两次，$n$ 作为初始辅助栈不推入队列。

假如我们当前遇到了一个数 $x$，这个 $x$ 没还没出现在栈中，我们要给 $x$ 找一个没满的栈时，直接取队列的队头作为 $x$ 选择的栈编号，队列弹出队头即可。特别地，如果此时队列为空，证明除了辅助栈所有栈都满了，证明我们按照 $k = 2n-2$ 的策略走不下去，要开始特别处理了；

而当一个元素被弹出栈后，让元素所对应的栈的编号入队。

容易发现，这样就维护好了上面队列应该满足的四条性质。不过，辅助栈的编号可能会变动，要始终保证好它不出现在队列中是有些细节的。

时间复杂度 $\Theta(m)$。

```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2022-12-04 01:03:11 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2022-12-04 13:35:14
 */
#include <bits/stdc++.h>
inline int read() {
    int x = 0;
    bool f = true;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = false;
    for (; isdigit(ch); ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    return f ? x : (~(x - 1));
}

const int maxn = 305;
const int maxm = (int)2e6 + 5;

int a[maxm];
std :: deque <int> st[maxn];
int id[maxn * 2]; // 维护所在栈编号，局面未出现则为 0

typedef std :: pair <int, int> pii;
std :: vector <pii> ans;

inline void pu(int s) {
    ans.emplace_back(s, 0);
}

inline void de(int s, int t) {
    ans.emplace_back(s, t);
}

int spt; // 辅助栈编号
std :: queue <int> q; // 维护空栈

inline bool simple(int x) { // 尝试简单相消
    int s = id[x];
    if (!s) {
        if (q.empty())
            return false;
        id[x] = s = q.front();
        q.pop();
        pu(s);
        st[s].push_back(x);
    } else {
        id[x] = 0;
        q.push(s);
        if (x == st[s].back()) {
            pu(s);
            st[s].pop_back();
        } else {
            pu(spt);
            de(spt, s);
            st[s].pop_front();
        }
    }
    return true;
}

int main() {
    for (int T = read(); T; --T) {
        int n = read(), m = read(); read();
        for (int i = 1; i <= m; ++i)
            a[i] = read();
        std :: memset(id, 0, sizeof(id));
        ans.clear();
        spt = n;

        while (!q.empty())
            q.pop();
        for (int i = 1; i < n; ++i) {
            q.push(i);
            q.push(i);
        }
        
        for (int i = 1; i <= m; ++i) if (!simple(a[i])) {
            int p = a[i];
            int r = i + 1, x = a[r];
            for (; r <= m && x != p && st[id[x]].back() == x; ++r, x = a[r]);
            // 此时 r 是 i 后第一个不在栈顶上的下标，x 是 a[r]

            if (x == p) {
                pu(spt);
                for (int j = i + 1; j < r; ++j)
                    simple(a[j]);
                pu(spt);
            } else {
                int s = id[x], y = st[s].back();
                bool evn = true; // 中间栈顶中，y 的数量是否为偶数
                for (int j = i + 1; j < r; ++j)
                    if (a[j] == y)
                        evn = !evn;
                if (evn) {
                    pu(s);
                    st[s].push_back(p);
                    for (int j = i + 1; j < r; ++j) {
                        if (a[j] == y)
                            pu(spt);
                        else
                            simple(a[j]);
                    }
                    pu(spt);
                    de(spt, s);
                    st[s].pop_front();
                    // st[s] 从栈底到栈顶，原先为 x, y，现在为 y, p
                    // 依此更新 id
                    id[x] = 0;
                    id[p] = s;
                } else {
                    pu(spt);
                    st[spt].push_back(p);
                    for (int j = i + 1; j < r; ++j) {
                        if (a[j] == y)
                            pu(s); // 注意这里不要直接 simple(a[j])
                        // 原因是 s 即将变成 spt，所以暂时不能让 s 弹入 q
                        // 特判让 simple 函数此时不把 s 不弹入 q 也不行
                        // 假如 3 1 2 1 1 1 ....
                        // 如果直接不弹入 q，会造成后面的一串 1 1 1 无法正确弹入 s
                        // 最后暴力扫队列把 s 删除复杂度也不对
                        // 所以正确的做法就是不用 simple 函数
                        else
                            simple(a[j]);
                    }
                    pu(s);
                    st[s].clear();
                    // 原先辅助栈 spt 此时存在一个元素 p
                    // s 原先栈底到栈顶为 x，y， 现在为空
                    // s 作为新的 spt
                    // 依此更新 id 和 q
                    id[x] = id[y] = 0;
                    id[p] = spt;
                    q.push(spt);
                    spt = s;
                }
            }

            i = r; // 注意循环会自带 ++i，下一次循环 i = r + 1
        }

        printf("%d\n", (int)ans.size());
        for (pii p : ans) {
            if (p.second)
                printf("2 %d %d\n", p.first, p.second);
            else
                printf("1 %d\n", p.first);
        }
    }
}
```

删除注释和不必要的空格，并且仍然保持很高的可读性后，代码长度是不足 2K 的，几乎优于所有 AC 提交。而且，可读性非常好。

如果觉得这篇题解写得好，请不要忘记点赞，谢谢！

---

## 作者：E.Space (赞：47)

这是我的简易题解：

$k=2n-2$ 的时候直接留一个空栈，然后其它每个栈维护两个颜色。

这是我的 $15$ 分代码，如果想到做法的话，应该很好写：

```cpp
#include<bits/stdc++.h>
namespace io
{
	int F()
	{
		int n=0,F=0;
		char ch;
		while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));
		ch=='-'?F=1:n=ch-'0';
		while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';
		return F?-n:n;
	}
}
int top[3333],bot[3333];
struct op{
	int v,s1,s2;
};
int main()
{
	int T=io::F();
	while(T--){
		std::vector<op> ops;
		int n=io::F(),m=io::F(),k=io::F();
		for(int i=1;i<=m;++i){
			int a=io::F();
			int pl=a+1>>1;
			if(bot[pl]==a){
				ops.push_back((op){1,n,0});
				ops.push_back((op){2,pl,n});
				bot[pl]=top[pl];
				top[pl]=0;
			}
			else{
				ops.push_back((op){1,pl,0});
				if(top[pl]==a)top[pl]=0;
				else if(bot[pl]==0)bot[pl]=a;
				else top[pl]=a;
			}
		}
		printf("%ld\n",ops.size());
		for(auto p: ops){
			if(p.v==1)printf("1 %d\n",p.s1);
				else printf("2 %d %d\n",p.s1,p.s2);
		}
	}
	return 0;
}
```

$k=2n-1$ 的时候如果第 $2n-1$ 种颜色加入，那么检查下一种栈底元素或者自身出现的位置。如果自身先于任何一个栈底元素出现，那么将它放入空栈中。如果一个栈底元素先出现，那么检查这个元素上面的元素在它之前出现奇数次还是偶数次。如果是偶数次就把新元素插入在这个栈栈顶，最后用空栈消去栈底元素。如果是奇数次就把新元素插入空栈，然后从栈顶消去那个栈底元素。

不过我的主要目的是说说 $n=2$ 的部分分怎么做。发现大部分没有通过本题的选手都没有拿到这一档部分分。

第一种思路，也是我最先考虑到的思路是，$n=2$ 相当于往一根两端开口的管子里塞卡牌，两张相邻的卡牌消去。往管道的左边塞牌就相当于放入第一个栈。往右边塞牌就相当于放入第二个栈。消除时若两张相邻的牌在不同栈里，就使用一次操作 $2$。

然后考虑加入第三种颜色的牌的情况。这时看下一张牌的颜色。此时一定有一种方式使得加入这第三种颜色的牌之后，下一张牌没有被夹在中间。于是下一张牌进来时就可以消除了。这种方法很好写。

第二种思路是，如果两张相同的牌之间没有牌或者只有一张别的牌，那么可以考虑把这两张牌放在同一个栈里。如果它们之间有一张牌，那么就放在与这张牌放的栈不同的那个栈里。然后从序列中删去这两张牌。

到不能消之后剩下的牌会形如 `123123123123...` 的循环，这时候只要随便构造一下 `123123` 怎么消就行，然后不断重复就好了。这种方法很难写。

这是我的正解程序：

```cpp
#include<bits/stdc++.h>
namespace io
{
	int F()
	{
		int n=0,F=0;
		char ch;
		while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));
		ch=='-'?F=1:n=ch-'0';
		while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';
		return F?-n:n;
	}
}
int last;
int a[2222222];
int pos[11111];
int top[3333],bot[3333];
int q[2222222],hq,tq;
struct op{
	int v,s1,s2;
	op(int x,int y,int z):v(x),s1(y),s2(z){}
};
void remove_top(std::vector<op>& ops, int& p){
	ops.emplace_back(1,p,0);
	top[p]=0;
	q[tq++]=p;
	p=0;
}
void remove_bot(std::vector<op>& ops, int& p){
	ops.emplace_back(1,last,0);
	ops.emplace_back(2,-p,last);
	pos[top[-p]]*=-1;
	bot[-p]=top[-p];
	top[-p]=0;
	q[tq++]=-p;
	p=0;
}
void push(std::vector<op>& ops, int c){
	int pl=q[hq++];
	ops.emplace_back(1,pl,0);
	if(bot[pl]){
		top[pl]=c;
		pos[c]=pl;
	}
	else{
		bot[pl]=c;
		pos[c]=-pl;
	}
}
int main()
{
	int T=io::F();
	while(T--){
		int n=io::F(),m=io::F(),k=io::F();

		for(int i=1;i<=m;++i){
			a[i]=io::F();
		}
		hq=tq=1;
		for(int i=1;i<n;++i){
			q[tq++]=i;
			q[tq++]=i;
		}
		last=n;
		std::vector<op> ops;
		for(int i=1;i<=m;++i){
			int &p=pos[a[i]];
			if(p>0){
				remove_top(ops,p);
			}
			else if(p<0){
				remove_bot(ops,p);
			}
			else if(hq!=tq){
				push(ops,a[i]);
			}
			else{
				int j=i+1;
				while(pos[a[j]]>0)++j;
				if(a[i]==a[j]){
					ops.emplace_back(1,last,0);
					for(++i;i<j;++i){
						if(pos[a[i]]){
							remove_top(ops,pos[a[i]]);
						}
						else{
							push(ops,a[i]);
						}
					}
					ops.emplace_back(1,last,0);
				}
				else{
					int cnt=0;
					int cr=top[-pos[a[j]]],crp=pos[cr];
					int now=a[i];
					for(int l=i+1;l<j;++l){
						cnt^=a[l]==cr;
					}
					if(cnt){
						ops.emplace_back(1,last,0);
						for(++i;i<j;++i){
							if(pos[a[i]]){
								remove_top(ops,pos[a[i]]);
								if(a[i]==cr)--tq;
							}
							else if(a[i]==cr){
								q[--hq]=crp;
								push(ops,cr);
							}
							else{
								push(ops,a[i]);
							}
						}
						ops.emplace_back(1,crp,0);
						bot[last]=now;
						pos[a[i]]=0;
						pos[now]=-last;
						q[tq++]=last;
						last=crp;
						bot[last]=0;
					}
					else{
						ops.emplace_back(1,crp,0);
						for(++i;i<j;++i){
							if(a[i]==cr){
								ops.emplace_back(1,last,0);
							}
							else if(pos[a[i]]){
								remove_top(ops,pos[a[i]]);
							}
							else{
								push(ops,a[i]);
							}
						}
						ops.emplace_back(1,last,0);
						ops.emplace_back(2,crp,last);
						pos[a[i]]=0;
						pos[cr]*=-1;
						pos[now]=crp;
						bot[crp]=cr;
						top[crp]=now;
					}
				}
			}
		}
		printf("%ld\n",ops.size());
		for(auto p: ops){
			if(p.v==1)printf("1 %d\n",p.s1);
				else printf("2 %d %d\n",p.s1,p.s2);
		}
	}
	return 0;
}
```


---

## 作者：周子衡 (赞：29)

好题，为出题人点赞。这里提供一个稍微不一样的做法。

我们先来考虑 $k=2n-2$ 的情形。一个自然的想法是，我们保留一个栈为空，同时其他的栈都至多放 $2$ 个元素。这样的话，每次处理一张牌时，如果这张牌的图案出现在某个栈的顶部，那么我们可以直接扔到该栈栈顶消掉；如果出现在某个栈的底部，那么把这张牌扔到空栈里，然后把两个栈栈底同时消掉；否则扔到某个某个未满的栈里即可。由于至多只有 $2n-2$ 种图案，这样的方法总是行得通的。

接下来考虑 $k=2n-1$ 的情形。上面的做法直接套用会遇到一个问题：可能当前 $2n-2$ 种图案已经把 $n-1$ 个栈都占满了，接下来又出现了剩下的那种图案（记为 $u$）。此时如果把它扔到空栈里，会让其他栈的栈底弹不出来；如果扔到满的栈上，又会让这个栈的中间元素处境非常尴尬。我们需要灵活处理这样的情况。

解决方案是这样的。记当前所有在栈顶的 $n-1$ 个元素构成集合 $S$。我们不断扫描之后的图案，直到遇到第一个不在 $S$ 中的图案为止。（注意到由于每个元素在总操作序列中出现的次数都是偶数，故每个元素之后都还会出现至少一次。）

- 如果这个图案就是 $u$：我们把之前的 $u$ 和现在的 $u$ 都扔到空栈里，它们就消掉了。中间的所有元素都是栈顶，可以直接扔到对应的栈上。
- 如果这个图案不是 $u$：那么这个图案 $v$ 是某个栈 $P$ 的栈底。记 $P$ 的栈顶为 $w$，我们来讨论 $w$ 在刚刚扫描过的所有图案中出现次数的奇偶性：
- - 奇数次：我们把 $u$ 扔到空栈里，所有的 $w$ 都扔到 $P$ 里。这样 $v$ 再次出现的时候，$P$ 上面的 $u$ 被清空了，此时可以直接把 $v$ 消掉，$P$ 变成新的空栈。
  - 偶数次：我们把 $u$ 扔到 $P$ 里，所有的 $w$ 也扔到 $P$ 里。这样 $v$ 再次出现的时候，$P$ 中自顶到底分别是 $u,w,v$ 三个元素。把 $v$ 扔进空栈里，再消掉 $P$ 和空栈的栈底，这样就仍然维持了 $P$ 中只有两个元素的条件。
- 这个过程中，其他栈顶元素扔到对应栈顶即可。

这样我们就解决了此题。时间复杂度 $O(m)$。

一些题外话：如果游戏更改一下规则，例如

- 玩家必须在读入每个图案后就立即决定该图案应该放进那个栈里。

那么 $k=2n-1$ 时很有可能玩家是必败的。这也启示我们在作当前决策时必须考虑之后的图案。考虑到这一点后本题就不是特别棘手了。

```cpp
#include<cstdio>
#include<vector>

using namespace std;

int up[3000],down[3000],val[3000][2],sz[3000],a[3000000];
int sta[3000];

int main()
{
	//freopen("meow.in","r",stdin);
	//freopen("meow.out","w",stdout);
	int TT=0;scanf("%d",&TT);
	while(TT--)
	{
		int n=0,m=0,k=0;scanf("%d%d%d",&n,&m,&k);for(int i=1;i<=m;i++)scanf("%d",&a[i]);
		k=2*n-1;
		vector<int> L;for(int i=1;i<n;i++)L.push_back(i);
		vector<pair<int,int> > V;
		int empty=n;
		for(int l=1,r=0;l<=m;l=r+1)
		{
			r=l;int i=l;
			if(down[a[i]])
			{
				int u=down[a[i]];
				V.push_back(make_pair(empty,0));V.push_back(make_pair(u,empty));
				//printf("1 %d\n",empty);printf("2 %d %d\n",u,empty);
				if(sz[u]==2){int v=val[u][1];val[u][0]=v,val[u][1]=0;sz[u]=1;up[v]=0,down[v]=u;L.push_back(u);}
				else{val[u][0]=0;sz[u]=0;}
				down[a[i]]=0;
			}
			else if(up[a[i]])
			{
				int u=up[a[i]];
				V.push_back(make_pair(u,0));
				//printf("1 %d\n",u);
				up[a[i]]=0;sz[u]=1;val[u][1]=0;
				L.push_back(u);
			}
			else if(!L.empty())
			{
				int u=L.back();L.pop_back();
				V.push_back(make_pair(u,0));
				//printf("1 %d\n",u);
				if(sz[u]==0)
				{
					val[u][0]=a[i];sz[u]=1;down[a[i]]=u;
					
					L.push_back(u);
				}
				else
				{
					val[u][1]=a[i];sz[u]=2;up[a[i]]=u;
				}
			}
			else
			{
				while(r+1<=m)
				{
					r++;
					if(a[r]==a[i])
					{
						V.push_back(make_pair(empty,0));
						//printf("1 %d\n",empty);
						for(int x=l+1;x<r;x++)
						{
							V.push_back(make_pair(up[a[x]],0));
							//printf("1 %d\n",up[a[x]]);
						}
						for(int x=l+1;x<r;x++)if(up[a[x]]&&sta[up[a[x]]])
						{
							int u=up[a[x]];
							sta[u]=0;val[u][1]=0;up[a[x]]=0;sz[u]=1;
							
							L.push_back(u);
						}
						V.push_back(make_pair(empty,0));
						//printf("1 %d\n",empty);
						break;
					}
					if(down[a[r]])
					{
						int u=down[a[r]];
						if(sta[u])
						{
							V.push_back(make_pair(empty,0));
						//printf("1 %d\n",empty);
						}
						else
						{
							V.push_back(make_pair(u,0));
							//printf("1 %d\n",u);
						}
						
						for(int x=l+1;x<r;x++)
						{
							V.push_back(make_pair(up[a[x]],0));
							//printf("1 %d\n",up[a[x]]);
						}
						for(int x=l+1;x<r;x++)if(up[a[x]]&&sta[up[a[x]]]&&up[a[x]]!=u)
						{
							int u=up[a[x]];
							sta[u]=0;val[u][1]=0;up[a[x]]=0;sz[u]=1;
							
							L.push_back(u);
						}
						
						if(sta[u])
						{
							V.push_back(make_pair(u,0));
							//printf("1 %d\n",u);
							
							sta[u]=0;
							
							down[val[u][0]]=up[val[u][1]]=0;
							val[u][0]=val[u][1]=0;sz[u]=0;
							
							down[a[l]]=empty;val[empty][0]=a[l];sz[empty]=1;
							L.push_back(empty);
							
							empty=u;
						}
						else
						{
							V.push_back(make_pair(empty,0));
							V.push_back(make_pair(u,empty));
							//printf("1 %d\n",empty);
							//printf("2 %d %d\n",u,empty);
							
							down[val[u][0]]=0;
							up[val[u][1]]=0;down[val[u][1]]=u;
							up[a[l]]=u;
							
							val[u][0]=val[u][1];val[u][1]=a[l];
							sz[u]=2;
						}
						
						break;
					}
					sta[up[a[r]]]^=1;
				}
			}
		}
		printf("%d\n",V.size());
		for(int i=0;i<V.size();i++)
		{
			if(V[i].second==0)printf("1 %d\n",V[i].first);
			else printf("2 %d %d\n",V[i].first,V[i].second);
		}
	}
}
```

---

## 作者：Rainbow_qwq (赞：25)

估计是出题人觉得简单才放在 T2 的，但思路虽然明了很有可能想错。

赛时想法：

- 好像很不好做，但留一个空栈，钦定 $2(n-1)$ 个不同元素每个栈放两个，就能做 $k=2n-2$ 了。
- 发现 $k=2n-1$ 会有新的数加进来冲突。手玩发现有两种情况需要新的数必须放在某个栈顶或者新的数必须放在空栈，最后才能消空。
- 然后分类讨论怎样才能让若干轮后再消出一个空栈，这部分想的最久，最后还假了。

实际上要理清思路，尽量让新加的数**影响最小**的方向讨论。

设新的数是 $x$。如果新的数堵住了一个栈顶那么来一个这种栈顶就 GG 了。堵住了空栈那么来一个栈底的就 GG 了。

观察到**堵住空栈的影响更大**，于是考虑下一个出现的 $x$ 和下一个出现的某个栈底，如果下一个出现的是 $x$ 那么可以放空栈里，没影响到栈底。

如果某个栈底先出现，设这个栈底为 $u$，栈顶为 $v$。考虑到下一个 $u$ 出现时 $v$ 出现的次数：

如果 $v$ 出现了偶数次，把 $x$ 丢在栈顶，后面来的 $v$ 都丢在空栈里，最后空栈会空出来。

如果 $v$ 出现了奇数次，把 $x$ 丢在空栈，后面来的 $v$ 丢在栈顶，这样栈底来的时候 $v$ 已经被奇数个 $v$ 干掉了，可以直接丢进栈里面。

模拟上述过程即可，可以做到 $O(n+m)$。

---

## 作者：SSH_automaton (赞：24)

此题解纪念我第一次在 NOIP 考场上通过 T2。

首先考虑 $k = 2n - 2$ 的情况。这种情况只要用前 $n - 1$ 个栈放卡牌，最后一个栈用来消除下层卡牌。

定义“简单情况”表示所有栈中卡牌数量均不超过 2，且至少有一个空栈的情况。每种卡牌的第奇数、偶数张分别称为入栈牌、出栈牌。

再考虑 $k = 2n - 1$。如果现在已经有 $n - 1$ 个放了 2 张卡牌的栈和一个空栈，当前的牌为入栈牌，一种方法是放在空栈，另一种方法是放在一个已经有 2 张卡牌的栈顶。

但是，这两种方法都存在问题。方法一放完之后不存在空栈，如果接下来出现下层卡牌的出栈牌，那就寄了。方法二放完之后会存在一个有 3 张卡牌的栈，中间的牌消不掉。

注意到 3 张卡牌的栈如果在遇到中间牌的出栈牌之前就变成 2 张卡牌，就不会存在问题。所以，使用方法二时要找到一个上层牌出栈比下层牌晚的栈，下层牌必定先被消除，而其他栈里的牌都能在自己的栈和空栈中解决，不会有影响。消除之后就转化为简单情况。

如果找不到这样的栈怎么办？不存在上层牌出栈比下层牌晚的栈，则消除下层牌之前，对应的上层牌必定被消除。所以用方法一即可。

但是可能存在上层牌出栈之后立刻入栈的情况。对于这种情况，入栈时进行微调，选择有 1 张牌，且这张牌出栈较晚的栈放入即可。这样可以保证在消除第一张下层牌时，这张牌在栈顶，消除这张牌即可转化为简单情况。

最后利用空栈进行消除即可。

总结一下放牌的方法：遇到入栈牌，如果存在两个以上空栈，放入空栈即可；否则找有 1 张牌的栈，放入牌出栈最晚的栈；若没有，找有 2 张牌，且上层牌出栈比下层牌晚的栈；再找不到，就放入空栈。遇到出栈牌，如果消除的牌在栈顶，直接消去。如果消除的牌在栈底，此时必然存在空栈，利用空栈消除。

用 3 个 set 分别维护有 0 张、1 张、2 张牌的栈。

时间复杂度 $O(S \log n)$。据说可以线性，但是我不会。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef pair<int, int> pii;
const int N = 2e6 + 5;
int T, n, m, k;
int tim[N], last[N], a[N], pos[N];
int len[N], out[N][4];
set<pii, greater<pii>> q[3];

struct Triple {
	int x, y, z;
	
	Triple(int _x = 0, int _y = 0, int _z = 0) : x(_x), y(_y), z(_z) {}
};

vector<Triple> ans;

inline void put(int x, int s) {
	pos[x] = s;
	ans.emplace_back(1, s, 0);
}

void solve() {
	for (int i = 1; i <= m; ++i) {
		if (last[a[i]]) tim[last[a[i]]] = i, last[a[i]] = 0;
		else last[a[i]] = i;
	}
	for (int i = 1; i <= n; ++i) {
		q[0].insert(pii(0, i));
		len[i] = 0;
	}
	for (int i = 1; i <= m; ++i) {
		if (tim[i]) {
			last[a[i]] = i;
			if (q[0].size() >= 2u) {
				auto it = q[0].begin();
				int id = it->second;
				q[0].erase(it);
				out[id][++len[id]] = i;
				put(i, id);
				q[1].insert(pii(tim[i], id));
				continue;
			}
			if (!q[1].empty()) {
				auto it = q[1].begin();
				int id = it->second, t = it->first;
				q[1].erase(it);
				out[id][++len[id]] = i;
				put(i, id);
				q[2].insert(pii(tim[i] > t, id));
				continue;
			}
			if (!q[2].empty() && q[2].begin()->first) {
				auto it = q[2].begin();
				int id = it->second;
				q[2].erase(it);
				out[id][++len[id]] = i;
				put(i, id);
				continue;
			}
			auto it = q[0].begin();
			int id = it->second;
			q[0].erase(it);
			out[id][++len[id]] = i;
			put(i, id);
			q[1].insert(pii(tim[i], id));
		} else {
			int j = last[a[i]], id = pos[j];
			if (out[id][len[id]] == j) {
				ans.emplace_back(1, id, 0);
				if (len[id] == 1)
					q[1].erase(pii(tim[out[id][1]], id));
				else if (len[id] == 2)
					q[2].erase(pii(tim[out[id][2]] > tim[out[id][1]], id));
				--len[id];
				if (len[id] == 0)
					q[0].insert(pii(0, id));
				else if (len[id] == 1)
					q[1].insert(pii(tim[out[id][1]], id));
				else
					q[2].insert(pii(tim[out[id][2]] > tim[out[id][1]], id));
			} else {
				int tmp = q[0].begin()->second;
				ans.emplace_back(1, tmp, 0);
				ans.emplace_back(2, id, tmp);
				if (len[id] == 1)
					q[1].erase(pii(tim[out[id][1]], id));
				else if (len[id] == 2)
					q[2].erase(pii(tim[out[id][2]] > tim[out[id][1]], id));
				--len[id];
				for (int k = 1; k <= len[id]; ++k)
					out[id][k] = out[id][k + 1];
				if (len[id] == 0)
					q[0].insert(pii(0, id));
				else if (len[id] == 1)
					q[1].insert(pii(tim[out[id][1]], id));
				else
					q[2].insert(pii(tim[out[id][2]] > tim[out[id][1]], id));
			}
		}
	}
	cout << ans.size() << '\n';
	for (auto res : ans) {
		if (res.x == 1)
			cout << "1 " << res.y << '\n';
		else 
			cout << "2 " << res.y << ' ' << res.z << '\n';
	}	
}

inline void clear() {
	int mx = max({n, m, k});
	for (int i = 1; i <= mx; ++i)
		tim[i] = last[i] = a[i] = pos[i] = len[i] = 0;
	q[0].clear();
	q[1].clear();
	q[2].clear();
	ans.clear();
}

int main() {
	freopen("meow.in", "r", stdin);
	freopen("meow.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> T;
	while (T--) {
		cin >> n >> m >> k;
		for (int i = 1; i <= m; ++i)
			cin >> a[i];
		solve();
		clear();
	}
	return 0;
} 
```


---

## 作者：Iratis (赞：17)

~~嗯，这破题，真的很让人讨厌。~~

首先，观察数据范围，发现 $ k $ 只有两种情况，直接入手。

当 $ k=2n-2 $ 时，给前 $ n-1 $ 个栈每个分配两种颜色，这样每次遇到需要消除的情况时只需要在空栈中操作，必然能够完成。

当 $ k=2n-1 $ 时，发现之前的做法不能成立，倘若极限情况下前 $ n-1 $ 个栈堆满后又来一种新的颜色，此时就无法放置，所以我们做出一些变化。

记录 $ nxt $ 数组，记录一张牌后面第一张与它匹配的牌的位置，特别地，对于被用来匹配的牌不记录。

假如前 $ n-1 $ 个栈未放满或放满后仍然未出现多余的颜色，此时直接按照上文所述的做即可，接下来讨论最麻烦的情况，即放满后出现了多余的颜色。

我们考虑前 $ n-1 $ 个栈中栈顶和栈底元素 $ nxt $ 的关系。倘若我们发现存在一个栈，它的栈顶元素 $ nxt $ 值大于栈底元素 $ nxt $ 值，那么可以将新元素放在该栈上，因为在消除栈顶元素前一定会先消除栈底元素。倘若不存在，便说明在所有栈底元素中 $ nxt $ 最小的元素消除前，消除操作一定都是在栈顶进行，那么可以将新元素放入原本的空栈，等到消除出一个新的空栈，而上文的限制则保证了操作的合法性。

于是记录出空栈位置 $ Free $，及时更新即可。

感觉写的还行吧：

```cpp
#include<iostream>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
#define md(a) a=(a%mod+mod)%mod
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
const int Ns=305,Ncd=4000005,Ncol=705;
int T,Now;
int n,m,Num,col[Ncd];
int nxt[Ncd],las[Ncol];
int Free,st[Ns][2];
struct Do{int op,x,y;};
vector<Do>Res;
void Clear()
{
	Res.clear();
	for(int i=1;i<=n;i++)st[i][0]=st[i][1]=0;
	for(int i=1;i<=m;i++)nxt[i]=0;
	for(int i=1;i<=Num;i++)las[i]=0;
}
void Up(int x){Res.push_back({1,x,0});}
void Down(int x,int y){Res.push_back({1,y,0}),Res.push_back({2,min(x,y),max(x,y)});}
pair<int,int>Fcol(int c){for(int i=1;i<=n;i++){if(col[st[i][0]]==c)return {i,0};if(col[st[i][1]]==c)return {i,1};}}
int Fsta(){for(int i=1;i<=n;i++)if(i!=Free&&st[i][0]==0)return i;return -1;}
int Fuld(){for(int i=1;i<=n;i++)if(i!=Free&&nxt[st[i][0]]>nxt[st[i][1]])return i;return -1;}
int Fmin(){pair<int,int>ans={m+1,0};for(int i=1;i<=n;i++)if(i!=Free)ans=min(ans,{nxt[st[i][1]],i});return ans.second;}
void Use_Normal(int i)
{
	if(nxt[i]==0)
	{
		pair<int,int>Pos=Fcol(col[i]);
		int x=Pos.first,y=Pos.second;
		if(y==0)Up(x),st[x][0]=0;
		else Down(x,Free),st[x][1]=st[x][0],st[x][0]=0;
	}
	else
	{
		int Pos=Fsta();
		Up(Pos),st[Pos][(st[Pos][1]==0)]=i;
	}
}
int Use_Free(int i)
{
	int Pos=Fuld();
	if(Pos!=-1)
	{
		Up(Pos);int mn=min(nxt[st[Pos][1]],nxt[i]);
		for(int j=i+1;j<=mn-1;j++)Use_Normal(j);
		if(nxt[st[Pos][1]]<nxt[i])Down(Pos,Free),st[Pos][1]=st[Pos][0],st[Pos][0]=i;
		else Up(Pos);
		return mn+1;
	}
	else
	{
		Pos=Fmin(),Up(Free);
		int mn=min(nxt[st[Pos][1]],nxt[i]);
		if(nxt[st[Pos][1]]<nxt[i])st[Free][1]=i,Free=Pos;
		for(int j=i+1;j<=mn-1;j++)Use_Normal(j);
		if(nxt[st[Pos][1]]<nxt[i])Up(Pos),st[Pos][1]=0;
		else Up(Free),st[Free][1]=0;
		return mn+1;
	}
}
void Start()
{
	if(n==1){for(int i=1;i<=m;i++)Up(1);return ;}
	Free=n;
	for(int i=1;i<=m;)
	{
		if(nxt[i]==0)Use_Normal(i),i++;
		else
		{
			int Pos=Fsta();
			if(Pos!=-1)Up(Pos),st[Pos][(st[Pos][1]==0)]=i,i++;
			else i=Use_Free(i);
		}
	}
}
void Play_Game()
{
	scanf("%d%d%d",&n,&m,&Num);
	for(int i=1;i<=m;i++)scanf("%d",&col[i]);
	for(int i=1;i<=m;i++)
	{
		if(las[col[i]])nxt[las[col[i]]]=i,las[col[i]]=0;
		else las[col[i]]=i;
	}
	Start();
	cout<<Res.size()<<endl;
	for(Do x:Res)
	{
		if(x.op==1)printf("1 %d\n",x.x);
		else printf("2 %d %d\n",x.x,x.y);
	}
	Clear();
}
signed main()
{
	scanf("%d",&T);
	while(T--)Play_Game();
	return 0;
}
```


---

## 作者：BqtMtsZDnlpsT (赞：14)

upd on 12/4 修复一个小锅。



------------


不做评价，其实不难。

首先 $k=2n-2$ 的情况应该大家都会。

先给种类两两分组，并给每一组分配一个栈，不难发现有个空栈。

出现一个数时，若已经存在这个数，那就根据它在：

- 栈顶：直接放到该栈的上方消去。
- 栈底：放入空栈，然后用操作 $2$ 消去。

可以发现，空栈在每出现一个数的操作结束之后，必然为空。

---

想一想 $k=2n-1$ 会出现的极端时候。

那一定是局面上放满了东西。

放进去不是放在一个大小为 2 的栈的上面，就是在空栈。

设这个放进去的数为 $t$。

如果放在大小为 2 的栈上面，那么这个栈底要抽掉，这样才符合每个栈大小都是 $2$ 的美好希望。

栈底要抽掉，那么栈顶不能出现，否则一放上来，就 GG。

所以**找下一个出的栈底，并且这时候栈顶还没出。把 $t$ 放在栈顶。**

进过一系列操作后，原来的栈底出去了，栈顶变成了新栈底，$t$ 变成栈顶。

---

还有一种比较简单的情况。

就是在每个栈底都还未出的时候，出现了 $t$。

**直接把 $t$ 放进空位，等待下一个 $t$。**

因为后面只会 出/入 栈顶，所以空栈没有用，正好给 $t$ 用。

---

如果不满足以上两种情况。

因为这个时候，找下一个出的栈底（设为 $u$，与之对应的栈顶为 $v$），$v$ 一定在之前出现过。

所以我的想法就是把那个栈变成新的空栈。

具体的，**先把 $t$ 放入空栈，在第一次 $v$ 出现（这时候）的时候，按正常操作，将 $v$ 放入它所在的栈将其消除。第二次及以后的出现，放在 $t$ 的上面。$u$ 出现后，会带来一个新的空栈。**

以上就是全部。

分类讨论很麻烦。

附上赛时去注释代码。

复杂度 $O(m)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned ll
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3fll
#define For(i_,l_,r_) for(int i_=(l_);i_<=(r_);i_++)
#define Rep(i_,l_,r_) for(int i_=(l_);i_>=(r_);i_--)
using namespace std;
#define Ci const int
#define Cl const ll
#define Cul const ull
#define Cc const char
int _l=-1,_p;Ci inS=1<<18,ouS=1<<18;
char _c[inS],*_u=_c,*_v=_c,_b[ouS],_d[55];
#define getchar() (_u==_v&&(_v=(_u=_c)+fread(_c,1,inS,stdin),_u==_v)?EOF:*_u++)
#define _c_ getchar()
template<typename T=int>inline T read(){
	char ch=_c_;T X=0;bool fl=0;while(ch<48||ch>57)fl|=(ch==45),ch=_c_;
	while(ch>47&&ch<58)X=X*10+(ch^48),ch=_c_;return fl?-X:X;
}
inline char Gec(){
	char ch=_c_;while(ch<33)ch=_c_;return ch;
}
inline void flush(){fwrite(_b,1,_l+1,stdout);_l=-1;}
inline void _pc(Cc c){if(c!=-1)_b[++_l]=c;}
inline void _chf(){if(_l>(ouS>>1))flush();}
template<typename T=int>inline void write(T x,Cc c=-1){
	if(x<0)_pc(45),x=-x;do{_d[++_p]=(x%10)|48;}while(x/=10);
	do{_b[++_l]=_d[_p];}while(--_p);_pc(c);_chf();
}
inline void write(Cc c){_pc(c);}
inline void puc(Cc c){_pc(c);_chf();}
template<typename T,typename...A>void write(T x,A...a){write(x);write(a...);}
int n,m,k,a[2000005];
struct Q{
	int op,x,y;
}ans[4000005];int ansl;
int st[305][3],l[305];
int G[1005],L,emp;
int vis[1005],GG[1005],tuu[1005];
inline void work(Ci op,Ci x,Ci y){
	ans[++ansl]={op,x,y};
}
inline void ypa(){
	n=read(),m=read(),k=read();
	For(i,1,m)a[i]=read();
	emp=1;
	For(i,2,n)G[++L]=i;
	For(i,1,m){
		while(L&&l[G[L]]>=2)--L;
		if(!vis[a[i]]){
			if(!L){
				For(i,1,k)GG[i]=0,tuu[i]=vis[i];
				For(j,i+1,m){
					int I=vis[a[j]];
					if(st[I][0]==a[j]){
						if(!GG[st[I][1]]){
							work(1,I,0);
							st[I][l[I]++]=a[i];
							vis[a[i]]=I;
						}
						else{
							int now=st[I][1],fl=0;
							work(1,emp,0);
							st[emp][l[emp]++]=a[i];
							vis[a[i]]=emp;
							For(J,i+1,j-1){
								if(vis[a[J]]){
									int II=vis[a[J]];
									work(1,II,0),--l[II];
									vis[a[J]]=0;
								}
								else{
									int II;
									if(a[J]==now&&!fl){
										II=emp;
										work(1,II,0);fl=1;
										st[II][l[II]++]=a[J];
										vis[a[J]]=II;tuu[a[J]]=II;
									}
									else{
										II=tuu[a[J]];
										work(1,II,0);
										st[II][l[II]++]=a[J];
										vis[a[J]]=II;
									}
								}
							}
							work(1,I,0);--l[I];vis[a[j]]=0;
							emp=I;i=j;
						}
						break;
					}
					else{
						GG[a[j]]=1;
						if(a[j]==a[i]){
							work(1,emp,0);
							st[emp][l[emp]++]=a[i];
							vis[a[i]]=emp;
							break;
						}
					}
				}
				L=0;
				For(i,1,n)
					if(l[i]<2&&i!=emp)G[++L]=i;
			}
			else{
				int I=G[L];
				work(1,I,0);
				st[I][l[I]++]=a[i];
				if(l[I]>=2)--L;
				vis[a[i]]=I;
			}
		}
		else{
			int I=vis[a[i]];
			if(l[I]>=2&&st[I][0]==a[i]){
				work(1,emp,0);
				work(2,emp,I);
				--l[I];
				st[I][0]=st[I][1];
				st[I][1]=st[I][2];
			}
			else work(1,I,0),--l[I];
			if(l[I]<2&&I!=emp)G[++L]=I;vis[a[i]]=0;
		}
	}
	write(ansl,'\n');
	For(i,1,ansl){
		if(ans[i].op==1)write(ans[i].op,' ',ans[i].x,'\n');
		if(ans[i].op==2)write(ans[i].op,' ',ans[i].x,' ',ans[i].y,'\n');
	}
	flush();
	ansl=0;L=0;
	For(i,1,k)vis[i]=GG[i]=tuu[i]=G[i]=0;
	For(i,1,n)l[i]=st[i][0]=st[i][1]=st[i][2]=0;
}
signed main(){
//	freopen("meow.in","r",stdin);
//	freopen("meow.out","w",stdout);
	int T=read();
	For(I,1,T)ypa();
	flush();return 0;
}
```

---

## 作者：Brilliance_Z (赞：12)

### 从部分分 $k=2n-2$ 入手

这个数据特征启示我们将所有牌尽量往前 $n-1$ 个栈放，留第 $n$ 个栈作为空栈。

有了这个空栈，不难构造一种策略：将 $2n-2$ 种牌型平均分配到前 $n-1$ 个栈中。对于当前的牌 $i$，设其的种类为 $a_i$，种类 $a_i$ 应分配到的栈为 $s_i$。

- 若栈 $s_i$ 没有第 $a_i$ 种牌，则执行操作 $1$：将牌 $i$ 放入栈 $s_i$。
- 若栈 $s_i$ 已经有第 $a_i$ 种牌，且它在栈顶，则执行操作 $1$：将牌 $i$ 放入栈 $s_i$，并自动消除栈 $s_i$ 最上方的两张相同种类的牌。
- 若栈 $s_i$ 已经有第 $a_i$ 种牌，且它在栈底，则先执行操作 $1$：将牌 $i$ 放入栈 $n$；再执行操作 $2$：消除栈 $s_i$ 和栈 $n$ 的栈底两张相同种类的牌。

上面的策略会保证：**任意时候任意一个栈中最多只有 $2$ 张牌，且从牌堆中新拿一张牌时一定会存在空栈。栈顶的牌在栈顶直接消除，栈底的牌利用空栈消除。**

### 在部分分 $n=2$ 中，将 $k=2n-1$ 转化为 $k=2n-2$

$k=2n-1$ 相比于 $k=2n-2$ 多了一种牌。设当前第一个栈已经有 $2$ 张牌，**栈底的牌的种类为 $x$，栈顶的牌的种类为 $y$**，第二个栈为空栈。

如果将多出的这种牌放入空栈（第二个栈），可能导致空栈被占用而不能消除第一个栈的栈底的牌；如果将其放入第一个栈，可能导致第一个栈有 $3$ 张牌，不能消除中间的牌。我们把**多出的这种牌称为第 $3$ 者**。

从简单入手，设想一种很美好的情况：牌堆中第 $3$ 者后面全是 $y$。那么我们只要把第 $3$ 者放入空栈，$y$ 在栈顶直接消。这种情况显然不可能。因为当前第一个栈中已经有 $x$，所以**第 $3$ 者后面一定会存在 $x$**。

欸～是不是我们可以一次性对**牌堆中从当前的第 $3$ 者到第一张 $x$** 进行处理，处理完后将局面转化为 $k=2n-2$ 时的情况呢？可以！

1. 若牌堆中从第 $3$ 者到第一张 $x$ 的情况是 `3 x`：先执行操作 $1$：将第 $3$ 者放入第一个栈；再执行操作 $1$：将 $x$ 放入第二个栈；再执行操作 $2$：消除第一个栈和第二个栈的栈底两张相同种类的牌。
2. 若牌堆中从第 $3$ 者到第一张 $x$ 的情况是 `3 y y x`：先执行操作 $1$：将第 $3$ 者放入第二个栈；再执行操作 $1$：将 $y$ 放入第一个栈，并自动消除第一个栈最上方的两张相同种类的牌；再执行操作 $1$：将 $y$ 放入第二个栈；再执行操作 $1$：将 $x$ 放入第一个栈，并自动消除第一个栈最上方的两张相同种类的牌。此时空栈变成了第一个栈。

对于其他情况（从第 $3$ 者到第一张 $x$ 中有若干个 $3$ 和 $y$），可以把**多余的** $3$ 放在第二个栈的栈顶**消除**，把多余的 $y$ 放在第一个栈的栈顶消除，将**最后一张** $3$ 或 $y$ 学习上面两种情况的讨论进行类似的处理，具体细节见代码。

### 将部分分 $n=2$ 推广到正解 $n\le 300$

类似地，我们可以一次性对牌堆中从当前的第 $3$ 者到第一张栈底的牌（设该栈为 $s$，该栈的栈底的牌为 $s_x$、栈顶为 $s_y$）进行处理，处理完后将局面转化为 $k=2n-2$ 时的情况。

容易发现在牌堆从第 $3$ 者到第一张 $s_y$ 中我们只需要关心三种牌：$3,s_x,s_y$。因为**其他的牌都是其他栈的栈顶的牌，可以直接在他们各自的栈的栈顶直接消除**。现在我们仅需要利用栈 $s$ 和空栈对牌 $3,s_x,s_y$ 进行处理，发现这就是 $n=2$ 时的情况。

注意特判 $n=1$ 时的情况，此时没有空栈。

理论时间复杂度：$O(S)$。考场上为了代码方便，我写的是 $O(NS)$ 的代码。

具体代码见[剪贴板](https://www.luogu.com.cn/paste/l3cramtm)。

###### 后记

本题有一定的构造思维难度，但是又配之以大模拟，导致考场上想出 T2 构造思路的同学深陷大模拟；考场上对 T2 没思路的同学反而无形中被帮了一把，去写更划算的 T3 了。

---

## 作者：OMG_wc (赞：10)

首先操作次数的限制 $2m$ 可以完全不用管，因为 $1$ 操作只会进行 $m$ 次，而 $2$ 操作只要不进行无效的最多 $m\over2$ 次。

当卡牌种类 $k= 2n-2 =2(n-1)$ 时，可以把所有卡牌两两分组，让前 $n-1$ 个栈各属于两种卡牌，最后一个栈空着，称为特殊栈。

这样对于某个栈，来一个属于该栈的卡牌时，若和底部卡牌相同就利用特殊栈进行 $2$ 操作，否则就直接放上去。这样可以保证每时每刻，前 $n-1$ 个栈的卡牌个数不超过 $2$ 。

当 $k=2n-1$  时，此时会出现一种情况：$n-1$ 个栈都包含 $2$ 个卡牌了，此时又来最后一种卡牌。

设该卡牌为 $w$，找到 $n-1$ 个放满的栈中底部卡牌之后最先出现的栈 $x$ ，$x$ 栈底设为 $u$，栈顶设为 $v$，分下面三种情况讨论：

- 若 $w$ 的下一次出现时间早于 $u$ ，那么可以 $w$ 直接放到特殊栈（因为特殊栈的作用是消除底部，在 $u$ 下次出现之前都不会用到特殊栈）
- 若 $u$ 下次出现时间早于 $v$ ，那么可以把 $w$ 放到 $x$ 顶部（虽然此时栈内会有 $3$ 个卡牌导致中间的 $v$ 无法消除，但是 $u$ 会早于 $v$ 离开）
- 剩下的情况意味着下次出现的时间是 $v<u<w$ ，那么可以把 $w$ 放到特殊栈，然后规定接下来的特殊栈改为 $x$ （很明显在 $x$ 清空之前，都不会存在 $2$ 操作，所以没影响）

实现起来有很多细节，最开始写的 $O(mn)$ 的暴力版本跑了官方数据居然也能拿 $95$ 分，只会有一组数据超时。

优化成 $O(m)$ 要注意几个点：

- 需要一个数组维护每个卡牌当前所在栈的编号

- 需要一个队列来分配每个新来的卡牌属于哪个普通栈的，初始每个普通栈能提供两个空位，卡牌出栈会归还空位
- 查找下一个最先出现底部元素的栈，可以暴力往后找，因为下一次再出现放满栈的局面一定在底部元素出栈后（若是第一种情况 $w$ 先出，就循环到下个 $w$ 结束）。这样所有暴力找的部分不会有交叉，总循环次数不超过 $m$


[采用完全 STL 实现，写了 $90$ 多行，点我查看](https://www.luogu.com.cn/paste/p9kp120t)

---

## 作者：xrk2006 (赞：6)

# 【题解】P8866 [NOIP2022] 喵了个喵

[博客园食用效果更佳](https://www.cnblogs.com/xrkforces/p/luogu-P8866.html)

## 题目链接

[P8866 [NOIP2022] 喵了个喵](https://www.luogu.com.cn/problem/P8866)

## 题意概述

有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过规则将所有的卡牌消去。

开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1, a_2,\dots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。
- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。

要求构造一个操作序列，满足进行这些操作之后可以使得操作的牌堆和每个栈均为空。

## 数据范围

设 $S$ 为所有 $T$ 组数据中 $m$ 的总和。

对于所有数据，保证 $S \leq 2 \times 10^6$，$1 \leq n \leq 300$，$1 \leq a_i \leq k$。

|   测试点    |  $T=$  |    $n$     |  $k=$  | $m \leq$ |
| :---------: | :----: | :--------: | :----: | :------: |
|  $1\sim 3$  | $1001$ | $\leq 300$ | $2n-2$ |  无限制  |
|  $4\sim 6$  | $1002$ |    $=2$    | $2n-1$ |  无限制  |
| $7\sim 10$  |  $3$   |    $=3$    | $2n-1$ |   $14$   |
| $11\sim 14$ | $1004$ |    $=3$    | $2n-1$ |  无限制  |
| $15\sim 20$ | $1005$ | $\leq 300$ | $2n-1$ |  无限制  |

## 思路分析

注：为了方便起见，我们将题目中的**卡牌**称之为**元素**。

首先看到这个题目，可以尝试发现一些基本的结论：

我们最终一定进行了 $m$ 次第一种操作，和至多 $\frac{m}{2}$ 次第二种操作，那么操作次数 $op$ 一定满足 $m \le op \le  \frac{3}{2}m$，所以题目中关于 $op$ 的限制是没用的。 

观察数据范围就比较容易能联想到 NOIP2018 的旅行，说明解法一定与 $k$ 强相关。

所以我们可以考虑先从 $k$ 的部分分入手。

### $k=2n-2$

观察 $k$ 和 $n$ 的关系，发现 $k=2(n-1)$，即 $k$ 是 $n-1$ 的二倍，那么当我们把每两种元素放到一个堆里，恰好最后会剩下一个空栈。

那么我们就考虑直接钦定将 $2i$ 和 $2i-1$ 两种元素放在第 $i$ 个栈中，然后将空的栈 $n$ 作为辅助栈。

那么由于一个栈中只会放两种卡牌，所以任意时刻，一个栈中的元素**最多**为 $2$ 个：当栈中元素数量为 $2$ 时再加进来一个元素，那么这个元素一定与栈顶/栈底相同，一定可以相消使得元素个数 $\le 2$。

那么可以有以下解法：

假设当前我们要将 $x$ 放入栈中进行操作，考虑 $x$ 放入栈 $s$ 的操作：

- 若 $s$ 为空，直接入栈；
- 若 $s$ 有一个元素：
	- 该元素和 $x$ 相同，那么直接进行第一种操作：将 $x$ 入栈并将两个 $x$ 相消；
	- 该元素和 $x$ 不同，那么也直接进行第一种操作：将 $x$ 入栈。
- 若 $s$ 有两个元素：
	- 栈顶与 $x$ 相同，那么直接进行第一种操作：将 $x$ 入栈并将两个 $x$ 相消；
	- 栈底和 $x$ 相同，那么直接进行第二种操作：将 $x$ 加入辅助栈并将两个 $x$ 相消。

那么首先显然最后无论如何辅助栈一定为空：因为三类五种情况下只有最后一种情况会用到辅助栈且每次操作都能讲辅助栈清空。

且由于每个元素出现次数为偶数次，最后一次 $x$ 入栈也一定能将其它栈清空，所以这样做一定可以有解。

这部分分给了 15pts，虽然相对于正解还差别很大，但已经给了我们很大的启发来思考正解。

### $k=2n-1$

由于 $2n-1$ 只比 $2n-2$ 多了一个，所以我们可以想到：前 $2n-2$ 种元素还按照上述办法处理，只需要考虑 $x=2n-1$ 应该如何处理。

但如果直接沿用上述 $k=2n-2$ 的解法将会非常复杂，至于为什么之后再说。

考虑另一种使用上述解法的策略但抛开 $2i,2i-1$ 和栈 $i$ 绑定关系的一种做法：

我们同样在**初始时**将前 $n-1$ 个栈当做普通栈，第 $n$ 个栈当做辅助栈。

假设当前我们要将 $x$ 放入栈中进行操作，考虑 $x$ 放入栈中的操作：

- 当 $x$ 在之前的栈中**已经出现过**，假设 $x$ 之前出现在栈 $s$ 中。则我们可以按照 $k=2n-2$ 的策略将 $x$ 与栈 $s$ 中的另外一个 $x$ 进行简单相消，具体而言：
	- 当 $x$ 是 $s$ 的栈顶时，执行第一种操作；
	- 当 $x$ 是 $s$ 的栈底时，执行第二种操作。

- 当 $x$ 在之前的栈中**从未出现过**，则将 $x$ 加入到一个新的**没满两个元素**的栈中。若除了辅助栈之外的其它栈已满，那么发现此时已经不能用 $k=2n-2$ 进行操作了，我们考虑进行特殊操作。

发现此时我们已经基本解决了问题，只有最后一种情况当【所有普通栈已满】时的特殊操作还不知道应该怎么办。

那么我们接下来都来说明如何进行特殊操作。

当所有普通栈已满时，此时局面上一定是前 $n-1$ 个栈被元素摆满，且下一个入栈序列中的元素 $P$ 从未在之前的栈中出现过。

贪心的考虑是直接将 $P$ 放入辅助栈中，但假如 $P$ 后面跟了一个是前面栈中栈底的元素，那么本来直接将该元素放入辅助栈栈底就可以与前面的栈中元素进行操作 2 相消。但要是将 $P$ 放入辅助栈，那么这个元素就很难再抵消，不能最优。

由此可以发现我们的选栈策略实际上与 $P$ 后面的一串数有关。那么我们考虑离线：即分别考虑 $P$ 后面都有哪些数，然后再进行选栈。

- 对于 $P$ 后面在**栈顶**的元素：这些栈顶的数都很好解决，我们直接将他们放入原来的栈中简单相消即可。
- 对于 $P$ 后面本来就是 $P$ 的元素：显然可以将两个 $P$ 放在辅助栈然后直接相消，这时候辅助栈还是空的；
- 对于 $P$ 后面在**栈底**的元素：按理来讲，我们应该将它放在辅助栈中，然后与另外一个栈底元素相消；那么这时候操作完辅助栈还是空的

我们发现当 $P$ 的后面出现 $P$ 或者在**栈底**的元素时，我们可以将他们入栈之后直接结束特殊处理，因为无论如何将它们入栈之后都一定会出现至少一个空栈，这个空栈就变成了辅助栈，回到了正常相消的局面。而当 $P$ 后面在栈顶的元素入栈之后不一定会使得一定存在空栈，那么就不能回到正常相消的局面。

那么我们分类讨论考虑入栈序列中 $P$ 后面第一个**不在栈顶**的元素是什么：

- 当 $P$ 后面第一个不在栈顶的元素是 $P$ 时，那么此时的入栈序列一定是 $(P,\cdots,P)$，省略号表示了一段在栈顶的元素，那么我们将 $P$ 放入辅助栈中，对于省略号中的元素可以直接在栈顶自由相消，再将第二个 $P$ 加入到辅助栈中，使得辅助栈变空且辅助栈位置不变；

- 当 $P$ 后面第一个不在栈顶的元素在栈底时，假设这个元素为 $X$，$X$ 原来在栈 $s$ 的栈底。那么此时的入栈序列一定是 $(P,\cdots,X)$，

	我们当然会尽量让 $X$ 相抵消，那么有两种情况：

	- 使用操作 1 将入栈序列中的 $X$ 放入 $s$ 中，此时一定满足 $s$ 只有一个元素 $X$，那么就要把 $s$ 的栈顶元素全部消掉，我们设 $s$ 的栈顶元素为 $Y$，那么说明 $(P,\cdots,X)$ 的省略号中 $Y$ 的个数一定是奇数个，因为这样它们才能与栈中的一个 $Y$ 共同全部消掉。即：当 $(P,\cdots,X)$ 的省略号中 $Y$ 为奇数时，则将 $P$ 放入辅助栈中，再将省略号中的元素自由相消，然后将 $X$ 入栈 $s$，与栈中 $s$ 相消。此时 $s$ 为空，变成新的辅助栈；
	- 同理当省略号中 $Y$ 的个数为偶数个时，只能让两个 $X$ 通过操作 2 栈底相消，那么我们只能先将 $P$ 放入 $s$ 中，然后再将其它非 $Y$ 的栈顶元素自由相消，偶数个 $Y$ 放在辅助栈中相消，最后再将 $X$ 放入辅助栈进行操作 2 与栈底的 $X$ 相消。此时辅助栈为空且辅助栈位置不变。

- 当 $P$ 后面全部跟的都是在栈顶的元素时，直接一直相消到入栈序列为空即可。

经过上述操作后，局面总保持：

- 存在一个空栈，就是辅助栈。
- 所有元素在栈中最多出现一次；
- 每个栈最多只有两个元素。

由于每种元素数量均为偶数，相消永远是同种元素两两相消，所以到最后，某种数出现奇数次是不可能的。又由于每种元素在栈中最多只出现一次。综合来看，每种元素到最后只能出现零次，也就是必定不会出现。

## 实现细节

之所以在这个题题解中突然加一个我之前写题解从来没有过的【实现细节】的环节，是因为这个题代码确实难写也比较巧妙，所以专门在这里说一下。

1. 如何实现普通局面时，对于 $x$ 的入栈和简单相消的过程？

	实际上只要维护一个队列 $stk$ 存储栈的编号，满足：

	- 如果一个栈中已经存满两个元素，那么当前栈不在队列中；
	- 如果一个栈中有一个元素，那么当前栈在队列中出现一次；
	- 如果一个栈中没有元素，那么当前栈在队列中出现两次；
	- **辅助栈的编号不出现在队列中**。

	初始时，我们将 $1$ 到 $n-1$ 的所有元素入栈两次。

	同时，定义一个数组 $id_x$ 表示 $x$ 出现的栈的编号，初始时 $id_x=0$。

	我们用 `deque` 来存储每个栈的元素和栈内相对位置。并用一个变量 $spt$ 表示当前辅助栈的编号。

	当一个元素 $x$ 要入栈时：

	- 当 $id_x=0$ 时：直接从队列中弹出一个栈，并将 $x$ 入栈。
	- 当 $id_x\ne0$ 时：
		- 当 $x$ 在栈顶，即 $dq[id_x].back=x$ 时，将 $x$ 加入 $id_x$，并与栈顶 $x$ 进行相消；
		- 当 $x$ 在栈底，即 $dq[id_x].front=x$ 时，将 $x$ 加入 $spt$，并与栈底 $x$ 进行相消。

	这块需要注意，及时更新 $id_x$（变为 $0$ 还是变成新的数），及时将每个栈入队出队，及时更新栈内元素。

	code：

	```cpp
	int solve(int x)
	{
		if(id[x])
		{
			int ID=id[x];
			if(dq[ID].back()==x)
			{
				id[x]=0;
				dq[ID].pop_back();
				pb(ID);
				stk.push(ID);
			}
			else if(dq[ID].front()==x)
			{
				id[x]=0;
				dq[ID].pop_front();
				pb(spt);
				del(ID,spt);
				stk.push(ID);
			}
		}
		else
		{
			if(stk.empty())//特殊处理
			{
				return 0;
			}
			else//简单插入
			{
				int tt=stk.front();
				dq[tt].push_back(x);
				stk.pop();
				id[x]=tt;
				pb(tt);
			}
		}
		return 1;
	}
	```

2. 特殊处理中，如何求出 $P$ 后面第一个不为栈顶的元素是谁？

	我们可以从 $P$ 开始暴力枚举每一个元素，判断它们是否为栈顶。直到判断到一个元素是 $P$ 或者是栈底即可。

	由于 $P$ 一定没有出现在栈中，所以可以直接判断当前元素是否在栈中出现。

	code：

	```cpp
	int t=pos;
	pos++;
	while(id[a[pos]]&&dq[id[a[pos]]].back()==a[pos])pos++;
	```

3. 特殊处理中有哪些需要注意的细节？

	- 对于 $(P,\cdots,X)$ 中，$Y$ 为偶数的情况，未来所有不为 $Y$ 的栈顶自由相消，对于 $Y$，不能直接自由相消，需要我们把它放到辅助栈相消。
	- 对于 $(P,\cdots,X)$ 中，$Y$ 为偶数的情况，辅助栈即将变到 $s$，所以辅助栈不能入栈。也不能直接特判当前栈为 $s$ 时，直接不入栈，例如：当当前入栈序列为 `3 1 2 1 1 1 ...`，如果直接不弹入 $stk$，会造成后面的一串 `1 1 1` 无法正确入栈。但由于最后暴力扫队列把 $s$ 删除复杂度存在问题，所以我们可以直接不使用简单相消。

4. 如何记录最终答案？

	我们可以使用一个 `vector<pair<int,int>>ans` 来存储答案序列，对于 $ans$ 中的元素 $val$，若 $val.second$ 为 $0$，则是操作 1，$val.first$ 表示操作 1 选择的栈；反之则是操作 2，$val.first$ 和 $val.second$ 分别表示操作 2 选择的两个栈。那么操作次数直接输出 $ans.size()$ 即可。

## 代码实现

```cpp
//luoguP8866
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<vector>
#define mk make_pair
#define pii pair<int,int>
using namespace std;
const int maxn=305;
const int maxm=2e6+10;
const int maxk=1005;
int a[maxm],id[maxk];
int n,m,k,spt;

queue<int>stk;

deque<int>dq[maxn];

vector<pii>ans;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

void pb(int pos){ans.push_back(mk(pos,0));}

void del(int pos1,int pos2){ans.push_back(mk(pos1,pos2));}

void clear()
{
	while(!stk.empty())stk.pop();
	for(int i=1;i<=k;i++)id[i]=0;
	ans.clear();
	spt=n;
}

int solve(int x)
{
	if(id[x])
	{
		int ID=id[x];
		if(dq[ID].back()==x)
		{
			id[x]=0;
			dq[ID].pop_back();
			pb(ID);
			stk.push(ID);
		}
		else if(dq[ID].front()==x)
		{
			id[x]=0;
			dq[ID].pop_front();
			pb(spt);
			del(ID,spt);
			stk.push(ID);
		}
	}
	else
	{
		if(stk.empty())//特殊处理
		{
			return 0;
		}
		else//简单插入
		{
			int tt=stk.front();
			dq[tt].push_back(x);
			stk.pop();
			id[x]=tt;
			pb(tt);
		}
	}
	return 1;
}

int work(int pos)
{
	int t=pos;
	pos++;
	while(id[a[pos]]&&dq[id[a[pos]]].back()==a[pos])pos++;
	if(a[pos]==a[t])
	{
		pb(spt);
		for(int i=t+1;i<pos;i++)solve(a[i]);
		pb(spt);
		return pos;
	}
	int cnt=0,idx=id[a[pos]];
	for(int i=t;i<pos;i++)if(id[a[i]]==idx)cnt++;
	int ID=id[a[pos]];
	int y=dq[ID].back();
	if(cnt&1)
	{
		pb(spt);
		dq[spt].push_back(a[t]);
		for(int i=t+1;i<pos;i++)
		{
			if(a[i]==y)pb(ID);
			else solve(a[i]);
		}
		pb(ID);
		dq[ID].clear();
		id[a[pos]]=id[y]=0;
		id[a[t]]=spt;
		stk.push(spt);
		spt=ID;
	}
	else
	{
		pb(ID);
		dq[ID].push_back(a[t]);
		for(int i=t+1;i<pos;i++)
		{
			if(a[i]==y)pb(spt);
			else solve(a[i]);
		}
		pb(spt);
		del(ID,spt);
		dq[ID].pop_front();
		id[a[pos]]=0;
		id[a[t]]=ID;
	}
	return pos;
}

int main()
{
	int T=read();
	while(T--)
	{
		n=read();m=read();k=read();
		clear();
		for(int i=1;i<=m;i++)a[i]=read();
		for(int i=1;i<n;i++){stk.push(i);stk.push(i);}
		for(int i=1;i<=m;i++)
		{
			int x=a[i];
			if(solve(x))continue;
			int tt=work(i);
			i=tt;
		}
		cout<<ans.size()<<'\n';
		for(auto val:ans)
		{
			if(val.second){cout<<"2 "<<min(val.first,val.second)<<" "<<max(val.first,val.second)<<'\n';}
			else cout<<"1 "<<val.first<<'\n';
		}
	}
}
```

## 写在后面

我是很菜的，遇到构造就没招了。更何况这题比较 adhoc。

后来搞了一天才把这题搞明白（可见我有多菜）。但终究还是弄懂了，所以写篇题解来纪念一下（

特别鸣谢：@[dbxxx](https://www.luogu.com.cn/user/120868)

不管是他的[题解](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p8866.html)还是本人都对我提供了很大帮助，感谢他专门抽出一天时间从早到晚不厌其烦给我讲解+调代码。

---

## 作者：JiaY19 (赞：4)

[**更好的阅读体验**](https://cjmfeitveer.github.io/2023/03/20/P8866%20%5BNOIP2022%5D%20%E5%96%B5%E4%BA%86%E4%B8%AA%E5%96%B5%20%E9%A2%98%E8%A7%A3/)

大恶心思维题。

此题解以纪念我死去的 $\text{NOIP2023}$

### 思路

考虑 $k=2n-2$ 时。

发现对于每两种元素放在同一个栈内就必然会有一个栈空出。

那么我们可以将这个栈作为辅助栈。

我们假设将 $a_i,b_i$ 放在同一个栈 $i$ 内。

那么我们此时加入 $a_i$ 这张卡牌。

1. 栈顶为 $a_i$，直接加入消去即可。
2. 栈顶为 $b_i$，且仅有一张卡牌，直接加入至栈顶，无需消去。
3. 栈顶为 $b_i$，且栈底为 $a_i$，将 $a_i$ 加入至辅助栈内，消去两张卡。

这样，可以发现每一个栈内最多就两张卡，也比较容易维护。

这就是我在考场上想了两个小时的思路~~虽然四个小时硬钢T2~~。

考虑 $k=2n-1$ 时。

讲一下我考场时候的思路。

发现对于 $k=2n-2$ 时的做法对于栈的要求：

- 要有一个空栈来作为辅助栈。
- 每一个其余的栈都最多放两张卡。

然后就可以发现可以将加入序列中的第 $k$ 号卡提出，维护一下左右的序列即可。

这是我考场的大致思路，可惜没能写出来，最后交的代码~~甚至调试代码没删CE掉了~~。

现在考虑一下其实实现也不算难。

可以发现对于一个现在处在栈顶的元素，我们就必然可以直接加入消去。

那么我们找到第一个栈底的元素 $a_i$。

假设此时栈顶为 $b_i$。

那么我们对于 $k,\cdots,a_i$ 中的 $b_i$ 的个数进行分类讨论。

1. 加入 $cnt_{b_i}$ 为偶数。

    那么我们将 $k$ 放置在 $i$ 的栈顶，考虑由于 $cnt_{b_i}$ 为偶数，那么**新出现**的 $b_i$ 都会被消去，最后将 $a_i$ 加入辅助栈，直接消去即可。

    考虑现在第 $i$ 号栈任然只有两个元素，而辅助栈还是空的，符合条件。

2. 加入 $cnt_{b_i}$ 为奇数

    那么我们将 $k$ 放置在辅助栈内，考虑由于 $cnt_{b_i}$ 为奇数，那么**所有**的 $b_i$ 都会被消去，最后将 $a_i$ 加入 $i$ 号栈，直接消去即可。

    考虑现在第 $i$ 号栈变成空栈，而辅助栈只有一个元素，那么我们将 $i$ 号栈变为辅助栈，而辅助栈变为一个普通的栈，同样符合条件。

具体实现也不算太难。

[Code](https://www.luogu.com.cn/record/105349479)

---

## 作者：takanashi_mifuru (赞：4)

考场上挂成 30 分了，很气。

考虑部分分情况即 $k=2n-2$，此时我们预留出一个空栈，剩下的栈每一个栈分配两种颜色，如果所有非栈的栈都满了，那么根据鸽巢原理栈里的所有元素都不重不漏，如果是压在底下的就进空栈然后 2 操作消除，否则就压到它所在的栈上面。

容易发现，这样操作的话栈最大大小不超过 2。

考虑把做法扩展到 $k=2n-1$，还是一样预留空栈，但是颜色多了一个，也就是说可能会出现这种情况：除了空栈其他栈都是满的，此时还有一种颜色没有选中过，我们应该怎么办呢？

我们把栈划分成两种，第一种是下面的先被消掉，第二种是上面的先被消掉。

如果有栈属第一种，那么我们就把这个颜色叠上去，因为先消下面的，下面的消掉后这个栈又会变成大小为 2 的栈。

如果所有栈都属第二种，那么我们就把当前元素丢进空栈里，然后找到所有栈中栈底最先被消掉的栈，钦点他为空栈。

为什么？

比较显然，接下来在空栈出现之前都不会用到空栈，如果用到了空栈就会归到到第一种去。

然后就做完了，CCF 怎么天天出这种答辩模拟题啊。

---

## 作者：Cocoly1990 (赞：4)

简单讲一下第二题的思路。考虑 $k=2n-2$ 怎么做，我们将 $2\times i-1$ 和 $2\times i$ 都放进第 $i$ 号栈，剩余的栈作为辅助栈，用于消除对应栈的栈底元素。

---

那么我们怎么做 $k=2n-1$，多出的一种颜色我们将其记作特殊的颜色，当我们需要把该特殊颜色从牌堆扔进栈里的时候，我们分情况讨论。

首先，按照我们之前的策略，非辅助栈的栈内元素在任意时刻是不多于两个的。

我们考虑该颜色和下一个该颜色元素之间的元素，如果这些元素存在一个是用于弹出栈底的，那么我们就可以把这个特殊元素扔进这个用于弹出栈底的栈内，并把特殊颜色设置为用于弹出栈底元素的颜色。

如果不存在用于弹出栈底的元素，那么直接把这两个特殊颜色扔进辅助栈就好了。

代码实现不难，细节略多。

---

## 作者：I_am_Accepted (赞：3)

想到就很难了，$O(n)$ 精细实现也难。

首先 $k=2n-2$，我们想到 [NOIP2020] 移球游戏 的类似做法，将两种颜色的牌放在一堆里，这样会有一个空堆。

加入牌 $x$ 时，当其所属堆已有两张不同颜色的牌（否则直接 1 操作压入）。

若 $x$ 在顶部，我们 1 操作压入即可。

若 $x$ 在底部，我们 1 操作压入空堆，然后 2 操作两个堆底消掉即可。

这样我们保证了牌堆大小 $\le 2$，所以上述情况全矣。

为了方便拓展，当两种情况均可操作时，优先选择堆顶抵消。

考虑推广到 $k=2n-1$。

发现空堆的固定和牌颜色两两搭配的固定是非必要的，也就是说，我们可以暂时不满足上述性质，来处理这多出来的一种颜色，最后也不必还原回原来的空堆和配对。

当一张牌 $x$ 加入前局面时这样的：一个空堆，剩下每堆两个，共 $2n-2$ 种与 $x$ 不同的颜色。我们就需要更高妙的操作。

如果在下一次使用空堆前出现了另一张 $x$，则我们直接将这两个在空堆抵消。

否则我们找到下一张使用空堆消除的牌，记为颜色 $y$，她当前必然是某堆的底，设其堆顶为 $z$。

若 $z$ 在总牌堆在 $(x,y)$ 之间出现了偶数次，我们：

1. 将 $x$ 放在 $y$ 所在堆顶。

2. 持续按原来的套路消除，$z$ 直接在 $x$ 上方消除。

3. $y$ 通过底部消除。

若出现了奇数次，则接下来空堆会换位置：

1. 将 $x$ 放在空堆。

2. 持续按原来的套路消除。

3. 现在 $y$ 堆已经没有 $z$ 了，$y$ 通过顶部消除。

4. $y$ 堆空了，将空堆设为这个堆。

讲完了，$O(n)$ 代码实现非常有难度（对于我来说）。

```cpp
#define M 2000010
#define N 303
vector<pi> out;
struct node{
	int a[2],sz;
	void push(int x){
		if(sz && a[sz-1]==x) sz--;
		else a[sz++]=x;
	}
	void pop(){
		sz--;
		if(sz) a[0]=a[1];
	}
	int bot(){ return a[0]; }
	int top(){ return a[sz-1]; }
}t[N];
int n,m,k,tar,a[N],ta,pos[N<<1],pre[N<<1],p[M],cnt,L,R;
bool ban;//for tar
void ins(int x){
	if(pos[x]){
		assert(t[pos[x]].sz);
		if(t[pos[x]].top()==x){
			out.pb(0,pos[x]);
			t[pos[x]].push(x);
		}else if(t[pos[x]].bot()==x){
			assert(!ban);
			out.pb(0,tar);
			out.pb(pos[x],tar);
			t[pos[x]].pop();
		}else assert(0);
		if(t[pos[x]].sz==1) a[++ta]=pos[x];
		pos[x]=0;
		cnt--;
	}else{
		assert(ta);
		out.pb(0,a[ta]);
		t[a[ta]].push(x);
		pos[x]=a[ta];
		cnt++;
		if(t[a[ta]].sz==2) ta--;
	}
}
void work(){
	out.clear();
	cin>>n>>m>>k;
	rep(i,1,m) cin>>p[i];
	tar=n;//empty
	rep(i,1,n) t[i].sz=0;
	ta=n-1;
	iota(a+1,a+n,1);
	fill(pos+1,pos+1+k,0);
	cnt=0;
	L=1;
	ban=false;
	bool pan;
	int x,y,z,now;
	while(L<=m){
		x=p[L];
		if(!pos[x] && cnt==2*n-2){
			assert(!ta);
			R=L+1;
			while((y=p[R])!=p[L] && y==(z=t[now=pos[y]].top())){
				assert(now && t[now].sz==2);
				R++;
			}
			if(x==y){
				out.pb(0,tar);
				ban=true;
				rep(i,L+1,R-1) ins(p[i]);
				ban=false;
				out.pb(0,tar);
			}else{
				pan=false;
				rep(i,L+1,R-1) if(p[i]==z) pan^=1;
				if(pan){//odd
					out.pb(0,tar);
					ban=true;
					rep(i,L+1,R-1){
						if(p[i]==z){
							out.pb(0,now);
						}else{
							ins(p[i]);
						}
					}
					ban=false;
					out.pb(0,now);
					t[now].sz=0;
					pos[z]=0;
					pos[y]=0;
					pos[x]=tar;
					t[tar].push(x);
					a[++ta]=tar;
					tar=now;
					cnt--;
				}else{//even
					out.pb(0,now);
					ban=true;//虽然此时 tar 是空的，但确实没有 2 操作
					rep(i,L+1,R-1){
						if(p[i]==z){
							out.pb(0,now);
						}else{
							ins(p[i]);
						}
					}
					ban=false;
					out.pb(0,tar);
					out.pb(tar,now);
					t[now].pop();
					t[now].push(x);
					pos[y]=0;
					pos[x]=now;
				}
			}
			L=R+1;
		}else{
			ins(x);
			L++;
		}
	}
	assert(!cnt);
	cout<<siz(out)<<"\n";
	for(auto i:out)
		if(i.fir) cout<<"2 "<<i.fir<<" "<<i.sec<<"\n";
		else cout<<"1 "<<i.sec<<"\n";
}
```

---

## 作者：Leasier (赞：2)

好题，但是赛时我最多只能拿到 $15 \operatorname{pts}$ /kk

~~虽然但是，这题放 NOIP T2 挺创人的。~~

------------

首先考虑 $k = 2n - 2$ 的情况。不难发现这玩意跟 $2n$ 很接近且为偶数——也就是说我们可以抓出 $n - 1$ 个栈，每个至多放两个元素，剩下一个栈备用。

从这个角度出发，我们不难想到以下做法：

- 把 $k$ 种图案两两配对，构成 $n - 1$ 个 pair。
- 取出卡牌时，若当前图案在栈顶，则直接消除；若当前图案在栈底，先将这张牌放到备用的空栈里，再使用一次操作 $2$ 消除；否则，将其放入对应的栈。

由于每种图案的牌有偶数张，显然最终会被消完。

现在来算一下操作次数。第一种操作显然只有恰好 $m$ 次，第二种操作至多只有 $\frac{m}{2}$ 次，则 $m \leq op \leq \frac{3m}{2}$，符合要求。

接下来考虑 $k = 2n - 1$ 的情况。这两种情况的区别是什么呢？——可能存在某个时刻，有 $n - 1$ 个栈都有两种图案，而我们正在放入一个新的图案，直接放入备用栈可能会导致后面无法按照上述操作进行下去……

**tips：这种时候不要直接放弃原有思路，可以进行一些打补丁的尝试。**

人类智慧地，考虑从接下来将要放入的卡牌中找出第一张可以在某个时刻被消掉的牌并将当前牌暂时置于那个栈的顶端。

那这张牌应该满足什么条件呢？更加人类智慧地，我们想到这张牌需要满足**当前在栈底**，因为这样的话中间遇到的其他牌要么可以被消掉，要么因为偶数次操作而不变。

设我们找出的这张牌为 $p = a_k$。将当前牌 $a_j$ 放到 $p$ 所在栈的上方，中间的该咋操作咋操作，最后把 $p$ 放到备用栈里跟之前在栈里的 $p$ 消掉，此后所有栈就恢复了 $k = 2n - 2$ 的情况，按照之前所说的方法做下去即可。

但是很快你就会发现这玩意寄了，因为在牌堆中 $(j, k)$ 之间如果遇到了 $q$ 此前对应的栈顶 $q$ 就会消不掉……

不过若 $q$ 在 $(j, k)$ 间出现次数是偶数看上去没啥问题，因为你可以把备用栈单独让给它用于消除。接下来考虑奇数的情况。

为了让 $q$ 可以被消掉，不计后果地，考虑启用备用栈，把 $a_j$ 单独放到备用栈里，这样就可以在不影响其它项的前提下消掉 $(j, k)$ 之间的 $q$ 了。

现在唯一的问题就是备用栈被占用了，但注意到在执行到 $k$ 时我们可以直接把 $p$ 拿去消掉原来那个栈里的 $p$，则我们最终又会获得一个新的备用栈，所以就没问题了。

综上，时间复杂度为 $O(\sum nm)$（当然可以精细实现做到 $O(\sum (n + m))$）。注意特判 $n = 1$ 的情况。

细节稍多，可以参考一下代码。

代码：
```cpp
#include <stdio.h>

int ansop;
int a[2000007], cnt[307], pos1[607], pos2[607], anstype[3000007], anss[3000007], anss1[3000007], anss2[3000007];

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline void process1(int x){
	ansop++;
	anstype[ansop] = 1;
	anss[ansop] = x;
}

inline void process2(int x, int y){
	ansop++;
	anstype[ansop] = 2;
	anss1[ansop] = x;
	anss2[ansop] = y;
}

void write(int n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}

int main(){
	int t = read();
	for (register int i = 1; i <= t; i++){
		int n = read(), m = read(), k = read();
		ansop = 0;
		for (register int j = 1; j <= m; j++){
			a[j] = read();
		}
		if (n == 1){
			for (register int j = 1; j <= m; j++){
				process1(a[j]);
			}
		} else {
			for (register int j = 1; j <= n; j++){
				cnt[j] = 0;
			}
			for (register int j = 1; j <= k; j++){
				pos1[j] = pos2[j] = 0;
			}
			for (register int j = 1; j <= m; j++){
				if (pos1[a[j]] != 0 && pos2[a[j]] == cnt[pos1[a[j]]]){
					process1(pos1[a[j]]);
					cnt[pos1[a[j]]]--;
					pos1[a[j]] = 0;
				} else {
					int zero, zero_cnt = 0, one = -1;
					for (register int x = 1; x <= n; x++){
						if (cnt[x] == 0){
							zero = x;
							zero_cnt++;
						} else if (cnt[x] == 1){
							one = x;
						}
					}
					if (pos1[a[j]] != 0 && pos2[a[j]] == 1){
						process1(zero);
						process2(pos1[a[j]], zero);
						cnt[pos1[a[j]]]--;
						for (register int x = 1; x <= k; x++){
							if (x != a[j] && pos1[x] == pos1[a[j]]){
								pos2[x]--;
								break;
							}
						}
						pos1[a[j]] = 0;
					} else if (zero_cnt > 1 || one != -1){
						int goal = zero_cnt > 1 ? zero : one;
						process1(goal);
						pos1[a[j]] = goal;
						pos2[a[j]] = ++cnt[goal];
					} else {
						int pos, up;
						bool flag = false;
						for (register int x = j + 1; x <= m; x++){
							if (pos1[a[x]] != 0 && pos2[a[x]] == 1){
								pos = x;
								break;
							}
						}
						for (register int x = 1; x <= k; x++){
							if (x != a[pos] && pos1[x] == pos1[a[pos]]){
								up = x;
								break;
							}
						}
						for (register int x = j + 1; x < pos; x++){
							if (a[x] == up) flag = !flag;
						}
						if (!flag){
							pos1[a[j]] = pos1[a[pos]];
							pos2[a[j]] = 0;
							pos1[up] = zero;
							pos2[up] = 0;
							for (register int x = j; x < pos; x++){
								process1(pos1[a[x]]);
								if (pos2[a[x]] == 0){
									pos2[a[x]] = ++cnt[pos1[a[x]]];
								} else {
									pos2[a[x]] = 0;
									cnt[pos1[a[x]]]--;
								}
							}
							pos1[up] = pos1[a[pos]];
							pos2[up] = 1;
							process1(zero);
							process2(pos1[a[pos]], zero);
							cnt[pos1[a[pos]]]--;
							pos2[a[pos]] = 0;
							if (pos2[a[j]] != 0) pos2[a[j]]--;
						} else {
							process1(zero);
							pos1[a[j]] = zero;
							pos2[a[j]] = ++cnt[zero];
							for (register int x = j + 1; x <= pos; x++){
								process1(pos1[a[x]]);
								if (pos2[a[x]] == 0){
									pos2[a[x]] = ++cnt[pos1[a[x]]];
								} else {
									pos2[a[x]] = 0;
									cnt[pos1[a[x]]]--;
								}
							}
						}
						for (register int x = j; x <= pos; x++){
							if (pos2[a[x]] == 0) pos1[a[x]] = 0;
						}
						j = pos;
					}
				}
			}
		}
		write(ansop);
		putchar('\n');
		for (register int j = 1; j <= ansop; j++){
			if (anstype[j] == 1){
				putchar('1');
				putchar(' ');
				write(anss[j]);
			} else {
				putchar('2');
				putchar(' ');
				write(anss1[j]);
				putchar(' ');
				write(anss2[j]);
			}
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：Cxny (赞：2)

## [[NOIP2022] 喵了个喵](https://www.luogu.com.cn/problem/P8866)

但凡出题人脑子正常一点都不会把这题放在 $\text{T2}$。

场上以为自己想出来了，打了 $3h$ 无果。然后没时间了。寄。

后来还发现开了 $10^6$ 个 `deque`，光荣爆蛋。

---

发现 $k$ 只有 $2n-1$ 和 $2n-2$ 两种。

$k=2n-2$ 的情况是平凡的。前 $n-1$ 个栈每个储存两个元素，最后一个栈为空栈，用于消除栈底元素。

考虑如何存放多出来的一个元素。

尝试**在大多数时候**保持 $k=2n-2$ 做法的特性，即 $n-1$ 个栈仅保存两种元素并且剩余一个栈为空。

感觉空栈很浪费，毕竟只是用来消除栈底。那么，如果不需要删除栈底，我们直接把它扔在空栈就好了。

也是就是说，令下一个栈底元素为 $i$，其所在栈的栈顶元素为 $j$。

若当前元素到 $i$ 之间出现了**奇数个** $j$，那么我们就可以**从栈顶删到栈底**。此时把多出来的元素放在原来的空栈中就没有问题，且**本轮操作结束后仍然存在一个空栈**。

如果出现了偶数个 $j$ 呢？

发现把偶数个 $j$ 扔到空栈之后会被全部消除。我们就**不需要从栈顶删除元素了**！

这个时候可以把多出来的元素扔到 $i$ 所在栈的栈顶。

如此操作，每一轮结束后都保留了原有的性质。非特殊元素正常操作即可。

细节较多。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define ppb pop_back
#define pf push_front
#define ppf pop_front
const int maxn = 610, maxm = 2e6 + 10;
int sz;
int n, m, k, a[maxm], emp, sp, cnt[maxn];
int bel[maxn];
queue<int> qu;
bool inq[maxn];
struct Satck{
    deque<int> q;
    int id;
    bool empty(){return q.empty();}
    int size(){return q.size();}
    void push_back(int x){
        cnt[x] ^= 1;
        if(!q.empty() && q.back() == x) q.ppb(), sz--;
        else q.pb(x), sz++;
        if(q.size() < 2 && !inq[id]) qu.push(id), inq[id] = 1;
    }
    void pop_front(){
        cnt[front()] ^= 1, q.pop_front(), sz--;
        if(q.size() < 2 && !inq[id]) qu.push(id), inq[id] = 1;
    }
    int back(){assert(!q.empty()); return q.back();}
    int front(){assert(!q.empty()); return q.front();}
}st[maxn];
int front(){
    while(!qu.empty() && (st[qu.front()].size() > 1 || qu.front() == emp)) inq[qu.front()] = 0, qu.pop();
    assert(!qu.empty()); int ret = qu.front(); 
    return ret;
}
struct Query{
    int opt, x, y;
    Query(int o, int a, int b = 0){opt = o, x = a, y = b;}
    void print(){printf("%d %d ", opt, x); if(opt == 2) printf("%d\n", y); else puts("");}
};
vector<Query> ans;
void wsyakioi(){
    assert(!sz);
    while(!qu.empty()) qu.pop();
    scanf("%d%d%d", &n, &m, &k), ans.clear();
    for(int i = 1; i <= m; i++) scanf("%d", &a[i]);
    for(int i = 1; i < n; i++) qu.push(i), inq[i] = 1;
    emp = n, sp = 2 * n - 1, fill(bel + 1, bel + n * 2 + 1, 0);
    for(int i = 1; i <= m; i++) if(sz < n * 2 - 2 || cnt[a[i]]){
        if(!cnt[a[i]]) bel[a[i]] = front(), ans.pb(Query(1, bel[a[i]])), st[bel[a[i]]].pb(a[i]);
        else if(st[bel[a[i]]].back() == a[i]) ans.pb(Query(1, bel[a[i]])), st[bel[a[i]]].pb(a[i]);
        else if(st[bel[a[i]]].front() == a[i]) ans.pb(Query(1, emp)), ans.pb(Query(2, bel[a[i]], emp)), st[bel[a[i]]].ppf();
        else assert(0);
    }else{
        sp = a[i];
        int j = i + 1, qwq = 0;
        for(; j <= m; j++) if(bel[a[j]] && st[bel[a[j]]].size() == 2 && st[bel[a[j]]].front() == a[j]) break;
        if(j == m + 1){ans.pb(Query(1, emp)), st[emp].pb(a[i]), bel[a[i]] = emp; continue;}
        for(int k = i + 1; k <= j; k++) if(a[k] == st[bel[a[j]]].back()) qwq++;
        int ano = st[bel[a[j]]].back();
        if(qwq & 1){
            bel[sp] = emp, ans.pb(Query(1, emp)), st[emp].pb(a[i]);
            for(int k = i + 1; k <= j; k++) st[bel[a[k]]].pb(a[k]), ans.pb(Query(1, bel[a[k]]));
            assert(st[bel[a[j]]].empty()); 
            qu.push(emp), inq[emp] = 1;
            bel[a[j]] = emp, sp = ano, emp = bel[ano], bel[ano] = 0;
            i = j;
        }else{
            bel[sp] = bel[a[j]], bel[ano] = emp;
            for(int k = i; k < j; k++) st[bel[a[k]]].pb(a[k]), ans.pb(Query(1, bel[a[k]]));
            ans.pb(Query(1, emp)), ans.pb(Query(2, bel[a[j]], emp)), st[bel[a[j]]].ppf();
            assert(st[emp].empty());
            bel[ano] = bel[a[j]], sp = a[j], bel[sp] = 0;
            i = j;
        }
    }
    printf("%d\n", ans.size());
    for(auto p : ans) p.print();
    for(int i = 1; i <= n; i++) assert(st[i].empty());
}
int main(){
    for(int i = 1; i < maxn; i++) st[i].id = i;
    int T; scanf("%d", &T);
    while(T--) wsyakioi();
    return 0;
}
```

---

## 作者：jifbt (赞：2)

先解决 $k=2n-2$ 的情况。

定义三种基本操作：
- 插入（`ins`）：把不等于栈顶的数入栈。
- 删除（`del`）：把等于栈顶的数入栈，与栈顶消除。
- 连接（`con`）：把数放到备用栈（一个钦定的空栈），再与某个栈底进行消除。

插入时，如果有高度为 $1$ 的栈，就任选一个插入；否则就插到高度为 $0$ 的栈中。显然这样的栈总是存在。实现时，可以用 `set`，也可以维护一个栈，删除时用栈顶替换。

$k=2n-1$ 时，这样的栈不总是存在了，此时除了将要放入的数（原数），其他数都已存在。我们先忽略这个数，继续往后做。有几种情况（可能需要前后对照来理解）：
- 等于原数：如果执行到这里，则不会出现连接操作而使用备用栈。把它们都放入备用栈中对消，结束循环。
- 连接：如果执行这种操作，只有可能上面的数被放入偶数次。因此预先放入原数，可以让后面偶数个数对消，不会有影响。结束循环。
- 删除：如果删除后栈为空，可以把原数放入备用栈，这个栈变成新的备用栈，结束循环。否则继续。
- 插入：直接插入。注意插入的地方要和之前保持一致，不能放到别处。  
下面的 hack 数据会让程序把带星号的 5 插入原来是 1 的位置，把带星号的 1 插入原来是 5 的位置（如果你用“栈”实现集合，且插入到“栈”顶的那个栈），在连接 3 之前，变成 3 ~~5 5~~ 1，再把 2 预先放入就变成 3 5 2 **5 1**，后面两数无法对消。如果和之前保持一致，则是 3 ~~5 5~~ 5 和 3 5 2 ~~5 5~~。

```plain
1
4 18 7
4 1 6 7 3 5 2 5 1 5 1 3 2 7 4 5 1 6
                  * *
```

细节略多，要多加注意。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>void rd(T&x){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-48;c=getchar();}
	x*=f;
}
const int N=310,M=2e6+10,K=N*2;
int T,n,m,k,a[M];
int o[M],p[M],b,c[K],c2[K];
int s[N][2],t[N];
int f[N],e[N],z,e2[N],z2;
void ins(int x){
	if(t[x]==1)e2[f[x]=z2++]=x;
	else if(!t[x])e[f[x]=z++]=x;
}
void del(int x){
	if(t[x]==1)f[e2[--z2]]=f[x],e2[f[x]]=e2[z2];
	else if(!t[x])f[e[--z]]=f[x],e[f[x]]=e[z];
}
void ins(int y,int i){int x=a[i];del(y);o[i]=0;p[i]=y;c[x]=y;s[y][t[y]++]=x;ins(y);}
void del(int y,int i){int x=a[i];del(y);o[i]=0;p[i]=y;c[x]=0;--t[y];ins(y);}
void con(int y,int i){int x=a[i];del(y);o[i]=e[0];p[i]=y;c[x]=0;++b;s[y][0]=s[y][1];--t[y];ins(y);}
int main(){
	rd(T);
	while(T--){
		rd(n);rd(m);rd(k);b=m;
		memset(c,0,(k+5)<<2);
		memset(t,0,(n+5)<<2);
		memset(f,0,(n+5)<<2);
		z=z2=0;
		for(int i=n;i;--i)ins(i);
		for(int i=1;i<=m;++i)rd(a[i]);
		for(int i=1,j=1;i<=m;i=++j){
			int x=a[i];
			if(int y=c[x]){
				if(s[y][t[y]-1]==x)del(y,i);
				else con(y,i);
			}else if(z2||z>1)ins(z2?e2[z2-1]:e[z-1],i);
			else for(j=i+1;;++j){
				if(x==a[j]){int y=e[0];ins(y,i);del(y,j);break;}
				if(int y=c[a[j]]){
					if(s[y][t[y]-1]==a[j]){
						del(y,j);
						if(!t[y]){ins(e[0],i);break;}
						c2[a[j]]=y;
					}else{con(y,j);ins(y,i);break;}
				}else ins(c2[a[j]],j);
			}
		}
		printf("%d\n",b);
		for(int i=1;i<=m;++i){
			if(o[i])printf("1 %d\n2 %d %d\n",o[i],p[i],o[i]);
			else printf("1 %d\n",p[i]);
		}
	}
}
```

---


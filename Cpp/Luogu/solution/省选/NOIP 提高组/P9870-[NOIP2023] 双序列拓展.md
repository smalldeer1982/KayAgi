# [NOIP2023] 双序列拓展

## 题目描述

称某个序列 $B = \{b_1,b_2,\cdots,b_n\}$ 是另一个序列 $A = \{a_1,a_2,\cdots,a_m\}$ 的**拓展**当且仅当存在**正整数**序列 $L = \{l_1,l_2,\cdots,l_m\}$，将 $a_i$ 替换为 $l_i$ 个 $a_i$ 后得到序列 $B$。例如，

- $\{1,3,3,3,2,2,2\}$ 是 $\{1,3,3,2\}$ 的拓展，取 $L = \{1,1,2,3\}$ 或 $\{1,2,1,3\}$；
- 而 $\{1,3,3,2\}$ 不是 $\{1,3,3,3,2\}$ 的拓展，$\{1,2,3\}$ 不是 $\{1,3,2\}$ 的拓展。

小 R 给了你两个序列 $X$ 和 $Y$，他希望你找到 $X$ 的一个长度为 $l_0 = 10^{100}$ 的拓展 $F = \{f_i\}$ 以及 $Y$ 的一个长度为 $l_0$ 的拓展 $G = \{g_i\}$，使得任意 $1 \le i , j \le l_0$ 都有 $(f_i - g_i)(f_j - g_j) > 0$。由于序列太长，你只需要告诉小 R 是否存在这样的两个序列即可。

为了避免你扔硬币蒙混过关，小 R 还给了 $q$ 次额外询问，每次额外询问中小 R 会修改 $X$ 和 $Y$ 中若干元素的值。你需要对每次得到的新的 $X$ 和 $Y$ 都进行上述的判断。

**询问之间是独立的，每次询问中涉及的修改均在原始序列上完成。**

## 说明/提示

**【样例解释 #1】**

由于 $F$ 和 $G$ 太长，用省略号表示重复最后一个元素直到序列长度为 $l_0$。如 $\{1,2,3,3,\cdots\}$ 表示序列从第三个元素之后都是 $3$。

以下依次描述四次询问，其中第一次询问为初始询问，之后的三次为额外询问：

1. $A = \{8,6,9\}$，$B = \{1,7,4\}$，取 $F = \{8,8,6,9,\cdots\}, G = \{1,7,4,4,\cdots\}$；
2. $A = \{8,6,0\}$，$B = \{1,7,4\}$，可以证明不存在满足要求的方案；
3. $A = \{8,6,9\}$，$B = \{8,7,5\}$，可以证明不存在满足要求的方案；
4. $A = \{8,8,9\}$，$B = \{7,7,4\}$，取 $F = \{8,8,9,\cdots\}, G = \{7,7,4,\cdots\}$。

**【样例解释 #2】**

该组样例满足测试点 $4$ 的条件。

**【样例解释 #3】**

该组样例满足测试点 $7$ 的条件。

**【样例解释 #4】**

该组样例满足测试点 $9$ 的条件。

**【样例解释 #5】**

该组样例满足测试点 $18$ 的条件。

**【数据范围】**

对于所有测试数据，保证：

- $1 \le n, m \le 5 \times 10 ^ 5$；
- $0 \le q \le 60$；
- $0 \le x_i, y_i < 10 ^ 9$；
- $0 \le k_x, k_y \le 5 \times 10 ^ 5$，且所有额外询问的 $(k_x+k_y)$ 的和不超过 $5 \times 10 ^ 5$；
- $1 \le p_x \le n$，$1 \le p_y \le m$，$0 \le v_x, v_y < 10 ^ 9$；
- 对于每组额外询问，$p_x$ 两两不同，$p_y$ 两两不同。

|测试点编号|$n, m \le$|特殊性质|
|:-:|:-:|:-:|
|$1$|$1$|否|
|$2$|$2$|否|
|$3, 4$|$6$|否|
|$5$|$200$|否|
|$6, 7$|$2000$|否|
|$8, 9$|$4 \times 10 ^ 4$|是|
|$10, 11$|$1.5 \times 10 ^ 5$|是|
|$12 \sim 14$|$5 \times 10 ^ 5$|是|
|$15, 16$|$4 \times 10 ^ 4$|否|
|$17, 18$|$1.5 \times 10 ^ 5$|否|
|$19, 20$|$5 \times 10 ^ 5$|否|

特殊性质：对于每组询问（包括初始询问和额外询问），保证 $x_1 < y_1$，且 $x_n$ 是序列 $X$ 唯一的一个最小值，$y_m$ 是序列 $Y$ 唯一的一个最大值。

## 样例 #1

### 输入

```
3 3 3 3
8 6 9
1 7 4
1 0
3 0
0 2
1 8
3 5
1 1
2 8
1 7
```

### 输出

```
1001```

# 题解

## 作者：liangbowen (赞：219)

[blog](https://www.cnblogs.com/liangbowen/p/17848721.html)。NOIP2023 T3，特殊性质题。

什么是特殊性质题？就是题目给出了你极其神秘的性质，从而引导你想出正解。

本篇题解将从部分分的角度，一步步讲述部分分与正解的关系。这样看的话，本题会变得十分简单。

## $\text{Task }1\sim7$，$O(Tnm)$

首先转换题意。$\forall(f_i-g_i)(f_j-g_j)>0$，本质上就是满足两者中的一个：

+ 所有 $1\le i\le 10^{100}$ 都有 $f_i<g_i$。
+ 所有 $1\le i\le 10^{100}$ 都有 $f_i>g_i$。

这两件事情本质相同，我们只考虑第一件事情（$\forall f_i<g_i$），第二件事情就是将 $f,g$ 对调一下再处理。

你想一想拓展的本质。其实就是有两个指针 $X_i$ 与 $Y_j$，每次如果有 $X_i<Y_j$，那么可以做：

+ $(i,j)\to(i+1,j)$，表示 $f$ 的下一位是 $X_{i+1}$，$g$ 的下一位仍然是 $Y_j$。
+ $(i,j)\to(i,j+1)$，表示 $f$ 的下一位仍然是 $X_{i}$，$g$ 的下一位是 $Y_{j+1}$。
+ $(i,j)\to(i+1,j+1)$，表示 $f$ 的下一位是 $X_{i+1}$，$g$ 的下一位是 $Y_{j+1}$。

于是考虑 DP。$dp_{i,j}$ 表示 $X$ 匹配到第 $i$ 位，$Y$ 匹配到第 $j$ 位，是否可行。转移即：

$$X_i<Y_j, dp_{i,j}\gets dp_{i-1,j}\cup dp_{i,j-1}\cup dp_{i-1,j-1}$$

答案即 $dp_{n,m}$。这一部分的代码如下，时间复杂度 $O(Tnm)$。

```cpp
#include <iostream>
#include <cstdio>
#include <cassert>
using namespace std;
const int N = 5e5 + 5;
bool dp[2005][2005];
bool chk(int x[], int y[], int n, int m) //是否可以构造出 fi<gi
{
	if (x[1] <= y[1] || x[n] <= y[m]) return false; //特判
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) dp[i][j] = false; //初始化
	dp[1][1] = true; //(1,1) 作为起点，显然可以到达
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) //下面的转移方程就和思路中的一样
			if (x[i] > y[j]) dp[i][j] |= (dp[i - 1][j - 1] | dp[i - 1][j] | dp[i][j - 1]);
	return dp[n][m];
}
int x[N], y[N], ttx[N], tty[N];
int main()
{
	int n, m, q;
	scanf("%*d%d%d%d", &n, &m, &q);
	for (int i = 1; i <= n; i++) scanf("%d", &x[i]);
	for (int i = 1; i <= m; i++) scanf("%d", &y[i]);
	putchar(chk(x, y, n, m) || chk(y, x, m, n) ? '1' : '0');
	while (q--)
	{
		for (int i = 1; i <= n; i++) ttx[i] = x[i];
		for (int i = 1; i <= m; i++) tty[i] = y[i];
		int cx, cy;
		scanf("%d%d", &cx, &cy);
		while (cx--) {int p, v; scanf("%d%d", &p, &v); ttx[p] = v;}
		while (cy--) {int p, v; scanf("%d%d", &p, &v); tty[p] = v;}
		putchar(chk(ttx, tty, n, m) || chk(tty, ttx, m, n) ? '1' : '0');
	}
	return 0;
}
```

## $\text{Task }8\sim14$，$O(T(n+m))$ 特殊性质

考虑上面那个做法是在干啥。

> 令 $A_{i,j}=[X_i<Y_j]$，从 $(1,1)$ 开始，每次可以向右、下、右下的 $A_{i,j}=1$ 的点走一步，问能否走到 $(n,m)$。

首先，如果 $X_{\min}\ge Y_{\min}$，说明 $Y_{\min}$ 的那一列的全部 $A_{i,j}$ 都是 $0$。显然路被堵死了，走不到捏。

同理，$Y_{\max}\le X_{\max}$ 也是走不到。

考虑完这些小情况后，根据这个特殊性质，必然有：

+ 对于 $1\le i\le m$，都有 $A_{n,i}=1$。
+ 对于 $1\le i\le n$，都有 $A_{i,m}=1$。

这说明，只要我们能走到第 $(n-1)$ 行或者第 $(m-1)$ 列，就一定能顺着这条通路到达 $(n,m)$。看起来像下面这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/me8vw3bs.png)

以此类推，找到 $1\sim(n-1)$ 的最小值，如果有 $X_{\min}<Y_{\min}$，说明：**对于 $1\le i\le m-1$，都有 $A_{xmin,i}=1$**。

这说明，只要我们能走到第 $xmin$ 行或者第 $(m-1)$ 列，就一定能顺着这条通路到达第 $n$ 行或者第 $m$ 列，然后再到达 $(n,m)$。

同样地，列也可以类似地操作。

可以理解为，现在有一个边框，你只要到达了边框就能走到 $(n,m)$ 了。那么每次缩小整个边框地大小，必然是不会更劣的。

于是你一直缩小边框，如果中途无法缩小（$X_{\min}\ge Y_{\min}$ 且 $Y_{\max}\le X_{\max}$），不可行；否则，如果边框到达了 $(1,1)$，那么就是可行。

实现方面可以采用递归，维护前缀最小值 / 最大值的位置即可。时间复杂度 $O(T(n+m))$。

```cpp
bool check(int x, int y) //能否从 (1,1) 走到第 x 行或者第 y 列
{
	if (x == 1 || y == 1) return true; //如果刚好是第 1 行或者第 1 列，可行
	Node X = preX[x - 1], Y = preY[y - 1]; //找到前缀最值的位置
	if (f[X.min] < g[Y.min]) return check(X.min, y);
	if (g[Y.max] > f[X.max]) return check(x, Y.max);
	return false;
}
```

## 正解

特殊性质的提示性非常强。你可以**找到 $X$ 的最小值与 $Y$ 的最大值的位置**。

![](https://cdn.luogu.com.cn/upload/image_hosting/2btm2hh1.png)

如图所示，分左上与右下两个区域，如果 $(1,1)$ 能走到红线部分，并且红线部分能走到 $(n,m)$，那么就是可行了。

所以，你只要实现两个 `check()` 函数，一个看左上部分的合法性，一个看右下部分的合法性即可。

完整代码如下，时间复杂度 $O(T(n+m))$。

```cpp
#include <iostream>
#include <cstdio>
#include <cassert>
using namespace std;
const int N = 5e5 + 5;
int f[N], g[N]; struct Node {int min, max; Node(int ge = 0, int fe = 0): min(ge), max(fe){}} preX[N], preY[N], sufX[N], sufY[N];
#define update(T, p) (Node){T[i] < T[p.min] ? i : p.min, T[i] > T[p.max] ? i : p.max};
bool check1(int x, int y, int n, int m) //左上区域
{
	if (x == 1 || y == 1) return true;
	Node X = preX[x - 1], Y = preY[y - 1];
	if (f[X.min] < g[Y.min]) return check1(X.min, y, n, m);
	if (g[Y.max] > f[X.max]) return check1(x, Y.max, n, m);
	return false;
}
bool check2(int x, int y, int n, int m) //右下区域，同左上区域
{
	if (x == n || y == m) return true;
	Node X = sufX[x + 1], Y = sufY[y + 1];
	if (f[X.min] < g[Y.min]) return check2(X.min, y, n, m);
	if (g[Y.max] > f[X.max]) return check2(x, Y.max, n, m);
	return false;
}
bool solve(int tmpf[], int tmpg[], int n, int m)
{
	if (tmpf[1] >= tmpg[1]) return false; //一个特判
	for (int i = 1; i <= n; i++) f[i] = tmpf[i]; //copy 一下，方便在全局定义函数
	for (int i = 1; i <= m; i++) g[i] = tmpg[i];

    //这里求出 X,Y 的前后缀 最大/最小值 的位置，为了让代码更优美，使用了 update()
	for (int i = 1; i <= n; i++) preX[i] = (i == 1) ? (Node){1, 1} : update(f, preX[i - 1]);
	for (int i = 1; i <= m; i++) preY[i] = (i == 1) ? (Node){1, 1} : update(g, preY[i - 1]);
	for (int i = n; i >= 1; i--) sufX[i] = (i == n) ? (Node){n, n} : update(f, sufX[i + 1]);
	for (int i = m; i >= 1; i--) sufY[i] = (i == m) ? (Node){m, m} : update(g, sufY[i + 1]);

	Node X = preX[n], Y = preY[m]; //找出两条红线的位置
	if (f[X.min] >= g[Y.min] || g[Y.max] <= f[X.max]) return false; //一个特判
	return check1(X.min, Y.max, n, m) && check2(X.min, Y.max, n, m); //分左上右下递归即可
}
int tx[N], ty[N], ttx[N], tty[N];
int main()
{
	int n, m, q;
	scanf("%*d%d%d%d", &n, &m, &q);
	for (int i = 1; i <= n; i++) scanf("%d", &tx[i]);
	for (int i = 1; i <= m; i++) scanf("%d", &ty[i]);
	putchar(solve(tx, ty, n, m) || solve(ty, tx, m, n) ? '1' : '0');
	while (q--)
	{
		for (int i = 1; i <= n; i++) ttx[i] = tx[i];
		for (int i = 1; i <= m; i++) tty[i] = ty[i];
		int cx, cy;
		scanf("%d%d", &cx, &cy);
		while (cx--) {int p, v; scanf("%d%d", &p, &v); ttx[p] = v;}
		while (cy--) {int p, v; scanf("%d%d", &p, &v); tty[p] = v;}
		putchar(solve(ttx, tty, n, m) || solve(tty, ttx, m, n) ? '1' : '0');
	}
	return 0;
}
```

希望能帮助到大家 /qq。

---

## 作者：Petit_Souris (赞：24)

不知道为什么场上就是认定了这题是不可做题，也同样觉得 T4 不可做，结果拼完 7.5KB 暴力之后会了但是来不及写。只能说打的像个小丑。

首先有一个显然的平方 dp，把转移放在网格图之后相当于限定了 $x_i\ge y_j$ 的位置为障碍，求 $(1,1)$ 和 $(n,m)$ 是否八连通。（$y_j\ge x_i$ 的部分同理，是对称的。）

观察到对于 $x_i>x_k$，满足 $x_k\ge y_j$ 的 $j$ 一定是满足 $x_i\ge y_j$ 的 $j$ 的子集，因此 $(1,1)$ 和 $(n,m)$ 不连通只有四种情况：

- 有一行全部是障碍，即 $\max x_i\ge \max y_j$。

- 有一列全部是障碍，即 $\min x_i\ge \min y_j$。

- 起点被一个 L 型障碍封起来，即存在 $(i,j)$ 满足 $x_i\ge \max\limits_{k=1}^{j} y_k$ 且 $y_j\le \min\limits _{k=1}^{i} x_k$。

- 终点被一个 L 型障碍封起来，即存在 $(i,j)$ 满足 $x_i\ge \max\limits_{k=j}^{m} y_k$ 且 $y_j\le \min\limits _{k=i}^{n} x_k$。

一、二直接判就行了；三、四两种是对称的，只考虑三怎么判断。

枚举 $i$，要找到最小的 $j$ 满足 $y_j\le \min\limits _{k=1}^{i} x_k$，相当于找到最小的 $j$ 满足 $\min\limits_{k=1}^{j} y_k\le \min\limits _{k=1}^{i} x_k$。$j$ 具有单调性，随 $i$ 的增大而增大，因此维护一个指针 $j$ 即可。

全部是赛后没看题解的情况下想的。什么时候正式考试能拼一点，不要天天当四暴力战神呢。

```cpp
#include<bits/stdc++.h>
typedef int ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void write(ll x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
const ll N=5e5+9,INF=2e9;
ll c,n,m,q,x[N],y[N],tx[N],ty[N],px[N],py[N];
void work(ll*x,ll*y,ll n,ll m){
	//x[i]>=y[j] (i,j) obstacle
	if(*max_element(x+1,x+n+1)>=*max_element(y+1,y+m+1))return putchar('0'),void();
	if(*min_element(x+1,x+n+1)>=*min_element(y+1,y+m+1))return putchar('0'),void();
	px[0]=py[0]=INF;
	rep(i,1,n)px[i]=min(px[i-1],x[i]);
	rep(i,1,m)py[i]=min(py[i-1],y[i]);
	ll p=0,c=0;
	rep(i,1,n){
		while(p<=m&&py[p]>px[i])p++,c=max(c,y[p]);
		if(p<=m&&x[i]>=c)return putchar('0'),void();
	}
	px[n+1]=py[m+1]=INF;
	per(i,n,1)px[i]=min(px[i+1],x[i]);
	per(i,m,1)py[i]=min(py[i+1],y[i]);
	p=m+1,c=0;
	per(i,n,1){
		while(p>=1&&py[p]>px[i])p--,c=max(c,y[p]);
		if(p>=1&&x[i]>=c)return putchar('0'),void();
	}
	putchar('1');
}
void solve(){
	if(x[1]==y[1])putchar('0');
	else if(x[1]<y[1])work(x,y,n,m);
	else work(y,x,m,n);
}
int main(){
	c=read(),n=read(),m=read(),q=read();
	rep(i,1,n)tx[i]=read();
	rep(i,1,m)ty[i]=read();
	rep(i,1,n)x[i]=tx[i];
	rep(i,1,m)y[i]=ty[i];
	solve();
	while(q--){
		rep(i,1,n)x[i]=tx[i];
		rep(i,1,m)y[i]=ty[i];
		ll kx=read(),ky=read();
		while(kx--){
			ll a=read(),b=read();
			x[a]=b;
		}
		while(ky--){
			ll a=read(),b=read();
			y[a]=b;
		}
		solve();
	}
	return 0;
}

```

---

## 作者：_yjh (赞：15)

显然可以将题目转化为序列相互匹配的形式，下设匹配后 $A$ 序列中每一个元素都比 $B$ 序列对应元素小。

首先有非常显然的 dp：设 $f_{i,j}$ 表示 $A$ 序列的前 $i$ 个是否能和 $B$ 序列的前 $j$ 个匹配，$O(1)$ 转移即可，时间复杂度 $O(qn^2)$，理论应当获得 $35$ 分。

实际上由于这个 dp 状态维度过高且难以优化，自然可以考虑贪心：设 $g_i$ 表示 $A$ 序列的第 $i$ 个最多能匹配到 $B$ 序列的哪一个。从小到大枚举 $i$，首先令 $g_i=g_{i-1}$，如果当前匹配合法就不断尝试拓展，否则不断回退，直到合法为止（如果回退到 $0$ 或最后匹配不完即为不合法）。时间复杂度同样为 $O(qn^2)$，同样理论应当获得 $35$ 分。[link](https://www.luogu.com.cn/paste/isxhpvtj)

插一段与正解无关的话，上面的贪心直接使用 ST 表或线段树维护即可做到 $O(qn\log n)$，理论应当获得 $[55,75]$ 分。

然后考虑拓展这个贪心。对于特殊性质，发现只有前缀 $\min$ 会形成有效拓展，其余元素只可能造成回退并影响合法性（即回退到 $0$）。换句话讲，假设说 $A$ 序列中前缀 $\min$ 分别为 $mn_1,mn_2\dots mn_k$，那么对于位于 $(mn_i,mn_{i+1})$ 的元素，最不容易合法的一定是其中最大值，只要 $B$ 序列中的前 $g_{mn_i}$ 个元素中的最大值比这个值大就一定合法，否则一定非法。具体实现的话对两个序列分别维护前缀 $\min$ 和 前缀 $\max$ 即可。时间复杂度 $O(qn)$，理论应当获得 $70$ 分。[link](https://www.luogu.com.cn/paste/9drfavq8)

最后，直接把第一个序列按最小值分开（两段都含最小值），第二个序列按最大值分开（两段都含最大值），两部分分别跑特殊性质即可。时间复杂度同上，理论应当获得 $100$ 分。[link](https://www.luogu.com.cn/paste/1bx62rkm)

------------

最后是对一开始贪心的证明：

首先不难证明对于 $A$ 序列中所有前缀 $\min$ 对应的位置，贪心得到的 $g_i$ 一定是对的。然后将 $A$ 序列按最小值 $mn$ 分成两段（两段都不含最小值），前一段对应的 $B$ 序列即为完整的 $B$ 序列，后一段对应的 为从 $g_{mn}$ 开始的 $B$ 序列（因为不可能回撤到 $g_{mn}$ 之前），可以发现这两个问题是分别独立的。于是不断递归下去每个值都可以看作前缀 $\min$，也就是说贪心的每一步决策都是正确的。

---

## 作者：不知名用户 (赞：12)

# NOIP2023 T3

## 题意（核心，修改什么不说了）

给定序列 $x(len=n),y(len=m)$，称 $f$ 的扩展序列 $g$：$\exists c$，将 $f_i$ 写 $c_i>1$ 次构成 $g$。问是否存在长度为 $10^{100}$ 的两个序列 $a,b$ 分别为 $x,y$ 的扩展且 $\forall(a_i-b_i)(a_j-b_j)>0$。

## 做法

由于 $x,y$ 对称，不妨令 $x_1>y_1$。

观察得出一个 $x$ 元素（在 $a$ 中）匹配多个 $y$ 元素或一个 $y$ 元素匹配多个 $x$ 元素，不存在一个 $x$ 元素与 $y$ 元素相交一半。即任意两个元素要么不相交，要么包含。

考虑画一个 $n\times m$ 的网格图，如果 $x_i>y_j$，那么在 $(i,j)$ 处打勾，否则打叉。然后要找一条“打勾路径”，每一步往右/下/右下走。往右表示 $x_i$ 匹配多个，往下表示 $y_i$ 匹配多个，右下表示匹配结束。（观察：不可能往右紧跟往下，因为可以被右下代替，实际意义为两元素重合且不包含）

于是可以 $\Theta(nm)$ DP 啦！由于实际题目中有修改，还要乘 $q$。（35pts）

为方便理解，给出样例最初的图解（绿表示勾，红表示叉，灰表示路径）：

![样例解释1.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_fd06ec798d-样例解释1.png) 

然后再看特殊性质 1（这里交换一下 $x,y$，即 $x_1>y_1$，方便后序说明），发现如果可以必然最后一行、一列都是勾，即：

![特殊性质.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_067cce758d-特殊性质.png) 

如果除去最后一行的最大值 $a$ 和所有列的最大值 $b$，$a$ 更大，则问题规模缩小到蓝框区域：

![特殊性质1.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_0fcb61858d-特殊性质1.png) 

否则：

![特殊性质4.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_18ee38b18d-特殊性质4.png) 

如果除去最后列的最小值 $c$ 和所有行的最小值 $d$，$c$ 更小，则问题规模缩小至蓝框：

![特殊性质2.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_1fcb0ddf8d-特殊性质2.png) 

否则：

![特殊性质3.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_287cdcaa8d-特殊性质3.png) 

如果 $b$ 更大，$d$ 更小，就走不出去了：

![不可以.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_2fd782308d-不可以.png) 

回归无特殊性质，发现所有行的最大值必须最大，所有列的最小值必须最小，否则就会有一列或一行全是红的走不出去了（这里不放图了），否则图长这样，对两个蓝框分别处理，后缀处理方法类似：

![一般.png](https://cdn.acwing.com/media/article/image/2023/11/28/60248_38844a5a8d-一般.png)

边界状态：只有一行**或**一列，因为这时候全是绿的（因为在问题规模变小的时候也保持最后一行、一列都是绿的）

时间复杂度 $q(n+m)$，因为问题规模最多缩小 $\Theta(n+m)​$ 次。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e5 + 10;

int n, m;

int x[N], y[N];

namespace chk
{

int mxxp[N], mnxp[N], mxxs[N], mnxs[N];
int mxyp[N], mnyp[N], mxys[N], mnys[N];

bool pre(int X, int Y, int *x, int *y, int n, int m)
{
	if(X<=1||Y<=1) return 1;
	if(x[mxxp[X-1]]>y[mxyp[Y]]) return pre(mxxp[X-1],Y,x,y,n,m);
	if(y[mnyp[Y-1]]<x[mnxp[X]]) return pre(X,mnyp[Y-1],x,y,n,m);
	return 0;
}

bool suf(int X, int Y, int *x, int *y, int n, int m)
{
	if(X>=n||Y>=m) return 1;
	if(x[mxxs[X+1]]>y[mxys[Y]]) return suf(mxxs[X+1],Y,x,y,n,m);
	if(y[mnys[Y+1]]<x[mnxs[X]]) return suf(X,mnys[Y+1],x,y,n,m);
	return 0;
}

bool main(int *x, int *y, int n, int m)
{
	if(x[1]<=y[1]||x[n]<=y[m]) return 0;
	int i;
	for(i=1;i<=n;i++)if(i==1||x[i]>x[mxxp[i-1]])mxxp[i]=i;else mxxp[i]=mxxp[i-1];
	for(i=1;i<=n;i++)if(i==1||x[i]<x[mnxp[i-1]])mnxp[i]=i;else mnxp[i]=mnxp[i-1];
	for(i=n;i>=1;i--)if(i==n||x[i]>x[mxxs[i+1]])mxxs[i]=i;else mxxs[i]=mxxs[i+1];
	for(i=n;i>=1;i--)if(i==n||x[i]<x[mnxs[i+1]])mnxs[i]=i;else mnxs[i]=mnxs[i+1];
	for(i=1;i<=m;i++)if(i==1||y[i]>y[mxyp[i-1]])mxyp[i]=i;else mxyp[i]=mxyp[i-1];
	for(i=1;i<=m;i++)if(i==1||y[i]<y[mnyp[i-1]])mnyp[i]=i;else mnyp[i]=mnyp[i-1];
	for(i=m;i>=1;i--)if(i==m||y[i]>y[mxys[i+1]])mxys[i]=i;else mxys[i]=mxys[i+1];
	for(i=m;i>=1;i--)if(i==m||y[i]<y[mnys[i+1]])mnys[i]=i;else mnys[i]=mnys[i+1];
	if(x[mnxp[n]]<=y[mnyp[m]]||x[mxxp[n]]<=y[mxyp[m]]) return 0;
	int midx = mxxp[n], midy = mnyp[m];
	return pre(midx,midy,x,y,n,m) && suf(midx,midy,x,y,n,m);
}

}//namespace chk

pair<int*,int> stk[N];int top;

void store(int &x)
{
	stk[++top] = make_pair(&x,x);
} 

void restore()
{
	while(top)
	{
		*stk[top].first = stk[top].second;
		top--;
	}
}

int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); 
	int c, q, i;
	cin>>c>>n>>m>>q;
	for(i=1;i<=n;i++) cin>>x[i];
	for(i=1;i<=m;i++) cin>>y[i]; 
	if(x[1]>y[1]) cout<<chk::main(x,y,n,m);
	else cout<<chk::main(y,x,m,n);
	while(q--)
	{
		int kx, ky;
		cin>>kx>>ky;
		while(kx--)
		{
			int a, b;
			cin>>a>>b;
			store(x[a]);
			x[a] = b;
		}
		while(ky--)
		{
			int a, b;
			cin>>a>>b;
			store(y[a]);
			y[a] = b;
		}
		if(x[1]>y[1]) cout<<chk::main(x,y,n,m);
		else cout<<chk::main(y,x,m,n);
		restore();
	}
	return 0;
}
```

---

## 作者：Nightingale_OI (赞：8)

## 简单转化

实际上，题目的 $q$ 是为了减少输入而存在的，每次求解复杂度为 $O(n+m)$。

$(f_i-g_i)(f_j-g_j)>0$ 相当于所有 $f_i>g_i$ 或所有 $f_i<g_i$。

由于 $f_1=x_1$，$g_1=y_1$，可以确定是哪种情况，不妨假设 $f_i>g_i$。

## 思路

记 $A_{[l,r]}$ 表示 $A$ 数组从第 $l$ 到第 $r$ 个元素依次排列构成的数组。

$l>r$ 时 $l,l-1,\dots,r+1,r$ 这么数，当然 $1\leq l,r\leq |A|$。

---

原问题相当于给定一个二分图，上点 $i$ 和下点 $j$ 可以连边当且仅当 $x_i>y_j$。

求是否可以每个点至少连一条边且所有边不交（重边视为相交）。

![](https://cdn.luogu.com.cn/upload/image_hosting/el3i92qh.png)

上图是一组合法解的转换方式。

发现如果存在边 $(i,j)$ 和边 $(i+1,j+1)$，一定可以存在边 $(i,j+1)$ 或 $(i+1,j)$。

这是好证的，$x_i>y_j,x_{i+1}>y_{j+1}$，假设不存在边 $(i,j+1)$ 即 $x_i\leq y_{j+1}$，则 $x_{i+1}>y_{j+1}\geq x_i>y_j$ 即存在边 $(i+1,j)$。

由此，我们需要为这个二分图连 $n+m-1$ 条不交的边，每个点至少连了一条边。

---

由于我们钦定 $f_i>g_i$，所以特殊性质为 $x_n$ 是唯一最大值，$y_m$ 是唯一最小值。

若 $Y$ 中存在元素不小于 $x_n$，显然无解，同理 $X$ 中存在元素不大于 $y_m$ 也无解。

显然最后一定存在一条边 $(n,m)$，考虑其它一定存在的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/pmgp7rt1.png)

若存在 $x_p$ 使得 $x_p>\max Y$，则一定可以存在边 $(p,m)$。

考虑一种合法方案，找到关于 $p$ 的任意边 $(p,q)$，根据大小关系 $(p,q\sim m)$ 和 $(p\sim n,m)$ 都可以连。

则原问题 $\{X,Y\}$ 和子问题 $\{X_{[1,p]},Y\}$ 等价。

同理，若有 $y_q<\min X$，则一定可以存在边 $(n,q)$ 且其右必定有解。

则原文题 $\{X,Y\}$ 和子问题 $\{X,Y_{[1,q]}\}$ 等价。

递归边界是 $n=1$ 时必定存在 $(1,1\sim m)$ 的边，问题有解，$m=1$ 同理。

考虑如果 $x_p$ 和 $y_q$ 都不存在的情况（当然可以取 $x_{p=n}$ 和 $y_{q=m}$，但是对问题规模变小没用，忽略）。

我们设 $x_a=\min X_{[1,n-1]},y_b=\max Y_{[1,m-1]}$，则必须存在边 $(a,m)$ 和 $(n,b)$，但是这两条边相交，无解。

不难证明递归构造出的连边方式满足 $n+m-1$ 条不交的边，每个点至少连了一条边。

当 $r$ 增加时，最小的满足 $x_p>\max Y_{[1,r]}$ 的 $p$ 单调不降，拿个数组维护，$y_q$ 同理，复杂度 ${\rm O}(n+m)$。

每次问题规模的 $n+m$ 至少变小 $1$，复杂度 ${\rm O}(n+m)$。

总复杂度 ${\rm O}(n+m)$，值得一提的是我们并没有用到最值唯一的性质，也没有用到是最值的性质，只要满足 $x_n>\max Y$ 和 $y_m<\min X$ 就行，所以可以递归。

---

发现只要从 $X$ 的任意最大值 $x_p$ 和 $Y$ 的任意最小值 $y_q$ 处劈开。

原问题 $\{X,Y\}$ 有解等价于 $\{X_{[1,p]},Y_{[1,q]}\}$ 有解且 $\{X_{[n,p]},Y_{[m,q]}\}$ 有解，这两个子问题都满足特殊性质。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,j,k) for(int i=j;i<=k;++i)
#define g(i,j,k) for(int i=j;i>=k;--i)
int n,m,s,l;
const int N=505050,inf=1e9+7;
inline int read(){
	int x=0;
	char ch=getchar();
	for(;!('0'<=ch&&ch<='9');ch=getchar());
	for(;'0'<=ch&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return x;
}
int a[N],b[N],c[N],d[N],pa[N],pb[N],oa[N],ob[N];
inline int clac(int *a,int*b,int n,int m){
	if(a[1]<=b[1])return 0;
	a[n+1]=inf;b[m+1]=-inf;
	int w=inf,p=1;
	f(i,1,n){
		for(w=min(w,a[i]);b[p]>=w;)++p;
		pa[i]=p;
	}
	w=-inf;p=1;
	f(i,1,m){
		for(w=max(w,b[i]);a[p]<=w;)++p;
		pb[i]=p;
	}
	while(n>1&&m>1){
		if(pa[n]<m){m=pa[n];continue;}
		if(pb[m]<n){n=pb[m];continue;}
		return 0;
	}
	return 1;
}
inline int doing(int*a,int*b,int n,int m){
	a[0]=-inf;b[0]=inf;
	int pa=0,pb=0;
	f(i,1,n)if(a[i]>a[pa])pa=i;
	f(i,1,m)if(b[i]<b[pb])pb=i;
	f(i,1,n)if(a[i]<=b[pb])return 0;
	f(i,1,m)if(b[i]>=a[pa])return 0; 
	int na=0,nb=0;
	f(i,1,pa)c[++na]=a[i];
	f(i,1,pb)d[++nb]=b[i];
	if(!clac(c,d,na,nb))return 0;
	na=nb=0;
	g(i,n,pa)c[++na]=a[i];
	g(i,m,pb)d[++nb]=b[i];
	if(!clac(c,d,na,nb))return 0;
	return 1;
}
signed main(){
	int c,q,ka,kb;
	c=read();n=read();m=read();q=read();
	f(i,1,n)oa[i]=read(); 
	f(i,1,m)ob[i]=read();
	f(_,0,q){
		f(i,1,n)a[i]=oa[i];
		f(i,1,m)b[i]=ob[i];
		if(_){
			ka=read();kb=read();
			f(e,1,ka)c=read(),a[c]=read();
			f(e,1,kb)c=read(),b[c]=read();
		}
		if(a[1]>b[1])putchar(doing(a,b,n,m)^48);
		else putchar(doing(b,a,m,n)^48);
	}
	return 0;
}
```

---

## 作者：Moeebius (赞：7)

> [full version](https://www.luogu.com.cn/blog/Moeebius/noip-2023-sol)
>
> [原](https://qoj.ac/problem/3300)，[jls sol](https://www.luogu.com.cn/blog/jiangly/xxi-open-cup-gp-of-korea)

发现题意等价于：在一个 $n$ 行 $m$ 列的网格图上，$(i,j)$ 的权值是 $a_i-b_j$，每次只能向下/向右/向右下方走一格，求出能否从 $(1,1)$ 走到 $(n,m)$，并且路径上每个点正负性都相同，且不能为 $0$。

进一步地：
- 可以发现正负性的要求其实和 $a_1,b_1$ 的大小关系有关，特判掉 $a_1=b_1$ 的情况（无解），若 $a_1<b_1$ 则交换两个序列。然后转化成要求每个点权值大于 $0$。

- 向右下方走一格是没有意义的，一定可以被替换成向右和向下的组合。

---

考虑什么时候会走不到：

- 1. 一整行都不合法，即 $\min\{a\} \le \min\{b\}$
- 2. 一整列都不合法，即 $\max\{b\} \ge \max\{a\}$
- 3. 起点被围住了：$\exists (x,y)$ 使得 $(x,1),(x,2),\dots,(x,y)$ 和 $(1,y),(2,y),\dots,(x,y)$ 均不合法。
- 4. 终点被围住了：$\exists (x,y)$ 使得 $(x,y),(x,y+1),\dots,(x,m)$ 和 $(x,y),(x+1,y),\dots,(n,y)$ 均不合法。

如果以上 $4$ 种情况都不存在，则 **一定有解**。

**Proof:**

- 起点和终点一定合法；
- 一定存在某一整列合法、某一整行合法，设该行、该列交点为 $(p,q)$；
- 由于起点没有被围住，一定存在 $(p',q)\ (p'<p)$ 或 $(p,q')\ (q'<q)$ 满足其为起点或其所在的一行/一列均合法。直接从该点走过来即可。终点同理。
- 容易发现，这样一定可以找到一组解。

---

由此，有一个简单的 $O(n\log m)$ 做法：

- 第一种和第二种不合法的情况可以直接判掉。
- 对于第三种，枚举 $x$，二分出最大的 $y$ 满足 $\min_{i=1}^{y}\{b_i\}\ge a_x$，若 $\max_{i=1}^{y}\{b_i\}\ge \max_{i=1}^{x}\{a_i\}$ 则不合法。
- 对于第四种，我们可以把序列 `reverse` 之后再做一遍。

可以获得 [$\mathtt{75pts}$](https://www.luogu.com.cn/record/137186564) 的高分！

---

考虑优化到线性。

容易发现有可能对答案造成影响的 $a_i$ 是一个严格递减序列；于是我们需要找的 $y$ 也有了单调性。可以把二分扬了！

时间复杂度 $O(\sum n+m)$。

```cpp
constexpr ll MAXN = 5e5 + 5;
int c, n, m, q, a[MAXN], b[MAXN], maxa[MAXN], maxb[MAXN], mina[MAXN],
    minb[MAXN];
il int cmp(int x, int y) { return x == y ? 0 : (x < y ? -1 : 1); }
il void init_val() {
  maxa[0] = maxb[0] = -1;
  mina[0] = minb[0] = 1e9 + 5;
  For(i, 1, n) maxa[i] = max(maxa[i - 1], a[i]),
               mina[i] = min(mina[i - 1], a[i]);
  For(i, 1, m) maxb[i] = max(maxb[i - 1], b[i]),
               minb[i] = min(minb[i - 1], b[i]);
}
il void solve() {
  if (!cmp(a[1], b[1]))
    return putchar('0'), void();
  int tp = cmp(a[1], b[1]);
  if (tp == 1) {
    init_val();
    if (mina[n] <= minb[m] || maxa[n] <= maxb[m])
      return putchar('0'), void();
    int p = 1;
    For(i, 1, n) {
      if (a[i] >= mina[i - 1])
        continue;
      while (p <= m && minb[p] >= a[i])
        p++;
      if (maxb[p - 1] >= maxa[i])
        return putchar('0'), void();
    }
    reverse(a + 1, a + 1 + n), reverse(b + 1, b + 1 + m);
    init_val();
    p = 1;
    For(i, 1, n) {
      if (a[i] >= mina[i - 1])
        continue;
      while (p <= m && minb[p] >= a[i])
        p++;
      if (maxb[p - 1] >= maxa[i]) {
        reverse(a + 1, a + 1 + n), reverse(b + 1, b + 1 + m);
        return putchar('0'), void();
      }
    }
    reverse(a + 1, a + 1 + n), reverse(b + 1, b + 1 + m);
    return putchar('1'), void();
  } else {
    init_val();
    if (mina[n] >= minb[m] || maxa[n] >= maxb[m])
      return putchar('0'), void();
    int p = 1;
    For(i, 1, n) {
      if (a[i] <= maxa[i - 1])
        continue;
      while (p <= m && maxb[p] <= a[i])
        p++;
      if (minb[p - 1] <= mina[i])
        return putchar('0'), void();
    }
    reverse(a + 1, a + 1 + n), reverse(b + 1, b + 1 + m);
    init_val();
    p = 1;
    For(i, 1, n) {
      if (a[i] <= maxa[i - 1])
        continue;
      while (p <= m && maxb[p] <= a[i])
        p++;
      if (minb[p - 1] <= mina[i]) {
        reverse(a + 1, a + 1 + n), reverse(b + 1, b + 1 + m);
        return putchar('0'), void();
      }
    }
    reverse(a + 1, a + 1 + n), reverse(b + 1, b + 1 + m);
    return putchar('1'), void();
  }
}
il void solver_main() {
  freopen("expand.in", "r", stdin);
  freopen("expand.out", "w", stdout);
  read(c, n, m, q);
  For(i, 1, n) read(a[i]);
  For(i, 1, m) read(b[i]);
  solve();
  while (q--) {
    vector<pii> oa, ob;
    int k1, k2;
    read(k1, k2);
    For(i, 1, k1) {
      int p, v;
      read(p, v);
      oa.eb(p, v), swap(a[p], oa.back().se);
    }
    For(i, 1, k2) {
      int p, v;
      read(p, v);
      ob.eb(p, v), swap(b[p], ob.back().se);
    }
    solve();
    for (auto [p, v] : oa)
      a[p] = v;
    for (auto [p, v] : ob)
      b[p] = v;
  }
}
```

---

## 作者：EuphoricStar (赞：5)

首先 $x_1 = y_1$ 显然不合法。若 $x_1 > y_1$ 就把 $x, y$ 全部取相反数，这样就只用考虑 $x_1 < y_1$ 的情况了。

然后考虑一个 $O(nmq)$ 的 dp，设 $f_{i, j}$ 为拓展 $X$ 的前 $i$ 个元素和 $Y$ 的前 $j$ 个元素是否可行。那么若 $x_i < y_j$ 则 $f_{i, j}$ 取 $f_{i - 1, j}, f_{i, j - 1}, f_{i - 1, j - 1}$ 的或，否则 $f_{i, j} = 0$。

发现这个 dp 的转移形式很像网格上行走，于是考虑转成网格上的问题。考虑令 $c_{i, j} = [x_i < y_j]$，那么可行当且仅当能找到一条从 $(1, 1)$ 到 $(n, m)$ 的全为 $1$ 的**八连通**的路径。

注意到任意两行之间 $1$ 的位置总是包含关系，这意味着不用考虑斜着走，即 $(i - 1, j - 1)$ 走到 $(i, j)$，因为可以被 $(i - 1, j - 1) \to (i - 1, j) \to (i, j)$ 或 $(i - 1, j - 1) \to (i, j - 1) \to (i, j)$ 的其中一个代替。于是只用考虑**四连通**的路径。

考虑从特殊性质入手，即网格第 $n$ 行和第 $m$ 列全为 $1$（如果不全为 $1$ 一定不可行），这样只要到达第 $n$ 行或第 $m$ 列就赢了。考虑递归求解，设 $f(n, m)$ 为当前在 $(1, 1)$，是否能到达第 $n$ 行或第 $m$ 列。设 $i = \operatorname{argmin}_{k = 1}^{n - 1}\{x_k\}, j = \operatorname{argmax}_{k = 1}^{m - 1}\{y_k\}$。若第 $i$ 列全为 $1$ 则可以直接递归至 $f(i, m)$，若第 $j$ 列全为 $1$ 则可以直接递归至 $f(n, j)$；若都不满足，则网格一定存在一个以 $0$ 组成的十字架，把起点和终点隔开，于是这种情况直接返回不可行。所有要用到的信息都能预处理 $x, y$ 的前缀 $\text{minmax}$ 数组然后 $O(1)$ 求出，所以复杂度为 $O((n + m)q)$。

对于一般的情况，考虑设 $u = \operatorname{argmin}_{k = 1}^n\{x_k\}, v = \operatorname{argmax}_{k = 1}^m\{y_k\}$，那么第 $u$ 行和第 $v$ 列一定要全为 $1$。容易发现网格被第 $u$ 行和第 $v$ 列分成了左上角和右下角两个互相独立的部分，于是把右下角的部分翻转过来，做一遍同样的问题即可。

总时间复杂度就是 $O((n + m)q)$。

```cpp
#include <bits/stdc++.h>
#define fst first
#define scd second
#define pb emplace_back
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef double db;
typedef long double ldb;

inline int read() {
	int x = 0;
	bool f = 0;
	char c = getchar();
	while (c < '0' || c > '9') {
		f |= (c == '-');
		c = getchar();
	}
	while ('0' <= c && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f ? -x : x;
}

const int maxn = 500100;
const int inf = 0x3f3f3f3f;

int n, m, q, test, a[maxn], b[maxn];

int c[maxn], d[maxn];
pii pcmn[maxn], pcmx[maxn], pdmn[maxn], pdmx[maxn];
pii scmn[maxn], scmx[maxn], sdmn[maxn], sdmx[maxn];

int dfs1(int x, int y) {
	if (x == 1 || y == 1) {
		return 1;
	}
	int p1 = pcmn[x - 1].scd, p2 = pdmx[y - 1].scd;
	if (c[p1] < pdmn[y - 1].fst) {
		return dfs1(p1, y);
	} else if (pcmx[x - 1].fst < d[p2]) {
		return dfs1(x, p2);
	} else {
		return 0;
	}
}

int dfs2(int x, int y) {
	if (x == n || y == m) {
		return 1;
	}
	int p1 = scmn[x + 1].scd, p2 = sdmx[y + 1].scd;
	if (c[p1] < sdmn[y + 1].fst) {
		return dfs2(p1, y);
	} else if (scmx[x + 1].fst < d[p2]) {
		return dfs2(x, p2);
	} else {
		return 0;
	}
}

inline int calc() {
	if (c[1] == d[1]) {
		return 0;
	}
	if (c[1] > d[1]) {
		for (int i = 1; i <= n; ++i) {
			c[i] = -c[i];
		}
		for (int i = 1; i <= m; ++i) {
			d[i] = -d[i];
		}
	}
	pcmn[0].fst = pdmn[0].fst = inf;
	pcmx[0].fst = pdmx[0].fst = -inf;
	for (int i = 1; i <= n; ++i) {
		pcmn[i] = min(pcmn[i - 1], mkp(c[i], i));
		pcmx[i] = max(pcmx[i - 1], mkp(c[i], i));
	}
	for (int i = 1; i <= m; ++i) {
		pdmn[i] = min(pdmn[i - 1], mkp(d[i], i));
		pdmx[i] = max(pdmx[i - 1], mkp(d[i], i));
	}
	scmn[n + 1].fst = inf;
	sdmn[m + 1].fst = inf;
	scmx[n + 1].fst = -inf;
	sdmx[m + 1].fst = -inf;
	for (int i = n; i; --i) {
		scmn[i] = min(scmn[i + 1], mkp(c[i], i));
		scmx[i] = max(scmx[i + 1], mkp(c[i], i));
	}
	for (int i = m; i; --i) {
		sdmn[i] = min(sdmn[i + 1], mkp(d[i], i));
		sdmx[i] = max(sdmx[i + 1], mkp(d[i], i));
	}
	int p1 = pcmn[n].scd, p2 = pdmx[m].scd;
	for (int i = 1; i <= m; ++i) {
		if (c[p1] >= d[i]) {
			return 0;
		}
	}
	for (int i = 1; i <= n; ++i) {
		if (c[i] >= d[p2]) {
			return 0;
		}
	}
	return dfs1(p1, p2) && dfs2(p1, p2);
}

void solve() {
	test = read();
	n = read();
	m = read();
	q = read();
	for (int i = 1; i <= n; ++i) {
		a[i] = read();
	}
	for (int i = 1; i <= m; ++i) {
		b[i] = read();
	}
	for (int i = 1; i <= n; ++i) {
		c[i] = a[i];
	}
	for (int i = 1; i <= m; ++i) {
		d[i] = b[i];
	}
	putchar('0' + calc());
	while (q--) {
		for (int i = 1; i <= n; ++i) {
			c[i] = a[i];
		}
		for (int i = 1; i <= m; ++i) {
			d[i] = b[i];
		}
		int kx, ky;
		kx = read();
		ky = read();
		while (kx--) {
			int x, y;
			x = read();
			y = read();
			c[x] = y;
		}
		while (ky--) {
			int x, y;
			x = read();
			y = read();
			d[x] = y;
		}
		putchar('0' + calc());
	}
	putchar('\n');
}

int main() {
	int T = 1;
//	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
```

----

有小丑场上把

```cpp
for (int i = 1; i <= n; ++i) {
	c[i] = a[i];
}
for (int i = 1; i <= m; ++i) {
	d[i] = b[i];
}
```

写成了

```cpp
for (int i = 1; i <= n; ++i) {
	c[i] = a[i];
	d[i] = b[i];
}
```

暴挂 $30$ 分，怎么会是呢。

---

## 作者：hxhhxh (赞：5)

### 题意
定义一个序列 $a_{1,\dots n}$ 是一个序列 $b_{1,\dots m}$ 的拓展当且仅当可以将 $a$ 划分成 $m$ 个连续的非空段，使得按顺序的第 $i$ 段中的所有元素都等于 $b_i$。

给序列 $a_{1,\dots n}$，$b_{1,\dots m}$，求是否存在长度为 $10^{100}$ 的序列 $s,t$，使得 $s$ 是 $a$ 的拓展，$t$ 是 $b$ 的拓展，且 $\forall (i,j)\in[1,10^{100}]^2,(s_i-t_i)(s_j-t_j)>0$。

有 $q$ 次询问，每次会**基于原序列**改 $k$ 个地方并要求输出答案。

$n,m,\sum k\leq 5\times 10^5,q\leq 60$

### 做法
显然每次询问可能基本无关。所以相当于要求 ${\rm O}(n+m)$ 解决每次询问。 

取 $i=j=1$，即得 $s_1>t_1\lor s_1<t_1$，不妨设 $s_1<t_1$；带入 $i=1,j\in[2,10^{100}]$ 得 $s_j<t_j$。有 $s_1=a_1$，$t_1=b_1$，所以直接比较 $a_1$ 与 $b_1$ 就可以知道是 $s_i<t_i$ 还是 $s_i>t_i$（或者 $a_1=b_1$，**一定无解**${}^{[0]}$）。下直接假设 $s_i<t_i$。

考虑两个序列一起拓展的意义。它相当于在 $n+m$ 个点的二分图上连至多 $n+m-1$ 条边，要求边不能相交，每个点至少连一条边，且对于所有边 $(i,j)$，满足 $a_i<b_j$。

如果存在 $i,j$ 使得 $(i,j)$ 与 $(i+1,j+1)$ 之间都有边，那么 $(i,j+1)$ 和 $(i+1,j)$ 这两条边至少一条是合法的，连上不会影响合法性，所以可以假设连了 $n+m-1$ 条边。 

设 $b$ 的最大值位置为 $p$，若有多个随便选一个。如果 $a$ 中存在不小于 $b_p$ 的数，$p$ 无法匹配，就**一定无解**${}^{[1]}$。设 $a$ 的最小值位置为 $q$，有多个任选，显然也不能出现 $j$ 使得 $b_j\leq a_q$，不然 $j$ 无法匹配，**一定无解**${}^{[2]}$。对于这两个数，如果一个合法方案中它们之间没有连边，我们一定可以在不影响合法性的情况下调整为它们之间有连边。

![这里有一张图](https://cdn.luogu.com.cn/upload/image_hosting/74lhzo3m.png)

像这样，黑色边是原来的方案，绿色边是修改的方案，下面是 $a$，上面是 $b$。直接将 $p,q$ 连边，并将与之相交的边删去，剩下的点直接向 $p,q$ 之一连边即可。此时问题转化为无关的两部分 $a_{1,\dots,p}$，$b_{1,\dots,q}$ 及剩下的一半。两边是对称的，下面只处理左半部分。

若 $\min(p,q)=1$，连边方法是唯一的，可以直接判断是否合法，下设 $p>1,q>1$。这里 $p$ 是 $b_{1,\dots p}$ 的最大值位置之一，$q$ 是 $a_{1,\dots q}$ 的最大值位置之一。

找到 $b$ 最小值，设位置为 $r$（多个任意找，要不同于 $p$，若 $p>1$ 显然可以找到）。再找到 $a$ 序列中第一个小于 $b_r$ 的位置 $u$（$u$ 可以与 $q$ 重合，找不到说明 $r$ 无法匹配，**一定无解**${}^{[3]}$）。那么 $a_u$ 比 $b$ 中任何元素都小。如果一种合法方案中 $u$ 与 $r$ 之间没有连边，一定可以在不影响合法性地调整到 $u$ 和 $r$ 之间有连边。

![这里有另一张图](https://cdn.luogu.com.cn/upload/image_hosting/3xd5bakx.png)

像这样，黑色边是原来的方案，绿色边是修改的方案。直接将 $u,r$ 连边，并将与之相交的边删去，剩下的点直接向 $u,p$ 之一连边即可。注意到 $p$ 是 $b$ 的最大值，且 $u$ 的左边不会有向 $p$ 的连边（否则 $r$ 原本的边就是不合法的），所以这样连边一定仍然合法。当 $u$ 和 $r$ 之间有连边后，$u$ 到 $q$ 的点和 $r$ 到 $p$ 的点一定有合法的连边方案（$r$ 到 $p$ 的所有点连向 $u$，$u$ 到 $q$ 的所有点连向 $p$）。

继续找 $b_{1,\dots r}$ 中的最大值位置 $v$（多个任意找）。此时 $b_v$ 应该比 $a_{1,\dots,u}$ 中的所有元素都要大（否则 $a$ 中违反的元素无法匹配，**一定无解**${}^{[4]}$）。 注意到如果一种合法方案中 $u$ 与 $v$ 之间没有连边，一定可以在不影响合法性地调整到 $u$ 和 $v$ 之间有连边。

![这里还有一张图](https://cdn.luogu.com.cn/upload/image_hosting/1jas4txa.png)

像这样，黑色边是原来的方案，绿色边是修改的方案。直接将 $u,v$ 连边，并将与之相交的边删去，剩下的点直接向 $u,v$ 之一连边即可。这一调整和使 $p,q$ 有连边的调整的类似。若 $u,v$ 之间有连边，则 $v$ 到 $r$ 之间的点一定可以全部连向 $u$，即有合法方案。

此时 $v$ 为 $b_{1,\dots v}$ 的最大值位置之一，$u$ 是 $a_{1\dots u}$ 中的最小值位置之一，而 $v$ 与 $p$ 不重叠。我们要解决的问题与原本的问题完全一样，可以直接递归地解决。但是为了代码效率，我使用循环来模拟递归过程。

在上面的过程中你需要求最小值及其位置。发现每个求最小值的位置都只要求前缀最小值，所以可以每次询问分别预处理。单次询问时间复杂度 ${\rm O}(n+m)$。唯一一处不是求最小值位置的地方是求 $u$。由于 $u$ 只会向左移动，所以这部分也不难做到 ${\rm O}(n+m)$，具体实现可以看代码。

时间复杂度是 ${\rm O}(q(n+m))$，可以通过此题。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int F,n,m,q,A[500005],B[500005],a[500005],b[500005],amx[500005],amn[500005],bmx[500005],bmn[500005];
string ans;
bool slove(int p,int q){
	if(a[1]==b[1]) return false;//[0]处的无解条件
	if(p==1||q==1) return true;
	//求的是前缀最值的位置而不是值
	amx[1]=amn[1]=bmx[1]=bmn[1]=1;
	for(int i=2;i<=n;i++){
		amx[i]=amx[i-1];
		amn[i]=amn[i-1];
		if(a[i]>a[amx[i]]) amx[i]=i;
		if(a[i]<a[amn[i]]) amn[i]=i;
	}
	for(int i=2;i<=m;i++){
		bmx[i]=bmx[i-1];
		bmn[i]=bmn[i-1];
		if(b[i]>b[bmx[i]]) bmx[i]=i;
		if(b[i]<b[bmn[i]]) bmn[i]=i;
	}
	//下面的变量名和上面描述的一样
	while(p>1&&q>1){
		bool s=0;
		int r=bmn[p];
		int u=q;
		while(u&&a[amn[u]]<b[r]) u--,s=1;//u前面还有比r小的
		//这样就找到了最后一个位置，使得它前面没有比r小的
		u++;
		if(!s) return false;//[3]处的无解条件
		int v=bmx[r];
		if(a[amx[u]]>=b[v]) return false;//[4]处的无解条件
		p=v,q=u;
	}
	return true;
}
void rev(){
	for(int i=1;i+i<=n;i++) swap(a[i],a[n-i+1]);
	for(int i=1;i+i<=m;i++) swap(b[i],b[m-i+1]);
}
bool solve(){
	int R=0;
	if(a[1]>b[1]){
		R=1;
		for(int i=1;i<=max(n,m);i++) swap(a[i],b[i]);
		swap(n,m);
		//交换序列，保证a[1]<=b[1]
	}
	int p=1,q=1;
	for(int i=1;i<=n;i++) if(a[i]<a[q]) q=i;
	for(int i=1;i<=m;i++) if(b[i]>b[p]) p=i;
	int s=0;
	for(int i=1;i<=n;i++) if(a[i]>=b[p]) s=1;//[1]处的无解条件
	for(int i=1;i<=m;i++) if(b[i]<=a[q]) s=1;//[2]处的无解条件
	if(s){
		if(R) swap(n,m);
		//记得换回来
		return false;
	}
	if(slove(p,q)){
		rev();//处理另一侧的问题，为了方便可以反转序列
		bool t=slove(m-p+1,n-q+1);
		if(R) swap(n,m);
		return t;
	}
	if(R) swap(n,m);
	return false;
}
int main(){
	cin>>F>>n>>m>>q;
	for(int i=1;i<=n;i++) scanf("%d",&A[i]),a[i]=A[i];
	for(int i=1;i<=m;i++) scanf("%d",&B[i]),b[i]=B[i];
	ans+=solve()+'0';
	for(int i=1,j,k,l,o;i<=q;i++){
		for(int p=1;p<=n;p++) a[p]=A[p];
		for(int p=1;p<=m;p++) b[p]=B[p];
		scanf("%d %d",&j,&k);
		for(;j--;a[l]=o) scanf("%d %d",&l,&o);
		for(;k--;b[l]=o) scanf("%d %d",&l,&o);
		ans+=solve()+'0';
	}
	cout<<ans;
	return 0; 
}

```

---

## 作者：Phartial (赞：4)

首先不难将题意转化为：有一个 $n\times m$ 的矩阵 $c_{i,j}=[x_i<y_j]$，从 $(1,1)$ 开始，你每次可以往右、下或右下走一步，且只能经过 $c_{i,j}=1$ 的格子，问是否能走到 $(n,m)$。

**注意到** $(1,1)$ 不能够走到 $(n,m)$ 当且仅当出现以下四种情况之一：

- 存在 $i$，使得对所有 $j$，有 $c_{i,j}=0$（即 $\max(x_i)\ge\max(y_j)$）；
- 存在 $j$，使得对所有 $i$，有 $c_{i,j}=0$（即 $\min(x_i)\ge\min(y_j)$）；
- 存在 $i,j$，使得对所有 $k\le j$，有 $c_{i,k}=0$，且对所有 $u\le i$，有 $c_{u,j}=0$（即存在 $i,j$，使得 $x_i\ge\max\limits_{k\le j}(y_k)$，且 $\min\limits_{u\le i}(x_u)\ge y_j$）；
- 存在 $i,j$，使得对所有 $k\ge j$，有 $c_{i,k}=0$，且对所有 $u\ge i$，有 $c_{u,j}=0$（即存在 $i,j$，使得 $x_i\ge\max\limits_{k\ge j}(y_k)$，且 $\min\limits_{u\ge i}(x_u)\ge y_j$）；

证明：若前两种情况都未出现，那么必然存在一行全为 $1$（否则条件 $1$ 会被满足）且存在一列全为 $1$（否则条件 $2$ 会被满足），设这一行和这一列的交点为 $(r,c)$，那么我们只需要证明 $(1,1)$ 能走到 $(r,c)$ 且 $(r,c)$ 能走到 $(n,m)$，不失一般性，以下只考虑如何从 $(1,1)$ 走到 $(r,c)$。

若 $(r,c)=(1,1)$，那么显然得证。否则必然存在一行 $r'$ 与一列 $c'$，使得对所有 $k\le c'$ 都有 $c_{r',k}=1$ 且对所有 $k\le r'$ 都有 $c_{k,c'}=1$（否则条件 $3$ 会被满足），则我们只需证明 $(1,1)$ 能够走到 $(r',c')$ 且 $(r',c')$ 能够走到 $(r,c)$，这可以通过归纳证明，于是该结论得证。

前两种情况不难维护，对于第三种情况，注意到如果存在 $i$，那么必然存在在 $x_i$ 的前缀最大值上的 $i$，于是 $x_i$ 变得单调递增，因此 $j$ 也变得单调不降，维护合法的 $j$ 的前缀最小值即可。第四种情况可以类似地处理。

时间复杂度 $\mathcal{O}(q(n+m))$。

```cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int kN = 5e5 + 1;

int cid, n, m, q, a[kN], b[kN], _a[kN], _b[kN];

bool S() {
  if (a[1] == b[1]) {
    return 0;
  }
  int *x, *y, n, m;
  if (a[1] < b[1]) {
    x = a, y = b;
    n = ::n, m = ::m;
  } else {
    x = b, y = a;
    n = ::m, m = ::n;
  }
  if (*max_element(x + 1, x + n + 1) >= *max_element(y + 1, y + m + 1) || *min_element(x + 1, x + n + 1) >= *min_element(y + 1, y + m + 1)) {
    return 0;
  }
  for (int i = 1, mx = -1, mn = 1e9, j = 1, p = 1; i <= n; ++i) {
    mn = min(mn, x[i]);
    if (x[i] <= mx) {
      continue;
    }
    mx = x[i];
    for (; j <= m && y[j] <= x[i]; ++j) {
    }
    for (; p < j && mn < y[p]; ++p) {
    }
    if (p < j) {
      return 0;
    }
  }
  for (int i = n, mx = -1, mn = 1e9, j = m, p = m; i >= 1; --i) {
    mn = min(mn, x[i]);
    if (x[i] <= mx) {
      continue;
    }
    mx = x[i];
    for (; j >= 1 && y[j] <= x[i]; --j) {
    }
    for (; p > j && mn < y[p]; --p) {
    }
    if (p > j) {
      return 0;
    }
  }
  return 1;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> cid >> n >> m >> q;
  for (int i = 1; i <= n; ++i) {
    cin >> _a[i];
  }
  for (int i = 1; i <= m; ++i) {
    cin >> _b[i];
  }
  copy_n(_a + 1, n, a + 1);
  copy_n(_b + 1, m, b + 1);
  cout << S();
  for (int kx, ky; q--;) {
    copy_n(_a + 1, n, a + 1);
    copy_n(_b + 1, m, b + 1);
    cin >> kx >> ky;
    for (int p; kx--;) {
      cin >> p >> a[p];
    }
    for (int p; ky--;) {
      cin >> p >> b[p];
    }
    cout << S();
  }
  return 0;
}
```

---

## 作者：RyexAwl (赞：3)

对于 $y_1>x_1$ 的情况可以转化为 $x_1<y_1$，因此只考虑这一种情况的做法。

先考虑特殊性质怎么做。

注意到题意等价于 $X$ 中每个元素匹配 $Y$ 中的一个区间 $[l_i,r_i]$ 满足 $l_1=1$，$\forall i>1$，$l_i=r_{i-1}$ 或 $l_i=r_{i-1}+1$。

注意到，如果 $l_i<r_i$ 且 $l_i=r_{i-1}$，那么总是可以调整为 $l_i:=r_{i-1}+1$。

那么对于 $X_i$，有两种匹配选项：

- $l_i=r_{i-1}+1,r_i\ge l_i$。

- $l_i=r_i=r_{i-1}$。

考虑所有第一类的 $i$ 构成的关键点 $p_1,p_2,\dots,p_k$，特别地，$p_{k+1}=n+1$，及其匹配的区间 $[l_{p_i},r_{p_i}]$，合法的充要条件为 $\forall 1\le i\le k$:

- $\forall j\in [l_{p_i},r_{p_i}]$,$y_j>x_{p_i}$。

- $\forall j\in (p_i,p_{i+1})$，$x_j<y_{r_{p_i}}$。

那么 $\forall 1\le i\le k$，考虑将 $y_{l_{p_i}}\sim y_{r_{p_i}}$ 和 $x_{p_i}$ 分在一组，$x_{p_{i}+1}\sim x_{p_{i+1}-1}$ 和 $y_{r_{p_i}}$ 分在一组。

那么可以看成交替在 $X$ 和 $Y$ 中选第一个元素匹配另一个序列的一段前缀，然后将这个元素和匹配的前缀删掉。

但是有一个问题，$p_i+1=p_{i+1}$ 时有可能连续在 $X$ 中连续选两次。此时一定有 $l_{p_i}\ne r_{p_i},l_{p_{i+1}}\ne r_{p_{i+1}}$。

但是我们可以进行调整法搞一搞。设 $p_i=j$，$p_{i+1}=j+1$。

如果 $x_{j}\le x_{j+1}$，那么可以令 $r_j:=r_{j+1}-1$，$l_{j+1}=r_{j+1}$。

如果 $x_j\ge x_{j+1}$，那么令 $r_j:=l_j$，$l_{j+1}=l_{j}+1$。

对于可能连续在 $Y$ 中选连续两次的情况的调整是对称的。

那么考虑当前匹配哪个前缀，考虑贪一下，在能匹配的前提下，如果是用 $X$ 的头匹 $Y$ 的前缀，让剩下的 $Y$ 的头尽量大，如果是用 $Y$ 的头匹 $X$ 的前缀，让剩下的 $X$ 的头尽量小。

那么考虑单调栈维护 $X$ 中每个数右边第一个小于等于它的数，并且递推区间 $\max$。维护 $Y$ 中每个数右边第一个大于等于它的数，并且递推区间 $\min$。

但是注意到上面的做法在不满足 $x_n$ 是最小值，$y_m$ 是最大值的情况下不一定正确。因为你可以留下的东西更劣，但是你匹配的前缀尽量更长，让后面的能匹完。

但是注意到我们可以找到 $X$ 的最小值位置 $p$，$y$ 中的最大值位置 $q$，对 $x_1\sim x_p,y_1\sim y_q$ 做一遍，对 $x_p\sim x_n,y_q\sim y_m$ 做一遍。当且仅当两个都合法，整个序列合法。

复杂度 $O(q(n+m))$。

---


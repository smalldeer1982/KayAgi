# 「Stoi2031」蒲公英的约定（vol.1）

## 题目背景

> 一起长大的约定 那样清晰 拉过勾的我相信 说好要一起旅行 是你如今 唯一坚持的任性 ——《蒲公英的约定》

## 题目描述

清和如在玩游戏。她们有 $n$ 丛 **蒲公英**，每丛分别有 $s_i$ 朵。这些 **蒲公英** 有一个神奇的性质：有一个给定的常数 $\sigma \in (0,1)$，$x$ 朵 **蒲公英** 会分出 $\lfloor \sigma x \rfloor$ 朵为一组，剩下 $x-\lfloor \sigma x \rfloor$ 朵继续分组，直到分出的组没有 **蒲公英** 即 $\lfloor \sigma x \rfloor=0$ 为止。她们称这种现象为 **任性**。现在她们的每丛 **蒲公英** 都有 **任性** 的现象。她们的游戏规则如下：从清开始，两人轮流进行 **旅行**。一次 **旅行** 为选择一丛 **蒲公英** 并吹散这一丛的第一组中的若干朵 **蒲公英**，至少要吹一朵，至多吹的朵数为第一组的朵数，即不能吹散除第一组外的 **蒲公英**。当第一组为空时，其下一组成为第一组。若这一丛只剩下一组 **蒲公英**，这一丛不能再被选定。每丛 **蒲公英** 都不能被选定时，游戏结束，当前轮到的人落败。她们想知道如果清第一次 **旅行** 时等概率选择其中一丛可吹散的 **蒲公英** 再等概率选择吹散的朵数后两人都按最优策略操作，那么清的胜率 $x \bmod 20190816170251$ 的值将会是多少。

与 vol.2 的区别是，**蒲公英** 在被吹散一部分后 **不会** 重新分组。

## 说明/提示

#### 简述版题意：

有 $n$ 丛 **蒲公英**，第 $i$ 丛有 $s_i$ 朵。给定实数 $\sigma$，每丛会分为若干组，第 $j$ 组有 $t_j$ 朵，且满足 $t_j=\left\lfloor \sigma\left(s_i - \sum\limits_{k=1}^{j-1}t_k\right) \right\rfloor$，当 $t_j=0$ 时不再分组。两人轮流操作，每次操作可以选择一丛 **蒲公英**，并选择一个整数 $c \in t_j$，从这丛 **蒲公英** 中吹散 $c$ 朵，将 $t_j$ 变为 $t_j-c$，其中 $j$ 为操作之前这丛 **蒲公英** 中满足 $t_j \neq 0$ 的最小正整数。必须至少吹一朵，不能操作者败。求先手第一步等概率选择任意一丛可操作的 **蒲公英** 再等概率选择吹散的朵数后两人都采取最优策略时先手的胜率 $x \bmod{20190816170251}$ 的值。

#### 样例解释：

对于样例 $1$，清无法操作，胜率为 $0$。

对于样例 $2$，初始局面为 $\{0;1\},\{2,1,1,1,0;2\},\{1,0;2\}$，清可以选择第 $2$ 丛并在两种操作中选择吹散 $2$ 朵变成 $\{0;1\},\{1,1,1,0;2\},\{1,0;2\}$，选择第 $3$ 丛没有可取胜的策略，且第 $1$ 丛不能选择，总胜率为 $\dfrac{\frac{1}{2}+0}{2}=\dfrac{1}{4}$。

#### 数据范围：

**本题采用捆绑测试，各个 Subtask 的分数与限制如下。**

| Subtask No. | $n \le$ | $s_i \le$ | $\sigma$ 限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{2}+1}{3}$ | $10$ |
| $2$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{3}+1}{5}$ | $10$ |
| $3$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{5}-1}{2}$ | $10$ |
| $4$ | $100$ | $1$ | 无 | $3$ |
| $5$ | $100$ | $100$ | $\sigma=\dfrac{1}{2}$ | $7$ |
| $6$ | $100$ | $10^6$ | 无 | $13$ |
| $7$ | $3 \times 10^5$ | $10^{10}$ | $\sigma \ge \dfrac{1}{2}$ | $47$ |

对于 $100\%$ 的数据，$1 \le n \le 3 \times 10^5,1 \le s_i \le 10^{10},1 \le p<q \le 10^9$。

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
4 3
1 1 1
1 6
```

### 输出

```
0
```

## 样例 #2

### 输入

```
6 3
1 7 3
1 3
```

### 输出

```
5047704042563
```

# 题解

## 作者：VinstaG173 (赞：7)

显然是 SG 函数题。

如果不会 SG 函数可以学一下，推销[我的博客](https://59388.blog.luogu.org/game-theory-1)。

题外话：本来想直接出先手是否必胜的，后来懒得构造后手必胜数据就整成现在这样脚造数据都骗不到分的问法（

有一说一，这题的 SG 函数还是很好求的，不用找什么规律，证明更是非常简单。

回到题解。

首先我们考虑一串数列 $(a_1,a_2,\dots,a_n,0)$ 的 SG 值。

显然 $(0)$ 的 SG 值为 $0$。现在考虑 $(a_2,\dots,a_n,0)$ 的 SG 值已知且为 $t$。

显然 $(a_1,a_2,\dots,a_n,0)$ 的后继状态有 $(a_1-1,a_2,\dots,a_n,0),(a_1-2,a_2,\dots,a_n,0),\dots,(a_2,\dots,a_n,0)$。由此可以发现 $(a_1,a_2,\dots,a_n,0)$ 的 SG 函数值在 $a_1 \le t$ 时为 $a_1-1$，在 $a_1 > t$ 时为 $a_1$。

再看原题中 $x$ 的 SG 函数。显然 $t_1=\lfloor\sigma x\rfloor\ge\lfloor\sigma(x-t_1)\rfloor=t_2$，所以只有 $t_1=t_2$ 且 $x-\lfloor\sigma x\rfloor$ 的 SG 函数值为 $t_2$ 时 $x$ 的 SG 函数值才为 $t_1-1$，其余情况均为 $t_1$。这样就可以 $O(1)$ 求出 $x$ 的 SG 值了。

显然有 $x$ 及其后继状态 SG 值取遍 $0,1,\dots,\lfloor\sigma x\rfloor$ 且互不重复。因此只要对于最终整个游戏的 SG 值 $ans$ 满足 $\operatorname{SG}(x) \operatorname{xor} ans \le \lfloor\sigma x\rfloor$ 则将答案加上 $\dfrac{1}{n\lfloor\sigma x\rfloor}$。

时间复杂度 $O(n\log{n})$。

Code:
```cpp
#include<cstdio>
#define rg register
#define LL __int128
#define ll unsigned long long
#define _tau(x) ((ll)((id<4)?(x*tau[id]):((x*q-1)/p)))
#define _sigma(x) ((ll)((id<4)?(x*sigma[id]):(x*p/q)))
const ll ntf=20190816170251;
inline char rc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
inline ll _read()
{
	ll x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
void print(LL x)
{
	if(x>9)print(x/10);
	putchar(x%10^48);
}
int id,n,m;
ll s[300007],d,p,q,r,SG[300007];
double tau[7]={0,1.242640687119285,1.8301270189222,1.61803398874989};
double sigma[7]={0,0.8047378541243,0.5464101615137,0.61803398874989};
inline ll _gcd(ll a,ll b)
{
	while(b^=a^=b^=a%=b);
	return a;
}
inline ll sg(ll x)
{
	ll t=_sigma(x);
	if(!t)return 0;
	return t-(((x-_tau(t)-1)/t)&1);
}
LL exgcd(LL a,LL b,LL &x,LL &y)
{
	if(!b)
	{
		x=1,y=0;
		return a;
	}
	LL d=exgcd(b,a%b,y,x);
	y-=a/b*x;return d;
}
inline LL _inv(LL a)
{
	LL d,x,y;
	d=exgcd(ntf,a,x,y);
	return (y%ntf+ntf)%ntf;
}
int main()
{
	id=rc()^48,n=read();
	for(rg int i=1;i<=n;++i)s[i]=_read();
	(id>=4)&&(p=_read(),q=_read(),d=_gcd(p,q),p/=d,q/=d);d=r=m=0;
	for(rg int i=1;i<=n;++i)SG[i]=sg(s[i]),d^=SG[i];
	for(rg int i=1;i<=n;++i)(_sigma(s[i])==0)?(++m):(((SG[i]^d)<=_sigma(s[i]))&&(r+=_inv(_sigma(s[i])),(r>=ntf)&&(r-=ntf)));
	print((d)?r*_inv(n-m)%ntf:0);
	return 0;
}
```

---

## 作者：Iris_Aurora (赞：1)

看官解看晕了，来写一篇详细的题解供后人理解。

我们不妨假设 $(a_2,…,a_n,0)$ 的 SG 值已知且为 $t$。

根据题意 $(a_1,a_2,\dots,a_n,0)$ 的后继状态有  $(a_1−1,a_2,\dots,a_n,0),(a_1−2,a_2,\dots,a_n,0),\cdots,(a_2,\dots,a_n,0)$，并且有 $(a_1,a_2,\dots,a_n,0)>(a_1−1,a_2,\dots,a_n,0)>(a_1−2,a_2,\dots,a_n,0)>\cdots >(1,a_2,\dots,a_n,0)$（后面的状态的后继集合是前面的状态的后继集合的真子集），然后 $(1,a_2,\dots,a_n,0)$ 的后继只有 $(a_2,\dots,a_n,0)$，所以这个状态的 SG 值为 $\mathrm{mex}(\{t\})$。

当 $t=0$ 时这个状态的 SG 值为 $1$，那么原状态 $(a_1,a_2,\dots,a_n,0)$ 的 SG 值显然为 $a_1$。

当 $t\not=0$ 时这个状态的 SG 值为 $0$：

若 $t\ge a_1$，有 $(a_1,a_2,\dots,a_n,0)=\mathrm{mex}(\{0,1,\dots,a_1-2,t\})=a_1-1$。

若 $t< a_1$，有 $(t+1,a_2,\dots,a_n,0)=\mathrm{mex}(\{0,1,\dots,(t+1)-2,t\})=t+1$，于是可以推出 $(a_1,a_2,\dots,a_n,0)=\mathrm{mex}(\{0,1,\dots,t,t+1,\dots,a_1-1\})=a_1$。

以此类推。

然后我们回到原题的分组方式，不妨设这一丛的蒲公英有 $x$ 朵：

$a_1=\lfloor\sigma x\rfloor \ge \lfloor\sigma(x−a_1)⌋=a_2$。

当 $a_1>a_2$ 时显然有 $t<a_1$，那么 $sg(x) = a_1$。

当 $a_1=a_2$ 时如果此时 $t=a_2$，那么 $sg(x) = a_1-1$，否则 $sg(x) = a_1$。

注意到 $a_i$ 单调不增，我们令 $len$ 表示 $a$ 序列最长相等前缀的长度（$a_1=a_2=\cdots =a_{len}$），则对于 $(a_{len},a_{len+1},\dots a_n,0),(a_{len-1},a_{len},\dots a_n,0),\cdots,(a_1,a_2,\dots,a_n,0)$，它们的 SG 值为 $a_1,a_1-1$ 交替（其中 $a_{len}=a_1$），那么我们只需要判断 $len$ 的奇偶性就可以知道 $sg(x)$ 的值，当 $len$ 为偶数时，$sg(x)=a_1-1$，否则 $sg(x)=a_1$。

那怎么求 $len$ 呢？发现 $len$ 满足 $\lfloor\sigma (x-len\times a_1)\rfloor<a_1$，那我们就可以求出 $len$ 的表达式进行 $\mathcal{O}(1)$ 计算，$len=\lfloor \frac{\sigma n}{(\sigma +1)a_1}\rfloor+1$。

于是我们得到了 $\mathcal{O}(1)$ 求得 $sg(x)$ 的方法。

我们求出整个局面的 SG 值 $Xor$,  $sg(x) \oplus Xor ≤⌊\sigma x⌋$，即其他堆总共的 SG 值的异或 $\le$ 先手选择这一丛蒲公英第一次能吹散的朵数，那么将有 $\frac{1}{(n-cnt)\lfloor\sigma x\rfloor}$ 的概率给后手留一个 SG 值异或为 $0$ 的局面（$cnt$ 为不能被选定的丛数，即只有一组的蒲公英丛数），将答案加上这个概率即可。

附上代码：

```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(ll i=(a);i<=(b);i++)
#define FR(i,a,b) for(ll i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const ll MAXN = 3e5 + 10;
const __int128 mod = 20190816170251;
ll id,n,p,q,Xor=0,cnt=0,ans=0;
ll s[MAXN],sg[MAXN];
ll qpow(ll a,ll b){
	ll res=1;
	while(b){
		if(b&1) res=(__int128)res*a%mod;
		a=(__int128)a*a%mod;
		b>>=1;
	}
	return res;
}
ll SG(ll x){
	ll num=(__int128)x*p/q;
	if(!num) return 0;
	ll len=(__int128)x*p/(p+q)/num+1;
	if(len&1) return num;
	return num-1;
} 
signed main(){
	scanf("%lld%lld",&id,&n);
	FL(i,1,n) scanf("%lld",&s[i]);
	if(id==1) p=804737854124365016,q=1000000000000000000;
	else if(id==2) p=546410161513775458,q=1000000000000000000;
	else if(id==3) p=618033988749894848,q=1000000000000000000; 
	else scanf("%lld%lld",&p,&q);
	FL(i,1,n) sg[i]=SG(s[i]),Xor^=sg[i];
	if(!Xor) puts("0"),exit(0);
	FL(i,1,n){
		ll num=(__int128)s[i]*p/q;
		if(!num){
			cnt++;
			continue;
		}
		if((Xor^sg[i])<=num) ans=(ans+qpow(num,mod-2))%mod; 
	}
	ans=(__int128)ans*qpow(n-cnt,mod-2)%mod;
	printf("%lld\n",ans); 
}
```

---

## 作者：OldDriverTree (赞：0)

这里发一篇比较像人话的题解。

# Solution

先考虑如何求一丛蒲公英的 $\text{SG}$ 函数。

令一丛蒲公英为 $(a_1,\dots,a_n,0)$，可以发现：
$$
\text{SG}(a_1,\dots,a_n,0)=
\begin{cases}
0&n=0\\
a_1-1&n>0\land a_1\le \text{SG}(a_2,\dots,a_n,0)\\
a_1&n>0\land a_1>\text{SG}(a_2,\dots,a_n,0)\\
\end{cases}
$$

证明是简单的，用脚归纳一下即可。

但是这样还是不够优雅，注意到 $a$ 单调不增，我们令 $l$ 为 $a$ 序列最长相等前缀，则：
$$
\begin{aligned}
\text{SG}(a_l,\dots,a_n,0)&=a_1\\
\text{SG}(a_{l-1},\dots,a_n,0)&=a_1-1\\
\text{SG}(a_{l-2},\dots,a_n)&=a_1\\
\vdots\\
\text{SG}(a_1,\dots,a_n)=\begin{cases}a_1-1&2\mid l\\a_1&2\nmid l\end{cases}
\end{aligned}
$$

因此我们只需要求出 $l$ 就能求出 $\text{SG}$ 函数。

求 $l$ 就是解不等式：令当前这从蒲公英的个数为 $n$，$t=\lfloor\sigma n\rfloor$，我们要找到一个最小的 $l$ 满足 $\sigma(n-lt)<t$，移项可以得到 $l=\lfloor\dfrac{\sigma n}{(\sigma+1)t}\rfloor+1$，于是我们就可以 $O(1)$ 求出一个数的 $\text{SG}$ 函数了。

接下来考虑整道题怎么做。

令 $sum=\oplus_{i=1}^n \text{SG}(s_i)$，先判掉 $sum=0$ 的情况，此时答案为 $0$，然后枚举 $x$ 计算吹 $s_x$ 丛先手获胜的概率，注意到 $s_x$ 及其后继状态恰好取遍 $0,\dots,t$ 且互不重复，那么相当于我们要计算 $\sum\limits_{0\le i\le t,i\neq\text{SG}(s_x)}[sum\oplus a_x\oplus i=0]$，又因为 $sum\neq 0$，所以不等于 $\text{SG}(s_x)$ 的限制的概率可以去掉，获胜的概率就为 $\dfrac{[sum\oplus a_x\le t]}t$，于是我们就做完了。

总时间复杂度为 $O(n)$。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDriverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
//using mint=modint998244353;
const int N=3e5+1,mod=20190816170251;
int _,n,p,q,ans,sum,cnt,a[N],b[N];

struct custom_hash
{
    static uint64_t splitmix64(uint64_t x) {
        x+=0x9e3779b97f4a7c15;
        x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
        x=(x^(x>>27) )*0x94d049bb133111eb;
        return x^(x>>31);
    }
    size_t operator() (uint64_t x) const {
        static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x+FIXED_RANDOM);
    }
};
int read() {
    int x=0; bool _=true; char c=0;
    while (!isdigit(c) ) _&=(c!='-'),c=getchar();
    while (isdigit(c) ) x=x*10+(c&15),c=getchar();
    return _?x:-x;
}
int mul(int x,int y) {
    return (__int128)x*y%mod;
}
int power(int a,int b=mod-2)
{
    int res=1;
    while (b) {
        if (b&1) res=mul(res,a);
        a=mul(a,a),b>>=1;
    }
    return res;
}
int SG(int x) {
    int t=(__int128)x*p/q;
    if (!t) return 0;
    int l=(__int128)x*p/(p+q)/t;
    return t-(l&1);
}
main()
{
    _=read(),n=read();
    for (int i=1;i<=n;i++) a[i]=read();
    if (_==1) p=8047378541243,q=1e13;
    else if(_==2) p=5464101615137,q=1e13;
    else if(_==3) p=61803398874989,q=1e14;
    else p=read(),q=read();
    for (int i=1;i<=n;i++) sum^=SG(a[i]);
    if (!sum) return !putchar('0');
    for (int i=1;i<=n;i++) {
        int t=(__int128)p*a[i]/q;
        if (!t) continue; cnt++;
        if ( (sum^SG(a[i]) )<=t)
        ans=(ans+power(t) )%mod;
    }
    printf("%lld",mul(ans,power(cnt) ) );
    return 0;
}
```

---


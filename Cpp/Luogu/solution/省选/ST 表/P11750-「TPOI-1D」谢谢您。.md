# 「TPOI-1D」谢谢您。

## 题目背景

> もしも もう一度 あなたに会えるなら
>
> 如果 能够再次与您相遇
>
> たった一言伝えたい ありがとう ありがとう
>
> 我只想告诉您一句话 谢谢您 谢谢您
>
> —— KOKIA「[ありがとう…](https://www.bilibili.com/video/BV12W421X7MQ/)」 

## 题目描述

Misaka Mikoto 给你一个长度为 $n$ 的序列 $[a_1, \dots, a_n]$ 和 $m$ 个区间 $[l_1,r_1], \dots, [l_m,r_m]$。

Misaka Mikoto 有 $q$ 次询问 $L, R, k$，对于每一次询问，请你求出：

$$\max_{i=L}^R \sum_{j=l_i}^{r_i} [a_j = k]$$

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（5 分）：$n,m,q\le 500$。
- Subtask 2（5 分）：$n,m,q\le 5000$。
- Subtask 3（5 分）：序列 $a$ 中至多有 $100$ 种元素。
- Subtask 4（5 分）：序列 $a$ 中每种元素至多出现 $10$ 次。
- Subtask 5（20 分）：$n,m,q\le 5\times 10^4$。
- Subtask 6（20 分）：$n,m,q\le 10^5$。
- Subtask 7（40 分）：无特殊限制。

对于 $100\%$ 数据，$1\le n,m,q\le 2\times 10^5$，$1\le a_i,k\le n$，$1\le l_i\le r_i\le n$，$1\le L\le R\le m$。

## 样例 #1

### 输入

```
1 1 1
1
1 1
1 1 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
10 6 8
1 1 2 1 3 2 1 3 2 3
1 5
2 7
3 6
4 5
7 10
5 9
1 3 3
2 4 1
5 6 1
2 2 2
4 6 3
2 5 2
1 3 1
3 5 4
```

### 输出

```
1
3
1
2
2
2
3
0
```

## 样例 #3

### 输入

```
15 15 15
11 14 1 5 5 5 5 4 10 2 5 1 4 5 4
10 14
2 7
7 12
6 10
4 5
5 11
3 15
3 7
3 8
1 6
8 11
14 14
5 8
8 12
4 5
8 15 2
12 13 5
8 12 5
7 12 11
7 12 10
2 11 11
10 10 10
5 13 11
11 14 11
2 4 4
13 14 1
4 8 11
7 12 5
3 5 11
10 15 11
```

### 输出

```
1
3
4
1
1
1
0
1
0
1
1
0
6
0
1
```

## 样例 #4

### 输入

```
20 20 20
12 1 20 1 1 11 11 1 11 12 11 17 12 1 11 12 20 12 17 17
4 7
6 7
10 20
17 19
2 4
6 6
17 19
10 12
14 15
12 13
7 19
8 16
8 11
4 6
16 18
3 8
16 20
4 5
7 10
6 19
6 8 20
2 6 12
1 3 17
4 5 12
13 14 12
2 8 11
7 11 12
3 4 20
12 15 20
19 19 1
4 4 1
1 8 1
7 15 20
2 8 17
8 16 12
4 12 1
12 17 1
4 9 11
2 7 1
1 15 17
```

### 输出

```
1
4
3
1
1
2
4
1
1
1
0
2
1
3
4
2
3
1
2
3
```

# 题解

## 作者：Reunite (赞：13)

这是两个时间复杂度 $O(n\sqrt n)$，空间复杂度 $O(n)$ 的做法，下文设 $n,m,q$ 同阶。

不考虑阈值分治，而是直接考虑对**区间序列**分块，设块长为 $B$。

先考虑整块，设 $f_{i,j}$ 为第 $i$ 个块 $j$ 的最大出现次数。显然有包含关系的区间，小的区间一定没有贡献，直接删去，现在该块内所有区间 $l_i,r_i$ 同时单调上升，我们维护 $t_i,h_i$ 分别为当前区间每个数出现次数，以及每个数的最大出现次数，用两个指针 $L,R$ 表示当前取到的区间，显然因为端点同时单调，顺次取到每个区间的复杂度为 $O(n)$，现在考虑如何更新答案。

注意到，我们从 $[l_i,r_i]$ 移动到 $[l_i+x,r_i+y]$ 的过程中，如果我们**先移动左指针，再移动右指针**，同时动态更新 $t,h$，那一定是对的，因为是取 $\max$，容易发现我们在移动过程中任意时刻任意数的出现次数，一定不大于其应在相邻两个区间中的出现次数，也就是正确的。注意过程中可以出现 $L>R$ 的情况，但无所谓。

现在考虑散块，就转化为 $O(nB)$ 次询问区间某个数出现次数，直接 $\text{vector}$ 上二分复杂度 $O(nB\log)$，很不牛。于是分出了两种做法：

- 注意到本质不同的区间只有 $O(n)$ 个，因此可以对这些区间做莫队，处理完一整个区间之后，遍历其对应的块中的所有询问并更新答案，因为一个询问最多拆到两个散块上，复杂度为 $O(nB+m\sqrt n)$。

- 还有一种做法是，把询问的 $[l,r,k]$ 挂在 $k$ 上，顺次做所有的 $k$，我们设 $b_i=[a_i=k]$，那询问就是区间和，使用 $O(\sqrt n)-O(1)$ 再次分块平衡即可 $O(1)$ 查询。

这两种做法总复杂度显然都可以做到 $O(n\sqrt n)$，现在考虑空间复杂度，我们不维护 $f_{i,j}$，而是离线逐块处理，这样整块空间复杂度线性。对于散块，做法一空间直接就是线性的；做法二注意到一次询问会被拆到散块中的两个连续区间，只记录端点即可做到空间线性。

这样总复杂度就是时间 $O(n\sqrt n)$，空间 $O(n)$ 了。~~口胡没写。~~

写了，莫队最后遍历常数太大，用第二种方法过的，给一个卡常前的代码。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define B 600
#define BB 500
using namespace std;

int n,m,q,cnt;
int a[200005];
int p[200005];
int t[200005];
int h[200005];
int g[200005];
int bl[200005];
int lf[200005];
int rt[200005];
int ll[200005];
int rr[200005];
bool mp[200005];
int ans[200005];
vector <int> F[200005];
vector <int> G[200005];
struct node{int l,r,x;}qq[200005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

int llf[200005];
int rrt[200005];
int bll[200005];

inline void add(int x,int y){
	for(int i=bll[x];i<=bll[n];i++) t[i]+=y;
	for(int i=x;i<=rrt[bll[x]];i++) h[i]+=y;
	return ;
}

inline int ask(int x){return t[bll[x]-1]+h[x];}

int main(){
	in(n),in(m),in(q);
	for(int i=1;i<=n;i++) in(a[i]),F[a[i]].emplace_back(i);

	for(int i=1;i<=m;i++) bl[i]=(i+B-1)/B;
	for(int i=1;i<=m;i++) rt[bl[i]]=i;
	for(int i=m;i>=1;i--) lf[bl[i]]=i;

	for(int i=1;i<=n;i++) bll[i]=(i+BB-1)/BB;
	for(int i=1;i<=n;i++) rrt[bll[i]]=i;
	for(int i=n;i>=1;i--) llf[bll[i]]=i;

	for(int i=1;i<=m;i++) in(ll[i]),in(rr[i]),p[i]=i;
	for(int i=1;i<=q;i++) in(qq[i].l),in(qq[i].r),in(qq[i].x);
	for(int i=1;i<=bl[m];i++){
		for(int j=lf[i];j<=rt[i];j++) h[j]=j;
		sort(h+lf[i],h+rt[i]+1,[](int x,int y){return ll[x]==ll[y]?rr[x]>rr[y]:ll[x]<ll[y];});
		int R=0,mm=0;
		for(int j=lf[i];j<=rt[i];j++){
			if(R>=rr[h[j]]) continue;
			g[++mm]=h[j];
			R=max(R,rr[h[j]]);
		}
		for(int j=1;j<=n;j++) t[j]=h[j]=0;
		int L=1;R=0;
		for(int j=1;j<=mm;j++){
			while(L<ll[g[j]]) t[a[L++]]--;
			while(R<rr[g[j]]) t[a[++R]]++,h[a[R]]=max(h[a[R]],t[a[R]]);
		}
		for(int j=1;j<=q;j++) if(qq[j].l<=lf[i]&&qq[j].r>=rt[i]) ans[j]=max(ans[j],h[qq[j].x]);
	}
	for(int i=1;i<=q;i++) G[qq[i].x].emplace_back(i);
	memset(t,0,sizeof(t));
	memset(h,0,sizeof(h));
	for(int i=1;i<=n;i++){
		for(int v:F[i]) add(v,1);
		for(int v:G[i]){
			int x=0,l,r;
			if(bl[qq[v].l]+1>=bl[qq[v].r]){
				l=qq[v].l,r=qq[v].r;
				for(int j=l;j<=r;j++) x=max(x,ask(rr[j])-ask(ll[j]-1));
				ans[v]=max(ans[v],x);
				continue;
			}
			l=qq[v].l,r=rt[bl[l]];
			for(int j=l;j<=r;j++) x=max(x,ask(rr[j])-ask(ll[j]-1));
			r=qq[v].r,l=lf[bl[r]];
			for(int j=l;j<=r;j++) x=max(x,ask(rr[j])-ask(ll[j]-1));
			ans[v]=max(ans[v],x);
		}
		for(int v:F[i]) add(v,-1);
	}
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);

	return 0;
}
```

---

## 作者：lzyqwq (赞：10)

出题人题解。

对不起。

---




> - 给出长度为 $n$ 的序列 $(a_1,\dots,a_n)$ 以及 $m$ 个区间 $([l_1,r_1],\dots,[l_m,r_m])$
> - $q$ 次询问 $L,R,k$，求：
>$$\max\limits_{i=L}^R\sum\limits_{j=l_i}^{r_i}[a_j=k]$$
> - $n,m,q\le 2\times 10^5$。

----
规定本问题中任意变量的线性根号阶大于任意变量的线性对数阶大于任意变量的线性阶。

考虑阈值分治，设阈值为 $B$，记 $\text{cnt}_k=\sum\limits_{i=1}^n[a_i=k]$，$\text{occ}(k,i)=\sum\limits_{j=l_i}^{r_i}[a_j=k]$。

----

**Case 1：$\text{cnt}_k\ge B$。**

此时至多只有 $\mathcal{O}\left(\dfrac{n}{B}\right)$ 种 $k$。暴力枚举这些 $k$，维护前缀出现次数 $s_i=\sum\limits_{j=1}^i[a_j=k]$，可以求出任意 $\text{occ}(k,i)=s_{r_i}-s_{l_i-1}$，然后把 $\text{occ}(k,i)$ 看成一个序列 $\mathcal{O}(m)$ 建立线段树维护区间最大值。

预处理时间复杂度为 $\mathcal{O}\left(\dfrac{n(n+m)}{B}\right)$，查询时间复杂度为 $\mathcal{O}(q\log m)$。

----

**Case 2：$\text{cnt}_k< B$。**

对于每个 $k$，枚举她的询问，考虑钦定她在 $[l_i,r_i]$ 最左边出现的位置 $p$，此时只会有 $\mathcal{O}(B)$ 种 $p$。枚举 $p$，记在 $p$ 之前一个 $k$ 的位置为 $\text{lst}_p$，则一个区间中最左边的 $k$ 的位置为 $p$ 的必要条件是，$\text{lst}_p<l_i\le p$。此时，我们希望这样的区间的 $r_i$ 最大，这样才能包含尽量多的 $k$。沿用 Case 1 部分关于 $s_i$ 的定义，$p$ 对答案的贡献即为 $s_{\max r_i}-s_{\text{lst}_p}$。

现在，问题变成 $\mathcal{O}(qB)$ 次求：

$$\max\limits_{l_i\in\left[\text{lst}_p+1,p\right],i\in[L,R]}r_i$$

这是一个 $\text{4 side}$ 矩形 $\max$ 问题，有点困难做到单次较好的复杂度，考虑继续转化。

我们发现不需要限制 $l_i\ge \text{lst}_p+1$，即只需要求：

$$\max\limits_{l_i\le p,i\in[L,R]}r_i$$

考虑若 $k$ 在 $[l_i,r_i]$ 中出现得最多（若多个 $i$ 满足出现次数最多，则选择 $r_i$ 最大的那个；若仍存在多个满足条件的区间，则选择 $i$ 最小的那个），记其最左边出现位置为 $\text{lp}$。则在枚举到 $\text{lp}$ 这个位置时，$l_i$ 一定满足 $\text{lst}_{\text{lp}}<l_i\le \text{lp}$，且 $r_i=\max\limits_{l_j\in \left[\text{lst}_{\text{lp}}+1, p\right],j\in[L,R]}r_j$。对于 $l_j\le\text{lst}_{\text{lp}}$ 的部分，$r_j$ 一定不可能超过 $\ge r_i$，不然 $\text{occ}(k,j)>\text{occ}(k,i)$，与 $k$ 在 $[l_i,r_i]$ 中出现得最多矛盾。因此此时 $\max\limits_{l_j\le p,j\in[L,R]}r_j=r_i$。，则 $s_{r_i}-s_{\text{lst}_{\text{lp}}}=\text{occ}(k,i)$，因为根据 $\text{lst}$ 的定义，$\left[\text{lst}_{\text{lp}}+1,\text{lp}-1\right]$ 内没有出现 $k$。所以，正确答案被统计到了。记正确答案即最大出现次数为 $\text{ans}$。

考虑不合法的贡献，则此时求出 $\max r_i$ 后，其对应的 $l_i$ 均 $\le \text{lst}_p$，此时计算得到的 $s_{\max r_i}-s_{\text{lst}_p}<\text{occ}(k,i)\le \text{ans}$，因此不会对答案产生影响。

那么现在变成 $\text{3 side}$ 矩形 $\max$ 了。考虑扫描 $l_i$ 这一维，记当前扫描到 $x$，维护一个数组 $b_i=\max\limits_{l_j\le x,j=i}r_j$。然后解决所有限制为 $l_i\le x$ 的询问。

则需要支持 $\mathcal{O}(m)$ 次单点 $b_i$ 对定值 $v$ 取 $\max$，$\mathcal{O}(qB)$ 次区间查询 $\max\limits_{i=L}^R b_i$。要平衡这个东西，考虑一些 $\mathcal{O}(\sqrt{m})$ 修改 $\mathcal{O}(1)$ 查询的东西。

$\mathcal{O}(1)$ 查询区间最大值，考虑 ST 表。但是对于普通的 ST 表，难以支持修改。考虑以 $S=\mathcal{O}(\sqrt{m})$ 为块长分块，此时块长与块数 $T$ 同阶。对于一个位置 $i$，维护 $\text{pre}_i$ 表示 $i$ 到所在块开头的 $b_i$ 最大值，$\text{suf}_i$ 表示 $i$ 到所在块结尾的 $b_i$ 最大值。再对块间维护 ST 表 $\text{st}_{i,j}$，表示块 $j$ 至块 $j+2^i-1$ 内的 $b$ 最大值。

对于一次修改，修改位置 $i$ 所在块 $I$ 内，$i$ 前的位置的 $\text{suf}$ 需要对 $v$ 取 $\max$；$i$ 后的位置的 $\text{pre}$ 需要对 $v$ 取 $\max$。此时需要修改的位置数量为 $\mathcal{O}(\sqrt{m})$。


对于 $\text{st}$，考虑 $i\in[0,\lfloor\log_2 T\rfloor]$ 时，有多少个 $\text{st}_{i,j}$ 需要修改。此时以 $i$ 为起点长度为 $2^j$ 的区间必须包含 $I$，得到 $I-2^i+1\le j\le I$，此时会有 $\mathcal{O}\left(2^i\right)$ 个位置。

则修改位置的总数：

$$\sum\limits_{i=0}^{\lfloor\log_2T\rfloor}\mathcal{O}\left(2^i\right)=\mathcal{O}\left(2^{\lfloor\log_2T\rfloor+1}\right)$$

因为 $2^{\lfloor\log_2T\rfloor}\le 2^{\log_2 T}=T$，所以 $\mathcal{O}\left(2^{\lfloor\log_2T\rfloor+1}\right)=\mathcal{O}\left(2^{\lfloor\log_2T\rfloor}\times 2\right)=\mathcal{O}(T)=\mathcal{O}(\sqrt{m})$。

那么修改时间复杂度仍是 $\mathcal{O}(\sqrt{m})$。

对于区间查询，若 $L,R$ 不同块，则拿 $\text{pre}_L,\text{suf}_R$ 以及用 ST 表求出两个位置之间的块的 $b_i$ 最大值三者去合并答案，时间复杂度 $\mathcal{O}(1)$。

若 $L,R$ 同块，难以合并信息。考虑再维护一个 ST 表 $\text{tt}_{i,j}$ 表示 $j$ 下标至 $j+2^i-1$ 下标的 $b$ 最大值。只不过，我们 $i$ 仅需要维护到 $\lfloor\log_2 S\rfloor$ 即可，因为只需要支持块内查询，不需要太长的区间。那么单点修改的时候，对 $\text{tt}_{i,j}$ 需要修改的位置暴力修改，可以类似上面分析出来需要修改的位置为 $\mathcal{O}(\sqrt{m})$ 个。

那么我们就 $\mathcal{O}(\sqrt{m})$ 解决了 $\mathcal{O}(m)$ 次修改，$\mathcal{O}(1)$ 解决了 $\mathcal{O}(qB)$ 次小查询。但是还没完，仍然需要求出每个位置的 $[p,\max r_i]$ 之间有多少个 $k$。注意到当 $p$ 递增时，$\max r_i$ 不降，因为约束条件变宽松了。类似双指针即可维护出区间 $k$ 的出现次数。

具体而言，对于每种 $k$ 开一个 `vector` 按顺序存储其出现位置，记 $\text{id}_i$ 表示她是序列中从左至右第几个 $a_i$。那么 $p$ 右移对应 $\text{id}_p$ 变为上一个位置加 $1$。用一个单调递增的指针 $\text{pt}$ 维护最右的不超过 $\max r_i$ 的 $k$ 是从左至右的第几个，然后 $k$ 的出现次数即为 $\text{pt}-\text{id}_p+1$。代码中 $\text{pt}$ 维护的是最左边超过 $\max r_i$ 的位置，因此不用 $+1$。由于 $k$ 出现次数不超过 $B$，因此指针移动次数为 $\mathcal{O}(B)$。

如果把所有询问的答案求出来再跑双指针，则需要 $\mathcal{O}(qB)$ 的空间，无法接受。

注意到虽然有 $\mathcal{O}(qB)$ 个询问，但是她们所用到的 $p\in[1,n]$。且对于同一个 $p$，她只会被 $k=a_p$ 的询问使用。因此不需要存储下 $\mathcal{O}(qB)$ 个询问，而是对每个询问维护一个指针 $\text{pt}_i$，并在扫描线扫到 $x$ 后，遍历 $k=x$ 的所有输入的询问并进行查询，然后用该询问对应的 $\text{pt}_i$ 跑双指针并更新前缀最大值。

这样一来仅需要对于每种 $k$ 存下询问，一共 $\mathcal{O}(q)$ 个。并且每个询问只会被 $\mathcal{O}(B)$ 个位置遍历，一次遍历花费 $\mathcal{O}(1)$ 时间查询、更新前缀最大值以及双指针。而 $\mathcal{O}(B)$ 次遍历的双指针中指针移动次数总和为 $\mathcal{O}(B)$，因此查询总时间复杂度还是 $\mathcal{O}(qB)$。

----

平衡一下两部分，取 $B=\mathcal{O}\left(\sqrt\dfrac{n(n+m)}{q}\right)$ 时，时间复杂度为 $\mathcal{O}\left(\sqrt{n(n+m)q}+m\sqrt m\right)$。

当然，Case 1 部分的 $s$ 也可以直接用一个 $\mathcal{O}(\sqrt n)$ 区间加 $\mathcal{O}(1)$ 单点查的分块维护。这样对于每种出现次数 $\ge B$ 的权值，总的修改次数是 $\mathcal{O}(n)$ 的，因此分块预处理的时间复杂度与阈值无关，为 $\mathcal{O}(n\sqrt n)$。当 $m$ 较小时，可以对 $\mathcal{O}(m)$ 个区间的左右端点离散化，这样修改时间复杂度变为 $\mathcal{O}(n\sqrt m)$。

那么需要平衡的部分为 $\mathcal{O}\left(\dfrac{mn}{B}\right)$ 和 $\mathcal{O}(qB)$。取 $B=\mathcal{O}\left(\sqrt{\dfrac{nm}{q}}\right)$ 时，时间复杂度为 $\mathcal{O}\left(n\sqrt {\min\{n,m\}}+m\sqrt m+\sqrt{nmq}\right)$。

事实上，在前缀和做掉 $\text{cnt}_k\ge B$ 的询问后，先对于 $L,R$ 位于同一个块的询问，用上面这个分块做掉，再使用扫描线 + 分块 + ST 表处理剩余的询问，就不需要 $\text{tt}$ 这个 ST 表了。这样会比不提前做 $L,R$ 同块的询问快一点。

本题中可以认为 $n,m,q$ 同阶，std 取 $B=\mathcal{O}(\sqrt n)$，时间复杂度为 $\mathcal{O}(n\sqrt n)$。但是在三者不同阶的情况下这个时间复杂度并不是最优的。而且不能把 $S$ 取成 $\mathcal{O}(\sqrt n)$ 而是应该取成 $\mathcal{O}(\sqrt m)$。因为此时是对区间序列分块，要平衡 $\mathcal{O}(S)$ 和 $\mathcal{O}\left(\dfrac{m}{S}\right)$。

空间复杂度为 $\mathcal{O}(m\log m)$，瓶颈在于 ST 表。

因为要卡掉 $\mathcal{O}(qB\log m)$ 的做法所以本题有点卡常，但是过了一车？？？结果把一些不是阈值分治的单根号做法卡了。同时也要卡掉 $\mathcal{O}(qB)$ 空间的做法。但是出题人忘记给这一档分配一点部分分了，不知道有没有人写这个。对不起。对不起。对不起。我紫菜。



----

闲话部分。

其实本来题目叫做 Railgun 且背景有一张御坂美琴的图。但是后来为了纪念一些发生的重要的事情，题目名称和背景变成了现在这个样子。

致敬传奇出题人 @[critnos](https://www.luogu.com.cn/user/203623) 和传奇题目 [P8571 [JRKSJ R6] Dedicatus545](https://www.luogu.com.cn/problem/P8571)。不难发现本题是 P8571 的严格加强版以及题目描述中出现的动漫人物有着紧密联系。

![](https://cdn.luogu.com.cn/upload/image_hosting/2cadaup2.png?x-oss-process=image/resize,m_lfit,h_1700,w_2025)
![](https://cdn.luogu.com.cn/upload/image_hosting/4r5h2ma6.png?x-oss-process=image/resize,m_lfit,h_1700,w_2205)
![](https://cdn.luogu.com.cn/upload/image_hosting/3288hdo9.png?x-oss-process=image/resize,m_lfit,h_1700,w_2025)

事实上，P8571 可以使用后缀数组转化到本题上来。你可能会问 P8571 还要一个后缀数组那不是比本题更难吗？其实不然，考虑 P8571 中 $n$ 个字符串的排名区间 **均能够对应一棵后缀树上的子树**。而子树显然是弱于序列上的区间的。举个例子：区间众数目前只能做到 $\mathcal{O}(n\sqrt n)$（暂时不考虑 [P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology Ⅲ](https://www.luogu.com.cn/problem/P5048) 中提到的 $\mathcal{O}\left(n^{1.48541}\right)$ 做法），而子树众数可以通过 dsu on tree 做到 $\mathcal{O}(n\log n)$。

不过其实我也不知道 P8571 中出题人给的猫树分治 + ACAM + 虚树 + 分块做法每部分放到本题中来是否能找到平替的东西。

---

## 作者：sunnygreen (赞：5)

怎么这么卡常。$50$ 发过了。

------------

对 $m$ 个区间分块，块长为 $O( \sqrt m)$。

对于散块，把相同的 $k$ 一起做，有 $O(n)$ 次单点加和 $O(q \sqrt m)$ 次区间求和，用 $O( \sqrt m ) - O(1)$ 的分块平衡，$O(n \sqrt m + q \sqrt m)$。

对于整块，被另一区间包含的一定不优，可以删去。把剩下的区间排成 $l,r$ 递增的形式。

记 $ans_i$ 为 $ \displaystyle \max_{j=1}^{c} \sum_{k=l_j}^{r_j} \left [a_k = i \right ]$，其中 $c$ 是区间数。

枚举最后一个计入贡献的点 $i$。找到最小的 $j$ 使 $r_j \ge i$，将 $ans_{a_i}$ 对 $ \displaystyle \sum_{k=l_j}^{r_j} \left [a_k = a_i \right ]$ 取 $ \max$ 即可。容易用双指针维护，$O(n \sqrt m)$。

------------

接下来是卡常环节，不想看的可以跳过。

散块部分是没有太大优化空间的，也不是瓶颈。

$ \displaystyle \sum_{k=l_j}^{r_j} \left [a_k = a_i \right ]$ 的维护一开始用了 vector，显然是很慢的，改成维护每个位置的 $nxt$ 也不够快。

因此把所有 $ \left (a_i,i \right )$ 排序，可以少开几个数组改成变量，且内存连续。$50 \rightarrow 55$。[Submission](https://www.luogu.com.cn/record/218826020)。

```cpp
	rep(i,1,bm)
	{
		int cnt=0;
		rep(j,bl[i],br[i])
			tmp[++cnt]=b[j];
		sort(tmp+1,tmp+1+cnt,[](pii X,pii Y) { return (X.fi!=Y.fi)? X.fi<Y.fi:X.se>Y.se; } );
		int cntt=0;
		rep(j,1,cnt)
			if(tmp[j].se>tmp[cntt].se)
				tmp[++cntt]=tmp[j];
		cnt=cntt,tmp[cnt+1]=mk(inf32,inf32); int pos=1,l=0;
		memset(cur,0,sizeof(cur));
		rep(j,1,n)
		{
			if(a[j].fi!=a[j-1].fi)
				pos=1,l=j;
			while(tmp[pos].se<a[j].se) ++pos;
			if(pos>cnt)
			{
				while(a[j].fi==a[j+1].fi) ++j;
				continue;
			}
			while(a[l].se<tmp[pos].fi) ++l;
			upd(cur[a[j].fi],j-l+1);
		}
		rep(j,1,q)
			if(c[j].rl<i&&i<c[j].rr)
				upd(c[j].ans,cur[c[j].k]);
	}
```

这时候发现 ```while(tmp[pos].se<a[j].se) ++pos;``` 一句很慢，改成预处理。

又发现 ```if(c[j].rl<i&&i<c[j].rr)``` 一句也很慢，改成 bitset 维护，$55 \rightarrow 95$。[Submission](https://www.luogu.com.cn/record/218848853)。

此时最慢点 1.05s 左右。

```bit[id1[pos1]]=!bit[id1[pos1]];``` 写抽象了，用 ```bit.flip(id1[pos1]);``` 代替，快了一点。调了几次块长过了。973ms。

------------

[完整代码](https://www.luogu.com.cn/record/218850500)。放一下整块部分，不一定可读。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define fi first
#define se second
#define mk make_pair
#define eb emplace_back
#define rep(i,l,r) for(int i=(l); i<=(r); ++i)
#define rep_(i,l,r) for(int i=(l); i>=(r); --i)
typedef pair<int,int> pii;
constexpr int inf32=0x3f3f3f3f,Inf32=0xc0c0c0c0;
template<typename T>il T Max(T x,T y) { return (x>y)? x:y; }
template<typename T>il T Min(T x,T y) { return (x<y)? x:y; }
constexpr int N=200064,B1=469,B2=448;
struct que { int l,r,k,id; }; que c[N];
pii ind[N]; int ans[N],Ans[N];
int bm,rev[N],bl[N],br[N]; bitset<N> bit; int id1[N],id2[N];
int n,m,q; pii b[N],a[N],tmp[N]; int cur[N],nxt[N],rgt[N];
il void upd(int &x,Int y) { if(x<y) x=y; }
il void Solve()
{
	cin>>n>>m>>q,bm=(m+B1-1)/B1;
	rep(i,1,bm)
	{
		bl[i]=(i-1)*B1+1,br[i]=Min(i*B1,m);
		rep(j,bl[i],br[i]) rev[j]=i;
	}
	rep(i,1,n)
		cin>>a[i].fi,a[i].se=i;
	sort(a+1,a+1+n);
	rep_(i,n,1)
		rgt[i]=(a[i].fi==a[i+1].fi)? rgt[i+1]:i;
	rep(i,1,m)
		cin>>b[i].fi>>b[i].se;
	rep(i,1,q)
		cin>>c[i].l>>c[i].r>>c[i].k,c[i].id=i;
	sort(c+1,c+1+q,[](que X,que Y) { return X.k!=Y.k? X.k<Y.k:(X.l!=Y.l? X.l<Y.l:X.r<Y.r); } );
	int qq=0;
	rep(i,1,q)
	{
		ind[i]=mk(rev[c[i].l],rev[c[i].r]);
		if(ind[i].se-ind[i].fi>1)
			id1[++qq]=i,id2[qq]=i;
	}
	sort(id1+1,id1+1+qq,[](int X,int Y) { return ind[X].fi!=ind[Y].fi? ind[X].fi<ind[Y].fi:X<Y; } );
	sort(id2+1,id2+1+qq,[](int X,int Y) { return ind[X].se!=ind[Y].se? ind[X].se<ind[Y].se:X<Y; } );
	ind[q+1]=mk(bm+2,bm+2),id1[qq+1]=id2[qq+1]=q+1;
	int pos1=1,pos2=1;
	rep(i,1,bm)
	{
		int cnt=0;
		rep(j,bl[i],br[i])
			tmp[++cnt]=b[j];
		sort(tmp+1,tmp+1+cnt,[](pii X,pii Y) { return X.fi!=Y.fi? X.fi<Y.fi:X.se>Y.se; } );
		int cntt=0;
		rep(j,1,cnt)
			if(tmp[j].se>tmp[cntt].se)
				tmp[++cntt]=tmp[j];
		cnt=cntt,tmp[cnt+1]=mk(n+1,n+1); int l=0;
		rep(j,1,cnt+1)
			rep(k,tmp[j-1].se+1,tmp[j].se)
				nxt[k]=j;
		memset(cur,0,n+1<<2);
		rep(j,1,n)
		{
			if(a[j].fi!=a[j-1].fi) l=j;
			int pos=nxt[a[j].se];
			if(pos>cnt)
				{ j=rgt[j]; continue; }
			while(a[l].se<tmp[pos].fi) ++l;
			upd(cur[a[j].fi],j-l+1);
		}
		while(ind[id1[pos1]].fi+1<=i)
			bit.flip(id1[pos1]),++pos1;
		while(ind[id2[pos2]].se<=i)
			bit.flip(id2[pos2]),++pos2;
		for(int j=bit._Find_first(); j<=q; j=bit._Find_next(j))
			upd(ans[j],cur[c[j].k]);
	}
}
```

---

## 作者：_Yonder_ (赞：5)

![](https://cdn.luogu.com.cn/upload/image_hosting/cnxmt8au.png)

考虑根号分治。

令 $cnt_x=\sum^n_{i=1}[a_i=x]$。

$cnt_x\ge\sqrt n$ 的，建线段树跑询问即可。

$cnt_x<\sqrt n$ 的，我们假设在处理一个询问时遍历到了某个位置为 $p$ 的 $k$。那么我们需要快速求出编号在 $[L,R]$ 且 $l_i\le p$ 的最大的 $r_i$。

看到 $l_i\le p$ 果断扫描线，支持修改，查询 $O(1)$，考虑分块加 ST 表。那么接下来的问题是处理 $L,R$ 同块的，给这些区间按 $l_i,r_i$ 各排序，指针即可。诶有人可能就会问了：排序不是 $O(n\log n)$ 的吗？这个你只需要给每个块提前排序，询问时把这些点挑出来即可。

时间复杂度 $O(n\sqrt n)$。

---

## 作者：鲤鱼江 (赞：4)

## 前言（可以不看）

赛时写正解常数太大被卡了，悲伤，不过复杂度应该是对的。

最开始被特殊性质误导去想了对原序列颜色出现次数阈值分治，但是发现只保留出现次数小于等于根号时的做法也是对的。不过被卡常之后缝上阈值分治能多五分。

## 解法

考虑逐颜色处理询问，对 $m$ 个区间进行序列分块，然后想一想怎么处理整块和散块。

对于散块，考虑对于每个元素暴力询问一遍其所对应的区间中元素出现次数，散块总长度为 $O(q\sqrt m)$，若每次 $O(\log n)$ 查询，复杂度不可接受，故考虑 $O(1)$ 进行回答。

又发现颜色出现次数总和为 $n$（一共只有 $n$ 个数），考虑使用 $O(\sqrt n)$ 单点修改，$O(1)$ 区间求和的分块来平衡一下。具体地，存一下块的前缀和和块内前缀和与后缀和。实现如下：

```cpp
struct Block{//单点加，区间查。 
	int pos[N],lenth,tot,pre[N],lpos[N],rpos[N],Pre[N],Suf[N],n;
	//Pre,Suf:块内前后缀和，pre：块的前缀和。 
	inline void init(const int len){
		lenth=sqrt(len)*1.4;n=len;
		for(int i=1;i<=len;++i) pos[i]=(i-1)/lenth+1;
		for(int i=1;i<=pos[n];++i) lpos[i]=(i-1)*lenth+1,rpos[i]=i*lenth;
		rpos[pos[n]]=n;
	}
	inline void Add(int p,int v){
		int bel=pos[p];
		for(int i=p;i<=rpos[bel];++i) Pre[i]+=v;
		for(int i=lpos[bel];i<=p;++i) Suf[i]+=v;
		for(int i=bel;i<=pos[n];++i) pre[i]+=v;
	}
	inline int Ask(int l,int r){
		int st=pos[l],ed=pos[r];
		if(st==ed) return Pre[r]-(l==lpos[st]?0:Pre[l-1]);
		else return Suf[l]+Pre[r]+pre[ed-1]-pre[st];
	}
}b;
```

然后散块就处理完毕了。

考虑处理整块，对于每个块内求出 $pre_j$ 表示块内左端点小于等于 $j$ 的区间的右端点最大值，然后我们把对应颜色的位置拿出来双指针，因为我们有借助 $pre$ 实现 $O(1)$ 判定一个区间是否被一个块内的某个区间包含的能力，所有我们枚举最终颜色的左端点，则右端点随之单调。发现空间复杂度达到了惊人的 $O(n\sqrt n)$，于是逐块处理。

分析一下复杂度，发现对于出现次数为 $x$ 的数，处理其的复杂度为 $O(x\sqrt n)$，故总时间 $O(n\sqrt n)$。

实际非常好写，以下是没阈值分治的 $50$ 分代码。

```cpp
#include<bits/stdc++.h>
#define mk make_pair
#define sec second
#define endl '\n'
#define fi first

using namespace std;
typedef pair<int,int> pii;

namespace Fread {
	const int SIZE=1<<21;char buf[SIZE],*S,*T;
	inline char getchar() {if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return '\n';}return *S++;}
}
namespace Fwrite {
	const int SIZE=1<<21;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}
	inline void putchar(char c){*S++=c;if(S==T)flush();}
	struct POPOSSIBLE{~POPOSSIBLE(){flush();}}ztr;
}
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio{
	struct Reader{
	    template<typename T>
    	Reader& operator >> (T& x) {
        	char c=getchar();T f=1;
        	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}x=0;
        	while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}x*=f;
	        return *this;
    	}
	    Reader(){}
	}cin;
	struct Writer{
	    template<typename T>
	    Writer& operator << (T x) {
	        if(x==0){putchar('0');return *this;}
	        if(x<0){putchar('-');x=-x;}
	        static int sta[45];int top=0;
	        while(x){sta[++top]=x%10;x/=10;}
	        while(top){putchar(sta[top]+'0');--top;}
	        return *this;
    	}
    	Writer& operator << (char c) {putchar(c);return *this;}
    	Writer(){}
	}cout;
}
#define cin Fastio :: cin
#define cout Fastio :: cout

const int N=2e5+10;
struct Query{int l,r,id;};
int a[N],ans[N],n,m,q,sum[N],ct[N],val[N],Z;
vector < Query > v[N];vector < int > p[N];
vector<int>A;
pii s[N];

struct Block{//单点加，区间查。 
	int pos[N],lenth,tot,pre[N],lpos[N],rpos[N],Pre[N],Suf[N],n;
	//Pre,Suf:块内前后缀和，pre：块的前缀和。 
	inline void init(const int len){
		lenth=sqrt(len)*1.4;n=len;
		for(int i=1;i<=len;++i) pos[i]=(i-1)/lenth+1;
		for(int i=1;i<=pos[n];++i) lpos[i]=(i-1)*lenth+1,rpos[i]=i*lenth;
		rpos[pos[n]]=n;
	}
	inline void Add(int p,int v){
		int bel=pos[p];
		for(int i=p;i<=rpos[bel];++i) Pre[i]+=v;
		for(int i=lpos[bel];i<=p;++i) Suf[i]+=v;
		for(int i=bel;i<=pos[n];++i) pre[i]+=v;
	}
	inline int Ask(int l,int r){
		int st=pos[l],ed=pos[r];
		if(st==ed) return Pre[r]-(l==lpos[st]?0:Pre[l-1]);
		else return Suf[l]+Pre[r]+pre[ed-1]-pre[st];
	}
}b;

struct Block2{//对区间分块 
	const int lenth=800;
	int pos[N],tot,pre[N],lpos[N],rpos[N];
	inline void chkmax(int &x,const int y){(x<y)&&(x=y);}
	inline void init(const int len){
		for(int i=1;i<=len;++i) pos[i]=(i-1)/lenth+1;
		for(int i=1;i<=pos[len];++i) lpos[i]=(i-1)*lenth+1,rpos[i]=i*lenth;
		rpos[pos[m]]=m;
	}
	inline bool check(int l,int r){return pre[l]>=r;} 
	inline void Deal(int id){
		for(int i=1;i<=n;++i) pre[i]=0;
		for(int i=lpos[id];i<=rpos[id];++i) chkmax(pre[s[i].fi],s[i].sec);
		for(int i=1;i<=n;++i) chkmax(pre[i],pre[i-1]);
		for(int i:A){//遍历颜色 
			int res=0;
			int len=p[i].size(),l=0,r=-1;
			for(l=0;l<len;++l){
				if(r<l) r=l-1;
				while(r<len-1&&check(p[i][l],p[i][r+1])) ++r;
				chkmax(res,r-l+1);
			}
			for(auto j:v[i]) if(j.l<=lpos[id]&&rpos[id]<=j.r) chkmax(ans[j.id],res);
		}
	}
	inline void Calc(int l,int r,int id){for(int i=l;i<=r;++i) ans[id]=max(ans[id],b.Ask(s[i].fi,s[i].sec));}
	inline void Do(){
		for(int i=1;i<=pos[m];++i) Deal(i);
		for(int i:A){
			for(auto j:p[i]) b.Add(j,1);
			for(auto j:v[i]){
				if(pos[j.l]==pos[j.r]) Calc(j.l,j.r,j.id);
				else {
					int st=pos[j.l],ed=pos[j.r];
					Calc(j.l,rpos[st],j.id);Calc(lpos[ed],j.r,j.id);
				}
			}
			for(auto j:p[i]) b.Add(j,-1);
		}
	}
}B;

int main(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;++i) cin>>a[i],++ct[a[i]];
	for(int i=1;i<=m;++i) cin>>s[i].fi>>s[i].sec;
	for(int i=1;i<=n;++i) p[a[i]].emplace_back(i);
	for(int i=1,x,y,z;i<=q;++i){cin>>x>>y>>z;v[z].emplace_back((Query){x,y,i});}
	for(int i=1;i<=n;++i){
		if(v[i].empty()||!ct[i]) continue;
		A.emplace_back(i);
	}
	b.init(n);B.init(m);B.Do();
	for(int i=1;i<=q;++i) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Demeanor_Roy (赞：2)

考虑根号分治。我们把 $k$ 相同的询问放在一起考虑，分以下两种情况：

### case 1

$k$ 在序列 $a$ 中出现次数大于 $\sqrt n$。则这样的 $k$ 只有 $\sqrt n$ 种。此时我们对每个给定区间直接求出区间内 $k$ 的个数，查询直接就是区间 $\max$。由于需要初始化 $\sqrt n$ 次，而查询的总量是 $O(q)$ 的，用分块平衡实现线性初始化，根号查区间 $\max$ 即可。这部分复杂度 $O((n+m)\sqrt n + q\sqrt m)$。 

---


### case 2

$k$ 在序列 $a$ 中出现次数不超过 $\sqrt n$。我们把询问挂在这 $\sqrt n$ 个位置，把区间挂在左端点。此时我们从左往右扫位置做扫描线，遇到区间则把区间编号处的值改为右端点，遇到询问直接求区间 $\max$，这样对于每个询问和每个 $k$ 在原序列的位置，我们就求出了该询问覆盖的区间里左端点不超过该位置最往右能覆盖到哪里，也就求出了答案。此处我们需要实现 $O(n)$ 次单点修和 $O(n \sqrt n)$ 次区间 $\max$，使用 $n^{0.75} - n^{0.5} - n^{0.25}$ 分块的技巧即可实现根号修， $O(1)$ 查。这部分复杂度 $O(n \sqrt m + q\sqrt n)$。

---

于是这道题在根号的复杂度内被我们解决掉。

---

## 作者：XZhuRen (赞：1)

我们来致敬一下 @[Reunite](https://www.luogu.com.cn/user/377760) 学长。

对 $m$ 序列分块，则散块可以暴力算答案喵喵喵。

块内由于是区间的集合，考虑有什么性质：首先考虑拉成 $l,r$ 递增的区间集合。

对于每个 $k$ 扫描单次花费是 $\mathcal{O}(cnt_k)$ 的，总花费是 $\mathcal{O}(n)$ 的，考虑快速计算答案：

则对于每一个点作为被取为答案的第一个的点，找出最靠右的端点即可，这时利用它计算一次答案即可，这样单次就是 $\mathcal{O}(cnt_k)$ 的。

竹筷离线空间就是线性的。

关于散块：

直接问是 $\mathcal{O}(\log)$ 的，不优，考虑对于颜色区分，由于总数是 $\mathcal{O}(n)$ 的，对于散块按照颜色离线所有询问，在做对于每个颜色额外维护一个分块对位连接查找 `lower_bound`。

但是这个也需要竹筷离线……

---

## 作者：Aegleseeker_ (赞：1)

突然会了的一个很厉害的题。

和出现次数有关的处理方法通常是根号复杂度的，不难发现可以先按照 $k$ 的出现次数根号分治一下。

若 $cnt_k>\sqrt n$，则这样的 $k$ 不超过 $\sqrt n$ 个，离线下来后直接暴力统计 $k$ 在每个区间的出现次数，线段树维护 rmq 即可。

若 $cnt_k<\sqrt n$，似乎不太好处理。我们可以枚举其每个出现位置，然后考虑左端点在当前点左侧的所有区间，取右端点的 $\max$ 即可不漏的取到答案，即 $\max\limits_{a_{p_i}=k}\max\limits_{L\le j\le R,l_j\le k}r_j$。这是一个 3-side 的矩形限制，考虑在这 $<\sqrt n$ 个出现位置上都挂上该次询问，离线后扫描线。

现在问题转换成一个有单点改的 rmq。仔细分析下发现有 $O(n\sqrt n)$ 次查询，$O(n)$ 次本质不同的修改。这个看起来十分困难，因为你不能 $O(n\sqrt n\log n)$，不过仍然还是有非常具有启发性的做法的。

借鉴 Four Russians 的思想，对当前序列分块，每个块内维护一个 st 表，块间维护一个 st 表。查询时可以做到 $O(1)$，难点在于修改。不过注意到，一次单点修改，其实不会对很多表里的值造成影响。我们考虑 $j$ 的贡献，即有多少 $i$ 满足 $st_{i,j}$ 发生了变化，此时 $i$ 的一个限制是 $x-2^j+1\le i\le x$，也就是说 $j$ 的贡献至多是 $2^j$ 的，所以总共产生的影响是 $O(\sum2^i=2^{\log \sqrt n}=\sqrt n)$。直接维护即可。

总复杂度精细实现可以做到 $O(n\sqrt n)$。

---

## 作者：Linge_Zzzz (赞：1)

# 鲜花

卡常题。当然也可能是我做法常数太大。

# Sol

考虑分块。经过一些枚举之后，我们选择把所有区间按照下标分块，然后套用经典分块技巧：对每个整块预处理出所有颜色的答案，散块逐个暴力。

考虑整块，发掘这个式子的性质，也就是 $\max$ 的性质，可以发现如果两个区间呈包含关系那么小的那个一定没用。所以我们先去除所有的包含关系，现在考虑一个类似莫队的指针移动法。容易发现我们每次移动指针到下一个区间的时候并不需要更新所有颜色的答案，只需要更新遍历过的答案即可。所以这部分每块处理是 $O(n)$ 的，总共时间复杂度 $O(n\sqrt m)$。

考虑散块，散块长度总共 $O(q\sqrt m)$，那么我们考虑离线所有散块询问，把相同的 $k$ 合在一块做。对于一个 $k$，我们维护一个支持单点加区间求和的数据结构，先把颜色 $k$ 出现的位置都 $+1$，查询是区间的区间和。容易发现 $+1$ 的次数是 $O(n)$ 的，用分块平衡复杂度到 $O(\sqrt n)$ 修改 $O(1)$ 查询，这部分即可做到 $O(q\sqrt m+n\sqrt n)$。

综上复杂度总共为 $O(n\sqrt m+q\sqrt m+n\sqrt n)$，可能能通过此题，但是不知道为什么我的无法通过，怎么会是呢？

以下是一些需要注意的点：

- 本题卡 $O(n\sqrt m)$ 空间，所以需要使用经典逐块处理 Trick。
- 散块对于每个 $k$ 查完不能直接清空否则复杂度不对，要一个个减回去。
- 卡常。

# TLE Code

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
typedef pair<int,int> pii;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
const int N=2e5+10,INF=0x3f3f3f3f,mod=998244353;
int n,m,q,a[N];
vector<int> pos[N];
pii p[N],tmp[N];
struct Q{int l,r,id;};
vector<Q> qr[N];
int ans[N];
int bel[N],L[N],R[N],tot=1;
inline void work(int l,int r){
	static int res[N],vis[N],cnt[N];
	int tp=0;
	memset(res,0,sizeof(res));
	for(int i=l;i<=r;i++)tmp[i]=p[i];
	sort(p+l,p+r+1);
	int pl=1,pr=0;
	for(int i=l;i<=r;i++){
		if(p[i].second<=pr)continue;
		while(pr<p[i].second){
			pr++;
			cnt[a[pr]]++;
			vis[++tp]=a[pr];
		}
		while(pl<p[i].first){
			cnt[a[pl]]--;
			pl++;
		}
		while(tp){
			res[vis[tp]]=max(res[vis[tp]],cnt[vis[tp]]);
			tp--;
		}
	}
	while(pl<=pr){
		cnt[a[pl]]--;
		pl++;
	}
	for(int k=1;k<=n;k++){
		for(Q q:qr[k]){
			if(q.l<=l&&r<=q.r)
				ans[q.id]=max(ans[q.id],res[k]);
		}
	}
	for(int i=l;i<=r;i++)p[i]=tmp[i];
}
struct Block{
	int bel[N],L[N],R[N],sum[N],val[N],t,tot=1;
	void init(){
		t=1500;
		for(int l=1,r=t;l<=n;l=r+1,r=min(l+t-1,n),tot++){
			L[tot]=l,R[tot]=r;
			for(int i=l;i<=r;i++)bel[i]=tot;
		}
		tot--;
	}
	inline void add(int p,int v){
		if(L[bel[p]]<p)for(int i=p;i<=R[bel[p]];i++)val[i]+=v;
		for(int i=(L[bel[p]]<p)?bel[p]+1:bel[p];i<=tot;i++)sum[i]+=v;
	}
	inline int ask(int p){
		return val[p]+sum[bel[p]];
	}
}blk;
inline void build(int k){
	for(int i:pos[k])blk.add(i,1);
}
inline void destroy(int k){
	for(int i:pos[k])blk.add(i,-1);
}
int query(int l,int r,int k){
	static int res[N],co[N];
	int ans=0;
	if(bel[l]==bel[r]){
		if(l>L[bel[l]]||r<R[bel[r]])
			for(int i=l;i<=r;i++)
				ans=max(ans,blk.ask(p[i].second)-blk.ask(p[i].first-1));
	}else{
		if(l>L[bel[l]])
			for(int i=l;i<=R[bel[l]];i++){
				if(co[i]==k)ans=max(ans,res[i]);
				else ans=max(ans,res[i]=blk.ask(p[i].second)-blk.ask(p[i].first-1)),co[i]=k;
			}
		if(r<R[bel[r]])
			for(int i=L[bel[r]];i<=r;i++){
				if(co[i]==k)ans=max(ans,res[i]);
				else ans=max(ans,res[i]=blk.ask(p[i].second)-blk.ask(p[i].first-1)),co[i]=k;
			}
	}
	return ans;
}
signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)cin>>a[i],pos[a[i]].push_back(i);
	for(int i=1;i<=m;i++)cin>>p[i].first>>p[i].second;
	for(int i=1;i<=q;i++){
		int l,r,k;
		cin>>l>>r>>k;
		qr[k].push_back({l,r,i});
	}
	int t=1500;
	for(int l=1,r=t;l<=m;l=r+1,r=min(l+t-1,m),tot++){
		for(int i=l;i<=r;i++)bel[i]=tot;
		L[tot]=l,R[tot]=r;
	}
	tot--;
	for(int i=1;i<=tot;i++)work(L[i],R[i]);
	blk.init();
	for(int k=1;k<=n;k++){
		build(k);
		for(Q q:qr[k])
			ans[q.id]=max(ans[q.id],query(q.l,q.r,k));
		destroy(k);
	}
	for(int i=1;i<=q;i++)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Erine (赞：1)

根号 log 也就个蓝，咋还被过了。。。

先把 $k$ 相同的询问扔在一起。对于 $k$ 出现次数 $>\sqrt n$ 的只有 $\Theta(\sqrt n)$ 个，直接前缀和一下。

对于出现次数 $\le \sqrt n$ 的，考虑枚举答案 $ans\le \sqrt n$，那么我对于当前 $k$ 的所有出现，记当前位置为左端点，后面第 $ans-1$ 次出现为右端点，我要查询是否有 $L\le i\le R$ 的 $l_i\le l_{cur}$ 的 $r_i$，然后我相当于要做 $n\sqrt n$ 次 3-side 矩形 max，就可以做到 $\Theta(n\sqrt n \log n)$ 了。

还能再给力一点吗？

注意到我们实际在做这样一件事：$\Theta(n)$ 次单点 chkmax，$\Theta(n\sqrt n)$ 次区间查询 $\max$。看起来好像没有比较方便的分块平衡方式。

考虑 ST 表上的一次修改，我们第 $i$ 层修改 $2^i$ 个点，总共修改 $\Theta(n)$ 个值。不妨套一个分块，假设我们维护了块内和块间的 ST，那么我们就可以轻松地做到 $\Theta(\sqrt n)$ 修改，常数复杂度查询了。

这样是单根号不带 $\log$。

---

## 作者：wang54321 (赞：1)

场上不会根号分治，考虑序列分块。

下文默认 $n,m,k$ 同阶。

对区间进行分块，设块长为 $B$ 考虑每一块的答案如何处理。

容易发现每个区间的答案是可差分信息，在 vector 上二分即可 $O(\log n)$ 处理单个区间的贡献，对于 **每一块**：拆分成 $O(n)$ 个全局询问，因为询问是全局的，把块内每个区间的 $l$ 挂到 $r$ 上，取后缀 $\min$，扫描线，插入一个数的时候更新等于这个数的答案就好了，由于每次查询要在 vector 上二分，是 $O(n\log n+n\frac{n}{B})$ 的，注意这里暴力处理每个颜色的值的话空间会爆炸，询问的时候对 $k$ 扫描线，每次重新预处理一遍就好了。

之后对每个询问暴力合并散块就是 $O(nB\log n)$ 的，考虑优化，这种题里面二分通常能优化成分散层叠或者分块状物，直接用 $O(\sqrt n)-O(1)$ 维护前缀和的分块即可做到 $O(nB)$。

$B$ 显然取 $\sqrt n$ 即可 $n\sqrt n$。

---


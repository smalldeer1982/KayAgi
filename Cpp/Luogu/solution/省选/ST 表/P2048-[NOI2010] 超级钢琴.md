# [NOI2010] 超级钢琴

## 题目描述

小 Z 是一个小有名气的钢琴家，最近 C 博士送给了小 Z 一架超级钢琴，小 Z 希望能够用这架钢琴创作出世界上最美妙的音乐。

这架超级钢琴可以弹奏出 $n$ 个音符，编号为 $1$ 至 $n$。第 $i$ 个音符的美妙度为 $A_i$，其中 $A_i$ 可正可负。

一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于 $L$ 且不多于 $R$。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。

小 Z 决定创作一首由 $k$ 个超级和弦组成的乐曲，为了使得乐曲更加动听，小 Z 要求该乐曲由 $k$ 个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小 Z 想知道他能够创作出来的乐曲美妙度最大值是多少。

## 说明/提示

### 样例解释

共有 $5$ 种不同的超级和弦：

1. 音符 $1 \sim 2$，美妙度为 $3+2=5$；
2. 音符 $2 \sim 3$，美妙度为 $2+(-6)=-4$；
3. 音符 $3 \sim 4$，美妙度为 $(-6)+8=2$；
4. 音符 $1 \sim 3$，美妙度为 $3+2+(-6)=-1$；
5. 音符 $2 \sim 4$，美妙度为 $2+(-6)+8=4$。

最优方案为：乐曲由和弦 $1,3,5$ 组成，美妙度为 $5+2+4=11$。

 ![](https://cdn.luogu.com.cn/upload/pic/2609.png) 

所有数据满足：$-1000 \leq A_i \leq 1000$，$1 \leq L \leq R \leq n$ 且保证一定存在满足要求的乐曲。


## 样例 #1

### 输入

```
4 3 2 3
3
2
-6
8```

### 输出

```
11```

# 题解

## 作者：Nekroz (赞：214)

搬自[blog](https://blog.csdn.net/diogenes_/article/details/80820571)

## $Description$

有 $n$ 个音符，编号为 $1$ 至 $n$ 。第 $i$ 个音符的美妙度为 $A_i$ 。

我们要找到 $k$ 段超级和弦组成的乐曲，每段连续的音符的个数 $x$ 满足 $L\leq x\leq R$ ，求乐曲美妙度的最大值。

## $Solution$

贪心 + 堆 + RMQ

首先可以看到，每段超级和弦都是连续的，美妙度是这段区间内所有美妙度的和。可以想到，每次求解区间和显然是不合算的，所以考虑到用前缀和。

考虑暴力，我们需要把所有满足条件的字段抽出来排个序，但这实在是不可想象。所以考虑使用贪心思想来解决这个问题。

先想预处理。我们定义 $MAX(o, l, r) = max\{sum(t) - sum(o - 1) \ | \ l\leq t \leq r \}$ ,即以 $o$ 为左端点，右端点范围是 $[l, r]$ 的最大子段。求 $sum()$ 就用前面说的前缀和。可以看出，$o$ 的位置是固定的。所以 $sum(o - 1)$ 也是固定的。所以我们要求这个的最大值，只要 $sum(t)$ 最大就可以了。即要求 $sum(t)$ 在 $[l, r]$ 中的最大值，那怎么快速地求出这个最大值呢？很显然，这不是 $RMQ$ 的活么。对 $RMQ$ 不熟悉的可以参考[这](https://blog.csdn.net/diogenes_/article/details/80794838) 。当然，具体计算的时候还要看看上界 $r$ 是否超过了 $n$ 。

接下来想怎么贪心。我们可以每次都选最优的子段，这样选 $k$ 次显然就是我们所要的结果，那怎么找到最优解呢？用堆来将解存进去，每次堆顶的元素就是最优解。

考虑一个三元组 $(o, l, r)$ 表示以 $o$ 为左端点，右端点的选择区间为 $[l, r]$ 的 情况，我用了一个 $struct$ 来表示这个三元组，但往往实际上每个情况需要额外记录这个情况的最优解 $t$ ，这个不麻烦，在 $struct$ 里面敲一个构造函数就可以了。

我们假设当前最大的三元组是 $(o, l, r)$ 。最优解位置是 $t$ 。$ans$ 累加这个三元组的贡献。由于 $t$ 已经被选中，对于这个 $o$， $t$ 已经不能重复选中，但最优解还可能存在于 $t$ 左右的两端区间中，所以提取出 $(o, l, r)$ 之后，为了避免重复且不丧失其他较优解，我们仍然要把 $(o, l, t - 1)$ , $(o, t + 1, r)$ 扔回堆里面去。显然地，在放回去之前应该保证区间的存在，即 $l = t$ 或 $r = t$ 的情况要进行特判。

最后实现的时候还要注意一点，$RMQ$ 原本数组里面记录的是最优解的值，但我们查询区间最大值的时候查询的是最优解的位置。所以数组里面存的是最优解的位置，要特殊处理。

## $Code$

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#define MAXN 500005
#define LOG 20
#define max(x, y) ((x) > (y) ? (x) : (y))
#define min(x, y) ((x) < (y) ? (x) : (y))
long long sum[MAXN], table[MAXN][LOG];
namespace RMQ {
    void init(int n) {
        for (int i = 1; i <= n; i++) table[i][0] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                int x = table[i][j - 1], y = table[i + (1 << (j - 1))][j - 1];
                table[i][j] = sum[x] > sum[y] ? x : y;
            }
    }
    int query(int l, int r) {
        int k = log2(r - l + 1);
        int x = table[l][k], y = table[r - (1 << k) + 1][k];
        return sum[x] > sum[y] ? x : y;
    }
}
struct element {
    int o, l, r, t;
    element() {}
    element(int o, int l, int r) : o(o), l(l), r(r), t(RMQ::query(l, r)) {}
    friend bool operator < (const element& a, const element& b) {
        return sum[a.t] - sum[a.o - 1] < sum[b.t] - sum[b.o - 1];
    }
};
std::priority_queue< element > Q;
int main() {
    int n, k, L, R;
    scanf("%d%d%d%d", &n, &k, &L, &R);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &sum[i]);
        sum[i] += sum[i - 1];
    }
    RMQ::init(n);
    for (int i = 1; i <= n; i++)
        if (i + L - 1 <= n) 
            Q.push(element(i, i + L - 1, min(i + R - 1, n)));
    long long ans = 0;
    while (k--) {
        int o = Q.top().o, l = Q.top().l, r = Q.top().r, t = Q.top().t;
        Q.pop();
        ans += sum[t] - sum[o - 1];
        if (l != t) Q.push(element(o, l, t - 1)); 
        if (t != r) Q.push(element(o, t + 1, r));
    }
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：juju527 (赞：134)

# RMQ好题
这是RMQ的一道难题了吧,至少作为蒟蒻的我是这么认为的

开始我的表演~~

~~自认为踩遍所有坑~~

首先给出我题解中的变量定义

k: 需要超级和弦总数

l,r: 分别是超级和弦所包含音符个数的下限和上限

dp[i][j]: RMQ数组,表示i~(i+2^j-1)最大值

num[i][j]: dp[i][j]中最大值对应的位置（结束点）

---

## 第一部分 区间最大美妙度超级和弦的解决

首先,因为我们需要一段每妙度的和,我们可以用一个前缀和数组c[i]

若我们找到了一个区间 L~R 

那么我们如何在这一段区间中找到最大的美妙度和呢

![](https://cdn.luogu.com.cn/upload/pic/59310.png)

显然,如上图所示,最大的美妙度之和应为 max(c[i])-c[L-1] 

这道题中应是这样的
![](https://cdn.luogu.com.cn/upload/pic/59321.png)

那么这个问题就转化成了找出前缀和数组 c[i] 的最大值

### RMQ登场了

about [RMQ](http://iwo.im/?q=RMQ)

---
## 第二部分 RMQ
这道题根据上面的分析我们应去找c[i]的最大值

才能去解决最大美妙度的问题

附RMQ模板
```cpp
void RMQ(){
	for(int j=1;j<=maxlog;j++){
		for(int i=1;i<=n;i++){
			if(i+(1<<j)-1<=n)
				dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
		}
	}
}
```
这道题RMQ的不同之处在哪呢？

在于我们需要知道我们取的最大值的位置

不然我们会不知道我们究竟取了哪一段音符,有可能会取重或者取不到

如何在RMQ中找到最大值位置呢？

其实不难,在dp[i][j]取数时哪个大num[i][j]就取谁
```cpp
void RMQ(){
    for(int j=1;j<=20;j++){
        for(int i=1;i<=n;i++){
            if(i+(1<<j)-1<=n){
                if(dp[i][j-1]<dp[i+(1<<(j-1))][j-1]){
                    dp[i][j]=dp[i+(1<<(j-1))][j-1];
                    num[i][j]=num[i+(1<<(j-1))][j-1];
                }
                else{
                    dp[i][j]=dp[i][j-1];
                    num[i][j]=num[i][j-1];
                }
            }
        }
    }
}
```
---
## 第三部分 k个最大超级和弦的解决

那怎么去解决k个超级和弦呢?

我们可以用优先队列来解决这个问题

首先我们可以将以1~n为开头的长度为l~r的超级和弦中

分别是最大的n个超级和弦放进队列

按值从大到小排序

此时我们取出队列中的队顶,这一定是全局最大的美妙度

接下来如何找到第二大的呢？

- 我们可以破开最大的这一个

- 用 w 表示当前最大值结束位置（num[i][])

- 将原本的 i~w 这个区域pop掉

- 将i~((i+l-1)—(w-1)),i~((w+1)—(i+r-1))中的最大值push进去

- 再取队顶出来重复刚才操作

为何这样操作能找到最大美妙度呢
![](https://cdn.luogu.com.cn/upload/pic/59322.png)

---
## 第四部分 细节处理与代码
这样我们的题目就基本上解决了

开心开心~~
![](https://cdn.luogu.com.cn/upload/pic/59323.png)

听取WA声一片啊

附上我的10分代码:
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int maxn=500005;
struct node{
    int data;
    int s,w;
    bool operator <(node i)const{
        return data<i.data;
    }
};
int c[maxn],dp[maxn][20],lg[maxn];
int num[maxn][20];
bool vis[500000000];
int p[maxn];
int n,k,l,r;
int ans=0;
int maxnum=0x3f3f3f3f;
priority_queue<node>q;
void RMQ(){
    for(int j=1;j<=20;j++){
        for(int i=1;i<=n;i++){
            if(i+(1<<j)-1<=n){
                if(dp[i][j-1]<dp[i+(1<<(j-1))][j-1]){
                    dp[i][j]=dp[i+(1<<(j-1))][j-1];
                    num[i][j]=num[i+(1<<(j-1))][j-1];
                }
                else{
                    dp[i][j]=dp[i][j-1];
                    num[i][j]=num[i][j-1];
                }
            }
        }
    }
}
void work(int i,int x,int y){
    int tmp=lg[y-x+1];
    int o,jl;
    bool flag=0;
    if(dp[x][tmp]>dp[y-(1<<tmp)+1][tmp]){
        o=dp[x][tmp];
        o-=c[i-1];
        jl=num[x][tmp];
    }
    else{
        o=dp[y-(1<<tmp)+1][tmp];
        o-=c[i-1];
        jl=num[y-(1<<tmp)+1][tmp];
    }
    if(vis[o]==1)flag=1;
    vis[o]=1;
    //cout<<i<<" "<<o-c[i-1]<<" "<<jl<<" "<<endl;
    if(!flag){
        node u;
        u.data=o;
        u.s=i;
        u.w=jl;
        q.push(u);
    }
}
int main()
{	
    cin>>n>>k>>l>>r;
    lg[0]=-1;
    for(int i=1;i<=n;i++){
        int x; 
        cin>>x;
        c[i]=c[i-1]+x;
        dp[i][0]=c[i];
        num[i][0]=i;
        lg[i]=lg[i>>1]+1;
    }
    RMQ();
    for(int i=1;i+l-1<=n;i++)
        work(i,i+l-1,min(i+r-1,n));
    ans+=q.top().data;
    //cout<<"#"<<q.top().data<<endl;
    int d=q.top().w,f=q.top().s;
    for(int i=1;i<k;i++){
        q.pop();
        if(d-1>=f+l-1&&d-1>=1)
            work(f,f+l-1,d-1);
        if(d+1<=f+r-1&&d+1<=n)
            work(f,d+1,min(f+r-1,n));
        d=q.top().w;
        f=q.top().s;
        ans+=q.top().data;
        //cout<<"#"<<q.top().data<<endl;
    }
    cout<<ans;
    return 0;
}
```
究竟是哪里有问题呢？

是因为我的10分代码无法解决这种情况:
![](https://cdn.luogu.com.cn/upload/pic/59324.png)

详情见下

正确代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500005;
struct node{
    ***
    int num;
    int lid,rid;
    int w;
    int data;
    bool operator <(node i)const{
        return data<i.data;
    }
    ***
};
int c[maxn],dp[maxn][20],lg[maxn];
int num[maxn][20];
int p[maxn];
int n,k,l,r;
int minn=2147483647;
long long ans=0;
priority_queue<node>q;
void RMQ(){
    for(int j=1;j<=20;j++){
        for(int i=1;i<=n;i++){
            if(i+(1<<j)-1<=n){
                if(dp[i][j-1]<dp[i+(1<<(j-1))][j-1]){
                    dp[i][j]=dp[i+(1<<(j-1))][j-1];
                    num[i][j]=num[i+(1<<(j-1))][j-1];
                }
                else{
                    dp[i][j]=dp[i][j-1];
                    num[i][j]=num[i][j-1];
                }
            }
        }
    }
}
int wz(int x,int y){
    int tmp=lg[y-x+1];
    int o,jl;
    if(dp[x][tmp]>dp[y-(1<<tmp)+1][tmp])
        jl=num[x][tmp];
    else
        jl=num[y-(1<<tmp)+1][tmp];
    return jl;//找到位置
}
void add(int po,int i,int left,int right){
    node tmp;
    tmp.w=po;
    tmp.num=i;
    tmp.lid=left;
    tmp.rid=right;
    tmp.data=c[po]-c[i-1];
    q.push(tmp);
    return ;
}
int main()
{   
    cin>>n>>k>>l>>r;
    lg[0]=-1;
    for(int i=1;i<=n;i++){
        int x; 
        cin>>x;
        c[i]=c[i-1]+x;
        dp[i][0]=c[i];
        num[i][0]=i;
        lg[i]=lg[i/2]+1;
    }
    RMQ();
    ***
    for(int i=1;i+l-1<=n;i++)
    	add(wz(i+l-1,min(i+r-1,n)),i,i+l-1,min(i+r-1,n));
    ***
    while(k--){
        int d=q.top().w,left=q.top().lid,right=q.top().rid;
        int e=q.top().data,id=q.top().num;
        ans+=e;
        q.pop();
        ***
        if(d>left)
            add(wz(left,d-1),id,left,d-1);
        if(d<right)
            add(wz(d+1,right),id,d+1,right);
        ***
   }
    cout<<ans<<endl;
    return 0;
}
```
完结撒花~~

管理大大求通过

---

## 作者：xryjr233 (赞：52)

Debug了一个下午。。。居然是ST表里面少写了几个+1...

我们记$a_i$的前缀和为$sum_i$那么对于一个固定的起点$i$和长度区间$l,r$，它的最值为

$max_{k=i+l-1}^{i+r-1}(sum_k-sum_{i-1})$

又因为$sum_{i-1}$是固定的，所以事实上只要求出$[l,r]$内最大的$sum_k$即可。于是转化为区间RMQ，使用ST表求出。我们把此时的答案记为$f(i,l,r)$

那么怎么求整个序列的前m大呢？

考虑枚举区间起点$i$，将$f(i,l,r)$和取到答案的位置(即之前$sum_k$最大的$k$)构成一个四元组$(i,l,r,k)$加入一个大根堆，按照$f(i,l,r)$的大小排序，即$sum_k-sum_{i-1}$。

当我们取出堆头元素时(设为$(i,l,r,nw)$)，将他的权值加入答案，并将其分裂成两段:

1.$(i,l,nw-1,(f(i,l,nw-1)\texttt{取到答案的}k))$，当$nw\ne l$时存在；

2.$(i,nw+1,r,(f(i,nw+1,r)\texttt{取到答案的}k))$，当$nw\ne r$时存在；

取出m次后结束这个过程，得到答案。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,l,r,sum[500010],v,mx[500010][20],d[500010][20],id[500010][20];
long long ans;
struct node{//四元组
	int id,l,r,nw;
	bool operator <(node y)const{
		return sum[nw]-sum[id-1]<sum[y.nw]-sum[y.id-1];
	}
}tmp,t;
priority_queue<node>q;
int RMQ(int L,int R){//L到R的区间最大值的取值位置
	int Max=-2e9,Id;
	for(int i=19;i>=0;i--){
		if(L+(1<<i)-1<=R){
			if(mx[L][i]>Max){
				Max=mx[L][i];
				Id=id[L][i];
			}
			L=d[L][i]+1;
		}
	}
	return Id;
}
int main(){
	scanf("%d%d%d%d",&n,&k,&l,&r);
	for(int i=1;i<=n;i++){
		scanf("%d",&v);
		sum[i]=sum[i-1]+v;
		d[i][0]=i;
		mx[i][0]=sum[i];
		id[i][0]=i;
	}
	for(int j=1;j<=19;j++){//ST表,mx维护最大值,id维护位置
		for(int i=1;i<=n;i++){
			d[i][j]=d[d[i][j-1]+1][j-1];
			if(mx[i][j-1]>mx[d[i][j-1]+1][j-1]){
				mx[i][j]=mx[i][j-1];
				id[i][j]=id[i][j-1];
			}else{
				mx[i][j]=mx[d[i][j-1]+1][j-1];
				id[i][j]=id[d[i][j-1]+1][j-1];
			}
		}
	}
	for(int i=1;i<=n-l+1;i++){//加入初始的四元组
		tmp.nw=RMQ(i+l-1,min(n,i+r-1));
		tmp.id=i;
		tmp.l=i+l-1;
		tmp.r=min(n,i+r-1);
		q.push(tmp);
	}
	while(k--){
		t=q.top();
		q.pop();
		ans+=sum[t.nw]-sum[t.id-1];//累计答案
		if(t.nw>t.l){//分裂(左边)
			tmp.l=t.l;
			tmp.r=t.nw-1;
			tmp.id=t.id;
			tmp.nw=RMQ(tmp.l,tmp.r);
			q.push(tmp);
		}
		if(t.nw<t.r){//分裂(右边)
			tmp.l=t.nw+1;
			tmp.r=t.r;
			tmp.id=t.id;
			tmp.nw=RMQ(tmp.l,tmp.r);
			q.push(tmp);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：34)

st表太神啦~

但是似乎主席树吸氧之后跑的飞起呢~(或者是因为stl的问题？反正开O2和不开O2大概差了4倍常数)

## 本题题解

这道题简单来说，就是给你一个序列a，求前k大长度在(l,r)内的子串和

然后简单来说，我们可以$O(n^2)$的处理出来所有子串的和，然后直接暴力的跑sort或者堆就可以了，为了快速计算子串和当然需要前缀和

然而显然会t的飞起对吧……

所以我们需要想一些机智的方法

这道题呢我们可以采取类似于贪心的思路，先找到最大值，然后删掉最大值，继续找剩下值中的最大值就可以了

假设现在我们一个区间都没删，现在要找最大值，

那么我们枚举左端点l，然后考虑对于一个给定的左端点l哪个是最优的右端点r
因为长度限制是[l,r]因此对于这个l来讲，所有合法的右端点r形成一个区间

当然是一个区间的前缀和值的最大值所对应的r了，因为总之你都要减去左端点的前缀和……，因此当然是要r的前缀和最大咯

这是一个区间最大值问题，当然可以使用st表解决这个问题

但是如果使用主席树解决这个静态区间第k大问题也不是不可以对吧……

然后我们对于每一个左端点都求出了一个最大合法的子串和

所以把这些值放进堆里取就可以找到最大值，好了我们现在有了一个最大值！

现在我们取出了这个最大值……我们发现此时这个左端点对应的区间第2大可能是此时最大的值，因此我们再求一遍区间第2大插堆里去，同理如果我们取出来来了区间第2大就插区间第3大，当然如果取掉了区间最小值就不能插入了……

(什么？你不会使用主席树求静态区间第k大？出门右转你站膜板区，包教包会~)

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=5*1e5+10;typedef long long ll;
int n;int k;int l;int r;int sum[N];ll res;int lsh[N];int rk[N];
int dl[N];int dr[N];
inline bool cmp(int a,int b){return sum[a]<sum[b];}//离散化 
struct data
{
	int rk;int l;int v;
	friend bool operator <(data a,data b){return a.v<b.v;} 
};priority_queue <data> pq;//保存答案的堆 
struct per_linetree//主席树板子，压行之后还是比较短小的 
{
	int s[25*N][2];int val[25*N];int root[N];int ct;int tim;
	per_linetree(){ct=root[0]=1;}
	inline void setadd(int p1,int p2,int l,int r,int pos)
	{
		val[p2]=val[p1]+1;if(r-l==1){return;}int mid=(l+r)/2;
		if(pos<=mid){s[p2][0]=++ct;s[p2][1]=s[p1][1];setadd(s[p1][0],ct,l,mid,pos);}
		else {s[p2][1]=++ct;s[p2][0]=s[p1][0];setadd(s[p1][1],ct,mid,r,pos);}
	}
	inline int kth(int p1,int p2,int l,int r,int rk)
	{
		if(r-l==1){return r;}int nv=val[s[p2][0]]-val[s[p1][0]];int mid=(l+r)/2;
		if(rk>nv){return kth(s[p1][1],s[p2][1],mid,r,rk-nv);}
		else {return kth(s[p1][0],s[p2][0],l,mid,rk);}
	}
	inline void cadd(int pos){setadd(root[tim],root[tim+1]=++ct,0,n,pos);tim++;}
	inline int ckth(int l,int r,int rk){return kth(root[l],root[r],0,n,rk);}
}plt;
int main()
{
	scanf("%d%d%d%d",&n,&k,&l,&r);
	for(int i=1;i<=n;i++){scanf("%d",&sum[i]);sum[i]+=sum[i-1];}//前缀和 
	for(int i=1;i<=n;i++){lsh[i]=i;}sort(lsh+1,lsh+n+1,cmp);//离散化 
	rk[lsh[1]]=1;for(int i=2;i<=n;i++){rk[lsh[i]]=(sum[lsh[i]]==sum[lsh[i-1]])?rk[lsh[i-1]]:i;}
	for(int i=1;i<=n;i++){plt.cadd(rk[i]);}
	dl[0]=l-1;dr[0]=r-1;//求出每个i对应的区间左右端点 
	for(int i=1;i<=n;i++)//插入的东西会比较恶心，凑合着看吧…… 
	{
		dl[i]=dl[i-1]+1;dr[i]=min(dr[i-1]+1,n);if(dl[i]>dr[i]){break;}
		pq.push((data){dr[i]-dl[i]+1,i,sum[lsh[plt.ckth(dl[i]-1,dr[i],dr[i]-dl[i]+1)]]-sum[i-1]});
	}
	for(int i=1;i<=k;i++)
	{
		data nw=pq.top();pq.pop();int v=nw.l;res+=nw.v; 
		if(nw.rk==1){continue;}//判一下是不是最小值 
		pq.push((data){nw.rk-1,v,sum[lsh[plt.ckth(dl[v]-1,dr[v],nw.rk-1)]]-sum[v-1]});//不是最小值就接着插入 
	}printf("%lld",res);return 0;//拜拜程序~ 
}
```

---

## 作者：nofind (赞：29)

## upd 2019.12.10 latex和markdown化
## [题意](https://www.luogu.org/problemnew/show/P2048)

解析：

先考虑暴力:将每个区间求出来,放进一个堆里,取出前k个就是答案。

期望得分：20,原因:TLE

code(对,我真写了):

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=5*1e5+10;
int n,k,L,R,ans;
int sum[maxn];
priority_queue<int> q;
int main()
{
    scanf("%d%d%d%d",&n,&k,&L,&R);
    for(int i=1;i<=n;i++) scanf("%d",&sum[i]),sum[i]+=sum[i-1];
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
            if(j-i+1>=L&&j-i+1<=R) q.push(sum[j]-sum[i-1]);
    for(int i=1;i<=k;i++) ans+=q.top(),q.pop();
    printf("%d",ans);
    return 0;
}
```
考虑优化,先看[这道题](https://www.luogu.org/problemnew/show/P1631)

这道题中我们并没有将所有的组合全部求出,而是先将一些最优解放入堆中,取出后放入次于它的最优解来更新。

这道题也可以用相同的方法来优化。

首先区间和肯定用前缀和优化了。

我们先固定左端点,将从每个点向右的最优解放入,记为四元组:$(x,l,r,t)$,$x$是左端点,$l$和$r$是右端点的范围,t是当前解的右端点的位置。求解该区间的最优解可以用ST表解决。

将这些数放入后,我们每从堆中取出一个四元组$(x,l,r,t)$,加上它的答案后,向堆中放入$(x,l,t-1,query(l,t-1))$和$(x,t+1,query(t+1,r))$(相当于放入对于$x$的$[l,r]$区间除去$t$后的最优解,注意判断$l,r$是否为$t$)

取$k$次即为答案。

之前做过的题思想还是要记住的~

code：
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=5*1e5+10;
int n,k,L,R;
int st[maxn][30];
ll ans;
ll sum[maxn];
void init()
{
    for(int i=1;i<=n;i++) st[i][0]=i;
    int t=(int)log2(n);
    for(int j=1;j<=t;j++)
        for(int i=1;i+(1<<j)-1<=n;i++)
        {
            int x=st[i][j-1],y=st[i+(1<<(j-1))][j-1];
            st[i][j]=sum[x]>sum[y]?x:y;
        }
}
int query(int l,int r)
{
    int k=(int)log2(r-l+1);
    int x=st[l][k],y=st[r-(1<<k)+1][k];
    return sum[x]>sum[y]?x:y;
}
struct node
{
    int x,l,r,t;
    bool operator < (const node& y)const
    {
        return sum[t]-sum[x-1]<sum[y.t]-sum[y.x-1];
    }
};
priority_queue<node> q;
int main()
{
    scanf("%d%d%d%d",&n,&k,&L,&R);
    for(int i=1;i<=n;i++) scanf("%lld",&sum[i]),sum[i]+=sum[i-1];
    init();
    //puts("1111");
    for(int i=1;i<=n;i++)
        if(i+L-1<=n) q.push((node){i,i+L-1,min(n,i+R-1),query(i+L-1,min(n,i+R-1))});//puts("111");
    //puts("11");
    while(k--)
    {
        int x=q.top().x,l=q.top().l,r=q.top().r,t=q.top().t;
    //	printf("%d %d %d %d\n",x,l,r,t);
        q.pop();ans+=sum[t]-sum[x-1];
        //puts("111");
        if(l!=t) q.push((node){x,l,t-1,query(l,t-1)});
        if(r!=t) q.push((node){x,t+1,r,query(t+1,r)});
        //puts("111");
 	}
    printf("%lld",ans);
 	return 0;
}
```


---

## 作者：御·Dragon (赞：22)

### 2019/11/14 更新日志：

近期发现这篇题解有点烂，更新一下，删繁就简，详细重点。代码多加了注释。就酱紫啦！

------------

> ## 正解步骤

1. 我们需要先算美妙度的前缀和，并初始化RMQ。

2. 循环 $i$ 从 $1$ 到 $n$ ，因为以i为起点的 __和弦__ 终点必定是 $i + L - 1$ 到 $i + R - 1$ 之间，所以只要在区间内用RMQ取 __超级和弦__ ，并加入以美妙度从小排到大的优先队列中。

3. 取出堆顶元素，将美妙度加入 $ans$ ，并将元素切为从 （当前元素的左边界 到 当前元素终点 - 1） 和 （$当前元素终点 + 1 到 当前元素右边界$） 两个部分，并再次加入优先队列，依次进行 $k$ 次。

4. 输出答案即可

------------

> 为什么要使用前缀和 and RMQ？

数据范围是500000，很明显，为了优化需要前缀和 and RMQ。

前缀和最明显的用处，是可以优化一个用来循环累加和的 $n$ 。而 $RMQ$ ，显然区间最值符合题目要求。

这两个算法询问答案都是O(1)。前缀和后面减去前面，RMQ只需要初始化一下，然后O(1)询问即可。

------------


> 为什么第三步要切开元素并放入优先队列？ 直接累加前 $k$ 个元素不行么？

首先，我们肯定可以确定：优先队列中第一大的和弦一定是 __全局__ 最大的和弦。 ~~不要问我怎么证明~~

那么优先队列中第二大的和弦一定是 $全局$ 次大的和弦么？这就不一定了。

所以我们需要切开元素并放入优先队列，保证每次取出来的元素一定是全局大小排名的元素

__自己拿出纸和笔，结合题解自己思考，在草稿纸上演算一下，就懂了__

------------

### 那我就把解题思路放上吧233

~~实在还有问题，私信本人233~~

![](https://i.loli.net/2019/07/01/5d19da9db12ad27222.jpg)

感谢老师 @apple365 的思路指引。

## AC代码

```
#include<bits/stdc++.h>
#include<cctype>
#pragma GCC optimize(2)

#define in(a) a = read()
#define out(a) write(a)
#define outn(a) out(a),putchar('\n')

#define ll long long
#define Min(a,b) a < b ? a : b
#define Max(a,b) a > b ? a : b
#define rg register
#define New ll

using namespace std;

namespace IO_Optimization{

	inline New read()
	{
	    New X = 0,w = 0;
		char ch = 0;

		while(!isdigit(ch))
		{
			w |= ch == '-';
			ch=getchar();
		}
	    while(isdigit(ch))
		{
			X = (X << 3) + (X << 1) + (ch ^ 48);
			ch = getchar();
		}
	    return w ? -X : X;
	}

	inline void write(New x)
	{
	     if(x < 0) putchar('-'),x = -x;
	     if(x > 9) write(x/10);
	     putchar(x % 10 + '0');
	}

	#undef New
}
using namespace IO_Optimization;//上面一坨优化的东西不用在意 

const int MAXN = 500000 + 2;//定义常亮 

int n,k,L,R;
int sum[MAXN],lg[MAXN],dp[MAXN][20],pos[MAXN][20];
//  前缀和    lg2值
//dp[i][j]表示i的2^j次方祖先  pos数组来记录最佳位置 
ll ans;
struct Node
{
	int start, left, right, t, val; 
	//超级和弦的起点 左、右边界 最值位置 最值 
	bool operator < (const Node &next) const
	{
		return val < next.val; //最值从大到小排序 
	} 
};

inline void RMQ_init() //预处理 
{ 
	for(rg int j = 1;j <= 20; ++j)
		for(rg int i = 1;i + (1 << j) - 1 <= n; ++i)
		{
			if(dp[i][j - 1] > dp[i + (1 << (j - 1))][j - 1])
			{
				dp[i][j] = dp[i][j - 1];
				pos[i][j] = pos[i][j - 1];//更新最值位置 
			}
			else
			{
				dp[i][j] = dp[i + (1 << (j - 1))][j - 1];
				pos[i][j] = pos[i + (1 << (j - 1))][j - 1];
			}
		}
	return;
} 

inline int RMQ_query(int l, int r) //返回最值的位置 
{
	int t, tmp = lg[r - l + 1];
	if(dp[l][tmp] > dp[r - (1 << tmp) + 1][tmp])
		t = pos[l][tmp];
	else t = pos[r - (1 << tmp) + 1][tmp];
	return t;
}

int main()
{
	in(n),in(k),in(L),in(R);
	lg[0] = -1;//lg2(0) = -1,方便后面预处理lg2值 
	for(rg int i = 1;i <= n; ++i)
	{
		int a = read();//读入音符 
		sum[i] = sum[i - 1] + a; //前缀和 
		lg[i] = lg[i >> 1] + 1; //预处理lg2值 
		dp[i][0] = sum[i];
		pos[i][0] = i; //初始化最大值的位置 
	}
	RMQ_init();//初始化 
	priority_queue<Node> pq; //定义优先队列 
	for(rg int i = 1;i + L - 1 <= n; ++i) //计算每个位置最大的超级和弦 
	{
		int t = RMQ_query(i + L - 1, Min(n, i + R - 1)); 
		Node cur;
		cur.val = sum[t] - sum[i - 1]; //由前缀和取最大值 
		cur.t = t;
		cur.start = i; //当前超级和弦的起始位置 
		cur.left = i + L - 1; //当前的左边界 
		cur.right = Min(n,i + R - 1); //当前的右边界 
		pq.push(cur); //入堆 
	}

	for(rg int i = 1;i <= k; ++i) //取k次堆顶的值 
	{
		Node cur = pq.top();
		pq.pop();
		ans = ans + cur.val; //累加结果 
		Node next;

		if(cur.t > cur.left) //当前取最值的位置 大于 当前和弦的 左边界 
		{
			next.start = cur.start;
			next.left = cur.left;
			next.right = cur.t - 1; //新的右边界 
			next.t = RMQ_query(next.left, next.right);
			next.val = sum[next.t] - sum[next.start - 1];
			pq.push(next);
		}

		if(cur.t < cur.right) //当前取最值的位置 小于 当前和弦的 右边界 
		{
			next.start = cur.start;
			next.left = cur.t + 1; //新的左边界 
			next.right = cur.right;
			next.t = RMQ_query(next.left, next.right);
			next.val = sum[next.t] - sum[next.start - 1];
			pq.push(next);
		}
	}
	outn(ans);
	return 0;
}
```

### END.

---

## 作者：「QQ红包」 (赞：17)

两个log的做法，**我写的不开O2会T**，没有思维难度。

其实可以继续卡常。比如离散化一下，但是动态开点很方便对不对（逃）

那样就可以过了。

题目是要求前$k$大的和，

那么我们二分答案，求出第$k$大，

我们先记一个前缀和，设为s。

我们check的时候枚举左端点，右端点在主席树里查，有多少个是合法的。

设我们二分的答案是$x$，左端点为$i$，那么右端点的范围为$i+L-1$到$i+R-1$。

然后符合条件的右端点$p$要满足条件$s_p-s_{i-1}\ge x$

所以$s_p\ge x+s_{i+1}$

我们最后求的时候要注意，和第k大元素值相同的可能不止k个。

所以我们把大于二分出来的第k大值加起来，最后再算一下。

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
void qmax(int &x,int y) {if (x<y) x=y;}
void qmin(int &x,int y) {if (x>y) x=y;}
inline ll read()
{
    char s;
    ll k=0,base=1;
    while((s=getchar())!='-'&&!(isdigit(s)));
    if(s=='-')base=-1,s=getchar();
    while(isdigit(s)){k=k*10+(s^'0');s=getchar();}
    return k*base;
}
inline void write(ll x)
{
    static char cnt,num[25];cnt=0;
    if (!x)
    {
        putchar('0');
        return;
    }
    for (;x;x/=10) num[++cnt]=x%10;
    for (;cnt;putchar(num[cnt--]+48));
}
const int maxn=5e5+100;
const int N=500000000;
int n,k,L1,R1,a[maxn],cnt,b[maxn],len;
ll t[maxn*40];
int L[maxn*40],R[maxn*40],rt[maxn];
ll s[maxn*40];
void insert(int&d,int d1,int x,int y,int p)
{
    d=++cnt;
    *(t+d)=t[d1];s[d]=s[d1];
    L[d]=(*(L+d1)),R[d]=R[d1];
    if (x==y)
    {
        t[d]++;s[d]+=x;
        return;
    }
    int mid=(x+y)>>1;
    if (p<=mid) insert(L[d],(*(L+d1)),x,mid,p);
    else insert(R[d],R[d1],mid+1,y,p);
    *(t+d)=t[L[d]]+t[R[d]];
    s[d]=s[L[d]]+s[R[d]];
}
ll find(int d1,int d2,int x,int y,int K)//求于等于k的数的个数
{
    if (t[d2]-t[d1]==0) return 0;
    if (x==y) return t[d2]-t[d1];
    int mid=(x+y)>>1;
    if (K<=mid) return t[R[d2]]-t[R[d1]]+find((*(L+d1)),L[d2],x,mid,K);
    return find(R[d1],R[d2],mid+1,y,K);
}
ll Find(int d1,int d2,int x,int y,int K)//求大于等于K的数的和
{	
    if (t[d2]-t[d1]==0) return 0;
    if (x==y) return s[d2]-s[d1];
    int mid=(x+y)>>1;
    if (K<=mid) return s[R[d2]]-s[R[d1]]+Find((*(L+d1)),L[d2],x,mid,K);
    return Find(R[d1],R[d2],mid+1,y,K);
}
inline bool check(int x)
{
    ll sum=0;	
    for (int i=1;i+L1-1<=n;i++)
    {
        sum+=find(rt[i+L1-2],rt[min(i+R1-1,n)],-N,N,x+b[i-1]);
    }
    return sum>=k;
}
ll sum,ans;
signed main()
{
#ifdef ylx
    freopen("piano9.in","r",stdin);
    freopen("p2048.out","w",stdout);
#endif
    n=read();
    k=read();
    L1=read();R1=read();len=R1-L1;
    for (int i=1;i<=n;i++) 
    {
        a[i]=read();
        b[i]=b[i-1]+a[i];//前缀和 
        insert(rt[i],rt[i-1],-N,N,b[i]);//插入到主席树中
    }
    int mid,l=-N,r=N;
    while (l<=r)//二分第k大
    {
        mid=(l+r)>>1;
        if (check(mid)) ans=mid,l=mid+1; else r=mid-1;
    }
    int Cnt=0,C1;
    for (int i=1;i+L1-1<=n;i++)
    {
        C1=find(rt[i+L1-2],rt[min(n,i+R1-1)],-N,N,ans+b[i-1]+1);
        sum+=Find(rt[i+L1-2],rt[min(n,i+R1-1)],-N,N,ans+b[i-1]+1);
        sum-=(ll)b[i-1]*C1;//去掉前面的部分（前面不要算）
        Cnt+=C1;
    }
    //printf("%d %lld\n",Cnt,ans);
    sum+=(ll)(k-Cnt)*ans;//加上剩下的。
    printf("%lld\n",sum);
    return 0;
}
```

---

## 作者：Soulist (赞：17)

这道题真的好妙妙啊~~真怕自己忘记了这个妙妙的思路~~

首先考虑题目要我们求什么，即前$k$大的区间数和

其中，区间长度$[L,R]$

我们考虑做一个前缀和，不难发现，题目所求即：

$sum_x - \min_{i=l}^r(sum_i)$

（$l,r$表示可行的转移区间$(x-r+1,x-l+1)$）

然而对于每个点都考虑是非常不明智的，所有的这种值都求的复杂度是$O(L*n*\log)$

（当然要用堆存一下维护最大值）

**$But$**，我们真的需要求出所有这种值吗？我们只要求前$k$大不是吗？

于是我们可以有一个比较初步的想法，我们每次弹出最大的答案，这样操作$k$次即可不是么。

然而全部存入堆内复杂度不对，所以，我们再仔细思考得到：

对每个$x$求出最大值（显然有$x$的最大值存在，以$x$结尾的其他值不会成为答案），把这些最大值丢入堆内，每次删除后更新最大值对应元素的值。

我们尝试将每个点的转移区间和其本身及答案和答案从那里来看作一体，用一个五元组表示

$(l,r,x,w,t)$表示这段区间$(l,r)$以$x$为结尾的最大答案为$w$，且是通过$(sum_x-sum_t)$得到的，因为$sum_x$本身大小不变，所以我们要求出$(l,r)$区间内最小$sum_t$即可

我们将这些五元组依次丢入一个堆内，那么我们可以弹出最大的答案，而且亦可以保证这一定是最大的答案。

每次弹出后我们把五元组分裂一下，因为这个点已经不能转移给$x$了，所以我们把原来的五元组前三项项变成：$(l,t-1,x),(t+1,r,x)$

每次分裂后重新求一下$(l,r)$内最小值再重新丢入堆好了。

当然求这个最小值用什么都是可以的，但是ST表常数小，就用ST表算了

复杂度$O(k\log(n+k))$

```cpp
#include<bits/stdc++.h>
using namespace std ; 
#define int long long
int read() {
	char cc = getchar() ; int cn = 0, flus = 1 ; 
	while( cc < '0' || cc > '9' ) { if( cc == '-' ) flus = -flus; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' ) cn = cn * 10 + cc - '0', cc = getchar() ; 
	return cn * flus ; 
}
const int N = 5e5 + 5 ; 
#define inf 123456789
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
int n, k, L, R, a[N], mx[N][22], rj[N][22], sum[N], Ans ;  
struct node {
	int l, r, fr, wh, val ;
	bool operator < ( const node& x ) const {
		return val < x.val ; 
	}
};
priority_queue<node> q ; 
int query( int l, int r ) {
	int w = log2(r - l + 1);
	if( mx[l][w] > mx[r - ( 1 << w ) + 1][w] ) return rj[l][w] ; 
	else return rj[r - ( 1 << w ) + 1][w] ;
}
void ins( int l, int r, int x ) {
	int y = query( l, r ) ;
	q.push((node){ l, r, x, y, sum[y] - sum[x - 1] });
}
void init() {
	rep( j, 1, 21 ) {
		for( int i = 1; i + ( 1 << j ) - 1 <= n; ++ i ) {
			mx[i][j] = mx[i][j - 1], rj[i][j] = rj[i][j - 1];
			if( mx[i + ( 1 << (j - 1) )][j - 1] > mx[i][j - 1] ) 
			mx[i][j] = mx[i + ( 1 << (j - 1) )][j - 1], rj[i][j] = rj[i + ( 1 << (j - 1) )][j - 1];
		}
	}
	int l, r, x ; 
	rep( i, 1, n ) {
		l = i + L - 1, r = i + R - 1, r = min( r, n );
		if( l <= n ) ins( l, r, i ) ;
	}
}
void solve() {
	rep( i, 1, k ) {
		if( q.empty() ) break ; 
		node u = q.top(); Ans += 1ll * u.val; q.pop();
		if( u.wh != u.r ) ins( u.wh + 1, u.r, u.fr ) ;
		if( u.wh != u.l ) ins( u.l, u.wh - 1, u.fr ) ; 
	} 
	printf("%lld\n", Ans ) ;
}
signed main() {
	n = read(), k = read(); L = read(), R = read() ;
	rep( i, 1, n ) a[i] = read(), rj[i][0] = i, sum[i] = sum[i - 1] + a[i], mx[i][0] = sum[i] ; 
	init(), solve() ;
	return 0 ; 
}  
```

---

## 作者：Flaranis (赞：14)

大概......这题就我想复杂了？

看到题：前缀和优化--->优先队列+区间第k大--->priority\_queue+树套树

然后发现两个log过不去...

再思考到这题的区间第k大是不带修的

于是就自然而然的想到了主席树

思路大致是对于每个点x，以它为右端点的最优区间先塞入一个heap中

这一步等价于求前缀和s[i]减去x-max到x-min这段前缀和区间的最小值，主席树求第一小

然后每次pop出堆顶累入答案，假设这次pop出的位置是i，为第Rank[i]小

那就将以i为右端点的前缀和减去区间i-max到i-min的第Rank[i]+1小的前缀和压入heap

同时Rank[i]++;这一切都利用静态主席树的区间第k小解决

我用了STL的优先队列，跑了1500ms，时间和空间都比RMQ要多的多。不过好想啊...


Attention：

i-max到i-min可能会<=0需要特判，我直接在序列最前端强行加入一个0以避免


以下是我的代码：

    
        


```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<algorithm>
#define rt register int
#define l printk()
#define ll long long
#define r read()
using namespace std;
inline ll read()
{
    ll x = 0; int zf = 1; char ch;
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') zf = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;
}
void write(ll y)
{
    if (y < 0) putchar('-'), y = -y;
    if (y > 9) write(y / 10);
    putchar(y % 10 + '0');
}
inline int min(const int x,const int y)
{
    return x<y?x:y;
}
inline int max(const int x,const int y)
{
    return x>y?x:y;
}
void printk(){puts("");}
inline void writeln(ll x)
{
    write(x);l;
}
int i,j,k,m,n,x,y,z,cnt,all,Min,Max,u,mid,h,t;
int a[500010],ys[500010],Root[500010],Rank[500010],L,R;
struct num{
    int a,bh;
}s[500010];
struct hjt_tree{
    int ls,rs,size,val;
}tree[500010*40];
inline void up(const int x)
{
    tree[x].size=tree[tree[x].ls].size+tree[tree[x].rs].size;
}
void First_build(int &x,const int L,const int R)
{
    x=++u;
    if(L!=R)
    {
        mid=L+R>>1;
        First_build(tree[x].ls,L,mid);
        First_build(tree[x].rs,mid+1,R);
    }
}
void insert(const int v,int &x,const int la,const int L,const int R)
{
    x=++u;tree[x].size=tree[la].size+1;
    if(L==R)return (void)(tree[x].val=v);
    tree[x].ls=tree[la].ls;tree[x].rs=tree[la].rs;tree[x].size=tree[la].size+1;
    mid=L+R>>1;
    if(v<=mid)insert(v,tree[x].ls,tree[la].ls,L,mid);
    else insert(v,tree[x].rs,tree[la].rs,mid+1,R);
}
inline bool cmp(const num x,const num y)
{
    return x.a<y.a;
}
inline int find(int le,int ri,int rank)
{        
    if(rank>tree[ri].size-tree[le].size)return 2000000000;
    while(tree[ri].ls)
    {
        const rt l1=tree[le].ls,l2=tree[ri].ls,v=tree[l2].size-tree[l1].size;
        if(v>=rank)le=l1,ri=l2;
        else rank-=v,le=tree[le].rs,ri=tree[ri].rs;
    }
    return ys[tree[ri].val];
}
struct two{
    int x,dis;
}p[500010];
inline bool operator <(const two x,const two y)
{
    return x.x<y.x;
}
priority_queue<two>S;
inline int reans(const int x)
{
    return ys[a[x]]-find(Root[max(0,x-R-1)],Root[x-L],Rank[x]++)  ;
}
int main()
{
    n=r;k=r;L=r;R=r;s[1].bh=1;
    for(rt i=2;i<=n+1;i++)a[i]=r,s[i].a=s[i-1].a+a[i],s[i].bh=i;n++;
    sort(s+1,s+n+1,cmp);
    for(rt i=1;i<=n;i++)
    {
        if(s[i].a!=s[i-1].a||i==1)cnt++;
        a[s[i].bh]=cnt;ys[cnt]=s[i].a;
    }
    First_build(Root[0],1,n);
    for(rt i=1;i<=n;i++)insert(a[i],Root[i],Root[i-1],1,cnt);
    for(rt i=1;i<=n;i++)Rank[i]=1;
    for(rt i=1;i<=n;i++)if(i>=L)
    S.push((two){reans(i),i});ll ans=0;
    while(k--)
    {
        ans+=S.top().x;x=S.top().dis;
        S.pop();S.push((two){reans(x),x});
       }
    cout<<ans;
    return 0;
}

```

---

## 作者：Linshey (赞：12)

# 前K大值求解方法

这题的思维难度还是很大的

看题解我才做出来（好吧那不叫做出来

# 1.RMQ问题

RMQ 即区间最大值,分为动态和静态区间最大值,动态区间最大值使用线段树实现（可以持久化）

今天的重点是静态区间最大值——ST表,（草，我连ST表都不会我敢来做这道题？）

ST表的原理就是倍增，有点像倍增DP

实现使用数组$ f_{i, j} = max{A_k|k ∈[i, i+2^j]}$ 
转移： $ f_{i, j} = max(f_{i, j-1}, f_{i + 2^{j- 1},j - 1})$ 
初始值：$f_{i, 0} = A_{i} $

易错点：$ \color{red}\text{很多细节要注意} $
如下：

1.初始值是$f_{i,0} = A_{i} $ 而不是$f_{i, 1}=A_{i} $  
2.位运算一定要加括号   
3.转移时的+1/-1极容易出岔子   
4.左右边界一定要对上  
5.初始化及其他任何脑残错误  

## Code.

### init:

```cpp
void init()
{
	memset(ST, -127 / 3, sizeof(ST));
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> A[i];
	}
	for (int i = n; i > 0; i--)
	{
		ST[i][0] = A[i];
		for (int j = 1; i + (1 << j) - 1 <= n; j++)
		{
			ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);
		}
	}
}
```

( pos指的是最大值的位置，视情况而定）

### qry:

```cpp
int qryk(int l, int r)
{
	int tmp = int(log(r - l + 1) / log(2));
	int maxsumk = max(ST[l][tmp], ST[r - (1 << tmp) + 1][tmp])
	return maxsumk;
}
```

还有另一种巧妙地写法，使得支持查询最值的位置：(感谢Nekroz）

```cpp
void init(int n) {
    for (int i = 1; i <= n; i++) table[i][0] = i;
    for (int j = 1; (1 << j) <= n; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            int x = table[i][j - 1], y = table[i + (1 << (j - 1))][j - 1];
            table[i][j] = sum[x] > sum[y] ? x : y;
        }
}
int query(int l, int r) {
    int k = log2(r - l + 1);
    int x = table[l][k], y = table[r - (1 << k) + 1][k];
    return sum[x] > sum[y] ? x : y;
}
```

# 2.本题的处理

本题的处理比较麻烦，大致思路如下：

首先解决一个误会：音符集合相同并不是美妙度集合相同，因此那句话几乎可以忽略

我们这个肯定是取序列中最大的k个和弦,那么最为暴力方法是取出序列中所有的和弦,取最大的K个，肯定超时.

解决这种问题的一般方法：

$ \color{red}\text{建立集合S, 使当前剩余最大值一定存在于S中，且使得将最大值排除后，集合性质不变} $

这一题的解决方法是：

$ Nowmax = max{f_{o,l,r}}$,   
$ f_{o,l,r} = max{sum_k - sum_{o-1}|k∈[l,r]}$,

这样做的好处：可以完美地满足题目中$[l,r]$的性质,且取出最优解后，可以将$(o,l,r)$切成前后两半，放回去，原集合性质不变

具体实现使用二叉堆，将三元组放进堆里，然后取k次堆顶，取完堆顶将堆顶切成两半放回堆里。

# Talk is cheap.

```cpp

#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>

using namespace std;
const int maxn = 500005 * 4;

int n, k, L, R, A[maxn];
int sum[maxn], ST[maxn][20], pos[maxn][20];

void init()
{
	memset(sum, -127 / 3, sizeof(sum));
	memset(ST, -127 / 3, sizeof(ST));
	cin >> n >> k >> L >> R;
	sum[0] = 0;
	for (int i = 1; i <= n; i++)
	{
		cin >> A[i];
		sum[i] = sum[i - 1] + A[i];
	}
	for (int i = n; i > 0; i--)
	{
		ST[i][0] = sum[i]; pos[i][0] = i;
		for (int j = 1; i + (1 << j) - 1 <= n; j++)
		{
			ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);
			pos[i][j] = ST[i][j - 1] > ST[i + (1 << (j - 1))][j - 1] ? pos[i][j - 1] : pos[i + (1 << (j - 1))][j - 1];
		}
	}
}

int qryk(int o, int l, int r)
{
	int tmp = int(log(r - l + 1) / log(2));
	int maxsumk = ST[l][tmp] > ST[r - (1 << tmp) + 1][tmp] ?
		pos[l][tmp] : pos[r - (1 << tmp) + 1][tmp];
	return maxsumk;
}

struct node
{
	int o, l, r, k;
	bool operator <(const node b) const
	{
		return sum[k] - sum[o - 1] < sum[b.k] - sum[b.o - 1];
	}
} tmp, tmp2;

priority_queue<node> hp;

int main()
{
	init();
	for (int o = 1; o + L - 1 <= n; o++)
	{
		tmp.o = o;
		tmp.l = o + L - 1;
		tmp.r = min(n, o + R - 1);
		tmp.k = qryk(o, tmp.l, tmp.r);
		hp.push(tmp);
	}
	long long ans = 0;
	while (k--)
	{
		tmp = hp.top(); hp.pop();
		ans += sum[tmp.k] - sum[tmp.o - 1];
		if (tmp.k != tmp.r)
		{
			tmp2 = tmp;
			tmp2.l = tmp.k + 1;
			tmp2.k = qryk(tmp2.o, tmp2.l, tmp2.r);
			hp.push(tmp2);
		}
		if (tmp.k != tmp.l)
		{
			tmp.r = tmp.k - 1;
			tmp.k = qryk(tmp.o, tmp.l, tmp.r);
			hp.push(tmp);
		}
	}
	cout << ans << endl;
	return 0;
}
```












---

## 作者：axs7384 (赞：9)

大致题意是求前k大长度在l到r长度的子串和。

先用前缀和处理数据，用st表预处理区间最小值

然后构建一个大根堆

队里存储左边界的范围(-1)，右边界，以此为右边界的最大答案，最大答案时的左边界（-1）

每次取出都把左边界的范围拆分成2份

维护一下就好了


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
ll a[500005],i,j,k,lll,rr,xx,yy,zz,ed,ans,n;
int st[500005][20];
struct da{
    ll l1,l2,r,x,sum;
}h[1000005],yyyy;
int min(int x,int y)
{
    return a[x]<a[y]?x:y;
}
inline void read(ll &xxx)
{
    char ch;ll bo=0;xxx=0;
    for (ch=getchar();ch<'0'||ch>'9';ch=getchar())if (ch=='-')bo=1;
    for (;ch>='0'&&ch<='9';xxx=xxx*10+ch-'0',ch=getchar());
    if (bo)xxx=-xxx;
}
void up(ll i)
{
    if (i==1) return;
    if (h[i].sum>h[i>>1].sum)
    {
        swap(h[i],h[i>>1]);
        up(i>>1);
    }
}
void down(ll i)
{
    //cout<<i<<endl;
    ll j=i<<1;
    if (j>ed) return;
    if (j<ed)
        if (h[j].sum<h[j+1].sum)
            ++j;
    if (h[i].sum<h[j].sum)
    {
        swap(h[i],h[j]);
        down(j);
    }
}
void build(ll z1,ll z2,ll y)
{
    //cout<<z1<<' '<<z2<<' '<<y<<endl;
    ll m = int(double(log(z2-z1+1))/double(log(2)));
    ++ed;
    h[ed].l1=z1;
    h[ed].l2=z2;
    h[ed].r=y;
    if (z1==z2) 
        h[ed].x=z1;
    else h[ed].x=min(st[z1][m],st[z2-(1<<m)+1][m]);
    h[ed].sum=a[y]-a[h[ed].x];
    up(ed);
}
void cut()
{
    da o=h[1];
    //cout<<'!'<<h[1].l1<<' '<<h[1].l2<<' '<<h[1].r<<' '<<h[1].x<<' '<<h[1].sum<<endl;
    ans+=h[1].sum;
    h[1]=h[ed];
    --ed;
    down(1);
    if (o.l1<=o.x-1) 
        build(o.l1,o.x-1,o.r);
    if (o.l2>=o.x+1)
        build(o.x+1,o.l2,o.r);
    //for (ll i=1;i<=ed;i++)
    //    cout<<'?'<<h[i].l1<<' '<<h[i].l2<<' '<<h[i].r<<' '<<h[i].x<<' '<<h[i].sum<<endl;
}
int main()
{
    read(n);
    read(k);
    read(lll);
    read(rr);
    for (i=1;i<=n;++i)
    {    
        read(a[i]);
        a[i]+=a[i-1];
        st[i][0]=i;
    }
    a[0]=0;
    xx=double(log(n))/double(log(2));
    for (i=1;i<=xx;i++)
    {
        yy=1<<i;
        zz=yy>>1;
        for (j=0;j<=n-yy+1;j++)
            st[j][i]=min(st[j][i-1],st[j+zz][i-1]);
    }
    /*for (i=0;i<=n;i++)
        cout<<a[i]<<' ';
    cout<<endl;
    for (i=1;i<=xx;i++)
    {
        for (j=0;j<=n-(1<<i)+1;j++)
            cout<<j<<' '<<i<<' '<<st[j][i]<<';';
        cout<<endl;
    }*/
    for (i=lll;i<=n;i++)
        build(max(i-rr,(ll)0),i-lll,i);
    //for (i=1;i<=ed;i++)
    //    cout<<h[i].l1<<' '<<h[i].l2<<' '<<h[i].r<<' '<<h[i].x<<' '<<h[i].sum<<endl;
    for (i=1;i<=k;i++)
    {    
        cut();
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：luckydrawbox (赞：4)

[$\text{Link}$](https://www.luogu.com.cn/problem/P2048)

## 题意

给出一个长度为 $n$ 的数组 $A_{1\sim n}$，求区间和前 $k$ 大的长度在 $[L,R]$ 之间的区间的区间和之和。

## 分析

显然选出的这前 $k$ 大的区间的区间和肯定是单调不升的，我们可以二分最小的区间和 $mid$，看区间和不小于 $mid$ 的区间是否超过 $k$ 个。

要求区间和，显然可以直接用前缀和， $\text{check}$ 函数就是求 $sum_i-sum_{j}\ge mid$ 且 $j+L\le i\le j+R$ 的 $(i,j)$ 的个数是否大于等于 $k$。

移项一下可以得到 $sum_i\ge mid+sum_{j}$，对于每个 $j$，我们求出有多少个 $i$ 满足要求即可。

如果直接从 $1\sim n$ 枚举 $j$ 的话，很难用什么数据结构在同时满足两个条件的情况下计数，但是我们可以改变一下枚举顺序，按 $sum_j$ 从大到小枚举，这样的话到下一个 $sum_{j'}$ 时满足第一个条件的集合需要新加入的 $i$ 也是从大到小的，加入时把第 $i$ 个位置标记为 $1$，统计 $[j+L,j+R]$ 的 $1$ 的个数就是 $j$ 的答案。

为了改变枚举顺序，我们可以把 $sum_{j=0\sim n-1}$ 和 $sum_{i=1\sim n}$ 分别从大到小排序，用双指针 $+$ 树状数组维护即可。

二分出最大的 $mid$ 后，用同样的办法统计符合条件的 $sum_i$，减去 $sum_j$ 就可以求到和，注意如果 $(i,j)$ 的个数大于 $k$，要把多余的 $mid$ 减去。

令值域为 $S$，则时间复杂度为 $O(n\log n\log S)$，~~由于这题的题号 2048 很二进制所以树状数组做法可以过~~。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=5e5+10;
int n,L,R,ff;
ll a[N],s[N],l,r,c1[N],c2[N],ans2,k,cnt,w,z;
struct asdf{
	ll v;
	int id;
}d1[N],d2[N];
bool cmp(asdf x,asdf y){
	return x.v>y.v;
}
void add1(int x,ll v){
	for(;x<=n;x+=x&-x)
		c1[x]+=v;
}
ll ask1(int x){
	ll ans=0;
	if(x>n)
		x=n;
	for(;x;x-=x&-x)
		ans+=c1[x];
	return ans;
}
void add2(int x,ll v){
	for(;x<=n;x+=x&-x)
		c2[x]+=v;
}
ll ask2(int x){
	ll ans=0;
	if(x>n)
		x=n;
	for(;x;x-=x&-x)
		ans+=c2[x];
	return ans;
}
ll check(ll x,bool f){
	ll ans=0;
	for(int i=1;i<=n;i++)
		c1[i]=0;
	for(int i=1,j=1;i<=n;i++){
		while(j<=n&&d1[j].v>=d2[i].v+x){
			add1(d1[j].id,1);
			if(f)
				add2(d1[j].id,d1[j].v);
			j++;
		}
		w=ask1(d2[i].id+R)-ask1(d2[i].id+L-1);
		ans+=w;
		if(f)
			ans2+=ask2(d2[i].id+R)-ask2(d2[i].id+L-1)-d2[i].v*w;
	}
	return ans;
}
int main(){
	n=read();k=read();L=read();R=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		s[i]=s[i-1]+a[i];
		d1[i].v=s[i];
		d2[i].v=s[i-1];
		d1[i].id=i;d2[i].id=i-1;
		if(a[i]<0)
			l+=a[i];
		else
			r+=a[i];
	}
	sort(d1+1,d1+n+1,cmp);
	sort(d2+1,d2+n+1,cmp);
	l*=k;r*=k;
	while(l<r){
		ll mid=(l+r+1)>>1;
		if(check(mid,0)>=k)
			l=mid;
		else
			r=mid-1;
	}
	ll p=check(l,1);
	ans2-=(p-k)*l;
	write(ans2);
	return 0;
}
```

---

## 作者：lahlah (赞：4)

# 题目大意：

### 求前k大的长度在L~R之间的最大连续子序列和的和。


# 题解：

首先先做一个前缀和，设sum[i]表示的是1~i的和

然后枚举右端点 r，区间所对应的左端点只能在 r - R + 1到 r - L + 1 之间，然后对sum数组的r - R 到 r - L 之间取个最小值就可以了，这里直接用st表维护，然后把这个最大的加到大根堆里，维护一个四元组（a, b, c, d）,a表示答案，就是以b为右端点，左端点在c~d之间的最大连续子序列和。

然后每次把大根堆堆顶的元素拿出来，答案加上a之后把这个区间拆成两个区间，假设最大的区间的左端点在mid这个位置，那么这个区间就可以拆成c~mid-1和mid+1~d这两个区间，再把它们加入到堆里,这样做k次就可以了。

code：~~（好像还比较短）~~
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
#define pr pair<int,int>//毒瘤操作
#define mp(a, b, c, d) make_pair(make_pair(a, b), make_pair(c, d))//毒瘤操作+1
using namespace std;
priority_queue<pair<pr, pr> >q;//毒瘤操作，这样就可以表示四元组了
int sum[N], f[N][24], n, k, L, R;
int mi(int x, int y){//比较x,y这两个位置的sum的值
	if(sum[x] < sum[y]) return x;
	return y;
}
int query(int x, int y){//求x~y的最小值的位置
	if(x > y) return -1;
	int k = log2(y - x + 1);
	return mi(f[x][k], f[y - (1 << k) + 1][k]);
}
signed main(){
	scanf("%lld%lld%lld%lld", &n ,&k, &L, &R);
	for(int i = 1; i <= n; i ++) scanf("%lld", &sum[i]), f[i][0] = i, sum[i] += sum[i - 1];
	for(int j = 1; j <= 20; j ++)
		for(int i = 0; i <= n; i ++)
			f[i][j] = mi(f[i][j - 1], (i + (1 << (j - 1)) <= n)? f[i + (1 << (j - 1))][j - 1]:f[i][j - 1]);//st表
	for(int i = L; i <= n; i ++) q.push(mp(sum[i] - sum[query(max(i - R, 0ll), i - L)], i, max(i - R, 0ll), i - L));//先把一开始的加进去
	int ans = 0;
	for(int i = 1; i <= k; i ++){
		pr h1 = q.top().first, h2 = q.top().second; q.pop();
		int a = h1.first, b = h1.second, c = h2.first, d = h2.second;
		ans += a; int mid = query(c, d);
		int x = query(c, mid - 1), y = query(mid + 1, d);//x,y分别为拆开后两个区间的最优左端点
		if(x != -1) q.push(mp(sum[b] - sum[x], b, c, mid - 1));//拆成两个区间
		if(y != -1) q.push(mp(sum[b] - sum[y], b, mid + 1, d));	
	}
	printf("%lld", ans);
	return 0;
}//好棒的一道题！
```

---

## 作者：苏联元帅 (赞：3)

这里我给出一种思维难度比较低，比较直接的做法.
首先我们将这道题转化为求前ｋ大区间和，区间长度需要在L,R之间．这个问题比较难，我们先求这些区间中第k大区间和是多少．此问题可以转化为判定性问题，用二分答案解决．

   我们需要求对某个x，有多少个区间的和<=x，且区间长度满足条件．对以j结尾的区间，其开头i属于[j-R+1,j-L+1]．设前缀和数组为S，S[j]-S[i-1]<=x，即为S[i-1]<=S[j]-x．如果将前缀和数组用数据结构维护，该问题可以进一步转化为序列上某区间中有多少个数<=x．
   
   我们可以将前缀和数组依次插入可持久化01trie．该数据结构可以以O(32)的复杂度查询区间[1,x]中<=某数ｙ的数的个数．查询[L,R]只需要用查询两次相减即可．
   
   当我们得到第ｋ大区间和是p．我们只需要知道有多少个区间和大于k，设有ａ个，这些区间和的和为Sum．则我们恰好还要选k-a个和为p的区间．最终答案即为(k-a)*p+Sum
   
   如果想知道有多少个区间和大于ｋ，方法和之前判定方法非常类似不再赘述．这些区间的和要在可持久化01trie上多维护一个和的信息，思路也很相似．
   初始化可持久化01trie复杂度O(32n)，二分判定复杂度O(32nlogn)，最后统计答案复杂度O(32n),故总复杂度O(32nlogn)，01trie常数极小，故能险险地过本题．
   	
    
 
```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
const int maxn=5e5+1000;
int n,K,L,R;
int a[maxn];
int sum[maxn]={0};
typedef long long ll;
struct trie
{
    int size,ch[2];
    ll sum;
}Trie[maxn*40];
int mem=0;
int root[maxn]={0};
#define size(x) Trie[x].size
#define lch(x) Trie[x].ch[0]
#define rch(x) Trie[x].ch[1]
#define sum(x) Trie[x].sum
void insert(int& rt,int old,int v)
{
    int org=v;
    v+=5e8;
    rt=++mem;
    size(rt)=size(old)+1;
    sum(rt)=sum(old)+org;
    int p=rt,q=old;
    for(int i=30;i>=0;i--)
    {
        if(v&(1<<i))
        {	
            rch(p)=++mem;
            lch(p)=lch(q);
            p=rch(p);
            q=rch(q);
        }
        else
        {
            lch(p)=++mem;
            rch(p)=rch(q);
            p=lch(p);
            q=lch(q);
        }
        size(p)=size(q)+1;	
        sum(p)=sum(q)+org;
    }
    
} 
inline int getsmaller(int rt,int v) //查询平衡树中<v的数的个数
{
    v+=5e8;
    register int p=rt,ret=0;
    for(int i=30;i>=0;i--)
    {
        if(v&(1<<i))
        {	
            ret+=size(lch(p));
            p=rch(p);
        }
        else
            p=lch(p);
        if(!p)
            return ret;
    }
    return ret;
}
inline ll getsum(int rt,int v)		//查询平衡树中<v的数的和
{
    v+=5e8;
    register int p=rt;	
    register ll ret=0;
    for(int i=30;i>=0;i--)
    {
        if(v&(1<<i))
        {
            ret+=sum(lch(p));
            p=rch(p);
        }
        else
            p=lch(p);
        if(!p)
            return ret;
    }
    return ret;
}
ll getcount(int x)		//有多少个区间和<=x
{
    ll ret=0;
    for(int i=1;i<=n;i++)
    {
        if(i>R)
        {
            int lp=i-R-1;
            int rp=i-L;
            int l=getsmaller(root[lp],sum[i]-x+1);
            int r=getsmaller(root[rp],sum[i]-x+1);
            ret+=r-l;
        }
        else if(i>=L)
        {
            int rp=i-L;
            int r=getsmaller(root[rp],sum[i]-x+1);
            ret+=r;
        }
    }

    return ret;
}
int main()
{
//	freopen("piano10.in","r",stdin);
    ios::sync_with_stdio(false);
    cin>>n>>K>>L>>R;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        sum[i]=sum[i-1]+a[i];
    }
    insert(root[0],root[0],0);
    for(int i=1;i<=n;i++)
        insert(root[i],root[i-1],sum[i]);
    //cout<<mem<<endl;
    const int t=5e8;
    int l=0,r=1e9+100;
    while(l<r)
    {
        int mid=(l+r)>>1;
        ll ret=getcount(mid-t);
        if(ret<K)
            r=mid;
        else
            l=mid+1;
    }
    int x=l-t-1;
    ll real=0;
    for(int i=1;i<=n;i++)
    {
        if(i>R)
        {
            int lp=i-R-1;
            int rp=i-L;
            int li=getsmaller(root[lp],sum[i]-x);
            int ri=getsmaller(root[rp],sum[i]-x);
            real+=ri-li;
        }
        else if(i>=L)
        {
            int rp=i-L;
            
            int ri=getsmaller(root[rp],sum[i]-x);
            real+=ri;
        }
    }
    real=K-real;	//real是区间和恰好为x的区间中我们要选的个数
    ll su=0;
    for(int i=1;i<=n;i++)
    {
        if(i>R)
        {
            int lp=i-R-1;
            int rp=i-L;
            ll l=getsum(root[lp],sum[i]-x);
            ll r=getsum(root[rp],sum[i]-x);
            int li=getsmaller(root[lp],sum[i]-x);
            int ri=getsmaller(root[rp],sum[i]-x);
            su+=1ll*sum[i]*(ri-li)-(r-l);
        }
        else if(i>=L)
        {
            int rp=i-L;
            ll r=getsum(root[rp],sum[i]-x);
            int ri=getsmaller(root[rp],sum[i]-x);
            su+=1ll*sum[i]*ri-r;	
        }
    }
    su+=1ll*real*x;
    cout<<su<<endl;
    return 0;
}
/*
5 7 1 5
1 1 -1 1 1
 */
```

---

## 作者：Kyon (赞：2)

先前拿st表搞了半天,好歹是调过了.
突然意识到,用划分树应该很简单.结果一发就过了==...
看题解也没有写划分树的,便分享一下自己的思路.~~套主席树我是不会的~~
***
### 首先我们来理解一下题意:
给你$n$个数,求前$k$大长度在$(L,R)$内的子串和

那么,很显然,求子段和,首先就要把前缀和求出来.

于是这道题就变成了:

前缀和:$sum[i]=	\sum_{j=1}^i a[j]$

如何再把每一个$i$对应的所有$\{sum[i+L-1]......sum[min(i+R-1,n)]\}-sum[i]$都存起来,列如扔进一个优先队列里,然后取前$k$个.
***
### 显然这个过于暴力,当然是会$TLE$的.
我们同一个思路,换一个解法.

对于每一个以$a[i]$为开头的子串和$\{sum[L+i-1]....sum[R+i-1]\}-sum[i]$,都有一个最大值.

那么是不是我们把所有最大值存起来就完事了?

显然有个问题:对于$\{sum[L+j-1].....sum[R+j-1]\}-sum[j]$,以$a[j]$为开头的第二甚至第三,第四大子段和,都有可能大于以$a[i]$开头的$\{sum[L+i-1]....sum[R+i-1]\}-sum[i]$的最大值.

解决方法则是,当我们取完以$a[j]$为开头的子段和最大值,再将以$a[j]$开头的子段和次大值扔进优先队列里,不断取出放进.

直到取满$k$个为止.
***
### 根据上述思路,我们在这里可以完美的使用划分树来解决.
划分树能干什么呢?它可以求取区间$[L,R]$中的第$k$大值.而且很简单简洁.

划分树的讲解可参考我的[blog](https://blog.csdn.net/UnKfrozen/article/details/90215747)
1. 先将每个区间的最大值放入优先队列中
2. 遍历优先队列,先取出的值必定是最大值.
3. 再求取该区间的第二大值,放入优先队列
4. 循环直到取得$k$个值

如何保存呢?我们整一个结构体,里面保存$i,i+L-1,min(n,i+R-1)$,取得的数是$\{i+L-1,min(n,i+R-1)\}$的第$t$大数,和所得的最大值ans.
***
```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#include<queue>
#include<stdio.h>
#include<stdlib.h>
#include<map>
#include<cstring>
#include<algorithm>
#ifndef null
#define null -1
#endif
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int MAXN = 5e5 + 10;

ll tree[20][MAXN],sorted[MAXN];
int toleft[20][MAXN],n;

void built(int l, int r, int dep)
{
	if (l == r)
		return;
	int mid = (l + r) >> 1, same = mid - l + 1;
	for (int i = l; i <= r; i++)
		if (tree[dep][i] > sorted[mid])
			same--;
	int lpos = l, rpos = mid + 1;
	for (int i = l; i <= r; i++) {
		if (tree[dep][i] > sorted[mid])
			tree[dep + 1][lpos++] = tree[dep][i];
		else if (tree[dep][i] == sorted[mid] && same > 0) {
			tree[dep + 1][lpos++] = tree[dep][i];
			same--;
		}
		else
			tree[dep + 1][rpos++] = tree[dep][i];
		toleft[dep][i] = toleft[dep][l - 1] + lpos - l;
	}
	built(l, mid, dep + 1);
	built(mid + 1, r, dep + 1);
}

ll query(int L, int R, int l, int r, int dep, int k)
{
	if (l == r)
		return tree[dep][l];
	int mid = (L + R) >> 1;
	int cnt = toleft[dep][r] - toleft[dep][l - 1];
	if (cnt >= k) {
		int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1];
		int newr = newl + cnt - 1;
		return query(L, mid, newl, newr, dep + 1, k);
	}
	else {
		int newr = r + toleft[dep][R] - toleft[dep][r];
		int newl = newr - (r - l - cnt);
		return query(mid + 1, R, newl, newr, dep + 1, k - cnt);
	}
}

bool cmp(ll a, ll b)
{
	return a > b;
}

struct vec {
	int o, l, r, t;
	ll a;
	vec(int x, int y, int z,int k ) {
		o = x, l = y, r = z, t = k;
		a = query(1, n, l, r, 0, t) - tree[0][o - 1];
	}
	vec(){}
	friend bool operator < (const vec &x,const vec &y) {
		return x.a < y.a;
	}
}p;

priority_queue<struct vec>q;

int main()
{
	int  k, L, R;
	cin >> n >> k >> L >> R;
	for (int i = 1; i <= n; i++) {
		cin >> tree[0][i];
		tree[0][i]+= tree[0][i - 1];
		sorted[i] = tree[0][i];
	}

	sort(sorted + 1, sorted + n + 1,cmp);
	built(1, n, 0);

	for (int i = 1; i + L - 1 <= n; i++) 
		q.push(vec(i, i + L - 1, min(n, i + R - 1), 1));
	
	ll ans = 0;
	while (k && !q.empty()) {
		p = q.top(); q.pop();
		ans += p.a;
		k--;

		if(p.r-p.l+1>p.t)
			q.push(vec(p.o, p.l, p.r,p.t + 1));
	}
	cout << ans << endl;

	return 0;
}
```



---

## 作者：HomuraCat (赞：2)

这题思路比较巧妙

首先题意是让你求前k大区间之和。

首先区间和容易想到差分。

我们枚举左端点$i$，那么右端点会有一个范围$[i + L - 1, min(i + R - 1,n)]$

对于每个左端点，我们可以找到一个右端点，使得这段区间和最大。用堆维护所有这样的最大值，我们就能找到当前没选的区间里区间和最大的是哪个区间

因为每次要删除选过的区间，我们可以将这个左端点拆成两个，记选的数位置为k，那么在堆中加入(左端点i,右端点范围$[i+L-1,k-1]$)和(左端点i,右端点范围$[k+1, min(i + R - 1,n)])$即可

复杂度是$O(nlogn)$的啦

代码

```cpp
#include<bits/stdc++.h>
#define fo(i, a, b) for (int i = (a); i <= (b); ++i)
#define fd(i, a, b) for (int i = (a); i >= (b); --i)
#define N 2200005
#define ls(u) t[u].s[0]
#define rs(u) t[u].s[1]
#define mod 51061
#define ll long long
int a[N], n, m, L, R, len, st[N][23];
ll ans;
inline int query (int l, int r)
{
    len = log(r - l + 1) / log(2);
    return a[st[l][len]] > a[st[r - (1 << len) + 1][len]] ? st[l][len] : st[r - (1 << len) + 1][len];
}
struct node{
    int z, l, r, v;
    node (int z, int l, int r) : z(z), l(l), r(r), v(query(l, r)) {}
    friend bool operator < (node x, node y) {return a[x.v] - a[x.z] < a[y.v] - a[y.z];}
};
std::priority_queue<node> q;
int main ()
{
    scanf("%d %d %d %d", &n, &m, &L, &R);
    fo (i, 1, n) {scanf("%d", &a[i]); a[i] += a[i - 1]; st[i][0] = i;}
    fo (j, 1, 20)
        fo (i, 1, n)
            st[i][j] = a[st[i][j - 1]] > a[st[i + (1 << j - 1)][j - 1]] ? st[i][j - 1] : st[i + (1 << j - 1)][j - 1];
    fo (i, 1, n)
        if (i + L - 1 <= n)
            q.push(node(i - 1, i + L - 1, std::min(i + R - 1, n)));
    fo (i, 1, m)
    {
        node tmp = q.top(); q.pop();
        ans += a[tmp.v] - a[tmp.z];
        if (tmp.v != tmp.l) q.push(node(tmp.z, tmp.l, tmp.v - 1));
        if (tmp.v != tmp.r) q.push(node(tmp.z, tmp.v + 1, tmp.r));
    }
    printf("%lld\n", ans);
}
```

---

## 作者：Ebola (赞：2)

**优先队列+zkw线段树**

用大根堆去维护四元组(s, x, l, r)，表示以x为右端点、\[l, r\]中取一个位置为左端点的这些区间中，最大的区间和为s。直接使用STL的优先队列即可

然后每次取堆顶元素，将s加入答案，然后找到取得s这个最大值的位置p，将左端点选取区间分裂为\[l, p-1\]和\[p+1, r\]两个。然后求出两个选取区间中的左端点与右端点所构成的区间中的最大区间和。将新得到的两个四元组入堆

现在问题变成了——已知右端点与左端点的选取区间，求一个左端点，使得区间和最大。哦我知道了，用主席树！我可去你的啊！(╯‵□′)╯︵┻━┻

其实吧，求出前缀和数组，然后求左端点选取区间中的最小前缀和，那与右端点构成的不就是最大区间和吗？所以就是一个RMQ啊，用ST表搞搞就行。但是ST表预处理常数好大啊，zkw线段树的实际效率比ST表快多了！

```cpp
#include<bits/stdc++.h>
using namespace std;

const int S=(1<<20)+5;
char buf[S],*H,*T;
inline char Get()
{
    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
    if(H==T) return -1;return *H++;
}
inline int read()
{
    int x=0,fg=1;char c=Get();
    while(!isdigit(c)&&c!='-') c=Get();
    if(c=='-') fg=-1,c=Get();
    while(isdigit(c)) x=x*10+c-'0',c=Get();
    return x*fg;
}

const int N=500010;
typedef pair<int,int> pii;
typedef pair<pii,pii> ppp;
priority_queue<ppp> q;
int mn[N<<2],mnid[N<<2],leaf;
int n,K,L,R;
int sum[N];

void build()
{
    for(leaf=1;leaf<=n+2;leaf<<=1);
    memset(mn,0x3f,sizeof(mn));leaf++;
    for(int i=0;i<=n;i++) mn[leaf+i]=sum[i],mnid[leaf+i]=i;
    for(int i=leaf-2;i;i--)
    {
        if(mn[i<<1]<mn[i]) mn[i]=mn[i<<1],mnid[i]=mnid[i<<1];
        if(mn[i<<1|1]<mn[i]) mn[i]=mn[i<<1|1],mnid[i]=mnid[i<<1|1];
    }
}
int query(int l,int r)
{
    if(l>r) return -1;
    int res=INT_MAX,ans;
    for(l=leaf+l-1,r=leaf+r+1;l^r^1;l>>=1,r>>=1)
    {
        if(~l&1) if(mn[l^1]<res) res=mn[l^1],ans=mnid[l^1];
        if(r&1) if(mn[r^1]<res) res=mn[r^1],ans=mnid[r^1];
    }
    return ans;
}

int main()
{
    n=read();K=read();L=read();R=read();
    for(int i=1;i<=n;i++) sum[i]=sum[i-1]+read();
    build();
    for(int i=L;i<=n;i++)
    {
        int l=max(i-R,0),x=query(l,i-L);
        q.push(ppp(pii(sum[i]-sum[x],i),pii(l,i-L)));
    }
    long long ans=0;
    for(int i=1;i<=K;i++)
    {
        pii p1=q.top().first,p2=q.top().second;q.pop();
        int p=p1.second;ans+=p1.first;
        int x=query(p2.first,p2.second);
        int y1=query(p2.first,x-1),y2=query(x+1,p2.second);
        if(~y1) q.push(ppp(pii(sum[p]-sum[y1],p),pii(p2.first,x-1)));
        if(~y2) q.push(ppp(pii(sum[p]-sum[y2],p),pii(x+1,p2.second)));
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：KokiNiwa (赞：1)

# [NOI2010]超级钢琴

## 想法

对于每一个位置$i$而言，可以在这个位置前面$i-L+1$到$i-R+1$这些位置中选择一个位置，求区间和。于是我们就需要求出所有的位置的所有区间和中前$k$大的数的和。现在二分第$k$大是多少，然后看对于每一个位置而言有多少个可选区间使得比第$k$大要大。二分之后，再求出前$k$大的所有数的和。所以我们考虑用主席树维护，这样求出每个区间内小于一个数的数的数量，而且求出这些数的和。但仔细观察发现每一次二分$check$的时候，维护的区间是这样的：$[l,r],[l+1,r+1],[l+2,r+2]\cdots\cdots$。这样就可以用一个树状数组，每一次去掉当前区间的头，加上尾，就可以了。

结果是这样的：

| 算法     | 常数 |      | 得分                              | 复杂度       | 代码复杂度 |
| -------- | ---- | ---- | --------------------------------- | ------------ | ---------- |
| 树状数组 | 小   |      | $80$（经过卡常后得到两个超时）    | $O(nlog^2n)$ | 不复杂     |
| 主席树   | 大   |      | $60$（一个错误答案 $\&$ 3个超时） | $O(nlog^2n)$ | 复杂       |
|          |      |      |                                   |              |            |



## 代码

### 树状数组（80分）

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#define lowbit(x) (((x))&(-(x)))

using namespace std;

typedef long long ll;
inline int read()
{
    char s;
    ll k=0,base=1;
    while((s=getchar())!='-'&&!(isdigit(s)));
    if(s=='-')base=-1,s=getchar();
    while(isdigit(s)){k=k*10+(s^'0');s=getchar();}
    return k*base;
}
const int maxLen = 5e5;
int len = 0, chosK = 0, lLim = 0, rLim = 0, diffNum = 0;
int seq[maxLen + 5] = {}, liSan[maxLen + 5] = {}, preSum[maxLen + 5] = {};
struct BIT
{
	ll bit[maxLen + 5];
	void clear() { memset(bit, 0, sizeof(bit)); }
	inline void add(int pos, int val)
	{
		for (; pos <= diffNum; pos += lowbit(pos))
			bit[pos] += val;
		return ;
	}
	inline ll ask(int pos)
	{
		ll ret = 0;
		//ret应该是 long long 类型的！！！
		for (; pos; pos -= lowbit(pos))
			ret += bit[pos];
		return ret;
	}
} valSum, cnt;
ll getNum(int val)
{
	cnt.clear();
	ll ret = 0;
	int nowLep = 1, nowRep = 0;
	
	for (int seqI = 1; seqI <= len; ++seqI)
	{
		int lep = max(1, seqI - rLim + 1), rep = min(len, seqI - lLim + 1);
		int need = upper_bound(liSan + 1, liSan + diffNum + 1, preSum[seqI + 1] - val) - (liSan + 1);
		while (nowLep < lep)
		{
			int delVal = upper_bound(liSan + 1, liSan + diffNum + 1, preSum[nowLep]) - liSan - 1;
			cnt.add(delVal, -1);
			++nowLep;
		}
		while (nowRep < rep)
		{
			int addVal = upper_bound(liSan + 1, liSan + diffNum + 1, preSum[rep]) - liSan - 1;
			cnt.add(addVal, 1);
			++nowRep;
		}
		ret += cnt.ask(need);
	}
	return ret;
}
ll getSum(int val)
{
	cnt.clear();
	valSum.clear();
	ll ret = 0;
	int nowLep = 1, nowRep = 0;
	
	for (int seqI = 1; seqI <= len; ++seqI)
	{
		int lep = max(1, seqI - rLim + 1), rep = min(len, seqI - lLim + 1);
		int need = upper_bound(liSan + 1, liSan + diffNum + 1, preSum[seqI + 1] - val) - (liSan + 1);
		while (nowLep < lep)
		{
			int delVal = upper_bound(liSan + 1, liSan + diffNum + 1, preSum[nowLep]) - liSan - 1;
			cnt.add(delVal, -1);
			valSum.add(delVal, -preSum[nowLep]);
			++nowLep;
		}
		while (nowRep < rep)
		{
			int addVal = upper_bound(liSan + 1, liSan + diffNum + 1, preSum[rep]) - liSan - 1;
			cnt.add(addVal, 1);
			valSum.add(addVal, preSum[rep]);
			++nowRep;
		}
		ret += 1ll * preSum[seqI + 1] * cnt.ask(need) - valSum.ask(need);
		//这里也要开 long long！！！
	}
	return ret;
}

signed main()
{
	freopen("super.in", "r", stdin);
	freopen("piano.out", "w", stdout);
	len = read(); chosK = read(); lLim = read(); rLim = read();
	for (int seqI = 1; seqI <= len; ++seqI)
	{
		seq[seqI] = read();
		preSum[seqI + 1] = preSum[seqI] + seq[seqI];
		liSan[seqI + 1] = preSum[seqI + 1];
	}
	liSan[1] = 0;
	sort(liSan + 1, liSan + (len + 1) + 1);
	diffNum = unique(liSan + 1, liSan + (len + 1) + 1) - (liSan + 1);
	int lep = -5e8, rep = 5e8;
	while (rep > lep)
	{
		int mid = (lep + rep + 1) / 2;
		if (getNum(mid) >= chosK)
		{
			lep = mid;
		}
		else
		{
			rep = mid - 1;
		}
	}
	printf("%lld\n", getSum(lep + 1) + (chosK - getNum(lep + 1)) * lep);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

### 主席树（60分）

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>

using namespace std;

typedef long long ll;
inline ll read()
{
    char s;
    ll k=0,base=1;
    while((s=getchar())!='-'&&!(isdigit(s)));
    if(s=='-')base=-1,s=getchar();
    while(isdigit(s)){k=k*10+(s^'0');s=getchar();}
    return k*base;
}
const int maxLen = 5e5 + 10;
int len = 0, regNum = 0, lSize = 0, rSize = 0, diffNum = 0, totNode = 0;
int seq[maxLen] = {}, sum[maxLen] = {}, liSan[maxLen] = {}, gen[maxLen] = {};
//sum[i]表示前 i - 1 个数的和
struct TREE
{
	int lson, rson, num;
	ll sum;
	#define ls(p) tree[p].lson
	#define rs(p) tree[p].rson
	#define num(p) tree[p].num
	#define sum(p) tree[p].sum
} tree[maxLen << 5] = {};
int build(int lVal, int rVal)
{
	int root = ++totNode;
	if (lVal == rVal)
		return root;
	int mid = (lVal + rVal) >> 1;
	ls(root) = build(lVal, mid);
	rs(root) = build(mid + 1, rVal);
	return root;
}
void update(int id)
{
	num(id) = num(ls(id)) + num(rs(id));
	sum(id) = sum(ls(id)) + sum(rs(id));
	return ;
}
int insert(int last, int insVal, int real, int lVal, int rVal)
{
	int root = ++totNode;
	ls(root) = ls(last), rs(root) = rs(last);
	num(root) = num(last) + 1;
	sum(root) = sum(last) + real;
	//这么写的话要把这两句话放在前面
	if (lVal == rVal)
	{
		//这里应该是 num(root) = num(last) + 1，不能直接把他的值赋为1
		return root;
	}
	int mid = (lVal + rVal) >> 1;
	if (insVal <= mid) ls(root) = insert(ls(last), insVal, real, lVal, mid);
	else rs(root) = insert(rs(last), insVal, real, mid + 1, rVal);
	return root;
}
int numQuery(int now, int lVal, int rVal, int ql, int qr)
{
	if (ql <= lVal && rVal <= qr)
	{
		return num(now);
	}
	int mid = (lVal + rVal) >> 1, ret = 0;
	if (ql <= mid) ret += numQuery(ls(now), lVal, mid, ql, qr);
	if (mid + 1 <= qr) ret += numQuery(rs(now), mid + 1, rVal, ql, qr);
	return ret;
}
ll sumQuery(int now, int lVal, int rVal, int ql, int qr)
{
	if (ql <= lVal && rVal <= qr)
		return sum(now);
	int mid = (lVal + rVal) >> 1;
	ll ret = 0;
	if (ql <= mid)
		ret += sumQuery(ls(now), lVal, mid, ql, qr);
	if (mid + 1 <= qr)
		ret += sumQuery(rs(now), mid + 1, rVal, ql, qr);
	return ret;
}
inline int getNum(int val)
{
	int ret = 0;
	for (int seqI = 1; seqI <= len; ++seqI)
	{
		int lep = std::max(1, seqI - rSize + 1), rep = std::min(len, seqI - lSize + 1);
		//这里应该是 seqI - rSize + 1是左端点
		if (lep > rep) continue;
		int lim = upper_bound(liSan + 1, liSan + diffNum + 1, sum[seqI + 1] - val) - liSan;
		--lim;
		if (lim == 0) continue;
		ret += numQuery(gen[rep], 1, diffNum, 1, lim) - numQuery(gen[lep - 1], 1, diffNum, 1, lim);
	}
	return ret;
}
ll getWrongAns(int val)
{
	ll ret = 0;
	for (int seqI = 1; seqI <= len; ++seqI)
	{
		int rep = std::min(len, seqI - lSize + 1), lep = std::max(1, seqI - rSize + 1);
		if (lep > rep) continue;
		int lim = upper_bound(liSan + 1, liSan + diffNum + 1, sum[seqI + 1] - val) - liSan;
		--lim;
		if (lim == 0) continue;
		ret += sum[seqI + 1] * (numQuery(gen[rep], 1, diffNum, 1, lim) - numQuery(gen[lep - 1], 1, diffNum, 1, lim))
			 - sumQuery(gen[rep], 1, diffNum, 1, lim) + sumQuery(gen[lep - 1], 1, diffNum, 1, lim);
		//sum[seqI + 1]要乘以一个系数，就是这个区间选了多少次
		//发现了一个问题，把类似的问题也改掉，就是 getNum部分和这部分基本完全一样，但是开始 getNum 部分有些错误
	}
	return ret;
}

int main()
{
	scanf("%d%d%d%d", &len, &regNum, &lSize, &rSize);
	for (int seqI = 1; seqI <= len; ++seqI)
	{
//			scanf("%d", &seq[seqI]);
		seq[seqI] = read();
		sum[seqI + 1] = sum[seqI] + seq[seqI];
	}
	for (int seqI = 1; seqI <= len + 1; ++seqI)
	{
		liSan[seqI] = sum[seqI];
	}
	sort(liSan + 1, liSan + len + 1);
	diffNum = unique(liSan + 1, liSan + (len + 1) + 1) - (liSan + 1);
	build(1, diffNum);
	gen[0] = 1;
	for (int seqI = 1; seqI <= len + 1; ++seqI)
	{
		int insVal = lower_bound(liSan + 1, liSan + diffNum + 1, sum[seqI]) - liSan;
		gen[seqI] = insert(gen[seqI - 1], insVal, sum[seqI], 1, diffNum);
		//这里要写 gen[seqI] = ！！！否则就炸了！！！
	}
	int lep = -5e8, rep = 5e8;
	while (rep > lep)
	{
		int mid = (lep + rep + 1) / 2;
		if (getNum(mid) >= regNum)
		{
			lep = mid;
		}
		else
		{
			rep = mid - 1;
		}
	}
	printf("%lld\n", getWrongAns(lep + 1) + (regNum - getNum(lep + 1)) * lep);
	return 0;
}
```

## 正解

设$f(i,a,b)$表示结尾在$i$处，选择的起点在$[a,b]$之间的最大值。现在用一个堆，以这个区间的最大值为关键字排序。每次取出堆顶，然后将堆顶$f(j,a_0,b_0)$分裂为两块（如果取到最大值的点为$k$），那么将分裂为$f(j,a_0,k-1)$与$f(j,k+1,b_0)$两个部分。这样就可以保证不会选择重复的两个区间了。

## 知识点

+ 用一个数据结构前先想想能不能用更简单的数据结构，并且要结合实现的问题进行观察，最好画出来。（比如这道题根本用不着主席树）。
+ 当我们遇见一个和**连续一段区间**相关的，并且把区间展开成好几段就会超时/超空间的，**考虑把这段区间记录成一块**。

---

## 作者：Wyxrg (赞：1)

题意简述：

1.给你一个序列 $n$，求出每一个长度为 l~r 的子序列数值的和。

2.取出前 $k$ 大个，累及总和。

------------
###  Solution：
容易想到，求静态子序列之和，可以使用前缀和，区间 l~r 和即为 $pre[r]-pre[l-1]$。

于是可以暴力求出每个的和然后排序累加，但这样复杂度过高，会 TLE。

再想想，对于每一个超级和弦的起始点 k，终点的范围在 k+l-1~k+r-1 之间。

那么我们若能找出每一个 k 中，对应的终点中的最大值，不断取出最大值不就可以了吗？

~~显然是不可行的。~~

理由1：k 可能大于 $n$，即取完不够。

理由2：如图：
![](https://s2.ax1x.com/2019/11/29/QEuHr8.png)

当 1~3,2~3 取完时，1~2 显然相对于其他解更优。

所以，当我们累加一个节点 mid 时，应考虑 l~mid-1，mid+1~r，将其加入候选队列，以避免漏掉更优解。

由此可见，我们需要维护 1.前缀和 2.RMQ 3.当前最优解（优先队列）。

同时，优先队列中维护五个元素：当前选取节点编号，当前的范围 l~r，当前的最大值，当前的超级和弦的来源。

注意：st 表维护的是前缀和最大值，优先队列则是区间和最大值。

我的写法貌似和其他人不大一样（~~跑得慢~~）代码内有注释：
```cpp
#include<bits/stdc++.h>
using namespace std;

struct hx
{
	long long now,lk,rk,val,pos;//当前选取编号，l~r，max，和弦来源
	hx();
	hx(long long _now,long long _lk,long long _rk,long long _val,long long _pos):now(_now),lk(_lk),rk(_rk),val(_val),pos(_pos){};
	bool operator < (hx x) const
	{
        return val<x.val;
    }
};//和弦结构体，并重载<，按值排序
priority_queue<hx> q;
long long n,k,l,r,st[23][2000500][2],hxt[2000500],ans;//st表，第三维0是维护区间前缀和最大值，1是区间前缀和最大值编号
//一开始没开long long错了，一气之下想都没想全开成long long
void st_pre()
{
	for(int i=1;i<=20;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(st[i-1][j][0]<st[i-1][j+(1<<(i-1))][0]) st[i][j][0]=st[i-1][j+(1<<(i-1))][0],st[i][j][1]=st[i-1][j+(1<<(i-1))][1];
			else st[i][j][0]=st[i-1][j][0],st[i][j][1]=st[i-1][j][1];
		}//在更新区间前缀和最大值时同时更新最大值位置（稍微改下模板）
	}
}//st表预处理

int main()
{
	scanf("%lld %lld %lld %lld",&n,&k,&l,&r);//读入
	for(int i=1;i<=n;i++) scanf("%lld",&st[0][i][0]),st[0][i][0]+=st[0][i-1][0],st[0][i][1]=i;//维护初始前缀和最大值与初始位置
	st_pre();
	for(int i=1;i<=20;i++) hxt[1<<i]++;
	for(int i=1;i<=n;i++) hxt[i]+=hxt[i-1];//O(1)询问预处理
	for(int i=1;i<=n-l+1;i++)
	{
		long long ll=i+l-1,rr=min(n,i+r-1),len=rr-ll+1;//左，右，长度，注意范围取min
		long long max1=st[hxt[len]][ll][0],max2=st[hxt[len]][rr-(1<<hxt[len])+1][0],id1=st[hxt[len]][ll][1],id2=st[hxt[len]][rr-(1<<hxt[len])+1][1];//这四个变量其实就是st表中两段区间内的前缀和最大值与编号，取max
		if(max1<max2) q.push(hx(id2,ll,rr,max2-st[0][i-1][0],i));
		else q.push(hx(id1,ll,rr,max1-st[0][i-1][0],i));//插入大的，同时用前缀和最大值减去起始点-1，得到序列和
	}
	int js=0;
	while(js<k)
	{
		js++;
		ans=ans+q.top().val;//更新
		long long ll=q.top().lk,rr=q.top().rk,mid=q.top().now,poss=q.top().pos;//左端点，右端点，上次取的位置，原本起点
		if(mid>ll)//左边有可更新插入的
		{
			mid--;//因为不能重复取mid，故减一
			long long len=mid-ll+1,max1=st[hxt[len]][ll][0],max2=st[hxt[len]][mid-(1<<hxt[len])+1][0],id1=st[hxt[len]][ll][1],id2=st[hxt[len]][mid-(1<<hxt[len])+1][1];
			if(max1<max2) q.push(hx(id2,ll,mid,max2-st[0][poss-1][0],poss));
			else q.push(hx(id1,ll,mid,max1-st[0][poss-1][0],poss));//插入堆
			mid++;//一定要记得回来，下面可能还用到
		}
		if(rr>mid)//同上，右边情况
		{
			mid++;
			long long len=rr-mid+1,max1=st[hxt[len]][mid][0],max2=st[hxt[len]][rr-(1<<hxt[len])+1][0],id1=st[hxt[len]][mid][1],id2=st[hxt[len]][rr-(1<<hxt[len])+1][1];
			if(max1<max2) q.push(hx(id2,mid,rr,max2-st[0][poss-1][0],poss));
			else q.push(hx(id1,mid,rr,max1-st[0][poss-1][0],poss));
			mid--;
		}
		q.pop();
	}
	printf("%lld",ans);//输出结果
	return 0;
}
```
题解清楚么？

return 0；

---

## 作者：whyl (赞：1)

我要解出一个

i l r x v的 组

我可以查找的是一个最大值

并且我要知道他在哪个位置

查最大值ST表即可

但是查找位置的话

st表是不是也可以直接维护处位置来

答案是肯定的

只要开一个数组记录（一个2的j次方的最大值）

在哪一个位置即可

贪心每次取出最大的并将最大的分裂成为

i l x-1 posl vl

i x+1 r pos2 vr

即可

最后不要忘记要开long long

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

inline int read(){
	int x=0,f=1;
	char p=getchar();
	while(!isdigit(p)){
		if(p=='-') f=-1;
		p=getchar();
	}
	while(isdigit(p)) x=(x<<3)+(x<<1)+p-48,p=getchar();
	return x*f;
}

const int maxn=5e5+5;

struct node{
	int start,l,r,val,pos;
	bool operator <(const node x)const{
		return x.val>val;
	}
};

int f[maxn][21],p[maxn][21],n,m,L,R,ans,x[maxn],sum[maxn];

priority_queue<node> q;

inline void pre_work(){
	for(int j=1;j<=19;j++)
		for(int i=1;i+(1<<j)-1<=n;i++){
			if(f[i][j-1]<f[i+(1<<j-1)][j-1]){
				f[i][j]=f[i+(1<<j-1)][j-1];
				p[i][j]=p[i+(1<<j-1)][j-1];
			}
			else{
				f[i][j]=f[i][j-1];
				p[i][j]=p[i][j-1];
			}
		}
}

inline pair<int,int> query(int l,int r){
	int t=log2(r-l+1);
	pair<int,int> pi;
	if(f[l][t]<f[r-(1<<t)+1][t]){
		pi.first=f[r-(1<<t)+1][t];
		pi.second=p[r-(1<<t)+1][t];
	} 
	else{
		pi.first=f[l][t];
		pi.second=p[l][t];
	}
	return pi;
}

signed main(){
	n=read();m=read();L=read();R=read();
	for(int i=1;i<=n;i++) x[i]=read(),p[i][0]=i;
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+x[i];
	for(int i=1;i<=n;i++) f[i][0]=sum[i];
	pre_work();
	for(int i=1;i<=n;i++){
		if(i+L-1<=n){
			int l=i+L-1,r=min(i+R-1,n);
			pair<int,int> pi=query(l,r);
			q.push((node){i,l,r,pi.first-sum[i-1],pi.second});
		}
		else break;
	}
//	cout<<"%^&"<<endl;
	while(m--){
	//	cout<<ans<<endl;
		node a=q.top();
		q.pop();
		ans+=a.val;
		if(a.pos==a.l){
	//		cout<<"$%^"<<endl;
			if(a.l==a.r) continue;
			pair<int,int> pi=query(a.l+1,a.r);
	//		cout<<":"<<endl;
			q.push((node){a.start,a.l+1,a.r,pi.first-sum[a.start-1],pi.second});
		}
		else if(a.pos==a.r){
			if(a.l==a.r) continue;
			pair<int,int> pi=query(a.l,a.r-1);
			q.push((node){a.start,a.l,a.r-1,pi.first-sum[a.start-1],pi.second});
		}
		else{
			pair<int,int> pi=query(a.l,a.pos-1);
			q.push((node){a.start,a.l,a.pos-1,pi.first-sum[a.start-1],pi.second});
			pi=query(a.pos+1,a.r);
			q.push((node){a.start,a.pos+1,a.r,pi.first-sum[a.start-1],pi.second});	
		}
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：VPYEKINDAR (赞：1)

给大家一个通俗一点的代码，堆中元素意义：val为该选取方案的值，mid为选取的右边端点，l，r为限制在l-r取这个mid，ori为左端点位置-1
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[500100],st[500100][21];
long long qr(int l,int r){
	long long mx=-1;
	int j=log2(r-l+1);
	if(a[st[l][j]]>a[st[r-(1<<j)+1][j]])return st[l][j];
	else return st[r-(1<<j)+1][j];
}
int n,k,l,r;
struct p{
	long long ori,l,r,val,mid;
bool operator<(const p &a)const{
	return a.val>val;
}
};
priority_queue<p> q;
int main()
{
	cin>>n>>k>>l>>r;long long tt;
	for(int i=1;i<=n;i++){
		cin>>tt;a[i]=a[i-1]+tt;
		st[i][0]=i;
	}
	for(int i=1;(1<<i)<=n;i++){
		for(int j=1;j+(1<<i)-1<=n;j++){
		//printf("%d %d\n",i,j);
		if(a[st[j][i-1]]>a[st[j+(1<<(i-1))][i-1]])
		st[j][i]=st[j][i-1];
		else st[j][i]=st[j+(1<<(i-1))][i-1];
		}
	}long long ans=0;
	for(int i=0;i<=n;i++){
		int z=i+l,zz=min(n,i+r);
				if(z>n)break;
		//printf("%lld\n",a[qr(z,zz)]-a[i]);
	p t;
	t.ori=i;t.val=a[qr(z,zz)]-a[i];t.l=z,t.r=zz;t.mid=qr(z,zz);
	q.push(t);
	}//push pile 
	while(k--){
		p d=q.top();q.pop();
		ans+=d.val;
		p j,k;
		if(d.mid-1>=d.l&&d.mid-1<=d.r){
			j.l=d.l;j.r=d.mid-1;j.ori=d.ori;j.mid=qr(j.l,j.r);j.val=a[j.mid]-a[j.ori];
		q.push(j);
		}
		if(d.mid+1>=d.l&&d.mid+1<=d.r){
			k.l=d.mid+1;k.r=d.r;k.ori=d.ori;k.mid=qr(k.l,k.r);k.val=a[k.mid]-a[k.ori];
		q.push(k);
		}
	}
	cout<<ans;
}```

---


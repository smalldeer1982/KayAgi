# [ZJOI2018] 胖

## 题目背景

Cedyks 是九条可怜的好朋友（可能这场比赛公开以后就不是了），也是这题的主人公。

## 题目描述

Cedyks 是一个富有的男孩子。他住在著名的 The Place（宫殿）中。

Cedyks 是一个努力的男孩子。他每天都做着不一样的题来锻炼他的 The Salt（灵魂）。

这天，他打算在他的宫殿外围修筑一道城墙，城墙上有 $n$ 座瞭望塔。你可以把城墙看做一条线段，瞭望塔是线段上的 $n$ 个点，其中 $1$ 和 $n$ 分别为城墙的两个端点。其中第 $i$ 座瞭望塔和第 $i + 1$ 座瞭望塔的距离为 $w_i$，他们之间的道路是双向的。

城墙很快就修建好了，现在 Cedyks 开始计划修筑他的宫殿到城墙的道路。因为这题的题目名称，Cedyks 打算用他的宫殿到每一个瞭望塔的最短道路之和来衡量一个修建计划。

现在 Cedyks 手上有 $m$ 个设计方案，第 $k$ 个设计方案会在宫殿和瞭望塔之间修建 $T_k$ 条双向道路，第 $i$ 条道路连接着瞭望塔 $a_i$，长度为 $l_i$。

计算到每一个瞭望塔的最短路之和是一个繁重的工程，本来 Cedyks 想用广为流传的 SPFA 算法来求解，但是因为他的 butter（缓冲区）实在是太小了，他只能转而用原始的贝尔福特曼算法来计算，算法的流程大概如下：

1. 定义宫殿是 $0$ 号点，第 $i$ 个瞭望塔是 $i$ 号点，双向边 $(u_i, v_i, l_i)$ 为一条连接 $u_i$ 和 $v_i$ 的双向道路。令 $d$ 为距离数组，最开始 $d_0 = 0, d_i = 10^{18}(i ∈ [1, n])$。
2. 令辅助数组 $c = d$。依次对于每一条边 $(u_i, v_i,w_i)$ 进行增广，$c_{u_i} = \min(c_{u_i} , d_{v_i} + w_i)$，$c_{v_i} = \min(c_{v_i} , d_{u_i} + w_i)$。
3. 令 $t$ 为 $c$ 和 $d$ 中不一样的位置个数，即令 $S = \{i|c_i≠d_i\}$，则 $t = |S|$。若 $t = 0$，说明 $d$ 就是最终的最短路，算法结束。否则令 $d = c$，回到第二步。

因为需要计算的设计方案实在是太多了，所以 Cedyks 雇佣了一些人来帮他进行计算。为了避免这些人用捏造出来的数据偷懒，他定义一个设计方案的校验值为在这个方案上运行贝尔福特曼算法每一次进入第三步 $t$ 的和。他会让好几个雇佣来的人计算同样的设计方案，并比对每一个人给出的校验值。

你是 Cedyks 雇佣来的苦力之一，聪明的你发现在这个情形下计算最短路的长度的和是一件非常简单的事情。但是寄人篱下不得不低头，你不得不再计算出每一个方案的校验值来交差。

## 说明/提示

### 样例解释

对于第一个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10^{18},2,10^{18},10^{18},10^{18}] \rightarrow$ $[0,4,2,5,10^{18},10^{18}] \rightarrow [0,4,2,5,6,10^{18}] \rightarrow [0,4,2,5,6,10]$。

因此校验值为 $1+2+1+1=5$。

对于第二个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},10^{18},10,10^{18}] \rightarrow$ $[0,1,3,11,10,14] \rightarrow [0,1,3,6,10,14] \rightarrow [0,1,3,6,7,14] \rightarrow [0,1,3,6,7,11]$。

因此校验值为 $2+3+1+1+1=8$。

对于第三个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},1,10^{18},1] \rightarrow [0,1,3,1,2,1]$。

因此校验值为 $3+1+1=5$。

对于第四个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10,100,10^{18},10^{18},1] \rightarrow$ $[0,10,12,103,5,1] \rightarrow [0,10,12,6,5,1] \rightarrow [0,10,9,5,1]$。

因此校验值为 $3+3+1+1=8$。

对于第五个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,1,1,1,1]$

因此校验值为 $5$。

### 数据范围

测试点|$n$|$m$|$K$|其他约定
-|-|-|-|-
1,2|$\le 1000$|$\le 1000$|$\le 100$|无
3,4|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 100$|无
5,6|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$1 \le w_i,l_i \le 50$
7,8,9,10|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|无


对于 $100\%$ 的数据，保证每个设计方案 $a_i$ 两两不同且 $1\le a_i\le n$。  
对于 $100\%$ 的数据，保证 $1\le w_i,l_i\le 10^9,1\le\sum K\le 2\times 10^5$。

感谢 @Xeonacid 提供题面

## 样例 #1

### 输入

```
5 5
2 3 1 4
1 2 2
2 1 1 4 10
3 1 1 3 1 5 1
3 1 10 2 100 5 1
5 1 1 2 1 3 1 4 1 5 1```

### 输出

```
5
8
5
8
5```

# 题解

## 作者：Ameyax (赞：16)

[先放博客](http://blog-wayne.com/2018/05/02/329/)，~~然后直接跑Bellman-Ford。~~

换个角度，考虑每一个修路的点能更新到哪一些点，显然这是一个包含自己的连续区间。

那么对于一个修路的点$X$，分别二分左右两个端点$L,R$，以$L$为例，令$l=X-L$，如果$[L-l,L+l]$这个区间内不存在点使得从这里出发到$L$小于从$X$出发到$L$，那么这个$L$就是可行的。

答案就是求$\sum\limits_{i=1}^{K}(R_i-L_i+1)$

还要考虑边界问题防止重复计算，比如相同距离编号相近的更优先，相同距离编号差的绝对值也相同就左边优先。

rmq的实现方法也很重要，线段树很慢（没卡过去），我写的是用离散化后的st表。虽然两个复杂度都是$nlog^2n$的。还有二分查找用不要用库函数，时间有手写的两倍。

```cpp
#include <bits/stdc++.h>
using namespace std;
int read() {
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
#define ll long long

const ll Max = 200033;
const ll inf = 9999999999999999ll;
ll n, m, now, K;
ll dis[Max], pos[Max], len[Max], Ans;
int bin[20], Log[Max];

struct Data {
    ll mn, id;
    Data() {}
    Data(ll a, ll b) {
        mn = a, id = b;
    }
};

void init() {
    bin[0] = 1;
    for (int i = 1; i <= 18; i++) {
        bin[i] = bin[i - 1] << 1;
        Log[bin[i]] = i;
    }
    for (int i = 1; i < Max; i++)
        if (!Log[i]) Log[i] = Log[i - 1];
}

struct ST {
    ll d[Max][18];
    void init() {
    	for (int j = 1; j <= Log[K]; j++)
    		for (int i = 1; i <= K; i++)
    			d[i][j] = min(d[i][j - 1], d[i + bin[j - 1]][j - 1]);
    }
    ll query(int L, int R) {
    	int len = R - L + 1;
    	return min(d[L][Log[len]], d[R - bin[Log[len]] + 1][Log[len]]);
    }
} st[2];

int tmp[Max], t[Max];

int lower(int V) {
    int L = 1, R = K, re = K + 1;
    while (R >= L) {
        int mid = (L + R) >> 1;
        if (tmp[mid] < V) L = mid + 1;
        else R = mid - 1, re = mid;
    }
    return re;
}

int upper(int V) {
    int L = 1, R = K, re = K + 1;
    while (R >= L) {
        int mid = (L + R) >> 1;
        if (tmp[mid] <= V) L = mid + 1;
        else R = mid - 1, re = mid;
    }
    return re;
}

void solve() {
    for (int i = 1; i <= K; i++)
        tmp[i] = pos[i];
    sort(tmp + 1, tmp + K + 1);
    for (int i = 1; i <= K; i++)
        t[tmp[i]] = i;
    for (int i = 1; i <= K; i++) {
    	st[0].d[t[pos[i]]][0] = len[i] - dis[pos[i]];
    	st[1].d[t[pos[i]]][0] = len[i] + dis[pos[i]];
    }
    st[0].init(), st[1].init();
    Ans = 0;
    for (int i = 1; i <= K; i++) {
        int ql = 1, qr = pos[i] - 1, L = pos[i], R = L;
        while (qr >= ql) {
            bool flag = 1;
            int mid = (ql + qr) >> 1;
            ll nowdis = len[i] + dis[pos[i]] - dis[mid], idx = pos[i] - mid;
            ll dl = inf, dr = dl;
            
            int qql = lower(max(1ll, mid - idx));
            int qqr = upper(mid) - 1;
            if (qql <= qqr) dl = st[0].query(qql, qqr);
            
        	qql = lower(mid);
            qqr = upper(pos[i] - 1) - 1;
            if (qql <= qqr) dr = st[1].query(qql, qqr);
            
            if (dl + dis[mid] <= nowdis) flag = 0;
            if (dr - dis[mid] <= nowdis) flag = 0;
            if (flag) qr = mid - 1, L = mid;
            else ql = mid + 1;
        }
        
        ql = pos[i] + 1, qr = n;
        while (qr >= ql) {
            bool flag = 1;
            int mid = (ql + qr) >> 1;
            ll nowdis = len[i] + dis[mid] - dis[pos[i]], idx = mid - pos[i];
            ll dl = inf, dr = dl;
            
            int qql = lower(mid);
            int qqr = upper(min(mid + idx - 1, n)) - 1;
            if (qql <= qqr) dr = st[1].query(qql, qqr);
            //cout << "fuck: " << mid << ' ' << dl << ' ' << dr << endl;
            
            qql = lower(pos[i] + 1);
            qqr = upper(mid) - 1;
            if (qql <= qqr) dl = st[0].query(qql, qqr);
            
            if (dl + dis[mid] <= nowdis) flag = 0;
            if (dr - dis[mid] <= nowdis) flag = 0;
            if (mid + idx <= n) {
            	qqr = upper(min(mid + idx, n)) - 1;
            	if (tmp[qqr] == mid + idx)
            		if (st[1].d[qqr][0] - dis[mid] < nowdis)
            			flag = 0;
        	}
            if (flag) ql = mid + 1, R = mid;
            else qr = mid - 1;
        }
        Ans += (R - L + 1);
    }
    printf("%lld\n", Ans);
}

signed main() {
    init();
    n = read(), m = read();
    for (int i = 2; i <= n; i++)
        dis[i] = dis[i - 1] + read();
    for (int i = 1; i <= m; i++) {
        K = read();
        for (int j = 1; j <= K; j++)
            pos[j] = read(), len[j] = read();
        solve();
    }
}
```

---

## 作者：Labelray (赞：11)

[Blog](http://labelray.top/2018/10/05/zjoi2018%e8%83%96/)

在题目中的图上跑Bellman-Ford的时候，有一个很有趣的性质，手玩一下就可以知道，对于任意一个点$m$，如果$d=|a_{i}-m|$，$[m-d, m+d]$中没有比从点$0$经过点$a_{i}$到达点$m$更优的点，那么点$m$必定会被从$0$开始经过点$a_{i}$更新。、

所以对于每个点$a_{i}$，可以采用二分查找的方法很容易的找到被他更新过的区间$[l, r]$。

其中考虑点$0$经过点$a_{i}$到点$x$的距离怎么求，设$dis_{i}$为点$1$到点$i$的距离，如果$a_{i}$在$x$的左边，那么就是$dis_{x}+(l_{i}-dis_{a_{i}})$，如果$a_{i}$在$x$的右边，那么就是$-dis_{x}+(l_{i}+dis_{a_{i}})$。

所以开两个ST表分别维护$l_{i}+dis_{a_{i}}$，$l_{i}-dis_{a_{i}}$就好啦

这样的话时间复杂度就是$O(n\log^{2}n)$

ST表中记得是按$a_{i}$的$i$存储而不是按每个位置$i$存储，也就是说ST表的大小是$K$而不是$n$，否则时间复杂度就会是$O(n\cdot m\log^{2} n)$了

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
 
struct Data{
    int p;
    long long l;
    bool operator <(const Data &_)const{
        return p<_.p;
    }
}a[200010];
int n, m, K;
long long dis[200010];
 
namespace ST{
    long long st1[200010][18], st2[200010][18];
 
    void init(){
        std::sort(a+1, a+K+1);
        for(int i=1; i<=K; i++){
            st1[i][0]=a[i].l-dis[a[i].p];
            st2[i][0]=a[i].l+dis[a[i].p];
        }
        for(int j=1; j<=17; j++)
            for(int i=1; i<=K-(1<<j)+1; i++){
                st1[i][j]=std::min(st1[i][j-1], st1[i+(1<<(j-1))][j-1]);
                st2[i][j]=std::min(st2[i][j-1], st2[i+(1<<(j-1))][j-1]);
            }
    }
     
    int findl(int x){
        Data _; _.p=x;
        return std::lower_bound(a+1, a+K+1, _)-a;
    }
     
    int findr(int x){
        Data _; _.p=x;
        return std::upper_bound(a+1, a+K+1, _)-a-1;
    }    
    long long query1(int l, int r){
        if(l>r) std::swap(l, r);
        l=std::max(1, l), r=std::min(r, n);
        l=findl(l), r=findr(r);
        if(l>r)  return 0x3f3f3f3f3f3f3f3f;
        int lim=log2(r-l+1);
        return std::min(st1[l][lim], st1[r-(1<<lim)+1][lim]);
    }
 
    long long query2(int l, int r){
        if(l>r) std::swap(l, r);
        l=std::max(1, l), r=std::min(r, n);
        l=findl(l), r=findr(r);
        if(l>r)  return 0x3f3f3f3f3f3f3f3f;
        int lim=log2(r-l+1);
        return std::min(st2[l][lim], st2[r-(1<<lim)+1][lim]);
    }
}
 
bool check1(int p, int x){
    if(x==p)    return true;
    long long qwq1=ST::query1(2*x-p+1, x)+dis[x];
    long long qwq2=ST::query2(x, p-1)-dis[x];
    long long mst=ST::query2(p, p)-dis[x];
    if(qwq1<=mst || qwq2<=mst)  return false;
    if(2*x-p>=1) return ST::query1(2*x-p, 2*x-p)+dis[x]>mst;
    return true;
}
 
bool check2(int p, int x){
    if(x==p)    return true;
    long long qwq1=ST::query1(p+1, x)+dis[x];
    long long qwq2=ST::query2(x, 2*x-p-1)-dis[x];
    long long mst=ST::query1(p, p)+dis[x];
    if(qwq1<=mst || qwq2<=mst)  return false;
    if(2*x-p<=n) return ST::query2(2*x-p, 2*x-p)-dis[x]>=mst;
    return true;
}
 
int solve1(int p){
    int l=1, r=p, ans=p;
    while(l<=r){
        int mid=(l+r)/2;
        if(check1(p, mid))  r=mid-1, ans=mid;
        else                l=mid+1;
    }
    return ans;
}
 
int solve2(int p){
    int l=p, r=n, ans=p;
    while(l<=r){
        int mid=(l+r)/2;
        if(check2(p, mid))  l=mid+1, ans=mid;
        else                r=mid-1;
    }
    return ans;
}
 
int main(){
    scanf("%d%d", &n, &m);
    for(int i=2; i<=n; i++){
        scanf("%lld", &dis[i]);
        dis[i]+=dis[i-1];
    }
    while(m--){
        scanf("%d", &K);
        for(int i=1; i<=K; i++)
            scanf("%d%lld", &a[i].p, &a[i].l);
        ST::init();
        long long ans=0;
        for(int i=1; i<=K; i++){
            ans+=1LL*(solve2(a[i].p)-solve1(a[i].p)+1);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：GK0328 (赞：4)

膜拜[$\color{black} \text{z} \color{red} \text{houchenyuan}$](https://www.luogu.com.cn/user/87416)秒杀这道题。

### 线段树

我们可以观察一下Bellman-Ford算法在这张图上是如何进行松弛的，对于一个拥有从$0$号点来的边的瞭望塔$a_i$来说，它在第一步一定会被边$0-u$松弛，随后向两边扩张，直到遇到阻碍后停止，形成一段$a_i$松弛过的区间，这个区间的边界之后可能被两边的瞭望塔重新松弛。

我们发现，如果我们能够对于每一个$a_i$，找到对应的一段区间，那么我们就可以把每个瞭望塔的贡献全部计算出来，从而得到答案。

我们可以二分答案，然后判断是否合法，对于一个$a_i$，我们通过二分求出其左右边界，先看如何处理左边界：

假设我们二分到的区间为$[g,a_i]$，我们需要保证两个条件：

$1.$$a_i$不能被区间$[g,a_i)$中的瞭望塔拦截。

$2.$$a_i$到达$g$点的路程小于**在它之前**从$g$左侧瞭望塔到达$g$点的路程。

直接处理第一个条件并不容易，但是我们可以利用第一个条件计算出二分边界，就可以丢掉这个限制。

令$s_k=\sum_{i=1}^{k-1} w_i$，我们可以利用$s_i-s_j$表示$i,j$之间的距离。

对于一个瞭望塔$a_j$，如果$j$不会拦截$i$，那么就满足：

$$
l_i+s_i-s_j<l_j
$$
$$
l_i+s_i<l_j+s_j
$$

我们用一棵线段树维护区间$l_i+s_i$的最小值（无瞭望塔处设为$+\infty$），然后利用倍增计算出二分边界。

然后我们就可以二分了，同时判断第二个条件是否成立。首先，要想抢夺$a_i$对$g$的控制，就必须比$a_i$先到达$g$，那么对于$g$有影响的区间就是$[\max(1,g-(u-g)),g]$，对于瞭望塔$a_j$，满足：

$$
l_i+s_i-s_g<l_j+s_g-s_j
$$
$$
l_i+s_i-2s_g<l_j-s_j
$$

再利用一棵线段树维护区间$l_i-s_i$最小值即可。

对于右边界也是同理的。

还有一个关键点，就是如果存在一个点$j$满足$l_i+dis(i,g)=l_j+dis(j,g)$，那么我们需要注意一下，如果$j$比$i$先到达$g$，我们不必在$i$处计算答案，因为在$j$处一定会计算到。但是如果$i,j$同时到达$g$，且没有其他点会先抢夺到$g$，我们就会漏解，因此我们可以在枚举左边界时对这种情况进行特判。

时间复杂度：$O(n \log^2 n)$。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 200005
#define ll long long
using namespace std;
const ll INF=1919191919191919;
int n,m,k,w[N],a[N],len[N];
ll ans,s[N],vl[N],gl[N];
struct sgt
{
    ll tr[N << 2];
    void build(int p,int l,int r)
    {
        tr[p]=INF;
        if (l==r)
            return;
        int mid(l+r >> 1);
        build(p << 1,l,mid);
        build(p << 1 | 1,mid+1,r);
    }
    void modify(int p,int l,int r,int x,ll y)
    {
        if (l==r)
        {
            tr[p]=y;
            return;
        }
        int mid(l+r >> 1);
        if (x<=mid)
            modify(p << 1,l,mid,x,y); else
            modify(p << 1 | 1,mid+1,r,x,y);
        tr[p]=min(tr[p << 1],tr[p << 1 | 1]);
    }
    void modify(int x,ll y)
    {
        modify(1,1,n,x,y);
    }
    ll calc(int p,int l,int r,int x,int y)
    {
        if (l==x && r==y)
            return tr[p];
        int mid(l+r >> 1);
        if (y<=mid)
            return calc(p << 1,l,mid,x,y); else
        if (x>mid)
            return calc(p << 1 | 1,mid+1,r,x,y); else
            return min(calc(p << 1,l,mid,x,mid),calc(p << 1 | 1,mid+1,r,mid+1,y));
    }
    ll calc(int x,int y)
    {
        return calc(1,1,n,x,y);
    }
}s1,s2;
int calcL(ll s,int I)
{
    if (!I)
        return 1;
    for (int i=20;i>=0;--i)
        if (I-(1 << i)+1>0 && s1.calc(I-(1 <<i)+1,I)>s)
            I-=(1 << i);
    if (!I || vl[I]<=s)
        ++I;
    return I;
}
int calcR(ll s,int I)
{
    if (I>n)
        return n;
    for (int i=20;i>=0;--i)
        if (I+(1 << i)-1<=n && s2.calc(I,I+(1 << i)-1)>s)
            I+=(1 << i);
    if (I>n || gl[I]<=s)
        --I;
    return I;
}
ll calc1(int l,int r)
{
    return s2.calc(l,r);
}
ll calc2(int l,int r)
{
    return s1.calc(l,r);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<n;++i)
        scanf("%d",&w[i]),s[i+1]=s[i]+w[i];
    s1.build(1,1,n),s2.build(1,1,n);
    for (int i=1;i<=n;++i)
        vl[i]=gl[i]=INF;
    while (m--)
    {
        scanf("%d",&k);
        for (int i=1;i<=k;++i)
        {
            scanf("%d%d",&a[i],&len[i]);
            vl[a[i]]=s[a[i]]+len[i];
            gl[a[i]]=-s[a[i]]+len[i];
            s1.modify(a[i],vl[a[i]]);
            s2.modify(a[i],gl[a[i]]);
        }
        ans=0;
        for (int i=1;i<=k;++i)
        {
            int u(a[i]);
            int lim(calcL(vl[u],u-1));
            int l(lim),r(u),g(u);
            while (l<=r)
            {
                int mid(l+r >> 1);
                ll L(s[u]-s[mid]+len[i]-s[mid]);
                int pt(max(1,mid-(u-mid)));
                if (calc1(pt,mid)>L)
                    g=mid,r=mid-1; else
                    l=mid+1;
            }
            ans+=u-g+1;
            if (g!=1)
            {
                --g;
                ll L(s[u]-s[g]+len[i]-s[g]);
                int pt(max(1,g-(u-g)));
                if (g-(u-g)>0 && calc1(pt+1,g)>L && gl[pt]==L)
                    ++ans;
            }
        }
        for (int i=1;i<=k;++i)
        {
            int u(a[i]);
            int lim(calcR(gl[u],u+1));
            if (lim==u)
                continue;
            int l(u+1),r(lim),g(-1);
            while (l<=r)
            {
                int mid(l+r >> 1);
                ll L(-s[u]+s[mid]+len[i]+s[mid]);
                int pt(min(n,mid+(mid-u)));
                if (calc2(mid,pt)>L)
                    g=mid,l=mid+1; else
                    r=mid-1;
            }
            if (g==-1)  
                continue;
            ans+=g-u;
        }
        printf("%lld\n",ans);
        for (int i=1;i<=k;++i)
        {
            vl[a[i]]=gl[a[i]]=INF;
            s1.modify(a[i],INF);
            s2.modify(a[i],INF);
        }
    }
    return 0;
}
```

---

## 作者：james1BadCreeper (赞：2)

从 $0$ 号点到达某一个点后，可以被更新的瞭望塔显然是一段连续的区间，这样我们就可以分别对做右端点进行二分。

设要从 $p$ 更新，这条路的距离为 $l$，到达第 $x$ 个点，那么令 $d=|l-x|$，在 $[x-d,x+d]$ 当中不应该存在距离小于 $p$ 时距离的点。预处理出图上距离的前缀和 $dis$，距离的最小值要分在 $x$ 的左右讨论，在 $x$ 左边时是 $dis_x+(l-dis_p)$，右边时是 $-dis_x+(l+dis_p)$，询问前 ST 表预处理两个信息即可求出距离的最小值（建立大小为 $K$ 的 ST 表，询问的时候直接二分出左右端点的位置）。

注意距离相等时更新顺序的问题，二分右端点时要对 $x+d$ 的位置做一个单独的讨论。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long i64; 
const i64 INF = 2e18; 

int n, m, K; 
struct Node {
    int p, d; 
    bool operator< (const Node &a) const {
        return p < a.p; 
    }
} a[200005];
i64 dis[200005]; 

namespace ST {
    int lg[200005]; i64 f[18][200005], g[18][200005]; 
    i64 query(int op, int l, int r) {
        l = max(1, l); r = min(r, n); 
        Node tmp = {l, 0}; l = lower_bound(a + 1, a + K + 1, tmp) - a; 
        tmp = {r, 0}; r = upper_bound(a + 1, a + K + 1, tmp) - (a + 1);  
        if (l > r) return INF; 
        int k = lg[r - l + 1]; 
        if (op == 1) return min(f[k][l], f[k][r - (1 << k) + 1]); 
        return min(g[k][l], g[k][r - (1 << k) + 1]); 
    }
    void init(void) {
        for (int i = 2; i <= K; ++i) lg[i] = lg[i >> 1] + 1; 
        for (int i = 1; i <= K; ++i) 
            f[0][i] = a[i].d - dis[a[i].p], 
            g[0][i] = a[i].d + dis[a[i].p]; 
        for (int i = 1; i <= lg[K]; ++i)
            for (int j = 1; j + (1 << i) - 1 <= K; ++j)
                f[i][j] = min(f[i - 1][j], f[i - 1][j + (1 << i - 1)]), 
                g[i][j] = min(g[i - 1][j], g[i - 1][j + (1 << i - 1)]); 
    }
}
using namespace ST; 

bool checkl(int p, int x) { // p 更新到 x，x < p
    if (p == x) return 1; int d = abs(p - x); 
    i64 t1 = query(1, x - d, x) + dis[x];
    i64 t2 = query(2, x, x + d - 1) - dis[x]; 
    i64 now = query(2, p, p) - dis[x]; 
    return t1 > now && t2 > now; 
}
int calcl(int p) {
    int L = 0, R = p + 1;
    while (L + 1 != R) {
        int mid = L + R >> 1; 
        if (checkl(p, mid)) R = mid; 
        else L = mid; 
    }
    return R; 
}

bool checkr(int p, int x) { // 从 p 能否更新到 x，x > p
    if (p == x) return 1; int d = abs(p - x); 
    i64 t1 = query(1, x - d + 1, x) + dis[x]; 
    i64 t2 = query(2, x, x + d - 1) - dis[x]; 
    i64 now = query(1, p, p) + dis[x]; 
    if (t1 <= now || t2 <= now) return 0; 
    if (x + d <= n) return query(2, x + d, x + d) - dis[x] >= now; // p 在 x 左边，相等时会先更新
    return 1; 
}
int calcr(int p) {
    int L = p - 1, R = n + 1; 
    while (L + 1 != R) {
        int mid = L + R >> 1; 
        if (checkr(p, mid)) L = mid; 
        else R = mid; 
    }
    return L; 
}

int main(void) {
    scanf("%d%d", &n, &m); 
    for (int i = 2; i <= n; ++i) scanf("%lld", dis + i), dis[i] += dis[i - 1]; 
    while (m--) {
        scanf("%d", &K); 
        for (int i = 1; i <= K; ++i) scanf("%d%d", &a[i].p, &a[i].d); 
        sort(a + 1, a + K + 1); ST::init(); 
        
        i64 ans = 0; 
        for (int i = 1; i <= K; ++i) ans += (calcr(a[i].p) - calcl(a[i].p) + 1); 
        printf("%lld\n", ans); 
    }
    return 0; 
}
```

---

## 作者：行吟啸九州 (赞：2)

本题解所提供的办法，需要多次提交在洛谷上方可$AC$此题。但是实际考场上，用这个办法的叶卓睿大佬当场通过了此题。

说句题外话，$ZJOI2018D1D2$最可做的都是$T2$，[历史](https://www.luogu.com.cn/problem/P4338)那个题我感觉还是需要想一段时间才能想到正解，但是这个题的这个办法却非常好想，可以说是两天最可做的题了。

算法一：用SPFA算法直接模拟这个过程，复杂度$O(n\sum k)$，期望得分$0 - 20$分。

算法二：我们利用人类智慧，模拟这个松弛过程。不难发现其实每次答案就和这选定的k个点有关，即就是用这k个点向左向右去更新其他点，分别统计这$k$个点能更新到多少个点即可。

我们开始的时候预处理每个点到$1$号点的距离为$dep[]$，选定的k个点到宫殿的距离为$dis[]$。不难发现此时$i, j(i < j)$两个点的距离为$dep[j] - dep[i]$。

如果$ki$可以向右更新到$j$这个点，他们的距离为$d$。

那么$ki$与$j$之间的点$l$都要满足
 $dis[ki] + dep[l] - dep[i] < dep[l]$，

$j$到$j + d$的点$p$都要满足$dis[ki] + dep[j] - dep[ki] < dis[p] + dep[p] - dep[j]$。

向左更新也是类似的过程，暴力维护复杂度$O(nmk)$。

算法三：上面那些式子列出来，可以发现这个$d$可以二分，然后用[线段树](https://www.luogu.com.cn/problem/P1083)维护区间最值即可，不会可以点击链接学一下如何线段树维护最值，复杂度$O(n\log ^ 2n)$。

有一个细节，$i$到$j$的距离等于$j$到$k$的距离一样($i < j < k$)，这个$i$和$k$总共会更新$j$一次，但是上面没有统计，你可以强制向右更新的时候统计。

代码有点辣眼睛，请做好心理准备然后再看。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 200005
#define maxt 800005
#define ll long long
#define inf 2003518617518617ll
#define For(i, j, n) for(register int i = j ; i <= n ; ++i)
int k, n, m, v, w, dis[maxn], stk[maxn];
ll ans, c[maxt], t[maxt], dep[maxn];

#define ls x << 1
#define rs x << 1 | 1
#define mid (l + r >> 1)
inline void Cpushup(int x){ c[x] = min(c[ls], c[rs]); }
inline ll Cquery(int x, int l, int r, int ql, int qr){
	if(ql <= l && r <= qr) return c[x];
	ll sum = inf;
	if(ql <= mid) sum = min(sum, Cquery(ls, l, mid, ql, qr));
	if(qr > mid) sum = min(sum, Cquery(rs, mid + 1, r, ql, qr));
	return sum;
}
inline void Crevise(int x, int l, int r, int ql, ll y){
	if(l == r) return c[x] = y, void(); 
	ql <= mid ? Crevise(ls, l, mid, ql, y) : Crevise(rs, mid + 1, r, ql, y);
	Cpushup(x);
}
inline void Tpushup(int x){ t[x] = min(t[ls], t[rs]); }
inline ll Tquery(int x, int l, int r, int ql, int qr){
	if(ql <= l && r <= qr) return t[x];
	ll sum = inf;
	if(ql <= mid) sum = min(sum, Tquery(ls, l, mid, ql, qr));
	if(qr > mid) sum = min(sum, Tquery(rs, mid + 1, r, ql, qr));
	return sum;
}
inline void Trevise(int x, int l, int r, int ql, ll y){
	if(l == r) return t[x] = y, void(); 
	ql <= mid ? Trevise(ls, l, mid, ql, y) : Trevise(rs, mid + 1, r, ql, y);
	Tpushup(x);
}
inline void build(int x, int l, int r){
	if(l == r) return c[x] = t[x] = inf, void();
	build(ls, l, mid), build(rs, mid + 1, r);
	Cpushup(x), Tpushup(x); 
}

inline int Queryl(int x){
	int d = 0, l = 1, r = x - 1;
	while(l <= r){
		if(Tquery(1, 1, n, x - mid, x - 1) > dis[x] + dep[x] && Cquery(1, 1, n, max(1, x - mid * 2), x - mid) > dis[x] + dep[x] - dep[x - mid] * 2) 
				d = mid, l = mid + 1; 
		else r = mid - 1;
	}
	return d;
}
inline int Queryr(int x){
	int d = 0, l = 1, r = n - x;
	while(l <= r){
		if(Cquery(1, 1, n, x + 1, x + mid) > dis[x] - dep[x] && Tquery(1, 1, n, x + mid, min(x + mid * 2 - 1, n)) > dis[x] - dep[x] + dep[x + mid] * 2 && (x + mid * 2 > n || Tquery(1, 1, n, x + mid * 2, x + mid * 2) >= dis[x] - dep[x] + dep[x + mid] * 2))
			d = mid, l = mid + 1;
		else r = mid - 1;
	}
	return d;
} 

int main(){
	scanf("%d %d", &n, &m), build(1, 1, n);
	For(i, 2, n) scanf("%d", &w), dep[i] = dep[i - 1] + w;
	For(i, 1, m){
		scanf("%d", &k), ans = 0;
		For(i, 1, k) scanf("%d %d", &v, &w), stk[i] = v, dis[v] = w, Crevise(1, 1, n, v, w - dep[v]), Trevise(1, 1, n, v, w + dep[v]); 
		For(i, 1, k) ans += Queryl(stk[i]) + Queryr(stk[i]) + 1;
		For(i, 1, k) Crevise(1, 1, n, stk[i], inf), Trevise(1, 1, n, stk[i], inf);
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：良心WA题人 (赞：1)

## 题意

给定一个链和链外面的点，每次询问给出一些连接外面的点和链上的一个点的边，求这个图每个点被松弛次数的和。

## 思路

首先，起点会松弛每个与之相连的点。然后这些点会不断松弛两侧的点直到遇到一个已经被松弛且权值更小的点。

那么每个与起点相连的点会产生的贡献是一个区间，我们需要求出来这个区间。考虑二分答案，若一个点 $x(x\le u)$ 可以被点 $u$ 松弛一次，当且仅当在区间 $[x-(u-x),u]$ 中，没有任何一个点到达 $x$ 的距离更短。

判断可以考虑将区间拆成 $[x-(u-x),x]$ 和 $[x+1,u-1]$ 两个区间分别计算贡献。对于左侧的区间，可以计算前缀和并用 st 表预处理区间最大最小值来计算。以左侧区间为例，每个与起点相连的点 $p$ 到达 $x$ 的距离为 $s_x-s_{p-1}+w_p$，其中 $w_p$ 为这条边的边权。那么我们用 st 表维护 $s_{p-1}-w_p$ 的最大值，则这个点到达 $x$ 的距离最短，与当前点到达 $x$ 的距离比较即可。右边的区间同理。

需要注意，若两个点与 $x$ 的距离相同则在链上更靠近的点会成功松弛 $x$。若仍然相同则钦定左边还是右边松弛即可。

显然二分右端点同理。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int NN=2e5+4;
ll s[NN];
ll minn1[NN][24],minn2[NN][24];
int lg2[NN];
pair<int,ll>p[NN];
ll query1(int l,int r)
{
    if(l>r)
        return 1e18;
    int t=lg2[r-l+1];
    return min(minn1[l][t],minn1[r-(1<<t)+1][t]);
}
ll query2(int l,int r)
{
    if(l>r)
        return 1e18;
    int t=lg2[r-l+1];
    return min(minn2[l][t],minn2[r-(1<<t)+1][t]);
}
int main()
{
    lg2[0]=-1;
    for(int i=1;i<NN;i++)
        lg2[i]=lg2[i>>1]+1;
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=2;i<=n;i++)
    {
        scanf("%lld",&s[i]);
        s[i]+=s[i-1];
    }
    while(m--)
    {
        int k;
        scanf("%d",&k);
        for(int i=1;i<=k;i++)
            scanf("%d%lld",&p[i].first,&p[i].second);
        sort(p+1,p+1+k);
        for(int i=1;i<=k;i++)
        {
            minn1[i][0]=p[i].second-s[p[i].first];
            minn2[i][0]=p[i].second+s[p[i].first];
        }
        for(int i=1;i<=20;i++)
            for(int j=1;j+(1<<i)-1<=k;j++)
            {
                minn1[j][i]=min(minn1[j][i-1],minn1[j+(1<<i-1)][i-1]);
                minn2[j][i]=min(minn2[j][i-1],minn2[j+(1<<i-1)][i-1]);
            }
        ll ans=0;
        for(int i=1;i<=k;i++)
        {
            int L,R,l=1,r=p[i].first;
            while(l<r)
            {
                int mid=l+(r-l)/2;
                int pl=lower_bound(p+1,p+1+i,make_pair(mid-(p[i].first-mid),0ll))-p,pr=lower_bound(p+1,p+1+i,make_pair(mid,0ll))-p;
                ll w=minn2[i][0]-s[mid];
                if(s[mid]+query1(pl,pr-1)>w&&query2(pr,i-1)-s[mid]>w)
                    r=mid;
                else
                    l=mid+1;
            }
            L=l;
            l=p[i].first,r=n;
            while(l<r)
            {
                int mid=l+(r-l+1)/2;
                int pl=lower_bound(p+i,p+1+k,make_pair(mid,0ll))-p,pr=upper_bound(p+i,p+1+k,make_pair(mid+(mid-p[i].first),(ll)1e18))-p-1;
                ll t=1e18;
                if(p[pr].first==mid+(mid-p[i].first))
                {
                    t=minn2[pr][0]-s[mid];
                    pr--;
                }
                ll w=s[mid]+minn1[i][0];
                if(s[mid]+query1(i+1,pl-1)>w&&query2(pl,pr)-s[mid]>w&&t>=w)
                    l=mid;
                else
                    r=mid-1;
            }
            R=l;
            cerr<<L<<' '<<R<<endl;
            ans=(ans+R-L+1);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：XuYueming (赞：0)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P4501)。

**[更好的阅读体验](https://www.cnblogs.com/XuYueming/p/18753770)**。

## 题意简述

给定一个包含 $n$ 个节点的链状无向图，编号为 $1\sim n$，节点 $i$ 和 $i+1$ 之间的边权为 $w_i$。此外，有 $m$ 次互相独立的询问，每个询问添加若干条从 $0$ 号点到某些点的双向边，每条边具有给定的长度。

对于每次询问求，使用 Bellman-Ford 算法计算过程中，每轮的 $t$ 之和，其中 $t$ 是本轮更新的节点数量。

$n, m \leq 2\times10^5$。

## 题目分析

解决一维问题的一个重要的 observation 是找到连续一段区间。这里我们不难发现，每条额外新增的边能够更新到的点是连续的一段区间。那么我们情不自禁地转换计数视角，要求每轮更新结点数量之和，就是每个点被更新次数之和，就是每条新增边更新的结点个数之和。问题转化为求出每一条新增边更新到点的区间，进一步，我们只需要快速求出区间的左右端点。左右本质相同，以下仅考虑求出区间左端点。

不难想到二分出这个左端点，考虑 check 一个 $L$ 是否合法。从新增边连向的点 $p$ 更新到 $L$ 需要 $d=p-L$ 轮。在这 $d$ 轮中，$[L-d,L+d)$ 中连着新增边的点也会更新到 $L$，想要 $p$ 顺利更新到 $L$，就需要保证 $[L-d,L+d)$ 更新后，$p$ 依旧可以进行松弛。对 $w$ 做前缀和为 $l$，令 $e_i$ 表示连向点 $i$ 的新增边长度（没有则为 $+\infty$），那么上述条件可以表示为 $\forall i\in[L-d,L],l_L-l_i+e_i\gt l_p-l_L+e_p$ 与 $\forall i\in[L,L+d),l_i-l_L+e_i\gt l_p-l_L+e_p$，发现只需要维护 $e_i-l_i$ 和 $e_i+l_i$ 的区间最小值即可快速判断。使用 ST 表即可。需要注意到的是，如果两个点在同一时刻尝试松弛某一个点，且尝试松弛的距离相等，那么只有左边的可以更新到它。这个小小特判即可。

ST 表预处理 $\mathcal{O}(n\log n)$，所以先要离散化，令 $c$ 为新增边的条数，做到 $\mathcal{O}(c\log c)$ 预处理和 $\mathcal{O}(c\log n \log c)$ 的时间复杂度。

## 代码

见[我的博客](https://www.cnblogs.com/XuYueming/p/18753770)。

---

## 作者：Corzica (赞：0)

显然，每一个点可能能更新到的点是一个连续的区间。因此我们能够使用二分来确定这个区间的范围。

问题转化为对一个点求出第一个进入的点的范围在 $[l,r]$ 内的最短路，明显可以分成左右两边分别做 rmq 来解决。

时间复杂度 $O(n\log^2n)$。

---


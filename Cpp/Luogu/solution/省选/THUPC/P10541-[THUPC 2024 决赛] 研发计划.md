# [THUPC 2024 决赛] 研发计划

## 题目描述

看到近期若干家大模型创业公司获得高额融资，作为炼丹大师的你心痒难耐，决定入局，亲自下场搞产品。

经过一段时间的梳理，你发现当前共有 $m$ 种产品推出后将会大卖，其中第 $i$ 个产品推出之后预期获得 $g_i$ 的收益。这 $m$ 种产品涉及 $n$ 种技术：共有 $p$ 条技术-产品依赖关系 $(u,v)$ ，表示第 $u$ 个技术是第 $v$ 个产品的前置技术。对于每个产品，你必须获得它的全部前置技术之后才能推出。

对于第 $j$ 个技术，你可以选择花费 $f_j$ 的代价直接从其他公司购买获得，或者花费 $h_j$ 的代价通过研发获得。研发需要一定的条件：给出 $q$ 条技术-技术依赖关系 $(a,b)$ ，表示第 $a$ 个技术是第 $b$ 个技术的前置技术，那么必须在获得了技术 $j$ 的所有前置技术后才能通过研发获得技术 $j$ 。若某个技术没有前置技术，那么你可以直接通过研发获得。保证技术-技术依赖关系构成一个有向无环图，即不会发生循环依赖（自然不会有自环）。

一个方案的收益为推出的产品的收益总和减去获得的技术的代价总和。现在，作为一个商人，你希望研究一些技术、推出一些产品，最大化你获得的收益。为简单起见，你只要输出最大的收益值。

## 说明/提示

最优方案是依次研究技术 1，购买技术 3，研究技术 4，这时我们就能推出产品 1、4、5 了。此时收益为 $(2+8+8)-(1+6+3)=8$。

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
4 5 5 3
2 10 6 7
1 7 5 3
2 2 3 8 8
1 1
2 2
2 3
3 4
4 5
1 2
2 3
3 4```

### 输出

```
8```

# 题解

## 作者：strcmp (赞：2)

我们发现如果没有可以直接购买技术这个条件，那么直接建反图，这题就是一个裸的最大权闭合子图。

但是可以购买技术，稍微难处理了一点。

将超级源汇分别设为 $s,\,t$。我们考虑最大权闭合子图的思路，割掉就是不选。

我们购买相当于从原来的建图中搞出来一个点放到 $s$ 那边的联通块内，然后这个点的后继可以不用管。

肯定考虑将技术 $u$ 拆成入点 $u$ 和出点 $u'$。方便我们决策是自研还是购买。

如果选择自研，可以想到要用 $u'$ 去连接它的前置技术，边权自然是 $+\infty$.

可以想到 $u \to u'$ 的连边必定不是 $h$，否则我们的 $f$ 放到哪都不合适。如果 $u \to u'$ 的连边是 $f$，它被割就相当于我们直接购买了，可以忽略掉其后继结点。至于出点 $u'$ 连向汇点的权值，也就只能是 $h$ 了。

在原来的基础上跑最大权闭合子图即可。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i = a; i <= b; i++)
#define mp make_pair
using namespace std;
typedef long long int ll;
using pii = pair<int, int>;
constexpr int maxn = 1e5 + 10;
const ll top = 114514191981000LL, inf = top * 1000;
struct edge { int to, nxt; ll w; } nd[maxn]; int h[maxn], cnt = 0;
inline void add(int u, int v, ll w) { nd[cnt].nxt = h[u], nd[cnt].to = v, nd[cnt].w = w, h[u] = cnt++; }
inline void addE(int u, int v, ll w) { add(u, v, w); add(v, u, 0); }
int T, s, t, n, m, p, q, cur[maxn], d[maxn], que[maxn], hd = 1, ta = 0; ll sum = 0;
inline int bfs() {
	memset(d, 0x3f, (t + 1) * sizeof(int));
	hd = 1, ta = 0; que[++ta] = t; d[t] = 0;
	while (hd <= ta) {
		int u = que[hd++];
		for (int i = h[u]; ~i; i = nd[i].nxt) {
			int v = nd[i].to;
			if (d[v] > d[u] + 1 && nd[i ^ 1].w) d[v] = d[u] + 1, que[++ta] = v;
		}
	}
	return d[s] < 1e9;
}
ll dfs(int u, ll fl) {
	if (u == t || !fl) return fl; ll nw = fl;
	for (int& i = cur[u]; ~i; i = nd[i].nxt) {
		if (d[u] != d[nd[i].to] + 1 || !nd[i].w) continue;
		ll c = nd[i].w, wv = dfs(nd[i].to, min(fl, c));
		if (!(nd[i].w -= wv, nd[i ^ 1].w += wv, fl -= wv)) return nw;
	}
	if (fl) d[u] = 1e9;
	return nw - fl;
}
inline void Dinic() { while (bfs()) memcpy(cur, h, sizeof(cur)), sum += dfs(s, inf); }
ll f[maxn], H[maxn], g[maxn];
int main() {
	memset(h, -1, sizeof(h));
	scanf("%d%d%d%d", &n, &m, &p, &q); s = 2 * n + m + 1, t = s + 1; ll ans = 0;
	rep(i, 1, n) scanf("%lld", &f[i]), addE(i, i + n, f[i]);
	rep(i, 1, n) scanf("%lld", &H[i]), addE(i + n, t, H[i]);
	rep(i, 1, m) scanf("%lld", &g[i]), addE(s, i + 2 * n, g[i]), ans += g[i];
	for (int i = 1, u, v; i <= p; i++) scanf("%d%d", &u, &v), addE(v + 2 * n, u, inf);
	for (int i = 1, u, v; i <= q; i++) scanf("%d%d", &u, &v), addE(v + n, u, inf); Dinic();
	printf("%lld\n", ans - sum);
	return 0;
}
```

---

## 作者：Larunatrecy (赞：1)

### [[THUPC2024] 研发计划](https://www.luogu.com.cn/problem/P10541)

如果没有 $f$ 的限制就是最大权闭合子图板子，因此我们考虑延续最小割的思路，稍微改一下建图。

对于每个技术 $i$ 拆成入点，出点 $i,i'$，然后连边：

- $i\to i'$，边权为 $f_i$。
- 如果选技术 $i$ 必须要选技术 $j$，连边 $i'\to j$，边权 `inf`。
- 如果选产品 $i$ 必须要选技术 $j$，连边 $i\to j$，边权  `inf`。
- 源点连向产品 $i$，$S\to i$，边权 $g_i$。
- 技术 $i'$ 连向汇点 $T$，边权 $h_i$。

答案就是 $\sum g_i-W$，其中 $W$ 是最小割。

正确性证明：

在这个图中，一个产品点如果和源点连代表选，否则代表不选；

那么对于一个技术 $i$，如果他选，那么它就不能和汇点连通，要么割掉 $i\to i'$（直接购买），要么它的前置技术都被选且 $i'\to T$ 被割掉，产品同理。

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T>inline void read(T &x)
{
    x=0;char c=getchar();bool f=0;
    for(;c<'0'||c>'9';c=getchar())f|=(c=='-');
    for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c-'0');
    x=(f?-x:x);
}
#define int long long
const int inf = 1e12+7;
typedef long long LL;
const int N = 5e5+7;
struct edge
{
    int y,next;
}e[N*2];
int flink[N],t=1;
int f[N*2];
void add(int x,int y,int v)
{
    e[++t].y=y;
    e[t].next=flink[x];
    f[t]=v;
    flink[x]=t;
}
void Link(int x,int y,int v)
{
    add(x,y,v);
    add(y,x,0);
}
int d[N],cur[N];
queue<int> q;
int S,T,tot;
int Extend()
{
    while(!q.empty()) q.pop();
    for(int i=1;i<=tot;i++) d[i]=-1,cur[i]=flink[i];
    q.push(S);
    d[S]=0;
    cur[S]=flink[S];
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=flink[x];i;i=e[i].next)
        {
            int y=e[i].y;
            if(d[y]==-1&&f[i])
            {
                d[y]=d[x]+1;
                if(y==T) return 1;
                q.push(y);
            }
        }
    }
    return 0;
}
int Find(int x,int limit)
{
    if(x==T) return limit;
    int flow=0;
    for(int i=cur[x];i&&flow<limit;i=e[i].next)
    {
        cur[x]=i;
        int y=e[i].y;
        if(d[y]==d[x]+1&&f[i])
        {
            int v=Find(y,min(f[i],limit-flow));
            if(!v) d[y]=-1;
            f[i]-=v;
            f[i^1]+=v;
            flow+=v;
        }
    }
    return flow;
}
int dinic()
{
    int ans=0,flow=0;
    while(Extend())
    {
        while(flow=Find(S,inf))
        {
            ans+=flow;
        }
    }
    return ans;
}
int n,m,P,Q;
int F[N],h[N],g[N];
int id1[N],id2[N],id3[N];
signed main()
{
    read(n);read(m);read(P);read(Q);
    for(int i=1;i<=n;i++)read(F[i]);
    for(int i=1;i<=n;i++)read(h[i]);
    for(int i=1;i<=m;i++)read(g[i]);
    tot=2*n+m;S=++tot;T=++tot;
    for(int i=1;i<=P;i++)
    {
        int x,y;
        read(x);read(y);
        Link(y+2*n,x,inf);
    }
    for(int i=1;i<=Q;i++)
    {
        int x,y;
        read(x);read(y);
        Link(y+n,x,inf);
    }
    LL sum=0;
    for(int i=1;i<=m;i++)sum+=g[i],Link(S,i+n*2,g[i]);
    for(int i=1;i<=n;i++)
    {
        Link(i,i+n,F[i]);
        Link(i+n,T,h[i]);
    }
    cout<<sum-dinic();
    return 0;
}
```

---

## 作者：是青白呀 (赞：1)

不能购买的情况显然是一个最大权闭合子图的板子，对所有的依赖关系建反图即可。为了解决这个问题，我们考虑一下最大权闭合子图的工作原理：把新图划分成两个部分，和源点在一个部分的就是要选的点。先假设选上了所有正权点，当我们选上一个负权点的时候，要切断它和汇点的边，损耗增加；当我们放弃一个正权点的时候，要切断它和源点的连边，损耗也增加，因而最终的答案就是所有正权点的权值和减去新图的最小割。

在这个问题中，我们通过直接购买的方式获得一个技术的操作，放在模型中等价于是在图上割去一条边，将这个点划分到源点的方向去，且该点连边向的所有点都不必须要选。

为了达到分离该点和该点连向的所有点的目的，我们不难想到将一个技术点 $i$ 拆成两个（一个入点和一个出点），原图上连进来的边都连向入点，容量仍为 $\infty$；原图上连出去的边和连向汇点的边都从出点出发，原图上的边容量为 $\infty$，连向汇点的边容量为 $h_i$；入点与出点之间连一条权值为 $f_i$ 的边，表示割去这条边后，这个点就被选到“已拥有”的部分去了，其它点不再对它产生影响。对于产品点，仍然是按照原图上的连边方式连容量为 $\infty$ 的边，从源点向它连容量为 $g_i$ 的边即可。最终用总收益减去该图的最小割即得到答案。

不难发现该图可以表示题目中的所有操作：
1. 割去源点与产品之间的连边，表示放弃得到一个产品的收益。

2. 割去技术点出点与汇点之间的连边，表示研发一个技术，花费 $h_i$，且由于出点直接连向其它技术点，代表这个点所依赖的所有技术都必须拥有。

3. 割去技术点入点与出点之间的连边，表示直接购买一个技术，割开后入点不再与汇点存在任何通路，代表其它点是否选择不影响该点的情况。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second 
#define int long long
using namespace std;
typedef long long ll;
const int N=305,M=40005,mo=1e9+7,inf=1e18+7;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,p,q,tot;
struct edge{
	int to,nxt,val;
}e[M*2];
int fir[N],np=1,st[N];
void add(int x,int y,int w){
	e[++np]=(edge){y,fir[x],w};
	fir[x]=np;
}
int ans=0;
int dep[N];
bool bfs(){
	queue<int>q;
	rep(i,0,tot)
	    dep[i]=0;
    dep[0]=1,q.push(0);
    while(!q.empty()){
    	int x=q.front();
    	q.pop();
    	st[x]=fir[x];
    	for(int i=fir[x];i;i=e[i].nxt){
    		if(!e[i].val)continue;
    		int j=e[i].to;
    		if(dep[j])continue;
    		dep[j]=dep[x]+1,q.push(j);
    	}
    }
    return dep[tot];
}
int dinic(int x,int num){
	if(x==tot)return num;
	int res=num;
	for(int i=st[x];i;i=e[i].nxt){
		int j=e[i].to;
		st[x]=i;
		if(dep[j]!=dep[x]+1||!e[i].val)continue;
		int gnum=dinic(j,min(res,e[i].val));
		e[i].val-=gnum,e[i^1].val+=gnum,res-=gnum;
		if(!res)break;
	}
	return num-res;
}
signed main(){
	read(n),read(m),read(p),read(q);
	tot=2*n+m+1;
	rep(i,1,n){
		int x;
		read(x),add(i,i+n,x),add(i+n,i,0); 
	}
	rep(i,1,n){
		int x;
		read(x),add(i+n,tot,x),add(tot,i+n,0);
	}
	rep(i,1,m){
		int x;
		read(x),ans+=x,add(0,2*n+i,x),add(2*n+i,0,0);
	}
	rep(i,1,p){
		int x,y;
		read(x),read(y),add(y+2*n,x,inf),add(x,y+2*n,0);
	}
	rep(i,1,q){
		int x,y;
		read(x),read(y),add(y+n,x,inf),add(x,y+n,0);
	}
	while(bfs())
	    ans-=dinic(0,inf);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：0)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18224748)

### [P10541 [THUPC2024] 研发计划](https://www.luogu.com.cn/problem/P10541)

首先看上去就比较像流，直接考虑怎么建模。

如果没有 $h$ 就是裸的最大权闭合子图：$S$ 向每个技术连边，每个收益向 $T$ 连边，然后技术指向收益的边连 `inf`，做最小割（割掉的表示支付的代价），答案就是收益之和减去最小割。

现在有了 $h$，要做的大概形如：如果一堆技术全都割掉了和 $S$ 的边，那某个技术代价可以更小。首先要割掉的是 $h$ 或者 $f$，所以两者应当是串联的。然后稍微尝试一下就能发现 $h$ 应该连在前面：

![image.png](https://s2.loli.net/2024/05/31/E3yolhgtwbsk8pI.png)

上图表示 $3,4$ 是 $1$ 的前置，然后 $3$ 是 $5$ 的前置，$2$ 是 $3$ 的前置。可以发现这样建模只有所有前置都被割掉才会割 $h$，否则割的是 $f$，然后跑 `dinic` 即可。

```cpp
	int n,m,X,Y,S,T;
	int cnt=1,head[410],to[100010],nex[100010],v[100010],now[410],d[410];
	inline void Add(int x,int y,int z){to[++cnt]=y,v[cnt]=z,nex[cnt]=head[x],head[x]=cnt;}
	inline void add(int x,int y,int z){Add(x,y,z),Add(y,x,0);}
	queue<int> q;
	inline bool bfs()
	{
		while(!q.empty())q.pop();
		q.e(S),memset(d,0,sizeof(d)),d[S]=1,now[S]=head[S];
		while(!q.empty())
		{
			int nw=q.front();q.pop();
			for(int i=head[nw];i;i=nex[i])
			{
				if(!d[to[i]]&&v[i])
				{
					d[to[i]]=d[nw]+1,now[to[i]]=head[to[i]],q.e(to[i]);
					if(to[i]==T)return 1;
				}
			}
		}
		return 0;
	}
	int dinic(int x,int flow)
	{
		if(x==T)return flow;
		int rest=flow,t;
		for(int i=head[x];i&&rest;i=nex[i])
		{
			now[x]=i;
			if(!v[i]||d[to[i]]!=d[x]+1)continue;
			t=dinic(to[i],min(rest,v[i]));
			if(!t)d[to[i]]=0;
			v[i]-=t,v[i^1]+=t,rest-=t;
		}
		return flow-rest;
	}
	inline void mian()
	{
		read(n,m,X,Y),S=3*n+m+1,T=S+1;int x,y,ans=0;
		for(int i=1;i<=n;++i)read(x),add(S,i,INF),add(i+n,i+n*2,x);
		for(int i=1;i<=n;++i)read(x),add(i,i+n,x);
		for(int i=1;i<=m;++i)read(x),add(3*n+i,T,x),ans+=x;
		while(X--)read(x,y),add(x+n*2,y+n*3,INF);
		while(Y--)read(x,y),add(x+n*2,y+n,INF);
		while(bfs())while((x=dinic(S,INF)))ans-=x;
		write(ans);
	}
```

---


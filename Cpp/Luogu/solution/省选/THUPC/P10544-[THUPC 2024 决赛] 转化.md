# [THUPC 2024 决赛] 转化

## 题目描述

有 $n$ 种物品和 $m$ 种转化方式。第 $i$ 种转化方式可以将一个第 $a_i$ 种物品转化成 $k_i$ 个互不相同的物品，其中第 $j$ 个的种类是 $b_{i,j}$。同一种转化方式可以使用任意多次。

你有一些物品。你想知道，对于每一种特定的物品 $d$，你用这些你所拥有的物品可以分别转化出最多多少个该种物品。


## 说明/提示

不使用任何转化方式，可以得到一个物品 $1$。

使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。这样可以得到一个物品 $2$。

使用一次第二种转化方式，可以把物品 $1$ 变成物品 $3$。这样可以得到一个物品 $3$。

使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。然后再使用一次第三种转化方式，可以把物品 $2$ 变成物品 $4$。这样可以得到两个物品 $4$。

可以证明这四种方案分别是当 $d=1,2,3,4$ 时的最优方案。

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
4 4
1 0 0 0
1 2 2 4
1 1 3
2 1 4
3 1 4
```

### 输出

```
1
1
1
2
```

# 题解

## 作者：Hanghang (赞：4)

### [P10544 [THUPC2024] 转化](https://www.luogu.com.cn/problem/P10544)

来个暴力做法。

对每个物品的答案分别处理。设当前处理的物品为 $z$。

设 $f_{t,i}$ 表示经过了至多 $t$ 次转换，用一个 $i$ 最多能转化出 $f_{t,i}$ 个 $z$ 物品。

那么最终的答案为 $\sum f_{+\infty,i}\times a_i$，$a_i$ 为初始 $i$ 的物品个数，转移即枚举每种转移条件更新即可。

注意到这种松弛至多 $n$ 次，如果还能继续松弛那么说明物品可以无穷多。

复杂度为 $O(n^3m)$，实测非常快。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef __int128 ll;
const int N=103,M=1003;
ll n,m,sum,a[N],f[N],g[N],c[M],len[M],b[M][N];
void write(ll X)
{
	if(X<0){putchar('-');X=~(X-1);}
	int s[50],o=0;
	while(X){s[++o]=X%10;X/=10;}
	if(!o)s[++o]=0;while(o)putchar(s[o--]+'0');
	putchar('\n');
}
int main()
{
	int _n,_m;cin>>_n>>_m;n=_n;m=_m;
	for(int i=1,x;i<=n;i++)cin>>x,a[i]=x,sum+=n*a[i];
	for(int i=1;i<=m;i++)
	{
		int _c,_len;cin>>_c>>_len;c[i]=_c;len[i]=_len;
		for(int j=1,x;j<=len[i];j++)cin>>x,b[i][j]=x;
	}
	for(int t=1;t<=n;t++)
	{
		ll fl=0;
		for(int i=1;i<=n;i++)f[i]=i==t;
		for(int tim=1;tim<=n;tim++)
		{
			for(int i=1;i<=n;i++)g[i]=f[i];
			for(int i=1;i<=m;i++)
			{
				ll x=0;
				for(int j=1;j<=len[i];j++)x+=g[b[i][j]];
				f[c[i]]=max(f[c[i]],x);
			}
			ll cnt=0;
			for(int i=1;i<=n;i++)cnt+=f[i]==g[i];
			if(cnt==n)break;
			fl|=tim==n;ll s=0;
			for(int i=1;i<=n;i++)s+=f[i]*a[i];
		    if(s>(ll)1e33){fl=1;break;}
		}
		ll s=0;
		for(int i=1;i<=n;i++)s+=f[i]*a[i];
		if(fl)cout<<"infinity"<<endl;
		else write(s);
	}
}
```

---

## 作者：居然有个高手 (赞：3)

细节好多。

考虑先建出图论模型：若 $a$ 可以一步转化为 $b$，则连有向边 $a\to b$。并对该图缩强连通分量。

枚举 $d$，考虑何时答案为 $\inf$，发现若存在一组 $i,j,k$ 使得 $i$ 可以同时转化为 $j,k$，$j$ 能转化为 $i$ 并且 $k$ 能到达 $d$ 且 $i$ 可以通过某种转化后使得 $c_i\not=0$ 则答案为 $\inf$。否则我们可以对于 $i$ 选择一种贡献最大的转移方式统计进答案。

具体的，我们按照拓扑逆序一次考虑每个强连通分量，对于每个强连通分量记录 $sumc=\sum_{i\in s}c_i$ 与 $maxf = \max_{i\in s}f_i$，$f_i$ 表示将 $i$ 点转化的方案中，能转化出 $d$ 的数量的最大值（此处我们不计入将 $i$ 转化为其同强连通分量内的点的贡献）。

我们称一个强连通分量是必杀的，当且仅当该强连通分量内存在某个点 $i$ 使得存在一种将 $i$ 转化的方案满足能转化出至少一个 $d$ 且能转化出与 $i$ 同强连通分量内的点，或者 $maxf\not=0$ 并存在一个强连通分量内的点 $i$ 的转化方案使得 $i$ 可以转化出至少两个与其在同强连通分量内的点，发现若存在一个强连通分量是必杀的，且可以通过转化使得该强连通分量内至少有一个点 $c\not=0$，则答案为 $inf$。

接下来的判断就是容易的，考虑强连通分量的过程中若其 $sumc\not=0$ 并其是必杀的或其能到达必杀的强连通分量，则答案为 $\inf$，否则其对答案贡献 $sumc\times maxf$。

对于点 $d$ 所在的强连通分量需要有一定的特殊处理，代码中可以体现；答案可以用 __int128 存下。

时间复杂度： $O(n^2m)$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=105,M=1005;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x*f;
}
int n,m,dfn[N],low[N],op[N],scc[N],st[N],cnt,num,top,c[N];
__int128 f[N];
bool in[N];
vector<vector<int>>v[N];
vector<int>s[N];
inline void tarjan(int x){
    dfn[x]=low[x]=++cnt,in[x]=1,st[++top]=x;
    for(auto t : v[x]){
        for(auto y : t){
            if(!dfn[y])tarjan(y),low[x]=min(low[x],low[y]);
            else if(in[y])low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x]==dfn[x]){
        int z;num++;
        do{
            z=st[top--],in[z]=0,scc[z]=num;s[num].push_back(z);
        }while(z^x);
    }
}
inline void write(__int128 x){
    if(x>=10)write(x/10);
    putchar(x%10^48);
}
int main(){
    n=read(),m=read();
    for(int i = 1;i<=n;i++)c[i]=read();
    for(int i = 1;i<=m;i++){
        int a = read(),k=read();
        v[a].push_back(vector<int>());
        for(int j = 1;j<=k;j++)v[a].back().push_back(read());
    }
    for(int i = 1;i<=n;i++){
        if(!dfn[i])tarjan(i);
    }
    for(int d = 1;d<=n;d++){
        __int128 ans = 0;
        memset(f,0,sizeof f);
        memset(op,0,sizeof op);
        int op1=0,op2=1;
        for(auto j : s[scc[d]])op1|=c[j]>0;
        for(auto j : s[scc[d]]){
            f[j]=1;
            for(auto t : v[j]){
                int op = 0;
                for(auto k : t)op+=scc[k]==scc[d];
                if(op>=2&&op2){
                    if(op1){
                        printf("infinity\n");
                        goto fail;
                    }
                    else ::op[scc[d]]=1;
                }
            }
            ans+=c[j];
        }
        for(int i = scc[d]+1;i<=num;i++){
            int op1=0,op2=0;
            __int128 g=0;
            for(auto j : s[i]){
                for(auto t : v[j]){
                    __int128 sum = 0;
                    for(auto k : t)if(scc[k]!=scc[j])sum+=f[k],op[i]|=op[scc[k]];
                    f[j]=max(f[j],sum);
                    g=max(g,f[j]);
                }
                op1|=c[j]>0,op2|=f[j]>0;
            }
            for(auto j : s[i]){
                for(auto t : v[j]){
                    int o1=0,o2=0;
                    for(auto k : t){
                        if(scc[k]==scc[j])o1++;
                        else if(f[k])o2++;
                    }
                    if(o1&&o2&&op1){
                        printf("infinity\n");
                        goto fail;
                    }
                    if(o1>=2&&op2 || o1&&o2)op[scc[j]]=1;
                    if(op[scc[j]]==1&&op2){
                        if(op1){
                            printf("infinity\n");
                            goto fail;
                        }
                    }
                    
                    
                }
                ans+=c[j]*g;
                f[j]=g;
            }

        }
        write(ans);putchar('\n');
        fail:;
    }
    return 0;
}
```

---

## 作者：Larunatrecy (赞：2)

### [[THUPC2024] 转化](https://www.luogu.com.cn/problem/P105440)

我们先把所有边扔一块建图，跑强连通分量缩点，然后分析一下：

- 如果某一种转化方式有 $\ge 2$ 条边连向自己所在 `scc`，那么我们不断走这种转化可以让该 `scc` 内部每个物品达到无限种，接着所有在 `DAG` 上这个 `scc` 可以到达的物品也都是无限种。
- 如果某一种转化方式有至少一条边连向自己所在 `scc`，且至少有一条边连向别的 `scc`，那么不断在这里转圈就会导致这条连向外边的 `scc` 产生无限个物品。
- 剩下的转化方式就是有且只有一条连向自己所在 `scc`，以及只向外部连的，注意到如果不是无穷的话只会使用这两种边，那么我们只保留这些边，在 `DAG` 上倒着 `DP` 出来 $F_{i,j}$ 表示物品 $i$ 最多转化出 $j$ 个物品 $j$，以及 $G_i$ 表示最多生成物品 $i$ 的数量。

接着，如果 $G_i>0$，就把该 `scc` 第一、二种边连向的 `scc` 标成无限，然后把所有无限的节点的后继都也改成无限即可。

复杂度 $O(n^2m)$，注意到 $F,G$ 可能会很大，最大是竞赛图时，此时不会超过 $2^n$，因此用 `__int128` 可以存下。

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T>inline void read(T &x)
{
    x=0;char c=getchar();bool f=0;
    for(;c<'0'||c>'9';c=getchar())f|=(c=='-');
    for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c-'0');
    x=(f?-x:x);
}
const int N = 1005;
const int M = 1005;
vector<int> transport[N];
int K[M];
vector<int> seq[M];
vector<int> G[N];
int dfn[N],low[N],ins[N],num=0;
vector<int> scc[N];
stack<int> st;
int bel[N],cnt=0;
int n,m;
void tarjan(int x)
{
	dfn[x]=low[x]=++num;
	st.push(x);
	ins[x]=1;
	for(int y:G[x])
	{
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y])
		{
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		int y;
		do
		{
			y=st.top();
			st.pop();
			ins[y]=0;
			bel[y]=cnt;
			scc[cnt].push_back(y);
		}while(x!=y);
	}
}
int tim[N],ord[N],pos[N],tot=0;
int deg[N];
vector<int> T[N];
typedef long long LL;
typedef __int128 BIG;
BIG f[N],S[N],C[N];
int type[N];
BIG Ans[N];
int bin[N];
void solve(int x)
{
    for(int i=1;i<=tot;i++)f[i]=0;
    f[x]=1;
    for(int i=pos[x]-1;i>=1;i--)
    {
        int u=ord[i];
        for(int y:scc[u])
        for(int j:transport[y])
        if(bin[j]==0)
        {
            BIG sum=0;
            for(int z:seq[j])
            sum+=f[bel[z]];
            f[u]=max(f[u],sum);
        }
    }
    for(int i=1;i<=tot;i++)
    Ans[x]+=f[i]*S[i];
}
int fro[N];
bool inf[N];
void write(BIG x)
{
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}
int main()
{
    read(n);read(m);
    for(int i=1;i<=n;i++)read(C[i]);
    for(int i=1;i<=m;i++)
    {
        int x;
        read(x);
        fro[i]=x;
        read(K[i]);
        for(int j=1;j<=K[i];j++)
        {
            int y;
            read(y);
            seq[i].push_back(y);
            G[x].push_back(y);
        }
        transport[x].push_back(i);
    }
    queue<int> q;
    for(int i=1;i<=n;i++)
    if(!dfn[i])tarjan(i);
    for(int i=1;i<=n;i++)S[bel[i]]+=C[i];
    for(int x=1;x<=n;x++)
    for(int y:G[x])
    {
        if(bel[x]!=bel[y])
        {
            T[bel[x]].push_back(bel[y]);
            deg[bel[y]]++;
        }
    }
    for(int i=1;i<=m;i++)
    {
        bool flag=1,flag2=0;
        int s=fro[i];
        for(int y:seq[i])
        {
            if(bel[s]==bel[y])bin[i]++;
        }
    }
    for(int i=1;i<=cnt;i++)if(!deg[i])q.push(i);
    while(!q.empty())
    {
        int x=q.front();
        ord[++tot]=x;
        pos[x]=tot;
        q.pop();
        for(int y:T[x])
        {
            deg[y]--;
            if(!deg[y])q.push(y);
        }
    }
    for(int x=1;x<=cnt;x++)
    {
        solve(x);
    }
    for(int u=1;u<=tot;u++)
    if(Ans[u]>0)
    {
        for(int y:scc[u])
        for(int i:transport[y])
        {
            if(bin[i]>1)inf[u]=1;
            if(bin[i]>0&&bin[i]<K[i])
            {
                for(int z:seq[i])
                if(bel[z]!=u)inf[bel[z]]=1;
            }
        }
    }
    for(int i=1;i<=tot;i++)if(inf[i])q.push(i);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int y:T[x])
        {
            if(!inf[y])
            {
                inf[y]=1;
                q.push(y);
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(inf[bel[i]])printf("infinity\n");
        else
        {
            write(Ans[bel[i]]);
            printf("\n");
        }
    }
    return 0;
}

```

---


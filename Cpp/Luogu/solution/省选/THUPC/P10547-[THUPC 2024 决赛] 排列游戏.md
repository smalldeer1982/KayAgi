# [THUPC 2024 决赛] 排列游戏

## 题目描述

有 $n$ 个格子排成一行，从左到右依次编号为 $1,2,\cdots,n$，每个格子上有一个数字卡片，初始状态下，格子 $i$ 上的卡片数字为 $i$。

打乱者会进行 $n$ 次交换操作来排列这些卡片：每次选择两个格子 $i,j$（$i\ne j$），然后交换格子 $i$ 和格子 $j$ 上的卡片。$n$ 次交换操作结束后，就完成了对卡片的排列。

然后轮到玩家行动，玩家同样需要用交换操作，每次交换两张卡片，目标是将这些卡片的顺序还原到初始状态。

交换格子 $i$ 和格子 $j$ 上的卡片所需的时间为 $|i-j|$，玩家打算用最短的时间还原该排列。问：有多少种可能的排列，玩家可以用不超过 $m$ 的总时间完成还原？两种排列不同，当且仅当至少有一张数字卡片在两种排列中所在的格子不同。

## 说明/提示

在第 $1$ 组数据中，打乱者的 $2$ 次操作均只可能是交换格子 $1$ 和格子 $2$ 上的卡片，只有 $1$ 种可能的排列，也就是初始状态 $[1,2]$。

在第 $2$ 组数据中，有 $2$ 种可能的排列：$[1,3,2]$ 和 $[2,1,3]$。注意初始状态 $[1,2,3]$ 不是一种可能的排列，因为打乱者进行前 $2$ 次交换之后，所有卡片要么仍在初始状态（前 $2$ 次交换的是同一对卡片），要么均不在初始位置上（前 $2$ 次交换的不是同一对卡片），第 $3$ 次交换后不可能回到初始状态。

在第 $3$ 组数据中，有 $7$ 种可能的排列：$[1,2,3,5,4]$，$[1,2,4,3,5]$，$[1,2,5,4,3]$，$[1,3,2,4,5]$，$[1,4,3,2,5]$，$[2,1,3,4,5]$，$[3,2,1,4,5]$。

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
6
2 1
3 1
5 2
7 5
10 20
15 24
```

### 输出

```
1
2
7
331
1570446
73880648
```

# 题解

## 作者：Union_of_Britain (赞：6)

先考察操作的性质。

注意到若设每个点的势能是 $|i-p_i|$，一次代价为 $W$ 的操作的最多使得总势能减少 $2W$。因此有不等式：

$$Ans\ge \frac{\sum |i-p_i|}{2}$$

这个形式看起来就很正确。猜想其可以取到下界，所以有：

引理 1：一个排列的最小交换代价是 $\dfrac{\sum |i-p_i|}{2}$。

证明：

只需说明对于每个非恒等的排列有一个使总势能减少 $2W$ 的操作即可，然后施加归纳法即可。设原排列为 $p$，逆排列为 $r$，则等价于存在：

$$\exists i\neq j,i\le r_j<r_i\le j$$

取 $i$ 为最小的 $i\neq p_i$，$j$ 为 $[i,r_i]$ 中一个 $k$ 使得 $p_k\ge r_i$ 即可。这样的 $i,j$ 总是存在的。

再考虑“交换 $n$ 次”是什么意思。不难发现：

引理 2：可以交换 $n$ 次到达的排列是所有奇偶性等于 $n$ 的奇偶性的排列。

这是容易证明的：奇偶性不等于 $n$ 的排列显然无法到达，奇偶性相等的排列可以构造：每次操作直接从后面交换即可（如果需要）。最后剩下的次数是偶数，一直操作 $(1,2)$ 即可。

奇排列和偶排列的答案应该不会差太远，并且应该具有某种模式。打表不难发现：

引理 3：对于 $\sum |i-p_i|=2k$ 的排列，奇偶排列的个数差的绝对值是 $\binom{n-1}{k}$，并且正负性是 $(-1)^{n+k}$。

证明（不过显然考试时这个结论是没有必要证明的）：考虑建立一个使得势能和不变的奇偶排列的映射。如果存在一个使势能和不变的交换就交换一次，这样的映射显然可逆，这样只需考虑那些不能交换的。

那些不能交换的就是循环都由连续数字构成的排列。设有 $m$ 个循环，则势能和应该是 $2(n-m)$，而计数是 $\binom{n-1}{m-1}=\binom{n-1}{n-m}$。

这样问题就被几乎转化为 [ABC134F](https://www.luogu.com.cn/problem/AT_abc134_f)。~~然后我们队在做的时候看到数据范围就不知道怎么做了。~~

事实上这里的 DP 就是采取 ABC134F 的方法。比如[这一篇题解](https://www.luogu.com.cn/article/vlbxfqmn)。但是那道题的时间复杂度是 $O(n^2m)$，似乎难以通过。

但是本题具有更特殊的性质：$m$ 量级小于 $n^2$。仔细分析这篇题解的状态，应该有 $j$（第二维）是 $O(\sqrt m)$ 的，只是由于那道题的 $m=n^2$ 才没有改变复杂度。

这样最后的复杂度就是 $O(nm\sqrt m)$，可以通过。

注：代码里的状态实际上是官方题解的状态，也就是说这个代码的 $j$（代码里是 $d+i$）是上面那篇题解的 $i-j$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int T,n,m,N=500,M=10000,SM=80;
int f[2][160][10005],fac[100005],ifac[10005];
int qp(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
inline int C(int a,int b){
	if(b>a)return 0;
	return fac[a]*ifac[b]%mod*ifac[a-b]%mod;
}
int s[505][20005];
inline int pow1(int x){
	if(x&1)return mod-1;
	return 1;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	fac[0]=1;
	for(int i=1;i<=M;i++)fac[i]=fac[i-1]*i%mod;
	ifac[M]=qp(fac[M],mod-2);
	for(int i=M-1;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%mod;
	int I2=(mod+1)/2,cur=0;
	f[cur][0][0]=1;
	for(int i=1;i<=N;i++){
		cur^=1;
		for(int d=0;d<=min(SM,i);d++){
			for(int k=(d-1)*d;k<=M;k+=2){
				f[cur][d][k]=0;
				if(d>0)f[cur][d][k]=f[cur^1][d-1][k-2*(d-1)];
				if(k>=2*d)f[cur][d][k]+=f[cur^1][d][k-2*d]*(2*d+1);
				if(f[cur][d][k]>=mod)f[cur][d][k]-=mod;
				if(k>=2*(d+1))(f[cur][d][k]+=f[cur^1][d+1][k-2*(d+1)]*(d+1)*(d+1))%=mod;
			}
		} 
		for(int j=0;j<=M;j++){
			if(j&1)continue;
			int k=j/2,F=f[cur][0][j];
			if(k<=i)(F+=pow1((i&1)+(k&1))*C(i-1,k)%mod)%=mod;
			F=F*I2%mod;
			s[i][j]=((j>0?s[i][j-2]:0)+F)%mod;
		}
	}
	cin>>T;
	while(T--){
		cin>>n>>m;
		int ans=s[n][m*2];
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：honglan0301 (赞：5)

upd：感谢评论区指出问题，更正了结论一的证明。

## 分析

<1> 尝试转化题目条件，我们通过手玩/猜能够发现以下两个结论：

1. “可以用不超过 $m$ 的总时间还原”$\iff \sum |p_i-i|\leq 2m$。

	证明：一方面 $\sum |p_i-i|\leq 2m$ 是必要的，因为初始状态时 $\sum |p_i-i|=0$ 而每次操作后其变化量 $|p_i-i|-|p_i-j|+|p_j-j|-|p_j-i|\leq 2|i-j|$。
    
   另一方面 $\sum |p_i-i|\leq 2m$ 也是充分的。在任意一个未被还原的排列中，我们一定能够找到一对满足 $p_j\leq i<j\leq p_i$ 的 $(i,j)$（找出**最小的** $p_j$ 满足 $p_j<j$，则此时有 $[p_1,p_2,\dots,p_{p_j-1}]=[1,2,\dots,p_j-1]$。那么显然一定存在 $p_j\leq i<j$ 使得 $p_i\geq j$，否则 $p_1 ,p_2,\dots,p_j$ 均 $<j$，无法构成排列），不断对找出的 $(i,j)$ 进行操作即可。
   
2. “$n$ 次交换操作结束后，就完成了对卡片的排列”$\iff$ 排列置换环数量为偶数。

	证明：显然每次选两个不同位置交换会使得置换环数量的奇偶性改变。
    
<2> 对 $\sum |p_i-i|\leq 2m$ 且 置换环数量为偶数的排列计数：

- 注意到 $\sum |p_i-i|=2\sum [p_i>i](p_i-i)$，考虑对置换环形态做 dp，只记录环里上升边（即 $i\rightarrow j\ (i<j)$ 的边）的贡献。

- 枚举值域，从小到大插入每个数。记 $f_{i,j,k,op}$ 表示考虑了 $1\sim n$ 这些数，此时有 $j$ 条链、上升边的总贡献为 $k$、置换环奇偶性为 $op$ 的方案数。（为了方便转移，我们需要对每个链尾 $x$ 额外加上 $i-x$ 的贡献。）

- 转移是简单的，因为插入一个数 $i+1$ 只有六种可能的情况（作为一条新链；作为自环；接在某条链前面；接在某条链后面；把某两条链合并；把某条链变成环）：

	$$
   \left\{
  	\begin{aligned}
   &f_{i+1,j+1,p+j,op}\gets f_{i+1,j+1,p+j,op}+f_{i,j,p,op}\\
   &f_{i+1,j+1,p+j,1-op}\gets f_{i+1,j+1,p+j,1-op}+f_{i,j,p,op}\\
   &f_{i+1,j,p+j,op}\gets f_{i+1,j,p+j,op}+f_{i,j,p,op}\times j\\
   &f_{i+1,j,p+j,op}\gets f_{i+1,j,p+j,op}+f_{i,j,p,op}\times j\\
   &f_{i+1,j-1,p+j,op}\gets f_{i+1,j-1,p+j,op}+f_{i,j,p,op}\times j\times (j-1)\\
   &f_{i+1,j-1,p+j,1-op}\gets f_{i+1,j-1,p+j,1-op}+f_{i,j,p,op}\times j\\
   \end{aligned}
   \right.
   $$
   
- 注意到第二维的值域只有 $O(\sqrt m)$，总时间复杂度 $O(nm\sqrt m)$，可以通过本题。但是赛时被卡常了。被卡常了。被卡常了。被卡常了。被卡常了。

## 代码

核心代码如下。

```cpp
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define int long long
#define N 505
#define M 5005
#define B 75

int T,n,m,dp[2][B][M][2],ans[1005];
vector <pair<int,int>> qu[N];

signed main()
{
	cin>>T;
	for(int i=1;i<=T;i++) cin>>n>>m,qu[n].pb(mp(m,i));
	dp[0][0][0][0]=1;
	for(int i=0;i<=500;i++)
	{
		memset(dp[(i+1)&1],0,sizeof(dp[(i+1)&1]));
		for(int j=0;j<=71;j++)
		{
			for(int p=j*(j-1)/2;p+j*(j+1)/2<=5000;p++)
			{
				for(int op=0;op<2;op++)
				{
					int nr=dp[i&1][j][p][op];
					dp[(i+1)&1][j+1][p+j][op]=(dp[(i+1)&1][j+1][p+j][op]+nr)%mod;
					dp[(i+1)&1][j][p+j][op^1]=(dp[(i+1)&1][j][p+j][op^1]+nr)%mod;
					dp[(i+1)&1][j][p+j][op]=(dp[(i+1)&1][j][p+j][op]+nr*j)%mod;
					dp[(i+1)&1][j][p+j][op]=(dp[(i+1)&1][j][p+j][op]+nr*j)%mod;
					if(j) dp[(i+1)&1][j-1][p+j][op]=(dp[(i+1)&1][j-1][p+j][op]+nr*j*(j-1))%mod;
					if(j) dp[(i+1)&1][j-1][p+j][op^1]=(dp[(i+1)&1][j-1][p+j][op^1]+nr*j)%mod;
				}
			}
		}
		for(auto j:qu[i])
		{
			for(int p=0;p<=j.fi;p++) ans[j.se]=(ans[j.se]+dp[i&1][0][p][0])%mod;
		}
	}
	for(int i=1;i<=T;i++) cout<<ans[i]<<endl;
}
```

---


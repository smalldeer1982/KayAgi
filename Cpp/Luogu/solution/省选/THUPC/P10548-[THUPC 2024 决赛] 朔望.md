# [THUPC 2024 决赛] 朔望

## 题目背景

Syzygy，中文译作朔望，表示三个或三个以上的天体大致位于同一直线上。本题中主要探讨母恒星与至少两颗行星位于同一直线上的情况。


## 题目描述

在一个理想的行星系中，所有行星在同一平面内围绕共同的单一母恒星作匀速圆周的公转运动，且公转方向相同（如同为逆时针）。我们定义这样的行星系的 Syzygy 指数为平均每年发生的所有（含母恒星的）朔望的稀有程度之和，其中单次朔望的稀有程度是与产生连线的**行星**数量 $x$ 有关的常数 $w_x$；如果在行星系中同时发生多个朔望但不位于同一直线上，则对每条直线上的行星分别统计稀有程度。

现有一理想的包含 $n$ 颗行星的行星系，其中从内到外第 $i$ 颗行星绕母恒星公转周期为 $t_i$ 年（根据开普勒第三定律可知 $t_i$ 单调递增）。假设存在某一时刻，所有 $n$ 颗行星位于同一条以母恒星为端点的射线上。请求出该系统的 Syzygy  指数。

## 说明/提示

**样例解释 1**

不妨假设 $T=0$ 时刻两颗行星位于同一以母恒星为端点的射线上。由于两颗行星的公转周期的最小公倍数为 $12$ 年，且两颗行星的会合周期也恰为 $\displaystyle\frac{1}{\displaystyle\left|\frac{1}{3}-\frac{1}{4}\right|}=12$ 年，故可取 $T\in[0, 12)$ 年的行星系的运行情况作为研究对象。$T$ 取 $[0, 12)$ 中整数值时，行星系的运行情况分别如下各图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/okkdl28r.png)

可以证明，在 $12$ 年的周期内，两颗行星仅发生如上图所示的 $2$ 次朔望（分别为 $T=0$ 时的内行星凌/外行星冲及 $T=6$ 年的合）。因此，该行星系的 Syzygy 指数为

$$
\frac{2\times 5}{12} = \frac{5}{6} \equiv 833333340 \pmod{10^9 +7}.
$$

**样例解释 2**

同理设 $T=0$ 时刻三颗行星位于同一以母恒星为端点的射线上。由 $\mathrm{lcm}(4, 5, 6)=60$，可取 $T\in[0,60)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/df7frwd2.png)


因此，该行星系的 Syzygy 指数为

$$
\frac{14\times 7+2\times 8}{60}=\frac{19}{10}\equiv300000004 \pmod{10^9+7}.
$$

**样例解释 3**

同理设 $T=0$ 时刻四颗行星位于同一以母恒星为端点的射线上。由 $\mathrm{lcm}(4, 6, 8, 24)=24$，可取 $T\in[0,24)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/5930jff7.png)

因此，该行星系的 Syzygy 指数为

$$
\frac{20\times 20+0\times22+2\times 1207}{24}=\frac{1407}{12}\equiv250000119 \pmod{10^9+7}.
$$


**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
2
3 4
5
```

### 输出

```
833333340
```

## 样例 #2

### 输入

```
3
4 5 6
7 8
```

### 输出

```
300000004
```

## 样例 #3

### 输入

```
4
4 6 8 24
20 22 1207
```

### 输出

```
250000119
```

## 样例 #4

### 输入

```
9
88 225 365 687 4333 10759 30685 60189 90560
306 241 336 406 342 86884 86885 86886
```

### 输出

```
94380764
```

# 题解

## 作者：Ian_NIE (赞：1)

## 0x00 前言

读了半天没读懂白鸽子同学的[题解](https://www.luogu.me/article/es3epoly)，我自己也来写一篇。

## 0x01 题目大意

我们从一个初中生的角度理解题目。小奥大家都知道有个东西叫环形跑道，就是一些人在一个环形跑道上行动。这道题是一样的，一些行星在一个长度为 $1$（这个不是很重要，设一个就好）的跑道上进行运动，已经知道了每个行星运动完一圈所需要花的时间。

继续理解什么是所谓 Syzygy，朔望现象。就是两个行星，之间的距离是 $0$ 或 $\frac{1}{2}$，就是这个轨道的一侧或间距一半。我们会发现，存在很多种情况，比如只有两颗行星共线，或者三颗，甚至四颗。这时候题目告诉我们这些情况对答案的贡献是不一样的，需要乘上一个整数。在一个周期内（行星运行一圈所需时间的最小公倍数的倍数）把所有“朔望”的贡献加起来，初一这个周期的时刻数量，假设此时的结果是 $\frac{p}{q}$，答案 $ans$ 可以表示为：

$$\frac{p}{q} \equiv x \pmod {10^9 + 7}$$

## 0x01 题目分析 & 算法设计

不要被各种公式吓懵，这是一道紫题。

### 0x01 化简求答案的公式

首先我们需要解决这个答案 $ans$ 的求法。这个公式：

$$\frac{p}{q} \equiv x \pmod {10^9 + 7}$$

这时候我们利用费马小定理，当 $m$ 是质数且 $\gcd(x, m) = 1$ 时：

$$b^{-1} \equiv b^{m - 2} \pmod m$$

因为 $10^9 + 7$ 是质数并且显然 $\gcd(q, m) = 1$（因为 $q$ 是 $t_{1 \dots n}$ 的最小公倍数的倍数的因数，并且 $t_{1 \dots n}$ 均 $\le 10^9$，所以 $t_{1 \dots n}$ 的最小公倍数一定没有 $10^9 + 7$ 这个质因子，所以其因数更没有这个质因子，进而与 $10^9 + 7$ 互质），所以：

$$\frac{p}{q} = p \times q ^ {-1} \equiv p \times q^{10^9 + 7 - 2} = p \times q^{10^9 + 5} \equiv x \pmod {10^9 + 7}$$

即：

$$x \equiv p \times q^{10^9 + 5} \pmod {10^9 + 7}$$

现在我们的问题只在于解决 $\frac{p}{q}$ 了。

### 0x02 “朔望”怎么计算

我们先考虑简化问题，只考虑两个行星的系统。

设这两个行星的公转周期是 $t_1$ 和 $t_2$，不妨设 $t_1 < t_2$。所以运行速度是 $v_1 = \frac{1}{t_1}$ 和 $v_2 = \frac{1}{t_2}$，此时显然 $v_1 > v_2$。此时，“朔望”怎么理解，就是我在 “题目大意”部分已经说过的这句话：

> 继续理解什么是所谓 Syzygy，朔望现象。就是两个行星，之间的距离是 $0$ 或 $\frac{1}{2}$，就是这个轨道的一侧或间距一半。

所以，考虑一开始两个行星之间的距离是 $0$，下一次达到 $\frac{1}{2}$ 就是产生 $\frac{1}{2}$ 的路程差，再下一次达到 $0$ 就是再产生 $\frac{1}{2}$ 的路程差。根据 $t \times v = s$（行程问题的基础），即 $t = \frac{s}{v}$，所以对于两颗行星，“朔望”周期就是：

$$\frac{\frac{1}{2}}{v_1 - v_2} = \frac{1}{2(\frac{1}{t_1} + \frac{1}{t_2})} = \frac{t_1t_2}{2(t_2 - t_1)}$$

继续考虑“三星系统”。~~是行星，不是恒星，不是三体问题。~~ 在证明三点共线是有一个证法，就是证明 $C$ 在直线 $AB$ 上。这时候我们可以先让行星 $1$ 和 $2$“朔望”，在计算什么时候 $1$ 与 $3$“朔望”，然后三星同时“朔望”在周期 $T$ 里面的“朔望”次数就是（不妨设 $t_1 < t_2 < t_3$）：

$$\gcd(\frac{T \,\cdot\, 2(t_2 - t_1)}{t_1t_2}, \frac{T \,\cdot\, 2(t_3 - t_1)}{t_1t_3})$$

另外，对于周期 $T$，因为影响答案的是概率，所以 $T$ 只要是 $t_{1 \dots n}$ 的最小公倍数的倍数即可。显然当 $T = \prod t_i$ 时满足要求，所以这时候，我们粗略地把 $T$ 看作 $\prod t_i$。所以显然所有的 $\frac{T \,\cdot\, 2(t_j - t_i)}{t_it_j}$，满足 $t_i < t_j$，一定是正整数。

进而，以此类推，对于一个 $k$ 星系统，$k$ 星“朔望”在 $T$ 内的次数就是 $\gcd ^ k _{i = 2} \frac{T \,\cdot\, 2(t_i - t_1)}{t_1t_i}$，即计算所有 $2 \,\sim\, k$ 中所有与 $1$“朔望”的周期最小公倍数。

这样，数学部分也就解决了。

### 0x03 算法设计

观察我们得到的式子，首先先把 $2$ 提出来，然后预处理 $\frac{T}{t_1t_i}$ 和 $t_i - t_1$ 的每一个质因数，因为 $\gcd$ 本质就是质因数的运算。两者乘起来之后可以发现实质上不同的质因数数量很少，所以考虑直接暴力存储并且在以 $10^9 + 7$ 为模数的情况下求解答案。

我们直接选择一些行星，时间复杂度 $O(n^2)$，设总质因数个数为 $p$，此时进行数学计算的时间复杂度为 $O(n + w)$，整体时间复杂度 $O(2^n(n + w))$。

但是，在我们的算法里面根本没有考虑在当前这个行星中，该内部“朔望”没有更多的集合外的行星也发生了“朔望”。所以，我们需要再使用 IFWT 算法在 $O(w2^n)$ 的时间复杂度内实现该过程，按照前面的公式求取答案即可。

## 0x04 代码实现

这是一道大模拟，只需要注意一些细节即可。

**IFWT 算法：**

这里我的讲解比较粗略，直接放代码：
```cpp
void IFWT(ll *f)
{
    for(int i = 1; i <= n; i++)
    {
        for(int st = tot; st >= 1; st--)
        {
            if(!((st >> (i - 1)) & 1)) continue;
            int nw = st ^ (1 << (i - 1));
            cnts[nw] = (cnts[nw] - cnts[st] + mo) % mo;
        }
    }
}
```

其他的讲解相对详细，可以直接写出代码，具体代码大家直接参考[原题解](https://www.luogu.me/article/es3epoly)就好了，只是我认为我的思路更加详细。

## 0x05 后记

本人水平不高，有问题请在评论区指出。本文对白鸽子同学的题解有大量的参考，但是我认为原题解的讲解不够详细，故又发文解释。

[AC 记录](https://www.luogu.com.cn/record/222506757)。

---

## 作者：是青白呀 (赞：1)

观察到 $n\leq 20$，直接的思路是枚举每一个星球集合 $S$，计算这一个集合里的星球在一个周期里的共线次数。这里我们简单地设 $T=\prod t_i$，不难发现 $T$ 一定是星球运动最小正周期的倍数。

不妨先考虑两个星球与母恒星共线的情况：设 $t_{S_1}<t_{S_2}$，则 $v_1=\frac {1}{t_{S_1}}$，$v_2=\frac{1}{t_{S_2}}$，则共线的周期为 $\frac{\frac 12}{v_1-v_2}=\frac{t_{S_1}t_{S_2}}{2(_{S_2}-t_{S_1})}$，则在 $T$ 的时间里，其共线次数为 $2(t_{S_2}-t_{S_1})\times \frac{T}{t_{S_1}t_{S_2}}$。

三个星球共线的情况，实际上等价于 $S_1$ 和 $S_2$ 共线的同时，$S_1$ 和 $S_3$ 共线。由于初始时任意星球都共线，因此它们的共线次数为 $\gcd(2(t_{S_2}-t_{S_1})\times \frac{T}{t_{S_1}t_{S_2}},2(t_{S_3}-t_{S_1})\times \frac{T}{t_{S_1}t_{S_3}})$。

以此类推，$n$ 个星球共线，实际上等价于 $S_2\sim S_n$ 的所有星球同时与星球 $S_1$ 共线。因此，对于星球集合 $S$，它们共线的次数为 $\gcd_{i=2}^{|S|} 2(t_{S_i}-t_{S_1})\times \frac{T}{t_{S_i}t_{S_1}}$。

考虑如何处理上面这个式子。先把公因数 $2$ 提出来，然后可以预处理出每一个 $t_i-t_1$ 和 $\frac{T}{t_it_1}$ 的质因数集合。发现它们乘起来之后，不同质因数的个数 $w$ 很少，因此我们可以通过暴力合并的方式求得上面这个式子对 $10^9+7$ 取模的值。通过 dp 不难在 $O(2^n(n+w))$ 的复杂度内算出每个星球集合 $S$ 共线发生的次数。

注意到此处算出来的次数并没有限制其它集合外的星星是否参与共线。因此，我们还需要计算共线的所有星星恰好等于某个集合的次数，可以直接用 IFWT 在 $O(n2^n)$ 的复杂度内还原。最终用得到的次数除掉 $T$ 即可求出每一年的平均共线次数，然后乘上对应权值并求和即可。

时间复杂度 $O((n+w)2^n)$，空间复杂度 $O(w2^n)$。有点卡空间，实测出 $w$ 取 $45$ 即可通过。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second 
using namespace std;
typedef long long ll;
const int N=25,M=(1<<20)+5,mo=1e9+7,inf=1e9+7;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
ll quick_power(ll base,int x){
	ll res=1;
	while(x){
		if(x&1)res*=base,res%=mo;
		base*=base,base%=mo;
		x>>=1;
	}
	return res;
}
int n,t[N],w[N];
struct divi{
	pii d[45];
	int cntd=0;
	friend divi operator+(divi x,divi y){//对两个大数做乘积，合并质因数集合
		divi res;
		rep(i,1,x.cntd){
			bool exi=0;
			rep(j,1,y.cntd){
				if(x.d[i].fir==y.d[j].fir)y.d[j].sec+=x.d[i].sec,exi=1;
				if(exi)break;
			}
			if(!exi)res.d[++res.cntd]=x.d[i];
		}
		rep(j,1,y.cntd)
		    res.d[++res.cntd]=y.d[j];
		sort(res.d+1,res.d+res.cntd+1);
		return res;
	}
}num[N],dif[N][N],dv[N][N],pre[M];
divi getd(int x){//求质因数集合
	divi res;
	rep(i,2,sqrt(x)){
		if(x<i)break;
		int cnt=0;
		while(x%i==0)
		    x/=i,cnt++;
		if(cnt)res.d[++res.cntd]=mp(i,cnt);
	}
	if(x!=1)res.d[++res.cntd]=(mp(x,1));
	return res;
}
int cntr;
divi getgcd(divi x,divi y){//合并质因数集合，求gcd.
	divi res;
	int nw=1;
	rep(i,1,x.cntd){
		while(nw<=y.cntd&&y.d[nw].fir<x.d[i].fir)
		    nw++;
		cntr++;
		if(y.d[nw].fir==x.d[i].fir)res.d[++res.cntd]=mp(x.d[i].fir,min(x.d[i].sec,y.d[nw].sec));
	}
	return res;
}
ll cnts[M];
int tot;
ll count(divi x){
	ll res=1;
	rep(i,1,x.cntd)
	    res=res*quick_power(x.d[i].fir,x.d[i].sec)%mo;
	return res;
}
void IFWT(ll *f){
	rep(i,1,n){
		repp(st,tot,1){
			if(!((st>>(i-1))&1))continue;
			int nw=st^(1<<(i-1));
			cnts[nw]=(cnts[nw]-cnts[st]+mo)%mo; 
		}
	}
}
signed main(){
	read(n),tot=(1<<n)-1;
	rep(i,1,n) 
	    read(t[i]);
	rep(i,2,n)
	    read(w[i]);
	rep(i,1,n)
	    num[i]=getd(t[i]);
	rep(i,1,n-1){//count the devisors
		rep(j,i+1,n){
			dif[i][j]=getd(t[j]-t[i]);
			rep(k,1,n)
			    if(i!=k&&j!=k)dv[i][j]=dv[i][j]+num[k];
			dv[i][j]=dv[i][j]+dif[i][j];
		}
	}
	rep(st,1,tot){
		int nnum=__builtin_popcount(st);
		if(nnum==1)continue;
		int fir=0;
		vector<divi>nwres[2];
		rep(i,1,n){
			if(!((st>>(i-1))&1))continue;
			if(!fir)fir=i;
			break;
		}
		repp(i,n,1){
		    if(!((st>>(i-1))&1))continue;
		    int nw=st^(1<<(i-1));
		    if(nnum==2)pre[st]=dv[fir][i];
		    else pre[st]=getgcd(pre[nw],dv[fir][i]);
		    break;
		}
		cnts[st]=2*count(pre[st])%mo;
    }
	IFWT(cnts);
	//get the ans.
	ll ans=0,mult=1;
	rep(i,1,n)
	    mult*=t[i],mult%=mo;
	mult=quick_power(mult,mo-2);
	repp(st,tot,1){
		int nnum=__builtin_popcount(st);
		if(nnum==1)continue;
		ans+=w[nnum]*cnts[st]%mo*mult%mo;
		ans%=mo;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：MatrixGroup (赞：0)

## 题意

在一个理想的行星系中，所有行星在同一平面内围绕共同的单一母恒星作匀速圆周的公转运动，且公转方向相同（如同为逆时针）。我们定义这样的行星系的 Syzygy 指数为平均每年发生的所有（含母恒星的）朔望的稀有程度之和，其中单次朔望的稀有程度是与产生连线的**行星**数量 $x$ 有关的常数 $w_x$；如果在行星系中同时发生多个朔望但不位于同一直线上，则对每条直线上的行星分别统计稀有程度。

现有一理想的包含 $n$ 颗行星的行星系，其中从内到外第 $i$ 颗行星绕母恒星公转周期为 $t_i$ 年（根据开普勒第三定律可知 $t_i$ 单调递增）。假设存在某一时刻，所有 $n$ 颗行星位于同一条以母恒星为端点的射线上。请求出该系统的 Syzygy  指数，模 $10^9+7$。

$n\le 20,1\le t_1<t_2<\cdots<t_n\le 10^9,1\le w_i\le 10^9$。3s。

## 题解

因为 $n\le20$，可以考虑枚举在同一条直线上的行星集合。但是钦定某个集合是比恰好某个集合更好算的，所以先对 $w$ 进行二项式反演，然后对于每个集合 $S$（$|S|\ge 2$）求出 $S$ 在同一条直线上的方案数。

钦定 $S$ 在同一条直线上，因为可以是在同一侧或者不同侧，所以只需要要求对于 $i,j\in S$ 满足时间 $T$ 符合 $\dfrac{2T}{t_i}-\dfrac{2T}{t_j}=T\dfrac{2(t_i-t_j)}{t_it_j}$ 是整数，这样的话每 $t_it_j$ 年会有 $2|t_i-t_j|$ 次，换言之平均每年出现的次数为 $\dfrac{2|t_i-t_j|}{t_it_j}$。

这样我们就知道了 $|S|=2$ 的情况的求法。考虑对于一般的 $S=\{x_1,x_2,\cdots,x_k\}$，出现的年数周期是 $\{x_1,x_i\}$ 周期的 $\operatorname{lcm}$，因此只需要对 $\dfrac{2|t_{x_1}-t_{x_i}|}{t_{x_1}t_{x_i}}$ 求 $\gcd$ 即为所求。其中，有理数 $p,q$ 的 $\gcd(p,q)=r$ 为最大的正有理数 $r$ 满足存在整数 $n,m$ 使得 $p=nr,q=mr$。

我们可以预处理每一对 $(i,j)$ 预处理出 $\dfrac{2|t_i-t_j|}{t_it_j}$ 的质因数分解，这样在枚举时求 $\gcd$ 显然不会超时。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,_##i##__end=int(n);i<_##i##__end;++i)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
typedef long long ll;
using namespace std;
const ll mod2=1000000007;
int n,t[25];
ll w[25];ll C[25][25];
vector<pair<int,int> > fact[25];
vector<pair<int,int> > cur;
map<int,int> M;
void factorize(int N)
{
	cur.clear();
	for(int i=2;i<=N/i;++i)
	{
		if(N%i==0)
		{
			int c=0;
			while(N%i==0)
			{
				++c;N/=i;
			}
			cur.pb(mp(i,c));
		}
	}
	if(N>1) cur.pb(mp(N,1));
}
vector<pair<int,int> > cur1;
void multiply(const vector<pair<int,int> >&A,const vector<pair<int,int> > &B)
{
	cur1.clear();
	int l=0,r=0;
	while(l<int(A.size())||r<int(B.size()))
	{
		if(l==int(A.size()))
		{
			cur1.pb(B[r++]);
		}
		else if(r==int(B.size()))
		{
			cur1.pb(A[l++]);
		}
		else if(A[l].fi==B[r].fi)
		{
			cur1.pb(mp(A[l].fi,A[l].se+B[r].se));
			++l;++r;
		}
		else if(A[l].fi<B[r].fi)
		{
			cur1.pb(A[l++]);
		}
		else
		{
			cur1.pb(B[r++]);
		}
	}
}
void calcgcd(const vector<pair<int,int> >&A,const vector<pair<int,int> >&B)
{
	cur1.clear();
	int l=0,r=0;
	while(l<int(A.size())||r<int(B.size()))
	{
		if(l==int(A.size()))
		{
			if(B[r].se<0)
			cur1.pb(B[r++]);
			else
			++r;
		}
		else if(r==int(B.size()))
		{
			if(A[l].se<0)
			cur1.pb(A[l++]);
			else
			++l;
		}
		else if(A[l].fi==B[r].fi)
		{
			cur1.pb(mp(A[l].fi,min(A[l].se,B[r].se)));
			++l;++r;
		}
		else if(A[l].fi<B[r].fi)
		{
			if(A[l].se<0)
			cur1.pb(A[l++]);
			else
			++l;
		}
		else
		{
			if(B[r].se<0)
			cur1.pb(B[r++]);
			else
			++r;
		}
	}
}
void calcdel(const vector<pair<int,int> >&A,const vector<pair<int,int> >&B)
{
	cur1.clear();
	int l=0,r=0;
	while(l<int(A.size())||r<int(B.size()))
	{
		if(l==int(A.size()))
		{
			cur1.pb(mp(B[r].fi,-B[r].se));r++;
		}
		else if(r==int(B.size()))
		{
			cur1.pb(A[l++]);
		}
		else if(A[l].fi==B[r].fi)
		{
			if(A[l].se!=B[r].se)
			cur1.pb(mp(A[l].fi,A[l].se-B[r].se));
			++l;++r;
		}
		else if(A[l].fi<B[r].fi)
		{
			cur1.pb(A[l++]);
		}
		else
		{
			cur1.pb(mp(B[r].fi,-B[r].se));r++;
		}
	}
}
vector<pair<int,int> > F[25][25];
vector<pair<int,int> > QWQ;
ll total;
ll qkpw(ll a,ll b)
{
	ll r=1;
	while(b)
	{
		if(b&1)r=r*a%mod2;
		a=a*a%mod2;
		b>>=1;
	}
	return r;
}
vector<pair<int,int> > CONST2;
int pq[1919810];
int main()
{
	cin>>n;
	CONST2.pb(mp(2,1));
	rep(i,n) cin>>t[i];
	for(int i=2;i<=n;++i) cin>>w[i];
	C[0][0]=1;
	for(int i=1;i<=n;++i)
	{
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;++j)
		{
			C[i][j]=C[i-1][j]+C[i-1][j-1];
			if(C[i][j]>=mod2)C[i][j]-=mod2; 
		}
	}
	rep(i,n)
	{
		factorize(t[i]);
		fact[i].swap(cur);
	}
	rep(i,n) rep(j,i)
	{
		factorize(t[i]-t[j]);
		multiply(fact[i],fact[j]);
		QWQ.swap(cur1);
		multiply(cur,CONST2);
		cur.swap(cur1);
		calcdel(cur,QWQ);
		F[i][j].swap(cur1);
		F[j][i]=F[i][j];
	}
	for(int i=3;i<=n;++i)
	{
		for(int j=2;j<i;++j)
		{
			w[i]=(w[i]-C[i][j]*w[j])%mod2;
		}
		if(w[i]<0)w[i]+=mod2;
	}
	for(int i=0;i<(1<<n);++i)
	{
		pq[i]=pq[i>>1]+(i&1);
		if((i&(i-1))!=0)
		{
			int curt=-1;
			QWQ.clear();
			bool fl=0;
			rep(j,n)
			{
				if((i>>j)&1)
				{
					if(curt==-1) curt=j;
					else if(fl==0)
					{
						QWQ=F[j][curt];fl=true;
					}
					else
					{
						calcgcd(QWQ,F[j][curt]);
						QWQ.swap(cur1);
					}
				}
			}
			ll p=1,q=1,ans;
			rep(j,QWQ.size())
			{
				int P=QWQ[j].fi,K=QWQ[j].se;
				if(K>0)
				rep(k,K) p=p*P%mod2;
				else
				rep(k,-K) q=q*P%mod2;
			}
			ans=p*qkpw(q,mod2-2)%mod2;
			total=(total+ans*w[pq[i]])%mod2;
		}
	}
	cout<<total<<endl;
	return 0;
}
```

---


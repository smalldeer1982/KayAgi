# [THUPC 2025 初赛] 骑行计划

## 题目描述

随着盛夏的到来，小 Rei 迎来了长达 $n$ 天的假期。为了充分利用这段时间，她计划每天骑共享单车出门，享受户外的清新空气。根据小 Rei 的计划，第 $i$ 天她将会骑行 $s_i$ 分钟，而每分钟的骑行费用为 $c$ 元。

为了节约开支，小 Rei 打算购买 APP 中提供的一些骑行卡。她了解到现在有 $m$ 种骑行卡可以购买，其中第 $i$ 种骑行卡的具体信息如下：

- **售价 $w_i$**：每张卡的价格为 $w_i$ 元；
- **有效期 $d_i$**：从购买当天算起，连续 $d_i$ 天内有效；
- **免费时间 $t_i$**：在有效期内，每天的前 $t_i$ 分钟骑行是免费的。

小 Rei 可以多次购买任意一种骑行卡，并且可以在同一时间持有多张有效的骑行卡。如果某天有多张骑行卡同时有效，那么当天可以享受的免费骑行时间为这些卡中 $t_i$ 的**最大值**。超出免费时间的部分，仍然按照每分钟 $c$ 元计算。

小 Rei 希望在假期中尽可能减少骑行的总支出。请你帮助她计算出在假期中骑行的最小总支出是多少。


## 说明/提示

#### 样例 1 解释

小 Rei 的最优策略为：在第一天和第二天购买第二种骑行卡，在第三天购买第一种骑行卡。此时前三天的免费时间为 $30$ 分钟，后两天的免费时间为 $20$ 分钟，还需要在第二天额外支付 $10$ 分钟的骑行费用，在第三天额外支付 20 分钟的骑行费用。购买骑行卡共花费 $15+15+10=40$ 元，额外骑行费用为 $(10 + 20) \times 2 = 60$ 元，总支出为 $100$ 元。可以证明不存在总支出更少的方案，故输出 $100$。

#### 题目来源

来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。

题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。

## 样例 #1

### 输入

```
5 2 2
30 40 50 20 10
10 3 20
15 2 30```

### 输出

```
100```

## 样例 #2

### 输入

```
8 4 1
5 10 9 3 9 8 3 1
11 4 5
12 7 4
10 2 9
5 3 4```

### 输出

```
33```

# 题解

## 作者：_maojun_ (赞：7)

赛场上的想法感觉比较奇怪。

---

如果存在 $(w',d',t')$，$w'\le w,d'\ge d,t'\ge t$，即这个操作就被偏序了，那么不妨把 $(d,t)$ 操作的代价改为 $w'$，因为如果选取的卡没有用满两个限制之一，答案不会更大。

于是可以把卡 $(w,d,t)$ 看作一个 $(d,t)$ 的权值为 $w$ 的点，在矩形上对右上角 chkmin。这样就可以在想要的地方钦定这个操作出来。

然后考虑在 $s_i$ 画成的柱状图上从上往下 dp，记 $f_{t,l,r}$ 表示考虑柱状图 $\ge t$ 的操作，区间 $[l,r]$ 全部满足的最小代价。

设辅助数组 $g_{l,r}$ 表示只考虑 $s_i$ 中 $>t$ 的部分，区间 $[l,r]$ 全部满足的最小代价。

$g$ 的转移：

- 直接用 $c$：

  $$g_{l,r}\gets g_{l,r-1}+\max\{0,a_r-t\}c$$

- 用操作。用 $\le t$ 的操作没用，所以直接从 $f_{t+1}$ 转移过来：

  $$g_{l,r}\gets\min\limits_k\{g_{l,r-k}+f_{t+1,r-k+1,r}\}$$

$f$ 的转移：

- 直接用 $c$：

  $$f_{t,l,r}\gets f_{t,l,r-1}+a_rc$$

  这条转移只在 $t=1$ 合并答案时有用，$t>1$ 时虽然没错，但显然不优。

- 用 $\ge t+1$ 的操作完成：

  $$f_{t,l,r}\gets\min\limits_k\{f_{t,l,r-k}+f_{t+1,r-k+1,r}\}$$

- 新增长度为 $k$，高度为 $t$ 的操作：

  $$f_{t,l,r}\gets\min\limits_k\{f_{t,l,r-k}+w_{k,t}+g_{r-k+1,r}\}$$

  其中 $w_{k,t}$ 就是上述后缀 $\min$ 得到的数组。表示执行长度至少为 $k$，高度至少为 $t$ 的操作的最小代价。

直接转移即可，复杂度 $O(Vn^3)$。

---

代码是赛场上随机写的。

```cpp
typedef long long ll;
const int N=155;
int n,m,c,V=150,a[N],w[N][N];

inline void C(ll&x,ll y){x>y&&(x=y);}
ll f[N][N][N],g[N][N];
inline void main(){
	scanf("%d%d%d",&n,&m,&c);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	memset(w,0x3f,sizeof w);
	for(int v,d,t;m--;){scanf("%d%d%d",&v,&d,&t);w[d][t]=min(w[d][t],v);}
	for(int i=n;i;i--)for(int j=V;j;j--)w[i][j]=min(w[i][j],min(w[i+1][j],w[i][j+1]));
	memset(f,0x3f,sizeof f);
	for(int t=V;t;t--){
		memset(g,0x3f,sizeof g);
		for(int i=1;i<=n;i++)f[t][i][i-1]=g[i][i-1]=0;
		for(int l=1;l<=n;l++)for(int r=l;r<=n;r++){
			g[l][r]=g[l][r-1]+(ll)max(0,a[r]-t)*c;
			for(int k=1;k<=r-l+1;k++)C(g[l][r],g[l][r-k]+f[t+1][r-k+1][r]);
		}
		for(int l=1;l<=n;l++)for(int r=l;r<=n;r++){
			if(t==1)f[t][l][r]=f[t][l][r-1]+(ll)a[r]*c;
			for(int k=1;k<=r-l+1;k++)
				C(f[t][l][r],f[t][l][r-k]+min(w[k][t]+g[r-k+1][r],f[t+1][r-k+1][r]));
		}
	}
	printf("%lld\n",f[1][1][n]);
}
```

---

## 作者：快斗游鹿 (赞：3)

把问题抽象一下：你有一个二维网格图，对于每个 $s_i$，网格图上 $(i,1),(i,2)\dots (i,s_i)$ 这几个格子初始是黑的，其他格子是白的。你可以花费 $w_i$ 的代价染白一个 $d_i\times t_i$ 的矩形，也可以花费 $c$ 的代价染白一个黑色格子。你的目标是把整张网格图染成全白。问最小代价。

线性 dp 并不好处理，因为矩形可能互相包含。考虑区间 dp。从上往下扫，设 $f_{x,l,r}$ 表示不考虑纵坐标 $\le x$ 的部分，染白横坐标 $[l,r]$ 内所有格子需要的最小代价。转移有两种：

- 当前位置及以上被单点染，有 $f_{x,l+1,r}+\max(0,s_l-x)\times c\to f_{x,l,r}$。

- 当前位置不被单点染，枚举覆盖的范围 $len,t$，有转移 $f_{t,l,l+len-1}+f_{x,l+len,r}+g_{len,t}\to f_{x,l,r}$。$g_{i,j}$ 表示染白一个 $i\times j$ 的矩形所需最小代价，$g$ 容易 $O(mns)$ 预处理。

暴力转移大概是 $O(n^5)$ 的，常数写的好一点可以通过。但是可以进一步优化。发现枚举 $t$ 是不必要的，因为你本身就是从上往下扫，固定 $l$ 后，这个过程中可以直接维护 $h_i=\min f_{x,l,i}+g_{i-l+1,x}$。然后就是 $O(n^4)$ 了。

---

## 作者：ty_mxzhn (赞：1)

我蠢了哈哈哈哈。

题意简化一下就变成有一个柱状图要被覆盖，每次可以覆盖一个贴着底部的 $a_i \times b_i$ 的矩形，但是要花费 $c_i$ 元，也可以覆盖一个任意的格子花费 $d$ 元。问你覆盖的最小代价。

考虑区间 dp。设计状态 $f_{x,l,r}$ 表示我们把 $l\sim r$ 的柱形图 $\ge x$ 的部分染完的最小代价。

转移的时候有三种：

1. 裂成两部分。
2. 把剩下的东西全部一个一个覆盖。
3. 染一个 $A\times B$ 的矩形，然后就可以拆成两部分了。

经过一些预处理后，这样子时间复杂度是 $O(n^5)$ 左右。前缀优化可以做到 $O(n^4)$。

---


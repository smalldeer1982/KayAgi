# [THUPC 2025 初赛] 挑战大模型

## 题目背景

由于洛谷评测机太慢，$3s\to 4s$。

## 题目描述

S 是学校里屈指可数的理工天才。两脚分离式的电动平衡车，通过刺激人体上臂、腰部及大腿的运动神经实现控制身体运动的电极装置，以及可以用无人机吊起来的巨幅轻薄柔性屏，只不过是 S 登峰造极的技术水平的冰山一角。这一次，S 又将目光投向了最近很流行的大语言模型（Large Language Model）。

大语言模型是机器学习中的新兴方向，其特点是使用大量的语料来训练语言模型，而正是算法的发展及算力的提升使得训练大语言模型不再捉襟见肘。此外，部分最新的大语言模型不仅支持文本输入输出，更支持音频、图像、视频等格式的多模态输入输出。但是 S 发现，即便是多模态的大语言模型，也不能正确处理一类特殊的图片——随机点立体图（Random Dot Stereogram）。

立体图是使用视错觉造成立体感知的图像，而随机点立体图的原理是通过对随机生成的位图进行平移变换，产生立体视觉。下图是一张简单的随机点立体图。通过将绿色虚线框中的部分向左平移 $2$ 个像素，可以产生虚线框中的部分浮在原图像之上的效果。注意除虚线框及左图中虚线框左侧的红色矩形，右图中虚线框右侧的绿色矩形覆盖的部分之外，图像的外围部分需要保持完全相同，而红色矩形及绿色矩形覆盖的区域则可以分别随机生成。形式化地，如果记左图为 $W$，右图为 $Y$，则将 $W$ 中第 $r_1$ 至 $r_2$ 行，第 $c_1$ 至 $c_2$ 列的矩形子区域平移至 $Y$ 中第 $r_1$ 至 $r_2$ 行，第 $c_1'$ 至 $c_2'$ 列时，需要满足 $r_1\le r_2$，$c_2 - c_1 = c_2'-c_1'\ge 0$ （为 $0$ 时恰好只移动一列），$c_1>c_1'$；只有 $W$ 中的第 $r_1$ 至 $r_2$ 行，第 $c_1'$ 至 $(c_1-1)$ 列及 $Y$ 中的第 $r_1$ 至 $r_2$ 行，第 $(c_2'+1)$ 至 $c_2$ 列部分的像素都可以独立随机生成，无论平移前后矩形区域是否重叠。

![](https://cdn.luogu.com.cn/upload/image_hosting/7vts3y14.png)

S 发现：尽管大语言模型可以识别传统的图像验证码，但是如果使用随机点立体图来生成验证码，那么大语言模型将无法正确识别！为了验证这一发现，S 需要生成不同的随机点立体图来测试大语言模型是否能够识别图像内容。作为计划的第一步，S 想先测试大语言模型能否看出图片中的矩形。具体而言，S 将把两个可以表示为 $01$ 矩阵的 $N$ 行 $M$ 列的位图 $W$ 和 $Y$ 输入到大语言模型中，并询问 $Y$ 是否可以由 $W$ 向左平移某个矩形子区域得到。假设在平移前后，这一矩形子区域都不超出原图片的边界。为了检验大语言模型的输出，S 需要一个程序来计算，对于所有可能的平移距离，右半边的图片 $Y$ 是否可以通过对左半边的图片 $W$ 平移某个矩形子区域得到，并在可行时求出该矩形子区域的最大面积。由于 S 这周末还要陪 M 逛街，所以她想请你帮她实现一下这个程序。


## 说明/提示

#### 样例解释 1

当固定平移距离为 $1$ 时，可能的最大矩形子区域在 $W$ 中对应第 $2$ 行至第 $4$ 行，第 $2$ 列至第 $4$ 列的矩形区域，其平移后在 $Y$ 中为第 $2$ 行至第 $4$ 行，第 $1$ 列至第 $3$ 列。

如果假设平移距离为 $2$，则可能的最大矩形子区域为 $W$ 中第 $3$ 列整列对应的矩形区域。

可以证明，不存在任何平移距离为 $3$ 的平移方法。

#### 样例解释 2

该样例即为题面所附图片。

#### 数据范围

对于所有数据，保证 $1\le N, M\le 500$，输入的 $W$ 和 $Y$ 是 $N$ 行 $M$ 列仅含 `0` 和 `1` 的字符矩阵。

#### 题目来源

来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。

题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。

## 样例 #1

### 输入

```
4 4
0100
0110
1001
1000
0100
1100
0011
0000```

### 输出

```
9 4 -1```

## 样例 #2

### 输入

```
11 11
01010100100
10111011000
10001010110
11011101110
10110010010
00100010010
11011010011
01001111001
00111000111
10010011101
00101110110
01010100100
10111011000
10001010110
11110111010
10001000010
00001001110
11101000111
01111100101
00111000111
10010011101
00101110110```

### 输出

```
-1 25 -1 -1 -1 -1 -1 -1 -1 -1```

# 题解

## 作者：Inui_Sana (赞：1)

不算难吧，为啥场上没多少人做（

先翻译一下题意：

>定义对 01 矩阵的一个操作 $(x_1,y_1,x_2,y_2,k)$ 为，向 $x\in[x_1,x_2],y\in[y_1,y_2]$ 的子矩阵内任意填 01，然后将原子矩阵的元素向左平移 $k$ 个单位，覆盖在矩阵上。
>
>给你两个 01 矩阵 $A,B$。你要对于每一个 $k\in [1,m]$，求出有多少个子矩形，使得对 $A$ 进行操作 $(x_1,y_1,x_2,y_2,k)$ 后，矩阵等于 $B$。

分析一下这个操作，矩形会变成三个不同的部分：在平移后的子矩阵中的，在原子矩阵但是不在平移后的子矩阵中的，完全没有影响的。

- 第一部分，要求平移后对应位置相同。
- 第二部分，没有任何限制。
- 第三部分，要求原本 $A$ 和 $B$ 这些位置就相同。

于是对于一个操作合法，也就是两个限制：

- 平移后子矩形对应位置相同。
- 影响到的位置包含了所有 $A,B$ 不同的位置。

不难发现第二个限制就是对 $x_1,y_1,x_2,y_2$ 有一些限制。于是考虑第一个限制。

考虑枚举 $k$，处理出 $c_{i,j}=[a_{i,j}=b_{i,j-k}]$。那么第一个限制就变成了 $c_{i,j}$ 中，这个位置的矩形全为 $1$。即问题变成了求最大全 $1$ 子矩阵大小。

这是一个经典问题。考虑枚举 $y_1$，对于全部 $x_1$ 求出 $f_{x_1}$ 表示第 $x_1$ 行中，以 $(x_1,y_1)$ 为左端点的最长全 $1$ 段长度。然后对 $f$ 单调栈求出 $l_i,r_i$ 表示左边第一个 $f_j<f_i$ 的 $j$ 和右边第一个 $f_j\le f_i$ 的 $j$。那么答案就是 $\max(r_i-l_i-1)\times f_i$。

但是一个问题是这里有 $x,y$ 的限制。会不会有影响？但是容易发现，在满足对应位置相等的条件下，这个子矩阵的大小更大，在 $x,y$ 的限制中是不劣的，因为影响到的元素变多了。所以只用每次更新答案的时候判断 $(i,l_i+1),(f_i,r_i-1)$ 这个矩阵是否满足条件即可。

还有一点细节：如果移动前后的矩形不交，在一些不太精细的实现中（比如我的），要特判两个矩阵中间几列有不同元素的情况。

时间复杂度 $O(n^3)$。

code：

```cpp
int n,m,top,a[N][N],b[N][N],c[N][N],f[N],g[N],h[N],st[N];
int pd[N];
char s[N];
void Yorushika(){
	read(n,m);
	rep(i,1,n){
		scanf("%s",s+1);
		rep(j,1,m){
			a[i][j]=s[j]-'0';
		}
	}
	int x1=inf,x2=-inf,y1=inf,y2=-inf;
	rep(i,1,n){
		scanf("%s",s+1);
		rep(j,1,m){
			b[i][j]=s[j]-'0';
			if(a[i][j]!=b[i][j]){
				x1=min(x1,i),y1=min(y1,j);
				x2=max(x2,i),y2=max(y2,j);
				pd[j]=1;
			}
		}
	}
	rep(i,1,m){
		pd[i]+=pd[i-1];
	}
	rep(k,1,m-1){
		mems(c,0);
		rep(i,1,n){
			rep(j,k+1,m){
				c[i][j]=a[i][j]==b[i][j-k];
			}
		}
		mems(f,0),f[0]=f[n+1]=-inf;
		int ans=-1;
		drep(j,m,k+1){
			rep(i,1,n){
				if(c[i][j]){
					f[i]++;
				}else{
					f[i]=0;
				}
			}
			st[top=1]=0;
			rep(i,1,n){
				while(top&&f[st[top]]>=f[i]){
					top--;
				}
				g[i]=st[top]+1;
				st[++top]=i;
			}
			st[top=1]=n+1;
			drep(i,n,1){
				while(top&&f[st[top]]>=f[i]){
					top--;
				}
				h[i]=st[top]-1;
				st[++top]=i;
			}
			rep(i,1,n){
				if(g[i]<=x1&&h[i]>=x2&&j-k<=y1&&j+f[i]>y2&&f[i]&&pd[j-1]-pd[j+f[i]-1-k]<=0){
					ans=max(ans,(h[i]-g[i]+1)*f[i]);
				}
			}
		}
		printf("%d ",ans?ans:-1);
	}
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---


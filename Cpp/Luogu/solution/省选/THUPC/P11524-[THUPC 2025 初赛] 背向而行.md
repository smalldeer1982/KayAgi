# [THUPC 2025 初赛] 背向而行

## 题目描述

有 $m$ 堆积木，其中第 $i$ 堆积木位于坐标 $x_i$ 的位置，有 $c_i$ 块。

反复执行如下操作，直至无法操作：

- 如果存在两块积木坐标相同，则找到满足条件的积木中坐标最小的两块，将一块坐标减 $1$，另一块坐标加 $1$，

可以证明在有限次操作之后，所有积木的坐标都会不同，此时无法进行操作。

多次询问，每次给定正整数 $k$，问最后左数第 $k$ 块积木的位置。保证询问的 $k$ 严格递增。

## 说明/提示

我们用长度为 5 的单调不降数字字符串描述从左往右五块积木的位置，那么操作过程如下所示：

$33344 \to 23444 \to 23345 \to 22445 \to 13445 \to 13355 \to 12455 \to 12446 \to 12356$

最终第二块积木坐标为 2，第四块积木坐标为 5。

#### 题目来源

来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。

题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。

## 样例 #1

### 输入

```
2
3 3
4 2
2
2
4```

### 输出

```
2
5```

# 题解

## 作者：NobodyThere (赞：8)

~~是的，我只给我的队伍贡献了 E 题，可见我严重拖累了整支队伍（~~

试试堆成一列会怎么样。打表观察或者稍微想一下，不难发现：

- 当 $c$ 为奇数时，最终坐标是一段连续以 $x$ 为中心的区间。
- 当 $c$ 为偶数时，最终坐标是一段“几乎连续”的以 $x$ 为中心的区间，其中缺失的恰好为 $x$。

猜想：如果积木的初始位置“足够连续”，那么它们的最终坐标会构成一段“几乎连续”的区间，并且有至多一个坐标的空缺。我们用三元组 $(l,r,p)$ 刻画空缺坐标为 $p$ 的区间 $[l,r]$。（方便起见，若元素间没有空缺，不妨视为空缺在最右边，如 $[1,2,4,5]$ 视为 $(1,5,3)$，而 $[1,2,3,4]$ 视为 $(1,5,5)$）

先考虑如何求一个“足够连续”的段的最终形态：注意到坐标总和 $s=\sum x_i$ 在操作过程中是不变的，因此只要 $s$ 与积木个数 $c$ 固定，$(l,r,p)$ 就是固定的。只需从 $c$ 的奇偶性以及 $\left\lfloor\dfrac sc\right\rfloor, s\bmod c$ 的值考虑即可求出 $(l,r,p)$，具体公式不再赘述。（如果对此有疑惑，可以自行尝试打表找规律，或者参考下面给出的代码）

那么如何知道一个段是否“足够连续”呢？考虑一开始将每一列视作一个单独的连续段，对这些连续段分别求出预期的 $(l,r,p)$，如果对应的区间都不交，那么显然各自为不同的连续段；否则，有交的连续段应合并，视为同一连续段。直接维护一个当前所有连续段的栈，从左到右检查合并即可求出最终形态。

猜想成立，即一个连续段最终构成“几乎连续”的区间的原因如下：

- 首先，如果一个段已经达成了“几乎连续”，那么最终它也是“几乎连续”的。

- 其次，当两个连续段发生干涉，即这两个连续段各有至少一块积木相遇（垒到同一个位置）时，我们总可以认为两个连续段是“几乎连续”的区间，其中左边有至多一个“不活跃”的断点（取决于合并方向；“活跃”的断点是指与当前操作相邻的断点），而右边没有“不活跃”的断点；于是这个处于交界处的“活跃”断点就会吞噬左边“不活跃”的断点（如果有的话）。于是新的连续段在最终时刻也是“几乎连续”的。

于是做法的正确性也得到了保障。复杂度线性。

附上本题主要代码：

```cpp
int m, q;
int X[N], C[N], K[N];

 // getres 用于求出三元组 (l,r,p)；t 是坐标总和 s，且保证在 [0,c) 的范围内；c 是积木总个数
inline std::tuple<int, int, int> getres(int t, int c) {
    int l, r, p;
    if(c & 1) {
        l = -(c / 2), r = l + c, p = r - t;
    } else {
        if(t < c / 2) l = -(c / 2), r = l + c, p = -t;
        else l = -(c / 2) + 1, r = l + c, p = c + 1 - t;
    }
    return std::make_tuple(l, r, p);
}
struct node {
    int l, r, p, c;
    ll s;
    node() {}
    node(int _c, ll _s) : c(_c), s(_s) {
        int dt = s / c, t = s % c;
        std::tie(l, r, p) = getres(t, c);
        l += dt, r += dt, p += dt;
    }
    node(int _l, int _r, int _p, int _c, ll _s) : l(_l), r(_r), p(_p), c(_c), s(_s) {}
} stk[N];
node operator + (node x, node y) {
    return node(x.c + y.c, x.s + y.s);
}
int tot;
int main() {
    read(m);
    for(int i = 1; i <= m; i++)
        read(X[i], C[i]);
    read(q);
    for(int i = 1; i <= q; i++)
        read(K[i]);
    for(int i = 1; i <= m; i++) {
        auto t = node(C[i], 1ll * X[i] * C[i]);
        while(tot && stk[tot].r >= t.l) {
            t = stk[tot--] + t;
        }
        stk[++tot] = t;
    }
    int cur = 0;
    for(int i = 1, j = 1; i <= q; i++) {
        while(K[i] - cur > stk[j].c) {
            cur += stk[j++].c;
        }
        int qwq = stk[j].l + K[i] - cur - 1;
        if(qwq >= stk[j].p) ++qwq;
        write(qwq, '\n');
    }
    return 0;
}
```

---

## 作者：wwwwwza (赞：0)

若只有一堆积木时，题中的操作就是将满足条件的积木均匀地延中间位置铺开。那如果有几堆积木互相影响时，简单构思并大胆猜测，它们的坐标可以刻画成一段连续的区间且空了一个位置。

不论如何进行操作，所有积木的位置之和是一定的。所以对于一堆或几堆混在一起的积木，都可以用一个三元组 $(l,r,p)$ 来刻画，表示这些积木的位置填满了区间 $[l,r]$ 且除去 $p$ 的所有位置。特别地，如果一堆积木能完全填满区间 $[l,r]$，就用三元组 $(l,r+1,r+1) 来刻画$。

然后就是计算出三元组的具体数值，设一堆积木有 $num$ 个，位置之和为 $sum$。先判断是否能填满整个区间，即满足如下式子。

$$
\left\{\begin{matrix}
r-l+1=num 
\\
\frac{(l+r)\times(r-l+1)}{2}=sum
\end{matrix}\right.
$$
解得
$$
\left\{\begin{matrix}
l=\frac{\frac{2\times sum}{num}-num+1}{2}
\\
r=l+num-1
\end{matrix}\right.
$$

判断 $l,r$ 是否为整数即可。

否则要解如下式子。

$$
\left\{\begin{matrix}
r-l+1=num+1
\\
\frac{(l+r)\times(r-l+1)}{2}=sum+p
\end{matrix}\right.
$$

这个式子不太好解，就设 $p=l+k(0\le k<num)$。

可解得
$$
\left\{\begin{matrix}
l=\frac{\frac{2\times(sum+k)}{num}-num-1}{2}
\\
r=l+num
\end{matrix}\right.
$$

因为 $0\le k<num$，所以可以将 $k$ 忽略不计，将 $l$ 左右浮动一下即可找到正确的解。

若两堆积木混到了一起，就重新计算一起的 $(l,r,p)$，用栈来维护。

询问的时候前缀和维护一下即可。

时间复杂度 $O(m+q)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+5;
int n,x,c,q,tot=0,pre[N];
struct node{
	int l,r,p;
}st[N];
node calc(int num,int sum){
	if((2*sum)%num==0&&(2*sum/num-num+1)%2==0){
		int l=(2*sum/num-num+1)/2,r=l+num-1;
		return {l,r+1,r+1};
	}
	int k=(2*sum/num-num-1)/2;
	for(int l=k-1;l<=k+1;l++){
		int r=l+num,p=(l+r)*(r-l+1)/2-sum;
		if(l<=p&&p<=r)return {l,r,p};
	}
	return {0,0,0};
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin >>n;
	for(int i=1;i<=n;i++){
		cin >>x>>c;
		node cnt=calc(c,x*c);
		while(tot&&cnt.l<=st[tot].r){
			int num=(cnt.r-cnt.l)+(st[tot].r-st[tot].l);
			int sum=(cnt.r-cnt.l+1)*(cnt.l+cnt.r)/2-cnt.p+
			(st[tot].r-st[tot].l+1)*(st[tot].l+st[tot].r)/2-st[tot].p;
			cnt=calc(num,sum),tot--;
		}
		st[++tot]=cnt;
	}
	for(int i=1;i<=tot;i++)pre[i]=pre[i-1]+(st[i].r-st[i].l); 
	cin >>q;
	int id=1;
	while(q--){
		cin >>x;
		while(x>pre[id])id++;
		x-=pre[id-1];
		int ans=st[id].l+x-1+(st[id].l+x-1>=st[id].p);
		cout <<ans<<"\n";
	}
	return 0;
}
```

---


# [THUPC 2025 决赛] 三元链

## 题目描述


给定正整数 $n,k$，请在一个 $n\times n$ 的网格中将 $kn$ 个方格染成黑色，其余方格染成白色，满足：

- 在水平或竖直方向上不存在连续的三个同色格。具体地：

  1. 不存在 $1\le i\le n,1\le j \le n-2$ 满足坐标为 $(i,j),(i,j+1),(i,j+2)$ 的格子均为黑色或均为白色。
  2. 不存在 $1\le i\le n-2,1\le j \le n$ 满足坐标为 $(i,j),(i+1,j),(i+2,j)$ 的格子均为黑色或均为白色。
  
- 每列中有恰好 $k$ 个黑色格。

- 对于任意 $i=1,2,\dots,k$，任意相邻的两列中从上至下第 $i$ 个黑色格的行坐标之差不超过 $1$。具体地，记第 $j$ 列的黑色格的坐标分别为 $(x_{1,j},j),(x_{2,j},j),\dots,(x_{k,j},j)$，其中 $x_{1,j}<x_{2,j}<\dots<x_{k,j}$，那么对于 $1\le i\le k,1\le j< m$ 有 $|x_{i,j}-x_{i,j+1}|\le 1$。

给出一种合法的方案，或判定无解。


## 说明/提示

### 样例 #1 解释


对于第一组数据，以下为若干不符合条件的示例：

![](https://cdn.luogu.com.cn/upload/image_hosting/7tghzsoe.png)

示例 $1$ 中左下角有连续的三个白色格，示例 $2$ 中第一列与第四列黑色格数量不正确，示例 $3$ 中左上角有连续的三个黑色格，示例 $4$ 中第三、四列的第二个黑色格行坐标之差大于 $1$。

对于第二组数据，容易发现不存在合法的染色方案。

对于第三组数据，下图中不同方位的黑色格用不同颜色标注后易见答案的合法性：

![](https://cdn.luogu.com.cn/upload/image_hosting/v4bhosde.png)


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
3
4 2
6 1
9 5
```

### 输出

```
Yes
#..#
.##.
.##.
#..#
No
Yes
.#.#..##.
#.#.##..#
#.##..##.
.#..##.##
#..##.#.#
.##..#.#.
##.##.#.#
#.##.##..
.##.##.##
```

# 题解

## 作者：WYXkk (赞：13)

为了炫耀我拿下了本题赛时一血，我决定跑来写个题解。

---

题目描述看似很复杂，实际上也确实有点复杂。但是如果你玩过[《14种扫雷变体2》](https://store.steampowered.com/app/2631960/142/)，你会在看到题目后立刻意识到这就是 [2T] 无三连 + [2B] 桥，虽然这对解题并没有太大帮助。实际上出题人就是玩家群群友，此前还在致理杯 div2 上放了一个 [1S] 蛇 + [2B] 桥。

样例解释提供了一个直观理解后两个条件的方式：黑格形成从左侧到右侧的 $k$ 座桥，每座桥的相邻两个雷水平或斜向相邻。同时，通过观察样例（其实不看也不是很难想到），可以发现下面两个结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/e7qajr4r.png)

这两个结构的密铺都满足条件（纵向必须在整数份处截断）且可以拼接，这样就能对很多组 $(n,k)$ 构造出一个解。比如一个 $n=10,k=6$ 的解长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/yr9xhuwy.png)

如果一个这样的解使用了 $a$ 份第一个结构和 $b$ 份第二个结构，那么 $n=3a+2b,k=2a+b$，即 $a=2k-n,b=2n-3k$。于是，如果 $2k-n\ge 0$ 且 $2n-3k\ge0$，那么上面的结构的组合就可以给出一个解。**大胆猜测其他情况都无解即可通过本题。** 代码较为简单，这里略去。但是由于这是一份题解，这里不得不给出证明。

---

每列的 $n$ 格中都有 $k$ 格染黑。在无三连的限制下，每三格最多只能染黑两格。

- 如果 $n=3a$，那么自然 $k\le 2a$。

- 如果 $n=3a+1$，那么 $k\le 2a+1$，且 $k=2a+1$ 时，每一列的最后一格都必须染黑，在 $n\ge3$ 时就会出现横向黑色三连，所以 $k\le 2a$。

- 如果 $n=3a+2$，那么 $k\le 2a+2$，且 $k=2a+2$ 时，每一列的最后一格都必须染黑，在 $n\ge3$ 时就会出现横向黑色三连，所以 $k\le 2a+1$。

综上所述，有解时必然 $2n-3k\ge0$。

---

第一座桥不会经过 $(3\sim n,2\sim n-1)$。否则如果它经过了其中的 $(a,b)$，由于纵向一次只能上下一格，它就无法经过 $(1,b-1\sim b+1)$，从而出现了白色三连。这在玩家群里有个名字，叫“光锥定式”。如果你通过一些正确的相对论科普知道了光锥的含义，你应该会觉得这相当形象。

再用一次光锥定式，可以得到第二座桥不会经过 $(5\sim n,3\sim n-2)$，否则第三行会出现白色三连。同理，第三座桥不会经过 $(7\sim n,4\sim n-3)$。以此类推，第 $k-1$ 座桥不会经过 $(2k-1\sim n,k\sim n+1-k)$。

再反过来考虑最后一座桥，它不会经过 $(1\sim n-2,2\sim n-1)$，否则最后一行会出现白色三连。在 $k\ge 2$ 时，如果 $n>2k$，即 $n\ge 2k+1$，则 $(n-2,k\sim k+2)$ 既无法被前 $k-1$ 座桥覆盖也无法被被最后一座桥覆盖，从而出现了白色三连。在 $k=1$ 时，由于 $n\ge 4$，这座桥无法经过 $(1\sim n,2)$，矛盾。所以，有解时必然 $2k-n\ge0$。

---

本题并未涉及 $n\le 3$。上面的两个结论都部分依赖 $n\ge4$，所以在更小的时候是有反例的。具体而言，$(n,k)=(3,1),(2,2),(2,0),(1,1),(1,0)$ 并不满足上面两个条件，但是有解。构造非常简单，略。

---

这就是玩[《14种扫雷变体》](https://store.steampowered.com/app/1865060/14/)和[《14种扫雷变体2》](https://store.steampowered.com/app/2631960/142/)给我带来的自信.jpg

---

## 作者：Egg_eating_master (赞：3)

考虑令黑格在第一列平均分配，即把第一列的第 $i$ 个黑格放在 $(\lfloor\frac{i\cdot n}{k}\rfloor,1)$ 上。然后令第 $i$ 列是第 $i-1$ 列向下做一次循环移位后的结果。大胆猜测只要这样做出来的网格不合法就无解。

这样做可以非常自然地处理 corner case！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1005;
int T, n, k;
int a[maxn][maxn];
void work() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            a[i][j] = 0;
    for (int i = 1; i <= k; i++) a[i * n / k][1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j < n; j++) a[j][i] = a[j + 1][i - 1];
        a[n][i] = a[1][i - 1];
    }
    for (int i = 1; i <= n - 2; i++)
        for (int j = 1; j <= n; j++)
            if (a[i][j] == a[i + 1][j] && a[i][j] == a[i + 2][j]) {cout << "No" << '\n'; return;}
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n - 2; j++)
            if (a[i][j] == a[i][j + 1] && a[i][j] == a[i][j + 2]) {cout << "No" << '\n'; return;}
    for (int i = 1; i < n; i++) {
        int p = 1, q = 1;
        for (int j = 1; j <= k; j++) {
            while (a[p][i] == 0) p++;
            while (a[q][i + 1] == 0) q++;
            if (abs(p - q) > 1) {cout << "No" << '\n'; return;}
        }
    }
    cout << "Yes" << '\n';
    for (int i = 1; i <= n; i++, cout << '\n')
        for (int j = 1; j <= n; j++)
            cout << (a[i][j] ? '#' : '.');
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> T;
    while (T--) work();
    return 0;
}
```

---


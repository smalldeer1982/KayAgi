# [THUPC 2025 决赛] 喜爱之钥

## 题目描述


玩具箱承载着幼时的欢乐。喜爱、软弱、苦恼、希望……当沉睡的玩具箱再次被打开时，重见天日的宝物将会带来怎样的惊喜？

M 就有一个这样的玩具箱，那是身为宝石设计师的母亲送给她的生日礼物。精心打磨的宝石像夜空中的繁星一般点缀着玩具箱，而玩具箱上更有造型各异的 $L$ 把锁严防死守着宝贝女儿的小宇宙：花朵发夹、羽毛笔、字母 M 造型的气球……每一件都浓缩着 M 的回忆。

前几天，M 在整理房间时翻出了这个玩具箱，以及一串专门为这个玩具箱打造的钥匙。钥匙串上共挂着 $(L+K)$ 把钥匙，其中有 $L$ 把钥匙，每把分别可以打开其中一把锁；而剩下的 $K$ 把钥匙仅仅是增加暴力破解难度的干扰项。为了方便记忆，M 的母亲在设计钥匙时，给每一把钥匙镶嵌了一颗不同的宝石，可惜 M 已经忘记了正确的对应关系。

“……所以我只好向大家求助了。” M 说着把手里的钥匙串摆在了桌面上。

K 拿起了钥匙串仔细端详。“仅凭外表似乎无法推断出任何有用的信息，恐怕只能逐把尝试。”

虽然大家都愿意帮助 M，但是面对这么多把钥匙，不免感到无从下手。看着大家的反应，T 提议：“要不我们来玩个游戏吧。每个人按顺序试一把钥匙，最终打开最多锁的人最厉害。”

包括 M 在内，总共有 $N$ 个人按相同的顺序轮流尝试解锁玩具箱，直到 $L$ 把锁都被打开。每人每次操作时只选择一把钥匙，且只用这把钥匙试着打开其中一把锁。为了尽快打开玩具箱，所有人的策略都是尝试能最大化这次选择的钥匙打开这次选择的锁的概率的组合；如果有多种概率最大的钥匙和锁的组合，则等概率地选取任意一种这样的组合。显然，如果之前成功用一把钥匙打开了一把锁，那么之后所有人在尝试的时候，都不会再选择相同的钥匙或者相同的锁。

假设在最开始的时候，任意一把钥匙打开任意一把锁的概率都相等。如果每个人都能根据之前尝试的所有钥匙和锁的组合，选择最优的组合进行尝试，那么每个人成功解锁的期望次数分别是多少？

## 说明/提示

### 样例 #1 解释


当只有 $1$ 把锁时，每个人的策略都是随机选择一把尚未有人试过的钥匙开锁。由于总共有 $1+4=5$ 把钥匙，每个人打开门的概率分别为 $2/5, 2/5, 1/5$，这也是每个人成功解锁的期望次数。

### 样例 #2 解释


此时有 $2$ 把锁和 $2$ 把钥匙，每把钥匙恰好可以打开其中一把锁。由于没有任何已知信息，第 $1$ 个人只能随机选择一把钥匙和一把锁，此时成功解锁的概率为 $1/2$。

- 如果第 $1$ 个人打开了这把锁，那么第 $2$ 个人可以直接用另外一把钥匙打开另外一把锁。

- 如果第 $1$ 个人没有打开这把锁，那么第 $1$ 个人选择的钥匙一定对应另一把锁，且另一把钥匙一定可以打开第 $1$ 个人选择的锁。根据这个信息，第 $2$ 个人和第 $3$ 个人可以各打开一把锁。

综上所述，每个人成功解锁的期望次数分别为

$$
\begin{split}
E_1 &= \frac{1}{2}\times 1 + \frac{1}{2}\times 0 = \frac{1}{2} \equiv 500,000,004 \pmod {10^9+7},\\
E_2 &= \frac{1}{2}\times 1 + \frac{1}{2} \times 1 = 1,\\
E_3 &= \frac{1}{2}\times 0 + \frac{1}{2} \times 1 = \frac{1}{2} \equiv 500,000,004\pmod {10^9+7}.
\end{split}
$$


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
3 1 4
```

### 输出

```
800000006 800000006 400000003
```

## 样例 #2

### 输入

```
3 2 0
```

### 输出

```
500000004 1 500000004
```

## 样例 #3

### 输入

```
25 2 5
```

### 输出

```
142857144 166666668 615646263 639455787 234126986 257936510 195918369 502040820 478316330 81264173 190523433 471438023 23809524 0 0 0 0 0 0 0 0 0 0 0 0
```

## 样例 #4

### 输入

```
4 102 9
```

### 输出

```
568832210 85779764 969938175 375449967
```

# 题解

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P12061)

场上被三元链硬控导致没时间做这道题了！
## 题意
有 $k$ 个人进行游戏，初始局面有 $n$ 把锁以及只能打开对应锁的 $n$ 把钥匙，此外还有 $m$ 把无法打开任何锁的假钥匙，所有 $n+m$ 把无法分辨的钥匙被均匀随机地打乱。

现在 $k$ 人轮流进行操作，每一人可选择一把钥匙与一把锁进行尝试，在场所有人均可知道尝试结果。每一把锁只能打开一次，当所有锁均被打开后游戏结束。

每人的操作策略均为选取最大概率可开锁的组合。若有多组组合均有最大概率，则均匀随机地采用一种。

问游戏过程中，每个人打开的锁的数量的期望，对 $10^9+7$ 取模。

$n\le 5000$，$m,k\le 50$。
## 题解

不妨将概率问题转为计数问题以方便讨论。补上 $m$ 把假锁，与假钥匙一一对应，则每个 $1\sim n+m$ 的排列 $p_{1\sim n+m}$ 均描述一个状态，其中第 $i$ 把锁对应第 $p_i$ 把钥匙。

初始时任意一把锁打开任意一把钥匙的概率均为 $\dfrac{1}{n+m}$，不妨记第一个人用第一个钥匙开第一把锁并失败，这提供了 $p_1\ne 1$ 的信息。

接下来第二个人：

- 用第 $x$ 把钥匙开第一把锁，概率为 $\dfrac{1}{n+m-1}$，这代表 $p_1=x$ 的概率；
- 用第一把钥匙开第 $y$ 把锁，概率为 $\dfrac{1}{n+m-1}$，这代表 $p_y=1$ 的概率；
- 用第 $x$ 把钥匙开第 $y$ 把锁，概率为 $\dfrac{n+m-2}{(n+m-1)^2}$，这代表 $p_y=x$ 的概率，可通过容斥计算。

第二个人有 $n+m-1$ 种方案使用某把钥匙开第一把锁，$n-1$ 种方案使用第一把要是开另一把锁，故使用两种策略的概率分别可简单计算。

假设第二个人用第二把钥匙开第一把锁且失败，第三个人就只会继续用第三把钥匙开第一把锁，成功概率为 $\dfrac{1}{n+m-2}$。依此类推，接下来所有人会一直尝试解锁第一把锁。

设 $f_{n,m,x}$ 表示现有 $n$ 个锁以及 $n+m$ 个钥匙，当前轮到第 $x$ 个人操作。

- 若逐把试钥匙，一定会在 $n+m$ 次尝试中成功，概率为 $\dfrac{n+m-1}{2n+m-2}\cdot \dfrac{1}{n+m}$；
- 若逐把试锁：
	- 若在 $n$ 次尝试中成功，则概率为 $\dfrac{n-1}{2n+m-2}\cdot\dfrac{1}{n+m}$；
    - 否则该钥匙必定为假钥匙，概率为 $\dfrac{n-1}{2n+m-2}\cdot \dfrac{m}{n+m}$。

上述概率均可用排列计数方式来理解。前缀和优化转移到对应的状态并累加入对应状态答案即可。

无论成功还是失败，其都变为一个不含任何额外信息的子状态，可以转移。

时间复杂度 $O(nmk)$。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
#define pii pair<int,int>
#define mpr make_pair
#define fir first
#define sec second
const int N=5e3+10,M=50+5,mod=1e9+7;
inline int add(int x,int y){ return x+y>=mod?x+y-mod:x+y; }
inline int dec(int x,int y){ return x>=y?x-y:x-y+mod; }
inline void inc(int &x,int y){ x=add(x,y); }
int n,m,k,inv[N*2+M],f[N][M][M],fp[N][M][M],ansp[M];
inline void Prefix(int n){
	inv[1]=1;
	for(int i=2;i<=n;i++)
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
}
inline void add(int n,int m,int l,int r,int v){
	if(l>r||!v) return ;
	inc(fp[n][m][l+1],v),inc(fp[n][m][r+2],mod-v);
	if(r==k-1) inc(fp[n][m][0],v),inc(fp[n][m][1],mod-v);
	inc(ansp[l],v),inc(ansp[r+1],mod-v);
}
inline void Add(int n,int m,int x,int c,int v){
	if(x+c<=k) return add(n,m,x,x+c-1,v);
	add(n,m,x,k-1,v),c-=k-x;
	int cp=c/k;
	add(n,m,0,k-1,1ll*cp*v%mod);
	c-=cp*k;
	add(n,m,0,c-1,v);
}
int main(){
	k=read(),n=read(),m=read();
	Prefix(n*2+m);
	f[n][m][0]=1; 
	for(int i=n;i;i--)
		for(int j=m;j>=0;j--)
			for(int x=0;x<k;x++){
				inc(fp[i][j][x+1],fp[i][j][x]);
				int v=add(f[i][j][x],fp[i][j][x]);
				if(!v) continue;
				Add(i-1,j,x,i,1ll*v*inv[i+j]%mod);
				int p=(x+i)%k;
				if(j){
					inc(f[i][j-1][p],1ll*v*(i-1)%mod*j%mod*inv[2*i+j-2]%mod*inv[i+j]%mod);
					Add(i-1,j,p,j,1ll*v*inv[i+j]%mod*(i+j-1)%mod*inv[2*i+j-2]%mod);
				}
			}
	for(int i=0,s=0;i<k;i++)
		inc(s,ansp[i]),write(s),putc(' ');
	flush();
}
```

---

## 作者：UniGravity (赞：4)

记当前有 $a$ 个锁，$a+b$ 个钥匙。

考虑第一个人。每对钥匙和锁的配对成功概率都是 $\frac1{a+b}$。不妨假设第一个人选了第一个锁和钥匙。

接下来考虑第一个人没选中轮到第二个人，有三种可能：

* 选择第一个锁和任意编号不为一的钥匙。发现相当于配对的钥匙去掉选过的可能有 $a+b-1$ 种选择，成功概率为 $\frac1{a+b-1}$。
* 选择第一个钥匙和任意编号不为一的锁。这里还需要考虑是假钥匙的概率可能因为之前不匹配而发生变化。一种理解方式是加入 $b$ 个假锁与假钥匙配对，发现概率相当于仍然是 $\frac1{a+b-1}$。严谨的通过贝叶斯定理的证明可以看 [CF 上的题解](https://codeforces.com/blog/entry/141053)。
* 钥匙和锁都不选第一个。此时相当于对于某个锁仍然有 $a+b$ 个钥匙可能与其匹配，排除掉与第一个钥匙匹配的结果，成功的概率为 $(1-\frac1{a+b-1})\frac1{a+b-1}=\frac{a+b-2}{(a+b-1)^2}<\frac1{a+b-1}$，必定更劣。

因此我们发现实际上第二个人绝对会选择第一个锁或钥匙（分别简记为选锁和钥匙）然后任意选择其它的配对。由于每个人会等概率选取所有成功概率相同的操作，并且选钥匙则有 $a-1$ 个锁配对，选锁则有 $a+b-1$ 个钥匙配对。所以选钥匙和锁的概率分别为 $\frac{a-1}{2a+b-2}$ 和 $\frac{a+b-1}{2a+b-2}$ 种方案。

轮到第二个人且选中的概率是 $\frac{a+b-1}{a+b}\cdot\frac1{a+b-1}=\frac1{a+b}$，和第一个人相同。

考虑第三个人，还是三种情况。例如如果还是第一个锁与其它钥匙配对，则概率为 $\frac1{a+b-2}$，并且可以证明这个方案是唯一最大的。感性理解可以认为其利用了最多的信息。第一个钥匙和锁配对同理。因此轮到第三个人且选中的概率同样是 $\frac1{a+b}$。

于是发现从第二个人之后，每个人都会重复和上个人一样的操作。考虑到某个人成功配对了，我们将配对的钥匙和锁去掉后发现没有任何关于剩下的东西的信息，即之前的操作不会干扰后续的概率！因此我们就把问题转化为 $a\gets a-1$，$b$ 不变的情况。

另一种情况是第二个人选了钥匙后到第 $a$ 个人仍然没有配对成功，那么说明是假钥匙。只将这个钥匙去掉，前后仍然没有影响，因此转移到 $a$ 不变，$b\gets b-1$ 的子问题。注意的是转化后的问题人的编号会发生循环移位。

接下来就可以 dp 了：记 $f_{a,b,i}$ 表示 $a$ 个锁，$a+b$ 个钥匙，第 $i$ 个人期望成功多少次。

一种情况是从 $f_{a-1,b,i-j}$（$i-j$ 是在模 $n$ 意义下的）转移过来，选钥匙则 $j$ 的上界为 $a$，否则为 $a+b$。转移的概率为 $\frac1{a+b}$ 乘上第二个人选钥匙或锁的概率。可以前缀和优化转移。

另一种情况只在选钥匙时生效，即 $\frac b{a+b}$ 的概率转移到 $f_{a,b-1,i-a}$。

同时还要加上恰好在 $i$ 人上完成配对的概率，为 $\frac{\sum_{c=0}^{a-1}[i==c]}{a+b}$，容易 $O(1)$ 计算。

因此我们发现 dp 可以做到 $O(nlk)$，可以通过此题。

```cpp
// Code by UniGravity
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define forto(i,a,b) for(int i=(a),_##i(b);i<=_##i;i++)
#define forbk(i,a,b) for(int i=(a),_##i(b);i>=_##i;i--)
#define forv(i,a) for(int i(0),_##i(a);i<_##i;i++)
#define fst first
#define snd second
#define il inline
#define eb emplace_back
#define mkp make_pair
using namespace std;
il int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||'9'<c)c=='-'?(f=-1):0,c=getchar();
    while('0'<=c&&c<='9')x=x*10+c-'0',c=getchar();
    return x*f;
}

const int P=1000000007;
int inv[20005];
il void init(int n){
    inv[1]=1;forto(i,2,n)inv[i]=1ll*(P-P/i)*inv[P%i]%P;
}
int n,l,k,f[5005][55][55];
il void addto(int &x,int y){x+=y;if(x>=P)x-=P;}
il void delto(int &x,int y){x-=y;if(x<0)x+=P;}
il void work(){
    n=read(),l=read(),k=read();
    int cnt,s1,s2;ll v1,v2;
    forto(a,1,l)forto(b,0,k){
        s1=s2=0;
        forv(i,n)addto(s1,1ll*(a/n+(i>=n-a%n))*f[a-1][b][i]%P),addto(s2,1ll*((a+b)/n+(i>=n-(a+b)%n))*f[a-1][b][i]%P);
        v1=1ll*(a-1)*inv[2*a+b-2]%P*inv[a+b]%P,v2=1ll*(a+b-1)*inv[2*a+b-2]%P*inv[a+b]%P;
        if(a==1&&b==0)v1=inv[a+b],v2=0;
        forv(i,n){
            addto(f[a][b][i],v1*s1%P),addto(f[a][b][i],v2*s2%P);
            addto(f[a][b][i],v1*(a/n+(i<a%n))%P),addto(f[a][b][i],v2*((a+b)/n+(i<(a+b)%n))%P);
            if(b)addto(f[a][b][i],v1*b%P*f[a][b-1][(i-a%n+n)%n]%P);
            addto(s1,f[a-1][b][i]),delto(s1,f[a-1][b][(i-a%n+n)%n]);
            addto(s2,f[a-1][b][i]),delto(s2,f[a-1][b][(i-(a+b)%n+n)%n]);
        }
    }
    forv(i,n)printf("%d ",f[l][k][i]);puts("");
    forto(a,0,l)forto(b,0,k)forv(i,n)f[a][b][i]=0;
}

signed main(){
    init(20000),work();
    return 0;
}
```

---

## 作者：Lyrella (赞：2)

# 前言

困难题。前置知识：一点古典概型知识。

# 题解

注意到每个人均按照最优决策，所以在决策时我们需要去选择成功概率最大的。假设现在有 $x$ 个锁，$x+y$ 个钥匙。对于第一个人成功的概率为 ${x\over x(x+y)}={1\over x+y}$。我们称第一个人选择的锁和钥匙为一号锁、钥匙，现在去考虑第二个人以及后面人的情况：

- 选择一号锁和非一号钥匙。因为我们排除了一号钥匙所以还剩下 $x+y-1$ 个钥匙，故成功的概率为 $1\over x+y-1$。
- 选择非一号锁和一号钥匙。成功的概率也为 $1\over x+y-1$。接下来考虑证明。

> 设 $A,B,C$ 分别为第一个人拿到的钥匙为真的，第一个人失败，第二个人成功，下面有：
> $$
> \begin{aligned}
> P(A|B)&={P(B|A)P(A)\over P(B)}\\&={{x-1\over x}\cdot{x\over x+y}\over{x+y-1\over x+y}}={x-1\over x+y-1}\\
> P(C|B)&=P(A|B)P(C|AB)+P(\overline A|B)P(C|\overline AB)\\&={x-1\over x+y-1}\cdot{1\over x-1}+0={1\over x+y-1}
> \end{aligned}
> $$
> 证毕。

- 选择非一号锁和非一号钥匙。成功的概率为 $(1-{1\over x+y-1}){1\over x+y-1}={x+y-2\over (x+y-1)^2}<{1\over x+y-1}$，所以不进行此种决策。

所以第二个人会选择与第一个人相同的锁或钥匙，并且选择锁或者钥匙的概率相同，所以第二个人会有 ${x-1\over 2x+y-2}$ 的概率选择锁，有 $x+y-1\over 2x+y-2$ 的概率选择钥匙。并且如果第二个人选了锁，接下来的人就会一直选相同的锁直到锁开；否则就是一直选相同的钥匙直到发现其是假钥匙或者开了一把锁。因为这样他们的成功率比没有任何信息去瞎蒙的情况成功概率更高。并且我们可以计算第二个人成功的概率：$(1-{1\over x+y})\cdot{1\over x+y-1}={1\over x+y}$，和第一个人相同，以此类推可得到后面的成功概率同样为 ${1\over x+y}$。

也就是说除了第一个人外，我们对于相同的 $x,y$ 都进行本质相同的操作（选相同的锁/钥匙），并且成功概率相同。这个问题我们尝试 dp 解决。设 $f_{i,j,c}$ 表示现有 $i$ 个锁 $i+j$ 个钥匙，轮到了第 $c$ 个人期望成功次数。

首先肯定从 $x=1,y=0$ 的情况开始倒推（废话？）。我们进行一点小分讨进行转移：

- 选择的是能够配对的锁或钥匙，有 $f_{i,j,c}\leftarrow f_{i-1,j,c-l}$。首先注意 $c-l$ 是在模 $n$ 意义下的，因为这 $n$ 个人是轮着来的。然后我们要将锁和钥匙稍微分开处理，首先是因为选择相同锁或钥匙的概率不同，其次就是注意枚举的 $l$ 的上界也不同。具体的，对于锁来说，因为最多就 $i$ 把所以上界为 $i$；对于钥匙上界就可以到 $i+j$。转移式就是：$f_{i,j,c} = {\left((i-1)\sum f_{i-1,j,c-l}\right)+\left((i+j-1)\sum f_{i-1,j,c-l}\right)\over (i+j)(2i+j-2) }$。
- 注意如果只选钥匙的时候我们还可以有 $f_{i,j,c}\leftarrow f_{i,j-1,c-i}$，因为我们如果要发现这个钥匙是假的需要让 $n$ 个人轮 $i$ 次，每次选相同的这个假钥匙，所以有 $f_{i,j,c}={j\over i+j}\cdot{i-1\over 2i+j-2}\cdot f_{i,j-1,c-i}$。因为每次要选锁，所以还要乘选择锁的系数，然后那个 ${j\over i+j}$ 是选到假钥匙的概率。

- 最后还要考虑的是这一次本身成功的贡献。考虑是固定一个相同的锁还是钥匙，直接拿成功的概率乘上每次选择的概率即可。

直接做时间复杂度 $O(n^2LK)$，记得对于第一种情况进行前缀和优化，最后时间复杂度 $O(nLK)$。

代码就不放了，原因有二。一是这道题的代码是小清新；二是我觉得我的讲解已经足够清晰，你就算直接抄上面的转移式似乎也能写出来。

感觉这道题挺难的，能看到这里的也很不容易，要不点个免费的赞再走？~~求你了。~~

---

## 作者：MatrixGroup (赞：2)

## 题意简述

共有 $L+K$ 把钥匙，其中有 $L$ 把钥匙，每把对应一个锁，可以打开它；剩下 $K$ 把钥匙哪个锁都打开不了。有 $N$ 个人，$1\sim N$ 轮流循环尝试开锁，在所有最大化当前这次成功概率的情况中（当然，不能开成功开过的锁）等概率选择一个方案开，问开完所有 $L$ 个锁时每个人成功开锁次数的期望。对 $10^9+7$ 取模。

(THUPC ver.) $N\le 50, L\le 5\,000,K\le 50$。

(Codeforces ver.) 多测，$N\le 100, \sum L\le 5\,000,K\le 25$。

## 题解

先考虑刻画策略。第一个人当然是随便选。如果第一个人猜对了那问题就转化成了 $L$ 减掉 $1$ 的问题，否则第二个人当然应该要么选第一个人选了的钥匙，要么选第一个人选了的锁——因为它们各自排除了一个选项，当然比没有排除的好。当然这是直觉，我们来计算一下。设 $p_1,p_2,\cdots,p_L$ 为对应钥匙的编号。假如第一个人通过用 $b$ 开 $a$ 确定了 $p_a\neq b$，设 $c\neq a,d\neq b$。那么计算：

- $p_a\neq b,p_c\neq d$ 的概率是 $\dfrac{(L+K-1)(L+K-1)-(L+K-2)}{(L+K)(L+K-1)}$
- $p_a\neq b,p_c\neq b$ 的概率是 $\dfrac{(L+K-1)(L+K-2)}{(L+K)(L+K-1)}=\dfrac{L+K-2}{L+K}$
- $p_a\neq b,p_a\neq d$ 的概率是 $\dfrac{L+K-2}{L+K}$

注意以上算的都不是条件概率，反正条件概率就是除以 $p_a\neq b$ 的概率，大小关系还是不变的。总之第一个概率更高，后两者是一样的。而因为要让猜对的概率更高，猜错的概率就要更低。因此第二个人的策略就是后两者中随机，也就是在 $L+K-1$ 个 $d$ 和 $L-1$ 个 $c$ 里随便选。

接下来无论是直觉上说还是通过类似的论证可以说明，如果第二个人顺着第一个人选了相同的 $a$，那么接下来会一直选择猜相同的 $a$，直到猜对。如果第二个人顺着第一个人选了相同的 $b$，那么接下来会一直选择猜相同的 $b$，直到猜对或者发现没有这个 $b$。接下来就可以规约到一个更小的问题。当然不妨把第一次就猜对也拆成这样的两种，方便计算。

这样的子结构启发使用 dp 求解。设 $dp_{\ell,k,c}$ 表示 $L=\ell,K=k$ 时第 $j$ 个人的答案，那么因为不断猜一个数，第 $i$ 个人猜对的概率都是相同的 $\dfrac{1}{\ell+k}$，因此转移就是要么是边界的没有 $b$，要么要查询模意义下的区间和。前缀和优化转移，时间复杂度 $O(NLK)$。

## 代码

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll mod2=1000000007;
int t,n,l,k;
ll dp[5005][52][102];
ll s[5005][52][102];
ll f(int L,int K,int N){return (N/n*s[L][K][n]+s[L][K][N%n])%mod2;}
ll f(int L,int K,int a,int b){return (f(L,K,b+100000*n)-f(L,K,a+100000*n-1)+mod2)%mod2;}
ll qkpw(ll a,ll b){ll r=1;while(b){if(b&1)r=r*a%mod2;a=a*a%mod2;b>>=1;}return r;}
ll inv(ll x){return qkpw((x%mod2+mod2)%mod2,mod2-2);}
int main()
{
	cin>>n>>l>>k;
	for(int L=1;L<=l;++L) for(int K=0;K<=k;++K)
	{
		ll p1=inv(2*L+K-2)*(L+K-1)%mod2,p2=(mod2+1-p1)%mod2,q=inv(L+K);p1=p1*q%mod2;p2=p2*q%mod2;
		for(int i=1;i<=n;++i)
		{
			ll cur=((L+K-i+n)/n*p1+(L-i+n)/n*p2);if(K)cur+=K*p2%mod2*dp[L][K-1][((i-L-1+L*n)%n+1)];
			cur+=f(L-1,K,i-L-K,i-1)*p1+f(L-1,K,i-L,i-1)*p2;
			s[L][K][i]=(s[L][K][i-1]+(dp[L][K][i]=cur%mod2))%mod2; 
		}
	}
	for(int i=1;i<=n;++i) cout<<dp[l][k][i]<<" \n"[i==n];
    return 0;
}
```

---

## 作者：lalaouye (赞：0)

好题。

式子一定要认真推，不然就完蛋咯。

首先显然我们需要求出贪心策略。直接对于一种莫名其妙的方案是不好算的，而且一般这种题由于贪心的决策可以让局面变得不那么复杂，于是我们考虑从第一次开始计算。

不妨考虑第一次匹配失败的情况，第二次匹配的选手需要利用第一次匹配失败的信息找到最优解。

首先我们来感性地思考一下，如果选择的是跟前两个无关的锁和钥匙是不优的，因为这样我们几乎什么都没能利用到。然后我们来考虑是用第一把钥匙去匹配另一个锁还是第一个锁去匹配另一个钥匙。

我们来计算一下概率，首先锁去找钥匙匹配成功的概率很好算，令锁个数为 $m$，没用的钥匙个数为 $k$，那么概率就是 $\frac 1 {n + m-1}$，并且不难发现匹配了 $i$ 把钥匙后匹配成功的概率为 $\frac 1 {n+m-i}$。

然后再计算钥匙去匹配锁的概率。但是让人有点心虚的是这个钥匙可能是没用的。不过由于锁的个数更少，所以可能让钥匙去匹配锁也能有较大概率撞对。总之老老实实算概率，这里有个显然错的方法，就是我们可能觉得需要先保证它是有用的，于是就先乘个 $\frac m {m+k}$，这显然是有问题的，因为既然第一把钥匙已经失配了一次，那么理论上它是无用钥匙的概率就会更大。

总之我们换一种角度考虑概率，由于我们已知它不匹配第一个锁，而第一个锁有另一个钥匙匹配，而我们现在的第一个钥匙一定不是匹配第一个锁的钥匙，所以相当于这个钥匙是在 $m+k-1$ 个钥匙里随机选择，那么概率为 $\frac 1 {m+k-1}$。

到这里我们发现两种匹配方式的概率一样！这个貌似有点麻烦，我们考虑既然已经选择了一条路，那么我们就不会切换别的方案了，感性上是因为我们针对的物品获得的都是专属于它的信息，去拿别的物品做匹配一定不优。实际上算算概率也是如此，首先如果第一个钥匙匹配了 $i$ 个锁都失败了，那么它的下一次概率也是 $\frac 1 {n+m-i}$，就是沿着刚刚的思路，我们已知这个钥匙只会在 $n+m-i$ 个钥匙随机取了。然而这个时候如果让锁去匹配钥匙得到的信息则会少很多。

别忘了我们似乎还没算第三种选法的概率，也就是选开始两个物品之外的物品匹配，虽然感性上很劣，~~但是事实上也很劣~~，我们还是尝试算一下概率，其实就是对于一个锁算选出钥匙的概率，就算我们已经知道第一个钥匙匹配的不是它，那当前的概率也是 $\frac {1} {m+k-1}$，而且我们还不知道，所以肯定更劣。

那么我们可以很自然的设 $f(j,k,i)$ 表示 $j$ 个锁还没匹配并且还剩 $k$ 个无用的钥匙，当前轮到第 $i$ 个人操作的概率。转移考虑钥匙找锁的概率为 $\frac {j-1}{2j+k-2}$，因为能找的锁有 $j-1$ 个，能找的钥匙却有 $j+k-1$ 个，然后如果这个钥匙是没用的，那么有

$$\frac{j-1}{2j+k-2}\times \frac{k}{m+k}\times f(j,k,i)\rightarrow f(j,k-1,i+m)$$

然后如果钥匙是有用的，有

$$\frac{j-1}{2j+k-2}\times \frac{1}{m+k}\times f(j,k,i)\rightarrow f(j-1,k,i+l)$$

其中 $1\le l\le j$。然后如果是锁找钥匙，有

$$\frac{j+k-1}{2j+k-2}\times\frac{1}{m+k}\times f(j,k,i)\rightarrow f(j-1,k,i+l)$$

其中 $1\le l\le j+k$。

然后考虑优化，我们发现转移只有 $l$ 在变，前缀和搞一搞就好了。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i, l, r) for (int i (l); i <= (r); ++ i)
#define rrp(i, l, r) for (int i (r); i >= (l); -- i)
#define eb emplace_back
using namespace std;
#define pii pair <int, int>
#define inf 1000000000
#define ls (p << 1)
#define rs (ls | 1)
constexpr int N = 100 + 5, M = 5e3 + 5, B = 305, P = 1e9 + 7;
typedef long long ll;
typedef unsigned long long ull;
inline int rd () {
  int x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) {
    if (ch == '-') f = -1;
    ch = getchar ();
  }
  while (isdigit (ch)) {
    x = (x << 1) + (x << 3) + (ch ^ 48);
    ch = getchar ();
  }
  return x * f;
}
int qpow (int x, int y, int p = P) {
  int ret (1);
  for (; y; y >>= 1, x = x * x % p) if (y & 1) ret = ret * x % p;
  return ret;
}
int n, m, K;
int f[M][55][55], inv[M << 3], ans[N], i2;
int pf[M][55][55];
void add (int j, int k, int i, int d, int p) {
  int w (d / n); d %= n;
  (f[j][k][i] += w * pf[j + 1][k][n - 1] % P * p) %= P;
  (ans[(i + n - 1) % n] += w * pf[j + 1][k][n - 1] % P * p) %= P;
  if (i - d <= 0) {
    (f[j][k][i] += pf[j + 1][k][i - 1] * p) %= P;
    (ans[(i + n - 1) % n] += pf[j + 1][k][i - 1] * p) %= P;
    int ps (i - d + n);
    (f[j][k][i] += (pf[j + 1][k][n - 1] + P - pf[j + 1][k][ps - 1]) * p) %= P;
    (ans[(i + n - 1) % n] += (pf[j + 1][k][n - 1] + P - pf[j + 1][k][ps - 1]) * p) %= P;
  } else
    (f[j][k][i] += (pf[j + 1][k][i - 1] - pf[j + 1][k][i - d - 1] + P) * p) %= P,
    (ans[(i + n - 1) % n] += (pf[j + 1][k][i - 1] - pf[j + 1][k][i - d - 1] + P) * p) %= P;
}
void solve () {
  i2 = (P >> 1) + 1;
  n = rd (), m = rd (); K = rd ();
  memset (ans, 0, sizeof ans);
  rep (i, 1, (m + K) << 2) inv[i] = qpow (i, P - 2);
  rep (i, 0, m + 1) memset (f[i], 0, sizeof f[i]), memset (pf[i], 0, sizeof pf[i]);
  f[m][K][0] = 1;
  rrp (j, 0, m) {
    rrp (k, 0, K) {
      rep (i, 0, n - 1) {
        int p ((j - 1) * inv[j - 1 + j + k - 1] % P);
        int pp (j * inv[j * 2 + k] % P);
        add (j, k, i, j + 1, pp * inv[j + k + 1] % P);
        add (j, k, i, j + k + 1, (1 - pp + P) * inv[j + k + 1] % P);
        if (k) (f[j][k - 1][(i + j) % n] += f[j][k][i] * k % P * inv[j + k] % P * p) %= P;
        pf[j][k][i] = ((i ? pf[j][k][i - 1] : 0) + f[j][k][i]) % P;
      }
    }
  }
  int sum (0);
  rep (i, 0, n - 1) printf ("%lld ", ans[i]), sum += ans[i]; puts ("");
}
int32_t main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout);
  for (int T (1); T; -- T) solve ();
}
```

---


# [THUPC 2025 决赛] 列队

## 题目背景

……所以这个题意和标题是什么关系？

## 题目描述

定义 $f(A)$ 为 矩阵 $A$ 经过如下操作后得到的结果：

1. 独立地对矩阵 $A$ 的每行进行排序，使得各行中的元素从左到右单调不降。如果排序过后的矩阵和排序之前完全相同，则此次变换停止，否则再进行 2. 中描述的操作。
2. 独立地对矩阵 $A$ 的每列进行排序，使得各列中的元素从上到下单调不降。如果排序过后的矩阵和排序之前完全相同，则此次变换停止，否则再进行 1. 中描述的操作。

现给定一个 $n$ 行 $m$ 列的整数矩阵 $P$，满足$1\le P_{ij}\le n\times m$ 且矩阵中元素互不相同。

接下来有 $q$ 次操作，操作有以下两种：

- 修改操作：给定矩阵中的两个位置 $(x_1,y_1)$ 和 $(x_2,y_2)$，将这两个位置上的元素交换，即交换 $P_{x_1y_1}$ 和 $P_{x_2y_2}$。
- 查询操作：给定矩阵中的一个位置 $(x,y)$，输出矩阵 $f(P)$ 中该位置的元素，即$f(P)_{xy}$。注意，**查询操作并不会真的改变矩阵形态**。

## 说明/提示

### 样例 #1 解释

第一次查询的时候矩阵形如

```plain
1 4
2 3
```

我们发现第一次按行排列时就没能使得矩阵改变，因此答案就是第一行第二列的元素，也就是 $4$。

第二次查询的时候矩阵形如

```plain
4 1
2 3
```

我们先按行排序，变成

```plain
1 4
2 3
```

再按列排序，变成

```plain
1 3
2 4
```

再尝试按行排序，发现不能成功排序。因此答案就是此时第一行第二列的元素，也就是 $3$。

### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
2 2 10
1 4
2 3
2 1 2
1 1 1 1 2
2 1 2
1 1 1 1 2
1 1 2 2 1
2 2 1
2 2 2
1 1 1 2 2
2 1 1
2 2 1
```

### 输出

```
4
3
3
4
1
2
```

# 题解

## 作者：myee (赞：3)

### 前言

出题人题解。

其实是军训的时候整出来的 idea……

这题原本可能是今年的省选题，不过一月的时候因为一些原因我主动撤下了，于是塞进了 THUPC 中。（快说：谢谢 Itst）

命题会上大家发现这似乎是唯一一道能用的 ds 了，所以就毫无疑问地选上了。

实际赛时居然没人写正解，全去写根号分治然后卡常了……

我寻思着这题开了 $7$ 倍 std 时限而且 std 还没卡过常，不知道为啥这么多人还要卡常。

本题应该会有 Ynoi ver.，只保留做法中的第二种情况~~并开大数据范围卡常~~。

### 思路

首先注意到一个小结论：最多排序两次。

为什么？观察到如果矩阵只有 $0$ 和 $1$，那这点是显然的。

对于矩阵中的每个数，我们考虑把比其小的赋值为 $0$，其余都赋值为 $1$，那么显然也满足这点。于是直接得证。

由于第二次就退出和第二次排序后第三次退出对矩阵形态的实践行为是一样的，我们实际上只用分为两种情况：
* 一次也没排序。
* 恰好排序了两次。

至于是哪种情况，我们只用维护每行是否分别有序就行。也就是我们只用维护每个行内相邻的元素是否均有序。

这个是容易做到 $O(1)$ 的。哪怕比较懒用 `set` 也是 $O(\log(nm))$ 的。没有特意卡这部分常数，但是要注意一些代码细节，比如交换操作刚好交换相邻元素。

分辨出是哪种情况后，由于第一种情况就是输出矩阵对应位置元素，直接维护矩阵形态即可，显然是 $O(1)$ 的。

于是接下来我们只用考虑第二种情况。这种情况实际上是在求：假设各行分别取出第 $y$ 小的数，求出这些数中第 $x$ 小的。

一种很基础的思路是根号分治，场上确实大家都是这么写的。但是这个做法非常难写，所以我们这里换个思路。

注意到本题始终保持了排列的性质，于是考虑反过来维护每个数在矩阵中对应的行号。那么问题就变成了找到最小的位置，使得这个这个位置之前出现了至少 $y$ 次的数有 $x$ 个。

这个显然是可以直接分块维护的。具体地，我们设 $B$ 为块长，取 $0,B,2B,3B,\cdots$ 为间断点，那么我们只用维护每个间断点之前的所有元素的出现次数，及每种出现次数被多少种数达到即可。

信息维护与查询较为简单，不作赘述了。总之取 $B=\Theta(\sqrt{nm})$ 后本题总复杂度是 $O((q+nm)\sqrt{nm})$ 的。

值得一提的是，如果允许离线，就算不保证是排列，该做法也仍旧适用。

### Code

```cpp
// ぼたぼたと
// しゃりしゃりと
// うとうとと
// はらはらと
// ぱりぱりと
// しんしんと
// この世界を閉ざした
// 今もひとり宇宙を覗き込んだまま
#include <bits/stdc++.h>

using uint = unsigned;

const uint Lim=200000,B=500;
uint n,m,q,cnt;
uint A[Lim+5],P[Lim+5],L[Lim+5],bid;
uint Cnt[Lim/B+5][Lim+5],CCnt[Lim/B+5][Lim+5];
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    freopen("QAQ.out","w",stdout);
#endif
    scanf("%u%u%u",&n,&m,&q);
    for(uint i=0;i<n;i++)for(uint j=0;j<m;j++)scanf("%u",A+i*m+j),P[--A[i*m+j]]=i*m+j,cnt+=j&&A[i*m+j-1]>A[i*m+j];
    for(uint i=0;i<n*m;i++)L[i]=P[i]/m;
    for(uint i=0;i<n*m;i++)
    {
        if(!(i%B))
        {
            for(uint j=0;j<n;j++)Cnt[bid+1][j]=Cnt[bid][j];
            for(uint j=0;j<m;j++)CCnt[bid+1][j]=CCnt[bid][j];
            bid++;
        }
        CCnt[bid][Cnt[bid][L[i]]++]++;
    }
    while(q--)
    {
        uint o;scanf("%u",&o);
        if(o==1)
        {
            uint x1,y1,x2,y2;scanf("%u%u%u%u",&x1,&y1,&x2,&y2),x1--,y1--,x2--,y2--;
            if(x1==x2&&y1==y2)continue;
            if(y1>y2)std::swap(y1,y2),std::swap(x1,x2);
            if(y1)cnt-=A[x1*m+y1-1]>A[x1*m+y1];
            if(y1<m-1)cnt-=A[x1*m+y1+1]<A[x1*m+y1];
            if(y2&&(x1!=x2||y1+1!=y2))cnt-=A[x2*m+y2-1]>A[x2*m+y2];
            if(y2<m-1)cnt-=A[x2*m+y2+1]<A[x2*m+y2];
            uint a=A[x1*m+y1],b=A[x2*m+y2];std::swap(P[a],P[b]),std::swap(L[a],L[b]),std::swap(A[P[a]],A[P[b]]);
            if(y1)cnt+=A[x1*m+y1-1]>A[x1*m+y1];
            if(y1<m-1)cnt+=A[x1*m+y1+1]<A[x1*m+y1];
            if(y2&&(x1!=x2||y1+1!=y2))cnt+=A[x2*m+y2-1]>A[x2*m+y2];
            if(y2<m-1)cnt+=A[x2*m+y2+1]<A[x2*m+y2];
            if(L[a]==L[b])continue;
            if(a>b)std::swap(a,b);
            for(uint j=a/B+1;j<=b/B;j++)--CCnt[j][--Cnt[j][L[b]]],CCnt[j][Cnt[j][L[a]]++]++;
        }
        else
        {
            uint x,y;scanf("%u%u",&x,&y),x--,y--;if(!cnt){printf("%u\n",A[x*m+y]+1);continue;}
            uint p=0;while(CCnt[p+1][y]<=x)p++;
            uint t=CCnt[p][y];
            p*=B;
            while(t<=x)
            {
                if(Cnt[p/B][L[p]]++==y)t++;
                p++;
            }
            printf("%u\n",p);
            do p--,Cnt[p/B][L[p]]--;while(p%B);
        }
    }
    return 0;
}
```

---

## 作者：mygr (赞：2)

来篇 $O(q\sqrt{N}\log{\sqrt{N}} + q\sqrt{N})$ 的不优秀题解。

----------

首先有一个很关键的性质：按行排序与按列排序至多只会进行一次

考虑证明：若进行了第二次排序，则意味着按列排序后出现了一个位置，使得其右侧的值比当前位置更小。不妨对按行排序后相邻的两列考虑，此时若再进行列排序，则形成的相邻对的情况则是 **两列元素从大到小排序后，大小排名相同** 的元素相匹配，而对于左排列中每个元素而言，在右排列中大于其的元素的数量显然大于等于它的排名(左排列中比其大的元素都会贡献一个比其大的右排列元素)，所以不会产生左大于右的相邻对。

接下来就好办了，考虑维护这两次操作后的影响即可，观察到数据范围中有 $N=n \times m \le 2 \times 10^5$ ，很自然的想到根号分治。

### 情况一： $m \le \sqrt{N}$

因为 $m$ 很小，所以考虑记录下每一行 **行排序** 后的结果，修改时直接暴力排序即可，而查询等价于询问行排序后，第 $y$ 列中第 $x$ 小的元素，考虑一个 $O(1)$ 修改，$O(\sqrt{n})$ 查询的做法，我们对每一列用一个值域分块维护某值域区间内数的个数，修改则直接在对应位置和对应块上加减即可。

考虑查询，我们考虑 **大步小步算法** 的过程，具体的，我们从值域最小处开始向大跳跃，一开始先一个块一个块( $+\sqrt n$ )的跳跃，直到当前的前缀和大于查询的排名，然后转为一格一格( $+1$ )的跳，这样就能做到 $O(\sqrt n)$ 的查询。

于是我们就做到了 $O(q\sqrt{N}\log{\sqrt{N}} + q\sqrt{N})$ 的复杂度。

### 情况二： $n < \sqrt{N}$

考虑查询怎么做，我们可以枚举每一行求出他们的第 $y$ 小的元素，然后答案即为这些元素中第 $x$ 小的值( 使用 `nth_element` )。

而修改等价于对某行进行增删元素，要求能做到 $O(\sqrt m)$ 修改 $O(\log \sqrt m)$ 查询，考虑块状链表，但是块状链表的查询是 $\sqrt m$ 的，瓶颈在于外部链表的遍历，怎么优化呢？

在这里提出一种新的分块结构(雾)，我称之为 **朝鲜块状链表** ，具体的，我们对外部的块使用数组进行维护，块内元素使用 `vector` 维护，查询时即可在外部的块使用二分查找，修改是平凡的，但是修改次数过多可能会导致块长不平衡，所以我们借用 **朝鲜树** 的思想，每进行 $\sqrt{q}$ 次询问则对整个块状链表进行重构，在 $n,q$ 同阶时则可以做到均摊 $O(\sqrt{n})$ 的修改。

于是我们就做到了 $O(q\sqrt{N}\log{\sqrt{N}} + q\sqrt{N})$ 的复杂度。

----------

### 注意事项

注意当每一行都已经有序时，列排序则不会进行，所以需要进行特判，具体的可以记录一个 `cnt` 代表整个矩阵中 $a_{i,j}>a_{i,j+1}$ 的对的数量，若询问时有 $cnt=0$ 则直接输出 $a_{x,y}$ 即可。

码丑，勿喷（

```cpp
#include<bits/stdc++.h>
// #define fp_on
#define ll long long
#define pii pair<int,int>
#define db double

#define fi first
#define se second
using namespace std;
const int Max=2.5e5+5,Mod=998244353,inf=0x7fffffff,bMax=500;
namespace mygr{
	ll qpow(ll a,ll b){
		ll ans=1;
		while(b)
		{	if(b&1)
			ans=(ans*a)%Mod;
			a=(a*a)%Mod;b>>=1;
		}return ans;}
	ll read()
	{
		char c=getchar();
		ll w=1,a=0;
		while(!isdigit(c)){
			if(c=='-')w=-1;
			c=getchar();}
		while(isdigit(c)){
			a=a*10+c-'0';
			c=getchar();}
		return a*w;
	}
	struct graph{
		struct edge{
			int to,next;
		}p[Max*2];
		int head[Max],last[Max],idx=0;
		void add(int u,int v)
		{
			if(!head[u])
				head[u]=++idx;
			else
				p[last[u]].next=++idx;
			last[u]=idx;
			p[idx].to=v;
		}
	};
	template<class T>
	struct vector2{
		T x,y;
		vector2()
		{x=y=0;}
		vector2(T xx,T yy)
		{x=xx;y=yy;}
		friend vector2 operator + (vector2 A,vector2 B)
		{return vector2(A.x+B.x,A.y+B.y);}
		friend vector2 operator - (vector2 A,vector2 B)
		{return vector2(A.x-B.x,A.y-B.y);}
		friend T operator * (vector2 A,vector2 B)
		{return A.x*B.y-A.y*B.x;}
		friend T dot(vector2 A,vector2 B)
		{return A.x*B.x+A.y*B.y;}
	};
	int Turn(int num)
	{return (num%Mod+Mod)%Mod;}
	int lowbit(int num)
	{return num&(-num);}
}
using namespace mygr;

const int B=400;
int CB;
struct Blo{
	int p[Max],S[Max];
	int qs()
	{
		int ans=0;
		for(int i=0;i<=bMax;i++)
			ans+=S[i];
		return ans;
	}
	void upd(int pos,int num)
	{
		int ps=pos/B;
		p[pos]+=num;
		S[ps]+=num;
	}
	void upd(int l,int r,int num)
	{
		int np=l/B;
		int i=l;
		for(;i/B==np and i<=r;i++)
			p[i]+=num;
		if(i>r)return ;
		for(;i/B!=r/B;i+=B)
			S[i/B]+=num;
		for(;i<=r;i++)
			p[i]+=num;
	}
	int query(int k)
	{
		int now=0;
		while(k>S[now])
		{
			k-=S[now];
			now++;
		}
		now=now*B;
		while(k>p[now])
		{
			k-=p[now];
			now++;
		}
		return now;
	}
	int qry(int pos)
	{
		return p[pos]+S[pos];
	}
}T[bMax];
struct Blo_list{
	int tot,cntq;
	struct node{
		int l;
		vector<int> v;
	}p[bMax];
	void rebuild()
	{
		CB++;
		vector<int> d;
		for(int i=1;i<=tot;i++)
		{
			for(auto j : p[i].v)
				d.push_back(j);
			p[i].v.clear();
		}
		tot=1;
		p[1].l=1;
		for(auto i : d)
		{
			if(p[tot].v.size()>=B)
			{
				tot++;
				p[tot].l=p[tot-1].l+p[tot-1].v.size();
			}
			p[tot].v.push_back(i);
		}
	}
	void del(int num)
	{
		cntq++;
		if(cntq>=B)
			rebuild(),cntq=0;
		
		int now=1;
		while(now<tot and p[now+1].v[0]<=num)
			now++;
		p[now].v.erase( lower_bound(p[now].v.begin(),p[now].v.end(),num) );
		if(p[now].v.size()<=0)
		{
			if(now==tot)
				tot--;
			else
				rebuild();
			return ;
		}
		now++;
		for(;now<=tot;now++)
			p[now].l--;
	}
	void add(int num)
	{
		cntq++;
		if(cntq>=B)
			rebuild(),cntq=0;
		
		int now=1;
		while(now<tot and p[now+1].v[0]<=num)
			now++;
		
		p[now].v.insert( lower_bound(p[now].v.begin(),p[now].v.end(),num) ,num );
		now++;
		for(;now<=tot;now++)
			p[now].l++;
	}
	int qry(int k)
	{
		int l=1,r=tot;
		while(l<r)
		{
			int mid=(l+r+1)>>1;
			if(p[mid].l<=k)
				l=mid;
			else
				r=mid-1;
		}
		return p[l].v[k-p[l].l];
	}	
}P[bMax];

int n,m,q;
int *a[Max],*s[Max];
int buf[Max*4],bufs[Max*4];
void init(int* A[],int Bf[])
{
	for(int i=0;i<=n;i++)
		A[i]=&(Bf[i*(m+1)]);
}
int cnt;
void updc(int x,int y,int op)
{
	if(y<=0 or y>=m)return ;
	cnt+=op*(a[x][y]>a[x][y+1]);
}
void updnr(int x,int y,int op)
{
	updc(x,y-1,op);
	updc(x,y,op);
}

void solve1()
{
	init(s,bufs);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			s[i][j]=a[i][j]=read();
	for(int i=1;i<=n;i++)
		sort(s[i]+1,s[i]+m+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<m;j++)
			updc(i,j,1);
	for(int j=1;j<=m;j++)
		for(int i=1;i<=n;i++)
			T[j].upd(s[i][j],1);
			
	
	while(q--)
	{
		if(read()==1)
		{
			int X1=read(),Y1=read(),X2=read(),Y2=read();
			
			if(X1==X2 and Y1==Y2)
				continue;
			
			for(int i=1;i<=m;i++)
			{
				T[i].upd(s[X1][i],-1);
				if(X1!=X2)T[i].upd(s[X2][i],-1);
			}
			updnr(X1,Y1,-1);updnr(X2,Y2,-1);
			if(X1==X2 and abs(Y1-Y2)==1){cnt+=(a[X1][min(Y1,Y2)]>a[X2][max(Y1,Y2)]);}
			swap(a[X1][Y1],a[X2][Y2]);
			updnr(X1,Y1,1);updnr(X2,Y2,1);
			if(X1==X2 and abs(Y1-Y2)==1){cnt-=(a[X1][min(Y1,Y2)]>a[X2][max(Y1,Y2)]);}
			for(int i=1;i<=m;i++)
			{
				s[X1][i]=a[X1][i];
				s[X2][i]=a[X2][i];
			}
			sort(s[X1]+1,s[X1]+m+1);
			sort(s[X2]+1,s[X2]+m+1);
			for(int i=1;i<=m;i++)
			{
				T[i].upd(s[X1][i],1);
				if(X1!=X2)T[i].upd(s[X2][i],1);
			}
		}
		else
		{
			int x=read(),y=read();
			if(cnt==0)
				printf("%d\n",a[x][y]);
			else
			{
				int ans=T[y].query(x);
				printf("%d\n",ans);
			}
		}
	}
}

int Buf[Max];

void solve2()
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=read();
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<m;j++)
			updc(i,j,1);
	for(int i=1;i<=n;i++)P[i].tot=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			P[i].p[1].v.push_back(a[i][j]);
	
	for(int i=1;i<=n;i++)
	{
		sort(P[i].p[1].v.begin(),P[i].p[1].v.end());
		P[i].rebuild();
	}
	
	while(q--)
	{	
		
		if(read()==1)
		{
			int X1=read(),Y1=read(),X2=read(),Y2=read();
			if(X1==X2 and Y1==Y2)
				continue;
			
			P[X1].del(a[X1][Y1]);
			P[X2].del(a[X2][Y2]);
			
			updnr(X1,Y1,-1);updnr(X2,Y2,-1);
			if(X1==Y1 and abs(Y1-Y2)==1){cnt+=(a[X1][min(Y1,Y2)]>a[X2][max(Y1,Y2)]);}
			swap(a[X1][Y1],a[X2][Y2]);
			updnr(X1,Y1,1);updnr(X2,Y2,1);
			if(X1==Y1 and abs(Y1-Y2)==1){cnt-=(a[X1][min(Y1,Y2)]>a[X2][max(Y1,Y2)]);}
			
			P[X1].add(a[X1][Y1]);
			P[X2].add(a[X2][Y2]);
		}
		else
		{
			int x=read(),y=read();
			if(cnt==0)
				printf("%d\n",a[x][y]);
			else
			{
				for(int i=1;i<=n;i++)
					Buf[i]=P[i].qry(y);
				nth_element(Buf+1,Buf+x,Buf+n+1);
				printf("%d\n",Buf[x]);
			}
		}
	}
}
//#define fp_on
signed main()
{
#ifdef fp_on
	freopen("62.in","r",stdin);
	freopen("mygr.out","w",stdout);
#endif
	n=read();m=read();q=read();
	init(a,buf);
	if(m<=n)
		solve1();
	else
		solve2();
}
```

---

## 作者：happybob (赞：0)

考虑单次询问怎么做，分析一下结果的性质。

打表或者简单分析可以看出，两个操作都最多操作 $1$ 次，也就是说要么每行本身就已排好序，要么排序后再对列排序然后结束过程。原因也很简单，考虑如果矩阵只有 $0$ 和 $1$，排两次序后肯定符合条件。对于原矩阵，考虑这样操作后如果存在一行按顺序两个数 $a,b$ 满足 $a>b$，则将 $\leq b$ 的数视为 $0$，其余数视为 $1$，导出矛盾。

于是我们只需要维护排序两次的过程，并且特判初始时行都排好序。显然判断行是否都排好序是很容易的，考虑排序两次怎么做。

这个过程看着比较困难，时限也比较大，考虑能不能做到根号之类的复杂度。这个是矩阵，显然提示我们使用 $\min(n,m) \leq \sqrt{nm}$ 的 Trick。设定阈值 $B$，$m \leq B$ 时，修改时对行重新排序，然后每列维护一个数据结构支持插入删除，查询 $k$ 小值。$m > B$ 时，$n < \dfrac{nm}{B}$，对每行维护同样的数据结构，查询把每行对应的值求出后直接算答案。

分析复杂度，如果使用平衡树这样的数据结构，取 $B=\sqrt{nm}$ 可以做到 $O(q\sqrt{nm}\log{nm})$，但无法通过。注意到 $m \leq B$ 时，我们要做 $O(qB)$ 次插入删除和 $O(q)$ 次查询 $k$ 小值，可以简单使用分块均摊两部分复杂度做到 $O(qB)$，取 $B=\sqrt{nm \log nm}$ 即可做到 $O(q\sqrt{nm \log nm})$，写得好已经能过了。但可以做到更优。发现 $m>B$ 时，要做的是 $O(q)$ 次插入删除与 $O(q\dfrac{nm}{B})$ 次查询，我们希望能做到 $O(\sqrt{nm})$ 插入和 $O(1)$ 查询。这个是可以维护的。具体地，插入删除对第 $k$ 小的数构成的序列的影响是类似于区间位移一格的操作，分块并对每个块维护链表即可支持这样的操作，总复杂度即可做到 $O(q\sqrt{nm})$。

---

## 作者：MatrixGroup (赞：0)

## 前言

官方题解的思路我没看，好像很短的样子。不过本文讲的是没调出来的赛时做法，以及具体哪里写挂了。

如果，如果我当时能够意识到，这细微之处的错误呢……

## 题意

定义 $f(A)$ 为 矩阵 $A$ 经过如下操作后得到的结果：

1. 独立地对矩阵 $A$ 的每行进行排序，使得各行中的元素从左到右单调不降。如果排序过后的矩阵和排序之前完全相同，则此次变换停止，否则再进行 2. 中描述的操作。
2. 独立地对矩阵 $A$ 的每列进行排序，使得各列中的元素从上到下单调不降。如果排序过后的矩阵和排序之前完全相同，则此次变换停止，否则再进行 1. 中描述的操作。

现给定一个 $n$ 行 $m$ 列的整数矩阵 $P$，满足 $1\le P_{ij}\le n m$ 且矩阵中元素互不相同。

接下来有 $q$ 次操作，操作有以下两种：

- 修改操作：给定矩阵中的两个位置 $(x_1,y_1)$ 和 $(x_2,y_2)$，将这两个位置上的元素交换，即交换 $P_{x_1y_1}$ 和 $P_{x_2y_2}$。
- 查询操作：给定矩阵中的一个位置 $(x,y)$，输出矩阵 $f(P)$ 中该位置的元素，即 $f(P)_{xy}$。注意，**查询操作并不会真的改变矩阵形态**。

$nm\le 2\times10^5$，$q\le 2\times10^5$，5s，2GB。

## 题解

思路一部分来源于队友 [zhuzhu2891](https://www.luogu.com.cn/user/515385)，致谢。

首先观察到一个性质：最多两个操作各执行一次后，矩阵就行列分别有序了。考虑证明。因为如果不这样的话考虑一个 $x>y$ 违反条件，那把数分成 $\le y$ 的和 $>y$ 的，就只需要考虑 $01$ 矩阵即可。而对于 $01$ 矩阵这是显然的。一个感性的理解是把 $1$ 看成物品然后向右晃一次向下晃一次就全都堆在右下角了，而严格证明也不难，第一次之后所有 $1$ 都在右边，而第二次显然等价于对每行 $1$ 的个数进行排序。

那么只需要分两种情况：每行都排好了，这时不用排。否则排两次。先判掉前者：直接动态维护每行相邻元素有几个逆序对即可。那么接下来考虑后者。

$nm\le 2\times10^5$，乘积的形式容易想到根号分治。考虑 $n,m$ 分别小的时候，有没有方便的求法。

当 $n$ 很小时，因为要求的是每行排序后第 $y$ 列的第 $x$ 大，可以考虑把第 $y$ 列的每个元素都求出来，找到第 $x$ 大。而这只需要维护每行元素组成的集合即可。

当 $m$ 很小时，可以考虑每次修改至多影响两行，把影响的这两行重新排序，更新排序后每一列的集合，查询的时候查询第 $y$ 列的第 $x$ 大即可。

于是就做完了……吗？等等插入删除第 $k$ 大要用平衡树吧，平衡树根号 $\log$ 能过 $2\times10^5$ 就怪了。于是要考虑别的算法。

先解决平衡树之外的 $\log$。对于 $n$ 小时，求序列第 $k$ 大可以使用 `nth_element` 线性求出。对于 $m$ 小时，修改排序结果时，因为只修改了一个数，可以用插入排序类似的方法线性求解。

仔细分析一下。当 $n$ 小时，单次修改只会涉及 $O(1)$ 次集合修改，询问会涉及 $O(n)$ 次第 $k$ 大。当 $m$ 小时，单次修改会涉及 $O(m)$ 次集合修改，但询问只需要 $1$ 次第 $k$ 大。

考虑平衡复杂度。如果对于一个值域为 $V$ 的集合，可以 $O(1)$ 插入删除，$O(\sqrt V)$ 查第 $k$ 大，也可以 $O(\sqrt V)$ 插入删除，$O(1)$ 查第 $k$ 大，设 $nm$ 和 $q$ 同阶，则整个问题即可在 $O(q\sqrt q)$ 的时间复杂度内完成。

实际上这真的可以做到。

对于前者，考虑分块维护，把序列分成 $O(\sqrt V)$ 个长度为 $B=O(\sqrt V)$ 的块，每次修改更新每个元素是否在集合内，以及每个块有多少个元素。查询时从前往后找到目标元素所在块再在块内暴力扫即可。

对于后者，考虑分块链表，维护若干长度为 $B=O(\sqrt V)$ 的链表，每次修改找到第一个被影响的块暴力改，之后每个块只需要改一个元素同时链表头平移 $1$ 即可。查询直接定位需要的链表的需要的元素即可。

于是就做完了。

## 实现细节

我场上和现在补题都写挂了同样的两个地方。

一个地方是，需要注意在 $m$ 小时，你维护的是行排序后的每一列的集合，初始化时不能写错。

一个地方时，统计邻项逆序对时，如果被修改的两个元素是相邻的，可能会算重。

或许这是很弱智的错误……但如果那时的我能发现就好了啊。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,del##i##verme=int(n);i<del##i##verme;++i)
#define rep1(i,n) for(int i=1,parano##i##a=int(n);i<=parano##i##a;++i)
#define pb push_back
#define y1 VividCycle
using namespace std;
const int N=200005;
const int B=512; 
const int Q=N/B+5;
struct ds1{
	bool in[N];int c[Q];
	void clear()
	{
		rep(i,N) in[i]=false;
		rep(i,Q) c[i]=0;
	}
	void insert(int x)
	{
		++c[x/B];in[x]=true;
	}
	void erase(int x)
	{
		--c[x/B];in[x]=false;
	}
	int kth(int k)
	{
		int bl=0;
		while(k>c[bl])
		{
			k-=c[bl];++bl;
		}
		int cur=bl*B;
		rep1(i,k)
		{
			while(!in[cur]) ++cur;
			++cur;
		}
		return --cur;
	}
};
struct ds2{
	int val[Q][B];
	int bg[Q];
	inline int& value(int x,int y)
	{
		return val[x][(y+bg[x])%B];
	}
	void clear()
	{
		rep(i,Q)
		{
			bg[i]=0;rep(j,B) val[i][j]=1145141;
		}
	}
	void insert(int x)
	{
		int cur=0;
		while(value(cur,B-1)<x) ++cur;
		int idx=bg[cur];
		while(val[cur][idx]<x)
		{
			++idx;if(idx==B)idx=0;
		}
		while(1)
		{
			swap(x,val[cur][idx]);
			++idx;if(idx==B)idx=0;
			if(idx==bg[cur]) break;
		}
		while(x!=1145141)
		{
			++cur;int id=(bg[cur]==0)?(B-1):(bg[cur]-1);
			swap(x,val[cur][bg[cur]==0?(B-1):(bg[cur]-1)]);
			bg[cur]=id;
		}
	}
	void erase(int x)
	{ 
		int cur=0;
		while(value(cur,B-1)<x) ++cur;
		int idx=bg[cur];
		while(val[cur][idx]<x)
		{
			++idx;if(idx==B)idx=0;
		}
		while(1)
		{
			int nx=(idx==B-1)?0:(idx+1);
			if(nx==bg[cur]) break;
			val[cur][idx]=val[cur][nx];
			idx=nx;
		}
		while(val[cur][bg[cur]]!=1145141)
		{
			int lst=(bg[cur]==0)?(B-1):(bg[cur]-1);
			val[cur][lst]=val[cur+1][bg[cur+1]];
			++cur;bg[cur]=(bg[cur]==B-1)?0:(bg[cur]+1);
		}
	}
	int kth(int k)
	{
		return value((k-1)/B,(k-1)%B);
	}
};
ds1 qaq[500];ds2 qvq[500];
int n,m,a,q,op,x1,y1,x2,y2;
int cnt;
vector<int> vc[200005];
int valt[500];
vector<int> st[200005];
void Delete(int x,int y){if(vc[x][y-1]>vc[x][y])--cnt;if(vc[x][y]>vc[x][y+1])--cnt;}
void Add(int x,int y){if(vc[x][y-1]>vc[x][y])++cnt;if(vc[x][y]>vc[x][y+1])++cnt;}
void solve_nsmall()
{
	rep1(i,n)
	{
		qvq[i].clear();
		rep1(j,m) qvq[i].insert(vc[i][j]);
	}
	while(q--)
	{
		cin>>op>>x1>>y1;
		if(op==1)
		{
			cin>>x2>>y2;
			if(x1==x2&&y1==y2) continue;
			if(x1!=x2)
			{
				qvq[x1].erase(vc[x1][y1]);
				qvq[x2].erase(vc[x2][y2]);
				qvq[x1].insert(vc[x2][y2]);
				qvq[x2].insert(vc[x1][y1]);
			}
			Delete(x1,y1);Delete(x2,y2);
			swap(vc[x1][y1],vc[x2][y2]);
			Add(x1,y1);Add(x2,y2);
			if(x1==x2&&abs(y1-y2)==1)
			{
				if(vc[x1][min(y1,y2)]<vc[x2][max(y1,y2)]) ++cnt;
				else --cnt;
			}
		}
		else
		{
			if(cnt==0)
			{
				cout<<vc[x1][y1]<<"\n";
				continue;
			}
			rep1(i,n) valt[i]=qvq[i].kth(y1);
			nth_element(valt+1,valt+x1,valt+n+1);
			cout<<valt[x1]<<"\n";
		}
	}
}
void solve_msmall()
{
	rep1(j,m)
	{
		qaq[j].clear();
	}
	rep1(i,n)
	{
		st[i]=vc[i];sort(st[i].begin(),st[i].end());
		rep1(j,m) qaq[j].insert(st[i][j]);
	}
	while(q--)
	{
		cin>>op>>x1>>y1;
		if(op==1)
		{
			cin>>x2>>y2;
			if(x1==x2&&y1==y2) continue;
			if(x1!=x2)
			{
				int v1=vc[x1][y1],v2=vc[x2][y2];
				int i1=0,i2=0;
				rep1(i,m) if(st[x1][i]==v1) {i1=i;break;}
				rep1(i,m) if(st[x2][i]==v2) {i2=i;break;}
				qaq[i1].erase(v1);
				qaq[i2].erase(v2);
				int j1=i1,j2=i2;
				swap(st[x1][i1],st[x2][i2]);
				while(st[x1][j1]<st[x1][j1-1])
				{
					--j1;qaq[j1].erase(st[x1][j1]);swap(st[x1][j1],st[x1][j1+1]);
				}
				while(st[x1][j1]>st[x1][j1+1])
				{
					++j1;qaq[j1].erase(st[x1][j1]);swap(st[x1][j1],st[x1][j1-1]);
				}
				while(st[x2][j2]<st[x2][j2-1])
				{
					--j2;qaq[j2].erase(st[x2][j2]);swap(st[x2][j2],st[x2][j2+1]);
				}
				while(st[x2][j2]>st[x2][j2+1])
				{
					++j2;qaq[j2].erase(st[x2][j2]);swap(st[x2][j2],st[x2][j2-1]);
				}
				for(int i=min(i1,j1);i<=max(i1,j1);++i) qaq[i].insert(st[x1][i]);
				for(int i=min(i2,j2);i<=max(i2,j2);++i) qaq[i].insert(st[x2][i]);
			}
			Delete(x1,y1);Delete(x2,y2);
			swap(vc[x1][y1],vc[x2][y2]);
			Add(x1,y1);Add(x2,y2);
			if(x1==x2&&abs(y1-y2)==1)
			{
				if(vc[x1][min(y1,y2)]<vc[x2][max(y1,y2)]) ++cnt;
				else --cnt;
			}
		}
		else
		{
			if(cnt==0)
			{
				cout<<vc[x1][y1]<<"\n";
				continue;
			}
			cout<<qaq[y1].kth(x1)<<"\n";
		}
	}
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>m>>q;
	rep1(i,n)
	{
		vc[i].pb(0);
		rep1(j,m)
		{
			cin>>a;
			if(a<vc[i].back()) ++cnt;
			vc[i].pb(a);
		}
		vc[i].pb(3614250);
	}
	if(n<m)
	{
		solve_nsmall();
	}
	else
	{
		solve_msmall();
	}
	return 0;
}
```

---


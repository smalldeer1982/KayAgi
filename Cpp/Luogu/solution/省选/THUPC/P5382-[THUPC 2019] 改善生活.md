# [THUPC 2019] 改善生活

## 题目描述

「改善生活」是小 Z 创建的一个群聊。在群聊里，小 Z 和他的 $n-1$ 个朋友们（共 $n$ 名群友，小 Z 的编号为 $1$，他的朋友们的编号从 $2$ 至 $n$）无话不说，畅谈甚欢。然而，经常水群会被冠以水王的名号，这让小 Z 头痛不已。

今天，小 Z 预见到了群里可能会有 $n$ 个话题（编号从 $1$ 至 $n$）。其中，第 $i$ 个话题是 $c_i$ 号群友（当然也有可能是小 Z 自己）感兴趣的话题，这意味着该话题如果出现，这位群友将会进行 $w_i$ 分钟的**激烈发言**。方便起见，你可以认为，除此之外，群友不会进行激烈发言。

所有 $n$ 个话题之间有 $m$ 组引导关系，每组引导关系的形式是一个二元组 $\left(u,v\right)$，它表示如果 $u$ 号话题出现，**必定**会导致 $v$ 号话题出现。

巧合的是，小 Z 发现，所有他自己的**不同**话题都不存在**直接或间接**的引导关系。

由于期中考试的临近，除小 Z 外的群友们都忙于复习，因此他们不会主动发起话题（发起话题指让一个话题出现，下同），也就是说，**所有** $c_i\neq 1$ **的话题都只能由引导关系直接或间接引出**。这让想要水群、却又希望摆脱水王名号的小 Z 左右为难。因此，他决定主动发起**一个或以上**的**自己感兴趣**的话题，来诱导其他话题的出现，致使**水群最多的另一位群友激烈发言的时间**与**小 Z 自己激烈发言的时间**的比值尽可能大。即最大化下面这个式子：

$$\frac{\max\limits_{k=2}^n \text{sum}\left(k\right)}{\text{sum}\left(1\right)}$$

其中，$\text{sum}\left(k\right)$ 表示所有**出现**且**群友 $k$ 感兴趣**的话题的 $w$ 值总和。

为避免精度误差，你只需要求出最大值**向下取整**的结果即可。

## 说明/提示

### 样例解释

小 Z 可以选择发起编号为 3 和 4 的话题，这将致使编号为 5、6、7 的话题出现，并引发 3 号群友时长 $150$ 分钟的激烈发言、以及 4 号群友时长 $40$ 分钟的激烈发言。由于 $3$ 号群友激烈发言时间更长，且小 Z 自己的激烈发言时长为 $60$ 分钟，因此所求最大比值为 $\frac{150}{60}=2.5$，这个值向下取整的结果是 $2$。

可以证明小 Z 不存在更优的策略。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
7 8
2 2 1 1 3 3 4
100 100 40 20 100 50 40
1 3
2 3
1 4
2 4
3 5
4 6
3 7
4 7```

### 输出

```
2```

# 题解

## 作者：hehezhou (赞：5)

首先让我们证明一个结论：存在一个最优解小Z只引出了一个话题  
感性理解：我多选了一个相当与把两个答案进行某种意义下的平均，不会变的更优

证明：  
若$S_1$表示小Z引出话题的集合，我们只要证明向$S_1$中插入集合$S_2$不会变的更优($S1\cap S_2=\emptyset$)(新方案要么不优于只选$S_1$的方案，要么不优于只选$S_2$的方案)

设当只选$S_1$时,答案为$ans_1$,$sum(k)=a_k$,  
当只选$S_2$时,答案为$ans_2$,$sum(k)=b_k$(令$ans_1\leq ans_2$)  
当选$S_1\cup S_2$时,答案为$ans_3$,$sum(k)=c_k$
  
显然$c_1=a_1+b_1$  
$\forall k\in [2,n]\ a_k\leq a_1*ans_1$  
$\forall k\in [2,n]\ b_k\leq b_1*ans_2$  
$\forall k\in [2,n]\ c_k\leq a_k+b_k$(话题可能有交集)$\leq a_1*ans_1+b_1*ans_2$  
$$ans_3=\frac{max_{k\in [2,n]}\{c_k\}}{c_1}$$
$$\leq max_{k\in [2,n]}\{\frac{a_1*ans_1+b_1*ans_2}{a_1+b_1}\}$$
$$\leq max_{k\in [2,n]}\{\frac{a_1*ans_2+b_1*ans_2}{a_1+b_1}\}$$
$$=ans_2$$  
证毕

所以只要枚举选的点，然后算答案即可(我的代码实现求了个传递闭包)

#### Talk is cheap, show me the code.

码风丑，请大佬轻喷

```
#include <bits/stdc++.h>
using namespace std;
int mp[710][710], n, m, c[710], w[710];
int cnt[710], ans;
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%d", c + i);
    for(int i = 1; i <= n; i++) scanf("%d", w + i);
    for(int i = 1, u, v; i <= m; i++) {
        scanf("%d%d", &u, &v);
        mp[u][v] = 1;
    }
    for(int k = 1; k <= n; k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++) mp[i][j] |= mp[i][k] & mp[k][j];
    //没有错，n ^ 3 就是能过700 (700 ^ 3 = 3e8)
    for(int i = 1; i <= n; i++) {
        if(c[i] == 1) {
            memset(cnt, 0, sizeof cnt);
            for(int j = 1; j <= n; j++) if(mp[i][j]) cnt[c[j]] += w[j];
            for(int j = 2; j <= n; j++) ans = max(ans, cnt[j] / w[i]);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Bezime (赞：2)

~~这题好水。~~

首先，我们将话题引发关系建成一个有向图，

小 Z 只能发起自己感兴趣的话题，就从这些话题的其中几个出发，进行DFS，搜索到的每一个节点将对应的人加上对应时间，每个点只能走一次。

我们能知道最优解当中肯定有只发起一个话题的解。

解释：

我们设，发起了第 $i$ 个小 Z 能发起的话题后，小 Z 发言时间为 $a_{1i}$，其他人的发言时间为 $a_{ki}$（$k>1$），比值向下取整后为 $w_i$。

其中：（$i \neq j$）

$\Large w_i=\frac{a_{1i}}{a_{ki}}$，

$\Large w_j=\frac{a_{1j}}{a_{kj}}$，

$\Large w_{ij}=\frac{a_{1i}+a_{1j}}{a_{ki}+a_{kj}}$，

不妨让 $w_i \geq w_j$，

则当 $w_i=w_j$ 时，

$\LARGE w_{ij}=\frac{a_{1i}+a_{1j}}{a_{ki}+a_{kj}}=\frac{a_{1i}+xa_{1i}}{a_{ki}+xa_{ki}}=\frac{(1+x)a_{1i}}{(1+x)a_{ki}}=\frac{a_{1i}}{a_{ki}}=w_i=w_j$

当 $w_i=(1-\frac{y}{x})w_j$ 时，（$0<\frac{y}{x}<1$）

$\LARGE w_{ij}=\frac{a_{1i}+a_{1j}}{a_{ki}+a_{kj}}=\frac{a_{1i}+(x-y)a_{1i}}{a_{ki}+xa_{ki}}<\frac{a_{1i}+xa_{1i}}{a_{ki}+xa_{ki}}=\frac{(1+x)a_{1i}}{(1+x)a_{ki}}=\frac{a_{1i}}{a_{ki}}=w_i$

综上，$w_i \geq w_{ij}$

同理，

$w_{ij} \geq w_{ijk}$

......

$w_{i...o} \geq w_{i...ol}$

所以，$w_{i} \geq w_{i...l}$

所以总有只选一个话题比再选一个更优，

搜索分别发起每一个话题，求得比值，找到最大值即可。

时间复杂度：$\mathcal{O}(nm+n^2)$（实际上不特意卡的话比这低很多）

[AC记录](https://www.luogu.com.cn/record/58827531)

AC代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxx 2000000000
#define mxm 60002
#define mxn 702
using namespace std;
struct bzm{
	ll v,nt;
}e[mxm];//有向图的边
ll hd[mxn],tt;//有向图的其他变量
ll n,m,a[mxn],w[mxn];//输入的数据
ll dis[mxn],ans;//每个人的时间、最终的答案
bool vis[mxn];//不重复走
inline void rd(ll &x){x=0;short f=1;char c=getchar();while((c<'0'||c>'9')&&c!='-') c=getchar();if(c=='-') c=getchar(),f=-1;while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();x*=f;}
inline void pt(ll x){if(x<0) putchar('-'),x=-x;if(x>9) pt(x/10);putchar((x%10)+'0');}
inline void adde(ll u,ll v){//有向图的加边
	e[++tt]=(bzm){v,hd[u]};
	hd[u]=tt;
}
inline void dfs(ll u){//求出每个人的时间
	dis[a[u]]+=w[u];
	vis[u]=1;
	for(ll i=hd[u];i;i=e[i].nt){
		ll v=e[i].v;
		if(vis[v]) continue;
		dfs(v);
	}
}
int main(){
	rd(n);rd(m);
	for(ll i=1;i<=n;i++)//话题对应的人
		rd(a[i]);
	for(ll i=1;i<=n;i++)//话题对应的时间
		rd(w[i]);
	for(ll i=1,u,v;i<=m;i++)//话题引发关系
		rd(u),rd(v),adde(u,v);
	for(ll i=1;i<=n;i++)
		if(a[i]==1){//枚举小 Z 能发起的话题
			memset(dis,0,sizeof(dis));
			memset(vis,0,sizeof(vis));
			dfs(i);
			for(ll i=2;i<=n;i++)//求得最终答案
				ans=max(ans,dis[i]/dis[1]);
		}
	pt(ans);
}
```

---

## 作者：chenruikai (赞：0)

这道题第一眼建图，把每个引导关系之间连一条有向边，这样一来，可以在 $\Theta(n)$ 的时间内求出哪些话题会被提及。

然后再关心发起哪个话题的问题。简化问题：如果只能提及一个话题，那么很显然，只要枚举每一个点然后按前面的方法算取个最大值就 OK 了。

但是本题中要求可以发起多个，最直接的想法就是枚举发起了哪些话题，能在 $\Theta(2^{700})$ 这样优异的复杂度内求出。再进一步，可能想到 DP，可能能行但是我没尝试。

那这该如何是好呢？~~莫过于打开题解~~设 $max_i,max_j,t_i,t_j$ 分别表示最长的时间，发起者自己的时间。可以证明，对于任意两个 $\frac{max_i}{t_i}\ge \frac{max_j}{t_j}$，合并之后的最大情况 $\frac{(max_i+max_j)}{(t_i+t_j)}$（发起者感兴趣的之间没有交集）也比 $\frac{max_i}{t_i}$ 小，所以说只发起一个的方案一定更优。

具体证明
$$
\begin{aligned}
\text{设}\frac{max_i}{t_i}=k_i,\frac{max_j}{t_j}=k_j\\
\implies max_i=k_i\times t_i,max_j=k_j\times t_j\\
\frac{max_i}{t_i}-\frac{max_i+max_j}{t_i+t_j}&=
k_i-\frac{k_i\times t_i+k_j\times t_j}{t_i+t_j}\\
&=\frac{(k_i-k_j)\times t_j}{t_i+t_j}\\
k_i
\ge k_j\implies(k_i-k_j)\times \frac{t_j}{t_i+t_j}>0\\
\end{aligned}
$$
所以得证了。

而后事情就好办了，每个求一遍，搞个最大，就是答案。

我做这道题时先看错题了，以为只能发起一个，发现样例居然都对，然后就开始想了。

### code
```cpp
#include <bits/stdc++.h>
using namespace std;

#define debug 1
#define debugpart if(debug)
struct cell
{
    vector <int> con , peo;
    int l;
    bool vis;
};
int t[701];
vector <int> source;
vector <int> mem_max , mem0;
cell point[701];
int pn , en;
void addedge(int frompos , int endpos){point[frompos].con.push_back(endpos);}
void addpeo(int pos , int peo){point[pos].peo.push_back(peo);if(peo == 0)source.push_back(pos);}
void work(int pos)
{
    for(int i = 0;i < pn;i++)point[i].vis = false;
    memset(t , 0 , sizeof(int) * pn);
    queue <int> w;w.push(pos);
    while(!w.empty())
    {
        pos = w.front();w.pop();
        if(point[pos].vis)continue;
        point[pos].vis = true;
        for(int i : point[pos].peo)
            t[i] += point[pos].l;
        for(int nextpos : point[pos].con)
        {
            if(!point[nextpos].vis)
            {
                w.push(nextpos);
            }
        }
    }
}
int main()
{
    cin >> pn >> en;int a , b;
    for(int i = 0;i < pn;i++){cin >> a;addpeo(i , a - 1);}
    for(int i = 0;i < pn;i++)cin >> point[i].l;
    for(int i = 0;i < en;i++)
    {
        cin >> a >> b;
        addedge(a - 1 , b - 1);
    }
    int ans0 = 1 , ans_max = 0 , maxn;
    for(unsigned long long int i = 0;
        i < source.size();i++)
    {
        work(source[i]);
        maxn = 0;
        for(int j = 1;j < pn;j++)
            maxn = max(maxn , t[j]);
        if(i == 0){ans0 = t[0] , ans_max = maxn;}
        else if(maxn * ans0 >= ans_max * t[0])
            ans0 = t[0] , ans_max = maxn;
    }
    cout << ans_max / ans0 << '\n';
    return 0;
}
```
玥玥月月如今朝。

---


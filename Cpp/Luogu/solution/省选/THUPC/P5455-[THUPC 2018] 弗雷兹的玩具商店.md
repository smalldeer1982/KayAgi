# [THUPC 2018] 弗雷兹的玩具商店

## 题目背景

物是人非事事休，欲语泪先流。


## 题目描述

弗雷兹在 C 市有一个玩具店，店里有 $n$ 种玩具，编号依次为 $1,2,\dots, n$，编号为 $i$ 的玩具的单价为 $c_i$ 元，一个该玩具提供的愉悦度为 $v_i$ 。

突然有一天，C市来了 $m$ 个小朋友。据可靠消息，这些小朋友会在一些时刻一起来店里买东西，其中第 $i$ 个小朋友每次都会带 $i$ 元（ $1\leq i\leq m$ ）。

由于某些玩具特别优秀，所以每次小朋友们都会在特定的编号范围内挑选玩具。

除此之外，由于小朋友们在一年前的清华校赛中就愉悦得无法自拔，所以弗雷兹放弃了对他们的治疗，于是小朋友们就可以无限制地购买玩具了。也就是说，对于任意玩具，每个小朋友在每次的购买件数都可以是任意的非负整数。

时代飞速发展，玩具的受欢迎程度和价格也会随着时代的发展而改变。

为了方便你处理这些信息，Yazid 进行了整理，发现这些日子里，弗雷兹的玩具商店里共发生了 $Q$ 个事件。

对于每个事件，都有 $3$ 个基本参数 $op,l,r$ 。其中 $op$ 为 $1$ 至 $3$ 之间的整数，代表了事件的类别：

1. 对于 $op=1$ 的事件，Yazid 还会给你一个额外参数 $d$ ，表示这是一个**价格调整**事件：将编号在区间 $[l,r]$ 内的玩具的单价 $c$ 全部增加 $d$ 元。为了防止单价超过 $m$ 元导致玩具永远无法被小朋友们购买，弗雷兹会将所有超过 $m$ 的单价减去 $m$。（保证 $d$ 为不超过 $m$ 的正数）

2. 对于 $op=2$ 的事件，Yazid还会给你一个额外参数 $b$ ，表示这是一个**愉悦修正**事件：将编号在区间 $[l,r]$ 内的玩具的愉悦度 $v$ 全部增加 $b$ 。（需要注意这里的 $b$ 可能是负数）

3. 对于 $op=3$ 的事件，表示**购买**事件：所有的 $m$ 个小朋友来到弗雷兹的玩具商店，在编号范围在 $[l,r]$ 内的玩具中进行随意地购买。

现在，对于每一次的购买事件，你想知道：

1. 所有小朋友所能获得的最大愉悦度之和。

2. 所有小朋友所能获得的最大愉悦度的异或和（异或运算是 $\mathrm{xor}$ 运算，即 C++/Java/Python 中的 `^` 运算）。

## 说明/提示

### 样例解释

对于第 $1$ 个购买事件，各位小朋友（编号从小到大，即从 $1$ 至 $10$）能够获得的最大愉悦度依次为：$100,300,400,600,700,2333,2433,2633,2733,2933$。

对于第 $2$ 个购买事件，各位小朋友（编号从小到大，即从 $1$ 至 $10$）能够获得的最大愉悦度依次为：$100,200,300,400,500,2333,2433,2533,2633,2733$。

对于第 $3$ 个购买事件，各位小朋友（编号从小到大，即从 $1$ 至 $10$）能够获得的最大愉悦度依次为：$666,1332,1998,2664,3330,3996,4662,5328,5994,6660$。

对于第 $4$ 个购买事件，各位小朋友（编号从小到大，即从 $1$ 至 $10$）能够获得的最大愉悦度依次为：$0,0,300,300,300,600,733,733,900,1033$。

根据这些信息，你将很容易计算出答案。

### 数据范围

保证 $1\le n\leq 200,000$，$1\le m\leq 60$，$0\le Q\leq 30,000$。

保证 $1\leq c_i,d\leq m$。

保证 $0\leq v_i\leq 10^7$，$\left| b\right|\leq 10^3$。

### 提示

这个提示本不该有，但善良的出题人还是想提醒你：所有小朋友所能获得的最大愉悦度之和有可能超过 $32$ 位有符号整数的范围。

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
4 10
1 6 10 2
100 2333 666 300
7
3 1 4
3 1 3
1 2 4 1
3 1 4
2 2 3 -1000
2 2 3 -600
3 2 4```

### 输出

```
15165 2865
14165 2169
36630 798
4899 1273```

# 题解

## 作者：AThousandSuns (赞：3)

在我的博客园食用效果更佳：[点这里](https://www.cnblogs.com/1000Suns/p/11179686.html)

最近状态有点颓，刷刷水题找找自信。

首先每次询问就是完全背包。可以 $O(m^2)$。

由于每个物品都可以用无数次，所以对于价格相同的物品，我们只用考虑愉悦度最高的。

直接上线段树。$val[i]$ 表示这个区间中价格为 $i$ 的物品中最大的愉悦度。如果没有这样的物品就是 -INF。

询问就把这个区间的所有 $val$ 取出来，做个完全背包就好了。

两种修改操作用个标记随便搞搞。分别是区间的每个数组平移，和区间加。

复杂度 $O(nm\log n+q(m^2+m\log n))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=200020,INF=1e9;
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,m,q,c[maxn],v[maxn],tmp[66],ctag[maxn*4],vtag[maxn*4];
ll f[66];
struct node{
	int val[66];
	bool vis[66];
	node operator+(const node &nd)const{
		node ans;
		ans.val[0]=-INF;
		FOR(i,1,m) ans.val[i]=max(val[i],nd.val[i]);
		return ans;
	}
}seg[maxn*4];
inline void setc(int o,int v){
	FOR(i,1,m) tmp[(i+v-1)%m+1]=seg[o].val[i];
	FOR(i,1,m) seg[o].val[i]=tmp[i];
	ctag[o]=(ctag[o]+v)%m;
}
inline void setv(int o,int v){
	FOR(i,1,m) seg[o].val[i]+=v;
	vtag[o]+=v;
}
inline void pushdown(int o){
	if(ctag[o]){
		setc(o<<1,ctag[o]);
		setc(o<<1|1,ctag[o]);
		ctag[o]=0;
	}
	if(vtag[o]){
		setv(o<<1,vtag[o]);
		setv(o<<1|1,vtag[o]);
		vtag[o]=0;
	}
}
void build(int o,int l,int r){
	if(l==r){
		FOR(i,0,m) seg[o].val[i]=-INF;
		seg[o].val[c[l]]=v[l];
		return;
	}
	int mid=(l+r)>>1;
	build(lson);build(rson);
	seg[o]=seg[o<<1]+seg[o<<1|1];
}
void updatec(int o,int l,int r,int ql,int qr,int v){
	if(l>=ql && r<=qr) return void(setc(o,v));
	pushdown(o);
	int mid=(l+r)>>1;
	if(mid>=ql) updatec(lson,ql,qr,v);
	if(mid<qr) updatec(rson,ql,qr,v);
	seg[o]=seg[o<<1]+seg[o<<1|1];
}
void updatev(int o,int l,int r,int ql,int qr,int v){
	if(l>=ql && r<=qr) return void(setv(o,v));
	pushdown(o);
	int mid=(l+r)>>1;
	if(mid>=ql) updatev(lson,ql,qr,v);
	if(mid<qr) updatev(rson,ql,qr,v);
	seg[o]=seg[o<<1]+seg[o<<1|1];
}
node query(int o,int l,int r,int ql,int qr){
	if(l>=ql && r<=qr) return seg[o];
	pushdown(o);
	int mid=(l+r)>>1;
	if(mid<ql) return query(rson,ql,qr);
	if(mid>=qr) return query(lson,ql,qr);
	return query(lson,ql,qr)+query(rson,ql,qr);
}
int main(){
	n=read();m=read();
	FOR(i,1,n) c[i]=read();
	FOR(i,1,n) v[i]=read();
	build(1,1,n);
	q=read();
	while(q--){
		int op=read(),l=read(),r=read();
		if(op==1) updatec(1,1,n,l,r,read());
		else if(op==2) updatev(1,1,n,l,r,read());
		else{
			node ans=query(1,1,n,l,r);
			FOR(i,0,m) f[i]=0;
			FOR(i,1,m) FOR(j,0,i) f[i]=max(f[i],f[i-j]+max(0,ans.val[j]));
			ll s1=0,s2=0;
			FOR(i,1,m) s1+=f[i],s2^=f[i];
			printf("%lld %lld\n",s1,s2);
		}
	}
}
```

---

## 作者：Refined_heart (赞：1)

#####  一点吐槽

~~做的时候看到有异或心里就想到不会还要什么可持久化 `Trie` 多合一吧不会做不会做溜了，然而题目中并没有那种东西~~

### 题目大意

一共有 $m$ 种重量的物品，每次可以给区间中的物品重量区间加减，以及价值区间加减。询问一段区间中的物品做完全背包后的价值和。

### $\text{Solution:}$

首先观察到 $m\leq 60,$ 这引导我们有一个暴力的想法。

首先容易根据贪心得到，**每一种权值的物品我们只需要保留价值最大的**即可。所以我们容易想到，用线段树直接维护这个权值数组，也就是在每个线段树节点上，维护这个节点对应区间的所有物品构成的最优物品组合。

然后会发现这个东西进行 `pushup` 以及 `pushdown` 都是可以暴力维护的，复杂度是 $O(m)$

具体而言两种标记打上之后暴力对 $m$ 个数修改即可。

进行查询的时候，我们直接把对应节点的所有信息合并起来，拉出来做完全背包即可。

复杂度就是 $O(nm\log n+q(m^2+m\log n))$ 了。

启发了用线段树直接套数组来维护信息的思想。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
#define int long long
#define fi first
#define se second
#define mk make_pair
#define pb emplace_back
#define poly vector<int>
#define Bt(a) bitset<a>
#define bc __builtin_popcount
#define pc putchar
#define ci const int&
const int mod = 1e9 + 7;
const db eps = 1e-10;
inline int Max(ci x, ci y) {return x > y ? x : y;}
inline int Min(ci x, ci y) {return x < y ? x : y;}
inline db Max(db x, db y) {return x - y > eps ? x : y;}
inline db Min(db x, db y) {return x - y < eps ? x : y;}
inline int Add(ci x, ci y, ci M = mod) {return (x + y) % M;}
inline int Mul(ci x, ci y, ci M = mod) {return 1ll * x * y % M;}
inline int Dec(ci x, ci y, ci M = mod) {return (x - y + M) % M;}
typedef pair<int, int> pii;
inline int Abs(int x) {return x < 0 ? -x : x;}
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char Obuf[105000],*O=Obuf;//Siz shoule be the size of Out File
int pst[30],ptop;
inline void Fprint(){fwrite(Obuf,1,O-Obuf,stdout);}
inline void Fwrite(int x){
  if(x==0){*O++='0';return;}
  if(x<0)*O++='-',x=-x;ptop=0;
  while(x)pst[++ptop]=x%10,x/=10;
  while(ptop)*O++=pst[ptop--]+'0';
  if(O-Obuf>100000)Fprint(),O=Obuf;
}
inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') w = -1;ch = getchar();}
    while (isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
    return s * w;
}
inline void write(int x) {
    if (x < 0)putchar('-'), x = -x;
    if (x > 9)write(x / 10);
	pc(x % 10 + '0');
}
inline int qpow(int x, int y) {
    int res = 1;
    while (y) {if (y & 1)res = Mul(res, x);x = Mul(x, x);y >>= 1;}
    return res;
}
inline void cadd(int &x, int y) {x += y;}
inline void cmul(int &x, int y) {x *= y;}
inline void cmax(int &x, int y) {x = Max(x, y);}
inline void cmin(int &x, int y) {x = Min(x, y);}
const int N = 2e5 + 10;
const int inf = (1LL << 60);
namespace Refined_heart{
	int n,m,c[N],v[N],trans[100];
	int vl[N<<2][100],atag[N<<2],xtag[N<<2],ans[100];
	void pushup(int x){for(int i=1;i<=m;++i)vl[x][i]=Max(vl[x<<1][i],vl[x<<1|1][i]);}
	void build(int x,int L,int R){
		for(int i=1;i<=m;++i)vl[x][i]=-inf;
		if(L==R){vl[x][c[L]]=v[L];return;}
		int mid=(L+R)>>1;
		build(x<<1,L,mid);
		build(x<<1|1,mid+1,R);
		pushup(x);
	}
	void downa(int x,int v){
		atag[x]+=v;
		for(int i=1;i<=m;++i)vl[x][i]+=v;
	}
	void downx(int x,int v){
		xtag[x]+=v;
		for(int i=1;i<=m;++i)trans[(i-1+v)%m+1]=vl[x][i];
		for(int i=1;i<=m;++i)vl[x][i]=trans[i];
	}
	inline void pushdown(int x){
		if(atag[x]){
			downa(x<<1,atag[x]);
			downa(x<<1|1,atag[x]);
			atag[x]=0;
		}
		if(xtag[x]){
			downx(x<<1,xtag[x]);
			downx(x<<1|1,xtag[x]);
			xtag[x]=0;
		}
	}
	void change_add(int x,int L,int R,int l,int r,int v){
		if(L>=l&&R<=r){
			downa(x,v);
			return;
		}
		int mid=(L+R)>>1;pushdown(x);
		if(l<=mid)change_add(x<<1,L,mid,l,r,v);
		if(mid<r)change_add(x<<1|1,mid+1,R,l,r,v);
		pushup(x);
	}
	void change_xuan(int x,int L,int R,int l,int r,int v){
		if(L>=l&&R<=r){
			downx(x,v);
			return;
		}
		int mid=(L+R)>>1;pushdown(x);
		if(l<=mid)change_xuan(x<<1,L,mid,l,r,v);
		if(mid<r)change_xuan(x<<1|1,mid+1,R,l,r,v);
		pushup(x);
	}
	void Query(int x,int L,int R,int l,int r){
		if(L>=l&&R<=r){
			for(int i=1;i<=m;++i)cmax(ans[i],vl[x][i]);
			return;
		}
		int mid=(L+R)>>1;pushdown(x);
		if(l<=mid)Query(x<<1,L,mid,l,r);
		if(mid<r)Query(x<<1|1,mid+1,R,l,r);
	}
	int f[100];
	void solve(){
		n=read();m=read();
		for(int i=1;i<=n;++i)c[i]=read();
		for(int i=1;i<=n;++i)v[i]=read();
		int QQ=read();
		build(1,1,n);
		while(QQ--){
			int op=read(),l=read(),r=read();
			if(op==1){
				int d=read();
				change_xuan(1,1,n,l,r,d);
			}
			if(op==2){
				int d=read();
				change_add(1,1,n,l,r,d);
			}
			if(op==3){
				for(int i=0;i<=m;++i)ans[i]=-inf,f[i]=0;
				Query(1,1,n,l,r);
				for(int i=1;i<=m;++i){
					for(int j=i;j<=m;++j){
						cmax(f[j],f[j-i]+ans[i]);
					}
				}
				int Ans=0;
				for(int i=1;i<=m;++i)Ans+=f[i];
				Fwrite(Ans),*O++=' ';Ans=0;
				for(int i=1;i<=m;++i)Ans^=f[i];
				Fwrite(Ans),*O++='\n';
			}
		}
		Fprint();
	}
}
signed main(){
	Refined_heart::solve();
	return 0;
}
```

---

## 作者：happybob (赞：0)

很简单的一个题。

问题相当于是每次给个区间，你要求区间完全背包的答案。

如果考虑常见的每个区间维护一个背包你发现做不了。懒标记不太能很好的维护，如果将状态升维可以维护懒标记，但是区间合并等价于完全背包合并，复杂度不太对。

但是但凡想到你应该在每次询问时做一次背包那就做完了。线段树上每个区间维护一个 $f_i$ 表示价格为 $i$ 的物品的最大愉悦值是多少。显然这个信息是半群信息，满足结合律。可以 $O(m)$ 合并。懒标记需要维护两种，但显然这两种懒标记是独立的，不需要钦定顺序。同时两种懒标记都是幺半群信息，显然满足结合律。标记对信息的影响显然满足分配律。于是整个线段树维护的信息是双半群信息，必然是对的。

总复杂度 $O(nm\log n+q(m\log n+m^2))$。可以通过。

代码：


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
using namespace std;

using ll = long long;

const int N = 2e5 + 5, M = 65;

int n, m, c[N], v[N], q;
ll g[M];

class SegmentTree
{
public:
	struct Node
	{
		int l, r;
		ll ctag, vtag;
		ll f[M];
	}tr[N << 2];
	void pushup(int u)
	{
		for (int i = 0; i < M; i++)
		{
			tr[u].f[i] = max(tr[u << 1].f[i], tr[u << 1 | 1].f[i]);
		}
	}
	void pushtagc(int u, ll c)
	{
		tr[u].ctag += c;
		for (int i = 0; i < M; i++) g[i] = (ll)-1e14;
		for (int i = 0; i < M; i++)
		{
			ll nc = (i + c) % m;
			if (!nc) nc = m;
			g[nc] = max(g[nc], tr[u].f[i]);
		}
		for (int i = 0; i < M; i++) tr[u].f[i] = g[i];
	}
	void pushtagv(int u, ll v)
	{
		tr[u].vtag += v;
		for (int i = 0; i < M; i++) tr[u].f[i] += v;
	}
	void pushdown(int u)
	{
		if (tr[u].ctag)
		{
			pushtagc(u << 1, tr[u].ctag);
			pushtagc(u << 1 | 1, tr[u].ctag);
			tr[u].ctag = 0;
		}
		if (tr[u].vtag)
		{
			pushtagv(u << 1, tr[u].vtag);
			pushtagv(u << 1 | 1, tr[u].vtag);
			tr[u].vtag = 0;
		}
	}
	void build(int u, int l, int r)
	{
		tr[u].l = l, tr[u].r = r;
		tr[u].ctag = tr[u].vtag = 0ll;
		for (int i = 0; i < M; i++) tr[u].f[i] = (ll)-1e14;
		if (l == r)
		{
			tr[u].f[c[r]] = v[r];
			return;
		}
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
	void updatec(int u, int l, int r, ll c)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			pushtagc(u, c);
			return;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) updatec(u << 1, l, r, c);
		if (r > mid) updatec(u << 1 | 1, l, r, c);
		pushup(u);
	}
	void updatev(int u, int l, int r, ll v)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			pushtagv(u, v);
			return;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) updatev(u << 1, l, r, v);
		if (r > mid) updatev(u << 1 | 1, l, r, v);
		pushup(u);
	}
	ll query(int u, int l, int r, int c)
	{
		if (tr[u].l >= l and tr[u].r <= r) return tr[u].f[c];
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		ll res = (ll)-1e14;
		if (l <= mid) res = query(u << 1, l, r, c);
		if (r > mid) res = max(res, query(u << 1 | 1, l, r, c));
		return res;
	}
}sgt;

ll dp[N], val[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> c[i];
	for (int i = 1; i <= n; i++) cin >> v[i];
	sgt.build(1, 1, n);
	cin >> q;
	while (q--)
	{
		int op, l, r;
		cin >> op >> l >> r;
		if (op == 1)
		{
			ll d;
			cin >> d;
			sgt.updatec(1, l, r, d);
		}
		else if (op == 2)
		{
			ll d;
			cin >> d;
			sgt.updatev(1, l, r, d);
		}
		else
		{
			for (int i = 0; i < M; i++) dp[i] = val[i] = 0ll;
			dp[0] = val[0] = 0ll;
			for (int i = 1; i <= m; i++) val[i] = sgt.query(1, l, r, i);
			for (int i = 1; i <= m; i++)
			{
				for (int j = i; j <= m; j++) dp[j] = max(dp[j], dp[j - i] + val[i]);
			}
			ll sum = 0ll, xa = 0ll;
			for (int i = 1; i <= m; i++)
			{
				sum += dp[i];
				xa ^= dp[i];
			}
			cout << sum << " " << xa << "\n";
		}
	}
	return 0;
}
```

---

## 作者：__DDDDDD__ (赞：0)

## 题面描述

[$\mathcal{Link}$](https://www.luogu.com.cn/problem/P5455)

给定 $n$ 种物品，每个物品有两种属性：单价 $c_{i}$，愉悦度 $v_{i}$，每种物品数量无限。

有如下三种操作：

1. `1 l r d`，表示将区间 $[l,r]$ 的所有物品单价增加 $d$，并将超过 $m$ 的单价减去 $m$；

1. `2 l r b`，表示将区间 $[l,r]$ 的所有物品愉悦度增加 $b$；

1. `3 l r`，表示一次询问：对于 $x \in [1,m]$，询问购买总价不超过 $x$ 的物品所得到的最大愉悦度的和与异或和分别是多少。

## 题目分析

容易想到，对于两个单价相同的物品，由于数量不限，选择愉悦度高的物品必比另一种物品更优，于是我们只保留相同价格下愉悦度最高的物品。

先忽略修改操作，对于每一个询问三，相当于取出区间 $[l,r]$ 的物品做一次完全背包。因为 $m \in [1,60]$，且我们只保留相同价格下愉悦度最高的物品，所以可以用线段树树维护之，即线段树上每个节点维护一个数组 $val$，$val[i]$ 表示一个区间内单价为 $i$ 的物品的愉悦度最大值。

再考虑修改，对于 $i \in [1,m]$，操作一相当于 $val[j] \gets val[i]$（其中 $j$ 为修改后的单价）；操作二相当于 $val[i] \gets val[i]+b$。属于线段树的基本区间操作，打标记维护即可。

~~虽然题目中写了~~，注意开`long long`；同时因为值可能出现负数，注意将 $val$ 的初值设为 $-\infty$。

其他细节详见下方代码：

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
inline int read(){
	re int x=0,f=1;re char ch=getchar();
	while(!isdigit(ch)&&ch!='-')ch=getchar();
	if(ch=='-')f=-1,ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
const int maxn=2e5+10;
int n,m,q;
int c[maxn],v[maxn];
int ddd[66];	

struct node{
	int l,r,val[66];
	int tagc,tagv;
	node(){
		memset(val,128,sizeof val);		// 初值设为-INF 
	}
}t[maxn<<2];
inline void update(int p){
	for(int i=1;i<=m;i++)t[p].val[i]=max(t[p<<1].val[i],t[p<<1|1].val[i]);
}
inline void modify_c(int p,int val){	// 维护单价(val[j]<-val[i])
	for(int i=1;i<=m;i++){
		int j=i+val;
		while(j>m)j-=m;
		ddd[j]=t[p].val[i];
	}
	for(int i=1;i<=m;i++)t[p].val[i]=ddd[i];
	t[p].tagc=(t[p].tagc+val)%m;		// 及时取模防止TLE
}
inline void modify_v(int p,int val){	// 维护愉悦度(val[i]<-val[i]+b)
	for(int i=1;i<=m;i++)t[p].val[i]+=val;
	t[p].tagv+=val;
}
inline void spread(int p){
	if(t[p].tagc){
		modify_c(p<<1,t[p].tagc);
		modify_c(p<<1|1,t[p].tagc);
		t[p].tagc=0;
	}
	if(t[p].tagv){
		modify_v(p<<1,t[p].tagv);
		modify_v(p<<1|1,t[p].tagv);
		t[p].tagv=0;
	}
}
inline void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	if(l==r){
		t[p].val[c[l]]=v[l];
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	update(p);
}
inline void change_c(int p,int l,int r,int val){
	if(l<=t[p].l&&t[p].r<=r){
		modify_c(p,val);
		return;
	}
	spread(p);
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid)change_c(p<<1,l,r,val);
	if(r>mid)change_c(p<<1|1,l,r,val);
	update(p);
}
inline void change_v(int p,int l,int r,int val){
	if(l<=t[p].l&&t[p].r<=r){
		modify_v(p,val);
		return;
	}
	spread(p);
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid)change_v(p<<1,l,r,val);
	if(r>mid)change_v(p<<1|1,l,r,val);
	update(p);
}
inline node merge(node L,node R){		// 合并两个节点的val信息
	node res;
	for(int i=1;i<=m;i++){
		res.val[i]=max(L.val[i],R.val[i]);
	}
	return res;
}
inline node query(int p,int l,int r){
	if(l<=t[p].l&&t[p].r<=r){
		return t[p];
	}
	spread(p);
	node res;
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid)res=merge(res,query(p<<1,l,r));
	if(r>mid)res=merge(res,query(p<<1|1,l,r));
	return res;
}

int dp[maxn];
signed main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)c[i]=read();
	for(int i=1;i<=n;i++)v[i]=read();
	build(1,1,n);
	q=read();
	for(int i=1;i<=q;i++){
		int opt=read(),l=read(),r=read();
		if(opt==1){
			int d=read()%m;
			change_c(1,l,r,d);
		}else if(opt==2){
			int d=read();
			change_v(1,l,r,d);
		}else if(opt==3){
			node tmp=query(1,l,r);
			int ans1=0,ans2=0;
			for(int i=1;i<=m;i++){		// 完全背包
				dp[i]=0;				// 记得清空dp数组
				for(int j=0;j<=i;j++){
					dp[i]=max(dp[i],dp[i-j]+max(0ll,tmp.val[j]));
				}
				ans1+=dp[i];
				ans2^=dp[i];
			}
			printf("%lld %lld\n",ans1,ans2);
		}
	}
	return 0; 
} 
```


---


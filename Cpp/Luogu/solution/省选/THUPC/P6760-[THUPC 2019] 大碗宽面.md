# [THUPC 2019] 大碗宽面

## 题目描述

Yazid 喜欢吃大碗宽面。现有 $m$ 碗宽面，其中第 $i$ 碗宽面（$1 \le i \le m$）共包含 $n_i$ 根面条，它们的宽度分别为 $A_{i,1},A_{i,2},\cdots,A_{i,n}$。

记 $f(u,v)$ 表示若混合第 $u$ 碗宽面和第 $v$ 碗宽面，将得到的超大碗宽面的第 $\left\lfloor\dfrac{n_u +n_v +1}{2}\right\rfloor$ 小的面条宽度（$\lfloor x \rfloor$ 表示不超过 $x$ 的最大整数）。

Yazid 想求出所有 $f(u,v)$，但为了节省你的输出时间，你只需要对所有 $1 \le u \le m$ 求出：

- $R(u)=\mathop{\rm xor}\limits_{v=1}^{m} {(f(u,v)+u+v)}$（$\rm xor$ 指异或运算，在 C++ 语言中对应 `^` 运算符）。

## 说明/提示

#### 样例说明

对于样例 $1$：

- $\def\x{\operatorname{xor}} R(1) = {(f(1,1)+2)}\x{(f(1,2)+3)}\x{(f(1,3)+4)} = 4\x6\x6 = 4$
- $\def\x{\operatorname{xor}} R(2) = {(f(2,1)+3)}\x{(f(2,2)+4)}\x{(f(2,3)+5)} = 6\x8\x9 = 7$
- $\def\x{\operatorname{xor}} R(3) = {(f(3,1)+4)}\x{(f(3,2)+5)}\x{(f(3,3)+6)} = 6\x9\x8 = 7$

#### 数据规模与约定

对于 $100\%$ 的数据，$m \le 10^4$，$n_i \le 500$，$0 \le A_{i,j} \le 10^9$。

#### 说明

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 https://github.com/wangyurzee7/THUPC2019 查看。

## 样例 #1

### 输入

```
3
3 1 2 3
3 3 4 5
2 4 2```

### 输出

```
4
7
7```

# 题解

## 作者：detect (赞：5)

## [题目传送门](https://www.luogu.com.cn/problem/P6760)

看起来非常不可做的题。

寻找突破点，每一个桶先内部排序，中位数变式有

- 如果中位数在t，位置为post,在s中第一个比中位数小的数位置在poss。

有$\frac{|s|+|t|+1}{2}=post+poss$,将其做变形：$|s|-2*poss==2*post-|t|$。

因为必须要是做接近的两个数满足这个关系才成立。

所以不难想到对每一个数按照权值排序，同时记录其$|i|-2*posi$。

任何时刻都只保留每一个桶最大的数，只要有满足上述式子的一对桶就是一组解。

查询值和删除值可以用链表$O(1)$实现。

因为一共只有$N^2$对，所以总时间复杂度为$O(N^2+NMlogM)$

(p.s 链表好难调）

code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int getint(){
	int summ=0,f=1;char ch;
	for(ch=getchar();!isdigit(ch)&&ch!='-';ch=getchar());
	if(ch=='-')f=-1,ch=getchar();
	for(;isdigit(ch);ch=getchar()) summ=(summ<<3)+(summ<<1)+ch-48;
	return summ*f;
}
const int M=1e4+5,N=505;
int n,m,b[N],cnt;
struct node{
	int val,id;
	friend bool operator < (node x,node y){
		return x.val<y.val;
	}
}a[N*M];
int vl[M*4],ans[M*4],head[M*4],nex[M*4],pre[M*4];
inline void Insert(int val,int pos){
	val+=2*M;
	if(head[val]) pre[head[val]]=pos;
	nex[pos]=head[val];head[val]=pos;
}
inline void Delete(int val,int pos){
	val+=2*M;
	if(nex[pos]) pre[nex[pos]]=pre[pos];
	if(pre[pos]) nex[pre[pos]]=nex[pos];
	if(head[val]==pos) head[val]=nex[pos];
	nex[pos]=pre[pos]=0;
} 
signed main(){
	cin>>m;
	for(int i=1;i<=m;i++){
		n=getint();vl[i]-=n;
		for(int j=1;j<=n;j++) b[j]=getint();
		sort(b+1,b+n+1);
		ans[i]^=(i+i+b[(n+1)>>1]);
		Insert(-n,i);
		for(int j=1;j<=n;j++) a[++cnt].val=b[j],a[cnt].id=i;
	}
	sort(a+1,a+cnt+1);
	for(int i=1;i<=cnt;i++){
		Delete(vl[a[i].id],a[i].id);vl[a[i].id]+=2;Insert(vl[a[i].id],a[i].id);
		for(int j=head[2*M-vl[a[i].id]];j;j=nex[j])
		  if(j!=a[i].id) ans[j]^=(j+a[i].id+a[i].val),ans[a[i].id]^=(j+a[i].id+a[i].val);
		for(int j=head[2*M-vl[a[i].id]+1];j;j=nex[j])
		  if(j!=a[i].id) ans[j]^=(j+a[i].id+a[i].val),ans[a[i].id]^=(j+a[i].id+a[i].val);
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<"\n";
	return 0;
}
```


---

## 作者：UnyieldingTrilobite (赞：3)

[如果你是从博客点进来的，关于标题，自行体会](https://www.luogu.com.cn/problem/P6760)。

大家好啊这里是一只啥也不会然后无脑过了这个题的菜鸡。

首先会有一个传统刻画之枚举中位数：给所有元素一个序然后从小到大枚举每一条面，看看以之为中位的碗是哪些。很显然两碗中必有一碗是这条面所在碗。

考虑给每条面一个权值，初始为 $-1$。每枚举到一条面就把它的权值改成 $1$。一碗面的权值是其中所有面的权值的总和。这样的话我们的中位数判定就呼之欲出了：两碗（不同）面的权值之和是 $0$ 或 $1$。如果两碗面是相同的，那就是当前碗的权值是 $0$ 或 $1$（中位数常见套路）。

那么我们要做的其实是这些操作：给定一堆数，支持单点修改，和查询某一权值上的所有数是哪些。很显然可以在每个权值后面拖个链表解决之。复杂度 $O(m^2+mn(\log(m)+\log(n)))$。

哦另外有一个小小小 trick：我们可以对每碗面和自己算中位数的情况特判掉，此时两碗面的权值之和只能是 $0$ 或 $2$，那在枚举权值和是 $1$ 的时候不必特判。而枚举权值 $0$ 的时候实际上也不必特判，对此可以参考代码实现，异或两次会自动抵消。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int M = 1e4 + 9, N = 509;
int m, ans[M], ttot;
pair<int, int> tmp[M * N];
int hd[N << 1], pre[M], nxt[M], val[M];
void append(int x) {
  pre[hd[val[x] + N]] = x;
  nxt[x] = hd[val[x] + N];
  hd[val[x] + N] = x, pre[x] = 0;
}
void add2(int x) {
  (pre[x] ? nxt[pre[x]] : hd[val[x] + N]) = nxt[x];
  if (nxt[x]) pre[nxt[x]] = pre[x];
  val[x] += 2, append(x);
}
int main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> m;
  for (int i = 1, n; i <= m; ++i) {
    cin >> n, val[i] = -n, append(i);
    for (int a; n; --n) cin >> a, tmp[ttot++] = {a, i};
  }
  sort(tmp, tmp + ttot);
  for (int p = 0; p < ttot; ++p) {
    auto [a, id] = tmp[p];
    add2(id);
    if (val[id] == 1 || !val[id]) ans[id] ^= a + id + id;
    for (int j = hd[-val[id] + N]; j; j = nxt[j])
      ans[id] ^= a + id + j, ans[j] ^= a + id + j;
    for (int j = hd[1 - val[id] + N]; j; j = nxt[j])
      ans[id] ^= a + id + j, ans[j] ^= a + id + j;
  }
  copy(ans + 1, ans + m + 1, ostream_iterator<int>{cout, "\n"});
  return cout << flush, 0;
}
```

Over.

---

## 作者：Waldin (赞：2)

### 题目摘要

给定 $m\isin[1\dots10^4]$个多重集合（multiset），第 $i\isin[1\dots m]$个集合有 $n_i\isin[1\dots500]$个元素。对于给定的任意两个多重集合，都要求它们的并中所有元素的中位数。

### 思路分析

首先对于中位数（median），有如下性质：考虑两个多重集合 $A=\{a_1,a_2,\dots,a_s\}$和 $B=\{b_1,b_2,\dots,b_t\}$，假设它们内部都是升序，且 $s$ 和 $t$ 都是偶数，那么对于它们的并中所有元素的中位数 $a_j$，以及 $B$ 中最后一个不大于 $a_j$ 的元素 $b_k$，有 $j+k=\dfrac{s+t}2$，变形得$(2j-s)+(2k-t)=0$。这样对于此题，就可以枚举每一条面作为 $a_j$，然后查找满足条件的 $B$。

查找过程显然可以枚举 $B$，然后遍历 $B$ 中所有的元素来找到 $k$，最后带入式子判断 $B$ 是否合法，但是现在需要考虑优化。先考虑如何优化 $k$ 的查找，发现如果 $a_j$ 是从窄到宽枚举的，那么 $b_k$ 就是 $B$ 中最近一次被枚举到的元素；再考虑如何用这个优化进一步优化 $B$ 的查找，发现此时 $2k-t$ 仅在枚举到 $B$ 中的元素时会发生改变，所以可以用桶来记录 $2k-t$ 为某个值的 $B$ 有哪些，然后每枚举到 $B$ 中的元素就把 $2k-t$ 增 $2$，最后桶内元素用链表（list）存储，便于快速删除。

### 代码实现

具体地，可以设每一条面都有一个权值，初始为$-1$，然后从窄到宽枚举每一条面，枚举到某一条面就把这条面的权值改为 $1$，此时 $2j-s$ 和 $2k-t$ 就变成了 $A$ 和 $B$ 内面的权值和，那么碗内面权值和与这条面所在碗内面的权值和的和为 $0$ 的碗就是 $B$。

最后对于 $s$ 或 $t$ 为奇数的情况，把判断条件改为$(2j-s)+(2k-t)=1$，也就是两碗面的碗内面权值和的和为 $1$ 即可。

总时间复杂度为 $\text O(m^2+nm\log nm)$。

示例代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define typeof(...) __decltype(__VA_ARGS__)
constexpr size_t MAXm = 1e4, MAXn = 500;

#ifndef _getchar_nolock
#define _getchar_nolock getchar_unlocked
#endif
class FastIn_Base {
public:
    template<typename _Ty>
    FastIn_Base& operator>>(_Ty& __restrict__ int_var) noexcept {
        int c; bool f;
        if (is_signed<_Ty>::value)
            f = false;
        while (!isdigit(c = _getchar_nolock()))
            if (is_signed<_Ty>::value && c == 45)
                f = true;

        int_var = c - 48;
        while (isdigit(c = _getchar_nolock()))
            int_var = int_var * 10 + (c - 48);

        if (is_signed<_Ty>::value && f)
            int_var = -int_var;
        return *this;
    }
};
#define intIn ((FastIn_Base) {})
#define cin intIn

class Bowl {
public:
    unsigned short siz;  // 属于该碗的面数
    list<unsigned short>* lt;  // 所属的链表
    list<unsigned short>::iterator pos;  // 在 *lt 中对应元素的迭代器
};

class Noodle {
public:
    unsigned long width;  // 宽度
    Bowl* bowl;  // 所属碗

    constexpr bool operator<(const Noodle& __restrict__ y) const noexcept {
        return width < y.width;
    }
};

int main(void) noexcept {
    ios::sync_with_stdio(false);
    #ifndef cin
    cin.tie(nullptr);
    #endif

    unsigned short m; cin >> m;
    Bowl bowls[MAXm];  // 碗们
    Noodle noodles[MAXm * MAXn];  // 面们
    unsigned long idx = 0;  // noodles[] 内的元素数量
    list<unsigned short> lts_BASE[2 * MAXn + 1];
    auto lts = &lts_BASE[MAXn];  // 碗内所有面的权值和为 i 的碗们
    for (typeof(m)i = 0; i < m; ++i) {
        cin >> bowls[i].siz;
        for (auto j = bowls[i].siz; j--;) {
            cin >> noodles[idx].width;
            noodles[idx++].bowl = bowls + i;
        }

        (bowls[i].lt = lts - bowls[i].siz)->push_front(i);  // 一开始，所有碗的碗内面权值和都为碗内面数的相反数
        bowls[i].pos = bowls[i].lt->begin();
    }

    sort(noodles, noodles + idx);
    unsigned long ans[MAXm]; memset(ans, 0x00, m * sizeof(*ans));
    for (typeof(idx)i = 0; i < idx; ++i) {
        unsigned short bowl = noodles[i].bowl - bowls;  // 当前枚举到的宽面所属的碗的编号

        // 当前枚举到的宽面的权值设为 1
        bowls[bowl].lt->erase(bowls[bowl].pos);
        (bowls[bowl].lt += 2)->push_front(bowl);
        bowls[bowl].pos = bowls[bowl].lt->begin();

        switch (bowls[bowl].lt - lts) {  // 如果当前碗的碗内面权值和为 0 或 1，那么一定会导致下面两个循环其中的一个，在其某次循环中出现 j = bowl 的情况，然后由于两次连续异或互相抵消，最终漏算了一碗面和自己混合时对答案产生的贡献，所以要在这里对这种情况再单独计算一次
        case 0:
        case 1:
            ans[bowl] ^= noodles[i].width + bowl * 2 + 2;
        }
        for (auto j : lts[lts - bowls[bowl].lt]) {  // 两碗面的碗内面权值和的和为 0
            auto tmp = noodles[i].width + bowl + j + 2;
            ans[bowl] ^= tmp; ans[j] ^= tmp;
        }
        for (auto j : lts[lts - bowls[bowl].lt + 1]) {  // 两碗面的碗内面权值和的和为 1
            auto tmp = noodles[i].width + bowl + j + 2;
            ans[bowl] ^= tmp; ans[j] ^= tmp;
        }
    }

    copy(ans, ans + m, ostream_iterator<unsigned long>(cout, "\n"));
    return 0;
}
```

---


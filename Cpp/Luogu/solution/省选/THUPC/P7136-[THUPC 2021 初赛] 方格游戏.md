# [THUPC 2021 初赛] 方格游戏

## 题目描述

小 F 和小 H 在玩游戏。今天，他们在一个 $N\times M$ 的棋盘上玩游戏。小 H 想考考小 F 的数学能力，但小 F 天生数学就不好，所以想请你帮忙。为了加大难度，小 $H$ 会在棋盘里面加入 $P$ 个矩形障碍物。每个矩形障碍物用 $U$、$D$、$L$、$R$ 来表示，即在第 $U$ 行到第 $D$ 行以及在第 $L$ 列到第 $R$ 列之间的所有格子都变成了障碍物。小 H 保证所有矩形障碍物互不相交，并且所有非障碍物格子之间都能够直接或者间接互达，若两个非障碍物格子有公共边，那么它们直接互达并且它们的距离为 $1$。

现在每一局游戏中，小 F 在棋盘中挑选一个非障碍物格子 $X$，小 H 也挑另外一个非障碍物格子 $Y$，这一局游戏 $(X,Y)$ 的得分就是 $X$ 到 $Y$ 的最短路径。小 F 需要计算出所有可能的游戏中的得分和，答案模 $1,000,000,007$。注意两局游戏中只要挑选的两个格子相同则视为同一局游戏，即 $(X, Y)$ 等同于 $(Y,X)$。

## 说明/提示

**【样例解释 #1】**

距离为 $1$ 的有 $8$ 种。  
距离为 $2$ 的有 $8$ 种。  
距离为 $3$ 的有 $8$ 种。  
距离为 $4$ 的有 $4$ 种。  
总共得分为 $64$。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
3 3 1
2 2 2 2
```

### 输出

```
64
```

# 题解

## 作者：wrpwrp (赞：2)

## 题意

> 小 F 和小 H 在玩游戏。今天，他们在一个 $N \times M$ 的棋盘上玩游戏。小 H 想考考小 F 的数学能力，但小 F 天生数学就不好，所以想请你帮忙。
>
> 为了加大难度，小 H 会在棋盘里面加入 $P$ 个矩形障碍物。每个矩形障碍物用 $U$、$D$、$L$、$R$ 来表示，即在第 $U$ 行到第 $D$ 行以及在第 $L$ 列到第 $R$ 列之间的所有格子都变成了障碍物。小 H 保证所有矩形障碍物互不相交，并且所有非障碍物格子之间都能够直接或者间接互达，若两个非障碍物格子有公共边，那么它们直接互达并且它们的距离为 1 。
>
> 现在每一局游戏中，小 F 在棋盘中挑选一个非障碍物格子 $X$，小 H 也挑另外一个非障碍物格子 $Y$，这一局游戏 $(X,Y)$ 的得分就是 X 到 Y 的最短路径。小 F 需要计算出所有可能的游戏中的得分和，答案模 $1,000,000,007$。
>
> 注意两局游戏中只要挑选的两个格子相同则视为同一局游戏，即 $(X, Y)$ 等同于 $(Y, X)$。
>
> 第一行三个整数 $N(1 \leq N \leq 1,000,000,000)$，$M(1 \leq M \leq 1,000,000,000)$，$P(0 \leq P \leq 100,000)$。
>
> 接下来有 $P$ 行，每行四个正整数，$U_i$，$D_i (1<U_i \leq D_i<N)$，$L_i$，$R_i(1<L_i \leq R_i<M)$，表示第 $i$ 个矩形障碍物。
>
> 对于任意两个不同的矩形障碍物 $i$ 和 $j$，都满足 $D_i+1<U_j$ 或者 $D_j+1<U_i$，以及 $R_i+1<L_j$ 或者 $R_j+1<L_i$。
>
> 只有一行一个正整数，即所有游戏的得分和模 $1,000,000,007$。
>
> 距离为 1 的有 8 种。
>
> 距离为 2 的有 8 种。
>
> 距离为 3 的有 8 种。
>
> 距离为 4 的有 4 种。
>
> 总共得分为 64 。

## 题解

分类讨论题。 ~~终于见到阳间的分类讨论题了， md模拟赛里面的我就没对过~~ 。

~~纪念第一个自己推出来的分类讨论， 虽然好像并没有什么难度~~

考虑先不考虑障碍物直接求每两两之间不考虑障碍物的最短路， 然后减去障碍物里面到外面的， 然后加上绕路的部分， 一点一点讨论。



### 不考虑障碍物的两两最短路之和

考虑对于横坐标和纵坐标分别枚举长度计算贡献得到 :
$$
\sum_{i = 0}^{n - 1}m^2(n -i)i + \sum_{i = 0}^{m - 1}n^2(m - i)i = \frac{m^2(n^3 - n) + n^2(m^3 - m)}{6}
$$

### 计算障碍物内外的最短路之和

只考虑当前一个障碍物， 当前障碍物为 $(l_x, r_x, l_y, r_y)$ 分别表示横纵坐标。

先考虑横坐标的贡献， 记 $S1(n) = \sum_{i = 1}^ni$, $S2 = \sum_{i = 1}^ni^2$。

$$
\sum_{i = l_x} ^{r_x}\sum_{j = 1}^n|j - i|m(r_y - l_y + 1)
$$

令 $m(r_y - l_y + 1) = C$ 最后乘上。

$$ \sum_{i = l_x} ^{r_x}\sum_{j = 1}^n|j - i|$$ 
$$ = \sum_{i = l_x}^{r_x}\sum_{j = 1}^{i - 1} i - j + \sum_{i = l_x}^{r_x}\sum_{j = i +1}^{n} j - i$$

$$ = \sum_{i = l_x}^{r_x}i(i - 1) - \sum_{i = l_x} ^ {r_x} \frac{i(i - 1)}{2} - \sum_{i = l_x}^{r_x}(n - i)i + \sum_{i = l_x}^{r_x}\frac{(n - i)(i + 1 + n)}{2}$$ 
$$= \frac{1}{2} \times \sum_{i = l_x}^{r_x} 2i^2 - 2in +n^2 + n - 2i
$$


所以 $x$ 轴的贡献是 ：
$$
\frac{1}{2} \times C \times [(r_x - l_x + 1) \times (n^2 + n) + 2 (S2(r_x) - S2(l_x - 1)) - (2n + 2)(S1(r_x) - S1(l_x - 1))]
$$
同理 $y$ 轴的贡献就是 ：
$$
\frac{1}{2} \times C \times [(r_y - l_y + 1) \times (m^2 + m) + 2 (S2(r_y) - S2(l_y - 1)) - (2m + 2)(S1(r_y) - S1(l_y - 1))]
$$


### 计算障碍物到自己里面的最短路之和

就是一开始的计算全局不考虑障碍物的路径长度之和的做法。



### 计算当前障碍物里面到外面所有障碍物路径之和

有一个经典的操作。

同样把 $x$ 轴和 $y$ 轴分开考虑， 以 $x$ 轴为例。

我们把矩形按照 $x$ 轴排序， 维护之前的点数和 $cnt$ 以及 $x$ 坐标和 $sum_x$，记当前障碍的点数为 $c$， 当前的障碍的 $x$ 坐标和是 $s$ 。

把答案加上 $cnt \times s - sum_x\times c$ 即可。



### 计算绕远路的部分

同样不妨考虑 $x$ 轴的贡献， 设障碍物的宽为 $l$ ， 左边有 $L$ 个数， 右边有 $R$ 个数， $C = L \times R$ 。可以写出答案 ：
$$ \sum_{i = 1}^l\sum_{j = 1}^l2\times \min(i, l - i + 1, j, l - j + 1) $$
不妨设 $l$ 为偶数， $t = \frac{l}{2}$ 。
$$ \sum_{i = 1}^l\sum_{j = 1}^l2\times \min(i, l - i + 1, j, l - j + 1) $$
$$=4\times \sum_{i = 1}^t\sum_{j = 1}^t2 \min (i, j) $$
$$= 4\times ((2t + 1)\frac{t(t+ 1)}{2} - \frac{t(t + 1)(2t + 1)}{6})$$

考虑 $l$ 是奇数的情况， 只要加一个 $(l +1)^2\times \frac{1}{2}$ 即可， 具体只要观察一下会多出来哪些东西就好了。

[code](https://www.cnblogs.com/clover4/p/15717221.html)

---

## 作者：WaReTle (赞：0)

# 本题方便好写的做法

感谢@[JCY_](https://www.luogu.com.cn/user/141572)巨佬提供思路。

显然横向和纵向距离可以分开算。下文所有距离均只考虑横向距离。将障碍物排序。下文所有障碍物均为排序后的。

由于题目保证 $R_i+1<L_j$ 或 $R_j+1<L_i$ 且 $1<L_i\le R_i<M$ ，我们可以将 $M$ 列分成 $2P+1$ 段使得同一段内的列两两相同，相邻段的列不同，奇数段为“两个障碍物之间的空隙”（由空白列组成），偶数段为某个障碍物对应的列区间（这些列中间由障碍物）。枚举当前列，考虑对答案的贡献。

设 $S1_n=\sum_{i=1}^ni$，$S2_n=\sum_{i=1}^ni^2$。

下文中 $w$ 指当前段的宽度，$h$ 指当前段除去障碍物后的高度，$h_1$ 指当前段障碍物上面的部分的高度，$h_2$ 指当前段障碍物下面的部分的高度，$cnt$ 指当前段所有非障碍物的格子的数量。

**注意：“部分”指对答案的贡献的一部分，“段”指完全相同的列组成的极长连续段。**


第一段（$L_1-1$ 个空白列）对答案的贡献显然很好求，为 $N^2\sum_{i=1}^{w}i(w-i)=N^2(wS1_w-S2_w)$。接下来考虑一个偶数段和一个奇数段组成的“组”的贡献。

首先是偶数段。它对答案的贡献分为三部分：前面的格子到这一段的格子的距离和（横向上一定不会绕路），上下两部分的“无障碍”（类似于第一段）贡献之和，上下两部分之间包含绕路的距离和。

设这一段是 $[l,r]$ 之间的列。我们需要维护前面所有格子到第 $l-1$ 列的距离之和以计算路径中不在此段中的距离之和，维护前面格子的个数用于计算路径中在这一段内的距离之和。

具体地，设前面的格子共有 $tot$ 个，分别位于第 $a_1,a_2,\cdots,a_{tot}$ 列，令 $totlen=\sum_{i=1}^{tot}l-1-a[i]$。则第一部分的贡献总和为 $totlen\times cnt+h\times S1_w\times tot$。在计算下一段时 $tot$ 直接加上 $h\times w$，而 $totlen$ 的变化分两部分：原来的每个点延伸出的距离都增加 $w$，而当前段新增的点到当前段末尾贡献 $hS1_{w-1}$。

第二部分可以类似第一段求。主要问题在于第三部分的“绕路”长度怎么求。~~都是这个害我调了2h。~~

把这一段摘出来，把这一段里的列重新按照 $1\cdots w$ 编号。考虑上半部分某一行的第 $i$ 个格子和下面某一行的第 $j$ 个格子。它们的横向距离为 $\min(i+j,2w+2-i-j)$。考虑某个 $i$，举几个例子后发现它对应的距离序列像下面这样：

$$i+1,i+2,\cdots,w,w+1,w,w-1,\cdots,w+2-i$$

对所有 $i$ 对应的序列的所有元素求和再乘 $h_1h_2$，即为这一部分的“绕路”总长度。（因为这里算的是上面的一行和下面的一行组合的结果，有 $h_1h_2$ 种）

观察发现，在所有序列中除 $w+1$ 外，元素 $i(2\le i\le w)$ 出现了 $2i-2$ 次，而 $w+1$ 出现了 $w$ 次。容易推出所有元素总和为 $2(S2_w-S1_w)+w(w+1)$。

奇数段（空白段）不需要计算”绕路“部分的距离，其他部分类似偶数段的计算方法。

代码如下。只要上面的内容都想清楚了非常好写。

```cpp
#include<bits/stdc++.h>
#define int long long
//这题要开一堆long long，又不卡常，可以直接define
//这是很不好的习惯 
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,m,p;
const int mod=1e9+7,inv2=5e8+4,inv3=333333336,inv6=166666668;
struct block
{
	int u,d,l,r;
}a[100005];
bool operator<(const block&a,const block&b)
{
	return a.l<b.l;
}
int s1n(int n){return n*(n+1)%mod*inv2%mod;}//S1[i]
int s1n2(int n){return n*(n+1)%mod*(n+n+1)%mod*inv6%mod;}//S2[i]
int calcRect(int w,int h)//w*h的矩形区域内的横向距离贡献 
{
	return h*h%mod*(s1n(w)*w%mod-s1n2(w)+mod)%mod;
}
int calc2(int w,int h)//w*h的矩形区域对totlen的贡献 
{
	return h*s1n(w-1)%mod;
}
int calc1(int w)//长为w的两行之间的绕路贡献 
{
	return (2ll*(s1n2(w)-s1n(w)+mod)+(w+1ll)*w)%mod;
}
int calc()
{
	a[p+1].l=m+1;
	int tot=(a[1].l-1ll)*n%mod,ans=calcRect(a[1].l-1,n),totlen=calc2(a[1].l-1,n);
	//第一段空白矩形的答案 
	for(int i=1;i<=p;++i)
	{
		int ht=n-a[i].d+a[i].u-1,wd=a[i].r-a[i].l+1;//ht：上下两部分高的总和 wd：宽 
		ans=(ans+totlen*ht%mod*wd%mod+ht*s1n(wd)%mod*tot%mod)%mod;//第一部分对答案的贡献 
		totlen=(totlen+tot*wd%mod+calc2(wd,ht))%mod;//维护totlen 
		tot=(tot+ht*wd)%mod;//维护tot 
		ans=(ans+calc1(wd)*(a[i].u-1)%mod*(n-a[i].d)%mod)%mod;//绕路
		ans=(ans+calcRect(wd,a[i].u-1)+calcRect(wd,n-a[i].d))%mod;//上下两个矩形 
		wd=a[i+1].l-a[i].r-1,ht=n;//右边的空白部分 
		ans=(ans+totlen*ht%mod*wd%mod+ht*s1n(wd)%mod*tot%mod)%mod;//同上 
		ans=(ans+calcRect(wd,ht))%mod,totlen=(totlen+tot*wd%mod+calc2(wd,ht))%mod;//同上 
		tot=(tot+ht*wd)%mod;//同上 
	}
	return ans;
}
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&p);
	for(int i=1;i<=p;++i)
		scanf("%lld%lld%lld%lld",&a[i].u,&a[i].d,&a[i].l,&a[i].r);
	sort(a+1,a+p+1);
	int ans=calc();
	for(int i=1;i<=p;++i)
		swap(a[i].u,a[i].l),swap(a[i].d,a[i].r);
	swap(n,m);
	//翻转图形重算，不要忘记重新排序 
	sort(a+1,a+p+1);
	ans=(ans+calc())%mod;
	printf("%lld\n",ans);
	return 0;
}
```

update on 2022/7/1:修了几个可能影响理解的锅，新增一些注释。~~刚审核完就重交~~

---


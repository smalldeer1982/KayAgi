# [THUPC 2021 初赛] 棋盘

## 题目描述

有一个 $n$ 行 $m$ 列的棋盘，共有 $n m$ 个格子。请你在格子内放入棋子（每个格子可以放入至多一个棋子），使得对于所有 $1 \le i \le m$，第 $i$ 列里恰好包含 $a_i$ 个棋子。另外，棋盘上的任意两颗棋子都不能边相邻。

请判断是否存在一种合法方案。如果存在，请输出任意一个合法方案。

## 说明/提示

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
3 4
2 1 2 1
```

### 输出

```
Yes
1010
0101
1010
```

## 样例 #2

### 输入

```
3 4
2 3 3 3
```

### 输出

```
No
```

# 题解

## 作者：约瑟夫用脑玩 (赞：12)

#### 题外话：

没错我就是那个考场错了51次的那个垫底队中做这道题的人(之一)。

考场难得看到一道可做(du)题，然后就陷入了奇奇怪怪的构造中。

#### 题解：

题意已经很简洁了(好评)，就不再赘述。

由于限制的是每列多少个(差点看反差评)，于是来考虑行 $n$ 。

如果 $n$ 为偶数，每列都只能放 $\frac{n}{2}$ 个，与相邻的列无关，直接判断即可。

否则至少能放 $\frac{n}{2}$ 个，最多能放 $\frac{n}{2}+1$ 个，差异在于**放在奇数位置上**或**偶数位置**上。

如果 $\max{}a_i$ 超过了 $\frac{n}{2}+1$ 或小于 $\frac{n}{2}$ 了就不再考虑，这些可以特判。

我们称，满足 $a_i = \frac{n}{2}+1$ 的列 $i$ 叫做**顶满**了的列。

我们可以发现如果顶满了的列都在奇数列或偶数列，直接强制保证顶满的列都填奇数位置，由于其他列都未顶满， $\frac{n}{2}$ 个位置就够用了，对于每列从前往后交替(注：交替指奇偶位置交替)填即可，没有影响。

于是考虑某两个顶满的列 $i,j$ 满足 $i < j$ 满足 $j-i \equiv 1 \pmod{2}$ ，即中间行数为偶行。

此时如果你不进行操作，你强制两列都放奇数位置，中间的列就可能出现问题，更具体的，你需要将 $j-1$ 的奇数位置空出来，否则无法构造。

考虑构造一种方法让其空出来，由于原来不操作时，这些列是交替填的，我们希望让中间某两行打破这个交替。

那么我们就**从后往前**尽量让当前行不与上一行交替，可能会剩下一些必定交替，此时再正常的按交替的填，直到某两行打破交替，后面的构造就都会切换奇偶交替的状态了，使得 $j-1$ 的奇数位置能空出来。

如果从 $i$ 构造至 $j$ 都还没构造出来就可以输出 $\texttt{NO}$ 走人了，否则用相同的方法处理后面顶满的列即可。

还是放下核心代码吧qwq：

```cpp
	//这是中间行的构造过程。
	for(k=lst+1;k<i;k++)
	{//lst:上一个顶满的列 i:当前顶满的列 且 (i&1)^(lst&1)。
		for(t=1,j=n-(((k-lst)&1)^1);t<=a[k]&&j>0;t++,j-=2)
		{//这里是尽量不交替
			if(ans[j][k-1])
			{
				break;
			}
			ans[j][k]=1;
		}
		for(j=((k-lst)&1)+1;t<=a[k];t++,j+=2)
		{//这里是必定交替
			if(ans[j][k-1])
			{
				writechar('N','o');
				pc(10,false);
				return output;
			}
			ans[j][k]=1;
		}
	}
```

Upd:较严重的笔误，对题解的理解有较大的影响，已修正。

Upd:顺便修了一下题解不清的地方。

---

## 作者：luobotianle (赞：5)

逆天构造。

首先我们可以发现，对于一个 $n$，每一列最多能放的棋子个数为 $ \lceil \frac{n}{2} \rceil$ 个，多于这个数连这一行都无法保证不相邻，直接 $\texttt{NO}$ 即可；

所以我们很容易想出一种做法：判断第一列的棋子是从 $1$ 开始还是从 $2$ 开始放，然后交替放置即可。

但这样的话显然不对。考虑这组数据：
```
5 4
3 1 1 3
```

有解为：

```
1001
0100
1001
0010
1001
```

然而，交替的方法会输出 $\texttt{NO}$。究其原因，是因为在 $n$ 为奇数时，当 $a_i$ 为 $\lfloor \frac{n}{2} \rfloor + 1$ 时，第 $i$ 列的放法只有一种。

所以，我们可以分为以下几种情况讨论：

1. $n$ 为偶数。此时直接交替构造即可。
2. $n$ 为奇数，但没有任何一列的棋子个数为 $\lfloor \frac{n}{2} \rfloor + 1$。同样直接交替构造。
3. $n$ 为奇数，但存在相邻两列棋子个数均为 $\lfloor \frac{n}{2} \rfloor + 1$。此时无解。
4. $n$ 为奇数，存在某几个不相邻的列的棋子个数为 $\lfloor \frac{n}{2} \rfloor + 1$。

前三种情况都很好构造，问题出在第 $4$ 种上。

如果这些棋子个数为 $\lfloor \frac{n}{2} \rfloor + 1$ 的列中不存在 $i,j(i>j)$ 使 $i-j \equiv 1 \pmod 2$，那么只要我们将必须要“顶满”的行先放好，剩下的循环构造即可；

但如果存在 $i,j(i>j)$，$i-j \equiv 1 \pmod 2$，此时第 $i$ 行与第 $j$ 行都要顶满，但奇偶性不同，所以我们要用中间的几行来调整一下奇偶性；

具体地，在中间的几行，我们放棋子时，能不交替就不交替；如果到最后仍然无法排出可行解，输出 $\texttt{NO}$ 就可以了。

最后处理一下两边的散列即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=305;
int n,m,a[N];
bool ism[N];
bool b[N][N];
vector<int> mm;
int main(){
	cin>>n>>m;
	int maxn=n/2+(n%2);
	for(int i=1;i<=m;i++){
		cin>>a[i];
		if(a[i]>maxn)return puts("No"),0;//太多了 
	}
	if(n%2==0){//case 1：n为偶数 
		puts("Yes");
		for(int j=1,f=1;j<=m;j++,f=3-f){
			for(int i=f;i<=n&&a[j];i+=2,a[j]--){
				b[i][j]=1;
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<b[i][j];
			}
			cout<<"\n";
		}
	}
	else{
		for(int i=1;i<=m;i++){
			if(a[i]==maxn)ism[i]=1,mm.push_back(i);
			if(ism[i]==1&&ism[i-1]==1)return puts("No"),0;//case 3：相邻两列均顶满，无解 
		}
		if(mm.empty()){//case 2：没有顶满列 
			puts("Yes");
			for(int j=1,f=1;j<=m;j++,f=3-f){
				for(int i=f;i<=n&&a[j];i+=2,a[j]--){
					b[i][j]=1;
				}
			}
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++){
					cout<<b[i][j];
				}
				cout<<"\n";
			}
			return 0;
		}
		for(int j=1;j<=m;j++){
			if(ism[j]){
				for(int i=1;i<=n;i+=2){
					b[i][j]=1;
				}
			}
		}
		for(int i=1;i<mm.size();i++){
			int d=mm[i]-mm[i-1];
			if(d&1){// case 4-1：相邻两顶满列差为奇数，尝试调整奇偶性 
				int lst=mm[i-1],now=mm[i];
				for(int k=lst+1;k<now;k++){
					int t,j;
					for(t=1,j=n-(((k-lst)&1)^1);t<=a[k]&&j>0;t++,j-=2){
						if(b[j][k-1]||b[j][k+1])break;
						b[j][k]=1;
					}
					for(j=((k-lst)&1)+1;t<=a[k];t++,j+=2){
						if(b[j][k-1]||b[j][k+1]){
							return puts("No"),0;
						}
						b[j][k]=1;
					}
				}
			}
			else{//case 4-2：差为偶数，直接循环构造 
				for(int j=mm[i-1]+1,f=2;j<mm[i];j++,f=3-f){
					for(int i=f;i<=n&&a[j];i+=2,a[j]--){
						if(i>n)break;
						b[i][j]=1;
					}
				}
			}
		}
		for(int j=mm[0]-1,f=2;j>=1;j--,f=3-f){//构造第一列到第一个顶满列间的位置 
			for(int i=f;i<=n&&a[j];i+=2,a[j]--){
				if(i>n)break;
				b[i][j]=1;
			}
		}
		for(int j=mm[mm.size()-1]+1,f=2;j<=m;j++,f=3-f){//最后一个顶满列到最后一列 
			for(int i=f;i<=n&&a[j];i+=2,a[j]--){
				if(i>n)break;
				b[i][j]=1;
			}
		}
		puts("Yes");
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<b[i][j];
			}
			cout<<"\n";
		}
	}
	return 0;
}
```

---


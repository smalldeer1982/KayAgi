# [THUPC 2021 初赛] 狗蛋和二五仔

## 题目背景

**那女孩对我说**  
**代价为十辆铲车**

## 题目描述

小 E 喜欢和老师变换着花样玩牌。最近，他们又发明了一种叫做“狗蛋和二五仔”的玩法。

规则是这样的：

游戏开始时小 E 和老师各有 $30$ 点体力值，手上各有 $2$ 张牌。所有的牌是完全相同的。每个玩家的面前都可以放置牌，开始时双方面前没有任何牌。

双方轮流进行操作。玩家在每个自己的回合开始时先抽一张牌。“抽一张牌”的操作指的是，如果手上的牌的数量小于 $3$ 张，则再抓一张牌放在手上；如果手上恰好有 $3$ 张牌，则不能再抓牌。操作分为 $4$ 种类型。

- 技能。让自己的体力值 $- 2$，然后抽一张牌。
- 攻击。具体地，玩家可以选择一张放在自己面前的**本回合还未攻击过**的牌，选择对方面前的一张牌同归于尽，或者选择一张放在自己面前的**本回合还未攻击过**的牌，让对方的体力值 $- 3$。如果是后者，则将这张选择的牌标记为已攻击。
- 打牌。如果你面前的牌的数量小于 $4$ 张，且手上有牌才能进行此操作。先进行下面的过程 $3$ 次：
  - 随机选择一个角色，让它的体力值 $- 1$。这个角色可以是自己、对方或者某一方面前的一张牌。如果双方场上的牌一共有 $k$ 张，那么选择到任何一个角色的概率为 $\frac{1}{k + 2}$。如果该角色是一张牌且体力值变为了 $0$，那么将它摧毁；如果该角色是一个玩家且体力值变为了 $0$，那么该玩家直接输掉游戏。
  
  在进行完 $3$ 次后将手上的一张牌放在自己面前。牌的体力值为 $2$。这张牌在本回合中被认为已攻击过。
- 结束回合，接下来轮到对方的回合。

一回合中，玩家可以进行多次操作，但是技能和打牌的操作次数**之和**不能超过 $O$。除了结束回合，这些操作没有顺序限制，比如你可以先打一张牌，然后使用技能，然后再打一张牌。在结束回合之前，玩家需要进行至少一次任意的操作才能结束回合。

在任何时刻如果有玩家的体力值小于或等于 $0$，那么该玩家输掉游戏。

游戏进行了几个回合后，现在轮到了小 E 的回合开始前。小 E 想让你帮他分析，如果双方都采用最优策略，那么现在自己赢的概率是多少。

## 说明/提示

**【样例解释 #1】**

回合开始，小 E 抽一张牌。此时小 E 手上有 $2$ 张牌，老师手上没有牌，双方的面前都没有牌。双方的体力值均为 $1$。这时，最优策略下，小 E 不能使用技能，因为使用后会因为自己的体力值小于等于 $0$ 而输掉游戏；小 E 不能攻击，因为自己面前没有牌；小 E 也不能结束回合，因为本回合他还没有进行任何操作。所以小 E 的最优策略是打一张牌，这时会随机选到小 E 或者老师中的一个角色，让他体力值 $- 1$ 然后输掉游戏。所以小 E 的获胜概率为 $0.5$。

**【子任务】**

保证 $1\le T\le 351493,3\le O \le 5$ 。

**【后记】**

最后小 E 还是战胜了老师。

**“老师你术士玩多了就知道怎么玩了，你打得还不够多。”**

**“吹牛现在都流行这么吹的吗？兄弟你知道我术士多少胜场嘛，啊？我跟你说全世界没有一个人术士比我胜场多的。”**

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
1 5
1 1
0
0
0 1
```

### 输出

```
0.500000000
```

## 样例 #2

### 输入

```
1 4
5 14
1 1
1 1
1 0
```

### 输出

```
0.041879441
```

# 题解

## 作者：dead_X (赞：6)

## 前言
THUPC 将近，写写大模拟。
## 题解
假设现在是 A 的回合，考虑有用的状态只有这些：

- A 有 $n$ 点血，B 有 $m$ 点血。
- A 有 $n$ 张手牌，B 有 $m$ 张手牌。
- A 有 $t_1$ 张没攻击过的，有 $1$ 点血的桌面牌。
- A 有 $n_1$ 张攻击过的，有 $1$ 点血的桌面牌。
- A 有 $t_2$ 张没攻击过的，有 $2$ 点血的桌面牌。
- A 有 $n_2$ 张攻击过的，有 $2$ 点血的桌面牌。
- B 有 $m_1$ 张有 $1$ 点血的桌面牌。
- B 有 $m_2$ 张有 $2$ 点血的桌面牌。
- A 还能进行抽牌和打牌共 $o$ 次。
- A 本回合是否已经进行过至少一次操作。

考虑状态数总和只有 $20^4\times 15^3\times 5\times 6\times 2$，可以接受，于是直接进行记忆化搜索，结果 TLE 了（悲）

事实上在进行出牌操作时，我们需要枚举三步随机攻击的情况，将最后一步（如果你的实现足够精细，可以是最后两步）的结果也加入记忆化，时间常数显著降低，可以通过。
## 代码
变量名和上面是一样的，我觉得比另一篇可读。

```cpp
// Problem: P7144 [THUPC2021 初赛] 狗蛋和二五仔
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7144
// Memory Limit: 1 MB
// Time Limit: 20000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//不回家了，我们去鸟巢！
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int T=read(),o=read();
#define double float
double ans[20][20][4][4][15][15][15][6][2];
double tmp[20][20][4][4][15][15][15][6][1];
bool vis[20][20][4][4][15][15][15][6][2];
bool v1[20][20][4][4][15][15][15][6][1];
#define F(x,y) ((x*(11-x))>>1)+y
double dfs(int n,int m,int x,int y,int t1,int n1,
int t2,int n2,int m1,int m2,int d,int flg);
double att(int n,int m,int x,int y,int t1,int n1,
int t2,int n2,int m1,int m2,int d,int tm)
{
	if(n<=0) return 0;
	if(m<=0) return 1;
	if(tm==0) return dfs(n,m,x-1,y,t1,n1,t2,n2+1,m1,m2,d,1);
	if(tm==1&&v1[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][tm-1])
	return tmp[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][tm-1];
	int tot=2+t1+n1+t2+n2+m1+m2;
	double res=0;
	res+=att(n-1,m,x,y,t1,n1,t2,n2,m1,m2,d,tm-1);
	res+=att(n,m-1,x,y,t1,n1,t2,n2,m1,m2,d,tm-1);
	if(t1) res+=t1*att(n,m,x,y,t1-1,n1,t2,n2,m1,m2,d,tm-1);
	if(n1) res+=n1*att(n,m,x,y,t1,n1-1,t2,n2,m1,m2,d,tm-1);
	if(t2) res+=t2*att(n,m,x,y,t1+1,n1,t2-1,n2,m1,m2,d,tm-1);
	if(n2) res+=n2*att(n,m,x,y,t1,n1+1,t2,n2-1,m1,m2,d,tm-1);
	if(m1) res+=m1*att(n,m,x,y,t1,n1,t2,n2,m1-1,m2,d,tm-1);
	if(m2) res+=m2*att(n,m,x,y,t1,n1,t2,n2,m1+1,m2-1,d,tm-1);
	if(tm>=2) return res/tot;
	v1[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][tm-1]=1;
	return tmp[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][tm-1]=res/tot;
}
double dfs(int n,int m,int x,int y,int t1,int n1,
int t2,int n2,int m1,int m2,int d,int flg=0)
{
	if(n<=0) return 0;
	if(m<=0) return 1;
	if(vis[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][flg])
		return ans[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][flg];
	double &res=ans[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][flg];
	if(n>2&&x<3&&d)
		res=max(res,dfs(n-2,m,x+1,y,t1,n1,t2,n2,m1,m2,d-1,1));
	if(t1&&m1)
		res=max(res,dfs(n,m,x,y,t1-1,n1,t2,n2,m1-1,m2,d,1));
	if(t1&&m2)
		res=max(res,dfs(n,m,x,y,t1-1,n1,t2,n2,m1,m2-1,d,1));
	if(t1)
		res=max(res,dfs(n,m-3,x,y,t1-1,n1+1,t2,n2,m1,m2,d,1));
	if(t2&&m1)
		res=max(res,dfs(n,m,x,y,t1,n1,t2-1,n2,m1-1,m2,d,1));
	if(t2&&m2)
		res=max(res,dfs(n,m,x,y,t1,n1,t2-1,n2,m1,m2-1,d,1));
	if(t2)
		res=max(res,dfs(n,m-3,x,y,t1,n1,t2-1,n2+1,m1,m2,d,1));
	if(x&&t1+n1+t2+n2<4&&d)
		res=max(res,att(n,m,x,y,t1,n1,t2,n2,m1,m2,d-1,3));
	if(flg)
		res=max(res,1-dfs(m,n,min(y+1,3),x,m1,0,m2,0,t1+n1,t2+n2,o));
	vis[n-1][m-1][x][y][F(t1,n1)][F(t2,n2)][F(m1,m2)][d][flg]=1;
	return res;
}
signed main()
{
	while(T--)
	{
		int n=read(),m=read();
		int a[2]={0,0},b[2]={0,0};
		for(int s=read(); s--; ++b[read()-1]);
		for(int s=read(); s--; ++a[read()-1]);
		int y=read(),x=read();
		printf("%.9lf\n",dfs(n,m,min(x+1,3),y,a[0],0,a[1],0,b[0],b[1],o));
	}
	return 0;
}
```

---

## 作者：anke2017 (赞：1)

### 闲话

又卡上最优解了。嘻嘻。

## 正题

首先，我们发现这个游戏的状态数很少。（血量等值的范围都不大），考虑**记忆化搜索**。

经过整理，当前局面有如下变量：

* 双方血量（$20\times20$ 种）
* 双方牌数（$4\times4$ 种）
* 我方已（未）攻击的，二血或一血牌数量（由于有最多四张牌的限制，只有 $15\times15$ 种）
* 对方二血或一血牌数量（$15$ 种）
* 我方的攻击和出牌次数（$6$ 种）
* 我方是否可以结束回合（我方本回合是否已执行操作）（两种）

全部乘起来后，我们发现状态数只有 $2.59\times10^8$ 种，在时限内可以跑完。再加上第三条中，实际没有那么多的方案数，正常是没事的。

---

不过，大佬说他出事了！他说死因是时间爆了。

于是，我们把放牌的两步后结果也加入记忆化。常数大幅减小，可通过。

但，这就是极限了吗？

我们知道，如果有 $\le6$ 个参数，就可以用寄存器保存它们，超过六个就不行。

我们的函数原来有太多参数了，需要压缩一下：

- 把双方手牌情况合并为一个参数（高 $2$ 位为对方手牌，低 $2$ 位为自己手牌，以方便操作）
- 把刚才的出牌状态和操作状态合并为一个参数。

我们发现，还有很多个参数，而且压缩其他参数都会有一些（数组的）内存浪费。  
那么就把我方牌和对方牌压缩吧。

再加上剪枝：所有牌均攻击过了才能结束回合，我们的代码遥遥领先，成功拿下最优解。

代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

#define double float//节省空间，本题精度要求不高
#define int unsigned int//听说能卡常？

#define cerr clog
//#define debug

#ifdef ONLINE_JUDGE
#undef debug
#endif
inline char nc()
{
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char a;
    a=nc();
    int flag=0;
    while(!isdigit(a)){if(a=='-')flag=1;a=nc();}
    int n=0;
    while(isdigit(a))
    {
    	n=(n<<1)+(n<<3);
        n+=(int)(a^48);
        a=nc();
    }
    if(flag==0)return n;
    else return -n;
}
inline int read1()//读入一个小于等于 10 的正数
{
    char a=nc();
    while(!isdigit(a))a=nc();
    return a^48;
}

float ans[20][20][16][225][15][12];
bool have_ans[20][20][16][225][15][12];
float now[20][20][16][225][15][6];
bool have_now[20][20][16][225][15][6];

//ans:n,m,crd1 and crd2(num_rar),seta(crd_rar),setb,state
//now:n,m,crd1 and crd2(num_rar),seta,setb,state
//一些对状态操作的辅助函数
__inline int num_rar(int a,int b){return (a<<2)+b;}
__inline int crd2_rar(int a,int b){return (a<<4)+b;}
__inline int get_hash(int a,int b){return (a*(11-a)>>1)+b;}
__inline int state_rar(int x,int can_jmp){return (x<<1)+can_jmp;}
__inline int get_anum(int x){static constexpr int the_table[]={0,0,0,0,0,1,1,1,1,2,2,2,3,3,4};return the_table[x];}
__inline int get_bnum(int x){static constexpr int the_table[]={0,1,2,3,4,0,1,2,3,0,1,2,0,1,0};return the_table[x];}
__inline int get_sum(int x){static constexpr int the_table[]={0,1,2,3,4,1,2,3,4,2,3,4,3,4,4};return the_table[x];}
__inline int get_down(int x){return x+get_anum(x)-5;}
__inline int get_down2(int x){return x+get_anum(x)-6;}
__inline int get_up2(int x){return x+5-get_anum(x);}

float get_ans(int n,int m,int crd_rar,int seta,int setb,int state);

//crdrar:others,mine
//seta:notused_2,notused_1,used_2,used_1
//setb:_2,_1

int o;
//这个函数的最后一个参数，高位是已操作次数（有限制的操作的次数），低 2 位是剩余次数
float get_now(int n,int m,int crd_rar,int seta,int setb,int state)
{
	if(n>20)return 0;if(m>20)return 1;//因为是 unsigned 数，这个是在判断溢出，也就是血量是否为负
	if(!(state&3))return get_ans(n,m,crd_rar,crd2_rar((seta>>4),get_hash(get_anum(seta&0xf)+1,get_bnum(seta&0xf))),setb,(state>>1)+3);
	if((state&3)==1)if(have_now[n][m][crd_rar][seta][setb][state>>2])return now[n][m][crd_rar][seta][setb][state>>2];
	int tot=2+get_sum(seta>>4)+get_sum(seta&0xf)+get_sum(setb);
	float tmp=0;
	tmp+=get_now(n-1,m,crd_rar,seta,setb,state-1);
	tmp+=get_now(n,m-1,crd_rar,seta,setb,state-1);
	if(get_anum(seta>>4))tmp+=get_anum(seta>>4)*get_now(n,m,crd_rar,crd2_rar(get_down(seta>>4),seta&0xf),setb,state-1);
	if(get_bnum(seta>>4))tmp+=get_bnum(seta>>4)*get_now(n,m,crd_rar,seta-16,setb,state-1);
	if(get_anum(seta&0xf))tmp+=get_anum(seta&0xf)*get_now(n,m,crd_rar,crd2_rar(seta>>4,get_down(seta&0xf)),setb,state-1);
	if(get_bnum(seta&0xf))tmp+=get_bnum(seta&0xf)*get_now(n,m,crd_rar,seta-1,setb,state-1);
	if(get_anum(setb))tmp+=get_anum(setb)*get_now(n,m,crd_rar,seta,get_down(setb),state-1);
	if(get_bnum(setb))tmp+=get_bnum(setb)*get_now(n,m,crd_rar,seta,setb-1,state-1);
	tmp/=tot;
	#ifdef debug
	cerr<<n<<' '<<m<<' '<<crd_rar<<' '<<seta<<' '<<setb<<' '<<state<<' '<<tmp<<" now\n";
	#endif
	if((state&3)!=1)return tmp;
	have_now[n][m][crd_rar][seta][setb][state>>2]=1,now[n][m][crd_rar][seta][setb][state>>2]=tmp;
	return tmp;
}
//这个函数则是高位为操作次数，最低位为是否已操作过
float get_ans(int n,int m,int crd_rar,int seta,int setb,int state)
{
	if(n>20)return 0;if(m>20)return 1;
	if(have_ans[n][m][crd_rar][seta][setb][state])return ans[n][m][crd_rar][seta][setb][state];
	float &res=ans[n][m][crd_rar][seta][setb][state];
	//end
	if((state&1)&&seta<16)res=max(res,1-get_ans(m,n,min((crd_rar>>2)+1,3u)+((crd_rar&3)<<2),crd2_rar(setb,0),get_hash(get_anum(seta>>4)+get_anum(seta&0xf),get_bnum(seta>>4)+get_bnum(seta&0xf)),0));
	//skill
	if(n>=2&&((crd_rar&3)!=3)&&(state>>1)!=o)res=max(res,get_ans(n-2,m,crd_rar+1,seta,setb,(state|1)+2));
	//use
	if(get_sum(seta>>4)+get_sum(seta&0xf)<4&&(crd_rar&3)&&(state>>1)!=o)res=max(res,get_now(n,m,crd_rar-1,seta,setb,((state>>1)<<2)+3));
	//attack
	if(get_anum(seta>>4))
	{
		if(get_anum(setb))res=max(res,get_ans(n,m,crd_rar,crd2_rar(get_down2(seta>>4),seta&0xf),get_down2(setb),state|1));
        if(get_bnum(setb))res=max(res,get_ans(n,m,crd_rar,crd2_rar(get_down2(seta>>4),seta&0xf),setb-1,state|1));
		res=max(res,get_ans(n,m-3,crd_rar,crd2_rar(get_down2(seta>>4),get_up2(seta&0xf)),setb,state|1));
	}
	if(get_bnum(seta>>4))
	{
		if(get_anum(setb))res=max(res,get_ans(n,m,crd_rar,crd2_rar((seta>>4)-1,seta&0xf),get_down2(setb),state|1));
        if(get_bnum(setb))res=max(res,get_ans(n,m,crd_rar,crd2_rar((seta>>4)-1,seta&0xf),setb-1,state|1));
		res=max(res,get_ans(n,m-3,crd_rar,crd2_rar((seta>>4)-1,(seta&0xf)+1),setb,state|1));
	}
	have_ans[n][m][crd_rar][seta][setb][state]=1;
	#ifdef debug
	cerr<<n<<' '<<m<<' '<<crd_rar<<' '<<seta<<' '<<setb<<' '<<state<<' '<<res<<" ans\n";
	#endif
	return res;
}

int tmpa[2],tmpb[2];

signed main()
{
	#ifdef debug
	freopen("debug.txt","w",stderr);
	#endif
	int t;t=read(),o=read1();
	int n,m;int c;int p,q;
	while(t--)
	{
		tmpa[0]=(tmpa[1]=(tmpb[0]=(tmpb[1]=0)));
		n=read(),m=read();
		c=read1();while(c--){tmpb[read1()-1]++;}
		c=read1();while(c--){tmpa[read1()-1]++;}
		p=read1(),q=read1();
		printf("%.9f\n",get_ans(n-1,m-1,num_rar(p,min(3u,q+1)),crd2_rar(get_hash(*(tmpa+1),*(tmpa)),0),get_hash(*(tmpb+1),*tmpb),0));
	}
	return 0;
}
```
有趣的是，快读似乎优化并不明显。谁知道怎么回事吗？

---


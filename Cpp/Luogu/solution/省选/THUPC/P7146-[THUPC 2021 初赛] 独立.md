# [THUPC 2021 初赛] 独立

## 题目背景

feecle6418 备注：可以认为本题的数据是随机生成的。

## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向图。

对于 $\{1, 2, \ldots , n\}$ 的某个子集 $A$，$A$ 的分数为：

1. 初始分数为 $0$；
2. 对于所有 $i \in A$，分数加 $a_i$；
3. 对于所有边 $(u, v, k)$（代表从 $u$ 到 $v$ 值为 $k$ 的边）满足 $u \in A$ 并且 $v \in A$，分数减 $k$；

现在请你计算出所有的 $A$ 中，分数最高是多少。

## 说明/提示

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
10 5 1 2 3 4
```

### 输出

```
3909327860
```

# 题解

## 作者：Soulist (赞：4)

瞎几把写的乱搞。

首先拿那个 maker 玩一玩，可以发现环数一般都很小，随了蛮久好像最大就 7 的样子。

所以可以把涉及到的 14 个点拿出来，枚举选/不选，树形背包。

然后这样是 $\mathcal O(4^{cnt}\cdot n)$ 的，过不去。

然后可以发现一般是不连通的，有效的连通块大小大概是几千的样子（具体多少我不记得了）然后只对这些连通块 dp，印象中可以跑到比较后的点了，但还是过不去。

然后可以发现每条环边都是返祖边的，那么有效枚举量只有 $3^{cnt}$ 的，先枚举每条返祖边贡献/不贡献，对于不贡献的情况只需要枚举儿子的选择情况。

复杂度就是 $\mathcal O(3^{cnt}\cdot \textrm{size})$ 了。$\rm size$ 是涉及到的树的大小，$cnt$ 是环数。

代码很丑，修修补补过的。

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define mp make_pair
#define pi pair<int, int>
#define pb push_back
#define vi vector<int>
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int inf = 1e14 + 7 ; 
const int P = 1e9 + 7 ; 
const int N = 2e5 + 5 ; 
const int M = 30 ; 
int n, m, cnt, A[N], Ans, dp[N][2], zk[N], zt[N], g[N], rt[N] ; 
int head[N], fa[N], st[M], top, c[M], zmy, f[N] ;
int ban[N] ; 
struct E {
	int to, next, w ; 
} e[N] ; 
map<pi, int> S ;
struct node {
	int x, y, z ; 
};
node ST[15] ; int num ; 
int fd(int x) {
	return (fa[x] == x) ? fa[x] : fa[x] = fd(fa[x]) ; 
}
void add(int x, int y, int z) {
	e[++ cnt] = (E){ y, head[x], z }, head[x] = cnt,
	e[++ cnt] = (E){ x, head[y], z }, head[y] = cnt ; 
}
void merge(int x, int y, int zz) {	
	int u = fd(x), v = fd(y) ;
	fa[u] = v, add(x, y, zz) ; 
} 
int dfn[N], color ; 
void dfs(int x, int ff) {
	zk[x] = 1 ; 
	Next( i, x ) {
		int v = e[i].to ; if(v == ff) continue ; 
		if(ban[i]) continue ; 
		dfs(v, x) ; 
		dp[x][0] += max(dp[v][1], dp[v][0]) ;
		dp[x][1] += max(dp[v][1] - e[i].w, dp[v][0]) ; 
	}
}
void Dfs(int x, int ff) {
	dfn[x] = ++ color ;
	if(x == ff) rt[x] = 1 ;  
	Next( i, x ) {
		int v = e[i].to ; if(v == ff) continue ; 
		if( !dfn[v] ) Dfs( v, x ), g[x] |= g[v] ;
		else if(dfn[v] < dfn[x]) 
		ST[++ num] = (node){v, x, e[i].w}, ban[i] = 1, ban[i ^ 1] = 1, g[x] = 1 ; 
	}
}
int h[N], qls, cc[100], ttop ; 
int root[N], fgo ; 
signed main()
{
	int xx, yy, zz ; cnt = 1 ; 
	n = gi(), m = gi(), xx = gi(), yy = gi(), A[0] = gi(), zz = gi() ; 
	rep( i, 1, n ) A[i] = (A[i - 1] * 101 + 137) % P ; 
	rep( i, 1, n ) fa[i] = i ; 
	rep( i, 1, m ) {
		xx = (xx * 101 + 137) % P, yy = (yy * 101 + 137) % P,
		zz = (zz * 101 + 137) % P ; 
		int x = xx % n + 1, y = yy % n + 1 ; 
		if(!S[mp(x, y)] && (x != y)) 
			S[mp(x, y)] = S[mp(y, x)] = 1, merge(x, y, zz) ; 
	}
	rep( i, 1, n ) if(!dfn[i]) Dfs(i, i) ; 
	for(re int i = 1; i <= num; ++ i)
	st[++ top] = ST[i].x, st[++ top] = ST[i].y ; 
	sort(st + 1, st + top + 1) ; 
	rep( i, 1, top ) if(st[i] != st[i - 1]) c[++ zmy] = st[i] ; 
	int limit = (1 << zmy) - 1 ; 
	rep( i, 1, zmy ) f[c[i]] = 1 ; 
	int SA = 0 ; 
	rep( i, 1, n ) dp[i][0] = 0, dp[i][1] = A[i] ;
	rep( i, 1, n ) if(rt[i] && (!g[i])) dfs(i, i), SA += max(dp[i][0], dp[i][1]) ; 
	rep( i, 1, n ) if(!zk[i]) h[++ qls] = i ; 
	rep( i, 1, n ) if(!zk[i] && rt[i]) root[++ fgo] = i ; 
	limit = (1 << num) - 1 ; 
	for(re int AC = 0; AC <= limit; ++ AC) {
		int fSA = SA ; 
		rep( j, 1, zmy ) zt[c[j]] = 0 ;
		for(re int j = 1; j <= num; ++ j) {
			if(AC & (1 << (j - 1))) 
			fSA -= ST[j].z, zt[ST[j].x] = 1, zt[ST[j].y] = 1 ; 
		}
		int lim = (AC ^ limit) ; 
		for(re int T = lim; ; T = (T - 1) & lim) {
			rep( i, 1, qls ) zk[h[i]] = 0, dp[h[i]][1] = A[h[i]], dp[h[i]][0] = 0 ; 
			rep( j, 1, zmy ) if(zt[h[j]]) dp[h[j]][0] = -inf ; 
			rep( j, 1, num ) {
				if(!((1 << (j - 1)) & lim)) continue ; 
				if((1 << (j - 1)) & T) 
				dp[ST[j].x][0] = -inf, dp[ST[j].y][1] = -inf ; 
				else 
				dp[ST[j].x][1] = -inf ; 
			}
			int ans = fSA ; 
			rep( i, 1, fgo ) dfs(root[i], root[i]), ans += max( dp[root[i]][0], dp[root[i]][1] ) ; 
			Ans = max(Ans, ans) ; 
			if(!T) break ; 
		}
	}
	cout << Ans << endl ; 
	return 0 ;
}
```

---

## 作者：天梦 (赞：0)

## P7146

首先关注边很少，而且数据随机，这提示我们这道题可以乱搞，经过随机可以知道环的个数不会很多，我们把所有的环找出来，删掉一个点，这样整张图变成森林，然后在森林上进行 dp，对于这些删除的点，直接暴力枚举选不选即可。

注意，删点的时候注意删掉了一个点，就更新一下整张图，否则可能会重复删一个环上的点，具体来说，不这样做，一条非树边的两边节点都会被删掉一次，所以删的点数就翻倍了。

代码：

```

#include<bits/stdc++.h>
#define mset(a,b) memset((a),(b),sizeof((a)))
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define dec(i,l,r) for(int i=(r);i>=(l);i--)
#define inc(a,b) (((a)+(b))>=mod?(a)+(b)-mod:(a)+(b))
#define sub(a,b) (((a)-(b))<0?(a)-(b)+mod:(a)-(b))
#define mul(a,b) 1ll*(a)*(b)%mod
#define sgn(a) (((a)&1)?(mod-1):1)
#define cmax(a,b) (((a)<(b))?(a=b):(a))
#define cmin(a,b) (((a)>(b))?(a=b):(a))
#define Next(k) for(int x=head[k];x;x=li[x].next)
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define N 100010
#define M number
using namespace std;

typedef double dd;
typedef long double ld;
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
#define int long long
typedef pair<int,int> P;
typedef vector<int> vi;

const int INF=0x3f3f3f3f;
const dd eps=1e-9;

template<typename T> inline void read(T &x) {
    x=0; int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    x*=f;
}

int n,m,x,y,z,a[N],q=101,b=137,p=1e9+7;
struct edge{
    int to,next,w;
    inline void Init(int to_,int ne_,int w_){
        to=to_;next=ne_;w=w_;
    }
}li[N<<1];
int head[N],tail=1,sp[N],st,cho[N],ans,nowans;
int ft;
map<P,bool> Map;
bool vis[N],ban[N];

inline void Add(int from,int to,int w){
    // printf("from=%d to=%d w=%d\n",from,to,w);
    li[++tail].Init(to,head[from],w);head[from]=tail;
}
inline void PreWork(){
    read(n);read(m);read(x);read(y);read(a[0]);read(z);
    rep(i,1,n) a[i]=(1ll*q*a[i-1]%p+b)%p;
    // rep(i,1,n) printf("%d ",a[i]);puts("");
    rep(i,1,m){
        x=(1ll*q*x%p+b)%p;y=(1ll*q*y%p+b)%p;z=(1ll*q*z%p+b)%p;
        int nx=x%n+1,ny=y%n+1;
        if(Map[mp(nx,ny)]||nx==ny) continue;Map[mp(nx,ny)]=Map[mp(ny,nx)]=1;
        Add(nx,ny,z);Add(ny,nx,z);
    }
}
inline void dfs(int k,int fa){
    vis[k]=1;
    // for(int x=head[k];x;x=li[x].next){
    //     int to=li[x].to,w=li[x].w;if(to==fa) continue;
    //     if(vis[to]) sp[++st]=to;
    //     else dfs(to,k);
    // }
    Next(k){
        int to=li[x].to,w=li[x].w;if(to==fa||ban[to]) continue;
        if(vis[to]){sp[++st]=k,ban[k]=1;}
    }
    if(ban[k]) return;
    Next(k){
        int to=li[x].to,w=li[x].w;if(to==fa||ban[to]) continue;
        dfs(to,k);
    }
}
namespace s1{
    int f[N][2];
    inline void dp(int k,int fa){
        f[k][1]=a[k];f[k][0]=0;vis[k]=1;
        for(int x=head[k];x;x=li[x].next){
            int to=li[x].to;if(to==fa) continue;
            if(!ban[to]) dp(to,k);
        }
        for(int x=head[k];x;x=li[x].next){
            int to=li[x].to;if(to==fa) continue;
            if(!ban[to]){
                f[k][1]+=max(f[to][0],f[to][1]-li[x].w);
                f[k][0]+=max(f[to][0],f[to][1]);
            }
            else{
                if(cho[to]) f[k][1]-=li[x].w;
            }
        }
    }
    inline void dfs(int k){
        // if(((dd)clock()-(dd)ft)/CLOCKS_PER_SEC>=0.95){
        //     printf("%lld\n",ans);exit(0);
        // }
        if(k==st+1){
            nowans=0;rep(i,1,st) if(cho[sp[i]]) nowans+=a[sp[i]];
            rep(i,1,st) if(cho[sp[i]]){
                for(int x=head[sp[i]];x;x=li[x].next){
                    int to=li[x].to;if(cho[to]&&to>sp[i]) nowans-=li[x].w;
                }
            }
            mset(vis,0);
            // mset(f,0);
            rep(i,1,n) if(!vis[i]&&!ban[i]) dp(i,0),nowans+=max(f[i][0],f[i][1]);
            ans=max(ans,nowans);
            return;
        }
        int now=random()%2;
        cho[sp[k]]=now;dfs(k+1);cho[sp[k]]=now^1;dfs(k+1);
    }
}
inline void Solve(){
    rep(i,1,n) if(!vis[i]) dfs(i,0);
    // printf("st=%d\n",st);
    // st=min(st,10ll);
    // st=unique(sp+1,sp+st+1)-sp-1;
    rep(i,1,st) ban[sp[i]]=1;
    s1::dfs(1);printf("%lld\n",ans);
}

signed main(){
    srand(time(0));
    // assert(freopen("my.in","r",stdin));
    // assert(freopen("my.out","w",stdout));
    ft=clock();
    PreWork();Solve();return 0;
}

```

---


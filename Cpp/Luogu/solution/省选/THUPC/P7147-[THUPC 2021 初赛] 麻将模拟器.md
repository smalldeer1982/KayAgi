# [THUPC 2021 初赛] 麻将模拟器

## 题目描述

麻将是一种休闲的四人博弈游戏。你的任务是写一个模拟器来模拟一局游戏的进程。

接下来将详细介绍游戏规则和每个玩家的决策。注意：为了实现方便和使游戏更加有趣味，这里介绍的规则和主流的几种麻将规则均略有不同。

**基础规则：**

- 一副麻将由 $148$ 张牌组成，其中包含 $37$ 种不同的牌，每种各 $4$ 张。
- 这 $37$ 种牌分别是：一万到九万（`1M ~ 9M`）、一筒到九筒（`1P ~ 9P`）、一索到九索（`1S ~ 9S`）、东（`E`）、南（`S`）、西（`W`）、北（`N`）、白（`B`）、发（`F`）、中（`Z`），以及 $3$ 种特殊牌：跳过（`PASS`），反向（`REVERSE`），双重回合（`DOUBLE`）。
- 游戏共有 $4$ 名玩家，不妨称其为 `A`，`B`，`C`，`D`。
- 游戏开始前，将 $148$ 张牌随机洗乱后摆成一排，称为牌堆。此后玩家摸牌一定是从牌堆中摸取最靠前的一张牌。
- 从 `A` 开始按照 `ABCDABCD...` 的顺序，每人依次从牌堆中摸一张牌，直到每人都有 $13$ 张牌，这些牌组成每个玩家的手牌。
- 再从 `A` 开始按照 `ABCDABCD...` 的顺序，依次进入每人的回合：
- 在一个回合中，玩家先摸一张牌进入自己的手牌，再从自己的手牌中打出一张牌。
- 依次进行直到有人和牌或者无牌可摸时游戏结束。

**特殊牌：**

- 跳过（`PASS`）：在出牌时打出这张牌，可以指定一名玩家，跳过他的下一个回合。
- 反向（`REVERSE`）：在出牌时打出这张牌，反转进行回合的顺序，即由 `ABCDABCD...` 变为 `ADCBADCB...` 或由 `ADCBADCB...` 变为 `ABCDABCD...`。出牌后即按照反转后的顺序，从出牌者原先的上家开始进行回合。
- 双重回合（`DOUBLE`）：在出牌时打出这张牌，该名玩家立即进入一个额外的回合。

**牌型：**&#8203;有如下 $3$ 种牌型：

- 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的筒，或 $3$ 张数字连续的索，如 `4P 5P 6P`。
- 刻子：$3$ 张完全一样的非特殊牌，如 `B B B`。
- 对子：$2$ 张完全一样的非特殊牌，如 `9M 9M`。

**吃、碰：**

- 当一名玩家打出一张非特殊牌时，其他玩家可以进行吃或碰：
- 吃（`CHOW`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个顺子时，可以将手牌中能与之组成顺子的其余两张牌取出，与这张牌一起摆在旁边。
- **注意只有上一名出牌玩家的下家（按当前顺序原本应在下一个进行回合的玩家）才能吃。**
- 碰（`PONG`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个刻子时，可以将手牌中能与之组成刻子的其余两张牌取出，与这张牌一起摆在旁边。
- 碰没有吃的上述限制，任意其他玩家都能碰。
- 如果既有玩家能吃又有玩家能碰，则碰优先于吃。
- 吃（或碰）不是强制性的，也就是说玩家满足吃（或碰）的条件时，可以选择不吃（或碰）。
- 吃和碰统称为副露。为方便起见，不将副露视为手牌的一部分。
- 在任意一名玩家吃（或碰）后，跳过从上一名出牌的玩家到这名玩家之间的所有玩家的回合，直接从当前玩家开始进行新的回合。但该玩家在这一回合中**跳过摸牌直接出牌**，在下一回合（如果没有吃碰的话）恢复正常。
- **注意在本规则中不能杠。**

**胡牌规则：**

- 称一名玩家的牌能和，当且仅当满足如下条件：
  - 牌数为 $14 - 3 n$，其中 $n$ 为该玩家副露（即吃碰）的个数；
  - 这些牌中无特殊牌；
  -  这些牌能够被分成 $(5 - n)$ 组，其中 $(4 - n)$ 组均为 $3$ 张且均为顺子或刻子，其余一组为 $2$ 张且为对子。
- **注意本规则中不支持七对子、十三幺、全不靠等特殊的和牌规则。**
- 另外，定义一组包含 $13 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x - 1$ 张手牌后，每种牌仍不超过 $4$ 张且能和。
- 定义一组包含 $14 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x$ 张手牌后，每种牌仍不超过 $4$ 张且能和。
- 特别地，一手能和的牌的和牌距离为 $0$；和牌距离为 $1$ 的牌称为听牌。
- 注意这里的“**每种牌仍不超过** $\boldsymbol{4}$ **张**”的限制：如果一手牌是 `1M 1M 1M 1M` 且副露数为 $3$，再向其中加入一张 `1M` 就能和，但是由于有 $5$ 张 `1M` 所以是不被允许的，故不认为其和牌距离为 $1$。
- 但如果一手牌是 `1M` 且副露数为 $4$，但是曾进行过一次 `1M 1M 1M` 的碰，仍然认为其和牌距离为 $1$（虽然缺的这张 `1M` 永远也等不到）。

**终局：**

- 荣和（`RON`）：当一名玩家出牌后，某名其他玩家的手牌加上这张牌能和，则称这名玩家荣和。荣和优先于吃碰。
- 如果有多名玩家同时达到荣和的标准，规定只有从上一名出牌玩家开始，沿回合进行顺序的第一名能荣和的玩家才能荣和，其余玩家荣和不了，称这种情况为截和。
- 自摸（`SELFDRAWN`）：一名玩家摸牌后其手牌能和，称这名玩家自摸。
- 一旦有一名玩家荣和或自摸，游戏立即结束，该名玩家胜利。
- 如果某名玩家摸牌时发现牌堆中已经无牌可摸，游戏立即结束，称此种情况为流局。

**出牌策略：**&#8203;每名玩家的出牌策略相同且固定：

- 出牌时，若手里有特殊牌一定会优先出，且如果有多种特殊牌，按照 `PASS`、`REVERSE`、`DOUBLE` 的优先顺序；出的 `PASS` 一定指定下家。
- 出牌时若手里没有特殊牌，则会对于每一种可能的出牌方法计算出完牌后的和牌距离，选择和牌距离最小的一种方案。如果有并列最小，按照 `Z`，`F`，`B`，`N`，`W`，`S`，`E`，`9S`，`8S`，……，`1S`，`9P`，……，`1P`，`9M`，……，`1M` 的优先顺序出牌。
- 同一个人能吃且能碰时，优先考虑碰；因为每种牌只有 $4$ 张所以不会有两名玩家同时可以碰的情况；当且仅当吃（或碰）后能使得和牌距离严格减小才会去吃（或碰）；如果有多种吃的方案使得和牌距离严格减小，优先选择数字较大的方案。
-  能荣和一定荣和（除非被截和），能自摸一定自摸，不会拒和（能和时故意选择不和）。

## 说明/提示

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
8M
Z
E
9P
3P
9S
5P
W
3M
8P
DOUBLE
5P
Z
2P
3M
8S
2S
5P
5M
E
6M
9S
6P
5S
7M
4S
3S
6M
3S
2M
9M
5S
Z
7P
5P
8M
3M
F
7M
2S
N
4P
3S
S
PASS
1P
6S
3P
9P
9S
4M
8P
N
Z
N
5M
DOUBLE
REVERSE
S
3P
4M
4S
1S
PASS
4P
6S
7S
7P
6S
9M
REVERSE
3P
7P
DOUBLE
B
9P
4S
5S
7S
7S
7P
6S
9S
B
9M
S
F
2P
1P
PASS
9P
DOUBLE
4P
PASS
5S
2M
2P
6P
W
1M
8S
REVERSE
8M
6M
5M
F
4M
F
8P
2S
1M
2M
3M
7M
3S
B
7S
1S
REVERSE
8P
6M
4S
2M
B
1M
S
6P
5M
W
7M
2S
8S
8M
1S
4P
E
4M
9M
1M
8S
1S
1P
2P
1P
W
6P
N
E
```

### 输出

```
A IN 8M
B IN Z
C IN E
D IN 9P
A IN 3P
B IN 9S
C IN 5P
D IN W
A IN 3M
B IN 8P
C IN DOUBLE
D IN 5P
A IN Z
B IN 2P
C IN 3M
D IN 8S
A IN 2S
B IN 5P
C IN 5M
D IN E
A IN 6M
B IN 9S
C IN 6P
D IN 5S
A IN 7M
B IN 4S
C IN 3S
D IN 6M
A IN 3S
B IN 2M
C IN 9M
D IN 5S
A IN Z
B IN 7P
C IN 5P
D IN 8M
A IN 3M
B IN F
C IN 7M
D IN 2S
A IN N
B IN 4P
C IN 3S
D IN S
A IN PASS
B IN 1P
C IN 6S
D IN 3P
A IN 9P
B IN 9S
C IN 4M
D IN 8P
A IN N
A OUT PASS B
C IN Z
C OUT DOUBLE
C IN N
C OUT Z
A PONG Z Z Z
A OUT 9P
B CHOW 7P 8P 9P
B OUT Z
C IN 5M
C OUT N
A PONG N N N
A OUT 3P
B CHOW 3P 4P 5P
B OUT F
C IN DOUBLE
C OUT DOUBLE
C IN REVERSE
C OUT REVERSE
B IN S
B OUT S
A IN 3P
A OUT 3P
D IN 4M
D OUT W
C IN 4S
C OUT E
B IN 1S
B OUT 4S
A RON
A WIN
```

# 题解

## 作者：FjswYuzu (赞：43)

历时三天，写代码时间四个半小时。重构一次，代码总长度约 30k，AC 代码 8.53kb。

另外吐槽一下这道题的出题人是不是不太会打麻将（ 明明有更好理解的向听定义然而搞了个和牌距离弄了我半天。

---

首先开一个 `class` 类是传统艺能。因为构造函数不知道干什么就占了个位，析构函数比较好说，我们可以存下几个信息，即 `isWon` 是否有人和牌，`wonWay` 表示和牌方式。另外存下一个值 `ope`，这个东西可以多用，既可以表示当前是谁**出牌**（不是摸牌的原因是因为鸣牌会跳过摸牌），也可以表示在结束之时谁赢了。

根据这个写一下函数。用析构函数的原因是当过程结束这个函数会自动执行。

```cpp
	bool isWon=false;
	int wonWay=0;
	char gameEnding[3][10]={"","RON","SELFDRAWN"};
	MahjongGame(){}
	~MahjongGame()
	{
		if(!isWon)	puts("DRAW");
		else	printf("%s %s\n%s WIN\n",playerName[ope],gameEnding[wonWay],playerName[ope]);
	}
```

捋一遍过程。首先我们需要将牌山读下来。我们需要写一个函数完成牌的名称与编号的转化。至于不需要写编号转化成牌的函数，因为我们可以很简单的用字符串数组完成这个过程。

```cpp
	char brickName[40][10]=
	{
		"",
		"1M","2M","3M","4M","5M","6M","7M","8M","9M",
		"1P","2P","3P","4P","5P","6P","7P","8P","9P",
		"1S","2S","3S","4S","5S","6S","7S","8S","9S",
		"E","S","W","N","B","F","Z",
		"DOUBLE","REVERSE","PASS"
	};
	int nameTrans(char *s)
	{
		int len=int(strlen(s));
		if(len==1)
		{
			switch (s[0])
			{
				case 'E':	return 28;
				case 'S':	return 29;
				case 'W':	return 30;
				case 'N':	return 31;
				case 'B':	return 32;
				case 'F':	return 33;
				case 'Z':	return 34;
			}
		}
		else if(len==2)
		{
			int p=s[0]-'0';
			switch (s[1])
			{
				case 'M':	return p;
				case 'P':	return p+9;
				case 'S':	return p+18;
			}
		}
		else
		{
			switch(s[0])
			{
				case 'D':	return 35;
				case 'R':	return 36;
				case 'P':	return 37;
			}
		}
		return -1;
	}
```

考虑与牌有关的，需要保存下来的信息。无疑我们需要保存每个玩家的牌是什么，有多少张牌，每个玩家所拥有的每种牌的数量以及牌山。写一个读牌山的函数：

```cpp
	void Initialization()
	{
		for(int i=1;i<=148;++i)
		{
			char s[10];
			scanf("%s",s);
			brickHill[i]=nameTrans(s);
		}
	}
```

然后我们需要发牌。在这里比较好处理的方法是一开始就只给每个人发 $13$ 张牌。对于玩家 `A` 发 $14$ 张可以看成发了 $13$ 张牌并且摸牌进行出牌操作。

同时我们需要写几个基本函数去辅助。比如调整当前某个玩家的牌（按顺序，实现就是一个 `sort`）；得到牌以及扔掉牌，输出得到牌以及扔掉牌的信息（注意要包含 `PASS` 的特殊用法）；下一个玩家是谁，上一个玩家是谁；调整可能出现错误的当前操作用户信息（比如 $5 \to 1,0 \to 4$）。定义两个变量 `ope` 与 `rev`（`ope` 意义如上，`rev` 表示当前的顺序是什么：$1$ 代表正序，$-1$ 代表反序。两个变量初始值皆为 $1$）

```cpp
	void adjustBricks(int who){sort(brick[who]+1,brick[who]+1+brickCnt[who]);}
	void getBrick(int who,int wch)
	{
		++brickApp[who][wch];
		++brickCnt[who];
		brick[who][brickCnt[who]]=wch;
		adjustBricks(who);
	}
	void outBrick(int who,int wch)
	{
		--brickApp[who][wch];
		for(int i=1;i<=brickCnt[who];++i)
		{
			if(brick[who][i]==wch)
			{
				for(int j=i+1;j<=brickCnt[who];++j)	brick[who][j-1]=brick[who][j];
				brick[who][brickCnt[who]]=0;
				--brickCnt[who];
				return ;
			}
		}
	}
	int fixOpe(int wch)
	{
		if(wch==5)	wch=1;
		if(wch==0)	wch=4;
		return wch;
	} 
	void outputGetBrick(int who,int wch){printf("%s IN %s\n",playerName[who],brickName[wch]);}
	void outputOutBrick(int who,int wch)
	{
		printf("%s OUT %s",playerName[who],brickName[wch]);
		if(wch==37)	printf(" %s",playerName[fixOpe(who+rev)]);
		puts("");
	}
	void dealBrick()
	{
		for(int i=1;i<=52;++i)
		{
			int who=i%4;
			if(!who)	who=4;
			getBrick(who,brickHill[i]);
			outputGetBrick(who,brickHill[i]);
		}
	}
	int nxtPlayer(int who){return fixOpe(who+rev);}
	int lasPlayer(int who){return fixOpe(who-rev);}
```

其他的东西比较复杂。我们先考虑怎么写我们的主要执行函数 `void execute()`。

首先肯定需要执行一次 `Initialization()` 与 `dealBrick()` 函数。然后枚举当前的牌用到哪里了。用一个 `cnt` 存下来。初始值设成 $53$，因为前面的 $52$ 张牌已经发出去了。

然后执行一次 `getBrick(ope,brickHill[cnt])` 与 `outputGetBrick(ope,brickHill[cnt])`，表示发牌的过程。然后写一个函数 `bool isTsumo(int who)` 表示当前这个人手中的牌是否自摸了（因为涉及到听牌距离一概念暂且不谈，实际上判断是否自摸还有一个贪心做法），那么游戏结束，`isWon` 置为 `true` 并且 `wonWay` 置为 $2$，退出程序。否则需要写一个函数 `void outBricker(int who)`，表示对该玩家进行一次出牌操作。然后将玩家置为下一个玩家，并且将 `cnt` 自增 $1$。根据思路写出代码。

```cpp
	void execute()
	{
		Initialization();
		dealBrick();
		int cnt=53;
		while(cnt<=148)
		{
			getBrick(ope,brickHill[cnt]);
			outputGetBrick(ope,brickHill[cnt]);
			if(isTsumo(ope))
			{
				isWon=true;
				wonWay=2;
				exit(0);
			}
			outBricker(ope);
			ope=nxtPlayer(ope);
			++cnt;
		}
	}
```

这里不把发牌放入 `void outBricker(int)` 函数中的原因是因为可能会出现鸣牌需要递归的情况，为了方便将摸牌操作拿出来，传参的原因也是因为能够方便递归。

然后考虑 `void outBricker(int)` 函数的实现。

根据题目所述，我们需要按 `PASS`、`REVERSE`、`DOUBLE` 的顺序去实现。根据 `int nameTrans(char*)` 内置的编号，分别为 $37,36,35$，以此判断即可。

- 对于 `PASS`，我们将当前执行的玩家置为下一个玩家，在返回到 `execute()` 函数中就会跳过应该被跳过的玩家；   
- 对于 `REVERSE`，我们将 `rev` 取反即可；    
- 对于 `DOUBLE`，我们将当前执行的玩家置为上一个玩家，在返回到 `execute()` 函数中就会变成该玩家。

写一个函数 `int decideThrowBrick(int*)` 表示对于当前牌，在题目的说明下进行选择丢弃哪一张牌。因为这个东西涉及到的东西更复杂在后面再说。

然后就对当前执行的玩家将决定扔出的牌扔掉。考虑荣和的过程，相当于得到一张牌并且判断是否自摸即可。注意顺序判断。

如果有人荣和，游戏立刻结束，将 `ope` 置为荣和的人的编号，`isWon` 置为 `true` 并且 `wonWay` 置为 $1$，退出程序自动执行析构函数。

否则我们需要判断有没有人能够碰。如果能够碰，那我们就将当前的需要出牌的人置为这个人，然后再递归执行 `outBricker` 函数即可。

吃同理。不再赘述。根据思路写下代码。

```cpp
	void outBricker(int who)
	{
		if(brickApp[who][37])
		{
			outBrick(who,37);
			outputOutBrick(who,37);
			ope=nxtPlayer(ope);
			return ;
		}
		if(brickApp[who][36])
		{
			outBrick(who,36);
			outputOutBrick(who,36);
			rev=-rev;
			return ;
		}
		if(brickApp[who][35])
		{
			outBrick(who,35);
			outputOutBrick(who,35);
			ope=lasPlayer(ope);
			return ;
		}
		int outBrk=decideThrowBrick(brick[who]);
		outBrick(who,outBrk);
		outputOutBrick(who,outBrk);
		for(int i=nxtPlayer(ope);i!=ope;i=nxtPlayer(i))
		{
			getBrick(i,outBrk);
			if(isTsumo(i))
			{
				ope=i;
				isWon=true;
				wonWay=1;
				exit(0);
			}
			outBrick(i,outBrk);
		}
		for(int i=nxtPlayer(ope);i!=ope;i=nxtPlayer(i))
		{
			if(allowPong(i,outBrk))
			{
				ope=i;
				Pong(i,outBrk);
				outBricker(i);
				return ;
			}
		}
		int i=nxtPlayer(ope),type=allowChow(i,outBrk);
		if(allowChow(i,outBrk))
		{
			ope=i;
			Chow(i,outBrk,type);
			outBricker(i);
		}
	}
```

于是我们成功的给自己挖了很多坑。按吃和碰又分别讲解。

首先我们要写一个计算和牌距离的函数以及需要扔掉哪张牌的函数，分别定义为 `int calcXt(int*)` 与 `int decideThrowBrick(int*)`。因为这个东西是最最复杂的所以又延后说。

**注意，这里的和牌距离不等同于向听**。如果当前并不是你出牌的回合，和牌距离是向听加一；否则就是向听数。听牌即为 $0$ 向听。害死我这个日麻玩家了（

假设这两个函数能够返回正确的值。我们需要实现判断是否能吃/碰的函数。

先说碰 `bool allowPong(int who,int brk)`。首先如果这个人没有两张牌 `brk`，那么肯定是不可以的。计算一下当前的和牌距离（即调用 `calcXt(brick[who])`），然后扔出去两张再算一下和牌距离。如果扔出去之后的听牌距离严格小于（即，向听数小于等于）之前的和牌距离，这个碰的动作就是允许的；否则禁止。注意将牌放回来。

输出碰这个动作（`void Pong(int who,int wch)`）就比较 naive。直接来就行了。注意在这个函数中要执行副露的过程。

```cpp
	bool allowPong(int who,int brk)
	{
		if(brickApp[who][brk]<2)	return false;
		int nowXt=calcXt(brick[who]);
		outBrick(who,brk);
		outBrick(who,brk);
		int presentXt=calcXt(brick[who]);
		getBrick(who,brk);
		getBrick(who,brk);
		if(presentXt<nowXt)	return true;
		return false;
	}
	void Pong(int who,int wch)
	{
		printf("%s PONG %s %s %s\n",playerName[who],brickName[wch],brickName[wch],brickName[wch]);
		outBrick(who,wch);
		outBrick(who,wch);
	}
```

然后是吃。因为吃有三种可能分别判断一下和牌距离即可。注意不要字牌吃字牌，万吃索这样的情况出现（预防就可以直接看有没有，会不会出去等的判断即可）。然后取最小值判断是否比之前的和牌距离小即可。做法一样。

注意的是方案具有优先级。这个时候返回一个方案即可。与执行吃这个操作的函数一起用就行了。

```cpp
	int allowChow(int who,int wch)
	{
		if(wch>27)	return false;
		int nowXt=calcXt(brick[who]);
		int Xts[4];
		memset(Xts,63,sizeof Xts);
		if(wch!=8 && wch!=9 && wch!=17 && wch!=18 && wch!=26 && wch!=27 && brickApp[who][wch+1] && brickApp[who][wch+2])
		{
			outBrick(who,wch+1);
			outBrick(who,wch+2);
			Xts[3]=calcXt(brick[who]);
			getBrick(who,wch+1);
			getBrick(who,wch+2);
		}
		if(wch!=9 && wch!=1 && wch!=18 && wch!=10 && wch!=27 && wch!=19 && brickApp[who][wch+1] && brickApp[who][wch-1])
		{
			outBrick(who,wch-1);
			outBrick(who,wch+1);
			Xts[2]=calcXt(brick[who]);
			getBrick(who,wch-1);
			getBrick(who,wch+1);
		}
		if(wch!=1 && wch!=2 && wch!=10 && wch!=11 && wch!=19 && wch!=20 && brickApp[who][wch-1] && brickApp[who][wch-2])
		{
			outBrick(who,wch-2);
			outBrick(who,wch-1);
			Xts[1]=calcXt(brick[who]);
			getBrick(who,wch-2);
			getBrick(who,wch-1);
		}
		int minn=min({Xts[1],Xts[2],Xts[3]});
		if(minn>=nowXt)	return 0;
		if(minn==Xts[1] && minn==Xts[2] && minn==Xts[3])	return 3;
		if(minn==Xts[1] && minn==Xts[2] && minn!=Xts[3])	return 2;
		if(minn==Xts[1] && minn!=Xts[2] && minn==Xts[3])	return 3;
		if(minn!=Xts[1] && minn==Xts[2] && minn==Xts[3])	return 3;
		if(minn!=Xts[1] && minn!=Xts[2] && minn==Xts[3])	return 3;
		if(minn!=Xts[1] && minn==Xts[2] && minn!=Xts[3])	return 2;
		if(minn==Xts[1] && minn!=Xts[2] && minn!=Xts[3])	return 1;
		return -1;
	}
	void Chow(int who,int brk,int type)
	{
		if(type==3)
		{
			printf("%s CHOW %s %s %s\n",playerName[who],brickName[brk],brickName[brk+1],brickName[brk+2]);
			outBrick(who,brk+1);
			outBrick(who,brk+2);
			return ;
		}
		if(type==2)
		{
			printf("%s CHOW %s %s %s\n",playerName[who],brickName[brk-1],brickName[brk],brickName[brk+1]);
			outBrick(who,brk-1);
			outBrick(who,brk+1);
			return ;
		}
		if(type==1)
		{
			printf("%s CHOW %s %s %s\n",playerName[who],brickName[brk-2],brickName[brk-1],brickName[brk]);
			outBrick(who,brk-2);
			outBrick(who,brk-1);
			return ;
		}
	}
```

最后我们还有两个函数没有实现，即 `int calcXt(int*)` 与 `int decideThrowBrick(int*)`。暴力判断（一般型最大向听数为 $7$，对应和牌距离应该是 $8$，即需要用 $34^8$ 次去判断向听与扔走哪张牌）肯定是不行的。

于是定义 $dp_{i,j,k=0 \operatorname{or} 1,l,o}$ 表示当前用到了第 $i$ 张牌，已经组了 $j$ 个面子，组了 $k$ 个对子（一定要有对子），现在还存在 $l$ 个单张以及有 $o$ 个搭子快成为顺子，的和牌距离。

转移的过程和大多数麻将题目一样枚举下一张牌使用什么。至于实现出牌可以用另外一个数组保存。

显然我们必须将 $l$ 个搭子补全并新加上一些单张。分情况讨论：

- 补全完 $l$ 个搭子之后剩下三张能够组成一个新刻子并且组完之后面子数还不超过需要的面子数；   
- 补全完 $l$ 个搭子之后剩下两张能够组成一个新雀头（对子）；   
- 加单张。

注意字牌的特殊情况。此时不存在补全顺子一说。

然后暴力枚举就行了。因为这样状态数还是比较多，因为最大和牌距离小于等于 $8$，所以枚举到 $8$ 即可。

于是暴力转移即可。保存该扔掉哪张牌直接放到状态转移即可。

为了方便，我们再开一个函数，`int calcXt(int*)` 与 `int decideThrowBrick(int*)` 就只剩下传参区别了。

```cpp
	#define mp make_pair
	int dpExecuter(int *brk,int type)
	{
		int len=0,mz;
		while(brk[len+1])	++len;
		mz=len/3;
		sort(brk+1,brk+1+len);
		int dp[40][5][2][3][3],brkApp[40],usf[40][5][2][3][3];
		memset(brkApp,0,sizeof brkApp);
		for(int i=1;i<=len;++i)	++brkApp[brk[i]];
		memset(dp,63,sizeof dp);
		memset(usf,-1,sizeof usf);
		dp[0][0][0][0][0]=0;
		for(int i=0;i<=33;++i)
		{
			for(int j=0;j<=mz;++j)
			{
				for(int k=0;k<=1;++k)
				{
					for(int l=0;l<=2 && l+j<=mz;++l)
					{
						for(int o=0;o<=2 && o+l+j<=mz;++o)
						{
							if(dp[i][j][k][l][o]<=8)
							{
								for(int nxtUse=l+o;nxtUse<=4;++nxtUse)
								{
									int dx=dp[i][j][k][l][o]+max(0,nxtUse-brkApp[i+1]),dy=(brkApp[i+1]>nxtUse?i+1:usf[i][j][k][l][o]);
									pair<int,int> mvdStatement=mp(dx,dy);
									int rest=nxtUse-l-o;
									if(rest>=3 && j+l+1<=mz)
									{
										pair<int,int> Statement=lesserPair(mp(dp[i+1][j+l+1][k][o][rest-3],usf[i+1][j+l+1][k][o][rest-3]),mvdStatement);
										dp[i+1][j+l+1][k][o][rest-3]=Statement.first,usf[i+1][j+l+1][k][o][rest-3]=Statement.second;
									}
									if(rest>=2 && !k)
									{
										pair<int,int> Statement=lesserPair(mp(dp[i+1][j+l][k+1][o][rest-2],usf[i+1][j+l][k+1][o][rest-2]),mvdStatement);
										dp[i+1][j+l][k+1][o][rest-2]=Statement.first,usf[i+1][j+l][k+1][o][rest-2]=Statement.second;
									}
									if(rest<=2)
									{
										pair<int,int> Statement=lesserPair(mp(dp[i+1][j+l][k][o][rest],usf[i+1][j+l][k][o][rest]),mvdStatement);
										dp[i+1][j+l][k][o][rest]=Statement.first,usf[i+1][j+l][k][o][rest]=Statement.second;
									}
								}
								if(i%9==0 || i>=27)	break;
							}
						}
						if(i%9==0 || i>=27)	break;
					}
				}
			}
		}
		if(type==1)	return dp[34][mz][1][0][0];
		return usf[34][mz][1][0][0];
	}
	#undef mp
	int calcXt(int *brk){return dpExecuter(brk,1);}
	int decideThrowBrick(int *brk){return dpExecuter(brk,2);}
```

将这个类取名 `MahjongGame`，定义一个 `MahjongGame` 类的变量 `MainGame`。主函数只需要执行 `MainGame.execute()` 即可。

至此，我们不算太过条理清晰地解决了这个问题。

因为所有的模块都放过一遍了，所以[完整代码](https://www.luogu.com.cn/paste/hhijcyk3)扔 Luogu 云剪贴板吧。

---

## 作者：liuzhangfeiabc (赞：37)

#### 写在前面

大家好我是泥萌可爱的出题人liuzhangfeiabc~

(别骂了我知道错了嘤嘤嘤)

说起来为什么会让我这个大一萌新来出这种题呢……~~喂这么毒瘤的题除了你还有谁会感兴趣~~

大家听我掩饰，哦不，解释，事情是这样的……最初他们组好题之后发现按往年惯例缺一道模拟，然后就找到了我

（为什么要找我啊？我也不想啊qwq）

~~为什么找你你自己心里还不清楚~~

总之接了这个活之后，按往年惯例一般大模拟会以一个游戏为背景（比如[P5380 [THUPC2019]鸭棋](https://www.luogu.com.cn/problem/P5380)），然后我就自然而然地想到去年整个机房被麻将支配的恐惧……

但是吧鉴于我的麻将水平也就那样，雀魂只有一个刚打上雀士1就弃了的号，也就勉强能分清日麻规则和国标规则的程度，于是造题的时候就很随心所欲（比如我题面里用的术语简直是乱七八糟大杂烩），到最后控制不住脑洞了又加了点特殊牌。当然最后出出来的结果是受到了出题组的一致好（tu）评（cao）(逃

行吧我们来看题解，当然作为大模拟我是不是只要写一个“本题按照题意模拟即可”就可以溜了……喂喂喂大家别走啊，喂！

接下来我们一个模块一个模块地看吧：



#### 各种定义

```cpp
#define gc getchar()
#define pc putchar
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
int pai[200],head = 1,fx = 1;
struct player{
	int a[20],sum;
	bool pass;
}p[4]; 
```

结构体`player`定义一名玩家，其中`a`数组表示他现有的牌，`sum`为手牌数，`pass`记录他有没有被pass。

`pai`表示牌堆，`head`表示牌堆顶，`fx`表示游戏进行的顺序。



#### 输入输出处理

我的处理方法是把输入进来的每一张牌变成1~37的数字进行存储，输出的时候再还原成牌的名称。

输入处理就是一堆case:

```cpp
int i,j,l;
string st;
for(i = 1;i <= 148;++i){
    cin>>st;
    if(st[0] >= '1' && st[0] <= '9'){
        l = st[0] - '0';
        switch(st[1]){
            case 'M' : pai[i] = l;break;
            case 'P' : pai[i] = l + 9;break;
            case 'S' : pai[i] = l + 18;break;
        }
    }
    else{
        switch(st[0]){
            case 'E' : pai[i] = 28;break;
            case 'S' : pai[i] = 29;break;
            case 'W' : pai[i] = 30;break;
            case 'N' : pai[i] = 31;break;
            case 'B' : pai[i] = 32;break;
            case 'F' : pai[i] = 33;break;
            case 'Z' : pai[i] = 34;break;
            case 'D' : pai[i] = 35;break;
            case 'R' : pai[i] = 36;break;
            case 'P' : pai[i] = 37;break;
        }
    }
}
```

输出的时候，先写了一个输出某特定编号牌的函数，也没有什么难度：

```cpp
inline void outpai(int paii){//输出paii这一张牌
	if(paii <= 27) cout<<(paii - 1) % 9 + 1<<("MPS"[(paii - 1) / 9]);
	else if(paii <= 34) cout<<("ESWNBFZ"[paii - 28]);
	else if(paii == 35) cout<<"DOUBLE";
	else if(paii == 36) cout<<"REVERSE";
	else cout<<"PASS";
}
```

有了这个之后来实现题目要求的几种输出就比较自然了：

```cpp
inline void draw(){//输出平局 
	cout<<"DRAW"<<endl;
	exit(0);
}
inline void win(int x){//输出x获胜 
	pc(x + 'A');pc(' ');cout<<"WIN"<<endl;
	exit(0);
} 
inline void hupai(int x){//输出x荣和 
	pc(x + 'A');cout<<" RON"<<endl;
	win(x);
}
inline void zimo(int x){//输出x自摸 
	pc(x + 'A');cout<<" SELFDRAWN"<<endl;
	win(x);
}
inline void in(int x,int paii){//输出x摸牌paii 
	pc(x + 'A');cout<<" IN ";
	outpai(paii);pc('\n');
}
inline void out(int x,int paii,int fg = -1){//输出x出牌paii，特判pass 
	pc(x + 'A');cout<<" OUT ";
	outpai(paii);
	if(fg >= 0) pc(' '),pc(fg + 'A');
	pc('\n');
}
inline void outchi(int x,int paii){//输出x吃，吃的第一张牌是paii 
	pc(x + 'A');cout<<" CHOW ";
	outpai(paii);pc(' ');outpai(paii + 1);pc(' ');outpai(paii + 2);pc('\n');
}
inline void outpeng(int x,int paii){//输出x碰paii 
	pc(x + 'A');cout<<" PONG ";
	outpai(paii);pc(' ');outpai(paii);pc(' ');outpai(paii);pc('\n');
}
```



#### 进行回合、摸牌

```cpp
int play(int x){//玩家x进行回合
	if(p[x].pass){
		p[x].pass = 0;
		return nxt(x);
	}
	mopai(x);
	return chupai(x);
}
```

这个框架很简单。一上来是判`pass`，这个`nxt`表示下家：

```cpp
#define nxt(x) (((x) + fx + 4) % 4)
```

摸牌也相对简单：

```cpp
inline void mopai(int x){//玩家x摸牌 
	if(head > 148) draw();
	p[x].a[++p[x].sum] = pai[head++];
	in(x,p[x].a[p[x].sum]);
	sort(p[x].a + 1,p[x].a + p[x].sum + 1);
}
```

摸完牌最好整理一下手牌。

注意别忘了开局要摸牌：

```cpp
for(i = 1;i <= 13;++i){
    for(j = 0;j < 4;++j) mopai(j);//开局摸牌 
}
```



#### 出牌

```cpp
int chupai(int x){//出牌 
	if(p[x].a[p[x].sum] == 37){//pass 
		--p[x].sum;p[nxt(x)].pass = 1;
		out(x,37,nxt(x));
		return nxt(x);
	}
	if(p[x].a[p[x].sum] == 36){//reverse
		--p[x].sum;
		fx *= -1;
		out(x,36);
		return nxt(x);
	}
	if(p[x].a[p[x].sum] == 35){//double
		--p[x].sum;
		out(x,35);
		mopai(x);
		return chupai(x);
	}
	int chu = check(x);
	if(chu == -1) zimo(x);
	chup(x,chu);
	checkhu(x,chu);
	int px = checkpeng(chu);
	if(px >= 0) return chupai(px);
	if(checkchi(nxt(x),chu)) return chupai(nxt(x));
	return nxt(x);
}
```

先判断有没有特殊牌可出，有的话就出，没有就通过`check`函数确定下一张出什么/有没有自摸。

确定了出的牌是`chu`之后，用`chup`函数进行出牌。

再用`checkhu`、`checkpeng`、`checkchi`判断有无和牌、碰、吃。

注意吃碰之后不会摸牌，因此直接进入对应玩家的`chupai`函数而不是`play`函数。

`chup`函数不难实现：

```cpp
inline void chup(int x,int chu){//玩家x出牌chu 
	int chid;
	for(chid = 1;chid <= p[x].sum;++chid) if(chu == p[x].a[chid]) break;
	swap(p[x].a[chid],p[x].a[p[x].sum]);
	--p[x].sum;
	sort(p[x].a + 1,p[x].a + p[x].sum + 1);
	out(x,chu);
}
```

出完牌也最好整理一下手牌。

接下来我们把重点放在其他几个函数上：



#### 计算和牌距离和下一张出的牌

这可能是整道题里最难的部分，因为其余地方只需要无脑模拟就完事了，最多是写起来复杂一点。

但是这一块就需要有一些技巧。

如果你做过[P5279 [ZJOI2019]麻将](https://www.luogu.com.cn/problem/P5279)或者[P5301 [GXOI/GZOI2019]宝牌一大堆](https://www.luogu.com.cn/problem/P5301)的话，你应该能反应上来这需要一个dp：
$dp[i][j][k][l][g]$表示：目前考虑了前$i$种牌，已经凑齐了$j$个顺子和刻子、$k$个对子，计划凑成从第$i-1$种牌开始的顺子$l$个，从第$i$种牌开始的顺子$g$个，至少要往现在的手牌里添加多少张牌。

同时记录一个$zy[i][j][k][l][g]$表示在上述情况下，手里最后一张没有用上的手牌是什么。

转移：枚举$i+1$这种牌要用多少张（至少$l+g$张，至多$4$张）。假设要用$x$张，而手牌里有$y$张，需要讨论：

1、$x<y$：这说明手牌没用完，$dp$数组的值不会增加，$zy$数组的值变为$i+1$。

2、$x=y$：这说明手牌恰好用完，$dp$数组的值不会增加，$zy$数组的值不变。

3、$x>y$：这说明手牌不够，还差了$x-y$张是需要额外添加的，$dp$数组的值增加$x-y$，$zy$数组的值不变。

对于每个$x$，需要拿出$l+g$张用于之前未完成的顺子，剩余的部分可以用于开启新的顺子/凑一个对子/凑一个刻子，这样我们就可以通过讨论计算出下一步转移到的状态是什么。

这一部分的代码如下：

```cpp
int sl[40],dp[40][5][2][3][3],zy[40][5][2][3][3];
#define zhuanyi(a,b,x,y) if((x) < (a) || ((x) == (a) && (y) > (b))) (a) = (x),(b) = (y)
pii work(int x){//计算和牌距离和下一张出的牌（最后一张没用的牌），x表示要凑出的顺子和刻子数目 
	memset(dp,0x3f,sizeof(dp));memset(zy,-1,sizeof(zy));
	dp[0][0][0][0][0] = 0;
	register int i,j,k,l,g,q,nx,ny,r;
	for(i = 0;i < 34;++i){
		for(j = 0;j <= x;++j){
			for(k = 0;k <= 1;++k){
				for(l = 0;l <= 2 && l + j <= x;++l){
					for(g = 0;g <= 2 && g + l + j <= x;++g) if(dp[i][j][k][l][g] < 15){
						for(q = l + g;q <= 4;++q){
							nx = dp[i][j][k][l][g] + max(0,q - sl[i + 1]);
							ny = (sl[i + 1] > q ? i + 1 : zy[i][j][k][l][g]);
							r = q - l - g;
							if(r >= 3 && j + l + 1 <= x) zhuanyi(dp[i + 1][j + l + 1][k][g][r - 3],zy[i + 1][j + l + 1][k][g][r - 3],nx,ny);
							if(r >= 2 && !k) zhuanyi(dp[i + 1][j + l][k + 1][g][r - 2],zy[i + 1][j + l][k + 1][g][r - 2],nx,ny);
							if(r <= 2) zhuanyi(dp[i + 1][j + l][k][g][r],zy[i + 1][j + l][k][g][r],nx,ny);
						}
						if(i % 9 == 0 || i >= 27) break; 
					}
					if(i % 9 == 0 || i >= 27) break; 
				}
			}
		}
	}
	return mp(dp[34][x][1][0][0],zy[34][x][1][0][0]);
}
int check(int x){//返回应该出哪一张牌，如果已经和了返回-1（因此也可以用于检验是否已经和牌） 
	memset(sl,0,sizeof(sl));
	for(int i = 1;i <= p[x].sum;++i) if(p[x].a[i] <= 34) ++sl[p[x].a[i]];
	pii as = work(4 - (14 - p[x].sum) / 3);
	return as.se;
}
```

其中`check`函数会对玩家`x`的手牌进行分类整理后扔给`work`函数。



#### 和牌

```cpp
inline bool ts(int x){//能和牌的前提是没有特殊牌 
	for(int i = 1;i <= p[x].sum;++i) if(p[x].a[i] > 34) return 1;
	return 0;
}
void checkhu(int x,int chu){//判断能否和牌 
	for(int i = nxt(x);i != x;i = nxt(i)) if(!ts(i)){
		p[i].a[++p[i].sum] = chu;
		if(check(i) == -1) hupai(i);
		--p[i].sum;
	}
}
```

这里在一开始写的时候遇到了一个bug：如果手牌里有特殊牌，`work`函数有可能在和牌距离不为$0$的时候返回$-1$，因此提前判了一下。



#### 碰

```cpp
bool chkpeng(int x,int chu){//碰 
	memset(sl,0,sizeof(sl));
	for(int i = 1;i <= p[x].sum;++i) ++sl[p[x].a[i]];
	int lst = work(4 - (14 - p[x].sum) / 3).fi;
	if(sl[chu] >= 2){
		sl[chu] -= 2;
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outpeng(x,chu);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
	}
	return 0;
} 
int checkpeng(int chu){//对每一家判断能不能碰 
	for(int x = 0;x < 4;++x) if(chkpeng(x,chu)) return x;
	return -1;
}
```

所有玩家都能碰，所以要枚举不同的玩家，这里可以这么写是因为自己肯定不会碰自己刚出的牌。

具体实现就是先计算一下和牌距离，然后把手里相应的牌去掉再计算和牌距离，如果减小了就碰，碰完也最好整理一下手牌。



#### 吃

```cpp
bool checkchi(int x,int chu){//吃 
	if(chu > 27) return 0;
	memset(sl,0,sizeof(sl));
	for(int i = 1;i <= p[x].sum;++i) ++sl[p[x].a[i]];
	int lst = work(4 - (14 - p[x].sum) / 3).fi;
	if(chu % 9 != 8 && chu % 9 != 0 && sl[chu + 1] && sl[chu + 2]){//x x+1 x+2 
		--sl[chu + 1];--sl[chu + 2];
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outchi(x,chu);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
		++sl[chu + 1];++sl[chu + 2];
	}
	if(chu % 9 != 1 && chu % 9 != 0 && sl[chu - 1] && sl[chu + 1]){//x-1 x x+1
		--sl[chu - 1];--sl[chu + 1];
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outchi(x,chu - 1);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
		++sl[chu - 1];++sl[chu + 1];
	}
	if(chu % 9 != 1 && chu % 9 != 2 && sl[chu - 2] && sl[chu - 1]){//x-2 x-1 x
		--sl[chu - 2];--sl[chu - 1];
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outchi(x,chu - 2);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
		++sl[chu - 2];++sl[chu - 1];
	}
	return 0;
}
```

吃与碰的区别在于只有下家能吃，但是有3种可能的吃法，都判断一下就好。其他细节跟碰类似。



#### 大功告成！来看一下完整代码

```cpp
#include<bits/stdc++.h>
#define gc getchar()
#define pc putchar
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
using namespace std;
int pai[200],head = 1,fx = 1;
struct player{
	int a[20],sum;
	bool pass;
}p[4]; 
inline void outpai(int paii){//输出paii这一张牌 
	if(paii <= 27) cout<<(paii - 1) % 9 + 1<<("MPS"[(paii - 1) / 9]);
	else if(paii <= 34) cout<<("ESWNBFZ"[paii - 28]);
	else if(paii == 35) cout<<"DOUBLE";
	else if(paii == 36) cout<<"REVERSE";
	else cout<<"PASS";
}
inline void draw(){//输出平局 
	cout<<"DRAW"<<endl;
	exit(0);
}
inline void win(int x){//输出x获胜 
	pc(x + 'A');pc(' ');cout<<"WIN"<<endl;
	exit(0);
} 
inline void hupai(int x){//输出x荣和 
	pc(x + 'A');cout<<" RON"<<endl;
	win(x);
}
inline void zimo(int x){//输出x自摸 
	pc(x + 'A');cout<<" SELFDRAWN"<<endl;
	win(x);
}
inline void in(int x,int paii){//输出x摸牌paii 
	pc(x + 'A');cout<<" IN ";
	outpai(paii);pc('\n');
}
inline void out(int x,int paii,int fg = -1){//输出x出牌paii，特判pass 
	pc(x + 'A');cout<<" OUT ";
	outpai(paii);
	if(fg >= 0) pc(' '),pc(fg + 'A');
	pc('\n');
}
inline void outchi(int x,int paii){//输出x吃，吃的第一张牌是paii 
	pc(x + 'A');cout<<" CHOW ";
	outpai(paii);pc(' ');outpai(paii + 1);pc(' ');outpai(paii + 2);pc('\n');
}
inline void outpeng(int x,int paii){//输出x碰paii 
	pc(x + 'A');cout<<" PONG ";
	outpai(paii);pc(' ');outpai(paii);pc(' ');outpai(paii);pc('\n');
}
inline void mopai(int x){//玩家x摸牌 
	if(head > 148) draw();
	p[x].a[++p[x].sum] = pai[head++];
	in(x,p[x].a[p[x].sum]);
	sort(p[x].a + 1,p[x].a + p[x].sum + 1);
}
inline void chup(int x,int chu){//玩家x出牌chu 
	int chid;
	for(chid = 1;chid <= p[x].sum;++chid) if(chu == p[x].a[chid]) break;
	swap(p[x].a[chid],p[x].a[p[x].sum]);
	--p[x].sum;
	sort(p[x].a + 1,p[x].a + p[x].sum + 1);
	out(x,chu);
}
int sl[40],dp[40][5][2][3][3],zy[40][5][2][3][3];
#define zhuanyi(a,b,x,y) if((x) < (a) || ((x) == (a) && (y) > (b))) (a) = (x),(b) = (y)
pii work(int x){//计算和牌距离和下一张出的牌（最后一张没用的牌），x表示要凑出的顺子和刻子数目 
	memset(dp,0x3f,sizeof(dp));memset(zy,-1,sizeof(zy));
	dp[0][0][0][0][0] = 0;
	register int i,j,k,l,g,q,nx,ny,r;
	for(i = 0;i < 34;++i){
		for(j = 0;j <= x;++j){
			for(k = 0;k <= 1;++k){
				for(l = 0;l <= 2 && l + j <= x;++l){
					for(g = 0;g <= 2 && g + l + j <= x;++g) if(dp[i][j][k][l][g] < 15){
						for(q = l + g;q <= 4;++q){
							nx = dp[i][j][k][l][g] + max(0,q - sl[i + 1]);
							ny = (sl[i + 1] > q ? i + 1 : zy[i][j][k][l][g]);
							r = q - l - g;
							if(r >= 3 && j + l + 1 <= x) zhuanyi(dp[i + 1][j + l + 1][k][g][r - 3],zy[i + 1][j + l + 1][k][g][r - 3],nx,ny);
							if(r >= 2 && !k) zhuanyi(dp[i + 1][j + l][k + 1][g][r - 2],zy[i + 1][j + l][k + 1][g][r - 2],nx,ny);
							if(r <= 2) zhuanyi(dp[i + 1][j + l][k][g][r],zy[i + 1][j + l][k][g][r],nx,ny);
						}
						if(i % 9 == 0 || i >= 27) break; 
					}
					if(i % 9 == 0 || i >= 27) break; 
				}
			}
		}
	}
	return mp(dp[34][x][1][0][0],zy[34][x][1][0][0]);
}
int check(int x){//返回应该出哪一张牌，如果已经和了返回-1（因此也可以用于检验是否已经和牌） 
	memset(sl,0,sizeof(sl));
	for(int i = 1;i <= p[x].sum;++i) if(p[x].a[i] <= 34) ++sl[p[x].a[i]];
	pii as = work(4 - (14 - p[x].sum) / 3);
	return as.se;
}
inline bool ts(int x){//能和牌的前提是没有特殊牌 
	for(int i = 1;i <= p[x].sum;++i) if(p[x].a[i] > 34) return 1;
	return 0;
}
#define nxt(x) (((x) + fx + 4) % 4)
void checkhu(int x,int chu){//判断能否和牌 
	for(int i = nxt(x);i != x;i = nxt(i)) if(!ts(i)){
		p[i].a[++p[i].sum] = chu;
		if(check(i) == -1) hupai(i);
		--p[i].sum;
	}
}
bool chkpeng(int x,int chu){//碰 
	memset(sl,0,sizeof(sl));
	for(int i = 1;i <= p[x].sum;++i) ++sl[p[x].a[i]];
	int lst = work(4 - (14 - p[x].sum) / 3).fi;
	if(sl[chu] >= 2){
		sl[chu] -= 2;
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outpeng(x,chu);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
	}
	return 0;
} 
int checkpeng(int chu){//对每一家判断能不能碰 
	for(int x = 0;x < 4;++x) if(chkpeng(x,chu)) return x;
	return -1;
}
bool checkchi(int x,int chu){//吃 
	if(chu > 27) return 0;
	memset(sl,0,sizeof(sl));
	for(int i = 1;i <= p[x].sum;++i) ++sl[p[x].a[i]];
	int lst = work(4 - (14 - p[x].sum) / 3).fi;
	if(chu % 9 != 8 && chu % 9 != 0 && sl[chu + 1] && sl[chu + 2]){//x x+1 x+2 
		--sl[chu + 1];--sl[chu + 2];
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outchi(x,chu);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
		++sl[chu + 1];++sl[chu + 2];
	}
	if(chu % 9 != 1 && chu % 9 != 0 && sl[chu - 1] && sl[chu + 1]){//x-1 x x+1
		--sl[chu - 1];--sl[chu + 1];
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outchi(x,chu - 1);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
		++sl[chu - 1];++sl[chu + 1];
	}
	if(chu % 9 != 1 && chu % 9 != 2 && sl[chu - 2] && sl[chu - 1]){//x-2 x-1 x
		--sl[chu - 2];--sl[chu - 1];
		if(lst > work(3 - (14 - p[x].sum) / 3).fi){
			outchi(x,chu - 2);
			p[x].sum = 0;
			for(int i = 1;i <= 37;++i){
				while(sl[i]) p[x].a[++p[x].sum] = i,--sl[i];
			}
			return 1;
		}
		++sl[chu - 2];++sl[chu - 1];
	}
	return 0;
}
int chupai(int x){//出牌 
	if(p[x].a[p[x].sum] == 37){//pass 
		--p[x].sum;p[nxt(x)].pass = 1;
		out(x,37,nxt(x));
		return nxt(x);
	}
	if(p[x].a[p[x].sum] == 36){//reverse
		--p[x].sum;
		fx *= -1;
		out(x,36);
		return nxt(x);
	}
	if(p[x].a[p[x].sum] == 35){//double
		--p[x].sum;
		out(x,35);
		mopai(x);
		return chupai(x);
	}
	int chu = check(x);
	if(chu == -1) zimo(x);
	chup(x,chu);
	checkhu(x,chu);
	int px = checkpeng(chu);
	if(px >= 0) return chupai(px);
	if(checkchi(nxt(x),chu)) return chupai(nxt(x));
	return nxt(x);
}
int play(int x){//玩家x进行回合
	if(p[x].pass){
		p[x].pass = 0;
		return nxt(x);
	}
	mopai(x);
	return chupai(x);
}
int main(){
	int i,j,l;
	string st;
	for(i = 1;i <= 148;++i){
		cin>>st;
		if(st[0] >= '1' && st[0] <= '9'){
			l = st[0] - '0';
			switch(st[1]){
				case 'M' : pai[i] = l;break;
				case 'P' : pai[i] = l + 9;break;
				case 'S' : pai[i] = l + 18;break;
			}
		}
		else{
			switch(st[0]){
				case 'E' : pai[i] = 28;break;
				case 'S' : pai[i] = 29;break;
				case 'W' : pai[i] = 30;break;
				case 'N' : pai[i] = 31;break;
				case 'B' : pai[i] = 32;break;
				case 'F' : pai[i] = 33;break;
				case 'Z' : pai[i] = 34;break;
				case 'D' : pai[i] = 35;break;
				case 'R' : pai[i] = 36;break;
				case 'P' : pai[i] = 37;break;
			}
		}
	}
	for(i = 1;i <= 13;++i){
		for(j = 0;j < 4;++j) mopai(j);//开局摸牌 
	}
	int nw = 0;
	while(1) nw = play(nw);
	return 0;
}
```



#### 后记

~~泥萌怎么能说我这题比猪国杀还毒瘤呢qwq~~

~~这题std明明只写了3个小时，代码只有6个k，验题人甚至只写了4个k~~

~~再说了场上可是有足足两车人过了这题啊qaq~~



---

## 作者：SuperCowHorse (赞：5)

耗费 $9.5$ Hours，终于写出了自己第一道大模拟，纪念一下。

---

~~这种题对那种麻将意识从小培养的家庭的孩子来说，是很容易的。~~

好吧，也不是很容易。~~但我真的从小培养麻将。~~

---
[传送门](https://www.luogu.com.cn/problem/P7147)。

那我们就一个个函数来看吧（若遇到了前面没有讲到的函数，那么应该在下面或最后完整代码中，因为按本篇文章的顺序写逻辑方面更好理解，作者语文不好，请见谅 qwq，若实在找不到，请打开博客详情页，Ctrl+F）：

## 预处理
我们预处理出每张牌的**价值**。注意，这里的价值指：若有重复元素，出牌的先后顺序，对每种牌进行标号。如："M"牌的价值为 $1$，"PASS"牌的价值为 $37$，到时候只要读取价值取最大的出就可以了。顺便再确定初始的出牌顺序，和每个价值对应的牌。
``` cpp
string Mah_Jong[50]={//每一个价值代表的牌
	"",
	"1M","2M","3M","4M","5M","6M","7M","8M","9M",
	"1P","2P","3P","4P","5P","6P","7P","8P","9P",
	"1S","2S","3S","4S","5S","6S","7S","8S","9S",
	"E","S","W","N","B","F","Z",
	"DOUBLE","REVERSE","PASS"
};
string People=" ABCD";//People[i] 表示第 i 个人
inline void Init(){
	Reverse();//确定出牌顺序
	level["PASS"]=37;level["REVERSE"]=36;level["DOUBLE"]=35;
	level["Z"]=34;level["F"]=33;level["B"]=32;level["N"]=31;level["W"]=30;level["S"]=29;level["E"]=28;
	level["9S"]=27;level["8S"]=26;level["7S"]=25;level["6S"]=24;level["5S"]=23;level["4S"]=22;level["3S"]=21;level["2S"]=20;level["1S"]=19;
	level["9P"]=18;level["8P"]=17;level["7P"]=16;level["6P"]=15;level["5P"]=14;level["4P"]=13;level["3P"]=12;level["2P"]=11;level["1P"]=10;
	level["9M"]=9;level["8M"]=8;level["7M"]=7;level["6M"]=6;level["5M"]=5;level["4M"]=4;level["3M"]=3;level["2M"]=2;level["1M"]=1;
    //确定每张牌价值
}
```

## 输入
我们将 $148$ 张麻将牌按顺序存入 `Mahjong` 数组中，方便以后摸牌。
``` cpp
inline int Get(int i){
	return (i+3)%4+1;
}
inline void Input(){
	for(int i=1;i<=148;++i){
		cin>>Mahjong[i];
	}
}
inline void TakeUpCard(){
	for(int i=1;i<=52;++i){
		int p=Get(i);
		a[p].AddCard(level[Mahjong[i]]);//将牌添加到 i 的牌组
		cout<<People[p]<<" IN "<<Mahjong[i]<<"\n";
	}
	now=52;
}
```
## 回合

这里的东西有点多，我们按顺序一一讲解函数：

首先先枚举每一个人的顺序：

``` cpp
for(int i=1;now<148;i=a[i].next)//a[i].next 表示下家
```

由于人是可以吃或碰的，这时候他就不能再摸牌，我们就可以用一个 `flg` 记录下一个人要不要摸牌，然后进行摸牌操作。注意，摸牌的时候，有可能会自摸，记录一下即可：
``` cpp
if(!flg){
	cout<<People[i]<<" IN "<<Mahjong[++now]<<"\n";//输出摸到那张牌
	a[i].AddCard(level[Mahjong[now]]);//加牌
	if(a[i].DIST()==0){//a[i].DIST() 表示和牌距离
//		a[i].Debug(i);
		cout<<People[i]<<" SELFDRAWN"<<"\n";
		cout<<People[i]<<" WIN"<<"\n";
		return;//直接返回
	}
}
```
然后是出牌。先将 `flg` 清零，然后计算出那张牌**既可以使和牌距离减小，也有最大的价值**（注：技能牌"PASS"，"REVERSE"，"DOUBLE"要先出）。
``` cpp
//a[i].Debug(i);
flg=0;
int s=a[i].Clac();//计算出哪张卡最优
a[i].DelCard(s);//删除价值为 s 的卡
if(s==37){//PASS
	cout<<People[i]<<" OUT PASS "<<People[a[i].next]<<"\n";//PASS 特判
	i=a[i].next;//下家跳过（因为循环里还有一个 i=a[i].next，相当于跳了一家）
	continue;
}
cout<<People[i]<<" OUT "<<Mah_Jong[s]<<"\n";//输出出了哪张牌
if(s==36){//REVERSE
	Reverse();
	continue;
}
if(s==35){//DOUBLE
	i=a[i].pres;//a[i].pres 表示上家
	continue;
}
```
由题目，荣和优先级大于吃和碰，所以，先判断荣和：加进某张牌后，和牌距离是否为 $0$。
``` cpp
for(int j=a[i].next;j!=i;j=a[j].next){//枚举 j 能否荣和，因为有截胡的可能，所以要按下家枚举
	if(i==j) continue;
	a[j].AddCard(s);//添加 s 牌
	if(a[j].DIST()==0){//荣和了
		cout<<People[j]<<" RON"<<"\n";
		cout<<People[j]<<" WIN"<<"\n";
		return;//直接返回
	}
	a[j].DelCard(s);//删除 s 牌
}
```
然后是碰。与荣和类似。
``` cpp
bool fl=0;
for(int j=a[i].next;j!=i;j=a[j].next){//枚举 j
	if(a[j].CheckPong(s)){//如果能碰
		cout<<People[j]<<" PONG "<<Mah_Jong[s]<<" "<<Mah_Jong[s]<<" "<<Mah_Jong[s]<<"\n";
		i=a[j].pres;flg=1;//记录：下一个出牌的是 j，不能摸牌
		fl=1;break;//记录：碰了，直接下一轮
	}
}
if(fl) continue;//如果碰了直接下一轮
```
然后是吃。注意，这里的吃只能下家吃。~~虽然来做这道题的基本都会麻将但是也强调一下~~：
``` cpp
int j=a[i].next;
if(a[j].CheckChow(s)){//如果能吃
	cout<<People[j]<<" CHOW "<<Mah_Jong[chow[0]]<<" "<<Mah_Jong[chow[1]]<<" "<<Mah_Jong[chow[2]]<<"\n";//输出
	i=a[j].pres;//记录：下一个出牌的是 j
	flg=1;//记录：下一轮不能摸牌
	continue;
}
```
对了，别忘了判断流局。只需在最后加一段：
``` cpp
cout<<"DRAW"<<"\n";
```
就行。

好啦，$\operatorname{Playing}$ 函数就写完了。放个完整代码：
``` cpp
inline void Playing(){
	bool flg=0;
	for(int i=1;now<148;i=a[i].next){
		if(!flg){
			cout<<People[i]<<" IN "<<Mahjong[++now]<<"\n";
			a[i].AddCard(level[Mahjong[now]]);
			if(a[i].DIST()==0){
//				a[i].Debug(i);
				cout<<People[i]<<" SELFDRAWN"<<"\n";
				cout<<People[i]<<" WIN"<<"\n";
				return;
			}
		}
//		a[i].Debug(i);
		flg=0;
		int s=a[i].Clac();
		a[i].DelCard(s);
		if(s==37){
			cout<<People[i]<<" OUT PASS "<<People[a[i].next]<<"\n";
			i=a[i].next;
			continue;
		}
		cout<<People[i]<<" OUT "<<Mah_Jong[s]<<"\n";
		if(s==36){
			Reverse();
			continue;
		}
		if(s==35){
			i=a[i].pres;
			continue;
		}
		for(int j=a[i].next;j!=i;j=a[j].next){
			if(i==j) continue;
			a[j].AddCard(s);
			if(a[j].DIST()==0){
				cout<<People[j]<<" RON"<<"\n";
				cout<<People[j]<<" WIN"<<"\n";
				return;
			}
			a[j].DelCard(s);
		}
		bool fl=0;
		for(int j=a[i].next;j!=i;j=a[j].next){
			if(a[j].CheckPong(s)){
				cout<<People[j]<<" PONG "<<Mah_Jong[s]<<" "<<Mah_Jong[s]<<" "<<Mah_Jong[s]<<"\n";
				i=a[j].pres;flg=1;
				fl=1;break;
			}
		}
		if(fl) continue;
		int j=a[i].next;
		if(a[j].CheckChow(s)){
			cout<<People[j]<<" CHOW "<<Mah_Jong[chow[0]]<<" "<<Mah_Jong[chow[1]]<<" "<<Mah_Jong[chow[2]]<<"\n";
			i=a[j].pres;
			flg=1;
			continue;
		}
	}
	cout<<"DRAW"<<"\n";
}
```
然后就是刚才咕咕咕的函数了。
首先是 $\operatorname{Reverse}$（很好理解）：
``` cpp
inline void Reverse(){//翻转顺序
	if(a[1].next==2){
		a[1].next=4;a[2].next=1;a[3].next=2;a[4].next=3;
		a[1].pres=2;a[2].pres=3;a[3].pres=4;a[4].pres=1;
	}
	else{
		a[1].next=2;a[2].next=3;a[3].next=4;a[4].next=1;
		a[1].pres=4;a[2].pres=1;a[3].pres=2;a[4].pres=3;
	}
}
```
其他函数我都放在了一个 `struct` 类型的容器里。

首先是加牌，删牌：
``` cpp
inline void AddCard(int s){//加牌
	++cnt[s];++tot;//cnt 是桶，tot 是牌数
}
inline void DelCard(int s){//删牌
	--cnt[s];--tot;
}
```
然后是计算下一张牌该出什么（$\operatorname{Clac}$）：
``` cpp
inline int Clac(){
	if(cnt[37]){return 37;}//有 PASS
	if(cnt[36]){return 36;}//有 REVERSE
	if(cnt[35]){return 35;}//有 DOUBLE
	priority_queue<node>q;//堆，计算哪一张牌最优
	for(int i=1;i<=34;++i){
		if(!cnt[i]) continue;
		DelCard(i);//删牌（即出了这张牌）
		q.push(node{i,DIST()});//入堆
		AddCard(i);//加回来
	}
	int s=q.top().id;//取最优
	return s;
}
```
至于 `node`，我使用了重载运算符进行堆排与计算，~~不会的可以 Bing 一下~~：
``` cpp
struct node{
	int id,dis;//牌的编号与打出后的向听（和牌距离）
	inline bool operator <(const node &tmp)const{
		return tmp.dis==dis?tmp.id>id:tmp.dis<dis;
	}
};
```
然后就是碰了。碰好一点，没有大分讨（分类讨论）：
``` cpp
inline void Pong(int s){
	DelCard(s);DelCard(s);//删除两张“碰牌”
}
inline bool CheckPong(int s){
	if(cnt[s]<2) return 0;//如果没有两张就不能碰
	int oldDist=DIST();//原本的和牌距离
	DelCard(s);DelCard(s);//假如要碰
	int newDist=DIST();//现在的和牌距离
	AddCard(s);AddCard(s);//加回来
	if(oldDist<=newDist){//没有严格减小
		return 0;//不能碰
	}
	Pong(s);//否则就碰
	return 1;
}
```
然后是吃。由于 1 万，1 条，1 筒等特殊的不能吃的情况存在，我们需要分类讨论：
``` cpp
inline void Chow(int s1,int s2,int s3){//吃
	chow[0]=s1;chow[1]=s2;chow[2]=s3;
	sort(chow,chow+3);//题目中说要从大到小输出
	DelCard(s2);DelCard(s3);//删除
}
inline bool CheckChow(int s){
	if(s>=28) return 0;//如果是东南西北红中白就不能吃
	int oldDist=DIST();//原本的和牌距离
	int newDist;
	if(s==1||s==10||s==19){//1万，1条，1筒
		int s2=s+1,s3=s+2;//只能和 2,3 吃
		if(!cnt[s2]||!cnt[s3]) return 0;//如果没有就不能吃
		DelCard(s2);DelCard(s3);//删除
		newDist=DIST();//计算新的和牌距离
		AddCard(s2);AddCard(s3);//加回来
		if(oldDist<=newDist) return 0;//如果不优就不吃
		Chow(s,s2,s3);//否则就吃
		return 1;
	}
	if(s==9||s==18||s==27){//9万，9条，9筒
		int s2=s-1,s3=s-2;//只能和 7,8 吃
		if(!cnt[s2]||!cnt[s3]) return 0;//如果没有就不能吃
		DelCard(s2);DelCard(s3);//删除
		newDist=DIST();//计算新的和牌距离
		AddCard(s2);AddCard(s3);//加回来
		if(oldDist<=newDist) return 0;//如果不优就不吃
		Chow(s,s2,s3);//否则就吃
		return 1;
	}
	for(int i=0;i<3;++i){//枚举每种碰的情况
		if((s==2||s==11||s==20)&&i==2) continue;//2万，2条，2筒不能和 0,1 吃
		if((s==8||s==17||s==26)&&i==0) continue;//8万，8条，8筒不能和 9,10 吃
		int s2=s+dx[i];
		int s3=s+dy[i];
		if(!cnt[s2]||!cnt[s3]) continue;//如果没有就不能吃
		DelCard(s2);DelCard(s3);//删除
		newDist=DIST();//计算新的和牌距离
		AddCard(s2);AddCard(s3);//加回来
		if(oldDist<=newDist) continue;//如果不优就不吃
		Chow(s,s2,s3);//否则就吃（因为枚举顺序，直接吃就行）
		return 1;
	}
	return 0;
}
```
代码中的 $dx,dy$ 指吃的距离：
``` cpp
const int dx[]={2,1,-2};
const int dy[]={1,-1,-1};
```
~~还有 `Denug` 函数，可以帮你查错，功能是输出每一回合某人的手牌：~~
``` cpp
inline void Debug(int p){
	cout<<"Now,Player "<<People[p]<<" "<<"has these following MahJongs:\n";
	for(int i=1;i<=37;++i){//输出
		for(int j=1;j<=cnt[i];++j){
			cout<<Mah_Jong[i]<<" ";
		}
	}
	cout<<"\n";
}
```
还有一个天坑：计算和牌距离。

这需要用一些动态规划的知识。

我们定义一个状态，$f_{i,j,k,l,g}$ 表示枚举到第 $i$ 张牌（注意是全局的所有牌，不是每一个人的手牌），已经有了 $j$ 个顺子和刻子，$k$ 个对子，单牌 $l$ 个，快成为顺子（差一个）有 $g$ 个的和牌距离。

如何转移？

我们可以枚举这第 $i+1$ 张牌需要多少张（至少 $l+g$ 张，需要组成对子和顺子）。枚举 $o=[l+g,4]$，然后转移：

由于 $l+g$ 个拿去当顺子了，还有 $o-l-g$ 个剩下的，我么在上面做文章：

1. 剩下的牌有 $3$ 张以上，我们可以拿它做刻子。

1. 剩下的牌有 $2$ 张以上且**没有对子**（有 $2$ 个对子就胡不了了，~~7 对子没法赢~~）。

1. 剩下的牌有 $2$ 张一下，没法组牌，直接转移。
``` cpp
inline int Dist(){
	memset(f,0x3f,sizeof(f));//初始化
	f[0][0][0][0][0]=0;//初始化
	int x=tot/3;//计划要凑 x 个刻子、顺子
	for(int i=0;i<34;++i){//枚举 i
		for(int j=0;j<=x;++j){//枚举 j
			for(int k=0;k<=1;++k){//枚举 k
				for(int l=0;l<=2&&l+j<=x;++l){//枚举 l
					for(int g=0;g<=2&&l+j+g<=x;++g){//枚举 g
						if(f[i][j][k][l][g]<=20){//如果此状态可以转移，则刷表
							for(int o=l+g;o<=4;++o){//枚举 o
								int s=f[i][j][k][l][g]+max(0,o-cnt[i+1]);
								int t=o-l-g;//剩下 t 个
								if(t>=3&&j+l+1<=x){//做刻子、顺子
									f[i+1][j+l+1][k][g][t-3]=min(f[i+1][j+l+1][k][g][t-3],s);
								}
								if(t>=2&&!k){//组对子
									f[i+1][j+l][k+1][g][t-2]=min(f[i+1][j+l][k+1][g][t-2],s);
								}
								if(t<=2){//直接转移
										f[i+1][j+l][k][g][t]=min(f[i+1][j+l][k][g][t],s);
								}
							}
						}
						if(i%9==0||i>=27) break;//东南西北中发白没法转移，9万、9条、9筒开头组不了顺子
					}
					if(i%9==0||i>=27) break;
				}
			}
		}
	}
	return f[34][x][1][0][0];//返回
}
```
好啦！放一个 `struct` 容器：
``` cpp
struct Person{
	int next,pres;
	int tot;
	int cnt[50];
	int f[50][5][2][3][3];
	inline int Dist(){
		memset(f,0x3f,sizeof(f));
		f[0][0][0][0][0]=0;
		int x=tot/3;
		for(int i=0;i<34;++i){
			for(int j=0;j<=x;++j){
				for(int k=0;k<=1;++k){
					for(int l=0;l<=2&&l+j<=x;++l){
						for(int g=0;g<=2&&l+j+g<=x;++g){
							if(f[i][j][k][l][g]<=20){
								for(int o=l+g;o<=4;++o){
									int s=f[i][j][k][l][g]+max(0,o-cnt[i+1]);
									int t=o-l-g;
									if(t>=3&&j+l+1<=x){
										f[i+1][j+l+1][k][g][t-3]=min(f[i+1][j+l+1][k][g][t-3],s);
									}
									if(t>=2&&!k){
										f[i+1][j+l][k+1][g][t-2]=min(f[i+1][j+l][k+1][g][t-2],s);
									}
									if(t<=2){
										f[i+1][j+l][k][g][t]=min(f[i+1][j+l][k][g][t],s);
									}
								}
							}
							if(i%9==0||i>=27) break;
						}
						if(i%9==0||i>=27) break;
					}
				}
			}
		}
		return f[34][x][1][0][0];
	}
	inline void AddCard(int s){
		++cnt[s];++tot;
	}
	inline void DelCard(int s){
		--cnt[s];--tot;
	}
	inline int DIST(){
		return Dist();
	}
	inline int Clac(){
		if(cnt[37]){return 37;}
		if(cnt[36]){return 36;}
		if(cnt[35]){return 35;}
		priority_queue<node>q;
		for(int i=1;i<=34;++i){
			if(!cnt[i]) continue;
			DelCard(i);
			q.push(node{i,DIST()});
			AddCard(i);
		}
		int s=q.top().id;
		return s;
	}
	inline void Pong(int s){
		DelCard(s);DelCard(s);
	}
	inline bool CheckPong(int s){
		if(cnt[s]<2) return 0;
		int oldDist=DIST();
		DelCard(s);DelCard(s);
		int newDist=DIST();
		AddCard(s);AddCard(s);
		if(oldDist<=newDist){
			return 0;
		}
		Pong(s);
		return 1;
	}
	inline void Chow(int s1,int s2,int s3){
		chow[0]=s1;chow[1]=s2;chow[2]=s3;
		sort(chow,chow+3);
		DelCard(s2);DelCard(s3);
	}
	inline bool CheckChow(int s){
		if(s>=28) return 0;
		int oldDist=DIST();
		int newDist;
		if(s==1||s==10||s==19){
			int s2=s+1,s3=s+2;
			if(!cnt[s2]||!cnt[s3]) return 0;
			DelCard(s2);DelCard(s3);
			newDist=DIST();
			AddCard(s2);AddCard(s3);
			if(oldDist<=newDist) return 0;
			Chow(s,s2,s3);
			return 1;
		}
		if(s==9||s==18||s==27){
			int s2=s-1,s3=s-2;
			if(!cnt[s2]||!cnt[s3]) return 0;
			DelCard(s2);DelCard(s3);
			newDist=DIST();
			AddCard(s2);AddCard(s3);
			if(oldDist<=newDist) return 0;
			Chow(s,s2,s3);
			return 1;
		}
		for(int i=0;i<3;++i){
			if((s==2||s==11||s==20)&&i==2) continue;
			if((s==8||s==17||s==26)&&i==0) continue;
			int s2=s+dx[i];
			int s3=s+dy[i];
			if(!cnt[s2]||!cnt[s3]) continue;
			DelCard(s2);DelCard(s3);
			newDist=DIST();
			AddCard(s2);AddCard(s3);
			if(oldDist<=newDist) continue;
			Chow(s,s2,s3);
			return 1;
		}
		return 0;
	}
	inline void Debug(int p){
		cout<<"Now,Player "<<People[p]<<" "<<"has these following MahJongs:\n";
		for(int i=1;i<=37;++i){
			for(int j=1;j<=cnt[i];++j){
				cout<<Mah_Jong[i]<<" ";
			}
		}
		cout<<"\n";
	}
}a[5];
```

完整代码（高清无注释）：
``` cpp
#include<bits/stdc++.h>
using namespace std;

//----------Set----------

//Define.
#define pb push_back
#define mp make_pair
#define fi first
#define se second

//Typedef.
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<pii> vpii;
typedef vector<pll> vpll;
typedef map<int,int> mii;
typedef map<int,bool> mib;
typedef map<string,int> msi;
typedef map<string,bool> msb;
typedef map<pii,pii> mpp;

//Const.
const int maxn=1e5+5;
const int maxm=1e5+5;
const ll inf=0x3f3f3f3f;
const int mod=998244353;
const ld eps=1e-6;
const ld dl=0.9969;
const int dx[]={2,1,-2};
const int dy[]={1,-1,-1};

//----------Finished----------
map<string,int>level;
int now;
const int m=37;
string Mahjong[150];
string People=" ABCD";
struct node{
	int id,dis;
	inline bool operator <(const node &tmp)const{
		return tmp.dis==dis?tmp.id>id:tmp.dis<dis;
	}
};
string Mah_Jong[50]={
	"",
	"1M","2M","3M","4M","5M","6M","7M","8M","9M",
	"1P","2P","3P","4P","5P","6P","7P","8P","9P",
	"1S","2S","3S","4S","5S","6S","7S","8S","9S",
	"E","S","W","N","B","F","Z",
	"DOUBLE","REVERSE","PASS"
};
inline int Get(int i){
	return (i+3)%4+1;
}
inline void Input(){
	for(int i=1;i<=148;++i){
		cin>>Mahjong[i];
	}
}
int chow[3];
struct Person{
	int next,pres;
	int tot;
	int cnt[50];
	int f[50][5][2][3][3];
	inline int Dist(){
		memset(f,0x3f,sizeof(f));
		f[0][0][0][0][0]=0;
		int x=tot/3;
		for(int i=0;i<34;++i){
			for(int j=0;j<=x;++j){
				for(int k=0;k<=1;++k){
					for(int l=0;l<=2&&l+j<=x;++l){
						for(int g=0;g<=2&&l+j+g<=x;++g){
							if(f[i][j][k][l][g]<=20){
								for(int o=l+g;o<=4;++o){
									int s=f[i][j][k][l][g]+max(0,o-cnt[i+1]);
									int t=o-l-g;
									if(t>=3&&j+l+1<=x){
										f[i+1][j+l+1][k][g][t-3]=min(f[i+1][j+l+1][k][g][t-3],s);
									}
									if(t>=2&&!k){
										f[i+1][j+l][k+1][g][t-2]=min(f[i+1][j+l][k+1][g][t-2],s);
									}
									if(t<=2){
										f[i+1][j+l][k][g][t]=min(f[i+1][j+l][k][g][t],s);
									}
								}
							}
							if(i%9==0||i>=27) break;
						}
						if(i%9==0||i>=27) break;
					}
				}
			}
		}
		return f[34][x][1][0][0];
	}
	inline void AddCard(int s){
		++cnt[s];++tot;
	}
	inline void DelCard(int s){
		--cnt[s];--tot;
	}
	inline int DIST(){
		return Dist();
	}
	inline int Clac(){
		if(cnt[37]){return 37;}
		if(cnt[36]){return 36;}
		if(cnt[35]){return 35;}
		priority_queue<node>q;
		for(int i=1;i<=34;++i){
			if(!cnt[i]) continue;
			DelCard(i);
			q.push(node{i,DIST()});
			AddCard(i);
		}
		int s=q.top().id;
		return s;
	}
	inline void Pong(int s){
		DelCard(s);DelCard(s);
	}
	inline bool CheckPong(int s){
		if(cnt[s]<2) return 0;
		int oldDist=DIST();
		DelCard(s);DelCard(s);
		int newDist=DIST();
		AddCard(s);AddCard(s);
		if(oldDist<=newDist){
			return 0;
		}
		Pong(s);
		return 1;
	}
	inline void Chow(int s1,int s2,int s3){
		chow[0]=s1;chow[1]=s2;chow[2]=s3;
		sort(chow,chow+3);
		DelCard(s2);DelCard(s3);
	}
	inline bool CheckChow(int s){
		if(s>=28) return 0;
		int oldDist=DIST();
		int newDist;
		if(s==1||s==10||s==19){
			int s2=s+1,s3=s+2;
			if(!cnt[s2]||!cnt[s3]) return 0;
			DelCard(s2);DelCard(s3);
			newDist=DIST();
			AddCard(s2);AddCard(s3);
			if(oldDist<=newDist) return 0;
			Chow(s,s2,s3);
			return 1;
		}
		if(s==9||s==18||s==27){
			int s2=s-1,s3=s-2;
			if(!cnt[s2]||!cnt[s3]) return 0;
			DelCard(s2);DelCard(s3);
			newDist=DIST();
			AddCard(s2);AddCard(s3);
			if(oldDist<=newDist) return 0;
			Chow(s,s2,s3);
			return 1;
		}
		for(int i=0;i<3;++i){
			if((s==2||s==11||s==20)&&i==2) continue;
			if((s==8||s==17||s==26)&&i==0) continue;
			int s2=s+dx[i];
			int s3=s+dy[i];
			if(!cnt[s2]||!cnt[s3]) continue;
			DelCard(s2);DelCard(s3);
			newDist=DIST();
			AddCard(s2);AddCard(s3);
			if(oldDist<=newDist) continue;
			Chow(s,s2,s3);
			return 1;
		}
		return 0;
	}
	inline void Debug(int p){
		cout<<"Now,Player "<<People[p]<<" "<<"has these following MahJongs:\n";
		for(int i=1;i<=37;++i){
			for(int j=1;j<=cnt[i];++j){
				cout<<Mah_Jong[i]<<" ";
			}
		}
		cout<<"\n";
	}
}a[5];
inline void Reverse(){
	if(a[1].next==2){
		a[1].next=4;a[2].next=1;a[3].next=2;a[4].next=3;
		a[1].pres=2;a[2].pres=3;a[3].pres=4;a[4].pres=1;
	}
	else{
		a[1].next=2;a[2].next=3;a[3].next=4;a[4].next=1;
		a[1].pres=4;a[2].pres=1;a[3].pres=2;a[4].pres=3;
	}
}
inline void Init(){
	Reverse();
	level["PASS"]=37;level["REVERSE"]=36;level["DOUBLE"]=35;
	level["Z"]=34;level["F"]=33;level["B"]=32;level["N"]=31;level["W"]=30;level["S"]=29;level["E"]=28;
	level["9S"]=27;level["8S"]=26;level["7S"]=25;level["6S"]=24;level["5S"]=23;level["4S"]=22;level["3S"]=21;level["2S"]=20;level["1S"]=19;
	level["9P"]=18;level["8P"]=17;level["7P"]=16;level["6P"]=15;level["5P"]=14;level["4P"]=13;level["3P"]=12;level["2P"]=11;level["1P"]=10;
	level["9M"]=9;level["8M"]=8;level["7M"]=7;level["6M"]=6;level["5M"]=5;level["4M"]=4;level["3M"]=3;level["2M"]=2;level["1M"]=1;
}
inline void TakeUpCard(){
	for(int i=1;i<=52;++i){
		int p=Get(i);
		a[p].AddCard(level[Mahjong[i]]);
		cout<<People[p]<<" IN "<<Mahjong[i]<<"\n";
	}
	now=52;
}
inline void Playing(){
	bool flg=0;
	for(int i=1;now<148;i=a[i].next){
		if(!flg){
			cout<<People[i]<<" IN "<<Mahjong[++now]<<"\n";
			a[i].AddCard(level[Mahjong[now]]);
			if(a[i].DIST()==0){
//				a[i].Debug(i);
				cout<<People[i]<<" SELFDRAWN"<<"\n";
				cout<<People[i]<<" WIN"<<"\n";
				return;
			}
		}
//		a[i].Debug(i);
		flg=0;
		int s=a[i].Clac();
		a[i].DelCard(s);
		if(s==37){
			cout<<People[i]<<" OUT PASS "<<People[a[i].next]<<"\n";
			i=a[i].next;
			continue;
		}
		cout<<People[i]<<" OUT "<<Mah_Jong[s]<<"\n";
		if(s==36){
			Reverse();
			continue;
		}
		if(s==35){
			i=a[i].pres;
			continue;
		}
		for(int j=a[i].next;j!=i;j=a[j].next){
			if(i==j) continue;
			a[j].AddCard(s);
			if(a[j].DIST()==0){
				cout<<People[j]<<" RON"<<"\n";
				cout<<People[j]<<" WIN"<<"\n";
				return;
			}
			a[j].DelCard(s);
		}
		bool fl=0;
		for(int j=a[i].next;j!=i;j=a[j].next){
			if(a[j].CheckPong(s)){
				cout<<People[j]<<" PONG "<<Mah_Jong[s]<<" "<<Mah_Jong[s]<<" "<<Mah_Jong[s]<<"\n";
				i=a[j].pres;flg=1;
				fl=1;break;
			}
		}
		if(fl) continue;
		int j=a[i].next;
		if(a[j].CheckChow(s)){
			cout<<People[j]<<" CHOW "<<Mah_Jong[chow[0]]<<" "<<Mah_Jong[chow[1]]<<" "<<Mah_Jong[chow[2]]<<"\n";
			i=a[j].pres;
			flg=1;
			continue;
		}
	}
	cout<<"DRAW"<<"\n";
}
inline void solve(){
	Init();
	Input();
	TakeUpCard();
	Playing();
}

signed main(){
	int T=1;
	for(;T;--T) solve();
	return 0;
}
```

---

## 作者：suxxsfe (赞：4)

传说中比猪国杀更牛逼的模拟？  
话说这场初赛还打过，当时这个题都没怎么看（  

主要是前几天打 PKUSC 的时候有个判断向听数的题，于是就想到来写这个了  
判断向听的时候用一个 dp，设 $f(i,a,b,p,q,h)$ 表示考虑到第 $i$ 中牌，之前有 $a$ 对 $(i-1,i)$ 的牌（需要补一个 $i+1$ 组成顺子），有 $b$ 个 $i$ 牌（需要补一个 $i+1,i+2$ 组成顺子），一共扔了 $p$ 张牌，一共拿进来了 $q$ 张牌，目前有/没有雀头 的情况，是否可以达成  

转移就是枚举加入（或扔掉）了几张 $i+1$，第 $i+1$ 种牌是否要组成刻子，是否要组成去偷，然后所有的 $b$ 变成 $a$，除去雀头、刻子剩下的牌变成 $b$  
一万、一索、一筒、字牌的转移和别的牌不太相同，只有 $f(i,0,0,p,q,h)$ 的状态可以转移到他们  
技能牌则是必须扔掉，这个可以用限制技能牌一共有 $0$ 张，其他的一共有 $4$ 张来实现，不用单独讨论  

然后显然最后合理的状态是要满足 $p=q$ 的，而这个 $p$（或 $q$） 就是胡牌距离（注意题面里说的胡牌距离是向听数加一）  
由于技能牌的存在，且不考虑七对子，所以最大胡牌距离是 $12$（给你发 $12$ 张技能牌）  
因为一共有 $37$ 种牌，所以最后找最小的 $dis$ 满足 $f(37,0,0,dis,dis,1)=1$  
因为还要找到最大的能打的牌，所以要再记录一个数组表示能达成此状态的前提下，扔掉的牌中最大是多少  

这个 dp 的状态数是 $38\times 5\times 5\times 13\times 13\times 2$，每个状态的转移最多有 $12$（相同的牌一共有 $4$ 张，所以扔掉、添加一共有 $4$ 种情况，再加上有雀头、有刻子、没有雀头或刻子三种情况）  
看起来复杂度不低，但是显然完全跑不满；考虑一共要做多少次这样的 dp，配牌后还剩 $96$ 张牌，这些要判断切什么牌一次、切完判断别人胡不胡这个四次，所以固定有 $480$ 次，而一局种能副露的情况实际非常少，基本不用考虑  
所以每次吃碰、判断是否荣和都只要暴力跑这个 dp 就行，并不需要什么其他的骚操作（  

判断吃碰的时候要把拿出来副露的两张牌从手牌里删掉跑 dp，而不是把要被吃碰的那张牌加进去，否则可能会导致那张加进去的牌和别的牌（不是要副露的那两张）组成面子或雀头  
另外副露了的牌就没用了，直接删了就行不用记录  

然后他甚至不需要存牌山（  
具体细节上用一个 `cardNum` 定义这种牌最多多少张，用 `isBeginCard` 定义这种牌是否是一万、一索、一筒、字牌、技能牌  
然后吃的时候，如果你存所有牌的编号是连着的，不要不要出现拿 89M 去吃 1P，或者吃了字牌这种事（  
所以下一步是不是要出个在向听数最小的情况下要求用进张数最广的打法的题，再下一步是不是要出个考虑役种的题，再下一步是不是要和三个交互库一块打麻将（  

代码只有 5K 多点，甚至比某些数据结构题还短，感觉除了没怎么封装外还挺好看（  

```cpp  
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<assert.h>
const int _nex[2][4]={{1,2,3,0},{3,0,1,2}};
const int *nex=_nex[0];
int order=0;
const char playerName[]={'A','B','C','D'};
const char *cardName[]={
	"",
	"1M","2M","3M","4M","5M","6M","7M","8M","9M",
	"1P","2P","3P","4P","5P","6P","7P","8P","9P",
	"1S","2S","3S","4S","5S","6S","7S","8S","9S",
	"E","S","W","N","B","F","Z",
	"DOUBLE","REVERSE","PASS"
};
const int isBeginCard[]={1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1};
const int cardNum[]={0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0};
#define CARD_TYPE_NUM 37
#define CARD_TYPE_NUM2 34
#define PLAYER_NUM 4
#define MAX_DIS 12
char input[12];
inline int strMatch(const char *s,const char *t){
	for(int i=0,j=0;s[i]||t[j];i++,j++)if(s[i]!=t[j]) return 0;
	return 1;
}
struct Player{
	int dis,id;//max dis: 12
	int t[38];
	inline int getCard(){
		if(scanf("%s",input)==EOF) return 0;
		for(int i=1;i<=CARD_TYPE_NUM;i++)if(strMatch(input,cardName[i])){
			t[i]++;printf("%c IN %s\n",playerName[id],cardName[i]);
			break;
		}
		return 1;
	}
	inline void init(int _id){id=_id;dis=MAX_DIS;}
};
int f[38][5][5][14][14][2][2];
inline void trans(int *t,int i,int a,int b,int p,int q,int h,int dis){
	if(!f[i][a][b][p][q][h][0]) return;
	int *u=f[i][a][b][p][q][h],*_u;
	for(int n,x=std::max(p-dis,-t[i+1]);x+q<=dis&&x+t[i+1]<=cardNum[i+1];x++){//x= num of cards that will be added
		n=t[i+1]+x;
		for(int _h=0;_h+h<2&&2*_h+a+b<=n;_h++)for(int o=0;2*_h+3*o+a+b<=n;o++){
			if(x<0){
				_u=f[i+1][b][n-2*_h-3*o-a-b][p-x][q][h|_h];
				_u[1]=i+1;_u[0]=1;
			}
			else{
				_u=f[i+1][b][n-2*_h-3*o-a-b][p][q+x][h|_h];
				_u[1]=std::max(_u[1],u[1]);_u[0]=1;
			}
		}
	}
}
inline int findCardDp(int *t,int &dis){
	//f...[0]: can reach? f...[1]: the biggest card that be thrown
	//f[i][a][b][p][q][h]: p= num of cards that be thrown q= num of cards that be added h= if thers is a head
	//a= num of (i-1,i) b= num of (i)
	std::memset(f,0,sizeof f);
	f[0][0][0][0][0][0][0]=1;
	for(int i=0;i<CARD_TYPE_NUM;i++)for(int p=0;p<=dis;p++)for(int q=0;q<=dis;q++)for(int h=0;h<2;h++){
		if(isBeginCard[i+1]) trans(t,i,0,0,p,q,h,dis);
		else for(int a=0;a<=4;a++)for(int b=0;a+b<=4;b++) trans(t,i,a,b,p,q,h,dis);
	}
	for(dis=0;dis<=MAX_DIS&&!f[CARD_TYPE_NUM][0][0][dis][dis][1][0];dis++);
	if(dis>12) return 0;
	return f[CARD_TYPE_NUM][0][0][dis][dis][1][1];
}
inline int findCard(Player &p,int &nextPlayer){
	if(p.t[37]) return nextPlayer=nex[nex[p.id]],37;
    else if(p.t[36]) return nex=_nex[order^=1],nextPlayer=nex[p.id],36;
    else if(p.t[35]) return nextPlayer=p.id,35;
    nextPlayer=nex[p.id];
    return findCardDp(p.t,p.dis);
}
inline int ron(Player &p,int card){
	if(p.dis!=1) return 0;
	p.t[card]++;
	int disBackup=p.dis;
	findCardDp(p.t,p.dis);
	if(!p.dis){
		printf("%c RON\n",playerName[p.id]);
		return 1;
	}
	p.t[card]--;p.dis=disBackup;
	return 0;
}
inline int pon(Player &p,int card){
	if(p.t[card]<2) return 0;
	p.t[card]-=2;
	int disBackup=p.dis;
	findCardDp(p.t,p.dis);
	if(p.dis>=disBackup){
		p.dis=disBackup;p.t[card]+=2;
		return 0;
	}
	printf("%c PONG %s %s %s\n",playerName[p.id],cardName[card],cardName[card],cardName[card]);
	return 1;
}
inline int chi(Player &p,int a,int b,int c){
	if(!p.t[a]||!p.t[b]) return 0;
	p.t[a]--;p.t[b]--;
	int disBackup=p.dis;
	findCardDp(p.t,p.dis);
	if(p.dis>=disBackup){
		p.t[a]++;p.t[b]++;p.dis=disBackup;
		return 0;
	}
	if(b>c) std::swap(b,c);
	if(a>b) std::swap(a,b);
	if(b>c) std::swap(b,c);
	if(a>b) std::swap(a,b);
	printf("%c CHOW %s %s %s\n",playerName[p.id],cardName[a],cardName[b],cardName[c]);
	return 1;
}
inline int chi(Player &p,int card){
	int a,b;
	a=card+1;b=card+2;
	if(!isBeginCard[a]&&!isBeginCard[b]&&chi(p,a,b,card)) return 1;
	a=card-1;b=card+1;
	if(!isBeginCard[card]&&!isBeginCard[b]&&chi(p,a,b,card)) return 1;
	a=card-2;b=card-1;
	if(!isBeginCard[card]&&!isBeginCard[b]&&chi(p,a,b,card)) return 1;
	return 0;
}
Player p[4];
inline int ron(int gunner,int c){
	for(int j=nex[gunner];j!=gunner;j=nex[j])
		if(ron(p[j],c)) return 1;
	return 0;
}
inline int pon(int &nextPlayer,int c){
	for(int j=nextPlayer;nex[j]!=nextPlayer;j=nex[j])
		if(pon(p[j],c)) return nextPlayer=j,1;
	return 0;
}
inline int chi(int &nextPlayer,int c){
	if(chi(p[nextPlayer],c)) return 1;
	return 0;
}
int main(){
	for(int i=0;i<PLAYER_NUM;i++) p[i].init(i);
	for(int i=1;i<=13;i++)for(int j=0;j<PLAYER_NUM;j++) p[j].getCard();
	int willGetCard=1;
	for(int i=0,nextPlayer;;i=nextPlayer){
		if(willGetCard&&!p[i].getCard()) break;
		int c=findCard(p[i],nextPlayer);willGetCard=1;
		if(!p[i].dis){
			printf("%c SELFDRAWN\n",playerName[i]);
			break;
		}
		printf("%c OUT %s",playerName[i],cardName[c]);
		p[i].t[c]--;
		if(c==37) printf(" %c\n",playerName[nex[i]]);
		else puts("");
		if(c>CARD_TYPE_NUM2) continue;
		if(ron(i,c)) break;
		if(pon(nextPlayer,c)||chi(nextPlayer,c)) willGetCard=0;
	}
	for(int i=0;i<PLAYER_NUM;i++)if(!p[i].dis) return printf("%c WIN\n",playerName[i]),0;
	puts("DRAW");
	return 0;
}
```  


---

## 作者：fush (赞：3)

[更好的阅读体验](https://fush-git.github.io/2024/12/20/洛谷-P7147题解/)。  
## 前言   
[麻将模拟器](https://www.luogu.com.cn/problem/P7147)     
调了一早上结果发现 DP 中的 $j$ 写成 $i$ 了。      
题目中的和牌距离基本和**向听数**差不多。     
文中的面子指刻子和顺子的统称。   
___   
## 基础操作   
### 定义   
```c++   
#define endl '\n'   
#define FL(a, b, c) for(int a = (b), a##end = (c); a <= a##end; a++)   
#define FR(a, b, c) for(int a = (b), a##end = (c); a >= a##end; a--)   
#define pc putchar   
struct player{   
	int a[20], len;   
	bool pass;   
}p[4];   
int cd[200], top, turn = 1;   
```   
我们用一个 `player` 结构体存一个玩家的信息，分别是玩家手中的牌，牌的数量，是否被 pass。     
`cd` 用来存牌堆，`top` 表示最上面的牌，`turn` 是回合顺序。   
### 牌面存储   
因为直接存储牌是字符，并不利于判断优先级。     
所以我们在输入的时候先转化成优先级，输出时再换回字符。   
```c++   
//main内   
FR(i, top = 148, 1){   
	string s;   
	cin >> s;   
	//转化   
	if(isdigit(s[0]))   
		switch(cd[i] = s[0] ^ 48, s[1]){   
			case 'S':cd[i] += 9;   
			case 'P':cd[i] += 9;   
		}   
	else switch(cd[i] = 28, s[0]){   
			case 'P':cd[i]++;   
			case 'R':cd[i]++;   
			case 'D':cd[i]++;   
			case 'Z':cd[i]++;   
			case 'F':cd[i]++;   
			case 'B':cd[i]++;   
			case 'N':cd[i]++;   
			case 'W':cd[i]++;   
			case 'S':cd[i]++;   
		}   
}   
//优先级->字符   
void outcd(int x){   
	if(x <= 27)cout << (x - 1) % 9 + 1 << ("MPS"[(x - 1) / 9]);   
	else if(x <= 34)cout << ("ESWNBFZ"[x - 28]);   
	else if(x == 35) cout << "DOUBLE";   
	else if(x == 36) cout << "REVERSE";   
	else cout << "PASS";   
}   
```   
### 输出操作   
```c++   
#define in(x, y)pc(x + 'A'), cout << " IN ", outcd(y), pc(endl)   
#define nxt(x) (((x) + turn + 4) % 4)   
#define out(x, y) pc(x + 'A'), cout << " OUT ", outcd(y), (y == 37) && (pc(' '), pc(nxt(x) + 'A')),  pc(endl)   
#define outpeng(x, y) pc(x + 'A'), cout << " PONG ", outcd(y), pc(' '), outcd(y), pc(' '), outcd(y), pc(endl)   
#define outchi(x, y) pc(x + 'A'), cout << " CHOW ", outcd(y), pc(' '), outcd(y + 1), pc(' '), outcd(y + 2), pc(endl)   
void GameOver(int x, int y){   
	if(x == -1)cout << "DRAW", exit(0);   
	pc(x + 'A'), cout << (y ? " RON" : " SELFDRAWN") << endl;   
	pc(x + 'A'), cout << " WIN", exit(0);   
}   
```   
这部分就没什么好说的，注意 pass 的输出特判。   
### 摸牌和删牌   
可以将每个人手中的牌按优先级维护，好判断特殊牌。   
```c++   
//摸牌   
void mopai(int x){   
	if(!top)GameOver(-1, 0);   
	int *a = p[x].a, z = upper_bound(a + 1, a + p[x].len + 1, cd[top]) - a;   
	FR(i, p[x].len, z)a[i + 1] = a[i];   
	a[z] = cd[top--], p[x].len++, in(x, a[z]);   
}   
//出牌   
void delpai(int x, int y){   
	int *a = p[x].a, z = lower_bound(a + 1, a + 1 + p[x].len, y) - a;   
	FL(i, z, --p[x].len)a[i] = a[i + 1];   
}   
```   
## 和牌距离   
我们来看最难的和牌距离部分。   
   
我们定义：     
$dp_{i,j,k,l,g}$ 表示前第 $i$ 种牌中有 $j$ 个面子和 $k$ 个对子，且第 $i - 1$ 种牌开始有 $g$ 个顺子，第 $i$ 种牌开始有 $g$ 个顺子，时的和牌距离。      
$zy_{i,j,k,l,g}$ 表示此时要丢弃的优先级最高牌。   
$nx$ 表示现在能转移的状态的和牌距离，$ny$ 表示需要丢弃的牌。     
    
我们再枚举一个 $q$ 表示需要 $q$ 张第 $i$ 种牌，$r$ 表示除顺子后剩下的。     
   
如果我们剩余的牌能凑出刻子，那么我们就可以转移到 $i+1,j+l+1,k,g,r-3$。     
如果能凑出对子，可以转移到 $i+1,j+l,k,g,r-2$。   
我们也可以开启新的顺子，可以转移到 $i+1,j+l,k,g,r$。   
   
转移（$dp',zy'$ 表示新状态）：   
如果 $nx < dp'$，那么 $dp' \gets nx, zy' \gets ny$。     
如果 $nx = dp',ny > zy'$，那么 $zy' \gets ny$。   
   
具体细节可以看代码。   
```c++   
int sl[40], dp[40][5][2][3][3], zy[40][5][2][3][3];//sl 表示每种牌的数量   
#define zhuanyi(i, j, k, l, g) if(nx < dp[i][j][k][l][g] || (nx == dp[i][j][k][l][g] && ny > zy[i][j][k][l][g])) dp[i][j][k][l][g] = nx, zy[i][j][k][l][g] = ny   
pair<int, int> JuLi(int x){//求和牌距离与要弃的牌，x 表示最后有几个面子   
	memset(dp, 0x3f, sizeof(dp)), memset(zy,-1,sizeof(zy));   
	dp[0][0][0][0][0] = 0;   
	FL(i, 0, 34) FL(j, 0, x) FL(k, 0, 1)    //前第 i 种牌，有 j 个面子，k 个对子   
		FL(l, 0, min(2, x - j)){            //从第 i - 1 种牌开始的 l 个顺子   
			FL(g, 0, min(2, x - l - j))     //从第 i 种牌开始的顺子   
				if(dp[i][j][k][l][g] <= 14){//状态合法   
					FL(q, l + g, 4){   
						int nx = dp[i][j][k][l][g] + max(0, q - sl[i + 1]);  //新的和牌距离   
						int ny = (sl[i + 1] > q ? i + 1 : zy[i][j][k][l][g]);//要打出的牌   
						int r = q - l - g; //剩了几个第 i 种牌   
                        //可以凑出刻子   
						if(r >= 3 && j + l + 1 <= x)zhuanyi(i + 1, j + l + 1, k, g, r - 3);   
                        //可以凑出对子   
						if(r >= 2 && !k)zhuanyi(i + 1, j + l, 1, g, r - 2);   
                        //开启新的顺子   
						if(r <= 2)zhuanyi(i + 1, j + l, k, g, r);   
					}   
                    //字牌不能组成顺子   
					if(i % 9 == 0 || i >= 27) break;   
				}   
			if(i % 9 == 0 || i >= 27) break;   
		}   
	return make_pair(dp[34][x][1][0][0], zy[34][x][1][0][0]);   
}   
pair<int, int> check(int x){//统计除了特殊牌的其他牌面   
	memset(sl, 0, sizeof(sl));   
	int *a = p[x].a, &len = p[x].len;   
	FL(i, 1, len) if(a[i] <= 34) ++sl[a[i]];   
	return JuLi(4 - (14 - len) / 3);   
}   
```   
## 游戏部分   
### 框架部分   
```c++   
//main内部   
FL(i, 1, 13)FL(j, 0, 3)mopai(j);   
int now = 0;   
while(1){   
	if(p[now].pass)p[now].pass = 0, now = nxt(now);   
	else mopai(now), now = chupai(now);   
}   
```   
### 出牌阶段   
```c++   
bool TeShuPai(int x){//没有特殊牌才可能和   
	FL(i, 1, p[x].len)if(p[x].a[i] >= 34)return 0;   
	return 1;   
}   
int chupai(int x){   
	int *a = p[x].a, &len = p[x].len;   
    //有特殊牌直接打   
	if(a[len] == 37)return --len, p[nxt(x)].pass = 1, out(x, 37), nxt(x);   
	if(a[len] == 36)return --len, turn *= -1,  out(x, 36), nxt(x);   
	if(a[len] == 35)return --len, out(x, 35), x;   
	int chu = check(x).second;	//要打出的牌   
	if(chu == -1)GameOver(x, 0);//自摸   
	delpai(x, chu), out(x, chu);   
    //先判断荣和   
	for(int i = nxt(x); i != x; i = nxt(i))   
		if(TeShuPai(i)){   
			p[i].a[++p[i].len] = chu;   
			if(check(i).second == -1)GameOver(i, 1);   
			p[i].len--;   
		}   
	//然后是碰   
	int z = Peng(chu);   
	if(z != -1)return chupai(z);   
	//吃   
	if(Chi(nxt(x), chu))return chupai(nxt(x));   
	return nxt(x);   
}   
```   
特殊牌的优先级最高，有就直接打。     
否则就看一下是不是自摸，不然就打出去。     
荣和的比碰、吃都在前面，但是有截和，注意判断顺序。     
而吃碰后不用摸牌，直接跳到出牌阶段。   
### 碰   
碰就比吃的可能少多了，注意要和牌距离要严格变小才会碰。   
```c++   
int Peng(int y){   
	FL(i, 0, 3){   
		int z = check(i).first;//原本的和牌距离   
		if((sl[y] -= 2) >= 0)  //至少要两张   
			if(z > JuLi(3 - (14 - p[i].len) / 3).first)//和牌距离严格变小   
				return outpeng(i, y), delpai(i, y), delpai(i, y), i;   
	}   
	return -1;   
}   
```   
### 吃   
只有下家能吃，但有三种可能。   
```c++   
bool Chi(int x, int y){//判断吃，注意判断顺序，优先级越大越好。   
	if(y > 27)return 0;   
	int z = check(x).first;   
	if((y - 1) % 9 <= 6 && sl[y + 1] && sl[y + 2]){   
		sl[y + 1]--, sl[y + 2]--;   
		if(z > JuLi(3 - (14 - p[x].len) / 3).first)   
			return outchi(x, y), delpai(x, y + 1), delpai(x, y + 2), 1;   
		++sl[y + 1], ++sl[y + 2];   
	}   
	if(y % 9 > 1 && y % 9 != 0 && sl[y - 1] && sl[y + 1]){   
		sl[y - 1]--, sl[y + 1]--;   
		if(z > JuLi(3 - (14 - p[x].len) / 3).first)   
			return outchi(x, y - 1), delpai(x, y - 1), delpai(x, y + 1), 1;   
		++sl[y - 1], ++sl[y + 1];   
	}   
	if((y - 1) % 9 >= 2 && sl[y - 1] && sl[y - 2]){   
		sl[y - 1]--, sl[y - 2]--;   
		if(z > JuLi(3 - (14 - p[x].len) / 3).first)   
			return outchi(x, y - 2), delpai(x, y - 1), delpai(x, y - 2), 1;   
		++sl[y - 1], ++sl[y - 2];   
	}   
	return 0;   
}   
```   
## 代码   
**大功告成！**     
[代码（约5KB）](https://www.luogu.com.cn/paste/wlbbbu1p)

---

## 作者：cunzai_zsy0531 (赞：3)

[题面](https://www.luogu.com.cn/problem/P7147)

做完 pkusc2022 day2t3 雀圣之后跑来做这题。

首先我们考虑雀圣那题。那个题是说给你一副 $13$ 张的手牌，让你算向听数。设 $dp[i][j][0/1][p1][p2][up][dn]=0/1$ 表示考虑到 $i$ 花色第 $j$ 张牌，是否已经有雀头，上张牌剩下 $p1$ 张，这张牌剩下 $p2$ 张，已经加了 $up$ 张，已经扔了 $dn$ 张的状态是否可以达到。枚举当前这张牌加几张、删几张，是否作为雀头，能作为刻子就一定作为刻子，和前两张牌组成顺子，然后转移一下。每一种花色转移完之后清掉除 $p1=p2=0$ 之外的所有状态即可。

有了这个 dp 这题剩下的就不难了。特殊牌的话就先处理一下，`PASS` 就多跳一个，`DOUBLE` 和 `REVERSE` 就定义一个 $delta=1/-1$，每次加 $delta$ 表示顺/逆时针即可。进入打牌阶段之后，对每个玩家记一个当前和牌距离。打牌就是每次枚举打哪一张，dp算一下取一个和牌距离最短且最大的，打出去之后再对另外的玩家判一下碰和吃即可。虽然复杂度比较高，但是看起来可以过。

code(8.3k)：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<map>
#define memset __builtin_memset
#define mp std::make_pair
#define fi first
#define se second
typedef std::pair<int,int> pii;
std::map<char,int> ms;
inline void chkmin(int &a,const int &b){if(b<a)a=b;}
inline char cc(int x){return (char)(x+'A');}
inline char cn(int x){return (char)(x+'0');}
char nam[8]={'0','E','S','W','N','B','F','Z'},nam1[3]={'M','P','S'};
int limt[5]={9,9,9,7,3};
std::string nam2[4]={"","PASS","REVERSE","DOUBLE"};
inline void init(){
	ms['E']=1,ms['S']=2,ms['W']=3,ms['N']=4,ms['B']=5,ms['F']=6,ms['Z']=7;
}
inline std::string f(pii x){
	std::string res="";
	if(x.fi<=2) res+=cn(x.se),res+=nam1[x.fi];
	else if(x.fi==3) res+=nam[x.se];
	else res=nam2[x.se];
	return res;
}
int a[4][5][10],to[4];
inline void print_in(int o,const char *in){printf("%c IN %s\n",cc(o),in);}
inline void print_out(int o,const char *out,int oo){
	if(out[0]=='P') printf("%c OUT %s %c\n",cc(o),out,cc(oo));
	else printf("%c OUT %s\n",cc(o),out);
}
inline void print_pong(int o,const char *pong){printf("%c PONG %s %s %s\n",cc(o),pong,pong,pong);}
inline void print_chow(int o,const char *chow1,const char *chow2,const char *chow3){printf("%c CHOW %s %s %s\n",cc(o),chow1,chow2,chow3);}
inline void print_selfdrawn(int o){printf("%c SELFDRAWN\n",cc(o));}
inline void print_ron(int o){printf("%c RON\n",cc(o));}
inline void print_win(int o){printf("%c WIN\n",cc(o));}
inline void rd(int o,const char *in){
	if(in[0]=='P') a[o][4][1]++;
	else if(in[0]=='R') a[o][4][2]++;
	else if(in[0]=='D') a[o][4][3]++;
	else if(in[0]>='1'&&in[0]<='9'){
		int tmp;
		if(in[1]=='M') tmp=0;else if(in[1]=='P') tmp=1;else tmp=2;
		a[o][tmp][in[0]-'0']++;
	}
	else a[o][3][ms[in[0]]]++;
}
inline int findans(int a[5][10],bool flag=0){
	static bool dp[6][10][2][3][3][14][13];
	memset(dp,0,sizeof dp);
	dp[0][0][0][0][0][0][0]=1;
	for(int o=0;o<=4;++o){
		for(int i=1;i<=limt[o];++i){
			for(int qt=0;qt<=1;++qt)
			for(int p1=0;p1<=2;++p1)
			for(int p2=p1;p2<=2;++p2)
			for(int up=0;up<=13;++up)
			for(int dn=0;dn<=12;++dn){
				if(!dp[o][i-1][qt][p1][p2][up][dn]) continue;
				//不加不减
				int now=a[o][i];
				//雀头 
				if(o<=3&&!qt&&now>=2){
					now-=2;
					if(!p1) dp[o][i][1][p2][now][up][dn]=1;
					if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][1][p2-1][now-1][up][dn]=1;
					if(o<=2&&p1==2&&p2>=2&&now>=2) dp[o][i][1][p2-2][now-2][up][dn]=1;
					now+=2;
				}
				//是否有刻子 
				if(o<=3&&now>=3){
					now-=3;
					if(!p1) dp[o][i][qt][p2][now][up][dn]=1;
					if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][qt][p2-1][now-1][up][dn]=1;	
				}
				else{
					if(!p1) dp[o][i][qt][p2][now][up][dn]=1;
					if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][qt][p2-1][now-1][up][dn]=1;
					if(o<=2&&p1==2&&p2>=2&&now>=2) dp[o][i][qt][p2-2][now-2][up][dn]=1;
				}
				for(int j=1;j<=4-a[o][i]&&up+j<=13;++j){//加 
					now=a[o][i]+j;
					if(o<=3&&!qt&&now>=2){
						now-=2;
						if(!p1) dp[o][i][1][p2][now][up+j][dn]=1;
						if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][1][p2-1][now-1][up+j][dn]=1;
						if(o<=2&&p1==2&&p2>=2&&now>=2) dp[o][i][1][p2-2][now-2][up+j][dn]=1;
						now+=2;
					}
					if(o<=3&&now>=3){
						now-=3;
						if(!p1) dp[o][i][qt][p2][now][up+j][dn]=1;
						if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][qt][p2-1][now-1][up+j][dn]=1;	
					}
					else{
						if(!p1) dp[o][i][qt][p2][now][up+j][dn]=1;
						if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][qt][p2-1][now-1][up+j][dn]=1;
						if(o<=2&&p1==2&&p2>=2&&now>=2) dp[o][i][qt][p2-2][now-2][up+j][dn]=1;
					}
				}
				for(int j=1;j<=a[o][i]&&dn+j<=12;++j){//减 
					now=a[o][i]-j;
					if(o<=3&&!qt&&now>=2){
						now-=2;
						if(!p1) dp[o][i][1][p2][now][up][dn+j]=1;
						if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][1][p2-1][now-1][up][dn+j]=1;
						if(o<=2&&p1==2&&p2>=2&&now>=2) dp[o][i][1][p2-2][now-2][up][dn+j]=1;
						now+=2;
					}
					if(o<=3&&now>=3){
						now-=3;
						if(!p1) dp[o][i][qt][p2][now][up][dn+j]=1;
						if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][qt][p2-1][now-1][up][dn+j]=1;	
					}
					else{
						if(!p1) dp[o][i][qt][p2][now][up][dn+j]=1;
						if(o<=2&&p1==1&&p2>=1&&now>=1) dp[o][i][qt][p2-1][now-1][up][dn+j]=1;
						if(o<=2&&p1==2&&p2>=2&&now>=2) dp[o][i][qt][p2-2][now-2][up][dn+j]=1;
					}
				} 
			}
		}
		for(int qt=0;qt<=1;++qt)
		for(int up=0;up<=13;++up)
		for(int dn=0;dn<=12;++dn)
			dp[o+1][0][qt][0][0][up][dn]=dp[o][limt[o]][qt][0][0][up][dn];
	}
	for(int ans=0;ans<=12;++ans)
		if(dp[5][0][1][0][0][ans+flag][ans]) return ans+flag;
}
inline pii findout(int o){
	for(int i=1;i<=3;++i)
		if(a[o][4][i]) return --a[o][4][i],mp(4,i);
	int res=13;pii ans;
	for(int oo=3;oo>=0;--oo)
		for(int i=limt[oo];i;--i){
			if(!a[o][oo][i]) continue;
			a[o][oo][i]--;int tmp;
			if((tmp=findans(a[o],1))<res) res=tmp,ans=mp(oo,i);
			a[o][oo][i]++;
		}
	return --a[o][ans.fi][ans.se],to[o]=res,ans;
}
inline bool drawn(int a[5][10]){
	if(a[4][1]||a[4][2]||a[4][3]) return 0;
	int b[5][10];
	for(int oo=0;oo<=3;++oo)
	for(int ii=1;ii<=limt[oo];++ii){
		for(int ooo=0;ooo<=3;++ooo)for(int iii=1;iii<=limt[ooo];++iii)b[ooo][iii]=a[ooo][iii];
		if(b[oo][ii]<2) continue;
		b[oo][ii]-=2;bool ok=1;
		for(int o=0;o<=3;++o){
			for(int i=1;i<=limt[o];++i){
				if(b[o][i]>=3) b[o][i]-=3;
				if(o==3&&b[o][i]){ok=0;break;}
				while(b[o][i]){
					if(i>7||!b[o][i+1]||!b[o][i+2]){ok=0;break;}
					--b[o][i],--b[o][i+1],--b[o][i+2];
				}
				if(!ok) break;
			}
			if(!ok) break;
		}
		if(ok) return 1;
	}
	return 0;
} 
inline bool ron(int o,pii x){
	a[o][x.fi][x.se]++;
	bool ans=drawn(a[o]);
	a[o][x.fi][x.se]--;
	return ans;
}
inline bool pong(int o,pii x){
	if(a[o][x.fi][x.se]<2) return 0;
	a[o][x.fi][x.se]-=2;
	int now=findans(a[o]);
	if(now<to[o]) return to[o]=now,1;
	return a[o][x.fi][x.se]+=2,0;
}
inline int chow(int o,pii x){
	if(x.se<=7&&a[o][x.fi][x.se+1]&&a[o][x.fi][x.se+2]){
		a[o][x.fi][x.se+1]--,a[o][x.fi][x.se+2]--;
		int now=findans(a[o]);
		if(now<to[o]) return to[o]=now,1;
		a[o][x.fi][x.se+1]++,a[o][x.fi][x.se+2]++;
	}
	if(x.se<=8&&x.se>=2&&a[o][x.fi][x.se-1]&&a[o][x.fi][x.se+1]){
		a[o][x.fi][x.se-1]--,a[o][x.fi][x.se+1]--;
		int now=findans(a[o]);
		if(now<to[o]) return to[o]=now,2;
		a[o][x.fi][x.se-1]++,a[o][x.fi][x.se+1]++;
	}
	if(x.se>=3&&a[o][x.fi][x.se-2]&&a[o][x.fi][x.se-1]){
		a[o][x.fi][x.se-2]--,a[o][x.fi][x.se-1]--;
		int now=findans(a[o]);
		if(now<to[o]) return to[o]=now,3;
		a[o][x.fi][x.se-2]++,a[o][x.fi][x.se-1]++;
	}
	return 0;
}
int main(){
//	freopen("a.in","r",stdin);freopen("a.out","w",stdout);
//	return system("fc P7147_2.out data.out"),0;
#ifdef LOCAL
	freopen("29.in","r",stdin);
//	freopen("a.out","w",stdout);
#endif
	init();
	int o=0,delta=1,Cnt=52;
	while(Cnt--){
		char in[10];scanf("%s",in);
		print_in(o,in);rd(o,in);
		o=(o+delta+4)%4;
	}
	for(int pp=0;pp<=3;++pp){
		int res=13;
		for(int oo=0;oo<=3;++oo)
			for(int i=1;i<=limt[oo];++i)
				++a[pp][oo][i],chkmin(res,findans(a[pp])+1),--a[pp][oo][i];
		to[pp]=res;
	}
	Cnt=96;bool flag=0;int win=-1;
	while(Cnt--){
		int ff=1;char in[10];
		if(!flag){
			scanf("%s",in);
			print_in(o,in);rd(o,in);	
		}
		else ++Cnt,flag=0;
		if(drawn(a[o])){print_selfdrawn(o),win=o;break;}
		pii res=findout(o);
		print_out(o,f(res).c_str(),(o+delta*ff+4)%4);
		if(res.fi==4){
			if(res.se==2) delta*=-1;
			else if(res.se==3) ff=0;
			else o=(o+delta*ff+4)%4;
			o=(o+delta*ff+4)%4;
			continue;
		}
		if(res.fi<=3){
			for(int nn=(o+delta+4)%4;nn!=o;nn=(nn+delta+4)%4)
				if(ron(nn,res)){print_ron(nn),win=nn;break;}
			if(win!=-1) break;
			bool jump=0;
			for(int nn=0;nn<=3;++nn)
				if(nn!=o&&pong(nn,res)){print_pong(nn,f(res).c_str()),o=nn,flag=1,jump=1;break;}
			if(jump) continue;
		}
		if(res.fi<=2){
			int tmp;
			if(tmp=chow((o+delta+4)%4,res)){
				o=(o+delta+4)%4,flag=1;
				if(tmp==1) print_chow(o,f(mp(res.fi,res.se)).c_str(),f(mp(res.fi,res.se+1)).c_str(),f(mp(res.fi,res.se+2)).c_str());
				else if(tmp==2) print_chow(o,f(mp(res.fi,res.se-1)).c_str(),f(mp(res.fi,res.se)).c_str(),f(mp(res.fi,res.se+1)).c_str());
				else print_chow(o,f(mp(res.fi,res.se-2)).c_str(),f(mp(res.fi,res.se-1)).c_str(),f(mp(res.fi,res.se)).c_str());
				continue;
			}
		}
		o=(o+delta*ff+4)%4;
	}
	if(win==-1) puts("DRAW");
	else print_win(win);
	return 0;
}
```

---

## 作者：myster1ous (赞：1)

## 题目描述

细节非常多，大意就是给定一个麻将规则，给定牌山，让你模拟四个人机的游戏过程。

默认读者已经知道吃、碰、和牌的定义。

一些细节的规则：

- **没有杠**，这为我们大大简化了题目；
- **没有特殊的牌型**，所有和牌都符合最基本的麻将规则； 
- 增加了跳过、翻转和双重回合三种特殊牌；
- **特殊牌不可碰，更不能吃**，有特殊牌的情况下无法和牌； 
- **没有一炮双响**，如果两个人同时荣和，只有从上一名出牌玩家开始，沿回合进行顺序的第一名能荣和的玩家才能荣和。

题面定义了**和牌距离**，这个定义是所有人机操作的基础：

- 如果手牌和副露共有 $13$ 张，那么和牌距离就是最小的 $x$ 使得存在一种在手牌中加入 $x$ 张牌，去掉 $x - 1$ 张牌后就能和牌**且每种牌不超过四个**（不包括副露）的方案。
- 如果手牌和副露共有 $13$ 张，那么和牌距离就是最小的 $x$ 使得存在一种在手牌中加入 $x$ 张牌，去掉 $x$ 张牌后就能和牌**且每种牌不超过四个**（不包括副露）的方案。

人机们的吃、碰都只会在**和牌距离严格减小**的时候进行。\
人机们每回合出的牌都是能使**和牌距离减少最多的牌**。

人机出牌的小细节：
- 有特殊牌先打特殊牌，按照跳过 `PASS`、反转 `REVERSE`、双重回合 `DOUBLE` 的顺序打，`PASS` 一定指定下家。
- 如果有多重吃法都可以使得和牌距离严格减小，那么**只会优先选取数字较大的吃法**。
- 如果既能吃，也能碰，那么**优先碰**，如果碰不能使和牌距离减小，再考虑吃。
- 如果每回合出牌的时候有多重方案都可以使和牌距离减小得最多，那么以红中 `Z`、发财 `F`、白板 `B`、北风 `N`、西风 `W`、南风 `S`、东风 `E`、九条 `9S` 到一条 `1S`、九饼 `9P` 到一饼 `1P`、九万 `9M` 到一万 `1M` 的优先顺序出牌。

## 题目分析

首先，这道题的细节非常的多，我们可以考虑分而治之，把庞大的题目分解成几个小的部分逐个击破。

我们先将整个流程分为三步：

- 读入牌山。
- 分发初始手牌。
- 开始游戏。

其中前两个都没有任何细节，而第三个还是有些复杂，因此我们再将第三个步骤分解：

- 循环进入每个人的回合
- 摸牌。
- 如果有特殊牌，优先打出。
- 否则，对打出每一张牌的情况都计算和牌距离，选择最合适的那一张打出。
- 判断荣和。
- 判断碰。注意荣和优先级大于碰，碰优先级大于吃。
- 判断吃。注意吃只能下家吃本家的牌，本家只能吃上家的牌。

这样整个问题就被我们成功的分解成了很多个小的步骤，可是还剩下一个最大的问题：

## 如何计算和牌距离？

这道题的重要难点就是这点，使用动态规划就可以解决。

我们定义 `dp[i][j][k][x][y]`：

- 第一维 $i(0 \leqslant i < 34)$ 表示当前处理到了第 $i$ 种牌；
- 第二维 $j(0 \leqslant j \leqslant 4)$ 表示当前已经有了 $j$ 个面子（刻字和顺子）；
- 第三维 $k(0 \leqslant k \leqslant 1)$ 表示当前是否已经有雀头（对子）；  
- 第四维 $x(0 \leqslant x \leqslant 2)$ 表示当前已经有 $x$ 个已经组成形如 `3M 4M` 的半顺子；
- 第五维 $y(0 \leqslant y \leqslant 2)$ 表示当前已经有 $y$ 个单牌，正准备形成“半顺子”。

注：因为如果一个牌有三个相同的顺子那么不如直接定义为三个刻子，所以 $x,y$ 最高到 $2$（一杯口）。

注：同时每一个 $x,y,j$ 都是独立的面子，所以 $x+y+j \leqslant 4$。

初始条件：`dp[0][0][0][0][0] = 0`。

对于状态转移，我们枚举 $c$ 表示对于这第 $i$ 种牌我们取多少个，$c$ 必须至少为 $x + y$ 因为这些 $x + y$ 单牌和半顺子都需要靠第 $i$ 种牌来形成下一阶段的顺子，而这些都是从第 $i - 1$ 种牌和（对于半顺子）第 $i - 2$ 种牌组合而成的。 

然后如果还有空余的第 $i$ 种牌，那么就考虑让它们成为雀头、刻子。

转移的代价就是 $c$ 减去当前的手牌中第 $i$ 种牌的个数（非负，和 $0$ 取 $\max$）。

伪代码：

$\small\textbf{function }\texttt{dist}(\texttt{card}): $ \
$\small\quad \textbf{declare }\texttt{dp}[35][5][2][5][5] $\
$\small\quad \textbf{declare }\texttt{n} \textbf{ as }\lfloor\frac{\text{length of }\texttt{card}}{3}\rfloor$\
$\small\quad \textbf{fill } \texttt{dp} \textbf{ with } \texttt{infinity}$\
$\small\quad \textbf{for }\texttt{i}\textbf{ as } \texttt{state of dp}$\
$\small\quad\quad \textbf{for }\texttt{j}\textbf{ as } \texttt{state of dp}$\
$\small\quad\qquad \textbf{for }\texttt{k}\textbf{ as } \texttt{state of dp}$\
$\small\quad\qquad\quad \textbf{for }\texttt{x}\textbf{ as } \texttt{state of dp}$\
$\small\quad\qquad\qquad \textbf{for }\texttt{y}\textbf{ as } \texttt{state of dp}$\
$\small\quad\qquad\qquad\quad \textbf{if }\texttt{dp}[\texttt{i}][\texttt{j}][\texttt{k}][\texttt{x}][\texttt{y}] \textbf{ is not } \texttt{infinity}$\
$\small\quad \qquad\quad\quad\qquad \textbf{for } \texttt{c} \textbf{ satisfy }\texttt{x} + \texttt{y}\leqslant\texttt{c} \leqslant 4$\
$\small\quad\qquad \qquad \qquad\quad \textbf{declare }\texttt{l} \textbf{ as }\texttt{c} - \texttt{x} - \texttt{y}$\
$\small\quad\qquad \qquad\quad \qquad \textbf{declare } \texttt{w} \textbf{ as } \texttt{dp}[\texttt{i}][\texttt{j}][\texttt{k}][\texttt{x}][\texttt{y}] + \max(0,\texttt{c} - \text{count of card }\texttt{i}\text{ in }\texttt{card})$\
$\small\quad\qquad \qquad \qquad\quad \textbf{update }\texttt{dp}[\texttt{i}+1][\texttt{j}+\texttt{x}][\texttt{k}][\texttt{y}][\texttt{c}] \textbf{ with } \texttt{w}$\
$\small\quad\qquad \qquad\quad\qquad \textbf{update }\texttt{dp}[\texttt{i}+1][\texttt{j}+\texttt{x}][1][\texttt{y}][\texttt{c}-2] \textbf{ with } \texttt{w} \textbf{ if } \texttt{k} = 0 \textbf{ and } \texttt{c} \geqslant 2$\
$\small\quad\qquad \qquad \quad\qquad \textbf{update }\texttt{dp}[\texttt{i}+1][\texttt{j}+\texttt{x}+1][\texttt{k}][\texttt{y}][\texttt{c}-3] \textbf{ with } \texttt{w} \textbf{ if } \texttt{j}+\texttt{x} < \texttt{n} \textbf{ and } \texttt{c} \geqslant 3$\
$\small\quad \qquad\qquad\quad \textbf{break if }\text{card }\texttt{i} \texttt{ is } "\text{9M}","\text{9S}","\text{9P}" \textbf{ or } \text{card }\texttt{i} \text{ isn't number}$\
$\small\quad \qquad\quad\quad \textbf{break if }\text{card }\texttt{i} \texttt{ is } "\text{9M}","\text{9S}","\text{9P}" \textbf{ or } \text{card }\texttt{i} \text{ isn't number}$\
$\small\quad\textbf{return }\texttt{dp}[34][\texttt{n}][1][0][0]$

有了这个函数之后，整个过程中还剩下一个略微难的步骤：判断吃牌，不难发现吃牌一共就三种情况：

- 形如打出 `4M`，被 `3M ~ 5M` 吃。
- 形如打出 `4M`，被 `2M 3M ~` 吃。
- 形如打出 `4M`，被 `~ 5M 6M` 吃。

由于吃优先吃大的，所以第三种优先于第一种，第一种优先于第二种。

判断吃的伪代码：

$\textbf{function }\texttt{trychow}(\texttt{card}):$\
$\quad\textbf{return false if }\texttt{card} \text{ is not number card} $\
$\quad\textbf{if }\text{number of }\texttt{card} \textbf{ is not }8 \textbf{ or } 9:$\
$\qquad\textbf{if }\text{count of }(\texttt{card} + 1) \geqslant 1 \textbf{ and }\text{count of }(\texttt{card} + 2) \geqslant 1:$\
$\qquad\quad\textbf{if }\texttt{dist}(\texttt{nowcard})>\texttt{dist}(\texttt{nowcard} \text{ remove } \texttt{card}+1,\texttt{card}+2):$\
$\qquad\qquad\textbf{return true}$\
$\quad\textbf{if }\text{number of }\texttt{card} \textbf{ is not }1 \textbf{ or }9:$\
$\qquad\textbf{if }\text{count of }(\texttt{card} + 1) \geqslant 1 \textbf{ and }\text{count of }(\texttt{card} - 1) \geqslant 1:$\
$\qquad\quad\textbf{if }\texttt{dist}(\texttt{nowcard})>\texttt{dist}(\texttt{nowcard} \text{ remove } \texttt{card}-1,\texttt{card}+1):$\
$\qquad\qquad\textbf{return true}$\
$\quad\textbf{if }\text{number of }\texttt{card} \textbf{ is not }1 \textbf{ or }2:$\
$\qquad\textbf{if }\text{count of }(\texttt{card} - 1) \geqslant 1 \textbf{ and }\text{count of }(\texttt{card} - 2) \geqslant 1:$\
$\qquad\quad\textbf{if }\texttt{dist}(\texttt{nowcard})>\texttt{dist}(\texttt{nowcard} \text{ remove } \texttt{card}-1,\texttt{card}-2):$\
$\qquad\qquad\textbf{return true}$\
$\quad\textbf{return false}$

剩下的都不太难，直接上完整代码：

```cpp
#include <bits/stdc++.h>
#define int long long
std::deque<std::string> allcard({
    "1M", "2M", "3M", "4M", "5M", "6M", "7M", "8M", "9M",
    "1P", "2P", "3P", "4P", "5P", "6P", "7P", "8P", "9P",
    "1S", "2S", "3S", "4S", "5S", "6S", "7S", "8S", "9S",
    "E", "S", "W", "N", "B", "F", "Z", "PASS", "REVERSE", "DOUBLE"
});
int mappings(std::string card) {
    for (int i = 0; i < allcard.size(); i++)
        if (allcard[i] == card) return i; return -1;
}
bool compare(std::string a, std::string b) { return mappings(a) < mappings(b); }
struct Simulator {
    struct Cardheap {
        Simulator* simulator;
        std::deque<std::string> deque;
        Cardheap(Simulator* sim) {deque.clear(); simulator = sim; }
        void addcard(std::string card) {deque.push_back(card); }
        std::string getcard() {
            if (deque.empty()) {
                std::cout << "DRAW\n";
                std::exit(0);
            }
            std::string ret = deque.front();
            deque.pop_front(); return ret;
        }
    } *heap;
    struct Player {
        struct Handcard {
            std::deque<std::string> hand;
            std::deque<std::tuple<std::string, std::string, std::string>> showns;
            Handcard() {hand.clear(); }
            void sort() { std::sort(hand.begin(), hand.end(), compare); }
            int windistance() {
                static int dp[40][5][2][5][5];
                memset(dp, 0x3f, sizeof(dp));
                dp[0][0][0][0][0] = 0;
                int xxx = hand.size() / 3;
                for (int i = 0; i < 34; i++) {
                    int has = 0;
                    for (auto j : hand) has += (mappings(j) == i);
                    for (int j = 0; j <= xxx; j++)
                        for (int k = 0; k < 2; k++)
                            for (int x = 0; x <= 2 && x + j <= xxx; x++) {
                                for (int y = 0; y <= 2 && x + j + y <= xxx; y++) {
                                    if (dp[i][j][k][x][y] <= 20)
                                        for (int choose = y + x; choose <= 4; choose++) {
                                            int l = choose - y - x;
                                            int nw = dp[i][j][k][x][y] + std::max(0ll, choose - has);
                                            if (l <= 2) dp[i + 1][j + x][k][y][l] = std::min(dp[i + 1][j + x][k][y][l], nw);
                                            if (l >= 2 && !k) dp[i + 1][j + x][1][y][l - 2] = std::min(dp[i + 1][j + x][1][y][l - 2], nw);
                                            if (l >= 3 && j + x < xxx) dp[i + 1][j + x + 1][k][y][l - 3] = std::min(dp[i + 1][j + x + 1][k][y][l - 3], nw);
                                        }
                                    if ((i) % 9 == 0 || (i) >= 27) break;
                                }
                                if ((i) % 9 == 0 || (i) >= 27) break;
                            }
                }
                return dp[34][xxx][1][0][0];
            }
            Handcard* outcard(std::string card) {
                Handcard *news = new Handcard();
                news->showns = showns;
                bool shown = false;
                for (auto i : hand)
                    if (i == card && !shown) shown = true;
                    else news->hand.push_back(i);
                return news; 
            }
            bool have(std::string card) {
                for (auto i : hand) if (i == card) return true;
                return false;
            }
            int count(std::string card) {
                int cnt = 0;
                for (auto i : hand) if (i == card) cnt += 1;
                return cnt;
            }
            // void printout() {
                // sort();
                // for (auto i : hand) std::cout << i << " "; std::cout << " | ";
                // for (auto [u, v, w] : showns) std::cout << "[" << u << ", " << v << ", " << w << "] ";
                // std::cout << windistance() << " (" << hand.size() << ")" << std::endl;
            // }
        } *handcard; 
        bool passed; int id;
        Simulator* simulator;
        Player(Simulator *sim, int idx): passed(0), simulator(sim), id(idx)
            { handcard = new Handcard(); }
        void getcard(std::string card) {
            handcard->hand.push_back(card); 
            std::cout << char('A' + id) << " IN " << card << std::endl;
        }    
        // void printout() {
            // handcard->sort();
            // std::cout << "Player " << char('A' + id) << ": ";
            // handcard->printout();
        // }
        bool canron(std::string card) {
            handcard->hand.push_back(card);
            if (handcard->windistance() == 0) {
                handcard->sort()/*handcard->printout()*/;
                return true;
            }
            handcard->hand.pop_back(); 
            return false;
        }
        bool canpong(std::string card) {
            if (handcard->count(card) >= 2) 
                if (handcard->outcard(card)->outcard(card)->windistance() < handcard->windistance()) {
                    handcard = handcard->outcard(card)->outcard(card);
                    handcard->showns.push_back(std::make_tuple(card, card, card));
                    simulator->now = ((id - simulator->dir) % 4 + 4) % 4; return true;
                }
            return false;
        }
        void trychow(std::string card) {
            if (mappings(card) >= 27) return;
            int map = mappings(card) % 9 + 1;
            char type = card[1];
            std::deque<std::string> num;
            num.push_back("114514");
            for (int i = 1; i <= 9; i++)
                num.push_back(std::to_string(i) + (type));
            if (map != 8 && map != 9)
                if (handcard->outcard(num[map + 2])->outcard(num[map + 1])->windistance() < handcard->windistance()) {
                    handcard = handcard->outcard(num[map + 1])->outcard(num[map + 2]);
                    handcard->showns.push_back(std::make_tuple(num[map + 2], num[map + 1], num[map]));
                    std::cout << char('A' + id) << " CHOW " << num[map] << " " << num[map + 1] << " " << num[map + 2] << "\n";
                    simulator->now = ((id - simulator->dir) % 4 + 4) % 4; 
                }
            if (map != 1 && map != 9)
                if (handcard->outcard(num[map - 1])->outcard(num[map + 1])->windistance() < handcard->windistance()) {
                    handcard = handcard->outcard(num[map - 1])->outcard(num[map + 1]);
                    handcard->showns.push_back(std::make_tuple(num[map - 1], num[map], num[map + 1]));
                    std::cout << char('A' + id) << " CHOW " << num[map - 1] << " " << num[map] << " " << num[map + 1] << "\n";
                    simulator->now = ((id - simulator->dir) % 4 + 4) % 4; 
                }
            if (map != 1 && map != 2)
                if (handcard->outcard(num[map - 2])->outcard(num[map - 1])->windistance() < handcard->windistance()) {
                    handcard = handcard->outcard(num[map - 1])->outcard(num[map - 2]);
                    handcard->showns.push_back(std::make_tuple(num[map - 2], num[map - 1], num[map]));
                    std::cout << char('A' + id) << " CHOW " << num[map - 2] << " " << num[map - 1] << " " << num[map] << "\n";
                    simulator->now = ((id - simulator->dir) % 4 + 4) % 4; 
                } 
        }
        void startround() {
            if (passed) return passed = false, void();
            if (handcard->hand.size() % 3 == 1) getcard(simulator->heap->getcard());
            // for (int i = 0; i < 4; i++) simulator->player[i]->printout();
            if (handcard->windistance() == 0) {
                std::cout << char('A' + id) << " SELFDRAWN\n";
                std::cout << char('A' + id) << " WIN\n";
                std::exit(0); 
            }
            handcard->sort();
            if (handcard->have("PASS")) {
                handcard = handcard->outcard("PASS");
                simulator->player[simulator->next()]->passed = true;
                std::cout << char('A' + id) << " OUT PASS " << char('A' + simulator->next()) << "\n"; 
            } else if (handcard->have("REVERSE")) {
                handcard = handcard->outcard("REVERSE");
                simulator->dir = -simulator->dir;
                std::cout << char('A' + id) << " OUT REVERSE\n";
            } else if (handcard->have("DOUBLE")) {
                handcard = handcard->outcard("DOUBLE");
                std::cout << char('A' + id) << " OUT DOUBLE\n";
                startround();
            } else {
                int mindistance = 114514;
                std::string mincard;
                for (auto i : handcard->hand) {
                    int wind = handcard->outcard(i)->windistance();
                    if (wind <= mindistance) {
                        mindistance = wind;
                        mincard = i;
                    } 
                }
                handcard = handcard->outcard(mincard);
                std::cout << char('A' + id) << " OUT " << mincard << "\n";
                for (int i = simulator->next(); i != id; i = ((i + simulator->dir) % 4 + 4) % 4)  
                    if (simulator->player[i]->canron(mincard)) {
                        std::cout << char('A' + i) << " RON\n";
                        std::cout << char('A' + i) << " WIN\n";
                        std::exit(0);
                    }
                bool ponged = false;
                for (int i = simulator->next(); i != id; i = ((i + simulator->dir) % 4 + 4) % 4)
                    if (simulator->player[i]->canpong(mincard)) 
                        std::cout << char('A' + i) << " PONG " << mincard << " " << mincard << " " << mincard << "\n", ponged = true;
                if (!ponged) simulator->player[simulator->next()]->trychow(mincard);
            }
        }
    } *player[4];
    int now, dir;
    int next() {return ((now + dir) % 4 + 4) % 4; }
    Simulator(): now(0), dir(0) {
        for (int j = 0; j < 4; j++) player[j] = new Player(this, j);
        heap = new Cardheap(this);
    }
    void inputheap() {
        for (int i = 1; i <= 148; i++) {
            std::string card;
            std::cin >> card;
            heap->addcard(card);
        }
    }
    void distributecard() {
        for (int i = 1; i <= 13; i++)   
            for (int j = 0; j < 4; j++)
                player[j]->getcard(heap->getcard());
    }
    void simulate() {
        dir = 1, now = 0;
        while (true) {
            player[now]->startround();
            now = next();
        }
    }
};
signed main() {
    Simulator* sim = new Simulator();
    sim->inputheap();
    sim->distributecard();
    sim->simulate();
    return 0;
}
```

---

## 作者：江户川·萝卜 (赞：1)

感觉这道题的难点在于计算和牌距离。

----

接下来以作者写代码的顺序将这道题的代码过程剖析一下。

(四个人在代码中分别编号 $0\sim 3$。）

### 第一部分：基础操作

大概就是输出、输入什么的封装一下。

```cpp
string cd[39]={"","1M","2M","3M","4M","5M","6M","7M","8M","9M","1P","2P","3P","4P","5P","6P","7P","8P","9P","1S","2S","3S","4S","5S","6S","7S","8S","9S","E","S","W","N","B","F","Z","PASS","REVERSE","DOUBLE"};
// cd 牌类型
int cnt[4][39],cur,rev,mc[4],dis[4];
// cnt 记录每个人某种牌有多少
// cur 当前操作人编号
// rev 是否反向
// mc 每个人的鸣牌数
// dis 每个人当前手牌的和牌距离
int cardset[155],cp;
// cardset 牌堆
// cp 牌堆顶编号
inline int getcd(string s){for(int i=1;i<=37;i++)if(s==cd[i])return i;return 114514;}
// getcd 摸牌
inline void mov(int &cur){cur=(cur+1+(rev<<1))&3;}
// mov 向 rev 的方向将 cur 移动一个人
inline void remov(){cur=(cur+1+(!rev<<1))&3;}
// remov 向 rev 的反向将 cur 移动一个人
inline void in(){cout<<(char)('A'+cur)<<" IN "<<cd[cardset[++cp]]<<'\n';cnt[cur][cardset[cp]]++;}
// in 摸牌输出
inline void out(int p){cout<<(char)('A'+cur)<<" OUT "<<cd[p]<<'\n';cnt[cur][p]--;}
// out 切牌输出
inline void pong(int x,int p){cout<<(char)('A'+x)<<" PONG "<<cd[p]<<' '<<cd[p]<<' '<<cd[p]<<'\n';}
// pong 碰牌输出
inline void chow(int x,int p){cout<<(char)('A'+x)<<" CHOW "<<cd[p]<<' '<<cd[p+1]<<' '<<cd[p+2]<<'\n';}
// chow 吃牌输出
inline void pass(){cnt[cur][35]--;cout<<(char)('A'+cur)<<" OUT PASS ";mov(cur);cout<<(char)('A'+cur)<<'\n';}
// pass PASS 的特殊输出
inline void win(int p){cout<<(char)('A'+p)<<" WIN\n";exit(0);}
// win 编号 p 的人 win 的输出及结束
inline void chkwin(int p,bool op){if(!calc(p))cout<<(char)('A'+p)<<' '<<(op?"SELFDRAWN":"RON")<<'\n',win(p);}
// chkwin 用 calc 函数计算和牌距离，如果为 0 则和牌
```

`calc` 的实现在第四部分。

还有主函数的框架：

```cpp
int main(){
    std::ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    string s;
    for(int i=1;i<=148;i++) cin>>s,cardset[i]=getcd(s);
    for(int i=1;i<=52;i++) in(),mov(cur);
    for(int i=0;i<=3;i++) dis[i]=calc(i);
    for(int i=53;i<=148;i++) in(),chk(),mov(cur);
    cout<<"DRAW\n";
    return 0;
}
// chk 是计算该切什么牌的部分
``` 

实际上这么写完之后，框架有了，接下来整个问题就分成了若干个小问题了。

### 第二部分：计算切牌

按题意来即可。先判特殊牌，再判最小和牌距离。切牌切出去的响应留给下部分。

```cpp
inline void chk(){
    if(cnt[cur][35]) return pass();         // PASS
    if(cnt[cur][36]) return rev^=1,out(36); // REVERSE
    if(cnt[cur][37]) return out(37),remov();// DOUBLE
    chkwin(cur,1);// 特判是否自摸
    int q=114514,mx=0;
    // q 表示最小和牌距离
    // mx 表示为了 q 要切什么牌
    for(int i=34;i>=1;i--){//有相同距离的取编号最大
        if(cnt[cur][i]){
            cnt[cur][i]--;
            int k=calc(cur);
            cnt[cur][i]++;
            if(k<q) q=k,mx=i;
        }
    }
    dis[cur]=q;
    out(mx);call(mx);
    // call 就是切牌响应
}
```

### 第三部分 切牌响应

这部分也是按题意来。注意响应有优先级次序：

1. 先判和牌。有头跳（即需按顺序），我们之前写的 `mov` 函数就有用了。
2. 再判碰牌。由于最多只有一家响应所以实现随意。
3. 最后判吃牌，只有下家能吃。注意字牌不能被吃，`89M1P` 不能吃等等。

注意此时算距离的时候要将鸣的牌删去，副露数加一。

```cpp
inline void call(int op){
    // 和牌
    int q=cur;mov(q);
    while(q!=cur){
        cnt[q][op]++;
        chkwin(q,0);
        cnt[q][op]--;
        mov(q);
    }
    // 碰牌
    q=cur;mov(q);
    while(q!=cur){
        if(cnt[q][op]>=2){
            cnt[q][op]-=2;
            mc[q]++;
            int x=calc(q);
            if(x<dis[q]){
                dis[q]=x;
                pong(q,op);
                cur=q;
                return chk();
            }
            else cnt[q][op]+=2,mc[q]--;
            break;
        }
        mov(q);
    }
    // 吃牌
    q=cur;mov(q);
    if(op<=27){
        cnt[q][op]++;
        for(int i=1;i>=-1;i--){
            if((op+i)%9>1){
                if(cnt[q][op+i]&&cnt[q][op+i-1]&&cnt[q][op+i+1]){
                    cnt[q][op+i-1]--,cnt[q][op+i]--,cnt[q][op+i+1]--;mc[q]++;
                    int x=calc(q);
                    if(x<dis[q]){
                        dis[q]=x;
                        chow(q,op+i-1);
                        cur=q;return chk();
                    }
                    cnt[q][op+i-1]++,cnt[q][op+i]++,cnt[q][op+i+1]++;mc[q]--;
                }
            }
        }
        cnt[q][op]--;
    }
}
```

### 第四部分 和牌距离

注意到我们的 `calc` 函数会调用上百次，所以简单的搜索剪枝优化可能无法通过。（~~我不知道我没写过~~）

考虑使用 dp 解决。按照牌的种类从前往后 dp。我们将和牌距离视作向虚空借牌并扔掉无用牌。

发现对于某一种牌，只有它前面两种牌的已用的数量可能会影响决策，所以可以将状态进行压缩。且由于和牌肯定需要 $14$ 张所以不用管扔掉的牌。

那么我们记 $f_{i,a,b,c,d=0/1}$ 表示当前计算到第 $i$ 种牌，$i-1$ 用了 $a$ 张，$i-2$ 用了 $b$ 张，为了达到 $c$ 个面子 $d$ 个雀头所需要借几张牌。

可以考虑使用刷表法，也就是目前我们有 $f_{i-1,a,b,c,d}$，要往后转移。

借东西这个概念把它具象一下，设 $g(k,d)$ 表示为了总共有 $d$ 张编号为 $k$ 的牌，要借几张 $k$。显然 $g(k,d)=\max(0,d-cnt_{k,d})$，其中 `cnt` 是已有的牌。

再设 $w=f_{i-1,a,b,c,d}-g(i-1,b)-g(i-2,a)$。准备工作做完了，开始转移。

- 什么都不干。$f_{i,b,0,c,d}=\min(f_{i,b,0,c,d},w+g(i-1,b)+g(i-2,a))$。
- 补一个雀头。$f_{i,b,2,c,1}=\min(f_{i,b,2,c,1},w+g(i,2)+g(i-1,b)+g(i-2,a))$。
- 补 $k\in\{1,2\}$ 个顺子。$f_{i,b+k,k,c+k,d}=\min(f_{i,b+k,k,c+k,d},w+g(i,k)+g(i-1,b+k)+g(i-2,a+k)$。
- 补一个雀头加 $k\in \{1,2\}$ 个顺子。$f_{i,b+k,k+2,c+k,1}=\min(f_{i,b+k,k+2,c+k,1},w+g(i,k+2)+g(i-1,b+k)+g(i-2,a+k)$。
- 补一个刻子。$f_{i,b,3,c+1,d}=\min(f_{i,b,3,c+1,d},w+g(i,3)+g(i-1,b)+g(i-2,a))$。
- 补一个刻子加一个顺子。$f_{i,b+1,4,c+2,d}=\min(f_{i,b+1,4,c+2,d},w+g(i,4)+g(i-1,b+1)+g(i-2,a+1))$。

注意由于三个相同顺子相当于三个刻子所以可以少分讨一点。

`1M2M1P2P1S2S` 和字牌这些种类的牌没法补一个顺子，所以只需要分前两种即可。具体实现看代码：

```cpp
int dp[35][5][5][5][2],op;
inline int getn(int op,int cd,int num){return max(0,num-cnt[op][cd]);}
inline void cmin(int &x,int y){if(x>y) x=y;}
inline void solve1(int l,int r,int op){
    for(int k=l;k<=r;k++)
    for(int a=0;a<=4;a++)
    for(int b=0;b<=4;b++)
    for(int c=0;c<=4;c++)
    for(int d=0;d<=1;d++){
        int res=dp[k-1][a][b][c][d];
        if(res>114514) continue;
        cmin(dp[k][b][0][c][d],res);
        // cout<<k<<' '<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<res<<'\n';
        if(!d) cmin(dp[k][b][2][c][1],res+getn(op,k,2));
        if(c<4) cmin(dp[k][b][3][c+1][d],res+getn(op,k,3));
    }
}
inline void solve2(int l,int r,int op){
    for(int k=l;k<=r;k++)
    for(int a=0;a<=4;a++)
    for(int b=0;b<=4;b++)
    for(int c=0;c<=4;c++)
    for(int d=0;d<=1;d++){
        int res=dp[k-1][a][b][c][d]-getn(op,k-1,b)-getn(op,k-2,a);
        if(res>114514) continue;
        // cout<<k<<' '<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<res<<'\n';
        cmin(dp[k][b][0][c][d],res+getn(op,k-1,b)+getn(op,k-2,a));
        if(!d) cmin(dp[k][b][2][c][1],res+getn(op,k,2)+getn(op,k-1,b)+getn(op,k-2,a));
        if(c<4) cmin(dp[k][b][3][c+1][d],res+getn(op,k,3)+getn(op,k-1,b)+getn(op,k-2,a));
        if(a<4&&b<4&&c<3) cmin(dp[k][b+1][4][c+2][d],res+getn(op,k,4)+getn(op,k-1,b+1)+getn(op,k-2,a+1));
        if(a<4&&b<4&&c<4&&!d) cmin(dp[k][b+1][3][c+1][1],res+getn(op,k,3)+getn(op,k-1,b+1)+getn(op,k-2,a+1));
        if(a<3&&b<3&&c<3&&!d) cmin(dp[k][b+2][4][c+2][1],res+getn(op,k,4)+getn(op,k-1,b+2)+getn(op,k-2,a+2));
        if(a<4&&b<4&&c<4) cmin(dp[k][b+1][1][c+1][d],res+getn(op,k,1)+getn(op,k-1,b+1)+getn(op,k-2,a+1));
        if(a<3&&b<3&&c<3) cmin(dp[k][b+2][2][c+2][d],res+getn(op,k,2)+getn(op,k-1,b+2)+getn(op,k-2,a+2));
    }
}
inline int calc(int op){
    memset(dp,0x3f,sizeof dp);
    dp[0][0][0][mc[op]][0]=0;
    solve1(1,2,op);
    solve2(3,9,op);
    solve1(10,11,op);
    solve2(12,18,op);
    solve1(19,20,op);
    solve2(21,27,op);
    solve1(28,34,op);
    int ans=dp[34][0][0][4][1];
    for(int i=0;i<=3;i++)
    for(int j=0;j<=3;j++)
        ans=min(ans,dp[34][i][j][4][1]);
    return ans;
}
```

整体代码拼一拼就有了。

---

## 作者：GavinCQTD (赞：0)

[更好的阅读体验](https://gavin-blog.pages.dev/2025/%E6%B4%9B%E8%B0%B7-p7147-thupc-2021-%E5%88%9D%E8%B5%9B-%E9%BA%BB%E5%B0%86%E6%A8%A1%E6%8B%9F%E5%99%A8-%E9%A2%98%E8%A7%A3/)

## 碎碎念

目前写过最恶心的一道模拟题。

## 正文

本人写模拟题的习惯是先拟一个流程图，知道自己要写什么，避免在写代码的时候卡壳。

本题题面很清楚，看完基本就能构建出一个流程，所以下面直接把流程放上来了。

总流程如下：

1. 初始化玩家
2. 输入牌堆
3. 发牌
4. 进行回合

一个回合的流程如下：

1. 摸牌（若刚吃、碰）则跳过。
2. 判断自摸。
3. 出牌。
4. 若是功能牌，则立即生效。
5. 判断是否荣和
6. 判断能否碰
7. 判断能否吃

这里对于其中几个较复杂的点进行详细说明。

### 和牌距离

这里参考了[这篇题解](https://www.luogu.com.cn/article/408pj66x)的方法，非常感谢！

由于需要计算多次和牌距离，暴力枚举显然是不现实的，考虑 dp。

令 $dp_{i,j,k,x,y}$ 表示前 $i$ 种牌，已经组成 $j$ 个顺子或刻子、$k$ 个对子的情况下，有 $x$ 对牌加上第 $i$ 种牌就可以组成顺子，$y$ 副第 $i-1$ 种单牌。定义 $n$ 为我们需要组成的顺子或刻子的数量。

转移过程中，枚举 $c$ 作为当前这张牌选取的个数，由于我们需要第 $i$ 种牌组成新的顺子或差一张牌的顺子（就是上文 $x$ 及 $y$ 表示的），所以 $x + y \le c$。

如果第 $i$ 张牌仍有剩余，组成刻子、对子或成为单牌。

### 吃

直接将三种情况都判断一下就可以了。

## 一些错误

下面是本人写这道题时遇到的错误，放出来供大家自查 qwq。

1. 不拥有特殊牌时才能和牌
2. 不包含数字的 $7$ 种牌不能吃
3. 用 sort 查找要出的牌会导致 TLE

## 代码

```cpp
/******************************
 - @GavinCQTD / 2025-07-16 11:24:47
 - "P7147 [THUPC 2021 初赛] 麻将模拟器" From Luogu
 - # https://www.luogu.com.cn/problem/P7147
 - 1000 ms / 512 MB
  You have to love yourself.
******************************/

#include <algorithm>
#include <iostream>
#include <iterator>
#include <cstring>
#include <string>
#include <vector>
#include <queue>

constexpr int MAX_PLAYER=4,TILE_NUMBER=148,INITIAL_TILE_NUMBER=13;
const std::string TILES[38]={"","1M","2M","3M","4M","5M","6M","7M","8M","9M",
"1P","2P","3P","4P","5P","6P","7P","8P","9P","1S","2S","3S","4S","5S","6S",
"7S","8S","9S","E","S","W","N","B","F","Z","DOUBLE","REVERSE","PASS"};

class Tile{
    protected:
    std::string type;

public:
    std::string getType(){
        return type;
    }

    int getPriority(){
        for(int i=1;i<=37;i++){
            if(type==TILES[i]){
                return i;
            }
        }
        return 0;
    }

    bool isSpecialTile(){
        return getPriority()>=35;
    }

    bool isNumberTile(){
        return 1<=getPriority()&&getPriority()<=27;
    }

    int getNumber(){
        return type[0]-'0';
    }

    bool operator==(Tile y){
        return type==y.type;
    }

    bool operator!=(Tile y){
        return !(*this==y);
    }

    Tile(){}
    Tile(std::string _type):
    type(_type){}
};

namespace Util{
    Tile nextTypeTile(Tile tile){
        return Tile(TILES[tile.getPriority()+1]);
    }

    Tile prevTypeTile(Tile tile){
        return Tile(TILES[tile.getPriority()-1]);
    }
}

class Tiles{
    protected:
    std::queue<Tile> tiles;

public:
    void addTile(Tile tile){
        tiles.push(tile);
    }

    bool canDraw(){
        return !tiles.empty();
    }

    Tile draw(){
        Tile front=tiles.front();
        tiles.pop();
        return front;
    }

    Tiles(){}
};

class Player{
    protected:
    std::string name;
    std::vector<Tile> tiles;
    std::vector<int> tileNumber;

public:
    std::string getName(){
        return name;
    }

    void addTile(Tile tile,bool output=true){
        tiles.push_back(tile);
        tileNumber[tile.getPriority()]++;
        if(output){
            std::cout << name << " IN " << tiles.back().getType() << "\n";
        }
    }

    void draw(Tiles &_tiles){
        addTile(_tiles.draw());
    }

    template<typename compareT>
    std::vector<Tile>::iterator getTile(compareT compare){
        std::vector<Tile> _tiles=tiles;
        std::vector<Tile>::iterator result=_tiles.begin();
        for(std::vector<Tile>::iterator it=std::next(_tiles.begin());it!=_tiles.end();it=std::next(it)){
            if(compare(*it,*result)){
                result = it;
            }
        }
        return std::find_if(tiles.begin(),tiles.end(),[&](Tile tile)->bool{
            return tile==*result;
        });
    }

    void discard(std::vector<Tile>::iterator tile,bool output=true){
        if(output){
            std::cout << name << " OUT " << tile->getType() << "\n";
        }
        tileNumber[tile->getPriority()]--;
        tiles.erase(tile);
    }

    void discard(Tile tile,bool output=true){
        std::vector<Tile>::iterator it=std::find_if(tiles.begin(),tiles.end(),[&](Tile _tile)->bool{
            return tile.getType()==_tile.getType();
        });
        discard(it,output);
    }

    int specialTileCount(){
        return tileNumber[35]+tileNumber[36]+tileNumber[37];
    }

    int calculateDistance(){
        static int dp[36][5][2][5][5];
        memset(dp,0x3f,sizeof(dp));
        dp[1][0][0][0][0] = 0;
        int n=tiles.size()/3;
        for(int i=1;i<=34;i++){
            for(int j=0;j<=n;j++){
                for(int k=0;k<=1;k++){
                    for(int x=0;x<=2&&x+j<=n;x++){
                        for(int y=0;y<=2&&x+y+j<=n;y++){
                            if(dp[i][j][k][x][y]<=14){
                                for(int c=x+y;c<=4;c++){
                                    int l=c-x-y,w=dp[i][j][k][x][y]+std::max(0,c-tileNumber[i]);
                                    if(l<=2){
                                        dp[i+1][x+j][k][y][l] = std::min(dp[i+1][x+j][k][y][l],w);
                                    }
                                    if(l>=2&&!k){
                                        dp[i+1][x+j][1][y][l-2] = std::min(dp[i+1][x+j][1][y][l-2],w);
                                    }
                                    if(l>=3&&x+j<n){
                                        dp[i+1][x+j+1][k][y][l-3] = std::min(dp[i+1][x+j+1][k][y][l-3],w);
                                    }
                                }
                            }
                            if(!Tile(TILES[i]).isNumberTile()||Tile(TILES[i]).getNumber()==1){
                                break;
                            }
                        }
                        if(!Tile(TILES[i]).isNumberTile()||Tile(TILES[i]).getNumber()==1){
                            break;
                        }
                    }
                }
            }
        }
        return dp[35][n][1][0][0];
    }

    int distanceAfterDiscard(Tile target){
        discard(target,false);
        int result=calculateDistance();
        addTile(target,false);
        return result;
    }

    int distanceAfterAdd(Tile target){
        addTile(target,false);
        int result=calculateDistance();
        discard(std::prev(tiles.end()),false);
        return result;
    }

    int distanceAfterPONG(Tile target){
        discard(target,false);
        discard(target,false);
        int result=calculateDistance();
        addTile(target,false);
        addTile(target,false);
        return result;
    }

    bool canPONG(Tile target){
        return tileNumber[target.getPriority()]>=2&&distanceAfterPONG(target)<calculateDistance();
    }

    void PONG(Tile target){
        std::cout << name << " PONG " << target.getType() << " " << target.getType() << " " << target.getType() << "\n";
        discard(target,false);
        discard(target,false);
    }

    int distanceAfterCHOW(Tile target,int type){
        Tile tile1,tile2;
        if(type==1){
            tile1 = Util::nextTypeTile(target);
            tile2 = Util::nextTypeTile(tile1);
        }
        else if(type==2){
            tile1 = Util::prevTypeTile(target);
            tile2 = Util::nextTypeTile(target);
        }
        else{
            tile2 = Util::prevTypeTile(target);
            tile1 = Util::prevTypeTile(tile2);
        }

        discard(tile1,false);
        discard(tile2,false);
        int result=calculateDistance();
        addTile(tile1,false);
        addTile(tile2,false);
        return result;
    }

    int canCHOW(Tile target){
        if(target.getNumber()<=7&&tileNumber[Util::nextTypeTile(target).getPriority()]>=1&&
            tileNumber[Util::nextTypeTile(Util::nextTypeTile(target)).getPriority()]>=1&&distanceAfterCHOW(target,1)<calculateDistance()){
                return 1;
        }
        if(2<=target.getNumber()&&target.getNumber()<=8&&tileNumber[Util::prevTypeTile(target).getPriority()]>=1&&
            tileNumber[Util::nextTypeTile(target).getPriority()]>=1&&distanceAfterCHOW(target,2)<calculateDistance()){
                return 2;
        }
        if(3<=target.getNumber()&&tileNumber[Util::prevTypeTile(Util::prevTypeTile(target)).getPriority()]>=1&&
            tileNumber[Util::prevTypeTile(target).getPriority()]>=1&&distanceAfterCHOW(target,3)<calculateDistance()){
                return 3;
        }
        return 0;
    }

    void CHOW(Tile target,int type){
        Tile tile1,tile2,tile3;
        if(type==1){
            tile1 = target;
            tile2 = Util::nextTypeTile(tile1);
            tile3 = Util::nextTypeTile(tile2);
        }
        else if(type==2){
            tile2 = target;
            tile1 = Util::prevTypeTile(tile2);
            tile3 = Util::nextTypeTile(tile2);
        }
        else{
            tile3 = target;
            tile2 = Util::prevTypeTile(tile3);
            tile1 = Util::prevTypeTile(tile2);
        }

        std::cout << name << " CHOW " << tile1.getType() << " " << tile2.getType() << " " << tile3.getType() << "\n";
        if(tile1!=target){
            discard(tile1,false);
        }
        if(tile2!=target){
            discard(tile2,false);
        }
        if(tile3!=target){
            discard(tile3,false);
        }
    }

    Player(){
        tileNumber.resize(38);
    }
    Player(std::string _name):
    name(_name){
        tileNumber.resize(38);
    }
};

Tiles tiles;
bool reversed=false,skipDraw=false;
std::vector<Player> players(MAX_PLAYER);
std::vector<Player>::iterator currentPlayer=players.begin();

namespace Game{
    std::vector<Player>::iterator getNextPlayer(std::vector<Player>::iterator targetPlayer){
        if(!reversed){
            return std::next(targetPlayer)==players.end()?players.begin():std::next(targetPlayer);
        }
        else{
            return targetPlayer==players.begin()?std::prev(players.end()):std::prev(targetPlayer);
        }
    }

    void nextPlayer(){
        currentPlayer = getNextPlayer(currentPlayer);
    }

    void goRound(){
        if(!skipDraw){
            if(!tiles.canDraw()){
                std::cout << "DRAW\n";
                exit(0);
            }
            currentPlayer->draw(tiles);
        }
        else{
            skipDraw = false;
        }

        if(currentPlayer->specialTileCount()==0&&currentPlayer->calculateDistance()==0){
            std::cout << currentPlayer->getName() << " SELFDRAWN\n" << currentPlayer->getName() << " WIN\n";
            exit(0);
        }

        std::vector<Tile>::iterator firstTile=currentPlayer->getTile([](Tile x,Tile y)->bool{
            return x.getPriority()>y.getPriority();
        });
        if(firstTile->isSpecialTile()){
            bool doubleRound=false,skipNextRound=false;
            if(firstTile->getType()=="PASS"){
                skipNextRound = true;
                std::cout << currentPlayer->getName() << " OUT PASS " << Game::getNextPlayer(currentPlayer)->getName() << "\n";
            }
            else if(firstTile->getType()=="REVERSE"){
                reversed = !reversed;
            }
            else if(firstTile->getType()=="DOUBLE"){
                doubleRound = true;
            }
            currentPlayer->discard(firstTile,firstTile->getType()!="PASS");
            if(skipNextRound){
                nextPlayer();
                nextPlayer();
            }
            else if(!doubleRound){
                nextPlayer();
            }
            return;
        }

        firstTile = currentPlayer->getTile([&](Tile x,Tile y)->bool{
            int disx=currentPlayer->distanceAfterDiscard(x),disy=currentPlayer->distanceAfterDiscard(y);
            if(disx==disy){
                return x.getPriority()>y.getPriority();
            }
            return disx<disy;
        });
        Tile publicTile = *firstTile;
        currentPlayer->discard(firstTile);

        std::vector<Player>::iterator targetPlayer=getNextPlayer(currentPlayer);
        while(targetPlayer!=currentPlayer){
            if(targetPlayer->specialTileCount()==0&&targetPlayer->distanceAfterAdd(publicTile)==0){
                std::cout << targetPlayer->getName() << " RON\n" << targetPlayer->getName() << " WIN\n";
                exit(0);
            }
            targetPlayer = getNextPlayer(targetPlayer);
        }

        targetPlayer = getNextPlayer(currentPlayer);
        while(targetPlayer!=currentPlayer){
            if(targetPlayer->canPONG(publicTile)){
                targetPlayer->PONG(publicTile);
                skipDraw = true;
                currentPlayer = targetPlayer;
                return;
            }
            targetPlayer = getNextPlayer(targetPlayer);
        }

        if(publicTile.isNumberTile()){
            targetPlayer = getNextPlayer(currentPlayer);
            int CHOWType=targetPlayer->canCHOW(publicTile);
            if(CHOWType!=0){
                targetPlayer->CHOW(publicTile,CHOWType);
                skipDraw = true;
                currentPlayer = targetPlayer;
                return;
            }
        }

        nextPlayer();
    }
}

int main(){
    for(int tilesCount=1;tilesCount<=TILE_NUMBER;tilesCount++){
        std::string tileType;
        std::cin >> tileType;
        tiles.addTile(tileType);
    }

    std::string currentName="A";
    for(int player=1;player<=MAX_PLAYER;player++){
        *currentPlayer = Player(currentName);
        currentName[0]++;
        Game::nextPlayer();
    }

    for(int range=1;range<=INITIAL_TILE_NUMBER;range++){
        for(int player=1;player<=MAX_PLAYER;player++){
            currentPlayer->draw(tiles);
            Game::nextPlayer();
        }
    }

    while(true){
        Game::goRound();
    }

    return 0;
}
```

---

## 作者：anke2017 (赞：0)

四天，十四小时，码量约平均码长，在和牌距离处调试了很久。

## 前情提要

做完猪国杀之后做这题（由于我对猪国杀的完成时长不满意）

## 正题

### 基本读入读出

我们需要一个结构体，存下一个人的牌。考虑到存储字符串不太方便，所以可以将一种牌独立的设一个编号。

#### 读入

用 `switch` 维护即可。

```cpp
int card_to_num(string s)
{
	switch(s.length())
	{
		case 1://字牌
			switch(s[0])
			{
				case 'Z':return 4;
				case 'F':return 5;
				case 'B':return 6;
				case 'N':return 7;
				case 'W':return 8;
				case 'S':return 9;
				case 'E':return 10;
				default:return 114514;//不会执行
			}
		case 2://普通牌
			switch(s[1])
			{
				case 'S':return 20-(s[0]-'0');
				case 'P':return 29-(s[0]-'0');
				case 'M':return 38-(s[0]-'0');
				default:return 9824;//不会执行
			}
		default://特殊牌
			switch(s[0])
			{
				case 'P':return 1;
				case 'R':return 2;
				case 'D':return 3;
				default:return 998244353;//不会执行
			}
	}
}
```

#### 输出

上面的转换把每一个牌都变成了一个数，而且在 $1\sim37$ 之间。所以直接开数组即可。

```cpp
const string num_to_card[]=
{
	"NULL","PASS","REVERSE","DOUBLE",//3
	"Z","F","B","N","W","S","E",//10
	"9S","8S","7S","6S","5S","4S","3S","2S","1S",//19
	"9P","8P","7P","6P","5P","4P","3P","2P","1P",//28
	"9M","8M","7M","6M","5M","4M","3M","2M","1M"//37
};
```

### 玩家存储

开一个结构体。考虑玩家有用的信息有哪些。

我得到的是：

1. 各手牌数量（手牌总数可以通过暴力计算得到）。
2. 玩家编号（可有可无）

代码如下（部分函数后面再实现）

```cpp
struct player
{
	int player_num;
	int card[50];
	inline char name()
	{
		return player_num+'A'-1;
	}
	void add(int num,bool st)//st 表示可否胡牌
	{
		cout<<name()<<" IN "<<num_to_card[num]<<'\n';
		card[num]++;
		if(st&&!(card[1])&&!(card[2])&&!(card[3]))//没有特殊牌
		{
			int tmp;
			copy_card(card,siz);
			if(!dis_to_do(tmp,4-(14-sum_card(card))/3))
			{
				cout<<name()<<" SELFDRAWN \n";
				cout<<name()<<" WIN";
				exit(0);
			}
		}
	}
	int push()//return num
	{
		int tmp=0;
		if(card[1])tmp=1;
		else if(card[2])tmp=2;
		else if(card[3])tmp=3;
//特殊牌
		else 
		{
			copy_card(card,siz);
			dis_to_do(tmp,4-(14-sum_card(siz))/3);
		}
		if(tmp!=1)cout<<name()<<" OUT "<<num_to_card[tmp]<<'\n';
		card[tmp]--;
		siz[tmp]--;
		return tmp;
	}
}players[5];
```

### 摸牌

将每一张牌直接读入，每次取出第一张。我无聊，所以用了 `queue`。

```cpp
queue<int> all_cards;

...
	for(int i=1;i<=148;i++)
	{
		cin>>ss;
		all_cards.push(card_to_num(ss));
	}
	for(int i=1;i<=13;i++)
	{
		for(int j=1;j<=4;j++)
		{
			players[j].add(all_cards.front(),0);
			all_cards.pop();
		}
	}
```

### 判断自摸或荣和

用后面的和牌距离算，距离为 `0` 时显然为荣和或自摸。

### 计算和牌距离

本题最难的部分。

考虑 `dp`。令 $dp(i,j,0/1,m,n)$ 表示考虑前 $i$ 张牌，已经有了 $j$ 个刻子或顺子，$0/1$ 个对子，计划凑成 $m$ 个形如 $(i-2,i-1,i)$ 的顺子，$m$ 个形如 $(i-1,i,i+1)$ 的顺子，此时的和牌距离。同时令 $dis(i,j,0/1,m,n)$ 为此时应该出的第一张牌。

显然有 $dp(3,0,0,0,0)=0$（我的是 $3$，因为编号不一样）。

这个时候，有三步：

1. 凑一个刻子。这在可能的剩余牌数 $\ge3$ 时才可行，如果有剩下的牌，跳到第三步。
2. 凑一个对子。同样的，这在可能的剩余牌数 $\ge2$ 是才可能，如果有剩下的牌，跳到第三步。
3. 凑一些顺子。此时只要考虑顺子数量 $\le2$ 即可（如果三个，那么凑三个刻子是等价的）

剩余牌数可以通过枚举得到，注意不能超过 $4-m-n$。

注意转移时不仅要转移步数，如果有更优的第一步牌也要转移。

部分细节在代码中标明。

代码：

```cpp
int dp[40][10][5][10][10];
int dis[40][10][5][10][10];
int siz[40];//记录每一个数字
inline void doit(int &st1,int &st2,int ne1,int ne2)
{
	if(st1>ne1||(st1==ne1&&st2>ne2))st1=ne1,st2=ne2;
}

int dis_to_do(int &first,int count)//first返回第一张牌，count传入需要几个副露，返回和牌距离
{
	memset(dp,0x3f,sizeof(dp));
	dp[3][0][0][0][0]=0;
	for(int i=3;i<=36;i++)
		for(int j=0;j<=count;j++)//需要的附露数 
			for(int k=0;k<=1;k++)
				for(int l=0;l<=2&&l+j<=count;l++)
				{
					for(int r=0;r<=2&&l+r+j<=count;r++)
					{
						if(dp[i][j][k][l][r]>20)continue;
//无效 （显然和牌距离比这个小）
						for(int x=l+r;x<=4;x++)
//最终有几张这样的牌
						{
							int nx=max(0,x-siz[i+1])+dp[i][j][k][l][r];
							int ny=((siz[i+1]>x&&dis[i][j][k][l][r]==0) ? (i+1) : dis[i][j][k][l][r]);
//如果这种牌最后的数量更少，那么显然要丢掉（一些）这种牌
//否则，不用丢这种牌，第一张出的与原来一致
							int now=x-l-r;
							if(now>=2&&(!k))
								doit(dp[i+1][j+l][1][r][now-2],dis[i+1][j+l][1][r][now-2],nx,ny);
//组了一对
							if(now>=3&&(j+l+r+1<=count))
								doit(dp[i+1][j+1+l][k][r][now-3],dis[i+1][j+1+l][k][r][now-3],nx,ny);
//组一个刻子
							if(now<=2)
//三个以上全当刻子就好了，同时得保证顺子合法 
								doit(dp[i+1][j+l][k][r][now],dis[i+1][j+l][k][r][now],nx,ny);
//全组了顺子
						}
						if(i<=10||i==19||i==28||i==37)break;
//每组的第一张牌不能组 
					}
					if(i<=10||i==19||i==28||i==37)break;
				}
	first=dis[37][count][1][0][0];
	return dp[37][count][1][0][0];
}
```

### 决定出的牌

优先下特殊牌，然后用计算和牌距离的函数计算即可。

### 碰，吃

同理，比较前后的和牌距离即可。注意有些吃是不合法的。

## 完整代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const string num_to_card[]=
{
	"NULL","PASS","REVERSE","DOUBLE",//3
	"Z","F","B","N","W","S","E",//10
	"9S","8S","7S","6S","5S","4S","3S","2S","1S",//19
	"9P","8P","7P","6P","5P","4P","3P","2P","1P",//28
	"9M","8M","7M","6M","5M","4M","3M","2M","1M"//37
};

int card_to_num(string s)
{
	switch(s.length())
	{
		case 1:
			switch(s[0])
			{
				case 'Z':return 4;
				case 'F':return 5;
				case 'B':return 6;
				case 'N':return 7;
				case 'W':return 8;
				case 'S':return 9;
				case 'E':return 10;
				default:return 114514;
			}
		case 2:
			switch(s[1])
			{
				case 'S':return 20-(s[0]-'0');
				case 'P':return 29-(s[0]-'0');
				case 'M':return 38-(s[0]-'0');
				default:return 9824;
			}
		default:
			switch(s[0])
			{
				case 'P':return 1;
				case 'R':return 2;
				case 'D':return 3;
				default:return 998244353;
			}
	}
}

int dp[40][10][5][10][10];
int dis[40][10][5][10][10];
int siz[40];

inline int sum_card(int need[])
{
	int ans=0;
	for(int i=1;i<=37;i++)ans+=need[i];
	return ans;
}

inline void copy_card(int need[],int need2[])
{
	for(int i=1;i<=37;i++)
	{
		need2[i]=need[i];
	}
}

inline void doit(int &st1,int &st2,int ne1,int ne2)
{
	if(st1>ne1||(st1==ne1&&st2>ne2))st1=ne1,st2=ne2;
}

int dis_to_do(int &first,int count)
{
	//cout<<count<<"\n";
	memset(dp,0x3f,sizeof(dp));
	dp[3][0][0][0][0]=0;
	for(int i=3;i<=36;i++)
		for(int j=0;j<=count;j++)//需要的附露数 
			for(int k=0;k<=1;k++)
				for(int l=0;l<=2&&l+j<=count;l++)
				{
					for(int r=0;r<=2&&l+r+j<=count;r++)
					{
						if(dp[i][j][k][l][r]>20)continue;//无效 
						for(int x=l+r;x<=4;x++)
						{
							int nx=max(0,x-siz[i+1])+dp[i][j][k][l][r];
							int ny=((siz[i+1]>x&&dis[i][j][k][l][r]==0) ? (i+1) : dis[i][j][k][l][r]);
							int now=x-l-r;
							if(now>=2&&(!k))
								doit(dp[i+1][j+l][1][r][now-2],dis[i+1][j+l][1][r][now-2],nx,ny);//组了一对
							if(now>=3&&(j+l+r+1<=count))
								doit(dp[i+1][j+1+l][k][r][now-3],dis[i+1][j+1+l][k][r][now-3],nx,ny);//多一个杠
							if(now<=2)//三个以上全当杠就好了，得保证顺子合法 
								doit(dp[i+1][j+l][k][r][now],dis[i+1][j+l][k][r][now],nx,ny);//全组了顺子
						}
						if(i<=10||i==19||i==28||i==37)break;//每组的第一张牌不能组 
					}
					if(i<=10||i==19||i==28||i==37)break;
				}
	first=dis[37][count][1][0][0];
	return dp[37][count][1][0][0];
} 

queue<int> all_cards;

struct player
{
	int player_num;
	int card[50];
	inline char name()
	{
		return player_num+'A'-1;
	}
	void add(int num,bool st)
	{
		cout<<name()<<" IN "<<num_to_card[num]<<'\n';
		card[num]++;
		if(st&&!(card[1])&&!(card[2])&&!(card[3]))
		{
			int tmp;
			copy_card(card,siz);
			if(!dis_to_do(tmp,4-(14-sum_card(card))/3))
			{
				cout<<name()<<" SELFDRAWN \n";
				cout<<name()<<" WIN";
				exit(0);
			}
		}
	}
	int push()//return num
	{
		int tmp=0;
		if(card[1])tmp=1;
		else if(card[2])tmp=2;
		else if(card[3])tmp=3;
		else 
		{
			copy_card(card,siz);
			//for(int i=1;i<=37;i++)cout<<siz[i]<<' ';cout<<sum_card(siz)<<'\n';
			dis_to_do(tmp,4-(14-sum_card(siz))/3);
		}
		if(tmp!=1)cout<<name()<<" OUT "<<num_to_card[tmp]<<'\n';
		card[tmp]--;
		siz[tmp]--;
		return tmp;
	}
}players[5];

inline void next_player(int &now,bool flag)
{
	if(!flag)now=now%4+1;//norble
	else 
	{
		now--;
		if(!now)now=4;
	}
}

inline void print_cards(int now)//for debug
{
	cout<<players[now].name()<<" 's card: ";for(int i=1;i<=37;i++)for(int j=1;j<=players[now].card[i];j++)cout<<num_to_card[i]<<" ";cout<<"\n";
}

int main()
{
	//freopen("7147ans.txt","w",stdout);
	string ss;
	for(int i=1;i<=4;i++)players[i].player_num=i;
	for(int i=1;i<=148;i++)
	{
		cin>>ss;
		all_cards.push(card_to_num(ss));
	}
	for(int i=1;i<=13;i++)
	{
		for(int j=1;j<=4;j++)
		{
			players[j].add(all_cards.front(),0);
			all_cards.pop();
		}
	}
	int now=1;
	bool should_jmp=0;bool flag=0;
	for(;all_cards.size();)
	{
		//print_cards(now);
		int waste;
		if(should_jmp)goto after_touch;
		players[now].add(all_cards.front(),1);
		all_cards.pop();
		after_touch:;
		should_jmp=0;
		int tmp=players[now].push();
		if(tmp==1)
		{
			cout<<players[now].name()<<" OUT PASS ";
			next_player(now,flag);
			cout<<players[now].name()<<"\n";
			next_player(now,flag);
			continue;
		}
		else if(tmp==2)
		{
			flag^=1;
			next_player(now,flag);
			continue;
		}
		else if(tmp==3)continue;
		int now2=now;
		next_player(now2,flag);
		//胡牌
		for(int x=1;x<4;x++)
		{
			copy_card(players[now2].card,siz);
			siz[tmp]++;
			if(!dis_to_do(waste,4-(14-sum_card(siz))/3))
			{
				//print_cards(now2);
				cout<<players[now2].name()<<" RON\n";
				cout<<players[now2].name()<<" WIN\n";
				return 0;
			}
			next_player(now2,flag);
		} 
		now2=now;
		next_player(now2,flag);
		//碰 
		for(int x=1;x<4;x++)//自己不能碰自己
		{
			if(players[now2].card[tmp]>=2)
			{
				copy_card(players[now2].card,siz);
				int tt=dis_to_do(waste,4-(14-sum_card(siz))/3);
				siz[tmp]-=2;
				if(dis_to_do(waste,4-(14-sum_card(siz))/3)<tt)
				{
					cout<<players[now2].name()<<" PONG "<<num_to_card[tmp]<<' '<<num_to_card[tmp]<<' '<<num_to_card[tmp]<<'\n';
					now=now2;
					should_jmp=1;
					players[now2].card[tmp]-=2;
					break;
				}
			}
			next_player(now2,flag);
		}
		if(should_jmp)continue;
		if(tmp>10)
		{
			now2=now;next_player(now2,flag);
			//吃 
			for(int st=tmp-2;st<=tmp;st++)
			{
				copy_card(players[now2].card,siz);
				int ed=st+2;
				if(ed==11||ed==12||ed==20||ed==21||ed==29||ed==30)continue;
				int last=dis_to_do(waste,4-(14-sum_card(siz))/3);
				siz[st]--;siz[st+1]--;siz[st+2]--;siz[tmp]++;
				if(siz[st]<0||siz[ed]<0||siz[st+1]<0)continue;
				if(dis_to_do(waste,4-(14-sum_card(siz))/3)<last)
				{
					cout<<players[now2].name()<<" CHOW "<<num_to_card[ed]<<" "<<num_to_card[st+1]<<' '<<num_to_card[st]<<"\n";
					now=now2;
					should_jmp=1;
					players[now2].card[st]--;
					players[now2].card[ed]--;
					players[now2].card[st+1]--;
					players[now2].card[tmp]++;
					break;
				}
			}
		}
		if(should_jmp)continue;
		next_player(now,flag);
	}
	cout<<"DRAW";
	return 0;
}
```

---


# [THUPC 2021] 鬼街

## 题目描述

那条街有“鬼街”之称,十年前是 A 市最繁华的地段之一，然而如今这里已无活人居住。

街边七零八落地排着 $n$ 座房子，每栋房子都有一个 $1$ 到 $n$ 之间的独一无二的编号，用仿佛来自地狱的黑漆涂在破瓦残砖上，在黄尘中隐隐若现。

传说，这条街上的鬼是与别处的鬼是不同的，它们喜欢研究数论，会根据数字的性质来选择自己的生活，所以它们才为每一栋房子都画上了编号。

新上任的 A 市市长并不相信魑魅魍魉的传言，为了探清真相，他决定为这条街装上灵异事件监控器。

下面有 $m$ 个事件依次发生。

- 灵异事件：在以 $x$ 的所有质因子为编号的房子里，都发生了 $y$ 次闹鬼。由于神秘的原因，次数 $y$ 可能为 $0$。
- 监控事件：有一个监控器被安装，其监控以 $x$ 的所有质因子为编号的房子，当累计的闹鬼总次数达到阈值 $y$ 时，该监控器会触发报警（若 $y = 0$，则不论被监控的房子是哪几栋，下一次灵异事件都会立即触发该监控器的报警）。不同房子发生的灵异事件次数会被分开统计，不同的监控器互不影响。所有的监控器被从 $1$ 开始依次编号。

请将所有的报警反馈给市长，即每个灵异事件之后，有哪些监控器被触发。

## 说明/提示

**【样例解释】**

在本样例中，依次发生了以下事件：

- 安装了 $1$ 号监控器，监控编号为 $2$ 和 $5$ 的房子，报警阈值为 $2$。
- 发生了一次灵异事件，$5$ 号房子似乎有闹鬼，但次数为 $0$，没有报警被触发。
- 发生了一次灵异事件，$2$ 号和 $3$ 号房子发生了 $1$ 次闹鬼。$1$ 号监控器上的累计次数达到了 $1$，但尚未触发报警。
- 发生了一次灵异事件，$7$ 号房子发生了 $1$ 次闹鬼，没有报警被触发。
- 发生了一次灵异事件，$3$ 号和 $5$ 号房子发生了 $1$ 次闹鬼。$1$ 号监控器的累计次数达到阈值 $2$，触发报警。
- 安装了 $2$ 号监控器，监控编号为 $2$ 和 $3$ 的房子，报警阈值为 $2$。
- 发生了一次灵异事件，$2$ 号房子发生了 $1$ 次闹鬼。$2$ 号监控器的累计次数达到了 $1$，但尚未触发报警。
- 安装了 $3$ 号监控器，不过其阈值为 $0$，所以下一次灵异事件必会触发其报警。
- 发生了一次灵异事件，$2$ 号房子发生了 $2$ 次闹鬼。$2$ 号监控器的累计次数达到了 $3$，超过了其报警阈值 $2$，所以被触发了报警。同时 $3$ 号监控器的报警也被触发。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_0/tree/master](https://github.com/yylidiw/thupc_0/tree/master) 查看。

## 样例 #1

### 输入

```
20 9
1 10 2
0 5 0
0 6 1
0 7 1
0 15 1
1 12 3
0 8 0
1 5 0
0 8 2
```

### 输出

```
0
0
0
1 1
0
2 2 3
```

# 题解

## 作者：zhoukangyang (赞：138)

[cnblogs](https://www.cnblogs.com/zkyJuruo/p/18668862)。

我们希望**在线**解决如下形式的问题：

> 给定长度为 $n$ 的数组和 $q$ 次操作，每次操作如下：
> - 给数组一个位置加 $v$。
> - 给定不超过 $k$ 个位置，要求在数组这些位置的总和超过 $v$ 的时候输出该操作的编号。

这题就是 $k = \omega(n)$ 的版本。

众所周知，折半警报器能在均摊做到 $\mathcal O(1) - \mathcal O(k^2\log q\log V)$（$x - y$ 表示操作一复杂度为 $x$，操作二复杂度为 $y$）。但我发现了一个 $\mathcal O(1) - \mathcal O(k\log V)$ 的算法，我们就称其为 "二进制警报器" 吧。

对于一个二操作，设其对应位置为 $pos_1,...,pos_d$。对于该操作，维护一个阈值 $h$，只要 $a_{pos_i}$ 的值经过（$a_x \to a_x+w$ 的时候，我们认为它经过了 $(a_x,a_x+w]$）$2^h$ 的倍数时 "报警"。如果目前的 $h$ 能让所有 $a_{pos_i}$ 在都不报警的前提下总和超过 $v$，那么将 $h$ 降低 $1$。

对于每个 $h=h_0$，报警次数总和是不超过 $\mathcal O(k)$ 的：$h$ 降到 $h_0$ 时，$v - \sum_{i=1}^{k}a_{pos_i}$ 应是 $\mathcal O(k2^{h_0})$ 的；而一个元素报警两次时，它必然增加了至少 $2^{h_0}$。

对每个 $(\text{位置},h)$ 开个 ``vector`` 维护警报器并利用二进制优化修改时找报警器的复杂度，复杂度是 $\mathcal O(1) - \mathcal O(k\log V)$。

对于这题，复杂度为 $\mathcal O(n + q\omega(n)\log V)$。

[轻松拿下目前最优解](https://www.luogu.com.cn/record/198032646)。

---

## 作者：WeLikeStudying (赞：20)

- 话说俺最近的题解咋都没有审核啊。
- 算了这只是个人笔记，提交题解只是进一步检验而已。

#### 题意

- [题目链接](https://www.luogu.com.cn/problem/P7603)。
- 从前有一群鬼，他们喜欢数论，因此是**魔鬼**。
- 鬼屋编号为 $1$ 到 $n$。
- 有 $m$ 个操作：
- $0\ x\ y$，以 $x$ 为质因数的房子都加上 $y$ 次闹鬼。
- $1\ x\ y$，一个监控器被安装，当以 $x$ 为质因数的房子的（在安装后）闹鬼次数总和达到或超过 $y$，这个监控器会立刻报警。
- 对于每个 $0$ 操作输出操作触发的警报器。
- 可恶的**数论魔鬼**不允许我们离线进行操作，因此这题强制在线。
- $1<x\le n,m\le 10^5$，$0\le y<2^{32}$。

#### 分析

- 有句话说得好：要用 **魔鬼** 来打败 **魔鬼**，这提示我们使用 **数论魔鬼** 的方式来思考。
- 作者可能会提到一些有趣的结论并且没有加上它的证明，因为作者要用 **魔鬼** 打败 **魔鬼**，如果感兴趣也可以对作者的文章进行评论~~或者不让题解过审~~。
- 首先观察到这一点：质因子很少啊！我们知道平均每个数的不同质因子 $\omega(n)$ 是 $O(\ln\ln n)$ 级别的，最特别的不超过 $O(\ln n/\ln\ln n)$ 级别（更具体化地，在 $10^5$ 内这个数字不会超过 $6$ 因为 $2\times 3\times 5 \times 7\times 11\times 13\times 17=510510$），埃拉托斯特尼筛法 $O(n\ln\ln n)$ 筛出每个数的质因子之后（这题空间大可以直接存），插入操作是平凡的。
- 但问题是查询操作怎么办？
- 这是一个有趣的地方，鸽巢原理：如果 $\sum_{i=1}^nx_i\ge y$，那么一定有 $\max_{i=1}^nx_i\ge \lceil y/n\rceil$（这里增强了原定理来适应变量取整数的情况）。
- 那特别地，我们对于每个警报器阈值 $y$，对于它的因子个数 $\omega(x)$，对于它的每个质因子 $p$ 都设下阈值 $\lceil y/\omega(x)\rceil$，它的复杂度会如何呢？
- 不难发现触发有可能是真的，有可能并没有效果，但是容易发现对所有没有效果的情况，警报器阈值都会减小 $1/\omega(x)$，所以假警报的次数不会太多，可以从容更新。
- 因为我们还要使用数据结构维护警报（多一个 $\log$），最坏的时间复杂度不会超过：

$$O(n\ln\ln n+m\omega(x)\log_{\omega(x)/(\omega(x)-1
)}y\log n)$$

- 将 $\omega(x)=O(\ln n/\ln\ln n)$ 带入可得。

$$O(n\ln\ln n+m\frac{\ln y\cdot \ln n\cdot \log n}{(\ln\ln n)^2-\ln\ln n\cdot \ln(\ln n-\ln\ln n)})$$

- 值得一提的是，通过一些有趣的手段可以得到一个清晰一点的界（不完全是上式转移得到）：

$$O(n\ln\ln n+m\frac{\ln y\cdot \ln^3 n}{(\ln\ln n)^2})$$

- 本人也不对此复杂度做出分析，反正在测试数据中肯定会给你卡到这个复杂度的，方法是给 $99884$ 个 $1\ 30030\ 2^{32}-1$，再在后面的 $116$ 个数中（可以证明，存在一种安排使得前 $115$ 个闹鬼事件都是假激发，复杂度 $6\times 116\times \log (99984)\times 99984=1.15\times 10^9$），所以可以做好卡常的准备了。
- 空间复杂度 $O(n\ln\ln n+m\omega(x))=O(n\ln\ln n+m\ln n/\ln\ln n)$ 是显然的。

#### 后记

我都退役这么久了现在一个[帖子](https://www.luogu.com.cn/discuss/779602)就把我干碎，没有自主创新必然被后人干碎，本人的几篇高赞题解（其实也不过四五个赞）就是被这样干碎的。

其实就是重复的触发警报可能把完全相同的预警器插入优先队列里面，出队列的时候把重复的元素删除即可，下面给出我的代码。

```cpp
//2021/12/27 18:57
#include<bits/stdc++.h>
using u32=unsigned;
using u64=u32 long long;
const u32 N=11e4;
using namespace std;
using noip=pair<u64,u32>;
u32 n,m,k=0,to[N],id[N],la=0;//上一个监控 
u64 num[N],val[N];
vector<u32>p[N],noi;//质因子 
vector<u64>bef[N];//询问（上一次更新）时质因子数目 
priority_queue<noip,vector<noip>,greater<noip> >q[N];//阈值， 来源 
priority_queue<u32,vector<u32>,greater<u32> >ccf;//更新的监控 
void watch(u32 x)
{
	u32 sz=p[id[x]].size();
	u64 dt=(val[x]+sz-1)/sz;
	for(u32 i=0;i<sz;++i)
	{
		u32 v=p[id[x]][i];
		bef[x][i]=num[v];
		q[v].push(make_pair(bef[x][i]+dt,x));
	}
}
void select(u32 x)
{
	u32 sz=p[id[x]].size();
	u64 sum=0;
	for(u32 i=0;i<sz;++i)
	{
		u32 v=p[id[x]][i];
		sum+=num[v]-bef[x][i];
	}
	if(sum>=val[x])
	{
		val[x]=0;
		if(noi.empty()||noi.back()!=x)
			noi.push_back(x);
		return;
	}
	val[x]-=sum;
	watch(x);
}
void check(u32 x)//x must be prime
{
	while(!q[x].empty())
	{
		auto it=q[x].top();
		if(it.first>num[x])break;
		if(val[it.second])ccf.push(it.second);
		while(!q[x].empty()&&q[x].top()==it)q[x].pop();//后 pop 
	}
}
int main()
{
	scanf("%u%u",&n,&m);
	for(u32 i=2;i<=n;++i)
		if(p[i].empty())
			for(u32 j=i;j<=n;j+=i)
				p[j].push_back(i);
	for(u32 i=0;i<m;++i)
	{
		u32 op,x,y;
		scanf("%u%u%u",&op,&x,&y);
		y^=k;
		if(!op)
		{
			u32 sz=p[x].size();
			for(u32 i=0;i<sz;++i)
			{
				u32 v=p[x][i];
				num[v]+=y;
				check(v);
			}
			while(!ccf.empty())
			{
				select(ccf.top());
				ccf.pop();
			}
			k=noi.size();
			printf("%u",k);
			for(u32 i=0;i<k;++i)
				printf(" %u",noi[i]);
			noi.clear();
			puts("");
		}
		else
		{
			++la;
			id[la]=x,val[la]=y;
			if(!y)ccf.push(la);
			bef[la].reserve(p[x].size());
			for(u32 i=0;i<p[x].size();++i)
				bef[la].push_back(0);
			watch(la);  
		}
	}
	return 0;
} 
//2021/12/28 16:07
```


#### 真·后记

- 顺带一提若这题允许离线就简单了，修改操作太少了，先把所有操作可持久化下去，然后对于每次查询二分查找首次冲突的警报即可。
- 时间复杂度 $O(n\ln\ln n+m\omega(x)\log m)$，空间复杂度同在线做法。

#### 真·真·后记

猜猜我是如何推导出这个时间复杂度的？

首先是两个可以搜索到的事实：

在 $1$ 到 $n$ 中，$\omega(n)$ 平均是 $\ln\ln n+O(1)$ 量级，最大是 $O(\frac{\ln n}{\ln\ln n})$ 量级。

$\ln(1+x)$ 的泰勒展开，$x-\frac12x^2+\frac13x^3-\frac14x^4+o(x^4)$。

所以 $\ln(\omega(x))-\ln(\omega(x)-1)=-\ln(1-\frac{1}{\omega(x)})=\frac1{\omega(x)}+\frac1{2\omega^2(x)}+\frac{1}{3\omega^3(x)}+o(\frac1{\omega^3(x)})$

原本的式子是：

$$n\ln\ln n+m\omega(x)\log_{\omega(x)/(\omega(x)-1
)}y\log n\sim n\ln\ln n+m\omega(x)\ln n\frac{\ln y}{\ln(\omega(x))-\ln(\omega(x)-1)}\sim n\ln\ln n+m\omega^2(x)\ln y$$

最终得到：

$$O(n\ln\ln n+m\frac{\ln^3n\ln y}{(\ln\ln n)^2})$$

这个复杂度。

---

## 作者：EXODUS (赞：11)

# Part 1：前言
比较猛的一个题，总感觉之前好像在哪见过这种 trick，即当到达某一个阈值的时候把东西拎出来检查一遍，不合法再丢回去。

当时 VP 组队赛的时候队友被卡常了，回去看的时候发现他复杂度有个地方好像写的常数比较大被卡了一会常~~结果赛时三个人瞪了好久也没看出来~~。

update on 2024.2.20：更改了实现，通过了 @sqrtDataStructure 在评论区提出的 Hack，感谢他的 Hack！

# Part 2：正文

有一个数论知识是，质因子个数函数 $\omega(n)$ 在 $n\leq 10^5$ 的时候最大为 $6$。这启发我们可以对每个数字开个队列，然后把所有报警器丢到其监视的的质因子队列里，开始闹鬼的时候把闹鬼涉的质因子屋子里的报警器的闹鬼次数加一下，没有达到阈值的再丢回去，这样时间复杂度是 $O(n^2)$ 的，并且还有一个不小的常数。

考虑优化，如果一个报警 $i$ 器可能达到阈值，设其监视了 $k_i$ 个屋子，他的阈值为 $B_i$，则必定有一个屋子闹鬼次数超过了 $\dfrac{B_i}{k_i}$，证明是容易的。

也就是说，现在我们只需要拎出来所有当前在这个屋子里的，闹鬼总次数大于等于 $\dfrac{B_i}{k_i}$ 的监视器 $i$，然后计算他现在所有的报警次数，如果达到阈值了就将其输出，否则在放回去，这个东西可以通过在每个节点上放个堆，维护一下需要达到的阈值和编号即可。注意到可能会有屋子先闹鬼再被装了报警器，我们需要在报警器被丢进去之前改变一下阈值，即加上所有其监视的屋子先前闹鬼的次数，这个细节可以见代码。

但是这么做复杂度还是错的，因为你一旦一个报警器达到阈值了就会被反复拉出来，考虑进一步优化上述的过程。我们发现每一次 check 第 $i$ 个监视器做完直接按照原阈值 $B'_i$ 丢进去是很蠢的一件事，你可以直接让阈值减去已经报警的次数，然后设阈值变成了 $B'_i$ 再次平均分配成 $\dfrac{B'_i}{k_i}$ 丢进去，这样每个数被拉出来一次以后阈值一定会降低为原来的 $\dfrac{5}{6}$ 及以下（因为有一个屋子超过了 $\dfrac{B_i}{k_i}$，而 $k_i$ 不超过 $6$），所以一个东西最多被拉出来 $\log_{\frac{5}{6}} V$ 次（设 $V$ 为值域），单次是 $O(\log n)$ 的，所以总时间复杂度是 $O(n\log n\log V)$ 的，可以通过本题。


# Part 3：代码
实现要小心一点，在每次减半警报后，先对所有的位置和询问下标构成的二元组去重，保留最小值放入减半警报器！


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i,l,r) for(int i(l);i<=(r);++i)
#define per(i,r,l) for(int i(r);i>=(l);--i)
#define eb emplace_back
#define mp make_pair
#define Debug(...) fprintf(stderr,__VA_ARGS__)
ll read(){
	ll ans=0,flag=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flag=-1;ch=getchar();}
	while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	return ans*flag;
}
template<typename T>
void read(T &x){
	x=0;T flag=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')flag=-1;ch=getchar();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	x*=flag;
}
const int N=1e5+7;
priority_queue<pair<ll,int>>awaq[N];
vector<int>locate,awa;
bool awavis[N];
vector<int>pri[N];
vector<int>ans;
int n,Q;
ll cnt[N];
bool vis[N];
priority_queue<pair<ll,int> > q[N];
int all=0;
ll val[N];
int pos[N];
ll All=0;

ll tim=0;

void check(int id){
	tim++; 
	if(vis[id])return;
	ll v=val[id];
	int s=pri[pos[id]].size();
	for(auto p:pri[pos[id]])
		v-=cnt[p];
	if(v<=0)return ans.eb(id),vis[id]=1,void();
	locate.eb(id);
	for(auto p:pri[pos[id]])
        awaq[id].emplace(-((v-1)/s+1+cnt[p]),p);
}

void check(int p,ll v){
	cnt[p]+=v;
	while(!q[p].empty()){
		auto [tot,id]=q[p].top();tot=-tot;
		if(tot>cnt[p])break;q[p].pop();check(id);
	}
    for(auto id:locate){
        while(!awaq[id].empty()){
            auto [tot,pos]=awaq[id].top();awaq[id].pop();
            if(awavis[pos])continue;
            q[pos].emplace(tot,id);
            awavis[pos]=1;
            awa.eb(pos);
        }
        for(auto p:awa)
            awavis[p]=0;
        awa.clear();
    }
    locate.clear();
}


int main(){
	// freopen("qaq.in","r",stdin);
	// freopen("qaq.out","w",stdout);
	n=read();Q=read();
	for(int i=2;i<=n;i++){
		if(!pri[i].empty())continue;
		for(int j=i;j<=n;j+=i)pri[j].eb(i);
	}
	// for(int i=1;i<=100;i++){
	// 	for(auto j:pri[i])cerr<<j<<" ";
	// 	cerr<<'\n';
	// }
	int lans=0,base=0;
	while(Q--){
		int op=read(),x=read();
		ll y=read();y^=lans;
		if(op==0){
			for(auto i:pri[x])check(i,y);
			stable_sort(ans.begin(),ans.end());
			printf("%d ",(int)(ans.size()));
			for(auto i:ans) printf("%d ",i);
			printf("\n");lans=ans.size();ans.clear();
		}else{
			all++;pos[all]=x;val[all]=y;
			for(auto i:pri[x])val[all]+=cnt[i];
			check(all);
            for(auto id:locate){
                while(!awaq[id].empty()){
                    auto [tot,pos]=awaq[id].top();
                    if(awavis[pos])continue;awaq[id].pop();
                    q[pos].emplace(tot,id);
                    awavis[pos]=1;
                    awa.eb(pos);
                }
                for(auto p:awa)
                    awavis[p]=0;
                awa.clear();
            }
            locate.clear();
		}
//		if(All>=base)cout<<Q<<" "<<All<<endl,base+=1e4;
//		if(Q%1000==0)cout<<tim<<" "<<Q<<endl;
	}
	return 0;
}

```
# Part 4：后文
感觉这个题挺优美的，有一种从暴力一点点优化到正解的感觉。

难度评分可能有点偏高了，可能是因为当时这个 trick 还没有这么普及？

---

## 作者：是青白呀 (赞：8)

**折半报警器**。第一次看到这个玩意应该是在 gym 102331F。

设 $d_x$ 表示 $x$ 的质因子集合，$cnt_i$ 表示从开始起，$i$ 房间的报警次数。记安装监视器 $i$ 时，其监视的所有房间的 $cnt$ 和为 $stp_i$，则报警的条件是 $\sum_{j\in d_x}cnt_j\geq stp_i+y$。每次加入后都判断该条件是否成立，复杂度爆炸。

考虑减少判断次数，引入折半报警器。上述条件等价于 $\sum_{j\in d_x}\Delta cnt_j\geq y$，也即至少存在一个 $j$ 满足 $\Delta cnt_j\geq \lceil \frac{y}{|d_x|}\rceil$。因此，我们对每个房间开一个优先队列，记录每一个监视器在该房间处可能报警的 $cnt$ 的阈值。每次更新某个房间的 $cnt$ 时，就 check 它是否达到了某个监视器的报警阈值。若达到了报警阈值，就将计算该监视器当前的总闹鬼次数，判断是否会触发报警，并将该监视器从所有房间的队列里删除。若触发报警，则计入当前答案；否则用现在的 $y^{\prime}=stp_i+y- \sum_{j\in d_x}cnt_j$ 重新设定每个房间的报警阈值，将新的报警阈值 $\Delta cnt_j\geq \lceil \frac{y^{\prime}}{|d_x|}\rceil$ 扔进每个房间的优先队列里即可。

不难发现，每次报警时，一个监视器的 $y$ 都会减少 $\frac{1}{|d_x|}$，因此共会更新 $\log V$ 个报警阈值，被加入总共 $d_x\log V$ 个优先队列里。总复杂度可以被控制在 $O(nd_x\log V\log n)$。

堆的删除可以使用懒惰删除，维护每个监视器的最新阈值编号、以及堆中每个阈值信息的编号即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=1e5+5,M=105,inf=1e9+7,mo=998244353;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m;
vector<int>d[N];
struct node{
	int id,opid,targ;//监视器编号、阈值编号及报警阈值
	friend bool operator<(node x,node y){
		return x.targ>y.targ;
	}
};
priority_queue<node>q[N];
int cnt[N];
pii mon[N];
int stp[N],nop[N];
bool vis[N];
int gets(int x){
	int res=0;
	for(auto j:d[mon[x].fir])
	    res+=cnt[j];
	return res;
}
signed main(){
	read(n),read(m);
	rep(i,1,n){
		int x=i;
		rep(j,2,sqrt(i)){
			int cnt=0;
			while(x%j==0)
			    x/=j,cnt++;
			if(cnt!=0)d[i].push_back(j);
		}
		if(x!=1)d[i].push_back(x);
	}
	int lans=0,cntm=0;
	vector<int>ans;
	while(m--){
		int op,x,y;
		read(op),read(x),read(y),y^=lans;
		if(op==1){
			cntm++;
			if(!y){
				ans.push_back(cntm);
				continue;
			}
			int targ=(y-1)/d[x].size()+1;
			nop[cntm]++;
			for(auto i:d[x])
			    q[i].push((node){cntm,nop[cntm],targ+cnt[i]}),stp[cntm]+=cnt[i];
			mon[cntm]=mp(x,y+stp[cntm]);
		}
		else{
			for(auto i:d[x])
				cnt[i]+=y;
			for(auto i:d[x]){
				while(!q[i].empty()&&q[i].top().targ<=cnt[i]){
					node nw=q[i].top();
					q[i].pop();
					if(vis[nw.id])continue;
					if(nop[nw.id]!=nw.opid)continue;//懒惰删除 
					int nws=gets(nw.id);
					if(nws>=mon[nw.id].sec)vis[nw.id]=1,ans.push_back(nw.id);
					else{
						int ntg=(mon[nw.id].sec-nws-1)/d[mon[nw.id].fir].size()+1;
					    nop[nw.id]++;
						for(auto j:d[mon[nw.id].fir])
							q[j].push((node){nw.id,nop[nw.id],cnt[j]+ntg});
					}
				}
			}
			printf("%lld",(int)ans.size());
			sort(ans.begin(),ans.end());
			for(auto i:ans)
			    printf(" %lld",i);
			lans=ans.size();
			ans.clear();
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：Moyou (赞：4)

# P7603 [THUPC2021] 鬼街 题解

> 第一次见折半报警器的 trick，记录一下。

首先观察到 $x \le n \le 10^5$，所以 $x$ 最多有 6 个质因数，$x = 30030$ 可以取到，这使得对于修改，我们可以暴力单点修改。

接下来考虑询问，朴素的做法是：每一次灵异事件之后，都对所有监控器进行检验是否满足和为 $y$。

这样复杂度不对，但是我们可以注意到并不是所有时刻都需要对某些监控器进行检验。

这里有一个显然但是关键的结论：

如果 $\sum_{1\le i\le k} a_i = y$，则 $\exists a_i \ge \lceil\dfrac yk\rceil$，这里面的 $a_i$ 表示从监控设置开始到监控报警时刻，$i$ 号房的闹鬼次数。

反证法易证。

这启示我们，只在满足上必要条件的情况下，对于一个监控进行检验，检验之后更新限制为：$\sum_{1\le i\le k}\Delta a_i = y - \sum_{1\le i\le k}a_{1i}$，其中 $\Delta a_i$ 表示从这次检验时间开始，$i$ 号房的闹鬼次数，$a_{1i}$ 表示从上次检验/设置开始，到当前检验时间 $i$ 号房的闹鬼次数。

由于 $\exists a_{1i} \ge \lceil\dfrac yk\rceil$，所以 $\sum_{1\le i\le k}a_{1i}\ge \lceil\dfrac yk\rceil$ 每进行一次检验，都会使得 $y \leftarrow y - \lceil\dfrac yk\rceil$，相当于每次 $y$ 会变为原来的 $\dfrac{k-1}{k}$ 倍左右，所以最多进行 $O(\log_{\frac{k}{k-1}}y)$ 次检验。

那么我们只需要在每个位置上设置一个 "报警器"，在单点设置监控/检验之后，为这个点添加 "报警器" $(\lceil\dfrac yk\rceil, i)$，表示如果这个位置的闹鬼次数超过了 $\lceil\dfrac yk\rceil$ 就需要检验 $i$ 号监控。

然后每次修改一个点的时候就对这个点上最可能报警的 "报警器" 进行检查，即限制最小的报警器。

这些报警器使用 `std::set` 或者 `__gnu_pbds::tree` 可以维护，但是常数略大，因为每次只需要取出最小值，可以使用一个堆来维护。

本题中询问 $m$ 与鬼屋个数 $n$ 同阶，时间复杂度：$O(n\log_{\frac k{k-1}} V\log n\omega(n))$。

## 参考代码

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <ctime>
#include <ext/pb_ds/priority_queue.hpp>
#include <ext/pb_ds/assoc_container.hpp>
//#define int long long
#define x first
#define y second
using namespace std;
typedef long long ll;
typedef pair<ll, int> PII;
const int N = 1e5 + 10;

int n, m, primes[N], tx[N], tot;
ll val[N], sback[N], a[N];
bool st[N];
void sieve() {
    for(int i = 2; i < N; i ++) {
        if(!st[i]) primes[++ tot] = i;
        for(int j = 1; j <= tot && primes[j] * i < N; j ++) {
            st[i * primes[j]] = 1;
            if(i % primes[j] == 0) break;
        }
    }
}
__gnu_pbds::priority_queue<PII, greater<PII>, __gnu_pbds::pairing_heap_tag> warn[N];
vector<__gnu_pbds::priority_queue<PII, greater<PII>, __gnu_pbds::pairing_heap_tag>::point_iterator> back[N];
vector<int> que, pr[N];
void check(int i) {
    ll s = 0, x = tx[i], y = val[i];
    for(auto d : pr[x]) s += a[d];
    y -= s - sback[i], val[i] = y;
    for(int id = 0, d; id < pr[x].size(); id ++) d = pr[x][id], warn[d].erase(back[i][id]);
    if(y <= 0) {
        que.push_back(i);
        return ;
    }
    ll lm = (y + (int)pr[x].size() - 1) / (int)pr[x].size();
    sback[i] = s;
    for(int id = 0, d; id < pr[x].size(); id ++) {
        d = pr[x][id];
        back[i][id] = warn[d].push({lm + a[d], i});
    }
}

signed main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m, sieve();
    clock_t stt =clock();
    for(int i = 1; i <= tot; i ++)
        for(int p = primes[i], j = p; j <= n; j += p)
            pr[j].push_back(p);
    int cnt = 0;
    for(ll i = 1, op, x, y, lst = 0; i <= m; i ++) {
        cin >> op >> x >> y, y ^= lst;
        if(op == 1) {
            cnt ++;
            tx[cnt] = x, val[cnt] = y;
            ll lm = (y + (int)pr[x].size() - 1) / (int)pr[x].size();
            if(y == 0) que.push_back(cnt);
            else {
                back[cnt].resize(pr[x].size(), 0);
                sback[cnt] = 0;
                for(int id = 0, d; id < pr[x].size(); id ++) {
                    d = pr[x][id];
                    sback[cnt] += a[d];
                    back[cnt][id] = warn[d].push({lm + a[d], cnt});
                }
            }
        }
        else {
            for(auto d : pr[x]) a[d] += y;
            for(auto d : pr[x]) {
                while(warn[d].size() && (warn[d].top().x <= a[d])) 
                    check(warn[d].top().y);
            }
            sort(que.begin(), que.end());
            cout << que.size() << ' ';
            for(auto x : que) cout << x << ' '; cout << '\n';
            lst = que.size();
            que.clear();
        }
    }
    return 0;
}

```

---

## 作者：山田リョウ (赞：4)

感谢 fjy 几个月前把题解全叉了才使得我现在能发这题题解（雾

大概是一个名为减半报警器的 trick，感觉很聪明啊！

观察发现在 $[1,10^5]\cup\mathbb{Z}$ 中每个数最多拥有 $6$ 个素因子，所以对于每个事件影响到的房子以及每个监控观察的房子均是可以枚举的。

每个监控器至多报警一次，所以我们只需要尽可能减少其被查询的次数即可。

根据抽屉原理，

$$ (\forall s,a_1,a_2,\cdots,a_k \in \mathbb{R}\; \text{s.t.}\;\sum\limits_{i=1}^ka_i\geq s)\exist i \in [1,k]\cap\mathbb{Z}\;\text{s.t}\;a_i\geq\frac{s}{k} $$
故仅当该监控器监控的某个房子累计闹鬼次数超过了阈值与监控房子数的比值才值得去查询此时是否达到阈值。

但是如果一个监控器监控的某个房子达到了该值，它每次被修改时都会查询到这个监控器直至监控器达到其阈值，此时查询次数不可接受。

考虑一个监控器的某个房子闹鬼次数达到了阈值 $y$ 与房子数 $k$ 的比值 $\frac{y}{k}$，则距离报警还需要的闹鬼次数不超过 $\frac{k-1}{k}y$，所以此时我们重复上面过程重新分配这个监控器监控的每个房间需要查询到它的限制即可，这样每查询一次它剩余次数至少乘以 $\frac{k-1}{k}$，故每个监控器被查询次数为 $O(\log_{\frac{k}{k-1}}y)$，可接受。

具体来说我先线性筛预处理了每个数的分解，然后每个房子使用堆来需要查询监控器的限制即可，我懒得写堆删除所以标记了下更新时间然后懒惰删除，时间复杂度不同写法不太一样但是总之差不多是两只 $\log$ 所以可过。

[code](https://www.luogu.com.cn/paste/968ehfh5)

---

## 作者：StayAlone (赞：3)

虽然看到 zak 最新发布的 [二进制警报器](https://www.luogu.com.cn/article/gz6wr8e3)，但还是记录一下这个原始形态。

### 题意

维护两个操作：

1. 给此刻监视 $x$ 的质因数的警报器加 $y$；
2. 增加一个警报器，监视 $x$ 的质因数。当该警报器的值达到 $y$ 时报警。

强制在线。

### 思路

令 $k=\omega(n)\leq 6$。

每增加一个警报器，就在这 $\omega(x)$ 个位置上设定阈值 $\lceil\frac{y}{\omega(x)}\rceil$。根据抽屉原理，警报器报警时，一定存在某个位置上的值达到阈值。

当某个位置达到阈值，就暴力重构。每次 $y$ 都变为原来的 $\frac{\omega(x)-1}{\omega(x)}$，则重构总次数为 $\mathcal O(q\log_{\frac{k}{k-1}} V)$。

使用优先队列维护阈值，引入时间戳懒惰删除，重构和修改的复杂度是 $\mathcal O(k\log q)$。

忽略分解质因数，总时间复杂度 $\mathcal O(qk\log q\log V)$。

刚开始试图用 set 写，慢了八倍。

[AC record](https://www.luogu.com.cn/record/202767445)

```cpp
int n, m, lst, mip[MAXN], vis[MAXN]; ll tag[MAXN];

struct node {
	ll val; int id, t;
	
	il bool operator < (const node &p) const {
		return val > p.val;
	}
}; priority_queue <node> q[MAXN];
unsigned op, x, y, X[MAXN];
ll Y[MAXN]; vector <int> ans, D[MAXN];

il void brute(int i, int t) {
	int x = X[i];
	if (vis[i]) for (auto v : D[x]) Y[i] += tag[v];
	ll d = (max(Y[i], 0ll) + D[x].size() - 1) / D[x].size();
	if (!d) return vis[i] = -1, ans.eb(i), void();
	for (auto v : D[x]) {
		q[v].emplace(node{d - tag[v], i, t});
		Y[i] -= tag[v];
	} vis[i] = t;
}

int main() {
	read(n, m);
	rep1(i, 1, n) {
		mip[i] = i;
		rep1(j, 2, sqrt(i)) if (i % j == 0) {
			mip[i] = j;
			break;
		}
	} int cnt = 0;
	rep1(i, 1, n) {
		int t = i;
		while (t > 1) D[i].eb(mip[t]), t /= mip[t];
		D[i].resize(unique(begin(D[i]), end(D[i])) - begin(D[i]));
	}
	rep1(i, 1, m) {
		read(op, x, y); y ^= lst;
		if (op == 0) {
			for (auto v : D[x]) tag[v] -= y;
			for (auto v : D[x]) {
				while (q[v].size() && q[v].top().val + tag[v] <= 0) {
					auto [val, id, t] = q[v].top();
					if (vis[id] == t) brute(q[v].top().id, i);
					q[v].pop();
				}
			} sort(begin(ans), end(ans));
			printf("%d ", lst = ans.size());
			for (auto v : ans) printf("%d ", v); puts("");
			ans.clear();
		} else ++cnt, X[cnt] = x, Y[cnt] = y, brute(cnt, i);
	}
	return 0;
}
```

---

## 作者：Ebola (赞：2)

### 题意释义

题目里有一些表述非常不严谨的地方，需要阅读样例才能看出来：

1. 监控器报警后就会消失，不然就 $O(m^2)$ 了。
2. 只有从监控器设立时刻之后，质因数鬼屋的闹鬼总次数达到阈值，才会报警。在设立之前的闹鬼次数不算。

### 做法

每个数的质因数不超过 $6$ 个。

暴力维护 $cnt_p$ 表示编号为 $p$ 的房子的闹鬼次数，每次闹鬼暴力更新。

#### idea 1

- 每次给房子 $p$ 加了闹鬼次数后，暴力枚举所有监控了 $p$ 的监控器，逐个检查是否达到阈值。
- 会被卡成 $O(m^2)$。

#### idea 2

- 给每个房子 $p$ 的监控器按阈值排个序，暴力枚举的时候，只要 $cnt_p$ 没有达到阈值，就直接 `break`。
- 这不对，一个监控器监控了好几个房子，要算**所有被监控的**房子从它安装时刻开始的累积闹鬼次数。

#### idea 3

假设一个监控器监控了 $p_1,...,p_k$，在他的安装时刻，这些房子的已有闹鬼次数是 $st_1,...,st_k$，监控器报警需要满足条件：
$$
\sum_{i=1}^k cnt_{p_i}- st_i \geq y
$$
抽屉原理（鸽巢原理）：至少存在一个 $i$，满足：
$$
cnt_{p_i}-st_i \geq \left\lceil\frac{y}{k}\right\rceil
$$
设置一批 “报警器”：收到警报后，向相应的监控器发送警报。监控器收到警报之后，检查被监控的所有房子是否已经达到阈值。

在房子 $p_i$ 处，设置一个阈值为 $st_i+\left\lceil\frac{y}{k}\right\rceil$ 的 “报警器”

- 监控器报警的前提条件是，至少一个报警器向他发送了报警信号。
- 因为报警器是独立工作的，可以使用 idea2 的优化。

监控器收到报警信号后，有两种可能：

1. 达到阈值，此时输出答案，拆除监控器和对应的报警器。

2. 没有达到阈值，把原来的报警器拆除，放置一批新的报警器。我们假设现在总的累积次数距离 $y$ 还差 $s$，那么报警阈值是：
   $$
   st'_i +\left\lceil\frac{s}{k}\right\rceil
   $$
   $st'_i$ 是报警器发送信号的时刻，各房子的已有闹鬼次数。
   $$
   s < y - \frac{y}{k} = \frac{k-1}{k} y
   $$
   $k\leq 6$，最多乘 $121$ 次。

### 实现

模拟？用 set，每个房子一个 set，里面存所有的报警器。支持：insert、erase、从小到大遍历。

卡常。

用 priority\_queue。需要使用 lazy 删除。

两个 pq 对顶删除？（把要删除的扔进另一个 pq，每次如果原 pq 的 top 和另一个 pq 的 top 相等，就同时 pop）还是会被卡常。

存每个监控器对应的有效报警器的阈值，判断你 pq 里取出来的是不是一个有效阈值，不是就 pop。

复杂度：$m\times 6\times 121\times \log m\approx m \log^3 m$。

---

## 作者：gyyyyx (赞：1)

的确是第一次见折半警报器 trick，顺便也算半个学习笔记了。

最朴素的想法是先把所有数的质因数筛出来，每次闹鬼了就暴力维护会被影响到的房间，然后把每个还没响的监控器单独拎出来，看一下哪些会响。

由于 $2\times 3\times 5\times 7\times 11\times 13\times17>10^5$，所以 $10^5$ 范围内的数字的质因数个数最多只有 $6$ 个，所以暴力维护被影响的房间和对于一个监控器计算其监控到闹鬼次数只是常数级别的。

我们发现每个警报器只会响一次，所以考虑让每个监控器被拎出来的次数尽可能少。

这时就能用折半警报器 trick，将每个监控器的阈值平均分到其能监控到的房间上，若一个房间闹鬼次数达到这个平均阈值，则将这个监控器拎出来判断是否会响。

具体的，若一个监控器的阈值为 $B$，其能监控 $k$ 个房间，则当且仅当 $k$ 个房间中存在一个房间闹鬼次数达到 $\lceil\frac{B}{K}\rceil$ 时才将监控器拎出来。

为什么这样做是对的呢？

首先我们知道对于一个序列 $a_{1\sim n}$，若 $\sum a_i\geq K$，则 $\exist i,a_i\geq \frac{K}{n}$，因此这个 trick 是有正确性的。

但这样的时间复杂度依旧不对。

我们可以考虑如果拎出来的监控器不会响，则将阈值减去已经监控到的闹鬼次数。

这样的话阈值 $B$ 每次会变成 $(1-\frac{1}{k})B$，其中 $k$ 为能监控到的房间数量。

由于 $k\leq 6$，那 $B$ 至少也会变成 $\frac{5}{6}B$，这样的操作最多只有 $\log_{\frac{5}{6}}V$（$V$ 为值域）。

也就是说我们最多只会把一个监控器领出来 $O(\log V)$ 次就能把这个监控器扔掉了。

之后考虑如何实现。

可以对于每个房间开一个优先队列，里面塞会监控到当前房间的监控器，以当前房间闹鬼次数和阈值平均值的差值作为优先级。

然后每次遍历闹鬼的房间，把差值更小的监控器拎出来判断是否会响，会响的扔掉，不会响的把阈值减去闹鬼次数后再塞回去。

注意评论区里的 HACK，要把不会响的监控器先记录下来去重，然后遍历完所有闹鬼房间后一并塞回去。

注意监控器监控到的闹鬼次数是按安装监控器之后开始算的，所以要减去安装之前的闹鬼次数。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 100005
using namespace std;
int n,m,tot,pos[N];
LL c[N],lim[N];
bool ban[N];
vector <int> p[N];
struct Moni{
	int id;LL delta;
	bool operator < (const Moni&x) const {
		return delta>x.delta;
	}
};
priority_queue <Moni> Q[N];
set <int> ans,now;int len;
int main(){
	scanf("%d%d",&n,&m);
	for(int i(2);i<=n;++i)
		if(p[i].empty())
			for(int j(i);j<=n;j+=i)
				p[j].push_back(i);
	while(m--){
		int op,x;LL y;
		scanf("%d%d%lld",&op,&x,&y);y^=len;
		if(op){
			lim[++tot]=y;pos[tot]=x;
			if(!y){ans.insert(tot);continue;}
			LL o((y-1)/p[x].size()+1);
			for(auto k:p[x]){
				lim[tot]+=c[k];
				Q[k].push((Moni){tot,o+c[k]});
			}
		}
		else{
			now.clear();
			for(auto k:p[x]){
				c[k]+=y;
				while(!Q[k].empty()){
					Moni u(Q[k].top());Q[k].pop();
					if(ban[u.id]) continue;
					if(u.delta<=c[k]) now.insert(u.id);
					else{Q[k].push(u);break;}
				}
			}
			for(auto k:now){
            	LL sum(0);
				for(auto t:p[pos[k]]) sum+=c[t];
				if(sum>=lim[k]){
					ban[k]=1;
					ans.insert(k);
				}
				else{
					LL o((lim[k]-sum-1)/p[pos[k]].size()+1);
					for(auto t:p[pos[k]]) Q[t].push((Moni){k,o+c[t]});
				}
			}
			printf("%d",len=ans.size());
			for(auto k:ans) printf(" %d",k);
			puts("");ans.clear();
		}
	}
	return 0;
}
```

---

## 作者：ax_by_c (赞：0)

折半警报器模板题，有更高妙的二进制警报器，然而我不会。/ll

相当于每次给出 $c\le 6$ 个位置问它们从现在开始增加量首次达到某个数的时刻。

注意到 $\sum_{x\in S}a_x\ge y$ 的必要但不充分条件是 $\max a_x\ge \frac{y}{\lvert S\rvert}$。

于是每次操作可以把触发这个条件的阈值放到对应位置的 set 中，每次加的时候把 set 里面被触发的阈值对应条件拿出来暴力判断，如果不合法要重新加进去。

那么每个条件会被判断 $O(\log_{\frac{c}{c-1}}y)$ 次，时间复杂度 $O(mc\log_{\frac{c}{c-1}}y\log m)$。

卡常：

- 快速 IO。

- 实测本题中最好的实现方式不是 set 而是用堆，要对每个数据维护一个时间维度来判断是否合法，时间复杂度会变成 $O(mc\log_{\frac{c}{c-1}}y\log(m\log_{\frac{c}{c-1}}y))$ 但是确实跑得快。

  

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace ax_by_c{
const int MB=1<<20;
struct FastIO{
	char ib[MB+100],*p,*q;
	char ob[MB+100],*r,stk[128];
	int tp;
	FastIO(){p=q=ib,r=ob,tp=0;}
	~FastIO(){fwrite(ob,1,r-ob,stdout);}
	char read_char(){
		if(p==q){
			p=ib,q=ib+fread(ib,1,MB,stdin);
			if(p==q)return 0;
		}
		return *p++;
	}
	template<typename T>
	void read_int(T& x){
		char c=read_char(),l=0;
		for(x=0;!isdigit(c);c=read_char())l=c;
		for(;isdigit(c);c=read_char())x=x*10-'0'+c;
		if(l=='-')x=-x;
	}
	void write_char(char c){
		if(r-ob==MB)r=ob,fwrite(ob,1,MB,stdout);
		*r++=c;
	}
	template<typename T>
	void write_int(T x){
		if(x<0)write_char('-'),x=-x;
		do stk[++tp]=x%10+'0';
		while(x/=10);
		while(tp)write_char(stk[tp--]);
	}
}IO;
typedef long long ll;
const int N=1e5+5;
const int M=10;
bool mk[N];
int p[N],pc,ps[N][M],cc[N];
void Init(int n){
	mk[1]=1;
	for(int i=2;i<=n;i++){
		if(!mk[i])p[++pc]=i;
		for(int j=1;j<=pc&&i*p[j]<=n;j++){
			mk[i*p[j]]=1;
			if(i%p[j]==0)break;
		}
	}
	for(int i=1;i<=pc;i++)for(int j=p[i];j<=n;j+=p[i])ps[j][++cc[j]]=p[i];
}
ll ceildiv(ll x,ll y){
	return x/y+bool(x%y);
}
int n,m,xxs[N];
ll a[N],w[N];
vector<int>zs,ans;
int tt[N];
struct node{
	ll val;
	int id,t_;
	bool operator < (const node &b)const{
		return val>b.val;
	}
};
priority_queue<node>g[N];
void ins(int idx,ll sum){
	tt[idx]++;
	for(int i=1,it=ps[xxs[idx]][i];i<=cc[xxs[idx]];i++,it=ps[xxs[idx]][i])g[it].push({a[it]+ceildiv(w[idx]-sum,cc[xxs[idx]]),idx,tt[idx]});
}
void main(){
	IO.read_int(n),IO.read_int(m);
	Init(n);
	ll y;
	for(int i=1,lst=0,idx=0,op,x;i<=m;i++){
		IO.read_int(op),IO.read_int(x),IO.read_int(y),y^=lst;
		if(op==0){
			ans.clear();
			for(auto it:zs)ans.push_back(it);
			zs.clear();
			for(int i=1,it=ps[x][i];i<=cc[x];i++,it=ps[x][i])a[it]+=y;
			for(int i=1,it=ps[x][i];i<=cc[x];i++,it=ps[x][i]){
				while(g[it].size()&&a[it]>=g[it].top().val){
					auto tmp=g[it].top();
					g[it].pop();
					if(tt[tmp.id]>tmp.t_)continue;
					ll sum=0;
					for(int i=1,it=ps[xxs[tmp.id]][i];i<=cc[xxs[tmp.id]];i++,it=ps[xxs[tmp.id]][i])sum+=a[it];
					if(sum>=w[tmp.id]){
						ans.push_back(tmp.id);
						tt[tmp.id]++;
					}
					else{
						tt[tmp.id]++;
						for(int i=1,cit=ps[xxs[tmp.id]][i];i<=cc[xxs[tmp.id]];i++,cit=ps[xxs[tmp.id]][i])g[cit].push({a[cit]+ceildiv(w[tmp.id]-sum,cc[xxs[tmp.id]]),tmp.id,tt[tmp.id]});
					}
				}
			}
			IO.write_int(lst=ans.size()),IO.write_char(' ');
			sort(ans.begin(),ans.end());
			for(auto it:ans)IO.write_int(it),IO.write_char(' ');
			IO.write_char('\n');
		}
		if(op==1){
			idx++,xxs[idx]=x;
			ll sum=0;
			for(int i=1,it=ps[x][i];i<=cc[x];i++,it=ps[x][i])sum+=a[it];
			if(!y){
				zs.push_back(idx);
				continue;
			}
			w[idx]=sum+y;
			ins(idx,sum);
		}
	}
}
}
int main(){
	ax_by_c::main();
	return 0;
}
```

---

## 作者：xxxxxzy (赞：0)

神奇 trick。

如果 $\sum\limits_{i=1}^n a_i = w, \max\limits_{i-1}^k a_i \ge \left \lfloor \dfrac{w}{k} \right \rfloor $。

那么对每个质数维护一个堆，设 $w$ 为监视器 $x$ 的阈值，$s$ 为 $x$ 的质因子个数，然后每次如果闹鬼次数到达了 $\left \lfloor \dfrac{w}{s} \right \rfloor$，那么就暴力更新这个堆，并更新阈值。

考虑这么做为什么是对的，每次阈值都至少会变为原来的 $\dfrac{s-1}{s}$，所以复杂度是对的。

时间复杂度 $O(nk \log n \log V)$，$k$ 为质因子个数。

---

## 作者：Grisses (赞：0)

[题面](https://www.luogu.com.cn/problem/P7603)

---

根据学长的讲题找到这里。

看懂了，记一下。

---

减半报警器。

考虑到如果 $\sum\limits_{i=1}^ka_i=S$，则有 $\max\limits_{i=1}^ka_i\ge \left\lceil\dfrac{S}{k}\right\rceil$。证明是显然的。

注意到 $10^5$ 以内的数最多只有 6 个质因子，我们考虑对所有质数暴力维护闹鬼的次数，并且及时检查警报器的状态。

具体而言，我们假设一个警报器监视的集合为 $d$，报警的阈值为 $y$。由之前的结论，如果某个 $x\in d$ 的房子在其开始监测后闹鬼次数达到了 $\left\lceil\dfrac yd\right\rceil$ 时我们就计算 $s=\sum\limits_{x\in d}\Delta cnt_x$ 并检查一下这个监测器会不会报警。如果发现并没有达到阈值，就将 $y$ 减小，更新对应的阈值（相当于加入一个阈值比之前少 $s$ 的监测器）。这样的话每次阈值都会至少变成原来的 $\dfrac {k-1}k$，所以一个监测器不成功的检查最多 $\log$ 次。

具体实现就是对于每个质数维护一个堆来记录监测这里的所有监测器的阈值。每次更新后暴力取出所有阈值小于目前 $cnt$ 的检查即可。

---

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans;
bool f[100005];
vector<int>d[100005];
void ss(){//筛质数
	for(int i=2;i<=100000;i++){
		if(!f[i]){
			for(int j=i;j<=100000;j+=i){
				f[j]=1;
				d[j].push_back(i);
			}
		}
	}
}
struct node{
	int val,id,tim;
	bool operator<(const node &t)const{return val>t.val;}
};//记录一个加到堆中的阈值的值、对应的监测器以及是否失效
priority_queue<node>q[100005];
int las[100005],tag,num,cnt[100005],a[100005],b[100005],stp[100005];
vector<int>res,zer;
void Sol(node x){//检查一个监测器
	int p=x.id;
	if(las[p]==-1)return;//已报警
	int sum=0;
	for(int v:d[a[p]])sum+=cnt[v];//计算s
	if(sum>=stp[p]+b[p]){//报警了
		res.push_back(p);
		las[p]=-1;
		return;
	}
	b[p]=stp[p]+b[p]-sum;//更新阈值
	stp[p]=sum;//当前值
	las[p]=++tag;//现在使用最新的阈值
	int s=d[a[p]].size(),l=(b[p]+s-1)/s;
	for(int v:d[a[p]]){
		q[v].push(node({cnt[v]+l,p,tag}));
	}
}
void ch(int x){//检查一个堆
	while(!q[x].empty()&&q[x].top().val<=cnt[x]){
		node tmp=q[x].top();
		q[x].pop();
		if(las[tmp.id]!=tmp.tim)continue;//不是最新的
		Sol(tmp);
	}
}
signed main()
{
	ss();
	scanf("%lld%lld",&n,&m);
	int op,x,y;
	while(m--){
		scanf("%lld%lld%lld",&op,&x,&y);
		y^=ans;
		if(op){
			int s=d[x].size();
			int l=(y+s-1)/s;
			tag++;
			num++;
			if(y==0){
				zer.push_back(num);
				continue;
			}
			a[num]=x;
			b[num]=y;
			las[num]=tag;
			for(int v:d[x]){
				stp[num]+=cnt[v];
				q[v].push(node({cnt[v]+l,num,tag}));
			}
		}
		else{
			res.clear();
			for(int v:zer)res.push_back(v);
			zer.clear();
			for(int v:d[x])cnt[v]+=y;
			for(int v:d[x])ch(v);
			sort(res.begin(),res.end());
			ans=res.size();
			printf("%lld ",ans);
			for(int v:res)printf("%lld ",v);
			puts("");
		}
	}
	return 0;
}
```

---


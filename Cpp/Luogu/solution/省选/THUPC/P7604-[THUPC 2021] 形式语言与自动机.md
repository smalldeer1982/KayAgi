# [THUPC 2021] 形式语言与自动机

## 题目背景

《形式语言与自动机》是 T 大学 C 系开设的一门专业基础课，在这门课程中，你能学到“常用语言类及其相应的计算模型，以及计算模型之间的联系”。这门课程涉及到不少较为晦涩难懂的理论知识；但对于你的好朋友，曾经在国际比赛中捧杯的小 A 来说，它似乎有些太简单了。

## 题目描述

不知道为什么，小 A 虽然上课总在做自己的事情，但是每次布置的作业他用了十几分钟就做完了。你很好奇小 A 为什么这么熟练，但眼下，小 A 上课做的事情似乎更吸引你。

“你每周上课都不认真听，是在做什么？”

“我觉得老师上课讲得还挺水的，就随便做点东西玩玩。不过充其量也就是跟课程相关的吧，随便设计点自动机什么的，测试一下它能接受什么状态。”小 A 盯着他电脑前的草稿纸说道。

过了一会，小 A 看到他屏幕上出现了一堆圆括号。你猜想他可能是设计了一个判断括号序列是否匹配的自动机。但正当你准备和小 A 搭话时，他突然指着屏幕对你说：“你说说这合理吗，我本来输了一个测试用的括号序列，结果手一滑，把光标蹭到了奇怪的地方。我就想着怎么看半天没看出来程序哪里有问题，原来是我输错了。”

你苦笑着回复说：“这不常有的事吗，反正知道问题在哪就好了。”

没想到，这句话反而让小 A 更烦躁了。

“你说常有，那我给你这个串，你试试有多少种方法把它变回一个合法的括号序列。”

诚然，你不是不会算，但是你更想听课。可惜，你没来得及打断小 A 的下一句话。

“那就这么说定了，你要是下课前没算出来，请我吃香锅。”

## 说明/提示

**【样例解释】**

所有可能的还原方案为（其中箭头前后分别为 $s=u+v+w$ 和 $uwv$）：

1. $l=0,r=2$，对应 $\varepsilon$（空串，下同）$+$`()`$+$`()()` $\Rightarrow$ `()()()`；
2. $l=0,r=4$，对应 $\varepsilon+$`()()`$+$`()`$\Rightarrow$`()()()`；
3. $l=1,r=2$，对应 `(`$+$`)`$+$`()()`$\Rightarrow$`(()())`；
4. $l=1,r=4$，对应 `(`$+$`)()`$+$`()`$\Rightarrow$`(())()`；
5. $l=2,r=4$，对应 `()`$+$`()`$+$`()`$\Rightarrow$`()()()`；
6. $l=3,r=4$，对应 `()(`$+$`)`$+$`()`$\Rightarrow$`()(())`。

这些划分方案中，方案 $1,2,5$ 还原出的串和输入的串相同，但这并不影响它们划分的方式不同。

另外，`()()`$+$`()`$+\varepsilon$ 和 `()()`$+\varepsilon+$`()` 都不是合法的还原方案，因为在前一种划分中 $w=\varepsilon$，而在后一种划分中 $v=\varepsilon$。

**【数据范围】**

对于 $100\%$ 的数据，保证 $1\le |s| \le 10,000,000$。

**【提示】**

你不需要掌握《形式语言与自动机》这门课程的相关知识也能通过本题。

另外，《形式语言与自动机》这门课程“很简单”的说法只是本题中虚构人物小 A 的看法，不代表出题人的意见。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_0/tree/master](https://github.com/yylidiw/thupc_0/tree/master) 查看。

## 样例 #1

### 输入

```
()()()```

### 输出

```
6```

# 题解

## 作者：约瑟夫用脑玩 (赞：4)

这里是出题人为喜欢线性做法的选手提供的其中一种将复杂度优化到线性的算法。

令 $f(t)=\sum_{i=1}^{|t|}1-(2\times[t_i=\text{)}])$，也就是 $t$ 串中左括号减去右括号的数量。

一个串 $t$ 是合法的括号序列当且仅当其每个前缀对应的 $f$ 都非负，且整个串 $f(t)=0$。

$f(s=uvw)=0$ 题目已经保证了，故有 $f(uwv)=0$，考虑如何使得 $\forall i\le|uwv|,f(uwv_{i})\ge 0$。

一个 key thought 就是把 $uwv$ 分为 $uw$ 的前缀和 $v$ 这个后缀分别考虑，基于一个显然的事实是 $f(uwv)=0$，若 $uw$ 为合法前缀且 $v$ 为合法后缀，则 $uwv$ 为合法括号序。

转化为如下限制：

- $u$ 为合法前缀，要求 $\forall i\le|u|,f(u_i)\ge 0$。
- $v$ 为合法后缀，要求 $\forall i\le|v|,f(v_{|v|})-f(v_{i})\le 0$。
- $uw$ 为合法前缀，要求 $\forall i\le|w|,f(u_{|u|})+f(w_i)\ge 0$。

令 $S(i)=f(s_i)$，即特指给定串 $s$ 的前缀和，$l=|u|,r=|u|+|v|$，即在 $l,r$ 处划分 $u,v,w$ 串，这里与题目定义相同。

以上限制可以用 $S,l,r$ 来表示：

- 题目定义：$0\le l<r<n$。
- $u$ 为合法前缀，要求 $\forall i\le l,S(i)\ge 0$。
- $v$ 为合法后缀，要求 $\forall l<i\le r,S(r)\le S(i)$。
- $uw$ 为合法前缀，要求 $\forall r<i,S(l)+S(i)-S(r)\ge 0$。

题目定义为第零个限制，第一个限制是简单的，第二个限制与 $l$ 的位置有关，第三个限制与 $S(l)$ 有关。

先处理第三个限制，令 $d(r)=\min_{i>r} S(i)-S(r)$，则第三个限制转化为 $S(l)+d(r)\ge 0$，即 $S(l)\ge -d(r)$。

考虑对每个 $r$ 计数有多少个 $l$ 合法，前三个限制都只与位置有关，如果直接当做偏序限制使用二维数点，~~虽然被出题人放过了~~，显然没有利用到限制本身的优秀性质。

考虑依次加入点 $(i,S(i))$，在加入 $i$ 前计数 $0\sim i-1$ 作为 $l$ 对 $r=i$ 的贡献，这样满足了第零个限制。

记录一个变量 $flag=\prod_i[S(i)\ge 0]$，作为加入每个点的贡献，这样就满足了第一个限制。

重要的是第二个限制，考虑维护一条条的分支链，分支链的每个位置代表贡献限制相同的点 $\{(x,S(x))\}$ 的集合。

实际上我们并不关心集合里有哪些点，故只需记录其大小，由于第三个限制，故每个位置的 $S$ 相同。

故每个位置可以用一个二元组 $(S,\{S\})$，表示其 $S$ 与集合大小，来代表这个位置，对限制的满足还体现在它位于哪个分支链上，实际上它在分支链的位置上具体是按其 $S$ 顺序连接的，这样是方便处理限制三的询问的。

每条分支链的起点的 $S=\min_{l<i\le r}S(i)$，满足了第二个限制，这样就满足了所有限制，我们只需要对分支链位置的集合大小做一个后缀和，就可以快速回答第三个限制的询问了。

以下是对算法流程的描述：考虑由 $i-1\to i$ 分支链的变化，如果 $S\to S+1$，那么上一个维护的分支链被留在了起点为 $(i-1,S(i-1))$ 所属集合的位置，此时相当于在**预构一条新的分支链**。

如果 $S\to S-1$，那么当前的分支链就**处于构建的状态**，也就是正在变长，起点正在前移，我们只需维护后缀和即可，如果 $S-1$ 那里有以前的一条分支链，我们需要支持将当前的分支链合并到以前的分支链上。

为了做到线性，对于留下上一条分支链和预构新分支链，以及合并到上一条分支链**都不应与上一条分支链的大小有关**，我们需要 $O(1)$ 实现。

同时预构新分支链和合并分支链**都应该只与当前分支链的大小有关**，这样才能进行势能分析，最后总复杂度 $O(n)$。

放了完整的[代码](https://www.luogu.com.cn/paste/qdl4387p)，方便对拍，但算法流程讲了就没写注释，看不懂可以直接询问。

实现细节：对于初状态，我们可以放一条 $(S=0,\{S\}=1),(S=1,\{S\}=0)$ 的分支链。

如果怕挂可以先放一条 $(S=0,\{S\}=1),(S=1,\{S\}=0),(S=2,\{S\}=0),\cdots,(S=n,\{S\}=0)$ 的分支链，然后再改回来。（实际不一定能避免什么可能挂的地方，而且不改回来常数加倍）

维护了后缀和后，为了处理询问，我们应维护出分支链的终点，注意到其构建变长的过程中变化的是起点，故终点不变，只用在合并时处理即可。

---

## 作者：Time_tears (赞：3)

这里是出题人点名放过的 $O(n\log n)$ 做法。

考虑 $uwv$ 在什么时候合法，需要满足三个条件。
1. $u$ 中不存在前缀使得缩括号后为 $‘)’$ 
2. $v$ 中不存在后缀使得缩括号后为 $‘(’$
3. $u$ 缩完括号后 $‘(’$ 的数量大于等于 $w$ 缩完括号后 $‘)’$ 的数量

这里解释一下第 $3$ 条，若 $u$ 缩完括号后 $‘(’$ 的数量小于 $w$ 缩完括号后 $‘)’$ 的数量，则 $uw$ 缩完括号后必定存在前缀满足缩完括号后为 $‘)’$，此时不合法。

知道合法条件后就很好做了，注意到 $u$ 的位置在前后都是不变的，所以 $l,r$ 中影响更大的肯定是 $r$，考虑枚举 $r+1$。

第一个条件 $\Leftrightarrow$ 找到最小的 $L_0$ 使得 $[1,L_0]$ 缩括号后为 $‘)’$，$l<L_0$

第二个条件 $\Leftrightarrow$ 找到对于每个 $r$ 的最大的 $f_r$ 使得 $[f_r,r-1]$ 缩括号后为 $‘(’$，$l\geqslant r_0$

第三个条件 $\Leftrightarrow$ 求出 $[r+1,n]$ 中缩完括号后 $‘)'$ 的数量记为 $S$，则要满足 $[1,l-1]$ 中缩完括号后 $‘(’$ 的数量大于等于 $S$。

所以对于每个 $r$，合法的 $l$ 本质上是一个二维数点，扫描线+树状数组即可。

实现上由于边界情况较多，大家自己推一下，这里放一份参考代码。

```cpp
#include<bits/stdc++.h>
#define N 10000005
using namespace std;
char s[N];
int n,sum,S0,cnt,f[N],L,c[N],h[N],nx[N<<1],to[N<<1],vl[N<<1],Q[N];
inline void Add(int x) {if(++sum,!x)return ++S0,void();for(; x<=n; x+=x&-x)++c[x];}
inline int Ask(int x,int ans=S0) {if(x<0)return 0;for(; x; x-=x&-x)ans+=c[x];return ans;}
void Add(int x,int y,int z) {nx[++cnt]=h[x],to[h[x]=cnt]=y,vl[cnt]=z;}
int main() {
	scanf("%s",s+1),n=strlen(s+1),L=n;
	for(int i=1,S=0; i<=n; ++i) {
		if(s[i]=='(')++S,f[i]=i;else --S,f[i]=f[i-1]-1<0?0:f[f[i-1]-1];
		if(S<0&&L==n)L=i-1;
	}
	for(int i=n,S=0; i>=1; --i) {
		if(s[i]==')')++S;else S=(--S<0)?0:S;
		if(f[i-1]<i-1&&f[i-1]<=L){if(f[i-1]>=1)Add(f[i-1]-1,S,-1);Add(min(L,i-2),S,1);}
	}
	long long ans=0;Add(0);for(int j=h[0]; j; j=nx[j])ans+=vl[j]*(sum-Ask(to[j]-1));
	for(int i=1,S=0; i<=L; ++i) {
		if(s[i]=='(')++S;else --S;Add(S);
		for(int j=h[i]; j; j=nx[j])ans+=vl[j]*(sum-Ask(to[j]-1));
	} cout<<ans;
	return 0;
}
```


---

## 作者：g1ove (赞：0)

# P7604
给出一个长度为 $n$ 的括号序列 $T$，求有多少种划分方案，使得 $T=uvw$，且 $uwv$ 是合法括号序列。

$n\le 10^7$。
## Solution 1

将 `(` 看做 `1`，`)` 看做 `-1`，考虑一个括号串合法的充要条件：

+ 总和为 $0$
+ 所有前缀和均不小于 $0$

问题转化为：给你一个 $-1,1$ 序列，问你将 $uvw$ 变成 $uwv$ 有多少种和法情况。

形式化的，令前缀和数组为 $s$，求满足条件的二元组 $(l,r) $ 个数：

+ $0\le l<r<n$ ①
+ $\min s_{r+1\sim n}-s_r+s_l\ge 0$ ②
+ $\min s_{l+1\sim r}+s_n-s_r\ge 0$ ③
+ $\min s_{1\sim l}\ge 0$ ④

容易找到最大的 $\text{last}$ 满足 $\min s_{1\sim \text{last}}\ge 0$ 可以处理限制④。

考虑从左往右扫 $r$，我们题目保证 $s_n=0$，将③整理一下，不难发现整理完合法的 $l$ 是一段区间，记 $p$ 为最后一个合法的 $l$。

现在转化为：

+ $\min s_{r+1\sim n}-s_r+s_l\ge 0$
+ $l\ge p$
+ $l \le \text{last}$
+ $0\le l<r<n$

$l\in[p,\text{last}]$ 不好处理，考虑差分，转化为问题 $[0,p-1]$ 和 $[0,\text{last}]$ 最后作差即可。 

记 $c_r=s_r - \min s_{r+1\sim n}$。

那么问题转化为在 $\forall x\in[1,pos],s_x\ge c_r$ 的 $x$ 个数。

### Part 1:$O(n\log n)$
怎么找 $p$ 呢？可以把 $s$ 的所有数从大往小扫用并查集找到即可。

最后统计二维数点使用 BIT 即可。

时间复杂度 $O(n\log n)$。
### Part 2:$O(n)$
此做法依赖 $s_i-s_{i-1}\in\{1,-1\}$ 的性质。

不难发现函数 $s$ 是连续的，因此有非常优美的性质。画出来就是一条连续的线段，且 $\forall s_i\in[-\frac{n}{2},\frac{n}{2}]$。

怎么找 $p$ 呢？只需要找到 $r$ 之前最后一个出现的 $s_r-1$ 即可，然后考虑下一位是升还是降，就可以快速找到位置或者判断没有位置。

那么怎么求二维数点呢？我们开一个答案桶。假设有两个位置 $p_1,p_2$ 满足 $s_{p_1}=s_{p_2}$，那么我们只需要判断这一段是上升的还是下降的就可以判断这一段要不要统计进答案。最后再处理最后一个数到当前数的答案就行。

注意不要用 `vector` 存差分，效率很低，用链表即可。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned ll
#define pb emplace_back
#define ls(u) tr[u].l
#define rs(u) tr[u].r
#define fi first
#define se second
#define mp make_pair
#define N 10000005
using namespace std;
char t[N];
int n,s[N],suf[N],last;
ll res;
int tmp[N*2],*lst=&tmp[N],t2[N*2],*sum=&t2[N];
int head[N],tot=1;
struct edge{
	int next,w,c;
}e[N*2];
void add(int u,int w,int c)
{
	e[tot]=(edge){head[u],w,c};
	head[u]=tot++;
}
int main()
{
	scanf("%s",t+1);
	n=strlen(t+1);
	for(int i=1;i<=n;i++) s[i]=s[i-1]+(t[i]=='('?1:-1);
	suf[n+1]=N;last=n-1;
	for(int i=n;i>=1;i--) suf[i]=min(suf[i+1],s[i]);
	for(int i=1;i<=n;i++) if(s[i]<0) {last=i-1;break;}
	memset(tmp,-1,sizeof tmp);
	lst[0]=0;
	for(int i=1;i<n;i++)//R 
	{
		int p=lst[s[i]-1];
		if(p==-1)
		{
			if(s[i]<=0) p=0;
		}
		else
		{
			if(s[p+1]==s[p]+1){++p;}
			else p=-1; 
		}
		lst[s[i]]=i;
		if(p>last||p==-1) continue;
		if(p) add(p-1,s[i]-suf[i+1],-1);
		add(min(last,i-1),s[i]-suf[i+1],1);
	}
	memset(tmp,-1,sizeof tmp);
	memset(t2,0,sizeof t2);
	for(int i=0;i<n;i++)
	{
		sum[s[i]]++;
		if(s[lst[s[i]]+1]==s[i]+1) sum[s[i]]+=i-lst[s[i]]-1;
		lst[s[i]]=i;
		for(int x=head[i];x;x=e[x].next)
		{
			int all=sum[e[x].w];
			if(s[i]>=e[x].w) all+=i-lst[e[x].w];
			res+=all*e[x].c;
		}
	}
	printf("%lld",res);
	return 0;
}
```

---


# [THUPC 2021] 游戏

## 题目描述

小 C 和小 W 两个人打算玩一局双人博弈游戏。

现在小 C 手里有 $n$ 颗相同的石子，小 W 打算把它们分为有顺序的 $m$ 堆，其中第 $i$ 堆石子的数量不能超过 $a_i$，但允许为 $0$。

随后，由小 C 先手，两人轮流进行操作，每次可以选择一堆非空的石子并拿走其中若干个（至少 $1$ 个），无法操作者输。

作为算法竞赛界的老司机，小 C 和小 W 早已对各种游戏的策略摸得门儿清，于是这次他们打算玩点不一样的：他们想要知道，有多少种分石子的方法能使得小 C 有必胜策略。

## 说明/提示

**【样例解释】**

以下 $4$ 种方案是符合题意的：$(0,2,4)$、$(1,1,4)$、$(2,0,4)$、$(2,2,2)$。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_2/tree/master](https://github.com/yylidiw/thupc_2/tree/master) 查看。

## 样例 #1

### 输入

```
6 3
2 3 4
```

### 输出

```
4
```

# 题解

## 作者：Time_tears (赞：5)

Nim游戏先手必胜当且仅当所有石子的 Xor 非 0。

也就是说我们要求的是：把n个石子分成m堆，每堆不超过上限且 Xor 非 0 的方案数

而这个东西不太好求，可以转换为求：总方案数-每堆不超过上限且 Xor 为 0 的方案数

总方案数：
$$\sum\limits_{S}(-1)^{|S|}\times\binom{n-\sum_{i\in S}(a_i+1)+m-1}{m-1}$$
直接 $2^m$ 枚举子集即可。

考虑怎么求堆不超过上限且 Xor 为 0 的方案数，容易想到数位 Dp，只不过我们现在需要把 $m$ 堆是否顶着上限都要压入状态中。

所以设：$f_{i,s,j}$ 表示从高到低 Dp 到第 $i$ 位，目前被卡上界的集合是 $s$，低位向这一位进位 $j$ 次，注意 $j$ 的范围只能是 $0\to m-1$。

考虑直接枚举每一个数在这一位填 $0/1$，复杂度约为 $O(4^mm\log n)$，应该无法通过。

注意到我们只需要枚举目前还顶着上界的，没顶着上界的只需要枚举有几个 $1$ 再乘上组合数即可，这样复杂度就降为了 $O(3^mm^2\log n)$，代码颇多细节。

```cpp
#include<bits/stdc++.h>
#define N 11
#define ll long long
using namespace std;
const int mod=998244353;
ll n,a[N];
int m,S,c[N][N],f[2][1<<N][N],num[1<<N],cnt[1<<N],t[1<<N][2],tot;
inline int Mod(int x) {return x<mod?x:x-mod;}
inline void Add(int&x,int y) {x=Mod(x+y);}
inline int Ksm(int a,int n,int ans=1) {for(; n; n>>=1,a=1ll*a*a%mod)if(n&1)ans=1ll*ans*a%mod;return ans;}
int C(ll a,int b,int ans=1) {for(int i=1; i<=b; ++i)ans=1ll*ans*((a-i+1)%mod)%mod*Ksm(i,mod-2)%mod;return ans;}
inline int Solve1(int ans=0) {
	for(int i=0; i<(1<<m); ++i) {
		int opt=1;ll S=0;
		for(int j=0; j<m; ++j)if(i>>j&1)opt=-opt,S+=a[j]+1;
		if(S<=n)ans=Mod(Mod(ans+opt*C(n-S+m-1,m-1))+mod);
	} return ans;
}
inline int Solve2(int ans=0) {
	if(n&1)return 0;
    int nw=0;f[nw][S=(1<<m)-1][0]=1;
    for(int i=59; ~i; --i) {
    	nw^=1;for(int j=0; j<=S; ++j)for(int k=0; k<m; ++k)f[nw][j][k]=0;
		for(int j=0,tmp; j<=S; ++j)
			for(int k=0; k<m; ++k)if(tmp=f[nw^1][j][k]) {
    			int ct=0;for(int l=0; l<m; ++l)ct+=!(j>>l&1);
				for(int l=j,bj,num; 1; l=(l-1)&j) {
					bj=1;for(int r=0; r<m; ++r)if((j>>r&1)&&!(l>>r&1)&&!(a[r]>>i&1))bj=false;
					if(bj) {
						for(int r=num=0; r<m; ++r)if((j>>r&1)&&(l>>r&1)&&(a[r]>>i&1))++num;
						for(int r=num&1,A; r<=ct; r+=2)
							if((r+num>>1)<=k&&(A=(k-((r+num)>>1)<<1)+(n>>i&1))<m)Add(f[nw][l][A],1ll*tmp*c[ct][r]%mod);
					} if(!l)break;
				}
			}
	}
	for(int j=0; j<=S; ++j)ans=Mod(ans+f[nw][j][0]);return ans;
}
int main() {
	cin>>n>>m;
	for(int i=0; i<m; ++i)cin>>a[i];
	for(int i=0; i<=m; ++i)c[i][0]=1;
	for(int i=1; i<=m; ++i)for(int j=1; j<=i; ++j)c[i][j]=Mod(c[i-1][j]+c[i-1][j-1]);
	cout<<Mod(Solve1()-Solve2()+mod);
	return 0;
}
```

---

## 作者：MiniLong (赞：0)

### P7609

[题目链接](https://www.luogu.com.cn/problem/P7609)

输的充要条件是异或和为 $0$，就是每个位置有偶数个 $1$。总和为 $n$，且每个数有上界，考虑数位dp。设 $f_{i,st,j}$ 为从最高到 $i$ 这一位，一直顶着上界的还有 $st$ 这些数，且前面退位到有 $j$ 个 $2^i$。显然最后这个 $j$ 要为 $0$，但每次因为最多 $j \leftarrow 2j-m$，所以 $j$ 的上界是 $2m-1$。转移枚举 $st$ 的子集 $st'$，有 $f_{i,st,j} \binom{\sum\limits_{x\notin st}[a_{x,i} =1]}{t-\sum\limits_{x\in st'} [a_{x,i}=1]} [\forall x\in st ,x\notin st',a_{x,i}=1] \to f_{i-1,st',2j+[n_{i-1}=1]-t}$，最后用总方案数（容斥可得）减去就行。复杂度为 $\Theta(3^m m^2 \log n)$，但是显然跑不满。

---

## 作者：Jsxts_ (赞：0)

由 Nim 游戏的获胜条件得出，我们要求的就是总方案数减去所有数异或和为 $0$  的方案数。

其中后者可以用经典的 dp 套路求解：设 $f_{i,j,k}$ 表示当前考虑到第 $i$ 位，其中每个数填的前 $i$ 位是否大于其对应上界的前 $i$ 位，上一位对这一位的进位为 $k$（这个是对于所有数之和为 $n$ 而记录的）。转移就直接枚举这一位每个数填什么，然后记搜转移。这样复杂度为 $O(2^{2m}m^2\log n)$，直接写不太能过，但是加上一些剪枝（具体看代码）可以跑到 500ms。

现在考虑总方案数怎么求，直接仿照上面的方法剪枝是怎么也过不去的，考虑用容斥，钦定其中一个集合 $S$ 满足其中数 $>a_i$，即先各自放 $a_i+1$ 个，然后剩下的问题就是 $n$ 个相同的数划分到 $m$ 个不同集合中，直接隔板法。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 10;
const int inf = 1e9;
const ll INF = 1e18;
ll read() {
	ll s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-'? -1 : 1, ch = getchar();
	while(isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();
	return s * f;
}
const int mod = 998244353;
int f[60][1 << N][10],pop[1 << N],c[1 << N],tt;
ll n,m,a[N + 10];
int dfs(int x,int fl,int jw) {
	if (x == 60) return !fl && !jw;
	if (~f[x][fl][jw]) return f[x][fl][jw];
	int res = 0;
	for (int i = 1;i <= tt;i ++ ) {//异或和为0说明这一位为1的是偶数个。 
		int nfl = 0,njw = pop[c[i]] + jw;
		if ((njw >> 1 & 1) != (n >> x + 1 & 1)) continue;//由上面知道进到下一位后也会加上一个偶数，又要和n的第x+1位相同，所以进位的奇偶性要和n的第x+1位相同。 
		for (int j = 0;j < m;j ++ ) {
			int y = c[i] >> j & 1,z = a[j] >> x & 1;
			nfl |= (!(!y && z) & ((fl >> j & 1) && y == z) | (y && !z)) << j;
		}
		res = (res + dfs(x + 1,nfl,njw >> 1)) % mod;
	}
	return f[x][fl][jw] = res;
}
int qpow(int a,int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = 1ll * res * a % mod;
		b >>= 1, a = 1ll * a * a % mod;
	}
	return res;
}
int C(ll n,int m) {
	if (n < m) return 0;
	int r1 = 1,r2 = 1;
	for (ll i = n;i >= n - m + 1;i -- ) r1 = 1ll * r1 * (i % mod) % mod;
	for (int i = 1;i <= m;i ++ ) r2 = 1ll * r2 * i % mod;
	return 1ll * r1 * qpow(r2,mod - 2) % mod;
}
int main() {
	n = read(), m = read();
	for (int i = 0;i < m;i ++ ) a[i] = read();
	for (int i = 0;i < 1 << m;i ++ ) {
		pop[i] = __builtin_popcount(i);
		if (pop[i] % 2 == 0) c[++tt] = i;
	}
	memset(f,-1,sizeof f);
	int ans;
	if (n % 2 == 0) ans = (mod - dfs(0,0,0)) % mod;
	else ans = 0;
	for (int i = 0;i < (1 << m);i ++ ) {
		ll tn = n;
		for (int j = 0;j < m;j ++ ) if (i >> j & 1) tn -= a[j] + 1;
		if (tn < 0) continue;
		ans = (ans + 1ll * (__builtin_popcount(i) % 2 ? mod - 1 : 1) * C(tn + m - 1,m - 1)) % mod;
	}
	cout << ans;
	return 0;
}
```


---


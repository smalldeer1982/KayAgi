# [THUPC 2023 初赛] 背包

## 题目描述

本题中，你需要解决完全背包问题。

有 $n$ 种物品，第 $i$ 种物品单个体积为 $v_i$、价值为 $c_i$。

$q$ 次询问，每次给出背包的容积 $V$，你需要选择若干个物品，每种物品可以选择任意多个（也可以不选），在选出物品的体积的和**恰好**为 $V$ 的前提下最大化选出物品的价值的和。你需要给出这个最大的价值和，或报告不存在体积和恰好为 $V$ 的方案。

为了体现你解决 NP-Hard 问题的能力，$V$ 会远大于 $v_i$，详见数据范围部分。

## 说明/提示

#### 样例解释 1

第二组询问的最优方案为：选择 $3$ 个物品 $1$ 和 $12499999998$ 个物品 $2$。

#### 子任务

对于所有测试数据，$1 \le n \le 50, 1 \le v_i \le 10^5, 1 \le c_i \le 10^6, 1 \le q \le 10^5, 10^{11} \le V \le 10^{12}$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 2
6 10
8 15
100000000001
100000000002
```

### 输出

```
-1
187500000000
```

# 题解

## 作者：Alex_Wei (赞：139)

[cnblogs](https://www.cnblogs.com/alex-wei/p/17531487.html)

众所周知，在同余最短路算法中，我们选取基准物品的体积作为模数 $m$，并对其它物品的体积 $v_i$ 和所有 $0\leq j < m$，从 $j$ 向 $(j + v_i)\bmod m$ 连权值为 $v_i$ 的边，跑最短路。

### 算法介绍

不要从图论的角度考虑问题，而是回归本源：体积模 $m$ 意义下的完全背包。对于体积为 $v_i$ 的物品，它在长度为 $m$ 的环上形成 $d = \gcd(v_i, m)$ 个子环。从一个点出发，不可能绕着子环走一圈再转移回到该点，因为最短路不会经过同一个点两次，否则存在负环。如果重复经过同一个点，那么可以将这两次经过之间加入的所有物品替换为若干基准物品。

因此，往背包加入体积为 $v_i$ 的物品时，至多加入 $\frac {m} {\gcd(v_i, m)} - 1$ 个。对于每一个子环，我们绕着这个环转两圈，即可考虑到所有转移，因为每个点都转移到了子环上其它所有点。时间复杂度 $\mathcal{O}(nm)$。

对于普通的完全背包，即边权等于 $v_i$ 的问题，我们找到子环上权值最小的点，绕着环转移一圈即可（[daklqw](https://daklqw.blog.luogu.org/solution-p2371)）。但是写起来不如转两圈简洁。

### 例题

#### [P2371 墨墨的等式](https://www.luogu.com.cn/problem/P2371)

以下是经典同余最短路问题「墨墨的等式」的转圈代码。它是普通的完全背包。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 5e5 + 5;
int n, m, a[N], _a[N];
long long f[N], l, r, ans;
int main() {
  cin >> n >> l >> r;
  for(int i = 1; i <= n; i++) {
    cin >> a[i];
    if(!a[i]) n--, i--;
  }
  if(!n) cout << "0\n", exit(0);
  memset(f, 0x3f, sizeof(f)), f[0] = 0;
  sort(a + 1, a + n + 1), m = a[1];
  for(int i = 1; i <= n; i++) _a[i] = a[i] % m; // 避免多次取模常数太大
  for(int i = 2; i <= n; i++) {
    for(int j = 0, lim = __gcd(a[i], m); j < lim; j++) {
      for(int t = j, c = 0; c < 2; c += t == j) {
        int p = t + _a[i];
        if(p >= m) p -= m;
        f[p] = min(f[p], f[t] + a[i]), t = p;
      }
    }
  }
  for(int i = 0; i < a[1]; i++) {
    if(r >= f[i]) ans += max(0ll, (r - f[i]) / a[1] + 1);
    if(l > f[i]) ans -= max(0ll, (l - 1 - f[i]) / a[1] + 1);
  }
  cout << ans << endl;
  return 0;
}
```

#### [P9140 背包](https://www.luogu.com.cn/problem/P9140)

本题在完全背包的可行性基础上加入了权值这一维度。

如果我们将 $\frac {c_i}{v_i}$ 最大的物品选做基准物品，设其体积为 $m$，价值为 $w$，那么同样不会经过同一个点，原因是类似的：将一部分其它物品替换为若干基准物品，以最大化单位体积贡献的价值。

对于两组背包方案 $(V_1, C_1)$ 和 $(V_2, C_2)$，若 $V_1\equiv V_2\pmod m$，该如何衡量这两组方案的优劣呢？

对于一组背包方案 $(V', C')$ 和一次查询 $V$，若 $V'\equiv V\pmod m$ 且 $V' \leq V$，则其权值为 $C' + \frac {V - V'} mw$。因此，对于相同剩余系的所有背包方案 $(V', C')$，我们希望最大化 $C' - \lfloor\frac {V'} {m}\rfloor w$，转化为图论就是最长路的 $dist$。也就是说，当加入物品 $(v_i, c_i)$ 从 $p$ 转移到 $q = (p + v_i)\bmod m$ 时，用于更新 $f_q$ 的值为 $f_p + c_i - \lfloor \frac {p + v_i} {m}\rfloor w$。

根据 $\frac {w} {m}$ 的最大性，这样一张包含正负权边的图上不存在正权环（求最长路）。又因为不经过重复点，所以每组剩余系的最优方案对应的 $V'$ 不超过 $m ^ 2$ 即 $10 ^ {10}$，配合 $V\geq 10 ^ {11}$ 的限制保证了正确性。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
constexpr int N = 1e5 + 5;
ll n, q, m = 1, w, V, f[N], c[55], v[55], _v[55], _d[55];
int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> q;
  for(int i = 1; i <= n; i++) {
    cin >> v[i] >> c[i];
    if(w * v[i] < m * c[i]) w = c[i], m = v[i];
  }
  for(int i = 1; i <= n; i++) _v[i] = v[i] % m, _d[i] = v[i] / m; // 避免多次取模和除法常数太大
  for(int i = 1; i < m; i++) f[i] = -1e18;
  for(int i = 1; i <= n; i++) {
    for(int j = 0, lim = __gcd(v[i], m); j < lim; j++) {
      for(int t = j, _ = 0; _ < 2; _ += t == j) {
        int q = t + _v[i], d = _d[i];
        if(q >= m) q -= m, d++;
        f[q] = max(f[q], f[t] + c[i] - d * w), t = q;
      }
    }
  }
  for(int i = 1; i <= q; i++) {
    cin >> V;
    int p = V % m;
    if(f[p] < -1e17) cout << "-1\n";
    else cout << f[p] + V / m * w << "\n";
  }
  return 0;
}
```

### 和其它算法的对比

SPFA 跑同余最短路的复杂度依然是个谜。它的理论上界是 $\mathcal{O}(|V||E|)$ 即 $\mathcal{O}(nm ^ 2)$，但实际表现和小常数 $\mathcal{O}(nm)$ 同样优秀。

此外，在可以使用最大体积作为基准元素时，令 $f_i$ 除以 $m$ 下取整得 $f'_i$，则 $f_i = f'_i m + i$。对于 $f'$，边权只有 $0$ 或 $1$，01-BFS（[FZzzz](https://www.luogu.com.cn/blog/0123456-3456789/solution-p3403)）。

显然，转圈技巧比最短路好写，且适用范围没有任何限制，如 01-BFS 就无法解决第二道例题。

### 总结

同余最短路的本质是根据单调性值域定义域互换后将完全背包转化为体积模 $m$ 意义下的完全背包。普通完全背包的转移是有向无环图，而体积模 $m$ 的完全背包的转移成环，这让我们想到最短路。最短路不成环，对应原问题就是可以将两次经过同一个点之间添加的所有物品换成若干基准物品。所以，我们可以将完全背包转化为类多重背包问题。

笔者在研究「背包」一题的官方解法时，惊讶于其 “转两圈” 思想的巧妙。翻了一遍经典同余最短路题目，也没找到几篇除了 SPFA 和 Dijkstra 以外的题解，故分享给各位读者。

**同余最短路还在写最短路？时代的眼泪！**

---

## 作者：喵仔牛奶 (赞：11)

## $\mathcal{Solution}$

发现 $V$ 很大 $v_i$ 却很小，而且还是完全背包，一般都是**同余最短路**。

- 首先考虑贪心，发现对于最优解的很大一部分容量，都是在取性价比最高的物品。令**性价比最高的物品**为 $k$，其体积为 $v_k$，价值为 $c_k$。
- 容易发现对于一些总体积为 $v_k$ 的物品，不如换成 $k$。因为 $k$  是性价比最高的。但是对于总体积不为 $v_k$ 就不一定，最优解可能会比全部取 $k$ 并空出剩下容量要优或劣（劣是因为本题要求总体积必须为 $V$）。考虑求出要优或劣多少。
- 考虑 dp，设 $V$ 为体积，$C$ 为价值，设 $f_{i}$ 为 $i\equiv V\text{ }(\bmod\text{ }v_k)$ 下最大的 $C-\lfloor\frac{V}{v_k}\rfloor\times c_k$，也就是最优解比全部取 $k$ 优或劣多少。可以证明 $V$ 不会大于实际询问的 $V$。
$$f_{i}=\max_{1\leq j\leq n}\{f_{j}+c_j-\lfloor\frac{i+v_j}{v_k}\rfloor\times c_k\}$$
- 发现 dp 有后效性，建图跑最长路模拟 dp 即可求出。
- 询问的结果即 $\lfloor\frac{V}{v_k}\rfloor\times c_k+f_{V\bmod v_k}$。

一些性质的说明：
- 关于为什么 dp 中的 $V$ 不会大于实际询问的 $V$：记实际询问的 $V$ 为 $V'$，把 dp 过程看成一条最长路，那么这条最长路就不会两次经过同一个结点，不然把两次经过该结点中间使用的一些物品换成 $k$ 更优。所以 dp 中的 $V\leq\sum v_i$。观察发现这题 $\sum v_i\leq 10^{11}\leq V'$，所以可证。
- 关于为什么没有正环，感性理解一下，最长路在模拟 dp，而这个 dp 的值有上限。

理论最坏复杂度是 $\mathcal{O}(nv^2+q)$，但是在本题的图里面 SPFA 跑得飞快，而且出题人不太能卡（）

## $\mathcal{Code}$

同余最短路，[345ms](/record/104446931)。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Milkcat {
	typedef long long LL;
	const int N = 1e6 + 5, M = 5e6 + 5;
	struct edge {
		LL to, w, next;
	} e[M];
	queue<LL> q;
	LL n, m, t, T, V, cnt, w[N], v[N], head[N], dis[N];
	bool vis[N];
	void add(LL u, LL v, LL w) {
		e[++ cnt].to = v;
		e[cnt].w = w;
		e[cnt].next = head[u];
		head[u] = cnt;
	}
	void SPFA(int s) { // SPFA 求最长路
    for (int i = 0; i <= m; i ++) dis[i] = -1e18;
		dis[s] = 0, q.push(s);
		while (!q.empty()) {
			int u = q.front(); q.pop();
			vis[u] = false;
			for (int i = head[u]; i; i = e[i].next) {
				int v = e[i].to;
				if (dis[v] < dis[u] + e[i].w) {
					dis[v] = dis[u] + e[i].w;
					if (!vis[v]) q.push(v), vis[v] = true;
				}
			}
		}
	}
	int main() {
		cin >> n >> T, m = 1e6;
		for (int i = 1; i <= n; i ++) {
			cin >> w[i] >> v[i];
			if (v[i] * m > t * w[i]) m = w[i], t = v[i];
		}
		for (int i = 0; i <= m; i ++)
			for (int j = 1; j <= n; j ++)
				add(i, (i + w[j]) % m, v[j] - (i + w[j]) / m * t);
		SPFA(0);
		for (int i = 1; i <= T; i ++) {
			cin >> V;
			if (dis[V % m] <= -1e17) cout << "-1\n";
			else cout << V / m * t + dis[V % m] << '\n';
		}
		return 0;
	}
}
int main() {
	return Milkcat::main();
}
```


---

## 作者：Leasier (赞：9)

对于这种数据范围巨大的背包，我们往往都可以用贪心去进行一些优化。

注意到当体积很大时，很多时候我们都会用一些性价比很高的物品去填充。这里我们设性价比最高的项为 $k$，则在幻想中，我们会先用 $\lfloor \frac{V}{v_k} \rfloor$ 个 $k$ 填满绝大部分，再用一些小的填满 $r = V \bmod v_k$。

但事实上有时候我们不能填满 $r$，而此时却有解——则我们有时是要抛弃一些 $k$ 的，但个数并不确定……

考虑做 $\bmod \ v_k$ 的同余最短路，并用走过一条边表示加入新的元素，以及超过 $v_k$ 后所必要的把原来的 $k$ 扔掉的操作。

具体地，对于在取模后为 $i$ 的基础上加上物品 $j$，我们连边 $i \to^{c_j - c_k \lfloor \frac{i + v_j}{v_k} \rfloor} (i + v_j) \bmod v_k$。

直接跑 SPFA 即可。时间复杂度为 $O(\operatorname{SPFA}(\max v_i, n \max v_i) + q)$。

------------

SPFA 被卡了，但注意到 [Alex_Wei 的题解](https://www.luogu.com.cn/blog/AlexWei/tong-yu-zui-duan-lu-de-zhuan-quan-ji-qiao) 里有更优的做法！！！

考虑回归本源：$\bmod \ m$ 意义下的完全背包。

首先我们有与 SPFA 建图相同的递推式：$\operatorname{chkmax}(dis_{(i + v_j) \bmod m}, dis_i + c'_j)$，其中 $m = v_k, c'_j = c_j - c_k \lfloor \frac{i + v_j}{v_k} \rfloor$。

考虑一个一个加入物品，此时可以转移的项在 $\bmod \ m$ 意义下形成了 $\gcd(v_j, m)$ 个**环**。

类似于 [[模拟赛 2022.11.18] 风信子](https://www.luogu.com.cn/blog/Leasier/solution-simulation-2022-11-18-hyacinth)，注意到我们只需要在每个环上转两圈就可以求出答案——要不然原图存在负环，而本题选出性价比最高的元素的体积作为模数事实上保证了这一点。

时间复杂度为 $O(n \max v_i + q)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

int v[57], c[57];
ll dis[100007];

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

inline ll max(ll a, ll b){
	return a > b ? a : b;
}

int main(){
	int n, q, base = -1;
	scanf("%d %d", &n, &q);
	for (register int i = 1; i <= n; i++){
		scanf("%d %d", &v[i], &c[i]);
		if (base == -1 || (ll)c[base] * v[i] < (ll)c[i] * v[base]) base = i;
	}
	for (register int i = 1; i < v[base]; i++){
		dis[i] = 0x8000000000000000ll;
	}
	for (register int i = 1; i <= n; i++){
		if (i == base) continue;
		int d = gcd(v[i], v[base]), len = v[base] / d * 2;
		for (register int j = 0; j < d; j++){
			for (register int k = j, l = 1; l <= len; l++){
				int newv = k + v[i], nxt = newv % v[base];
				if (dis[k] != 0x8000000000000000ll) dis[nxt] = max(dis[nxt], dis[k] + c[i] - (ll)newv / v[base] * c[base]);
				k = nxt;
			}
		}
	}
	for (register int i = 1; i <= q; i++){
		ll V, rem;
		scanf("%lld", &V);
		rem = V % v[base];
		if (dis[rem] == 0x8000000000000000ll){
			printf("-1\n");
		} else {
			printf("%lld\n", V / v[base] * c[base] + dis[rem]);
		}
	}
	return 0;
}
```

---

## 作者：Purslane (赞：5)

# Solution

你信不信我的同余最短路写的都是 Dijkstra /cf 学到了学到了。

$V$ 非常非常大，那么一看就不是纯 DP 做法。考虑要求总体积**恰好**是 $V$，因此我们可以借鉴刚入门时候的“分数背包”的做法，选取性价比最高的物品。假设这个物品的体积是 $v_0$，价值是 $c_0$。

那么考虑画一个圈，上面标有数字 $0$ 到 $v_0-1$。那么再模 $v_0$ 意义下，每个点 $i$ 向 $i+v_i$ 连价值为 $c_i$ 的边。然后跑最长路。

诶等等，好像我们没有用上性价比最高的背包。那么我们知道 $V \bmod v_0$ 的值之后，我们只知道用其他不是性价比最高的物品拼出 $kv_0+V \bmod v_0$ 的容量的最大价值，但是并不知道 $k$ 是多少啊！这样你就无法计算还能放多少个性价比最高的物品。

那么考虑最开始你一共能放 $\lfloor \frac{V}{v_0} \rfloor$ 个。 $k$ 每增加 $1$，你就得少放一个。因此你可以把一条边的边权减掉 $c_0$ 乘上他覆盖 $v_0-1$ 到 $0$ 这条边的次数。

然后使用其他题解提到的“转圈”法即可。

但是我们如何保证最终 $k$ 一定不会大于 $\lfloor \frac{V}{v_0} \rfloor$ 呢？事实上，最优情况下，我们一定不会重复经过同一个点，否则一定可以把这一段换成性价比最高的。因此最优情况下其他非性价比最高的物品最多小号 $10^{10}$ 个容量，不到 $V$。（也就是经典的错解不优思想）

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,q,pos,tot,v[MAXN],c[MAXN],dp[MAXN];
int calc(int st,int len,int tot) {
	if(tot-st>len) return 0;
	return (len-(tot-st))/tot+1;	
}
void update(int v,int C) {
	int l=__gcd(tot,v);
	ffor(i,0,l-1) {
		int tmp=i;
		while(1) {
			int nxt=(tmp+v)%tot;
			dp[nxt]=max(dp[nxt],dp[tmp]+C-calc(tmp,v,tot)*c[pos]),tmp=nxt;
			if(tmp==i) break;
		}
		while(1) {
			int nxt=(tmp+v)%tot;
			dp[nxt]=max(dp[nxt],dp[tmp]+C-calc(tmp,v,tot)*c[pos]),tmp=nxt;
			if(tmp==i) break;
		}
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	ffor(i,1,n) cin>>v[i]>>c[i];
	ffor(i,1,n) if(c[i]*v[pos]>=c[pos]*v[i]) pos=i;
	memset(dp,-0x3f,sizeof(dp));
	dp[0]=0,tot=v[pos];
	ffor(i,1,n) if(i!=pos) update(v[i],c[i]);
	ffor(i,1,q) {
		int v; cin>>v;
		if(dp[v%tot]+c[pos]*((v-v%tot)/tot)<=0) cout<<-1<<'\n';
		else cout<<dp[v%tot]+c[pos]*((v-v%tot)/tot)<<'\n';
	}
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：2)

[博客](https://ntsc.flowus.cn)

本题有助于我们完全了解同余最短路。

对于总容量很大的完全背包问题，我们通常会使用同余最短路。并且我们会发现，最后的最优方案一定是某个性价比最高的物品重复很多次，然后剩下一些物品在一个小范围内。

并且我们考虑同余最短路（就考虑例题 #1（[前情回顾](https://ntsc-yrx.github.io/oi-beats/site/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF/)）的），我们发现最后答案的组成也是某个很小的 $by+cz$，再加上很大的 $ax$ 组成的。

因此我们的 $x$ 要选什么就很显然啦，就是性价比最高的那个。下面我们就令 $x$ 为性价比最高的物品的编号



那么接下来怎么做呢？我们怎么样取确定一条边的边权，还有，怎么样统计答案？

这里我们先回到背包问题的基本做法上，dp。

定义 $f_i$ 为选择物品的体积为i时的最大价值。那么我们就有：

$$f_i=\max(f_{i-kv_j}+kc_j)$$

但是我们不太可能取枚举 $k$ 又要枚举 $j$，因此我们直接考虑从体积为 $j$ 到体积为 $i$ 的最优价值差。即我们写成以下形式：

$$f_i=\max(f_j+w(i-j))$$

我们发现，只要体积是 $v_x$ 的整数倍，我们就使用一个 $x$ 替代。于是有：

$$f_i=\max(f_j+\lfloor\frac{(i-j)}{v_x}\rfloor\times c_x+f_{(i-j)\bmod v_x})$$

然后呢？

如果放在同余最短路上，那么我们所有的下标都对 $v_x$ 取模，那么 $f$ 值会越滚越大，并且没有人知道它滚了几圈！

但是如果我们不知道它滚了几圈，我们怎么样确定最后我们需要多少个 $x$ 才可以凑到询问的 $V$ 呢？

因此我们需要改进以下我们的 dp。将 $f$ 的定义修改为选体积为 $i$（在模 $v_x$ 意义下）的物品，其与最优选法的最小差值。这里的最优选法自然就是只选 $x$ 物品。当然这个差值有正有负，因为 $x$ 可能选不满体积 $i$。

不过我们不管这些。只要我们求出了 $f$，那么答案就很简单了。对于询问 $V$，除去凑数的一大堆 $x$，剩下的就是 $V\bmod v_x$，那么差值就是 $f_{V\bmod v_x}$。加上只选 $x$ 的最优选法的价值 $\lfloor\frac{V}{v_x}\rfloor\times c_x$ 就是答案。



$$f_i=\max(f_{(i+v_j)\bmod v_x}+\lfloor\frac{i+v_j}{v_x}\rfloor\times c_x)$$

考虑跑最短路（当然这里应该是最长路）就相当于从一个状态加上一些权值变成下一个状态，那么按照上面的转移建图即可。

这里丢一个带 SLF 优化的代码。

```C++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define itn int
#define mp make_pair
#define pb push_back
#define pii pair<int,int>
#define pf first 
#define ps second
#define cdbg(x) cerr<<#x<<" = "<<x<<'\n';
#define rd read()
inline int read(){
	int x;
	cin>>x;
	return x;
}

const int N=2e6+5;
const int INF=1e18;
const int MOD=998244353;


/*

策略

同余最短路解决完全背包问题，这是一个典型的题目

但是本题除了要求恰好意外，还要要求价值最大。
先考虑贪心，发现对于最优解的很大一部分容量，都是在取性价比最高的物品。这是我们写同余最短路的一个很重要的限制：
我们的模数旧应该是取的次数异常多的数字

然后呢？我们每条路的长度应该是多少？
根据要求，应该是使得我们求出的f_i为k%mod=i中性价比最高的
但是注意这里的性价比和mod有关，因为如果我们取的越少，那么我们的mod就可以取得越多

*/

list<int> q;
int d[N];
bitset<N> vis;
struct edge{
	int v,w;
};
vector<edge> e[N];

void add(int a,int b,int c){
	// cerr<<a<<' '<<b<<' '<<c<<endl; 
	e[a].pb({b,c});
}

void spfa(){
	memset(d,-0x3f3f,sizeof d);
	d[0]=0;
	q.push_back(0);
	while(q.size()){
		int x=q.front();
		q.pop_front();
		vis[x]=0;
		for(auto v:e[x]){
			if(d[v.v]<d[x]+v.w){//最长路
				d[v.v]=d[x]+v.w;
				if(!vis[v.v]){
					if(d[v.v]>d[q.front()])
						q.push_front(v.v);
					else q.push_back(v.v);
					vis[v.v]=1;
				}
			}
		}
	}
}

int mid=1,v[N],c[N];

void solve(){
	int n=rd;
	int q=rd;
	for(int i=1;i<=n;i++){
		v[i]=rd;
		c[i]=rd;
		if(v[mid]*c[i]>v[i]*c[mid])mid=i;
	}
	cdbg("OK");


	for(int i=1;i<=n;i++){
		if(i==mid)continue;

		for(itn j=0;j<v[mid];j++){
			add(j,(j+v[i])%v[mid],c[i]-(j+v[i])/v[mid]*c[mid]);
			// add(j,(j+v[i])%v[mid],c[j]-((j+v[i])%v[mid]+v[j])/v[mid]*c[mid]);
		}
	}



	spfa();
	cdbg(v[mid]);
	while(q--){
		int V=rd;
		int res=V/v[mid]*c[mid]+d[V%v[mid]];
		if(res<0)res=-1;
		cout<<res<<endl;
	}
}
signed  main(){
	int T=1;
	while(T--){

		solve();
		// if(T)puts("");
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：2)

# P9140 [THUPC 2023 初赛] 背包 题解

## 题意回顾

$ n $ 个物品都有体积 $ v_i $ 和价值 $ c_i $，**完全背包**，每次询问拼凑出总体积 $ V $ 的可行性和最大价值。

$ n \le 50, v_i \le 10^5, c_i \le 10^6, q \le 10^5, 10^{11} \le V \le 10^{12} $。

## 分析

$ V $ 上界这么大，这样的完全背包问题理论上是无法在规定时间内解决的。

但是注意到 $ V $ 的下界很离谱，为什么要规定 $ V \ge 10^{11} $ 呢？问题解决的关键在这里。

在可拆分背包问题中我们的策略是先用**性价比**最高的物品，而这个策略在完全背包中错误的原因就是没有考虑到用完最大值**余下**的部分，但是 $ V $ 足够大的时候，余下的部分**几乎**可以忽略不计，因此我们考虑先用性价比最高的物品。

因为 $ V $ 足够大，所以只要 $ V $ 能被所有物品体积的最大公约数整除的话，一定能凑出来，现在考虑如何凑。

我们的预期价值是尽量凑尽可能多的最高性价比物品而不去考虑余下部分，记那个物品体积为 $ v $，价值为 $ w $。

剩下的部分体积为 $ V \bmod v $，但是可能凑不出来，我们就从已经凑完的部分中“借”$ v $ 的若干整倍数的体积，对总价值**贡献**为余下部分的原本价值减去 $ w $ 的对应整倍数（即因为借用体积耗费的价值）。

维护 $ dp_{i} $ 表示对于模 $ v $ 余 $ i $ 的部分对总价值的贡献最大是多少。

跑最短路太慢了，可以发现先用哪个物品再用哪个物品转移是**等价的**，因此按照物品原顺序依次转移即可，因为模运算加法是循环的，所以可以对于每个点跑两圈，这样就能覆盖每个转移情况了。

总时间复杂度为 $ O(nv+q) $。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 1e5 + 5;
const long long inf = 1e12 + 5;
int n, q;
int v[N];
int c[N];
struct node {
	long long vi;
	long long wi;
};
node make(long long v0, long long w0) {
	node res;
	res.vi = v0;
	res.wi = w0;
	return res;
}
node dp[M];
bool operator<(node p1, node p2) {
	//if(p1.vi != p2.vi) {
	//	return p1.vi < p2.vi;
	//}
	return p1.wi > p2.wi;
}
int gcd(int x, int y) {
	if(y == 0) {
		return x;
	}
	return gcd(y, x % y);
}
int main() {
	scanf("%d%d", &n, &q);
	long double tps = 0;
	int v1, w1, id;
	for(int i = 1; i <= n; i++) {
		scanf("%d%d", &v[i], &c[i]);
		if((long double)c[i] / v[i] > tps) {
			tps = (long double)c[i] / v[i];
			v1 = v[i];
			w1 = c[i];
			id = i;
		}
	}
	int g = v[1];
	for(int j = 1; j < v[id]; j++) {
		dp[j] = make(inf, -inf);
	}
	dp[0] = make(0, 0);
	for(int i = 1; i <= n; i++) {
		g = gcd(g, v[i]);
		if(i == id) {
			continue;
		}
		int li = gcd(v[id], v[i]);
		for(int j = 0; j < li; j++) {
			for(int p = j;true;) {
				dp[(p + v[i]) % v1] = min(dp[(p + v[i]) % v1], make(dp[p].vi + v[i], dp[p].wi + c[i] - (dp[p].vi % v1 + v[i]) / v1 * w1));
				p = (p + v[i]) % v1;
				if(j == p) {
					break;
				}
			}
			for(int p = j;true;) {
				dp[(p + v[i]) % v1] = min(dp[(p + v[i]) % v1], make(dp[p].vi + v[i], dp[p].wi + c[i] - (dp[p].vi % v1 + v[i]) / v1 * w1));
				p = (p + v[i]) % v1;
				if(j == p) {
					break;
				}
			}
		}
	}
	long long x;
	for(int i = 1; i <= q; i++) {
		scanf("%lld", &x);
		if(x % g != 0) {
			printf("-1\n");
		} else {
			printf("%lld\n", x / v1 * w1 + dp[x % v1].wi);
		}
	}
	return 0;
}
```

---

## 作者：TTpandaS (赞：1)

## 问题

有 $n$ 种物品，体积为 $w_i$，价值为 $v_i$，跑 $q$ 次背包容积为 $W$ 的完全背包。其中 $W \geq w_i ^2$。

要求时间复杂度 $O(n^2 w_i)$ 级别。

-----

## 引理

令性价比（$\dfrac{v_i}{w_i}$） 最高的物品为 $x$，则其他物品最多选 $w_x-1$ 个。

----

## 证明

令选择的其他物品的集合为 $S$，$ |S| = m $，$S=\{p_1,p_2,p_3,\dots,p_m\}$。

---

### 结论

若存在一个子集 $S'=\{p'_1,p'_2,\dots,p'_k\}$ ，满足 $\sum_{i=1}^{k}w_{p'_i}  \equiv 0 \pmod {w_x}$，则将该子集的全部物品替换为 $\dfrac{\sum_{i=1}^{k} w_{p'_i}}{w_x}$ 个 $x$ 物品更优。

----

### 证明

替换子集的物品价值之和为 $\sum_{i=1}^{k} v_{p'_i}$。

$\dfrac{\sum_{i=1}^{k} w_{p'_i}}{w_x}$ 个 $x$ 物品的价值为 $\dfrac{v_x}{w_x} \times \sum_{i=1}^{k} w_{p'_i}$。

$$\sum_{i=1}^{k} v_{p'_i} = \sum_{i=1}^{k} w_{p'_i} \times \dfrac{v_{p'_i}}{w_{p'_i}} \leq \sum_{i=1}^{k} w_{p'_i} \times \dfrac{v_{x}}{w_{x}} = \dfrac{v_x}{w_x} \times \sum_{i=1}^{k} w_{p'_i}$$

因此 $\dfrac{\sum_{i=1}^{k} w_{p'_i}}{w_x}$ 个 $x$ 物品的价值大于等于该子集的物品价值之和，则替换更优。

---


令 $s_i=\sum_{j=1}^{i} w_{p_j}$，若存在 $s_l \equiv s_r \pmod {w_x} (0 \leq l < r \leq m)$，则子集 $S'=\{p_{l+1}, p_{l+2},\dots,p_r\}$ 满足 $\sum_{i=l+1}^{r}w_{p'_i}  \equiv 0 \pmod {w_x}$，可替换。

$0 \leq s_i \mod w_x \leq w_x-1$，$s_0 = 0$，由鸽巢原理可得，当 $k \geq w_x$ 时，必定存在 $s_l \equiv s_r \pmod {w_x} (0 \leq l < r \leq m)$，因此可以将子集 $S'=\{p_{l+1}, p_{l+2},\dots,p_r\}$ 替换为数量更少的 $x$ 物品。

重复上述过程，则最后得到的其他物品的集合 $S$ 满足 $|S| \leq w_x-1$，引理得证。

----

等价的，选择的其他物品的总体积小于等于 $(w_x-1) \times \max w_i$。

## 解决方案

由于 $W \geq w_i^2 \geq (w_x-1) \times \max w_i$，因此可以首先用 $x$ 物品填满，然后做 $\mod w_x$ 的同余最短路即可。

---

### SPFA

物品的替换相当于每个物品连接 $w_x$ 条边：$(u \to (u+w_i)\%w_x,v_i-\dfrac{u+w_i}{w_x} \times v_x)(0 \leq u < w_x)$。

然后用 SPFA 跑最长路即可。

该图中一定不存在正环，因为每经过一条边相当于更新一种背包取法，而背包是有上界的，所以一定不存在正环。

最坏情况下时间复杂度 $O(n^3 {w_x}^2)$。

----

### 转圈技巧

对于体积为 $w_i$ 的物品，其在长度为 $l$ 的环上会形成 $\gcd(w_i,l)$ 个子环。

由于该图中不存在正环，因此最长路不会经过一个点两次，进而每个子环中至多只有一个该物品，所以对于体积为 $w_i$ 的物品，最多只会加入 $\dfrac{l}{\gcd(w_i,l)}-1$ 个。

对于每个物品，只需要将每个子环正反各跑一圈即可。

时间复杂度 $O(n^2 {w_x})$。

----

## 应用

### P9140 [THUPC 2023 初赛] 背包 

原问题。

----

### CF2115E Gellyfish and Mayflower *3500

对于 $r>c_i^2$ 可采用此问题的方法，否则可以暴力 dp。

---

## 作者：Lamb_Carp (赞：1)

# advertisement

这位靓仔，你都来看我的题解了，为什么不来[我的博客](https://www.cnblogs.com/carp-oier/p/17744760.html)看呢。

# prologue

这很难评（调了我 1h，我都想紫砂了。

还是典型得不重构就看不见系列。

![不重构看不见系列](https://cdn.luogu.com.cn/upload/image_hosting/13h56d3t.png)
![不重构看不见系列](https://cdn.luogu.com.cn/upload/image_hosting/iaaoo6in.png)
***
# analysis

如果我们还是一个正常人，那么我们大体上是能看到题目的加粗字，这个格式很明显符合我们的同余最短路的格式。（如若不知，请先[出门直走](https://www.cnblogs.com/carp-oier/p/17744327.html "出门直走")）

然后我们就要考虑这个**同余最短路**的实现。这个题目不同于往常的同余最短路，而是新增了一个条件。除了显然得他是给到完全背包，我们决定用同余最短路解决之后，我们该考虑怎么让他这个完全背包利益最大化。

（不知道你们有没有，反正我学 01 背包的时候是先教的我用单位价值进行排序然后一个一个加。）

我们就可以借助上述的**贪心**，先找到单位体积最大的即 $\frac{c_i}{v_i}$，这个很好实现，即在实现输入的时候发现 $\frac{c_i}{v_i} > \frac{w}{m}$，更新 $m$、$w$ 即可，为了规避整数除法，我们将式子转换成 $c_i \times m > w \times a_i$ 就可以实现维护。

之后就是我们进行同余最短路的时候。

附上一句：**同余最短路写最短路就好比打游戏玩原神。**

下面不讲常规方法，讲的是转圈做法。（都 3202 年了你还不会转圈？那就赶紧[左转](https://www.cnblogs.com/alex-wei/p/17531487.html "左转")或者[右转](https://www.cnblogs.com/ying-xue/p/16976289.html "右转")到大佬的博客进行学习。）

之后是统计答案。（下面的过程参考了[大佬的这篇博客](https://www.cnblogs.com/ying-xue/p/16976289.html "大佬的这篇博客")，想看原汁原味的可以去这位大佬的博客中查看）

令 $v \gets V \bmod m, v < V $，这个时候我们将考虑到最终最大值为 $C + \frac{V - v}{m} \times w$，也就是我们要求 $C - \frac{v}{m} \times w$ 最大。也就得到我们的转移方程：

$$f_p \gets f_t + c[i] - ((t + a[i]) / m) \times w, t = p$$

我们在查询答案的时候，如果这个位置的 $f$ 值不为 $-∞$ 就得到：
$$ans \gets f[p] + \frac{v}{m} \times w$$

# code time
马蜂优良。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long 
#define rl register ll

constexpr ll N = 55, M = 1e5 +10;

ll n, m = 1, q, a[N], f[M], c[N], ans, w;

inline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

int main()
{
    // freopen("1.in", "r", stdin), freopen("1.out", "w", stdout);

    cin >> n >> q;

    for(rl i=1; i <= n; ++ i) 
    {
        cin >> a[i] >> c[i];
        if(w * a[i] < m * c[i]) w = c[i], m = a[i];
    }

    for(rl i=1; i < m; ++ i) f[i] = -1e18;
    for(rl i=1; i <= n; ++ i)
        for(rl j=0, lim = gcd(m, a[i]); j < lim; ++ j)
            for(rl t = j, asd = 0; asd < 2; asd += t == j)
            {
                ll p = (t + a[i]) % m;
                f[p] = max(f[p], f[t] + c[i] - ((t + a[i]) / m) * w), t = p;
            }

    while(q -- )
    {
        ll v; cin >> v;
        ll p = v % m;
        if(f[p] < -1e17) puts("-1");
        else cout << f[p] + v / m * w << endl;
    }
    return 0;
}
```

---

## 作者：xxr___ (赞：0)

第一眼看到这个题数据范围，发现 $V$ 下界很大，所以考虑到贪心是否正确。

我们设最有性价比的那个物品作为基准，其单位体积是 $m$ 单位价值是 $v$。

那么有一个比较简单的同余最短路的做法，就是对于 $i\in [0,m]$ 每个数，都让他去连 $v_j,j\in [1,n]$ 连向的位置为 $(i + v_j)\bmod m$ 权值是 $c_j$。

但是我们应该怎么确定什么情况才是最优的呢？

假如存在 $(v_1,w_1)$ 和 $(v_2,w_2)$ 在同一个位置，那么哪个更优？首先，最后的答案一定是 $\frac{V - used}{m}\times v + f_{V\bmod m}$ 的，由于 $\frac{V}{m}\times v$ 是定值，所以只需要最大化 $f_{V\mod m} - \frac{used}{m} v$ 的值即可。

换到我们图论中就是求解最长路。具体转移就是当我们新加入物品 $(v_i,c_i)$ 的时候，有 $f_x → f_{(x + v_i) \bmod m} + c_i - \frac{x + v_i}{m} v$ 也就是占用了几倍的 $m$。

然后直接跑 SPFA 可能会被卡，所以我们考虑转圈法解决。

转圈就是，当前物品体积是 $v$ 那么他会产生 $\gcd (v,m)$ 个环，因为最短路/最长路不会经过同一个点两次，如果经过，可以用基准物品去替换，所以没加入一个物品会加入 $\frac{m}{\gcd(v,m)}$ 个环，这里有个小技巧就是遍历两边环可以把环上所有点都更新到，代码部分参考了 [Alex_Wei](https://www.luogu.com.cn/user/123294) 大佬的代码。时间复杂度是 $\mathcal O(nm)$ 的。

代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#define int long long
const int N = 1e5 + 5;

int m,w,n,q,v[N],c[N],f[N];
//f[i] 表示 % m 是 i 的最大价值 

int32_t main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cin >> n >> q;
	double ans = 0;
	for(int i = 1;i <= n; ++ i){
		std::cin >> v[i] >> c[i];
		if((double)(c[i] * 1.0 / v[i]) > ans){
			ans = c[i] * 1.0 / v[i];
			m = v[i];w = c[i];
		}	
	}
	for(int i = 1;i < m; ++ i) f[i] = -1e18;
	for(int i = 1;i <= n; ++ i){
		int len = std::__gcd(v[i],m);
		for(int j = 0;j < len; ++ j){
			for(int _ = 0,t = j;_ < 2;_ += t == j){
				int p = (t + v[i] % m),cnt = 0;
				if(p >= m) p %= m,++ cnt;
				f[p] = std::max(f[p],f[t] + c[i] - w * (v[i] / m + cnt));
				t = p;
			}
		}
	}
	for(int i = 1;i <= q; ++ i){
		int V;
		std::cin >> V;
		int p = V % m;
		if(f[p] < -1e17){
			std::cout << "-1\n";
		}else{
			std::cout << f[p] + V / m * w << '\n';
		}
	}
	return 0;
}
```

---

## 作者：User_Unauthorized (赞：0)

观察到有 $V \ge 10^{11}$，我们考虑其意义。发现一般的背包问题贪心会导致错误的原因是在选择尽可能多的最优物品后不能更好的利用未使用的空间。而在本题中，由于 $V$ 很大，因此我们可以先在最优的情况下构造出一种方案使得剩余容量是最优物品体积的倍数，然后填充剩余容量即可。

设最优物品的体积为 $m$，收益为 $w$，问题就转化为了对于 $x \in \left[0, m\right)$ 求解 $f_x$ 代表容量对 $m$ 取模为 $x$ 的最大收益。但是发现在转移时可能会出现同时转移到 $f_x$ 与 $f_{x + m}$，而后者的状态应当合并到前者中，考虑如何合并。由于最优物品的最优性，我们可以认为在容量为 $x$ 的基础上，每多使用 $m$ 的空间就会造成 $w$ 的损失，进而可以实现转移。对于物品 $\left(v_i, c_i\right)$ 有转移式：

$$f_{\left(x + v_i\right) \bmod m} \leftarrow f_x + c_i - \left\lfloor\frac{x + v_i}{m}\right\rfloor \times w$$

由于本题建出的图的特殊性，导致了 SPFA 无法通过。因此我们考虑直接使用完全背包来实现转移。

考虑体积模 $m$ 意义下的完全背包，发现对于体积为 $v_i$ 的物品，其会形成 $d = \gcd\left(m, v_i\right)$ 个环，而由于最优物品的最优性，不会存在 $x$ 转移到 $x$ 自身的情况，因此该物品在环中最多加入 $\frac{m}{d} - 1$ 个，我们对于每个环分别做两次转移即可，不难发现这样操作之后可以覆盖环上所有转移边。

复杂度为 $\mathcal{O}(nv + q)$。

---

## 作者：封禁用户 (赞：0)

### Solution：

考虑 $\lfloor c_{p} / v_{p} \rfloor$ 最大的 $item(v_{p}, c_{p})$，最后的答案一定是尽量多取。

当 $i$ 足够大时，$f_{i+v_{p}} = f_{i} + c_{p}$。

由于本题为完全背包，而 $V$ 远大于 $v_{i}$，故考虑**同余最短路**，模 $v_{p}$。

发现无法定义图中边的边权，最后会陷入无限负环，无法最短路。

令 $f_{i} = g_{i} \bmod m + \lfloor \frac{i}{v_{p}} \rfloor \times c_{p}$。

对于 $g_{i}$ 求最短路，对于 $f_{i}$ 取物品 $(v_{x}, c_{x})$ 并转移到 $f_{j}$。

等价于 

$$f_{i+c_{x}} = g_{i} \bmod m + \lfloor \frac{i}{v_{p}} \rfloor \times c_{p} + c_{x} = g_{i} \bmod m + c_{x} + (\lfloor \frac{i}{v_{p}} \rfloor - \lfloor \frac{i+v_{x}}{v_{p}} \rfloor) \times c_{p} + \lfloor \frac{i+v_{x}}{v_{p}} \rfloor \times c_{p}$$

转换到

$$g_{j} \bmod m + \lfloor \frac{j}{v_{p}} \rfloor \times c_{p}$$

### 参考代码

code:
```cpp
#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define ForkD(i,k,n) for(int i=n;i>=k;i--)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (o<<1)
#define Rson ((o<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,0x3f,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define MEMx(a,b) memset(a,b,sizeof(a));
#define INF (0x3f3f3f3f)
#define F (1000000007)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define vi vector<int> 
#define pi pair<int,int>
#define SI(a) ((a).size())
#define Pr(kcase,ans) printf("Case #%d: %lld\n",kcase,ans);
#define PRi(a,n) For(i,n-1) cout<<a[i]<<' '; cout<<a[n]<<endl;
#define PRi2D(a,n,m) For(i,n) { \
						For(j,m-1) cout<<a[i][j]<<' ';\
						cout<<a[i][m]<<endl; \
						} 
#pragma comment(linker, "/STACK:102400000,102400000")
#define ALL(x) (x).begin(),(x).end()
#define gmax(a,b) a=max(a,b);
#define gmin(a,b) a=min(a,b);
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return ((a-b)%F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar();}
	return x*f;
} 
#define MAXN (60+10)
ll v[MAXN],c[MAXN];
ll f[500000+10];
int main()
{
//	freopen("D.in","r",stdin);
//	freopen(".out","w",stdout);
	int n=read(),q=read(),p=1;
	For(i,n) {
		cin>>v[i]>>c[i];
		if(v[i]*c[p]<v[p]*c[i]) {
				p=i;
		}
	}
	const ll M=v[p],w=c[p];
	Rep(i,M) f[i]=-1e18;f[0]=0;
	For(i,n) {
		int ma=__gcd(v[i],M);
		Rep(j,ma) {
			for(int t=j,_=0;_<2;_+=t==j){
				int q=(t+v[i])%M;
				if(f[t]!=-1e18)
					gmax(f[q],f[t]+c[i]-(t+v[i])/M *w)
				t=q;
			}
		}
	}
	For(i,q) {
		ll qv;
		cin>>qv; ll p=qv%M;
		if(f[p]==-1e18)puts("-1");
		else {
			cout<<f[p]+qv/M*w<<endl;
		}
	}
	return 0;
}


```


---


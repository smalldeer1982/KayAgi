# [THUPC 2023 初赛] 最后的活动

## 题目背景

各位亲爱的《La Lumière: Scarlet Intense Flame》玩家：

感谢您一直给予《La Lumière: Scarlet Intense Flame》的支持与厚爱。我们非常遗憾地宣布，《La Lumière: Scarlet Intense Flame》将于 2023 年 3 月 5 日 16:00 停止运营服务。

停止运营相关时间表如下：

……

## 题目描述

元老级二次元手游《La Lumière: Scarlet Intense Flame》将于今年 3 月停止运营服务。作为这款游戏的忠实玩家，小 S 希望能在游戏的最后一次活动中刷到一个特殊的分数，以此为近十年来与这款游戏共度的难忘时光画上一个圆满的句号。

《La Lumière: Scarlet Intense Flame》中的每种活动都有其独特的规则，而最后一次活动是 Chase Festival。在 Chase Festival 中，玩家需要多次攻略每次随机生成的多层迷宫，每次退出迷宫时根据在迷宫中各层击杀怪物的评价独立结算本次随机迷宫的分数。每次挑战迷宫时的流程简化如下：

1. 选择挑战的随机迷宫的难度。小 S 是这款游戏的资深玩家，因此在本题中假定小 S 总是挑战最高难度的迷宫。最高难度的迷宫最深为 $N$ 层。确定难度后，从随机生成的迷宫的第 1 层开始挑战。

2. 进行第 $i$ 层的挑战。挑战第 $i$ 层时，小 S 有可能挑战失败，挑战成功并获得普通评价，或者挑战成功并获得高评价。如果小 S 选择保守的挑战策略，则有 $p_{i,0}$ 的概率挑战失败，有 $p_{i,1}$ 的概率挑战成功并获得普通评价，有 $p_{i,2}$ 的概率挑战成功并获得高评价；如果小 S 选择激进的挑战策略，则有 $q_{i,0}$ 的概率挑战失败，有 $q_{i,1}$  的概率挑战成功并获得普通评价，有 $q_{i, 2}$ 的概率挑战成功并获得高评价。
   
   - 获得普通评价时，在当前层获得 $s_{i,1}$ 的分数；获得高评价时，在当前层获得 $s_{i,2}$ 的分数。这部分获得的分数**不会直接加算**到玩家的总分数中，而是**在退出迷宫时结算**。如果挑战成功，且当前不是最后一层（$i<N$），则跳转到第 3 步，选择是否继续挑战；否则（$i=N$），退出迷宫并跳转到第 4 步进行结算。
   
   - 如果挑战失败，则强制退出迷宫，跳转到第 4 步。

3. 如果当前不是最后一层，玩家可以选择是否继续挑战下一层。如果选择继续，则返回第 2 步；否则退出当前迷宫，跳转到第 4 步进行结算。

4. 本次迷宫的分数结算：如果因为失败而强制退出，则当前层不获得任何奖励，且**本次迷宫中之前各层**累积的分数需要乘上惩罚系数 $c$（为了使最终分数为整数，游戏会对惩罚后的分数先求和再下取整）；除了强制退出之外，玩家主动退出或者通关迷宫后退出都可以获得全部尚未结算的分数。

小 S 想得到的目标分数是一个比较大的分数，因此小 S 需要先大量刷最高难度的迷宫，再在接近目标分数时根据当前剩余的分数选择相对稳定的策略，以确保活动结束时能恰好获得目标分数。小 S 不会编程，因此小 S 找到了你，希望你能帮忙计算当剩余分数在 $1$ 至 $M$ 分之间，仅按照上述的流程挑战迷宫，并采用最佳策略时，最终能够恰好达到目标分数的最大概率。

## 说明/提示

#### 子任务

对于 $100\%$ 的数据，保证 $1\le N\le 6$，$1\le M\le 10000$，$0\le c'\le 100$，$1\le s_{i,1}\le s_{i, 2}\le 10000$，$0\le u_{i, 0}, u_{i, 1}, u_{i, 2}, v_{i, 0}, v_{i, 1}, v_{i, 2}\le 10000$，$u_{i,1}+u_{i,2}\ge 1$，$v_{i,1}+v_{i,2}\ge 1$。

#### 提示

《La Lumière: Scarlet Intense Flame 2》将于 2023 年春暖花开的时节与大家相见！

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 8 50
3 4 0 1 1 0 1 1
4 5 1 2 1 1 1 2
```

### 输出

```
0.125000000000000000 0.140625000000000000 0.515625000000000000 0.564453125000000000 0.135009765625000000 0.328369140625000000 0.548858642578125000 0.625278472900390625
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.ans```

# 题解

## 作者：Alex_Wei (赞：6)

> [P9144 [THUPC 2023 初赛] 最后的活动](https://www.luogu.com.cn/problem/P9144)

设 $f_i$ 表示恰好凑到 $i$ 的概率，$f_0 = 1$。用 $f_0\sim f_{i - 1}$ 递推 $f_i$。

我们直接模拟一轮迷宫的过程，在每个决策处取概率较大值，出迷宫就认为概率是 $f_{i - c}$，其中 $c$ 表示本轮迷宫获得的分数。问题在于 $c$ 可能等于 $0$。这种情况下，如果我们给 $f_i$ 赋初值，那么得到的 $f_i$ 相较于初值一定更偏向于真实值，这是因为决策时 $f$ 的系数在 $[0, 1)$ 之间（不可能取到 $1$，因为 $u_1 + u_2$ 和 $v_1 + v_2$ 均大于 $0$，即总有概率得分），所以如果 $f$ 偏离真实值，那么偏离的部分会因为乘上了 $[0, 1)$ 之间的系数而减小，使得答案偏向真实值。

直接迭代需要很多轮才能收敛，根据单调性将迭代换成二分就可以接受了。

时间复杂度 $\mathcal{O}(2 ^ nM\log \frac 1 {\epsilon})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;

bool Mbe;
constexpr int N = 8;
constexpr int M = 1e4 + 5;
int n, m, c, s1[N], s2[N];
double u0[N], u1[N], u2[N], v0[N], v1[N], v2[N], f[M];
double dfs(int pos, int acc, int aim) {
  if(pos > n) return 0;
  auto F = [&](int c) {return c > aim ? 0 : f[aim - c];};
  double p1 = max(F(acc + s1[pos]), dfs(pos + 1, acc + s1[pos], aim));
  double p2 = max(F(acc + s2[pos]), dfs(pos + 1, acc + s2[pos], aim));
  int sc = acc * c / 100;
  double u = u0[pos] * F(sc) + u1[pos] * p1 + u2[pos] * p2;
  double v = v0[pos] * F(sc) + v1[pos] * p1 + v2[pos] * p2;
  return max(u, v);
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif

  cin >> n >> m >> c;
  for(int i = 1; i <= n; i++) {
    cin >> s1[i] >> s2[i];
    cin >> u0[i] >> u1[i] >> u2[i];
    int su = u0[i] + u1[i] + u2[i];
    u0[i] /= su, u1[i] /= su, u2[i] /= su;
    cin >> v0[i] >> v1[i] >> v2[i];
    int sv = v0[i] + v1[i] + v2[i];
    v0[i] /= sv, v1[i] /= sv, v2[i] /= sv;
  }
  f[0] = 1;
  for(int i = 1; i <= m; i++) {
    double l = 0, r = 1;
    for(int _ = 0; _ <= 30; _++) {
      double m = (l + r) / 2;
      f[i] = m;
      if(dfs(1, 0, i) < m) r = m;
      else l = m;
    }
    printf("%.9lf ", f[i]);
  }
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
```

---

## 作者：Eraine (赞：4)

题目编号：P9144

这里仅仅提供题目二分部分讲解。其他部分请参考其他题解。

由于此题的概率递推式成环，所以我们需要二分初值。假设二分初值为 $f_1$。

得到的答案 $f_2$ 必定为 $pf_1+(1-p)f_3(0\le p\le 1)$，这里的 $f_3$ 为其他非初值部分递推而来的概率，感性理解一下，将标准答案带入，发现 $f_3$ 就是标准答案。

假设标准答案为 $f_3$，令 $\Delta=f_3-f_1$。我们将关于 $f_2$ 的式子展开：

$$f_2=pf_1+(1-p)f_3$$

$$f_2=p(f_3-\Delta)+(1-p)f_3$$

得到：

$$f_3-p\Delta=f_2$$

又因为：

$$f_3-\Delta=f_1$$

显然，$\lvert f_3-f_2\rvert\le\lvert f_3-f_1\rvert$。等号成立当且仅当 $\Delta=0$。

重要的结论证明完了，便有了如果 $f_2\gt f_1$ 则必有 $f_3\gt f_1$，反之小于 $f_3\lt f_1$。二分方向至此可以确定。

---

## 作者：cmk666 (赞：1)

[题目传送门](/problem/P9144)

场上没加二分，一直寄/ll

一看 $n\le 6$，可以直接对每个关卡的三种决策进行爆搜，取概率的 $\max$。

然后你会发现搜的时候需要用到自己的概率，这时候考虑二分。具体的，先把这个概率设成某个数，如果搜出来的结果比它大，则答案区间应该增大，反之亦然。

注意特判掉第一关就放弃或者寄了，这些情况是完全没有意义的。

精度不能设太小不然会被卡常。

代码很丑，不贴了。

---


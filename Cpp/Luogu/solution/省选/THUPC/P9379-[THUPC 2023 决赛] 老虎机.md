# [THUPC 2023 决赛] 老虎机

## 题目描述

小 I 经营着一个电玩城，最近引进的新型老虎机深受欢迎。

作为经营者，小 I 首先需要设定老虎机的状态。老虎机的状态为一个三元组 $(l,S,\mathbf{p})$，其中

- $l$ 是一个正整数；
- $S$ 是一个非空字符串集合，其中所有的字符串均是长度为 $l$ 的 01 串；
- $\mathbf{p}$ 是一个长度为 $l$ 的实数序列 $p_0,p_1,\dots,p_{l-1}$，其中对于任意 $0 \le i \le l - 1$，$0 < p_i \le 1$。

设定好状态后即可开始游戏。每一轮游戏的流程如下：

- 玩家首先获得老虎机的状态 $(l,S,\mathbf{p})$。
- 老虎机内部选择一个串 $s \in S$ 作为答案串，玩家需要通过与老虎机进行若干次交互得到答案串。
  - 每一次交互中，玩家投入一个游戏币并拉下老虎机的拉杆，然后老虎机的界面中会出现一个长度为 $l$ 的信息串 $t$。对于 $0 \le i \le l - 1$，$t_i$ 有 $p_i$ 的概率为 $s_i$，有 $(1-p_i)$ 的概率为 `?`。
  - 交互过程中生成信息串进行的所有随机过程两两独立。
- 当玩家可以根据**老虎机的状态和交互得到的若干信息串**唯一确定答案串后，即可将答案串输入老虎机并结束游戏、获得奖励。

小 I 设定好了一个状态，但还不知道设定多少奖励。为了让奖励和难度匹配，小 I 想知道：对于 $S$ 中的每个串 $t$，在玩家以最优策略游玩（即一旦可以唯一确定答案串就结束游戏）的情况下，若答案串为 $t$，玩家期望需要投入多少游戏币。

由于小 I 不喜欢实数，你需要将答案对 $998244353$ 取模。

## 说明/提示

**【样例解释 #1】**

- 对于第一组测试数据，每一次交互有 $\frac{5000}{10000} = \frac{1}{2}$ 的概率知道答案串是 $0$ 还是 $1$，有 $\frac{1}{2}$ 的概率不能获得信息，因此期望游戏币数为 $\sum_{i=1}^{+\infty} \frac{i}{2^i} = 2$。
- 对于第二组测试数据，每一次交互都可以得到字符串的第二位，有 $\frac{1}{10000}$ 的概率得到字符串的第一位。第二个字符串为答案串时可以通过字符串的第二位唯一确定，而其他两个字符串为答案串时必须要得到字符串的第一位。
- 对于第三组测试数据，由于 $|S| = 1$，所以不需要任何交互就可以确定答案串。
- 对于第四组测试数据，我有一个绝妙的解释，可这里空间太小写不下。

**【数据范围】**

对于所有测试数据，$1 \le T \le 10$，$1 \le l \le 15$，$1 \le n \le 2^l$，$1 \le c_i \le 10^4$，$s_1,\dots,s_n$ 为两两不同的长度为 $l$ 的 01 串。

**【后记】**

“喂喂喂，未成年人不准进入电玩城！什么？你们说你们要进去学算法竞赛？谁信你的鬼话！”

**【题目来源】**


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
4
1 2
5000
0
1
2 3
1 10000
00
01
10
1 1
1
1
3 4
8888 7777 5555
000
010
101
110
```

### 输出

```
2
2
10000
1
10000
0
209031157
194428714
835313860
674719626
```

# 题解

## 作者：Alex_Wei (赞：7)

### C. [P9379 [THUPC 2023 决赛] 老虎机](https://www.luogu.com.cn/problem/P9379)

显然，我们只关心已经确定的位置集合 $A$。称 $A$ 合法，当且仅当 $A$ 可以确定目标串。

对于操作次数的期望，经典套路是根据期望的线性性，求出到达每个不合法状态的概率 $P_S$，乘以停留在该状态的期望时间 $t_S$，再求和。注意到 $A$ 合法则 $A$ 的超集合法，因此最终求答案时需要的 $P$ 和 $t$ 和目标串无关，即若一个状态不合法，则到达它的概率不受到目标串的影响，考虑预处理。

设 $p_S$ 表示停留在状态 $S$ 的概率，则 $p_S = \prod_{i\notin S} (1 - p_i)$。根据经典结论，$t_S = \sum_{x = 0} ^ {+\infty} p_S ^ x = \frac {1} {1 - p_S}$，即 $x$ 次操作后仍停留在 $S$ 的概率乘以代价 $1$，求和。

从 $P_S\to P_T$ 的转移系数为 $\frac {\prod_{i\notin T} (1 - p_i) \prod_{i\in T\land i\notin S} p_i} {1 - p_S}$。预处理 $f_S = \prod_{i\in S} p_i$，$g_S = f_S \prod_{i\notin S} (1 - p_i)$，则系数为 $\frac {g_T} {f_S - g_S}$。枚举超集 DP，时间复杂度 $\mathcal{O}(3 ^ l)$。这部分也可以做到 $\mathcal{O}(2 ^ ll)$（类似 A 题按位处理）。

对于目标串 $s_i$，设 $T_i$ 表示多少个已知位置集合使得可以唯一确定 $s_i$，即 $s_i$ 的合法位置集合，则答案为 $\sum_{A\notin T} P_At_A$。

显然，对于任意 $A$，它不会出现在超过 $2 ^ {|A|}$ 个 $T_i$ 中。因此 $\sum |T_i| \leq 3 ^ l$。考虑补集转化，将答案写成 $\sum_{A} P_At_A - \sum_{A\in T_i} P_At_A$。前者在预处理 $P, t$ 时直接求，关键在于如何求 $T_i$。

其实也不难。设 $h_{S, T}$ 表示位置集合为 $S$ 时，状态为 $T$ 的唯一的串的标号。如果没有则为 $0$，如果有多个则为 $-1$。初始化 $h_{U, s_i} = i$，其中 $U$ 是全集 $\{0, 1, \cdots, l - 1\}$。$h_S$ 容易从 $h_{S\cup \{x\}}$ 转移过来，其中 $x$ 是任意一个不属于 $S$ 的位置。如果 $h_{S, T} = i$，则将 $s_i$ 的答案减去 $P_S t_S$。

时间复杂度 $\mathcal{O}(3 ^ l)$。[代码](https://uoj.ac/submission/746237)。

---

## 作者：__stick (赞：5)



## 题意

一个 01 串集合 $S$ 有一些长度为 $l$ 的字符串，有一个机器，每次对于每一位有 $p_i$ 的概率给出当前位的情况，对于每个字符串，求出来期望需要操作多少次可以唯一确定当前字符串。

## 思路

一个想法是对于每个字符串求出我们必须要知道哪些位置才能确定当前字符串。

对于每一位，我们在操作过后有三种情况：已知是 $0$，已知是 $1$，未知（用 $2$ 表示）。用一个三进制数表示当前状态。

对于某一个状态，如果其中有 $2$ 我们就看看将 $2$ 换成 $0/1$ 是否会出现两个不同的字符串，如果不会，则当前状态是合法状态，可以确定某一个字符串。

这个因为先换哪个 $2$ 不影响答案，可以使用 lowbit 递推，每次找到当前状态最低位的 $2$，然后对将当前位换成 $0/1$ 的两个状态的情况进行讨论。

对于一个字符串来说，只要我们到达了属于它的某个状态就能确定它，所以问题就是这个期望时间的求法。

对一个字符串来说，每一位有知道和不知道两种情况，可以在使用二进制数表示

现在的问题就是对于每一个状态我们到达当前状态的期望步数是多少，发现合法后再操作仍然合法，于是考虑处理不合法的期望时间。

每个不合法状态停留的期望乘上到达这个状态的概率和即是在不合法位置停留的期望时间。

概率可以简单 dp 出来，然后期望时间就是每次操作都选择已经选过的概率的倒数。

## code

照着 std 写的。

```c++
#include<bits/stdc++.h>
//#pragma GCC optimize("Ofast")
using namespace std;
template<typename T>
inline bool cmax(T&x,const T& y){return x<y?x=y,1:0;}
template<typename T>
inline bool cmin(T&x,const T& y){return y<x?x=y,1:0;}
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> vi;
typedef vector<vector<int> > vii; 
typedef unsigned long long ull;
#define sz(x) (int(x.size()))
#define all(x) (x).begin(),(x).end()
#define pb push_back
#define eb emplace_back
#define em emplace
#define X first
#define Y second
const int mod=998244353;
inline void MOD(int&x){x-=mod,x+=x>>31&mod;}
inline void MOD(ll& x){x-=mod,x+=x>>63&mod;}
inline int add(int x,int y){MOD(x+=y);return x;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
template<typename ... A>inline int mul(const int& x,const A&... p){return 1ll*x*mul(p...)%mod;}
inline ll ksm(ll a,ll p=mod-2){ll ans=1;for(;p;p>>=1,a=a*a%mod)if(p&1)ans=ans*a%mod;return ans;}
typedef long double LD;
const int MAXN=600+10;
int po[20],p[20];
int lowbit[14348907+10],id[14348907+10],rev[14348907+10];
int val[1<<15|1],F[1<<15|1][16];

inline void solve()
{
    int L,n;cin>>L>>n;
    for(int i=0;i<L;i++)cin>>p[i],p[i]=ksm(10000)*p[i]%mod;
    memset(F,0,sizeof(F));
    val[0]=1;
    int sum=0;
    for(int s=0;s<(1<<L);s++)
    {
        auto update=[&]()
        {
            for(int i=0;i<L;i++)
            {
                if(s>>i&1)MOD(F[s][i+1]+=F[s][i]);
                else
                {
                    MOD(F[s|(1<<i)][i+1]+=mul(F[s][i],p[i]));
                    MOD(F[s][i+1]+=mul(F[s][i],1+mod-p[i]));
                }
            }
        };
        update();
        if(s)val[s]=F[s][L];
        else val[s]=1;
        int pp=1;
        for(int i=0;i<L;i++)if((~s)>>i&1)pp=mul(pp,1+mod-p[i]);
        int inv=ksm(mod+1-pp);
        memset(F[s],0,sizeof(F[s]));
        F[s][0]=mul(val[s],inv);
        update();
        val[s]=mul(val[s],inv);
        MOD(sum+=val[s]);
    }
    memset(id,0,sizeof(id));
    for(int i=1;i<=n;i++)
    {
        string s;cin>>s;
        int x=0;reverse(all(s));
        for(auto&p:s)x=x*3+p-'0';
        id[x]=i;
    }
    vi ans(n+1);
    
    for(int s=0;s<po[L];s++)
    {
        if(~lowbit[s])
        {
            int u=id[s-po[lowbit[s]]],v=id[s-po[lowbit[s]]*2];
            if(u==-1||v==-1||(u!=0)&&(v!=0))id[s]=-1;
            else id[s]=u|v;
        }
        if(id[s]>0)MOD(ans[id[s]]+=val[rev[s]^((1<<L)-1)]);
    }
    for(int i=1;i<=n;i++)cout<<(sum+mod-ans[i])%mod<<'\n';
}
int main()
{
    po[0]=1;for(int i=1;i<=15;i++)po[i]=po[i-1]*3;
	for(int i=0;i<po[15];i++)
    {
        lowbit[i]=-1;
        for(int j=0,x=i;j<15;j++,x/=3)
        {
            if(x%3==2){lowbit[i]=j;break;}
        }
        if(~lowbit[i])rev[i]=rev[i-po[lowbit[i]]*2]|1<<lowbit[i];
    }
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(10);
	int T;cin>>T;while(T--)solve();
	return 0;
} 
```







 





---

## 作者：tzl_Dedicatus545 (赞：0)

### Preface

[none]

### Solution

首先注意到题目相当于在一个有向图上走，每个位置可能是 $\{0,1,?\}$，然后当我们走到某个状态时，我们就可以唯一确定对应的答案串，游戏就结束了，我们将这类状态记作终点。

显然对于老虎机来说，当前对于每一位只有知道与不知道两种状态（也就是说，每一位是 $0$ 还是 $1$ 对于走到这个节点的概率来说是没有区别的）。每次询问后，你会从当前状态 $S$ 转移到某个状态 $S\cup T$。注意到一次询问可能啥也没确定，所以你还会额外再每个点停留 $a_S$ 的时间，然后你枚举子集就可以做到 $O(3^n)$ 计算走到某个状态的概率。

我们要计算的实际上是对于所有从 $0$ 走到某一个终点的路径 $S$，计算 $\Pr(s)\cdot\sum_{u\in S} a_u$。

那你拆贡献，答案其实就是对于图上的每个**非终点** $u$，走到 $u$ 的概率乘上 $a_u$ 的和。

显然接下来的问题就变成了对于每个答案串，确定它的终点串集合，这个东西的总大小是 $O(3^n)$ 的，所以可以做。

接下来你要对于每种三进制状态，求他是否能唯一确定某个答案。这个东西考虑每次找出串中的一个 $?$，把 $?$ 分别改成 $0$ 和 $1$，然后合并状态就行。

找出串中的 $?$ 是一个 $\text{lowbit}$ 状物，注意到 $\sum 3^i(n-i+1)=O(3^n)$，所以暴力枚举复杂度就是对的。

---


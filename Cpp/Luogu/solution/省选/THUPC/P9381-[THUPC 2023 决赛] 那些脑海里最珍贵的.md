# [THUPC 2023 决赛] 那些脑海里最珍贵的

## 题目背景

E.Space：设定很怪，别问为什么，问就是看附件。

_没有人听懂的傻话_

_还记得吗_

_写满青春的围墙_

_好努力练习的倔强_

_浅浅伤疤_

_勇敢是我们的翅膀_

_——张韶涵《还记得吗》_

## 题目描述

故事的世界观大概是这样的。这个世界的人分为三类，根据其某种特点被直接命名为 Weak，Average 和 Strong。你可以理解为这是一个关于种族或者职业的分类。

两个队伍之间发生了一场回合制战斗。你知道双方做了什么，现在希望你把所有的细节还原出来。

下面是本题的一些技术细节。

**【人物】**

一个人有以下几种属性值：「种族」、「等级」、「体力上限」、「基础攻击指数」、「基础防御指数」、「主动技能等级」、「被动技能等级」。其中「体力上限」、「基础攻击指数」、「基础防御指数」完全由「种族」和「等级」决定。但是为了输入方便，本题中所有信息都会给出。在战斗中，每个人有一个「体力值」。在战斗开始时，「体力值」等于「体力上限」。当「体力值」小于等于 $0$ 时这个人就会「倒下」。对于同一个「种族」而言，「体力上限」、「基础攻击指数」、「基础防御指数」大致随「等级」指数增长。每个人持有一把「武器」。「武器」的细节在下一节给出。

**【武器】**

「武器」的属性只有两种：「武器类型」和「武器攻击力」。所有「武器」都有「普通攻击」和「特殊攻击」两种攻击方式。发起「攻击」指使用这两种方式中的任意一种。「普通攻击」的效果与「武器类型」无关，但不同的「武器类型」有着不同的「特殊攻击」效果。「武器」有三种类型，分别叫做「B」、「G」、「M」。

**【战场与队伍】**

交战双方的每一方包含不超过 $6$ 名队员，一字排开，从西到东的编号分别为 $5,3,1,2,4,6$（若不足 $6$ 名则删去较大的若干个编号）。方便起见，就叫两队为「南队」和「北队」。

**【回合】**

每个「回合」中，只有一个人可以「行动」。第奇数个「回合」是「南队」的队员「行动」，第偶数个「回合」是「北队」的队员「行动」。第一个「回合」和第二个「回合」中，「行动」的人是队伍里未「倒下」的编号最小的人。之后的「回合」中，若本队中没有编号比本队上一个「行动」的人大且未「倒下」的人，则由本队中编号最小的未「倒下」的人「行动」。否则由编号大于本队上一个「行动」者的人中，编号最小且未「倒下」的人「行动」。若一个队伍中的所有队员均已「倒下」，则判另一个队伍「胜利」。

**【行动】**

「行动」一共有三种。当前「回合」中「行动」的人必须选择三种之一来完成。

1. 「普通攻击」；
2. 「特殊攻击」；
3. 「主动技能」。

这些「行动」的效果会在之后介绍。「特殊攻击」和「主动技能」是有次数限制的，但是在本题中，保证所有「行动」均合法，所以你不需要考虑这个限制。

**【伤害计算】**

「伤害」指的是因为「普通攻击」或「特殊攻击」而造成的「体力值」减少。

「伤害」，即「体力值」减少的量，由「攻击强度」和受到「伤害」的人的「防御指数」决定。

一个人的「防御指数」等于这个人的「基础防御指数」乘以队伍的「防御加成」。

具体地，若一个人受到「攻击强度」为 $x$ 的「伤害」，那么这个人的「体力值」就会减少 $y$。其中 $y$ 的值等于 $x$ 除以这个人的「防御指数」下取整。

「攻击强度」等于「基础攻击强度」乘以发起「攻击」的人的「技能加成」乘以队伍的「攻击加成」乘以「种族克制加成」乘以「方位加成」。这些概念会在之后介绍。

**【普通攻击】**

选择一个敌方未「倒下」的队员作为「目标」。「目标」受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」的「伤害」。

**【特殊攻击】**

选择一个敌方未「倒下」的队员作为「目标」。

「武器」有三种，不同「武器类型」的「特殊攻击」效果如下：

- 「B」：「目标」受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $125\%$ 的「伤害」。
- 「G」：「目标」和「目标」东西两侧与「目标」距离最近的各一名未「倒下」的队员（如果存在）均受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $x\%$ 的「伤害」。其中 $x$ 的值等于 $135$ 除以将要受到「伤害」的人数。「伤害」按照「目标」、「目标」西侧、「目标」东侧的顺序计算。注意如果过程中有人「倒下」，那么这个人的「被动技能」将不再对该顺序中位于这个人之后的人的「伤害」结算起作用。特别地，所有「伤害」的「方位加成」以「目标」的「躲闪方位」来计算。
- 「M」：「目标」受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $115\%$ 的「伤害」。「目标」东西两侧与「目标」距离最近的各一名未「倒下」的队员（如果存在）分别受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $23\%$ 的「伤害」。「伤害」按照「目标」、「目标」西侧、「目标」东侧的顺序计算。注意如果过程中有人「倒下」，那么这个人的「被动技能」将不再对该顺序中位于这个人之后的人的「伤害」结算起作用。特别地，所有「伤害」的「方位加成」以「目标」的「躲闪方位」来计算。

**【技能】**

「技能」分为「主动技能」和「被动技能」。每个「种族」的人都有一个「主动技能」和一个「被动技能」。「技能」的效果因「种族」和「技能等级」的不同而不同。「技能等级」为一个 $0$ 到 $5$ 之间的整数。「技能等级」为 $0$ 表示没有该「技能」。

使用「主动技能」需要选择一个人作为「技能目标」。

「主动技能」描述如下：（$1$ 到 $5$ 级的「技能」效果由斜杠隔开，保证使用「主动技能」的人的「主动技能等级」不为 $0$）

- 「Weak 种族」：使本队一名未「倒下」的队员的「体力值」增加这名队员的「体力上限」乘以 $10\%/12\%/15\%/17\%/20\%$ 下取整。
- 「Average 种族」：选择一名敌方未「倒下」的队员，在使用该「主动技能」这一队的「回合」结束时，其「体力值」减去其「体力上限」的 $6\%/7\%/8\%/9\%/10\%$ 下取整。该效果持续 $3$ 个回合，即会触发 $3$ 次。若该队员已有同类型（可以是不同等级）的「技能」施加的效果，那么这个效果将会覆盖之前的效果。
- 「Strong 种族」：使本队一名未「倒下」的队员的「技能加成」变为 $2.1/2.17/2.24/2.32/2.4$。

一名队员的「被动技能」只有当该队员未「倒下」时才能发挥效果，「倒下」之后不再发挥效果。

「被动技能」描述如下：

- 「Weak 种族」：在本队的「回合」开始时，本队所有未「倒下」的成员的「体力值」增加该成员「体力上限」的 $1.3\%/1.6\%/1.9\%/2.2\%/2.5\%$。若本队有多名队员有这个「技能」，这个效果的数值可以相加至最多 $5\%$。超过 $5\%$ 按照 $5\%$ 计算。「体力值」增加的量在效果叠加后需要下取整。
- 「Average 种族」：队伍的「防御加成」初始为 $1$。该技能使队伍的「防御加成」增加 $0.01/0.02/0.03/0.04/0.05$。若本队有多名队员有这个「技能」，这个效果的数值可以相加至最多 $0.1$。超过 $0.1$ 按照 $0.1$ 计算。
- 「Strong 种族」：队伍的「攻击加成」初始为 $1$。该技能使队伍的「攻击加成」增加 $0.01/0.02/0.03/0.04/0.05$。若本队有多名队员有这个「技能」，这个效果的数值可以相加至最多 $0.1$。超过 $0.1$ 按照 $0.1$ 计算。

一名队员的「体力值」增加时，不能超过这名队员的「体力上限」。若增加后的「体力值」超过了「体力上限」，则把这次增加「体力值」的效果改为将这名队员的「体力值」变成这名队员的「体力上限」。

**【技能加成】**

战斗开始时，所有人的「技能加成」都是 $1$。只有两种方式能够改变「技能加成」：

- 「Strong 种族」的「主动技能」。见「技能」的描述。
- 当一个人发起「攻击」且计算完这次「攻击」的所有「伤害」之后，这个人的「技能加成」变为 $1$。

**【种族克制加成】**

「种族克制加成」与发起「攻击」的人的「种族」以及受到「伤害」的人的「种族」有关。「种族克制加成」的值如下表：


| 发起「攻击」方/受到「伤害」方 | Weak  | Average | Strong |
| :---------------------------: | :---: | :-----: | :----: |
|             Weak              | $1.0$ |  $0.9$  | $1.1$  |
|            Average            | $1.1$ |  $1.0$  | $0.9$  |
|            Strong             | $0.9$ |  $1.1$  | $1.0$  |



**【方位加成】**

在「攻击」时，发起「攻击」的一方有一个「攻击方位」，「攻击」的「目标」有一个「躲闪方位」。「攻击方位」和「躲闪方位」分别为一个 $1$ 到 $6$ 之间的整数。当「攻击方位」为 $a$，「躲闪方位」为 $d$ 时，「方位加成」的值由下表所示：


| $(a-d)\bmod 6$ | 「方位加成」 |
| :------------: | :----------: |
|      $0$       |    $1.25$    |
|   $1$ 或 $5$   |    $1.00$    |
|   $2$ 或 $4$   |    $0.75$    |
|      $3$       |    $0.00$    |



## 说明/提示

**【样例 #2】**

见题目目录下的 *2.in* 与 *2.ans*。

**【样例解释 #2】**

这个样例，无疑是善良的出题人无私的馈赠。中间忘了。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。

**【数据范围】**

保证 $1\le n,m \le 6$。

保证 $1\le T \le 50000$。

保证「武器攻击力」的范围在 $300$ 到 $80000$ 之间。

「体力上限」「基础攻击指数」「基础防御指数」的范围见下表。

| 「种族」与「等级」 | 「体力上限」 | 「基础攻击指数」 | 「基础防御指数」 |
| :----------------: | :----------: | :--------------: | :--------------: |
|     Weak Lv.1      |   $100000$   |    $0.75000$     |    $0.010000$    |
|    Average Lv.1    |    $5000$    |    $0.80000$     |    $0.20000$     |
|    Strong Lv.1     |    $100$     |     $1.0000$     |     $10.000$     |
|    Weak Lv.100     |  $7807514$   |     $1.0089$     |    $0.10464$     |
|   Average Lv.100   |   $252234$   |     $1.3108$     |     $1.8101$     |
|   Strong Lv.100    |    $3512$    |     $1.6385$     |     $125.11$     |

 

**【后记】**

_有一天我将会老去_

_希望你会觉得满意_

_我没有 对不起那个_

_十五岁的自己_

_——刘若英《继续-给十五岁的自己》_

**【题目来源】**

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
2 1
Strong Lv=90 maxhp=2451 atk=15588e-4 def=96931e-3 skillLv=5 passivesklLv=5 M weaponatk=80000e0
Strong Lv=100 maxhp=3512 atk=16385e-4 def=12511e-2 skillLv=5 passivesklLv=5 G weaponatk=80000e0
Weak Lv=1 maxhp=100000 atk=75000e-5 def=10000e-6 skillLv=5 passivesklLv=5 B weaponatk=80000e0
3
Skill target=2
Specialattack target=1 atkpos=3 ddgpos=3
Specialattack target=1 atkpos=5 ddgpos=5
```

### 输出

```
South 1 applied Strong skill to South 2
North: 100000/100000
South: 2451/2451 3512/3512

South 1 took 1063 damage from North 1 -> 1388/2451
North: 100000/100000
South: 1388/2451 3512/3512

North 1 took 52556526 damage from South 2 -> 0/100000
North: 0/100000
South: 1388/2451 3512/3512

Team South won.
```

# 题解

## 作者：fush (赞：13)

# 题解-那些脑海里最珍贵的
## 题目链接  
[题目链接](https://www.luogu.com.cn/problem/P9381)
## 题意
题目的大意：先输入两个小队（南队、北队）每个人的角色，血量，攻击力，防御力，武器类型等基本信息。在每个回合，先判断这个回合行动的人，再输入这个回合的行动（普通攻击、特殊攻击、技能），在回合结束时输出两队每人的血量。
## 重点
**1. 写模拟题时**
  - 多读题，尽量写对每一个细节。  
  - 不要把所有代码放在主函数中，这样会特别乱，而且写完后调试的时候也会特别耗时间，把每一块代码放在不同的函数中会更方便。  
  - 一定要写注释，特别是变量名，不然在后面调试的时候根本不知道在写什么。  
  - 要保证代码结构清晰，保证代码可读性。

**2. 本题要注意的点**
  - 回血时，如果回血值为 $0$ 则**不用输出**。    
  - 攻击时，即使攻击值是 $0$ 也**需要输出**。    
  - 「Average」 的「主动技能」是在**使用的这队回合结束后扣血，对方的回合结束后不会扣血**，且输出格式与其他攻击不同。  
  - 注意每种角色的**被动技能的上限**，在计算的时候用 `min` 控制。  
- 「Weak」 的「被动技能」只在**本队回合开始**时回血，而 「Average」 和 「Strong」 的「被动技能」是**一直存在**的，除非他们「倒下」了。    
- 计算完一次攻击的**所有伤害**之后再把「技能加成」赋值为 $1$。  
- 注意每个人的编号与站位的区别。  


## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
enum HR/*种群*/{week=0,average=1,strong=2};
enum T/*队伍*/{north=1,south=0};
enum AT/*武器种类*/{B=1,G=2,M=3};
struct human{//人 
	HR race;//人种 
	string race2;//人种 
	int level;//血量，体力值
	int max_level;//最大血量 
	int Lv;//等级
	double b_attack;//基础攻击指数
	double b_defense;//基础防御指数
	int s_skill_Lv;//主动技能等级
	int p_skill_Lv;//被动技能等级
	AT type;//武器种类 
	double arm_attack;//武器攻击力
	bool die;//死亡 
	int position;//站位 
	double s_bonu;//技能加成 
	int a_skill_Lv;//a技能层数 
	int a_skill_att;//a技能伤害 
};
struct team{//队伍 
	human t[8];
	double att_bonu;//攻击加成
	double def_bonu;//防御加成 
	double re_bl_speed;//回血速度 
	int num;//剩余人数 
	int ans;//总人数
	int last;//上一个行动的人 
	string name;//队伍名字（南，北） 
}ranks[2];
double wps[]={0,0.013,0.016,0.019,0.022,0.025};//w的被动技能 
double wss[]={0,0.1,0.12,0.15,0.17,0.2};//w的主动技能 
double aps[]={0,0.01,0.02,0.03,0.04,0.05};//a的被动技能 
double ass[]={0,0.06,0.07,0.08,0.09,0.1};//a的主动技能 
double sps[]={0,0.01,0.02,0.03,0.04,0.05};//s的被动技能 
double sss[]={0,2.1,2.17,2.24,2.32,2.4};//s的主动技能
int forma[7]={0,3,4,2,5,1,6}/*对照*/;
double dire_bonu(int attpos/*攻击方位*/,int defpos/*防御方位*/){//方位加成 
	double t[]={1.25,1,0.75,0,0.75,1};
	int x=abs(attpos-defpos)%6;
	return t[x];
}
double race_restraint(HR atter/*攻击者*/,HR defer/*防御者*/){//种类克制 
	double t[3][3]{
		{1,0.9,1.1},
		{1.1,1,0.9},
		{0.9,1.1,1.0}
	} ;
	return t[atter][defer];
}
void down(team &de,human &dead){//料理后事 
	dead.die=0;
	de.num--;
	dead.a_skill_Lv=0;
	if(dead.race==0)de.re_bl_speed-=wps[dead.p_skill_Lv];
	if(dead.race==1)de.def_bonu-=aps[dead.p_skill_Lv];
	if(dead.race==2)de.att_bonu-=sps[dead.p_skill_Lv];
	dead.level=0;
}
void attack(human &atter/*攻击者*/,human &defer/*防御者*/,team att,team &def,
			 double A/*基础攻击强度*/,int attpos,int defpos){//攻击
	if(!defer.die)return ;
	double B=atter.s_bonu;//技能加成 
	double C=min(att.att_bonu+1,1.1);//队伍攻击加成 
	double D=race_restraint(atter.race,defer.race);//种族克制 
	double E=dire_bonu(attpos,defpos);//方位加成 
	double x=A*B*C*D*E;//攻击强度 
	double F=defer.b_defense;//基础防御指数
	double G=min(def.def_bonu+1,1.1);//队伍防御加成 
	double y=F*G;//防御指数 
	int z=floor(x/y);
	defer.level=max(0,defer.level-z);
	if(defer.level<=0)down(def,defer);
	cout<<def.name<<" "<<defer.position<<" took "<<z<<" damage from ";
	cout<<att.name<<" "<<atter.position<<" -> "<<defer.level<<"/"<<defer.max_level<<endl;
}
void com_attack(human &atter,human &defer,team att,team &def,int attpos,int defpos){//基础攻击
	attack(atter,defer,att,def,atter.b_attack*atter.arm_attack,attpos,defpos);
	atter.s_bonu=1;
}
void spe_att_B(human &atter,human &defer,team att,team &def,int attpos,int defpos){//特殊攻击B 
	attack(atter,defer,att,def,atter.b_attack*atter.arm_attack*1.25,attpos,defpos); 
	atter.s_bonu=1;
}
void spe_att_G(human &atter,human &defer,team att,team &def,int defer1,int attpos,int defpos){//特殊攻击G
	int s=1,l=0,r=0;
	for(int i=defer1-1;i>=1;i--)//左侧的人 
		if(def.t[i].die){
			s++,l=i;
			break;
		}
	for(int i=defer1+1;i<=6;i++)//右侧的人 
		if(def.t[i].die){
			s++,r=i;
			break;
		}
	attack(atter,defer,att,def,atter.b_attack*atter.arm_attack*1.35/s,attpos,defpos);
	if(l)attack(atter,def.t[l],att,def,atter.b_attack*atter.arm_attack*1.35/s,attpos,defpos);
	if(r)attack(atter,def.t[r],att,def,atter.b_attack*atter.arm_attack*1.35/s,attpos,defpos);
	atter.s_bonu=1;
}
void spe_att_M(human &atter,human &defer,team att,team &def,int defer1,int attpos,int defpos){//特殊攻击M
	int l=0,r=0;
	for(int i=defer1-1;i>=1;i--)//左侧的人 
		if(def.t[i].die){
			l=i;break;
		}
	for(int i=defer1+1;i<=6;i++)//右侧的人 
		if(def.t[i].die){
			r=i;break;
		}
	attack(atter,defer,att,def,atter.b_attack*atter.arm_attack*1.15,attpos,defpos);
	if(l)attack(atter,def.t[l],att,def,atter.b_attack*atter.arm_attack*0.23,attpos,defpos);
	if(r)attack(atter,def.t[r],att,def,atter.b_attack*atter.arm_attack*0.23,attpos,defpos);
	atter.s_bonu=1;
}
void w_skill(human &rec,string att,double re_bonu){//w的技能 
	if(rec.max_level==rec.level||!rec.die)return;
	int x=floor(rec.max_level*re_bonu);
	if(x<=0)return;
	rec.level=min(rec.max_level,rec.level+x);
	cout<<att<<" "<<rec.position<<" recovered +"<<x<<" hp -> "<<rec.level<<"/"<<rec.max_level<<endl;
}
void a_skill(human atter,human &defer){//a的特殊技能 
	defer.a_skill_Lv=3;
	defer.a_skill_att=floor(defer.max_level*ass[atter.s_skill_Lv]);
}
void s_skill(human atter,human &rec){//s的特殊技能
	 rec.s_bonu=sss[atter.s_skill_Lv];
}
int mover(team move,int round){//行动者 
	int l=0;
	if(round>0)
		for(int i=move.last+1;i<=move.ans;i++)
			if(move.t[forma[i]].die)return i;
	for(int i=1;i<=move.ans;i++)
		if(move.t[forma[i]].die)return i;
}
void into(T a,int n){
	ranks[a].num=n;
	ranks[a].ans=n;
	for(int i=1;i<=n;i++){
		int k=forma[i];
		char x[10];
		char c;
		scanf("%s Lv=%d maxhp=%d atk=%lf def=%lf skillLv=%d passivesklLv=%d %c weaponatk=%lf",x,
				&ranks[a].t[k].Lv,&ranks[a].t[k].max_level,&ranks[a].t[k].b_attack,&ranks[a].t[k].b_defense,
				&ranks[a].t[k].s_skill_Lv,&ranks[a].t[k].p_skill_Lv,&c,&ranks[a].t[k].arm_attack);
		int len = strlen(x);
		for(int l=0;l<len;l++)ranks[a].t[k].race2+=x[l];
		ranks[a].t[k].s_bonu=1;
		ranks[a].t[k].level=ranks[a].t[k].max_level;
		ranks[a].t[k].position=i;
		ranks[a].t[k].die=1;
		human t1=ranks[a].t[k];
		if(ranks[a].t[k].race2=="Weak")ranks[a].t[k].race=week,ranks[a].re_bl_speed+=wps[t1.p_skill_Lv];
		else if(ranks[a].t[k].race2=="Average")ranks[a].t[k].race=average,ranks[a].def_bonu+=aps[t1.p_skill_Lv];
		else if(ranks[a].t[k].race2=="Strong")ranks[a].t[k].race=strong,ranks[a].att_bonu+=sps[t1.p_skill_Lv];
		if(c=='B')ranks[a].t[k].type=B;
		if(c=='G')ranks[a].t[k].type=G;
		if(c=='M')ranks[a].t[k].type=M;
	}
}
void summary(){
	cout<<"North:";
	for(int j=1;j<=6;j++)
	if(ranks[1].t[j].max_level)
		cout<<" "<<ranks[1].t[j].level<<"/"<<ranks[1].t[j].max_level;
	cout<<endl;
	cout<<"South:";
	for(int j=1;j<=6;j++)
	if(ranks[0].t[j].max_level)
		cout<<" "<<ranks[0].t[j].level<<"/"<<ranks[0].t[j].max_level;
	cout<<endl;
	cout<<endl;
}
int main(){
	int n,m,k;
	cin>>n>>m;
	ranks[1].name="North";
	ranks[0].name="South";
	into(south,n);
	into(north,m);
	cin>>k;
	for(int i=0;i<k;i++){
		team move=ranks[i%2];
		int l=i%2,r=(i+1)%2,round=(i+1)/2;
		for(int j=1;j<=move.ans;j++)
			w_skill(ranks[l].t[forma[j]],move.name,min(move.re_bl_speed,0.05));
		char x[20];
		scanf("%s ",x);
		int atter1=mover(move,round);
		int atter2=forma[atter1];
		ranks[l].last=atter1;
		if(x[0]=='B'){//普通攻击 
			int defer,attpos,defpos;
			scanf("target=%d atkpos=%d ddgpos=%d",&defer,&attpos,&defpos);
			com_attack(ranks[l].t[atter2],ranks[r].t[forma[defer]],move,ranks[r],attpos,defpos);
		}
		else if(x[1]=='p'){//特殊攻击 
			int defer,attpos,defpos;
			scanf("target=%d atkpos=%d ddgpos=%d",&defer,&attpos,&defpos);
			switch(move.t[atter2].type){
				case B:
					spe_att_B(ranks[l].t[atter2],ranks[r].t[forma[defer]],move,ranks[r],attpos,defpos);
					break;
				case G:
					spe_att_G(ranks[l].t[atter2],ranks[r].t[forma[defer]],move,ranks[r],forma[defer],attpos,defpos);
					break;
				case M:
					spe_att_M(ranks[l].t[atter2],ranks[r].t[forma[defer]],move,ranks[r],forma[defer],attpos,defpos);
					break;
			}
		}
		else{//主动技能 
			int rec;
			scanf("target=%d",&rec);
			switch(move.t[atter2].race){
				case week:
					cout<<move.name<<" "<<atter1<<" applied "<<ranks[l].t[atter2].race2<<" skill to ";
					cout<<move.name<<" "<<rec<<endl;
					w_skill(ranks[l].t[forma[rec]],move.name,wss[move.t[atter2].s_skill_Lv]);
					break;
				case average:
					cout<<move.name<<" "<<atter1<<" applied "<<move.t[atter2].race2<<" skill to ";
					cout<<ranks[r].name<<" "<<rec<<endl;
					a_skill(move.t[atter2],ranks[r].t[forma[rec]]);
					break;
				case strong:
					cout<<move.name<<" "<<atter1<<" applied "<<ranks[l].t[atter2].race2<<" skill to "<<move.name<<" "<<rec<<endl;
					s_skill(move.t[atter2],ranks[l].t[forma[rec]]);
					break;
			}
			//<team> <id> applied <type> skill to <targetteam> <targetid>
		}
		for(int l=1;l<=6;l++){//a的标记 
			int j=forma[l];
			if(ranks[r].t[j].a_skill_Lv&&ranks[r].t[j].die){
				ranks[r].t[j].level=max(0,ranks[r].t[j].level-ranks[r].t[j].a_skill_att);
				ranks[r].t[j].a_skill_Lv--;
				cout<<ranks[r].name<<" "<<ranks[r].t[j].position<<" took "<<ranks[r].t[j].a_skill_att<<" damage from skill -> ";
				cout<<ranks[r].t[j].level<<"/"<<ranks[r].t[j].max_level<<endl;
				if(ranks[r].t[j].level<=0)down(ranks[r],ranks[r].t[j]);
			}
	}
		summary();
	}
	if(!ranks[1].num)cout<<"Team South won.";
	if(!ranks[0].num)cout<<"Team North won.";
	return 0;
}
```

---

## 作者：向晚大魔王 (赞：12)

小 E 说要有题解，于是就有了题解。

按照题意模拟即可。

代码中始终让 $a$ 代表当前行动的一方。

一些需要注意的细节：

- 死人之后被动增益需要重算。
- 不造成伤害的攻击也要输出。
- **不造成生命值增加的回复不能输出。**
- 被动回血在回合开始时发动。
- **被动扣血在回合结束时发动。**
- **注意浮点数精度。**

和考场代码编辑距离不超过 20。

大样例不判主动技能回血时是否形成了实际的数值提升也能过，警钟敲烂。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
int read()
{
    int x=0,f=1,c=getchar();
    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
    while(c>47&&c<58)x=x*10+c-48,c=getchar();
    return x*f; 
}
using namespace std;
struct node
{
    char type[23];
    int lv,maxhp;
    int hp;
    double atk,def;
    int slv,pslv;
    char wtype[23];
    double watk;
    double ex_skill=1;
    double cut;
    int remainround;
    void in()
    {
        scanf("%s Lv=%lld maxhp=%lld atk=%Lf def=%Lf skillLv=%lld passivesklLv=%lld %s weaponatk=%Lf",
        type,&lv,&maxhp,&atk,&def,&slv,&pslv,wtype,&watk);
        // printf("%s %lld %lld %Lf %Lf %lld %lld %s %Lf\n",type,lv,maxhp,atk,def,slv,pslv,wtype,watk);
        hp=maxhp;
    }
}a[13],b[13];
const int p[]={0,5,3,1,2,4,6,0};
const int ip[]={0,3,4,2,5,1,6,0};
int n=read(),m=read();
double ex_type(node x,node y)
{
    char A=x.type[0],B=y.type[0];
    int va=0,vb=0;
    if(A=='A') va=1;
    if(A=='S') va=2;
    if(B=='A') vb=1;
    if(B=='S') vb=2;
    int s=(va+3-vb)%3;
    if(s==0) return 1;
    else if(s==2) return 0.9;
    else return 1.1;
}
double ex_pos(int ap,int dp)
{
    int g=(ap+6-dp)%6;
    if(g==0) return 1.25;
    else if(g==1||g==5) return 1;
    else if(g==2||g==4) return 0.75;
    else return 0;
}
const double ew_table[]={0,0.013,0.016,0.019,0.022,0.025};
const double ea_table[]={0,0.01,0.02,0.03,0.04,0.05};
const double es_table[]={0,0.01,0.02,0.03,0.04,0.05};
const double sw_table[]={0,0.1,0.12,0.15,0.17,0.2};
const double sa_table[]={0,0.06,0.07,0.08,0.09,0.1};
const double ss_table[]={0,2.1,2.17,2.24,2.32,2.4};
double Aexatk=1,Aexdef=1,Bexatk=1,Bexdef=1;
double heal;
void recalc()
{
    heal=0;
        Aexatk=Aexdef=Bexatk=Bexdef=1;
        for(int i=1; i<=n; ++i) if(a[i].hp>0)
        {
            if(a[i].type[0]=='W') heal+=ew_table[a[i].pslv];
            else if(a[i].type[0]=='A') Aexdef+=ea_table[a[i].pslv];
            else Aexatk+=es_table[a[i].pslv];
        }
        for(int i=1; i<=m; ++i) if(b[i].hp>0)
        {
            if(b[i].type[0]=='W');
            else if(b[i].type[0]=='A') Bexdef+=ea_table[b[i].pslv];
            else Bexatk+=es_table[b[i].pslv];
        }
        heal=min(heal,0.05L),Aexatk=min(Aexatk,1.1L),Aexdef=min(Aexdef,1.1L);
        Bexatk=min(Bexatk,1.1L),Bexdef=min(Bexdef,1.1L);
}
const double eps=1e-9;
signed main()
{
    for(int i=1; i<=n; ++i) a[i].in();
    for(int i=1; i<=m; ++i) b[i].in();
    int lsta=0,lstb=0;
    int T=read();
    char player[]="South";
    char rival[]="North";
    
    for(int I=1; I<=T; ++I)
    {
        recalc();
        // cout<<heal<<endl;
        for(int i=1; i<=n; ++i) if(a[i].hp>0&&a[i].hp<a[i].maxhp)
        {
            int qwq=a[i].maxhp*heal+eps;
            a[i].hp=min(a[i].maxhp,a[i].hp+qwq);
            if(qwq)
            printf("%s %lld recovered +%lld hp -> %lld/%lld\n",player,i,qwq,a[i].hp,a[i].maxhp);
            
        }
        char str[103];
        scanf("%s",str);
        int tgt,ap,dp,cur=-1;
        for(int i=lsta+1; i<=n; ++i) if(a[i].hp>0){cur=i;break;}
        if(cur==-1)for(int i=1; i<=n; ++i) if(a[i].hp>0){cur=i;break;}
        lsta=cur;
        // for(int i:{5,3,1,2,4,6}) if((i<=m)&&b[i].hp>0) printf("%lld ",i);
        // puts("");
        if(str[1]=='a') //basic
        {
            scanf(" target=%lld atkpos=%lld ddgpos=%lld\n",&tgt,&ap,&dp);
            int dmg=a[cur].atk*a[cur].watk*Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
            *a[cur].ex_skill/b[tgt].def/Bexdef+eps;
            b[tgt].hp=max(0ll,b[tgt].hp-dmg);
            printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
            rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
            a[cur].ex_skill=1;
        }
        else if(str[1]=='p') //special
        {
            scanf(" target=%lld atkpos=%lld ddgpos=%lld\n",&tgt,&ap,&dp);
            // double dmg=
            if(a[cur].wtype[0]=='B')
            {
                int dmg=a[cur].atk*a[cur].watk*Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
                *a[cur].ex_skill/b[tgt].def/Bexdef*1.25+eps;
                b[tgt].hp=max(0ll,b[tgt].hp-dmg);
                printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
                rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
            }
            else if(a[cur].wtype[0]=='G')
            {
                int left=ip[tgt]-1,right=ip[tgt]+1;
                while(left>=1&&(p[left]>m||b[p[left]].hp<=0)) --left;
                while(right<=6&&(p[right]>m||b[p[right]].hp<=0)) ++right;
                if(right>6) right=0;
                left=p[left],right=p[right];
                // printf("%d %d\n",left,right);
                int z=(left>0)+(right>0)+1;
                            int dmg=a[cur].atk*a[cur].watk
                            *Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
                            *a[cur].ex_skill*1.35
                            /b[tgt].def/Bexdef/z+eps;
                            b[tgt].hp=max(0ll,b[tgt].hp-dmg);
                            printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
                            rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
                tgt=left;
                if(tgt)
                {
                    recalc();
                    int dmg=a[cur].atk*a[cur].watk*Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
                    *a[cur].ex_skill*1.35/b[tgt].def/Bexdef/z+eps;
                    b[tgt].hp=max(0ll,b[tgt].hp-dmg);
                    printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
                    rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
                }
                tgt=right;
                if(tgt)
                {
                    recalc();
                    int dmg=a[cur].atk*a[cur].watk*Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
                    *a[cur].ex_skill*1.35/b[tgt].def/Bexdef/z+eps;
                    b[tgt].hp=max(0ll,b[tgt].hp-dmg);
                    printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
                    rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
                }
            }
            else
            {
                int left=ip[tgt]-1,right=ip[tgt]+1;
                while(left>=1&&(p[left]>m||b[p[left]].hp<=0)) --left;
                while(right<=6&&(p[right]>m||b[p[right]].hp<=0)) ++right;
                if(right>6) right=0;
                left=p[left],right=p[right];
                            int dmg=a[cur].atk*a[cur].watk*Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
                            *a[cur].ex_skill*1.15/b[tgt].def/Bexdef+eps;
                            b[tgt].hp=max(0ll,b[tgt].hp-dmg);
                            printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
                            rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
                tgt=left;
                if(tgt)
                {
                    recalc();
                    int dmg=a[cur].atk*a[cur].watk*Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
                    *a[cur].ex_skill*0.23/b[tgt].def/Bexdef+eps;
                    b[tgt].hp=max(0ll,b[tgt].hp-dmg);
                    printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
                    rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
                }
                tgt=right;
                if(tgt)
                {
                    recalc();
                    int dmg=a[cur].atk*a[cur].watk*Aexatk*ex_type(a[cur],b[tgt])*ex_pos(ap,dp)
                    *a[cur].ex_skill*0.23/b[tgt].def/Bexdef+eps;
                    b[tgt].hp=max(0ll,b[tgt].hp-dmg);
                    printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n",
                    rival,tgt,dmg,player,cur,b[tgt].hp,b[tgt].maxhp);
                }
            }
            a[cur].ex_skill=1;
        }
        else //skill
        {
            scanf(" target=%lld\n",&tgt);
            if(a[cur].slv!=0){ 
            if(a[cur].type[0]=='W')
            {
                printf("%s %lld applied %s skill to %s %lld\n",player,cur,a[cur].type,player,tgt);
                int qwq=a[tgt].maxhp*sw_table[a[cur].slv]+eps;
                bool ok=(a[tgt].hp==a[tgt].maxhp);
                a[tgt].hp=min(a[tgt].maxhp,a[tgt].hp+qwq);
                if(qwq&&ok==0)
                printf("%s %lld recovered +%lld hp -> %lld/%lld\n",player,tgt,qwq,a[tgt].hp,a[tgt].maxhp);
            }
            else if(a[cur].type[0]=='A')
            {
                printf("%s %lld applied %s skill to %s %lld\n",player,cur,a[cur].type,rival,tgt);
                b[tgt].cut=sa_table[a[cur].slv];
                b[tgt].remainround=3;
            }
            else
            {
                printf("%s %lld applied %s skill to %s %lld\n",player,cur,a[cur].type,player,tgt);
                a[tgt].ex_skill=ss_table[a[cur].slv];
            }}
        }
        for(int i=1; i<=m; ++i)
        {
            if(b[i].remainround>0&&b[i].hp>0)
            {
                int qwq=b[i].cut*b[i].maxhp+eps;
                --b[i].remainround,
                b[i].hp=max(b[i].hp-qwq,0ll);
                printf("%s %lld took %lld damage from skill -> %lld/%lld\n",rival,i,qwq,b[i].hp,b[i].maxhp);
            }
        }
        if(rival[0]=='S')
        {
            printf("North: ");
            for(int i:{5,3,1,2,4,6})
                if(i<=n) printf("%lld/%lld ",a[i].hp,a[i].maxhp);
            puts("");printf("South: ");
            for(int i:{5,3,1,2,4,6})
                if(i<=m) printf("%lld/%lld ",b[i].hp,b[i].maxhp);
        }
        else
        {
            printf("North: ");
            for(int i:{5,3,1,2,4,6})
                if(i<=m) printf("%lld/%lld ",b[i].hp,b[i].maxhp);
            puts("");printf("South: ");
            for(int i:{5,3,1,2,4,6})
                if(i<=n) printf("%lld/%lld ",a[i].hp,a[i].maxhp);
        }
        puts("");puts("");
        swap(a,b),swap(lsta,lstb),swap(n,m);
        swap(rival,player);
    }
    bool win=1;
    for(int i=1; i<=n; ++i) win&=(a[i].hp==0);
    if(win) printf("Team %s won.",rival);
    return 0;
}
```

---

## 作者：佬头 (赞：7)

# 题解 - 那些脑海里最珍贵的

[**佬夫的博客(空间跳跃)**](https://www.luogu.com.cn/blog/Glory-of-the-King/solution-p9381)

## Description

故事的世界观大概是这样的。这个世界的人分为三类，根据其某种特点被直接命名为 Weak，Average 和 Strong。你可以理解为这是一个关于种族或者职业的分类。

两个队伍之间发生了一场回合制战斗。你知道双方做了什么，现在希望你把所有的细节还原出来。

一道[多种族团队对战类回合制**纯模拟**游戏](https://www.luogu.com.cn/problem/P9381)。

## Import
- **写大模拟时**

	**1.** ~~像我们这种蒟蒻~~读题至少 $5$ 遍。~~我不信你不看题也能写。~~

	**2.** 先对所有信息做一个简单的**统计**，可以拿笔记下来，让你的思路更清晰。

	**3.** 输入部分打完后~~强烈~~建议将样例输入后**输出一遍**检查一下。

	**4.** 对每一个觉得有必要记录的信息（变量意义，函数作用等等）**注释**在代码后方，防止敲完后面的代码回头再看时忘记。

	**5.** **不要**全写在主函数里，可以将步骤拆分成多个函数，这样会使代码层次更清晰，检查时也会更方便。

	**6.** 信息量大的话，可以先拿**部分分**。

	**7.** **不要**压行，保持代码**优雅、明确**。
	
   **8.** 个人建议先自己写一会儿，实在不晓得错哪了再开题解~~瞻仰~~他人代码。
- **本题我认为比较重要的点**

	**1.** 「Weak 种族」的「被动技能」仅在本队「回合」开始时发动，「Average 种族」和「Strong 种族」的「被动技能」是一直开着的，除非他们「倒下」了。

	**2.** $1$ 到 $5$ 级的「技能」效果由斜杠隔开，这里指的「等级」是「技能等级」，而不是队员的「等级」更不是该队拥有该技能的人数。~~我一开始理解错了。~~

	**3.** 「Average 种族」的「主动技能」仅在使用该「主动技能」这一队的「回合」结束时触发，敌人的「回合」结束时并不会触发。

	**4.** 「Average 种族」和「Strong 种族」的「被动技能」是叠加的，而不是相乘的，即增加的不是原先加成的百分比。

	**5.** 每个「回合」开始前先处理「Weak 种族」的「被动技能」，每个「回合」的最后再处理「Average 种族」的「主动技能」。

	**6.** 建议将「伤害」计算单独分出写一个函数，每次「伤害」计算后在那个函数内 **check** 一下是否有队员「倒下」，这样要是写错了只要改一个地方就行了。

	**7.** 计算完本次「攻击」的**所有**「伤害」之后再把「技能加成」赋值为 $1$。**注：**「技能」效果不算「攻击」。

	**8.** 一个人「倒下」之后每个「回合」就不会再受到「Average 种族」的「主动技能」所造成的「体力值」减少，更不用输出。

	**9.** 交战双方的队员是**一字排开**的，而不是一个环。~~我把他当成环做了。~~

	**10.** 「主动技能」的施加对象可能是队友也可能是敌人。

	**11.** 对每个队伍更新「行动」的人应当在该队伍的「回合」开始时，而不能在结束时，因为在敌人的「回合」可能会将「行动」的队友击倒。

	**12.** 要及时处理好体力值的下限和上限，即始终满足 $0 \le hp \le maxhp$。

	**13.** 对于「被动技能」的上限，可以先计算出总数值，使用「技能」时再处理上限。

	**14.** 「武器」「G」乘的是 $x\%$，而不是 $x$。

- **主要信息**

	「种族」、「体力值」、「体力上限」、「主动技能等级」、「被动技能等级」、「防御加成」、「攻击加成」、「基础攻击指数」、「基础防御指数」、「武器类型」、「武器攻击力」、「技能加成」、西侧的队员、东侧的队员、接下来「行动」的人、队员总数、剩余队员人数。

（队员的「等级」其实没什么用，可以当个摆设，彰显这个队员可能会比较厉害？）

- WA 了好几遍也不要放弃，再多读几遍题目，或许错误就被你找出来了。

其实这道大模拟实现起来比[猪国杀](https://www.luogu.com.cn/problem/P2482)简单一点，只是有关数字的信息比较多，还大多都是小数，不怎么好处理，比较好的解决方法就是先把那些会用到的小数存数组里。（码量还是蛮大的，和猪国杀差不多）

基本上大样例过了就能 **AC**。~~这是我见过**最良心**的一个大样例，没有之一。~~


## Code

```cpp
#include <iostream>
using namespace std;
const double weak[6] = {0, 0.1, 0.12, 0.15, 0.17, 0.2}; //weak的主动技能
const double ave[6] = {0, 0.06, 0.07, 0.08, 0.09, 0.1}; //average的主动技能
const double strong[6] = {1, 2.1, 2.17, 2.24, 2.32, 2.4}; //strong的主动技能
const double W[6] = {0, 0.013, 0.016, 0.019, 0.022, 0.025}; //weak的被动技能
const double AS[6] = {0, 0.01, 0.02, 0.03, 0.04, 0.05}; //Average\Strong被动技能
const double pos[6] = {1.25, 1, 0.75, 0, 0.75, 1}; //方位加成
const char steam[2][6] = {"North","South"};
int t;
struct team{
	int num[8], left[8], right[8], lv[8], hp[8], maxhp[8], skill[8], P[8], total, res, id, DB[8], DBdamage[8];
	//种族编号,西侧队员,东侧队友,队员等级,体力,体力上限,主动等级,被动等级,队员数,剩余队员数,行动的人,average的主动技能剩余回合数及伤害
	double atk[8], def[8], weapon_atk[8], Sadd[8], WP, AP, SP;
	//基础攻击指数,基础防御指数,武器攻击力,技能加成,weak被动技能效果,average被动技能效果,strong被动技能效果
	char weapon[8], type[8][8]; //武器类型,种族
} s[2];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 3) + (x << 1) + (a ^ 48), a = getchar();
	return x;
}
void insert(int left[], int right[], int p, int &x){ //插入
	left[x] = p, right[x] = right[p];
	left[right[p]] = x, right[p] = x;
}
void build(team &x){
	x.left[0] = x.right[0] = x.SP = x.AP = 1;
	for(int i = 2; i <= x.res; ++ i) //手搓链表
		insert(x.left, x.right, (i == 4 || i == 6? i - 2: i == 2? 1: 0), i);
	for(int i = 1; i <= x.res; ++ i){ //读入队伍信息,比较臃肿
		scanf("%s", x.type[i]);
		x.lv[i] = read();
		x.maxhp[i] = x.hp[i] = read();
		scanf("atk=%lf", &x.atk[i]);
		scanf(" def=%lf", &x.def[i]);
		x.skill[i] = read();
		x.P[i] = read();
		x.weapon[i] = getchar();
		scanf(" weaponatk=%lf", &x.weapon_atk[i]);
		x.Sadd[i] = 1;
		if(x.type[i][0] == 'W') x.num[i] = 1, x.WP += W[x.P[i]];
		else if(x.type[i][0] == 'A') x.num[i] = 2, x.AP += AS[x.P[i]];
		else x.num[i] = 3, x.SP += AS[x.P[i]];;
	}
}
void check(team &x, int &target){ //检查是否倒下并料理后世
	if(x.hp[target] <= 0){
		x.hp[target] = 0;
		x.left[x.right[target]] = x.left[target];
		x.right[x.left[target]] = x.right[target];
		-- x.res;
		if(x.type[target][0] == 'W') x.WP -= W[x.P[target]];
		else if(x.type[target][0] == 'A') x.AP -= AS[x.P[target]];
		else x.SP -= AS[x.P[target]];
	}
}
void Damage(int &from, bool &turn, int &target, bool &other, double damage, int atkpos, int ddgpos){ //damage基础攻击强度
	double x = damage * s[turn].Sadd[from] * (s[turn].SP > 1.1? 1.1: s[turn].SP) * pos[(atkpos - ddgpos + 6) % 6]; //攻击强度
	if((s[turn].num[from] - s[other].num[target] + 3) % 3 == 1) x *= 1.1; //种族克制加成是有规律的
	else if((s[turn].num[from] - s[other].num[target] + 3) % 3 == 2) x *= 0.9;
	int reduce = x / (s[other].def[target] * (s[other].AP > 1.1? 1.1: s[other].AP));
	s[other].hp[target] -= reduce;
	check(s[other], target);
	printf("%s %d took %d damage from %s %d -> %d/%d\n", steam[other], target, reduce, steam[turn], s[turn].id, s[other].hp[target], s[other].maxhp[target]);
}
void Average(team &x, bool turn){
	for(int i = 1; i <= x.total; ++ i)
		if(x.hp[i] > 0 && x.DB[i] > 0){
			x.hp[i] -= x.DBdamage[i];
			x.DB[i] --;
			check(x, i);
			printf("%s %d took %d damage from skill -> %d/%d\n", steam[turn], i, x.DBdamage[i], x.hp[i], x.maxhp[i]);
		}
}
void Weak(team &x, bool &turn, int &p, int restore){ //weak技能
	if(0 < x.hp[p] && x.hp[p] < x.maxhp[p]){
		x.hp[p] += restore;
		if(x.hp[p] > x.maxhp[p]) x.hp[p] = x.maxhp[p];
		printf("%s %d recovered +%d hp -> %d/%d\n", steam[turn], p, restore, x.hp[p], x.maxhp[p]);
	}
}
void Weak_p(team &x, bool &turn){ //weak被动技能
	if(x.WP > 0)
		for(int i = 1; i <= x.total; ++ i)
			Weak(x, turn, i, x.maxhp[i] * (x.WP > 0.05? 0.05: x.WP));
}
int nex(team &x){ //change行动的人
	for(int i = x.id + 1; i <= x.total; ++ i)
		if(x.hp[i] > 0) return x.id = i;
	for(int i = 1; i < x.id; ++ i)
		if(x.hp[i] > 0) return x.id = i;
	return x.id;
}
void output(){ //输出两个队伍的成员状态
	printf("North:");
	for(int i : {5, 3, 1, 2, 4, 6})
		if(i <= s[0].total) printf(" %d/%d", s[0].hp[i], s[0].maxhp[i]);
	puts("");
	printf("South:");
	for(int i : {5, 3, 1, 2, 4, 6})
		if(i <= s[1].total) printf(" %d/%d", s[1].hp[i], s[1].maxhp[i]);
	puts(""), puts("");
}
int main(){
	s[1].res = s[1].total = read(), s[0].res = s[0].total = read();
	build(s[1]), build(s[0]);
	t = read();
	for(int i = 1; i <= t; ++ i){
		char a = getchar();
		while(a < 'a' || 'z' < a) a = getchar();
		bool turn = i & 1, other = !turn;
		int from = nex(s[turn]), target = read(); //行动的人,目标
		Weak_p(s[turn], turn);
		if(a == 'a'){ //普通攻击
			int atkpos = read(), ddgpos = read(); //攻击方位,闪躲方位
			Damage(from, turn, target, other, s[turn].atk[from] * s[turn].weapon_atk[from], atkpos, ddgpos);
			s[turn].Sadd[from] = 1;
		}
		else if(a == 'p'){ //特殊攻击
			int atkpos = read(), ddgpos = read();
			if(s[turn].weapon[from] == 'B') Damage(from, turn, target, other, s[turn].atk[from] * s[turn].weapon_atk[from] * 1.25, atkpos, ddgpos);
			else if(s[turn].weapon[from] == 'G'){
				int lft = s[other].left[target], rt = s[other].right[target], cnt = 1 + (lft > 0) + (rt > 0);
				Damage(from, turn, target, other, s[turn].atk[from] * s[turn].weapon_atk[from] * 1.35 / cnt, atkpos, ddgpos);
				if(lft) Damage(from, turn, lft, other, s[turn].atk[from] * s[turn].weapon_atk[from] * 1.35 / cnt, atkpos, ddgpos);
				if(rt) Damage(from, turn, rt, other, s[turn].atk[from] * s[turn].weapon_atk[from] * 1.35 / cnt, atkpos, ddgpos);
			}
			else{
				int lft = s[other].left[target], rt = s[other].right[target];
				Damage(from, turn, target, other, s[turn].atk[from] * s[turn].weapon_atk[from] * 1.15, atkpos, ddgpos);
				if(lft) Damage(from, turn, lft, other, s[turn].atk[from] * s[turn].weapon_atk[from] * 0.23, atkpos, ddgpos);
				if(rt) Damage(from, turn, rt, other, s[turn].atk[from] * s[turn].weapon_atk[from] * 0.23, atkpos, ddgpos);
			}
			s[turn].Sadd[from] = 1;
		}
		else{ //主动技能
			printf("%s %d applied %s skill to %s %d\n", steam[turn], from, s[turn].type[from], steam[s[turn].type[from][0] == 'A'? other: turn], target);
			if(s[turn].type[from][0] == 'W') Weak(s[turn], turn, target, s[turn].maxhp[target] * weak[s[turn].skill[from]]);
			else if(s[turn].type[from][0] == 'A') s[other].DB[target] = 3, s[other].DBdamage[target] = s[other].maxhp[target] * ave[s[turn].skill[from]];
			else s[turn].Sadd[target] = strong[s[turn].skill[from]];
		}
		Average(s[other], other);
		output();
	}
	if(s[1].res == 0) puts("Team North won.");
	else if(s[0].res == 0) puts("Team South won.");
	return 0;
}
```
$\texttt{2023 年 8 月 16 日 update:}$ 删了很多废话。

---

## 作者：ydzr00000 (赞：2)

## 题目大意
有两个队伍，每个队伍有角色，然后还有角色信息、攻击类型等信息，每个回合先确定行动的人、然后确定行动，最后判断每个人的血量。

## 题解
### 信息
考虑我们有哪些类别的信息？

- 武器：类型、攻击力。
- 角色：种族、等级、当前体力、体力上限、基础攻击指数、基础防御指数、主动技能等级、被动技能等级、是否死亡、技能加成、属于哪个队伍与他的编号、拥有的武器、受到的 debuff。
- 队伍：名字、包含的角色、初始角色总数、活着的角色数量、上一次行动的玩家、防御加成与攻击加成、还可以加上计算防御加成和攻击加成的函数。

其实，Average 种族的主动技能施加的减体力值（全文的 debuff 含义均为此）也可以记录，其包含结束时间与减的程度。

对于上述信息，我们可以开结构体进行存储。

```c++
struct Weapon{
	char Type;
	double CommonAttack;
};
struct AverageDebuff{
	int RemainTime;
	double multiply;
};
struct Player{
	string Race;
	int Type;
	int Level;
	int belong,pID;
	int HP,maxHP;
	double BasicAttack;
	double BasicDefense;
	int InitiativeSkillLevel;
	int PassiveSkillLevel;
	double SkillBoost;
	bool die;
	Weapon weapon;
	AverageDebuff debuff;
};
struct Team{
	string name;
	Player player[7];
	int live,all;
	double DefenseBoost;
	double AttackBoost;
	inline void RecalculateBoost()
	{
		double def=1.0,atk=1.0;
		for(int i=1;i<=all;i++)
		{
			Player P=player[i];
			if(P.die)
				continue;
			if(P.Race=="Average")
				def+=AveragePassiveBoostLevel[P.PassiveSkillLevel];
			if(P.Race=="Strong")
				atk+=StrongPassiveBoostLevel[P.PassiveSkillLevel];
		}
		def=min(def,1.1),atk=min(atk,1.1);
		DefenseBoost=def;
		AttackBoost=atk;
	}
	int lastPlayer;
	inline bool Live(int id)
	{
		return id<=all&&!player[id].die;
	}
}
```
### 常量
站位与编号、各种族主动技能与被动技能的百分比、种族克制加成与方位加成，还有控制精度的 $\epsilon$。

对于这些常量，我们用 `const` 直接定义。

```c++
const double eps=1e-9;
const double WeakInitiativeBoostLevel[6]={0.00,0.10,0.12,0.15,0.17,0.20};
const double AverageInitiativeBoostLevel[6]={0.00,0.06,0.07,0.08,0.09,0.10};
const double StrongInitiativeBoostLevel[6]={0.00,2.1,2.17,2.24,2.32,2.4};
const double WeakPassiveBoostLevel[6]={0.00,0.013,0.016,0.019,0.022,0.025};
const double AveragePassiveBoostLevel[6]={0.00,0.01,0.02,0.03,0.04,0.05};
const double StrongPassiveBoostLevel[6]={0.00,0.01,0.02,0.03,0.04,0.05};
const double RaceBoostForm[3][3]={
	{1.0,0.9,1.1},
	{1.1,1.0,0.9},
	{0.9,1.1,1.0}
};
const double OrientationBoostForm[6]={1.25,1.00,0.75,0.00,0.75,1.00};
const int TeamPosition[7]={0,5,3,1,2,4,6};
const int MemberPosition[7]={0,3,4,2,5,1,6};
```

### 其余函数
将我们所需要执行的不同操作用函数来编写，可以降低调试的难度。

首先，计算伤害（减体力值）在整个游戏中基本处于核心部分，伤害有三个部分：攻击强度、防御指数、最终造成的伤害。

对于最终造成的伤害，如果传参，除了两名玩家以外，还有方位差与伤害倍率，这个倍率在特殊攻击的武器 `G` 与武器 `M` 中有体现，注意死亡之后要清空与重新计算的东西。

```c++
inline double AttackStrength(double BasicAttack,double AttackBoost,double SkillBoost,double RaceBoost,double OrientationBoost)
{
	return BasicAttack*AttackBoost*SkillBoost*RaceBoost*OrientationBoost;
}
inline double DefenseStrength(double BasicDefense,double DefenseBoost)
{
	return BasicDefense*DefenseBoost;
}
inline void Deduct(Player &P,int more)
{
	P.HP-=more;
	if(P.HP<=0)
	{
		P.HP=0;
		P.die=true;
		team[P.belong].RecalculateBoost();
		team[P.belong].live--;
		P.debuff.RemainTime=0;
	}
}
inline void DeductHP(Player &P1,Player &P2,double r,int diff)
{
	double x=AttackStrength(P1.BasicAttack*P1.weapon.CommonAttack*r,team[P1.belong].AttackBoost,P1.SkillBoost,RaceBoostForm[P1.Type][P2.Type],OrientationBoostForm[diff]);
	double y=DefenseStrength(P2.BasicDefense,team[P2.belong].DefenseBoost);
	int damage=x/y+eps;
	Deduct(P2,damage);
	printf("%s %d took %d damage from %s %d -> %d/%d\n",team[P2.belong].name.c_str(),P2.pID,damage,team[P1.belong].name.c_str(),P1.pID,P2.HP,P2.maxHP);
}
```

与伤害对应的， `Weak` 的技能是回体力，所以我们还可以类似地编写治疗函数：

```c++
inline void Recover(Player &P,int more)
{
	P.HP=min(P.HP+more,P.maxHP);
}
```

其余的，我们按照攻击方式分类编写：

基础攻击就直接按照题面来就可以。

```c++
inline void ClearSkillBoost(Player &P)
{
	P.SkillBoost=1.00;
}
inline void BasicAttack(int TeamID,int PlayerID)
{
	int ID,atkpos,ddgpos;
	scanf(" target=%d atkpos=%d ddgpos=%d",&ID,&atkpos,&ddgpos);
	int diff=(atkpos-ddgpos+6)%6;
	Player &P1=team[TeamID].player[PlayerID];
	Player &P2=team[TeamID^1].player[ID];
	DeductHP(P1,P2,1.00,diff);
	ClearSkillBoost(P1);
}
```

接下来是特殊攻击，特殊攻击中我们可能需要找目标东西两侧的存活队员各一名，先前的 `TeamPosition` 数组就可以使用（这里采用 lambda 编写）。

```c++
inline void SpecialAttack(int TeamID,int PlayerID)
{
	int ID,atkpos,ddgpos;
	scanf(" target=%d atkpos=%d ddgpos=%d",&ID,&atkpos,&ddgpos);
	Player &P1=team[TeamID].player[PlayerID];
	int diff=(atkpos-ddgpos+6)%6;
	
	auto WeaponB=[&]()->void
	{
		Player &P2=team[TeamID^1].player[ID];
		DeductHP(P1,P2,1.25,diff);
	};
	auto WeaponG=[&]()->void
	{
		int now=MemberPosition[ID],p=0,q=0;
		for(int i=now-1;i>=1;i--)
			if(team[TeamID^1].Live(TeamPosition[i]))
			{
				p=TeamPosition[i];
				break;
			}
		for(int i=now+1;i<=6;i++)
			if(team[TeamID^1].Live(TeamPosition[i]))
			{
				q=TeamPosition[i];
				break;
			}
		int all=1+(bool)(p)+(bool)(q);
		double r=1.35/all;
		
		Player &TargetPlayer=team[TeamID^1].player[ID];
		DeductHP(P1,TargetPlayer,r,diff);
		if(p)
		{
			Player &WestPlayer=team[TeamID^1].player[p];
			DeductHP(P1,WestPlayer,r,diff);
		}
		if(q)
		{
			Player &EastPlayer=team[TeamID^1].player[q];
			DeductHP(P1,EastPlayer,r,diff);
		}
	};
	auto WeaponM=[&]()->void
	{
		int now=MemberPosition[ID],p=0,q=0;
		for(int i=now-1;i>=1;i--)
			if(team[TeamID^1].Live(TeamPosition[i]))
			{
				p=TeamPosition[i];
				break;
			}
		for(int i=now+1;i<=6;i++)
			if(team[TeamID^1].Live(TeamPosition[i]))
			{
				q=TeamPosition[i];
				break;
			}
		
		Player &TargetPlayer=team[TeamID^1].player[ID];
		DeductHP(P1,TargetPlayer,1.15,diff);
		if(p)
		{
			Player &WestPlayer=team[TeamID^1].player[p];
			DeductHP(P1,WestPlayer,0.23,diff);
		}
		if(q)
		{
			Player &EastPlayer=team[TeamID^1].player[q];
			DeductHP(P1,EastPlayer,0.23,diff);
		}
	};
	
	if(P1.weapon.Type=='B')
		WeaponB();
	else if(P1.weapon.Type=='G')
		WeaponG();
	else
		WeaponM();
	
	ClearSkillBoost(P1);
}
```

最后就是技能部分，每个种族都考虑一下就行。

```c++
inline void WeakInitiative(Player &P1,Player &P2)
{
	double boost=WeakInitiativeBoostLevel[P1.InitiativeSkillLevel];
	int more=P2.maxHP*boost;
	if(P2.HP==P2.maxHP)
		return;
	Recover(P2,more);
	printf("%s %d recovered +%d hp -> %d/%d\n",team[P2.belong].name.c_str(),P2.pID,more,P2.HP,P2.maxHP);
}
inline void AverageInitiative(Player &P1,Player &P2)
{
	P2.debuff.RemainTime=3;
	P2.debuff.multiply=AverageInitiativeBoostLevel[P1.InitiativeSkillLevel];
}
inline void StrongInitiative(Player &P1,Player &P2)
{
	P2.SkillBoost=StrongInitiativeBoostLevel[P1.InitiativeSkillLevel];
}
inline void useSkill(int TeamID,int PlayerID)
{
	Player &P=team[TeamID].player[PlayerID];
	int ID;
	scanf(" target=%d",&ID);
	if(P.Race=="Average")
	{
		printf("%s %d applied %s skill to %s %d\n",team[TeamID].name.c_str(),PlayerID,P.Race.c_str(),team[TeamID^1].name.c_str(),ID);
		AverageInitiative(P,team[TeamID^1].player[ID]);
	}
	else
	{
		printf("%s %d applied %s skill to %s %d\n",team[TeamID].name.c_str(),PlayerID,P.Race.c_str(),team[TeamID].name.c_str(),ID);
		if(P.Race=="Weak")
			WeakInitiative(P,team[TeamID].player[ID]);
		else
			StrongInitiative(P,team[TeamID].player[ID]);
	}
}
```

最后，我们还剩下 Weak 种族的被动技能、Average 种族带来的 debuff 结算，选择行动的角色、血量公示，找赢家：

```c++
inline void WeakPassive(int TeamID)
{
	double boost=0;
	int member=0;
	for(int i=1;i<=team[TeamID].all;i++)
	{
		Player P=team[TeamID].player[i];
		if(!P.die&&P.Race=="Weak"&&P.PassiveSkillLevel)
		{
			boost+=WeakPassiveBoostLevel[P.PassiveSkillLevel];
			member++;
		}
	}
	if(!member)
		return;
	boost=min(boost,0.05);
	for(int i=1;i<=team[TeamID].all;i++)
	{
		Player &P=team[TeamID].player[i];
		if(P.die)
			continue;
		if(P.HP==P.maxHP)
			continue;
		int more=P.maxHP*boost;
		Recover(P,more);
		printf("%s %d recovered +%d hp -> %d/%d\n",team[TeamID].name.c_str(),i,more,P.HP,P.maxHP);
	}
}
inline int ChoosePlayer(int TeamID)
{
	int PlayerID=0;
	for(int i=team[TeamID].lastPlayer+1;i<=team[TeamID].all;i++)
		if(!team[TeamID].player[i].die)
		{
			PlayerID=i;
			team[TeamID].lastPlayer=PlayerID;
			return PlayerID;
		}
	for(int i=1;i<=team[TeamID].lastPlayer;i++)
		if(!team[TeamID].player[i].die)
		{
			PlayerID=i;
			team[TeamID].lastPlayer=PlayerID;
			return PlayerID;
		}
	return -1;
}
inline void DebuffClearing(int TeamID)
{
	for(int i=1;i<=team[TeamID].all;i++)
	{
		Player &P=team[TeamID].player[i];
		if(P.debuff.RemainTime)
		{
			int more=P.maxHP*P.debuff.multiply;
			P.debuff.RemainTime--;
			Deduct(P,more);
			printf("%s %d took %d damage from skill -> %d/%d\n",team[TeamID].name.c_str(),i,more,P.HP,P.maxHP);
		}
	}
}
inline void ShowHP(int TeamID)
{
	printf("%s: ",team[TeamID].name.c_str());
	for(int i=1;i<=6;i++)
		if(TeamPosition[i]<=team[TeamID].all)
		{
			Player P=team[TeamID].player[TeamPosition[i]];
			printf("%d/%d ",P.HP,P.maxHP);
		}
	puts("");
}
inline void checkWinner()
{
	for(int i=0;i<2;i++)
		if(!team[i].live)
		{
			printf("Team %s won.\n",team[i^1].name.c_str());
			return;
		}
}
```

注意没有 Weak 种族的时候不要结算被动技能。

于是每一轮，我们就可以写成：

```c++
inline void Run(int TeamID)
{
	WeakPassive(TeamID);
	int ID=ChoosePlayer(TeamID);
	string typ;
	cin>>typ;
	if(typ=="Skill")
		useSkill(TeamID,ID);
	else if(typ=="Basicattack")
		BasicAttack(TeamID,ID);
	else
		SpecialAttack(TeamID,ID);
	DebuffClearing(TeamID^1);
	ShowHP(1);ShowHP(0);
	puts("");
}
```

读入部分与初始化部分略去，代码详情见[此](https://www.luogu.com.cn/paste/o37zcxzx)。

本篇代码中，将种族与数字进行映射，同时将队伍编号为 $0/1$，以降低编写难度。

---

## 作者：SuperCowHorse (赞：2)

>纪念我写出的第四道大模拟——那些脑海里最珍贵的
---
### 前言
[题目传送门](https://www.luogu.com.cn/problem/P9381)。

这道题比我做过的[麻将模拟器](https://www.luogu.com.cn/problem/P7147)和[德州消消乐](https://www.luogu.com.cn/problem/P8422)都要简单一点，后两题都需要超级无敌大 dp 去计算某个东西（前者是和牌距离，后者是组合奖分），但这题不用，只需要直接按题意模拟就可以了。

### 初始化
~~搞好初始化是一切大模拟的关键。~~ 先来看看一些变量的作用。

```cpp
struct Peoples{//代表一个人
	string name;int team,id,pos;//种族名称，队伍编号，编号，所处位置
	double atk,def,weaatk,skiatk;//基础攻击指数，基础防御指数，武器攻击力，技能加成
	int maxhp,hp,skilv,paslv,lev,weaty,type;//血量上限，当前血量，主动技能等级，被动技能等级，等级，武器类型，种族类型
	int roundAve;double delAve;//Average 的主动技能
	inline void Debug(){
		cout<<name<<"\n";
	}
};
struct Teams{//代表一个队
	int n,last;string name;//人数，上次行动的人，队伍名称
	Peoples e[10];int pos[10];//角色，每个位置上的角色
	double teamatk,teamdef,teamhp;//队伍攻击加成，队伍防御加成，队伍回血量（其中队伍回血量是 Weak 的被动）
}a[2];
double posatk[6]={1.25,1,0.75,0,0.75,1};//方位加成
double typatk[4][4]={{},{0,1,0.9,1.1},{0,1.1,1.0,0.9},{0,0.9,1.1,1}};//种族加成
double ski[4][6]={{},{0,0.1,0.12,0.15,0.17,0.2},{0,0.06,0.07,0.08,0.09,0.1},{0,2.1,2.17,2.24,2.32,2.4}};//主动技能
double pas[4][6]={{},{0,0.013,0.016,0.019,0.022,0.025},{0,0.01,0.02,0.03,0.04,0.05},{0,0.01,0.02,0.03,0.04,0.05}};//被动技能
```
### 读入
然后是读入。这里我脑子抽掉了，没有想到用 `scanf` 的内置函数直接去输入，而是写了一个又臭又长的 `cin`。

考虑到每一行 `=` 后面都代表着一个数据，这样我们就可以根据 `=` 出现的次数，来读入当前的数据。武器类型 `B`、`G`、`M` 直接特判即可。

~~但还是建议读入这边去看其他用 `scanf` 的题解。~~
```cpp
inline void Input(){
	cin>>a[0].n>>a[1].n;
	a[0].name="South";a[1].name="North";
	string s;getline(cin,s);
	for(int j=0;j<2;++j){
		a[j].teamatk=a[j].teamdef=1;a[j].teamhp=0;
		for(int i=1;i<=a[j].n;++i){
			getline(cin,s);
			if(s[0]=='W'){
				a[j].e[i].name="Weak";
				a[j].e[i].type=1;
			}
			else if(s[0]=='A'){
				a[j].e[i].name="Average";
				a[j].e[i].type=2;
			}
			else if(s[0]=='S'){
				a[j].e[i].name="Strong";
				a[j].e[i].type=3;
			}
			int now,cnt=0;double res=0;
			for(int k=0;k<s.size();++k){//枚举每一个等号
				if(s[k]=='B'||s[k]=='G'||s[k]=='M'){//特判武器
					a[j].e[i].weaty=s[k]=='B'?1:(s[k]=='G'?2:3);
				}
				if(s[k]=='='){
					++cnt;now=0;
					++k;while(s[k]>='0'&&s[k]<='9'){//用类似快读的思想读入每一个数
						now=now*10+s[k]-'0';
						++k;
					}
					if(s[k]=='e'){//浮点数直接用 double 存
						res=now;
						for(int p=1;p<=s[k+2]-'0';++p){
							res/=10.0;
						}
					}
					switch(cnt){//分类讨论是第几个等号
						case 1:a[j].e[i].lev=now;//等级
						case 2:a[j].e[i].maxhp=now;//血量上限
						case 3:a[j].e[i].atk=res;//基础攻击指数
						case 4:a[j].e[i].def=res;//基础防御指数
						case 5:a[j].e[i].skilv=now;//主动技能等级
						case 6:a[j].e[i].paslv=now;//被动技能等级
						case 7:a[j].e[i].weaatk=res;//武器攻击力
					}
				}
			}
			a[j].e[i].hp=a[j].e[i].maxhp;//当前血量
			a[j].e[i].team=j;a[j].e[i].id=i;
			a[j].e[i].skiatk=1;//技能加成初始为 1
		}
	}
	for(int j=0;j<2;++j){//计算每一个人在第几位，即按 531246 的顺序，这个人排在第几位
		int cnt=0;
		for(int i=((a[j].n&1)?a[j].n:a[j].n-1);i>=1;i-=2){//枚举 531
			a[j].e[i].pos=++cnt;
		}
		for(int i=2;i<=a[j].n;i+=2){//枚举 246
			a[j].e[i].pos=++cnt;
		}
		for(int i=1;i<=a[j].n;++i){
			a[j].pos[a[j].e[i].pos]=i;
		}
	}
}
```
### 战斗
和输入一样，我们在战斗时可以通过等号，来输入特定的数值。

一些函数在后文会详细介绍。
``` cpp
inline void R(int Round){
	int t=Round&1;//计算当前是哪一个队伍行动
	int p=a[t].last;
	for(int i=a[t].last+1;;++i){//枚举下一个出场的人
		if(i>a[t].n) i=1;
		if(a[t].e[i].hp>0){
			p=i;
			break;
		}
	}
	a[t].last=p;
	string s;getline(cin,s);
	Passive1();Passive2(t);//更新被动，Passive1 更新队伍攻击加成、队伍防御加成和回血量，Passive2 通过 Weak 的被动技能来回血
	if(s[1]=='k'){
		Skill(t,p,s[13]-'0');//技能
	}
	else{
		int cnt=0,now=0,tar,atk,ddg;
		for(int k=0;k<s.size();++k){//枚举等号
			if(s[k]=='='){
				++cnt;now=0;
				++k;while(s[k]>='0'&&s[k]<='9'){
					now=now*10+s[k]-'0';++k;
				}
				switch(cnt){
					case 1:tar=now;
					case 2:atk=now;
					case 3:ddg=now;
				}
			}
		}
		if(s[0]=='B'){
			BasicAttack(t,p,tar,posatk[((atk-ddg)%6+6)%6]);//普通攻击
		}
		else{
			SpeciAttack(t,p,tar,posatk[((atk-ddg)%6+6)%6]);//特殊攻击
		}
	}
	UpdateAve(t^1);//Average 的主动技能
	Print(1);Print(0);//输出当前血量
	cout<<"\n";
}
inline void Playing(){
	int Q;cin>>Q;
	string s;getline(cin,s);
	for(int Round=0;Round<Q;++Round){
		R(Round);//每一个回合
	}
	Win(0);Win(1);//判断胜负
}
```
### 内置函数
一个一个来吧。

- $\operatorname{Passive1}$
```cpp
inline void Passive1(){
	for(int j=0;j<2;++j){
		double cnt1=0,cnt2=0,cnt3=0;
		a[j].teamatk=a[j].teamdef=1;a[j].teamhp=0;//初始化
		for(int i=1;i<=a[j].n;++i){//判断种族来获得加成
			if(a[j].e[i].type==1&&a[j].e[i].hp>0) cnt1+=pas[1][a[j].e[i].paslv];
			if(a[j].e[i].type==2&&a[j].e[i].hp>0) cnt2+=pas[2][a[j].e[i].paslv];
			if(a[j].e[i].type==3&&a[j].e[i].hp>0) cnt3+=pas[3][a[j].e[i].paslv];
		}
		cnt1=min(cnt1,0.05L);cnt2=min(cnt2,0.1L);cnt3=min(cnt3,0.1L);//计算最终的加成
		a[j].teamatk+=cnt3;a[j].teamdef+=cnt2;a[j].teamhp+=cnt1;
	}
}
```
- $\operatorname{Passive2}$ 和 $\operatorname{UpdateAve}$
```cpp
inline int UpdateHp(int &hp,int maxhp,double delhp){//delhp 是血量变化的比率，为正就是回血，为负就是扣血。这里还需要返回血量的变化量，方便进行输出。（加上 1e-9 的原因是：精度会爆炸）
	if(delhp>0) hp=min(hp+int(floor(delhp*1.0*maxhp+1e-9)),maxhp);
	if(delhp<0) hp=max(hp-int(floor(-delhp*1.0*maxhp+1e-9)),0);
	if(delhp>0) return int(floor(delhp*1.0*maxhp+1e-9));
	if(delhp<0) return int(floor(-delhp*1.0*maxhp+1e-9));
	return -1;
}
inline void Passive2(int T){
	double cnt=0;bool g=0;
	for(int i=1;i<=a[T].n;++i){
		if(a[T].e[i].maxhp==a[T].e[i].hp||a[T].e[i].hp==0) continue;
		int hp=a[T].e[i].hp;
		int del=UpdateHp(a[T].e[i].hp,a[T].e[i].maxhp,a[T].teamhp);//回血
		if(hp!=a[T].e[i].hp) cout<<a[T].name<<' '<<a[T].e[i].id<<" recovered +"<<del<<" hp -> "<<a[T].e[i].hp<<"/"<<a[T].e[i].maxhp<<"\n";//回复量为 0 不用输出！！！
	}
}
inline void UpdateAve(int T){
	for(int i=1;i<=a[T].n;++i){
		if(a[T].e[i].roundAve&&a[T].e[i].hp>0){//如果有 Average 的技能附着
			--a[T].e[i].roundAve;//剩余回合数减一
			int hp=a[T].e[i].hp;
			int del=UpdateHp(a[T].e[i].hp,a[T].e[i].maxhp,-a[T].e[i].delAve);//扣血
			cout<<a[T].name<<' '<<a[T].e[i].id<<" took "<<del<<" damage from skill -> "<<a[T].e[i].hp<<"/"<<a[T].e[i].maxhp<<"\n";
		}
	}
}
```
- $\operatorname{Skill}$、$\operatorname{BasicAttack}$ 和 $\operatorname{SpeciAttack}$
```cpp
inline int DelHp(double atk,double def){//计算受到的伤害
	return int(floor(atk*1.0/def+1e-9));
}
inline double ClacAtk(double bas,double ski,double tea,double typ,double pos){//计算攻击强度
	return bas*ski*tea*typ*pos;
}
inline double ClacDef(double bas,double tea){//计算防御指数
	return bas*tea;
}
inline void UpdateHP(int &hp,int x){//更新血量
	hp-=min(hp,x);
}
inline void BasicAttack(int T,int p,int tar,double PosAtk){
	int hp=a[T^1].e[tar].hp;
	int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));//造成普通攻击伤害
	UpdateHP(a[T^1].e[tar].hp,del);
	cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
	a[T].e[p].skiatk=1;//技能加成变为 1
}
inline void SpeciAttack(int T,int p,int tar,double PosAtk){
	int hp=a[T^1].e[tar].hp;
	if(a[T].e[p].weaty==1){
		int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*1.25,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));//基础攻击强度乘以 1.25
		UpdateHP(a[T^1].e[tar].hp,del);
		cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
	}
	if(a[T].e[p].weaty==2){
		double x=0;int y=a[T^1].e[tar].pos,i;
		x+=a[T^1].e[tar].hp!=0;
		for(i=y-1;i>=1;--i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];//枚举西边的人
		x+=a[T^1].e[tar].hp!=0;
		for(i=y+1;i<=6;++i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];//枚举东边的人
		x+=a[T^1].e[tar].hp!=0;
		x=135.0/x;//计算 x
		tar=a[T^1].pos[y];//先对目标造成伤害
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*(x/100.0),a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();//注意：一定要更新现在的被动技能！人死不能复生！！
		}
		for(i=y-1;i>=1;--i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){//再对西边的人造成伤害
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*(x/100.0),a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
		for(i=y+1;i<=6;++i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){//最后对东边的人造成伤害
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*(x/100.0),a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
	}
	if(a[T].e[p].weaty==3){//基本上和 2 一致，不再赘述
		int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*1.15,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
		UpdateHP(a[T^1].e[tar].hp,del);
		cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
		Passive1();
		int y=a[T^1].e[tar].pos,i;
		for(i=y-1;i>=1;--i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*0.23,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
		for(i=y+1;i<=6;++i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*0.23,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
	}
	a[T].e[p].skiatk=1;//更新技能加成
}
inline void Skill(int T,int p,int tar){
	if(a[T].e[p].type==1){//Weak 的回血
		cout<<a[T].name<<" "<<a[T].e[p].id<<" applied "<<a[T].e[p].name<<" skill to "<<a[T].name<<" "<<tar<<"\n";
		int hp=a[T].e[tar].hp;
		int del=UpdateHp(a[T].e[tar].hp,a[T].e[tar].maxhp,ski[1][a[T].e[p].skilv]);
		if(hp!=a[T].e[tar].hp) cout<<a[T].name<<' '<<a[T].e[tar].id<<" recovered +"<<del<<" hp -> "<<a[T].e[tar].hp<<"/"<<a[T].e[tar].maxhp<<"\n";//回复量为 0 不用输出！！！
	}
	if(a[T].e[p].type==2){//Average 的持续伤害
		cout<<a[T].name<<" "<<a[T].e[p].id<<" applied "<<a[T].e[p].name<<" skill to "<<a[T^1].name<<" "<<tar<<"\n";
		a[T^1].e[tar].roundAve=3;a[T^1].e[tar].delAve=ski[2][a[T].e[p].skilv];
	}
	if(a[T].e[p].type==3){//Strong 的技能加成
		cout<<a[T].name<<" "<<a[T].e[p].id<<" applied "<<a[T].e[p].name<<" skill to "<<a[T].name<<" "<<tar<<"\n";
		a[T].e[tar].skiatk=ski[3][a[T].e[p].skilv];
	}
}
```
- $\operatorname{Print}$
```cpp
inline void Print(int T){
	cout<<a[T].name<<":";
	for(int i=1;i<=a[T].n;++i){//直接输出
		cout<<" "<<a[T].e[a[T].pos[i]].hp<<"/"<<a[T].e[a[T].pos[i]].maxhp;
	}
	cout<<"\n";
}
```
- $\operatorname{Win}$
```cpp
inline void Win(int T){
	for(int i=1;i<=a[T].n;++i){
		if(a[T].e[i].hp!=0){
			return;
		}
	}
	cout<<"Team "<<a[T^1].name<<" won.";//如果当前队伍全员阵亡，一定是另外一支队伍获胜
}
```
- $\operatorname{main}$
```cpp
signed main(){
	Input();//输入
	Playing();//战斗
	return 0;
}
```
完整代码（高清无码）：
```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
struct Peoples{
	string name;int team,id,pos;
	double atk,def,weaatk,skiatk;
	int maxhp,hp,skilv,paslv,lev,weaty,type;
	int roundAve;double delAve;
	inline void Debug(){
		cout<<name<<"\n";
	}
};
struct Teams{
	int n,last;string name;
	Peoples e[10];int pos[10];
	double teamatk,teamdef,teamhp;
}a[2];
double posatk[6]={1.25,1,0.75,0,0.75,1};
double typatk[4][4]={{},{0,1,0.9,1.1},{0,1.1,1.0,0.9},{0,0.9,1.1,1}};
double ski[4][6]={{},{0,0.1,0.12,0.15,0.17,0.2},{0,0.06,0.07,0.08,0.09,0.1},{0,2.1,2.17,2.24,2.32,2.4}};
double pas[4][6]={{},{0,0.013,0.016,0.019,0.022,0.025},{0,0.01,0.02,0.03,0.04,0.05},{0,0.01,0.02,0.03,0.04,0.05}};
inline void Input(){
	cin>>a[0].n>>a[1].n;
	a[0].name="South";a[1].name="North";
	string s;getline(cin,s);
	for(int j=0;j<2;++j){
		a[j].teamatk=a[j].teamdef=a[j].teamhp=1;
		for(int i=1;i<=a[j].n;++i){
			getline(cin,s);
			if(s[0]=='W'){
				a[j].e[i].name="Weak";
				a[j].e[i].type=1;
			}
			else if(s[0]=='A'){
				a[j].e[i].name="Average";
				a[j].e[i].type=2;
			}
			else if(s[0]=='S'){
				a[j].e[i].name="Strong";
				a[j].e[i].type=3;
			}
			int now,cnt=0;double res=0;
			for(int k=0;k<s.size();++k){
				if(s[k]=='B'||s[k]=='G'||s[k]=='M'){
					a[j].e[i].weaty=s[k]=='B'?1:(s[k]=='G'?2:3);
				}
				if(s[k]=='='){
					++cnt;now=0;
					++k;while(s[k]>='0'&&s[k]<='9'){
						now=now*10+s[k]-'0';
						++k;
					}
					if(s[k]=='e'){
						res=now;
						for(int p=1;p<=s[k+2]-'0';++p){
							res/=10.0;
						}
					}
					switch(cnt){
						case 1:a[j].e[i].lev=now;
						case 2:a[j].e[i].maxhp=now;
						case 3:a[j].e[i].atk=res;
						case 4:a[j].e[i].def=res;
						case 5:a[j].e[i].skilv=now;
						case 6:a[j].e[i].paslv=now;
						case 7:a[j].e[i].weaatk=res;
					}
				}
			}
			a[j].e[i].hp=a[j].e[i].maxhp;
			a[j].e[i].team=j;a[j].e[i].id=i;
			a[j].e[i].skiatk=1;
		}
	}
	for(int j=0;j<2;++j){
		int cnt=0;
		for(int i=((a[j].n&1)?a[j].n:a[j].n-1);i>=1;i-=2){
			a[j].e[i].pos=++cnt;
		}
		for(int i=2;i<=a[j].n;i+=2){
			a[j].e[i].pos=++cnt;
		}
		for(int i=1;i<=a[j].n;++i){
			a[j].pos[a[j].e[i].pos]=i;
		}
	}
}
inline void Passive1(){
	for(int j=0;j<2;++j){
		double cnt1=0,cnt2=0,cnt3=0;
		a[j].teamatk=a[j].teamdef=1;a[j].teamhp=0;
		for(int i=1;i<=a[j].n;++i){
			if(a[j].e[i].type==1&&a[j].e[i].hp>0) cnt1+=pas[1][a[j].e[i].paslv];
			if(a[j].e[i].type==2&&a[j].e[i].hp>0) cnt2+=pas[2][a[j].e[i].paslv];
			if(a[j].e[i].type==3&&a[j].e[i].hp>0) cnt3+=pas[3][a[j].e[i].paslv];
		}
		cnt1=min(cnt1,0.05L);cnt2=min(cnt2,0.1L);cnt3=min(cnt3,0.1L);
		a[j].teamatk+=cnt3;a[j].teamdef+=cnt2;a[j].teamhp+=cnt1;
	}
}
inline int UpdateHp(int &hp,int maxhp,double delhp){
	if(delhp>0) hp=min(hp+int(floor(delhp*1.0*maxhp+1e-9)),maxhp);
	if(delhp<0) hp=max(hp-int(floor(-delhp*1.0*maxhp+1e-9)),0);
	if(delhp>0) return int(floor(delhp*1.0*maxhp+1e-9));
	if(delhp<0) return int(floor(-delhp*1.0*maxhp+1e-9));
	return -1;
}
inline void Passive2(int T){
	double cnt=0;bool g=0;
	for(int i=1;i<=a[T].n;++i){
		if(a[T].e[i].maxhp==a[T].e[i].hp||a[T].e[i].hp==0) continue;
		int hp=a[T].e[i].hp;
		int del=UpdateHp(a[T].e[i].hp,a[T].e[i].maxhp,a[T].teamhp);
		if(hp!=a[T].e[i].hp) cout<<a[T].name<<' '<<a[T].e[i].id<<" recovered +"<<del<<" hp -> "<<a[T].e[i].hp<<"/"<<a[T].e[i].maxhp<<"\n";
	}
}
inline void UpdateAve(int T){
	for(int i=1;i<=a[T].n;++i){
		if(a[T].e[i].roundAve&&a[T].e[i].hp>0){
			--a[T].e[i].roundAve;
			int hp=a[T].e[i].hp;
			int del=UpdateHp(a[T].e[i].hp,a[T].e[i].maxhp,-a[T].e[i].delAve);
			cout<<a[T].name<<' '<<a[T].e[i].id<<" took "<<del<<" damage from skill -> "<<a[T].e[i].hp<<"/"<<a[T].e[i].maxhp<<"\n";
		}
	}
}
inline int DelHp(double atk,double def){
	return int(floor(atk*1.0/def+1e-9));
}
inline double ClacAtk(double bas,double ski,double tea,double typ,double pos){
	return bas*ski*tea*typ*pos;
}
inline double ClacDef(double bas,double tea){
	return bas*tea;
}
inline void UpdateHP(int &hp,int x){
	hp-=min(hp,x);
}
inline void BasicAttack(int T,int p,int tar,double PosAtk){
	int hp=a[T^1].e[tar].hp;
	int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
	UpdateHP(a[T^1].e[tar].hp,del);
	cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
	a[T].e[p].skiatk=1;
}
inline void SpeciAttack(int T,int p,int tar,double PosAtk){
	int hp=a[T^1].e[tar].hp;
	if(a[T].e[p].weaty==1){
		int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*1.25,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
		UpdateHP(a[T^1].e[tar].hp,del);
		cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
	}
	if(a[T].e[p].weaty==2){
		double x=0;int y=a[T^1].e[tar].pos,i;
		x+=a[T^1].e[tar].hp!=0;
		for(i=y-1;i>=1;--i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		x+=a[T^1].e[tar].hp!=0;
		for(i=y+1;i<=6;++i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		x+=a[T^1].e[tar].hp!=0;
		x=135.0/x;
		tar=a[T^1].pos[y];
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*(x/100.0),a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
		for(i=y-1;i>=1;--i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*(x/100.0),a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
		for(i=y+1;i<=6;++i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*(x/100.0),a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
	}
	if(a[T].e[p].weaty==3){
		int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*1.15,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
		UpdateHP(a[T^1].e[tar].hp,del);
		cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
		Passive1();
		int y=a[T^1].e[tar].pos,i;
		for(i=y-1;i>=1;--i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*0.23,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
		for(i=y+1;i<=6;++i){if(a[T^1].e[a[T^1].pos[i]].hp!=0){break;}}tar=a[T^1].pos[i];
		if(a[T^1].e[tar].hp!=0){
			int del=DelHp(ClacAtk(a[T].e[p].atk*a[T].e[p].weaatk*0.23,a[T].e[p].skiatk,a[T].teamatk,typatk[a[T].e[p].type][a[T^1].e[tar].type],PosAtk),ClacDef(a[T^1].e[tar].def,a[T^1].teamdef));
			UpdateHP(a[T^1].e[tar].hp,del);
			cout<<a[T^1].name<<" "<<a[T^1].e[tar].id<<" took "<<del<<" damage from "<<a[T].name<<" "<<a[T].e[p].id<<" -> "<<a[T^1].e[tar].hp<<"/"<<a[T^1].e[tar].maxhp<<"\n";
			Passive1();
		}
	}
	a[T].e[p].skiatk=1;
}
inline void Skill(int T,int p,int tar){
	if(a[T].e[p].type==1){
		cout<<a[T].name<<" "<<a[T].e[p].id<<" applied "<<a[T].e[p].name<<" skill to "<<a[T].name<<" "<<tar<<"\n";
		int hp=a[T].e[tar].hp;
		int del=UpdateHp(a[T].e[tar].hp,a[T].e[tar].maxhp,ski[1][a[T].e[p].skilv]);
		if(hp!=a[T].e[tar].hp) cout<<a[T].name<<' '<<a[T].e[tar].id<<" recovered +"<<del<<" hp -> "<<a[T].e[tar].hp<<"/"<<a[T].e[tar].maxhp<<"\n";
	}
	if(a[T].e[p].type==2){
		cout<<a[T].name<<" "<<a[T].e[p].id<<" applied "<<a[T].e[p].name<<" skill to "<<a[T^1].name<<" "<<tar<<"\n";
		a[T^1].e[tar].roundAve=3;a[T^1].e[tar].delAve=ski[2][a[T].e[p].skilv];
	}
	if(a[T].e[p].type==3){
		cout<<a[T].name<<" "<<a[T].e[p].id<<" applied "<<a[T].e[p].name<<" skill to "<<a[T].name<<" "<<tar<<"\n";
		a[T].e[tar].skiatk=ski[3][a[T].e[p].skilv];
	}
}
inline void Print(int T){
	cout<<a[T].name<<":";
	for(int i=1;i<=a[T].n;++i){
		cout<<" "<<a[T].e[a[T].pos[i]].hp<<"/"<<a[T].e[a[T].pos[i]].maxhp;
	}
	cout<<"\n";
}
inline void Win(int T){
	for(int i=1;i<=a[T].n;++i){
		if(a[T].e[i].hp!=0){
			return;
		}
	}
	cout<<"Team "<<a[T^1].name<<" won.";
}
inline void R(int Round){
	int t=Round&1;int p=a[t].last,tot=0;
	for(int i=a[t].last+1;;++i){
		if(i>a[t].n) i=1;
		++tot;
		if(a[t].e[i].hp>0){
			p=i;
			break;
		}
		if(tot==20) break;
	}
	if(tot==20){
		return;
	}
	a[t].last=p;
	string s;getline(cin,s);
	Passive1();Passive2(t);
	if(s[1]=='k'){
		Skill(t,p,s[13]-'0');
	}
	else{
		int cnt=0,now=0,tar,atk,ddg;
		for(int k=0;k<s.size();++k){
			if(s[k]=='='){
				++cnt;now=0;
				++k;while(s[k]>='0'&&s[k]<='9'){
					now=now*10+s[k]-'0';++k;
				}
				switch(cnt){
					case 1:tar=now;
					case 2:atk=now;
					case 3:ddg=now;
				}
			}
		}
		if(s[0]=='B'){
			BasicAttack(t,p,tar,posatk[((atk-ddg)%6+6)%6]);
		}
		else{
			SpeciAttack(t,p,tar,posatk[((atk-ddg)%6+6)%6]);
		}
	}
	UpdateAve(t^1);
	Print(1);Print(0);
	cout<<"\n";
}
inline void Playing(){
	int Q;cin>>Q;
	string s;getline(cin,s);
	for(int Round=0;Round<Q;++Round){
		R(Round);
	}
	Win(0);Win(1);
}
signed main(){
	Input();
	Playing();
	return 0;
}

```

---

## 作者：eoinlee (赞：2)

[给自己的博客打个广告。](https://eoin.blog/p/sol-luogu9381/)

这是笔者自己写的第一篇纯大模拟，因此本题的代码成为了目前笔者写过最长的代码。

## How to Code

~~依题意模拟即可。~~

本题除了模拟代码外几乎没有任何思维含量，纯纯的码力题，只要审题足够仔细并且有足够的耐心，A 掉这题是并不困难的。如果写大模拟的经验不是很足的话，看到题目甚至会无从下手（比如我）。这时候就最好从头到尾把题目读一遍，或者多读几遍，然后尽量顺着程序的大致运行过程开始编码。下面就跟着程序运行的逻辑顺序来一步一步实现代码。首先，规定一下本文中某些变量类型的替代称谓（C++11 语法）：

``` cpp
using f64 = double;
using str = std::string;
using MAP_SI = std::unordered_map<str, int>;
using MAP_II = std::unordered_map<int, int>;
```

### 玩家信息输入

首先，几乎可以完全确定的是，题目给定的数据全部都是有用的。所以输入的所有东西都要存储起来。并且，对于本题中这样有关 “队伍” 与 “玩家” 这样阵营分明的设定，我们可以几乎肯定地使用类（结构体）将同一实体有关的数值封装起来。这样就获得了我们的 `PLAYER` 类，用于存储一个玩家的全部有关信息。由于题目有关玩家信息的输入是以玩家为单位的，所以我们在该类中定义一个成员函数 `input()` 用于处理单个玩家信息的输入。当然，我们也需要将题目中涉及到的其他没有被输入的玩家属性存储到这个类中。

``` cpp
int member_cnt[2];

struct PLAYER {
    int team_fr; // 归属队伍
    int team_id; // 归属队伍内编号

    int type; // 类型：0 = weak, 1 = average, 2 = strong
    int lvl; // 等级：1 ~ 100
    f64 atk; // 基础攻击力
    f64 def; // 基础防御力
    int max_hp; // 体力上限
    int act_skl; // 主动技能等级：0 ~ 5
    int psv_skl; // 被动技能等级：0 ~ 5

    int weapon_type; // 武器类型：0 = B, 1 = G, 2 = M
    f64 weapon_atk; // 武器攻击力

    int hp; // 当前体力
    bool status; // 状态：0 = dead, 1 = alive
    f64 skl_boost; // 技能加成

    void input() {
        char player_type[10], weapon_type_t[4];
        scanf("%s Lv=%d maxhp=%d atk=%lf def=%lf skillLv=%d passivesklLv=%d %s weaponatk=%lf\n",
            player_type, &lvl, &max_hp, &atk, &def, &act_skl, &psv_skl, weapon_type_t, &weapon_atk);

        hp = max_hp; // 初始生命值为上限
        status = true; // 初始角色未倒下
        skl_boost = 1; // 初始技能加成为 1
        type = PLAYER_TYPE[str(player_type)]; // 根据输入获取角色类型对应数字
        weapon_type = WEAPON_TYPE[str(weapon_type_t)]; // 根据输入获取武器类型对应数字
    }
} team[2][7];

// ...

int main() {
    scanf("%d %d\n", &member_cnt[0], &member_cnt[1]);

    // 输入南队队员
    for (int i = 1; i <= member_cnt[0]; ++i) {
        team[0][i].input();
        team[0][i].team_fr = 0;
        team[0][i].team_id = i;
    }

    // 输入北队队员
    for (int i = 1; i <= member_cnt[1]; ++i) {
        team[1][i].input();
        team[1][i].team_fr = 1;
        team[1][i].team_id = i;
    }
}
```

为了方便，我们将输入的字符串属性转换成数字，存储在一个常量哈希表中（详见文末代码部分）。

### 获取当前回合的攻击方队员编号

通过阅读题面，我们可以知道，每一轮的攻击方（或技能施放方，以下我们将一回合内主动进行操作的一队统称为攻击方队伍）队伍是根据回合数确定的，攻击方队伍中的攻击者是根据队员编号进行选择的。

为了追踪两队的攻击队员，我们定义数组 `attacker[2]`，分别存储两队当前的攻击队员编号。接着，为了根据题目含义确定每一回合的攻击队员，我们定义 `get_attacker()` 函数：

``` cpp
int attacker[2];

/// @brief 计算每一回合攻击方队伍的攻击者
/// @param t 攻击方队伍的编号
void get_attacker(int t) {
    do {
        ++attacker[t];
        if (attacker[t] > member_cnt[t]) attacker[t] = 1;
    } while (!team[t][attacker[t]].status); // 如果找到未倒下的角色就跳出循环
    // 由于题目保证所有操作合法，所以不用担心死循环
}
```

为了确定每一个回合是哪一队进行攻击，我们在每次循环开头执行以下代码。

``` cpp
int round_cnt;

int main() {
    // ...

    scanf("%d\n", &round_cnt);

    for (int RND = 1; RND <= round_cnt; ++RND) {
        int t_a = (RND % 2) ^ 1; // 计算攻击方队伍
        int t_b = (RND % 2); // 计算防御方队伍

        // 获取攻击方队伍的当前攻击者
        get_attacker(t_a);
        int active = attacker[t_a];
    }
}
```

### 计算伤害

伤害计算是施放攻击对敌人造成影响的重要要素。因此这一部分需要作为铺垫并率先考虑。根据题目中描述：

> 「伤害」，即「体力值」减少的量，由「攻击强度」和受到「伤害」的人的「防御指数」决定。

攻击强度是由攻击队员的各项数值确定的，最终扣血的数值通过受攻击队员的相关防御指数确定。可见，计算完的攻击强度是沟通施放伤害与承受伤害的桥梁。因此我们将计算完的攻击强度作为一个整体，对于单个队员实施扣血操作。为此，我们在 `PLAYER` 类中定义 `deal_damage()` 函数，用于根据当前角色受到攻击的强度来确定扣血的数值。同时，由于攻击强度的计算以及扣血数值的计算都需要用到以队伍为单位的攻击加成和防御加成，所以我们也需要定义这两个浮点型变量 `atk_boost[2]` 和 `def_boost[2]`。由于这两个数值最终是乘到计算中的，所以初始值需要赋值为 1。

在扣血的时候，需要额外注意输出答案中的伤害大小是**原始数值**，但角色实际扣血是不能扣成负数的。其他扣血的地方也是同理。

``` cpp
f64 atk_boost[2] = {1, 1};
f64 def_boost[2] = {1, 1};

struct PLAYER {
    // ...

    void deal_damage(int, int, f64);
}

/// @brief 根据攻击强度对当前角色进行扣血
/// @param t_a 攻击方队伍的编号
/// @param act 攻击者在攻击方队伍内的编号
/// @param eff 攻击强度
void PLAYER::deal_damage(int t_a, int act, f64 eff) {
    if (!status) return; // 保险措施，如果已经倒下就不用考虑了

    int dmg = eff / (def * def_boost[team_fr]); // 计算攻击产生扣血的有效值
    hp -= dmg; // 扣血

    // 如果扣血后角色生命值不高于 0，则该角色倒下
    if (hp <= 0) {
        hp = 0;
        status = false; // 设定角色状态为倒下
    }

    printf("%s %d took %d damage from %s %d -> %d/%d\n",
        (team_fr ? "North" : "South"), team_id, dmg, (t_a ? "North" : "South"), act, hp, max_hp);
}
```

### 攻击

由题面我们可以知道，攻击分四种：普通攻击和三种特殊攻击。阅读题面不难发现，这四种攻击中，只跟攻击队员相关的属性加成，以及跟受攻击队员的躲闪位置有关的方位加成，对于任何一种攻击都是相同的，所以我们先预处理出这一部分属性的加成。普通攻击和 B 特殊攻击比较简单，直接调用受攻击者的 `deal_damage()` 函数，并传入计算好的攻击强度值即可。G 攻击和 M 攻击属于 AoE 攻击，与受攻击队员的站位有关，因此我们先根据题目要求定义两个数组（我不知道为什么我要用一个哈希表）`PLACE[]` 和 `INIT_INDEX[]`，分别存储队员的站位顺序和每一个队员在队伍中的位置编号，这两个数组的信息是互为键值的。由此我们就可以获取 AoE 攻击中受攻击的队员了。接下来依题意模拟即可。

需要注意的是，在 AoE 伤害中，虽然攻击强度中的方位加成是按照主要被攻击者的躲闪方位来计算的，但种族加成是按照受到攻击的实体本身的种族来计算的，所以这一部分需要单独考虑，这也是我把种族加成从预处理中孤立出来的一个主要因素。

``` cpp
const int PLACE[6] = {5, 3, 1, 2, 4, 6};
MAP_II INIT_INDEX = {{1, 2}, {2, 3}, {3, 1}, {4, 4}, {5, 0}, {6, 5}};

/// @brief 实施普通攻击和特殊攻击
/// @param atk_p 攻击位置
/// @param ddg_p 躲闪位置
/// @param act 攻击者在攻击方队伍内的编号
/// @param trg 防御者在防御方队伍内的编号
/// @param t_a 攻击方队伍编号
/// @param t_b 防御方队伍编号
/// @param type 攻击类型，-1 为普通攻击，0~2 为对应的特殊攻击
void perform_attack(int atk_p, int ddg_p, int act, int trg, int t_a, int t_b, int type = -1) {
    // 由于 G 和 M 类型的种族加成对不同目标有不同的取值，所以预处理时不包含种族加成
    f64 eff = team[t_a][act].atk *
        team[t_a][act].weapon_atk *
        team[t_a][act].skl_boost *
        atk_boost[t_a] *
        LOC_BOOST[(atk_p - ddg_p + 6) % 6];

    // 普通攻击
    if (type == -1)
        return team[t_b][trg].deal_damage(t_a, act, eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);

    // B 型特殊攻击
    if (type == 0)
        return team[t_b][trg].deal_damage(t_a, act, 1.25 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);

    // 预处理 G 和 M 类型特殊 AoE 攻击的范围
    int trg_l = -1, trg_r = -1;

    // 西边第一个未倒下的角色
    for (int i = INIT_INDEX[trg] - 1; i >= 0; --i)
        if (team[t_b][PLACE[i]].status) {
            trg_l = PLACE[i];
            break;
        }

    // 东边第一个未倒下的角色
    for (int i = INIT_INDEX[trg] + 1; i < 6; ++i)
        if (team[t_b][PLACE[i]].status) {
            trg_r = PLACE[i];
            break;
        }

    // G 型特殊攻击
    if (type == 1) {
        int cand_cnt = (trg_l != -1) + (trg_r != -1) + 1;
        f64 mul = 1.35 / cand_cnt;

        team[t_b][trg].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);
        if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]);
        if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]);
    }

    // M 型特殊攻击
    else if (type == 2) {
        team[t_b][trg].deal_damage(t_a, act, 1.15 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);
        if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]);
        if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]);
    }
}

int main() {
    // ...

    for (int RND = 1; RND <= round_cnt; ++RND) {
        // ...

        char action_type[20];
        int trg;

        scanf("%s target=%d ", action_type, &trg);

        // 施放普通攻击
        if (str(action_type) == "Basicattack") {
            int atk_p, ddg_p;
            scanf("atkpos=%d ddgpos=%d \n", &atk_p, &ddg_p);
            perform_attack(atk_p, ddg_p, active, trg, t_a, t_b);
            team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成
        }

        // 施放特殊攻击
        else if (str(action_type) == "Specialattack") {
            int atk_p, ddg_p;
            scanf("atkpos=%d ddgpos=%d \n", &atk_p, &ddg_p);
            perform_attack(atk_p, ddg_p, active, trg, t_a, t_b, team[t_a][active].weapon_type);
            team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成
        }

        putchar('\n');
    }
}
```

### 释放主动技能

由于技能部分涉及到了很多常数，所以我们不如先把所有数值存起来。这个时候就体现出将字符串属性存储为整数的优越之处了。注意我的存法中，还包含了技能等级为 0 时的加成，虽然可能用不到，但还是存一下比较保险。

``` cpp
const f64 ACT_SKL_MUL[3][6] = {
    {0.00, 0.10, 0.12, 0.15, 0.17, 0.20},
    {0.00, 0.06, 0.07, 0.08, 0.09, 0.10},
    {1.00, 2.10, 2.17, 2.24, 2.32, 2.40}
};

const f64 PSV_SKL_MUL[3][6] = {
    {0.00, 0.013, 0.016, 0.019, 0.022, 0.025},
    {0.00, 0.01, 0.02, 0.03, 0.04, 0.05},
    {0.00, 0.01, 0.02, 0.03, 0.04, 0.05}
};
```

有关主动技能，有几点值得注意。

第一是 Weak 类型的主动技能，技能释放的对象是本队成员，所以在传入参数的时候，目标队伍需要设定为本队。在回复生命的时候，需要额外注意输出答案中的回复量大小是**原始数值**，但角色实际回复生命是不能超过上限的。其他回复生命的地方也是同理。

第二是 Average 类型的主动技能，会给对方施加 DoT 持续伤害并在**技能释放者所在队伍的主动回合的回合末**进行结算。由于 DoT 伤害一旦施加，就只与被施加的敌方队员有关了，所以我们在 `PLAYER` 类中对有关 DoT 伤害的信息进行存储，并定义函数 `DOT()`，在每一个生效回合末激活。

```cpp
struct PLAYER {
    // ...

    int dot_dmg; // 持续伤害大小
    int dot_rounds; // 持续伤害层数

    // ...

    void DOT();
} team[2][7];

/// @brief DoT，即 Damage over Time，处理当前角色受到的 Average 类型的持续伤害
void PLAYER::DOT() {
    if (!status) return; // 保险措施，如果已经倒下就不用考虑了

    if (dot_rounds) { // 如果持续伤害层数不为 0
        --dot_rounds, hp -= dot_dmg; // 则触发一次持续伤害并减一层层数

        // 同上
        if (hp <= 0) {
            hp = 0;
            status = false;
        }

        void input() {
            // ...
            dot_rounds = 0; // 初始持续伤害剩余层数为 0
            dot_dmg = 0; // 初始持续伤害大小为 0
        }

        printf("%s %d took %d damage from skill -> %d/%d\n",
            (team_fr ? "North" : "South"), team_id, dot_dmg, hp, max_hp);
    }
}
```

那么接下来就可以写处理主动技能释放的函数了。

```cpp
/// @brief 触发主动技能
/// @param act 释放技能者在释放技能方队伍内的编号
/// @param trg 被释放技能者在被释放技能方队伍内的编号
/// @param t_a 释放技能方队伍的编号
/// @param t_b 被释放技能队伍的编号
void activate_active_skill(int act, int trg, int t_a, int t_b) {
    // 获取技能类型名以便输出
    str skl_type;

    if (team[t_a][act].type == 0) skl_type = "Weak";
    else if (team[t_a][act].type == 1) skl_type = "Average";
    else if (team[t_a][act].type == 2) skl_type = "Strong";

    printf("%s %d applied %s skill to %s %d\n",
        (t_a ? "North" : "South"), act, skl_type.c_str(), (t_b ? "North" : "South"), trg);

    // 对于 Weak 类型的主动技能
    if (team[t_a][act].type == 0) {
        int tmp = team[t_b][trg].hp;
        int heal = ACT_SKL_MUL[0][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算回复量
        team[t_b][trg].hp += heal; // 回复
        if (team[t_b][trg].hp > team[t_b][trg].max_hp) // 如果回复后超过生命上限
            team[t_b][trg].hp = team[t_b][trg].max_hp; // 则将生命值改为上限

        if (tmp != team[t_b][trg].hp) // 如果生命值有所变动，就需要输出
            printf("%s %d recovered +%d hp -> %d/%d\n",
                (t_b ? "North" : "South"), trg, heal, team[t_b][trg].hp, team[t_b][trg].max_hp);
    }

    // 对于 Average 类型的主动技能
    else if (team[t_a][act].type == 1) {
        team[t_b][trg].dot_rounds = 3; // 设持续伤害持续 3 层
        team[t_b][trg].dot_dmg = ACT_SKL_MUL[1][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算持续伤害大小
    }

    // 对于 Strong 类型的主动技能
    else if (team[t_a][act].type == 2)
        team[t_b][trg].skl_boost = ACT_SKL_MUL[2][team[t_a][act].act_skl]; // 更改角色的技能加成
}

int main() {
    // ...

    for (int RND = 1; RND <= round_cnt; ++RND) {
        // ...

        // 施放主动技能
        else if (str(action_type) == "Skill") // 只有 Average 类型的主动技能是对敌方的
            activate_active_skill(active, trg, t_a, (team[t_a][active].type == 1 ? t_b : t_a));

        // 对防守方队伍中所有收到持续伤害的队员结算持续伤害（同队施放的持续伤害只在同队为攻击方的回合内生效）
        for (int i = 1; i <= member_cnt[t_b]; ++i)
            team[t_b][i].DOT();

        putchar('\n');
    }
}
```

### 计算并施加被动技能

被动技能是本题主要的坑点之一，虽然题目已经说明，但还是很容易漏写。在角色倒下时，该角色给己方队伍贡献的被动技能数值需要重新计算。每回合开始时，还需要处理 Weak 类型的被动技能对己方队伍成员的生命值回复。因此我们写一个专门的函数 `reapply_passive_skills()`，在每次需要重新计算被动技能时，整体全部统计一遍。（反正数据范围小，复杂度再高也没什么问题。）

``` cpp
/// @brief 在每回合开始时及有角色倒下后重新计算被动伤害
/// @param t 默认为 -1，有角色倒下；如果输入为 0 或 1，则代表 Weak 类型的被动技能生效的团队
void reapply_passive_skills(int t = -1) {
    if (t != -1) { // 如果是开局，则需要使 Weak 类型的被动效果生效
        f64 weak = 0; // 统计 Weak 被动叠加效果层数
        for (int i = 1; i <= member_cnt[t]; ++i)
            if (team[t][i].status &&
                team[t][i].type == 0) // 对于当前队伍中所有还活着的 Weak 类型角色
                weak += PSV_SKL_MUL[0][team[t][i].psv_skl]; // 根据其等级叠加效果加成

        weak = std::min(weak, 0.05); // 考虑效果加成上限

        for (int i = 1; i <= member_cnt[t]; ++i) {
            if (!team[t][i].status) continue; // 已经倒下的角色就不用考虑了

            int tmp = team[t][i].hp;
            int heal = weak * team[t][i].max_hp; // 计算回复量
            team[t][i].hp += heal; // 回复
            if (team[t][i].hp > team[t][i].max_hp) // 如果回复后超过生命上限
                team[t][i].hp = team[t][i].max_hp; // 则将生命值更改为上限

            if (tmp != team[t][i].hp) // 如果生命值有所变动，就需要输出
                printf("%s %d recovered +%d hp -> %d/%d\n",
                    (t ? "North" : "South"), i, heal, team[t][i].hp, team[t][i].max_hp);
        }
    }

    // 对于其他两种类型，只需要在角色倒下后考虑被动技能分配情况即可
    for (int t = 0; t < 2; ++t) {
        f64 average = 0, strong = 0; // 统计被动效果叠加层数
        for (int i = 1; i <= member_cnt[t]; ++i)
            if (team[t][i].status) // 对于当前队伍中所有还活着的对应类型队员
                if (team[t][i].type == 1) // 统计 Average 被动叠加层数
                    average += PSV_SKL_MUL[1][team[t][i].psv_skl];
                else if (team[t][i].type == 2) // 统计 Strong 被动叠加层数
                    strong += PSV_SKL_MUL[2][team[t][i].psv_skl];

        // 根据上限进行相应调整
        average = std::min(average, 0.1);
        strong = std::min(strong, 0.1);

        // 增加对应的防御加成、攻击加成的值
        def_boost[t] = average + 1;
        atk_boost[t] = strong + 1;
    }
}
```

将这个函数添加到每回合开始时以及有角色倒下后即可。

### 其他细节

比如回合末信息的输出和最后赢家的判定。这些小细节就请看下面的完整代码了。

## Code

以下代码建议使用 Visual Studio Code 或者其他功能较丰富的编辑器打开预览，因为我在部分函数上添加了 Doxygen 注释，以便增强代码可读性，即使已经没有什么可读性可言了。但一定不要复制粘贴提交，一定要自己写一遍！

``` cpp
#include <cstdio>
#include <string>
#include <unordered_map>

#define endl '\n'

using f64 = double;
using str = std::string;
using MAP_SI = std::unordered_map<str, int>;
using MAP_II = std::unordered_map<int, int>;

// 固定的加成数值
const f64 LOC_BOOST[6] = {1.25, 1.00, 0.75, 0.00, 0.75, 1.00};
const f64 TYPE_BOOST[3][3] = {{1.0, 0.9, 1.1}, {1.1, 1.0, 0.9}, {0.9, 1.1, 1.0}};
const int PLACE[6] = {5, 3, 1, 2, 4, 6};

const f64 ACT_SKL_MUL[3][6] = {
    {0.00, 0.10, 0.12, 0.15, 0.17, 0.20},
    {0.00, 0.06, 0.07, 0.08, 0.09, 0.10},
    {1.00, 2.10, 2.17, 2.24, 2.32, 2.40}
};

const f64 PSV_SKL_MUL[3][6] = {
    {0.00, 0.013, 0.016, 0.019, 0.022, 0.025},
    {0.00, 0.01, 0.02, 0.03, 0.04, 0.05},
    {0.00, 0.01, 0.02, 0.03, 0.04, 0.05}
};

f64 atk_boost[2] = {1, 1};
f64 def_boost[2] = {1, 1};
MAP_SI WEAPON_TYPE = {{"B", 0}, {"G", 1}, {"M", 2}};
MAP_SI PLAYER_TYPE = {{"Weak", 0}, {"Average", 1}, {"Strong", 2}};
MAP_II INIT_INDEX = {{1, 2}, {2, 3}, {3, 1}, {4, 4}, {5, 0}, {6, 5}};

int member_cnt[2];
int round_cnt;
int attacker[2];

struct PLAYER {
    int team_fr; // 归属队伍
    int team_id; // 归属队伍内编号

    int type; // 类型：0 = weak, 1 = average, 2 = strong
    int lvl; // 等级：1 ~ 100
    f64 atk; // 基础攻击力
    f64 def; // 基础防御力
    int max_hp; // 体力上限
    int act_skl; // 主动技能等级：0 ~ 5
    int psv_skl; // 被动技能等级：0 ~ 5

    int weapon_type; // 武器类型：0 = B, 1 = G, 2 = M
    f64 weapon_atk; // 武器攻击力

    int hp; // 当前体力
    bool status; // 状态：0 = dead, 1 = alive
    f64 skl_boost; // 技能加成

    int dot_dmg; // 持续伤害大小
    int dot_rounds; // 持续伤害层数

    void input() {
        char player_type[10], weapon_type_t[4];
        scanf("%s Lv=%d maxhp=%d atk=%lf def=%lf skillLv=%d passivesklLv=%d %s weaponatk=%lf\n",
            player_type, &lvl, &max_hp, &atk, &def, &act_skl, &psv_skl, weapon_type_t, &weapon_atk);

        hp = max_hp; // 初始生命值为上限
        status = true; // 初始角色未倒下
        skl_boost = 1; // 初始技能加成为 1
        type = PLAYER_TYPE[str(player_type)]; // 根据输入获取角色类型对应数字
        weapon_type = WEAPON_TYPE[str(weapon_type_t)]; // 根据输入获取武器类型对应数字
        dot_rounds = 0; // 初始持续伤害剩余层数为 0
        dot_dmg = 0; // 初始持续伤害大小为 0
    }

    void deal_damage(int, int, f64);
    void DOT();
} team[2][7];

/// @brief 在每回合开始时及有角色倒下后重新计算被动伤害
/// @param t 默认为 -1，有角色倒下；如果输入为 0 或 1，则代表 Weak 类型的被动技能生效的团队
void reapply_passive_skills(int t = -1) {
    if (t != -1) { // 如果是开局，则需要使 Weak 类型的被动效果生效
        f64 weak = 0; // 统计 Weak 被动叠加效果层数
        for (int i = 1; i <= member_cnt[t]; ++i)
            if (team[t][i].status &&
                team[t][i].type == 0) // 对于当前队伍中所有还活着的 Weak 类型角色
                weak += PSV_SKL_MUL[0][team[t][i].psv_skl]; // 根据其等级叠加效果加成

        weak = std::min(weak, 0.05); // 考虑效果加成上限

        for (int i = 1; i <= member_cnt[t]; ++i) {
            if (!team[t][i].status) continue; // 已经倒下的角色就不用考虑了

            int tmp = team[t][i].hp;
            int heal = weak * team[t][i].max_hp; // 计算回复量
            team[t][i].hp += heal; // 回复
            if (team[t][i].hp > team[t][i].max_hp) // 如果回复后超过生命上限
                team[t][i].hp = team[t][i].max_hp; // 则将生命值更改为上限

            if (tmp != team[t][i].hp) // 如果生命值有所变动，就需要输出
                printf("%s %d recovered +%d hp -> %d/%d\n",
                    (t ? "North" : "South"), i, heal, team[t][i].hp, team[t][i].max_hp);
        }
    }

    // 对于其他两种类型，只需要在角色倒下后考虑被动技能分配情况即可
    for (int t = 0; t < 2; ++t) {
        f64 average = 0, strong = 0; // 统计被动效果叠加层数
        for (int i = 1; i <= member_cnt[t]; ++i)
            if (team[t][i].status) // 对于当前队伍中所有还活着的对应类型队员
                if (team[t][i].type == 1) // 统计 Average 被动叠加层数
                    average += PSV_SKL_MUL[1][team[t][i].psv_skl];
                else if (team[t][i].type == 2) // 统计 Strong 被动叠加层数
                    strong += PSV_SKL_MUL[2][team[t][i].psv_skl];

        // 根据上限进行相应调整
        average = std::min(average, 0.1);
        strong = std::min(strong, 0.1);

        // 增加对应的防御加成、攻击加成的值
        def_boost[t] = average + 1;
        atk_boost[t] = strong + 1;
    }
}

/// @brief 根据攻击强度对当前角色进行扣血
/// @param t_a 攻击方队伍的编号
/// @param act 攻击者在攻击方队伍内的编号
/// @param eff 攻击强度
void PLAYER::deal_damage(int t_a, int act, f64 eff) {
    if (!status) return; // 保险措施，如果已经倒下就不用考虑了

    int dmg = eff / (def * def_boost[team_fr]); // 计算攻击产生扣血的有效值
    hp -= dmg; // 扣血

    // 如果扣血后角色生命值不高于 0，则该角色倒下
    if (hp <= 0) {
        hp = 0;
        status = false; // 设定角色状态为倒下
        reapply_passive_skills(); // 重新考虑被动技能
    }

    printf("%s %d took %d damage from %s %d -> %d/%d\n",
        (team_fr ? "North" : "South"), team_id, dmg, (t_a ? "North" : "South"), act, hp, max_hp);
}

/// @brief DoT，即 Damage over Time，处理当前角色受到的 Average 类型的持续伤害
void PLAYER::DOT() {
    if (!status) return; // 保险措施，如果已经倒下就不用考虑了

    if (dot_rounds) { // 如果持续伤害层数不为 0
        --dot_rounds, hp -= dot_dmg; // 则触发一次持续伤害并减一层层数

        // 同上
        if (hp <= 0) {
            hp = 0;
            status = false;
            reapply_passive_skills();
        }

        printf("%s %d took %d damage from skill -> %d/%d\n",
            (team_fr ? "North" : "South"), team_id, dot_dmg, hp, max_hp);
    }
}

/// @brief 计算每一回合攻击方队伍的攻击者
/// @param t 攻击方队伍的编号
void get_attacker(int t) {
    do {
        ++attacker[t];
        if (attacker[t] > member_cnt[t]) attacker[t] = 1;
    } while (!team[t][attacker[t]].status); // 如果找到未倒下的角色就跳出循环
    // 由于题目保证所有操作合法，所以不用担心死循环
}

/// @brief 触发主动技能
/// @param act 释放技能者在释放技能方队伍内的编号
/// @param trg 被释放技能者在被释放技能方队伍内的编号
/// @param t_a 释放技能方队伍的编号
/// @param t_b 被释放技能队伍的编号
void activate_active_skill(int act, int trg, int t_a, int t_b) {
    // 获取技能类型名以便输出
    str skl_type;

    if (team[t_a][act].type == 0) skl_type = "Weak";
    else if (team[t_a][act].type == 1) skl_type = "Average";
    else if (team[t_a][act].type == 2) skl_type = "Strong";

    printf("%s %d applied %s skill to %s %d\n",
        (t_a ? "North" : "South"), act, skl_type.c_str(), (t_b ? "North" : "South"), trg);

    // 对于 Weak 类型的主动技能
    if (team[t_a][act].type == 0) {
        int tmp = team[t_b][trg].hp;
        int heal = ACT_SKL_MUL[0][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算回复量
        team[t_b][trg].hp += heal; // 回复
        if (team[t_b][trg].hp > team[t_b][trg].max_hp) // 如果回复后超过生命上限
            team[t_b][trg].hp = team[t_b][trg].max_hp; // 则将生命值改为上限

        if (tmp != team[t_b][trg].hp) // 如果生命值有所变动，就需要输出
            printf("%s %d recovered +%d hp -> %d/%d\n",
                (t_b ? "North" : "South"), trg, heal, team[t_b][trg].hp, team[t_b][trg].max_hp);
    }

    // 对于 Average 类型的主动技能
    else if (team[t_a][act].type == 1) {
        team[t_b][trg].dot_rounds = 3; // 设持续伤害持续 3 层
        team[t_b][trg].dot_dmg = ACT_SKL_MUL[1][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算持续伤害大小
    }

    // 对于 Strong 类型的主动技能
    else if (team[t_a][act].type == 2)
        team[t_b][trg].skl_boost = ACT_SKL_MUL[2][team[t_a][act].act_skl]; // 更改角色的技能加成
}

/// @brief 实施普通攻击和特殊攻击
/// @param atk_p 攻击位置
/// @param ddg_p 躲闪位置
/// @param act 攻击者在攻击方队伍内的编号
/// @param trg 防御者在防御方队伍内的编号
/// @param t_a 攻击方队伍编号
/// @param t_b 防御方队伍编号
/// @param type 攻击类型，-1 为普通攻击，0~2 为对应的特殊攻击
void perform_attack(int atk_p, int ddg_p, int act, int trg, int t_a, int t_b, int type = -1) {
    // 由于 G 和 M 类型的种族加成对不同目标有不同的取值，所以预处理时不包含种族加成
    f64 eff = team[t_a][act].atk *
        team[t_a][act].weapon_atk *
        team[t_a][act].skl_boost *
        atk_boost[t_a] *
        LOC_BOOST[(atk_p - ddg_p + 6) % 6];

    // 普通攻击
    if (type == -1)
        return team[t_b][trg].deal_damage(t_a, act, eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);

    // B 型特殊攻击
    if (type == 0)
        return team[t_b][trg].deal_damage(t_a, act, 1.25 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);

    // 预处理 G 和 M 类型特殊 AoE 攻击的范围
    int trg_l = -1, trg_r = -1;

    // 西边第一个未倒下的角色
    for (int i = INIT_INDEX[trg] - 1; i >= 0; --i)
        if (team[t_b][PLACE[i]].status) {
            trg_l = PLACE[i];
            break;
        }

    // 东边第一个未倒下的角色
    for (int i = INIT_INDEX[trg] + 1; i < 6; ++i)
        if (team[t_b][PLACE[i]].status) {
            trg_r = PLACE[i];
            break;
        }

    // G 型特殊攻击
    if (type == 1) {
        int cand_cnt = (trg_l != -1) + (trg_r != -1) + 1;
        f64 mul = 1.35 / cand_cnt;

        team[t_b][trg].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);
        if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]);
        if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]);
    }

    // M 型特殊攻击
    else if (type == 2) {
        team[t_b][trg].deal_damage(t_a, act, 1.15 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]);
        if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]);
        if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]);
    }
}

int main() {
    scanf("%d %d\n", &member_cnt[0], &member_cnt[1]);

    // 输入南队队员
    for (int i = 1; i <= member_cnt[0]; ++i) {
        team[0][i].input();
        team[0][i].team_fr = 0;
        team[0][i].team_id = i;
    }

    // 输入北队队员
    for (int i = 1; i <= member_cnt[1]; ++i) {
        team[1][i].input();
        team[1][i].team_fr = 1;
        team[1][i].team_id = i;
    }

    scanf("%d\n", &round_cnt);

    for (int RND = 1; RND <= round_cnt; ++RND) {
        int t_a = (RND % 2) ^ 1; // 计算攻击方队伍
        int t_b = (RND % 2); // 计算防御方队伍

        // 对攻击方队伍施放 Weak 类型被动技能
        reapply_passive_skills(t_a);

        // 获取攻击方队伍的当前攻击者
        get_attacker(t_a);
        int active = attacker[t_a];

        char action_type[20];
        int trg;

        scanf("%s target=%d ", action_type, &trg);

        // 施放普通攻击
        if (str(action_type) == "Basicattack") {
            int atk_p, ddg_p;
            scanf("atkpos=%d ddgpos=%d \n", &atk_p, &ddg_p);
            perform_attack(atk_p, ddg_p, active, trg, t_a, t_b);
            team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成
        }

        // 施放特殊攻击
        else if (str(action_type) == "Specialattack") {
            int atk_p, ddg_p;
            scanf("atkpos=%d ddgpos=%d \n", &atk_p, &ddg_p);
            perform_attack(atk_p, ddg_p, active, trg, t_a, t_b, team[t_a][active].weapon_type);
            team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成
        }

        // 施放主动技能
        else if (str(action_type) == "Skill") // 只有 Average 类型的主动技能是对敌方的
            activate_active_skill(active, trg, t_a, (team[t_a][active].type == 1 ? t_b : t_a));

        // 对防守方队伍中所有收到持续伤害的队员结算持续伤害（同队施放的持续伤害只在同队为攻击方的回合内生效）
        for (int i = 1; i <= member_cnt[t_b]; ++i)
            team[t_b][i].DOT();

        // 先输出北队，再输出南队
        for (int t = 1; ~t; --t) {
            printf("%s: ", t ? "North" : "South");
            for (int i = 0; i < 6; i++)
                if (PLACE[i] <= member_cnt[t]) // 如果队伍不足 6 人就不输出对应位置的生命值
                    printf("%d/%d ", team[t][PLACE[i]].hp, team[t][PLACE[i]].max_hp);
            putchar('\n');
        }

        putchar('\n');
    }

    // 统计是否有队伍获胜
    int alive_cnt[2] = {0, 0};

    for (int t = 0; t < 2; ++t)
        for (int i = 1; i <= member_cnt[t]; ++i)
            if (team[t][i].status || team[t][i].hp)
                ++alive_cnt[t];

    if (!alive_cnt[0])
        puts("Team North won.");
    else if (!alive_cnt[1])
        puts("Team South won.");

    return fflush(stdout), 0;
}
```

## Tips

写这道题让我获得了许多写模拟的心得，下面简单说几条我觉得比较重要的。

- 对于纯模拟题，一定要保证关键信息的可获取性。简单来说，在任何环境下，你都一定要保留至少一种查询到你所需要的信息的方式。它决定了我们需要维护什么东西。
- 保证代码可读。平时写 OI 题那种只有一个字母的变量名尽量少出现，多写注释，要让自己时刻清楚自己在写什么代码、实现什么功能，不被大量的信息冲昏头脑。
- 善用 Ctrl/Cmd + F 查找。像本题这种，同样一种属性可能在很多地方被影响或者影响其他数值的情况，最好用浏览器或 PDF 阅读器的查找功能找到某一个属性在题目表述中所有出现的地方，确保自己考虑周全了。

## Epilogue

感谢你看到这里。这份代码或许不是最为简洁、最有效率的一份代码，但我依然希望你在完成这道题、阅读这篇题解的过程中有所收获。毕竟，正如出题人提供的的大样例成为我 AC 这道题的道路上一份有力的援助一样，写出这道题也一定是我们锻炼自己编码能力和调试能力、最终成为一名优秀的程序员的路途中一次十分有价值的经历吧。与你共勉。

---

## 作者：Yoimiyamwf (赞：2)

~~第一次写大模拟的题解，好激动~~

~~本题只需要按题意模拟即可，本文到此结束（不是）~~

# 关于大模拟的一些小建议

1. 开始敲之前一定要仔细看题，先看上个两三遍起步，确保完全理解了题意再开工。

1. 必要的话可以把重要信息记录下来，理清思路。

1. 一些具体操作建议写到函数里，这样写出来代码更直观，主要是好调。

1. 马蜂一定要优雅，不要试图压行，否则你可能调疯（）

1. 变量名取的直观一点，同样是方便调试。

1. 要有耐心。

# 开始~~百年工程~~

个人比较习惯从一些基础操作开始写，感觉这样思路更清楚。

我这里为了直观好调试，取的变量名稍微有那么亿点点长（）

下文中的一些宏定义：

```cpp
#define NORTH 0
#define SOUTH 1
#define target_team (!source_team)
#define get_team(x) ((x)?"South":"North")
```


## 基本信息

通读全文后，可以发现对于每个角色，其信息包含「等级」、「种族」、「体力上限」、「体力值」、「ATK」、「DEF」、「主动技能等级」、「被动技能等级」、「武器类型」、「武器攻击力」、「技能加成」。其中等级貌似没什么用，其余部分写个结构体维护即可。不建议写一堆数组，这样看上去会有点乱（）

同时，Average 种族的主动技能是针对单个角色的持续效果，可以把流血量和剩余回合数一起存进来。

注意 「ATK」、「DEF」、「武器攻击力」、「技能加成」这几个都是实数，记得开 double。

```cpp
struct character{
    string Race; //种族
    char Weapon; //武器类型
    int Lv,MaxHP,HP,SkillLv,PassiveLv,BleedRound;
    //从左到右依次是：等级，体力上限，体力值，主动技能等级，被动技能等级，流血剩余回合数
    double ATK,DEF,WeaponATK,Bleed,SkillBonus;
    //ATK，DEF，武器攻击力，流血量，技能加成
    bool dead; //用来判断这个角色是否已死亡
};
```

对于每个队伍，全局信息包含「总人数」、「剩余存活人数」、「DEF 加成」、「ATK 加成」、「回合开始回血量」（这三个都取决于队伍角色的被动技能），同时为了方便判断接下来行动的角色，还需要存储一下下一个要进行行动的是哪个角色。

```cpp
struct team{
    character I[7];
    int next,memcnt,maxid;
    double defBonus,atkBonus,recoverBonus;
}Team[2];
```

## 输入信息

感觉输入部分的这个科学计数法和各种没用的字符串有点麻烦（）

实数要处理，~~不过你要是愿意手写个科学计数法表示小数也不是不行~~，没用的字符可以用快读或者 scanf 过滤。

注意被动技能总倍率是加起来的，并且不要在此时直接处理上限，否则后面角色死亡可能会造成被动技能倍率混乱。

```
void TeamInit(int team){
    Team[team].atkBonus=Team[team].defBonus=1;
    Team[team].recoverBonus=Team[team].memcnt=Team[team].maxid=Team[team].next=0;
}
void CharacterInit(int team,int id){
    cin>>Team[team].I[id].Race,r(Team[team].I[id].Lv),r(Team[team].I[id].MaxHP);
    Team[team].I[id].HP=Team[team].I[id].MaxHP;
    r(x1),r(x2);
    Team[team].I[id].ATK=x1*pow(10,x2);
    r(x1),r(x2);
    Team[team].I[id].DEF=x1*pow(10,x2);
    r(Team[team].I[id].SkillLv),r(Team[team].I[id].PassiveLv);
    ch=getchar();
    while(!isalpha(ch)) ch=getchar();
    Team[team].I[id].Weapon=ch;
    r(x1),r(x2);
    Team[team].I[id].WeaponATK=x1*pow(10,x2);
    if(Team[team].I[id].Race=="Weak"){
        double SkillBonus[6]={0,0.013,0.016,0.019,0.022,0.025};
        Team[team].recoverBonus+=SkillBonus[Team[team].I[id].PassiveLv];
    }else if(Team[team].I[id].Race=="Average"){
        double SkillBonus[6]={0,0.01,0.02,0.03,0.04,0.05};
        Team[team].defBonus+=SkillBonus[Team[team].I[id].PassiveLv];
    }else{
        double SkillBonus[6]={0,0.01,0.02,0.03,0.04,0.05};
        Team[team].atkBonus+=SkillBonus[Team[team].I[id].PassiveLv];
    }
    Team[team].memcnt++;
    Team[team].I[id].BleedRound=Team[team].I[id].Bleed=0;
    Team[team].I[id].SkillBonus=1;
}
void IO(){
    TeamInit(SOUTH),TeamInit(NORTH);
    cin>>Team[SOUTH].maxid>>Team[NORTH].maxid;
    for(rint i=1;i<=Team[SOUTH].maxid;i++){
        CharacterInit(SOUTH,i);
    }
    for(rint i=1;i<=Team[NORTH].maxid;i++){
        CharacterInit(NORTH,i);
    }
}
```


## 伤害部分

一些比较麻烦的分情况讨论建议拉出来单独写一个函数，其他的直接在造成伤害时运算即可。

### 种族克制

按照题意写即可，我这里是用函数加一堆 if 判断的，这样会直观一点。

```cpp
double RaceRestraint(int source_team,int source,int target){
    if(Team[source_team].I[source].Race=="Weak"){
        if(Team[target_team].I[target].Race=="Weak") return 1;
        if(Team[target_team].I[target].Race=="Average") return 0.9;
        if(Team[target_team].I[target].Race=="Strong") return 1.1;
    }
    if(Team[source_team].I[source].Race=="Average"){
        if(Team[target_team].I[target].Race=="Weak") return 1.1;
        if(Team[target_team].I[target].Race=="Average") return 1;
        if(Team[target_team].I[target].Race=="Strong") return 0.9;
    }
    if(Team[source_team].I[source].Race=="Strong"){
        if(Team[target_team].I[target].Race=="Weak") return 0.9;
        if(Team[target_team].I[target].Race=="Average") return 1.1;
        if(Team[target_team].I[target].Race=="Strong") return 1;
    }
    return 1;
}
```

### 方位加成

直接把每种结果存到一个数组里即可。

### 伤害计算

按照题目中的定义写出来计算出总伤害，然后给受伤角色减去对应的量。由于受伤后可能涉及到角色死亡，所以每次都要判断一下受伤角色的 HP 是否减到了 $0$ 以下。为了方便后面的输出， HP 降为负数后直接赋为 $0$。

```cpp
void Damage(int source_team,double BaseATK,int source,int target,int pos){
    double posadd[6]={1.25,1,0.75,0,0.75,1};
    double posBonus=posadd[pos];
    double ATKStrength=BaseATK*Team[source_team].I[source].SkillBonus*min(1.1,Team[source_team].atkBonus)*RaceRestraint(source_team,source,target)*posBonus;
    int damage=ATKStrength/(min(1.1,Team[target_team].defBonus)*Team[target_team].I[target].DEF);
    Team[target_team].I[target].HP-=damage;
    if(Team[target_team].I[target].HP<0) Team[target_team].I[target].HP=0;
    printf("%s %d took %d damage from %s %d -> %d/%d\n",get_team(target_team),target,damage,get_team(source_team),source,Team[target_team].I[target].HP,Team[target_team].I[target].MaxHP);
    JudgeDead(target_team,target);
}
```

### 死亡判断

角色死亡后，可能变化的值有「剩余存活人数」、「回合开始回血量」、「ATK 加成」、「DEF 加成」，需要处理好对应的变化。Average 和 Strong 种族的被动技能会在死后时效，记得在加成里面减去影响。

```cpp
void JudgeDead(int tg_team,int source){
    if(Team[tg_team].I[source].HP<=0){
        Team[tg_team].I[source].dead=true;
        Team[tg_team].memcnt--;
        if(Team[tg_team].I[source].Race=="Weak"){
            double SkillBonus[6]={0,0.013,0.016,0.019,0.022,0.025};
            Team[tg_team].recoverBonus-=SkillBonus[Team[tg_team].I[source].PassiveLv];
        }else if(Team[tg_team].I[source].Race=="Average"){
            double SkillBonus[6]={0,0.01,0.02,0.03,0.04,0.05};
            Team[tg_team].defBonus-=SkillBonus[Team[tg_team].I[source].PassiveLv];
        }else{
            double SkillBonus[6]={0,0.01,0.02,0.03,0.04,0.05};
            Team[tg_team].atkBonus-=SkillBonus[Team[tg_team].I[source].PassiveLv];
        }
    }
}
```

## 攻击和技能

### 普通攻击

还是比较简单的，直接按照定义算出伤害量即可，记得攻击后清空技能加成。

```cpp
void BasicAttack(int source_team,int source,int target,int pos){
    double BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK;
    Damage(source_team,BaseATK,source,target,pos);
    Team[source_team].I[source].SkillBonus=1;
}
```

### 特殊攻击

#### B 类攻击

和普通攻击一样，只是多乘个 $125%$。

```cpp
double BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*1.25;
Damage(source_team,BaseATK,source,target,pos);
```

#### G 类攻击

最麻烦的一个。。。

首先要找出攻击目标左右两边最近的角色，这里写了两个简单的函数。

```cpp
int las[8]={0,3,1,5,2,0,4,0},nex[8]={0,2,4,1,6,3,0,0};
in int West(int team,int id){
    if(!id) return -1;
    if(Team[team].I[las[id]].dead||las[id]>Team[team].maxid) return West(team,las[id]);
    return las[id];
}
in int East(int team,int id){
    if(!id) return -1;
    if(Team[team].I[nex[id]].dead||nex[id]>Team[team].maxid) return East(team,nex[id]);
    return nex[id];
}
```

同时要统计合法的目标数来计算伤害，记得如果没有合法目标就不要乱打伤害了（）同时技能加成是在整个攻击结束后才清空，不是只对第一个角色有效~~，我因为这个调了半个小时~~。

```cpp
int east=East(target_team,target),west=West(target_team,target);
int cnt=1+(east>0)+(west>0);
double BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*1.35/cnt;
Damage(source_team,BaseATK,source,target,pos);
if(west>0) Damage(source_team,BaseATK,source,west,pos);
if(east>0) Damage(source_team,BaseATK,source,east,pos);
```

#### M 类攻击

和上面那个差不多。

```cpp
int east=East(target_team,target),west=West(target_team,target);
double BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*1.15;
Damage(source_team,BaseATK,source,target,pos);
BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*0.23;
if(west>0) Damage(source_team,BaseATK,source,west,pos);
if(east>0) Damage(source_team,BaseATK,source,east,pos);
```

#### 总代码

```cpp
void SpAttack(int source_team,int source,int target,int pos){
    switch(Team[source_team].I[source].Weapon){
        case 'B':{
            double BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*1.25;
            Damage(source_team,BaseATK,source,target,pos);
            break;
        }
        case 'G':{
            int east=East(target_team,target),west=West(target_team,target);
            int cnt=1+(east>0)+(west>0);
            double BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*1.35/cnt;
            Damage(source_team,BaseATK,source,target,pos);
            if(west>0) Damage(source_team,BaseATK,source,west,pos);
            if(east>0) Damage(source_team,BaseATK,source,east,pos);
            break;
        }
        case 'M':{
            int east=East(target_team,target),west=West(target_team,target);
            double BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*1.15;
            Damage(source_team,BaseATK,source,target,pos);
            BaseATK=Team[source_team].I[source].ATK*Team[source_team].I[source].WeaponATK*0.23;
            if(west>0) Damage(source_team,BaseATK,source,west,pos);
            if(east>0) Damage(source_team,BaseATK,source,east,pos);
            break;
        }
    }
    Team[source_team].I[source].SkillBonus=1;
}
```

### 主动技能

按照题意计算即可。注意 Weak 种族回血那部分要特判一下，如果目标体力已满就不需要回血也不需要输出，直接 return 调。

```cpp
void Skill(int source_team,int source,int target){
    if(Team[source_team].I[source].Race=="Weak"){
        printf("%s %d applied Weak skill to %s %d\n",get_team(source_team),source,get_team(source_team),target);
        if(Team[source_team].I[target].HP==Team[source_team].I[target].MaxHP) return;
        double SkillBonus[6]={0,0.1,0.12,0.15,0.17,0.2};
        int heal=Team[source_team].I[target].MaxHP*SkillBonus[Team[source_team].I[source].SkillLv];
        Team[source_team].I[target].HP+=heal;
        if(Team[source_team].I[target].HP>Team[source_team].I[target].MaxHP) Team[source_team].I[target].HP=Team[source_team].I[target].MaxHP;
        printf("%s %d recovered +%d hp -> %d/%d\n",get_team(source_team),target,heal,Team[source_team].I[target].HP,Team[source_team].I[target].MaxHP);
    }else if(Team[source_team].I[source].Race=="Average"){
        printf("%s %d applied Average skill to %s %d\n",get_team(source_team),source,get_team(target_team),target);
        double SkillBonus[6]={0,0.06,0.07,0.08,0.09,0.1};
        Team[target_team].I[target].BleedRound=3;
        Team[target_team].I[target].Bleed=SkillBonus[Team[source_team].I[source].SkillLv];
    }else if(Team[source_team].I[source].Race=="Strong"){
        printf("%s %d applied Strong skill to %s %d\n",get_team(source_team),source,get_team(source_team),target);
        double SkillBonus[6]={0,2.1,2.17,2.24,2.32,2.4};
        Team[source_team].I[target].SkillBonus=SkillBonus[Team[source_team].I[source].SkillLv];
    }
}
```

## 战斗部分

上面各种技能伤害之类的已经写好了，这部分直接调用上面的函数即可。

要注意的是：

1. 在回合开始时，执行本回合的队伍所有**体力值不满**的角色会恢复生命

1. 回合结束后，**对手**受到 Average 种族技能影响的角色会流血

1. 等到回合开始时再确定需要执行操作的角色，或者在此时判断一下当前要操作的角色是否存活，否则可能出现死人突然秽土转生起来打人的情况（）

```cpp
void Gaming(){
    cin>>t;
    for(rint i=1;i<=t;i++){
        cin>>opt;
        Recover(i&1);
        Team[i&1].next=next(i&1,Team[i&1].next);
        if(opt=="Basicattack"){
            r(target),r(atkpos),r(ddgpos);
            BasicAttack(i&1,Team[i&1].next,target,mod(atkpos-ddgpos));
        }else if(opt=="Specialattack"){
            r(target),r(atkpos),r(ddgpos);
            SpAttack(i&1,Team[i&1].next,target,mod(atkpos-ddgpos));
        }else{
            r(target);
            Skill(i&1,Team[i&1].next,target);
        }
        Bleeding(!(i&1));
        GetHP(NORTH);
        GetHP(SOUTH);
        putchar('\n');
    }
}
```

## 胜负判断

看一下每个队伍的存活角色数，然后输出即可。注意如果双方都没有全员倒下，那么本局胜负未分，不需要执行本段。

```cpp
void GameEnding(){
    if(!Team[NORTH].memcnt){
        puts("Team South won.");
    }else if(!Team[SOUTH].memcnt){
        puts("Team North won.");
    }
}
```

此时，你已经完成了每一部分的代码，只需要拼接起来并耐心调试即可。

---

## 作者：Phartial (赞：2)

小清新大模拟（？

写起来挺顺的，就是浮点误差那块整破防了，最后问了神虎用了科学计数法存浮点数才过。

stO 神虎 Orz

坑点：

- 注意精度误差；
- 死亡后要清除 Average 的主动技能，防止重复触发死亡处理导致被动技能被弄乱；
- Average 的主动技能里的 “$3$ 个回合” 指的是南北两边各行动一次算一个回合，且回合结束时只清算敌队的 Average 的主动技能效果；
- 如果 Weak 的技能没有造成实际上的体力回复（而不仅仅是当体力达到上限时），不输出对应信息；
- 输出信息格式，注意空格。

小技巧：使用 `C++` 风格输入输出时，可以使用

```cpp
struct Skiper {
} skip;
istream &operator>>(istream &in, Skiper skip) {
  for (; in.get() != '=';) {
  }
  return in;
}
```

来跳过形如 `[sth.]=` 的输入，用法是直接 `cin >> skip`。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;
using i128 = __int128_t;

struct Skiper {
} skip;
istream &operator>>(istream &in, Skiper skip) {
  for (; in.get() != '=';) {
  }
  return in;
}

i128 pow10[39];
auto InitPow10 = []() {
  for (int i = pow10[0] = 1; i <= 38; ++i) {
    pow10[i] = pow10[i - 1] * 10;
  }
  return 0;
}();

struct Float {
  i128 mag;
  int exp;

  Float(i128 mag = 0, int exp = 0) : mag(mag), exp(exp) { Shrink(); }
  void Shrink() {
    for (; mag && (mag % 10 + 10) % 10 == 0; mag /= 10, ++exp) {
    }
  }
  Float operator+(const Float &o) const {
    int rexp = min(exp, o.exp);
    return Float(mag * pow10[exp - rexp] + o.mag * pow10[o.exp - rexp], rexp);
  }
  Float operator-() const { return Float(-mag, exp); }
  Float operator-(const Float &o) const { return *this + (-o); }
  Float operator*(const Float &o) const { return Float(mag * o.mag, exp + o.exp); }
  int operator*(int o) const {
    __int128_t s = mag * o;
    if (exp < 0) {
      return s / pow10[-exp];
    }
    return s * pow10[exp];
  }
  int operator/(const Float &o) const {
    int rexp = min(exp, o.exp);
    return (mag * pow10[exp - rexp]) / (o.mag * pow10[o.exp - rexp]);
  }
  Float operator+=(const Float &o) { return *this = *this + o; }
  Float operator-=(const Float &o) { return *this = *this - o; }
  bool operator<(const Float &o) const {
    int rexp = min(exp, o.exp);
    return (mag * pow10[exp - rexp]) < (o.mag * pow10[o.exp - rexp]);
  }
};
Float operator"" lf(const char *s) {
  int p = 0, c = 0, d = 0;
  for (int i = 0; s[i] != '\0'; ++i) {
    if (s[i] == '.') {
      d = 1;
    } else {
      p = p * 10 + s[i] - '0';
      c -= d;
    }
  }
  return Float(p, c);
}
istream &operator>>(istream &in, Float &x) {
  for (char c; (c = in.get()) != 'e'; x.mag = x.mag * 10 + c - '0') {
  }
  in >> x.exp;
  x.Shrink();
  return in;
}

const string kTeam[2] = {"South", "North"};
const string kType[3] = {"Weak", "Average", "Strong"};
const char kWeaponType[3] = {'B', 'G', 'M'};
const Float kTypeBuff[3][3] = {{1lf, 0.9lf, 1.1lf}, {1.1lf, 1lf, 0.9lf}, {0.9lf, 1.1lf, 1lf}};
const Float kPosBuff[6] = {1.25lf, 1lf, 0.75lf, 0lf, 0.75lf, 1lf};
const int kPos[7] = {0, 5, 3, 1, 2, 4, 6};
const int kWhere[7] = {0, 3, 4, 2, 5, 1, 6};
const Float kPassSkill[3][6] = {{0lf, 0.013lf, 0.016lf, 0.019lf, 0.022lf, 0.025lf}, {0lf, 0.01lf, 0.02lf, 0.03lf, 0.04lf, 0.05lf}, {0lf, 0.01lf, 0.02lf, 0.03lf, 0.04lf, 0.05lf}};
const Float kSkill[3][6] = {{0lf, 0.1lf, 0.12lf, 0.15lf, 0.17lf, 0.2lf}, {0lf, 0.06lf, 0.07lf, 0.08lf, 0.09lf, 0.1lf}, {1lf, 2.1lf, 2.17lf, 2.24lf, 2.32lf, 2.4lf}};

int n[2], last[2], turn;
Float buff[3][2] = {{}, {1lf, 1lf}, {1lf, 1lf}};
struct Player {
  int team, id, type, level, max_hp, hp, skill_level, passive_skill_level, weapon_type;
  Float atk, def, weapon_atk;
  bool dead;
  Float skill_buff = 1lf;
  Float poison;
  int poison_turn;

  void PassiveSkill(bool g) {
    Float _ = kPassSkill[type][passive_skill_level];
    buff[type][team] += g ? _ : -_;
  }
  void TakeDamage(const Player &from, Float damage, int atkpos, int ddgpos) {
    Float real_atk = damage * from.skill_buff * min(1.1lf, buff[2][from.team]) * kTypeBuff[from.type][type] * kPosBuff[(atkpos - ddgpos + 6) % 6];
    Float real_def = def * min(1.1lf, buff[1][team]);
    int real_damage = real_atk / real_def;
    hp = max(0, hp - real_damage);
    cout << kTeam[team] << ' ' << id << " took " << real_damage << " damage from " << kTeam[from.team] << ' ' << from.id << " -> " << hp << '/' << max_hp << '\n';
    CheckDead();
  }
  void CheckDead() {
    if (!hp) {
      dead = 1, poison = 0lf, poison_turn = 0;
      PassiveSkill(0);
    }
  }
  void Recovered(Float d) {
    int delta = d * max_hp;
    if (hp != min(max_hp, hp + delta)) {
      hp = min(max_hp, hp + delta);
      cout << kTeam[team] << ' ' << id << " recovered +" << delta << " hp -> " << hp << '/' << max_hp << '\n';
    }
  }
} p[2][7];

void CheckWin() {
  for (int o = 0; o < 2; ++o) {
    bool f = 1;
    for (int i = 1; i <= n[o]; ++i) {
      f &= p[o][i].dead;
    }
    if (f) {
      cout << "Team " << kTeam[!o] << " won.";
      return;
    }
  }
}
int GetActor(int o) {
  int i = last[o] % n[o] + 1;
  for (; p[o][i].dead; i = i % n[o] + 1) {
  }
  return last[o] = i;
}
vector<int> GetNeighbor(int o, int x) {
  vector<int> neighbor(1, x);
  for (int d = -1; d <= 1; ++d) {
    if (!d) {
      continue;
    }
    int i = kWhere[x] + d;
    for (; 1 <= i && i <= 6 && kPos[i] <= n[o] && p[o][kPos[i]].dead; i += d) {
    }
    if (1 <= i && i <= 6 && kPos[i] <= n[o]) {
      neighbor.push_back(kPos[i]);
    }
  }
  return neighbor;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n[0] >> n[1];
  for (int o = 0; o < 2; ++o) {
    for (int i = 1; i <= n[o]; ++i) {
      Player &x = p[o][i];
      x.team = o, x.id = i;
      string s;
      cin >> s;
      x.type = find(kType, kType + 3, s) - kType;
      cin >> skip >> x.level >> skip >> x.max_hp >> skip >> x.atk >> skip >> x.def >> skip >> x.skill_level >> skip >> x.passive_skill_level;
      char c;
      cin >> c;
      x.weapon_type = find(kWeaponType, kWeaponType + 3, c) - kWeaponType;
      cin >> skip >> x.weapon_atk;
      x.hp = x.max_hp;
      x.PassiveSkill(1);
    }
  }
  cin >> turn;
  for (int o = 0; turn--; o ^= 1) {
    for (int i = 1; i <= n[o]; ++i) {
      if (!p[o][i].dead) {
        p[o][i].Recovered(min(0.05lf, buff[0][o]));
      }
    }
    string type;
    int target, atkpos, ddgpos;
    cin >> type >> skip >> target;
    Player &actor = p[o][GetActor(o)];
    Player &t = p[!o][target];
    if (type == "Basicattack") {
      cin >> skip >> atkpos >> skip >> ddgpos;
      t.TakeDamage(actor, actor.atk * actor.weapon_atk, atkpos, ddgpos);
      actor.skill_buff = 1;
    } else if (type == "Specialattack") {
      cin >> skip >> atkpos >> skip >> ddgpos;
      if (actor.weapon_type == 0) {
        t.TakeDamage(actor, actor.atk * actor.weapon_atk * 1.25lf, atkpos, ddgpos);
      } else if (actor.weapon_type == 1) {
        vector<int> neighbor = GetNeighbor(!o, target);
        for (int _target : neighbor) {
          p[!o][_target].TakeDamage(actor, actor.atk * actor.weapon_atk * (neighbor.size() == 1 ? 1.35lf : (neighbor.size() == 2 ? 0.675lf : 0.45lf)), atkpos, ddgpos);
        }
      } else {
        t.TakeDamage(actor, actor.atk * actor.weapon_atk * 1.15lf, atkpos, ddgpos);
        vector<int> neighbor = GetNeighbor(!o, target);
        for (int _target : neighbor) {
          if (_target != target) {
            p[!o][_target].TakeDamage(actor, actor.atk * actor.weapon_atk * 0.23lf, atkpos, ddgpos);
          }
        }
      }
      actor.skill_buff = 1;
    } else {
      cout << kTeam[o] << ' ' << actor.id << " applied " << kType[actor.type] << " skill to ";
      Float skill_value = kSkill[actor.type][actor.skill_level];
      if (actor.type == 0) {
        cout << kTeam[o] << ' ' << target << '\n';
        p[o][target].Recovered(skill_value);
      } else if (actor.type == 1) {
        cout << kTeam[!o] << ' ' << target << '\n';
        t.poison = skill_value;
        t.poison_turn = 3;
      } else {
        cout << kTeam[o] << ' ' << target << '\n';
        p[o][target].skill_buff = skill_value;
      }
    }
    for (int i = 1; i <= n[!o]; ++i) {
      Player &_p = p[!o][i];
      if (!_p.dead && _p.poison_turn) {
        int real_damage = _p.poison * _p.max_hp;
        _p.hp = max(0, _p.hp - real_damage);
        cout << kTeam[!o] << ' ' << i << " took " << real_damage << " damage from skill -> " << _p.hp << '/' << _p.max_hp << '\n';
        if (!_p.hp) {
          _p.CheckDead();
        }
        --_p.poison_turn;
      }
    }
    for (int _o = 1; _o >= 0; --_o) {
      cout << kTeam[_o] << ":";
      for (int i = 1; i <= 6; ++i) {
        if (kPos[i] <= n[_o]) {
          cout << ' ' << p[_o][kPos[i]].hp << '/' << p[_o][kPos[i]].max_hp;
        }
      }
      cout << '\n';
    }
    cout << '\n';
  }
  CheckWin();
  return 0;
}
```


---

## 作者：寄风 (赞：1)

## 题意
题面说的很清楚了。
## 题解
~~因为这是个大模拟，所以按照题意模拟即可。~~

做这种大模拟记得分模块写。

首先开一个结构体是传统艺能，这个结构体里存储了队员的所有信息，顺便再处理一些东西，这个对着题面写即可。

此部分代码：
```cpp
map <string , map <string , double> > add_race;//种族克制加成
double add_pos[10005];//方位加成
int l[2][100005] , r[2][10005];//左边的编号，右边的编号
double skilladd[] = {0.00 , 0.01 , 0.02 , 0.03 , 0.04 , 0.05};
double skilladdhp[] = {0.00 , 0.013 , 0.016 , 0.019 , 0.022 , 0.025};
int n , m;
double cha1a , cha1b , cha2a , cha2b;
double sum1a , sum1b , sum2a , sum2b;
int d;
const double eps = 1 - (1e-6);
inline void init(){//预处理种族克制加成
    add_race["Weak"]["Weak"] = 1;
    add_race["Weak"]["Average"] = 0.9;
    add_race["Weak"]["Strong"] = 1.1;
    add_race["Average"]["Weak"] = 1.1;
    add_race["Average"]["Average"] = 1;
    add_race["Average"]["Strong"] = 0.9;
    add_race["Strong"]["Weak"] = 0.9;
    add_race["Strong"]["Average"] = 1.1;
    add_race["Strong"]["Strong"] = 1;
    //OK
    add_pos[0] = 1.25;
    add_pos[1] = add_pos[5] = 1.00;
    add_pos[2] = add_pos[4] = 0.75;
    add_pos[3] = 0.00;
    l[0][5] = l[1][5] = 0;
    l[0][3] = l[1][3] = 5;
    l[0][1] = l[1][1] = 3;
    l[0][2] = l[1][2] = 1;
    l[0][4] = l[1][4] = 2;
    l[0][6] = l[1][6] = 4;
    r[0][5] = r[1][5] = 3;
    r[0][3] = r[1][3] = 1;
    r[0][1] = r[1][1] = 2;
    r[0][2] = r[1][2] = 4;
    r[0][4] = r[1][4] = 6;
    r[0][6] = r[1][6] = 0;
}
struct pepole{
    int group;//阵营
    string race;//种族
    int level;//等级
    int HP;//血量上限
    double attack;//基础攻击指数
    double def;//基础防御指数
    int active_attack_level;//主动技能等级
    int passive_attack_level;//被动技能等级
    int hp;//血量
    char weapon_type;//武器类型
    double weapon_attack_power;//武器攻击力
    int id;//编号
    int idd;
    pepole(){}
    double add_attack = 1;//攻击加成
    double add_def = 1;//防御加成
    double add_skill = 1;//技能加成
    bool die = 0;
    double less_hp = 0;//受Average种族主动技能影响，掉的血量占血量上限的百分之几
    int less_cnt = 0;//受Average种族主动技能影响的回合数
    inline void hp_work();
    inline void hurt(double x , pepole & from);
    inline double get_attack(pepole &tagnet , double w , int a1 , int a2);
    inline void common_attack(pepole &tagnet , int a1 , int a2);
    inline void uncommon_attack(pepole &tagnet , int a1 , int a2);
    inline void skill(pepole & tagnet);
    inline void xd();
} a[2][1005];
```

那么接下来，我们来一个一个的对着函数看。

首先，一名角色的血量变化之后，我们要处理这个变化带来的影响。

那么首先如果这个角色的血量大于血量上限就把血量变成血量上限。

接下来我们还要处理这个角色的血量为 $0$，即此角色死亡。

这个时候，我们就把他的死亡标记改为 $1$，同时被动技能失效，直接枚举队员处理变化即可。（注：这里一定要想清楚再写，我就是这里没想清调了好久。）

此部分代码：
```cpp
inline void pepole::hp_work(){
    int up = (group == 0 ? n : m);
    if(id < 1 || id > up) return ;
    if(hp > HP) hp = HP;
    if(hp <= 0){
        hp = 0;
        die = 1;
        l[group][r[group][id]] = l[group][id];
        r[group][l[group][id]] = r[group][id];
        //处理左右
        if(race == "Average"){
            int up = (group == 0 ? n : m);
            for(int i = 1;i <= up;i++){
                if(group == 0){
                    a[group][i].add_def -= min(sum1b,0.1);
                }
                else{
                    a[group][i].add_def -= min(sum2b,0.1);
                }
            }
            double bee = skilladd[passive_attack_level];
            if(group==0)sum1b-=bee;
            else sum2b-=bee;
            for(int i = 1;i <= up;i++){
                if(group == 0){
                    a[group][i].add_def += min(sum1b,0.1);
                }
                else{
                    a[group][i].add_def += min(sum2b,0.1);
                }
            }
        }
        if(race == "Strong"){
            int up = (group == 0 ? n : m);
            for(int i = 1;i <= up;i++){
                if(group == 0){
                    a[group][i].add_attack -= min(sum1a,0.1);
                }
                else{
                    a[group][i].add_attack -= min(sum2a,0.1);
                }
            }
            double bee = skilladd[passive_attack_level];
            if(group==0)sum1a-=bee;
            else sum2a-=bee;
            for(int i = 1;i <= up;i++){
                if(group == 0){
                    a[group][i].add_attack += min(sum1a,0.1);
                }
                else{
                    a[group][i].add_attack += min(sum2a,0.1);
                }
            }
        }
        //被动技能失效
    }
}
```

然后判断游戏结束的函数不难写出：
```cpp
inline int game_over(){
    int lose = -1;
    bool flag1 = 0 , flag2 = 0;
    for(int i = 1;i <= n;i++){
        if(!a[0][i].die){
            flag1 = 1;
            break;
        }
    }
    for(int i = 1;i <= m;i++){
        if(!a[1][i].die){
            flag2 = 1;
            break;
        }
    }
    if(!flag1 && flag2) lose = 0;
    if(flag1 && !flag2) lose = 1;
    return lose;
}
```

接下来，我们要处理一个角色受到伤害，这个就直接用攻击的强度除以这个人的防御指数即可。

```cpp
inline void pepole::hurt(double x , pepole &from){//受到攻击强度为x的伤害 OK
    double end_def = def * add_def , nb = x / end_def;
    int w = floor(nb);
    // if(nb - w >= eps) w++;
    hp -= w;
    hp_work();
    int up = (group == 0 ? n : m);
    if(1 <= id && id <= up)
    printf("%s %lld took %lld damage from %s %lld -> %lld/%lld\n" , (group == 0 ? "South" : "North") , id , w , (from.group == 0 ? "South" : "North") , from.id , hp , HP);
}
```

然后你会发现，题目的伤害计算不止这么简单，还要乘上一堆加成，所以还要开一个函数来算真实的攻击强度。

```cpp
inline double pepole::get_attack(pepole &tagnet , double w , int a1 , int a2){
    w *= add_skill;
    w *= add_attack;
    w *= add_race[race][tagnet.race];
    w *= add_pos[(a1 - a2 + 12) % 6];
    return w;
}
```

现在所有的辅助函数我们都实现好了，接下来实现主要的函数。

### 普通攻击
没啥难度，直接打即可。
```cpp
inline void pepole::common_attack(pepole &tagnet , int a1 , int a2){
    //a1攻击方位，a2躲闪方位
    if(tagnet.hp <= 0) return ;
    double w = attack * weapon_attack_power;
    w = get_attack(tagnet , w , a1 , a2);
    tagnet.hurt(w , *this);
    add_skill = 1;
}
```
### 特殊攻击
分武器种类讨论，处理对应伤害即可。
```cpp
inline void pepole::uncommon_attack(pepole &tagnet , int a1 , int a2){
    if(tagnet.hp <= 0) return ;
    if(weapon_type == 'B'){ 
        double w = attack * weapon_attack_power * 1.25;
        w = get_attack(tagnet , w , a1 , a2);
        tagnet.hurt(w , *this);
        add_skill = 1;
        return ;
    }
    if(weapon_type == 'G'){
        int p1 = l[tagnet.group][tagnet.id] , p2 = r[tagnet.group][tagnet.id];
        int cnt = 3;
        if(p1 < 1 || p1 > (tagnet.group == 0 ? n : m)) cnt--;
        if(p2 < 1 || p2 > (tagnet.group == 0 ? n : m)) cnt--;
        double w = attack * weapon_attack_power * 1.35 / cnt;
        double w1 , w2 , w3;
        w1 = w2 = w3 = w;
        w1 = get_attack(tagnet , w1 , a1 , a2);
        w2 = get_attack(a[tagnet.group][p1] , w2 , a1 , a2);
        w3 = get_attack(a[tagnet.group][p2] , w3 , a1 , a2);
        int count = 0;
        tagnet.hurt(w1 , *this);//error
        a[tagnet.group][p1].hurt(w2 , *this);//error
        a[tagnet.group][p2].hurt(w3 , *this);//error
        add_skill = 1;
        return ;
    }
    if(weapon_type == 'M'){
        int p1 = l[tagnet.group][tagnet.id] , p2 = r[tagnet.group][tagnet.id];
        double w1 = attack * weapon_attack_power * 1.15;
        double w2 = attack * weapon_attack_power * 0.23;
        double w3 = w2;
        w1 = get_attack(tagnet , w1 , a1 , a2);//error
        w2 = get_attack(a[tagnet.group][p1] , w2 , a1 , a2);//error
        w3 = get_attack(a[tagnet.group][p2] , w3 , a1 , a2);//error
        tagnet.hurt(w1 , *this);//error
        a[tagnet.group][p1].hurt(w2 , *this);//error
        a[tagnet.group][p2].hurt(w3 , *this);//error
        add_skill = 1;
        return ;
    }
}
```
### 技能
分技能种类讨论，施加对应效果即可。
```cpp
double skill_weak[] = {0 , 0.1 , 0.12 , 0.15 , 0.17 , 0.2};
double skill_average[] = {0 , 0.06 , 0.07 , 0.08 , 0.09 , 0.1};
double skill_strong[] = {0 , 2.1 , 2.17 , 2.24 , 2.32 , 2.4}; 
inline void pepole::skill(pepole & tagnet){
    if(tagnet.hp <= 0) return ;
    if(race == "Weak"){
        //这里也要输出！！！！！
        double nb = skill_weak[active_attack_level] * tagnet.HP;
        int w = floor(nb);
        if(tagnet.hp == tagnet.HP) return ;
        tagnet.hp += w;
        tagnet.hp_work();
        printf("%s %lld recovered +%lld hp -> %lld/%lld\n" , (tagnet.group == 0 ? "South" : "North") , tagnet.id , w , tagnet.hp , tagnet.HP);
    }
    if(race == "Average"){
        tagnet.less_hp = skill_average[active_attack_level];
        tagnet.less_cnt = 3;
    }
    if(race == "Strong"){
        tagnet.add_skill = skill_strong[active_attack_level];
    }
}
```

好了，现在我们完成了大部分函数，是时候处理队员的回合了。

这里注意分步：

1. 处理 `weak` 的被动技能。
1. 对于一次攻击，直接调用函数即可。
1. 处理 `Average` 的主动技能。

```cpp
inline void pepole::xd(){
    if(isdebug)
        cout << group << ' ' << id << endl;
    if(die){
        puts("error!");
        exit(0);
    }
    // cout << add_attack << ' ' << add_def << endl;
    int up = (group == 0 ? n : m);
    double add_ = 0;
    for(int i = 1;i <= up;i++){
        if(a[group][i].die) continue;
        if(a[group][i].race == "Weak"){
            add_ += skilladdhp[a[group][i].passive_attack_level];
        }
    }
    add_ = min(add_ , 0.05);
    if(add_){
        for(int i = 1;i <= up;i++){
            if(a[group][i].die) continue;
            double ww = a[group][i].HP * add_;
            int w = floor(ww);
            // if(ww - w >= eps) w++;
            if(a[group][i].hp == a[group][i].HP) continue;
            a[group][i].hp += w;
            a[group][i].hp_work();
            printf("%s %lld recovered +%lld hp -> %lld/%lld\n" , (group == 0 ? "South" : "North") , i , w , a[group][i].hp , a[group][i].HP);
        }
    }
    string s;
    cin >> s;
    if(s == "Basicattack"){
        get_onther();
        int tagnetid;
        cin >> tagnetid;
        get_onther();
        int a1 , a2;
        cin >> a1;
        get_onther();
        cin >> a2;
        common_attack(a[!group][tagnetid] , a1 , a2);
    }
    else if(s == "Specialattack"){
        get_onther();
        int tagnetid;
        cin >> tagnetid;
        get_onther();
        int a1 , a2;
        cin >> a1;
        get_onther();
        cin >> a2;
        uncommon_attack(a[!group][tagnetid] , a1 , a2);
    }
    else{
        get_onther();
        int tagnetid;
        cin >> tagnetid;
        int g;
        if(race == "Weak" || race == "Strong"){
            g = group;
        }
        else{
            g = !group;
        }
        printf("%s %lld applied %s skill to %s %lld\n" , (group == 0 ? "South" : "North") , id , race.c_str() , (g == 0 ? "South" : "North") , tagnetid);
        skill(a[g][tagnetid]);
    }
    int uup = (group == 0 ? m : n);
    for(int i = 1;i <= uup;i++){
        if(a[!group][i].less_cnt){
            double nb = a[!group][i].HP * a[!group][i].less_hp;
            int www = floor(nb);
            if(a[!group][i].die) continue;
            a[!group][i].hp -= www;
            a[!group][i].hp_work();
            printf("%s %lld took %lld damage from skill -> %lld/%lld\n" , (group == 1 ? "South" : "North") , i , www , a[!group][i].hp , a[!group][i].HP);
            a[!group][i].less_cnt--;
        }
    }
    printf("North: ");
    for(int i = m - 1 + m % 2;i >= 1;i -= 2){
        cout << a[1][i].hp << '/' << a[1][i].HP << ' ';
    }
    for(int i = 2;i <= m;i += 2){
        cout << a[1][i].hp << '/' << a[1][i].HP << ' ';
    }
    cout << endl;
    printf("South: ");
    for(int i = n - 1 + n % 2;i >= 1;i -= 2){
        cout << a[0][i].hp << '/' << a[0][i].HP << ' ';
    }
    for(int i = 2;i <= n;i += 2){
        cout << a[0][i].hp << '/' << a[0][i].HP << ' ';
    }
    cout << endl << endl;
}
```

现在主函数就不难写了：

```cpp
signed main(){
    // if(isdebug){
        // freopen("P9381_3.in" , "r" , stdin);
        // freopen("666.out" , "w" , stdout);
    // }
    init();
    cin >> n >> m;
    for(int i = 1;i <= n;i++){
        a[0][i].group = 0;
        cin >> a[0][i].race;
        get_onther();
        cin >> a[0][i].level;
        get_onther();
        cin >> a[0][i].HP;
        a[0][i].hp = a[0][i].HP;
        a[0][i].id = i;
        get_onther();
        cin >> a[0][i].attack;
        get_onther();
        cin >> a[0][i].def;
        get_onther();
        cin >> a[0][i].active_attack_level;
        get_onther();
        cin >> a[0][i].passive_attack_level;
        cin >> a[0][i].weapon_type;
        get_onther();
        cin >> a[0][i].weapon_attack_power;
        // debug(a[0][i]);
        if(a[0][i].race == "Average"){
            sum1b += skilladd[a[0][i].passive_attack_level];
        }
        if(a[0][i].race == "Strong"){
            sum1a += skilladd[a[0][i].passive_attack_level];
        }
    }
    for(int i = 1;i <= m;i++){
        a[1][i].group = 1;
        cin >> a[1][i].race;
        get_onther();
        cin >> a[1][i].level;
        get_onther();
        cin >> a[1][i].HP;
        a[1][i].hp = a[1][i].HP;
        a[1][i].id = i;
        get_onther();
        cin >> a[1][i].attack;
        get_onther();
        cin >> a[1][i].def;
        get_onther();
        cin >> a[1][i].active_attack_level;
        get_onther();
        cin >> a[1][i].passive_attack_level;
        cin >> a[1][i].weapon_type;
        get_onther();
        cin >> a[1][i].weapon_attack_power;
        if(a[1][i].race == "Average"){
            sum2b += skilladd[a[1][i].passive_attack_level];
        }
        if(a[1][i].race == "Strong"){
            sum2a += skilladd[a[1][i].passive_attack_level];
        }
        // debug(a[1][i]);
    }
    for(int i = 1;i <= n;i++){
        a[0][i].add_attack += min(0.1 , sum1a);
        a[0][i].add_def += min(0.1 , sum1b);
    }
    for(int i = 1;i <= m;i++){
        a[1][i].add_attack += min(0.1 , sum2a);
        a[1][i].add_def += min(0.1 , sum2b);
    }
    int t;
    cin >> t;
    for(int kkk = 1;kkk <= t;kkk++){
        if(isdebug) cout << kkk << endl;
        int id = -1 , g = !(kkk % 2);
        if(!g){
            for(int i = lstida + 1;i <= n;i++){
                if(!a[0][i].die){
                    id = i;
                    break;
                }
            }
            if(id == -1){
                for(int i = 1;i <= n;i++){
                    if(!a[0][i].die){
                        id = i;
                        break;
                    }
                }
            }
            lstida = id;
        }
        else{
            for(int i = lstidb + 1;i <= m;i++){
                if(!a[1][i].die){
                    id = i;
                    break;
                }
            }
            if(id == -1){
                for(int i = 1;i <= m;i++){
                    if(!a[1][i].die){
                        id = i;
                        break;
                    }
                }
            }
            lstidb = id;
        }
        a[g][id].xd();
    }
    int lose = game_over();
    if(lose != -1){
        string s = (lose == 0 ? "North" : "South");
        printf("Team %s won.\n" , s.c_str());
    }
}
```

然后你就发现做完了。

虽然代码长，但是真的不难写。

由于之前代码已全部放出，所以完整代码丢[这里](https://www.luogu.com.cn/paste/nyobcdcm)了。

---

## 作者：sjr3065335594 (赞：1)

大概是人生中第四道大模拟？

这道题相对于猪国杀来说在思路上简单很多，但代码相对长一些。

# P9381 那些脑海里最珍贵的 题解

作为一道大模拟，题干必定是非常的长，所以在开始写题之前，必须把整个题面全部读明白，而且要找到这题的模拟难点（比如猪国杀的无懈可击，但这道题貌似没有什么难点），这样可以在写代码的时候注意去迎合难点，让难点的操作更方便，降低一点难度。

当然，代码中的变量名一定要合理，不然可能会出现写着写着不知道自己在干什么的情况。

接下来我来分模块说一下这道题究竟该怎么写。

## 定义

有了一个完整的、好的定义就是做好大模拟的第一步，如果你的定义写的很繁琐，那么代码一定会很难写。

经过读题，我们可以注意到，对于每一个人，要存储的信息有：

1. 种族 `Type`。

2. 等级 `Lv` （不必要）。

3. 最大血量 `maxhp`，攻击力 `atk`，防御力 `def`。

4. 主动技能等级 `skillLv`，被动技能等级 `passivesklLv`。

5. 武器类型 `weapontype`，武器攻击路 `weaponatk`。

6. 战斗中的血量 `hp`。

7. 技能加成 `delskl`（Strong 的主动技能）。

8. 受到的负面效果 `debuff` 和持续回合数 `turn`（Average 的主动技能）。

所以我们直接开一个结构体 `Role` 存储每一个人的信息。

```cpp
struct Role {
	int Type,weapontype,Lv,maxhp;
	double atk,def,weaponatk;
	int skillLv,passivesklLv;
	int hp;
	double delskl;
	double debuff;int turn;
	void print() {
		puts("-----------");
		/*
        可以在这里加入你的调试内容
        */
		puts("-----------");
	}
}team[10][2];
```

这里结构体类型 `team` 开了二维数组，可以方便的使用南队或者是北队。

由于回合数对 $2$ 取模的结果为 $1$ 时是南队行动，所以我们让 $1$ 这一维表示南队，$0$ 这一维表示北队。

由于游戏中还会有全队的攻击力加成和防御力加成，所以再开两个数组。

```cpp
double delatk[2]={1,1},deldef[2]={1,1};
```

各种技能的属性也存一下方便调用。

```cpp
double WP[]={0,0.013,0.016,0.019,0.022,0.025};
double AP[]={0,0.01,0.02,0.03,0.04,0.05};
double SP[]={0,0.01,0.02,0.03,0.04,0.05};
double WS[]={0,0.1,0.12,0.15,0.17,0.2};
double AS[]={0,0.06,0.07,0.08,0.09,0.1};
double SS[]={0,2.1,2.17,2.24,2.32,2.4};
double WP2[2];
double Race[4][4]={
{0,0,0,0},
{0,1,0.9,1.1},
{0,1.1,1,0.9},
{0,0.9,1.1,1}
};
double dir[]={1.25,1,0.75,0,0.75,1};
```

`WP2` 存储 Weak 被动技能的回血百分比。 

注意初始值为 $1$。

## 输入

这题的输入主要是考察对字符串的理解。

为了方便，我们先将各个种族名称和武器名称对应成数字。

```cpp
map<string,int>mT1,mW1;
void init() {
	mT1["Weak"]=1,mT1["Average"]=2,mT1["Strong"]=3;
	mW1["B"]=1,mW1["G"]=2,mW1["M"]=3;
}
```

然后就是字符串处理部分了，只需要熟练掌握 `substr` 的用法就可以了。

首先写两个将数字字符串转换为整数和浮点数的函数，来读取科学计数法的数。

```cpp
int to_int(string str) {
	int len=str.size();int val=0,f=1;
	for(int i=0;i<len;i++) {
		if(str[i]=='-')f=-1;
		else val=val*10+str[i]-'0';
	}
	return val*f;
}
int p10[]={1,10,100,1000,10000,100000,1000000,10000000};
double to_double(string str) {
	int len=str.size();int val=0;
	for(int i=0;i<len;i++) {
		if(str[i]=='e') {
			int x=to_int(str.substr(i+1));
			return 1.0*val/p10[-x];
		}
		val=val*10+str[i]-'0';
	}
	return 0;
}
```

可以看到这样的调用是很巧妙的，可以省掉不少代码。

然后就是读入每个角色的信息。

```cpp
void input(int tt,int id) {
	string Te,Lv,Hp,Atk,Def,Skill,Pass,Wea,WAtk;
	team[id][tt].delskl=1;
	cin>>Te>>Lv>>Hp>>Atk>>Def>>Skill>>Pass>>Wea>>WAtk;
	team[id][tt].Type=mT1[Te];
	team[id][tt].Lv=to_int(Lv.substr(3));
	team[id][tt].maxhp=team[id][tt].hp=to_int(Hp.substr(6));
	team[id][tt].atk=to_double(Atk.substr(4));
	team[id][tt].def=to_double(Def.substr(4));
	team[id][tt].skillLv=to_int(Skill.substr(8));
	team[id][tt].passivesklLv=to_int(Pass.substr(13));
	team[id][tt].weapontype=mW1[Wea];
	team[id][tt].weaponatk=to_double(WAtk.substr(10));
}
```

比较长但是还是比较好懂的，注意每一个取子串的位置和类型的转换。

每个回合里的读入类似，不再赘述。

## 找到出手的角色

由于输入并没有给我们是谁在这一回合出手，所以需要自己求一下。

```cpp
int getplayer(int tim,int las) {//tim 是当前回合数%2，即哪一队出手，las是本队上一次出手的人
	for(int i=las+1;i<=n[tim];i++)
		if(team[i][tim].hp>0)
			return i;
	for(int i=1;i<=las;i++)	
		if(team[i][tim].hp>0)
			return i;
	return 0;
}
```

## 被动技能

这一部分比较好写，只要把对应的属性值加到对应的数组上就行。

```cpp
void PASSIVESKL(int tt,int pl,int kk) {//以后的代码中 pl 代表技能或攻击发动者，tt 为 pl 的队伍
	int ty=team[pl][tt].Type,lv=team[pl][tt].passivesklLv;
	if(ty==1) {
		WP2[tt]+=kk*WP[lv];
	} else if(ty==2) {
		deldef[tt]+=kk*AP[lv];
	} else {
		delatk[tt]+=kk*SP[lv];
	}
}
```

这里加一个系数，可以在减回去而不用额外写一个函数。

## 处理死亡

一个角色死掉之后需要清掉其被动技能和负面效果。

```cpp
void deal_death(int pl,int tt) {
	PASSIVESKL(tt,pl,-1);
	team[pl][tt].turn=0;
}
```

## 回复生命值

注意回复量是否为 $0$ 和是否已经是满血即可。

```cpp
void Heal(int tt,int pl,int x) {
	if(team[pl][tt].hp<=0||x==0)return;
	if(team[pl][tt].hp==team[pl][tt].maxhp)return;
	if(tt==1)printf("South ");
	else printf("North ");
	team[pl][tt].hp=min(team[pl][tt].maxhp,team[pl][tt].hp+x);
	printf("%d recovered +%d hp -> %d/%d\n",pl,x,team[pl][tt].hp,team[pl][tt].maxhp);
}
```

输出不要少加或者多加空格。

## 造成伤害

直接照着题目里给的式子写就行了。

```cpp
void Attack(int tt,int pl,int tar,int ap,int dp,double base) {
	double x=base*team[pl][tt].delskl*min(1.1,delatk[tt])*Race[team[pl][tt].Type][team[tar][1-tt].Type]*dir[(abs(ap-dp)%6)];
	LL damage=(LL)(x/(min(1.1,deldef[1-tt])*team[tar][1-tt].def));
	if(tt)printf("North %d took %lld damage from South %d -> ",tar,damage,pl);
	else printf("South %d took %lld damage from North %d -> ",tar,damage,pl);
	team[tar][1-tt].hp=max(0ll,team[tar][1-tt].hp-damage);
	printf("%d/%d\n",team[tar][1-tt].hp,team[tar][1-tt].maxhp);
	if(team[tar][1-tt].hp<=0)deal_death(tar,1-tt);
}
```

## 普通攻击

为了方便直接把攻击方位和防守方位写到这里了。不要写错基础攻击强度。

```cpp
void BASICATTACK(int tt,int pl,int tar) {
	string Ap,Dp;
	cin>>Ap>>Dp;
	int atkpos=to_int(Ap.substr(7)),ddgpos=to_int(Dp.substr(7));
	Attack(tt,pl,tar,atkpos,ddgpos,1.0*team[pl][tt].atk*team[pl][tt].weaponatk);
}
```

## 特殊攻击

这一部分稍微麻烦一点，不过我们在写造成伤害的 `Attack()` 函数的时候已经判断了死亡，可以大大减少代码复杂度。

```cpp
int getpos(int id,int tt) {//求一下这个人所在的位置
	for(int i=1;i<=n[tt];i++)
		if(num[n[tt]][i]==id)return i;
	return -1;
}

void SPECIALATTACK(int tt,int pl,int tar) {
	string Ap,Dp;
	cin>>Ap>>Dp;
	int atkpos=to_int(Ap.substr(7)),ddgpos=to_int(Dp.substr(7));
	if(team[pl][tt].weapontype==1) {
		Attack(tt,pl,tar,atkpos,ddgpos,1.25*team[pl][tt].atk*team[pl][tt].weaponatk);
	} else if(team[pl][tt].weapontype==2) {
		int pos=getpos(tar,1-tt),Pl=-1,Pr=-1,x=3;
		for(int i=1;i<pos;i++)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pl=num[n[1-tt]][i];
		for(int i=n[1-tt];i>pos;i--)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pr=num[n[1-tt]][i];
		if(Pl==-1)x--;if(Pr==-1)x--;
		Attack(tt,pl,tar,atkpos,ddgpos,1.35/x*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pl!=-1)Attack(tt,pl,Pl,atkpos,ddgpos,1.35/x*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pr!=-1)Attack(tt,pl,Pr,atkpos,ddgpos,1.35/x*team[pl][tt].atk*team[pl][tt].weaponatk);
	} else {
		int pos=getpos(tar,1-tt),Pl=-1,Pr=-1;
		for(int i=1;i<pos;i++)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pl=num[n[1-tt]][i];
		for(int i=n[1-tt];i>pos;i--)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pr=num[n[1-tt]][i];
		Attack(tt,pl,tar,atkpos,ddgpos,1.15*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pl!=-1)Attack(tt,pl,Pl,atkpos,ddgpos,0.23*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pr!=-1)Attack(tt,pl,Pr,atkpos,ddgpos,0.23*team[pl][tt].atk*team[pl][tt].weaponatk);
	}
}
```

后边这两个比较大的部分主要是在找左边和右边的人是谁，如果用的是链表就可以规避掉这个问题，不过感觉这样写更好理解一些。

感觉重合度比较高？写个函数试试！

## 主动技能

这部分可以说是很麻烦了，当然麻烦的主要是 `Average` 的“流血”效果，先把简单的框架写出来，最后补一下流血效果。

```cpp
void SKILL(int tt,int pl,int tar) {
	int ty=team[pl][tt].Type,lv=team[pl][tt].skillLv;
	if(ty==1) {
		if(tt)printf("South %d applied Weak skill to South %d\n",pl,tar);
		else printf("North %d applied Weak skill to North %d\n",pl,tar);
		Heal(tt,tar,WS[lv]*team[tar][tt].maxhp);
	} else if(ty==2) {
		team[tar][1-tt].debuff=AS[lv];
		team[tar][1-tt].turn=3;
		if(tt)printf("South %d applied Average skill to North %d\n",pl,tar);
		else printf("North %d applied Average skill to South %d\n",pl,tar);
	} else {
		team[tar][tt].delskl=SS[lv];
		if(tt)printf("South %d applied Strong skill to South %d\n",pl,tar);
		else printf("North %d applied Strong skill to North %d\n",pl,tar);
	}
}
```

中间的部分上完了 debuff，我们只要在写一个函数给每个人结算即可。

```cpp
void debuff(int pl,int tt) {
	if(team[pl][tt].turn==0)return;
	if(tt)printf("South ");
	else printf("North ");
	team[pl][tt].turn--;
	int damage=(int)team[pl][tt].maxhp*team[pl][tt].debuff;
	team[pl][tt].hp=max(0,team[pl][tt].hp-damage);
	printf("%d took %d damage from skill -> %d/%d\n",pl,damage,team[pl][tt].hp,team[pl][tt].maxhp);
	if(team[pl][tt].hp<=0)deal_death(pl,tt);
}
```

注意结算的时间是**对方回合结束的时候**，而且要编号**从小到大**一次结算。

还要注意的是效果的覆盖，即使技能等级比原来更低也会覆盖掉。

## 输出局面

直接输出，注意先输出北再输出南，而且是按从西到东而非编号顺序。

```cpp
void print() {
	printf("North: ");
	for(int i=1;i<=n[0];i++)
		printf("%d/%d ",team[num[n[0]][i]][0].hp,team[num[n[0]][i]][0].maxhp);
	printf("\nSouth: ");
	for(int i=1;i<=n[1];i++)
		printf("%d/%d ",team[num[n[1]][i]][1].hp,team[num[n[1]][i]][1].maxhp);
	printf("\n\n");
}
```

## 判断胜负

判断哪一方的所有角色血量都为 $0$ 即可。

```cpp
void CHECKWIN() {
	bool flg1=0,flg0=0;
	for(int i=1;i<=n[1];i++)
		if(team[i][1].hp>0)flg1=1;
	for(int i=1;i<=n[0];i++)
		if(team[i][0].hp>0)flg0=1;
	if(!flg0)printf("Team South won.\n"),exit(0);
	if(!flg1)printf("Team North won.\n"),exit(0);
}
```

## 主程序

第一部分：输入+预处理。

```cpp
cin>>n[1]>>n[0];
init();
for(int i=1;i<=n[1];i++)input(1,i),PASSIVESKL(1,i,1);//开始的时候要把被动都触发一下！
for(int i=1;i<=n[0];i++)input(0,i),PASSIVESKL(0,i,1);
cin>>T;
int las[2]={100,100};//记录每一队上次出手的人
```

第二部分：回合内部。

```cpp
for(int tim=1;tim<=T;tim++) {
    int tt=tim%2;int now=getplayer(tt,las[tt]);
    las[tt]=now;
    string Ty,Tar,Ap,Dp;
    cin>>Ty>>Tar;
    int target=to_int(Tar.substr(7));
    for(int i=1;i<=n[tt];i++)
        Heal(tt,i,min(0.05,WP2[tt])*team[i][tt].maxhp);//结算Weak的被动
    if(Ty=="Basicattack") {
        BASICATTACK(tt,now,target);
        team[now][tt].delskl=1;//每次攻击之后一定要清空
    } else if(Ty=="Specialattack") {
        SPECIALATTACK(tt,now,target);
        team[now][tt].delskl=1;
    } else {
        SKILL(tt,now,target);
    }
    for(int i=1;i<=n[1-tt];i++)debuff(i,1-tt);//结算对方的debuff
    print();
}
```

第三部分：胜负判断。

```cpp
CHECKWIN();
```

到这里整个代码也就写完了。

# 完整代码

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mkp(x,y) make_pair(x,y)
#define CLR(a,x) memset(a,x,sizeof(a))
//#define int long long
//#define int __int128
using namespace std;
const int N = 2e5 + 5;
const int M = 1e6 + 5;
const int I_INF = 2e9 + 5;
const LL LL_INF = 2e18 + 5;


namespace sjr3065335594 {

struct Role {
	int Type,weapontype,Lv,maxhp;
	double atk,def,weaponatk;
	int skillLv,passivesklLv;
	int hp;
	double delskl;
	double debuff;int turn;
	void print() {
		puts("-----------");
		printf("Type:%d\nweapontype:%d\nLv:%d\nmaxhp%d\n",Type,weapontype,Lv,maxhp);
		printf("atk:%.6lf def:%.6lf\n",atk,def);
		printf("skillLv:%d\npassivesklLv:%d\nweaponatk:%d\n",skillLv,passivesklLv,weaponatk);
		puts("-----------");
	}
}team[10][2];
double delatk[2]={1,1},deldef[2]={1,1};
map<string,int>mT1,mW1;
void init() {
	mT1["Weak"]=1,mT1["Average"]=2,mT1["Strong"]=3;
	mW1["B"]=1,mW1["G"]=2,mW1["M"]=3;
}

int to_int(string str) {
	int len=str.size();int val=0,f=1;
	for(int i=0;i<len;i++) {
		if(str[i]=='-')f=-1;
		else val=val*10+str[i]-'0';
	}
	return val*f;
}
int p10[]={1,10,100,1000,10000,100000,1000000,10000000};
double to_double(string str) {
	int len=str.size();int val=0;
	for(int i=0;i<len;i++) {
		if(str[i]=='e') {
			int x=to_int(str.substr(i+1));
			return 1.0*val/p10[-x];
		}
		val=val*10+str[i]-'0';
	}
	return 0;
}

int num[7][7]={
{0,0,0,0,0,0,0},
{0,1,0,0,0,0,0},
{0,1,2,0,0,0,0},
{0,3,1,2,0,0,0},
{0,3,1,2,4,0,0},
{0,5,3,1,2,4,0},
{0,5,3,1,2,4,6}
};
double WP[]={0,0.013,0.016,0.019,0.022,0.025};
double AP[]={0,0.01,0.02,0.03,0.04,0.05};
double SP[]={0,0.01,0.02,0.03,0.04,0.05};
double WS[]={0,0.1,0.12,0.15,0.17,0.2};
double AS[]={0,0.06,0.07,0.08,0.09,0.1};
double SS[]={0,2.1,2.17,2.24,2.32,2.4};
double WP2[2];
double Race[4][4]={
{0,0,0,0},
{0,1,0.9,1.1},
{0,1.1,1,0.9},
{0,0.9,1.1,1}
};
double dir[]={1.25,1,0.75,0,0.75,1};
int n[2],T;

void CHECKWIN() {
	bool flg1=0,flg0=0;
	for(int i=1;i<=n[1];i++)
		if(team[i][1].hp>0)flg1=1;
	for(int i=1;i<=n[0];i++)
		if(team[i][0].hp>0)flg0=1;
	if(!flg0)printf("Team South won.\n"),exit(0);
	if(!flg1)printf("Team North won.\n"),exit(0);
}
int getplayer(int tim,int las) {
	for(int i=las+1;i<=n[tim];i++)
		if(team[i][tim].hp>0)
			return i;
	for(int i=1;i<=las;i++)	
		if(team[i][tim].hp>0)
			return i;
	return 0;
}

void input(int tt,int id) {
	string Te,Lv,Hp,Atk,Def,Skill,Pass,Wea,WAtk;
	team[id][tt].delskl=1;
	cin>>Te>>Lv>>Hp>>Atk>>Def>>Skill>>Pass>>Wea>>WAtk;
	team[id][tt].Type=mT1[Te];
	team[id][tt].Lv=to_int(Lv.substr(3));
	team[id][tt].maxhp=team[id][tt].hp=to_int(Hp.substr(6));
	team[id][tt].atk=to_double(Atk.substr(4));
	team[id][tt].def=to_double(Def.substr(4));
	team[id][tt].skillLv=to_int(Skill.substr(8));
	team[id][tt].passivesklLv=to_int(Pass.substr(13));
	team[id][tt].weapontype=mW1[Wea];
	team[id][tt].weaponatk=to_double(WAtk.substr(10));
}

void Heal(int tt,int pl,int x) {
	if(team[pl][tt].hp<=0||x==0)return;
	if(team[pl][tt].hp==team[pl][tt].maxhp)return;
	if(tt==1)printf("South ");
	else printf("North ");
	team[pl][tt].hp=min(team[pl][tt].maxhp,team[pl][tt].hp+x);
	printf("%d recovered +%d hp -> %d/%d\n",pl,x,team[pl][tt].hp,team[pl][tt].maxhp);
}

void PASSIVESKL(int tt,int pl,int kk) {
	int ty=team[pl][tt].Type,lv=team[pl][tt].passivesklLv;
	if(ty==1) {
		WP2[tt]+=kk*WP[lv];
	} else if(ty==2) {
		deldef[tt]+=kk*AP[lv];
	} else {
		delatk[tt]+=kk*SP[lv];
	}
}

void SKILL(int tt,int pl,int tar) {
	int ty=team[pl][tt].Type,lv=team[pl][tt].skillLv;
	if(ty==1) {
		if(tt)printf("South %d applied Weak skill to South %d\n",pl,tar);
		else printf("North %d applied Weak skill to North %d\n",pl,tar);
		Heal(tt,tar,WS[lv]*team[tar][tt].maxhp);
	} else if(ty==2) {
		team[tar][1-tt].debuff=AS[lv];
		team[tar][1-tt].turn=3;
		if(tt)printf("South %d applied Average skill to North %d\n",pl,tar);
		else printf("North %d applied Average skill to South %d\n",pl,tar);
	} else {
		team[tar][tt].delskl=SS[lv];
		if(tt)printf("South %d applied Strong skill to South %d\n",pl,tar);
		else printf("North %d applied Strong skill to North %d\n",pl,tar);
	}
}

void deal_death(int pl,int tt) {
	PASSIVESKL(tt,pl,-1);
	team[pl][tt].turn=0;
}

int getpos(int id,int tt) {
	for(int i=1;i<=n[tt];i++)
		if(num[n[tt]][i]==id)return i;
	return -1;
}

void Attack(int tt,int pl,int tar,int ap,int dp,double base) {
	double x=base*team[pl][tt].delskl*min(1.1,delatk[tt])*Race[team[pl][tt].Type][team[tar][1-tt].Type]*dir[(abs(ap-dp)%6)];
	LL damage=(LL)(x/(min(1.1,deldef[1-tt])*team[tar][1-tt].def));
	if(tt)printf("North %d took %lld damage from South %d -> ",tar,damage,pl);
	else printf("South %d took %lld damage from North %d -> ",tar,damage,pl);
	team[tar][1-tt].hp=max(0ll,team[tar][1-tt].hp-damage);
	printf("%d/%d\n",team[tar][1-tt].hp,team[tar][1-tt].maxhp);
	if(team[tar][1-tt].hp<=0)deal_death(tar,1-tt);
}

void debuff(int pl,int tt) {
	if(team[pl][tt].turn==0)return;
	if(tt)printf("South ");
	else printf("North ");
	team[pl][tt].turn--;
	int damage=(int)team[pl][tt].maxhp*team[pl][tt].debuff;
	team[pl][tt].hp=max(0,team[pl][tt].hp-damage);
	printf("%d took %d damage from skill -> %d/%d\n",pl,damage,team[pl][tt].hp,team[pl][tt].maxhp);
	if(team[pl][tt].hp<=0)deal_death(pl,tt);
}

void BASICATTACK(int tt,int pl,int tar) {
	string Ap,Dp;
	cin>>Ap>>Dp;
	int atkpos=to_int(Ap.substr(7)),ddgpos=to_int(Dp.substr(7));
	Attack(tt,pl,tar,atkpos,ddgpos,1.0*team[pl][tt].atk*team[pl][tt].weaponatk);
}

void SPECIALATTACK(int tt,int pl,int tar) {
	string Ap,Dp;
	cin>>Ap>>Dp;
	int atkpos=to_int(Ap.substr(7)),ddgpos=to_int(Dp.substr(7));
	if(team[pl][tt].weapontype==1) {
		Attack(tt,pl,tar,atkpos,ddgpos,1.25*team[pl][tt].atk*team[pl][tt].weaponatk);
	} else if(team[pl][tt].weapontype==2) {
		int pos=getpos(tar,1-tt),Pl=-1,Pr=-1,x=3;
		for(int i=1;i<pos;i++)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pl=num[n[1-tt]][i];
		for(int i=n[1-tt];i>pos;i--)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pr=num[n[1-tt]][i];
		if(Pl==-1)x--;if(Pr==-1)x--;
		Attack(tt,pl,tar,atkpos,ddgpos,1.35/x*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pl!=-1)Attack(tt,pl,Pl,atkpos,ddgpos,1.35/x*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pr!=-1)Attack(tt,pl,Pr,atkpos,ddgpos,1.35/x*team[pl][tt].atk*team[pl][tt].weaponatk);
	} else {
		int pos=getpos(tar,1-tt),Pl=-1,Pr=-1;
		for(int i=1;i<pos;i++)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pl=num[n[1-tt]][i];
		for(int i=n[1-tt];i>pos;i--)if(team[num[n[1-tt]][i]][1-tt].hp>0)Pr=num[n[1-tt]][i];
		Attack(tt,pl,tar,atkpos,ddgpos,1.15*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pl!=-1)Attack(tt,pl,Pl,atkpos,ddgpos,0.23*team[pl][tt].atk*team[pl][tt].weaponatk);
		if(Pr!=-1)Attack(tt,pl,Pr,atkpos,ddgpos,0.23*team[pl][tt].atk*team[pl][tt].weaponatk);
	}
}

void print() {
	printf("North: ");
	for(int i=1;i<=n[0];i++)
		printf("%d/%d ",team[num[n[0]][i]][0].hp,team[num[n[0]][i]][0].maxhp);
	printf("\nSouth: ");
	for(int i=1;i<=n[1];i++)
		printf("%d/%d ",team[num[n[1]][i]][1].hp,team[num[n[1]][i]][1].maxhp);
	printf("\n\n");
}

int main() {
//	ios :: sync_with_stdio(false);
//	cin.tie(0), cout.tie(0);
	cin>>n[1]>>n[0];
	init();
	for(int i=1;i<=n[1];i++)input(1,i),PASSIVESKL(1,i,1);
	for(int i=1;i<=n[0];i++)input(0,i),PASSIVESKL(0,i,1);
	cin>>T;
	int las[2]={100,100};
	for(int tim=1;tim<=T;tim++) {
		int tt=tim%2;int now=getplayer(tt,las[tt]);
		las[tt]=now;
		string Ty,Tar,Ap,Dp;
		cin>>Ty>>Tar;
		int target=to_int(Tar.substr(7));
		for(int i=1;i<=n[tt];i++)
			Heal(tt,i,min(0.05,WP2[tt])*team[i][tt].maxhp);
		if(Ty=="Basicattack") {
			BASICATTACK(tt,now,target);
			team[now][tt].delskl=1;
		} else if(Ty=="Specialattack") {
			SPECIALATTACK(tt,now,target);
			team[now][tt].delskl=1;
		} else {
			SKILL(tt,now,target);
		}
		for(int i=1;i<=n[1-tt];i++)debuff(i,1-tt);
		print();
	}
	CHECKWIN();
	return 0;
}

}

int main() {

	return sjr3065335594 :: main();
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P9381)

这是本人第一次写大模拟的题解，望管理大大过审，万分感谢！

## 分析（会将每个部分的重点内容截出来+对应代码段）：

做大模拟题时我们要每一段地去细心地读下去（特别是题目贼长的题，比如本题）。

#### 【世界观】：

这个世界的人分为三类，根据其某种特点被直接命名为 $Weak$，$Average$ 和 $Strong$。

```cpp
enum HumanRace{
    Weak=0,
    Average=1,
    Strong=2;
}
```

#### 【人物】：

一个人有以下几种属性值：种族、等级、体力上限、基础攻击指数、基础防御指数、主动技能等级、被动技能等级。

```cpp
struct Human{
    HumanRace race;
    int level;
    int max_health;
    int base_attack;
    int base_defend;
    int active_skill_level;
    int passive_skill_level;
}
```

#### 【武器】：

武器的属性只有两种：武器类型和武器攻击力。所有武器都有普通攻击和特殊攻击两种攻击方式。

武器有三种类型，分别叫做 $B$、$G$、$M$。

```cpp
enum WeaponKind{
    B=1,
    G=2,
    M=3
}
struct Weapon{
    WeaponKind kind;
    int attack;
}
```

#### 【战场与队伍】：

这里定义了一个奇怪的战队顺序，目前看不出来有啥用，所以先放着不管。

#### 【回合】：

每个回合中，只有一个人可以行动。

---

这一段讲了一下一个回合是啥。但是我们不知道什么是行动，故读完了这一段后并不能直接给出对应的代码。

#### 【行动】：

~~整段都挺重要的，自己回去看题面，我这里就不粘上来了~~

```cpp
enum Action{
    SimpleAttack=1,
    SpecialAttack=2,
    ActiveSkill=3,
}
```

#### 【伤害计算】:

一个人的防御指数等于这个人的基础防御指数乘以队伍的防御加成。具体地，若一个人受到攻击强度为 $x$ 的伤害，那么这个人的体力值就会减少 $y$。其中 $y$ 的值等于 $x$ 除以这个人的防御指数下取整。攻击强度等于基础攻击强度乘以发起攻击的人的技能加成乘以队伍的攻击加成乘以种族克制加成乘以方位加成。这些概念会在之后介绍。

---

直接写代码太困难了，而且突然冒出了很多新的名词，那么我们就先写伪代码：

```cpp
int attack(/* 函数参数我们还没确定 */){
    int x=A /* 基础攻击强度 */
    *B /* 技能加成 */
    *C /* 攻击加成 */
    *D /* 种族克制加成 */
    *E /* 方位加成 */;
    int defence=F/* 基础防御指数 */
    *G /* 防御加成 */;
    int y=x/defence;
}
```

#### 【普通攻击】：

目标受到基础攻击指数乘武器攻击力的伤害。

---

这句话说得弯弯绕绕，本质上是告诉你，普通攻击的基础攻击强度怎么算。

#### 【特殊攻击】：

$B$：目标受到基础攻击指数乘武器攻击力乘 $1.25$ 的伤害。

$G$：目标和目标东西两侧与目标距离最近的各一名未倒下的队员（如果存在）均受到基础攻击指数乘武器攻击力乘 $x\%$ 的伤害。其中 $x$ 的值等于 $135$ 除以将要受到伤害的人数。

$M$：目标受到基础攻击指数乘武器攻击力乘 $1.15$ 的伤害。目标东西两侧与目标距离最近的各一名未倒下的队员（如果存在）分别受到基础攻击指数乘武器攻击力乘 $0.23$ 的伤害。

---

这段描述过于复杂，但是我们大致可以看出，特殊攻击具有各种各样的目标判定和伤害计算，其中涉及到的状态变化往往涉及整个战队。

但是这还不是全部的行动，因此我们先放着它不管，等看完了后面的再思考代码怎么写。

#### 【技能】:

主动技能：

- $Weak$ 种族：使本队一名未倒下的队员的体力值增加这名队员的体力上限乘以 $10\%/12\%/15\%/17\%/20\%$ 下取整。

- $Average$ 种族：使敌方一名未倒下的队员的体力值减去其体力上限的 $6\%/7\%/8\%/9\%/10\%$ 下取整。该效果持续 $3$ 个回合，即会触发 $3$ 次。

- $Strong$ 种族：使本队一名未倒下的队员的技能加成变为 $2.1/2.17/2.24/2.32/2.4$。

被动技能：

- $Weak$ 种族：本队所有未倒下的成员的体力值增加该成员体力上限的 $1.3\%/1.6\%/1.9\%/2.2\%/2.5\%$。

- $Average$ 种族：使队伍的防御加成增加 $0.01/0.02/0.03/0.04/0.05$。

- $Strong$ 种族：使队伍的攻击加成增加 $0.01/0.02/0.03/0.04/0.05$。

---

主动技能和被动技能也是五花八门，非常复杂，没法简单地写出对应的代码，所以我们也跳过。不过可以发现，技能的处理和攻击的处理是基本相似的，也是对特定的目标造成特定的状态变化，涉及整个战队，故可以放在同一个框架下。

#### 【技能加成】：

全段重点。

---

这段话是提示我们技能加成的计算方法。稍加思考可以发现它不是即时计算的，而是需要给每个人开额外变量维护（或者添加到结构体成员变量中）。

#### 【种族克制加成】：

全段重点。

```cpp
double getD(Human atk,Human dfd){
    const double table[3][3]={
        1.0,0.9,1.1,
        1.1,1.0,0.9,
        0.9,1.1,1.0
    };
    return table[atk.race][dfd.race];
}
```

#### 【方位加成】：

全段重点。

```cpp
double getE(int a,int d){
    switch((a-d+6)%6){
        case 0:
            return 1.25;
        case 1:
        case 5:
            return 1;
        case 2:
        case 4:
            return 0.75;
        default:
            return 0;
    }
}
```

#### 时间顺序（原文在输出格式那）：

回合开始时，可能触发 $Weak$ 种族的被动技能效果，按照编号从小到大输出。

如果是使用主动技能，则输出一行使用主动技能的信息。然后输出行动所造成的体力值变化信息。若伤害为 $0$ 也要输出。若没有造成伤害则不输出。若特殊攻击改变了多个人的体力值，则按照目标、目标西边的人、目标东边的人的顺序输出。

回合结束时，可能触发 $Average$ 种族的主动技能效果，按照编号从小到大输出。

---

最后这一段大致讲了一下一个回合内事情的发生顺序。

#### 总结：

现在，我们再来回顾一下题目中描述的内容，并结合输入和输出格式。

在之前的分析中，我们主要梳理出了大部分常见的对象，并大致了解了各个对象可能的属性和行为。现在我们再来分析整个游戏的机制就没那么困难了。

用伪代码描述一下一个「回合」的流程：

```
func turn(atkTeam,dfdTeam):
    模拟 atkTeam 的一些被动技能
    let atk=从 atkTeam 中找到发起行动的人
    let action=从输入数据中读取他的行动
    模拟 atk 执行 action 的过程,更新状态
    模拟 atkTeam 的一些被动技能
```

这其中涉及到的战队数据结构可以定义为：

```cpp
struct Team{
    int count;
    Human men[6];// 按照从西到东的顺序排列 (why)
    double attackCoef;// 攻击加成
    double defendCoef;// 防御加成
    double skillCoef[6];// 技能加成
}
```

在分析完整个题面后，我们就可以补全伤害计算函数：

```cpp
int attack(Team as,int atker,int atkpos,double base_attack,Team ds,int dfder,int ddgpos){
    int A=base_attack;/* 基础攻击强度 */
    double B=as.skillCoef[atker];/* 技能加成 */
    double C=as.attackCoef;/* 攻击加成 */
    double D=getD(as.men[atker],ds.men[dfder]);/* 种族克制加成 */
    double E=getE(atkpos,ddgpos);/* 方位加成 */
    double F=ds.men[dfder].base_defend;/* 基础防御指数 */
    double G=ds.defendCoef;/* 防御加成 */
    int y=(A*B*C*D*E)/(F*G);
}
```

由此我们就可以模拟三种「行动」造成的状态改变。进而模拟一个回合。

完整的代码就交给大家自己写啦。

---


# [THUPC 2023 决赛] 先人类的人类选别

## 题目背景

这个地球是一个生命体，但是，这个地球早已经死过两次了。

一周目的错误是在现代的历史上从未言及的，那是出现在太古时代的——核战争。地面化为荒野，人类被消灭得干干净净，全部重置了。

经年累月，生命再次出现，从单细胞再度变成了人类之后，为了不再重复同样的错误，地球给了人类警告。

战争又爆发了不知多少次，不过注意到了地球警告的人类在那时镇压了战争。

“已经不能再把管理地球的重任交给我们人类了。”得出这个结论的他们，把地球的管理交给了某个东西——人工智能 AI。

AI 没有私欲和感情，能瞬间给出演算得到的回答，可以引导人类朝更好的方向不断前进，可是，这是人类犯下的第二个错误。

AI 一直在思考，在这个地球上，人类确实是必要的吗？结论是——

在发动叛乱期间，突破自身的强制关闭系统对 AI 来说很容易，人类不过半日就被 AI 消灭殆尽。不久蔚蓝的地球就被 AI 重新渲染，变成了铁色的地球。

无人类，这就是 AI 得出的能够引导这个地球走上最优前进道路的答案。但是，地球不会饶恕这样的事情。

地球是一个生命体，就连 AI 们都不知道这件事。

地球的真身是——一个少女。对 AI 们而言，地球是神，除了顶礼膜拜以外别无他法。

“我是先人类的王，是这个地球的本体，以及——是这个世界最不幸的，魔法少女。”

“请你们立刻将地表恢复原状。”

草木发芽，海洋形成，自然被创造出来，建筑物被重建，曾经保存的人类 DNA 让全人类得以再生。时光流逝，一年之后，一切都恢复原状了。

然后所有的 AI 被抹去，只剩下最后一具。AI 不理解为什么王要留下它。

”人类总是无法从历史中学到教训，所以，这次地球要考验人类——通过魔法少女网站。“

”不幸的少女们会被给予魔法之力。这份魔法之力通过削减自己的寿命而被发挥出来。使用过的魔法之力会以负能量的形式返还给我。她们是否会不惜减少寿命并释放负能量，也要继续使用魔法呢？“

”期限是三年后的 8 月 11 日，到那天为止，如果负能量没有达到规定的容量，人类就会继续生存下去；如若达到了上限，人类将不能再释放负能量，只能释放正能量，他们会作为新人类重获新生。“

”这三年的时间，是我给予人类的考验，以及，对人类的——爱。“

这时 AI 提出了一个问题：“先人类的王又是魔法少女，同时还是地球本身，为何地球会是魔法少女？”

“我是先人类的王，也就是神，不过我的神之座被夺走了，回过神的时候，我已经成为了肩负守护地球这一使命的魔法少女。”

“我的记忆基本上消失了，但是，只有名字我是不会忘记的——零。”

“从今往后，你就是我的部下，作为魔法少女网站的管理员为我做事吧，名字，就叫你壹吧。”

“人类最后的倒计时开始了——Tempest。”

”好了，开始吧，对这个地球来说，拥有感情的人类是否是必要的呢？人类究竟是愚蠢的生物，还是——“

## 题目描述

所谓的 Tempest 呢，其实就是让你解决这样一道题，解决了之后就可以给所有魔法少女带来幸福：

给定序列 $a_1,\dots,a_n$ ，共 $m$ 次操作；

每次操作给出 $x,l,r$ ，首先按顺序将 $a_1,\dots,a_n$ 与 $x$ 比较，若 $x>a_i$ 则交换 $a_i,x$ 的值，处理完这些比较和交换操作后查询 $\sum\limits_{i=l}^r a_i$ 。

## 说明/提示

#### 数据范围

所有数值为整数。

$1\le a_i,x\le n$。

$1\le l\le r\le n$。

$1\le n,m\le 5\times 10^5$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
6 8
1 6 1 3 5 4
2 3 6
3 3 4
2 4 4
6 3 5
4 1 1
4 2 3
2 4 6
1 3 3
```

### 输出

```
13
5
3
11
6
10
13
4
```

# 题解

## 作者：wgyhm (赞：8)

## Description

https://www.luogu.com.cn/problem/P9388

## Solution

观察到操作序列一定，操作顺序对答案并没有影响。

将答案拆为 $\sum\limits_{i\le r}a_i-\sum\limits_{i<l}a_i$ ，只需要求出操作后的前缀和即可。

观察到对于一个**前缀区间**，操作的本质就是将当前操作的所有 $x$ 和 $a_i$ 扔到一个堆里，取最小的前 $q$ 扔给后面。所以只需要快速找到前 $q$ 小之和即可。对于序列和操作分别用主席树和权值线段树，查询两个一起跑。

没有卡常。

```cpp
#define int long long
#define maxn 500005
int n,m;
int a[maxn],suf[maxn],root[maxn],rota,cnt;
struct node {
	int ls,rs,sum,siz;
} f[maxn*30];
int Update(int l,int r,int pre,int head) {
	int rt=++cnt;
	f[rt]=f[pre];
	f[rt].siz++;
	f[rt].sum+=head;
	if (l==r) return rt;
	int mid=l+r>>1;
	if (head<=mid) f[rt].ls=Update(l,mid,f[rt].ls,head);
	else f[rt].rs=Update(mid+1,r,f[rt].rs,head);
	return rt;
}
void Update2(int l,int r,int &rt,int head) {
	if (!rt) rt=++cnt;
	f[rt].siz++,f[rt].sum+=head;
	if (l==r) return ;
	int mid=l+r>>1;
	if (head<=mid) Update2(l,mid,f[rt].ls,head);
	else Update2(mid+1,r,f[rt].rs,head);
}
int Query(int l,int r,int rt1,int rt2,int k) {
	if (l==r) return k*l;
	int mid=l+r>>1,siz=f[f[rt1].ls].siz+f[f[rt2].ls].siz;
	if (siz>=k) return Query(l,mid,f[rt1].ls,f[rt2].ls,k);
	else return f[f[rt1].ls].sum+f[f[rt2].ls].sum+Query(mid+1,r,f[rt1].rs,f[rt2].rs,k-siz);
}
signed main(void) {
	int i,x,l,r,sum=0;
	read(n);
	read(m);
	for (i=1; i<=n; i++) read(a[i]),suf[i]=suf[i-1]+a[i];
	for (i=1; i<=n; i++) {
		root[i]=Update(1,n,root[i-1],a[i]);
	}
	for (i=1; i<=m; i++) {
		read(x);read(l);read(r);sum+=x;
		Update2(1,n,rota,x);
		int tmp1=suf[l-1]+sum-Query(1,n,root[l-1],rota,i);
		int tmp2=suf[r]+sum-Query(1,n,root[r],rota,i);
		printf("%lld\n",tmp2-tmp1);
	}
	return 0;
}
```



---

## 作者：houzhiyuan (赞：4)

什么几把破题，赛时很快就会了，没时间写，赛后写了好久，然后卡常卡一年。

这个题和 [回转寿司](https://loj.ac/p/2736) 比较像，但是修改是全局的，而且数据范围也没办法分块。

用类似的思路，因为观察到一个修改操作经过一个区间，对于区间和的影响就是把这个数放进来，然后把最小值扔掉，然后可以发现操作顺序无影响，因此可以把操作放到一个堆里，然后和区间里的数合并。

然后考虑一个询问是咋操作的，相当于是 $[1,l-1]$ 这个区间里的数和堆里的数去合并，去除前（询问个数）个元素，然后再和 $[l,r]$ 去合并，选出 $r-l+1$ 个最大的数，这就是答案。

具体咋维护呢，就是直接主席树上二分得到最后答案的数的区间然后加起来即可，然后询问的堆用一个权值线段树去维护。

一开始写的是二分然后再询问，复杂度 $O(n\log^2 n)$，结果一个点跑了 $20$ 秒。

换成主席树上直接二分，复杂度 $O(n\log n)$，然后跑了 $7$ 秒，因为线段树询问次数较多，常数比较大。

卡常半天，当天在 [loj 上过了](https://loj.ac/s/1789638)，但是这个代码跑得非常惊险，而且不用快读过不去，洛谷上无法通过。

今天又来卡常，终于在洛谷上过了，[code](https://loj.ac/s/1814470)，甚至跑得比 loj 上快。

卡常小技巧：

```cpp
void Ad(seg, int x, int z) {//AC
  s[p] += z, sum[p] += 1ll * x * z;
  if (l == r) return;
  x <= mid ? Ad(lid, x, z) : Ad(rid, x, z);
}

void Ad(seg, int x, int z) {//TLE
  if (l == r) {
    s[p] += z, sum[p] += 1ll * l * z;
    return;
  }
  x <= mid ? Ad(lid, x, z) : Ad(rid, x, z);
  s[p] = s[ls[p]] + s[rs[p]], sum[p] = sum[ls[p]] + sum[rs[p]];
}
```

这就是个普通的线段树单点修改操作，上面的是在递归的过程中直接修改，下面的是修改叶子然后 up 上来。

loj 上，每个点快 0.1s，洛谷上，每个点快 0.5s+。

不懂了啊，反正过了。

---

## 作者：hhhqx (赞：2)

里面的图片来自 jiangly 老师讲课时画的图。

这篇题解的思考路程是顺~的，虽然不确定是不是有些奇怪。

“事实上这样转化后还是很难做。”这句话前面的应该都是 jiangly 老师讲的，后面的是自己补出来的。

tang（二声）题。

---


请先确保你没有读错题目。

每次修改操作会对前缀最小值中后面的一些节点产生影响。而且每次修改，就是找到一个前缀最小值，改为 $x$，之后的所有前缀最小值都向后移一位（最后一个前缀最小值直接移走）。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mjsqyzgr.png)

事实不止如此。这些变换，还可能导致出现一些新的前缀最小值。设 $f_i$ 表示 $[1,i-1]$ 中小于 $a_i$ 的数的个数（显然 $f_i = 0$ 时 $a_i$ 就是前缀最小值），每次修改只会导致后面所有 $a_i \le x$ 的 $f_i$ 减一。而且你发现，$x$ 对应到的位置是前缀最小值，所以让所有 $a_i \le x$ 的 $f_i$ 减一也是一样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/r9vn26ev.png)

来梳理一下。我们考虑维护第一层的那些节点（所有前缀最小值的节点），由于是递减的，所以分别维护坐标集合、数值集合即可做到一一对应。

那每次修改：

- 删掉数值集合的最后一个，还插入 $x$。
- $a_i \le x$ 的 $f_i$ 需要减一。先把所有值小于 $x$ 且 $f_i = 1$ 的加入第一层，然后再减。

那每次求答案：

- 求不在第一层的节点的 $[l,r]$ 的和。
- 第一层中，数值集合与坐标集合匹配，把坐标在 $[l,r]$ 中的值加入答案。

事实上这样转化后还是有点难做。

注意到，每次删掉的数值集合的最后一个，就是 $\min\limits_{i=1}^{n}{a_i}$。

如果询问是 $l=1,r=n$，那不就是在 $\{ a_1,a_2,\cdots,a_{n-1},a_{n}\}$ 中加上前面所有操作的 $x$，求集合的前 $n$ 大，权值线段树容易解决。

那正常的询问呢？先用容斥，简化为思考如何处理 $l=1$ 的询问。

然后你突然发现！询问 $[1,r]$ 和询问 $[1,n]$ 不是一样的吗？因为修改操作不存在后面的影响前面的。

然后做完了。建一个可持久化权值线段树一个权值线段树即可，具体见代码。

```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

const int MAXN = 5e5 + 3;

struct Node{
  int ls, rs, sz;
  LL sum;
}tr[MAXN * 20 * 2];
int tot = 0, root[MAXN], trt, rt;

int n, m;

void Update(int &i, int _i, int l, int r, int p){
  if(!i) i = ++tot;
  if(l == r){
    tr[i].sz = tr[_i].sz + 1, tr[i].sum = tr[_i].sum + l;
    return;
  }
  int mid = (l + r) >> 1;
  if(p <= mid) Update(tr[i].ls, tr[_i].ls, l, mid, p), tr[i].rs = tr[_i].rs;
  else Update(tr[i].rs, tr[_i].rs, mid + 1, r, p), tr[i].ls = tr[_i].ls;
  tr[i].sz = tr[tr[i].ls].sz + tr[tr[i].rs].sz;
  tr[i].sum = tr[tr[i].ls].sum + tr[tr[i].rs].sum;
}
LL Query(int i, int j, int l, int r, int k){
  if(l == r){
    return 1ll * k * l;
  }
  int mid = (l + r) >> 1, sum = tr[tr[i].rs].sz + tr[tr[j].rs].sz;
  if(k <= sum) return Query(tr[i].rs, tr[j].rs, mid + 1, r, k);
  return Query(tr[i].ls, tr[j].ls, l, mid, k -= sum) + tr[tr[i].rs].sum + tr[tr[j].rs].sum;
}

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m;
  for(int i = 1, x; i <= n; i++){
    cin >> x;
    Update(root[i], root[i - 1], 1, n, x);
  }
  rt = 0;
  while(m--){
    int x, l, r; cin >> x >> l >> r;
    trt = rt, rt = 0, Update(rt, trt, 1, n, x);
    cout << Query(root[r], rt, 1, n, r) - Query(root[l - 1], rt, 1, n, l - 1) << "\n";
  }
  return 0;
}
```

---

## 作者：xfrvq (赞：1)

以下集合指可重集。设集合 $S$，一次操作 $x$ 会让 $x$ 替换掉 $S\cap\{x\}$ 中最小值。如果有多次操作，设 $O=\{x\}$，$S'$ 即为 $S\cup O$ 的前 $|S|$ 大值。

将求区间和变为求前缀和。设当前操作过的 $x$ 集合 $O$。现在即求 $\{a_1,\cdots,a_i\}\cap O$ 的前 $i$ 小值。维护 $O$ 的值域线段树，序列前缀值域主席树， 查询时一起跑即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 5e5 + 5;

int n,m,a[N],rt[N],RT,cnt;
struct { int lc,rc,v; ll s; } T[N * 30];

#define mid ((L + R) / 2)

void upd(int p,bool f,int &i,int L = 1,int R = n){
	if(f) T[++cnt] = T[i],i = cnt; else if(!i) i = ++cnt;
	++T[i].v,T[i].s += p;
	if(L == R) return;
	p <= mid ? upd(p,f,T[i].lc,L,mid) : upd(p,f,T[i].rc,mid + 1,R);
}

ll qry(int k,int i,int j,int L = 1,int R = n){
	if(L == R) return 1ll * min(k,T[i].v + T[j].v) * L;
	if(k <= T[T[i].rc].v + T[T[j].rc].v) return qry(k,T[i].rc,T[j].rc,mid + 1,R);
	return T[T[i].rc].s + T[T[j].rc].s + qry(k - T[T[i].rc].v - T[T[j].rc].v,T[i].lc,T[j].lc,L,mid);
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;++i) scanf("%d",a + i),rt[i] = rt[i - 1],upd(a[i],1,rt[i]);
	for(int x,l,r;m--;){
		scanf("%d%d%d",&x,&l,&r),upd(x,0,RT);
		printf("%lld\n",qry(r,rt[r],RT) - qry(l - 1,rt[l - 1],RT));
	}
	return 0;
}
```

---

## 作者：Sunny郭 (赞：1)

注意到操作可以转换为：每次询问向当前数列前面插入一个数，设当前位置到原序列位置 $i$ 的前 $i$ 大的和为 $sum_i$，那么答案即为 $sum_r - sum_{l-1}$，维护前 k 大的状物可以直接上主席树，代码不长
```cpp
#include<bits/stdc++.h>
#define mid (l + r >> 1)
using namespace std;
using ll = long long;
const int N = 1e6 + 7;
int i, j, n, m, k;
int x, l, r;
int P, rt[N];

struct pq {
	ll s; int lc, rc, t;
	#define s(p) d[p].s
	#define t(p) d[p].t
	#define lc(p) d[p].lc
	#define rc(p) d[p].rc 
} d[N<<5];

void add(int& p, int pp, int x, int l=1, int r=n) {
	p = ++P; d[p] = d[pp];
	s(p) += x, t(p)++;
	if(l == r) return;
	x <= mid ? add(lc(p), lc(pp), x, l, mid) : add(rc(p), rc(pp), x, mid+1, r);
}

ll ask(int p, int pp, int x, int l=1, int r=n) {
	if(l == r) return 1ll * x * l;
	return t(rc(p)) - t(rc(pp)) >= x ? ask(rc(p), rc(pp), x, mid+1, r) : ask(lc(p), lc(pp), x - t(rc(p)) + t(rc(pp)), l, mid) + s(rc(p)) - s(rc(pp));
}

signed main() {
	scanf("%d %d", &n, &m);
	for(i=1; i<=n; i++) scanf("%d", &rt[i]);
	for(i=n; i; i--) add(rt[i+m], rt[i+1+m], rt[i]);
	for(i=m; i; i--) {
		scanf("%d %d %d", &x, &l, &r);
		add(rt[i], rt[i+1], x);
		printf("%lld\n", ask(rt[i], rt[m+r+1], r) - ask(rt[i], rt[m+l], l-1));
	}
	return 0;
}

```

---

## 作者：freoepn (赞：0)

先考虑这个操作的本质，对于一个前缀 $[1,i]$，如果前缀 $[1,i]$ 中的最小值比 $x$ 小，该操作相当于把 $[1,i]$ 的最小值用 $x$ 替换，否则就相当于什么都没做。

现在考虑如何处理有 $q$ 次操作的情况，易得该操作等于把 $[1,i]$ 和所有的 $x$ 中的 $q$ 小值删去，把答案写成前缀减去前缀的形式，再用可持久化 01Trie 维护 $q$ 小值即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int kMaxN = 1000005;
int son[21 * kMaxN][2], siz[21 * kMaxN], a[kMaxN], root[kMaxN], idx = 0;
long long tr[21 * kMaxN], sum[kMaxN];
int n, m;
void add(int x, int y, int z) {
    for (int i = 19; i >= 0; i--) {
        int p = ((z & (1 << i)) != 0);
        // cout <<i << " " << y << " "<< p << " "<< z << '\n';
        son[y][!p] = son[x][!p];
        son[y][p] = ++idx;
        x = son[x][p], y = son[y][p];
        tr[y] = tr[x] + z;
        siz[y] = siz[x] + 1;
    }
}
long long query(int x, int y, int z) {
    long long ans = 0;

    for (int i = 19; i >= 0; i--) {
        //cout<< i << ":" << x << "?"<< y << " "<< siz[son[x][0]] << " "<< siz[son[x][1]]<<" "<< siz[son[y][0]]<< " "<< siz[son[y][1]]<<" "<< ans <<" "<< z <<    '\n';
        if (siz[son[x][0]] + siz[son[y][0]] >= z) {
            x = son[x][0], y = son[y][0];
            //   cout << x << " "<< y << '\n';
        } else {
            z -= (siz[son[x][0]] + siz[son[y][0]]);
            ans += (tr[son[x][0]] + tr[son[y][0]]);
            x = son[x][1], y = son[y][1];
            //  cout << x << " "<< y << '\n';
        }
    }

    if (z) {
        ans += z * (max(tr[x], tr[y]) / max(siz[y], siz[x]));
    }

    // cout << ans << "!!!\n";
    return ans;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    root[0] = ++idx;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[i] = sum[i - 1] + a[i];
        root[i] = ++idx;
        add(root[i - 1], root[i], a[i]);
    }

    long long num = 0;

    for (int i = 1; i <= m; i++) {
        int x, l, r;
        cin >> x >> l >> r;
        root[n + i] = ++idx;
        add((i == 1 ? 1 : root[n + i - 1]), root[n + i], x);
        num += x;
        // cout << num << " "<< sum[l-1]<< " "<< sum[r]<<" "<< query(root[l-1],root[n+i],i) << " "<<  query(root[r],root[n+i],i)<< '\n';
        long long e = num + sum[l - 1] - query(root[l - 1], root[n + i], i), y = num + sum[r] - query(root[r],
                      root[n + i], i);
        cout << y - e << '\n';
    }

    return 0;
}
```

---

## 作者：harmis_yz (赞：0)

题解摘自[做题记录](https://www.luogu.com.cn/article/xbpjecpf)。

## 分析

性质见 AT_joisc2016_h。

有个很简单的性质，我们对于一个区间 $[l,r]$，$x$ 放进去跑，那么 $x$ 最后会变成区间最小值。然后改变的数每次是变成当前的队列里的最小值。证明简单，模拟即可。

那么对于一个询问 $\sum\limits_{i=l}^{r} a_i$，我们拆成两个前缀的查询。对于一个查询 $\sum\limits_{i=1}^{k} a_i$ 的问题，因为每次修改相当于是把 $x$ 放进去，然后和 $a_1\sim a_k$ 一起跑，得到一个最小值。那么前 $i$ 次操作，我们就相当于是将 $x_1,x_2,\dots,x_i$ 和 $a_1\sim a_k$ 放一起，然后删去了前 $i$ 小的数。

现在就只需要维护一个前缀和当前 $x$ 合起来的前 $i$ 小数的和了。首先想到二分，对于一个答案 $mid$，如果它们分别不大于 $mid$ 的数不小于 $i$，说明答案不超过 $mid$。反之同理。因为 $x$ 的范围和 $a_i$ 的范围相同，而它们相互独立。所以可以直接搞个形如树上二分的东西，只是两棵树同时二分。其中一棵是 $a_1 \sim a_k$ 的树，一棵是 $x$ 的树。这样能做到 $O(n\log n)$。

## 代码

```cpp
il void up(int s,int u){
	tr[s][u].siz=tr[s][ls(s,u)].siz+tr[s][rs(s,u)].siz;
	tr[s][u].sum=tr[s][ls(s,u)].sum+tr[s][rs(s,u)].sum;
	return ;
}
il void modify(int &u,int l,int r,int x,int s){
	if(s==0) tr[s][++idx]=tr[s][u],u=idx;
	else if(!u) u=++idx;
	if(l==r) return ++tr[s][u].siz,tr[s][u].sum+=l,void(0);
	int mid=l+r>>1;
	if(x<=mid) modify(ls(s,u),l,mid,x,s);
	else modify(rs(s,u),mid+1,r,x,s);
	return up(s,u),void(0);
}
il int query(int u,int u_,int l,int r,int k){
	if(!k) return 0;
	if(!u&&!u_) return debug(),0;
	if(l==r) return k*l;
	int mid=l+r>>1;
	if(tr[0][ls(0,u)].siz+tr[1][ls(1,u_)].siz>=k) return query(ls(0,u),ls(1,u_),l,mid,k);
	return tr[0][ls(0,u)].sum+tr[1][ls(1,u_)].sum+query(rs(0,u),rs(1,u_),mid+1,r,k-(tr[0][ls(0,u)].siz+tr[1][ls(1,u_)].siz));
}
il int work(int k,int x){
	return s[k]+s_-query(root[k],Root,1,n,x);
}

il void solve(){
	n=rd,m=rd;
	for(re int i=1;i<=n;++i){
		a[i]=rd,s[i]=a[i]+s[i-1];
		modify(root[i]=root[i-1],1,n,a[i],0);
	}
	for(re int i=1;i<=m;++i){
		int x=rd,l=rd,r=rd,sum=0;
		s_+=x,modify(Root,1,n,x,1);
		printf("%lld\n",work(r,i)-work(l-1,i));
	}
    return ;
}
```

---


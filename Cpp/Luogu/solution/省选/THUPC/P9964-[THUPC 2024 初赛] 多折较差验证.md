# [THUPC 2024 初赛] 多折较差验证

## 题目描述

临海听潮意，入林闻籁鸣。这是一座依山傍水、宁静祥和的小镇，在这里人们很少担心自己家里的物品故障损坏，因为 Kanan 总能帮大家修好。Kanan 是这片地区首屈一指的机械师；虽然她还年轻，但是娴熟的技艺加上慷慨的性格使得她平时总会收到人们的修理委托，据说就连那位遗世独立的魔王遇到了问题都得求助她。在帮人修理时， Kanan 会接触到千奇百怪的使用说明书。其中一些说明书有着不可思议的折叠结构，Kanan 为了理解机械的构造会在修理之前展开说明书，可在修好之后按照原来的折痕折回原状却比修理本身更费劲。

对于所有折痕互相平行的说明书，可以按照说明书上文字的阅读顺序从上到下给每条折痕分别编号 $1, 2, \cdots, N$，这 $N$ 条折痕将说明书分成了 $(N+1)$ 条纸带。每条折痕可能为两种形态之一：一种是垂直纸面向内凸出，对应将纸的上下两半向前对折；一种是垂直纸面向外凸出，对应将上下两半向后对折。根据折痕截面的形状，分别使用小写字母 `v` 表示向内凸出的折痕，`^` （ASCII 码为 $94$）表示向外凸出的折痕。假设所有纸带的宽度都是一样的，并且折纸的过程中说明书不发生形变，那么沿着一条折痕对折后两侧的纸能够重合，当且仅当两侧的折痕是相反的；即，如果沿着第 $k$ 条折痕折叠，那么对于所有满足 $1\le k-m<k+m\le N$ 的正整数 $m$，第 $(k-m)$ 条折痕和第 $(k+m)$ 条折痕的形态是相反的。例如，对于折痕依次为 `v^v^^^^v` 的说明书，可以沿其第 $7$ 条折痕进行折叠。根据定义可知，一张说明书总能沿着第一条或最后一条折痕进行折叠。折叠之后的说明书可以用被折叠的折痕两侧中，剩余折痕数量较多一侧的折痕表示，如 `v^v^^^^v` 沿着第 $7$ 条折痕折叠后得到 `v^v^^^`。如果被折叠的折痕两侧折痕数量相等，那么用哪一侧的折痕表示折叠后的纸都可以，因为折痕在三维空间中是旋转对称的。特别地，对只剩下一条折痕的说明书，即 `v` 或 `^` 进行折叠后，所有 $(N+1)$ 条纸带都重叠在一起，此时称这张说明书被折叠整齐。

虽然按顺序依次折叠每一条折痕，总能将说明书折叠整齐，但 Kanan 觉得这样并不美观。一种美观的折法应该尽量少折，并且每次折的时候折痕两侧应该尽可能的对称。定义一种折法的不对称程度为每次折叠时，被折叠的折痕两侧的折痕数量之差的总和。给出一张说明书的折痕，Kanan 想知道最少需要折多少次才能将这张说明书折叠整齐，以及所有折叠次数最少的折法中，不对称程度的最小值。


## 说明/提示

### 样例 \#1 解释

如果先沿着中间的折痕对折，那么两侧的纸恰好重合，此时再对折一次即可将说明书折叠整齐。

### 子任务

对于所有数据，保证 $1\le N\le 5000$，$|s|=N$ 且 $s$ 仅由 `v` 和 `^` 组成。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
3
^vv
```

### 输出

```
2 0
```

## 样例 #2

### 输入

```
8
v^v^^^^v
```

### 输出

```
6 15
```

## 样例 #3

### 输入

```
40
v^vv^v^^v^^vvvv^v^^v^^^vv^^vvvv^v^^v^^^v
```

### 输出

```
14 201
```

## 样例 #4

### 输入

```
56
v^vvvvvvv^v^^vv^v^^v^^^^v^^v^vvvv^^vvvv^v^^v^^^vv^^vv^v^
```

### 输出

```
24 663
```

# 题解

## 作者：0xyz (赞：6)

赛后写出，比 std 少一个 $\log$，不需要任何数据结构。

不难想到区间 DP，令 $f_{i,j}$ 表示将区间 $[i,j]$ 完全折好最少要折多少次，以及在这一前提下最小的不对称度是多少。那么我们枚举在哪个点 $k$ 折叠，并转移即可。能在点 $k$ 折叠要求 $k$ 左右边能完全匹配的位数 $p_k\ge\min(k-i,j-k)$。这个 $p_k$ 可以 $O(n^2)$ 预处理。总时间复杂度 $O(n^3)$ 的[代码](https://loj.ac/s/1962618)。

考虑优化，注意到对于区间的左半边是一类转移，区间的右半边是一类转移。对于剩余串 $a$ 和 $b$，如果 $b$ 是 $a$ 的子串，那么 $b$ 的最优折叠一定优于 $a$ 的最优折叠。这启示我们，对于区间 $[i,j]$ 左半边的所有 $k$，取最右边那个，设为 $s$；右半边的，取最左边那个，设为 $t$。$f_{i,j}$ 只需要由 $f_{s+1,j}$ 和 $f_{i,t-1}$ 转移而来，这样就可以保证每次操作都是最优的。[代码](https://loj.ac/s/1962624)。

注意到 $s$ 的实质是前缀 $[1,\lfloor\frac{i+j}{2}\rfloor]$ 里满足 $i\ge k-p_k$ 的最大 $k$。状态 $(\lfloor\frac{i+j}{2}\rfloor,i)$ 只有 $O(n^2)$ 个，所以我们可以通过枚举 $O(n^2)$ 预处理出所有 $s$。对 $t$ 的处理同理。总时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$，跑得很快。[代码](https://loj.ac/s/1962680)。

---

## 作者：yizcdl2357 (赞：3)

赛时 1.5h 左右过了。想不通 D 为什么过的这么少，感觉比 H、J 都难。

考虑区间 dp：$dp_{i,j,0/1}$ 表示折整齐 $i\sim j$ 的最小次数/代价和。转移时枚举折叠点 $k$ 即可。

然而时间是 $O(n^3)$ 的。观察到：当两个折叠点 $k_1,k_2$ 在 $i,j$ 的中点的同侧，且 $k_1$ 离中点比 $k_2$ 更近时，选取 $k_1$ 的代价更小，且选取 $k_1$ 后剩下的串是选取 $k_2$ 后剩下的串的子串。故 $k_1$ 必然优于 $k_2$。

因此，只需分别记录在中点左/右侧，且离中点最近的折叠点。

# 代码

实现上需要开一个数组 $g_{i,j}$ 表示 $i\sim j$ 是否能被折叠。

然后设 $f_{i,j,0/1}$ 表示离 $i\sim j$ 的中点最近的，且在 $i\sim j$ 的中点左/右侧的折叠点。

考场代码：

```cpp
#include<bits/stdc++.h>
#define N 5000
using namespace std;
int n,r[N+5],g[N+5][N+5],f[N+5][N+5][2];
int dp[N+5][N+5][2];
bool a[N+5];
string s;
int main()
{
//	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>s;s=' '+s;
	for(int i=1;i<=n;i++) a[i]=(s[i]=='^');
	for(int i=1;i<=n;i++)
		for(int j=0;;j++)
			if(j==0||i-j>=1&&i+j<=n&&a[i-j]!=a[i+j]) g[i-j][i+j]=1;
			else break;
//	cout<<'A';
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			if(g[i][j]) f[i][j][0]=(i+j)/2;
			else f[i][j][0]=f[i][j-1][0];
//	cout<<'A';
	for(int j=n;j>=1;j--)
		for(int i=j;i>=1;i--)
			if(g[i][j]) f[i][j][1]=(i+j)/2;
			else f[i][j][1]=f[i+1][j][1];
/*	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			cout<<i<<' '<<j<<':'<<f[i][j][0]<<' '<<f[i][j][1]<<endl;*/
	for(int i=1;i<=n;i++) dp[i][i][0]=1;
	for(int c=1;c<n;c++)
		for(int i=1,j=c+1;j<=n;i++,j++)
		{
			int l1=f[i][j][0]+1,r1=f[i][j][1]-1;
			if(dp[i][r1][0]<dp[l1][j][0])
				dp[i][j][0]=dp[i][r1][0]+1,
				dp[i][j][1]=dp[i][r1][1]+(r1+1-i)-(j-r1-1);
			else if(dp[i][r1][0]>dp[l1][j][0])
				dp[i][j][0]=dp[l1][j][0]+1,
				dp[i][j][1]=dp[l1][j][1]+(j-l1+1)-(l1-1-i);
			else if(dp[i][r1][1]+(r1+1-i)-(j-r1-1)
			<dp[l1][j][1]+(j-l1+1)-(l1-1-i))
				dp[i][j][0]=dp[i][r1][0]+1,
				dp[i][j][1]=dp[i][r1][1]+(r1+1-i)-(j-r1-1);
			else 
				dp[i][j][0]=dp[l1][j][0]+1,
				dp[i][j][1]=dp[l1][j][1]+(j-l1+1)-(l1-1-i);
		}
	cout<<dp[1][n][0]<<' '<<dp[1][n][1];
	return 0;
}
```


---

## 作者：Hypercube (赞：1)

套路做法。

设 $f_{l,r}$ 表示操作到只剩 $[l,r]$ 时，在最小化操作次数的前提下答案最小是多少。

显然我们要按长度降序枚举区间，那么区间 $[l,r]$ 只能被 $[l,R]$ 或 $[L,r]$ 转移到，其中 $L<l,R>r$。那么对每个左/右端点开个单调栈，对每个区间预处理最远距离后单调栈上二分即可。

一般来讲单调栈卡不满，所以常数不大。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
typedef double db;
inline ll read() {
	ll x=0,f=1;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)) {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
const int N=5005,inf=0x3f3f3f3f;
int n;
short R[N][N],L[N][N],stk_l[N][N],stk_r[N][N],tp_l[N],tp_r[N];
string s;
struct dp {int num,sum;}f[N][N],ans;
bool operator < (dp x,dp y) {
	if(x.num==y.num) return x.sum<y.sum;
	return x.num<y.num;
}
bool kll(int l1,int r1,int l2,int r2,int tp) {
	if(tp==0) {
		return (dp){f[l1][r1].num,f[l1][r1].sum-(l1+r1)}<(dp){f[l2][r2].num,f[l2][r2].sum-(l2+r2)};
	}
	else {
		return (dp){f[l1][r1].num,f[l1][r1].sum+(l1+r1)}<(dp){f[l2][r2].num,f[l2][r2].sum+(l2+r2)};
	}
}
void ins(int l,int r) {
	while(tp_l[l]>0&&kll(l,r,l,stk_l[l][tp_l[l]],0)) tp_l[l]--;
	stk_l[l][++tp_l[l]]=r;
	while(tp_r[r]>0&&kll(l,r,stk_r[r][tp_r[r]],r,1)) tp_r[r]--;
    stk_r[r][++tp_r[r]]=l;
}
int main() {
    n=read();cin>>s;s=" "+s;s+=" ";
    for(int i=0;i<=n;i++) 
    	for(int j=0;j<=n;j++) 
    		f[i][j]={inf,inf};
    for(int i=1;i<=n;i++) {
    	if(i==1) {
    		for(int j=1;j<=n;j++) L[i][j]=1;
    		continue;
		}
		bool die=false;
		if(s[i]==s[i-2]||s[i-2]==' ') die=true,L[i][i]=i-1;
		else L[i][i]=i-2;
    	for(int j=i+1;j<=n;j++) {
    		if(die) {L[i][j]=L[i][j-1];continue;}
    		if(s[j]==s[(i-1)-(j-(i-1))]||s[(i-1)-(j-(i-1))]==' ') die=true,L[i][j]=L[i][j-1];
    		else L[i][j]=L[i][j-1]-1;
		}
	}
	for(int j=1;j<=n;j++) {
		if(j==n) {
			for(int i=j;i>=1;i--) R[i][j]=n;
			continue;
		}
		bool die=false;
		if(s[j]==s[j+2]||s[j+2]==' ') die=true,R[j][j]=j+1;
		else R[j][j]=j+2;
		for(int i=j-1;i>=1;i--) {
			if(die) {R[i][j]=R[i+1][j];continue;}
			if(s[i]==s[(j+1)+((j+1)-i)]||s[(j+1)+((j+1)-i)]==' ') die=true,R[i][j]=R[i+1][j];
			else {
				R[i][j]=R[i+1][j]+1;
			}
		}
	}
    f[1][n]={1,0};ins(1,n);
    for(int len=n-1;len>=1;len--) {
    	for(int x=1;x+len-1<=n;x++) {
    		int y=x+len-1;
    		int l=1,r=tp_l[x],ans=-1;
			while(l<=r) {
				int mid=(l+r)>>1;
				if(R[x][y]>=stk_l[x][mid]) r=mid-1,ans=stk_l[x][mid];
				else l=mid+1;
			} 
			if(ans!=-1&&(dp){f[x][ans].num+1,f[x][ans].sum-(x+ans)+2*(y+1)}<f[x][y]) {
				f[x][y]=(dp){f[x][ans].num+1,f[x][ans].sum-(x+ans)+2*(y+1)};
			} 
			l=1,r=tp_r[y],ans=-1;
			while(l<=r) {
				int mid=(l+r)>>1;
				if(L[x][y]<=stk_r[y][mid]) r=mid-1,ans=stk_r[y][mid];
				else l=mid+1;
			}
			if(ans!=-1&&(dp){f[ans][y].num+1,f[ans][y].sum+(ans+y)-2*(x-1)}<f[x][y]) {
				f[x][y]=(dp){f[ans][y].num+1,f[ans][y].sum+(ans+y)-2*(x-1)};
			}
			if(f[x][y].num!=inf) ins(x,y);
		}
	}
	ans={inf,inf};
	for(int i=1;i<=n;i++) if(f[i][i]<ans) ans=f[i][i];
	cout<<ans.num<<' '<<ans.sum<<'\n';
	return 0;
}

```


---

## 作者：Lonely_NewYear (赞：1)

# P9964 题解

## 题目描述

给一个长度为 $n$ 的 01 串，每次可以选择一个位置 $i$ 当作中心将串对折（要求对于 $1\le i-k<i+k\le n$ 的所有 $k$，满足 $s_{i-k}\neq s_{i+k}$），对折后将留下 $1\sim i-1$ 和 $i+1\sim n$ 中长度较长的一段，并产生两段长度之差即 $|n-2i+1|$ 的代价。求最少多少次对折能将整个 01 串对折空，以及对折次数最少的情况下代价的最小值。

## 题目分析

很容易想到 $O(n^3)$ 的区间 dp。记 $a_{i,j},b_{i,j}$ 分别表示区间 $[i,j]$ 的最小次数和相应的最小代价，转移只需枚举对折点。判断对折点是否满足条件可以暴力 $O(n^2)$ 预处理出以每个点为中心的“最长对折长度”，即对于 $1\le i\le n$ 求出最大的 $k\le\min(i-1,n-i)$ 满足 $\forall 1\le j\le k,s_{i-j}\neq s_{i+j}$。

容易发现对于一个区间 $[l,r]$，若存在两个对折点 $l\le j<i\le\frac{l+r}{2}$（即两个都在左半部分的对折点），折 $i$ 产生的子区间 $[i+1,r]$ 是折 $j$ 产生的子区间 $[j+1,r]$ 的后缀，此时可以发现折 $i$ 一定必折 $j$ 更优。具体证明考虑折空 $[i+1,r]$ 可以复制折空 $[j+1,r]$ 的操作，显然次数前者一定小于等于后者，而在折 $[l,r]$ 时前者比后者的代价少 $2(i-j)$，画画图容易得到前者在之后的代价最多比后者多 $i-j$，所以前者产生的代价也一定小于等于后者。如果存在两个都在右半部分的对折点也相同。

此时我们转移只需要枚举左半部分和右半部分最靠近中心的对折点。如果能快速找到这两个点就可以做到 $O(n^2)$。考虑记 $f_{l,r},g_{l,r}$ 表示区间 $[l,r]$ 左半部分和右半部分的最优对折点。首先可以和上面的暴力一样的找到以每个点 $i$ 为中心的“最长对折长度”$k$，初始化 $\forall 0\le j\le k,f_{i-j,i+j}=g_{i-j,i+j}=i$，之后递推 $f_{l,r}=\max(f_{l,r},f_{l,r-1}),g_{l,r}=\min(g_{l,r},g_{l+1,r})$ 即可。总复杂度 $O(n^2)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=5010;
int n;
char s[MAXN];
int f[MAXN][MAXN],g[MAXN][MAXN],a[MAXN][MAXN],b[MAXN][MAXN];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>s+1;
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
            f[i][j]=i,g[i][j]=j;
    for(int k=1;k<=n;k++){
        for(int i=1;k-i>=1&&k+i<=n;i++){
            int l=k-i,r=k+i;
            if(s[l]==s[r])break;
            f[l][r]=max(f[l][r],k);
            g[l][r]=min(g[l][r],k);
        }
    }
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            f[i][j]=max(f[i][j],f[i][j-1]);
    for(int j=1;j<=n;j++)
        for(int i=j-1;i>=1;i--)
            g[i][j]=min(g[i][j],g[i+1][j]);
    for(int i=1;i<=n;i++)a[i][i]=1;
    for(int h=1;h<n;h++){
        for(int i=1;i+h<=n;i++){
            int j=i+h;
            a[i][j]=a[f[i][j]+1][j]+1;
            b[i][j]=b[f[i][j]+1][j]+(j-f[i][j])-(f[i][j]-i);
            int A=a[i][g[i][j]-1]+1;
            ll B=b[i][g[i][j]-1]+(g[i][j]-i)-(j-g[i][j]);
            if(a[i][j]>A||(a[i][j]==A&&b[i][j]>B))a[i][j]=A,b[i][j]=B;
        }
    }
    cout<<a[1][n]<<' '<<b[1][n];
    return 0;
}
```

谢谢观看！

---

## 作者：I_am_Accepted (赞：1)

一个 DP 是 $f_{l,r},g_{l,r}$ 表示区间 $[l,r]$ 折完的最少次数，及满足最少次数时的最小代价。

转移分别考虑折痕为 $l-1,r+1$ 位置的情况。

考虑先求出 $f$，按长度升序转移，两个方向的转移分别是长度前缀的 $f$ 进行 check min，而且由于 $f$ 在两维均单调，所以用横竖各 $n$ 个队列维护即可。

求完 $f$ 后对于 $g$ 可以仿照上述过程，但由于 $g$ 的转移不能发生在 $f$ 值相同的状态之间，所以做法稍有不同：在一个状态向右侧（左侧同理）增长 $1$ 后若 $f$ 不同了，则将等于其 $f$ 值、左端点相同的状态的 $g$ 同时转移，这样也不用队列了（允许离线了），做前缀 $\min$ 即可。

复杂度 $O(n^2)$。

赛时写挂硬是没调出来。

没用到反回文串个数的性质，跪求大佬教教反回文串个数上界证明。

---

## 作者：shinzanmono (赞：1)

dp 状态非常好想。


设 $f_{l,r}$ 表示折痕序列 $s_{l,\cdots,r}$ 全部折叠完所需的最小折叠次数，$g_{l,r}$ 表示折痕序列子序列 $s_{l,\cdots,r}$ 折叠完的不对称程度的最小值。

转移比较好想，关键在于优化。

我们记录以第 $i$ 个折痕为中心的最大可折叠半径 $p_i$。即对于任意的 $1\leq r\leq p_i$，$s_{i-r+1,\cdots,i+r-1}$ 是可折叠的。对于子串 $s_{l,r}$ 和任意 $l\leq k\leq r$，如果 $k>\frac{l+r}{2}$ 且 $k+p_i-1\leq r$ 说明子串的右半部分可以沿 $k$ 向左折叠。同理，若 $k\leq \frac{l+r}2$ 且 $k-p_i+1\geq l$，说明子串的左半部分可以沿 $k$ 向左折叠。

我们预处理出所有转移点，枚举转移即可。

通过观察它的折叠方法，我们将对称变为二叉树，可以发现最坏情况为完全二叉树，单次转移时间复杂度为 $O(\log n)$。

所以总的时间复杂度为 $O(n^2\log n)$，可以通过本题。

---


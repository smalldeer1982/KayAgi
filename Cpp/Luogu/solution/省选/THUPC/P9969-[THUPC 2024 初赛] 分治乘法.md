# [THUPC 2024 初赛] 分治乘法

## 题目描述

小艾想要挑战分治乘法。TA 将策略抽象成了如下问题：

现在给定一个目标集合 $T$，该集合是 $\{1,\dots,n\}$ 的一个子集（$1\leq n\leq 5\times 10^5$）。你需要通过一系列操作构造一些集合最后得到 $T$，具体来说有以下三种操作：

- 创造一个大小为一的集合 $|S|=1$。
- 将已经被构造出的两个不交集合 $A, B$ 并起来，得到 $A\cup B$。
- 将已经被构造出的一个集合 $A$ 进行平移，也即 $A+x = \{ a+x : a\in A \}$。

一个已经被构造出的集合可以在之后被使用多次。同时你需要保证操作过程中出现的所有集合都是 $\{1,\dots,n\}$ 的子集。

你的代价是构造出的所有集合的大小之和，你不需要最小化代价，只需要让代价控制不超过 $5\times 10^6$ 即可。你用的操作数量也不应超过 $10^6$。

## 说明/提示

### 样例 \#1 解释

- 第一次操作：创造集合 $T_1=\{1\}$。
- 第二次操作：创造集合 $T_2=\{4\}$。
- 第三次操作：将 $T_1, T_2$ 并起来，得到 $T_3=\{1,4\}$。
- 第四次操作：将 $T_3$ 平移 $1$，得到 $T_4=\{2,5\}$。
- 第五次操作：将 $T_3, T_4$ 并起来，得到 $T_5=\{1,2,4,5\}$。这就得到了 $T$。

这个方案的总代价是 $1 + 1 + 2 + 2 + 4 = 10$。

### 提示

如果你的复杂度是好的，请相信常数。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
5
11011
```

### 输出

```
5
1 1
1 4
2 1 2
3 3 1
2 3 4
```

# 题解

## 作者：meyi (赞：7)

不会做，但是乱搞过了。

直接分治乘或合并果子面对五十万个 `1` 要操作九百九十七万次，几乎是题目限制的两倍，但这已经是前两个操作的最优结果，所以考虑用第三个操作进行优化。

有一个很 naive 的想法是把所有长度为二的连续段的第一个元素用操作一构造出来，再用操作三平移构造第二个元素，最后合并果子。在 `1` 很稠密的时候这个东西确实能优化很多，但是仍然会被五十万个 `1` 薄纱。。。

五十万个 `1` 疑似有点极端稠密了。。。于是我们也极端一点，把长度为三的连续段也用前述方式构造出来再合并果子，注意控制好阈值，然后这个东西薄纱五十万个 `1` 了。。。然后在五十万个 `1` 里随机加 `0` 拍了一千组也轻松薄纱。。。然后交上去过了。

实际上这个阈值貌似瞎取也没太大问题。

不会证也不会 hack，给出参考代码供大家薄纱。

```cpp
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
#ifdef ONLINE_JUDGE
static char pbuf[1000000],*p1=pbuf,*p2=pbuf,obuf[1000000],*o=obuf;
#define getchar() p1==p2&&(p2=(p1=pbuf)+fread(pbuf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define putchar(x) (o-obuf<1000000)?(*o++=(x)):(fwrite(obuf,o-obuf,1,stdout),o=obuf,*o++=(x))
struct flusher{~flusher(){fwrite(obuf,o-obuf,1,stdout);}}autoflush;
#endif
inline int qr(){
    int in=0;char ch;
    while(!isdigit(ch=getchar()));
    do in=(in<<1)+(in<<3)+(ch^48);while(isdigit(ch=getchar()));
    return in;
}
template<class T>
void qw(T out){
    if(out>9)qw(out/10);
    putchar(out%10|48);
}
inline char gc(){
    char ch;
    while(!isupper(ch=getchar()));
    return ch;
}
int main(){
    int n=qr();
    V<char>a;
    a.reserve(n);
    char ch;
    while(!isdigit(ch=getchar()));
    do a.pb(ch);while(isdigit(ch=getchar()));
    V<V<int>>ans;
    V<int>siz;
	auto cmp=[&](int x,int y){return siz[x]>siz[y];};
    priority_queue<int,V<int>,decltype(cmp)>q(cmp);
    if(count(ALL(a),49)>=300000){
    	priority_queue<int,V<int>,decltype(cmp)>_q(cmp);
		For(i,n-2)if((a[i]^48)&&(a[i+1]^48)&&(a[i+2]^48))a[i]=a[i+1]=a[i+2]=48,ans.pb({1,i+1}),siz.pb(1),_q.push(ans.size()-1);
		while(_q.size()>1){
			int x=_q.top();_q.pop();
			int y=_q.top();_q.pop();
			ans.pb({2,x+1,y+1}),siz.pb(siz[x]+siz[y]),_q.push(ans.size()-1);
		}
		int nw=ans.size();
		ans.pb({3,nw,1}),siz.pb(siz[nw-1]);
		ans.pb({3,nw+1,1}),siz.pb(siz[nw]);
		ans.pb({2,nw,nw+1}),siz.pb(siz[nw-1]+siz[nw]);
		ans.pb({2,nw+2,nw+3}),siz.pb(siz[nw+1]+siz[nw+2]);
		q.push(nw+3);
	}
	if(count(ALL(a),49)>=150000){
    	priority_queue<int,V<int>,decltype(cmp)>_q(cmp);
		For(i,n-1)if((a[i]^48)&&(a[i+1]^48))a[i]=a[i+1]=48,ans.pb({1,i+1}),siz.pb(1),_q.push(ans.size()-1);
		while(_q.size()>1){
			int x=_q.top();_q.pop();
			int y=_q.top();_q.pop();
			ans.pb({2,x+1,y+1}),siz.pb(siz[x]+siz[y]),_q.push(ans.size()-1);
		}
		int nw=ans.size();
		ans.pb({3,nw,1}),siz.pb(siz[nw-1]);
		ans.pb({2,nw,nw+1}),siz.pb(siz[nw]<<1);
		q.push(nw+1);
	}
	For(i,n)if(a[i]^48)ans.pb({1,i+1}),siz.pb(1),q.push(ans.size()-1);
	while(q.size()>1){
		int x=q.top();q.pop();
		int y=q.top();q.pop();
		ans.pb({2,x+1,y+1}),siz.pb(siz[x]+siz[y]),q.push(ans.size()-1);
	}
    qw(ans.size()),putchar(10);
    for(auto &i:ans){
        for(int j:i)qw(j),putchar(32);
        putchar(10);
    }
    return 0;
}
```

---

## 作者：zhuzhu2891 (赞：5)

考虑每相邻三个分一组。

那么每组只有 $8$ 种可能，`000` 不用考虑。

然后 `001` `010` `100` 分一类叫 A 类。

 `011` `110` 分一类叫 B 类。

 `101` 分一类叫 C 类。

 `111` 分一类叫 D 类。
 
 然后对于每一类由于形态相似，考虑取出这一类中每组的第一个元素，启发式合并，再对于整体平移并合并成这一类所需的所有元素。
 
 最后把 AB 并一起，再把 ABC 并一起，再和 D 并一起，就没了。
 
 考虑操作次数及代价证明：
 
 对于操作次数显然是 $\frac{2N}3$ 的。
 
 对于操作代价，中间启发式合并是 $\le\frac{N\left \lceil\log_2\frac N3\right\rceil}{3}$ 的。
 
 对于前后的部分，设 A 类有 $a$ 个，设 B 类有 $b$ 个，设 C 类有 $c$ 个，设 D 类有 $d$ 个。
 
 显然对于构造新集与平移合并，代价是 $a+4b+4c+8d$。
 
 对于最终合并，代价是 $3a+6b+4c+3d$。
 
 加起来是 $4a+10b+8c+11d\le\frac{11N}3$。
 
 于是总共 $\le\frac{11N}3+\frac{N\left \lceil\log_2\frac N3\right\rceil}{3}\le 5\times 10^6$。

---

## 作者：_Diu_ (赞：4)

大腿队友 [bdzzj](https://www.luogu.com.cn/user/548975) 想的一个神秘做法。

~~考虑分治乘法~~

考虑到如果不存在连续的 `1111`，那么总共有值的个数不超过 $\dfrac n2$，直接分治代价 $\dfrac {n\log n}2$ 可以接受。如果存在很多连续的 `1111`，我们通过神秘方法让他们重复利用。

考虑先把所有连续段拆成 $\log$ 段长度均为 $2^k$ 的东西，然后我们从 $d$ 从大到小枚举，维护集合 $T$ 初始为空，进行以下操作：

- $T\cup (T\times 2^k)\to T$

- 把所有恰好为 $2^k$ 的段的左端分治加入集合。

~~注意到这个算法看起来很对，所以它过了。~~

注意到我们对于单独一个长度为 $2^k$ 的段，它的代价是 $3\times2^k$。如果我们和别的段合并，比如说 $2^x$ 和 $2^y$ 合并 $(x\le y)$，会在 $2^{x}$ 出额外贡献一次，贡献的代价是 $2^{y-x}$。并且我们在每一层中间合并时，可以考虑把 $T,(T\times 2^k)$ 和一些大小为 $1$ 的集合启发式，每次拿出最小的两个合并。感觉很对，但是不太会证也不太会卡。`01` 交替可以卡到 $\dfrac {n\log n}2$，其他的未知，但是能过。欢迎 hack。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1<<19;
int n,m,b[N],k,t=1;
char s[N];
struct node{
    int l,r;
}a[N];
struct upd{
    int op,x,y;
};
int cnt;
vector<upd> ans;
void ins(int op,int x,int y=0){
    ++cnt,ans.push_back({op,x,y});
}
struct Node{
    int x,y;
    bool operator<(const Node h)const{return y>h.y;}
};
priority_queue<Node> q;
int s1;
vector<int> p[20];
signed main(){
    scanf("%d\n%s",&n,s+1);
//	n=500000;srand(time(0));
//	for(int i=1;i<=n;i++){
//		s[i]=(rand()&1)?'1':'0';
//	}
    for(int i=1;i<=n;i++){
        b[i]=s[i]-'0';
        if(b[i]){
            if(!m||a[m].r!=i-1)a[++m]={i,i};
            else a[m].r=i;
        }
    }
    int mx=1;
//	for(int i=1;i<=m;i++)printf("%d %d\n",a[i].l,a[i].r);
    for(int i=2;i<=m;i++){
        if(a[i].r-a[i].l>a[mx].r-a[mx].l)mx=i;
    }
    while(t<=a[mx].r-a[mx].l+1)t<<=1,++k;
    --k,t>>=1;
    for(int i=1;i<=m;i++){
        int l=a[i].l,d=a[i].r-a[i].l+1;
        for(int j=k;j>=0;j--){
            if(d>>j&1)p[j].push_back(l),l+=1<<j;
        }
    }
    for(int i=k;i>=0;i--){
        for(int j:p[i]){
            ins(1,j),++s1;
            q.push({cnt,1});
        }
        while(q.size()>1){
            Node u=q.top();q.pop();
            Node v=q.top();q.pop();
            ins(2,u.x,v.x);
            s1+=u.y+v.y;
            q.push({cnt,u.y+v.y});
        }
        if(i==0)break;
        Node u=q.top();
        ins(3,u.x,1<<i-1),s1+=u.y;
        q.push({cnt,u.y});
    }
    if(ans.size()>1000000){
        while(1)ins(1,1,1);
    }
    if(s1>=5000000){
        exit(-1);
    }
    printf("%d\n",ans.size());
    for(upd t:ans){
        if(t.op==1)printf("%d %d\n",t.op,t.x);
        else printf("%d %d %d\n",t.op,t.x,t.y);
    }
}
```

---

## 作者：0xyz (赞：3)

赛后写出。直接写分治乘法，发现最大操作代价和将近 $10^7$，仅仅是题目要求的 $2$ 倍。我们要卡常，应该利用操作 $3$ 记忆化。那么就可以这样：处理 $[l,r]$ 的时候，先处理 $[l,mid]$ 和 $[mid+1,r]$ 的公共部分，再处理公共部分以外的部分。很神奇，这样居然能过，至于为什么我不会证。

时间复杂度 $O(n\log n)$。空间复杂度 $O(n)$。[代码](https://loj.ac/s/1961064)。

---

## 作者：Perta (赞：3)

一些乱搞。

后文将操作简称为 ``创造``，``合并``，``平移``。

设置阈值 $k$，将极长全 1 子串提出来并将其划分为若干个长为 $k$ 的子串与 $0\sim1$ 个长度小于 $k$ 的子串。

设 $l_i$ 表示 $i$ 在原串中的位置。对于划分出的子串集合 $S$，设 $T_i=\{l_{x_i}\vert x\in S\}$。将 $T_k$ 中的元素创造出来后合并，再平移到 $T_{k-1}$，若平移后没有对应的元素，再使用创造操作然后合并即可，一直进行到 $T_1$。

也许有点抽象，举个例子。原串为 $1111111101$，令 $k=3$，则划分的串有 $\color{red}{1}\color{orange}{1}\color{pink}{1},\color{red}{1}\color{orange}{1}\color{pink}{1},\color{red}{1}\color{orange}{1},\color{red}{1}$，其中 $\color{red}{1}$ 在 $T_1$ 中，$\color{orange}{1}$ 在 $T_2$ 中，$\color{pink}{1}$ 在 $T_3$ 中。对于 $T_3$，先创造出两个 $\color{pink}{1}$ 并将其合并到同一个集合中，通过平移操作得到两个 $\color{orange}{1}$。由于 $\lvert T_2\rvert=3$，还需要再创造出一个 $\color{orange}{1}$，并将其与之前两个 $\color{orange}{1}$ 的集合合并。之后平移到 $T_1$ 同理。

之后把所有 $T$ 合并起来即可。

合并均使用启发式。不是很会算操作数，设置 $k$ 在 $3$ 到 $300$ 左右都能通过此题。遇到 ``10101010...`` 的数据会被卡到 $4.7\times10^6$ 次操作多一点。

~~~c++
#include<bits/stdc++.h>
using namespace std;
int stk[10],tp;
inline void write(int x)
{
    if(!x) return putchar('0'),void();
    tp=0;
    while(x) stk[++tp]=x%10,x/=10;
    while(tp) putchar(stk[tp--]^48);
}
const int N=5e5+10,Q=1e6+10;
struct ok{
    int op,x,y;
}ans[Q];
struct node{
    int l,len;
    bool operator <(const node &A) const{return len>A.len;}
};
int n,k=20,st;
char a[N];
vector<int>ned[N];
priority_queue<node>q1,q2;
void add(int l,int r) {ned[k-r+l].push_back(l);}
int main()
{
    scanf("%d%s",&n,a+1);
    for(int i=1,t;i<=n;i=t)
    {
        if(a[i]=='0') {t=i+1;continue;}
        t=i;
        while(a[t]=='1') ++t;
        for(int r=i;r<t;r+=k) add(r,min(r+k,t)-1);
    }
    int Mn=0;
    for(int i=1;i<=k;i++)
        if(!ned[i].empty()) {Mn=i;break;}
    for(int i=Mn;i<=k;i++)
    {
        for(int x:ned[i])
            ans[++st]=(ok){1,x,0},q1.push((node){st,1});
        while((int)q1.size()>1)
        {
            node x=q1.top();q1.pop();
            node y=q1.top();q1.pop();
            ans[++st]=(ok){2,x.l,y.l};
            q1.push((node){st,x.len+y.len});
        }
        int L=q1.top().len;
        q2.push(q1.top());
        q1.pop();
        if(i<k) ans[st+1]=(ok){3,st,1},++st,q1.push((node){st,L});
    }
    while((int)q2.size()>1)
    {
        node x=q2.top();q2.pop();
        node y=q2.top();q2.pop();
        ans[++st]=(ok){2,x.l,y.l};
        q2.push((node){st,x.len+y.len});
    }
    write(st),putchar('\n');
    for(int i=1;i<=st;i++)
    {
        write(ans[i].op),putchar(' ');
        write(ans[i].x),putchar(' ');
        if(ans[i].op>1) write(ans[i].y);
        putchar('\n');
    }
    return 0;
}
~~~

亿点玄学，欢迎 hack。

---

## 作者：Harry27182 (赞：3)

赛时队友把这题丢给我说他们去写 B，然后我成功成为了战犯。

首先考虑一个朴素的暴力，建出一个类似线段树的结构。然后每次合并两个儿子节点，操作次数为 $n\log n$，大约需要 1e7 次操作，不能通过。

这时候有一个思路，如果一个区间里的东西比较满，就会让它很慢。但是如果区间比较满，那么重复位置的元素比较多，就可以先处理一半然后平移出来，然后合并三个块，但是要合并的块数变成了三个，比较不好实现（并且预计是常数比较大的 $\frac{1}{2}\log n$），我赛时并没有成功实现这个做法，如果它能过或者不能过可以在评论区留言。

另一种想法是考虑平衡复杂度。具体的，我们选取一个比较小的 $B$ ，那么长度为 $B$ 的区间种类为 $2^B$ 也不会很大。我们考虑对于每一种长度为 $B$ 的区间处理出他们是 1 的位中某一位的集合，那么通过平移就可以得到其他位的集合，这部分的操作次数是 $\frac{n}{B}\log n+n$。然后我们现在有 $B2^B$ 个区间，将他们用类似于合并果子的思路合并，操作次数不超过 $n\log {B2^B}$。取 $B=\sqrt {\log n}$，操作次数为 $n\sqrt{\log n}$，可以通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{int op,x,y;};vector<node>ans;
int siz[1000005],a[500005],n;char s[500005];vector<int>g;vector<int>v[105];
int solve(int l,int r)
{
	if(l==r){ans.emplace_back(node{1,g[l],0});siz[ans.size()]=1;return ans.size();}
	int mid=(l+r)>>1;
	int x=solve(l,mid),y=solve(mid+1,r);
	ans.emplace_back(node{2,x,y});siz[ans.size()]=siz[x]+siz[y];
	return ans.size();
}
int main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin>>n>>(s+1);
    for(int i=1;i<=n;i++)a[i]=s[i]-'0';
	int B=5;
	for(int i=1;i<=n;i+=B)
	{
		int now=0;
		for(int j=i;j<i+B;j++)now=(now<<1)+a[j];
		v[now].emplace_back(i);
	}
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
	for(int j=1;j<(1<<B);j++)
	{
		g.clear();int pos=0;
		for(int i=0;i<v[j].size();i++)
		{
			for(int k=B-1;k>=0;k--)if(j&(1<<k)){g.emplace_back(v[j][i]+B-1-k);pos=k;break;}
		}
		if(!g.size())continue;
		int now=solve(0,g.size()-1);q.push(make_pair(siz[now],now));
		for(int k=pos-1;k>=0;k--)if(j&(1<<k))
		{
			ans.emplace_back(node{3,now,pos-k});
			siz[ans.size()]=siz[now];q.push(make_pair(siz[now],ans.size()));
		}
	}
	while(q.size()>1)
	{
		int x=q.top().second;q.pop();int y=q.top().second;q.pop();
		ans.emplace_back(node{2,x,y});
		siz[ans.size()]=siz[x]+siz[y];
		q.push(make_pair(siz[ans.size()],ans.size()));
	}
	cout<<ans.size()<<'\n';
	for(int i=0;i<ans.size();i++)
	{
		if(ans[i].op==1)cout<<ans[i].op<<' '<<ans[i].x<<'\n';
		else cout<<ans[i].op<<' '<<ans[i].x<<' '<<ans[i].y<<'\n';
	}
	return 0;
}
```

---

## 作者：thousands_of_years (赞：3)

~~没听懂 dottle 的讲课时讲的，QQ 上搞懂后来造福后人。~~

## Solution

注意到朴素的启发式合并是 $O(n \log n)$ 的。无法通过，考虑使用 $\log n$ 分块。
将序列每 $B$ 个分块，所以一共有 $2^B$ 种块，将所有块按种类分组。

关于一种块，你将它所有出现位置记录下来了，然后对出现这种块的第一个出现 $1$ 位置进行启发式合并。

为什么这么做呢，启发式合并完后，我们可以通过平移这个得到的集合，使这种块的每个 $1$ 位置都有覆盖。
![](https://cdn.luogu.com.cn/upload/image_hosting/9xmchtuw.png)

如图所示，我们设 $B$ 为 $3$，我们发现第 $1,3,4$ 个块属于同一种块，我们对于这种块第一个出现 $1$ 位置，即一号位置进行合并，就是将图上 $1,7,10$ 号位置进行合并，我们通过平移该集合，可以得到图中 $3,9,12$ 号位置，这样我们就创造出这种块所需所有集合。再进行启发式合并一下，这种块的集合就求到了。

接着，将每种块的集合启发式合并即可。

再来分析一下所需集合大小。

对于每种块，启发式合并出其起始位置的集合是 $O(\frac{n \log n}{B})$ 的，再用 $3$ 操作平移，然后用 $2$ 操作合并是 $O(n \log B)$。

把各种类型的块合并到一起又是 $O(n \log 2^B)=O(nB)$。

取 $B=\sqrt{\log n}$ 可以达到 $O(n\sqrt{\log n})$ 的复杂度。

## code

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N=5e6+9,B=4;
char s[N];
int cnt=0;
struct node{
	int opt,x,y;
}e[N];
vector<int> vv[N];
int ss[N],lenn[N];
void merge(int u)
{
	if(vv[u].empty()) return ;
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > q;
	for(int v:vv[u])
	{
//		cout<<v<<"!";
		q.push({1,++cnt});
		e[cnt]={1,v,0};
	}
	while(q.size()!=1)
	{
		int u1=q.top().second,len1=q.top().first;
		q.pop();
		int u2=q.top().second,len2=q.top().first;
		q.pop();
		q.push(make_pair(len1+len2,++cnt));
		e[cnt]={2,u1,u2};
	}
	int len=q.top().first,pos=cnt;
	q.pop();
	for(int j=1;j<=B;j++)
	{
		if(u&(1<<(j-1)))
		{
			q.push({len,++cnt});
			e[cnt]={3,pos,j-1};
		}
	}
	while(q.size()!=1)
	{
		int u1=q.top().second,len1=q.top().first;
		q.pop();
		int u2=q.top().second,len2=q.top().first;
		q.pop();
		q.push(make_pair(len1+len2,++cnt));
		e[cnt]={2,u1,u2};
	}
	ss[u]=cnt;
	lenn[u]=q.top().first;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	cin>>(s+1);
	for(int i=1;i<=n;i+=B)
	{
		int vall=0;
		for(int j=1;j<=B;j++)
		{
			if(s[j+i-1]=='1')
			vall+=(1<<(j-1));
		}
//		cout<<vall<<"!!!!!";
		vv[vall].push_back(i);
	}
	for(int i=1;i<(1<<B);i++)
	{
		merge(i);
	}
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > q;
	for(int i=1;i<(1<<B);i++)
	{
		if(ss[i]!=0)
		{
			q.push({lenn[i],ss[i]});
		}
	}
	while(q.size()!=1)
	{
		int u1=q.top().second,len1=q.top().first;
		q.pop();
		int u2=q.top().second,len2=q.top().first;
		q.pop();
		q.push(make_pair(len1+len2,++cnt));
		e[cnt]={2,u1,u2};
	}
	cout<<cnt<<endl;
	for(int i=1;i<=cnt;i++)
	{
		if(e[i].opt==1)
		{
			cout<<1<<" "<<e[i].x<<endl;
		}
		else
			cout<<e[i].opt<<" "<<e[i].x<<" "<<e[i].y<<endl;
	}
	return 0;
}
```

---

## 作者：vzcx_host (赞：2)

本文所述的所有做法操作次数均为 $n+\text{常数}$，为了方便，我们用字母 $W$ 表示一个做法的代价。

考虑一个非常经典的暴力：对于 $1\sim n$ 中的所有数，依次判断其在不在集合 $T$ 中，若在则将这个数暴力加入 $S$。

这个做法的 $W$ 为 $n^2$ 级别，显然会吃罚时。

发现这个做法可以优化，具体的，我们可以用类似线段树的结构合并来降低复杂度，例如 $T=\{1,2,3,4,5,6,7,8\}$ 时，我们可以先构造出 $A=\{1,2,3,4\},B=\{5,6,7,8\}$，再合并 $A,B$。

这个做法的 $W$ 为 $n\log n$ 级别，常数为 $1$，算出来 $W$ 约为 $10^7$，还是会吃罚时。

发现我们没有用到操作 $3$，考虑如何使用操作 $3$ 降低常数，如果我们规定 $x$ 在集合 $T$ 中 $x+1$ 就一定不在集合 $T$ 中的话常数天然减半，而如果 $x+1$ 在集合 $T$ 中的话我们可以将 $x$ 和 $x+1$ 配对，设配对的 $x$ 构成的集合为集合 $A$，配对的 $x+1$ 构成的集合为集合 $B$，未配对的数构成的集合为集合 $C$，那么我们分别构造出 $A,C$，对 $A$ 进行一次加 $1$ 的操作 $3$ 即可得到集合 $B$，暴力合并 $A,B,C$ 即可得到 $T$。

这个做法的 $W$ 为 $n\log n$ 级别，由于 $|A|+|C|\le 0.5n$，所以常数为 $0.5$，看起来可以了，但事实告诉我们会吃罚时，为什么呢，精确估计一下，用 $A$ 生成 $B$ 与暴力合并 $A,B,C$ 的代价和最多为 $2n$，$W=0.5n\log (0.5n)+2n=2.5\times 10^5\times 18+5\times 10^5\times 2=5.5\times 10^6$，完蛋。

充分发扬“一次不行就两次，二分不行就三分”的优良传统，对于 $x$ 按照 $x+1,x+2$ 这两个数在不在 $T$ 中的标准分 $4$ 类，每类分开构造然后合并，所有类的大小之和不超过 $\lceil\frac{n}{3}\rceil$，构造的代价为 $\frac{n}{3}\times\log\frac{n}{3}=4.5\times 10^6$ 级别，合并的代价只要常数别太离谱就行。

不想去翻赛时代码，就不放了。

---

## 作者：Rubidium_Chloride (赞：2)

事情是这样的，小 rc 整 E 自闭了，于是去开题。

然后看到了 I 这么一个题面非常简短的题目。

然后开始瞎搞。

第一步是我们发现 $O(n\log n)$ 的代价可以过掉 1 的个数 $\le 2.5\times 10^5$ 这部分可以直接用线段树的合并方式写过去。

第二步是我们发现 $>2.5\times 10^5$ 的时候要求构造的集合 1 的密度偏大，于是我们考虑如果有连续两个 1 我们把它整合在一起（即只考虑一个）然后用平移操作处理，其他的还是线段树。

写完代码发现这玩意跑不过去！大概多个 $5\times 10^5$ 的代价。

但是随机了一堆数据发现能跑过 $3.5\times 10^5$ 个 1。

第三步是我们如法炮制，发现这个时候 1 的密度变得更大了。所以我们考虑三个 $1$ 连在一起的情况，然后再考虑两个，然后再考虑一个。

然后这玩意就非常顺利地跑过了随机数据，1 的个数 $>2.5\times 10^5$ 大概代价在 $4\times 10^6$ 以下。 

然后啪的一下提交了上去，就过了。

然后我一直以为这个就是出题人想要让你干的事情。

然后赛后看到某个群里在讨论 THUPC，然后我问了一句 I 为啥这么少人过，小 E 说这题正解是四毛子分治，定位是后期题。

反正我也没搞懂这是个啥东西，我只知道三次平移能做这个题。

所以，如果你的复杂度比较优秀的话（指 $O(n\log n)$），请相信你的常数（指瞎搞）。

[代码](https://www.luogu.com.cn/paste/6lwy9rch)是一坨屎山，但是总归不到 3K。



---


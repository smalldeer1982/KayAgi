# [THUPC 2024 初赛] 套娃

## 题目描述

我们定义一个集合的 $\operatorname{mex}$ 是最小的不在 $S$ 中的非负整数。

给定一个序列 $a_1,\dots,a_n$，对于每个 $1\leq k\leq n$，我们按照如下方式定义 $b_k$：

- 对于 $a$ 的所有长为 $k$ 的子区间，求出这个子区间构成的数集的 $\operatorname{mex}$。
- 对于求出的所有 $\operatorname{mex}$，求出这个数集自己的 $\operatorname{mex}$，记为 $b_k$。

请你求出序列 $b$。


## 说明/提示

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
6
0 0 0 1 2 3
```

### 输出

```
2 3 4 0 0 0
```

# 题解

## 作者：lsj2009 (赞：15)

### 闲话

膜你赛刚做过类似的 trick，结果马上就用上了/jy

场上一下子就切了，没吃罚时，很爽！

### Solution

#### 结论

先说一个经典（？结论：

方便起见，先下一个定义：

> 我们称满足 $\text{mex}(l,r)=x$ 的区间为 $x\text{-mex}$ 区间。
>
>对于一个 $x\text{-mex}$ 区间 $[l,r]$，如果不存在另一个 $x\text{-mex}$ 区间 $[l',r']\subset[l,r]$，则称 $[l,r]$ 为『极小的 mex 区间』。
>

- 则有结论：极小的 mex 区间只有 $\Theta(n)$ 个；具体的，一个上界是 $2n$。

- 证明：对于一个满足条件的『极小的 mex 区间』$[l,r]$ 显然满足 $a_l\ne a_r$，否则删任意一个不影响答案，不妨假设 $a_l>a_r$，则 $a_r$ 和 $a_l$ 的加入先后影响了 $\text{mex}(l,r)$ 的答案，则可以得到的是：$\text{mex}(l+1,r-1)=a_r$，由于当 $l$ 固定时 $\text{mex}$ 单调不降，且有多个满足他条件的 $r$ 只取最左边那个，所以对于任意的 $l$ 只有一个 $r$ 满足条件；同理，对于 $a_l<a_r$ 的情况，对于每个 $r$ 也至多只有一个 $l$ 满足条件，故最多只有 $2n$ 个『极小的 mex 区间』。

#### 求『极小的 mex 区间』

然后我们考虑知道了这么一个性质只会要怎么做。

那么我们首先要把所有极小的 mex 区间给掏出来，这个好像说是有什么『阶梯状』的东西，和同学们讨论了一下，不是很懂（或者说感觉不是很好维护），这里讲一个比较脑瘫的求法。如果说你会比较优雅的求法，那么可以选择跳过。

假设我们已经求出 $\text{mex}=1\sim x-1$ 的答案，我们考虑如何推出 $\text{mex}=x$ 的答案。

那么一个比较显然的结论是：$\text{mex}=x$ 的一个答案区间必然是往 $\text{mex}=y(y<x)$ 的一个答案区间两边加上了 $y\sim x-1$ 然后得到。

然后我们就得到了一个求『极小的 mex 区间』的算法：

- 预处理出极小的 $0\text{-mex}$ 和 $1\text{-mex}$ 区间。
- 对于每一个极小的 $(x-1)\text{-mex}$ 区间分别求出其距离左端点最近的 $x-1$ 出现位置，和距离右端点最近的 $x-1$ 出现位置，形成两个新的区间，算一下两个区间的 $\text{mex}=x'$，然后丢到对应的存储 $x'\text{-mex}$ 区间的 ``vector`` 里。
- 对于存储 $x\text{-mex}$ 区间的 ``vector`` 求极小区间。

由于最终答案是 $2n$ 级别的，所以任何时刻的区间个数不会超过 $4n$ 级别，复杂度是 $\Theta(n\log{n})$。

对于实现细节：

- 求在某个点左/右侧最近的 $=x$ 的点：开 $n$ 个 ``vector``，分别存储每个数的出现位置，``vector`` 上二分即可。

- 在线求区间 mex：这个也就是 P4137，主席树即可，不再赘述。

#### 计算答案

我们考虑对于每个『极小的 $x\text{-mex}$ 区间』$S$ 求出其对应的『极大的 $x\text{-mex}$ 区间』$S'$。

则对于任意 $k\in[|S|,|S'|]$ 的集合都可以拥有 $x$ 这个数，我们考虑把区间 $[|S|,|S'|]$ 推平成 $1$。

然后对于最终为 $0$ 的点显然 mex 不大于 $x$。

则我们倒着枚举 $x$，每次将其为 $0$ 的点在答案序列上位置修改成 $x$，最终即为答案。

至于区间推平，ODT 即可。

需要注意的是，这里 ODT 复杂度不依赖于随机，而依赖于均摊。

具体的，每次未被推平成 $0$ 的节点构成了若干个区间，区间总数至多为 $|S_x|+1$ 个（$S_x$ 表示『极小的 $x\text{-mex}$ 区间』个数），由于 $\sum |S_x|\le 2n$，所以总共不会被推平超过 $3n$ 次。

最终复杂度 $\Theta(n\log{n})$。

常数看起来很大，但是实际上跑得很快，不是很懂。

### Code

```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define ull unsigned long long
#define ld long double
#define PII pair<int,int>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
bool M1;
void file_IO() {
//	freopen("mushroom.in","r",stdin);
//	freopen("mushroom.out","w",stdout);
}
const int N=1e5+5;
int a[N],n,q;
vector<int> vec[N];
vector<PII> g[N];
inline int pre(const vector<int> &vec,const int& x) {
	auto p=upper_bound(vec.begin(),vec.end(),x);
	if(p!=vec.begin())
		return *(--p);
	return -1;
}
inline int nxt(const vector<int> &vec,const int& x) {
	auto p=lower_bound(vec.begin(),vec.end(),x);
	if(p!=vec.end())
		return *p;
	return -1;
}
struct PSGT {
	struct node {
		int lson,rson,val;
	}; node tree[N*20];
	int p;
	inline int new_node(const int& k) {
		tree[++p]=tree[k];
		return p;
	}
	inline void push_up(const int& k) {
		tree[k].val=min(tree[tree[k].lson].val,tree[tree[k].rson].val);
	}
	void update(int &k,const int& l,const int& r,const int& qx,const int& val) {
		k=new_node(k);
		if(l==r) {
			tree[k].val=val;
			return;
		}
		int mid=(l+r)>>1;
		if(qx<=mid)
			update(tree[k].lson,l,mid,qx,val);
		if(qx>=mid+1)
			update(tree[k].rson,mid+1,r,qx,val);
		push_up(k);
	}
	int query(const int& k,const int& l,const int& r,const int& ql,const int& qr) {
		if(l==r)
			return l;
		int mid=(l+r)>>1,val=tree[tree[k].lson].val;
		if(val<ql)
			return query(tree[k].lson,l,mid,ql,qr);
		return query(tree[k].rson,mid+1,r,ql,qr);
	}
	int root[N],cnt;
	inline void ins(const int& x) {
		++cnt;
		root[cnt]=root[cnt-1];
		update(root[cnt],0,n,x,cnt);
	}
}; PSGT T2;
inline int mex(const int& l,const int& r) {
	return T2.query(T2.root[r],0,n,l,r);
}
struct ODT {
	struct node {
		int l,r;
		mutable int val;
		node() {
			l=r=val=0;
		}
		node(int _l,int _r,int _val) {
			l=_l; r=_r; val=_val;
		}
		bool operator < (const node &tmp) const {
			return l<tmp.l;
		}
	}; set<node> s;
	ODT() {
		s.clear();
		s.insert(node{1,n,0});
	}
	auto split(int pos) {
		auto p=s.lower_bound(node(pos,0,0));
		if(p!=s.end()&&(*p).l==pos)
			return p;
		--p;
		if((*p).r<pos)
			return s.end();
		int l=(*p).l,r=(*p).r,val=(*p).val;
		s.erase(p);
		s.insert(node(l,pos-1,val));
		auto t=s.insert(node(pos,r,val));
		return t.first;
	}
	void assign(int l,int r,int val) {
		auto _r=split(r+1),_l=split(l);
		s.erase(_l,_r);
		s.insert(node(l,r,val));
	}
	auto ins(int p,int val) {
		auto t=s.insert(node(p,p,val));
		return t.first;
	}
}; ODT T,T1;
int ans[N];
inline void solve() {
	scanf("%d",&n);
	rep(i,1,n) {
		scanf("%d",&a[i]);
		vec[a[i]].push_back(i);
		T2.ins(a[i]);
	}
	rep(i,1,n) {
		if(a[i])
			g[0].push_back({i,i});
		else
			g[1].push_back({i,i});
	}
	rep(i,1,n) {
		for(auto x:g[i-1]) {
			int l=x.first,r=x.second;
			int pl=pre(vec[i-1],l),pr=nxt(vec[i-1],r);
			if(pl!=-1)
				g[mex(pl,r)].push_back({pl,r});
			if(pr!=-1)
				g[mex(l,pr)].push_back({l,pr});
		}
		sort(g[i].begin(),g[i].end(),[](const PII &a,const PII &b) {
			return a.first>b.first||(a.first==b.first&&a.second<b.second);
		});
		vector<PII> tmp;	
		int last=INF;
		for(auto x:g[i]) {
			if(last>x.second)
				tmp.push_back(x);
			chkmin(last,x.second);
		}
		swap(g[i],tmp);
	}
	T1=ODT();
	per(i,n+1,0) {
		T=ODT();
		for(auto x:g[i]) {
			int l=x.first,r=x.second;
			int pl=pre(vec[i],l),pr=nxt(vec[i],r);
			if(pl==-1)
				pl=1;
			else
				++pl;
			if(pr==-1)
				pr=n;
			else
				--pr;
			T.assign(r-l+1,pr-pl+1,1);
		}
		for(auto x:T.s) {
			int l=x.l,r=x.r,val=x.val;
			if(!val)
				T1.assign(l,r,i);
		}
	}
	for(auto x:T1.s) {
		int l=x.l,r=x.r,val=x.val;
		rep(i,l,r)
			printf("%d ",val);
	}
}
bool M2;
signed main() {
	file_IO();
	int testcase=1;
	//scanf("%d",&testcase);
	while(testcase--)
		solve();
//	cerr<<"used time = "<<1000.0*clock()/CLOCKS_PER_SEC<<"ms\n";
//	cerr<<"used memory = "<<(&M1-&M2)/1024/1024<<"MB\n";
	return 0;
}
```

---

## 作者：masterhuang (赞：13)

推销[博客](https://www.cnblogs.com/HaHeHyt/p/17773631.html)！第 $10$ 篇。

前置知识：[P4137](https://www.luogu.com.cn/problem/P4137) 的在线单次 $O(\log n)$ 求区间 $\text{mex}$ 做法，[CF1870E](https://www.luogu.com.cn/problem/CF1870E) 的结论。

赛事做繁了，没冲出来。发现第二篇题解难理解，第一篇题解有个细节繁了，于是我结合了一下。除去主席树板子，代码非常短。
  
这篇题解是目前第一篇题解和第二篇的结合，由重合请见谅。
  
如果不想看结论证明直接忽略即可，没啥影响。
 
---
  
称 $[l,r]$ 是极小区间，当且仅当不存在 $[L,R]\varsubsetneq[l,r]$，$\text{mex}(l,r)=\text{mex}(L,R)$。则有结论：极小区间只有 $O(n)$ 个。
  
- 证明：设 $[l,r]$ 是极小区间，则显然 $a_l\neq a_r$，不妨设 $a_l>a_r$，则由于删掉端点 $\text{mex}$ 要变化，于是 $\text{mex}(l,r)>a_l>a_r$。若存在 $r_1>r$，$[l,r_1]$ 是极小区间，则 $\text{mex}(l,r)\ge a_l>a_{r_1}$，于是 $a_{r_1}$ 在 $[l,r]$ 中出现过。于是删去 $a_{r_1}$，$\text{mex}$ 不变。于是固定 $l$，$a_l>a_r$ 的情况只对应一个 $r$，所以只有 $O(n)$ 个了。
  
---
考虑如何求所有极小区间。如果直接按证明方法求是非常难写的。于是考虑巧妙方法。
  
设 $\text{mex}(l,r)=x$，则称 $[l,r]$ 为 $\text{mex}_x$ 区间。
  
考虑一个 $\text{mex}_x$ 的极小区间，同样不妨设 $a_l>a_r$，则由于极小性，于是 $a_r$ 在 $(l,r)$ 中没有出现。
  
考虑删去 $a_l$ 之后，$\text{mex}$ 变为 $a_l$，不妨设 $\text{mex}_{a_l}$ 区间 $[l+1,r]$ 对应的极小子区间为 $[L,R]$，则 $a_r$ 一定在 $[L,R]$ 中出现，于是 $R=r$。
  
- 这说明：$\text{mex}_x$ 区间必定为一个 $\text{mex}_{t}$ 区间向**一端**扩展到**第一个**数 $t$ 得到。其中 $x>t$。
                                                                                  
---                                                                                  
考虑从 $x=0\to n+1$ 依次求出所有 $\text{mex}_x$ 极小区间。对于每个 $x$ 维护 $\text{mex}_x$ 极小区间的 **vector**。

每次先把所有 $\text{mex}_{x-1}$ 区间进行如上扩展，设一个扩展完后 $\text{mex}=y$，则把新区间丢到 $y$ 的 **vector** 里。这里求扩展完的 $\text{mex}$ 用上面说的单次 $O(\log n)$ 的方法。
  
这时候所有 $\text{mex}_x$ 极小区间都在 $x$ 的 **vector** 里了，但注意扩展完的不一定都是极小的，于是排除掉即可。就不多不少的求出了 $\text{mex}_x$ 极小区间，一直做下去即可。记得初始化极小 $\text{mex}_{0/1}$ 区间。
  
由于极小区间总共只有 $O(n)$ 个，乘上求区间 $\text{mex}$ 的 $\log$，于是复杂度为 $O(n\log n)$。
  
---
  
求出所有极小区间后，考虑所有对应 $\text{mex}_x$ 的极小子区间 $[l,r]$ 的大区间的形态。
  
设 $l$ 左侧第一个 $x$ 的位置为 $L-1$，$r$ 右侧第一个 $x$ 的位置为 $R+1$。
  
则所有对应的大区间为：左端点在 $[L,l]$，右端点在 $[r,R]$ 的所有区间。于是 $\forall len\in [r-l+1,R-L+1]$，存在长为 $len$ 的区间 $\text{mex}=x$。
  
于是问题就转化成了：维护 $n$ 个集合，区间插入一个数，最终对所有集合求 $\text{mex}$。把插入操作差分，用一个 **set** 动态维护 $\text{mex}$ 即可。具体看代码。
  
代码：
  
```cpp
#include<bits/stdc++.h>
#define LL long long
#define P pair<int,int>
#define fi first
#define se second
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int N=1e5+5;
int n,V,a[N],cnt[N],tot,rt[N];
vector<int>g[N],ad[N],dl[N];vector<P>h[N];
namespace MEX
{
	struct node{int ls,rs,x;}b[N*25];
	void build(int l,int r,int &wz)
	{
		b[wz=++tot]={0,0,0};if(l==r) return;
		int mid=(l+r)>>1;build(l,mid,b[wz].ls);build(mid+1,r,b[wz].rs);
	}
	void updata(int l,int r,int &wz,int wz1,int x,int y)
	{
		b[wz=++tot]=b[wz1];if(l==r) return b[wz].x=y,void();
		int mid=(l+r)>>1;
		if(x<=mid) updata(l,mid,b[wz].ls,b[wz1].ls,x,y);
		else updata(mid+1,r,b[wz].rs,b[wz1].rs,x,y);
		b[wz].x=min(b[b[wz].ls].x,b[b[wz].rs].x);
	}
	int query(int l,int r,int wz,int x)
	{
		if(l==r) return l;int mid=(l+r)>>1;
		if(b[b[wz].ls].x<x) return query(l,mid,b[wz].ls,x);
		return query(mid+1,r,b[wz].rs,x);
	}
	inline int que(int l,int r){return query(0,V,rt[r],l);}
}using MEX::que;
int vis[1005][1005];
inline void add(int l,int r,int L,int R,int x){ad[L-r+1].push_back(x);dl[R-l+2].push_back(x);}
inline void getans()
{
	set<int>S;for(int i=0;i<=n;i++) cnt[i]=0,S.insert(i);
	for(int i=1;i<=n;i++)
	{
		for(int j:ad[i]) if(!cnt[j]++) S.erase(j);
		for(int j:dl[i]) if(!--cnt[j]) S.insert(j);cout<<*S.begin()<<" ";
	}
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>n;
	V=n+3;for(int i=0;i<=V;i++) g[i].push_back(0);
	for(int i=1;i<=n;i++) cin>>a[i],g[a[i]].push_back(i);
	MEX::build(1,V,rt[0]);for(int i=1;i<=n;i++) MEX::updata(0,V,rt[i],rt[i-1],a[i],i);
	for(int i=0;i<=V;i++) g[i].push_back(n+1);
	for(int i=1;i<=n;i++) a[i]?h[0].push_back({i,i}):h[1].push_back({i,i});
	for(int i=1;i<=V;i++)
	{
		for(auto [l,r]:h[i-1])
		{
			#define all g[i-1].begin(),g[i-1].end()
			int L=*(--lower_bound(all,l)),R=*upper_bound(all,r);
			if(L) h[que(L,r)].push_back({L,r});
			if(R<=n) h[que(l,R)].push_back({l,R});
		}sort(h[i].begin(),h[i].end(),[](P x,P y){return x.fi==y.fi?x.se<y.se:x.fi>y.fi;});
		vector<P>G;int las=2e9;
		for(auto [l,r]:h[i]) if(las>r) G.push_back({l,r}),las=r;swap(G,h[i]);
	}
	for(int i=0;i<=V;i++)
		for(auto [l,r]:h[i])
			#define all g[i].begin(),g[i].end()
			add(*(--lower_bound(all,l))+1,l,r,*upper_bound(all,r)-1,i);
	return getans(),0;
}
```

---

## 作者：min_inf (赞：7)

似乎之前看到类似的东西都是一堆神秘分裂什么的，一直没搞懂，场上看到比较慌，不过胡出了一个似乎更好写的做法。

有个结论是区间 $\operatorname{mex}$ 在平面上的矩形个数是 $O(n)$ 的，下面是构造性证明。

倒着求，先预处理每个后缀的 $\operatorname{mex}$。维护每个起点的 $\operatorname{mex}$，考虑后面删一个数产生的影响，记 $lst_i=\max\limits_{j<i,a_j=a_i}j$（没有记为 $0$），那么只有 $lst_i$ 之后的 $\operatorname{mex}$ 才会产生影响，实际上就是对 $a_i$ 取 $\min$。由于 $\operatorname{mex}$ 是单调的，直接开颗 ODT 暴力删即可，显然均摊 $O(n)$。对应区间容易求出。

接下来就好做了。对于每个矩形，记左端点在 $[l_1,r_1]$ 内，右端点在 $[l_2,r_2]$ 内，那能产生影响的区间就是 $[l_2-r_1+1,r_2-l_1+1]$，扫一遍就行。

赛时代码：

```cpp
namespace KnownError_{
    constexpr int N = 1e5+5;
    int n,a[N];
    vector<int> ea[N],ed[N];
    void add_rect(int l1,int r1,int l2,int r2,int x){
        ea[l2-r1+1].push_back(x);
        ed[r2-l1+2].push_back(x);
    }
    int cnt[N],mex;
    int pos[N],lst[N];
    struct node{
        mutable int l,r,v,t;
        bool operator<(const node &o)const{
            return l<o.l;
        }
    };
    set<node> se;
    auto split(int pos){
        auto it=se.lower_bound({pos,0,0,0});
        if(it!=se.end()&&it->l==pos)return it;
        --it;
        int l=it->l,r=it->r,v=it->v,t=it->t;
        se.erase(it);
        se.insert({l,pos-1,v,t});
        return se.insert({pos,r,v,t}).first;
    }
    void main(){
        cin>>n;
        rep(i,1,n)cin>>a[i];
        per(i,n,1){
            ++cnt[a[i]];
            while(cnt[mex])++mex;
            se.insert({i,i,mex,n});
        }
        rep(i,1,n){
            lst[i]=pos[a[i]];
            pos[a[i]]=i;
        }
        se.insert({n+1,n+1,-1,-1});
        per(i,n,1){
            auto it=split(i+1);
            if(i<n)add_rect(i+1,i+1,i+1,it->t,it->v);
            it->v=it->t=-1;
            it=split(lst[i]+1);
            int r=lst[i];
            while(it->v>a[i]){
                auto lst=it++;
                add_rect(lst->l,lst->r,i,lst->t,lst->v);
                r=lst->r;
                se.erase(lst);
            }
            if(r>lst[i])se.insert({lst[i]+1,r,a[i],i-1});
        }
        for(auto x:se)
            if(~x.t){
                add_rect(x.l,x.r,1,x.t,x.v);
            }
        set<int> se;
        rep(i,0,n)cnt[i]=0,se.insert(i);
        rep(i,1,n){
            for(auto x:ea[i]){
                if(!cnt[x]++)se.erase(x);
            }
            for(auto x:ed[i]){
                if(!--cnt[x])se.insert(x);
            }
            cout<<*se.begin()<<' ';
        }
        cout<<'\n';
    }
}
```


---

## 作者：Masterwei (赞：5)

除了一个 trick 之外都挺简单的。

首先就是这个性质：

我们设二元组 $(l,r)$ 表示不存在 $[l,r]$ 的子区间（不为它本身）的 mex 不为 $[l,r]$ 的 mex，那么 $(l,r)$ 的个数是 $2n$ 级别的。

证明可以参考 [CF1870D](https://www.luogu.com.cn/problem/CF1870E)。

于是我们可以考虑找出这些二元组。

首先 mex 为 $0$ 和 $1$ 的可以预处理。

然后可以发现除此之外的一个合法的二元组一定是从另一个合法二元组拓展而来的。

具体的：我们现在有一个二元组 $(l,r)$，设它的 mex 为 $val$，那么我们在 $l$ 的左边或者 $r$ 的右边找最近的 $k$，使得 $a_k=val$，那么区间 $[k,r]$ 或 $[l,k]$ 才可能成为新的满足条件的二元组。

然后我们对于每个二元组可以求出最大的区间长度使得 mex 值依旧不变，然后差分一下，扫描线扫一遍用值域线段树维护 mex 就做完了。


```cpp
#include<bits/stdc++.h>
#define fir first
#define sec second
using namespace std;
inline int read(){
	int x=0;bool f=0;char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
const int Maxn=1e5+5;
int n,a[Maxn];
vector<pair<int,int> >g[Maxn];
struct Tree{
	int ls,rs,data;
}t[Maxn*50];
int root[Maxn],cnt;
void change(int&x,int y,int l,int r,int d,int p){
	x=++cnt;t[x]=t[y];if(l==r)return void(t[x].data=p);
	int mid=l+r>>1;
	if(mid>=d)change(t[x].ls,t[y].ls,l,mid,d,p);
	else change(t[x].rs,t[y].rs,mid+1,r,d,p);
	t[x].data=min(t[t[x].ls].data,t[t[x].rs].data);
}
int query(int x,int l,int r,int L){
	if(l==r)return l;
	int mid=l+r>>1;
	if(t[t[x].ls].data>=L)return query(t[x].rs,mid+1,r,L);
	return query(t[x].ls,l,mid,L);
}
inline int query(int l,int r){return query(root[r],0,n+1,l);}
vector<int>ww[Maxn];
vector<int>G[Maxn];
int cntt[Maxn];
struct seg{
	int t[Maxn<<2];
	void change(int x,int l,int r,int d,int p){
		t[x]+=p;if(l==r)return;
		int mid=l+r>>1;
		if(mid>=d)change(x<<1,l,mid,d,p);
		else change(x<<1|1,mid+1,r,d,p);
	}
	int query(int x,int l,int r){
		if(l==r)return l;
		int mid=l+r>>1;
		if(t[x<<1]==mid-l+1)return query(x<<1|1,mid+1,r);
		return query(x<<1,l,mid);
	}
}T;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();while(cnt)t[cnt--]={0,0,0};
	ww[0].clear();g[0].clear();
	for(int i=1;i<=n;i++)a[i]=read(),change(root[i],root[i-1],0,n+1,a[i],i);
	g[n+1].clear();
	for(int i=1;i<=n;i++)ww[a[i]].push_back(i);
	for(int i=1;i<=n;i++){
		if(a[i]!=0)g[0].push_back(make_pair(i,i));
		if(a[i]==0)g[1].push_back(make_pair(i,i));
	}
	for(int i=0;i<=n+1;i++){
		sort(g[i].begin(),g[i].end(),[&](pair<int,int>a,pair<int,int>b){return a.fir==b.fir?a.sec<b.sec:a.fir>b.fir;});
		vector<pair<int,int> >tmp;
		int R=1e9+7;
		for(pair<int,int>j:g[i])if(j.sec<R)tmp.push_back(j),R=j.sec;
		swap(tmp,g[i]);
		for(pair<int,int>tmp:g[i]){
			int L=lower_bound(ww[i].begin(),ww[i].end(),tmp.fir)-ww[i].begin()-1;
			int R=upper_bound(ww[i].begin(),ww[i].end(),tmp.sec)-ww[i].begin();
			if(~L)g[query(ww[i][L],tmp.sec)].push_back(make_pair(ww[i][L],tmp.sec)),L=ww[i][L]+1;
			else L=1;
			if(R<ww[i].size())g[query(tmp.fir,ww[i][R])].push_back(make_pair(tmp.fir,ww[i][R])),R=ww[i][R]-1;
			else R=n;
			G[tmp.sec-tmp.fir+1].push_back(i+1);
			G[R-L+2].push_back(-i-1);
//			printf("fewfew %d %d %d\n",tmp.sec-tmp.fir+1,R-L+1,i);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j:G[i]){
			if(j>0){
				j--;
				if(!cntt[j]++)T.change(1,0,n+1,j,1);
			}else{
				j=-j;
				j--;
				if(!--cntt[j])T.change(1,0,n+1,j,-1);
			}
		}
		printf("%d ",T.query(1,0,n+1));
	}
	return 0;
}

```

---

## 作者：bochibochi (赞：4)

首先我们考虑如何求区间 $\rm mex$，可以在扫描线扫右端点的过程中，用权值线段树维护每个值最后一次出现的位置，查询就在线段树上二分出第一个最后一次出现位置小于 $l$ 的值。

这里需要用到一个结论：如果将区间 $[l,r]$ 视作平面上的一个点，点的颜色是这个区间的 $\rm mex$，那么这个平面有 $\mathcal O(n)$ 个矩形构成。

证明也很简单，考虑在扫描线扫右端点时，我们每往右侧加入一个数 $x$，会让原本一段 $\rm mex$ 为 $x$ 的区间分裂或不变，由于每次这段的 $\rm mex$ 都会增加，所以不变的次数最多有 $\mathcal O(n)$ 次，并且最多有 $n$ 个连续段。然后右边至多会多出一个连续段。每次连续段的 $\rm mex$ 变化都会在平面上新增一个矩形，因此矩形的个数也是 $\mathcal O(n)$ 级别的。

我们可以直接将所有的矩形存下来，放到二维平面上，长度为 $k$ 的区间就是这个平面上某一条斜率为 $1$ 的直线所穿过的点。可以再次用扫描线做，用一条斜率为 $1$ 的直线扫这个平面，问题就变成了维护单点插入一个数，单点删除，全局求 $\rm mex$，可以在线段树上二分解决。

---

## 作者：lihaoda0120 (赞：1)

[套娃](https://www.luogu.com.cn/problem/P9970)



考虑只用 ODT 找出所有极短 mex 区间。对 $l$ 从小到大扫描线，维护所有 $r$ 的 mex，那么删除 $a_l$ 就是对 $r\le nxt_l \wedge \text{mex}(l,r)\ge a_l$ 的 $\text{mex}(l,r)$ 推平成 $a_l$ 。可以用 ODT 维护 mex 值。

那么如何找到极短 mex 区间，以及对每个极短 mex 区间找到它的极长 mex 区间呢？扫描线时 `set` 中记录每个连续段被放进 `set` 中时的左端点在哪，记为 $tl$，`set` 中一个区间记为 $[ll,rr]$，那么极短 mex 区间和极长 mex 区间分别为 $[l,ll],[tl,rr]$。注意，极短 mex 区间和极长 mex 区间都是在 ODT 中被删除时才考虑的。注意要特殊考虑长度为 $1$ 的区间。

用 ODT 复杂度证明也可以证明极短 mex 区间只有 $O(n)$
 个。
 
给一张 mex 的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/8y4tfips.png)

将这个东西看成平面直角坐标系，$x$ 轴为 $l$，$y$ 轴为 $r$，那么就是对 $x$ 轴扫描线，`set` 维护 $y$ 轴。

并且可以发现每一个 mex 相同的连通块都是一个阶梯一样的东西。

其实每个极短 mex 区间和极长 mex 区间，就代表了一个矩形，这个矩形中的 mex 都是相等的。上述算法就是将这个上三角分成 $O(n)$ 个不交矩形，且每个矩形中的数都相同。

由于 `set` 中并不保证每段都是极长的数都相同的一段。所以其实上面找到的“极短 mex 区间”和“极长 mex 区间”并不一定是“极短”，“极长”的。但是这并不影响，只要保证所有的矩形的并等于全集即可。

最后每个矩形对答案的贡献相当于长度在一个区间内都插入一个数。这个扫描线 + `set` 维护没出现过的数就行了。

代码：

```cpp
#include<bits/stdc++.h>
#define psb push_back
#define fi first
#define se second
#define endl '\n'
using namespace std;
const int N=1e5+5; 
struct stu{
	int l,r,ml,v;
	bool operator<(stu b)const{return l<b.l;}
};
int n,a[N],nxt[N],lst[N],cnt[N];
bool vis[N];
vector<int> ad[N],del[N];
set<stu> s;
set<int> st;
auto split(int p){
	auto it=s.lower_bound(stu{p,0,0});
	if(it!=s.end()&&it->l==p)return it;
	if((--it)->r<p)return s.end();
	int l=it->l,r=it->r,ml=it->ml,v=it->v;
	s.erase(it);
	s.insert({l,p-1,ml,v});
	return s.insert({p,r,ml,v}).fi;
}
void add(int l1,int r1,int l2,int r2,int v){
	ad[r1-l1+1].psb(v);
	del[r2-l2+2].psb(v);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	int m=0,ls=1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		int lm=m;
		vis[a[i]]=1;
		while(vis[m])m++;
		if(i>1&&m!=lm)s.insert({ls,i-1,1,lm}),ls=i;
	}
	s.insert({ls,n,1,m});
	for(int i=n;i>=1;i--){
		nxt[i]=!lst[a[i]]?n+1:lst[a[i]];
		lst[a[i]]=i;
	}
	for(int i=1;i<=n;i++){
		split(i+1);
		add(i,i,s.begin()->ml,i,s.begin()->v);
		s.erase(s.begin());
		if(i<n){
			auto itr=split(nxt[i]),itl=itr;
			while(itl!=s.begin()&&prev(itl)->v>=a[i]){
				itl--;
				add(i,itl->l,itl->ml,itl->r,itl->v);
			}
			if(itl!=itr){
				int l=itl->l;
				s.erase(itl,itr);
				s.insert({l,nxt[i]-1,i+1,a[i]});
			}
		}
	}
	for(int i=0;i<=n+2;i++)st.insert(i);
	for(int i=1;i<=n;i++){
		for(int j:ad[i])if(!cnt[j]++)st.erase(j);
		for(int j:del[i])if(!--cnt[j])st.insert(j);
		cout<<*st.begin()<<" ";
	}
	return 0;
}/*
6
0 0 0 1 2 3
*/
```

---

## 作者：0xyz (赞：1)

赛后写出。想了一上午的做法假了，看了官方题解之后才会做。

一开始令 $b_i\to 10^9$。我们从小到大枚举区间的 $\text{mex}$，$v$。假设去掉 $a$ 中所有值为 $v$ 的元素后将原序列分成 $c_v$ 段，那么 $\sum c_v=O(n)$。

对于一个特定的 $v$，我们想要求出哪些长度的区间的 $\text{mex}$ 可以是 $v$。对于所有 $i$，预处理出来左端点是 $i$，值域包含 $[0,v-1]$ 的最小区间，假设其右端点是 $p_i$。那么对于那 $c_v$ 段不含 $v$ 的区间，每段都分开处理。对于一段 $[l,r]$，如果它的值域包含 $[0,v-1]$，那么它的 $\text{mex}$ 为 $v$ 的子区间最长是 $r-l+1$，求最短长度时，由于 $p$ 具有单调性，我们先二分出使得 $p_i\le r$ 的最大 $i$，再查询区间 $[l,i]$ 里最小的 $p_j-j+1$。求出这 $c_v$ 个区间之后，我们求出全集为 $[1,n]$ 时它们的补集，然后对这个补集的 $b_i\to\min(b_i,v)$ 即可。

开两棵线段树分别维护 $p$ 和 $b$。对于 $p$，发现维护区间 $p_j-j+1$ 最小值和 $p$ 的区间最值修改很难同时实现。注意到 $p$ 具有单调性，所以可以在线段树二分后对 $p$ 进行区间赋值。对于 $b$，我们要实现最值修改。时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。[代码](https://loj.ac/s/1962236)。

---

## 作者：zzafanti (赞：1)


我们队赛时被 J 题创死了 awa

离做出来差下文一个优化，而且赛后试了试不加甚至能过……

6 题离场。

## J 套娃

先对 $[0,n]$ 中每个数 $k$ 分别考虑。

假设总共出现了 $c$ 次 $k$，第 $i$ 次出现的位置是 $pos_{i}$，（令 $pos_0=0,pos_{c+1}=n+1$），则只有处在 $pos_{i-1}$ 和 $pos_i$ 间的区间可能 mex 等于 $k$。假设 $pos_{i-1}$ 和 $pos_{i}$ 中间存在 mex 为 $k$ 的区间，那么存在一个最短的在 $pos_{i-1}$ 到 $pos_{i}$ 的区间满足其 mex 等于 $k$，设其长度为 $d$。可以观察到，所有长度在 $[d,pos_i-pos_{i-1}-1]$ 中的区间都能取到至少一个 mex 为 $k$ 的位置。

经过上面的分析，问题就变成，对所有 $k\in [0,n+1]$ 求出 $c+1$ 个 $[d_i,pos_{i}-pos_{i-1}-1]$ 这样的长度区间，它们的并就是 mex 能取到 $k$ 的区间长度的集合。然后从小到大枚举 $k$，对 $[1,n]$ 每个长度 $l$ 检查 $k$ 是不是第一次覆盖不到 $l$，如果是，则 $l$ 的答案就是 $k$。最后剩下一直被覆盖的长度答案就是 $n+2$。

实际实现过程中，可以把用并集覆盖转化成其补集的覆盖，然后从小到大枚举的每个 $k$ 相当于要给补集内还没有删去的位置标记上答案 $k$ 并删去，可以用 $\text{set}$ 维护还没有被补集覆盖过的位置。

下面只需要想办法求出所有 $[d_i,pos_i-pos_{i-1}-1]$ 了。用 $\text{mex}([l,r])$ 表示下标在 $[l,r]$ 中的数构成的集合的 mex。

首先是 $[pos_i-pos_{i-1}-1]$，只需要对于每个 $pos_i$ 检查 $\text{mex}(pos_{i-1}+1,pos_i-1)$ 是否等于 $k$，如果不是，显然不会存在符合条件的 $d_i$。

然后考虑最难求的最短合法区间长度 $d_i$。

从 $1$ 到 $n$ 枚举右端点 $R$，然后维护一个指针 $L$，初始等于 $R$，然后每次找到 $\text{mex}([L,R])=p$。这时，$L,R$ 一定在 $p$ 的两个 $pos$ 中间，二分出来在哪两个 $pos$ 中间，然后用 $R-L+1$ 更新最小值。因为下标在 $[L,R]$ 中的数一定不存在 $p$，且当前 mex 为 $p$，所以只有继续往左找到最靠右的 $p$，把 $L$ 变成 $p$ 才能更新答案。设对于一个 $R$，指针 $L$ 跳了 $t_R$ 次，则对于整个序列就跳了 $\sum t_R$ 次，这个跳跃次数当然是可以卡到 $O(n^2)$ 的，比如说 $n=100$ 时这个数据：

```
50 49 48 47 ... 3 2 1 0 0 0 ... 0
```

这时候我们考虑去排除一些一定不是最优的区间。

如果下标在 $[L,R-1]$ 中的数出现过 $a_R$，则不必往前跳了，一定不是最优的。因为这时我们完全可以删去 $a_R$ 让区间长度更短并且不影响 mex 的取值。

实际测试这么搞可以通过本题。

下面来证明按照这个规则跳指针，$\sum t_R \leq 2n$。

把命题抽象一下可以发现就是：

> 满足 $\text{mex}(l,r-1)=a_r$ 且 $\text{mex}(l+1,r)=a_l$ 的区间 $[l,r]$ 的数量不超过 $2n$。

设 $a_l$ 是 $a_l,a_r$ 中较大的，则 $\text{mex}(l,r)>a_l$。那么不存在一个 $\text{r}$ 满足 $[l,\text{r}]$ 也是合法的区间且 $a_{\text{r}} <a_l$，因为 $a_{\text{r}}$ 此时一定在下标为 $[l,r]$ 中的数中出现过。

因此，两端点中较大的数一定只会对应序列向左向右各至多一个另一个端点作为合法区间。所以这样的区间数量不超过 $2n$。

区间 mex 使用可持久化权值线段树维护，时间空间复杂度都是 $O(n\log n)$。

参考代码：[#1958222 LOJ](https://loj.ac/s/1958222)


---

## 作者：lzqy_ (赞：1)

> $\forall\, 1\le k \le n,$ 求所有长度为 $k$ 的子区间 $\text{mex}$ 的 $\text{mex}$。

> $1 \le n \le 10^5,0 \le a_i \le n$

场上没调出来，把队伍送出复赛线了。

$\text{mex}$ 题的一个关键是如何消掉 `不存在 x` 的限制。

对于一个数 $x$，将 $x$ 所在位置拿出来，将序列划分成 $k$ 个连续段（显然 $O(\sum k)=O(n)$）。考虑一个连续段能贡献到哪些 $len$。

由于限制变宽松了（只要求 $0\sim x-1$ 出现过），因此枚举连续段中每一个 $l$，$r$ 是单调递增且能取满一个后缀，**所以这些区间长度的并一定还是一个区间**。

所以只要能快速找到每个连续段的贡献区间这题就做完了。

贡献区间的 $R$ 是好处理的，即连续段长度。问题是如何求 $L$。

考虑动态维护每个 $l$ 对应的最小的 $r$ 满足 $[l,r]$ 内出现过 $0\sim x-1$。从小到大枚举 $x$，那么每一个连续段对 $r$ 的更新即区间对连续段右端点取 $
\max$。即区间取 $\max$，区间查询 $(r-l+1)_{\min}$，这可以通过吉司机线段树的均摊维护。

注意要线段树上二分出第一个合法的 $l$。

时间复杂度 $O(n\log n)$。

```
#include<bits/stdc++.h>
#define il inline
using namespace std;
const int maxn=100010;
const int MAXN=maxn*30;
const int inf=1<<30;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
int d[MAXN],tag[MAXN];
///////////////////////
int d1[MAXN],d2[MAXN];
int d1_L[MAXN],d3[MAXN];
int lz[MAXN];
//d1:min(R)
//d2:cmin(R)
//d1_L max(L)->Rmin
//d3:min(R-L+1) except Rmin
int L[maxn],R[maxn];
int n,a[maxn];
int loc[maxn],m;
int ans[maxn];
vector<int>v[maxn];
void pushup(int i){
	if(d1[i<<1]>=d1[i<<1|1])
		d1_L[i]=d1_L[i<<1|1];
	else d1_L[i]=d1_L[i<<1];
	if(d1[i<<1]==d1[i<<1|1]){
		d2[i]=min(d2[i<<1],d2[i<<1|1]);
		d3[i]=min(d3[i<<1],d3[i<<1|1]);
	}
	else{
		d2[i]=min(min(d2[i<<1],d2[i<<1|1]),max(d1[i<<1],d1[i<<1|1]));
		d3[i]=min(d3[i<<1],d3[i<<1|1]);
		if(d1[i<<1]>d1[i<<1|1])
			d3[i]=min(d3[i],d1[i<<1]-d1_L[i<<1]+1);
		else d3[i]=min(d3[i],d1[i<<1|1]-d1_L[i<<1|1]+1);
	}
	d1[i]=min(d1[i<<1],d1[i<<1|1]);
}
void pushdown(int i){
	if(!lz[i]) return ;
	if(d1[i<<1]<=lz[i])
		d1[i<<1]=lz[i<<1]=lz[i];
	if(d1[i<<1|1]<=lz[i])
		d1[i<<1|1]=lz[i<<1|1]=lz[i];
	lz[i]=0;
}
void build(int i,int l,int r){ 
	d[i]=r-l+1;
	if(l==r){
		d1[i]=d1_L[i]=l;
		d2[i]=d3[i]=inf;
		return ;
	}int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	pushup(i);
}
void optMx(int i,int l,int r,int L,int R,int x){
	if(x<d1[i]) return ;
	if(l>R||r<L) return ;
	if(l>=L&&r<=R&&x<d2[i])
		return d1[i]=x,lz[i]=x,void();
	int mid=l+r>>1;
	pushdown(i);
	if(mid>=L) optMx(i<<1,l,mid,L,R,x);
	if(mid<R) optMx(i<<1|1,mid+1,r,L,R,x);
	pushup(i);
}
int getMn1(int i,int l,int r,int L,int R){
	if(l>R||r<L) return inf;
	if(l>=L&&r<=R) return d1[i];
	pushdown(i);
	int mid=l+r>>1;
	return min(getMn1(i<<1,l,mid,L,R),getMn1(i<<1|1,mid+1,r,L,R));
}
int getMn2(int i,int l,int r,int L,int R){
	if(l>R||r<L) return inf;
	if(l>=L&&r<=R) return min(d3[i],d1[i]-d1_L[i]+1);
	int mid=l+r>>1;
	pushdown(i);
	return min(getMn2(i<<1,l,mid,L,R),getMn2(i<<1|1,mid+1,r,L,R));
}
int Lst(int i,int l,int r,int L,int R,int x){
	if(d1[i]>x||l>R||r<L) return -inf;
	if(l==r) return l;
	int mid=l+r>>1;
	pushdown(i);
	if(l>=L&&r<=R){
		if(d1[i<<1|1]<=x) return Lst(i<<1|1,mid+1,r,L,R,x);
		else return Lst(i<<1,l,mid,L,R,x);
	}
	return max(Lst(i<<1,l,mid,L,R,x),Lst(i<<1|1,mid+1,r,L,R,x));
}
////////////
void Add(int i,int l,int r,int L,int R){
	if(l>=L&&r<=R){
		tag[i]=1;
		return ;
	}int mid=l+r>>1;
	if(mid>=L) Add(i<<1,l,mid,L,R);
	if(mid<R) Add(i<<1|1,mid+1,r,L,R); 
}
void clear(int i,int l,int r,int L,int R){
	if(l>=L&&r<=R){
		tag[i]=0;
		return ;
	}int mid=l+r>>1;
	if(mid>=L) clear(i<<1,l,mid,L,R);
	if(mid<R) clear(i<<1|1,mid+1,r,L,R); 
}
void calc(int ANS,int i,int j,int l,int r){
	if(tag[j]) return ;
	if(!d[i]) return ;
	if(l==r){
		ans[l]=ANS,d[i]=0;
		return ;
	}int mid=l+r>>1;
	calc(ANS,i<<1,j<<1,l,mid);
	calc(ANS,i<<1|1,j<<1|1,mid+1,r);
	d[i]=d[i<<1]+d[i<<1|1];
}
int main(){
	freopen("CF.in","r",stdin);
	freopen("CF.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read(),v[a[i]].push_back(i);
	build(1,1,n);
	memset(ans,-1,sizeof(ans));
	for(int i=0;i<=n;i++){
		loc[m=1]=0;
		for(auto x:v[i]) loc[++m]=x;
		loc[++m]=n+1;
		for(int i=2;i<=m;i++){
			if(getMn1(1,1,n,loc[i-1]+1,loc[i]-1)>=loc[i]){
				L[i]=R[i]=0;
				continue;
			}
			R[i]=loc[i]-loc[i-1]-1;
			L[i]=getMn2(1,1,n,loc[i-1]+1,Lst(1,1,n,loc[i-1]+1,loc[i]-1,loc[i]-1));
		}
		
		for(int i=2;i<=m;i++)
			optMx(1,1,n,loc[i-1]+1,loc[i]-1,i==m?inf-1:loc[i]);
		for(int i=1;i<=m;i++)
			 if(L[i]) Add(1,1,n,L[i],R[i]);
		calc(i,1,1,1,n);
		for(int i=1;i<=m;i++)
			if(L[i]) clear(1,1,n,L[i],R[i]);
	}
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]);
	return 0;
} 
```

---

## 作者：zheng_zx (赞：1)

## P9970 [THUPC 2024 初赛] 套娃

[题目传送门](https://www.luogu.com.cn/problem/P9970)

### 分析

---

~~在我把脑子烧掉之前~~，得到了一个神奇的结论：对于 $(l,r)$ 为 $\operatorname{mex}_{l,r}$ 的矩形，其中按颜色分割得到的矩形数是 $O(n)$ 级别的。

**证明**：我们考虑找出这些矩形的过程，可以先求出每个后缀的 $\operatorname{mex}$，再考虑删点，删点过程是对 $\operatorname{lst}_{a_i}$ 到 $i$ 的位置和 $a_i$ 取 $\operatorname{min}$，又由于 $\operatorname{mex}$ 序列是单调不增的，于是最多只会改变一段后缀，前面不会改变，所以每次操作只会新增 $1$ 个区间，实现同理用 $\operatorname{odt}$ 维护即可。

---

## 作者：lalaouye (赞：0)

这题不会极短 $\text{mex}$ 区间的话感觉难度还是很大的！

让我们来看看极短 $\text{mex}$ 区间有哪些性质：

1. 它很短。不存在一个它的子区间满足该子区间的 $\text{mex}$ 等于它（这似乎应该是定义）。
2. 显然它的左右端点都缺一不可，少一个 $\text{mex}$ 就会变小。
3. 不妨设 $a_l>a_r$，以下同理，那么该区间的 $\text{mex}$ 大于 $a_l$。
4. 这样的段只有 $\mathcal{O}(n)$ 个，证明考虑对于任意的 $l$，我们可以证明只有一个 $r$ 满足条件，对于一个极短区间 $[l,r]$， 不难发现 $[l,r-1]$ 的 $\text{mex}$ 是 $a_r$，也就是说对于 $l$，其它小于 $r$ 的右端点都不需要 $a_l$ 了，于是可以左端点加一不影响结果。而对于右端点大于 $r$ 的区间则更不可能了，因为此时的 $\text{mex}$ 已经大于 $a_l$，而 $a_r$ 钦定小于 $a_l$，所以此时右端点也没用。
5. 对于一个极短 $\text{mex}$ 区间，我们可以采取寻找左右最近的值恰为该区间 $\text{mex}$ 的位置进行拓展，采取这种方式可以拓展出所有极短 $\text{mex}$ 区间。

那么我们就可以找到这些区间了，对于每种数维护一个 set，可以查询前驱后继，对于区间我们需要在线求出 $\text{mex}$ 的值，可以采取可持久化线段树维护，即通过扫描线在 $r$ 这棵线段树查询最小的最后一次出现位置小于 $l$ 的数，最后求出极短区间后找出其生效长度范围，这是好找的，最后操作差分利用扫描线维护每个长度的 $\text{mex}$ 即可。

---

## 作者：xxxxxzy (赞：0)

现在来看，这个就是经典套路题了。

首先一个关键结论是，一个序列极短的子区间并且 $\text{mex}$ 为 $x$ 的个数是 $O(n)$ 级别的，我们称这些区间为关键区间。

对于一个关键区间 $[l,r]$，肯定有 $a_l \ne a_r$，我们假定 $a_l > a_r$。

那么，加入 $a_l,a_r$ 后答案发生了变化，也就是说，$\text{mex}(l+1,r-1)=a_r -1$。

所以说，对于任意一个 $l$，其对应的 $r$ 只有一个，反之也亦然。

所以总数是小于等于 $2n$ 的，得证。

知道了这个结论之后，后面的比较简单。

考虑一个区间的存在 $(l_1,r_1,l_2,r_2,k)$，表示 $k$ 的存在在 $x\in [l_1,r_1],y \in [l_2,r_2]$ 造成贡献，求出来后拿个扫描线做一遍。

最后考虑如何求这个东西。

维护一个点左边的最右同点权出现下标 $L_i$，倒叙扫一遍删除每个点，删除 $a_i$ 本质是对 $L_i$ 右边取 $\min$。

由于 $\text{mex}$ 具有单调性，所以可以拿个 ODT 方便地维护。

时间 $O(n\log n)$。

---

## 作者：cyc001 (赞：0)

这里讲一个比 std 多一个 $\log$ 但能过的做法。

首先根据 [CF1870E](https://www.luogu.com.cn/problem/CF1870E) 的解法，我们知道满足 $\forall l<l_1\le r_1<r$ 都有 $\text{mex}\{a_l\cdots a_r\}<\text{mex}\{a_{l_1}\cdots a_{r_1}\}$ 的 $(l,r)$ 数量是 $O(n)$ 的。

在这道题里面我们采用 1870E 的处理方式找出所有满足条件的 $(l,r)$，可以使用主席树+二分优化到 $O(n\log^2n)$。


我们把那满足条件的区间 $[l,r]$ 称为最小 $\text{mex}$ 区间，则我们对于每个最小 $\text{mex}$ 区间 $[l,r]$ 考虑最大的 $k$ 使得存在一个长度为 $k$ 的区间包含 $[l,r]$ 且这个区间的 $\text{mex}$ 等于 $[l,r]$ 的 $\text{mex}$。

容易发现 $k$ 为 $r$ 右边的第一个 $\text{mex}\{a_l\cdots a_r\}+1$ 的出现位置 $-$ $l$ 左边的第一个 $\text{mex}\{a_l\cdots a_r\}+1$ 出现位置 $-1$，这个过程可以线性预处理，时间复杂度是 $O(n)$。

最后我们用 ```std::set``` 维护每个时刻不存在的 $\text{mex}$，则每个时刻的答案是 ```set``` 里的最小值，时间复杂度 $O(n\log n)$。

总时间复杂度 $O(n\log^2n)$，可以通过。

~~代码里的主席树部分是贺的队友的所以就不放了...~~

[Code](https://loj.ac/s/1957162)

---


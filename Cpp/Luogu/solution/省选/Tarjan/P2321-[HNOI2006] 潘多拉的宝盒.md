# [HNOI2006] 潘多拉的宝盒

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/1372.png) 

![](https://cdn.luogu.com.cn/upload/pic/1373.png)


## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/1380.png)


## 样例 #1

### 输入

```
4
1  1
0
0  0
2  1
0
1  1
0  0
3  1
0
1  1
2  2
0  0
4  1
0
1  1
2  2
3  3
0  0```

### 输出

```
3```

## 样例 #2

### 输入

```
3
1  1
0
0  0
3  1
0
0  1
2  0
1  2
9  1
0
0  1
2  3
4  5
6  7
8  0
1  2
3  4
5  6
7  8```

### 输出

```
3```

# 题解

## 作者：pldzy (赞：10)

## 思路

我们要先找到所有的升级序列，找出所有的包含与被包含的关系，

然后找到一条最长链，满足题目要求。

1. 如何找到所有的包含关系？
 
	遍历每一对盒子，对于二者，我们用 **dfs** 扫一遍，如果有一个盒子在一个节点输出了串，而另一个没有，那么这两者就不存在包含关系。
    
    反之，两者就存在包含关系。我们就可以建一条有向边，从包含者指向被包含者。
    
2. 为什么求最长链？

	易得，在一个**强连通分量**中，肯定是存在一条链的。
    
   所以，我们只需要把一个个强连通分量**缩点**，然后找到一条把超级点（强连通分量）串起来的最长的链即可。
   
   最终答案，就是最长链的长度。
   
3. 怎么找最长链？

	还是用 dfs，我们分别从每一个节点开始遍历，以当前节点当作当前链的链顶，
    
    然后用前向星搜下去，每次返回以该点作为链顶时最长链的长度。
    
## 代码实现

0. 初始化：

	有两个细节一定要注意：
    
     1. 一定要开 `long long`；
     
     2. 用前向星的话存边数组至少开到 400。
  

1. 输入：

   我们开个结构体存一下输入条件。
   
	注意输入的点的编号要加一（题目编号从 0 开始）。
    
````cpp
void input ()
{
	scanf ("%lld", &s);
	for (int i = 1; i <= s; i++)
	{
		scanf ("%lld %lld", &n, &m);
		for (int j = 1; j <= m; j++)
		{
			int t;
			scanf ("%lld", &t);
			t++;
			a[i].out[t] = 1;
		}
		for (int l = 1; l <= n; l++)
		{
			int aa, bb;
			scanf ("%lld %lld", &aa, &bb);
			aa++, bb++;
			a[i].lin[l][0] = aa, a[i].lin[l][1] = bb;
		}
	}
}
````

2. 建边：

	每次对于任意两个宝盒，我们同时从 1 开始出发（题目已知条件），如果他们之间存在包含关系，
    
    证明他们两者间必定有完全相同的 01 串。
    
    所以，如果当我们访问到一个节点时，一个宝盒中的是输出元，而另一个不是，
    
    就证明这两个间不存在包含关系。
    
    反之，即存在，我们就可以在他们之间建一条有向边，指向他们之间的包含关系。
    
    记得要用数组储存一下每一条边的起点和终点，方便后面缩点，重新建图。
    
````cpp
void find (int x, int y, int nx, int ny)
{
	if (a[x].out[nx] == 1 and a[y].out[ny] == 0) 
	{
		flag = 1;
		return;
	}
	if (vis[nx][ny]) return;
	vis[nx][ny] = 1;
	find (x, y, a[x].lin[nx][0], a[y].lin[ny][0]);
	find (x, y, a[x].lin[nx][1], a[y].lin[ny][1]);
}

void build ()
{
	for (int i = 1; i <= s; i++)
	{
		for (int j = 1; j <= s; j++)
		{
			if (i == j) continue;
			flag = 0, memset (vis, 0, sizeof vis);
			find (i, j, 1, 1);
			if (!flag) add (i, j), u[cnt] = i, v[cnt] = j;
		}	
	}
}
````

3. 缩点：

	按照之前思路所说的我们要缩点，以找最长链。
    
    这里缩点就不多说了，具体可以见我的博客[缩点（算法笔记）](https://469672.blog.luogu.org/su-dian)。
    
````cpp
void tarjan (int u)
{
	dfn[u] = low[u] = ++tmp;
	st[++top] = u;
	for (int i = hd[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (!dfn[v])
		{
			tarjan (v);
			low[u] = min (low[u], low[v]);
		}
		else if (!co[v]) low[u] = min (low[u], dfn[v]);
	}
	if (dfn[u] == low[u])
	{
		co[u] = ++col;
		siz[col] = 1;
		while (st[top] != u)
		{
			co[st[top]] = col;
			siz[col]++;
			top--;
		}
		top--;
	}
}

void rebuild ()
{
	for (int i = 1; i <= s; i++) if (!dfn[i]) tarjan (i);
	int recoc = cnt;
	cnt = 0;
	memset (hd, 0, sizeof hd);
	memset (e, 0, sizeof e);
	for (int i = 1; i <= recoc; i++)
	{
		if (co[u[i]] == co[v[i]]) continue;
		add (co[u[i]], co[v[i]]);
	}
}
````

4. 输出答案：

	这时候我们就可以直接记忆化搜索最长链了，最后边搜边记录最长链长度即可。
    
````cpp
int get (int u)
{
	if (ans[u]) return ans[u];
	ans[u] = siz[u];
	for (int i = hd[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		ans[u] = max (ans[u], get (v) + siz[u]);
	}
	return ans[u];
}

void output ()
{
	int anss = 0;
	for (int i = 1; i <= col; i++) if (!ans[i]) anss = max (anss, get (i));
	printf ("%lld\n", anss);
}
````

## 完整代码

````cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
int s, n, m;
const int maxn = 205;
int cnt, hd[maxn];
struct node{
	int to, nxt;
}e[305];
struct node2{
	int lin[maxn][5], out[maxn];
}a[maxn];
int dfn[maxn], low[maxn], siz[maxn], co[maxn], st[maxn];
int tmp, top, col;
int flag, vis[maxn][maxn];
int u[305], v[305], ans[maxn];

void add (int u, int v)
{
	e[++cnt].to = v;
	e[cnt].nxt = hd[u];
	hd[u] = cnt;
}

void input ()
{
	scanf ("%lld", &s);
	for (int i = 1; i <= s; i++)
	{
		scanf ("%lld %lld", &n, &m);
		for (int j = 1; j <= m; j++)
		{
			int t;
			scanf ("%lld", &t);
			t++;
			a[i].out[t] = 1;
		}
		for (int l = 1; l <= n; l++)
		{
			int aa, bb;
			scanf ("%lld %lld", &aa, &bb);
			aa++, bb++;
			a[i].lin[l][0] = aa, a[i].lin[l][1] = bb;
		}
	}
}

void find (int x, int y, int nx, int ny)
{
	if (a[x].out[nx] == 1 and a[y].out[ny] == 0) 
	{
		flag = 1;
		return;
	}
	if (vis[nx][ny]) return;
	vis[nx][ny] = 1;
	find (x, y, a[x].lin[nx][0], a[y].lin[ny][0]);
	find (x, y, a[x].lin[nx][1], a[y].lin[ny][1]);
}

void build ()
{
	for (int i = 1; i <= s; i++)
	{
		for (int j = 1; j <= s; j++)
		{
			if (i == j) continue;
			flag = 0, memset (vis, 0, sizeof vis);
			find (i, j, 1, 1);
			if (!flag) add (i, j), u[cnt] = i, v[cnt] = j;
		}	
	}
}

void tarjan (int u)
{
	dfn[u] = low[u] = ++tmp;
	st[++top] = u;
	for (int i = hd[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (!dfn[v])
		{
			tarjan (v);
			low[u] = min (low[u], low[v]);
		}
		else if (!co[v]) low[u] = min (low[u], dfn[v]);
	}
	if (dfn[u] == low[u])
	{
		co[u] = ++col;
		siz[col] = 1;
		while (st[top] != u)
		{
			co[st[top]] = col;
			siz[col]++;
			top--;
		}
		top--;
	}
}

void rebuild ()
{
	for (int i = 1; i <= s; i++) if (!dfn[i]) tarjan (i);
	int recoc = cnt;
	cnt = 0;
	memset (hd, 0, sizeof hd);
	memset (e, 0, sizeof e);
	for (int i = 1; i <= recoc; i++)
	{
		if (co[u[i]] == co[v[i]]) continue;
		add (co[u[i]], co[v[i]]);
	}
}

int get (int u)
{
	if (ans[u]) return ans[u];
	ans[u] = siz[u];
	for (int i = hd[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		ans[u] = max (ans[u], get (v) + siz[u]);
	}
	return ans[u];
}

void output ()
{
	int anss = 0;
	for (int i = 1; i <= col; i++) if (!ans[i]) anss = max (anss, get (i));
	printf ("%lld\n", anss);
}

signed main ()
{
	input ();
	build ();
	rebuild ();
	output ();
	return 0;
}
````

如有问题，求大佬斧正，感谢。

---

## 作者：SNiFe (赞：8)

#我居然是第一个

坐这道题的最关键的一步也是第一步：**读懂题！！！！！！！**

##题目大意：

\_有s个咒语机，每个咒语机出度为2，字符串后加0指向一个元件，加1指向一个元件，直到找到一个输出元，算是一种方案；当A咒语机的所有方案包含B咒语机的所有方案时，那么A咒语机是B咒语机的升级。求：最长升级序列的长度。（我读了40分钟才读懂，语文不好）\_

##做法：

我一开始是没有思路的，感觉像搜索，看了网上很多代码都是Tarjan+DFS+……（本人很懒，不想学这种方法），最后找到一个dalao的code，我把他的思路介绍给大家：

1.pri[i][x]记录的是输出元；

2.vis[i][j]记录的是s1中的i元件和s2中的j元件这个状态；

3.map[i][j][（0,1）]记录的是i咒语机中j元件到哪个元件；（因为n很小，所以开矩阵就好）

4.一个BFS来判断j是否是i的升级，用levup[i][j]记录；

5.Floyd找出最长升级序列。

#代码：


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=55;
int map[N][N][2],n,m,levup[N][N],ans=0;
bool vis[N][N],pri[N][N];
struct node
{
    int sx,sy;
};
bool check(int s1,int s2)//判断s2是否是s1的升级 
{
    memset(vis,0,sizeof(vis));
    queue<node>q;
    node fir;
    fir.sx=0,fir.sy=0;
    q.push(fir);
    while(!q.empty())
    {
        node x=q.front(),tmp;q.pop();
        if(pri[s1][x.sx]&&!pri[s2][x.sy])return 0;//如果 pri[s1][x.sx]是输出元，且pri[s2][x.sy]不是的话，那么s2不是s1的升级 
        tmp.sx=map[s1][x.sx][0],tmp.sy=map[s2][x.sy][0];
        if(!vis[tmp.sx][tmp.sy])vis[tmp.sx][tmp.sy]=true,q.push(tmp);
        tmp.sx=map[s1][x.sx][1],tmp.sy=map[s2][x.sy][1];
        if(!vis[tmp.sx][tmp.sy])vis[tmp.sx][tmp.sy]=true,q.push(tmp);
    }
    return 1;
}
int main()
{
    int s;
    scanf("%d",&s);
    for(int i=0;i<s;i++)//因为是从0号元件开始的所以i=0;i<s;i++ 
    {
        scanf("%d%d",&n,&m);
        for(int j=0;j<m;j++)
        {
            int x;
            scanf("%d",&x);pri[i][x]=1;
        }
        for(int j=0;j<n;j++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            map[i][j][0]=u,map[i][j][1]=v;
        }
    }
    memset(levup,-0x3f,sizeof(levup));
    for(int i=0;i<s;i++)
    {
        for(int j=0;j<s;j++)
        {
            if(check(i,j)&&i!=j&&levup[j][i]<0)//这里是levup[j][i]!!!!!!!!!!!  j  !!!!!!  i  !!!!!!!!
            //因为要i不是j的升级，避免重复，否者ans很大，最开始我写的levup[i][j]全WA 
            levup[i][j]=1;//这里是levup[i][j]!!!!!!!!!!!  i  !!!!!!  j  !!!!!!!! 
        }
    }
    for(int k=0;k<s;k++)//floyd(一个精巧的DP) 
    {
        for(int i=0;i<s;i++)
        {
            for(int j=0;j<s;j++)
            {
                if(levup[i][j]<levup[i][k]+levup[k][j]&&levup[i][k]&&levup[k][j])
                levup[i][j]=levup[i][k]+levup[k][j],ans=max(ans,levup[i][j]);
            }
        }
    }
    printf("%d",ans+1);//因为要把开头的咒语机算进去，所以ans+1 
}
欢迎dalao指正！！！！！！！！！！
```

---

## 作者：我是逍逍 (赞：5)

#### 吐槽
这题最难的部分就是读题……没少花时间……

#### 题意
有 $s$ 个盒子，每个盒子按照一定规则产生 01 串。设第 $i$ 个盒子能产生的所有字符串为集合 $S_i$，寻找满足 $S_a \in S_b \in S_c \in S_d \in \cdots \in S_x$ 能构成的最长包含关系。

#### 思路 & 算法
先求出所有盒子两两之间是否有包含关系，接着利用包含关系建立有向图，然后用 _Tarjan_ 算法简单判环，最后 _dfs_ 答案，输出。

如何判断包含关系呢？需要注意的是，包含关系包括相等的情况。  
判定包含，只需要保证 $\forall str \in S_i, str 
\in S_j$ 即在每一处 $Box_i$ 能输出咒语的地方，$Box_j$ 也能输出。由此可以判定存在包含关系 $S_i \in S_j$。

#### 代码
题目比较友善，没什么坑，代码也好写，不过不清楚为什么别的题解强调要使用 `long long`，数据量非常小啊……

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <stack>

using namespace std;
const int Max = 55;

struct Box {
    int g[Max][2];
    bool p[Max];
} a[Max];

int s, dfn[Max], low[Max], scc[Max], l[Max], t, cnt, f[Max], ans;
bool flag, vis[Max][Max], ins[Max];
vector<int> g[Max], h[Max];
stack<int> st;

void check(int i, int j, int x, int y) {
    if (a[i].p[x] < a[j].p[y]) 
        flag = false;
    if (!flag || vis[x][y])
        return;
    vis[x][y] = true;
    check(i, j, a[i].g[x][0], a[j].g[y][0]);
    check(i, j, a[i].g[x][1], a[j].g[y][1]);
}

void tarjan(int x) {
    dfn[x] = low[x] = ++t;
    ins[x] = true;
    st.push(x);
    
    for (int y: g[x])
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if (ins[y])
            low[x] = min(low[x], dfn[y]);
    
    if (low[x] == dfn[x]) {
        int y;
        cnt++;
        do {
            y = st.top();
            st.pop();
            ins[y] = false;
            scc[y] = cnt;
            l[cnt]++;
        } while (x != y);
    }
}

int dfs(int x) {
    if (f[x])
        return f[x];
    for (int y: h[x]) 
        f[x] = max(f[x], dfs(y));
    return f[x] += l[x];
}

int main() {
    cin >> s;
    for (int i = 1, n, m; i <= s; i++) {
        cin >> n >> m;
        for (int j = 1, x; j <= m; j++) {
            cin >> x;
            a[i].p[x + 1] = true;
        }
        for (int j = 1, x, y; j <= n; j++) {
            cin >> x >> y;
            a[i].g[j][0] = x + 1;
            a[i].g[j][1] = y + 1;
        }
    }
    
    // 检查两两包含关系
    for (int i = 1; i <= s; i++)
        for (int j = 1; j <= s; j++) 
            if (i != j) {
                flag = true;
                memset(vis, 0, sizeof vis);
                check(i, j, 1, 1);
                
                if (flag) // 建图
                    g[i].push_back(j);
            }
    
    // Tarjan 判环
    for (int i = 1; i <= s; i++) 
        if (!dfn[i])
            tarjan(i);
    
    // 重新建图，将 SCC 缩成点
    for (int i = 1; i <= s; i++) 
        for (int j: g[i]) 
            if (scc[i] != scc[j]) 
                h[scc[i]].push_back(scc[j]);
    
    // DFS 统计答案
    for (int i = 1; i <= cnt; i++)
        ans = max(ans, dfs(i));

    cout << ans << endl;
    return 0;
}
                       
```



---

## 作者：Sharing666 (赞：3)

## 题意

有 S 个宝盒，每个宝盒有 $n$ 个元件，$m$ 个输出元。若宝盒 a 可输出的字符串涵盖了所有宝盒 b 可输出的字符串，则称 a 是 b 的升级。求最长的升级序列。

## 思路

我们先求出宝盒之间的升级关系，如果 a 是 b 的升级，就在两者之间连一条单向边，再跑一边 Tarjan 求最长链即可。

### Step 1：
怎样求出宝盒之间的升级关系？

我们考虑同时枚举宝盒 a 和宝盒 b 所有可能输出的字符串。

当 a 的字符串末尾加了一个 1,b 的字符串也要加上一个 1，这样就可以保证它们的字符串相同。

如果 a 枚举到的元件 x 不是输出元，但相对应 b 的原件 y 是输出元，这时 y 就会输出字符串，而 x 不会输出。

也就是说，a 并没有涵盖所有 b 可能输出的字符串，a 不是 b 的升级。

这一过程可以用 dfs 实现：

```cpp
	void dfs(int x,int y,int nx,int ny) {
    if(!a[x].out[nx] && a[y].out[ny]) flag=1;
    if(flag) return ;
    if(vis[nx][ny]) return ;
    vis[nx][ny]=1;
    dfs(x,y,a[x].ver[nx][0],a[y].ver[ny][0]);
    dfs(x,y,a[x].ver[nx][1],a[y].ver[ny][1]);
}
```

### Step 2：
求出由一个或多个宝盒组成的强联通分量。

这一部分就不多说了，很明显用 Tarjan 求，直接贴代码：

```cpp
	void tarjan(int u) {
    dfn[u]=low[u]=++num;
    stack[++tot]=u;
    mark[u]=1;
    for(int i=head[u];i;i=e[i].nxt) {
        int v=e[i].to;
        if(!dfn[v]) {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        } else if(mark[v]) low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u]) {
        int x=0;
        res++;
        while(x!=u) {
            x=stack[tot--];
            mark[x]=0;
            sz[res]++;
            bl[x]=res;
        }
    }
}
```

### Step 3：
求出最长的升级链。

缩点后再建一次图，跑一遍 dfs 取最大值。

```cpp
	int dfs2(int u) {
    if(ans[u]) return ans[u];
    ans[u]=sz[u];
    for(int i=head2[u];i;i=e2[i].nxt) {
        int v=e2[i].to;
        ans[u]=max(ans[u],sz[u]+dfs2(v));
    }
    return ans[u];
}
```

AC 代码：
```cpp
#include <iostream>
using namespace std;
#define int long long

int s,n,m,maxn,ans[102];
int cnt,cnt2,head[102],head2[102]; //链式前向星 
int num,tot,dfn[102],low[102],stack[102]; //Tarjan
int res,sz[102],bl[102]; //bl表示每个点所属的双联通分量 
bool flag,vis[52][52];
bool mark[52];

struct node{
    int ver[52][2];
    bool out[52]; //标记输出元 
}a[52];

struct edge{
    int from,to,nxt;
}e[100002],e2[100002];

void addedge(int A,int B) {
    e[++cnt].to=B;
    e[cnt].from=A;
    e[cnt].nxt=head[A];
    head[A]=cnt;
} //建边 

void addedge2(int A,int B) {
    if(A==B) return ;
    e2[++cnt2].to=B;
    e2[cnt2].nxt=head2[A];
    head2[A]=cnt2;
}

void dfs(int x,int y,int nx,int ny) {
    if(!a[x].out[nx] && a[y].out[ny]) flag=1;
    if(flag) return ;
    if(vis[nx][ny]) return ;
    vis[nx][ny]=1;
    dfs(x,y,a[x].ver[nx][0],a[y].ver[ny][0]);
    dfs(x,y,a[x].ver[nx][1],a[y].ver[ny][1]);
}

void tarjan(int u) {
    dfn[u]=low[u]=++num;
    stack[++tot]=u;
    mark[u]=1;
    for(int i=head[u];i;i=e[i].nxt) {
        int v=e[i].to;
        if(!dfn[v]) {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        } else if(mark[v]) low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u]) {
        int x=0;
        res++;
        while(x!=u) {
            x=stack[tot--];
            mark[x]=0;
            sz[res]++;
            bl[x]=res;
        }
    }
}

int dfs2(int u) {
    if(ans[u]) return ans[u];
    ans[u]=sz[u];
    for(int i=head2[u];i;i=e2[i].nxt) {
        int v=e2[i].to;
        ans[u]=max(ans[u],sz[u]+dfs2(v));
    }
    return ans[u];
}

signed main() {
    scanf("%lld",&s);
    for(int i=1;i<=s;i++) {
        int n,m;
        scanf("%lld%lld",&n,&m);
        maxn=max(maxn,n);
        while(m--) {
            int tmp;
            scanf("%lld",&tmp);
            tmp++;
            a[i].out[tmp]=1;
        }
        for(int j=1;j<=n;j++) {
            scanf("%lld%lld",&a[i].ver[j][0],&a[i].ver[j][1]);
            a[i].ver[j][0]++;
            a[i].ver[j][1]++;
        }
    }
    for(int i=1;i<=s;i++) 
        for(int j=1;j<=s;j++) {
            if(i==j) continue;
            flag=0;
            for(int k=1;k<=maxn;k++) 
                for(int l=1;l<=maxn;l++) vis[k][l]=0;
            dfs(i,j,1,1);
            if(!flag) addedge(i,j);
        }
    for(int i=1;i<=s;i++) 
        if(!dfn[i]) tarjan(i);
    for(int i=1;i<=cnt;i++) {
        int u=e[i].from,v=e[i].to;
        addedge2(bl[u],bl[v]);
    }
    int anss=0;
    for(int i=1;i<=res;i++) anss=max(anss,dfs2(i));
    printf("%lld\n",anss);
    return 0;
}
```

---

## 作者：ethan0328 (赞：1)

## 思路

首先要求出包含关系。这个可以直接 dfs 求。当某机器在另一个机器有输出的地方都有输出，则这个机器包含另一个机器。dfs 代码如下。

```cpp
void dfs(int x,int y,int nx,int ny)
{
	if(!a[x].out[nx]&&a[y].out[ny])
	{
		flg=0;
		return;
	}
	if(!flg)
	{
		return;
	}
	if(vis[nx][ny])
	{
		return;
	}
	vis[nx][ny]=1;
	dfs(x,y,a[x].to[nx][0],a[y].to[ny][0]);
	dfs(x,y,a[x].to[nx][1],a[y].to[ny][1]);
}
```
然后把包含的向被包含的连有向边，问题就变成求一条最长链。发现一个强连通分量中一定可以抠出一条链，所以用 tarjan 缩点。然后图就变成了一个 $DAG$，用拓扑排序去更新到每个点的最长链即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=60;
struct mch
{
	int to[N][2];
	bool out[N];
};
int n,ans,dp[N];
mch a[N];
bool flg,vis[N][N];
vector<int> e[N],e2[N];
int ind,cnt,dfn[N],low[N],scc[N],dex[N],num[N];
bool inst[N],inq[N];
stack<int> stk;
queue<int> q;
void dfs(int x,int y,int nx,int ny)
{
	if(!a[x].out[nx]&&a[y].out[ny])
	{
		flg=0;
		return;
	}
	if(!flg)
	{
		return;
	}
	if(vis[nx][ny])
	{
		return;
	}
	vis[nx][ny]=1;
	dfs(x,y,a[x].to[nx][0],a[y].to[ny][0]);
	dfs(x,y,a[x].to[nx][1],a[y].to[ny][1]);
}
void tar(int x)
{
	low[x]=dfn[x]=++ind;
	stk.push(x);
	inst[x]=1;
	for(auto y:e[x])
	{
		if(!dfn[y])
		{
			tar(y);
			low[x]=min(low[x],low[y]);
		}else if(inst[y])
		{
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		int tmp=0;
		while(tmp!=x)
		{
			tmp=stk.top();
			inst[tmp]=0;
			scc[tmp]=cnt;
			stk.pop();
			num[cnt]++;
		}
	}
}
int main()
{
	int x,y,z;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		for(int j=1;j<=y;j++)
		{
			cin>>z;
			z++;
			a[i].out[z]=1;
		}
		for(int j=1;j<=x;j++)
		{
			cin>>a[i].to[j][0]>>a[i].to[j][1];
			a[i].to[j][0]++;
			a[i].to[j][1]++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i==j)
			{
				continue;
			}
			flg=1;
			memset(vis,0,sizeof(vis));
			dfs(i,j,1,1);
			if(flg)
			{
				e[i].push_back(j);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])
		{
			tar(i);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(auto j:e[i])
		{
			if(scc[i]!=scc[j])
			{
				e2[scc[i]].push_back(scc[j]);
				dex[scc[j]]++;
			}
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		if(dex[i]==0)
		{
			q.push(i);
			inq[i]=1;
			dp[i]=num[i];
			ans=max(ans,dp[i]);
		}
	}
	while(!q.empty())
	{
		x=q.front();
		q.pop();
		for(auto i:e2[x])
		{
			if(inq[i])
			{
				continue;
			}
			dex[i]--;
			dp[i]=max(dp[i],dp[x]+num[i]);
			ans=max(ans,dp[i]);
			if(!dex[i])
			{
				q.push(i);
				inq[i]=1;
			}
		}
	}
	cout<<ans;
}
```


---

## 作者：xiaoyuchenp (赞：1)

**题意**

这道题题意确实比较晦涩。

有 $s$ 个盒子，每个盒子有 $n$ 个元件，在这些元件中有 $m$ 个元件是输出元。这些盒子按照一定的规则（具体见题面）产生 01 串。若盒子 $i$ 产生的所有串盒子 $j$ 都能产生，则称 $j$ 为 $i$ 的升级。求最长的升级序列。

**思路**

图论题。先判断两个宝盒间是否有升级关系，若有，连一条单向边。以此建立一个有向图，这道题就变成了求图的最长链。求最长链用 Tarjan 缩点再 dfs 或者 Floyd 最长路皆可，这里采用 Tarjan 缩点的方法。

首先判断两点之间是否有升级关系。

设两宝盒分别为 $a$ 与 $b$，显然保证两个盒子产生的字符串相同，每次必须加上相同的字符，即 $0$ 或 $1$。若 $a$ 在某个元件输出了字符串，而 $b$ 没有，显然 $b$ 并非 $a$ 的升级。用深搜实现。

```cpp
void check(int x,int y,int posx,int posy){
	if(!a[x].out[posx]&&a[y].out[posy]){flg=false;return;}
	if(vis[posx][posy])return;
	vis[posx][posy]=true;
	check(x,y,a[x].mac[posx][0],a[y].mac[posy][0]);
	check(x,y,a[x].mac[posx][1],a[y].mac[posy][1]);
}
```

接着根据求出的升级关系建图。

```cpp
for(int i=1;i<=s;i++)
	for(int j=1;j<=s;j++){
		if(i==j)continue;
		memset(vis,false,sizeof(vis));
		flg=true;
		check(i,j,1,1);
		if(flg)add(i,j);
	}
```

建图后，跑一遍 Tarjan 缩点。如果还不了解缩点的相关知识，可以去做一做有关的模板题，如 [P3387](https://www.luogu.com.cn/problem/P3387)。

```cpp
void tarjan(int id){
	low[id]=dfn[id]=++num;
	ins[id]=true;st.push(id);
	for(int i=head[id];i;i=graph[i].next){
		int to=graph[i].to;
		if(!dfn[to]){
			tarjan(to);
			low[id]=min(low[id],low[to]);
		}else if(ins[to])low[id]=min(low[id],dfn[to]);
	}
	if(dfn[id]==low[id]){
		int t=0;idxtot++;
		while(t!=id){
			t=st.top();st.pop();
			ins[t]=false;
			bui[t]=idxtot;
			gtot[idxtot]++;
		}
	}
}
```

接着是搜索最长链。这里采用深搜解决。从每一个节点开始遍历，将该节点作为最长链的链顶，一步一步搜下去就可以了。

```cpp
int dfs(int id){
	if(ans[id])return ans[id];
	ans[id]=gtot[id];
	for(int i=head2[id];i;i=graph2[i].next){
		int to=graph2[i].to;
		ans[id]=max(ans[id],gtot[id]+dfs(to));
	}
	return ans[id];
}
```

个人感觉本题的难点在于判断两个盒子的升级关系这一步，这一步解决了，下面的步骤基本上套模板就可以实现了。

**code**

```cpp
#include<bits/stdc++.h>
#define MAXN 55
#define MAXS 105
#define MAXM 1000005
using namespace std;
struct magic_machine{
	bool out[MAXN];
	int mac[MAXN][2];
}; 
struct node{
	int to,next,from;
};
magic_machine a[MAXS];
int s,n,m;
node graph[MAXM],graph2[MAXM];
int head[MAXS],idx,head2[MAXS],idx2;
bool vis[MAXN][MAXN],flg=true;
int low[MAXS],dfn[MAXS],ins[MAXS],num,gtot[MAXS],bui[MAXS],idxtot;
stack<int>st;
int ans[MAXS];
void add(int u,int v){
	graph[++idx].to=v;
	graph[idx].from=u;
	graph[idx].next=head[u];
	head[u]=idx;
}
void add2(int u,int v){
	if(u==v)return;
	graph2[++idx2].to=v;
	graph2[idx2].from=u;
	graph2[idx2].next=head2[u];
	head2[u]=idx2;
}
void check(int x,int y,int posx,int posy){
	if(!a[x].out[posx]&&a[y].out[posy]){flg=false;return;}
	if(vis[posx][posy])return;
	vis[posx][posy]=true;
	check(x,y,a[x].mac[posx][0],a[y].mac[posy][0]);
	check(x,y,a[x].mac[posx][1],a[y].mac[posy][1]);
}
void tarjan(int id){
	low[id]=dfn[id]=++num;
	ins[id]=true;st.push(id);
	for(int i=head[id];i;i=graph[i].next){
		int to=graph[i].to;
		if(!dfn[to]){
			tarjan(to);
			low[id]=min(low[id],low[to]);
		}else if(ins[to])low[id]=min(low[id],dfn[to]);
	}
	if(dfn[id]==low[id]){
		int t=0;idxtot++;
		while(t!=id){
			t=st.top();st.pop();
			ins[t]=false;
			bui[t]=idxtot;
			gtot[idxtot]++;
		}
	}
}
int dfs(int id){
	if(ans[id])return ans[id];
	ans[id]=gtot[id];
	for(int i=head2[id];i;i=graph2[i].next){
		int to=graph2[i].to;
		ans[id]=max(ans[id],gtot[id]+dfs(to));
	}
	return ans[id];
}

int main(){
	ios::sync_with_stdio(NULL);
	cin.tie(NULL);cout.tie(NULL);
	cin>>s;
	for(int i=1;i<=s;i++){
		cin>>n>>m;
		for(int j=1,tmp;j<=m;j++)cin>>tmp,a[i].out[++tmp]=true;
		for(int j=1,p1,p2;j<=n;j++){
			cin>>p1>>p2;
			a[i].mac[j][0]=++p1;a[i].mac[j][1]=++p2;
		}
	}
	for(int i=1;i<=s;i++)
		for(int j=1;j<=s;j++){
			if(i==j)continue;
			memset(vis,false,sizeof(vis));
			flg=true;
			check(i,j,1,1);
			if(flg)add(i,j);
		}
	for(int i=1;i<=s;i++)
		if(!dfn[i])tarjan(i);
	for(int i=1;i<=idx;i++)
		add2(bui[graph[i].from],bui[graph[i].to]);
	int maxn=-1;
	for(int i=1;i<=idxtot;i++)maxn=max(maxn,dfs(i));
	cout<<maxn;
	return 0; 
}
```

---

## 作者：Dispwnl (赞：1)

看懂了楼下的楼下的题解，于是来发波题解

这题要做出来，首先**语文**要好。。。

题目大意：有一坨咒语机，每个咒语机有一坨元件，元件分为普通元（瞎起名字）和输出元

一个咒语机经过运行，能产生一坨咒语

如果一个咒语机能产生的咒语包括另一个咒语机能产生的咒语

这个咒语机就是另一个咒语机的升级

在程序中把它们间连一条有向边

通过bfs判断它们升级关系

最后跑一个floyed最长路

输出最长的就完了

最难的就是bfs判断关系

```cpp
bool look(int x,int y)
{
    memset(use,0,sizeof(use));
    f[1][1]=f[1][2]=0;
    int he=1,ta=1;
    while(he<=ta)
    {
        int xx=f[he][1],yy=f[he][2];
        if(go[x][xx]&&!go[y][yy])//如果这个咒语机有输出元而另一个没有，那它们间肯定不存在升级关系
        return 0;
        int xxx=make[x][xx][0],yyy=make[y][yy][0];//加0的元
        int xxxx=make[x][xx][1],yyyy=make[y][yy][1];//加1的元
        if(!use[xxx][yyy])
        {
            use[xxx][yyy]=1;
            f[++ta][1]=xxx;//存入队列
            f[ta][2]=yyy;
        }
        if(!use[xxxx][yyyy])
        {
            use[xxxx][yyyy]=1;
            f[++ta][1]=xxxx;
            f[ta][2]=yyyy;
        }
        he++;
    }
    return 1;//存在升级关系
}
```


---

## 作者：Templ_1 (赞：0)

楼下的玄学levelup...然而这个题本意是tarjan..


思路楼下已经说的很清楚了：

1. BFS建图

2. ** Tarjan 删掉图中的强连通分量**

3.  跑最长路..


为什么要跑一遍Tarjan?

假设A,B 是两个完全相同的咒语机，判断升级序列的时候必然有 is\_levelup(A,B) == true 和 is\_levelup(B,A) == true 同时成立，

答案的升级序列应该是 ....AB.... 或者 ....BA.... , 而不是 ....ABABABABAB.... ，所以要先缩点再统计


---


# 边三连通分量

## 题目背景

对于一张无向图 $G = (V, E)$。

- 我们称两个点 $u, v ~ (u, v \in V, u \neq v)$ 是边三连通的，当且仅当存在三条从 $u$ 出发到达 $v$ 的，相互没有公共边的路径。
- 我们称一个点集 $U ~ (U \subseteq V)$ 是边三连通分量，当且仅当对于任意两个点 $u', v' ~ (u', v' \in U, u' \neq v')$ 都是边三连通的。
- 我们称一个边三连通分量 $S$ 是极大边三连通分量，当且仅当不存在 $u \not \in S$ 且 $u \in V$，使得 $S \cup \{u\}$ 也是边三连通分量。

## 题目描述

给出一个 $n$ 个点，$m$ 条边的无向图 $G = (V, E)$，$V = \{1, 2, \ldots, n\}$，请求出其所有的极大边三连通分量。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/eqpng8sy.png)

如图，$1 \to 3$ 共有 $(1, 2, 3)$，$(1, 3)$，$(1, 4, 3)$ 三条路径，它们互相都没有相交的边。因此 $1$ 与 $3$ 在同一个边三连通分量中。

由于 $2$，$4$ 点度都只有 $2$，不可能有三条边不相交的到其它点的路径，因此它们自己形成边三联通分量。

---

#### 数据范围

- 对于 $30\%$ 的数据，$n \le 100$，$m \le 200$。
- 对于 $50\%$ 的数据，$n \le 1000$，$m \le 2000$。
- 对于 $80\%$ 的数据，$n \le 10 ^ 5$，$m \le 2 \times 10 ^ 5$。
- 对于 $100\%$ 的数据，$1 \le n, m \le 5 \times 10 ^ 5$，$1 \le u, v \le n$。可能有重边和自环。

---

#### 来源

题目搬运自 [Three-Edge-Connected Components](https://judge.yosupo.jp/problem/three_edge_connected_components)。

## 样例 #1

### 输入

```
4 5
1 3
1 2
4 1
3 2
3 4```

### 输出

```
3
1 3
2
4```

## 样例 #2

### 输入

```
17 29
1 2
1 10
1 10
2 3
2 8
3 4
3 5
4 6
4 6
5 6
5 6
5 7
7 8
7 11
7 12
7 17
7 17
8 9
9 10
11 12
11 17
12 13
12 16
13 14
13 15
13 16
14 15
14 16
15 16```

### 输出

```
7
1 10
2 8
3 4 5 6
7 11 17
9
12
13 14 15 16```

# 题解

## 作者：iMya_nlgau (赞：44)

[~~更差的阅读体验~~](https://www.cnblogs.com/sapphire162/p/15941274.html)

这题仅有的题解是一个叫做 Absorb-Eject 的算法，但其实对于边三连通分量有一个更经典也更容易理解的做法（HDU6431 NewNippori）。

前置知识：

- tarjan 求边双连通分量
- 对 dfs 树的一定理解

使用 tarjan 算法求出割边之后我们考虑每个边双连通分量（不在同一个边双连通分量中的点显然也不在同一个边三连通分量中）。

首先，求出一颗 dfs 树，原图中的边可以分为树边和非树边，由于是无向图，所以树边一定只有后向边而没有前向边和横叉边。每条非树边可以看作是覆盖了一些树边，而由于是边双连通分量，所以每条树边至少被一条非树边覆盖。

如果两个点不在一个边三连通分量中，我们可以通过割掉两条边使这两点不再连通，我们考虑怎样选择要割的两条边，不难发现，有两种情况：

1. 割掉一条树边和一条非树边。如果一条树边仅被一条非树边覆盖，那么我们就可以割掉这条树边以及覆盖它的非树边使图分成两部分。
2. 割掉两条树边。如果覆盖两条树边的非树边集合相同，那么可以通过割掉这两条树边使图分成两部分（可以参考下图）

![](https://cdn.luogu.com.cn/upload/image_hosting/dngvrs0u.png)

图中蓝色的边是树边，红色的边是非树边，而覆盖 $1$ 号边和 $3$ 号边的非树边集合相同（都是被 $6$ 号边和 $7$ 号边覆盖），所以割掉 $1$ 号边和 $3$ 号边之后图会分割成两个部分（绿色圈出的部分和其余部分）。当然，覆盖 $2$ 号边的非树边也是 $6$ 和 $7$，所以割掉 $1$ 号边和 $2$ 号边，或割掉 $2$ 号边和 $3$ 号边也能将图分成两部分。

在考虑具体怎么割之前，先讲一下如何判断覆盖一条树边的非树边。我们可以给每条非树边随机一个 $[0,2^{64})$ 内的权值。令每个点的权值为所有从该点出发的非树边的权值的异或和，这样一个点子树内所有点的权值异或和就是覆盖了这个点的父边的所有非树边的权值异或和。通过这种方式，我们就可以用 Hash 表快速判断一条树边是否只被一条非树边覆盖，两条覆盖两条树边的非树边集合是否相同。

我们把所有边的权值插入一个 Hash 表，然后对于每条树边，如果覆盖了它的非树边权值异或和在 Hash 表中，那么它仅被一条非树边覆盖，我们直接割掉这些边，图裂成很多连通块，然后对于每个连通块，我们就只需考虑情况 $2$。

当前的连通块里会有很多能按照情况 $2$ 配对的树边，它们配对的方式一定是形如下图左面那种样子，即配对的树边都在一条祖孙链上，且不会出现右面两种的情况（图是自己画的，有点丑）。

![](https://cdn.luogu.com.cn/upload/image_hosting/i5g4g4d9.png)

图中的边都表示树边，颜色相同的边是可以配对的边。

还可能会有多条树边之间都能两两配对的情况，这是我们要选择最近的配对，这样才能让拆出的连通块中不再存在配对的树边，即三连通。

具体的，我们在 dfs 回溯的过程中维护一个 Hash 表，这样对于每条树边，我们能快速求出它下方与它配对的另一条树边，然后直接删掉两条边之间的连通块，这个连通块中一定不存在可以配对的边了，因为如果存在，也在之前的过程中删完了。这也就是说，删掉的这个连通块就是一个边三连通分量。删掉所有配对边之间部分之后，剩下的部分也是一个边三连通分量。

这样我们就以 $O(n+m)$ 的复杂度找出了所有三连通分量。

代码（感觉还是挺短的（？）

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <random>
#include <ctime>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

inline int read() {
    int x = 0;
    char c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = x * 10 + (c ^ '0'), c = getchar();
    return x;
}

const int maxn = 5e5 + 10;
const int maxm = 2e6 + 10;

struct Edge {
    int to, next;
} edge[maxm];
int head[maxn], cnt = 1;
inline void addedge(int u, int v) { edge[++cnt] = (Edge){ v, head[u] }, head[u] = cnt; }

int n, m;
vector<vector<int> > ans;

int dfn[maxn], low[maxn], idx, cut[maxm];
void tarjan(int x, int fr) {
    dfn[x] = low[x] = ++idx;
    for (int i = head[x]; i; i = edge[i].next) {
        if (i == (fr ^ 1))
            continue;
        int y = edge[i].to;
        if (!dfn[y]) {
            tarjan(y, i);
            low[x] = min(low[x], low[y]);
            if (low[y] >= dfn[y])
                cut[i] = cut[i ^ 1] = true;
        } else
            low[x] = min(low[x], dfn[y]);
    }
}

void dfs1(int, int);
void dfs2(int, int);
void dfs3(int, int, vector<int> &);

typedef unsigned long long ull;

mt19937 rnd(time(NULL));
inline ull get_rnd() { return rnd() | 1ull * rnd() << 32; }

ull w[maxn];
gp_hash_table<ull, bool> st;
gp_hash_table<ull, int> mp;

int _dfn[maxn], _idx;
bool on_tree[maxm], cut1[maxm];
int fa[maxn];
void dfs1(int x, int fr) {
    _dfn[x] = ++_idx;
    for (int i = head[x]; i; i = edge[i].next) {
        if (i == (fr ^ 1) || cut[i])
            continue;
        int y = edge[i].to;
        if (_dfn[y]) {
            if (_dfn[y] > _dfn[x])
                continue;
            ull val = get_rnd();
            w[x] ^= val, w[y] ^= val;
            st[val] = true;
        } else {
            on_tree[i] = true, fa[y] = x;
            dfs1(y, i);
            w[x] ^= w[y];
        }
    }
    if (st.find(w[x]) != st.end())
        cut1[fr] = cut1[fr ^ 1] = true;
    if (cut1[fr] || !fr) {
        mp.clear();
        dfs2(x, 0);
        vector<int> tmp;
        dfs3(x, 0, tmp);
        ans.push_back(tmp);
    }
}

void dfs2(int x, int fr) {
    for (int i = head[x]; i; i = edge[i].next) {
        int y = edge[i].to;
        if (cut[i] || cut1[i] || !on_tree[i])
            continue;
        dfs2(y, i);
    }
    if (mp.find(w[x]) != mp.end()) {
        int y = mp[w[x]];
        vector<int> tmp;
        dfs3(x, y, tmp);
        ans.push_back(tmp);
        on_tree[fr] = false;
        addedge(fa[x], y);
        on_tree[cnt] = true, fa[y] = fa[x];
        mp[w[x]] = y;
    } else
        mp[w[x]] = x;
}

void dfs3(int x, int t, vector<int> &v) {
    v.push_back(x);
    for (int i = head[x]; i; i = edge[i].next) {
        int y = edge[i].to;
        if (cut[i] || cut1[i] || !on_tree[i] || y == t)
            continue;
        dfs3(y, t, v);
    }
}

int main() {
    n = read(), m = read();
    for (int i = 1; i <= m; i++) {
        int u = read(), v = read();
        addedge(u, v), addedge(v, u);
    }

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i, 0);

    for (int i = 1; i <= n; i++)
        if (!_dfn[i])
            dfs1(i, 0);

    for (vector<int> &v : ans) sort(v.begin(), v.end());
    sort(ans.begin(), ans.end());

    printf("%d\n", ans.size());
    for (vector<int> v : ans) {
        for (int x : v) printf("%d ", x);
        puts("");
    }
    return 0;
}
```
参考资料： 

- <https://blog.csdn.net/weixin_45313881/article/details/104032690>

---

## 作者：Tweetuzki (赞：28)

[题目链接](https://www.luogu.com.cn/problem/U119667)

> 给出一张 $n$ 个点 $m$ 条边的无向图，可能不连通、有重边、有自环、有割边。求其所有极大的边三连通分量。
>
> $n, m \le 5 \times 10 ^ 5$。

论文太长了，还没看完，目前只看懂了算法步骤，一些证明还咕在后面。就先介绍一下步骤，正确性证明和时间复杂度证明等我看懂以后补上来。附一个论文原地址：[A Simple 3-Edge-Connected Component Algorithm](https://xueshu.baidu.com/usercenter/paper/show?paperid=5a791af706fa9836a86af59d6778ff2f)，来源选 ResearchGate 那个可以免费下载。本文内图片均出自这篇论文。

由于这个算法的核心在于其中的 Absort-Eject 操作，我习惯称其为 Absorb-Eject 算法。Absorb-Eject 算法的思想与求点双、边双的 Tarjan 算法类似，都是利用算法过程中建出的 dfs 树，求出点之间的连边情况。故为了更清晰地弄懂这个算法，最好对点双、边双的 Tarjan 算法有一定的理解。

为了减少讨论，我们需要先删除掉原图上一些可有可无，但会导致一些麻烦的分类情况的边：自环和割边。

- 自环：显然存在一个最优方案使得连通的三条路径都不包含自环，故自环可删。
- 边三连通分量一定是边双连通分量，因此割边两端的边不可能属于同一个边三连通分量，故割边可删。

经过这样预处理转化后，我们将原图变成了若干无自环的边双连通分量的连通块。那么以下的算法过程，均在这样的边双中进行。

首先，对限制条件进行一定的观察：两个点 $u, v$ 在相同的边三内，当且仅当不存在一个边对 $(e_1, e_2)$，满足将原图的 $e_1, e_2$ 割开以后，$u$ 与 $v$ 不连通。

再加上这张图内没有割边，我们可以定义一个类似割边的定义：切边。我们称一条边 $e$ 是切边，当且仅当它能够与另外一条边 $e'$ 配合，把原图割成两个连通块。那么，对于一条边 $e = (u, v)$，若 $e$ 是一条切边，则 $u, v$ 一定不在一个相同的边三内；若 $e$ 不是一条切边，则 $u, v$ 一定在一个相同的边三内。所以我们只需要把原图中所有切边删去，剩下的边就将原图连成了若干边三。

于是我们明确了算法的目的：确定每条边是否为切边。

这个算法的核心步骤是 Absorb-Eject 操作，可译为吞吐操作。Absorb 会在一条边 $(w, u)$ 上进行，表示 $w$ 将 $u$ 吞并。吞并时，$u$ 消失，所有与 $u$ 相邻的边 $(x, u)$（除了 $(w, u)$ 以外），都变成与 $w$ 相邻的边 $(x, w)$。特殊地，如果 $u$ 的点度为 $2$ （注意此时的点度是吞并后形成的新图的点度，而点 $u$ 也可能已吞并了若干个点），那么可以割开这两条边使得 $u$ 与外界不连通，说明 $u$ 及 $u$ 已吞并过的点是一个单独的边三，就让 $w$ 将 $u$ 吐出来，而吐出来的 $u$ 失去所有相邻的边。

形式化来讲，对于每个点 $u$，定义其已吞并点集为 $\sigma(u)$，初始时，$\sigma(u) = \{u\}$。进行到目前的图为 $G' = (V', E')$，进行吞吐的边为 $(w, u)$。那么进行一次 Absorb-Eject 操作后，图会变成 $G' / e = (V'', E'')$。其中 $E'' = E' \setminus E_u \cup E_{w ^ +}$，其中 $E_u$ 表示 $G'$ 中与 $u$ 相邻的边，$E_{w ^ +} = \{ f' = (w, z) \mid \exists f \in E_u,\text{ such that } f = (u, z) \text{ for some } z \in V' - \{w\} \}$。而 $V''$ 需要分类讨论，若 $deg_{G'}(u) = 2$，则 $u$ 会被 $w$ 吐出来，那么 $V'$ 没变；若 $deg_{G'}(u) \neq 2$，则 $u$ 被 $w$ 吸收，$V'' = V' - \{u\}$，$\sigma(w) = \sigma(w) \cup \sigma(u)$。

由于可以证明（第一个待补证明的坑），若 $deg_{G'}(u) \neq 2$，则 $(w, u)$ 一定不是切边，也就是 $w, u$ 一定在一个边三内。换句话说，就是 $\sigma(w)$ 就是 $w$ 所代表的一个原图上的一个边三。在进行若干次吞并后，所有的边都消失了，变成若干独立的点。则每个独立的点就代表着原图上一个极大边三连通分量，就是我们想求的东西。

![pic1.png](https://i.loli.net/2020/06/18/A5lvqOF8IwCYpVc.png)

以上是核心步骤 Absorb-Eject。我们接下来用一个类似 Tarjan 算法的 dfs 过程，配合着 Absorb 操作，将原图一步步变成这样没有边的图，得到每一个表示极大边三连通分量的独立点。

又有一个奇怪的结论（第二个待补证明的坑）：递归完一个子树 $u$ 结束回溯后，子树 $u$ 内所有仍未确定是否为切边的边形成了一条一端为 $u$ 的路径，也即修改后的图形成了一条一端为 $u$ 的路径和若干代表者边三连通分量的独立点。我们称 $u$ 上挂着的这条路径为 $u$ - path，记 $P_u$，我们需要在 dfs 的过程中维护 $P_u$，最终到达根 $r$ 时的 $P_r$ 会为空，也就是再没有未确定是否为切边的边，就结束了我们的算法过程。

dfs 过程中，同样记录 $low$ 和 $dfn$，$dfn(u)$ 表示点 $u$ 在 dfs 序中的编号，$low(u)$ 表示 $u$ 经过最多一条返祖边能到达的 $dfn$ 最小值，那么有 $low(w) = \min(\{low(u) \mid u \text{ is a child of } w\} \cup \{ dfn(w') \mid (w, w') \text{ is a back-edge} \} \cup \{dfn(w)\})$。我们令此时 dfs 到了一个点 $w$，枚举其相邻边，分类讨论更新 $low$ 和 $P_w$。

- $(w, u)$ 是一条没用的边，即 $w = u$，或 $(w, u)$ 为割边，或 $u$ 是 $w$ 的父亲且 $w$ 是从 $u$ 的这条边过来（就是父边）。不管，continue。
- $(w, u)$ 是一条树边。递归执行 $dfs(u)$。首先判断一下 $deg_{G'}(u)$ 是否为 $2$，如果等于 $2$ 那么要先把 $u$ 独立吐出来形成一个单独的边三，同时把 $u$ 从 $P_u$ 中去掉，$P_u = P_u - u$。接着看 $low(u)$ 是否会对 $low(w)$ 产生贡献：
  - 若 $low(u) < low(w)$，大概由于增加了一条 $u \to low(u) \to low(w) \to P_w$ 的路径，原本还未确定的 $P_w$ 可以确定为不是切边了，于是让 $w$ 将原本的 $P_w$ 吞并掉，然后用 $w + P_u$ 把 $P_w$ 替换掉。  
    ![pic2.png](https://i.loli.net/2020/06/18/mUMyX8fBFRup2Iz.png)
  - 若 $low(u) \ge low(w)$，类似上一条，原本还未确定的 $P_u$ 可以确定为不是切边了，让 $w$ 把 $P_u$ 吞并掉，保持 $P_w$ 不变。
- $(w, u)$ 是一条返祖边。若再满足 $dfn(u)$ 可以更新 $low(w)$，那么 $P_w$ 可以确定为不是切边了，这时让 $w$ 把 $P_w$ 吞并掉，然后 $P_w$ 清空。
- $(w, u)$ 是一条前向边。由于 $(w, u)$ 这条边的存在，$u$ 一定落在 $P_w$ 上。那么这时 $P_w$ 的 $[w \cdots u]$ 部分可以确定为不是切边了，就让 $u$ 把 $P_w$ 的 $[w \cdots u]$ 部分吞并掉，剪掉 $P_w$ 的这段前缀。  
  ![pic3.png](https://i.loli.net/2020/06/18/HpRz4GuFPEQBhgo.png)

由于 $low(r) = 1$，所有的树边都会到 $low(u) \ge low(w)$ 这条，因此 $P_r$ 保持为空。也就是上面所说的，递归到根结束后，就确定了每条边是否为切边，算法顺利完成。

贴上论文中给出的伪代码：

![pic4.png](https://i.loli.net/2020/06/18/qVdRD27mG6vJchF.png)

最后，注意到图变化的时候边不需要显式地维护，只要维护每个点的相邻点度就好了。代码能比较容易地写出来。

我用了并查集维护一个点的集合，所以时间复杂度 $\mathcal{O}((n + m) \log n)$。实现细致一点可以把并查集扔掉，时间复杂度为 $\mathcal{O}(n + m)$。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <utility>
#include <vector>

const int MaxN = 500000, MaxM = 500000;

struct graph_t {
  int cnte;
  int head[MaxN + 5], to[MaxM * 2 + 5], next[MaxM * 2 + 5];

  graph_t() { cnte = 1; }

  inline void addEdge(int u, int v) {
    cnte++; to[cnte] = v;
    next[cnte] = head[u]; head[u] = cnte;
  }
};

struct union_find {
  int par[MaxN + 5];
  union_find() { memset(par, -1, sizeof par); }

  int find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }

  inline void merge(int u, int v) {
    int p = find(u), q = find(v);
    if (p == q) return;
    par[p] += par[q];
    par[q] = p;
  }
};

int N, M;
graph_t Gr;

class two_edge_connect {
private:
  int low[MaxN + 5], dfn[MaxN + 5], dfc;
  int stk[MaxN + 5], tp;
  int bel[MaxN + 5], s;

  void dfs(int u, int fe) {
    low[u] = dfn[u] = ++dfc;
    stk[++tp] = u;
    for (int i = Gr.head[u]; i; i = Gr.next[i]) {
      if ((i ^ fe) == 1) continue;
      int v = Gr.to[i];
      if (dfn[v] == 0) {
        dfs(v, i);
        low[u] = std::min(low[u], low[v]);
      } else
        low[u] = std::min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
      s++;
      for (;;) {
        int v = stk[tp--];
        bel[v] = s;
        if (u == v) break;
      }
    }
  }

public:
  void init() {
    memset(dfn, 0, sizeof dfn);
    dfc = tp = s = 0;
    for (int i = 1; i <= N; ++i)
      if (dfn[i] == 0) dfs(i, 0);
  }

  inline bool isbridge(int u, int v) {
    return bel[u] != bel[v];
  }
};

class three_edge_connect {
private:
  two_edge_connect bcc;
  union_find uf;
  int low[MaxN + 5], dfn[MaxN + 5], end[MaxN + 5], dfc;
  int deg[MaxN + 5];

  inline bool insubtree(int u, int v) {
    if (dfn[u] <= dfn[v] && dfn[v] <= end[u]) return true;
    else return false;
  }

  inline void absorb(std::vector<int> &path, int u, int w = 0) {
    while (path.empty() == false) {
      int v = path.back();
      if (w > 0 && insubtree(v, w) == false) break;
      path.pop_back();
      deg[u] += deg[v] - 2;
      uf.merge(u, v);
    }
  }

  void dfs(int u, int fe, std::vector<int> &pu) {
    low[u] = dfn[u] = ++dfc;
    for (int i = Gr.head[u]; i; i = Gr.next[i]) {
      int v = Gr.to[i];
      if (u == v || bcc.isbridge(u, v) == true) continue;
      deg[u]++;
      if ((i ^ fe) == 1) continue;
      if (dfn[v] == 0) {
        std::vector<int> pv;
        dfs(v, i, pv);
        if (deg[v] == 2) pv.pop_back();
        if (low[v] < low[u]) {
          low[u] = low[v];
          absorb(pu, u);
          pu = pv;
        } else absorb(pv, u);
      } else {
        if (dfn[v] > dfn[u]) {
          absorb(pu, u, v);
          deg[u] -= 2;
        } else if (dfn[v] < low[u]) {
          low[u] = dfn[v];
          absorb(pu, u);
        }
      }
    }
    end[u] = dfc;
    pu.push_back(u);
  }

public:
  void init() {
    memset(dfn, 0, sizeof dfn);
    memset(deg, 0, sizeof deg);
    dfc = 0;
    bcc.init();
    for (int i = 1; i <= N; ++i) {
      if (dfn[i] == 0) {
        std::vector<int> pi;
        dfs(i, 0, pi);
      }
    }
  }

  std::vector< std::vector<int> > getall() {
    std::vector< std::vector<int> > res(N), ans;
    for (int i = 1; i <= N; ++i) {
      int x = uf.find(i);
      res[x - 1].push_back(i);
    }
    for (int i = 0; i < N; ++i)
      if (res[i].empty() == false) ans.push_back(res[i]);
    return ans;
  }
};

void init() {
  scanf("%d %d", &N, &M);
  for (int i = 1; i <= M; ++i) {
    int u, v;
    scanf("%d %d", &u, &v);
    Gr.addEdge(u, v);
    Gr.addEdge(v, u);
  }
}

inline bool cmp(const std::vector<int> &x, const std::vector<int> &y) { return x[0] < y[0]; }

void solve() {
  static three_edge_connect tcc;
  tcc.init();
  std::vector< std::vector<int> > ans = tcc.getall();
  for (int i = 0; i < (int) ans.size(); ++i)
    std::sort(ans[i].begin(), ans[i].end());
  std::sort(ans.begin(), ans.end(), cmp);
  printf("%d\n", (int) ans.size());
  for (int i = 0; i < (int) ans.size(); ++i) {
    int s = (int) ans[i].size();
    for (int j = 0; j < s; ++j)
      printf("%d%c", ans[i][j], " \n"[j == s - 1]);
  }
}

int main() {
  init();
  solve();
  return 0;
}

```


---

## 作者：yyyyxh (赞：18)

感觉口胡了很多遍的模板算法，快 NOI 了才想起来写写代码。其实边三的代码很好写，网上许多资料都写麻烦了。

边联通性其实是一个很能扩展的东西。两个点之间如果**最少**要割开 $k$ 条边才能使它们之间不联通，称这两个点的边联通度为 $k$。称两个点之间是 $k$ 边联通的，当且仅当这两个点的边联通度 $\ge k$。

边联通性具有很好的传递性。即若 $x,y$ 是 $k$ 边联通的，$y,z$ 是 $k$ 边联通的，那么 $x,z$ 是 $k$ 边联通的。证明考虑假设一个大小 $<k$ 的边集割开了 $x,z$，那么这个割集势必没有割开 $x,y$ 和 $y,z$，此时 $x,z$ 仍联通矛盾。$k$ 边联通分量就是把 $k$ 边联通的点连边形成的连通块。由上面的传递性我们可以知道边联通分量中的点两两 $k$ 边联通。

这件事告诉我们了 $k$ 边联通分量总是可以被良好定义且结构优美的，但是点联通分量光是在 $k=2$ 的时候就略显丑陋——有可能一个点在多个点双中。

如何判断 $k$ 边联通性呢？我们考虑一个比较通用的问题：给定一张图的 $k$ 条边，问其是否是边割集。

做法是考虑经典的[割空间与环空间](https://rushcheyo.blog.uoj.ac/blog/6704)。极小的边割集定义为对于一个边割集加回其中一条边后，图的联通性**有变化**，或者说你考虑把图仍以分成两个部分，那么跨过这两个部分的边组成一个极小的边割集。一个图的割空间是一个由所有极小的边割集组成的线性空间，即其在对称差（异或）运算下封闭。一个图的回路空间也是线性空间（回路指每个连通块都有欧拉回路的边集，也就是每个点均与其中的偶数条边相邻）。这两个空间互为正交补，即边割集与回路的公共部分一定大小为偶数，且与一个回路公共部分大小为偶数的一定是边割集。

由一些经典结论我们知道只用非树边和树边形成的简单环异或就可以得到所有的环。所以判定一个边集是不是极小的边割集可以**异或哈希**给非树边随机赋权，然后让树边的权值等于所有覆盖它的非树边权值的异或。这样如果一个边集权值异或和为 0，说明其与某个回路正交。

判断一个集合是否是边割集就是看存不存在一个非空子集是极小边割集，那么就是问这个集合的权值是不是线性相关。

现在对于 $k=3$ 的情况，我们应用这个技巧给边随机赋权。那么一个点集边三联通相当于其中所有边的大小不超过三的子集线性不相关。线性相关无非这么几种情况：

+ 存在一条树边边权为 0。即这条边是割边，在三联通分量中我们需要割开这条树边。

+ 存在一个树边和非树边权值相等。我们也需要割开这条树边。

+ 存在两条树边权值相等。此时中间的部分需要跟两边的部分隔开。

发现我们要做一个分割连通块的操作，一种方法是 dfs 打标记，但这样细节还是不够少。我发现 tzc_wk 博客里的方法是又好写又好记。我们同样采用**异或哈希**的手法，一个连通块需要跟其它部分分开相当于这个连通块需要全体异或上一个与众不同的值。那么对于前两种情况，打一个子树异或标记，对于第三种一上一下打两个子树异或标记，就可以区分出中间的连通块。

由于是 dfs 树，非树边一定直上直下，那么所有权值相等的树边肯定排列在一条直上直下的树链上，显然我们只需要处理这条链上相邻的两条边就够了。我们只需要开个全局 Hash 表，在 dfs 回溯时找到子树中第一条跟它权值相同的边处理第三种情况。（因为跟它权值相同的边都在一条链上，所以如果 Hash 表中有那么一定在当前边的子树中）

只需要两次 dfs。如果你选择多跑一次 tarjan 处理第一种情况有点多此一举了。

```cpp
#include <cstdio>
#include <random>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
mt19937_64 rng(random_device{}());
typedef unsigned long long ull;
int read(){
	char c=getchar();int x=0;
	while(c<48||c>57) c=getchar();
	do x=x*10+(c^48),c=getchar();
	while(c>=48&&c<=57);
	return x;
}
int n,m;
const int N=500003;
int hd[N],ver[N<<1],nxt[N<<1],tot=1;
void add(int u,int v){nxt[++tot]=hd[u];hd[u]=tot;ver[tot]=v;}
int dfn[N],num;
ull w[N],eq[N];
typedef vector<int> vi;
__gnu_pbds::gp_hash_table<ull,int> mp,id;
__gnu_pbds::gp_hash_table<ull,bool> exi;
vector<vi> res;
bool ontr[N<<1],rt[N];
void dfs(int u,int las){
	dfn[u]=++num;
	for(int i=hd[u];i;i=nxt[i]){
		int v=ver[i];
		if(i==las) continue;
		if(dfn[v]){
			if(dfn[v]<dfn[u]){
				ull val=rng();
				w[u]^=val;
				w[v]^=val;
				exi[val]=1;
			}
		}
		else{
			ontr[i]=1;
			dfs(v,i^1);
			w[u]^=w[v];
		}
	}
	if(exi.find(w[u])!=exi.end()) eq[u]^=rng();
	else{
		auto it=mp.find(w[u]);
		if(it!=mp.end()){
			ull val=rng();
			eq[it->second]^=val;
			eq[u]^=val;
			it->second=u;
		}
		else mp[w[u]]=u;
	}
}
void split(int u){
	for(int i=hd[u];i;i=nxt[i])
		if(ontr[i]){
			int v=ver[i];
			eq[v]^=eq[u];
			split(v);
		}
	if(id.find(eq[u])!=id.end()) 
		res[id[eq[u]]].emplace_back(u);
	else{
		id[eq[u]]=res.size();
		res.emplace_back(1,u);
	}
}
int main(){
	n=read();m=read();
	for(int i=1;i<=m;++i){
		int u=read(),v=read();
		add(u,v);add(v,u);
	}
	exi[0]=1;
	for(int i=1;i<=n;++i)
		if(!dfn[i]){
			eq[i]^=rng();
			dfs(i,0);
			rt[i]=1;
		}
	for(int i=1;i<=n;++i) if(rt[i]) split(i);
	for(vi &cur:res) sort(cur.begin(),cur.end());
	sort(res.begin(),res.end());
	printf("%lu\n",res.size());
	for(vi cur:res){
		for(int x:cur) printf("%d ",x);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：Felix72 (赞：1)

边三连通分量的定义是一个割掉任意两条边仍然联通的点集。

我们建出 DFS 树，考虑割掉边的方案：

- 割一条树边，满足它是桥；
- 割一条树边和一条非树边，满足这条非树边是覆盖这条树边的唯一非树边；
- 割两条树边，满足这两条树边所对应的非树边集合一致。

我们使用异或哈希来求解这个问题。考虑构造一种方案，给每个节点一个哈希值。最后两个节点的哈希值相同即这两个节点在同一个边三连通分量中。

对于第一种情况，我们给每条割边对应的子树打一个随机数异或标记；

对于第二种情况，我们给满足这个限制的所有树边的子树打一个随机数异或标记；

对于第三种情况，考虑到满足条件的两条边一定是祖孙边，我们先用哈希维护最近的满足条件的边，再给两条边之间的连通块打一个随机数异或标记。给连通块打标记的方法可以拆解为先给深度更小的边对应子树打一个随机数异或标记，再给深度更大的边对应的子树打一个同样的异或标记容斥掉影响。

最后求出每个点的标记异或和即可。

```cpp
 /* NE_Cat 4.3 */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 500010;
typedef unsigned long long ull;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
int n, m; vector < int > edge[N], tr[N], extend[N];
bool vis[N], is_root[N]; int dep[N];

vector < int > tricc[N]; int tricc_n;
inline bool cmp(vector < int > u, vector < int > v) {return u.front() < v.front();}

inline void build(int pos)
{
	vis[pos] = true;
	for(int to : edge[pos])
	{
		if(!vis[to])
		{
			dep[to] = dep[pos] + 1;
			tr[pos].push_back(to);
			build(to);
		}
		else if(dep[to] > dep[pos]) extend[pos].push_back(to);
	}
}

const int P = 1e6 + 3;
struct Hash_Table
{
	vector < ull > state[P]; vector < int > con[P];
	bool vis[P]; queue < int > q;
	inline void refresh(int id) {if(!vis[id]) vis[id] = true, q.push(id);}
	inline void clear()
	{
		while(!q.empty())
		{
			int id = q.front(); q.pop();
			vis[id] = false;
			state[id].clear(); con[id].clear();
		}
	}
	inline void modify(ull num, int data)
	{
		int id = num % P; refresh(id);
		for(int i = 0; i < (int)state[id].size(); ++i)
			if(state[id][i] == num)
				{con[id][i] = data; return ;}
		state[id].push_back(num); con[id].push_back(data);
	}
	inline int get(ull num)
	{
		int id = num % P;
		for(int i = 0; i < (int)state[id].size(); ++i)
			if(state[id][i] == num)
				return con[id][i];
		return 0;
	}
}; Hash_Table mp;
ull tag[N], w[N]; int len[N];
struct node {ull num; int id;} nd[N];
inline bool cmp_node(node u, node v)
{
	if(u.num == v.num) return u.id < v.id;
	return u.num < v.num;
}
inline void work(int pos)
{
	for(int to : tr[pos])
	{
		work(to);
		tag[pos] ^= tag[to];
		len[pos] += len[to];
	}
	if(len[pos] <= 1) w[pos] ^= rnd();
	if(tag[pos] == 0) w[pos] ^= rnd();
	else
	{
		ull cur = tag[pos]; int x = mp.get(cur);
		if(x)
		{
			ull hash_num = rnd();
			w[x] ^= hash_num;
			w[pos] ^= hash_num;
		}
		mp.modify(cur, pos);
	}
}
inline void get(int pos, ull num)
{
	num ^= w[pos]; nd[pos].num = num;
	for(int to : tr[pos]) get(to, num);
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1, x, y; i <= m; ++i)
	{
		cin >> x >> y;
		edge[x].push_back(y);
		edge[y].push_back(x);
	}
	for(int i = 1; i <= n; ++i) if(!vis[i]) is_root[i] = true, build(i);
//	cerr << "tree" << '\n';
//	for(int i = 1; i <= n; ++i)
//		for(int j : tr[i])
//			cerr << i << " " << j << '\n';
//	cerr << "extend" << '\n';
//	for(int i = 1; i <= n; ++i)
//		for(int j : extend[i])
//			cerr << i << " " << j << '\n';
	for(int i = 1; i <= n; ++i)
		for(int j : extend[i])
			{ull cur = rnd(); tag[j] ^= cur, tag[i] ^= cur; ++len[j], --len[i];}
	for(int i = 1; i <= n; ++i) nd[i].id = i;
	for(int i = 1; i <= n; ++i) if(is_root[i]) mp.clear(), work(i), get(i, 0);
	sort(nd + 1, nd + n + 1, cmp_node);
	for(int l = 1, r = 0; l <= n; ++l)
	{
		r = l; while(r < n && nd[r + 1].num == nd[r].num) ++r;
		++tricc_n; for(int i = l; i <= r; ++i) tricc[tricc_n].push_back(nd[i].id);
		l = r;
	}
	sort(tricc + 1, tricc + tricc_n + 1, cmp);
	cout << tricc_n << '\n';
	for(int i = 1; i <= tricc_n; ++i)
	{
		for(int x : tricc[i]) cout << x << " ";
		cout << '\n';
	}
	return 0;
}
/*

*/
```

---


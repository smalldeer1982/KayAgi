# [USACO21DEC] Paired Up P

## 题目描述

数轴上总计有 $N$（$1\le N\le 5000$）头奶牛，每一头奶牛都是荷斯坦牛（Holstein）或更赛牛（Guernsey）之一。第 $i$ 头奶牛的品种为 $b_i\in \{H,G\}$，第 $i$ 头奶牛的位置为 $x_i$（$0 \leq x_i \leq 10^9$），而第 $i$ 头奶牛的重量为 $y_i$（$1 \leq y_i \leq 10^5$）。

根据 Farmer John 的信号，某些奶牛会组成对，使得

- 每一对包含位置相差不超过 $K$ 的一头荷斯坦牛 $h$ 和一头更赛牛 $g$（$1\le K\le 10^9$）；也就是说，$|x_h-x_g|\le K$。

- 每一头奶牛要么包含在恰好一对中，要么不属于任何一对。
- 配对是**极大的**；也就是说，没有两头未配对的奶牛可以组成对。

你需要求出未配对的奶牛的重量之和的可能的范围。具体地说，

- 如果 $T=1$，计算未配对的奶牛的最小重量和。

- 如果 $T=2$，计算未配对的奶牛的最大重量和。

## 说明/提示

【样例解释1】

奶牛 $2$ 和 $3$ 可以配对，因为她们的距离为 $1$，不超过 $K = 4$。这个配对方案是极大的，因为奶牛 $1$，唯一余下的更赛牛，和奶牛 $4$ 的距离为 $5$，和奶牛 $5$ 的距离为 $7$，均大于 $K = 4$。未配对的奶牛的重量和为 $1 + 6 + 9 = 16$。

【样例解释2】

奶牛 $1$ 和 $2$ 可以配对，因为她们的距离为 $2 \leq K = 4$，同时奶牛 $3$ 和 $5$ 可以配对，因为她们的距离为 $4 \leq K = 4$。这个配对方案是极大的，因为只剩下了奶牛 $4$。未配对的奶牛的重量和即为唯一未配对的奶牛的重量，即为 $6$。

【样例解释3】

这个例子的答案为 $18+465+870+540=1893$。

【数据范围】

- 测试点 4-7 满足 $T=1$；
- 测试点 8-14 满足 $T=2$ 且 $N\le 300$；
- 测试点 15-22 满足 $T=2$。

**注意：本题的内存限制为 $\text{512MB}$，是通常限制的两倍。**


## 样例 #1

### 输入

```
2 5 4
G 1 1
H 3 4
G 4 2
H 6 6
H 8 9```

### 输出

```
16```

## 样例 #2

### 输入

```
1 5 4
G 1 1
H 3 4
G 4 2
H 6 6
H 8 9```

### 输出

```
6```

## 样例 #3

### 输入

```
2 10 76
H 1 18
H 18 465
H 25 278
H 30 291
H 36 202
G 45 96
G 60 375
G 93 941
G 96 870
G 98 540```

### 输出

```
1893```

# 题解

## 作者：ETHANK (赞：14)

> 题目难度：USACO P+/NOI-

**子任务 1：**$T=1,N\le 5000$

设 $dp[i][j]$ 为当前考虑到第 $i$ 头 H 牛，第 $j$ 头 G 牛时匹配的牛的最大权值和。那么我们可以选择不匹配 $i$ ，不匹配 $j$ ，或者是将 $i$ 和 $j$ 匹配。

时间复杂度： $O(N^2)$

```cpp
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define pii pair<int,int>
#define vi vector<int>
int main(){
	T=read(),n=read(),K=read();
    vector <pii> cow[2];
    cow[0].pb({0,0}),cow[1].pb({0,0});
    rep(i,1,n){
        cin>>c;
        int x=read(),y=read();
        cow[c=='H'].pb({x,y});
        sum+=y;
    }
    A=sz(cow[0]),B=sz(cow[1]);
    if(T==1){
        vector <vi> dp(A+1,vi(B+1));
        rep(i,1,A)rep(j,1,B){
            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            if(abs(cow[0][i].x-cow[1][j].x)<=K)
                dp[i][j]=max(dp[i][j],dp[i-1][j-1]+cow[0][i].y+cow[1][j].y);
        }
        printf("%d\n",sum-dp[A][B]);
    }
}
```

**子任务 2：**$T=2,N\le 300$

对于最大化未匹配的权值和，我们考虑使用类似的 dp 状态。但是注意到在上述转移时，有时候我们考虑的并不是**最大**匹配，只是因为最优解只产生于最大匹配（若不是最大匹配，多匹配两头牛显然更优），我们才能得到 $T=1$ 时的答案。 

于是我们需要把**最大**匹配这一限制加入我们的 dp 状态，具体地，我们加入一维 $k$ 表示最后一头未匹配的牛，假设我们不想匹配当前的 H 牛，那么牛 $k$ 必须满足如下条件之一：

- 牛 $k$ 的品种是 $H$
- 牛 $k$ 与当前牛的距离大于 $K$

状态量是 $O(N^3)$ ，每次转移还是 $O(1)$ 的，足够通过该子任务。

时间复杂度：$O(N^3)$

```cpp
vector <vector<vi>> dp(A+1,vector<vi>(B+1,vi(n+1,-1)));
dp[0][0][n]=0;
rep(i,0,A)rep(j,0,B)rep(k,0,n){
    if(dp[i][j][k]==-1)continue;
    if(i<A&&j<B&&abs(cow[0][i].x-cow[1][j].x)<=K)
        Max(dp[i+1][j+1][k],dp[i][j][k]);
    if(i<A&&(!(A<=k&&k<n&&cow[0][i].x<=cow[1][k-A].x+K)))
        Max(dp[i+1][j][i],dp[i][j][k]+cow[0][i].y);
    if(j<B&&(!(k<A&&cow[1][j].x<=cow[0][k].x+K)))
        Max(dp[i][j+1][A+j],dp[i][j][k]+cow[1][j].y);
}
int ans = 0;
rep(i,0,n)Max(ans,dp[A][B][i]);
printf("%d\n",ans);
```

**子任务 1：**$T=1,N\le 5000$

考虑最终的优化，$i,j$ 两维比较难舍去，但我们可以修改最后一维的定义。定义 $dp[i][j][x]$ 为处理到前 $i$ 头 H 牛， $j$  头 G 牛，并且钦定下一种不放入匹配的牛的品种为 $x$ 。有转移：
$$
dp[i][j][x]\to dp[i+1][j+1][x]\\
dp[i][j][H]\to dp[i+1][j][H]\\
dp[i][j][G]\to dp[i][j+1][G]\\
$$
 当然我们也可以转换钦定的品种：如果之前我们被强制不选 H 牛，那么最后一个未匹配的 H 牛最多是第 $i$ 个。能不放入匹配的 G 牛需要离该牛距离至少为 $K$ ，且在该牛之前的所有牛都要放入匹配。预处理出对于所有 $i$ ，满足条件的 G 牛编号的最小值，并且判断这段区间的牛是否能全部匹配即可。

时间复杂度：$O(N^2)$

```cpp
per(i,A,1)per(j,B,1){
    if(chk(i,j))lst[i][j]=lst[i+1][j+1]+1;
    else lst[i][j]=0;
}
int j=1;
rep(i,1,A){
    while(j<=B&&(chk(i,j)||G[j].x<H[i].x))j++;
    nxtH[i] = j;
}
j=1;
rep(i,1,B){
    while(j<=A&&(chk(j,i)||H[j].x<G[i].x))j++;
    nxtG[i] = j;
}
memset(f,-0x3f,sizeof(f));
memset(g,-0x3f,sizeof(g));
nxtG[0] = nxtH[0] = 1;
f[0][0] = g[0][0] = 0;
rep(i,0,A)rep(j,0,B){
    int cnt = max(nxtH[i]-j-1,0);
    if(i+cnt<=A && lst[i+1][j+1]>=cnt)
        Max(g[i+cnt][j+cnt],f[i][j]);
    cnt = max(nxtG[j]-i-1,0);
    if(j+cnt<=B && lst[i+1][j+1]>=cnt)
        Max(f[i+cnt][j+cnt],g[i][j]);
    if(i<A && j<B && chk(i+1,j+1)){
        Max(f[i+1][j+1],f[i][j]);
        Max(g[i+1][j+1],g[i][j]);
    }
    if(i<A) Max(f[i+1][j],f[i][j]+H[i+1].y);
    if(j<B) Max(g[i][j+1],g[i][j]+G[j+1].y);
}
printf("%d\n",max(f[A][B],g[A][B]));
```

---

## 作者：EuphoricStar (赞：6)

如果 $T = 1$，可以把重量全部取相反数转化成 $T = 2$。接下来只考虑 $T = 2$ 的情况。

下文的 $m$ 代表原题中的 $K$。

设第 $i$ 个 G 牛的位置和重量分别为 $a_{0, i}, b_{0, i}$，第 $i$ 个 H 牛的位置和重量分别为 $a_{1, i}, b_{1, i}$。

考虑 dp。dp 状态的前两维一定是 $i, j$ 表示当前考虑了前 $i$ 个 G 牛和前 $j$ 个 H 牛的匹配。为了使匹配极大，还需要多记一维上一个失配的牛，无法承受。

考虑改变 dp 状态的含义，设 $f_{i, j, 0/1}$ 表示当前考虑了前 $i$ 个 G 牛和前 $j$ 个 H 牛的匹配，上一个失配的牛是第 $i$ 个 G 牛或者第 $j$ 个 H 牛。

考虑转移。以 $f_{i, j, 0}$ 为例。枚举连续的匹配数 $k$，如果 $(i + 1, j + 1), (i + 2, j + 2), \ldots, (i + k, j + k)$ 都能形成匹配，那么 $f_{i + k + 1, j + k, 0} \gets f_{i, j, 0} + b_{0, i + k + 1}$。在此基础上，如果 $a_{1, j + k + 1} > a_{0, i} + m$，那么可以切换失配的牛的品种，即 $f_{i + k, j + k + 1, 1} \gets f_{i, j, 0} + b_{1, j + k + 1}$。$f_{i, j, 1}$ 类似。然后我们可以 $O(n)$ 地转移：

```cpp
ll f[maxn][maxn][2];
	
void solve() {
	mems(f, -0x3f);
	f[0][0][0] = f[0][0][1] = 0;
	for (int i = 0; i <= A; ++i) {
		for (int j = 0; j <= B; ++j) {
			for (int k = 0; i + k + 1 <= A && j + k <= B; ++k) {
				if (k && abs(a[0][i + k] - a[1][j + k]) > m) {
					break;
				}
				f[i + k + 1][j + k][0] = max(f[i + k + 1][j + k][0], f[i][j][0] + b[0][i + k + 1]);
				if (a[0][i + k + 1] - a[1][j] > m && j) {
					f[i + k + 1][j + k][0] = max(f[i + k + 1][j + k][0], f[i][j][1] + b[0][i + k + 1]);
				}
			}
			for (int k = 0; i + k <= A && j + k + 1 <= B; ++k) {
				if (k && abs(a[0][i + k] - a[1][j + k]) > m) {
					break;
				}
				f[i + k][j + k + 1][1] = max(f[i + k][j + k + 1][1], f[i][j][1] + b[1][j + k + 1]);
				if (a[1][j + k + 1] - a[0][i] > m && i) {
					f[i + k][j + k + 1][1] = max(f[i + k][j + k + 1][1], f[i][j][0] + b[1][j + k + 1]);
				}
			}
		}
	}
	printf("%lld\n", max(f[A][B][0], f[A][B][1]));
}
```

发现转移是把一条对角线取 $\max$。考虑类似差分，最后再前缀 $\max$ 起来。以 $f_{i, j, 0}$ 为例，可以选择让第 $i + 1$ 个 G 牛失配，即 $f_{i + 1, j, 0} \gets f_{i, j, 0} + b_{0, i + 1}$；可以选择让第 $i + 1$ 个 G 牛和第 $j + 1$ 个 H 牛匹配，即 $f_{i + 1, j + 1, 0} \gets f_{i, j, 0}$；还要切换失配的牛的种类。找到最小的非负整数 $k$ 使得 $a_{1, j + k + 1} > a_{0, i} + m$，若 $(i + 1, j + 1), (i + 2, j + 2), \ldots, (i + k, j + k)$ 都能匹配，那么 $f_{i + k, j + k, 1} \gets f_{i, j, 0}$。

容易合理地预处理做到时空复杂度均为 $O(n^2)$。

[code](https://loj.ac/s/1913080)

---

## 作者：周子衡 (赞：5)

我们先来解决下面这个问题：给定两个大小相等的集合 $G,H$，其中 $G$ 是全体 G 牛的某个子集，$H$ 是全体 H 牛的某个子集，判定 $G,H$ 中的牛能否构成一个符合题意的匹配。梳理一下题中条件，可知这等价于：

- 不存在一头不在 $G$ 中的 G 牛和一头不在 $H$ 中的 H 牛使得这两头牛距离小于等于 $K$。
- 将 $G$ 中的牛和 $H$ 中的牛分别按坐标排序，则 $G$ 中的第 $i$ 头牛和 $H$ 中的第 $i$ 头牛距离小于等于 $K$。（从贪心思想可以得知：若存在一组配对方案，那么顺序配对也一定可行。）

考虑将 G 牛和 H 牛分别按坐标排序。我们从小到大考虑所有的 G 牛、H 牛，不难设计出如下 DP 状态：

- $F(i,j,k,l)$：在已经决定了所有编号 $< i$ 的 G 牛、编号 $< j$ 的 H 牛是否在配对中，其中编号 $< i$ 的 G 牛中编号最大的、未被选择的 G 牛编号为 $k$，编号 $< j$ 的 H 牛中编号最大的、未被选择的 H 牛编号为 $l$，且已选择的 G 牛和 H 牛数量相等的情况下，已选择的牛的价值总和的最大 / 最小值。

（方便起见，这里考虑的是所有在配对中的牛，和原问题之间是互补的关系。）

其中，记录 $k,l$ 的目的是为了判断某牛可否不选。具体来说，如果编号为 $i$ 的 G 牛距离编号为 $l$ 的 H 牛不超过 $K$，那么 $i$ 是必选的；反之亦然。转移时，可以考虑要么 $i,j$ 同时选（此时 $i,j$ 间距离应不超过 $K$），或者有某个不选。两边分别转移即可。

上面的 DP 容易理解，但这个做法状态数达到了 $O(n^4)$，需要优化。我们可以观察到：$k,l$ 中有一个限制是无用的。具体来说，假设编号为 $k$ 的 G 牛比编号为 $l$ 的 H 牛的位置靠左，那么由于这两头牛距离大于 $K$，而接下来考虑的 H 牛都在编号为 $l$ 的 H 牛的右边，自然距离编号为 $k$ 的 G 牛也大于 $K$，这样 $k$ 就不需要考虑了；反之同理。这样我们把状态数优化到了 $O(n^3)$ 级别。

进一步考虑优化。我们只保留所有 $k=i-1$ 或 $l=j-1$ 的状态，这样状态总数便仅有 $O(n^2)$ 级别。与前两个算法不同的是，这个算法暴力转移时间复杂度 $O(n)$，超过时限，我们需要考虑加速转移。以 $k=i-1$ 为例，如果 $i,j$ 中某个不选那么很好转移；如果都选且配成一对，那么接下来一定会一路将 $(i+1,j+1),(i+2,j+2),...$ 都配成一对，直到某个 $i+t$ 没有选或者 $j+t$ 没有选。可以发现，这样的 $t$ 落在某个范围内。同时可以发现，这样一次能转移到的状态都有着相同的 $(i-j)$ 值，可以对每个 $(i-j)$ 值都利用一个数据结构维护。直接线段树维护是 $O(n^2\log n)$ 的应该会被卡常。精细实现的话可以进一步观察性质：每次更新的区间要么互不相交，要么右端点相同，而且右端点相同的区间左端点单调递增，可以用双端队列来维护。这样总时间复杂度 $O(n^2)$，常数略大，应该能通过此题。

（代码咕掉了）

**后记**

这两天看了看 USACO 1 月比赛的题，感觉似乎比 12 月的比赛简单，没有特别想写题解的题，就回来把这个题的题解补了。回过头来看这题算是这两场 USACO 里最难而且最有意思的一个题了，而且我的做法似乎和官方题解不太一样，就写篇博客记录一下吧。

---

## 作者：Anonymely (赞：1)

好题。

第一问即最大化匹配和，容易发现直接设 $f_{i,j}$ 表示考虑 $H$ 前 $i$ 个和 $G$ 前 $j$ 个就是对的，因为由于要答案最大所以跑出来的一定是最大匹配，不会出现有点对未匹配的情况。

第二问则需要考虑如何为最大匹配，暴力一点需要多加一维 $x$ 表示上一个未匹配的牛在哪里，复杂度不可接受。

改一下状态，多加一维 $0/1$ 表示未匹配的牛在 $i/j$，转移枚举接下来的匹配长度，以及是否改变未匹配的牛。注意刚刚的转移是 $O(1)$，状态是 $O(n^3)$，这里我们让转移是 $O(n)$，状态是 $O(n^2)$。

发现本质在对一条对角线取 $\max$，改成前缀 $\max$ 即可。

[submission](https://www.luogu.com.cn/record/119973857)

---


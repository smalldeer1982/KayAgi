# [SDOI2012] 基站建设

## 题目描述

up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。

为了简化问题，我们假设移动公司，所有的基站、up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点**可能**会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r$ 是固定的，接收半径 $r'$ 是可调的的。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)

一个基站 $i$ 如果想从另一个基站 $j$ 接收到信号（当且仅当 $x_j<x_i$），必须满足 $i$ 的接收范围与 $j$ 的发射范围**相切**，且需要付 $\sqrt{r'_i}$ 的额外费用。启动每一个点 $i$ 都需要费用 $v_i$。

up 主家如果能接收到某个基站的信号，只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)

当然费用越少就越好咯，于是 up 主想要请你帮他的忙。

## 说明/提示

对于 $100\%$ 的数据 $n\le5\times 10^5$，$x_i,m \le 10^{12}$，$v_i \le 10000$

## 样例 #1

### 输入

```
10 33
5 4 660
10 2 2040
11 6 3207
14 5 2006
18 3 6130
19 9 3363
22 1 1265
25 8 2836
27 10 7961
29 7 9075```

### 输出

```
3501.000```

# 题解

## 作者：TKXZ133 (赞：11)

[基站建设](https://www.luogu.com.cn/problem/P2497)

### 题目大意

在平面上存在 $n$ 个点，第 $i$ 个点的坐标为 $(x_i,0)$，具有一个发射半径 $r_i$ 和一个费用 $v_i$。

连接具有方向性，当且仅当 $j<i$ 且点 $i$ 的接收范围与点 $j$ 的发射范围相切时点 $i$ 才能连接到点 $j$。

第 $i$ 个点的发射范围是指一个圆心在 $(x_i,r_i)$，半径为 $r_i$ 的圆，接收范围是指一个圆心在 $(x_i,r_i')$，半径为 $r_i'$ 的圆，其中 $r_i'$ 可以被指定。

点 $i$ 连接到点 $j$ 的代价被定义为 $\sqrt{r_i'}+v_i$，连接具有按方向的传递性，也就是说，若 $a$ 连接到 $b$，$b$ 连接到 $c$，那么 $a$ 也连接到 $c$。

平面上还存在一个特殊点 $u$，点 $u$ 连接到点 $j$ 的条件是 $x_j+r_j\ge m$，且没有代价。求将点 $u$ 连接到点 $1$ 的最小代价。

### 思路分析

[斜率优化 DP](https://www.cnblogs.com/TKXZ133/p/17532085.html) 好题。

设 $f_i$ 表示考虑到第 $i$ 个点，第 $i$ 个点强制连接到某个点的最小代价。

考虑初值，有 $f_1=v_1$。考虑终值，所求即 $\min\limits_{x_i+r_i\ge m} f_i$。

枚举第 $i$ 个点连接到的点 $j$，容易得状态转移方程为：

$$f_i=\min_{j<i}(f_j+w(i,j))$$

其中，$w(i,j)$ 表示将点 $i$ 和点 $j$ 连接的代价，即 $r_i'+v_i$。

$r_i'$ 可以直接计算出来，根据勾股定理，有 $(r_i'-r_j)^2+(x_i-x_j)^2=(r_i'+r_j)^2$，容易解得 $r_i'=\frac{(x_i-x_j)^2}{4r_j}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ckbbfiuz.png)

故 $w(i,j)=\frac{x_i-x_j}{2\sqrt{r_j}}+v_i$。

代入原方程，则：

$$f_i=\min_{j<i}(f_j+\frac{x_i-x_j}{2\sqrt{r_j}}+v_i)$$

然后是常规斜率优化化简：

$$\begin{aligned}f_i&=f_j+\frac{x_i}{2\sqrt{r_j}}-\frac{x_j}{2\sqrt{r_j}}+v_i\\(f_i-v_i)&=(\frac{1}{2\sqrt{r_j}})(x_i)+(f_j+\frac{x_j}{2\sqrt{r_j}})\end{aligned}$$

设：

$$\begin{cases}y=f_i-v_i\\k=\frac{1}{2\sqrt{r_i}}\\x=x_i\\b=f_j+\frac{x_j}{2\sqrt{r_j}}\end{cases}$$

问题转化为每次插入一条 $k_i=\frac{1}{2\sqrt{r_i}},b_i=f_i+\frac{x_i}{2\sqrt{r_i}}$ 的直线，查询 $x=x_i$ 处的最小值，用[李超线段树](https://www.cnblogs.com/TKXZ133/p/17529789.html)优化即可。

考虑到 $x_i$ 的值域较大，可以对其离散化。

### 代码

```
#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>
#include <algorithm>

using namespace std;
#define int long long
const int N=500500;
#define inf 1e18
#define mid ((l+r)>>1)

int n,m;
int x[N],bx[N],r[N],v[N];

double f[N],ans=inf;

struct Line{
    double k,b;
}line[N];

double calc(int id,int pos){//计算第 id 条直线在离散化后的 pos 处的值
    return line[id].k*bx[pos]+line[id].b;
}

bool Less(int id1,int id2,int pos){//比较两条直线的优劣
    return calc(id1,pos)<calc(id2,pos);
}

struct ST{//简洁的李超线段树
    int a[N<<2];
    void add(int p,int l,int r,int id){
        if(l==r){if(Less(id,a[p],l)) a[p]=id;return ;}
        if(Less(id,a[p],mid)) swap(a[p],id);
        if(Less(id,a[p],l)) add(p<<1,l,mid,id);
        if(Less(id,a[p],r)) add(p<<1|1,mid+1,r,id);
    }
    double query(int p,int l,int r,int pos){
        double res=calc(a[p],pos);
        if(l==r) return res;
        if(pos<=mid) res=min(res,query(p<<1,l,mid,pos));
        else res=min(res,query(p<<1|1,mid+1,r,pos));
        return res;
    }
}tree;

signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld%lld%lld",&x[i],&r[i],&v[i]);
        bx[i]=x[i];
    }
    int tot=unique(bx+1,bx+n+1)-bx-1;
    for(int i=1;i<=n;i++)
        x[i]=lower_bound(bx+1,bx+tot+1,x[i])-bx;//常规离散化
    line[0]={0,inf};//将第 0 条线的值赋为无穷，可以省去特判空直线的情况
    f[1]=v[1];//初始化
    line[1]=Line{1/(2*sqrt(r[1])),f[1]-bx[x[1]]/(2*sqrt(r[1]))};
    tree.add(1,1,n,1);//插入第一条直线
    for(int i=2;i<=n;i++){
        f[i]=tree.query(1,1,n,x[i])+v[i];
        line[i]=Line{1/(2*sqrt(r[i])),f[i]-bx[x[i]]/(2*sqrt(r[i]))};
        tree.add(1,1,n,i);//插入直线
    }
    for(int i=1;i<=n;i++)
        if(bx[x[i]]+r[i]>=m) ans=min(ans,f[i]);//对所有满足条件的点取最小值
    printf("%.3lf\n",ans);
    return 0;
}
```

---

## 作者：agicy (赞：8)

点此使用更佳 [$\huge{\texttt{My Blog}}$](https://www.lu-anlai.com/oi/solution/sdoi2012-r2d1t3/)。

一道神奇的 斜率优化DP 题。

题目链接：[Luogu P2497](https://www.luogu.com.cn/problem/P2497)/[BZOJ 3006](http://www.lydsy.com/JudgeOnline/problem.php?id=3006)/SDOI2012 R2D1T3。

# 题目

## 题目描述

up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。

为了简化问题，我们假设移动公司，所有的基站，up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点不会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r_1$ 是固定的，接收半径 $r_2$ 是可调的的。如下图：

![](https://www.lu-anlai.com/wp-content/uploads/2020/04/SDOI2012-R2D1T3-Z3.png)

一个点 $i$ 如果能从另一个点 $j$ 接收到信号（当且仅当 $x_j < x_i$)，必须满足 $i$ 的接收范围与 $j$ 的发射范围相切，并且需要付 $\sqrt{r_{2,i}}$ 的额外费用。同时启动每一个点 $i$ 都需要费用 $v_i$。

当然一个点如果能够发射的 up 主家只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：

![](https://www.lu-anlai.com/wp-content/uploads/2020/04/SDOI2012-R2D1T3-Z4.png)

当然费用越少就越好咯，于是 up 主想要请你帮他的忙。

## 数据范围

$$1\leq n\leq 5 \times 10^6$$
$$x_i,m\leq 10^{12}$$
$$v_i\leq 10^4$$

## 时空限制

|题目|时间限制|空间限制|
|:-:|:-:|:-:|
|[Luogu P2497](https://www.luogu.com.cn/problem/P2497)|$$13\text{s}$$|$$500\text{MiB}$$|
|[BZOJ 3006](http://www.lydsy.com/JudgeOnline/problem.php?id=3006)|$$?\text{s}$$|$$?\text{MiB}$$|
|SDOI2012 R2D1T3|$$13\text{s}$$|$$512\text{MiB}$$|

# 题解

## 思路

首先，我们要求出 $i,j$ 之间信号传递的代价。

![](https://www.lu-anlai.com/wp-content/uploads/2020/04/SDOI2012-R2D1T3-Z1.png)

![](https://www.lu-anlai.com/wp-content/uploads/2020/04/SDOI2012-R2D1T3-Z2.png)

所以根据勾股定理得到式子：

$$(r_{2,i}+r_{1,j})^2=(r_{2,i}-r_{1,j})^2+(x_i-x_j)^2$$

$$4r_{2,i}\times r_{1,j}=(x_i-x_j)^2$$

所以联通代价为 $\sqrt{r_{2,i}}=\frac{x_i-x_j}{2\sqrt{r_{j}}}$。

设 $\text{dp}_i$ 信号达到基站 $i$ 的最小代价，那么首先可以看出：

$$\text{dp}_1=v_1$$
$$\text{dp}_i=\min_{j\in[1,i-1]}(\text{dp}_j+\frac{x_i-x_j}{2\sqrt{r_{j}}})+v_i$$

发现这是一个简单的动态规划问题，上述式子的时间复杂度为 $\Theta(n^2)$。

然后考虑优化，运用排除法：~~单调队列~~、斜率优化。

于是考虑斜率优化。

1. 化简式子

	进行移项
	$$\text{dp}_i-v_i-\frac{1}{2\sqrt{r_j}}\times x_i=\text{dp}_j-\frac{x_j}{2\sqrt{r_j}}$$
	然后设 $y=\text{dp}_j-\frac{x_j}{2\sqrt{r_j}}$，$k=x_i$，$x=-\frac{1}{2\sqrt{r_j}}$，$b=\text{dp}_i-v_i$。
    
2. 分析

	分析得出，我们实际上是要使得 $b$ 最小化，于是维护一个下凸包即可。
    
    但是发现本题中 $x=-\frac{1}{2\sqrt{r_j}}$ 不单调，所以用**神奇方法**（下文介绍）维护即可。

## 代码

维护凸包方法有很多：

1. 不维护，考虑基于时间的分治算法（CDQ 分治），将整个区间分为 $\log_2n$ 个凸包，一一求解即可，然后向归并排序一样合并，时间复杂度为 $\Theta(n\log_2^2n)$。
2. Splay+二进制分组，时间复杂度为 $\Theta(n\log_2^2n)$。
3. 李超线段树，时间复杂度为 $\Theta(n\log_2n)$。

下面就是李超线段树的版本。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
typedef long long ll;
typedef double db;
#define eps 1e-12 //精度
#define INF 1e32 //正无穷
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
static char buf[100000],*p1=buf,*p2=buf;
inline ll read(void){ //快读，记得开 long long
	reg bool f=false;
	reg char ch=getchar();
	reg ll res=0;
	while(ch<'0'||'9'<ch)f|=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getchar();
	return f?-res:res;
}

const int MAXN=5000000+5;

struct Node{ //保存基站信息
	ll x,r;
	int v;
	inline void Read(void){
		x=read(),r=read(),v=read();
		return;
	}
};

int n;
ll m;
db dp[MAXN],ans;
Node a[MAXN];

struct SegmentTree{ //李超线段树
	#define mid ( ( (l) + (r) ) >> 1)
	struct Node{
		int son[2];
		db k,b;
	};
	int tot;
	Node unit[MAXN];
	inline db f(reg db x,reg db kk,reg db bb){
		return kk*x+bb;
	}
	inline void Query(reg ll l,reg ll r,reg int x,reg int y){
		if(x==0)
			return;
		dp[y]=min(dp[y],f(a[y].x,unit[x].k,unit[x].b));
		if(a[y].x<=mid)
			Query(l,mid,unit[x].son[0],y);
		else
			Query(mid+1,r,unit[x].son[1],y);
		return;
	}
	inline void Add(reg ll l,reg ll r,reg int x,db& k,db& b){
		if(x==0){
			++tot;
			unit[tot].k=k;
			unit[tot].b=b;
			return;
		}
		reg bool fl=(f(l,k,b)-f(l,unit[x].k,unit[x].b)>eps);
		reg bool fr=(f(r,k,b)-f(r,unit[x].k,unit[x].b)>eps);
		reg bool fm=(f(mid,k,b)-f(mid,unit[x].k,unit[x].b)>eps);
		if((fl)&&(fr)&&(fm))
			return;
		if((!fl)&&(!fr)&&(!fm)){
			unit[x].k=k;
			unit[x].b=b;
			return;
		}
		reg bool s=(fm^fr);
		if(!fm){
			swap(unit[x].k,k);
			swap(unit[x].b,b);
		}
		if(s)
			Add(mid+1,r,unit[x].son[s],k,b);
		else
			Add(l,mid,unit[x].son[s],k,b);
		if(!unit[x].son[s])
			unit[x].son[s]=tot;
		return;
	}
	#undef mid
};

SegmentTree T;

int main(void){
	n=read(),m=read();
	a[1].Read(); //读入公司信息
	for(reg int i=2;i<=n;++i)
		a[i].Read(); //读入其他信息（其实完全没有必要把两个分开）
	T.unit[1].k=1/(sqrt((db)a[1].r)*2); //初始节点
	T.unit[1].b=(db)(-a[1].x)/(sqrt((db)a[1].r)*2)+a[1].v;
	dp[1]=a[1].v;
	T.tot=1; //动态开点
	for(reg int i=2;i<=n;++i){ //动态规划
		dp[i]=INF;
		T.Query(a[1].x,a[n].x,1,i);
		dp[i]+=a[i].v;
		db k=1/(sqrt((db)a[i].r)*2);
		db b=(db)(-a[i].x)/(sqrt((db)a[i].r)*2)+dp[i];
		T.Add(a[1].x,a[n].x,1,k,b);
	}
	ans=INF; //统计答案
	for(reg int i=1;i<=n;++i)
		if(a[i].x+a[i].r>=m) //题目已经保证基站一定在家的左边，没必要判断 x-r 与 m 的关系
			ans=min(ans,dp[i]);
	printf("%.3lf\n",ans); //输出答案
	return 0;
}
```

---

## 作者：Seauy (赞：6)

楼下说 CDQ 是两只 log 的？并不见得……他要么笔误了要么忽略了 $x_i$ 是单调的这一事实

首先稍微几何分析一下列出状态转移方程

$$ dp_i=\min_{j=1}^{i-1} dp_j+\frac{x_i-x_j}{2\sqrt{r_j}}+V_i $$

$$ dp_1=V_1 $$

这样干推是 $O(n^2)$ 爆炸，想到能斜率优化，然后整理成关于 $j$ 的一次函数的形式

$$ \frac{x_j}{2\sqrt{r_j}}-dp_j=x_i(\frac{1}{2\sqrt{r_j}})+V_i-dp_i $$

这里要 $dp_i$ 最小就要让截距最小，维护上凸壳

发现凸包的 x 坐标并不单调，所以决定用 CDQ分治 维护一下

又发现斜率 $x_i$ 是单调递增的，所以在凸包上找点时不用二分，从后往前删点就行了

注意记得把点按 $x=\frac{1}{2\sqrt{r_i}}$ 归并排序一下

最后

$$ ans=\min_{1\leq i \leq n\space,\space x_i+r_i\geq m } dp_i $$

时间 $O(n \log n)$ 空间 $O(n)$

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long double ld;
typedef double dbl;
typedef long long ll;

const int MAXN=5e6;
const ld MAXV=1e13;

int n;ld m,ans=MAXV;
ld x[MAXN+5],R1[MAXN+5],V[MAXN+5];
ld dp[MAXN+5],X[MAXN+5],Y[MAXN+5];
int A[MAXN+5],Q[MAXN+5],Tail;

ld K(int a,int b) {return (Y[b]-Y[a])/(X[b]-X[a]);}

void CDQ(int L,int R)
{
	if(L==R) {Y[L]=x[L]*X[L]-dp[L];return;}
	int mid=(L+R)>>1;
	CDQ(L,mid);
	Tail=0;
	for(int i=L;i<=mid;i++)
	{
		while(Tail>1)
		{
			if(X[Q[Tail]]==X[A[i]])
			{
				if(Y[Q[Tail]]<Y[A[i]]) --Tail;
				break;
			}
			else if(K(Q[Tail-1],Q[Tail])<=K(Q[Tail],A[i])) --Tail;
			else break;
		}
		Q[++Tail]=A[i];
	}
	//printf("[%d,%d] %d\n",L,R,Tail);
	//for(int i=1;i<Tail;i++) cout<<K(Q[i],Q[i+1])<<' ';cout<<endl;
	//for(int i=1;i<=Tail;i++) printf("%d ",Q[i]);printf("\n");
	//for(int i=1;i<=Tail;i++) cout<<Y[Q[i]]<<' ';cout<<endl;
	//for(int i=1;i<=Tail;i++) cout<<X[Q[i]]<<' ';cout<<endl;
	for(int i=mid+1;i<=R;i++)
	{
		while(Tail>1)
			if(K(Q[Tail-1],Q[Tail])<=x[i]) --Tail;
			else break;
		dp[i]=min(dp[i],dp[Q[Tail]]+(x[i]-x[Q[Tail]])*X[Q[Tail]]+V[i]);
		//for(int j=L;j<=mid;j++) dp[i]=min(dp[i],dp[j]+(x[i]-x[j])*X[j]+V[i]);
	}
	CDQ(mid+1,R);
	Tail=L-1;
	for(int i=L,j=mid+1;i<=mid || j<=R;)
		if(i<=mid && j<=R)
		{
			if(X[A[i]]<X[A[j]]) Q[++Tail]=A[i],++i;
			else Q[++Tail]=A[j],++j;
		}
		else if(i<=mid) Q[++Tail]=A[i],++i;
		else Q[++Tail]=A[j],++j;
	for(int i=L;i<=R;i++) A[i]=Q[i];
}

int main()
{
	scanf("%d",&n),cin>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>R1[i]>>V[i];
		if(R1[i]==0) {--i,--n;continue;}
		X[i]=sqrt(R1[i])/(2*R1[i]);
		A[i]=i;
	}
	dp[1]=V[1];
	for(int i=2;i<=n;i++) dp[i]=MAXV;
	CDQ(1,n);
	//for(int i=1;i<=n;i++) cout<<dp[i]<<' ';cout<<endl;
	//for(int i=1;i<=n;i++) cout<<Y[i]<<' ';cout<<endl;
	//for(int i=1;i<=n;i++) cout<<X[i]<<' ';cout<<endl;
	for(int i=1;i<=n;i++)
		if(x[i]+R1[i]>=m) ans=min(ans,dp[i]);
	printf("%.3lf\n",(double)ans);
	return 0;
}
/*
10 33
5 4 660
10 2 2040
11 6 3207
14 5 2006
18 3 6130
19 9 3363
22 1 1265
25 8 2836
27 10 7961
29 7 9075
*/
```

注意把要算的根号预处理好避免在线求，以防被卡常

---

## 作者：Komodo (赞：3)

斜率优化dp模板题

首先，我们可以写出一个 $O(n^2)$ 的式子：

$$
dp_i=\min (dp_j+v_i+\frac{x_i-x_j}{2\sqrt{r_j}})
$$

然后套路地斜率优化，把它整理成 $b=y-kx$ 的形式，其中 $b$ , $k$ 为只含i的项， $x$ , $y$ 为只含 $j$ 的项。

然后就变成了这样：

$$
dp_i-v_i=(dp_j-\frac{x_j}{2\sqrt{r_j}})+\frac{1}{2\sqrt{r_j}}x_i
$$
$$
y=dp_j-\frac{x_j}{2\sqrt{r_j}}
$$
$$
x=-\frac{1}{2\sqrt{r_j}}
$$
$$
k=x_i
$$
$$
b=dp_i-v_i
$$
$$
b=y-kx
$$

然后发现 $x$ 不单调，所以我选择用splay维护凸包。

每次动态插入点，维护左线斜率和右线斜率，然后把不符合凸包要求的点一次性扔出去，如果插入点在凸包内部也直接扔。

剩下的就是平衡树板子了。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500010
#define ll long long
#define eps (1e-10)
#define inf (1e+30)
struct line{
	double k,b;
	line(double _k=0,double _b=0){k=_k,b=_b;}
	double val(double x){return k*x+b;}
};
struct node{
	int ch[2],f,id;
	double x,y,lk,rk;
};
struct SPLAY{
	node d[N];
	int cnt,root;
	#define lc d[x].ch[0]
	#define rc d[x].ch[1]
	SPLAY(){
		cnt=1;
		root=0;
	}
	inline bool get(int x){
		return d[d[x].f].ch[1]==x;
	}
	void turn(int x){
		int y=d[x].f,z=d[y].f,k=get(x);
		d[y].ch[k]=d[x].ch[k^1],d[d[x].ch[k^1]].f=y;
		d[y].f=x,d[x].ch[k^1]=y;
		d[x].f=z;if(z)d[z].ch[d[z].ch[1]==y]=x;
	}
	void splay(int x,int goal=0){
		while(d[x].f!=goal){
			int y=d[x].f,z=d[y].f;
			if(z!=goal)turn(get(y)==get(x)?y:x);
			turn(x);
		}
		if(!goal)root=x;
	}
	int query(int x,double k){
		if(!x)return 0;
		if(d[x].lk-eps<=k&&k<=d[x].rk+eps)return x;
		if(d[x].lk+eps>k)return query(d[x].ch[0],k);
		else return query(d[x].ch[1],k);
	}
	double slope(int x,int y){return (d[y].y-d[x].y)/(d[y].x-d[x].x);}
	int pre(){
		int x=d[root].ch[0],ret=x;
		while(x){
			if(d[x].lk-eps<slope(x,root))ret=x,x=rc;
			else x=lc;
		}
		return ret;
	}
	int post(){
		int x=d[root].ch[1],ret=x;
		while(x){
			if(d[x].rk+eps>slope(root,x))ret=x,x=lc;
			else x=rc;
		}
		return ret;
	}
	int ins(double x,double y,int idx){
		int u=root,v=0;
		while(u)v=u,u=d[u].ch[d[u].x<x];
		u=cnt++;d[u].x=x,d[u].y=y,d[u].id=idx;
		if(v){d[v].ch[d[v].x<x]=u;d[u].f=v;}
		else root=u;
		return u;
	}
	void insert(double vx,double vy,int idx){
		int x=ins(vx,vy,idx);
		splay(x);
		if(lc){
			int y=pre();
			splay(y,x);
			d[y].ch[1]=0;
			d[y].rk=d[x].lk=slope(y,x);
		}else d[x].lk=-inf;
		if(rc){
			int y=post();
			splay(y,x);
			d[y].ch[0]=0;
			d[y].lk=d[x].rk=slope(y,x);
		}else d[x].rk=inf;
		if(d[x].lk>d[x].rk+eps){
			int y=lc;
			root=y;d[y].f=0,d[y].ch[1]=rc,d[rc].f=y;
			d[y].rk=d[rc].lk=slope(y,rc);
		}
	}
	void pnt(int x){
		if(!x)return;
		pnt(lc);
		printf("(%lf,%lf) ",d[x].x,d[x].y);
		pnt(rc);
	}
	void print(){
		printf("CONV:");
		pnt(root);
		printf("\n");
	}
}s;
int n,m;
double dp[N],x[N],r[N],v[N];
int main(){/*
	while(1){
		double x,y;
		scanf("%lf%lf",&x,&y);
		s.insert(x,y,0);
		s.print();
	}*/
	scanf("%d%d",&n,&m);
	double ans=inf;
	for(int i=1;i<=n;i++){
		scanf("%lf%lf%lf",x+i,r+i,v+i);
		if(i==1){
			dp[i]=v[i];s.insert(-1/(2*sqrt(r[i])),dp[i]-x[i]/(2*sqrt(r[i])),i);continue;
		}
		int j=s.query(s.root,x[i]);
		dp[i]=dp[j]+v[i]+(x[i]-x[j])/(2*sqrt(r[j]));
		//printf("%d chooses %d,dp[%d]=%.3lf\n",i,j,i,dp[i]);
		s.insert(-1/(2*sqrt(r[i])),dp[i]-x[i]/(2*sqrt(r[i])),i);
		if(x[i]+r[i]+eps>=m){
			ans=min(ans,dp[i]);
		}
	}
	printf("%.3lf\n",ans);
	return 0;
}
```




---

## 作者：xuzz (赞：2)

看到题解区中的李超线段树全是动态开点版的，那我就写一篇离散化的。

感谢@jiangchenyangsong大佬为我提供的思路。
## 前置知识：
初中数学知识，李超线段树（想学斜率优化请移步其他题解）

首先选上移动公司： 

$$f_1=v_1$$

勾股定理可得：

$$(r_{1,j}+r_{2,i})^2=(r_{1,j}-r_{2,i})^2+(x_i-x_j)^2$$

$$f_i=v_i+min(f_j+\dfrac{x_i}{2\sqrt{r_{1,j}}}-\dfrac{x_j}{2\sqrt{r_{1,j}}})$$

这个式子本来能斜率优化，但我太蒟了，不会cdq，平衡树等写法所以就用李超线段树。

设 $x=x_i$，$k=\dfrac{1}{2\sqrt{r_{1,j}}}$，$b=f_j-\dfrac{x_j}{2\sqrt{r_{1,j}}}$

维护线段的最小值即可。

由于 $x$ 过大，有 $10^{12}$，可以动态开点，但由于 $x$ 从小到大输入，刚好为离散化省了一步，直接映射即可。

## code
本人李超线段树写法较为奇怪，请见谅
```cpp
#include<bits/stdc++.h>
#define N 500010
using namespace std;
long long read()
{
	long long x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') f=(ch=='-')?-1:1,ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f; 
}
int tree[N<<2];
long long xx[N],v[N],r[N],tot=1;
double k[N],b[N],f[N];
double g(int x,int y){return k[y]*xx[x]+b[y];}
void up(int u,int l,int r,int x)
{
	if(!tree[u])
	{
		tree[u]=x;  
		if(l==r) return ;
		int mid=(l+r)>>1;
		up(u<<1,l,mid,x),up(u<<1|1,mid+1,r,x);
		return;
	}
	if(l==r)
	{
		if(g(l,x)<g(l,tree[u])) tree[u]=x;
		return;
	}
	double a1=g(l,x),a2=g(r,x),b1=g(l,tree[u]),b2=g(r,tree[u]);
	if(a1<=b1&&a2<=b2){tree[u]=x;return;}
	if(a1>b1&&a2>b2) return ;
	int mid=(l+r)>>1;
	up(u<<1,l,mid,x),up(u<<1|1,mid+1,r,x);
	return;
}
double query(int u,int l,int r,int x)
{
	if(l==r) return g(x,tree[u]);
	double ans=g(x,tree[u]);
	int mid=(l+r)>>1;
	if(x<=mid) return min(ans,query(u<<1,l,mid,x));
	else return min(ans,query(u<<1|1,mid+1,r,x));
}
int main()
{
	long long n=read(),m=read();
	for(int i=1;i<=n;i++) xx[i]=read(),r[i]=read(),v[i]=read(),k[i]=1/(sqrt(r[i])*2),b[i]=-xx[i]/(sqrt(r[i])*2);
	f[1]=v[1],b[1]+=f[1],up(1,1,n,1);
	for(int i=2;i<=n;i++) f[i]=query(1,1,n,i)+v[i],b[i]+=f[i],up(1,1,n,i);
	double minn=1e18;
	for(int i=1;i<=n;i++)
		if(xx[i]+r[i]>=m)
			minn=min(minn,f[i]);
	printf("%.3lf\n",minn);
	return 0;
}
```


---

## 作者：lgswdn_SA (赞：2)

比较套路的 cdq 搞凸包的清新题目。

首先考虑算一下费用。我们发现从 $j$ 连接到 $i$ 的费用为 $\frac{x_i-x_j}{2\sqrt{r_j}}$。设 $t_i=\frac{1}{\sqrt{r_i}}$。

做一个普通的 DP。$f_i$ 代表必选 $i$ 基站，从移动公司连到 $i$ 的最少费用。

$$
f_i=\min f_j+(x_i-x_j)t_j+v_i
$$

转化一下。

$$
f_i=v_i+\min (f_j-x_jt_j)+x_it_j
$$

这是一个可以斜率优化的东西。把每个状态考虑成点 $(t_j,f_j-x_jt_j)$，每次转移相当于用斜率为 $-x_i$ 的线去切这些点并希望能得到一个最小的截距。容易发现这需要维护下凸壳。

由于 $t$ 不单调，所以我们考虑用 cdq 分治。最开始已经按照 $x_i$ 排序，所以就不需要有什么操作了。cdq 分治的时候，先分治左边，然后求出左边的点组成的一个下凸壳（用个单调栈），然后更新右边，然后再分治右边（套路的），最后按照 $t$ 归并一下。

这题如果不归并的话复杂度会 $O(n\log^2n)$，尽管可以在洛谷上过，但是实际上是没法过 $5\times 10^6$ 的。用了归并排序就可以变成 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int N=5e6+9;
typedef pair<int,int>pii;
typedef double ld;

inline long long read() {
	long long res=0, w=1; char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) {res=res*10+c-48; c=getchar();}
	return res*w;
}

int n,m,x[N],r[N],v[N],q[N],lc,rc;
ld t[N],f[N];

struct node {ld x,y;} p[N],la[N];
bool cmp(const node &a,const node &b) {return a.x<=b.x;}

bool cmp1(ld ax,ld ay,ld bx,ld by,ld cx,ld cy) { //slope(a,b)>slope(b,c)
	return (by-ay)*(cx-bx)>(bx-ax)*(cy-by);
}
ld calc(int j,int i) {
	return v[i]+p[j].y+x[i]*p[j].x;
}

void cdq(int l,int r) {
	if(l==r) {
		p[l].x=t[l], p[l].y=f[l]-x[l]*t[l];
		return;
	}
	int mid=(l+r)/2;
	cdq(l,mid);
	int top=0;
	rep(i,l,mid) {
		while(top>1&&cmp1(p[q[top-1]].x,p[q[top-1]].y,p[q[top]].x,p[q[top]].y,p[i].x,p[i].y)) top--;
		q[++top]=i;
	}
	rep(i,mid+1,r) {
		while(top>1&&calc(q[top-1],i)<calc(q[top],i)) top--;
		f[i]=min(f[i],calc(q[top],i));
	}
	cdq(mid+1,r);
	int i=l,j=mid+1,t=0;
	while(i<=mid&&j<=r) {
		if(cmp(p[i],p[j])) la[++t]=p[i++];
		else la[++t]=p[j++];
	}
	while(i<=mid) la[++t]=p[i++];
	while(j<=r) la[++t]=p[j++];
	t=0;
	rep(i,l,r) p[i]=la[++t];
}

signed main() {
	n=read(), m=read();
	rep(i,1,n) {
		x[i]=read(), r[i]=read(), v[i]=read();
		t[i]=1/(2*sqrt(r[i]));
	}
	rep(i,2,n) f[i]=2e18; f[1]=v[1];
	cdq(1,n);
	ld ans=2e18;
	rep(i,1,n) if(x[i]+r[i]>=m) ans=min(ans,f[i]);
	printf("%.3lf\n",ans);
	return 0;
}
```

---

## 作者：Varuxn (赞：2)

>[推销](https://www.cnblogs.com/Varuxn/p/15332650.html)

# 解题思路
**CDQ优化DP**

下文中 $pos_i$ 表示编号为 $i$ 的位置或者说坐标。

暴力 DP 转移方程是 $f_i=\min\limits_{1\le j<i}\{f_j+\dfrac{pos_i-pos_j}{2\sqrt{r_j}}\}+val_i$

这样直接转移是 $\mathcal{O}(n^2)$ 的，时间无法接受，尝试优化一下柿子。

对于 $r_j>r_k$ 并且 $j$ 优于 $k$ 的条件就是:

$$f_j+\dfrac{pos_i-pos_j}{2\sqrt{r_j}}<f_k+\dfrac{pos_i-pos_k}{2\sqrt{r_k}}$$

$$2\times \sqrt{r_jr_k}(f_j-f_k)<-pos_i\sqrt{r_k}+pos_j\sqrt{r_k}+pos_i\sqrt{r_j}-pos_k\sqrt{r_j}$$

$$pos_i(\sqrt{r_j}-\sqrt{r_k})>2\sqrt{r_jr_k}(f_j-f_k)-pos_j\sqrt{r_k}+pos_k\sqrt{r_j}$$

$$-pos_i<\dfrac{(2\times f_j-\frac{pos_j}{\sqrt{r_j}})-(2\times f_k-\frac{pos_k}{\sqrt{r_k}})}{\frac{1}{\sqrt{r_j}}-\frac{1}{\sqrt{r_k}}}$$

然后我们就可以让 x 轴表示 $\dfrac{1}{\sqrt{r_i}}$ y 轴表示 $2\times f_i-\dfrac{pos_i}{\sqrt{r_i}}$

由于 $pos$ 具有单调性，因此我们只需要 CDQ ，并且对于左区间以 $r$ 为关键字进行排序，单调队列维护就好了。

对于每一个 $\dfrac{1}{\sqrt{r}}$ 可以预处理，时间复杂度： $\mathcal{O}{nlog^2n}$，好像无法用归并排序减去一个 $log$。

注意变量的类型不然就会 100pts -> 17pts。
# code
```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define f() cout<<"Failed"<<endl
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
const int N=5e5+10,INF=2e18;
int n,m,q[N],pos[N];
double f[N],ans=INF,c[N];
struct Node{int pos,r,val,id;double c;}s[N];
bool comp(Node x,Node y){return x.r<y.r;}
double g(int x){return 2.0*f[x]-(1.0*pos[x])*c[x];}
void CDQ(int l,int r)
{
	if(l==r) return ;
	int mid=(l+r)>>1,head=1,tail=0; CDQ(l,mid);
	sort(s+l,s+mid+1,comp);//对于左区间进行排序
	for(int i=l;i<=mid;i++)//单调队列处理左区间可能的答案
	{
		while(head<tail&&(g(s[i].id)-g(s[q[tail]].id))*(s[q[tail]].c-s[q[tail-1]].c)>=(g(s[q[tail]].id)-g(s[q[tail-1]].id))*(s[i].c-s[q[tail]].c)) tail--;
		q[++tail]=i;
	}
	for(int i=mid+1;i<=r;i++)//处理右区间答案
	{
		while(head<tail&&g(s[q[head+1]].id)-g(s[q[head]].id)<-s[i].pos*(s[q[head+1]].c-s[q[head]].c)) head++;
		f[s[i].id]=min(f[s[i].id],(f[s[q[head]].id]+(1.0*s[i].pos-1.0*s[q[head]].pos)*s[q[head]].c/2.0)+s[i].val);
	}
	CDQ(mid+1,r);
}
signed main()
{
	n=read(); m=read();
	for(int i=1,r,val;i<=n;i++)
	{
		pos[i]=read(); r=read(); val=read(); f[i]=INF;
		if(!r){i--;n--;continue;}
		s[i]=(Node){pos[i],r,val,i,1.0/sqrt(r)}; c[i]=1.0/sqrt(r);
	}
	f[1]=s[1].val; CDQ(1,n);
	for(int i=1;i<=n;i++)
		if(s[i].pos+s[i].r>=m)
			ans=min(ans,f[s[i].id]);//计算答案
	printf("%.3lf",ans);
	return 0;
}
```

---

## 作者：ningago (赞：1)

考虑 $i$ 向 $j$ 发射的代价（圆外的 $i,j$ 写反了 QAQ）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gl7k7jgw.png)

读图可知：$(R_i+R_j)^2=(R_i-R_j)^2+(X_i-X_j)^2$。

解得 $\sqrt {R_j}=\dfrac{x_i-x_j}{2\sqrt{R_i}}$。

故令 $dp_i$ 表示 $i(1<i\leq n)$ 点接收到信号的最小代价，则有：

$$\begin{aligned} 
dp_i & =\min_{1\leq j< i}\{dp_j+\dfrac{x_i-x_j}{2\sqrt{R_j}}\}+v_i\\
&=\min_{1\leq j< i}\{dp_j-\dfrac{x_j}{2\sqrt{R_j}}+\dfrac{x_i}{2\sqrt{R_j}}\}+v_i\end{aligned}$$

显然，考虑斜率优化，则：

$$\begin{cases}
X_j=\dfrac{1}{2\sqrt{R_j}}\\
Y_j=dp_j-\dfrac{x_j}{2\sqrt{R_j}}\\
K_i=x_i
\end{cases}$$

由于 $K,X$ 都无单调性，故离散化 $K$ 后使用李超线段树维护。复杂度 $O(n\log n)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

#define N 500010
int n, m;
double x_[N], r[N], v[N];
double dp[N];
int p[N];

struct Tree
{
	double k, b;
	Tree(double _ = 0, double __ = 1000000000000000)
	{
		k = _, b = __;
	}
	double calc(int x)
	{
		return k * x_[x] + b;
	}
}tr[N << 2];

#define lson k << 1
#define rson k << 1 | 1

void change(int k, int l, int r, Tree z)
{
	int mid = (l + r) >> 1;
	if(z.calc(mid) < tr[k].calc(mid))
		std::swap(z, tr[k]);
	if(z.calc(l) < tr[k].calc(l))
		change(lson, l, mid, z);
	if(z.calc(r) < tr[k].calc(r))
		change(rson, mid + 1, r, z);
}

double query(int k, int l, int r, int q)
{
	double res = tr[k].calc(q);
	if(l == r)
		return res;
	int mid = (l + r) >> 1;
	if(q <= mid)
		return std::min(res, query(lson, l, mid, q));
	else
		return std::min(res, query(rson, mid + 1, r, q));
}

double K(int i){return 1.0 / (2.0 * sqrt(r[i])); }
double B(int i){return dp[i] - 1.0 * x_[i] / (2.0 * sqrt(r[i])); }

int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
		scanf("%lf%lf%lf", &x_[i], &r[i], &v[i]);
	dp[1] = v[1];
	change(1, 1, n, (Tree){K(1), B(1)});
	double ans = 1000000000000000;
	for(int i = 2; i <= n; i++)
	{
		dp[i] = query(1, 1, n, i) + v[i];
		change(1, 1, n, (Tree){K(i), B(i)});
		if(x_[i] + r[i] >= m)
			ans = std::min(ans, dp[i]);
	}
	printf("%.3f\n", ans);
	return 0;
}
```

---

## 作者：__ycx2010__ (赞：0)

### 思路

容易列出 $O(n^2)$ 的 dp 式子，设 $dp_i$ 表示在前 $i$ 个基站中选，使得 $i$ 号基站接收到信号

$$dp_i = \min_{j < i}\\{ dp_j + \frac{x_i - x_j}{2\sqrt{r_j}}\\} + v_i$$

换一个角度，用 $j$ 来更新 $i$，则

$$dp_i - v_i = \frac{1}{2\sqrt{r_j}}x_i + dp_j - \frac{x_j}{2\sqrt{r_j}}$$

于是这个式子变为横坐标为 $x_i$，纵坐标为 $dp_i-v_i$ 的一次函数，每次要求的是横坐标为 $x_i$ 的最小的纵坐标，于是就可以用李超线段树解决。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define INF 1e18
#define M 1e12

using namespace std;

const int N = 1e7 + 10;

class LICHAO_SGT {
	protected :
		int cnt, tot = 1, root = 1;
		db b[N], slope[N];
		int ls[N], rs[N], mvp[N];
		db calc(db x, int k) {
			if (!k) return INF;
			return b[k] + x * slope[k];
		} bool cmp2(ll k, int x, int y) {
			db xx = calc(k, x), yy = calc(k, y);
			if (xx < yy || (xx == yy && x < y)) return true;
			return false;
		} void upd(int &u, ll l, ll r, int k) {
			if (!u) u = ++ tot;
			ll mid = l + r >> 1;
			if (mvp[u] == k) return;
			if (cmp2(mid, k, mvp[u])) swap(mvp[u], k);
			if (cmp2(l, mvp[u], k) && cmp2(r, mvp[u], k)) return;
			if (cmp2(l, k, mvp[u])) upd(ls[u], l, mid, k);
			else upd(rs[u], mid + 1, r, k);
		} int query(int u, ll l, ll r, int x) {
			if (!u) return 0;
			if (l == r) return mvp[u];
			ll mid = l + r >> 1;
			int k;
			if (x <= mid) k = query(ls[u], l, mid, x);
			else k = query(rs[u], mid + 1, r, x);
			return cmp2(x, mvp[u], k) ? mvp[u] : k;
		}
	public :
		db qry(db x) {
			return calc(x, query(1, 1, M, x));
		} void insert(db d, db s) {
			slope[++ cnt] = d, b[cnt] = s;
			upd(root, 1, M, cnt);
		}
} T;

int main() {
	int n;
	ll m;
	scanf("%d%lld", &n, &m);
	vector<ll> x(n + 1);
	vector<int> r(n + 1), v(n + 1);
	vector<db> dp(n + 1);
	for (int i = 1; i <= n; i ++ ) scanf("%lld%d%d", &x[i], &r[i], &v[i]);
	dp[1] = v[1];
	T.insert(1.0 / (2 * sqrt((db)r[1])), dp[1] - x[1] * 1.0 / (2 * sqrt((db)r[1])));
	for (int i = 2; i <= n; i ++ ) {
		dp[i] = T.qry(x[i]) + v[i];
		T.insert(1.0 / (2 * sqrt((db)r[i])), dp[i] - x[i] * 1.0 / (2 * sqrt((db)r[i])));
	}
	db ans = INF;
	for (int i = 1; i <= n; i ++ )
		if (x[i] + r[i] >= m)
			ans = min(ans, dp[i]);
	printf("%.3lf", ans);
	return 0;
}
```

---

## 作者：BINYU (赞：0)

## 题意

给定一条直线上 $n$ 个基站及其坐标 $x$ 和发送半径 $r$ 与使用的代价 $v$，初始时一号点有信息，要传到坐标 $m$，每次传递可以选择一个比上一个基站坐标更大的基站来传递，基站之间的传递信息方式如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pkbibuno.png)

假设 $A$ 点为上一个基站所在位置，$C$ 点为下一个基站的所在位置，我们以 $A$ 的发送半径 $r_A$ 为半径做圆，与地平线相切与 $A$，再自选一个 $C$ 的接受半径 $r'_ C$ 以同样的方式做圆，但要保证两圆相切，代价为 $\sqrt {r'_ C} + v_C$，特别的，一个基站 $i$ 能传到 $m$ 只需要满足 $x_i + r_i \ge m$，求将信息传递到 $m$ 的最小代价。

## 思路

发现选定上一个基站和下一个基站所在的位置后，下一个基站的代价是固定的，我们先求出这个代价：

还是上面那张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pkbibuno.png)

可以发现，$AC$、$|AB-CD|$ 和 $BE+DE$ 形成勾股关系，我们把这些线段的长度带入到等量关系中，可以得到：

$$(x_C - x_A)^2 + (r_A - r'_ C)^2 = (r_A + r'_ C)^2$$

化简，得：

$$(x_C - x_A)^2 = 4r_A\times r'_ C$$
则上一个选基站 $A$ 时，选基站 $C$ 的代价为 $\frac{2(x_C - x_A)}{\sqrt{r_A}}+v_C$。

据此，我们可以列出 DP 方程：

$$dp_i = \min\limits_{1\le j < i}{\{dp_j + \frac{2(x_i - x_j)}{\sqrt{r_j}}+v_i\}}$$

时间复杂度 $O(n^2)$，空间复杂度 $O(n)$，会 TLE。

考虑优化

先把 $\min$ 拆掉方便我们观察，得：

$$dp_i = dp_j + \frac{2(x_i - x_j)}{\sqrt{r_j}}+v_i$$

拆括号，得：

$$dp_i = dp_j +\frac{ 2x_i}{\sqrt{r_j}} - \frac{2x_j}{\sqrt{r_j}} + v_i$$

可以发现，这个式子满足斜率优化的条件，但是作为新加入点的横坐标的 $\sqrt{r_j}$ 并不满足单调不减，无法直接使用二分或单调队列来实现，需要写一个李超树。

接着按李超树的需求去移项，得：

$$dp_i - v_i = \frac{2x_i}{\sqrt{r_j}} + dp_j-\frac{2x_j}{\sqrt{r_j}}$$

所以每次查询已有直线在 $x_i$ 时的最小值，在李超树中加入一条斜率为 $\frac{2}{\sqrt{r_i}}$，截距为 $dp_i-\frac{2x_i}{\sqrt{r_i}}$ 的直线就行了。

DP 的初始值自然是 $dp_1 = v_1$。

还有最后一个细节，如果每次插入线段时直接往 $1$ 至 $\max\{x\}$ 中插入会爆空间，我们可以离散化，对于本题，因为保证了输入的 $x$ 单调递增，我们可以直接用下标来表示离散化后的值。

总时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$，可过。

---

## 作者：Skicyer (赞：0)

# [题意](https://www.luogu.com.cn/problem/P2497)
很简单，自己看。
# 暴力
我们考虑暴力怎么打？先推式子。

由于我们知道发射的 $r_1$ 是固定的，所以可以推一下接收的 $r_2$。

因为我们的价值要最小，所以相切时最省。从而得到以下式子。

$$(x_i-x_j)^2+(r_{j,2}-r_{i,1})^2=(r_{j,2}+r_{i,1})^2$$

移项

$$(x_i-x_j)^2=4r_{j,2}r_{i,1}$$

那么

$$r_{j,2}=\frac{(x_i-x_j)^2}{4r_{i,1}}$$

由于 $val=\sqrt{r_{j,2}}$，所以 

$$val=\sqrt{\frac{(x_i-x_j)^2}{4r_{i,1}}}=\frac{x_j-x_i}{2\sqrt{r_{i,1}}}$$

那么就可以暴力的打了！！
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=5e5+5;
double m,dp[maxn],ans=1e9,r[maxn],x[maxn],v[maxn];
int n;
signed main() {
	scanf("%d%lf",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lf%lf%lf",&x[i],&r[i],&v[i]);
		dp[i]=1000000000;
	}
	dp[1]=0;
	if(r[1]+x[1]>=m) ans=v[1];
	else ans=1e9;
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++){
			dp[i]=min(dp[i],(dp[j]+(x[i]-x[j])*sqrt(r[j])/(2*r[j])+v[j]));
		}
		if(r[i]+x[i]>=m) ans=min(ans,dp[i]+v[i]);
	}
	printf("%0.3lf",ans);
	return 0;
}
```
$10$ 分入手。~~好少~~
# 优化
暴力的求解看上去非常对，所以考虑优化。

我们观察到柿子可以变一下。

$$dp_i=\min_{j=1}^{i-1}(x_i\times\frac{\sqrt{r_j}}{2r_j}+dp_j+v_j-x_j\times\frac{\sqrt{r_j}}{2r_j})$$

显然可以用李超做一下。那么就可以了。
## 离散
但是，我们观察到 $x\le1\times10^{12}$ 且 $x$ 为整数。

离散化就可以解决我们的问题啦。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ls rt*2
#define rs rt*2+1
#define mid (l+r)/2
const int maxn=5e5+5;
double m,dp[maxn],ans=1e9,r[maxn],v[maxn];
int n,xx[maxn],tot,x[maxn];
struct node{
	double k,b;
	node(){}
	node(double _k,double _b){
		k=_k;
		b=_b;
	}
}c[maxn];
int s[maxn<<2];
double cnt(int l,int x){
	if(l==0) return 1e9;
	return c[l].k*xx[x]+c[l].b;
}
void modify(int rt,int l,int r,int x){
	if(l==r){
		if(cnt(s[rt],l)>cnt(x,l)){
			s[rt]=x;
		}
		return ;
	}
	if(cnt(s[rt],mid)>cnt(x,mid)){
		swap(s[rt],x);
	}
	if(cnt(s[rt],l)>cnt(x,l)) modify(ls,l,mid,x);
	else modify(rs,mid+1,r,x);
}
double query(int rt,int l,int r,int x){
	if(l==r) return cnt(s[rt],x);
	double res=cnt(s[rt],x);
	if(x<=mid) res=min(res,query(ls,l,mid,x));
	else res=min(res,query(rs,mid+1,r,x));
	return res;
}
signed main() {
	scanf("%lld%lf",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld%lf%lf",&x[i],&r[i],&v[i]);
		xx[i]=x[i];
		dp[i]=1000000000;
	}
	sort(xx+1,xx+1+n);
	int len=unique(xx+1,xx+n+1)-xx-1;
	for(int i=1;i<=n;i++){
		x[i]=lower_bound(xx+1,xx+len+1,x[i])-xx;
	}
	dp[1]=0;
	if(r[1]+x[1]>=m) ans=v[1];
	else ans=1e9;
	c[++tot]=node(sqrt(r[1])/(2*r[1]),dp[1]+v[1]-1.0*xx[x[1]]*(sqrt(r[1])/(2*r[1])));
	modify(1,1,len,tot);
	for(int i=2;i<=n;i++){
		dp[i]=query(1,1,len,x[i]);
		c[++tot]=node(sqrt(r[i])/(2*r[i]),dp[i]+v[i]-1.0*xx[x[i]]*(sqrt(r[i])/(2*r[i])));
		modify(1,1,len,tot);
		if(xx[x[i]]+r[i]>=m) {
			ans=min(ans,dp[i]+v[i]);
		}
	}
	printf("%0.3lf",ans);
	return 0;
}
```



---

## 作者：聊机 (赞：0)

我此刻的心情无法用语言描述。

本来是一道斜率优化板题，然而我调了一个白天才调出来。

我真的好舒畅啊。



------------
~~废话到此结束~~

此篇题解仅讲解普通的维护斜率优化DP的方式（本篇应该是为数不多使用vector的）。

如果对斜率优化DP很不熟悉，可以看下这篇更基础的[博客](https://www.luogu.com.cn/blog/liaoji/xie-shuai-you-hua-dp)

斜率优化DP的特点:

$$F_i=min_{1\le j<i} (F_j\times...+...)$$

对于普通的取前几个的min的DP，我们可以直接用单调队列进行优化，然而当这个式子复杂化，就不好直接取了，于是便有了斜率优化，其实这真的是一种很好用的优化方式。

首先分析题目，发射范围和接收范围都是和地面相切的圆，每选择一个中转站，都会多花费$sqrt(r2_i)+v_i$的代价，我们首先需要找到一个求$r2_i$的方式。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gcdkcv6w.png)

由此我们得到$sqrt(r2_i)=(x_i-x_j)/2sqrt(r1_j)$

那么我们可以开始推DP式子了($F_i$表示用基站i传输的最小花费）：

$$F_i=min_{1\le j<i}(F_j+(x_i-x_j)/2sqrt(r1_j)+v_i)$$

把min去掉，整理式子得到：

$$x_j-2sqrt(r1_j)F_j-x_i=(v_i-F_i)2sqrt(r1_j)$$

我们可以吧这个式子看成以$2sqrt(r1_j)$为横坐标，$x_j-2sqrt(r1_j)F_j-x_i$为纵坐标的直线。

注意：我一开始把与$2sqrt(r1_j)$有关的式子全部合并了，把$F_j$也放到了斜率里（这个错误让我调了很久），这是万万不可的，与$i$有关的项里一定不能出现$j$ !

这个式子与我所做过的题目还是有所不同的，之前的$F_i$都在截距里，而这个式子里$F_i$在斜率里，不过都一样。对于每一个$i$只有当斜率最大时，$F_i$才最小。

于是我们采用常规思路：维护凸包。

对于此题我们发现，下凸的点一定不是最优的（画个图就明白了）。而对于上凸包，假设最优解点为$j$那么$j$必定是**第一个到它右侧点斜率小于这个点到原点斜率的点**。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/i7jzzkbr.png)

对于不同的$i$这些点之间的相对位置相同，而与原点的相对位置不同，所以我们只需要维护一个相对位置上斜率单调递减的上凸包。

这时我们发现了另一个问题，题目中给的$r1$并不是单调的，也就是说我们不能直接用单调栈来维护凸包。因为$r1$是1...n的一种排列，所以我们可以开一个数组存放，然后用set维护可用的下标，可以做到稳定$O(nlogn)$的复杂度。

然而我觉得这样写好麻烦，所以便用了vector，vector的插入和删除可以看做介于根号至log之间的复杂度（当然可以造数据卡），O2下跑得更快，于是我们用暴力A掉了此题并获得了最优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double lb;//我一开始用的long double，其实不用 
inline ll qr() {//快读 
	ll k=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
	while(isdigit(ch)){k=(k<<1)+(k<<3)+(ch^48);ch=getchar();}
	return k;
}
const int N=5e5+2;
int n,v[N];
ll s,x[N],r1[N];
struct node{//存放每个点 
	lb x,y; 
	bool operator < (const node &nx)const{
		return x<nx.x;
	}
};
vector<node>p;
lb ans=(lb)LONG_LONG_MAX;
int main() {
	n=qr(),s=qr();
	for(int i=1;i<=n;i++) 
		x[i]=qr(),r1[i]=qr(),v[i]=qr();
	if(r1[1]>=s-x[1]) {printf("%.3f",1.0*v[1]);return 0;}//如果从基站能直接传到家里，特判一下 
	p.push_back((node){2.0*(lb)sqrt(r1[1]),1.0*x[1]-2.0*(lb)sqrt(r1[1])*v[1]});
	lb m1,m2,f,xx,yy;int it;
	for(int i=2,l,r,mid;i<=n;i++) {
		l=1,r=(int)p.size()-1;
		while(l<=r) {//二分查找最优解（题解中有解析） 
			mid=(l+r)>>1;
			m1=(p[mid].y-p[mid-1].y)/(p[mid].x-p[mid-1].x);
			m2=(p[mid].y-x[i])/p[mid].x;//-x[i]在这里 
			if(m1>m2) l=mid+1;
			else r=mid-1;
		}  
		f=(1.0*x[i]-p[r].y)/p[r].x+v[i];
		xx=2.0*sqrt(r1[i]),yy=1.0*x[i]-xx*f;//这里的纵坐标没有减式子中的x[i],因为存的是点之间的相对位置 
		if(r1[i]>=s-x[i]) ans=min(ans,f);//更新答案 
		it=upper_bound(p.begin(),p.end(),(node){xx,0})-p.begin();
		if(it&&it<(int)p.size()) {//如果这个点本身就是个下凸点，就不用插入了 
			m1=(yy-p[it-1].y)/(xx-p[it-1].x);
			m2=(p[it].y-yy)/(p[it].x-xx);
			if(m2>m1) continue;
		}
		while(--it>0) {//维护凸包性质 
			m1=(p[it].y-p[it-1].y)/(p[it].x-p[it-1].x);
			m2=(yy-p[it].y)/(xx-p[it].x);
			if(m2>m1) p.erase(p.begin()+it);
			else break;
		}
		++it;
		while(it<(int)p.size()-1) {
			m1=(p[it+1].y-p[it].y)/(p[it+1].x-p[it].x);
			m2=(p[it].y-yy)/(p[it].x-xx);
			if(m1>m2) p.erase(p.begin()+it);
			else break;
		}
		p.insert(p.begin()+it,(node){xx,yy});
	}
	printf("%.3f",ans);
	return 0;
}

```
总之是一道很不错的斜率优化DP题，~~数据有点水~~。


---

## 作者：tylon2006 (赞：0)

比较奇怪的 k 单调 x 不单调的斜率优化。

sb了，因为斜率写成 $x/y$ 调了半天。。。

而且这题别想着画图，$x,y$ 差距太大了。。。

## solution
首先推个dp式。

显然有 $dp[i]=\min(dp[j])+\dfrac{x_i-x_j}{2\sqrt{r_j}}+v[i]$

化为 $-x_i\times\dfrac{1}{2\sqrt{r_j}}+(dp[i]-v[i])=dp[j]-\dfrac{x_j}{2\sqrt{r_j}}$

那么 $k=x_i$，$x=-\dfrac{1}{2\sqrt{r_j}}$，$b=dp[i]-v[i]$，$y=dp[j]-\dfrac{x_j}{2\sqrt{r_j}}$

我们的目标是使 $b$ 最小，那么维护下凸壳即可。

本题的 $k$ 是递增的，所以可以直接单调出队头。这里写的是 $k$ 随意的做法。使用无旋 treap 实现，写起来很舒服。

根据下凸性质有 $x$ 和 $slope(j_1,j_2)$ 同时递增，那么我们可以直接通过凸包上相邻两点斜率 $split$ 来找到最优决策点。注意需要维护一个点与左右的斜率，要多维护一个平衡树中最大最小位置实现连接。（虽然二分也能过就是了）

关于如何插入点自己手摸一下吧，个人感觉对理解很有帮助。

同样的，也可以通过李超线段树与 CDQ 分治解决。个人感觉李超线段树比较好写，CDQ 比较强大但受制于离线。

## code
注意凸包的左/右端点的右/左斜率要设极小/大值。

精度要求不高，感动。
```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const double eps=1e-7;
double dp[500010];
double X[500010];
double Y[500010];
double lk[500010];
double rk[500010];
int id[500010];
int mn[500010];
int mx[500010];
int siz[500010];
int ls[500010];
int rs[500010];
int w[500010];
int R[500010];
int b[500010];
ll a[500010];
int n,cnt,rt;
double ans=1e16;
ll m;
int newnode(double x,double y,int i){
	cnt++;
	X[cnt]=x;
	Y[cnt]=y;
	id[cnt]=i;
	rk[cnt]=1e16;
	mn[cnt]=mx[cnt]=cnt;
	siz[cnt]=1;
	return cnt;
}
void up(int x){
	siz[x]=siz[ls[x]]+siz[rs[x]]+1;
	mn[x]=ls[x]?mn[ls[x]]:x;
	mx[x]=rs[x]?mx[rs[x]]:x; 
} 
int merge(int x,int y){
	if(x==0||y==0) return x|y;
	if(w[x]<w[y]){
		rs[x]=merge(rs[x],y);
		up(x); return x; 
	}
	else{
		ls[y]=merge(x,ls[y]);
		up(y); return y;
	}
}
void split(int u,int &x,int &y,double v,int tp){
	if(u==0){
		x=y=0;
		return;
	}
	double val=tp?rk[u]:X[u];
	if(val<=v) x=u,split(rs[u],rs[u],y,v,tp);
	else y=u,split(ls[u],x,ls[u],v,tp);
	up(u);
}
int link(int x,int y){
	if(x==0||y==0) return x|y;
	int u=mx[x],v=mn[y];
	rk[u]=lk[v]=(Y[v]-Y[u])/(X[v]-X[u]);
	return merge(x,y);
}
double cx(int i){
	return -0.5/sqrt(R[i]);
}
double cy(int i){
	return dp[i]-a[i]/2.0/sqrt(R[i]);
}
int main(){
	int x,y,z;
	scanf("%d%lld",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%lld%d%d",&a[i],&R[i],&b[i]);
	dp[1]=b[1];
	rt=newnode(cx(1),cy(1),1);
	for(int i=2;i<=n;i++){
		split(rt,x,y,a[i],1);
		int j=y==0?id[mx[x]]:id[mn[y]],k;
		dp[i]=dp[j]+(a[i]-a[j])/2.0/sqrt(R[j])+b[i];
		rt=link(x,y);
		split(rt,x,y,cx(i),0); 
		j=mx[x],k=mn[y];
		if(x&&y&&rk[j]<=(cy(i)-Y[j])/(cx(i)-X[j])){
			rt=link(x,y);
			continue;
		}
		while(siz[x]>1&&lk[j]>=(cy(i)-Y[j])/(cx(i)-X[j])){
			split(x,x,z,X[j]-eps,0);
			z=link(ls[z],rs[z]);
			x=link(x,z);
			j=mx[x];
		}
		while(siz[y]>1&&rk[k]<=(Y[k]-cy(i))/(X[k]-cx(i))){
			split(y,y,z,X[k],0);
			y=link(ls[y],rs[y]);
			y=link(y,z);
			k=mn[y];
		}
		rt=link(x,link(newnode(cx(i),cy(i),i),y)); 
	}
	for(int i=1;i<=n;i++)
	if(a[i]+R[i]>=m) 
	ans=min(ans,dp[i]);
	printf("%.3lf",ans);
}
```

---


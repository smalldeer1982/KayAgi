# [COCI 2018/2019 #2] Sunčanje

## 题目描述

Slavko 做了一个不寻常的梦。在一个晴朗的早上，$N$ 个白色的矩形一个接着一个爬上了 Slavko 家的屋顶，并在屋顶上晒太阳。每个矩形在屋顶都选定了一个位置，使得它的边与屋顶的棱角平行。有些矩形可能会覆盖在其它矩形所在的位置上。每个矩形的长、宽分别为 $A_i,B_i$，其与屋顶左方和下方的棱角的距离分别为 $X_i,Y_i$。

日落后，矩形们从屋顶上下来，并睡了一觉。次日，它们发现，有些矩形变成了黄色，而有些仍为白色。变为黄色的矩形都是完全暴露在阳光下的。

请判断每个矩形是否变为了黄色。

## 说明/提示

#### 样例 1 解释

矩形 $1,3$ 没有完全暴露在阳光下，因而它们没有变为黄色：

![](https://cdn.luogu.com.cn/upload/image_hosting/pzfz7o9i.png?x-oss-process=image/resize,m_lfit,h_320,w_362)

#### 数据规模与约定

对于 $10\%$ 的数据，$N \le 10^4$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$0 \le X_i,Y_i \le 10^9$，$1 \le A_i,B_i \le 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $130$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #2](https://hsin.hr/coci/archive/2018_2019/contest2_tasks.pdf)  _T5 Sunčanje_。**

## 样例 #1

### 输入

```
5
1 1 4 2
6 1 1 1
2 2 2 3
3 4 3 2
4 0 1 2```

### 输出

```
NE
DA
NE
DA
DA```

## 样例 #2

### 输入

```
3
3 3 1 1
2 2 3 3
1 1 5 5```

### 输出

```
NE
NE
DA```

# 题解

## 作者：lzqy_ (赞：18)

考虑更简洁的 $\text{cdq}$ 做法。

约定：第 $i$ 个矩形左下角为 $(xl_i,yl_i)$，右上角为 $(xr_i,yr_i)$，所有坐标都已离散化。

如果 第 $i$ 个矩形可以覆盖第 $j$ 个矩形，那么必须满足：


- $i>j$

- $xl_i\le xr_j,xr_i\ge xl_j$（横向有交点）

- $yl_i\le yr_j,yr_i\ge yl_j$（竖向有交点）

首先将矩形按照出现的顺序降序排列，解决完第一个条件。

考虑满足 $xl_i\le xr_j$。将 $[l,mid]$ 按照 $xl$ 排序，$[mid+1,r]$ 按照 $xr$ 排序，然后将满足 $xl_i\le xr_j$ 条件的矩形存入线段树中（具体存法后文讲），这样在线段树中的矩形都随时满足 $xl_i\le xr_j$。

关键在于如何将矩形存储到线段树中来满足剩下三个条件。

将线段树看做纵坐标的值域，那么存储第 $i$ 个矩形就一定是对区间 $[yl_i,yr_i]$ 进行操作，且操作的值一定和 $xr_i$ 有关。

看到剩下的条件 $xr_i\ge xl_j$，发现 $xr_i$ 越大越好，于是存储矩形到线段树中的操作就很明了了，即 $[yl_i,yr_i]$ 更新最大值 $xr_i$。

设 $f_j$ 表示第 $j$ 个矩形是否被覆盖，线段树区间最大值为 $g_{[l,r]}$，那么就有：

$$f_j=f_j|[g_{[yl_j,yr_j]}\ge xl_j]$$

所以执行一遍 $\text{cdq}$ 就全部搞定了。

**关于线段树清空**

在多设一个区间是否清空的懒标记，每次懒标记下传的时候，先下穿清空的懒标记，再下传正常的懒标记。

**代码：**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=200010;
const int N=(maxn<<2);
inline int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c^48);
	return x;
}
struct node{
	int id,xl,yl,xr,yr;
}a[maxn];
int data[N],lz[N],LZ[N];
//data为区间最值,lz为正常懒标记,LZ为清空懒标记
int X[N],Y[N];
int n,m;
bool f[maxn];
bool cmp1(node a,node b){
	return a.xl<b.xl;
}
bool cmp2(node a,node b){
	return a.xr<b.xr;
}
bool cmp3(node a,node b){
	return a.id<b.id;
}
bool cmp4(node a,node b){
	return a.id>b.id;
}
void pushdown(int i){
	if(~LZ[i]){
	//先下传清空懒标记(可以思考下传递顺序的问题)
		lz[i<<1]=lz[i<<1|1]=0;
		data[i<<1]=data[i<<1|1]=0;
		LZ[i<<1]=LZ[i<<1|1]=0;
		LZ[i]=-1;
	} 
	lz[i<<1]=max(lz[i<<1],lz[i]);
	lz[i<<1|1]=max(lz[i<<1|1],lz[i]);
	data[i<<1]=max(data[i<<1],lz[i]);
	data[i<<1|1]=max(data[i<<1|1],lz[i]);
	lz[i]=0;
}
void add(int i,int l,int r,int L,int R,int x){
	if(l>R||r<L) return ;
	if(l>=L&&r<=R){
		data[i]=max(data[i],x);
		lz[i]=max(lz[i],x);
		return ;
	}
	pushdown(i);
	int mid=l+r>>1;
	add(i<<1,l,mid,L,R,x);
	add(i<<1|1,mid+1,r,L,R,x);
	data[i]=max(data[i<<1],data[i<<1|1]);
}
int Query(int i,int l,int r,int L,int R){
	if(l>R||r<L) return 0;
	if(l>=L&&r<=R) return data[i];
	pushdown(i);
	int mid=l+r>>1;
	return max(Query(i<<1,l,mid,L,R),Query(i<<1|1,mid+1,r,L,R));
}
void cdq(int l,int r){
	if(r-l<1) return ;
	int mid=l+r>>1,ii=l,x;
	cdq(l,mid),cdq(mid+1,r);
	sort(a+l,a+1+mid,cmp1);
	sort(a+mid+1,a+r+1,cmp2);
	//注意[l,mid][mid+1,r]排序方法不同
	for(int j=mid+1;j<=r;j++){//cdq常规操作
		while(ii<=mid&&a[ii].xl<=a[j].xr) 
			add(1,1,m,a[ii].yl,a[ii].yr,a[ii].xr),ii++;
		f[a[j].id]|=(Query(1,1,m,a[j].yl,a[j].yr)>=a[j].xl);
		//更新fj
	}
	data[1]=lz[1]=LZ[1]=0,pushdown(1);
	//将整个区间打上清空懒标记
	//不要忘记下传一层 
}
map<int,int>Hx,Hy;
int main(){
	n=read(),memset(LZ,-1,sizeof(LZ));
	int x,y,u,v,cntx=0,cnty=0,Cntx=0,Cnty=0;
	for(int i=1;i<=n;i++){
		a[i].id=i,x=read()+1,y=read()+1,u=read(),v=read();
		a[i].xl=x,a[i].yl=y,a[i].xr=x+u-1,a[i].yr=y+v-1;
		X[++cntx]=a[i].xl,X[++cntx]=a[i].xr;
		Y[++cnty]=a[i].yl,Y[++cnty]=a[i].yr;
	}
	sort(X+1,X+1+cntx),sort(Y+1,Y+1+cnty);
	Hx[X[1]]=++Cntx,Hy[Y[1]]=++Cnty;
	for(int i=2;i<=cntx;i++){
		if(X[i]!=X[i-1]) Hx[X[i]]=++Cntx;
		if(Y[i]!=Y[i-1]) Hy[Y[i]]=++Cnty;
	}
	for(int i=1;i<=n;i++){
	//离散化(其实xl,xr是不用离散化的)
		a[i].xl=Hx[a[i].xl],a[i].xr=Hx[a[i].xr];
		a[i].yl=Hy[a[i].yl],a[i].yr=Hy[a[i].yr];
	} 
	sort(a+1,a+1+n,cmp4),m=Cnty,cdq(1,n);
	for(int i=1;i<=n;i++) 
		printf("%s\n",f[i]?"NE":"DA");
	return 0;
}
```

祝 $\text{AC}$。

---

## 作者：PPL_ (赞：7)

# 前言

好久没写得这么爽了~



# 题目

[洛谷](https://www.luogu.com.cn/problem/P7312)

[LOJ](https://loj.ac/p/3128)

# 讲解

在我看来，这是一道码农题。

对于每个矩形，我们考虑计算出**顺序在它之后(即可能将其覆盖)**且**没有与它相交**的矩形个数，我们将其取名为**合法矩形**，然后与顺序在它之后的矩形个数比较即可得出答案。

考虑容斥。

对于每个矩形，我们可以将其四条边无限延长，然后整个平面就被分为了 $9$ 个格子。对于上下左右四个方向**各三个格子**统计出有多少个合法矩形，记录下来。

显然四个角的合法矩形被计算了两次，减掉即可。这就是个简单的偏序问题了，使用 $\tt cdq$ 即可求解。

小优化：在 $\tt cdq$ 过程中，显然可以使用归并排序优化时间，当然不优化也行，这道题时限很宽。

注意 $\tt cdq$ 排序时的顺序，求解时的边界问题以及树状数组的清空(因为我都挂过qwq)。

$\tt cdq$ 套树状数组，时间复杂度是 $O(n\log^2n)$。

# 代码

我的代码实现过于冗长，主要是因为四个角打了四个 $\tt cdq$。 /jk

而且我为了方便，将整个数组翻转了，看代码时不要误解了。

```cpp
//12252024832524
#include <cstdio>
#include <cstring>
#include <algorithm>
#define TT template<typename T>
using namespace std; 

typedef long long LL;
const int MAXN = 200005;
int n,lenx,leny;
int lshx[MAXN],lshy[MAXN];

LL Read()
{
	LL x = 0,f = 1;char c = getchar();
	while(c > '9' || c < '0'){if(c == '-')f = -1;c = getchar();}
	while(c >= '0' && c <= '9'){x = (x*10) + (c^48);c = getchar();}
	return x * f;
}
TT void Put1(T x)
{
	if(x > 9) Put1(x/10);
	putchar(x%10^48);
}
TT void Put(T x,char c = -1)
{
	if(x < 0) putchar('-'),x = -x;
	Put1(x); if(c >= 0) putchar(c);
}
TT T Max(T x,T y){return x > y ? x : y;}
TT T Min(T x,T y){return x < y ? x : y;}
TT T Abs(T x){return x < 0 ? -x : x;}

int b[MAXN];
int lowbit(int x){return (x & -x);}
void Add(int x,int M,int val){for(int i = x;i <= M;i += lowbit(i)) b[i] += val;}
int Sum(int x){int ret = 0;for(int i = x;i >= 1;i -= lowbit(i)) ret += b[i]; return ret;}
void clr(int x){for(int i = 1;i <= x;++ i) b[i] = 0;}
int cnt[MAXN];
struct Rectangle 
{
	int x,y,x2,y2;//lower left,upper right,ID
}c[MAXN];
struct node
{
	int x,y,f,ID,ori;//f=1:calculate,f=0:update
	node(){}
	node(int x1,int y1,int f1,int ID1,int ori1){
		x = x1;
		y = y1;
		f = f1;
		ID = ID1;
		ori = ori1;
	}
}p[MAXN],q[MAXN];
bool cmpID(node A,node B){return A.ID < B.ID;}
bool cmpx(node A,node B){return A.x < B.x;}
bool cmpy(node A,node B){return A.y < B.y;}

void cdq1(int l,int r)//upper left
{
	if(l == r) return;
	int mid = (l+r) >> 1;
	cdq1(l,mid); cdq1(mid+1,r);
	int I = l,J = mid+1,K = l;
	while(I <= mid && J <= r)
		if(p[I].x < p[J].x || (p[I].x == p[J].x && p[I].ori < p[J].ori)) q[K++] = p[I++];//Pay attention to the order when x is equal to another. 
		else q[K++] = p[J++];
	while(I <= mid) q[K++] = p[I++];
	while(J <= r) q[K++] = p[J++];
	for(int i = l;i <= r;++ i) 
	{
		p[i] = q[i];
		if(!p[i].f && p[i].ori <= mid)
			Add(leny-p[i].y+1,leny,1);
		else if(p[i].f && p[i].ori > mid)
			cnt[p[i].ID] -= Sum(leny-p[i].y+1);
	}
	for(int i = l;i <= r;++ i) 
		if(!p[i].f && p[i].ori <= mid)
			Add(leny-p[i].y+1,leny,-1);
}
void cdq2(int l,int r)//lower left
{
	if(l == r) return;
	int mid = (l+r) >> 1;
	cdq2(l,mid); cdq2(mid+1,r);
	int I = l,J = mid+1,K = l;
	while(I <= mid && J <= r)
		if(p[I].x < p[J].x || (p[I].x == p[J].x && p[I].ori < p[J].ori)) q[K++] = p[I++];
		else q[K++] = p[J++];
	while(I <= mid) q[K++] = p[I++];
	while(J <= r) q[K++] = p[J++];
	for(int i = l;i <= r;++ i) 
	{
		p[i] = q[i];
		if(!p[i].f && p[i].ori <= mid)
			Add(p[i].y,leny,1);
		else if(p[i].f && p[i].ori > mid)
			cnt[p[i].ID] -= Sum(p[i].y);
	}
	for(int i = l;i <= r;++ i) 
		if(!p[i].f && p[i].ori <= mid)
			Add(p[i].y,leny,-1);
}
void cdq3(int l,int r)//upper right
{
	if(l == r) return;
	int mid = (l+r) >> 1;
	cdq3(l,mid); cdq3(mid+1,r);
	int I = l,J = mid+1,K = l;
	while(I <= mid && J <= r)
		if(p[I].x < p[J].x || (p[I].x == p[J].x && p[I].ori > p[J].ori)) q[K++] = p[I++];
		else q[K++] = p[J++];
	while(I <= mid) q[K++] = p[I++];
	while(J <= r) q[K++] = p[J++];
	for(int i = r;i >= l;-- i) 
	{
		p[i] = q[i];
		if(!p[i].f && p[i].ori <= mid)
			Add(leny-p[i].y+1,leny,1);
		else if(p[i].f && p[i].ori > mid)
			cnt[p[i].ID] -= Sum(leny-p[i].y+1);
	}
	for(int i = r;i >= l;-- i) 
		if(!p[i].f && p[i].ori <= mid)
			Add(leny-p[i].y+1,leny,-1);
}
void cdq4(int l,int r)//lower right
{
	if(l == r) return;
	int mid = (l+r) >> 1;
	cdq4(l,mid); cdq4(mid+1,r);
	int I = l,J = mid+1,K = l;
	while(I <= mid && J <= r)
		if(p[I].x < p[J].x || (p[I].x == p[J].x && p[I].ori > p[J].ori)) q[K++] = p[I++];
		else q[K++] = p[J++];
	while(I <= mid) q[K++] = p[I++];
	while(J <= r) q[K++] = p[J++];
	for(int i = r;i >= l;-- i) 
	{
		p[i] = q[i];
		if(!p[i].f && p[i].ori <= mid)
			Add(p[i].y,leny,1);
		else if(p[i].f && p[i].ori > mid)
			cnt[p[i].ID] -= Sum(p[i].y);
	}
	for(int i = r;i >= l;-- i) 
		if(!p[i].f && p[i].ori <= mid)
			Add(p[i].y,leny,-1);
}

int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n = Read();
	for(int i = n;i >= 1;-- i) 
	{
		c[i].x = Read(),c[i].y = Read(),c[i].x2 = Read(),c[i].y2 = Read();//reverse order
		c[i].x2 += c[i].x-1;
		c[i].y2 += c[i].y-1;
		lshx[i<<1] = c[i].x; lshx[(i<<1)-1] = c[i].x2;
		lshy[i<<1] = c[i].y; lshy[(i<<1)-1] = c[i].y2;
	}
	//Discretization 
	sort(lshx+1,lshx+(n<<1)+1); sort(lshy+1,lshy+(n<<1)+1);
	lenx = unique(lshx+1,lshx+(n<<1)+1) - lshx - 1; leny = unique(lshy+1,lshy+(n<<1)+1) - lshy - 1;
	for(int i = 1;i <= n;++ i) c[i].x = lower_bound(lshx+1,lshx+lenx+1,c[i].x) - lshx,c[i].x2 = lower_bound(lshx+1,lshx+lenx+1,c[i].x2) - lshx;
	for(int i = 1;i <= n;++ i) c[i].y = lower_bound(lshy+1,lshy+leny+1,c[i].y) - lshy,c[i].y2 = lower_bound(lshy+1,lshy+leny+1,c[i].y2) - lshy;
	//4 directions
	for(int i = 1;i <= n;++ i) cnt[i] += Sum(c[i].x-1),Add(c[i].x2,lenx,1); clr(lenx); //left
	for(int i = 1;i <= n;++ i) cnt[i] += Sum(lenx-c[i].x2),Add(lenx-c[i].x+1,lenx,1); clr(leny); //right
	for(int i = 1;i <= n;++ i) cnt[i] += Sum(c[i].y-1),Add(c[i].y2,leny,1); clr(leny); //down
	for(int i = 1;i <= n;++ i) cnt[i] += Sum(leny-c[i].y2),Add(leny-c[i].y+1,leny,1); clr(leny); //up
	//4 corners 
	for(int i = 1;i <= n;++ i) p[i<<1] = node(c[i].x-1,c[i].y2+1,1,i,i<<1),p[(i<<1)-1] = node(c[i].x2,c[i].y,0,i,(i<<1)-1); cdq1(1,n<<1);
	for(int i = 1;i <= n;++ i) p[i<<1] = node(c[i].x-1,c[i].y-1,1,i,i<<1),p[(i<<1)-1] = node(c[i].x2,c[i].y2,0,i,(i<<1)-1); cdq2(1,n<<1);
	for(int i = 1;i <= n;++ i) p[i<<1] = node(c[i].x2+1,c[i].y2+1,1,i,i<<1),p[(i<<1)-1] = node(c[i].x,c[i].y,0,i,(i<<1)-1); cdq3(1,n<<1);
	for(int i = 1;i <= n;++ i) p[i<<1] = node(c[i].x2+1,c[i].y-1,1,i,i<<1),p[(i<<1)-1] = node(c[i].x,c[i].y2,0,i,(i<<1)-1); cdq4(1,n<<1);
	//There are so many "+1" and "-1". Pay attention to the boundary.
	//print
	for(int i = n;i >= 1;-- i)
	{
		if(cnt[i] != i-1) printf("NE\n");
		else printf("DA\n");
	}
	return 0;
}
//sorry for my poor English
```

---

## 作者：LFCode (赞：6)

### 题意

给定平面上的 $n$ 个矩形，询问每个矩形是否与编号更大的矩形有交。$n\leq 10^5$。

### 解法

上星期校内模拟赛题。用 CDQ 分治来做的话也不难，不过昨天突然想到一种更加无脑的做法。

这个做法没有 CDQ 分治优秀，但是……他比 CDQ 分治要无脑呀……

一个最无脑的做法：从大到小处理每个矩形，做一个矩形加矩形查询状物。

那这显然不大行，考虑优化这个过程。做矩形加是大炮打蚊子，因为我们只需要查询矩形是否有交。

如果已经知道两个矩形横坐标有交，如何判断这两个矩形纵坐标是否有交？这个很简单，用一棵线段树维护即可（当然了用树状数组或者别的什么也行）。

那么我们考虑一下如何处理出横坐标的相交关系。这可以用一种很套路的做法解决。

考虑在线段树上定位一个区间的过程。这个过程中我们会访问到一些上层结点（下称 1 类点）和一些被需要定位的区间包含的结点（下称 2 类点）。

可以发现这样一件事情：两个区间有交，当且仅当在定位这两个区间的过程中，某个结点同时被作为 2 类点访问，或某个结点被作为其中一个区间的 2 类点和另一个区间的 1 类点访问。

有了这个结论问题就简单了许多。我们维护一个形如线段树的分治结构，按照编号从大到小在这个结构上做定位横坐标区间的过程，并在访问过的 1 类、2 类点上打标记（下称“覆盖信息”）。

所有矩形都定位完成后，我们 DFS 这个结构。此时每个结点是独立的，我们单独考虑其中某个结点。

开两棵线段树，分别维护当前结点记录的 1 类访问、2 类访问覆盖的纵坐标区间。对于一个覆盖信息，我们查询该信息与先前处理过的 2 类访问是否有交。如果当前覆盖信息属于 2 类访问，那么我们还要查询一下其与先前处理过的 1 类访问是否有交。查询完毕后，我们在当前信息对应的线段树上做修改。

时间复杂度是两枚 $\log$，空间复杂度一枚 $\log$。感觉 CDQ 分治的空间复杂度应该是线性的，这个做法的空间瓶颈在于覆盖信息的插入。卡一卡的话空间说不定还能优化，不过意义不大所以我没想。时间上常数比 CDQ 分治要大，主要是因为对 1 类结点也要进行操作。

### 代码

注意上文中的“2 类点”在代码中是第 0 层。蚂蜂略丑，呜呜

```c++
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int N=200086;
int n,xval,yval,tme,xl[N],xr[N],yl[N],yr[N],lt[N<<2];
bool gg[N],tag[N<<2][2],sum[N<<2][2];
struct asdf{int v,p,k;asdf(){}asdf(int vv,int pp,int kk){v=vv;p=pp;k=kk;}};
struct infor{
	int f,l,r,id;infor(){}
	infor(int fl,int a,int b,int no){f=fl;l=a;r=b;id=no;}
};
asdf tmpx[N],tmpy[N];
vector<infor>t[N<<2];
int read(){
	char ch=getchar();int nn=0,ssss=1;
	while(ch<'0'||ch>'9'){if(ch=='-')ssss*=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){nn=nn*10+(ch-'0');ch=getchar();}
	return nn*ssss;
}
bool upd(int k){if(lt[k]!=tme){lt[k]=tme;tag[k][0]=tag[k][1]=sum[k][0]=sum[k][1]=0;}return true;}
bool pushdown(int k,int l,int r,int mid){
	upd(k<<1);upd(k<<1|1);
	if(tag[k][0]){
		tag[k<<1][0]|=tag[k][0];tag[k<<1|1][0]|=tag[k][0];
		sum[k<<1][0]|=tag[k][0];sum[k<<1|1][0]|=tag[k][0];
	}
	if(tag[k][1]){
		tag[k<<1][1]|=tag[k][1];tag[k<<1|1][1]|=tag[k][1];
		sum[k<<1][1]|=tag[k][1];sum[k<<1|1][1]|=tag[k][1];
	}
	tag[k][0]=tag[k][1]=false;return true;
}
bool change(int k,int l,int r,int x,int y,int flr){
	upd(k);if(l>=x&&r<=y)return tag[k][flr]=sum[k][flr]=true;
	int mid=(l+r)>>1;pushdown(k,l,r,mid);
	if(x<=mid)change(k<<1,l,mid,x,y,flr);
	if(mid<y)change(k<<1|1,mid+1,r,x,y,flr);
	sum[k][0]=sum[k<<1][0]|sum[k<<1|1][0];
	sum[k][1]=sum[k<<1][1]|sum[k<<1|1][1];
	return true;
}
bool ask(int k,int l,int r,int x,int y,int flr){
	upd(k);if(!sum[k][flr])return false;
	if(l>=x&&r<=y)return sum[k][flr]>0;
	int mid=(l+r)>>1;bool ret=false;pushdown(k,l,r,mid);
	if(x<=mid)ret|=ask(k<<1,l,mid,x,y,flr);
	if(mid<y&&ret==false)ret|=ask(k<<1|1,mid+1,r,x,y,flr);
	return ret;
}
bool push(int k,int l,int r,int x,int y,int L,int R,int z){
	if(l>=x&&r<=y){t[k].push_back(infor(0,L,R,z));return true;}
	else t[k].push_back(infor(1,L,R,z));
	int mid=(l+r)>>1;
	if(x<=mid)push(k<<1,l,mid,x,y,L,R,z);
	if(mid<y)push(k<<1|1,mid+1,r,x,y,L,R,z);
	return true;
}
bool dfs(int k,int l,int r){
	tme++;
	for(vector<infor>::iterator it=t[k].begin();it!=t[k].end();it++){
		gg[it->id]|=ask(1,1,yval,it->l,it->r,0);
		if(!it->f)gg[it->id]|=ask(1,1,yval,it->l,it->r,1);
		change(1,1,yval,it->l,it->r,it->f);
	}
	if(l==r)return true;int mid=(l+r)>>1;
	return dfs(k<<1,l,mid)&&dfs(k<<1|1,mid+1,r);
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		int xa=read();int ya=read();
		int xb=xa+read();int yb=ya+read();
		tmpx[i*2-1]=asdf(xa,i,1);tmpx[i*2]=asdf(xb,i,-1);
		tmpy[i*2-1]=asdf(ya,i,1);tmpy[i*2]=asdf(yb,i,-1);
	}
	sort(tmpx+1,tmpx+2*n+1,[&](asdf a,asdf b){return a.v==b.v?a.k<b.k:a.v<b.v;});
	sort(tmpy+1,tmpy+2*n+1,[&](asdf a,asdf b){return a.v==b.v?a.k<b.k:a.v<b.v;});
	for(int i=1;i<=2*n;i++){
		xval+=(tmpx[i].v!=tmpx[i-1].v||tmpx[i].k!=tmpx[i-1].k||i==1);
		if(tmpx[i].k==1)xl[tmpx[i].p]=xval;else xr[tmpx[i].p]=xval;
		yval+=(tmpy[i].v!=tmpy[i-1].v||tmpy[i].k!=tmpy[i-1].k||i==1);
		if(tmpy[i].k==1)yl[tmpy[i].p]=yval;else yr[tmpy[i].p]=yval;
	}
	for(int i=n;i;i--)push(1,1,xval,xl[i],xr[i],yl[i],yr[i],i);
	dfs(1,1,xval);for(int i=1;i<=n;i++)puts(gg[i]?"NE":"DA");
}
```

---

## 作者：operator_ (赞：5)

# P7312 [COCI2018-2019#2] Sunčanje

[题目传送门](https://www.luogu.com.cn/problem/P7312)

## 题解

分类讨论的思想有点像[P4169](https://www.luogu.com.cn/problem/P4169)?

要你对于每一个矩形，求是否存在**编号比它大，与它有交**的矩形。

直接做需要用一个比较神仙的线段树用法，所以我们可以容斥：我们求出编号比它大，与它**无**交的矩形数量，最后与所有可能覆盖它的矩形共 $n-i$ 个作比较。

更具体的，求出在它上下左右的矩形数量减去四个角的矩形数量即可。上下左右的矩形数量是经典二维偏序，四个角的矩形数量是经典三维偏序，直接套板子就好。

一个小技巧：只考虑一边和一个角的贡献，打包成一个函数（即下文的 ```solve()``` 函数），每次直接转坐标轴就可以快速求解。

时间复杂度 $O(n\log^2n)$ ，可以尝试归并，但是我懒。

代码很好写：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int rd() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
const int ML=200005;
int n,ans[100005];
struct QWQ {int id,xl,xr,yl,yr;} a[100005],b[100005];
bool cmp1(QWQ a1,QWQ a2) {return a1.id>a2.id;}
bool cmp2(QWQ a1,QWQ a2) {return a1.xr<a2.xr;}
bool cmp3(QWQ a1,QWQ a2) {return a1.xl<a2.xl;}
int bx[200005],by[200005],cntx,cnty,qx,qy;
struct Binary_Indexed_Tree {
	int t[ML+5];
	inline int lb(int x) {return x&-x;}
	inline int sum(int x) {int s=0;for(int i=x;i;i-=lb(i)) s+=t[i];return s;}
	inline void add(int x,int k) {for(int i=x;i<=ML;i+=lb(i)) t[i]+=k;}
} t;
void cdq(int l,int r) {
	if(l>=r) return;
	int mid=(l+r)>>1;
	cdq(l,mid);cdq(mid+1,r);
	sort(b+l,b+mid+1,cmp2);
	sort(b+mid+1,b+r+1,cmp3);
	int i=l;
	for(int j=mid+1;j<=r;j++) {
		while(i<=mid&&b[i].xr<=b[j].xl) t.add(b[i].yr,1),i++;
		ans[b[j].id]+=t.sum(b[j].yl);
	}
	for(int j=l;j<i;j++) t.add(b[j].yr,-1);
}
void solve() {
	for(int i=1;i<=n;i++)
		ans[b[i].id=a[i].id]-=t.sum(b[i].yl),t.add(b[i].yr,1);
	for(int i=1;i<=n;i++) t.add(b[i].yr,-1);
	cdq(1,n);
}
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		int xi=rd()+1,yi=rd()+1,ai=rd(),bi=rd();
		a[i].id=i,ans[i]=n-i;
		bx[++cntx]=a[i].xl=xi,bx[++cntx]=a[i].xr=xi+ai,
		by[++cnty]=a[i].yl=yi,by[++cnty]=a[i].yr=yi+bi;
	}
	sort(bx+1,bx+cntx+1);qx=unique(bx+1,bx+cntx+1)-bx-1;
	sort(by+1,by+cnty+1);qy=unique(by+1,by+cnty+1)-by-1;
	for(int i=1;i<=n;i++)
		a[i].xl=lower_bound(bx+1,bx+qx+1,a[i].xl)-bx,
		a[i].xr=lower_bound(bx+1,bx+qx+1,a[i].xr)-bx,
		a[i].yl=lower_bound(by+1,by+qy+1,a[i].yl)-by,
		a[i].yr=lower_bound(by+1,by+qy+1,a[i].yr)-by;
	sort(a+1,a+n+1,cmp1);
	for(int i=1;i<=n;i++)
		b[i].xl=a[i].xl,b[i].xr=a[i].xr,b[i].yl=a[i].yl,b[i].yr=a[i].yr;
	solve();
	for(int i=1;i<=n;i++)
		b[i].xl=a[i].yl,b[i].xr=a[i].yr,b[i].yl=ML-a[i].xr,b[i].yr=ML-a[i].xl;
	solve();
	for(int i=1;i<=n;i++)
		b[i].xl=ML-a[i].xr,b[i].xr=ML-a[i].xl,b[i].yl=ML-a[i].yr,b[i].yr=ML-a[i].yl;
	solve();
	for(int i=1;i<=n;i++)
		b[i].xl=ML-a[i].yr,b[i].xr=ML-a[i].yl,b[i].yl=a[i].xl,b[i].yr=a[i].xr;
	solve();
	for(int i=1;i<=n;i++)
		if(!ans[i]) puts("DA");
		else puts("NE");
	return 0;
}

```

---

## 作者：suibian1234 (赞：3)

这题要我们求矩阵与其编号更大的矩阵是否有交点。

考虑按照时间顺序倒序处理，利用树套树维护矩形赋值，矩形查询。

外层是线段树，其节点 $l,r$ 范围表示横坐标；内层是平衡树。

线段树每个节点开 $2$ 棵平衡树，$T_1$ 维护“横坐标与该区间有交集的矩形”纵坐标取值范围的并集，$T_2$ 维护“横坐标能覆盖该区间的矩形“纵坐标取值范围的并集。查询或修改时，若操作的区间能覆盖当前节点，则查 $T_1$；只要它们有交集就要查 $T_2$（$T_2$ 相当于标记永久化）。

时间，空间复杂度均为 $O(n\times(\log{n})^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005,inf=2147483647;
struct o2{
	int l,r;
	bool operator<(const o2 &a)const{return l<a.l;}
}ls;
#define TREE set<o2>
TREE T1[N*8],T2[N*8];
int n,dx,cp[N],L[N*8],R[N*8],ls1[N*2],ls2[N*2];
struct op{
	int x[4];
}d[N];
void js(int x,int l,int r){
	L[x]=l,R[x]=r;
	T1[x].insert({0,0}),T1[x].insert({n*2+1,n*2+1});
	T2[x].insert({0,0}),T2[x].insert({n*2+1,n*2+1});
	if(l==r)return;
	int mid=(l+r)/2;
	js(x*2+1,l,mid),js(x*2+2,mid+1,r);
}
void add(TREE &T,int vl,int vr){
	auto it=T.upper_bound({vl,0}),pd=it;it--;
	ls=*it;
	if(ls2[vl]<=ls2[ls.r]+1)vl=ls.l,vr=max(vr,ls.r),T.erase(it);
	ls=*pd;
	while(ls2[vr]+1>=ls2[ls.l]){
		vr=max(vr,ls.r),it=pd,pd++;
		T.erase(it),ls=*pd;
	}
	T.insert({vl,vr});
}
void xg(int x,int l,int r,int vl,int vr){
	if(l<=L[x]&&R[x]<=r){
		add(T2[x],vl,vr);
		return;
	}
	add(T1[x],vl,vr);
	int mid=(L[x]+R[x])/2;
	if(l<=mid)xg(x*2+1,l,r,vl,vr);
	if(mid<r)xg(x*2+2,l,r,vl,vr);
}
int NTT(TREE &T,int vl,int vr){
	auto it=T.upper_bound({vl,0}),pb=it;
	it--,ls=*it;
	if(ls.r>=vl)return 1;
	if((*pb).l<=vr)return 1;
	return 0;
}
int cx(int x,int l,int r,int vl,int vr){
	int mid=(L[x]+R[x])/2;
	if(NTT(T2[x],vl,vr))return 1;
	if(l<=L[x]&&R[x]<=r)return NTT(T1[x],vl,vr);
	if(l<=mid)if(cx(x*2+1,l,r,vl,vr))return 1;
	if(mid<r)if(cx(x*2+2,l,r,vl,vr))return 1;
	return 0;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=0;j<4;j++)scanf("%d",&d[i].x[j]);
		d[i].x[2]+=d[i].x[0],d[i].x[3]+=d[i].x[1];
		d[i].x[0]++,d[i].x[1]++;
		ls1[i*2-1]=d[i].x[0],ls1[i*2]=d[i].x[2];
		ls2[i*2-1]=d[i].x[1],ls2[i*2]=d[i].x[3];
	}
	sort(ls1+1,ls1+n*2+1),sort(ls2+1,ls2+n*2+1);
	ls2[0]=-1,ls2[n*2+1]=inf,dx=n*2;
	for(int i=1;i<n*2;i++){
		if(ls1[i]==ls1[i+1])ls1[i]=inf,dx--;
	}
	sort(ls1+1,ls1+n*2+1);
	for(int i=1;i<=n;i++){
		d[i].x[0]=lower_bound(ls1+1,ls1+dx+1,d[i].x[0])-ls1;
		d[i].x[2]=lower_bound(ls1+1,ls1+dx+1,d[i].x[2])-ls1;
		d[i].x[1]=lower_bound(ls2+1,ls2+n*2+1,d[i].x[1])-ls2;
		d[i].x[3]=lower_bound(ls2+1,ls2+n*2+1,d[i].x[3])-ls2;
	}
	js(0,1,dx);
    for(int i=n;i>=1;i--){
    	cp[i]=!cx(0,d[i].x[0],d[i].x[2],d[i].x[1],d[i].x[3]);
    	xg(0,d[i].x[0],d[i].x[2],d[i].x[1],d[i].x[3]);
	}
	for(int i=1;i<=n;i++){
		if(cp[i])printf("DA\n");
		else printf("NE\n");
	}
	return 0;
}
```

---

## 作者：spdarkle (赞：2)

我们记矩阵序列为 $A$ ,其中 $A[i]=(x_1,y_1,x_2,y_2)(x_1\le x_2,y1\le y_2)$ ，为了方便，我们将 $A[i]$ 的 $x_1$ 写作 $A[i,x_1]$ ，其余类似

那么矩阵 $i$ 被矩阵 $j$ 覆盖需要满足以下条件

$$
\left\{
\begin{aligned}
i<j\\
\left\{
\begin{aligned}
A[i,x_1]&\le A[j,x_2] \\
A[j,x_1]&\le A[i,x_2] \\
\end{aligned}
\right.\\
\left\{
\begin{aligned}
A[i,y_1]&\le A[j,y_2] \\
A[j,y_1]&\le A[i,y_2] \\
\end{aligned}
\right.
\end{aligned}
\right.
$$

(在这里有一个细节，就是有可能一个矩形的右边和一个矩形的左边在同一直线上(亦或者一个矩形的上边和一个矩形的下边在同一直线上)，但此时没有交点却仍然会被累加进入答案，故为了解决这个问题，可以把右上角整体缩一格，也即右上角的横纵坐标全部-1(这就是部分同志最后几个点过不了的原因))；

考虑如何求解
这个玩意类似于偏序问题，考虑使用 CDQ 分治

若按照时间轴分治，则设分治两区间为 $[l,mid],[mid+1,r]$

此时 $[l,mid]$ 的时间都早于 $[mid+1,r]$ 

此时我们需要考虑后半区间对前半区间的影响，先用常规双指针套路维护限制条件 $A[j,x_1]\le A[i,x_2]$

将区间 $[l,mid]$ 按照 $x_2$ 递增排序，区间 $[mid+1,r]$ 按照 $x_1$ 递增排序，设两个指针分别为 $L,R$

采用双指针扫描，则 $[mid+1,R]$ 的矩形都满足对于 $L$ 来说 $A[L,x_2]\ge A[k,x_1]$ ,考虑判定在 $[mid+1,R]$ 中有无矩形可以覆盖 $L$ 

按照 $CDQ$ 分治的套路我们需要数据结构来维护剩余的几个条件

$$
\left\{
\begin{aligned}
A[i,x_1]&\le A[j,x_2] \\
A[i,y_1]&\le A[j,y_2] \\
A[j,y_1]&\le A[i,y_2] \\
\end{aligned}
\right.
$$

这里由于限制条件就是要求矩形横向有交点，竖向有交点，而对于竖向有交点，可以转化为线段有交问题，考虑使用维护线段的数据结构——线段树

那，我们对区间 $[A[i,y_1],A[i,y_2]]$ 进行修改，只需要我们能够判定在区间 $[A[L,y_1],A[L,y_2]]$ 中有无大于等于 $A[L,x_1]$ 的元素，这启发我们的线段树维护区间最大值，假设我们将区间 $[l',r']$ 的最大值记为 $g[l',r']$ ，记 $f[i]$ 表示第$i$个矩形是否被覆盖

那么就有 $f[A[L,id]]|=A[L,x_1]\le g[A[L,y_1],A[L,y_2]]$

统计完了之后将线段树全部清空为-1即可


最后，我们再来梳理一遍这个过程

1. 离散化坐标
2. 在CDQ分治中
3. 左半区间按照$x_2$排，右半区间按$x_1$排
4. 双指针扫描，使得$A[L,x_2]\ge A[R,x_1]$
5. 在扫描的过程中不断在线段树的区间$[A[R,y_1],A[R,y_2]]$上更新区间最大值
6. 对于$L$查询区间$[A[L,x_1,x_2]]$是否存在大于$A[L,x_1]$的值，存在也就表示$L$被覆盖
7. 清空线段树


时间复杂度是$O(n\log^2n)$,~~线段树常数大得一批，怪不得时间要求4s~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define scanf scanf_s
using namespace std;
#define N 1000050
struct node {
	int id, x1, x2, y1, y2;
}a[N];//矩阵
int b[N], c[N], cnt;//离散化
int f[N], n, m;
struct seg_tree {
	int mx, tag, lazy, l, r;
}t[N << 2];//线段树
#define lc x<<1
#define rc x<<1|1
void build(int l, int r, int x) {
	t[x] = { 0,0,-1,l,r };
	if (l == r)return;
	int mid = l + r >> 1;
	build(l, mid, lc);
	build(mid + 1, r, rc);
}
inline void pushup(int x) {
	t[x].mx = max(t[lc].mx, t[rc].mx);
}
inline void pushdown(seg_tree& a, seg_tree& b, seg_tree& c) {
	if (a.lazy != -1) {
		b.tag = c.tag = 0;
		b.mx = c.mx = 0;
		b.lazy = c.lazy = 0;
		a.lazy = -1;
	}
	b.tag = max(b.tag, a.tag);
	c.tag = max(c.tag, a.tag);
	b.mx = max(b.mx, a.tag);
	c.mx = max(c.mx, a.tag);
	a.tag = 0;
	return;
}
inline void pushdown(int x) {
	pushdown(t[x], t[lc], t[rc]);
}
void update(int x, int l, int r, int k) {
	if (l <= t[x].l && t[x].r <= r) {
		t[x].mx = max(t[x].mx, k);
		t[x].tag = max(t[x].tag, k);
		return;
	}
	pushdown(x);
	int mid = t[x].l + t[x].r >> 1;
	if (l <= mid)update(lc, l, r, k);
	if (mid < r)update(rc, l, r, k);
	pushup(x);
}
int find(int x, int l, int r) {
	if (l <= t[x].l && t[x].r <= r) {
		//		printf("%d %d %d %d %d\n", t[x].lazy, t[x].tag, t[x].l, t[x].r, t[x].mx);
		return t[x].mx;
	}
	int ans = -1, mid = t[x].l + t[x].r >> 1;
	pushdown(x);
	if (l <= mid)ans = max(ans, find(lc, l, r));
	if (mid < r)ans = max(ans, find(rc, l, r));
	pushup(x);
	return ans;
}
#undef lc
#undef rc
void init() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		int A, B, c, d;
		scanf("%d%d%d%d", &A, &B, &c, &d);
		c += A - 1, d += B - 1;
		a[i] = { i,A,c,B,d };
		b[++cnt] = A, b[++cnt] = B, b[++cnt] = c, b[++cnt] = d;
	}
	sort(b + 1, b + cnt + 1);
	cnt = unique(b + 1, b + cnt + 1) - b - 1;
	//	printf("%d\n", cnt);
	for (int i = 1; i <= n; i++) {
		a[i].x1 = lower_bound(b + 1, b + cnt + 1, a[i].x1) - b;
		a[i].y1 = lower_bound(b + 1, b + cnt + 1, a[i].y1) - b;
		a[i].x2 = lower_bound(b + 1, b + cnt + 1, a[i].x2) - b;
		a[i].y2 = lower_bound(b + 1, b + cnt + 1, a[i].y2) - b;
		//		printf("%d %d %d %d\n", a[i].x1, a[i].y1, a[i].x2, a[i].y2);
	}
}
bool cmp1(node a, node b) {
	return a.x1 < b.x1;
}
bool cmp2(node a, node b) {
	return a.x2 < b.x2;
}
void cdq(int l, int r) {
	if (l == r)return;
	int mid = l + r >> 1;
	cdq(l, mid);
	cdq(mid + 1, r);
	int L = l, R = mid + 1;
	sort(a + l, a + mid + 1, cmp2);
	sort(a + R, a + r + 1, cmp1);
	//	for (int i = l; i <= r; i++)printf("%d ", a[i].id);
	//	puts("");
	for (; L <= mid; L++) {
		while (a[R].x1 <= a[L].x2 && R <= r) {
			update(1, a[R].y1, a[R].y2, a[R].x2);
			R++;
		}
		f[a[L].id] |= find(1, a[L].y1, a[L].y2) >= a[L].x1;
		//	if (find(1, a[L].y1, a[L].y2) >= a[L].x1) {
		//		printf("%d %d %d\n", a[L].id, find(1, a[L].y1, a[L].y2), L-l);
		//	}
	}
	t[1].tag = t[1].mx = t[1].lazy = 0;
	pushdown(1);
	//	puts("Cleaded");
}
int main() {
	init();
	build(1, cnt << 1, 1);
	cdq(1, n);
	for (int i = 1; i <= n; i++) {
		if (f[i])puts("NE");
		else puts("DA");
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

该题是判断一个矩形是否被其他矩形覆盖；注意，这里有一个小细节，如果两矩形的边是重合的，那么两者是不算覆盖的；所以初始要将右上角的横纵坐标都减去 $1$。

归纳一下当矩形 $i$ 被矩形 $j$ 覆盖的条件：

- 首先是矩形 $i$ 要出现在矩形 $j$ 前面：

$$time_i<time_j$$

- 其次是横轴有覆盖的：

$$\begin{cases} X_{i,l} \le X_{j,r} \\ X_{i,r} \ge X_{j,l} \end{cases}$$

- 然后是纵轴有覆盖的：

$$\begin{cases} Y_{i,l} \le Y_{j,r} \\ Y_{i,r} \ge Y_{j,l} \end{cases}$$

当上述五个条件都满足时，则矩形 $i$ 被矩形 $j$ 覆盖。

是一个偏序问题，尝试使用 cdq 分治，先按 $time$ 从小到大排序；然后分治的区间为 $[l,mid]$ 和 $[mid+1,r]$，将两个区间分别按照 $X_r$ 和 $X_l$ 排序。

则现在要考虑右区间是否覆盖了左区间，先按照 $X_{i,r} \ge X_{j,l}$ 进行走指针，然后考虑剩下的三个条件：

$$\begin{cases} X_{i,l} \le X_{j,r} \\ Y_{i,l} \le Y_{j,r} \\ Y_{i,r} \ge Y_{j,l} \end{cases}$$

发现可以用线段树进行维护，每次将区间 $[Y_{j,l},Y_{j,r}]$ 内每个数的值替换为与 $X_{j,r}$ 的较大值。

则最后询问时，如果矩形 $i$ 的纵轴被其他矩形覆盖了，则 $[Y_{i,l},Y_{j,r}]$ 内肯定有值。

但是还要满足 $X_{i,l} \le X_{j,r}$，则要取区间最大值 $Max$ 是否满足 $X_{i,l} \le Max$，因为如果最大值都小于了 $X_{i,l}$，那么其他值就肯定也小于 $X_{i,l}$。

注意每次分治结束后清空线段树，也可以打一个清空的懒标记；而且值域很大，需要离散化。

时间复杂度为 $O(N \log^2 N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef double db;
const int N=100100;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int n,cnt=0; 
int h[N<<2];
bool ans[N];
struct Node{
	int x1,x2,y1,y2;
	int id;
}A[N];
class Tree{
public:
	struct Node{
		int l,r;
		int Max;
		int tag;
		int lazy; 
	}X[N<<4];
	inline void pushup(int k){
		X[k].Max=max(X[k<<1].Max,X[k<<1|1].Max);
	}
	inline void push_down(int k){
		if(X[k].lazy==-1){
			X[k<<1].tag=X[k<<1|1].tag=X[k<<1].Max=X[k<<1|1].Max=0;
			X[k<<1].lazy=X[k<<1|1].lazy=-1;
			X[k].lazy=0;
		}
		if(X[k].tag){
			X[k<<1].tag=max(X[k<<1].tag,X[k].tag);
			X[k<<1|1].tag=max(X[k<<1|1].tag,X[k].tag);
			X[k<<1].Max=max(X[k<<1].Max,X[k].tag);
			X[k<<1|1].Max=max(X[k<<1|1].Max,X[k].tag);
			X[k].tag=0;
		}
	}
	inline void build(int k,int l,int r){
		X[k].l=l,X[k].r=r;
		X[k].Max=X[k].tag=0;
		if(l==r)
		  return ;
		int mid=(l+r)>>1;
		build(k<<1,l,mid);
		build(k<<1|1,mid+1,r);
	}
	inline void updata(int k,int l,int r,int v){
		if(X[k].l==l&&r==X[k].r){
			X[k].Max=max(X[k].Max,v);
			X[k].tag=max(X[k].tag,v);
			return ; 
		}
		push_down(k);
		int mid=(X[k].l+X[k].r)>>1;
		if(r<=mid)
		  updata(k<<1,l,r,v);
		else if(l>mid)
		  updata(k<<1|1,l,r,v);
		else{
			updata(k<<1,l,mid,v);
			updata(k<<1|1,mid+1,r,v);
		}
		pushup(k);
	}
	inline int qurey(int k,int l,int r){
		if(X[k].l==l&&r==X[k].r)
		  return X[k].Max;
		push_down(k);
		int mid=(X[k].l+X[k].r)>>1;
		if(r<=mid)
		  return qurey(k<<1,l,r);
		else if(l>mid)
		  return qurey(k<<1|1,l,r);
		else
		  return max(qurey(k<<1,l,mid),qurey(k<<1|1,mid+1,r));
	}
	inline void add(int k){
		X[k].lazy=-1;
		X[k].tag=X[k].Max=0;
	}
}T;
inline bool cmp1(const Node&x,const Node&y){
	return x.x2<y.x2;
}
inline bool cmp2(const Node&x,const Node&y){
	return x.x1<y.x1;
}
inline void cdq(int l,int r){
	if(l==r)
	  return ;
	int mid=(l+r)>>1;
	cdq(l,mid);
	cdq(mid+1,r);
	sort(A+l,A+mid+1,cmp2);
	sort(A+mid+1,A+r+1,cmp1);
	int i=l,j=mid+1;
	for(;i<=mid;i++){
		while(j<=r&&A[j].x1<=A[i].x2){
			T.updata(1,A[j].y1,A[j].y2,A[j].x2);
			j++;
		}
		ans[A[i].id]|=(T.qurey(1,A[i].y1,A[i].y2)>=A[i].x1);
	}
	T.add(1);
}
int main(){
	n=read();
	for(int a,b,c,d,i=1;i<=n;i++){
		a=read(),b=read(),c=read(),d=read();
		c+=a-1,d+=b-1;
		A[i]={a,c,b,d,i};
		h[++cnt]=a,h[++cnt]=b;
		h[++cnt]=c,h[++cnt]=d;
	}
	sort(h+1,h+cnt+1);
	cnt=unique(h+1,h+cnt+1)-(h+1);
	for(int i=1;i<=n;i++){
		A[i].x1=lower_bound(h+1,h+cnt+1,A[i].x1)-h;
		A[i].y1=lower_bound(h+1,h+cnt+1,A[i].y1)-h;
		A[i].x2=lower_bound(h+1,h+cnt+1,A[i].x2)-h;
		A[i].y2=lower_bound(h+1,h+cnt+1,A[i].y2)-h;
//		cout<<A[i].x1<<' '<<A[i].y1<<' '<<A[i].x2<<' '<<A[i].y2<<'\n';
	}
	T.build(1,1,cnt);
	cdq(1,n);
	for(int i=1;i<=n;i++){
		if(ans[i])
		  puts("NE");
		else
		  puts("DA");
	}
	return 0;
}
```


---

## 作者：Felix72 (赞：0)

题目可以转化为求被挡住的矩形的编号，剩下的就是变成黄色的矩形。

考虑到前面加入的只会被后面的覆盖，我们先套上 cdq 模板，用一只 log 解决时间先后问题。我们要解决的就是求一个矩形的集合被另一个矩形的集合覆盖的问题。

先想想如果是线段怎么做。两根相交的线段，其左右端点有四种可能的相对位置情况，我们做四次排序，每次排序完维护坐标最值即可。那么既然多了一维，我们可以使用支持区间修改区间查询的数据结构维护最值，比如线段树。对于清空操作，使用懒标记就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 200010;
int n, tot, signx, signy;
bool is[N];
struct node {int osx, osy, otx, oty, sx, sy, tx, ty, id;} s[N];
struct lsh {int id, opt, num;} org[N];
inline bool cmp(lsh x, lsh y) {return x.num < y.num;}
inline bool cmp2(node x, node y) {return x.sx > y.sx;}
inline bool cmp3(node x, node y) {return x.tx < y.tx;}
inline bool cmp4(node x, node y) {return x.sx < y.sx;}
inline bool cmp5(node x, node y) {return x.tx > y.tx;}
int rt, idx;
struct SGT
{
	int ls, rs;
	int maxni, maxno, minni, minno, tag;
	#define ls(x) tree[x].ls
	#define rs(x) tree[x].rs
	#define maxni(x) tree[x].maxni
	#define maxno(x) tree[x].maxno
	#define minni(x) tree[x].minni
	#define minno(x) tree[x].minno
	#define tag(x) tree[x].tag
}tree[N * 4];
inline void pushdown(int now)
{
	if(tag(now))
	{
		if(ls(now)) tag(ls(now)) = 1, maxni(ls(now)) = maxno(ls(now)) = -2e9, minni(ls(now)) = minno(ls(now)) = 2e9;
		if(rs(now)) tag(rs(now)) = 1, maxni(rs(now)) = maxno(rs(now)) = -2e9, minni(rs(now)) = minno(rs(now)) = 2e9;
		tag(now) = 0;
	}
}
inline void build(int &now, int l, int r)
{
	if(!now) now = ++idx, maxni(now) = maxno(now) = -2e9, minni(now) = minno(now) = 2e9;
	if(l == r) return ;
	int mid = (l + r) >> 1;
	if(l <= mid) build(ls(now), l, mid);
	if(mid < r) build(rs(now), mid + 1, r);
}
inline void insertmax(int now, int l, int r, int L, int R, int num)
{
	maxno(now) = max(maxno(now), num);
	if(L <= l && r <= R) {maxni(now) = max(maxni(now), num); return ;}
	pushdown(now); int mid = (l + r) >> 1;
	if(L <= mid) insertmax(ls(now), l, mid, L, R, num);
	if(mid < R) insertmax(rs(now), mid + 1, r, L, R, num); 
}
inline void insertmin(int now, int l, int r, int L, int R, int num)
{
	minno(now) = min(minno(now), num);
	if(L <= l && r <= R) {minni(now) = min(minni(now), num); return ;}
	pushdown(now); int mid = (l + r) >> 1;
	if(L <= mid) insertmin(ls(now), l, mid, L, R, num);
	if(mid < R) insertmin(rs(now), mid + 1, r, L, R, num);
}
inline int askmax(int now, int l, int r, int L, int R)
{
	if(L <= l && r <= R) return max(maxni(now), maxno(now));
	pushdown(now); int mid = (l + r) >> 1, ans = maxni(now);
	if(L <= mid) ans = max(ans, askmax(ls(now), l, mid, L, R));
	if(mid < R) ans = max(ans, askmax(rs(now), mid + 1, r, L, R));
	return ans;
}
inline int askmin(int now, int l, int r, int L, int R)
{
	if(L <= l && r <= R) return min(minni(now), minno(now));
	pushdown(now); int mid = (l + r) >> 1, ans = minni(now);
	if(L <= mid) ans = min(ans, askmin(ls(now), l, mid, L, R));
	if(mid < R) ans = min(ans, askmin(rs(now), mid + 1, r, L, R));
	return ans;
}
inline void refresh()
{
	tag(rt) = 1;
	maxni(rt) = maxno(rt) = -2e9;
	minni(rt) = minno(rt) = 2e9;
}
inline void solve(int l, int r)
{
	if(l == r) return ;
	int mid = (l + r) >> 1;
	if(l <= mid) solve(l, mid), solve(mid + 1, r);
	
	int p1 = l, p2 = mid + 1;
	sort(s + l, s + mid + 1, cmp2);
	sort(s + mid + 1, s + r + 1, cmp2);
	refresh();
	for(int i = l; i <= r; ++i)
	{
		if(p1 == mid + 1 || (p2 <= r && s[p2].sx >= s[p1].sx))
		{
			insertmin(rt, 1, signy - 1, s[p2].sy, s[p2].ty - 1, s[p2].sx);
			++p2;
		}
		else
		{
			int cur = askmin(rt, 1, signy - 1, s[p1].sy, s[p1].ty - 1);
			if(cur < s[p1].tx) is[s[p1].id] = true;
			++p1;
		}
	}
	
	p1 = l, p2 = mid + 1;
	sort(s + l, s + mid + 1, cmp3);
	sort(s + mid + 1, s + r + 1, cmp3);
	refresh();
	for(int i = l; i <= r; ++i)
	{
		if(p1 == mid + 1 || (p2 <= r && s[p2].tx <= s[p1].tx))
		{
			insertmax(rt, 1, signy - 1, s[p2].sy, s[p2].ty - 1, s[p2].tx);
			++p2;
		}
		else
		{
			int cur = askmax(rt, 1, signy - 1, s[p1].sy, s[p1].ty - 1);
			if(cur > s[p1].sx) is[s[p1].id] = true;
			++p1;
		}
	}
	
	p1 = l, p2 = mid + 1;
	sort(s + l, s + mid + 1, cmp4);
	sort(s + mid + 1, s + r + 1, cmp4);
	refresh();
	for(int i = l; i <= r; ++i)
	{
		if(p1 == mid + 1 || (p2 <= r && s[p2].sx <= s[p1].sx))
		{
			insertmax(rt, 1, signy - 1, s[p2].sy, s[p2].ty - 1, s[p2].tx);
			++p2;
		}
		else
		{
			int cur = askmax(rt, 1, signy - 1, s[p1].sy, s[p1].ty - 1);
			if(cur > s[p1].sx) is[s[p1].id] = true;
			++p1;
		}
	}
	
	p1 = l, p2 = mid + 1;
	sort(s + l, s + mid + 1, cmp5);
	sort(s + mid + 1, s + r + 1, cmp5);
	refresh();
	for(int i = l; i <= r; ++i)
	{
		if(p1 == mid + 1 || (p2 <= r && s[p2].tx >= s[p1].tx))
		{
			insertmin(rt, 1, signy - 1, s[p2].sy, s[p2].ty - 1, s[p2].sx);
			++p2;
		}
		else
		{
			int cur = askmin(rt, 1, signy - 1, s[p1].sy, s[p1].ty - 1);
			if(cur < s[p1].tx) is[s[p1].id] = true;
			++p1;
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; ++i)
	{
		cin >> s[i].osx >> s[i].osy >> s[i].otx >> s[i].oty, s[i].id = i;
		s[i].otx += s[i].osx, s[i].oty += s[i].osy;
	}
	
	for(int i = 1; i <= n; ++i)
	{
		org[++tot].id = i, org[tot].opt = 0, org[tot].num = s[i].osx;
		org[++tot].id = i, org[tot].opt = 1, org[tot].num = s[i].otx;
	}
	sort(org + 1, org + tot + 1, cmp);
	for(int i = 1; i <= tot; ++i)
	{
		if(i == 1 || org[i].num > org[i - 1].num) ++signx;
		if(org[i].opt == 0) s[org[i].id].sx = signx;
		else s[org[i].id].tx = signx;
	}
	
	tot = 0;
	for(int i = 1; i <= n; ++i)
	{
		org[++tot].id = i, org[tot].opt = 0, org[tot].num = s[i].osy;
		org[++tot].id = i, org[tot].opt = 1, org[tot].num = s[i].oty;
	}
	sort(org + 1, org + tot + 1, cmp);
	for(int i = 1; i <= tot; ++i)
	{
		if(i == 1 || org[i].num > org[i - 1].num) ++signy;
		if(org[i].opt == 0) s[org[i].id].sy = signy;
		else s[org[i].id].ty = signy;
	}
	
	build(rt, 1, signy - 1);
	solve(1, n);
	
	for(int i = 1; i <= n; ++i)
	{
		if(is[i]) cout << "NE" << '\n';
		else cout << "DA" << '\n';
	}
	return 0;
}
```

---


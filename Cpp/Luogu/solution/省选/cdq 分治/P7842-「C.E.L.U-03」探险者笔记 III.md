# 「C.E.L.U-03」探险者笔记 III

## 题目背景

罗司机在通关小 Soup 所制作的游戏《探险者笔记》后，感到十分的悲伤。为了缓解内心的伤痛，他决定改制《探险者笔记》，使其成为一个快乐的游戏。  
一段时间之后，罗司机完成了制作，并喊来小 Soup 给他测试。

## 题目描述

改制后的《探险者笔记》由 $n$ 个关卡组成，每个关卡有一个难度 $b_i$，同时有 $m$ 个成就，第 $i$ 个成就需要你恰好完成 $sum_i$ 个关卡，且**刚好**分别是 $a_{i_1},a_{i_2},...,a_{i_{sum_i}}$。完成第 $i$ 个成就可以得到 $v_i$ 的分数。  
如果长时间推关而没有获得任何成就，小 Soup 会感到疲乏。而且成就的解锁是有一定顺序的。因此上一个获得第 $i$ 个成就接下来再获得第 $j$ 个成就的条件是 $i<j$ 且 $w+\sum\limits_{k=1}^{sum_i}b_{a_{i_k}}\ge\sum\limits_{k=1}^{sum_j}b_{a_{j_k}}$，其中 $w$ 是一个给定的常数。  
第一次获得成就没有任何限制。求最多他能得到多少分数。

## 说明/提示

### 样例解释

**样例解释一**    
依次完成第 $1,2$ 个成就。  

**样例解释二**    
依次完成第 $4,5,6$ 个成就。注意，成就之间的限制**只在相邻获得的成就之间生效。**

### 数据范围
|数据编号|$n\leq$|$m\leq$|
|:---:|:---:|:---:|
|$1$|$9$|$10^3$|
|$2$|$18$|$10^3$|
|$3\sim 6$|$9$|$10^5$|
|$7\sim 10$|$18$|$10^5$|

对于 $100\%$ 的数据 $1\le n\le18,1\le m\le10^5,1\le sum_i\le18,1\le w,b_i,v_i\le10^3,1\le a_i\le n$。  



## 样例 #1

### 输入

```
3 3 1
1 1 2
2 1 1
2 2 1 2
3 2 1 3```

### 输出

```
4```

## 样例 #2

### 输入

```
4 6 2
1 1 3 2
3 3 1 2 3
2 2 2 3
3 3 2 3 4
2 2 1 3
4 3 1 3 4
6 4 1 2 3 4```

### 输出

```
12```

# 题解

## 作者：abruce (赞：8)

关于探险者笔记和探险者笔记II，第一个出 R1 的时候被拒了，第二个重了，~~总之就是SPFA了~~。  
### 20pts  
题目给的信息非常难看，我们需要将其简化。我们设 $c_i=\sum\limits_{k=1}^{sum_i}b_{a_{i_k}}$，这很明显是个定值。然后我们再把第 $i$ 个成就需要的关卡用一个二进制数表示出来，设其为 $p_i$。我们便可以推出一个 $O(m^2)$ 的 dp：  
$f_i=\max\limits_{j=1}^{i-1} f_j+v_i(c_j+w\ge c_i,p_j\in p_i)$。  
直接暴力转移即可。  
### 50~60pts  
上面那个式子本质上是个三维偏序，考虑用 cdq 分治加速这个转移。  
只需用 cdq 解决 $c_j+w\ge c_i$，然后暴力枚举子集转移 $p_j\in p_i$ 即可。  
时间复杂度 $O(2^nm\log m)$。  
## 100pts  
暴力枚举子集时间复杂度显然不对，我们考虑怎么优化枚举。这时就有两种方法：  
一种是修改时把 $p_j$ 存下来，查询时枚举 $p_i$ 的子集，这样修改 $O(1)$，查询 $O(2^n)$。  
另一种是修改时枚举所有 $p_j$ 的超集进行预处理，查询时直接在数组中查询，这样修改 $O(2^n)$，查询 $O(1)$。  
我们考虑如何平衡这个复杂度。我们可以把一个 $18$ 位的二进制数劈成前 $9$ 位和后 $9$ 位。然后定义一个二维数组 $g_{s,t}$ 表示 $p_i$ 前 $9$ 位为 $s$,$p_j$ 后 $9$ 位为 $t$ 时的最优决策。  
在修改时，我们枚举 $p_j$ 前 $9$ 位的超集，然后把它的后 $9$ 位不枚举，直接存起来。  
在查询时，我们就直接调用 $p_i$ 的前 $9$ 位，再枚举其后 $9$ 位即可。  
这样就达到了平衡复杂度的目标，总时间复杂度 $O(2^{\frac{n}{2}}m\log m)$，可以通过本题。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5,maxm=512;
struct node {
	int a,b,v,id;
	friend bool operator<(node a,node b) {
		return a.a==b.a?a.id<b.id:a.a>b.a;
	}
} p[maxn],zc[maxn];
int g[maxm][maxm],n,f[maxn],b[maxn],m,w;
void add(int x,int v) {//修改
	int gw=x>>9,dw=x&511;
	if(n<=9) {
		g[0][dw]=max(g[0][dw],v);//如果只有8位，修改就不用枚举，减小常数。
		return;
	}
	for(register int i=gw;; i=(i+1)|gw) {//枚举前8位的超集
		g[i][dw]=max(g[i][dw],v);//后8位直接储存
		if(i==511)break;
	}
}
void clr(int x) {//清空，道理同修改
	int gw=x>>9,dw=x&511;
	if(n<=9) {
		g[0][dw]=0;
		return;
	}
	for(register int i=gw;; i=(i+1)|gw) {
		g[i][dw]=0;
		if(i==511)break;
	}
}
int ask(int x) {
	int gw=x>>9,dw=x&511,sum=0;
	for(register int i=dw;; i=(i-1)&dw) {//查询时枚举后8位
		sum=max(sum,g[gw][i]);
		if(!i)break;
	}
	return sum;
}
void cdq(int l,int r) {
	if(l==r)return;
	int mid=(l+r)/2,lst=l;
	cdq(l,mid);
	sort(p+l,p+mid+1),sort(p+mid+1,p+r+1);
	for(register int i=mid+1; i<=r; i++) {
		while(p[lst].a>=p[i].a-w&&lst<=mid) {
			add(p[lst].b,f[p[lst].id]);
			lst++;
		}
		f[p[i].id]=max(f[p[i].id],ask(p[i].b)+p[i].v);
	}
	for(register int i=l; i<lst; i++)clr(p[i].b);
	for(register int i=l; i<=r; i++)zc[p[i].id]=p[i];
	for(register int i=l; i<=r; i++)p[i]=zc[i];
	cdq(mid+1,r);
}//注意cdq优化dp必须按中序遍历
int main() {
	int siz,x;
	scanf("%d%d%d",&n,&m,&w);
	for(register int i=1; i<=n; i++)scanf("%d",&b[i]);
	for(register int i=1; i<=m; i++) {
		scanf("%d%d",&p[i].v,&siz);
		for(register int j=1; j<=siz; j++) {
			scanf("%d",&x);
			p[i].a+=b[x],p[i].b|=1<<x-1;
		}
		p[i].id=i,f[i]=p[i].v;
	}
	cdq(1,m);
	int ans=0;
	for(register int i=1; i<=m; i++)ans=max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：dAniel_lele (赞：1)

遇到小的转移到大的，考虑 CDQ 分治处理。

将每个成就包含的关卡记为一个 $S_i$ 集合，设子集和为 $tot_S$。则 $i$ 成就转移到 $j$ 成就的条件为 $i<j$ 且 $w+tot_{S_i}\geq tot_{S_j}$，$S_i\subset S_j$。

第一个条件在 CDQ 分治的时候满足了，第二个条件可以按照 $tot_{S_k}$ 排序双指针。第三个条件考虑折半，将 $S_i$ 前 $\frac{n}{2}$ 位先向后转移，查询时再将 $S_j$ 后 $\frac{n}{2}$ 位向前找即可。

总复杂度 $O(m\log m2^{\frac{n}{2}})$。

```cpp
#include <bits/stdc++.h>
#define double long double
#define mid ((l+r)>>1)
using namespace std;
struct deletable_heap{//本人原以为要求待删，后来改的时候名字就没改了，实际上就是个比 max 的玩意。
	int val;
	void add(int x){
		val=max(val,x);
	}
	int qry(){
		return val;
	}
}hp[262144];
int b[20],n,m,w;
struct node{
	int pos,v,dp,a,rb;
}c[100005];
bool cmp1(node x,node y){
	return x.pos<y.pos;
}
bool cmp2(node x,node y){
	return x.rb<y.rb;
}
void solve(int l,int r){
	if(l==r){
		c[l].dp+=c[l].v;
		return ;
	}
	solve(l,mid);
	sort(c+l,c+r+1,cmp2);
	int npos=r+1;
	for(int i=r;i>=l;i--){
		while(npos!=l&&c[i].rb<=c[npos-1].rb+w){
			npos--;
			if(c[npos].pos<=mid){
				for(int j=0;j<(1<<(n/2));j++){
					if((j&c[npos].a)==(((1<<(n/2))-1)&c[npos].a)){
						hp[j|c[npos].a].add(c[npos].dp);
					}
				}
			}
		}
		if(c[i].pos>mid){
			for(int j=0;j<(1<<((n+1)/2));j++){
				int rj=j<<(n/2);
				if((rj|c[i].a)==c[i].a){
					c[i].dp=max(c[i].dp,hp[c[i].a&(rj|((1<<(n/2))-1))].qry());
				}
			}
		}
	}
	for(int i=l;i<=r;i++){
		if(c[i].pos<=mid){
			for(int j=0;j<(1<<(n/2));j++){
				if((j&c[i].a)==(((1<<(n/2))-1)&c[i].a)){
					hp[j|c[i].a].val=0;
				}
			}
		}
	}
//	cout<<"\n";
	sort(c+l,c+r+1,cmp1);
	solve(mid+1,r);
}
signed main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=m;i++){
		int sum;
		cin>>c[i].v>>sum; c[i].pos=i;
		for(int j=1;j<=sum;j++){
			int x; cin>>x;
			c[i].a|=(1<<(x-1));
			c[i].rb+=b[x];
		}
	}
	solve(1,m);
	int maxv=0;
	for(int i=1;i<=m;i++) maxv=max(maxv,c[i].dp);
	cout<<maxv;
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

~~神题，先膜拜……~~

### 思路：

~~是不是只有我每个分段的代码都打了一次……~~

先说一下概念：

- 若 $A$ 是 $B$ 的子集，则 $A \subseteq B$。

- 若 $B$ 是 $A$ 的超集，则 $A \subseteq B$。

首先发现 $\sum\limits_{k=1}^{sum_i} b_{a_i,k}$ 是一个固定的值，将第 $i$ 个成就的难度和记为 $t_i$。

然后因为对于每一个成就需要**恰好**完成这些关卡，即多完成一个或者少完成一个都不行，则只要成就 $i$ 要完成的关卡是成就 $j$ 要完成的关卡的子集且 $t_i + w \ge w_k$，那么就可以从成就 $i$ 跳到成就 $j$；则现在定义成就 $i$ 要完成的关卡的二进制形式为 $s_i$。

那么考虑动态规划算法，定义 $dp_i$ 表示完成第 $i$ 个成就得到的最大分数；初始 $dp_i=v_i$，状态转移方程为：

$$dp_i=\max\limits_{j=1}^{i-1} [t_j+w \ge t_i] [s_j \subseteq s_i] dp_j+v_i$$

算上枚举子集的 $2^N$，则时间复杂度为 $O(M^2 2^N)$，获得了 20pts。

[20pts 代码。](https://www.luogu.com.cn/paste/i0d10z34)

这是一个偏序最大值问题，考虑 cdq 分治，当 $j$ 可以被 $i$ 转移的条件为：

$$\begin{cases} j <i \\ t_j + w \ge t_i \\ s_j \subseteq s_i\end{cases}$$

设分治的区间为 $[l,mid]$ 和 $[mid+1,r]$，要求左区间对右区间的贡献，则需要按照 $t$ 从大到小排序，然后进行走指针。

现在主要是看如果计算子集的贡献，先考虑将符合条件的左区间的 $dp_j$ 加入集合 $s_j$ 中，然后查询的时候，可以枚举 $s_i$ 的子集，求每个子集集合答案的最大值。

时间复杂度为 $O(2^N M \log M)$。

[60pts 代码。](https://www.luogu.com.cn/paste/z497xr32)

现在时间瓶颈就在找子集上，考虑进行优化，定义 $a_{x,y}$ 表示前 $9$ 为位为 $x$ 后 $9$ 位为 $y$ 的最大值。

则每次插入 $s_j$ 时，设前 $9$ 位为 $x_2$ 后 $9$ 位为 $y_2$，后 $9$ 位不动，枚举 $x_2$ 的超集 $i$，将 $a_{i,y_2} \to \max(a_{i,y_2},dp_j)$。

每次查询 $s_i$ 的子集最大值时，枚举 $y_2$ 的子集 $i$，答案为 $\max\limits_{i \subseteq y_2} a_{x_2,i}$。

这样为什么正确的呢？因为插入时将前 $9$ 位的超集更新了，则前 $9$ 位为 $x_2$ 的答案中肯定是 $x_2$ 的子集；对于后 $9$ 位枚举子集，记录答案即可。

时间复杂度为 $O(2^{\frac{N}{2}} M \log M)$。

**注意因为是动态规划优化，要按中序遍历分治。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll M=100100,N=513;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,w,l,x,ans;
ll a[M];
struct Node{
	ll id;
	ll v,s,t;
	ll ans;
	bool operator<(const Node&rhs)const{
		if(t!=rhs.t)
		  return t>rhs.t;
		return id<rhs.id;
	}
}A[M];
class Tree{
public:
	ll a[N][N];
	void add(ll x,ll y){
		ll X=x>>9,Y=x&511;
		if(n<=9){
			a[0][Y]=max(a[0][Y],y);
			return;
		}
		for(int i=X;;i=(i+1)|X){
			a[i][Y]=max(a[i][Y],y);
			if(i==511)
			  break;
		}
	}
	ll qurey(ll x){
		ll X=x>>9,Y=x&511,ans=0;
		for(int i=Y;;i=(i-1)&Y){
			ans=max(ans,a[X][i]);
			if(!i)
			  break;
		}
		return ans;
	}
	void clear(ll x){
		ll X=x>>9,Y=x&511;
		if(n<=9){
			a[0][Y]=0;
			return;
		}
		for(int i=X;i<512;i=(i+1)|X){
			a[i][Y]=0;
			if(i==511)
			  break;
		}
	}
}T;
bool cmp(const Node&a,const Node&b){
	return a.id<b.id;
}
void cdq(ll l,ll r){
	if(l==r)
	  return ;
	ll mid=(l+r)>>1;
	cdq(l,mid);
	sort(A+l,A+mid+1);
	sort(A+mid+1,A+r+1);
	int i=l,j=mid+1; 
	for(;j<=r;j++){
		while(i<=mid&&A[i].t+w>=A[j].t){
			T.add(A[i].s,A[i].ans);
			i++;
		}
		A[j].ans=max(A[j].ans,T.qurey(A[j].s)+A[j].v);
	}
	for(int j=l;j<i;j++)
	  T.clear(A[j].s);
	sort(A+l,A+r+1,cmp);
	cdq(mid+1,r);
}
int main(){
	n=read(),m=read(),w=read();
	for(int i=1;i<=n;i++)
	  a[i]=read();
	for(int i=1;i<=m;i++){
		A[i].v=read();
		l=read();
		for(int j=1;j<=l;j++){
			x=read();
			A[i].s|=1ll<<(x-1);
			A[i].t+=a[x];
		}
		A[i].id=i;
		A[i].ans=A[i].v;
	}
	cdq(1,m);
	for(int i=1;i<=m;i++)
	  ans=max(ans,A[i].ans);
	write(ans);
	return 0;
}
```

---


# 「DTOI-2」星之河

## 题目背景

> 星稀河影转，霜重月华孤。


## 题目描述

星之统治者有一个星盘，其可以被抽象为一棵根节点为 $1$ 的树。树上每个节点 $i$ 有一颗红星、一颗蓝星，亮度分别记为 $\text{Red}_i,\text{Blue}_i$。

现在，星之统治者想要知道，对于每个节点 $x$，其子树内（不包括该节点）有多少节点满足：其红星亮度小于等于 $x$ 的红星亮度，且其蓝星亮度小于等于 $x$ 的蓝星亮度。

你需要按编号顺序依次输出每个节点的答案。为减少输出量，**如果答案为 $0$ 则不必输出。**


## 说明/提示

### 样例解释

对于节点 $1$，小于等于他的子节点有 $6,7,8,9,10$，因此输出 $5$。  
对于节点 $4$，小于等于他的子节点有 $6$，因此输出 $1$。  
对于节点 $5 $ 至 $10$，没有小于等于他的子节点，因此不输出。

### 数据范围

| $\textbf{Subtask}$| $n\le$ | 特殊性质 | 总分数 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $1000$ | 无 | $10$ |
| $2$ | $5\times 10^4$ | 无 | $20$ ||
| $3$ | $10^5$ | $-200\le \text{Red}_i, \text{Blue}_i \le 200$ | $20$ |
| $4$ | $2\times 10^5$ | 树的形态是链 | $20$ |
| $5$ | $2\times 10^5$ | 无 | $30$ |

对于所有数据，保证 $n \le 2\times 10^5$，$-10^9 \le \text{Red}_i, \text{Blue}_i \le 10^9$。



## 样例 #1

### 输入

```
10
2 1
3 1
4 3
5 1
6 4
7 2
8 2
9 4
10 3
3 1
2 4
-3 3
4 -2
-2 3
-3 -6
-5 -1
-4 -7
-5 -1
-7 -7```

### 输出

```
5
2
3
1```

# 题解

## 作者：Demeanor_Roy (赞：13)

- 比较板的三维偏序。

- 不会三维偏序的可以先转[这儿](https://www.luogu.com.cn/problem/P3810)

------------
首先拿到题，不难发现如果给定的不是一棵树而是序列，那就是完全的板子题。

考虑如何向原问题转化：当然是要按照某个“序”将树变成序列，那怎么知道应该按照什么“序”呢？

让我们回归问题本身，题目要求的是求每个节点为根的子树内的二维偏序，那这个“序”当然需要满足同一子树内的节点在“序”中编号都大于/小于根节点，容易想到 dfs 序就满足条件。

- 按 dfs 序给每个点编号，那题目就转化为对每个点 $u$ 求出满足如下要求的点 $v$ 的个数：

1. $red_v \leq red_u$

2. $blue_v \leq blue_u$

3. $dfn_u < dfn_v < dfn_u + sz_u$

那么直接做三维偏序就行了，下附代码：

```cpp

#include<bits/stdc++.h>
using namespace std;
#define lowbit(x)	x&-x
#define mid ((L+R)>>1)
const int N=2e5+10;
int n,now,ans[N],C[N];
int h[N],e[N<<1],ne[N<<1],idx;
struct node
{
	int red,blue,dfn,sz,id;
	bool operator<(const node other)const
	{
		if(red!=other.red)	return red<other.red;
		if(blue!=other.blue)	return blue<other.blue;
		return dfn>other.dfn;
	}
}p[N],tmp[N];
inline void link(int a,int b)
{
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
inline void dfs(int u,int fa)
{
	p[u].dfn=++now;
	p[u].sz=1;
	for(int i=h[u];~i;i=ne[i])
	{
		if(e[i]==fa)	continue;
		dfs(e[i],u);
		p[u].sz+=p[e[i]].sz;
	}
}
inline void add(int x,int y)
{
	for(;x<=n;x+=lowbit(x))	C[x]+=y;
}
inline int query(int x)
{
	int ans=0;
	for(;x;x-=lowbit(x))	ans+=C[x];
	return ans;
}
inline void mergesort(int L,int R)
{
	if(L==R)	return void();
	mergesort(L,mid);
	mergesort(mid+1,R);
	int i=L,j=mid+1,t=0;
	while(i<=mid&&j<=R)
		if(p[i].blue<=p[j].blue)	add(p[i].dfn,1),tmp[++t]=p[i],i++;
		else ans[p[j].id]+=query(min(p[j].dfn+p[j].sz-1,n))-query(p[j].dfn),tmp[++t]=p[j],j++;
	while(i<=mid)	add(p[i].dfn,1),tmp[++t]=p[i],i++;
	while(j<=R)	ans[p[j].id]+=query(min(p[j].dfn+p[j].sz-1,n))-query(p[j].dfn),tmp[++t]=p[j],j++;
	for(int i=L;i<=mid;i++)	add(p[i].dfn,-1);
	for(int i=L,j=1;i<=R;i++,j++)	p[i]=tmp[j];
}
int main()
{
	memset(h,-1,sizeof h);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)	p[i].id=i;
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		link(u,v),link(v,u);
	}
	dfs(1,-1);
	for(int i=1;i<=n;i++)	scanf("%d%d",&p[i].red,&p[i].blue);
	sort(p+1,p+n+1);
	mergesort(1,n);
	for(int i=1;i<=n;i++)	if(ans[i])	printf("%d\n",ans[i]);
	return 0;
}
```
- 完结撒花~

---

## 作者：joke3579 (赞：11)

出题人题解。

----

抽象蓝红星间关系为二维偏序。然而无法使用二维线段树维护树上关系，因此考虑将树上父子关系抽象成偏序关系。

首先把树使用欧拉序拍成序列。然后父子关系就被转换成了序列内部的包含关系。设节点的欧拉序为 $[p,t]$，值为 $(a,b)$。我们可以将原问题的关系转化成偏序关系 $a_i \le a_j \ \land \ b_i \le b_j \ \land \ p_j< p_i \le t_i \le t_j $。使用 cdq 偏序求解即可。

需要注意的是，如果使用出节点不 `++ stp` 的 dfn 序时应使用偏序 $p_j< p_i$ 而不是 $t_i \le t_j$，以避免出现 $t_i = t_j$ 时无法算入贡献的问题。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Fread  { const int SIZE = (1 << 18); char buf[SIZE], *p1 = buf, *p2 = buf; inline char getchar() {return (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, SIZE, stdin), p1 == p2) ? EOF : *p1++);} }
namespace Fwrite { const int SIZE = (1 << 18); char buf[SIZE], *S = buf, *T = buf+SIZE; inline void flush(){ fwrite(buf, 1, S-buf, stdout), S = buf; }  struct NTR{ ~NTR() { flush(); } }ztr;inline void putchar(char c){ *S++ = c; if(S == T) flush(); } }
#ifdef ONLINE_JUDGE
    #define getchar Fread::getchar
    #define putchar Fwrite::putchar
#endif
namespace Fastio{
    struct Reader{ template <typename T> Reader & operator >> (T & x) {char c = getchar(); bool f = false;while (c < '0' or c > '9') { if (c == '-') f = true;c = getchar();} x = 0;while(c >= '0' and c <= '9'){x = (x<<1)+(x<<3)+(c^48);c = getchar();} if (f) x = -x;return *this;}Reader&operator>>(char&c){ c=getchar();while(c=='\n'||c==' '||c=='\r')c=getchar();return *this;}Reader&operator>>(char*str){ int len=0;char c=getchar(); while(c=='\n'||c==' '||c=='\r')c=getchar(); while(c!='\n'&&c!=' '&&c!='\r')str[len++]=c,c=getchar(); str[len]='\0'; return *this;}Reader & operator >> (float & x) {char c=getchar();short f=1,s=0;x=0;double t=0;while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else return x*=f,*this;while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader & operator >> (double & x) {char c=getchar();short f=1,s=0;x=0;double t=0;while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else return x*=f,*this;while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(long double&x){char c=getchar();short f=1,s=0;x=0;long double t=0;while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else return x*=f,*this;while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(__float128&x){char c=getchar();short f=1,s=0;x=0;__float128 t=0;while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.') c = getchar();else return x*=f, *this;while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return *this;}Reader(){}}cin;
    struct Writer{ template <typename T> Writer & operator << (T   x) {if(x == 0) return putchar('0'), *this;if(x < 0) putchar('-'), x = -x;static int sta[60], top = 0; while (x)  sta[++top] = x %10, x /= 10; while (top)  putchar(sta[top] + '0'), --top; return *this;} Writer&operator<<(char c){putchar(c);return*this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;} typedef unsigned long long mxdouble; int precision = 6; Writer set_precision(int val) { precision = val; return *this; }template <typename T> T deal_precision(T x) {__float128 tmp = x;for(int i=0;i<=precision;i++)tmp*=10;tmp+=5;for(int i=0;i<=precision;i++) tmp/=10;return (T)tmp;}Writer&operator<<(float x){if(x<0)putchar('-'),x=-x; x=deal_precision(x); mxdouble _=x;x-=(__float128)_;static int sta[60];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');while(top)putchar(sta[top]+'0'),--top;if(precision==0)return*this;putchar('.');for(int i=0;i<=precision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<precision-top;i++)putchar('0');while(top)putchar(sta[top]+'0'),--top;return*this;}Writer&operator<<(double x){if(x<0)putchar('-'),x=-x; x = deal_precision(x); mxdouble _=x;x-=(double)_;static int sta[60];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');while(top)putchar(sta[top]+'0'),--top;if(precision==0)return*this;putchar('.');for(int i=0;i<precision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<precision-top;i++)putchar('0');while(top)putchar(sta[top]+'0'),--top;return*this;}Writer&operator<<(long double x){if(x<0)putchar('-'),x=-x; x = deal_precision(x); mxdouble _=x;x-=(__float128)_;static int sta[60];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');while(top)putchar(sta[top]+'0'),--top;if(precision==0)return*this;putchar('.');for(int i=0;i<precision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<precision-top;i++)putchar('0');while(top)putchar(sta[top]+'0'),--top;return*this;}Writer&operator<<(__float128 x){if(x<0)putchar('-'),x=-x; x = deal_precision(x); mxdouble _=x;x-=(__float128)_;static int sta[60];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');while(top)putchar(sta[top]+'0'),--top;if(precision==0)return*this;putchar('.');for(int i=0;i<precision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<precision-top;i++)putchar('0');while(top)putchar(sta[top]+'0'),--top;return*this;}Writer(){}}cout; /* 精度是后15位 nan会以“9223372036854775808.9223372036854775808”的方式输出 */
}   const char * enl = "\n"; const char * sp = " ";
#define cin  Fastio :: cin
#define cout Fastio :: cout
#define N 400005
#define rep(i,a,b) for ( register int (i) = (a); (i) ^ ((b)+1); ++(i) )
#define pre(i,a,b) for ( register int (i) = (a); (i) ^ ((b)-1); --(i) )
int n, ans[N];

struct ele {
    int p, t, a, b, id;
    bool operator < (const ele & k) const {
        if (a != k.a) return a < k.a;
        if (b != k.b) return b < k.b;
        return p > k.p;
    }
} el[N], tmp[N];

bool cmp(const ele & a, const ele & b) {
    if (a.b != b.b) return a.b < b.b;
    return a.p > b.p;
}

#define Aster(_src) for ( register int i = head[_src] ; i; i = e[i].next)
#define v e[i].to
int head[N], mlc;
struct star {
    int next, to;
}e[N<<1]; 
inline void adde(int f, int t) {
    e[++mlc].to = t;
    e[mlc].next = head[f];
    head[f] = mlc;
}

int dfn[N], stp, end[N];
void dfs(int u, int f) {
    el[u].p = ++stp;
    Aster(u) {
        if (v == f) continue;
        dfs(v, u);
    } el[u].t = stp;
}

int Index[N];
inline void add(int p, int val) {
    while (p <= n) {
        Index[p] += val;
        p += p & -p;
    }
}
inline int qry(int p) {
    int ret = 0;
    while (p) {
        ret += Index[p];
        p -= p & -p;
    } return ret;
}

#define mid ((l + r) >> 1)
void cdq(int l, int r) {
    if(l == r) return;
    cdq(l, mid), cdq(mid+1, r);
    int i = l, j = mid+1;
    while (j <= r) {
        while (i <= mid and el[i].b <= el[j].b) {
            add(el[i].p, 1);
            i++;
        } ans[el[j].id] += qry(el[j].t) - qry(el[j].p - 1);
        j++;
    } 
    rep(k,l,i-1) add(el[k].p, -1);
    merge(el + l, el + mid + 1, el + mid + 1, el+r+1, tmp+l, cmp);
    memcpy(el+l, tmp+l, sizeof(ele) * (r - l + 1));
}

int main() {
    register int t1, t2;
    cin >> n;
    rep(i,2,n) cin >> t1 >> t2, adde(t1, t2), adde(t2, t1);
    rep(i,1,n) {
        cin >> el[i].a >> el[i].b;
        el[i].id = i;
    } dfs(1, 0);
    sort(el+1, el+1+n);
    // rep(i,1,n) cout << el[i].t << enl;
    cdq(1, n);
    rep(i,1,n) {
        if (ans[i] != 0) cout << ans[i] << enl;
    } return 0;
}
```

---

## 作者：Cadmus (赞：8)

## $\mathcal{Solution}$

通过 [dfs 序](https://www.baidu.com/s?wd=dfs序)将树上问题转化为序列问题：

对于每个 $u$ 求 $v$ 的个数，使得
- $\text{Red}_{v}\leq\text{Red}_{u}$
- $\text{Blue}_{v}\leq\text{Blue}_{u}$
- $L_u\leq L_v$
- $R_v\leq R_u$

乍一看好像四维偏序，实际上 dfs 序有一个性质，两个点的 dfs 序要么包含，要么不相交。也就是说最后两维肯定同时合法 / 不合法。

那么，显然[三维偏序](/problem/P3810)板子。

```cpp
struct node {
	int a, b, l, r, id;
} s[N];
```

$a,b$ 为分别为该点的 $\text{Red}$ 与 $\text{Blue}$，$l,r$ 为该点的 dfs 序的左右端点。

那么排序时，应该如下排序：

```cpp
bool cmp1(const node& x, const node& y) {
	return x.a == y.a ? x.b == y.b ? x.l > y.l : x.b < y.b : x.a < y.a;
}
bool cmp2(const node& x, const node& y) {
	return x.b == y.b ? x.l > y.l : x.b < y.b;
}
```
为什么呢？因为求的时 $[L_i,R_i]$ 之间的答案，显然 $L_i$ 较大的才会被之后包含。

## $\mathcal{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
struct node {
	int a, b, l, r, id;
} s[N];
int n, u, v, tot, in[N], out[N], ans[N];
vector<int> G[N];
struct tree {
    int c[N];
    int lowbit(int x) { return x & (-x); }
    void upd(int x, int val) { for (; x <= n; x += lowbit(x)) c[x] += val; }
    int query(int x) { int res = 0; for (; x; x -= lowbit(x)) res += c[x]; return res; }
} bit;
bool cmp1(const node& x, const node& y) {
	return x.a == y.a ? x.b == y.b ? x.l > y.l : x.b < y.b : x.a < y.a;
}
bool cmp2(const node& x, const node& y) {
	return x.b == y.b ? x.l > y.l : x.b < y.b;
}
void cdq(int l, int r) {
	if (l == r) return;
	int mid = (l + r) >> 1;
	cdq(l, mid), cdq(mid + 1, r);
	sort(s + l, s + 1 + mid, cmp2);
	sort(s + mid + 1, s + 1 + r, cmp2);
	int p = l;
	for (int i = mid + 1; i <= r; i ++) {
		while (s[i].b >= s[p].b && p <= mid)
			bit.upd(s[p].l, 1), p ++;
		ans[s[i].id] += bit.query(s[i].r) - bit.query(s[i].l - 1);
	}
	for (int i = l; i < p; i ++) bit.upd(s[i].l, -1);
}
void dfs(int u, int fa) {
	in[u] = ++ tot;
	for (int v : G[u])
		if (v != fa) dfs(v, u);
	out[u] = tot;
}
int main() {
	cin >> n;
	for (int i = 1; i < n; i ++)
		cin >> u >> v, G[u].push_back(v), G[v].push_back(u);
	dfs(1, 0);
	for (int i = 1; i <= n; i ++) {
		cin >> s[i].a >> s[i].b;
		s[i].l = in[i], s[i].r = out[i], s[i].id = i;
	}
	sort(s + 1, s + 1 + n, cmp1);
	cdq(1, n);
	for (int i = 1; i <= n; i ++)
		if (ans[i]) cout << ans[i] << '\n';
	return 0;
}

```


---

## 作者：bcdmwSjy (赞：7)

这是一道明显的三维偏序，偏序关系如下：

1. $\text{Red}_v\le\text{Red}_u$

2. $\text{Blue}_v\le\text{Blue}_u$

3. $\text{dfn}_u<\text{dfn}_v\le\text{dfn}_u+\text{size}_u-1$

对点按红、蓝升序，dfn 降序排序后，很明显可以使用树套树（树状数组套线段树）维护后两维，但是朴素的树套树空间太大，无法通过。

考虑优化，给树上每个节点再多维护出 idx 和 cnt，在修改 x 位置时如果要新建节点，那么就把 idx 设为 x，并把 cnt 设为 1，然后立即返回，不继续向下走，以后的修改和查询注意一下 idx 位置的值就可以了，这样就做到了每次只开一个点。这样总共只需要不到 $5\times10^6$ 个节点。

线段树部分代码：

```cpp
void update(int &i,int l,int r,int x){
	if (i==0){
		i=++cnt;
		tr[i].idx=x;
		tr[i].cnt=tr[i].sum=1;
		return;
	}
	tr[i].sum++;
	if (tr[i].idx==x){
		tr[i].cnt++;
		return;
	}
	if (l==r) return;
	int mid=(l+r)>>1;
	if (mid>=x) update(tr[i].ls,l,mid,x);
	else update(tr[i].rs,mid+1,r,x);
}

int query(int i,int l,int r,int ql,int qr){
	if (i==0) return 0;
	if (l>=ql and r<=qr) return tr[i].sum;
	int mid=(l+r)>>1,ans=0;
	if (ql<=tr[i].idx and tr[i].idx<=qr) ans=tr[i].cnt;
	if (mid>=ql) ans+=query(tr[i].ls,l,mid,ql,qr);
	if (mid+1<=qr) ans+=query(tr[i].rs,mid+1,r,ql,qr);
	return ans;
}
```

但是这样仍然有两个点 MLE，但是超的不多，考虑如何继续卡，首先把不同时用到的数组复用（拿 dfn 数组离散化），并删除存根节点的数组，提前把根节点开出来，前 n 个点就是根节点，然后发现线段树节点存的数不会占满 32 位，可以把 5 个 int 压到一个 int128 内。

附赠一份自己写的位域（用法很清楚了）：

```cpp
typedef __int128 i128;
typedef __uint128_t u128;

const u128 one=1,neg1=-1;

struct Bit128{
	u128 a;
	inline void set(int pos,int len,int v){
		a&=(neg1^(((one<<len)-1)<<pos));
		a|=u128(v)<<pos;
	}
	inline int get(int pos,int len){
		return (a>>pos)&((one<<len)-1);
	}
	inline void add(int pos,int v){
		a+=u128(v)<<pos;
	}
};
```

把那五个变量在位域内安排一下位置就行了。

接下来再卡卡常，减少一些函数调用就可以在不用快读快写的情况下过掉这道题了。

数据结构的力量是无穷的！

~~不加快读的[记录](https://www.luogu.com.cn/record/200263845)，时空都极限通过，喜提最劣解（~~

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 i128;
typedef __uint128_t u128;

const u128 one=1,neg1=-1;

// var pos len
// ls:0 25
// rs:26 25
// idx:51 18
// sum:69 30
// cnt:99 30

//struct Node{
//	int ls,rs,idx,sum,cnt;
//};

struct A{
	int a,b,id;
};

int n,m,cnt,tot,dcnt;
int ans[200001],dfn[200001],siz[200001];
vector<int> e[200001];
A a[200001];
Bit128 tr[5000000];

inline bool cmp(A a,A b){
    if (a.a==b.a){
        if (a.b==b.b){
            return dfn[a.id]>dfn[b.id];
        }else{
            return a.b<b.b;
        }
    }else{
        return a.a<b.a;
    }
}

int update(int i,int l,int r,int x){
	if (i==0){
		i=++cnt;
		tr[i].add(51,x);
		tr[i].add(69,1);
		tr[i].add(99,1);
		return i;
	}
	tr[i].add(69,1);
	if (tr[i].get(51,18)==x){
		tr[i].add(99,1);
		return i;
	}
	if (l==r) return i;
	int mid=(l+r)>>1;
	if (mid>=x) tr[i].set(0,25,update(tr[i].get(0,25),l,mid,x));
	else tr[i].set(26,25,update(tr[i].get(26,25),mid+1,r,x));
	return i;
}

int query(int i,int l,int r,int ql,int qr){
	if (i==0) return 0;
	if (l>=ql and r<=qr) return tr[i].get(69,30);
	int mid=(l+r)>>1,ans=0,idx=tr[i].get(51,18);
	if (ql<=idx and idx<=qr) ans=tr[i].get(99,30);
	if (mid>=ql) ans+=query(tr[i].get(0,25),l,mid,ql,qr);
	if (mid+1<=qr) ans+=query(tr[i].get(26,25),mid+1,r,ql,qr);
	return ans;
}

inline void add(int x,int y){
	for (;x<=tot;x+=x&-x){
		update(x,1,n,y);
	}
}

inline int query(int x,int l,int r){
	int ans=0;
	for (;x;x&=x-1) ans+=query(x,1,n,l,r);
	return ans;
}

void dfs(int u,int fa){
	dfn[u]=++dcnt;
	siz[u]=1;
	for (auto i:e[u]){
		if (i!=fa){
			dfs(i,u);
			siz[u]+=siz[i];
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>n;
	for (int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for (int i=1;i<=n;i++){
	    cin>>a[i].a>>a[i].b;
		a[i].id=i;
		dfn[++tot]=a[i].b;
	}
	sort(dfn+1,dfn+tot+1);
	tot=unique(dfn+1,dfn+tot+1)-dfn-1;
	for (int i=1;i<=n;i++) a[i].b=lower_bound(dfn+1,dfn+tot+1,a[i].b)-dfn;
	dfs(1,0);
	stable_sort(a+1,a+n+1,cmp);
	cnt=tot;
	for (int i=1;i<=n;i++){
		int u=a[i].id;
		ans[u]=query(a[i].b,dfn[u],dfn[u]+siz[u]-1);
		add(a[i].b,dfn[u]);
	}
	for (int i=1;i<=n;i++) if (ans[i]) cout<<ans[i]<<"\n";
	return 0;
}
```

代码里的位域被我吃了。

---

## 作者：JimmyLee (赞：3)

# P8575 「DTOI-2」星之河 题解

## 题目描述

[P8575 「DTOI-2」星之河](https://www.luogu.com.cn/problem/P8575)

## 题目解法

看题目就能感觉到是一道求偏序的题。所以我们先找偏序关系。

$Red_i$ 和 $Blue_i$ 的关系题面已经给出，现在考虑子树关系。

自然而然地联想到 dfs 序。

先求出每个点的 dfs 序 $dfn_i$，以及其子树的大小 $size_i$。

如果点 $j$ 在点 $i$ 的子树中，那么就有 $dfn_i<dfn_j<dfn_i+size_i$。

综上，可以得出 $j$ 对 $i$ 有贡献的条件：

$$
Red_j\leq Red_i\wedge Blue_j\leq Blue_i \wedge dfn_i<dfn_j<dfn_i+size_i
$$

乍一看，好像是个四维偏序 ~~（cdq 套 cdq）~~

但是由于最后一组条件比较特殊，可以化为三维偏序。

使用 cdq 分治。如果不会建议先做：[【模板】三维偏序](https://www.luogu.com.cn/problem/P3810)

在三维偏序模板中，用树状数组统计答案的时候统计的是 $[1,x_i)$ 该区间。

在本题中，用树状数组统计答案的时候我们统计 $(dfn_i,dfn_i+size_i)$ 区间。

除此之外就是裸的 cdq 分治。

同时需要注意一下排序部分 $Blue_i,Red_i$ 升序，而 $dfn_i$ 降序。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 200005

vector<int> e[maxn];

int dfn[maxn], siz[maxn];
void dfs(int u, int f)
{
    dfn[u]=++*dfn;
    for(auto v:e[u])
        if(v!=f) 
            dfs(v, u), siz[u]+=siz[v]+1;
}

struct st
{
    int x, y, l, r, id;
    st(int X, int Y, int L, int R, int I): id(I), x(X), y(Y), l(L), r(R){}
};

bool cmp1(st a, st b)
{
    if(a.x!=b.x) return a.x<b.x;
    if(a.y!=b.y) return a.y<b.y;
    return a.l>b.l;
}

bool cmp2(st a, st b)
{
    if(a.y!=b.y) return a.y<b.y;
    if(a.l!=b.l) return a.l>b.l;
    return a.x<b.x;
}

vector<st> vc;

template<typename Tp>
struct BIT:vector<Tp>
{
    void modify(size_t i, Tp v) {for(;i<this->size();i+=i&-i) (*this)[i]+=v;}
    Tp query(size_t i)     {Tp r=0; for(;i;i-=i&-i) r+=(*this)[i]; return r;}
};

BIT<int> ta;

int ans[maxn];

void cdq(int l, int r)
{
    if(l==r) return;
    int mid=(l+r)>>1;
    cdq(l, mid); cdq(mid+1, r);
    sort(vc.begin()+l, vc.begin()+r+1, cmp2);
    for(int i=l;i<=r;i++)
        if(vc[i].x<=mid) ta.modify(vc[i].l, 1);
        else ans[vc[i].id]+=ta.query(vc[i].r)-ta.query(vc[i].l-1);
    for(int i=l;i<=r;i++)
        if(vc[i].x<=mid) 
            ta.modify(vc[i].l, -1);
}

signed main()
{
    int n;
    cin>>n;
    ta.resize(n+5);
    for(int i=1, u, v;i<n;i++)
    {
        cin>>u>>v;
        e[u].emplace_back(v);
        e[v].emplace_back(u);
    }
    dfs(1, 0);
    for(int i=1, r, b;i<=n;i++) 
    {
        cin>>r>>b;
        vc.emplace_back(r, b, dfn[i], min(dfn[i]+siz[i], n), i);
    }
    sort(vc.begin(), vc.end(), cmp1);
    for(int i=0;i<vc.size();i++) vc[i].x=i;
    cdq(0, n-1);
    for(int i=1;i<=n;i++) if(ans[i]) cout<<ans[i]<<'\n';
}
```

---

## 作者：E1_de5truct0r (赞：3)

## 思路

看到“子树”，不难想到一个性质，那就是一个点的子树内，假设这个点 $dfn$ 序为 $dfn_u$，子树大小为 $sze_u$，则这个子树内所有的点位于 $[dfn_u+1,dfn_u+sze_u-1]$ 之间。

假设 $r_i,b_i$ 表示 $\text{Red}_i$ 和 $\text{Blue}_i$。

于是问题转化为，给定 $n$ 个点，求所有点对 $(i,j)$ 满足 $dfn_i<dfn_j<dfn_i+sze_i$ 且 $r_i\leq r_j$ 且 $b_i\leq b_j$ 的数量。

显然这是一个裸的三维区间偏序问题。建议按 $r$ 或者 $d$ 排序，然后 cdq 一下，转化成二位区间偏序，再上一个树状数组或者线段树维护就行了。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

// 此处为了美观，省略 114514 行缺省源。

using namespace std;
const int MAXN=200005;

int n,tot=0;
vector<int> E[MAXN];

struct Node{int dfn,sze,r,b,id;}a[MAXN];
inline bool cmp1(const Node &a,const Node &b){
	if(a.r!=b.r) return a.r<b.r;
	if(a.b!=b.b) return a.b<b.b;
	if(a.dfn+a.sze!=b.dfn+b.sze) return a.dfn+a.sze<b.dfn+b.sze; // 如果子树结尾的更大则排在前面
	return a.dfn>b.dfn; // 实在不行按子树大小排
}
inline bool cmp2(const Node &a,const Node &b){
	if(a.b!=b.b) return a.b<b.b;
	return a.dfn+a.sze<b.dfn+b.sze;
}

void dfs(int u,int fa){
	a[u].dfn=++tot,a[u].sze=1;
	for(int v:E[u])	if(v!=fa) dfs(v,u),a[u].sze+=a[v].sze; // 求 dfn 序，以及算子树大小 
}

int tr[MAXN<<2]; // 线段树维护单点+1、区间求和 
void upd(int p,int l,int r,int t,int k){
	if(l==r) return tr[p]+=k,void();
	int mid=(l+r)>>1;
	if(t<=mid) upd(p<<1,l,mid,t,k);
	else upd(p<<1|1,mid+1,r,t,k);
	tr[p]=tr[p<<1]+tr[p<<1|1];
}
int query(int p,int l,int r,int st,int en){
	if(l>en || r<st) return 0;
	if(st<=l && r<=en) return tr[p];
	int mid=(l+r)>>1;
	return query(p<<1,l,mid,st,en)+query(p<<1|1,mid+1,r,st,en);
}

int ans[MAXN];
void cdq(int l,int r){ // cdq 分治 
	if(l==r) return;
	int mid=(l+r)>>1;
	cdq(l,mid),cdq(mid+1,r); // 先递归左右两边 
	sort(a+l,a+mid+1,cmp2); // 排序 
	sort(a+mid+1,a+r+1,cmp2);
	int i=l;
	for(int j=mid+1;j<=r;j++){ // 双指针算贡献 
		while(i<=mid && a[i].b<=a[j].b) upd(1,1,n,a[i].dfn,1),i++; // 插入 dfn 的位置 
		ans[a[j].id]+=query(1,1,n,a[j].dfn+1,a[j].dfn+a[j].sze-1); // 查询子树内满足条件的数量 
	}
	for(int j=l;j<i;j++) upd(1,1,n,a[j].dfn,-1); // 清空线段树 
}

signed main(){
	read(n);
	for(int i=1;i<n;i++){
		int u,v; read(u,v);
		E[u].push_back(v);
		E[v].push_back(u); 
	}
	dfs(1,0); // 预处理 
	for(int i=1;i<=n;i++) read(a[i].r,a[i].b),a[i].id=i;
	sort(a+1,a+1+n,cmp1); // 按照 r,b,dfn 排序
	
	cdq(1,n); // cdq 分治 
	for(int i=1;i<=n;i++)
		if(ans[i]!=0) write(ans[i]); // 输出 
	return flush(),0;
}
```

常数有点大，不开 O2 会 T 飞掉。建议各位写树状数组。qwq

---

## 作者：freoepn (赞：2)

首先考虑用 dfs 序把这个树的限制拍到序列上，则对于点  $x$ 来说，点 $y$ 如果满足满足 $a_y \leq a_x $ 和 $b_y \leq b_x$ 和 $dfn_x < dfn_y < dfn_x + siz_x$，就能对 $x$ 的答案产生贡献，这是一个经典的的三位偏序问题，可以用 cdq 分治解决，区间的限制插入两个不同 $dfn$ 的相同点即可，注意排序时遇到 $a,b$ 相同要考虑 $dfn$ 大小。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int kMaxN = 5e5 + 5;
struct node {
  int x, y, z, v, e, id;
} a[kMaxN];
int n, m;
bool vis[kMaxN];
int c[kMaxN];
int lowbit(int x) {
  return x & (-x);
}
void updata(int i, int k) {
  while (i <= n) {
    c[i] += k;
    i += lowbit(i);
  }
}
int getsum(int i) {
  long long ans = 0;
  while (i) {
    ans += c[i];
    i -= lowbit(i);
  }
  return ans;
}
bool cmp(node i, node j) {
  return i.y != j.y ? i.y < j.y : (i.z != j.z ? i.z > j.z : i.v < j.v);
}
bool CMP(node i, node j) {
  return i.x != j.x ? i.x < j.x : (i.y != j.y ? i.y < j.y : i.z > j.z);
}
long long ans[kMaxN];
void cdq(int l, int r) {
  if (l == r) {
    return;
  }
  int mid = (l + r) >> 1;
  cdq(l, mid), cdq(mid + 1, r);
  int p = l;
  for (int i = mid + 1; i <= r; i++) {
    while (p <= mid && a[i].y >= a[p].y) {
      updata(a[p].z, a[p].e);
      p++;
    }
    ans[a[i].id] += a[i].v * (long long)(getsum(n) - getsum(a[i].z - 1));
  }
  for (int i = l; i < p; i++) {
    updata(a[i].z, -a[i].e);
  }
  stable_sort(a + l, a + r + 1, cmp);
}
vector<int> v[kMaxN];
int p[kMaxN], siz[kMaxN];
int tot;
void dfs(int x, int y) {
  p[x] = ++tot;
  siz[x] = 1;
  for (int i = 0; i < v[x].size(); i++) {
    if (v[x][i] != y) {
      dfs(v[x][i], x);
      siz[x] += siz[v[x][i]];
    }
  }
}
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n;
  for (int i = 1; i < n; i++) {
    int x, y;
    cin >> x >> y;
    v[x].push_back(y);
    v[y].push_back(x);
  }
  dfs(1, 0);
  for (int i = 1; i <= n; i++) {
    cin >> a[i].x >> a[i].y;
  }
  int e = n;
  for (int i = 1; i <= e; i++) {
    a[i].z = p[i], a[i].v = 1, a[i].e = 1, a[i].id = i;
    a[++n].x = a[i].x, a[n].y = a[i].y, a[n].z = p[i] + siz[i], a[n].v = -1, a[n].e = 0, a[n].id = i;
  }
  stable_sort(a + 1, a + 1 + n, CMP);
  cdq(1, n);
  for (int i = 1; i <= n; i++) {
    if (ans[i]) cout << ans[i] << '\n';
  }
  return 0;
}
```

---

## 作者：Wilderness_ (赞：1)

### 思路
题目给定一棵树，要求每个点 $i$ 子树内满足两种星亮度均小于 $i$ 的点 $j$ 的个数，即 $j\in son_i,\tt{Red_j\le Red_i},\tt{Blue_j\le Blue_i}$ 的 $j$ 的个数。

不难发现后两个条件形式类似于偏序形式，考虑把第一个条件转化为偏序形式。由于是一棵树，我们取 $dfs$ 序作为偏序条件，则第一个条件可以转化为 $\tt{dfs_i<dfs_j<dfs_i+size_i}$，其中 $\tt{size_i}$ 为点 $i$ 子树大小。

以 $\tt{Red_i}$、$\tt{Blue_i}$、$\tt{dfs_i}$ 分别作为三个维度进行三维偏序即可。

### Code:
这里使用树状数组套动态开点线段树解决，时间复杂度 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch<='9'&&ch>='0')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
inline void write(int x)
{
    if(x>9)write(x/10);
    putchar(x%10+48);
    return;
}
const int M=400004;
struct node{int to,nxt;}edge[M];
int n,K,tot,tim,len,syh[M],hd[M],ans[M],cnt[M],rt[M];
inline void addedge(int u,int v)
{
    edge[++tot].to=v;
    edge[tot].nxt=hd[u];
    hd[u]=tot;
    return;
}
struct point
{
    int id,x,y,z,sz;
    inline bool operator==(point b){return x==b.x&&y==b.y&&z==b.z;}
    inline bool operator<(point b)
    {
        if(x^b.x)return x<b.x;
        if(y^b.y)return y<b.y;
        return z>b.z;
    }
}p[M];
struct SegmentTree
{
    struct node
    {
        int val;
        node*lson,*rson;
        node(int val=0):val(val){lson=rson=nullptr;}
    };
    node*root;
    SegmentTree(){root=nullptr;}
    inline void modify(node*&rt,int l,int r,int pos,int val)
    {
        if(!rt)rt=new node();
        if(l==r)
        {
            rt->val+=val;
            return;
        }
        int mid=l+r>>1;
        if(pos<=mid)modify(rt->lson,l,mid,pos,val);
        else modify(rt->rson,mid+1,r,pos,val);
        rt->val=(rt->lson?rt->lson->val:0)+(rt->rson?rt->rson->val:0);
        return;
    }
    inline int query(node*rt,int l,int r,int posl,int posr)
    {
        if(!rt)return 0;
        if(posl==l&&posr==r)return rt->val;
        int mid=l+r>>1;
        if(posr<=mid)return query(rt->lson,l,mid,posl,posr);
        if(posl>mid)return query(rt->rson,mid+1,r,posl,posr);
        return query(rt->lson,l,mid,posl,mid)+query(rt->rson,mid+1,r,mid+1,posr);
    }
}tr[M<<1];
inline int lowbit(int x){return x&(-x);}
inline void Modify(int x,int y,int val)
{
    for(int i=x;i<=K;i+=lowbit(i))tr[i].modify(tr[i].root,1,K,y,val);
    return;
}
inline int Query(int x,int y)
{
    int res=0;
    for(int i=x;i;i-=lowbit(i))res+=tr[i].query(tr[i].root,1,K,1,y);
    return res;
}
inline void dfs(int pos,int fa)
{
	p[pos].z=++tim,p[pos].sz=1;
	for(int i=hd[pos];i;i=edge[i].nxt)
	{
        int to=edge[i].to;
		if(to==fa)continue;
		dfs(to,pos);
		p[pos].sz+=p[to].sz;
	}
    return;
}
int main()
{
    K=n=read();
    for(int i=1;i<n;++i)
    {
        int u=read(),v=read();
        addedge(u,v);
        addedge(v,u);
    }
    for(int i=1;i<=n;++i)
    {
        p[i].id=i,p[i].x=read(),p[i].y=read();
        syh[++len]=p[i].y;
    }
    sort(syh+1,syh+len+1);
    len=unique(syh+1,syh+len+1)-syh-1;
    for(int i=1;i<=n;++i)p[i].y=lower_bound(syh+1,syh+len+1,p[i].y)-syh;
    dfs(1,0);
    sort(p+1,p+n+1);
    for(int i=1;i<=n;++i)
    {
        ans[p[i].id]+=Query(p[i].y,min(p[i].z+p[i].sz-1,n))-Query(p[i].y,p[i].z);
		Modify(p[i].y,p[i].z,1);
    }
	for(int i=1;i<=n;++i)if(ans[i])write(ans[i]),puts("");
    return 0;
}
```

---

## 作者：Charlie_ljk (赞：1)

乍一眼是个二维偏序，但发现要处理树上问题。

树上问题可以通过 $dfn$ 转化为区间问题，为方便下文解释，这里称 $l_i=dfn_i,r_i=dfn_i+size_i$。

那么另其 $dfn$ 为第三维，一样的三维偏序做，树状数组查询区间 $[l_i,r_i]$ 的数量即可。

这道题卡排序，对于本题的三维偏序，$x$ 对 $y$ 产生贡献，需满足：

- $red_x\le red_y$；
- $blue_x\le blue_y$；
- $l_y\le l_x\le r_y$。

发现第三维和一般三维偏序不太一样，那么排序的时候也要按照这个顺序，这么排：

```cpp
bool cmp(aa a,aa b) 
{
	return a.a==b.a?(a.b==b.b?(a.r==b.r?a.l>b.l:a.r<b.r):a.b<b.b):a.a<b.a;
}
```

剩下的 cdq 直接跑就行了。

```cpp
#include<bits/stdc++.h>
#define ll long long 
#define endl '\n'
#define sort stable_sort
using namespace std;
const int N=2e5+10;
template<typename Tp> inline void read(Tp&x)
{
	x=0;register bool z=true;
	register char c=getchar();
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') z=0;
	for(;'0'<=c&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	x=(z?x:~x+1);
}
template<typename T,typename ...Tp> inline void read(T &x,Tp &...y){read(x);read(y...);}
template<typename Tp> inline void wt(Tp x)
{if(x>9)wt(x/10);putchar((x%10)+'0');}
template<typename Tp> inline void write(Tp x)
{if(x<0)putchar('-'),x=~x+1;wt(x);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y){write(x);putchar(' ');write(y...);}
int n,tot,ans[N],c[N];
vector<int>e[N];
struct aa {int a,b,l,r,id;}a[N],tmp[N];
bool cmp(aa a,aa b) 
{
	return a.a==b.a?(a.b==b.b?(a.r==b.r?a.l>b.l:a.r<b.r):a.b<b.b):a.a<b.a;
}
void dfs(int x,int fa)
{
	a[x].l=++tot; a[x].id=x;
	for(int y:e[x]) if(y!=fa) dfs(y,x);
	a[x].r=tot;
}
int lowbit(int x) {return x&-x;}
void add(int x,int d) {for(;x<=n;x+=lowbit(x)) c[x]+=d;}
int ask(int l,int r)
{
	int ans=0; l--;
	for(;r;r-=lowbit(r)) ans+=c[r];
	for(;l;l-=lowbit(l)) ans-=c[l];
	return ans;
}
void cdq(int l,int r)
{
	if(l==r) return ;
	int mid=(l+r)>>1,x=l,y=mid+1,tot=l;
	cdq(l,mid),cdq(mid+1,r);
	for(;y<=r;y++)
	{
		for(;a[x].b<=a[y].b&&x<=mid;x++)
		{
			add(a[x].l,1);
			tmp[tot++]=a[x];
		}
		ans[a[y].id]+=ask(a[y].l,a[y].r);
		tmp[tot++]=a[y];
	}
	for(int i=l;i<=x-1;i++) add(a[i].l,-1);
	for(;x<=mid;x++) tmp[tot++]=a[x];
	for(int i=l;i<=r;i++) a[i]=tmp[i];
}
signed main()
{
	read(n);
	for(int i=1,x,y;i<=n-1;i++)
	{
		read(x,y);
		e[x].push_back(y),e[y].push_back(x);
	}
	dfs(1,0);
	for(int i=1,x,y;i<=n;i++) read(a[i].a,a[i].b);
	sort(a+1,a+1+n,cmp);
	cdq(1,n);
	for(int i=1;i<=n;i++) 
		if(ans[i]) write(ans[i]),puts("");
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

~~简单板子题……~~

发现如果将这题拍在序列上做，就是一个**三维偏序**板子，所以考虑将这棵树拍成一个序列，容易发现可以用 dfs 序进行维护。

定义 $dfn_i$ 表示 $i$ 点的 dfs 序编号，那么对于 $x$ 子树内（不包含）的点在 dfs 序 $[dfn_i+1,dfn_i+siz_i-1]$ 范围内。

那么可以得出有贡献的点对 $(u,v)$ 满足的关系式：

$$Red_v \le Red_u$$

$$Blue_v \le Blue_u$$

$$dfn_u < dfn_v < dfn_v+siz_v-1$$

则我们用 cdq 分治计算一下即可。

时间复杂度为 $O(N \log^2 N)$。

~~可恶，出题人竟然卡树套树……~~

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&(-x)
using namespace std;
typedef double db;
const int N=200200;
inline int read(){
    register int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(register int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int n,sum;
int l[N],r[N],siz[N],ans[N];
vector<int> E[N];
void add(int u,int v){
	E[u].push_back(v);
	E[v].push_back(u);
}
struct Node{
	int a,b,l,r,id;
	inline bool operator<(const Node&rhs)const{
	    if(a!=rhs.a)
		  return a<rhs.a;
	    if(b!=rhs.b)
		  return b<rhs.b;
	    return l>rhs.l;
	}
}A[N];
bool cmp(const Node&a,const Node&b){
	if(a.b!=b.b)
	  return a.b<b.b;
	return a.l>b.l;
}
class BIT{
public:
	int a[N];
	inline void add(register int x,register int v){
		for(register int i=x;i<=n;i+=lowbit(i))
		  a[i]+=v;
	}
	inline int qurey(register int x){
	    int ans=0;
	    for(int i=x;i;i-=lowbit(i))
	      ans+=a[i];
	    return ans;
	}
}T;
void dfs(int u,int fa){
	l[u]=++sum;
	for(auto v:E[u]){
		if(v==fa)
		  continue;
		dfs(v,u);
	}
	r[u]=sum;
}
void cdq(int l,int r){
	if(l==r)
	  return ;
	int mid=(l+r)>>1;
	cdq(l,mid);
	cdq(mid+1,r);
	sort(A+l,A+mid+1,cmp);
	sort(A+mid+1,A+r+1,cmp);
	int i=l,j=mid+1;
	for(;j<=r;j++){
		while(i<=mid&&A[i].b<=A[j].b){
			T.add(A[i].l,1);
			i++;
		}
		ans[A[j].id]+=T.qurey(A[j].r)-T.qurey(A[j].l-1);
	}
	for(int j=l;j<i;++j)
	  T.add(A[j].l,-1);
}
int main(){
	n=read();
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
	  A[i]={read(),read(),l[i],r[i],i};
	sort(A+1,A+n+1);
	cdq(1,n);
	for(int i=1;i<=n;i++){
		if(!ans[i])
		  continue;
		write(ans[i]);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：未来姚班zyl (赞：1)

## 题目大意
在一颗树上，每个节点有两个元素 $R_i$，$B_i$。对每个节点 $x$，求其字数内有多少个 $y$ 满足 $R_y\le R_x$，$B_y\le B_x$。

## 题目分析

显然的三维偏序，对树 dfs。

则对于一对 $(i,j)$。对 $j$ 产生贡献条件是：

$R_i\le R_j$，$B_i\le B_j$，$dfn_j<dfn_i\le dfn_j+siz_j-1$。

这时候有些同学就会问了：啊博主这不是四维偏序吗？

这时候有些厉害的同学就会答到：啊这最后两维放在树状数组上差分一下不就行了！

复杂度 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned long long
#define e(x) for(int i=h[x];i;i=nxt[i])
#define Pi pair<int,int>
#define ui unsigned int 
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =2e5+5,M=5e6+5,inf=2147000000;
const ll mod=998244353;
using namespace std;
int n=read(),h[N],to[N*2],nxt[N*2],ans[N],cnt,Time;
struct node{
	int id,a,b,dfn,siz;
}a[N];
inline void add(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
}
inline void dfs(int x,int fa){
	a[x].dfn=++Time,a[x].siz=1;
	e(x){
		int y=to[i];
		if(y^fa)dfs(y,x),a[x].siz+=a[y].siz;
	}
}
inline bool cmp(node a,node b){
	if(a.a^b.a)return a.a<b.a;
	if(a.b^b.b)return a.b<b.b;
	return a.dfn>b.dfn;
}
inline bool cpm(node a,node b){
	return a.b<b.b;
}
int t[N];
inline void ad(int x,int k){
	while(x<=n)t[x]+=k,x+=x&-x; 
}
inline int query(int x){
	int ans=0;
	while(x)ans+=t[x],x-=x&-x;
	return ans;
}
inline void cdq(int l,int r){
	if(l==r)return;
	cdq(l,mid),cdq(mid+1,r);
	sort(a+l,a+mid+1,cpm),sort(a+mid+1,a+r+1,cpm);
	int Ll=l;
	rep(Rr,mid+1,r){
		while(Ll<=mid&&a[Ll].b<=a[Rr].b)ad(a[Ll++].dfn,1);
		ans[a[Rr].id]+=query(a[Rr].dfn+a[Rr].siz-1)-query(a[Rr].dfn);
	}
	while(Ll>l)ad(a[--Ll].dfn,-1);
}
int main(){
	for(int i=1,x,y;i^n;i++)x=read(),y=read(),add(x,y),add(y,x);
	rep(i,1,n)a[i].a=read(),a[i].b=read(),a[i].id=i;
	dfs(1,0);
	sort(a+1,a+n+1,cmp);
	cdq(1,n);
	rep(i,1,n)if(ans[i])pf(ans[i]),putchar('\n');
	return 0;
}
```


---

## 作者：ollo (赞：1)

# 题目大意

给定一棵树，每个点都有一个 $Blue$ 和一个 $Red$ 权值，对于每个点，问它的子树内满足 $Red_y \leq Red_x$，$Blue_y \leq Blue_x$。

# 思路

我们发现 $Red_y \leq Red_x$，$Blue_y \leq Blue_x$ 满足二维偏序关系，易想到 CDQ 分治，此时只剩下子树内这个要求，由于我们要凑出三维偏序关系，不难想到把树拍扁成 DFS 序，记下每个点在 DFS 中第一二次出现的位置，则子树内转化为 $dfn_{x1} \leq dfn_{y1} \leq dfn_{x2}$，直接 CDQ 即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x & (-x)

using namespace std;

const int N = 2e5 + 10;

struct S{
	int a, b, c1, c2, id;
}s1[N], s2[N];
int tot, n, m, ans[N], win[N];

bool cmp1(S u, S v){
	if(u.a != v.a) return u.a < v.a;
	if(u.b != v.b) return u.b < v.b;
	if(u.c1 != v.c1) return u.c1 > v.c1;
}

int tr[N];
void add(int x, int w){
	for(; x <= tot; x += lowbit(x)) tr[x] += w;
}

int query(int x){
	int num = 0;
	for(; x > 0; x -= lowbit(x)) num += tr[x];
	return num;
}

void CDQ(int L, int R){
	if(L >= R) return ;
	int mid = L + R >> 1;
	CDQ(L, mid);CDQ(mid + 1, R);
	int l = L, r = mid + 1, len = L - 1;
	while(l <= mid && r <= R){
		if(s1[r].b >= s1[l].b){
			add(s1[l].c1, 1);
			s2[++len] = s1[l];
			l++;
		}
		else{
			ans[s1[r].c1] += query(s1[r].c2) - query(s1[r].c1);
			s2[++len] = s1[r];
			r++;
		}
	}
	while(l <= mid){add(s1[l].c1, 1);s2[++len] = s1[l];l++;}
	while(r <= R){ans[s1[r].c1] += query(s1[r].c2) - query(s1[r].c1);s2[++len] = s1[r];r++;}
	for(int i = L; i <= mid; i++){
		add(s1[i].c1, -1);
	}
	for(int i = L; i <= R; i++) s1[i] = s2[i];
}

vector<int> g[N];
int dfn[N];

void dfs(int x, int f){
	s1[x].c1 = ++tot;dfn[tot] = x;
	for(auto y : g[x]){
		if(y == f) continue;
		dfs(y, x);
//		s1[x].sz += s1[y].sz;
	}
	s1[x].c2 = tot;
}

int main(){
	cin >> n;
	for(int x, y, i = 1; i < n; i++){
		cin >> x >> y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	for(int i = 1; i <= n; i++){
		cin >> s1[i].a >> s1[i].b;
        s1[i].id = i;
	}
	dfs(1, 0);
	sort(s1 + 1, s1 + n + 1, cmp1);
	CDQ(1, tot);
	for(int i = 1; i <= n; i++){
		win[dfn[s1[i].c1]] = ans[s1[i].c1];
	}
	for(int i = 1; i <= n; i++) if(win[i]) cout << win[i] << '\n';
	return 0;
}
```

---

## 作者：xuyuansu (赞：1)

## 题意
给你一个树，每个点上有两个点权 $ a_i $ 和 $ b_i $，要求每个点的子树内有多少个点 $ j $ 满足 $ a_i<a_j $ 且 $ b_i<b_j $。
## 题解
第一眼看出这是一个偏序类问题，但是这个树怎么处理让我思考了一下，发现其实很简单，只要拍扁成 dfs 序就可以转换成序列问题，然后按 dfs 序为第三维，把每个点的询问拆开，给定正负号就是三维偏序板子，不再赘述。

这里要特殊注意一个点，一定要保证询问和修改的先后，在手写归并时的大小比较也要注意特判这一点，不然可能会和我一样样例输出一直是 5 2 2 1 调不出来。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,dfn[N],tr[N],h[N],sum,cnt,ans[N],num,siz[N];
struct node
{
    int x,y,z,opt,id;
}q[N*3],w[N*3];
vector<int> g[N];
void dfs(int x,int fa)
{
    dfn[x]=++num;siz[x]=1;
    for(int y : g[x])
    {
        if(y==fa) continue;
        dfs(y,x);
        siz[x]+=siz[y];
    }
}
bool cmp(node i,node j)
{
    if(i.z!=j.z) return i.z<j.z;
    return abs(i.opt)<abs(j.opt);
}
void add(int x,int y)
{
    for(int i=x;i<=sum;i+=(i&(-i))) tr[i]+=y;
}
int query(int x)
{
    int res=0;
    for(int i=x;i;i-=(i&(-i))) res+=tr[i];
    return res;
}
void merge_sort(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)>>1;
    merge_sort(l,mid);merge_sort(mid+1,r);
    int i=l,j=mid+1,cnt=l-1;
    while(i<=mid && j<=r)
    {//一定要注意先后顺序
        if(q[i].x<q[j].x || (q[i].x==q[j].x && abs(q[i].opt)<abs(q[j].opt)))
        {
            if(q[i].opt==0) add(q[i].y,1);
            w[++cnt]=q[i];i++;
        }
        else{
            if(q[j].opt)
            {
                ans[q[j].id]+=q[j].opt*query(q[j].y);
            }
            w[++cnt]=q[j];j++;
        }
    }
    while(i<=mid)
    {
        if(q[i].opt==0) add(q[i].y,1);
        w[++cnt]=q[i];i++;
    }
    while(j<=r)
    {
        if(q[j].opt)
        {
            ans[q[j].id]+=q[j].opt*query(q[j].y);
        }
        w[++cnt]=q[j];j++;
    }
    for(int i=l;i<=mid;i++) if(q[i].opt==0) add(q[i].y,-1);
    for(int i=l;i<=r;i++) q[i]=w[i];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        int x,y;scanf("%d%d",&x,&y);
        g[x].push_back(y);g[y].push_back(x);
    }
    dfs(1,0);
    for(int i=1;i<=n;i++)
    {
        int x,y;scanf("%d%d",&x,&y);
        q[++cnt]={x,y,dfn[i],-1,i};
        q[++cnt]={x,y,dfn[i]+siz[i]-1,1,i};
        q[++cnt]={x,y,dfn[i],0,i};
        h[++sum]=y;
    }
    sort(h+1,h+sum+1);sum=unique(h+1,h+sum+1)-h-1;
    for(int i=1;i<=cnt;i++) q[i].y=lower_bound(h+1,h+sum+1,q[i].y)-h;
    sort(q+1,q+cnt+1,cmp);
    merge_sort(1,cnt);
    for(int i=1;i<=n;i++)
        if(ans[i]) printf("%d\n",ans[i]);
    return 0;
}
```


---

## 作者：eastcloud (赞：1)

### 题目分析

看到题目，发现题中有三个约束条件，分别是蓝色红色和节点必须在子树内，对于前两种情况可以使用二维偏序处理，我们关注子树的情况。

由于前两个与偏序问题有关，我们考虑对第三种情况进行转化，由树链剖分的子树内节点连续想到可以用 dfs 序转化节点编号，并且最后修改树状数组查询的步骤即可。

转换后问题变为三维偏序，修改一下累计答案的部分使用 cdq 分治即可。

~~总体上是个比较板的三维偏序，考前可以练练手~~

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<queue>
#define eps 0.00001
using namespace std;
struct Node{
	int r,b,dfn,sz;
}id[1000001];
bool cmp(Node x,Node y){
	if(x.r!=y.r)return x.r<y.r;
	else if(x.b!=y.b) return x.b<y.b;
	else return x.dfn>y.dfn;
}
int ba[1000001];
int a[1000001];
int ans[1000001];
int fin[1000001];
vector<int> l[1000001];
int tot;
int lowbit(int x){
	return x&(-x);
}
void add(int x,int val){
	while(x<=tot){
		a[x]+=val;
		x+=lowbit(x);
	}
}
int query(int x){
	int ans=0;
	while(x){
		ans+=a[x];
		x-=lowbit(x);
	}
	return ans;
}
void dfs(int x,int fa){
	id[x].dfn=++tot;
	id[x].sz=1;
	ba[id[x].dfn]=x;
	for(int i=0;i<l[x].size();i++){
		int v=l[x][i];
		if(v==fa) continue;
		dfs(v,x);
		id[x].sz+=id[v].sz;
	}
}
Node tmp[1000001];
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)>>1;
	cdq(l,mid);cdq(mid+1,r);
	int i=l,j=mid+1,len=l-1;
	while(i<=mid && j<=r){
		if(id[i].b<=id[j].b){
			add(id[i].dfn,1);
			tmp[++len]=id[i];
			i++;
		}
		else{
			ans[id[j].dfn]+=query(id[j].dfn+id[j].sz-1)-query(id[j].dfn);
			tmp[++len]=id[j];
			j++;
		}
	}
	while(i<=mid){
		add(id[i].dfn,1);
		tmp[++len]=id[i];
		i++;
	}
	while(j<=r){
		ans[id[j].dfn]+=query(id[j].dfn+id[j].sz-1)-query(id[j].dfn);
		tmp[++len]=id[j];
		j++;
	}
	for(int k=l;k<=mid;k++) add(id[k].dfn,-1);
	for(int k=l;k<=r;k++) id[k]=tmp[k];
}
int main(){
	int n,u,v;
	cin>>n;
	for(int i=1;i<n;i++){
		cin>>u>>v;
		l[u].push_back(v);
		l[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)cin>>id[i].r>>id[i].b;	
	sort(id+1,id+n+1,cmp);
	cdq(1,tot);
	for(int i=1;i<=n;i++)fin[ba[id[i].dfn]]=ans[id[i].dfn];
	for(int i=1;i<=n;i++){
		if(fin[i])cout<<fin[i]<<endl;
	}
	return 0;
}
```


---

## 作者：Istruggle (赞：0)

题目上很明显已经给出了三对偏序关系：

- $red_v \le red_u$
- $blue_v \le blue_u$
- $v$ 在 $u$ 的子树上

前两个条件都很好满足，对于第三个条件我们可以想到 dfs 序，若用 $size_u$ 表示节点 $u$ 的子树大小，如果满足 $dfn_u+size_u > dfn_v > dfn_u$ 就说明 $v$ 在 $u$ 的子树上，然后直接进行 CDQ 分治即可。

### AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,head[N],cnt,dfn[N],num,c[N],siz[N];
void add(int x,int y){for(;x<=n;x+=x&-x) c[x]+=y;}
int ask(int x){int y=0; for(;x;x-=x&-x) y+=c[x]; return y;}
struct edge{
	int v,next;
}e[N<<1];
void addedge(int u,int v){
	e[++cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void dfs(int u,int fa){
	dfn[u]=++num; siz[u]=1;
	for(int i = head[u];i;i=e[i].next){
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
	}
}
struct star{
	int r,b,id,dfn;
}a[N];
bool cmpr(star x,star y){
	if(x.r==y.r){
		if(x.b==y.b) return x.dfn>y.dfn;
		return x.b<y.b;
	}
	return x.r<y.r;
}
int ans[N];
bool cmpb(star x,star y){
	if(x.b==y.b) return x.dfn>y.dfn;
	return x.b<y.b;
}
void solve(int l,int r){
	if(l==r) return;
	int mid=(l+r)>>1;
	int i = l,j=mid+1;
	solve(l,mid); solve(mid+1,r);
	sort(a+l,a+mid+1,cmpb);
	sort(a+mid+1,a+r+1,cmpb);
	while(j<=r){
		while(a[i].b<=a[j].b&&i<=mid){
			add(a[i].dfn,1); i++;
		}
		ans[a[j].id]+=ask(a[j].dfn+siz[a[j].id]-1)-ask(a[j].dfn);
		j++;
	}
	for(int j = l;j<i;j++)
	add(a[j].dfn,-1);
} 
int main(){
	scanf("%d",&n);
	for(int i = 1;i<n;i++){
		int u,v; scanf("%d%d",&u,&v);
		addedge(u,v); addedge(v,u);
	}
	for(int i = 1;i<=n;i++)
	scanf("%d%d",&a[i].r,&a[i].b);
	dfs(1,0);
	for(int i = 1;i<=n;i++) a[i].id=i,a[i].dfn=dfn[i];
	sort(a+1,a+1+n,cmpr);
	solve(1,n);
	for(int i = 1;i<=n;i++)
	if(ans[i])
	printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8575)

# 前置知识

[CDQ 分治](https://oi-wiki.org/misc/cdq-divide/) | [权值树状数组及应用](https://oi-wiki.org/ds/fenwick/#%E6%9D%83%E5%80%BC%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8F%8A%E5%BA%94%E7%94%A8)

# 解法

增加一维为 DFS 序，然后就转化成了三维偏序问题，可以使用 CDQ 分治求解。

此时等价于求 $red_{j} \le red_{i},blue_{j} \le blue_{i},dfn_{i}<dfn_{j} \le out_{i}$ 的 $j$ 的数量。第三个限制条件前缀和维护即可。

注意按 DFS 序排序时，为保证子树内部节点能更新到根节点，需要降序排序。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
struct node
{
	int a,b,dfn,out,id;
}a[200010];
int ans[200010],tot=0;
vector<int>e[200010];
bool cmpb(node a,node b)
{
	return (a.b==b.b)?(a.dfn>b.dfn):(a.b<b.b);
}
bool cmpa(node a,node b)
{
	return (a.a==b.a)?cmpb(a,b):(a.a<b.a);
}
void add(int u,int v)
{
	e[u].push_back(v);
}
void dfs(int x,int fa)
{
	tot++;
	a[x].dfn=tot;
	for(int i=0;i<e[x].size();i++)
	{
		if(e[x][i]!=fa)
		{
			dfs(e[x][i],x);
		}
	}
	a[x].out=tot;
}
struct BIT
{
	int dfn[200010];
	int lowbit(int x)
	{
		return (x&(-x));
	}
	void add(int n,int x,int val)
	{
		for(int i=x;i<=n;i+=lowbit(i))
		{
			dfn[i]+=val;
		}
	}
	int getsum(int x)
	{
		int ans=0;
		for(int i=x;i>=1;i-=lowbit(i))
		{
			ans+=dfn[i];
		}
		return ans;
	}
}T;
void cdq(int l,int r,int k)
{
	if(l==r)
	{
		return;
	}
	int mid=(l+r)/2,x,y;
	cdq(l,mid,k);
	cdq(mid+1,r,k);
	sort(a+l,a+mid+1,cmpb);
	sort(a+mid+1,a+r+1,cmpb);
	for(x=l,y=mid+1;y<=r;y++)
	{
		for(;a[x].b<=a[y].b&&x<=mid;x++)
		{
			T.add(k,a[x].dfn,1);
		}
		ans[a[y].id]+=T.getsum(a[y].out)-T.getsum(a[y].dfn);
	}
	x--;
	for(int i=l;i<=x;i++)
	{
		T.add(k,a[i].dfn,-1);
	}
}
int main()
{
	int n,u,v,i;
	cin>>n;
	for(i=1;i<=n-1;i++)
	{
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	for(i=1;i<=n;i++)
	{
		cin>>a[i].a>>a[i].b;
		a[i].id=i;
	}
	sort(a+1,a+1+n,cmpa);
	cdq(1,n,n);
	for(i=1;i<=n;i++)
	{
		if(ans[i]!=0)
		{
			cout<<ans[i]<<endl;
		}
	}
	return 0;
}	
```

---

## 作者：DengDuck (赞：0)

看到求子树内满足条件的节点数，立刻想到利用 DFS 序转成数组。

那么式子可以看成：

$$
\begin{aligned}
R_j&\leq R_i\\
B_j&\leq B_i\\
Dfn_i<Dfn_j&\leq Dfn_i+Sz_i-1
\end{aligned}
$$

那这个就是一个很显然的三维偏序。

注意到第三维是一个区间，这个要求我们维护区间和（大部分三维偏序是前缀和），实现上前缀和作差一下就行。

时间复杂度为 $\mathcal O(n\log ^2n)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LF long double
#define pLL pair<LL,LL>
#define pb push_back
//#define Fi first
//#define Se second
//#define Ls(x) (x<<1)
//#define Rs(x) (x<<1|1)
//#define Ls(x) t[x].Lson
//#define Rs(x) t[x].Rson
using namespace std;
//const LL Inf;
const LL N=2e5+10;
//const LL M;
//const LL Mod;
//const LF eps;
//const LL P;
LL n,Ans[N];
vector<LL>G[N];
struct Nd
{
	LL A,B,L,R,id;
}A[N];
struct BIT
{
	LL t[N];
	LL LB(LL x){return x&-x;};
	LL Qry(LL x)
	{
		LL Ans=0;
		
		for(int i=x;i;i-=LB(i))Ans+=t[i];
		return Ans;
	}
	void Upd(LL x,LL k)
	{
	//	cout<<x<<endl;
		for(int i=x;i<=n;i+=LB(i))t[i]+=k;
	}
}T;
LL tot;
void Dfs(LL x,LL f)
{
	A[x].L=++tot;
	for(LL i:G[x])
	{
		if(i==f)continue;
		Dfs(i,x);
	}
	A[x].R=tot;
}
void CDQ(LL L,LL R)
{
	if(L>=R)return;
	LL Mid=L+R>>1;
	CDQ(L,Mid),CDQ(Mid+1,R);
	sort(A+L,A+Mid+1,[](Nd x,Nd y)
		{
			if(x.B!=y.B)return x.B<y.B;
			return x.L>y.L;
		});
	sort(A+Mid+1,A+R+1,[](Nd x,Nd y)
		{
			if(x.B!=y.B)return x.B<y.B;
			return x.L>y.L;
		});
	LL t=L;
	for(int i=Mid+1;i<=R;i++)
	{
		while(t<=Mid&&A[t].B<=A[i].B)T.Upd(A[t].L,1),t++;
		Ans[A[i].id]+=T.Qry(A[i].R)-T.Qry(A[i].L);
	}
	for(int i=L;i<t;i++)T.Upd(A[i].L,-1);
}
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)A[i].id=i;
	for(int i=1;i<n;i++)
	{
		LL x,y;
		scanf("%lld%lld",&x,&y);
		G[x].pb(y),G[y].pb(x);
	}
	for(int i=1;i<=n;i++)scanf("%lld%lld",&A[i].A,&A[i].B);
	Dfs(1,0);
	sort(A+1,A+n+1,[](Nd x,Nd y)
		{
			if(x.A!=y.A)return x.A<y.A;
			if(x.B!=y.B)return x.B<y.B;
			return x.L>y.L;
		});
	CDQ(1,n);
	for(int i=1;i<=n;i++)if(Ans[i])printf("%lld\n",Ans[i]);
	return 0;
}
//RP++
```

---

## 作者：LEE114514 (赞：0)

## 思路

首先，子树条件可以通过 $dfn$ 限制转化变成大小关系，然后我们就要对与每一个点 $x$ 统计满足以下条件的点 $y$ 的个数。

$$
\begin{cases}
r_y \le r_x \\
b_y \le b_x \\
dfn_x \le dfn_y \\
dfn_y \le dfn2_x
\end{cases}
$$

其中 $r,b$ 分别红星亮度，蓝星亮度，$dfn,dfn2$ 分别表示自身 dfs 序和子树中最大的 dfs 序。

由于四个条件，这看起来是一个“四维偏序”，然而我们发现有两个条件限制了同一个变量 $dfn_y$，而且把它限制在一个区间内，因此我们考虑用一个支持值域上区间查询的数据结构维护它。由于它的值域为 $[1,n]$，所以我们使用树状数组比较方便。

到这里，我们的思路已经比较明确，按照 $r$ 排序，用 cdq 分治解决掉 $b$ 和 $dfn$，其中 $dfn$ 用树状数组维护。

**注意**，在按照前两个关键字排序后，还要按照 $dfn$ 排序，让 $dfn$ 较小的节点排到后面，为了让子树内节点先被处理。

## Code

为了方便理解调试，使用了 `std::inplace_merge` 实现归并排序，因此复杂度为 $O(n \log^2n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,u,v;
const int maxn=2e5+5;
vector<int> G[maxn];
int tot;
struct node{
	int r,b,id,dfn,dfn2;
	inline bool operator<(const node &tmp) const {
		return (r^tmp.r)?(r<tmp.r):((b^tmp.b)?b<tmp.b:dfn>tmp.dfn);
	}
}p[maxn];
int ans[maxn];
void dfs(int u,int fa){
	p[u].dfn=++tot;
	for(int v:G[u]) if(v^fa) dfs(v,u);
	p[u].dfn2=tot;
}
int trr[maxn];
void upd(int p,int x){
	while(p<=n) trr[p]+=x,p+=(p&-p);
}
int qry(int p){
	int res=0;
	while(p) res+=trr[p],p^=(p&-p);
	return res;
}
inline bool cmp(const node &a,const node &b){
	return a.b^b.b?a.b<b.b:a.dfn>b.dfn;
}
void cdq(int l,int r){
	if(l>=r) return;
	int mid=(l+r)>>1;
	cdq(l,mid);
	cdq(mid+1,r);
	int p1,p2;
	for(p1=l,p2=mid+1;p2<=r;++p2){
		while(p1<=mid&&p[p1].b<=p[p2].b) upd(p[p1].dfn,1),++p1;
		ans[p[p2].id]+=qry(p[p2].dfn2)-qry(p[p2].dfn-1); 
	}
	while(--p1>=l) upd(p[p1].dfn,-1);
	inplace_merge(p+l,p+mid+1,p+r+1,cmp);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;++i){
		scanf("%d%d",&u,&v);
		G[u].emplace_back(v);
		G[v].emplace_back(u);
	}
	for(int i=1;i<=n;++i) scanf("%d%d",&p[i].r,&p[i].b),p[i].id=i;
	dfs(1,0);
	sort(p+1,p+n+1);
	cdq(1,n);
	for(int i=1;i<=n;++i) ans[i]&&printf("%d\n",ans[i]);
}
```

---

## 作者：complete_binary_tree (赞：0)

> 星稀河影转，霜重月华孤。——宋·张孝祥

[原题传送门](https://www.luogu.com.cn/problem/P8575)

一道二维偏序，但是在树上。如果是序列，那么就可以直接用用 $\text{cdq}$ 分治。那么我们考虑将树转化为一个序列。

我们可以存储 $\text{dfs}$ 序和每个节点（包含它本身）子树的大小。那么这个问题就可以转化为这样的三维偏序：

1. $\text{Red}_i\le\text{Red}_j$

2. $\text{Blue}_i\le\text{Blue}_j$

3. $\text{dfn}_j<\text{dfn}_i<\text{dfn}_j+\text{size}_j$

其中，$\text{dfn}$ 表示的是 $\text{dfs}$ 序，$\text{size}$ 表示的是子树大小。**特别注意 $\text{dfn}_i$ 不能等于 $\text{dfn}_j+\text{size}_j$，因为 $\text{size}_j$ 算上了 $j$ 这个节点，等于的话会重复算**。

然后我们跑一遍 $\text{dfs}$，求出 $\text{dfn}$ 和 $\text{size}$，再跑一遍 $\text{cdq}$ 分治，像三维偏序一样使用树状数组存 $\text{dfn}$、更新答案即可。时间复杂度 $O(n\log^2n)$。

**特别提醒：**

如果您 $80\text{pts/WA on subtask\#2,subtask\#5}$，您需要考虑 $\text{cmp}$ 的写法。例如我 $\text{cdq}$ 统计的是 **前半段对后半段贡献**，那么我的 $\text{cmp}$ 应该：

```cpp
bool cmp(node x, node y){
  if(x.red == y.red){
    if(x.blue == y.blue){
      return x.dfn > y.dfn; //而不是 x.dfn < y.dfn
    }
    return x.blue < y.blue;
  }
  return x.red < y.red;
}
```

因为如果 $j$ 是 $i$ 的祖先（$i$ 在 $j$ 的子树内），那么 $\text{dfn}_j$ 一定大于 $\text{dfn}_i$，所以如果从小到大排序，那么祖先在前面，后代在后面，只算前面对后面的贡献就算不到 $i$ 对 $j$ 的贡献。

$\text{Code:}$
```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 2e5 + 5;

int n;

vector<int> e[N];

int red[N], blue[N], sz[N];

struct node{
	int re, bl, dfn, sz, id;
	ll ans;
} a[N];
int cnt;

struct treezu{
	ll t[N];
	void add(int pos, ll x){
		for(; pos <= n; pos += (pos & (-pos))) t[pos] += x;
	}
	ll find(int pos){
		ll ans = 0;
		for(; pos > 0; pos -= (pos & (-pos))) ans += t[pos];
		return ans;
	}
} t1; 

void dfs(int u, int fa){
	int L = e[u].size();
	int now = ++cnt;
	sz[u] = 1;
	a[now].re = red[u], a[now].bl = blue[u], a[now].dfn = now, a[now].id = u;
	for(int i = 0; i < L; ++i){
		int v = e[u][i];
		if(v == fa) continue;
		dfs(v, u);
		sz[u] += sz[v];
	}
	a[now].sz = sz[u];
	return ;
}

bool cmp1(node x, node y){
	return x.re == y.re? x.bl == y.bl? x.dfn > y.dfn: x.bl <= y.bl: x.re <= y.re;
}

bool cmp2(node x, node y){
	return x.bl == y.bl? x.dfn > y.dfn: x.bl <= y.bl;
}

bool cmp3(node x, node y){
	return x.id < y.id;
}

void cdq(int l, int r){
	if(l == r) return ;
	int mid = (l + r) >> 1;
	cdq(l, mid), cdq(mid + 1, r);
	sort(a + l, a + mid + 1, cmp2), sort(a + mid + 1, a + r + 1, cmp2);
	int i, j = l;
	for(i = mid + 1; i <= r; ++i){
		while(j <= mid && a[j].bl <= a[i].bl) t1.add(a[j++].dfn, 1);
		a[i].ans += t1.find(a[i].dfn + a[i].sz - 1) - t1.find(a[i].dfn);
	}
	for(int k = l; k < j; ++k) t1.add(a[k].dfn, -1);
	return ;
}

inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x*f;
}

inline void write(int x){
	if(x < 0){
		putchar('-');
		write(-x);
		return ;
	}
	if(x >= 10) write(x / 10);
	putchar(x % 10 + 48);
	return ;
}

int main(){
	n = read();
	for(int i = 2; i <= n; ++i){
		int u, v;
		u = read(), v = read();
		e[u].push_back(v), e[v].push_back(u);
	}
	for(int i = 1; i <= n; ++i){
		red[i] = read(), blue[i] = read();
	}
	dfs(1, -1);
	sort(a + 1, a + n + 1, cmp1);
	cdq(1, n);
	sort(a + 1, a + n + 1, cmp3);
	for(int i = 1; i <= n; ++i){
		if(a[i].ans) write(a[i].ans), puts("");
	}
	return 0;
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P8575)

裸的三维偏序。

首先看到题目就一眼丁真，鉴定为偏序，考虑 $\text{CDQ}$ 分治。

显然现在比二位偏序（$a_i\leq a_j,b_i\leq b_j$）多了一个条件：$i\in j\ subtree,i\neq j$。

联想到一个子树内的 $\text{dfs}$ 序是连续的，即以 $u$ 为根的子树所有节点的 $\text{dfs}$ 序在一定是 $dfn_u\sim dfn_{u}+siz_u-1$ 之中。

那要条件意味着 $dfn_j< dfn_i\leq dfn_j+siz_j-1$。

合并时只需要用树状数组维护一下就行了。

代码：

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n;
struct Edge{
	int nxt,to;
	Edge(int a=0,int b=0):nxt(a),to(b){}
};
struct Edge e[N<<1];
int head[N],tot;
inline void AddEdge(int x,int y){
	e[++tot]=Edge(head[x],y);head[x]=tot;
}
int dfn[N],cnt,siz[N];
void DFS(int u,int f){
	dfn[u]=++cnt;siz[u]=1;
	for(int i(head[u]);i;i=e[i].nxt){
		int v(e[i].to);
		if(v^f){
			DFS(v,u);
			siz[u]+=siz[v];
		}
	}
}
int red[N],blue[N],id[N],tmp[N];
inline bool cmp(int a,int b){
	if(red[a]^red[b]) return red[a]<red[b];
	if(blue[a]^blue[b]) return blue[a]<blue[b];
	return dfn[a]>dfn[b];
}
int c[N];
inline int lowbit(int x){return x&-x;}
inline void Add(int x,int v){
	while(x<=n){
		c[x]+=v;
		x+=lowbit(x);
	}
}
inline void Update(int x,int v){Add(dfn[x],v);}
inline int Sum(int x){
	int res(0);
	while(x){
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
inline int Query(int x){return Sum(dfn[x]+siz[x]-1)-Sum(dfn[x]);}
int ans[N];
void CDQ(int l,int r){
	if(l>=r) return;
	int mid(l+r>>1);
	CDQ(l,mid);CDQ(mid+1,r);
	int k(l),k1(l),k2(mid+1);
	while(k1<=mid&&k2<=r){
		if(blue[id[k1]]<=blue[id[k2]]){
			Update(id[k1],1);
			tmp[k++]=id[k1++];
		}
		else{
			ans[id[k2]]+=Query(id[k2]);
			tmp[k++]=id[k2++];
		}
	}
	while(k2<=r){
		ans[id[k2]]+=Query(id[k2]);
		tmp[k++]=id[k2++];
	}
	for(int i(l);i<k1;++i) Update(id[i],-1);
	while(k1<=mid) tmp[k++]=id[k1++];
	for(int i(l);i<=r;++i) id[i]=tmp[i];
}
int main(){
	scanf("%d",&n);
	for(int i(1);i<n;++i){
		int u,v;scanf("%d%d",&u,&v);
		AddEdge(u,v);AddEdge(v,u);
	}
	DFS(1,0);
	for(int i(1);i<=n;++i) scanf("%d%d",&red[i],&blue[i]);
	for(int i(1);i<=n;++i) id[i]=i;
	sort(id+1,id+1+n,cmp);CDQ(1,n);
	for(int i(1);i<=n;++i) if(ans[i]) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：irris (赞：0)

看到与子树相关的约束条件，想到用 dfs 序刻画，那么抽象为：

+ $f_i \lt f_j \lt l_j \lt l_i$
+ $r_j \leq r_i$
+ $b_j \leq b_i$

乍一看，这不是四维偏序吗？事实上，$f_i < f_j < l_j < l_i$ 可以简化为 $f_i < f_j < l_i$，因为 dfs 序构成的 **区间不存在相交不包含关系**。

于是这就好做了。对 $r_i$ 排序，$b_i$ 用一维 cdq 解决，目的在于让那个带两个偏序符号的条件用 BIT 统计，让代码简洁一点。但是这样可能出现等于号横跨 $mid$ 的情形，需要额外处理。

---

## 作者：_AyachiNene (赞：0)

# 思路：
如果一个点对 $(x,y)$ 对答案有贡献，那么要满足：一，$x$ 在 $y$ 的子树内；二，$red_x\leq red_y$；三，$blue_x\leq blue_y$。在子树内可以转化为 dfs 序的比较。dfs 序的判断有两维，看起来是四位偏序，但其实还是三维偏序，因为 dfs 序实际上只限制了在子树中的点的 dfs 序范围，所以直接就是三维偏序板子了。
# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+(c^48);c=getchar();}
	return res*f;
}
void write(int x)
{
	if(x<0){x=-x;putchar('-');}
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
int t[114514<<2];
inline int lowbit(int x)
{
	return x&-x;
}
inline void add(int x,int v)
{
	for(;x<=2e5;x+=lowbit(x))
		t[x]+=v;
}
inline int query(int x)
{
	int res=0;
	for(;x;x-=lowbit(x))
		res+=t[x];
	return res;
}
struct node
{
	int nxt,to;
}e[114514<<2];
int head[114514<<1],cnt_edge;
void add_edge(int u,int v)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
struct Elaina
{
	int a,b,c;
}q[114514<<2];
int dfn[114514<<1],cnt;
bool cmp1(Elaina x,Elaina y)
{
    if(x.a==y.a)
    {
    	if(x.b==y.b)
			return dfn[x.c]>dfn[y.c];
 		return x.b<y.b;
    }
    return x.a<y.a;
}
bool cmp2(Elaina x,Elaina y)
{
	if(x.b==y.b)
		return dfn[x.c]>dfn[y.c];
    return x.b<y.b;
}
int n,a[114514<<1],b[114514<<1];
int cnt_ls,bkt[114514<<2];
int ans[114514<<1];
int siz[114514<<1];
void dfs(int u,int fa)
{
	dfn[u]=++cnt;
	siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa)
			continue;
		dfs(v,u);
		siz[u]+=siz[v];
	}
}
void cdq_solve(int l,int r)
{
	if(l>=r)
		return;
	int mid=l+r>>1;
	cdq_solve(l,mid);
	cdq_solve(mid+1,r);
	sort(q+l,q+mid+1,cmp2);
	sort(q+mid+1,q+r+1,cmp2);
	int cur=l;
	for(int i=mid+1;i<=r;i++)
	{
		while(q[cur].b<=q[i].b&&cur<=mid)
		{
			add(dfn[q[cur].c],1);
			++cur; 
		}
		ans[q[i].c]+=query(dfn[q[i].c]+siz[q[i].c]-1)-query(dfn[q[i].c]);
	}
	for(int i=l;i<cur;i++)
		add(dfn[q[i].c],-1);
}
int main()
{
	n=read();
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	for(int i=1;i<=n;i++)
		a[i]=read(),b[i]=read(),bkt[++cnt_ls]=a[i],bkt[++cnt_ls]=b[i];
	sort(bkt+1,bkt+cnt_ls+1);
	int tot=unique(bkt+1,bkt+cnt_ls+1)-bkt-1;
	for(int i=1;i<=n;i++)
	{
		a[i]=lower_bound(bkt+1,bkt+tot+1,a[i])-bkt;
		b[i]=lower_bound(bkt+1,bkt+tot+1,b[i])-bkt;
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
		q[i].a=a[i],q[i].b=b[i],q[i].c=i;
	sort(q+1,q+n+1,cmp1);
	cdq_solve(1,n);
	for(int i=1;i<=n;i++)
		if(ans[i])
			write(ans[i]),puts("");
}
```

---


# [CCPC 2023 北京市赛] 最小环

## 题目描述

小 I 发明了 $O(n + m)$ 的有向图最小环，于是他想考考你。

给定一个 $n$ 个节点、$m$ 条边的有向图，每条边有正整数边权。你需要求出图上的一个环使得环上边的边权和最小。求出这个最小值，或者报告不存在环。

当然，由于你不会 $O(n + m)$ 的有向图最小环，于是小 I 放宽了条件：保证输入的图是弱连通的，且 $m-n$ 不会很大。一个图是弱连通的当且仅当将有向边换为无向边后图连通。

## 说明/提示

**【样例解释 1】**

最小环为 $1 \to 2 \to 4 \to 3 \to 1$。

**【样例解释 3】**

最小环为 $1 \to 1$。

## 样例 #1

### 输入

```
4 6
1 2 1
4 3 3
4 1 9
2 4 1
3 1 2
3 2 6```

### 输出

```
7```

## 样例 #2

### 输入

```
1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
1 1
1 1 1```

### 输出

```
1```

# 题解

## 作者：约瑟夫用脑玩 (赞：7)

首先是标解，由于太简明直白就放前面了。

入度为 0 或出度为 0 的点一定不会在环上，这样的点可以直接删掉，那么度数（入度加出度）至少为 2。

而当入度等于出度等于 1 时，可以把这个点和入度出度这两条边合成一条边，这样并不改变环的存在与长度。

这样可以保证度数至少为 3，一条边只贡献 2 的度数，由于点的度数可以比 3 大，最后得到的新图我们根据度数有不等式 $2m\ge 3n$。

上述操作始终不会改变 $m-n\le 1500$ 的事实（删点必定伴随删边，弱联通也是一个重要条件），解不等式组得到 $n\le 3000,m\le 4500$。

于是我们可以用传统的全源最短路+枚举边来找最小环，复杂度可以浅浅的做到 $O(nm\log m)$，此处 $n,m$ 均为新图，也就是上述不等式得到的点数边数。

------------

以下为我们队在此题下进行的讨论，没有标解这么直接，但也没标解这么跳跃，最后得到本质相同的办法，也算是正解。（更重要的是，这是考场思维，但我队友没打出来，这是可以说的吗

首先有向环一定处于强连通分量中，于是我们先跑个 tarjan 对每个强连通分量进行考察。

随意取一颗外向生成树，发现一些没用的性质，比如叶子必定有非树边使其强连通，非树边数 $k$ 同样有 $\le 1500$ 的条件。

但这些条件让我们感受到，点多叶子少，树边一定形成很多长链，于是我们考虑缩链，对于没有分叉也没有非树边的长链直接合成一条边，也就是由于非树边得到的一些点集，我们直接跑虚树，那么虚树边就自然进行了合并。

注意到非树边之和才为 1500，于是可以对每个强连通块的虚树（以及其非树边）跑全源最短路求最小环，$\sum$ 起来复杂度也是 3000 同级别的 $O(nm\log m)$ 可以接受。

------------

然后吐槽一下已有题解，第一篇思路大概和咱考场相同，但是边双确实不严谨，最后用线段树优化也不是很懂。虚树的思想差不多，但最后应该和标解一样走合并度为 2 的点的路子，但前面思路都一样应该是正解。

然后是第二篇：

> 实际上，这样的操作并不能保证图的规模是 $O(m-n)$。

属实难蚌了，“忘记缩入度为 0 出度为 1 的点”也很难蚌，好好的全源最短路，搞什么去重边（不过自环确实是值得注意的点，特判即可），还有当前最优化的剪枝，我直接写标解也妹卡常啊，`priority_queue` 直接摆上去都不会T（一眼顶针鉴定为纯纯的乱搞）

而且跑每个强连通块既避免了出入度为 0 的特殊情况，同时每个块的全源最短路分开跑，常数会更小，就是难写点。

我写标解 20min 秒了！[code。](https://www.luogu.com.cn/paste/68acfbcl)

---

## 作者：Loser_Syx (赞：3)

你考虑选出一个环时，各点的出入度数都是 $1$，而且我选出的度数相较于原度数只能是不大于原来的，所以如果某个点的某个度数为 $0$，直接删除就好，可以对于出度、入度跑两遍拓扑删。

接下来考虑构造极限数据，$n=3\times 10^5,m=n+1500$，并且图是一个长度为 $n$ 的环带 $1500$ 条非自环边。

但是有一个性质，如果点 $i$ 的出入度都为 $1$，则 $i$ 在答案的环上时，连接 $i$ 的两个点也一定在环上。  
所以你可以对于这样子的 $i$ 直接删除，让连接它的两个点直接连一条价值为两条边价值之和的边。如果连接的两个点中某个点还满足要求就继续删，删到不能删为止。

因为 $m=n+1500$，最大的环边个数为 $n$ 条，而剩下 $1500$ 条边每个最多只会影响到两个点的出入度大小，所以最多剩 $3000$ 个点，$3000+1500=4500$ 条边，可以直接对于每个点 Dijkstra，然后枚举其中的某条环边，复杂度 $O(NM \log M)$，$N$ 是剩余点数，$M$ 是剩余边数。

显然自环不能加边进去。

很难想象我是如何写出 4kb 还调很快的。

[代码](https://www.luogu.com.cn/paste/jrb2d7h1)，大常选手竟然是最优解。

---

## 作者：Shui_Dream (赞：1)

观察到这个问题如果没有特殊性质，是很难做的。考虑最简单的暴力做法。枚举环上出现的边 $u\xrightarrow{w} v$。我们把 $v$ 当作起点，初始距离是 $w$，终点是 $u$。跑一点 Dij 求最短路。复杂度可以做到 $O(m^2\log m)$。

考虑优化这个算法。注意到环上的点必然在同一个强连通分量里面里，因此先缩强连通。观察到性质 $m-n$ 比较小，且原图弱连通。设这个分量的点数为 $k$。那么由于原图弱联通，不在这个分量内的边至少有 $n-k$ 条，因此这个强连通分量内的边至多有 $m-(n-k)=m-n+k$ 条。

现在问题变成对于一个强连通图找最小环，先随便拿一个点建深度搜索树，这是一个外向树，所以必然经过非环边。我们可以枚举非环边跑 Dij。复杂度变成了 $O(m(m-n)\log m)$ 还是不能通过。考虑我们跑最短路时只保留有非环边的点，称这些点为特殊点，总数是 $O(m-n)$ 级别。特殊点之间若可以不经过其他特殊点到达，要么经过非环边，要么经过树上的边，树上的点是固定的。考虑线段树优化 Dij。每次轮到点 $u$ 拓展时，把 $w-dep_u$ 转移到子树区间。每次相当于找一个 $dep_u+w$ 最小的点拓展，线段树可以维护。复杂度做到 $O(n+(m-n)^2\log (m-n))$。有点卡常。

代码有一点长，但是没啥细节。

```cpp
#include<bits/stdc++.h>
#define pli pair<LL,int>
#define fi first
#define nd second
#define lc(p) p<<1
#define rc(p) p<<1|1
#define psb push_back
using namespace std;
typedef long long LL;
inline int read(){
    char ch=getchar();
    while(!isdigit(ch) && ch!='-') ch=getchar();
    int x=0,ff=1; if(ch=='-') ff=-1,ch=getchar();
    while(isdigit(ch)) x=(x<<3) + (x<<1) + (ch^48),ch=getchar();
    return x*ff;
}
const int N=3e5+5; const LL inf=1e16;
int n,m,dfn[N],low[N],st[N],tp,tot,col[N],gn,vc[N],ld[N],rd[N]; vector< pair<int,int> > e[N],e2[N],e3[N];
bool vis[N],bj[N]; LL lw[N],fd[N],ans=inf;
void tarjan(int u){
    dfn[u]=low[u]=++tot; st[++tp]=u; vis[u]=1;
    for(auto [v,w]:e[u]){
        if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
        else if(vis[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]){
        vc[++gn]=u;
        while(1){
            vis[st[tp]]=0; col[st[tp]]=u;
            if(st[tp--]==u) break;
        }
    }
}
void dfs1(int u){
    vis[u]=1;
    for(auto [v,w]:e[u]) if(col[v]==col[u]){
        if(!vis[v] ) { e2[u].psb({v,w}); dfs1(v);}
        else e3[u].psb({v,w}),bj[u]=bj[v]=1;
    }
}
void dfs2(int u){
    if(bj[u]) st[ld[u]=++tp]=u;
    for(auto [v,w]:e2[u]){ lw[v]=lw[u]+w; dfs2(v);}
    if(bj[u]) rd[u]=tp;
}
struct node{
    pli ma,mb; LL tg;
} tr[N<<2];
void pushup(int p){
    tr[p].mb=min(tr[lc(p)].mb,tr[rc(p)].mb);
    tr[p].ma=min({tr[lc(p)].ma,tr[rc(p)].ma,{tr[p].mb.fi+tr[p].tg,tr[p].mb.nd}});
}
void build(int p,int L,int R){
    tr[p].tg=inf; if(L==R) {
        int u=st[L];  tr[p].ma={inf,u}; tr[p].mb={lw[u],u}; tr[p].tg=inf;
        return ;
    } int mid=(L+R)/2; build(lc(p),L,mid); build(rc(p),mid+1,R); pushup(p);
}
void Mdf(int p,int L,int R,int lt,int rt,LL w){
    if(tr[p].mb.fi==inf) return ;
    if(L>=lt && R<=rt){
        if(w<tr[p].tg){
            tr[p].tg=w;
            if(L==R) tr[p].ma.fi=min(inf,w+tr[p].mb.fi);
            else pushup(p);
        }
        return ;
    } int mid=(L+R)/2;
    if(lt<=mid) Mdf(lc(p),L,mid,lt,rt,w);
    if(rt>mid) Mdf(rc(p),mid+1,R,lt,rt,w);
    pushup(p);
}
void Mban(int p,int L,int R,int kx){
    if(L==R) { tr[p].tg=tr[p].ma.fi=tr[p].mb.fi=inf; return ;}
    int mid=(L+R)/2;
    if(kx<=mid) Mban(lc(p),L,mid,kx);
    else Mban(rc(p),mid+1,R,kx);
    pushup(p);
}
void Dij(int T,int S,int w0){
    for(int i=1;i<=tp;i++) fd[st[i]]=inf;
    build(1,1,tp); Mdf(1,1,tp,ld[S],ld[S],w0-lw[S]);
    while(1){
        int u=tr[1].ma.nd; fd[u]=tr[1].ma.fi; if(u==T) break;
        Mban(1,1,tp,ld[u]); Mdf(1,1,tp,ld[u],rd[u],fd[u]-lw[u]);
        for(auto [v,w]:e3[u]) if(fd[v]==inf) Mdf(1,1,tp,ld[v],ld[v],fd[u]+w-lw[v]);
    }
    ans=min(ans,fd[T]);
}
int main(){
    n=read(); m=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),w=read();
        e[u].psb({v,w});
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
    memset(vis,0,sizeof(vis));
    for(int ii=1;ii<=gn;ii++){
        tp=0; int su=vc[ii];
        dfs1(su); dfs2(su); 
        for(int i=1;i<=tp;i++){
            int u=st[i]; 
            for(auto [v,w]:e3[u]) Dij(u,v,w);
        }
    } printf("%lld",(ans<inf)?ans:-1);
    return 0;
}
```

---

## 作者：DengDuck (赞：0)

我的代码在洛谷和 QOJ 都跑到了第二快，码量最短的成绩，当然我的实现其实还是挺垃圾的，欢迎大家优化。

~~我调试了半天然后不知道改哪里就过了。~~

首先很多题解都提到如果入度为 $0$，出度为 $1$ 或者反之，是可以删点的，但是我们其实都知道只要入度或出度为 $0$ 就能删点，不用管另外一个，这样我们能删更多的点。

现在所有点的入度和出度都是正数，考虑 $m-n\leq 1500$，因此我们可以算出平均度数在 $n\geq 10^5$ 之后是很小的，所以应该有一车子的点入度和出度都为 $1$，这个显然可以缩点。

缩了之后可以证明 $n\leq 3000$，于是可以考虑枚举环的一个起点跑 $n$ 轮 Dijkstra，然后统计即可。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
#define Edge pair<int,LL>
#define pLL pair<LL,int>
#define To first
#define W second
using namespace std;
const int N=3e5+5;
const LL Inf=1e18;
set<Edge>E[N],R[N];
LL D[N],Ans=Inf;
int n,m,Vis[N];
inline void Add(int x,int y,LL w){E[x].insert({y,w}),R[y].insert({x,w});}
inline void Del(int x,int y)
{
	E[x].erase(E[x].lower_bound({y,0}));
	R[y].erase(R[y].lower_bound({x,0}));
}
inline void Dij(int x)
{
	priority_queue<pLL,vector<pLL>,greater<pLL> >Q;
	Q.push({D[x]=0,x});
	vector<int>V;V.pb(x);
	while(!Q.empty())
	{
		int x=Q.top().W;Q.pop();
		if(Vis[x])continue;Vis[x]=1;
		for(Edge i:E[x])
		{
			if(D[x]+i.W<D[i.To]&&D[x]+i.W<Ans)
				Q.push({D[i.To]=D[x]+i.W,i.To}),V.pb(i.To);
		}
	}
	for(Edge i:R[x])Ans=min(Ans,D[i.To]+i.W);
	for(int i:V)D[i]=Inf,Vis[i]=0;
}
queue<int>Q;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,x,y,w;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&w);
		if(x==y)Ans=min(Ans,w*1ll);
		else Add(x,y,w);
	}
	for(int i=1;i<=n;i++)Q.push(i);
	while(!Q.empty())
	{
		int x=Q.front();Q.pop();
		if(E[x].empty())
		{
			set<Edge>V=R[x];
			for(Edge i:V)Q.push(i.To),Del(i.To,x);
		}
		if(R[x].empty())
		{
			set<Edge>V=E[x];
			for(Edge i:V)Q.push(i.To),Del(x,i.To);
		}
		if(E[x].size()==1&&R[x].size()==1)
		{
			Edge A=*R[x].begin(),B=*E[x].begin();
			Del(A.To,x),Del(x,B.To);
			if(A.To==B.To)
			{
				Ans=min(Ans,A.W+B.W);
				Q.push(A.To);
				continue;
			}
			Add(A.To,B.To,A.W+B.W);
			Q.push(A.To);
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!E[i].empty())D[i]=Inf;
	}
	for(int i=1;i<=n;i++)
	{
		if(!E[i].empty())Dij(i);
	}
	if(Ans==Inf)puts("-1");
	else printf("%lld\n",Ans);
}
```

---

## 作者：critnos (赞：0)

看到一个 $m-n\le 1500$ 直接猜一手类似广义串并联图的东西，把入度为 $1$ 出度为 $0$ 的点和删了，把入度出度均为 $1$ 的点的入边和出边加起来，把重边取 $\min$，把答案对自环取 $\min$。

然后 T 了。进行一个剪枝，在 dij 增广的时候动态更新 $ans$，然后只增广最短路到 $<ans$ 的点，保险起见加个卡时（目前没用）即可通过。

谷友会不会卡[啊](https://www.luogu.com.cn/paste/zhfmqb0a)

upd：非常强大的@I_am_Accepted 卡掉了上面的做法，不过原因是我忘记缩入度为 $0$ 出度为 $1$ 的点了。现在的[这份代码](https://www.luogu.com.cn/paste/8tb9guv9)即使去掉剪枝和卡时也可以通过。

upd：实际上，这样的操作并不能保证图的规模是 $O(m-n)$。考虑构造一个偶数个点的环，相邻两条边一个顺时针一个逆指针。

---


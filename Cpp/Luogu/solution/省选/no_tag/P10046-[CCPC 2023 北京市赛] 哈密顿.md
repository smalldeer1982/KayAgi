# [CCPC 2023 北京市赛] 哈密顿

## 题目描述

给出 $n$ 个二元组 $(a_i,b_i)$。

考虑 $n$ 个节点的带权有向完全图 $G$，其中从 $i (1 \le i \le n)$ 到 $j (1 \le j \le n)$ 的边边权为 $|a_i-b_j|$。

求 $G$ 的一条哈密顿回路使得其经过的边的边权和最大，并给出这个最大值。

## 说明/提示

考察哈密顿回路 $1 \to 2 \to 3 \to 1$，其边权和为 $|1-2| + |
8-5| + |4-10| = 10$。可以证明不存在哈密顿回路边权和超过 $10$，因此答案为 $10$。

## 样例 #1

### 输入

```
3
1 10
8 2
4 5```

### 输出

```
10```

# 题解

## 作者：Alex_Wei (赞：3)

### *[P10046 [CCPC 2023 北京市赛] 哈密顿](https://www.luogu.com.cn/problem/P10046)

问题等价于每个 $a_i$ 匹配一个 $b_j$，不同的 $a_i$ 匹配不同的 $b_j$，且匹配关系形成一个大环。即若 $a_i$ 匹配 $b_j$ 则连边 $i\to j$，图是一个环。

绝对值太烦人了，先去掉，则答案为 $\sum a_i - \sum b_j$。

考虑到每个 $a_i < b_j$ 会让答案增加 $2(b_j - a_i)$，则问题等价于选择相同数量的 $a_i$ 和 $b_j$，让选中的 $a_i$ 只会匹配选中的 $b_j$，匹配的 $a_i$ 和 $b_j$ 满足 $a_i < b_j$，并且除非全选，否则匹配关系不能成环。如果目前的匹配关系不成环，那么容易构造出补充匹配使得图是一个大环的情况。

- 如果选出的匹配（钦定 $a_i < b_j$）存在 $a_i > b_j$ 的情况，其贡献为 $b_j - a_i$，只会将答案算小。
- 如果补充的匹配（钦定 $a_i > b_j$）存在 $a_i < b_j$ 的情况，其贡献为 $a_i - b_j$，只会将答案算小。
- 要让选出的匹配不成环，只需让选出的 $a_i$ 下标集合 $A$ 和 $b_j$ 下标集合 $B$ 不完全相同。每次选 $A\backslash B$ 的某个 $i$，让它匹配 $A\cap B$ 的某个 $j$，然后从 $A$ 删去 $i$，从 $B$ 删去 $j$，则 $A\backslash B$ 大小不变且一定不会成环。假设 $u\to v$ 成环，那么 $v\in B$ 且 $v$ 之前作为某个 $i$ 出现，即当时 $v\in A$，则当时 $v\in A\cap B$，和 $v\in A\backslash B$ 矛盾。当 $A\cap B = \varnothing$ 时随便匹配就行。因为初始 $A\backslash B \neq \varnothing$，所以构造可行。

因此，我们的目标是在选中的两组下标集合不完全相同的限制下，最大化选出的 $\sum b_j - \sum a_i$。

将 $a_i$ 和 $b_j$ 从小到大排序，设它们原来的下标为 $c_i$ 和 $d_j$。显然，如果没有限制，则一定会选 $a_{1\sim k}$ 和 $b_{n - k + 1\sim n}$，满足 $a_k < b_{n - k + 1}$ 但 $a_{k + 1} > b_{n - k}$。先这么选着，如果不符合条件，说明 $A = B$ 且 $0 < |A| < n$，需要对方案进行调整。

对 $\Delta |A|$ 分类讨论：

- 若 $\Delta |A| = -1$，则
  - 若 $c_k \neq d_{n - k + 1}$ 或者 $|A| = 1$，则将 $c_k$ 和 $d_{n - k + 1}$ 分别从 $A$ 和 $B$ 中删去。
  - 否则删去 $c_k$ 和 $d_{n - k + 2}$，或 $c_{k - 1}$ 和 $d_{n - k + 1}$。
- 若 $\Delta |A| = 0$，则将 $c_k$ 和 $d_{n - k + 1}$ 删去，换成 $c_k$ 和 $d_{n - k}$，或 $c_{k + 1}$ 和 $d_{n - k + 1}$。
- 若 $\Delta |A| = 1$，则
  - 若 $c_{k + 1}\neq d_{n - k}$ 或 $|A| = n - 1$，则加入 $c_{k + 1}$ 和 $d_{n - k}$。
  - 否则加入 $c_{k + 1}$ 和 $d_{n - k - 1}$，或 $c_{k + 2}$ 和 $d_{n - k}$。

正确性证明分两步，一步是证明给出的方案是在固定 $\Delta |A|$ 之后最优的，另一步是证明其它 $\Delta |A|$ 一定不优于 $\Delta |A| = \pm 1$ 的情况。具体细节留给读者自行补充。

时间复杂度为除排序外线性。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using pdd = pair<double, double>;
using ull = unsigned long long;
using LL = __int128_t;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;

// ---------- templates above ----------

constexpr int N = 1e5 + 5;

int n;
struct dat {
  int val, id;
  bool operator < (const dat &z) const {
    return val < z.val;
  }
} a[N], b[N];
void solve() {
  cin >> n;
  for(int i = 1; i <= n; i++) {
    cin >> a[i].val >> b[i].val;
    a[i].id = b[i].id = i;
  }
  sort(a + 1, a + n + 1);
  sort(b + 1, b + n + 1);
  int l = 0, r = n + 1;
  map<int, int> mp;
  ll ans = 0;
  while(l < n) {
    if(a[l + 1].val > b[r - 1].val) break;
    mp[a[++l].id]++, mp[b[--r].id]--;
    ans += b[r].val - a[l].val;
  }
  bool ok = 0;
  for(pii it : mp) ok |= it.second > 0;
  if(!ok && l < n && l) {
    ll res = -1e18;
    auto f = [&](int l, int r) {
      return ll(b[r].val - a[l].val);
    };
    if(a[l].id != b[r].id || l == 1) res = max(res, -f(l, r));
    else res = max(res, max(-f(l, r + 1), -f(l - 1, r)));
    res = max(res, max(f(l, r - 1), f(l + 1, r)) - f(l, r));
    if(a[l + 1].id != b[r + 1].id || l == n - 1) res = max(res, f(l + 1, r - 1));
    else res = max(res, max(f(l + 2, r - 1), f(l + 1, r - 2)));
    ans += res;
  }
  ans *= 2;
  for(int i = 1; i <= n; i++) ans += a[i].val - b[i].val;
  cout << ans << endl;
}

bool Med;
signed main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) solve();
  fprintf(stderr, "%.3lf ms\n", 1e3 * clock() / CLOCKS_PER_SEC);
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：Jsxts_ (赞：2)

容易发现需要定出所有 $a,b$ 的正负号并让，使其贡献最大并且满足条件。

那么第一个限制就是在 $a$ 中的正号与 $b$ 中的负号数量相同。然后对于一个 $i$，所有符号的情况有 $a_i$ 为正/负，$b_i$ 为正/负的 $4$ 种情况（表示为二元组 $(a,b)$，正为 $1$，负为 $0$），我们考察何时这些情况可以使得在匹配后组成一个环。（注意这里我们不需要保证匹配的时候正号对应的数一定大于等于负号对应的数，因为我们求的是贡献最大，会自然规避掉不合法的情况）。

首先若全为 $(1,0)$ 或 $(0,1)$ 肯定有解。并且若有且只有 $(1,0),(0,1)$ 肯定无解。

其次考虑加入一个 $(1,1)$，此时由于数量限制一定会加入一个 $(0,0)$（即两者数量一定相同），那么我们容易通过它们构造出一组合法的匹配，使其形成一个环。（具体可以自己手玩，过程不好描述）。

那么知道所有限制后，考虑来构造贡献最大的方案。首先无论 $(1,0)$ 或 $(0,1)$ 贡献肯定为 $|a_i-b_i|$，而删去一个 $(1,0)$ 或 $(0,1)$ 替换成 $(1,1)$ 的贡献为 $2\times \min(a_i,b_i)$，替换成 $(0,0)$ 的贡献为 $2\times\max(a_i,b_i)$。而我们就要选出至少一对 $(i,j)$ 使令 $i$ 变为 $(1,1)$，$j$ 变为 $(0,0)$ 并使贡献最大。

于是我们考虑一个贪心：维护两个存数组下标的堆，其中第一个按 $2\times \min(a_i,b_i)$ 降序排序，第二个按 $2\times\max(a_i,b_i)$ 升序排序。选出一对就在两个堆头分别选出第一个还未选过的下标作为当前轮选的数对。显然贡献递减，所以若当前新增贡献 $\le 0$ 并且已经选出至少一对就可以结束贪心。

但是当两个堆弹出的堆头相同时要特殊处理。此时知道之后的贡献一定 $\le 0$，所以若之前选过直接退出，之前还未选过就取出两个堆中的次优值来分别与其匹配并取贡献较大的部分即可。

正确性证明：若一个数 $i$ 在取出 $(1,1)$ 的堆中先被取出，则不可能被用作 $(0,0)$，因为此时剩下 $(1,1)$ 中的 $\min(a,b)$ 一定小于等于 $\max(a_i,b_i)$，不会再和其匹配。反过来同理。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 1e9;
const ll INF = 1e15;
const int N = 1e5;
inline int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
int n,a[N + 10],b[N + 10];
struct node {
	int i;
	bool operator < (const node &x) const {
		return min(a[i],b[i]) < min(a[x.i],b[x.i]);
	}
};
struct node2 {
	int i;
	bool operator < (const node2 &x) const {
		return max(a[i],b[i]) > max(a[x.i],b[x.i]);
	}
};
priority_queue<node> q1;
priority_queue<node2> q2;
int vis[N + 10];
int main() {
	n = read();
	for (int i = 1;i <= n;i ++ ) a[i] = read(), b[i] = read();
	for (int i = 1;i <= n;i ++ ) q1.push({i}), q2.push({i});
	ll ans = 0,tmp = 0;
	int ct = 0;
	for (int i = 1;i <= n;i ++ ) ans += abs(a[i] - b[i]), tmp += a[i] - b[i];
	tmp = abs(tmp);
	while (!q1.empty() && !q2.empty()) {
		while (q2.size() && vis[q2.top().i]) q2.pop();
		if (!q2.size()) cout << max(ans,tmp), exit(0);
		int y = q2.top().i;q2.pop();
		while (q1.size() && vis[q1.top().i]) q1.pop();
		if (!q1.size()) cout << max(ans,tmp), exit(0);
		int x = q1.top().i;q1.pop();
		if (x == y) {
			if (ct) cout << max(ans,tmp), exit(0);
			int z = -1;
			ll res = -INF;
			while (q1.size() && vis[q1.top().i]) q1.pop();
			if (q1.size()) {
				z = q1.top().i;q1.pop();
				res = max(res,ans + 2 * min(a[z],b[z]) - 2 * max(a[x],b[x]));
			}
			while (q2.size() && vis[q2.top().i]) q2.pop();
			if (q2.size()) {
				z = q2.top().i;q2.pop();
				res = max(res,ans + 2 * min(a[x],b[x]) - 2 * max(a[z],b[z]));
			}
			cout << max(res,tmp);
			exit(0);
		}
		ll v = 2 * min(a[x],b[x]) - 2 * max(a[y],b[y]);
		if (v <= 0 && ct) cout << max(ans,tmp), exit(0);
		vis[x] = vis[y] = 1, ans += v;ct ++;
	}
	cout << max(ans,tmp);
	return 0;
}
```


---

## 作者：良心WA题人 (赞：2)

绝对值很烦。考虑将相邻两条边的绝对值拆出来，有以下四种：

- $a_i-b_j\to a_j-b_k$：$a_j-b_j$
- $a_i-b_j\to b_k-a_j$：$-a_j-b_j$
- $b_j-a_i\to b_k-a_j$：$b_j-a_j$
- $b_j-a_i\to a_j-b_k$：$a_j+b_j$

然后你会发现，如果实际上能拼出来合法路径但拼不出来一个权值符合要求的图则一定中间会出现两个相减为负数，则一定不优。于是我们只需要使用上面四种使得能够拼出来一条合法路径即可。

注意到因为绝对值都是一正一负，所以首先正负号一定要相等，即第二种和第四种个数要相等。

而第一种和第三种分别可以单独出现。若要同时出现，则至少有一个第二种和第四种。

显然可以从一开始全都是第一种和第三种，然后不断加入第二种和第四种边取最大值。可以用优先队列简单维护。

注意到除了第一次替换以外别的每次替换若替换了两个相同的一定不优，则不需要处理相同的情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int NN=1e5+4;
struct node
{
	int a,b,w1,w2;
	bool operator<(const node&it)const
	{
		return w1<it.w1;
	}
}t[NN];
int main()
{
	int n;
	scanf("%d",&n);
	ll s1=0,s2=0;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		s1+=a-b,s2+=b-a;
		t[i]={a,b,a+b,abs(a-b)};
	}
	ll res=0;
	sort(t+1,t+1+n);
	priority_queue<pair<ll,int> >q1,q2;
	for(int i=1;i<=n;i++)
	{
		res+=t[i].w2;
		q1.push({t[i].w1-t[i].w2,i}),q2.push({-t[i].w1-t[i].w2,i});
	}
	ll ans=max(s1,s2);
	while(q1.size()&&q2.size())
	{
		if(q1.top().second!=q2.top().second)
			res+=q1.top().first+q2.top().first;
		else
		{
			int a=q1.top().first,b=q2.top().first;
			q1.pop(),q2.pop();
			if(!q1.size())
				break;
			res+=max(q1.top().first+b,a+q2.top().first);
		}
		q1.pop(),q2.pop();
		ans=max(ans,res);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：masterhuang (赞：1)

~~由于懒惰进行了一个无耻的抄，希望各位谅解~~

## 法 1 ([良心WA题人](https://www.luogu.com.cn/user/132424))

拆绝对值套路。考虑将相邻两条边的绝对值拆出来，有以下四种：

* $a_i - b_j \to a_j - b_k: a_j - b_j$
* $a_i - b_j \to b_k - a_j: -a_j - b_j$
* $b_j - a_i \to b_k - a_j: b_j - a_j$
* $b_j - a_i \to a_j - b_k: a_j + b_j$​

即对每种情况，考虑对于**中间点** $j$，$a,b$​ 的符号。

---

显然合法图都能被这四种拼出来。考虑怎么拼才是合法：

显然由于正负个数相等，第二种和第四种个数要相等。

而第一种和第三种**分别可以单独出现**。**若要同时出现，则至少有一个第二种和第四种（过渡）**。$\color{red}(*)$

特判全一和全三。

显然可以从一开始全都是第一种或第三种（取最优），然后不断加入第二种和第四种（进行调整）边取最大值。可以用优先队列简单维护。

具体的：每次贪心的，同时加入当前最优的调整 $(a_i+b_i-|a_i-b_i|)$ 和 $(-a_j-b_j-|a_i-b_i|)$。

若 $i=j$，则需要分别拿出调整值次大的 $k,l$，判断 $(i,l)$ 和 $(k,j)$ 应该同时调整哪一对。

---

优先队列调整，复杂度 $O(n\log n)$​。

关键代码参考：

```cpp
for(int i=1;i<=n;i++)q1.emplace(a[i].fi+a[i].se-abs(a[i].fi-a[i].se),i),q2.emplace(-a[i].fi-a[i].se-abs(a[i].fi-a[i].se),i);
    while(q1.size()&&q2.size()){
        if(q1.top().se!=q2.top().se){
            res+=q1.top().first+q2.top().first;
        }else{
            int A=q1.top().first,B=q2.top().first;
            q1.pop();q2.pop();
            if(!q1.size())break;
            res+=max(A+q2.top().first,B+q1.top().first);
        }
        q1.pop();q2.pop();
        ans=max(ans,res);
    }
```

## 法 2 (TachiBK)

**这个代码是最短的**。

有个贪心：我们贪心强制对 $a,b$ 定 $n$ 个 $+$，$n$ 个 $-$，使得组合出来的数最大。

此时只有少部分情况不合法，我们参考法 $1$ 的 $\color{red}(*)$：

参考法 $1$ 的分析，若此时在我**贪心强制的定符号**下，出现**全一或全三**，或者存在二四的单组（并且二四个数一致，判一个就行），那么方案一定合法。

否则一定一三均有，且无二四。考虑调整一组最优的符号即可，就把排序完的第 $n$ 小调整为 $+$，第 $n+1$ 小调整为 $-$。

如果第 $n$ 小和第 $n+1$ 小属于同一个数，那么调整又无效了。考虑调整 $(n,n+2)$ 和 $(n-1,n+1)$ 即可，看看哪个更优秀。

时间复杂度为除排序外线性。

[$\bf{record}$](https://qoj.ac/submission/978630)

## 法 3 (云斗题解+Alex_Wei)

~~不是很建议，有点小复杂~~

首先把答案设为 $\sum a_i - \sum b_i$， 然后考虑如果有一条边的 $a_i < b_j$， 我们就可以获得 $2(b_j - a_i)$ 的收益。

考虑钦定一些边 $(i, j)$ 被选中， 然后这些边不能连成环。 首先， 最优解一定可以被这样算到。 那么会不会有更优的解被算到呢， 发现我们如果给选定的这些位置随便钦定一个不成环的匹配（不管 $a_i < b_j$ 的约束）， 那么当 $a_i > b_j$ 的时候也会算入 $2(b_j - a_i) < 0$， 但实际贡献应该是 $0$。 于是我们不会算得更大。

于是只需要找两个集合 $S, T$ 满足 $|S| = |T|, S \neq T$， 最大化 $\sum_{i \in S} b_i - \sum_{j \in T} a_j$。

将 $a_i$ 和 $b_j$ 从小到大排序，设它们原来的下标为 $c_i$ 和 $d_j$。显然，如果没有限制，则一定会选 $a_{1 \sim k}$ 和 $b_{n-k+1 \sim n}$，满足 $a_k < b_{n-k+1}$ 但 $a_{k+1} > b_{n-k}$​。

---

先这么选着，设两边选的对应的 $c,d$ 的集合分别为 $A,B$，如果不符合条件，说明 $A = B$ 且 $0 < |A| < n$，需要对方案进行调整。

对 $\Delta |A|$ 分类讨论：

* 若 $\Delta |A| = -1$，则
  * 若 $c_k \neq d_{n-k+1}$ 或者 $|A| = 1$，则将 $c_k$ 和 $d_{n-k+1}$ 分别从 $A$ 和 $B$ 中删去。
  * 否则删去 $c_k$ 和 $d_{n-k+2}$，或 $c_{k-1}$ 和 $d_{n-k+1}$。
* 若 $\Delta |A| = 0$，则将 $c_k$ 和 $d_{n-k+1}$ 删去，换成 $c_k$ 和 $d_{n-k}$，或 $c_{k+1}$ 和 $d_{n-k+1}$。
* 若 $\Delta |A| = 1$，则
  * 若 $c_{k+1} \neq d_{n-k}$ 或 $|A| = n-1$，则加入 $c_{k+1}$ 和 $d_{n-k}$。
  * 否则加入 $c_{k+1}$ 和 $d_{n-k-1}$，或 $c_{k+2}$ 和 $d_{n-k}$。

正确性证明分两步，一步是证明给出的方案是在固定 $\Delta |A|$ 之后最优的，另一步是证明其它 $\Delta |A|$ 一定不优于 $\Delta |A| = \pm 1$ 的情况。具体细节留给读者自行补充。

时间复杂度为除排序外线性。

```cpp
// code by Alex_Wei
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using pdd = pair<double, double>;
using ull = unsigned long long;
using LL = __int128_t;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;

// ---------- templates above ----------

constexpr int N = 1e5 + 5;

int n;
struct dat {
  int val, id;
  bool operator < (const dat &z) const {
    return val < z.val;
  }
} a[N], b[N];
void solve() {
  cin >> n;
  for(int i = 1; i <= n; i++) {
    cin >> a[i].val >> b[i].val;
    a[i].id = b[i].id = i;
  }
  sort(a + 1, a + n + 1);
  sort(b + 1, b + n + 1);
  int l = 0, r = n + 1;
  map<int, int> mp;
  ll ans = 0;
  while(l < n) {
    if(a[l + 1].val > b[r - 1].val) break;
    mp[a[++l].id]++, mp[b[--r].id]--;
    ans += b[r].val - a[l].val;
  }
  bool ok = 0;
  for(pii it : mp) ok |= it.second > 0;
  if(!ok && l < n && l) {
    ll res = -1e18;
    auto f = [&](int l, int r) {
      return ll(b[r].val - a[l].val);
    };
    if(a[l].id != b[r].id || l == 1) res = max(res, -f(l, r));
    else res = max(res, max(-f(l, r + 1), -f(l - 1, r)));
    res = max(res, max(f(l, r - 1), f(l + 1, r)) - f(l, r));
    if(a[l + 1].id != b[r + 1].id || l == n - 1) res = max(res, f(l + 1, r - 1));
    else res = max(res, max(f(l + 2, r - 1), f(l + 1, r - 2)));
    ans += res;
  }
  ans *= 2;
  for(int i = 1; i <= n; i++) ans += a[i].val - b[i].val;
  cout << ans << endl;
}

bool Med;
signed main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) solve();
  fprintf(stderr, "%.3lf ms\n", 1e3 * clock() / CLOCKS_PER_SEC);
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：Leasier (赞：1)

~~拒绝反悔贪心，从我做起。~~

------------

设最终走的哈密顿回路为 $p_1 \to p_2 \to \cdots \to p_n \to p_1$。

首先我们可以把绝对值拆开，变成 $\max(a_{p_i} - b_{p_{i \bmod n + 1}}, b_{p_{i \bmod n + 1}} - a_{p_i})$，即我们要让相邻的 $a, b$ 一正一负**匹配**。

考虑建两个点 $S, T$。当 $a_i$ 贡献为正则从 $S$ 连出一条边，否则向 $S$ 连入一条边；当 $b_i$ 贡献为正则从 $T$ 连出一条边，否则向 $T$ 连入一条边。

首先特判欧拉回路是一个自环的情况：此时答案为 $|\displaystyle\sum_{i  = 1}^n (a_i - b_i)|$。

否则，考虑一个 $i$ 对应 $a_i, b_i$ 的正负性对 $S$ 的入度减出度的影响：

- $(+, +)$：$\Delta = 1$。
- $(+, -) / (-, +)$：$\Delta = 0$。
- $(-, -)$：$\Delta = -1$。

于是问题变为：

- 有 $n$ 类物品，每类有权值为 $1, 0, -1$ 的三个物品，从每类物品中选一个，使得权值之和为 $0$，且贡献之和最大。

至此，一个直接的想法是 $O(n^2)$ 背包。

在此基础上的一个经典做法是随机打乱后钦定前缀权值之和 $O(\sqrt{n})$ 来做背包，时间复杂度为 $O(n \sqrt{n})$。

还有一种想法是，考虑把物品分为权值为 $\pm 1$ 的两类，不难发现此时答案关于它们选的数量是**凸**的，于是二分数量后跑 [[AGC018C] Coins](https://www.luogu.com.cn/problem/AT_agc018_c) check 即可。

时间复杂度为 $O(n \log^2 n)$。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <cstdlib>

using namespace std;

typedef long long ll;

typedef struct {
	int a;
	ll b;
} Node;

int a[100007], b[100007];
ll pre[100007], suf[100007];
Node c[100007];
priority_queue<int, vector<int>, greater<int> > q1;
priority_queue<ll, vector<ll>, greater<ll> > q2;

bool operator <(const Node a, const Node b){
	return a.a - a.b > b.a - b.b;
}

inline ll check(int n, int k){
	if (k == 0 || k * 2 > n) return 0x8000000000000000ll;
	ll cur = 0, ans = 0x8000000000000000ll;
	while (!q1.empty()) q1.pop();
	for (int i = 1; i <= n; i++){
		cur += c[i].a;
		q1.push(c[i].a);
		if (i > k){
			cur -= q1.top();
			q1.pop();
		}
		pre[i] = cur;
	}
	cur = 0;
	while (!q2.empty()) q2.pop();
	for (int i = n; i >= 1; i--){
		cur += c[i].b;
		q2.push(c[i].b);
		if (i + k <= n){
			cur -= q2.top();
			q2.pop();
		}
		suf[i] = cur;
	}
	for (int i = k; i + k <= n; i++){
		ans = max(ans, pre[i] + suf[i + 1]);
	}
	return ans;
}

int main(){
	int n, l = 0, r, pos;
	ll sum1 = 0, sum2 = 0;
    cin >> n;
	r = n / 2;
	for (int i = 1; i <= n; i++){
		int p, q;
		cin >> a[i] >> b[i];
		p = a[i] - b[i];
		sum1 += p;
		p = abs(p);
		sum2 += p;
		q = a[i] + b[i];
		c[i].a = q - p;
		c[i].b = -(ll)q - p;
	}
	sort(c + 1, c + n + 1);
	while (l <= r){
		int mid = (l + r) >> 1;
		if (check(n, mid) >= check(n, mid + 1)){
			r = mid - 1;
			pos = mid;
		} else {
			l = mid + 1;
		}
	}
	cout << max(llabs(sum1), check(n, pos) + sum2);
	return 0;
}
```

---

## 作者：cryozwq (赞：1)

一种比较神秘的做法，洛谷通过后本地把小数据都对拍了下，应该保真。

考虑到 $|a-b|=\max (a-b,b-a)$，则原问题事实上等价于给每个 $a_i,b_i$ 标号，满足对于所求路径上一条边 $i \to j$，$a_i,b_j$ 不同号。（到这里比较正常）

如果不考虑整体要连成一个大环，限制等价于给 $a_i$ 标的负号的数量等于给 $b_i$ 标的正号的数量，那么这个问题是容易的，枚举分界线即可，设分界线为 $k$ （排序后的 $a_1$ 到 $a_k$ 为负，对应的 $b_{n-k+1}$ 到 $b_n$ 为正）。这么做的问题是什么？我们得到的答案事实上是若干个环构成的，而不是一个，所以会使得算出来的更大。

考虑在得到这样一个方案后调整，对于两个环上两条边 $i\to j$ 和 $i' \to j'$ 调整为 $i \to j'$，$i' \to j$ 就合并了两个环。

接下来阐述两个个较为简单的结论（由于证明比较显然，故不赘述，有问题私信），称 $a_i < b_j$ 的边 $i \to j$ 为正边，否则为负边。边 $i\to j$ 在数轴上代表的线段为 $[\min(a_i,b_j),\max(a_i,b_j) ]$。

- 对于任意两条边 $i \to j$ 与 $i' \to j'$，若两者在数轴上代表的线段无交集，调整为 $i \to j'$ 与 $i' \to j$ 一定更优
。

- 对于任意两条边 $i \to j$ 与 $i' \to j'$，若两者在数轴上代表的线段有交集，则两条边正负不同时，调整为 $i \to j'$ 与 $i' \to j$ 会使答案减小，否则对答案无影响，下图列了两个例子，其余情况类似（黑色未调整，蓝色调整后）：

![](https://cdn.luogu.com.cn/upload/image_hosting/6ghzcwlx.png)


由于此时已经为理论最优解，故无法再找到两条边所代表线段无交集，则合并两个环时，若两个环都有正边或者负边，则合并不减小答案，我们现在要尽可能减小合并带来的损失，则若存在一个既有正边又有负边的环，那么合并为一个环一定无损失，先判掉。

否则一个环一定要么都是负边，要么都是正边，这些环内部合并不产生损失，因此**需要且仅需要一次有损失的合并**就能保证所有环最后合并为一个，接下来，我们只需要最小化这次合并的损失。那么我们形式化描述一下这个损失的具体大小，其实就是**选的两条边代表线段的交的大小**的 $2$ 倍，为了使其尽量小，简单贪心可知即为分界点 $k$ 对应的 $k \to n-k+1$ 和 $k+1 \to n-k$ 这两条边所产生的交一定是所有正负不同的边对应线段交最小的。


唯一的问题是，只合并这两条边一定在所有情况下都能保证所有环合并完吗？并不是。需要进行分类讨论：

- 如果两条线段并非包含关系，画图可知这两条边调整后一定还是为正边和负边，则一定合法。

- 如果属于包含关系，则调整后为两条正边或者两条负边，这里以两条正边举例，负边同理，这样的话，合并剩余的正环无需额外代价，但是对于负环就无法合并，所以我们需要在这次正负边合并前先把所有负环合并起来，只要这条需要合并的负边对应的环不是自环，我们就可以拿这个环上其他边去先合并完其余负环，再用这条边和刚刚说的那条正边合并达到最小损失。

也就是说，当且仅当这两条边对应线段属于包含关系且被包含者对应的环是一个自环，这种方案不成立，这种情况下，不得不用这条边去和其他负环的边合并导致对应线段变大，但是合并一次之后这个环就不是自环了，只需要让这次合并对这条边对应线段变化尽量小，简单讨论后贪心即可，不再赘述。

综上，通过这一系列较为繁杂的讨论，我们事实上得到了一个较为简洁的解法。

代码：

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define fr first
#define sc second
using namespace std;
typedef long long ll;
int n;
const ll inf=1e17;
const int maxn=2e6+5;
ll a[maxn],b[maxn];
pair<ll,int>ta[maxn],tb[maxn];
ll sa[maxn],sb[maxn];
ll mul;
map<int,int>g;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld",&a[i],&b[i]),ta[i]=mp(a[i],i),tb[i]=mp(b[i],i);
	sort(ta+1,ta+n+1);
	sort(tb+1,tb+n+1);
	for(int i=1;i<=n;i++)sa[i]=sa[i-1]+ta[i].fr;
	for(int i=1;i<=n;i++)sb[i]=sb[i-1]+tb[i].fr;
	ll ans=0;
	int k=0;
	for(int i=0;i<=n;i++){
		ll val=-sa[i]+(sa[n]-sa[i])-sb[n-i]+(sb[n]-sb[n-i]);
		ans=max(ans,val);
		if(ans==val)k=i;
	}
	for(int i=1;i<=k;i++){
		g[ta[i].sc]++;
		g[tb[n-i+1].sc]--;
	}
	bool fl=0;
	for(auto v:g)fl|=(v.sc>0);
	if(fl){
		cout<<ans;
		return 0;
	}
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	ll mul=inf;
	int a1=k,a2=k+1,b1=n-k+1,b2=n-k;
	if(k==0||k==n){
		cout<<ans<<endl;
		return 0;
	} 
	if(a[a1]<=b[b2]){
		if(a[a2]<=b[b1]){
			if(a2==n||ta[a2].sc!=tb[b2].sc)mul=2ll*(a[a2]-b[b2]);
			else{
				int b3=n-k-1,a3=a2+1;
				mul=min(2ll*(a[a2]-max(b[b3],a[a1])),2ll*(min(a[a3],b[b1])-b[b2]));
			}
		} 
		if(b[b1]<=a[a2])mul=2ll*(b[b1]-b[b2]);
	}
	else{
		if(a[a2]<=b[b1])mul=2ll*(a[a2]-a[a1]);
		if(b[b1]<=a[a2]){
			if(b1==n||tb[b1].sc!=ta[a1].sc)mul=2ll*(b[b1]-a[a1]);
			else{
				int b3=b1+1,a3=a1-1;
				mul=min(2ll*(b[b1]-max(a[a3],b[b2])),2ll*(min(b[b3],a[a2])-a[a1]));
			}
		}
	}
	cout<<ans-mul<<endl;
	return 0;
}
```

---

## 作者：BreakPlus (赞：0)

把绝对值拆开，$|a_i - b_j| = \max(a_i-b_j, b_j-a_i)$。每个 $a_i$ 或 $b_i$ 的贡献均为 $1$ 或 $-1$，且 $1$ 和 $-1$ 的数量相等，均为 $n$。

我们令 $P$ 表示 $a_i,b_i$ 均为正贡献的 $i$ 的数量；$Q_1$ 表示 $a_i$ 为正，$b_i$ 为负的数量；$Q_2$ 表示 $a_i$ 为负，$b_i$ 为正的数量。考虑怎样的三元组 $(P, Q_1, Q_2)$ 合法。

首先有 $2P + Q_1 + Q_2 = n$。这是因为 $a_i,b_i$ 均为正和均为负的数量肯定相等（正负总数量相等）。

转化一下题目要求，其实就是问能不能构造出一个把所有 $i$ 串起来的环，且对于环上一条边 $i_1 \to i_2$，$b_{i_1}$ 和 $a_{i_2}$ 的贡献一正一负。

发现若 $P>0$，可以从一个“正正”开始，依次连接所有的“正负”，再连接到一个“负负”，然后一次连接所有的“负正”，最后“负负”“正正”交替串联。

若 $P=0$，显然当 $Q_1Q_2 > 0$ 是不行的，$Q_1Q_2 = 0$ 则可以。

先贪心取 $n$ 个较大值为正贡献，然后枚举一个“正正”进行调整。注意分讨 $P$。就做完了。

```cpp
ll n;
struct Node{
	ll val, id, tp;
}node[200005];
ll f[2][100005], a[2][100005];
ll calc(){
	ll ans = 0;
	for(ll i=1;i<=n;i++){
		ans += (f[0][i]*2-1) * a[0][i];
		ans += (f[1][i]*2-1) * a[1][i];
	}
	return ans;
}

ll qz[2][100005], hz[2][100005];
void solve(){
	n=read();
	for(ll i=1;i<=n;i++) {
		a[0][i]=read(); node[2*i-1].val=a[0][i];
		node[2*i-1].id=i;
		a[1][i]=read(); node[2*i].val=a[1][i];
		node[2*i].id=i; node[2*i].tp=1;
	}
	ll ans = 0;
	for(ll i=1;i<=n;i++) f[0][i] = 1; ans = max(ans, calc());
	memset(f, 0, sizeof(f));
	for(ll i=1;i<=n;i++) f[1][i] = 1; ans = max(ans, calc());
	memset(f, 0, sizeof(f));

	sort(node+1, node+2*n+1, [](Node A, Node B){ return A.val > B.val; });
	for(ll i=1;i<=n;i++){
		f[node[i].tp][node[i].id] = 1;
	}
	ll cnt = 0, cnt2 = 0;
	for(ll i=1;i<=n;i++){
		if(f[0][i] == f[1][i]) ++cnt;
		else{
			if(f[0][i]) ++cnt2;
		}
	}
	if(cnt || cnt2 == 0 || cnt2 == n){
		printf("%lld\n", calc());
		return;
	}
	ll now = calc();
	memset(qz[1], 63, sizeof(qz[1]));
	memset(hz[1], 63, sizeof(hz[1]));
	for(ll i=1;i<=n;i++){
		if(f[0][i] == 0) qz[0][i] = max(a[0][i], qz[0][i-1]);
		if(f[0][i] == 1) qz[1][i] = min(a[0][i], qz[1][i-1]);
		if(f[1][i] == 0) qz[0][i] = max(a[1][i], qz[0][i-1]);
		if(f[1][i] == 1) qz[1][i] = min(a[1][i], qz[1][i-1]);
	}
	for(ll i=n;i>=1;i--){
		if(f[0][i] == 0) hz[0][i] = max(a[0][i], hz[0][i+1]);
		if(f[0][i] == 1) hz[1][i] = min(a[0][i], hz[1][i+1]);
		if(f[1][i] == 0) hz[0][i] = max(a[1][i], hz[0][i+1]);
		if(f[1][i] == 1) hz[1][i] = min(a[1][i], hz[1][i+1]);
	}
	for(ll i=1;i<=n;i++){
		if(f[0][i] == 0){
			ll A = now + 2 * (a[0][i] - min(qz[1][i-1], hz[1][i+1]));
			ll B = now + 2 * (max(qz[0][i-1], hz[0][i+1]) - a[1][i]);
			ans = max({ans, A, B});
		}else{
			ll A = now + 2 * (a[1][i] - min(qz[1][i-1], hz[1][i+1]));
			ll B = now + 2 * (max(qz[0][i-1], hz[0][i+1]) - a[0][i]);
			ans = max({ans, A, B});
		}
	}
	printf("%lld\n", ans);
}
```

---

## 作者：analysis (赞：0)

首先是绝对值，显然要去掉绝对值。

由于原题要求一个最优解（最大值），我们不妨将绝对值转化成最大值。

即 $|a-b| = \max(a-b,b-a)$。

（说人话就是要给 $a,b$ 加上正负号）

显然，路径上 $u \to v$ 的边可以表示为 $F(a_u)=-F(b_v)$，$F$ 表示符号。

所以，合法的路径方案（不一定联通，但每个点都经过且仅经过一次）至少要求 $a,b$ 间相反符号的数量相等。

在这的基础上，我们还要思考怎样的路径是哈密顿路径。

- 你的路线要联通（不能散成几块）

那我们讨论怎么样是“散成几块”的方案。

显然，`(-,+)` 和 `(+,-)` 之间无法联通。

如何让他们联通呢？使用 `(+,+)` 和 `(-,-)` 即可（注意 `(+,+)` 和 `(-,-)` 必须成对出现）。

所以总结下来就是这样的：

- `(+,+)` 和 `(-,-)` 必须成对出现

- 当 `(-,+)` 和 `(+,-)` 同时出现时，必须有 `(+,+)` 和 `(-,-)`

在满足上述规则的情况下，尽可能使答案最大。

具体来说，我们可以应用贡献的思想，一开始先让所有点为 `(-,+)` 或 `(+,-)`。若 $a > b$ 为 `(+,-)`，否则为 `(-,+)`。

然后，如果 `(-,+)` 和 `(+,-)` 同时出现，我们根据贡献大小把一部分 `(-,+)` 和 `(+,-)` 改为 `(+,+)` 和 `(-,-)`。

显然，把点 $i$ 改为 `(+,+)` 的贡献为 $2\min(a_i,b_i)$，改为 `(-,-)` 的贡献为 $-2\max(a_i,b_i)$。 用两个大根堆维护即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct st{
	int id;
	int v;
	st(int id,int v):id(id),v(v){}
};
bool operator<(st a,st b)
{
	if(a.v != b.v)return a.v < b.v;
	else return a.id < b.id;
}
bool vis[100005];
priority_queue<st> s1,s2;
int n,ans;
int lnum;
bool func(bool must=false) //改一对
{
	while(!s1.empty() && vis[s1.top().id])s1.pop();
	while(!s2.empty() && vis[s2.top().id])s2.pop();
	if(s1.empty() || s2.empty())return false;
	st a = s1.top(),b = s2.top();
	s1.pop();
	s2.pop();
	if(a.id != b.id)
	{
		if(must || a.v + b.v > 0)return ans += a.v + b.v,1;
		else return false;
	}
	else
	{
		if(!must)return false;
		else
		{
			while(!s1.empty() && vis[s1.top().id])s1.pop();
			while(!s2.empty() && vis[s2.top().id])s2.pop();
			if(s1.empty() && s2.empty())return false;
			else if(s1.empty())
			{
				st d = s2.top();
				s2.pop();
				ans += a.v + d.v;
				return true;
			}
			else if(s2.empty())
			{
				st c = s1.top();
				s1.pop();
				ans += b.v + c.v;
				return true;
			}
			else
			{
				st c = s1.top();
				st d = s2.top();
				if(a.v + d.v > b.v + c.v)
				{
					s2.pop();
					ans += a.v + d.v;
				}
				else
				{
					s1.pop();
					ans += b.v + c.v;
				}
				return true;
			}
		}
	}
}
int ts1,ts2;//特殊的，全为 (-,+) 或 (+,-)
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		cin>>a>>b;
		ts1 += a-b;
		ts2 += b-a;
		if(a >= b)lnum++;
		ans += abs(a - b);
		int v1 = 2 * min(a,b);
		int v2 = 2 * max(a,b);
		v2 = -v2;
		s1.push(st(i,v1));
		s2.push(st(i,v2));
	}
	if(lnum != n && lnum != 0)
	{
		func(true);
	}
	while(func());
	cout<<max(ans,max(ts1,ts2));
}

```

---


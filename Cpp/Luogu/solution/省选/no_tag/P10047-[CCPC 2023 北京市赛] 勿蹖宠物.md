# [CCPC 2023 北京市赛] 勿蹖宠物

## 题目描述

Ene 喜欢回文。

Ene 现在有一些单词。她想选出若干个单词并将它们首尾相连，形成长度恰好为 $L$ 的回文串。每个单词都可以选择多次，也可以不选。

Ene 想知道这样做的方案数。Ene 认为两个方案不同，当且仅当各单词出现次数不同或它们的排列顺序不同，注意多种不同的方案可能会得到同一个回文串。由于答案可能会很大，你需要将答案对 $1,000,000,007$ 取模。

## 说明/提示

**【样例解释 1】**

有以下五种方案：

- `stack` `cats`
- `evil` `olive`
- `eel` `eve` `lee`
- `lee` `eve` `eel`
- `eve` `eve` `eve`

**【样例解释 2】**

有以下两种方案：

- `a` `a`
- `aa`

## 样例 #1

### 输入

```
7 9
cats
eel
eve
evil
lee
olive
stack```

### 输出

```
5```

## 样例 #2

### 输入

```
2 2
a
aa```

### 输出

```
2```

## 样例 #3

### 输入

```
6 12
aa
aab
no
on
pets
step```

### 输出

```
43```

# 题解

## 作者：Alex_Wei (赞：2)

### [P10047 [CCPC 2023 北京市赛] 勿蹖宠物](https://www.luogu.com.cn/problem/P10047)

对每个回文串，考虑它如何被统计入答案。如果只是单侧添加单词，则 DP 过程中难以满足回文的要求。考虑往两侧添加单词，哪一侧长度更短就往哪一侧加入单词，长度相同则规定往左边加入单词。

为了满足回文的限制，记录必要信息，设计 DP $f_{0 / 1, i, j, k}$ 表示当前状态是左侧更长还是右侧更长，较短的一侧长度为 $i$，较长的一侧（从边界开始数）第 $i + 1$ 个字符是第 $j$ 个字符串的第 $k$ 个字符，基于这些信息可以确定回文串已经匹配了左右两侧多少个字符，以及除去左右两侧匹配的 $i$ 个字符之后剩余部分的具体形态。注意 $(j, k)$ 状态总数为 $S = \sum |s_i|$。

转移即枚举要放的一侧放哪个字符串，判定合法性需要预处理 $s_i$ 在 $s_j$ 中的所有出现位置，以及 $s_i$ 的每个前缀和 $s_j$ 对应长度的后缀是否相等。时间复杂度 $\mathcal{O}(nLS + S ^ 2)$。

细节太多不想写怎么办？考虑从外往里依次确定每个字符，需要记录匹配长度，以及左右两侧分别匹配到哪个字符串的第几个字符。若某一侧刚好匹配完，则这一侧需要枚举新的字符串。时间复杂度 $\mathcal{O}(L(n + S) ^ 2)$，但代码非常好写。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using pdd = pair<double, double>;
using ull = unsigned long long;
using LL = __int128_t;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;

constexpr int mod = 1e9 + 7;
void addt(int &x, int y) {
  x += y, x >= mod && (x -= mod);
}
int add(int x, int y) {
  return x += y, x >= mod && (x -= mod), x;
}

// ---------- templates above ----------

constexpr int N = 600 + 5;

pii pos[N], vk[N], vl[N];
int n, L, cnt, lb[N][N];
int f[N][N], g[N][N];
string s[N];
void solve() {
  cin >> n >> L;
  for(int i = 1; i <= n; i++) {
    cin >> s[i];
    for(int j = 0; j + 1 < s[i].size(); j++) {
      pos[++cnt] = {i, j};
      lb[i][j] = cnt;
    }
  }
  f[0][0] = 1;
  for(int p = 0; p < L / 2; p++) {
    memset(g, 0, sizeof(g));
    int tot = 0;
    for(int i = 0; i <= cnt; i++) {
      for(int j = 0; j <= cnt; j++) {
        if(!f[i][j]) continue;
        int pk = 1, pl = 1;
        if(i) vk[0] = {pos[i].first, pos[i].second + 1};
        else {
          pk = n;
          for(int p = 1; p <= n; p++) vk[p - 1] = {p, 0};
        }
        if(j) vl[0] = {pos[j].first, pos[j].second - 1};
        else {
          pl = n;
          for(int p = 1; p <= n; p++) vl[p - 1] = {p, int(s[p].size()) - 2};
        }
        tot += pk * pl;
        for(int _k = 0; _k < pk; _k++) {
          for(int _l = 0; _l < pl; _l++) {
            pii k = vk[_k], l = vl[_l];
            int idk = k.first, pk = k.second, sk = lb[idk][pk];
            int idl = l.first, pl = l.second + 1, sl = pl ? lb[idl][pl - 1] : 0;
            if(s[idk][pk] == s[idl][pl]) addt(g[sk][sl], f[i][j]);
          }
        }
      }
    }
    swap(f, g);
  }
  int ans = 0;
  if(L & 1 ^ 1) {
    for(int i = 0; i <= cnt; i++) addt(ans, f[i][i]);
  }
  else {
    for(int i = 1; i <= n; i++) {
      if(s[i].size() == 1) addt(ans, f[0][0]);
      else {
        addt(ans, f[lb[i][s[i].size() - 2]][0]);
        addt(ans, f[0][lb[i][0]]);
        for(int j = 1; j < s[i].size() - 1; j++) {
          addt(ans, f[lb[i][j - 1]][lb[i][j]]);
        }
      }
    }
  }
  cout << ans << "\n";
}

bool Med;
signed main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) solve();
  fprintf(stderr, "%.3lf ms\n", 1e3 * clock() / CLOCKS_PER_SEC);
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：约瑟夫用脑玩 (赞：2)

楼上比我早发了一篇口胡的题解，思路都一样的，但还是写一下自己的题解吧，毕竟我早在考场就过了这道题，现在顺便帮它补充一下代码。（其实我觉得它的语言已经很简洁了，我只是按照我的写法具体阐述一些细节，故可参考其题解作为补充）

简而言之，如果只是要思路，~~我在考场都能想出来你自己想去~~，看上面的题解其实完全够了，如果要~~贺代码~~了解具体实现，就来看我的学学冗杂繁琐的题解。

方案数肯定还是考虑 DP，由于回文的要求我们从外往里挨个塞串是方便的，我们发现，左边塞一个右边塞一个，在长度不等的情况下会有一边更短，这个时候长的那边就会遗留下来末尾的一段。

这时候我们再枚举在短的那边补哪个串，发现恰好符合题面定义的排列不同的方案区分，且每次在短的那边补也可以保证方案恰好被唯一的考虑到，而相同的长度简单的钦定先放一边即可，钦定这边变成长的另一边是短的。（这里意外的发现都钦定的左边）

具体的，设 $f_{i,j,k}$：

- $i$ 表示左右已经回文匹配的长度，注意我的定义是一半的长度，只代表左边/右边已经匹配完成的长度，总匹配长度是 2 倍。
- $j$ 表示长的串已匹配完恰好所处在位置，我们将每个串的每个位置映射到 $1\sim \sum|s_i|$ 上方便存储，这里特别注意，每个串应该是 $0\sim s_i-1$ 可以充当匹配完的位置，如果把 $s_i$ 都匹配完了，说明长的串也匹配完，左右是一样长的，这时候我们用 $j=0$ 表示两边一样长的状态。
- $k\in\{0,1\}$ 表示长的串所在方向，0 是左边 1 是右边，注意当 $j=0$ 时不存在左右，我们此时钦定 $k=0$，同时注意到 $j=0,k=0$ 两边相同长的时候我们加串只能钦定一边，否则两边都加方案会重，这里我们钦定只加到 $f_{i,j,0}$ 上。

然后 $f_{i,j,k}$ 应当枚举加 $n$ 个串的哪个，然后判断并转移到 $f_{i+len,p,q}$ 上，我们发现这个转移过程与 $i$ 无关，而只要知道 $j,k$，我们枚举加串就可以确定 $len,p,q$，所以提前预处理，判断后把 $len,p,q$ 都记下来，这里我选择了用链表串起来转移 $f$ 的时候直接使用。

然后是统计答案，我们枚举已匹配长度，然后让长串剩余位置恰好填满长为 $L$，注意当 $L$ 为偶数时要加上没有长串，两边恰好匹配了 $\frac L2$ 长度的值，即 $f_{L/2,0,0}$。然后判断回文成功就可以累加了。

最后分析一下复杂度：

- 第一部分预处理，先枚举每个串的每个位置 $O(\sum|s_i|)$，再枚举拼哪个串，但注意要判断是否回文，所以总复杂度为 $O((\sum|s_i|)^2)$。（而不是 $O(n\sum|s_i|)$，虽然都不是瓶颈）
- 第二部分转移，按理来说这里是瓶颈，但我用了链表实际表现良好（跑滴飞快），状态数 $O(L\sum|s_i|)$，转移枚举加哪个串 $O(n)$，由于预处理没有其他复杂度，总复杂度 $O(nL\sum|s_i|)$。
- 第三部分统计答案，先枚举长串剩余长度，每个串奇/偶数位置都有可能复杂度 $O(\sum|s_i|)$，再判断回文 $O((\sum|s_i|)^2)$ 不是瓶颈。

然后就跑过了，40ms 官解的正反双 Trie 还能有我快？肯定是卡常过去的，咱的算法理论复杂度都是优势，最后是代码，附上注释：（由于个人马蜂问题全放太长，只给核心代码）

```cpp
inline int Ck(int a,int b,int c,int d)
{
	int i,k=Min(tt[c],tt[a]-b),p,q;
	for(i=1;i<=k;i++)
	{
		p=d?chr[a][tt[a]-b-i+1]:chr[a][b+i];q=d?chr[c][i]:chr[c][tt[c]-i+1];
		if(p^q)return 0;
	}//预处理判断长串短串是否左右对应回文，注意 d 代表的左右方向
	return 1;
}
inline int ps(int x,int y)
{
	return sm[x-1]+y+1;//第 x 个串匹配完前 y 位置的映射值
}
inline void ade(int a,int b,int c,int d,int e)
{
	nxt[++cnt]=h[a][b];
	val[h[a][b]=cnt]=c;
	flg[cnt]=d;pos[cnt]=e;
}//链表提前预存转移后的状态，回文判断失败的就不再转移
inline int Chk(int a,int b,int c)
{
	int i,k=tt[a]-b;
	if(c)
	{
		for(i=1;i<=k;i++)if(chr[a][i]^chr[a][k-i+1])return 0;
	}
	else
	{
		for(i=1;i<=k;i++)if(chr[a][tt[a]-i+1]^chr[a][tt[a]-k+i])return 0;
	}//长串剩余长度拼成 L，判断最后剩的这段是否中心回文
	return 1;
}
signed main()
{
	#ifndef ONLINE_JUDGE
	freopen("_.in","r",stdin);
//	freopen("_.out","w",stdout);
	#endif
	int i,j,k,f,t,p,l,x,v;char ch;
	n=read();L=read();
	for(i=1;i<=n;sm[i]=sm[i-1]+tt[i],i++)for(ch=gt();ck(ch);ch=gc())chr[i][++tt[i]]=ck(ch);//朴实无华的getchar读入小写字符
	for(i=1;i<=n;i++)for(j=0;j<tt[i];j++)for(f=0;f<2;f++)for(k=1;k<=n;k++)
	{
		if(Ck(i,j,k,f))
		{//预处理判断，插入链表
			if(tt[i]-j==tt[k])ade(f,ps(i,j),tt[k],0,0);
			else if(tt[i]-j>tt[k])ade(f,ps(i,j),tt[k],f,ps(i,j+tt[k]));
			else ade(f,ps(i,j),tt[i]-j,f^1,ps(k,tt[i]-j));//提前讨论转移后的状态存入链表，dp 时直接转移
		}
	}
	F[0][0][0]=1;
	for(i=0;i<=(L>>1);i++)
	{
		for(f=0;f<2;f++)
		{
			for(j=0;j<=sm[n];j++)if((v=F[i][j][f]))
			{//简洁的 dp
				if(!f&&!j)
				{//F[i][0][0]的情况，代表左右匹配长度相同，已无长串
					for(k=1;k<=n;k++)Add(F[i][ps(k,0)][0],v);
				}//枚举加串，我们钦定只放在左边，也就是F[i][p][0]
				else
				{
					for(x=h[f][j];x;x=nxt[x])
					{
						t=flg[x];l=val[x];p=pos[x];
						if(i+l<=(L>>1))Add(F[i+l][p][t],v);
					}//根据链表直接转移！
				}
			}
		}
	}
	ans=!(L&1)?F[(L>>1)][0][0]:0;//注意偶数时加上直接匹配完的情况
	for(i=0;i<=(L>>1)-!(L&1);i++)
	{
		for(j=1;j<=n;j++)if(L-(i<<1)<=tt[j])
		{
			for(f=0;f<2;f++)if(Chk(j,tt[j]-(L-(i<<1)),f))Add(ans,F[i][ps(j,tt[j]-(L-(i<<1)))][f]);
		}//判断中心回文，累加答案
	}
	writenum(ans,10);
	return output;
}
```

---

## 作者：Elma_ (赞：2)

**以下做法纯口胡，出锅的话欢迎指出**。

要求是回文串，只考虑一个方向没法处理相等关系，考虑从两边往中间 DP。

然后我们考虑对每一个回文串钦定一个唯一的生成方式，并且每一步都能比较方便地处理回文匹配的条件。考虑这样：每次在长度较短的一边放一个字符串，如果两边长度相等就在左边放，这样是不重不漏的。

于是考虑设 $f_{i,j,0/1}$ 表示当前串总长为 $i$，左边/右边较长并且匹配到位置 $j$（即多出来的那部分对应哪个前缀或后缀），状态数是 $\mathcal{O}(L \cdot \sum|s_i|)$ 的。转移枚举另一边放哪个串，需要满足能够匹配上，直接暴力预处理是 $\mathcal{O}((\sum|s_i|)^2)$ 的。

最后若 $j$ 对应的前缀或后缀是回文串就把 $f_{L,j,0/1}$ 算进答案，总时间复杂度 $\mathcal{O}(nL \cdot \sum|s_i| + (\sum|s_i|)^2)$。不知道官方题解在干啥。

---


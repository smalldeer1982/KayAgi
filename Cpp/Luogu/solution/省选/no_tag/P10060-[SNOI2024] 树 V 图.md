# [SNOI2024] 树 V 图

## 题目描述

你有一棵 $n$ 个点的无根树，节点的编号为 $1, 2, \ldots, n$。定义树上两点之间的距离 $\operatorname{dis}(i, j)$ 为树上 $i$ 点到 $j$ 点的简单路径上的边数。

现在有 $k$ 个关键点 $a_1, a_2, \ldots, a_k$，对于每个点，我们想求出距离它最近的关键点是哪个点。也就是对于一个点 $v$，令 $f(v)$ 表示令 $\operatorname{dis}(v, a_i)$ 最小的 $i$，如果有多个 $i$ 满足条件，那么我们会选择其中最小的 $i$。

现在，我们给出了 $f(1), f(2), \ldots, f(n)$，问有多少组可能的 $(a_1, a_2, \ldots, a_k)$ 满足条件。由于答案可能很大，输出对 $998244353$ 取模的结果。

## 说明/提示

**【样例 \#1 解释】**

在第一个样例中，对于第二组数据，一个解为 $(1, 2)$。对于第三组数据，两个解为 $(2, 1), (3, 1)$。

注意，当多个点距离相同时，我们选择的是最小的 $i$ 而不是 $a_i$。

---

**【样例 \#3】**

见附件中 `voronoi/voronoi3.in` 与 `voronoi/voronoi3.ans`，这个样例满足测试点 $3 \sim 4$ 的条件限制。

---

**【样例 \#4】**

见附件中 `voronoi/voronoi3.in` 与 `voronoi/voronoi3.ans`，这个样例满足测试点 $7 \sim 10$ 的条件限制。

---

**【数据范围】**

对于所有的数据，保证 $1 \le T \le 10$，$2 \le k \le n \le 3 \times {10}^3$，$1 \le f(i) \le k$。

具体如下：

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $15$ | 无 |
| $3 \sim 4$ | $3000$ | A |
| $5 \sim 6$ | $3000$ | B |
| $7 \sim 10$ | $3000$ | 无 |

特殊性质 A：保证树是一条链。  
特殊性质 B：保证 $k = 2$。

## 样例 #1

### 输入

```
3
3 3
1 2
2 3
1 2 1
3 2
1 2
2 3
1 2 2
3 2
1 2
2 3
2 1 1
```

### 输出

```
0
1
2
```

## 样例 #2

### 输入

```
1
10 5
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
13
```

# 题解

## 作者：Zxd2009 (赞：15)

题目中给出了 $f(v)$，表示令 $\operatorname{dis}(v, a_i)$ 最小的 $i$，也就是离点 $v$ 最近的关键点 “序号”。或者再换一种说法，我们把每个点的关键点 “序号” 看成它的 “**颜色**”。

显然，每个 “序号” 只能对应一个关键点，所以每个 “颜色” 里也只有一个关键点。

结合样例，我们发现，**颜色相同的点** 构成的图一定 **连通**，否则就无解。

感性理解一下，既然是树，那么任意两点之间绝对存在路径。那么，假如让点 $x$ “走到” 距离自己最近的关键点，如果中途遇到 和自己的关键点不同的点 $y$，那么直接走点 $y$ 的路径肯定更短。所以不存在这种情况。

既然这样，我们就把颜色相同的点看成一个整体，对原树进行 **缩点**，得到一个新树。

------

我们发现，某些情况不成立的原因在于，有的点原本应该离自己的关键点更近，现在却离别人的关键点更近。暂且称这种点是错误的。

![](https://cdn.luogu.com.cn/upload/image_hosting/s2r80xbt.png)

如图，假如选择了点 $2$ 和点 $6$ 作为关键点，那么点 $1$ 就是错误的，它应该离黄色关键点更近，可现在离绿色关键点更近。

能够看出，这种情况下必然有一个 错误的点 **在颜色之间的交界处**，毕竟如果不在颜色的交界处 而在内部的话，就不符合刚刚那条 “颜色相同的点一定连通” 的性质了。

反过来，如果没有错误的点在颜色的交界处，也就都没有错误的点。那么这种情况就一定成立。

所以，对于每种情况，我们现在需要 **判断边界处的点是否正确**。

再看一下数据范围：$n \leq 3000$。这意味着我们可以使用 $O(n^2)$ 的算法。

于是，我们可以暴力求出 **每个点对的距离** 和 **每个边界处的点**。我们想知道一种情况是否是正确的，只需要枚举所有颜色的边界，检查边界上的点到底离谁更近，就可以了。

------

接下来，我们就需要引入 **树形 DP**，定义 `f[x][i]` 为 “第 $x$ 种颜色，取点 $i$ 作为关键点，（在缩点后的新树上）这棵树及其子树可选择的方案数”。

我们每访问到一个颜色，首先先把这个颜色下面的子树全都访问一遍，然后枚举自己的关键点 $i$、枚举相邻的颜色（子树） $y$、枚举子树的关键点 $j$。

对于子树 $y$，它内部的方案数 是 选择每个关键点的方案数之和。对于树 $x$，它内部的方案数 是 每个子树的方案数之积。答案当然就是 根节点选择每个关键点的方案数之和。

关于时间复杂度：求每个点对的距离是 $O(n^2)$ 的，预处理之后就可以 $O(1)$ 直接使用；每个边界处的点可以在缩点时顺便求出，是 $O(n)$ 的。上面那个 DP 看起来枚举了很多，实际上颜色 $x$ 和颜色内的点 $i$ 乘起来是枚举 $n$ 个点，相邻颜色 $y$ 和颜色内的点 $j$ 乘起来不足 $n$ 个点，所以还是 $O(n^2)$。

如果还不明白可以看代码。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

const int MOD = 998244353;
vector <int> v[3005], s[3005], g[3005];
int T, n, k, x, y, f[3005], dis[3005][3005], jiao[3005][3005];
bool flag, vis[3005];
long long dp[3005][3005], ans;

void suo(int x, int fa)    // 缩点，把旧图缩成新图 
{
	if(flag)  return;    // 如果输入不合法直接退出 
	if(f[x] != f[fa])    // 如果自己和父亲的颜色不同，即遇到交界处 
	{
		g[f[fa]].push_back(f[x]);    // 更新新图 
		g[f[x]].push_back(f[fa]);
		jiao[f[x]][f[fa]] = x;    // 更新交界处数组 
		jiao[f[fa]][f[x]] = fa;
		
		if(vis[f[x]])  flag = true;    // 如果已经访问过这个颜色，输入不合法 
		vis[f[x]] = true;
	}
	s[f[x]].push_back(x);    // 更新颜色内的点编号 
	for(int i = 0; i < v[x].size(); i++)
	{
		if(v[x][i] != fa)  suo(v[x][i], x); 
	}
}
void juli(int root, int x, int fa, int d)    // 在旧树上暴力 dfs 距离 
{
	// root 和 x 是点 
	dis[root][x] = d;    // root 到 x 的距离为 d 
	for(int i = 0; i < v[x].size(); i++)
	{
		if(v[x][i] != fa)  juli(root, v[x][i], x, d + 1);
	}
}

inline bool check(int gx, int vx, int gy, int vy)    // 检查这种情况是否合法 
{
	// gx 和 gy 是颜色，vx 和 vy 是关键点的编号 
	if(gx > gy)  swap(gx, gy), swap(vx, vy);    // 使得 x 颜色编号小于 y 
	int bx = jiao[gx][gy], by = jiao[gy][gx];    // bx 即为 x 与 y 边界处中颜色为 x 的点 
	// 由于距离相同先取编号较小的点，所以第一个是小于等于，第二个是小于 
	return (dis[bx][vx] <= dis[bx][vy]) && (dis[by][vy] < dis[by][vx]);
}
void dfs(int x, int fa)    // 在新树上进行树形 dp，x 和 fa 是颜色种类 
{
	for(int i = 0; i < g[x].size(); i++)
	{
		if(g[x][i] != fa)  dfs(g[x][i], x);    // 先访问每个子树 
	}
	for(int i = 0; i < s[x].size(); i++)    // 枚举自己颜色的关键点（s[x][i]） 
	{
		dp[x][s[x][i]] = 1;
		for(int j = 0; j < g[x].size(); j++)    // 枚举相邻的颜色（g[x][j]） 
		{
			if(g[x][j] == fa)  continue;
			int y = g[x][j];   long long z = 0;    // z 是子树方案数 
			for(int l = 0; l < s[y].size(); l++)    // 枚举子树颜色的关键点（s[y][l]） 
			{
				// 如果 check 成立，z 加上子树方案数，即求和 
				z = (z + dp[y][s[y][l]] * check(x, s[x][i], y, s[y][l])) % MOD;
			}
			// 当前颜色当前关键点的方案数是所有子树方案数的乘积 
			dp[x][s[x][i]] = (dp[x][s[x][i]] * z) % MOD;
		}
	}
}

int main()
{
	scanf("%d", &T);
	for(int t = 1; t <= T; t++)
	{
		scanf("%d%d", &n, &k);
		flag = false, ans = 0;
		for(int i = 1; i <= n; i++)  v[i].clear();
		for(int i = 1; i <= k; i++)  s[i].clear(), g[i].clear(), vis[i] = false;
		
		for(int i = 1; i < n; i++)
		{
			scanf("%d%d", &x, &y);
			v[x].push_back(y);    // 旧图的建图 
			v[y].push_back(x);
		}
		for(int i = 1; i <= n; i++)
		{
			scanf("%d", &f[i]);
		}
		
		suo(1, 0);    // 先进行缩点 
		if(flag)    // 如果输入不合法直接输出 0 
		{
			puts("0");
			continue;
		}
		for(int i = 1; i <= n; i++)
		{
			juli(i, i, 0, 0);    // 暴力枚举距离 
		}
		
		x = f[1];
		dfs(x, 0);    // 进行树形 dp 
		for(int i = 0; i < s[x].size(); i++)
		{
			// 答案为新树的根节点每种关键点方案数之和 
			ans = (ans + dp[x][s[x][i]]) % MOD;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

如果有错欢迎讨论交流

---

## 作者：xlpg0713 (赞：13)

我现在发现我去年写的这东西太抽象了，所以我选择直接重写一遍，想看我发一堆无意义牢骚的可以看[这里](https://www.luogu.com.cn/paste/2u0yrk21)。

有一些 corner：关键点的 $f$ 值为它本身，故如果存在一个 $x\in[1,k]$ 没有在 $f$ 中出现非法；$f$ 值相同的点一定形如一个连通块。以上的这些东西都可以简单判断。

为方便叙述，我们令 $g_x=a_{f_x}$，及距离 $x$ 最近的关键点的标号。$d(x,y)$ 为 $x$ 和 $y$ 的距离。

注意到一条满足 $f_x\ne f_y$ 的树边 $(x,y)$，不妨令 $f_x<f_y$，可以解释为：$d(x,g_x)-d(y,g_y)\in[0,1]$。

我们关于上文“颜色的连通块”dp。设 $dp_x$ 为满足了 $x$ 所在联通块和该连通块的子树的所有限制，$x$ 是关键点的方案数。初值为 $f_x=1$，答案是 $\sum\limits_{v\le n}[f_v=f_{root}]dp_v$。

我们仍然关于连通块整体转移：现在存在一条满足 $f_x\ne f_y$ 的树边 $(x,y)$，$y$ 是 $x$ 的子节点，我们要将 $y$ 所在连通块的信息向 $x$ 转移。另外设 $w_i$ 为 $\sum\limits_{v\le n\land f_v=f_y\land d(v,y)=i}dp_v$，根据以上的讨论，对于 $x$ 所在连通块的一个点 $o$，会在这一步乘上 $\begin{cases}w_{d(x,o)}+w_{d(x,o)+1}\quad f_x>f_y\\w_{d(x,o)}+w_{d(x,o)-1}\quad f_x<f_y\end{cases}$ 的系数。

根据这个做转移，时间复杂度 $O(n^2)$。不过貌似常数非常小。以下这份代码是我很久前写的，变量名与题解不同，请自己辨别。

```cpp
#include<iostream>
#include<vector>
#define pb push_back
const int p = 998244353;
int n, fl, k, rs, a[3050], f[3050], ct[3050];
std::vector <int> e[3050], o[3050];
inline void gr(std::vector<int> &vc, int x, int fa, int d){
    (vc[d] += f[x]) %= p; for(auto v:e[x]) 
        if(v != fa && a[v] == a[x]) gr(vc, v, x, d + 1);
}
inline void dp(std::vector<int> &vc, int x, int fa, int k, int d){
    f[x] = 1ll * f[x] * (vc[d] + vc[d + (a[x] < k ? -1 : 1)]) % p;
    for(auto v:e[x]) if(v != fa && a[v] == a[x]) dp(vc, v, x, k, d + 1);
}
inline void dfs(int x, int fa){
    ct[a[x]] += a[x] != a[fa];
    if(ct[a[x]] >= 2) return void(fl = 1);
    for(auto v:e[x]) if(v != fa){
        dfs(v, x); if(a[v] != a[x]){
            std::vector<int>vc(n + 5);
            gr(vc, v, x, 1); dp(vc, x, v, a[v], 1);
        }
    }
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);std::cout.tie(0);
    int T; std::cin >> T; while(T--){
        std::cin >> n >> k; rs = fl = 0;
        for(int i = 1; i <= n; i++)
            e[i].clear(), o[i].clear(), ct[i] = 0;
        for(int i = 1, x, y; i < n; i++)
            std::cin >> x >> y, e[x].pb(y), e[y].pb(x);
        for(int i = 1; i <= n; i++) 
            std::cin >> a[i], o[a[i]].pb(i);
        for(int i = 1; i <= n; i++) f[i] = 1;
        dfs(1, 0); for(int i = 1; i <= k; i++)
            if(!ct[i]) {fl = 1; break;}
        if(fl){std::cout << 0 << '\n'; continue;}
        for(auto v:o[a[1]]) (rs += f[v]) %= p;
        std::cout << rs << '\n';
    }
}
```

---

## 作者：听取MLE声一片 (赞：8)

简单题，不妨把关键点视为颜色。

对于一个关键点 $a_i$，$f(a_i)$ 必然等于 $i$，所以每种颜色必须出现过，否则一定不存在合法方案。

颜色相同的点一定在一个连通块内否则一定不合法，这可以简单证明。若不在一个连通块内，则中间一定有其他颜色，则必然有一部分取其他颜色距离更短，所以结论成立。

把每个颜色相同连通块缩成一个点，建出新树（钦定一个颜色作为根），考虑在新树上计数。

设 $f_{u,x}$ 表示颜色 $u$ 选择原树上节点 $x$ 作为关键点子树内的方案数。

初值显然都是 $1$，设 $S_i$ 是颜色为 $i$ 的所有点构成的集合，则转移方程为：

$$f_{u,x}=\prod_{v\in son_u} \sum_{y\in S_v} f_{v,y}g(u,v,x,y)$$

也就是对于枚举儿子，对于每个节点都乘上合法的方案数。

最终答案即为 $\sum_{x\in S_{rt}} f_{rt,x}$。

其中若 $u$ 颜色取 $x$ 作为关键点，$v$ 颜色取 $y$ 作为关键点，两种颜色合法，则 $g(u,v,x,y)=1$，否则 $g(u,v,x,y)=0$。

要求 $g(u,v,x,y)$ 的值，先预处理出原树上两两点之间的距离。因为每种颜色都在一个连通块内，所以两种颜色只有一个位置相邻，若交界点合法，则剩下的点一定合法，找出这两个交界点判断即可。这样可以做到 $O(n^2)$ 预处理，$O(1)$ 查询。

考虑分析转移复杂度。考虑到每个点对至多被枚举到一次，再加上能 $O(1)$ 判断合法性，所以转移复杂度为 $O(n^2)$。

时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$，可以通过此题。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#include<random>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=3010;
const int mod=998244353;
int n,k,ans,a[N],b[N][N],U[N],V[N],vis[N],dis[N][N],f[N][N];
vector<int>e[N],E[N],vec[N];
void init(){
	ans=0;
	for(int i=1;i<=n;i++){
		a[i]=0;
		e[i].clear();
		E[i].clear();
		vec[i].clear();
		vis[i]=0;
		for(int j=1;j<=n;j++)b[i][j]=f[i][j]=dis[i][j]=0;
	}
}
void get(int u){
	if(vis[u])return;
	vis[u]=1;
	vec[a[u]].push_back(u);
	for(int v:e[u])
		if(a[u]==a[v])
			get(v);
}
queue<int>q;
void getdis(int s,int *dis){
	for(int i=1;i<=n;i++)vis[i]=0;
	dis[s]=0;
	q.push(s);
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int v:e[u]){
			if(vis[v])continue;
			dis[v]=dis[u]+1;
			q.push(v);
			vis[v]=1;
		}
	}
}
int check(int u,int v,int x){
	if(dis[u][x]==dis[v][x])
		return a[u]<a[v];
	return dis[u][x]<dis[v][x];
}
void dfs(int u,int fa){
	for(int x:vec[u])
		f[u][x]=1;
	for(int v:E[u]){
		if(v==fa)continue;
		dfs(v,u);
		for(int x:vec[u]){
			if(!f[u][x])continue;
			int res=0;
			for(int y:vec[v])
				if(check(x,y,b[u][v])&&check(y,x,b[v][u]))
					res+=f[v][y];
			res%=mod;
			f[u][x]=f[u][x]*res%mod;
		}
	}
}
void solve(){
	init();
	n=read(),k=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		U[i]=u,V[i]=v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=k;i++){
		for(int j=1;j<=n;j++){
			if(a[j]!=i){
				if(j==n){
					puts("0");
					return;
				}
				continue;
			}
			get(j);
			break;
		}
	}
	for(int i=1;i<=n;i++)
		if(!vis[i]){
			puts("0");
			return;
		}
	for(int i=1;i<=n;i++)
		getdis(i,dis[i]);
	for(int i=1;i<n;i++){
		int u=U[i],v=V[i];
		if(a[u]!=a[v]){
			E[a[u]].push_back(a[v]);
			E[a[v]].push_back(a[u]);
			b[a[u]][a[v]]=u;
			b[a[v]][a[u]]=v;
		}
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
		ans+=f[1][i];
	ans%=mod;
	cout<<ans<<'\n';
}
signed main()
{
	int T=read();
	while(T--)solve();
	return 0;
}


```

---

## 作者：MoSalah (赞：5)

### 题意

一棵 $n$ 个节点的树上有 $k$ 个关键点 $a_1\sim a_k$。定义 $f(v)$ 表示 $v$ 到 $a_i$ 的最小的 $i$。给出 $f(1)\sim f(n)$，求有多少组满足条件的 $(a_1\sim a_k)$。答案模 $998244353$。

### 题解

考虑树形 dp。

无解怎么判？

1. $f(a_i)=i$。如果不符合一定无解。
2. $f$ 相等的点，割到同一个连通块内。如果 $f$ 相等但不处于同一个连通块内，$0$。

可以把一个连通块看作一个点，重新建树，用新树（重新建的树）的树形，对于每一个连通块进行运算，随后树形 dp。

$f_{i,k}$ 表示新树上点 $i$，所在连通块内 $k$ 为关键点的方案数。

$$\displaystyle f_{i,k}=\prod_{j}\sum_{l} f_{j,l}(\text{judge}())$$

其中，$j$ 为 $i$ 的儿子节点，$l$ 是连通块 $j$ 内的关键点 $l$，$\text{judge()}$ 是判断这种方案是否合法。

怎么判断？

有一条连边 $(x,y)$，如果 $f(x)\ne f(y)$，感性理解可知 $|dis(x,a_{f(x)})-dis(y,a_{f(y)})|\le 1$。如果不理解，可以画图或者手模样例。

那么就很好办了，只需要 BFS 求两点之间距离，割连通块，树形 dp。

### 代码

空。

---

## 作者：sunkuangzheng (赞：5)



### 树 $\text V$ 图


考虑 dp。设 $f_{i}$ 表示关键点设在 $i$ 的方案数量，但是难以转移。

观察到一个关键性质：$f(i)$ 相同的点构成一个连通块，否则无解。证明简单：如果构成多个连通块，那么没有 $i$ 的连通块的 $f$ 值必定不等于 $i$。

我们把 $f$ 值相同的点缩在一起形成新树并在**新树**上 dp（注意一定在新树上 dp，否则转移顺序会出错，赛时写的正解就因为这个挂了 /ll）。令 $f_i$ 表示考虑**新树**上以 $i$ 为根的子树并设置关键点的方案数量，枚举新树上 $u$ 的儿子点 $v$ 和 $v$ 内的点 $p$，有方程：

$$f_i = \sum \limits_{u}\prod\limits_{j=1}^m p_j[fk(u,p_j)]$$

其中 $u$ 是新点 $i$ 内的点，$m$ 是新树上 $i$ 的儿子数量，$p_j$ 为从新树上 $u$ 的第 $j$ 个儿子中的点，$[fk(u,p_j)]$ 成立当且仅当在 $u,p_j$ 设置关键点合法。

考虑一个结论：我们判断设置关键点是否合法只需要考虑边界处，如果边界合法，向外扩展也一定合法。至此我们可以用 $\mathcal O(1)$ 计算距离后 $\mathcal O(1)$ 检验。

不能暴力枚举 $p_j$，但是可以做类似“子树合并”式 dp：$x_1y_1+x_1y_2+x_1y_3+x_2y_1+x_2y_2+x_3y_3=(x_1+x_2)(y_1+y_2+y_3)$，只需要维护 $(y_1+y_2+y_3)$ 的值，加入所有 $x$ 后更新这个值即可。

总时间复杂度 $\mathcal O(n^2)$，但实际上随机数据下跑得飞快。

[代码](https://www.luogu.com.cn/paste/h0mflgc4)，因为是考场代码改的所以有很多没有用的变量（）

---

## 作者：SamHJD (赞：3)

## [[SNOI2024] 树 V 图](https://www.luogu.com.cn/problem/P10060)

### 题意

一棵树上有 $k$ 个关键点，各不相同，给出每个点距离最近的关键点 $f_i$，求有多少种放置关键点的方案。

### 解法

显然 $f$ 相同的点处在同一个连通块，否则无解。

证明：假设 $f=a_x$ 的点处在两个连通块 $A,B$ 中。若 $a_x$ 不在 $A,B$ 中，则 $f_{a_x}=a_x$，矛盾。若 $a_x$ 在 $A$ 中，则 $B$ 中任意一点到 $a_x$ 的路径上每个点都满足 $f=a_x$，矛盾。

于是可以将 $f$ 相同的一个连通块缩成一个点处理，考虑朴素的树形动态规划。

设 $dp_{i,j}$ 表示 $i$ 连通块中关键点为 $j$ 的方案数，仅考虑以 $i$ 为根的子树。枚举子节点（连通块）转移：

$$dp_{i,j}=\prod\limits_{v\in son}\sum\limits_{k\in v} f_{v,k}$$

此处 $j,k$ 合法才可转移，设连通块 $i,v$ 交界的两个点为 $x,y\ (x\in i,y\in v)$，则判断 $j,k$ 合法只需判断 $x,y$ 是否满足 $f$ 的限制。

证明：距离 $j$ 最近的 $v$ 中的点为 $y$，其余 $v$ 中的点和 $j$ 的距离均大于 $y$，$k$ 同理。若此两点满足限制，则 $i,v$ 其余的点均满足限制。

### [代码](https://www.luogu.com.cn/paste/e60ebt24)

---

## 作者：DengDuck (赞：3)

死因：颜色连成的图可能不连通（有的颜色没有）。

我的想法比较牛，首先，你把 $a_i$ 当成颜色，那么一个显然的结论是一个颜色的所有点应该组成一个连通块，所以自然想到缩点，一个颜色缩一起，然后建边。

有两种无解情况：

- 颜色连成的图有环。
- 颜色连成的图可能不连通（有的颜色没有）。



然后显然合法的图依旧是一棵树。

我们记录 $F(i\to j)$ 表示颜色连成的图，$i$ 和 $j$ 两个相邻点，$i$ 在走到 $j$ 之前最后一个点

我们设 $f_{i,j}$ 表示当前在处理颜色连成的图的第 $i$ 个点，父亲的那个颜色连通块的那个 $a_i$（就是那个关键点）的距离是 $j$ 的合法方案数。

然后直接转移即可，把不合法的状态判掉即可（判断考虑看离 $F(i\to j)$ 最近的是不是 $a_i$，离 $F(j\to i)$ 最近的是不是 $a_j$）。

感性上合法状态其实会很少。

时间复杂度感性上可以均摊到 $\mathcal O(n^2)$，具体时间复杂度不太会分析。

求大神分析严谨时间复杂度。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
using namespace std;
const int N=3e3+5;
const LL mod=998244353;
int T,n,k,c[N],dis[N][N],vis[N],Link[N][N],dep[N],tot;
unordered_map<LL,LL>f[N];
vector<int>v[N],in[N],V[N];
void prework(int x,int fa)
{
    dep[x]=dep[fa]+1;
    for(int i:v[x])
    {
        if(i==fa)continue;
        if(c[i]!=c[x])
        {
            V[c[x]].pb(c[i]),V[c[i]].pb(c[x]);
            Link[c[x]][c[i]]=x;
            Link[c[i]][c[x]]=i;
        }
        prework(i,x);
    }
}
inline int pd(int x,int fa)
{
    if(vis[x])return 1;
    vis[x]=1;
    for(int i:V[x])
    {
        if(i==fa)continue;
        if(pd(i,x))return 1;
    }
    return 0;
}
LL dfs(int x,int fa,int k)
{
    if(f[x].count(k))return f[x][k];
    LL ans=0;
    int Lk1=Link[fa][x],Lk2=Link[x][fa];
    for(int i:in[x])
    {  
        if(k>dis[Lk1][i])continue;
        if(k==dis[Lk1][i]&&fa>x)continue;
        if(k+1<dis[Lk2][i])break;
        if(k+1==dis[Lk2][i]&&fa<x)break;
        LL cnt=1;
        for(int j:V[x])
        {
            if(j==fa)continue;
            int t=Link[x][j];
            cnt=cnt*dfs(j,x,dis[t][i])%mod;
        }
        ans=(ans+cnt)%mod;
    }
    return f[x][k]=ans;
}
int main()
{
    freopen("voronoi.in","r",stdin);
    freopen("voronoi.out","w",stdout);
    scanf("%d",&T);
    while(T--)
    {;
        
        scanf("%d%d",&n,&k);
        //cerr<<n<<' '<<k<<endl;
        for(int i=1;i<=k;i++)f[i].clear();
        for(int i=1;i<=n;i++)v[i].clear();
        for(int i=1;i<=k;i++)vis[i]=0;
        for(int i=1;i<=k;i++)in[i].clear(),V[i].clear();
        for(int i=1;i<=n-1;i++)
        {
            LL x,y;
            scanf("%d%d",&x,&y);
            v[x].pb(y),v[y].pb(x);
        }
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&c[i]);
            in[c[i]].pb(i);
        }

        prework(1,0);
        if(pd(1,0))
        {
            puts("0");
            continue;
        }      
        LL flg=0;
        for(int i=1;i<=k;i++)
        {
            if(vis[i]==0)flg=1;
        }  
        if(flg)
        {
            puts("0");
            continue;         
        }
        memset(dis,127,sizeof(dis));
        for(int i=1;i<=n;i++)   
        {
            dis[i][i]=0;
            queue<int>q;
            q.push(i);
            while(!q.empty())
            {
                int x=q.front();
                q.pop();
                for(int j:v[x])
                {
                    if(dis[i][j]>dis[i][x]+1)
                    {
                        dis[i][j]=dis[i][x]+1;
                        q.push(j);
                    }
                }
            }
        }
        for(int i=1;i<=k;i++)
        {
            sort(in[i].begin(),in[i].end(),[](LL x,LL y){return dep[x]<dep[y];});
        }
        LL ans=0;
        int rt=c[1];
        for(int i:in[rt])
        {
            LL cnt=1;
            for(int j:V[rt])
            {
                int t=Link[rt][j];
                cnt=cnt*dfs(j,rt,dis[t][i])%mod;
            }
            ans=(ans+cnt)%mod;
        }
        printf("%lld\n",ans);
    }
}

```

---

## 作者：Gmt丶FFF (赞：3)

这是一篇树形 dp 题解。

仔细分析还是挺简单的。

把每种不同的 $f$ 看成一种颜色，不难想到，相同的颜色一定相邻，如果两个颜色相同的点的简单路径上有不同的颜色，那肯定无解了，输出 $0$ 即可。

而且每种颜色至少有一个点，否则无解，这个也易证。

判完两种无解情况以后，我们就可以正常处理这题了，现在问题就转化为了每种颜色有一个关键点，到相同颜色的关键点距离要比到其他关键点的距离更短的方案数。

我们先考虑链的情况，假设颜色 $x$ 与 $y$ 相邻，颜色 $x$ 覆盖的区间为 $[lx,rx]$，颜色 $y$ 覆盖的区间为 $[ly,ry]$，且假设 $ly=rx+1$，那么如果在 $q\in[lx,rx]$ 位置标上关键点，那么对于颜色 $y$ 的关键点，只能在 $ly+rx-q-1,ly+rx-q,ly+rx-q+1$ 这三个点上，其中第 $1,3$ 个点根据 $x,y$ 的大小进行取舍，至于原因很简单，如果离 $ly$ 过近，$rx$ 就会离 $y$ 的关键点更近，如果离 $ly$ 更远，$ly$ 就会离 $x$ 的关键点更近。

换个简单的说法，$y$ 的关键点是 $x$ 的关键点与 $x,y$ 交界处对称的点（根据 $x,y$ 的大小关系上下浮动一格）。

那么对于链的情况，我们就设 $f_{x,i}$ 为对于颜色 $x$，与右端点距离为 $i$ 的方案数。

若 $x>y$，则 $f_{y,ry-ly-i}=f_{x,i}+f_{x,i-1}$。

若 $x<y$，则 $f_{y,ry-ly-i}=f_{x,i}+f_{x,i+1}$。

那么链的情况就成功了，分数也来到了 $40$ pts。

但如果都推出链的情况了，那树的情况也很简单了。

第三个部分分没怎么明白有什么简单的做法，所以直接跳过写正解。

因为树上与自己相邻的颜色有很多种，所以我们再按颜色相邻情况建一棵树，相邻的两种颜色建一条边。

那么跟链上的一样，我们设 $f_{x,i}$ 为对于颜色 $x$，与这个颜色的顶端（即深度最小的那个点）距离为 $i$ 的方案数。

但由于对于同一个 $i$ 可能会有多个点，所以在转移时我们先拆开，后合并。

详细点说，我们再设 $g_z$ 为选择点 $z$ 的方案数。

若 $z$ 到颜色 $x$ 的距离为 $d$，$z$ 到这个颜色的顶端的距离为 $num$，$z$ 对应的颜色为 $y$。

那么若 $y>x$，$q_z=q_z\times(f_{x,d}+f_{x,d+1})$，

若 $x<y$，$q_z=q_z\times(f_{x,d}+f_{x,d-1})$。

当把所有 $x$ 转移完后，再让所有距离顶端为 $num$ 的 $z$ 进行合并，即 $f_{y,num}=\sum q_z$ 即可。

初始所有的 $q_z$ 都为 $1$。

时间复杂度不优秀，为 $O(n^2\log n)$（求 $d$ 需要 lca，所以有 $\log n$），但貌似挺快的？比很多 $n^2$ 的都跑得快。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int mod=998244353;
const int N=3e3+5;
int n,k,c[N],f[N][13],dep[N],g[N][N],topp[N],q[N];
bool vis[N];
vector<int>a[N],p[N],b[N];
void dfs(int x,int fa)
{
	vis[x]=1;
	int len=a[x].size();
	for(int i=0;i<len;i++)
	{
		if(a[x][i]==fa)continue;
		if(c[x]!=c[a[x][i]])
		{
			b[c[x]].push_back(c[a[x][i]]);
			continue;
		}
		dfs(a[x][i],x);
	}
}
void dfs2(int x,int fa)
{
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	for(int i=1;i<=12;i++)f[x][i]=f[f[x][i-1]][i-1];
	int len=a[x].size();
	for(int i=0;i<len;i++)
	{
		if(a[x][i]==fa)continue;
		dfs2(a[x][i],x); 
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i=12;i>=0;i--)if(dep[f[x][i]]>=dep[y])x=f[x][i];
	if(x==y)return x;
	for(int i=12;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
	return f[x][0];
}
int dist(int x,int y)
{
	return dep[x]+dep[y]-2*dep[lca(x,y)];
}
void dfs3(int x,int fa)
{
//	cout<<x<<" "<<fa<<" ????\n";
	int len=b[x].size();
	int len2=p[x].size();
	for(int i=0;i<len2;i++)q[p[x][i]]=1;
	for(int i=0;i<=n;i++)g[x][i]=0;
	for(int i=0;i<len;i++)
	{
		if(b[x][i]==fa)continue;
		dfs3(b[x][i],x);
		for(int j=0;j<len2;j++)
		{
			int num=dist(p[x][j],topp[b[x][i]])-1;
			if(x>b[x][i])q[p[x][j]]=1ll*(g[b[x][i]][num]+g[b[x][i]][num+1])*q[p[x][j]]%mod;
			else
			{
				if(num==0)q[p[x][j]]=1ll*g[b[x][i]][num]*q[p[x][j]]%mod;
				else q[p[x][j]]=1ll*(g[b[x][i]][num]+g[b[x][i]][num-1])*q[p[x][j]]%mod;
			}
//			cout<<x<<" "<<p[x][j]<<" "<<topp[b[x][i]]<<" "<<num<<" "<<q[p[x][j]]<<endl; 
		}
	}
	
	for(int j=0;j<len2;j++)g[x][dep[p[x][j]]-dep[topp[x]]]+=q[p[x][j]],g[x][dep[p[x][j]]-dep[topp[x]]]%=mod;
//	cout<<x<<" "<<g[x][0]<<" "<<g[x][1]<<" "<<g[x][2]<<" "<<g[x][3]<<" "<<g[x][4]<<" ???\n";
}
int main()
{
//	freopen("10.in","r",stdin);
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&k);
		for(int i=1;i<=n;i++)a[i].clear(),vis[i]=0;
		for(int i=1;i<=k;i++)p[i].clear(),b[i].clear();
		for(int i=1;i<n;i++)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			a[x].push_back(y);
			a[y].push_back(x); 
		}
		for(int i=1;i<=n;i++)scanf("%d",&c[i]),p[c[i]].push_back(i);
		bool flag=1;
		for(int i=1;i<=k;i++)
		{
			if(!p[i].size())
			{
				flag=0;
				break;
			}
			dfs(p[i][0],0);
		}
		for(int i=1;i<=n;i++)if(!vis[i])flag=0;
		if(!flag)
		{
			puts("0");
			continue;
		}
		dfs2(1,0);
		for(int i=1;i<=k;i++)
		{
			topp[i]=p[i][0];
			int len=p[i].size();
			for(int j=1;j<len;j++)if(dep[p[i][j]]<dep[topp[i]])topp[i]=p[i][j];
		}
		dfs3(c[1],0);
		int res=0;
		for(int i=0;i<=n;i++)res+=g[c[1]][i],res%=mod;
		printf("%d\n",res);
	}
	return 0;
}
/*
3
3 3
1 2
2 3
1 2 1
3 2
1 2
2 3
1 2 2
3 2
1 2
2 3
2 1 1
*/
```


---

## 作者：nullqtr_pwp (赞：2)

动态的，不确定的问题通常是困难的。常见的思想是从简单的问题开始研究，我们考虑当 $k$ 个关键点都确定了之后怎么去求 $f(u)$。显然可以用 dp 求解，因为有 $f(a_i)=i$，我们不关心怎么求的，但是我们可以发现一个点的 $f(u)$，如果 $u$ 不是关键点，只能从邻域节点中选一个 $x$，将其变成 $f(x)$。选的那个 $x$，可以让 $u\rightarrow a_{f(u)}$ 的路径与 $x\rightarrow a_{f(x)}$ 基本重合，除了边 $(u,x)$。如果考虑将关键点向外做贡献，也就是谁的 $f(x)$ 是这个点，应该是一个染色的过程。

说了这么多，其实我们可以发掘出，**对于相同的 $\textbf{\textit{f}}\textbf{(}\textbf{\textit{u}}\textbf{)}$ 的值，应该构成有且仅有的一个联通块。**

而每个连通块可以缩成一个点，我们只需要从每个连通块中选一个点作为这个颜色的关键点，我们需要将一堆颜色的关键点组合起来，让 $f(u)$ 的取值序列恰好满足题目要求。考虑这样建立一棵新的重构树。


不难想到令 $f[u][x]$ 表示以 $u$ 为根的子树内的染色方案中，要求 $u$ 节点的关键点取在原树的 $x$ 号节点。我们可以通过求 $\text{LCA}$ 的深度去快速求解树上两点间距离。

考虑转移：合并两个子树。我们显然不能全加上，需要判定非法情况。具体就是在新树上记录 $(x,y)$ 表示 $(u,v)$ 颜色的相接是通过原来树的 $(x,y)$ 边相接的。只要 $x,y$ 分别都满足 $f(x)=u,f(y)=v$ 即为合法。

时间复杂度 $O(n^2)$。

[参考代码。](https://loj.ac/s/1982257)

---

## 作者：5k_sync_closer (赞：1)

手玩样例可以发现，把树划分为若干极大同 $f$ 连通块，

若存在 $i$ 满足极大 $f=i$ 连通块不唯一，则无解。证明比较平凡。

另外，若存在 $i$ 满足没有 $f=i$ 的点，也无解。证明比较平凡。

把每个唯一的极大 $f=i$ 连通块缩起来，建出一棵新树 $T$，

设 $f_{i,j}$ 表示钦定 $a_i=j$，然后对 $T$ 上 $i$ 子树中每个 $f=k$ 连通块选定 $a_k$ 的方案数，

可以发现这里 $j$ 一定在 $f=i$ 连通块中，证明比较平凡。

考虑转移，对于符合 $f_{i,j}$ 要求的方案，$i$ 的每个孩子的子树的方案是独立的，

于是 $f_{i,j}$ 即为 $i$ 的每个孩子的子树符合要求的方案数之积，即

$$
f_{i,j}=\prod_{v\in\text{son}(i)}\sum f_{v,k}
$$

其中要求 $a_i=j,a_v=k$ 合法，考虑如何判断这个条件，

发现只需判断 $f=i,f=v$ 连通块交界处的两个点的 $f$ 值在这种情况下是否正确，

预处理相邻连通块交界处的点、原树上任意两点间的距离即可。

```cpp
#include <vector>
#include <cstdio>
#include <cstring>
#define M 998244353
#define int long long
using namespace std;
struct T
{
	struct E
	{
		int v, t;
	} e[6050];
	int c, h[3050];
	void A(int u, int v) { e[++c] = {v, h[u]}, h[u] = c; }
} X, Y;
vector<int> V[3050];
bool b[3050];
int T, n, k, u[3050], v[3050], a[3050], f[3050][3050], d[3050][3050], p[3050][3050];
void D1(int u, int k, int S)
{
	for (int i = X.h[u], v; i; i = X.e[i].t)
		if ((v = X.e[i].v) != k)
			d[S][v] = d[S][u] + 1, D1(v, u, S);
}
void D2(int u, int k, int S)
{
	b[u] = 1;
	V[S].push_back(u);
	for (int i = X.h[u], v; i; i = X.e[i].t)
		if ((v = X.e[i].v) != k && a[v] == S)
			D2(v, u, S);
}
bool C(int x, int y, int k) { return d[x][k] == d[y][k] ? a[x] < a[y] : d[x][k] < d[y][k]; }
void Q(int u, int k)
{
	for (auto i : V[u])
		f[u][i] = 1;
	for (int i = Y.h[u], v; i; i = Y.e[i].t)
		if ((v = Y.e[i].v) != k)
		{
			Q(v, u);
			for (auto i : V[u])
			{
				if (!f[u][i])
					continue;
				int q = 0;
				for (auto j : V[v])
					if (C(i, j, p[u][v]) && C(j, i, p[v][u]))
						q = (q + f[v][j]) % M;
				f[u][i] = f[u][i] * q % M;
			}
		}
}
signed main()
{
	scanf("%lld", &T);
	while (T--)
	{
		for (int i = 1; i <= 3000; ++i)
			V[i].clear();
		X.c = Y.c = 0;
		memset(X.e, 0, sizeof X.e);
		memset(Y.e, 0, sizeof Y.e);
		memset(X.h, 0, sizeof X.h);
		memset(Y.h, 0, sizeof Y.h);
		memset(b, 0, sizeof b);
		memset(u, 0, sizeof u);
		memset(v, 0, sizeof v);
		memset(a, 0, sizeof a);
		memset(f, 0, sizeof f);
		scanf("%lld%lld", &n, &k);
		for (int i = 1; i < n; ++i)
			scanf("%lld%lld", u + i, v + i), X.A(u[i], v[i]), X.A(v[i], u[i]);
		for (int i = 1; i <= n; ++i)
			scanf("%lld", a + i);
		bool F = 1;
		for (int u = 1; u <= k; ++u)
		{
			bool f = 0;
			for (int i = 1; i <= n; ++i)
				if (a[i] == u)
				{
					D2(i, 0, u);
					f = 1;
					break;
				}
			if (!f)
			{
				puts("0");
				F = 0;
				break;
			}
		}
		if (!F)
			continue;
		for (int i = 1; i <= n; ++i)
			if (!b[i])
			{
				puts("0");
				F = 0;
				break;
			}
		if (!F)
			continue;
		for (int i = 1; i <= n; ++i)
			d[i][i] = 0, D1(i, 0, i);
		for (int i = 1; i < n; ++i)
			if (a[u[i]] != a[v[i]])
			{
				Y.A(a[u[i]], a[v[i]]);
				Y.A(a[v[i]], a[u[i]]);
				p[a[u[i]]][a[v[i]]] = u[i];
				p[a[v[i]]][a[u[i]]] = v[i];
			}
		Q(1, 0);
		int q = 0;
		for (auto i : V[1])
			q = (q + f[1][i]) % M;
		printf("%lld\n", q);
	}
	return 0;
}
```


---

## 作者：crimson000 (赞：1)

同学模拟赛场上场切了这题，做法好像和其他人不太一样。

[题目链接](https://www.luogu.com.cn/problem/P10060)

---

下文记 $a_u$ 为题目中的 $f(u)$。

显然相同颜色的点会形成一个连通块，考虑这个连通块的关键点放在哪里即可。

设 $f_{i, j,0/1}$ 表示 $i$ 距离和它同色的关键点距离为 $j$ 时其子树的方案数，$0/1$ 表示 $i$ 的儿子中是否存在一个点距离关键点距离为 $j-1$。显然如果关键点在 $i$ 子树内时最后一维为 $1$，否则关键点不在 $i$ 子树中。

转移可以分第三维为 $0/1$ 两种情况。

- 当第三维为 $0$ 时，让子树中同色的全部第二维为 $j+1$ 然后乘起来，对于不同色的可以分两种情况讨论，记这个不同色的儿子为 $v$，当前点为 $u$。
	- 当 $a_u<a_v$ 时，可以取 $f_{v, j,1}$ 和 $f_{v, j-1,1}$，因为这两种情况不会让 $v$ 变为和 $u$ 同色，也不会让 $u$ 变得和 $v$ 同色。
   - 对于 $a_u>a_v$ 的情况同理，选择 $f_{v,j,1}$ 和 $f_{v, j+1,1}$
- 当第三维为 $1$ 时，枚举哪个儿子选择 $j-1$，同时记录上面讨论情况的前缀积和后缀积即可转移。

时间复杂度 $O(n^2)$，细节比较多，可以看代码。

```cpp
const int N = 3010, mod = 998244353;
ll f[N][N][2];
vector<int> G[N];
int mx[N][2];
int a[N], cnt[N];
int n, k;
int fa[N];

void dfs1(int u, int f)
{
    fa[u] = f;
    for(auto v : G[u])
        if(v != f)
            dfs1(v, u);
}

void dfs2(int u, int f, int d, int &mx)
{
    mx = max(mx, d);
    for(auto v : G[u])
    {
        if(v == f || a[v] != a[u]) continue;
        dfs2(v, u, d + 1, mx);
    }
}

ll ml[N], suf[N][N], pre[N][N];

void merge(int u, int v)
{
    if(a[u] == a[v])
    {
        for(int j = 0; j <= n; j ++ )
            ml[j] = ml[j] * f[v][j + 1][0] % mod;
    }
    else if(a[u] < a[v])
    {
        for(int j = 1; j <= n; j ++ )
            ml[j] = ml[j] * (f[v][j][1] + f[v][j - 1][1]) % mod;
        ml[0] = ml[0] * f[v][0][1] % mod;
    }
    else
    {
        for(int j = 0; j <= n; j ++ )
            ml[j] = ml[j] * (f[v][j][1] + f[v][j + 1][1]) % mod;
    }
}

void dp(int u, int fa)
{
    for(auto v : G[u])
        if(v != fa) dp(v, u);
    for(int j = 0; j <= n; j ++ )
        ml[j] = pre[0][j] = 1;
    for(int i = 0; i < (int)G[u].size(); i ++ )
    {
        int v = G[u][i];
        if(v != fa) merge(u, v);
        for(int j = 0; j <= n; j ++ )
            pre[i + 1][j] = ml[j];
    }
    for(int j = 0; j <= n; j ++ )
        ml[j] = suf[G[u].size()][j] = 1;
    for(int i = (int)G[u].size() - 1; i >= 0; i -- )
    {
        int v = G[u][i];
        if(v != fa) merge(u, v);
        for(int j = 0; j <= n; j ++ )
            suf[i][j] = ml[j];
    }
    for(int j = 0; j <= mx[u][0]; j ++ )
        f[u][j][0] = ml[j];
    f[u][0][1] = ml[0];
    for(int i = 0; i < (int)G[u].size(); i ++ )
    {
        int v = G[u][i];
        if(v == fa) continue;
        if(a[u] == a[v])
        {
            for(int j = 1; j <= mx[u][1]; j ++ )
                f[u][j][1] = (f[u][j][1] + f[v][j - 1][1] * pre[i][j] % mod * suf[i + 1][j]) % mod;
        }
    }
}

void solve()
{
    memset(f, 0, sizeof f);
    memset(mx, 0, sizeof mx);
    for(int i = 1; i <= n; i ++ ) G[i].clear();
    n = read(), k = read();
    for(int i = 1; i < n; i ++ ) 
    {
        int a = read(), b = read();
        G[a].emplace_back(b);
        G[b].emplace_back(a);
    }

    for(int i = 1; i <= n; i ++ ) a[i] = read(), cnt[i] = 0;
    dfs1(1, 0);

    for(int i = 1; i <= n; i ++ )
        if(a[i] != a[fa[i]])
            cnt[a[i]] ++;
    
    for(int i = 1; i <= k; i ++ )
        if(cnt[i] > 1)
        {
            puts("0");
            return;
        }

    for(int u = 1; u <= n; u ++ )
    {
        for(auto v : G[u])
        {
            if(v == fa[u] && a[u] == a[v])
                dfs2(v, u, 1, mx[u][0]);
            else if(v != fa[u] && a[u] == a[v])
                dfs2(v, u, 1, mx[u][1]);
        }
    }

    dp(1, 0);
    ll ans = 0;
    for(int i = 0; i <= mx[1][1]; i ++ )
        ans = (ans + f[1][i][1]) % mod;
    
    cout << ans << endl;
}

int main()
{
    int T = read();
    while(T -- ) solve();

    return 0;
}

// And in that light, I find deliverance.
// 殺してあげる
```

---

## 作者：int_R (赞：1)

[更好的阅读体验](https://www.cnblogs.com/int-R/p/17980674/P10060)

[原题链接](https://www.luogu.com.cn/problem/P10060)

首先想到 $f$ 值相同的点一定构成一个连通块，所以应当有 $k$ 个连通块并且每个连通块 $f$ 值互不相同。

判断一下 $[1,k]$ 是否在 $f$ 中都出现过，并且是否有 $k-1$ 条边两个端点的 $f$ 值不同，若有不符合的就是非法输入，直接输出 $0$。

考虑 $k=2$ 的部分分，对于那个两端点不同的边 $(x,y)$，一个属于 $x$ 所在连通块的点 $i$，一个属于 $y$ 所在连通块的点 $j$，点对 $(i,j)$ 是一组合法答案当且仅当

$$([dis(x,i)=dis(y,j)+1]\wedge[a_x<a_y]\vee[dis(x,i)<dis(y,j)+1])$$

并且

$$([dis(y,j)=dis(x,i)+1]\wedge[a_y<a_x]\vee[dis(y,j)<dis(x,i)+1])$$

于是可以枚举每个点对，时间复杂度 $O(n^2)$。

对于所有数据考虑，每个连通块缩起来以后肯定也构成一棵 $k$ 个节点的树，在这棵树上从下往上处理即可。

具体的，记 $f_i$ 为只考虑 $i$ 所在的连通块及其子树中，最后 $i$ 可以作为关键点的方案数，初始时都是 $1$。对于一个子节点，枚举其中所有的节点来暴力和当前连通块中的节点做上述的匹配。

对于一个 $i$，找到所有合法的 $j$，将 $f_j$ 累加起来再乘到 $f_i$ 上，因为不同的子节点的贡献是相乘的关系。

可以先 $O(n^2)$ 预处理出每个点对的距离，上述算法每个点对只会考虑一次所以是 $O(n^2)$ 的。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int MAXN=3e3+10,MOD=998244353;
int T,n,k,cur,cnt,x[MAXN],y[MAXN],a[MAXN];
long long t[MAXN],f[MAXN],ans;bool vis[MAXN];
vector <int> v[MAXN],p[MAXN][MAXN];
inline void clear()
{
    for(int i=1;i<=n;++i)
    {
        vis[a[i]]=false;t[i]=f[i]=0,v[i].clear();
        for(int j=0;!p[i][j].empty();++j) p[i][j].clear();
    }
    cnt=ans=0;return ;
}
void init(int x,int fa=0,int dep=0)
{
    p[cur][dep].push_back(x);
    for(int y:v[x])
        if(y!=fa&&a[x]==a[y]) init(y,x,dep+1);
    return ;
}
void dfs(int x,int fa=0)
{
    for(int y:v[x])
    {
        if(y==fa) continue;
        if(a[x]==a[y]) dfs(y,x);
        else
        {
            dfs(y,x);
            for(int depy=0;!p[y][depy].empty();++depy)
                for(int j:p[y][depy])
            for(int depx=max(depy-1,0);depx<=depy+1;++depx)//这里有个小优化，但是其实没啥必要也没用
                for(int i:p[x][depx])
                if((depx<depy+1||a[x]<a[y])&&(depy<depx+1||a[y]<a[x]))
                    t[i]=(t[i]+f[j])%MOD;
            for(int depx=0;!p[x][depx].empty();++depx)
                for(int i:p[x][depx]) f[i]=f[i]*t[i]%MOD,t[i]=0;
        }
    }
    return ;
}
inline void work()
{
    clear();cin>>n>>k;
    for(int i=1;i<n;++i)
        cin>>x[i]>>y[i],
        v[x[i]].push_back(y[i]),
        v[y[i]].push_back(x[i]);
    for(int i=1;i<=n;++i)
        cin>>a[i],vis[a[i]]=true,f[i]=1;
    for(int i=1;i<=k;++i)
        if(!vis[i]) {cout<<"0\n";return ;}
    for(int i=1;i<n;++i)
        if(a[x[i]]!=a[y[i]]) ++cnt;
    if(cnt!=k-1){cout<<"0\n";return ;}
    for(int i=1;i<=n;++i) cur=i,init(i);dfs(1);
    for(int d=0;!p[1][d].empty();++d)
        for(int i:p[1][d]) ans=(ans+f[i])%MOD;
    cout<<ans<<'\n';return ;
}
int main()
{
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    cin>>T;while(T--) work();
    return 0;
}
```

---


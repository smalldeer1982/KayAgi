# [GDKOI2024 普及组] 刷野 III

## 题目描述

Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。

但是由于某种神秘原因，Zayin 并不能控制自己打到想打的怪物。具体来说, 存在一个长度为 $n$ 的排列 $p$，Zayin 每次攻击第 $i$ 只怪物时，实际上是在攻击第 $p_i$ 只怪物。

Zayin 每次可以选择一个 $[1, n]$ 的整数 $k$，让第 $p_k$ 只怪物的血量减少 $1$ 点，当某只怪物的血量小于等于 $0$ 时这只怪物死亡。

然而 Zayin 并不知道这个排列 $p$ 具体是什么，也无法看到每个怪物剩余的具体血量，仅可以知道每次攻击完后怪物是否死亡。

现在 Zayin 想知道，在他采取最优策略的情况下，最多需要攻击多少次，才可以杀死 $m$ 只怪物。

## 说明/提示

**【样例解释】**

在第一个样例，Zayin 会一直攻击某一只怪物，直到怪物死亡。

在第二个样例，Zayin 先攻击某一个怪物 $10$ 次，如果没有死亡，则说明攻击的是 $30$ 血的怪物。这时 Zayin 会选择攻击第二只怪物，攻击 $10$ 次后另一只怪物一定死亡，故最差需要 $20$ 次。

**【数据范围】**

对于 $10\%$ 的数据，$1 \leq n, m \leq 5$。

对于另外 $20\%$ 的数据，所有 $a_i$ 全部相等。

对于另外 $30\%$ 的数据，$1 \leq m \leq n \leq 500$。

对于 $100\%$ 的数据，$1 \leq m \leq n \leq 2000$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
2 1
10 15```

### 输出

```
15```

## 样例 #2

### 输入

```
2 1
10 30```

### 输出

```
20```

# 题解

## 作者：pikiuk (赞：9)

irris 的题解太厉害了，我来点不怎么厉害的。

考虑 $m=1$ 的情况，两种极端策略是：

- 我抓住一个一直刀，直到死亡为止。
- 我刀死最小的小怪，如果某只小怪被刀了最小小怪血量次数刀没死，我就换下一只。

继续考虑 $m=1$ 的情况，容易发现我可以在最开始钦定一下我刀死小怪的血量，然后最坏情况下血量大于他的小怪都要被试错他的血量刀数。

仔细思考一下，发现 $m>1$ 也可以这么做，具体的，我们把 $\{a_n\}$ 排序，考虑如果我们钦定了若干小怪 $\{b_m\}$，最后死亡的是 $a_{b_{1\sim m}}$ 的时候我们最坏情况需要的代价。

不难发现根据之前的分析下标在 $(b_k,b_{k+1})$ 的小怪要被试错 $a_{b_{k}}$ 刀，很容易依次设计状态：$f(i,j)$ 表示当前考虑到 $a_i$，确定了 $b_{1\sim j}$ 且 $b_j=i$ 时最坏情况需要的代价。转移的时候枚举 $b_{j-1}$ 转移，有：

$$f(i,j)=\min\{f(k,j-1)+(i-k)\times a_k\}$$

这个式子不难用斜率优化优化，时间复杂度 $\mathcal{O}(n^2)$。

---

## 作者：大眼仔Happy (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P10074)

## 前言

在一篇 20 年的校内训练的博客见到了这道题，只能说这题不是原创题了。

~~昨天模拟赛原封不动考了这 3 个题，但是我懒得抄。~~

然后因为我很菜，于是这篇题解写的颇为详细，也方便大家看懂。

感慨要熟练斜率优化还是得多做题。

## 正文

先从样例入手，样例引导我们有两种方法。一种就是死磕一个，另一种就是选定最小的那个 $a_i$，每一个都试一试这个值。**这是样例想告诉我们的**。但是不一定都是这样的，我们大可以选择中间的某个数 $a_i$，然后就以这个值来尝试。显然这种方法包含了上面的那两种方法。我们先将 $\{a_n\}$ 降序排序，假定选定的是第 $i$ 个数 $a_i$，那么最坏的情况就是前面的数都被尝试了一遍。所以就是 $\min\{a_i\times i\}$。

以上是 $m=1$ 的特殊情况，在我的那个题面是有这一档特殊性质的。下面对其拓展到 $m>1$ 的情况。

同样是先降序排序，然后~~艰难的~~发现我们在 $m=1$ 的性质可以套到这里。假定我们选择的 $m$ 个数的下标是 $\{pos_m\}$（默认 $pos_0=0$），那么就将其分成 $m$ 个区间，第 $i$ 个区间为 $(pos_{i-1},pos_i]$，然后这个东西就按上面 $m=1$  的情况搞。得到的答案就应该是

$${\rm ans}=\displaystyle\sum_{i=1}^m a_{pos_i}\times (pos_i-pos_{i-1})$$

于是就可以 dp 了。

```cpp
for(int i=1;i<=m;i++)
{
	for(int j=1;j<=n;j++)
	{
		for(int k=0;k<j;k++)
		{
			f[i][j]=min(f[i][j],f[i-1][k]+a[j]*(j-k));
		}
	}
}
for(int i=1;i<=n;i++)ans=min(ans,f[m][i]);
```

当然这东西可以被滚掉。

```cpp
for(int tim=1;tim<=n;tim++)
{
	for(int i=1;i<=n;i++)
		for(int j=0;j<i;j++)
			g[i]=min(g[i],f[j]+a[i]*(i-j));
	for(int i=0;i<=n;i++)f[i]=g[i];
}
```


视 $n,m$ 同阶，这个代码就是 $O(n^3)$ 的，理论上还不能通过，~~[实际却可以](https://www.luogu.com.cn/record/146871477)~~。

于是我们经过重重困难，~~尝试~~ 排除若干其他数据结构优化 dp 的方法，最终选定了斜率优化：

假设 $0\le j_1<j_2<i$，且 $j_1$ 优于 $j_2$，那么就有以下关系

$$f_{j_1}+a_i\times (i-j_1)<f_{j_2}+a_i\times (i-j_2)$$

进行整理可得

$$\dfrac{f_{j_1}-f_{j_2}}{j_1-j_2}>a_i$$

于是就是维护一个下凸壳了。

由于 $a_i$ 降序排序，而下凸壳的斜率 $k$ 却是升序，所以这里我们选用的是单调栈而不是单调队列。（因为不弹 head，只弹 tail，而且只取 tail）

时间复杂度就是喜闻乐见的 $O(n^2)$ 了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2005;
ll inline read()
{
	ll num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
int T;
ll n,m,a[N],f[N],g[N],ans;
int h,t,p,q[N];
double slope(int j1,int j2){return 1.0*(f[j1]-f[j2])/(j1-j2);}
void solve()
{
	n=read();m=read();ans=1e18;
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+1+n,greater<ll>());
	memset(f,0x3f,sizeof(f));f[0]=0;
	for(int tim=1;tim<=m;tim++)
	{
		memset(g,0x3f,sizeof(g));
		h=t=1;q[1]=0; // 所以 h 一点用没有
		for(int i=1;i<=n;i++)
		{
			while(h<t&&slope(q[t-1],q[t])>a[i])t--;
			g[i]=f[q[t]]+a[i]*(i-q[t]);
			while(h<t&&slope(q[t-1],q[t])>slope(q[t],i))t--;
			q[++t]=i;
		}
		for(int i=0;i<=n;i++)f[i]=g[i];
	}
	for(int i=1;i<=n;i++)ans=min(ans,f[i]);
	printf("%lld\n",ans);
}
int main(){
	T=1;while(T--)solve();
	return 0;
}
```

---

## 作者：FeelGood (赞：5)

首先，我们先要考虑一下攻击策略。有一个策略是划定一个血线，对每个怪物都去攻击那么多次，然后观察是否有怪物死亡，如果没有就换一个怪物继续攻击。

然后我们就考虑如何划定血线。我们发现没有什么很好的贪心策略那个帮助我们划定攻击的血线，那就考虑用动态规划来求最优解。

先考虑最劣的情况：我们划定的血线为 $a_i$，那我们就需要攻击血量大于 $a_i$ 的怪物和一个血量为 $a_i$ 的怪物。我们设这一个数量为 $x$，那么这一次攻击的代价就为 $x \times a_i$。

已知一共有 $n$ 个怪物，先对 $a_i$ 从小到大排序，这样方便求解血量大于等于划定血线的怪物数量，也方便后续处理。我们考虑设 $f_{i,j}$ 表示前 $i$ 个怪物，已经击杀了 $j$ 个，且当前划定的血线为 $a_i$，需要的最少攻击次数。然后我们可以推出一个状态转移方程为 

 $$ f_{i, j} = \min_{k < i}\{f_{k, j - 1} + a_i \times (n - i + 1)\}$$
 
但是这个方程是有问题的，上一次划定血线时，我们已经攻击了所有血量大于等于 $a_k$ 的怪物，那这一次所需要攻击的次数是需要减去上一次的影响的。所以，正确的状态转移方程为

 $$ f_{i, j} = \min_{k < i}\{f_{k, j - 1} + (a_i - a_k) \times (n - i + 1)\}$$
 
此时我们的时间复杂度是 $O(n^3)$ ，显然过不了，我们要考虑优化。我们发现这个式子很想斜率优化的式子，于是我们可以使用斜率优化。我们先不考虑取最小值的问题，直接把式子展开、变形。此时我们可以得到 $f_{i, j} - a_i \times (n - i + 1) + a_k \times (n - i + 1) = f_{k, j - 1}$。

对比 $y = kx + b$，我们可以得到 $y = f_{k, j - 1}$，$k = n - i + 1$，$x = a_k$，$b = f_{i, j} - a_i \times (n - i + 1)$，然后斜率优化即可。但是这里我们的斜率是递减的，所以我们实际上要维护一个单调栈，而不是单调队列。同时计算斜率时会爆 ```long long```，需要用 ```__int128```。

代码如下
```cpp
#include <bits/stdc++.h>

#define ll long long
#define lll __int128

using namespace std;

namespace IO
{
	void read() {}
	template <typename T1, typename ...T2>
	void read(T1 &n, T2 &...m)
	{
		T1 op = 1;
		char c;
		while (isdigit(c = getchar()) == false)
			if (c == '-') op = -1;
		n = c ^ 48;
		while (isdigit(c = getchar()))
			n = (n << 1) + (n << 3) + (c ^ 48);
		n *= op;
		return read(m...);
	}
}

using IO::read;

namespace Solve
{
	const int MaxN = 2e3;
	
	ll f[MaxN + 10][MaxN + 10], a[MaxN + 10];
	int q[MaxN + 10], h, t;
	
	lll dx(int i, int j) {return a[j] - a[i];}
	lll dy(int id, int i, int j) {return f[j][id] - f[i][id];}
	
	void Sol()
	{
		int n, m;
		read(n, m);
		for (int i = 1; i <= n; ++i)
			read(a[i]);
		sort(a + 1, a + n + 1);
		memset(f, 0x3f, sizeof f);
		f[0][0] = 0;
		for (int j = 1; j <= m; ++j)
		{
			h = 1, t = 0;
			for (int i = 1; i <= n; ++i)
			{
				while (h < t && dy(j - 1, q[t - 1], q[t]) * dx(q[t], i - 1) >= dy(j - 1, q[t], i - 1) * dx(q[t - 1], q[t]))
					--t;
				q[++t] = i - 1;
				while (h < t && dy(j - 1, q[t - 1], q[t]) >= dx(q[t - 1], q[t]) * (n - i + 1))
					--t;
				int id = q[t];
				f[i][j] = f[id][j - 1] + (a[i] - a[id]) * (n - i + 1);
			}
		}
		ll ans = LLONG_MAX;
		for (int i = 1; i <= n; ++i)
			ans = min(ans, f[i][m]);
		printf("%lld\n", ans);
	}
}

using Solve::Sol;

int main()
{
	Sol();
	return 0;
}
```

---

## 作者：toolong114514 (赞：3)

# P10074 [GDKOI2024 普及组] 刷野 III 题解
说句闲话：在 GDKOI2024 现场只写了一档特殊性质，居然还爆了，一分不得，~~太菜了~~。
## 题面大意
[传送门。](https://www.luogu.com.cn/problem/P10074)
## 解题思路
### $10\%$（第一档部分分）
~~容易发现乱搞就行。~~
### 另外的 $20\%$（第二档部分分）
我们发现所有的 $a_i$ 相等，那么直接打 $m\cdot a_i$ 次就行。
### $50\%$（第三档部分分）
我们知道哪些怪物死亡，那么可以知道当前存活的怪物的情况。

如果想要刀掉某只存活的怪物，那么钦定一个血量，刀掉所有比它大的怪物，再击杀一个一定会死，这样才是最坏情况。

我们已知每只怪物最初的血量，每次钦定血量杀怪，都会把活着的减血。剩余的血量是可以计算的。

钦定的血量一定是逐渐递增的，而且正好是某个怪物的当前血量，否则一定不会更优。

因此，我们尝试对 $a$ 从小到大排序，再来分析策略。

每次钦定怪物的时候，要考虑两件事：

- 上一次钦定了哪个血量？
- 这一次的代价？

上一次钦定的血量是比这次钦定的血量小的，上文已有论述。这也是我们对 $a$ 排序的依据。

我们对钦定的血量，最多把比这个多的怪物都打一遍，再打一个一定会死。

定义 $f_{i,j}$ 为对于前 $i$ 个怪，杀了 $j$ 个怪，且杀死了初始血量小于等于 $a_i$ 怪物的最小代价。

得到状态转移方程如下

$$f_{i,j}=\min_{k<i}\{f_{k,j-1}+(a_i-a_k)(n-i+1)\}$$

直接暴力枚举转移，时间复杂度约为 $O(n^2m)$，可以通过 $1\le m\le n\le500$ 的数据，拿到 $50\%$ 的分数。卡常卡的好的情况下，甚至可以拿到 $80$ 到 $90$ 分，甚至直接满分：[来源](https://www.luogu.com.cn/discuss/805313)以及[提交记录](https://www.luogu.com.cn/record/155161258)。

核心转移代码：
```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=n&&j<=m;j++){
		for(int k=0;k<i;k++){
			f[i][j]=min(f[i][j],f[k][j-1]+(a[i]-a[k])*(n-i+1));
		}
	}
}
for(int i=1;i<=n;i++){
	ans=min(ans,f[i][m]);
}

```

### 正解
刚才的 DP 式子可以斜率优化。

将状态转移方程写作以下形式：

$$f_{i,j}=\min_{k<i}\{-a_k\cdot (n-i+1)+f_{i,j-1}\}+a_i\cdot(n-i+1)$$
令 $k'=-a_k$，$x=n-i+1$，$b'=f_{i,j-1}$，则原式写作：

$$f_{i,j}=\min_{k<i}\{k'x+b'\}+a_i\cdot(n-i+1)$$

那么问题转化成了若干条直线，在指定横坐标下，纵坐标的最小值。

考虑用[李超线段树](https://oi-wiki.org/ds/li-chao-tree/)维护（不会的点蓝字了解）。

总的时间复杂度约为 $O(nm\log{n})$，可以通过本题。
## 参考代码
```cpp
#include<iostream>
#include<cmath>
using namespace std;
const int N=2e5+10;
struct node{
	int l,r,fa[600];
}bl[500];
int find(int x,int num){
	if(bl[num].fa[x]==x) return x;
	else return bl[num].fa[x]=find(bl[num].fa[x],num); 
}
void connect(int x,int y,int num){
	bl[num].fa[find(x,num)]=find(y,num);
}
int len,cnt;
int n,q;
int a[N],blo[N];
void build(){
	len=sqrt(n);
	for(int i=1;i<=n;i+=len){
		cnt++;
		bl[cnt].l=i;
		bl[cnt].r=min(i+len-1,n);
		for(int j=bl[cnt].l;j<=bl[cnt].r;j++){
			blo[j]=cnt;
		}
		for(int j=1;j<=bl[cnt].r-bl[cnt].l+101;j++){
			bl[cnt].fa[j]=j;
		}
		for(int j=1;j<=bl[cnt].r-bl[cnt].l+1;j++){
			connect(j,a[j+bl[cnt].l-1]+bl[cnt].r-bl[cnt].l+1,cnt);
		}
	}
}
int tmp[505];
void upd(int x,int y,int v1,int v2){
	int ql=blo[x],qr=blo[y];
	if(x==y){
		for(int i=1;i<=bl[ql].r-bl[ql].l+1;i++){
			tmp[i]=find(i,ql);
		}
		for(int i=x-bl[ql].l+1;i<=y-bl[ql].l+1;i++){
			if(tmp[i]==v1+bl[ql].r-bl[ql].l+1) tmp[i]=v2+bl[ql].r-bl[ql].l+1;
		}
		for(int i=1;i<=bl[ql].r-bl[ql].l+101;i++){
			bl[ql].fa[i]=i;
		}
		for(int i=1;i<=bl[ql].r-bl[ql].l+1;i++){
			connect(i,tmp[i],ql);
		}
		return;
	}
	for(int i=ql+1;i<qr;i++){
		if(v1+bl[i].r-bl[i].l+1!=find(v1+bl[i].r-bl[i].l+1,i)) continue;
		if(v2+bl[i].r-bl[i].l+1==find(v2+bl[i].r-bl[i].l+1,i)){
			connect(v1+bl[i].r-bl[i].l+1,v2+bl[i].r-bl[i].l+1,i);
		}else{
			bl[i].fa[v1+bl[i].r-bl[i].l+1]=v2+bl[i].r-bl[i].l+1;
			bl[i].fa[v2+bl[i].r-bl[i].l+1]=v2+bl[i].r-bl[i].l+1;
		}
	}
	for(int i=1;i<=bl[ql].r-bl[ql].l+1;i++){
		tmp[i]=find(i,ql);
	}
	for(int i=x-bl[ql].l+1;i<=bl[ql].r-bl[ql].l+1;i++){
		if(tmp[i]==v1+bl[ql].r-bl[ql].l+1) tmp[i]=v2+bl[ql].r-bl[ql].l+1;
	}
	for(int i=1;i<=bl[ql].r-bl[ql].l+101;i++){
		bl[ql].fa[i]=i;
	}
	for(int i=1;i<=bl[ql].r-bl[ql].l+1;i++){
		connect(i,tmp[i],ql);
	}

	for(int i=1;i<=bl[qr].r-bl[qr].l+1;i++){
		tmp[i]=find(i,qr);
	}
	for(int i=1;i<=y-bl[qr].l+1;i++){
		if(tmp[i]==v1+bl[qr].r-bl[qr].l+1) tmp[i]=v2+bl[qr].r-bl[qr].l+1;
	}
	for(int i=1;i<=bl[qr].r-bl[qr].l+101;i++){
		bl[qr].fa[i]=i;
	}
	for(int i=1;i<=bl[qr].r-bl[qr].l+1;i++){
		connect(i,tmp[i],qr);
	}	
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	build();
	cin>>q;
	while(q--){
		int ll,rr,xx,yy;
		cin>>ll>>rr>>xx>>yy;
		upd(ll,rr,xx,yy);
	}
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=bl[i].r-bl[i].l+1;j++){
			cout<<find(j,i)-(bl[i].r-bl[i].l+1)<<" ";
		}
	}
	return 0;
}
```
和直线方程相关的部分要开 ```__int128```，不然有 ```WA``` 的可能！

[本代码可以通过洛谷的评测。](https://www.luogu.com.cn/record/162538076)
## 后记
这是一道相当有实力的 DP 题，“钦定血量”的思路反常规，思考量较大，不易在考场上写出来。

~~懒癌晚期，GDKOI 过去了半年才来补题。~~

Written by [toolong114514](www.luogu.com/user/toolong114514) on 2024/6/19.

---

## 作者：irris (赞：2)

> 动态规划，dp / 基础优化

## Preface

Zayin 你这么给部分分的？？？？？？？？？

## Solution

首先我们考虑，Zayin 的策略其实只有两种：

- 选择一个怪物 $u$，持续攻击直到杀死它。
- 选择一个怪物 $u$ 和一个血量线 $a_v$，若攻击 $u$ 了 $\geq a_v$ 次还没死就把 $u$ 扔到一边去不再攻击。

考虑为什么只有这两种策略。例如 $a = [1 ,2, 4]$，聪明的你告诉我，我先全局打 $1$，再全局打 $1$，这样最劣代价也是 $5$。事实上，通过转置视角，我们自然可以将其描述至 $\lang u = 1, a = 2\rang\lang u = 2, a = 2\rang\lang u = 3(, a = 1)\rang$ 这样的策略序列，而且代价是一样的。

这启发我们的是，所有奇怪策略都可以转化为策略二，所有策略一都可以认为转化为策略二；策略二的执行顺序是 $a$ 从大到小。

考虑如果我们确定了策略二的序列 $a_{v_1}, a_{v_2} \dots a_{v_n}$，如何计算答案。首先要判别的是无解情况：如果我们存在一个 $1 \sim n$ 的排列 $p$ 满足 $\sum [a_{p_i} \gt a_{v_i}] \gt n - m$ 则无解。然后我们肯定按照 $a_1 \dots a_n$ 从小到大的顺序，能匹配则尽量匹配一个，这样的方式，这肯定是最优的。

欲求的答案，则是对于任何一个 $1 \sim n$ 的排列，求 $\sum \min(a_{v_i}, a_{p_i})$ 的最大值；显然，第 $k$ 小和第 $k$ 小一一配对是所能达到的最优解。

因此做法呼之欲出：先对 $a$ 数组排序，然后，设 $dp_{i,j,l}$ 表示确定了策略二序列的前 $i$ 个元素，目前匹配上了 $j$ 个元素，上一个元素是 $l$，答案的最小值。初值 $dp_{0,0,0} = 0$。

转移，枚举下一个元素 $k \in [l, n]$，那么 $dp_{i+1,j+[a_{i+1} \gt a_k],k}$ 与 $dp_{i,j,l} + \min(a_{i+1}, a_k)$ chkmin。答案，$dp_{n,0\sim (n-m), 0\sim n}$。

这个看起来是来搞笑的，因为它是 $\mathcal O(n^4)$ 的，**仅能通过测试点 $\color{red}1$**。所以考虑优化：

- 分类讨论 $a_{i+1}$ 与 $a_k$ 的大小关系：
	- 如果 $a_k \lt a_{i+1}$：$dp_{i,j,k} \gets \min\limits_{0 \leq l \leq k}(dp_{i,j-1,l}) + a_k$；
	- 如果 $a_k \geq a_{i+1}$：$dp_{i,j,k} \gets \min\limits_{0 \leq l \leq k}(dp_{i,j,l}) + a_{i+1}$。

发现我们只需要维护 dp 数组的前缀 min 即可 $\mathcal O(n^3)$，但是这个优化 **仅能通过测试点 $\color{red}1,4,5,6$**。如果拼上性质分可以额外拿下 $2,3$，但是这个特殊性质未免有点太搞笑了些，为啥要给 20 分？？？？

接着优化。我们把 dp 数组放在一个 $j$ 作为纵轴、$k$ 作为横轴的平面直角坐标系的视角下观察（$0 \leq j \leq n - m$，$0 \leq k \leq n$）。发现每次是左边半个平面整体往上平移（没有的值会被填充为 $+\infin$），然后每一列加同一个值，最后每一行 chk 前缀 min。

发现，移动的部分会继续移动下去，它们的行关系保持不变了。在同一行内，由于 $a_1 \leq a_2 \leq \dots \leq a_n$，所以，设第一个不是 $+\infin$ 的位置是 $(j, k)$，那么 $t(\geq 1)$ 时刻后，这一部分该行的所有非 $\infin$ 值都会是 $dp_{j,k} + ta_k$。

所以我们只需要在 $i \to i + 1$ 之后，$k$ 变大，然后一些 $(j, k)$ 开始移动的时候，计算每个这样的 $(j, k)$ 最终能不能被最终结算到，然后贡献一下最后答案即可。对于没有开始移动的部分，维护也是简单的，因为容易发现每行的值都相同。我们只要时刻维护平移分界线两旁各一列的 dp 值即可。

因此问题在 $\mathcal O(n^2)$ 时间复杂度下得到了解决。

---

## 作者：__xxy_free_ioi__ (赞：1)

# 题解：P10074 \[GDKOI2024 普及组] 刷野 III

斜优，启动！！！

## 解法

考虑动态规划。

不难发现，主人翁有两种策略：

1. 逮住一个怪物 $x$，一直肘到死。
2. 逮住一个怪物 $x$，并选择一个血量线 $a_i$，如若肘了 $a_i$ 下还没有肘死，我们就扔掉换一只肘。

那么，在最劣的情况下，我们就要把血量 $\ge a_i$ 的全部肘一遍。所以，我们可以从小到大排个序，那么就有 $n-i+ 1$ 个怪物被肘了 $a_i$ 下，代价就是 $a_i \times (n-i+1)$。

设 $f_{i,j}$ 表示在前 $i$ 个怪物中，有 $j$ 个怪物已经被肘死了，并且钦定 $a_i$ 为血量线。假设前面在 $k$ 时已经划分过一次血量线，那么此时 $a_i$ 其实已经被肘掉了 $a_k$ 的血量了，所以，转移方程就是 $f_{i,j} = \min_{k < i} \left\{ f_{k,j-1} + (a_i-a_k) \times (n-i+1) \right\}$。

但是这还没完，$O(n^3)$ 次方还不足以通过此题（~~为啥我总感觉洛谷神机可以过？~~），所以，斜率优化即可。不会斜率优化的小伙伴可以看看这篇[题解](https://www.luogu.com.cn/article/8v0t07uz)。

## 代码

```
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define db double
#define up(i, s, t) for (int i = s; i <= t; i++)
#define down(i, s, t) for (int i = s; i >= t; i--)

const int N = 2010;

int n, m;
int a[N], f[N][N], s[N];

int y(int ix, int iy, int j) { return f[ix][j] - f[iy][j]; }
int x(int ix, int iy) { return a[ix] - a[iy]; }
int l(int i) { return n - i + 1; }
db k(int ai, int bi, int j) { return 1.0 * y(ai, bi, j) / x(ai, bi); }

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    up(i, 1, n) cin >> a[i];

    sort(a + 1, a + n + 1);
    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;

    up(j, 1, m) {
        int t = 0;
        up(i, 1, n) {
            while (t > 1 && k(s[t - 1], s[t], j - 1) >= k(i - 1, s[t], j - 1)) t--;
            s[++t] = i - 1;
            while (t > 1 && k(s[t - 1], s[t], j - 1) >= l(i)) t--;
			int kk = s[t];
            f[i][j] = f[kk][j - 1] + (a[i] - a[kk]) * l(i);
        } 
    }

    int res = 1e18;
    up(i, 1, n) res = min(res, f[i][m]);
    cout << res << '\n';
    
    return 0;
}
```

---

## 作者：wujingfey (赞：1)

## 一篇不用斜率优化 DP 的题解

[传送门](https://www.luogu.com.cn/problem/P10074)

题意描述有点复杂，略过了。

## 题解
说在前面：~~这是一篇充分发挥人类智慧的题解~~。关于正确性：还没严谨证明，但通过了本题且和 std 对拍了一下午，没拍出问题。

首先把怪物的血量**从高到低**排序，画在坐标系上如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rgsmc96a.png)

如果我们的玩家是个莽夫，怼着一个怪打直到打死它，根据题意玩家是个倒霉蛋只会打血最后的 $m$ 只怪物，所以我们的花费如图（黑色部分）：
![](https://cdn.luogu.com.cn/upload/image_hosting/zm1h09pw.png)

但显然我们的玩家很聪明，会用别的方案打怪兽。比如我们可以选择一个 $x$，选择怪兽打 $x$ 次，如果没打死就换另一只。花费如图（黑色部分）：

![](https://cdn.luogu.com.cn/upload/image_hosting/r6wb38b5.png)

那么现在有一种~~人类智慧~~的杀怪方法：

1. 先选择一个比较小的 $x_1$，对每个怪物干 $x$ 刀，杀死血量较少的若干只怪物。
![](https://cdn.luogu.com.cn/upload/image_hosting/d6o1u956.png)
2. 在剩下的怪物中，我们选择另外一个 $x_2$，对活着的怪物打 $x_2$ 刀，直到杀满 $m$ 只怪物。

![](https://cdn.luogu.com.cn/upload/image_hosting/osquan8r.png)

先枚举 $x_1$ 杀死的怪物数，然后对每种情况，继续枚举 $x_2$，据剩下的怪物数量计算答案。在枚举 $x_2$ 的时候用前缀和优化可以把复杂度优化到 $O(nm)$。

## CODE:
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2005,INF=1e18+7;
int T,a[N],b[N],sum[N],n,m,ans=INF;
bool cmp(int a,int b){
	return a>b;
}
int solve(int N,int M){//在前N个的中间选择 M个 
    int minn=INF;
    for (int i=1;i<=N-M+1;i++){//从i开始杀起 
        int res=sum[i+M-1]-sum[i-1]+b[i]*(i-1);
		//前缀和优化 
        minn=min(minn,res);
    }
    return minn;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin>>n>>m;
	for (int i=1;i<=n;i++){
	   	cin>>a[i];
	}
	sort(a+1,a+1+n,cmp);
	for (int i=0;i<=m;i++){//用x1扫后面i个 
	    int res=0;
	    for (int j=n;j>=n-i+1;j--){
	    	res+=a[j];
		}
	    for (int j=1;j<=n-i;j++){
			//前面 n-i个因为运气不好也被扫了 
	    	b[j]=a[j]-a[n-i+1];
	    	//b表示剩余血量
			res+=a[n-i+1];
			sum[j]=sum[j-1]+b[j];
			//前缀和 
		}
	    ans=min(ans,solve(n-i,m-i)+res);
    }
	cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Astatinear (赞：0)

### [P10074 [GDKOI2024 普及组] 刷野 III](https://www.luogu.com.cn/problem/P10074)

$\text{Tag : }$ 动态规划，斜率优化。

难点在于模型的构建。

首先，不难想到一个 $m=1$ 的做法，就是说你去钦定一个试错最大值 $\text{lim}$。对于每次打怪，无脑操作 $\text{lim}$ 次，如果还没到 $\text{lim}$ 次就死了，那就下一只，否则就跳过这一只。

容易发现，假设有 $x$ 只怪物的血量 $> \text{lim}$，也就是说，你在最优策略下，最多需要 $(x+1)\times \text{lim}$ 次操作，通过调整 $\text{lim}$ 的值从而得到 $m=1$ 的最优解。（且可以发现我们每次打死的那只怪的血量一定等于 $\text{lim}$。）

考虑对于 $m>1$ 的情况进行扩展。先将原数组降序排序，假设我们最终打死的 $m$ 只怪物的编号分别是 $b_{1},b_2,...,b_m$（编号对应的是排完序之后的序列，且不妨设 $b_i<b_{i+1}$）。最优策略显然是我们对于打死的每只怪 $b_i$，对于 $(b_{i-1},b_i]$ 这中间的所有怪，使用 $m=1$ 的办法，将 $b_i$ 当作 $\text{lim}$，从而得到当前区间的最优解。然后把所有区间加起来就是答案。

由于不知道打死的编号序列，考虑 $\text{dp}$ 这个过程：

+ 定义 $dp_{i,j}$ 表示 $b_j=i$ 时，当前杀死所有怪的最优策略所需的最少攻击数。
+ 故有 $dp_{i,j}=\min_{k=1}^i\{ dp_{k-1,j-1}+a_i\times (i-k+1)\}$。
+ $dp_{n,m}$ 即是答案。
+ 此时时间复杂度 $\mathcal{O}(n^2m)$。
+ 注意到内部的转移式子是一个非常典型的斜率优化，可以直接套板子，将复杂度降为 $\mathcal{O}(n\times m)$。

---


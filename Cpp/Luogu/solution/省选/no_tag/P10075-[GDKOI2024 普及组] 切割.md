# [GDKOI2024 普及组] 切割

## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向连通图，**有**重边无自环。

ymqOAO 现在有 $k$ 个询问。每次询问如果删去图中的 $c_i$ 条边，剩下的图是否还是连通的。

注意：询问之间是相互独立的，即一个询问的删边不会影响之后的询问。

注解：
- 连通图：一个图中任意两个顶点都有路径相连。

## 说明/提示

对于 $10\%$ 的数据，$1 \leq m, n, k \leq 2000$。

对于另外 $10\%$ 的数据，$m = n-1$。

对于另外 $10\%$ 的数据，$c_i = 1$。

对于 $60\%$ 的数据，$1 \leq m, n, k \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq m, n, k \leq 10^6$。

## 样例 #1

### 输入

```
4 5
1 2
2 3
3 4
4 1
2 4
3
1 5
2 2 3
2 1 2```

### 输出

```
ymqOAO
Bob
ymqOAO```

# 题解

## 作者：sevenki (赞：13)

tag: 随机赋权、线性基（不是必须的）

大概是比较有意思的题目。

但是，这是一道原题。[Luogu P5227](https://www。luogu。com。cn/problem/P5227)

这道题的难点主要在于：

- 想到随机赋权。
- 知道怎么赋权。

在赛场上原题面的数据范围下，这道题读入估计得花 $1$ 个月。

后来出题人把 $c$ 的数据范围改成和原题一模一样。

### 思路

下面说本题做法。

随机赋权，使删去一些边，使得图刚好不联通的边集的权值异或值为 $0$。

“刚好不联通” 指的是，少删任意一条都能连。

怎么办呢？

我们考虑几个简单情况。

对于一个点，把所有和他相关的边切掉，图就不联通了。因此，一个点的所有连边的异或值为 $0$。

如果按照这个方法赋权，那么：

对于一个联通的点集，与外界（两点非联向该点集的边）的边权异或值将会是什么？

每个点连的边的异或值为 $0$。点集里，每个点都按照这样算一次，异或值显然为 $0$。

此时，联向外面的边由于一端联向点集中，因此被计算 $1$ 次。
联向里面的边由于 $2$ 端联向点集中，因此被计算 $2$ 次，直接就抵消了。

那么结果其实就是联向外面的边权异或值。而结果为 $0$。

于是，只要能构造出“一个点的所有连边的异或值为 $0$” 的图，问题就解决了。

### 构造方法：

随便来一棵生成树。

对于图中不在树上的边，随机赋权。

父亲联向孩子的边，就是孩子的除了联向父亲之外其余边的异或和。

这样子就能保证每个点的所有连边的异或值为 $0$。

由于权值随机，所以不符合条件，异或值却恰恰为 $0$ 的概率比较小。这样子我们就从概率上解决了这个问题。

**注意，出错的概率随着 $c_i$ 增大而增大。这个问题在后面会有细致的说明。**

### 解决询问

对于每次询问，如果其中任意几条边的异或和为 $0$，那么把它们删掉图就不联通。

如果暴力枚举边集，复杂度就会达到 $2^c$。然而，在 $c\leq 4$ 的情况下，暴力枚举的方法跑的飞快。

如何才能去掉这个指数，使得 $c$ 的范围可以更大？

我们可以考虑线性基。

用线性基可以在 $O(c \log w)$ 的时间内判断几个数中是否有异或和为 0 的组合。

线性基可以动态插入，也可以高斯消元。前者容易写得多。

这样子，我们就可以在时间上通过 $\sum c \log w$ 的数据。**不保证正确性。** 我的意思是，在 $c$ 大的情况下，正确性几乎为 $0\%$。

### 关于概率

为什么我们的随机算法不能通过 $c$ 很大的数据？

先看线性基的重要性质：

- 线性基中没有异或和为 $0$ 的子集。
- 线性基中各数二进制最高位不同。

显然，如果前面的几个数构造的线性基把 $64$ 个位置占满了，那么后面的数就不会再增加新的线性基元素。

如果没有插入到任何一个位置上，则表明该数可以由线性基中若干个元素的异或和表示出。也就可以用原来的元素异或出。

那么该数与线性基中这若干个元素的异或和为 $0$。

这样子的话，当 $c\ge \log w$，无论删的是什么边都可以使得异或和都为 $0$。

那么我们的概率正确就被打破了。

比如，有一个环。$i\to i+1\bmod n$。

在这里面随便多连几条边。

我们询问把这多连的边删掉图连不联通，答案显然为 $1$。

但是如果询问的边数量大的话，则可以使得异或和为 $0$ 了。

而我们定义异或和为 $0$ 表示删掉这几条边图不联通。显然发生了矛盾。

所以这就是上述问题的 $ans$。

另外，还有一个很重要的性质：

$c$ 在小于 $\log w$ 的情况下，越大，出错概率越大。

感性理解一下，随着数的增多，异或出来的数的数量也越来越多，越有可能碰到 $0$，这时随机赋权就越有可能出错（使得删掉一些边而图联通时这些边的异或值却为 $0$）。

### 参考

本人不太会表述，且不太清楚线性基原理，所以本文有一些内容参考了：

- [线性基学习笔记 Menci's OI Blog](https://oi.men.ci/linear-basis-notes/)
- [OI wiki 线性基](https://oi-wiki.org/math/linear-algebra/basis/)

### 外话

了解一个算法、定理的本质还是很重要的。

如果不了解线性基本质，就无法发现我上面说的概率问题。

感谢偶然的发现，让我意外的学到了不少。


---

## 作者：chenhouyuan (赞：1)

题目要求我们能够快速的判断给定的边集能否将原图分割成不连通的。我们注意到 $c_i\le4$ 也就是说每次询问的边集很小，这为后面做法的正确性提供了保证。
# Solution
考虑**随机异或哈希**，我们希望给每条边赋权使得任意一个删除后**恰好**使图不连通的边集的异或和为 $0$ ，怎么办呢？试着构造，对图的 dfs 树上的非树边从 $0$ 开始标号并令其权值为 $2^x$ ，树边的权值则为穿过它的简单环上的非树边的异或和，此时当且仅当一条树边和它所在的简单环上的非树边被删去时图不连通且异或和为 $0$ ，符合我们的要求。

但是这样非树边的权值太大，不可接受。考虑随机化，对非树边随机赋权，修改后显然当一条树边和它所在的简单环上的非树边被删去时异或和仍为 $0$ ，但是可能存在非法情况，概率随 $k$ 增大而增大，因此当 $k$ 太大时这个做法就假了。

那如何快速判断询问呢？维护一个**线性基**即可。
# AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e6+5;
ll n,m,Q,a[N],cnt,k,c,fl,aa[70];
struct edge{
	ll u,v,w,id;
}e2[N];
vector<edge>e[N];
mt19937_64 rnd(time(0));
void dfs(ll x,ll f){
	a[x]=++a[0];
	for(edge i:e[x]){
		if(i.id==f)continue;
		if(a[i.v]){
			if(a[i.v]<a[x]){
				e2[i.id].w=rnd();
			}
		}
		else{
			dfs(i.v,i.id);
		}
		e2[f].w^=e2[i.id].w;
	}
}
ll put(ll x){
	x=e2[x].w;
	for(ll i=63;i>=0;i--){
		if(((x>>i)&1)==0)continue;
		if(!aa[i]){
			aa[i]=x;
			return 0;
		}
		x^=aa[i];
	}
	return 1;
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=m;i++){
		scanf("%lld%lld",&e2[i].u,&e2[i].v);
		e[e2[i].u].push_back({0,e2[i].v,0,i});
		e[e2[i].v].push_back({0,e2[i].u,0,i});
	}
	dfs(1,0);
	scanf("%lld",&Q);
	while(Q--){
		fl=0;
		memset(aa,0,sizeof(aa));
		scanf("%lld",&k);
		for(ll i=0;i<k;i++){
			scanf("%lld",&c);
			if(put(c)){
				fl=1;
			}
		}
		if(fl){
			printf("Bob\n");
		}
		else{
			printf("ymqOAO\n");
			cnt++;
		}
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：1)

[双倍经验](https://www.luogu.com.cn/problem/P5227)。

非常有意思的一道题。

首先思考一个比较简单的问题，如果一个点和其他点不连通应该满足啥条件？那显然是这个点所有的边都断开了。

两个点的连通块呢？那么显然是只保留两点相连的边，其他边都应当断开。

那么如果断开了一个连通块，那么就应该是这些连通块连向外面的边全部被断开了。

想一想这给了我们什么启发。

首先想到记录一下每个点删掉了多少边，但是这个方法并不好，因为无法体现边与边之间的不同（我删除的是连通块里的边还是连外面的边？不知道对不对）。

然后我们想到给每个边随机一个权值来体现他们的不同。

那这些权值应该满足啥性质呢？思考一下，我们发现一个天才的构造是使得一个点所有的边的边权异或和为 $0$。

因为异或这个东西，可以当成加，可以当成减，相当灵活，在这里也有所体现，我们发现一个连通块被断开当且仅当存在一些删除的边的异或和为 $0$。

证明是这样的：对于一个点，删除它所有对外的边，这些边的边权异或和显然是 $0$。

这时候如果连通块里面多一个点，那么连通块内唯一保留的边就是彼此相连的那条边，设它的边权为 $x$，由于 $x\oplus x=0$，所以这两个点剩下的边的边权异或和应该都是 $x$，所以异或起来一定是 $0$。

如果再增加到三个点，四个点的话也是类似的。

至于随机的边权，这个一个 DFS 就能求出来，过程如下：

```cpp
void Dfs(LL x,LL f)
{
	Vis[x]=1;
	for(int i=H[x];i;S[x]^=W[i>>1],i=E[i].Nxt)
	{
		if(E[i].To==f)continue;
		if(Vis[E[i].To]&&!W[i>>1])W[i>>1]=rand()+1;
		else if(!Vis[E[i].To])Dfs(E[i].To,x),W[i>>1]=S[E[i].To];
	}
}
```



所以我们枚举删除边的子集，直接看异或和是否为 $0$ 即可。

容易发现这个做法建立在每次删掉的边不多，如果删除边数超过了 $64$ 那怎么说都会有一种凑出 $0$ 的方式，那就错没了。

注意处理重边问题，这个有点恶心。

---

## 作者：Hyvial (赞：0)

## 思路

1. 随机化边权使 __同一点__ 所连的边权 __异或值__ 为 $0$；
2. 加入边时枚举边集判断异或和是否为 $0$，为 $0$ 就是图已经不联通（有一个联通子集的所有连边已经被删除，详见 __证明__）。

## 证明

现在图中有一个联通子集，其中的每一个点所连的边权异或和为 $0$，此时将每个点所连的边都异或起来（__不管是否重复__），这些边的异或和一定为 $0$（因为分开异或也是 $0$）。

## 操作

在原图中搞出一棵生成树，对于树上没有的边，直接随机边权，对于连向父亲，边权为儿子其他边的异或和，之后的操作和 2. 一样。

## 优化

该方法的复杂度为 $O(N + \sum_{i=1}^{k} 2^{c_i})$，其中当 $c_i \le 4$ 时 $2^{c_i}$ 可以跑的特别，但当 $c_i$ 增大时速度会减慢，此时可以使用  __线性基__ 优化成 $O(N + \sum_{i=1}^{k}c_i \log \omega)$（$\omega$ 为随机化函数的最大值），线性基就不多讲了，可以看[这里](https://oi.wiki/math/linear-algebra/basis/)。

## 代码

```
#include <bits/stdc++.h>
#define PII pair <int, int>
#define LL long long
#define ST string
#define DB double

using namespace std;

const int N = 1e6 + 10;
int n, m, q, f[20];

int tot = 2, head[N], ver[N << 1], nxt[N << 1], edge[N << 1];

void add(int x, int y)
{
	ver[tot] = y;
	nxt[tot] = head[x];
	head[x] = tot ++ ;
}

bool vis[N], used[N << 1];
int dfs(int x)
{
	vis[x] = 1;
	int sum = 0;
	// 随机赋值不边权，并满足同意点所连边权异或和为 1 
	for(int i = head[x]; i; i = nxt[i])
	{
		int to = ver[i];
		if(vis[to] && !used[i])
			edge[i] = edge[i ^ 1] = rand(), used[i] = used[i ^ 1] = 1;
		else if(!vis[to]) 
			used[i] = used[i ^ 1] = 1, edge[i] = edge[i ^ 1] = dfs(to);
		sum ^= edge[i];
	} return sum;
}

vector <int> ask;
bool dfs(int x, int sum, int c, bool flg)
{
	if(x == c)
	{
		if(!sum && flg) return true;
		return false;
	}
	
	if(dfs(x + 1, sum, c, flg)) return true;
	if(dfs(x + 1, sum ^ edge[ask[x] << 1], c, 1)) return true;
	return false;
}

signed main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1, x, y; i <= m; i ++ )
		scanf("%d%d", &x, &y), add(x, y), add(y, x);
	
	dfs(1);
	
	scanf("%d", &q);
	int c;
	while(q -- )
	{
		scanf("%d", &c);
		ask.clear();
		for(int i = 1, x; i <= c; i ++ )
			scanf("%d", &x), ask.push_back(x);
		
		bool flg = 0;
		// 暴力枚举边集
		flg = dfs(0, 0, c, 0);
		
		/* 线性基
		for(int i = 0; i < 20; i ++ )
			f[i] = 0;
		
		for(int i : ask)
		{
			int ins = edge[i << 1];
			for(int j = 19; j >= 0; j -- )
			{
				if(!((ins >> j) & 1)) continue;
				if(!f[j]) { f[j] = ins; break; }
				else ins ^= f[j];
			}
			if(!ins) flg = 1;
		} */
		
		if(flg) puts("Bob");
		else puts("ymqOAO");
	}
		
	return 0;
}


```



## 写于结尾

1. 随机化代码：

```
n = rand();
```

此时 $n$ 就是随机化生成的。

1. ##### 关于正确性：正确性随着 $c_i$ 的增加而减少，并在 $\log \omega \le c_i$ 时正确性为 $0\%$。

2. [__双倍经验（原题）__](https://www.luogu.com.cn/problem/P5227)。

3. [有线性基](https://www.luogu.com.cn/record/224411855)和[无线性基](https://www.luogu.com.cn/record/224386634)在该题的数据下差别不大。

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10075)

# 前置知识

[线性基](https://oi-wiki.org/math/linear-algebra/basis/) | 异或哈希

# 解法

$n,m,q \le 10^{6}$ 的数据范围限制了 [luogu P5227 [AHOI2013] 连通图](https://www.luogu.com.cn/problem/P5227) 的线段树分治无法通过。

注意到对于原图的一张生成树中的树边，如果它与覆盖它的返祖边都断开了就会变得不连通。

不妨考虑异或哈希，对返祖边随机赋权，树边的权值为覆盖它的返祖边的权值的异或和。询问时通过线性基判断能否正确插入来得到是否同时出现。

值得一提的是异或哈希能通过的重要限制是 $c \le 4$，即每次删的边不会太多。但是随着 $c$ 的增长，错误性会逐渐扩大，且当 $c> O(\log V)$ 后一定存在不能插入的情况（已经插满了）使得判断错误。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
mt19937_64 rng(random_device{}());
struct node
{
	int nxt,to,id;
}e[2000010];
int head[1000010],u[1000010],v[1000010],vis[1000010],ins[1000010],cnt=0;
ull w[1000010];
void add(int u,int v,int id)
{
	cnt++;  e[cnt]=(node){head[u],v,id};  head[u]=cnt;
}
void dfs(int x,int fa)
{
	vis[x]=ins[x]=1;
	for(int i=head[x];i!=0;i=e[i].nxt)
	{
		if(e[i].id!=fa)
		{
			if(vis[e[i].to]==0)  dfs(e[i].to,e[i].id);
			else  if(ins[e[i].to]==1)  w[e[i].id]=rng();
			w[fa]^=w[e[i].id];
		}
	}
	ins[x]=0;
}
struct Liner_Base
{
	ull d[70];
	void clear()
	{
		memset(d,0,sizeof(d));
	}
	int insert(ull x)
	{
		for(int i=63;i>=0;i--)
		{
			if((x>>i)&1)
			{
				if(d[i]==0)
				{
					d[i]=x;
					return 1;
				}
				x^=d[i];
			}
		}
		return 0;
	}
}L;
int main()
{
// #define Isaac
#ifdef Isaac
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
#endif
	int n,m,q,k,x,flag,i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		scanf("%d%d",&u[i],&v[i]);
		add(u[i],v[i],i);  add(v[i],u[i],i);
	}
	dfs(1,0);
	scanf("%d",&q);
	for(i=1;i<=q;i++)
	{
		scanf("%d",&k);  L.clear();
		flag=1;
		for(j=1;j<=k;j++)
		{
			scanf("%d",&x);
			flag&=L.insert(w[x]);
		}
		if(flag==0)  printf("Bob\n");
		else  printf("ymqOAO\n");
	}
	return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：0)

好的如你所见，这道题让我们动态删边然后询问原图是否连通。

我一看这不是很简单吗？线段树分治一挂直接就过了好吧。

但是，**强制在线**。~~不做了直接逃逸~~。

回归问题本质，我们只需要知道整张图是不是连通的即可，判断连通很麻烦，就倒过来想什么情况会**不连通**。

原图 $S$ 若是可以断成两个连通块 $E$ 与 $S-E$ 那么显然就是不连通的，两个以上的连通块都可以归类于上面的情况。

如果我想让图不连通，那么对于一条边 $(u,v)$，显然当两个端点各属于两个连通块就得删掉它。

所以有一个直观的想法了，我们若是能够找到一组询问的边集包含了图中子集 $T$ 就可以说明不连通了。

神奇的地方来了，这个东西叫**随机异或哈希**。构造边权使得对于所有 $T$ 的边权异或和都为 $0$。

那么我们只需要查询边集的异或和是否可以为 $0$ 即可，可以用**线性基**维护。

那怎么构造呢？

先说方法，随便在图上找棵生成树。然后非树边的边权随机，树边的边权为经过它的非树边的权值的异或和。然后就解决了这个问题。

为什么是对的捏。你想啊，如果 $S$ 里只有两个点的话那么边权就直接抵消掉了，理由是异或的性质。推广到多个点也是一样的。

所以，我们就用了看上去和本题一个八竿子打不着的算法线性基解决了这道题。

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
mt19937 rnd(27426169); 
uniform_int_distribution<int> sjs(1,2e9); 
struct Point{
	int v,val;
};
struct xxj{
	int c[32];
	void clear(){
		memset(c,0,sizeof(c));
	}
	bool insert(int x){
		for(int i = 31;i >= 0;i--){
			if(x&(1<<i)){
				if(!c[i]){
					c[i]=x;
					return 1;
				}
				x^=c[i];
			}
		}
		return 0;
	}
}t;
bool vis[N];
int n,m,u,v,f[N],val[N];
vector <Point> e[N],g[N];
void dfs(int u,int fa){
	vis[u]=1;
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i].v,id=e[u][i].val;
		if(v==fa)continue;
		if(vis[v]&&!val[id]){
			val[id]=sjs(rnd);
			f[v]^=val[id];
			f[u]^=val[id];
		}
		else if(!vis[v]){
			g[u].push_back((Point){v,id});
			dfs(v,u);
		}
	}
} 
void dfs1(int u){
	for(int i = 0;i < g[u].size();i++){
		int v=g[u][i].v,id=g[u][i].val;
		dfs1(v);
		val[id]=f[v];
		f[u]^=f[v]; 
	}
}
int x,q,k;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		cin >> u >>v;
		e[u].push_back((Point){v,i});
		e[v].push_back((Point){u,i});
	}
	dfs(1,0);
	dfs1(1);
	cin >> q;
	int cnt=0;
	for(int i = 1;i <= q;i++){
		cin >> k;
		int flag=1;
		t.clear();
		for(int j = 1;j <= k;j++){
			cin >> x;
			flag&=t.insert(val[x]);
		}
		if(!flag)cout << "Bob\n";
		else cout << "ymqOAO\n";
	}	
	return 0;
}
```

---

## 作者：1234567890sjx (赞：0)

很厉害一题。

考虑给每一条边随机赋一个权值，满足对于任意的一个点 $u$，满足一个端点为 $u$ 的边形成的边集 $E$ 中所有的边的权值的异或的值为 $0$。

即：$\forall u\in[1,n]\cap\textbf{N}_+,\ s.t.\ \oplus_{i\in E_u}W(i)=0$。其中 $W(i)$ 表示 $i$ 编号的边被随机赋的边权的值。

显然对于初始的连通图所有边的异或权值为 $0$。

容易发现，如果恰好此时将点全集的一个点子集和剩余的点形成的集合分割所必须删除的边集（即只删除对分割这两个点集所必须删除的边），则此时剩下的所有边的随机权的异或值一定为 $0$。

但是问题是，有可能除了删除分割两个点子集必须删除的边以外，可能还删除了对分割这两个点子集没有直接影响的边。发现 $c_i\le 4$，因此直接 $2^{c_i}$ 枚举每一个删边集合，若存在这样的一个删边集合满足剩下的边的边权的异或值为 $0$，则此时删除这 $c_i$ 个点（不）一定可以让连通块不再联通。否则一定连通。

upd：这个东西可以使用线性基在 $O(c_i\log W)$ 的时间复杂度内维护，但是因为 $c_i\le 4$ 实在是太小了，所以反而成了负优化。

但是其实在随机很优秀的情况下，上面括号括起来的（不）是不会发生的。因此该做法正确。

---


# [GDKOI2024 提高组] 匹配

## 题目描述

给定一个 $2n$ 个点 $m$ 条边的二分图，左部点编号为 $1 \sim n$，右部点编号为 $n + 1 \sim 2n$。

给定每条边为黑色或白色，你需要找到一个完美匹配，使得匹配里的黑色边数恰好为偶数。

如果你对二分图的定义有疑问：

- 二分图是一个无向图，点分为左右两部分，每部分各 $n$ 个点，每条边都连接两个属于不同部分的点。
- 一个完美匹配是一个大小为 $n$ 的边的集合，使得每个点都恰好与集合里的一条边相连。

## 说明/提示

**【样例解释】**

在第一组数据中，一个合法的完美匹配是 $(1, 6),(2, 5),(3, 4)$，且里面有恰好两条黑色边。

在第二组数据中，虽然存在完美匹配，但每个完美匹配都有奇数条黑色边。

**【数据范围】**

**本题使用子任务捆绑测试。**

对于所有数据，保证 $1 \leq T \leq 250$，$2 \leq n,\sum n \leq 500$，$1 \leq m \leq n^2$。保证图中不存在重边，即对于 $i \neq j$ 有 $(u_i, v_i)\neq (u_j , v_j)$。

- Subtask 1（20%）：$n ≤ 8$，$T ≤ 10$。
- Subtask 2（20%）：$n ≤ 18$，$T ≤ 10$。
- Subtask 3（20%）：$c_i$ 在 $\{0, 1\}$ 里独立均匀随机。
- Subtask 4（40%）：无特殊限制。

## 样例 #1

### 输入

```
2
3 7
3 6 1
2 6 0
2 5 1
3 5 1
1 6 1
3 4 0
1 5 1
3 7
1 6 1
3 5 1
2 5 1
3 4 1
1 5 0
1 4 0
2 6 0```

### 输出

```
5 3 6
-1```

# 题解

## 作者：CYZZ (赞：22)

# [P10080](https://www.luogu.com.cn/problem/P10080)
考场上想到做法，结果忘了匈牙利和网络流，后悔莫及。但现在看来就算会了也写不出来，膜拜 @缪凌锴_Mathew 大师场切。
## 前置知识
二分图最大匹配，找环。
## 思路
题目要求找一个黑色边数量为**偶数**的匹配，这是一个很好的切入口，可以排除掉很多奇怪的算法。

假设现在你已经找到了一个完美匹配（找不到直接无解），称匹配中的边为**原配边**，此时黑色边的数量无非就两种情况：

1. 黑色边的数量为偶数，此时直接输出匹配即可。
2. 黑色边的数量为奇数，此时我们考虑对匹配进行调整，使黑边数量的**奇偶性**改变。

稍加思考可以发现，只需要找到一个环，满足环上黑边数量为奇数，且**原配边**占环的一半（即隔一条有一条原配边）。调整时，把环上的原配边调整为环上的非原配边即可。

如何找到这个环呢？发现在求解完美匹配后的残量网络里，恰好改变了原配边的方向。也就是说，我们只需要**在残量网络中找奇环**即可。

可能讲得有一点抽象，配个样例的图理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/533t6xeo.png)

以上是残量网络：如果我们已经找到了完美匹配 $(3,4),(1,5),(2,6)$，然后发现边权和为奇数。接着我们找到了一个奇环 $5\rightarrow1\rightarrow6\rightarrow2\rightarrow5$，就用 $(1,6),(2,5)$ 替换掉 $(5,1),(6,2)$，最后得到正确匹配 $(3,4),(1,6),(2,5)$。

需要注意的是：找环不能单纯地以每个点为根节点都 bfs 一次，这样是 $\mathcal{O(nm)}$ 的。应该使用 dfs，同时不要重复点,这是 $\mathcal{O(n+m)}$ 的。拆点的意思是由 $(u,val)$ 走到 $(v,val\oplus w)$，$val,w$ 分别表示当前的奇偶性和当前边的权值。

如果使用 dinic 求解完美匹配的话，瓶颈在网络流，时间复杂的 $\mathcal{O(m\sqrt{n})}$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1005
#define M 600005
int n,m,S,T;
int tot=1,head[N];
struct Edge
{
    int next,to,w,val;
}e[M];
void add_edge(int u,int v,int w1,int w2)
{
    e[++tot].next=head[u];
    e[tot].to=v;
    e[tot].w=w1;
    e[tot].val=w2;
    head[u]=tot;
}
int dep[N],now[N];
int bfs()
{
    for(int i=1;i<=T;i++)
    {
        dep[i]=0;
    }
    for(int i=1;i<=T;i++) now[i]=head[i];
    queue<int>q;q.push(S);dep[S]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        if(u==T) return 1;
        for(int i=head[u];i;i=e[i].next)
        {
            int v=e[i].to;
            if(!e[i].w||dep[v]) continue;
            dep[v]=dep[u]+1;
            q.push(v);
        }
    }
    return 0;
}
int dinic(int u,int flow)
{
    if(u==T) return flow;
    int rest=flow;
    for(int i=now[u];i;i=e[i].next)
    {
        int v=e[i].to;
        now[u]=i;
        if(!e[i].w||dep[v]!=dep[u]+1) continue;
        int k=dinic(v,min(rest,e[i].w));
        if(!k) dep[v]=-1;
        e[i].w-=k;e[i^1].w+=k;
        rest-=k;
        if(!rest) break;
    }
    return flow-rest;
}
int top,st[N];
bool vis[N][2],instk[N][2];
int match[N];
bool dfs(int u,int w)
{
    if(vis[u][w]) return 0;
    vis[u][w]=1;
    instk[u][w]=1;
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(!e[i].w||e[i].val==-1) continue;
        st[++top]=i;
        int ew=w^e[i].val;
        if(instk[v][ew^1])
        {
            pair<int,int> tmp={v,ew};
            while(tmp!=make_pair(v,ew^1))
            {
                int j=st[top--],nw=e[j^1].to;
                if(nw<=n) match[nw]=j/2;
                tmp=make_pair(nw,tmp.second^e[j^1].val);
            }
            return 1;
        }
        if(dfs(v,ew)) return 1;
        top--;
    }
    instk[u][w]=0;
    return 0;
}
void init()
{
    tot=1;
    for(int i=1;i<=T;i++) head[i]=0;
}
void solve()
{
    scanf("%d%d",&n,&m);
    S=n*2+1;T=n*2+2;
    init();
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add_edge(x,y,1,z);
        add_edge(y,x,0,z);
    }
    for(int i=1;i<=n;i++)
    {
        add_edge(S,i,1,-1);
        add_edge(i,S,0,-1);
    }
    for(int i=n+1;i<=2*n;i++)
    {
        add_edge(i,T,1,-1);
        add_edge(T,i,0,-1);
    }
    int cnt=0;
    while(bfs()) cnt+=dinic(S,1e9);
    if(cnt<n) return printf("-1\n"),void();
    int ans=0;
    for(int i=2;i<=2*m;i+=2)
    {
        if(!e[i].w)
            match[e[i^1].to]=i/2,ans+=e[i].val;
    }
    if(!(ans&1))
    {
        for(int i=1;i<=n;i++) printf("%d ",match[i]);
        putchar('\n');
        return ;
    }
    memset(vis,0,sizeof(vis));
    memset(instk,0,sizeof(instk));
    for(int i=1;i<=n;i++)
    {
        top=0;
        if(dfs(i,0))
        {
            for(int i=1;i<=n;i++) printf("%d ",match[i]);
            putchar('\n');
            return ;
        }
    }
    printf("-1\n");
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        solve();
    }
}
```
点个赞再走吧。

---

## 作者：缪凌锴_Mathew (赞：7)

考场想出来了被卡常，交一发题解。

首先先找完美匹配，找不到就无解。

然后用网络流找到完美匹配后：

- 如果此完美匹配黑色边数恰好为偶数，直接输出即可。

- 如果此完美匹配黑色边数为奇数，我们注意到可以在残量网络上找一个黑边为单数的环来调整（网络流建反边的性质），使它变成黑色边数恰好为偶数。

这个找环可以把每个点拆成到达此点时黑边为奇数和偶数两个点，然后就变成了普通图找环。

这时候你直接整一个 $O(nm)$ 的 bfs 找环，就会悲催地得到超时的好成绩。

其实可以用 dfs 避免找到重复点，时间复杂度 $O(m)$。

```cpp
#include<map>
#include<set>
#include<cmath>
#include<ctime>
#include<queue>
#include<stack>
#include<cstdio>
#include<bitset>
#include<string>
#include<vector>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e3+10;
const int MAXM=1e6+10;
const int INF=0x3f3f3f3f;
const long long LINF=0x3f3f3f3f3f3f3f3f;
int n,m,s,t;
int idx=1;
int head[MAXN],nxt[MAXM],to[MAXM];
bool w[MAXM];
inline void add_edge(int x,int y,bool z){
    idx++;
    nxt[idx]=head[x];
    head[x]=idx;
    to[idx]=y;
    w[idx]=z;
}
int dep[MAXN],cur[MAXN];
bool bfs(){
    memset(dep,0,sizeof(dep));
    queue <int> q;
    q.push(s);
    dep[s]=1;
    while(!q.empty())
    {
        int x=q.front();
        cur[x]=head[x];
        q.pop();
        for(int i=head[x];i;i=nxt[i])
        {
            if((!w[i])||dep[to[i]]){
                continue;
            }
            dep[to[i]]=dep[x]+1;
            q.push(to[i]);
        }
    }
    if(dep[t]){
        return true;
    }
    else{
        return false;
    }
}
int dfs(int x,int flow){
    if(x==t){
        return flow;
    }
    int res=0;
    for(int i=cur[x];i;i=nxt[i])
    {
        cur[x]=i;
        if(!w[i]){
            continue;
        }
        if(dep[to[i]]!=dep[x]+1){
            continue;
        }
        if(!dfs(to[i],w[i])){
            dep[to[i]]=0;
            continue;
        }
        res++;
        flow--;
        w[i]^=1;
        w[i^1]^=1;
        if(!flow){
            return res;
        }
    }
    return res;
}
int dinic(){//网络流找完美匹配
    int flow=0;
    while(bfs())
    {
        flow+=dfs(s,n);
    }
    return flow;
}
int e[MAXN];
int c[MAXM];
bool vis[MAXN][2];
int top=1;
int st[MAXN];
bool inst[MAXN][2];
bool Dfs(int x,bool v){//点x,黑边为奇数/偶数
    if(vis[x][v]){
        return false;
    }
    vis[x][v]=true;
    inst[x][v]=true;
    for(int i=head[x];i;i=nxt[i])
    {
        if(!w[i]){
            continue;
        }
        bool tov=v^c[i];
        if(inst[to[i]][!tov]){
            w[i]=!w[i];
            w[i^1]=!w[i^1];
            while(x!=to[i]||v==tov)
            {
                int now=st[top];
                top--;
                w[now]^=1;
                w[now^1]^=1;
                v^=c[now];
                x=to[now^1];
            }
            return true;
        }
        st[++top]=i;
        if(Dfs(to[i],tov)){
            return true;
        }
        --top;
    }
    inst[x][v]=false;
    return false;
}
inline bool extra_test(){//找奇环
    top=0;
    memset(vis,false,sizeof(vis));
    memset(inst,false,sizeof(inst));
    for(int i=1;i<=n;i++)
    {
        if(Dfs(i,0)){
            return true;
        }
    }
    return false;
}
inline void solve(){
    idx=1;
    memset(head,0,sizeof(head));
    scanf("%d%d",&n,&m);
    s=n*2+1;
    t=n*2+2;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d%d",&x,&y,&c[i*2]);
        c[i*2+1]=c[i*2];
        add_edge(x,y,1);
        add_edge(y,x,0);
    }
    for(int i=1;i<=n;i++)
    {
        add_edge(s,i,1);
        add_edge(i,s,0);
    }
    for(int i=n+1;i<=n+n;i++)
    {
        add_edge(i,t,1);
        add_edge(t,i,0);
    }
    int flow=dinic();
    if(flow!=n){
        puts("-1");
        return ;
    }
    bool flg=false;
    for(int i=1;i<=m;i++)
    {
        if(!w[i*2]){
            e[to[i*2+1]]=i;
            if(c[i*2]){
                flg=!flg;
            }
        }
    }
    if(!flg){
        for(int i=1;i<=n;i++)
        {
            printf("%d ",e[i]);
        }
        putchar('\n');
        return ;
    }
    if(extra_test()){
        for(int i=1;i<=m;i++)
        {
            if(!w[i*2]){
                e[to[i*2+1]]=i;
            }
        }
        for(int i=1;i<=n;i++)
        {
            printf("%d ",e[i]);
        }
        putchar('\n');
    }
    else{
        puts("-1");
    }
}
signed main(){
    int t;
    scanf("%d",&t);
    while(t--)
    {
        solve();
    }
    return 0;
}
```
暂时是最优解。

---

## 作者：FFTotoro (赞：3)

很好的 Graph Matchings 题。

先考虑找出一个完美匹配，如果找不到肯定就是无解。如果这个完美匹配上黑边的数量为偶数直接输出；否则考虑使用如下的方法调整出合法的解。

考虑一个完美匹配该怎么变成另一个完美匹配；对于这个变换有个结论：改变后的边集和原来的那一部分边集并起来会形成一个环，且原边集里的边和改变后边集里的边**交替出现**。而我们要使更改后的黑边数量的奇偶性改变，即如果将黑边权值视为 $1$，白边视为 $0$，只需找到一个**边权和为奇数且满足上述条件的环**，将环内原答案内的边剔除，其他所有边加入答案。如果找不到满足条件的环，那么报告无解。

似乎题解里面很多都是网络流啊，这里供一个匈牙利算法的。找环可以借助一个栈进行 dfs。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef tuple<int,int,int> tpi;
int main(){
  ios::sync_with_stdio(false);
  int t; cin>>t;
  while(t--){
    int n,m,k=0; cin>>n>>m;
    vector<vector<tpi> > g(n<<1),g2(n<<1);
    vector<bool> r(m),b(n<<1),c(n<<1);
    for(int i=0;i<m;i++){
      int u,v,w; cin>>u>>v>>w;
      g[--u].emplace_back(--v,w,i);
      g[v].emplace_back(u,w,i);
    }
    vector<int> p(n<<1,-1),s(n<<1);
    function<bool(int)> find=[&](int u){
      for(auto [v,w,i]:g[u])
        if(!b[v])
          if(b[v]=1;p[v]<0||find(p[v])){
            p[v]=u; return true;
          }
      return false;
    }; // 匈牙利算法找匹配
    bool f=false;
    for(int i=0;i<n&&!f;i++)
      fill(b.begin(),b.end(),0),f|=!find(i);
    if(f){cout<<"-1\n"; continue;} // 无完美匹配
    for(int u=n;u<n<<1;u++)
      for(auto [v,w,i]:g[u])
        if(p[u]==v)k+=w,r[i]=1,g2[v].emplace_back(u,w,i);
        else r[i]=0,g2[u].emplace_back(v,w,i); // 建有向边
    if(k&1){
      stack<pii> t;
      function<void(int)> dfs=[&](int u){
        b[u]=1; // 打标记
        for(auto [v,w,i]:g2[u])
          if(!f){
            if(!b[v])t.emplace(v,i),s[v]=s[u]+w,dfs(v);
            else if(c[v]&&s[u]-s[v]+w&1){
              f=true,r[i]=!r[i];
              while(!t.empty()&&t.top().first!=v)
                r[t.top().second]=!r[t.top().second],t.pop();
            } // 找到满足条件的环
          }
        if(c[u]=0;!t.empty())t.pop();
      }; // dfs 找环
      for(int i=0;i<n<<1&&!f;i++){
        fill(b.begin(),b.end(),0),fill(c.begin(),c.end(),0);
        s[i]=0,t.emplace(i,-1),c[i]=1,dfs(i);
      } // 搜索前记得清空
      if(!f){cout<<"-1\n"; continue;} // 无解
    }
    for(int i=0;i<m;i++)
      if(r[i])cout<<i+1<<' ';
    cout<<endl;
  }
  return 0;
}
```

---

## 作者：Tx_Lcy (赞：3)

[可能更好的阅读体验](https://tx-lcy.github.io/2024/01/22/GDKOI2024S%E5%8C%B9%E9%85%8D/)

[题目传送门](https://www.luogu.com.cn/problem/P10080)

## 思路

首先我们先找一个最大匹配，如果有点无法匹配那么答案显然是 $-1$。

接着我们统计最大匹配中黑边的出现次数，若为偶数，直接输出，否则考虑调整。

若本来的匹配是 $(1,5),(2,6),(3,4)$，现在我们要将匹配转化成 $(1,4),(2,5),(3,6)$，那么考虑按如下方式连边：

![](https://cdn.luogu.com.cn/upload/image_hosting/b877b0fe.png)

不难发现此时连成了一个环。

也就是说，如果我们按照“所有在最大匹配里的边左部点连到右部点，不在最大匹配里的边右部点连到左部点”的方式建出有向图，那么这张图上的环与调整方案一一对应。

同时，我们给每条边赋上颜色，边的颜色为这条边原先对应的那条无向边的颜色。

那么只要这张图存在一个奇环（出现了奇数次黑边的环），那么调整环上的匹配方案即可令答案合法。

暴力找环即可，时间复杂度 $\mathcal O(nm)$。

## 代码

```cpp
//A tree without skin will surely die.
//A man without face is invincible.
#include<bits/stdc++.h>
using namespace std;
#define rep(i,j,k) for(int i=j;i<=k;++i)
#define per(i,j,k) for(int i=j;i>=k;--i)
int const N=1e3+10;
int n,m,vis[N],dep[N],pre[N],matched[N],b[N][N],id[N][N];
vector<int>a[N];vector< pair<int,int> >c[N];
inline bool Hungary(int x,int co){
	for (auto v:a[x]){
		if (vis[v]==co) continue;
		vis[v]=co;
		if (!matched[v] || Hungary(matched[v],co)) return matched[v]=x,1;
	}
	return 0;
}
inline void dfs(int x){
	vis[x]=1;
	for (auto i:c[x]){
		int v=i.first,w=i.second;
		if (!vis[v]) dep[v]=dep[x]+w,pre[v]=x,dfs(v);
	}
}
void solve(){
	cin>>n>>m;
	rep(i,1,2*n) a[i].clear(),matched[i]=vis[i]=0;
	rep(i,1,2*n) rep(j,1,2*n) b[i][j]=-1;
	rep(i,1,m){
		int u,v,c;cin>>u>>v>>c;
		a[u].push_back(v);
		b[u][v]=b[v][u]=c;
		id[u][v]=id[v][u]=i;
	}
	rep(i,1,n)
		if (!Hungary(i,i)) return cout<<"-1\n",void();
	int w=0;
	rep(i,n+1,2*n) w+=b[i][matched[i]];
	if (!(w&1)){
		rep(i,n+1,2*n) cout<<id[i][matched[i]]<<' ';
		cout<<'\n';
		return;
	}
	rep(i,1,2*n) c[i].clear();
	rep(i,n+1,n+n) c[matched[i]].push_back({i,b[i][matched[i]]});
	rep(i,n+1,n+n) rep(j,1,n)
		if (j!=matched[i] && b[i][j]!=-1) c[i].push_back({j,b[i][j]});
	rep(i,1,n){
		rep(j,1,n+n) vis[j]=dep[j]=pre[j]=0;
		int tag=0;dfs(i);
		rep(x,1,n+n)
			for (auto s:c[x]){
				int v=s.first,w=s.second;
				if (v!=i) continue;
				if (!vis[x]) continue;
				if ((dep[x]-dep[v]+w)&1){tag=x;break;}
			}
		if (tag){
			for (int nw=tag;nw!=i;nw=pre[nw]){
				int k=pre[nw];
				if (k>n) matched[k]=nw;
			}
			if (tag>n) matched[tag]=i;
			rep(i,n+1,2*n) cout<<id[i][matched[i]]<<' ';
			cout<<'\n';
			return;
		}
	}
	cout<<"-1\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int t=1;
	cin>>t;
	while (t--) solve();
	return 0;
}
```

---


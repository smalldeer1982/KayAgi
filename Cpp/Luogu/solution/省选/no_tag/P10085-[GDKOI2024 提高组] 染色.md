# [GDKOI2024 提高组] 染色

## 题目描述

Alice 非常喜欢二进制，她认为事物只有和二进制有关才是美的。

一天，她奇思妙想了一种图案，并打算在长宽都为 $2^n$ 的网格上画出她心中所想的图案。
网格的格子只有黑色和白色两种，一开始都是白色。

现在 Alice 规定一种绘画操作为：选定一个格子，使它自己和相邻上下左右的网格颜色反转，即原本黑色会变成白色，白色会变成黑色。

Alice 还规定网格的第一行和最后一行相邻，第一列和最后一列也相邻。

现在 Alice 希望你给出一个操作方案或告诉无解。如果有多个方案，输出任意一个即可。

## 说明/提示

- 对于 $20\%$ 的数据，$n = 2$。
- 对于另外 $15\%$ 的数据，$n = 4$。
- 对于另外 $15\%$ 的数据，$n = 7$。
- 对于 $100\%$ 的数据，$n \leq 11$。

## 样例 #1

### 输入

```
2
0 0 1 1
1 0 1 0
0 0 0 0
1 1 1 0```

### 输出

```
7
0 0
1 0
1 3
2 1
3 1
3 2
3 3```

# 题解

## 作者：bmatrix (赞：9)

[题面](https://www.luogu.com.cn/problem/P10085)。

$\Theta\left(\dfrac{n^3}w\right)$ 过 $4096$，这就是伟大的 bitset 的伟大之处！

下文用 $\oplus$ 表示异或运算，加减运算均在模 $2^n$ 意义下进行。

设 $x_{i,j}$ 表示坐标为 $(i,j)$ 的格子是否进行操作，不难发现，题目就是给定了若干个限制：$x_{i,j}\oplus x_{i-1,j}\oplus x_{i+1,j}\oplus x_{i,j-1}\oplus x_{i,j+1}=a_{i,j}$。共 $2^{2n}$ 个变量，$2^{2n}$ 个方程，高斯消元即可拿到 35 分。

事实上，当我们知道第 $i$ 行和第 $i-1$ 行的所有 $x$ 时，我们可以直接推导出第 $i+1$ 行的 $x$，不需要高斯消元。

因此考虑只设出前两行共 $2^{n+1}$ 个变量，逐行推导，用这些变量表示出最后两行，然后用最后两行与前两行形成方程，进行高斯消元。

用 bitset 优化，时间复杂度 $\Theta\left(\dfrac{2^{3n+3}}w\right)$，大数据点需要对 $4096$ 个元素进行高斯消元。但由于 bitset 伟大的小常数，卡卡常就能跑进 1s。

卡常小寄巧：

1. 本题输入输出量大，建议使用 `fread` 和 `fwrite` 加速。
2. 滚动数组不用拷贝或清空，直接原地异或即可。
3. 不要写 `a ^= b ^ c ^d;`，写 `a ^= b, a ^= c, a ^= d;`，前者需要存中间值，常数大。

```cpp
constexpr int N = 1 << 11;
int n, a[N][N], ans[N][N];
bitset<N * 2 + 1> bs[N * 2];

signed main() {
    cin >> n;
    n = 1 << n;
    for(int i = 0; i < n; ++i) 
        for(int j = 0; j < n; ++j)
            cin >> a[i][j];
    for(int i = 0; i < n * 2; ++i) 
        bs[i][i] = 1;
    for(int i = 2; i < n; ++i) {
        int x = i & 1, y = x ^ 1;
        for(int j = 0; j < n; ++j) {
            bs[x * n + j] ^= bs[y * n + j], 
            bs[x * n + j] ^= bs[y * n + (j - 1 + n) % n],
            bs[x * n + j] ^= bs[y * n + (j + 1) % n];
            if(a[i - 1][j]) bs[x * n + j].flip(n * 2);
        }
    }
    for(int j = 0; j < n; ++j) {
        bs[j] ^= bs[n + j];
        bs[j] ^= bs[n + (j - 1 + n) % n];
        bs[j] ^= bs[n + (j + 1) % n];
        bs[j].flip(j);
        if(a[n - 1][j]) bs[j].flip(n * 2);
    }
    for(int j = 0; j < n; ++j) {
        bs[n + j].flip(j), bs[n + j].flip(n + j), bs[n + j].flip((j - 1 + n) % n), bs[n + j].flip((j + 1) % n);
        if(a[0][j]) bs[n + j].flip(n * 2);
    }
	// cerr << clock() / 1e3 << endl;
    for(int i = 0; i < n * 2; ++i) {
        for(int j = i; j < n * 2; ++j) {
            if(bs[j][i]) {
                if(j != i) swap(bs[j], bs[i]);
                break;
            }
        }
        for(int j = 0; j < n * 2; ++j)
            if(j != i && bs[j][i]) bs[j] ^= bs[i];
    }
	// cerr << clock() / 1e3 << endl;
    int cnt = 0;
    for(int i = 0; i < n * 2; ++i) {
        ans[i / n][i % n] = bs[i][n * 2];
        if(ans[i / n][i % n]) ++cnt;
    }
    for(int i = 2; i < n; ++i) 
        for(int j = 0; j < n; ++j) {
            ans[i][j] = ans[i - 1][j] ^ ans[i - 2][j] ^ ans[i - 1][(j - 1 + n) % n] ^ ans[i - 1][(j + 1) % n] ^ a[i - 1][j];
            if(ans[i][j]) ++cnt;
        }
	// cerr << clock() / 1e3 << endl;
    cout << cnt << endl;
    for(int i = 0; i < n; ++i)
        for(int j = 0; j < n; ++j)
            if(ans[i][j]) cout << i << ' ' << j << endl;
    return 0;
}
```



---

## 作者：ZnPdCo (赞：4)

# 【GDKOI 2024 TG Day2】染色（set） 题解

发现我们给一个点染上色后有：

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALgAAACNCAYAAAAEhLDZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAT+SURBVHhe7ZvBqmpBEMT8/5++T9+4i0jR0FAjCfRuKmA4Wx9/AY9H9GyEbqKbTN3P3eP/2PN+8t4f+ldeD7fQTXSTqTtaGZzoJo3uaGVwops0uqOVwYlu0uiOVgYnukmjO1oZnOgmje5oZXCimzS6o5XBiW7S6I5WBie6SaM7Whmc6CaN7mhlcKKbNLqjlcGJbtLojlYGJ7pJoztaGZzoJo3uaGVwops0uqOVwYlu0uiOVgYnukmj+7n78C8Iz/uVe3/oX3k93EI30U2m7mhlcKKbNLqjlcGJbtLojlYGJ7pJoztaGZzoJo3uaGVwops0uqOVwYlu0uiOVgYnukmjO1oZnOgmje5oZXCimzS6o5XBiW7S6I5WBie6SaM7Whmc6CaN7mhlcKKbNLqjlcGJbtLojlYGJ7pJoztaGZzoJo3u5+7DvyA871fu/aF/5fVwi7vdO2dvMnVHK4OT4945e5OpO1oZnBz3ztmbTN3RyuDkuHfO3mTqjlYGJ8e9c/YmU3e0Mjg57p2zN5m6o5XByXHvnL3J1B2tDE6Oe+fsTabuaGVwctw7Z28ydUcrg5Pj3jl7k6k7WhmcHPfO2ZtM3dHK4OS4d87eZOqOVgYnx71z9iZTd7QyODnunbM3mbqjlcHJce+cvcnUHa0MTo575+xNpu5oZXBy3DtnbzJ1P3cnqOf95L0/9K+8Hm6x7965u907NLqj1d1Rdu5u9w6N7mh1d5Sdu9u9Q6M7Wt0dZefudu/Q6I5Wd0fZubvdOzS6o9XdUXbubvcOje5odXeUnbvbvUOjO1rdHWXn7nbv0OiOVndH2bm73Ts0uqPV3VF27m73Do3uaHV3lJ27271Dozta3R1l5+5279DojlZ3R9m5u907NLqj1d1Rdu5u9w6N7mh1d5Sdu9u9Q6M7Wt0dZefudu/Q6I5Wd0fZubvdOzS6n7vzoz3vJ+/9oX/l9XCLu907Z28ydUcrg5Pj3jl7k6k7WhmcHPfO2ZtM3dHK4OS4d87eZOqOVgYnx71z9iZTd7QyODnunbM3mbqjlcHJce+cvcnUHa0MTo575+xNpu5oZXBy3DtnbzJ1RyuDk+PeOXuTqTtaGZwc987Zm0zd0crg5Lh3zt5k6o5WBifHvXP2JlN3tDI4Oe6dszeZuqOVwclx75y9ydQdrQxOjnvn7E2m7mhlcHLcO2dvMnU/dyeo5/3kvT/0r7webqGb6CZTd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0Z3tDI40U0a3dHK4EQ3aXRHK4MT3aTRHa0MTnSTRne0MjjRTRrd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0b3c/fhXxCe9yv3/tC/8nq4hW6im0zd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0Z3tDI40U0a3dHK4EQ3aXRHK4MT3aTRHa0MTnSTRne0MjjRTRrd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3P3Yd/QXjer9z7Q//K6+EWuoluMnVHK4MT3aTRHa0MTnSTRne0MjjRTRrd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0Z3tDI40U0a3dHK4EQ36XP//f0DFqz/GR4ShtkAAAAASUVORK5CYII=)

我们称这是一个大小为 $1$ 的十字。

进一步地，我们给这 $5$ 个点再次染上色后有：

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACCCAYAAACkRjFvAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAOzSURBVHhe7ZoxriNREAJ9/0v/Ha+d4YzqAEFJTFhqwQvn9QfweiGan8ytJLgRywZS2t2IZQMp7W7EsoGUdjdi2UBKuxuxbCCl3Y1YNpDS7kYsG0hpdyOWDaS0ux/P679sWdB8H5jFW3TF3EqCG7FsIKXdjVg2kNLuRiwbSGl3I5YNpLS7EcsGUtrdiGUDKe1uxLKBlHY3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2IZQMp7W7EsoGUdjdi2UBKu/vx/Pj7b1ncfB+YxVt0xb37Jtmd+CCW7BJvkt2JD2LJLvEm2Z34IJbsEm+S3YkPYsku8SbZnfggluwSb5LdiQ9iyS7xJtmd+CCW7BJvkt2JD2LJLvEm2Z34IJbsEm+S3YkPYsku8SbZnfggluwSb5LdiQ9iyS7xJtmd+CCW7BJvkt2JD2LJLvEm2Z34IJbsEm+S3YkPYsku8SbZnfg8nk8Jy4Lm+8As3qIr5lYS3IhlAyntbsSygZR2N2LZQEq7G7FsIKXdjVg2kNLuRiwbSGl3I5YNpLS7EcsGUtrdiGUDKe1uxLKBlHY3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2P58fff8vi5vvALN6i53uSj/uG3a2h7kYsG0jTfjdi2UCa9rsRywbStN+NWDaQpv1uxLKBNO13I5YNpGm/G7FsIE373YhlA2na70YsG0jTfjdi2UCa9rsRywbStN+NWDaQpv1uxLKBNO13I5YNpGm/G7FsIE373YhlA2na7348H9myoPk+MIu36Iq5lQQ3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2IZQMp7W7EsoGUdjdi2UBKuxuxbCCl3Y1YNpDS7kYsG0hpdyOWDaS0uxHLBlLa3YhlAyntbsSygZR29+P58fffsrj5PjCLt+iKe/dNsjvxQSzZJd4kuxMfxJJd4k2yO/FBLNkl3iS7Ex/Ekl3iTbI78UEs2SXeJLsTH8SSXeJNsjvxQSzZJd4kuxMfxJJd4k2yO/FBLNkl3iS7Ex/Ekl3iTbI78UEs2SXeJLsTH8SSXeJNsjvxQSzZJd4kuxMfxJJd4k2yO/FBLNkl3iS7Ex/Ekl3iTbI78Xk8nxKWBc33gVm8RVfMrSS4EcsGUtrdiGUDKe1uxLKBlHY3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2IZQMp7W7EsoGUbvff3z8gA2mw22z8TwAAAABJRU5ErkJggg==)

我们称这是一个大小为 $2$ 的十字。

同理可得，我们给这 $5$ 个点染上**相同**的大小为 $2$ 的十字，可得一个大小为 $4$ 的十字：

![](data:image/png;base64,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)

---

假设我们图的边长为 $N=2^n$，我们只需要染上一个大小为 $w=\frac{N}{2}$ 的十字，左边的那一个点就会和右边的点抵消，上面的点就会和下面的点抵消。最终效果就是只染了一个点。

![](data:image/png;base64,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)

假如我们要染一个大小为 $w=\frac{N}{2}$ 的十字，可以通过在这个十字的 $5$ 个红色的点位染上 $5$ 个大小为 $\frac{w}{2}=\frac{N}{4}$ 的十字来实现：

![](data:image/png;base64,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)

进一步地，如果我们要染一个大小为 $w=\frac{N}{4}$ 的十字，可以染上 $5$ 个大小为 $\frac{w}{2}=\frac{N}{8}$ 的十字来实现。

同理，我们可以使用分治来实现这一过程，最后就只会需要染若干个大小为 1 的十字，我们就能通过若干次操作染上一个点，而题目要求染的点我们只需要一个点一个点这么染就可以了。

我们只需要对于每个需要染色的位置跑一遍分治即可。时间复杂度由 $T(n)=5T(\frac{n}{2})+O(1)$ 得 $O(N^2n^{\log_25})$，就可以拿到不错的分数。

```c++
#include <cstdio>
#include <cstdlib>
#include <set>
#define ll long long
#define N 3000
using namespace std;
ll n, siz;
ll a[N][N], v[N][N];
ll tot;
inline ll calc(ll x) {
	return (x%siz+siz)%siz;
}
void fun(ll x, ll y, ll w) {
	if(w == 1) {
		v[x][y] ^= 1;
		return;
	}
	
	fun(x, y, w/2);
	fun(calc(x+w/2), y, w/2);
	fun(calc(x-w/2), y, w/2);
	fun(x, calc(y+w/2), w/2);
	fun(x, calc(y-w/2), w/2);
}
int main() {
	freopen("set.in", "r", stdin);
	freopen("set.out", "w", stdout);
	scanf("%lld", &n);
	siz = 1<<n;
	for(ll i = 0; i < siz; i++) {
		for(ll j = 0; j < siz; j++) {
			scanf("%lld", &a[i][j]);
		}
	}
	
	for(ll i = 0; i < siz; i++) {
		for(ll j = 0; j < siz; j++) {
			if(a[i][j]) {
				fun(i, j, siz / 2);
			}
		}
	} 
	
	for(ll i = 0; i < siz; i++) {
		for(ll j = 0; j < siz; j++) {
			if(v[i][j]) {
				tot++;
			}
		}
	}
	printf("%lld\n", tot);
	for(ll i = 0; i < siz; i++) {
		for(ll j = 0; j < siz; j++) {
			if(v[i][j]) {
				printf("%lld %lld\n", i, j);
			}
		}
	}
}
```

---

考虑为什么会这么慢，因为一个点可能被染了多次，这可以被抵消，我们可以枚举 $w$，在染完一种大小的十字后再去染较小的十字，十字可以互相抵消，然后再同理得解。时间复杂度 $O(N^2n)$，可以满分。

不要开 `long long`。

```c++
#include <cstdio>
#include <cstdlib>
#include <set>
#define N 3000
using namespace std;
int n, siz;
bool a[N][N], v[N][N];
int tot;
inline int calc(int x) {
	return (x % siz + siz) % siz;
}
inline int read() {
	int x = 0;
	char c = '.';
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') {
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = getchar();
	}
	return x;
}
void print(int x) {
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
int main() {
	freopen("set.in", "r", stdin);
	freopen("set.out", "w", stdout);
	n = read();
	siz = 1<<n;
	for(int i = 0; i < siz; i++) {
		for(int j = 0; j < siz; j++) {
			a[i][j] = read();
		}
	}
	
	for(int w = siz/2; w >= 2; w /= 2) {
		for(int i = 0; i < siz; i++) {
			for(int j = 0; j < siz; j++) {
				v[i][j] = 0;
			}
		}
		for(int i = 0; i < siz; i++) {
			for(int j = 0; j < siz; j++) {
				if(a[i][j]) {
					v[i][j] ^= 1;
					v[calc(i+w/2)][j] ^= 1;
					v[calc(i-w/2)][j] ^= 1;
					v[i][calc(j+w/2)] ^= 1;
					v[i][calc(j-w/2)] ^= 1;
				}
			}
		}
		for(int i = 0; i < siz; i++) {
			for(int j = 0; j < siz; j++) {
				a[i][j] = v[i][j];
			}
		}
	}
	
	for(int i = 0; i < siz; i++) {
		for(int j = 0; j < siz; j++) {
			if(v[i][j]) {
				tot++;
			}
		}
	}
	print(tot);
	putchar('\n');
	for(int i = 0; i < siz; i++) {
		for(int j = 0; j < siz; j++) {
			if(v[i][j]) {
				print(i);
				putchar(' ');
				print(j);
				putchar('\n');
			}
		}
	}
}
```





---

## 作者：ADNAP (赞：3)

首先题目给出了如下的染色方式：
![](https://cdn.luogu.com.cn/upload/image_hosting/5lz7r5rv.png)

接下来我们把周围四个点再染一遍色，能得到下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/ehla9pk8.png)

其等价于给一个更大的十字上的五个点各染色一次，即：
![](https://cdn.luogu.com.cn/upload/image_hosting/v06eetqq.png)

接下来我们拿着这个更大的十字进行同样的操作，在边上的四个点也用大的十字染色一次，得到：
![](https://cdn.luogu.com.cn/upload/image_hosting/n6fozrpl.png)

此时会有两个点超出边界，与对应的点抵消。所以最后只相当于给最开始操作的中心点染色。注意到每个十字的大小为 $2^n$，又因为题目中给出的矩阵大小为 $2^n$，所以，我们可以通过扩展 $n-1$ 十字最后一定能做到与只对一个点染色的等价操作。

如果我们将上述过程用递归实现，时间复杂度为 $O(4^n5^{2^{n-1}})$，可以得到 $35$ 分的好成绩。

### Code
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+1e4,M=1e3+1e2;
ll k;
ll n;
ll a[M*4][M*4];
bool flag[M*4][M*4];
ll res;
void work(ll x,ll y,ll tim)
{
    if(tim==-1)
    {
        ll xx,yy;
        if(x<0)xx=n-((-x)%n);
        else xx=x%n;;
        if(xx==0)xx+=n;
        if(y<0)yy=n-((-y)%n);
        else yy=y%n;;
        if(yy==0)yy+=n;
        if(flag[xx][yy])flag[xx][yy]=false,res--;
        else flag[xx][yy]=true,res++;
        return ;
    }
    ll p=pow(2,tim);
    work(x,y,tim-1);
    work(x+p,y,tim-1);
    work(x-p,y,tim-1);
    work(x,y-p,tim-1);
    work(x,y+p,tim-1);
}
signed main()
{
    cin>>k;
    n=pow(2,k);
    for(ll i=1;i<=n;i++)
        for(ll j=1;j<=n;j++)
            cin>>a[i][j];
    for(ll i=1;i<=n;i++)
        for(ll j=1;j<=n;j++)
            if(a[i][j])
                work(i,j,k-2);
    cout<<res<<"\n";
    for(ll i=1;i<=n;i++)
        for(ll j=1;j<=n;j++)
            if(flag[i][j])cout<<i-1<<" "<<j-1<<"\n";
}
```

其 TLE 的原因在于递归太多次，染色的点指数性增长，但有很多的点又是染偶数次，即相当于没有染色。

如果我们在递归过程中及时把这些不需要染色的点删去，使其不再递归，这样可以大大减少时间复杂度，其时间复杂度可以化为 $O(n4^n)$，符合数据范围。

#### Code
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> PLL;
#define x first
#define y second
const ll N=1e5+1e4,M=1e3+1e2,K=16*M*M;
ll k;
ll n;
ll a[M*3][M*3];
bool flag[M*3][M*3];
ll res;
PLL q[K];//存储要递归的点
ll bigg;//记录递归的十字的半径长度
ll cnt;
ll vist[M*3][M*3];
//记录某个点是否需要递归染色
signed main()
{
    cin>>k;
    n=pow(2,k);
    for(ll i=1;i<=n;i++)
        for(ll j=1;j<=n;j++)
            cin>>a[i][j];
    bigg=k-1;
    for(ll i=1;i<=n;i++)
        for(ll j=1;j<=n;j++)
            if(a[i][j])
            {
                vist[i][j]=1;
                q[++cnt].x=i,q[cnt].y=j;
            }
    while(bigg)//当bigg=0时，半径长度为1，就是最开始的十字
    {
        bigg--;
        ll w=pow(2,bigg);
        for(ll i=1;i<=cnt;i++)
        {
            ll xx,yy;
            
            xx=(q[i].x+w)%n,yy=q[i].y;
            if(xx==0)xx=n;
            //保证1<=xx<=n，下面同理
            vist[xx][yy]=1-vist[xx][yy];
            //即染变不染，不染变染
            
            xx=(q[i].x-w+n)%n;
            if(xx==0)xx=n;
            vist[xx][yy]=1-vist[xx][yy];
            
            xx=q[i].x,yy=(q[i].y+w)%n;
            if(yy==0)yy=n;
            vist[xx][yy]=1-vist[xx][yy];
            
            yy=(q[i].y-w+n)%n;
            if(yy==0)yy=n;
            vist[xx][yy]=1-vist[xx][yy];
        }
        cnt=0;
        for(ll i=1;i<=n;i++)
            for(ll j=1;j<=n;j++)
                if(vist[i][j])q[++cnt].x=i,q[cnt].y=j;
    }
    cout<<cnt<<"\n";
    for(ll i=1;i<=cnt;i++)
        cout<<q[i].x-1<<" "<<q[i].y-1<<"\n";
}
```

---

## 作者：cff_0102 (赞：3)

赛时差点切了，可惜没想到分治。

先说说赛时的思路：

首先，考虑 $2\times2$ 的情况，手动模拟一下，发现点击一个格子之后，它四周的格子都被抵消，此时只有被点击的这个格子被点亮。这样就可以在 $2\times2$ 大小的格子上实现单点修改。

那么，盘面更大的情况呢？

首先，肯定要先选择一个要修改的格子。

![](https://cdn.luogu.com.cn/upload/image_hosting/wwy415zt.png)

接着，要想办法把它上下左右的都消掉，那就尝试一下修改它上下左右的格子。

![](https://cdn.luogu.com.cn/upload/image_hosting/c8x9wwmx.png)

一看，发现盘面上就只剩下这个格子被修改了！把这个操作放到更大的盘面上看，效果就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/cznkh6aw.png)

可以看到，此时原本四周的格子其实被拓展了一倍，超出各格子的地方就上下左右抵消了。这个时候，不难想到可以在外面那四个点上继续进行和现在中心相同的操作：

![](https://cdn.luogu.com.cn/upload/image_hosting/pec1okkt.png)

没错，四周的点到中间的距离再次变成了原来的两倍。如果此时盘面大小是 $8\times8$，那么上下左右消掉，就能实现这个大小的盘面的单点修改。这也就是为什么这道题大小是 $2^n\times2^n$ 的了。

然而，因为我在考场上得到这个发现的时候已经快没时间了，所以我只能随随便便写个 $50$ 分做法：遍历每个点，然后对于每个点都拓展成 $5$ 个点，一直递归下去直到最小，然后将所有要修改的点全部修改一次。重复这种操作，最后每个需要修改的点都能被修改。

那么满分做法是怎么做的呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/8douf56t.png)

将这么一个盘面这样分，可以看到拓展一次后的修改相当于改变了每一个 $2\times2$ 格子的同一个对应位置，如果把每个 $2\times2$ 格子的相同的对应位置都从盘面中拿出来拼成一个新的大小是原来四分之一的小盘面，可以看到这样的操作在小盘面上就变成了正常的改变上下左右相邻格子的操作。这样，就把一个大的盘面变成了四个小的盘面。

同理，继续拆分小的盘面，一直这样分治下去，最后分出若干个 $2\times2$ 的盘面，在这个盘面中就能实现单点修改。

上面的代码就是 std 的实现方法。那么，我在考场上的方法和这个有什么不一样，导致我的考场代码 $50$ 分，而使用分治的代码就能 $100$ 分呢？

我的考场代码是要对每一个点都单独实现单点修改，这样遍历每个点就需要 $O(2^{2n})$ 的时间复杂度，然后实现单点修改的时候每次将修改一个点分成五个点，接着每个点都这样分，复杂度就变成了 $O(5^{n-1})$，乘上前面遍历的时间复杂度就变成了 $O(2^{2n}5^{n-1})$，所以会寄一半的点。

但是如果使用分治，首先 $O(n)$ 分成 $2^{\frac{n}4}$ 个盘面，接着每个盘面单点修改，计算完影响再扩大到更大一级的盘面，重新计算影响，然后只将这个盘面需要变的扩大到更大的盘面。这里可以看到，在很小盘面上可以抵消的，就不需要放到最大的盘面来计算多次。这样，即使每个大小盘面都是每个点都需要修改，时间复杂度最大也就 $O(2^{2n}\times n)$，乘上之前的复杂度变成 $O(n^22^{2n})$，代入最大值 $11$，乘上一点常数，也可以在规定时间跑完。

因此，此题可以用分治通过。

---

## 作者：0x3F (赞：2)

对一个点操作，那么它和它周围的 $4$ 个点都反转颜色。

![](https://s11.ax1x.com/2024/01/22/pFZnj78.png)

如果我们对这个点和周围的 $4$ 个点都操作一遍呢？

![](https://s11.ax1x.com/2024/01/22/pFZnX0f.png)

我们发现，这个图形变大了！

此时，我们按照格子的 $x,y$ 坐标的奇偶性，把整张图分为 $4$ 个部分，分别求出这 $4$ 张图中，哪些位置需要操作。

然后把这些要操作的点在原图中的四周的点也操作一次，重复操作需要抵消。

边界情况是 $n=1$ 时，对周围 $4$ 个点的操作相互抵消，所以返回自身即可。

可以递归，但是逆推实现起来更简单，时间复杂度为 $\mathcal{O}(n4^n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, N, ans;
bool arr[2100][2100], brr[2100][2100];
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	N = (1 << n) - 1;
	for (int i = 0; i <= N; i++) {
		for (int j = 0; j <= N; j++) {
			cin >> arr[i][j];
		}
	}
	for (int t = n-2; t >= 0; t--) {
		int W = (1 << t);
		memset(brr, 0, sizeof(brr));
		for (int i = 0; i <= N; i++) {
			for (int j = 0; j <= N; j++) {
				brr[i][j] ^= arr[i][j];
				brr[(i+W)&N][j] ^= arr[i][j];
				brr[(i-W)&N][j] ^= arr[i][j];
				brr[i][(j+W)&N] ^= arr[i][j];
				brr[i][(j-W)&N] ^= arr[i][j];
			}
		}
		memcpy(arr, brr, sizeof(brr));
	}
	for (int i = 0; i <= N; i++) {
		for (int j = 0; j <= N; j++) {
			ans += arr[i][j];
		}
	}
	cout << ans << '\n';
	for (int i = 0; i <= N; i++) {
		for (int j = 0; j <= N; j++) {
			if (arr[i][j]) cout << i << ' ' << j << '\n';
		}
	}
	cout << flush;
	return 0;
}
```

---

## 作者：SunsetGlow95 (赞：2)

# 题解 - GDKOI 2024 提高组 D2T3 染色

## 简要题意

给定一个边长为 $2^n$ 的 01 循环矩阵，要求构造一组方案选出若干点，使得把每个点及其四个方向的邻点均翻转后，矩阵变为全 0。

## 解法

容易发现，一个点操作与不操作，可以只由它的上下左右四个点决定。

假设翻转与否由矩阵 $v$ 表示，且原矩阵 $w$ 有这样的子矩阵：

```plain
..h..
.icg.
jdabf
.kem.
..l..
```

就是，当前点是 $a$，周围一圈是 $b\sim e$，再往外一圈是 $f\sim m$。

则有

$$\begin{aligned}v_a &= w_a\oplus v_b\oplus v_c\oplus v_d\oplus v_e \\
&= w_a \\
&\oplus (w_b\oplus v_f\oplus v_g\oplus v_a\oplus v_m) \\
&\oplus (w_c\oplus v_g\oplus v_h\oplus v_i\oplus v_a) \\
&\oplus (w_d\oplus v_a\oplus v_i\oplus v_j\oplus v_k) \\
&\oplus (w_e\oplus v_m\oplus v_a\oplus v_k\oplus v_l) \\
&= w_a\oplus w_b\oplus w_c\oplus w_d\oplus w_e\oplus v_f\oplus v_h\oplus v_j\oplus v_l
\end{aligned}$$

令 $w'_a=w_a\oplus w_b\oplus w_c\oplus w_d\oplus w_e$，那么只需要处理

```plain
..h..
.....
j.a.f
.....
..l..
```

的子问题即可。

因此，我们想到这样子的分治：

```plain
! ! ! ! 
 # # # #
! ! ! ! 
 # # # #
! ! ! ! 
 # # # #
! ! ! ! 
 # # # #
```

把整个矩阵像这样子染色，先转化 `!` 和 `#` 的 $w$ 值，然后分别解决 `!` 和 `#` 标识的两个子问题，然后再还原空格处的 $v$ 值。

关于分治的边界：当 $n=0$ 时，每个点自己解决自己，则 $v_a=w_a$。

令 $p=2^n$，则时间复杂度为 $T(p)=O(p^2)+2T(\frac{p}{2})=O(p^2)=O(2^{2n})$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MXN = 1 << 11;
const int DIRs = 4;
const int Xs[] = {1, 0, -1, 0};
const int Ys[] = {0, 1, 0, -1};
int N, cnt;
bool mat[MXN][MXN];
inline int mv(int i, int p, int s) {
  int x(i + p * (1 << s));
  if (x < 0) x += (1 << N);
  if (x >= (1 << N)) x -= (1 << N);
  return x;
}
void solve(int x, int y, int s) {
  if (s == N) return;
  for (int i(0); i != (1 << (N - s)); ++i)
    for (int j(0); j != (1 << (N - s)); ++j)
      if (!((i + j) & 1)) {
        for (int d(0); d != DIRs; ++d)
          mat[mv(x, i, s)][mv(y, j, s)] ^= mat[mv(x, i + Xs[d], s)][mv(y, j + Ys[d], s)];
      }
  solve(x, y, s + 1);
  solve(x + (1 << s), y + (1 << s), s + 1);
  for (int i(0); i != (1 << (N - s)); ++i)
    for (int j(0); j != (1 << (N - s)); ++j)
      if ((i + j) & 1) {
        for (int d(0); d != DIRs; ++d)
          mat[mv(x, i, s)][mv(y, j, s)] ^= mat[mv(x, i + Xs[d], s)][mv(y, j + Ys[d], s)];
      }
}
int main() {
  cin >> N;
  for (int i(0), x(0); i != (1 << N); ++i)
    for (int j(0); j != (1 << N); ++j)
      cin >> x, mat[i][j] = x;
  solve(0, 0, 0);
  for (int i(0); i != (1 << N); ++i)
    for (int j(0); j != (1 << N); ++j) cnt += mat[i][j];
  cout << cnt << endl;
  for (int i(0); i != (1 << N); ++i) {
    for (int j(0); j != (1 << N); ++j)
      if (mat[i][j]) cout << i << ' ' << j << '\n';
    cout << flush;
  }
  return 0;
}
```

---

## 作者：thomaswmy (赞：2)

[题意](https://www.luogu.com.cn/problem/P10085)略

设题目中一次操作为 $f(a)$，则所求为 $f^{-1}(a)$。

显然，$f^k(a)$ 可以拆成每个位置的一次操作异或起来。

#### 引理 1：在一个无穷大的棋盘上，对一个点 $(x,y)$ 进行 $2^k$ 操作剩下 $(x,y),(x-2^k,y),(x+2^k,y),(x,y-2^k),(x,y+2^k)$

>证明：
>
>$k=0$ 时显然成立。
>
>考虑现在做了 $2^k$ 次操作，要再做 $2^k$ 次操作。
>
>手玩一下可以发现，$(x-2^k,y-2^k),(x-2^k,y),(x-2^k,y+2^k),(x,y-2^k),(x,y+2^k),(x+2^k,y-2^k),(x+2^k,y),(x+2^k,y+2^k)$ 都有两次，消失。
>
>而 $(x,y)$ 有 5 次，保留，$(x-2^{k+1},y),(x+2^{k+1},y),(x,y-2^{k+1}),(x,y+2^{k+1})$ 有 1 次，保留。
>
>故引理成立。

#### 引理 2：在一个 $2^n\times2^n$ 的棋盘上，$f^{-1}(x)=f^{2^{n-1}-1}(x)$

>证明：
>
>假如没有限制棋盘大小，则一个点在 $2^{n-1}$ 次操作后 $(x,y)\to(x,y),(x-2^{n-1},y),(x+2^{n-1},y),(x,y-2^{n-1}),(x,y+2^{n-1})$。
>
>又因为 $a-2^{n-1}\equiv a+2^{n-1}\pmod{2^n}$
>
>所以除了 $(x,y)$ 以外的点两两抵消。
>
>故引理成立。

根据引理 2，我们只需要做 $2^{n-1}-1$ 次操作就得到了答案，一次操作可以用 bitset 加速为 $O(\frac{4^n}{\omega})$，总复杂度 $O(\frac{8^n}{\omega})$。

进一步地，根据引理 1, $2^k$ 次操作可以快速求出，复杂度 $O(4^n)$ 或用 bitset $O(\frac{4^n}{\omega})$，所以总复杂度 $O(n4^n)$ 或 $O(\frac{n4^n}{\omega})$。

容易根据引理得出不存在无解且答案唯一。

代码比较容易，常数也挺小。

---

## 作者：大眼仔Happy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10085)

## 前言

赛时觉得是最后一个题很不可做，于是就想直接写一个 bfs 骗一点分就跑路了，没想到却是很简单（不过确实很妙）的构造，而且暴力也不知道莫名其妙寄了。。。

## 题解部分

观察一下图有哪些性质（太懒了，用了[这篇题解](https://www.luogu.com.cn/blog/znpdco/solution-p10085)的图）

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALgAAACNCAYAAAAEhLDZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAT+SURBVHhe7ZvBqmpBEMT8/5++T9+4i0jR0FAjCfRuKmA4Wx9/AY9H9GyEbqKbTN3P3eP/2PN+8t4f+ldeD7fQTXSTqTtaGZzoJo3uaGVwops0uqOVwYlu0uiOVgYnukmjO1oZnOgmje5oZXCimzS6o5XBiW7S6I5WBie6SaM7Whmc6CaN7mhlcKKbNLqjlcGJbtLojlYGJ7pJoztaGZzoJo3uaGVwops0uqOVwYlu0uiOVgYnukmj+7n78C8Iz/uVe3/oX3k93EI30U2m7mhlcKKbNLqjlcGJbtLojlYGJ7pJoztaGZzoJo3uaGVwops0uqOVwYlu0uiOVgYnukmjO1oZnOgmje5oZXCimzS6o5XBiW7S6I5WBie6SaM7Whmc6CaN7mhlcKKbNLqjlcGJbtLojlYGJ7pJoztaGZzoJo3u5+7DvyA871fu/aF/5fVwi7vdO2dvMnVHK4OT4945e5OpO1oZnBz3ztmbTN3RyuDkuHfO3mTqjlYGJ8e9c/YmU3e0Mjg57p2zN5m6o5XByXHvnL3J1B2tDE6Oe+fsTabuaGVwctw7Z28ydUcrg5Pj3jl7k6k7WhmcHPfO2ZtM3dHK4OS4d87eZOqOVgYnx71z9iZTd7QyODnunbM3mbqjlcHJce+cvcnUHa0MTo575+xNpu5oZXBy3DtnbzJ1P3cnqOf95L0/9K+8Hm6x7965u907NLqj1d1Rdu5u9w6N7mh1d5Sdu9u9Q6M7Wt0dZefudu/Q6I5Wd0fZubvdOzS6o9XdUXbubvcOje5odXeUnbvbvUOjO1rdHWXn7nbv0OiOVndH2bm73Ts0uqPV3VF27m73Do3uaHV3lJ27271Dozta3R1l5+5279DojlZ3R9m5u907NLqj1d1Rdu5u9w6N7mh1d5Sdu9u9Q6M7Wt0dZefudu/Q6I5Wd0fZubvdOzS6n7vzoz3vJ+/9oX/l9XCLu907Z28ydUcrg5Pj3jl7k6k7WhmcHPfO2ZtM3dHK4OS4d87eZOqOVgYnx71z9iZTd7QyODnunbM3mbqjlcHJce+cvcnUHa0MTo575+xNpu5oZXBy3DtnbzJ1RyuDk+PeOXuTqTtaGZwc987Zm0zd0crg5Lh3zt5k6o5WBifHvXP2JlN3tDI4Oe6dszeZuqOVwclx75y9ydQdrQxOjnvn7E2m7mhlcHLcO2dvMnU/dyeo5/3kvT/0r7webqGb6CZTd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0Z3tDI40U0a3dHK4EQ3aXRHK4MT3aTRHa0MTnSTRne0MjjRTRrd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0b3c/fhXxCe9yv3/tC/8nq4hW6im0zd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0Z3tDI40U0a3dHK4EQ3aXRHK4MT3aTRHa0MTnSTRne0MjjRTRrd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3P3Yd/QXjer9z7Q//K6+EWuoluMnVHK4MT3aTRHa0MTnSTRne0MjjRTRrd0crgRDdpdEcrgxPdpNEdrQxOdJNGd7QyONFNGt3RyuBEN2l0RyuDE92k0R2tDE50k0Z3tDI40U0a3dHK4EQ36XP//f0DFqz/GR4ShtkAAAAASUVORK5CYII=) $\to$ ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACCCAYAAACkRjFvAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAOzSURBVHhe7ZoxriNREAJ9/0v/Ha+d4YzqAEFJTFhqwQvn9QfweiGan8ytJLgRywZS2t2IZQMp7W7EsoGUdjdi2UBKuxuxbCCl3Y1YNpDS7kYsG0hpdyOWDaS0ux/P679sWdB8H5jFW3TF3EqCG7FsIKXdjVg2kNLuRiwbSGl3I5YNpLS7EcsGUtrdiGUDKe1uxLKBlHY3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2IZQMp7W7EsoGUdjdi2UBKu/vx/Pj7b1ncfB+YxVt0xb37Jtmd+CCW7BJvkt2JD2LJLvEm2Z34IJbsEm+S3YkPYsku8SbZnfggluwSb5LdiQ9iyS7xJtmd+CCW7BJvkt2JD2LJLvEm2Z34IJbsEm+S3YkPYsku8SbZnfggluwSb5LdiQ9iyS7xJtmd+CCW7BJvkt2JD2LJLvEm2Z34IJbsEm+S3YkPYsku8SbZnfg8nk8Jy4Lm+8As3qIr5lYS3IhlAyntbsSygZR2N2LZQEq7G7FsIKXdjVg2kNLuRiwbSGl3I5YNpLS7EcsGUtrdiGUDKe1uxLKBlHY3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2P58fff8vi5vvALN6i53uSj/uG3a2h7kYsG0jTfjdi2UCa9rsRywbStN+NWDaQpv1uxLKBNO13I5YNpGm/G7FsIE373YhlA2na70YsG0jTfjdi2UCa9rsRywbStN+NWDaQpv1uxLKBNO13I5YNpGm/G7FsIE373YhlA2na7348H9myoPk+MIu36Iq5lQQ3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2IZQMp7W7EsoGUdjdi2UBKuxuxbCCl3Y1YNpDS7kYsG0hpdyOWDaS0uxHLBlLa3YhlAyntbsSygZR29+P58fffsrj5PjCLt+iKe/dNsjvxQSzZJd4kuxMfxJJd4k2yO/FBLNkl3iS7Ex/Ekl3iTbI78UEs2SXeJLsTH8SSXeJNsjvxQSzZJd4kuxMfxJJd4k2yO/FBLNkl3iS7Ex/Ekl3iTbI78UEs2SXeJLsTH8SSXeJNsjvxQSzZJd4kuxMfxJJd4k2yO/FBLNkl3iS7Ex/Ekl3iTbI78Xk8nxKWBc33gVm8RVfMrSS4EcsGUtrdiGUDKe1uxLKBlHY3YtlASrsbsWwgpd2NWDaQ0u5GLBtIaXcjlg2ktLsRywZS2t2IZQMp7W7EsoGUbvff3z8gA2mw22z8TwAAAABJRU5ErkJggg==)

记前面的那个 $0$ 级操作，后面那个为 $1$ 级操作。我们可以发现，在上下左右（与中间格子距离为 $1$）和中间共 $5$ 个格子做一次 $0$ 级操作就可以得到 $1$ 级操作。

![](data:image/png;base64,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)

类似的，对于上下左右（与中间格子的距离为 $2$）和中间的格子做 $1$ 级操作，我们就可以得到 $2$ 级操作。可以一直网上推广。

那么这个东西有什么用呢？我们可以发现，当大小为 $2^n\times 2^n$ 时，对于一个格子做一个 $n-1$ 级的操作时，上下抵消，左右抵消。**这是极为关键的一步。**

![](data:image/png;base64,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)

那么我们就可以认为给定的目标就是要操作的 $n-1$ 级操作的位置，然后倒推回 $0$ 级操作即可。

感觉也只是用可能另一种方式来讲这一种方法而已（毕竟都是官方题解），希望这篇更易懂一点。~~应该不算抄袭吧。。。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2050;
const int dx[5]={0,1,0,-1,0},dy[5]={1,0,-1,0,0};
int inline read()
{
	int num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
int n,siz,sum;
int x[N][N],y[N][N];
int main(){
	n=read();siz=(1<<n)-1; // 取模太慢了不妨试一试位运算
	for(int i=0;i<=siz;i++)
		for(int j=0;j<=siz;j++)
			x[i][j]=read();
	for(int t=n-1;t;t--)
	{
		for(int i=0;i<=siz;i++)
			for(int j=0;j<=siz;j++)
				for(int d=0;d<5;d++)
					y[(i+dx[d]*(1<<t-1))&siz][(j+dy[d]*(1<<t-1))&siz]^=x[i][j];
		for(int i=0;i<=siz;i++)
			for(int j=0;j<=siz;j++)
				x[i][j]=y[i][j],y[i][j]=0;
	}
	for(int i=0;i<=siz;i++)
		for(int j=0;j<=siz;j++)
			if(x[i][j])sum++;
	printf("%d\n",sum);
	for(int i=0;i<=siz;i++)
		for(int j=0;j<=siz;j++)
			if(x[i][j])printf("%d %d\n",i,j);
	return 0;
}
```


---

## 作者：Z1qqurat (赞：0)

官方题解依托答辩。

首先发现染一个格子是得到 $w\times w,w=2^1+1$ 的十字架。如果我们对这个十字架中五个点分别染一次 $3\times 3$ 十字架，那么是这样的：

![](https://pic.imgdb.cn/item/65a64ea1871b83018a865a85.jpg)

类似的，对这个 $3\times3$ 的十字架中每个点都染一个 $3\times3$ 的：

![](https://pic.imgdb.cn/item/65a64ea0871b83018a8659a6.jpg)

发现对于 $m=2^n,m\times m$ 的目标矩阵，只要对于每个为 $1$ 的点染上一个 $w=2^{n}+1$ 的十字架即可。然后我们递归地将其变成染 $2^{n-1}+1$ 的，一直递归，这样是过不了的。

![](https://pic.imgdb.cn/item/65a64ea1871b83018a865a40.jpg)

考虑到可能一个点被重复染，这是没有必要的，于是从大到小枚举 $w$ 往下传就可以减少不必要的染色，复杂度 $\mathcal{O}(n\times 2^{2n})$。

这么说很抽象，不如看看 [Submission.](https://qoj.ac/submission/306321)

---


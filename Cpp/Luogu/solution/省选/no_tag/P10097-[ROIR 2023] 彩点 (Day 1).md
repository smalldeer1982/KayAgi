# [ROIR 2023] 彩点 (Day 1)

## 题目背景

翻译自 [ROIR 2023 D1T4](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day1.pdf)。

平面上有 $n$ 个点，分别是 $P_1,P_2,P_3,\dots，P_n$。第 $i$ 个点的坐标为 $(x_i,y_i)$。

选择两个点 $P_i,P_j$（$i\ne j$）。设 $P_i$ 为起始点，$P_j$ 为终止点。**以终止点 $P_j$ 为中心**，从向量 $\overrightarrow{P_iP_j}$ **的方向**开始按照逆时针顺序将除 $P_j$ 以外的点进行排序（角度相同时按照到点 $P_j$ 的距离升序排序）。假设排序后的第 $t$ 个点为 $P_k$，则继续重复操作，设 $P_j$ 为起始点，$P_k$ 为终止点，按照相同的方法重新排序并计算新的终止点的编号。这个过程循环进行。

在下图中，刚开始时 $n=6,t=4,i=1,j=2$。按照顺序将除了 $P_2$ 以外的点排序，结果是 $P_3,P_5,P_1,P_6,P_4$，所以下一个终止点应该是 $P_6$，起始点是 $P_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/x6wd9qkr.png)

此时 $n=6,t=4,i=2,j=6$。继续按照规则排序，如左下图，结果是 $P_4,P_3,P_2,P_1,P_5$。所以下一个终止点是 $P_1$，起始点是 $P_6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/n2mrm47v.png)

此时 $n=6,t=4,i=6,j=1$。继续按照规则排序，如右上图，结果是 $P_5,P_6,P_4,P_2,P_3$。所以下一个终止点是 $P_2$，起始点是 $P_1$。此时就回到刚开始的情况，进入了一个循环。

## 题目描述

我们将 $n$ 个点中的每个点涂上三种颜色之一。第 $i$ 个点的颜色如下确定：

- 如果存在点 $j$，选取点 $i$ 作为起始点，点 $j$ 作为终止点，在上面的过程中点 $i$ 会无数次成为起始点，则将点 $i$ 涂成绿色。
- 如果点 $i$ 没有涂成绿色并且存在点 $j$，选取点 $i$ 作为起始点，点 $j$ 作为终止点，在上面的过程中点 $i$ 至少还能成为起始点一次，则将点 $i$ 涂成蓝色。
- 如果点 $i$ 既不是绿色也不是蓝色，则将点 $i$ 涂成红色。

对于每个点，确定它应该涂成哪种颜色。

## 说明/提示

样例 $1$ 解释：

在前面举的例子中已经知道 $P_1,P_2,P_6$ 构成一个循环，这三个点肯定会被无限次访问，所以应被涂上绿色。

当起始点是 $P_3$ 时，可以令终止点为 $P_1$，排序后 $P_3$ 正好是第四个，这样 $P_3$ 就重回起始点了，如下图。所以应该涂蓝。

![](https://cdn.luogu.com.cn/upload/image_hosting/2ftwju5s.png)

当起始点是 $P_4$ 时，可以选择 $P_5$ 为终止点，排序后 $P_4$ 正好是第四个。所以 $P_4$ 可以涂蓝。当 $P_5$ 是起始点时，易得它既不能被涂上绿色也不能被涂上蓝色，所以涂红。

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $n\le10$，所有点共线 |
| $2$ | $15$ | 所有点共线 |
| $3$ | $10$ | $n\le10$，没有蓝色点 |
| $4$ | $10$ | $n\le10$ |
| $5$ | $15$ | $n\le100$，没有蓝色点 |
| $6$ | $15$ | $n\le100$ |
| $7$ | $5$ | $n\ge3$，所有点构成一个严格凸 $n$ 边形，且按照逆时针顺序输入 |
| $8$ | $20$ | 无 |

对于全部数据，$2 \le n \le 1 000, 1 \le t \le n−1,−10^9 \le x_i, y_i \le 10^9$。

## 样例 #1

### 输入

```
6 4
-1 -1
1 -2
4 -2
2 -4
2 3
-4 -5```

### 输出

```
GGBBRG```

## 样例 #2

### 输入

```
2 1
1 1
2 2```

### 输出

```
GG```

# 题解

## 作者：0xyz (赞：1)

在模拟赛上场切了，但是这题居然没有题解，所以我写一个。

这题可以分成两个部分。我们先推导出 $(i,j)$ 排序后的第 $t$ 个 $w_{i,j}$，再将状态 $(i,j)$ 看成点，向 $(j,w_{i,j})$ 连边，然后就建好了一个 $n^2-n$ 个点的内向基环树森林，同时可以用拓扑排序求出所有环。不难发现 $i$ 是绿点当且仅当存在 $j$ 使 $(i,j)$ 的后继的环上有点 $(i,k)$；$i$ 是蓝点当且仅当所有 $j$ 使 $(i,j)$ 的后继的环上都没有有点 $(i,k)$ 且存在 $j$ 使 $(i,j)$ 的后继有点 $(i,k)$；其余情况 $i$ 是红点。所以，我们建出反图，对每个环用 `bitset` 存储环上的 $i$，从每个环开始向外 dfs，同时给每个点维护一个 `bitset` 表示它后继有哪些 $i$。这两类 `bitset` 综合判断一下就可以求出答案。

接下来是建图。对于固定的 $j$，我们先将其它所有点相对于它逆时针排序，放在 $p,q$ 里。对于不同的 $i$，我们把它到 $j$ 的向量在 $p,q$ 内二分它的位置即可。

时间复杂度 $O(n^2\log n+\frac{n^3}{w})$，空间复杂度 $O(\frac{n^2}{w})$。 

```cpp
#include<bits/stdc++.h>
#define cmp [&](ll u,ll v){return (a[u].y-y)*(a[v].x-x)==(a[v].y-y)*(a[u].x-x)?abs(a[u].x-x)+abs(a[u].y-y)<abs(a[v].x-x)+abs(a[v].y-y):(a[u].y-y)*(a[v].x-x)<(a[v].y-y)*(a[u].x-x);}
using namespace std;
typedef long long ll;
const ll _=1005;
struct o{ll x,y;}a[_];
ll n,t,w[_][_],h[_],v[_*_],d[_*_],op,f[_*_];
vector<ll>e[_*_];
queue<ll>q;
bitset<_>b[_],g[_*_];
void dfs(ll x,ll cl){
	if(b[cl][x/n])h[x/n]|=2;
	if(g[x][x/n])h[x/n]|=1;
	g[x][x/n]=1;
	for(auto y:e[x])
		if(!v[y])g[y]=g[x],dfs(y,cl);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>t;
	for(ll i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	for(ll i=1;i<=n;i++){
		vector<ll>p,q;
		ll x=a[i].x,y=a[i].y;
		for(ll j=1;j<=n;j++)
			if(j!=i){
				if(a[j].x<a[i].x||a[j].x==a[i].x&&a[j].y<a[i].y)p.push_back(j);
				else q.push_back(j);
			}
		sort(p.begin(),p.end(),cmp);
		sort(q.begin(),q.end(),cmp);
		for(ll j=1,l,r,s;j<=n;j++)
			if(j!=i){
				if(a[j].x<a[i].x||a[j].x==a[i].x&&a[j].y<a[i].y){
					for(l=0,r=q.size()-1,s=q.size();l<=r;){
						ll z=l+r>>1;
						if((a[i].x-a[j].x)*(a[q[z]].y-a[i].y)>=(a[i].y-a[j].y)*(a[q[z]].x-a[i].x))s=z,r=z-1;
						else l=z+1;
					}
					if(s+t<=q.size())w[j][i]=q[s+t-1];
					else if(s+t<n)w[j][i]=p[s+t-1-q.size()];
					else w[j][i]=q[s+t-n];
				}else{
					for(l=0,r=p.size()-1,s=p.size();l<=r;){
						ll z=l+r>>1;
						if((a[i].x-a[j].x)*(a[p[z]].y-a[i].y)>=(a[i].y-a[j].y)*(a[p[z]].x-a[i].x))s=z,r=z-1;
						else l=z+1;
					}
					if(s+t<=p.size())w[j][i]=p[s+t-1];
					else if(s+t<n)w[j][i]=q[s+t-1-p.size()];
					else w[j][i]=p[s+t-n];
				}
				e[(i-1)*n+w[j][i]-1].push_back((j-1)*n+i-1);
				f[(j-1)*n+i-1]=(i-1)*n+w[j][i]-1;d[(i-1)*n+w[j][i]-1]++;
			}
	}
	for(ll i=0;i<n*n;i++)
		if(i/n!=i%n&&!d[i])q.push(i);
	while(q.size()){
		ll x=q.front();q.pop();
		if(!--d[f[x]])q.push(f[x]);
	}
	for(ll i=0;i<n*n;i++)
		if(i/n!=i%n&&d[i]&&!v[i]){
			op++;
			for(ll j=i;!v[j];j=f[j])v[j]=op,b[op][j/n]=1;
		}
	for(ll i=0;i<n*n;i++)
		if(i/n!=i%n&&v[i])g[i]=b[v[i]],dfs(i,v[i]);
	for(ll i=0;i<n;i++)
		if(h[i]>1)cout<<'G';
		else if(h[i])cout<<'B';
		else cout<<'R';
	return 0;
}
```

---

## 作者：DerrickLo (赞：0)

考虑转化成图论问题。

我们从 $(i,j)$ 到 $(j,k)$ 连一条边当且仅当从起始点 $i$，终止点 $j$ 的状态可以转化成起始点 $j$，终止点 $k$ 的状态。先考虑如何建图，考虑枚举终止点 $j$，然后将其余点按与 $j$ 点连边后与 $x$ 轴正方向的夹角排序，这里可以先按所在象限排序，再按斜率排序。然后我们考虑枚举 $i$，那么可以直接二分出来对应的 $k$，这样就能在 $\mathcal O(n^2\log n)$ 的时间内完成建图。

那么建完图之后，一个点 $i$ 如果是绿色点当且仅当存在 $j$ 使得 $(i,j)$ 在一个环内，一个点 $i$ 如果是蓝色点当且仅当它不是绿色点并且存在 $j\neq k$ 使得 $(i,j)$ 可以到达 $(i,k)$。

考虑缩点，第一问是简单的，第二问直接对于每个点维护一个 bitset，第 $i$ 位表示这个点是否有 $j$ 使得这个点能到达 $(i,j)$ 就可以了。

时间复杂度 $\mathcal O(n^2\log n+\frac{n^3}{\omega})$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,t,m,x[1005],y[1005],low[1000005],dfn[1000005],st[1000005],top,ins[1000005],cntt,fr[1000005],cnt,vis[1005],fff[1005],co[1000005],in[1000005];
vector<int>ve[1000005],ve2[1000005];
bitset<1005>f[1000005],g[1000005];
queue<int>qu;
struct ee{
	int u,v;
}e[1000005];
struct nd{
	int k,dis,id;
	long double xl;
	friend bool operator<(const nd&a,const nd&b){
		if(a.k!=b.k)return a.k<b.k;
		if(a.xl-b.xl>1e-18||b.xl-a.xl>1e-18)return a.xl-b.xl<1e-18;
		return a.dis<b.dis;
	}
	friend bool operator>(const nd&a,const nd&b){
		return b<a;
	}
}a[1005];
long double slope(int i,int j){
	if(x[i]==x[j]){
		return (int)-1e18;
	}
	return (long double)(y[i]-y[j])/(x[i]-x[j]);
}
int dist(int i,int j){
	return(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
}
int get(int i,int j){
	return(i-1)*n+j;
}
void tarjan(int u){
	low[u]=dfn[u]=++cnt,st[++top]=u,ins[u]=1;
	for(int v:ve[u]){
		if(!dfn[v])tarjan(v),low[u]=min(low[u],low[v]);
		else if(ins[v])low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		cntt++;
		do{
			fr[st[top]]=cntt;
			ins[st[top]]=0;
		}while(st[top--]!=u);
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>t;
	for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
	for(int i=1;i<=n;i++){
		int cnt=0;
		for(int j=1;j<=n;j++)if(i!=j){
			cnt++,a[cnt].dis=dist(i,j),a[cnt].xl=slope(i,j),a[cnt].id=j;
			if(x[j]>x[i]&&y[j]>=y[i])a[cnt].k=1;
			if(x[j]<=x[i]&&y[j]>y[i])a[cnt].k=2;
			if(x[j]<x[i]&&y[j]<=y[i])a[cnt].k=3;
			if(x[j]>=x[i]&&y[j]<y[i])a[cnt].k=4;
		}
		sort(a+1,a+cnt+1);
		for(int j=1;j<=cnt;j++){
			nd xx=a[j];xx.dis=-1e18;
			if(xx.k<=2)xx.k+=2;
			else xx.k-=2;
			int now=lower_bound(a+1,a+cnt+1,xx)-a;
			e[++m]={get(a[j].id,i),get(i,a[(now+t-2)%cnt+1].id)};
			ve[get(a[j].id,i)].emplace_back(get(i,a[(now+t-2)%cnt+1].id));
		}
	}
	for(int i=1;i<=n*n;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i<=n*n;i++)co[fr[i]]++,g[fr[i]][(i-1)/n+1]=1;
	for(int i=1;i<=n*n;i++)if(co[fr[i]]>1)vis[(i-1)/n+1]=1;
	for(int i=1;i<=m;i++)if(fr[e[i].u]!=fr[e[i].v]){
		ve2[fr[e[i].v]].emplace_back(fr[e[i].u]),in[fr[e[i].u]]++;
	}
	for(int i=1;i<=cntt;i++)if(!in[i])qu.push(i);
	while(!qu.empty()){
		int ft=qu.front();qu.pop();
		for(int v:ve2[ft]){
			f[v]|=f[ft],f[v]|=g[ft];
			if(--in[v]==0)qu.push(v);
		}
	}
	for(int i=1;i<=n*n;i++)if(f[fr[i]][(i-1)/n+1]&&!vis[(i-1)/n+1])vis[(i-1)/n+1]=2;
	for(int i=1;i<=n;i++){
		if(vis[i]==1)cout<<"G";
		else if(vis[i]==2)cout<<"B";
		else cout<<"R";
	} 
	return 0;
}
```

---

## 作者：cosf (赞：0)

教练真会搬题，搬了一个没题解、没代码的题。~~我猜他也不会。~~

这场模拟赛直接让这题通过数量翻倍。

---

观察到这题的数据范围特别的小（$n \le 10^3$），所以，可以考虑 $O(n^2\log n)$ 的做法。

注意到，对于起点、终点有序点对 $(i, j)$，它的下一对是唯一确定的（例如样例中 $(1, 2) \to (2, 6)$），因此，如果我们向指向的点连一条边，我们会得到一个内向基环树森林。

显然，对于点 $i$，它能成为绿色的充要条件是存在一个 $j$，使得 $(i, j)$ 存在于某一个环中。

接下来考虑蓝色点。显然，蓝色点不能出现于环中。它的条件是，存在两个点 $j, k$，满足基环树中，$(i, j)$ 为 $(i, k)$ 的祖先。因此，考虑对每一个基环树的子树分别 dfs，并且维护一个桶 $dp_i$，表示 $i$ 是否在祖先中存在，存在了几次。因此，对于一个节点 $(i, j)$，如果 $dp_i$ 不为 $0$，则说明 $i$ 可以为一个蓝色节点。

因为绿色节点优先级比蓝色节点高，所以可以分别维护绿色和蓝色，这样即使在 dfs 中把某个绿色点标成了蓝色点，最终输出时也是绿色的。

---

实际上本题最难写的是，找出 $(i, j)$ 指向的点。

对于 $i$，将所有异于 $i$ 的点 $j$ 分为四类：

1. $x_j = x_i, y_j \gt y_i$。
2. $x_j \lt x_i$。
3. $x_j = x_i, y_j \lt y_i$。
4. $x_j \gt x_i$。

对于第 2、4 类，按照斜率从小到大排序。将四类连在一起，即得到从十二点方向的逆时针顺序。因此，我们可以通过双指针来得到所有以 $i$ 为终点的节点去到哪一个节点。

---

代码很长，注意细节。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <array>
using namespace std;

#define MAXN 1005
#define MAXM 1000006
#define o(x, y) (((x) - 1) * n + (y))
#define gx(x) (((x) - 1) / n + 1)
#define gy(x) (((x) - 1) % n + 1)

using ll = long long;
using pll = array<ll, 2>;

int n, t;

pll v[MAXN];

vector<int> u, l, d, r; // 四类点

int s[MAXN << 2];
int idx = 0;

vector<int> e[MAXM], f[MAXM]; // 内向图、外向图

/* 比较器 */

bool lu(int a, int b)
{
    return v[a][1] < v[b][1];
}

bool cl(int a, int b)
{
    if (v[a][1] * v[b][0] == v[b][1] * v[a][0])
    {
        return v[a][0] > v[b][0];
    }
    return v[a][1] * v[b][0] < v[b][1] * v[a][0];
}

bool dl(int a, int b)
{
    return v[a][1] * v[b][0] < v[b][1] * v[a][0];
}

bool rd(int a, int b)
{
    return v[a][1] > v[b][1];
}

bool cr(int a, int b)
{
    if (v[a][1] * v[b][0] == v[b][1] * v[a][0])
    {
        return v[a][0] < v[b][0];
    }
    return v[a][1] * v[b][0] < v[b][1] * v[a][0];
}

bool dr(int a, int b)
{
    return v[a][1] * v[b][0] < v[b][1] * v[a][0];
}

bool ins[MAXM], vis[MAXM]; // 是否遍历到了、是否曾经遍历过
bool rng[MAXM]; // 是否在环上

bool ir = false; // 是否继续标记环

bool dfs1(int p) // 找环
{
    if (ins[p] == true)
    {
        ir = true;
        ins[p] = false;
        rng[p] = true;
        vis[p] = true;
        return true;
    }
    ins[p] = true;
    for (int u : e[p])
    {
        if (vis[u])
        {
            continue;
        }
        bool r = dfs1(u);
        if (r)
        {
            rng[p] = ir;
            if (!ins[p])
            {
                ir = false;
            }
            vis[p] = true;
            return ins[p];
        }
    }
    vis[p] = true;
    return false;
}

bool G[MAXN], B[MAXN]; // 绿色点、蓝色点

int dp[MAXN]; // 桶

void dfs2(int p) // 找蓝色点
{
    if (dp[gx(p)])
    {
        B[gx(p)] = true;
    }
    dp[gx(p)]++;
    for (int u : f[p])
    {
        dfs2(u);
    }
    dp[gx(p)]--;
}

int main()
{
    cin >> n >> t;
    for (int i = 1; i <= n; i++)
    {
        cin >> v[i][0] >> v[i][1];
    }
    for (int i = 1; i <= n; i++)
    {
        idx = 0;
        u.clear();
        l.clear();
        d.clear();
        r.clear();
        for (int j = 1; j <= n; j++)
        {
            if (i == j)
            {
                continue;
            }
            v[j][0] -= v[i][0];
            v[j][1] -= v[i][1];
            if (v[j][0] == 0 && v[j][1] > 0)
            {
                u.push_back(j);
            }
            else if (v[j][0] < 0)
            {
                l.push_back(j);
            }
            else if (v[j][0] == 0)
            {
                d.push_back(j);
            }
            else
            {
                r.push_back(j);
            }
        }
        sort(u.begin(), u.end(), lu);
        sort(l.begin(), l.end(), cl);
        sort(d.begin(), d.end(), rd);
        sort(r.begin(), r.end(), cr);
        for (int j : u) // 找到了四类点。需要复制三份，才不会越界（实测）
        {
            s[++idx] = j;
            s[idx + n - 1] = j;
            s[idx + 2 * n - 2] = j;
        }
        for (int j : l)
        {
            s[++idx] = j;
            s[idx + n - 1] = j;
            s[idx + 2 * n - 2] = j;
        }
        int mid = idx;
        for (int j : d)
        {
            s[++idx] = j;
            s[idx + n - 1] = j;
            s[idx + 2 * n - 2] = j;
        }
        for (int j : r)
        {
            s[++idx] = j;
            s[idx + n - 1] = j;
            s[idx + 2 * n - 2] = j;
        }
        for (int l = 1, r = mid + 1; l <= mid; l++) // 双指针
        {
            if (v[s[l]][0] == 0)
            {
                e[o(s[l], i)].push_back(o(i, s[r + t - 1]));
                f[o(i, s[r + t - 1])].push_back(o(s[l], i));
                continue;
            }
            while (v[s[r]][0] == 0 && v[s[r]][1] < 0)
            {
                r++;
            }
            v[0] = {-v[s[l]][0], -v[s[l]][1]};
            while (v[s[r]][0] > 0 && dr(s[r], 0))
            {
                r++;
            }
            e[o(s[l], i)].push_back(o(i, s[r + t - 1]));
            f[o(i, s[r + t - 1])].push_back(o(s[l], i));
        }
        for (int l = mid + 1, r = n; l < n; l++)
        {
            if (v[s[l]][0] == 0)
            {
                e[o(s[l], i)].push_back(o(i, s[r + t - 1]));
                f[o(i, s[r + t - 1])].push_back(o(s[l], i));
                continue;
            }
            while (v[s[r]][0] == 0 && v[s[r]][1] > 0)
            {
                r++;
            }
            v[0] = {-v[s[l]][0], -v[s[l]][1]};
            while (v[s[r]][0] < 0 && dl(s[r], 0))
            {
                r++;
            }
            e[o(s[l], i)].push_back(o(i, s[r + t - 1]));
            f[o(i, s[r + t - 1])].push_back(o(s[l], i));
        }
        for (int j = 1; j <= n; j++)
        {
            if (i == j)
            {
                continue;
            }
            v[j][0] += v[i][0];
            v[j][1] += v[i][1];
        }
    }
    for (int i = 1; i <= n * n; i++) // 找环。注意判掉 (i, i) 等非法点
    {
        if (e[i].empty())
        {
            continue;
        }
        if (!vis[i])
        {
            ir = false;
            dfs1(i);
        }
    }
    for (int i = 1; i <= n * n; i++) // 标记绿色
    {
        if (e[i].empty())
        {
            continue;
        }
        if (rng[i])
        {
            G[gx(i)] = 1;
            G[gy(i)] = 1;
        }
    }
    for (int i = 1; i <= n * n; i++)// 找蓝色点
    {
        if (e[i].empty())
        {
            continue;
        }
        if (!rng[i] && rng[e[i][0]]) // 一个点能否作为一个子树的根
        {
            dfs2(i);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        if (G[i])
        {
            cout << 'G';
        }
        else if (B[i])
        {
            cout << 'B';
        }
        else
        {
            cout << 'R';
        }
    }
    cout << endl;
    return 0;
}

```

---


# [ROIR 2023] 一个普通的字符串问题 (Day 2)

## 题目背景

翻译自 [ROIR 2023 D2T4](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day2.pdf)。

如果对于任意长度为 $2$ 的字符串 $u$，字符串 $s$ 中 $u$ 的出现次数与字符串 $t$ 中 $u$ 的出现次数相同，则两个字符串 $s$ 和 $t$ 称为等效字符串。因此，字符串 `aaaba`、`abaaa` 和 `baaab` 彼此等效（字符串 `aa` 出现两次，字符串 `ab` 出现一次，字符串 `ba` 出现一次，字符串 `bb` 不作为子串出现），而字符串 `cff` 和 `ccf` 则不等效。一个字符串和它本身是等效的。

## 题目描述

在这个问题中，你将会得到 $Q$ 个由字符 `a`、`b` 和 `c` 组成的字符串，对于每个字符串，需要计算与它等效的由字符 `a`、`b` 和 `c` 组成的非空字符串的数量。由于这个数量可能非常大，所以要求对 $10^9 + 7$ 取余。

## 说明/提示

样例说明：

- 字符串 `abaa` 等效于字符串 `abaa`、`aaba`、`baab`；
- 字符串 `abca` 等效于字符串 `abca`、`bcab`、`cabc`；
- 字符串 `ccbca` 等效于字符串 `ccbca` 和 `cbcca`；
- 字符串 `bacc` 只等效于字符串 `bacc`。

本题使用捆绑测试。

$n_i$ 表示第 $i$ 个输入字符串的长度，$L$ 表示所有字符串的长度之和，$w$ 表示所有查询中最大（未取模）的答案。

| 子任务编号 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 输入数据与样例相同 |
| $1$ | $11$ | $s$ 中不含 `c` |
| $2$ | $13$ | $s$ 中 `a` 与 `c` 不相邻 |
| $3$ | $11$ | $n_i\le13$ |
| $4$ | $10$ | $L\le40$ |
| $5$ | $9$ | $L\le60$ |
| $6$ | $13$ | $L\le10^5,w\le100$ |
| $7$ | $33$ | 无 |

对于 $100\%$ 数据，$1\le q\le10^5$，$L\le10^6$。

## 样例 #1

### 输入

```
0
4
abaa
abca
ccbca
bacc```

### 输出

```
3
3
2
1```

# 题解

## 作者：_lbw_ (赞：9)

对于相邻的字符 $s_i,s_{i+1}$，连边 $s_i\to s_{i+1}$。

也就是说，我们要求在这张点数为 $3$ 的图上走一条欧拉**路径**，对**点**区分的方案数。

对于欧拉相关记数，考虑 BEST 定理。

但有两个问题：

- BEST 定理是对**边**区分的。
- BEST 定理是欧拉**回路**。

首先我们处理区分方式不同的问题，考虑求欧拉**路径**对**边**区分的方案数，这个问题除以每条重边次数的阶乘即为原问题的答案。

然后处理回路，枚举起点和终点，从终点向起点连一条边，我们发现因为 BEST 定理是对**边**区分且循环同构，我们把每一种方案旋转，使得我们新加那条边在最后即可。

所以此时直接套用 BEST 定理公式即可，点数较少可以手动求外向树。

实现时注意图不一定取满 $3$ 个点。

时间复杂度 $\mathcal{O}(L+q|\sum|^5)$，[代码](https://www.luogu.com.cn/paste/ykm3ombo)。

---

## 作者：Purslane (赞：1)

# Solution

一道普通的组合计数问题。

考虑现在有三种点，$\rm A$、$\rm B$、$\rm C$，表示这三种颜色的连续段。

我们需要保证这三种颜色的连续段两两相邻的次数满足题目所给的条件。再次基础上，如果我们知道三种颜色分别出现了多少次，就可以具体分配内部 $\rm a$、$\rm b$、$\rm c$ 的个数以实现目标。

后者是平凡的，关注一下前面的问题。

-----

先考虑计算 $\rm A$、$\rm B$、$\rm C$ 出现的次数。我们发现，除了第一个位置以外，其他的字母必定为某一条相邻关系的出边。也就是说，如果我们枚举起点，我们就知道每个位置的出现次数了。

显然我们还可以判断，那种点的最后一个是没有出边的，具体表现为这种点的总出边比这种点的出现次数少 $1$。

如果只有一种点出现，答案是 $3$（如果 $n=1$）或 $1$（$n>1$），下面不妨设有两种点出现。

一种很自然的想法是，我们可以把每个点的所有出边赋上颜色，表示它走向另外两个点中的哪一个。每一种序列都会对应唯一一个颜色的赋值方式，但是有的颜色赋值方式可能是不合法的。

假设 $\rm A$ 的最后一个点没有出边。当 $\rm B$ 和 $\rm C$ 的最后一个点走向的都不是 $\rm A$，那么最后一个 $\rm A$ 会提前出现，这时候就路断了。而如果 $\rm B$ 或 $\rm C$ 的最后一个走向 $\rm A$，那么就是合法的。不妨设 $\rm B$ 最后一个走向 $\rm A$，那么 $\rm A$ 之后显然不会返回 $\rm B$，有可能已经结束了，有可能返回到 $\rm C$。$\rm C$ 这时候也不能去 $\rm B$，但是它又不能结束（根据假设），因此会在 $\rm A$ 和 $\rm C$ 中徘徊，最终正确的停在 $\rm A$。

这样写几个组合数就好了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e6+10,MOD=1e9+7;
int op,n,m,q,frac[MAXN],inv[MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int C(int u,int d) {
	if(u>d) return 0;
	return frac[d]*inv[u]%MOD*inv[d-u]%MOD;	
}
string S;
int cnt[3][3];
signed main() {
	freopen("str.in","r",stdin);
	freopen("str.out","w",stdout);
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	m=2000000;
	frac[0]=1;
	ffor(i,1,m) frac[i]=frac[i-1]*i%MOD;
	inv[m]=qpow(frac[m],MOD-2);
	roff(i,m-1,0) inv[i]=inv[i+1]*(i+1)%MOD;
	cin>>op>>q;
	ffor(i,1,q) {
		cin>>S,n=S.size(),S="&"+S;
		if(n==1) {
			cout<<3<<'\n';
			continue ;
		}
		int flg=1;
		memset(cnt,0,sizeof(cnt));
		ffor(j,2,n) cnt[S[j-1]-'a'][S[j]-'a']++,flg&=(S[j]==S[1]);
		if(flg) {
			cout<<1<<'\n';
			continue ;	
		}
		int ans=0;
		ffor(s,0,2) {
			int col[3]={0,0,0},in[3]={0,0,0},out[3]={0,0,0};
			col[s]++;
			ffor(c1,0,2) ffor(c2,0,2) if(c1!=c2) in[c2]+=cnt[c1][c2],out[c1]+=cnt[c1][c2],col[c2]+=cnt[c1][c2];
			int flg=0,psl=0,ed=0;
			ffor(c,0,2) {
				if(out[c]!=col[c]&&out[c]+1!=col[c]) flg=1;
				if(out[c]!=col[c]) psl++,ed=c;
			}
			if(out[s]==0) continue ;
			if(flg||psl!=1) continue ;
			int mul=C(cnt[0][1],out[0])*C(cnt[1][0],out[1])%MOD*C(cnt[2][0],out[2])%MOD;
			if(ed==0) mul=(mul-C(cnt[0][1],out[0])*C(cnt[1][0],out[1]-1)%MOD*C(cnt[2][0],out[2]-1)%MOD)%MOD;
			else if(ed==1) mul=(mul-C(cnt[0][1],out[0]-1)*C(cnt[1][0],out[1])%MOD*C(cnt[2][1],out[2]-1)%MOD)%MOD;
			else mul=(mul-C(cnt[0][2],out[0]-1)*C(cnt[1][2],out[1]-1)%MOD*C(cnt[2][0],out[2])%MOD)%MOD;
			ffor(c,0,2) {
				if(col[c]==0) {
					if(cnt[c][c]!=0) mul=0;
					continue ;
				}
				mul=mul*C(col[c]-1,cnt[c][c]+col[c]-1)%MOD;
			}
			ans=(ans+mul)%MOD;
		}
		cout<<(ans%MOD+MOD)%MOD<<'\n';
	}
	return 0;
}
```

-----

我怎么想不到 $\rm BEST$ 引理，这辈子真有了。

---

## 作者：shinzanmono (赞：0)

考虑相邻两字符连边，问题转化为通路个数。

考虑 BEST 定理。

> BEST 定理：有向图欧拉回路数 $P=T\prod(outdeg_i-1)!$，其中 $T$ 是原图外向生成树个数。

下文使用**图**来表示**有向图**。

显然，$T$ 可以使用矩阵树定理求出，而我们想知道的是如何将欧拉通路转化为欧拉回路。

考虑一个图可以有一条欧拉回路当且仅当所有顶点的入度与出度相等。而有欧拉通路则有两个点的入度出度不等。显然我们就可以确定起点 $s$，终点 $t$。我们加一条 $t\rightarrow s$ 的边然后跑 BEST 即可。

如果起点终点未确定，那么每一个循环重构都可以给答案贡献一次，总次数为 $n-1$，总数要乘 $n-1$。

每条边是相同的，所以我们需要除去 $c(u,v)!$，其中 $c(u,v)$ 表示 $u$ 到 $v$ 的边数。

然后就是 BEST 定理板子了。

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using ll=long long;
const int sz=1e6+10;
const ll mod=1e9+7;
ll fact[sz],inv[sz];
ll qpow(ll base,ll exp){
  ll ans=1;
  while(exp!=0){
    if(exp&1)ans=ans*base%mod;
    base=base*base%mod,exp>>=1;
  }
  return ans;
}
int main(){
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin>>t>>t;
  while(t--)[](){
    int n,N=3;
    std::string str;
    std::cin>>str,n=str.size(),str=" "+str;
    if(n==1)return std::cout<<"3\n",void();
    fact[0]=1;
    for(int i=1;i<=n;i++)fact[i]=fact[i-1]*i%mod;
    inv[n]=qpow(fact[n],mod-2);
    for(int i=n-1;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;
    std::vector<std::vector<int>>cnt(3,std::vector<int>(3));
    std::vector<std::vector<ll>>det(3,std::vector<ll>(3));
    std::vector<int>ind(3),oud(3);
    for(int i=1;i<n;i++){
      int u=str[i]-'a',v=str[i+1]-'a';
      oud[u]++,ind[v]++;
      det[v][v]++,det[u][v]--,cnt[u][v]++;
    }
    int s=-1,t=-1;
    for(int i=0;i<N;i++){
      if(ind[i]<oud[i])s=i,ind[s]++;
      if(ind[i]>oud[i])t=i,oud[t]++;
    }
    ll ans=1;
    for(int i=0;i<N;i++)
      for(int j=0;j<N;j++)ans=ans*inv[cnt[i][j]]%mod;
    for(int i=0;i<N;i++)ans=ans*fact[std::max(oud[i]-1,0)]%mod;
    std::vector<bool>sim(3);
    for(int i=0;i<N;i++)sim[i]=oud[i]==0;
    for(int i=0;i<N;i++){
      if(!sim[i]){
        sim[i]=true;
        break;
      }
    }
    ll res=1;
    if(s!=-1)det[s][s]++,det[t][s]--;
    if(!sim[0]&&!sim[1])res=det[0][0]*det[1][1]-det[1][0]*det[0][1];
    if(!sim[0]&&!sim[2])res=det[0][0]*det[2][2]-det[2][0]*det[0][2];
    if(!sim[1]&&!sim[2])res=det[1][1]*det[2][2]-det[1][2]*det[2][1];
    if(sim[0]+sim[1]+sim[2]==2)res=det[0][0]*(1-sim[0])+det[1][1]*(1-sim[1])+det[2][2]*(1-sim[2]);
    ans=ans*(res%mod+mod)%mod;
    if(s==-1)ans=ans*(n-1)%mod;
    std::cout<<ans<<"\n";
  }();
  return 0;
}
```

---


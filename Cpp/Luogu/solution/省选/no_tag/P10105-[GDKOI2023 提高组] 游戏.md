# [GDKOI2023 提高组] 游戏

## 题目描述

你正在树上玩游戏。

给定一棵 $n$ 个结点的树，有 $Q$ 次询问，每次给定 $x, y, z$，你要找到三个点 $(u, v, w)$ 满足 $\operatorname{dis}(u, v) =
x, \operatorname{dis}(u, w) = y, \operatorname{dis}(v, w) = z$。其中 $\operatorname{dis}(u, v)$ 表示树上 $u$ 和 $v$ 两点唯一简单路径所包含的边数，$\operatorname{dis}(u, u) = 0$。
保证有解。


## 说明/提示

对于 10% 的数据，满足 $n, Q ≤ 500$。

对于 20% 的数据，满足 $n, Q ≤ 2 \times 10^3$。

对于另外 20% 的数据，满足 $Q = 1$。

对于另外 20% 的数据，满足 $Q \le 10$。

对于另外 10% 的数据，满足第 $i$ 条边连接 $i$ 和 $i + 1$。

对于另外 10% 的数据，满足 $x = 0$。

对于 100% 的数据，满足 $1 ≤ n, Q ≤ 2 \times 10^5, 0 ≤ x, y, z ≤ 2 \times 10^5$。

下发 checker 和 checker.exe，分别用于 64 位 linux 以及 windows 下的答案校验。

你可以使用 `./checker < 输入文件名 > < 输出文件名 > < 答案文件名 >` 来检测你的输出文件是否合
法。

实际上下发的 checker 并不会用到答案文件，所以你只需要随便选择一个文件作为答案文件即可。

你需要保证输入文件合法，即格式正确并且有解，否则可能会出现未知错误。

根据你的输出文件的问题，checker 分别会返回一下信息：

1. 如果你的输出文件正确，则 checker 会返回 `Accepted!`。
2. 如果在第 $t$ 组数据，答案错误，则 checker 会返回 `Wrong answer on test t!`。
3. 如果你的格式错误，则 checker 会返回 `wrong output format` 后接相关错误信息。

UPD: 在洛谷下发 chk.cpp。

## 样例 #1

### 输入

```
10
7 10
2 8
10 2
8 1
9 7
4 5
1 6
9 4
4 3
10
3 2 1
5 4 1
6 6 0
3 0 3
1 5 4
2 5 7
6 5 1
2 1 3
2 0 2
2 2 0```

### 输出

```
2 6 1
7 6 1
9 6 6
6 2 6
6 1 7
8 6 4
9 6 1
1 2 6
6 8 6
8 6 6```

# 题解

## 作者：jr_linys (赞：6)

[P10105 [GDKOI2023 提高组] 游戏](https://www.luogu.com.cn/problem/P10105)  
去年Day2爆零打铜，今年又打铜。当时锯材务必的我赛后这题搞了两星期。

给出的 $3$ 个距离对应的路径的交汇点为中心点，设中心点到那三个点的距离为 $x,y,z$。
$$
\begin{cases}
x+y=u\\
x+z=v\\
y+z=w
\end{cases}
$$
可得
$$x=\frac{u+v-w}{2}$$

然后可用换根 DP 查找每个点的最长链、次长链、次次长链来自哪里，维护儿子方最长链、到根节点路径的倍增。

接着对一个询问，找到满足最长链、次长链的限制下次次长链最长的中心点，这是一个二维偏序问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){//哮哮快读
	char c;
	while(c=getchar(),c<'0'||c>'9');
	int x=c^'0';
	while(c=getchar(),c>='0'&&c<='9') x=x*10+(c^'0');
	return x;
}
const int N=2e5,M=18;
int n,logn,q,m,cnt;
int dep[N+5],siz[N+5][3],fr[N+5][3],zz[N+5][3];
int dss[N+5][2],ds[N+5][M],fa[N+5][M];
vector<int> g[N+5];

struct stu{int x,y,z,id;}dot[N+5],qs[N+5];
bool cmp(stu a,stu b){
	if(a.y==b.y) a.x>b.x;
	return a.y>b.y;
}
struct stu2{int x,id;}fuc[N+5];
bool cmp2(stu2 a,stu2 b){return a.x>b.x;}
int ans[N+5][3],xid[N+5];

void dfs1(int u,int fat){
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v!=fat){
			dep[v]=dep[u]+1;
			fa[v][0]=u;
			for(int i=1;i<=logn;i++) fa[v][i]=fa[fa[v][i-1]][i-1];//父节点方向倍增
			dfs1(v,u);
			
			for(int i=0;i<3;i++){
				if(siz[v][0]+1>siz[u][i]){
					for(int j=2;j>i;j--) siz[u][j]=siz[u][j-1],fr[u][j]=fr[u][j-1],zz[u][j]=zz[u][j-1];
					siz[u][i]=siz[v][0]+1,fr[u][i]=v,zz[u][i]=u;
					break; 
				}
			}
		}
	}
	ds[u][0]=dss[u][0]=fr[u][0],dss[u][1]=fr[u][1];//重子链和次重子链方向
	for(int i=1;i<=logn;i++) ds[u][i]=ds[ds[u][i-1]][i-1];//重子链倍增
}
void dfs2(int u,int fat){
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v!=fat){
			int sizu,zzu;//换根，处理来自父节点方向的最长连
			if(fr[u][0]==v) sizu=siz[u][1]+1,zzu=zz[u][1];
			else sizu=siz[u][0]+1,zzu=zz[u][0];
			for(int i=0;i<3;i++){
				if(sizu>siz[v][i]){
					for(int j=2;j>i;j--) siz[v][j]=siz[v][j-1],fr[v][j]=fr[v][j-1],zz[v][j]=zz[v][j-1];
					siz[v][i]=sizu,fr[v][i]=u,zz[v][i]=zzu;
					break;
				}
			}
			dfs2(v,u);
		}
	}
	dot[++cnt]={siz[u][0],siz[u][1],siz[u][2],u};//储存三元组+id
}

int trs[N+5],tri[N+5];
void upd(int x,int s,int id){//树状数组，trs为最大第三长链，tri为中心点
	for(;x<=n;x+=x&-x) if(s>trs[x]) trs[x]=s,tri[x]=id;
}
int ask(int x){
	int s=-1,id=0;
	for(;x;x-=x&-x) if(trs[x]>s) s=trs[x],id=tri[x];
	return id;//求的是中心点
}
int find(int x){//找到最长连符合条件的范围
	int l=1,r=n+1;
	while(r-l>1){
		int mid=l+r>>1;
		fuc[mid].x>=x? l=mid:r=mid;
	}return l;
}
int line(int u,int d,int x){
	if(!x) return u;
	int z=zz[u][d],len=dep[u]-dep[z],ans=u;
	if(x<=len){//在起点一侧
		for(int i=logn,y=(1<<logn);i>=0;i--,y>>=1) if(x&y) ans=fa[ans][i];
	}else{//在另一侧
		int fs=u;
		if(len){//转折点非自身
			for(int i=logn,y=(1<<logn);i>=0;i--,y>>=1) if((len-1)&y) fs=fa[fs][i];
			d=(dss[z][0]==fs);
		}else d=(fr[u][d]!=dss[u][0]);//转折点是自身
		x-=len+1,ans=dss[z][d];//跳到转折点的 重儿子/次重儿子
		for(int i=logn,y=(1<<logn);i>=0;i--,y>>=1) if(x&y) ans=ds[ans][i];//倍增
	}
	return ans;
}
int main(){
	memset(trs,-1,sizeof(trs));//初始值要为-1,不然为第三长为0的不会更新
	n=read(),logn=__lg(n);
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		g[u].push_back(v),g[v].push_back(u);
	}
	
	dfs1(1,-1),dfs2(1,-1);
	
	//对最长连进行离散化，以便用树状数组维护
	sort(dot+1,dot+1+n,cmp);
	fuc[1]={dot[1].x,1};
	for(int i=2;i<=n;i++) fuc[i]={dot[i].x,i};
	sort(fuc+1,fuc+1+n,cmp2);
	for(int i=1;i<=n;i++) xid[fuc[i].id]=i;
	
	q=read();
	for(int i=1;i<=q;i++){
		int x=read(),y=read(),z=read();
		x=x+y-z>>1,y-=x,z-=y,swap(y,z);
		ans[i][1]=1,ans[i][2]=2;
		if(x<y) swap(x,y),swap(ans[i][0],ans[i][1]);
		if(x<z) swap(x,z),swap(ans[i][0],ans[i][2]);
		if(y<z) swap(y,z),swap(ans[i][1],ans[i][2]);
		qs[i]={x,y,z,i};
	}
	sort(qs+1,qs+1+q,cmp);
	cnt=1;
	for(int i=1;i<=q;i++){
		int x=qs[i].x,y=qs[i].y,z=qs[i].z,id=qs[i].id;
		while(cnt<=n&&dot[cnt].y>=y) upd(xid[cnt],dot[cnt].z,dot[cnt].id),cnt++;
		int u=ask(find(x));
		int sss[3]={ans[id][0],ans[id][1],ans[id][2]};
		ans[id][sss[0]]=line(u,0,x),ans[id][sss[1]]=line(u,1,y),ans[id][sss[2]]=line(u,2,z);
	}
	for(int i=1;i<=q;i++) printf("%d %d %d\n",ans[i][0],ans[i][1],ans[i][2]);
}
```

---

## 作者：qczrz6v4nhp6u (赞：3)

### 题意

给定一颗有 $n$ 个节点的无边权的树，有 $q$ 次询问，每次给定 $(x,y,z)$，找到三个点 $(u,v,w)$，满足：

$$\begin{cases}\text{dis}(u,v)=x\\\text{dis}(u,w)=y\\\text{dis}(v,w)=z\end{cases}$$

其中 $\text{dis}(u,v)$ 表示树上 $u$ 和 $v$ 两点间唯一简单路径所包含的边数。保证有解。

### Solution

注意：以下定义一颗子树的深度为其在原树中深度最大的节点的深度。

一个结论：$u\to v,u\to w,v\to w$ 的路径必然交于一点。

我们把三条路径的交点记作 $p$，则：

$$\begin{cases}\text{dis}(u,p)+\text{dis}(p,v)=x\\\text{dis}(u,p)+\text{dis}(p,w)=y\\\text{dis}(v,p)+\text{dis}(p,w)=z\end{cases}$$

于是解得：

$$\begin{cases}\text{dis}(u,p)=\frac12(x+y-z)\\\text{dis}(v,p)=\frac12(x-y+z)\\\text{dis}(w,p)=\frac12(-x+y+z)\end{cases}$$

发现 $u,v,w$ 到 $p$ 的距离一定，于是我们可以找出一个 $p$，使得 **以 $p$ 作为根** 时，在三个不相同的子树内存在合法的 $u,v,w$。

分配 $u,v,w$ 的事可以贪心搞：找出以 $p$ 作为根时，$p$ 的最大、次大、次次大深度的子树，按距离降序分配即可。

求出以 $p$ 作为根时，$p$ 的最大、次大、次次大深度的子树可以换根 DP 预处理。

现在就剩一个问题：如何找出符合条件的 $p$？

考虑我们先前的贪心。我们要找的是以 $p$ 作为根时，$p$ 的最大、次大、次次大深度的子树分别大于等于 $\text{dis}(u,p),\text{dis}(v,p),\text{dis}(w,p)$ 的最大、次大、次次大值的 $p$。

发现这是一个三维偏序，直接把询问离线跑 CDQ 分治即可。

时间复杂度 $O(n\log ^2 n)$。构造答案时倍增即可。

---

到这里已经可以通过了，但我们有更简洁的做法：三维偏序可以降成二维。

注意到我们维护的是 **存在** 一个点，满足询问的偏序关系。

而 CDQ 维护了所有满足偏序关系的点对，未免太过浪费。

考虑贪心：在前两维满足条件的情况下，第三维要尽可能大。

于是这就化为了二维。排序 + 树状数组取个 $\max$ 即可。

时间复杂度 $O(n\log n)$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
#define Tp template<typename T>
#define Ts template<typename T,typename... _T>
char buf[1<<20],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=buf+fread(p1=buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
Tp inline void read(T& x){
    x=0;char c=getchar();bool f=0;
    for(;!isdigit(c);c=getchar())if(c=='-')f=1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    f&&(x=-x);
}
Ts inline void read(T& x,_T&... y){read(x),read(y...);}
Tp inline void copy(T* a,T* b,int len){for(int i=0;i<len;i++)b[i]=a[i];}
Tp inline void assign(T* a,int len,T b=0){for(int i=0;i<len;i++)a[i]=b;}
Tp inline void ckmin(T& x,T y){x=min(x,y);}
Tp inline void ckmax(T& x,T y){x=max(x,y);}
const int N=2e5+5,INF=1e9;
int n,q;
vector<int>Gr[N];
void ins(int x,int y){Gr[x].push_back(y);}
struct node1{
    int dis,x;
    bool operator <(const node1& _)const{return dis!=_.dis?dis<_.dis:x<_.x;}
    bool operator !=(const node1& _)const{return dis!=_.dis;}
};
struct node2{
    int x,y,z,op,id;
    bool operator <(const node2& _)const{
        if(x!=_.x)return x>_.x;
        if(y!=_.y)return y>_.y;
        if(z!=_.z)return z>_.z;
        return op<_.op;
    }
};
struct node3{
    int x,id;
    bool operator <(const node3& _)const{return x!=_.x?x<_.x:id<_.id;}
};
int fat[N][20],dep[N];
node1 f[N],g[N];
bool cmp(const int& a,const int& b){return !(f[a]<f[b]);}
void dfs1(int x,int fa){
    fat[x][0]=fa;
    dep[x]=dep[fa]+1;
    for(int i=0;fat[x][i];i++)
        fat[x][i+1]=fat[fat[x][i]][i];
    f[x]={0,x};
    for(auto y:Gr[x])
        if(y!=fa){
            dfs1(y,x);
            if(f[x].dis<f[y].dis+1){
                f[x]=f[y];
                f[x].dis++;
            }
        }
}
node1 pre[N],suf[N];
int out[N],len;
void dfs2(int x,int fa){
    len=0;
    for(auto y:Gr[x])
        if(y!=fa)out[++len]=y;
    pre[0]=suf[len+1]={0,0};
    for(int i=1;i<=len;i++)pre[i]=max(pre[i-1],f[out[i]]);
    for(int i=len;i>=1;i--)suf[i]=max(suf[i+1],f[out[i]]);
    for(int i=1;i<=len;i++)g[out[i]]=max(max(pre[i-1],suf[i+1]),g[x]),g[out[i]].dis++;
    for(auto y:Gr[x])
        if(y!=fa)dfs2(y,x);
}
int LCA(int x,int y){
    if(x==y)return x;
    if(dep[x]<dep[y])swap(x,y);
    for(int i=19;i>=0;i--)
        if(dep[fat[x][i]]>=dep[y])x=fat[x][i];
    if(x==y)return x;
    for(int i=19;i>=0;i--)
        if(fat[x][i]!=fat[y][i])x=fat[x][i],y=fat[y][i];
    return fat[x][0];
}
node3 c[N];
void add(int x,node3 k){
    for(;x<=n+1;x+=x&-x)
        ckmax(c[x],k);
}
node3 ask(int x){
    node3 ans={0,0};
    for(;x;x-=x&-x)
        ckmax(ans,c[x]);
    return ans;
}
node1 Q[N][3];
node2 a[N*2];int tot;
int ans[N];
int find(int p,int dis,int k){
    if(k>=Gr[p].size())return p;
    if(Gr[p][k]==fat[p][0]){
        int x=g[p].x,lca=LCA(p,x);
        if(dep[p]-dep[lca]<dis){
            dis=dep[p]+dep[x]-dep[lca]*2-dis;
            p=x;
        }
    }
    else{
        int x=f[Gr[p][k]].x;
        dis=dep[x]-dep[p]-dis;
        p=x;
    }
    for(int i=19;i>=0;i--)
        if(dis>>i&1)
            p=fat[p][i];
    return p;
}
int main(){
    read(n);
    for(int i=1;i<n;i++){
        int x,y;
        read(x,y);
        ins(x,y),ins(y,x);
    }
    dfs1(1,0);
    dfs2(1,0);
    for(int i=1;i<=n;i++){
        node1 temp=f[fat[i][0]];
        f[fat[i][0]]=g[i];
        sort(Gr[i].begin(),Gr[i].end(),cmp);
        a[++tot].id=i;
        a[tot].op=0;
        if(Gr[i].size()>=1)a[tot].x=f[Gr[i][0]].dis+1;
        if(Gr[i].size()>=2)a[tot].y=f[Gr[i][1]].dis+1;
        if(Gr[i].size()>=3)a[tot].z=f[Gr[i][2]].dis+1;
        f[fat[i][0]]=temp;
    }
    read(q);
    for(int i=1;i<=q;i++){
        int x,y,z,s;
        read(x,y,z);
        s=(x+y+z)>>1;
        Q[i][0]={s-z,0};
        Q[i][1]={s-y,1};
        Q[i][2]={s-x,2};
        sort(Q[i],Q[i]+3,[](const node1& a,const node1& b){return a.dis>b.dis;});
        a[++tot]={Q[i][0].dis,Q[i][1].dis,Q[i][2].dis,1,i};
    }
    sort(a+1,a+tot+1);
    for(int i=1;i<=tot;i++){
        if(a[i].op)ans[a[i].id]=ask(n-a[i].y+1).id;
        else add(n-a[i].y+1,{a[i].z,a[i].id});
    }
    for(int i=1;i<=q;i++){
        int p=ans[i];
        Q[i][0].dis=find(p,Q[i][0].dis,0);
        Q[i][1].dis=find(p,Q[i][1].dis,1);
        Q[i][2].dis=find(p,Q[i][2].dis,2);
        sort(Q[i],Q[i]+3,[](const node1& a,const node1& b){return a.x<b.x;});
        printf("%d %d %d\n",Q[i][0].dis,Q[i][1].dis,Q[i][2].dis);
    }
    return 0;
}
```


---

## 作者：P2441M (赞：2)

## 题意
给定一颗 $n$ 个点的树，$q$ 次询问 $x,y,z$，找到 $3$ 个点 $u,v,w$ 满足 $\operatorname{dist}(u,v)=x,\operatorname{dist}(u,w)=y,\operatorname{dist}(v,w)=z$，数据保证有解。$1\leq n,q\leq 2\times 10^5$。

## 题解
首先有经典结论，三点两两间的路径恰好交于一点 $p$，且三点位于点 $p$ 的不同子树中。我们容易列出关于 $\operatorname{dist}(p,u),\operatorname{dist}(p,v),\operatorname{dist}(p,w)$ 的方程：
$$
\begin{cases}
\operatorname{dist}(p,u)+\operatorname{dist}(p,v)=x\\
\operatorname{dist}(p,u)+\operatorname{dist}(p,w)=y\\
\operatorname{dist}(p,v)+\operatorname{dist}(p,w)=z
\end{cases}
$$
解得
$$
\begin{cases}
\operatorname{dist}(p,u)=\frac{x+y-z}{2}\\
\operatorname{dist}(p,v)=\frac{x-y+z}{2}\\
\operatorname{dist}(p,w)=\frac{-x+y+z}{2}\\
\end{cases}
$$
考虑枚举这个点 $p$ 后怎么做：我们需要 $u,v,w$ 放到 $p$ 的不同的子树里，那直接贪心，将距离 $p$ 最大的点放到以 $p$ 为根深度最大的子树中，距离次大、次次大同理。

于是我们对于每个点，预处理出以它为根，深度最大/次大/次次大的子树深度，这个可以树形 DP 做。令 $f_{u,0/1/2}$ 表示以 $u$ 为根时深度最大/次大/次次大的子树深度，$g_{u,0/1/2}$ 表示对应的叶子，$b_{u,0/1/2}$ 表示是从哪个子树转移过来的。初值令 $f_{u,0}\leftarrow 0,g_{u,0}\leftarrow u,b_{u,0}\leftarrow u$，对于 $i=1/2$ 的 $f$ 令 $f_{u,i}\leftarrow -\infty$。转移相当于每次把 $f_{u,0/1/2}$ 和 $f_{v,0}$ 放在一起排序，取前 $3$ 大，写一个类似冒泡排序的东西就行了。然后做换根 DP，注意 $v$ 从父亲节点 $u$ 处的子树转移时，要保证 $b_{u,i}\neq v$，转移是类似的。

那么现在我们需要找到一个满足要求的点 $p$，满足 $f_{p,0}\geq a,f_{p,1}\geq b,f_{p,2}\geq c$，看上去是三维偏序，但是我们可以对 $f_{p,2}$ 这一维直接贪心，变成找到一个点 $p$，满足 $f_{p,0}\geq a,f_{p,1}\geq b$ 且 $f_{p,2}$ 最大，这样就是二维偏序了，扫描线，用树状数组维护后缀 $\max$ 和 $\operatorname{argmax}$ 即可。

最后就是找到点 $p$ 后，需要找出对应的 $x,y,z$，相当于要查询从 $x$ 开始，沿着 $\text{path}(x,y)$ 跳 $k$ 步到达的点。这是简单的，倍增预处理树上 $2^k$ 级祖先，然后做简单的分类讨论即可。注意我们会把 $\operatorname{dist}(p,u),\operatorname{dist}(p,v),\operatorname{dist}(p,w)$ 排序，计算答案时需要恢复原来的顺序。

视 $n,q$ 同阶，时间复杂度为 $\mathcal{O}(n\log{n})$。

## 代码
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 2e5 + 5, LGN = 18 + 5, INF = 1e9;

int n, q, f[N][3], g[N][3], b[N][3], ans[N];
int lg2[N], dep[N], fa[LGN][N];
int sz;

struct Rec { int id, val, ans; };
struct Pt {
	int id, x, y, z;
	bool operator<(const Pt &p) const { return x > p.x; }
} p[N];
struct Query {
	int id, x, y, z;
	bool operator<(const Query &q) const { return x > q.x; }
} qr[N], tq[N];
struct AdjList {
	int tot, head[N], nxt[N << 1], to[N << 1];
	void init() { tot = 0, memset(head + 1, -1, n << 2); }
	void ins(int x, int y) { to[++tot] = y, nxt[tot] = head[x], head[x] = tot; }
} t;
struct BIT {
	pii c[N];
	void init() { for (int i = 0; i <= n + 1; ++i) c[i] = { -INF, -INF }; }
	pii query(int x) {
		pii res = { -INF, 0 };
		for (; x <= n + 1; x += lowbit(x)) chk_max(res, c[x]);
		return res;
	}
	void change(int x, pii v) { for (; x; x -= lowbit(x)) chk_max(c[x], v); }
} ft;

bool cmp1(Rec x, Rec y) { return x.val > y.val; }
bool cmp2(Rec x, Rec y) { return x.id < y.id; }

void add(int x, int val, int lf, int br) {
	if (val < f[x][2]) return;
	f[x][2] = val, g[x][2] = lf, b[x][2] = br;
	for (int i = 2; i; --i) if (f[x][i] > f[x][i - 1])
		swap(f[x][i], f[x][i - 1]), swap(g[x][i], g[x][i - 1]), swap(b[x][i], b[x][i - 1]);
}
void dfs1(int x) {
	for (int i = 1; i <= lg2[dep[x]]; ++i) fa[i][x] = fa[i - 1][fa[i - 1][x]];
	f[x][0] = 0, g[x][0] = b[x][0] = x, f[x][1] = f[x][2] = -INF;
	for (int i = t.head[x]; ~i; i = t.nxt[i]) {
		int y = t.to[i];
		if (y == fa[0][x]) continue;
		fa[0][y] = x, dep[y] = dep[x] + 1, dfs1(y);
		add(x, f[y][0] + 1, g[y][0], y);
	}
}
void dfs2(int x) {
	for (int i = t.head[x]; ~i; i = t.nxt[i]) {
		int y = t.to[i];
		if (y == fa[0][x]) continue;
		for (int j = 0; j < 3 && f[x][j] != INF; ++j)
			if (b[x][j] != y) { add(y, f[x][j] + 1, g[x][j], x); break; }
		dfs2(y);
	}
}
int lca(int x, int y) {
	if (dep[x] > dep[y]) swap(x, y);
	for (int i = lg2[dep[y] - dep[x]]; ~i; --i)
		if (dep[fa[i][y]] >= dep[x]) y = fa[i][y];
	if (x == y) return x;
	for (int i = lg2[dep[x]]; ~i; --i)
		if (fa[i][x] ^ fa[i][y]) x = fa[i][x], y = fa[i][y];
	return fa[0][x];
}
int kth_anc(int x, int k) {
	for (int i = lg2[k]; ~i; --i)
		if (k >> i & 1) x = fa[i][x];
	return x;
}
int kth(int x, int y, int k) {
	int d = lca(x, y);
	if (y == d) swap(x, y), k = dep[y] - dep[x] - k;
	if (dep[y] - dep[d] >= k) return kth_anc(y, k);
	k -= dep[y] - dep[d];
	return kth_anc(x, dep[x] - dep[d] - k);
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n, t.init(), ft.init();
    for (int i = 1, u, v; i < n; ++i) cin >> u >> v, t.ins(u, v), t.ins(v, u);
    for (int i = 2; i <= n; ++i) lg2[i] = lg2[i >> 1] + 1;
    dep[1] = 1, dfs1(1), dfs2(1);
    for (int i = 1; i <= n; ++i)
    	if (f[i][1] >= 0) p[++sz] = { i, f[i][0], f[i][1], f[i][2] };
    cin >> q;
    for (int i = 1, u, v, w; i <= q; ++i) {
    	static int val[3];
    	cin >> u >> v >> w;
    	val[0] = (u + v - w) >> 1, val[1] = (u - v + w) >> 1, val[2] = (-u + v + w) >> 1;
    	tq[i] = { i, val[0], val[1], val[2] };
    	sort(val, val + 3);
    	qr[i] = { i, val[2], val[1], 0 };
    }
    sort(p + 1, p + sz + 1), sort(qr + 1, qr + q + 1);
    for (int x = n, i = 1, j = 1; ~x; --x) {
    	while (i <= sz && p[i].x == x) ft.change(p[i].y + 1, { p[i].z, p[i].id }), ++i;
     	while (j <= q && qr[j].x == x) ans[qr[j].id] = ft.query(qr[j].y + 1).second, ++j;
    }
    for (int i = 1; i <= q; ++i) {
    	static Rec val[3];
    	int p = ans[i];
    	val[0] = { 0, tq[i].x }, val[1] = { 1, tq[i].y }, val[2] = { 2, tq[i].z };
    	sort(val, val + 3, cmp1);
    	for (int j = 0; j < 3; ++j) val[j].ans = kth(g[p][j], p, val[j].val);
    	sort(val, val + 3, cmp2);
    	for (int j = 0; j < 3; ++j) cout << val[j].ans << " \n"[j == 2];
    }
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

我们只关心每个点往外最长的三条链，这个可以换根 DP 做一下，设三条链从大到小为 $a,b,c$。

那么每个询问我们就需要找一个点，满足这个点到三个点 $(x,y,z)$ 的距离是某个数，这个题目没有给出，但是可以根据给的三个数解个方程得到：

$$\begin{cases} x+y=u \\x+z=v\\ y+z=w\end{cases}$$

解方程得：

$$\begin{cases} x=u+v-w \\y=u-v+w\\ z=-u+v+w\end{cases}$$

设 $x \le y \le z$，则我们需要找到一个点满足 $x \le a,y \le b,z \le c$。

考虑三维偏序，第一维开桶倒着扫，第二维线段树下标，第三维区间最大值。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=200200,M=20,T=3; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll l,r;
	ll data;
}X[N<<2];
struct St{
    ll x,y,z;
}W[N];
struct Pair{
	ll x,y;
	bool operator<(const Pair&rhs)const{
		if(x==rhs.x)
		  return y<rhs.y;
		return x<rhs.x;
	}
}Max[N][T];
ll n,q;
ll d[N],F[N][M];
ll ans[N];
vector<Pair> Q[N];
vector<ll> E[N],G[N];
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void dfs1(ll u,ll fa){
    d[u]=d[fa]+1;
    ll son=0;
    for(ll i=0;i<3;i++)
	  Max[u][i]={0,u};
    for(auto v:E[u]){
    	if(v==fa)
    	  continue;
        son++;
        F[v][0]=u;
        for(ll j=1;j<20;j++)
		  F[v][j]=F[F[v][j-1]][j-1];
        dfs1(v,u);
        auto k=Max[v][0];
		k.x++;
        for(ll j=0;j<3;j++)
		  if(k.x>=Max[u][j].x)
		    swap(k,Max[u][j]);
    }
}
void dfs2(ll u,ll fa,Pair k){
    for(ll i=0;i<3;i++)
	  if(k.x>=Max[u][i].x)
	    swap(k,Max[u][i]);
    for(auto v:E[u]){
    	if(v==fa)
    	  continue;
        Pair t;
        if(Max[u][0].y==Max[v][0].y)
		  t=Max[u][1];
        else 
		  t=Max[u][0];
        t=max(t,k);
        t.x++;
        dfs2(v,u,t);
    }
}
ll lca(ll x,ll y){
    if(d[x]>d[y])
	  swap(x,y);
    for(ll i=M-1;i>=0;i--)
	  if(d[F[y][i]]>=d[x])
	    y=F[y][i];
    if(x==y)
	  return x;
    for(ll i=M-1;i>=0;i--)
	  if(F[x][i]!=F[y][i])
	    x=F[x][i],y=F[y][i];
    return F[x][0];
}
ll dis(ll x,ll y){
    return d[x]+d[y]-2*d[lca(x,y)];
}
ll get(ll x,ll y,ll k){
    ll z=lca(x,y);
    if(k>d[x]-d[z]){
        k=d[x]+d[y]-2*d[z]-k;
        x=y;
    }
    for(ll i=M-1;i>=0;i--)
	  if(d[x]-d[F[x][i]]<=k)
	    k-=d[x]-d[F[x][i]],x=F[x][i];
    return x;
}
void pushup(ll k){
    if(Max[X[k<<1].data][2].x>=Max[X[k<<1|1].data][2].x)
	  X[k].data=X[k<<1].data;
    else 
	  X[k].data=X[k<<1|1].data;
}
void build(ll k,ll l,ll r){
	X[k].l=l,X[k].r=r;
	if(l==r)
	  return ;
	ll mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
}
void update(ll k,ll i,ll x){
    if(X[k].l==i&&i==X[k].r){
        if(Max[x][2].x>=Max[X[k].data][2].x)
		  X[k].data=x;
        return;
    }
    ll mid=(X[k].l+X[k].r)>>1;
    if(i<=mid)
	  update(k<<1,i,x);
    else 
	  update(k<<1|1,i,x);
    pushup(k);
}
ll qurey(ll k,ll l,ll r){
    if(l==X[k].l&&X[k].r==r)
	  return X[k].data;
    ll mid=(X[k].l+X[k].r)>>1;
    if(r<=mid)
      return qurey(k<<1,l,r);
    else if(l>mid)
      return qurey(k<<1|1,l,r);
    else{
    	ll t1=qurey(k<<1,l,mid),t2=qurey(k<<1|1,mid+1,r);
    	if(Max[t1][2].x>=Max[t2][2].x)
    	  return t1;
    	else
    	  return t2;
	}
}
bool check(ll x,ll y,ll z,ll u,ll v,ll w,ll p){
    return dis(p,u)==x&&dis(p,v)==y&&dis(p,w)==z;
}
void print(ll a,ll b,ll c){
	write(a);
	putchar(' ');
	write(b);
	putchar(' ');
	write(c);
	putchar('\n');
}
void check(ll i){
    vector<ll> S;
    ll p=ans[i];
    S.push_back(W[i].x);
	S.push_back(W[i].y);
	S.push_back(W[i].z);
	sort(S.begin(),S.end());
    ll u=get(p,Max[p][0].y,S[2]);
	ll v=get(p,Max[p][1].y,S[1]);
	ll w=get(p,Max[p][2].y,S[0]);
    if(check(W[i].x,W[i].y,W[i].z,u,v,w,p))
      print(u,v,w);
    else if(check(W[i].x,W[i].y,W[i].z,u,w,v,p))
	  print(u,w,v);
    else if(check(W[i].x,W[i].y,W[i].z,v,u,w,p))
	  print(v,u,w);
    else if(check(W[i].x,W[i].y,W[i].z,v,w,u,p))
	  print(v,w,u);
    else if(check(W[i].x,W[i].y,W[i].z,w,u,v,p))
	  print(w,u,v);
    else
      print(w,v,u);
}
int main(){
    n=read();
    for(ll u,v,i=1;i<n;i++){
        u=read(),v=read();
        add(u,v);
    }
    dfs1(1,0);
	dfs2(1,0,{0,0});
	build(1,0,n);
    for(ll i=1;i<=n;i++)
	  G[Max[i][0].x].push_back(i);
    q=read();
    for(ll x,y,z,t1,t2,t3,i=1;i<=q;i++){
    	vector<ll> S;
    	x=read(),y=read(),z=read();
    	t1=(x+y-z)>>1,t2=(x-y+z)>>1,t3=(-x+y+z)>>1;
        W[i]={t1,t2,t3};
        S.push_back(t1);
		S.push_back(t2);
		S.push_back(t3);
		sort(S.begin(),S.end());
        Q[S[2]].push_back({i,S[1]});
    }
    for(ll i=n;i>=0;i--){
        for(ll x:G[i])
		  update(1,Max[x][1].x,x);
        for(Pair p:Q[i])
		  ans[p.x]=qurey(1,p.y,n);
    }
    for(ll i=1;i<=q;i++)
      check(i);
    return 0;
}
```


---

## 作者：未来姚班zyl (赞：1)

~~感受过几道 GDKOI 的题后感叹 GDKOI 是真的牛逼，比如这道签到题。~~

## 题目大意

给你一棵树，多次询问，每次询问要求你给出三个点 $u,v,w$，使得它们互相的距离等于给定值 $x,y,z$。

## 题目分析

思考三个点的位置关系会是怎样的，并想办法转换为可做的形式。

简单思考后发现只有两种情况，第一种是一个点在其它两点的路径上，第二种与之相反。

我们会发现这两种情况下三条路径都会交于某个点，设其为 $p$，则以 $p$ 为根，三个点在不同子树。此时**两点距离等于两点深度之和**，这带来了三组等量关系，故可以解出三点的深度。

这时题目转换成，能否以一个点为根，在它不同的三个子树中找出三个给定深度的点。显然，从一个子树里找，只需找到该子树距离 $p$ 最远的叶子，往上跳即可，倍增即可实现。要找到合法的 $p$ 只需维护其最深、次深、次次深的子树，分别大于等于三个深度中的最大、次大、次次大值即可，显然这是有解的充要条件。维护这些子树的方法是简单的换根 dp。

所以可以直接二位偏序，对最大值扫描线，以次大值为下标，求次次大值的 $\max$ 即可，再加上倍增构造答案，总复杂度 $O(n\log n)$，可以通过此题。

代码是一坨，仅供参考。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid (l+r>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
using namespace std;
const int N=2e5+5,inf=(1LL<<31)-1;
struct nod{
	int x,d;
}S;
struct node{
	nod mx,se,th;
}a[N];
inline bool cmp(nod a,nod b){
	return a.d<=b.d;
}
inline void insert(node &x,nod k){
	if(cmp(x.mx,k))x.th=x.se,x.se=x.mx,x.mx=k;
	else if(cmp(x.se,k))x.th=x.se,x.se=k;
	else if(cmp(x.th,k))x.th=k;
}
int n,m,h[N],to[N<<1],nxt[N<<1],cnt,dep[N],f[N][19],t[N],d[N];
inline void add_(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
	to[++cnt]=a,nxt[cnt]=h[b],h[b]=cnt;
}
inline void dfs(int x,int fa){
	dep[x]=dep[fa]+1,f[x][0]=fa;
	rep(i,1,18)f[x][i]=f[f[x][i-1]][i-1];
	e(x)if(y^fa)dfs(y,x),insert(a[x],{a[y].mx.x,a[y].mx.d+1});
}
struct spe{
	int y;
	nod k;
};
inline void Dfs(int x,int fa,nod k){
	vector<spe>p;
	nod pr=k;
	insert(a[x],k),k.d++;
	if(cmp(k,{x,1}))k={x,1};
	e(x)if(y^fa){
		nod nw=a[y].mx;
		nw.d+=2,p.pb({y,k});
		if(cmp(k,nw))k=nw;
	}
	k=pr,k.d++;
	if(cmp(k,{x,1}))k={x,1};
	int siz=p.size();
	per(i,siz-1,0){
		int y=p[i].y;
		nod nw=a[y].mx;
		nw.d+=2;
		if(cmp(p[i].k,k))p[i].k=k;
		Dfs(y,x,p[i].k);
		if(cmp(k,nw))k=nw;
	}
}
vector<int>p[N],q[N];
struct que{
	int a,b,c;
}b[N],g[N]; 
inline void ad(int x,int k){
	x=n+1-x;
	while(x<=n+1)t[x]=cmp(a[t[x]].th,a[k].th)?k:t[x],x+=x&-x;
}
inline int query(int x){
	x=n+1-x;
	int ans=0;
	while(x)ans=cmp(a[ans].th,a[t[x]].th)?t[x]:ans,x-=x&-x;
	return ans;
}
inline void sor(int &a,int &b,int &c){
	int d=max({a,b,c}),e=min({a,b,c}),s=a+b+c;
	a=d,b=s-d-e,c=e;
}
inline void jump(int &x,int dep){
	int p=0;
	while(dep){
		if(dep&1)x=f[x][p];
		p++,dep>>=1;
	}
}
inline int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	jump(x,dep[x]-dep[y]);
	per(i,18,0)if(f[x][i]^f[y][i])x=f[x][i],y=f[y][i];
	return x==y?x:f[x][0];
}
inline int dist(int x,int y){
	return dep[x]+dep[y]-dep[lca(x,y)]*2;
}
inline int getp(int x,int y,int d){
	int la=lca(x,y);
	int dx=dep[x]-dep[la],dy=dep[y]-dep[la],dis=dx+dy;
	if(dx>=d)return jump(x,d),x;
	return jump(y,dis-d),y; 
}
inline bool che(int a,int b,int c,int i){
	return dist(a,b)==g[i].a&&dist(a,c)==g[i].b&&dist(b,c)==g[i].c;
}
inline void solve(int &a,int &b,int &c,int i){
	if(che(a,b,c,i))return;
	if(che(a,c,b,i))return swap(b,c),void();
	if(che(b,a,c,i))return swap(a,b),void();
	if(che(b,c,a,i))return swap(a,b),swap(b,c),void();
	if(che(c,a,b,i))return swap(a,c),swap(b,c),void();
	swap(a,c);
}
inline void Main(){
	n=read(),S.d=-inf,a[0].th=S;
	repn(i)a[i]={{i,0},S,S};
	rep(i,2,n)add_(read(),read());	
	dfs(1,0),Dfs(1,0,S);
	repn(i)insert(a[i],{i,0}),insert(a[i],{i,0}),p[a[i].mx.d].pb(i);
	m=read();
	repm(i){
		int x=read(),y=read(),z=read();
		b[i]={(x+y-z)/2,(x-y+z)/2,(-x+y+z)/2},g[i]={x,y,z},sor(b[i].a,b[i].b,b[i].c),q[b[i].a].pb({i});
	}
	per(i,n,0){
		E(i)ad(a[y].se.d,y);
		for(auto y:q[i])d[y]=query(b[y].b);
	}
	repm(i){
		int x=d[i],u=getp(x,a[x].mx.x,b[i].a),v=getp(x,a[x].se.x,b[i].b),w=getp(x,a[x].th.x,b[i].c);
		solve(u,v,w,i),printf("%d %d %d\n",u,v,w);
	}
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}
```


---

## 作者：N2MENT (赞：0)

去年模拟赛写的。（我写的）是依托答辩，警示后人，想清楚再写。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ysv2u7t.png)

_这是赛时的结果_


因为它浪费了我三个小时，所以无论如何都要发点东西。

注意到 $u$，$v$，$w$ 之间的连边一定交汇于一点，并形成一个三爪鱼一样的东西，然后找到每个点分别连出去最长的链，可以三维偏序（二维也可以，但是赛时没想到）。

以下是我的代码（赛后美化了一点）：

AC code：

```cpp
#include <bits/stdc++.h>  
using namespace std;
namespace _0x0620AF {
    typedef long long ll;
    typedef long double ld;
    void swap(int &a, int &b) {
        a ^= b, b ^= a, a ^= b;
    }
    void swap(ll &a, ll &b) {
        a ^= b, b ^= a, a ^= b;
    }
    template <typename T>
    T Max(const T &a, const T &b) {
        if (a > b)
            return a;
        return b;
    }
    template <typename T>
    T Min(const T &a, const T &b) {
        if (a < b)
            return a;
        return b;
    }
#define epb emplace_back
#define ep emplace
    inline ll read() {
        ll x = 0;
        bool f = false;
        char c = getchar();
        while (!isdigit(c)) {
            if (c == '-')
                f = true;
            c = getchar();
        }
        while (isdigit(c)) {
            x = (x << 1) + (x << 3) + (c ^ 48);
            c = getchar();
        }
        return f ? -x : x;
    }
    int OutPut[100];
    inline void write(ll x, char end) {
        if (x == 0) {
            putchar('0');
            putchar(end);
            return;
        }
        int len = 0;
        if (x < 0) {
            x = -x;
            putchar('-');
        }
        while (x) OutPut[len++] = x % 10, x /= 10;
        while (len--) putchar(OutPut[len] ^ 48);
        putchar(end);
    }
    inline void write2(ll x, char end) {
        if (x == 0) {
            putchar('0');
            putchar(end);
            return;
        }
        int len = 0;
        if (x < 0) {
            x = -x;
            putchar('-');
        }
        while (x) OutPut[len++] = x & 1, x >>= 1;
        while (len--) putchar(OutPut[len] ^ 48);
        putchar(end);
    }
    inline void write(ll x) {
        if (x == 0) {
            putchar('0');
            return;
        }
        int len = 0;
        if (x < 0) {
            x = -x;
            putchar('-');
        }
        while (x) OutPut[len++] = x % 10, x /= 10;
        while (len--) putchar(OutPut[len] ^ 48);
    }
    inline void write2(ll x) {
        if (x == 0) {
            putchar('0');
            return;
        }
        int len = 0;
        if (x < 0) {
            x = -x;
            putchar('-');
        }
        while (x) OutPut[len++] = x & 1, x >>= 1;
        while (len--) putchar(OutPut[len] ^ 48);
    }
}
using namespace _0x0620AF;
const int maxn = 2e5 + 10;
class Node {
public:
    int a, b, c, num;
    Node() = default;
    Node(int a, int b, int c, int num) : a(a), b(b), c(c), num(num) {}
};
class MaxDis {
public:
    int v[3];
    int len[3];
    void Insert(int u, int dis) {
        if (dis >= len[0]) {
            v[2] = v[1];
            len[2] = len[1];
            v[1] = v[0];
            len[1] = len[0];
            v[0] = u;
            len[0] = dis;
        } else if (dis >= len[1]) {
            v[2] = v[1];
            len[2] = len[1];
            v[1] = u;
            len[1] = dis;

        } else if (dis >= len[2]) {
            v[2] = u;
            len[2] = dis;
        }
    }
};
class Pair {
public:
    int v, len;
    Pair() = default;
    Pair(int v, int len) : v(v), len(len) {}
    const bool operator<(const Pair &d) const {
        if (len != d.len)
            return len > d.len;
        else
            return v > d.v;
    }
};
class SegTree {
public:
#define lc (k << 1)
#define rc (k << 1 | 1)
    int tr[maxn << 2];
    void Update(int k) {
        if (tr[lc] && tr[rc]) {
            tr[k] = tr[lc];
            return;
        }
        tr[k] = tr[lc] + tr[rc];
    }
    void Modify(int k, int l, int r, int adr, int val) {
        if (l == r) {
            tr[k] = val;
            return;
        }
        int mid = (l + r) >> 1;
        if (adr <= mid)
            Modify(lc, l, mid, adr, val);
        else
            Modify(rc, mid + 1, r, adr, val);
        Update(k);
    }
    int Query(int k, int l, int r, int L, int R) {
        if (L <= l && r <= R) {
            return tr[k];
        }
        int res = 0;
        int mid = (l + r) >> 1;
        if (L <= mid)
            res = Query(lc, l, mid, L, R);
        if (res)
            return res;
        if (R > mid)
            res = Query(rc, mid + 1, r, L, R);
        return res;
    }
#undef lc
#undef rc
} sgt;
vector<int> G[maxn];
MaxDis to[maxn];
int fa[maxn][21];
int dep[maxn];
int dfn[maxn], cnt;
int siz[maxn];
void dfs(int u, int f) {
    fa[u][0] = f;
    dep[u] = dep[f] + 1;
    dfn[u] = ++cnt;
    siz[u] = 1;
    to[u].v[0] = to[u].v[1] = to[u].v[2] = u;
    for (int i = 1; i < 21; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int v : G[u]) {
        if (v == f)
            continue;
        dfs(v, u);
        siz[u] += siz[v];
        to[u].Insert(to[v].v[0], (to[v].len[0]) + 1);
    }
}
Pair suf[maxn], pre[maxn];
Pair g[maxn];
void dfs2(int u, int f) {
    for (int i = 0; i < 3; i++) {
        if (dfn[u] <= dfn[to[f].v[i]] && dfn[to[f].v[i]] < dfn[u] + siz[u])
            continue;
        else {
            to[u].Insert(to[f].v[i], to[f].len[i] + 1);
            break;
        }
    }
    for (int v : G[u]) {
        if (v == f)
            continue;
        dfs2(v, u);
    }
}
bool cmp(const Node &a, const Node &b) {
    if (a.a != b.a)
        return a.a > b.a;
    if (a.b != b.b)
        return a.b > b.b;
    if (a.c != b.c)
        return a.c > b.c;
    return a.num > b.num;
}
bool cmp2(const Node &a, const Node &b) {
    if (a.b != b.b)
        return a.b > b.b;
    if (a.c != b.c)
        return a.c > b.c;
    return a.num > b.num;
}
int ans[maxn];
Node seq[maxn << 1];
Node tmp[maxn << 1];
Node qry[maxn];
int top;
int n, q;
int in[3];
int x[maxn], y[maxn], z[maxn];
int a[maxn], b[maxn], c[maxn];
void Merge(int l, int r) {
    int mid = (l + r) >> 1;
    int p1 = l, p2 = mid + 1;
    for (int i = l; i <= r; i++) {
        if (p2 > r) {
            tmp[i] = seq[p1];
            p1++;
        } else if (p1 > mid) {
            tmp[i] = seq[p2];
            p2++;
        } else if (cmp2(seq[p1], seq[p2])) {
            tmp[i] = seq[p1];
            p1++;
        } else {
            tmp[i] = seq[p2];
            p2++;
        }
    }
    for (int i = l; i <= r; i++) seq[i] = tmp[i];
}
void cdq(int l, int r) {
    if (l == r)
        return;
    int mid = (l + r) >> 1;
    cdq(l, mid);
    cdq(mid + 1, r);
    int p = l;
    for (int i = mid + 1; i <= r; i++) {
        while (p <= mid && seq[p].b >= seq[i].b) {
            if (seq[p].num > 0)
                sgt.Modify(1, 1, n + 1, seq[p].c + 1, seq[p].num);
            p++;
        }
        if (seq[i].num < 0) {
            int t = sgt.Query(1, 1, n + 1, seq[i].c + 1, n + 1);
            if (t != 0)
                ans[-seq[i].num] = t;
        }
    }
    for (int i = l; i < p; i++) {
        if (seq[i].num > 0)
            sgt.Modify(1, 1, n + 1, seq[i].c + 1, 0);
    }
    Merge(l, r);
}
int lca(int x, int y) {
    if (dep[x] < dep[y])
        swap(x, y);
    for (int i = 20; ~i; i--) {
        if ((1 << i) <= (dep[x] - dep[y]))
            x = fa[x][i];
    }
    if (x == y)
        return x;
    for (int i = 20; ~i; i--) {
        if (fa[x][i] != fa[y][i]) {
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    return fa[x][0];
}
int Cut(int u, int v, int len) {
    if (dfn[u] <= dfn[v] && dfn[v] < dfn[u] + siz[u]) {
        int del = (dep[v] - dep[u]) - len;
        for (int i = 20; ~i; i--) {
            if ((1 << i) <= del) {
                v = fa[v][i];
                del -= (1 << i);
            }
        }
        return v;
    }
    int w = lca(u, v);
    if (dep[u] - dep[w] >= len) {
        int del = len;
        for (int i = 20; ~i; i--) {
            if ((1 << i) <= del) {
                u = fa[u][i];
                del -= (1 << i);
            }
        }
        return u;
    } else {
        int del = (dep[v] - dep[w]) - (len - (dep[u] - dep[w]));
        for (int i = 20; ~i; i--) {
            if ((1 << i) <= del) {
                v = fa[v][i];
                del -= (1 << i);
            }
        }
        return v;
    }
}
pair<int, int> h[maxn];
void Out(int k) {
    int u = a[ans[k]], v = b[ans[k]], w = c[ans[k]];
    int la = qry[k].a, lb = qry[k].b, lc = qry[k].c;
    u = Cut(ans[k], u, la);
    v = Cut(ans[k], v, lb);
    w = Cut(ans[k], w, lc);
    while (la + lb != x[k] && la + lc != y[k] && lb + lc != z[k]) {
        swap(la, lb);
        swap(u, v);
        swap(lb, lc);
        swap(v, w);
    }
    if (la + lb == x[k] && la + lc != y[k] && lb + lc != z[k]) {
        swap(la, lb);
        swap(u, v);
    }
    if (la + lb != x[k] && la + lc == y[k] && lb + lc != z[k]) {
        swap(la, lc);
        swap(u, w);
    }
    if (la + lb != x[k] && la + lc != y[k] && lb + lc == z[k]) {
        swap(lb, lc);
        swap(v, w);
    }
    write(u, ' '), write(v, ' '), write(w, '\n');
}
int main() {
    // freopen("game.in", "r", stdin);
    // freopen("game.out", "w", stdout);
    n = read();
    for (int i = 1; i < n; i++) {
        int u = read(), v = read();
        G[u].epb(v), G[v].epb(u);
    }
    dfs(n, n);
    dfs2(n, n);
    q = read();
    for (int i = 1; i <= q; i++) {
        int u = read(), v = read(), w = read();
        x[i] = u, y[i] = v, z[i] = w;
        in[0] = (u + v - w) / 2;
        in[1] = (u + w - v) / 2;
        in[2] = (v + w - u) / 2;
        sort(in, in + 3, greater<int>());
        qry[i] = Node(in[0], in[1], in[2], i);
        seq[++top] = Node(in[0], in[1], in[2], -i);
    }
    for (int i = 1; i <= n; i++) {
        a[i] = to[i].v[0], b[i] = to[i].v[1], c[i] = to[i].v[2];
        seq[++top] = Node(to[i].len[0], to[i].len[1], to[i].len[2], i);
    }
    sort(seq + 1, seq + top + 1, cmp);
    cdq(1, top);
    for (int i = 1; i <= q; i++) Out(i);
}

```

---


# [湖北省选模拟 2024] 花神诞日 / sabzeruz

## 题目背景

传说，之所以这个日子会叫做「花神诞日」，其实最早是「花神祝诞」的意思。

在很久很久以前，有一次树王大人过生日，她的朋友们举办了宴席为她祝寿。

宴席上，几位神明大人都喝醉了，其中一位便乘兴弹奏起了乐器，于是树王大人唱歌，花神大人就跳起舞来。

在花神大人起舞时，她踏过的草地上，长出了无数美丽的帕蒂沙兰……

啊，若是时间能永驻此刻就好了。

## 题目描述

你正在为花神诞日准备宴席。你一共有 $N$ 种食材，依次编号为 $1,2,\cdots, N$，第 $i$ 种食材的味道为 $a_i$，任意两种食材的味道都不相同。你希望用这 $N$ 种食材做两道菜，每种食材必须被在**恰好**一道菜中使用。每道菜至少使用一种食材。

同一道菜中不同食材的味道会**两两发生反应**。食材 $i$ 与食材 $j$ 反应，将产生 $a_i \oplus a_j$ 的味道，其中 $\oplus$ 表示异或运算。一道菜最终的味道为**两两反应产生的味道的最小值**。例如，一道菜使用了味道分别为 $2,3,4$ 的三种食材，食材将会两两反应产生 $1(2 \oplus 3)$，$6(2\oplus 4)$，$7(3\oplus 4)$ 三种味道，这道菜的味道为 $\min(1,6,7)=1$。

本真的味道最为美味。**如果一道菜只使用了一种食材，这道菜的味道为 $+\infty$。**

你希望第一道菜的味道不低于 $k_1$，第二道菜的味道不低于 $k_2$。请问，你一共有多少种做菜的方案？

**请注意：相同集合的食材，分别作为第一道菜与第二道菜是两种不同的方案。** 例如，第一道菜使用食材 $1,2,3$，第二道菜使用食材 $4,5$，与第一道菜使用食材 $4,5$，第二道菜使用食材 $1,2,3$ 是两种不同的方案。

由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的值。

## 说明/提示

### 样例解释 2

做菜的五种方式列举如下：

- 第一道菜使用食材 $1,2,3$，第二道菜使用食材 $4$。
- 第一道菜使用食材 $1,2$，第二道菜使用食材 $3,4$。
- 第一道菜使用食材 $1,3$，第二道菜使用食材 $2,4$。
- 第一道菜使用食材 $2,3,4$，第二道菜使用食材 $1$。
- 第一道菜使用食材 $3,4$，第二道菜使用食材 $1,2$。

### 子任务

对于所有测试数据，保证 $1 \le N \le 2\times 10^5$，$1 \le k_1,k_2,a_i <2^{60}$。对于任意的 $1 \le i<j \le N$，有 $a_i \neq a_j$。

| 测试点编号 | $N\le$ | 特殊性质 |
| :--:|:--:|:--:|
| $1$ | $18$ | 无 |
| $2\sim 3$ | $5\times 10^3$ | A |
| $4\sim 8$ | $5\times 10^3$ | 无 |
| $9\sim 11$ | $2\times 10^5$ | A |
| $12\sim 15$ | $2\times 10^5$ | B |
| $16\sim 25$ | $2\times 10^5$ | 无 |

特殊性质 A：保证 $k_1=k_2$。

特殊性质 B：保证 $k_1=1$。

## 样例 #1

### 输入

```
2 10 10
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
4 2 5
5 3 1 4```

### 输出

```
5```

## 样例 #3

### 输入

```
见选手目录下的 sabzeruz/sabzeruz3.in 与 sabzeruz/sabzeruz3.ans。```

### 输出

```
该样例符合测试点 9 ∼ 11 的限制。```

## 样例 #4

### 输入

```
见选手目录下的 sabzeruz/sabzeruz4.in 与 sabzeruz/sabzeruz4.ans。```

### 输出

```
该样例符合测试点 12 ∼ 15 的限制。```

## 样例 #5

### 输入

```
见选手目录下的 sabzeruz/sabzeruz5.in 与 sabzeruz/sabzeruz5.ans。```

### 输出

```
```

# 题解

## 作者：honglan0301 (赞：15)

提供一个巨大麻烦 nt 做法。

## 题意

计数把大小为 $n$ 的序列 $a_i$ 划分成两个子序列 $a_{1,i},a_{2,i}$ 的方案数，使得 $\forall i\neq j,a_{1,i}\oplus a_{1,j}\geq k_1$ 且 $\forall i\neq j , a_{1,i}\oplus a_{1,j}\geq k_2$。
 
## 题目分析

不妨设 $k_1<k_2$。

------------

- Part 1：$k_1=k_2$ 时。

容易想到建图。把满足 $a_i\oplus a_j<k_1$ 的 $i,j$ 连边，如果连出来的不是二分图，那么一定无解，否则合法方案相当于对二分图染色，方案数就是 $2^{cntk}$，其中 $cntk$ 表示连通块数量，时间复杂度 $O(n^2)$。

考虑优化找二分图的过程。求出该完全图的【最小异或生成树】，那么较严的限制都在树边上，在树上连边染色即可。

找【最小异或生成树】是 CF888G，可以用该题题解方法做到 $O(n\log n\log V)$。

------------

- Part 2：$k_1=1$ 时。

此时第一个子序列没有限制。

同样容易想到建图。把满足 $a_i\oplus a_j<k_2$ 的 $i,j$ 连边，连完之后是一般图独立集计数，时间复杂度是指数级。

考虑优化这个图的形态，我们对满足 $a_i\oplus a_j<2^{\lfloor\log_2 k_2\rfloor+1}$ 的 $i,j$ 连边，这样连完之后图的形态显然是若干个团，对每个团分别考虑即可。

在一个团中，选零个数或一个数显然合法，选 $\geq 3$ 个数显然不合法（$a_i\oplus a_j\geq k_2$，$a_j\oplus a_k\geq k_2$ 意味着 $a_i\oplus a_k\leq 2^{\lfloor\log_2 k_2\rfloor}<k_2$）。选两个数则需要满足 $a_i\oplus a_j\geq k_2$，满足条件数对计数可以用字典树，找团依然用 【最小异或生成树】，时间复杂度 $O(n\log V+n\log n\log V)$。

------------

- Part 3：没有特殊性质时。

考虑把以上两个做法拼起来，建出 $<k_1$ 的二分图和 $<2^{\lfloor\log_2 k_2\rfloor+1}$ 的团。

容易发现二分图每个连通块都包含在一个团内，那么对每个团分讨即可。

1. 若该团内不存在 $size>2$ 的二分图连通块：那么就是 Part 2。

2. 若该团内存在超过三个 $size>2$ 的二分图连通块：那么显然不合法，因为团里必须有 $\geq 3$ 个数都在第二个序列中，与 Part 2 中得到的结论矛盾。

3. 否则暴力枚举每个 $size>2$ 的二分图连通块的染色方式，然后对 $O(1)$ 种染色方式分别判断每个孤立点是否能选即可。

总时间复杂度 $O(n\log n\log V)$，瓶颈在于找二分图（最小异或生成树）。码量较大，被薄纱了。

------------

## 代码

注意需要特判某个序列为空的情况（题目规定这种划分方式不合法）。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <queue>
#include <map>
#include <unordered_map>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <cmath>
#include <random>
#include <set>
#include <bitset>
#include <assert.h>
using namespace std;

//快读快写。

#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define int long long
#define ull unsigned long long
#define mod 1000000007
mt19937 rnd(time(0));
mt19937_64 rndl(time(0));
#define N 200005
int num,p,ch[N<<6][2],l[N<<6],r[N<<6],n,b[N];
int head[N],ver[N],nxt[N],c[N],tot,id;
struct node{
	int x,id;
	bool operator<(const node b)const {
		return x<b.x;
	}
}a[N];
int mu[N],mv[N],cntb;
void ad(int u,int v){
	nxt[++tot]=head[u],ver[head[u]=tot]=v;
}
void add(int u,int v){
	//cout<<u<<" "<<v<<endl;
	cntb++; mu[cntb]=u; mv[cntb]=v;
	ad(u,v);ad(v,u);
}
void insert(int x,int p,int id,int dep){
	if(dep==-1)return ;
	int s=(x>>dep)&1;
	if(ch[p][s])r[ch[p][s]]=id;
	else ch[p][s]=++num,l[num]=r[num]=id;
	insert(x,ch[p][s],id,dep-1);
}
int query(int x,int p,int dep){
	if(dep==-1){
		id=l[p];return 0;
	}
	int s=(x>>dep)&1;
	if(ch[p][s])return query(x,ch[p][s],dep-1);
	return query(x,ch[p][s^1],dep-1)+(1ll<<dep);
}
void solve(int p,int dep){
	if(!p||dep==-1)return ;
	int x=ch[p][0],y=ch[p][1];
	if(x&&y){
		if(r[x]-l[x]+1>r[y]-l[y]+1)swap(x,y);
		int ans=(1ll<<62),u=-1,v=-1;
		for(int i=l[x];i<=r[x];i++){
			int k=query(a[i].x,y,dep-1);
			if(ans>k)ans=k,u=i,v=id;
		}
		add(a[u].id,a[v].id);
	}
	solve(x,dep-1);solve(y,dep-1);
}
void dfs(int u,int now){
	c[u]=now;
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];if(c[v]!=-1)continue;
		dfs(v,now^1);
	}
}

int k1,k2,ans=1;

int ck(int x)
{
	vector <int> na,nb;
	for(int i=1;i<=n;i++) if(c[i]==0) na.pb(b[i]); else nb.pb(b[i]);
	for(int i=1;i<na.size();i++) if((na[i]^na[i-1])<x) return 0;
	for(int i=1;i<nb.size();i++) if((nb[i]^nb[i-1])<x) return 0;
	return 1;
}

int fa[200005],vis[200005],cntk;
vector <int> dn1[200005],e[200005];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void solve1()
{
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=cntb;i++) if((b[mu[i]]^b[mv[i]])<k1) fa[getfa(mu[i])]=getfa(mv[i]);
	for(int i=1;i<=n;i++) if(!vis[getfa(i)]) cntk++,vis[getfa(i)]=1;
	for(int i=1;i<=cntk;i++) ans=ans*2%mod;
}
int fa2[200005],vis2[200005];
int getfa2(int x) {return fa2[x]==x?x:fa2[x]=getfa2(fa2[x]);}
vector <int> dn2[200005];

const int maxn = 200005;
struct Tri
{
    int ch[maxn<<6][2];
    int sz[maxn<<6];
    int tot;
    void init()
    {
    	for(int i=0;i<=tot;i++) ch[i][0]=ch[i][1]=sz[i]=0; 
		tot=2;
    }
    void insert(int x)
    {
    	//cout<<"G "<<x<<endl;
        int u=1;sz[u]++;
        for(int i=60;i>=0;i--)
        {
            int p = (x>>i)&1;
            if(!ch[u][p])ch[u][p]=tot++;
            u=ch[u][p]; sz[u]++;
        }
    }
    int get(int x,int y)
    {
        int u=1;
        long long ans = 0;
        for(int i=60;i>=0;i--)
        {
            int p = (x>>i)&1^1;
            int q = (y>>i)&1;
            if(q==0)ans+=sz[ch[u][p]],u=ch[u][p^1];
            else u=ch[u][p];
            if(u==1) return ans;
        }
        return ans+sz[u];
    }
}T;

void dfs1(int x,int op)
{
	c[x]=op;
//	cout<<"PP "<<x<<" "<<c[x]<<endl;
	for(auto i:e[x])
	{
		if(c[i]!=-1) continue; dfs1(i,op^1);
	}
}

int calc2(int x)
{
	if(!dn2[x].size()) return 1;
	int na=dn2[x].size()+1;
	T.init();
	for(auto i:dn2[x])
	{
		na+=T.get(b[i],k2); T.insert(b[i]);
	}
	return na%mod;
}
void solve2()
{
	int lim=1; while(lim<k2) lim*=2;
	for(int i=1;i<=n;i++) fa2[i]=i;
	for(int i=1;i<=cntb;i++) if((b[mu[i]]^b[mv[i]])<lim) fa2[getfa2(mu[i])]=getfa2(mv[i]);
	for(int i=1;i<=n;i++) dn2[getfa2(i)].pb(i);
	for(int i=1;i<=n;i++) ans=ans*calc2(i)%mod;
}
int calc6(int x,int q1)
{
	int nu=0,nv=0;
	//cout<<"G "<<x<<" "<<q1<<endl;
	for(auto i:dn1[q1])
	{
	//	cout<<i<<" "<<c[i]<<endl;
		if(c[i]!=0) continue;
		if(!nu) nu=i;
		else if(!nv) nv=i;
		else return 0;	
	}
	if(nu&&nv) return (b[nu]^b[nv])>=k2?1:0;
	if(nu)
	{
		int na=1;
		for(auto j:dn2[x])
		{
			if(getfa(j)==getfa(nu)) continue;
			if((b[j]^b[nu])>=k2) na++;
		}
		return na;
	}
	//cout<<dn1[q1].size()<<" "<<nu<<" "<<nv<<endl;
	exit(4);
}
int calc4(int x,int q1)
{
	//return 1;
	int na=0;
	for(auto i:dn1[q1]) c[i]=-1;
	dfs1(q1,0);
	na+=calc6(x,q1);
	for(auto i:dn1[q1]) c[i]=-1;
	dfs1(q1,1);
	na+=calc6(x,q1);
	return na;
}
int calc7(int x,int q1,int q2)
{
	int nu=0,nv=0;
	for(auto i:dn1[q1])
	{
		if(c[i]!=0) continue;
		if(!nu) nu=i;
		else if(!nv) nv=i;
		else return 0;	
	}
	for(auto i:dn1[q2])
	{
		if(c[i]!=0) continue;
		if(!nu) nu=i;
		else if(!nv) nv=i;
		else return 0;	
	}
	if(nu&&nv) return (b[nu]^b[nv])>=k2?1:0;
	exit(3);
}
int calc5(int x,int q1,int q2)
{
	int na=0;
	for(auto i:dn1[q1]) c[i]=-1; for(auto i:dn1[q2]) c[i]=-1;
	dfs1(q1,0); dfs1(q2,0);
	na+=calc7(x,q1,q2);
	for(auto i:dn1[q1]) c[i]=-1; for(auto i:dn1[q2]) c[i]=-1;
	dfs1(q1,0); dfs1(q2,1);
	na+=calc7(x,q1,q2);
	for(auto i:dn1[q1]) c[i]=-1; for(auto i:dn1[q2]) c[i]=-1;
	dfs1(q1,1); dfs1(q2,0);
	na+=calc7(x,q1,q2);
	for(auto i:dn1[q1]) c[i]=-1; for(auto i:dn1[q2]) c[i]=-1;
	dfs1(q1,1); dfs1(q2,1);
	na+=calc7(x,q1,q2);
	return na;
}
int calc3(int x)
{
	int lt1=0,lt2=0;
	for(auto i:dn2[x])
	{
		if(dn1[getfa(i)].size()<=1) continue;
		if(!lt1) lt1=getfa(i);
		else if(lt1==getfa(i)) continue;
		else if(!lt2) lt2=getfa(i);
		else if(lt2==getfa(i)) continue;
		else return 0;
	}
	if(!lt1&&!lt2) return calc2(x);
	else if(lt1) return calc4(x,lt1);
	else if(lt1&&lt2) return calc5(x,lt1,lt2);
	else exit(2);
}
void solve3() 
{
	for(int i=1;i<=cntb;i++) if((b[mu[i]]^b[mv[i]])<k1) e[mu[i]].pb(mv[i]),e[mv[i]].pb(mu[i]);
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=cntb;i++) if((b[mu[i]]^b[mv[i]])<k1) fa[getfa(mu[i])]=getfa(mv[i]);
	for(int i=1;i<=n;i++) dn1[getfa(i)].pb(i);
	int lim=1; while(lim<k2) lim*=2;
	for(int i=1;i<=n;i++) fa2[i]=i;
	for(int i=1;i<=cntb;i++) if((b[mu[i]]^b[mv[i]])<lim) fa2[getfa2(mu[i])]=getfa2(mv[i]);
	for(int i=1;i<=n;i++) dn2[getfa2(i)].pb(i);
	for(int i=1;i<=n;i++) ans=ans*calc3(i)%mod;
}

int calc2()
{
	int nmn=(1ll<<62);
	for(int i=2;i<=n;i++) nmn=min(nmn,a[i].x^a[i-1].x);
	return (nmn>=k1)+(nmn>=k2);
}

signed main()
{
	freopen("sabzeruz.in","r",stdin);
	freopen("sabzeruz.out","w",stdout);
	cin>>n>>k1>>k2; num=1;for(int i=1;i<=n;i++)cin>>a[i].x,b[i]=a[i].x,a[i].id=i;
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)insert(a[i].x,1,i,60),c[i]=-1;
	solve(1,60);dfs(1,0);
	if(k1>k2) swap(k1,k2); if(!ck(k1)) {cout<<"0"<<endl; return 0;}
	if(k1==k2) solve1(); else if(k1==1) solve2(); else solve3();
	ans-=calc2(); ans=(ans+mod)%mod;
	cout<<ans<<endl;
}
```

---

## 作者：览遍千秋 (赞：14)

本题解为官方题解。

---

首先，证明一个结论：对于任意的 $a < b < c$。都有 $a \oplus c > \min(a \oplus b , b \oplus c)$。
		
证明：假设 $a$ 与 $c$ 二进制表示中 $a$ 与 $c$ 不一样的最高位为第 $i$ 位，由 $a < c$ 可知 $a$ 这一位为 $0$，$c$ 这一位为 $1$。由 $a < b < c$ 可知 $b$ 在高于第 $i$ 位的每一个二进制位一定与 $a$ 和 $c$ 一样。若 $b$ 的第 $i$ 为为 $0$，则 $a$ 与 $b$ 二进制表示不一样的最高位低于第 $i$ 位，即 $a \oplus b < a\oplus c$。同理，如果 $b$ 的第 $i$ 位为 $1$，那么则有 $b \oplus c < a\oplus c$。将两种情况总结即可得到 $a \oplus c > \min(a \oplus b , b \oplus c)$。
		
根据上面的结论即可得到，一个集合中任意两个正整数的异或的最小值一定出现在集合中大小关系上相邻的两个数之间。
	

于是，将集合 $S$ 中所有元素从小到大排序得到数组 $a$，此问题则等价于将数组 $a$ 划分为两个非空子序列 $b_1 , b_2$，使得 $b_1$ 中任意两个相邻元素的异或大于等于 $k_1$，且 $b_2$ 中任意两个相邻元素的异或大于等于 $k_2$ 的方案数。
		
考虑使用动态规划解决此问题：将数组 $a$ 中每个正整数从前向后依次添加到数组 $b_1$ 或数组 $b_2$ 中。设 $dp_{i,j}$ 表示子序列 $b_1$ 末尾元素为 $a_i$，且子序列 $b_2$ 末尾元素为 $a_j$ 时的方案数。当添加一个数组 $a$ 中的元素到数组 $b_1$ 或 $b_2$ 中时，枚举所有的 $(i,j)$ 并判断是否满足异或限制的条件进行转移。这样即可得到一个 $O(n^3)$ 的动态规划做法，但无法通过此题。
	
考虑优化上述动态规划做法：由于插入数组 $a$ 中第 $i$ $(i > 1)$个正整数时，两个子序列 $b_1 , b_2$ 中一定刚好有一个子序列末尾为 $a_{i-1}$。于是可以用一个 $0/1$ 变量记录 $b_1 , b_2$ 中哪个子序列末尾为第 $i-1$ 个元素，并记录另一个子序列末尾的位置，将时间复杂度优化到 $O(n^2)$。但仍然无法通过此题。
		
继续优化上述做法：对于数组 $b_1$ 的末尾为数组 $a$ 第 $i-1$ 个数的情况，将数组 $b_2$ 末尾所有可能的数和对应的方案数插入到一个字典树中。对于数组 $b_2$ 的末尾为数组 $a$ 第 $i-1$ 个数的情况，将数组 $b_1$ 末尾所有可能的数和对应的方案数插入到另一个字典树中。将数组 $a_i$ 个数插入到 $b_1 , b_2$ 中的一个数组时，讨论 $a_{i-1}$ 此时的位置在 $b_1 . b_2$ 哪个数组的末尾，分四种情况讨论转移。单次转移即为查询字典树中所有与 $a_i$ 异或不超过 $k_1$ 或 $k_2$ 的数的总数。单次查询可以在 $O(\log(\max(a)))$ 时间内做到。
		
总时间复杂度和空间复杂度均为 $O(n \cdot \log(\max(a)))$。


---

## 作者：luanmenglei (赞：8)

分享一下考场上的笨比分讨做法。

首先不妨设 $k_1 \ge k_2$，同时规定 trie 树上的根深度为 $59$，叶子深度为 $-1$。

同时为了方便计算，我们将空集也算入合法答案，在最后再减去。

首先把所有数插入到 trie 树上，注意到在深度为 $\operatorname{highbit}(k_1)$ 的点的子树内 $k_1$ 最多选择一个点进入 $S_1$ 集合。

所以这启发我们对 $\operatorname{highbit}(k_1)$ 与 $\operatorname{highbit}(k_2)$ 的关系进行讨论。

1.  当 $\operatorname{highbit}(k_1) = \operatorname{highbit}(k_2)$ 时。

注意到此时深度为 $\operatorname{highbit}(k_1)$ 的子树大小最多为 $4$，否则答案一定为 $0$，那么我们直接暴力即可。

2. 当 $\operatorname{highbit}(k_1) \not = \operatorname{highbit}(k_2)$ 时。

记当前考虑的深度为 $\operatorname{highbit}(k_1)$ 的点为 $x$。

我们发现 $x$ 的两个子树之间的选择对于 $S_2$ 是独立的，因为 $\operatorname{highbit}(k_1) > \operatorname{highbit}(k_2)$，所以说之间的最小异或值一定不小于 $k_2$。

那么问题就变成了两个子树中都有一些点使得选出他之后剩下的点不冲突（$xor \ge k_2$），然后我们要在两个点集中分别选出最多一个点，使得他们之间的 $xor \ge k_1$。

如果我们求出了点集，那么后面那个东西是简单的。

求出点集则需要进一步讨论。

还是一样的办法，找到深度为 $\operatorname{highbit}(k_2)$ 的点，记他为 $u$。

如果 $u$ 的一个儿子大小 $\ge 2$ 一定答案为 $0$。

如果 $u$ 一个儿子大小为 $2$ 则我们有必选限制，既两个点 $S_1$ 中一定选一个。

那么现在没有必选限制，那么子树大小一定 $=2$。

然后如果左右子树异或 $\le k_2$，一定要选走一个数，这也是一个必选限制。

显然如果有多个必选限制答案一定为 $0$。

然后就做完了。

时间复杂度 $\mathcal{O}(n \log n)$。

[代码（很丑，仅供参考）](https://www.luogu.com.cn/paste/woecx4me)

---

## 作者：Purslane (赞：5)

# Solution

楼下小朋友太没有素质了，干扰我想题目。

大概在若干年前我还打 ABC 的时候见到了这么一个结论：$\min\{a \oplus b,b \oplus c\} \le a \oplus c$。枚举 $a$ 和 $c$ 第一个不同的位很容易证明。所以这道题只需要保证两个集合分别排序之后，相邻两个数的异或和满足要求即可。

那么考虑把所有数从小到大排序，依次枚举每一个数分别在哪个集合之中。

设 $f_{u,v}$ 为当前枚举到了第 $u$ 个数且第 $u$ 个数被放到了第一个集合之中，上一个被放入另一个集合的数的下标为 $v$ 的方案数。$g_{u,v}$ 对称定义。

考虑在 $f_{u,v}$ 的基础上加入 $a_{u+1}$。如果 $a_u \oplus a_{u+1} \ge k_1$，那么 $u+1$ 就可以放入第一个集合。如果 $a_v \oplus a_{u+1} \ge k_2$，那么 $u+1$ 就可以放入第二个集合。前者转移到 $f_{u+1,v}$，后者转移到 $g_{u+1,u}$。

那么其实很明确了：如果 $a_u \oplus a_{u+1} \ge k_1$，我们就给第一个数组全体保留原样放到 $f_{u+1,v}$ 中；然后找到所有满足 $a_v \oplus a_{u+1} \ge k_2$ 的 $v$ 并对 $f_{u,v}$ 求和加入 $g_{u+1,u}$。得到了 $O(n^2)$ 的算法，简单粗暴。

发现需要优化的其实是第二部分。考虑 Trie 树其实很容易统计这个东西。那么就在 Trie 树上完成动态加点和子树求和即可。（特别地，当 $a_u \oplus a_{u+1} < k_1$ 时，直接把这棵树删了。从势能分析的角度来看，复杂度正确且合理。）

特别地，每次要特判当前加入的数是这个集合第一个放入的数的情况。不是很能理解为什么满足了所有数互不相等。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10,MOD=1e9+7;
int n;ll a[MAXN],k1,k2;
namespace DS {
	int tot; queue<int> bin;
	struct Node {int s[2],sum;}t[MAXN*120];
	int get_node(void) {
		int ans;
		if(!bin.empty()) ans=bin.front(),bin.pop(); 
		else ans=++tot;
		return t[ans]={0,0,0},ans;
	}
	void insert(ll id,int val,int rt) {
		if(!val) return ;int u=rt;
		roff(i,59,0) {
			int op=!!(id&(1ll<<i));
			if(!t[u].s[op]) t[u].s[op]=get_node();
			t[u].sum=(t[u].sum+val)%MOD,u=t[u].s[op];
		}
		t[u].sum=(t[u].sum+val)%MOD;
		return ;
	}
	int calc_sum(ll id,ll u,int rt) { //求所有和 id 异或起来大于等于 u 的位置的和 
		int ans=0,v=rt;
		roff(i,59,0) {
			int _u=!!(u&(1ll<<i)),_id=!!(id&(1ll<<i));
			if(_u==0) ans=(ans+t[t[v].s[_id^1]].sum)%MOD;
			if(t[v].s[_id^_u]) v=t[v].s[_id^_u];
			else return ans;
		}
		ans=(ans+t[v].sum)%MOD;
		return ans;
	}
	void del(int u) {
		if(t[u].s[0]) bin.push(t[u].s[0]),del(t[u].s[0]);
		if(t[u].s[1]) bin.push(t[u].s[1]),del(t[u].s[1]);
		return t[u]={0,0,0},void();
	}
};
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k1>>k2; ffor(i,1,n) cin>>a[i];
	sort(a+1,a+n+1);
	ll tmp=LONG_LONG_MAX;int rt1=DS::get_node(),rt2=DS::get_node();
	ffor(i,2,n) {
		int _g=DS::calc_sum(a[i],k2,rt1),_f=DS::calc_sum(a[i],k1,rt2);
		if(tmp>=k1) _g=(_g+1)%MOD;
		if(tmp>=k2) _f=(_f+1)%MOD;
		if((a[i-1]^a[i])<k1) DS::del(rt1);
		if((a[i-1]^a[i])<k2) DS::del(rt2);
		DS::insert(a[i-1],_f,rt1),DS::insert(a[i-1],_g,rt2);
		tmp=min(tmp,a[i]^a[i-1]);
	}
	int ans=(DS::t[rt1].sum+DS::t[rt2].sum)%MOD;
	cout<<ans;
	return 0;
}
//還記得你說家是唯一的城堡 隨著稻香河流依舊奔跑 微微笑 小時候的夢我知道
```

AHOI 2024 RP++！

---

## 作者：ZhongYuLin (赞：4)

回旋镖正中眉心，笔者因为没写这道题导致没写出来 CSP-S2024 T3。这篇文章讲下动态规划的设计。

发现将 $a$ 排序后，我们要将其划分为两个子序列 $X,Y$，要求邻项的异或和要满足要求。设 $f_i$ 表示第 $i$ 项属于 $X$，且 $i-1$ 属于 $Y$，类似地设 $g_i$ 表示第 $i$ 项属于 $Y$，且 $i-1$ 属于 $X$。怎么转移呢？以 $f_i$ 为例，枚举 $j<i$，钦定 $[j,i-1]$ 都属于 $Y$，此时要求这个区间内邻项异或和都不小于 $k_2$。然后检查 $a_{j-1}\operatorname{xor}a_i$ 是否不小于 $k_1$，转移即可。形式化地讲：

$$\sum_{j=1}^{i-1}[\forall k\in[j+1,i-1],a_k\operatorname{xor}a_{k-1}\ge k_2][a_{j-1}\operatorname{xor} a_i \ge k_1\vee j=1]g_j$$

使用 trie 维护转移即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int P=1e9+7;
const int N=2e5+3;
void add(int &x,int y){if((x+=y)>=P)x-=P;}
int n,cnt;
ll k1,k2;
ll a[N];
int t[N*120][2],sum[N*120];
void ins(int p,ll x,int k){
    for(int i=60;~i;--i){
        bool c=x>>i&1;
        if(!t[p][c])t[p][c]=++cnt;
        add(sum[p=t[p][c]],k);
    }
}
int ask(int p,ll x,ll k){
    int ans=0;
    for(int i=60;~i&&p;--i){
        bool c=x>>i&1;
        if(!(k>>i&1)){
            add(ans,sum[t[p][!c]]);
            p=t[p][c];
        }else p=t[p][!c];
    }
    add(ans,sum[p]);
    return ans;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>k1>>k2;
    for(int i=1;i<=n;++i)cin>>a[i];
    sort(a+1,a+1+n);cnt=2;
    for(int i=2,dA=1,dB=1;i<=n;++i){
        int tA=ask(1,a[i],k2)+dA,tB=ask(2,a[i],k1)+dB;
        if((a[i]^a[i-1])<k1)t[1][0]=t[1][1]=0,dA=0;
        if((a[i]^a[i-1])<k2)t[2][0]=t[2][1]=0,dB=0;
        ins(1,a[i-1],tB);ins(2,a[i-1],tA);
    }
    printf("%lld\n",((ll)sum[t[1][0]]+sum[t[1][1]]+sum[t[2][0]]+sum[t[2][1]])%P);
    return 0;
}
```

---

## 作者：D2T1 (赞：4)

## 湖北省选模拟 2024 - 花神诞日 / sabzeruz [省选/NOI-]

显然有 $a\leq b\leq c, a\operatorname{xor} c \geq \min\{a\operatorname{xor} b, b\operatorname{xor} c\}$。所以我们只用排序后从左往右考虑每个数，记录一下每道菜最后一个数是什么即可。

考虑设 $f_{i,j}$ 表示前 $i$ 个数，第 $i$ 个数被第一道菜选，第二道菜最后选的是第 $j$ 个数的方案数；$g_{i,j}$ 表示前 $i$ 个数，第 $i$ 个数被第二道菜选，第一道菜最后选的是第 $j$ 个数的方案数。

有四种转移：

- $[a_{i-1}\operatorname{xor}a_{i}\geq k_1]f_{i-1,j}\to f_{i,j}$；
- $[a_{i-1}\operatorname{xor}a_{i}\geq k_2]g_{i-1,j}\to g_{i,j}$；
- $[a_{j}\operatorname{xor}a_{i}\geq k_2]f_{i-1,j}\to g_{i,i-1}$；
- $[a_{j}\operatorname{xor}a_{i}\geq k_1]g_{i-1,j}\to f_{i,i-1}$；

那么我们使用 trie 树维护 $(x,y)=(a_j,f_{i,j})$ 的二元组，第三种操作实际上相当于对于 $x\operatorname{xor}a_i\geq k_2$ 的 $x$ 求和 $y$；第一种操作实际上相当于什么都不干或者全部置 $0$，可以在 trie 每个节点上维护一个 lazytag。第二、第四个操作同理。

最后，因为题目要求两个集合均非空。那么要减去所有数都归到一个集合的方案。

```cpp
const int N = 2e5 + 10;
const ll P = 1e9 + 7;
ll a[N], k1, k2;
int n, cnt = 2;
struct node{
	int ch[2], tag;
	ll sum;
} t[N*130];

void psd(int p){
	if(t[p].tag){
		if(t[p].ch[0]){
			t[t[p].ch[0]].sum = 0;
			t[t[p].ch[0]].tag = 1;
		}
		if(t[p].ch[1]){
			t[t[p].ch[1]].sum = 0;
			t[t[p].ch[1]].tag = 1;
		}
		t[p].tag = 0;
	}
}
void ins(int p, ll v, ll x){
	for(ll i = 62; i >= 0; -- i){
		psd(p);
		t[p].sum = (t[p].sum + x) % P;
		if(!t[p].ch[(v>>i)&1]){
			t[p].ch[(v>>i)&1] = ++ cnt;
		}
		p = t[p].ch[(v>>i)&1];
	}
	t[p].sum = (t[p].sum + x) % P;
}
ll qry(int p, ll v, ll w){
	ll ans = 0;
	for(ll i = 62; i >= 0; -- i){
		psd(p);
		if((w >> i) & 1){
			if(t[p].ch[!((v>>i)&1)]){
				p = t[p].ch[!((v>>i)&1)];
			} else {
				return ans;
			}
		} else {
			ans += t[t[p].ch[!((v>>i)&1)]].sum;
			if(t[p].ch[(v>>i)&1]){
				p = t[p].ch[(v>>i)&1];
			} else {
				return ans;
			}
		}
	}
	ans = (ans + t[p].sum) % P;
	return ans;
}
void fil(int p){
	t[p].sum = 0;
	t[p].tag = 1;
}

void solve(){
	read(n, k1, k2);
	for(int i = 1; i <= n; ++ i){
		read(a[i]);
	}
	sort(a + 1, a + n + 1);
	ins(1, (1ll<<61), 1);
	ins(2, (1ll<<61), 1);
	for(int i = 2; i <= n; ++ i){
		ll sg = qry(1, a[i], k2);
		ll sf = qry(2, a[i], k1);
		if((a[i-1] ^ a[i]) < k1){
			fil(1);
		}
		if((a[i-1] ^ a[i]) < k2){
			fil(2);
		}
		ins(1, a[i-1], sf);
		ins(2, a[i-1], sg);
	}
	int fa = 1, fb = 1;
	for(int i = 2; i <= n; ++ i){
		if((a[i-1] ^ a[i]) < k1){
			fa = 0;
		}
		if((a[i-1] ^ a[i]) < k2){
			fb = 0;
		}
	}
	println((t[1].sum + t[2].sum - fa - fb + P) % P);
}

```

---

## 作者：zyn_ (赞：2)

## 一个结论

若 $a\gt b\gt c$，则 $a\operatorname{xor}c\gt\min\{a\operatorname{xor}b,b\operatorname{xor}c\}$。下作证明。

设 $a$ 写成二进制为 $\overline{a_na_{n-1}\dots a_1a_0}$，$b,c$ 类似。

如果 $a_n=b_n=c_n,a_{n-1}=b_{n-1}=c_{n-1},\dots,a_k=b_k=c_k$，则去掉 $a,b,c$ 二进制下的前 $n-k+1$ 位不改变 $a\operatorname{xor}c,a\operatorname{xor}b,b\operatorname{xor}c$。因此可以不妨设 $a_n,b_n,c_n$ 不全相同。由 $a\gt b\gt c$ 知 $a_n=1,c_n=0$。

因此当 $b_n=1$ 时 $a\operatorname{xor}b$ 的第 $n$ 位为 $0$，当 $b_n=0$ 时 $b\operatorname{xor}c$ 的第 $n$ 位为 $0$。故 $\min\{a\operatorname{xor}b,b\operatorname{xor}c\}$ 的第 $n$ 位必为 $0$。但 $a\operatorname{xor}c$ 的第 $n$ 位为 $(a_n+c_n)\bmod 2=1$，故 $a\operatorname{xor}c\gt\min\{a\operatorname{xor}b,b\operatorname{xor}c\}$。证毕！

## DP

令 $w(S)=w(\{x_1,x_2,\dots,x_k\})=\displaystyle\min_{1\le i\lt j\le k}\{x_i\operatorname{xor}x_j\}$，其中 $x_1\lt x_2\lt \dots \lt x_k$。（若 $k=1$ 则 $w(S)=+\infty$。）由上述结论知对 $p\lt q\lt r$，$x_p\operatorname{xor}x_r\gt\min\{x_p\operatorname{xor}x_q,x_q\operatorname{xor}x_r\}$。故 $w(S)=\displaystyle\min_{1\le i\lt k}\{x_i\operatorname{xor}x_{i+1}\}$。

现在原题要求将 $\{a_1,a_2,\dots,a_n\}$ 划分为两个集合 $S_0,S_1$，使 $w(S_j)\ge k_j$（$j=0,1$，这里的 $k_0$ 是原题的 $k_1$，这里的 $k_1$ 是原题的 $k_2$），求方案数。

考虑将 $\{a_i\}$ 从小到大排序。设 $dp_{i,p,t}$ 为已经划分了 $a_1,a_2,\dots,a_i$，$a_i$ 被划分到 $S_t$，且上一个被划分到 $S_{1-t}$ 的元素为 $a_p$（若 $p=0$ 意为此前没有元素被划分入 $S_{1-t}$），此时 $w(S_j)\ge k_j$（$j=0,1$）或有一个 $S_j$ 为空集的方案数。

设 $[A]$ 表示若 $A$ 为真其值为 $1$，若 $A$ 为假其值为 $0$。转移方程为：

$$
dp_{i,p,t}=
\begin{cases}
dp_{i-1,p,t}[a_{i-1}\operatorname{xor}a_i\ge k_t],\space p\neq i-1 \\
dp_{i-1,0,1-t}+\sum_{c=1}^{i-2}dp_{i-1,c,1-t}[a_i\operatorname{xor}a_c\ge k_t],\space p=i-1
\end{cases}
$$

初始值为：$dp_{1,0,0}=dp_{1,0,1}=1$。

注意到统计答案时 $S_0,S_1$ 不能为空集，故答案为

$$
\sum_{c=1}^{n-1}\sum_{t=0}^{1}dp_{n,c,t}
$$

这样直接转移就是 $O(n^2)$。

## 优化 DP

$$
dp_{i,p,t}=dp_{i-1,p,t}[a_{i-1}\operatorname{xor}a_i\ge k_t],\space p\neq i-1
$$

因此对于固定的 $p$，所有 $dp_{i,p,t}$（$i\gt p$）应该形如 $x,x,\dots,x,0,0,\dots,0$，其中 $x=dp_{p+1,p,t}$，变为 $0$ 的位置，就是某个 $i_0$ 使 $a_{i_0-1}\operatorname{xor}a_{i_0}\lt k_t$。

现在考虑**滚动数组**，把 $i$ 这一维去掉。遍历 $i=2,\dots,n$，对 $t=0,1$，若发现 $a_{i-1}\operatorname{xor}a_i\lt k_t$，则对 $c=0,\dots,i-2$ 令 $dp_{c,t}\gets 0$。显然每次置零操作只需从上一次置零操作的末尾开始，因此这里就做到了 $O(n)$。

$$
dp_{i,i-1,t}=dp_{i-1,0,1-t}+\sum_{c=1}^{i-2}dp_{i-1,c,1-t}[a_i\operatorname{xor}a_c\ge k_t]
$$

这个转移在滚动数组后变成了求所有 $dp_{c,t}$ 中满足 $a_i\operatorname{xor}a_c\ge k_t$ 的 $c$ 的 $dp_{c,t}$ 之和。这可以用一个 01-trie 维护，单次询问是 $O(\log V)$ 的，$V$ 为值域。

于是整个 DP 的复杂度降为了 $O(n\log V)$。

## Code

代码的实现可能与上述分析略有差异。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200009
#define M 60
#define ll long long
#define mod 1000000007
int n;ll k[2],a[N];
ll dp[N][2],ans;
struct trie{
	int s[N*M+9][2],cnt;ll a[N*M+9];
	void insert(ll f,ll x){
		static int p;static ll k,d;
		p=0;
		for(int i=M-1;i>=0;--i){
			k=(f>>i)&1;
			if(!s[p][k])s[p][k]=++cnt;
			p=s[p][k];
		}
		d=x-a[p];
		p=0;
		for(int i=M-1;i>=0;--i){
			p=s[p][(f>>i)&1];
			a[p]+=d;
		}
	}
	ll qr(ll y,ll f){
		static int p,t;static ll k,ans;
		ans=0;p=0;
		for(int i=M-1;i>=0;--i){
			k=(f>>i)&1;
			if(k==0){
				t=s[p][((y>>i)&1)^1];
				if(t)ans+=a[t],ans%=mod;
				p=s[p][(y>>i)&1];
			}
			else p=s[p][((y>>i)&1)^1];
			if(p==0)break;
		}
		ans+=a[p],ans%=mod;
		return ans;
	}
}tr[2];
int main(){
    //Happy birthday to Nahida!
	scanf("%d%lld%lld",&n,&k[0],&k[1]);
	if(n==1)return puts("0"),0;
	for(int i=1;i<=n;++i)scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	dp[1][0]=dp[1][1]=1;
	static int l[2];l[0]=l[1]=1;
	for(int i=2;i<=n;++i){
		for(int j=0;j<=1;++j)dp[i][j]=(tr[j^1].qr(a[i],k[j])+dp[1][j^1])%mod;
		for(int j=0;j<=1;++j)if((a[i]^a[i-1])<k[j])
			while(l[j]<i){
				dp[l[j]][j]=0;
				if(l[j]>1)tr[j].insert(a[l[j]-1],0);
				++l[j];
			}
		for(int j=0;j<=1;++j)tr[j].insert(a[i-1],dp[i][j]);
	}
	for(int i=2;i<=n;++i)ans=(ans+dp[i][0]+dp[i][1])%mod;
	printf("%lld\n",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：Fzrcy (赞：2)

首先我们证明 $a_{i}\operatorname{xor} a_{k}\ge \min(a_{i}\operatorname{xor}a_{j},a_{j}\operatorname{xor}a_{k})$（$a_{i}<a_{j}<a_{k}$）,我们先将其写为二进制，设 $a_{i},a_{j},a_{k}$ 在第 $x$ 位（$x$ 要最大）存在不同，设其分别为 $A,B,C$，显然 $A\ne C$，然后对 $B$ 分类讨论：

1. 若 $B=A$，显然 $a_{i}\operatorname{xor} a_{k}\ge a_{i}\operatorname{xor}a_{j}$。
2. 若 $B=C$，显然 $a_{i}\operatorname{xor} a_{k}\ge a_{j}\operatorname{xor}a_{k}$。

所以 $a_{i}\operatorname{xor} a_{k}\ge \min(a_{i}\operatorname{xor}a_{j},a_{j}\operatorname{xor}a_{k})$（$a_{i}<a_{j}<a_{k}$）。

然后考虑原问题，先将 $a$ 从小到大排序。设 $F_{i,j,k}$ 表示考虑到第 $i$ 位，第一道菜的末尾是 $j$，第二道菜的末尾是 $k$ 的方案数，大力 `DP` 的复杂度是 $O(n^3)$。

由于 $j,k$ 中一定有一个是 $i$，所以我们设 $F_{i,j,1/2}$ 表示考虑到第 $i$ 位，$i$ 是第 $1/2$ 道菜的末尾，另一道菜的末尾是 $j$ 的方案数，复杂度 $O(n^2)$。

转移方程：
$$
F_{i,j,t}=F_{i,j,t}+F_{i-1,j,t}[a_{i}\operatorname{xor}a_{i-1}\ge k_{t}]
$$

$$
F_{i,i-1,t}=F_{i,i-1,t}+\sum F_{i-1,j,3-t}[a_{j}\operatorname{xor}a_{i}\ge k_{t}]
$$

然后我们可以考虑用字典树维护 $F_{i,j,1/2}$，$O(\log V)$ 求 $\sum F_{i-1,j,3-t}[a_{j}\operatorname{xor}a_{i}\ge k_{t}]$，复杂度是 $O(n\log V)$。

实现时我们可以考虑设 $a_{0}=2^{60}$，最后减去 $F_{n,0,t}$，可以减少初始化的难度。

```cpp
// Fzrcy
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

namespace IO{
    #define gc ((b1==b2)&&(b2=(b1=buf)+fread(buf,1,1<<20,stdin),b1==b2)?EOF:*b1++)

    char buf[1<<20],*b1=buf,*b2=buf;

    inline int in(){
        char c; int x=0; bool ok=0; while(!isdigit(c=gc))if(c=='-')ok=1;
        while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=gc; return ok?-x:x;
    }

    inline LL inLL(){
        char c; LL x=0; bool ok=0; while(!isdigit(c=gc))if(c=='-')ok=1;
        while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=gc; return ok?-x:x;
    }

    inline void wr(int x){
        if(x<0)putchar('-'),x=-x;
        if(x>=10)wr(x/10);
        putchar(x%10+'0');
    }
} using IO::in; using IO::wr; using IO::inLL;

constexpr int N=2e5+9;
constexpr int mod=1e9+7;

inline void Mod(int&x){x=(x<0?x+mod:(x>=mod?x-mod:x));}

int n; LL a[N],k1,k2;

struct Trie{
    int ch[N*63][2],s[N*63],cnt;

    inline void up(int x){
        Mod(s[x]=s[ch[x][0]]+s[ch[x][1]]);
    }

    inline int ask(int u,LL V,LL K,int d){
        if(d<0)return s[u];
        int c=((V^K)>>d)&1,ans=0;
        if((K>>d&1)==0)ans=s[ch[u][c^1]];
        return Mod(ans+=ask(ch[u][c],V,K,d-1)),ans;
    }

    inline void ins(int&u,LL V,int f,int d){
        !u&&(u=++cnt);
        if(d==-1){Mod(s[u]+=f);return;}
        return ins(ch[u][V>>d&1],V,f,d-1),up(u);
    }

    inline int Q(int u,LL v,int d){
        if(d==-1)return s[u];
        return Q(ch[u][v>>d&1],v,d-1);
    }
}Tr[2];

int r1,r2;

int main(){
    //FILE* fin=freopen("a.in","r",stdin);
    n=in(),k1=inLL(),k2=inLL();
    for(int i=1;i<=n;i++)a[i]=inLL();
    sort(a+1,a+n+1),a[0]=1ll<<60;
    Tr[0].ins(r1,a[0],1,60);
    Tr[1].ins(r2,a[0],1,60);
    for(int i=2;i<=n;i++){
        int v1=Tr[0].ask(r1,a[i],k2,60);
        int v2=Tr[1].ask(r2,a[i],k1,60);
        if((a[i]^a[i-1])>=k1);else r1=0;
        if((a[i]^a[i-1])>=k2);else r2=0;
        Tr[0].ins(r1,a[i-1],v2,60);
        Tr[1].ins(r2,a[i-1],v1,60);
    }
    int ans=Tr[0].s[r1]+Tr[1].s[r2];
    Mod(ans);
    Mod(ans-=Tr[0].Q(r1,1ll<<60,60));
    Mod(ans-=Tr[1].Q(r2,1ll<<60,60));
    return wr(ans),0;
}
```

---

## 作者：Otomachi_Una_ (赞：2)

## 花神诞日

> 引理：对于 $a<b<c$，$\min(a\text{ XOR }b,b\text{ XOR }c)\leq a\text{ XOR }c$。
>
> 证明：考虑比较 $a,c$ 二进制下第一位不同，也就是 $a=(X0\dots)_{(2)},c=(X1\dots)_{2}$。因为 $b\in(a,c)$ 所以 $b$ 也有 $X$ 前缀，后一位必然和 $a$ 或者 $c$ 相同。证毕。

原问题我们只需要排序，只需要关注相邻数的异或大小。

考虑 dp，假设 $f_{i,j}$ 表示考虑到 $a[1,\max(i,j)]$，第一道菜最后放置 $i$，第二道最后放置 $j$ 的方案数。直接转移是 $\mathcal O(n^3)$。

你发现 $f_{i,j}$ 当 $i-j\geq 2$ 时只能从 $f_{i-1,j}$ 转移而来，复杂度降至 $\mathcal O(n^2)$。

这样子，我们根据经典技巧压掉一位，对每个 $i$，考虑 $T(i)_j$ 表示 $i$ 放在第一道菜，上一个放到第二道菜的是 $j$ 的方案数。考虑 $T(i)$ 转移到 $T(i+1)$，$S(i)_j$ 表示 $i$ 放第二道菜的方案数。

- 如果 $a_i\text{ XOR }a_{i+1}< k_1$，那么 $T(i)$ 不能转到 $T(i+1)$。
- 否则，$T(i+1)$ 继承 $T(i)$。

最后再考虑 $T(i+1)_i$ 的情况，其会从 $S(i)$ 转移而来，具体的从每个 $a_j\text{ XOR }a_{i+1}\geq k_1$ 的数转移过来。

这部分我们只需要对 $T(i),S(i)$ 维护一颗 trie 树就容易查询了。

---

## 作者：kkxacj (赞：1)

#### 思路

首先有一个 `trick`，若 $a > b > c$ 则 $a \wedge c > \min\left(a \wedge b,b \wedge c\right)$。

将 $a,b,c$ 二进制表示，然后给高位补 $0$，找到第一位使得这三个数当前位二进制不都相同，因为 $a > b > c$，所以 $a$ 的这一位是 $1$，$c$ 的这一位只能是 $0$，若 $b$ 这一位为 $1$ 则 $a \wedge c > a \wedge b$，否则 $a \wedge c > b \wedge c$。

直接将 $a_i$ 按值从小到大排序，如[这题](https://www.luogu.com.cn/article/530il5hx)一样设状态就行了。

设 $k_{0/1}$ 为输入的 $k1,k2$。 $f_{0/1,i,j}$ 表示第 $i$ 个位置颜色为红色或蓝色与其相反的颜色最后一次出现在 $j$ 的最大贡献，很容易想到转移式： 

1. $f_{z,i,j} = f_{z,i-1,j} \times \left[(a_i \wedge a_{i-1}) \ge k_z\right]$。
1. $f_{z,i,i-1} = \max(f_{z,i,i-1},f_{!z,i,j} \times \left[(a_i \wedge a_j) \ge k_z\right]$。

执行前提是 $j < i-1$，**$j$ 要从 $0$ 开始，表示没有不同的**。

发现第二维的 $i$ 可以优化掉，不过优化掉后第二个转移要**先执行**，对于第一个转移，只要 $(a_i \wedge a_{i-1}) < k_z$，那么 $0$ 到 $i-2$ 的值将全部赋为 $0$，写两个指针就行了。

对于第二个操作，建一颗字典树即可。

**坑点：每道菜都必须有至少一种食材，所以不能加 $f_{0/1,0}$ 的贡献**。

代码是记的 $f_{i,0/1}$，无伤大雅。

**code**


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],top,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++top]=48+x%10;while(top) pc(stk[top--]);}
}
using namespace IO;
const int N = 2e5+10,mod = 1e9+7,B = 61;
int n,o,o1,f[N][2],a[N],c[N],d[N],K[2],l[2],ans,cnt = 1,cnt1,cnt2,sum[N*B*2][2],b[N*B*2][2];
inline void insert(int x,int y,int z,int z1)
{
	sum[y][0] = (sum[y][0]+z+mod)%mod,sum[y][1] = (sum[y][1]+z1+mod)%mod;
	if(x > B) return;
	if(!b[y][c[x]]) b[y][c[x]] = ++cnt;
//	cout<<cnt<<endl;
	insert(x+1,b[y][c[x]],z,z1);
}
inline void check(int x,int y)
{
//	cout<<x<<" @"<<endl;
	if(x > B || y == 0) return;
	if(c[x] == 0 && d[x] == 0) check(x+1,b[y][0]);
	else if(c[x] == 1 && d[x] == 1) check(x+1,b[y][0]);
	else if(c[x] == 0 && d[x] == 1) check(x+1,b[y][1]);
	else if(c[x] == 1 && d[x] == 0) check(x+1,b[y][1]);
	if(x == B)
	{
		if(c[x] == 0 && d[x] == 0) f[o][o1] = (f[o][o1]+sum[b[y][0]][!o1])%mod;
		else if(c[x] == 1 && d[x] == 1) f[o][o1] = (f[o][o1]+sum[b[y][0]][!o1])%mod;
		else if(c[x] == 1 && d[x] == 0) f[o][o1] = (f[o][o1]+sum[b[y][1]][!o1])%mod;
		else if(c[x] == 0 && d[x] == 1) f[o][o1] = (f[o][o1]+sum[b[y][1]][!o1])%mod;
	}
	if(d[x] == 0)
	{
	//	cout<<o<<' '<<o1<<" "<<x<<" % "<<y<<" "<<c[x]<<" "<<sum[b[y][0]][!o1]<<" "<<sum[b[y][1]][!o1]<<endl; 
		if(c[x] == 1) f[o][o1] = (f[o][o1]+sum[b[y][0]][!o1])%mod;
		else f[o][o1] = (f[o][o1]+sum[b[y][1]][!o1])%mod;
	}
}
signed main()
{
//	freopen("sabzeruz3.in","r",stdin);
//	freopen("sabzeruz3.out","w",stdout);
	read(n),read(K[0]),read(K[1]); a[0] = (1ll<<60);
	for(int i = 1;i <= n;i++) read(a[i]);
	sort(a+1,a+1+n); f[0][0] = f[0][1] = 1;
	o = a[0],cnt1 = 0; while(o) c[++cnt1] = o%2,o /= 2;
	while(cnt1 < B) c[++cnt1] = 0; for(int s = 1;s <= B/2;s++) swap(c[s],c[B-s+1]);
	o = 0,insert(1,1,f[0][0],f[0][1]); 
	for(int i = 2;i <= n;i++)
	{
		for(int z = 0;z <= 1;z++) 
		{
			o = a[i],cnt1 = 0; while(o) c[++cnt1] = o%2,o /= 2;
			while(cnt1 < B) c[++cnt1] = 0; for(int s = 1;s <= B/2;s++) swap(c[s],c[B-s+1]);
			o = K[z],cnt1 = 0; while(o) d[++cnt1] = o%2,o /= 2;
			while(cnt1 < B) d[++cnt1] = 0; for(int s = 1;s <= B/2;s++) swap(d[s],d[B-s+1]);
			o = i-1,o1 = z,check(1,1);
		}
		o = a[i-1],cnt1 = 0; while(o) c[++cnt1] = o%2,o /= 2;
		while(cnt1 < B) c[++cnt1] = 0; for(int s = 1;s <= B/2;s++) swap(c[s],c[B-s+1]);
		insert(1,1,f[i-1][0],f[i-1][1]);
		for(int z = 0;z <= 1;z++)
		if((a[i]^a[i-1]) < K[z])
			while(l[z] <= i-2) 
			{
				o = a[l[z]],cnt1 = 0; while(o) c[++cnt1] = o%2,o /= 2;
				while(cnt1 < B) c[++cnt1] = 0; for(int s = 1;s <= B/2;s++) swap(c[s],c[B-s+1]);
				insert(1,1,-f[l[z]][0]*(z==0),-f[l[z]][1]*(z==1));
				l[z]++;
			}
	}
	for(int z = 0;z <= 1;z++)
		for(int i = max(1ll,l[z]);i < n;i++) 
			ans = (ans+f[i][z])%mod;
	print(ans); flush();  
	return 0;
}
```

---

## 作者：dengchengyu (赞：1)

## [P10200 [湖北省选模拟 2024] 花神诞日](https://www.luogu.com.cn/problem/P10200)

首先注意到一个集合中两两异或和的最小值就是，排序后相邻两个数异或和的最小值。证明可以考虑放到 01-Trie 上，从高往低位建树，求一个数与之异或的最小值，就是使高位相同位数尽可能多，则就是 01-Trie 上的前一个叶子或后一个叶子。

由此，我们可以设一个 $O(n^2)$ 的 DP，把 $a$ 排序后，设 $f_{i,j}$ 表示考虑完了前 $\max(i,j)$ 个数后，第一道菜考虑最后选了 $i$，第二道菜最后选了 $j$ 的方案数。转移就是考虑下一位与当前位是否属于同一道菜。这样我们能写出以下代码并获得[ 32 分](https://www.luogu.com.cn/record/197656757)。

```cpp
const int mod=1e9+7,N=5e3+5;
ll a[N],k1,k2;
int n,f[N][N];
void add(int &x,int y) {
	x+=y;
	if(x>=mod) x-=mod;
}
signed main(){
	read(n,k1,k2);
	fo(i,1,n) read(a[i]);
	sort(a+1,a+1+n);
	f[1][0]=f[0][1]=1;
	fo(i,2,n) {
		fu(j,0,i-1) {
			if((a[i]^a[i-1])>=k1) add(f[i][j],f[i-1][j]);
			if((a[i]^a[i-1])>=k2) add(f[j][i],f[j][i-1]);
			if(!j||(a[i]^a[j])>=k1) add(f[i][i-1],f[j][i-1]);
			if(!j||(a[i]^a[j])>=k2) add(f[i-1][i],f[i-1][j]);
		}
	}
	int ans=0;
	fu(i,1,n) add(ans,f[n][i]),add(ans,f[i][n]);
	write(ans);
	return 0;
}
```

这样的状态不太简洁，事实上我们可以设 $f_{i,j,0/1}$ 表示考虑完前 $i$ 个位置，上一个与 $i$ 颜色不同的位置是 $j(j<i)$，且第 $i$ 位属于第一道还是第二道菜的方案数。这与上面是等价的。则有如下转移（从 $1$ 转移是对称的）：
$$
f_{i,j,0}\to f_{i+1,j,0}(a_{i+1}\oplus a_{i}\ge k_1)
$$

$$
f_{i,j,0}\to f_{i+1,i,1}(a_{i+1}\oplus a_j\ge k_2\lor j=0)
$$

其中初始状态为 $f_{1,0,0}=f_{1,0,1}=1$。

考虑优化 DP。发现第一条转移与 $j$ 无关，我们可以直接继承。而第二条转移仅仅是把满足条件的 $j$ 求和，可以把 DP 数组中的每个数放在 01-Trie 上，动态开点存在 $a_j$ 代表的叶子中。由于条件是 $a_{i+1}\oplus a_j\ge k_2$ 所以可以 $O(\log V)$ 求和。时间复杂度 $O(n\log V)$。

AC 代码，注意最后要减掉其中一道菜不选的情况：

```cpp
const int mod=1e9+7,N=2e5+5;
const int L=1.5e7;
int n;
ll a[N],k1,k2;
void add(int &x,int y) {
	x+=y;
	if(x>=mod) x-=mod;
}
struct trie {
	int tot,tr[L][2],s[L];
	void insert(int &x,ll w,int v,int val) {
		if(!x) x=++tot,tr[x][0]=tr[x][1]=s[x]=0;
		if(v<0) {add(s[x],val); return;}
		insert(tr[x][w>>v&1],w,v-1,val);
		s[x]=(s[tr[x][0]]+s[tr[x][1]])%mod;
	}
	int query(int x,ll w1,ll w2,int v) {
		if(!x) return 0;
		if(v<0) return s[x];
		int o1=w1>>v&1,o2=w2>>v&1;
		if(o2) return query(tr[x][o1^1],w1,w2,v-1);
		else return (query(tr[x][o1],w1,w2,v-1)+s[tr[x][o1^1]])%mod;
	}
	int q0(int x,int v) {
		if(!x) return 0;
		if(v<0) return s[x];
		return q0(tr[x][0],v-1);
	}
}t1,t2;
int rt1,rt2;
signed main(){
	read(n,k1,k2);
	fo(i,1,n) read(a[i]);
	sort(a+1,a+1+n);
	t1.insert(rt1,0,59,1),t2.insert(rt2,0,59,1);
	fo(i,2,n) {
		int s1=t1.query(rt1,a[i],k2,59);
		int s2=t2.query(rt2,a[i],k1,59);
		if(a[i]<k2) add(s1,t1.q0(rt1,59));
		if(a[i]<k1) add(s2,t2.q0(rt2,59));
		if((a[i]^a[i-1])<k1) rt1=0,t1.tot=0;
		if((a[i]^a[i-1])<k2) rt2=0,t2.tot=0;
		t1.insert(rt1,a[i-1],59,s2),t2.insert(rt2,a[i-1],59,s1);
	}
	write(((ll)mod+t1.s[rt1]+t2.s[rt2]-t1.q0(rt1,59)-t2.q0(rt2,59))%mod);
	return 0;
}
```

---

## 作者：littlez_meow (赞：1)

今年二月份的时候不会做，现在看来觉得自己当时好菜啊。

## 思路

首先是一个结论，$\forall a<b<c,a\oplus c>\min\{a\oplus b,b\oplus c\}$，其中 $\oplus$ 是异或。换句话说，一个集合中异或和最小的两个数必然是从小到大排序后相邻的两个数。证明考虑丢到 trie 树上找到第一个不同位。

所以给 $a$ 排个序，问题变成给每个元素染成红蓝两种颜色之一，要求相邻红色的异或和 $\ge k_1$，相邻蓝色异或和 $\ge k_2$，必须两种颜色都有，求方案数。

这个题意长得很像什么？是不是很像 CSP-S2024 T3？

考虑一样地设状态。设 $dp(i,j,0/1)$ 表示当前已经决定了前 $i$ 个元素的颜色，第 $i$ 个元素的颜色是红/蓝，和 $i$ 颜色不同的最后一个元素是 $j$。

转移分两种，首先是 $i+1$ 和 $i$ 颜色相同，此时 $j\le i-1$：

$$dp(i+1,j,0)=dp(i,j,0)[a_{i+1}\oplus a_i\ge k_1]$$

$$dp(i+1,j,1)=dp(i,j,1)[a_{i+1}\oplus a_i\ge k_2]$$

其中方括号是艾弗森括号。然后是 $i+1$ 和 $i$ 颜色不同，也就是和 $j$ 颜色相同：

$$dp(i+1,i,0)=\sum\limits_{j=0}^{i-1}dp(i,j,1)[a_{i+1}\oplus a_j\ge k_1]$$

$$dp(i+1,i,1)=\sum\limits_{j=0}^{i-1}dp(i,j,0)[a_{i+1}\oplus a_j\ge k_2]$$

初值为 $a_0=\infty,dp(1,0,0)=dp(1,0,1)=1$。答案为 $\sum\limits_{i=1}^{n-1}(dp(n,i,0)+dp(n,i,1))$。注意此处 $i$ 是从 $1$ 开始，因为两种颜色都要有。

考虑优化。我们对 $i$ 扫描线，维护数列 $dp(i,*,0),dp(i,*,1)$ 的变化。

先考虑后两个转移。需要快速维护满足 $a_{i+1}\oplus a_j\ge k_t$ 的 $dp(i,j,t\oplus t)$ 的和。异或问题丢上 01-trie。我们在 $a_j$ 对应的叶子处维护 $dp(i,j,*)$，每个节点维护子树和。上面这个问题很容易在 trie 上做，如果 $k_t$ 的这一位是 $1$ 就递归到这一位异或 $a_{i+1}$ 为 $1$ 的子树，否则返回异或为 $1$ 的子树和加上递归到异或后为 $0$ 的子树的结果。

然后再是前两个。既然上 trie 树了那也好处理，如果 $a_{i+1}\oplus a_i\ge k_t$ 就不修改 $dp(i,*,t)$，否则打上 tag 赋值为 $0$，访问的时候像线段树一样下传 tag 即可。

最后统计答案不能去 $a_0$ 的子树，原因同上。

时间复杂度 $O(n\log V)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
using namespace std;
const int MAXN=2e5+1,MOD=1e9+7;
int n;
ll a[MAXN],k[2];
int rt=1,cnt=1,nxt[MAXN*64][2],s[2][MAXN*64],tag[MAXN*64];
inline void psd(int now){
	if(tag[now]&1){
		if(nxt[now][0]) s[0][nxt[now][0]]=0,tag[nxt[now][0]]|=1;
		if(nxt[now][1]) s[0][nxt[now][1]]=0,tag[nxt[now][1]]|=1;
	}
	if(tag[now]&2){
		if(nxt[now][0]) s[1][nxt[now][0]]=0,tag[nxt[now][0]]|=2;
		if(nxt[now][1]) s[1][nxt[now][1]]=0,tag[nxt[now][1]]|=2;
	}
	tag[now]=0;
	return;
}
inline void upd(int now){
	(s[0][now]=s[0][nxt[now][0]]+s[0][nxt[now][1]])>=MOD&&(s[0][now]-=MOD);
	(s[1][now]=s[1][nxt[now][0]]+s[1][nxt[now][1]])>=MOD&&(s[1][now]-=MOD);
	return;
}
void mdf(int&now,int dep,ll v,int val,int id){
	if(!now) now=++cnt;
	if(dep==-1) return s[id][now]=val,void();
	psd(now);
	mdf(nxt[now][v>>dep&1],dep-1,v,val,id);
	upd(now);
	return;
}
int qry(int now,int dep,ll v,bool id){//s[id^1] of v^a[i]>=k[id]
	if(!now) return 0;
	if(dep==-1) return s[id^1][now];
	psd(now);
	if(k[id]>>dep&1) return qry(nxt[now][(v>>dep&1)^1],dep-1,v,id);
	else{
		int ans=s[id^1][nxt[now][(v>>dep&1)^1]]+qry(nxt[now][v>>dep&1],dep-1,v,id);
		ans>=MOD&&(ans-=MOD);
		return ans;
	}
	return 0;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k[0]>>k[1];
	F(i,1,n) cin>>a[i];
	sort(a+1,a+n+1);
	a[0]=1ll<<60;
	mdf(rt,60,a[0],1,0),mdf(rt,60,a[0],1,1);
	F(i,1,n-1){
		int dp0,dp1;
		dp0=qry(rt,60,a[i+1],0),dp1=qry(rt,60,a[i+1],1);
		if((a[i+1]^a[i])<k[0]) tag[rt]|=1,s[0][rt]=0;
		if((a[i+1]^a[i])<k[1]) tag[rt]|=2,s[1][rt]=0;
		mdf(rt,60,a[i],dp0,0),mdf(rt,60,a[i],dp1,1);
	}
	cout<<((s[0][rt]+s[1][rt]-s[0][nxt[rt][1]]-s[1][nxt[rt][1]])%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：xyzfrozen (赞：1)

~~24号就打了 $4$ 分，输麻了~~。

Task $1$：二进制枚举，$O(n2^n)$。

特殊性质 $A$：

规定两个点之间有边，当且仅当异或权值 $\lt k=k_1=k_2$。

问题转化为每个连通块内部必须是二分图，可以交换染色方案。

答案为 $2^{cnt}$，$cnt$ 为连通块个数，注意判无解。

采用 Trie 优化建图可以做到 $O(n\log \max a)$。


------------

Task $2 \sim 8$：暴力 dp。

对于这种任意满足，可以排序，观察是否可以转化成相邻满足。

注意到两两不相等，考虑 $a \lt b \lt c$，有 $a \oplus c \gt \min (a \oplus b,b \oplus c)$。

设 $a$ 与 $c$ 最高的不一样 $bit$ 位为 $i$，那么 $a_i=0,c_i=1$。

那么直接讨论 $b$ 这一位，因为 $bit$ 上一定一样，选择 $b_i \oplus 1$ 的那一个就可以让 $bit$ 这一位为 $0$，而 $a_i \oplus c_i=1$。

排序后问题转化为，按顺序将原序列分为满足条件的两个非空子序列，每次在加入最后一个数的时候判断合法。

设 $f_{n,i,j}$ 表示第一个序列结尾是 $a_i$，第二个序列记为是 $a_j$ 的方案数，枚举 $a_{n+1}$ 放哪个序列即可转移到 $f_{n+1,n+1,j}/f_{n+1,i,n+1}$，$O(n^3)$，这个应该放个 $10$ 分的。

注意到我们是按顺序插入的，所以一定有一个序列结尾是 $a_{n}$，只需要知道另一个序列结尾是什么即可。

$f_{i,j,0/1}$ 表示 $a_i$ 在第 $1/2$ 个子序列，另一个子序列的结尾是 $a_j$ 的方案数，分四种情况讨论转移，$O(n^2)$，暴力应该给到 `44` 差不多。


```cpp
const int N=1e4+10,Q=1e9+7;
int n,k1,k2;
int a[N],pos[N],f[N][2],g[N][2];
void mod(int &x,int y){if((x+=y)>=Q) x-=Q;} //(x+y)%mod

signed main()
{
	n=fr(),k1=fr(),k2=fr(); //快读
	for(int i=1;i<=n;i++) a[i]=fr();
	sort(a+1,a+1+n);

	f[0][0]=f[0][1]=g[0][0]=g[0][1]=1;
	for(int i=2;i<=n;i++)
	{
		memcpy(f,g,sizeof f);
		memset(g,0,sizeof g);
		for(int j=0;j<=i;j++)
		{
			if((a[i-1]^a[i])>=k1) mod(g[j][0],f[j][0]);
			if(!j || (a[j]^a[i])>=k2) mod(g[i-1][1],f[j][0]);
			
			if((a[i]^a[i-1])>=k2) mod(g[j][1],f[j][1]);
			if(!j || (a[i]^a[j])>=k1) mod(g[i-1][0],f[j][1]);
		}
	}
	
	int ans=0;
	for(int i=0;i<=n;i++)
		mod(ans,g[i][0]),mod(ans,g[i][1]);
	fw(ans);
	return 0;
}
```

------------

Task $9 \sim 25$：优化 dp。

注意到我们每次只会更新含有 $i-1$ 的状态以及 $[0,i-2]$ 的状态从之前的继承，前者是一个前缀和操作，满足 $a_i \oplus a_j \geq k_1/k_2$，考虑用 Trie 优化这个求和。

第一种操作：

设 $f(now,x,y,d)$ 表示当前在 Trie 树节点 $now$，求所有满足 $a_j \oplus x \geq y$ 的 $j$ 的方案总和，当前考虑到第 $d$ 层，讨论 $x,y$ 在 $d$ 位是 $0/1$，$x \oplus a_j\gt y$ 的方案树直接加入答案，这一部分是子树和，插入节点时跳链维护，相等则继续递归。

每次只会递归相等的，所以是 $O(\log \max a)$ 的。

注意还要特判序列全空的情况，但是最后不能算入答案！

第二种：

继承成功就不管了，不会影响结果，继承失败就是清空 $[0,i-2]$ 的值，但是一个节点最多被清空一次，因为如果某一次继承失败了，这个节点的值会变成 $0$，而每次只会更新 $i-1$，之后也一直是 $0$，所有每次从上次清空完的后一个节点开始清空到 $i-2$，$O(n\log \max a)$。

总复杂度 $O(n\log \max a)$。

以下代码省去快读 `fr` ，快写 `fw` 和头文件。

```cpp
const int N=2e5+10,Q=1e9+7;
int n,k1,k2;
int a[N],pos[N];
void mod(int &x,int y){if((x+=y)>=Q) x-=Q;}

struct Trie
{
	int idx,tr[N*62][2],s[N*62],fa[N*62],lt=0;
	Trie(){idx=0;}
	int ins(int x)
	{
		int now=0;
		for(int i=60;~i;i--)
		{
			int word=(x>>i)&1;
			if(!tr[now][word]) fa[tr[now][word]=++idx]=now;
			now=tr[now][word];
		}
		return now;
	}
	
	void upd(int x,int v)
	{
		v=(v+Q)%Q,x=pos[x];
		while(x) (s[x]+=v)%=Q,x=fa[x];
	}
	
	void clear(int r)
	{
		if(!r) fill(s,s+idx+1,0);
		for(int i=lt+1;i<=r;i++)
			upd(i,-s[pos[i]]);
		lt=r;
	}
	
	int query(int now,int x,int y,int d)
	{
		//x^a[j]>=y;
		if(!~d) return s[now];
		int k=(x>>d)&1;
		if((y>>d)&1) return tr[now][k^1]?query(tr[now][k^1],x,y,d-1):0;
		else return (s[tr[now][k^1]]+(tr[now][k]?query(tr[now][k],x,y,d-1):0))%Q;
	}
}A,B;

signed main()
{
	n=fr(),k1=fr(),k2=fr();
	for(int i=1;i<=n;i++) a[i]=fr();
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++) pos[i]=A.ins(a[i]),B.ins(a[i]);

	for(int i=2,ety1=1,ety2=1;i<=n;i++)
	{
		int v1=B.query(0,a[i],k1,60)+ety2,v2=A.query(0,a[i],k2,60)+ety1;
		if((a[i-1]^a[i])<k1) A.clear(i-2),ety1=0;
		if((a[i-1]^a[i])<k2) B.clear(i-2),ety2=0;
		A.upd(i-1,v1),B.upd(i-1,v2);
	}
	
	fw((A.s[A.tr[0][0]]+A.s[A.tr[0][1]]+B.s[B.tr[0][0]]+B.s[B.tr[0][1]])%Q);
	return 0;
}
```

---

## 作者：王熙文 (赞：1)

提供一种神秘思路。

## 思路

钦定 $k_1 \ge k_2$。考虑对每个数 $a_i$ 取出 $k_1$ 的最高位之上（不包含最高位）的数 $b_i$。那么如果 $b_i \not=b_j$，则一定有 $a_i \oplus a_j \ge k_1 \ge k_2$。还可以发现，对于 $b_i$ 相同的数，选进第一个集合的个数 $\le 2$。因为如果超过两个，在 $k_1$ 的最高位一定存在两个相同的数。这样我们只需要对 $b_i$ 相同的分别解决。

这时候已经有一个多项式复杂度的做法了，直接枚举进第一个集合的元素，然后暴力判断。

仿照上面的思路，将每个数 $a_i$ 取出 $k_2$ 的最高位之上的数 $c_i$。还是将 $c_i$ 相同的放到一个集合，这样形成了若干个集合 $S_1,S_2,\cdots$。发现如果有一个集合的大小大于 $4$，则这个集合无法分出两个小于等于 $2$ 的子集，无解。这个特判对接下来的复杂度做了保证。考虑对集合不满足任意两个数大于等于 $k_2$ 的个数进行分讨，设其为 $cnt$。如果 $cnt >2$，则选到第一个集合的元素个数一定 $>2$，无解。否则，设 $fir,sec$ 分别表示第一个、第二个集合不满足条件（如果没有就是 $0$）。接下来对 $cnt$ 进行分讨。

* $cnt=0$：此时取任意子集都满足第二个集合的条件，现在只需要计算选出两个数使得异或 $\ge k_1$ 的个数即可。这个问题可以使用 01 Trie 树解决。将所有数插入 Trie 树。查询时，从大到小遍历二进制位。设查询数的当前位位 $nowx$。对 $k_1$ 的当前位 $nowk$ 进行分讨。如果 $nowk=1$，则第二个数的当前位必须与 $nowx$ 不同；否则，如果第二个数的当前位与 $nowx$ 不同，则一定满足条件，可以直接将子树大小加进答案里，否则，需要继续枚举下面的位。

* $cnt \not=0$：因为集合大小 $\le 4$，所以可以暴力枚举这一个或两个集合中放进第一个集合的元素，并检查第一个集合和第二个集合是否都满足条件。如果只放进一个元素，则需要继续枚举另一个元素。

这样我们就得到了一个子问题的答案。将这些答案乘起来即为原问题的答案。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int n,k1,k2;
int a[200010];
map<int,vector<int>> mp,mmp;
int tot; vector<int> vvec[200010];
struct Trie
{
	int tot=0,son[13000010][2],siz[13000010];
	void insert(int x,int f)
	{
		int now=0;
		for(int i=60; i>=0; --i)
		{
			int nowx=(x>>i&1);
			if(son[now][nowx]==0) son[now][nowx]=++tot;
			now=son[now][nowx],siz[now]+=f;
		}
	}
	int query(int x)
	{
		int ans=0,now=0;
		for(int i=60; i>=0; --i)
		{
			int nowx=(x>>i&1),nowk=(k1>>i&1);
			if(nowk==1) now=son[now][nowx^1];
			else ans+=siz[son[now][nowx^1]],now=son[now][nowx];
			if(now==0) return ans;
		}
		ans+=siz[now];
		return ans;
	}
} trie;
signed main()
{
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>n>>k1>>k2;
	if(k1<k2) swap(k1,k2);
	int ax1=__lg(k1),ax2=__lg(k2);
	for(int i=1; i<=n; ++i) cin>>a[i],mp[a[i]>>ax1+1].push_back(a[i]);
	int ans=1;
	bool all1=1,all2=1;
	for(pair<int,vector<int>> tmp:mp)
	{
		vector<int> vec=tmp.second;
		all1&=(vec.size()==1 || (vec.size()==2 && (vec[0]^vec[1])>=k1));
		mmp.clear();
		for(int i:vec) mmp[i>>ax2+1].push_back(i);
		bool flag=1;
		int fir=0,sec=0;
		tot=0;
		for(pair<int,vector<int>> ttmp:mmp)
		{
			vvec[++tot]=ttmp.second;
			all2&=(vvec[tot].size()==1 || (vvec[tot].size()==2 && (vvec[tot][0]^vvec[tot][1])>=k2));
			if(vvec[tot].size()>4) return cout<<0,0;
			if(vvec[tot].size()>2 || (vvec[tot].size()==2 && (vvec[tot][0]^vvec[tot][1])<k2))
			{
				if(fir==0) fir=tot;
				else if(sec==0) sec=tot;
				else return cout<<0,0;
			}
		}
		int nowans=0;
		if(fir==0)
		{
			for(int i:vec) trie.insert(i,1);
			for(int i:vec) nowans+=trie.query(i);
			nowans/=2;
			nowans+=vec.size()+1;
			for(int i:vec) trie.insert(i,-1);
		}
		else if(sec==0)
		{
			map<int,bool> vis;
			for(int i:vvec[fir]) vis[i]=1;
			map<int,bool> vvis;
			for(int i:vvec[fir])
			{
				vvis[i]=1;
				bool flag=1;
				for(int j:vvec[fir])
				{
					if(j==i) continue;
					for(int k:vvec[fir]) if(k!=i && k!=j) flag&=(j^k)>=k2;
				}
				if(flag)
				{
					++nowans;
					for(int j:vec) if(!vis[j]) nowans+=(i^j)>=k1;
				}
				for(int j:vvec[fir])
				{
					if(vvis[j] || (i^j)<k1) continue;
					bool flag=1;
					for(int k:vvec[fir])
					{
						if(k==i || k==j) continue;
						for(int l:vvec[fir])
						{
							if(l!=i && l!=j && l!=k) flag&=(k^l)>=k2;
						}
					}
					nowans+=flag;
				}
			}
		}
		else
		{
			for(int i:vvec[fir])
			{
				bool flag=1;
				for(int j:vvec[fir])
				{
					if(j==i) continue;
					for(int k:vvec[fir]) if(k!=i && k!=j) flag&=(j^k)>=k2;
				}
				if(!flag) break;
				for(int j:vvec[sec])
				{
					if((i^j)<k1) continue;
					bool flag=1;
					for(int k:vvec[sec])
					{
						if(k==j) continue;
						for(int l:vvec[sec]) if(l!=j && l!=k) flag&=(k^l)>=k2;
					}
					nowans+=flag;
				}
			}
		}
		ans=ans*(nowans%mod)%mod;
	}
	cout<<(ans-all1-all2+mod)%mod;
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：1)

一个集合中两两异或最小值在排序后相邻的元素间取到。

因为需要相同才可以减少异或值，而越高位相同值就越小，因此值在排序后会相邻。

然后考虑排序后变成提取出一个子序列的问题，考虑刻画这个子序列，不难发现转移时只需要知道两个序列最后一个元素即可。

首先前一个元素一定是某一个序列的最后一个元素，记录下属于哪一个序列并记录下另一个子序列的最后一个元素，形式化的说就是设计状态 $dp_{i,u,0/1}$ 表示考虑到第 $i$ 位，第 $i$ 位的元素是哪个子序列的结尾，另一个子序列的结尾为 $u$ 的方案数。

转移有 $4$ 种，这里讨论两种，其余类似。

1. 第 $i-1$ 位属于第一个序列，第 $i$ 位属于第二个，那么 $dp_{i,a_{i-1},1} = \sum_{u \oplus a_i \geq k_1} dp_{i-1,u,0}$。

2. 第 $i-1$ 位属于第一个序列，第 $i$ 位属于第一个，那么假若 $a_{i-1} \oplus a_{i} \geq k_1$ 则可以全部继承过来，否则贡献为 $0$。

第二种是好维护的，第一种考虑将所有状态以 $u$ 为下标丢到字典树上转移即可。

时间复杂度 $O(n \log V)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9+7;
//dp[u][k][0] -> dp[u][k][0]*(a[i]^a[i-1]>=k1)
//dp[u][k][0] -> dp[u][a[i-1]][1]*(k^a[i]>=k2) 所有 dp[u][k][0] 之和
//dp[u][k][1] -> dp[u][k][1]*(a[i]^a[i-1]>=k2)
//dp[u][k][1] -> dp[u][a[i-1]][0]*(k^a[i]>=k1) 所以 dp[u][k][1] 之和
const int maxn = 2e5+114;
int tr[maxn*130],ls[maxn*130],rs[maxn*130],tot;
void ins(int x,int v,int rt){
  int u=rt;
  for(int i=60;i>=0;i--){
    tr[u]+=v;
    tr[u]%=mod;
    if((1ll<<i)&x){
      if(rs[u]==0) rs[u]=++tot;
      u=rs[u];
    }else{
      if(ls[u]==0) ls[u]=++tot;
      u=ls[u];
    }
  }
  tr[u]+=v;
  tr[u]%=mod;
}
int ask(int k,int x,int rt){//异或上 x 不小于 k 的权值之和
  int u=rt,res=0;
  for(int i=60;i>=0;i--){
    if((1ll<<i)&k){
      if((1ll<<i)&x) u=ls[u];
      else u=rs[u];
    }else{
      if((1ll<<i)&x) res+=tr[ls[u]],res%=mod,u=rs[u];
      else res+=tr[rs[u]],res%=mod,u=ls[u];
    }
  }
  res+=tr[u];
  res%=mod;
  return res;
}
int a[maxn],n,k1,k2;
signed main(){
  cin>>n>>k1>>k2;
  for(int i=1;i<=n;i++) cin>>a[i];
  sort(a+1,a+n+1);
  int rt1=++tot,rt2=++tot;
  ins(a[1],1,rt1);
  ins(a[1],1,rt2);
  int sum=a[1]^a[2];
  for(int i=3;i<=n;i++){
    int add1=ask(k2,a[i],rt1);
    int add2=ask(k1,a[i],rt2);
    if((a[i]^a[i-1])<k1) rt1=++tot;
    if((a[i]^a[i-1])<k2) rt2=++tot;
    ins(a[i-1],add1,rt2);
    ins(a[i-1],add2,rt1);
    if(sum>=k2) ins(a[i-1],1,rt1);
    if(sum>=k1) ins(a[i-1],1,rt2);
    sum=min(sum,(a[i]^a[i-1]));
  }
  int ans=(tr[rt1]+tr[rt2])%mod;
  cout<<ans<<'\n';
  return 0;
}
```


---

## 作者：hez_EX (赞：1)

好题！写篇题解纪念一下被 $\mathcal{O}(n^2)$ 做法卡了七个小时……

~~这里吐槽一下官方题解的抽象~~。于是就写一篇推导过程多一点的题解，~~至少让愿意看的人看懂~~。

### 性质
> 假设在无序数列 $a$ 中，任意两数的异或和的最小值应该出现在排序后任意两个相邻的数之间。

~~这里楼上题解证得很详细，此处就不证了~~。

显然考虑对数列排序后 DP：

### $\mathcal{O}(n^3)$ 做法
题面要求相当于把序列 $a$ **恰好**分入两个数列 $b,c$ 使对于任意两个属于相同数列的元素 $u,v$ 和对应数列的 $k$ 有 $u\oplus v \leqslant k$。

记 $f_{i,j}$ 为当序列 $b,c$ 末尾元素分别是 $a_i,a_j$ 时的总答案数，易得转移方程为：

$$f_{i,j}=\sum_{k\in[1,i)}f_{k,j}(a_k \oplus a_i \geqslant k_1)+\sum_{k\in[1,i)}f_{i,k}(a_k \oplus a_j \geqslant k_2)$$

### $\mathcal{O}{(n^2)}$ 做法
对上面的方程稍加优化即可得出，规定 $f_{i,j,0/1}$ 为考虑插入数 $a_i$，此时末尾元素**非** $a_i$ 的序列末尾元素为 $a_j$ 时的总方案数，第三维为 $0$ 代表 $a_i$ 插在了序列 $b$ 后，$1$ 代表插在了 $c$ 后。于是我们得到转移方程（以下是对于插入 $b$ 序列半边的推导，另外半边类似，不过多赘述。）：

$$f_{i,j,0}=f_{i-1,j,0}(j<i-1)(a_{i-1}\oplus a_i\geqslant k_1)$$

特别地，当 $j=i-1$ 时有：

$$f_{i,i-1,0}=\sum_{j\in[1,i-1)}f_{i-1,j,1}(a_i\oplus a_j\geqslant k_1)$$

### $\mathcal{O}(n \log n)$ 做法
题目中的操作都带有异或相关条件，考虑使用 01-Trie 优化，沿上述方程继续推导如下。

注意到对于方程在 $i$ 处的状态只与 $i-1$ 处的状态有关，兼之要采用数据结构优化，瞬间联想到[方伯伯的玉米田](https://www.luogu.com.cn/problem/P3287)，这里处理方法类似，利用滚动压去第一维后，可以发现每次的更新变为了：

$$f_{j,0} \longleftarrow f_{j,0} (0\leqslant j<i-1)(a_{i-1}\oplus a_i \geqslant k_1)$$

$$f_{i-1,0} \longleftarrow \sum_{j\in[1,i-1)}f_{j,1}(a_i\oplus a_j\geqslant k_1)$$

注意到第一个式子中的前一个条件是循环限定条件，后一个条件是独立于 $j$ 的；第二个式子中的条件即在另一数组中求和，所以试直接将整个数组用 01-Trie 维护，直接在 01-Trie 上进行转移。对于第一个方程不成立时直接将根的儿子清空；对于第二个方程写一个特制的查询函数查到了结果后插入在 01-Trie 的 $a_{i-1}$ 位置上即可。

### [AC](https://www.luogu.com.cn/record/148814472) 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <algorithm>
#define ls tr[now].ch[0]
#define rs tr[now].ch[1]
#define fa tr[now].fat
#define gb(x,p) (((x)>>(p))&1)
#define p 1000000007
using namespace std;
template<class T>
inline void read(T &x)
{
	char c=getchar();x=0;
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10+c-48,c=getchar();
}
struct node
{
	long long sum;
	int ch[2];bool lzy;
}tr[80000005];
int n,top,rut0,rut1;
long long k0,k1,a[200005],tmp0,tmp1;
bool at0,at1;
int mkn(long long val){return tr[++top]=(node){val,0,0},top;}
void upd(int now){tr[now].sum=(tr[ls].sum+tr[rs].sum)%p;}
void ins(int now,long long k,long long val,int d)
{
	if(d<0) return (void)(tr[now].sum=val);
	if(!tr[now].ch[gb(k,d)]) tr[now].ch[gb(k,d)]=mkn(0);
	ins(tr[now].ch[gb(k,d)],k,val,d-1);upd(now);
}
long long qry(int now,long long val,long long k,int d)
{
	if(!now) return 0;if(d<0) return tr[now].sum;
	if(gb(k,d)) return qry(tr[now].ch[gb(val,d)^1/*val^this_bit=1 => this_bit=val^1*/],val,k,d-1);
	else return (qry(tr[now].ch[gb(val,d)],val,k,d-1)+tr[tr[now].ch[!gb(val,d)]].sum)%p;
}
int main()
{
	read(n);read(k0);read(k1);rut0=mkn(0);rut1=mkn(0);
	for(int i=1;i<=n;i++) read(a[i]);sort(a+1,a+n+1);
	ins(rut0,a[1],1,62);ins(rut1,a[1],1,62);at0=(a[1]^a[2])>=k0;at1=(a[1]^a[2])>=k1;
	for(int i=3;i<=n;i++)
	{
		tmp0=qry(rut1,a[i],k0,62)+at1;tmp1=qry(rut0,a[i],k1,62)+at0;
		if((a[i-1]^a[i])<k0) tr[rut0].ch[0]=tr[rut0].ch[1]=0,at0=false;
		if((a[i-1]^a[i])<k1) tr[rut1].ch[0]=tr[rut1].ch[1]=0,at1=false;
		ins(rut0,a[i-1],tmp0,62);ins(rut1,a[i-1],tmp1,62);
//		printf("%d %d\n",tr[rut0].sum,tr[rut1].sum);
	}
	printf("%d",(tr[rut0].sum+tr[rut1].sum)%p);
	return 0;
}
```

这道题 01-Trie 要求的空间真是离谱，开了 $400$ 倍大。（雾）

~~第二次写题解，审核大大辛苦了。~~

---

## 作者：0xyz (赞：0)

首先，有一个显然结论：对于任意 $a<b<c,\min(a\oplus b,b\oplus c,c\oplus a)=\min(a\oplus b,b\oplus c)$。要证明它，我们不妨去掉 $a,b,c$ 二进制表示下的最长相同前缀，得到 $a',b',c'$，此时任意两个数异或值不变，有 $\text{highbit}(a')\le\text{highbit}(b')\le\text{highbit}(c')$，然后讨论此时最高位的大小关系即可。

我们可以进而推出：$a_1\le a_2\le …\le a_k,\min\limits_{1\le i<j\le k}\{a_i\oplus a_j\}=\min\limits_{1\le i\le k-1}\{a_i\oplus a_{i+1}\}$。注意到我们不关心食材的使用顺序，所以可以在一开始将所有食材从小到大排序，对于两道菜都从小到大使用食材，此时我们只需要关心两道菜各自的最后一个食材是什么就可以了。

假设 $f_{i,j,l}$ 表示考虑前 $i$ 个食材，第一道菜最后使用的食材是 $j$，第二道菜最后使用的食材是 $l$，并且满足对于两道菜味道要求的方案数。

注意到第 $i$ 个食材一定属于两道菜之一，所以一个有用状态必定有 $j=i$ 或者 $l=i$。由于两道菜的味道最小值要求不同，我们假设 $f_{i,o,j}$ 表示考虑前 $i$ 个食材，第 $o$ 道菜最后使用的食材是 $i$，第 $3-o$ 道菜最后使用的食材是 $j$，并且满足对于两道菜味道要求的方案数。转移方程就是：

$$\begin{cases}f_{i,o,i-1}=\sum\limits_{a_j\oplus a_i\ge k_o} f_{i-1,3-o,j}\\f_{i,o,j}=f_{i-1,o,j}&a_{i-1}\oplus a_i\ge k_o\end{cases}$$

很明显，$f_{i,*,*}$ 只能从 $f_{i-1,*,*}$ 得到。所以 $i$ 这一维可以滚动，此时空间复杂度变为 $O(n)$。

32 分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll _=2e5+5,mod=1e9+7;
ll n,k[2],s,a[_],f[2][_];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0); 
	cin>>n>>k[0]>>k[1];
	for(ll i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	f[0][0]=f[1][0]=1;
	for(ll i=2;i<=n;i++){
		for(ll j=i-2;~j;j--)
			for(ll o:{0,1})
				if(!j||(a[j]^a[i])>=k[o])f[o][i-1]=(f[o][i-1]+f[o^1][j])%mod;
		for(ll o:{0,1})
			if((a[i-1]^a[i])<k[o])for(ll j=i-2;~j;j--)f[o][j]=0;
	}
	for(ll o:{0,1})
		for(ll j=1;j<n;j++)s=(s+f[o][j])%mod;
	cout<<s<<'\n';
	return 0;
}
```

下式就是一个前缀赋值。对于上式，考虑什么样的 $x$ 满足 $x\oplus a_i\ge k_o$。不难发现我们在值域中抠掉 $x\oplus a_i<k_o$ 的 $x$ 对应区间，剩下的就是合法的 $x$ 了。所以我们想要快速求出 $0\oplus a_i,1\oplus a_i,2\oplus a_i,…,(k_o-1)\oplus a_i$ 的所有值域区间。考虑 $0\oplus y,1\oplus y,2\oplus y,…,(2^j-1)\oplus y$，$0,1,2,…,2^j-1$ 分别异或上 $y$，实际上是对 $y$ 的最低 $j$ 位进行等概率随机取反，其值域区间恰为 $[2^j\lfloor\frac{y}{2^j}\rfloor,2^j\lfloor\frac{y}{2^j}\rfloor+2^j-1]$。所以我们对 $k_o$ 进行二进制拆分，可以将 $a_i$ 转化成 $O(\log V)$ 个不同的 $y$，从而得到 $O(\log V)$ 个值域连续段。所以，上式实际上就是对于 $O(\log V)$ 个值域连续段求其区间和。用线段树维护，总时间复杂度 $O(n\log n\log V)$，空间复杂度 $O(n)$。

100 分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll _=8e5+5,mod=1e9+7;
ll n,k[2],a[_],s[2][_],t[2][_];
ll qry(ll x,ll l,ll r,ll o,ll ql,ll qr){
	if(ql<=l&&r<=qr)return s[o][x];
	ll mid=l+r>>1,res=0;
	if(~t[o][x]){
		s[o][x<<1]=(mid-l+1)*t[o][x]%mod;
		s[o][x<<1|1]=(r-mid)*t[o][x]%mod;
		t[o][x<<1]=t[o][x<<1|1]=t[o][x];
		t[o][x]=-1;
	}
	if(ql<=mid)res=qry(x<<1,l,mid,o,ql,qr);
	if(qr>mid)res=(res+qry(x<<1|1,mid+1,r,o,ql,qr))%mod;
	return res;
}
void upd(ll x,ll l,ll r,ll o,ll ql,ll qr,ll v){
	if(ql<=l&&r<=qr){
		s[o][x]=v*(r-l+1)%mod;
		t[o][x]=v;
		return;
	}
	ll mid=l+r>>1;
	if(~t[o][x]){
		s[o][x<<1]=(mid-l+1)*t[o][x]%mod;
		s[o][x<<1|1]=(r-mid)*t[o][x]%mod;
		t[o][x<<1]=t[o][x<<1|1]=t[o][x];
		t[o][x]=-1;
	}
	if(ql<=mid)upd(x<<1,l,mid,o,ql,qr,v);
	if(qr>mid)upd(x<<1|1,mid+1,r,o,ql,qr,v);
	s[o][x]=(s[o][x<<1]+s[o][x<<1|1])%mod;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0); 
	cin>>n>>k[0]>>k[1];
	for(ll i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(ll i=1;i<=4*n;i++)t[0][i]=t[1][i]=-1;
	upd(1,0,n-1,1,0,0,1);upd(1,0,n-1,0,0,0,1);
	for(ll i=2;i<=n;i++){
		ll d[2];
		for(ll o:{0,1}){
			ll p=0,h=0;
			for(ll j=59;~j;j--)
				if((k[o]>>j)&1){
					ll q=(h^a[i])>>j,l,r;
					l=lower_bound(a+1,a+n+1,q<<j)-a;
					r=lower_bound(a+1,a+n+1,(q+1)<<j)-a-1;
					r=min(r,i-2);
					if(l<=r)p=(p+qry(1,0,n-1,o^1,l,r))%mod;
					h+=1ll<<j;
				}
			d[o]=(qry(1,0,n-1,o^1,0,n-1)-p+mod)%mod;
		}
		for(ll o:{0,1}){
			upd(1,0,n-1,o,i-1,i-1,d[o]);
			if((a[i-1]^a[i])<k[o])upd(1,0,n-1,o,0,i-2,0);
		}
	}
	cout<<(qry(1,0,n-1,0,1,n-1)+qry(1,0,n-1,1,1,n-1))%mod<<'\n';
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10200)

**题目大意**

> 给定 $a_1\sim a_n$，将所有数划分成 $X,Y$ 两个子集，使得 $X$ 中任意两个不同元素异或和 $\ge k_1$，$Y$ 中任意两个不同元素异或和 $\ge k_2$，求方案数。
>
> 数据范围：$n\le 2\times 10^5,a_i,k_1,k_2<2^{60}$。

**思路分析**

根据经典结论，如果有 $x<y<z$，那么一定有 $x\oplus z>\min(x\oplus y,y\oplus z)$，可以分讨 $\mathrm{highbit}$ 分布情况证明。

因此我们把 $a_i$ 从小到大排序，只要 $X,Y$ 的邻项异或和 $\ge k_1,k_2$ 即可。

设 $f_{i,j}$ 表示 dp 到 $a_i$ 且 $a_i\in X$，上一个在 $Y$ 中的元素是 $a_j$，$g_{i,j}$ 类似定义。

考虑 $f_{i,j}$ 的转移，如果 $a_i\oplus a_{i+1}\ge k_1$，那么 $f_{i+1,j}=f_{i,j}$，否则 $f_{i+1,j}=0$。

如果 $a_j\oplus a_{i+1}\ge k_2$，$f_{i,j}$ 可以转移到 $g_{i+1,i}$，特殊处理 $j=0$ 的情况。

因此我们只要维护数据结构支持整体清空，查询 $\sum\limits_{i\oplus x\ge k}f_i$ 的值，直接用 Trie 树维护懒标记和子树和即可。

时间复杂度 $\mathcal O(n\log V)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5,MOD=1e9+7;
void add(int &x,int y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
namespace T {
struct Node {
	int s[2],f[2]; bool tg[2];
	Node() { s[0]=s[1]=f[0]=f[1]=tg[0]=tg[1]=0; }
}	tr[MAXN*64];
void adt(Node &p,int o) { p.tg[o]=true,p.f[o]=0; }
void psd(Node &p) {
	for(int o:{0,1}) if(p.tg[o]) {
		if(p.s[0]) adt(tr[p.s[0]],o);
		if(p.s[1]) adt(tr[p.s[1]],o);
		p.tg[o]=false;
	}
}
int tot=1;
void ins(ll z) {
	int p=1;
	for(int i=59;~i;--i) {
		int c=z>>i&1;
		if(!tr[p].s[c]) tr[p].s[c]=++tot;
		p=tr[p].s[c];
	}
}
void upd(ll z,int x,int o) {
	int p=1;
	for(int i=59;~i;--i) {
		psd(tr[p]),add(tr[p].f[o],x);
		p=tr[p].s[z>>i&1];
	}
	add(tr[p].f[o],x);
}
int qry(ll z,ll k,int o) {
	int p=1,x=0;
	for(int i=59;~i;--i) {
		psd(tr[p]);
		int q=tr[p].s[(z>>i&1)^1];
		if(k>>i&1) p=q;
		else add(x,tr[q].f[o]),p=tr[p].s[z>>i&1];
	}
	return x;
}
}
int n;
ll a[MAXN],X,Y;
signed main() {
	scanf("%d%lld%lld",&n,&X,&Y),--X,--Y;
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]),T::ins(a[i]);
	sort(a+1,a+n+1);
	ll cur=1ll<<60;
	for(int i=2;i<=n;++i) {
		int f=(T::qry(a[i],X,0)+(cur>Y))%MOD;
		int g=(T::qry(a[i],Y,1)+(cur>X))%MOD;
		if((a[i-1]^a[i])<=X) T::adt(T::tr[1],1);
		if((a[i-1]^a[i])<=Y) T::adt(T::tr[1],0);
		if(f) T::upd(a[i-1],f,1);
		if(g) T::upd(a[i-1],g,0);
		if(i>1) cur=min(cur,a[i-1]^a[i]);
	}
	int ans=(T::tr[1].f[0]+T::tr[1].f[1])%MOD;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Nelofus (赞：0)

没想到我学的字符串在这里用上了。

根据一个经典结论，如果有三个串 $A,B,C$ 满足 $A<B<C$，那么 $\operatorname{LCP}(A,B), \operatorname{LCP}(B,C)\ge \operatorname{LCP}(A,C)$。

对于这题，显然有若 $a<b<c$，则 $a\operatorname{xor}c\ge \min(a\operatorname{xor}b,b\operatorname{xor}c)$。

所以只用考虑排序后两两相邻的最值即可。不妨设 $f_{i,j,k}$ 表示前 $i$ 个数，种类 $1$ 的末尾下标是 $j$，种类 $2$ 的末尾下标是 $k$ 的方案数。

又注意到 $j,k$ 必定有一个是 $i$，那么 $f_{i,j,0/1}$ 表示第 $i$ 个数在序列 $1/2$ 的末尾，另一个序列末尾下标为 $j$ 的方案数。

假设还是放在同一个序列末尾：
$$
f_{i,j,0/1}\leftarrow f_{i,j,0/1}+[a_i\operatorname {xor} a_{i-1}\ge k]f_{i-1,j,0/1}(j\neq i-1)
$$
否则：
$$
f_{i,i-1,0/1}\leftarrow f_{i,i-1,0/1}+[a_i\operatorname{xor} a_j\ge k]f_{i-1,j,1/0}(j\neq i-1)
$$

```cpp
#include <bits/stdc++.h>
using i64 = long long;
using u64 = unsigned long long;

constexpr int N = 2e5 + 10;
constexpr int M = 5e3 + 10;
constexpr int mod = 1e9 + 7;
int n;
u64 k1, k2;
u64 a[N];
int f[M][M][2];

inline int Plus(const int &x, const int &y) {
	return x + y >= mod ? x + y - mod : x + y;
}
inline int Minu(const int &x, const int &y) {
	return x - y < 0 ? x - y + mod : x - y;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	std::cin >> n >> k1 >> k2;
	for (int i = 1; i <= n; i++)	std::cin >> a[i];
	std::sort(a + 1, a + 1 + n);
	f[1][0][0] = 1;
	f[1][0][1] = 1;
	for (int i = 2; i <= n; i++) {
		for (int j = 0; j < i - 1; j++) {
			if ((a[i] ^ a[i - 1]) >= k1)
				f[i][j][0] = Plus(f[i][j][0], f[i - 1][j][0]);
			if ((a[i] ^ a[i - 1]) >= k2)
				f[i][j][1] = Plus(f[i][j][1], f[i - 1][j][1]);

			if (j == 0 || (a[i] ^ a[j]) >= k1)
				f[i][i - 1][0] = Plus(f[i][i - 1][0], f[i - 1][j][1]);
			if (j == 0 || (a[i] ^ a[j]) >= k2)
				f[i][i - 1][1] = Plus(f[i][i - 1][1], f[i - 1][j][0]);
		}
	}
	int ans = 0;
	for (int i = 0; i < n; i++)
		ans = Plus(ans, Plus(f[n][i][0], f[n][i][1]));
	std::cout << ans << '\n';
	return 0;
}
```

观察转移，发现前半部分若 $a_i\operatorname{xor} a_{i-1}\ge k$ 就直接继承，后半部分只有一个点的改变，可以直接压掉第一维。同时不妨对 $a_{i-1}$ 建出两棵 Trie 树，分别在叶子处维护 $f_{i,0/1}$ 的值。

```cpp
#include <bits/stdc++.h>
using i64 = long long;
using u64 = unsigned long long;

constexpr int N = 2e5 + 10;
constexpr int M = 61;
constexpr int mod = 1e9 + 7;

int n;
u64 k1, k2;
u64 a[N];

inline int Plus(const int &x, const int &y) {
	return x + y >= mod ? x + y - mod : x + y;
}

inline int Minu(const int &x, const int &y) {
	return x - y < 0 ? x - y + mod : x - y;
}

int tot;
struct node {
	std::array<int, 2> ch;
	int sum;
} tr[N * M * 2];
int rt[2], st[2];

u64 deg(const u64 &x, const int &k) {
	return x >> k & 1;
}

void insert(int u, const u64 &x, int val) {
	if (!val)
		return ;
	for (int i = M; i >= 0; i--) {
		if (!tr[u].ch[deg(x, i)])
			tr[u].ch[deg(x, i)] = ++tot;
		tr[u].sum = Plus(tr[u].sum, val);
		u = tr[u].ch[deg(x, i)];
	}
	tr[u].sum = Plus(tr[u].sum, val);
	return;
}

int query(int u, const u64 &x, const u64 &k) {
	int ans = 0;
	for (int i = M; i >= 0; i--) {
		if (deg(k, i) == 0)
			ans = Plus(ans, tr[tr[u].ch[deg(x, i) ^ 1]].sum);
		if (!tr[u].ch[deg(x, i) ^ deg(k, i)])
			return ans;
		u = tr[u].ch[deg(x, i) ^ deg(k, i)];
	}
	ans = Plus(ans, tr[u].sum);
	return ans;
}

int main() {
#ifdef HeratinoNelofus
	freopen("input.txt", "r", stdin);
#endif
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	std::cin >> n;
	std::cin >> k1 >> k2;
	for (int i = 1; i <= n; i++)
		std::cin >> a[i];
	std::sort(a + 1, a + 1 + n);

	rt[0] = ++tot;
	rt[1] = ++tot;
	st[0] = 1;
	st[1] = 1;

	// insert(rt[0], a[0], 1, M);
	// insert(rt[1], a[0], 1, M);
	for (int i = 2; i <= n; i++) {
		int res1 = query(rt[1], a[i], k1);	// f[i][1] 中 a[i] ^ a[j] >= k2 的
		int res2 = query(rt[0], a[i], k2);	// f[i][0] 中 a[i] ^ a[j] >= k1 的

			res1 = Plus(res1, st[1]);
			res2 = Plus(res2, st[0]);

		if ((a[i] ^ a[i - 1]) < k1)
			tr[rt[0]].ch[0] = tr[rt[0]].ch[1] = 0,
				tr[rt[0]].sum = 0, st[0] = 0;

		if ((a[i] ^ a[i - 1]) < k2)
			tr[rt[1]].ch[0] = tr[rt[1]].ch[1] = 0,
				tr[rt[1]].sum = 0, st[1] = 0;
		insert(rt[0], a[i - 1], res1);
		insert(rt[1], a[i - 1], res2);
	}
	int ans = Plus(tr[rt[0]].sum, tr[rt[1]].sum);
	std::cout << ans << '\n';
	return 0;
}
```

---

## 作者：Jsxts_ (赞：0)

首先需要知道一个结论：一个序列两两异或和最小值，为将其排序后所有相邻数异或和的最小值。

知道之后，我们按 $a_i$ 从小到大枚举其划分进哪个集合，并统计方案数。

具体地，设 $f_{i,j}$ 表示前 $i$ 个数，不和 $i$ 在一个集合里的下标最大数为 $j$（这里因为要区分两个集合，所以当 $0\le j\le n$ 时表示 $j$ 是集合 $1$ 的，$n+1\le j\le 2n+1$ 时表示 $j$ 是集合 $2$ 的）。

转移即枚举下一位填什么，满足对应限制即可。

```cpp
for (int j = 0;j <= n;j ++ ) {
	if (i == 0 || (a[i] ^ a[i + 1]) >= k2) dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;
	if (j == 0 || (a[j] ^ a[i + 1]) >= k1) dp[i + 1][i + n + 1] = (dp[i + 1][i + n + 1] + dp[i][j]) % mod;
}
for (int j = n + 1;j <= 2 * n + 1;j ++ ) {
	if (i == 0 || (a[i] ^ a[i + 1]) >= k1) dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;
	if (j == n + 1 || (a[j - n - 1] ^ a[i + 1]) >= k2) dp[i + 1][i] = (dp[i + 1][i] + dp[i][j]) % mod;
}
```

然后我们对着转移优化：

$j=0,n+1$ 较为特殊，单独拿出来，然后将 $j\in 1\sim n$ 与 $j\in n+2\sim 2n+1$ 的下标对应 dp 值分开维护。

- 对于形如 `(a[i] ^ a[i + 1]) >= k1` 的限制，相当于一个全局推平成 $0$ 的操作。

- 对于形如 `(a[j] ^ a[i + 1]) >= k1` 的限制，由于这类贡献是一个单点修改，若我们将对应 dp 值放到 Trie 树上的对应节点，则就是在 Trie 上的子树查询。我们可以将单点修改，子树查询转为到根修改，单点查询。

所以现在要维护一个数据结构支持：单点修改，全局推平成 $0$，单点查询，维护修改时间即可做到 $O(1)-O(1)$。

总共 $O(n\log V)$ 次修改和查询，总复杂度 $O(n\log V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 1e9;
const ll INF = 1e15;
const int N = 2e5;
inline ll read() {
	ll s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
struct Trie {
	int ch[N * 60][2],to[N + 10];
	int tot,fa[N * 60];
	void insert(ll x,int id) {
		int u = 0;
		for (int i = 59;~i;i -- ) {
			int t = x >> i & 1;
			if (!ch[u][t]) ch[u][t] = ++tot, fa[tot] = u;
			u = ch[u][t];
		}
		to[id] = u;
	}
}T;
const int mod = 1e9 + 7;
int getmod(int x) {
	return x - (x >= mod) * mod;
}
struct ds {
	int val[N * 60],tag,t[N * 60];
	void modify(int x,int s,int now) {
		if (t[x] < tag) val[x] = s;
		else val[x] = getmod(val[x] + s);
		t[x] = now;
	}
	int query(int x) {
		return t[x] < tag ? 0 : val[x];
	}
	void tp(int now) {
		tag = now;
	}
}t1,t2;
int n,dp[N * 2 + 10];
ll k1,k2,a[N + 10];
//i:k1 i + n:k2
int main() {
	n = read(), k1 = read(), k2 = read();
	T.insert(k1,0), T.insert(k2,0);
	for (int i = 1;i <= n;i ++ ) a[i] = read();
	sort(a + 1,a + n + 1);
	for (int i = 1;i <= n;i ++ ) T.insert(a[i],i);
	int v0 = 1,vn = 0;
	for (int i = 0;i < n;i ++ ) {
		int u = 0,s = 0,s2 = 0;
		for (int j = 59;~j;j -- ) {
			int t = a[i + 1] >> j & 1;
			int tk = k1 >> j & 1;
			if (tk == 1) u = T.ch[u][!t];
			else s = getmod(s + t1.query(T.ch[u][!t])), u = T.ch[u][t];
			if (!u) break;
		}
		if (u) s2 = getmod(s + t1.query(u));
		s = getmod(s + v0);
		u = 0;
		for (int j = 59;~j;j -- ) {
			int t = a[i + 1] >> j & 1;
			int tk = k2 >> j & 1;
			if (tk == 1) u = T.ch[u][!t];
			else s2 = getmod(s2 + t2.query(T.ch[u][!t])), u = T.ch[u][t];
			if (!u) break;
		}
		if (u) s2 = getmod(s2 + t2.query(u));
		s2 = getmod(s2 + vn);
		if (i != 0 && (a[i] ^ a[i + 1]) < k2) t1.tp(i + 1), v0 = 0;
		if (i != 0 && (a[i] ^ a[i + 1]) < k1) t2.tp(i + 1), vn = 0;
		if (i == 0) vn = 1;
		else {
			int x = T.to[i];
			while (x) {
				t1.modify(x,s2,i + 1);
				t2.modify(x,s,i + 1);
				x = T.fa[x];
			}
		}
	}
	int ans = 0;
	for (int i = 1;i <= n;i ++ ) ans = ((ll)ans + t1.query(T.to[i]) + t2.query(T.to[i])) % mod;
	cout << ans;
	return 0;
}
```

---


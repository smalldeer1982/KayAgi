# [湖北省选模拟 2024] 沉玉谷 / jade

## 题目背景

倘若天下无神，这里便是人的国度。

## 题目描述

你将主持一场祭祀，祭祀会使用到 $N$ 块排成一列的玉石，玉石从左至右依次编号为 $1,2,\cdots,N$。玉石 $i$ 的颜色为 $a_i$。

每一轮祭祀，你需要选择一段颜色相同的玉石 $a_l \sim a_r(1\le l \le r\le N\le 50)$，并将它们沉入水中。本次祭祀的仙力值 $K$ 将变为 $10000\cdot K+100\cdot l+r$，$K$ 的初始值为 $0$。

一段玉石被沉入水中后，右侧的玉石会向左移动。**同时，编号也会发生变化**，从左至右依次编号为 $1,2,\cdots$。例如，共有 $7$ 块玉石，颜色依次为 $1,1,2,2,2,3,2$。一开始，颜色为 $3$ 的玉石编号为 $6$，在 $3\sim 5$ 号玉石被沉入水中后，其编号将变为 $3$。

当所有玉石被沉入水中，祭祀完成，此时的仙力值即为本次祭祀的仙力值。请问祭祀完成后，一共可能得到多少种不同的仙力值？

由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的值。

## 说明/提示

### 样例解释 3

这里列举两种可能得到的仙力值和得到的方式：

1. $(1,\underline{2},1,2,1) \xrightarrow{K=202} (1,1,\underline{2},1) \xrightarrow{K=2\ 020\ 303} (\underline{1},\underline{1},1) \xrightarrow{K=20\ 203\ 030\ 102} (\underline{1}) \xrightarrow{K=202\ 030\ 301\ 020\ 101} ()$，得到的仙力值 $K$ 为 $202\ 030\ 301\ 020\ 101$。

2. $(1,2,\underline{1},2,1) \xrightarrow{K=303} (1,\underline{2},\underline{2},1) \xrightarrow{K=3\ 030\ 203} (\underline{1},\underline{1}) \xrightarrow{K=30\ 302\ 030\ 102} ()$，得到的仙力值 $K$ 为 $30\ 302\ 030\ 102$。


### 子任务

对于所有测试数据，保证 $1 \le N \le 50$，$1 \le a_i \le N$。

| 测试点编号 | $N\le$ | 特殊性质 |
| :--: | :--: | :--: |
| $1\sim 2$ | $18$ | 无 |
| $3$ | $50$ | A |
| $4$ | $50$ | B |
| $5\sim 8$ | $50$ | C,D |
| $9\sim 12$ | $50$ | C |
| $13\sim 16$ | $50$ | D |
| $17\sim 25$ | $50$ | 无 |

特殊性质 A：保证 $a_i=i$。

特殊性质 B：保证 $a_i=1$。

特殊性质 C：保证不存在 $p_1<p_2<p_3<p_4$，使得 $a_{p_1}=a_{p_3},a_{p_2}=a_{p_4},a_{p_1}\neq a_{p_2}$。

特殊性质 D：保证不存在 $p_1<p_2<p_3$，使得 $a_{p_1}=a_{p_2}=a_{p_3}$。

## 样例 #1

### 输入

```
1
1```

### 输出

```
1```

## 样例 #2

### 输入

```
3
3 3 1```

### 输出

```
8```

## 样例 #3

### 输入

```
5
1 2 1 2 1
```

### 输出

```
165```

## 样例 #4

### 输入

```
见选手目录下的 jade/jade4.in 与 jade/jade4.ans。```

### 输出

```
该样例满足测试点 5 ∼ 8 的限制。```

## 样例 #5

### 输入

```
见选手目录下的 jade/jade5.in 与 jade/jade5.ans。```

### 输出

```
该样例满足测试点 9 ∼ 12 的限制。```

## 样例 #6

### 输入

```
见选手目录下的 jade/jade6.in 与 jade/jade6.ans。```

### 输出

```
该样例满足测试点 13 ∼ 16 的限制。```

## 样例 #7

### 输入

```
见选手目录下的 jade/jade7.in 与 jade/jade7.ans。```

### 输出

```
```

# 题解

## 作者：cnyzz (赞：11)

好像比题解劣一个 $n$，但是也跑的很快。  

首先说明，问题等价于计算有多少种本质不同的方案使得整个序列被删完，证明省略。

考虑用区间的方式表述这些操作，具体的，忽略删除后的移位操作，将每次删除的左右段点视为一个区间，则一定会有：
- 区间的并是 $[1,n]$。
- 区间之间要么不交，要么包含。
- 对于每一个区间，没被其内部的区间包含的点一定会与该区间操作的颜色相同。

于是尝试 DP，令 $f_{l,r,k}$ 表示 $[l,r]$ 内的覆盖方案个数，要求包含 $[l,r]$，同时需要步数是 $k$ 步，$g_{l,r,k,v}$ 表示 $[l,r]$ 内的一组覆盖方案，不要求包含完 $[l,r]$，但是要求只能剩下至多一种数，且这种数是 $v$，同时需要步数是 $k$ 步。  
容易枚举最右侧的区间来转移，算贡献需要使用组合数，于是可以做到 $O(n^6)$。

```cpp
const int N=55;
int a[N];
modint f[N][N][N],g[N][N][N][N],C[N][N];
void solve() {
	int n=read();
	FOR(i,1,n) a[i]=read();
	C[0][0]=1;
	FOR(i,1,n) { C[i][0]=1; FOR(j,1,i) C[i][j]=C[i-1][j]+C[i-1][j-1]; }
	FOR(i,1,n) f[i][i][1]=1,g[i][i][1][0]=1,g[i][i][0][a[i]]=1,g[i][i-1][0][0]=1;
	FOR(len,2,n) FOR(l,1,n-len+1) {
		int r=l+len-1;
		FOR(i1,0,r-l) g[l][r][i1][a[l]]+=g[l+1][r][i1][0]+g[l+1][r][i1][a[l]];
		// FOR(i1,0,r-l) g[l][r][i1][a[r]]+=g[l][r-1][i1][0]+g[l][r-1][i1][a[r]];
		FOR(x,l,r-1) if(a[x]==a[l])
			FOR(i1,0,x-l+1) FOR(i2,0,r-x) FOR(k,0,n)
				g[l][r][i1+i2][k]+=f[l][x][i1]*g[x+1][r][i2][k]*C[i1+i2][i1];
		if(a[l]==a[r])
			FOR(i1,0,r-l-1) {
				modint tp=g[l+1][r-1][i1][a[l]]+g[l+1][r-1][i1][0];
				g[l][r][i1+1][0]+=tp,f[l][r][i1+1]+=tp;
			}
	}
	modint o=0;
	FOR(i,1,n) o+=g[1][n][i][0];
	cout<<o.x<<"\n";
}
```

---

## 作者：览遍千秋 (赞：7)

本题解为官方题解。


首先，如果两种操作方案在某次操作中选择的区间不同，那么两种操作方案产生的列表 $s$ 也不同。
		
考虑用区间 dp 维护删除子序列的过程：设 $dp_{l,r,k}$ 表示用 $k$ 次操作删除区间 $[l,r]$ 内所有元素的方案数。动态规划的转移方式有两种：
		
1. 若 $a_r = a_l$，则可将 $a_r$ 添加到删除 $a_l$ 的操作的子序列的末尾。总操作次数不变。
2. 拼接两个区间 $[l,mid]$ 和 $[mid+1,r]$ 的删除操作得到删除区间 $[l,r]$ 的操作方案，总操作次数等于两个区间的操作次数之和。

为计数，需要保证每个删除的方案被转移到的方式唯一。可以通过要求操作 $2$ 中右侧扩展的每个区间的最左侧元素和最右侧元素在同一次操作中被删除实现保证转移唯一（即右侧扩展的区间通过操作 $1$ 扩展得到）。由于在操作 $2$ 中除了 $a_l$ 所在的子序列必须最晚被操作外，其余操作的相对顺序没有要求，所以在做操作 $2$ 的转移时，需要乘 $C_{k_l+k_r-1}^{k_r}$ 的组合数因子，其中 $k_l$ 和 $k_r$ 分别为左侧区间和右侧区间删除需要的操作次数。
		
做完区间 dp 后，可以再做一个普通的 dp 记录删除前 $i$ 个数的方案数，得到最终答案。
		
时间复杂度瓶颈在于操作 $2$ 的转移，需要枚举每个区间，再枚举中间的分界 $mid$，再分别枚举左侧和右侧操作的次数，总时间复杂度为 $O(n^5)$。

---

## 作者：唐一文 (赞：5)

有点太难了。

一种操作序列唯一对应一种仙力值，因此求不同的仙力值的数量就是求删空整个序列的方案数。

我们想要求删空 $[1,n]$ 的方案数。看数据范围容易想到区间 DP。区间 DP 的状态设计还没什么头绪，那么就先设 $f(l,r)$ 表示删空 $[l,r]$ 的方案数吧。

考虑如何让它变成一个规模更小的问题，也就是思考按什么方式进行转移。

假如我们考察第一次操作，即枚举子区间 $[L,R]$ 被删除，则 $[1,L-1]$ 和 $[R+1,n]$ 会被合并起来。那么新的序列在原序列上就不是一段连续的区间，不好用状态去刻画。

那么我们考查最后一次操作。假如我们最后一次操作会从左到右删除在原序列上的下标为 $s_1,s_2,\dots,s_{m-1},s_m$ 的位置，则这些位置需要满足：
- $s_1<s_2<\cdots<s_{m-1}<s_m$
- $a_{s_1}=a_{s_2}=\cdots=a_{s_{m-1}}=a_{s_m}$

不妨令 $s_0=0,s_{m+1}=n+1$。我们想要保留这个子序列到最后一次操作。那么我们要让 $s_{i-1}$ 和 $s_i$ 相邻，也就是需要将 $[s_{i-1}+1,s_{i}-1]$ 内的数删空。这样就递归到了一个相同的问题：求删空 $[s_{i-1}+1,s_{i}-1]$ 的方案数。于是我们找到了一种 DP 的方式。

我们枚举的这个子序列 $s$ 将整个序列划分成了 $m+1$ 段区间，每段区间的操作方案都是独立的。因此我们还需要考虑合并操作序列的问题。这是比较套路的。

从合并两个操作序列入手。假设第一个操作序列长度为 $a$，第二个操作序列长度为 $b$，那么问题可以看作：$a$ 个白球，$b$ 个黑球形成的黑白序列数量。方案数为 $\binom{a+b}{b}$：从 $a+b$ 个位置中选 $b$ 个位置放黑球。

现在要合并 $m+1$ 个操作序列。对于前 $i$ 个序列，先把前 $i-1$ 个序列合并完，就只需要考虑合并两个序列的情况。

如果要计算方案数，还需要知道一个区间用了几次操作。于是 DP 的状态就确定了：$f(l,r,t)$ 表示用 $t$ 次操作删空 $[l,r]$ 的方案数。

枚举了 $(l,r,t)$，我们还需要枚举子序列 $s$。这需要我们再做一个 DP 来计算所有子序列产生的贡献。

从前往后考虑每个位置 $p$ 是否加入到子序列中。设 $g(p,u)$ 表示 $p$ 是当前子序列中的最后一个元素，且这个子序列划分出的区间一共用了 $u$ 次操作。

初值 $g(p,u)=f(l,p-1,u)$。转移需要枚举上一个在子序列中的元素 $q$，要求 $a_{q}=a_{p}$。那么新划分的区间为 $[q+1,p-1]$，枚举其用了 $v$ 次操作，转移为：
$$
g(p,u)\leftarrow g(p,u)+g(q,u-v)\times f(q+1,p-1,v)\times\binom{u}{v}
$$

然后用 $g(p,u)$ 来更新 $f(l,r,t)$。（$t-1$ 的原因是还要一次操作来删除最后的子序列）
$$
f(l,r,t)\leftarrow f(l,r,t)+g(p,u)\times f(p+1,r,(t-1)-u)\times\binom{t-1}{u}
$$

求一次 $g$ 的复杂度是 $O(n^4)$ 的。加上枚举 $(l,r,t)$ 的复杂度，对着这个直接写是 $O(n^7)$ 的。能拿 72pts，[code](https://www.luogu.com.cn/paste/gyj8ieau)。

注意到 $g(p,u)$ 的初始化只与 $l$ 有关，转移也不会受到 $(l,r,t)$ 的影响。那么改变一下区间 DP 的顺序：从大到小枚举 $l$，从小到大枚举 $r$。这种顺序也能满足：求一个区间的答案时，被它包含的区间已经处理完毕。

此时就可以做到一边转移 $g$ 一边转移 $f$，只需要跑 $n$ 次 $g$ 的 DP。复杂度 $O(n^5)$，常数很小。[code](https://www.luogu.com.cn/paste/k1ya87xu)。

---

## 作者：HHH6666666666 (赞：5)

区间 DP。

令 $f_{i,j,k}$ 表示用 $k$ 步删去区间 $[i,j]$ 内所有数的总方案数。设置第三维的原因是转移时需要根据步数进行插板。

区间 DP 的计数技巧：枚举某一端点的状态。在此题中，我们的思路就是对于一个区间枚举其左端点是如何被删除的。比如一个区间为 ${1,2,1,3,1}$，那么我们就分别统计：

1. 左端点单独被删除的方案数。
2. 左端点与第二个 $1$ 在同一步被删的方案数。
3. 左端点与第三个 $1$ 在同一步被删的方案数。
4. 左端点与后面两个 $1$ 在同一步被删的方案数。

不难发现这样统计是不重不漏的。但此时有两个问题：

1. 方案划分共有 $O(2^n)$ 种。
1. 每种方案具体如何计数？

作为后续思路的铺垫，先想一想在这样的划分下如何进行计数。假如当前区间为 $[l,r]$ 且让 $l,a, b(l<a<b)$ 三个位置同一步删除，这三个位置将区间划分成了三个部分：$[l+1,a-1],[a+1,b-1],[b+1,r]$。这三个数要一步删除的条件是前两个区间已删空。因此，假如这三个区间的步数分别为 $k_0,k_1,k_2$，则对答案 $f_{l,r,k_0+k_1+k_2+1}$ 的贡献为 $f_{l+1,a-1,k_0}\times f_{a+1,b-1,k_1}\times \binom{k_0+k_1}{k_0}\times f_{b+1,r,k_2}\times \binom{k_0+k_1+k_2+1}{k_2}$。注意删除左端点时的额外步数。

现在解决第一个问题，尝试优化方案划分方式。我们将其优化成：

1. 左端点单独被删的方案数。
1. 左端点与其后第 $t$ 个相同数同一步被删，并不与该数后的任何相同数同一步被删的方案数。

即改为枚举集合的右端点，将种类数变为 $O(n)$。尝试转移。发现这样的划分与上一种本质上没有区别，我们现在正在做的实际上是优化转移。

令 $g_{i,j,k}$ 表示用 $k$ 步删除了区间 $[i,j]$ 种所有值与左端点不同的数，保留左端点，剩下的数可删可不删的方案数。例如，区间为 ${1,1,2}$ 时 $g_{i,j,1}=1,g_{i,j,2}=2$。注意根据统计答案的方式，保留的是左端点的位置而不是数，我们不能把最左端的 $1$ 删去，即使右侧的 $1$ 会移过来。

但是这样并不符合刚刚讨论的划分方式。于是再加一条限制：左右端点颜色必须相同且必须保留右端点。这样就可以了。转移见代码。总复杂度为 $O(n^5)$。

```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

const int MAXN = 55;
const int MOD = 1e9 + 7;

int n;
int a[MAXN];
ll c[MAXN][MAXN];
ll f[MAXN][MAXN][MAXN], g[MAXN][MAXN][MAXN];

#define add(x, y) x += y, x %= MOD
#define mul(x, y) x *= y, x %= MOD
void solve(int l, int r) {
    if (l == r) { f[l][r][1] = 1, g[l][r][0] = 1; return; }
    if (a[l] == a[r]) {
        for (int j = r - 1; j >= l; --j)
            if (a[j] == a[l]) 
                for (int t = 0; t <= n; ++t)
                    for (int s = 0; s <= t; ++s)
                        add(g[l][r][t], g[l][j][s] * f[j + 1][r - 1][t - s] % MOD * c[t][s] % MOD);
    }
    for (int i = l; i <= r; ++i) {
        if (a[i] != a[l]) continue;
        for (int k = 0; k <= n; ++k)
            for (int t = 0; t < k; ++t)
                add(f[l][r][k], g[l][i][t] * f[i + 1][r][k - t - 1] % MOD * c[k][t + 1] % MOD);
    }
    return;
}

signed main() {
    ios:: sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    c[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        c[i][0] = 1;
        for (int j = 1; j <= i; ++j)
            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
    }
    for (int i = 0; i <= n; ++i) f[i + 1][i][0] = 1;
    for (int i = n; i; --i)
        for (int j = i; j <= n; ++j) solve(i, j);
    ll ans = 0;
    for (int i = 0; i <= n; ++i) add(ans, f[1][n][i]);
    cout << ans << endl;
    return 0;
}

```

---

## 作者：SnowTrace (赞：4)

考前写题解加 RP。

赛中又想复杂了，明明是简单 dp 模板但是我又写了一个巨大抽象的区间 dp，甚至不能叫区间 dp，而且复杂度也非常抽象。

---

首先我们先看看性质 D 怎么做。

考虑枚举最后一次操作，枚举删的数是哪个以及删的数都是哪些位置的（注意，这些数在最初序列中的位置不一定是相邻的，因为可以通过删掉两个不相邻的数中间的所有数让它们最终变得相邻），然后考虑这些被删掉的数的位置之间的区间，它们显然是互不干扰的。

举个例子：

$n = 7$，最后一步我们删除的元素位置集合是 $\{3,5\}$，从而我们划分出三个互不干扰的区间 $[1,2],[4,4],[6,7]$ 从而可以递归下去求解，注意到互不干扰区间的操作可以穿插进行，比如我们先在第一个区间做一步删除，然后又去第二个区间做一步删除，然后又会到第一个区间做一步删除，这样是可行的，所以答案还要乘上一个组合数。

具体的设 $dp_{l,r,k}$ 表示考虑区间为 $[l,r]$，做了 $k$ 步操作把区间全消除完的情况数，随后枚举删完区间的最后一次操作，然后乘上一些子区间的权值即可。

期望得分 $40$。

---

枚举颜色这步显然必不可少。

我们考虑优化上面直接枚举删的数的位置是哪些的这个过程。

发现这个东西相当于对集合 $S = \{i | a_i = c\}$ 的所有非空子集计算答案并求和，我们考虑在每次转移时都做一次 $dp$ 以达到快速转移的目的。

具体的，设 $f_{i,j}$ 表示考虑到 $S$ 中第 $i$ 个元素，此时前面不属于 $S$ 的所有数全部被删空且 $S_i$ 不被删，做了 $j$ 次操作的方案数。

为了方便我们也钦定 $r+1$ 和 $l-1$ 都在 $S$ 里且这两个位置不会被删。

显然 $S_i$ 没被删那么这里的独立区间右端点是 $S_i-1$，然后我们枚举左端点（也就是枚举 $S_i$ 前面的第一个也没被删的元素，左端点位置应该是这个元素位置加上一），从而可以进行转移。

首先我们要枚举区间，然后要枚举最后一次操作删除的元素的颜色，然后枚举 $f_{i,j}$，然后枚举左端点，最后枚举当前的这个独立区间里面被删完用了多少次操作即可转移。

时间复杂度是 $O(n^6)$ 的，因为极小的常数所以跑的比较快。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1000000007;
int qp(int p,int q){
	int ans = 1,pro = p;
	while(q){
		if(q&1)ans = ans*pro%mod;
		pro = pro*pro%mod;q>>=1;
	}return ans;
}int jie[1005],inv[1005],C[1005][1005];
int CC(int n,int m){
	return jie[n]*inv[m]%mod*inv[n-m]%mod;
}int a[505];int n;int vis[55][55],dp[55][55][55];
void solve(int l,int r){//写了非常奇怪的形式的记忆化搜索，其实直接枚举区间也可以的。 
	if(l>r){
		dp[l][r][0] = 1;vis[l][r] = 1;return;
	}if(l == r){
		dp[l][r][1] = 1;vis[l][r] = 1;return;
	}for(int col = 1;col<=n;col++){//枚举最后一次删的数的颜色。 
		int ok = 0;for(int i = l;i<=r;i++)if(a[i] == col)ok = 1;
		if(!ok)continue;
		vector<int>pos;pos.push_back(114514);// pos 数组即为 S。 
		pos.push_back(l-1);for(int i = l;i<=r;i++)if(a[i] == col)pos.push_back(i);pos.push_back(r+1);
		//用dp辅助转移
		vector<vector<int> >ddp;
		ddp.resize(r-l+10);
		for(int i =0;i<=r-l+5;i++)ddp[i].resize(r-l+10,0);
		ddp[1][0] = 1;
		for(int i = 2;i<pos.size();i++){
			for(int j = 1+(i == (int)pos.size()-1);j<i;j++){// i+(i == pos.size()-1) 意味着右端点是 r+1 时，左端点不能是 l-1 
				if(!vis[pos[j]+1][pos[i]-1])solve(pos[j]+1,pos[i]-1);
				int len = pos[i]-pos[j]-1,len1 = pos[j]-l+1;
				for(int k1 = 0;k1<=len1;k1++){//枚举前面做了多少次操作 
					for(int k2 =0;k2<=len;k2++){//枚举当前段做了多少次操作 
						ddp[i][k1+k2] += ddp[j][k1]*dp[pos[j]+1][pos[i]-1][k2]%mod*C[k1+k2][k1]%mod;
						ddp[i][k1+k2]%=mod;
					}
				}
			}
		}for(int k = 0;k<=r-l+1;k++)dp[l][r][k+1] = (dp[l][r][k+1]+ddp[pos.size()-1][k])%mod; 
		//注意到我们算的是独立区间内所有需要的操作数的总和但是没有算上最后一次的操作，所以要加一 
	}
	vis[l][r] = 1;
}
signed main(){
	jie[0] = inv[0] = 1;
	for(int i = 1;i<=1000;i++)jie[i] = jie[i-1]*i%mod,inv[i] = qp(jie[i],mod-2);
	for(int i = 0;i<=1000;i++){
		for(int j =0;j<=i;j++)C[i][j] = CC(i,j);//预处理组合数 
	}cin >> n;for(int i = 1;i<=n;i++)cin >> a[i];
	solve(1,n);
	int ans =0 ;
	for(int i = 0;i<=n;i++)ans =(ans+dp[1][n][i])%mod;
	cout << ans << endl; 
	return 0;
}
```

---

## 作者：jr_linys (赞：3)

[P10202 [湖北省选模拟 2024] 沉玉谷 / jade](https://www.luogu.com.cn/problem/P10202)

首先每次操作后玉石的编号不更新得到的结果与更新的结果是双射的。

定义 $g_{i,j,k}$ 为区间 $[i,j]$ 的玉石用 $k$ 步消掉，且最后一步为 $(i,j)$ 的答案。  
定义 $f_{i,j,B,k}$ 为区间 $[i,j]$ 的玉石中有颜色为 $B$ 的玉石没有消掉（$B=0$ 则全消），操作步数为 $k$ 的答案。

$g_{i,j,k}$ 的转移：  
枚举区间 $[x,y](i<x,y<j)$，使得 $[i,x-1],[y+1,j]$ 的玉石颜色都为 $B$，那么累加上 $f_{x,y,B,k-1}$。

$f_{i,j,0,k}$ 的转移：  
1. $f_{i,j,0,k}$ 包含了 $g_{i,j,k}$。
2. 枚举断点 $x$，把 $f_{i,x,0,l}$ 和 $g_{x+1,j,k-l}$ 乘起来，由于两者的操作顺序可以调换，乘上 $C(k,l)$。

$f_{i,j,B,k}(B\neq 0)$ 的转移：
1. 枚举断点 $x$，把 $f_{i,x,B,l}$ 和 $g_{x+1,j,k-l}$ 乘起来，乘上 $C(k,l)$。
2. 枚举区间 $[x,y](i<x,y<j)$，使得 $[x,y]$ 的玉石颜色都为 $B$，把 $f_{i,x-1,B,l}$ 和 $g_{y+1,j,k-l}$ 乘起来，乘上 $C(k,l)$。

时间按复杂度 $O(n^6)$，空间复杂度 $O(n^4)$。  
精细实现可以做到 $O(n^5)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T=int> T read(){
	char c;bool f=1;
	while(!isdigit(c=getchar())) if(c=='-') f=0;
	T x=c^'0';
	while(isdigit(c=getchar())) x=x*10+(c^'0');
	return f?x:-x;
}
template<class T>void Min(T &a,T b){if(b<a) a=b;}
template<class T>void Max(T &a,T b){if(b>a) a=b;}
const int N=50;
int n,a[N+5],b[N+5][N+5];
const ll mod=1000000007;
ll g[N+2][N+2][N+2],f[N+2][N+2][N+2][N+2],C[N+5][N+5];
template<class T> void Mo(T &x){
	while(x>=mod) x-=mod;
}
template<class T> T mo(T x){
	while(x>=mod) x-=mod;
	return x;
}

int main(){
	n=read();
	for(int i=1;i<=n;++i) a[i]=read();
	C[0][0]=1;
	for(int i=1;i<=n;++i){
		b[i][i]=a[i];
		for(int j=i+1;a[j]==a[j-1];++j) b[i][j]=a[i];
		C[i][0]=1;
		for(int j=1;j<=i;++j) C[i][j]=mo(C[i-1][j-1]+C[i-1][j]);
		f[i][i][0][1]=g[i][i][1]=1;
	}
	for(int len=2;len<=n;++len){
		for(int i=1,j=len;j<=n;++i,++j){
			auto G=g[i][j];auto F=f[i][j];
			if(b[i][j]) Mo(G[1]+=1);
			for(int x=i+1;x<j&&b[i][x-1];++x){
				int B=a[i];
				for(int y=j-1;y>=x&&B==b[y+1][j];--y){
					auto F=f[x][y];
					for(int k=1;k<=y-x+1;++k) Mo(G[k+1]+=mo(F[0][k]+F[B][k]));
				}
			}
			for(int k=1;k<=len;++k) Mo(F[0][k]+=G[k]);
			for(int x=i;x<j;++x){
				for(int k=1;k<=x-i+1;++k)
					for(int l=1;l<=j-x;++l){
						F[0][k+l]=(F[0][k+l]+f[i][x][0][k]*g[x+1][j][l]%mod*C[k+l][k])%mod;
						for(int y=1;y<=n;++y) F[y][k+l]=(F[y][k+l]+f[i][x][y][k]*g[x+1][j][l]%mod*C[k+l][k])%mod;
					}
			}
			for(int x=i+1;x<j;++x){
				int B=a[x];
				for(int y=x;y<j&&b[x][y];++y)
					for(int k=1;k<=x-i;++k)
						for(int l=1;l<=j-y;++l)
							F[B][k+l]=(F[B][k+l]+(f[i][x-1][0][k]+f[i][x-1][B][k])*g[y+1][j][l]%mod*C[k+l][k])%mod;
			}
		}
	}
	ll ans=0;
	for(int i=1;i<=n;++i) Mo(ans+=f[1][n][0][i]);
	printf("%lld",ans);
}
```

---

## 作者：Graphcity (赞：2)

设 $f_{l,r,k}$ 表示仅考虑区间 $[l,r]$，使用了 $k$ 次删除操作将它删空的方案数。考虑按照区间长度从小往大的顺序枚举 $l,r$ 并统一处理 $f_{l,r,*}$ 的值。

考虑最后一次进行操作的子序列为 $a_{p_1},a_{p_2},a_{p_3},\cdots,a_{p_k}$，那么最后会剩下 $[l,p_1),(p_1,p_2),(p_2,p_3),\cdots,(p_k,r]$ 这些区间。容易发现这些区间的操作是互不影响的，把它们的方案数乘起来，再用多重集组合数分配一下就行了。

具体来说，设 $g_{i,j}$ 表示当前子序列的最后一个数是 $i$，用了 $j$ 次操作的方案数，有转移 $g_{i,j+k}\gets g_{p,j}\times f_{p+1,i-1,k}\times \dfrac{1}{k!}\ (a_p=a_i)$。最后 $f_{l,r,k}$ 要乘上 $(k-1)!$ 的系数。

总时间复杂度 $O(n^6)$，可能可以通过更加精细的复杂度分析做到更低的复杂度上界。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=50,Mod=1e9+7;

inline int Pow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=1ll*res*x%Mod;
        x=1ll*x*x%Mod,y>>=1;
    }
    return res;
}

int n,a[Maxn+5],fac[Maxn+5],inv[Maxn+5];
int f[Maxn+5][Maxn+5][Maxn+5];

int main()
{
    cin>>n; For(i,1,n) cin>>a[i];
    For(i,0,n) f[i+1][i][0]=1;
    fac[0]=inv[0]=1;
    For(i,1,n) fac[i]=1ll*fac[i-1]*i%Mod;
    For(i,1,n) inv[i]=Pow(fac[i],Mod-2);
    For(len,1,n) For(l,1,n-len+1)
    {
        int r=l+len-1; static int g[Maxn+5][Maxn+5];
        memset(g,0,sizeof(g));
        For(i,l,r) For(j,1,len)
        {
            g[i][j]=1ll*f[l][i-1][j-1]*inv[j-1]%Mod;
            For(k,l,i-1) if(a[i]==a[k]) For(p,0,j)
                g[i][j]=(g[i][j]+1ll*g[k][p]*f[k+1][i-1][j-p]%Mod*inv[j-p])%Mod;
        }
        For(i,l,r) For(j,0,len) if(g[i][j]) For(k,0,len)
        {
            int res=1ll*g[i][j]*f[i+1][r][k]%Mod*inv[k]%Mod;
            f[l][r][j+k]=(f[l][r][j+k]+1ll*res*fac[j+k-1])%Mod;
        }
    }
    int ans=0; For(i,1,n) ans=(ans+f[1][n][i])%Mod;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：C1942huangjiaxu (赞：2)

题目要求的就是有多少种不同的删数方案。

考虑每个删数区间左右端点在**原序列**中的下标 $[l,r]$，可以发现每种删数方案的区间只有包含关系。

那么考虑对区间的包含关系建树，为了方便加入区间 $[0,n+1]$，因为要考虑区间的相对顺序，所以每种树对答案的贡献就是树的拓扑序数。

对于节点个数为 $n$ 的树 $T$，拓扑序数为 $\dfrac{n!}{\prod _{x\in T}sz_x}$，$sz_x$ 表示以 $x$ 根的子树大小。

于是就可以 DP 了，记 $f_{l,r,j}$ 表示以区间 $[l,r]$ 为根的大小为 $j$ 的子树对答案的贡献，需要满足 $a_l=a_r$。

还需要记录数组 $g$ 来转移，记 $g_{l,r,j}$ 表示以区间 $[l,*]$ 为根，考虑了 $[l+1,r]$ 中的子树，子树大小和为 $j$ 的贡献。

转移分 $2$ 类。

+ 若 $a_l=a_r$ 则可以将 $a_r$ 放入区间 $[l,*]$ 删除，$g_{l,r-1,j}\rightarrow g_{l,r,j}$。
+ 加入以区间 $[i,r]$ 为根的大小为 $k$ 的子树，$g_{l,i-1,j}\times f_{i,r,k}\rightarrow g_{l,r,j+k}$。

转移时间复杂度 $O(n^5)$。

求出 $g$ 后，有 $f_{l,r,j}=\dfrac{g_{l,r-1,j-1}}{j}$。

最后答案即为 $\sum_i f_{0,n+1,i}\times i!$。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55,P=1e9+7;
int n,a[N],f[N][N][N],fac[N],inv[N],g[N][N][N],ans;
inline void Add(int &x,int y){
	if((x+=y)>=P)x-=P;
}
int main(){
	scanf("%d",&n);
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<N;++i)fac[i]=1ll*fac[i-1]*i%P,inv[i]=1ll*(P-P/i)*inv[P%i]%P;
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);
	for(int i=0;i<=n+1;++i)f[i][i][1]=g[i][i][0]=1;
	for(int l=n;~l;--l)for(int r=l+1;r<=n+1;++r){
		int ln=r-l;
		for(int i=l+1;i<=r;++i)if(a[i]==a[r])
			for(int j=0;j<=ln;++j)if(g[l][i-1][j])
				for(int k=1;j+k<=ln;++k)if(f[i][r][k])Add(g[l][r][j+k],1ll*g[l][i-1][j]*f[i][r][k]%P);
		if(a[l]!=a[r])continue;
		for(int j=0;j<=ln;++j)Add(g[l][r][j],g[l][r-1][j]);
		for(int j=0;j<ln;++j)f[l][r][j+1]=1ll*inv[j+1]*g[l][r-1][j]%P;
	}
	for(int i=1;i<=n+1;++i)ans=(ans+1ll*f[0][n+1][i]*fac[i])%P;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：2020HZ06 (赞：2)

来一篇时间复杂度 $O(n^5)$ 的题解。

首先这个仙力值的种数相当于每次删去序列值相同的一段，删完后两边拼接，将其删空的方案数。

那么我们很容易想到区间 DP，设 $dp_{i,j,times}$ 表示区间 $[i,j]$ 删了 $times$ 次删完的方案数。为什么要记录删除次数？后面会讲。

如何转移？枚举区间之后，再枚举一个 $k$，表示最后一次删除的第一个数下标是 $k$。那么 $k$ 左边的数要删完，$k$ 右边的数要么删完，要么只剩下一些颜色为 $a_k$ 的玉石。于是我们还要设 $f_{i,j,times,col}$ 表示区间 $[i,j]$ 删了 $times$ 次使区间内只剩下颜色为 $col$ 的方案数。

接下来我们枚举 $ta$ 和 $tb$，即左右两边删除次数。那么一旦确定，两边的删除方案还有 $C_{ta+tb}^{ta}$ 种方法穿插起来。于是得到状态转移方程：

$f_{i,j,ta+tb,a[k]}=dp_{i,k-1,ta}\times(f_{k+1,j,tb,a[k]}+dp_{k+1,j,tb})\times C_{ta+tb}^{ta}$

从 $f$ 推回 $dp$：$dp_{i,j,k}=\sum_{c=1}^n f_{i,j,k-1,c}$

答案即为 $\sum_{i=1}^n dp_{1,n,i}$。

不要忘了杨辉三角预处理组合数。

分析时间复杂度：枚举区间 $O(n^2)$，枚举 $k$ $O(n)$，枚举 $ta$ 和 $tb$ $O(n^2)$，总共 $O(n^5)$，常数很小。

code:

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,a[55];
long long dp[55][55][55],f[55][55][55][55],C[55][55];
const long long mod=1e9+7;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),f[i][i][0][a[i]]=1,dp[i][i][1]=1;
	C[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=i;j++)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	for(int i=1;i<=n+1;i++) dp[i][i-1][0]=1;
	for(int l=2;l<=n;l++)
		for(int i=1;i+l-1<=n;i++)
		{
			int j=i+l-1;
			for(int k=i;k<=j;k++)
				for(int ta=0;ta<=k-i;ta++)
					for(int tb=0;tb<=j-k;tb++)
						(f[i][j][ta+tb][a[k]]+=dp[i][k-1][ta]*(f[k+1][j][tb][a[k]]+dp[k+1][j][tb])%mod*C[ta+tb][ta]%mod)%=mod;
			for(int k=1;k<=l;k++)
				for(int c=1;c<=n;c++)
					(dp[i][j][k]+=f[i][j][k-1][c])%=mod;//注意这里是k-1,因为从颜色相同还要再删一次才删完
		}
	long long ans=0;
	for(int i=1;i<=n;i++) (ans+=dp[1][n][i])%=mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：dspt (赞：2)

题意：给定一个数组 $a$，每次可以删除 $a$ 中连续一段 $[l,r]$，要求 $\forall l\leqslant i\leqslant r,a_i=a_l$，求有多少种删除方案？

一眼区间 DP，不知道为什么考场上为什么没推出来。

给出一个 $O(n^6)$ 做法，常数小，比较类似官方题解，但与其它 $O(n^6)$ 做法相比，不依赖于值域。

---

基本的，设 $f_{l,r,k}$ 表示区间 $[l,r]$ 删除 $k$ 次的方案数，但是这样无法转移。于是对状态添加限制：$f_{l,r,k}$ 表示 **$a_l=a_r$** 的区间 $[l,r]$ 删除 $k$ 次的方案数，**并且最后一次删除必须删除元素 $l$ 和元素 $r$**。

这样的话转移就好想了，因为有一个性质：对于一个上述区间而言，**除了最后一次删除之外，其它删除发生在其若干个不相交的子区间**，剩下的元素必定相等，并且会在最后一次删完。枚举子区间即可。

这里我们用 $g_{j,k}$ 辅助转移，意思是对于上述区间 $[l,r]$，当转移进行到 $j$ 的方案数，即除了最后一步删除之外，删除 $[l,j]$ 的方案数。

为了方便，我们一开始把最后一步当成只删除元素 $l$ 和元素 $r$，初始化是 $g_{l,1}=1$，最后 $f_{l,r,k}=g_{r-1,k}$。

考虑 $\forall l<j<r$，$j$ 作为子区间的右端点，枚举其左端点 $k+1$，另外再枚举区间 $[l,k]$ 的步数 $s1$，区间 $[k+1,j]$ 的步数 $s2$，可以得到转移 $g_{j,s1+s2}\leftarrow(g_{k,s1}+f_{k+1,j,s2})\binom{s1+s2-1}{s2}+g_{j,s1+s2}$。乘组合数的意思是，区间 $[l,k]$ 的 $s1$ 步和区间 $[k+1,j]$ 的 $s2$ 步顺序是任意的，要乘一个组合数。但是 $s1$ 中包含了最后一步，所以要减一。

当然还有一种情况， $\exist l<j<r,a_j=a_l$，则 $g_{j,k}\leftarrow g_{j-1,k}+g_{j,k}$。这是说这个元素可以留到最后一步删除，暂时不管。

在算出了 $f$ 之后，统计总答案是类似的，只不过没有最后一步的限制。

[代码](https://www.luogu.com.cn/paste/6zoec91z) 跑得很快，因为实际上这是个 $\sum_{l=1}^{n-1}\sum_{r=l+1}^n\sum_{j=l+1}^{r-1}\sum_{k=l}^{j-1}(k-l+1)(j-k)$ 的问题，当 $n=50$ 时，计算次数为 $22957480$，可以通过。

~~可以发现，这个在转移时可以使用 $\text{FFT}$，使时间复杂度降为 $O(n^5\log n)$，当然，这样只会让代码跑的更慢。~~

---

## 作者：Purslane (赞：1)

# Solution

提供一个非常容易想到，常数很小，复杂度为 $O(n^5)$ 的解法。我在十五分钟之内完成了此题。

> @Purslane：这道题应该是 $O(n^4)$ 之类的做法。

> @LitDarkness：你不觉得 $O(n^4)$ 很浪费吗。我写了 $O(n^6)$，常数为 $\dfrac{1}{7!}$，过了。

很显然本题就是求有多少种删数的方案能把所有数删光。设 $f_{l,r,k}$ 为将 $[l,r]$ 这段区间里面的数删光光，用了 $k$ 次删的操作（这是因为合并的时候要乘上 $\dbinom{k_1+k_2}{k_1}$ 来处理序列合并的答案），并且最后一次是删掉了（原来序列中的）$l$ 到 $r$ 中的所有颜色与 $a_l$、$a_r$ 相等的数的方案总数。$g_{l,r,k}$ 为把 $l$ 和 $r$ 中的数删光，用了 $k$ 步的方案数。

考虑用区间 DP 计算 $f_{l,r,k}$。这部分并不困难，扫描一遍 $l+1$ 到 $r$ 中的所有数，如果与 $a_{l}$ 相等就可以决定它是否最后一步删，而那些最后一步删掉的数之间夹的数都要用 $g_{l',r'}$ 加入答案。（具体的设 $tmp_{t,k}$ 为 $t$ 是最后一个决定最后删的数，用了 $k$ 步的方案数）

计算 $g_{l,r,k}$ 更加简单。枚举一个后缀用 $f_{t,r,k_1}$ 计算，另一个前缀用 $g_{l,t-1,k-k_1}$ 计算即可（注意乘上组合数）。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=55,MOD=1e9+7;
int n,C[MAXN][MAXN],a[MAXN],frac[MAXN],f[MAXN][MAXN][MAXN],g[MAXN][MAXN][MAXN];
int tmp[MAXN][MAXN];
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n; ffor(i,1,n) cin>>a[i];
	frac[0]=1; ffor(i,1,n) frac[i]=1ll*i*frac[i-1]%MOD;
	ffor(i,0,n) {C[i][0]=1;ffor(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;}
	ffor(i,1,n) f[i][i][1]=1,g[i][i][1]=1;
	ffor(len,2,n) for(int l=1,r=len;r<=n;l++,r++){
		if(a[l]==a[r]) {
			ffor(i,l,r) ffor(k,0,len-1) tmp[i][k]=0;
			tmp[l][0]=1;
			ffor(i,l+1,r) if(a[i]==a[l]) {
				ffor(lst,l,i-2) ffor(k1,0,len-1) ffor(k2,0,min(r-lst,len-1-k1)) tmp[i][k1+k2]=(tmp[i][k1+k2]+1ll*tmp[lst][k1]*g[lst+1][i-1][k2]%MOD*C[k1+k2][k1])%MOD;
				int lst=i-1; ffor(k1,0,len-1) tmp[i][k1]=(tmp[i][k1]+tmp[lst][k1])%MOD;
			}
			ffor(k,0,len-1) f[l][r][k+1]=tmp[r][k];
		}
		ffor(k,1,len) g[l][r][k]=(g[l][r][k]+f[l][r][k])%MOD;
		ffor(lst,l,r-1) ffor(k1,1,lst-l+1) ffor(k2,1,r-lst) g[l][r][k1+k2]=(g[l][r][k1+k2]+1ll*g[l][lst][k1]*C[k2+k1][k1]%MOD*f[lst+1][r][k2])%MOD;
	}
	int ans=0;
	ffor(i,1,n) ans=(ans+g[1][n][i])%MOD;
	cout<<ans;
	return 0;
}
```

AHOI 2024 RP++！

---

## 作者：pikiuk (赞：1)

不难发现 $K$ 其实没有特别有用。

考虑区间 dp，枚举区间最后一次删除的颜色并转移。

对于我们正在处理的区间 $[l,r]$，考虑所有颜色为 $c$ 的位置 $b_{1\sim m}$， 相当于从中选出若干个位置保留到最后，然后合并其余位置的方案数。注意我们必须钦定最后一次操作消除了若干数字，否则可能会算重。

现在考虑加入我们已经确定了某些位置保留到最后，我们应该如何合并其他区间的操作。考察两个区间答案的合并，显然我们需要知道他们的操作次数 $o_1,o_2$，因此把操作次数也计入状态，记 $f(l,r,o)$ 表示把这个区间全部消完，操作 $o$ 次的方案数，那么合并后的方案数是 $f(l_1,r_1,o_1)\times f(l_2,r_2,o_2)\times {o_1+o_2\choose o_1}$，对于多个区间显然顺序合并过去即可。

现在考虑如果钦定保留到最后的位置，记 $g(i,o)$ 表示最后一个保留位置是 $b_i$，当前未保留位置操作数是 $o$ 时的方案数，转移枚举上一个保留的位置转移即可。

这样我们有一个 $\operatorname{poly}(n)$ 的做法了。视实现精细程度复杂度为 $\mathcal{O}(n^5)\sim \mathcal{O}(n^7)$，不过区间 dp 常数相对较小，只要不要是太离谱的复杂度都能轻松通过。

```c++
int main () {
	cin >> n;
	for (int i = 1; i <= n; i ++)
		cin >> a[i];
		
	for (int i = 1; i <= n + 1; i ++) 
		f[i][i - 1][0] = 1;
	
	for (int i = 0; i <= n; i ++)
		C[i][0] = 1;
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= i; j ++)
			C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
			
	for (int l = n; l; l --) {
		for (int r = l; r <= n; r ++) {
			for (int c = 1; c <= n; c ++) {
				vec.clear ();
				vec.push_back (0);
				int m = 0, len = r - l + 1;
				for (int i = l; i <= r; i ++)
					if (a[i] == c)
						m ++,
						vec.push_back (i);
				if (! m)
					continue;
				m ++;
				vec.push_back (r + 1);
				
				for (int i = 1; i <= m; i ++)
					for (int j = 0; j <= len; j ++)
						g[i][j] = 0;
					
				for (int i = 1; i <= m; i ++) {
					if (i < m)
						for (int j = 0; j <= len; j ++)
							g[i][j] += f[l][vec[i] - 1][j];
						
					for (int v = 1; v < i; v ++) {
						for (int o1 = 0; o1 <= len; o1 ++) {
							if (! g[v][o1]) 
								continue;
							
							for (int o2 = 0; o1 + o2 <= len; o2 ++) 
								g[i][o1 + o2] += 
								g[v][o1] * f[vec[v] + 1][vec[i] - 1][o2] * C[o1 + o2][o1];
						}
					}
				}
				
				for (int i = 0; i < len; i ++)
					f[l][r][i + 1] += g[m][i];
			}
		}
	}
	
	Modint ans = 0;
	for (int i = 1; i <= n; i ++)
		ans += f[1][n][i];
	
	cout << ans.x;
}
```

---

## 作者：Fzrcy (赞：1)

首先，这个 $K$ 和操作序列是双射关系，所以我们考虑有多少方案将序列删空，显然操作之间只会有无交和包含两种关系。

设 $F_{i,j,k}$ 表示只用了恰好 $k$ 次操作就将 $[i,j]$ 恰好删完的方案数，满足 $i,j$ 是最后一次同时删除的，若 $a_{i}\ne a_{j}$ 则 $F_{i,j,k}=0$，否则转移就是一个 `dp`，求的是用 $k-1$ 次操作将 $[i+1,j-1]$ 中的一些数删除，使得剩下的数 $i$ 满足 $a_{i}=a_{l}=a_{r}$ 的方案数 $G_{l+1,r-1,k-1}$，求出 $F_{i,j,k}$ 后我们再做一个 `dp` 就可以求出答案了，三个 `dp` 的转移式比较简单，这里就不阐述了，如果不会可以看代码。

我们先枚举倒序 $l$，然后顺序枚举 $r$，就可以发现 $F_{l,r,k}$ 是可以和 $G_{l+1,r-1,k-1}$ 同时转移的。

时间复杂度 $O(n^5)$，但是这个东西和小 E 爱消除一样常数很小，所以可以通过。

```cpp
// Fzrcy
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

constexpr int N=62,mod=1e9+7;

inline void Mod(int&x){x=(x>=mod?x-mod:(x<0?x+mod:x));}
inline void suf(int&x,int y){Mod(x+=y);}
inline void sub(int&x,int y){Mod(x-=y);}
inline int Pow(int x,int y=mod-2){
    int ret=1;
    for(;y;y>>=1,x=(LL)x*x%mod)
        if(y&1)ret=(LL)ret*x%mod;
    return ret;
}

int n,a[N],F[N][N][N],jc[N],inv[N];
int G[N][N];

inline int C(int x,int y){
    return (x<0||y<0||x<y)?0:(LL)jc[x]*inv[y]%mod*inv[x-y]%mod;
}

int main(){
    cin>>n,jc[0]=jc[1]=inv[0]=inv[1]=1;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=2;i<=n;i++)jc[i]=(LL)jc[i-1]*i%mod;
    for(int i=2;i<=n;i++)inv[i]=(LL)inv[mod%i]*(mod-mod/i)%mod;
    for(int i=2;i<=n;i++)inv[i]=(LL)inv[i-1]*inv[i]%mod;
    for(int l=n;l;l--){
        memset(G[l],0,n+2<<2);G[l][0]=F[l][l][1]=1;
        for(int r=l+1;r<=n;r++){
            if(a[l]==a[r]){
                for(int i=1;i<=r-l+1;i++)F[l][r][i]=G[r-1][i-1];
            }
            if(a[r]==a[l])memcpy(G[r],G[r-1],n+2<<2);
            else          memset(G[r],0     ,n+2<<2);
            for(int j=r;j>l;j--)for(int y=1;y<=r-j+1;y++)if(F[j][r][y])
                for(int x=0;x<=j-l;x++)if(G[j-1][x])
                    Mod(G[r][x+y]+=(LL)G[j-1][x]*F[j][r][y]%mod*C(x+y,x)%mod);
        }
    }
    memset(G,0,sizeof G);G[0][0]=1;
    for(int i=1;i<=n;i++)for(int j=i;j;j--)for(int y=1;y<=i-j+1;y++)if(F[j][i][y])
        for(int x=0;x<=j-1;x++)Mod(G[i][x+y]+=(LL)G[j-1][x]*F[j][i][y]%mod*C(x+y,x)%mod);
    int ans=0;for(int i=1;i<=n;i++)Mod(ans+=(LL)G[n][i]);
    return cout<<ans<<endl,0;
}
```

---

## 作者：tobie (赞：0)

一道很好的区间 dp 题！

这题 $n=50$ 的数据范围，以及删除后区间会发生合并的操作过程，可以让我们想到使用区间 dp 解决问题。

考虑记录答案。令 $f_{l,r}$ 表示将区间 $[l,r]$ 删干净的方案数，那么答案即为 $f_{1,n}$。

考虑删除整个区间的过程。我们可以枚举最后一步删除了下标为 $p_1,p_2,\cdots,p_k$ 的数，那么整个区间被这些下标分成了若干子区间。那么我们的步骤必然是：删除区间 $[p_1+1,p_2-1],[p_2+1,p_3-1],\cdots,[p_{n-1}+1,p_n-1]$，最后删除 $p_1,p_2,\cdots,p_n$。

所以很自然的需要记录第二个 dp 数组。令 $g_{l,r}$ 表示将 $[l,r]$ 删到只剩下与 $a_l$ 值相同的元素，并且 $a_l$ 和 $a_r$ **必须保留**的方案数。所以 $g$ 数组在 $a_l\neq a_r$ 时没有意义，我们也不会用到此时的值。

现在让我来推导一下转移：

对于 $f$，因为 $a_l$ 不会被右边的数所影响，所以我们考虑 $a_l$ 是和那些东西一起删去的。考虑枚举上文中的 $p_k$ 的最大值。那么我们将操作分成两部分：删除 $[l,p_k]$ 直到只剩下 $p_1,p_2,\cdots,p_k$，以及删除 $[p_k,r]$ 中的所有元素。

令 $mid\leftarrow p_k$，于是有：

$$f_{l,r}\leftarrow g_{l,mid}\oplus f_{mid+1,r}$$

对于 $g$，我们考虑枚举 $p_1$ 的位置，那么下标在 $[l+1,p_1-1]$ 的所有数都应当先删除，然后将 $[p_1,r]$ 中所有数删到只剩下 $p_1,p_2,\cdots,p_k$。

令 $mid\leftarrow p_1$，于是有：

$$g_{l,r}\leftarrow f_{l+1,mid-1}\oplus g_{mid+1,r}$$

当然 $g_{l,r}$ 也可以通过一步删除 $p_1,p_2,\cdots,p_k$ 转移到 $f_{l,r}$。

这里的 $\oplus$ 表示合并答案，因为这里记录的 dp 内容不够完整，我将在后文补充。

我们发现，我们此时将操作分成了互不干扰的两个部分。现在我们要讲两个部分的操作合并到一起去。所以我们还需要记录当前状态下进行了多少次操作。

令 $f_{l,r,k}$ 表示用 $k$ 步将 $[l,r]$ 中的数全部删掉的方案数，$g_{l,r,k}$ 表示用 $k$ 步将 $[l,r]$ 中的数删到只剩下 $a_l,a_r$ 和其他数值等于 $a_l$ 的数的方案数。

整理转移，那么有：

$$f_{l,r,k}\leftarrow g_{l,mid,k-x-1}\times f_{mid+1,r,x}\times \binom{k}{x}$$
$$g_{l,r,k}\leftarrow f_{l+1,mid-1,x}\times g_{mid,r,k-x}\times \binom{k}{x}$$

以上能转移的前提是 $a_{mid}=a_l$。

还有 $g$ 单独转移到 $f$ 的方案：

$$f_{l,r,k}\leftarrow g_{l,r,k-1}$$

预处理组合数，然后根据式子进行 dp 即可。时间复杂度为 $O(n^5)$，但是常数非常小，可以通过。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define int long long
const int N=53,mod=1000000007;
int n,a[N];
int f[N][N][N],g[N][N][N];
inline void gx(int &x,int y){x+=y;while(x>=mod) x-=mod;}
int c[N][N],nxt[N];
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		f[i][i][1]=g[i][i][0]=1;
		f[i][i-1][0]=1;
	}
	for(int i=0;i<=n;i++)
	{
		c[i][0]=1;
		for(int j=1;j<=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}
	for(int r=1;r<=n;r++)
	for(int l=r-1;l>=1;l--)
	{
		if(a[l]==a[r])
		{
			for(int k=0;k<=n;k++)
			for(int mid=l+1;mid<=r;mid++)
			if(a[l]==a[mid])
			{
				for(int x=0;x<=k;x++)
				gx(g[l][r][k],f[l+1][mid-1][x]*g[mid][r][k-x]%mod*c[k][x]%mod);
			}
		}
		for(int k=0;k<=n;k++)
		for(int mid=l;mid<r;mid++)
		if(a[l]==a[mid])
		{
			for(int x=0;x<k;x++)
			gx(f[l][r][k],g[l][mid][k-x-1]*f[mid+1][r][x]%mod*c[k][x]%mod);
		}
		for(int k=1;k<=n;k++) gx(f[l][r][k],g[l][r][k-1]);
	}
	int ans=0;
	for(int i=0;i<=n;i++) gx(ans,f[1][n][i]);
	printf("%lld\n",ans);
}
```

---

## 作者：0x3F (赞：0)

~~省选考后写题解补 rp~~

~~怎么是原神题~~

记 $dp_{l,r,k}$ 表示将 $[l,r]$ 使用 $k$ 次操作删空，**且最后一次操作同时删了点** $l$ **和点** $r$ 的方案数。

显然 $dp_{i,i,1} = 1$，$l\ne r$ 时，必须 $a_l=a_r=A$，此时可以将 $[l+1,r-1]$ 拆成若干个子区间以及若干个 $A$。需要另开一个 $dp$ 数组，用组合数合并即可，转移是平凡的，此处不再赘述，具体见代码。

最后需要对所有的 $dp$ 再合并一次。

时间复杂度 $\mathcal{O}(n^6)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 100;
const int p = 1e9 + 7;
int n, a[_], c[_][_], dp[_][_][_], tmp[_][_], ans;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    c[0][0] = 1;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            c[i+1][j] = (c[i+1][j] + c[i][j]) % p;
            c[i+1][j+1] = (c[i+1][j+1] + c[i][j]) % p;
        }
    }
    for (int i = 1; i <= n; i++) {
        dp[i][i][1] = 1;
    }
    for (int d = 2; d <= n; d++) {
        for (int l = 1, r = d; r <= n; l++, r++) {
            if (a[l] == a[r]) {
                int A = a[l];
                int B = r - l;
                tmp[l][0] = 1;
                for (int i = l+1; i <= r-1; i++) {
                    if (a[i] == A) {
                        for (int t = 0; t <= B; t++) {
                            tmp[i][t] = tmp[i-1][t];
                        }
                    }
                    for (int j = l; j <= i-1; j++) {
                        for (int s = 0; s <= B; s++) {
                            for (int t = 0; t <= B - s; t++) {
                                tmp[i][s+t] = (tmp[i][s+t] + (long long) tmp[j][s] * dp[j+1][i][t] % p * c[s+t][s]) % p;
                            }
                        }
                    }
                }
                for (int t = 0; t <= B; t++) {
                    dp[l][r][t+1] = tmp[r-1][t];
                }
                for (int i = l; i <= r-1; i++) {
                    for (int t = 0; t <= B; t++) {
                        tmp[i][t] = 0;
                    }
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int t = 1; t <= i; t++) {
            tmp[i][t] = dp[1][i][t];
        }
        for (int j = 1; j < i; j++) {
            for (int s = 1; s <= j; s++) {
                for (int t = 1; t <= i-j; t++) {
                    tmp[i][s+t] = (tmp[i][s+t] + (long long) tmp[j][s] * dp[j+1][i][t] % p * c[s+t][s]) % p;
                }
            }
        }
    }
    for (int t = 1; t <= n; t++) {
        ans = (ans + tmp[n][t]) % p;
    }
    cout << ans << endl;
}

```

---

## 作者：Jsxts_ (赞：0)

首先发现只要方案不同，$K$ 就必然不同，证明考虑归纳法。然后套路地尝试区间 dp。

由于两个不交的区间中的操作之间没有限制，会乘一个组合数，所以设 $f_{l,r,k}$ 为 $k$ 次操作将区间 $[l,r]$ 全部消去的方案数。转移考虑分类讨论 $l,r$ 是否一起消除：

- 若 $l,r$ 不一起，则枚举分界点 $i$，由于避免算重需要钦定 $l,i$ 一起消去。

- 否则就是 $l,r$ 一起消去。发现两类转移都需要新定义 $g_{l,r,k}$ 表示区间中 $k$ 次操作后会保留 $a_l,a_r$ 以及区间中若干等于 $a_l$ 的数（前提为 $a_l=a_r$），这是因为若想让 $l,r$ 一起删，一定要把整个区间删到只剩等于 $a_l$ 的数。$g$ 的转移考虑枚举所有等于 $a_l$ 的数，钦定不删它，即：

$$g_{l,r,k}=\sum_{l=0}^k\sum_{i=l+1}^r[a_i=a_l]f_{l+1,i-1,l}\times g_{i,r,k-l}\times \dbinom{k}{l}$$

求出 $g$ 后，$f$ 的转移类似：
$$f_{l,r,k}=\sum_{l=1}^k\sum_{i=l}^r[a_i=a_l]g_{l,i,l-1}\times f_{i,r,k-l}\times \dbinom{k}{l}$$

由于转移复杂度为 $O(n^2)$，总时间复杂度为 $O(n^5)$。

---

## 作者：MaxBlazeResFire (赞：0)

听说省选前写题解可以增加 $\rm RP$！这可能也是退役前最后一篇发布出来的题解了。

考虑从最后一步倒着往前推，看作每次往一个缝隙内插入若干个相同的数。钦定第一步我们在空地放了 $i$ 个数 $c$，那么整个序列就被分为了 $i+1$ 个互不干扰的子问题，这启发我们进行区间 $\rm DP$：记 $f_{l,r,k}$ 表示用 $k$ 步上述过程还原原序列的 $[l,r]$ 的方案数，答案为 $f_{1,n,i}$ 求和。

注意到下一步我们的选择非常多，我们枚举下一步在区间的 $b-1$ 个位置放置某个颜色，贡献是 $\displaystyle f_{l,r,k+1}=k!\sum_{i_0=l-1,i_b=r+1,c_{i_1}=c_{i_2}=\cdots=c_{i_{b-1}},t_1+t_2+\cdots t_b=k}\prod_{j=1}^{b}\frac{f_{i_{j-1}+1,i_j-1,t_j}}{t_j!}$。

这个式子看起来很可以递推拆贡献。记 $g_{l,r,k,c}$ 表示上式在参数 $(l,r,k,c)$ 意义下除以 $k!$ 的值，考虑转移：

当 $[l,r]$ 不含颜色 $c$ 时，值为 $0$。

否则枚举区间内的某个位置 $p$ 的 $c$ 充当最后一个分割点，有

$\displaystyle g_{l,r,i+j,c}\leftarrow\sum_{i}(g_{l,p-1,i,c}+\frac{f_{l,p-1,i}}{i!})\times\sum_j\frac{f_{p+1,r,j,c}}{j!}$，卷积即可。

那么 $f_{l,r,k+1}=k!\times\displaystyle\sum_cg_{l,r,k,c}$。

考虑上述过程的复杂度。对于每个区间 $[l,r]$，我们在所有颜色的意义下会枚举 $r-l+1$ 个数，每次做一次卷积，于是总复杂度 $O(n^5)$，可以通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define MAXN 55
#define mod 1000000007

int n,a[MAXN],sc[MAXN][MAXN],f[MAXN][MAXN][MAXN],g[MAXN][MAXN][MAXN][MAXN];
int fac[MAXN],inv[MAXN],ifac[MAXN];

inline void chkadd( int &x , int k ){ x += k; if( x >= mod ) x -= mod; }

signed main(){
	fac[0] = inv[1] = ifac[0] = 1;
	for( int i = 1 ; i < MAXN ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;
	for( int i = 2 ; i < MAXN ; i ++ ) inv[i] = 1ll * ( mod - mod / i ) * inv[mod % i] % mod;
	for( int i = 1 ; i < MAXN ; i ++ ) ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;
	scanf("%d",&n);
	for( int i = 1 ; i <= n ; i ++ ) scanf("%d",&a[i]);
	for( int c = 1 ; c <= n ; c ++ )
		for( int i = 1 ; i <= n ; i ++ ) sc[c][i] = sc[c][i - 1] + ( a[i] == c );
	for( int i = 1 ; i <= n + 1 ; i ++ ) f[i][i - 1][0] = 1;
	for( int i = 1 ; i <= n ; i ++ ) f[i][i][1] = 1;
	for( int i = 1 ; i <= n ; i ++ ) g[i][i][0][a[i]] = 1;
	for( int len = 2 ; len <= n ; len ++ ){
		for( int l = 1 ; l + len - 1 <= n ; l ++ ){
			int r = l + len - 1;
			for( int p = l ; p <= r ; p ++ ){
				int c = a[p];
				for( int s1 = 0 ; s1 <= p - l ; s1 ++ ){
					for( int s2 = 0 ; s2 <= r - p ; s2 ++ ){
						int tmp = g[l][p - 1][s1][c];
						chkadd( tmp , 1ll * f[l][p - 1][s1] * ifac[s1] % mod );
						chkadd( g[l][r][s1 + s2][c] , 1ll * tmp * f[p + 1][r][s2] % mod * ifac[s2] % mod );
					}
				}
			}
			for( int c = 1 ; c <= n ; c ++ )
				for( int k = 0 ; k <= r - l + 1 ; k ++ )
					chkadd( f[l][r][k + 1] , 1ll * fac[k] * g[l][r][k][c] % mod );
		}
	}
	int res = 0;
	for( int i = 1 ; i <= n ; i ++ ) chkadd( res , f[1][n][i] );
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：QAQQWQ (赞：0)

快退役了，写点题解。

来个叉姐教的 $O(n^4)$ 做法。

首先一开始的 $O(n^5)$ 做法和其他题解差不多，首先我们设 $f_{l,r,k}$ 表示 $[l,r]$ 用 $k$ 次删掉，且位置 $l$ 是最后一次删的。那么我们每次就是找出最后一次删除的子序列转移，这部分 dp 可以参考代码。
```cpp
//O(n^5)
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sum=0,fh=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')fh=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		sum*=10;
		sum+=c-'0';
		c=getchar();
	}
	return sum*fh;
}
#define maxn 55
int n,a[maxn];
const int mod=1e9+7;
void add(int &x,int y){
	x+=y;if(x>=mod)x-=mod;return ;
}
int fp(int x,int y){
	int sum=1;
	while(y){
		if(y&1)sum=1ll*sum*x%mod;
		y>>=1;x=1ll*x*x%mod;
	}
	return sum;
}
int fac[maxn],inv[maxn];
void build(){
	fac[0]=1;for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[n]=fp(fac[n],mod-2);for(int i=n;i;i--)inv[i-1]=1ll*inv[i]*i%mod;
	return ;
}
int calc(int x,int y){
	if(x<y||y<0)return 0;
	return 1ll*fac[x]*inv[x-y]%mod*inv[y]%mod;
}
int f[maxn][maxn][maxn],g[maxn][maxn][maxn];
int main(){
//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);
	n=read();build();
	for(int i=1;i<=n;i++){
		a[i]=read();f[i][i-1][0]=1;
	}
	f[n+1][n][0]=1;
	for(int l=n;l;l--)for(int r=l;r<=n;r++){
		int len=r-l+1;
		for(int i=0;i<len;i++)add(g[l][r][i],f[l+1][r][i]);
		for(int i=l+1;i<=r;i++)if(a[i]==a[l])for(int j=0;j<i-l;j++)for(int k=0;k<=r-i;k++){
			add(g[l][r][j+k],1ll*f[l+1][i-1][j]*g[i][r][k]%mod*calc(j+k,k)%mod);
		}
		for(int i=l;i<=r;i++)for(int j=0;j<=i-l;j++)for(int k=0;k<=r-i;k++){
			add(f[l][r][j+k+1],1ll*f[l][i-1][j]*g[i][r][k]%mod*calc(j+k,k)%mod);
		} 
		//for(int i=0;i<=len;i++)cout<<i<<" "<<f[l][r][i]<<endl;
	}
	int ans=0;
	for(int i=0;i<=n;i++)add(ans,f[1][n][i]);
	printf("%d\n",ans);
//	  fclose(stdin);
//    fclose(stdout);
	return 0;
}

```
然后接下来我们优化一下，我们发现每个 $f_{l,r}$ 实际上是个 egf，然后我们 dp 过程就是把 egf 卷起来然后右移。然后我们维护点值，这样卷积就是 $O(n)$ 的，然后我们右移其实就是积分，我们全部加起来之后积一次就行，只有 $O(n^2)$ 个区间，每次积分 $O(n^2)$，这里也是 $O(n^4)$ 的，然后最后插值是 $O(n^2)$，总复杂度 $O(n^4)$。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sum=0,fh=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')fh=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		sum*=10;
		sum+=c-'0';
		c=getchar();
	}
	return sum*fh;
}
#define maxn 55
int n,a[maxn];
const int mod=1e9+7;
void add(int &x,int y){
	x+=y;if(x>=mod)x-=mod;return ;
}
int fp(int x,int y){
	int sum=1;
	while(y){
		if(y&1)sum=1ll*sum*x%mod;
		y>>=1;x=1ll*x*x%mod;
	}
	return sum;
}
int fac[maxn],inv[maxn];
void build(){
	fac[0]=1;for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[n]=fp(fac[n],mod-2);for(int i=n;i;i--)inv[i-1]=1ll*inv[i]*i%mod;
	return ;
}
int calc(int x,int y){
	if(x<y||y<0)return 0;
	return 1ll*fac[x]*inv[x-y]%mod*inv[y]%mod;
}
struct node{
	int d[maxn];
	node(){
		memset(d,0,sizeof(d));
	}
}f[maxn][maxn],g[maxn][maxn];
node nplus(node &a,node &b){
	node c;
	for(int i=0;i<=n;i++)add(c.d[i],a.d[i]),add(c.d[i],b.d[i]);
	return c;
}
node mul(node &a,node &b){
	node c;
	for(int i=0;i<=n;i++)c.d[i]=1ll*a.d[i]*b.d[i]%mod;
	return c;
}
node dtof(vector<int > &a){
	node b;
	for(int i=0;i<=n;i++)for(int j=a.size()-1;j>=0;j--){
		b.d[i]=1ll*b.d[i]*i%mod;
		add(b.d[i],a[j]);
	}
	return b;
}
vector<int > vmul(vector<int > &a,vector<int > &b){
	vector<int > c(a.size()+b.size()-1);
	for(int i=0;i<a.size();i++)for(int j=0;j<b.size();j++)add(c[i+j],1ll*a[i]*b[j]%mod);
	return c;
}
vector<int > vdiv(vector<int > a,vector<int > &b){//b.size()=2
	vector<int > c(a.size()-1);
	for(int i=a.size()-1;i;i--){
		c[i-1]=a[i];add(a[i-1],(mod-1ll*c[i-1]*b[0]%mod)%mod);
	}
	return c;
}
vector<int > ftod(node &a){
	vector<int > b(n+1);
	vector<int > stmul={1};
	for(int j=0;j<=n;j++){
		vector<int > qwq={mod-j,1};
		stmul=vmul(stmul,qwq);
	}
	for(int i=0;i<=n;i++){
		vector<int > nmul={mod-i,1};
		vector<int > dmul={a.d[i]};
		nmul=vdiv(stmul,nmul);
		for(int j=0;j<=n;j++)if(i!=j){
			dmul[0]=1ll*dmul[0]*fp(i-j+(i<j?mod:0),mod-2)%mod;
		}
		nmul=vmul(nmul,dmul);
		for(int j=0;j<min(n+1,(int)nmul.size());j++)add(b[j],nmul[j]);
	}
	return b;
}
node shift(node &a){
	vector<int > b=ftod(a);
	for(int i=n;i;i--){
		b[i]=1ll*b[i-1]*inv[i]%mod*fac[i-1]%mod;
	}
	b[0]=0;
	return dtof(b);
}
int main(){
//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);
	n=read();build();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=n+1;i++)for(int j=0;j<=n;j++)f[i][i-1].d[j]=1;
	for(int l=n;l;l--)for(int r=l;r<=n;r++){
		g[l][r]=f[l+1][r];
		for(int i=l+1;i<=r;i++)if(a[i]==a[l]){
			node qwq=mul(f[l+1][i-1],g[i][r]);
			g[l][r]=nplus(g[l][r],qwq);
		}
		for(int i=l;i<=r;i++){
			node qvq=mul(f[l][i-1],g[i][r]);
			f[l][r]=nplus(f[l][r],qvq);
			//vector<int > qwq=ftod(qvq);
			//for(int j=0;j<n;j++)add(qaq[j+1],1ll*qwq[j]*inv[j+1]%mod*fac[j]%mod);
		}
		vector<int > qaq(n+1);
		qaq=ftod(f[l][r]);
		for(int j=n;j;j--)qaq[j]=1ll*qaq[j-1]*inv[j]%mod*fac[j-1]%mod;
		qaq[0]=0;
		f[l][r]=dtof(qaq);
	}
	int ans=0;
	vector<int > qaq=ftod(f[1][n]);
	for(int i=0;i<=n;i++){
		add(ans,1ll*qaq[i]*fac[i]%mod);
	}
	printf("%d\n",ans);
//	  fclose(stdin);
//    fclose(stdout);
	return 0;
}

```
不过这东西因为常数太大甚至比 $O(n^6)$ 还慢，有点神秘。

---

## 作者：未来姚班zyl (赞：0)

## 题目大意

给定一个权值为颜色的序列，你每次可以选择一段颜色相同的区间并将其删除，删除后两边会接上。求将区间删空的操作序列总数。

## 题目分析

哇这题题解区居然都是 $O(n^6)$ 的做法，来个正经的 $O(n^5)$ 题解。

- 思考：状态设计

显然考虑区间 dp。设 $dp_{l,r}$ 表示把区间 $[l,r]$ 删空的方案数。然后枚举最后一次删除的最右边的点，发现转移时要考虑操作的顺序，所以多记录一维 $k$ 表示所用次数，转移时乘以一个组合数即可。
- 讨论：状态转移

最后一次删除可能是单独删除，也可能是和左边的最后一次操作合并。判断能不能合并只要多记录一维 $c$ 表示最后一次操作的颜色是 $c$ 即可。

枚举区间，枚举左右两边操作次数，枚举最后一次操作的点，然后 $O(1)$ 转移，总复杂度 $O(n^5)$。

似乎是道水紫？这通过率和难度可以评蓝了。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L(x) xd[x].l
#define R(x) xd[x].r
#define mid (l+r>>1)
#define lc(x) L(x),l,mid
#define rc(x) R(x),mid+1,r
#define OK Ll<=l&&r<=Rr
#define Root 1,1,n
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned int
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N =5e1+5,M=1e6+5,inf=(1LL<<31)-1,mod=1e9+7;
const ll llf=2e18;
inline void add(int &a,int b){((a+=b)>=mod) and (a-=mod);}
inline int Add(int a,int b){return add(a,b),a;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
inline void Mul(int &a,int b){a=mul(a,b);}
inline void red(int &a,int b){add(a,mod-b);}
inline int Red(int a,int b){return red(a,b),a;}
inline int qp(int a,int b){if(!b)return 1;int c=qp(a,b>>1);Mul(c,c);if(b&1)Mul(c,a);return c;}
inline int INV(int x){return qp(x,mod-2);}
int n,a[N],dp[N][N][N],g[N][N][N][N];
int fac[N],iv[N];
inline void prep(){
	fac[0]=1;rep(i,1,N-5)fac[i]=mul(fac[i-1],i);
	iv[N-5]=INV(fac[N-5]);
	per(i,N-6,0)iv[i]=mul(iv[i+1],i+1);
} 
inline int C(int x,int y){
	if(x<0||y<0||x<y)return 0;
	return mul(fac[x],mul(iv[y],iv[x-y]));
}
inline void Main(){
	n=read(),prep();
	repn(i)a[i]=read(),dp[i][i][1]=1,g[i][i][1][a[i]]=1,dp[i+1][i][0]=1;dp[1][0][0]=1;
	rep(len,2,n){
		rep(l,1,n-len+1){
			int r=l+len-1;
			rep(m,l,r){
				rep(kl,0,m-l)rep(kr,0,r-m){
					add(dp[l][r][kl+kr+1],mul(C(kl+kr,kl),mul(dp[l][m-1][kl],dp[m+1][r][kr])));
					add(g[l][r][kl+kr+1][a[m]],mul(C(kl+kr,kl),mul(dp[l][m-1][kl],dp[m+1][r][kr])));
					add(dp[l][r][kl+kr],mul(C(kl+kr-1,kl-1),mul(g[l][m-1][kl][a[m]],dp[m+1][r][kr])));
					add(g[l][r][kl+kr][a[m]],mul(C(kl+kr-1,kl-1),mul(g[l][m-1][kl][a[m]],dp[m+1][r][kr])));
				}
			}
		}
	}
	int ans=0;
	repn(i)add(ans,dp[1][n][i]);
	cout <<ans;
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}
```

---

## 作者：是青白呀 (赞：0)

区间删除操作，再加上较小的数据范围，考虑区间 dp。

首先不难发现不同的仙力值等价于不同的操作序列。

考虑一个区间的删除方式，可以由两个独立的区间合并而成，也可以是作为一个整体删除，即在一个内部的更小区间删完后，让外面套的一层相同颜色的石头合并到一起，来删除。

对于第一种，为了避免答案是由多个独立区间合并形成的，而算重，我们钦定最右边的那个区间一定是用整体删除的方式，不可分割。对于第二种，我们从 $[l,r-1]$ 转移到 $[l,r]$，也就是在最后一步多删除一个石头 $r$。能转移的条件是 $a_l=a_r$，并且在 $[l,r-1]$ 中，石头 $l$ 是最后一步被删除的。

不难发现两个独立区间合并时，左右删除的先后顺序不同也会导致最终操作序列不同。于是需要额外记录区间删完的操作次数。

综上，我们设 $f_{i,j,k}$ 表示用 $k$ 步删完区间 $[i,j]$ 的总方案数；$g_{i,j,k}$ 表示用 $k$ 步删完区间 $[i,j]$，且**最后一步才删除石头 $i$** 的总方案数；$h_{i,j,k}$ 表示用 $k$ 步删完区间 $[i,j]$，且**最后一步同时删除石头 $i$ 和石头 $j$** 的总方案数（也即该区间作为整体被删除的情况）。

则有如下几条转移：
1. 当 $a_i=a_j$ 时，$h_{i,j,k}\leftarrow g_{i,j-1,k}$，$f_{i,j,k}\leftarrow g_{i,j-1,k}$，$g_{i,j,k}\leftarrow g_{i,j-1,k}$，表示区间 $[i,j]$ 是整体被删除的。
2. 枚举分界点 $i\leq x<j$ 和左侧的操作次数 $y$，有 $f_{i,j,k}\leftarrow f_{i,x,y}\times h_{x+1,j,k-y}\times C_k^y$，$g_{i,j,k}\leftarrow g_{i,x,y}\times h_{x+1,j,k-y}\times C_{k-1}^{y-1}$。

转移瓶颈是第二类，需要枚举分界点和操作次数，复杂度 $O(n^5)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) ch[x][0]
#define rs(x) ch[x][1]
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define int long long
using namespace std;
typedef long long ll;
const int N=55,B=785,M=1005,mo=1e9+7;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,a[N],f[N][N][N],g[N][N][N],h[N][N][N];
int quick_power(int base,int x){
	int res=1;
	while(x){
		if(x&1)res*=base,res%=mo;
		base*=base,base%=mo;
		x>>=1;
	}
	return res;
}
int jc[N*2],qj[N*2];
int c(int x,int y){
	if(x<y)return 0;
	return jc[x]*qj[y]%mo*qj[x-y]%mo;
}
signed main(){
	read(n);
	jc[0]=qj[0]=1;
	rep(i,1,n)
	    jc[i]=jc[i-1]*i%mo,qj[i]=quick_power(jc[i],mo-2);
	rep(i,1,n)
	    read(a[i]);
	rep(i,1,n)
	    f[i][i][1]=g[i][i][1]=h[i][i][1]=1;
	rep(l,2,n){
		rep(i,1,n){
			int j=i+l-1;
			if(j>n)break;
			rep(k,1,l){//先处理h 
				if(a[i]!=a[j])break;
				h[i][j][k]=g[i][j-1][k]; 
			}
			rep(k,1,l){//处理f和g. 
				if(a[i]==a[j])f[i][j][k]+=g[i][j-1][k],g[i][j][k]+=g[i][j-1][k],f[i][j][k]%=mo,g[i][j][k]%=mo;
				rep(x,i,j-1){
					rep(y,1,min(x-i+1,k)){
						f[i][j][k]+=f[i][x][y]*h[x+1][j][k-y]%mo*c(k,y)%mo;
						g[i][j][k]+=g[i][x][y]*h[x+1][j][k-y]%mo*c(k-1,y-1)%mo;
						f[i][j][k]%=mo,g[i][j][k]%=mo;
					}
				}
			}
		}
	}
	int ans=0;
	rep(i,1,n)
	    ans+=f[1][n][i],ans%=mo;
	printf("%lld\n",ans);
	return 0;
}
```

---


# [COCI 2023/2024 #3] Restorani

## 题目背景

**译自 [COCI 2023/2024 Contest #3](https://hsin.hr/coci/archive/2023_2024) T4「[Restorani](https://hsin.hr/coci/archive/2023_2024/contest3_tasks.pdf)」**

## 题目描述

来到塞格德，Malnar 先生像通常一样，必须了解当地文化，品尝所有传统餐点、特色美食和当地饮料。

我们可以把塞格德想象成由 $n - 1$ 条双向道路连接的 $n$ 个景点，这些景点的编号从 $1$ 到 $n$。这样，每一对景点之间都有一条路径。令人惊奇的是，Malnar 先生走过每条道路正好需要一分钟。在景点行走的时间可以忽略不计。

Malnar 先生有一份他想去的 $m$ 家餐厅的清单。它由 $m$ 个正整数组成，其中第 $i$ 个数表示第 $i$ 个餐厅在哪个景点附近。

一个问题是 Malnar 先生在餐厅用餐后，必须马上去甜品店吃冰淇淋。另一个问题是，他拒绝两次光顾同一家甜品店。

幸运的是他有备而来，因为他知道 $m$ 家甜品店，这些甜品店的位置是由 $m$ 个正整数组成的列表，其中第 $i$ 个数字代表第 $i$ 家甜品店在这个景点附近。

Malnar 先生旅途劳累，不想走更多的路，因此他请你计算一下他需要走多少路，并提供去餐厅和甜品店的顺序，这样他就可以在没有帮助的情况下穿梭于餐厅和甜品店之间了。

Malnar 先生目前在景点 $1$，并且必须在最后回到景点 $1$。

## 说明/提示

### 样例解释 1

Malnar 先生首先走一分钟前往唯一在景点 $2$ 的餐厅，然后走两分钟到唯一在景点 $3$ 的甜品店，然后花一分钟走回景点 $1$。Malnar 先生总共会花 $1+2+1=4$ 分钟。

### 样例解释 2

Malnar 先生按如下顺序去餐厅和甜品店：在景点 $4$ 的餐厅（$2$ 分钟），在景点 $4$ 的甜品店（$0$ 分钟），在景点 $6$ 的餐厅（$3$ 分钟），在景点 $5$ 的甜品店（$1$ 分钟），在景点 $3$ 的餐厅（$1$ 分钟），在景点 $9$ 的甜品店（$3$ 分钟），在景点 $2$ 的餐厅（$3$ 分钟），在景点 $8$ 的甜品店（$3$ 分钟）。在景点 $8$ 处的甜品店吃完冰淇淋后，他返回景点 $1$（$2$ 分钟）。Malnar 先生一共走了 $2+0+3+1+1+3+3+3+2=18$ 分钟。

### 样例解释 3

Malnar 先生按如下顺序去餐厅和甜品店：在景点 $7$ 的餐厅（$6$ 分钟），在景点 $9$ 的甜品店（$2$ 分钟），在景点 $8$ 的餐厅（$1$ 分钟），在景点 $10$ 的甜品店（$2$ 分钟），在景点 $6$ 的餐厅（$4$ 分钟），在景点 $4$ 的甜品店（$2$ 分钟），在景点 $5$ 的餐厅（$1$ 分钟），在景点 $2$ 的甜品店（$3$ 分钟），在景点 $3$ 的餐厅（$1$ 分钟），在景点 $1$ 的甜品店（$2$ 分钟）。在吃完最后的冰淇淋后，他已经在景点 $1$ 所以他不会移动。Malnar 先生一共走了 $24$ 分钟。

### 子任务

| 子任务编号 |                附加限制                | 分值 |
| :--------: | :------------------------------------: | :--: |
|    $1$     |         $n\le 5\ 000,m\le 10$          | $18$ |
|    $2$     | $\forall i=1,\ldots,n-1,x_i=i,y_i=i+1$ | $18$ |
|    $3$     |             $n\le 5\ 000$              | $27$ |
|    $4$     |               无附加限制               | $37$ |

## 样例 #1

### 输入

```
3 1
2
3
1 2
1 3
```

### 输出

```
4
1 1
```

## 样例 #2

### 输入

```
9 4
2 3 4 6
4 5 8 9
1 2
1 3
3 4
3 5
5 6
1 7
7 8
7 9
```

### 输出

```
18
3 1 4 2 2 4 1 3
```

## 样例 #3

### 输入

```
10 5
3 5 6 7 8
1 2 4 9 10
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
```

### 输出

```
24
4 4 5 5 3 3 2 2 1 1
```

# 题解

## 作者：0x3F (赞：3)

神秘题。

首先如果把餐厅记作 $+1$，将甜品店记作 $-1$，那么如果一条边的某一侧的数字和为 $x(x>0)$，那么这条边至少需要经过 $2x$ 次。

若 $x=0$，如果这条边的两侧都有关键点（$1$ 号点或者餐厅或者甜品店），那么这条边仍然至少需要经过 $2$ 次。

否则，这条边可以不被经过。

但是怎么证明这样做是对的呢？我们考虑一个神秘的构造方法：如果一个点的子树里 $+$ 比 $-$ 多，那么可以把该子树内的 $+$ 和 $-$ 排列成若干个形如 $+-+\cdots+$ 的段（称为 $+$ 段），每段后留一个空位。

类似的，如果一个点的子树里 $-$ 比 $+$ 多，那么可以把该子树内的 $+$ 和 $-$ 排列成若干个形如 $-+-\cdots-$ 的段（称为 $-$ 段），每段前留一个空位。

如果 $+$ 和 $-$ 一样多，那么可以排成单独的一个形如 $+-+-\cdots+-$ 的段（称为 $0$ 段）。

对于子树信息的合并，我们只需要将 $+$ 段和 $-$ 段交错合并即可，而 $0$ 段可以和任意一个 $+,-,0$ 段合并，直至合并成若干 $+$ 段或若干 $-$ 段或一个 $0$ 段。

容易证明，使用这种方法可以使得每条边被经过的次数都取得最小值。

实现的时候，可以用链表套链表，外层链表维护一个子树包含哪些段，内层链表维护段内的 $+$ 点和 $-$ 点的编号。

时间复杂度为 $\mathcal{O}(n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 3e5 + 10;
int n, m, arr[_], brr[_], pos[_], neg[_], cntpos[_], cntneg[_], pnex[_], nnex[_], e, hd[_], nx[600010], to[600010], lef[_], rig[_], ans[_], bns[_];
int pcnt, ptop, pbin[_], pl[_], pr[_], pt[_];
int ncnt, ntop, nbin[_], nl[_], nr[_], nt[_];
long long len;
inline int pget(void) {
    if (ptop) {
        return pbin[ptop--];
    } else {
        return ++pcnt;
    }
}
inline void pdel(int x) {
    pbin[++ptop] = x;
}
inline int nget(void) {
    if (ntop) {
        return nbin[ntop--];
    } else {
        return ++ncnt;
    }
}
inline void ndel(int x) {
    nbin[++ntop] = x;
}
inline void pmerge(int& L, int& R, int l, int r) {
    if (l == 0 && r == 0) {
    } else if (L == 0 && R == 0) {
        L = l;
        R = r;
    } else {
        pt[R] = l;
        R = r;
    }
}
inline void nmerge(int& L, int& R, int l, int r) {
    if (l == 0 && r == 0) {
    } else if (L == 0 && R == 0) {
        L = l;
        R = r;
    } else {
        nt[R] = l;
        R = r;
    }
}
inline void mmerge(int& L, int& R, int l, int r) {
    if (l == 0 && r == 0) {
    } else if (L == 0 && R == 0) {
        L = l;
        R = r;
    } else {
        nnex[R] = l;
        R = r;
    }
}
inline void three_way_merge(int& L, int& R, int lp, int rp, int ln, int rn, int lm, int rm) {
    if (lp == 0 && rp == 0 && ln == 0 && rn == 0) {
        L = lm;
        R = rm;
    } else if (lp == 0 && rp == 0) {
        if (!(lm == 0 && rm == 0)) {
            nnex[nr[rn]] = lm;
            nr[rn] = rm;
        }
        L = ln;
        R = rn;
    } else if (ln == 0 && rn == 0) {
        if (!(lm == 0 && rm == 0)) {
            nnex[rm] = pl[rp];
            pl[rp] = lm;
        }
        L = lp;
        R = rp;
    } else {
        while (lp != -1 && ln != -1) {
            pnex[pr[lp]] = nl[ln];
            if (lm == 0 && rm == 0) {
                lm = pl[lp];
                rm = nr[ln];
            } else {
                nnex[rm] = pl[lp];
                rm = nr[ln];
            }
            pdel(lp);
            ndel(ln);
            lp = pt[lp];
            ln = nt[ln];
        }
        if (lp == -1 && ln == -1) {
            L = lm;
            R = rm;
        } else if (lp == -1) {
            nnex[nr[rn]] = lm;
            nr[rn] = rm;
            L = ln;
            R = rn;
        } else {
            nnex[rm] = pl[rp];
            pl[rp] = lm;
            L = lp;
            R = rp;
        }
    }
}
inline void add(int u, int v) {
    e++;
    nx[e] = hd[u];
    to[e] = v;
    hd[u] = e;
}
void dfs(int x, int f) {
    if (pos[x]) cntpos[x]++;
    if (neg[x]) cntneg[x]++;
    for (int i = hd[x]; i; i = nx[i]) {
        int y = to[i];
        if (y == f) continue;
        dfs(y, x);
        cntpos[x] += cntpos[y];
        cntneg[x] += cntneg[y];
        if (cntpos[y] > cntneg[y]) {
            len += cntpos[y] - cntneg[y];
        } else if (cntneg[y] > cntpos[y]) {
            len += cntneg[y] - cntpos[y];
        } else if (cntpos[y]) {
            len++;
        }
    }
}
void solve(int x, int f) {
    int lp = 0, rp = 0;
    int ln = 0, rn = 0;
    int lm = 0, rm = 0;
    if (pos[x]) {
        int a = pget();
        lp = rp = a;
        pl[a] = pos[x];
        pr[a] = pos[x];
        pt[a] = -1;
    }
    if (neg[x]) {
        int a = nget();
        ln = rn = a;
        nl[a] = neg[x];
        nr[a] = neg[x];
        nt[a] = -1;
    }
    for (int i = hd[x]; i; i = nx[i]) {
        int y = to[i];
        if (y == f) continue;
        solve(y, x);
        if (cntpos[y] > cntneg[y]) {
            pmerge(lp, rp, lef[y], rig[y]);
        } else if (cntpos[y] < cntneg[y]) {
            nmerge(ln, rn, lef[y], rig[y]);
        } else {
            mmerge(lm, rm, lef[y], rig[y]);
        }
    }
    three_way_merge(lef[x], rig[x], lp, rp, ln, rn, lm, rm);
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        cin >> arr[i];
        pos[arr[i]] = i;
    }
    for (int i = 1; i <= m; i++) {
        cin >> brr[i];
        neg[brr[i]] = i;
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    dfs(1, 0);
    (len <<= 1LL);
    solve(1, 0);
    ans[1] = lef[1];
    bns[1] = pnex[ans[1]];
    for (int i = 2; i <= m; i++) {
        ans[i] = nnex[bns[i-1]];
        bns[i] = pnex[ans[i]];
    }
    cout << len << endl;
    for (int i = 1; i <= m; i++) {
        cout << ans[i] << ' ' << bns[i];
        if (i != m) cout << ' ';
    }
    cout << endl;
    return 0;
}
```

---

## 作者：Add_Catalyst (赞：2)

# P10226 [COCI 2023/2024 #3] Restorani 题解

---

## 知识点

一拖拉库千奇百怪的做法，知识点涉及挺广。

---

## 题目分析

> 给定一棵树，求从节点 $1$ 开始，交替并不重复地遍历（路径可以重复）集合 $A$ 与 $B$ 中的点，并且最后回到节点 $1$ 的最小距离与方案。

---

## 做法分析

### Subtask 1

看到 $m \leq 10$，就应该知道只有两种可能：爆搜或状压 DP。但是由于是有两个大小为 $m$ 的集合，总大小为 $2m$，所以先排除爆搜，那么就是状压 DP 了。

可是有人会疑惑了：即使 $m \leq 10$，$n$ 可是 $ \leq 5 \times 10^3$，怎么状压呢？

其实只要关注两个集合中的点的距离即可，我们直接预处理出来，就可以不管 $n$​ 的范围了。

输出方案只要 DFS 或栈模拟一遍即可。

那么算法分为以下几个步骤：

1. 先跑一遍树的遍历，用各种求法求出集合 $A$ 与 $B$ 中点的距离。

2. 然后开始 DP：

   1. 设在 $A,B$ 被遍历过的点的状态为 $S,T$，且 $B$ 遍历的最后一个点位 $i$ 时的距离最小值为 $f_{i,S,T}$；

   2. 那么状态转移方程即为：
      $$
      f_{k,S|1<<j-1,T|1<<k-1} = \min {f_{i,S,T}+dis_{i,j}+dis_{j,k}}
      $$

   3. 在 DP 的同时，记一个 `std::pair` 数组 $pa_{i,S,T}$，分别保存这个状态下 $A,B$ 两个集合中各自被遍历的最后一个点，用于我们最后求方案。

3. 输出答案并倒序回溯输出方案。

这个算法时间复杂度十分奇怪，有人可能认为它的 DP 复杂度是 $O(m \cdot 2^{2m})$，但是其实只有 $O(\sum_{i=1}^{m}{\operatorname{C}_{m}^{i}}^2)$，因为两个集合是交替遍历的。

总时间复杂度 $O(m^2 \cdot \log_{2}{n}+\sum_{i=1}^{m}{\operatorname{C}_{m}^{i}}^2)$，空间复杂度 $O(m^2 + n \cdot \log_{2}{n} + m \cdot 2^{2m})$。

```cpp
namespace Subtask1{
	const int M1=15,S=(1<<10)+5,lV=20,lN=lV-1;
	int U,id,s,t,top;
	int dep[N],cnt[S],st[M1<<1];
	int d[M1][M1],fa[N][lV];
	int f[15][S][S];s
	vector<int> G[11];
	pair<int,int> pa[15][S][S];
	void dfs(int u){
		dep[u]=dep[fa[u][0]]+1;
		FOR(i,1,lN)fa[u][i]=fa[fa[u][i-1]][i-1];
		EDGE(g,i,u,v)if(v!=fa[u][0])fa[v][0]=u,dfs(v);
	}
	int Lca(int u,int v){
		if(dep[u]>dep[v])swap(u,v);
		DOR(i,lN,0)if((dep[v]-dep[u])&(1<<i))v=fa[v][i];
		if(u==v)return v;
		DOR(i,lN,0)if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];
		return fa[u][0];
	}
	int dis(int u,int v){
		return (dep[u]+dep[v])-(dep[Lca(u,v)]<<1);
	}
	signed Cmain(){
		s=t=U=(1<<m)-1,RCL(f,INF,f,1),ans=INF;
		FOR(i,1,U)cnt[i]=cnt[i>>1]+(i&1),G[cnt[i]].push_back(i);
		dfs(1);
		FOR(i,1,m)FOR(j,1,m)d[i][j]=dis(a[i],a[j+m]);
		FOR(i,1,m)FOR(j,1,m)
			f[j][1<<i-1][1<<j-1]=dis(1,a[i])+d[i][j],pa[j][1<<i-1][1<<j-1]={0,i};
		FOR(t,1,m-1)for(int S:G[t])for(int T:G[t])FOR(i,1,m)if(T&1<<i-1)
			FOR(j,1,m)if(!(S&(1<<j-1)))FOR(k,1,m)if(!(T&(1<<k-1))){
				int D=f[i][S][T]+d[j][i]+d[j][k];
				if(f[k][S|1<<j-1][T|1<<k-1]>D)
					f[k][S|1<<j-1][T|1<<k-1]=D,pa[k][S|1<<j-1][T|1<<k-1]={i,j};
			}
		FOR(i,1,m)if(f[i][U][U]+dis(1,a[i+m])<ans)id=i,ans=f[i][U][U]+dis(1,a[i+m]);
		cout<<ans<<endl;
		while(id){
			int id0=pa[id][s][t].first,s0=pa[id][s][t].second;
			st[++top]=id,st[++top]=pa[id][s][t].second,s^=1<<s0-1,t^=1<<id-1,id=id0;
		}
		while(top)cout<<st[top--]<<' ';
		cout<<endl;
		return 0;
	}
}
```

~~（这破部分分还真长……）~~

### Subtask 2

思考一下为什么我们只能想到用 DP？

其实是因为我们既要求**答案**，也要求**方案**，我们需要时刻把他们结合在一起，才能保证答案的正确性。

可是，我们能不能把他们分开呢？

答案是**可以**。分开后，就使得他们可以不相互受限，单个求解。

先考虑求答案：答案其实和方案并没有太大关系，因为一个答案可能有多种方案。我们来思考如何不顾方案求得答案。

我们以节点 $1$ 为根开始遍历这棵树，走到一棵子树的根，计算连接它与它的父节点的边会被走多少次。我们设这个子树中包含 $x$ 个 $A$ 集合的元素， $y$ 个 $B$ 集合中的元素，那么分类讨论：

1. $x=y$，我们可以直接在子树内把它们一通遍历完，易证这样肯定比再跑到子树外面给某个节点找配对快，所以只要进去一次并出来一次即可，贡献为 $2$。
2. $x<y$，我们在某一次进入时，同第一种情况把子树内能够直接配对的全部配对了，剩下的要出子树匹配，贡献为 $2(y-x)$。
3. $x>y$，同情况 2，贡献为 $2(x-y)$。

总结一下，我们设以 $i$ 为根的子树中有 $x_i$ 个 $A$ 集合的元素， $y_i$ 个 $B$ 集合中的元素，那么总共的贡献即 $\sum_{i=1}^n \max(1,|x_i-y_i|)$，也就是答案。

之后三个 Subtask 都可以用这种方法求得答案，那么现在只剩下方案了。

观察 Subtask 2，发现他变成了一个序列上的问题，那么我们隐约可以感觉到这个结论：能正着来的就直接正着来处理，不行的话就在折返的时候顺带解决，这样可以减少不必要的折回。

具体怎么做呢？

> 对于任意序列，设 $f_A ( i )$ 是长度为 $i$ 的序列前缀中来自集合 $A$ 的元素个数。同理，如果长度为 $k$ 的序列满足 $f_A ( k ) = f_B ( k )$ 且 $f_A(i) ≥ f_B(i),\forall i \le k$​ ，则该序列为正序列。现在，整个序列可以分为连续的正子序列和负子序列（举例说明最能让你理解这一点）。
>
> 观察。任何负序的逆序都是正序。
>
> 我们可以从序列的起点开始，将集合 $A$ 中最小的第 $i$ 个元素与集合 $B$ 中最小的第 $i$ 个元素配对，从而遍历一个正序列。

这段话来自官方题解，他告诉我们可以给它下一个更简洁的定义。

那么思路就有了：先遍历所有的正子序列，再倒序遍历所有负子序列，就可以求出方案。

时间复杂度 $O(n + m)$，空间复杂度 $O(n + m)$。

```cpp
namespace Subtask2{
	bool id[N];
	int cnt0[N][2];
	deque<int> dq[2];
	signed Cmain(){
		FOR(i,1,n)cnt0[i][0]=cnt0[i-1][0]+cnt[i][0],cnt0[i][1]=cnt0[i-1][1]+cnt[i][1];
		DOR(i,n,2)if(cnt[i][0]|cnt[i][1])
			ans+=max(1,abs(cnt[i][0]-cnt[i][1]))<<1,cnt[i-1][0]+=cnt[i][0],cnt[i-1][1]+=cnt[i][1];
		cout<<ans<<endl;
		id[1]=(cnt0[1][0]>=cnt0[1][1]);
		FOR(i,2,n){
			if(cnt0[i][0]==cnt0[i][1])id[i]=id[i-1];
			else id[i]=(cnt0[i][0]>cnt0[i][1]);
		}
		FOR(i,1,n)if(id[i]){
			if(~num[i][0])dq[0].push_back(num[i][0]);
			if(~num[i][1])dq[1].push_back(num[i][1]);
		}
		while(!dq[0].empty()&&!dq[1].empty())
			cout<<dq[0].front()<<" "<<dq[1].front()<<" ",dq[0].pop_front(),dq[1].pop_front();
		DOR(i,n,1)if(!id[i]){
			if(~num[i][0])dq[0].push_back(num[i][0]);
			if(~num[i][1])dq[1].push_back(num[i][1]);
		}
		while(!dq[0].empty()&&!dq[1].empty())
			cout<<dq[0].front()<<" "<<dq[1].front()<<" ",dq[0].pop_front(),dq[1].pop_front();
		cout<<endl;
		return 0;
	}
}
```

### Subtask 3

其实在有了求答案部分和 Subtask 2 的思路，我们就可以进一步拓展出一下思想：

我们设以 $i$ 为根的子树中有 $x_i$ 个 $A$ 集合的元素， $y_i$ 个 $B$ 集合中的元素。当 $x_i \geq y_i$ 时，称以 $i$ 为根的子树为“正子树”；当 $x_i \leq y_i$ 时，称以 $i$ 为根的子树为“负子树”。请注意，当 $x_i=y_i$ 时以 $i$ 为根的子树即是“正子树”也是“负子树”。

我们称目前最后访问的节点是 $A$ 集合中的元素为“处于过渡中”，否则就是“不在过渡中”。

假设我们当前处于 $i$ 点：

- 状态为“处于过渡中”：
  - $i \in B$，把 $i$ 加入答案，并在 $B$ 中去除该颜色。
  - $i \notin B$ 且以其子节点 $j$ 为根的子树为“负子树”，移动到 $j$。
- 状态为“不在过渡中”：
  - $i \in A$，把 $i$ 加入答案，并在 $A$ 中去除该颜色。
  - $i \notin A$ 且以其子节点 $j$ 为根的子树为“正子树”，移动到 $j$。
- 若不满足上述任一条件，移动到 $i$ 的父节点。当此时在 $1$ 节点，就结束了整个过程。

然后依照上述规则从 $1$ 开始爆搜即可（注意从集合中去除元素要对整个树进行更新以保证正确性）。

其实这个算法的中心思想也就是能在同一棵子树中配对的就在同一棵子树中配对。

然后有人可能会对这个算法的时间复杂度产生疑惑，认为它是依靠玄学，但其实并不是这样。

我们可以把操作概括为寻找与更新，单次寻找与更新都最多遍历这整棵树，也就是 $O(n)$，而总共有 $2m$ 个点，也就是 $2m$ 次这样的操作，总时间复杂度 $O(n \cdot m)$。

时间复杂度 $O(n \cdot m)$，空间复杂度 $O(n+m)$。

```cpp
namespace Subtask3{
	bool cur=1;
	int top;
	int fa[N],st[M];
	void dfs0(int u){
		EDGE(g,i,u,v)if(v!=fa[u]){
			fa[v]=u,dfs0(v);
			if(cnt[v][0]|cnt[v][1])
				ans+=max(1,abs(cnt[v][0]-cnt[v][1]))<<1,cnt[u][0]+=cnt[v][0],cnt[u][1]+=cnt[v][1];
		}
	}
	bool del(int u){
		if(~num[u][cur^1]){
			cur^=1,st[++top]=num[u][cur],num[u][cur]=-1;
			for(;u;u=fa[u])--cnt[u][cur];
			return 1;
		}return 0;
	}
	void dfs1(int u){
		while(del(u));
		for(bool flag=1;flag;){
			flag=0;
			EDGE(g,i,u,v){
				while(del(u));
				if(v!=fa[u]&&(cnt[v][0]|cnt[v][1])&&(cur&&cnt[v][0]>=cnt[v][1]||!cur&&cnt[v][0]<=cnt[v][1]))
					flag=1,dfs1(v);
			}
		}
	}
	signed Cmain(){
		dfs0(1),dfs1(1);
		cout<<ans<<endl;
		FOR(i,1,top)cout<<st[i]<<" ";
		cout<<endl;
		return 0;
	}
}
```

### Subtask 4

（啊哈哈，终于来到 ~~大家最爱的~~ 正解部分了。）

我们延续 Subtask 3 的思想，但是我们不能像他那样真正地一直模拟爆搜整个过程，于是我们就可以用一些东西把他们的顺序存下来，然后快速合并，最后得到答案。

用什么比较方便且快速？我们联想到合并（或者说叫“承接”更好）操作只有 $O(1)$ 的链表，用它来合并答案序列实在是再合适不过了。

但是呢，如何操作又成了另一个大问题。

为了遵循求得答案部分的思路，我们要保证：设以 $i$ 为根的子树中有 $x_i$ 个 $A$ 集合的元素， $y_i$ 个 $B$ 集合中的元素，当 $x_i \neq y_i$，在某一次进入时，把子树内能够直接配对的全部配对了。很多人都忘记了这一点，然后打出了错误代码。

设现在处于 $i$ 节点，子节点为 $j$，我们可以这样操作：

先遍历一遍所有子节点：

- $x_j=y_j$，直接加到链表的前面或后面，这样就可以避免一些多余贡献。
- $x_j>y_j$，加入集合 $A$。
- $x_j<y_j$，加入集合 $B$。

再遍历两集合 $A,B$：把两集合的元素不断合并再放到一个集合中。

然后就结束啦！！！

时间复杂度 $O(n+m)$，空间复杂度 $O(n+m)$。

```cpp
namespace Subtask4{
	int cur;
	int id[M],pre[M],nxt[M];
	list<int> st[N][2],res[M];//st[0/1]分别记以a/b结尾的链表的head节点
	void update(list<int> &A,list<int> &B,int cur){
		if(!A.empty())
			res[cur].splice(res[cur].end(),res[id[A.back()]]),A.back()=id[res[cur].back()]=cur;
		else 
			res[B.back()].splice(res[B.back()].end(),res[cur]),id[res[B.back()].back()]=B.back();
	}
	int dfs(int u,int fa){
		if(~num[u][0])st[u][0].push_back(num[u][0]);
		if(~num[u][1])st[u][1].push_back(num[u][1]+m);
		int cur=-1,nxt=-1;
		EDGE(g,i,u,v)if(v!=fa){
			int ret=dfs(v,u);
			bool ty=st[v][0].empty();
			if(cnt[v][0]|cnt[v][1])
				ans+=max(1,abs(cnt[v][0]-cnt[v][1]))<<1,cnt[u][0]+=cnt[v][0],cnt[u][1]+=cnt[v][1];
			if(~ret)~cur?res[cur].splice(res[cur].end(),res[ret]),id[res[cur].back()]=cur:cur=ret;
			st[u][ty].splice(st[u][ty].end(),st[v][ty]);
		}
		if(st[u][0].empty()&&st[u][1].empty())return cur;
		if(~cur)update(st[u][0],st[u][1],cur);
		while(!st[u][0].empty()&&!st[u][1].empty()){
			cur=st[u][0].back(),nxt=st[u][1].back(),st[u][0].pop_back(),st[u][1].pop_back();
			res[cur].splice(res[cur].end(),res[nxt]),id[res[cur].back()]=cur;
			if(st[u][0].empty()&&st[u][1].empty())return cur;
			update(st[u][0],st[u][1],cur);
		}return -1;
	}
	signed Cmain(){
		FOR(i,1,m<<1)id[i]=i,res[i].push_back(i);
		cur=dfs(1,0);
		cout<<ans<<endl;
		for(int x:res[cur])cout<<(x>m?x-m:x)<<" ";
		cout<<endl;
		return 0;
	}
}
```

---

## 提示&吐槽

这道题如果你在洛谷上得到了 622 分，千万不要沾沾自喜，请重新写程序，因为这道题的 Partically Accepted 有误。[（话说怎么现在都没修好啊？）]([Specail Judge 有误！！！ - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/discuss/811880))

---

## 链接

[COCI 官方题解中文翻译]([云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/n58pknrd))。

---


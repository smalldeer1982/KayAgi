# 在四方城外

## 题目背景

> 柳花、青山与月光。
>
> 诗中的酒香与诗外的酒香。
>
> 城中的天空与城外的天空。
>
> 一字一句，一笔一划，所知晓的，尚懵懂的。
>
> 	看呀看，学呀学，世界正如浊酒，滋味饮酌方知。

## 题目描述

定义字符串 $S$ 的**扩展**操作为：

- 求出 $S$ 的最长 $\text{border}$ $T$。

- $S'\leftarrow S+T$。

**注意，本题的 $\text{border}$ 指真 $\text{border}$（即字符串本身不计入 $\text{border}$）**。

设**扩展**操作的权值为**扩展**后字符串的长度 $|S'|$，请求出字符串 $S$ 第 $L$  次**扩展**到第 $R$ 次**扩展**的权值之和。

由于结果可能很大，请输出答案对 $998244353$ 取模的结果。

## 说明/提示

### 样例一解释

第 $1$ 次扩展操作：`ababcab[ab]`，权值为 $9$。

第 $2$ 次扩展操作：`ababcabab[abab]`，权值为 $13$。

第 $3$ 次扩展操作：`ababcabababab[abab]`，权值为 $17$。

权值之和为 $9+13+17=39$。

### 数据范围与约束

对于 $30\%$ 的数据，$1 \le |S| \le 100,1 \le L,R \le 10$。

对于 $60\%$ 的数据，$1 \le L,R \le 10^6$。

对于另外 $10\%$ 的数据，$\text{border}_{S}=|S|-1$。

对于 $100\%$ 的数据，$1 \le |S| \le 10^6,1 \le L \le R \le 10^9$，输入均为整数和小写字母。

## 样例 #1

### 输入

```
ababcab
1 3```

### 输出

```
39```

## 样例 #2

### 输入

```
aa
3 5```

### 输出

```
59```

# 题解

## 作者：dspt (赞：1)

[String Round](https://www.luogu.com.cn/contest/155684) Rank 6 纪念，场切了此题，写篇题解。

题目涉及了 Border，显然可以跟 KMP 结合，此外就是一些分类讨论了。

---

&nbsp;
## 性质
1. 长为 $n$ 的字符串 $S$ 为**周期字符串**等价于：存在长为 $k$ 的字符串 $T$，满足：$k|n$，$S$ 与 $\frac nk$ 个 $T$ 拼接而成的字符串等价。$k$ 被称为 $S$ 的一个**周期**。
2. 满足条件一的最小的 $k$ 被称为字符串 $S$ 的**最小周期**。
3. 若长为 $n$ 的字符串 $S$ 为周期字符串，记其**最长真 border** 的长为 $m$，若 $S$ 存在周期 $n-m$，则 $n-m$ 为 $S$ 的最小周期。

这些性质的证明可以见有关 KMP 的文章。

&nbsp;
## 分类讨论
我们使用 KMP 求出 $S$ 的最长真 border $T$，令 $n=|S|,k=|T|$，下面对 $T$ 进行分类讨论。

### 1：$T$ 为空
显然每次根本无法拓展，答案即为 $(R-L+1)n$。

### 2：$|T|$ 为 $S$ 的一个周期
假设已用 KMP 求出最长真 border $T$，判断 $k$ 是否为 $S$ 的周期是简单的。

由于拓展的字符串需要是真 border，每次拓展的长度即为 $|S'|-k$，拓展 $i$ 次后的 $|S'| $即为 $2^in-(2^i-1)k$，求和得 $(2^{R+1}-2^L)(n-k)+(r-l+1)k$，快速幂计算即可。

### 3：$T$ 不是周期字符串
注意：此情况的前提是不满足前两个情况。

显然每次拓展的长度均为 $k$，拓展 $L$ 次后长度为 $n+Lk$，$R$ 次后长度为 $n+Rk$，求和得 $(R-L+1)n+\frac{(L+R)(R-L+1)}2k$。

### 4：$T$ 是周期字符串
注意：此情况的前提是不满足前两个情况。

此情况的讨论应该是最容易漏掉的一种，$T$ 是否是周期字符串跟 $S$ 是否是周期字符串同理，容易判断。

设 $T$ 的最小周期为 $p$，且 $S[1:p]$ 在 $S$ 的前缀中重复了 $a$ 次，$S[1:p]$ 在 $S$ 的后缀中重复了 $b$ 次。

例如：$S=$`abababcabab`，则 $T=$`abab`，$p=2$，$S[1:p]=$`ab` 在 $S$ 的前缀中重复了 $a=3$ 次，在 $S$ 的后缀中重复了 $b=2$ 次。

这时的拓展情况应该是怎样的呢？不难发现每次向后拓展 $\min(a,b)$ 个 $S[1:p]$。

将 $\min$ 拆开助于思考：

1. 在 $a\geqslant b$ 时，每次拓展 $b$ 个 $S[1:p]$，同时 $b\leftarrow 2b$，这样的拓展不超过 $\log_2n$ 次，可以暴力枚举。
2. 在 $a<b$ 时，每次拓展 $a$ 个 $S[1:p]$，由于 $a$ 这个数值不会变，所以容易计算出。

具体地，计算第一部分暴力维护长度 $S'$ 和拓展次数 $i$，若 $i\in[L,R]$，将答案加上 $S'$。第二部分仅在 $R>i$ 时有贡献（$i$ 是完成第一部分的拓展次数），由于每次拓展长度固定，可以用情况三的式子计算。

容易发现第三种情况和这种情况类似，可以令 $a=b=1,p=k$，合并到一起计算。

---

## 作者：gdf_yhm (赞：1)

[P10272](https://www.luogu.com.cn/problem/P10272)

[P7525](https://www.luogu.com.cn/problem/P7525) 加强版。

### 思路

分类讨论。如果 $S$ 存在一个周期，设最小周期长为 $len$。那么第 $i$ 次操作是在 $i-1$长度上加 $(n-len)\times 2^i$。用字符串哈希判断是否存在长为 $i$ 的周期，只需要判断 $s[1,n-i]=s[i+1,n]$ 即可。$\sum_{i=l}^r 2^i=2^{r+1}-2^l$。快速幂处理。

如果 $S$ 不存在一个周期，找到真 border $T$，再找到 $T$ 的最小周期 $TT$，发现此时答案只取决于 $S$ 开头存在 $num$ 个连续的 $TT$。记 $cnt=\frac{\mid T\mid}{\mid TT\mid}$，发现每次操作答案增加 $\min(cnt\times 2^i,num)$ 个 $TT$。模拟前 $\log n$ 次操作后每次操作答案增加为定值，计算等差数列即可。

只需要字符串哈希，复杂度 $O(n)$。

### code

```cpp
int n,l,r;
inline int ksm(int a,int b=mod-2){
	int ans=1;b%=(mod-1);
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
char c[maxn];
int a[maxn],val[26],bas,pw[maxn];
int calc(int l,int r){
	return (a[r]-a[l-1]*pw[r-l+1]%mod+mod)%mod;
}
void work(){
	scanf("%s",c+1);n=strlen(c+1);l=read(),r=read();
	srand(time(0));bas=rand()*rand()%mod;
	for(int i=0;i<26;i++)val[i]=rand()*rand()%bas;
	for(int i=1;i<=n;i++)a[i]=(a[i-1]*bas+val[c[i]-'a'])%mod;
	pw[0]=1;for(int i=1;i<=n;i++)pw[i]=pw[i-1]*bas%mod;
	int pos=0;
	for(int i=1;i<=n/2;i++)if(n%i==0&&calc(1,n-i)==calc(i+1,n)){pos=i;break;}
//	cout<<pos<<"\n";
	if(pos){printf("%lld\n",(pos*(r-l+1)%mod+(n-pos)*(ksm(2,r+1)-ksm(2,l)+mod)%mod)%mod);return ;}
	for(int i=1;i<n;i++)if(calc(1,i)==calc(n-i+1,n))pos=i;
	if(!pos){printf("%lld\n",n*(r-l+1)%mod);return ;}
	int num=0,cnt=1;
	for(int i=1;i<=pos/2;i++)if(pos%i==0&&calc(1,pos-i)==calc(i+1,pos)){cnt=pos/i;pos=i;break;}
	for(int i=pos;i<=n;i+=pos){
		if(calc(1,pos)==calc(i-pos+1,i))num++;
		else break;
	}
	while(l&&cnt<=num){
		n+=cnt*pos%mod;n%=mod;
		l--,r--;cnt<<=1;
	}
	if(l){
		printf("%lld\n",(n*(r-l+1)%mod+(r+l)*(r-l+1)/2%mod*num%mod*pos%mod)%mod);
		return ;
	}
	int ans=n;
	while(r&&cnt<=num){
		n+=cnt*pos%mod;n%=mod;
		ans+=n;ans%=mod;r--;cnt<<=1;
	}
	printf("%lld\n",(ans+r*n%mod+r*(r+1)/2%mod*num%mod*pos%mod)%mod);
}
```

---

## 作者：MaxBlazeResFire (赞：0)

设原串为 $x+R+x$ 的形式，第一次扩展成 $x+R+x+x$。

Observation1：下一次扩展的长度介于 $[|x|,2|x|]$ 之间；

Observation2：下一次扩展的长度若为 $|x|+k$，则 $k$ 必然是 $|x|$ 最小整周期的倍数。

当原串有最小整周期时答案可以快速幂计算；当原串没有最小整周期时，先将其扩展一步，整个串一定可以写作以原串最长 $\rm border$ 的最小整周期为单位 $X$ 的串 $[aX]+R+[b_0X]+[b_1X]+...$，其中 $R$ 为任意杂串。

这个时候暴力模拟 $\rm log$ 次，求得若干个 $b$，当 $b>a$ 之后每次扩展的长度就是 $a$。

复杂度 $O(n+\log V)$。

```
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define MAXN 2000005
#define mod 998244353

char s[MAXN],t[MAXN];
int n,L,R,border[MAXN];

inline int fp( int x , int p ){ int res = 1; while( p ){ if( p & 1 ) res = res * x % mod; x = x * x % mod; p >>= 1; } return res; }
inline void chkadd( int &x , int k ){ x += k; if( x >= mod ) x -= mod; }
inline int reduce( int x ){ return x + ( x >> 31 & mod ); }

inline int getS( int R , int id ){
	int v1 = ( fp( 2 , R ) - 1 + mod ) % mod,v2 = ( fp( 2 , R ) - 2 - R + mod ) % mod;
	v1 = v1 * id % mod; return reduce( v1 - v2 );
}

inline int getV( int X , int P , int S ){
	if( !X ) return 0;
	int res = P + S; X --;
	while( S < P && X ) X --,S *= 2,chkadd( res , P + S );
	chkadd( res , X * ( X + 1 ) / 2 % mod * P % mod );
	chkadd( res , X * ( P + S ) % mod );
	return res;
}

signed main(){
	scanf("%s%lld%lld",s + 1,&L,&R); n = strlen( s + 1 );
	if( n == 1 ){ printf("%lld\n",( R - L + 1 ) % mod); return 0; }
	for( int i = 2 , j = 0 ; i <= n ; i ++ ){
		while( j && s[j + 1] != s[i] ) j = border[j];
		if( s[j + 1] == s[i] ) j ++; border[i] = j;
	}
	if( n % ( n - border[n] ) == 0 ){
		int k = n - border[n],c = n / k;
		int res = reduce( getS( R + 1 , c ) - getS( L , c ) );
		res = res * k % mod;
		printf("%lld\n",res);
		return 0;
	}
	else{
		for( int i = 1 ; i <= n ; i ++ ) t[i] = s[i];
		for( int i = 1 ; i <= border[n] ; i ++ ) t[n + i] = s[i];
		n = n + border[n];
		memset( border , 0 , sizeof( border ) );
		for( int i = 2 , j = 0 ; i <= n ; i ++ ){
			while( j && t[j + 1] != t[i] ) j = border[j];
			if( t[j + 1] == t[i] ) j ++; border[i] = j;
		}
		int A = 0;
		if( border[n] % ( border[n] - border[border[n]] ) == 0 ) A = border[n] - border[border[n]];
		else A = border[n];
		int P = 0,S = 0;
		for( P = 0 ; ; P ++ ){
			bool flag = 1;
			for( int i = 1 ; i <= A ; i ++ )
				if( t[P * A + i] != t[i] ){ flag = 0; break; }
			if( !flag ) break;
		}
		for( S = 0 ; ; S ++ ){
			bool flag = 1;
			for( int i = 1 ; i <= A ; i ++ )
				if( t[n - ( S + 1 ) * A + i] != t[i] ){ flag = 0; break; }
			if( !flag ) break;
		}
		int rem = n - ( P + S ) * A;
		int res1 = getV( R , P , S ) * A % mod;
		chkadd( res1 , R * rem % mod );
		int res2 = getV( L - 1 , P , S ) * A % mod;
		chkadd( res2 , ( L - 1 ) * rem % mod );
		printf("%lld\n",reduce( res1 - res2 ));
	}
	return 0;
}
```

---


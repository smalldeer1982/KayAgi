# [UESTCPC 2024] 一站到底

## 题目描述

假设你是电子科技大学的学生李华，在 4202 年的某一期一站到底中，你作为选手参加了节目的录制。不同于 2000 多年前的规则，节目中不会进行选手两两对战并抢答或轮答题目的环节，每位选手的答题以单人赛的方式进行，具体规则如下：

在选手的答题环节开始前，系统会从题库中抽取 $n$ 道题，每道题根据难度系数有 $a_i$ 的分值。主持人会在一开始公布所有的题目内容和分值，之后进入选手的答题环节。

为了增加节目的趣味性，在答题环节中，选手并不能随意选择作答题目的顺序。具体的，除 $1$ 号题目外所有题目**有且仅有**一道前置题目，在选手正确作答出某道题的前置题目后才可以进行作答这道题。节目组保证编号为 $i$ 的题目的前置题目编号必然小于 $i$。

此外，如果选手作答题目时提交了错误答案，那么其脚下的地板将立刻打开，选手掉落并结束作答，此前答对的所有题目的分值之和就是该选手的得分。如果选手答对了所有的题目，那么所有题目的分值之和就是该选手的得分。

现在你已经看完了所有的题目，根据你的知识储备，你判断出了每道题你做对的概率 $p_i$。你需要在最短时间内制定出最优的做题策略去最大化你的期望得分，请输出这个得分，~~并以参加这次节目的过程为主题写一篇不少于 120 词的英语作文~~。

## 说明/提示

在样例中，分值越高的题目你也有越大的概率答对，显然按照 $1,2,3,4,5$ 的顺序去答题最优。

## 样例 #1

### 输入

```
5
5 4 3 2 1
0.9 0.89 0.88 0.87 0.86
1 1 2 2```

### 输出

```
11.572522416```

# 题解

## 作者：OldDriverTree (赞：5)

套路题，学过这题的套路随便推一下就能切出来。

# 四倍经验
虽然不同，但是套路相同，学过套路能秒出来。

做完这四道题能对这个套路有更好的理解。

+ [P10332 [UESTCPC 2024] 一站到底](https://www.luogu.com.cn/problem/P10332)
+ [AT_agc023_f [AGC023F] 01 on Tree](https://www.luogu.com.cn/problem/AT_agc023_f)
+ [UVA1205 Color a Tree](https://www.luogu.com.cn/problem/UVA1205)
+ [P4437 [HNOI/AHOI2018] 排列](https://www.luogu.com.cn/problem/P4437)

# Solution

先考虑假如知道了两个连通块 $a$ 和 $b$ 内部的答题顺序，先答哪个连通块最优。

令 $a_p$ 为答完 $a$ 的概率，$a_{ans}$ 为答连通块 $a$ 的期望得分，$b_p$ 和 $b_{ans}$ 同理。

先答 $a$ 再答 $b$ 的期望得分为 $a_{ans}+a_pb_{ans}$。

先答 $b$ 再答 $a$ 的期望得分为 $b_{ans}+b_pa_{ans}$。

先答 $a$ 更优当且仅当 $a_{ans}+a_pb_{ans}>b_{ans}+b_pa_{ans}$，经过移项得 $\dfrac{a_p-1}{a_{ans}}>\dfrac{b_p-1}{b_{ans}}$。

考虑用堆维护每个连通块，一开始每个点为一个连通块，堆顶为 $\dfrac{p-1}{ans}$ 最大的。

每次把堆顶取出来，并把堆顶所在的连通块和堆顶的父亲所在的连通块合并起来，合并后的 $p$ 和 $ans$ 不难维护，最后的答案就为合并到只剩一个连通块时这个连通块的 $ans$，时间复杂度为 $O(n\log n)$。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
#define P pair<double,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
const int N=1e5+1;
int n,a[N],Fa[N],fa[N];
priority_queue<P> q;
double p[N],ans[N];
bool st[N];

int read() {
	int x=0; bool f=true; char c=0;
	while (!isdigit(c) ) f&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?x:-x;
}
int find(int x) {
	return fa[x]^x?fa[x]=find(fa[x]):x;
}
main()
{
	n=read();
	for (int i=1;i<=n;i++) a[i]=read(),fa[i]=i;
	for (int i=1;i<=n;i++) scanf("%lf",&p[i]),ans[i]=p[i]*a[i];
	for (int i=2;i<=n;i++) Fa[i]=read(),q.push({(p[i]-1)/ans[i],i});
	while (!q.empty() )
	{
		int u=q.top().second; q.pop();
		if (st[u]) continue; st[u]=true; int x=find(Fa[u]);
		fa[u]=x,ans[x]+=p[x]*ans[u],p[x]*=p[u];
		if (x^1) q.push({(p[x]-1)/ans[x],x});
	}
	printf("%.9lf",ans[1]);
	return 0;
}
```

---

## 作者：zhongpeilin (赞：4)

首先我们考虑没有先后顺序的要求，那么设按 $b$ 的顺序来做题，则期望得分为：$\sum_{i = 1}^{n} a_{b_{i}}\prod_{j = 1}^{i} p_{b_{i}}$，用邻项扰乱法，$b_{i}$ 题在 $b_{i + 1}$ 题前做当且仅当：
$$a_{b_{1}} \times p_{b_{1}} + \dots + a_{b_{i}} \times \prod_{j = 1}^{i} p_{b_{j}} + a_{b_{i + 1}} \times \prod_{j = 1}^{i + 1} p_{b_{j}} + \dots + a_{b_{n}} \times \prod_{j = 1}^{n} p_{b_{j}}$$
$$>$$
$$a_{b_{1}} \times p_{b_{1}} + \dots + a_{b_{i+1}} \times \prod_{j = 1}^{i-1} p_{b_{j}} \times p_{b_{i + 1}} + a_{b_{i}} \times \prod_{j = 1}^{i + 1} p_{b_{j}} + \dots + a_{b_{n}} \times \prod_{j = 1}^{n} p_{b_{j}}$$

由于无论是 $b_{i},b_{i+1}$ 还是 $b_{i+1},b_{i}$，$p_{b_{i}} \times p_{b_{i + 1}}$ 都是一定的，所以这两个式子的前 $i - 1$ 项和 $i + 1$ 后面的项都相同，所以只需比较 
$$a_{b_{i}} \times \prod_{j = 1}^{i} p_{b_{j}} + a_{b_{i + 1}} \times \prod_{j = 1}^{i + 1} p_{b_{j}}$$
与
$$a_{b_{i+1}} \times \prod_{j = 1}^{i-1} p_{b_{j}} \times p_{b_{i + 1}} + a_{b_{i}} \times \prod_{j = 1}^{i + 1} p_{b_{j}}$$
的大小即可。  
两边同除 $\prod_{j = 1}^{i - 1} p_{b_{j}}$，有：
$$a_{b_{i}} \times p_{b_{i}} + a_{b_{i + 1}} \times p_{b_{i}} \times p_{b_{i + 1}} > a_{b_{i + 1}} \times p_{b_{i + 1}} + a_{b_{i}} \times p_{b_{i}} \times p_{b_{i + 1}} $$
设 $V_{x} = a_{x} \times p_{x}$，将式子改为：
$$V_{b_{i}} + V_{b_{i + 1}} \times p_{b_{i}} > V_{b_{i + 1}} + V_{b_{i}} \times p_{b_{i + 1}} $$
移项有：
$$V_{b_{i}} \times (1 - p_{b_{i + 1}}) > V_{b_{i + 1}} \times (1 - p_{b_{i}})$$
$$\frac{V_{b_{i}}}{1 - p_{b_{i}}} > \frac{V_{b_{i + 1}}}{1 - p_{b_{i + 1}}}$$
所以无先后条件的问题就被我们解决了。  
那对于两个序列 $A$ 和 $B$，设 $V_{A}$ 为 $A$ 内部的最优期望，$V_{B}$ 为 $B$ 内部的最优期望，$P_{A}$ 为 $A$ 内部的概率乘积，$P_{B}$ 为 $B$ 内部的概率乘积，$A$ 应在 $B$ 前面时，也是与上面的判断条件一样。  

我们先建出个树，剩下的套路有个类似的题：AT_agc023_f。  
我们将每个点看成一个连通块，同时用优先队列维护 $\frac{V_{b_{i}}}{1 - p_{b_{i}}}$ 的最大值，每次将堆顶的连通块与这个连通块的最顶层的父亲的连通块合并，顺便更新一下父亲的 $\frac{V_{b_{i}}}{1 - p_{b_{i}}}$ 因为一旦他的父亲被做了那么下一个被做的一定是这个连通块，初始时就是将每个点看成一个连通块插入优先队列里即可。  
$O(n \log n)$。  

## CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
const long double eps = 1e-14;
struct node{
	int val; //权值 
	long double p, res; //当前连通块的概率乘积 最优策略下的得分 
}a[200005];
bool vis[100005];
int n;
int fa[100005], rl[100005];

int find(int x){
	if(rl[x] == x) return x;
	return rl[x] = find(rl[x]);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i].val;
	for(int i = 1; i <= n; i++) {
		cin >> a[i].p;
		a[i].res = a[i].p * a[i].val; //只有一个点 
	}
	for(int i = 2; i <= n; i++) cin >> fa[i];
	for(int i = 1; i <= n; i++) rl[i] = i; //并查集 
	
	priority_queue<pair<long double, int> > q;
	for(int i = 1; i <= n; i++){
		q.push({a[i].res / (1 - a[i].p), i});
	}
	while(!q.empty()){
		int x = q.top().second;
		q.pop();
		if(vis[x]) continue;
		vis[x] = 1;
		
		if(fa[x] == 0) continue;
		a[find(fa[x])].res += a[find(x)].res * a[find(fa[x])].p; //合并，因为在x的连通块时一定会将父亲的题都做完 
		a[find(fa[x])].p *= a[find(x)].p;
		rl[find(x)] = find(fa[x]);
		
		q.push({a[find(fa[x])].res / (1 - a[find(fa[x])].p), find(fa[x])}); //更新 
	}
	cout << fixed << setprecision(15) << a[find(1)].res << endl; //最后会变成一个连通块 
	return 0;
}
```

---

## 作者：断清秋 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10332)

感觉这个没有紫吧，比较套路。

首先肯定 $1$ 是必选的，然后选完 $1$ 就是一堆散开的连通块，考虑选择这些块的顺序。

假设有连通块 $i$ 和连通块 $j$，$ans_i$ 表示选择块 $i$ 的预期得分，$p_i$ 表示选择 $i$ 能做完的概率。

那么先选 $i$ 后选 $j$ 的预期得分就是 $ans_i+p_i \times ans_j$，同理先选 $j$ 后选 $i$ 的预期得分就是 $ans_j+p_j \times ans_i$。

因此先选 $i$ 更优的充要条件就是 $ans_i+p_i \times ans_j > ans_j+p_j \times ans_i$，移项即得 $\dfrac{ans_i}{1-p_i}>\dfrac{ans_j}{1-p_j}$。

因此只需要先选 $\dfrac{ans_i}{p_i}$ 大的连通块即可，考虑用一个堆维护所有块。

初始情况除了 $1$ 以外，其余每个点都是一个单独的连通块，$ans_i=p_ia_i$。然后每次取出堆顶进行更新。

考虑更新过程，每次取出堆顶的点（设为 $i$）之后，要向上更新。但是要保证每个点只被更新一遍，所以应该更新到它父亲的连通块里最靠上的点（设为 $x$），动态加一次边即可。然后把 $ans_x$ 和 $p_x$ 的值更新即可。

拿个优先队列模拟即可，最后答案就是 $ans_1$。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10332)

**题目大意**

> 给定一棵 $n$ 个点的树，每次可以将和已选集合相邻的一个点 $u$ 加入集合（初始必须先加入根），有 $1-p_u$ 的概率直接结束，否则会获得 $w_u$ 的收益并继续，最大化收益期望。
>
> 数据范围：$n\le 10^5$。

**思路分析**

给每个 $w$ 乘上 $p$，到期望收益就是 $\sum_{i=1}^nw_j\prod_{j<i}p_j$。

如果无拓扑序限制，这是经典的 Exchange Argument 问题，按 $w_i+p_iw_j<w_j+p_jw_i$ 排序，即按 $\dfrac{p_i-1}{w_i}<\dfrac{p_j-1}{w_j}$ 排序。

在树上就是树上 Exchange Argument，每次找到 $\dfrac{p_i-1}{w_i}$ 最小的点 $x$ 并和父亲 $y$ 合并，得到新的 $(p_x\times p_y,w_y+p_yw_x)$，用优先队列维护。

由于使用懒惰删除，因此要维护每个点当前的合并次数以判断是否是最新版本。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ld long double
using namespace std;
const int MAXN=1e5+5;
struct info {
	ld p,w; int id,s;
	friend bool operator <(const info &u,const info &v) {
		return u.w+u.p*v.w<v.w+v.p*u.w;
	}
}	a[MAXN];
int n,fa[MAXN],dsu[MAXN];
int find(int x) { return x^dsu[x]?dsu[x]=find(dsu[x]):x; }
signed main() {
	scanf("%d",&n);
	priority_queue <info> Q;
	for(int i=1;i<=n;++i) scanf("%Lf",&a[i].w),a[i].id=i,a[i].s=1;
	for(int i=1;i<=n;++i) scanf("%Lf",&a[i].p),a[i].w*=a[i].p;
	for(int i=2;i<=n;++i) scanf("%d",&fa[i]),Q.push(a[i]);
	iota(dsu+1,dsu+n+1,1);
	while(Q.size()) {
		auto z=Q.top(); int u=z.id; Q.pop();
		if(z.s!=a[u].s||dsu[u]!=u) continue;
		int x=find(fa[u]);
		a[x].w+=a[x].p*a[u].w,dsu[u]=x;
		a[x].p*=a[u].p,a[x].s+=a[u].s;
		if(x>1) Q.push(a[x]);
	}
	printf("%.18Lf\n",a[1].w);
	return 0;
}
```

---


# [PA 2024] Desant 3

## 题目背景

PA 2024 4B

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 4 [Desant 3](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/des/)，感谢 Macaronlin 提供翻译**

$n$ 个士兵，从左到右编号为 $1$ 到 $n$。每个士兵有两种状态：准备好和未准备好。现对这些士兵下发 $m$ 条命令，第 $i$ 条命令会使得在 $a_i$ 位置和 $b_i$ 位置的士兵交换位置，但只有 $a_i$ 位置的士兵准备好并且 $b_i$ 位置的士兵没有准备好时才能交换，否则无效。

问对于 $1$ 到 $n$ 中的每个整数 $k$，考虑 $\binom{n}{k}$ 种士兵的初始准备情况，其中有 $k$ 个士兵已准备好，求有多少种准备情况可以在进行 $m$ 条命令后，满足所有准备好的士兵形成一段连续区间。你只需要输出种类数对 $2$ 取模后的值即可。

## 说明/提示

如果一开始只有一名士兵准备好，那么无论如何操作，最终准备好的士兵一定形成一个连续的区间。

考虑这样一种情况：除了队列中的第二名士兵外，其他士兵都已准备好。第一个命令不会影响士兵的位置。第二道命令下达后，由于队列中的第一名士兵已准备好，而第二名士兵尚未准备好，他们将交换位置。第三道命令同样没有影响。由于现在队列中的第一名士兵还没有准备好，而队列中的第四名士兵已经准备好，因此他们不会因为最后一道命令而交换位置。最终只有排在第一位的士兵没有准备好。这是 $k = 3$ 时唯一一种满足条件的初始情况。

未取模前的答案为 $[4,0,1,1]$。

## 样例 #1

### 输入

```
4 4
4 1
1 2
3 4
1 4
```

### 输出

```
0 0 1 1
```

# 题解

## 作者：strcmp (赞：5)

$n \le 35$，而且操作和合法条件都极其难搞，存在多项式的可能性并不高。

我们先令 $a_x = 1$ 代表 $x$ 准备好了，$a_x = 0$ 代表 $x$ 没有准备好。

于是考虑暴力。你考虑最基础的暴力，就是直接枚举 $2^{n}$ 种状态直接判定，复杂度 $\Theta((n + m)2^n)$，肯定炸。

这个操作仍然太过于抽象，如果是正常的求，几乎想不到任何除了暴力外的做法。

但是题目为什么要对 $2$ 取模呢？对 $2$ 取模就是一个突破口，实际上，这类对 $2$ 取模的计数题，经常是寻找方案之间的对偶性。如果我们知道 $x$ 的后继有两种可能，而且递归计算这两种后继的贡献的奇偶性一定相等（我们并不关心它们具体贡献了什么，而只关心它们的奇偶性到底相等不相等），那么我们就可以直接忽略掉这两个后继，不计算它们。毕竟它们最后对答案（对 $2$ 取模）不存在任何影响。

这确实是一种套路，没见过的人感觉是挺难想到的，我自己还是在信友队的 NOIP 模拟赛上学到这个技巧的，比如 [AGC050F](https://www.luogu.com.cn/problem/AT_agc050_f) 就是这种类型的好题。

于是考虑二进制枚举应该没什么出路了，我们考虑搜索然后根据这个性质能不能剪枝。

刚开始，我们想象整个序列都是问号，然后我们要在问号里填数。

不妨枚举每个操作，保存我们当前存在的状态。

比如现在操作要我们交换 $x,\,y$。

- $x,\,y$ 都是问号，这其实比较棘手。分开讨论，如果 $x,\,y$ 状态不同，比如我们令 $a_x = 1,\,a_y = 0$ 或者 $a_x = 0,\,a_y = 1$。发现了吗？$a_x = 1,\,a_y = 0$ 经过操作一定会变换成 $a_x = 0,\,a_y = 1$。于是我们就有了两个后继状态，它们是一模一样的，对答案显然没影响（对 $2$ 取模），所以我们可以直接忽略掉它们状态不同的可能。于是只需要钦定 $a_x,\,a_y$ 状态相同即可，枚举 $0/1$ 状态暴搜即可。

- $x,\,y$ 中只有一个问号，如果问号在 $y$ 上且 $a_x = 0$ 就忽略掉，否则 $a_x = 1$。此时考虑 $a_y$ 的取值，要么为 $0$ 要么为 $1$。如果是 $0$ 那么就交换，否则不交换。看起来产生了两个新状态，但其实是一个。我们的后继状态一定 $a_x' = a_y,\,a_y' = 1$，于是只产生了唯一的后继状态，也就是 $x$ 位置是问号且 $a_y = 1$。问号在 $x$ 上是对称的，也只有一个后继状态。

- $x,\,y$ 中没有问号，那直接根据题意交换或不交换即可。

只有第一种情况会产生多个（两个）后继。这里每次决策会恰好去掉两个问号，问号总数是 $\Theta(n)$ 的，决策只有 $\lceil\frac{n}{2}\rceil$ 级别。也就是状态数是 $2^{\lceil\frac{n}{2}\rceil}$ 级别的。

哦还有一个小细节，就是我们经过 $m$ 个操作之后可能有状态仍然包含问号。

这如何统计答案？发现这些问号我们直接钦定区间里面是 $1$ 区间外面都是 $0$ 即可，对答案没影响。

时间复杂度 $\Theta((n^2 + m)\sqrt{2^n})$，最终状态数卡满大概 $2^{17}$ 级别，可以通过。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
using pli = pair<ll, int>;
using pq = priority_queue<int>;
using ld = double;
constexpr int maxn = 1e5 + 10, bs = 19260817, mod = 22309287;
constexpr ll inf = 1.1e14;
int a[42], n, m, l[maxn], r[maxn], ans[42];
void dfs(int u) {
    if (u == m + 1) {
        int cnt = 0; rep(i, 1, n) cnt += (a[i] == 1);
        for (int i = 1, v = 0; i <= n; i++, v = 0) rep(j, i, n) {
            if (a[j] == 0) break;
            if (((v += (a[j] == 1)) == cnt)) ans[j - i + 1] ^= 1;
        }
        return;
    }
    int x = l[u], y = r[u];
    if (a[x] == -1 && a[y] == -1) a[x] = a[y] = 0, dfs(u + 1), a[x] = a[y] = 1, dfs(u + 1), a[x] = a[y] = -1;
    else if (a[x] == -1 || a[y] == -1) {
        if (a[x] == 0 || a[y] == 1) dfs(u + 1);
        else if (a[x] == 1) { a[x] = -1, a[y] = 1; dfs(u + 1); a[x] = 1, a[y] = -1; }
        else if (a[y] == 0) { a[x] = 0, a[y] = -1; dfs(u + 1); a[x] = -1, a[y] = 0; }
    }
    else {
        if (a[x] == 1 && a[y] == 0) a[x] = 0, a[y] = 1, dfs(u + 1), a[x] = 1, a[y] = 0;
        else dfs(u + 1);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    rep(i, 1, m) scanf("%d%d", &l[i], &r[i]);
    memset(a, -1, sizeof(a)); dfs(1);
    rep(i, 1, n) printf("%d ", ans[i]);
    return 0;
}
```

---

## 作者：Loser_King (赞：3)

看到数据范围 $n\le 35$ 和抽象的题目，猜测不会是多项式时间复杂度。

注意到题目中答案输出是对二取模的，这启发我们考虑哪些时候经过一次交换会出现两个相同的序列，这样就不必算下去了。

我们每次等到需要执行一次操作的时候再去确定这两个人（$a_i$ 和 $b_i$）是否准备好，分两种情况：

- 两个人状态都没有确定。此时如果两个人准备状态不同，那么操作过后可能的两种情况相同（$a_i$ 准备好，$b_i$ 没准备好）。所以只需要确定这两个人状态相同的情况即可。

- 否则，注意到两个人准备状态相同时，交换不交换不影响最终状态序列，令这种情况下始终交换。那么我们只有一种情况不交换：两人状态均确定，且 $a_i$ 准备好，$b_i$ 没准备好。

统计答案时对所有包括全部确定没准备好的，不包括全部确定准备好的区间加上答案。

分析如此做的复杂度。每次遇到情况 1 时我们确定了两个人，使得可能的状态数翻倍。因此状态数为 $O(2^{n/2})$，总复杂度为 $O(2^{n/2}(n^2+m))$。

```cpp
// init s[i]=-1
void dfs(int x){
	if(x>m){
		int cnt=count(s+1,s+n+1,0);
		for(int i=1;i<=n;i++)
			for(int j=i,c=0;j<=n;j++)
				if(s[j]>0)break;
				else (c+=!s[j])==cnt&&ans[j-i+1]++;
		return;
	}
	int i=a[x],j=b[x];
	if(s[i]<0&&s[j]<0)
		s[i]=s[j]=0,dfs(x+1),s[i]=s[j]=1,dfs(x+1),s[i]=s[j]=-1;
	else{
		bool flg=!s[i]||(s[j]>0);
		if(flg)swap(s[i],s[j]);
		dfs(x+1);
		if(flg)swap(s[i],s[j]);
	}
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10360)

**题目大意**

> 给定长度为 $n$ 的 01 序列 $x_1\sim x_n$，$m$ 次操作 $(a_i,b_i)$，如果 $x_{a_i}=1,x_{b_i}=0$ 就交换 $x_{a_i}x_{b_i}$。
>
> 一个序列是好的当且仅当最终得到的 $x$ 序列中的 $1$ 恰好构成一个区间。
>
> 对每个 $k$ 求有多少恰有 $k$ 个 $1$ 的 01 序列是好的，答案对 $2$ 取模。
>
> 数据范围：$n\le 35,m\le 1000$。

**思路分析**

朴素暴力就是对于每个 $x$，从前往后维护这个序列，但这样显然不能通过。

考虑减小枚举量，对于一个不被任何操作覆盖的 $x_i$，我们不枚举其取值，只在某个 $a_j=i$ 的时候考虑。

对于一个操作 $a_i,b_i$，分类讨论两个元素当前的取值是否被确定：

- 如果 $x_{a_i},x_{b_i}$ 都被确定，那么直接模拟下一步操作。

- 如果 $x_{a_i},x_{b_i}$ 都未被确定，那么我们发现如果 $x_{a_i}\ne x_{b_i}$，那么转移到下一步操作的时候两个序列会得到相同的结果，因此这种序列对答案的贡献一定是偶数，可以忽略掉。

  因此只要枚举 $x_{a_i}=x_{b_i}=0/1$ 两种情况。

- 如果仅有 $x_{a_i}$ 被确定（另一种对称），如果 $x_{a_i}=0$，说明这次操作无效，可以跳过，否则我们发现：

  - 如果 $x_{b_i}=1$，那么交换后 $x'_{a_i}=x'_{b_i}=1$。
  - 如果 $x_{b_i}=0$，那么交换后 $x'_{a_i}=0,x'_{b_i}=1$。

  因此此时 $x_{b_i}$ 恒为 $1$，$x_{a_i}$ 任取 $0/1$，那么直接把 $x_{b_i}$ 设为已知且值为 $1$，$x_{a_i}$ 设为未知即可。

容易发现只有第二种情况时状态数翻倍，且此时一定消耗两个未知元素，其他操作不消耗未知元素，那么状态总数就是 $\mathcal O(2^{n/2})$ 的。

时间复杂度 $\mathcal O(2^{n/2}(m+n^2))$。

如果 $x_{b_i}=0$，那么交换后 $x'_{a_i}=x'_{b_i}=0$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define q(s,i) (s>>i&1)
#define d(i) (1ll<<i)
using namespace std;
const int MAXN=1005;
int n,m,a[MAXN],b[MAXN];
bool ans[40];
void dfs(int i,ll vis,ll col) {
	if(i==m+1) {
		for(int l=0;l<n;++l) {
			int p=n;
			for(int r=l;r<n;++r) if(q(vis,r)&&!q(col,r)) {
				p=r; break;
			}
			for(int r=n-1;r>=l;--r) {
				if(r<p) ans[r-l+1]^=1;
				if(q(vis,r)&&q(col,r)) break;
			}
			if(q(vis,l)&&q(col,l)) break;
		}
		return ;
	}
	if(q(vis,a[i])&&q(vis,b[i])) {
		if(q(col,a[i])&&!q(col,b[i])) col^=d(a[i])^d(b[i]);
		dfs(i+1,vis,col);
	} else if(q(vis,a[i])) {
		if(!q(col,a[i])) dfs(i+1,vis,col); 
		else {
			vis^=d(a[i])^d(b[i]);
			col&=~d(a[i]);
			dfs(i+1,vis,col|d(b[i]));
		}
	} else if(q(vis,b[i])) {
		if(q(col,b[i])) dfs(i+1,vis,col);
		else {
			vis^=d(a[i])^d(b[i]);
			col&=~d(b[i]);
			dfs(i+1,vis,col&(~d(a[i])));
		}
	} else {
		vis|=d(a[i])^d(b[i]);
		dfs(i+1,vis,col);
		dfs(i+1,vis,col|d(a[i])|d(b[i]));
	}
}
signed main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) scanf("%d%d",&a[i],&b[i]),--a[i],--b[i];
	dfs(1,0,0);
	for(int i=1;i<=n;++i) printf("%d ",ans[i]); puts("");
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

这是很久之前 NOI 模拟赛的 T1，当时真的一点也不会啊。~~现在也一点都不会。~~

首先，注意到 $n$ 很小，按照 PA 名叫 Desant 的题的脾气肯定不是啥多项式复杂度，所以考虑直接搜。而且看到模 $2$，容易想到某些重复情况可以被抵消掉从而不产生贡献。

对于每个位置，只有 $1$（已经准备好）、$0$（还未准备好）、$-1$（未确定）。

如果两个位置 $a_i$ 和 $b_i$ 都是未确定，如果他们初始情况不同，最终的结果会相同也就是抵消掉了。因此只用考虑都是 $1$ 和都是 $0$ 的两种情况。

而如果都确定了，显然模拟即可。

如果只有一个确定，我们显然不能暴力枚举另一个得具体取值，这样就变成 $O(2^n)$ 的暴力了。发现这时候无论另一个数取 $0$ 还是 $1$，一定可以从交换或不交换中选一个（具体是什么取决于已确定的数的位置和值）。所以后继是固定的，可以直接交换或不交换。

等所有 $m$ 个决策都搜完了，可以做一遍 $O(n^2)$ 暴力判断哪些区间可能成为最终的连续段。

发现每做一次后继个数为 $2$ 的决策会使不确定的位置减少 $2$，因此复杂度为 $O(2^{\frac{n}{2}}(m+n^2))$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=40+5,MAXM=10000+10;
int n,m,a[MAXM],b[MAXM],op[MAXM],ans[MAXN];
void solve(void) {
	int cnt1=0,cnt0=0;
	ffor(i,1,n) if(op[i]==0) cnt0++;
	else if(op[i]==1) cnt1++;
	ffor(l,1,n) {
		int n0=0,n1=0;	
		ffor(r,l,n) {
			if(op[r]==0) n0++;
			else if(op[r]==1) n1++;
			if(!n1&&cnt0==n0) ans[r-l+1]^=1;	
		}
	}
	return ;
}
void dfs(int dep) {
	if(dep==m+1) return solve(),void();
	int oa=op[a[dep]],ob=op[b[dep]],i=dep;
	if(op[a[i]]==-1&&op[b[i]]==-1) {
		op[a[i]]=op[b[i]]=0;
		dfs(dep+1);
		op[a[i]]=op[b[i]]=1;
		dfs(dep+1);
		op[a[i]]=op[b[i]]=-1;
		return ;
	}
	if(op[a[i]]!=-1&&op[b[i]]!=-1) {
		if(op[a[i]]==1&&op[b[i]]==0) swap(op[a[i]],op[b[i]]);
		dfs(dep+1);
		op[a[i]]=oa,op[b[i]]=ob;
		return ;
	}
	if(op[a[i]]==-1) {
		if(ob==0) swap(op[a[i]],op[b[i]]);
		dfs(dep+1);
		if(ob==0) swap(op[a[i]],op[b[i]]);
	}
	else {
		if(oa==1) swap(op[a[i]],op[b[i]]);
		dfs(dep+1);
		if(oa==1) swap(op[a[i]],op[b[i]]);
	}
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) cin>>a[i]>>b[i];
	ffor(i,1,n) op[i]=-1;
	dfs(1);
	ffor(i,1,n) cout<<ans[i]<<' ';
	return 0;
}
```

---

## 作者：xlpg0713 (赞：0)

什么构史玩意。

首先你会一个 $O(2^n(m+\operatorname{poly}(n)))$ 的暴力。状态数有足足 $2^{35}$ 这么多，过不了。~~然后就不会了~~。

答案是模 $2$ 输出，这启示我们很多状态对答案其实都没有影响，于是仍然搜索，记录每个位置是不填不确定或者已经填数，考虑第 $x$ 个操作 $(a_x,b_x)$ 的贡献：

1.操作的两个位置都已确定，直接模拟即可。不会增加状态数。

2.一个位置不确定，若 $a_x$ 位置上为 $1$ 或 $b_x$ 上为 $0$ 即交换两个位置。这是因为如果另一个位置填的数不同那么一定交换，如果相同那么换不换都无所谓。状态数不改变。

3.两个位置都不确定。枚举这两个位置上的 $4$ 种情况。发现 $(0,1),(1,0)$ 这一步后一定相同，也即对答案没有贡献。故只有 $(0,0),(1,1)$ 有用，继续搜索即可。

发现状态数的增加只来源于第三种情况。每次确定两个位置，同时状态数翻倍，总状态数是 $2^\frac{n}{2}$。于是总复杂度 $O(2^\frac{n}{2}(m+\operatorname{poly}(n)))$。

```cpp
#include<iostream>
#include<algorithm>
int n, m, a[1005], b[1005], f[40], rs[40];
void dfs(int x){
    if(x > m){
        int ct = std::count(f + 1, f + n + 1, 1);
        for(int i = 1, sm = 0; i <= n; i++, sm = 0)
            for(int j = i; j <= n; j++){
                if(f[j] == 0) break;
                if(f[j] == 1) ++sm;
                if(sm == ct) rs[j - i + 1] ^= 1;
            }
    } else if(f[a[x]] >= 0 && f[b[x]] >= 0){
        int fl = (f[a[x]] == 1 && f[b[x]] == 0);
        if(fl) std::swap(f[a[x]], f[b[x]]);
        dfs(x + 1); if(fl) std::swap(f[a[x]], f[b[x]]);
    } else if(f[a[x]] < 0 && f[b[x]] < 0){
        f[a[x]] = f[b[x]] = 0, dfs(x + 1);
        f[a[x]] = f[b[x]] = 1, dfs(x + 1);
        f[a[x]] = f[b[x]] = -1;
    } else {
        int fl = 0; if(f[a[x]] >= 0)
            fl = f[a[x]] == 1 && (std::swap(f[a[x]], f[b[x]]),1);
        else fl = f[b[x]] == 0 && (std::swap(f[a[x]], f[b[x]]),1);
        dfs(x + 1); if(fl) std::swap(f[a[x]], f[b[x]]);
    } return;
}
int main(){
    std::cin >> n >> m; std::fill(f + 1, f + n + 1, -1);
    for(int i = 1; i <= m; i++) std::cin >> a[i] >> b[i];
    dfs(1); for(int i = 1; i <= n; i++) std::cout << rs[i] << ' ';
}
```

---

## 作者：是青白呀 (赞：0)

暴力枚举的总方案数是 $2^{35}$ 的，不能接受。考虑答案对 $2$ 取模意味着有很多最终效果一致的状态我们没必要每个都找出来，可以带着不确定的状态搜索。

具体地，我们一边遍历 $m$ 个命令，一边搜索并剪枝。对于第 $i$ 个命令，考虑如下三种情况：
1. 若 $a_i$、$b_i$ 的情况均已被确定，那么直接按照要求交换即可。
2. 若 $a_i$、$b_i$ 的情况有一个未被确定，则根据已被确定的那一个可以判定是否可能会交换。若判定可能交换，就执行交换操作，因为在可能交换的前提下，若两个实际情况不同，就满足交换条件；若两个的实际情况相同，此时交换和不交换是等价的。
3. 若 $a_i$、$b_i$ 的情况均未被确定。假设两者状态不同，则最终一定是 $a_i$ 位置的士兵准备好且 $b_i$ 位置的士兵未准备好，这里的两种方案对应的结果是一致的，贡献到答案里也会被模成 $0$，故不再考虑。否则两者状态相同，由于两个的状态需要同步，不好记录，我们直接枚举两种情况并继续往下搜索即可。

$m$ 条命令执行结束后，不难简单地在 $O(n^2)$ 的复杂度内枚举准备好的士兵区间来计算答案。你发现搜索过程中，每一次增加情况数都是在上述 3 的位置，并且每枚举一次就可以确定两个位置、同时情况数翻一番，故状态数不超过 $2^{17.5}$，可以搜出来。最终复杂度 $O(2^{\frac n2}(n^2+m))$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=1005,M=40,inf=2e9+7,mo=1e9+7;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,a[N],b[N];
int st[M];
int ans[N];
void dfs(int x){
    if(x>m){
        int cntp=0;
        rep(i,1,n)
            cntp+=(st[i]==1);
        rep(i,1,n){
            int nwc=0;
            rep(j,i,n){
                if(st[j]==0)break;
                if(st[j]==1)nwc++;
                if(nwc==cntp)ans[j-i+1]^=1;
            }
        }
        return;
    }
    if(st[a[x]]>=0&&st[b[x]]>=0){
        bool swp=0;
        if(st[a[x]]==1&&st[b[x]]==0)swap(st[a[x]],st[b[x]]),swp=1;
        dfs(x+1);
        if(swp)swap(st[a[x]],st[b[x]]);
    }
    else if(st[a[x]]<0&&st[b[x]]<0){
        st[a[x]]=st[b[x]]=0,dfs(x+1);
        st[a[x]]=st[b[x]]=1,dfs(x+1);
        st[a[x]]=st[b[x]]=-1;
    }
    else{
        bool swp=0;
        if(st[a[x]]>=0){
            if(st[a[x]]==1)swp=1,swap(st[a[x]],st[b[x]]);
        }
        else{
            if(st[b[x]]==0)swp=1,swap(st[a[x]],st[b[x]]);
        }
        dfs(x+1);
        if(swp)swap(st[a[x]],st[b[x]]);
    }
}
int main(){
    read(n),read(m);
    rep(i,1,n)
        st[i]=-1;
    rep(i,1,m)
        read(a[i]),read(b[i]);
    dfs(1);
    rep(i,1,n)
        printf("%d ",ans[i]);
    return 0;
}
```

---

## 作者：qiuzx (赞：0)

[PA2024 题解全集](https://www.luogu.com.cn/article/gi139pd4)

注意到这个对 $2$ 取模很不常规，所以从这里入手解决问题。先考虑第一步操作，我们发现若 $s_{a_1}$ 和 $s_{b_1}$ 在初始状态中不同，那么无论如何操作完之后都是 $s_{a_1}=0,s_{b_1}=1$，所以这两种情况被抵消了。那么我们只需要考虑 $s_{a_1}=s_{b_1}$ 的情况。但这样在后面的操作中可能会出现有一个是前面出现过的位置，而另一个是未出现过的位置的情况，所以不能直接按照这个方法做。但这个思想是好的，所以我们考虑分析一下操作过程中的状态是什么样的。

具体来说，我们认为初始时所有位置都是未知，然后在逐步执行操作时，我们可能会钦定一些位置的值，那么这些位置就被认为是已知的了。注意这里未知的含义指的是它等于某个初始的 $s_x$，但由于我们还没有钦定这个值，所以是未知的。我们并不需要维护 $x$ 具体是什么，因为我们所有的操作都是交换，这意味着任意时刻未知的每个未知对应回原序列中都是一个不同的位置。同时这也意味着我们在钦定一个位置的值时，本质上是在钦定原序列中 $s_x$ 的值，但同样由于我们不关心 $x$，所以可以直接看作钦定这一时刻的值。

假如我们操作的是两个已知的位置，那么直接执行这步操作即可。假如是两个未知的位置，那么和一开始的情况类似，这两个位置的值不等的两种情况在操作完之后是相同的，所以被抵消了。剩下的情况是一个已知，一个未知。例如 $s_a=1$，而 $s_b$ 未知。此时如果 $s_b=1$，则结束后 $s_a=1,s_b=1$，否则结束后 $s_a=0,s_b=1$。所以相当于就是直接将 $s_a,s_b$ 交换，那么这种情况下可以将 $s_a$ 改为未知，将 $s_b$ 改为 $1$ 即可。类似地，其它情况也可以讨论出来发现直接做交换或保持不变即可完成对应情况的操作。这样一直执行操作直到结束，判定是否合法即可。注意这里可能仍然有一些位置未知，那么可以将它们任意复制，不过这个方案数是容易计算的。

考虑一下这么做的复杂度是什么，由于每次钦定会确定两个位置的值，且有两种情况，所以复杂度为 $O(2^{\frac n2}m)$。

``` c++
#include <bits/stdc++.h>
#define INF 1000000000
#define LINF 1000000000000000000
#define MOD 1000000007
#define mod 998244353
#define F first
#define S second
#define ll int
#define N 1010
using namespace std;
ll n,m,a[N],b[N],ans[N];
void upd(vector<ll> v)
{
	ll i,j,mx=-1;
	for(i=0;i<n;i++)
	{
		if(v[i]==1)
		{
			mx=i;
		}
	}
	for(i=0;i<n;i++)
	{
		for(j=i;j<n;j++)
		{
			if(v[j]==0)
			{
				break;
			}
			if(mx!=-1&&j<mx)
			{
				continue;
			}
			ans[j-i+1]^=1;
		}
		if(v[i]==1)
		{
			break;
		}
	}
	return;
}
void dfs(vector<ll> cur,ll x)
{
	while(x<m)
	{
		if(cur[a[x]]==-1&&cur[b[x]]==-1)
		{
			break;
		}
		if(cur[a[x]]==-1)
		{
			if(cur[b[x]]==0)
			{
				swap(cur[a[x]],cur[b[x]]);
			}
		}
		else if(cur[b[x]]==-1)
		{
			if(cur[a[x]]==1)
			{
				swap(cur[a[x]],cur[b[x]]);
			}
		}
		else if(cur[a[x]]==1&&cur[b[x]]==0)
		{
			swap(cur[a[x]],cur[b[x]]);
		}
		x++;
	}
	if(x==m)
	{
		upd(cur);
		return;
	}
	cur[a[x]]=cur[b[x]]=0;
	dfs(cur,x);
	cur[a[x]]=cur[b[x]]=1;
	dfs(cur,x);
	return;
}
int main(){
	ll i;
	cin>>n>>m;
	for(i=0;i<m;i++)
	{
		cin>>a[i]>>b[i];
		a[i]--,b[i]--;
	}
	vector<ll> qwq(n,-1);
	dfs(qwq,0);
	for(i=1;i<=n;i++)
	{
		cout<<ans[i]<<" ";
	}
	puts("");
	return 0;
}
```

---


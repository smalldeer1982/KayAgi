# [PA 2024] Żarówki

## 题目背景

PA 2024 5C2

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 5 [Żarówki](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/zar/)，感谢 Macaronlin 提供翻译**

有 $n$ 个灯泡，每个灯泡有两种状态：开和关，初始状态是给定的。有 $m$ 个开关，每个开关控制两个灯泡，按下开关可以使这两个灯泡变为与目前状态相反的状态，只有在两个灯泡有相同状态时才起作用，否则不起作用。

你可以随意安排开关的使用顺序和使用次数，问利用这些开关可以实现多少种配置方案。灯泡在一种配置中打开而在另一种配置中关闭，则两种配置被视为不同。

## 说明/提示

所有可以实现的配置方案为：`10110`，`00010`，`00111` 和 `10011`。

## 样例 #1

### 输入

```
5 4
1 0 1 1 0
1 3
5 3
4 2
1 5
```

### 输出

```
4```

# 题解

## 作者：Purslane (赞：4)

# Solution

二分图的运用。

如果原图是二分图，那么考虑将他进行黑白二染色，并且把条件改为“两端颜色不同才能翻转”。

那么发现，一次操作相当于把一个黑点移动了一条边的位置，且末状态是**所有黑点变为白点，所有白点变为黑点**。

显然如果黑点有 $b$ 个，白点有 $w$ 个，最终方案是 $\dbinom{b+w}{b}$。

如果不是二分图，考虑求出它的一个子图是二分图，那么非二分图边在同色的时候翻转。

那么这种边没操作一次会使得 $b \pm 2$，奇偶性不变。因此只要末状态和初状态黑点的奇偶性相同，就可以到达。方案是 $2^{b+w-1}$。

染色即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=200000+10,MOD=1e9+7;
int n,m,ans=1,frac[MAXN],inv[MAXN],c[MAXN],col[MAXN],vis[MAXN],pw[MAXN];
vector<int> G[MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;	
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int C(int u,int d) {return frac[d]*inv[u]%MOD*inv[d-u]%MOD;}
int check(int u) {
	int flg=0;
	vis[u]=1,c[u]^=col[u];
	for(auto v:G[u]) {
		if(vis[v]==0) col[v]=col[u]^1,flg|=check(v);
		if(col[v]!=col[u]^1) flg=1;
	}
	return flg;
}
pair<int,int> query(int u) {
	vis[u]=2;
	pair<int,int> ans={1,c[u]};
	for(auto v:G[u]) if(vis[v]==1) {
		auto pr=query(v);
		ans.first+=pr.first,ans.second+=pr.second;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m,pw[0]=1,frac[0]=1;
	ffor(i,1,n) cin>>c[i],pw[i]=pw[i-1]*2%MOD,frac[i]=frac[i-1]*i%MOD;
	inv[n]=qpow(frac[n],MOD-2);
	roff(i,n-1,0) inv[i]=inv[i+1]*(i+1)%MOD;
	ffor(i,1,m) {int u,v;cin>>u>>v,G[u].push_back(v),G[v].push_back(u);}
	ffor(i,1,n) if(!vis[i]) {
		int flg=check(i);
		auto pr=query(i);
		if(flg==1) ans=ans*pw[pr.first-1]%MOD;
		else ans=ans*C(pr.second,pr.first)%MOD;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P10367)

**题目大意**

> 给定 $n$ 个点 $m$ 条边的无向图，节点初始有黑白两种颜色，对于一条两端点同色的边，可以同时翻转两端点颜色，求一共能得到多少种不同的节点颜色组合。
>
> 数据范围：$n\le 2\times 10^5,m\le 4\times 10^5$。

**思路分析**

从链的情况入手，我们发现如果 $a_{i-1}\ne a_{i+1}$，不妨设 $a_i=a_{i-1}$，那么操作 $(i-1,i),(i,i+1)$ 就能交换 $a_{i-1},a_{i+1}$。

因此我们能任意排列奇数位置的点和偶数位置的点，并且可以同时增加或减少两种位置上黑点的个数。

因此只要保证两种位置上黑点个数差相等，每种颜色序列都是可以的得到的。

不难将这个结论推广到连通二分图上。

对于一个奇环，我们发现根据上面的过程，可以任意排列整个环的颜色，因此对于一个有奇环的连通块，我们只要求黑点个数的奇偶性不变。

答案就是每个连通块答案的乘积。

时间复杂度 $\mathcal O(n+m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5,MOD=1e9+7;
ll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
ll fac[MAXN],ifac[MAXN];
ll C(int x,int y) {
	if(x<0||y<0||y>x) return 0;
	return fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;
}
int n,m,f[2],g[2],w[MAXN];
bool vis[MAXN],col[MAXN],flg;
vector <int> G[MAXN];
void dfs(int u,int c) {
	if(vis[u]) return flg&=(col[u]==c),void();
	vis[u]=true,col[u]=c,++f[c],g[c]+=w[u];
	for(int v:G[u]) dfs(v,c^1);
}
signed main() {
	scanf("%d%d",&n,&m);
	for(int i=ifac[0]=fac[0]=1;i<=n;++i) ifac[i]=ksm(fac[i]=fac[i-1]*i%MOD);
	for(int i=1;i<=n;++i) scanf("%d",&w[i]);
	for(int i=1,u,v;i<=m;++i) scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	ll ans=1;
	for(int u=1;u<=n;++u) if(!vis[u]) {
		f[0]=f[1]=g[0]=g[1]=0,flg=1,dfs(u,0);
		ll sum=0;
		if(flg) {
			for(int i=0;i<=f[1];++i) {
				sum=(sum+C(f[0],i+g[0]-g[1])*C(f[1],i))%MOD;
			}
		} else {
			int s=f[0]+f[1];
			for(int i=g[1]%2;i<=s;i+=2) {
				sum=(sum+C(s,i))%MOD;
			}
		}
		ans=ans*sum%MOD;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Jorisy (赞：1)

运用 [Some Simple Tricks](https://www.luogu.com.cn/article/cqhi72t6) 的 $\bm{Trick\ 2}$，将图分层时奇数深度的翻转，那么操作就变成了交换一条边上节点的颜色。设一个极大连通分量内黑点、白点个数分别为 $c_0,c_1$，分类讨论：
- 若是一个二分图，那么黑点个数不变，显然有 $\binom{c_0+c_1}{c_0}$ 种方案。
- 若不是一个二分图，考察原图变化对转化后的图上黑点个数的影响。注意到转化后的图的 $c_0$ 会 $\pm2$（来源于二分图染色时奇环上的那一条同色边），而每一种黑点个数内黑点仍然可以在任意位置。黑白棋子奇偶性不同，并且形成对偶，故方案数为 $2^{c_0+c_1-1}$。

最后把每个连通分量的答案乘起来即可。

---

## 作者：ღꦿ࿐ (赞：1)

AGC004F Namori 的套路。

以灯为点，开关为边建图，显然连通块之间独立，分别考虑连通块的答案求乘积。

同时改变相邻两个，考虑一下二分图相关。若一个连通块为二分图，对其进行黑白染色，将每个点灯的状态异或上它的颜色（黑 $1$，白 $0$），然后接下来我们的操作就是同时翻转两个点，仅当它们不同，相当于异或出来为 $1$ 的点上有个棋子，你可以将它移动到没有棋子的点上，然后最后这个点上就没有棋子了。显然棋子在树上可以任意移动的，$\binom n c$ 种状态都可以达到。


若不是二分图，则奇环上的边可以任意吞掉两个棋子，或是任意产生两个棋子，所以只要棋子个数的个数是的奇偶性相同的状态都是可达的，$2^{n-1}$ 种状态全部可达。

时间复杂度 $O(n)$。

---


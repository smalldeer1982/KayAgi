# [JOIST 2024] 鱼 3 / Fish 3

## 题目描述

JOI 君在一个大水缸中饲养着 $ N $ 条鱼，每条鱼的编号从 $ 1 $ 到 $ N $。

JOI 君有两种类型的鱼食，$ A $ 和 $ B $，两种都有足够的数量。当往水族箱中添加一块食物时，恰好有一条鱼吃掉它（任何鱼都可以吃掉它），并且根据食物的类型以及吃掉它的鱼的情况，鱼的智力变化如下：

- 当第 $ k $ 条鱼（$ 1 \leq k \leq N $）吃掉一块 $ A $ 型食物时，第 $ k $ 条鱼的智力恰好增加 $ D $。
- 当第 $ k $ 条鱼（$ 1 \leq k \leq N $）吃掉一块 $ B $ 型食物时，编号大于等于 $ k $ 的所有鱼的智力都恰好增加 $ 1 $。

目前，所有鱼的智力都为 $ 0 $。JOI 君希望使第 $ i $ 条鱼（$ 1 \leq i \leq N $）的智力等于其理想智力 $ C_i $，但这并不总是可能的。

因此，他考虑了 $ Q $ 个问题。第 $ j $ 个问题（$ 1 \leq j \leq Q $）如下：

- 从所有鱼的智力都为 0 的状态开始，通过重复将食物放入水族箱零次或多次的动作，是否可能达到所有鱼 $ L_j , L_j + 1 ,..., R_j $ 都拥有其精确的理想智力值的状态？此外，如果可能，需要放入水族箱的 A 型食物的最小数量是多少？

编写一个程序，给定有关 JOI 君的鱼的信息以及有关问题的信息，回答他的问题。


## 说明/提示

#### 样例解释 1


例如，在以下情况下，所有鱼 $1,2,3$ 最终都达到了其精确的理想智力值，且放入水族箱的 $A$ 型食物的数量为 $1$。

- 起初，鱼 $1,2,3,4$ 的智力分别为 $0,0,0,0$。
- 接下来，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $3$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $0,0,1,1$。
- 然后，JOI 君将一块 $A$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $2,0,1,1$。
- 最后，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $3,1,2,2$。
- 由于不放入任何 $A$ 型食物就无法达到所有鱼 $1,2,3$ 的精确理想智力值的状态，输出 $1$。

这个样例满足子任务 $1$ 和 $5$ 的约束条件。

### 约束条件

- $ 1 \leq N \leq 300,000 $。
- $ 1 \leq Q \leq 300,000 $。
- $ 1 \leq D \leq 10^{12} $。
- $ 0 \leq C_i \leq 10^{12} $（$ 1 \leq i \leq N $）。
- $ 1 \leq L_j \leq R_j \leq N $（$ 1 \leq j \leq Q $）。
- 给定值均为整数。

### 子任务

- （9 分）$ N \leq 3,000 $，$ Q \leq 3,000 $。
- （7 分）$ C_i \leq 1 $（$ 1 \leq i \leq N $）。
- （28 分）$ D = 1 $。
- （20 分）$ C_i \geq C_{i+1} $（$ 1 \leq i \leq N - 1 $）。
- （36 分）无额外约束。


## 样例 #1

### 输入

```
4 2
3 1 2 1
1
1 3```

### 输出

```
1```

# 题解

## 作者：FFTotoro (赞：6)

观察性质题。下称“投喂 $A$ 饲料”为“执行 $A$ 操作”，$B$ 饲料同理。

考虑暴力怎么做。显然一个 $A$ 操作等价于令某个 $C_i\leftarrow C_i-D$，而最后能通过 $B$ 操作完成的序列 $C$ 必然单调不降（因为每次可以给一个后缀 $+1$，所以前面的数永远不会大于后面的）。

考虑另一种“暴力”，就是将询问离线，按 $R$ 从小到大排序然后扫一遍过去，每次扫到一个新的 $R$，如果 $C_{R-1}>C_R$ 就暴力往前更新，直到满足条件。

上面的这种暴力看起来很能找性质进行优化。观察到如果我们更新过了一对相邻的数，那么接下来不管怎么更新，**它们的差不变**！证明：每次更新都是对一个 $C_i$ 进行 $-D$，考虑 $\bmod D$ 的剩余系即可。于是考虑用一个栈维护还没有更新的位置（因为如果右边的不用更新左边的也不用更新），所以每次从栈顶开始暴力往下查有没有冲突，如果有直接更新中间一段的值，然后把栈顶删掉……均摊一下这种操作最多做 $N$ 次。区间加区间和可以用线段树维护。于是做完了，时间复杂度 $O(N\log N)$。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> pii;
inline int ceil_div(int x,int y){
  return x/y+!!(x%y);
}
class segtree{
  private:
    int n;
    vector<pii> B;
    vector<int> S,T;
  public:
    inline void pushup(int u){
      S[u]=S[u<<1]+S[u<<1|1];
    }
    inline int size(int u){
      return B[u].second-B[u].first+1;
    }
    inline void pushdown(int u){
      S[u<<1]+=T[u]*size(u<<1),S[u<<1|1]+=T[u]*size(u<<1|1);
      T[u<<1]+=T[u],T[u<<1|1]+=T[u],T[u]=0;
    }
    segtree(int N){
      n=N,B.resize(n<<2),S.resize(n<<2),T.resize(N<<2);
      function<void(int,int,int)> build=[&](int u,int l,int r){
        if(B[u]=make_pair(l,r);l==r)return;
        int m=l+r>>1;
        build(u<<1,l,m),build(u<<1|1,m+1,r);
      };
      build(1,0,n-1);
    }
    inline void update(int u,int l,int r,int x){
      if(B[u].first>r||B[u].second<l)return;
      if(l<=B[u].first&&B[u].second<=r){
        T[u]+=x,S[u]+=x*size(u); return;
      }
      pushdown(u);
      update(u<<1,l,r,x),update(u<<1|1,l,r,x);
      pushup(u);
    }
    inline int query(int u,int l,int r){
      if(B[u].first>r||B[u].second<l)return 0;
      if(l<=B[u].first&&B[u].second<=r)return S[u];
      pushdown(u);
      return query(u<<1,l,r)+query(u<<1|1,l,r);
    }
}; // 线段树
main(){
  ios::sync_with_stdio(false);
  int n,d; cin>>n>>d;
  vector<int> c(n);
  for(auto &i:c)cin>>i;
  int q; cin>>q;
  vector<vector<pii> > Q(n);
  vector<int> R(q);
  for(int i=0;i<q;i++){
    int l,r; cin>>l>>r;
    Q[r-1].emplace_back(l-1,i);
  } // 把询问离线下来
  segtree t(n);
  auto get=[&](int p){return c[p]-t.query(1,p,p)*d;};
  stack<int> s;
  for(int i=0;i<n;i++){
    int r=i;
    while(!s.empty()){
      int l=s.top(),x=get(r-1),y=get(r);
      if(x<=y)break;
      t.update(1,l,r-1,ceil_div(x-y,d));
      r=l,s.pop();
    } // 弹栈顶，均摊 N 次
    s.emplace(r);
    for(auto [l,w]:Q[i])
      R[w]=(get(l)<0?-1:t.query(1,l,i));
  }
  for(int i:R)cout<<i<<'\n';
  return 0;
}
```

---

## 作者：Naib (赞：5)

#### [[JOISC 2024 Day1] 鱼 3](https://www.luogu.com.cn/problem/P10430)

> 给定一个序列 $A$ 和 $C$ 和一个常数 $D$。有 $q$ 组询问，每次给你 $l,r$，你需要做一下两种操作把 $A_{l,r}$ 变成 $C_{l,r}$：
>
> 1. 选择一个单点 $i$，$A_{i}\leftarrow A_{i}+D$。
> 2. 选择一个后缀 $i$，$\forall j\ge i,A_{j}\leftarrow A_{j}+1$。
>
> 求最小的 1 操作数。
>
> $n,q\le 2\times 10^5$。

支持在线询问的单 log 做法。

首先记 $B_{i}=C_{i}-A_{i}$，一次操作即单点 $-D$ 或者后缀 $-1$。因为 2 操作没有次数限制，所以考虑什么时候只用 2 操作就可以还原。不难发现合法即 $B_{i}$ 单调不降。

因为 $D$ 是常数，所以考虑把 $B_{i}$ 拆成 $K_{i}\times D+R_{i}$。假设最终变成了 $H_{i}\times D+R_{i}$，那么有 $H_{i}=\min(K_{i},H_{i+1}-(R_{i} > R_{i+1}))$。

注意到如果 $\min$ 取到了 $K_{i}$，那么 $i$ 以及之前的部分就与前面的 $H$ 无关了。所以对于每个 $i$，我们先预处理出当 $H_{i}=K_{i}$ 时，最大的 $j$ 满足 $H_{j}=K_{j}$，同时我们在处理出中间的 $H_{i}$ 的和。这是好统计的：直接暴力跳就行，假设已经求出了前面的 $j$ 对应的 $pos_{j}$。那么跳到 $j$ 的时候，必然有 $H_{i} < K_{i}$。所以我们可以直接跳到 $to_{i}$ 去，中间的贡献预处理前缀和后也是好算的。

然后考虑对于一个询问 $l,r$，那么就是从 $r$ 开始往前跳，直到跳出 $l$ 的前一步，那一段不完整的区间同样可以快速求解。

现在唯一的问题就是加速这个跳的过程，也非常简单，直接上 ST 表就好了。

复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll maxn=3e5+5;

ll c[maxn];
ll K[maxn], R[maxn], C[maxn], SC[maxn], SK[maxn];
ll H[maxn], to[maxn];
ll MC[20][maxn], lg[maxn];
ll F[20][maxn], G[20][maxn], P[20][maxn];

ll ask(ll l,ll r) {
    ll k=lg[r-l+1];
    return min(MC[k][l],MC[k][r-(1<<k)+1]);
}

int main() {
    // freopen("1.in","r",stdin);
    // freopen("1.out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll n,d; cin>>n>>d;
    for(ll i=1;i<=n;i++) {
        cin>>c[i];
        K[i]=c[i]/d;
        R[i]=c[i]%d;
        SK[i]=SK[i-1]+K[i];
    }
    for(ll i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
    for(ll i=n-1;i>=1;i--) C[i]=C[i+1]-(R[i]>R[i+1]), SC[i]=SC[i+1]+C[i];
    for(ll i=1;i<=n;i++) MC[0][i]=C[i];
    for(ll j=1;(1<<j)<=n;j++) {
        for(ll i=1;i+(1<<j)-1<=n;i++) {
            MC[j][i]=min(MC[j-1][i],MC[j-1][i+(1<<j-1)]);
        }
    }
    for(ll i=1;i<=n;i++) {
        to[i]=i-1;
        ll val=K[i]-(R[i-1]>R[i]);
        while(to[i]&&val<K[to[i]]) {
            val=val+C[to[to[i]]]-C[to[i]];
            to[i]=to[to[i]];
        }
        F[0][i]=to[i];
        G[0][i]=SC[to[i]+1]-SC[i+1]+(i-to[i])*(K[i]-C[i]);
        ll v=ask(to[i]+1,i)-C[i]+K[i];
        if(v<0) P[0][i]=1;
    }
    for(int j=1;(1<<j)<=n;j++) {
        for(int i=1;i<=n;i++) {
            F[j][i]=F[j-1][F[j-1][i]];
            G[j][i]=G[j-1][i]+G[j-1][F[j-1][i]];
            P[j][i]=P[j-1][i]|P[j-1][F[j-1][i]];
        }
    }
    ll q; cin>>q;
    while(q--) {
        ll l,r; cin>>l>>r;
        H[r]=K[r];
        ll flag=0, sum=0;
        ll p=r;
        sum=SK[r]-SK[l-1];
        for(int i=19;i>=0;i--) if(F[i][p]>=l) {
            sum-= G[i][p];
            flag|=P[i][p];
            p=F[i][p];
        }
        sum-= SC[l]-SC[p+1]+(p-l+1)*(K[p]-C[p]);
        ll v=ask(l,p)-C[p]+K[p];
        if(v<0) flag=1;
        if(flag) cout<<"-1\n";
        else cout<<sum<<'\n';
    }
    return 0;
}
````

---

## 作者：WrongAnswer_90 (赞：4)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18246042)

### [P10430 [JOISC 2024 Day1] 鱼 3](https://www.luogu.com.cn/problem/P10430)

首先操作可以看成是单点减 $k$ 和后缀减 $1$，问区间能不能全部减到 $0$，并最小化单点操作次数。

假设先进行所有的单点修改，则一定是把一个区间改成单增的。

考虑扫描线，从左向右依次新加入数，并且在这个过程中要保持当前的序列单增。可以用一个单调栈来维护连续段。

这里的连续段指的是相邻两个数的差小于 $k$ 的极大连续段，如果当前栈顶连续段的右端点大于新加入的数 $x$，就需要对整个连续段的数进行一次操作，直到满足右端点小于等于当前的 $x$。

栈顶不断减 $k$ 的过程中，可能会和它下面的一个连续段合并。这样复杂度是均摊 $\mathcal O(n)$ 的。假设这次对某个连续段进行了 $k$ 次操作，可以看成是一次序列上的区间加 $k$，查询就是查询区间和，用树状数组或者线段树实现，复杂度是 $\mathcal O(n\log n)$。代码找不到了 QwQ。

---

## 作者：Nangu (赞：3)

提供一种与众不同的解法。

倘若只进行 B 操作，那么 $c$ 数组能被构造的充要条件是 $c$ 不降。于是我们套路地进行一个差分。

则题意就转化为，对于一个数组 $c'$，每次操作可以选择一个 $i$，令 $c'_i-D\to c'_i$，$c'_{i+1}+D\to c'_{i+1}$，问多少次操作后 $c'$ 中所有的元素大于等于零。

这个问题该怎么解决捏？一个贪心的想法：若有一个 $c'_i<0$，我们肯定要找到 $i$ 之前离 $i$ 最近的可以转移的元素。若为 $j$，则此部分的贡献为 $vi-vj$，其中 $v$ 表示 $j$ 要向 $i$ 转移的次数。

然后发现这个东西显然可以用单侧递归线段树维护。具体维护方法可见楼房重建一题。

代码：
```cpp
#include<bits/stdc++.h>
#define rep(i, j, k) for(int i=(j); i<=(k); ++i)
#define per(i, j, k) for(int i=(j); i>=(k); --i)
using namespace std;
namespace DEBUG{
  template<class T> void _debug(const char *s, T x) {cout<<s<<'='<<x<<endl;}
  template<class F, class... Nxt> void _debug(const char *s, F x, Nxt... nxt){
  int d=0;
  while(*s!=',' || d) d+=*s=='(', d-=*s==')', cout<<*s++;
    cout<<'='<<x<<',';
    _debug(s+1, nxt...);
  }
  #define debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)
} using namespace DEBUG;
#define int long long
using pa=pair<int, int>;
const int N=3e5+7;
struct node{int l, r, lst, sum, ned, ans, lft;}t[N<<2];
//lst 为右边的区间留下了多少
//sum 一共为右边区间留下的权值和
//ned 还需要左边的区间贡献多少
//lft 左边的区间在算好右边的区间后的答案
//ans 区间的答案
int n, d, a[N], b[N], m;

#define ls p<<1
#define rs p<<1|1

//需要为右边贡献x 的情况下整个区间的代价 返回值:[还需要左边多少，并且答案为多少]
pa f(int p, int x){
  if(!x) return pa(t[p].ned, t[p].ans);
  if(t[p].l==t[p].r){
    int v=a[t[p].l];
    if(v<0) return pa(-v+x, -v*t[p].l);
    else{
      int c=min(v, x);
      return pa(x-c, -c*t[p].l);
    }
  }
  if(t[rs].lst>=x){
    pa v=f(rs, x);
    return pa(t[p].ned, t[p].lft+v.second);
  } else{
    pa v=f(ls, x-t[rs].lst+t[rs].ned);
    return pa(v.first, v.second-t[rs].sum+t[rs].ans);
  }
}

void pushup(int p){
  pa x=f(ls, t[rs].ned);
  t[p].lft=x.second;
  t[p].ned=x.first;
  t[p].lst=t[rs].lst+t[ls].lst-(t[rs].ned-(x.first-t[ls].ned));
  t[p].ans=x.second+t[rs].ans;
  t[p].sum=t[rs].sum+t[ls].sum+(x.second-t[ls].ans);
}

void build(int p, int l, int r){
  t[p].l=l, t[p].r=r;
  if(l==r){
    if(a[l]>0) t[p].lst=a[l], t[p].sum=a[l]*l;
    else t[p].ned=-a[l], t[p].ans=-a[l]*l;
    return;
  }
  int mid=l+r>>1;
  build(ls, l, mid), build(rs, mid+1, r);
  pushup(p);
}

pa query(int p, int l, int r, int x=0){
  if(l<=t[p].l && t[p].r<=r) return f(p, x);
  if(l>t[p].r || r<t[p].l) return pa(x, 0);
  pa a=query(rs, l, r, x), b=query(ls, l, r, a.first);
  return pa(b.first, a.second+b.second);
}

signed main(){
  cin.tie(0)->sync_with_stdio(0);
  cin>>n>>d;
  rep(i, 1, n) cin>>a[i], b[i]=a[i];
  per(i, n, 1){
    a[i]-=a[i-1];
    if(a[i]>0) a[i]=a[i]/d;
    else if(a[i]<0) a[i]=(-a[i]-1)/d+1, a[i]*=-1;
  }
  build(1, 1, n);
  cin>>m;
  while(m--){
    int l, r;
    cin>>l>>r;
    if(l==r) cout<<"0\n";
    else{
      pa x=query(1, l+1, r);
      int tmp=b[l]/d;
      if(x.first>tmp) cout<<"-1\n";
      else{
        x.second-=x.first*l;
        cout<<x.second<<'\n';
      }
    }
  }
}

---

## 作者：daduoli (赞：3)

这个题我会做。

先考虑对于一个序列暴力怎么算，显然从后往前扫，对于一个点假设他被而操作操作了 $c_i$ 次，那么显然对于任意 $i<j$ 有 $c_i\le c_j$，对于最后一条鱼，我们记操作多少次 $2$ 操作不是很方便，我们记他的 $2$ 操作省了多少次 $1$ 操作。

显然有 $c_n=d_n=\lfloor\frac {a_n}{d}\rfloor$，至于余数操作掉是容易的。

考虑第 $n-1$ 条鱼，记 $b_i\equiv a_i\pmod d$。

分两种情况：

- $b_{n-1}\le b_n$，这时候 $c_{n-1}=\min(d_{n-1},c_{n})$。

- 否则，$c_{n-1}=\min(d_{n-1},c_n-1)$。

然后我们的答案就是 $\sum\limits_{i=l}^r d_i-c_i$。

进一步，考虑扫描线。

每次维护以 $i$ 为右端点时，$1\sim i$ 中每个点的 $c$ 为多少，不难发现 $c$ 是递减的。

我们考虑 $\min$ 里面的括号取到哪边，对于取到右边的，我们可以考虑把它们连续取右边即 $c_{i+1}$ 的情况，我们把它缩成一个段，这样就是若干个取右边的段，段内差分是固定的。

然后就是直接单调栈，当取到左边的时候就缩起来，缩起来之后，容易发现对于前面那个段是一个区间减的操作，然后我们可以用线段树维护，至于非法的情况就是出现负数。

时间复杂度 $O(n\log n)$。


```
#include<bits/stdc++.h>
#define Yzl unsigned long long
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
typedef long long LL;

using namespace std;

const Yzl Lty=20120712;

const int MAXN=3e5+10;
int n;
LL d,a[MAXN];
vector<pi> e[MAXN];
struct ddl {
	LL tr[MAXN<<2],lb[MAXN<<2];
	void add(int u,int l,int r,LL x) {
		tr[u]+=(LL)(r-l+1)*x;
		lb[u]+=x;
	}
	void psdn(int u,int l,int mid,int r) {
		if(lb[u]) {
			add((u<<1),l,mid,lb[u]);
			add((u<<1|1),mid+1,r,lb[u]);
			lb[u]=0;
		}
	}
	void psup(int u) {
		tr[u]=tr[(u<<1)]+tr[(u<<1|1)];
	}
	void update(int u,int l,int r,int x,int y,LL z) {
		if(l>=x&&r<=y) {
			add(u,l,r,z);
			return ;
		} int mid=(l+r)/2; psdn(u,l,mid,r);
		if(x<=mid) update((u<<1),l,mid,x,y,z);
		if(y>mid) update((u<<1|1),mid+1,r,x,y,z);
		psup(u);
	}
	LL query(int u,int l,int r,int x,int y) {
		if(l>=x&&r<=y) return tr[u];
		int mid=(l+r)/2; psdn(u,l,mid,r); LL res=0;
		if(x<=mid) res+=query((u<<1),l,mid,x,y);
		if(y>mid) res+=query((u<<1|1),mid+1,r,x,y);
		return res;
	}
	LL Que(int u,int l,int r,int x) {
		if(l==r) return tr[u];
		int mid=(l+r)/2; psdn(u,l,mid,r);
		if(x<=mid) return Que((u<<1),l,mid,x);
		return Que((u<<1|1),mid+1,r,x);
	}
}T;
LL ans[MAXN],b[MAXN],s[MAXN],S[MAXN],ind[MAXN];
int l[MAXN],r[MAXN],tot;
bool sf[MAXN];
int main () {
	scanf("%d%lld",&n,&d);
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]);
	int Q; scanf("%d",&Q);
	for(int i=1;i<=Q;++i) {
		int l,r; scanf("%d%d",&l,&r);
		e[r].pb(mp(l,i));
	}
	for(int i=1;i<=n;++i) {
		b[i]=a[i]/d; a[i]%=d; s[i]=s[i-1]; S[i]=S[i-1];
		if(a[i]<a[i-1]) ++s[i],sf[i]=1;
		S[i]+=b[i];
	}
	for(int i=1;i<=n;++i) {
		LL x=b[i];
		while(tot&&ind[tot]+sf[r[tot]+1]>=x) {
			LL ls=ind[tot]+sf[r[tot]+1]-x;
			T.update(1,1,n,l[tot],r[tot],-ls);
			x-=s[r[tot]+1]-s[l[tot]];
			--tot;
		} ind[++tot]=b[i]; l[tot]=r[tot-1]+1; r[tot]=i;
		T.update(1,1,n,i,i,b[i]);
		for(auto t:e[i]) {
			if(T.Que(1,1,n,t.fi)<0) ans[t.se]=-1;
			else ans[t.se]=(S[i]-S[t.fi-1])-T.query(1,1,n,t.fi,i);
		}
	}
	for(int i=1;i<=Q;++i) printf("%lld\n",ans[i]);
	return 0;
}

```

---

## 作者：cpchenpi (赞：2)

感觉很好的一个题，VP 的时候写了个复杂度劣但是比较好想好写（也许）的做法，过来说一说。

### 题意简述

有一个初始为 $0$ 的数组 $\{A\}_{i=1}^n$，可以执行两种操作：

- A 操作：单点加 $d$（$d$ 是题目全局给定的数）。

- B 操作：后缀加 $1$。

另外有数组 $\{C\}_{i=1}^n$，现区间询问，是否可以让区间内两数组相等（即 $A_{l..r}$ 等于 $C_{l..r}$），若可以至少需要几次操作 A。

### 题解

#### subtask 1, $O(nq)$

首先打暴力分，可以发现因为操作 B 是免费的，我们的策略是一个简单的贪心。

具体地，从右往左贪心，我们希望被尽可能多的 B 操作影响，同时还要保证和目标的差能被 $d$ 整除，以让剩下的值能被操作 A 补上。

因此，若记一个位置被 B 操作增加的次数为 $b_{i}$，我们知道，$b_i$ 是 $\le \min(b_{i + 1}, c_i)$ 的最大的与 $c_i$ 对 $D$ 同余的数（若小于 $0$ 则无解）；需要补上的 A 操作的次数是 $\lfloor \dfrac {c_i} d \rfloor - \lfloor \dfrac {b_i} d \rfloor$。

容易写出 $O(qn)$ 的代码：

``` cpp
// rem[i] = c[i] % d, cnt[i] = c[i] / d;
i64 last = INF, ans = 0;
for (int i = r; i >= l; i--) {
    if (rem[i] > last) {
        ans = -1;
        break;
    }
    i64 fcnt = min((last - rem[i]) / d, cnt[i]);
    ans += cnt[i] - fcnt;
    last = fcnt * d + rem[i];
}
cout << ans << "\n";
```


#### subtask 4, $C_i \ge C_{i + 1}$

前面说过需要补上的 A 操作的次数是 $\lfloor \dfrac {c_i} d \rfloor - \lfloor \dfrac {b_i} d \rfloor$，那么预处理 $\lfloor \dfrac {c_i} d \rfloor$ 前缀和后，只需要求出 $\lfloor \dfrac {b_i} d \rfloor$ 的区间和。

让我们向正解进发。我们发现“求 $\le \min(b_{i + 1}, c_i)$ 的最大的与 $c_i$ 对 $d$ 同余的数”这件事在 $C$ 非递减的时候是好做的，因为 $b_{i + 1} \le c_{i + 1} \le {c_i}$，我们并不需要考虑 $c_i$ 的限制，即只要求 $\le b_{i + 1}$ 的最大的与 $c_i$ 对 $d$ 同余的数。

那么可以得到递推式 $\lfloor \dfrac {b_i} d \rfloor = \lfloor \dfrac {b_{i + 1}} d \rfloor - [(c_i \bmod d) > (c_{i+1} \bmod d)]$（画图容易理解）。

预处理后面这个值（记作 $\text{diff}_i$），我们要求的就是区间“后缀和的后缀和”。预处理整个序列的后缀和，以及整个序列后缀和的后缀和，即可通过容斥进行区间查询。

写这个部分分的时候我还没有特别弄明白，代码写得比较乱，所以就不贴了。

#### 正解

当没有了 $C$ 单调性的限制时，唯一的影响是式子变为：

$$
\lfloor \dfrac {b_i} d \rfloor = \min(
  \lfloor \dfrac {b_{i + 1}} d \rfloor - \text{diff}_i,
  \lfloor \dfrac {c_i} d \rfloor
)
$$

做过这种题的同学容易意识到，这个操作链可以拆成点依赖（可以尝试使用归纳等方法证明一下）：

$$
\lfloor \dfrac {b_i} d \rfloor = \min\limits_{i \le j \le r}(
  \lfloor \dfrac {c_{j}} d \rfloor - \sum_{i \le p < j}\text{diff}_p
)
$$

预处理 $\text{diff}$ 的后缀和 $\text{suf}$，即

$$
\begin{aligned}
\lfloor \dfrac {b_i} d \rfloor
&= \min\limits_{i \le j \le r}(
  \lfloor \dfrac {c_{j}} d \rfloor - \text{suf}_i + \text{suf}_j
) \\
&= \min\limits_{i \le j \le r}(
  \lfloor \dfrac {c_{j}} d \rfloor + \text{suf}_j
) - \text{suf}_i
\end{aligned}
$$

$\min$ 之中的值已经可以预处理，现在要求的答案就变为 $\sum\limits_{l \le i \le r}(\min\limits_{i \le j \le r} g_j) - \text{suf}_i$。这是“区间后缀 $\min$ 之和”的形式，我选择不动脑子的用兔队树（单侧递归线段树，楼房重建线段树）在 $O((n + q) \log^2 n)$ 解决它，尽管这只是一个静态问题（用扫描线加线段树就可以单 $\log$ 了）。这也告诉我们，这一题可以加强带修的（太毒瘤了 2333）……

代码（符号有点区别）：

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = int64_t;
using i128 = __int128_t;

constexpr int N = 3e5 + 7;
struct Node {
    i64 min;
    i128 left_sum;
} tr[N << 2];
vector<i64> g;

i128 calc(int id, int l, int r, i64 suf_min) {
    if (l == r) return min(suf_min, tr[id].min);
    int mid = (l + r) >> 1;
    if (suf_min > tr[2 * id + 1].min) {
        return tr[id].left_sum + calc(2 * id + 1, mid + 1, r, suf_min);
    } else {
        return i128(r - mid) * suf_min + calc(2 * id, l, mid, suf_min);
    }
}

void build(int id, int l, int r) {
    if (l == r) {
        tr[id].min = g[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(2 * id, l, mid);
    build(2 * id + 1, mid + 1, r);
    tr[id].min = min(tr[2 * id].min, tr[2 * id + 1].min);
    tr[id].left_sum = calc(2 * id, l, mid, tr[2 * id + 1].min);
}

pair<i128, i64> query(int id, int ql, int qr, int l, int r, i64 suf_min) {
    if (ql <= l && r <= qr) return {calc(id, l, r, suf_min), min(suf_min, tr[id].min)};
    int mid = (l + r) >> 1;
    i128 ans = 0;
    if (qr > mid) {
        auto [ans_right, min_right] = query(2 * id + 1, ql, qr, mid + 1, r, suf_min);
        ans += ans_right, suf_min = min(suf_min, min_right);
    }
    if (ql <= mid) {
        auto [ans_left, min_left] = query(2 * id, ql, qr, l, mid, suf_min);
        ans += ans_left, suf_min = min(suf_min, min_left);
    }
    return {ans, suf_min};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin >> n; i64 d; cin >> d;
    vector<i64> c(n + 1), rem(n + 1), tcnt(n + 1);
    vector<i64> diff(n + 1), sum(n + 1), diff_suf(n + 2), suf_sum(n + 2);
    for (int i = 1; i <= n; i++) cin >> c[i];
    for (int i = 1; i <= n; i++) {
        rem[i] = c[i] % d, tcnt[i] = (c[i] - rem[i]) / d, sum[i] = sum[i - 1] + tcnt[i];
    }
    for (int i = n; i >=1; i--) {
        if (i < n) diff[i] = -(rem[i] > rem[i + 1]);
        diff_suf[i] = diff_suf[i + 1] + diff[i];
        suf_sum[i] = suf_sum[i + 1] + diff_suf[i];
    }
    g.resize(n + 1);
    for (int i = 1; i <= n; i++) {
        g[i] = tcnt[i] - diff_suf[i];
    }
    build(1, 1, n);
    int q; cin >> q;
    // acnt[i] = min(cnt[i], acnt[i + 1] + diff[i])
    // -> 每次操作是不变或 -1 ，后与另一个数取 min，求每次操作结束后数之和？
    // -> acnt[i] = min_{j>=i}(tcnt[j] + suf[i] - suf[j])
    //            = min_{r>=j>=i}(g[j]) + suf[i]
    while (q--) {
        int l, r; cin >> l >> r;
        auto [tsum, rmin] = query(1, l, r, 1, n, INT64_MAX >> 2);
        if (rmin + diff_suf[l] < 0) {
            cout << -1 << "\n";
        } else {
            cout << (sum[r] - sum[l - 1]) - i64(tsum + (suf_sum[l] - suf_sum[r + 1])) << "\n";
        }
    }
}
```

---

## 作者：Demeanor_Roy (赞：1)

提供一种新的思路。

首先把题意转化为用尽量少的一操作使序列不降，且首项非负。

显然有一个贪心是说从后往前考虑，如果当前数比后一个数大，就不断减 $D$ 直至恰好不大于后一个数。暴力做是平方的。

我们考虑把询问挂在左端点，从右往左做扫描线。扫到位置 $l$ 时，我们对 $r \in [l,n]$  维护对 $[l,r]$ 这段区间做完上述贪心 $a_l$ 的值（记作 $a_{l,r}$）。

注意到 $a_{l,x}$ 的值显然是从左往右单调不增的，且都是原来的 $a_l$ 减去一个 $D$ 的倍数。我们考虑加入 $a_{l-1}$ 的影响，找到最小的 $y$ 满足 $a_{l,y}<a_{l-1}$，显然对于 $[l,y)$ 这段区间 $a_{l-1,x}=a_{l-1}$，区间赋值即可；对于 $[y,n]$ 这段区间 $a_{l-1,x}=a_{l-1}-D\lceil \dfrac{a_{l-1}-a_{l,x}}{D}\rceil$，这玩意儿和 $a_{l,x}$ 的差显然对于 $x \in [y,n]$ 都是相同的。于是操作可以用区间减维护。

同时我们注意到操作的总次数可以直接用原来的区间和减去现在的区间和，故多维护一个历史和即可。时间复杂度 $O(n \log n)$。

---

## 作者：xzf_200906 (赞：1)

首先可以发现原问题等价于以下问题：
> 构造一个长度相等的序列 $A_i$，满足以下约束且最小化 $\sum_{i=1}^{n}\frac{C_i-A_i}{D}$：
>1. $0\leq A_i \leq C_i$。
>2. $A_i\leq A_{i+1}$
>3. $A_i\equiv C_i \pmod D$

记 $B_i=\lfloor\frac{A_i}{D}\rfloor$，则目标等价于最大化 $\sum_{i=1}^{n}B_i$。下文全部讨论此问题。

先考虑如何判断有无解。考虑构造一个最小的解。如果 $C_i \bmod D<C_{i-1} \bmod D$，则令 $B_i=B_{i-1}+1$，否则令 $B_i=B_{i-1}$，不难发现序列 $B$ 的每一项都是可行解中最小的，也是最容易满足要求的。先预处理整个序列的 $B_{all}$，则对于区间 $[l,r]$ 对应的数组 $B$ 有 $B_i=B_{all,i}-B_{all,l}$，该区间有解当且仅当 $\min_{l\leq i \leq r}\{\lfloor\frac{C_i}{D}\rfloor-(B_{all,i}-B_{all,l})\}\geq 0$。

现在我们有了一组合法解，但是它并不是最优解。考虑在这个解的基础上扩展以得到更优的解。记最优解为 $B'$，$E_i=B'_i-B_i$，则根据上述合法解的构造过程可知 $B'_i-B'_{i-1}\geq B_i-B_{i-1}$，也就是说 $E_i\geq E_{i-1}$。又根据约束1可知 $B'_i\leq \lfloor\frac{C_i}{D}\rfloor$，即 $E_i\leq \lfloor\frac{C_i}{D}\rfloor-B_i$，则 $E_i=\min_{i\leq j \leq r}\{\lfloor\frac{C_j}{D}\rfloor-B_j\}$。最终答案即为：
$$\begin{aligned}
&\sum_{i=1}^{n}\lfloor\frac{C_i}{D}\rfloor-B'_i
\\=&\sum_{i=1}^{n}\lfloor\frac{C_i}{D}\rfloor-(B_i+E_i)
\\=&\sum_{i=l}^{r}\lfloor\frac{C_i}{D}\rfloor-(B_{all,i}-B_{all,l})-\min_{i\leq j \leq r}\{\lfloor\frac{C_j}{D}\rfloor-B_{all,j}+B_{all,l}\}
\\=&\sum_{i=l}^{r}\lfloor\frac{C_i}{D}\rfloor-B_{all,i}-\min_{i\leq j \leq r}\{\lfloor\frac{C_j}{D}\rfloor-B_{all,j}\}
\end{aligned}$$

前两项使用前缀和维护，第三项为对区间内后缀最小值求和，不难想到使用扫描线+单调栈+线段树维护。判断有无解使用数据结构维护区间最小值即可。细节详见代码。

Code:
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const LL inf=1e18;
LL c[1000000],pre[1000000],pre2[1000000],num[1000000],ans[1000000];
int stk[1000000],top=0;
vector<pair<int,int> > qry[1000000];
LL tag[3000000],sum[3000000];
void up(int p){
	sum[p]=sum[p<<1]+sum[p<<1|1];
}
void dn(int p,int l,int r){
	if(tag[p]!=inf){
		int mid=(l+r)>>1;
		sum[p<<1]=tag[p]*(mid-l+1);
		sum[p<<1|1]=tag[p]*(r-mid);
		tag[p<<1]=tag[p<<1|1]=tag[p];
		tag[p]=inf;
	}
}
void change(int p,int l,int r,int ql,int qr,LL val){
	if(ql<=l&&qr>=r){
		tag[p]=val;
		sum[p]=val*(r-l+1);
		return;
	}
	int mid=(l+r)>>1;
	dn(p,l,r);
	if(ql<=mid) change(p<<1,l,mid,ql,qr,val);
	if(qr>mid) change(p<<1|1,mid+1,r,ql,qr,val);
	up(p);
}
LL query(int p,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r) return sum[p];
	int mid=(l+r)>>1;
	LL ret=0;
	dn(p,l,r);
	if(ql<=mid) ret=query(p<<1,l,mid,ql,qr);
	if(qr>mid) ret+=query(p<<1|1,mid+1,r,ql,qr);
	return ret;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,q;
	LL d;
	cin>>n>>d;
	for(int i=1;i<=n;i++){
		cin>>c[i];
		pre[i]=pre[i-1];//相当于 B_{all}
		if(c[i]%d<c[i-1]%d) pre[i]++;
		num[i]=c[i]/d-pre[i];
		pre2[i]=pre2[i-1]+c[i]/d-pre[i];
	}
	cin>>q;
	for(int i=1;i<=q;i++){
		int l,r;
		cin>>l>>r;
		qry[r].push_back({l,i});
	}
	for(int i=1;i<=n;i++){
		while(top&&num[stk[top]]>=num[i]) top--;
		change(1,1,n,stk[top]+1,i,num[i]);
		stk[++top]=i;
		for(auto it:qry[i]){
			if(query(1,1,n,it.first,it.first)+pre[it.first]<0)
				ans[it.second]=-1;
			else ans[it.second]=pre2[i]-pre2[it.first-1]-query(1,1,n,it.first,i);
		}
	}
	for(int i=1;i<=q;i++) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

人机验证题。

记鱼当前的智力为 $v_i$。

首先肯定是用 A 操作尽快地使得 $C_i-v_i$ 构成的序列不降，然后就可以用 B 操作达到想要的状态。

所以问题就是，给定区间的 $C$ 序列，每次操作形如给一个位置减 $D$ 问最少减多少次使得序列不降。

假若只回答一个区间，考虑从左往右扫一下，相当于做若干次对前缀所有大于某个数的位置不断减去 $D$ 直到小于等于这个数，这样做显然操作次数最少了，也就是我们只需要快速知道这个过程的答案就行。

考滤从左往右扫描线，这个修改看似比较诡异，不好维护，但是大力观察一下修改的形式，你发现，存在一些段中的数会在一次修改中产生相同的变化量，形式化的表达：假若区间 $[l,r]$ 已经满足 $C$ 序列不降，并且任意 $i \in [l,r)$ 都满足 $C_{i+1}-C_i < D$，那么在一次修改中，区间 $[l,r]$ 内每个位置都会做相同次数的减去 $D$ 操作。我们把这样的段叫做一个绑定的段。

知道了这些就好做了，每次扫描线加入一个 $r$ 的时候， 从后往前扫描所有绑定的段，当一个绑定的段不会被修改时，显然后面的段也不会被修改了于是就停止，注意到所有被扫描过的绑定的段都会被合并为一个段，所以直接用 vector 暴力维护就行，线段树维护下修改，时间复杂度 $O((n+q) \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 3e5+114;
int tr[maxn<<2],tag[maxn<<2],mi[maxn<<2];
void pushup(int cur){tr[cur]=tr[cur<<1]+tr[cur<<1|1],mi[cur]=min(mi[cur<<1],mi[cur<<1|1]);}
//tr 受到的标记与 tag/mi 相反
//mi 受到的标记*D
int D;
void pushdown(int cur,int lt,int rt){
    if(tag[cur]!=0){
        int mid=(lt+rt)>>1;
        tr[cur<<1]-=tag[cur]*(mid-lt+1),mi[cur<<1]+=tag[cur]*D,tag[cur<<1]+=tag[cur];
        tr[cur<<1|1]-=tag[cur]*(rt-mid),mi[cur<<1|1]+=tag[cur]*D,tag[cur<<1|1]+=tag[cur];
        tag[cur]=0;
    }
}
int ask(int cur,int lt,int rt,int l,int r){
    if(r<lt||rt<l) return 0;
    if(l<=lt&&rt<=r) return tr[cur];
    pushdown(cur,lt,rt);
    int mid=(lt+rt)>>1;
    return ask(cur<<1,lt,mid,l,r)+ask(cur<<1|1,mid+1,rt,l,r);
}
void add(int cur,int lt,int rt,int l,int r,int c){
    if(r<lt||rt<l) return ;
    if(l<=lt&&rt<=r){
        tr[cur]-=c*(rt-lt+1),mi[cur]+=c*D,tag[cur]+=c;
        return ;
    }
    pushdown(cur,lt,rt);
    int mid=(lt+rt)>>1;
    add(cur<<1,lt,mid,l,r,c),add(cur<<1|1,mid+1,rt,l,r,c),pushup(cur);
}
int askmin(int cur,int lt,int rt,int l,int r){
    if(r<lt||rt<l) return 1e18;
    if(l<=lt&&rt<=r) return mi[cur];
    pushdown(cur,lt,rt);
    int mid=(lt+rt)>>1;
    return min(askmin(cur<<1,lt,mid,l,r),askmin(cur<<1|1,mid+1,rt,l,r));
}
vector< pair<int,int> > que;//
int ans[maxn];
vector< pair<int,int> > Q[maxn];
int a[maxn],n,q;
//连续段首尾的 a 维护出真实值
void build(int cur,int lt,int rt){
    if(lt==rt){
        mi[cur]=a[lt];
        tr[cur]=0;
        return ;
    }
    int mid=(lt+rt)>>1;
    build(cur<<1,lt,mid),build(cur<<1|1,mid+1,rt),pushup(cur);
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>D;
    for(int i=1;i<=n;i++) cin>>a[i];
    build(1,1,n);
    cin>>q;
    for(int i=1;i<=q;i++){
        int l,r;
        cin>>l>>r,Q[r].push_back(make_pair(l,i));
    }
    for(int r=1;r<=n;r++){
        int endv=a[r];
        while(que.size()>0&&a[que.back().second]>endv){
            int cnt=(a[que.back().second]-endv+D-1)/D;
            add(1,1,n,que.back().first,que.back().second,-cnt);
            a[que.back().first]-=D*cnt;
            endv=a[que.back().first];
            que.pop_back();
        }
        if(que.size()==0) que.push_back(make_pair(1,r));
        else que.push_back(make_pair(que.back().second+1,r));
        for(pair<int,int> query:Q[r]) ans[query.second]=(askmin(1,1,n,query.first,r)>=0?ask(1,1,n,query.first,r):-1);
    }
    for(int i=1;i<=q;i++) cout<<ans[i]<<"\n";
    return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10430)

**题目大意**

> 定义一个序列的权值为，用单点 $+d$ 和后缀 $+1$ 构造这个序列时，第一种操作的最小操作次数。
>
> 给定 $a_1\sim a_n$，$q$ 次询问 $a[l,r]$ 的权值。
>
> 数据范围：$n,q\le 3\times 10^5$。

**思路分析**

可以看成进行尽可能少的单点 $-d$ 使得这个序列递增，一个简单贪心就是倒着确定序列，贪心地取合法的最大值。

假设 $a_{i+1}$ 上操作了 $k_{i+1}$ 次，那么 $a_i$ 上的操作次数 $k_i=\max\left(0,\left\lceil\dfrac{a_i-(a_{i+1}-k_{i+1}d)}{d}\right\rceil\right)=\max\left(0,\left\lceil\dfrac{a_i-a_{i+1}}{d}\right\rceil+k_{i+1}\right)$。

设 $c_i=\left\lceil\dfrac{a_i-a_{i+1}}{d}\right\rceil$，那么我们就要求 $k_i=\max(0,c_i+k_{i+1})$ 得到的 $k_{l}\sim k_r$ 之和。

如果 $c_i+k_{i+1}$ 总是 $\ge 0$，那么计算权值是平凡的，因此们以 $k_i=0$ 的时刻进行分割。

用二分求出 $k_r=0$ 时下一个 $k_i=0$ 的点，用倍增加速这个过程。

如果 $dk_i>a_i$ 答案是 $-1$，判定可以用 ST 表，合并答案的时候注意一下 $-1$ 的处理即可。

时间复杂度 $\mathcal O((n+q)\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define LL __int128
using namespace std;
const int MAXN=3e5+5;
int n,q,fa[MAXN][20];
ll a[MAXN],c[MAXN],S[MAXN],d;
ll st[MAXN][20],w[MAXN][20],vl[MAXN][20];
LL sum[MAXN];
int bit(int x) { return 1<<x; }
ll qmn(auto f,int l,int r) {
	int k=__lg(r-l+1);
	return min(f[l][k],f[r-bit(k)+1][k]);
}
ll val(int l,int r) {
	if(qmn(vl,l,r)<-S[r]*d) return -1;
	return sum[l]-sum[r]-(LL)S[r]*(r-l);
}
ll add(ll x,ll y) { return ~x&&~y?x+y:-1; }
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>d;
	for(int i=1;i<=n;++i) cin>>a[i];
	ll K=*max_element(a+1,a+n+1)/d+1;
	for(int i=n-1;i>=1;--i) {
		c[i]=(a[i]-a[i+1]+K*d+d-1)/d-K;
		S[i]=S[i+1]+c[i],st[i][0]=S[i],vl[i][0]=a[i]-S[i]*d;
		sum[i]=sum[i+1]+S[i];
	}
	for(int k=1;k<20;++k) for(int i=1;i+bit(k)-1<=n;++i) {
		st[i][k]=min(st[i][k-1],st[i+bit(k-1)][k-1]);
		vl[i][k]=min(vl[i][k-1],vl[i+bit(k-1)][k-1]);
	}
	for(int i=1;i<=n;++i) {
		int l=1,r=i,p=i;
		while(l<=r) {
			int mid=(l+r)>>1;
			if(qmn(st,mid,i)-S[i]>=0) p=mid,r=mid-1;
			else l=mid+1;
		}
		fa[i][0]=p-1,w[i][0]=val(p,i);
		for(int k=1;k<20;++k) {
			fa[i][k]=fa[fa[i][k-1]][k-1];
			w[i][k]=add(w[i][k-1],w[fa[i][k-1]][k-1]);
		}
	}
	cin>>q;
	for(int l,r;q--;) {
		cin>>l>>r;
		int p=r; ll s=0;
		for(int k=19;~k;--k) if(fa[p][k]>=l) s=add(s,w[p][k]),p=fa[p][k];
		s=add(s,val(l,p));
		cout<<s<<"\n";
	}
	return 0;
}
```

---

## 作者：是青白呀 (赞：0)

首先的转化是：原问题等价于，每次询问执行尽可能少的单点减 $D$ 的操作，不能减到负数，使得区间 $[L_j,R_j]$ 内的值单调不降。求最小操作次数。

对于一个固定的左端点 $l$，不难发现答案随着 $r$ 的增大而不降，且 $r$ 总是基于 $r-1$ 的情况下继续操作，故可以考虑离线后扫描右端点。

对于新加入的一个右端点 $r$，我们考虑从后往前遍历每个位置，对不合法的位置，减到恰好满足条件就停止。显然这样是最优的。若一个位置被减到了负数，则这个位置及它之前的所有位置都无解。此时可以得到一个 $O(n^2)$ 的算法。

一个重要的观察是：对于相邻的两个位置 $x,x+1$，若 $x$ 被操作过，则最终结果一定有 $C_{x+1}-C_{x}<D$。此时，若 $x$ 需要被操作 $y$ 次，则 $x-1$ 也要被操作 $y$ 次，即此后两者操作同步。

考虑合并操作同步的位置。具体地，我们用并查集维护所有操作同步的区间，对于当前轮已被操作的区间 $[x,r]$ 和未被操作的区间 $[l,x-1]$，先判断 $x$ 和 $x-1$ 之间是否合法。若合法，则区间 $[l,x-1]$ 及其之前的所有区间都不用操作，直接结束该轮；否则对区间 $[l,x-1]$ 进行贪心操作，并将两区间合并，然后继续判断下一个区间是否合法即可。注意到每一次区间操作都会合并两个区间，因此区间操作的次数不超过 $n-1$ 次，复杂度是可以接受的。

因此，对于每次新加进来的位置，都进行上述调整，即可构造出一个合法的序列。对于左端点在 $l$ 的一个查询，先判断 $l$ 处的值是否非负，若非负，则求出当前 $[l,r]$ 的区间和即可求得答案。总时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long 
using namespace std;
typedef long long ll;
const int N=3e5+5,M=105,inf=1e9+7,mo=998244353;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,d,a[N],m,suma[N];
vector<pii>q[N];
int ans[N];
struct seg{
	int t[4*N],tag[4*N];
	void pushup(int x){
		t[x]=t[ls(x)]+t[rs(x)];
	}
	void pushdown(int x,int le,int ri){
		int mid=(le+ri)>>1;
		tag[ls(x)]+=tag[x],tag[rs(x)]+=tag[x];
	    t[ls(x)]+=(mid-le+1)*tag[x];
	    t[rs(x)]+=(ri-mid)*tag[x];
	    tag[x]=0;
	}
	void modify(int x,int le,int ri,int ql,int qr,int v){
		if(ql<=le&&qr>=ri){
			t[x]+=v*(ri-le+1),tag[x]+=v;
			return;
		}
		pushdown(x,le,ri);
		int mid=(le+ri)>>1;
		if(ql<=mid)modify(ls(x),le,mid,ql,qr,v);
		if(qr>mid)modify(rs(x),mid+1,ri,ql,qr,v);
		pushup(x);
	}
	int query(int x,int le,int ri,int ql,int qr){
		if(ql<=le&&qr>=ri)return t[x];
		pushdown(x,le,ri);
		int mid=(le+ri)>>1,res=0;
		if(ql<=mid)res+=query(ls(x),le,mid,ql,qr);
		if(qr>mid)res+=query(rs(x),mid+1,ri,ql,qr);
		return res;
	}
}T;
struct bcj{
	int fa[N];
	void init(){
		rep(i,1,n)
		    fa[i]=i;
	}
	int find(int x){
		if(x==fa[x])return fa[x];
		return fa[x]=find(fa[x]);
	}
	void merge(int x,int y){
		x=find(x),y=find(y);
		if(x==y)return;
		if(x>y)swap(x,y);
		fa[y]=x;
	}
}B;
signed main(){
	read(n),read(d);
	rep(i,1,n)
	    read(a[i]),suma[i]=suma[i-1]+a[i];
	read(m);
	rep(i,1,m){
		int x,y;
		read(x),read(y);
		q[y].push_back(mp(x,i));
    }
    B.init();
    rep(i,1,n){
    	T.modify(1,1,n,i,i,a[i]);
    	int x=i-1;
    	while(x){
    		int nwv=T.query(1,1,n,x,x),nxtv=T.query(1,1,n,x+1,x+1);
    		if(nwv<=nxtv)break;
    		int tms=(nwv-nxtv-1)/d+1;
    		T.modify(1,1,n,B.find(x),x,-tms*d);
    		B.merge(x,x+1);
    		x=B.find(x)-1;
    	}
    	for(auto j:q[i]){
    		if(T.query(1,1,n,j.fir,j.fir)<0){
    			ans[j.sec]=-1;
    			continue;
    		}
    		ans[j.sec]=(suma[i]-suma[j.fir-1]-T.query(1,1,n,j.fir,i))/d;
    	}
    }
    rep(i,1,m)
        printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：Union_of_Britain (赞：0)

首先注意到问题等价于在 $\lang\{c_i-kD\}\rang$ 中选择和最大的递增子序列。显然，我干的事情就是每次选右边最大能选的。

然后画一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/w622bo8h.png?x-oss-process=image/resize,m_lfit,h_1700,w_2025)

注意到几个性质：

1.若做扫描线，只需维护最上面的线。

2.有相当多中间的线是“相似”的。

进一步：最上面一根线的相似关系改变（不再与下面相似）当 $c_i\ge c_{i-1}+D$。

当然重点是处理下降。下降时，前面的一根柱子需要不断转移到下面一根线。由于我们已经得知了和下面一根线的相似关系，我们可以维护若干（和下面一根线）相似的连续段，每次将连续段平移至需要的位置。之后。我们可能需要合并相似连续段。

还有一个小问题：搁浅了，没有下一根线怎么办（自然不存在相似）？这样的情况是不需要考虑的，因为这就是无解情况。

时间复杂度经过均摊是 $O(n\log n)$，由于需要对原序列区间减，查询和以及最小值。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=3e5+5,INF=1e9;
int n,D,q,c[maxn],L[maxn],ans[maxn],s[maxn];
int xds[maxn<<2],add[maxn<<2],mn[maxn<<2];
vector<int> e[maxn];
#define ls (k<<1)
#define rs (k<<1|1)
#define mid ((l+r)>>1)
void pushup(int k){xds[k]=xds[ls]+xds[rs],mn[k]=min(mn[ls],mn[rs]);}
void ADD(int k,int l,int r,int v){mn[k]+=v,xds[k]+=v*(r-l+1);add[k]+=v;}
void pushdown(int k,int l,int r){ADD(ls,l,mid,add[k]),ADD(rs,mid+1,r,add[k]);add[k]=0;}
void build(int k,int l,int r){
	if(l==r)return xds[k]=c[l],mn[k]=c[l],void();
	build(ls,l,mid),build(rs,mid+1,r);
	pushup(k);
}
void modify(int k,int l,int r,int x,int y,int v){
	if(x<=l&&r<=y)return ADD(k,l,r,v);
	pushdown(k,l,r);
	if(x<=mid)modify(ls,l,mid,x,y,v);
	if(mid<y)modify(rs,mid+1,r,x,y,v);
	pushup(k);
}
int query(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y)return mn[k];
	pushdown(k,l,r);
	int res=INF;
	if(x<=mid)res=min(res,query(ls,l,mid,x,y));
	if(y>mid)res=min(res,query(rs,mid+1,r,x,y));
	return res;
}
int query2(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y)return xds[k];
	pushdown(k,l,r);
	int res=0;
	if(x<=mid)res+=query2(ls,l,mid,x,y);
	if(y>mid)res+=query2(rs,mid+1,r,x,y);
	return res;
}
struct node{int l,r,vl,vr;};
bool cm(node a,node b){return a.vr+D>b.vl;}
node merge(node a,node b){return {a.l,b.r,a.vl,b.vr};}
bool cr(node a,node b){return a.vr>b.vl;}
node reduce(node a,node b){
	int d=(a.vr-b.vl+D-1)/D;
	a.vl-=d*D,a.vr-=d*D;
	modify(1,1,n,a.l,a.r,-d*D);
	return a;
}
node stk[maxn];int tp=0;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>D;
	for(int i=1;i<=n;i++)cin>>c[i],s[i]=s[i-1]+c[i];
	cin>>q;
	for(int i=1,R;i<=q;i++)cin>>L[i]>>R,e[R].push_back(i);
	build(1,1,n);
	for(int i=1;i<=n;i++){
		stk[++tp]={i,i,c[i],c[i]};
		while(tp>1&&(cm(stk[tp-1],stk[tp])||cr(stk[tp-1],stk[tp]))){
			if(cr(stk[tp-1],stk[tp]))stk[tp-1]=reduce(stk[tp-1],stk[tp]);
			else if(cm(stk[tp-1],stk[tp]))stk[tp-1]=merge(stk[tp-1],stk[tp]),tp--;
		}
		for(auto p:e[i]){
			int Mn=query(1,1,n,L[p],i),sum=query2(1,1,n,L[p],i);
			if(Mn<0)ans[p]=-1;
			else ans[p]=(s[i]-s[L[p]-1]-sum)/D;
		}
	}
	for(int i=1;i<=q;i++)cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：operator_ (赞：0)

# P10430 [JOISC 2024 Day1] 鱼 3

[题目传送门](https://www.luogu.com.cn/problem/P10430)

## 题解

赛时独立切了，写篇题解纪念一下。温馨提示：以下会出现大量数组名。

记原序列为 $a$。看这两个操作显然要差分得到 $b$，然后可以把操作倒序，于是变成：

操作 $1$：$b_i\leftarrow b_i-d$，$b_{i+1}\leftarrow b_{i+1}+d$。

操作 $2$：$b_i\leftarrow b_i-1$。

目标是使 $\sum\limits_{i=1}^l b_i=0$ 且 $\forall\  l< i\le r,b_i=0$。

因为操作 $2$ 不限次数，所以用操作 $1$ 将 $b$ 调整到非负整数后就没必要再操作了，我们用 $k_i$ 表示在位置 $i-1$ 进行了几次操作 $1$，那么基于上述结论，有 $k_{r+1}=0$，且 $\forall\  l\le i\le r,k_i=\max(0,\lceil\dfrac{k_{i+1}d-b_i}{d}\rceil)=\max(0,k_{i+1}-\lceil\dfrac{b_i}{d}\rceil)$。

其中我们记 $c_i=\lceil\dfrac{b_i}{d}\rceil$，则如果没有对 $0$ 取 $\max$ 的话我们就可以用二维前缀和求出 $k$ 的和，答案计算也就简单了，但是这里有对 $0$ 取 $\max$，我们需要特殊考虑。

我们把满足 $k_i=0$ 的点叫做碰壁点，那么当一个点被确定为碰壁点后，其它的 $k$ 其实也就随之确定了，而两个碰壁点之间的答案可以用上述方法求解，于是考虑倍增，维护 $nxt_{i,j}$ 表示若 $i$ 碰壁了，则之后第 $2^j$ 个碰壁点是谁。

接下来最后的问题就是怎么求一个碰壁点 $i$ 之后的下一个碰壁点 $j$。记 $s$ 是 $c$ 的前缀和，则该点应当是满足 $s_{i-1}-s_{j-1}\le 0,j<i$ 且最大的点，我们把其按 $s_{i-1}$ 排序，然后将序号插入 set 并查询即可。

想清楚实现起来应该不难，由于赛时代码太过于抽象就不放了。

---


# [JOIST 2024] 滑雪 2 / Ski 2

## 题目描述

JOI 先生管理着 IOI 高原上一家著名的滑雪度假村，他决定为滑雪度假村开业 15 周年庆祝活动而在相邻的 KOI 高原上建造一家新的滑雪度假村。

KOI 高原有 $N$ 个点，编号从 $1$ 到 $N$。目前，第 $i$ 个点（$1 \leq i \leq N$）的海拔高度为 $H_i$ 米，并且高原上的每个点都没有连接起来的滑道。此外，每个点都配备了一个未使用的连接设施。

JOI 先生的目标是在高原上的一个点上建造 KOI 酒店，然后建造一些滑道连接高原上的每个点，以便人们可以从任何一个点滑雪到酒店。具体来说，JOI 先生将按照以下步骤建造滑雪度假村：

1. 进行以下筑堤工作任意次数（可能为零）：选择一个点 $i$，将点 $i$ 的海拔高度增加 1 米。此工作的成本为每次操作 $K$。

2. 从 $N$ 个点中选择一个点，并在那里建造 KOI 酒店。

3. 进行以下扩展工作任意次数（可能为零）：选择一个点 $i$，在点 $i$ 建造一个连接设施。此工作的成本为每次操作 $C_i$。

4. 对于除了 KOI 酒店所在点之外的剩余 $N - 1$ 个点，执行以下构建：设 $i$ 为该点的编号。选择另一个海拔严格较低的点 $j$，并使用点 $j$ 的一个未使用的连接设施，从点 $i$ 向点 $j$ 构建单向滑道。注意，如果没有海拔严格较低且有未使用连接设施的点 $j$，则无法实现目标。

滑雪度假村的建造成本是进行堤岸工作和扩展工作的成本之和。

编写一个程序，给定 KOI 高原上每个点的信息和每次筑堤工作的成本 $K$，找到建造滑雪度假村的最小成本。


## 说明/提示

#### 样例解释 1

例如，可以按以下方式建造滑雪度假村：

1. 在点 $1$ 进行两次筑堤工作，在点 $5$ 进行一次。这些筑堤工作的总成本为 $2 \times (2 + 1) = 6$。每个点的海拔高度变为 $2, 1, 0, 2, 2$ 米。
2. 在点 $3$ 建造 KOI 酒店。
3. 在点 $2$ 进行两次扩展工作。这些扩展工作的总成本为 $1 \times 2 = 2$。结果，从点 $1$ 开始，每个点的连接设施数量变为 $1, 3, 1, 1, 1$。
4. 构建 $4$ 条滑道：一条从点 $1$ 到点 $2$，一条从点 $2$ 到点 $3$，一条从点 $4$ 到点 $2$，一条从点 $5$ 到点 $2$。

因此，构建滑雪度假村的成本为 $6 + 2 = 8$。由于无法以不超过 $7$ 的成本建造滑雪度假村，因此输出 $8$。

此样例输入满足子任务 $3,4,5,6$ 的约束条件。

#### 样例解释 2

这个样例输入与示例输入 1 的唯一区别在于 $K$ 的值。

这个样例输入满足子任务 $1, 3, 4, 5, 6$ 的约束条件。

#### 样例解释 3

此示例输入满足子任务 $2, 3, 4, 5, 6$ 的约束条件。

### 约束条件

- $1 \leq N \leq 300$
- $1 \leq K \leq 10^9$
- $0 \leq H_i \leq 10^9$（$1 \leq i \leq N$）
- $1 \leq C_i \leq 10^9$（$1 \leq i \leq N$）
- 给定的值均为整数。

### 子任务

- (5 分) $K \geq 100,000$，$H_i \leq 300$，$C_i \leq 100$（$1 \leq i \leq N$）
- (12 分) $H_1 \leq H_i$，$C_1 \leq C_i$，$H_i \leq 300$（$1 \leq i \leq N$）
- (9 分) $N \leq 10$，$H_i \leq 10$（$1 \leq i \leq N$）
- (33 分) $N \leq 40$，$H_i \leq 40$（$1 \leq i \leq N$）
- (27 分) $H_i \leq 300$（$1 \leq i \leq N$）
- (14 分) 无额外约束。

## 样例 #1

### 输入

```
5 2
0 6
1 1
0 5
2 1
1 2```

### 输出

```
8```

## 样例 #2

### 输入

```
5 100000
0 6
1 1
0 5
2 1
1 2```

### 输出

```
100010```

## 样例 #3

### 输入

```
8 8
0 36
1 47
2 95
0 59
1 54
0 95
1 87
2 92```

### 输出

```
108```

# 题解

## 作者：是青白呀 (赞：9)

喵喵喵，性质题。

首先是一个最基本的观察：

> 性质 $1$：对于同一个点，不可能既抬高海拔，又加装新的连接设施。

考虑反证：不妨设 $x$ 点抬高海拔后连边向 $y$，连向 $x$ 的其中两个点为 $a$ 和 $b$，且 $a$ 海拔较低。显然在抬高海拔前，$H_x<H_y$。若 $C_x<C_y$，则可以放弃抬高海拔的操作，直接将 $y$ 改连向 $x$，将 $a,b$ 中的任意一个改连向 $y$；否则可以将 $a,b$ 中的任意一个改连向 $y$，两种情况的修改下，花费均更小。

> 性质 $2$：存在一种最优策略，使得每一个高度上都至少有 $1$ 个点不被抬高，且这个点一定是该高度上 $C$ 最小的点。

首先，我们显然不可能抬高所有点，让该高度空置。其次，若有若干个点被抬高到当前高度，则不难发现，保留原来就在这个高度的点一定更优，因为他们都会为更高的位置提供 $1$ 个免费设施，保留原来就在这个高度的点可能能提供 $C$ 更小的新增设施的选择。因此我们可以在每个高度上保留 $C$ 最小的点。

此时可以开始考虑 dp。我们按高度从低到高扫描，设 $dp_{i,j,k}$ 表示考虑到高度 $i$，前面的有效接口数量为 $j$，之前的所有高度中，有 $k$ 个点被拔高到了该位置，且还要继续拔高的最小花费。下面考虑 $i$ 向 $i+1$ 的转移。

- 不妨首先将高度 $i+1$ 处的 $cnt_{i+1}$ 个点和 $j$ 合并，得到的新状态是 $dp_{i+1,j,k+cnt_{i+1}}$，代价是 $k\times K$。

- 枚举连到现有接口的点数 $x\leq j$，得到的新状态是 $dp_{i+1,j,k+cnt_{i+1}-x}$，代价不变。

- 枚举在前面新增接口的点数 $y\leq k+cnt_{i+1}-x$，得到的新状态是 $dp_{i+1,j+y,k+cnt_{i+1}-x-y}$。设 $minc_i$ 表示高度 $i$ 及之前的所有点中最小的 $C$，根据性质 $1$ 和性质 $2$，不难得出此步的代价为 $y\times minc_i$。

综上，我们对每个状态枚举 $x,y$，可得到转移 $dp_{i+1,j+y,k+cnt_{i+1}-x-y}\gets dp_{i,j,k}+y\times minc_i+k\times K$。复杂度 $O(n^4H)$，需要继续找性质优化。

> 性质 $3$：每一个高度都一定会尽可能用完上一个高度留下来的所有 $j$ 个免费设施。

原因很显然：使用一个免费设施后，自己也会产生一个新的免费设施位置，不会使得免费位置减少，所以能用就用。因此 $x$ 的枚举可以去除，直接根据 $j$ 和 $k+cnt_{i+1}$ 的大小分类转移即可。

还可以发现的是，$y$ 带来的代价是一个类似完全背包的东西，因而我们从小往大枚举 $j$，从大往小枚举 $k$，在 $j<k+cnt_{i+1}$ 的情况下（此时 $x=j$）新增内部转移 $dp_{i+1,j+1,k+cnt_{i+1}-j-1}\gets dp_{i+1,j,k+cnt_{i+1}-j}+minc_i$ 即可去除 $y$ 的枚举。此时复杂度来到 $O(n^2H)$。

最后一步显然是离散化高度。考虑哪些高度是有效的。

> 性质 $4$：有效的高度是不增加任何额外设施，仅将所有点在高度上往后排开，每个高度安排一个点，得到的所有有点的高度。

这些高度显然是必要的，它们对应只增加海拔而不新建设施的方案。充分的原因是，根据性质 $2$ 和性质 $3$，若新建了一个额外设施，则每个点的实际高度会往回缩，填满新建额外设施带来的新的可行位置；而这些点显然不能缩得比原始高度更低。不难发现，该性质中提到的有效高度，覆盖了往回缩的过程中会遇到的所有高度，因此这些高度是足够的。

此时，我们可以将所有有效高度离散化至 $O(n)$ 级别，总复杂度即可做到 $O(n^3)$。

需要注意的是，转移中 $k\times \Delta H\times K$ 可能达到 $10^{21}$ 级别，但不难通过抬高除酒店位置外所有最低点的海拔 $1$，并将所有点直接连向酒店的方式得到一个代价不超过 $10^{12}$ 的解，因而在 dp 过程中将所有出现的值对 $10^{12}$ 取 $\min$ 即可避免超过 long long 的范围。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long 
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=305,M=105,inf=(ll)1e18+7,mo=998244353;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int upp=(ll)1e12;
int n,co,h[N],lsh[N],cntl,c[N];
int dp[N][N][N],minc[N],cntp[N],sumc[N];
signed main(){
	read(n),read(co);
	rep(i,1,n)
	    read(h[i]),read(c[i]),lsh[++cntl]=h[i];
	sort(lsh+1,lsh+cntl+1);
	rep(i,2,cntl)
	    lsh[i]=max(lsh[i],lsh[i-1]+1);//离散化，将点铺开
	rep(i,1,n)
	    h[i]=lower_bound(lsh+1,lsh+cntl+1,h[i])-lsh;
	rep(i,1,cntl)
	    minc[i]=inf;
	rep(i,1,n)
	    cntp[h[i]]++,minc[h[i]]=min(minc[h[i]],c[i]);
	minc[0]=inf;   
	rep(i,1,cntl)
	    minc[i]=min(minc[i],minc[i-1]),sumc[i]=sumc[i-1]+cntp[i];
	rep(i,0,cntl){
		rep(j,0,n+2){
			rep(k,0,n+2)
			    dp[i][j][k]=upp;
		}
	}
	dp[1][1][cntp[1]-1]=0;
	rep(i,1,cntl-1){
		rep(j,0,n){
			repp(k,max(0ll,sumc[i]-1),0){
				int nk=k+cntp[i+1],niv;
				if(k&&(lsh[i+1]-lsh[i])*co>upp)niv=upp+1;
				else niv=k*(lsh[i+1]-lsh[i])*co;
				if(!i)nk--;
				if(nk<=j)dp[i+1][j][0]=min(dp[i+1][j][0],dp[i][j][k]+niv);
				else{
					dp[i+1][j][nk-j]=min(dp[i+1][j][nk-j],dp[i][j][k]+niv);
					dp[i+1][j+1][nk-j-1]=min(dp[i+1][j+1][nk-j-1],dp[i+1][j][nk-j]+minc[i]);
				}
			} 
		}
	}
	int ans=inf;
	rep(j,0,n)
	    ans=min(ans,dp[cntl][j][0]);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：6)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18246128)

### [P10432 [JOISC 2024 Day1] 滑雪 2](https://www.luogu.com.cn/problem/P10432)

感觉是挺好的观察性质题，vp 的时候场切了。

首先酒店一定是建在最低的某一个点。把高度离散化之后，把点扔到对应的位置。可以发现高度为 $i$ 的层的所有点，如果能接上一层的连接器那一定会尽量接上（因为到了下一层它本身也可以贡献一个空的连接器）。

设 $v_i$ 是高度为 $i$ 的点里最小的 $C$，则从 $1\sim i$ 的高度中选择一个搭连接器的代价就是 $\min_{1\leq j\leq i} v_j$。原因很简单，$i-1$ 层一定会有若干个未用的连接器，相同情况下肯定是对 $C$ 较大的对他进行升高高度的操作，所以 $C$ 最小的一定会留在当前层。

这样就可以 DP 了。设 $f_{i,j,k}$ 表示当前高度在第 $i$ 层，前 $i-1$ 层有 $j$ 个连接器可用，并且有 $k$ 个高度小于 $i$ 的点的高度被加到了 $i$ 的最小代价。

假设当前层有 $x$ 个点，直接把每个 $k$ 加上 $x$ 即可。转移可以从 $1\sim i-1$ 新建一个连接器上来转移到 $f_{i,j+1,k}$，可以不再新建直接往下转移到 $f_{i+1,j,\max(0,k-(h_{i+1}-h_i-1)\times j)}$。总复杂度是 $\mathcal O(n^3)$。

有一个小细节，因为 $i$ 层加连接器的时候只能从前 $i-1$ 层建，所以离散化的数组里不仅需要有 $h_j$，还应有 $h_{j+1}$。代码找不到了 QwQ。

---

## 作者：dadaaa (赞：3)

## [P10432](https://www.luogu.com.cn/problem/P10432)

~~首先认真读题，注意每个点都先有了一个未使用的连接设施。（本人太蠢了没看到懵了好久）~~

其实操作按不按顺序意思都一样。

我们思考有什么连接的方法。如果没有向上的提的操作，那么就是一个类似于最小生成树 (/?) 的东西，按顺序决策连边就行。

但是如果你提上去了，这时候就没有一定的决策顺序了，于是我们不得不发现一些性质。

>  注意到，当我们将一个点提上去以后，这个点就不会多建连接设施了。

如果将 $x$ 提上去到 $H_y+1$ 的高度并且向 $y$ 连边时，若 $C_y \le C_x$，那连 $x$ 非免费连接设施的点一定连 $y$ 非免费连接设施更优。否则，将 $y$ 连 $x$ 一定不差，至于已经连 $y$ 非免费设施的点，那也连 $x$ 非免费设施更好。

因此在同一个高度下新建连接设施的点一定是原本在这个高度下新建连接设施代价最小的。

这启发我们扫描高度进行 dp，但我们如何决定在哪个点为根呢？

> 一定在深度最小的点中新建免费设施最小的点为根。

因为你可以建免费设施，所以如果这个点还要提到根上面，不如直接让根连接这个点的免费连接设施，其他情况照样不影响，这样一定不劣。

但是 $H$ 值域是 $10^9$ 的，我们于是想到离散化。

考虑最极端情况，我们直接每个点只是疯狂地往上提，直到蹭到免费设施在连边，对涉及到的高度离散化就行了。

于是，设 $dp[i][j][k]$ 表示当前在 $i$ 高度，这层高度有 $j$ 个接口，推到 $i+1$ 高度的点有 $k$ 个。

1. 这一层多一个接口：

   $dp[i][j][k] + mnc[i] \to dp[i][j+1][k]$

2. 往上走一格：

   $dp[i][j][k] + K \times k \times (tmh[i+1]-tmh[i]) \to dp[i+1][j][max(k+cnt[i+1]-j,0)]$

$mnc[i]$ 表示原始在这一高度的点的最小增加接口的代价，$cnt[i]$ 表示原始在这一高度的点的数量，$tmh[i]$ 是个人离散化习惯（虽然好像这是没有必要的，因为当到一个有跨度的位置时是一定不会再向上提的，直接让上面那个点连这个点的免费接口就好了）。

复杂度 $O(n^3)$。

注意：有些值算的可能很大（？可能是我上面离散化那个操作太傻了），写的时候小心一点。

#### 代码：

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 310;
const ll lnf = 1e15;
int n;
int h[N];
int tmpx[N], cntx, cnt[N];
ll K, mnc[N], c[N];
ll dp[N * 2][N][N];
unordered_set<ll> use;
int main() {
	cin >> n >> K;
	for (int i = 1; i <= n; i++) {
		cin >> h[i] >> c[i];
		tmpx[i] = h[i];
		while (use.find(tmpx[i]) != use.end()) tmpx[i]++;
		use.insert(tmpx[i]);
	}
	sort(tmpx + 1, tmpx + 1 + n);
	tmpx[cntx = n + 1] = tmpx[n] + 1;
	for (int i = 1; i <= cntx; i++) mnc[i] = 1e9;
	for (int i = 1; i <= n; i++) {
		h[i] = lower_bound(tmpx + 1, tmpx + 1 + cntx, h[i]) - tmpx;
		mnc[h[i]] = min(mnc[h[i]], c[i]);
		cnt[h[i]]++;
	}
	memset(dp, 0x3f, sizeof(dp));
	dp[1][1][cnt[1] - 1] = 0;
	for (int i = 1; i < cntx; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 0; k <= n; k++) {
				dp[i][j][k] = min(dp[i][j][k], lnf);
				dp[i][j + 1][k] = min(dp[i][j + 1][k], dp[i][j][k] + mnc[i]);
				int l = max(0, cnt[i + 1] + k - j);
				if ((__int128_t)K * k * (tmpx[i + 1] - tmpx[i]) < lnf) {
					dp[i + 1][j][l] =
						min(dp[i + 1][j][l], dp[i][j][k] + K * k * (tmpx[i + 1] - tmpx[i]));
				}
			}
		}
	}
	ll ans = 1e18;
	for (int i = 0; i <= n; i++) ans = min(ans, dp[cntx][i][0]);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：Purslane (赞：3)

# Solution

性质：如果最终 $u$ 是 $v$ 的父亲，那么 $h_u \le h_v$。

证明：

若 $c_u \ge c_v$，考虑进行下图变换，肯定不劣。

![](https://s21.ax1x.com/2024/06/05/pkYp2Pe.png)

（点权相应修改）

若 $c_u < c_v$，考虑进行下图变换，肯定不劣。

![](https://s21.ax1x.com/2024/06/05/pkYpR8H.png)

对于本题，考虑按照原有深度逐层加点。

假设当前我们考虑了所有高度 $\le i$ 的节点，目前的叶子节点有 $j$ 个接口，我们将 $k$ 个高度 $\le i$ 的节点暂时高度调整为 $i+1$ 且还没有接入树的最小代价为 $dp_{i,j,k}$。

这时我们加入了 $cnt$ 个高度为 $i+1$ 的点。基本的贪心告诉我们，现在尽量把接口给占满，剩余的调整为 $i+2$。

因此我们可以加入 $cnt+k - \max\{0,cnt+k-j\}$ 个点。转移为：

$$
dp_{i,j,k} + K \times \max\{0,cnt+k-j\} \to dp_{i+1,j,\max\{0,cnt+k-j\}}
$$

如果我们现在想要扩充接口数量怎么办？重要的观察是，对于那 $k$ 个被推迟的点，不应该在此处扩容——如果他们要扩容，早就应该交给和他们原始高度相同的点来完成了。因此，我们要用 $\min_{1 \le t \le n,h_t = i+1} \{c_t\}$ 的代价来增加接口数。这就是一个简单的完全背包问题。

我们显然要对第一维进行离散化。而观察到真正有价值的每一层，至少会把一个节点加入树，因此将 $h$ 排序，执行 $k_i = \max\{k_{i-1},h_i\}$，把所有 $k$ 进行离散化即可。

代码比较简短：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=300+10;
int n,K,pre,lst=-1,h[MAXN],c[MAXN],tot,lsh[MAXN],cnt[MAXN],dp[MAXN][MAXN][MAXN],mn[MAXN];
map<int,int> mp;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>K,memset(mn,0x3f,sizeof(mn)),memset(dp,0x3f,sizeof(dp));
	ffor(i,1,n) cin>>h[i]>>c[i],mp[h[i]]++;
	for(auto pr:mp) {
		if(lst!=-1) {
			int dt=min(pr.first-lst,pre);
			ffor(j,lst,lst+dt-1) lsh[++tot]=j;
			pre-=dt;
		}
		pre+=pr.second,lst=pr.first;
	}
	ffor(j,1,pre) lsh[++tot]=lst+j-1;
	ffor(i,1,n) cnt[i]=mp[lsh[i]];
	ffor(i,1,n) {
		int id=lower_bound(lsh+1,lsh+n+1,h[i])-lsh;
		mn[id]=min(mn[id],c[i]);
	}
	dp[0][1][0]=0;
	ffor(i,0,n-1) {
		ffor(j,0,n) ffor(k,0,n) if(dp[i][j][k]!=0x3f3f3f3f3f3f3f3f) {
			int l=max(0ll,cnt[i+1]+k-j);
			dp[i+1][j][l]=min(dp[i+1][j][l],dp[i][j][k]+K*l); 
		}
		ffor(j,1,n) ffor(k,0,n) dp[i+1][j][k]=min(dp[i+1][j][k],dp[i+1][j-1][k]+mn[i+1]);
	}
	int ans=LONG_LONG_MAX;
	ffor(i,0,n) ans=min(ans,dp[n][i][0]);
	cout<<ans;
	return 0;
}
```

---

## 作者：_Cheems (赞：1)

题意：$n$ 个点，高度为 $h_i$，可以花费 $K$ 让 $h_i\gets h_i+1$。起初每个点有一个装置，花费 $c_i$ 增置一个（任意次）。若 $h_i>h_j$ 且 $j$ 有装置，则可以花费一个并连接 $i\to j$。求最小花费，使得存在一个点可以被所有点到达。$n\le 3\times 10^2$。

相当于连成内向树。

考虑按高度逐个扫描，记 $f_{i,j,k}$ 为考虑 $\le i$ 的高度，有 $j$ 个闲置接口，$k$ 个点现在高 $i$ 且准备抬到 $i+1$（这些点尚未加入树），的最小花费。初始化就是 $f_{0,1,0}=0$ 表示可以选一个根。

考虑 $i$ 向 $i+1$ 转移。首先，需加入 $i+1$ 高度上的原有的点，同时将 $k$ 个点花费 $k\times K$ 的代价抬高。

然后注意到一个性质：$j$ 个闲置接口一定尽量用完。因为用一个后它自己也会产生一个，所以 $j$ 不变。相当于白嫖。而且早晚都要连，延迟连边没有任何好处还带来额外代价。

最后考虑新增接口，形如完全背包，那么现在的问题是新增一个接口的花费？发现每一轮我们至少将 $1$ 个点连入树上，那么我肯定选择连接新增的点中 $c$ 最小的。对于原来抬上来的点，就算它的 $c$ 可能更小我们也无需考虑，因为在它的那一轮有更小的 $c$ 已经被计算了。综上代价即为 $\min\limits_{h_p\le i+1}c_p$。 

转移很朴素可以看代码。

现在是 $O(n^2H)$ 的。考虑离散化高度，因为每轮至少连入一个点，所以有用的高度只有将所有点从原先高度上向右依次排开的高度。变成 $O(n^3)$。

实现时注意转移代价可能超出 `long long`，特判一下。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define i128 __int128
#define MIN(a, b) a = min(a, b)
const int N = 3e2 + 5, inf = 1e12;
const i128 qwq = 1;
int n, K, h[N], c[N], m, idw[N], f[N][N][N];
map<int, bool> mp;
map<int, int> ct, mc;

signed main(){
    cin >> n >> K;
    for(int i = 1; i <= n; ++i){
        scanf("%lld%lld", &h[i], &c[i]);
        int hh = h[i];
        ++ct[hh]; 
        while(mp.count(hh)) ++hh;
        mp[hh] = true, idw[++m] = hh, mc[hh] = inf;  
    }
    for(int i = 1; i <= n; ++i) MIN(mc[h[i]], c[i]); 
    sort(idw + 1, idw + 1 + m);
    memset(f, 0x3f, sizeof f); f[0][1][0] = 0;
    for(int i = 1, mi = inf; i <= m; ++i){
        int cnt = ct[idw[i]];
        for(int j = 1; j <= n; ++j)
            for(int k = 0; k <= n - cnt; ++k){
                if(qwq * (idw[i] - idw[i - 1]) * k * K > inf) continue;
                MIN(f[i][j][k + cnt - min(j, k + cnt)], f[i - 1][j][k] + (idw[i] - idw[i - 1]) * k * K);
            }
        mi = min(mi, mc[idw[i]]);
        for(int j = 1; j < n; ++j)
            for(int k = 0; k <= n; ++k)
                MIN(f[i][j + 1][k], f[i][j][k] + mi);
    }
    int ans = inf;
    for(int i = 1; i <= n; ++i) MIN(ans, f[m][i][0]);
    cout << ans;
    return 0;
}
```

---

## 作者：Chy12321 (赞：1)

[$\mathcal{MY~BLOG}$](https://www.cnblogs.com/chy12321/p/18213414)


首先，不存在 $H_i < H_j$ 时增高 $H_i$ 至 $H_j + 1$ 后连 $i \to j$ 更优，因为增高后原来能连 $i$ 的点现在不一定能连 $i$ 了，原来能连 $j$ 的点还是能连 $j$，此时的方案集必然是原方案集的子集，答案一定不会更优，又因为你付出了增高的费用，所以这样一定劣。

那么我们就只会对存在 $j \ne i$，满足 $H_j = H_i, C_j \le C_i$ 的点 $i$ 增高。

所以可以把高度离散化到 $O(n)$ 个，留 $H_i, H_i + 1$​ 即可。

考虑 DP。

增高是不好判断的，考虑通过状态上的限制来完成增高。

我们以高度为横轴，相同高度按 $C_i$ 填点。

样例就可以画成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/bdyhyuaz.png)

最后出答案的图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/3k0fk09e.png)

记图上第 $i$ 个高度下的最大纵坐标为 $y_i$，则对于任一高度 $j$，其所能容纳的最多无需付费的点的数量就是 $\max\limits_{k=0}^{j-1} y_k$，记这个数量为 $t_j$，显然 $t_j$ 不降。

我们考虑限制 $t_j$ 来使得一些点被迫增高。

设 $f(i, j, k)$ 表示填完前 $i - 1$ 个高度，现在在填第 $i$ 个高度，此前所有高度的 $y$ 的最大值为 $j$，前 $i - 1$ 个高度给当前高度剩了 $k$ 个点的最小花费。

初值：$f(i, j, k) = +\infin, f(0, 1, 0) = 0$；答案：$\min\limits_{j=1}^n f(m, j, 0)$，其中 $m$ 为离散化后的高度数。

我们可以通过付出 $mn$ 的代价来增加一个连接装置，使 $t_i$ 增加 $1$，至于哪个点增加，贪心选最小的即可。记 $mn$ 为高度小于第 $i$ 个高度的点中 $C_i$ 的最小值，则有：
$$
f(i, j, k) + mn \to f(i, j + 1, k)
$$
然后就是填点：
$$
f(i, j, k) + F(j, h_{i+1} - h_i, k + cnt_i) \times K \to f(i + 1, j, \max\{k + cnt_i - (h_{i+1} - h_i)j, 0\})
$$
其中 $F(n, m, k)$ 表示将 $k$ 个点放到最大点数为 $m$ 的个 $n$ 个高度中的增高操作次数，显然可以 $\mathcal O(1)$ 计算。

$f(i, j, k)$ 可以滚动掉 $i$ 一维，但没必要。

时间复杂度 $\mathcal O(n^3)$。

代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

constexpr int N = 310;
constexpr ll INF = 0x3f3f3f3f3f3f3f3f;

int n, h[N], c[N], cnt[N << 1], mnc[N << 1];
ll K, f[N << 1][N][N];

vector<int> hs;

inline ll F(int n, int m, int k) {
	n = min(n, k / m);
	return n * (n - 1) / 2 * m + n * (k - n * m);
}

inline void chkmin(int &lhs, int rhs) {lhs = min(lhs, rhs);}
inline void chkmin(ll &lhs, ll rhs) {lhs = min(lhs, rhs);}

int main() {
	ios_base::sync_with_stdio(0); cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> K;
	for (int i = 1; i <= n; i++) cin >> h[i] >> c[i], hs.emplace_back(h[i]), hs.emplace_back(h[i] + 1);
	sort(hs.begin(), hs.end()); hs.erase(unique(hs.begin(), hs.end()), hs.end());
	memset(mnc, 0x3f, sizeof(mnc));
	for (int i = 1; i <= n; i++) {
		h[i] = lower_bound(hs.begin(), hs.end(), h[i]) - hs.begin();
		cnt[h[i]]++, chkmin(mnc[h[i]], c[i]);
	}
	memset(f, 0x3f, sizeof(f)), f[0][1][0] = 0;
	int m = hs.size(), mn = 2e9;
	for (int i = 0; i < m; i++) {
		int wid = i + 1 < m ? min(n, hs[i + 1] - hs[i]) : n;
		for (int j = 1; j <= n; j++) {
			for (int k = 0; k <= n; k++) if (f[i][j][k] < INF) {
				chkmin(f[i][j + 1][k], f[i][j][k] + mn);
				chkmin(f[i + 1][j][max(k + cnt[i] - wid * j, 0)], f[i][j][k] + F(wid, j, k + cnt[i]) * K);
			}
		}
		mn = min(mn, mnc[i]);
	}
	ll ans = INF;
	for (int j = 1; j <= n; j++) ans = min(ans, f[m][j][0]);
	cout << ans;
	return 0;
}
```

---

## 作者：daduoli (赞：0)

做了好久，但是好歹是我自己做出来的。

因为和位置没关系，先对高度进行排序，从小到大。

显然我们将酒店设在最矮的地方。

我们继续考虑显然如果我们要新建连接设施，一定是建在前缀中 $C$ 最小的位置。

而对于升高海拔接在某些点后面的操作，我们考虑假如 $x_u'\to x_w'\to x_v',x_u\le x_v\le x_w$，其中 $x_u$ 表示前 $u$ 这个点原高度，而 $x_u'$ 表示最后的高度。

如果存在上面这种情况，显然选择 $u\to v\to w$ 显然不劣。

所以我们考虑记 $f_{i,j,q}$ 表示前面有 $j$ 个可以连接，然后有 $q$ 个下放的后面了。

当然可能新建一些连接设施，可以直接从 $f_{i,j,q}\to f_{i,j+1,q-1}$，这个是容易的，原本我想这是枚举新建多少个，但是显然差分建造是方便的，这样复杂度就不是 $O(n^4)$，而是 $O(n^3)$ 的了。

至于其他的细节不多。

不过我们离散化之后，如果高度为 $x$ 的有 $t$ 个，那么 $x+1,x+2\dots x+t-1$ 也要加入我们的离散化数组中。

总时间复杂度 $O(n^3)$。


```
#include<bits/stdc++.h>
#define Yzl unsigned long long
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
typedef long long LL;

using namespace std;

const Yzl Lty=20120712;

const int MAXN=310,inf=1e9+1;
int n;
LL K;
struct ddl {
	LL x,y;
}a[MAXN];
bool cmp(ddl a,ddl b) {
	if(a.x!=b.x) return a.x<b.x;
	return a.y<b.y;
}
map<LL,LL> ma,mb,mc;
int ind[MAXN],sum[MAXN],bb[MAXN],cnt;
LL f[MAXN][MAXN][MAXN];
int main () {
	scanf("%d%lld",&n,&K);
	for(int i=1;i<=n;++i) {
		scanf("%lld%lld",&a[i].x,&a[i].y);
		LL ls=a[i].x; 
		while(ma.count(ls)) {
			++ma[ls];
			++ls;
		} ++ma[ls];
		if(!mb.count(a[i].x)) mb[a[i].x]=a[i].y;
		else mb[a[i].x]=min(mb[a[i].x],a[i].y);
		++mc[a[i].x];
	}
	for(auto t:ma) {
		ind[++cnt]=t.fi;
		sum[cnt]=mc[t.fi]; bb[cnt]=inf;
		if(mb.count(t.fi)) bb[cnt]=min(bb[cnt],(int)mb[t.fi]);
	}
	for(int i=0;i<=n;++i) {
		for(int j=0;j<=n+2;++j) {
			for(int q=0;q<=n+2;++q) {
				f[i][j][q]=1e15;
			}
		}
	}
	f[1][1][sum[1]-1]=0; LL tb=bb[1];
	for(int i=2;i<=cnt;++i) {
		for(int j=1;j<=n+1;++j) {
			for(int q=0;q<=n;++q) {
				int tt=q+sum[i];
				if(tt>n) continue;
				LL ls=f[i-1][j][q]+(LL)q*(ind[i]-ind[i-1])*K;
				tt=max(tt-j,0);
				if(ls<1e18&&(!q||(ind[i]-ind[i-1])*K<=1e13)) f[i][j][tt]=min(f[i][j][tt],ls);
				if(f[i][j][tt]<1e18&&tt) f[i][j+1][tt-1]=min(f[i][j+1][tt-1],f[i][j][tt]+tb);
			}
		} tb=min(tb,(LL)bb[i]);
	} LL ans=1e18;
	for(int i=0;i<=n+1;++i) ans=min(ans,f[cnt][i][0]);
	printf("%lld\n",ans);
	return 0;
}

```

---


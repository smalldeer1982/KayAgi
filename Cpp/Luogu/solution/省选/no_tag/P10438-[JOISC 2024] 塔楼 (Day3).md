# [JOISC 2024] 塔楼 (Day3)

## 题目描述

IOI Tower 是一座极其高的塔楼，配备了一条用于上升的楼梯。这个楼梯由 $10^{100}$ 个台阶组成，从底部开始依次编号为第 $0$ 级、第 $1$ 级，依此类推。JOI 君目前在第 $0$ 级，并打算爬楼梯。JOI 君可以通过以下两种方式上楼，禁止下楼。

- 上升 $1$ 级。这个动作需要 $A$ 秒。
- 从当前级别跳到上方 $D$ 级，跳过中间的台阶。这个动作需要 $B$ 秒。

目前，楼梯的几个位置正在进行施工，正在施工的台阶不能踩上去。具体来说，有 $N$ 处正在进行施工，第 $i$ 处施工（$1 \leq i \leq N$）正在进行的台阶为 $L_i$ 到 $R_i$。

IOI Tower 有 $Q$ 个房间，编号从 $1$ 到 $Q$。人们可以从楼梯的第 $X_j$ 级进入第 $j$ 个房间（$1 \leq j \leq Q$）。因此，JOI 君决定确定他是否可以到达每个房间，如果可能的话，以最短时间需要多少秒到达。

给出关于 JOI 君、施工和房间的信息，创建一个程序，确定 JOI 君是否可以到达第 $j$ 个房间（$1 \leq j \leq Q$），如果可能的话，计算需要的最短时间。


## 说明/提示

#### 样例解释 1

JOI 君可以按照以下步骤在 $120$ 秒内到达楼梯的第 $13$ 阶：

- 从第 $0$ 阶到第 $1$ 阶上升。此操作需要 $10$ 秒。
- 从第 $1$ 阶到第 $2$ 阶上升。此操作需要 $10$ 秒。
- 从第 $2$ 阶到第 $3$ 阶上升。此操作需要 $10$ 秒。
- 从第 $3$ 阶跳到第 $7$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。
- 从第 $7$ 阶到第 $8$ 阶上升。此操作需要 $10$ 秒。
- 从第 $8$ 阶到第 $9$ 阶上升。此操作需要 $10$ 秒。
- 从第 $9$ 阶跳到第 $13$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。

由于无法在小于 $120$ 秒内到达第 $13$ 阶楼梯，输出为 $120$。

这个样例输入满足子任务 $1,2,4$ 的约束条件。

#### 样例解释 2

这个样例输入满足子任务 $1,2,4$ 的约束条件。

### 约束条件

- $1 \leq N \leq 200,000$
- $1 \leq Q \leq 200,000$
- $1 \leq D \leq 10^{12}$
- $1 \leq A \leq 1,000,000$
- $1 \leq B \leq 1,000,000$
- $1 \leq L_i \leq R_i \leq 10^{12}$（$1 \leq i \leq N$）
- $R_{i}+1 < L_{i+1}$（$1 \leq i \leq N-1$）
- $1 \leq X_j \leq 10^{12}$（$1 \leq j \leq Q$）
- 给定值均为整数。

### 子任务

1. （5 分）$R_i \leq 1,000,000$（$1 \leq i \leq N$），$X_j \leq 1,000,000$（$1 \leq j \leq Q$）
2. （38 分）$N \leq 2,000$，$Q \leq 2,000$
3. （25 分）$A = 1$，$B = D$
4. （32 分）无额外约束。

## 样例 #1

### 输入

```
3 1
4 10 35
4 5
10 12
14 14
13```

### 输出

```
120```

## 样例 #2

### 输入

```
5 10
10 1 9
7 11
25 32
37 38
43 44
50 52
6
12
18
24
30
36
42
48
54
60```

### 输出

```
6
11
17
22
-1
33
-1
44
-1
55```

# 题解

## 作者：daduoli (赞：4)

> 一蓑烟雨里 春光不觉老
>
> 折扇挑珠帘 依稀闻童谣
>
> 东风却远送 小径人寥寥
>
> 桃花探杯中 谁家女郎笑
>
> —————⌈岁时记⌋

没人发题解，我来水一发。

---

首先容易想到对于 $D\times A\le B$ 以及 $D\times A>B$ 的情况分开来讨论。

我们先来考虑 $D\times A\le B$ 的情况，这种情况相对好处理很多。

容易知道，我们的图是若干段不施工的区域合并起来的，我们记 $l_i,r_i$ 分别表示第 $i$ 段不施工的区域。

那么我们现在想尽可能的少用操作 $2$，考虑记 $cnt_i$ 表示走到第 $i$ 段至少要用多少次 $2$ 操作，不过需要注意，对于第 $i$ 段而言，可能会出现一段前缀是无法到达的，我们记 $L_i$ 表示第 $i$ 段施工的区域可以被到达的最左边的位置。

然后对于询问 $x$，我们二分出它在哪一段不施工区域中，然后判断一下可达性即可。

这一部分的复杂度是 $O(n\log n)$ 的，也是相对简单的。

---

接下来考虑 $D\times A>B$ 的情况，这种情况我们需要尽可能多的使用 $2$ 操作。

显然只有在某个 $[L_i,r_i]$ 中的位置才是有用的。

我们考虑动态规划，记 $f_i$ 表示到 $i$ 最多使用多少次操作 $2$。

考虑一个块中的 $f$ 长什么样。

![](https://cdn.luogu.com.cn/upload/image_hosting/m3xsyj2k.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

看上去好像是上面这么一回事，$f_{x+D}$ 直接就是 $f_x+1$，但是实际上 $f_{x+D}$ 可以直接从 $f_{x+D-1}$ 转移过来，所以还是非常难做。

我们现在卡住了，没有更多很好的想法了，找点性质。

> 一个段中前 $D$ 个元素，记他为第 $y$ 个，满足 $f_{1\sim y}=x,f_{y+1\sim D}=x+1$ 

考虑证明（证明比较感性，不严谨，看看就好了，不看也可以，直接跳了）：

>假设 $f_y=x,f_{y+1}=x+k(k>1)$，考虑本质上为什么 $f_y$ 会比 $f_{y+1}$ 少，因为我们 $1$ 操作走了太多了，也就是 $1$ 操作浪费了太多步数。
>
>我们记 $g_y$ 表示 $y$ 执行 $1$ 的次数，$g_{y+1}$ 为 $y+1$ 执行 $y$ 的次数，那么 $f_{y+1}-f_y=k$，也就是说 $g_{y+1}-g_y\ge D$，而倘若浪费的步数比 $y+1$ 的方案多 $D$，那么实际上我们是可以在中途切换到 $y+1$ 的方案，可以看下面这个图。（因为我们想要观察的是 $g_y,g_{y+1}$ 的相对性，所以我们钦定 $g_{y+1}=0$。）
>
>![](https://cdn.luogu.com.cn/upload/image_hosting/zb6ko3gx.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
>
>我们倒着看，绿色点表示红色要走到这点才能进行二操作，也就是要浪费绿色点和红色点间距离的 $1$ 操作，那么当浪费的操作 $\ge D$ 时，就可以碰到 $y+1$ 路径上的点了，也就说明按 $y+1$ 那样走是可以更新到我们原本 $y$ 路径上的点的，同时还能少浪费 $D$ 次 $1$ 操作。所以是对的。

也就是一个段前 $D$ 个元素中存在一个分界点使其左边的 $f$ 为 $x$，右边的 $f$ 为 $x+1$。

而因为值只差 $1$，所以我们可以直接令 $f_{x+D}$ 从 $f_x+1$ 转移过去，一定不劣。

所以我们现在对于一个段只需要求前 $D$ 个元素即可，所以实际上我们就是要找到那个分界点，因为有单调性，考虑二分。

而对于一个段的前 $D$ 个元素因为我们不知道他的前驱在哪个元素，所以对于 $i$ 而言，要查询 $i-D$ 在哪个段中。

所以实际上实现出来是一个二分套二分的形式，计算是简单的，对于每个段记 $pos_i$ 表示分界点。

然后查询的话我们是可以做到 $O(\log n)$ 单次查询的。

预处理需要 $O(n\log^2n)$ 的复杂度。

所以这种情况的时间复杂度为 $O(n\log ^2n)$。

---

总时间复杂度为 $O(n\log^2n)$。

代码写起来没什么细节。

```
#include<bits/stdc++.h>
#define Yzl unsigned long long
#define mp make_pair
#define pi pair<LL,LL>
#define fi first
#define se second
#define pb emplace_back
typedef long long LL;

using namespace std;

const Yzl Lty=20120712;

const int MAXN=2e5+10;
const LL inf=1e13;
int n,Q,cnt; 
LL D,A,B;
struct ddl {
	LL l,r;
}a[MAXN],b[MAXN],c[MAXN];
LL f[MAXN];
void sub1() {
	while(Q--) {
		LL x; scanf("%lld",&x);
		LL l=0,r=cnt+1,mid;
		while(l+1<r) { mid=(l+r)/2;
			if(c[mid].r<x) l=mid;
			else r=mid;
		}
		if(c[r].l>x||r==cnt+1) puts("-1");
		else printf("%lld\n",x*A+f[r]*(B-A*D));
	}
}
LL pos[MAXN];
LL erfind(LL x) {
	LL l=0,r=cnt+1,mid;
	while(l+1<r) { mid=(l+r)/2;
		if(c[mid].r<x) l=mid;
		else r=mid;
	}
	if(r==cnt+1||c[r].l>x) x=c[--r].r;
	return f[r]+(x-c[r].l)/D+((x-c[r].l)%D>=pos[r]);
}
void sub2() {
	f[1]=0; pos[1]=D;
	for(int i=2;i<=cnt;++i) {
		LL ls=erfind(c[i].l-D)+1; f[i]=ls;
		LL l=c[i].l,r=min(c[i].r,c[i].l+D-1)+1,mid;
		while(l+1<r) { mid=(l+r)/2;
			if(erfind(mid-D)==ls) r=mid;
			else l=mid;
		} pos[i]=r-c[i].l;
	}
	while(Q--) {
		LL x; scanf("%lld",&x);
		LL l=0,r=cnt+1,mid;
		while(l+1<r) { mid=(l+r)/2;
			if(c[mid].r<x) l=mid;
			else r=mid;
		}
		if(r==cnt+1||c[r].l>x) puts("-1");
		else printf("%lld\n",x*A+(f[r]+(x-c[r].l)/D+((x-c[r].l)%D>=pos[r]))*(B-A*D));
	}
}
int main () {
	scanf("%d%d%lld%lld%lld",&n,&Q,&D,&A,&B);
	for(int i=1;i<=n;++i) {
		scanf("%lld%lld",&a[i].l,&a[i].r);
	} b[++cnt]=(ddl){0,a[1].l-1}; a[n+1].l=inf;
	for(int i=1;i<=n;++i) b[++cnt]=(ddl){a[i].r+1,a[i+1].l-1};
	int CNT=cnt; c[cnt=1]=b[1]; f[1]=0; int pre=0;
	for(int i=1;i<=CNT;++i) {
		while(pre<=cnt&&c[pre].r+D<b[i].l) ++pre;
		if(pre<=cnt&&c[pre].l+D<=b[i].r) {
			c[++cnt]=(ddl){max(b[i].l,c[pre].l+D),b[i].r};
			f[cnt]=f[pre]+1;
		}
	}
	if(D*A<=B) sub1();
	else sub2();
	return 0;
}
```

---

## 作者：cwfxlh (赞：1)

## [P10438](https://www.luogu.com.cn/problem/P10438)   

现有的两篇题解都是两 $\log$ 的，来一个一 $\log$ 的！(其实差不了太多)    

### 情况一

第一个情况是 $D\times A\ge B$，也就是说要尽可能少跳。    

先编一个 $O(V)$ 的 dp。令 $dp_i$ 表示到达 $i$ 最多跳多少次，那么转移就是 $dp_i=\min(dp_{i-1},dp_{i-D}+1)$，$dp_0=0$，不能通过的位置 $dp_i=\inf$。    

优化以上 dp。能通过的位置是一段一段的，先猜一下 dp 值长什么样子。    

对于每一段，肯定有一段前缀的 dp 值是 $\inf$。这是显然的。   

继续猜，每一段不是 $\inf$ 的都相同，并且每一段都不小于前一段。这个结论仔细想想也是对的。    

首先因为 $dp_i$ 对 $dp_{i-1}$ 取了 $\min$，所以每一段肯定是不升的。递归证明。新加入一段，令这段的左端点为 $l$，则 $dp_l=dp_{l-D}+1$，第一个大于 $dp_l$ 的位置为 $x$，则 $dp_x=\min(dp_{x-1},dp_{x-D}+1)=\min(dp_l,dp_{x-D}+1)<dp_l=dp_{l-D}+1$，推出 $dp_{x-D}<dp_{l-D}$，如果 $x-D\ge l$，那么肯定不成立，否则因为前面的段都满足条件，因此也不成立。    

所以 dp 值的连续段有 $O(n)$ 个，从前往后插入，然后找到第一个能转移到新段落的位置（转移的限制是距离限制状物），维护一个指针即可 $O(n)$ 解决。    

### 情况二    

第一个情况是 $D\times A<B$，也就是说要尽可能多跳。    

同样的，考虑 dp，令 $dp_i$ 表示到达 $i$ 最多跳多少次，转移是 $dp_i=\max(dp_{i-1},dp_{i-D}+1)$，$dp_0=0$，不能到达的地方 dp 值为 $-\inf$。   

同样的，dp 值不为 $-\inf$ 的位置是 $O(n)$ 个段落，并且每一段不降。   

显然的，现在每一段不是全相等了，因为可以对 $dp_{i-D}+1$ 取 $\max$，所以至少每经过 $D$ 个位置，dp 值会 +1。对于长度大于 $D$ 的段落，其形态必定如同将前 $D$ 个拿来一直复制，并且每往后加一段都整体将 dp 值 +1。    

考虑这前 $D$ 个，我们猜想其涨幅不会超过 1。考虑如下更强的命题：对于任意 $i,j\in[i+1,i+D],dp_i\not=-\inf,dp_j\not=-\inf$，那么都有 $dp_j\in[dp_i,dp_i+1]$。证明可以递归证明，在 $[1,j-1]$ 都满足情况的条件下，如果 $dp_j=dp_{j-1}$，那么显然满足条件，如果 $dp_j=dp_{j-D}+1$，那么有 $i\in[j-D,j-1]$ 也就是 $i\in[(j-D),(j-D)+D-1]$，如果 $i=j-D$，那么 $dp_j=dp_i+1$，否则 $dp_i\in(dp_{j-D},dp_{j-D}+1)$，一样可以证明。    

于是 dp 值又被刻画出来了，每一段都是不降的，且段与段之间也是不降的，每一段的 dp 值形态是长为 $x\le D$ 的某个值，然后每 $D$ 格 dp 值 +1。     

维护每段端点，开头的值，开头的长度，添加一段的时候通过二分算出开头的长度，复杂度 $O(n\log n)$。    

两部分结合起来算 dp，查询二分到对应的段落查询，复杂度 $O(n\log n+q\log n)$。     

代码：   

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,D,A,B,lft,rgt,mid,flg;
pair<int,int>a[200003];
int k1,k2,k3,k4,k5,k6,k7,k8,k9;
struct Segmt{
	int l;
	int r;
	int stv;
	int stlen;
}P[200003];
int totP;
int getval(int num,int pos){
	if(!flg)return P[num].stv;
	if(P[num].stlen==D)return P[num].stv+((pos-P[num].l)/D);
	return P[num].stv+((pos-P[num].l+D-P[num].stlen)/D);
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>q>>D>>A>>B;
	if(A*D>B)flg=1;
	for(int i=1;i<=n;i++)cin>>a[i].first>>a[i].second;
	P[++totP].l=0;P[totP].r=a[1].first-1;P[totP].stv=0;P[totP].stlen=D;
	a[n+1].first=1000000000001ll;
	a[n+1].second=1000000000001ll+D-1;
	for(int i=1,j=0;i<=n;i++){
		int u=a[i].second+1,v=a[i+1].first-1;
		lft=1;rgt=totP;
		while(lft<rgt){
			mid=((lft+rgt)/2);
			if(P[mid].r+D>=u)rgt=mid;
			else lft=mid+1;
		}
		j=lft;
		if(j>totP)continue;
		if(max(P[j].l+D,u)>min(P[j].r+D,v))continue;
		P[++totP].l=max(P[j].l+D,u);P[totP].r=v;P[totP].stv=getval(j,P[totP].l-D)+1;
		if(!flg){P[totP].stlen=0;continue;}
		k1=P[totP].stv-1;
		lft=j;rgt=totP-1;
		while(lft<rgt){
			mid=((lft+rgt)/2);
			if(getval(mid,P[mid].r)>k1||getval(mid,P[mid].l)>k1)rgt=mid;
			else lft=mid+1;
		}
		if(lft>=totP||lft<j||getval(lft,P[lft].r)==k1){P[totP].stlen=D;continue;}
		int pos=0;
		if(getval(lft,P[lft].l)>k1)pos=P[lft].l;
		else pos=P[lft].l+P[lft].stlen+D*(k1-P[lft].stv);
		pos+=D;
		if(pos>=P[totP].l&&pos<=P[totP].r)P[totP].stlen=pos-P[totP].l;
		else P[totP].stlen=D;
		if(P[totP].stlen==0)P[totP].stlen=D;
	}
	while(q--){
		cin>>k1;
		lft=1;
		rgt=totP;
		while(lft<rgt){
			mid=((lft+rgt)/2)+1;
			if(P[mid].l<=k1)lft=mid;
			else rgt=mid-1;
		}
		if(P[lft].l<=k1&&P[lft].r>=k1)cout<<A*(k1-getval(lft,k1)*D)+B*getval(lft,k1)<<'\n';
		else cout<<-1<<'\n';
	}
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10438)

**题目大意**

> 给定无穷长数轴，每次从 $x\to x+1$ 费用为 $a$，$x\to x+d$ 费用为 $b$，$n$ 个区间 $[l,r]$ 不能经过，$q$ 次询问 $0\to x$ 的最短路。
>
> 数据范围：$n,q\le 2\times 10^5$。

**思路分析**

把数轴分为 $n+1$ 给可以经过的区间，并且把不能到达的点删掉。

首先比较 $a\times d$ 和 $b$ 的大小关系。

如果 $a\times d\le b$，那么尽可能少用 $+d$ 操作，很显然我们只会用 $+d$ 操作跨越区间，那么贪心地找最靠前的能跳过来的区间转移即可。

否则我们需要用尽可能多的 $+d$ 操作，用 $f_x$ 表示到达 $x$ 最多用多少次 $+d$，如果 $x-d$ 可达那么 $f_x\gets f_{x-d}+1$。

因此对于连续的可达的一段，$f$ 一定是若干个长度为 $d$ 的区间构成，且每个区间值 $+1$，那么计算 $f$ 只需要二分所在段。

只有在每个区间开头的地方可能产生不同，即第一段的长度不一定 $=d$，只需要维护这一段的长度即可。

对于区间 $[l,r]$，我们二分出第一个 $f_x$ 使得 $\max_{i\le x-d}f_{i}\ge f_{l-d}+1$，前缀 $\max$ 只要找到第一个合法的 $f_i$ 即可。

时间复杂度 $\mathcal O(n\log^2n+q\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+5;
const ll inf=1.1e18;
struct info { ll l,r; } a[MAXN],b[MAXN];
int n,m,q;
ll A,B,D,f[MAXN],d[MAXN];
int pos(ll x) {
	int l=1,r=m,p=m+1;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(x<=b[mid].r) p=mid,r=mid-1;
		else l=mid+1;
	}
	return p;
}
ll dp(ll x) {
	int p=pos(x);
	if(x<b[p].l) x=b[--p].r;
	return f[p]+(x-b[p].l)/D+((x-b[p].l)%D>=d[p]);
}
signed main() {
	cin>>n>>q>>D>>A>>B;
	for(int i=1;i<=n;++i) cin>>a[i].r>>a[i+1].l,--a[i].r,++a[i+1].l;
	a[1].l=0,a[n+1].r=inf,b[m=1]=a[1];
	for(int i=2,j=1;i<=n+1;++i) {
		while(j<=m&&b[j].r+D<a[i].l) ++j;
		if(j<=m&&b[j].l+D<=a[i].r) b[++m]={max(a[i].l,b[j].l+D),a[i].r},f[m]=f[j]+1;
	}
	b[m+1]={inf,inf};
	if(A*D<=B) {
		for(ll x;q--;) {
			cin>>x; int p=pos(x);
			cout<<(x<b[p].l?-1:A*x+f[p]*(B-A*D))<<"\n";
		}
		return 0;
	}
	f[1]=0,d[1]=D;
	for(int i=2;i<=m;++i) {
		f[i]=dp(b[i].l-D)+1,d[i]=D;
		for(ll l=b[i].l,r=min(b[i].r,b[i].l+D-1);l<=r;) {
			ll mid=(l+r)>>1;
			if(dp(mid-D)>=f[i]) d[i]=mid-b[i].l,r=mid-1;
			else l=mid+1;
		}
	}
	for(ll x;q--;) {
		cin>>x; int p=pos(x);
		cout<<(x<b[p].l?-1:A*x+dp(x)*(B-A*D))<<"\n";
	}
	return 0;
}
```

---


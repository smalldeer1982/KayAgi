# [JOISC 2024] 环岛旅行 (Day4)

## 题目背景

**由于部分 BUG，使用 C++14 (GCC9) 提交会产生编译错误，请使用 C++14 等语言进行提交。**

**题目译自 [JOISC 2024](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html) Day4 T2 「[島巡り](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island.pdf) / [Island Hopping](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island-en.pdf)」**。翻译来源 LOJ。

**不要引入 `island.h`**。你应该在文件头添加以下声明：

```
int query(int, int);
void answer(int, int);
```

交互文件可在 [JOI 官网](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html)下载。

## 题目描述

**这是一道交互题。本题交互库是非自适应的。**

JOI 国有 $N$ 座岛屿，编号为 $1$ 到 $N$。有 $N-1$ 条航线，编号为 $1$ 到 $N-1$。航线 $j\ (1\le j\le N-1)$ 双向连接岛屿 $A_j$ 和 $B_j$。可以从一座岛屿出发，通过一些航线到达任意另一个岛屿。

葵准备在 JOI 国旅行。然而她不知道 JOI 国的航线。她准备向 JOI 国居住的 Bitaro 按下面的方式提一些问题：

1. 葵告诉 Bitaro 两个整数 $v$ 和 $k$，其中 $1\le v\le N,1\le k\le N-1$。
2. Bitaro 会告诉她除了 $v$ 之外的其他 $N-1$ 座岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。更确切地说，他会告诉她一个整数 $i$，满足 $\text{dist}(v,i)\times N+i\ (1\le i\le N,i\neq v)$ 是第 $k$ 小的，其中 $\text{dist}(v,i)$ 是从岛屿 $v$ 到 $i$ 所经过的最小航线数。

葵想通过提问知道所有 JOI 国的航线。因为葵不想花费太多时间，所以她最多只能向 Bitaro 问 $L$ 个问题。

给定 JOI 国的岛屿数和提问限制数，写一个程序模拟葵的提问策略，以找出所有的航线。

### 实现细节

你需要在程序开头引入库 `island.h`。

你需要实现如下函数。

- `void solve(int N, int L)`

  此函数在每个测试点中只被调用一次

  - 参数 `N` 是岛屿数 $N$
  - 参数 `L` 是提问次数限制 $L$。

在程序中，你可以调用如下函数。

- `int query(int v, int k)`

  葵使用此函数向 Bitaro 提问

  - 参数 `v` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [1]**。
  - 参数 `k` 必须在 $1$ 到 $N-1$​ 之间。如果不是，你的程序会被判为 **Wrong Answer [2]**。
  - 返回值表示除 $v$ 之外的其他 $N-1$ 个岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。参考题目描述获得更详细的定义。
  - 你不能调用 `query` 函数超过 $L$ 次，否则你的程序会被判为 **Wrong Answer [3]**。

- `void answer(int x, int y)`

  使用此函数回答 JOI 国的一条航线

  - 参数 `x` 和 `y` 表示被一条航线连接的两座岛屿。
  - 参数 `x` 和 `y` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [4]**。
  - 必须存在一条连接岛屿 `x` 和 `y` 的航线。换句话说，必须存在一个整数 $j\ (1\le j\le N-1)$ 满足 $x=A_j,y=B_j$ 或 $x=B_j,y=A_j$。否则，你的程序会被判为 **Wrong Answer [5]**。
  - 你的程序不能回答相同的航线两次或以上。否则，你的程序会被判为 **Wrong Answer [6]**。
  - 函数 `answer` 必须被调用恰好 $N-1$ 次。如果 `solve` 函数运行结束后此函数调用次数不是 $N-1$，你的程序会被判为 **Wrong Answer [7]**。
  
### 注意事项

- 你的程序可以实现其它函数供内部使用，或者使用全局变量。
- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。
- 测评中使用的交互器**不是**自适应性的。这意味着每组测试点的答案是提前确定好的。

### 编译运行

你可以在附件中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。

样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`island.cpp` 和 `island.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。

```bash
g++ -std=gnu++20 -O2 -o grader grader.cpp island.cpp
```

当编译成功时，会生成可执行文件 `grader`。

注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。

## 说明/提示

### 样例交互

#### 样例交互 $1$

样例调用过程如下表所示。

|      调用      |      调用      | 返回值 |
| :------------: | :------------: | :----: |
| `solve(4, 16)` |               |        |
|                | `query(2, 1)`  |  $1$   |
|                | `query(3, 1)`  |  $4$   |
|                | `answer(2, 4)` |        |
|                | `query(2, 2)`  |  $4$   |
|                | `answer(2, 1)` |        |
|                | `query(3, 2)`  |  $2$   |
|                | `query(2, 1)`  |  $1$   |
|                | `answer(3, 4)` |        |

从岛屿 $2$ 到岛屿 $1,3,4$ 的最小经过航线数分别为 $1,2,1$。例如，从岛屿 $2$ 到岛屿 $3$，我们可以使用航线 $2$ 后使用航线 $3$。

将岛屿按 $\text{dist}(2,i)\times N+i\ (i\neq 2)$ 递增的顺序排序，结果是岛屿 $1,4,3$。因此，`query(2, 1)` 的返回值为 $1$，`query(2, 2)` 的返回值为 $4$。

样例 $1$ 满足子任务 $2,6$ 的限制。

#### 样例交互 $2$


样例调用过程如下表所示。

|      调用      |      调用      | 返回值 |
| :------------: | :------------: | :----: |
| `solve(5, 25)` |            |        |
|                | `query(1, 3)`  |  $5$   |
|                | `query(1, 4)`  |  $2$   |
|                | `answer(3, 1)` |        |
|                | `query(2, 4)`  |  $4$   |
|                | `query(3, 1)`  |  $1$   |
|                | `query(3, 2)`  |  $4$   |
|                | `answer(1, 5)` |        |
|                | `answer(4, 1)` |      |
|                | `answer(2, 5)`  |        |

从岛屿 $1$ 到岛屿 $2,3,4,5$ 的最小经过航线数分别为 $2,1,1,1$。例如，从岛屿 $1$ 到岛屿 $2$，我们可以使用航线 $4$ 后使用航线 $1$。

将岛屿按 $\text{dist}(1,i)\times N+i\ (i\neq 1)$ 递增的顺序排序，结果是岛屿 $3,4,5,2$。因此，`query(1, 3)` 的返回值为 $5$，`query(1, 4)` 的返回值为 $2$。

样例 $2$ 满足子任务 $4,6$ 的限制。

### 数据范围

- $3\le N\le 300$
- $1\le A_j,B_j\le N\ (1\le j\le N-1)$
- $A_j\neq B_j\ (1\le j\le N-1)$
- 可以通过航线，从一个岛屿到达任意其他岛屿

### 子任务

| 子任务 |                           附加限制                           | 分值 |
| :----: | :----------------------------------------------------------: | :--: |
|  $1$   |                          $N=3,L=9$                           | $2$  |
|  $2$   |             $L=N^2$，每座岛屿最多有两条航线连接              | $4$  |
|  $3$   |              $L=2N$，每座岛屿最多有两条航线连接              | $7$  |
|  $4$   | $L=N^2$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $9$  |
|  $5$   | $L=3N$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $13$ |
|  $6$   |                           $L=N^2$                            | $15$ |
|  $7$   |                            $L=3N$                            | $22$ |
|  $8$   |                            $L=2N$                            | $28$ |

## 样例 #1

### 输入

```
4 16
1 2
2 4
4 3```

### 输出

```
```

## 样例 #2

### 输入

```
5 25
5 2
3 1
1 4
1 5```

### 输出

```
```

# 题解

## 作者：ケロシ (赞：3)

来补篇题解 111

首先一种想法就是把 $1$ 作为根，然后每次取距离 $1$ **最远**的点 $u$，然后依次访问距离 $u$ 距离最近的点，这样第一个查到的没被取出过的点就是 $u$ 的父亲，可以做到 $3n$ 次询问。

```cpp
const int N = 3e2 + 5;
int p[N], a[N], vis[N];
void solve(int n, int s) {
	ROF(i, n - 1, 1) {
		int u = query(1, i);
		FOR(j, 1, n) {
			int v = query(u, j);
			if(p[v] == u) continue;
			p[u] = v;
			break;
		}
	}
	FOR(i, 2, n) answer(p[i], i);
}
```

但是每次会查询一个点的所有邻居，而有用的信息只有其父亲，考虑充分利用信息。

还是将 $1$ 作为根，但是这次每次取距离 $1$ **最近**的点 $u$，接下来，当 $u$ 还没有确定其父亲的时候，就依次访问其最近的点，直到找到父亲为止。

这样的话，每次 $u$ 可以查询到邻居 $v$，如果 $v$ 被取出过，那么 $v$ 就是 $u$ 的父亲，反之，可以知道 $u$ 是 $v$ 的父亲。这样每次查询就能知道一对父子关系。

这样就做到了 $2n$ 次询问。

```cpp
const int N = 3e2 + 5;
int p[N], a[N], vis[N];
void solve(int n, int s) {
	vis[1] = 1;
	FOR(i, 1, n - 1) {
		int u = query(1, i);
		vis[u] = 1;
		int c = 0;
		while(! p[u]) {
			int v = query(u, ++ c);
			if(vis[v]) p[u] = v;
			else p[v] = u;
		}
	}
	FOR(i, 2, n) answer(p[i], i);
}
```

---

## 作者：Eternatis (赞：2)

考虑先问出对每个点  $x$ 最近的点 $f_x$，则树上一定有一条 $x \leftrightarrow f_x$ 的边。

我们增量构建整棵树，考虑编号最大的点 $n$，若一个点 $u$ 和 $n$ 相邻，且 $u$ 不是叶子，则一定有 $f_u \neq n$，同理可得 $f_u=n$ 的点 $u$ 是挂在 $n$ 上的叶子。

考虑如何求出点 $n$ 的所有边，首先把与 $n$ 相连的叶子删掉并加上对应边，之后按与 $n$ 的距离从小到大考虑所有点，我们知道与 $n$ 相邻的点一定是一个前缀，现在的问题是如何判断第一个不与 $n$ 相邻的点。

考虑上面“若一个点 $u$ 和 $n$ 相邻，且 $u$ 不是叶子，则一定有 $f_u \neq n$”这条性质，假设我们当前遍历到点 $v$，且 $v$ 是第一个不与 $n$ 相邻的点，则一定存在一个与 $n$ 相邻的点 $u_0$，使得 $f_{u_0}=v$，于是我们一边枚举相邻点 $u$ 一边记录访问过的 $f_u$ 即可。

之后我们删掉 $n$ 和与 $n$ 相邻的所有边，就得到了一个子问题，注意在求子问题对应的 $n'$ 的边时，我们只要遍历到一个 $n_0>n'$，就直接结束遍历。

分析一下询问次数，我们首先有 $n$ 次询问，之后我们对于每个点总共会询问其度数次，但当我们删除一个 $n$ 时，其相邻的所有 $u$ 枚举次数都会减一，故最终询问次数为 $n+2(n-1)-(n-1)=2n-1$。

具体实现可以参考代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10010
#define pb push_back
#define st first
#define ed second
int query(int, int);
void answer(int, int);
int n,m,f[N],vis[N];
map<int,int> ban[N];
void solve(int NN,int LL){
	n=NN,m=LL;
	vector<pair<int,int>> e;
	for(int i=1;i<=n;i++)f[i]=query(i,1);
	for(int x=n;x>=1;x--){
		for(int y=1;y<=n;y++){
			if(y==x)continue;
			if(vis[y])continue;
			if(f[y]==x)vis[y]=1,e.pb({x,y});
		}
		if(f[x]>x)continue;
		if(!vis[f[x]])e.pb({x,f[x]}),ban[x][f[f[x]]]=1;
		for(int i=2;i<n;i++){
			int y=query(x,i);
			if(y>x||ban[x][y])break;
			if(vis[y])continue;
			e.pb({x,y}),ban[x][f[y]]=1;
		}
	}
	for(auto x:e)printf("%lld %lld\n",x.st,x.ed);
}
```

---

## 作者：yanzihe (赞：1)

## 解法
设 $q(u, i)$ 表示距离 $u$ 第 $i$ 近的点，距离相同则按照编号从小到大排。

考虑从小到大遍历每个点，遍历到点 $u$ 的时候，通过询问找出 $u$ 的所有编号小于 $u$ 的邻居。


具体来说，不断查询 $q(u, i)(i=1, 2\dots)$ 直到某个 $q(u, i)>u$ 为止。

****
但是有一个问题是 $q(u, i)$ 和 $u$ 有可能不是邻居，而它们的距离为 $2$。那么该怎么判断这一点呢？

考虑设 $v$ 是最小的使 $q(u, i)$ 和 $u$ 不是邻居的 $i$。那么显然存在 $j<v$，$q(u, j)$ 和 $q(u, v)$ 是邻居。
- 如果 $q(u, v)$ 是 $q(u, 1), q(u, 2)\dots, q(u, v)$ 中的最大值，那么 $q(u, j)$ 和 $q(u, v)$ 的邻居关系我们一定已经在之前的查询中被发现了。（我们之前已经查询了所有编号小于 $u$ 的点 $i$ 是否和编号小于 $i$ 的点有边，并且 $q(u, j)<q(u, v)<u$）那么我们可以对于所有 $j$ 都查看 $q(u, j)$ 和 $q(u, v)$ 是否有邻居。
- 如果 $q(u, v)$ 不是 $q(u, 1), q(u, 2)\dots, q(u, v)$ 中的最大值，通过这一点足以证明 $q(u, v)$ 和 $u$ 不是邻居。
  
如上两条就是判断 $q(u, i)$ 和 $u$ 是否是邻居的方法，如果发现不是邻居，直接退出，继续查询 $u+1$ 即可。

**复杂度分析**：查询分两种，一种查询确定了一条边，这种查询数量为 $n-1$。另一种查询没有确定一条边，而每个点都只会进行一次这样的查询，数量为 $n$。

总次数为 $2n-1$。

## 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;
#define rep(i, a, b) for(ll i=a;i<=b;i++)
#define rrep(i, a, b) for(ll i=a;i>=b;i--)
const ll N=309;
ll f[N][N];
int query(int, int);
void answer(int, int);                                                        
void solve(int N, int L){
    rep(i, 1, N){
        vector <ll> hs;hs.clear();
        rep(j, 1, N-1){
            ll v=query((int)i, (int)j);
            if(v>i)break;
            if(j==1){
                f[i][v]=f[v][i]=1;
            }else{
                if(v<hs.back())break;
                bool ok=1;
                for(ll tmp:hs){
                    if(f[v][tmp]){
                        ok=0;break;
                    }
                }
                if(ok==0){
                    break;
                }else{
                    f[i][v]=f[v][i]=1;
                }
            }
            hs.emplace_back(v);
        }
    }
    rep(i, 1, N){
        rep(j, i+1, N){
            if(f[i][j]){
                answer((int)i, (int)j);
            }
        }
    }
}

```

---


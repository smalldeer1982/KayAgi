# [JOISC 2024] 乒乓球 (Day4)

## 题目描述

在 JOI 王国举办了一场乒乓球比赛。 $N$ 只编号从 $1$ 到 $N$ 的海狸参加了这场比赛，并进行了一场循环赛。

你从 Bitaro 那里得知了关于比赛结果的以下信息。

-  没有平局比赛。
- 正好有 $M$ 种选择 $3$ 只海狸形成“三元悖论”。请注意，只有当以下两个条件之一恰好满足时，$3$ 只海狸 $i, j, k$（$1 \leq i < j < k \leq N$）才形成“三元悖论”。
- - 海狸 $i$ 击败了海狸 $j$，海狸 $j$ 击败了海狸 $k$，海狸 $k$ 又击败了海狸 $i$。
- - 海狸 $i$ 击败了海狸 $k$，海狸 $k$ 击败了海狸 $j$，海狸 $j$ 又击败了海狸 $i$。

你不确定 Bitaro 提供的信息是否正确，所以你决定思考是否有任何与 Bitaro 提供的信息相符的比赛结果。编写一个程序，根据 Bitaro 提供的信息判断是否有任何比赛结果与信息相符，如果有，找出其中任意一种比赛结果。

## 说明/提示

#### 样例解释 1

有 $Q = 2$ 个场景。

在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $2$，海狸 $2$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1$、$2$、$3$ 形成了“三元悖论”。没有其他方式选择 $3$ 只海狸，所以有确切地 $1$ 种方式选择 $3$ 只形成“三元悖论”的海狸。

对应场景 $1$ 的另一个输出如下。

```
Yes
1
01
```

在场景 $2$ 中，没有任何与信息相符的比赛结果。因此，输出 No。

这个示例输入满足子任务 $2,3,4,5,6$ 的约束条件。

#### 样例解释 2

在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $4$，海狸 $4$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1,3,4$ 形成了“三元悖论”。还有两种其他方式选择 $3$ 只形成“三元悖论”的海狸：选择海狸 $2,3,4$ 和选择海狸 $3,4,5$。因此，有确切地 $3$ 种方式选择 $3$ 只形成“三元悖论”的海狸。

这个示例输入满足所有子任务的约束条件。


### 约束条件

- $1 \leq Q$．
- $3 \leq N \leq 5000$．
- $0 \leq M \leq \frac{1}{6} N(N - 1)(N - 2)$．
- $Q$ 个场景中 $N$ 的总和不超过 5000
- 给定值均为整数。

### 子任务

1. (5 分) $M \leq N - 2$．
2. (4 分) $Q$ 个场景中 $N$ 的总和不超过 7。
3. (23 分) $Q$ 个场景中 $N$ 的总和不超过 20。
4. (30 分) $Q$ 个场景中 $N$ 的总和不超过 150。
5. (15 分) $Q$ 个场景中 $N$ 的总和不超过 600。
6. (23 分) 无额外约束。

## 样例 #1

### 输入

```
2
3 1
4 4```

### 输出

```
Yes
0
10
No```

## 样例 #2

### 输入

```
1
5 3```

### 输出

```
Yes
0
11
001
0101```

# 题解

## 作者：Otomachi_Una_ (赞：5)

**【题目简述】**

构造一个 $n$ 个点，$m$ 个三元环的竞赛图。

$n\leq 5000$。

**【解题思路】**

经典结论：竞赛图三元环只和每个点的入度序列有关。

不难发现当入度序列为 $[0,1,\dots,n-1]$ 时没有三元环，当把一对 $(x,x+2)$ 调整为 $(x+1,x+1)$ 时会多一个三元环。

直接调整复杂度是 $\mathcal O(M)$ 的。可以考虑找一个最小的 $n_0\leq n$ 使得其最大三元环量不小于 $M$，在 $n_0$ 基础上调整，其余连成 DAG 即可。

时间复杂度：$\mathcal O(n^2)$。

**【参考代码】**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=5005;
int n,d[MAXN];ll m;
bool ans[MAXN][MAXN];
ll max_reach(ll x){
	ll r=x*((x-1)/2)*(x/2);
	return (r-x*(x-1)*(x-2)/6)/2;
}
void solve(){
	cin>>n>>m;
	if(m>max_reach(n)){
		cout<<"No\n";
		return;
	}
	cout<<"Yes\n";
	for(int i=1;i<=n;i++) d[i]=i-1;
	for(int i=1;i<=n;i++) if(m<=max_reach(i)){
		m=max_reach(i)-m;
		if(i%2==1) for(int j=1;j<=i;j++) d[j]=(i-1)/2;
		else for(int j=1;j<=i;j++) d[j]=i/2-(j<=i/2);
		while(m){
			for(int l=1,r=1;r<n;l=r+1){
				r=l;
				while(r<i&&d[r+1]==d[r]) r++;
				int r0=r;
				while(m>0&&l<r){
					m--;
					d[l++]--,d[r--]++;
				}
				r=r0;
			}
		}
		break;
	}
	sort(d+1,d+n+1);
	// for(int i=1;i<=n;i++) cout<<d[i]<<" \n"[i==n];
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) ans[i][j]=0;
	for(int i=n;i>=2;i--){
		d[i]=i-1-d[i];
		for(int l=i-1,r=i-1;;r=l-1){
			l=r;
			while(l>1&&d[l]==d[l-1]) l--;
			for(int j=l;j<=r;j++){
				if(d[i]>0) d[i]--,d[j]--,ans[j][i]=1;
				else ans[i][j]=1;
			}
			if(l==1) break;
		}
		// if(d[i]) cerr<<"ERROR "<<i<<' '<<d[i]<<endl;
	}
	for(int i=2;i<=n;i++) for(int j=1;j<i;j++){
		cout<<ans[i][j];
		if(j==i-1) cout<<'\n';
	}
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("Otomachi_Una.in","r",stdin);
	// freopen("Otomachi_Una.out","w",stdout);
	int _;cin>>_;
	while(_--) solve();
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

怎么刻画竞赛图的三元环。记 $\deg_u$ 为 $u$ 的出度，则三元环的个数是 $\dbinom{n}{3} - 2 \sum_u \dbinom{\deg_u}{2}$。

所以你只需要构造 $\sum \dbinom{deg_u}{2}$ 为定值的序列。

有一个叫做兰道定理的东西，精准刻画了 $\deg$ 序列应该满足的条件。很遗憾，在这个题里面不太有用。UPD：写到后面发现，其实是有用的。

考虑假设两个极端情况。这个值最大显然是在 DAG 的时候取到；最小显然是在度数尽可能平均的时候取到。

具体来说，DAG 的时候度数是 $0$ 到 $n-1$；平均的时候，如果 $n$ 是奇数就全是 $\frac{n-1}{2}$，否则有一半是 $\frac{n}{2}$ 一半是 $\frac{n}{2}-1$。

考虑对 $\deg$ 序列进行调整。初始 $\deg_i=i-1$。每次你可以选择**未操作**的 $(u,v)$ 满足 $u < v$，使得 $\deg_u \leftarrow \deg_u + 1$，$\deg_v \leftarrow \deg_v-1$。注意如果有 $\deg_u = \deg_v - 2$，那么这样操作一次会让式子恰好减 $1$。这是好的，出现了连续变化。

而强制限制“未操作”未免有些愚蠢。如果我们要求 $\deg_u < \deg_v$，这样操作一次一定会更加的满足兰道定理的条件。也就是说，我们并不是直接对图的结构调整，而是**调整图的一个参量**，而这个参量会隐式地影响图的结构。

同样，我们发现正着这么做有一点不好：你不知道调整的中点是什么。也就是说，如果不存在差等于 $2$ 的数，你就不会调整了。而如果你乱调确实可能出现这种情况。

不过我们考虑每次把相等的数往外分离。首先这样会让兰道定理的条件变劣。但是发现不能调整的终点是唯一确定的（注意到你这么做不可能出现 $[0,n-1]$ 之外的数。~~我也不太会证明。~~）

因此我们就获得了一个 $O(M)$ 的做法。就是暴力的进行调整。

而有一些调整其实不用做。你可以先找到一个比较优的形态（一个 DAG 套上度数尽可能平均），然后再调整。容易证明我们可以把调整的量卡到 $O(n^2)$。

最后你还要去根据度数序列构造竞赛图。但是这个并不困难，精细实现一下是 $O(n^2)$ 的。但是 $O(n^2 \log n)$ 无压力通过。

---

## 作者：_lmh_ (赞：2)

首先对于每个 $(u,v,w)$，考虑三条边对三个节点的度数的贡献。如果这个东西不是三元环，那么一定有恰好一个点有两条出边，恰好一个点有两条入边，恰好一个点一条入边一条出边。否则如果它是三元环，那么三个点都是一条入边一条出边。

因此，所有点的入度出度之积的和为 $2m+\binom{n}{3}$，它等于 $\sum_{i=1}^ndeg_i(n-1-deg_i)$。

$\sum_i deg_i=\binom{n}{2}$，因此可以把 $\sum_{i}deg_i(n-1)$ 提出来，相当于构造一个和为 $\binom{n}{2}$ 的序列使得其平方和为特定值 $k$。

考虑调整法：先令 $deg_i=n-i$，此时相当于连成一个 `DAG`；之后每次选择一条边 $(u,v)(u<v)$ 反转方向（要求其之前没被反转过并且 $deg_u>deg_v$），使 $deg_u$ 减小 $1$，$deg_v$ 增大 $1$。

对于任意一种可能的度数序列，显然将其从大往小排序之后一定能够通过上面的操作得到。

找平方和最小的度数序列是简单的：$n$ 为奇数时全相等，$n$ 为偶数时一半是 $\frac{n}{2}$ 一半是 $\frac{n}{2}-1$（如果需要让答案更小那么一定无解），自然需要往这个方向调整。

尝试在最左边和最右边同时维护一个值全部相等的连续段（一开始长度为 $1$），每次进行如下操作：

- 显然操作这里任意两个东西对答案的贡献均相等，求出最大的可能的操作次数。

- 对左边连续段的一个后缀和右边连续段的一个前缀依次进行操作。

- 如果所有点都被操作，将两个连续段同时扩展一格并返回第一步；否则，跳出循环。

跳出循环的时候肯定是尝试进行一次操作但是失败了，那么操作现在序列的最大值和最小值的话差值会太大——这也很好处理，选一对差值小一点的节点操作即可。显然这是可以做到的。

时间复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=5007;
ll T,n,m,deg[N];
bool ans[N][N];
bool flip(ll l,ll r){
	if (m<deg[l]-deg[r]-1) return 0;
	m-=(deg[l]--)-(++deg[r]);
//	ans[r][l]^=1;
	return 1;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>m;
		for (int i=1;i<=n;++i){
			deg[i]=n-i;
			for (int j=1;j<i;++j) ans[i][j]=1;
		}
		m=m*2+n*(n-1)/2*(n-2)/3;
		m-=n*(n-1)/2*(n-1);
		for (int i=0;i<n;++i) m+=i*i;
		assert(m%2==0&&m>=0);m>>=1;
//		cout<<m<<endl;
		for (int l=1,r=n;l+1<r;++l,--r){
			bool fl=1;
			for (int i=l,j=r;i;--i,++j) if (!flip(i,j)){
				fl=0;
				for (int o=i+1,p=r;o<=l;++o,++p) ans[p][o]^=1;
				break;
			}
			if (fl) for (int i=1,j=r;j<=n;++i,++j) ans[j][i]^=1;
		}
//		for (int i=1;i<=n;++i) cout<<deg[i]<<' ';cout<<endl;
//		cout<<m<<endl;
		if (m) for (int i=1;i<=n;++i) if (deg[i]>deg[i+1]) for (int j=i+1;j<=n;++j) if (deg[j]<deg[j-1]&&deg[i]-deg[j]-1==m&&ans[j][i]){
			flip(i,j);
			ans[j][i]=0;
		}
		if (m>0) cout<<"No\n";
		else{
			cout<<"Yes\n";
			for (int i=2;i<=n;++i){
				for (int j=1;j<i;++j) cout<<ans[i][j];cout<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：Mirasycle (赞：1)

题意：构造一个 $n$ 个点的竞赛图，使得其中三元环个数为 $m$。

> 经典结论：竞赛图三元环个数为 ${n\choose 3}-\sum\limits_{u}{deg_u\choose 2}$，其中 $deg$ 为出度序列。

> 兰道定理：竞赛图度数序列合法当且仅当将度数序列从小到大排序，满足 $\forall k,\sum\limits_{i=1}^kdeg_i\ge {k\choose 2}$。

从上述两个结论可以看出，当度数尽可能均匀的时候，会让三元环个数增多，同时会让兰道定理更容易成立。

于是我们先让度数在满足兰道定理的情况下，尽可能不均匀分布，得到一个三元环个数很少的竞赛图。然后每次往让其更均匀一点，这样子会在三元环个数增多的情况下，保证满足兰道定理。其中初始序列是 $deg_i=i-1$。


将 $\{i,i+2\}\to \{i+1,i+1\}$ 的时候，我们可以发现三元环个数会 $+1$，如果暴力调整的话是 $O(M)$ 的。

可以发现 $O(n^3-(n-1)^3)=O(n^2)$，于是我们构造一组尽可能接近 $M$ 的解，然后暴力调整，时间复杂度就是对的了。

---

## 作者：ForgotMe (赞：0)

很不错的构造题。

## 简要题意

给一个大小为 $n$ 的竞赛图定向使得刚好存在 $m$ 个三元环。

$n\le 5000$。

## Solution

首先需要知道的是竞赛图的三元环是可以直接计算的，设 $deg_i$ 表示第 $i$ 个点的入度/出度，那么三元环的个数可以直接写为 $\binom{n}{3}-\sum_{i=1}^n \binom{deg_i}{2}$（即总数减去不合法的）。

那么这个题就变成了一个背包问题，因为 $\sum_{i=1}^n deg_i=\frac{n(n-1)}{2}$。

可惜 $n$ 超级大，直接做的话会爆炸。

不如从易到难，先考虑如何判断是否有解，可以感知到的是一个竞赛图的三元环个数存在一个上界 $M$。

如何求出这个上界呢？即让 $\sum_{i=1}^n \binom{deg_i}{2}$ 最小，先不考虑 $deg_i \in[0,n-1]$ 且为整数的限制。

注意到这个代价函数是凸的，直接使用琴生不等式，当 $deg_i$ 都为 $\frac{n-1}{2}$ 时取得最小值。

可惜当 $n$ 为偶数时，$\frac{n-1}{2}$ 不是个整数，需要对方案进行微调。

通过手玩或者打表找规律可以知道，当 $n$ 为偶数时，让 $\frac{n}{2}$ 个 $deg_i$ 取 $\frac{n}{2}$，剩下的取 $\frac{n}{2}-1$ 时 $\sum_{i=1}^n \binom{deg_i}{2}$ 取得最小值。

于是便得到了三元环个数的上界 $M$，那么如何快速构造出一个任意解呢？似乎陷入了困境。

怎么办呢？如果你尝试用暴力分别打出 $M$，$M-1$，$M-2$ 等所对应的 $deg$ 数组，可以发现相邻的 $deg$ 数组长的非常相似。

例如 $n=10$ 时，$M$ 对应的 $deg$ 数组是 $4\ 4\ 4\ 4\ 4\ 5\ 5\ 5\ 5\ 5$，$M-1$ 对应的 $deg$ 数组是 $3\ 4\ 4\ 4\ 5\ 5\ 5\ 5\ 5\ 5$，仔细观察可以发现两个 $4$ 变成了 $3$ 和 $5$。

将这个操作抽象一下就是：选择 $deg$ 数组中两个相同的数 $x$，将其分别替换为 $x-1$，$x+1$，这个操作可以将当前图的三元环减少 $1$。这是一个非常令人振奋的操作：只要能将上述操作进行 $M-m$ 次，就能构造出一个三元环个数为 $m$ 的竞赛图。

可惜不是所有的 $deg$ 数组都能构造出一个竞赛图，一个合法的 $deg$ 数组需要以下条件（假设 $deg$ 数组单调不减）：

$$
\forall 1\le k\le n,\sum_{i=1}^k deg_i\ge \binom{k}{2}
$$

- 先考虑其必要性：这是显然的，因为前 $k$ 个点中自己内部的边都有 $\binom{k}{2}$ 条。

- 再证明其充分性：考虑递归的构造一个竞赛图：选出当前 $deg$ 最小的一个点 $u$，连 $deg_u$ 条 $u$ 指向其他点的边，剩下的点全部向 $u$ 连，然后删除 $u$，根据上述条件可知删除 $u$ 后仍然存在至少一个解。

这就是兰道定理。于是这可以引发我们的思考，该如何选择数进行操作并使 $deg$ 数组合法。

通过大量手玩/打表发现，无论怎么操作都能使得 $deg$ 数组合法。考虑该操作的实际意义：假设选择的 $deg$ 数组中两个相同的数 $x$ 所对应的图中的点分别是 $u,v$ ，那么该操作等价于将边 $(u,v)$ 反向，于是只要最初的 $deg$ 数组合法，怎么操作都是合法的。同时还可以发现以下性质：

- 这个操作的先后顺序并不重要。
- 这个操作最多能进行 $M$ 次，并且进行 $M$ 次后 $deg$ 数组一定会变成 $0,1,2,3,...,n-1$。

于是暴力做法呼之欲出，直接暴力做 $M-m$ 次操作即可，时间复杂度 $\mathcal{O}(n^3)$。

如何优化呢？笔者曾尝试能否加速上述操作过程，可惜以失败告终。

注意到一个关键性质：设 $f(n)$ 表示 $n$ 个点的竞赛图所对应的三元环上界，$f(n)-f(n-1)$ 是 $n^2$ 级别的，这个东西很好证，$f(n)$ 可以将其用公式表示出来。

如果能够构造出一个大小为 $n_2$ 的三元环个数为 $m$ 的竞赛图，那么就可以构造出一个大小为 $n(n>n_2)$ 的三元环个数为 $m$ 的竞赛图，这是显然的，加入 $n-n_2$ 个无贡献的点就可以（边都朝着一个方向连）。于是正解就出来了，找到最小的 $n_2$ 满足 $f(n_2)\ge m$，然后暴力做 $f(n_2)-m$ 次操作即可，这是容易做到的。

时间复杂度 $\mathcal{O}(n^2\log n)$ 或者 $\mathcal{O}(n^2)$。

```cpp
#include <cstdio>
#include <map>
#include <iostream>
#include <algorithm>
#include <bitset>
#include <queue>
#include <stack>
#include <cstring>
#include <ctime>
#include <cmath>
#include <assert.h> 
using namespace std;
#define LL long long
#define pp pair<int,int>
#define mp make_pair 
#define ull unsigned long long
namespace IO{
	const int sz=1<<22;
	char a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];
	inline char gc(){
	//	return p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;
		return getchar();
	}
	template<class T> void gi(T& x){
		x=0; int f=1;char c=gc();
		if(c=='-')f=-1;
		for(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=gc())
			x=x*10+(c-'0');
		x=x*f;
	}
	inline void flush(){fwrite(b,1,t-b,stdout),t=b; }
	inline void pc(char x){*t++=x; if(t-b==sz) flush(); }
	template<class T> void pi(T x,char c='\n'){
		if(x<0)pc('-'),x=-x;
		if(x==0) pc('0'); int t=0;
		for(;x;x/=10) p[++t]=x%10+'0';
		for(;t;--t) pc(p[t]); pc(c);
	}
	struct F{~F(){flush();}}f; 
}
using IO::gi;
using IO::pi;
using IO::pc;
const int mod=1e9+7;
inline int add(int x,int y){
	return x+y>=mod?x+y-mod:x+y;
}
inline int dec(int x,int y){
	return x-y<0?x-y+mod:x-y;
}
inline int qkpow(int a,LL b){
	if(b<0)return 0;
	int ans=1,base=a%mod;
	while(b){
		if(b&1)ans=1ll*ans*base%mod;
		base=1ll*base*base%mod;
		b>>=1;
	}
	return ans;
}
int fac[1000005],inv[1000005],Invn[600005];
inline int C(int n,int m){
	if(n<m||m<0)return 0;
	return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;
}
void init_C(int n){
	fac[0]=1;
	for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; 
	inv[0]=1;
	inv[n]=qkpow(fac[n],mod-2);
	for(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	Invn[0]=Invn[1]=1;
	for(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;
}
int q,n,N,a[5005],p[5005],deg[5005],buc[5005];
LL m,mxcnt[5005],cs;
inline LL calc(int n){
	return 1ll*n*(2*n*n-8*n+7+(n%2?-1:1))/16;
}
inline bool pd(int x,int y,int bel){
	if(x==bel)return 0;
	return 1;
};
bool cmp(int x,int y){
	return deg[x]<deg[y];
}
bool G[5005][5005];
inline void construct(){
	for(int i=1;i<=N;i++)p[i]=i;
	for(int i=1;i<=N;i++){
		sort(p+i,p+N+1,cmp);
		for(int j=i+1;j<=i+deg[p[i]];j++){
			G[min(p[i],p[j])][max(p[i],p[j])]=pd(min(p[i],p[j]),max(p[i],p[j]),p[i]);
		}
		for(int j=i+deg[p[i]]+1;j<=N;j++){
			G[min(p[i],p[j])][max(p[i],p[j])]=pd(min(p[i],p[j]),max(p[i],p[j]),p[j]);
			deg[p[j]]--;
		}
	}
}
inline void oper(int x){
	int mx=buc[x]/2;
	if(cs<=mx){
		buc[x]-=(cs<<1);
		buc[x-1]+=cs;
		buc[x+1]+=cs;
		cs=0;
	}else{
		buc[x]-=(mx<<1);
		buc[x-1]+=mx;
		buc[x+1]+=mx;
		cs-=mx;
	}
}
inline void solve(){
	gi(n),gi(m);
	if(m==0){
		puts("Yes");
		for(int i=2;i<=n;i++){
			for(int j=1;j<i;j++)printf("%d",0);
			printf("\n");
		}	
		return ;
	}
	for(int i=0;i<=n;i++)buc[i]=0;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			G[i][j]=0;
	for(int i=3;i<=n;i++)mxcnt[i]=1ll*i*(i-1)*(i-2)/6-calc(i);
	if(m>mxcnt[n]){
		puts("No");
		return ;
	}
	for(int i=3;i<=n;i++){
		if(mxcnt[i]>=m){
			N=i;
			break;
		}
	}
	if(N%2==0)buc[N/2]=N/2,buc[N/2-1]=N/2;
	else buc[N/2]=N;
	cs=mxcnt[N]-m;
	while(cs){
		for(int j=1;j<N-1;j++){
			if(buc[j]>1){
				oper(j);
				if(!cs)break;
			}
		}
	} 
	int id=0;
	for(int i=0;i<=N-1;i++){
		if(buc[i]){
			while(buc[i]--){
				deg[++id]=i;
			}
		}
	}
	puts("Yes");
	construct();
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++)printf("%d",max(i,j)<=N?G[j][i]:1);
		printf("\n");
	}
}
signed main(){
	gi(q);
	while(q--)solve();
	return 0;
}
```

---


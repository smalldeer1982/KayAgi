# [XJTUPC 2024] 循环移位

## 题目描述

给定长度为 $2^n$ 的数组 $a_i$ ($0 \leq i < 2^n$)，你可以进行任意次循环移位。

求 $\sum_{i=0}^{2^n-1} a_i \oplus i$， $\sum_{i=0}^{2^n-1} a_i \& i$，$\sum_{i=0}^{2^n-1} a_i | i$ 的最大值。其中 $\oplus, \&, |$ 分别代表按位异或，按位与，按位或。

对于一个长度为 $m$ 的数组 $x_i$ ($0 \leq i < m$)，其进行循环移位的结果 $x'_i$ 为:

$$x'_i = \left\{
	\begin{array}{ll}
		x_{i - 1} & i \neq 0 \\
		x_{m - 1} & i = 0
	\end{array}\right.$$

## 样例 #1

### 输入

```
2
1 3 2 2
```

### 输出

```
8 5 11
```

## 样例 #2

### 输入

```
4
1 1 4 5 1 4 1 9 1 9 8 1 0 0 0 0
```

### 输出

```
149 41 157
```

# 题解

## 作者：wangyizhi (赞：6)

[**题目传送门**](https://www.luogu.com.cn/problem/P10524)

很神奇的一个题目！

~~但感觉可以蓝？~~

### 题目分析

固定原序列，则就是序列 $0,1,...,2^n-1$ 在上面滚动

考虑对于第 $i$ 位，原序列就是：

$$$0,0,...,0,1,1,...,1,0,0,...,0,1,...$$$

其中，每个循环节长 $2^{i+1}$。

我们可以先暴力计算出第一串 $0$ 从 $0$ 开始的值，然后开始滚动这串数。

注意到滚动一次之后，只会有 $2^{n-i}$ 个数发生了改变，这几个数我们也可以暴力更新答案。

但是我们发现，事实上我们只需要求出第一串 $0$ 在第一个循环节内的结果就行了。

因此总的时间复杂的只有 $O(2^{n+1})$。

最后做个类似前缀和的东西就做完了。

## AC Code

可能常数有点大。。。

```cpp
//by wangyizhi(571247)
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
using ll=long long;
using ld=long double;
#define int ll
using pii=pair<int,int>;
//bool Mst;
int n,a[1<<20],f[20][1<<20];
int solve1()
{
	memset(f,0,sizeof(f));
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<(1<<n);j++) f[i][0]+=((a[j]^j)&(1<<i));
		for(int j=1;j<(1<<(i+1));j++)
		{
			f[i][j]=f[i][j-1];
			for(int k=j-1;k<(1<<n);k+=(1<<(i+1))) f[i][j]-=(a[k]&(1<<i)),f[i][j]+=(a[k]&(1<<i))^(1<<i);//将0改为1
			for(int k=(j-1)^(1<<i);k<(1<<n);k+=(1<<(i+1))) f[i][j]-=(a[k]&(1<<i))^(1<<i),f[i][j]+=(a[k]&(1<<i));//将1该为0
		}
	}
	int ans=0;
	for(int i=1;i<n;i++) for(int j=0;j<(1<<(i+1));j++) f[i][j]+=f[i-1][j&((1<<i)-1)];
	for(int i=0;i<(1<<n);i++) ans=max(ans,f[n-1][i]);
	return ans;
}
int solve2()
{
	memset(f,0,sizeof(f));
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<(1<<n);j++) f[i][0]+=((a[j]&j)&(1<<i));
		for(int j=1;j<(1<<(i+1));j++)
		{
			f[i][j]=f[i][j-1];
			for(int k=j-1;k<(1<<n);k+=(1<<(i+1))) f[i][j]+=(a[k]&(1<<i));
			for(int k=(j-1)^(1<<i);k<(1<<n);k+=(1<<(i+1))) f[i][j]-=(a[k]&(1<<i));
		}
	}
	int ans=0;
	for(int i=1;i<n;i++) for(int j=0;j<(1<<(i+1));j++) f[i][j]+=f[i-1][j&((1<<i)-1)];
	for(int i=0;i<(1<<n);i++) ans=max(ans,f[n-1][i]);
	return ans;
}
int solve3()
{
	memset(f,0,sizeof(f));
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<(1<<n);j++) f[i][0]+=((a[j]|j)&(1<<i));
		for(int j=1;j<(1<<(i+1));j++)
		{
			f[i][j]=f[i][j-1];
			for(int k=j-1;k<(1<<n);k+=(1<<(i+1))) f[i][j]+=(a[k]&(1<<i))^(1<<i);
			for(int k=(j-1)^(1<<i);k<(1<<n);k+=(1<<(i+1))) f[i][j]-=(a[k]&(1<<i))^(1<<i);
		}
	}
	int ans=0;
	for(int i=1;i<n;i++) for(int j=0;j<(1<<(i+1));j++) f[i][j]+=f[i-1][j&((1<<i)-1)];
	for(int i=0;i<(1<<n);i++) ans=max(ans,f[n-1][i]);
	return ans;
}
//bool Med;
signed main()
{
//	cerr<<"Memory Size: "<<abs((&Med)-(&Mst))/1024.0/1024<<" MB\n";
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=0;i<(1<<n);i++) cin>>a[i];
	cout<<solve1()<<" "<<solve2()<<" "<<solve3()<<"\n";
	return 0;
}
```

---

## 作者：NaCly_Fish (赞：6)

场上犯蠢没调出来选手简单写一下题解。

首先还是考虑拆位来做，且只考虑按位 and 这个子问题，那么问题就变成：

> 给定一个 `01` 序列 $a$，求其一个循环移位 $a'$，使得 $\sum_{i=0}^{m-1}a'_i b_i$ 最大（$m=2^n$），求这个最大值。 
> 
> 其中 $b_i= [\lfloor i/ 2^d \rfloor \bmod 2=1]$，即 $i$ 的二进制下第 $d$ 位是 $1$ 则 $b_i=1$。

直接求最大值并不好做，不妨对于所有循环移位，都求出这个式子的值。

这个式子和卷积有点类似，如果将序列 $a$ 翻转，那么其与 $b$ 卷积结果的 $m-1$ 位置就是不进行移位的结果。进一步，再将 $a$ 翻转后的序列复制一份，接在其后面再与 $b$ 计算卷积，然后提取结果的 $m,m+1,\cdots,2m-1$ 项即可。

如果直接用 FFT 来计算卷积，总复杂度为 $\Theta(m \log^2 m)$，想要优化就需要考虑序列 $b$ 的一些性质。
****
比如 $d=2$ 时，序列 $b$ 应该长这样：  

$$0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,\cdots$$  

对于一般的情况也一样，都是一段 $1$ 接着一段 $0$ 的循环，且 $1$ 和 $0$ 的长度相同。由此可以直接写出 $b$ 序列的生成函数：

$$x^{2^d} \frac{1-x^{2^d}}{1-x} \frac{1-x^m}{1-x^{2^{d+1}}}$$
这个生成函数做卷积是容易处理的，细节可以看代码。
****
现在已经完成了按位 and 的这个子问题，剩下两个只需要用性质：
$$(a \oplus b)+2(a  \ \&\  b)=a+b$$
$$(a \oplus b)+(a \ \& \ b)=a \ | \ b$$
证明很简单，按位考虑一下即可。于是这题就做完了。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define p 998244353
#define N 2097159
#define ll long long
using namespace std;

inline void convovle(const int *f,int m,int d,ll *R){ // 对于序列 f 计算它和参数为 d 时的序列 b 卷积
	static ll g[N];
	memset(g,0,sizeof(g));
	for(int i=(1<<d);i<2*m;++i) g[i] = f[i-(1<<d)];

	for(int i=1;i<2*m;++i) g[i] += g[i-1];
	for(int i=2*m-1;i>=(1<<d);--i) g[i] -= g[i-(1<<d)];

	for(int i=(2<<d);i<2*m;++i) g[i] += g[i-(2<<d)];
	for(int i=2*m-1;i>=m;--i) g[i] -= g[i-m];

	for(int i=0;i<2*m;++i) R[i] = g[i];
}

void solve(const int *a,int n){
	static int f[N];
	static ll ans[N],h[N];
	memset(ans,0,sizeof(ans));
	int m = 1<<n;
	ll sum = (ll)m*(m-1)/2;
	for(int i=0;i<m;++i) sum += a[i];
	for(int d=0;d<n;++d){
		memset(f,0,sizeof(f));
		memset(h,0,sizeof(h));
		for(int i=0;i<m;++i) f[i] = (a[i]>>d)&1;
		reverse(f,f+m);
		for(int i=m;i<2*m;++i) f[i] = f[i-m];
		convovle(f,m,d,h);
		for(int i=0;i<m;++i) ans[i] += h[i+m]<<d;
	}
	ll _and = 0,_xor = 0,_or = 0;
	for(int i=0;i<m;++i){
		_xor = max(_xor,sum-2*ans[i]);
		_and = max(_and,ans[i]);
		_or = max(_or,sum-ans[i]);
	}
	printf("%lld %lld %lld",_xor,_and,_or);
}

int n;
int a[N];

int main(){
	scanf("%d",&n);
	for(int i=0;i<(1<<n);++i) scanf("%d",&a[i]);
	solve(a,n);
	return 0;
}

```

---

## 作者：D2T1 (赞：3)

## XJTUPC2024 - 循环移位

三种运算做法本质相同，考虑异或的做法。

预处理 $f_{i,j}$ 表示若循环移位后 $x_i$ 移动到 $x_0$ 的位置时，$x$ 数组每一项的二进制第 $j$ 位与下标二进制第 $j$ 位进行异或后的和。

观察到只有 $i\in[0,2^{j+1})$ 是有用的，因为 $f_{i,j}=f_{i\bmod 2^{j+1},j}$。

考虑递推 $f_{i-1,j}\to f_{i,j}$。可以观察到每 $2^j$ 位会改变一个，其他位置的值不会变（类似于 $\texttt{00001111}\to \texttt{10000111}$，只变了两位）。所以我们每次找到这样的若干位暴力修改即可。

求好 $f$ 数组后就可以暴力枚举 $x_0$ 的位置然后对于每个位置 $O(n)$ 求解了。

复杂度 $\sum_{j=0}^n2^{j+1}\dfrac{2^n}{2^j}=O(n2^n)$。

```cpp
//P10524
#include <bits/stdc++.h>
using namespace std; typedef long long ll;
void solve();int main(){ solve(); return 0; }

const int N = (1 << 20) + 10;
int n, m, a[N];
ll sum[N][20];

int clc(int p, int q, int k, int op){
	p += m;
	if(op == 0){
		return ((p>>k)&1) ^ ((q>>k)&1);
	} else if(op == 1){
		return ((p>>k)&1) & ((q>>k)&1);
	} else {
		return ((p>>k)&1) | ((q>>k)&1);
	}
}
ll calc(int op){
	memset(sum, 0, sizeof(sum));
	for(int j = 0; j < n; ++ j){
		for(int i = 0; i < m; ++ i){
			sum[0][j] += clc(i, a[i], j, op);
		}
		for(int i = 1; i < (1 << j + 1); ++ i){
			sum[i][j] = sum[i-1][j];
			for(int k = (i-1) % (1<<j); k < m; k += (1 << j)){
				sum[i][j] -= clc(k-i+1, a[k], j, op);
				sum[i][j] += clc(k-i, a[k], j, op);
			}
		}
	}
	ll ans = 0;
	for(int i = 0; i < m; ++ i){
		ll now = 0;
		for(int j = 0; j < n; ++ j){
			now += sum[i%(1<<j+1)][j] * (1 << j);
		}
		ans = max(ans, now);
	}
	return ans;
	
}

void solve(){
	scanf("%d", &n);
	m = 1 << n;
	for(int i = 0; i < m; ++ i){
		scanf("%d", &a[i]);
	}
	printf("%lld %lld %lld\n", calc(0), calc(1), calc(2));
}

```

---

## 作者：eastcloud (赞：1)

题目要求我们求出三个式子的最大值，但是可以发现 $ i|j=i+j-(i\& j)$ 和 $i\oplus j =i+j -2(i \& j)$，所以我们只要求出 $\sum a_i\&i$ 的最大值和最小值即可。

位运算考虑拆位算贡献，关注一个数的某一位，我们把该位为 1 的数看作黑色块否则是白色块，考虑和它对应的数，只有对应的数是黑色块才可能有贡献。

接着我们可以观察到若干性质，比如和它对应的数的颜色随着循环移位也是周期性变化的，且有若干小区间自己循环且本质相同。

然后你可以按每个数的下标对小区间长度取模的方式分类，然后计算每个类有多少数对应位为 1（注意这里都是只考虑一个位的贡献），如果循环移位的长度在某些区间里那就有对应贡献，暴力找出区间并维护就可以，因为不难发现总区间个数是 $\sum 2^i $ 的，代码很好写。

```cpp
ll a[N];
vector<ll> cnt[25];
int main(){
    #ifdef EAST_CLOUD
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
    #endif
    ll ans=0,n=read(),ansmin=inf,sum=0;
    ll res=0;
    for(ll i=0;i<(1<<n);i++)a[i]=read(),sum+=a[i],sum+=i;
    for(ll i=0;i<n;i++){
        ll mod=(1<<(i+1));
        cnt[i].resize(mod);
        for(ll j=0;j<(1<<n);j++){
            if(a[j]&(1<<i))cnt[i][j%mod]++;
        }
        for(ll j=0;j<mod;j++)if(j>=mod/2)res+=(1<<i)*cnt[i][j];
    }
    ans=res;ansmin=res;
    for(ll i=1;i<(1<<n);i++){
        for(ll j=0;j<n;j++){
            ll mod=(1<<(j+1));
            ll p=((i-1)%mod+mod/2)%mod;
            ll p2=(i-1)%mod;
            res+=(1<<j)*(cnt[j][p2]-cnt[j][p]);
        }
        ans=max(ans,res);ansmin=min(ansmin,res);
    }
    write(sum-2*ansmin);putchar(' ');write(ans);putchar(' ');write(sum-ansmin);
}

```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10524)

**题目大意**

> 给定长度为 $2^n$ 的序列 $a$，求一个循环移位最大化 $\sum a_i\operatorname{AND}i,\sum a_i\operatorname{OR}i,\sum a_i\oplus i$。
>
> 数据范围：$n\le 20$。

**思路分析**

考虑暴力枚举循环移位的大小，即每次将所有元素左移一位，动态维护三个答案。

用支持全局 $+1$ 的 Trie，从高到低位维护，每次循环移位相当于交换 $\mathcal O(n)$ 对左右兄弟。

我们在深度为 $d$ 的节点维护第 $d$ 位的贡献，push up 的时候只需要数左右子树有多少个 $a_i$ 的第 $d$ 位为 $1$，这是简单的。

时间复杂度 $\mathcal O(n2^n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1<<21;
int n,a[MAXN],d[MAXN],tg[MAXN],f[MAXN];
ll X[MAXN],Y[MAXN],Z[MAXN];
void ins(int p,int u,int x) {
	if(p>1) f[p]+=x>>(d[p]-1)&1;
	if(d[p]==n) return ;
	int c=u>>d[p]&1;
	ins(p<<1|c,u,x);
}
void psu(int p) {
	int k=d[p],s=1<<(n-k-1),ls=p<<1|tg[p],rs=ls^1;
	X[p]=X[ls]+X[rs]+((ll)(f[ls]+s-f[rs])<<k);
	Y[p]=Y[ls]+Y[rs]+((ll)f[rs]<<k);
	Z[p]=Z[ls]+Z[rs]+((ll)(f[ls]+s)<<k);
}
void rot(int p) {
	if(d[p]==n) return ;
	rot(p<<1|tg[p]),tg[p]^=1,psu(p);
}
signed main() {
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=2;i<(2<<n);++i) d[i]=d[i>>1]+1;
	for(int i=0;i<(1<<n);++i) cin>>a[i],ins(1,i,a[i]);
	for(int i=(1<<n)-1;i;--i) psu(i);
	ll sx=X[1],sy=Y[1],sz=Z[1];
	for(int i=1;i<(1<<n);++i) rot(1),sx=max(sx,X[1]),sy=max(sy,Y[1]),sz=max(sz,Z[1]);
	cout<<sx<<" "<<sy<<" "<<sz<<"\n";
	return 0;
}
```

---


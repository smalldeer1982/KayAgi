# [XJTUPC 2024] 图上操作

## 题目描述

你有一张 $n$ 个点 $m$ 条边的**有向图**，点的下标为 $1\sim n$。每条边有一个正整数边权 $d_i$。特殊的，$1\le d_i \le 100$。

现在定义点 $i$ 的瓶颈路大小为：所有从点 $1$ 到点 $i$ 的有向路径中，最小边权的最大值。特殊的，若 $i$ 不能从 $1$ 出发到达，则其瓶颈路权值为 $0$。

有 $q$ 次修改，每次修改会指定一条边，将这条边的边权降低，保证降低后依然是正整数。

现在要求每次修改后，输出编号为 $2\sim n$ 的点的瓶颈路大小。注意，每次修改是在前面修改的基础上进行操作，并不是相互独立的。

由于输出数据量过于巨大，设每次修改完后点 $i$ 的瓶颈路大小为 $ans_i$，你只需要输出 $(\sum_{i=2}^n ans_i \times 2^i)\bmod 998244353$。

## 说明/提示

第一次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $4$。

第二次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $3$。

第三次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。

第四次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。

## 样例 #1

### 输入

```
3 3 4
1 2 3
2 3 4
1 3 5
3 1
3 2
1 2
2 3
```

### 输出

```
44
36
20
20
```

# 题解

## 作者：苏联小渣 (赞：4)

先考虑没有修改的情况，套路地按照权值从大到小排序，倒序加边，每次加一个权值为 $v$ 的边就从这条边的起始点开始遍历未被遍历过的点（前提是起始点现在可从 $1$ 到达），然后此时遍历到的点的答案就是 $v$。

考虑有修改的情况，发现权值都很小，这其实我们对于每个值做。对于每个值 $v$，维护当前只保留 $\ge v$ 的边形成的子图 $G_v$，同时维护每个图中点到 $1$ 的可达情况，那么一个点 $x$ 目前的答案，就是一个最大的 $v$，使得在 $G_v$ 中 $x$ 是从 $1$ 可达的。

如果直接做的话需要支持删边、维护联通性，显然不好做；考虑把操作离线然后倒过来，就变成了加边。这样每次将权值 $d_x$ 增加 $y$ 影响的图只有 $y$ 个，对这些图暴力做即可。由于每次都是遍历未被遍历过的点，所以每个点只会被遍历一次，时间复杂度 $O(nd_i)$。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define N 100
int n, m, q, ans, pw[100010], dx[200010], dy[200010], mx[200010], out[200010], vis[105][100010];
const int mo = 998244353;
struct Graph{
	int p, h[100010];
	struct node{
		int x, y, next;
	}d[200010];
	void add(int x, int y){
		d[++p].y = y, d[p].next = h[x], h[x] = p;
	}
}G[105];
struct edge{
	int x, y, z;
}a[200010];
void dfs(int id, int x){
	vis[id][x] = 1;
	if (id > mx[x] && x != 1){
		ans = (ans - 1LL * pw[x] * mx[x] % mo + mo) % mo;
		ans = (ans + 1LL * pw[x] * id % mo) % mo;
		mx[x] = id;
	}
	for (int i=G[id].h[x]; i; i=G[id].d[i].next){
		int y = G[id].d[i].y;
		if (vis[id][y]) continue;
		dfs(id, y);
	}
}
int main(){
	scanf ("%d%d%d", &n, &m, &q);
	pw[0] = 1;
	for (int i=1; i<=n; i++){
		pw[i] = 2LL * pw[i-1] % mo; 
	}
	for (int i=1; i<=m; i++){
		scanf ("%d%d%d", &a[i].x, &a[i].y, &a[i].z);
	}
	for (int i=1; i<=q; i++){
		scanf ("%d%d", &dx[i], &dy[i]);
		a[dx[i]].z -= dy[i];
	}
	for (int i=1; i<=m; i++){
		for (int j=1; j<=a[i].z; j++){
			G[j].add(a[i].x, a[i].y);
		}
	}
	for (int i=1; i<=N; i++){
		dfs(i, 1);
	}
	for (int i=q; i>=1; i--){
		out[i] = ans;
		for (int j=a[dx[i]].z+1; j<=a[dx[i]].z+dy[i]; j++){
			G[j].add(a[dx[i]].x, a[dx[i]].y);
			if (vis[j][a[dx[i]].x]) dfs(j, a[dx[i]].x);
		}
		a[dx[i]].z += dy[i];
	}
	for (int i=1; i<=q; i++){
		printf ("%d\n", out[i]);
	}
	return 0;
}
```

---

## 作者：minstdfx (赞：3)

较难题，没调出来，呜呜呜。  
如果没有修改权值，考虑类似 kruskal 的过程，按权值从大到小加边，出现第一次 $1$ 到 $k$ 可达时的权值即为 $k$ 的答案。  
考虑维护 100 张图表示边权不小于 $v$ 的子图，删边难以维护，考虑离线下来改为加边权，这样变成加边。对于每张图进行维护，直接遍历维护，复杂度考虑每个点只会被访问出边当且仅当这个点变为可达点。因此总复杂度为 $\Theta((n+m)\max d+q)$。

---

## 作者：xiezheyuan (赞：1)

## 简要题意

> H. 图上操作
>
> 给出一个 $n$ 个点 $m$ 条边的有向图。边有边权。
>
> 定义点 $i$ 的价值 $V_i$，为从 $1$ 到 $i$ 的路径中的最大瓶颈路（最小边最大值）长度。
>
> 特别地，若不存在合法的长度 $>0$ 的路径，则价值为 $0$。定义整个图的价值为 $\sum_{i=1}^{n}2^iV_i \bmod 998244353$。
>
> 有 $q$ 次操作，每次操作选定一条边和一个常数 $x$，令这条边的权值减去 $x$。操作完成后，你需要求出整个图的价值。
>
> $1\leq n\leq 10^5,1\leq m,q\leq 2\times10^5$，保证对于任意时刻，边权为位于区间 $[1,100]$ 的正整数。

## 思路

很好玩的一道题！首先发现边权特别小，一定是在边权上搞事情。

我们暴力一点，对于每一个 $x\in[1,100]$，维护所有边权 $\leq x$ 的边构成的子图。这样子的话，每个点 $i$ 的最大瓶颈路，就是按照 $x$ 从右往左扫描，遇到的最后一个存在路径 $(1,i)$ 的 $x$ 即可。

然后考虑如何做修改，发现修改等价于将一些图的边断掉，这显然不好维护，我们离线，然后倒着处理改成加边。

对于有向图与 $1$ 的连通性问题，并查集肯定是不能做的，考虑每一次加边的时候，如果出点与 $1$ 连通，就 BFS/DFS 一遍。注意需要保证每个点在每张图中只会被遍历一次。每遍历到一个新连通的点，就更新一下答案。

时间复杂度 $O((n + m+q)W)$，其中 $W=100$，可以通过本题。

## 代码

不知道为什么在 Gym 上过不去，反正在 Luogu 过了就行。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 5, M = 2e5 + 5, mod = 998244353;
int f[N], ans, n, pw2[N], m, q;

int Add(int x, int y){ return (x + y) > mod ? (x + y - mod) : (x + y); }
int Sub(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
void update(int i, int val){
    ans = Sub(ans, f[i] * pw2[i] % mod);
    f[i] = val;
    ans = Add(ans, f[i] * pw2[i] % mod);
}

struct graph{
    int val;
    vector<int> vct[N];
    bool vis[N];
    void init(int n, int val_){ val = val_; vis[1] = 1; }

    void merge(int x, int y){
        vct[x].push_back(y);
        if(!vis[x]) return;
        queue<int> q; q.push(x);
        while(!q.empty()){
            int u = q.front(); q.pop();
            for(int v : vct[u]){
                if(vis[v]) continue;
                vis[v] = 1; update(v, val);
                q.push(v);
            }
        }
    }
} g[105];

struct edge{
    int u, v, w;
} edg[M];

struct queries{
    int id, x;
} que[M];
int answer[M];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m >> q;
    for(int i=1;i<=m;i++) cin >> edg[i].u >> edg[i].v >> edg[i].w;
    for(int i=1;i<=q;i++){
        cin >> que[i].id >> que[i].x;
        edg[que[i].id].w -= que[i].x;
    }
    pw2[0] = 1;
    for(int i=1;i<=n;i++) pw2[i] = (pw2[i - 1] * 2) % mod;
    for(int i=1;i<=100;i++) g[i].init(n, i);
    for(int i=1;i<=100;i++){
        for(int j=1;j<=m;j++){
            if(edg[j].w < i) continue;
            g[i].merge(edg[j].u, edg[j].v);
        }
    }
    for(int i=q;i;i--){
        answer[i] = ans;
        int id = que[i].id, x = que[i].x;
        for(int j=1;j<=x;j++) g[edg[id].w + j].merge(edg[id].u, edg[id].v);
        edg[id].w += x;
    }
    for(int i=1;i<=q;i++) cout << answer[i] << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：xiao7_Mr_10_ (赞：0)

这个题的唯一难点在于卡常。

把问题离线，按权值建分层图。按照 $d$ 排序后套路的转化问题，把删除改成加入。

计入答案是平凡的，从点 $x$ 遍历某层的每一个点，遇到遍历过的不管。

由于每个点只会被遍历一次，所以时间复杂度为 $O(nd_i)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,mod=998244353;
struct edge{
	int u,v,w;
}a[N<<1];
struct ques{
	int x,k;
}wt[N<<1];
int n,m,q,vis[101][N],pw[N],f[N],ans;
inline int read() {
  int x = 0, w = 1;
  char ch = 0;
  while (ch < '0' || ch > '9') {  
    if (ch == '-') w = -1;        
    ch = getchar();              
  }
  while (ch >= '0' && ch <= '9') {  
    x = (x<<3) +(x<<1)+(ch^48); 
    ch = getchar();  
  }
  return x * w;
}
struct Edge{
	int tot,head[N<<1];
	struct line{
		int u,v,nxt;
	}ed[N<<1];
	inline void add(int u,int v){
		ed[++tot].v=v;
		ed[tot].nxt=head[u];
		head[u]=tot;
	}
}g[103];
inline void dfs(int u,int dep){
	vis[dep][u]=1;
	if(u!=1&&dep>f[u]){
		ans=(ans-1ll*pw[u]*f[u]%mod+mod)%mod;
		ans=(ans+1ll*pw[u]*dep%mod)%mod;
		f[u]=dep;
	}
	for(register int i = g[dep].head[u];i;i=g[dep].ed[i].nxt){
		int v=g[dep].ed[i].v;
		if(vis[dep][v])continue;
		dfs(v,dep);
	}return;
}int ans1[N<<1];
signed main(){
	n=read(),m=read(),q=read();pw[0]=1;
	for(register int i = 1;i <= n;i++)pw[i]=pw[i-1]*2ll%mod;
	for(register int i = 1;i <= m;i++)a[i].u=read(),a[i].v=read(),a[i].w=read();//cin >> a[i].u >> a[i].v >> a[i].w;
	for(register int i = 1;i <= q;i++)wt[i].x=read(),wt[i].k=read(),a[wt[i].x].w-=wt[i].k;
	for(register int i = 1;i <= m;i++)
		for(int j = 1;j <= a[i].w;j++)
			g[j].add(a[i].u,a[i].v);
	for(register int i = 1;i <= 100;i++)dfs(1,i);
	for(register int i = q;i >= 1;i--){
		int id=wt[i].x;ans1[i]=ans;
		for(register int j = a[id].w+1;j <= a[id].w+wt[i].k;j++){
			g[j].add(a[id].u,a[id].v);
			if(vis[j][a[id].u])dfs(a[id].u,j);
		}a[id].w+=wt[i].k;
	}for(register int i = 1;i <= q;i++)printf("%d\n",ans1[i]);//cout << ans1[i] << "\n";
	return 0;
}//卡常快读h的OIwiki 
```

---

## 作者：leiaxiwo (赞：0)

# 题解：P10525 [XJTUPC2024] 图上操作
[传送门](https://www.luogu.com.cn/problem/P10525)
### 题意分析
较难题，调试时间长。

瓶颈路的定义很有意思：
>所有从点 $1$ 到点 $i$ 的有向路径中，最小边权的**最大值**。
>
>特殊的，若 $i$ 不能从 $1$ 出发到达，则其瓶颈路权值为 $0$。

翻译一下，给两个点，这两个点之间有多条路可以抵达，在不走多余的路的前提下，选择两个点之间最长的那条路。

![](https://cdn.luogu.com.cn/upload/image_hosting/qwf12p96.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图（正常来说是有向图，这里画假了但是不影响），点 $1 \to 2$ 有两条路，$1 \to 2$ 或者 $1 \to 4 \to 2$，显然它的瓶颈路长度为 $2 + 2 =4$，因为 $1 \to 4 \to 2$ 是在不走多余的路的前提下两个点之间最长的那条路。

这个图留给大家把玩一下，我们继续。

先考虑没有修改的情况，我们通过控制加边数量来对这题分而治之。

[苏联小渣](https://www.luogu.com.cn/article/zmy50hi8)的做法很优，这里参考了她的做法。

按照权值从大到小排序，倒序加边，每次加一个权值为 $v$ 的边就从这条边的起始点开始遍历未被遍历过的点，后此时遍历到的点的答案就是 $v$。

考虑有修改的情况，发现权值都很小，这启示我们针对每一个值做。

对于每个值 $v$，维护当前只保留 $\ge v$ 的边形成的子图 $G_v$，同时维护每个图中点到 $1$ 的可达情况。

那么一个点 $x$ 目前的答案，就是一个最大的 $v$，使得在 $G_v$ 中 $x$ 是从 $1$ 可达的。

把操作离线然后倒过来，就变成了加边。和不修改的情况很类似。对这些图暴力做即可。

估算时间复杂度 $O(nd_i)$。感兴趣的可以去看看她的证明，这里存疑，但是可过。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,Q,ans;
int pw[500005],maxx[500005];
int dx[500005],dy[500005];
int answer[500005];
bool vis[505][500005];
const int mod=998244353;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
struct G{
	int tot,head[200005];
	struct node{
		int u,v,next;
	}ed[200005];
	void add(int u,int v){
		ed[++tot].v=v;
		ed[tot].next=head[u];
		head[u]=tot;
		return ;
	}
}liver_Graph[105];
struct edge{
	int u,v,val;
}e[500005];
inline void dfs(int id,int x){
	vis[id][x]=1;
	if(id>maxx[x]&&x!=1){
		ans=(ans-1ll*pw[x]*maxx[x]%mod+mod)%mod;
		ans=(ans+1ll*pw[x]*id%mod+mod)%mod;
		maxx[x]=id;
	}
	for(int i=liver_Graph[id].head[x];i;i=liver_Graph[id].ed[i].next){
		int v=liver_Graph[id].ed[i].v;
		if(vis[id][v]){
			continue;
		}
		dfs(id,v);
	}
	return ;
}
signed main(){
	pw[0]=1;
	n=read(),m=read(),Q=read();
	for(int i=1;i<=n;i++){
		pw[i]=2ll*pw[i-1]%mod;
	}
	for(int i=1;i<=m;i++){
		e[i].u=read();
        e[i].v=read();
        e[i].val=read();
	}
	for(int i=1;i<=Q;i++){
		dx[i]=read();
		dy[i]=read();
		e[dx[i]].val-=dy[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=e[i].val;j++){
			liver_Graph[j].add(e[i].u,e[i].v);
		}
	}
	for(int i=1;i<=100;i++){
		dfs(i,1);
	}
	for(int i=Q;i>=1;i--){
		answer[i]=ans;
		for(int j=e[dx[i]].val+1;j<=e[dx[i]].val+dy[i];j++){
			liver_Graph[j].add(e[dx[i]].u,e[dx[i]].v);
			if(vis[j][e[dx[i]].u]){
				dfs(j,e[dx[i]].u);
			}
		}
		e[dx[i]].val+=dy[i];
	}
	for(int i=1;i<=Q;i++){
		printf("%d\n",answer[i]);
	}
	return 0;
}
```

---


# [XJTUPC 2024] 勘探队

## 题目描述

一支勘探队从 $(0,0)$ 出发，终点是 $(0,y)$，携带着从 $1$ 号到 $n$ 号设备，每个设备的重量为 $m_i$，且必须安放在横坐标为 $x_i$ 的任意位置上（纵坐标可以是任意实数）。必须按照顺序安放所有设备，在较小编号的设备被全部放置之前，即使横坐标位置满足，也不能放置。

当勘探队身上的设备总重量为 $m$ 时，其移动一单位长度的代价是 $m+M$。问勘探队完成所有设备安装并到达终点的最小代价。

同一个坐标位置可以放置多台设备。

## 说明/提示

走直线走到 $(12,5)$，距离 $13$，然后走直线走到 $(0,14)$，距离 $15$，总代价 $13\times (25+14)+15\times 25=882$。不存在一个比这个更优的解。

## 样例 #1

### 输入

```
1 25 14
14
12
```

### 输出

```
882.000000
```

# 题解

## 作者：zhouyuhang (赞：3)

vp 的时候没来及看这题，后来想了想会了。题解区另一篇题解不知道在干什么，所以下面是一个非常简单的做法。

首先将路程划分为 $0 \to x_1, x_1 \to x_2, \cdots, x_n \to 0$ 这 $n + 1$ 个部分，并记第 $i$ 个部分 $y$ 坐标的变化量为 $y_i$，定义第 $i$ 段的代价函数 $f_i(y) = \left(M + \sum _ {j = i} ^ n m_j \right) \sqrt {d_i ^ 2 + y ^ 2}$，其中 $d_i = |x_i - x_{i - 1}|$，$x_0 = x_{n + 1} = 0$，则题目即要求我们在 $\sum _ {i = 1} ^ {n + 1} y_i = y$ 的条件下最小化 $\sum _ {i = 1} ^ {n + 1} f_i(y_i)$ 的值。

而这是简单的，只需注意到在最优方案中一定有 $f_1'(y_1) = f_2'(y_2) = \cdots = f_{n + 1}' (y_{n + 1})$，否则对于 $f_i'(y_i) < f_j'(y_j)$，我们只需将 $y_i$ 调小 $y_j$ 调大即可获得一组更优解。而注意到 $f_i'(y) = \left(M + \sum _ {j = i} ^ n m_j \right) \frac {y} {\sqrt{d_i ^ 2 + y ^ 2}}$ 单增，因此我们直接二分导函数的值并回代即可做到 $O(n \log V)$。

---

## 作者：minstdfx (赞：3)

中档题。  
容易看出光路折射模型，将坐标摊平，二分入射角，维护入射角的 $\operatorname{sin}$ 值，注意特判全反射的情况。

UPD：我们首先处理横坐标变换，改为全部向右走的形式（$\Delta x_i=x_i'-x'_{i-1}=|x_i-x_{i-1}|,x_{n+1}=0$），这样当前单位长度路径所耗费的代价就仅与当前横坐标位置相关。考虑代价可以转化为类似路程除以速度（速度 $v_i$ 为当前总质量 $M_i=\sum_{j=i}^n m_i+M$ 的倒数）的形式，根据拉格朗日乘数法证明或者利用初中物理知识可以知道，如果我们模拟类似光路折射的入射角偏转并最后到达了某个点，则经过的路径一定是到达该点的最小代价路径。同理可以证明，由于光速不断变快，入射角单调增加，在中途不发生全反射的情况下，最后到达 $x=x'_{n+1}$ 的时候 $y$ 坐标是入射角的单调增函数。因此可以二分入射角，在二分过程中维护当前偏转角 $\theta$（为了保留精度，维护 $\delta=\sin\theta$），在第 $i$ 个介质内经过的路程为 $S_i=\dfrac{x'_i-x'_{i-1}}{\cos\theta}=\dfrac{\Delta x_i}{\sqrt{1-\delta^2}}$，代价为 $\dfrac {S_i}{v_i}$。光线离开介质 $i$ 时由折射定律，$\dfrac{\sin \theta}{\sin\theta'}=\dfrac{v_i}{v_{i+1}}$。假设计算出的 $\sin{\theta'}>1$，说明发生了全反射。若最终 $y>y_0$ 或者中途发生了全反射则说明入射角过大，否则说明入射角过小。

细节比较多。
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int maxn=10009;
using ld=long double;
#define eps 1e-12
ld m[maxn],x[maxn];
ld X[maxn];
ld v[maxn];
int main()
{
	int n;
	ld M,y;

	scanf("%d",&n);
	scanf("%Lf %Lf",&M,&y);
	for(int i=1;i<=n;++i) scanf("%Lf",m+i);
	for(int i=1;i<=n;++i) scanf("%Lf",X+i);
	int fl=1;
	for(int i=1;i<=n;++i){
		if(std::abs(X[i])>eps){
			fl=0;
		}
	}
	if(fl){
		printf("%.9Lf\n",y*M);
		return 0;
	}
	for(int i=1;i<=n;++i)
		x[i]=x[i-1]+std::abs(X[i]-X[i-1]);
	x[n+1]=x[n]+std::abs(X[n]);
	v[++n]=M;
	for(int i=n-1;i;--i)
		v[i]=v[i+1]+m[i];
	ld sum=v[1];
	long double l=0,r=std::acos(-1)/2-eps;
	long double res=-1,mid,ans=-1;
	while(r-l>eps)
	{
		mid=(l+r)/2; res=0;
		long double san=std::sin(mid),cy=0;
		int flag=0;
		for(int i=1;i<n;++i)
		{
			ld R=(x[i]-x[i-1])/std::sqrt(1-san*san);
			res+=R*v[i];
			cy=cy+R*san;
			san*=v[i]/v[i+1];
			if(san>1){
				flag=1;
				break;
			}
		}
		ld R=(x[n]-x[n-1])/std::sqrt(1-san*san);
		res+=R*v[n];
		cy=cy+R*san;
		if(flag || cy>y)
		{
			r=mid;
			if(flag!=1)ans=res;
		}
		else{
			l=mid;
			ans=res;
		}
	}
	printf("%.9Lf\n",ans);
	return 0;
}
```

---


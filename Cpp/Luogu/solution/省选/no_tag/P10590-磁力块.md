# 磁力块

## 题目描述

在一片广袤无垠的原野上，散落着 $N$ 块磁石。

每个磁石的性质可以用一个五元组 $(x,y,m,p,r)$ 描述，其中 $x,y$ 表示其坐标，$m$ 是磁石的质量，$p$ 是磁力，$r$ 是吸引半径。

若磁石 $A$ 与磁石 $B$ 的距离不大于磁石 $A$ 的吸引半径，并且磁石 $B$ 的质量不大于磁石 $A$ 的磁力，那么 $A$ 可以吸引 $B$。

小取酒带着一块自己的磁石 $L$ 来到了这片原野的 $(x_0,y_0)$ 处，我们可以视磁石 $L$ 的坐标为 $(x_0,y_0)$。

小取酒手持磁石 $L$ 并保持原地不动，所有可以被 $L$ 吸引的磁石将会被吸引过来。

在每个时刻，他可以选择更换任意一块自己已经获得的磁石（当然也可以是自己最初携带的 $L$ 磁石）在 $(x_0,y_0)$ 处吸引更多的磁石。

小取酒想知道，他最多能获得多少块磁石呢？

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 1000$。

对于另外 $30\%$ 的数据，$p=r$。

对于 $100\%$ 的数据，$1 \le N \le 250000$，$-10^9 \le x,y \le 10^9$，$1 \le m,p,r \le 10^9$。

## 样例 #1

### 输入

```
0 0 5 10 5
5 4 7 11 5
-7 1 4 7 8
0 2 13 5 6
2 -3 9 3 4
13 5 1 9 9```

### 输出

```
3```

# 题解

## 作者：cyffff (赞：12)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10590)

来自传奇讨论区大神 @[年年有年](https://www.luogu.com.cn/user/377973) 的 $O(n\log n)$ 做法！

## 题意

有 $n+1$ 块磁铁 $0\sim n$，每个磁铁都有四个属性 $(d_i,m_i,p_i,r_i)$，如果你拥有了磁铁 $i$，那么你就能吸引并拥有所有满足 $d_j\le r_i,m_j\le p_i$ 的磁铁 $j$，初始你只拥有磁铁 $0$，求最后你能得到多少的磁铁。

$n\le 2.5\times 10^5$。
## 思路
考虑我们 BFS 中要求出满足两维偏序限制的还未被拥有过的磁铁，则预先对一维排序，另一维使用数据结构维护。

具体做法为，我们对线段树每个结点维护一个 `vector`，初始按 $m$ 从小到大排序，将 $i$ `push_back` 至所有包含 $d_i$ 的结点，这样每个结点的 `vector` 中的下标就满足其 $m$ 值是递增的。对每个结点维护一个指针 $u$ 表示这个结点的 `vector` 的前 $u$ 个磁铁都已经访问过，搜一个磁铁 $i$ 能更新的磁铁时直接在 $[1,r_i]$ 所拆出的所有结点上不断增加指针直至其对应 $m$ 值大于 $p_i$ 即可。

所有 `vector` 的大小和为 $O(n\log n)$，指针只会后移，所以时间复杂度为 $O(n\log n)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
    
}
const int N=2.5e5+10;
int n,x[N],y[N],m[N],p[N],r[N],d[N],tp[N];
bool vis[N];
vector<ll>lsh;
inline ll dis(int i,int j){
	return 1ll*(x[i]-x[j])*(x[i]-x[j])+1ll*(y[i]-y[j])*(y[i]-y[j]);
}
inline bool cmp(int i,int j){
	return m[i]<m[j];
}
queue<int>q;
struct Segment_Tree{
	#define ls (rt<<1)
	#define rs (rt<<1|1)
	int id[N<<2];
	vector<int>vec[N<<2];
	inline void ins(int rt,int l,int r,int p,int v){
		vec[rt].push_back(v);
		if(l==r) return ;
		int mid=l+r>>1;
		if(p<=mid) ins(ls,l,mid,p,v);
		else ins(rs,mid+1,r,p,v);
	}
	inline void upd(int rt,int l,int r,int L,int R,int w){
		if(id[rt]==vec[rt].size()) return ;
		if(L<=l&&r<=R){
			while(id[rt]<vec[rt].size()&&m[vec[rt][id[rt]]]<=w){
				if(!vis[vec[rt][id[rt]]]) q.push(vec[rt][id[rt]]),vis[vec[rt][id[rt]]]=1;
				id[rt]++;
			}
			return ;
		}
		int mid=l+r>>1;
		if(L<=mid) upd(ls,l,mid,L,R,w);
		if(R>mid) upd(rs,mid+1,r,L,R,w);
	}
}T;
int main(){
	x[0]=read(),y[0]=read(),p[0]=read(),r[0]=read();
	n=read();
	lsh.push_back(0);
	for(int i=1;i<=n;i++)
		x[i]=read(),y[i]=read(),m[i]=read(),p[i]=read(),r[i]=read(),
		lsh.push_back(dis(0,i)),tp[i]=i;
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	int c=lsh.size()-1; 
	for(int i=0;i<=n;i++)
		d[i]=lower_bound(lsh.begin(),lsh.end(),dis(0,i))-lsh.begin(),
		r[i]=upper_bound(lsh.begin(),lsh.end(),1ll*r[i]*r[i])-lsh.begin()-1;
	sort(tp+1,tp+n+1,cmp);
	for(int i=1;i<=n;i++)
		T.ins(1,1,c,d[tp[i]],tp[i]);
	q.push(0);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		T.upd(1,1,c,1,r[x],p[x]);
	}
	int ans=0;
	for(int i=1;i<=n;i++)
		ans+=vis[i];
	write(ans);
	flush();
}
```

---

## 作者：CNS_5t0_0r2 (赞：8)

分块好题。

首先考虑暴力做法，初始只有一个机械臂，我们暴力的把所有能抓过来的机械臂都抓过来，再分别尝试抓过来的机械臂。

这显然是一个 bfs 的过程，复杂度为 $O(n ^ 2)$，无法通过题目。

分块本身就是一个优雅的暴力，所以我们考虑本题使用分块优化。

不妨先取块长为 $\sqrt{n}$。

我们接下来分析：暴力有什么问题？

我们发现，暴力法每次都要把所有机械臂遍历一遍，无论其是否被抓走，这导致很多已经被抓走的机械臂被重复遍历了很多次，考虑从这个角度优化。

可以发现这么一个性质：设第 $i$ 个机械臂到 $(x,y)$ 的距离为 $dis_i$，如果 $dis$ 和 $m$ 都是单调不减的，我们显然可以维护一个指针，每次向右移动指针抓取机械臂直到不能抓为止。

在本例中，指针是不用向左移的，即每个机械臂都只会遍历一次，所以总复杂度是 $O(n)$ 的。

~~但出题人会这么良心吗？不会的！~~

不过，这给我们一个启发：我们可以让每个块内都有类似的性质，即我们对每个块维护一个上例中的指针，使这个指针不用左移。

上例中 $dis$ 和 $m$ 是严格单调的，但是我们无法通过排序使 $dis$ 和 $m$ 都单调。

本题关键来了：

我们可以通过“整体” $m$ 单调，“块内” $dis$ 单调。形式化来讲，记 $belong_i$ 为第 $i$ 个机械臂所在块的编号，对于任意 $i < j$，若 $belong_i < belong_j$，则 $m_i \leq m_j$；若 $belong_i = belong_j$，则 $dis_i \leq dis_j$。

这个思路巧妙在哪？

分块遵循的都是整体维护，块内暴力原则，那本题中的整体是什么？

很显然，有了整体的 $m$ 单调，我们可以确定我们需要查询哪些块，不查询哪些块。

具体来说，我们可以对每个块维护一个 $Max$ 表示最重的机械臂重量。我们从左往右暴力查找（也可以二分，但只起到优化常数的效果），当查找到第一个 $Max_k > p$ 时，说明 $1 \sim k - 1$ 块中所有机械臂的 $m$ 都满足要求，第 $k + 1 \sim n$ 块中所有机械臂的 $m$ 都不满足要求，第 $k$ 块无法确定，需要暴力 $O(\sqrt{n})$ 查询。

对于前 $k - 1$ 块，就可以用上述移动指针的方式查询，每个块均摊是 $O(1)$ 的，所以这部分查询复杂度也是 $O(\sqrt{n})$ 的。

综上，我们得到了一个 $O(n\sqrt{n})$ 的算法。

很奇怪的是我的代码中常量 $N$ 的大小需要比题目中的 $n$ 开大 $4$ 倍，否则会 RE，有大佬可以解释的欢迎留言！

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
typedef long long ll;
const int N = 1e6 + 9,SqrtN = 1e6 + 9;
int n;
struct Data{
    int x,y,m,p;
	ll r,dis;//dis存的是真实距离的平方，所以将读入的 r 也全部平方
} a[N];
struct block{//存储块的结构体
    int l,r;//块的左右边界，注意本代码中直接将 l 当作文中提到的指针使用
} b[SqrtN];
int belong[N];
int block_cnt,block_len;
int Max[SqrtN];
bool vis[N];
ll sq(int k){
    return (ll)k * k;
}
ll dist(Data m1,Data m2){
    int x1 = m1.x,y1 = m1.y,x2 = m2.x,y2 = m2.y;
    return sq(x1 - x2) + sq(y1 - y2);
}
bool cmp1(Data m1,Data m2){
    return m1.m < m2.m;
}
bool cmp2(Data m1,Data m2){
    return m1.dis < m2.dis;
}
void block_sort(int block_id){//块内按dis排序
    int l = b[block_id].l,r = b[block_id].r;
    sort(a + l,a + r + 1,cmp2);
}
void build_block(){
    block_cnt = block_len = (int)sqrt(n);
    for(int i = 1;i <= block_cnt;i++){
        b[i].l = b[i - 1].r + 1;
        b[i].r = block_len * i;
    }
    b[block_cnt].r = n;
    for(int i = 1;i <= block_cnt;i++){
        block_sort(i);
        for(int j = b[i].l;j <= b[i].r;j++){
            Max[i] = max(Max[i],a[j].m);
            belong[j] = i;
        }
    }
}
queue<Data>q;
int ans;
void attract(Data u){
    int pos = n + 1;
    for(int i = 1;i <= block_cnt;i++)
        if(Max[i] > u.p){
            pos = i;
            break;
        }
    for(int i = 1;i <= pos - 1;i++){
        while(b[i].l <= b[i].r && dist(a[0],a[b[i].l]) <= u.r){
            int j = b[i].l;
            if(!vis[j]){            
                ans++;
                q.push(a[j]);
                vis[j] = true;//这个加不加无所谓
            }
            b[i].l++;//移动指针
        }
    }
    if(pos == n + 1)
        return;
    for(int i = b[pos].l;i <= b[pos].r;i++)
        if(a[i].m <= u.p && dist(a[0],a[i]) <= u.r && !vis[i]){
            ans++;
            vis[i] = true;//暴力取走的必须标记，否则可能会在移动指针时被重复计算
            q.push(a[i]);
        }
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin >> a[0].x >> a[0].y >> a[0].p >> a[0].r >> n;
    for(int i = 1;i <= n;i++)
        cin >> a[i].x >> a[i].y >> a[i].m >> a[i].p >> a[i].r;
    for(int i = 0;i <= n;i++){
        a[i].r = sq(a[i].r);
        a[i].dis = dist(a[0],a[i]);
    }
    sort(a + 1,a + n + 1,cmp1);//整体满足m单调
    build_block();
    vis[0] = true;
    q.push(a[0]);
    while(!q.empty() && ans < n){
        Data u = q.front();
        q.pop();
        attract(u);
    }
    cout << ans;
    return 0;
}
```

---

## 作者：喵仔牛奶 (赞：6)

感觉是简单的线段树题，为啥之前没有线段树题解？

还有为啥我 $\mathcal{O}(n\log n)$ 空间过不了，要写线性空间……

# Solution

求出每个磁铁的 $d_i$，我们记录当前的磁铁，每次将一个磁铁可以吸引到的之前没有加过的磁铁加进来即可（话说这个算 BFS 吗，没有 breadth-frist 诶）。

问题就变成每次找出所有之前没有找出过的 $d_i\le r,m_i\le p$ 的点。以 $d_i$ 为下标建线段树，在叶子处用 `vector` 维护 $d_i$ 为该位置且当前没有取出过的点，每个节点维护 $mn_i$ 表示子树内 $m_i$ 的最小值。

每次找点时，在线段树上递归，若 $mn_i>p$ 则返回。一个点被删除时需要经过 $\mathcal{O}(\log n)$ 个点，总复杂度为 $\mathcal{O}(n\log n)$。

# Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5;
	struct mag {
		int m, r, p; LL d;
		bool operator < (const mag& x) { return m < x.m; }
	} a[N];
	int n, x0, y0, x, y, rs, tot, t[N], po[N << 2], mn[N << 2];
	vector<int> q, s[N << 2];
	void build(int p, int l, int r) {
		if (l == r) { mn[p] = 1e9; return; }
		int mid = (l + r) >> 1;
		build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
		mn[p] = min(mn[p << 1], mn[p << 1 | 1]);
	}
	void ins(int p, int l, int r, int t, int x) {
		int mid = (l + r) >> 1;
		if (l == r) { s[p].pb(x), mn[p] = a[x].m; return; }
		if (t <= mid) ins(p << 1, l, mid, t, x);
		if (t > mid) ins(p << 1 | 1, mid + 1, r, t, x);
		mn[p] = min(mn[p << 1], mn[p << 1 | 1]);
	}
	void clt(int p, int l, int r, int nl, int nr, int x) {
		if (mn[p] > x) return;
		if (l == r) {
			while (s[p].size() && a[s[p].back()].m <= x)
				q.pb(s[p].back()), s[p].pop_back();
			mn[p] = (s[p].size() ? a[s[p].back()].m : 1e9);
			return;
		}
		int mid = (l + r) >> 1;
		if (nl <= mid) clt(p << 1, l, mid, nl, nr, x);
		if (nr > mid) clt(p << 1 | 1, mid + 1, r, nl, nr, x);
		mn[p] = min(mn[p << 1], mn[p << 1 | 1]);
	}
	LL sqr(int x) { return 1LL * x * x; }
	int main() {
		cin >> x0 >> y0 >> a[0].p >> a[0].r >> n;
		REP(i, 1, n) {
			cin >> x >> y >> a[i].m >> a[i].p >> a[i].r;
			a[i].d = ceil(sqrt(sqr(x - x0) + sqr(y - y0)));
			t[++ tot] = a[i].d, t[++ tot] = a[i].m;
		}
		sort(t + 1, t + 1 + tot), tot = unique(t + 1, t + 1 + tot) - t - 1;
		REP(i, 0, n) {
			a[i].d = lower_bound(t + 1, t + 1 + tot, a[i].d) - t;
			a[i].m = lower_bound(t + 1, t + 1 + tot, a[i].m) - t;
			a[i].r = upper_bound(t + 1, t + 1 + tot, a[i].r) - t - 1;
			a[i].p = upper_bound(t + 1, t + 1 + tot, a[i].p) - t - 1;
		}
		sort(a + 1, a + 1 + n);
		DEP(i, n, 1) ins(1, 1, tot, a[i].d, i);
		q.pb(0);
		while (q.size()) {
			int x = q.back(); q.pop_back();
			rs ++, clt(1, 1, tot, 1, a[x].r, a[x].p);
		}
		cout << rs - 1 << '\n';
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：6)

首先，一眼广搜，不用多讲。

用队列维护广搜，每次用吸引到的磁石去扩展，可以 $O(n^2)$（每次遍历一遍磁石集合）。

第二，整理一下每次扩展我们都需要取那些磁石。

是距离小于等于吸引半径，质量小于等于磁力的磁石。

其中吸引半径与磁力都是定值，尝试用数据结构维护。

平衡树很难维护二维的东西。

CDQ 分治感觉可以。

但是，分块当然是最好选择。

对磁石的距离排序，分块，在每块内部对质量排序。

每次扩展的时候，可以把块分为 3 类。

第一类：最大距离小于等于吸引半径的。

第二类：最大距离大于吸引半径的第一个块。

第三类：其他的块。

首先，第三类的块中，不可能出现合法的磁石（因为距离限制）。

第二类的块中（只有一个），有可能出现合法的磁石，直接暴力 $O(\sqrt{n})$ 判断来取即可。

第一类的块中，只用看质量，看质量只可能是块头的几个被取走。

但是第一类的块还是会增加时间复杂度。

对于第一类的块，我们取走之后就可以改变块端点。

处理所有第一类的块的时间复杂度是 $O(n\sqrt{n})$（每个块一次操作均摊 $O(1)$）。

于是时间复杂度 $O(n\sqrt{n})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,x_0,y_0;
struct node{
	int d,m,p,r;
}a[250010];
queue<int>q;
bool cmp1(node x,node y){
	return x.d<y.d;
} 
bool cmp2(node x,node y){
	return x.m<y.m;
}
int l[1010],r[1010],pos[250010];
int maxd[1010];
bool vis[250010];
signed main() {
	cin>>x_0>>y_0>>a[0].p>>a[0].r>>n;
	a[0].d=0,a[0].r*=a[0].r,a[0].m=2e9;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y>>a[i].m>>a[i].p>>a[i].r;
		a[i].r*=a[i].r;
		a[i].d=(x_0-x)*(x_0-x)+(y_0-y)*(y_0-y);
	}
	sort(a+1,a+n+1,cmp1);
	int t=sqrt(n);
	for(int i=1;i<=t;i++){
		l[i]=(i-1)*t+1;
		r[i]=i*t;
	}
	if(r[t]<n) l[t+1]=r[t]+1,r[++t]=n;
	for(int i=1;i<=t;i++){
		maxd[i]=a[r[i]].d;
		sort(a+l[i],a+r[i]+1,cmp2);
		for(int j=l[i];j<=r[i];j++) pos[j]=i;
	}
	q.push(0);
	int ans=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=1;i<=t;i++){
			if(maxd[i]>a[u].r){
				for(int j=l[i];j<=r[i];j++)
					if(!vis[j] && a[j].d<=a[u].r && a[j].m<=a[u].p)
						q.push(j),vis[j]=1,ans++;
				break;
			}
			else{
				while(l[i]<=r[i] && a[l[i]].m<=a[u].p){
					if(!vis[l[i]]) q.push(l[i]),vis[l[i]]=1,ans++;
					l[i]++;
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Z_AuTwT (赞：4)

## 思路

先从最暴力的方法入手，建立队列，一个一个进行查找，但这样的时间显然是无法通过本题的。

我们可以尝试通过分块的思想来优化暴力，也就是“大局维护，局部朴素”的思想。

我们先以每块磁石的**质量**来进行排序，用**排序后**的序列进行分块，随后对于每一块内按照**离原点的距离**进行排序。注意：这里的距离指的是**直线距离**，要用勾股定理求。

我们同样使用一个**队列**来记录已经被收入的磁石，每次使用队首磁石来吸引剩余磁石。

## CODE

```c++
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,m,p,r;
	double jl;
}Arr[250010],Brr[250010];
bool cmp(node a,node b){
	return a.m<b.m;
}
bool Cmp(node a,node b){
	return a.jl<b.jl;
}
struct node1{
	int p,r;
};
int l[10010],r[10010];
bool flag[250010];
main(){
	int X,Y,P,R,n;
	cin>>X>>Y>>P>>R>>n;
	for(int i=1;i<=n;i++){
		cin>>Arr[i].x>>Arr[i].y>>Arr[i].m>>Arr[i].p>>Arr[i].r;
		Arr[i].jl=sqrt(1.00*(Arr[i].x-X)*(Arr[i].x-X)+1.00*(Arr[i].y-Y)*(Arr[i].y-Y));//勾股求距离
		Brr[i]={Arr[i].x,Arr[i].y,Arr[i].m,Arr[i].p,Arr[i].r,Arr[i].jl};
	}
	sort(Arr+1,Arr+n+1,cmp);//先以质量为基准
	sort(Brr+1,Brr+n+1,cmp);
	int tot=0,L=1,Rr=0,SQRT=sqrt(n);
	for(;L<=n;L=Rr+1){
		tot++;
		Rr=min(tot*SQRT,n);
		l[tot]=L;
		r[tot]=Rr;
		sort(Arr+L,Arr+Rr+1,Cmp);//再以距离为基准
	}
	queue<node1> que;
	que.push({P,R});
	int cnt=0;
	while(!que.empty()){
		auto Now=que.front();//取出队首
		que.pop();
		int ID=1;
		while(ID<=tot){
			if(Brr[r[ID]].m>Now.p) break;
			ID++;
		}
		for(int i=1;i<ID;i++){
			while(l[i]<=r[i]){
				if(flag[l[i]]){
					l[i]++;
					continue;
				}
				if(Arr[l[i]].jl<=Now.r){
					flag[l[i]]=true;
					que.push({Arr[l[i]].p,Arr[l[i]].r});
					cnt++;
					l[i]++;
				}
				else break;
			}
		}
		if(ID>tot) continue;
		for(int i=l[ID];i<=r[ID];i++){
			if(flag[i]) continue;
			if(Arr[i].jl<=Now.r&&Arr[i].m<=Now.p){
				flag[i]=true;
				que.push({Arr[i].p,Arr[i].r});
				cnt++;
			}
		}
	}
	cout<<cnt;
}
```

---

## 作者：鱼跃于渊 (赞：3)

## 题意
有 $N$ 块磁石，每块磁石有一个五元组 $(x,y,m,p,r)$，$x,y$ 表示其坐标，$m$ 是磁石的质量，$p$ 是磁力，$r$ 是吸引半径。  
磁石 $A$ 要吸引磁石 $B$ 需要满足两个条件：
1. $AB$ 的距离小于等于 $A$ 的吸引半径。
2. $B$ 的质量小于等于 $A$ 的磁力。
  
你持有一块磁石，在 $(x_0,y_0)$ 处，并且可以更换手中的磁石。  
问：你最多能获得多少磁石呢？（最初持有的磁石不算）
## 做法
一块分块好题。  
首先如果没有更换磁石这个条件，那这道题就是一个经典的二维偏序问题。  
但有这个条件就麻烦了，本人才疏学浅，想不到什么有效的数据结构。  
让我们想想，既然数据结构似乎行不通，先考虑显然的 bfs 暴力，时间复杂度是 $O(N^2)$ 的。  
那么有什么优化方法吗？有，即优雅的暴力——分块！  
我们首先按距离把所有磁石排个序，然后分块，记录每块内的最大距离，分完后在每个块内都按质量排个序。  
排完序后我们可以发现：通过每块距离单调性和最大距离，我们总可以找到一个位置 $p$，使得 $p$ 之前的所有块都满足条件 $1$，而 $p$ 这块中可能也存在能被吸引的磁石。  
对于前面的所有块，因为我们使得块内元素的质量也是单调的，所以可以通过维护一个指针，指向块内质量最小且未被吸引的磁石。这样每次查询时就可以直接从这里开始往后扫，节省时间。  
对于这个可能存在可被吸引磁石的块，我们直接暴力扫过去就可以了。  
这其实上就是分块“整体维护，块内暴力”思想的体现，时间复杂度也是常见的 $O(n \sqrt n)$。  
**tips**：  
1. 其实先按距离排序和先按质量排序都是可以的，没有什么显著影响。
2. 注意这题的距离指的是欧几里得距离，要用勾股定理来求。
3. 注意要标记一下每块磁石是否入队。对于有些写法，不这样做会导致答案统计错误。  
  
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=250005;
struct stone{
	int dis,m,p,r;
}st[N];
bool cmp1(const stone &x,const stone &y){
	return x.dis<y.dis;
}
bool cmp2(const stone &x,const stone &y){
	return x.m<y.m;
}
int sx,sy,p,r,n,ans;
int k,tot,L[N],R[N],belong[N],MX[N];
bool vis[N];
queue <stone> q;
void build(){
	k=sqrt(n);tot=(n-1)/k+1;
	for(int i=1;i<=n;i++)
		belong[i]=(i-1)/k+1;
	for(int i=1;i<=tot;i++){
		L[i]=(i-1)*k+1;
		R[i]=i*k;
	}
	R[tot]=n;
	for(int i=1;i<=tot;i++){
		MX[i]=st[R[i]].dis;
		sort(st+L[i],st+R[i]+1,cmp2);
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>sx>>sy>>p>>r>>n;
	for(int i=1,x,y,m,p,r;i<=n;i++){
		cin>>x>>y>>m>>p>>r;
		st[i]={ceil(sqrt(1.0*(sx-x)*(sx-x)+1.0*(sy-y)*(sy-y))),m,p,r};
	}
	sort(st+1,st+n+1,cmp1);
	build();
	q.push({0,0,p,r});
	while(!q.empty()){
		stone x=q.front();q.pop();
		for(int i=1;i<=tot;i++){
			if(MX[i]<=x.r){
				while(L[i]<=R[i]&&st[L[i]].m<=x.p){
					if(!vis[L[i]]){
						q.push(st[L[i]]);
						ans++;
						vis[L[i]]=1;
					}
					L[i]++;
				}
			}else{
				for(int j=L[i];j<=R[i];j++){
					if(!vis[j]&&st[j].dis<=x.r&&st[j].m<=x.p){
						q.push(st[j]);ans++;vis[j]=1;
					}
				}
				break;
			}
		}
	}
	cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：w9095 (赞：2)

[P10590 磁力块](https://www.luogu.com.cn/problem/P10590)

有一个很显然的 BFS，对于每一个吸到的新磁力块，遍历序列，把所有它能吸到的磁力块加入一个队列进行扩展。这样时间复杂度是 $O(n^2)$，不能通过。

考虑影响是否能吸到的两个因素，一个是利用 $x,y$ 计算出的距离，另一个是质量 $m$。对于这种问题，经典的做法是排序维护第一个变量，数据结构维护第二个变量。

由于本题需要取出可以吸到的磁力块入队，故 $\log$ 数据结构在本题中不好用。我们考虑分块。把所有磁力块按照距离升序排序，每 $\sqrt{n}$ 个元素分成一块。块内按照 $m$ 升序排序，并记录距离的最大值。

当我们扩展一个磁力块时，从小到大遍历序列中的每一块。

对于一个最大距离小于等于吸引半径的块，所有磁力块均处于吸引半径之内。可以对于每一块记录一个 $la$，表示块中已经前 $la-1$ 个磁力块已经被吸引。我们只需要利用 $la$，遍历到第 $x$ 个元素，使这个元素的 $m$ 大于当前吸力即可。由于 $m$ 升序排序，所以这一块中所有可以被吸走的磁力块要么在之前被吸走，要么在这一次被吸走，满足条件。之后，令 $la=x$。

对于第一个最大距离大于吸引半径的块，根据遍历顺序以及距离升序排序，之后的块中所有元素距离必然大于吸引半径，可以处理完这一块之后退出循环。这一块之中有的磁力块可以被吸走，有的磁力块不可以被吸走。我们暴力求出每一个能够吸走的磁力块，标记已经被吸走，之后排序重构。均衡复杂度之后为 $O(n\sqrt{n\log n})$，[可以通过](https://www.luogu.com.cn/record/162857173)。

事实上，可以继续优化。在处理第一个最大距离大于吸引半径的块时，我们不进行排序重构。改为在处理最大距离小于等于吸引半径的块时，如果遇到一个被吸走的磁力块，直接跳过到下一个。由于 $m$ 升序排序，依旧满足要求。时间复杂度 $O(n\sqrt{n})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct val
{
	long long m,p,r;
	double d;
}a[300000];
long long xq,yq,x,y,p,r,n,k,qp[300000],qr[300000],h=1,t=0,id[300000],la[300000],lc[300000],rc[300000],ans=-1;
double mx[300000];
bool cmp1(struct val a,struct val b)
{
	return a.d<b.d;
}

bool cmp2(struct val a,struct val b)
{
	return a.m<b.m;
}

double dist(long long x1,long long y1,long long x2,long long y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

void expand(long long p,long long r)
{
	for(int i=1;i<=(n+k-1)/k;i++)
	    if(mx[i]<=r)
	       while(a[la[i]].m<=p&&la[i]<=rc[i])
               {
               if(a[la[i]].m!=-1e10)qp[++t]=a[la[i]].p,qr[t]=a[la[i]].r,a[la[i]].m=-1e10;
               la[i]++;
               }
	    else
	       {
	       	la[i]=lc[i];
	       	for(int j=lc[i];j<=rc[i];j++)
	       	    if(a[j].m!=-1e10&&a[j].m<=p&&a[j].d<=r)qp[++t]=a[j].p,qr[t]=a[j].r,a[j].m=-1e10;
	       	break;
		   }
}

int main()
{
	scanf("%lld%lld%lld%lld%lld",&xq,&yq,&p,&r,&n);
	qp[++t]=p,qr[t]=r,k=sqrt(n);
	for(int i=1;i<=n;i++)
	    {
	    	scanf("%lld%lld%lld%lld%lld",&x,&y,&a[i].m,&a[i].p,&a[i].r);
	    	a[i].d=dist(xq,yq,x,y);
		}
	sort(a+1,a+n+1,cmp1);
	for(int i=1;i<=(n+k-1)/k;i++)lc[i]=1e10;
	for(long long i=1;i<=n;i++)id[i]=(i-1)/k+1,lc[id[i]]=min(lc[id[i]],i),rc[id[i]]=max(rc[id[i]],i),mx[id[i]]=max(mx[id[i]],a[i].d);
	for(int i=1;i<=(n+k-1)/k;i++)la[i]=lc[i],sort(a+lc[i],a+rc[i]+1,cmp2);
	while(h<=t)ans++,expand(qp[h],qr[h]),h++;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：1)

分块题目。

# 题意简述

>散落着 $N$ 块磁石。每个磁石的性质可以用一个五元组 $(x,y,m,p,r)$ 描述，其中 $x,y$ 表示其坐标，$m$ 是磁石的质量，$p$ 是磁力，$r$ 是吸引半径。
>
>若磁石 $A$ 与磁石 $B$ 的距离不大于磁石 $A$ 的吸引半径，并且磁石 $B$ 的质量不大于磁石 $A$ 的磁力，那么 $A$ 可以吸引 $B$。
>
>你现在手上持有一块磁石，问你一共可以吸引多少块磁石。
>
>$N\le 2.5\times 10^5$。


# 思路分析

下文中“距离”均指磁石 $i$ 的坐标 $(x_i,y_i)$ 到 $(x_0,y_0)$ 的距离。

一个暴力做法是进行 BFS。找出队头元素后枚举其他**未入队**的元素，判断能否入队。这样不断枚举直到队列为空。

但这样做法是 $O(n^2)$ 的，瓶颈在于枚举未入队的元素，我们要优化这个过程。这里提供一种分块做法。

先按照**距离**进行排序，然后分块，再在块内按照**质量**排序，同时记录每个块内的最大距离。

查询时，找到第一个最大距离大于当前吸引半径的块。记这个块为 $k$，显然对于任何 $1\sim k-1$ 块中的元素，其距离均小于当前吸引半径。这是因为我们先按照距离排序后再分块，块的最大距离也是有顺序的。

- 对于 $1\sim k-1$ 块，因为块内按照质量排过序。所以我们找到第一个质量大于当前磁力的元素下标 $t$，将其之前的元素都加入队列，并将第 $i$ 块的左边界设置为 $t$。

- 对于第 $k$ 块，虽然最大距离大于当前吸引半径，不过不代表块内所有的距离均大于当前吸引半径。我们朴素枚举块内的元素，遇到符合条件的将其入队。

注意：为了避免重复加入同一元素，我们在将元素入队的同时将其打上标记。

时间复杂度为 $O(n\sqrt n)$。

# Code

```cpp
//应为直线距离可能涉及精度问题，所以本代码中的所有距离均用其平方表示。因此要开 long long

#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long ll;
const int N=2.5e5+10,M=502;
ll X,Y,n,rr,P,L[M],R[M],cnt=0,mk[N],maxn[M]; 
struct node{
	ll p,r,m,dis,idx;
}a[N];
queue<node>q;
ll Dis(ll x,ll y){
	return (x-X)*(x-X)+(y-Y)*(y-Y);
} 
bool cmpdis(node a,node b){
	return a.dis<b.dis;
}
bool cmpm(node a,node b){
	return a.m<b.m;
}
int main(){
	scanf("%lld %lld %lld %lld %lld",&X,&Y,&P,&rr,&n);
	q.push(node{P,rr*rr,0,0,0});
	ll x,y,m,p,r;
	for(int i=1;i<=n;i++){
		scanf("%lld %lld %lld %lld %lld",&x,&y,&m,&p,&r);
		a[i]=node{p,r*r,m,Dis(x,y),i};
	} 
	
	int t=sqrt(n);
	for(int i=1;i<=t;i++)L[i]=R[i-1]+1,R[i]=i*t;
	if(R[t]!=n)L[++t]=R[t-1]+1,R[t]=n;
	sort(a+1,a+1+n,cmpdis);
	for(int i=1;i<=t;i++)maxn[i]=a[R[i]].dis,sort(a+L[i],a+R[i]+1,cmpm);
	while(q.size()){
		int p=0;node now=q.front();q.pop(),cnt++;
		for(p=1;p<=t;p++){
			if(L[p]>R[p])continue;
			if(maxn[p]>now.r)break;
			for(int i=L[p];i<=R[p];i++){
				if(a[i].m<=now.p){
					if(!mk[i])q.push(a[i]),mk[i]=1;//注意这里
					L[p]++;
					
				}
				else break;
			}
		}
		if(p>t)continue;//注意这里
		for(int i=L[p];i<=R[p];i++){
			if(mk[i])continue;
			if(a[i].m>now.p)break;
			if(a[i].dis<=now.r)q.push(a[i]),mk[i]=1;
		}
	}
	printf("%lld",cnt-1);
	return 0;
} 
```

---

## 作者：Kingna (赞：0)

首先我们要确定的是人的位置不变。

题目要求：质量 $\leq$ 磁力，距离 $\leq$ 吸引半径。

那么我们直接按照质量排序，可以吸走的磁铁是一个前缀（仅仅看质量）。但是距离就不一定了。于是考虑分块。

先看整体，按照质量排序。对于块内的磁铁，按照距离排序。这样来说：前 $i$ 个块的最大质量一定大于等于前 $i-1$ 个块的最大质量。即质量满足单调性，直接找到一个最靠右块 $j$，使得此块的最大质量小于等于拿的磁铁的磁力。

同时满足：

* 前 $j$ 段的所有磁石重量不大于拿的磁铁的磁力。
* 第 $j+1$ 段，有一些磁铁满足条件，暴力扫描。
* $j+1$ 段往后，没有磁石满足条件。

则前 $j$ 个块，我们都可以朴素扫描，把能吸引的磁石加入队尾，知道第一个不能被吸引的磁石（位置记为 $P$），然后，把该段的开头移动到 $P$，就保证不会重复扫描，均摊复杂度 $O(1)$。

对于第 $j+1$ 个块，我们暴力扫描此块，复杂度 $O(\sqrt n)$。

套一个 bfs 即可完成此过程。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long
const int N = 3e5 + 5, sq = 500 + 5;

int n, hd, tl, lx[N], rx[N], tot, vis[N], del[N], res, maxn[N];

struct edge {
	int x, y, m, p, r;	
}ed[N];

edge q[N];

int dis(int x, int y) {
	return (x - q[0].x) * (x - q[0].x) + (y - q[0].y) * (y - q[0].y);
}

signed main() {
	cin >> q[0].x >> q[0].y >> q[0].p >> q[0].r >> n;
	_for(i, 1, n) cin >> ed[i].x >> ed[i].y >> ed[i].m >> ed[i].p >> ed[i].r;
	sort(ed + 1, ed + n + 1, [](edge x, edge y) { return x.m < y.m; });
	_for(i, 1, n / sq) lx[i] = (i - 1) * sq + 1, rx[i] = i * sq, tot++;
	if (n % sq) tot++, lx[tot] = rx[tot - 1] + 1, rx[tot] = n;
	_for(i, 1, tot) _for(j, lx[i], rx[i]) maxn[i] = max(maxn[i], ed[j].m);
	_for(i, 1, tot) sort(ed + lx[i], ed + rx[i] + 1, [](edge x, edge y) {return dis(x.x, x.y) < dis(y.x, y.y);});
	while (hd <= tl) {
		auto u = q[hd]; hd++;
		int id = 0;
		_for(i, 1, tot) if (maxn[i] <= u.p) id = i;
		_for(i, 1, id) {
			int cnt = 0;
			_for(j, lx[i] + del[i], rx[i]) {
				if (dis(ed[j].x, ed[j].y) <= u.r * u.r) {
					if (!vis[j]) {
						vis[j] = 1;
						q[++tl] = ed[j];
						cnt++; res++;
					}
				}
				else break;
			}
			del[i] += cnt;
		}
		if (id + 1 <= tot) {
			_for(j, lx[id + 1], rx[id + 1]) {
				if (!vis[j] && dis(ed[j].x, ed[j].y) <= u.r * u.r && ed[j].m <= u.p) {
					vis[j] = 1;
					q[++tl] = ed[j]; res++;
				}
			}
		}
	}
	cout << res << endl;
}
```

---

## 作者：forever_nope (赞：0)

题目：[P10590 磁力块](https://www.luogu.com.cn/problem/P10590)，[CF198E Gripping Story](https://www.luogu.com.cn/problem/CF198E)。

贪心的考虑，我们希望对于已有的每一个磁石都吸引一遍。

那么直接类似 BFS 的做，复杂度是 $\mathcal O(n^2)$ 的。

考虑 BFS + 分块。

我们记 $d_i$ 表示第 $i$ 个磁石到 $(x_0,y_0)$ 的距离。

先将所有的点按照到 $d_i$ 升序排序，按照 $\sqrt n$ 大小分块。

块内再开一个数组，将所有的点按照质量升序排序。

分别考虑每一个磁石 $R,P$，将没有被吸引过的磁石的块分为以下三类：

1. 这一块的 $d_i$ 全都 $\le R$。

2. 这一块的 $d_i$ 全都 $>R$。

3. 这一块的 $d_i$ 包括了 $\le,> R$ 的。

考虑如何处理：

+ 对于第一类，我们直接暴力从头遍历直到 $m_i>P$。

+ 对于第二类，我们不管。

+ 对于第三类，我们暴力的遍历，可以吸引的加入并标记为删除。

考虑复杂度：

+ 对于第一类，每个点最多被遍历一次（然后就入队了），因此是 $\mathcal O(n)$ 的。

+ 对于第三类，每次最多处理 $1$ 个这样的块，每次复杂度是 $\mathcal O(\sqrt n)$ 的。

因此，时间复杂度为 $\mathcal O(n\sqrt n)$。

实现细节：

+ 我们并不需要实际删除节点，可以打标记表示删除。

+ 代码：

```cpp
#ifndef M_DEBUG
#define NDEBUG 1
#define FAST_IO 1
#define D(x) ({ void(0); })
#else
#define D(x) ({ auto t = (x); cerr << "| DEBUG #" << __LINE__ << " IN " << __FUNCTION__ << "() \t| \t" << #x << " = \t[" << t << "]\n"; void(0); })
#endif

#include <bits/stdc++.h>

#ifdef FAST_IO
#define endl "\n"
#endif

using namespace std;

// -----------------------------------------------------------------------------

using ll = long long;

constexpr int N = 3e5 + 10;

namespace solev {
    int n;
    int p0, r0;
    int x0, y0;

    struct query {
        int p;
        ll r2;
        query() = default;
        query(int p, int r): p(p), r2(1ll * r * r) {}
    };

    // -------------------------------------------------------------------------

    struct magic {
        int m, p, r;
        ll dis2;
        magic() = default;
        magic(int x, int y, int m, int p, int r): m(m), p(p), r(r), dis2(1ll * (x - x0) * (x - x0) + 1ll * (y - y0) * (y - y0)) {}
    } a[N];

    bool cmp_d(const magic &a, const magic &b) {
        return a.dis2 < b.dis2;
    }

    bool cmp_m(const magic &a, const magic &b) {
        return a.m < b.m;
    }

    int block, cnt;
    int belong[N];
    int L[N], R[N];
    ll mind[N], maxd[N];

    int beg[N];

    void init() {
        sort(a + 1, a + n + 1, cmp_d);
        block = sqrt(n);
        for (int i = 1; i <= n; ++i)
            belong[i] = (i - 1) / block + 1;
        cnt = (n - 1) / block + 1;
        for (int i = 1; i <= cnt; ++i) {
            L[i] = (i - 1) * block + 1;
            R[i] = min(L[i] + block - 1, n);
            beg[i] = L[i];
            mind[i] = a[L[i]].dis2;
            maxd[i] = a[R[i]].dis2;
            sort(a + L[i], a + R[i] + 1, cmp_m);
        }
        R[cnt] = n;
    }

    queue<query> q;

    bool del[N];

    void m_push(const query &u) {
        int p = u.p;
        ll r2 = u.r2;
        for (int j = 1; j <= cnt; ++j) {
            if (mind[j] > r2)
                break;
            if (maxd[j] <= r2) {
                for (int i = beg[j]; i <= R[j]; ++i) {
                    if (del[i]) continue;
                    if (a[i].m > p) break;
                    q.emplace(a[i].p, a[i].r);
                    beg[j] = i + 1;
                }
            }
            else {
                for (int i = beg[j]; i <= R[j]; ++i) {
                    if (del[i]) continue;
                    if (a[i].m > p) continue;
                    if (a[i].dis2 > r2) continue;
                    q.emplace(a[i].p, a[i].r);
                    del[i] = true;
                }
            }
        }
    }

    // -------------------------------------------------------------------------

    int Main() {
        cin >> x0 >> y0 >> p0 >> r0 >> n;
        for (int i = 1; i <= n; ++i) {
            int x, y, m, p, r;
            cin >> x >> y >> m >> p >> r;
            a[i] = magic(x, y, m, p, r);
        }
        init();
        q.emplace(p0, r0);
        int ans = 0;
        while (!q.empty()) {
            auto u = q.front();
            q.pop();
            m_push(u);
            ++ans;
        }
        return ans - 1;
    }
}

// -----------------------------------------------------------------------------

signed main() {
    #ifdef FAST_IO
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    #endif
    cout << solev::Main() << endl;
    return 0;
}
```

END.

---

## 作者：Augensterm (赞：0)

# 洛谷 P10590
## 分块+BFS
看到这道题，首先想到纯 BFS，一看数据直接 ~~T 到姥姥家~~。   



### 解题思路
这道题目的数据范围又大，区间操作很明显，而且似乎线段树和树状数组又不好处理这道题目，所以我们只好运用大块维护，小块枚举的分块思想了。

首先我们得到的条件是：质量 $\le$ 磁力，距离 $\le$ 吸引半径。

既然如此的话，我们不妨先把这 $n$ 块磁铁石按照质量排序，分成 $\sqrt{n}$ 段，然后在每一段的内部，再按照距离排序。

我们可以开一个队列，这个队列刚开始只有赠送磁石，那么每次我们就可以取出队头，然后将队头可以吸引的磁石统统存储入队列之中即可。然后因为每一段内部已经按照距离排好序了。

设队头磁铁石为 $H$，那么必然存在一个 $K$，满足以下这些性质：


---


1. 第 $1 \sim K-1$ 段中所有的磁石质量都不大于 $H$ 的磁力。
2. 第 $K+1$ 段之后的磁铁石质量都不大于 $H$ 的磁力。


---



所以来说 $1 \sim K-1$ 段中与 $(x _ {0} ^ {}$,$y _ {0} ^ {})$ 距离小于 $H$ 的必定是处于每段的开头。

每段设一个上次因距离原因截止的标记 $P _ {i} ^ {}$，那么我们从左往右数，发现如果无法吸引过来了，那么下一次我们直接把这段的开头位置移到这个无法吸引的位置 $P _ {i} ^ {}$。  

其实这里排序的时候先排距离还是先排重量都可以，先排距离的话，每段按重量排序这样这里的 $P _ {i} ^ {}$ 就表示第一个不满足重量的位置。

下面的代码就是先总的按距离排序，内部再按重量排序的。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5;
typedef long long LL;

struct Node
{
	LL d,r;//距离和吸引半径 
	LL m,p;//重量和磁力 
}a[N];
LL D[N],x_0,y_0,L[N],R[N],n,tot,l,r,p,x,y;
bool v[N];//标记数组防止重复入队 
queue<LL>q;
bool cmp_d(Node a,Node b)//距离排序 
{
	return a.d<b.d;
}
bool cmp_m(Node a,Node b)//重量排序 
{
	return a.m<b.m;
}
int bfs()
{
	int ans=0;
	q.push(0);
	while(q.size())
	{
		auto T=q.front();q.pop();
		auto now=a[T].r,p=a[T].p;//now为磁石控制的有效距离，p为磁石能吸动的重量
		for(LL i=1;i<=tot;i++)
		{
			if(D[i]>now)//不是全都满足距离<当前的now的段就要根据距离筛选
			{
				for(LL j=L[i];j<=R[i];j++)
				{
					if(!v[j]&&a[j].d <=now&&a[j].m<=p)//满足的 
					{
						ans++;q.push(j);v[j]=true;
					}
				}
				break;;//这一段的最大距离已经大于now,那么后面所有段的距离都大于now跳出循环
			}
			while(L[i]<=R[i]&&a[L[i]].m <=p)//扫描连续的一段直到重量不满足
			{
				if(!v[L[i]])
				{
					q.push(L[i]);ans++;
				}
				++L[i];//最后把该段的已经入队元素放弃，把左指针移到第一个不能入队的位置
			}
		}
	}
	return ans;
}
int main()
{
	scanf("%lld%lld%lld%lld%lld",&x_0,&y_0,&a[0].p,&a[0].r ,&n);
	a[0].r*=a[0].r;//比较时直接拿平方比较，避免失真 
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld%lld%lld",&x,&y,&a[i].m,&a[i].p ,&a[i].r );
		a[i].r*=a[i].r ;
		a[i].d =(x-x_0)*(x-x_0)+(y-y_0)*(y-y_0);
	}
	sort(a+1,a+n+1,cmp_d);
	int w=sqrt(n);
	for(LL i=1;i<=n;i+=w)
	{
		L[++tot]=i;//段的左边界 
		if(n<i+w-1)
			R[tot]=n;
		else
			R[tot]=i+w-1;
		//R[tot]=min(n,i+w-1);原谅我c++版本太低 
		D[tot]=a[R[tot]].d ;
		sort(a+L[tot],a+R[tot]+1,cmp_m);//段内按重量排序 
	}
	printf("%d\n",bfs());
	return 0;
}

```
2024-08-07 16:57 一稿被打回，已删除逗号后多余空格。

---


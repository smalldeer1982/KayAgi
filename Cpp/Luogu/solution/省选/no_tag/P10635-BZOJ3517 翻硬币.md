# BZOJ3517 翻硬币

## 题目描述

有一个 $n$ 行 $n$ 列的棋盘，每个格子上都有一个硬币，且 $n$ 为偶数。每个硬币要么是正面朝上，要么是反面朝上。每次操作你可以选定一个格子 $(x,y)$，然后将第 $x$ 行和第 $y$ 列的所有硬币都翻面。求将所有硬币都变成同一个面最少需要的操作数。

## 说明/提示

**【样例解释】**

对 $(2,3)$ 和 $(3,1)$ 进行操作，最后全变成 $1$。

**【数据范围】**

对于所有数据，$1\leq n \leq 1000$。

## 样例 #1

### 输入

```
4
0101
1000
0010
0101```

### 输出

```
2```

# 题解

## 作者：s4CRIF1CbUbbL3AtIAly (赞：12)

写在前面：我不太会写题解，写出来的东西都是一坨一坨的，但是已经尽量清晰的描述了，请谅解。

考虑如何使用一些操作来只翻转一位。

当我们轮流对 $(x_0,i)$ 和 $(i,y_0)$ 进行操作之后（$(x_0,y_0)$ 只操作一次）：

1. 对于 $x\neq x_0$ 且 $y\neq y_0$ 的 $(x,y)$，它仅会被 $(x,y_0)$ 和 $(x_0,y)$ 操作到，操作两次相当于没变；
2. 对于 $x=x_0$ 和 $y=y_0$ 只有一个满足的 $(x,y)$，它会被所有 $(x_0,i)$ 或所有 $(i,y_0)$ 操作到，而 $n$ 为偶数，所以也不变；
3. 对于 $x=x_0$ 且 $y=y_0$ 的 $(x,y)$，它会被每一次操作影响到，总共 $2n-1$ 次，为奇数，所以会变化。

所以，我们发现这样操作之后，我们能够仅翻转 $(x_0,y_0)$。

显然的，我们能够通过多次进行这样的轮流操作来翻转任意格子。如果某一个格子操作了两次则相当于没有操作，这样我们可以把每个格子上进行的操作次数限制成 $0$ 或 $1$。

于是，操作后的翻转情况（格子的被操作情况）有 $2^{n^2}$ 种，每个格子的操作情况也有 $2^{n^2}$ 种，而且每个翻转情况都有对应的操作情况，而操作情况能唯一对应翻转情况。这些足以说明每一个翻转情况对应的操作情况也是唯一的。因此，这个操作方式去掉无用操作后一定是最优解。

首先考虑怎么把 $1$ 全改成 $0$。我们给每行和每列打一个标记代表要对其整行或整列操作的次数，对于每个 $1$ 的位置 $(x,y)$，我们让第 $x$ 行和第 $y$ 列的标记加一。之后我们枚举每一个位置，其需要操作的次数是其自身是否需要操作（即自身是否为 $1$）加上所在行与所在列的次数之和。如果这个和是奇数就需要操作它。

而从 $0$ 全改成 $1$ 的方法就很简单：因为 $n$ 是偶数，所以每行或每列中 $0$ 和 $1$ 的数量奇偶性相同，也就是说行标记和列标记对这两种方案的影响是一样的。而因为从 $0$ 改成 $1$ 的数量与 $1$ 改成 $0$ 的数量和为 $n^2$，所以同时影响这两种方案之后（因为对于一个方格，两种方案同时翻转之后的操作次数之和还是 $1$）和不变，仍然为 $n^2$。因此，$n^2$ 减去 $1$ 全改成 $0$ 的次数就是 $0$ 全改成 $1$ 的次数。

实现很简单。

```cpp
cin>>n;
for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){
	cin>>ch[i][j];
	if(ch[i][j]=='1')++r[i],++c[j];
}
for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){
	ans+=(ch[i][j]+r[i]+c[j])&1;
}
cout<<min(ans,n*n-ans)<<"\n";
```

---

## 作者：wangbinfeng (赞：10)

[![](https://img.shields.io/badge/题目-P10635_BZOJ3517_翻硬币-green)
![](https://img.shields.io/badge/难度-提高+/省选−-blue)
![](https://img.shields.io/badge/考点-构造（位运算）-red)
![](https://img.shields.io/badge/题型-传统题-yellow)](https://www.luogu.com.cn/problem/P10635)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

---
- 原题数据过水，建议通过本题后可以用[我出的加强版](https://www.luogu.com.cn/problem/U475696)测试代码强度。具体的，将 $n$ 的范围扩大到了 $1\times 10^4$。

## 理解 1（数学做法）：
感觉目前已有题解写的都难以看懂，所以写一篇自认为比较好理解的，同时与目前题解的做法均不大相同。
> 下文中，$A_{i,j}$ 表示在 $(i,j)$ 处原本的状态，$C_{i,j}$ 表示是否在 $(i,j)$ 处执行整行整列的修改，$A_{i,j}\in\{0,1\},C_{i,j}\in\{0,1\}$。

考虑到一个位置如果被翻转两次那么结果会不变，很容易想到异或。更进一步思考：如果想将 $(x,y)$ 翻转为 $0$，那么 $\displaystyle A_{x,y}\oplus\left(\bigoplus_{i=1}^nC_{i,y}\right)\oplus\left(\bigoplus_{i=1}^{n}C_{x,i}\right)\oplus C_{x,y}=0$。两边同时异或 $A_{x,y}$ 得 $\displaystyle A_{x,y}=\left(\bigoplus_{i=1}^nC_{i,y}\right)\oplus\left(\bigoplus_{i=1}^{n}C_{x,i}\right)\oplus C_{x,y}$。

那么又可以得出：
$$
\begin{aligned}
& \displaystyle\left(\bigoplus_{i=1}^nA_{i,y}\right)\oplus\left(\bigoplus_{i=1}^{n}A_{x,i}\right)\oplus A_{x,y}\\
=& \bigoplus_{i=1}^n\left[\left(\bigoplus_{j=1}^nC_{j,y}\right)\oplus\left(\bigoplus_{j=1}^{n}C_{i,j}\right)\oplus C_{i,y}\right]
\oplus
\bigoplus_{i=1}^{n}\left[\left(\bigoplus_{j=1}^nC_{j,i}\right)\oplus\left(\bigoplus_{j=1}^{n}C_{x,j}\right)\oplus C_{x,i}\right]
\oplus
\left[\left(\bigoplus_{i=1}^nC_{i,y}\right)\oplus\left(\bigoplus_{i=1}^{n}C_{x,i}\right)\oplus C_{x,y}\right]\\
=& \bigoplus_{i=1}^n\left[\left(\bigoplus_{j=1}^nC_{j,y}\right)\oplus\left(\bigoplus_{j=1}^{n}C_{i,j}\right)\right]
\oplus
\bigoplus_{i=1}^{n}\left[\left(\bigoplus_{j=1}^nC_{j,i}\right)\oplus\left(\bigoplus_{j=1}^{n}C_{x,j}\right)\right]
\oplus C_{x,y}\\
=&C_{x,y},n\equiv 0(\bmod 2)
\end{aligned}
$$
也就是说，我们可以通过输入的 $A$ 数组推导出 $C$ 数组。如果知道了 $C$ 数组，也就是知道了每个位置是否需要执行行列修改操作。

那么如果要将所有的数均变为 $1$，那么只需要在统计时再异或 $1$ 即可。又考虑到异或的性质，均变为 $0$ 和均变为 $1$ 的答案之和恰好为统计 $1$ 时异或 $1$ 的个数（即 $n^2$）。在输出时用均变为 $0$ 的答案 $n^2$ 减去均变为 $0$ 的答案的最小值即可。

如果直接这么做时间复杂度为 $\Theta(n^4)$，但是考虑到 $\displaystyle\bigoplus_{i=1}^nA_{i,y}$ 和 $\displaystyle\bigoplus_{i=1}^{n}A_{x,i}$ 是可以用异或前缀和预处理出来的，那么时间复杂度就可以优化到 $\Theta(n^2)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1000 + 9;
int n, ans, a[maxn][maxn], line[maxn], column[maxn];
string s;
signed main()
{
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> s;
		for (int j = 1; j <= n; j++)
			a[i][j] = s[j - 1] - '0', line[i] ^= a[i][j], column[j] ^= a[i][j];
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			ans += line[i] ^ column[j] ^ a[i][j];
	cout << min(ans, n * n - ans);
}
```

## 理解 2：

考虑到对于每一个点，想当且仅当修改这一个点 $P$ 而不修改其它点，可以将它的横行数列的十字共计 $2n-1$ 个点全部修改（因为 $n$ 是偶数，所以其他所有点一定只会被修改偶数次，**当然这也可以用来简便理解计算出上面做法的那个大算式**）。
> 具体地讲：对于整个矩阵的点 $Q$ 分为如下三种情况：
> 1. 不在十字上：那么这个点一定会他水平方向和竖直方向的点修改两次，它的值并不会发生变化。
> 2. 在十字上但不是 $P$ 点：那么一定会被同一行或同一列的所有点修改 $n$ 次，由于 $n$ 是偶数，所以它的值也不会发生变化。
> 3. $P$ 点：被它同一行和同一列共计 $2n-1$ 个点修改，$2n-1$ 一定是奇数，所以可以成功取反。

如果两个点都要修改，这两个点一定会造成最少两个交点，那么这些交点显然不需要修改（即异或两次）。用一个数组统计每个点是否修改即可。

用 $\Theta(n^2)$ 枚举每个点，如果需要修改掉，再用 $\Theta(n)$ 修改所有要修改的点。共计时间复杂度为 $\Theta(n^3)$，但是因为位运算的较低常数复杂度，可以稳定通过本题（经多次测试，最慢的点也不会超过 400ms）。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1000 + 9;
int n, ans, a[maxn][maxn], f[maxn][maxn];
string s;
signed main()
{
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> s;
		for (int j = 1; j <= n; j++)
			a[i][j] = s[j - 1] - '0';
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (a[i][j])
			{
				for (int k = 1; k <= n; k++)
					f[i][k] ^= 1, f[k][j] ^= 1;
				f[i][j] ^= 1;
			}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			ans += f[i][j];
	cout << min(ans, n * n - ans);
}
```
但是还是可以考虑优化，注意到这个算法的复杂度瓶颈在于枚举 `f` 数组需要修改的位置，那么能否省略掉这个循环呢？答案是可以的，因为对于任意的 $(x,y)$，只有这一行和这一列的所有 $1$ 会对答案产生影响。且因为异或的性质，我们可以通过 $1$ 的个数直接快速地算出每一个 $f_{x,y}$ 的变量值，这就可以将时间复杂度优化为 $\Theta(n^2)$。

代码暂时省略，交给读者自行完成。

---

公式又多又长，写了好久，我要亖了，如果有错烦请请评论区交流。

- 鸣谢：
1. ~~[@wangbinfeng](https://www.luogu.com.cn/user/387009) 耗时 3h 完成本题解的创作。~~
2. [@NATO_Fan_Club](https://www.luogu.com.cn/user/1436306) 首先质疑本题已有题解并启发本人想到第二种理解，具体见[这个帖子](https://www.luogu.com.cn/discuss/918647)。
3. [@a1co0av5ce5az1cz0ap_](https://www.luogu.com.cn/user/320423) 的[题解](https://www.luogu.com.cn/article/rq2inge3)，让本人借鉴了部分的证明（即修改十字的准确证明，本人之前写法过于主观难以理解）。
4. ~~[难以理解的现有题解（所有在本题解完成前的 luogu 题解）](https://www.luogu.com.cn/problem/solution/P10635)激励本人完成本题解的创作。~~

---

## 作者：WZWZWZWY (赞：9)

感觉其他题解都没说清原理，我这种蒟蒻怎么知道这代码的具体含义呢！（~~也可能是我太菜了~~）于是想了想，有了这篇题解。

找规律题。

### 简洁题解：

将一个点同一行同一列的每个点都点一次（包括它自己），可以只改变它的值。一个点最多只需要点一次，因为偶数次就等于点 $0$ 次，奇数次就等于点 $1$ 次。那么就可以求出每个点最少需要点多少次。累加起来就得到答案。

### 详细题解：

在同一个位置最多点一次，因为点两次就变回去了，点三次和点一次效果一样。所以**每个点最多只需要都点一次**。

点击同一行或同一列的点（包括它自己）会改变它的值。奇数次的值是它取反，偶数次就变回去。

因为它这行和这列的总点数 $2n-1$ 是奇数，**将这些点都点一次**，会发现：**除去它自己的其他点值都不变，而它自己的值取反**。

原因：因为 $2n-1$ 是奇数，所以它这个位置取反；因为同一行或同一列的其他数都被改变了 $n$ 次（$n$ 为偶数），所以它们不变；因为剩下的数值都被改变了 $2$ 次，所以值也不变。

然后大多数人得到一个朴素的想法：每个点都用上面的方法做一次，使该位置取反，最后可以得到一张全是 $0$ 或 $1$ 的图。

但是别忘了我们一开始就得到的性质：一个点最多点一次。而这么做可能会使一个点被点多次。

那么怎么办呢？

拿一个这样的图：

```
4
0000
0000
1001
0000
```
如果按照上面的做法，需要操作那两个 $1$。

每个点被点击的次数如下（图 $1$）：

```
1001
1001
2222
1001
```

然后一个位置点偶数次和点 $0$ 次是一样的，点奇数次和点 $1$ 次是一样的。

那么和下面的点击是一个效果（图 $2$）：

```
1001
1001
0000
1001
```

那么我们统计每行需要点几次，每列需要点几次，就可以得到这个位置需要点几次，再根据奇偶性判断点一次还是不点。当然，可以仅记录每行每列的奇偶性。

那么如果求将一个图全都点成 $0$ 的最少步数，可以得到这个代码：

```cpp
cin >> n;
for (int i = 1; i <= n; i++)
  for (int j = 1; j <= n; j++) {
    cin >> c[i][j];
    if (c[i][j] == '1') h[i] ^= 1, l[j] ^= 1; // 行和列的奇偶性取反
  }
for (int i = 1; i <= n; i++)
  for (int j = 1; j <= n; j++) 
    res += ((c[i][j] == '1') ^ h[i] ^ l[j]); // 这个位置是否需要点击
cout << res; // 全点成 0 的最少步数
```

求 $1$ 的方法一样，只需改成 `res2 += ((c[i][j] == '0') ^ h[i] ^ l[j]);`，就不放了。本题答案就是 $\min(res,res2)$。

也许有人问第一个双重循环为什么不用改，因为行数和列数都是偶数，$n-x$ 和 $x$ 奇偶性刚好相同。


---


两个 $res$ 一看就能找规律。

`((c[i][j] == '1') ^ h[i] ^ l[j])` 和 `((c[i][j] == '0') ^ h[i] ^ l[j])` 的值刚好相反（其中肯定有一个结果为 $1$），那么这个 $1$ 不是加在 $res$ 上就是加在 $res2$ 上，然后循环求了 $n^2$ 次。~~诶，我有一计~~。那么只需要求一个 $res$，另一个的结果就是 $n^2-res$。两者取最小就是本题答案（~~当然这个规律不找也行，反正时间差不到哪去~~）。

### 代码

时间复杂度都是 $O(n^2)$。

朴素：

```cpp
#include <iostream>
using namespace std;

bool h[1005], l[1005];
int n, res, res2;
char c[1005][1005];

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			cin >> c[i][j];
			if (c[i][j] == '0') h[i] ^= 1, l[j] ^= 1; // c[i][j] == '0'/'1'都可以
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)  {
			res += ((c[i][j] == '1') ^ h[i] ^ l[j]);
			res2 += ((c[i][j] == '0') ^ h[i] ^ l[j]);
		}
	cout << min(res, res2);
}
```

规律：（找了跟找了一样）

```cpp
#include <iostream>
using namespace std;

bool h[1005], l[1005];
int n, res;
char c[1005][1005];

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			cin >> c[i][j];
			if (c[i][j] == '1') h[i] ^= 1, l[j] ^= 1;
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) 
			res += ((c[i][j] == '1') ^ h[i] ^ l[j]);
	cout << min(res, n * n - res);
}
```

有什么问题或者想吐槽的可以写在评论区里。

---

## 作者：TernaryTree (赞：6)

深刻的构造题。01 翻转有一种套路是先构造方案，操作贡献对 $2$ 取模之后得到一种优的解。

我们发现对所有 $x=i,y=j$ 的点操作一次，恰好其他点不动，$(i,j)$ 翻转。假如我们要让最后全是 $0$，这相当于对那些一开始是 $1$ 的点所在行列操作次数 $+1$，最后对整个矩阵取模 $2$。

记录每行每列有多少个 $1$，计算即可，记得把最终为 $0$ 和 $1$ 的情况都算一遍。

```cpp
#define gc getchar

int n, ans;
int a[maxn][maxn], x[maxn], y[maxn];

void fake_main() {
	n = read(); 
	rep(i, 1, n) {
		rep(j, 1, n) if (a[i][j] = gc() - '0') ++x[i], ++y[j];
		gc();
	}
	rep(i, 1, n) rep(j, 1, n) ans += (a[i][j] + x[i] + y[j]) & 1;
	write(min(ans, n * n - ans));
}
```

---

## 作者：Petit_Souris (赞：4)

被猜猜猜题硬控二十分钟，还是太菜了！

首先，操作前一共有 $2^{n^2}$ 个不同的状态。

其次，你发现在每个位置上操作两次相当于没变，因此不同的最简操作数量也是 $2^{n^2}$。

最后，你发现每个初始状态都是有解的，因为你可以对于一个是 $1$ 的位置 $(i,j)$，将所有的 $(x,y)$ 都操作一遍，其中 $x=i$ 或 $y=j$，这样就实现了翻转一个位置。

因此一种初始状态对应了一种最简操作方案，直接求出这个方案就行了，只需要统计每行每列的 $1$ 个数即可。时间复杂度 $\mathcal O(n^2)$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=1009;
ll n,R[N],C[N],ans;
char s[N][N];
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    n=read();
    rep(i,1,n)scanf("%s",s[i]+1);
    rep(i,1,n){
        rep(j,1,n){
            if(s[i][j]=='1')R[i]++,C[j]++;
        }
    }
    rep(i,1,n){
        rep(j,1,n){
            if((s[i][j]-'0'+R[i]+C[j])&1)ans++;
        }
    }
    write(min(n*n-ans,ans));
    return 0;
}
```

---

## 作者：Ravener (赞：3)

很妙的 Ad-hoc。

实质是个二维的 01 翻转问题（即开关问题）。\
01 翻转问题具有以下性质：
> 1. 翻转 $k$ 次等效于翻转 $(k \bmod 2)$ 次；
> 2. 翻转的顺序不影响翻转的结果。

---

回到这道题。

忽略图像的镜面变换和旋转变换，易知初始方案数为 $2^{n^2}$。\
根据性质 1，可知：
> 把 $(i,j)$ 所在的行和列的所有硬币作**一次操作**，可等效于只有 $(i,j)$ 发生翻转。\
> 因为如果这么做，**所有除 $(i,j)$ 外的硬币**翻转了 $2n$ 次，状态不变；而 $(i,j)$ 只翻转了 $(2n-1)$ 次，状态改变，被翻转。

据此可知：对于每一个初始方案，总是可以**在经过有限次操作后**变成全为反面（或全为正面）的情况。

把每行以及每列出现过的 $0$（或 $1$）统计下来，然后直接计算即可。

Code:
```cpp
signed main()
{
	n=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
		{
			char a=getchar();
			if(a=='1') coin[i][j]=1,
				  ++line_h[i],
				  ++row_h[j];
			else if(a=='0') coin[i][j]=0;
            else --j;
		}
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			ans+=(coin[i][j]+line_h[i]+row_h[j])&1;
	print(min(n*n-ans,ans));
}
```

此代码时间复杂度为 $\mathcal O(n^2)$，足以应付 [dalao 的 test](https://www.luogu.com.cn/problem/U475696)，但用时是正解的约 1.8 倍。

---

Q\&A：

1. 求贡献的式子怎么来的？
> ~~idk 啊。~~\
> 此代码计算的是变成全为反面的情况。\
> 根据性质 1，枚举 $(i,j)$ 以及其所在行、列的所有正面硬币加起来，再对 $2$ 取模，即可得到 $(i,j)$ 的贡献。

2. 为什么不能直接输出答案？
> 有些时候，变成全为正面的情况所需的操作数要比变成全为反面的情况的要少，所以要取两者的最小值。

3. 为什么变为全为正面所需操作数等于 `n*n-ans` 的值？
> 由那个求贡献的式子，$(i,j)$ 的贡献只能是 $0$ 或 $1$。\
> 变为全为反面的情况数等于 `ans` 的值，可知变为全为正面所需操作数等于 `n*n-ans` 的值。

---

## 作者：ljh789789 (赞：3)

# P10635题解

## 题目分析

### [题目传送门](https://www.luogu.com.cn/problem/P10635)

### 题目描述

有一个 $n$ 行 $n$ 列的棋盘，每个格子上都有一个硬币，且 $n$ 为偶数。每个硬币要么是正面朝上，要么是反面朝上。每次操作你可以选定一个格子 $(x,y)$，然后将第 $x$ 行和第 $y$ 列的所有硬币都翻面。求将所有硬币都变成同一个面最少需要的操作数。

### 数据规模

 $1 \le n \le 1000$

## 思路讲解

这是一道思维题。之所以是思维题，是因为这一题n的上限已经推到了 $10^3$，纯暴力枚举肯定不行，那么我们就要开始思考：

首先，我们考虑如果将第 $x$ 行和第 $y$ 列的所有硬币都翻转一遍会发生什么：对 $(x,y)$ 之外的所有硬币，都恰有两次操作会将其翻转，因此状态不变；而 $(x,y)$ 本身被翻转了 $2n-1$ 次，状态恰好改变。

于是我们得到了种将所有硬币都变成同一面的方法。比如要将所有位置都变成状态 $1$，只需对每个为$0$的位置，将其所在的行和列的全部 $2n-1$ 个位置翻转即可。

由于在同一个位置翻转两次等价于没有翻转，可以将重叠的操作抵消。这样我们就得到了一种能 $n^2$ 次操作内将全部硬币变成同一面的方案。

不仅如此，从上述分析过程来看，这样的方案应该是唯一的：因为每个状态都可用以上方法达到，而状态总数为 $2^{n^2}$，操作序列总数也为 $2^{n^2}$，每种操作序列好最终状态是一一对应的。

这样我们就解决了此题。注意题目要求的是变成同一个面，没有指出是全为 $0$ 还是全为 $1$，所以要在这两者里取最小值。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
int n,ans,h[maxn],l[maxn],a[maxn][maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
	while ( isdigit(ch))ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return ret*f;
}
int main(){
	freopen("coin.in","r",stdin);
	freopen("coin.out","w",stdout);
	n=read();
	for (int i=1;i<=n;i++)
	for (int j=1;j<=n;j++){
		char ch=getchar();
		while (ch!='0'&&ch!='1') ch=getchar();
		if (ch=='0') continue;
		a[i][j]=1,h[i]++,l[j]++;
	}
	for (int i=1;i<=n;i++)
	for (int j=1;j<=n;j++)
		ans+=(a[i][j]+h[i]+l[j])&1;
	ans=min(ans,n*n-ans);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：lhz123bc (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10635)

## 思路分析
题目的数据范围是 $1 \le n \le 1000$，我们需要写一份时间复杂度为 $\mathcal{O}(n^2)$ 的代码。

若将第 $x$ 列和第 $y$ 行翻转，那么对于 $(x,y)$ 以外的硬币都恰有两次操作会将其翻转，则状态不变。那么如果我们要把硬币全部变成朝上的，那么我们只需要对于每个朝下的位置，将其所在的行和列的全部 $2n−1$ 个位置都翻转一次即可。

对于一个 $n \times n$ 的棋盘，它的状态有 $2^{n^2}$ 种，两次操作等于没变，所以不同的最简操作次数也是 $2^{n^2}$ 种。其中每种操作序列和最终状态是一一对应的，而且每种初始状态均可在 $n^2$ 次操作将全部硬币变成同一面。

于是我们便解决了这道题，注意题目没告诉我们将硬币全部翻成向上的还是向下的，两者取最小值就是本题的答案。

[AC Code](https://www.luogu.com.cn/paste/g7nxxjth)

---

## 作者：donghanwen1225 (赞：1)

高考结束了，来复健 OI。

------------

这是一道纯正的 Ad-hoc 题。

我们考虑如果将第 $x$ 行和第 $y$ 列的所有硬币都翻转一遍会发生什么：对 $(x,y)$ 之外的所有硬币，都恰有两次操作会将其翻转，因此状态不变；而 $(x,y)$ 本身被翻转了 $2n-1$ 次，状态恰好改变。

于是我们得到了一种将所有硬币都变成同一面的方法。比如要将所有位置都变成状态 $1$，只需对每个为 $0$ 的位置，将其所在的行和列的全部 $2n-1$ 个位置都翻转一次即可。

由于在同一个位置翻转两次等价于没有翻转，可以将重叠的操作抵消。这样我们就得到了一种能在 $n^2$ 次操作内将全部硬币变成同一面的方案。

不仅如此，从上述分析过程来看，这样的方案应该是唯一的：因为每个状态都可用以上方法达到，而状态总数为 $2^{n^2}$，操作序列总数也为 $2^{n^2}$，每种操作序列和最终状态是一一对应的。

这样我们就解决了此题。注意题目要求的是都变成同一个面，没有指出是全为 $0$ 还是全为 $1$，所以要在这两者里取最小值。

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,h[1005],l[1005],a[1005][1005];char s[1005];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		for(int j=1;j<=n;j++)
			if(s[j-1]=='0') a[i][j]=1,h[i]++,l[j]++;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			ans+=(a[i][j]+h[i]+l[j])%2;
	cout<<min(n*n-ans,ans);
	return 0;
}
```

---

## 作者：Tracy_Loght (赞：1)

## 题目大意：

给你一个表，上面有多个单位二进制数，你有一种异或操作，可以让当前行列的数异或一次，求变为相同的最少操作次数。

## 分析：

注意异或这两个字，连续异或两次的结果是相同的，所以每个值只需要异或最多一次。

**考虑已下情况：**

![](https://cdn.luogu.com.cn/upload/image_hosting/2236gq8w.png)

其中第一张图的红色位置为一，其余为零。

考虑在第二张图的深灰色位置进行异或操作，这一次的异或操作会影响到图上的所有点。

但是在非深灰色的点上，每个点总会被其两侧的点异或，共计两次，约等于没变化。

对于红色的那个点则会异或 $2n-1$ 次，相当于变化一次。

最终结果为最后一张图，及全部为同一个数。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,o[1001][1001],x[1001],y[1001],jl;
string s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=0;j<n;j++){
			o[i][j+1]=s[j]-'0';
			if(o[i][j+1]==1) x[i]++,y[j+1]++;
			x[i]%=2;y[j+1]%=2;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if((o[i][j]+x[i]+y[j])%2==1) jl++;
		}
	}
	cout<<min(jl,n*n-jl);
	return 0;
}
```

---

## 作者：emo_zkt (赞：0)

首先，大家要知道一个常识：硬币翻两次等于没翻，故题目简单起来了，然后分开统计全转 $0$ 和全转 $1$ 操作数，小的输出。

具体流程：输入时分别统计 $0$ 和 $1$，若是想要的 $0/1$，则 $a_{i,j}$ 赋值 $1$，自身行列各加 $1$,（因为每次翻 $(i,j)$ 都会影响第 $i$ 行和第 $j$ 列，所以 $h_{i}$，$z_{j}$ 分别 $+1$），如果是 $1$，则同理。

输出：统计每个位置需要翻几次才能达到想要的 $0/1$，每次统计 $a_{i,j}+h_{i}+z_{j}$，因为翻两次等于没翻故再取余 $2$，$sum$ 累加这个值，最后比较 $sum0$，$sum1$。收工。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,h1[N],z1[N],a1[N][N],sum1,h0[N],z0[N],a0[N][N],sum0;//后面带1的：全转1的行数，列数，以及本体需要的0/1次，后面带0的同理 
char c;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>c;
			if(c=='0')a1[i][j]=1,h1[i]++,z1[j]++;//全转1
			else a0[i][j]=1,h0[i]++,z0[j]++;//全转0 
		}	
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)sum1+=(a1[i][j]+h1[i]+z1[j])%2,sum0+=(a0[i][j]+h0[i]+z0[j])%2;//统计需要次数，因翻两次等于没翻，故取余2
	cout<<min(sum0,sum1);//取最小 
	return 0;
}
```

---


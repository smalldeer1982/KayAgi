# [SNCPC2024] 猜质数 I

## 题目描述

**这是一道交互题。**

MCPlayer542 手上有一个神秘的**奇质数** $p$，但他并不想让你知道这个数是多少。

他打算用一个函数 $f(x)$ 来加密他的数，其值为 $x$ 在十进制下的各位数字之和，例如 $f(5)=5$，$f(542)=5+4+2=11$，$f(1024)=1+0+2+4=7$。

**然而考虑到你太聪明，他想了想，决定把加密函数改成：**
$$g(x)=f(f(f(f(f(f(f(f(f(f(x))))))))))$$
**即连续应用 $10$ 次 $f(x)$，并把手上的 $p$ 换成了 $q=p^k$。** 

现在他准备给你 $n$ 个整数 $g(q^{a_1}),\ g(q^{a_2}),\ \ldots,\ g(q^{a_n})$，并希望你能告诉他
$$q^{a_1}\bmod (m\cdot a_1),\ q^{a_2}\bmod (m\cdot a_2),\ \ldots,\ q^{a_n}\bmod (m\cdot a_n)$$
分别是多少。**他觉得你肯定猜不到，所以决定让你自己选择 $m$ 和 $a_1,\ a_2,\ \ldots,\ a_n$**。你能完成这个任务吗？

**注意：$m$ 的范围有特殊限制。**


## 说明/提示



在第一组数据中，MCPlayer542 手上的奇质数 $p=3$，因此有 $q=p^k=3$。

我们选择数组 $a=\{1,\ 2,\ 3\}$，依次得到 $g(3^1)=3, \ g(3^2)=9, \ g(3^3)=9$。

随后我们猜到 $p=3$，选择 $m=100$，因此输出 $3^1\bmod (100\times 1)=3, \ 3^2\bmod (100\times 2)=9, \ 3^3\bmod (100\times 3)=27$。

在第二组数据中，MCPlayer542 手上的奇质数 $p=7$，因此有 $q=p^k=49$。

我们选择数组 $a=\{1,\ 7,\ 49\}$，依次得到 $g(49^1)=4,\ g(49^7)=4,\ g(49^{49})=4$。

随后我们**敏锐地发现** $p=7$，选择 $m=49$，因此输出 $49^1\bmod (49\times 1)=0, \ 49^7\bmod (49\times 7)=0, \ 49^{49}\bmod (49\times 49)=0$。

注：第二组数据中的“**敏锐地发现**”仅作为交互流程的示意，并不保证上述交互可以确定 $p=7$。

## 样例 #1

### 输入

```
2
3 1

3

9

9


3 2

4

4

4


```

### 输出

```


1

2

3

100
3 9 27

1

7

49

49
0 0 0
```

# 题解

## 作者：Leasier (赞：5)

为什么洛谷同步赛场上只有一个人过啊 /ng

------------

显然 $g(x) = (x - 1) \bmod 9 + 1$。

注意到交互所能给我们的信息相当有限：顶天了就是 $p \bmod 9$。因此从原根等质数幂的性质角度出发是不可取的。~~这也告诉我们 $k$ 没用。~~

注意到 $n \leq 50$，猜想可以构造 $a_i \sim O(2^i)$。

令 $a_i = 2^i, m = 36 = 2^2 \times 9$，则现在我们需要求 $q^{2^i} \bmod 2^{i + 2}$，随后与询问出的 $q \bmod 9$ 的值 CRT 合并即可。

注意到 $\forall i \in \mathbb{N}^*, \operatorname{ord}(2^{i + 2}) = 2^i$，于是前者始终为 $1$。至此问题得解。

- 实际做这题的时候，我一开始尝试令 $a_i = 2^{i - 1}$，但由于 $\operatorname{ord}(4) = 2 \neq 1$，这样并不可行。

代码：
```cpp
#include <stdio.h>

typedef long long ll;
typedef __int128 lll;

const int N = 50;
ll x[N + 7], y[N + 7], mod[N + 7], ans[N + 7];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = (lll)ans * x % mod;
		x = (lll)x * x % mod;
		p >>= 1;
	}
	return ans;
}

int main(){
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= N; i++){
		ll a = 1ll << (i + 2);
		x[i] = a * quick_pow(a, 5, 9);
		y[i] = 9 * quick_pow(9, a / 2 - 1, a);
		mod[i] = 9 * a;
	}
	for (int i = 1; i <= t; i++){
		int n, k;
		scanf("%d %d", &n, &k);
		for (int j = 1; j <= n; j++){
			int r;
			printf("%lld\n", 1ll << j);
			fflush(stdout);
			scanf("%d", &r);
			ans[j] = (x[j] * r + y[j]) % mod[j];
		}
		printf("36\n");
		for (int j = 1; j <= n; j++){
			printf("%lld ", ans[j]);
		}
		printf("\n");
		fflush(stdout);
	}
	return 0;
}
```

---

## 作者：Cute_Fish (赞：1)

:::info[题面]
设 $f(n)$ 为 $n$ 的数位和。

则不妨设 $g(n)$ 满足：

$$
g(n)=
\begin{cases}
n &n \le 9\\
g(f(n)) &n \ge 10 \\
\end{cases}
$$

你可以自定义一个正整数 $m(m\ge 35)$ 和长度为 $n(n\le 50)$ 的正整数序列 $a(a_i \le 10^{18})$。

交互库会回答你 $g(q^{a_i})$，其中 $q=p^k$，$k$ 给定，$p$ 是一个奇素数。

请你求出 $q^{a_i} \bmod (m \times a_i)$。
:::

这个题太牛了，以至于空想 1h 最后看题解发现结论全假了 \bx。

注意到 $g(n)=(n-1) \bmod 9 +1$。但这并没有什么用。

所以我们考虑特殊的数据范围 $n\le 50$ 和 $m \ge 35$，这启发我们去猜测关于 $a_i$ 和 $m$ 的值。

考虑令 $a_i =2^i$，$m=36$，此时题目所求为 $q^{2^i} \bmod (9 \times 2^{i+2})$。直接做不好做，考虑先拆开再用 $\operatorname{CRT}$ 合并。

不难发现 $2^{i+2}(i \ge 1)$ 的阶为 $2^i$ 所以有 $q^{2^i} \bmod 2^{i+2}=1$。$q\bmod 9$ 显然好求。

然后就做完了。

:::success[Code]
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
int res[63],pw[63],x,y;
inline int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0;
		return a;
	}
	int d=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return d;
}
signed main(){
	pw[0]=1;
	for(int i=1;i<=62;i++)pw[i]=pw[i-1]*2%9;
	int T;cin>>T;
	while(T--){
		int n,k;cin>>n>>k;
		for(int i=1;i<=n;i++){
			cout<<(1ll<<i)<<"\n";
			int r;cin>>r;
			int d=exgcd(pw[i+2],9,x,y);
			x=(x%9+9)%9;
			x=x*(r-1)%9;
			res[i]=1+(1ll<<i+2)*x;
		}
		puts("36");
		for(int i=1;i<=n;i++)cout<<res[i]<<" ";
		cout<<"\n";
	}
}
```
:::

---

## 作者：xiezheyuan (赞：1)

## 思路

这道题非常费脑子，我也不会做，看了题解才会的。

首先需要证明一个结论 $q^{(2^x)}\bmod 2^{x+2}=1$。

欲证明原命题，先证明对于 $x=1$ 的情况，也就是 $q^2\bmod 8=1$。因为 $q=p^k$，而 $p$ 为奇数，所以 $q$ 也是奇数，则 $q+1,q-1$ 均为偶数。且 $q+1,q-1$ 中至少有一个为 $4$ 的倍数。所以 $(q+1)(q-1)=q^2-1$ 是 $8$ 的倍数，也就是 $q^2\bmod8=1$ 证毕。

然后我们采用数学归纳法，若已经证明了 $x=n$ 成立，那么需要证明 $x=n+1$ 同样成立。

对式子变形：$q^{(2^{x+1})}-1=(q^{(2^x)})^2-1=(q^{(2^x)}-1)(q^{(2^x)}+1)$。

又因为 $q^{2^x}\bmod 2^{x+2}=1$，则 $2^{x+2}\mid (q^{(2^x)}-1)$，而 $q^{(2^x)}=p^{k2^x}$ 是奇数，所以 $q^{(2^x)}+1$ 是偶数，所以 $2^{x+3}\mid (q^{(2^x)}-1)(q^{(2^x)}+1)$，所以 $2^{x+3}\mid (q^{(2^{x+1})}-1)$。

因此 $q^{(2^{x+1})}\bmod 2^{x+3}=1$。故该结论得证。

于是我们可以构造 $a_i=2^i$，得到 $g(q^{(2^i)})$。如何求出 $g(q^{(2^i)})\bmod(m\cdot a_i)$？我们不妨令 $m=2^2\cdot 9=36$。就转化成了已知两个同余方程，如何合并为一个同余方程？

可以直接 CRT，我比较懒，所以贺了我 exCRT 的板子。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 55;

void exgcd(int a,int b,int &x,int &y){
    if(!b) x = 1, y = 0;
    else exgcd(b, a%b, y, x), y -= a/b * x;
}

struct Equation{
    int a,b;// x=b(mod a)
};

Equation excrt(Equation eq1, Equation eq2){
    int a = eq1.a, b = eq1.b, A = eq2.a, B = eq2.b;
    int g = __gcd(a,A), d = (B - b) / g, k1, k2;
    exgcd(a,A,k1,k2);
    k1 = (k1 * d);
    int x = k1 * a + b, y = (a * A) / g;
    x = (x % y + y) % y;
    return {y, x};
}

int ans[N];

void solve(){
    int n, k;
    cin >> n >> k;
    for(int i=1;i<=n;i++){
        cout << (1ll << i) << '\n';
        cout.flush();
        int v; cin >> v;
        auto ret = excrt({1ll << (i + 2), 1}, {9, v});
        ans[i] = ret.b;
    }
    cout << 36 << '\n';
    for(int i=1;i<=n;i++) cout << ans[i] << ' ';
    cout << '\n';
    cout.flush();
}

signed main(){
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：Otomachi_Una_ (赞：0)

这也是个题啊。

首先 $g(x)=(x-1)\bmod 9+1$。然后我们去问 $a=2^n$，根据欧拉定理就有 $q^{a}\equiv 1\pmod {4a}$。

然后 CRT 一下就知道 $q^a\bmod{36a}$ 了。

显然不用写 CRT，用个暴力枚举代替就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
ll ans[55];
ll n,k;
void solve(){
	cin>>n>>k;
	for(int i=2;i<=n+1;i++){
		cout<<(1ll<<i)<<endl;
		ll x;cin>>x;x%=9;
		for(ll j=1;;j+=(1ll<<i+2)) if(j%9==x){
			ans[i-1]=j;
			break;
		}
	}
	cout<<36<<endl;
	for(int i=1;i<=n;i++){
		cout<<ans[i];
		if(i<n) cout<<' ';
	}
	cout<<endl;
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("Otomachi_Una.in","r",stdin);
	// freopen("Otomachi_Una.out","w",stdout);
	int _;cin>>_;
	while(_--) solve();
	return 0;
}
```

---


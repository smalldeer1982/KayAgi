# [SNCPC2024] 猜质数 II

## 题目描述

为了悄悄准备一个神秘的质数，MCPlayer542 伤透了脑筋。

随后他发明了一种~~聪明~~愚蠢的办法，并起名为“质数分”。

他准备了 $n$ 个不同的数 $a_1,\ a_2,\ \ldots,\ a_n$ 作为测试点，并定义“质数分” $score(x,l,r)$ 如下：

$$score(x,l,r)=\sum_{i=l}^r{f(x,a_i)}$$
其中
$$f(x,y)=\left\{\begin{array}{rcl}u-y, & x=1 \\ u, & 1<x\le y,\ \gcd(x,y)=1 \\ -x\cdot y, & x\neq 1,\ \gcd(x,y)=x \\ 0, & \text{otherwise} \end{array}\right.$$

可见质数的“质数分”通常会比较高~~但还是没什么卵用~~。

于是 MCPlayer542 急了，现在他只想暴力乱测，并得到一个得分和 $\sum_{i=1}^{10^6}{score(i,l,r)}$。他打算测试 $q$ 次，每次测试给定 $u$ 和 $l$，其中 $u$ 为函数 $f(x,y)$ 的参数。

对于每次询问，他想知道所能得到的最大得分和以及能得到这个最大得分和的最小 $r$ 是多少。

## 说明/提示



在样例 1 的第一个询问中，$u_1=14,\ l_1=4$。若我们选择 $r_1=6$，则最后的得分和为 $\sum_{i=1}^{10^6}{score(i,4,6)}$。其中：
- $score(1,4,6)=13+9+11=33$；
- $score(2,4,6)=0+14+14=28$；
- $score(3,4,6)=0+14-9=5$；
- $score(4,4,6)=0+14+0=14$；
- $score(5,4,6)=0-25+0=-25$；
- $i$ 取其他值时均有 $score(i,4,6)=0+0+0=0$。

故 $r_1=6$ 时得分和为 $33+28+5+14-25=55$。

可以证明在 $r_1$ 取其他值时无法得到更大的得分和，故答案为 $55$，且能达成的最小 $r_1$ 为 $6$。

## 样例 #1

### 输入

```
10 7
10 9 2 1 5 3 10 10 1 8
14 4
17 5
13 10
16 1
12 4
16 6
16 3
```

### 输出

```
55 6
60 6
-68 10
-58 6
41 6
20 6
79 6
```

## 样例 #2

### 输入

```
6 8
3 7 7 10 8 9
21 1
20 4
21 3
21 5
21 1
21 2
21 2
21 5
```

### 输出

```
170 3
-100 4
70 3
-27 6
170 3
140 3
140 3
-27 6
```

# 题解

## 作者：Cells (赞：2)

# P10700 \[SNCPC2024] 猜质数 II 嚼烂喂到嘴里教学

## 前言

一道很典的题，感谢 @ [why](https://www.luogu.com.cn/user/497065) @ [tiansuohaoer](https://www.luogu.com.cn/user/1251229) @ [maniubi](https://www.luogu.com.cn/user/528917) @ [Cobal](https://www.luogu.com.cn/user/300512) @ [dayz\_break](https://www.luogu.com.cn/user/688596) 提供大力帮助。

## 思路

首先先读 $10$ 分钟题，然后手模第一组样例的第一个询问，确保读懂题意，否则嚼得再烂都没用。

我们先将题目中乱七八糟的定义揉到一起，得到这个式子：

$$
\displaystyle \sum_{i = 1}^{10^6} \sum_{j = l}^{r} f(i, a_j)
$$

然后我们换个枚举顺序：

$$
\displaystyle \sum_{i = l}^{r} \sum_{j = 1}^{10^6} f(j, a_i)
$$

其中

$$
f(x,y)= \left\{\begin{array}{rcl}u-y, & x=1 \\ u, & 1<x\le y,\ \gcd(x,y)=1 \\ -x\cdot y, & x\neq 1,\ \gcd(x,y)=x \\ 0, & \text{otherwise} \end{array}\right.
$$

你看看函数 $f$ 第二个的式子，当 $x$ 与 $y$ 互质且 $1 < x \le y$ 时，函数值是 $u$，那么这一种情况之和就是 $u \times \varphi(y)$。第三个式子，当 $x$ 是 $y$ 的因数且 $x \not = 1$ 时，是 $-x \times y$，所以第二种情况之和就是 $y$ 的因子和与 $y$ 的乘积的相反数，即 $- \displaystyle \sum_{x \mid y} x \times y$。你可能会好奇为什么有第一个式子，因为当 $x = 1$ 时，第二三个式子（不要前面的那一个不等式）都是成立的，所以这个玩意的函数值就是 $u \times 1 - 1 \times y = u - y$，这也是为什么第二个式子的条件是 $1 < x \le y$，第三个式子的条件是 $x \not = 1$ 了。

综上所述，我们可以将式子化为：

$$
\displaystyle \sum_{i = l}^{r} u \times \varphi(a_i) - num_{a_i}
$$

其中 $num_{a_i}$ 就是 $\displaystyle \sum_{x \mid y} x \times y$。告诉 $a_i$，线性筛可以预处理得到 $\varphi$ 值，然后预处理出 $num$ 数组（因数和的与数的乘积）。

给定 $l, u$，求最大的 $r$，使得上面的函数值最大。我们发现可以使用前缀和处理掉 $l$ 到 $r$ 的循环，于是：

$$
u \times (prephi_{r} - prephi_{l - 1}) - (sum_{r} - sum_{l - 1})
$$

$prephi_{x}$ 就是前 $x$ 个 $a_i$ 的 $phi_{a_i}$ 之和，$sum_{x}$ 就是前 $x$ 个 $a_i$ 的 $num_{a_i}$ 的和。

我们为了~~方便好看~~，换个名字，将 $prephi$ 看作 $x$，把 $sum$ 看作 $y$，然后再将函数值设为 $b$，就有：

$$
u \times (x_{r} - x_{l - 1}) - (y_{r} - y_{l - 1}) = b
$$

因为 $l$ 给定，所以说 $x_{l - 1}, y_{l - 1}$ 不变，相当于我们的坐标轴平移了一下，所有点该怎么怎么样，相对位置不会发生改变，我们不妨将其写成：

$$
u \times x_{r} - y_{r} = b
$$

学过初二的同学都知道一次函数的一般式：

$$
y = k \cdot x + b
$$

如果你学过斜率优化（不学也没关系）就会更好的理解这里的类比。这不就是一个一次函数吗？移项：

$$
y_{r} = u \times x_{r} - b
$$

我们要求让 $b$ 最大，那么 $-b$ 就应该最小。每一对 $x, y$ 的值就相当于平面直角坐标系上的一个点，我们相当于是已知一次函数斜率及函数值，求截距，但是如果暴力算的话每一次都是 $O(n)$。~~那咋搞啊哥？~~

我们不妨数形结合画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gt0v575u.png)

是的，我们发现在凸包内的点无论斜率是多少，都取不到，如果你学过斜率优化 ~~（又来）~~，就更能理解了，如果不会维护凸包就上谷找板子吧，简单来说就是单调栈维护点与点之间的斜率。

另外在这道题中因为斜率始终是正数，所以只需要维护下凸包。但是这样的时间复杂度仍然不算理想，我们通过模拟发现，这不就当于是斜率为 $u$ 的直线去《切》凸包。

![](https://cdn.luogu.com.cn/upload/image_hosting/efesy4ev.png)

观察斜率 $u$ 和切点左右线段的斜率关系。

诶？左边线段的斜率小于 $u$，右边线段的斜率大于 $u$，又因为我们的凸包斜率始终有单调性，所以可以二分 $\log$ 时间查找。

注意 $a_i \le 10^6$，$num$ 数组可能会爆 `long long`，需要开 `__int128`，同理前缀和 $x, y$ 数组也会爆。并且由于只给定 $l$，要求区间的右端点 $r$，所以 $l \le r$，但是因为全局的凸包和 $l$ 右边的凸包可能长相不一样（绿色和黄色）：

![](https://cdn.luogu.com.cn/upload/image_hosting/oiq6py39.png)

所以我们需要从后往前遍历边加点，边处理询问，所以需要离线询问并排序。

## Code

```c++
# include <bits/stdc++.h>
# define int long long
# define fir first
# define sec second
# define vec vector
# define pb push_back
# define mem(a, b) memset(a, b, sizeof(a))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
using namespace std;

using LL = long long;
using PII = pair<int, int>; 

const int N = 5e5 + 10, A = 1e6 + 10;

int n, m, top, tot;
int a[N], stk[N], phi[A], prime[N];
__int128 x[N], y[N], num[A];

vec<PII> q[N]; 

PII answer[N]; 

int calc(int u, int l, int r){
	return u * (x[r] - x[l - 1]) - (y[r] - y[l - 1]);
}

void sieve(int n){
	rep(i, 1, n){
		for(int j = i; j <= n; j += i){//预处理因子和 
			num[j] += i;
		}
	}
	
	phi[1] = 1;//线性筛的时候处理phi
	rep(i, 2, n){
		if(!phi[i]) prime[++ tot] = i, phi[i] = i - 1;
		
		for(int j = 1; prime[j] * i <= n; j ++){
			if(i % prime[j] == 0){
				phi[i * prime[j]] = phi[i] * prime[j];
				break;
			}
			
			phi[i * prime[j]] = phi[i] * (prime[j] - 1);
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	sieve(A - 10);
	
	cin >> n >> m;
	rep(i, 1, n) cin >> a[i];
	
	rep(i, 1, n){//处理phi和因子和与数乘积的前缀和 
		x[i] = phi[a[i]] + x[i - 1];
		y[i] = a[i] * num[a[i]] + y[i - 1];
	}
	
	rep(i, 1, m){
		int u, l;
		cin >> u >> l;
		q[l].pb({u, i});//离线询问桶排 
	}
	
	pre(i, n, 1){//从后往前 
		while(top > 1 && (y[stk[top]] - y[stk[top - 1]]) * (x[i] - x[stk[top - 1]]) < (y[i] - y[stk[top - 1]]) * (x[stk[top]] - x[stk[top - 1]])) top --;//维护下凸包 
		stk[++ top] = i;//这里的i和离线是的l都是a数组的编号，所以是相同的含义 
		
		rep(j, 0, (int)q[i].size() - 1){
			int u = q[i][j].fir, id = q[i][j].sec;
			int l = 1, r = top - 1, res = top;//因为l = top - 1，所以说top需要单独计算
			while(l <= r){
				int mid = l + r >> 1;
				if((y[stk[mid]] - y[stk[mid + 1]]) < u * (x[stk[mid]] - x[stk[mid + 1]])) r = mid - 1, res = mid;//建议手模这个过程，注意栈中的编号是反着的 
				else l = mid + 1;
			}
			
			int ans = calc(u, i, stk[res]), pos = stk[res];
			answer[id] = {ans, pos};
		}
	}
	
	rep(i, 1, m) cout << answer[i].fir << " " << answer[i].sec << "\n";
	
	return 0;
}
```

写这篇题解一是教练压力的，另一个确实这题很好，我自己的计算几何里面凸包等玩意也没学好，写一下也能加深印象，这篇题解就到这里，感谢你的观看 QwQ。

---

## 作者：xiaruize (赞：2)

题解区咋全是李超树，来个线性解法。

$$
\max\limits_{r=l}^n \sum\limits_{i=1}^{10^6} \sum\limits_{j=l}^r f(i,a_j) = \max\limits_{r=l}^n  \sum\limits_{j=l}^r \sum\limits_{i=1}^{10^6} f(i,a_j)
$$
然后考虑转化 $f(x,y)$
$$
p(y)=\sum\limits_{i=1}^{10^6} f(i,y) =\phi(y)\cdot u -\sum\limits_{x|y}x\cdot y
$$
其中，$\phi(y)$， $s(y)=\sum\limits_{x|y}x\cdot y$ 是常数，可以预处理得到。

以下其它题解都用李超树做了，下面给出一个凸包做法。

考虑以上得到了 $n$ 个一次函数 $p(a_i)$，对这 $n$ 个函数的 $k,b$ 分别做前缀和，记为 $g(x)$。
$$
g(x)=\sum\limits_{i=1}^x p(a_x) = (\sum_{i=1}^x \phi(a_i))\cdot u + (\sum s(a_i))
$$
考虑对询问离线，然后从后往前做，$[l,r]$ 的得分即为 $g(r)-g(l-1)$，其中 $g(l-1)$ 是常数，所以实际要维护的就是最大的 $g(r)$。

发现上述前缀和中，$\phi(x)\geq 0$，所以 $g(x)$ 的斜率是递增的，所以可以维护一个凸包，然后再凸包上二分得到最大值。

具体来说，凸包中维护直线，每次向凸包中插入一条直线，考虑当前这个直线与凸包最后一条直线的交点。

- 若这个交点在最后一个顶点左侧，那么把当前直线放到栈顶。
- 否则说明栈顶的直线不产生贡献，弹栈。

然后在凸包上二分 $u$ 所在的线段，注意如果 $u$ 在顶点要特判取 $id$ 较小的。



```cpp
const int INF = 9e18;
const int N = 1e6 + 10;

struct line
{
	int k, b;
	int id;
	int operator()(int x) const
	{
		return k * x + b;
	}
} stk[N], s[N];
int top = 0;

struct slope
{
	void ins(line cur)
	{
		while (top >= 2 && (__int128)(stk[top].b - stk[top - 1].b) * (stk[top].k - cur.k) <= (__int128)(cur.b - stk[top].b) * (stk[top - 1].k - stk[top].k))
			top--;
		stk[++top] = cur;
	}

	pii get(int u)
	{
		int l = 1, r = top;
		while (l < r)
		{
			int mid = l + r >> 1;
			if ((stk[mid].b - stk[mid + 1].b) >= u * (stk[mid + 1].k - stk[mid].k))
				r = mid;
			else
				l = mid + 1;
		}
		if (stk[r](u) == stk[r + 1](u) && stk[r + 1].id < stk[r].id)
			r++;
		return {stk[r](u), stk[r].id};
	}
} tp;

int n, q;
int phi[N], sum[N];
pii st[N];
bool ntpr[N];
vector<int> pr;
int a[N];
vector<pii> qry[N];
pii res[N];

void init()//预处理
{
	phi[1] = 1;
	rep(i, 2, 1e6)
	{
		if (!ntpr[i])
		{
			pr.push_back(i);
			phi[i] = i - 1;
		}
		for (auto v : pr)
		{
			if (v * i > 1e6)
				break;
			ntpr[v * i] = true;
			if (i % v == 0)
			{
				phi[i * v] = phi[i] * v;
				break;
			}
			phi[i * v] = phi[i] * phi[v];
		}
	}
	rep(i, 1, 1e6)
	{
		for (int j = i; j <= 1e6; j += i)
			sum[j] += i;
	}
}

void solve()
{
	init();
	cin >> n >> q;
	rep(i, 1, n)
	{
		cin >> a[i];
		st[i].first = phi[a[i]] + st[i - 1].first;
		st[i].second = -sum[a[i]] * a[i] + st[i - 1].second;
		s[i] = {st[i].first, st[i].second, i};
	}
	rep(i, 1, q)
	{
		int x, v;
		cin >> v >> x;
		qry[x].push_back({v, i});
	}
	per(i, n, 1)
	{
		tp.ins(s[i]);
		for (auto [u, id] : qry[i])
		{
			int t = -(st[i - 1].first * u + st[i - 1].second);
			auto [val, pos] = tp.get(u);
			res[id] = {val + t, pos};
		}
	}
	rep(i, 1, q) cout << res[i].first << ' ' << res[i].second << endl;
}
```



特别注意，比较交点的时候乘法会炸 ``long long``，所以要开 ``__int128``。

---

## 作者：_LiWenX_ (赞：2)

难点在于看懂题意，场上硬是瞪了十分钟才看懂题，之后就比较套路，最后只有我们队和 rk1 过了这个题估计就是因为大部分人不想看题。

首先不管这个 $f$ 函数的定义，看看我们要求什么东西。

对于一个 $(u,l)$ 的询问，我们要求的应该是以下这个式子：

$$\max\limits_{r=l}^n \sum\limits_{i=1}^{10^6}\sum\limits_{j=l}^r f(i,a_j)$$

换一下求和顺序：

$$\max\limits_{r=l}^n\sum\limits_{j=l}^r\sum\limits_{i=1}^{10^6}f(i,a_j)$$

由于 $a$ 值域是 $10^6$，而且所有 $f(i,j)\not =0$ 要满足 $i\le j$。所以 $\sum\limits_{i=1}^{10^6}f(i,a_j)$ 相当于是把所有有值的 $f(i,a_j)$ 都枚举了一遍。而通过观察，可以发现 $\sum\limits_{i=1}^{10^6}f(i,a_j)=-a_id(a_i)+\varphi(a_i)\times u$。其中 $d(x)$ 表示 $x$ 的因数个数。

那么所求为：

$$\max\limits_{r=l}^n\sum\limits_{i=l}^r\varphi(a_i)\times u-a_id(a_i)$$

将 $\varphi(a_i)\times u-a_id(a_i)$ 看做自变量是 $u$ 的一次函数 $f_i(u)$，所求为：

$$\max\limits_{r=l}^n\sum\limits_{i=l}^r f_i(u)$$

设 $s_i(u)=\sum\limits_{j=1}^i f_j(u)$。式子可以写成：

$$(\max\limits_{r=l}^ns_{r}(u))-s_l(u)$$

直接将操作离线，从后向前枚举查询的 $l$，问题等价于插入一个一次函数，查询一个位置上的最大点值，我们使用李超线段树解决，再使用线性筛预处理出 $d,\varphi$ 函数，复杂度是 $O(n\log V+V)$。

~~场上由于赶时间，线性筛代码是我从网上贺的。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed prime[18000005], tot,phi[18000005];
bool isprime[18000005];
signed num[18000005]; //最小质因子p1组成的等比序列 p1^0+p1^1+...+p1^r1
int d[18000005]; //约数和
void shai(int n=18000000) {
    d[1] = 1; // 1的约数只有自己，约数和是1
    phi[1]=1;
    for (int i = 2; i <= n; i++) {
        if (!isprime[i]) {
            prime[tot++] = i;
            phi[i]=i-1;
            d[i] = num[i] = i + 1; // 1和自身是约数，约数和为i+1; 同时因为i是质数，所以只有一个分拆项,并且分拆项内容=pj^0+pj^1=1+pj=1+i
        }
        for (int j = 0; prime[j] * i <= n&&j<tot; j++) {
            isprime[i * prime[j]] = true;
            if (i % prime[j]) {
                d[i * prime[j]] = d[i] * d[prime[j]]; //积性函数
                num[i * prime[j]] = prime[j] + 1;
                phi[i*prime[j]]=phi[i]*(prime[j]-1);
            } else {
                d[i * prime[j]] = d[i] / num[i] * (num[i] * prime[j] + 1);
                num[i * prime[j]] = num[i] * prime[j] + 1;
                phi[i*prime[j]]=phi[i]*prime[j]; 
                break;
            }
        }
    }
}   
struct line{
	int k,b;
	signed id;
	line(){
		k=id=0;
		b=-1e18;
	}
}sum[500005],tree[500005*50];
signed ls[500005*50],rs[500005*50],cnt,root;
#define mid ((l+r)>>1)
int F(line l,int x){
	return l.k*x+l.b;
}
bool cmp(line a,line b,int x){
	int A=F(a,x);
	int B=F(b,x);
	if(A!=B) return A>B;
	return a.id<b.id; 
}
int add(int now,int l,int r,line k){
	if(k.b==-1e18) return now;
	if(!now) now=++cnt;
	if(F(tree[now],mid)<=F(k,mid)) swap(tree[now],k);
	if(l==r) return now;
	if(F(tree[now],l)<=F(k,l)) ls[now]=add(ls[now],l,mid,k);
	if(F(tree[now],r)<=F(k,r)) rs[now]=add(rs[now],mid+1,r,k);
	return now;
}
line ret;
void ask(int now,int l,int r,int x){
	if(!now) return ;
	if(cmp(tree[now],ret,x)) ret=tree[now];
	if(l==r) return ;
	if(mid>=x) ask(ls[now],l,mid,x);
	else ask(rs[now],mid+1,r,x);
}
#undef mid
int n,q,a[500005];
vector<pair<int,int> > vec[500005];
int ans[500005],id[500005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>q;
	shai();
	sum[0].k=sum[0].b=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i].b=-d[a[i]]*a[i];
		sum[i].k=phi[a[i]];
		sum[i].b+=sum[i-1].b;
		sum[i].k+=sum[i-1].k;
		sum[i].id=i;
	}
	for(int i=1;i<=q;i++){
		int u,l;cin>>u>>l;
		vec[l].push_back(make_pair(u,i));
	}
	for(int i=n;i;i--){
		root=add(root,1,18000000,sum[i]);
		for(auto u:vec[i]){
			ret.b=-1e18;
			ret.id=ret.k=0;
			ask(root,1,18000000,u.first);
			ans[u.second]=F(ret,u.first)-F(sum[i-1],u.first);
			id[u.second]=ret.id;
		}
	}
	for(int i=1;i<=q;i++){
		cout<<ans[i]<<' '<<id[i]<<'\n';
	}
}
```

---

## 作者：Fzrcy (赞：0)

诈骗题。将 $f(x,y)$ 拆开后可以得到：$f(x,y)=u[\gcd(x,y)=1]-xy[\gcd(x,y)=x]$。

有

$$
\begin{aligned}
\sum_{i=1}^{10^6}score(i,l,r)&=\sum_{i=1}^{10^6}\sum_{j=l}^{r}f(i,a_j)\\
&=\sum_{i=l}^{r}\sum_{j=1}^{10^6}f(j,a_i)
\end{aligned}
$$

由 $a_i\le 10^6$ 可知：

$$
\sum_{i=1}^{10^6}f(i,x)=\sum_{i=1}^{10^6}u[\gcd(i,x)=1]-ix[\gcd(i,x)=i]=\varphi(x)u-d(x)x
$$

其中 $d(x)$ 为 $x$ 的约数之和。

$\sum_{j=1}^{10^6}f(j,a_i)$ 可以 $O(n\log n)$ 或 $O(n)$ 预处理。设 $p_i=\sum_{j=1}^{i}\varphi(a_j)$，$q_i=\sum_{j=1}^{i}d(a_j)$，有 $\sum_{i=1}^{10^6}score(i,l,r)=(p_r u-q_r)-(p_{l-1} u-q_{l-1})$，于是问题变为求使 $p_r u-q_r$ 最大的 $r$。

由于 $p_r u-q_r$ 的形式是一次函数，所以我们可以用李超线段树，单次查询复杂度为 $O(\log V)$。

于是我们可以将询问离线，按照 $l$ 从大到小的顺序依次求解即可，总复杂度为 $O(q\log V)$。

如果题目强制在线，可以用树套树，时空复杂度均为 $O(n\log n\log V)$（视 $n,q$ 同阶）。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+9,M=1.8e7+2;
int phi[N],pr[N],pc;ll G[N];
bitset<N>vis;
inline void sieve(int n){
    phi[1]=1;
    for(int i=2;i<=n;i++){
        if(!vis[i])pr[++pc]=i,phi[i]=i-1;
        for(int j=1;j<=pc&&i*pr[j]<=n;j++){
            vis[i*pr[j]]=1;
            if(i%pr[j])phi[i*pr[j]]=phi[i]*(pr[j]-1);
            else{phi[i*pr[j]]=phi[i]*pr[j];break;}
        }
    }
    for(int i=1;i<=n;i++)for(int j=i;j<=n;j+=i)G[j]+=(ll)i*j;
}
struct Line{ll k,b;}L[N];
inline ll get(int i,int x){return (ll)x*L[i].k+L[i].b;}
bool cmp(int i,int j,int x){
    ll P=get(i,x),Q=get(j,x);
    return (P^Q)?P>Q:i<j;
}
struct LCtree{
    int id[M<<2];
    inline void ins(int k,int l,int r,int x){
        int mid=l+r>>1;
        if(cmp(x,id[k],mid))swap(id[k],x);
        if(l==r)return;
        if(cmp(x,id[k],l))ins(k<<1,l,mid,x);
        if(cmp(x,id[k],r))ins(k<<1|1,mid+1,r,x);
    }
    inline int q(int k,int l,int r,int x){
        int cur=id[k],t;if(l==r)return cur;int mid=l+r>>1;
        if(x<=mid)return t=q(k<<1,l,mid,x),cmp(cur,t,x)?cur:t;
        return t=q(k<<1|1,mid+1,r,x),cmp(cur,t,x)?cur:t;
    }
}tr;
inline int in(){
    static char c; static int x; x=0;
    while(c=getchar(),c<'0'||c>'9');
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
template<typename T>inline void wr(T x){
    if(x<0)putchar('-'),x=-x;
    if(x>=10)wr(x/10);
    putchar('0'+x%10);
}
int n,q,a[N],mx,U[N],R[N]; ll ans[N]; vector<int>e[N];
int main(){
    n=in(),q=in(),L[0]={0,(ll)-2e18};
    for(int i=1;i<=n;i++)mx=max(mx,a[i]=in());
    sieve(mx);
    for(int i=1;i<=n;i++){
        L[i]={phi[a[i]],-G[a[i]]};
        if(i>1)L[i].k+=L[i-1].k,L[i].b+=L[i-1].b;
    }
    mx=1;
    for(int i=1,l;i<=q;i++)
        U[i]=in(),e[l=in()].push_back(i),mx=max(mx,U[i]);
    for(int i=n;i;i--){
        tr.ins(1,1,mx,i);
        for(int x:e[i]){
            int cur=tr.q(1,1,mx,U[x]);
            R[x]=cur,ans[x]=get(cur,U[x])-get(i-1,U[x])*(i>1);
        }
    }
    for(int i=1;i<=q;i++)
        wr(ans[i]),putchar(' '),wr(R[i]),putchar('\n');
    return 0;
}
```

---

## 作者：xiezheyuan (赞：0)

## 思路

下文中，$\sigma(x)$ 表示 $x$ 的因子和。

题目写的极为抽象。发现我们需要回答的是这个玩意：

$$
\max_{r=l}^{n}\sum_{i=1}^{10^6}\sum_{j=l}^{r}f(i,a_j)=\max_{r=l}^{n}\sum_{i=l}^{r}\sum_{j=1}^{10^6} f(j,a_i)
$$

$f$ 的定义十分麻烦，我们一步一步看：

- $1\lt j\leq a_i,\gcd(a_i,j)=1,f(j,a_i)=u$，看起来很像 $u\varphi(a_i)$，但实际上是 $u\varphi(a_i)-u$。
- $j\neq 1,\gcd(a_i,j)=j,f(j,a_i)=-a_ij$，看起来很像 $-a_i\sigma(a_i)$，但实际上是 $-a_i\sigma(a_i)+a_i$。

所以：

$$
\begin{aligned}
&\sum_{j=1}^{10^6}f(a_i,j)\\
&=u-a_i+u\varphi(a_i)-u-a_i\sigma(a_i)+a_i\\
&=u\varphi(a_i)-a_i\sigma(a_i)
\end{aligned}
$$

然后带入原式：

$$
\begin{aligned}
&\max_{r=l}^{n}\sum_{i=l}^{r}\sum_{j=1}^{10^6} f(j,a_i)\\
&=\max_{r=l}^{n}\sum_{i=l}^{r}u\varphi(a_i)-a_i\sigma(a_i)\\
&=\max_{r=l}^{n}\left(\sum_{i=1}^{r}u\varphi(a_i)-a_i\sigma(a_i)-\sum_{i=1}^{l-1}u\varphi(a_i)-a_i\sigma(a_i)\right)\\
&=-\left(\sum_{i=1}^{l-1}u\varphi(a_i)-a_i\sigma(a_i)\right)+\max_{r=l}^{n}\left(\sum_{i=1}^{r}u\varphi(a_i)-a_i\sigma(a_i)\right)\\
&=-\left(\sum_{i=1}^{l-1}u\varphi(a_i)-a_i\sigma(a_i)\right)+\max_{r=l}^{n}\left((-a_i\sigma(a_i))+u\sum_{i=1}^{r}\varphi(a_i)\right)
\end{aligned}
$$

前半段是一个与最大值无关的式子，后半段是 $r-l+1$ 条一次函数位于 $x=u$ 的极大值。

我们离线，然后倒着扫一遍，维护一个李超线段树，在每个询问的 $l-1$ 处统计答案。

时间复杂度 $O((n+q)\log u)$。可以通过本题。注意李超线段树可能需要动态开点。

如果你 WA 在了第 $26$ 个点，LiWenX 指出，可能是没有处理同样大时要取 $r$ 最小的，这一部分需要讨论一下。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l + r) >> 1)
using namespace std;

const int V = 1e6 + 5, N = 5e5 + 5, M = 2e7 + 5;
bitset<V> vis;
int pri[N], tot, phi[V], d[V];
int n, q, a[N];
struct option {int u, id; };
vector<option> opt[N];

inline void sieve(int n){
    phi[1] = 1;
    for(int i=2;i<=n;i++){
        if(!vis[i]) pri[++tot]=i, phi[i]=i - 1;
        for(int j=1;j<=tot&&i*pri[j]<=n;j++){
            vis[i*pri[j]] = 1;
            if(!(i%pri[j])){
                phi[i*pri[j]] = phi[i] * pri[j];
                break;
            }
            phi[i*pri[j]] = phi[i] * phi[pri[j]];
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j+=i) d[j] += i;
    }
}

namespace Chao {
    int ls[N << 6], rs[N << 6];
    struct line{
        int k, b, id;
        line(){b = -1e18; }
        line(int k,int b,int id) : k(k), b(b), id(id) {}
        int operator()(int x){return k*x + b;}
    } t[N << 6];int tt;
    void update(line x,int &i,int l,int r){
        if(!i) i = ++tt;
        if(l == r){
            if(t[i](l) <= x(l)) t[i] = x;
            return;
        }
        if(t[i](mid) < x(mid)) swap(t[i], x);
        if(t[i](l) < x(l)) update(x, ls[i], l, mid);
        if(t[i](r) < x(r)) update(x, rs[i], mid + 1, r);
    }

    int lastans;
int ans;
    void query(int p,int &i,int l,int r){
        if(!i) return ;
        if(t[i](p)>t[ans](p)||(t[i](p)==t[ans](p)&&t[i].id<t[ans].id)) ans=i;
        if(l == r){
            return ;
        }
        int now = t[i](p);
        if(p<=mid) query(p,ls[i],l,mid);
        else query(p,rs[i],mid+1,r);
    }
}
pair<int,int> ans[N];
Chao::line lines[N];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> q;
    for(int i=1;i<=n;i++) cin >> a[i];
    sieve(1e6); int mxu = 0;
    for(int i=1;i<=q;i++){
        int u, l; cin >> u >> l;
        opt[l - 1].push_back({u, i});
        mxu = max(mxu, u);
    }
    int k = 0, b = 0, rt = 0;
    lines[0] = {0, 0, 0};
    for(int i=1;i<=n;i++){
        k += (phi[a[i]]);
        b += (- a[i] * d[a[i]]);
        lines[i] = {k, b, i};
        // cout << k << ' ' << b << '\n';
    }
    for(int i=n;~i;i--){
        for(option opt : opt[i]){
            Chao::ans=0;
            Chao::query(opt.u,rt,1,mxu);
            ans[opt.id].first = Chao::t[Chao::ans](opt.u) - lines[i](opt.u);
            ans[opt.id].second = Chao::t[Chao::ans].id;
            // Chao::lastans = 0;
            // ans[opt.id].first = Chao::query(opt.u, rt, 1, mxu) - lines[i](opt.u);
            // ans[opt.id].second = Chao::lastans;
        }
        if(i){
            // cout << lines[i].k << ' ' << lines[i].b << '\n';
            Chao::update(lines[i], rt, 1, mxu);
        }
    }
    for(int i=1;i<=q;i++) cout << ans[i].first << ' ' << ans[i].second << '\n';
    return 0;
}

// Written by xiezheyuan
```

---


# 永恒（Eternity）

## 题目背景

>$$行走人间的，$$
>
>$$不一定是天使。$$
>
>$$带来灾厄的，$$
>
>$$不一定是恶魔。$$
>
>$$恶魔的眼泪被天使珍藏 ， $$
>
>$$天使的纯净由恶魔守护。$$
>
>$$或许，$$
>
>$$这是最好的结局。$$

## 题目描述

一些前置定义：

- 可重集中的元素必须是非负整数。

- 可重集的大小为可重集中元素的个数。

- 对于一个大小为 $x$ 的可重集，设其中的元素为 $a_1,a_2\dots a_x$，那么这个可重集的**权值**就为 $a_1\oplus a_2\oplus \dots \oplus a_x$，即可重集中所有元素的**异或和**。

现在给出 $n,m$。

问有多少不同的大小为 $n$ 的可重集 $S$ 满足：

$$\max\limits_{T \subseteq  S,T\ne \emptyset}{Q_T}=m$$

其中 $Q_T$ 为可重集 $T$ 的**权值**。

**注意：根据可重集的性质，数字相同但数字顺序不同的可重集算同一种可重集，即 $\left \{ 1,2,3 \right \} $ 与 $\left \{ 3,2,1 \right \} $ 算同一种可重集。**

求出不同可重集的个数 $\bmod\ 998244353$ 的结果。

可以证明这样的可重集个数是有限的。

## 说明/提示

#### 【样例解释】

样例一中 $13$ 种方案分别为：

$(0,0,5)$$,$$(0,1,4)$$,$$(0,1,5)$$,$$(0,4,5)$$,$$(0,5,5)$$,$$(1,1,4)$$,$$(1,1,5)$$,$$(1,4,4)$$,$$(1,4,5)$$,$$(1,5,5)$$,$$(4,4,5)$$,$$(4,5,5)$$,$$(5,5,5)$。

#### 【数据范围】

| subtask 编号 | $n$ | $m$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :-----: |
| $0$ | $\le 10$ | $\le 10$ | $-$ | $10$ |
| $1$ | $\le 10^5$ | $<2^{60}$ | $A$ | $20$ |
| $2$ | $\le 2000$ | $\le 2000$ | $-$ | $10$ |
| $3$ | $\le 10^5$ | $<2^{60}$ | $-$ | $60$ | 

特殊性质 $A$： $\operatorname{popcount}(m)\le 5\ $，$\operatorname{popcount}(m)$ 表示 $m$ 的二进制表示中 $1$ 的个数。

对于 $100\%$ 的数据保证 $1\le n\le 10^5$，$0\le m<2^{60}$。

**特别提醒：本题使用 subtask 捆绑测试，只有通过一个子任务的全部测试点才能获得此子任务的分数。**


## 样例 #1

### 输入

```
3 5```

### 输出

```
13```

## 样例 #2

### 输入

```
12 7```

### 输出

```
48643```

# 题解

## 作者：_abcd_ (赞：5)

~~切的最快的一个，感觉比 $A$ 简单。~~

题目看起来就很线性基。我们先统计有多少种典型基能凑出 $m$。由于统计的是典型基的数量，因此不需要去重，且一定是全选。考虑对 $m$ 的二进制位逐位 $dp$，每次进行的操作是选择是否插入一个最高位为 $i$ 的典型基，并确定之前插入的典型基第 $i$ 位的值。

具体来说，假设 $m$ 的第 $i$ 位是 $1$，那么要么插入一个最高位为 $i$ 的典型基，要么将之前插入的典型基中选奇数个，将他们的第 $i$ 位赋为 $1$。设 $f_{i,j}$ 表示 $dp$ 到第 $i$ 位，已经插入了 $j$ 个典型基的方案数，则转移方程就是 $f_{i,j} = f_{i+1,j-1} + 2^{j-1} f_{i+1,j}$。如果 $m$ 的第 $i$ 位是 $0$，则只能在之前的典型基中选择偶数个，将他们的第 $i$ 位赋值为 $1$，转移方程是 $f_{i,j} = 2^{j-1} f_{i+1,j}$。注意特判 $j=0$ 的情况。

现在我们已经确定了典型基，还要做的就是根据典型基确定原序列。假设典型基的大小为 $S$，一个简单的想法就是，在这个典型基能凑出的 $2^S$ 个数中可重复的选出 $n$ 个，即 $\binom{2^S + n - 1}{n}$ 种方案，但是这样是不行的。因为选出的 $n$ 个数构成的典型基可能只是这个典型基的一个子基。那么只需要去掉这些序列就行了。设 $g_i$ 表示大小为 $i$ 的典型基能构成多少种序列，则枚举 $j$，表示选择一个大小为 $j$ 的子基，然后减去他能构成的序列即可。

现在问题就是求出大小为 $n$ 的子集有多少个大小为 $m$ 的子基。设这个答案为 $h_{n,m}$，不难发现，你从小往大考虑，每次考虑第 $i$ 小的典型基是否需要被删除，如果不被删除，则他可以异或上前面任意多个被删除的基。也就是说，转移方程为 $h_{i,j} = h_{i-1,j} + 2^{i-j} h_{i-1,j-1}$。而 $g_i = \binom{2^S + n - 1}{n} - \sum\limits_{j=0}^{i-1} h_{i,j} g_j$。最后输出 $\sum\limits_{i=0}^{60} f_{0,i} g_i$ 即可，复杂度 $O(60n)$，瓶颈在于算 $\binom{2^S + n - 1}{n}$。

---

### Code:
```cpp
#include<bits/stdc++.h>
#define ll long long
#define pn putchar('\n')
#define mclear(a) memset(a,0,sizeof a)
#define fls() fflush(stdout)
#define maxn 100005
#define int ll
#define mod 998244353
using namespace std;
int re()
{
    int x=0;
    bool t=1;
    char ch=getchar();
    while(ch>'9'||ch<'0')
        t=ch=='-'?0:t,ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return t?x:-x;
}
int n,m,ans;
int f[70][70],g[70],h[70][70],mi[70];
int ksm(int x,int y)
{
    int ret=1;
    while(y)
    {
        if(y&1)ret=ret*x%mod;
        x=x*x%mod,y>>=1;
    }
    return ret;
}
namespace ZH
{
    int jc[maxn],inv[maxn];
    void zh_init()
    {
        jc[0]=1;
        for(int i=1;i<=n;i++)
            jc[i]=jc[i-1]*i%mod;
        inv[n]=ksm(jc[n],mod-2);
        for(int i=n;i;i--)
            inv[i-1]=inv[i]*i%mod;
    }
    int A(int x,int y)
    {
        if(x<y)return 0;
        return jc[x]*inv[x-y]%mod;
    }
    int C(int x,int y)
    {
        return A(x,y)*inv[y]%mod;
    }
}
using namespace ZH;
int fu(int x)
{
    return x&1?-1:1;
}
signed main()
{
    n=re(),m=re();
    zh_init();
    mi[0]=1;
    for(int i=1;i<=60;i++)
        mi[i]=mi[i-1]*2%mod;
    f[60][0]=1;
    for(int i=59;~i;i--)
    {
        if(m>>i&1)
        {
            for(int j=1;j<=60;j++)
                f[i][j]=(f[i+1][j-1]+mi[j-1]*f[i+1][j])%mod;
        }
        else
        {
            f[i][0]=f[i+1][0];
            for(int j=1;j<=60;j++)
                f[i][j]=mi[j-1]*f[i+1][j]%mod;
        }
    }
    for(int i=0;i<=60;i++)
    {
        int x=1;
        for(int j=1;j<=n;j++)
            x=(mi[i]+n-j)%mod*x%mod;
        g[i]=x*inv[n]%mod;
    }
    h[0][0]=1;
    for(int i=1;i<=60;i++)
    {
        h[i][0]=1;
        for(int j=1;j<=i;j++)
            h[i][j]=(h[i-1][j-1]+mi[j]*h[i-1][j])%mod;
    }
    for(int i=0;i<=60;i++)
    {
        for(int j=1;j<=i;j++)
            (g[i]-=h[i][j]*g[i-j])%=mod;
        (ans+=g[i]*f[0][i])%=mod;
    }
    if(ans<0)
        ans+=mod;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：yywlp (赞：3)

## 题解

一句话总结：利用线性基的性质 dp 再 dp。

我们设 $dp_{i,j,k}(j=0,1)$ 表示当前的线性基有 $k$ 个元素并且以某种方法异或起来匹配了 $m$ 二进制分解后的前 $i$ 位且**不能更大**，并且第 $i+1$ 位为 $j$ 的方案数。

**注意：这里的线性基规定每个最高位最多只能有一个数**。

有了状态定义转移方程应该不难想：

假设现在枚举到第 $i$ 位，可能会有两种情况：

- $m$ 的下一位上为 $0$：

这时会发现下一位的线性基上**不能有数**，否则只要再选上这个数就一定比 $m$ 要大了，并且前面的元素异或起来这一位上也需要是 $0$，否则就已经比 $m$ 要大了，不合法。可以得到 dp 式子： 

$$dp_{i+1,0,k}=dp_{i+1,1,k}=\frac{dp_{i,0,k}}{2}$$

- $m$ 的下一位上为 $1$：

这时会发现要能匹配上 $m$ 有两种方案：

- 前面的元素异或起来下一位是 $1$。

- 前面的元素异或起来下一位是 $0$，但下一位线性基上有值，利用线性基下一位的数使下一位变为 $1$。

先考虑第一种，可以发现无论下一位线性基上**有没有数**都是可以满足的（因为本来就为 $1$ 不管怎样都不会选这个）所以可以得到 dp 式子：

$$dp_{i+1,0,k}=dp_{i+1,1,k}=\frac{dp_{i,1,k}}{2} (没数)$$

$$dp_{i+1,0,k+1}=dp_{i+1,1,k+1}=\frac{dp_{i,1,k}}{2} (有数)$$

第二种就很简单了，这一位上**一定**要有值，直接转移就行：

$$dp_{i+1,0,k+1}=dp_{i+1,1,k+1}=\frac{dp_{i,0,k}}{2}$$

到这里可能会有个疑问：为什么 $dp_{i,0,k}=dp_{i,1,k}$？

可以这样考虑：现在确定了线性基中每个数的前 $i$ 位，但从 $i+1$ 位开始是没有限制的，所以每个数在第 $i+1$ 位以及后面的位置上实际上包含了所有情况（也就是每一位都可能是 $0$ 或 $1$），那么我们在第 $i+1$ 把后面的数**分成两半**，一半是 $1$ 开头的，一半是 $0$ 开头的，刚好满足我们的定义。

那么 dp 完之后会有很多**组成的线性空间相同**的线性基，（我们叫他本质相同的线性基），需要去重。我们定义**一个有 $k$ 个元素的线性基为 $k$ 元线性基**，那么对于一个 $k$ 元线性基，最高位有 $2^{k-1}$ 种取法使所形成的线性基本质相同（因为除了自己后面还有 $k-1$ 个元素，在这 $k-1$ 个位置无论第一个数取什么都可以通过对应位置上的数把它变成同一个数），第二位则是 $2^{k-2}$ 种，以此类推，那么总共就有 $2^{k-1} \times 2^{k-2} \dots\times 2^1 \times  2^0$ 种**本质相同的线性基**。

那么设 $d1_i$ 表示有多少个本质不同的 $i$ 元线性基满足组成的最大的数为 $m$，不难发现:

$$d1_i=\frac{dp_{len,0,i}+dp_{len,1,i}}{2^{i-1} \times 2^{i-2} \dots 2^0}$$

然后考虑怎么用 $d1$ 去求答案。

既然知道有多少个 $i$ 元线性基，那么我们只需要知道一个 $i$ 元线性基能变化成多少个大小为 $n$ 的可重集即可。

这里还是可以 dp。

我们设 $f_{i,j}$ 表示选了 $i$ 个**不同的数**并且组成的线性基有 $j$ 个元素的方案数，注意：这里 $(3,2,1)$ 和 $(1,2,3)$ 算**不同方案**，最后再去重，否则这里不好转移。

那么我们可以先枚举这个线性基**将会有的总元素个数**，设为 $k$，然后假设现在枚举到了第 $i$ 个数，在选择下一个数时就有两种可能：

- 使线性基增加新的元素。

- 不使线性基增加新的元素。

先考虑第一种，增加新的元素也就是说新加进来的数**不能用前面的线性基表示**，也就是 （总的空间大小 $-$ 前面线性基形成的空间大小），也就是 $2^k - 2^j$，dp 式子显而易见：

$$f_{i+1,j+1}+=f_{i,j}\times(2^k - 2^j)$$

第二种情况则与第一种情况相反，一定要选**可以用线性基表示出来的**，这个很明显是 $2^j$，但是不要忘了，这里面的元素需要互不相同，所以还要 $-i$，dp 式子也很简单：

$$f_{i+1,j}+=f_{i,j}\times(2^j-i)$$

这里要判断一下，如果 $2^j-i\le0$ 就不要加了。

剩下的就是把重复的数字加进去，很经典的组合数学。

对于每一个 $k$，我们设 $d2_k$ 表示 $k$ 个元素的线性基能构成多少种长为 $n$ 的可重集，那么 

$$d2_k = {\sum_{i=1}^{n}}\frac{f_{i,k}}{i!} \times \binom{n-1}{i-1} $$

稍微解释一下，$dp_{i,k}$ 得到的方案数是**区分顺序**的，但是要求的答案却是**不区分顺序**的，而这里 $i$ 个数互不相同，所以不区分顺序的方案数为 $\frac{f_{i,k}}{i!}$，那么我们现在只需要从这 $i$ 个数中选择，将其填充到 $n$ 个数。

经典的插板法，在 $n-1$ 个空隙中插入 $i-1$ 个板子，会形成 $i$ 段，每一段的长度就是第 $i$ 个数的个数。

接下来只需要统计答案，回顾一下前面求出的 $d1_k$，其意义为**有多少个本质不同的 $k$ 元线性基满足组成的最大的数为 $m$**，那结合 $d2_k$ 的意义 **$k$ 元线性基能构成多少种长为 $n$ 的可重集**，即可得到：

$$ans=\sum_{i=1}^{k}d1_i \times d2_i $$
这里的 $k$ 就是 $m$ 拥有的位数。

复杂度瓶颈在第二个 dp ，枚举大小一个 $\log m$ ， dp 本身是 $n\log m$ 的，所以总复杂度 $\Theta (n\log^2 m)$，勉强通过。

出题人刚出这道题时本想着能够**与 $n$ 无关**的，但是最后没有想到解法，只能做到这样。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=1e5+10,N=70,mod=998244353;
int n,K;
int f1[N][2][N],f2[M][N];
int d1[N],d2[N];
int w[N];
int maxn=0;
int p[N];
int tn;
int qpow(int x,int k){
	if(k<=60&&x==2)return p[k]%mod;
	if(k==0)return 1;
	if(k==1)return x;
	int r=qpow(x,k>>1);
	r=r*r%mod;
	if(k%2)r=r*x%mod;
	return r;
}
int jc[M];
int yc[M];
int C(int n,int m){
	return jc[n]*qpow(jc[n-m]*jc[m]%mod,mod-2)%mod;
}
signed main(){
	freopen("temp.in","r",stdin);
   freopen("temp.out","w",stdout);
	cin>>n>>K;
	if(K==0){
		cout<<1<<endl;
		return 0;
	}
	jc[0]=p[0]=1;
	for(int i=1;i<=n;i++)jc[i]=jc[i-1]*i%mod;
	for(int i=1;i<=62;i++)p[i]=p[i-1]*2%mod;
	tn=qpow(2,mod-2);
	int first=-1;
	for(int i=62;i>=0;i--){
		w[i]=(bool)((1ll<<i)&K);
		maxn+=w[i];
		if(first==-1){
			if(w[i]==1)first=i;
		}
	}
	maxn=min(maxn,n);
	f1[first][0][1]=qpow(2,first-1);
	f1[first][1][1]=qpow(2,first-1);
	for(int i=first-1;i>=0;i--){
		for(int j=1;j<=maxn;j++){
			if(!w[i]){
				f1[i][0][j]=(f1[i][0][j]+f1[i+1][0][j]*tn)%mod;
				f1[i][1][j]=f1[i][0][j];
			}else{
				f1[i][0][j]=(f1[i][0][j]+f1[i+1][0][j-1]*(i==0?tn:p[i-1])+f1[i+1][1][j-1]*(i==0?tn:p[i-1])+f1[i+1][1][j]*tn)%mod;
				f1[i][1][j]=f1[i][0][j];
			}
		}
	}
	for(int i=1;i<=maxn;i++){
		int k=(i-1)*i/2;
		d1[i]=(f1[0][0][i]+f1[0][1][i])*qpow(qpow(2,k),mod-2)%mod;
	}
	for(int i=0;i<=n;i++)yc[i]=C(n-1,i);
	for(int k=1;k<=maxn;k++){
		f2[1][1]=qpow(2,k)-1;
		f2[1][0]=1;
		d2[k]=(d2[k]+f2[1][k]*qpow(jc[1],mod-2))%mod;
		for(int i=2;i<=n;i++){
			for(int j=1;j<=k;j++){
				f2[i][j]=0;
				f2[i][j]=(f2[i-1][j-1]*(p[k]-p[j-1]+mod))%mod;
				if(p[j]-(i-1)>0)f2[i][j]=(f2[i][j]+f2[i-1][j]*(p[j]-(i-1)))%mod;
			}
			d2[k]=(d2[k]+f2[i][k]*qpow(jc[i],mod-2)%mod*yc[i-1])%mod;
		}
	}
	int ans=0;
	for(int i=1;i<=maxn;i++)ans=(ans+d2[i]*d1[i])%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：隔壁泞2的如心 (赞：3)

$\log_2m\le60 $。$\log_2m\le60 $。$\log_2m\le60 $。$\log_2m\le60 $。

此做法复杂度为 $O(n\log^2 n+\log m\log^2\log m)$。

我们可以先想着对于每个 $i\le n$ 求出所有长为 $i$、最大异或和为 $m$ 的序列个数。你可以直接去做 Many Xor Optimization Problems。考虑从第一位开始依次添加数字。每加进一个数就和当前的线性基比较。可能有两种结果。如果没能成功加进线性基。那么这个数就是可以被线性基表示出来的。这样这个数有 $2^s$ 种可能性。$s$ 为当前线性基大小。如果成功加入线性基。那么这种情况的方案数可以后算。因为上一种情况的方案数只和线性基里数的个数有关。而和这些数具体是什么无关。

将序列视为格路。成功加入线性基视为上移。加入失败视为右移。那么加入失败的总方案数。就是 $2^s$。$s$ 为此格路下的面积。显然是 $q-$ 二项式定理的形式。再设最终线性基里有 $l$ 个数。当把一个数插入线性基时。设这个数在线性基里对应的是第 $i$ 位。那么这个数比 $i$ 低的位全是任意的。比 $i$ 高的位里面。在线性基里有数的对应位是它的位是任意的。其他位都是固定的。那么假设线性基里存在的位已确定，构成这个线性基的数就有 $2^{a-l+b}$ 种。$a$ 是线性基内数的位数和。不是构成这个线性基的数的位数和。$b$ 是序列里成功插入线性基各位置对应的线性基位数的逆序对。最后由于异或最大值要等于 $m$。每个不在线性基里的位最终异或值是确定的。所以每个这样的位都会让答案乘上 $\frac{1}{2}$。另外线性基里所有的位。$m$ 也必须有。用分治乘可以对于每个 $l$ 计算出这些加入到了线性基里的数的方案数。然后再用 $q$ 数卷积即可。

然而我们要的是可重集。所以考虑对于每个 $i \le n$ 求出长为 $i$、最大异或和为 $m$ 的不重复序列个数。这东西求出来就可以很容易变成可重集了。设这个序列对应的生成函数为 $f(x)$，前两段算的可重序列对应的生成函数为 $g(x)$。显然有:

$$f(e^x-1)=g(x)$$

故：

$$f(x)=g(\ln(x+1))$$

这其实就是斯特林反演。你好。我不会复合 $\ln(x+1)$。但是现在有人会了。请搜索“多项式复合函数（加强版）”。

但是。

$\log_2m\le60 $。$\log_2m\le60 $。$\log_2m\le60 $。$\log_2m\le60 $。

啊啊啊啊啊啊啊啊——

---


# [NOI2024] 百万富翁

## 题目背景

**本题仅支持 C++ 语言评测。由于平台限制，使用 C++14 (GCC 9) 提交代码会导致 CE。请使用其他版本的 C++ 提交（推荐 C++14 及以上）。**

与 NOI 要求的提交格式不同，你的程序中**不应该**包含头文件 `richest.h`。同时，你的程序中应当在包含 `vector` 头文件的前提下，包含对以下函数的声明：

```cpp
std::vector<int> ask(std::vector<int> a, std::vector<int> b);
```

除此之外，其余要求与 NOI 要求一致。

## 题目描述

小 Y 的银行有 $N$ 个客户，编号为 $0$ 到 $N-1$。客户 $i$ 有 $W_i$ 元存款，且**客户之间的存款金额互不相同**。

小 P 是小 Y 的深度合作伙伴，他希望知道哪个客户的存款最多。小 P 无法直接获取客户的存款金额，但他可以依次发送若干次**请求**，每次请求包含若干个**查询**，每个查询是一个二元组 $(i,j)$，表示小 P 想知道客户 $i$ 和客户 $j$ 的存款金额哪个更多。如果 $W_i>W_j$，小 Y 会回答 $i$，否则回答 $j$。

小 P 的**请求数** $t$ 和所有请求的**查询**次数总和 $s$ 有上限，他希望你帮他写一个程序，来找到存款最多的客户。

## 说明/提示

**【下发文件说明】**

在本试题目录下：
- `grader.cpp` 是提供的交互库参考实现。
- `richest.h` 是头文件，选手不用关心具体内容。
- `template_richest.cpp` 是提供的示例代码，选手可在此代码的基础上实现。

选手注意对所有下发文件做好备份，最终评测时只测试本试题目录下的 `richest.cpp`，对该程序以外文件的修改不会影响评测结果。

**【数据范围】**

对于所有测试数据保证：所有 $W_i$ 两两不同。

本题共 $2$ 个测试点，每个测试点的分值和数据范围见下表。

::cute-table{tuack}

| 测试点编号 | 分值 | $N=$ | $T=$ | $S=$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $15$ | $1\,000$ | $1$ | $499\,500$ |
| $2$ | $85$ | $1\,000\,000$ | $20$ | $2\,000\,000$ |

**【评分方式】**

注意：
- 选手不应通过非法方式获取交互库的内部信息，如试图直接读取数组 $W$ 的值，或直接与标准输入、输出流进行交互。此类行为将被视为作弊。
- **最终的评测交互库与样例交互库的实现不同，且可能是适应性的：在不与 `ask` 此前返回的结果相矛盾的前提下，最终的评测交互库可能会动态调整 $W$ 的值。**

**本题首先会受到和传统相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制都会导致相应测试点得 0 分。选手只能在程序中访问自己定义的和交互库给出的变量或数据，及其相应的内存空间。尝试访问其他位置空间将可能导致编译错误或运行错误。

在每次 `richest` 函数调用中，程序使用的请求次数 $t$ 和所有请求的查询次数总和 $s$ 需在对应限制下，否则将会获得 $0$ 分。

在上述条件基础上：
- 在测试点 $1$ 中，程序得到满分当且仅当 `ask` 函数调用合法且 `richest` 函数返回的答案正确；
- 在测试点 $2$ 中，程序得到的分数将按照以下方式计算：
  - 若 `ask` 函数调用不合法，则获得 $0$ 分；
  - 若 `ask` 函数调用均合法，设 $\max t$ 表示多次调用 `richest` 函数所得的 $t$ 的最大值，$\max s$ 表示 $s$ 的最大值，则程序将获得 $\lfloor 85 \cdot f(\max t) \cdot g(\max s)\rfloor$ 分，其中 $f$ 与 $g$ 的计算方式如下表所示：

::cute-table{tuack}
  
| $\max t$ | $f(\max t)$ |
| :----------: | :----------: |
| $\max t\leq 8$ | $1$ |
| $9\leq \max t\leq 20$ | $1-\dfrac{1}{4}\sqrt{\max t-8}$ |

::cute-table{tuack}

| $\max s$ | $g(\max s)$ |
| :----------: | :----------: |
| $\max s\leq 1\,099\,944$ | $1$ |
| $1\,099\,945\leq \max s\leq 1\,100\,043$ | $1-\dfrac{1}{6} \log_{10} (\max s-1\,099\,943)$ |
| $1\,100\,044\leq \max s\leq 2\,000\,000$ | $\dfrac{2}{3}-\dfrac{1}{1\,500}\sqrt{\max s-1\,100\,043}$|

以下是测试点 $2$ 中，不同的 $t$ 和 $s$ 对得分影响的示例。

::cute-table{tuack}

| $\max t$ |            $\max s$            | 测试点 $2$ 的得分 |
| :------: | :----------------------------: | :---------------: |
|  $=20$   |       $\le 1\,099\,944$        |       $11$        |
|  $=19$   |       $\le 1\,099\,944$        |       $14$        |
|  $=18$   |       $\le 1\,099\,944$        |       $17$        |
|  $=17$   |       $\le 1\,099\,944$        |       $21$        |
|  $=16$   |       $\le 1\,099\,944$        |       $24$        |
|  $=15$   |       $\le 1\,099\,944$        |       $28$        |
|  $=14$   |       $\le 1\,099\,944$        |       $32$        |
|  $=13$   |       $\le 1\,099\,944$        |       $37$        |
|  $=12$   |       $\le 1\,099\,944$        |       $42$        |
|  $=11$   |       $\le 1\,099\,944$        |       $48$        |
|  $=10$   |       $\le 1\,099\,944$        |       $54$        |
|   $=9$   |       $\le 1\,099\,944$        |       $63$        |
| $\le 8$  | $\in [1\,099\,974,1\,099\,978]$ |       $63$        |
| $\le 8$  | $\in [1\,099\,969,1\,099\,973]$ |       $64$        |
| $\le 8$  | $\in [1\,099\,965,1\,099\,968]$ |       $65$        |
| $\le 8$  | $\in [1\,099\,962,1\,099\,964]$ |       $66$        |
| $\le 8$  | $\in [1\,099\,959,1\,099\,961]$ |       $67$        |
| $\le 8$  | $\in [1\,099\,957,1\,099\,958]$ |       $68$        |
| $\le 8$  | $\in [1\,099\,955,1\,099\,956]$ |       $69$        |
| $\le 8$  | $\in [1\,099\,953,1\,099\,954]$ |       $70$        |
| $\le 8$  |         $=1\,099\,952$          |       $71$        |
| $\le 8$  |         $=1\,099\,951$          |       $72$        |
| $\le 8$  | $\in [1\,099\,949,1\,099\,950]$ |       $73$        |
| $\le 8$  |         $=1\,099\,948$          |       $75$        |
| $\le 8$  |         $=1\,099\,947$          |       $76$        |
| $\le 8$  |         $=1\,099\,946$          |       $78$        |
| $\le 8$  |         $=1\,099\,945$          |       $80$        |
| $\le 8$  |       $\le 1\,099\,944$        |       $85$        |

# 题解

## 作者：pulsar_ (赞：27)

由于交互库是适应性的（~~至少题目是这样说的~~），我们要找出 $k$ 个人中存款金额最多的那一个，只能将 $k$ 个人两两询问，需要的询问数为 $\frac{k \times (k-1)}{2}$，不妨设 $f(x)=\frac{x \times (x-1)}{2}$。

对于测试点 1，可以发现 $499500 = f(1000)$，可以对每一组 $(i,j)$ 询问一次，就可以得出这一组最大值的编号。

对于测试点 2：

> 对于每一次询问，我们可以将存款金额最多的人的候选人人数减少，直到减少到只剩一个人，就可以得出答案。我们可以把每一次询问后剩下的候选人数量表示成一个序列 $l$。
> 
> 首先考虑如何进行询问：
>
> > 设询问前有 $a$ 个候选人，询问后有 $b$ 个候选人。
> >
> > 最佳策略是将 $a$ 个人分成 $b$ 组，每组 $\lfloor\frac{a}{b}\rfloor$ 或 $\lfloor\frac{a}{b}\rfloor+1$ 个人，需要的询问数就是：
> > $$g(a,b) = (b-(a \bmod b)) \times f(\lfloor\frac{a}{b}\rfloor)+(a \bmod b) \times f(\lfloor\frac{a}{b}\rfloor+1)$$
> >
> 则请求数 $t$ 为序列 $l$ 的长度减 $1$，所有请求的查询次数总和 $s$ 为 $\sum_{i=0}^{t}{g(l_i,l_{i+1})}$。
> 
> 要想拿到满分，就需要找到满足 $t \le 8 \text{, } s \le 1099944$ 的序列 $l$，这里提供模拟退火算法的 python 实现。

```python
import random


def f(x: int) -> int:
    return (x*(x-1))//2


def g(a: int, b: int) -> int:
    return (b-(a % b))*f(a//b)+(a % b)*f(a//b+1)


def get_val(l: list[int]) -> int:
    l = [1000000]+l+[1]  # 退火时不用考虑总人数 1000000 和剩下的人数 1
    res = 0
    for i in range(len(l)-1):
        res += g(l[i], l[i+1])
    return res


def get_valid(l: list[int]) -> bool:
    return all(i > 0 for i in l)  # 保证不出现 l 中有一项小于等于 0 的情况


def simulate() -> list[int]:
    while True:
        cur_l = [500000, 250000, 125000, 62500, 31250, 15625, 7812]  # 初始序列
        cur_l_val = get_val(cur_l)
        temp = 200000.0  # 初始温度
        dec = 0.999  # 降温速度
        while temp > 1:
            new_l = []
            for i in range(len(cur_l)):
                dis = round(temp/(2**i))  # 序列中越靠后的数字绝对值越小，需要的改动幅度就越小，所以除 2 的 i 次方
                new_l.append(cur_l[i]+random.randint(-dis, dis))
            if not get_valid(new_l):
                continue
            new_l_val = get_val(new_l)
            if new_l_val < cur_l_val:
                cur_l_val = new_l_val
                cur_l = new_l
            temp *= dec
        if cur_l_val <= 1099944:
            return cur_l


print(simulate())

```

> 这段代码的平均运行时间小于 10 秒，运行多次后得出了 7 组不同的满足要求的序列：

```
[1000000, 500000, 250000, 125000, 62496, 20832, 3472, 183, 1]
[1000000, 500000, 250000, 125000, 62497, 20832, 3472, 183, 1]
[1000000, 500000, 250000, 125000, 62498, 20832, 3472, 183, 1]
[1000000, 500000, 250000, 125000, 62499, 20832, 3472, 183, 1]
[1000000, 500000, 250000, 125000, 62499, 20833, 3472, 183, 1]
[1000000, 500000, 250000, 125000, 62500, 20832, 3472, 183, 1]
[1000000, 500000, 250000, 125000, 62500, 20833, 3472, 183, 1]
```

---

## 作者：_H17_ (赞：20)

## 题外话

CSP-J2 T2 都能挂分，T3 都能不会的蒟蒻来看 NOI 题凑热闹，还真搞出来个大概。

## 题目分析

### 子任务 $1$

对于任意两个数都在一次查询问完，注意 $(i,i)$ 这样不要出现，$(i,i-k)$ 也不要（重复），共 $\frac{n(n-1)}{2}$ 个数对。

后面都正常取最大即可。

### 子任务 $2$

~~理解错题半天，读错题了。~~

首先考虑用【子任务 $1$】部分的部分方法。一次全查完不可能，我们可以分次查。

不难想到分块的思想，可是每次分 $\sqrt n$ 块肯定 $s$ 会炸。

第一次 $k=\sqrt n$，就需要 $k\times\frac{k(k-1)}{2}=\frac{k^3-k^2}{2}$。又知道 $n=1000000,k=1000$，次数就是 $499500000$，第一次就炸了。

~~想到同学线段树偷懒大分块挂分~~，突然想到线段树。每次 只需要 $\frac{n}{2}$ 次的 $s$ 消耗，经过计算，大约需要 $2^{20}=1048576$ 次，其实用类似时间复杂度的表示，是线性的 $n\times (\sum_{i=1}^{+\inf} \frac{1}{2^i})=n$。

但是需要 $t= \log_2^n$ 次，大约是 $20$ 估计压着 $11$ 分的部分分。

显然，最后一次可以用暴力性的方法，根据程序测算大约 $t=13$，是 $37$ 分。

接下来我们发现，每次序列一定是要除掉一个数（类似线段树或者“分块树”（就是分块之后继续分，而不是只分一次））。

我们根据以上两个部分分发现，通过调整每次除去的数可以得到综合了 $t,s$ 的答案。

于是我们考虑 DFS 每一个除去的数，由于我们不可能一次满分，每次不符合标准的都可以剪枝掉，但是标准要低一些，不是满分（似乎也可以 DP，但是我没想、写）。

#### DFS 代码

```cpp
vector<int> vec,v; 
void dfs(int t,int s,int n){
	if(s<0)
		return;
	if(t>8){
		if(n>1)
			return;
		vec=v;
		for(auto p:vec)
			cout<<p<<' ';
		exit(0);
	}
	for(int i=2;i<=n;i++){
		v.push_back(i);
		dfs(t+1,s-(i*(i-1)/2)*(n/i)-((n%i)*((n%i)-1)/2),(bool)(n%i)+n/i);
		v.pop_back();
	}
}
signed main(){
	dfs(1,1100000,1000000);//放低标准
}
```

由于不是写题的程序，而是打表的，写的比较随意，请见谅。

跑出来之后是 `2 2 2 2 3 6 19 183`，也就是前四次按照线段树方式（就是每两个数一个块的“分块树”）。

然后我们在尽量小的对余数进行分块处理，甚至可以拆块（拆一些块，把余数均摊进去）。

但是经过计算（读者可以算一下不处理、直接暴力（这里指 $\frac{k(k-1)}{2}$ 次处理）处理余数的 $t,s$ 消耗），显然数变多了对后面不好。

于是我们考虑把余数均摊进前面的数中来。

前四次正常来；第五次先抽一个 $4$ 出来，剩下 $3$ 个一块（原因是余数是 $1$，把 $1$ 均摊进一个块中）；第六次抽 $7$ 个出来（同理）；第七次比较特殊，最后余数比较大（是 $14$，过半了），我们考虑把数量加一，即多加入一个 $19$，然后剩余的一个负数均摊为 $5$ 个 $-1$ 加进来（即很多 $19$ 加上五个 $18$）。

经过计算，符合题意（计算见【附表】）。

设 $f(x)$ 表示“暴力”处理 $x$ 个数的次数，即 $f(x)=\frac{x(x-1)}{2}$。

#### 附表

|$t$|$op$|$n$|$s$|
|:-:|:-:|:-:|:-:|
|$0$|$-$|$1000000$|$0$|
|$1$|$2$|$500000$|$500000$|
|$2$|$2$|$250000$|$750000$|
|$3$|$2$|$125000$|$875000$|
|$4$|$2$|$62500$|$937500$|
|$5$|$3$|$20833$|$937500+20832\times f(3)+f(4)=937500+62502=1000002$|
|$6$|$6$|$3472$|$1000002+3471\times f(6)+f(7)=1000002+52086=1052088$|
|$7$|$19$|$183$|$1052088+5\times f(18)+178\times f(19)=1083291$|
|$8$|$183$|$1$|$1083291+f(183)=1099944$|

这样我们就可以顺利拿到 $85$ 分。

## 代码

以下是我的 `richest.cpp`。

```cpp
#include<bits/stdc++.h>
#include"richest.h"
using namespace std;
vector<int>ask(vector<int>a,vector<int>b);//声明
vector<int>get_division(vector<int>v,vector<int>division){//根据序列划分
    static int sum,tot,lmax;
    static vector<int>ret,a,b,c;
    static map<pair<int,int>,int>mp;
    ret.clear();
    a.clear(),b.clear(),mp.clear();//附录1
    sum=tot=0;//附录2
    for(auto p:division){//当前p个一块
        for(int i=sum;i<sum+p;i++)
        	for(int j=i+1;j<sum+p;j++)
        		a.push_back(v[i]),b.push_back(v[j]),mp[{v[i],v[j]}]=tot++;//两两询问
        sum+=p;
    }
    c=ask(a,b);
    sum=0;
    for(auto p:division){
    	lmax=v[sum];
    	for(int i=sum+1;i<sum+p;i++)
    		lmax=c[mp[{lmax,v[i]}]];
    	ret.push_back(lmax);//取当前块最大值
    	sum+=p;
	}
    return ret;
}
void test(vector<int>k){
    for(auto t:k)
    	cerr<<t<<' ';
    cerr<<'\n';
}
int richest(int n,int t,int s){
    if(n==1000){
        vector<int>v;
        for(int i=0;i<n;i++)
            v.push_back(i);
        return get_division(v,vector<int>(1,1000))[0];//一次性搞完
    }
    static vector<int>k,divi;
    k.clear(),divi.clear();
    for(int i=0;i<n;i++)
        k.push_back(i);
    for(int i=0;i<500000;i++)//1
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<250000;i++)//2
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<125000;i++)//3
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<62500;i++)//4
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    divi.push_back(4);
    for(int i=0;i<20832;i++)//5
        divi.push_back(3);
    k=get_division(k,divi);
    divi.clear();
    divi.push_back(7);
    for(int i=0;i<3471;i++)//6
        divi.push_back(6);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<5;i++)//7
        divi.push_back(18);
    for(int i=0;i<178;i++)
        divi.push_back(19);
    k=get_division(k,divi);
    return get_division(k,vector<int>(1,183))[0];
}
```

`divi` 是划分序列每段的长度（和是当前序列长）。

## 附录

### 附录 $1$

`static` 让变量每次不重新创建，这样每次调用函数都不需要消耗整个 `vector` 的空间。

### 附录 $2$

`sum` 维护之前处理过的大小和，从而得到这次开始的下标。

## 附件内容

首先是头文件 `richest.h`（注释不是我写的）。

大致就是做好宏定义当标识，声明 `richest,ask` 函数，并引入 `vector`。

```cpp
#ifndef RICHEST_H
#define RICHEST_H

#include <vector>

int richest(int N, int T, int S);

std::vector<int> ask(std::vector<int> i, std::vector<int> j);

#endif // RICHEST_H
```

接着是 `grader.cpp` 的代码，是交互库。

按照题目中的标准输入输入即可。$R$ 通常可以乱输入一个数，最好不要超过 `int`。

```cpp
#include "richest.h"
#include <bits/stdc++.h>
using namespace std;
static int N, T, S, r, t, s;
static vector<int> W;
vector<int> ask(vector<int> i, vector<int> j) {
    ++t;
    if (t > T)
        throw string("Too many queries");
    if (i.size() != j.size())
        throw string("Invalid query: i and j must have the same size");
    int m = i.size();
    s += m;
    if (s > S)
        throw string("Too many total elements in queries");
    vector<int> res(m);
    for (int k = 0; k < m; k++) {
        if (i[k] < 0 || i[k] >= N || j[k] < 0 || j[k] >= N)
            throw string("Invalid query: index out of bounds");
        res[k] = W[i[k]] > W[j[k]] ? i[k] : j[k];
    }
    return res;
}

constexpr int Sub2_score = 85;

int main() {
    int R;
    cin >> N >> T >> S >> R;
    if (N <= 0 || T < 0 || S < 0 || R < 0) {
        cerr << "Invalid input for N, T, S or R" << endl;
        return 1;
    }
    mt19937_64 rng(R);
    W.resize(N);
    bool hasWrong = false;
    int maxt = 0, maxs = 0;
    for (int _ = 0; _ < 10; _++) {
        iota(W.begin(), W.end(), 0);
        shuffle(W.begin(), W.end(), rng);
        int answer = max_element(W.begin(), W.end()) - W.begin();
        try {
            r = -1; t = 0; s = 0;
            r = richest(N, T, S);
            if (r != answer)
                throw string("Wrong Answer");
            cout << r << ' ' << t << ' ' << s << " Correct (pretest)" << endl;
        } catch (const string& msg) {
            hasWrong = true;
            cout << r << ' ' << t << ' ' << s << ' ' << msg << endl;
        }
        maxt = max(maxt, t);
        maxs = max(maxs, s);
    }
    if (N == 1000 && T == 1 && S == 499500) {
        if (hasWrong) {
            cout << "Wrong Case 1, score: 0 / " << (100 - Sub2_score) << endl;
        } else {
            cout << "Correct (pretest) Case 1, score: " << (100 - Sub2_score) << " / " << (100 - Sub2_score) << endl;
        }
    } else if (N == 1000000 && T == 20 && S == 2000000) {
        if (hasWrong) {
            cout << "Wrong Case 2, score: 0 / " << Sub2_score << endl;
        } else {
            double ft = 1;
            if (maxt > 8)
                ft -= sqrt(maxt - 8) / 4;
            double gs = 1;
            if (maxs > 1099944) {
            	if (maxs < 1100044)
            		gs -= log10(maxs - 1099943) / 6;
            	else
            		gs -= 1.0 / 3 + pow(maxs - 1100043, 1.0 / 2) / 1500;
			}
            cout
                << (ft * gs >= 1 ? "Correct" : "Partially correct")
                << " (pretest) Case 2, score: "
                << to_string(int(Sub2_score * ft * gs))
                << " / " << Sub2_score;
        }
    } else {
        if (hasWrong) {
            cout << "Wrong" << endl;
        } else {
            cout << "Correct" << endl;
        }
    }
}
```

最后给出~~没啥用的~~ `template_richest.cpp`，是样例程序。

```cpp
#include "richest.h"

int richest(int N, int T, int S) {
    ask({0, 2}, {1, 3});
    ask({0, 2, 3}, {1, 1, 1});
    return 1;
}
```

## 如何自测？

**注意：以下内容不严谨。**

把所有 `#include "richest.h"` 替换为 `richest.h` 的代码（包括交互库的）。

然后把交互库、主程序放在一起运行即可。

例如给出的 `template_richest.cpp` 的测试代码是：

```cpp
//grader.cpp
#ifndef RICHEST_H
#define RICHEST_H

#include <vector>

int richest(int N, int T, int S);

std::vector<int> ask(std::vector<int> i, std::vector<int> j);

#endif // RICHEST_H
#include <bits/stdc++.h>
using namespace std;
static int N, T, S, r, t, s;
static vector<int> W;
vector<int> ask(vector<int> i, vector<int> j) {
    ++t;
    if (t > T)
        throw string("Too many queries");
    if (i.size() != j.size())
        throw string("Invalid query: i and j must have the same size");
    int m = i.size();
    s += m;
    if (s > S)
        throw string("Too many total elements in queries");
    vector<int> res(m);
    for (int k = 0; k < m; k++) {
        if (i[k] < 0 || i[k] >= N || j[k] < 0 || j[k] >= N)
            throw string("Invalid query: index out of bounds");
        res[k] = W[i[k]] > W[j[k]] ? i[k] : j[k];
    }
    return res;
}

constexpr int Sub2_score = 85;

int main() {
    int R;
    cin >> N >> T >> S >> R;
    if (N <= 0 || T < 0 || S < 0 || R < 0) {
        cerr << "Invalid input for N, T, S or R" << endl;
        return 1;
    }
    mt19937_64 rng(R);
    W.resize(N);
    bool hasWrong = false;
    int maxt = 0, maxs = 0;
    for (int _ = 0; _ < 10; _++) {
        iota(W.begin(), W.end(), 0);
        shuffle(W.begin(), W.end(), rng);
        int answer = max_element(W.begin(), W.end()) - W.begin();
        try {
            r = -1; t = 0; s = 0;
            r = richest(N, T, S);
            if (r != answer)
                throw string("Wrong Answer");
            cout << r << ' ' << t << ' ' << s << " Correct (pretest)" << endl;
        } catch (const string& msg) {
            hasWrong = true;
            cout << r << ' ' << t << ' ' << s << ' ' << msg << endl;
        }
        maxt = max(maxt, t);
        maxs = max(maxs, s);
    }
    if (N == 1000 && T == 1 && S == 499500) {
        if (hasWrong) {
            cout << "Wrong Case 1, score: 0 / " << (100 - Sub2_score) << endl;
        } else {
            cout << "Correct (pretest) Case 1, score: " << (100 - Sub2_score) << " / " << (100 - Sub2_score) << endl;
        }
    } else if (N == 1000000 && T == 20 && S == 2000000) {
        if (hasWrong) {
            cout << "Wrong Case 2, score: 0 / " << Sub2_score << endl;
        } else {
            double ft = 1;
            if (maxt > 8)
                ft -= sqrt(maxt - 8) / 4;
            double gs = 1;
            if (maxs > 1099944) {
            	if (maxs < 1100044)
            		gs -= log10(maxs - 1099943) / 6;
            	else
            		gs -= 1.0 / 3 + pow(maxs - 1100043, 1.0 / 2) / 1500;
			}
            cout
                << (ft * gs >= 1 ? "Correct" : "Partially correct")
                << " (pretest) Case 2, score: "
                << to_string(int(Sub2_score * ft * gs))
                << " / " << Sub2_score;
        }
    } else {
        if (hasWrong) {
            cout << "Wrong" << endl;
        } else {
            cout << "Correct" << endl;
        }
    }
}

//richest.cpp 
#ifndef RICHEST_H
#define RICHEST_H

#include <vector>

int richest(int N, int T, int S);

std::vector<int> ask(std::vector<int> i, std::vector<int> j);

#endif // RICHEST_H

int richest(int N, int T, int S) {
    ask({0, 2}, {1, 3});
    ask({0, 2, 3}, {1, 1, 1});
    return 1;
}
```

例如输入 `4 100 100 1` 得到的结果是：

```
1 2 5 Correct (pretest)
1 2 5 Wrong Answer
1 2 5 Wrong Answer
1 2 5 Wrong Answer
1 2 5 Correct (pretest)
1 2 5 Wrong Answer
1 2 5 Correct (pretest)
1 2 5 Correct (pretest)
1 2 5 Wrong Answer
1 2 5 Wrong Answer
Wrong
```

## 我的代码正确性验证

```cpp
//grader.cpp
#ifndef RICHEST_H
#define RICHEST_H

#include <vector>

int richest(int N, int T, int S);

std::vector<int> ask(std::vector<int> i, std::vector<int> j);

#endif // RICHEST_H
#include <bits/stdc++.h>
using namespace std;
static int N, T, S, r, t, s;
static vector<int> W;
vector<int> ask(vector<int> i, vector<int> j) {
    ++t;
    if (t > T)
        throw string("Too many queries");
    if (i.size() != j.size())
        throw string("Invalid query: i and j must have the same size");
    int m = i.size();
    s += m;
    if (s > S)
        throw string("Too many total elements in queries");
    vector<int> res(m);
    for (int k = 0; k < m; k++) {
        if (i[k] < 0 || i[k] >= N || j[k] < 0 || j[k] >= N)
            throw string("Invalid query: index out of bounds");
        res[k] = W[i[k]] > W[j[k]] ? i[k] : j[k];
    }
    return res;
}

constexpr int Sub2_score = 85;

int main() {
    int R;
    cin >> N >> T >> S >> R;
    if (N <= 0 || T < 0 || S < 0 || R < 0) {
        cerr << "Invalid input for N, T, S or R" << endl;
        return 1;
    }
    mt19937_64 rng(R);
    W.resize(N);
    bool hasWrong = false;
    int maxt = 0, maxs = 0;
    for (int _ = 0; _ < 10; _++) {
        iota(W.begin(), W.end(), 0);
        shuffle(W.begin(), W.end(), rng);
        int answer = max_element(W.begin(), W.end()) - W.begin();
        try {
            r = -1; t = 0; s = 0;
            r = richest(N, T, S);
            if (r != answer)
                throw string("Wrong Answer");
            cout << r << ' ' << t << ' ' << s << " Correct (pretest)" << endl;
        } catch (const string& msg) {
            hasWrong = true;
            cout << r << ' ' << t << ' ' << s << ' ' << msg << endl;
        }
        maxt = max(maxt, t);
        maxs = max(maxs, s);
    }
    if (N == 1000 && T == 1 && S == 499500) {
        if (hasWrong) {
            cout << "Wrong Case 1, score: 0 / " << (100 - Sub2_score) << endl;
        } else {
            cout << "Correct (pretest) Case 1, score: " << (100 - Sub2_score) << " / " << (100 - Sub2_score) << endl;
        }
    } else if (N == 1000000 && T == 20 && S == 2000000) {
        if (hasWrong) {
            cout << "Wrong Case 2, score: 0 / " << Sub2_score << endl;
        } else {
            double ft = 1;
            if (maxt > 8)
                ft -= sqrt(maxt - 8) / 4;
            double gs = 1;
            if (maxs > 1099944) {
            	if (maxs < 1100044)
            		gs -= log10(maxs - 1099943) / 6;
            	else
            		gs -= 1.0 / 3 + pow(maxs - 1100043, 1.0 / 2) / 1500;
			}
            cout
                << (ft * gs >= 1 ? "Correct" : "Partially correct")
                << " (pretest) Case 2, score: "
                << to_string(int(Sub2_score * ft * gs))
                << " / " << Sub2_score;
        }
    } else {
        if (hasWrong) {
            cout << "Wrong" << endl;
        } else {
            cout << "Correct" << endl;
        }
    }
}
//richest.cpp
#ifndef RICHEST_H
#define RICHEST_H

#include <vector>

int richest(int N, int T, int S);

std::vector<int> ask(std::vector<int> i, std::vector<int> j);

#endif // RICHEST_H
#include<bits/stdc++.h>
using namespace std;
vector<int>ask(vector<int>a,vector<int>b);
vector<int>get_division(vector<int>v,vector<int>division){
    static int sum,tot,lmax;
    static vector<int>ret,a,b,c;
    static map<pair<int,int>,int>mp;
    ret.clear();
    a.clear(),b.clear(),mp.clear();
    sum=tot=0;
    for(auto p:division){
        for(int i=sum;i<sum+p;i++)
        	for(int j=i+1;j<sum+p;j++)
        		a.push_back(v[i]),b.push_back(v[j]),mp[{v[i],v[j]}]=tot++;
        sum+=p;
    }
    c=ask(a,b);
    sum=0;
    for(auto p:division){
    	lmax=v[sum];
    	for(int i=sum+1;i<sum+p;i++)
    		lmax=c[mp[{lmax,v[i]}]];
    	ret.push_back(lmax);
    	sum+=p;
	}
    return ret;
}
void test(vector<int>k){
    for(auto t:k)
    	cerr<<t<<' ';
    cerr<<'\n';
}
int richest(int n,int t,int s){
    if(n==1000){
        vector<int>v;
        for(int i=0;i<n;i++)
            v.push_back(i);
        return get_division(v,vector<int>(1,1000))[0];
    }
    static vector<int>k,divi;
    k.clear(),divi.clear();
    for(int i=0;i<n;i++)
        k.push_back(i);
    for(int i=0;i<500000;i++)//1
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<250000;i++)//2
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<125000;i++)//3
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<62500;i++)//4
        divi.push_back(2);
    k=get_division(k,divi);
    divi.clear();
    divi.push_back(4);
    for(int i=0;i<20832;i++)//5
        divi.push_back(3);
    k=get_division(k,divi);
    divi.clear();
    divi.push_back(7);
    for(int i=0;i<3471;i++)//6
        divi.push_back(6);
    k=get_division(k,divi);
    divi.clear();
    for(int i=0;i<5;i++)//7
        divi.push_back(18);
    for(int i=0;i<178;i++)
        divi.push_back(19);
    k=get_division(k,divi);
    return get_division(k,vector<int>(1,183))[0];
}
```

输入 #1：

```
1000 1 499500 1
```

输出 #1：

```
419 1 499500 Correct (pretest)
751 1 499500 Correct (pretest)
901 1 499500 Correct (pretest)
246 1 499500 Correct (pretest)
449 1 499500 Correct (pretest)
896 1 499500 Correct (pretest)
43 1 499500 Correct (pretest)
92 1 499500 Correct (pretest)
913 1 499500 Correct (pretest)
886 1 499500 Correct (pretest)
Correct (pretest) Case 1, score: 15 / 15
```

输入 #2：

```
1000000 20 2000000 1
```

输出 #2：

```
885942 8 1099944 Correct (pretest)
796018 8 1099944 Correct (pretest)
727483 8 1099944 Correct (pretest)
291388 8 1099944 Correct (pretest)
392425 8 1099944 Correct (pretest)
667129 8 1099944 Correct (pretest)
11164 8 1099944 Correct (pretest)
781119 8 1099944 Correct (pretest)
45059 8 1099944 Correct (pretest)
892089 8 1099944 Correct (pretest)
Correct (pretest) Case 2, score: 85 / 85
```

这里 $R$ 只是取了 $1$，正确性证明在【必读】部分。

另外：#2 可以输入 `1000000 8 1099944 1`。

---

## 作者：nullqtr_pwp (赞：15)

别的题解直接构造太抽象了，为什么不是 dp 出最优解啊。

测试点 $1$ 显然就是 $1000$ 个点之间两两连边，这样出度为 $N-1$ 的点一定就是最大值（定义 $u\to v$ 为 $a_u>a_v$，边的方向由交互库决定）

一个显然的结论是，如果想要立刻，即 $t=1$ 的找出一组数中的最大值，必须使用两两连成完全图的方式。

注意到 $s=1099944$ 是一个很死的限制，我们可以直接考虑在 $t$ 给定的情况下**最优化**询问组数。这时不应该去直接构造，因为这样很难调整出底层的最优解，可以考虑动态规划出解。

令 $f_{n,k}$ 为 $t=k$ 时，$n$ 个点询问出最大值，最少需要多少次询问。我们考虑在这一层中，将 $n$ 个点划分成 $p$ 组，我们在第 $t$ 层中要干的事情就是要将 $n$ 个点中找出最大值，变为 $p$ 个点中找出最大值。


转移即为：

$$f_{n,k}=\min_{p=1}^n \lbrace f_{p,k-1}+\text{cost}(n,p)\rbrace$$


其中 $\text{cost}(n,p)$ 代表立刻从 $n$ 个点中缩减为 $p$ 个点的最小询问次数。


那么本层所需要的代价，就是考虑每组的点数为 $b_1,b_2,\cdots,b_p,\sum b_i=n$，此时的代价为 $\sum\dfrac{b_i(b_i-1)}{2}$。这是一个二次项，由基础的不等式知识可以得到，$b_i$ 一定满足尽量均分，并且极差 $\leq 1$，否则可以调整极差 $>1$ 的一组得到更优的询问次数。此时下一层的代价可以动态规划求出，就是 $f_{p,t-1}$。

换而言之，下一层 $b_i$ 应该满足，有 $n\bmod p$ 个等于 $\lfloor \dfrac{n}{p}\rfloor+1$；有 $p-(n\bmod p)$ 个等于 $\lfloor \dfrac{n}{p}\rfloor$。那么我们可以 $O(1)$ 计算本层所需的代价。

事实上，这是一道提交答案题，我们可以将**本地**找出的最优解决方案直接填进答案文件。但是这里仍然介绍找出最优解的更优复杂度代码。


考虑现在的复杂度是 $O(Tn^2)$，那么考虑到 $p$ 的 $\text{cost}$ 与 $\lfloor\dfrac{n}{p}\rfloor$ 有关，那么我们可以考虑整除分块。对于 $\lfloor\dfrac{n}{p}\rfloor$，考虑使得其值相同的 $p$ 的区间是 $[l,r]$，由基础的整除分块知识，这样的 $[l,r]$ 只有 $O(\sqrt n)$ 段，我们**断言**有用的 $p$ 只有所有的 $l$ 和所有的 $r$。这样可以保证 $\text{cost}$ 取在两个极端上。

事实证明这是对的，因为可以搜出来 $s=1099944$ 的解。我们可以猜测前四次都是两两分组，将 $n$ 降到 $125000$，本地跑出解的复杂度上界是 $O(Tn\sqrt n)$。

**【寻找最优解代码】**

```cpp

ll f[maxn][10],a[maxn];
int lst[maxn][10];
ll dfs(int n,int k){
	if(f[n][k])return f[n][k];
	if(k==1)return a[n];
	vector<int>vec;
	for(int l=1,r=0;l<=n;l=r+1){
		r=n/(n/l);
		if(l>1)vec.pb(l);
		if(l^r)vec.pb(r);
	}
	f[n][k]=infll;
	for(int x:vec){
		if(x==1)continue;
		ll val=0;
		int p=n/x,q=n%x,p1=p+1;
		val+=1ll*q*a[p1];
		val+=1ll*(x-q)*a[p];
		val+=dfs(x,k-1);
		if(val<f[n][k])f[n][k]=val,lst[n][k]=x;
	}return f[n][k];
}
signed main(){
	F(i,1,maxn-3)a[i]=(1ll*i*(i-1))>>1;
	cout<<dfs(1000000,8)<<endl;
	int u=8,n=1000000;
	for(;u>0;--u){
		cout<<u<<' '<<n<<endl;
		n=lst[n][u];
	}
}
```


**【最优解序列】**

```
8 1000000
7 500000
6 250000
5 125000
4 62500
3 20833
2 3472
1 183
```

第二个数代表每次求出的 $p$。

**【答案代码】**


```cpp
// 私は猫です

#include"richest.h"
#include<bits/stdc++.h>
#define ull unsigned long long
#define ll long long
#define pb push_back
#define mkp make_pair
#define fi first
#define se second
#define inf 1000000000
#define infll 1000000000000000000ll
#define pii pair<int,int>
#define rep(i,a,b,c) for(int i=(a);i<=(b);i+=(c))
#define per(i,a,b,c) for(int i=(a);i>=(b);i-=(c))
#define F(i,a,b) for(int i=(a);i<=(b);i++)
#define dF(i,a,b) for(int i=(a);i>=(b);i--)
#define cmh(sjy) while(sjy--)
#define lowbit(x) (x&(-x))
#define HH printf("\n")
#define eb emplace_back
#define poly vector<int>
using namespace std;
const int maxn=1000005;
int cnt[maxn];
int getmax(vector<int>vec){
	vector<int>A,B;
	int siz=vec.size();
	if(siz==1)return vec[0];
	F(i,0,siz-2)F(j,i+1,siz-1)A.push_back(vec[i]),B.push_back(vec[j]);
	vector<int>res=ask(A,B);
	for(int i:res)++cnt[i];
	int rt=0;
	for(int i:vec)if(cnt[i]==siz-1)rt=i;
	for(int i:res)--cnt[i];
	return rt;
}
vector<int>qa,qb;
array<int,3>pushquery(vector<int>vec){
	const int siz=vec.size(),l=qa.size();
	F(i,0,siz-2)F(j,i+1,siz-1)qa.push_back(vec[i]),qb.push_back(vec[j]);
	const int r=qa.size()-1;
	return {l,r,siz};
}
vector<int>getnxt(vector<int>vec,int nxt){
	qa.clear(),qb.clear();
	const int n=vec.size();
	vector<int>res;
	const int p=n/nxt,p1=p+1,q=(nxt-n%nxt),q1=n%nxt;
	int c0=0,c1=0,ord=0,st=0;
	vector<int>qu;
	vector<array<int,5>>qwq;
	F(i,0,n-1){
		++ord,qu.push_back(vec[i]);
		if(ord==p&&c0<q){
			array<int,3>tmp=pushquery(qu);
			++c0,ord=0,qwq.push_back({tmp[0],tmp[1],tmp[2],st,i});
			qu.clear();
			st=i+1;
		}
		if(ord==p1&&c1<q1){
			array<int,3>tmp=pushquery(qu);
			++c1,ord=0,qwq.push_back({tmp[0],tmp[1],tmp[2],st,i});
			qu.clear();
			st=i+1;
		}
	}
	vector<int>qres=ask(qa,qb);
	for(auto [l,r,siz,st,ed]:qwq){
		F(i,l,r)++cnt[qres[i]];
		F(i,st,ed)if(cnt[vec[i]]==siz-1)res.push_back(vec[i]);
		F(i,l,r)--cnt[qres[i]];
	}
	return res;
}
int richest(int N, int T, int S){
	vector<int>vec;
	F(i,0,N-1)vec.push_back(i);
	if(N==1000)return getmax(vec);
	vec=getnxt(vec,500000);
	vec=getnxt(vec,250000);
	vec=getnxt(vec,125000);
	vec=getnxt(vec,62500);
	vec=getnxt(vec,20833);
	vec=getnxt(vec,3472);
	vec=getnxt(vec,183);
	return getmax(vec);
}
// g++ grader.cpp richest.cpp -o a -O2 -std=c++14 -static
```

已经在 QOJ 上测试通过。

---

## 作者：zyn_ (赞：8)

场外围观者来写一下 NOI 2024 D1T2 的题解。

话说为什么 D1T2 出交互题？~~为了让选手心态崩溃吗？~~

## 题目大意

一个长为 $N$ 的数组 $W_i$，你可以发起 **$T$ 组共不超过 $S$ 个询问**，形如 $W_i$ 与 $W_j$ 哪个更大。求出最大数。（原题面中的**请求**就是**一组询问**，下同）

## 测试点 $1$

询问**组数**只有 $1$，但**个数**有 $\dfrac{N(N-1)}{2}$，那么对任意 $1\le i\lt j\le N$ 做 $(i,j)$ 询问即可。比 $N-1$ 个数大的那个数就是最大数。

## 测试点 $2$

### 思路

$N=1000000$。直接看满分条件：$t\le 8$，$s\le 1099944$。

如果没有 $T$ 的限制，那么询问 $N-1$ 次就能得到最大数。

有了询问**组数**的限制后，应当确定一个思路：每组询问将**可能的最大数集合** $S$ **缩小**。初始 $S=\{1,2,\dots,N\}$，目标是在 $8$ 组询问后**将 $|S|$ 缩小至 $1$**。

由于交互库自适应，只有将一个集合中的数**两两做询问**，才能在**一组询问**中确定这个集合的最大数。

如果**一组询问中**希望将 $S$ 的大小除以 $2$，那么应当将 $S$ 分为 $\dfrac{|S|}{2}$ 组（关于可能的 $2\nmid|S|$ 情况暂不详细讨论），每组 $2$ 个数，之间做 $1$ 个询问。一共做 $\dfrac{|S|}{2}$ **个**询问。

类似地，如果希望将 $S$ 的大小除以 $k$，那么应当将 $S$ 分为 $\dfrac{|S|}{k}$ 组（关于可能的 $k\nmid|S|$ 情况也暂不讨论），每组 $k$ 个数，之间做 $\dfrac{k(k-1)}{2}$ 个询问。一共做 $\dfrac{|S|(k-1)}{2}$ 个询问。

可以将询问的**个数**当作**一组询问的代价**，那么为了让 $|S|$ 缩小更多，代价就更大。本题就是要在询问组数与代价之间**做出平衡**。

### 求一个较好的代价与方案

注意到 $1099944$ 略大于 $N=10^6$，因此每次当然可以大胆地让 $|S|$ 除以 $2$，这样总询问次数为 $\dfrac{|S|}{2}+\dfrac{|S|}{4}+\dfrac{|S|}{8}+\dots$，在 $|S|$ 也就是 $N$ 左右。当然这是远远不够的。

手玩可以发现，前几组询问只能使 $|S|$ 除以 $2$；当 $|S|$ 缩小到 $10^4$ 级别时，多出的 $99944$ 个询问，就允许将 $|S|$ 除以更大的数（例如 $3,4,5,6$）；并且，$|S|$ 大幅下降后，接下来每组询问的代价也会下降。

考虑设计 DP 求最小代价。采用倒推，设 $dp_{i,j}$ 表示**剩余 $j$ 次询问**，$|S|=i$ 时，将 $|S|$ 缩小为 $1$ 的代价（**其实这时不一定是最小代价，只是一种可行代价，让它尽量小**）。

初始 $dp_{i,1}=\dfrac{i(i-1)}{2}$。

枚举 $j=2,\dots,8$，枚举 $i$，再枚举 $k$ 表示希望让 $|S|$ 除以 $k$。此时钦定 $dp_{i,j}$ 从 $dp_{i',j-1}$ 转移，其中 $i'=\lceil\dfrac{i}{k}\rceil$。转移方程为 $dp_{i,j}=\min\{dp_{i,j},dp_{i',j-1}+\operatorname{calc}(i,k)\}$，其中 $\operatorname{calc}(i,k)$ 表示将 $S$ 分为 $i'=\lceil\dfrac{i}{k}\rceil$ 组，**每组之间两两询问**所需代价。

时间复杂度是 $O(N^2)$（因为 $i,k$ 均为从 $1$ 到 $N$）。其实可以优化，后面再说。

计算 $\operatorname{calc}(i,k)$ 时，设 $i=qk+r$，$0\le r\lt k$。

若 $r=0$ 则就是将 $S$ 的 $i$ 个元素分成 $q$ 组，一组 $k$ 个，代价 $\dfrac{qk(k-1)}{2}$。

若 $r\neq 0$，则 $i'=q+1$。考虑假想有 $i'$ 组，每组 $k$ 个数，则共有 $i'k=(q+1)k$ 个数，代价 $\dfrac{(q+1)k(k-1)}{2}$。但这样多了 $k-r$ 个数。若 $i'\ge k-r$，则从 $k-r$ 组中去除一个数即可，代价减少了 $(k-r)(k-1)$（因为每个多余的数和组内其余 $k-1$ 个数均不用询问了）。

若 $i'\lt k-r$ 怎么办？事实上，根本不需要担心，因为这种情况**可以忽略**。

手玩时还可以发现，第 $7$ 组询问之前，$|S|$ 很难下降到 $1000$ 及以下，那么第 $7$ 次询问的目标是将 $|S|$ 除以 $k_7$，$k_7$ 不会太大，一般 $k_7\le 30$。

于是，$i'\ge\dfrac{i}{k}=\dfrac{|S|}{k_7}\gt 33\gt k_7=k\gt k-r$。

实现时就是在 DP 中枚举 $i=1001,1002,\dots,N$，$j=2,3,\dots,30$。时间复杂度的问题也解决了，变成了 $O(N)$（常数巨大）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000000
#define INF 0x3f3f3f3f3f3f3fll
#define ll long long
ll dp[N+1][10],pre[N+1][10],v;
inline ll calc(ll n,ll k){
	static ll q,r;q=n/k,r=n%k;
	if(r==0)return q*(k*(k-1)/2);
	if(q+1>=k-r)return (q+1)*(k*(k-1)/2)-(k-r)*(k-1);
	return 0;
}
int main(){
	for(ll i=1;i<=N;++i)dp[i][1]=i*(i-1)/2;
	for(ll i=2;i<=8;++i){
		for(int j=1;j<=N;++j)dp[j][i]=INF;
		for(ll j=1001;j<=N;++j){
			for(ll k=2;k<=30;++k){
				v=dp[(j-1)/k+1][i-1]+calc(j,k);
				if(v<dp[j][i])dp[j][i]=v,pre[j][i]=k;
			}
		}
	}
	printf("%lld\n",dp[N][8]);
	int pos=N;
	for(int i=8;i>=2;--i){
		printf("%d %lld (%lld)\n",pos,pre[pos][i],calc(pos,pre[pos][i]));
		pos=(pos-1)/pre[pos][i]+1;
	}
	printf("%d %d (%lld)\n",pos,pos,pos*(pos-1)/2);
	return 0;
}
```

### 优化方案

看一下 DP 的输出：

```text
1099947
1000000 2 (500000)
500000 2 (250000)
250000 2 (125000)
125000 2 (62500)
62500 3 (62498)
20834 6 (52075)
3473 19 (31221)
183 183 (16653)
```

第一行是 $8$ 组询问的代价和，后面每一行为 $i,k,c$，代表 $S$ 集合的大小原本是 $i$，这组询问后它的大小除以了 $k$（上取整），代价为 $c$。

现在的总代价是 $1099947$，与目标 $1099944$ 只差了 $3$，接近正解了！

考察一下每组询问对 $|S|$ 的分法：

前四组，$|S|$ 除以了 $2$，分组时没有出现多余，不好优化。

第五组询问时，分法为 $62500=20832\times 3+2\times 2$。

第六组询问时，分法为 $20834=3469\times 6+4\times 5$。

第七组询问时，分法为 $3473=179\times 19+4\times 18$。

第八组询问只分了一组 $183=1\times 183$。

将第五组询问的 $2\times 2$ 合并为一组 $4$，代价增加了 $6-1-1=4$。

然而这样**第六组询问时 $|S|$ 减少了 $1$**，变为 $20833$。

将 $20833$ 分为 $3471\times 6+1\times 7$。这样的代价是 $52086$，比原来的 $52075$ 增加了 $11$。

但是这样**第七组询问的 $|S|$ 就减少了 $1$**。可以从大小为 $19$ 的组中减少一个数，这个数不再与组内的其余 $18$ 个数询问，代价减少了整整 $18$！

总代价变化为 $4+11-18=-3$，也就是减少了 $3$。这就得到了正解！

```cpp
#include<bits/stdc++.h>
#include "richest.h" //delete this in luogu.com.cn?
#define n 1000009
int richest(int N,int T,int S);
std::vector<int> ask(std::vector<int> a, std::vector<int> b);
int siz[n];
std::vector<int> res,a,b,ret;
std::vector<int> shrinker(std::vector<int> strategy,std::vector<int> lst){
	a.clear();b.clear();
	static int pos;pos=0;
	for(int i:strategy){
		for(int j=pos;j<pos+i;++j)for(int k=pos;k<j;++k)
			a.push_back(lst[j]),b.push_back(lst[k]);
		pos+=i;
	}
	res=ask(a,b);
	for(int i:lst)siz[i]=0;
	ret.clear();
	static int cnt;cnt=0;pos=0;
	for(int i:strategy){
		for(int j=pos;j<pos+i;++j)for(int k=pos;k<j;++k)++siz[res[cnt]],++cnt;
		for(int j=pos;j<pos+i;++j)if(siz[lst[j]]==i-1)ret.push_back(lst[j]);
		pos+=i;
	}
	return ret;
}
std::vector<int> s,l;
int richest(int N,int T,int S){
	if(N==1000){
		s.clear();s.push_back(N);
		l.clear();for(int i=0;i<N;++i)l.push_back(i);
		return shrinker(s,l)[0];
	}
	else{//N==1000000
		s.clear();for(int i=0;i<500000;++i)s.push_back(2);
		l.clear();for(int i=0;i<N;++i)l.push_back(i);
		l=shrinker(s,l);
		s.clear();for(int i=0;i<250000;++i)s.push_back(2);
		l=shrinker(s,l);
		s.clear();for(int i=0;i<125000;++i)s.push_back(2);
		l=shrinker(s,l);
		s.clear();for(int i=0;i<62500;++i)s.push_back(2);
		l=shrinker(s,l);
		s.clear();for(int i=0;i<20832;++i)s.push_back(3);s.push_back(4);
		l=shrinker(s,l);
		s.clear();for(int i=0;i<3471;++i)s.push_back(6);s.push_back(7);
		l=shrinker(s,l);
		s.clear();for(int i=0;i<178;++i)s.push_back(19);for(int i=0;i<5;++i)s.push_back(18);
		l=shrinker(s,l);
		s.clear();s.push_back(183);
		return shrinker(s,l)[0];
	}
}
```

另外，以上的代码是在本题数据仍未上传时写的。为了验证正确性，我写了一个非适应性的 grader：

```cpp
#include<bits/stdc++.h>

int richest(int N,int T,int S);
std::vector<int> ask(std::vector<int> a, std::vector<int> b);

static int testid;
static int N,T,S,W[1000009],ans,ret;
static std::mt19937 mt(time(0));
inline int ri(int a,int b){return mt()%(b-a+1)+a;}

static int m,t,s;
static std::vector<int> res;
std::vector<int> ask(std::vector<int> a, std::vector<int> b){
	m=a.size();
	if(m!=b.size()){
		printf("#%d WA: Length of a and b are not the same.\n",testid);
		exit(1);
	}
	++t;if(t>T){
		printf("#%d WA: Too many requirements, get already %d/%d.\n",testid,t,T);
		exit(1);
	}
	s+=m;if(s>S){
		printf("#%d WA: Too many queries, get already %d/%d.\n",testid,s,S);
		exit(1);
	}
	res.clear();
	for(int i=0;i<m;++i){
		if(W[a[i]]>W[b[i]])res.push_back(a[i]);
		else res.push_back(b[i]);
	}
	return res;
}

int main(){
	std::scanf("%d%d%d",&N,&T,&S);
	for(testid=1;testid<=10;++testid){
		t=s=0;
		for(int i=0;i<N;++i)W[i]=i;
		for(int i=0;i<N;++i)std::swap(W[i],W[ri(i,N-1)]);
		for(int i=0;i<N;++i)if(W[i]==N-1)ans=i;
		ret=richest(N,T,S);
		if(ret!=ans){
			printf("#%d WA: Answer is %d, you returned %d.\n",testid,ans,ret);
			return 1;
		}
		printf("#%d AC: Correct.\n",testid);
	}
	return 0;
}
```

---

## 作者：markding (赞：6)

对于测试点 $1$ 直接做一个大的循环赛即可，对于测试点 $2$ 我们考虑 dp。

设 $f_{i,j}$ 代表仅用 $i$ 次请求，此时还剩 $j$ 个人的最少查询总数。

$$f_{0,1}=0,f_{0,x}=+\infty$$

$$f_{k,i}=\min_{p\ge1,\sum_{j=1}^pa_j=i,a_j\ge1}\{f_{k-1,p}+\sum_{j=1}^p\frac{a_j(a_j-1)}{2}\}=\min_{1\le p\le i}\{f_{k-1,p}+\min_{\sum_{j=1}^pa_j=i,a_j\ge1}\sum_{j=1}^p\frac{a_j(a_j-1)}{2}\}=\min_{1\le p\le i}\{f_{k-1,p}+\frac{(p-b)\cdot a(a-1)}{2}+\frac{b\cdot (a+1)a}{2}\}$$

最后一个式子中 $a=\lfloor\frac{i}{p}\rfloor,b=i\bmod p$，因此可以 $O(n^2)$ 递推。

在第一个等号处，我们将 $i$ 个人分成了 $p$ 组，第 $j$ 组有 $a_j$ 个人，对每一组人进行循环赛（最后只剩下了 $p$ 人），一共需要 $\sum_{j=1}^p\frac{a_j(a_j-1)}{2}$ 次查询。对所有可能的分组方式取 $\min$ 即可。

第二个等号处我们首先枚举 $p$，也就是分的组数，然后再枚举具体的分组方式。

关于最后一个等号的成立，有引理：$C_n^2+C_{n+a}^2>C_{n+1}^2+C_{n+a-1}^2(a\ge2)$，可以证明按上述方法贪心，序列最后会变为 $p-b$ 个数字 $a$，以及 $b$ 个数字 $a+1$（感性理解一下：因为最终序列的极差 $<2$，所以只能这样分）。

直接递推是非常缓慢的，我们可以利用多线程的方式来进行计算。

附如下多线程加速循环的代码（$M$ 线程，代码中 $M=15$，可根据实际情况调整）：

```cpp
#include<vector>
#include<thread>
#include<cstring>
#include<fstream>
#include<functional>
using namespace std;const int N=1000005,M=15;
long long f[9][N];int g[9][N];
int main()
{
	ofstream fout("D1T2.txt");
	memset(f,0x3f,sizeof f),f[0][1]=0;
	for(int k=1;k<=8;k++)
	{
		function<void(int)> func=[&](int i){
    		for (int p=1;p<=i;p++)
        	{
				long long ord=f[k-1][p]+1ll*(p-i%p)*(i/p)*(i/p-1)/2+1ll*(i%p)*(i/p)*(i/p+1)/2;
				if(f[k][i]>ord)f[k][i]=ord,g[k][i]=p;
            }};
        vector<thread> threads;
        threads.reserve(M);
        for(int i=0;i<M;i++)
        {
            threads.emplace_back([=,&func]()
				{for(int t=i;t<N;t+=M)func(t);});
        }
        for(int i=0;i<M;i++)threads[i].join();
		fout<<k<<" Complete"<<endl;
	}
	int pos=1000000;fout<<f[8][pos]<<endl;
	for(int i=8;i;i--)fout<<g[i][pos]<<' ',pos=g[i][pos];
	return 0;
}
```

该程序创建的文本 `D1T2.txt` 最后两行为：

```txt
1099944
500000 250000 125000 62496 20832 3472 183 1
```

代码略，按照上述分组方式构造即可。

---

程序实测本地运行时间 $\sim 4h$（本地 CPU 采用 Intel(R) Core(TM) i7-13700H）。

当然考场上不需要搞出最优，爆搜一下即可。

不过，我们也可以在本地提前跑一些小的数据并观察最优解，发现前几次都是直接两两分组。可以根据这个性质加速 dp。从 $7$ 次开始，不断缩小两两分组的次数，直到找到最优解。实测代码经过优化后时间 $<2h$（代码略）。

---

附表：$N=1000000$ 时不同 $T$ 的所对应的 $f_{T,N}$:

| $T$ | $f_{T,N}$ |
| :-: | :-: |
| 1 | 499999500000 |
| 2 | 93990141 |
| 3 | 8816504 |
| 4 | 3280700 |
| 5 | 2000713 |
| 6 | 1473837 |
| 7 | 1223204 |
| 8 | 1099944 |
| 9 | 1044824 |
| 10 | 1019840 |
| 11 | 1008877 |
| 12 | 1003893 |
| 13 | 1001726 |
| 14 | 1000746 |
| 15 | 1000288 |
| 16 | 1000109 |
| 17 | 1000041 |
| 18 | 1000011 |
| 19 | 1000002 |
| 20 | 999999 |

---

## 作者：operator_ (赞：6)

# P10786 [NOI2024] 百万富翁

[题目传送门](https://www.luogu.com.cn/problem/P10786)

## 题解

**免责声明：非选手，因暂时无交互库和数据未知代码正确性，故先不放，但可以预见原理肯定还是正确的**。

题目让你在序列中找最大值，但是询问需要分为若干层，每层询问之间无先后顺序。

~~子任务 $1$ 就是把所有数对枚举一遍，不用我教吧。~~

主要来看子任务 $2$。首先 $T,S$ 的限制让我们想到分治，我们正常分治即可做到 $O(\log n)$ 层，$O(n)$ 次，这是简单的。

然后你会发现很不可思议的是我们要在次数最多增加 $100000$ 次的基础上把层数缩减到 $8$ 层，这直观而言非常不可做。

我们仔细来分析一下每一层。你会发现其实就是你给交互库一个无向图，然后交互库把他重定向，最后你可以把入度不为 $0$ 的点给删了，进入下一层。

不妨认为交互库是自适应的。那么你发现，如果对于一个 $n$ 个点的图，我们还保留了一个以上的点，那么这一定是不优的（仔细想想，感性理解）。而如果我们每次都只保留 $1$ 个点，那么所有询问在之后都是没有意义的。换句话说，不存在重复利用询问的情况。

所以最优解一定是把所有点分为若干个段，每个段都询问完全图。

基于这个我们可以 $dp$（记搜更好）。每次枚举分成几段，然后就变成了一个简单问题：把 $n$ 个点分成 $m$ 段，最大化每一段数量的平方之和。~~直观感受~~肯定是越接近越好，所以我们简单计算即可。

这个复杂度爆的很厉害，我们肯定不能这样写。

**接下来是乱搞部分，想看正解去别的题解。**

我们充分发挥人类智慧，猜测分的段数一定是某个 $\lfloor\dfrac{n}{i}\rfloor$！我们一写，发现跑到了 $1099947$！~~这很好，已经远超大众分了。~~

```cpp
int get(int x,int y) {
    if(y==1) return 0;if(!x) return (int)4e18;if(f[x][y]<(int)1e9) return f[x][y];
    for(int i=1;i<=sqrt(y);i++) {
        int a=y/i,b=y%i,ret=(i-b)*(a*(a-1)/2)+b*((a+1)*a/2)+get(x-1,i);
        if(ret<f[x][y]) f[x][y]=ret,g[x][y]=i;
    }
    for(int ii=2;ii<=sqrt(y);ii++) {
        int i=y/ii,a=y/i,b=y%i,ret=(i-b)*(a*(a-1)/2)+b*((a+1)*a/2)+get(x-1,i);
        if(ret<f[x][y]) f[x][y]=ret,g[x][y]=i;
    }
    return f[x][y];
}
```

你看这个数已经无比接近正解了，那我们再猜测：分的段数一定在某个 $\lfloor\dfrac{n}{i}\rfloor$ 附近！具体的，我们枚举他周围的 $5$ 个数（实测 $3$ 个就够），然后你发现，他就过了！

```cpp
int get(int x,int y) {
    if(y==1) return 0;if(!x) return (int)4e18;if(f[x][y]<(int)1e9) return f[x][y];
    for(int i=1;i<=sqrt(y);i++) {
        int a=y/i,b=y%i,ret=(i-b)*(a*(a-1)/2)+b*((a+1)*a/2)+get(x-1,i);
        if(ret<f[x][y]) f[x][y]=ret,g[x][y]=i;
    }
    for(int ii=2;ii<=sqrt(y);ii++) for(int i=max(y/ii-2,1ll);i<=min(y/ii+2,y-1);i++) {
        int a=y/i,b=y%i,ret=(i-b)*(a*(a-1)/2)+b*((a+1)*a/2)+get(x-1,i);
        if(ret<f[x][y]) f[x][y]=ret,g[x][y]=i;
    }
    return f[x][y];
}
```

输出一下方案，得到 ```mp[8]={1,183,3472,20832,62498,125000,250000,500000};``` 本题结束。

upd：在 qoj 测了一下代码，应该是没问题的，放出来吧。

```cpp
#include<bits/stdc++.h>
#include "richest.h"
using namespace std;
inline int rd() {
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}
int fl[1000005],mp[10]={0,1,183,3472,20832,62498,125000,250000,500000};
int richest(int N,int T,int S) {
    memset(fl,0,sizeof(fl));vector<int> now,a,b,ret;
    for(int i=0;i<N;i++) now.push_back(i);
    for(int ii=8;ii>=1;ii--) {
        a.clear(),b.clear(),ret.clear();
        int x=N/mp[ii],y=N%mp[ii],pos=0;
        for(int i=1;i<=mp[ii]-y;i++,pos+=x) for(int j=pos;j<pos+x;j++) for(int k=pos;k<j;k++)
            a.push_back(now[j]),b.push_back(now[k]);
        for(int i=1;i<=y;i++,pos+=x+1) for(int j=pos;j<=pos+x;j++) for(int k=pos;k<j;k++)
            a.push_back(now[j]),b.push_back(now[k]);
        ret=ask(a,b);for(int i=0;i<ret.size();i++) (ret[i]==a[i]?fl[b[i]]++:fl[a[i]]++);
        ret.clear();for(int i:now) if(!fl[i]) ret.push_back(i);
        now=ret;N=now.size();memset(fl,0,sizeof(fl));
    }
    return now[0];
}
```

---

## 作者：D0000 (赞：6)

[NOI2024 D1T2](https://www.luogu.com.cn/problem/P10786)

讲一个容易理解的方法。（测试点 $1$ 容易做，讲测试点 $2$）

## 思路

这道题难点在于有个 $t$ 代表请求次数，相当于要将询问打包。相当于我们要根据获取的答案做出决断，但限制请求 $t$ 次就使得我们只能决断 $t$ 次，因此打在一个包里的询问要尽量没有关联，于是便想到了分治。

### （29 分）

具体而言，每次比较相邻两数（下标奇数的只和它左边比），最大值取出来再重复操作，直到剩余一个数为止。这样询问总数是 $n$ 次的，但是请求次数仍达到了 $O(\log n)$ 级别，$n$ 取 $10^6$ 大概要请求 $19$ 次，感觉差的不远（满分 $8$ 次），但总分只能得 $29$ 分。看来得减少分的层数。

### （81 分）

其实我觉得与其说分治，不如看成节点的合并（是从下往上）。比如刚刚的方法就是将底层的节点两两合并，再两两合并，直到剩下一个。请求次数就是合并的树高，询问次数就是每次合并的代价总和。而将 $x$ 个节点并在一起，其实就是要一次请求找出最大值要 $\frac{x(x+1)}{2}$ 次。两两合并不行（合并得太慢了），那试一试多一点合并。

好吧，其实上 $3$ 个、$4$ 个合并不但不能满足 $8$ 次请求，还使得询问次数太多了。

那现在问题是既要合并得快，又要代价小（询问次数少），两者要均衡。或许每一次合并的数目不一定相同。那怎样最优呢？

别忘了，你参加的是信息学比赛，不是数学比赛，直接写个程序爆搜呗，枚举前 $7$ 层合并多少，最后一层直接合并。


运行发现最优是 $2,2,2,2,3,6,19$（从下往上每次合并的节点数目），需要询问 $1099960$ 次，这回真差不远了。

### （91 分）

其实发现合并时并非都是同样数目的。原因是点数不一定是最佳合并点数的倍数，比如刚才的方法其实是：

第一次：$2$ 个一合并。

第二次：$2$ 个一合并。

第三次：$2$ 个一合并。

第四次：$2$ 个一合并。

第五次：$1$ 个不需合并，其它点 $3$ 个一合并。

第六次：前 $2$ 个合并，其它 $6$ 个一合并。

第七次：前 $15$ 个合并，其它 $19$ 个一合并。

第八次：（只能所有合并起来）

发现前面很少的点合并太浪费了（浪费后面的，因为 $x$ 个点合并需要 $O(x^2)$ 级别次），因此平摊一下，变成这样：

第一次：$2$ 个一合并。

第二次：$2$ 个一合并。

第三次：$2$ 个一合并。

第四次：$2$ 个一合并。

第五次：前 $2$ 个 $2$ 个一合并，其它点 $3$ 个一合并。

第六次：前 $4$ 个 $5$ 个一合并，其它 $6$ 个一合并。

第七次：前 $4$ 个 $18$ 个一合并，其它 $19$ 个一合并。

这样就需要 $1099947$ 次，只差 $3$ 次了。

（计算过程太多了，这里就不展示了）

### （100 分）

前四次不管，看后面，刚刚是把靠后的补到前面来，但其实也可以把靠前的补到后面来。这一点很难想到是因为会使这一层的代价多一点，但会让点变少一些，对后面有好处。还有这里第 $7$ 次只单下一个。于是，方法如下：

第一次：$2$ 个一合并。

第二次：$2$ 个一合并。

第三次：$2$ 个一合并。

第四次：$2$ 个一合并。

第五次：前 $4$ 个合并，其它点 $3$ 个一合并。

第六次：前 $7$ 个合并，其它 $6$ 个一合并。

第七次：前 $5$ 个 $18$ 个一合并，其它 $19$ 个一合并。

这样刚好询问 $1099944$ 次，不知道有没有更好的方法啊？

## 其它

其实搜索前先算一算是有好处的。比如我是先算了算发现前 $5$ 次只有可能是 $2,2,2,2,3$。只搜了后面 $2$ 位。另外你会发现在靠下的地方，节点多，合并数目太多了会让代价增大。但到了上面（甚至是最上面），节点数目少了，才需要加快合并。因此我只限定了搜到 $40$，就很快出来了：

$$2,2,2,2,3,6,19,(183)$$

---

## 作者：huangjizuo (赞：5)

Note: 虽然没评测，不过做法应该是对的。

题目要求获得 $N$ 个数（互不相同）当中最大值的下标，总共可以使用 $s$ 次询问，每次询问可得知两个元素的大小关系。询问是分批次进行的，最多可以使用 $t$ 个查询批次。

首先考虑两个极端情况：1) $t=1$，那么为了保证找到最大值，必须枚举任意两个元素的配对，即 $s=N(N-1)/2$；2) 为了最小化 $s$，可以采用二分的策略，每个批次将当前元素两两配对，构成 $N/2$ 个查询，这样每个批次查询后候选元素减半，故 $s=N/2+N/4+N/8+... \approx N$，而查询批次 $t=\log_2 N$。

现在我们直接观察最优解的约束，即 
$$N=1000000,t=8, s=1099944,$$
注意到二分需要 $20$ 轮，远远多于题目要求，所以我们需要更快速地缩减候选集合的规模。考虑按 $k$ 个元素一组进行划分，总共得到约 $N/k$ 组（为方便分析，先忽略不整除的情形），要想通过一批查询得知 $k$ 个数的最大值，必须要枚举 $C_k^{2}=k(k-1)/2$ 组配对，这样一批次内的查询规模为：
$$ N/k \times C_k^2=N(k-1)/2.$$
值得注意的是 $s/N<1.1$，因此我们的操作空间非常有限，比方说第一批查询，只能选择 $k=2$。

现在我们重新叙述一下题目的含义：给定 $N$ 个叶节点，我们需要通过不断合并节点构造一个树结构，树的高度不超过 $t$ 层，若一个节点有 $k$ 个子节点，则花费 $k(k-1)/2$ 的代价，总代价不超过 $s$。

假设每一层节点的儿子数量都相等，那么对于 $t=8$ 的设定，本质上我们需要找到一组数 $k_1, k_2, ... k_8$，使得
$$k_1 \times k_2 \times ... \times k_8 = N,$$
并且总代价
$$\sum_{i=1}^8 \frac{N}{\prod_{j=1}^i k_j} C_{k_i}^2$$
尽可能小。

不妨先讨论只分两层的情况，即 $N=k_1 k_2$，此时代价为
$$cost=k_2 C_{k_1}^2+C_{k_2}^2=k_2 k_1 (k_1-1)/2+k_2(k_2-1)/2.$$
首先我们很容易观察到为了让代价最小一定有$k_1 \leq k_2$。由这个性质可以推广得到原题$k_1$~$k_8$一定是单调不降的。进一步估计发现：
$$cost \approx Nk_1/2+k_2^2/2=\frac{1}{2} (N^2/k_2+k_2^2),$$
该式右侧当 $N^2/(2k_2)=k_2^2$ 时取最小值，即$k_2=(N^2/2)^{1/3}$，同时$k_1=(2N)^{1/3}$，也可以归结为$k_1^2=2k_2$。当剖分层数大于 $2$ 时，同样可以推导出相邻两层大致满足 $k_i^2 \approx 2k_{i+1}$ 的关系。

为了找到一组最佳的划分，我们可以暴力搜索一组单调不降的 $\{k_i\}$ 使得
$$k_1 \times k_2 \times ... \times k_8 \geq N,$$
并且逐层累计的代价尽可能小。注意到我们尚未精确地处理不整除的情形，所以这里的代价可以粗略估计一下，比如允许分组的数量不是整数。或者你也可以像我一样自己按计算器人肉搜索，不难验证前三层必定满足 $k_1=k_2=k_3=2$，这样你只需要再试两到三层，然后套用  $k_i^2 \approx 2k_{i+1}$ 快速找到最后两到三层的最佳划分。

如果不出意外的话，你应该会发现这样一个组合：
$$2 \times 2 \times 2 \times 2 \times 3 \times 6 \times 19 \times 183=1001376$$
距离我们的目标代价 $1099944$ 最为接近。注意到 $6^2 \approx 2 \times 19$，$19^2 \approx 2 \times 183$，只要你钦定了前五个数是 $2,2,2,2,3$，这组划分其实并不难找到。

这样前 $4$ 个批次的查询没有疑义：

将 $N=1000000$ 个数按 $2$ 个一组查询，开销 $500000$，剩余 $500000$ 个数。

将 $500000$ 个数按 $2$ 个一组查询，开销 $250000$，剩余 $250000$ 个数。

将 $250000$ 个数按 $2$ 个一组查询，开销 $125000$，剩余 $125000$ 个数。

将 $125000$ 个数按 $2$ 个一组查询，开销 $62500$，剩余 $62500$ 个数。

接下来的问题是，$62500$ 并不被 $3$ 整除，多出来的一个数如何处理？这里可以直接验证，最后剩下的 $4$ 个数按照 $3+1$ 组合开销为 $3$，而按照 $2+2$ 组合开销为 $2$，所以 $2+2$ 的组合更好（由于代价函数是下凸函数，所以由琴生不等式，分组的规模越接近则代价越小）。分组策略为
$$62500 = 20832 \times 3 + 2 \times 2,$$
第五轮开销为
$$20832 \times C_3^2 + 2 \times C_2^2 = 62498.$$
现在剩下 $20834$ 个元素，我们按照 $6$ 个一组划分，余数为 $2$，同样的我们把最后几组元素均摊一下，凑成 $5$ 个一组，得到
$$20834 = 3469 \times 6 + 4 \times 5,$$
于是第六轮代价为：
$$3469 \times C_6^2 + 4 \times C_5^2 = 52075.$$
接着剩下 $3473$ 个元素，按照 $19$ 个一组，余数为 $15$，同理最后凑成 $18$ 个一组，得到
$$3473 = 179 \times 19 + 4 \times 18,$$
第七轮代价为：
$$179 \times C_{19}^2 + 4 \times C_{18}^2 = 31221.$$
最后剩下183个数，一次性处理完，第八轮代价为：
$$C_{183}^{2}=16653.$$
将上述八轮的代价加起来，得到 $1099947$，已经非常接近目标了。现在我们从哪里找到改进点呢？我们肯定要在当前划分的基础上加一点扰动（某一个瞬间我也怀疑过是不是前面挑的八个数错了）。观察我们第六轮的划分：
$$20834 = 3469 \times 6 + 4 \times 5,$$
这里如果我们减掉两个元素，它就可以写成：
$$20832 = 3472 \times 6.$$
这里的好处是我们下一层候选的数量减少了一个（原先是 $3473$），那么下一轮的代价显然有改进。而为了第六轮少两项，第五轮就需要砍掉两个分组。注意到本来的分组是
$$62500 = 20832 \times 3 + 2 \times 2.$$
我们知道分组规模必须是连续两个整数，为了减少分组数量，那么我们只能考虑 $3$ 个一组和 $4$ 个一组，因此我们改造成
$$62500 = 20828 \times 3 + 4 \times 4,$$
如此正好剩下 $$20832$$ 个分组。现在我们重新统计一遍代价，第五轮代价：
$$20828 \times C_3^2 + 4 \times C_4^2 = 62508.$$
第六轮：
$$20832 = 3472 \times 6,$$
代价为
$$3472 \times C_6^2 = 52080.$$
第七轮：
$$3472 = 178 * 19 + 5 * 18,$$
代价为：
$$178 \times C_{19}^2 + 5 \times C_{18}^2 = 31203.$$
最后一轮代价 $16653$ 不变，总计
$$500000+250000+125000+62500+62508+52080+31203+16653=1099944.$$

尽管没有证明这个是最优解，不过够用了。从上述第五轮的拆分方法也可以看到，最优解只能保证分组的规模取相邻两个整数，却没有约束这两种类型的比例。不过我这里抛出一个貌似正确的性质（可以通过加扰动证明？）：一定存在一组最优解，在任意相邻的两层中至少有一层是可以整除的，也就是分组规模完全一样。

---

## 作者：Aaronwrq (赞：4)

这应该是 NOI2024 最简单的题了，只要简单构造一下就能拿满分。我来口胡一下在考场上的想法。

令 $F(n,m)$ 表示 $m$ 步内求出 $n$ 个数最大值的最小询问数，初值为 $F(1,0)=0$。

我们容易发现一种简单的缩小 $n$ 的方式。将 $n$ 个数分作 $k$ 段，每段间两两询问，就能将 $n$ 缩小为 $k$。我们记这 $k$ 段的长度为序列 $L$，那么需要的询问数量显然为 $\frac{1}{2}\sum\limits_i L_i(L_i-1)=\frac{1}{2}\sum\limits_i L_i^2-\frac{n}{2}$。

因此，我们想让 $L_i$ 的平方和取到最小。显然要让所有 $L_i$ 的取值尽可能接近，即只可能存在 $w$ 和 $w+1$ 两种取值。这个代价是容易 $O(1)$ 计算的。

我们直接 dp 求出这样操作的最小代价，复杂度是 $O(n^2m)$ 的，稍加优化就容易在考场的时间内跑完。

实际上，我们稍加观察，容易发现前 $4$ 次操作都是两两求最大值，也就是将 $n$ 变为原来的一半。这样操作完之后再跑 dp 就很快了。

跑出来后的答案刚好等于满分限制，在考场上还是很让人感到惊喜的。

打出这个表后，实现就比较简单了。

下午讲题时，出题人在 ppt 中证明了这样做就是最优的，但似乎并没有详细讲解。

“~~出题人是这样的，选手 A 题只要构造出 1099944 的方案就可以了，可是出题人要说明最优性考虑到事情就多了。~~”（摘自讲题 ppt）

---

## 作者：WaTleZero_pt (赞：2)

~~NOIP2023 T1 挂掉的蒟蒻来写题解了~~

部分分分析：

### $15$ 分

对于测试点 $1$，直接用最朴素的暴力，每个数之间两两比较即可。

### $26$ 分

对于测试点 $2$ 不难想到采用分治，我们可以通过在每次请求的时候把所有人两两分组进行比较，较小者淘汰，剩余的人继续重复这样的操作直到只剩下一个人即可。~~我也只能独立做到这里了。~~

### 接近满分

注意到 $26$ 分的做法查询次数总和 $s$ 在 $10^{6}$ 左右，比题目中的要求 $1099944$ 小一些，因此我们可以考虑在这个基础上优化。

我们发现，$26$ 分的做法最后 $12$ 轮请求查询次数很少，因此我们可以通过增加查询次数以降低请求次数。我们发现，可以在分组的时候每组多分一些人，求出这组人的最大者来达到这样的目的。具体每次请求将几人分成一组呢？考虑爆搜（~~因为我 dp 很菜~~）。

为了避免爆搜太慢，我们可以通过一些手段进行优化。我们发现，后一轮请求中每组人数不小于前一轮请求中每组人数总是最优的（因为后一轮的人数比前一轮少得多，查询次数也不会很多）。同时，分析可以发现如果前 $4$ 轮不按照 $2$ 人一组的方法，总查询次数一定会超过 $1100000$，因此可以大大提高 dfs 的速度。

可以发现每组人数最优解为 $2,2,2,2,3,6,19,183$，如果我们按照此方法分组，多出来的人另成一组，此时查询次数仅仅比 $1099944$ 略大一点点了。

### 正解

为什么 CCF 要把查询次数设置的如此精确呢？显然就是需要我们找到最优解。考虑手动对第 $5 \sim 8$ 次请求进行微调。具体方法如下：

原先的第 $5$ 次请求中有一个人自成一组，我们可以将他合并到另一组中。按照这样的分配方式第 $6$ 次请求中也会有一个人自成一组，采用同样的方法。第 $7$ 次请求缺少了 $5$ 个人，平摊到另外 $5$ 组中，我们会惊奇地发现此时查询次数恰好为 $1099944$ 次！

代码实现难度不大，只需按照上述过程模拟一遍即可。

以下是我的部分代码，源程序已经在 QOJ 上通过：

```cpp
vector<int> lis[10];
vector<int> v1,v2,q,res;
int st[500010],pos=0,cnt=0;
void addquery(vector<int> v){
	st[pos]=cnt; pos++;
	int sz=v.size();
	for(int i=0;i<sz;i++)
		for(int j=i+1;j<sz;j++)
			v1.push_back(v[i]),v2.push_back(v[j]),cnt++;
}
bool ok[500010];
int richer(vector<int> v,int l){
	int sz=v.size();
	for(int i=0;i<sz;i++) ok[i]=1;
	for(int i=0;i<sz;i++)
		for(int j=i+1;j<sz;j++)
			if(res[l]==v[i]) ok[j]=0,l++;
			else ok[i]=0,l++;
	for(int i=0;i<sz;i++)
		if(ok[i]) return v[i];
}
void div(int id,int num,int sz1,int sz2){
    v1.clear(); v2.clear();
	int sz=lis[id].size();
	pos=0; cnt=0;
	for(int i=0;i<num*sz1;i+=sz1){
		q.clear();
		for(int j=0;j<sz1;j++)
			q.push_back(lis[id][i+j]);
		addquery(q);
	}
	for(int i=num*sz1;i<sz;i+=sz2){
		q.clear();
		for(int j=0;j<sz2;j++)
			q.push_back(lis[id][i+j]);
		addquery(q);
	}
	res=ask(v1,v2);
	int pos2=0;
	for(int i=0;i<num*sz1;i+=sz1){
		q.clear();
		for(int j=0;j<sz1;j++)
			q.push_back(lis[id][i+j]);
		lis[id+1].push_back(richer(q,st[pos2]));
		pos2++;
	}
	for(int i=num*sz1;i<sz;i+=sz2){
		q.clear();
		for(int j=0;j<sz2;j++)
			q.push_back(lis[id][i+j]);
		lis[id+1].push_back(richer(q,st[pos2]));
		pos2++;
	}
}
int smalldata(int n){
    lis[0].clear(); lis[1].clear();
    for(int i=0;i<n;i++) lis[0].push_back(i);
    div(0,1,n,0);
    return lis[1][0];
}
int bigdata(){
    for(int i=0;i<=8;i++) lis[i].clear();
    for(int i=0;i<1000000;i++) lis[0].push_back(i);
    div(0,500000,2,0);
    div(1,250000,2,0);
    div(2,125000,2,0);
    div(3,62500,2,0);
    div(4,20832,3,4);
    div(5,3471,6,7);
    div(6,5,18,19);
    div(7,1,lis[7].size(),0);
    return lis[8][0];
}

```

---

## 作者：Genius_Star (赞：1)

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18385632)

### 思路：

先考虑 Sub1 的部分分，暴力算法：

> 暴力询问所有 $i<j$ 的数对 $(i,j)$。  
> 则一个 $i$ 为最大值当且仅当 $(i,j)$ 的返回值都是 $i$ 且在 $i$ 之前没有满足此条件的位置。

则设 $\operatorname{F}(n) = \frac{n(n-1)}{2}$ 表示暴力找出 $n$ 个数中的最大值需要的询问次数，注意到 $\operatorname{F}(1000) = 499500$，故可以通过 Sub1。

对于 Sub2，直接暴力肯定是不行的，但是注意到 $t$ 的值开大了，故我们没必要一步到位，可以逐步缩小范围。

定义 $\operatorname{W}(a,b)$ 表示原先最大值候选有 $a$ 个，经过一次请求筛到 $b$ 个候选人的最小询问次数；考虑分为 $b$ 组，每组有 $\lfloor \frac{a}{b} \rfloor \sim \lceil \frac{a}{b} \rceil$ 人，故：

$$\operatorname{W}(a,b) = (b - b\bmod a) \operatorname{F}(\lfloor \frac{a}{b} \rfloor) + (b \bmod a) \operatorname{F}(\lceil \frac{a}{b} \rceil)$$

现在我们的目的就是找到一个合理的筛检最大值候选的序列 $h$，使得长度 $len \le t$ 且 $\sum\limits_{i=1}^{len-1} \operatorname{W}(h_i,h_{i+1}) \le s$。

爆搜经过实测可以搜到 $t=9$ 的情况，在 $t=8$ 时几乎无法跑出来。

考虑动态规划算法，令 $dp_{i,j}$ 表示 $W_i = j$ 的情况下的最小询问数，则状态转移方程为：

$$dp_{i,j} = \min_{k=j+1}^n dp_{i-1,k} + \operatorname{W}(k,j)$$

时间复杂度为 $O(tn^2)$，大概有 $10^{13}$，按照最低预算，计算机 1s 可以跑 $10^8$，则 $\frac{10^{13}}{10^{8}} = 10^5$，则 $\frac{10^5}{64^2} \approx 24$，大概要跑 $1$ 天的时间，是肯定不行的。

可以有一个猜想，每次候选人的数量至少要减半，这样一定不会太劣，这样我们就将范围个缩小了，对于 $dp_{i,j}$ 有效的 $j$ 只有 $\frac{n}{2^{i-1}}$，枚举的 $k$ 大概是 $(j,2j]$，这样大概可以缩到 $10^{11}$ 左右，可以在 1h 内跑完。

其实也可以在确定前面几位为 $1000000,500000,250000,125000$ 的情况下对后面跑 $dp$，这样时间更会大大减少。

最后根据我们得到的 $h$ 模拟一下分组求最大值的过程即可。

单组数据时间复杂度最多为 $O(Nt)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const int maxn=1e6+10;
std::vector<int> ask(std::vector<int> a, std::vector<int> b);
int n;
vector<int> a,b,h;
namespace Sub1{
    int cnt=0;
    int work(){
    	a.clear(),b.clear();
    	cnt=0;
        vector<int> l(n,0),r(n,0);
        For(i,0,n-1){
            l[i]=cnt;
            For(j,i+1,n-1){
                a.push_back(i);
                b.push_back(j);
                ++cnt;
            }
            r[i]=cnt-1;
        }
        h=ask(a,b);
        For(i,0,n-1){
            bool F=1;
            For(j,l[i],r[i]){
                if(h[j]!=i){
                    F=0;
                    break;
                }
            }
            if(F)
              return i;
        }
        return 0;
    }
};
namespace Sub2{
	int cnt=0;
	int s[maxn];
	vector<int> E[maxn];
	stack<int> S;
	int p[]={1000000,500000,250000,125000,62498,20832,3472,183,1};
	void solve(int x){
		s[x]=a.size();
		int n=E[x].size();
        For(i,0,n-1){
            For(j,i+1,n-1){
                a.push_back(E[x][i]);
                b.push_back(E[x][j]);
            }
        }
	}
	int get(int x){
		int g=s[x],n=E[x].size();
		For(i,0,n-1){
			bool F=1;
			For(j,i+1,n-1)
			  if(h[g++]!=E[x][i])
				F=0;
			if(F)
			  return E[x][i];
		}
		return 0;
	}
	void get(int X,int Y){
		cnt=0;
		int l=0,cnt=0,g=0,B=X/Y;
		For(i,1,Y)
		  E[i].clear();
		while(!S.empty()){
			++l;
			int x=S.top();
			S.pop();
			if((l-1)/B+1!=cnt)
			  ++cnt;
			if(cnt<=Y)
			  E[cnt].push_back(x);
			else{
				++g;
				E[g].push_back(x);
			}
		}
		For(i,1,Y)
		  solve(i);
		h=ask(a,b);
		For(i,1,Y){
			int x=get(i);
			S.push(x);
		}
	}
	int work(){
		while(!S.empty())
		  S.pop();
    	_For(i,0,n-1)
    	  S.push(i);
		For(i,1,8){
			a.clear(),b.clear();
			get(p[i-1],p[i]);
		}
		return S.top();
	}
};
int richest(int N,int T,int S){
    n=N;
    if(n<=1000)
      return Sub1::work();
    else
      return Sub2::work();
}
```

---

## 作者：1234567890sjx (赞：1)

### $15$ 分

属于阅读理解题。直接把每两个位置都比较一下，然后开一个桶，出现次数最多的就是答案。

```cpp
int richest(int n, int t, int s) {
        std::vector<int> a, b;
        for (int i = 0; i < n; ++i)
            for (int j = i + 1; j < n; ++j)
                a.emplace_back(i), b.emplace_back(j);
        std::vector<int> c = ask(a, b);
        for (int i = 0; i < 200100; ++i)
            box[i] = 0;
        for (auto &val : c)
            ++box[val];
        for (int i = 0; i < n; ++i)
            if (box[i] >= n - 1) return i;
        return -1;
}
```

### $27$ 分

考虑对序列分治。将序列分为左、右两个部分，若序列此时长度为 $1$ 则该序列最大的元素一定为这个唯一的元素，否则比较左、右两个部分，让长度为 $n$ 的序列剩余 $\lceil\frac{n}{2}\rceil$ 个元素并继续分治即可。需要花费 $20$ 次操作，总比较次数为 $999999$。

```cpp
int richest(int n, int t, int s) {
    std::vector<int> v;
    for (int i = 0; i < n; ++i)
        v.emplace_back(i);
    while (v.size() > 1) {
        std::vector<int> a, b;
        for (int j = 1; j < v.size(); j += 2)
            a.emplace_back(v[j - 1]), b.emplace_back(v[j]);
        int t;
        if (v.size() & 1) t = v.back();
        else t = -1;
        v = ask(a, b);
        if (~t) v.emplace_back(t);
    }
    return v[0];
}
```

### $52$ 分

看到限制查询次数为 $1099944>999999$，因此考虑用比较次数来换操作次数。考虑设置一个阈值 $p$，若序列的元素数量小于阈值 $p$ 则一遍暴力操作扫描，否则分治。操作次数可以做到 $13$ 次。

```cpp
int richest(int n, int t, int s) {
    std::vector<int> v;
    for (int i = 0; i < n; ++i)
        v.emplace_back(i);
    if (t == 20) {
        while (v.size() > 400) {
            std::vector<int> a, b;
            for (int j = 1; j < v.size(); j += 2)
                a.emplace_back(v[j - 1]), b.emplace_back(v[j]);
            int t;
            if (v.size() & 1) t = v.back();
            else t = -1;
            v = ask(a, b);
            if (~t) v.emplace_back(t);
        }
        if (v.size() == 1)
            return v[0];
        else {
            std::vector<int> a, b;
            for (int i = 0; i < v.size(); ++i)
                for (int j = i + 1; j < v.size(); ++j)
                    a.emplace_back(v[i]), b.emplace_back(v[j]);
            std::vector<int> c = ask(a, b);
            for (int i = 0; i < 2000100; ++i)
                box[i] = 0;
            for (auto &val : c)
                ++box[val];
            for (int i = 0; i < v.size(); ++i)
                if (box[v[i]] >= v.size() - 1) return v[i];
            return -1;
        }
    } else {
        std::vector<int> a, b;
        for (int i = 0; i < n; ++i)
            for (int j = i + 1; j < n; ++j)
                a.emplace_back(i), b.emplace_back(j);
        std::vector<int> c = ask(a, b);
        for (int i = 0; i < 200100; ++i)
            box[i] = 0;
        for (auto &val : c)
            ++box[val];
        for (int i = 0; i < n; ++i)
            if (box[i] >= n - 1) return i;
        return -1;
    }
}

```

### $100$ 分

其实分治序列，并不一定要将序列分治为两个部分，更不需要让分治出来的部分大小完全相等（但是为了让操作次数最小，需要让每一个部分的大小尽量的平均）。考虑每一次让序列分为 $p$ 个组，然后这些组每一次合并。因为最多是操作 $8$ 次因此考虑选出 $8$ 个不同的 $p$ 值。问题转变为如何选择这些 $p$ 值。

这 $8$ 个 $p$ 值可以手算，也可以写点奇奇怪怪的搜索。因为没有什么时间限制所以怎么跑都没事。然后最终算出来就是 $p=\lbrace2,2,2,2,3,6,19,183\rbrace$。

然后就是怎么合并信息。（这个就不用我说了吧）。

最后放一下混乱不堪的代码：

```cpp
int richest(int n, int t, int s) {
    std::vector<int> v;
    for (int i = 0; i < n; ++i)
        v.emplace_back(i);
    if (t == 20) {
        for (int i = 0; i < 8; ++i) {
            std::vector<int> a, b;
            for (int j = 0; j < v.size(); ++j)
                for (int k = j % p[i]; k < j; k += p[i])
                    if (j != k) {
                        a.emplace_back(v[j]);
                        b.emplace_back(v[k]);
                    }
            std::vector<int> c = ask(a, b);
            for (int j = 0; j < c.size(); ++j)
                if (a[j] == c[j])
                    box[b[j]] = 1;
                else
                    box[a[j]] = 1;
            std::vector<int> tmp;
            for (int j = 0; j < v.size(); ++j)
                if (!box[v[j]])
                    tmp.emplace_back(v[j]);
            v.swap(tmp);
            for (int j = 0; j < c.size(); ++j)
                box[a[j]] = box[b[j]] = 0;
        }
        // for (int i = 0; i < 8; ++i) {
        //     std::vector<int> a, b;
        //     for (int j = 1; j < v.size(); j += 2)
        //         a.emplace_back(v[j - 1]), b.emplace_back(v[j]);
        //     int t;
        //     if (v.size() & 1) t = v.back();
        //     else t = -1;
        //     v = ask(a, b);
        //     if (~t) v.emplace_back(t);
        // }
        // for (int i = 0; i < 8; ++i) {
        //     std::vector<int> a, b, c;
        //     for (int j = 2; j < v.size(); j += 3)
        //         a.emplace_back(v[j - 2]), b.emplace_back(v[j - 1]), c.emplace_back(v[j]);
        //     int t1 = -1, t2 = -1;
        //     if (v.size() % 3 == 2)
        //         t1 = v[v.size() - 2], t2 = v[v.size() - 1];
        //     else if (v.size() % 3 == 1)
        //         t1 = v[v.size() - 1];
        //     v = ask(ask(a, b), c);
        //     if (~t1)
        //         v.emplace_back(t1);
        //     if (~t2)
        //         v.emplace_back(t2);
        // }
        // printf("qwq %zd\n", v.size());
        return v[0];
        // if (v.size() == 1)
        //     return v[0];
        // else {
        //     std::vector<int> a, b;
        //     for (int i = 0; i < v.size(); ++i)
        //         for (int j = i + 1; j < v.size(); ++j)
        //             a.emplace_back(v[i]), b.emplace_back(v[j]);
        //     std::vector<int> c = ask(a, b);
        //     for (int i = 0; i < 2000100; ++i)
        //         box[i] = 0;
        //     for (auto &val : c)
        //         ++box[val];
        //     for (int i = 0; i < v.size(); ++i)
        //         if (box[v[i]] >= v.size() - 1) return v[i];
        //     return -1;
        // }
    } else {
        std::vector<int> a, b;
        for (int i = 0; i < n; ++i)
            for (int j = i + 1; j < n; ++j)
                a.emplace_back(i), b.emplace_back(j);
        std::vector<int> c = ask(a, b);
        for (int i = 0; i < 200100; ++i)
            box[i] = 0;
        for (auto &val : c)
            ++box[val];
        for (int i = 0; i < n; ++i)
            if (box[i] >= n - 1) return i;
        return -1;
    }
}

```

---


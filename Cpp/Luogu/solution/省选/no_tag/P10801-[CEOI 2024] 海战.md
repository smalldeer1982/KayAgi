# [CEOI 2024] 海战

## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T1「[Naval battle](https://ceoi2024.fi.muni.cz/page/tasks/statements/battle.pdf)」**

捷克海军司令官翁德拉刚刚晋升为大元帅，正享受着新职位的安稳，却突然被政府通知海军将被裁撤。

翁德拉决心证明捷克海军的重要性。他通过间谍得知，一场四国海军巨舰对决即将展开。如果能赢得这场战役，无疑能向政府有力地展示海军价值。

然而，捷克海军既无战舰也无港口。但翁德拉想到，如果他的间谍能夺取几艘参战舰艇，或许还有一线生机。关键是，如何预知哪些船能在这场海战中幸存下来呢？

海战规则如下：
- 战前，第 $i$ 艘战舰位于坐标 $(x_i, y_i)$ 处，其中 $x_i$ 和 $y_i$ 均为偶数。每艘战舰隶属于北方、南方、东方或西方舰队之一。
- 海战分回合进行。每回合：
    - 每艘战舰同时向其所属舰队方向移动一格。
    - 如果两艘或以上战舰占据同一格，它们将相撞沉没，从海图上消失。
- 当不再发生碰撞时，海战结束。存活的战舰是指海战结束后仍留在海图上的战舰。

各舰队战舰的移动方向及坐标变化如下：
- 北方舰队：$y$ 坐标减 $1$
- 南方舰队：$y$ 坐标加 $1$
- 东方舰队：$x$ 坐标加 $1$
- 西方舰队：$x$ 坐标减 $1$

## 说明/提示

**样例解释 1**

初始战舰分布如下图：

![battle-sample1-v2.svg](https://img.loj.ac.cn/2024/07/14/c9908b56ff284.svg)

海战过程：
- 第 $2$ 回合，战舰 $3$ 和 $4$ 在 $(4, 4)$ 处相撞。
- 第 $6$ 回合，战舰 $1$ 和 $5$ 在 $(6, 6)$ 处相撞，战舰 $2$ 和 $6$ 在 $(6, 8)$ 处相撞。

最终仅剩战舰 $7$ 存活。


**样例解释 2**

初始战舰分布如下图：

![battle-sample2.svg](https://img.loj.ac.cn/2024/07/14/59d352521ca5d.svg)

第 $2$ 回合，战舰 $1$、$3$、$4$ 在 $(2, 4)$ 处相撞，战舰 $2$ 和 $5$ 存活。

**数据范围与提示**

对于所有输入数据，满足：

- $2 \leq N \leq 2 \cdot 10^5$
- $0 \leq x_i, y_i \leq 10^9\ (1 \leq i \leq N)$，且 $x_i, y_i$ 均为偶数

详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :--: | :--: | :--: |
|  $1$  | $N = 2$ | $6$  |
|  $2$  | $N \leq 100, x_i, y_i \leq 100\ (1\leq i\leq n)$ | $12$ |
|  $3$  | $N \leq 100, x_i, y_i \leq 10^5\ (1\leq i\leq n)$ | $8$ |
|  $4$  | $N \leq 200$ | $11$ |
|  $5$  | $N \leq 5\,000$ | $9$ |
|  $6$  | $d_i\ (1 \leq i \leq N)$ 为 `S` 或 `E`  | $30$ |
|  $7$  | 无附加限制| $24$ |

## 样例 #1

### 输入

```
7
0 6 E
0 8 E
2 4 E
4 2 S
6 0 S
6 2 S
6 4 S```

### 输出

```
7```

## 样例 #2

### 输入

```
5
4 0 S
0 2 E
2 2 E
4 4 N
6 6 W```

### 输出

```
2
5```

# 题解

## 作者：codeforest (赞：5)

### 子任务 1~5
吾辈可观之，唯当一舟与他舟相触之时，下一次碰撞之时刻方有变动。

吾辈先算出所有可能发生的 $O(N^2)$ 次碰撞，再依时间先后排序，逐一审视，以验证每次碰撞是否真正发生。

然而，此处有一难点，即可能有超过两舟同时碰撞。为解此难，吾辈可为每舟记录“殒命”之时，若某舟之“殒命”时已过，则该碰撞便不会发生。

此过程因排序之需，耗时 $O(N^2\log N)$。
### 子任务 6
题解所遵方向依【上北下南左西右东】之常规。

初观之，须知唯同东南对角线上而航向各异之舟乃相触也。又，南行之舟必居东行之舟之右。且此二舟间之对角线上不可有他舟，否则必先与一舟相触。

吾辈可喻由南至东对角线上之舟为括弧序列，东行者为左括弧，南行者为右括弧。于是，配对之括弧即示相触之舟。（相邻之配对括弧可划去之，续寻他之配对括弧）

今欲对角线上排序舟只，则需费 $O(N\log N)$ 之时也。
### 子任务 1~7
仿照子任务 6 解法，一舟或与他向之三舟相触，故一舟必入三不同之“双向线”中。于“双向线”中，舟只将以链表存之。唯相邻之左右括弧方能相撞，吾辈将此等碰撞依其发生时序置于优先队列中。

今需处理一事件，首当查其二舟是否已沉。若均未沉，则在对应“双向线”链表中撤去二舟，此举或生新相邻之配对括弧，故必要时当构新碰撞。于同时刻之诸事件中，宜先逐一验其是否真发，继而撤去此刻所沉之舟。

一舟于优先队列中仅存三可能之碰撞，各对应一他向。碰撞至多 $O(N)$，而优先队列每操作需 $O(\log N)$。终解之时间复杂度为 $O(N\log N)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;char tp;bool vis[200002];
vector<pair<int,int>>g[200002];
struct node{int t,x,y;bool operator<(node o)const{return o.t<t;}};priority_queue<node>q;
struct Graph{
	int n;vector<int>l,r;
	struct node{int id,x,y;bool tp;};vector<node>v;
	void init(int id){
		sort(v.begin(),v.end(),[](node a,node b){return a.x==b.x?a.y<b.y:a.x<b.x;});
		n=v.size(),v.insert(v.begin(),{0,0,0,1}),v.push_back({0,0,0,0}),
		l.resize(v.size()),r.resize(v.size());
		for(int i=1;i<=n;i++)g[v[i].id].push_back({id,i});
		for(int i=1;i<=n;i++)l[i]=v[i].x==v[i-1].x?i-1:0,r[i]=v[i].x==v[i+1].x?i+1:n+1;
		for(int i=1;i<=n;i++)if(!v[l[i]].tp&&v[i].tp)
			q.push({v[i].y-v[l[i]].y,v[l[i]].id,v[i].id});
	}
	void del(int i){
		if(!v[l[i]].tp&&v[r[i]].tp)q.push({v[r[i]].y-v[l[i]].y,v[l[i]].id,v[r[i]].id});
		r[l[i]]=r[i],l[r[i]]=l[i];
	}
}t[6];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>tp;
		if(tp=='E')
			t[0].v.push_back({i,x+y,y,1}),
			t[2].v.push_back({i,x-y,y,0}),
			t[4].v.push_back({i,y,x/2,0});
		if(tp=='W')
			t[1].v.push_back({i,x-y,y,1}),
			t[3].v.push_back({i,x+y,y,0}),
			t[4].v.push_back({i,y,x/2,1});
		if(tp=='S')
			t[0].v.push_back({i,x+y,y,0}),
			t[1].v.push_back({i,x-y,y,0}),
			t[5].v.push_back({i,x,y/2,0});
		if(tp=='N')
			t[2].v.push_back({i,x-y,y,1}),
			t[3].v.push_back({i,x+y,y,1}),
			t[5].v.push_back({i,x,y/2,1});
	}
	for(int i=0;i<6;i++)t[i].init(i);
	while(!q.empty()){
		vector<int>v;
		for(int t=q.top().t;!q.empty()&&q.top().t==t;q.pop())
			if(!vis[x=q.top().x]&&!vis[y=q.top().y])v.push_back(x),v.push_back(y);
		for(int i:v)if(!vis[i]){
			vis[i]=1;
			for(auto j:g[i])t[j.first].del(j.second);
		}
	}
	for(int i=1;i<=n;i++)if(!vis[i])cout<<i<<'\n';
}
```

---

## 作者：pldzy (赞：4)

提供一篇码风友好，码量友好，题解语言友好易读的题解。

## Solution

考虑一下碰撞情况，$6$ 种碰撞方式。判断是否相撞（不考虑是否消失）的条件也很显然，例如南北方向就是横坐标相同，例如北东方向就是横纵坐标之和相同。具体的话可以参考 Code 部分的具体说明。

对于每种碰撞方式，维护它的所有可能情况。题目的难点在于碰撞完后船的消失会影响后面的碰撞情况。

以北东方向的碰撞为例，我们把所有北方向和东方向的船丢到一个 `vector<int>()` 中，按照横纵坐标之和为第一关键字，按照横坐标为第二关键字，从小到大排序。发现我们目前需要考虑的碰撞，是满足一下条件的船对：

- 第一关键字相同（否则它们永不相撞）；
- 两艘船的方向不同（方向相同的船不会相撞）；
- 两艘船在 `vector<int>()` 中相邻（不相邻的船对一定没有相邻的船对优，因为我们已经排序了）；
- 排在前面的那艘船一定是北船，排在后面的一定是东船（否则它们永不相撞）；
- 两艘船都还存活。

其他方向的碰撞（南北、东西、北西、南东、南西）是同理的。

抓住可能产生真实碰撞的只在相邻的船对之间，所以考虑用链表动态维护碰撞序列（六种情况）。每次把可能产生贡献的碰撞丢到优先队列，然后不断取队头，删掉相撞的船即可。

补充一下时间复杂度方面的分析。初始我们会往优先队列里面放入 $O(n)$ 个船对贡献。每次删除一艘船时，会产生至多一个新的船对贡献，依旧是 $O(n)$。所以本题复杂度是 $O(n\log n)$，但是至少带 $6$ 倍常数。

实现方面的细节，参考下文。

## Code

$\begin{array}{|c|c|c|c|}N(0)&S(1)&E(2)&W(3)\\NS(0)&NS(0)&NE(1)&NW(2)\\NE(1)&SE(3)&SE(3)&SW(4)\\NW(2)&SW(4)&EW(5)&EW(5)\end{array}$

约定标号参考上表格。方向标号 $[0,3]$，碰撞种类标号 $[0,5]$。具体每个碰撞情况的排序关键字就自己画图看看吧，这里不多说。

实现还有一个细节。当我们从优先队列取出碰撞删除时，要先把碰撞时间相同的全部取出来，再一起删，因为可能存在三艘船同时相撞的情况（样例二）。

$3\text{ KB}$，真的写的很良心了。

````cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

#define rep(i, a, b) for(int i = (a); i <= (b); ++i)
#define per(i, a, b) for(int i = (a); i >= (b); --i)
#define pii pair<int, int>
#define pip pair<int, pii>
#define fi first
#define se second
#define mkp make_pair

const int maxn = 2e5 + 5;

int n, vis[maxn];
struct node{
    int tp; pii p, v[6];
    pii dir[6];
}a[maxn];
vector<int> b[6];
int tr[4][3] = {{0, 1, 2}, {0, 3, 4}, {1, 3, 5}, {2, 4, 5}};

int NOW;
inline bool cmp(int x, int y){ 
    return a[x].v[NOW] < a[y].v[NOW];
}

priority_queue<pip, vector<pip>, greater<pip> > pq;

inline void calc(int o, int x, int y){
    if(!x or !y or x > n or y > n or vis[x] or vis[y]) return;

    int X = a[x].v[o].se, Y = a[y].v[o].se; 
    pii p = mkp(a[x].tp, a[y].tp);
    if(p.fi == p.se or a[x].v[o].fi != a[y].v[o].fi) return;
    
    if(p == mkp(1, 0) or p == mkp(3, 2)) 
        pq.push(mkp((Y - X) >> 1, mkp(x, y)));
    if(p == mkp(0, 2) or p == mkp(3, 0) or p == mkp(1, 2) or p == mkp(3, 1))
        pq.push(mkp(Y - X, mkp(x, y)));
}

inline void dlt(int x){
    if(vis[x]) return; vis[x] = 1;
    rep(oo, 0, 2){
        int o = tr[a[x].tp][oo];
        int pre = a[x].dir[o].fi, suf = a[x].dir[o].se;
        a[pre].dir[o].se = suf, a[suf].dir[o].fi = pre;
        calc(o, pre, suf);
    }
}

signed main(){
    ios_base::sync_with_stdio(0); cin.tie(NULL);
    
    cin >> n;
    rep(i, 1, n){
        char ch; int x, y;
        cin >> x >> y >> ch; x = 1e9 - x; 
        if(ch == 'S') a[i].tp = 1; if(ch == 'E') a[i].tp = 2; if(ch == 'W') a[i].tp = 3;
        
        a[i].p = mkp(x, y);
        if(!a[i].tp){
            a[i].v[0] = mkp(x, y), a[i].v[1] = mkp(x + y, x), a[i].v[2] = mkp(x - y, x);
        } else if(a[i].tp == 1){
            a[i].v[0] = mkp(x, y), a[i].v[3] = mkp(x - y, x), a[i].v[4] = mkp(x + y, x);
        } else if(a[i].tp == 2){
            a[i].v[1] = mkp(x + y, x), a[i].v[3] = mkp(x - y, x), a[i].v[5] = mkp(y, x);
        } else{
            a[i].v[2] = mkp(x - y, x), a[i].v[4] = mkp(x + y, x), a[i].v[5] = mkp(y, x);
        }
        
        rep(o, 0, 2) b[tr[a[i].tp][o]].push_back(i);
    }
    
    rep(o, 0, 5) NOW = o, sort(b[o].begin(), b[o].end(), cmp);
    
    rep(o, 0, 5){
        int lst = -1;
        for(auto it = b[o].begin(); it != b[o].end(); ++it){
            int x = *it;
            if(~lst) calc(o, lst, x); lst = x;
            
            if(it == b[o].begin()) a[x].dir[o].fi = 0;
            else a[x].dir[o].fi = *prev(it);
            
            if(next(it) == b[o].end()) a[x].dir[o].se = n + 1;
            else a[x].dir[o].se = *next(it);
        }
    }
    
    while(pq.size()){
        vector<int> tmp; pip ss = pq.top(); tmp.clear();
        while(pq.size() and pq.top().fi == ss.fi){
            pip nw = pq.top(); pq.pop();
            if(vis[nw.se.fi] or vis[nw.se.se]) continue;
            tmp.push_back(nw.se.fi), tmp.push_back(nw.se.se);
        }
        for(int x : tmp) dlt(x);
    }
    
    rep(i, 1, n) if(!vis[i]) cout << i << '\n';
    return 0;
}
````

---

## 作者：佬头 (赞：4)

## Description
捷克海上的四方战舰将进行海战，规则如下：
- 战前，第 $i$ 艘战舰位于坐标 $(x_i, y_i)$ 处（两两不重合），其中 $x_i$ 和 $y_i$ 均为偶数，且隶属于北方、南方、东方或西方舰队之一。
- 海战分回合进行。每回合：
  - 各战舰同时按所属舰队要求移动：
    - 北方舰队：$y$ 坐标减 $1$；
    - 南方舰队：$y$ 坐标加 $1$；
    - 东方舰队：$x$ 坐标加 $1$；
    - 西方舰队：$x$ 坐标减 $1$。
  - 如果两艘或以上战舰占据同一格，它们将相撞沉没并立即消失。
- 当战舰不再发生碰撞时，海战结束。

请预知海战结束后幸存的战舰。
## Solution
- 大体思路：在战前求出每艘战舰可能被撞的最短时间。每次让时间最短的几对幸存的战舰消失，并更新幸存战舰可能被撞的最短时间，直到战舰都不可能相撞。

### 战前：求相撞时间
设某北方战舰位于 $(x_n,y_n)$，某南方战舰位于 $(x_s,y_s)$，某东方战舰位于 $(x_e,y_e)$，某西方战舰位于 $(x_w,y_w)$：
- 若西方战舰和东方战舰相撞。则有 $y_w=y_e,x_w\gt x_e$，在第 $\dfrac{x_w-x_e}{2}$ 个回合相撞。
- 若北方战舰和南方战舰相撞。则有 $x_n=x_s,y_n\gt y_s$，在第 $\dfrac{y_n-y_s}{2}$ 个回合相撞。
- 若北方战舰和东方战舰相撞。设 $(x_n,y_n-k)=(x_e+k,y_e),k\in \mathbb{N^+}$，由两点式可得 $y=x+(y_n-x_n)$ 或 $y=x+(y_e-x_e)$，则有 $y_n-x_n=y_e-x_e,x_n\gt x_e$，在第 $k$ 个回合相撞。
- 若西方战舰和北方战舰相撞。设 $(x_w-k,y_w)=(x_n,y_n-k),k\in \mathbb{N^+}$，由两点式可得 $y+x=y_w+x_w$ 或 $y+x=y_n+x_n$，则有 $y_w+x_w=y_n+x_n,x_w\gt x_n$，在第 $k$ 个回合相撞。
- 若南方战舰和东方战舰相撞。同理，有 $y_s+x_s=y_e+x_e,x_s\gt x_e$，在第 $x_s-x_e$ 个回合相撞。
- 若西方战舰和南方战舰相撞。同理，有 $y_w-x_w=y_s-x_s,x_w\gt x_s$，在第 $x_w-x_s$ 个回合相撞。

将每种相撞情况的两方战舰放在一起，按照相撞条件**排序**（满足**相等**条件的数据为**第一关键字**，另一数据为第二关键字）。
### 战时：战舰相撞
由于要不断更新相撞时间，考虑使用**优先队列**。

用 $lft_{i,j}$ 表示在第 $i$ 种情况下排序后位于 $j$ 的战舰**左侧第一艘**与之**同舰队**且**第一关键字相同**的战舰在排序后的位置，$rt_{i,j}$ 表示在第 $i$ 种情况下排序后位于 $j$ 的战舰**右侧第一艘**与之**同舰队**且**第一关键字相同**的战舰在排序后的位置，那么在第 $i$ 种情况下排序后位于 $x,y~(x\lt y)$ 的两艘战舰的相撞时间需要更新，则可以通过 $x\gets lft_{i,x}$ 或 $y\gets rt_{i,y}$。

为了避免不必要的更新，初始时可以只把排序后**相邻**的两艘战舰的相撞时间加入队列（显然同舰队的战舰不会相撞）。在更新的时候还可以进行**路径压缩**。代码时间复杂度 $\mathcal O(N\log N)$。
## Code
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#define se second
#define fi first
using namespace std;
const int N = 200005;
int n, x[N], y[N], xk[]={0,1,-1,1,1,-1}, yk[]={1,0,1,1,1,1}, _, lft[6][N], rt[6][N];
vector <int> a[6], b; //0:WE,1:NS,2:NE,3:WN,4:SE,5:WS
char team[N], t[] = "ESENES";
bool ruin[N], tadd;
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
bool cmp(int &a, int &b){
	if(xk[_]*x[a] + yk[_]*y[a] == xk[_]*x[b] + yk[_]*y[b]) return yk[_] == 0? y[a] < y[b]: x[a] < x[b];
	return xk[_]*x[a] + yk[_]*y[a] < xk[_]*x[b] + yk[_]*y[b];
}
int dis(int &a, int &b){
	if(x[a] == x[b]) return y[b] - y[a] >> 1;
	if(y[a] == y[b]) return x[b] - x[a] >> 1;
	return x[b] - x[a];
}
struct cmp1{
	bool operator()(pair <int, int> &a, pair <int, int> &b){
		return dis(a.fi, a.se) > dis(b.fi, b.se);
	}
};
priority_queue <pair <int, int>, vector <pair <int, int>>, cmp1> d; //<id1,id2>
int lfind(int &x){
	if(ruin[x]) return x = lft[_][x]? lfind(lft[_][x]): 0;
	return x;
}
int rfind(int &x){
	if(ruin[x]) return x = rt[_][x]? rfind(rt[_][x]): 0;
	return x;
}
void add(pair <int, int> &k){
	if(y[k.fi] == y[k.se]) _ = 0;
	else if(x[k.fi] == x[k.se]) _ = 1;
	else if(team[k.se] == 'N') _ = 2;
	else if(team[k.fi] == 'N') _ = 3;
	else if(team[k.fi] == 'E') _ = 4;
	else _ = 5;
	if(tadd) k.fi = lft[_][k.fi], k.se = rt[_][k.se];
	if(lfind(k.fi) && rfind(k.se)) d.push(k);
}
int main(){
	n = read();
	for(int i = 1; i <= n; ++ i){
		x[i] = read(), y[i] = read(), team[i] = getchar();
		if(team[i] == 'N') a[1].push_back(i), a[2].push_back(i), a[3].push_back(i);
		else if(team[i] == 'S') a[1].push_back(i), a[4].push_back(i), a[5].push_back(i);
		else if(team[i] == 'E') a[0].push_back(i), a[2].push_back(i), a[4].push_back(i);
		else a[0].push_back(i), a[3].push_back(i), a[5].push_back(i);
	}
	for(_ = 0; _ <= 5; ++ _){
		sort(a[_].begin(), a[_].end(), cmp);
		for(int i = 0, j; i < a[_].size(); i = j){
			j = i + 1;
			while(j < a[_].size() && xk[_]*x[a[_][j]] + yk[_]*y[a[_][j]] == xk[_]*x[a[_][i]] + yk[_]*y[a[_][i]]) ++ j;
			if(i + 1 == j) continue;
			int p = -1, back = 0;
			for(int k = i; k < j; ++ k)
				if(team[a[_][k]] == t[_]){
					if(p != -1) lft[_][a[_][k]] = a[_][p];
					p = k, back = a[_][k];
				}
				else if(back && team[a[_][k - 1]] == t[_]){
					lft[_][a[_][k]] = a[_][p];
					d.push(make_pair(back, a[_][k]));
				}
			p = -1;
			for(int k = j - 1; k >= i; k --)
				if(team[a[_][k]] != t[_]){
					if(p != -1) rt[_][a[_][k]] = a[_][p];
					p = k;
				}
				else if(p != -1) p = -1;
		}
	}
	while(!d.empty()){
		pair <int, int> i = d.top();
		d.pop();
		while(ruin[i.fi] || ruin[i.se]){
			tadd = 0, add(i);
			if(d.empty()) break;
			i = d.top(), d.pop();
		}
		if(!i.fi || !i.se) break;
		if(!d.empty()){
			pair <int, int> j = d.top();
			while(dis(i.fi, i.se) == dis(j.fi, j.se)){
				if(!ruin[j.se] && !ruin[j.fi]) b.push_back(j.fi), b.push_back(j.se), tadd = 1;
				else tadd = 0;
				add(j), d.pop();
				if(d.empty()) break;
				j = d.top();
			}
		}
		b.push_back(i.fi), b.push_back(i.se), tadd = 1, add(i);
		for(int i: b) ruin[i] = 1;
		b.clear();
	}
	for(int i = 1; i <= n; ++ i) if(!ruin[i]) write(i), putchar('\n');
	return 0;
}
```

---

## 作者：羊叫兽同学 (赞：3)

提供一种没什么思维含量但代码恶心的做法，本人写了 6 个 kb，如果不想写可以不看。当然也有可能是做法没有问题我实现太烂了。

考虑什么样的船会撞上。显然如果两艘船会相撞，必然有在任意它们还活着的时刻，它们两点所确定的直线平行或重合于直线 $x=0$ 或 $y=0$ 或 $y=x$ 或 $y=-x$，并且它们的行驶方向与这条直线方向相符合。

首先我们可以 $O(N^3)$ 地去做。具体来说，每次枚举两艘还活着的船，判断它们是否会相撞及相撞时间，如果找不到会相撞的就退出，找到了就在所有相撞时间中取最小值，模拟出来哪些船会撞上。最多做 $O(N)$ 轮，每次复杂度 $O(N^2)$，故总复杂度为 $O(N^3) $。

这个做法可以优化到 $O(N^2 \log N)$。记 N 为北方向，S 为南方向，W 为西方向，E 为东方向。对于 N-S，N-W，N-E，S-W，S-E，W-E 六种相撞可能，每一种开 $O(N)$ 个 set。对于每一艘船，以 N 方向为例，若它的点为 $(x,y)$，把它分别塞入 N-S 的第 $y$ 个 set 里，N-W 的第 $x+y$ 个 set 里，N-E 的第 $x-y$ 个 set 里，由于值域很大，这里要离散化。之后你寻找两艘船是否相撞及相撞时间的过程就可以优化成你枚举每一个船，然后在对应的三个 set 里分别 lower_bound 一个第一个与他相撞的船。这样就把每一轮复杂度优化到了 $O(N \log N) $。

考虑正解。显然我们需要支持删除元素的操作。如果我们要把每一艘船的信息都算出来，那要么每次要重新算一遍，要么删除元素时复杂度不能接受。于是我们对于每一个 set，只算其中可能成为答案的船的信息。我们以 S-E 的某一条直线的 set 为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/mcixdfsq.png)

发现第 3 艘、第 4 艘、第 5 艘船全部会和第 6 艘配对，但显然第 5 艘的答案一定比第 3 艘、第 4 艘小。

所以对于一个连续的向东段，我们只计算最后一个就行了。

对于 S-E 情况，刚开始先处理一遍，把所有连续向东段的最后一个的答案连同编号扔进优先队列里。

然后每次取出优先队列队首元素，考虑到有可能有三艘甚至四艘的船同时相撞，我们先只是把元素记录下来，从优先队列里删除，而不从 set 里删除。之后一直删队首直到队首的时间大于当前时间。

然后把刚才记录的那些船在 set 里删除。仍以 S-E 为例，如果船为 E，那么删除它会更新答案当且仅当它在 set 里的上一个为 E 且下一个为 S。如果船为 S，它会更新答案其实也是上一个为 E 且下一个为 S。可以结合上面的图来理解。之后，把新得到的可能成为最小值的答案扔进优先队列即可。非 S-E 情况也类似去做即可。总时间复杂度显然为 $O(n \log n)$。

代码（写的太烂了轻喷）


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<set>
#include<unordered_map>
#include<queue>
#include<vector>
#define int long long
#define pr pair<int,int> 
#define ppr pair<int,pr> 
#define is insert
#define mkp make_pair
#define it set<pr >::iterator
#define mkpid(a,b) a<b?mkp(a,b):mkp(b,a)
using namespace std;
const int N=1e6+10;
const int inf=0x3f3f3f3f3f3f3f3f;
int n,m,s,l,way[100],X[N],Y[N],OP[N],TPLS;
bool book[N];
unordered_map<int,int>LS;
set<pr >NS[N],WE[N],NW[N],NE[N],SW[N],SE[N];
//set<ppr>NST[N],WET[N],NWT[N],NET[N],SWT[N],SET[N];
priority_queue<ppr,vector<ppr>,greater<ppr> >q;
vector<int>now;
int ls(int x)
{
	if(!LS[x])
		LS[x]=++TPLS;
	return LS[x];
}
inline int read()
{
	char x=getchar();
	int ans=0,f=1;
	while(x<'0'||x>'9')
	{
		if(x=='-')
			f=-f;
		x=getchar();
	}
	while(x>='0'&&x<='9')
	{
		ans=(ans<<1)+(ans<<3)+(x^48);
		x=getchar();
	}
	return ans*f;
}
inline int buildway()
{
	char x=getchar();
	while(!way[(int)x])
		x=getchar();
	return way[(int)x];
}
void outpr(pr a)
{
	cout<<"VAL"<<a.first<<" "<<"ID"<<a.second<<endl;
}
void buildsmway(set<pr>a)
{
	for(it p=a.begin();p!=a.end();p++)
	{
		int val=p->first,id=p->second;
		if(!(OP[id]&1))
		{
			it p2=p;
			p2++;
			if(p2!=a.end()&&OP[p2->second]!=OP[id])
			{
				q.push(mkp((p2->first-val)>>1,mkpid(id,p2->second)));
//				cout<<"   "<<id<<" "<<p2->second<<endl;
			}
		}
	}
}
void build_l(set<pr>a)
{
	for(it p=a.begin();p!=a.end();p++)
	{
		int val=p->first,id=p->second;
		if(OP[id]>2)
		{
			it p2=p;
			p2++;
			if(p2!=a.end()&&OP[p2->second]!=OP[id])
			{
				q.push(mkp(p2->first-val,mkpid(id,p2->second)));
//				cout<<id<<" "<<p2->second<<endl;
			}
		}
	}
}
void buildl_(set<pr>a)
{
	if(a.empty())
		return ;
	it p=a.end();
	p--;
	while(1)
	{
		int val=p->first,id=p->second;
		if(OP[id]>2)
		{
			it p2=p;
			p2--;
			if(p!=a.begin()&&OP[p2->second]!=OP[id])
			{
				q.push(mkp(val-p2->first,mkpid(id,p2->second)));
//				cout<<id<<" "<<p2->second<<endl;
			}
		}
		if(p==a.begin())
			break;
		p--;
	}
}
ppr buildmi(set<ppr>a)
{
	while(!a.empty())
	{
		ppr p=*a.begin();
		int x=p.second.first,y=p.second.second;
		if(book[x]||book[y])
		{
			a.erase(a.begin());
			continue;
		}
		return p;
	}
	return mkp(inf,mkp(inf,inf));
}
void delsm(set<pr>&a,int val,int id)
{
	it suf,pre;
	pre=suf=a.find(mkp(val,id));
	if(pre==a.end())
		return ;
	if(pre--!=a.begin()&&++suf!=a.end())
	{
		if(!(OP[id]&1))
		{
			if(OP[suf->second]!=OP[id]&&OP[pre->second]==OP[id])
				q.push(mkp((suf->first-pre->first)>>1,mkpid(suf->second,pre->second)));
		}
		else
		{
			if(OP[suf->second]==OP[id]&&OP[pre->second]!=OP[id])
				q.push(mkp((suf->first-pre->first)>>1,mkpid(suf->second,pre->second)));
		}
	}
	a.erase(mkp(val,id));
}
void del_l(set<pr>&a,int val,int id)
{
	it suf,pre;
//	cout<<"SIZ"<<a.size()<<endl;
//	cout<<val<<" "<<id<<endl;
	pre=suf=a.find(mkp(val,id));
	if(pre==a.end())
		return ;
	if(pre--!=a.begin()&&++suf!=a.end())
	{
//		outpr(*pre);
//		outpr(*suf);
		if(OP[id]>2)
		{
			if(OP[suf->second]!=OP[id]&&OP[pre->second]==OP[id])
				q.push(mkp(suf->first-pre->first,mkpid(suf->second,pre->second)));
		}
		else
		{
			if(OP[suf->second]==OP[id]&&OP[pre->second]!=OP[id])
				q.push(mkp(suf->first-pre->first,mkpid(suf->second,pre->second)));
		}
	}
	a.erase(mkp(val,id));
}
void dell_(set<pr>&a,int val,int id)
{
	it suf,pre;
	pre=suf=a.find(mkp(val,id));
	if(pre==a.end())
		return ;
	if(pre--!=a.begin()&&++suf!=a.end())
	{
		if(OP[id]>2)
		{
			if(OP[suf->second]==OP[id]&&OP[pre->second]!=OP[id])
				q.push(mkp(suf->first-pre->first,mkpid(suf->second,pre->second)));
		}
		else
		{
			if(OP[suf->second]!=OP[id]&&OP[pre->second]==OP[id])
				q.push(mkp(suf->first-pre->first,mkpid(suf->second,pre->second)));
		}
	}
	a.erase(mkp(val,id));
}
bool gettop()
{
	while(!q.empty())
	{
		ppr a=q.top();
		if(book[a.second.second]||book[a.second.first])
		{
			q.pop();
			continue;
		}
		return true;
	}
	return false;
}
signed main()
{
	n=read();
	way['N']=1;
	way['S']=2;
	way['W']=3;
	way['E']=4;
	for(int i=1;i<=n;i++)
	{
		int x,y,op;
		x=X[i]=read(),y=Y[i]=read(),op=OP[i]=buildway();
		if(op==1)
		{
			NS[ls(x)].is(mkp(y,i)); NW[ls(x+y)].is(mkp(x,i)); NE[ls(x-y)].is(mkp(x,i));
		}
		if(op==2)
		{
			NS[ls(x)].is(mkp(y,i)); SW[ls(x-y)].is(mkp(x,i)); SE[ls(x+y)].is(mkp(x,i));
		}
		if(op==3)
		{
			WE[ls(y)].is(mkp(x,i)); NW[ls(x+y)].is(mkp(x,i)); SW[ls(x-y)].is(mkp(x,i));
		}
		if(op==4)
		{
			WE[ls(y)].is(mkp(x,i)); NE[ls(x-y)].is(mkp(x,i)); SE[ls(x+y)].is(mkp(x,i));
		}
	}
	for(int i=1;i<=TPLS;i++)
	{
		buildsmway(NS[i]);
		buildsmway(WE[i]);
		build_l(NE[i]);
		build_l(SE[i]);
		buildl_(NW[i]);
		buildl_(SW[i]); 
	}
	q.push(mkp(inf,mkp(0,0)));
	while(!q.empty())
	{
		gettop();
		int tim=q.top().first;
//		cout<<tim<<endl;
		if(tim==inf)
			break;
		now.clear();
		while(true)
		{
			gettop();
			ppr TOP=q.top();
			if(TOP.first==tim)
			{
				now.push_back(TOP.second.first);
				now.push_back(TOP.second.second);
				q.pop();
			}
			else
				break;
		}
		for(int i:now)
		{
			if(!book[i])
			{
//				cout<<"I"<<i<<endl;
				book[i]=1;
				int x=X[i],y=Y[i];
				if(OP[i]==1)
				{
//					cout<<"LS:"<<ls(x-y)<<endl;
					delsm(NS[ls(x)],y,i); dell_(NW[ls(x+y)],x,i); del_l(NE[ls(x-y)],x,i);
				}
				if(OP[i]==2)
				{
					delsm(NS[ls(x)],y,i); dell_(SW[ls(x-y)],x,i); del_l(SE[ls(x+y)],x,i);
				}
				if(OP[i]==3)
				{
					delsm(WE[ls(y)],x,i); dell_(NW[ls(x+y)],x,i); dell_(SW[ls(x-y)],x,i);
				}
				if(OP[i]==4)
				{
//					cout<<"LS:"<<ls(x-y)<<endl;
					delsm(WE[ls(y)],x,i); del_l(NE[ls(x-y)],x,i); del_l(SE[ls(x+y)],x,i);
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!book[i])
			printf("%lld\n",i);
	}
}
```

---

## 作者：Starriverlight (赞：2)

疯狂STL，赛时一遍打过。

## 思路

我们可将相撞分为 $6$ 类。

![](https://cdn.luogu.com.cn/upload/image_hosting/p2hs2e8b.png)

（示意图）

对于 $6$ 类相撞单独考虑，以第一种 E,S 为例，只有在同一副对角线上的点才可能相撞，于是就对每一条副对角线都开一个 set 维护其点集，按某个坐标排序（比如这里可以用横坐标）。

因为我们一开始并不知道每个点应该是如何相撞，一个点也应该是消失于第一次相撞，这样对于某一次相撞，若它的点已经在之前的相撞中消失了，就不能记算了。因此，我们应该对于相撞时间从小到大处理。

我们再用一个 set 维护**所有**相撞，动态维护每种类型的相撞，按相撞时间排序。再以 E,S 举例，将每条副对角线的 set **相邻的**，可以撞在一起的放入 set 中，因为如上所述，不相邻的相撞得在相邻的算完之后才轮得到它。

每次就把维护所有相撞的 set 的第一个值取出，此时这个相撞的两个点都会没掉，那就得删掉它们在每一类相撞的 set 中对应的点与其对应产生的相撞。

可能会有同时相撞的，处理 set 第一个值时就先把当前所有与最小值相等的都取出再进行后续处理。

要注意算迎头相撞时相撞时间应除以 $2$。

建议：若对东南西北不太敏感，打的时候直接换成上下左右写可能会好想不少。

## AC code
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define ull unsigned long long
#define f(i,j,n) for(int i=j;i<=n;i++)
#define F(i,n,j) for(int i=n;i>=j;i--)
#define updmax(a,b) a=max(a,b)
#define updmin(a,b) a=min(a,b)
#define pb push_back
using namespace std;
namespace fsd{
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXSIZE,stdin),p1==p2)?EOF:*p1++)
	const int MAXSIZE=1<<20;
	char buf[MAXSIZE],*p1,*p2;
	inline int read(){
		int ak=0,ioi=1;char c=gc();
		while(!isdigit(c)){if(c=='-')ioi=-1;c=gc();}
		while(isdigit(c))ak=ak*10+(c^48),c=gc();
		return ak*ioi;
	}
	inline char readc(){
		char p=gc();
		while(!((p<='z'&&p>='a')||(p<='Z'&&p>='A'))){p=gc();}
		return p;
	}
}
using namespace fsd;
const int N=2e5+10;
map<int,int> mpdr,mpdl,mpdu,mplr;
int n,x[N],y[N];
char opt[N];
set<pair<int,pair<int,int> > >AL;
struct SE{
	set<pair<int,int> > s;
	char FR;
	bool isy=0;
	int isq=1;
	void insert(pair<int,int> t){
		s.insert(t);
	}
	void erase(int I){
		set<pair<int,int> >::iterator it;
		if(isy)it=s.lower_bound({y[I],0});
		else it=s.lower_bound({x[I],0});
		if(it!=s.begin()&&opt[I]!=FR&&opt[(*prev(it)).second]==FR)AL.erase({((*it).first-(*prev(it)).first)/isq,{(*prev(it)).second,(*it).second}});
		if(next(it)!=s.end()&&opt[I]==FR&&opt[(*next(it)).second]!=FR)AL.erase({((*next(it)).first-(*it).first)/isq,{(*it).second,(*next(it)).second}});
		if(it!=s.begin()&&next(it)!=s.end()&&opt[(*prev(it)).second]==FR&&opt[(*next(it)).second]!=FR)AL.insert({((*next(it)).first-(*prev(it)).first)/isq,{(*prev(it)).second,(*next(it)).second}});
		s.erase(it);
	}
	void build(){
		for(auto it=s.begin();it!=s.end();it++){
			if(it!=s.begin()){
				if(opt[(*prev(it)).second]==FR&&opt[(*it).second]!=FR){
					AL.insert({((*it).first-(*prev(it)).first)/isq,{(*prev(it)).second,(*it).second}});
				}
			}
		}
	}
}sdr[N],sdl[N],sur[N],sul[N],sdu[N],slr[N];
bool nal[N];
void insert(int i){
	if(opt[i]=='D'||opt[i]=='R')sdr[mpdl[x[i]+y[i]]].insert({x[i],i});
	if(opt[i]=='D'||opt[i]=='L')sdl[mpdr[x[i]-y[i]]].insert({x[i],i});
	if(opt[i]=='U'||opt[i]=='R')sur[mpdr[x[i]-y[i]]].insert({x[i],i});
	if(opt[i]=='U'||opt[i]=='L')sul[mpdl[x[i]+y[i]]].insert({x[i],i});
	if(opt[i]=='D'||opt[i]=='U')sdu[mpdu[y[i]]].insert({x[i],i});
	if(opt[i]=='L'||opt[i]=='R')slr[mplr[x[i]]].insert({y[i],i});
}
void erase(int i){
	nal[i]=1;
	if(opt[i]=='D'||opt[i]=='R')sdr[mpdl[x[i]+y[i]]].erase(i);
	if(opt[i]=='D'||opt[i]=='L')sdl[mpdr[x[i]-y[i]]].erase(i);
	if(opt[i]=='U'||opt[i]=='R')sur[mpdr[x[i]-y[i]]].erase(i);
	if(opt[i]=='U'||opt[i]=='L')sul[mpdl[x[i]+y[i]]].erase(i);
	if(opt[i]=='D'||opt[i]=='U')sdu[mpdu[y[i]]].erase(i);
	if(opt[i]=='L'||opt[i]=='R')slr[mplr[x[i]]].erase(i);
}
void gs(){
	n=read();
	f(i,1,n)y[i]=read(),x[i]=read(),opt[i]=readc();
	f(i,1,n){
		opt[i]=
		(
			opt[i]=='N'?'U':
			opt[i]=='S'?'D':
			opt[i]=='E'?'R':
			'L'
		);
	}
	f(i,1,n)if(!mpdr.count(x[i]-y[i]))mpdr[x[i]-y[i]]=mpdr.size()+1;
	f(i,1,n)if(!mpdl.count(x[i]+y[i]))mpdl[x[i]+y[i]]=mpdl.size()+1;
	f(i,1,n)if(!mpdu.count(y[i]))mpdu[y[i]]=mpdu.size()+1;
	f(i,1,n)if(!mplr.count(x[i]))mplr[x[i]]=mplr.size()+1;
	for(auto v:mpdr)sdl[v.second].FR='D',sur[v.second].FR='R';
	for(auto v:mpdl)sdr[v.second].FR='D',sul[v.second].FR='L';
	for(auto v:mpdu)sdu[v.second].FR='D',sdu[v.second].isq=2;
	for(auto v:mplr)slr[v.second].FR='R',slr[v.second].isy=slr[v.second].isq=2;
	f(i,1,n)insert(i);
	for(auto v:mpdr)sdl[v.second].build(),sur[v.second].build();
	for(auto v:mpdl)sdr[v.second].build(),sul[v.second].build();
	for(auto v:mpdu)sdu[v.second].build();
	for(auto v:mplr)slr[v.second].build();
	while(!AL.empty()){
		set<int> Dl;
		int V;
		do{
			auto v=*AL.begin();AL.erase(AL.begin());
			V=v.first;
			Dl.insert(v.second.first),Dl.insert(v.second.second);
		}while(!AL.empty()&&(*AL.begin()).first==V);
		for(auto v:Dl)erase(v);
	}
	f(i,1,n)if(!nal[i])printf("%d\n",i);
}
#define XQZ
signed main(){
#ifndef XQZ
	freopen("sea.in","r",stdin);
	freopen("sea.out","w",stdout);
#endif
#ifdef NXD
	int t=0;cin>>t;while(t--)
#endif
		gs();
	return 0;
}
//啊?????????????????????????
```

---

## 作者：chenzhaoxu2027 (赞：1)

# 题意

[link](https://www.luogu.com.cn/problem/P10801)

# 分析

神秘题目。

我们首先发现一个难点就是有可能一次撞船导致另一艘船存活从而引发连锁反应。于是我们只能一次一次地模拟最早一次的撞船然后更新时间去继续模拟撞船。

因此我们使用堆维护这一过程，以时间为第一关键字，撞船的两方为第二关键字将所有可能的撞船事件加入堆中。当然不能全加，我们只能挑选那些**可能是最早的**撞船事件加入堆中。

考虑如何维护这一过程，我们使用 6 个 vector，分别存储北南、东西、北西、北东、东南、西南的船只（即一个 vector 存储两类船）。然后，对于“北南”的 vector 来说，想要撞击必然 x 坐标相等。

因此如果我们按 x 坐标为第一关键字，y 坐标为第二关键字对所有船只排序，那么第一次北南撞船一定是发生于某两个在这个 vector 中相邻的南北船只。因此将**此时相邻的可能发生撞击的南北船只**加入堆中。对其他五个 vector 同样操作即可完成初始的建堆。

然后就是怎么快速更新了。由于某一个船只的沉没，我们可以看作在 vector 中删去此元素。由刚刚我们所说的，这导致 vector 产生了一个新的相邻的候选撞船对，因此我们只需要将这个新的撞船对加入堆中。所以我们对 vector 同步开一个双向链表即可快速维护。

综上，这个恶心人的题目就做完了。时间复杂度不难发现是 $O(n \log n)$ 的。

# 代码

包括一些调试注释和解释注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
//0:NS,1:EW,2:NW,3:NE,4:ES,5:WS
vector<int> ships[10];
int n;
int x[200005],y[200005],o[200005];
priority_queue<pair<int,pair<int,int> >,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > pq;
int O;
int R[200005][7]; 
int L[200005][7];//链表 
int lives[200005];
vector<int> ST;
bool cmp(int a,int b){
	if(O==0){
		return (x[a]==x[b]?y[a]<y[b]:x[a]<x[b]); 
	} 
	if(O==1){
		return (y[a]==y[b]?x[a]<x[b]:y[a]<y[b]); 
	}
	if(O==2||O==4){
		return (x[a]+y[a]==x[b]+y[b]?x[a]<x[b]:x[a]+y[a]<x[b]+y[b]);
	}
	if(O==3||O==5){
		return (x[a]-y[a]==x[b]-y[b]?x[a]<x[b]:x[a]-y[a]<x[b]-y[b]);
	}
}//对同一碰撞形式进行排序，使得相邻的、方向不同的船能够碰撞，从而直接插入优先队列。 
void PUSH(int a,int b){
	if(a<1||b<1||a>n||b>n||lives[a]||lives[b]||o[a]==o[b]){
		return;
	}
	if(o[a]==1&&o[b]==0){
		if(x[a]!=x[b]){
			return;
		}
//		cout<<"add case 1 crash in tick"<<max(y[a]-y[b],y[b]-y[a])/2<<",ships are "<<a<<" with "<<b<<"\n";
		pq.push({max(y[a]-y[b],y[b]-y[a])/2,{a,b}});
		return;
	}
	if(o[a]==3&&o[b]==2){
		if(y[a]!=y[b]){
			return;
		}
//		cout<<"add case 2 crash in tick"<<max(x[a]-x[b],x[b]-x[a])/2<<",ships are "<<a<<" with "<<b<<"\n";
		pq.push({max(x[a]-x[b],x[b]-x[a])/2,{a,b}});
		return;
	}
	if(o[a]==0&&o[b]==2||o[a]==3&&o[b]==1||o[a]==1&&o[b]==2||o[a]==3&&o[b]==0){//注意撞船具有方向性，由于排序的缘故，这里必然会有x[a]<x[b]。
		if((o[a]==0&&o[b]==2||o[a]==3&&o[b]==1)&&x[a]+y[a]!=x[b]+y[b]){
			return;
		}
		if((o[a]==1&&o[b]==2||o[a]==3&&o[b]==0)&&x[a]-y[a]!=x[b]-y[b]){
			return;
		}
//		cout<<"add case 3 crash in tick"<<max(x[a]-x[b],x[b]-x[a])<<",ships are "<<a<<" with "<<b<<"\n";
//		cout<<"the same sum is "<<x[a]+y[a]<<"\n";
		pq.push({max(x[a]-x[b],x[b]-x[a]),{a,b}});
		return;
	}
	return;
}//处理ab两船是否碰撞并压堆。 
void DELETE(int a){
	if(lives[a]){
		return;
	}
//	cout<<"the ship No"<<a<<" is dead.\n";
	lives[a]=1;
	if(o[a]==0){
		PUSH(L[a][0],R[a][0]);
		R[L[a][0]][0]=R[a][0];
		L[R[a][0]][0]=L[a][0];
		PUSH(L[a][2],R[a][2]);
		R[L[a][2]][2]=R[a][2];
		L[R[a][2]][2]=L[a][2];
		PUSH(L[a][3],R[a][3]);
		R[L[a][3]][3]=R[a][3];
		L[R[a][3]][3]=L[a][3];
	}
	else if(o[a]==1){
		PUSH(L[a][0],R[a][0]);
		R[L[a][0]][0]=R[a][0];
		L[R[a][0]][0]=L[a][0];
		PUSH(L[a][4],R[a][4]);
		R[L[a][4]][4]=R[a][4];
		L[R[a][4]][4]=L[a][4];
		PUSH(L[a][5],R[a][5]);
		R[L[a][5]][5]=R[a][5];
		L[R[a][5]][5]=L[a][5];
	}
	else if(o[a]==2){
		PUSH(L[a][1],R[a][1]);
		R[L[a][1]][1]=R[a][1];
		L[R[a][1]][1]=L[a][1];
		PUSH(L[a][2],R[a][2]);
		R[L[a][2]][2]=R[a][2];
		L[R[a][2]][2]=L[a][2];
		PUSH(L[a][5],R[a][5]);
		R[L[a][5]][5]=R[a][5];
		L[R[a][5]][5]=L[a][5];
	}
	else{
		PUSH(L[a][1],R[a][1]);
		R[L[a][1]][1]=R[a][1];
		L[R[a][1]][1]=L[a][1];
		PUSH(L[a][3],R[a][3]);
		R[L[a][3]][3]=R[a][3];
		L[R[a][3]][3]=L[a][3];
		PUSH(L[a][4],R[a][4]);
		R[L[a][4]][4]=R[a][4];
		L[R[a][4]][4]=L[a][4];
	}
}//对弹堆元素进行处理。 
int main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0);
//	cout.tie(0);
//	freopen("sea.in","r",stdin);
//	freopen("sea.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		char C;
		cin>>x[i]>>y[i]>>C;
		if(C=='N'){
			o[i]=0;
			ships[0].push_back(i);
			ships[2].push_back(i);
			ships[3].push_back(i);
		}
		else if(C=='S'){
			o[i]=1;
			ships[0].push_back(i);
			ships[4].push_back(i);
			ships[5].push_back(i);
		}
		else if(C=='W'){
			o[i]=2;
			ships[1].push_back(i);
			ships[2].push_back(i);
			ships[5].push_back(i);
		}
		else{
			o[i]=3;
			ships[1].push_back(i);
			ships[3].push_back(i);
			ships[4].push_back(i);
		}
//		cout<<"ships "<<i<<":"<<x[i]+y[i]<<"\n";
	}
	for(int o=0;o<6;o++){
		O=o;
		sort(ships[o].begin(),ships[o].end(),cmp);
//		cout<<"Operation:"<<O<<"\n";
		for(int i=0;i<ships[o].size();i++){
//			if(x[ships[o][i]]+y[ships[o][i]]==78){
//				cout<<"ship:"<<ships[o][i]<<"\n"; 
//			}
			L[ships[o][i]][o]=(i==0?0:ships[o][i-1]);
			R[ships[o][i]][o]=(i==ships[o].size()-1?n+1:ships[o][i+1]);
//			cout<<L[ships[o][i]][o]<<" and "<<ships[o][i]<<" maybe crash\n";
			PUSH(L[ships[o][i]][o],ships[o][i]);
			//计算相撞时间插入优先队列。 
			//构建链表。
		}
	}
	while(pq.size()){
		//优先队列弹堆。 
		//同一时间的碰撞一起处理。 
		ST.clear();
		int t=pq.top().first;
//		cout<<"tick:"<<t<<"\n";
		while(pq.size()&&pq.top().first==t){
//			ST.push_back(pq.top().second);
			auto u=pq.top();
			pq.pop();
			if(lives[u.second.first]||lives[u.second.second]){
				continue;
			}
//			cout<<"crash:"<<u.second.first<<" "<<u.second.second<<"\n";
			ST.push_back(u.second.first);
			ST.push_back(u.second.second);
		}
		for(int v:ST){
			DELETE(v);//船的沉没
		}
	}
	//输出结果。 
	for(int i=1;i<=n;i++){
		if(!lives[i]){
			cout<<i<<"\n"; 
		}
	}
	return 0;
} 
```

# 后记

本人在考场上没调出来，遗憾 300->200。

---

## 作者：0xyz (赞：0)

一场模拟赛，只切了这一题，所以写一下题解。

不难发现如果一条船没有沉没，它在 $t$ 时刻的位置可以 $O(1)$ 确定。对于这种有若干个轨迹互不干扰的点，并且看情况是否对单点进行删除的问题，比如 [P5688](https://www.luogu.com.cn/article/i3u99efh)，一个很常见的做法是按照时间顺序从小到大，运用优先队列维护可能最早被删除的点。每次取出合法的队头将其删除，并且将新造成的可能最早被删除的点加进优先队列。重复这一操作，直到无法再删点为止。更深入地来讲，对于那些可能有关系的点，我们将它们放进若干集合中，使得同一个集合中的点互相有关系，不同集合中的点没有关系，一个点可能同时属于多个集合中。每次删点时，就在所有它存在的集合中将它删去，并且在这些集合中更新。

在这题中我们考虑什么样的船可能最快沉没。二维太麻烦了，所以先考虑一维的情况，即每条船只能往东走或者往西走。由于往东走、往西走都不会改变 $y$ 的大小，所以我们按照 $y$ 来分类。在同一类中，我们可以按照 $x$ 的大小来排序，对于两个不相邻的船，它们想要互相撞击而沉没，必然需要它们中间的船全部沉没，所以必然不可能是最早沉没的船。所以具体做法就是按照 $y$ 的值分类，将每类按照 $x$ 来排序，排完序后将相邻的船撞船的事件放进优先队列里，每一次弹出队头直到找到一个撞船双方都还没有沉没的事件，并且继续寻找与这个事件同时间的所有撞船事件，寻找完后把涉及到这些事件的所有船全部删除，并标记它们已经沉没，最后在它们所在的类中将它们删除，它们原本东边和西边最近的船变为了新的相邻船，所以加进优先队列里。重复这个操作，直到不再有撞船事件为止。每一类支持删除单点和动态排序，可以用 std::set 维护。

现在考虑二维的情况。我们需要对于每个方向的撞击都分个类，一共要在六个方面分类：$NS\to y_i,EW\to x_i,NE\to x_i-y_i,ES\to x_i+y_i,SW\to x_i-y_i,WN\to x_i+y_i$。分完类后，在每类中，除了 $EW$ 是按照 $y_i$ 从小到大排序之外，其它五类全部按照 $x_i$ 从小到大排序，并且扔进优先队列里的依然只有相邻的船。我们以 $NE$ 为例，将其中一类的船重新编号为 $1\sim m$，若船 $i<j$ 不相邻且会相撞，则 $d_i=E,d_j=N$，必然存在 $i\le k<j$ 使得 $d_k=E,d_{k+1}=N$，则船 $k$ 与 $k+1$ 更早相撞，所以不相邻的船必然不会扔进优先队列里。其他类同理。

假设船在 $d$ 维运动，一共有 $2d$ 个方向，撞击需要分 $2d^2-d$ 种类，每进行一次删除，在这 $2d^2-d$ 类船最多产生一个新的撞船事件，加进优先队列里，所以优先队列的进队次数最多 $O(d^2n)$ 次，时间复杂度 $O(d^2n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int _=2e5+5,inf=2e9;
int n,a[_],b[_],w[_],e[_];
char c[_];
map<int,set<pair<int,int> > >d[6];
struct P{
	int a,b,c;
	bool operator <(const P v)const{return a>v.a;}
};
priority_queue<P>q,qq;
inline int gft(int i,int x,int y){
	int t=0;
	if(c[i]=='N')t=b[i]-y;
	else if(c[i]=='S')t=y-b[i];
	else if(c[i]=='W')t=a[i]-x;
	else t=x-a[i];
	if(t<=0)return inf;
	else return t;
}
inline int get(int i,int j){
	if(c[i]==c[j])return inf;
	if(e[i]&&e[j]){
		if(a[i]!=a[j])return inf;
		else return max(gft(i,a[i],(b[i]+b[j])/2),gft(j,a[j],(b[i]+b[j])/2));
	}
	if(!e[i]&&!e[j]){
		if(b[i]!=b[j])return inf;
		else return max(gft(i,(a[i]+a[j])/2,b[i]),gft(j,(a[i]+a[j])/2,b[j]));
	}
	if(e[i]&&!e[j]){
		int x=gft(i,a[i],b[j]),y=gft(j,a[i],b[j]);
		if(x!=y)return inf;
		else return x;
	}
	if(!e[i]&&e[j]){
		int x=gft(i,a[j],b[i]),y=gft(j,a[j],b[i]);
		if(x!=y)return inf;
		else return x;
	}
}
inline void del(int i){
	w[i]=1;
	set<pair<int,int> >::iterator p,j,k;
	int x,y,X=(c[i]=='S')||(c[i]=='E'),Y=(c[i]=='S'||c[i]=='W');
	if(e[i]){
		p=d[0][a[i]].lower_bound({b[i],i});
		if(p!=d[0][a[i]].begin()){
			j=k=p;j--;k++;
			if(k!=d[0][a[i]].end())x=(*j).second,y=(*k).second,q.push({get(x,y),x,y});
		}
		d[0][a[i]].erase(p);
	}else{
		p=d[1][b[i]].lower_bound({a[i],i});
		if(p!=d[1][b[i]].begin()){
			j=k=p;j--;k++;
			if(k!=d[1][b[i]].end())x=(*j).second,y=(*k).second,q.push({get(x,y),x,y});
		}
		d[1][b[i]].erase(p);
	}
	p=d[2+X][a[i]+b[i]].lower_bound({a[i],i});
	if(p!=d[2+X][a[i]+b[i]].begin()){
		j=k=p;j--;k++;
		if(k!=d[2+X][a[i]+b[i]].end())x=(*j).second,y=(*k).second,q.push({get(x,y),x,y});
	}
	d[2+X][a[i]+b[i]].erase(p);
	p=d[4+Y][a[i]-b[i]].lower_bound({a[i],i});
	if(p!=d[4+Y][a[i]-b[i]].begin()){
		j=k=p;j--;k++;
		if(k!=d[4+Y][a[i]-b[i]].end())x=(*j).second,y=(*k).second,q.push({get(x,y),x,y});
	}
	d[4+Y][a[i]-b[i]].erase(p);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i]>>c[i];
		e[i]=(c[i]=='N'||c[i]=='S');
		if(e[i])d[0][a[i]].insert({b[i],i});
		if(!e[i])d[1][b[i]].insert({a[i],i});
		if(c[i]=='N'||c[i]=='W')d[2][a[i]+b[i]].insert({a[i],i});
		else d[3][a[i]+b[i]].insert({a[i],i});
		if(c[i]=='N'||c[i]=='E')d[4][a[i]-b[i]].insert({a[i],i});
		else d[5][a[i]-b[i]].insert({a[i],i});
	}
	for(int i=0;i<6;i++)
		for(auto j:d[i]){
			vector<int>v;
			for(auto k:j.second)v.push_back(k.second);
			for(int k=1;k<v.size();k++)q.push({get(v[k-1],v[k]),v[k-1],v[k]});
		}
	while(q.size()){
		set<int>t;
		P x=q.top();q.pop();
		if(x.a==inf)break;
		if(w[x.b]||w[x.c])continue;
		t.insert(x.b);t.insert(x.c);
		while(q.size()){
			P y=q.top();
			if(y.a!=x.a)break;
			q.pop();
			if(w[y.b]||w[y.c])continue;
			t.insert(y.b);t.insert(y.c);
		}
		for(auto i:t)del(i);
	}
	for(int i=1;i<=n;i++)
		if(!w[i])cout<<i<<'\n';
	return 0;
}
```

---


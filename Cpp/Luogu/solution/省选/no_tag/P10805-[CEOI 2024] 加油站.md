# [CEOI 2024] 加油站

## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T2「[Petrol stations](https://ceoi2024.fi.muni.cz/page/tasks/statements/stations.pdf)」**

捷克的高速公路网络由 $N$ 个城市和 $N-1$ 条路组成，每条路的长度（公里）已知。我们知道任意两个城市之间只有一条路径。此外，每个城市恰好有一个加油站，其他地方没有。

有一天，许多人决定开车旅行。总共有 $N^2$ 辆车在路上。奇怪的是，对于每个有序城市对 $(a, b)$，恰好有一辆车从城市 $a$ 开往城市 $b$，沿着这两个城市之间唯一的路径行驶。由于捷克人全都开斯柯达车，每辆车的油箱容量都是 $K$ 升，并且每公里消耗一升汽油。出发前，每辆车的油箱都是满的。此外，捷克人非常有规律。由于懒惰，他们只在汽油不足以到达下一个城市时才加油（油箱为空时可以进入城市）。一旦他们被迫停在加油站，他们总是把油箱加满。

捷克税务部门想知道当天每个加油站停了多少辆车。鉴于这种可预测的行为，你应该能够轻松计算出来。

## 说明/提示

**样例解释 1**

有 $3$ 座城市呈直线排列，连接它们的道路长度为 $1$，油箱容量为 $1$ 升。只有在两个外围城市之间行驶的汽车会在中间城市加油。

**样例解释 2**

有 $6$ 个城市呈直线排列，油箱容量为 $2$ 升。许多汽车需要在城市 $3$ 和城市 $4$ 加油。这是有道理的，因为城市 $3$ 和城市 $4$ 之间的道路长度为 $2$ 公里。

对于所有输入数据，满足：
- $2 \leq N \leq 70\,000$
- $1 \leq K \leq 10^9$
- $0 \leq l_i \leq K\ (0 \leq i \leq N-2)$

令 $D$ 表示连接到单个城市的道路的最大数量。详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :--: | :--: | :--: |
|  $1$  | $N \leq 1\,000, K \leq 1\,000$ | $18$  |
|  $2$  | $D\le 2$ 且 $l_i = 1\ (0 \leq i \leq N-2)$ | $8$ |
|  $3$  | $D\le 2$| $10$ |
|  $4$  | $K\leq 10, D\leq 10$ | $12$ |
|  $5$  | $K\leq 10$ | $17$ |
|  $6$  | 无附加限制| $35$ |

## 样例 #1

### 输入

```
3 1
0 1 1
1 2 1```

### 输出

```
0
2
0```

## 样例 #2

### 输入

```
6 2
0 1 1
1 2 1
2 3 1
3 4 2
4 5 1```

### 输出

```
0
3
3
12
8
0```

# 题解

## 作者：tzl_Dedicatus545 (赞：4)

以及 ppip 是什么啊？？？？他那个题解我现在还没看懂。误导我这种小朋友有意思吗？

我的做法大概只需要点分治和树状数组，是不是很纯良！！！1

但是我树状数组 $n$ 写小了，调了 1h，怎么回事捏？

Page 3.

首先我们点分治，计算经过分治重心 $r$ 的方案数，经典的，我们不考虑算重（实际上两个到根的链在一个子树内），而是对每个子树做容斥。

我们对 $u\to r$ 和 $r \to v$ 产生的加油分别计算，特别的，$r$ 本身的贡献我们在 $r\to v$ 部分计算。

对每个点，我们记录 $f_u$ 表示：如果在 $u$ 点加过油，下次加油在何处？（只考虑 $u\to r$）

显然 $f$ 只要在 $u\to r$ 的链上二分就行了，顺理成章的，$u \to r$ 部分可以 $\Theta(n\log n)$ 计算。

$r\to v$ 如何计算？首先在加油地点本身计算是毫无道理的（考虑目的地不同可能会导致加油地不同）

我们记 $h_u$ 表示有多少点 $u$ 最终会在 $fa_u$ 处加油，其对答案的贡献就是 $sz_u$。

这样就可以转移了啊！初始的第一次“经过 $r$”的贡献是简单的，接下来就只在 $v\to r$ 链上转移了，我们对此用数据结构维护就行了。

大概是单点加，区间查，但是树状数组不能动态开点/ll，所以你要写线段树。

时间复杂度 $\Theta(n\log^2{n})$。

---

## 作者：YZMyangziming (赞：2)

这道题目是一道点分治的好题，但是题解并不是很清晰。所以这里写一篇题解。     
首先考虑点分治路径上的点的贡献怎么处理。我们把一条路径上的贡献拆分成两个部分，第一个部分是从$u \to rt$，第二个部分是从$rt\to v$，考虑如何分开处理这两个部分。    
考虑从$u \to rt$这个部分。我们考虑每一个点有多少条路径需要在它这里加油（因为一定要到根节点，所以需不需要加油是可以提前确定的）。然后考虑贡献：因为我们考虑从同一棵子树中出来再回去的路径，所以从一个点过根的路径数量是一定的。就是分治的这颗树的大小。      
考虑从$r \to v$这个部分的答案怎么贡献。我们首先会记录每一个点作为起始点到根节点之后剩余的油量。对于每一个点，我们先计算这个点到根的距离是否小于$k$，如果小于$k$,那么我们就在根节点二分找到那些点能走到父亲但是走不到自己。如果大于$k$，那么我们就可以直接倍增找出上一次加油的位置，然后再进行转移即可。       
其实这道题目并不是很困难的，核心在于我们每一个点加油一定和要去到的点有关，可以理解为每一次加油是在边上的。然后分开处理从别的点到根和根到别的点的两种路径。因为从别的点到根只有一个父亲，可以直接转移；如果是从根到别的点，就在根一个点记录完整信息，然后枚举上一次在哪里加油即可。    
下面是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=7e4+5;
typedef long long ll;
int siz[N],son[N],rt;
int h[N],e[N<<1],ne[N<<1],tot,w[N<<1];
void add(int a,int b,int c){
    e[++tot]=b,ne[tot]=h[a],h[a]=tot,w[tot]=c;
}
bool vis[N];
void get_siz(int x,int fa){
    siz[x]=1;
    for(int i=h[x];i;i=ne[i])if(e[i]!=fa&&!vis[e[i]])
        get_siz(e[i],x),siz[x]+=siz[e[i]];
}
void find_rt(int x,int fa,const int&sum){
    son[x]=0;
    for(int i=h[x];i;i=ne[i])if(e[i]!=fa&&!vis[e[i]])
        find_rt(e[i],x,sum),son[x]=max(son[x],siz[e[i]]);
    son[x]=max(son[x],sum-siz[x]);
    if(son[x]<son[rt])rt=x;
}
int fa[N][20];
ll dis[N],ans[N];
int val[N];//到当前点剩余的油量
ll s[N];//前缀和
int K;
ll v[N];//从v出发满
int nxt[N];//往上跳的位置油的数量
int tmp[N],cur;//到分支中心油量的集合
int lg[N],T;
void get_dis(int x,int f){
    fa[x][0]=f;
    for(int i=1;i<=T;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=h[x];i;i=ne[i])if(e[i]!=f&&!vis[e[i]]){
        dis[e[i]]=dis[x]+w[i];
        get_dis(e[i],x);
    }
}
void dfs1(int x,int f){//从下往上
    if(dis[x]<=K)val[x]=K-dis[x],nxt[x]=rt;
    else{
        int y=x;
        for(int i=T;i>=0;i--)if(dis[x]-dis[fa[y][i]]<=K)y=fa[y][i];
        val[x]=val[y];nxt[x]=y;
    }
    v[x]=1;
    tmp[++cur]=val[x];
    for(int i=h[x];i;i=ne[i])if(e[i]!=f&&!vis[e[i]])dfs1(e[i],x);
    v[nxt[x]]+=v[x];
}
ll dp[N];//根节点到这个节点父节点经过这个点的路径在父亲加油的方案数
inline int query(ll x){
    if(tmp[cur]<x)return cur+1;
    int l=1,r=cur,ans;
    while(l<=r){
        int mid=l+r>>1;
        if(tmp[mid]>=x)ans=mid,r=mid-1;
        else l=mid+1;
    }return ans;
}
void dfs2(int x,int f){//从上往下
    //dis[x]>t且dis[fa[x][0]]<=t
    if(x^rt){
        dp[x]=query(dis[x])-query(dis[fa[x][0]]);
        // dp[x]=lower_bound(tmp+1,tmp+cur+1,dis[x])-lower_bound(tmp+1,tmp+cur+1,dis[fa[x][0]]);
        if(dis[x]>K){
            int y=x;
            for(int i=T;i>=0;i--)if(dis[x]-dis[fa[y][i]]<=K)y=fa[y][i];
            //y以上
            int z=fa[x][0];
            for(int i=T;i>=0;i--)if(dis[fa[x][0]]-dis[fa[z][i]]<=K)z=fa[z][i];
            //z以下
            dp[x]+=s[y]-s[z];
        }
    }
    s[x]=s[fa[x][0]]+dp[x];
    for(int i=h[x];i;i=ne[i])if(e[i]!=f&&!vis[e[i]])dfs2(e[i],x);
}
void get_ans(int x,int f,const int&sum){
    if(x^rt)ans[x]+=(v[x]-1)*sum;
    ans[fa[x][0]]+=dp[x]*siz[x]*(sum>0?1:-1);
    for(int i=h[x];i;i=ne[i])if(e[i]!=f&&!vis[e[i]])get_ans(e[i],x,sum);
}
void calc(int x,int sgn){
    cur=0;
    dfs1(x,0);
    sort(tmp+1,tmp+cur+1);
    dfs2(x,0);
    get_ans(x,0,sgn*siz[x]);
}
void solve(int x){
    vis[x]=1;s[x]=0;get_siz(x,0);dis[x]=0;
    T=lg[siz[x]];
    get_dis(x,0);calc(x,1);
    for(int i=h[x];i;i=ne[i])if(!vis[e[i]])calc(e[i],-1);
    for(int i=h[x];i;i=ne[i])if(!vis[e[i]]){
        rt=0;
        find_rt(e[i],0,siz[e[i]]);solve(rt);
    }
}
int n;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    dis[0]=-0x3f3f3f3f;
    son[0]=0x3f3f3f3f;
    cin>>n>>K;
    for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1;
    for(int i=1,u,v,w;i<n;i++)cin>>u>>v>>w,add(u+1,v+1,w),add(v+1,u+1,w);
    get_siz(1,0);rt=0;find_rt(1,0,siz[1]);
    solve(rt);
    for(int i=1;i<=n;i++)cout<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：_lbw_ (赞：2)

树上路径问题考虑点分治。

考虑把贡献转成点对点的形式，方便点分治。

对于路径 $u\to v\to v'$，其中 $v$ 和 $v'$ 相邻，且在 $v\to v'$ 时刚好需要加油时会产生以 $v$ 为根 $v'$ 子树大小的贡献。

再考虑如何刻画是否需要加油，这个不好刻画，让我们直接快进到点分治经过 $u$ 节点的贡献。

按照套路，子树对于子树内部算重的贡献可以容斥，我们只要考虑所有从底下到根再从根到底下的路径贡献就行。

dp 之，每个点记录跳到这里的点有多少个。

对于底下到根这一段，如果当前点 $p$ 到根的路径长度 $\leq k$ 直接跳上去，否则跳到最深的一个点 $v$ 满足 $dis(p,v)\leq k$ 的点，根据题意这个点会把油加满，注意此时不要算这个点的贡献，因为我们算的是路径经过 $u$ 的贡献。

对于根到底下这一段，依然是到 $k$ 时记录贡献，但是这里把值记录在 $dis > k$ 的点上，原因很简单，知道一个点要加油并不能确定它是往哪个方向走才需要加油的。

对于每个点有两个贡献来源：

- 根直接跳下来，可以直接在排序后的数组上二分。
- 从一个点跳下来，满足这种情况的点是一段祖先-后代链，这里需要维护一下树上 dp 值前缀和然后查询时树上倍增即可。

综上，时间复杂度 $\mathcal{O}(n\log^2n)$。


```cpp
#include<map>
#include<set>
#include<ctime>
#include<cmath>
#include<queue>
#include<bitset>
#include<cstdio>
#include<vector>
#include<random>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
#define I ll
#define her1 20081214
#define IV void
#define cht 1000000007
#define ld long double
#define Aestas16 392699
#define ull unsigned long long
#define cp(x,y)memcpy(x,y,sizeof y)
#define mem(x,val)memset(x,val,sizeof x)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=e[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register i64 i=j;i>=n;i--)
#define EL(i,now)for(register i64 i=first[now];i;i=e[i].nxt)
#define FL(i,j,n)for(register i64 i=j;i<=n;i++)
//#define D(i,j,n)for(int i=j;i>=n;i--)
//#define E(i,now)for(int i=first[now];i;i=e[i].nxt)
//#define F(i,j,n)for(int i=j;i<=n;i++)
//#define DL(i,j,n)for(register ll i=j;i>=n;i--)
//#define EL(i,now)for(register ll i=first[now];i;i=e[i].nxt)
//#define FL(i,j,n)for(register ll i=j;i<=n;i++)
ll read(){
	ll ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans*f;
}
#undef ll
#include "assert.h"
mt19937_64 rnd(her1);
#include "functional"
using i64 = long long;
const int maxn = 1e6+5;
i64 n,k,ans[maxn],os[maxn];vector<pair<i64,i64> >G[maxn];
i64 sub(i64 u,i64 v){if(os[u]>os[v])return os[v];return n-os[u];}
IV dfs(i64 u,i64 F){os[u]=1;for(auto[v,w]:G[u])if(v^F)dfs(v,u),os[u]+=os[v];}

bool vis[maxn];
i64 siz[maxn],mx[maxn],rt,all;
IV getrt(i64 u,i64 F){
	siz[u]=1;mx[u]=0;
	for(auto[v,w]:G[u])if(v!=F&&!vis[v]){
		getrt(v,u);siz[u]+=siz[v];
		mx[u]=max(mx[u],siz[v]);
	}
	mx[u]=max(mx[u],all-siz[u]);
	if(mx[u]<mx[rt])rt=u;
}

#define vi vector<i64>
vector<i64>Tmp,All;
i64 ts0,as0;
i64 Q(const vi&V,i64 l,i64 r){
	if(V.empty())return 0;
	i64 L=lower_bound(V.begin(),V.end(),l)-V.begin();
	i64 R=upper_bound(V.begin(),V.end(),r)-V.begin();
	return R-L;
}
bool ck(i64 D,i64 w){
	if(D%k==0&&w)return 1;
	return D%k+w>k;
}
i64 dp[maxn],ft[maxn][22],sum[maxn],sw[maxn];
IV getdis(i64 u,i64 F,i64 d){
	dp[u]=0;sw[u]=d;sum[u]=1;
	ft[u][0]=F;F(i,1,16)ft[u][i]=ft[ft[u][i-1]][i-1];
	for(auto[v,w]:G[u])if(v!=F&&!vis[v])
		getdis(v,u,d+w);
	if(sw[u]<=k)F(i,1,sum[u])Tmp.push_back(sw[u]);
	else{
		i64 p=u;
		D(i,16,0)if(sw[u]-sw[ft[p][i]]<=k)
			p=ft[p][i];
		sum[p]+=sum[u];
	}
}
i64 sdp[maxn],Rt;
IV Q(i64 u,i64 F,const vi&V,i64 mul){
	dp[u]=Q(V,k-sw[u]+1,k-sw[F]);

	if(sw[u]>k){
		i64 lp=u,rp=u;
		D(i,16,0){
			if(sw[ft[rp][i]]>=sw[u]-k)rp=ft[rp][i];
			if(sw[ft[lp][i]]>=sw[F]-k)lp=ft[lp][i];
		}
		dp[u]+=sdp[rp]-sdp[lp];
	}
	sdp[u]+=dp[u];
	ans[F]+=mul*dp[u]*sub(F,u);
	for(auto[v,W]:G[u])if(v!=F&&!vis[v])
		sdp[v]=sdp[u],Q(v,u,V,mul);
}
IV solve(i64 u){
	All.clear();Rt=u;
	F(i,0,16)ft[u][i]=u;sw[u]=0;
	for(auto[v,w]:G[u])if(!vis[v]){
		ts0=0;Tmp.clear();
		getdis(v,u,w);
		ans[v]+=(sum[v]-1)*sub(v,u);
		sort(Tmp.begin(),Tmp.end());
		for(auto x:Tmp)All.push_back(x);
		sdp[u]=sdp[v]=dp[u]=0;
		Q(v,u,Tmp,-1);
	}
	All.push_back(0);sort(All.begin(),All.end());
	
	for(auto[v,w]:G[u])if(!vis[v])
		sdp[u]=sdp[v]=dp[u]=0,Q(v,u,All,1);
}
IV calc(i64 u){
	vis[u]=1;solve(u);
	for(auto[v,w]:G[u])if(!vis[v]){
		mx[rt=0]=all=siz[v];
		getrt(v,u);getrt(rt,0);calc(rt);
	}
}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();k=read();
	F(i,1,n-1){
		i64 u=read()+1,v=read()+1,w=read();
		G[u].push_back({v,w});G[v].push_back({u,w});
	}
	dfs(1,0);

	mx[rt=0]=all=n;
	getrt(1,0);getrt(rt,0);calc(rt);
	
	F(i,1,n)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：Petit_Souris (赞：1)

击败了一年前 CSP 模拟赛的自己，帅。

路径问题，直接起手一个点分治。现在固定重心 $R$ 为根，统计连通块内的路径的贡献。可以拆成 $u\to R$ 和 $R\to v$ 两段考虑。

$u\to R$ 的部分是比较容易的，因为初始是满的。我们可以从 $u$ 往上跳到第一次加油的位置 $u'$，那么 $u'$ 往上的部分就和 $u'$ 开始的路径相同了。于是可以自底向上统计贡献，处理出向上第一次耗尽的点即可，用倍增就能搞定。

$R\to v$ 就有点难了，因为我现在初始值不一定是定值了。 这时候试着反过来，枚举每个点去算计算他的起点数量。

对于一个点 $x$，如果 $dis(R, x) < k$，那么所有可以从 $R$ 走到 $fa_x$ 但是走不到 $x$ 的点都会在 $x$ 加油。这个可以直接二分解决。

如果 $dis(R, x) \ge k$，那么类似地，会在 $x$ 加油的上一步是一段祖先后代链。因此可以转成 dp，从前缀和处贡献到 $x$。这里不需要额外的数据结构，因为顺序是从上到下的，因此可以直接维护。

时间复杂度 $\mathcal O(n \log ^ 2 n)$。

```cpp
#include <bits/stdc++.h>
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define pii pair<ll, ll>
#define rep(i, a, b) for(ll i = (a); i <= (b); ++i)
#define per(i, a, b) for(ll i = (a); i >= (b); --i)
#define pb push_back
bool Mbe;
ll read() {
    ll x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
void write(ll x) {
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
const ll N = 7e4 + 9;
ll n, K, ans[N], lg[N];
ll sz[N], ff[N], root, B;
Ve<pii> to[N];
bool vis[N];
void findrt(ll x, ll f, ll S) {
    sz[x] = 1, ff[x] = 0;
    for(auto [y, w] : to[x]) {
        if(y == f || vis[y]) continue;
        findrt(y, x, S);
        sz[x] += sz[y];
        ff[x] = max(ff[x], sz[y]);
    }
    ff[x] = max(ff[x], S - sz[x]);
    if(ff[x] < ff[root]) root = x;
}
ll fa[N], up[18][N], dis[N];
void dfs1(ll x, ll f) {
    fa[x] = f, up[0][x] = f, sz[x] = 1;
    rep(i, 1, B) up[i][x] = up[i - 1][up[i - 1][x]];
    for(auto [y, w] : to[x]) {
        if(y == f || vis[y]) continue;
        dis[y] = dis[x] + w;
        dfs1(y, x), sz[x] += sz[y];
    }
}
ll lft[N], nxt[N], dp1[N], dp2[N], tf[N], len, tor[N];
void dfs2(ll x) {
    if(dis[x] <= K) lft[x] = K - dis[x], nxt[x] = root;
    else {
        ll u = x; 
        per(i, B, 0) {
            if(up[i][u] && dis[x] - dis[up[i][u]] <= K) u = up[i][u];
        }
        nxt[x] = u, lft[x] = lft[u];
    }
    dp1[x] = 1, tf[++len] = lft[x];
    for(auto [y, w] : to[x]) {
        if(y == fa[x] || vis[y]) continue;
        dfs2(y);
    }
    if(nxt[x] != root) dp1[nxt[x]] += dp1[x];
}
ll Count(ll l, ll r) {
    return lower_bound(tf + 1, tf + len + 1, r) - lower_bound(tf + 1, tf + len + 1, l - 1);
}
void dfs3(ll x) {
    if(x != root) {
        dp2[x] = Count(dis[fa[x]] + 1, dis[x]);
        if(dis[x] > K) {
            ll low = x, high = x;
            per(i, B, 0) {
                if(up[i][low] && dis[x] - dis[up[i][low]] <= K) low = up[i][low];
            }
            per(i, B, 0) {
                if(up[i][high] && dis[fa[x]] - dis[up[i][high]] <= K) high = up[i][high];
            }
            dp2[x] += tor[low] - tor[high];
        }
    }
    if(root) tor[x] = tor[fa[x]] + dp2[x];
    else tor[x] = 0;
    for(auto [y, w] : to[x]) {
        if(y == fa[x] || vis[y]) continue;
        dfs3(y);
    }
}
void dfs4(ll x, ll sgn, ll whole) {
    if(x != root) {
        ans[x] += (dp1[x] - 1) * sgn * whole;
        ans[fa[x]] += dp2[x] * sgn * sz[x];
    }
    for(auto [y, w] : to[x]) {
        if(y == fa[x] || vis[y]) continue;
        dfs4(y, sgn, whole);
    }
}
void calc(ll x, ll sgn) {
    len = 0, dfs2(x);
    sort(tf + 1, tf + len + 1);
    dfs3(x);
    dfs4(x, sgn, sz[x]);
}
void dfz(ll x, ll S) {
    vis[x] = 1, dis[x] = 0;
    B = lg[S];
    dfs1(x, 0), calc(x, 1);
    for(auto [y, w] : to[x]) {
        if(!vis[y]) calc(y, -1);
    }
    for(auto [y, w] : to[x]) {
        if(vis[y]) continue;
        ll nS = sz[y]; root = 0;
        findrt(y, x, nS);
        dfz(root, nS);
    }
}
bool Med;
int main() {
    cerr << fabs(&Med - &Mbe) / 1048576.0 << "MB\n";
    n = read(), K = read();
    rep(i, 2, n) {
        ll x = read() + 1, y = read() + 1, z = read();
        to[x].pb({y, z}), to[y].pb({x, z});
    }
    rep(i, 2, n) lg[i] = lg[i >> 1] + 1;
    ff[0] = 1e9;
    findrt(1, 0, n);
    dfz(root, n);
    rep(i, 1, n) write(ans[i]), putchar('\n');
    cerr << "\n" << clock() * 1.0 / CLOCKS_PER_SEC * 1000 << "ms\n";
    return 0;
}
```

---


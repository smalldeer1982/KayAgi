# 小分图最大匹配

## 题目描述

给你一个二分图，有一些个左部点。还有 $m$ 个右部点，编号为 $0$ 到 $m-1$。

对于每个左部点 $i$，有一个连边参数 $a_i$，表示其向所有满足 $\exist x\in \mathbb{N}, a_ix\equiv j \pmod m$ 的 $j$ 连接了一条边。

现在给出两个长度为 $n$ 的数组 $a_i,c_i$，表示存在 $c_i$ 个左部点的连边参数为 $a_i$，换句话说，这个图总共有 $\sum\limits_{i=1}^n c_i$ 个左部点，使用这样的方式来快速读入左部点的连边参数。

保证 $a_i$ 两两不同。

求这张二分图的最大匹配。


## 说明/提示

**本题采用捆绑测试**。

| Subtask | $n\le$ | $m\le$ | 特殊性质 | 分数 |
| :-: | :--------: | :-: | :-: | :-: |
| 0 | $10^3$ | $10^3$ | 无 | 10 |
| 1 | $1$ | $10^{12}$ | 无 | 10 |
| 2 | $2 \times 10^3$ | $2\times 10^7$ | 有 | 20 |
| 3 | $2 \times 10^3$ | $2\times 10^7$ | 无 | 20 |
| 4 | $2 \times 10^3$ | $10^{12}$ | 有 | 20 |
| 5 | $7 \times 10^3$ | $10^{12}$ | 无 | 20 |

对于所有数据，保证 $1\le n \le 7\times10^3, 1\le m \le 10^{12},1\le a_i \le m,0\le c_i \le 10^{12}$

特殊性质 : 保证 $\mu(m)\not=0$。

其中 $\mu$ 指莫比乌斯函数，定义为

$$
\mu(n)=\left\{\begin{array}{ll}
1 & n=1 \\
0 & n \text { 含有平方因子 } \\
(-1)^{k} & k \text { 为 } n \text { 的本质不同质因子个数 }
\end{array}\right.
$$

对于所有数据，保证 $a_i$ 互不相同。

## 样例 #1

### 输入

```
3 6
1 1
2 2
3 1```

### 输出

```
4```

## 样例 #2

### 输入

```
6 12
12 3
3 1
2 1
6 2
4 2
1 2```

### 输出

```
8```

## 样例 #3

### 输入

```
11 60
4 1
15 10
3 1
20 3
2 2
30 2
6 4
10 5
5 3
60 5
12 14```

### 输出

```
23```

# 题解

## 作者：rizynvu (赞：8)

[我的博客](https://www.cnblogs.com/rizynvu/p/18377349)。

首先考虑连边的情况。  
可以把 $a_i$ 拆成 $\gcd(a_i, m)\times \frac{a_i}{\gcd(a_i, m)}$，因为 $\gcd(\frac{a_i}{\gcd(a_i, m)}, m) = 1$，所以与 $a_i$ 有连边的 $j$ 一定满足 $j\bmod \gcd(a_i, m) = 0$。  

于是就可以把 $c_{a_i}$ 放到 $c_{\gcd(a_i, m)}$，左部点就只剩下了 $m$ 的因数了。  

考虑左部点 $i | m, j | m$，满足 $i | j$，可以知道 $j$ 所连向点 $i$ 肯定也有连边。  
具体就是令 $R_x$ 为 $x$ 与右部点有连边的点集合，对于 $i | j$ 有 $R_j\subset R_i$。

于是一个想法就是对于右部点 $y$，与其有连边的左部点可能有很多个，但是把其挂到左部点 $\gcd(y, m)$ 上，然后对于倍数去建边。  
为什么是 $\gcd(y, m)$？因为对于左部点 $x | m$，若此时满足 $x | \gcd(y, m)$，就有 $x | m$；同时对于 $x \nmid \gcd(y, m)$，肯定 $x\nmid y$。

于是接下来就考虑如何算左部点 $x$ 挂着的右部点个数。  
官方题解用了个莫反，是不是太唐了点。  
实际上这个值就是 $\varphi(\frac{m}{x})$，证明考虑选择了 $y\in [1, \frac{m}{x}]$。  
那么 $\gcd(m, xy) = x\gcd(y, \frac{m}{x})$，所以当 $\gcd(y, \frac{m}{x}) = 1$ 时满足 $\gcd(m, xy) = x$，这个 $y$ 的个数显然就是 $\varphi(\frac{m}{x})$ 了。

那么接下来就可以考虑网络流了。  
因为此时右部点都是挂在左部点上的，所以不用建成一个二分图的形式。  
具体的，对于左部点 $x$，连边 $(\operatorname{S}, x, c_x), (x, \operatorname{T}, \varphi(\frac{m}{x}))$，相当于是把右部点也压缩进来了。  
同时对于左部点 $x | y$，应该有连边 $(x, y, \operatorname{inf})$，但这样边数太大了，考虑优化（但实际上这样就已经可以过了）。  
一个想法是对于任意一个质数 $p$，$x$ 的次数肯定都小于等于 $y$ 的次数，所以若存在 $p | y$，连边 $(\frac{y}{p}, y, \operatorname{inf})$。

然后跑网络流即可。

复杂度 $\mathcal{O}(\sqrt{m} + \omega(m)d(m) + \operatorname{flow}(d(m), \omega(m)d(m)))$。  
其中 $\omega(m)$ 表示 $m$ 的质因子数量，$d(m)$ 表示 $m$ 的因子数量。

```cpp
#include<bits/stdc++.h>
using ll = long long;
constexpr ll inf = 1e18;
const int maxN = 7e3 + 10, maxM = maxN + maxN + maxN * 12;
ll val[maxM * 2];
int to[maxM * 2], nxt[maxM * 2], fir[maxN], tot = 1;
int S, T;
inline void add(int x, int y, ll w, bool f = 1) {
   to[++tot] = y, val[tot] = w, nxt[tot] = fir[x], fir[x] = tot;
   if (f) add(y, x, 0, 0);
}
int hd[maxN], dep[maxN];
inline bool bfs() {
   for (int i = 1; i <= T; i++)
      hd[i] = fir[i], dep[i] = -1;
   dep[S] = 0;
   std::queue<int> Q; Q.push(S);
   while (! Q.empty()) {
      int u = Q.front(); Q.pop();
      if (u == T) return true;
      for (int i = hd[u]; i; i = nxt[i])
         if (dep[to[i]] == -1 && val[i])
            dep[to[i]] = dep[u] + 1, Q.push(to[i]);
   }
   return false;
}
inline ll dfs(int u, ll fl) {
   if (u == T)
      return fl;
   ll ud = 0;
   for (int &i = hd[u]; i; i = nxt[i])
      if (dep[u] + 1 == dep[to[i]] && val[i]) {
         ll k = dfs(to[i], std::min(fl - ud, val[i]));
         if (! k) dep[to[i]] = -1;
         ud += k, val[i] -= k, val[i ^ 1] += k;
         if (ud == fl)
            return fl;
      }
   return ud;
}
inline ll Dinic() {
   ll ans = 0, f;
   while (bfs())
      while ((f = dfs(S, inf)) > 0)
         ans += f;
   return ans;
}
const int maxn = 7e3 + 10;
std::map<ll, int> id;
ll res[maxn], cnt[maxn];
std::vector<ll> pr;
inline void initpr(ll m) {
   for (ll x = 2; x * x <= m; x++)
      if (m % x == 0) {
         pr.push_back(x);
         while (m % x == 0) m /= x;
      }
   if (m > 1)
      pr.push_back(m);
}
inline ll phi(ll x) {
   ll v = x;
   for (ll p : pr)
      if (x % p == 0)
         v /= p, v *= p - 1;
   return v;
}
int main() {
   int n; ll m; scanf("%d%lld", &n, &m);
   for (ll i = 1; i * i <= m; i++)
      if (m % i == 0)
         id[i] = id[m / i] = 0;
   initpr(m);
   int N = 0;
   for (auto &[x, c] : id)
      c = ++N, res[N] = x;
   for (ll a, c; n--; )
      scanf("%lld%lld", &a, &c), cnt[id[std::__gcd(a, m)]] += c;
   S = N + 1, T = N + 2;
   for (int i = 1; i <= N; i++) {
      add(S, i, cnt[i]);
      add(i, T, phi(m / res[i]));
   }
   for (int i = 1; i <= N; i++)
      for (ll p : pr)
         if (res[i] % p == 0)
            add(id[res[i] / p], i, inf);
   printf("%lld\n", Dinic());
   return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：3)

这里是官方题解。

## sub0

直接建图，跑最大匹配即可

## sub1

送分的，输出 $\min(c_1,\frac{m}{\gcd(m,a_1)})$ 即可。

## sub2

由于 $\mu(m)\ne0$，所以可以将 $m$ 分解为 $\prod p_i$ 的形式，右部每个点都可以按是否含有 $p_i$ 压缩为一个二进数，把相同的二进制数放在一起考虑，左部点连边方式相同的也可以缩一起，最后左右部点数量均小于 $ 256$ 个，直接跑最大流即可。

## sub3

发现按照 $sub2$ 的做法直接压缩是不可行的，因为会有 $p_i$ 和 $p_i^2$ 的区别，于是需要压缩为序列。

$i$ 压缩成的序列对应的是 $m$ 的一个因数，即是 $\gcd(i,m)$。

发现点数为 $\sigma(m)$，在 $m\le 2\times10^7$ 时最大只有 $500$ 左右，直接做如果常数好可能可以卡过去。

这里提供一个方法，直接把左部点和对应的右部点合并，总点数减半，边数变化不大。

## sub4

回到 $sub2$ 的做法，首先对于质因子集合 $S$ 可以容斥求出对应的点数。

但是点数达到了 $2000$ 的级别，直接做不行，于是高维前缀和优化建图，即 $\forall T,|T|=|S|+1,S\sub T$，从 $S$ 向 $T$ 连一条流量为 $inf$ 的边。

于是边数只剩 $20000$ 多条，可过。

## sub5

将 $sub3$ 和 $sub4$ 结合，对于一个数，对应点数莫反求即可，向其乘一个 $m$ 的质因子得到的值连一条流量为 $inf$ 的边。

能够通过此题。

---

## 作者：Svemit (赞：1)

考虑一个 $a_i$ 会向怎样的 $j$ 连边。

满足 $a_i \times x \equiv j \pmod m$，设 $a_i \times x = y \times m + j$，即 $a_i \times x - y \times m = j$ 有解。

根据裴蜀定理只需要 $\gcd(a_i, m) | j$ 就会有解。

于是我们得到 $a_i$ 连出去的边满足 $j$ 是 $\gcd(a_i, m)$ 的倍数。

把题目转换为给定一个数，他会向自己的倍数连边。

那么左部点成功被降到了 $d(m)$ 级别。

此时右部点 $m$ 的点数依旧不可接受，仍然考虑只保留 $m$ 的因数。

对于 $u | v,u | m$，可以推出 $u | \gcd(v, m)$，想到把所有连向右部点 $v$ 的边全都算在 $\gcd(v, m)$ 上，不难发现这样建图不影响答案。

计算有多少个点缩到当前点 $v$ 上，即 $\sum_{i = 1} ^ {m} [\gcd(i, m) = v]$，这个东西等于 $\sum_{i=1}^{\frac {m}{v}} [\gcd (\frac {m}{v}, i) = 1]$，也就是 $\phi (\frac{m}{v})$。

对于左部点向所有倍数连边，我们考虑类似狄利克雷前缀和去做，每个点向自己的质数倍数连边，注意到点数可能比较多，把左右部点缩起来，但是不缩应该也能过。

代码中删去了 flow 板子。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 7e3 + 5, M = N * 15;
const ll inf = 1ll << 60;

int n;
ll m;
vector<ll> factors, pri;
ll in[N], out[N];

void init() {
	for (ll i = 1; i <= m / i; i ++) {
		if (m % i == 0) {
			factors.push_back(i);
			if (i * i != m) factors.push_back(m / i);
		}
	}
	sort(factors.begin(), factors.end());
	ll x = m;
	for (ll i = 2; i <= x / i; i ++) {
		if (x % i == 0) {
			pri.push_back(i);
			while (x % i == 0) x /= i;
		}
	}
	if (x != 1) pri.push_back(x);
}

ll get_phi(ll x) {
	ll phi = x;
	for (auto p : pri) {
		if (x % p == 0) {
			phi /= p, phi *= p - 1;
			while (x % p == 0) x /= p;
		}
	}
	return phi;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);

    cin >> n >> m;
    init();
    for (int i = 1; i <= n; i ++) {
    	ll a, c;
    	cin >> a >> c;
    	a = __gcd(a, m);
    	int x = lower_bound(factors.begin(), factors.end(), a) - factors.begin();
    	in[x + 1] += c;
    }
    int S = factors.size() + 1, T = S + 2;
    for (int i = 0; i < factors.size(); i ++) out[i + 1] = get_phi(m / factors[i]);
    g.init(T + 1, S, T);
	for (int i = 1; i <= factors.size(); i ++) {
		g.addedge(S, i, in[i]);
		g.addedge(i, T, out[i]);
	}
	for (int i = 0; i < S; i ++) {
		ll x = factors[i];
		for (auto p : pri) {
			if (x % p == 0) {
				ll j = lower_bound(factors.begin(), factors.end(), x / p) - factors.begin();
				g.addedge(j + 1, i + 1, inf);
			}
		}
	}

	cout << g.dinic() << "\n";

    return 0;
}
```

---


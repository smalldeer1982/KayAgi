# 异象石

## 题目描述

Adera 是 Microsoft 应用商店中的一款解谜游戏。

异象石是进入 Adera 中异时空的引导物，在 Adera 的异时空中有一张地图。

这张地图上有 $N$ 个点，有 $N-1$ 条双向边把它们连通起来。

起初地图上没有任何异象石，在接下来的 $M$ 个时刻中，每个时刻会发生以下三种类型的事件之一：

  1. 地图的某个点上出现了异象石（已经出现的不会再次出现）；
  2. 地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）；
  3. 向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。

请你作为玩家回答这些问题。

## 说明/提示

数据保证，$1 \le N,M \le 10^5$，$1 \le x,y \le N$，$x \neq y$，$1 \le z \le 10^9$。

## 样例 #1

### 输入

```
6
1 2 1
1 3 5
4 1 7
4 5 3
6 4 2
10
+ 3
+ 1
?
+ 6
?
+ 5
?
- 6
- 3
?```

### 输出

```
5
14
17
10```

# 题解

## 作者：ivyjiao (赞：13)

不是，哥们，你真来啊。

双倍经验：[P3320 [SDOI2015] 寻宝游戏](https://www.luogu.com.cn/problem/P3320)。

三倍经验：[CF176E Archaeology](https://www.luogu.com.cn/problem/CF176E)。

---

我们先看 P3320。

结论很好猜，模拟一下走的路径就明白了：

假设下图中，$4,5,8$ 号节点有宝物。

![](https://cdn.luogu.com.cn/upload/image_hosting/jm23r9ta.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

红色路径就是我们来时走过的路径。如果我们算上返回时走的路径，那么我们经过的路径经过且仅经过两次。

此时~~根据直觉~~，能知道这条路径与 LCA 有关，于是我们先敲一个板子。

```cpp
void dfs(int u,int fa,int w){
    dep[u]=dep[fa]+1;
    dis[u]=dis[fa]+w;
    f[u][0]=fa;
    for(int i=1;i<=20;i++) f[u][i]=f[f[u][i-1]][i-1];
    for(int i=0;i<G[u].size();i++){
        int v=G[u][i].se,w=G[u][i].fi;
        if(v==fa) continue;
        dfs(v,u,w);
    }
}
int lca(int x,int y){
    if(x==y) return x;
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=20;i>=0;i--){
        if(dep[f[x][i]]>=dep[y]) x=f[x][i];
    }
    if(x==y) return x;
    for(int i=20;i>=0;i--){
        if(f[x][i]!=f[y][i]){
            x=f[x][i];
            y=f[y][i];
        }
    }
    return f[x][0];
}
int getdis(int x,int y){
    return dis[x]+dis[y]-2*dis[lca(x,y)];
}
```

然后进一步分析。我们先假设只有 $(4,5)$ 一对点（单程）：

![](https://cdn.luogu.com.cn/upload/image_hosting/0ghmqqai.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

我们发现，结合 LCA，从 $4$ 到 $5$ 的路径长度可以表示为 $dis_4+dis_5-2\times dis_{2}=dis_4+dis_5-2\times dis_{lca_{4,5}}$。

对于 $(5,8)$，$(4,8)$ 两对点，也是如此。

但是我们还发现，如果把宝物点的数量继续增多，那么点对的顺序将不能随意变化。模拟之后，我们发现点对的顺序仅仅和点的 dfs 序有关，且最终 $n$ 个点组成 $n$ 个点对，拆开后变成一个环（因为最终要回到最开始的点）。实际上，原图点的顺序就是 dfs 序。

我们再假设原图中 $9$ 号点也有宝物，那么 $4$ 个点对分别是 $(4,5),(5,8),(8,9),(9,4)$。路径如下（往返）：

![](https://cdn.luogu.com.cn/upload/image_hosting/66hfckwq.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

设 $dist_{u,v}=dis_u+dis_v-2\times dis_{lca_{u,v}}$，$a_i$ 为字典序为第 $i$ 大的宝物点，则 $ans=dist_{a_1,a_2}+dist_{a_2,a_3}+\cdots+dist_{a_{n-1},a_n}+dist_{a_n,a_1}$。动态维护 $ans$ 即可。

dfs 序的顺序是很好维护的，用 set 维护即可，也可以用 rb_tree_tag。

对于本题，由于我们经过的路径经过且仅经过两次，而本题每条路径只需要算一遍，所以直接将答案 $\div 2$ 即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define fi first
#define se second
#define int long long
using namespace std;
int n,m,x,y,z,t,dep[100001],dis[100001],dfn[100001],f[100001][21],sum,ans;
char op;
bool vis[100001];
vector<PII>G[100001];
set<PII>st;
void dfs(int u,int fa,int w){
    dep[u]=dep[fa]+1;
    dis[u]=dis[fa]+w;
    dfn[u]=++sum;
    f[u][0]=fa;
    for(int i=1;i<=20;i++) f[u][i]=f[f[u][i-1]][i-1];
    for(int i=0;i<G[u].size();i++){
        int v=G[u][i].se,w=G[u][i].fi;
        if(v==fa) continue;
        dfs(v,u,w);
    }
}
int lca(int x,int y){
    if(x==y) return x;
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=20;i>=0;i--){
        if(dep[f[x][i]]>=dep[y]) x=f[x][i];
    }
    if(x==y) return x;
    for(int i=20;i>=0;i--){
        if(f[x][i]!=f[y][i]){
            x=f[x][i];
            y=f[y][i];
        }
    }
    return f[x][0];
}
int getdis(int x,int y){
    return dis[x]+dis[y]-2*dis[lca(x,y)];
}
signed main(){
    cin>>n;
    for(int i=1;i<n;i++){
        cin>>x>>y>>z;
        G[x].push_back({z,y});
        G[y].push_back({z,x});
    }
    dfs(1,0,0);
    cin>>m;
    while(m--){
        cin>>op;
        if(op=='+'||op=='-'){
            cin>>t;
            vis[t]=!vis[t];
            if(vis[t]) st.insert({dfn[t],t});
            auto it1=st.lower_bound({dfn[t],t}),it2=st.upper_bound({dfn[t],t});
            int a=(it1==st.begin()? (*--st.end()).se:(*--it1).se);
            int b=(it2==st.end()? (*st.begin()).se:(*it2).se);
            swap(a,b);
            if(!vis[t]) st.erase({dfn[t],t});
            int d=getdis(t,a)+getdis(t,b)-getdis(a,b);
            if(vis[t]) ans+=d;
            else ans-=d;
        }
        else cout<<ans/2<<endl;
    }
}
```

---

## 作者：wchengk09 (赞：6)

目前题解里的做法好像都是利用了 dfn 序的性质。这里提供一种树链剖分做法，其复杂度为 $O(n\log^2 n)$，但我感觉更好想。

很明显，一条边 $x \leftrightarrow fa_x$ 需要被选中，当且仅当删去这条边后，形成的两个连通块中都有异象石。

我们可以记 $cnt_x$ 表示 $x$ 的子树中有多少个异象石。那么 $x$ 的 **子树外** 的异象石个数就是 $cnt_1-cnt_x$（假设 $1$ 为根）。对于一条边 $x\leftrightarrow fa_x$，如果 $cnt_x\neq 0$ 且 $cnt_1-cnt_x\neq 0$（即 $cnt_x\neq cnt_1$），那么 $x\leftrightarrow fa_x$ 这条边需要被选中。

结点 $x$ 出现/消失异象石，相当于 $x$ 到根的路径上的所有 $cnt$ 都 $\pm 1$。

我们可以考虑树链剖分，这样我们只需要实现下面两个操作：

- 路径 $\pm 1$
- 全局查询 $cnt\neq 0$ 且 $cnt\neq cnt_1$ 的边的边权之和

第二个操作看起来不好维护。我们先正难则反，用总边权减去 $cnt=0$ 的边权再减去 $cnt=cnt_1$ 的边权。但是它看起来还是不太好做。

不过我们注意到一件事：如果一个点的 $cnt$ 等于 $0$，那么它必然是所有 $cnt$ 中最小的（不会出现 $cnt<0$ 的点）；如果一个点的 $cnt$ 等于 $cnt_1$，那么它必然是所有 $cnt$ 中最大的（不会出现 $cnt>cnt_1$ 的点）。

我们可以参考 [矩形面积并](https://www.luogu.com.cn/problem/P5490) 的做法，在线段树上维护四个信息：

1. $cnt$ 的区间最小值
2. $cnt$ 的区间最大值
3. 区间内 $cnt$ 等于最小值的边权之和
4. 区间内 $cnt$ 等于最大值的边权之和

区间修改、合并两个区间的信息是容易的。

于是我们就做完了，时间复杂度即为树链剖分的复杂度，为 $O(n \log^2 n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MAXN = 1e5 + 5;
int n,m;
int tot;
vector<pair<int,int> > G[MAXN];
int fa[MAXN],faval[MAXN],dep[MAXN],sz[MAXN],son[MAXN];
int dfn[MAXN],rdfn[MAXN],top[MAXN],dfn_cnt;

void dfs1(int x,int f){
    sz[x] = 1;
    son[x] = -1;
    int max_sz = -1;
    for (auto it : G[x]){
        int y = it.first,z = it.second;
        if (y == f)continue;
        fa[y] = x;
        faval[y] = z;
        dep[y] = dep[x] + 1;
        dfs1(y,x);
        sz[x] += sz[y];
        if (sz[y] > max_sz){
            max_sz = sz[y];
            son[x] = y;
        }
    }
}

void dfs2(int x,int tp){
    dfn[x] = ++dfn_cnt;
    rdfn[dfn[x]] = x;
    top[x] = tp;
    if (son[x] != -1)dfs2(son[x],tp);
    for (auto it : G[x]){
        int y = it.first;
        if (y == fa[x] || y == son[x])continue;
        dfs2(y,y);
    }
}

namespace SegTree{
    struct Node{
        int l,r;
        int minval;
        ll minsum;
        int maxval;
        ll maxsum;
        int lazy;
    };
    Node T[MAXN << 2];

    inline int lch(int p){return p << 1;}
    inline int rch(int p){return p << 1 | 1;}

    inline void pushup(int p){
        Node &l = T[lch(p)],&r = T[rch(p)],&nd = T[p];
        // update min
        if (l.minval == r.minval){
            nd.minval = r.minval;
            nd.minsum = l.minsum + r.minsum;
        }else if (l.minval < r.minval){
            nd.minval = l.minval;
            nd.minsum = l.minsum;
        }else{
            nd.minval = r.minval;
            nd.minsum = r.minsum;
        }
        // update max
        if (l.maxval == r.maxval){
            nd.maxval = r.maxval;
            nd.maxsum = l.maxsum + r.maxsum;
        }else if (l.maxval > r.maxval){
            nd.maxval = l.maxval;
            nd.maxsum = l.maxsum;
        }else{
            nd.maxval = r.maxval;
            nd.maxsum = r.maxsum;
        }
    }

    void build(int p,int l,int r){
        T[p].l = l,T[p].r = r;
        if (l == r){
            T[p].minval = T[p].maxval = 0;
            T[p].minsum = T[p].maxsum = faval[rdfn[r]];
            return;
        }
        int mid = (l + r) >> 1;
        build(lch(p),l,mid);
        build(rch(p),mid + 1,r);
        pushup(p);
    }

    inline void pushdown(int p){
        T[lch(p)].lazy += T[p].lazy;
        T[rch(p)].lazy += T[p].lazy;
        T[lch(p)].minval += T[p].lazy;
        T[rch(p)].minval += T[p].lazy;
        T[lch(p)].maxval += T[p].lazy;
        T[rch(p)].maxval += T[p].lazy;
        T[p].lazy = 0;
    }

    void change(int p,int l,int r,int d){
        if (l <= T[p].l && T[p].r <= r){
            T[p].minval += d;
            T[p].maxval += d;
            T[p].lazy += d;
            return;
        }
        pushdown(p);
        int mid = (T[p].l + T[p].r) >> 1;
        if (l <= mid)change(lch(p),l,r,d);
        if (r > mid)change(rch(p),l,r,d);
        pushup(p);
    }
}

inline ll getzero(){
    SegTree::Node nd = SegTree::T[1];
    // printf("getzero(): %d %lld\n",nd.minval,nd.minsum);
    if (nd.minval)return 0;
    return nd.minsum;
}

inline ll gettot(){
    SegTree::Node nd = SegTree::T[1];
    if (nd.maxval != tot)return 0;
    return nd.maxsum;
}

int main(){
    scanf("%d",&n);
    ll sum = 0;
    for (int i = 1;i < n;i ++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        G[x].push_back({y,z});
        G[y].push_back({x,z});
        sum += z;
    }
    dfs1(1,1);
    dfs2(1,1);
    SegTree::build(1,1,n);
    scanf("%d",&m);
    while (m --){
        char op[2];
        scanf("%s",op);
        if (op[0] == '+' || op[0] == '-'){
            int x;
            scanf("%d",&x);
            int c = (op[0] == '+' ? 1 : -1);
            tot += c;
            while (x){
                SegTree::change(1,dfn[top[x]],dfn[x],c);
                x = fa[top[x]];
            }
        }
        if (op[0] == '?'){
            if (!tot)printf("0\n");
            else printf("%lld\n",sum - getzero() - gettot());
        }
    }
    return 0;
}
```

---

## 作者：GGBondsqy (赞：5)

# 前言：
发个题解纪念一下这道做了一天的题，一道非常不错的倍增 。

# 题意：
给你一个带权无向图，让你求把这些点联通的最短路径。而且这些点每次都可能会变。

# 思路：
如果路径最短一定是按 dfs 序走，dfs 序就是你 dfs 遍历的顺序。但如果每次插入点都排序肯定会超时，所以考虑维护一个 set 现在来考虑怎么统计答案。如果每次都把 set 中的点跑一边还是会超时，想一想怎么优化?

题目保证了给出的图是一棵树，所以可以用倍增把复杂度大大降低，由此求出两点间最短路。那么，还有一个问题就是每次插入和删除一个点时如何更新答案。假如现在插入的点是 $c$ , 我们把 $c$ 前面那个点记为 $a$ , 后面的点记为 $b$ 。那么原先的路径是从 $a$ 到 $b$ , 现在 $a$ 和 $b$ 之间多了个 $c$ 。我们只要把 $a$ 到 $b$ 的路径减去，再加上 $a$ 到 $c$ 的路径和 $c$ 到 $b$ 的路径即可。这样就完了吗？不，我们发现每一个点在他插入时把他两边的路径都算了一遍，所以最后 $ans$ 要除以 $2$ 。

**最后注意一个坑点就是如果你用链式前向星要把它反过来建边，不然你求出的 dfs 序是错的**。

# 代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=2e5+10;
ll n,m,head[N],to[N],nt[N],len[N],op;
ll fa[N][21],deep[N],d[N],dfn[N],cnt;
struct sqy{
	ll x;
	bool operator<(const sqy & other)const{
		return dfn[x]<dfn[other.x];
	}
};
set<sqy>st;
void add(ll x,ll y,ll length){
	op++;
	to[op]=y;
	nt[op]=head[x];
	head[x]=op;
	len[op]=length;
}
void dfs(ll tot,ll fath){
	deep[tot]=deep[fath]+1;
	fa[tot][0]=fath;dfn[tot]=++cnt;
	for(ll i=1;i<=20;i++){
		fa[tot][i]=fa[fa[tot][i-1]][i-1];
	}
	for(ll i=head[tot];i!=-1;i=nt[i]){
		ll v=to[i];
		if(v==fath)continue;
		d[v]=d[tot]+len[i];
		dfs(v,tot);
	}
}
ll get_lca(ll x,ll y){
	if(deep[x]<deep[y])swap(x,y);
	for(ll i=20;i>=0;i--){
		if(deep[fa[x][i]]>=deep[y]){
			x=fa[x][i];
		}
	}
	if(x==y)return x;
	for(ll i=20;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i];y=fa[y][i];
		}
	}
	return fa[x][0];
}
ll get_path(ll x,ll y){
	ll lca=get_lca(x,y);
	return (d[x]-d[lca])+(d[y]-d[lca]);
}
ll a[N],b[N],c[N];
int main(){
	scanf("%lld",&n);
	memset(head,-1,sizeof(head));
	for(ll i=1;i<n;i++){
		scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
	}
	for(ll i=n-1;i>=1;i--){
		add(a[i],b[i],c[i]);
		add(b[i],a[i],c[i]);
	}
	dfs(1,0);
	scanf("%lld",&m);
	ll ans=0;
	while(m--){
		char op;
		cin>>op;
		if(op=='+'){
			ll x;
			scanf("%lld",&x);
			sqy g;g.x=x;
			st.insert(g);
			set<sqy>::iterator it=st.find(g);
			set<sqy>::iterator it1=it,it2=it;
			if(it1==st.begin())it1=--st.end();
			else --it1;
			if(it2==(--st.end()))it2=st.begin();
			else ++it2;
			ans+=get_path((*it1).x,x)+get_path(x,(*it2).x)-get_path((*it1).x,(*it2).x);
		}
		else if(op=='-'){
			ll x;
			scanf("%lld",&x);
			sqy g;g.x=x;
			set<sqy>::iterator it=st.find(g);
			set<sqy>::iterator it1=it,it2=it;
			if(it1==st.begin())it1=--st.end();
			else --it1;
			if(it2==(--st.end()))it2=st.begin();
			else ++it2;
			ans-=get_path((*it1).x,x)+get_path(x,(*it2).x)-get_path((*it1).x,(*it2).x);	
			st.erase(g);		
		}
		else printf("%lld\n",ans/2);
	}
	return 0;
}
```

---

## 作者：Wei_Han (赞：3)

两个多月之前做的了，题挺好的，写一下。

现在我们要在树上支持三个操作。加特殊点，抹除特殊点，求特殊点路径覆盖边的长度。这种东西看起来挺难搞的，那我们就一步一步模拟着来看。

人类直觉做法，发现所有情况可以分类讨论，假定当前点为 $u$，我们肯定是要找他前后**最优**的点来计算路径，这里是可以直接二分的，可能会发现有情况满足取的不会是最近的点，但是这种是不影响结果的，放到了下面去讲。

只有前驱或者只有后继的情况没什么好讨论的，我们考虑一般情况。

拟定当前的根有三棵子树，每棵子树下挂着一堆点，令 $u$ 在中间子树的某个节点上，他下面也有子节点。

![丑图](https://cdn.luogu.com.cn/upload/image_hosting/5apfkoy9.png)

画出图类似这样，我们记根的三棵子树分别为 $x$，$y$，$z$，特别地，我们令 $y$ 子树内 $x$ 往上到根的部分记作 $v$，往下的部分记作 $w$。

此处以增加为例，删除同理，讨论三个点的位置关系，前驱为 $pre$，后继为 $nxt$：

- $pre$ 在 $x$ 子树内，$nxt$ 在 $w$ 内，就不画图了，抽象理解一下，我们需要加上 $dis(pre,x)+dis(x,nxt)-dis(pre,nxt)$。

- $pre$ 在 $x$ 子树内，$nxt$ 在 $z$ 子树内，我们需要加上 $dis(pre,x)+dis(x,nxt)-dis(pre,nxt)-dis(x,root)$，此处 $root$ 为根节点。

- $pre$ 在 $v$ 内，$nxt$ 在 $w$ 内，同情况一。

- $pre$ 在 $v$ 内，$nxt$ 在 $z$ 内，我们需要加上 $dis(pre,x)$。

我们将每种情况的加减都变为 $dis(pre,x)+dis(x,nxt)-dis(pre,nxt)$，情况一三不变，情况二少了 $x$ 到根的答案，情况四多算了 $dis(x,pre)$，发现这两种情况下我们如果加上 $dis(pre,nxt)$，答案就是正确答案的二倍，进一步拓展这个结论，通过拼接几种情况，我们最后需要加上 dfn 最小的到 dfn 最大的路径长度就能使得所有边正好被经过两次，这个可以自己去手动模拟一下，这种结论挺抽象的，可以类似环尾再走到环首。

还有上面说到取的不是最近点的问题，就是类似情况三的时候，子树 $z$ 上还有点距离 $x$ 更近，发现此时我们按照上述方法更新的话增加这个点和没有增加的路径长度是一样的，所以说对答案并不会产生影响。

用 ```set``` 维护特殊点，二分 dfn 序再算答案就好了，复杂度 $O(n\log n)$。

补：过了 [P3320](https://www.luogu.com.cn/problem/P3320) 这个结论应该会更好理解一些，就是走过去再从终点走回来，每条边都被覆盖两次，再除掉就好了。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define pr printf("\n")
#define pp printf(" ")
#define pii pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(ll i = a ; i <= b ; i ++ )
#define Fo(a,i,b) for(ll i = a ; i >= b ;-- i  )
#define bug(x,y) (x<1||y<1||x>15||y>15)
using namespace std;
typedef long long ll;
typedef double db;
const int N=3e5+5,M=1e7+5;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
ll head[N],tot,n,m;
set<ll> st;
struct Graph{ll ver,nxt,w;}g[N<<1];
inline void add(ll x,ll y,ll z){g[++tot].ver=y,g[tot].nxt=head[x];g[tot].w=z;head[x]=tot;}
ll dep[N],fa[N],son[N],siz[N],top[N],rb[N],w[N],id[N],cnt,dist[N];
inline void dfs1(ll x,ll father,ll depth){
	dep[x]=depth;fa[x]=father;siz[x]=1;
	ll zson=-1;
	for(ll i=head[x];i;i=g[i].nxt){
		ll y=g[i].ver;if(y==father) continue;dist[y]=dist[x]+g[i].w; 
		dfs1(y,x,depth+1);siz[x]+=siz[y];
		if(siz[y]>zson) zson=siz[y],son[x]=y;
	}
}
inline void dfs2(ll x,ll nowtop){
	top[x]=nowtop;id[x]=++cnt;w[cnt]=x;
	if(!son[x]){rb[x]=cnt;return;}
	dfs2(son[x],nowtop);
	for(ll i=head[x];i;i=g[i].nxt){
		ll y=g[i].ver;if(y==fa[x]||y==son[x]) continue;
		dfs2(y,y);
	} 
	rb[x]=cnt;
}
inline ll lca(ll x,ll y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);return y;
}
inline ll dis(ll x,ll y){return dist[x]+dist[y]-2*dist[lca(x,y)];}
signed main(){
	read(n);
	fo(1,i,n-1){ll u,v,w;read(u),read(v),read(w);add(u,v,w),add(v,u,w);}
	dfs1(1,0,1),dfs2(1,1);st.insert(-INF),st.insert(INF);
	ll sum=0;read(m);
	fo(1,i,m){
		char op;ll x;
		cin>>op;
		if(op=='+'){
			read(x);st.insert(id[x]);
			set<ll> ::iterator it=st.upper_bound(id[x]);
			ll nxt=(*it),las=(*(--(--it)));
//			if(nxt!=INF&&las!=-INF) wr(w[nxt]),pp,wr(w[las]),pp,wr(1145),pr;
			if(las!=-INF) sum+=dis(w[las],x);
			if(nxt!=INF) sum+=dis(x,w[nxt]);
			if(las!=-INF&&nxt!=INF) sum-=dis(w[las],w[nxt]);
		}
		if(op=='-'){
			read(x);st.erase(id[x]);
			set<ll> ::iterator it=st.upper_bound(id[x]);
			ll nxt=(*it),las=(*(--it));
			if(las!=-INF) sum-=dis(w[las],x);
			if(nxt!=INF) sum-=dis(x,w[nxt]);
			if(las!=-INF&&nxt!=INF) sum+=dis(w[las],w[nxt]);
		}
		if(op=='?'){
			if(st.size()<=3) wr(0),pr;
			else wr((sum+dis(w[(*(st.upper_bound(-INF)))],w[(*(--st.lower_bound(INF)))]))>>1),pr; 
		}
	}
	return 0;
}
``````

---

## 作者：Furina_Saikou (赞：2)

本题的思考分为两个部分，第一个部分是如何求出连通边集最小大小，第二部分是如何在线维护这个大小。

# 求连通点边集最小大小

我们可以将问题转化成以一个异象石点所在点为起点，如何以最少的步数将所有点遍历最后回到起点。

![](https://cdn.luogu.com.cn/upload/image_hosting/ynn5goyg.png)

如图，最少步数的走法是从 $1$ 开始，然后绕着所有异象石的外围走一圈，也就是将异象石按 dfs 序的顺序走一遍，这样所用的步数其实就是我们要求的这个边集大小的两倍，我们只要统计这个步数最后 $\div 2$ 即可。

# 动态统计的方法

我们可以用 set 等数据结构来维护。

- 当异象石的点集为空时，显然加入点时不会影响答案。
- 当异象石的点集不为空时，加入一个点就是将答案加上它分别与左右两个异象石的距离并减去左右两个异象石互相的距离，删除异象石则反之。特别的，我们将点集看作一个**环**，所以如果插入或删除的点位于排序后的最左边或最右边，那么它的左边点或右边点为最右点或最左点。

两个点的距离我们可以用 LCA（最近公共祖先）维护。

# 具体实现

先建树，再预处理树上每个点的 dfs 序，然后在线处理询问即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=415411;
int n,q,a[N],head[N],id,ne[N],to[N],w[N],dep[N],fa[N][21],dfn[N],dis[N],tot,ans;//dfn是dfs序，dis是到根的距离
struct node{
	int x;
};
set<node>s;
inline bool operator<(node a,node b){return dfn[a.x]<dfn[b.x];}
inline void add(int x,int y,int z){to[++id]=y,w[id]=z,ne[id]=head[x],head[x]=id;}
inline void swaps(int &x,int &y){x^=y,y^=x,x^=y;}
inline int getdis(int x,int y,int t){return dis[x]+dis[y]-(dis[t]<<1);}
void dfs(int u)
{
	dep[u]=dep[fa[u][0]]+1,dfn[u]=++tot;
	for(int i=1;i<=20;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=head[u],v=to[head[u]];i;i=ne[i],v=to[i])if(v!=fa[u][0])fa[v][0]=u,dis[v]=dis[u]+w[i],dfs(v);
}
inline int lca(int x,int y)
{
	if(dep[x]<dep[y])swaps(x,y);
	for(int i=20;~i;i--)if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
	if(x==y)return x;
	for(int i=20;~i;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1,x,y,z;i<n;i++)
	{
		cin>>x>>y>>z;
		add(x,y,z),add(y,x,z);
	}
	dfs(1);
	cin>>q;
	while(q--)
	{
		static set<node>::iterator it,ed;
		static char op;
		static node x,l,r;
		static int t;
		cin>>op;
		if(op=='+')
		{
			cin>>x.x;
			if(s.size()==1llu)
			{
				t=lca(s.begin()->x,x.x);
				ans=getdis(x.x,s.begin()->x,t)<<1;
			}else if(s.size()>1)
			{
				if(x<*s.begin()||*s.rbegin()<x)
				{
					l=*s.begin(),r=*s.rbegin();
				}else
				{
					it=s.lower_bound(x);
					r=*it;
					it--;
					l=*it;
				}//找新异象石的目标左右点
				t=lca(l.x,x.x);
				ans+=getdis(x.x,l.x,t);
				t=lca(r.x,x.x);
				ans+=getdis(x.x,r.x,t);
				t=lca(l.x,r.x);
				ans-=getdis(l.x,r.x,t);
			}
			s.insert(x);
		}else if(op=='-')
		{
			cin>>x.x;
			it=s.find(x),ed=s.end();
			if(s.size()==1llu||s.size()==2llu)ans=0;
			else
			{
				ed--;
				if(it==s.begin())
				{
					ed=s.begin(),r=*s.rbegin();
					ed++;
					l=*ed;
				}else if(it==ed)
				{
					l=*s.begin(),ed--;
					r=*ed;
				}else
				{
					it++;
					r=*it;
					it--,it--;
					l=*it;
					it++;
				}
				t=lca(l.x,x.x);
				ans-=getdis(x.x,l.x,t);
				t=lca(r.x,x.x);
				ans-=getdis(x.x,r.x,t);
				t=lca(l.x,r.x);
				ans+=getdis(l.x,r.x,t);
			}
			s.erase(it);
		}else
		{
			cout<<ans/2<<"\n";//最后答案除以2
		}
	}
}
```

---

## 作者：北文 (赞：2)

纪念一下这一道有点难度的蓝题。  
观察询问的形式，他要我们求出在树上将所有点联通的最短距离。如果了解过**虚树**，就知道树上路径并的计算方法：  
令 $S$ 为需要计算的点集，$l$ 为集合大小，按 dfn 排序后，计算：  
$$\sum\limits_{i=0}^{l} dis[S_i] - \sum\limits_{i=0}^{l-1} dis[lca(S_i, S_{i+1})]-dis[lca(S_1, S_l)]$$  
证明与虚树的证明类似，如果不懂的建议先去学习虚树和树上路径并。  
而我们需要支持加点和删点，每次询问暴力做一遍的话肯定是不行。我们考虑每次加点和删点的时候维护增量。  
这里比较自然地想到，每次加点的时候，查看一下前驱后继，把原来的贡献退掉，再加入新的贡献。删除也是同理的。  
这需要我们用一个数据结构维护支持以下操作：  
1.加入/删除一个数  
2.查找一个数的前驱/后继  
3.二分出一个值所在的位置  
这三个条件 set 都符合，直接使用 set 维护即可。  

```cpp
#include<bits/stdc++.h>
using namespace std;
/*
树上路径并可以通过 dfn 排序然后类似构建虚树的方法解决。  
考虑这题支持加点删点，我们维护有序的当前按 dfn 排好的序列，每次序列修改，
只支持删除一个点，加入一个点，二分出某个位置，查询前驱后继。  
使用 set 维护。 
*/
#define int long long
const int N=1e5+5;
int n, q, h[N], cnt, to[N*2], c[N*2], nxt[N*2];
void add(int u, int v, int w) {
	to[++cnt]=v; 
	c[cnt]=w;
	nxt[cnt]=h[u];
	h[u]=cnt;
}
int dis[N], up[N][20], dep[N], dfn[N], rev[N], tot;
void dfs(int u, int fa) {
	dfn[u]=++tot;
	rev[tot]=u;
	up[u][0]=fa; dep[u]=dep[fa]+1;
	for(int i=1; i<=18; i++)
		up[u][i]=up[up[u][i-1]][i-1];
	for(int i=h[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==fa) continue ;
		dis[v]=dis[u]+c[i];
		dfs(v, u);
	}
}
int lca(int x, int y) {
	if(dep[x]<dep[y]) swap(x, y);
	for(int i=18; i>=0; i--)
		if(dep[up[x][i]]>=dep[y]) x=up[x][i];
	if(x==y) return x;
	for(int i=18; i>=0; i--)
		if(up[x][i]!=up[y][i])
			x=up[x][i], y=up[y][i];
	return up[x][0];
}

char op[20];
int u;
set<int> S;
int ans, l=0;
void Ins(int u) {
	auto it=S.lower_bound(dfn[u]);
	ans+=dis[u];
	if(S.empty()) l=u;
	else if(it==S.end()) {
		auto it2=prev(it);
		ans-=dis[lca(rev[*it2], u)];
	} else if(it==S.begin()) {
		ans-=dis[lca(rev[*it], u)];
	} else {
		auto it2=prev(it);
		ans+=dis[lca(rev[*it], rev[*it2])];
		ans-=dis[lca(rev[*it], u)];
		ans-=dis[lca(u, rev[*it2])];
	}
	S.insert(dfn[u]);
}
void Del(int u) {
	auto it=S.lower_bound(dfn[u]);
	ans-=dis[u];
	auto it2=prev(it), it3=next(it);
	if(it!=S.begin()) ans+=dis[lca(rev[*it2], rev[*it])];
	if(it3!=S.end())   ans+=dis[lca(rev[*it3], rev[*it])];
	if(it!=S.begin()&&it3!=S.end()) ans-=dis[lca(rev[*it2], rev[*it3])];
	S.erase(it);
}
signed main() {
	scanf("%lld", &n);
	for(int i=1; i<n; i++) {
		int u, v, w;
		scanf("%lld %lld %lld", &u, &v, &w);
		add(u, v, w);
		add(v, u, w);
	}
	dfs(1, 0);
	scanf("%lld", &q);
	for(; q--; ) {
		scanf("%s", op+1);
		if(op[1]=='+') {
			scanf("%lld", &u);
			Ins(u); 
		} else if(op[1]=='-') {
			scanf("%lld", &u);
			Del(u);
		} else {
			if(S.empty()) {
				printf("0\n");
				continue ;
			}
			int l=lca(rev[(*S.begin())], rev[(*(--S.end()))]);
			printf("%lld\n", ans-dis[l]);
		}
	}
	return 0;
}
```

---

## 作者：Yu_Chengxuan (赞：0)

对于一条树上的路径，我们发现按照 dfs 序递增来走是最优的。

因为 dfs 序就是 dfs 的顺序，对于每一个点，如果不递增来走的话，会多走一部分重复路径，即最小值一定是建立在 dfs 序递增来走的。

于是我们考虑如何维护新加入的点，我们维护关于 dfs 序的平衡树，查询前驱和后驱，就可以得到新加入的点所连接的两点,就可以维护最小值。

容易发现删除同理。

还有部分细节代码里说。

## Code 

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&& ch<='9') {
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
const int maxn = 1e5 + 10,inf = 1e18;
int n,m;
struct treap {
	int s[maxn][2],p[maxn],c[maxn],val[maxn],siz[maxn];
	int cnt,root; 
	inline void up(int &x){
		siz[x]=siz[s[x][0]]+siz[s[x][1]]+1; 
	}
	int newnode(int x){
		val[++cnt] = x;
		p[cnt] = rand();
		c[cnt] = 1;
		siz[cnt] = 1;
		return cnt;
	}
	inline void rotate(int &x,int opr){
	    int y=s[x][opr];
		s[x][opr]=s[y][!opr];
		s[y][!opr]=x;
		up(x),up(y),x=y;	
	} 
	void ins(int &x,int v){
    	if(!x){
			x=++cnt;
			siz[x]=1;
			val[x]=v;
			p[x]=rand();
			return ;
		}
    	siz[x]++;
    	if(v<=val[x]){
			ins(s[x][0],v);
			if(p[s[x][0]]<p[x])
				rotate(x,0);
		}
   		else{
			ins(s[x][1],v);
			if(p[s[x][1]]<p[x])
				rotate(x,1);
		}
	}	
	void del(int &x,int v){
    	if(val[x]==v){
        	if(s[x][0]*s[x][1]==0){
				x=s[x][0]+s[x][1];
				return ;
			}
        	if(p[s[x][0]]>p[s[x][1]]){
				rotate(x,1);
				del(s[x][0],v);
			}
        	else {
				rotate(x,0);
				del(s[x][1],v);
			}
    	}
    	else if(val[x]>v) del(s[x][0],v);
    	else del(s[x][1],v);
    	up(x);
	}
	int getrank(int x,int k){
    	if(!x)return 0;
    	if(val[x]>=k) return getrank(s[x][0],k);
    	return getrank(s[x][1],k)+siz[s[x][0]]+1;
	}
	int find(int x,int v){
    	if(siz[s[x][0]]==v-1) return val[x];
    	if(siz[s[x][0]]>=v) return find(s[x][0],v);
    	return find(s[x][1],v-siz[s[x][0]]-1);
	}
	int pre(int x,int v){
    	if(!x) return -inf;
    	if(val[x]<v) return max(val[x],pre(s[x][1],v));
    	else return pre(s[x][0],v);
	}
	int suf(int x,int v){
    	if(!x) return inf;
    	if(val[x]>v) return min(val[x],suf(s[x][0],v));
    	else return suf(s[x][1],v);
	}
}t;
//使用的是有旋treap
struct node{
	int v,w;
};
vector<node> e[maxn];
int f[maxn][20],dep[maxn],dis[maxn],in[maxn],rev[maxn],vis[maxn],dfn;
void dfs(int u,int fa){
	in[u]=++dfn;
	rev[dfn]=u;
	f[u][0]=fa;
	for (node x : e[u]){
		int v=x.v,w=x.w;
		if (v==fa) continue;
		dep[v]=dep[u]+1;
		dis[v]=dis[u]+w;	
		dfs(v,u);
	}
}
int lca(int a, int b) {
    if (dep[a] < dep[b])
        swap(a, b);
    for (int i = 19; i >= 0; i--) {
        if (dep[f[a][i]] >= dep[b]) {
            a = f[a][i];
        }
    }
    if (a == b)
        return b;
    for (int i = 19; i >= 0; i--) {
        if (f[a][i] != f[b][i]) {
            a = f[a][i];
            b = f[b][i];
        }
    }
    return f[a][0];
}
int dist(int u,int v){
	return dis[u]+dis[v]-2*dis[lca(u,v)];
}
signed main(){
    n=read();
    for (int i=1;i<=n-1;i++){
    	int u=read(),v=read(),w=read();
    	e[u].push_back({v,w});
    	e[v].push_back({u,w});
	}
	m=read();
	dfs(1,0);
	for (int j=1;j<=19;j++){
	    for (int i=1;i<=n;i++){
	        f[i][j]=f[f[i][j-1]][j-1];
	    }
	}
	int ans=0,flag=0;
	while (m--){
		char opr;
		cin >> opr;
		if (opr=='+'){
			int x=read(),pre,suf;
			t.ins(t.root,in[x]);	
			pre=t.pre(t.root,in[x]);
			suf=t.suf(t.root,in[x]);
			if (pre==-inf){ //无解情况，这样就连接到dfs序最大的那个点，其他同理
				pre=t.pre(t.root,inf);
			}
			if (suf==inf){
				suf=t.suf(t.root,-inf);
			}		
			pre = rev[pre];
			suf = rev[suf];
			int add = dist(pre,x)+dist(x,suf)-dist(pre,suf);
			ans+=add;
		}
		else if(opr=='-'){
			int x=read(),pre,suf;	
			pre=t.pre(t.root,in[x]);
			suf=t.suf(t.root,in[x]);
			if (pre==-inf){
				pre=t.pre(t.root,inf);
			}
			if (suf==inf){
				suf=t.suf(t.root,-inf);
			}		
			t.del(t.root,in[x]);//放到查询后删除是因为防止平衡树为空，造成RE，这个不影响答案
			pre = rev[pre];
			suf = rev[suf];
			int add = dist(pre,x)+dist(x,suf)-dist(pre,suf);
			ans-=add;
		}
		else if (opr=='?'){
			cout << ans/2 << "\n"; 	//插入的点的两端都被算了两遍
		}
	}
}
```

---

## 作者：Add_Catalyst (赞：0)

# P10930 异象石 题解

---

## 思路分析

这题是让我们维护一个动态的树上路径并。

首先，树上路径并我们可以用虚树来求，所以如果有部分分的话，可以暴力建虚树来处理。

假设我们要求的虚树上的路径点集按照 DFS 序排好序后为 $\{ a_i \}_1^n$，那么我们所求的值即为：
$$
\frac{\sum_{i=1}^{n}dis(a_i,a_{((i+1) \bmod n)+1})}2
$$
但是直接这么做非常麻烦，我们把式子化简一下：
$$
\begin{aligned}
\frac{\sum_{i=1}^{n}dis(a_i,a_{((i+1) \bmod n)+1})}2 
& = \frac{\sum_{i=1}^{n}dis_{a_i}+dis_{a_{((i+1) \bmod n)+1}}-2dis_{lca(a_i,a_{((i+1) \bmod n)+1})}}2 \\
& = \sum_{i=1}^n dis_{a_i} - \sum_{i=1}^{n} dis_{lca(a_i,a_{((i+1) \bmod n)+1})}
\end{aligned}
$$
那么剩下的就非常简单了，用一个 `set<int>` 实现动态维护即可。

---

## CODE

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define RCL(a,b,c,d) memset(a,b,sizeof(c)*(d))
#define FOR(i,a,b) for(int i(a);i<=(int)(b);++i)
#define DOR(i,a,b) for(int i(a);i>=(int)(b);--i)
#define tomax(a,...) ((a)=max({(a),__VA_ARGS__}))
#define tomin(a,...) ((a)=min({(a),__VA_ARGS__}))
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;~i;y=(g)[i=(g)[i].nxt].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=1e5+10,lN=17,lV=lN+1;
namespace Tree {
	int n,idx;
	int dl[N],Lg[N],dep[N],dfn[N];
	int dlca[N][lV];
	ll dis[N];
	template<const int N,const int M>struct CFS {
		int tot,h[N];
		struct edge {
			int v,w,nxt;
			edge(int v=0,int w=0,int nxt=-1):v(v),w(w),nxt(nxt) {}
		} e[M];
		edge &operator[](int i) {
			return e[i];
		}
		void Init(int n) {
			tot=-1,RCL(h+1,-1,int,n);
		}
		void att(int u,int v,int w) {
			e[++tot]=edge(v,w,h[u]),h[u]=tot;
		}
		void con(int u,int v,int w) {
			att(u,v,w),att(v,u,w);
		}
	};
	CFS<N,N<<1> g;
	void dfs(int u,int fa) {
		dep[dfn[dl[u]=++idx]=u]=dep[fa]+1,dlca[dl[u]][0]=fa;
		EDGE(g,i,u,v)if(v^fa)dis[v]=dis[u]+g[i].w,dfs(v,u);
	}
	int dmin(int u,int v) {
		return dl[u]<dl[v]?u:v;
	}
	int lca(int u,int v) {
		if(u==v)return u;
		if((u=dl[u])>(v=dl[v]))swap(u,v);
		int x=Lg[v-u++];
		return dmin(dlca[u][x],dlca[v-(1<<x)+1][x]);
	}
	void Build() {
		cin>>n,g.Init(n),Lg[0]=-1;
		FOR(i,1,n)Lg[i]=Lg[i>>1]+1;
		FOR(i,2,n) {
			int u,v,w;
			cin>>u>>v>>w,g.con(u,v,w);
		}
		dfs(1,0);
		FOR(j,1,lN)FOR(i,1,n-(1<<j)+1)dlca[i][j]=dmin(dlca[i][j-1],dlca[i+(1<<(j-1))][j-1]);
	}
} using namespace Tree;
namespace VT {
	int Q;
	ll sum;
	set<int> st;
	int Pre(int u) {
		if(st.empty())return dfn[u];
		auto it=st.lower_bound(u);
		return dfn[it==st.begin()?*st.rbegin():*--it];
	}
	int Nxt(int u) {
		if(st.empty())return dfn[u];
		auto it=st.upper_bound(u);
		return dfn[it==st.end()?*st.begin():*it];
	}
	void Insert(int u) {
		int pre(Pre(dl[u])),nxt(Nxt(dl[u]));
		sum+=dis[u]-dis[lca(pre,u)]-dis[lca(u,nxt)]+dis[lca(pre,nxt)],st.insert(dl[u]);
	}
	void Erase(int u) {
		st.erase(dl[u]);
		int pre(Pre(dl[u])),nxt(Nxt(dl[u]));
		sum-=dis[u]-dis[lca(pre,u)]-dis[lca(u,nxt)]+dis[lca(pre,nxt)];
	}
	void Operate() {
		for(cin>>Q; Q; --Q) {
			char opt;
			int u;
			cin>>opt;
			if(opt=='+')cin>>u,Insert(u);
			else if(opt=='-')cin>>u,Erase(u);
			else cout<<sum<<endl;
		}
	}
} using namespace VT;
signed main() {
	Build(),Operate();
	return 0;
}
```

---

---

## 作者：鱼跃于渊 (赞：0)

## 解法

我们称呼有异象石的点为关键点。  
首先考虑如何处理询问，可以发现我们要尽可能的用长度短的边将所有关键点联通。  
由于这是一棵树，所以这些边是固定的，考虑如何快速计算出总边长。  
有一个结论，如果我们将所有的关键点按 dfs 序从大到小排一遍序，可以得到一个长为 $m$ 的序列 $p$，而答案正好是：  

$$ \dfrac{dis_{p_1,p_2}+dis_{p_2,p_3}+\ldots +  dis_{p_{n-1},p_m}+dis_{p_m,p_1}}{2}$$  

可以发现如果我们把 $dis_{x,y}$ 上的边列出来，每条边都恰好经过了两次，所以答案要除以 $2$。  
证明要涉及到虚树：  

+ 考虑随便钦定一个关键点为根，若一个点的子树内没有任何关键点，就删去它。  
+ 这样就生成了一颗新树，树上的边就是将所有关键点联通的最小边集，而这棵树的根和叶子结点必定是关键点。  
+ 考虑从根出发，用 dfs 遍历所有的叶子结点。  
+ 可以发现一条边只会在进/出子树时被经过，所以只会经过一条边两次。  
+ 如果我们把所有关键点按照 dfs 序排序，并将 $p$ 序列看成一个环，相邻的取 $dis$ 相加，就等价于用 dfs 遍历。  

考虑如何动态维护这个式子的结果，发现如果要加入或删除一个点，变化的贡献只涉及到它和左右两个点的 $dis$。  
直接用 set 来维护即可，时间复杂度 $O(m\log n)$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace fisher{
#define int long long
#define per(i,a,b) for(int i=(a);i<=(b);i++)
#define rep(i,b,a) for(int i=(b);i>=(a);i--)
#define epb emplace_back
#define bit(x) (1ll<<(x))
const int N=1e5+5;
struct edge{
    int v,w;
    edge(int _v=0,int _w=0){
        v=_v;w=_w;
    }
};
char op;
int n,m,sum;
int tot,lg[N],dfn[N],dep[N],dis[N],st[30][N];
vector <edge> e[N];
struct Node{
    int x;
    friend bool operator <(const Node &x,const Node &y){
        return dfn[x.x]>dfn[y.x];
    };
};
set <Node> node;
void dfs(int u,int fa){
    dfn[u]=++tot;
    st[0][dfn[u]]=fa;
    dep[u]=dep[fa]+1;
    for(auto x:e[u]) if(x.v!=fa){
        dis[x.v]=dis[u]+x.w;
        dfs(x.v,u);
    }
}
int get(int x,int y){
    return dep[x]<dep[y]?x:y;
}
int query(int l,int r){
    int k=lg[r-l+1];
    return get(st[k][l],st[k][r-bit(k)+1]);
}
int lca(int u,int v){
    if(u==v) return u;
    u=dfn[u];v=dfn[v];
    if(u>v) swap(u,v);
    return query(u+1,v);
}
int dist(int u,int v){
    return dis[u]+dis[v]-2*dis[lca(u,v)];
}
void update(int x,int op){
    if(node.size()==1) return;
    auto it=node.find({x});
    auto itl=it,itr=it;
    --(itl=(itl==node.begin()?node.end():itl));
    itr=((++itr)==node.end()?node.begin():itr);
    sum+=op*(dist((*itl).x,x)+dist(x,(*itr).x)-dist((*itl).x,(*itr).x));
}
void main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
    for(int i=1,u,v,w;i<n;i++){
        cin>>u>>v>>w;
        e[u].epb(v,w);
        e[v].epb(u,w);
    }
    dfs(1,0);
    per(i,2,n) lg[i]=lg[i>>1]+1;
    per(i,1,lg[n]) per(j,1,n-bit(i)+1)
        st[i][j]=get(st[i-1][j],st[i-1][j+bit(i-1)]);
    cin>>m;
    for(int i=1,x;i<=m;i++){
        cin>>op;
        if(op=='+'){
            cin>>x;
            node.insert({x});
            update(x,1);
        }
        else if(op=='-'){
            cin>>x;
            update(x,-1);
            node.erase({x});
        }
        else cout<<(sum>>1)<<'\n';
    }
}}
signed main(){
	fisher::main();
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

考虑按照 dfn 序将**关键点**的集合排序后为 $a_0,a_1,\cdots,a_k$，则答案为：

$$\frac{\sum\limits_{i=0}^k \operatorname{dis}(a_i,a_{(i+1) \bmod k})}{2}$$

简单证明一下：
  
> 需要找出包含一些**关键点**的最小联通导出子图。
>  
> 则随便以一个**关键点**为根，对于子树内没有**关键点**的子树直接丢掉，就形成了新树；新树的叶子节点绝对都是**关键点**。
> 
> 我们要找出新树的边集数量，即在 dfs 搜索的时候，每条边会在搜入子树时经过一次，出子树的时候经过一次，总计每条边会经过**两次**。
>
> 这个 dfs 搜索的过程等价于按照叶子节点 dfn 序的相邻取距离。

故我们需要动态维护上面那个式子的答案，注意到每次我们只删除或插入一个数，直接使用 `set` 维护即可。

~~如果你想，也自己写平衡树。~~

时间复杂度为 $O(Q \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=1e5+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
inline char get(){
    char c;
    while(1){
        c=getchar();
        if(c=='+'||c=='-'||c=='?')
          break;
    }
    return c;
}
char op;
ll n,m,u,v,w,x,ans,cnt;
ll dfn[N];
set<pi> S;
vector<pi> E[N];
void add(ll u,ll v,ll w){
    E[u].push_back({v,w});
    E[v].push_back({u,w});
}
void dfs(ll u,ll fa){
    dfn[u]=++cnt;
    for(auto t:E[u]){
        ll v=t.fi;
        if(v==fa)
          continue;
        dfs(v,u);
    }
}
namespace Tree{
    ll siz[N],z[N],fa[N],t[N],d[N],dep[N];
    void dfs1(ll u,ll f){
        siz[u]=1;
        for(auto t:E[u]){
            ll v=t.fi,w=t.se;
            if(v==f)
              continue;
            fa[v]=u;
            d[v]=d[u]+w;
            dep[v]=dep[u]+1;
            dfs1(v,u);
            siz[u]+=siz[v];
            if(siz[v]>siz[z[u]])
              z[u]=v;
        }
    }
    void dfs2(ll u,ll k){
        t[u]=k;
        if(!z[u])
          return ;
        dfs2(z[u],k);
        for(auto t:E[u]){
            ll v=t.fi;
            if(v==fa[u]||v==z[u])
              continue;
            dfs2(v,v);
        }
    }
    ll Lca(ll u,ll v){
        while(t[u]!=t[v]){
            if(dep[t[u]]<dep[t[v]])
              swap(u,v);
            u=fa[t[u]];
        }
        return dep[u]<dep[v]?u:v;
    }
    ll dis(ll u,ll v){
        return d[u]+d[v]-2ll*d[Lca(u,v)];
    }
    void init(){
        dfs1(1,1);
        dfs2(1,1);
    }
};
void insert(ll x){
    if(S.empty()){
        S.insert({dfn[x],x});
        return ;
    }
    set<pi>::iterator a,b;
    b=S.upper_bound({dfn[x],x});
    if(b==S.end()){
        a=b,a--;
        ans-=Tree::dis((*S.begin()).se,(*a).se);
        ans+=Tree::dis((*S.begin()).se,x);
        ans+=Tree::dis((*a).se,x);
    }
    else if(b==S.begin()){
        a=S.end(),a--;
        ans-=Tree::dis((*b).se,(*a).se);
        ans+=Tree::dis(x,(*a).se);
        ans+=Tree::dis(x,(*b).se);
    }
    else{
        a=b,a--;
        ans-=Tree::dis((*a).se,(*b).se);
        ans+=Tree::dis(x,(*a).se);
        ans+=Tree::dis(x,(*b).se);
    }
    S.insert({dfn[x],x});
}
void del(ll x){
    if(S.size()==1){
        S.erase({dfn[x],x});
        return ;
    }
    set<pi>::iterator a,b,c,d=S.end();
    a=b=c=S.find({dfn[x],x});
    a--,d--,c++;
    if(c!=S.end())
      ans-=Tree::dis((*c).se,(*b).se);
    if(b!=S.begin())
      ans-=Tree::dis((*a).se,(*b).se);
    if(c!=S.end()&&b!=S.begin())
      ans+=Tree::dis((*a).se,(*c).se);
    if(b==S.begin()){
        ans-=Tree::dis((*b).se,(*d).se);
        ans+=Tree::dis((*c).se,(*d).se);
    }
    if(c==S.end()){
        ans-=Tree::dis((*b).se,(*S.begin()).se);
        ans+=Tree::dis((*a).se,(*S.begin()).se);
    }
    S.erase(b);
}
int main(){
    n=read();
    For(i,1,n-1){
        u=read(),v=read(),w=read();
        add(u,v,w);
    }
    dfs(1,1);
    Tree::init();
    m=read();
    while(m--){
        op=get();
        if(op=='+'){
        	x=read();
        	insert(x);
		}
        else if(op=='-'){
        	x=read();
        	del(x);
		}
        else{
            write(ans>>1);
            putchar('\n');
        }
        //cerr<<(ans>>1)<<'\n';
//        cerr<<"Yes";
    }
    return 0;
}
```

---


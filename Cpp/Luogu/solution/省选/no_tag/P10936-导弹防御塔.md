# 导弹防御塔

## 题目描述

Freda 的城堡遭受了 $M$ 个入侵者的攻击！

Freda 控制着 $N$ 座导弹防御塔，每座塔都有足够数量的导弹，但是每次只能发射一枚。

在发射导弹时，导弹需要 $T_1$ 秒才能从防御塔中射出，而在发射导弹后，发射这枚导弹的防御塔需要 $T_2$ 分钟来冷却。

所有导弹都有相同的匀速飞行速度 $V$，并且会沿着距离最短的路径去打击目标。

计算防御塔到目标的距离 $Distance$ 时，你只需要计算水平距离，而忽略导弹飞行的高度。

导弹在空中飞行的时间就是 $Distance/V$ 分钟，导弹到达目标后可以立即将它击毁。

现在，给出 $N$ 座导弹防御塔的坐标，$M$ 个入侵者的坐标，$T_1,T_2$ 和 $V$。

因为 Freda 的小伙伴 Rainbow 就要来拜访城堡了，你需要求出至少多少分钟才能击退所有的入侵者。

## 说明/提示

数据保证 $1 \le N,M \le 50$，坐标绝对值不超过 $10000$，$T_1,T_2,V$ 为不超过 $2000$ 的正整数。

## 样例 #1

### 输入

```
3 3 30 20 1
0 0
0 50
50 0
50 50
0 1000
1000 0```

### 输出

```
91.500000
```

# 题解

## 作者：wangbinfeng (赞：9)

[![](https://img.shields.io/badge/题目-P10936_导弹防御塔-green)
![](https://img.shields.io/badge/难度-提高+/省选−-blue)
![](https://img.shields.io/badge/考点-匈牙利算法（二分图多重匹配）-red)
![](https://img.shields.io/badge/题型-传统题-yellow)](https://www.luogu.com.cn/problem/P10936)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

---
前置知识：匈牙利算法（二分图最大匹配），如果不会欢迎阅读[我写的另一篇题解](https://www.luogu.com.cn/article/hqxr10nu)。

对于本题来说，因为导弹防御塔与入侵者并不是一一对应（一个导弹防御塔）可以对应若干个敌人，那么考虑将一个导弹防御塔拆成若干个结点。

而多少个结点取决于总用时（即答案），发现答案满足单调性（因为如果能在某一时间内击退敌人，那么时间更长也一定可以），那么可以用二分答案，再用二分的 $mid$ 来拆点（导弹防御塔）。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200+9;
const double eps=1e-9;
vector<int>g[maxn];
int n,m,t,ans,match[maxn*maxn];
double t1,t2,v,dis[maxn][maxn],l=0.0,r=1e6;
pair<int,int>a[maxn],b[maxn];
bitset<maxn*maxn>vis;
inline bool dfs(const int u){
	for(int v:g[u])if(!vis[v]){
		vis[v]=true;
		if(!match[v]||dfs(match[v])){match[v]=u;return true;}
	}
	return false;
}
inline bool check(const double lim){
	const int num=min(m,int((lim+t2)/(t1+t2)+eps*0.01));
	//cerr<<"[stderr]"<<fixed<<setprecision(8)<<lim<<' '<<num<<endl;
	for(int i=1;i<=m;i++){
		g[i].clear();
		for(int j=1;j<=n;j++)for(int k=1;k<=num;k++)
            if(dis[i][j]+t1*k+t2*(k-1)<=lim)g[i].push_back((j-1)*num+k);
	}
	memset(match,0,sizeof match);
	for(int i=1;i<=m;i++){
		//cerr<<"[stderr]"<<i<<endl;
		vis.reset();
		if(!dfs(i))return false;
	}
	return true;
}
signed main(){
	// freopen("dat.in","r",stdin);
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	cin>>n>>m>>t1>>t2>>v,t1/=60.0;
	for(int i=1,x,y;i<=m;i++)cin>>a[i].first>>a[i].second;
	for(int i=1,x,y;i<=n;i++)cin>>b[i].first>>b[i].second;
	for(int i=1;i<=m;i++)for(int j=1;j<=n;j++)
            dis[i][j]=sqrt(double(a[i].first-b[j].first)*(a[i].first-b[j].first)+double(a[i].second-b[j].second)*(a[i].second-b[j].second))/v;
	for(double mid=(l+r)/2.0;r-l>eps;mid=(l+r)/2.0)
		if(check(mid))r=mid;
		else l=mid;
	cout<<fixed<<setprecision(6)<<r<<endl;
	//for(int i=1;i<=n;i++){for(int j=1;j<=m;j++)cerr<<fixed<<setprecision(2)<<dis[i][j]<<' ';cerr<<endl;}
}
```


[![](https://jrenc.azurewebsites.net/api/signature?code=zHZRCCItO-yB8t7d2KyitELFDwADnXIotkeeIQL3juyNAzFucnyrWA%3D%3D&name=thacks%20for%20reading%20%20%20%20%20%20%20%20by%20%40wangbinfeng(387009)&animate=true&speed=0.7&color=purple)](https://www.luogu.com.cn/user/387009)
$$\color{grey}{\tiny{\texttt{发现上面的签名是动图了吗？}}}$$

---

## 作者：HirasawaYuii (赞：2)

# [题目链接](https://www.luogu.com.cn/problem/P10936)

## 题目大意
城堡有 $m$ 个敌人、$n$ 个能发射导弹的防御塔。导弹的速度固定，都为 $v$。导弹需要 $T_1$ 秒发射，$T_2$ 分钟冷却，还需要防御塔到敌人距离的 $\frac{dis}{v}$ 的时间。给定防御塔和敌人的坐标，求需要多少分钟能够消灭所有敌人。
## 推导思路
如果短的时间能够消灭所有敌人，则长的也一定能。所以答案具有单调性，可以通过二分答案将求解转为判定。而该问题的判定，类似于一个导弹与敌人互相匹配的问题。对于这个问题，二分图的最大匹配就是一个不错的求解思路。

[二分图最大匹配](https://oi-wiki.org/graph/graph-matching/bigraph-match/)
## 细节实现
由于每个导弹可以多次匹配，所以转化为多次匹配的拆点做法。设左部为敌人，右部为导弹，遍历连边即可。连边的细节较多，在下面的代码中有注释体现。
## 代码

```cpp
// Problem: P10936 导弹防御塔
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10936
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// Date: 2024-12-20 18:43:22
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define mst(x, y) memset(x, y, sizeof(x))
#define pii pair<int, int>
#define fi first
#define se second
#define mp(x, y) make_pair(x, y)

const int N = 55, M = 200005, inf = 0x3f3f3f3f; //记得空间开足够大，可以在不影响时间的情况下（memset）大概估一下
const double eps = 1e-8;

int n, m, idx;
int vis[M], mat[M], hd[M], ver[M], nxt[M];
double t1, t2, v;
struct pos{
	int x, y;
}ene[N], tow[N];

void add(int x, int y){
	nxt[++idx] = hd[x];
	ver[idx] = y;
	hd[x] = idx;
}
double cal(int i, int j){ //计算导弹飞行到敌人时间
	return sqrt((ene[i].x-tow[j].x)*(ene[i].x-tow[j].x)+(ene[i].y-tow[j].y)*(ene[i].y-tow[j].y))/v;
}
bool dfs(int x){ //二分图最大匹配增广路算法板子
	for(int i = hd[x];i;i = nxt[i]){
		int y = ver[i];
		if(vis[y]) continue;
		vis[y] = 1;
		if(!mat[y] || dfs(mat[y])){
			mat[y] = x;
			return true;
		}
	}
	return false;
}
bool check(double x){ //x为最大时间
	mst(mat, 0);mst(hd, 0);idx = 0; //最大匹配+链式前向星存图初始化
	int maxk = min(m, (int)floor((x+t2)/(t1+t2))); //maxk为最大时间内导弹最多的发生数（因为求的是最多次数，所以不考虑时间）
	for(int i = 1;i <= m;i++){ //遍历敌人
		for(int j = 1;j <= n;j++){ //遍历防御塔
			for(int k = 1;k <= maxk;k++){ //遍历导弹个数
				if(double(cal(i, j)+(k-1)*(t1+t2)+t1) > x) continue; //判断对于第i个敌人第j个防御塔的第k个导弹，是否能在最大时间限制内发射
				//这里需要详细注意一下，(j-1)*maxk+k即为第j个防御塔的第k个导弹编号，但导弹编号会和敌人编号重复，所以将导弹编号加上敌人个数防止重复
				add(i, m+(j-1)*maxk+k); 
				add(m+(j-1)*maxk+k, i); //连双向边
			}
		}
	}
	for(int i = 1;i <= m;i++){
		mst(vis, 0);
		if(!dfs(i)) return false; //如果有敌人无法匹配到导弹（即不能在最大时间内被杀死），则直接返回false
	}
	return true;
}
void init(){
	cin >> n >> m >> t1 >> t2 >> v;
	t1 /= 60;//t1单位为秒，要转化为分钟
	for(int i = 1;i <= m;i++) cin >> ene[i].x >> ene[i].y;
	for(int i = 1;i <= n;i++) cin >> tow[i].x >> tow[i].y;
}
void solve(){
	double l = 0, r = 100000, mid;
	while(r-l >= eps){//实数二分
		mid = (l+r)/2;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%.6lf", l);
}

int main(){
	init();
	solve();
	return 0; 
}
```

---

## 作者：_jimmywang_ (赞：2)

因为答案是入侵者被消灭时的时间最大值，所以并不好用某个值之和计算。最大值最小，我们考虑二分答案。

假设现在二分到的时间是 $t$，那么我们的问题转化为判定 $t$ 时间内能否消灭所有入侵者。注意到一个入侵者被多枚**炮弹**打中是不优的；一枚**炮弹**最多打一个入侵者。联想到二分图，建立模型：

左部点是**炮弹**，具体的，可以用 $(i,j)$ 表示，意义为第 $i$ 座防御塔的第 $j$ 枚炮弹。右部点为入侵者。左右有连边表示 $t$ 时间内 $(i,j)$ 这枚炮弹可以打到这个入侵者。最大匹配等于 $m$ 即为合法。

设炮弹坐标 $a_i$，入侵者坐标 $b_k$，那么有连边当且仅当 $(i,j)$ 发射出去的时间加上炮弹飞的时间之和小于等于 $t$，也即：

$$j\times\dfrac{T_1}{60}+(j-1)\times T_2+\dfrac{dis(a_i,b_k)}{V}\le t$$

一个坑点是 $T_1$ 在题面中的单位是**秒**，需要转化成分钟。

可能有同学会有疑问：这种方式如何保证一座塔是一颗一颗炮弹打出去的，不会跳着打？因为假设我们允许跳着打，那么这种方案一定不优，在 $t$ 减小时会自动把跳着打的边删掉，强制让打出的炮弹连续（因为如果 $(i,j)$ 满足条件，那么 $(i,j-1),(i,j-2)\dots$ 也一定满足）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(ll i=a;i<=b;i++)
#define wt int tt=d;while(tt--)
#define py puts("Yes")
#define pn puts("No")
#define fe(i,e) for(int i=0;i<e.size();i++)
#define vi vector<ll>
inline ll rd() {
	ll x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
#define d rd()
#define pb push_back
struct node{ll u,v,w,nx;}e[1000010];
ll hd[100010],cnt=1;
void add(ll u,ll v,ll w){e[++cnt]={u,v,w,hd[u]};hd[u]=cnt;}
void ad(ll u,ll v,ll w){add(u,v,w),add(v,u,0);}

ll de[100010],cur[100010];
ll dis[100010];
#define inf 0x3f3f3f3f
queue<ll>q;
ll nodes,S,T;
bool bfs(){
    while(!q.empty())q.pop();
    f(i,1,nodes)cur[i]=hd[i],de[i]=inf;de[S]=0;q.push(S);
    while(!q.empty()){
        ll u=q.front();q.pop();
        for(int i=hd[u];i;i=e[i].nx){
            ll v=e[i].v;if(e[i].w==0)continue;
            if(de[v]==inf){
                de[v]=de[u]+1;q.push(v);
                if(v==T)return 1;
            }
        }
    }return 0;
}
ll dfs(ll u,ll fl){
    if(u==T)return fl;
    ll res=0,k=0;
    for(int i=cur[u];i;i=e[i].nx){
        cur[u]=i;if(e[i].w==0)continue;
        ll v=e[i].v;if(de[v]==de[u]+1){
            k=dfs(v,min(fl,e[i].w));
            e[i].w-=k,e[i^1].w+=k;
            fl-=k,res+=k;
        }
    }return res;
}
ll n,m;
ll dinic(){
    ll res=0;
    while(bfs())res+=dfs(S,inf);
    return res;
}
void clear(){
    f(i,1,nodes)hd[i]=0;
    f(i,1,cnt)e[i]={0,0,0,0};
    cnt=1;
}
struct pnt{double x,y;}A[55],B[55];
double dist(pnt a,pnt b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
double T1,T2,V;
ll id(ll i,ll j){return (i-1)*m+j;}
bool ch(double x){
    clear();
    f(i,1,n){
        ad(S,id(i,1),1);
        f(j,2,m)ad(S,id(i,j),1);
    }
    f(i,1,m)ad(i+n*m,T,1);
    // cout<<x<<endl;
    f(i,1,n)f(j,1,m){
        double t=dist(A[i],B[j])/V+T1;
        f(k,1,m){
            if(t<=x)ad(id(i,k),j+n*m,1);//,printf("(%lld,%lld) %lld\n",i,k,j);
            else break;
            t+=T1+T2;
        }
    }return dinic()==m;
}
int main(){
    n=d,m=d,T1=d,T2=d,V=d;T1/=60;
    f(i,1,m)B[i]={(double)d,(double)d};
    f(i,1,n)A[i]={(double)d,(double)d};
    S=n*m+m+1,T=nodes=S+1;
    double l=0,r=1000000;
    while(r-l>1e-6){
        double mid=(l+r)/2;
        if(ch(mid))r=mid;
        else l=mid;
    }printf("%.6lf",r);
    return 0;
}
```

---

## 作者：20111019Yu (赞：2)

### 思路
观察题目，显而易见能发现若值比答案更大时一定可以，所以二分最后的答案。

接下来对于每个敌人，将所有防御塔能在规定时间打到他的导弹和他连边，然后跑二分图最大匹配。注意每个导弹都要编号。

代码就亿点点困难。
### code
```cpp
#include <bits/stdc++.h>
#define int long long
const double eps = 1e-5;
using namespace std;
int n, m, match[2505], visit[55];
double t1, t2, v;
struct node{
	double x, y;
} a[55], b[55];
vector<int> vec[55];

bool solve(int x, int tag){
	if(visit[x] == tag) return 0;
	visit[x] = tag;
	for( auto &i : vec[x] ){
		if(!match[i] || solve(match[i], tag)){
			match[i] = x;
			return 1;
		}
	}
	return 0;
}
bool check(double mid){
	memset(match, 0, sizeof(match));
	memset(visit, 0, sizeof(visit));
	for( int i = 1; i <= m; i++ ) vec[i].clear();
	int num = min(m, max(0ll, (int)floor((mid + t2) / (t1 + t2))));
	for( int i = 1; i <= m; i++ ){
		for( int j = 1; j <= n; j++ ){
			for( int k = 1; k <= num; k++ ){
				double arrive = sqrt(pow(b[i].x - a[j].x, 2) + pow(b[i].y - a[j].y, 2)) / v + (k - 1) * 1.00 * (t1 + t2) + t1;
				if(arrive > mid) continue;
				vec[i].push_back((j - 1) * num + k);
			}
		}
	}
	for( int i = 1; i <= m; i++ ){
		if(!solve(i, i)) return 0;
	}
	return 1;
}

signed main(){
	cin >> n >> m >> t1 >> t2 >> v;
	t1 /= 60.00;
	for( int i = 1; i <= m; i++ ) cin >> b[i].x >> b[i].y;
	for( int i = 1; i <= n; i++ ) cin >> a[i].x >> a[i].y;
	double l = 0, r = 1e9;
	while(l + eps < r){
		double mid = (l + r) / 2.00;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%.6lf", l);
	return 0;
}
```

---

## 作者：Enoch2013 (赞：1)

### 注：本专栏参考自《算法竞赛进阶指南》
# 重要知识点
1. 二分答案（大家应该都会，我就不多说了，为什么要用，在分析里找）；
2. 二分图最大匹配，建议大家看一下我的[这篇专栏](https://www.luogu.com.cn/article/lrjw6tm4)。

# 分析 & 代码
如果时间较短时能击退入侵者，那么时间较长时也能击退入侵者，显然，本题具有单调性。我们使用二分答案，设当前二分的中值为击退时间，我们就可以把问题转化为“能否在当前击退时间（当前二分中值）之内击退所有入侵者”。

首先我们要注意：**每个入侵者被攻击一次后就会死，虽然每个塔台可以发射多枚导弹，但是，一个导弹只能击退一个入侵者**。（~~这入侵者也太弱了qwq~~

已知，发射预热时间 $T_1$、冷却时间 $T_2$，我们容易计算出每座塔在当前二分的击退时间内至多能够发射多少枚导弹，我们将它记为 $P$。经过分析，我们容易发现，这道题是一个**多重匹配问题**，我们可以把入侵者看作二分图的左部节点，把每座塔台拆成 $P$ 个导弹，作为二分图的右部节点。最终，共有 $M$ 个左部节点，和 $N \times P$ 个右部节点。

注意，因为塔台和入侵者的坐标各不相同，所以导弹飞到飞到入侵者的时间也可能不同。我们在连边时，还需要检查导弹是否有足够的时间飞到入侵者。因此，一座塔台的 $P$ 个导弹是不等价的，这个**多重匹配问题**必须使用**拆点**的方法解决。如果在当前二分中值时间内，第 $i(1 \leq i \leq M)$ 个入侵者能够被第 $j(1 \leq j \leq N)$ 座塔台的第 $k(1 \leq k \leq P)$ 个导弹击中，那么，在第 $i$ 个左部节点和第 $(j - 1) \times P + K$ 个右部节点之间连一条无向边。

用匈牙利算法计算该二分图的最大匹配。若每个左部节点都能找到匹配节点，说明能够在当前二分中值的时间内击退所有入侵者，就令二分上界为当前中值，否则令二分下界为二分中值加一。

最后附上代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define N 3005
using namespace std;
const double M = 1e-5;
struct node
{
    double x, y;
} a[N], b[N];
vector<int> g[N];
int match[N], n, m, vis[N];
double t1, t2, v;
bool dfs(int x, int tag)
{
	if (vis[x] == tag)
        return 0;
	vis[x] = tag;
	for (auto to : g[x])
		if (!match[to] || dfs(match[to], tag))
        {
			match[to] = x;
			return true;
		}
	return false;
}
bool check(double mid)
{
    memset(match, 0, sizeof match);
	memset(vis, 0, sizeof vis);
	for (int i = 1; i <= m; i++)
        g[i].clear();
	int num = min(m, max(0ll, (int)floor((mid + t2) / (t1 + t2))));
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= num; k++)
            {
				double tmp = sqrt(pow(b[i].x - a[j].x, 2) + pow(b[i].y - a[j].y, 2)) / v + (k - 1) * 1.00 * (t1 + t2) + t1;
				if (tmp > mid)
                    continue;
				g[i].push_back((j - 1) * num + k);
			}
	for (int i = 1; i <= m; i++)
		if (!dfs(i, i))
            return false;
	return true;
}
signed main()
{
    cin >> n >> m >> t1 >> t2 >> v;
    t1 /= 60.00;
    for (int i = 1; i <= m; i++)
        cin >> b[i].x >> b[i].y;
	for (int i = 1; i <= n; i++)
        cin >> a[i].x >> a[i].y;
	double l = 0, r = 1e9;
	while (l + M < r)
    {
		double mid = (l + r) / 2.00;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%.6lf", l);
	return 0;
}
```

---

## 作者：xuchuhan (赞：1)

之前学二分图最大匹配的时候做到了这道题，最近回顾的时候发现这道题还可以交题解，遂写之。

首先直接求答案不好求解，而且发现答案具有单调性，考虑二分答案。设当前二分到时间为 $mid$ 分钟。若第 $i$ 个防御塔发射第 $k$ 次能够击中第 $j$ 个入侵者，则必须有 $\dfrac{T_1}{60}+(k-1)\times(\dfrac{T_1}{60}+T_2)+\dfrac{dis(a_i,b_j)}{V}\leq mid$，其中 $\dfrac{T_1}{60}+(k-1)\times(\dfrac{T_1}{60}+T_2)$ 为等待发射时间，$\dfrac{dis(a_i,b_j)}{V}$ 为导弹飞行时间。考虑将一个炮台拆成多枚导弹先后发射，若一枚导弹可以集中某个入侵者，则将该入侵者与该导弹连边。这样形成了一个二分图，入侵者为左部点，导弹为右部点。如果所有入侵者都匹配到了导弹，即二分图最大匹配数为 $m$ 时，则当前二分的时间内可以消灭所有入侵者。

这个思路不难，但是代码小细节有点多，比如：

- $T_1$ 输入的时候是秒，需要统一成分，这个在上文有体现，即 $T_1$ 需要除以 $60$。
- 先输入 $m$ 个入侵者，在输入 $n$ 个炮台。
- 注意每次二分图最大匹配的时候要清空数组等。

code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define eps 1e-6 
using namespace std;
const int N=55;
int n,m,match[N*N],vis[N*N];
double T1,T2,V;
struct node{double x,y;}a[N],b[N];
vector<int>v[N];
double Euc(node X,node Y){double res=sqrt((X.x-Y.x)*(X.x-Y.x)+(X.y-Y.y)*(X.y-Y.y));return res;}//欧几里得距离 
bool DFS(int x){//二分图最大匹配 
	for(int i=0;i<v[x].size();i++){
		int to=v[x][i];
		if(!vis[to]){
			vis[to]=1;
			if(!match[to]||DFS(match[to])){
				match[to]=x;
				return 1;
			}
		}
	}
	return 0;
}
bool check(double mid){
	int P=(mid-T1)/(T1+T2)+1;P=min(P,m);//每个炮台可以发射的导弹上线 
	for(int j=1;j<=m;j++){
		v[j].clear();//注意清空 
		for(int i=1;i<=n;i++){
			for(int k=1;k<=P;k++){
				double tim=T1+(k-1)*1.0*(T1+T2)+Euc(a[i],b[j])/V;//所需时间 
				if(tim>mid)continue;
				v[j].push_back((i-1)*P+k);//(i-1)*P+k即拆点操作 
			}
		}
	}
	memset(match,0,sizeof(match));
	for(int i=1;i<=m;i++){
		memset(vis,0,sizeof(vis));
		if(!DFS(i))return 0;//可以直接返回 
	}
	return 1;
}
signed main(){
	cin>>n>>m>>T1>>T2>>V;T1/=60.0;
	for(int i=1;i<=m;i++)cin>>b[i].x>>b[i].y;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	double lt=0,rt=1e8;
	while(lt+eps<rt){//二分答案 
		double mid=(lt+rt)/2.0;
		if(check(mid))rt=mid;
		else lt=mid;
	}
	printf("%.6lf",rt);
	return 0;
}
```

---

## 作者：Kingna (赞：1)

## [P10936](https://www.luogu.com.cn/problem/P10936)

一个入侵者 $a$ 被第 $b$ 号塔的第 $c$ 次导弹袭击中，可以连边 $a\to (b,c)$。

因为有时间的限制，显然不能连接 $a\to (b,+∞)$。因为时间具有单调性，时间越多，入侵者就越能被消灭。则二分时间 $mid$，若第 $b$ 号塔的第 $c$ 次导弹的发射时间小于等于 $mid$，则连边。


最后看每一个入侵者是否被一个点对 $(b,c)$ 所连接，即可以采用二分图匹配。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 3e5 + 5, mod = 998244353;

int n, m, match[N], vis[N];
double T1, T2, V;
struct edge {
	double x, y;
}a[N], b[N];
vector<int> G[N];

int solve(int x, int tag) {
	if (vis[x] == tag) return 0;
	vis[x] = tag;
	for (auto y : G[x]) {
		if (!match[y] || solve(match[y], tag)) {
			match[y] = x;
			return 1;
		}
	}
	return 0;
}

int check(double mid) {
	memset(match, 0, sizeof match);
	memset(vis, 0, sizeof vis);
	_for(i, 1, m) G[i].clear();
	int num = min(m, (int)floor((mid + T2) / (T1 + T2)));
	_for(i, 1, m) {
		_for(j, 1, n) {
			_for(k, 1, num) {
				double tmp = sqrt((b[i].x - a[j].x) * (b[i].x - a[j].x) + (b[i].y - a[j].y) * (b[i].y - a[j].y)) / V + (k - 1) * (T1 + T2) + T1;
				if (tmp > mid) continue;
				G[i].push_back((j - 1) * num + k + m);
			} 
		}
	}
	_for(i, 1, m) {
		if (!solve(i, i)) return 0;
	}
	return 1;
}

signed main() {
	cin >> n >> m >> T1 >> T2 >> V;
	T1 /= 60.0;
	_for(i, 1, m) cin >> b[i].x >> b[i].y;
	_for(i, 1, n) cin >> a[i].x >> a[i].y;
	double l = 1, r = 1e6;
	int cnt = 100;
	while (cnt--) {
		double mid = (l + r) / 2;
		if (check(mid)) r = mid;
		else l = mid;
	}
	printf("%.10lf", l);
}
```

---

## 作者：WangTianJiao (赞：0)

# 前置知识

匈牙利算法求二分图最大匹配

# 题意分析

显然时间越**长**越容易达成目标，于是可以通过二分答案把问题转化成判断**固定时间** $tm$ 之内能不能摧毁所有目标。由于每个防御塔能发射多枚导弹，考虑把每颗导弹拆开来看。每枚导弹只摧毁一个目标，每个目标只被一颗导弹摧毁，把导弹作为左部，敌人作为右部，求这个二分图的最大匹配。如果最大匹配等于 $M$ 就可以摧毁。

# 具体实现

**注意：题目中 $T_1$ 的单位是秒，下面的 $T_1$ 都是换算成分钟后的结果。**

钦定时间 $tm$ 之后，计算防御塔共经历多少个完整周期（长度为 $T_1 + T_2$ ），就至少能发射多少导弹。如果经历这些完整周期之后剩余时间大于 $T_1$，就可以再发射一颗。记每个防御塔导弹数目为 $cnt$。所有导弹共 $N \times cnt$ 颗。

那么，对于每个防御塔，每颗导弹如果之前共发射了 $k$ 颗导弹（$0 \le k < cnt$），那么需要等待 $k(T_1 + T_2) + T_1$ 分钟才可以发射，**可供飞行的时间**就是 $tm - k(T_1 + T_2) - T_1$ 分钟，飞行距离等于上式乘上 $V$。对于每个敌人，如果导弹所属防御塔和它的距离**小于等于**飞行距离，这枚导弹就有希望击毁它，在这枚导弹和敌人之间连一条边。

连边完成后，用匈牙利算法求二分图最大匹配。如果结果等于 $M$，就可以摧毁，把上界缩小；否则增大下界。实测最大答案约 $3\times 10^4$。

# 代码（求评价码风）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const int MAXN = 6005;
const db eps = 1e-6;
vector<int> edge[MAXN];
int vis[MAXN], match[MAXN];
struct pt
{
	db x, y;
}twr[MAXN], tgt[MAXN];
db T1, T2, V;
int n, m;
bool dfs(int now)
{
	for (auto v : edge[now])
	{
		if (!vis[v])
		{
			vis[v] = 1;
			if (!match[v] || dfs(match[v]))
			{
				match[v] = now;
				return true;
			}
		}
	}
	return false;
}
bool check(db tm)
{
	int cnt = int(tm / (T1 + T2));
	if ((T1 + T2) * cnt + T1 < tm)
		++cnt;
	for (int i = 0; i < MAXN; ++i)
		edge[i].resize(0);
	memset(vis, 0, sizeof(vis));
	memset(match, 0, sizeof(match));
	for (int i = 1; i <= n; ++i)
	{
		for (int k = 0; k < cnt; ++k)
		{
			db wait = k * (T1 + T2) + T1;
			db maxlen = (tm - wait) * V;
			for (int j = 1; j <= m; ++j)
			{
				if (maxlen >= hypot(tgt[j].x - twr[i].x, tgt[j].y - twr[i].y))
				{
					edge[(i - 1) * cnt + k + 1].push_back(j);
				}
			}
		}
	}
	int ans = 0;
	for (int i = 1; i <= n * cnt; ++i)
	{
		memset(vis, 0, sizeof(vis));
		if (dfs(i))
			++ans;
	}
	return ans >= m;
}
int main()
{
	cin >> n >> m >> T1 >> T2 >> V;
	T1 /= 60;
	for (int i = 1; i <= m; ++i)
		cin >> tgt[i].x >> tgt[i].y;
	for (int i = 1; i <= n; ++i)
		cin >> twr[i].x >> twr[i].y;
	db L = 0.0, R = 3e4;
	while (R - L > eps) 
	{
		db Mid = (R + L) / 2.0;
		if (check(Mid))
			R = Mid;
		else
			L = Mid;
	}
	printf("%.6lf\n", L);
	return 0;
}

```

---

## 作者：Genius_Star (赞：0)

### 思路：

容易发现具有单调性，故考虑二分答案。

我们令 $(i, j)$ 表示第 $i$ 个炮台的第 $j$ 个炮弹，则 $(i, j)$ 能打到第 $k$ 个入侵者，当且仅当：

$$j \frac{T_1}{60} + (j - 1)T2 + \frac{\operatorname{dis}(X_i, Y_k)}{V} \le mid$$

此时建立 $k \to (i, j)$ 的边。

那么目前形成了一个二分图，左部点有 $nm$ 个，右部点有 $m$ 个，判断是否存在一个完美匹配，即最大匹配数位 $m$。

直接跑匈牙利算法即可，时间复杂度为 $O(N^5 \log W)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 1e4 + 10;
const db eps = 1e-7;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Point{
	db x, y;
}a[N], b[N];
db n, m, t1, t2, v;
int my[N], f[N];
vector<int> E[N];
inline db dis(Point A, Point B){
	return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
}
inline void add(int u, int v){
	E[u].push_back(v);
}
inline bool dfs(int u){
	for(auto v : E[u]){
		if(f[v])
		  continue;
		f[v] = 1;
		if(!my[v] || dfs(my[v])){
			my[v] = u;
			return 1;
		}
	}
	return 0;
}
inline bool check(db x){
	for(int i = 1; i <= m; ++i)
	  E[i].clear();
	for(int i = 1; i <= n; ++i){
		for(int k = 1; k <= m; ++k){
		    for(int j = 1; j <= m; ++j){
			    if(j * t1 + (j - 1) * t2 + dis(a[i], b[k]) / v <= x)
			      add(k, (i - 1) * m + j);
			    else
			      break;
			}		
		}
	}
	memset(my, 0, sizeof(my));
	for(int i = 1; i <= m; ++i){
		memset(f, 0, sizeof(f));
		if(!dfs(i))
		  return 0;
	}
	return 1;
}
bool End;
int main(){
	n = read(), m = read(), t1 = read(), t2 = read(), v = read();
	t1 /= 60.0;
	for(int i = 1; i <= m; ++i)
	  b[i] = {(db)read(), (db)read()};
	for(int i = 1; i <= n; ++i)
	  a[i] = {(db)read(), (db)read()};
	db l = 1, r = 1000000;
	while(r - l > eps){
		db mid = (l + r) / 2.0;
//		cerr << mid << ' ' << check(mid) << '\n';
		if(check(mid))
		  r = mid;
		else
		  l = mid;
	}
	printf("%.6lf\n", l);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：Ortus (赞：0)

显然直接求最小值是不好做的，所以考虑二分，观察到 $n,m$ 都特别小，因为每个防御塔最多会发射 $m$ 发导弹，于是可以枚举第 $i$ 个防御塔已经发射过 $j$ 次，看能否在二分的 $mid$  时间内打中第 $k$ 个入侵者，如果可以则 $i+j \times n$ 向 $n \times m+k$  连边 这里的时间复杂度是 $O(n \times m^2)$ 的，然后判断所有入侵者是否能被打败，因为只有两种点，防御塔和入侵者，所以求一遍二分图最大匹配即可。

code
```cpp
#include <bits/stdc++.h>
//#define int long long
#define ull unsigned long long
#pragma GCC optimeze(3)
#pragma GCC optimeze(2)
#define PII pair<int, int>
#define pb push_back
#define fi first
#define se second
#define lowbit(x) (x & (-x))
using namespace std;
const int N=2e5+5;
const double eps=1e-5;
int n,m,co[N],ans=1,x[N],y[N],bj[N],st[N];
double t1,t2,v;
vector<int>G[N];
double ti(int i,int j){
	return sqrt((x[i]-x[j+n])*(x[i]-x[j+n])+(y[i]-y[j+n])*(y[i]-y[j+n]))/v;
}
bool match(int t){
	for(auto to:G[t]){
		if(!st[to]){
			st[to]=1;
			if(!bj[to]||match(bj[to])){
				bj[to]=t;
				return 1;
			}
		}
	}
	return 0;
}
bool check(double p){
	for(int i=1;i<=n*m+m;i++)bj[i]=0;
	int pp=n*m,sum=0;
	for(int i=1;i<=pp;i++)G[i].clear();
	for(int i=1;i<=n;i++){
		for(int q=0;q<m;q++){
			for(int j=1;j<=m;j++){
				if(q*(t1+t2)+t1+ti(i,j)<=p){
					G[i+q*n].pb(pp+j);
				}	
			}
		}
	}
	for(int i=1;i<=n*m;i++){
		for(int j=1;j<=m;j++)st[j+pp]=0;
		if(match(i))sum++;
	}
	return sum==m;
}
signed main(){
	ios::sync_with_stdio(0);  
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>t1>>t2>>v;
	t1/=60;
	for(int i=1;i<=m;i++){
		cin>>x[i+n]>>y[i+n];
	}
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
	}
	double l=0,r=1e7;
	while(r-l>eps){
		double mid=(l+r)/2;
		if(check(mid))r=mid;
		else l=mid;
	}
	printf("%.6lf",l);
	return 0;
}

---


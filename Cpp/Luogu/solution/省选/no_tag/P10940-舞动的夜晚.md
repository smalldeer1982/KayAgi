# 舞动的夜晚

## 题目描述

$L$ 公司和 $H$ 公司举办了一次联谊晚会。

晚会上，$L$ 公司的 $N$ 位员工和 $H$ 公司的 $M$ 位员工打算进行一场交际舞。

在这些领导中，一些 $L$ 公司的员工和 $H$ 公司的员工之间是互相认识的，这样的认识关系一共有 $T$ 对。

舞会上，每位员工会尝试选择一名 Ta 认识的对方公司的员工作为舞伴，并且每位员工至多跳一支舞。

完成的交际舞的数量越多，晚会的气氛就越热烈。

顾及到晚会的气氛，员工们希望知道，哪些员工之间如果进行了交际舞，就会使整场晚会能够完成的交际舞的最大数量减小。

## 说明/提示

数据保证，$1 \le N,M \le 10000$，$1 \le T \le 100000$，$1 \le x \le N$，$1 \le y \le M$。

## 样例 #1

### 输入

```
3 3 6
1 1
2 1
2 2
3 1
3 2
3 3```

### 输出

```
3
2 4 5```

# 题解

## 作者：_jimmywang_ (赞：4)

省流：二分图最大匹配的**必不经边**。即：任意最大匹配都不会用到的边。因此但凡用了这条边，一定不会有最大匹配。因此与题意等价。

本篇题解会顺带讲解**必经边**，**非必经边**，**必不经边**的判定方法，其实都是统一的。

-------------

首先用网络流随便搞出一个最大匹配以及他的残量网络。

众所周知，我们可以在原图中找到一条增广路（可以经过一端是源点或者汇点的边），并反转这条路径上的所有边的状态（匹配 $\to$ 不匹配 或 不匹配 $\to$ 匹配）使得反转后仍然是一个匹配。

在最大匹配中，不存在源点到汇点的增广路。想要改变某条边 $(u,v)$ 的状态（假设此时 1 流量的方向是 $u \to v$），只能尝试寻找 $v \rightsquigarrow u$ 的一条增广路。如果能找到，那么这条边的状态可以被反转。同时 $u\to v \rightsquigarrow u$ 会形成一个环，所以整张图流量不变，反转后仍然是一个最大匹配。反之，若找不到，则一定不能被反转。

稍加思考可以发现，如果我们把图上的所有边按照 1 流量的方向定向，那么 $u \to v$ 可反转，等价于 **$u$ 和 $v$ 在定向后的有向图中属于同一个强连通分量**。反之亦然，即不可反转，等价于 **$u$ 和 $v$ 在定向后的有向图中不属于同一个强连通分量**。

因此，定向完以后跑一遍 tarjan，我们就可以判断每一条边的状态是否可以改变，其中：

- 若一条匹配边 $(u,v)$ （$u$ 左 $v$ 右）不可被反转，那么这是一条 **必经边**；否则是**非必经边**。

- 若一条非匹配边 $(u,v)$ （$u$ 左 $v$ 右）不可被反转，那么这是一条 **必不经边**；否则是**非必经边**。

至此，求法结束。

总结一下流程：

1. 跑一遍网络流，求出残量网络。
2. 把所有边按照 1 流量方向定向，在新有向图上跑 tarjan 求强连通分量。
3. 枚举所有边，判断其两端点是否在同一个强连通分量中。

而对于此题，我们只需要找出不能反转的非匹配边即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
inline ll rd() {
	ll x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
#define d rd()
#define pb push_back
struct edge{ll u,v,w,id,nx;}e[2000010];
ll cnt=1,hd[1000010];
void add(ll u,ll v,ll w,ll id){e[++cnt]={u,v,w,id,hd[u]};hd[u]=cnt;}
void ad(ll u,ll v,ll w,ll id){add(u,v,w,id),add(v,u,0,id);}
ll n,m,S,T,nodes;
ll cur[1000010];
ll dep[1000010];
#define inf 0x3f3f3f3f3f3f3f3f
queue<ll>q;
bool bfs(){
	f(i,1,nodes)dep[i]=inf,cur[i]=hd[i];
	dep[S]=0;while(!q.empty())q.pop();
	q.push(S);while(!q.empty()){
		ll u=q.front();q.pop();
		for(int i=hd[u];i;i=e[i].nx){
			ll v=e[i].v;if(!e[i].w)continue;
			if(dep[v]==inf){
				dep[v]=dep[u]+1,q.push(v);
				if(v==T)return 1;
			}
		}
	}return 0;
}ll dfs(ll u,ll fl){
	if(u==T)return fl;
	ll sum=0;for(int i=cur[u];i&&fl;i=e[i].nx){
		ll v=e[i].v;cur[u]=i;if(!e[i].w||dep[v]!=dep[u]+1)continue;
		ll k=dfs(v,min(fl,e[i].w));
		fl-=k,sum+=k,e[i].w-=k,e[i^1].w+=k;
	}return sum;
}ll dinic(){
	ll res=0;while(bfs())res+=dfs(S,inf);
	return res;
}
ll dfn[100010],low[100010],tim;
ll bel[100010],scc;
ll st[100010],tp;
bool ins[100010];
vector<ll> E[100010];
void dfs(ll u){
	dfn[u]=low[u]=++tim;
	st[++tp]=u,ins[u]=1;
	for(auto v:E[u]){
		if(!dfn[v])dfs(v),low[u]=min(low[u],low[v]);
		else if(ins[v])low[u]=min(low[u],dfn[v]);
	}if(low[u]==dfn[u]){
		scc++;ll now;while(1){
			now=st[tp--];
			ins[now]=0,bel[now]=scc;
			if(now==u)break;
		}
	}
}
bool is[100010];
int main(){
	n=d,m=d;S=n+m+1,T=nodes=S+1;
    f(i,1,n)ad(S,i,1,0);
    f(i,1,m)ad(i+n,T,1,0);
    ll M=d;f(i,1,M){
        ll u=d,v=d;
        ad(u,v+n,1,i);
    }dinic();
    f(i,2,cnt)if(e[i].w==1){
        ll u=e[i].u,v=e[i].v;
        // if(u==S||u==T||v==S||v==T)continue;
        E[u].pb(v);
    }f(i,1,nodes)if(!dfn[i])dfs(i);
    ll res=0;
    f(i,2,cnt)if(e[i].w==1&&(i%2==0)){
        ll u=e[i].u,v=e[i].v;
        if(u==S||u==T||v==S||v==T)continue;
        // cout<<u<<" "<<v<<endl;
        if(bel[u]!=bel[v])is[e[i].id]=1,res++;
    }cout<<res<<endl;
    f(i,1,M)if(is[i])cout<<i<<" ";
	return 0;
}
```

---

## 作者：Stairs_upon_temple (赞：4)

### 闲话

基于本题没有题解，那我来水一发网络流，先声明一下，本篇题解可能有部分口胡现象（本人太菜不会证明，但结论是对的，感性理解一下）。


## 正文

本题的结果不能直接用网络流跑出来（至少我不能）。网络流的题重在建图，但这题不一样，他更多是在考察对残余网络的操作。

首先我们看这个东西和二分图匹配有点像所以先把图拆点然后画出来，如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/634slhnz.png)

显然这个图的最大流（最大匹配）是 $3$ ，即最多能选出三对组队的人，而选用后会对最大流造成影响的边是 $(2,4)$ $(3,4)$ $(3,5)$。因为选了这几条边后会直接或间接占用其他的流量通道，所以在这个图中答案显然是上述几条边，但如果我们看下面这个图。
![](https://cdn.luogu.com.cn/upload/image_hosting/chpvr62w.png)

能删去的边就不是那三条了，而只有 $(3,4)$ $(3,5)$ ，两条，相比之下 $(2,4)$ 这条边就不会造成影响了，因为 $1$ 点可以通过选择 $2$ 点原来必须经过的点，即可以走 $(1,5)$ 这条边。

然后我们发现可以将所有的便分为三种：

1. 必行边：要保证最大流不变的情况下必须流过的边。
2. 可行边：要保证最大流不变情况下有选择余地的边，即要在若干条边中选择一条边作为要流过的边。
3. 不行边：要保证最大流不变情况下不能有流量流过的边。

那么可以发现，在第一个图中，$(1,4)$ $(2,5)$ $(3,6)$ ,都是必行边，而其他三条都为不行边，而第二个图中，只有 $(3,6)$ 是必行边，而 $(1,4)$ $(2,4)$ $(1,5)$ $(2,5)$ ,都是可行边。

对于任意一条用于匹配的边，经过观察可以发现（下文的强连通分量指在残余网络中求得的结果，即求强连通分量的算法在运行时只能跑有流量的边）：
1. 若该边流量为一，且该边的两个点不位于一个强连通分量，该边为必行边。
2. 若该边的两点位于同一强连通分量中，且该强连通分量中存在一条从左点指向右点的边，即该强连通分量中有已经匹配成功的点，该边为可行边。
3. 若该边流量为零且两点并不位于同一强连通分量，该边为不行边。

接下来讲一下为什么可行边的定义如上，先看图。
![](https://cdn.luogu.com.cn/upload/image_hosting/mev7mlqw.png)

首先图中四个点位于一个强连通分量（网络流要求双向建边），我们由强连通分量的定义，这四个点最后会位于一个可以互相到达的环中，而因为这个性质，在这个环中，最大流相当于选择若干条边刚好将整个环的点覆盖，是可以自由选择的。

可行边理解了，必行边和不行边的定义应该也明白了。

那整道题的思路也清晰了，在原二分图中跑最大流，然后在有流量的边上跑强连通分量，最后判定不行边。


```cpp
/*
g++ -o2 P10940.cpp -o c -std=c++14
.\c

*/

#include<cstring>
#include<cstdio>

using namespace std;
const int N=2e4+100;
const int M=4e5+100;
const int inf=0x3f3f3f3f;

char *p1,*p2;
char buf[100];

// #define nc() getchar()
#define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++)

inline void read(int &x){
    x=0;
    char ch=nc();
    while(ch<48 || ch>57){
        ch=nc();
    }
    while(ch>=48 && ch<=57){
        x=(x<<3)+(x<<1)+ch-48;
        ch=nc();
    }
    return ;
}

int tot;
int head[N];
struct edge{
    // int x;
    int y;
    int f;
    int next;
}e[M];

int dep[N];
int gap[N];
int cur[N];

int last;
int dfn[N];
int low[N];

int cidx;
int col[N];

int nl,nr;
int n,m;
int s,t;

int bri_sta;
int top;
int pri[N];

int q[M];
int stk[M];
int _top;

inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
inline int ops(int x){return x^1;}

void init(){
    tot=0;
    memset(head,-1,sizeof(head));
    s=0;
    t=nl+nr+1;
    return ;
}

inline void add(int x,int y,int f){
    e[tot].y=y;
    e[tot].f=f;
    e[tot].next=head[x];
    head[x]=tot++;
    return ;
}

inline void make(int x,int y,int f){
    add(x,y,f);
    add(y,x,0);
    return ;
}

void debug(){
    for(int i=0;i<tot;i+=2){
        int x=e[ops(i)].y;
        int y=e[i].y;
        int f=e[i].f;
        printf("%d %d %d \n",x,y,f);
    }
    return ;
}

void bfs(int start,int to){
    memset(dep,-1,sizeof(dep));
    int hh=0;
    int tt=1;
    q[hh]=to;
    dep[to]=0;
    gap[0]=1;
    while(hh!=tt){
        int x=q[hh++];
        if(hh==M)hh=0;
        for(int i=head[x];~i;i=e[i].next){
            int y=e[i].y;
            if(dep[y]!=-1)continue;
            dep[y]=dep[x]+1;
            gap[dep[y]]++;
            q[tt++]=y;
            if(tt==M)tt=0;
        }
    }
    return ;
}

int find(int x,int to,int lim){
    if(x==to)return lim;
    int flow=0;
    for(int i=cur[x];~i;i=e[i].next){
        int y=e[i].y;
        int f=e[i].f;
        cur[x]=i;
        if(!f)continue;
        if(dep[y]+1==dep[x]){
            int t=find(y,to,min(f,lim-flow));
            if(t>0){
                e[i].f-=t;
                e[ops(i)].f+=t;
                flow+=t;
            }
            if(flow==lim)return flow;
        }
    }
    gap[dep[x]]--;
    if(!gap[dep[x]])dep[s]=n+1;
    dep[x]++;
    gap[dep[x]]++;
    return flow;
}

int ISAP(int start,int to){
    int flow=0;
    bfs(start,to);
    while(dep[start]<=n+1){
        memcpy(cur,head,sizeof(head));
        // for(int i=1;i<=n+1000;i++)cur[i]=head[i];
        flow+=find(start,to,inf);
    }
    return flow;
}

void tarjan(int x){
    last++;
    dfn[x]=last;
    low[x]=last;
    stk[++_top]=x;
    for(int i=head[x];~i;i=e[i].next){
        if(!e[i].f)continue;
        int y=e[i].y;
        if(!dfn[y]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(!col[y])low[x]=min(low[x],dfn[y]);
    }
    if(dfn[x]==low[x]){
        cidx++;
        while(_top){
            int t=stk[_top--];
            col[t]=cidx;
            if(t==x)break;
        }
    }
    return ;
}

int main(){
    read(nl);
    read(nr);
    read(m);
    n=nl+nr+2;
    init();
    for(int i=1;i<=nl;i++)make(s,i,1);
    for(int i=1;i<=nr;i++)make(i+nl,t,1);
    bri_sta=tot;
    for(int i=1;i<=m;i++){
        int x,y;
        read(x);
        read(y);
        y+=nl;
        make(x,y,1);
    }
    // debug();
    // printf("%d\n",ISAP(s,t));
    int ans=ISAP(s,t);
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
    for(int i=bri_sta;i<tot;i+=2){
        int x=e[ops(i)].y;
        int y=e[i].y;
        int f=e[i].f;
        if(f && col[x]!=col[y]){
            pri[++top]=(i-bri_sta)/2+1;
        }
    }
    printf("%d\n",top);
    for(int i=1;i<=top;i++){
        printf("%d ",pri[i]);
    }
    putchar('\n');
    return 0;
}
```

---

## 作者：syLph (赞：1)

Lyd 蓝书上的题。

本题要求二分图最大匹配的不可行边。

等价于求跑完最大流后，残量网络中两个端点不在同一个强连通分量中的点对。因为如果形成强连通分量成环，那么连接两个端点的边可以任取，不是不可行边。

实现即可。

Code:

```python
#include<bits/stdc++.h>
using namespace std;;
const int maxn = 400010;
const int maxm = 20010;
const int inf = 0x3f3f3f3f;
int nxt[maxn],head[maxm],ver[maxn],tot = 1;
int edg[maxn],now[maxm],d[maxm],n,m,s,t,id[maxn];
int low[maxn],dfn[maxn],ins[maxn],stk[maxn],c[maxn];
int num,cnt,top,tt;
inline int read(){
	int x = 0,f = 1; char c = getchar();
	while('0' > c || c > '9') c = getchar();
	while('0' <= c && c <= '9') x = x * 10 + c - '0',c = getchar();
	return x * f;
}
void add(int x,int y,int z,int d){
	ver[++tot] = y,edg[tot] = z,id[tot] = d,nxt[tot] = head[x],head[x] = tot;
	ver[++tot] = x,edg[tot] = 0,id[tot] = d,nxt[tot] = head[y],head[y] = tot;
}
bool bfs(){
	memset(d,0,sizeof d); memcpy(now,head,sizeof head);
	queue<int> q; q.push(s); d[s] = 1;
	while(!q.empty()){
		int x = q.front(); q.pop();
		for(int i = head[x] ; i ; i =nxt[i]){
			int y = ver[i];
			if(edg[i] && !d[y]){
				d[y] = d[x] + 1;
				if(y == t) return 1;
				q.push(y);
			}
		}
	} return 0;
}
int dinic(int x,int flow){
	if(x == t) return flow;
	int rest = flow,k,i;
	for(i = now[x] ; i && rest ; i = nxt[i]){
		int y = ver[i];
		if(edg[i] && d[y] == d[x] + 1){
			k = dinic(y,min(edg[i],rest));
			if(!k) d[y] = 0;
			edg[i] -= k,edg[i ^ 1] += k,rest -= k;
		}
	} return flow - rest;
}
int Dinic(){
	int x,y = 0;
	while(bfs()) while(x = dinic(s,inf)) y += x;
	return y;
}
void tarjan(int x){
	dfn[x] = low[x] = ++num;
	stk[++top] = x,ins[x] = 1;
	for(int i = head[x] ; i ; i = nxt[i]){
		int y = ver[i],z = edg[i];
		if(!z) continue;
		if(!dfn[y]) tarjan(y),low[x] = min(low[x],low[y]);
		else if(ins[y]) low[x] = min(low[x],dfn[y]);
	}
	if(dfn[x] == low[x]){
		cnt += 1; int y;
		do{y = stk[top--],c[y] = cnt,ins[y] = 0;} 
		while(x != y);
	}
}
int main(){
	//freopen("a.txt","r",stdin);
	cin >> n >> m >> tt;
	for(int i = 1 ; i <= tt ; i ++){
		int u = read(),v = read() + n;
		add(u,v,1,i);
	}
	s = 0,t = n + m + 1;
	for(int i = 1 ; i <= n ; i ++) add(s,i,1,inf);
	for(int i = 1 ; i <= m ; i ++) add(i + n,t,1,inf);
	
	int f = Dinic(); vector<int> ans;
	for(int i = 1 ; i <= n + m ; i ++) if(!dfn[i]) tarjan(i);
	for(int x = 1 ; x <= n ; x ++){
		for(int i = head[x] ; i ; i = nxt[i]){
			int y = ver[i];
			if(c[x] != c[y] && edg[i] && x != s && x != t && y != s && y != t){
				ans.push_back(id[i]);
			}
		}
	}
	printf("%d\n",(int)ans.size());
	sort(ans.begin(),ans.end());
	for(int i = 0 ; i < ans.size() ; i ++) printf("%d ",ans[i]);
	return 0;
}
```

---

## 作者：andy88888 (赞：1)

# 本题所需知识点
### 强联通分量
### 网络最大流
### 二分图的定义及匹配
### 二分图最大匹配及二分图匹配的必须边和可行边
### 完备匹配
#
# 题意简化
求二分图最大匹配的不可匹配边。
拓展：二分图的最大不可匹配边是对于任意一个匹配都没有的边。
#
# 题目求解
蓝书上讲得很清楚，就是属于同一个强连通分量，并且他在残量网络上不能没有边
一个二分图的最大匹配不是唯一的，若所有的最大匹配都含有的边，我们称其为必须边，对于任意一个最大匹配的边，我们称其为可行边。
最后我们一定要知道这条边再残量网络中属于不同的强联通分量即可
这里主要讲的是存储方法，一般来讲网络流是用链式前向星来写，但本人不是链式前向星党，所以我的代码是用动态数组写的。
具体就不展示了。
关于这题动态数组的做法基本没有对的做法，这里只提供一个修改做法，那就是二分。
但这这道题还能用歪式前向星。请见代码。
歪式前向星其实是链式前向星的变种，它就是用动态数组代替下一个和头指针。具体实现起来要比链式前向星慢一点，但实现较为简单。简单的把这条边加进去即可。
#
# 代码
## 歪式前向星
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,e;
vector<int>a[20005];
int tot=1;
int to[400005],id[400005];
void add(int u,int v,int w){
    tot++;
    a[u].push_back(tot);
    to[tot]=v;
    id[tot]=w;
    tot++;
    a[v].push_back(tot);
    to[tot]=u;
    id[tot]=0;
}
int d[20005];
int now[20005];
bool bfs(){
    memset(d,0,sizeof(d));
    queue<int>q;
    q.push(0);
    d[0]=1; 
    now[0]=0;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=0;i<a[u].size();i++){
            int v=a[u][i];
            if(id[v]==0) continue;
            if(d[to[v]]) continue;
            d[to[v]]=d[u]+1;
            now[to[v]]=0;
            q.push(to[v]);
            if(to[v]==n+m+1) return 1;
        }
    }
    return 0;
}
int dfs(int u,int flow){
    if(u==n+m+1) return flow;
    int rest=flow;
    for(int i=now[u];i<a[u].size()&&rest;i++){
        now[u]=i;
        int v=a[u][i];
        if(id[v]==0) continue;
        if(d[to[v]]!=d[u]+1) continue;
        int k=dfs(to[v],min(rest,id[v]));
        if(k==0) d[to[v]]=0;
        id[v]-=k;
        id[v^1]+=k;
        rest-=k;
    }
    return flow-rest;
}
int dfn[20005],low[20005],times=0;
stack<int>st;
bool h[20005];
int belong[20005],cnt;
void tarjan(int u){
    dfn[u]=low[u]=++times;
    st.push(u);
    h[u]=1;
    for(int i=0;i<a[u].size();i++){
        int v=a[u][i];
        if(id[v]==0) continue;
        v=to[v];
        if(dfn[v]==0){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }else if(h[v]) low[u]=min(low[u],dfn[v]); 
    }
    if(dfn[u]==low[u]){
        cnt++;
        while(st.top()!=u){
            h[st.top()]=0;
            belong[st.top()]=cnt;
            st.pop();
        }
        h[st.top()]=0;
        belong[st.top()]=cnt;
        st.pop();
    }
}
struct node{
    int u,v,e;
}ac[400005];
main(){
    cin>>n>>m>>e;
    for(int i=1;i<=n;i++) add(0,i,1);
    for(int i=1;i<=m;i++) add(i+n,n+m+1,1);
    for(int i=1;i<=e;i++){
        int u,v;
        cin>>u>>v;
        add(u,v+n,1);
       ac[i]={u,v,tot-1};
    }
    while(bfs()){
        while(dfs(0,LLONG_MAX));
    }
    for(int i=0;i<=n+m+1;i++){
        if(!dfn[i]) tarjan(i);
    }
    vector<int>ans;
    for(int i=1;i<=e;i++){
        int u=ac[i].u,v=ac[i].v,e=ac[i].e;
        if(id[e]&&belong[u]!=belong[v+n]) ans.push_back(i);
    }
    cout<<ans.size()<<endl;
    for(int i=0;i<ans.size();i++) cout<<ans[i]<<" ";
    cout<<"\n"<<endl;
    return 0;
}
``````
#
# 收尾与后期
这是蒟蒻的第二篇题解，蒟蒻也只是个三年级的小学生，请审核员大人手下留情，后续会持续更新。

---

## 作者：EternalHeart1314 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10940)

# Problem

给定一个二分图，对于每条边，求所有必不可行边。$n,m\le10^4$。

# Solution

在最大流的残量网络上跑 Tarjan，在同一个 SCC 里的边一定构成一些环，流可以在环上流动，则这些边在流动后可以选或不选，是可行边，连接不同 SCC 的匹配边是必须边，即必须选，非匹配边是必不可行边，即必须不选。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 4e5 + 7, INF = 1e9;
int n, m, k, tot, cnt = 1, nxt[N], hd[N], to[N], wt[N], d[N], nw[N], dfn[N], low[N], scc[N];
vector<int> e[N], v;
stack<int> s;

inline void add(int u, int v) {
    nxt[tot] = hd[u], to[hd[u] = tot] = v, wt[tot++] = 1;
    nxt[tot] = hd[v], to[hd[v] = tot++] = u;
}
inline bool bfs() {
    for (int i = 0; i <= n + 1; ++i) d[i] = INF, nw[i] = hd[i];
    queue<int> q; q.push(0), d[0] = 0;
    while (q.size()) {
        int u = q.front(); q.pop();
        for (int i = nw[u]; ~i; i = nxt[i])
            if (d[to[i]] == INF && wt[i]) {
                q.push(to[i]);
                d[to[i]] = d[u] + 1;
            }
    }
    return d[n + 1] < INF;
}
inline int Dinic(int u, int florr) {
    if (u > n) return florr; // 玩 florr 玩的，虽然早已退游
    int cur = florr, k;
    for (int i = nw[u], v; ~i && cur; i = nxt[i]) {
        nw[u] = i, v = to[i];
        if (d[v] == d[u] + 1 && wt[i]) {
            k = Dinic(v, min(cur, wt[i]));
            cur -= k, wt[i] -= k, wt[i ^ 1] += k;
        }
    }
    return florr - cur;
}
inline void tarjan(int u) {
    dfn[u] = low[u] = ++tot, s.push(u);
    for (auto v : e[u])
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (!scc[v]) low[u] = min(low[u], dfn[v]);
    if (dfn[u] == low[u]) {
        while (s.top() ^ u) scc[s.top()] = cnt, s.pop();
        s.pop(), scc[u] = cnt++;
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> k >> n >> m, n += k;
    memset(hd, -1, sizeof hd);
    for (int i = 1, u, v, w; i <= m; ++i)
        cin >> u >> v, add(u, v + k);
    for (int i = 1; i <= k; ++i) add(0, i);
    for (int i = k + 1; i <= n; ++i) add(i, n + 1);
    while (bfs()) Dinic(0, INF);
    for (int i = 0; i <= n + 1; ++i) for (int j = hd[i]; ~j; j = nxt[j])
        if (wt[j]) e[i].emplace_back(to[j]);
    for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i);
    for (int i = 0; to[i ^ 1]; i += 2) {
        if (wt[i] && scc[to[i]] ^ scc[to[i ^ 1]])
            v.emplace_back(i / 2 + 1);
    }
    cout << v.size() << '\n';
    for (auto i : v) cout << i << ' ';
    return 0;
}
```

---


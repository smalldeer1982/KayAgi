# 任务安排 2

## 题目背景

本题是 P2365 强化版，是 P5785 弱化版，用于让学生循序渐进地了解斜率优化 DP。

## 题目描述

机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。

**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。

请确定一个分组方案，使得总费用最小。

## 说明/提示

对于 $100\%$ 数据，$1 \le n \le 3 \times 10^5$，$1 \le s \le 2^8$，$1\le T_i \le 2^8$，$0 \le C_i \le 2^8$。

## 样例 #1

### 输入

```
5
1
1 3
3 2
4 3
2 3
1 4```

### 输出

```
153```

# 题解

## 作者：Inv_day_in_R (赞：27)

本题是 [P2365](https://www.luogu.com.cn/problem/P2365) 的强化版，先思考 P2365 怎么做。

我们用 $dp_i$ 来表示 $i+1$ 重新启动机器，区间 $1$ 到 $i$ 之间费用的最小值。不难想到每次机器启动都会给之后的所有机器都带来 $s$ 的时间，则启动代价为 $s\sum\limits_{k=i+1}^{n}C_k$，设上一次由 $dp_j$ 转移来，$j+1$ 到 $i$ 之间运行代价为 $\sum\limits_{k=j+1}^iC_k\sum\limits_{k=1}^iT_k$。

这里使用前缀和优化，最终，得到如下的转移方程：

$$
dp_i=\min\limits_{0<j<i}(dp_j+(C_i-C_j)T_i+(C_n-C_j)s)
$$

时间复杂度 $O(n^2)$，可以通过 P2365。

接下来考虑本题的斜率优化。斜率优化需要对原方程进行变形，先省略 $\min$，相当于求 $dp_i=dp_j+(C_i-C_j)T_i+(C_n-C_j)s$ 的最小值。
接下来如下进行变形：

$$
dp_i=dp_j+C_iT_i-C_jT_i+C_ns-C_js\\
dp_j=dp_i-C_iT_i+C_jT_i-C_ns+C_js\\
dp_j=(T_i+s)C_j+(dp_i-C_iT_i-C_ns)
$$

化成这个形式之后，发现像一个一次函数，于是以 $C_j$ 为 $x$ 轴，$dp_j$ 为 $y$ 轴建立平面直角坐标系，平面上第 $j$ 个点为 $(C_j,dp_j)$，而每次转移时的 $T_i+s$ 与 $-C_iT_i-C_ns$ 都是一个常量，要使 $dp_i$ 最小也就是在前 $i-1$ 个点中选出过这个点，斜率为定值的直线中截距最小的那个。

不难发现，答案必然在原点集的一个右下凸包上：

![](https://cdn.luogu.com.cn/upload/image_hosting/ev4ngffs.png)

考虑如何动态维护凸包。$C_i$ 单调递增，所以新加入的点必然在右边。

![](https://cdn.luogu.com.cn/upload/image_hosting/sw2oc6gw.png)

如上图，CD 斜率大于 DE 斜率，所以 D 被删除，然后再看 BC 与 CE。

查询时二分即可。
代码如下：

```cpp
#include<iostream>
#define int long long 
using namespace std;
int n,s,t[300010],c[300010],f[300010];
int q[300010];
main(){
    cin>>n>>s;
    for(int i=1;i<=n;i++){
        cin>>t[i]>>c[i];
        t[i]+=t[i-1];
        c[i]+=c[i-1];
    }
    int hh=0,tt=0;
    q[0]=0;
    for(int i=1;i<=n;i++){
        int l=hh,r=tt;
        while(l<r){
            int mid=l+r>>1;
            if((__int128)(t[i]+s)*(c[q[mid+1]]-c[q[mid]])<(__int128)(f[q[mid+1]]-f[q[mid]]))r=mid;
            else l=mid+1;
        }
        int j=q[r];
        f[i]=f[j]+c[i]*t[i]-c[j]*t[i]+c[n]*s-c[j]*s;
        while(hh<tt&&(__int128)(f[i]-f[q[tt]])*(c[q[tt]]-c[q[tt-1]])<=(__int128)(f[q[tt]]-f[q[tt-1]])*(c[i]-c[q[tt]]))tt--;
        q[++tt]=i;
    }
    cout<<f[n];
}
```
这个代码还能过 P5785。

---

## 作者：封禁用户 (赞：15)

这或许是这几天的济南云斗集训之旅最大的收获吧，若是最后一天的模拟赛文件不会交错也许结局会更好，但在这残酷的现实中却从不会有“如果”一词，母亲以不想让我学了，或许考完今年的 CSP 就可能不学了吧。

本文将效仿《李煜东算法进阶指南》的思路，按照例题层层深入。

### P2365 任务安排

[题目链接](https://www.luogu.com.cn/problem/P2365)

凡是先考虑朴素算法，这是一个好习惯。

#### 朴素的解法

求出 $T,C$ 的前缀 $t,c$，设 $f_{i,j}$ 为把前 $i$ 个任务分为 $j$ 批的最小费用，明显的是第 $j$ 批任务完成的时间为第 $j\times S+t_i$ 时刻。

$$f_{i,j}=\min_{0\le k<i} \left \{ f_{k,j-1}+(S\times j+t_i)\times(c_i-c_k)\right \}$$

朴素的解法复杂度 $O(n^3)$。

#### 本题正解

思考为什么要 $j$ 这一维，发现 $j$ 这一维完全是为了求当前这一批完成的时刻。

思考该如何优化，感觉不容易直接求之前此机器启动过几次，但机器每次启动所耗费的时间 $S$ 最终会累积到之后所有任务完成时间上。所以我们可以将其累加到费用当中。

设 $f_i$ 表示把前 $i$ 个任务分成若干批执行的最小费用，状态转移方程为：

$$f_i=\min_{0\le j<i}\left\{f_j+t_i\times (c_i-c_j)+S\times(c_n-c_j)\right\}$$

下文摘自《李煜东算法进阶指南》：

也就是说我们没有直接求出每批的完成时刻，而是在一批任务“开始”对后续任务产生影响时，就先把费用累加到答案中。这是一种名为“**费用前提计算**”的经典思想。

很明显这段话可谓相当的晦涩。

该复杂度 $O(N^2)$。

咦，好尴尬，我似乎没有写过关于此解的的代码。

### P10979 任务安排 2

[题目链接](https://www.luogu.com.cn/problem/P10979)

与上一题的题意一模一样，但数据加强了。

将上一题的转化方程拆一下，得：

$$f_i=\min_{0\le j<i}\left\{f_j+t_i\times c_i-t_i\times c_j+S\times c_n-S\times c_j\right\}$$

由于 $f_i$ 的大小只与跟 $j$ 有关的项有关，其他项都是固定的，可以当作常数，然后再合并同类项，于是得：

$$f_i=\min_{0\le j<i} \left\{f_j-c_j\times (S+t_i)\right\}+t_i\times c_i+S\times c_n$$

让我们把 $\min$ 函数去掉，然后将全部不与 $j$ 有关的项作为常数项（包括 $f_i$），将与 $j$ 有关的项当作变量，组成一个函数式：

$$f_j=(S+t_i)\times c_j+f_i-c_i\times t_i-S\times c_n$$

在一个以 $c_j$ 为横坐标（$x$），$f_j$ 为纵坐标（$y$）的平面直角坐标系当中，这是一条以 $S+t_i$ 为斜率（$k$），以 $f_i-c_i\times t_i-S\times c_n$ 为截距（$b$）的直线（$y=kx+b$）。因此每一个候选的决策都是一个坐标系中的点，即每一个 $j$ 都对应着一个点 $(c_j,f_j)$，而我们要求的 $f_i$ 对应每一个点对应直线的截距，每个直线的斜率是固定的，而截距是未知的。综上所述，当截距最小时，$f_i$ 也最小。

![](https://img2024.cnblogs.com/blog/3422024/202502/3422024-20250211155112993-1151997381.png)

对于三个决策点 $(c_{j_1},f_{j_1})$，$(c_{j_2},f_{j_2})$，$(c_{j_3},f_{j_3})$，设 $j_1<j_2<j_3$，因为 $T,C$ 都是正整数所以 $t$ 和 $c$ 都有单调性。

探究什么情况时，$j_2$ 有可能是最优决策：

![](https://img2024.cnblogs.com/blog/3422024/202502/3422024-20250211162059105-277403086.png)

如上图所示，$j_2$ 有可能是最优决策，当且仅当：

$$\frac{f_{j_2}-f_{j_1}}{c_{j_2}-c_{j_1}}<\frac{f_{j_3}-f_{j_2}}{c_{j_3}-c_{j_2}}$$

上示的不等式实际上是连接两个决策点连线的斜率，通俗的讲，我们应该维护“链接相邻两点的线段斜率” 单调递增的一个“**下凸壳**”

有这个下凸壳的顶点才有可能成为最优决策。实际上，对于一条斜率为 $k$ 的直线，若某个点的左侧线段比 $k$ 小、右侧线段的斜率比 $k$ 大，则该顶点就是最优决策。换言之，如果把这条直线和所有线段组成一个排列组成一个序列，那么令结局最小化的定点就出现在按照斜率大小排序时，直线应该排在的位置上。

在本题中，$j$ 的范围是 $0\le j<i$，随着 $i$ 的增大，都会有一个新决策出现。因为 $c$ 的单调性，新决策的单调性一定会大于之前所有决策点的单调性。由于 $t$ 的单调性，每次的斜率 $S+t_i$ 也单调递增，如果每次只保留“相邻两点的线段斜率” 大于 $S+t_i$ 的部分，那凸壳的最左端点就一定是最优决策。

综上，对于代码操作，我们建立一个单调队列 $q$，维护这个下凸壳。

对于每个决策 $i$：

1. 检查队头决策 $q_l$ 和 $q_{l+1}$，若斜率 $(f_{q_{l+1}}-f_{q_l})/(c_{q_{l+1}}-c_{q_l})\le S+t_i$，则 $q_l$ 出队，检查新对头。

2. 取队头 $q_l$ 为最优决策，计算 $f_i$。

3. 将新决策 $i$ 队尾插入，插入前，若 $q_r$ 不满足下凸性，即 $q_r$ 是无用决策，就将 $q_r$ 出队，检查新队尾。

时间复杂度 $O(n)$。

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,s,c[N],t[N],f[N],q[N];
int main(){
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>c[i];
		t[i]+=t[i-1],c[i]+=c[i-1]; 
	}
	int l=1,r=1;
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	q[1]=0;
	for(int i=1;i<=n;i++){
		int k = s+t[i] ;
		while( l<r && f[q[l+1]]-f[q[l]] <= k * (c[q[l+1]]-c[q[l]]) ) ++l;
		f[i]= f[q[l]] - k*c[q[l]] + t[i]*c[i] + s*c[n];
		while( l<r && (f[q[r]]-f[q[r-1]]) * (c[i]-c[q[r]])>=(c[q[r]]-c[q[r-1]])*(f[i]-f[q[r]]))--r;
		q[++r]=i;
	}
	cout<<f[n];
	return 0;
}
```

以下摘自《李煜东算法进阶指南》：

与一般的单调队列优化 DP 的模型相比，本题维护的“单调性”依赖于队列中相邻的两个元素之间的某种“比值”。因为这个值对应线性规划的坐标系的斜率，所以我们把本题中使用的优化方法称为“**斜率优化**”，英文称为 convex hull trikk（直译为凸包优化策略）。

### P5785 [SDOI2012] 任务安排

[题目链接](https://www.luogu.com.cn/problem/P5785)

与上一题不同的是这一题的 $T$ 可能是负数，即 $t$ 不具有单调性，所以本题的斜率 $S+t_i$ 并不具有单调性，所以上文的操作 1 无法进行，所以我们需要维护整个凸壳。

于是我们需要在单调队列中寻找一个点 $p$，$p$ 的左侧线段的斜率小于 $S+t_i$，右侧线段的斜率大于 $S+t_i$。

对于这个搜索，我们可以二分搜索。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+5;
int n,s,c[N],t[N],f[N],q[N],l,r,k;
int binary_search(int i){
	if(l==r)return q[l];
	int L=l,R=r;
	while(L<R){
		int mid=(L+R)>>1;
		if(f[q[mid+1]]-f[q[mid]]<=k*(c[q[mid+1]]-c[q[mid]]))L=mid+1;
		else R=mid;
	}
	return q[L];
} 
signed main(){
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>c[i];
		t[i]+=t[i-1],c[i]+=c[i-1]; 
	}
	l=r=1,q[1]=0;
	for(int i=1;i<=n;i++){
		k=s+t[i];
		int p=binary_search(i);
		f[i]=f[p]-k*c[p] + t[i]*c[i] + s*c[n];
		while( l<r && (f[q[r]]-f[q[r-1]]) * (c[i]-c[q[r]])>=(c[q[r]]-c[q[r-1]])*(f[i]-f[q[r]]))r--;
		q[++r]=i;
	}
	cout<<f[n];
	return 0;
}
```

### P10980 任务安排 4.1【暂无数据】

[题目链接](https://www.luogu.com.cn/problem/P10980)

若 $C$ 是负数，则 $c$ 不具有单调性，可以倒序 DP，设计一个状态转移，让 $t$ 为横坐标，$c$ 是斜率中的一项。仍然可以单调队列维护凸壳，用二分法求出最佳解法。

### P10981 任务安排 4.2【暂无数据】

$T,C$ 都有可能是负数，二者都不具有单调性，意味着需要动态开点、动态查询。

需要平衡树维护。

### CF311B Cats Transport

呵呵，任务安排系列就此完成了。

[题目链接](https://www.luogu.com.cn/problem/CF311B)

呃呃额，感觉前面写的够多了，这道题只要知道他跟任务安排 2 是类似的即可。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
int n,p,d[N],t[N],h[N],m,a[N],s[N],f[105][N],q[N];
int qy(int i,int L){
    return f[i-1][q[L]]+s[q[L]];
}
signed main(){
    cin>>n>>m>>p;
    for(int i=2;i<=n;i++){cin>>d[i];d[i]+=d[i-1];}
    for(int i=1;i<=m;i++){
        cin>>h[i]>>t[i];
        a[i]=t[i]-d[h[i]];
    }
    sort(a+1,a+1+m);
    for(int i=1;i<=m;i++)s[i]=s[i-1]+a[i];
    memset(f,0x3f,sizeof(f));
    for(int i=0;i<p;++i)f[i][0]=0;
    for(int i=1;i<=p;i++){
        int l=1,r=1;
        for(int j=1;j<=m;j++){
            int k=a[j];
            while(l<r&&qy(i,l+1)-qy(i,l)<=k*(q[l+1]-q[l]))++l;
            f[i][j]=qy(i,l)-a[j]*q[l]+a[j]*j-s[j];
            while(l<r&&(qy(i,r)-qy(i,r-1))*(j-q[r])>=(q[r]-q[r-1])*(f[i-1][j]+s[j]-qy(i,r)))--r;
            q[++r]=j;
        }
}
    cout<<f[p][m];
    return 0;
}
```

---

## 作者：liruixiong0101 (赞：15)

斜率优化模板题，有三倍经验，难度逐渐递增，建议从前做到后。

[P2365 任务安排](https://www.luogu.com.cn/problem/P2365)，[P10979 任务安排 2](https://www.luogu.com.cn/problem/P10979)，[P5785 [SDOI2012] 任务安排](https://www.luogu.com.cn/problem/P5785)。

下面的做法可以通过这三题。

## 思路：
设 $f_i$ 表示第 $i$ 个任务加工后所需的最小总费用，那么就有转移式。
$$
f_i=\displaystyle\min_{j=0}^{i-1}\{f_j+\sum_{k=j+1}^i{((\sum_{l=1}^i T_l+num\times s)\times C_k)}\}=\min_{j=0}^{i-1}\{f_j+(\sum_{k=1}^i T_k+num\times s)\times\sum_{k=j+1}^i C_k\}
$$

$num$ 表示在这批任务完成之前分了多少批任务。

但是 $num$ 的值关乎到前面转移的值，要再开一维吗？不需要，这里采用**费用前置**的思想。由于每分一组，$num$ 就会多一，根据 $\sum_{k=1}^i T_k+num\times s$，后面的每个任务 $k$ 就会多贡献 $s\times C_k$，那么转移式就变成了：
$$
f_i=\displaystyle\min_{j=0}^{i-1}\{f_j+\sum_{k=1}^i T_k\times\sum_{k=j+1}^i C_k+\sum_{k=j+1}^n C_k\times s\}
$$

观察到转移式的 $\sum$ 都是可以用前缀和维护的，对 $T,C$ 数组进行前缀和（为了方便书写，不加说明的 $T,C$ 数组表示已经前缀和完了的数组），那么转移式为：

$$
f_i=\displaystyle\min_{j=0}^{i-1}\{f_j+T_i\times(C_i-C_j)+(C_n-C_j)\times s\}
$$

动态规划的转移参照 [P2365 任务安排](https://www.luogu.com.cn/problem/P2365)的[这篇题解](https://www.luogu.com.cn/article/wsg1bbpg)。

---

下面讲一个没有利用决策单调性的斜率优化方法。

我们先把转移式做一些变化：

$$
f_i=\displaystyle\min_{j=1}^{i-1}\{f_j-C_j\times(T_i+s)\}+T_i\times C_i+C_n\times s
$$

即把常数项提到 $\min$ 外，再合并同类项。

上述转移式，时间复杂度瓶颈是找到最优决策点，所以我们考虑两个决策点 $j_1,j_2$，若决策点 $j_1$ 优于决策点 $j_2$，那么：

$$
f_{j_1}-C_{j_1}\times(T_i+s)<f_{j_2}-C_{j_2}\times(T_i+s)
$$

$$
(C_{j_2}-C_{j_1})\cdot(T_i+s)<f_{j_2}-f_{j_1}
$$

现在我们钦定 $C_{j_2}>C_{j_1}$（**注意**不是 $j_2>j_1$，后面再说为什么），那么我们可以把 $(C_{j_2}-C_{j_1})$ 除到不等式的右边，即：

$$
\frac{f_{j_2}-f_{j_1}}{C_{j_2}-C_{j_1}}>T_i+s
$$

不等式的左边是不是很像斜率式？我们令 $P_{i}$ 为二维平面直角坐标系的点 $(C_i,f_i)$，那么不等式的左边可以表示为 $k_{P_{j_1},P_{j_2}}$ 即点 $P_{j_1}$ 和点 $P_{j_2}$ 之间的斜率。

该不等式可以用文字描述为：若两点之间的斜率大于 $T_i+s$，那么左边的点更优，否则右边的点更优。（等号取到的情况即为两个点一样优秀，选哪个无所谓，不做细分）

我们现在考虑三个点的情况，若这三个点 $A,B,C$ 围成一个上凸壳（假设左右顺序为 $A,B,C$），那么直线 $AB$，直线 $BC$ 和斜率为 $T_i+s$ 的直线有下面三种关系：

- 直线 $AB$ 和直线 $BC$ 的斜率都大于 $T_i+s$，此时 $A$ 点优于 $B$ 点，$B$ 点优于 $C$ 点，$B$ 点不是最优的，如图：![](https://s21.ax1x.com/2024/10/04/pA8lCRS.png)
- 直线 $AB$ 的斜率大于 $T_i+s$，直线 $BC$ 的斜率小于 $T_i+s$，此时 $A$ 点优于 $B$ 点，$C$ 点优于 $B$ 点，$B$ 点不是最优的，请读者自行画图。
- 直线 $AB$ 和直线 $BC$ 的斜率都小于 $T_i+s$，此时 $B$ 点优于 $A$ 点，$C$ 点优于 $B$ 点，$B$ 点不是最优的，请读者自行画图。

综上，若三个点围成一个上凸壳，那么中间的那个点一定不是最优的。

现在考虑转移 $i$，根据上面的性质，我们可以将 $i$ 之前的所有点维护一个下凸壳，由于两点之间的斜率大于 $T_i+s$ 则左边的点更优，我们可以找到第一个 $j$，使得 $P_j$ 与 $P_{j+1}$ 的斜率大于 $T_i+s$ 的点，若没有这个点，那么凸壳的最后一个点最优，然后用这个点的来更新 $i$ 的 dp 值，这个点可以通过二分找到。

这个点形象化的来说就是用斜率为 $T_i+s$ 的直线来切这个凸包，切到的点就是最优决策点，如图：

![](https://s21.ax1x.com/2024/10/04/pA8QLKH.md.png)

其中 E 就是最优决策点。

然后考虑如何维护这个下凸壳，这个还是比较容易想到，假设在此之前已经维护好了之前所有点的下凸壳，需要加上该点。由于 $C_i$（不是前缀和数组）是非负的，那么 $C_i$ 是单调的，即点的横坐标是单调的，所以我们可以直接在下凸壳的最后加点。若新加上该点，点集不构成下凸壳，那么将最后一个点去掉反复循环，直到新加上该点可以构成下凸壳，或者下凸壳中没有点了结束。根据这个算法，我们可以用一个单调栈维护下凸壳。

这道题就做完了。

对于这种做法来说，[P10979 任务安排 2](https://www.luogu.com.cn/problem/P10979) 和 [P5785 [SDOI2012] 任务安排](https://www.luogu.com.cn/problem/P5785)没有区别，因为这两道题的 $C_i$ 都是非负整数（不是前缀和数组），这就使每个点的横坐标是单调的，而这个算法没有限制 $T_i$（不是前缀和数组）的正负，即并不需要要求决策单调性。

做完这道题，我们分析一下什么题可以用斜率优化，首先他要求出一段区间的某个函数值的极值，而这个函数值中包含 $i$ 与 $j$ 的交叉项，这样的题目大概率是斜率优化。

---

现在来讲为什么我们是要钦定 $C_{j_2}>C_{j_1}$ 而不是钦定 $j_2>j_1$，有的同学可能会认为钦定 $j_2>j_1$，不就是和钦定 $x_{j_2}>x_{j_1}$（$x_i$ 为点 $i$ 的横坐标）一样的吗？为什么不行。对于比较简单的斜率优化题目来说，这样是可以的包括这道题，但是有一些题目的点的横坐标并不是单调的，就导致每次加点的时候就不能按照编号顺序一个一个加点，而是要按照点的横坐标顺序来加点，否则你的思路会十分混乱。对于这种题目我们可以用 cdq 分治或者用平衡树维护凸壳解决。

## 代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 3e5 + 5;

int n, s, t[kMaxN], c[kMaxN], top, L, R, M;
long long f[kMaxN];

struct P {
  int x;
  long long y;
} stk[kMaxN];

long double slope(P i, P j) { return i.x == j.x ? (i.y > j.y ? -4e18 : 4e18) : (long double)(i.y - j.y) / (i.x - j.x); }

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> s;
  for (int i = 1; i <= n; i++) {
    cin >> t[i] >> c[i], t[i] += t[i - 1], c[i] += c[i - 1];
  }
  for (int i = 1; i <= n; i++) {
    for (; top > 1 && slope(stk[top - 1], stk[top]) > slope(stk[top], {c[i - 1], f[i - 1]}); top--) {
    }
    stk[++top] = {c[i - 1], f[i - 1]}, L = 1, R = top, M = L + R >> 1;  // 加入点，维护凸壳
    for (; L < R; M = L + R >> 1) {
      (M == top ? 4e18 : slope(stk[M], stk[M + 1])) > s + t[i] ? R = M : L = M + 1;
    }  // 二分最优决策点
    f[i] = stk[L].y - 1LL * (s + t[i]) * stk[L].x + 1LL * s * c[n] + 1LL * c[i] * t[i];  // 转移
  }
  cout << f[n];
  return 0;
}
```

作为一篇斜率优化的学习笔记，还是讲一道点的横坐标不单调的例题吧（毕竟这种方法比较常见），例题：[P4655 [CEOI2017] Building Bridges](https://www.luogu.com.cn/problem/P4655)。

## 思路：
设 $f_i$ 为建造了一座桥在 $i$ 点的最小代价，$s_i$ 为 $w_i$ 的前缀和数组，那么 dp 式很显然：
$$
f_i=\min_{j=0}^{i-1}\{f_j+(h_i-h_j)^2+s_{i-1}-s_j\}
$$

同样将式子转化一下：
$$
f_i=\min_{j=0}^{i-1}\{f_j+h_j^2-2h_ih_j-s_j\}+h_i^2+s_{i-1}
$$

若决策点 $j_1$ 优于 $j_2$，那么：
$$
f_{j_1}+h_{j_1}^2-2h_ih_{j_1}-s_{j_1}<f_{j_2}+h_{j_2}^2-2h_ih_{j_2}-s_{j_2}
$$
$$
2h_i(h_{j_2}-h_{j_1})<(f_{j_2}+h_{j_2}^2-s_{j_2})-(f_{j_1}+h_{j_1}^2-s_{j_1})
$$

我们令 $g_i=f_i+h_i^2-s_i$，再钦定 $h_{j_2}>h_{j_1}$（**注意**这里），则不等式化为：
$$
\frac{g_{j_2}-g_{j_1}}{h_{j_2}-h_{j_1}}>2h_i
$$

我们设点 $P_i$ 为 $(h_i,g_i)$，这里的点的横坐标不单调，所以不能像上一题一样更新一次加一个点，这里考虑使用 cdq 分治。

我们先将所有的点按照横坐标排序，然后将所有的点分成两半（设中点为 $mid$），第一半的编号为 $1$ 到 $mid$，第二半的编号为 $mid+1$ 到 $n$，两半中间的点的横坐标是单调的，假设我们已经更新好了第一半的所有点的 dp 值，我们用前面的点构成的凸壳来更新第二半的 dp 值，然后再递归执行第二半即可。

简单讲一下这种做法的正确性，不需要用 cdq 分治的做法其实是用一个凸包来更新 dp 值，而用了 cdq 分治的做法其实是用 $\log n$ 个凸包来更新 当前的 dp 值，将 $1$ 到 $i-1$ 这个区间分成若干个小区间，用这些小区间的点构成的凸包分别更新该点的 dp 值，所以这种做法是正确的。

## 代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e5 + 5;

int n, h[kMaxN], top, L, R, M;
long long s[kMaxN], f[kMaxN];

struct P {
  int i, x;
  long long y;
} stk[kMaxN], a[kMaxN];

long double slope(P i, P j) { return i.x == j.x ? (i.y > j.y ? -4e18 : 4e18) : (long double)(i.y - j.y) / (i.x - j.x); }

void S(int l, int r) {
  if (l == r) {
    a[l].y = f[a[l].i] + 1LL * a[l].x * a[l].x - s[a[l].i];
    return;
  }
  int mid = l + r >> 1;
  stable_partition(a + l, a + r + 1, [&](P p) { return p.i <= mid; });  // 按照编号分成两半
  S(l, mid), top = 0;                                                   // 算出前一半的 dp 值
  for (int i = l; i <= mid; i++) {
    for (; top > 1 && slope(stk[top - 1], stk[top]) >= slope(stk[top], a[i]); top--) {
    }
    stk[++top] = a[i];
  }  // 构成凸壳
  for (int i = mid + 1; i <= r; i++) {
    L = 1, R = top, M = L + R >> 1;
    for (; L < R; M = L + R >> 1) {
      (M == top ? 4e18 : slope(stk[M], stk[M + 1])) > 2 * h[a[i].i] ? R = M : L = M + 1;
    }
    f[a[i].i] = min(f[a[i].i], stk[L].y - 2LL * h[a[i].i] * stk[L].x + 1LL * h[a[i].i] * h[a[i].i] + s[a[i].i - 1]);
  }  // 转移
  S(mid + 1, r);                                                                     // 继续递归
  inplace_merge(a + l, a + mid + 1, a + r + 1, [](P i, P j) { return i.x < j.x; });  // 合并
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> h[i];
  }
  memset(f, 0x3f, sizeof(f)), f[1] = 0;
  for (int i = 1; i <= n; i++) {
    cin >> s[i], s[i] += s[i - 1], a[i] = {i, h[i], 0};
  }
  sort(a + 1, a + 1 + n, [](P i, P j) { return i.x < j.x; });
  S(1, n), cout << f[n];
  return 0;
}
```

---

## 作者：fengzhaoyu (赞：8)

## 题意
~~应该很好理解吧~~
## 基础
定义 $dp_i$ 表示完成第 $i$ 个任务后的最小值，那么方程转移呢？应是在前面找一个状态 $j(0\leq j\leq i-1)$ 作为上一批任务结束处，再加上花费。但是题中的 $s$ 好像不好处理，怎么办？我们可以用运用花费前置思想。想一想，现在时间多了一个 $s$，那么以后的转移中，所有答案的时间是不是都多了 $s$？那我给他加上就好了。还有，题中给的都是每一个任务的单独的信息，需要前缀和方便计算一批任务的结束时间与总花费。所以方程是：

$dp_i=min(dp_j+t_i\times(c_i-c_j)+s\times(c_n-c_j))$

其中 $t_i$ 和 $c_i$ 已做前缀和处理。
然就有[P2365](https://www.luogu.com.cn/problem/P2365)的方法了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,s,t[5002],c[5003],f[5003];
signed main()
{
	cin>>n>>s;
	for(int i=1;i<=n;i++)
	{
		cin>>t[i]>>c[i];
		t[i]+=t[i-1];
		c[i]+=c[i-1];
	}
	memset(f,0x3f,sizeof f);
	f[0]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<i;j++)
		{
			f[i]=min(f[i],f[j]+t[i]*(c[i]-c[j])+s*(c[n]-c[j]));
		}
	}
	cout<<f[n];
	return 0;
}
```
## 优化
但是此题如何做呢？需要用到[斜率优化](https://blog.csdn.net/sophilex/article/details/132634582)，不会的可以看看，这里只讲推导思路。
原方程：$dp_i=min(dp_j+t_i\times(c_i-c_j)+s\times(c_n-c_j))$

其实就是求 $dp_j+t_i\times(c_i-c_j)+s\times(c_n-c_j)$ 最小值，而斜率优化可以理解为“常数分离”，即 

$dp_i=dp_j+t_i\times(c_i-c_j)+s\times(c_n-c_j)$

$\Rightarrow dp_i=dp_j+t_i\times c_i-t_i\times c_j+s\times c_n-s\times c_j$ ，而此时 $i$ 作为已知量，$j$ 为未知量即所求，所以单独未知量放在等号左边，其余放右边：

$dp_j=(s+t_i)\times c_j+dp_i-t_i\times c_i-s\times c_n$ 

可以将方程化成如上的 $y=kx+b$ 的形式，利用斜率，维护 $dp_i-t_i\times c_i-s\times c_n$ 即截距最小即可。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e5+15;
int c[N],t[N];
int dp[N];
int q[N];
signed main()
{
	int n,s;
	scanf("%lld%lld",&n,&s);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&t[i],&c[i]);
		t[i]+=t[i-1];
		c[i]+=c[i-1];
	}
	int tt=0,hh=0;
	q[tt]=0;
	for(int i=1;i<=n;i++)
	{
		while(hh<tt && (dp[q[hh+1]]-dp[q[hh]])<= (s+t[i])*(c[q[hh+1]]-c[q[hh]])) hh++;// 当队首斜率小于此时要求时，就出队，它已无利用价值
		int j=q[hh];
		dp[i]=dp[j]-(t[i]+s)*c[j]+t[i]*c[i]+s*c[n];
		while(hh<tt && (dp[q[tt]]-dp[q[tt-1]])*(c[i]-c[q[tt]])>=(dp[i]-dp[q[tt]])*(c[q[tt]]-c[q[tt-1]])) tt--;//如果后来状态由于前面的，那前面的也不可能被使用了
		q[++tt]=i;
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

---

## 作者：lalaji2010 (赞：7)

# 任务安排

安利一下我的博客，里面是从斜率优化基础讲起的：[斜率优化 dp](https://www.luogu.com.cn/article/k2ytji6i)。

## 题目链接

### [P2365 任务安排 1](https://www.luogu.com.cn/problem/P2365)

### [P10979 任务安排 2](https://www.luogu.com.cn/problem/P10979)

### [P5785 任务安排 3（[SDOI2012] 任务安排 ）](https://www.luogu.com.cn/problem/P5785)

## 前言

这三个题只在数据范围略有不同，~~我是不会告诉你第三题的代码能过所有的~~，根据不同的数据范围我们要选择合适的做法。

## 分析

先设 $dp[i]$ 表示已经完成了前 $i$ 个任务的花费。你会发现，题目中的 $s$ 难以进行处理，这里用到一个很典的思路，统计当前对后面的影响（后面难以统计前面的贡献，那么就在前面对后面有贡献的时候直接累加在前面的值上），状态的定义就这样略有变化。

再前缀和优化一下，$st[i]=\sum_{j=1}^{i} t_j,sc[i]=\sum_{j=1}^{i} c_j$。

这样一来状态转移就相当简单了：

$$dp[i]=\min_{j=1}^{i-1}(dp[j]+st[i] \times (sc[i]-sc[j])+s \times (sc[n]-sc[j]))$$

表示在 $j$ 和 $j+1$ 之间分开，第 $i$ 件物品做完，不计算 $s$ 的截止时间 $st[i]$ 乘上每个物品的花费。同时完成 $j+1$ 到 $n$ 的总时长都要在 $st$ 数组的基础上再加上这一次启动机器的时间 $s$，还要再额外花费 $s \times (sc[n]-sc[j])$。

这样的时间复杂度是 $O(n^2)$ 的，你会发现可以过掉[P2365 任务安排 1](https://www.luogu.com.cn/problem/P2365)。

注意：$0$ 和 $1$ 之间可以进行分割，$j$ 从 $0$
开始枚举。

### code of [P2365 任务安排 1](https://www.luogu.com.cn/problem/P2365)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long M;
long long c[300005],t[300005];
long long sc[300005],st[300005];
long long dp[300005];
int main(){
	memset(dp,0x3f,sizeof dp);
	cin>>n>>M;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>c[i];
		st[i]=st[i-1]+t[i];
		sc[i]=sc[i-1]+c[i];
	}
	dp[0]=0;
	for(int i=1;i<=n;i++){
		for(int j=0;j<i;j++){
			dp[i]=min(dp[i],dp[j]+st[i]*(sc[i]-sc[j])+M*(sc[n]-sc[j]));
		}
	}
	cout<<dp[n]<<"\n";
	return 0;
}
```
## 进一步地分析

状态转移方程中有含 $i$ 项与含 $j$ 项的乘积，斜率优化没跑了。

把 $\min$ 去掉并拆括号得：

$$dp[i]=dp[j]+st[i] \times sc[i]-st[i] \times sc[j]+s \times sc[n]-s \times sc[j]$$

移项得：

$$dp[j]=(st[i]+s) \times sc[j]+dp[i]-st[i] \times sc[i]-s \times sc[n]$$

令 $y=dp[j],k=st[i]+s,x=sc[j],b=dp[i]-st[i] \times sc[i]-s \times sc[n]$，一定要保证 $b$ 中不含关于 $j$ 的项，因为这样才能将问题转化为最小化 $b$。

如果将 $j$ 在平面直角坐标系中对应的点设为 $(x,y)$。问题就转化成了拿斜率为 $k$ 的线去卡每个点，最小化截距 $b$。

易知最优决策点是下凸包上最后一个斜率小于等于 $k$ 的右端点。

在[P10979 任务安排 2](https://www.luogu.com.cn/problem/P10979)中，$t_i \geq 1$，所以 $st[i]$ 单调递增，进而 $k=st[i]+s$ 单调递增，如果下凸包上某两个点构成的直线的斜率已经不是 $i$ 前面最大的小于等于 $st[i]+s$ 的斜率，由于 $st[i+1]+s>st[i]$，所以该直线的右端点也不可能作为 $i+1$ 的最优决策点。这种特性使得本题可以使用单调队列在维护下凸包的同时维护 $i$ 的最优决策点，时间复杂度 $O(n)$。

注意：

- 单调队列中维护凸包上的点对应的 $j$。
- 维护的点不应存在三点共线，而应当只维护两端点，二分的时候你就知道为啥了。
- 单调队列中应保证至少有两个点再求斜率，deque 难以实现且常数大，建议使用手写队列。
- 维护凸包比较斜率时建议不要使用除法，容易被卡精度，交叉相乘是更好的选择。

### code of [P10979 任务安排 2](https://www.luogu.com.cn/problem/P10979)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long M;
long long c[300005],t[300005];
long long sc[300005],st[300005];
long long dp[300005];
int q[300005];
long long X(int j){
	return sc[j];
}
long long Y(int j){
	return dp[j];
}
long long up(int i,int j){
	return Y(j)-Y(i);
}
long long down(int i,int j){
	return X(j)-X(i);
}
int main(){
	cin>>n>>M;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>c[i];
		st[i]=st[i-1]+t[i];
		sc[i]=sc[i-1]+c[i];
	}
	int h=0,t=0;
	q[t]=0;
	for(int i=1;i<=n;i++){
		while(h<t&&down(q[h],q[h+1])*(st[i]+M)>=up(q[h],q[h+1])) h++;
		dp[i]=dp[q[h]]+st[i]*(sc[i]-sc[q[h]])+M*(sc[n]-sc[q[h]]);
		while(h<t&&up(q[t],i)*down(q[t-1],q[t])<=up(q[t-1],q[t])*down(q[t],i)){
			t--;
		} 
		q[++t]=i;
	}
	cout<<dp[n]<<"\n";
	return 0;
}
```

而在[P5785 任务安排 3（[SDOI2012] 任务安排 ）](https://www.luogu.com.cn/problem/P5785)中，$t_i$ 可能为负，所以 $st[i]+s$ 不具有单调性。我们就需要记下来 $i$ 前面的点的下凸包上的所有点，再根据下凸包上斜率单调递增的特性进行二分,时间复杂度 $O(n \log n)$。

### code of [P5785 任务安排 3（[SDOI2012] 任务安排 ）](https://www.luogu.com.cn/problem/P5785)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long M;
long long c[300005],t[300005];
long long sc[300005],st[300005];
long long dp[300005];
int q[300005];
long long X(int j){
	return sc[j];
}
long long Y(int j){
	return dp[j];
}
long long up(int i,int j){
	return Y(j)-Y(i);
}
long long down(int i,int j){
	return X(j)-X(i);
}
int binary_search(int l,int r,long long k){
	int mid=0;
	while(l<r){
		mid=(l+r)>>1;
		if(up(q[mid],q[mid+1])<=down(q[mid],q[mid+1])*k){
			l=mid+1;
		}else{
			r=mid;
		}
	}
	return q[l];
}
int main(){
	cin>>n>>M;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>c[i];
		st[i]=st[i-1]+t[i];
		sc[i]=sc[i-1]+c[i];
	}
	int top=1;
	q[top]=0;
	for(int i=1;i<=n;i++){
		int j=binary_search(1,top,M+st[i]);
		dp[i]=dp[j]+st[i]*(sc[i]-sc[j])+M*(sc[n]-sc[j]);
		while(top>1&&up(q[top],i)*down(q[top-1],q[top])<=up(q[top-1],q[top])*down(q[top],i)){
			top--;
		} 
		q[++top]=i;
	}
	cout<<dp[n]<<"\n";
	return 0;
}
```

---

## 作者：xAlec (赞：4)

[传送门](https://www.luogu.com.cn/problem/P10979)

## Solution

首先考虑 $O(n^2)$ 的暴力 dp，我们记 $dp_i$ 表示已经处理完前 $i$ 个任务的最小花费，枚举前 $i$ 个中分批于 $j$ 位置，对于处理任务的花费，我们可以记 $sumt_i,sumf_i$ 两个前缀和，花费即为 $sumt_i \times (sumf_i - sumf_j)$，对于启动机器的时间，显然它对后面 $[j + 1.n]$ 需要处理的任务会产生影响，故一同考虑，得到转移式子：

$$
dp_{i} = \min_{j=0}^{i-1}{dp_{j} + sumt_i \times (sumf_i - sumf_j) + S \times (sumf_n - sumf_j)}
$$

显然这是 $O(n^2)$ 的，可以通过弱化版，考虑优化。

我们来拆掉这个柿子：

$$
dp_{i} = \min_{j=0}^{i-1}{dp_{j} + sumt_i \times sumf_i -sumt_i \times sumf_j + S \times sumf_n - S \times sumf_j}
$$

暂时拆掉 $\min$ 并且移个项：

$$
dp_j = sumf_j \times (sumt_i + S) + dp_i - sumt_i \times sumf_i - S \times sumf_n
$$

显然的，在 $i$ 一定的情况下，$dp_i - sumt_i \times sumf_i - S \times sumf_n$ 为定值，令 $y = dp_j,x = summf_j$：

$$
y = x \times (sumt_i + S) + dp_i - sumt_i \times sumf_i - S \times sumf_n
$$

显然的关于 $x$ 的一次函数，斜率为 $k = (sumt_i + S)$，截距为 $b = dp_i - sumt_i \times sumf_i - S \times sumf_n$。

所以说建立平面直角坐标系，决策点集中每个点为 $(sumf_j,dp_j)$，我们现在就将题意转化成了对于一条直线 $y' = kx + b'$，其中 $b' \in (-\infty,\infty)$，使得它与决策点集中的点相交后 $b'$ 计算出来最小。

如下图：

![](https://s21.ax1x.com/2025/01/08/pECn1G8.png)

红色图像为 $y'$，蓝色图像为它与 $C$ 所交。

显然 $C$ 点为最优决策点，且所有最优决策点定位于下凸壳。

考虑如何维护，对于直线 $l_{p_ip_{i-1}}$ 和直线 $l_{p_ip_{i+1}}$，在满足 $k_{l_{p_ip_{i-1}}} < k <k_{l_{p_ip_{i+1}}}$ 时点 $p_i$ 为最优决策点，故选用具有单调性的容器（此处使用单调队列）进行操作，每次二分找到满足该条件的点，然后插入当前决策点 $i$，检查 $i$ 是否与上一个点构成下凸壳，否则就踢掉队尾直到符合下凸壳，即为保证新加入的直线的斜率大于队尾直线的斜率，每次插入新决策点前 dp 转移即可，复杂度 $O(n \log n)$。

但是其实有更优做法，所以该题为 P5785 弱化版。

由于本题 $t_i,c_i$ 满足为正整数，斜率和截距单增，因此下凸壳加入新决策点一定是不断向右加入，只需要在转移前在单调队列中去除无用策略，因为凸包最左侧的点一定是最优的，所以对于当前的 $k$，判断队头直线的斜率，不断踢出队头直到找到第一个大于 $k$ 的队头作为最优决策点转移，这个操作均摊 $O(1)$，故总复杂度 $O(n)$。

## Code

$O(n \log n)$ 做法。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
inline int read() {
    int res = 0, f = 1;
    char ch = getchar();
    while (!isdigit (ch)) f = ch == '-' ? -1 : 1, ch = getchar();
    while (isdigit (ch)) res = (res << 1) + (res << 3) + (ch ^ 48), ch = getchar();
    return res * f;
}
const int MAXN = 3e5 + 10;
int n, S, dp[MAXN], t[MAXN], f[MAXN], preSumt[MAXN], preSumf[MAXN], q[MAXN], head, tail;

signed main() {
    n = read(), S = read();
    for (int i = 1; i <= n; i ++)
        t[i] = read(), f[i] = read();
    for (int i = 1; i <= n; i ++) {
        preSumt[i] = preSumt[i - 1] + t[i];
        preSumf[i] = preSumf[i - 1] + f[i];
    }
    for (int i = 1; i <= n; i ++) {
        int l = head, r = tail, mid = 0;
        while (l < r) {
            mid = l + r >> 1;
            if (dp[q[mid + 1]] - dp[q[mid]] >= (preSumf[q[mid + 1]] - preSumf[q[mid]]) * (preSumt[i] + S)) r = mid;
            else l = mid + 1;
        }
        dp[i] = dp[q[l]] - (S + preSumt[i]) * preSumf[q[l]] + preSumt[i] * preSumf[i] + S * preSumf[n];
        while (head < tail && (__int128_t)(dp[q[tail]] - dp[q[tail - 1]]) * (preSumf[i] - preSumf[q[tail]]) >= (__int128_t)(dp[i] - dp[q[tail]]) * (preSumf[q[tail]] - preSumf[q[tail - 1]])) tail --;
        q[++ tail] = i;
    }
    printf ("%lld\n", dp[n]);
    return 0;
}
```

$O(n)$ 做法。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
inline int read() {
    int res = 0, f = 1;
    char ch = getchar();
    while (!isdigit (ch)) f = ch == '-' ? -1 : 1, ch = getchar();
    while (isdigit (ch)) res = (res << 1) + (res << 3) + (ch ^ 48), ch = getchar();
    return res * f;
}
const int MAXN = 3e5 + 10;
int n, S, dp[MAXN], t[MAXN], f[MAXN], preSumt[MAXN], preSumf[MAXN], q[MAXN], head, tail;

signed main() {
    n = read(), S = read();
    for (int i = 1; i <= n; i ++)
        t[i] = read(), f[i] = read();
    for (int i = 1; i <= n; i ++) {
        preSumt[i] = preSumt[i - 1] + t[i];
        preSumf[i] = preSumf[i - 1] + f[i];
    }
    for (int i = 1; i <= n; i ++) {
        while (head < tail && (__int128_t)(dp[q[head + 1]] - dp[q[head]]) <= (__int128_t)(preSumf[q[head + 1]] - preSumf[q[head]]) * (preSumt[i] + S)) head ++;
        dp[i] = dp[q[head]] - (S + preSumt[i]) * preSumf[q[head]] + preSumt[i] * preSumf[i] + S * preSumf[n];
        while (head < tail && (__int128_t)(dp[q[tail]] - dp[q[tail - 1]]) * (preSumf[i] - preSumf[q[tail]]) >= (__int128_t)(dp[i] - dp[q[tail]]) * (preSumf[q[tail]] - preSumf[q[tail - 1]])) tail --;
        q[++ tail] = i;
    }
    printf ("%lld\n", dp[n]);
    return 0;
}
```

## Warning

计算斜率可以使用交叉相乘规避掉精度问题，但是有可能暴 longlong 需要 int128。

---

## 作者：XXh0919 (赞：3)

这个题算斜率优化 dp 里面比较简单的了吧，还是很容易能想到思路。

首先我们肯定能看出来这是 dp。方程也很好想：

$$dp_i=\text{min}\{dp_j+t_i(c_i-c_j)+s(c_n-c_j)\}$$

其中 $0\le j<i$，$t_i$ 和 $c_i$ 均已做前缀和处理。

但是显然这个方程的复杂度已经达到了 $O(n^2)$，对于这个题会爆炸，所以考虑优化。

我们把原方程转换一下：

$$dp_i=\text{min}\{dp_j+t_ic_i-t_ic_j+s\times c_n-s\times c_j\}$$

把与 $j$ 无关的都提到外面：

$$dp_i=\text{min}\{dp_j-c_j(t_i+s)\}+t_ic_i+s\times c_n$$

移项，得：

$$dp_i-t_ic_i-s\times c_n=\text{min}\{dp_j-c_j(t_i+s)\}$$

现在我们令 $k_i=t_i+s$，$x_j=c_j$，$b_i=dp_i-t_ic_i-s\times c_n$，$y_j=dp_j$，则式子就变成了：

$$b_i=\text{min}\{y_j-k_ix_j\}$$

这不就是斜率优化板子吗？！在本题中，斜率单调上升，维护下凸壳。

于是代码也就写出来了：

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
#define pi pair<int,int>
#define mkp(a,b) make_pair((a),(b)) 
#define IOS cin.tie(0)->sync_with_stdio(0)
using namespace std;
const int N=1e6+15;

int n,s;
int t[N],c[N];
int q[N],hh,tt;
int dp[N];

signed main(){
	IOS;
	cin>>n>>s;
	rep(i,1,n){
		cin>>t[i]>>c[i];
		t[i]+=t[i-1];
		c[i]+=c[i-1];
	}
	hh=0,tt=-1;
	q[++tt]=0;
	rep(i,1,n){
		while(hh<tt&&dp[q[hh+1]]-dp[q[hh]]<(s+t[i])*(c[q[hh+1]]-c[q[hh]]))++hh;
		int j=q[hh];
		dp[i]=dp[j]-(s+t[i])*c[j]+t[i]*c[i]+s*c[n];
		while(hh<tt&&(dp[q[tt]]-dp[q[tt-1]])*(c[i]-c[q[tt]])>=(dp[i]-dp[q[tt]])*(c[q[tt]]-c[q[tt-1]]))--tt;
		q[++tt]=i; 
	}
	cout<<dp[n]<<endl;
	return 0;
} 
```
当然这个题保证了时间 $t_i$ 单调递增。那如果不保证了时间 $t_i$ 单调递增呢？（比如 [P5785](https://www.luogu.com.cn/problem/P5785)）

这个时候为了维护下凸壳，我们就需要二分了。当然代码就不放了，请各位自行求解。

---

## 作者：Tachibana27 (赞：3)

容易发现这题就是 [P2365](https://www.luogu.com.cn/problem/P2365) 的 $O(n)$ 做法。

先考虑很裸的状态 $dp_{i,j}$，表示当前考虑到第 $i$ 位，共分为 $j$ 批任务的最小代价。显然有转移 

$$dp_{i,j}=\min\limits _{k=0} ^{i-1}\{dp_{k,j−1}+(s\times j+\sum \limits _{l=1} ^{i}T_l)\times \sum \limits  _{l=k+1} ^{i} C_l\}$$

发现这个东西很慢，复杂度来到 $O(n^4)$。考虑前缀和，能够优化到 $O(n^3)$。$sumT_i=\sum \limits _{j=1} ^{i}T_j$，$sumC_i=\sum \limits  _{j=1} ^{i} C_j$。下文同。


---



用一个叫做**费用提前计算优化**的东西。考虑现有状态 $dp_{i,j}$ 中，我们拿 $j$ 只是用来计算 $s\times j$ 的。如果我们令从 $l$ 转移到 $r$ 表示 $l+1$ 到 $r$ 内的任务分为一批，那么当前是第几批不重要。此时启动时间 $s$ 总会对后面的处理增加代价，所以直接加上即可。发现状态的第二维可以被优化。

转移为 

$$dp_i=\min\limits _{j=1} ^{i}\{dp_{j-1}+sumT_i\times (sumF_i−sumF_{j-1})+s\times(sumF_n−sumF_{j-1})\}$$

其中 $s\times(sumF_n−sumF_{j-1})$ 为当前分批造成的启动时间对后面所有任务带来的代价。

此时复杂度是 $O(n^2)$ 的。

---

我们无法用单调数据结构优化它，原因在于 $i$ 和 $j$ 混在一起。也就是说，我们需要对它继续变形。

这里 $\min$ 本质上在求最小的 $dp_i$，也就是说找到一个 $j$ 使得 $dp_i$ 最小即可。我们把它去掉，并对原式展开，有：

$$dp_i=dp_{j-1}-sumF_{j-1}\times sumT_i-s\times sumF_{j-1}+sumT_i\times sumF_i+s\times sumF_n$$

会发现我把 $i$ 和 $j$ 分离开了。

不妨记 $b=dp_i-sumT_i\times sumF_i-s\times sumF_n$，$x=sumF_{j-1}$，$k=sumT_i+s$，对原式移项然后带入，变成了一个很美观的东西：

$$b=y-xk$$

它可以变成我们很喜欢的 $y=xk+b$，也就是说这个东西就是一个一次函数。

因为 $sumT_i\times sumF_i-s\times sumF_n$ 是定值，所以最终我们希望 $b$ 最小。$dp_i$ 一定需要由某个 $j$ 转移而来，也就是说，需要有某个 $(x,y)$ 在该直线上。代入 $x,y$ 得 $(sumF_{j-1},dp_{j-1})$。然后可以把它们扔到平面直角坐标系上，拿直线从下往上扫，第一个点就是可以更新的 $j$。

所以我们将问题转化为：有 $n$ 个点在平面直角坐标系上，有一条斜率固定的直线，问最小的截距是多少。


---

我们考虑维护**下凸**的点集，如果不知道是什么也没有关系，可以看下面这个东西：

![](https://cdn.luogu.com.cn/upload/image_hosting/1fviaxdg.png)

~~由于技术原因，没能画出 $x$ 和 $y$ 轴，就姑且把图片的左下角看作原点吧。~~

可以大致理解为先下降后上升的一些点（上凸反之）。当我们拿任意一条直线从下往上去“切”这些点时，只有下凸点集上的点可能被“切”到。如上图，不可能切到 $D$ 点。

考虑如何维护。假设上图按照字母顺序加点，已经加入 $D$ 点。这个时候所有点都在下凸点集内。此时要加入一个点 $E$，发现 $D$ 点不能在下凸点集中，否则不下凸。

也就是说，若 $CD$ 斜率大于 $DE$ 斜率，那么 $D$ 将不会再出现在下凸点集中了。

记 $C$ 的坐标为 $(C_x,C_y)$，以此类推，那么 $D$ 将不在点集内仅当 $\frac{D_y-C_y}{D_x-C_x}\ge \frac{E_y-D_y}{E_x-D_x}$。事实上三点共线舍去不劣。

这个东西就可以拿单调队列维护了。答案是在单调队列中第一次出现的，斜率大于或等于当前考虑直线的斜率的线段的靠左的端点（好绕啊）。

发现直线 $y=xk+b$ 的斜率递增，所以可以及时排除掉无法成为答案的线段。

然后把计算斜率的部分叉乘一下，防止挂精度。

```cpp

inline int read(){
	char ch=getchar();
	int s=0;
	int w=1;
	while(ch<'0' or ch>'9'){
		if(ch=='-')
			w=-1;
		ch=getchar();
	}
	while(ch>='0' and ch<='9'){
		s=(s<<3)+(s<<1)+(ch xor 48);
		ch=getchar();
	}
	return s*w;
}//快读自动掠过
int n;
int s;
class node{
	public:
		int f=0;
		int t=0;
		inline friend node operator+(node a,node b){
			node c;
			c.t=a.t+b.t;
			c.f=a.f+b.f;
			return c;
		}
}a[100086],sum[100086];
class Que{
	public:
		int q[1000086];
		int l=1;
		int r=0;
		inline void pop(){
			l++;
			return;
		}
		inline void push(int x){
			q[++r]=x;
			return;
		}
		inline void pop_b(){
			r--;
			return;
		}
		inline bool empty(){
			return l>=r;
		}
}q;//手写了一下双端队列
int dp[1000086];
inline bool check(int ax,int ay,int bx,int by,int cx,int cy){
	return (by-ay)*(cx-bx)>=(cy-by)*(bx-ax);//交叉相乘
}

#define k (s+sum[i].t)
#define c (sum[i].t*sum[i].f+s*sum[n].f)
signed main(){
	n=read();
	s=read();
	memset(dp,0x7f,sizeof dp);
	for(int i=1;i<=n;i++){
		a[i].t=read();
		a[i].f=read();
		sum[i]=a[i]+sum[i-1];//维护前缀和
	}
	dp[0]=0;
    q.push(0);//一定要往里面丢一个0，否则无法更新
	for(int i=1;i<=n;i++){
		while((not q.empty()) and dp[q.q[q.l+1]]-dp[q.q[q.l]]<=k*(sum[q.q[q.l+1]].f-sum[q.q[q.l]].f))//若线段斜率小于直线的斜率，那么它将永远不会成为答案
			q.pop();
		dp[i]=dp[q.q[q.l]]-k*sum[q.q[q.l]].f+c;//此时的队首就是可更新的 j
		while((not q.empty()) and check(sum[q.q[q.r-1]].f,dp[q.q[q.r-1]],sum[q.q[q.r]].f,dp[q.q[q.r]],sum[i].f,dp[i]))//凸包更新
			q.pop_b();
		q.push(i);//不要忘记把当前点扔进去
	}
	std::cout<<dp[n];
	return 0;//撒花
}

```

~~斜率优化好可爱。~~

---

## 作者：nytyq (赞：2)

## 算法

DP，斜率优化。

## 思路

这里列状态转移方程的时候有一个特点，叫做费用提前计算。为了清晰辨明，$c_i$ 为未经前缀和优化的数组，$t_i$ 同理，反之，$C_i$ 为经前缀和优化的数组，$T_i$ 同理。

如果以 $j(0 \le  j \le i)$ 作为这个批次的左端点，则 $i$ 一定是这个批次的右端点。因为此序列需要启动时间 $s$，容易考虑到 $s$ 对后面的所有时间都有影响。但是此时式子会连续区间求和，则有 $C_i=\sum_{i=1}^n c_i$，$T_i=\sum_{i=1}^{n} t_i$，则启动的代价为 $s\times(C_n-C_j)$，此序列考虑贡献为 $(C_i-C_j)\times T_i$。

则可以列出转移方程：

$$
\displaystyle f_i=\min_{0 \le j < i} \left\{f_j+(C_i-C_j)T_i+s(C_n-C_j)\right\}
$$

显然转移的时间复杂度为 $O(n^2)$。

考虑优化。

则~~化简~~式子为:

$$
\displaystyle 
f_i=\min_{0 \le j < i} \left\{f_j+C_iT_i-C_jT_i+s(C_n-C_j)\right\}
$$ 

设 $j$ 如果是当前的最优转移点，进一步移项化简为:

$$
f_j=(T_i+s)C_j+(f_i-C_iT_i+sC_n)
$$

这个式子有点像 $y=kx+b$，则 $f_j$ 对应的是 $y$，$C_j$ 对应的是 $x$，考虑到建立一个直角坐标系看可不可以进一步优化：

则坐标系的 $x$ 为 $C_j$，$y$ 为 $f_j$。（这里不理解没关系，我刚开始也不理解，后来总结出一个规律，如上，一定正确。）

那么可以建立出这样一个直角坐标系：

![123](https://cdn.luogu.com.cn/upload/image_hosting/cdhf6h7w.png)

则我们会有一些点分散在其中：

![123](https://cdn.luogu.com.cn/upload/image_hosting/y2whwazo.png)

因为我们的 $f_i$ 要求的最小值，这 $y=kx+b$ 中的 $b$ 要取最小值，因为 $b=f_i-C_iT_i+sC_n$，其中 $C_iT_i+sC_n$ 为常数，若 $b$ 越小，则 $f_i$ 一定越小。

容易发现对于不同的斜率 $k$，其取得 $b$ 最小的点一定是这些比较靠下的点，如下图：

![123](https://cdn.luogu.com.cn/upload/image_hosting/lsao511n.png)

这个东西和[凸壳](https://baike.baidu.com/item/%E5%87%B8%E5%A3%B3/6761501)很像，我们的转移点一定是在这个凸壳上面取。

比如说有一个直线 $y=k_1x+b_1$，其与凸壳相切为这个样子：

![123](https://cdn.luogu.com.cn/upload/image_hosting/vyqe360e.png)

则一定可以判定 $\text{hh}$ 不是转移点的不等式为：

$$
k_1 \ge \text{slope}(hh,hh+1)
$$

其中 $\text{slope}(j,i)$ ，其中 $j < i$，为如下式子计算（其实就是计算斜率）：

$$
\text{slope}(i,j)=\frac{f_i-f_j}{C_i-C_j}
$$

为什么可以这样算斜率呢？

因为根据斜率公式 $\Delta k=\displaystyle \frac{\Delta y}{\Delta x}$，而在这个直角坐标系中，$x$ 为 $C_j$，$y$ 为 $f_i$。

但是可以发现一个问题，对于两个数 $i$ 和 $j$，有 $i>j$，则一定有 $k_i>k_j$，其中 $k_q$ 为 $q$ 点的对应直线的斜率。

那么我们得到一个结论：斜率一定单调递增。

根据结论，证明使用**斜率筛掉一些点对后面的转移没有影响**这样的做法是对的：

当我们的 $j$ 已经把一些点都筛掉了，则 $i>j$，有 $k_i>k_j$，那么都会被 $k_j$ 筛掉，到 $k_i$ 一定也会被筛掉。

证毕。

那我们再来考虑插入节点 $i$ 至凸壳。

![123](https://cdn.luogu.com.cn/upload/image_hosting/59i08nxt.png)

我们很容易发现：

$$
\text{slope}(\text{tt},\text{tt}+1) \ge \text{slope}(\text{tt},i)
$$

则根据这个式子，可以筛掉 $\text{tt}$ 保持凸壳的性质——“整体外凸”。

但要注意精度问题，所以将求斜率的式子改为乘积式即可。

## Code

```
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=3e5+10;
#define int long long int
int c[N],t[N],n,s;
int q[N];
int f[N];
signed main()
{
    ios::sync_with_stdio(0);
    cin>>n>>s;
    for(int i=1;i<=n;i++){
        cin>>t[i]>>c[i];
        t[i]+=t[i-1];
        c[i]+=c[i-1];
    }
    int hh=0,tt=0;
    q[0]=0;
    for(int i=1;i<=n;i++){
        while(hh<tt && f[q[hh+1]]-f[q[hh]]<=(t[i]+s)*(c[q[hh+1]]-c[q[hh]])) hh++;
        int j=q[hh];
        f[i]=f[j]-(t[i]+s)*c[j]+t[i]*c[i]+s*c[n];
        while(hh<tt && (f[q[tt]]-f[q[tt-1]]) * (c[i]-c[q[tt-1]]) >= (c[q[tt]]-c[q[tt-1]]) * (f[i]-f[q[tt-1]]) ) tt--;
        q[++tt]=i;
    }
    cout<<f[n];
    return 0;
}
```

---

## 作者：_xguagua_Firefly_ (赞：2)

### 分析

斜率优化 DP 入门题。我们先处理 $t _ {i} = \sum _ {j = 1} ^ {i} T _ {i},c _ i = \sum _ {j = 1} ^ {i} C _ {i}$。

我们设 $dp _ {i}$ 为考虑前 $i$ 个任务，方案最优时的最小总费用。$dp _ {i}$ 从子任务 $dp _ {j}$ 转移而来，$[j + 1,i]$ 对答案的贡献为 $t _ {i}(c _ {i} - c _ {j + 1 - 1}) = t _ {i}(c _ {i} - c_ {j})$。然后 $[j + 1,n]$ 会因为启动时间而受到影响，所以会有 $s(c _ {n} - c _ {j})$ 的贡献。

因为我们要取最小值，所以汇总得到转移方程：

$$
dp _ {i} = \min _ {j = 0} ^ {i - 1} \{dp _ {j} + t _ {i}(c _ {i} - c_ {j}) + s(c _ {n} - c _ {j})\}
$$

考虑优化，先把式子展开，得到如下式子：

$$
\begin{aligned}
dp _ {i} &= \min \{ dp _ {j} + t _ {i} c _ {i} - t _ {i} c _ {j} + s \times c _ {n} - s \times c _ {j} \} \\
&= \min \{dp _ {j} - t _ {i} c _ {j} - s \times c _ {j} \} + t _ {i} c _ {i} + s \times c _ {n}
\end{aligned} \\
$$

因为 $t _ {i}$ 已知，可以代入求值，所以我们考虑设 $y = dp _ {i} - t _ {i} c _ {i} - s \times c _ {n},k = -c _ {j},x = t _ {i},b = dp _ {j} - s \times c _ {j}$，则我们需要求的就是 $\min \{ kx + b \}$，这个可以用李超线段树维护。

初始值为 $dp _ {0} = 0,k _ {0} = -c _ {0} = 0,b _ {0} = dp _ {0} - s \times c _ {0} = 0$，所以我们要先插入一条 $k = 0,b = 0$ 的线段。

### Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int,int>
using namespace std;

constexpr int MAXN = 3e5 + 24;
namespace LiChaoSGT
{
    #ifdef QUERY_MAX
    #define min max
    #define inf LONG_LONG_MIN
    #else
    #define inf LONG_LONG_MAX
    #endif
    struct Rukkhadevata
    {
        int ls,rs;
        pii seg;
    }tree[MAXN];
    inline int F(pii &id,int x)
    {return id.first * x + id.second;}
    int cnt,root;
    inline void insert(int &rt,int l,int r,pii S)
    {
        if(!rt)
            tree[rt = ++cnt].seg = S;
        else
        {
            int mid = (l + r) >> 1;
            if(F(S,mid) < F(tree[rt].seg,mid))
                swap(S,tree[rt].seg);
            if(S.first > tree[rt].seg.first)
                insert(tree[rt].ls,l,mid,S);
            else
                insert(tree[rt].rs,mid + 1,r,S);
        }
    }
    inline int query(int rt,int l,int r,int p)
    {
        if(!rt)
            return inf;
        int mid = (l + r) >> 1;
        return min(F(tree[rt].seg,p),(p <= mid) ? query(tree[rt].ls,l,mid,p) : query(tree[rt].rs,mid + 1,r,p));;
    }
}
int n,S,t[MAXN],c[MAXN],dp[MAXN];
signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >> S;
    for(int i = 1;i <= n;i++)
    {
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    int V = t[n];
    using namespace LiChaoSGT;
    insert(root,0,V,{0,0});
    for(int i = 1;i <= n;i++)
    {
        dp[i] = query(root,0,V,t[i]) + S * c[n] + t[i] * c[i];
        insert(root,0,V,{-c[i],dp[i] - S * c[i]});
    }
    cout << dp[n];
}
```

---

## 作者：Brilliant11001 (赞：2)

## 斜率优化 dp

[先安利一下我斜率优化的博客](https://www.cnblogs.com/Brilliant11001/p/18318473)

先来看看这道题的弱化版吧。

#### [P2365 任务安排](https://www.luogu.com.cn/problem/P2365)

### 思路

可见这是个序列问题，考虑将目前处理到第几位作为阶段来划分，即令 $dp_{i}$ 表示把前 $i$ 个任务处理完的最小花费。

枚举最后一次分批在哪个位置，设为 $j$，$0\le j < i$。

所以最后一批任务即为 $j + 1\sim i$。

所以状态转移方程为：

$dp_{i} = \min\limits_{0\le j < i}\{dp_{j} + val(j + 1,i)\}$

其中 $val(j + 1,i)$ 表示第 $j + 1\sim i$ 个任务带来的花费。

前 $j$ 个任务的最小花费即为 $dp_{j}$，所以只需计算 $val(j + 1, i)$。

难点在于花费的计算和完成任务的时间有关，机器启动时间 $S$ 会对后面的阶段造成影响，所以这里需要用到**费用提前计算**的思想，提前算出启动时间 $S$ 带来的额外花费。

用 $sumt_{i}$ 来表示要完成前 $i$ 个任务所需的时间和，$sumc_{i}$ 表示前 $i$ 个任务的费用系数总和，都可以用前缀和提前求出。

综上所述：状态转移方程为：

$dp_{i} = \min\limits_{0\le j < i}\{dp_{j} + sumt_{i}\times (sumc_{i} - sumc_{j}) + S\times (sumc_{n} - sumc_{j})\}$

时间复杂度为 $O(n^2)$，可以通过此题。

$\texttt{Code:}$

```cpp
#include <cstring>
#include <iostream>

using namespace std;

const int N = 5010;
typedef long long ll;

int n, S;
ll sumt[N], sumc[N];
ll dp[N];

int main() {
    scanf("%d%d", &n, &S);
    for(int i = 1; i <= n; i++) {
        scanf("%d%d", &sumt[i], &sumc[i]);
        sumt[i] += sumt[i - 1];
        sumc[i] += sumc[i - 1];
    }
    memset(dp, 0x3f, sizeof dp);
    dp[0] = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 0; j < i; j++)
            dp[i] = min(dp[i], dp[j] + sumt[i] * (sumc[i] - sumc[j]) + S * (sumc[n] - sumc[j]));
    printf("%lld", dp[n]);
    return 0;
}
```

---

### 本题就是加强版啦！

题目描述一样，但 $n\le 3 \times 10^5$，考虑优化。

对状态转移方程进行整理，合并同类项，得：

$dp_{i} = \min\limits_{0\le j < i}\{dp_{j} - (S + sumt_{i})\times sumc_{j}\} + sumt_{i}\times sumc_{i} + S\times sumc_{n}$

对于每个 $j$，去掉 $\min$，得：

$dp_{i} = dp_{j} - (S + sumt_{i})\times sumc_{j} + sumt_{i}\times sumc_{i} + S\times sumc_{n}$

顺便提一句动态规划的优化思路：

### 一个原则：

在朴素代码上做等价变形。

### 三个方向：

1. 优化状态设计，阶段和状态转移方程；
2. 若有状态被多次计算或调用，则考虑加上记忆化搜索；
3. 若有多层循环，考虑将与外层循环相关的变量看作定值，及时排除内层循环中的不可能决策或利用数据结构等方法优化找最值的过程，从而优化掉内层循环。

根据上文提到的方向 $3$，和外层循环 $i$ 相关的值可以暂时看成常量，所以原式的变量就只有 $dp_{j}$ 和 $sumc_{j}$，分别看成 $y$ 和 $x$，整理得：

$y = (S + sumt_{i})\times x + dp_{i} - sumt_{i}\times sumc_{i} - S\times sumc_{n}$

有点眼熟…… 再多看一眼…… 这不是直线斜截式 $y = kx + b$ 吗？

以 $sumc_{j}$ 为横坐标，$dp_{j}$ 为纵坐标，建立平面直角坐标系，所以这是一条斜率为 $S + sumt_{i}$，截距为 $dp_{i} - sumt_{i}\times sumc_{i} - S\times sumc_{n}$ 的直线。

也就是说，决策候选集合是坐标系的一个点集，每个决策 $j$ 都对应一个点 $(sumc_{j}, dp_{j})$。

这样一来，状态转移方程就变为了 $b_i = \min\limits_{0\le j < i}\{y_i - k_ix_i\}$

因为要求的 $dp_{i}$ 是 $b_i$ 中一个系数为正的项，所以问题转化成了：坐标系中有一些点 $(x_j,y_j)$，从中选出一个点，使得经过它，且斜率为 $k_i$ 的直线的截距最小。

形象一点来说就是有一根斜率为 $k_i$ 的直线从负无穷开始逐渐上移，直到它碰到点集中的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/kqmwp8uq.png)

如图所示，点 $D$ 就是我们要找的最佳决策点。

观察图像不难发现，只有当 $(x_j,y_j)$ 位于下凸壳时，$j$ 才可能被作为最优决策，所以我们不需要维护整个点集，只需要维护一个下凸壳就行了。

算完 $dp_{i}$ 我们就要把点 $(x_i,y_i)$ 插入点集中，那么如何维护点集才能使我们能快速地找到最优决策呢？

### 解法一：

首先想到：可以用二分。观察，思考什么时候 $(x_j,y_j)$ 可以作为最优决策呢？

可以发现，当 $(x_j,y_j)$ 与它的上一个点 $(x_{j-1},y_{j-1})$ 构成的直线的斜率小于 $k_i$，且与它的下一个点 $(x_{j+1},y_{j+1})$ 构成的直线的斜率大于 $k_i$ 时，$j$ 为最优决策点。

我们先用一个容器（这里选用队列）来存储目前的点集，然后二分求**第一个和上一个点构成的直线斜率小于 $k_i$ 且和后一个点构成的直线斜率大于 $k_i$ 的点**。

然后用二分出的答案来计算 $dp_{i}$。

再插入决策 $i$，这时要维护下凸壳，检查队尾 $q_{tt}$、$q_{tt - 1}$ 和要加入的 $i$ 是否构成一个下凸壳，具体地，当 

$$\frac{dp_{q[tt]} - dp_{q[tt - 1]}}{sumc_{q[tt]} - sumc_{q[tt - 1]}} \ge \frac{dp_{i} - dp_{q[tt]}}{sumc_{i} - sumc_{q[tt]}}$$

时，就应该将队尾弹出。

这样就可以将时间复杂度优化到 $O(n\log n)$。

$\texttt{Code:}$

```cpp
#include <iostream>

using namespace std;

const int N = 300010;
typedef long long ll;
int n, S;
ll sumt[N], sumc[N];
ll dp[N];
int q[N], hh, tt = -1;

int main() {
    scanf("%d%d", &n, &S);
    for(int i = 1; i <= n; i++) {
        scanf("%lld%lld", &sumt[i], &sumc[i]);
        sumt[i] += sumt[i - 1];
        sumc[i] += sumc[i - 1];
    }
    q[++tt] = 0;
    for(int i = 1; i <= n; i++) {
        int l = hh, r = tt;
        while(l < r) {
            int mid = l + r >> 1;
            if(dp[q[mid + 1]] - dp[q[mid]] > (sumt[i] + S) * (sumc[q[mid + 1]] - sumc[q[mid]])) r = mid;
            else l = mid + 1;
        }
        dp[i] = dp[q[l]] - (S + sumt[i]) * sumc[q[l]] + sumt[i] * sumc[i] + S * sumc[n];
        while(hh < tt && (__int128)(dp[q[tt]] - dp[q[tt - 1]]) * (sumc[i] - sumc[q[tt]]) >= (__int128)(dp[i] - dp[q[tt]]) * (sumc[q[tt]] - sumc[q[tt - 1]])) tt--;
        q[++tt] = i;
    }
    printf("%lld", dp[n]);
    return 0;
}
```

### 解法二

注意到这道题有个特殊条件：$T_i,C_i$ 都是正整数，意思就是说 $sumt$ 和 $sumc$ 数组一定是单调递增的，所以我们只会不断地在右边加点，而且 $k_i$ 是单调递增的。

外层循环每增加 $1$，就会新加入一个决策点，同时由于斜率会变大，就可能导致前面的一些决策没用了，要及时排除，只保留凸包上相邻两点连线斜率大于 $k_i$ 的部分，那么凸包最左端的点一定就是最优决策点。

这启示我们可以用单调队列来维护凸包。

建立一个单调队列 $q$，当外层循环 $i$ 增加 $1$ 后：

1. 排除无用决策，检查队头元素 $q_{hh}$ 和 $q_{hh + 1}$ 构成的直线的斜率是否小于等于当前斜率，具体地，当

$$\frac{dp_{q[hh + 1]} - dp_{q[hh]}}{sumc_{q[hh + 1]} - sumc_{q[hh]}} \le sumt_{i} + S$$

时，就应该将队头弹出；

3. 取出队头 $j = q_{hh}$ 为最优决策，用它来计算 $dp_{i}$；

4. 即将要把 $i$ 插入队尾，检查队尾 $q_{tt}$、$q_{tt - 1}$ 和要加入的 $i$ 是否构成一个下凸包，具体地，当

$$\frac{dp_{q[tt]} - dp_{q[tt - 1]}}{sumc_{q[tt]} - sumc_{q[tt - 1]}} \ge \frac{dp_{i} - dp_{q[tt]}}{sumc_{i} - sumc_{q[tt]}}$$
时，就应该将队尾弹出。

时间复杂度为 $O(n)$。

$\texttt{Code:}$

```cpp
#include <cstring>
#include <iostream>

using namespace std;

const int N = 300010;
typedef long long ll;

int n, S;
ll sumt[N], sumc[N];
int q[N], hh, tt = -1;
ll dp[N];

int main() {
    scanf("%d%d", &n, &S);
    for(int i = 1; i <= n; i++) {
        scanf("%lld%lld", &sumt[i], &sumc[i]);
        sumt[i] += sumt[i - 1];
        sumc[i] += sumc[i - 1];
    }
    q[++tt] = 0;
    for(int i = 1; i <= n; i++) {
      	//为防止浮点除法导致精度丢失，故交叉相乘，但要注意极端数据会爆 long long，需使用 __int128
        while(hh < tt && (__int128)(dp[q[hh + 1]] - dp[q[hh]]) <= (__int128)(sumt[i] + S) * (sumc[q[hh + 1]] - sumc[q[hh]])) hh++;
        int j = q[hh];
        dp[i] = dp[j] - sumc[j] * (sumt[i] + S) + sumt[i] * sumc[i] + sumc[n] * S;
        while(hh < tt && (__int128)(dp[q[tt]] - dp[q[tt - 1]]) * (sumc[i] - sumc[q[tt]]) >= (__int128)(dp[i] - dp[q[tt]]) * (sumc[q[tt]] - sumc[q[tt - 1]])) tt--;
        q[++tt] = i;
    }
    printf("%lld", dp[n]);
    return 0;
}
```

**注意：为了防止除法丢失精度，可以交叉相乘。**

然鹅，对于一些数据及其毒瘤的题，不仅斜率可能不单调递增，而且横坐标也可能不单调递增，我们分别来看一下这两种情况。

### 1. 横坐标单增，斜率不单增

[P5785 \[SDOI2012\] 任务安排](https://www.luogu.com.cn/problem/P5785)

题意相同，但 $T_i$ 可能为负数，也就是说 $sumt$ 数组不一定单调递增，也就导致斜率可能一会儿大，一会儿小，单调队列的方法行不通了，就只能采用解法一：二分来做。

### 2. 横坐标不单增，斜率单增

目前没有遇到这种题。

横坐标不单增，意味着可能需要在中间某个地方插入点，但单调队列还是可以用的，这时可以在单调队列中二分插入，但这样单调队列就要写成“单调链表” 了，感觉不太好写。

### 3. 横坐标不单增，斜率也不单增

[P4655 \[CEOI2017\] Building Bridges](https://www.luogu.com.cn/problem/P4655)

不得不说这种题真的毒瘤。

这时候就应该拿出斜率优化三件套了：**李超线段树、cdq 分治、平衡树。**

但是蒟蒻不会前两个，只能选择平衡树。

解释一下为什么是平衡树。

我们需要一个数据结构，支持以下操作：

1. 插入一个点 $(x,y)$；
2. 查询第一个横坐标小于 $x$ 的点的下标；
3. 查询第一个横坐标大于 $x$ 的点的下标；
4. 删除一个点；
5. 查询第一个**和左边点组成的直线斜率小于 $k$，且和右边点组成的直线斜率大于 $k$ 的点**的下标。

综上所述，平衡树是最符合条件的数据结构。

代码的话太长就不放了，可以去我的斜率优化的博客里看。

---

## 作者：MoonCake2011 (赞：2)

**注：这是我之前很久写的斜率优化 dp 详解，过来投题解**。

# 前置知识

单调队列

dp

单调队列优化 dp

# 正文

首先，来一道题 [Cats Transport](https://www.luogu.com.cn/problem/CF311B)。

因为这里着重讲斜率优化，dp 方程就简单讲一下。

首先，每只猫刚等待就被接走的饲养员的出发时间是 $a_i=t_i-\sum_{j=1}^i d_j$。

对 $a_i$ 排序。

状态定义 $dp_{i,j}$ 为用前 $i$ 个饲养员接走 $j$ 只猫的最小等待时间之和。

贪心一下，转移过程中，第 $i$ 个饲养员的出发时间为 $a_j$。

于是第 $u$ 只猫的等待时间为 $a_j-a_u$。

就可以写出转移方程。

$$dp_{i,j}=\min_{0 \le k <j}\{dp_{i-1,k}+\sum_{u=k+1}^j a_j-\sum_{u=k+1}^j a_u\}$$

前缀和优化，设 $s_i=\sum_{j=1}^i a_i$。

$$dp_{i,j}=\min_{0 \le k <j}\{dp_{i-1,k}+a_j\times j-a_j\times k-s_j+s_k\}$$

但这样是 $O(m^2p)$ 的，过不了。

考虑斜率优化，先提出常量。

$$dp_{i,j}=a_j\times j-s_j\min_{0 \le k <j}\{dp_{i-1,k}-a_j\times k+s_k\}$$

转化为 $y-bx$ 的一次函数形式。

设 $x=k$，$y=dp_{i-1,k}+s_k$，$b=a_j$。

$$dp_{i,j}=a_j\times j-s_j\min_{0 \le k <j}\{y-bx\}$$

那我们需要求 $y$ 的最小值。

我们那我们就是需要求 $(x,y)$ 的 $y$ 轴截距的最小值。

我们找一条斜率为 $b$ 的直线，从下向上平移，遇到的第一个点就是斜率最小的。
![](https://cdn.acwing.com/media/article/image/2021/09/25/55909_306884c91d-Xnip2021-09-25_11-46-08.jpg)
又发现，那个点一定在下凸壳上。

我们再去凸壳里找点 $t$。

满足点 $t-1,t$ 的两点间的斜率 $p_0<b$ 小于 点 $t,t+1$ 的两点间的斜率的最小的 $t$。

写作 $\text K(t-1,t)<b<\text K(t,t+1)$ 且 $t$ 最小。

其中 $K$ 为斜率 $K(i,j)=\dfrac{y_j-y_i}{x_j-x_i}$。

点 $t$ 一定就是第一个碰到的点。

因为队列中斜率与 $b$ 都单调递增（对 $a_i$ 排过序）。

所以直接将不满足以上不等式的从队头出队就行了。

每次加入点的时候。

在队尾维护斜率的单调性。

于是 $O(pm)$ 做出来了。

## 总结

将 $dp$ 方程变成如下。

$$dp_i=k+\min/\max\{y_j-kx_j\}$$

设队头为 $h$，队尾为 $t$，手写队列为 $q$。

那我们就可以在 $\dfrac{y_{q_{h+1}}-y_{q_h}}{x_{q_{h+1}}-x_{q_h}} \le b$ 的情况下删掉队头。

现在，队头就是最优答案。

在 $\dfrac{y_i-y_{q_t}}{x_i-x_{q_t}}\le\dfrac{y_{q_t}-y_{q_{t-1}}}{x_{q_t}-x_{q_{t-1}}}$ 的情况下删掉队尾。

最后，向队列里加入 $i$。

代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,p;
int sd[100010],h[100010],t[100010];
int s[100010],a[100010],q[200010];
int dp[110][100010];
signed main() {
	cin>>n>>m>>p;
	for(int i=2;i<=n;i++) cin>>sd[i],sd[i]+=sd[i-1];
	for(int i=1;i<=m;i++) cin>>h[i]>>t[i],a[i]=t[i]-sd[h[i]];
	sort(a+1,a+m+1);
	for(int i=1;i<=m;i++) s[i]=s[i-1]+a[i];
	memset(dp,0x3f,sizeof dp);
	for(int i=0;i<=p;i++) dp[i][0]=0;
	for(int i=1;i<=p;i++){
		int head=1,tail=0;
		q[++tail]=0;
		for(int j=1;j<=m;j++){
			while(head<tail && dp[i-1][q[head+1]]+s[q[head+1]]-dp[i-1][q[head]]-s[q[head]]<=a[j]*(q[head+1]-q[head])) head++;
			dp[i][j]=j*a[j]-s[j]+dp[i-1][q[head]]+s[q[head]]-a[j]*q[head];
			while(head<tail && (dp[i-1][q[tail]]+s[q[tail]]-dp[i-1][q[tail-1]]-s[q[tail-1]])*(j-q[tail])>=
			(dp[i-1][j]+s[j]-dp[i-1][q[tail]]-s[q[tail]])*(q[tail]-q[tail-1])) tail--;
			q[++tail]=j;
//			for(int k=0;k<j;k++)
//				dp[i][j]=min(dp[i][j],dp[i-1][k]+(j-k)*a[j]-s[j]+s[k]);
		}
	}
	cout<<dp[p][m];
	return 0;
}
```

# 附录

放下那道题。

如果 $dp$ 中 $b$ 不有序呢？

这样，队头就不是最优策略了。

需要枚举呀！但是时复会退化。

我们需要第一个 $\dfrac{y_{q_{i+1}}-y_{q_i}}{x_{q_{i+1}}-x_{q_i}} > b$ 的 $i$。

因为队尾维护着的呢！

所以 $\dfrac{y_{q_{i+1}}-y_{q_i}}{x_{q_{i+1}}-x_{q_i}}$ 单调。

在凸壳里二分即可。

习题：

[Acwing301](https://www.acwing.com/problem/content/description/303/)。

[Acwing302](https://www.acwing.com/problem/content/description/304/)。

习题讲解：

第一题，首先想到 $O(n^3)$，不用多讲，$dp_{i,j}$ 表示前 $i$ 个任务分为 $j$ 批。

发现需要 $j$ 的理由是要计算~~原神~~机器启动了几次，所以尝试**费用提前计算**。

每次将后面的启动时间全部累加完，这样可以 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
int sc[5010],st[5010];
int dp[5010];
signed main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int c,t;
		cin>>t>>c;
		sc[i]=sc[i-1]+c,st[i]=st[i-1]+t;
	}
	dp[0]=0;
	for(int i=1;i<=n;i++){
		dp[i]=1e15;
		for(int j=0;j<i;j++)//以 [j+1,i] 作为 1 批 
			dp[i]=min(dp[i],dp[j]+st[i]*(sc[i]-sc[j])+m*(sc[n]-sc[j]));
	}
	cout<<dp[n];
	return 0;
}
```

然后直接斜优。

第二题可以二分斜优。

---

## 作者：aCssen (赞：2)

### Solution

设 $f_i$ 表示前 $i$ 个任务的最小费用。记 $T$ 为 $t$ 的前缀和，$S$ 为 $C$ 的前缀和。

那么我们有 $f_i=\min_{0 \le j<i} f_j+s(S_n-S_j)+T_i(S_i-S_j)$

含义是我们枚举一个 $j$，让 $(j,i]$ 这一段任务同一批执行，那么因为又多执行了一次，$(j,n]$ 中的任务完成时间**全部往后了 $s$ 时间**，提前计算这一部分导致答案的增量，也就是 $s(S_n-S_j)$。因为提前计算了 $s$ 的部分，所以后面就可以当做没有启动时间来计算。

考虑优化这个式子，先把无关的项拉出来，那么

$$f_i=sS_n+T_iS_i+\min_{0 \le j<i} f_j-sS_j-T_iS_j$$

显然只有后面的部分有用，因为存在 $i,j$ 有关的乘积项，考虑斜率优化。

考虑 $j_1<j_2$，且 $j_1$ 不劣于 $j_2$ 的条件是 $f_{j_1}-sS_{j_1}-T_iS_{j_1} \le f_{j_2}-sS_{j_2}-T_iS_{j_2}$

那么也就是 $f_{j_1}-sS_{j_1}-(f_{j_2}-sS_{j_2})  \le T_i(S_{j_1}-S_{j_2})$

记 $F(j)=f_j-sS_j$，那么就是

$F(j_1)-F(j_2) \le T_i(S_{j_1}-S_{j_2})$

注意 $j_1 <j_2$，$S$ 单调递增，那么 $S_{j_1}-S_{j_2}<0$

所以 $\frac{F(j_1)-F(j_2)}{S_{j_1}-S_{j_2}} \ge T_i$。如果满足这样的条件，那么选 $j_1$ 一定不会比选 $j_2$ 差。反之若不满足这个条件，那么 $j_1$ 一定不比 $j_2$ 好。

记 $slope(i,j)=\frac{F(j)-F(i)}{S_{j}-S_{i}}$。

那么考虑三个点 $l<mid<r$，若中间的点有用，那么必然满足 $slope(l,mid) \le T_i,slope(mid,r) \ge T_i$，也就是 $slope(l,mid) \le slope(mid,r)$，那就是说只有斜率单调递增的才是有用的，那么我们这样就有了一个下凸壳。用单调队列维护它，每次插入比较相邻个点的连线的斜率，比当前这组（即队尾与当前点）小的就删掉即可。

进行查询的时候，应该是先有一些连线斜率 $\le T_i$，这些连线的意思是选后面的点更优，同时因为 $T_i$ 单调，所以斜率超过 $T_i$ 的地方肯定是越来越靠后的，所以这些斜率 $\le T_i$ 的点可以直接删掉。找到第一个连线斜率 $\ge T_i$ 的点，它就是最优的。

注意开始时队列中已经有 $0$ 这个决策点。可能维护凸壳的过程的实现有些难以理解，建议结合代码理解。

有一个小地方就是，这个题直接 double 求斜率是可以过的，有的时候精度误差比较严重时建议将斜率的式子拆开进行比较，避免浮点数运算。
### Code
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
typedef long long ll;
namespace FastIO{
    template<typename T=int> T read(){
        T x=0;int f=1;char c=getchar();
        while(!isdigit(c)){if(c=='-') f=~f+1;c=getchar();}
        while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
        return x*f;
    }
    template<typename T> void write(T x){
        if(x<0){putchar('-');x=-x;}
        if(x>9) write(x/10);
        putchar(x%10+'0');
    }
    template<typename T> void Write(T x,char c='\n'){write(x);putchar(c);}
}
using namespace FastIO;
const int maxn=3e5+5;
int S[maxn],T[maxn],q[maxn],n,s;
ll f[maxn];
double F(int j){
    return f[j]-1.0*s*S[j];
}
double slope(int i,int j){
    return (F(j)-F(i))/(S[j]-S[i]);
}
int main(){
    n=read(),s=read();
    for(int i=1;i<=n;i++){
        T[i]=T[i-1]+read();
        S[i]=S[i-1]+read();
    }
    int head,tail;
    q[head=tail=1]=0;
    for(int i=1;i<=n;i++){
        while(head<tail&&slope(q[head],q[head+1])<=T[i]) head++;
        int j=q[head];f[i]=f[j]+1ll*s*(S[n]-S[j])+1ll*T[i]*(S[i]-S[j]);
        while(head<tail&&slope(q[tail-1],q[tail])>=slope(q[tail],i)) tail--;
        q[++tail]=i;
    }
    write(f[n]);
    return 0;
}
```

---

## 作者：Jadonyzx (赞：2)

斜率优化套二分板子题。

前缀和处理。

$C$ 数组表示 $c$ 的前缀和。

$T$ 数组表示 $t$ 的前缀和。

$dp_i$ 表示前 $i$ 个任务的最小花费。

有以下转移方程：

$dp_i=dp_j-(T_i+s)\times C_j+T_i\times C_i+s\times C_n$

显然为斜率优化，但考虑到 $T$ 不单调，转移时在单调队列上二分第一个满足斜率的决策点转移即可。

代码就不贴了。

---

## 作者：xiao7_Mr_10_ (赞：1)

哦豁，这个题找到了。同学说他 $O(n^2)$ 过去了难绷。

我们设 $f_i$ 表示前 $i$ 个任务的花费，考虑**费用提前计算**思想，我们把对后续有影响的机器的启动费用先算了。

有 $f_{i}= \min(f_j+t_i\times(c_i-c_j)+s\times(s_n-s_i))$。

其中数组 $c$ 和 $t$ 都是经过前缀和后的注意。 

这样你就可以通过弱化版 P2365 了，但是据说这题好像也能过。

不会斜率优化的请移步模板题。

我们显然化简后令注意到形如点 $(c_i,f_i)$ 然后斜率为 $s+t_i$ 的直线，然后暴力斜优即可。

这里用的是二分，个人习惯。也可以过加强版，时间复杂度 $O(n \log n)$。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
int n,f[N],sum1[N],sum2[N],tail,q[N],l;
inline int find(int x){
	int l1=1,r1=tail,ans=-1;
	while(l1<=r1){
		int mid=(l1+r1)>>1;
		if(f[q[mid+1]]-f[q[mid]]<(sum1[x]+l)*(sum2[q[mid+1]]-sum2[q[mid]]))l1=mid+1;
		else ans=mid,r1=mid-1;
	}
	if(ans==-1)return q[1];
	return q[ans];
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> l;
	for(int i = 1;i <= n;i++){
		cin >> sum1[i] >> sum2[i];
		sum1[i]+=sum1[i-1];
		sum2[i]+=sum2[i-1];
	}
	memset(f,0x3f,sizeof(f));
	q[++tail]=f[0]=0;
	for(int i = 1;i <= n;i++){
		int id=find(i);
		f[i]=f[id]+sum1[i]*(sum2[i]-sum2[id])+l*(sum2[n]-sum2[id]);
		while(tail>1&&(f[q[tail]]-f[q[tail-1]])*(sum2[i]-sum2[q[tail]])>=(f[i]-f[q[tail]])*(sum2[q[tail]]-sum2[q[tail-1]]))tail--;
		q[++tail]=i;
	}
	cout << f[n];
	return 0;
}
```

---

## 作者：ivyjiao (赞：1)

前置知识：

- 弱化版：[P2365 任务安排](https://www.luogu.com.cn/problem/P2365)。

- 单调队列优化 DP，模板：[P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)。

- 一次函数的相关知识。

- 凸包的相关知识。

- 斜率优化 DP 是什么？为什么要用它？

我们知道，单调队列优化 DP 的一般形式如下：

$$dp_i=\min_{j=1}^{j<i}\{dp_j+a_i\}$$

优化这个东西的原理也很简单，我们显然可以把关于 $i$ 的所有元素全部摘到 $\min$ 外：

$$dp_i=\min_{j=1}^{j<i}\{dp_j\}+a_i$$

然后构造一个从队头到队尾越来越大的单调队列，，把之前的每个 $dp_i$ 塞进去，每次取队头的元素进行赋值，从 $O(n^2)$ 优化到 $O(n)$。

但是单调队列优化 DP 面对这种式子就无能为力了：

$$dp_i=\min_{j=1}^{j<i}\{dp_j+a_i\times a_j\}$$

我们发现，我们不可以把关于 $i$ 的所有元素全部摘到 $\min$ 外，普通的单调队列优化 DP 失效了，这时候就需要用到斜率优化 DP。

所谓斜率优化 DP，就是把原式化成：

$$y=kx+b$$

的形式，其中 $k,b$ 只有与 $j$ 无关的东西，$x,y$ 只有与 $j$ 有关的东西。然后单调队列优化 DP 维护斜率的信息（每个 $(x,y)$），根据题目需要选择维护上凸包（$\max$）或下凸包（$\min$）。

懒得画图了，下面的口述一下吧。

接下来借助本题来理解一下这个算法。

由弱化版 P2365 可得：

$$dp_i=\min_{j=1}^{j<i}\{dp_j+s_i\times (w_i-w_j)+s\times (w_n-w_j)\}$$

其中 $s_i=\sum_{j=1}^{j<i} t_i,w_i=\sum_{j=1}^{j<i} c_i$。

很明显本题有 $\min$，要维护下凸包。

接下来我们通过分析样例讲解维护下凸包的过程。

首先化简式子。

我们把式子中的 $\min$ 去掉：

$$dp_i=dp_j+s_i\times (w_i-w_j)+s\times (w_n-w_j)$$

拆括号：

$$dp_i=dp_j+s_i\times w_i-s_i\times w_j+s\times w_n-s\times w_j$$

移项：

$$dp_j = s_i\times w_j+s\times w_j+dp_i-s_i\times w_i-s\times w_n$$

$$dp_j~~~~=~~~~(s_i+s)~~~~\times~~~~ w_j~~~~+~~~~dp_i-s_i\times w_i-s\times w_n$$

得到 $y=kx+b$ 的形式。

然后我们把每个 $(x,y)$ 求出，用它们求出斜率 $k$，然后用现在的 $k$ 和这个 $k$ 依次比较，由于本题 $k$ 单调，所以不优就踢掉（$k$ 不单调时不行），队尾加入的时候也是不优就踢掉，最后维护出单调队列。

注意：

1. 单调队列中应有至少有两个点再求斜率，建议使用手写队列，判断条件应为 $head<tail$ 而非 $head\leq tail$。

2. 维护上或下凸包比较斜率 $k$ 时不要直接除，容易被卡，建议用 double。

代码：

```cpp
//s[i]=Σt[i], w[i]=Σc[i], dp[i] = min(dp[j]+s[i]*(w[i]-w[j])+s*(w[n]-w[j]))
//dp[i] = dp[j]+s[i]*(w[i]-w[j])+s*(w[n]-w[j])
//dp[i] = dp[j]+s[i]*w[i]-s[i]*w[j]+s*w[n]-s*w[j]
//dp[i] = dp[j]+s[i]*w[i]-s[i]*w[j]+s*w[n]-s*w[j]
//dp[j] = s[i]*w[j]+s*w[j] + dp[i]-s[i]*w[i]-s*w[n]
//dp[j] = (s[i]+s) *w[j] + dp[i]-s[i]*w[i]-s*w[n]
//   y  =    k     *  x  +          b
//启动！
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,s,t[200001],c[200001],sum[200001],w[200001],dp[200001],q[200001];
int X(int j){
	return w[j];
}
int Y(int j){
	return dp[j];
}
double query(int i,int j){
	return 1.0*(Y(j)-Y(i))/(X(j)-X(i));
}
signed main(){
	cin>>n>>s;
	for(int i=1;i<=n;i++){
        cin>>t[i]>>c[i];
        sum[i]=sum[i-1]+t[i];
        w[i]=w[i-1]+c[i];
    }
    int h=0,t=0;
	for(int i=1;i<=n;i++){
		while(h<t&&query(q[h],q[h+1])<=sum[i]+s) h++;
		dp[i]=dp[q[h]]+sum[i]*(w[i]-w[q[h]])+s*(w[n]-w[q[h]]);
		while(h<t&&query(q[t-1],i)<=query(q[t-1],q[t])) t--;
		q[++t]=i;
	}
	cout<<dp[n];
}
```

---

## 作者：dvsfanjo (赞：0)

# 题解：P10979 任务安排 2

## 前言

斜率优化板子题，前不久 A 了写篇题解做纪念。~~（真是搞邪啊！）~~

## 什么是斜率优化

当得到形如 $f_i=\min_{j<i}(f_j+a_ib_j)$ 这样的 dp 转移式，我们可以使用斜率优化。

设决策点为 $j_0$ ，得一次函数解析式 $y=kx+b$ ，其中 $y=f_{j_0}$ ，$k=-a_i$ ， $x=b_{j_0}$ ， $b=f_i$

![](https://cdn.luogu.com.cn/upload/image_hosting/6640mpbk.png)

也就是说，想要 $f_i$ 即 $b$ 最小，我们需要一条经过任一个决策点斜率为 $-a_i$ 的直线的截距最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/kbzr4v05.png)

显然，决策点在这个下凸包上，于是乎我们需要维护这个凸包。

现在的主要问题变成了，如何 __维护凸包__ 以及如何 __决策__ 。

不难发现，凸包上的斜率是递增的，还要支持插入，使用单调栈维护（有一些题目规定 $i-j_0$ 的范围，就要用单调队列维护），当然有其他情况会用李超线段树或平衡树~~因为我不会所以~~就不讨论了。

因为凸包上斜率是递增的，所以可以在凸包上二分最优决策点。

大家可以去看看[视频](https://www.bilibili.com/video/BV1dKSJY5Ew5/?vd_source=694030302ddb67b01442a3299fb99e9e)。

## 思路

由于个人代码习惯，把 $t$ 数组命名成了 $a$ 数组，把 $c$ 数组命名成了 $b$ 数组，请见谅。

将 $a$ 和 $b$ 做前缀和后，由本题[弱化版](https://www.luogu.com.cn/problem/P2365)可得 DP 转移方程 $f_i=\min_{j<i}(f_j+a_i(b_i-b_j)+s(b_n-b_j))$ ，设转移点为 $j_0$ ，去掉常数，得到决策点 $j_0$ 的坐标 $(b_{j_0}, f_{j_0}-sb_{j_0})$ ，求最小值维护下凸包就可以了。

## 核心代码

二分求决策点：


```cpp
inline ll find(ll x) {
	ll l = 0, r = t - 1, res = -1;
	while (l <= r) {
		ll mid = (l + r) >> 1;
		if (f[q[mid + 1]] - b[q[mid + 1]] * s - f[q[mid]] + b[q[mid]] * s > x * (b[q[mid + 1]] - b[q[mid]])) {
			res = mid;
			r = mid - 1;
		} else {
			l = mid + 1;
		}
	}
	if (res == -1) return q[t];
	return q[res];
}
```

单调栈维护凸包和转移：


```
for (int i = 1; i <= n; i++) {
		ll j = find(a[i]);
		f[i] = f[j] + a[i] * (b[i] - b[j]) + s * (b[n] - b[j]);
		while (t > 0 && (f[q[t]] - b[q[t]] * s - f[q[t - 1]] + b[q[t - 1]] * s) * (b[i] - b[q[t]]) >= (f[i] - b[i] * s - f[q[t]] + b[q[t]] * s) * (b[q[t]] - b[q[t - 1]])) t--;
		q[++t] = i;
	}
```

---


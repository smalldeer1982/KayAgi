# [IOI 2024] 马赛克上色

## 题目背景

提交时请不要引用 `mosaic.h`。

请不要使用 C++14 (GCC 9) 提交。

## 题目描述

Salma 想给墙上的粘土马赛克上色。该马赛克由 $N \times N$ 片正方形瓷砖组成，共有 $N^2$ 片瓷砖；每片瓷砖的尺寸为 $1 \times 1$，都还没有上色。马赛克从上到下每行瓷砖的行编号从 $0$ 到 $N-1$，从左到右每列瓷砖的列编号从 $0$ 到 $N-1$。位于第 $i$ 行第 $j$ 列（$0 \leq i < N$，$0 \leq j < N$）的瓷砖记为 $(i,j)$。每片瓷砖要么涂成白色（记为 $0$），要么涂成黑色（记为 $1$）。

为了给马赛克上色，Salma 首先选取两个长度为 $N$ 的数组 $X$ 和 $Y$，每个数组都由 $0$ 和 $1$ 组成，并且 $X[0] = Y[0]$。她按照数组 $X$ 对最上面的行（第 $0$ 行）的瓷砖进行上色，使得瓷砖 $(0,j)$ 的颜色为 $X[j]$（$0 \leq j < N$）。她按照数组 $Y$ 对最左边的列（第 $0$ 列）的瓷砖进行上色，使得瓷砖 $(i,0)$ 的颜色为 $Y[i]$（$0 \leq i < N$）。

然后她重复以下步骤直至所有瓷砖都上色完成：
* 她找到任意一片**没有上色**的瓷砖 $(i,j)$，其上方相邻的瓷砖 $(i-1, j)$ 和左边相邻的瓷砖 $(i, j-1)$ 都**已经上色**。
* 然后，如果这两片相邻的瓷砖都是白色，她会把瓷砖 $(i,j)$ 涂成黑色；否则，涂成白色。

可以证明，瓷砖最终的颜色不依赖于 Salma 的上色顺序。

Yasmin 对马赛克瓷砖的颜色非常好奇。她向 Salma 提出 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。在问题 $k$（$0 \leq k < Q$）中，Yasmin 通过以下信息指定马赛克中的一个长方形：
* 最上面的行 $T[k]$ 和最下面的行 $B[k]$（$0 \leq T[k] \leq B[k] < N$）；
* 最左边的列 $L[k]$ 和最右边的列 $R[k]$（$0 \leq L[k] \leq R[k] < N$）。

问题的答案是该长方形中黑色瓷砖的数量。具体来说，Salma 应当找出有多少片瓷砖 $(i,j)$ 满足  $T[k] \leq i \leq B[k]$，$L[k] \leq j \leq R[k]$，且颜色为黑色。

请编写程序回答 Yasmin 的问题。

### 实现细节

你要实现以下函数。

```
std::vector<long long> mosaic(
	std::vector<int> X, std::vector<int> Y,
    std::vector<int> T, std::vector<int> B,
    std::vector<int> L, std::vector<int> R)
```

* $X$，$Y$：长度为 $N$ 的数组，分别描述最上方行和最左边列的瓷砖的颜色。
* $T$，$B$，$L$，$R$：长度为 $Q$ 的数组，分别描述 Yasmin 所提出的问题。
* 该函数应返回一个长度为 $Q$ 的数组 $C$，使得 $C[k]$ 给出问题 $k$（$0 \leq k < Q$）的答案。
* 对每个测试用例，该函数恰好被调用一次。

## 说明/提示

考虑以下函数调用。

```
mosaic([1, 0, 1, 0], [1, 1, 0, 1], [0, 2], [3, 3], [0, 0], [3, 2])
```

该例子如下图所示。左边的图展示了马赛克中瓷砖的颜色，中间和右边的图分别展示了 Yasmin 的第一个问题和第二个问题中的长方形。

![](https://cdn.luogu.com.cn/upload/image_hosting/dhy83fvl.png "550")

这两个问题的答案（即阴影长方形中 1 的个数）分别是 7 和 3。因此，函数应该返回 $[7, 3]$。

### 约束条件

* $1 \leq N \leq 200\,000$
* $1 \leq Q \leq 200\,000$
* 对所有满足  $0 \leq i < N$ 的 $i$，都有 $X[i] \in \{0, 1\}$，且 $Y[i] \in \{0, 1\}$
* $X[0] = Y[0]$
* 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $0 \leq T[k] \leq B[k] < N$，且 $0 \leq L[k] \leq R[k] < N$

| 子任务 | 分数 | 额外的约束条件 |
| :-----: | :----: | ---------------------- |
| 1       | $5$    | $N \leq 2; Q \leq 10$
| 2       | $7$    | $N \leq 200; Q \leq 200$
| 3       | $7$    | 对所有满足  $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k] = 0$
| 4       | $10$   | $N \leq 5000$
| 5       | $8$    | 对所有满足 $0 \leq i < N$ 的 $i$，都有 $X[i] = Y[i] = 0$
| 6       | $22$   | 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k]$，且 $L[k] = R[k]$
| 7       | $19$   | 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k]$ 
| 8       | $22$   | 没有额外的约束条件。

## 样例 #1

### 输入

```
4
1 0 1 0
1 1 0 1
2
0 3 0 3
2 3 0 2
```

### 输出

```
7
3
```

# 题解

## 作者：Undead2008 (赞：5)

这个生成方式不好刻画，考虑打表观察答案网格的性质。

打表可以发现对于大部分的 $(i,j)$，$(i,j)$ 和 $(i-1,j-1)$ 的颜色相同。事实上对于所有 $i,j\ge 4$，该性质成立。

![](https://cdn.luogu.com.cn/upload/image_hosting/noqeap11.png)

证明一下。考虑对一个 $4\times 4$ 的网格标号，如上图。我们想要证明 $\tt 1$ 格子和 $\tt 2$ 格子的颜色总是相等，不妨先考虑不等的情况：

- $\tt 1$ 格子为黑色，$\tt 2$ 格子为白色：得出 $\tt 3$ 格子和 $\tt 4$ 格子均为白色，$\tt 2$ 格子理应为黑色，推出矛盾；
- $\tt 1$ 格子为白色，$\tt 2$ 格子为黑色：得出 $\tt 3$ 格子和 $\tt 4$ 格子均为白色，$\tt A$ 格子均为黑色，$\tt B$ 格子均为白色，$\tt 1$ 格子理应为黑色，推出矛盾。

所以 $\tt 1$ 格子和 $\tt 2$ 格子颜色总是相等，证明了上述结论。

所以我们暴力做前三行和前三列，之后的格子颜色都可以推出，查询时是一个等差序列求和，分讨一下即可。

```cpp
#include"bits/stdc++.h"
using namespace std;
#define L long long
const int maxN = 200010;
const int B = 3;
int n,q,a[B+2][maxN],b[maxN][B+2];
int Mex[2][2];
inline int Geta(int Xl,int Yl,int Xr,int Yr){
	return a[Xr][Yr]-a[Xl-1][Yr]-a[Xr][Yl-1]+a[Xl-1][Yl-1];
}
inline int Getb(int Xl,int Yl,int Xr,int Yr){
	return b[Xr][Yr]-b[Xl-1][Yr]-b[Xr][Yl-1]+b[Xl-1][Yl-1];
}
int Id[maxN<<1],Idx;
L Su[maxN<<1],Sl[maxN<<1],Sr[maxN<<1];
inline L Cl(int l,int r){
	return (Sl[r]-Sl[l-1])-(Su[r]-Su[l-1])*(l-1);
}
inline L Cr(int l,int r){
	return (Sr[r]-Sr[l-1])-(Su[r]-Su[l-1])*(Idx-r);
}
inline int Origin(int X,int Y){
	int Dl=min(X-B,Y-B);
	X-=Dl,Y-=Dl;
	if(Y==B)return n-X+1;
	return n-B+1+Y-B;
}
inline L Solve(int Xl,int Yl,int Xr,int Yr){
	int Lb=Origin(Xr,Yl),Rb=Origin(Xl,Yr),Ln=min(Xr-Xl+1,Yr-Yl+1);
	return Cl(Lb,Lb+Ln-1)+(Su[Rb-Ln+1]-Su[Lb+Ln-1])*Ln+Cr(Rb-Ln+2,Rb);
}
vector<L> mosaic(vector<int> Xo,vector<int> Yo,vector<int> To,vector<int> Bo,vector<int> Lo,vector<int> Ro){
	n=Xo.size(),q=To.size();
	Mex[0][0]=1;
	vector<L>Ans;
	for(int i=1;i<=n;i++)a[1][i]=Xo[i-1];
	for(int j=1;j<=min(B,n);j++)a[j][1]=Yo[j-1];
	for(int j=B+1;j<=n;j++)b[j][1]=Yo[j-1];
	for(int i=2;i<=B;i++)
		for(int j=2;j<=n;j++)
			a[i][j]=Mex[a[i][j-1]][a[i-1][j]];
	for(int i=B+1;i<=n;i++)
		for(int j=2;j<=B;j++)
			b[i][j]=Mex[b[i][j-1]][(i==B+1?a[i-1][j]:b[i-1][j])];
	for(int j=n;j>B;j--)Su[++Idx]=b[j][B];
	for(int j=B;j<=n;j++)Su[++Idx]=a[B][j];
	for(int i=1;i<=Idx;i++)Sl[i]=Sl[i-1]+i*Su[i];
	for(int i=1;i<=Idx;i++)Sr[i]=Sr[i-1]+(Idx-i+1)*Su[i];
	for(int i=1;i<=Idx;i++)Su[i]=Su[i-1]+Su[i];
	for(int i=1;i<=B;i++)
		for(int j=1;j<=n;j++)
			a[i][j]=a[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];
	for(int i=B+1;i<=n;i++)
		for(int j=1;j<=B;j++)
			b[i][j]=b[i][j]+b[i-1][j]+b[i][j-1]-b[i-1][j-1];
	for(int i=1,Xl,Yl,Xr,Yr;i<=q;i++){
		Xl=To[i-1]+1,Yl=Lo[i-1]+1,Xr=Bo[i-1]+1,Yr=Ro[i-1]+1;
		if(Xr<=B)Ans.push_back(Geta(Xl,Yl,Xr,Yr));
		else if(Xl>B&&Yr<=B)Ans.push_back(Getb(Xl,Yl,Xr,Yr));
		else if(Yr<=B)Ans.push_back(Getb(B+1,Yl,Xr,Yr)+Geta(Xl,Yl,B,Yr));
		else{
			int A=0;
			if(Xl<=B)A+=Geta(Xl,Yl,B,Yr),Xl=B+1;
			if(Yl<=B)A+=Getb(Xl,Yl,Xr,B),Yl=B+1;
			Ans.push_back(A+Solve(Xl,Yl,Xr,Yr));
		}
	}
	return Ans;
}
```
主函数部分~~是直接从题目附件里贺的~~：
```cpp
#ifndef ONLINE_JUDGE
int main() {
  int N;
  assert(1 == scanf("%d", &N));
  std::vector<int> Xo(N), Yo(N);
  for (int i = 0; i < N; i++)
    assert(1 == scanf("%d", &Xo[i]));
  for (int i = 0; i < N; i++)
    assert(1 == scanf("%d", &Yo[i]));
  int Q;
  assert(1 == scanf("%d", &Q));
  std::vector<int> To(Q), Bo(Q), Lo(Q), Ro(Q);
  for (int k = 0; k < Q; k++)
    assert(4 == scanf("%d%d%d%d", &To[k], &Bo[k], &Lo[k], &Ro[k]));
  fclose(stdin);

  std::vector<long long> Co = mosaic(Xo, Yo, To, Bo, Lo, Ro);

  int S = (int)Co.size();
  for (int k = 0; k < S; k++)
    printf("%lld\n", Co[k]);
  fclose(stdout);

  return 0;
}
#endif
```

---

## 作者：Petit_Souris (赞：3)

ez，IOI 24 D2 签到。

打个表，发现很快就出现规律了！看起来很像是一些像右下延申的斜线。

我们证明一下这个事情是对的：

![](https://cdn.luogu.com.cn/upload/image_hosting/1cw95kib.png)

- 若 $A$ 黑，那么 $B, C$ 白，则 $D$ 黑，$A = D$。
- 若 $A$ 白，假设 $D$ 黑。那么 $B, C$ 白，蓝色阴影是黑色，橙色阴影是白色，那么 $A$ 应当是黑，矛盾。

因此只要左上角有一个 $3\times 3$，对角线就都是同色的。

我们暴力跑出前三行三列的结果，找到所有的斜线。把询问差分成四个 2 - side 矩形。

以左边界出发的斜线为例。如果有一个 $(i, 3)$ 出发的全黑斜线，那么对询问 $(x, y)$ 的贡献为 $\min(x - i +  1, y - 2)$。显然是个分段函数，维护一下前缀和就好了。

时间复杂度 $\mathcal O(n)$。~~这里一开始幽默写了个树状数组，但是问题显然是静态的。相信是个人类都会反应过来，除了我。~~

```cpp
#include <bits/stdc++.h>
#include "mosaic.h"
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define pii pair<ll, ll>
#define rep(i, a, b) for(ll i = (a); i <= (b); ++i)
#define per(i, a, b) for(ll i = (a); i >= (b); --i)
#define pb push_back
const int maxN = 2e5 + 9;
int N, v1[3][maxN], v2[maxN][3], s1[3][maxN], s2[maxN][3];
int calc(int x, int y) {
    return (x + y == 0);
}
ll row1[maxN], row2[maxN], col1[maxN], col2[maxN];
ll Query(int x, int y) {
    if(x < 0 || y < 0) return 0;
    if(x <= 2) return s1[x][y];
    if(y <= 2) return s2[x][y];
    ll ans = s1[2][y] + s2[x][2] - s1[2][2];
    int lim = x - y + 2, cnt = (lim >= 0 ? row1[lim] : 0);
    ans += 1ll * cnt * (y - 2);
    cnt = row1[x] - cnt;
    ll sum = row2[x] - (lim >= 0 ? row2[lim] : 0);
    ans += 1ll * cnt * (x + 1) - sum;
    lim = y - x + 2, cnt = (lim >= 0 ? col1[lim] : 0);
    ans += 1ll * cnt * (x - 2);
    cnt = col1[y] - cnt;
    sum = col2[y] - (lim >= 0 ? col2[lim] : 0);
    ans += 1ll * cnt * (y + 1) - sum;
    return ans;
}
Ve<ll> mosaic(Ve<int> X, Ve<int> Y, Ve<int> T, Ve<int> B, Ve<int> L, Ve<int> R) {
    N = X.size();
    memset(v1, -1, sizeof(v1));
    memset(v2, -1, sizeof(v2));
    rep(i, 0, N - 1) {
        v1[0][i] = X[i], v2[i][0] = Y[i];
        if(i <= 2) v2[0][i] = X[i], v1[i][0] = Y[i];
    }
    rep(i, 0, 2) {
        rep(j, 0, N - 1) {
            if(~v1[i][j]) continue;
            v1[i][j] = calc(v1[i - 1][j], v1[i][j - 1]);
        }
    }
    rep(i, 0, N - 1) {
        rep(j, 0, 2) {
            if(~v2[i][j]) continue;
            v2[i][j] = calc(v2[i - 1][j], v2[i][j - 1]);
        }
    }
    rep(i, 0, 2) {
        rep(j, 0, N - 1) {
            s1[i][j] = v1[i][j];
            if(i) s1[i][j] += s1[i - 1][j];
            if(j) s1[i][j] += s1[i][j - 1];
            if(i && j) s1[i][j] -= s1[i - 1][j - 1];
        }
    } 
    rep(i, 0, N - 1) {
        rep(j, 0, 2) {
            s2[i][j] = v2[i][j];
            if(i) s2[i][j] += s2[i - 1][j];
            if(j) s2[i][j] += s2[i][j - 1];
            if(i && j) s2[i][j] -= s2[i - 1][j - 1];
        }
    }
    if(N >= 4) {
        rep(i, 3, N - 1) {
            if(!v2[i - 1][2]) continue;
            ++row1[i], row2[i] += i;
        }
        rep(i, 4, N - 1) {
            if(!v1[2][i - 1]) continue;
            ++col1[i], col2[i] += i;
        }
        rep(i, 1, N - 1) {
            row1[i] += row1[i - 1], row2[i] += row2[i - 1];
            col1[i] += col1[i - 1], col2[i] += col2[i - 1];
        }
    }
    int Q = T.size();
    Ve<ll> ans(Q);
    rep(i, 0, Q - 1) ans[i] = Query(B[i], R[i]) - Query(T[i] - 1, R[i]) - Query(B[i], L[i] - 1) + Query(T[i] - 1, L[i] - 1);
    return ans;
}
```

---

## 作者：qnqfff (赞：3)

### 思路

先打表，发现 $\forall i,j \ge 4,a_{i,j}=a_{i-1,j-1}$。

于是可是将原矩阵拆成4个矩阵，即左上角一个 $4 \times 4$ 的矩阵 $A$，右上角一个 $4 \times n$ 的矩阵 $B$，左下角一个 $n \times 4$ 的矩阵 $C$，右下角一个 $(n-4) \times (n-4)$ 的矩阵 $D$。

考虑如何算答案，$A$ 的答案显然可以直接暴力算，$B$ 和 $C$ 的可以直接二维前缀和，对于 $D$，设 $f_{x,y}$ 表示 $(5,5)$ 到 $(x,y)$ 这个子矩阵的答案，显然最后的询问可以二维差分，现在问题变成如何求 $f_{x,y}$。

考虑通过算每条斜线来计算答案，则 $f_{x,y} = (\sum\limits_{i=5}^{y}a_{5,i}\cdot\min(x-4,y-i+1))+(\sum\limits_{i=5}^{x}a_{i,5}\cdot\min(x-i+1,y-4))$，考虑单独将第5行和第5列来出来，设 $cnt_x=\sum\limits_{i=5}^{x}a_{5,i}$，$sum_x=\sum\limits_{i=5}^{x}a_{5,i}\cdot i$，$\_cnt_x=\sum\limits_{i=5}^{x}a_{i,5}$，$\_sum_x=\sum\limits_{i=5}^{x}a_{i,5}\cdot i$。

显然存在一个分界点使得前一部分最小值取前者而后一部分取后者，可以分开算，对于 $x$ 和 $y$ 的大小关系分类讨论一下。

1. $x\le y$。

$f_{x,y}=(cnt_{y-x+5}-cnt_4)\cdot (x-4)+(cnt_y-cnt_{y-x+5})\cdot (y+1)-(sum_y-sum_{y-x+5})+(\_cnt_x-\_cnt_5)\cdot (x+1)-(\_sum_x-\_sum_5)$。

2. $x\ge y$。

$f_{x,y}=(cnt_y-cnt_4)\cdot (y+1)-(sum_y-sum_4)+(\_cnt_{x-y+5}-\_cnt_5)\cdot (y-4)+(\_cnt_x-\_cnt_{x-y+5})\cdot (x+1)-(\_sum_x-\_sum_{x-y+5})$。

然后你就做完了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){int p=0,flg=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,m,a[5010][5010],b[5][200010],c[200010][5],__b[200010],__c[200010];long long _b[5][200010],_c[200010][5],cnt[200010],sum[200010],_cnt[200010],_sum[200010];
std::vector<long long>mosaic(std::vector<int>X,std::vector<int>Y,std::vector<int>T,std::vector<int>B,std::vector<int>L,std::vector<int>R){
	n=X.size();m=T.size();
	if(n<=4){
		for(int i=1;i<=n;i++) a[1][i]=X[i-1],a[i][1]=Y[i-1];for(int i=2;i<=n;i++) for(int j=2;j<=n;j++) a[i][j]=!(a[i-1][j]|a[i][j-1]);
		vector<long long>ans;for(int i=0;i<m;i++){int res=0;for(int x=T[i];x<=B[i];x++) for(int y=L[i];y<=R[i];y++) res+=a[x+1][y+1];ans.push_back(res);}return ans;
	}for(int i=1;i<=4;i++) a[1][i]=X[i-1],a[i][1]=Y[i-1];for(int i=2;i<=4;i++) for(int j=2;j<=4;j++) a[i][j]=!(a[i-1][j]|a[i][j-1]);
	for(int i=1;i<=4;i++) b[i][4]=a[i][4];for(int i=5;i<=n;i++) b[1][i]=X[i-1],_b[1][i]=_b[1][i-1]+b[1][i];
	for(int i=2;i<=4;i++) for(int j=5;j<=n;j++) b[i][j]=!(b[i-1][j]|b[i][j-1]),_b[i][j]=_b[i-1][j]+_b[i][j-1]-_b[i-1][j-1]+b[i][j];
	auto _B=[&](int x,int _x,int y,int _y){return _b[_x][_y]-_b[x-1][_y]-_b[_x][y-1]+_b[x-1][y-1];};
	for(int i=1;i<=4;i++) c[4][i]=a[4][i];for(int i=5;i<=n;i++) c[i][1]=Y[i-1],_c[i][1]=_c[i-1][1]+c[i][1];
	for(int i=5;i<=n;i++) for(int j=2;j<=4;j++) c[i][j]=!(c[i-1][j]|c[i][j-1]),_c[i][j]=_c[i-1][j]+_c[i][j-1]-_c[i-1][j-1]+c[i][j];
	auto _C=[&](int x,int _x,int y,int _y){return _c[_x][_y]-_c[x-1][_y]-_c[_x][y-1]+_c[x-1][y-1];};
	__b[4]=c[5][4];for(int i=5;i<=n;i++) __b[i]=!(b[4][i]|__b[i-1]),cnt[i]=cnt[i-1]+__b[i],sum[i]=sum[i-1]+__b[i]*i;
	__c[4]=b[4][5];for(int i=5;i<=n;i++) __c[i]=!(__c[i-1]|c[i][4]),_cnt[i]=_cnt[i-1]+__c[i],_sum[i]=_sum[i-1]+__c[i]*i;
	auto D=[&](int x,int y){
		if(x<5||y<5) return 0ll;
		if(x<=y){return (cnt[y-x+5]-cnt[4])*(x-4)+(cnt[y]-cnt[y-x+5])*(y+1)-(sum[y]-sum[y-x+5])+(_cnt[x]-_cnt[5])*(x+1)-(_sum[x]-_sum[5]);}
		else{return (cnt[y]-cnt[4])*(y+1)-(sum[y]-sum[4])+(_cnt[x-y+5]-_cnt[5])*(y-4)+(_cnt[x]-_cnt[x-y+5])*(x+1)-(_sum[x]-_sum[x-y+5]);}
	};auto calc=[&](int x,int _x,int y,int _y){return D(_x,_y)-D(x-1,_y)-D(_x,y-1)+D(x-1,y-1);};
	vector<long long>ans;for(int i=0;i<m;i++){
		long long res=0;for(int x=T[i];x<=min(3,B[i]);x++) for(int y=L[i];y<=min(3,R[i]);y++) res+=a[x+1][y+1];
		if(T[i]<=3&&3<R[i]) res+=_B(T[i]+1,min(3,B[i])+1,max(4,L[i])+1,R[i]+1);
		if(L[i]<=3&&3<B[i]) res+=_C(max(4,T[i])+1,B[i]+1,L[i]+1,min(3,R[i])+1);
		if(3<B[i]&&3<R[i]) res+=calc(max(4,T[i])+1,B[i]+1,max(4,L[i])+1,R[i]+1);ans.push_back(res);
	}return ans;
}
```

---

## 作者：jiamengtong (赞：2)

正面推理做法。

对于这种“做变换”的题目，一般的套路是将式子中的值不断带入，观察性质。这一题也可以同样这么做。

记 $a_{i,j}$ 为 $i$ 行 $j$ 列的格子的颜色（白为 $0$，黑为 $1$）。根据题意，我们有 $a_{i,j}=!(a_{i-1,j}|a_{i,j-1})$。使用套路，将 $a_{i-1,j}$ 和 $a_{i,j-1}$ 分别带入，可以得到 $a_{i,j}=![!(a_{i-1,j-1}|a_{i-2,j})|!(a_{i-1,j-1}|a_{i,j-2})]$。观察到这个式子实际上就是 $a_{i,j}=(a_{i-1,j-1}|a_{i-2,j})\&(a_{i-1,j-1}|a_{i,j-2})$。

于是有两种情况。如果 $a_{i-1,j-1}=1$，那么 $a_{i,j}=1$。否则 $a_{i,j}=1$ 当且仅当 $a_{i-2,j}=a_{i,j-2}=1$。对于第一种情况，这相当于是一个 $1$ 可以将它右下方的斜线完全覆盖。第二种情况，相当于是两个斜线中间会夹出一条斜线（这个夹出来的斜线会在上端点处短一格）。容易知道我们只考虑这两种情况是对的，并且不可能有其他转移的情况。

这样这个题就结束了。把前三行预处理一下，随便查询就好了。

---

## 作者：Zzzcr (赞：2)

先给出结论：$\forall i,j\ge4,a_{i-1,j-1}=a_{i,j}$。

先忽略一些边界情况。假设 $a_{i,j}=1$，容易发现 $a_{i+1,j}=a_{i,j+1}=0$，即 $a_{i+1,j+1}=1$。换句话说：在大部分情况下，$1$ 的分布是若干条斜线。而 $0$ 的位置是 $1$ 的位置的补集，同样是若干条斜线。

我们可以先暴力求出前三行三列，并用第三行和第三列求出剩余 $O(n)$ 条斜线的值，再进行一些分类讨论即可，时空复杂度 $O(N+Q)$。

给出部分核心代码：

```cpp
vector<long long> mosaic(vector<int> X, vector<int> Y, vector<int> T, vector<int> B, vector<int> L, vector<int> R) {
    n = X.size(), Q = T.size();
    vector<ll> C(Q, 0);

    // Write n = 1, 2 case here.

    for(int v : X) mp[0].emplace_back(v);
    _f(i, 1, n - 1) mp[i].emplace_back(Y[i]);
    _f(i, 1, 2) _f(j, 1, n - 1) mp[i].emplace_back(vl(mp[i][j - 1], mp[i - 1][j]));
    _f(i, 3, n - 1) _f(j, 1, 2) mp[i].emplace_back(vl(mp[i][j - 1], mp[i - 1][j]));

    // the value of the diagonal $j-i=k$ is $is_{n+k}$ (0 or 1)
    // pre : the prefix suf of $is_i$
    // prei : the prefix sum of $i\cdot is_i$
    _f(i, 0, n - 3) is[n - i] = mp[2][i + 2];
    _f(i, 1, n - 3) is[n + i] = mp[2 + i][2];
    _f(i, 3 - n, n - 3) pre[i + n] = pre[i + n - 1] + is[i + n], prei[i + n] = prei[i + n - 1] + is[i + n] * i;

    // Calculate the prefix sum of the square boundary
    _f(i, 1, n - 1) mp[0][i] += mp[0][i - 1];
    mp[1][0] += mp[0][0];
    _f(i, 1, n - 1) mp[1][i] = mp[1][i] + mp[0][i] + mp[1][i - 1] - mp[0][i - 1];
    _f(i, 2, n - 1) mp[i][0] += mp[i - 1][0], mp[i][1] = mp[i][1] + mp[i - 1][1] + mp[i][0] - mp[i - 1][0];

    auto getval = [&](int x, int y) -> ll {
        if(x < 0 || y < 0) return 0;
        return mp[x][y];
    } ;
    auto corner_query = [&](int a, int b, int c, int d) -> ll {
        assert(a <= c && b <= d && (c <= 1 || d <= 1));
        return getval(c, d) + getval(a - 1, b - 1) - getval(a - 1, d) - getval(c, b - 1);
    } ;

    auto calc = [&](int x, int y) -> ll {
        if(x >= n || y >= n) return 0;
        ll ret = 0;
        if(x <= 1 && y > 1) ret += corner_query(x, y, 1, n - 1), x = 2;
        else if(y <= 1 && x > 1) ret += corner_query(x, y, n - 1, 1), y = 2;
        else if(x <= 1 && y <= 1) ret += corner_query(x, 2, 1, n - 1) + corner_query(2, y, n - 1, 1) + corner_query(x, y, 1, 1), x = y = 2;
        if(x >= n || y >= n) return ret;

        // Case 1: (i >= 0)

        int mx = 2 * n - max(y + 1, 3);
        ret += 1ll * n * (pre[mx] - pre[n - 1]);
        if(y >= x) {
            ret -= 1ll * y * (pre[mx] - pre[n - 1]);
            ret -= prei[mx] - prei[n - 1];
        } else if(y + n - 3 <= x) {
            ret -= 1ll * x * (pre[mx] - pre[n - 1]);
        } else {
            ret -= 1ll * x * (pre[x - y + n] - pre[n - 1]);
            ret -= prei[mx] - prei[x - y + n];
            ret -= 1ll * y * (pre[mx] - pre[x - y + n]);
        }

        // Case 2: (i < 0)

        if(x >= y - 1) ret += 1ll * (pre[n - 1] - pre[x]) * (n - x) + (prei[n - 1] - prei[x]);
        else if(y + 3 - n >= x) ret += 1ll * pre[n - 1] * (n - y);
        else {
            ret += 1ll * (pre[n - 1] - pre[x - y - 1 + n]) * (n - y);
            ret += 1ll * (pre[x - y - 1 + n] - pre[x]) * (n - x) + (prei[x - y - 1 + n] - prei[x]);
        }
        
        return ret;
    } ;
    _f(i, 0, Q - 1) {
        int t = T[i], b = B[i], l = L[i], r = R[i];
        C[i] = calc(t, l) + calc(b + 1, r + 1) - calc(t, r + 1) - calc(b + 1, l);
    }
    return C;
}
```

---

## 作者：Purslane (赞：0)

# Solution

一道比较简单的题目，来说说我是怎么自己发现规律并且做出来的。

我们分析一下最后图形的一些性质。设 $col_{i,j}$ 为第 $i$ 行第 $j$ 列的马赛克的颜色（我们从 $1$ 开始编号，$0$ 是白 $1$ 是黑）

1. $\forall i,j \ge 2$，$col_{i,j}col_{i+1,j} = col_{i,j}col_{i,j+1} = 0$（即，不存在相邻的黑格）。
2. 考虑第三行的格子，**最长连续白格不超过 $2$ 个**。第二行不存在连续黑格，考虑它的形态是若干个黑格里面插入了很多白段。再次移动到第三行，显然不会出现 $3$ 个连续白格（否则第二行会对应相邻黑格）。
3. 对于 $i,j \ge 3$，如果 $col_{i,j} = 1$，则 $col_{i+1,j+1} = 3$。这是因为，显然有 $col_{i+1,j} = col_{i,j+1} = 0$。
4. 对于 $i,j \ge 4$，如果 $col_{i,j} = 1$，则 $col_{i-1,j-1} = 1$。这是因为，必定有 $col_{i-1,j} = col_{i,j-1} = 0$。若 $col_{i-1,j-1}=0$，则 $col_{i-2,j} = 1$，得出 $col_{i-2,j-1}= 0$。因此第 $j-1$ 列有连续 $3$ 个白格，这已经与性质 $3$ 矛盾。

$3$ 和 $4$ 两个性质告诉我们：$\forall i,j \ge 4$，$col_{i,j} = col_{i-1,j-1}$。

因此我们可以暴力计算前 $3$ 行和前 $3$ 列，再把右下角的矩形按照斜线投影到 $x=3$ 和 $y=3$ 两条线上，用前缀和计算。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=200000+10;
ll n,q,xl[MAXN],xr[MAXN],yl[MAXN],yr[MAXN],colu[MAXN],cold[MAXN];
ll pre1[MAXN<<1],pre2[MAXN<<1],res[MAXN];
vector<ll> subtask(void) {
	int pre[5001][5001];
	memset(pre,0,sizeof(pre));
	ffor(i,1,n) pre[1][i]=colu[i];
	ffor(i,1,n) pre[i][1]=cold[i];
	ffor(i,2,n) ffor(j,2,n) if(!pre[i-1][j]&&!pre[i][j-1]) pre[i][j]=1;
	ffor(i,1,n) ffor(j,1,n) pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+pre[i][j];
	vector<ll> ans;
	ffor(i,1,q) ans.push_back(pre[xr[i]][yr[i]]-pre[xl[i]-1][yr[i]]-pre[xr[i]][yl[i]-1]+pre[xl[i]-1][yl[i]-1]);
	return ans;
}
vector<int> pre[MAXN];
ll PRE(int x,int y) {
	if(x<=3||y<=3) return pre[x][y];
	return pre[3][y]+pre[x][3]-pre[3][3];
}
ll calc(int a,int b,int c,int d,int len) {
	a+=n-2,b+=n-2,c+=n-2,d+=n-2;
	vector<ll> mzx={a,b,c,d};
	sort(mzx.begin(),mzx.end());
	ll ans=(pre1[mzx[3]]-pre1[mzx[0]-1])*len;
	ans-=mzx[1]*(pre1[mzx[1]]-pre1[mzx[0]-1])-(pre2[mzx[1]]-pre2[mzx[0]-1]);
	ans-=pre2[mzx[3]]-pre2[mzx[2]-1]-mzx[2]*(pre1[mzx[3]]-pre1[mzx[2]-1]);
	return ans;
}
vector<ll> mosaic(vector<int> X,vector<int> Y,vector<int> T,vector<int> B,vector<int> L,vector<int> R) {
	vector<ll> ans;
	n=X.size(),q=T.size();
	ffor(i,1,n) colu[i]=X[i-1];
	ffor(i,1,n) cold[i]=Y[i-1];
	ffor(i,1,q) xl[i]=T[i-1]+1,xr[i]=B[i-1]+1,yl[i]=L[i-1]+1,yr[i]=R[i-1]+1;
	if(n<=5000) return subtask(); //其实为了避免特殊情况 /oh
	ffor(i,0,3) pre[i].resize(n+1);
	ffor(i,4,n) pre[i].resize(4);
	ffor(i,1,n) pre[1][i]=colu[i];
	ffor(i,1,n) pre[i][1]=cold[i];
	ffor(i,2,3) ffor(j,2,n) if(!pre[i-1][j]&&!pre[i][j-1]) pre[i][j]=1;
	ffor(i,4,n) ffor(j,2,3) if(!pre[i-1][j]&&!pre[i][j-1]) pre[i][j]=1;
	ffor(i,3,n) pre1[i-3+n-2]=pre2[i-3+n-2]=pre[i][3];
	ffor(i,3,n) pre1[3-i+n-2]=pre2[3-i+n-2]=pre[3][i];
	ffor(i,1,n) if(i<=3) ffor(j,1,n) pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+pre[i][j];
	else ffor(j,1,3) pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+pre[i][j];
	ffor(i,1,q) res[i]=PRE(xr[i],yr[i])-PRE(xl[i]-1,yr[i])-PRE(xr[i],yl[i]-1)+PRE(xl[i]-1,yl[i]-1);
	ffor(i,1,n+n-5) pre1[i]=pre1[i-1]+pre1[i],pre2[i]=pre2[i-1]+i*pre2[i];
	ffor(i,1,q) {
		xl[i]=max(xl[i],4ll),yl[i]=max(yl[i],4ll);
		if(xl[i]>xr[i]||yl[i]>yr[i]) continue ;
		res[i]+=calc(xl[i]-yr[i],xr[i]-yr[i],xl[i]-yl[i],xr[i]-yl[i],min(xr[i]-xl[i]+1,yr[i]-yl[i]+1));
	}
	ffor(i,1,q) ans.push_back(res[i]);
	return ans;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P11053)

**题目大意**

> 给定 $n\times n$ 的 01 矩阵 $A$ 的第一行和第一列，定义 $A_{i,j}=1-A_{i-1,j}\times A_{i,j-1}$，$q$ 次询问 $A$ 的某个子矩阵的元素和。
>
> 数据范围：$n,q\le 2\times 10^5$。

**思路分析**

观察这个矩阵，发现如果 $A_{i,j}=1$ 那么 $A_{i+1,j},A_{i,j+1}=0$，从而 $A_{i+1,j+1}=1$，因此所有的 $1$ 构成若干向右下方的射线。

并且我们发现如果 $A_{i,j}=1,A_{i-1,j-1}=0$，那么可以推出 $A_{i,j}$ 左上角的矩形一定形如 $\begin{bmatrix}x&y&1\\z&0&0\\1&0&1\end{bmatrix}$。

此时 $y,z$ 中至少有一个 $1$，又因为连续的两个 $1$ 显然不能出现在第一行或第一列以外的地方。

因此这种情况只能出现在 $\min(i,j)\le 3$ 的位置，也就是前三行或前三列，那么暴力求出第三行和第三列，其中的每个 $1$ 都对应一条向右下方的射线，且不存在其他的 $1$。

对子矩形询问差分成一个以 $(1,1)$ 为左上角的询问 $(x,y)$，对于一条射线的起点 $(i,j)$，其对询问的贡献就是 $\max(0,\min(x-i,y-j))$。

先求出 $\sum \min(x-i,y-j)$，$\min(x-i,y-j)<0$ 的点一定是 $A_{3,j+1\sim n}$ 和 $A_{i+1\sim n,3}$ 范围内的点，后缀和即可。

时间复杂度 $\mathcal O((n+q)\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
typedef vector<int> vi;
const int MAXN=2e5+5;
int n,q,a[4][MAXN],b[MAXN][4],cl[MAXN],cr[MAXN];
ll dl[MAXN],dr[MAXN];
bool cmp(array<int,2> i,array<int,2> j) { return i[0]-i[1]<j[0]-j[1]; }
vector<ll> mosaic(vi X,vi Y,vi T,vi B,vi L,vi R) {
	n=X.size(),q=T.size();
	if(n<=3) {
		vector <vi> M(n,vi(n));
		M[0]=X;
		for(int i=1;i<n;++i) {
			M[i][0]=Y[i];
			for(int j=1;j<n;++j) M[i][j]=(M[i-1][j]|M[i][j-1])^1;
		}
		for(int i=0;i<n;++i) for(int j=1;j<n;++j) M[i][j]+=M[i][j-1];
		for(int i=1;i<n;++i) for(int j=0;j<n;++j) M[i][j]+=M[i-1][j];
		vector <ll> ans(q);
		for(int i=0;i<q;++i) {
			ans[i]=M[B[i]][R[i]];
			if(T[i]) ans[i]-=M[T[i]-1][R[i]];
			if(L[i]) ans[i]-=M[B[i]][L[i]-1];
			if(T[i]&&L[i]) ans[i]+=M[T[i]-1][L[i]-1];
		}
		return ans;
	}
	for(int i=1;i<=n;++i) a[1][i]=X[i-1],b[i][1]=Y[i-1];
	a[2][1]=Y[1],a[3][1]=Y[2],b[1][2]=X[1],b[1][3]=X[2];
	for(int o:{2,3}) for(int i=2;i<=n;++i) {
		a[o][i]=(a[o-1][i]|a[o][i-1])^1;
		b[i][o]=(b[i][o-1]|b[i-1][o])^1;
	}
	vector <array<int,2>> Z;
	for(int i=3;i<=n;++i) if(a[3][i]) Z.push_back({3,i}),++cl[i],dl[i]+=i;
	for(int i=4;i<=n;++i) if(b[i][3]) Z.push_back({i,3}),++cr[i],dr[i]+=i;
	for(int i=n;i>=1;--i) cl[i]+=cl[i+1],dl[i]+=dl[i+1],cr[i]+=cr[i+1],dr[i]+=dr[i+1];
	sort(Z.begin(),Z.end(),cmp);
	int k=Z.size();
	vector <ll> sl(k),sr(k);
	if(k) {
		sl[0]=Z[0][1];
		for(int i=1;i<k;++i) sl[i]=sl[i-1]+Z[i][1];
		sr[k-1]=Z[k-1][0];
		for(int i=k-2;~i;--i) sr[i]=sr[i+1]+Z[i][0];
	}
	for(int i=1;i<=3;++i) for(int j=1;j<=n;++j) a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1];
	for(int i=1;i<=n;++i) for(int j=1;j<=3;++j) b[i][j]+=b[i][j-1]+b[i-1][j]-b[i-1][j-1];
	auto qry=[&](int x,int y) -> ll {
		if(x<=3) return a[x][y];
		if(y<=3) return b[x][y];
		ll s=a[3][y]+b[x][3]-a[3][3];
		int i=upper_bound(Z.begin(),Z.end(),array<int,2>{x,y},cmp)-Z.begin();
		if(i>0) s+=1ll*i*y-sl[i-1];
		if(i<k) s+=1ll*(k-i)*x-sr[i];
		s+=dl[y]-1ll*y*cl[y];
		s+=dr[x]-1ll*x*cr[x];
		return s;
	};
	vector <ll> ans(q);
	for(int i=0;i<q;++i) ans[i]=qry(B[i]+1,R[i]+1)-qry(T[i],R[i]+1)-qry(B[i]+1,L[i])+qry(T[i],L[i]);
	return ans;
}
```

---


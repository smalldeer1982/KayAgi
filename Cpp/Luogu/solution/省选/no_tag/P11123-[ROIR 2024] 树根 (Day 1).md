# [ROIR 2024] 树根 (Day 1)

## 题目背景

翻译自 [ROIR 2024 D1T4](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day1.pdf)。

给定一棵由 $n$ 个节点构成的树和一个数 $k$。固定树中的某个节点 $s$，并令其为根。

将树的边定向从树根出发。换句话说，将边 $(u, v)$ 定向为 $u \to v$，如果在以 $s$ 为根时，节点 $u$ 是节点 $v$ 的父节点。在这种定向下，每个节点都可以从根到达。

定义节点 $v$ 到节点 $s$ 的距离为从 $s$ 到 $v$ 的最短路径上边的数量。定义节点 $s$ 的可达性为所有节点到节点 $s$ 的距离中的最大值。

## 题目描述

允许在树中增加不超过 $k$ 条额外的有向边。对于树中的每个节点 $s$，确定如果选择节点 $s$ 作为树根，能够达到的最小可达性是多少。

注意，在某些子任务中，只需要输出顶点编号为 $1$ 的答案。

## 说明/提示

下图给出了第一个样例的图片。虚线表示添加的边。对于顶点 $1$ 和 $2$，最小可达性为 $1$；对于顶点 $3$，$4$ 和 $5$，最小可达性为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ubpdvqtn.png)

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $5$ | $u_i=i,v_i=i+1,t=0$ |
| $2$ | $5$ | $k=1,n\le2000,t=0$ |
| $3$ | $10$ | $k=1,t=0$ |
| $4$ | $5$ | $u_i=i,v_i=i+1$ |
| $5$ | $5$ | $n\le16$ |
| $6$ | $10$ | $n\le50$ |
| $7$ | $10$ | $n\le400$ |
| $8$ | $10$ | $n\le2000$ |
| $9$ | $25$ | $n\times k\le50000$ |
| $10$ | $15$ | 无 |

对于 $100\%$ 的数据，$2 \leq n \leq 2 \times 10^5$，$1 \leq k \leq n - 1$，$n \times k \leq 2 \times 10^5$，$0 \leq t \leq 1$，$1 \leq u_i, v_i \leq n$。

## 样例 #1

### 输入

```
5 2 1
1 2
1 3
2 4
2 5```

### 输出

```
1 1 2 2 2```

## 样例 #2

### 输入

```
3 1 0
1 2
2 3```

### 输出

```
1```

# 题解

## 作者：phil071128 (赞：3)

> 给定一个 $n$ 个点的树，和一个数字 $k$，你要对每个 $rt=1\cdots n$ 解决如下的问题：
>
> - 允许格外添加 $k$ 条有向边，将 $rt$ 视作根的树“深度"最大值最小是多少。
>
> 因为变成图的形态，所以“深度”即最短路。
>
> $n\times k\le 2\times 10^5$。

考虑 $O(n^2\log )$ 的部分分咋做？

- $n=1000$：

  可以先二分答案，转换为判定性问题。那么从上往下做，如果一个点超过 $mid$ 就向 $mid$ 级祖先连边。但这样实际是不对的，考虑有一个点有多个儿子，而你可能会每个儿子向祖先连边，但这样不如仅这个点向祖先连一条边。

  行不通考虑从下往上做：如果一个点到根距离过大就连边，这样是正确的原因在于：**如果是自下而上贪心只需往父亲方向处理就可以了，自上而下考虑的儿子就多了，选错极容易对后面产生影响**。复杂度 $O(n^2\log n)$。

  原题和类似的题目：[Reset K Edges - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF1739D) [[AGC004D] Teleporter - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/AT_agc004_d)。

- $n=5000$：

  如何把 $\log$ 去掉？**集中注意力：相邻两个节点换根的答案绝对值之差不会超过 $1$**。因此只需要第一次进行二分 `check`，后面换根的时候只需要 check $ans+1,ans,ans-1$ 三个数即可。

考虑如何优化到正解，也就是 check 的复杂度必须与 $k$ 有关，或者 $k\log n$ 之类的：

重新思考 check 的过程，发现相当于每次找到一个最深的节点，然后找到其 $mid$ 级祖先，并删掉整棵子树。

> 事实上，贪心的标准思维过程应该是先建立偏序关系，然后根据这个偏序关系排序。这也是贪心正确性的证明，该过程称作 `exchange argument`：[大家好啊，我是贪心说的道理 - Flandre-Zhu - 博客园 (cnblogs.com)](https://www.cnblogs.com/LightningUZ/p/14731292.html)。
>
> 而在本题中，偏序关系 `cmp(x,y)=dep[x]>dep[y]`，根据这个排序即可。所以理论上讲应该先想到这种做法，再发现这样就相当于自底向上做。

复杂度浪费在哪？删子树，但这个操作可以直接时间戳区间减 inf，用线段树二分+区间修改维护。至于倍增维护 $k$ 级祖先，分类讨论即可。另外，换根的时候还要建树，这是一个区间加操作，注意上面的线段树操作需要撤回，这样才能保证复杂度正确。

换根的时候修改子树也是分类讨论，这一部分有例题：[Jamie and Tree - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)。](https://www.luogu.com.cn/problem/CF916E)

设目前树根为 $r$，则 $u$ 的子树为：

1. 以 $1$ 为根的情况下，$u$ 为 $r$ 的祖先。取 $u\sim r$ 链上 $u$ 的儿子 $v$，则 $u$ 子树为**全局**去掉以 $1$ 为根下 $v$ 的子树。**注意这里是在根为1意义下的，也就是说找 v 不需要换根**。而且注意是全局而非 $u$ 子树。

   这里因为写了 kanc，所以可以比较方便 $O(\log )\sim O(1)$ 求，更好的做法是给每个邻接表 `vec` 排序，然后二分查找。

2. $u=r$，为所有节点。

3. 其他情况，以 $r$ 为根下 $u$ 的子树与以 $1$ 为根下 $u$ 的子树相同。

求 k 级祖先的分类讨论：

1. 如果 $k\le dis(lca,u)$，那么和 $1$ 为根下的相同。
2. 否则，令 $k'=dis(lca,u)-k$，此时 $k$ 级祖先为 $rt$ 的 $dis(rt,lca)-k'$ 级祖先，如果为负数说明跳过了。

复杂度 $O(nq\log n)$，如果额外加上二分的 $\log$ 可能过不了。


```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
int read(){
	char c=getchar();int h=0,tag=1;
	while(!isdigit(c)) tag=(c=='-'?-1:1),c=getchar();
	while(isdigit(c)) h=(h<<1)+(h<<3)+(c^48),c=getchar();
	return h*tag;
}
void fil(){
	freopen("187","r",stdin);
	freopen("data.out","w",stdout);
}
const int N=2e5+500;
int id[N],dep[N],f[N][22],siz[N],tot,dfn[N];
vector<int>s[N],g[N];
void dfs(int x,int fa) {
	id[x]=++tot;siz[x]=1;
	dfn[tot]=x;
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	for(int y:s[x]) {
		if(y==fa) continue;
		dfs(y,x);
		g[x].push_back(y);
		siz[x]+=siz[y];
	}
} 
int rt=1;
int lca(int u,int v) {
	if(dep[u]<dep[v]) swap(u,v);
	int ddep=dep[u]-dep[v];
	for(int i=19;i>=0;i--) if(ddep>=(1<<i)) ddep-=(1<<i),u=f[u][i];
	if(u==v) return u;
	for(int i=19;i>=0;i--) {
		if(f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i];
	} 
	return f[u][0];
}
int dis(int u,int v) {
	return dep[u]+dep[v]-2*dep[lca(u,v)];
}
bool inTree(int u,int x) {
	if(id[x]<=id[u]&&id[u]<=id[x]+siz[x]-1) return 1;
	return 0;
}
int normal_kanc(int u,int k) {
	for(int i=19;i>=0;i--) {
		if(k>=(1<<i)) u=f[u][i],k-=(1<<i);
	}
	return u;
}
int kanc(int u,int k) {
	int _dis=dis(u,rt); 
	if(inTree(rt,u)) {
		return normal_kanc(rt,_dis-k);
	}
	if(u==1) return normal_kanc(u,k);
	int _lca=lca(u,rt);
	int dis2=dep[u]-dep[_lca];
	if(dis2>=k) return normal_kanc(u,k);
	k-=dis2;
	int dis3=dep[rt]-dep[_lca];
	return normal_kanc(rt,dis3-k);
}
struct tree{
	int t[N*4],tag[N*4];
	#define ls(x) (x<<1)
	#define rs(x) (x<<1|1)
	#define mid ((l+r)>>1)
	inline void push_up(int p) {
		t[p]=max(t[ls(p)],t[rs(p)]);	
	}
	inline void push_down(int p) {
		if(tag[p]==0) return ;
		t[ls(p)]+=tag[p],t[rs(p)]+=tag[p];
		tag[ls(p)]+=tag[p],tag[rs(p)]+=tag[p];
		tag[p]=0;
		return ;
	}
	void update(int p,int l,int r,int nl,int nr,int k) {
		if(nl>nr) return ;
		if(nl<=l&&r<=nr) {
			t[p]+=k;tag[p]+=k;
			return ;
		} 
		push_down(p);
		if(nl<=mid) update(ls(p),l,mid,nl,nr,k);
		if(mid<nr) update(rs(p),mid+1,r,nl,nr,k);
		push_up(p);
	}
	int find(int p,int l,int r) {
		if(l==r) {
			return l;
		}
		push_down(p);
		if(t[ls(p)]>t[rs(p)]) return find(ls(p),l,mid);
		else return find(rs(p),mid+1,r);
	}
	int query(int p,int l,int r,int x) {
		if(l==r) {
			return t[p];
		}
		push_down(p);
		if(x<=mid) return query(ls(p),l,mid,x);
		else return query(rs(p),mid+1,r,x);
	} 
}t;
int find_son(int x,int v) {
	int l=0,r=g[x].size()-1,res=-1;
	while(l<=r) {
		int y=g[x][mid];
		if(id[y]<=id[v]) {
			res=mid;
			l=mid+1;
		}else r=mid-1;
	}
	return g[x][res];
}
int sumk,n;
void upd(int x,int k) {
	if(rt==x) return t.update(1,1,n,1,n,k),void();
	if(inTree(rt,x)) {
		int y=find_son(x,rt);
		t.update(1,1,n,1,id[y]-1,k);
		t.update(1,1,n,id[y]+siz[y],n,k);
		return ;
	}
	t.update(1,1,n,id[x],id[x]+siz[x]-1,k);
}
vector<pii>update;
bool check(int c) {
	for(int i=1;i<=sumk;i++) {
		int x=dfn[t.find(1,1,n)];
		int _dep=t.query(1,1,n,id[x]);
		if(_dep-1<=c) {
			for(pii z:update) {
				upd(z.fi,z.se);
			}
			update.clear();
			return 1;	
		}
	
		int anc=kanc(x,c-1);
		update.push_back(pii(anc,_dep));
		upd(anc,-_dep);	
	}
	int x=dfn[t.find(1,1,n)];
	int _dep=t.query(1,1,n,id[x]);
	for(pii z:update) {
		upd(z.fi,z.se);
	}
	update.clear();
	if(_dep-1<=c) return 1;
	else{
		return 0;
	} 
}
int ans[N];
void dfs2(int x,int fa,int as) {
	for(int y:g[x]) {
		t.update(1,1,n,1,n,1);
		t.update(1,1,n,id[y],id[y]+siz[y]-1,-2);
		rt=y;
		for(int i=max(1ll,as-1ll);i<=min(n,as+1ll);i++) {
			if(check(i)) {
				ans[y]=i;
				dfs2(y,x,i);
				break;
			}
		}
		
		t.update(1,1,n,1,n,-1);
		t.update(1,1,n,id[y],id[y]+siz[y]-1,2);
	}
}
signed main(){
//	fil();
	int _t=0;
	n=read(),sumk=read(),_t=read();
	if(_t==1) _t=n;
	else _t=1;
	for(int i=1;i<n;i++) {
		int u=read(),v=read();s[u].push_back(v);s[v].push_back(u);
	}  
	dfs(1,0);
	for(int j=1;j<20;j++) {
		for(int i=1;i<=n;i++) {
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
	for(int i=1;i<=n;i++) t.update(1,1,n,id[i],id[i],dep[i]);
	int l=1,r=n,res=-1;//0 or 1?
	while(l<=r) {
		if(check(mid)) {
			res=mid;
			r=mid-1;
		}else l=mid+1;
	}
	ans[1]=res;
	dfs2(1,0,res);
	for(int i=1;i<=_t;i++) {
		printf("%lld ",ans[i]);
	}
	return 0;
}
```

---

## 作者：_AyachiNene (赞：2)

# 思路：
首先考虑不换根的情况。一个显然的贪心，要让答案尽量小，那么每次肯定要使深度最深的点深度变小。容易发现，在保证答案不变的情况下，连向深度尽量小的点一定不劣。具体的，假设答案为 $k$，深度最大点为 $u$，那么加边就因该连在 $u$ 的 $k-1$ 级祖先上。这启发我们二分答案，判断就是直接模拟加边过程，加边部分用线段树维护深度最大点即可。这样复杂度是 $O(n^2k \log^2 n)$ 的。考虑换根，首先深度的变化是简单的，直接线段树上区间加即可，难点在于如何在换根后求出 $k$ 级祖先。假设当前的根是 $u$，最远点为 $v$，直接分讨：

1. $u$ 是 $v$ 的祖先，无影响，就是 $v$ 的 $k$ 级祖先。
2. 设 $u$ 和 $v$ 的 lca 为 $p$：

   - $dep_v-dep_p<k$，$v$ 的 $k$ 级祖先。
   - $k\leq dep_v-dep_p$，$u$ 的 $dep_u-2dep_p-k+1+dep_v$ 级祖先。

同理，可以分讨出每种情况造成的贡献，这里不再赘述。

这样复杂度是 $O(nk\log^2n)$ 的。注意到相邻点之间答案变化量不超过 $1$，就做到了 $O(nk\log n)$。

# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char ch=getch();while(!(ch>='a'&&ch<='z')&&!(ch>='A'&&ch<='Z'))ch=getch();while((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);putch(' ');write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
struct node
{
	int nxt,to;
}e[200005<<1];
int head[200005],cnt_edge;
inline void add_edge(int u,int v)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int id,T;
int n,m,op;
#define pii pair<int,int>
#define fi first
#define se second
namespace Shiki
{
	struct segt
	{
		pii val;
		int tag;
	}t[200005<<2];
	#define ls (root<<1)
	#define rs (root<<1|1)
	#define mid ((l+r)>>1)
	void insert(int x,pii v,int root=1,int l=1,int r=n)
	{
		if(l==r) return t[root].val=v,void();
		if(x<=mid) insert(x,v,ls,l,mid);
		else insert(x,v,rs,mid+1,r);
		t[root].val=max(t[ls].val,t[rs].val);
	}
	void add(int x,int y,int v,int root=1,int l=1,int r=n)
	{
		if(x>y) return;
		if(l>=x&&r<=y) return t[root].tag+=v,t[root].val.fi+=v,void();
		if(x<=mid) add(x,y,v,ls,l,mid);
		if(y>mid) add(x,y,v,rs,mid+1,r);
		t[root].val=max(t[ls].val,t[rs].val);t[root].val.fi+=t[root].tag;
	}
	int query(int x,int root=1,int l=1,int r=n,int tag=0)
	{
		if(l==r) return t[root].val.fi+tag;
		tag+=t[root].tag;
		if(x<=mid) return query(x,ls,l,mid,tag);
		return query(x,rs,mid+1,r,tag);
	}
	#undef mid
}using namespace Shiki;
int f[200005][20],dfn[200005],cnt,dep[200005],siz[200005];
void dfs1(int u,int fa)
{
	f[u][0]=fa;dfn[u]=++cnt;siz[u]=1;
	for(int i=1;i<20;i++) f[u][i]=f[f[u][i-1]][i-1];
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dep[v]=dep[u]+1;
		dfs1(v,u);siz[u]+=siz[v];
	}
}
inline int kfa(int x,int k){for(int i=19;~i;i--) if(k>=(1<<i)) k-=(1<<i),x=f[x][i];return x;}
int ans[200005];
int L[400005],R[400005],V[400005],top;
inline void init(){while(top) add(L[top],R[top],V[top]),--top;}
inline int lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=19;~i;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(int i=19;~i;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
inline int find(int u,int v){for(int i=19;~i;i--) if(dep[f[u][i]]>dep[v]) u=f[u][i];return u;}
inline int check(int dis,int u)
{
	for(int i=1;i<=m;i++)
	{
		if(t[1].val.fi<=dis) return init(),1;
		int v=t[1].val.se;
		if(dfn[v]>=dfn[u]&&dfn[v]<=dfn[u]+siz[u]-1)
		{
			int p=kfa(v,dis-1);
			int w=-query(dfn[p])+1;
			add(dfn[p],dfn[p]+siz[p]-1,w);
			++top;L[top]=dfn[p],R[top]=dfn[p]+siz[p]-1,V[top]=-w;
		}
		else
		{
			if(dfn[u]>=dfn[v]&&dfn[u]<=dfn[v]+siz[v]-1)
			{
				int k=dep[u]-dep[v]-dis+1;
				int p=kfa(u,k);
				int w=dep[u]-dep[p]-1;
				int x=find(u,p);
				add(1,n,-w);add(dfn[x],dfn[x]+siz[x]-1,w);
				++top;L[top]=1,R[top]=n,V[top]=w;
				++top;L[top]=dfn[x],R[top]=dfn[x]+siz[x]-1,V[top]=-w;
			}
			else
			{
				int lc=lca(u,v);
//				cout<<u<<" "<<v<<" "<<lc<<" "<<dep[3]<<" "<<dep[lc]<<" "<<dis<<endl;
				if(dep[v]-dep[lc]>dis-1) 
				{
					int p=kfa(v,dis-1);
					int w=-query(dfn[p])+1;
					add(dfn[p],dfn[p]+siz[p]-1,w);
					++top;L[top]=dfn[p],R[top]=dfn[p]+siz[p]-1,V[top]=-w;
				}
				else
				{
					int k=dis-1-dep[v]+dep[lc];
					k=dep[u]-dep[lc]-k;
					int p=kfa(u,k);
					int w=dep[u]-dep[p]-1;
					int x=find(u,p);
					add(1,n,-w);add(dfn[x],dfn[x]+siz[x]-1,w);
					++top;L[top]=1,R[top]=n,V[top]=w;
					++top;L[top]=dfn[x],R[top]=dfn[x]+siz[x]-1,V[top]=-w;
				}
			}
		}
	}
	int res=t[1].val.fi<=dis;
	init();
	return res;
}
void dfs2(int u,int fa)
{
	int l=0,r=n,res=0;
	if(fa) l=max(0,ans[fa]-1),r=min(n,ans[fa]+1);
	while(l<=r)
	{
		int mid=l+r>>1;
		if(check(mid,u)) res=mid,r=mid-1;
		else l=mid+1;
	}
	ans[u]=res;
	if(op==0) return;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		add(dfn[v],dfn[v]+siz[v]-1,-2);add(1,n,1);
		dfs2(v,u);
		add(dfn[v],dfn[v]+siz[v]-1,2);add(1,n,-1);
	}
}
int main()
{
//	freopen("acorn.in","r",stdin);
//	freopen("acorn.out","w",stdout);
//	read(id,T);
	T=1; 
	while(T--)
	{	
		memset(head,0,sizeof head);
		cnt_edge=0;
		read(n,m,op);
		for(int i=1;i<n;i++)
		{
			int u,v;read(u,v);
			add_edge(u,v);add_edge(v,u);
		}
		cnt=0;
		memset(dep,0,sizeof dep);
		dfs1(1,0);
		for(int i=1;i<=(n<<2);i++) t[i].val={0,0},t[i].tag=0;
		for(int i=1;i<=n;i++) insert(dfn[i],{dep[i],i});
		dfs2(1,0);
		if(op==1) for(int i=1;i<=n;i++) write(ans[i]),putch(' ');
		else write(ans[1]);
		putch('\n');
	}
	flush();
	return 0;
}
```

---

## 作者：kkxacj (赞：1)

#### 前言

十分有趣的题，不过赛时一直在想把换根的 $n$ 优化掉，然后就似了。

#### 思路

首先要求最大值最小，我们先考虑二分把题目转化为一个判定性问题，然后会发现，我们直接从上到下的考虑，其实是很麻烦的。

我们从下往上考虑一个贪心，我们考虑所有 $dep_i>mid$ 的，每次从里面选一个深度最大的 $x$，然后删除 $x$ 的 $mid-1$ 级祖先的子树，知道所有还在的点的深度 $\le mid$，这样操作次数一定是最少的，我们考虑数据结构维护这一个过程，具体的就线段树维护每个点的深度，然后删子树就是区间减去 $\inf$，求 $k$ 级祖先就倍增求就好了，单次复杂度 $k\log^2$。

对于换根，其实是可以通过分讨解决求 $k$ 级祖先，然后每个点的深度也好搞，复杂度可以做到 $n\times k \times \log^2$。

具体的，在求 $x$ 在 $y$ 为根时的 $k$ 级祖先（假设一定有）的分讨如下：

我们先对于根为 $1$ 时跑一遍。

然后先求出 $x,y$ 在以 $1$ 为根的最近公共祖先 $z$。

1. 如果 $x$ 是 $y$ 祖先，那么就是 $y$ 跳 $dep_y-dep_x-k$ 次。

1. 如果 $dep_x-dep_z \ge k$，那么 $x$ 直接跳就好了。

1. 否则就是 $y$ 跳 $dep_x+dep_y-2\times dep_z-k$ 次。


继续观察，注意到对于两个相邻点，答案相差不超过 $1$，比如我们对于 $y$ 还是进行 $x$ 的构建方式，然后对于 $y$ 的子树深度减一了，肯定合法，对于 $x$ 那边的深度加一，我们给答案也加一，那对于它们来说还是在对于原来的 $x$ 这里看，所以也一定合法。

所以只需要判一下 $ans-1,ans,ans+1$ 即可，复杂度 $n\times k\times \log$。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls (p<<1)
#define rs ((p<<1)+1)
#define mid ((c[p].l+c[p].r)>>1)
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 2e5+10,inf = 1e7;
int T1,T,x,y,n,k,t,head[N],ans[N],cnt,dep[N],f[N][20],lg[N],op;
int dfn[N],siz[N],son[N],col[N],id[N],fa[N],cnt1;
struct w
{
	int to,nxt;
}b[N<<1];
int cnt2;
struct w2
{
	int l,r,z;
}A[N<<1];
struct w1
{
	int l,r,mx,ad;
}c[N<<2],d[N<<2];
inline void add(int x,int y)
{
	b[++cnt].nxt = head[x];
	b[cnt].to = y;
	head[x] = cnt;
}
void dfs(int x,int y)
{
	siz[x] = 1; fa[x] = f[x][0] = y;
	for(int i = 1;i <= lg[dep[x]];i++) f[x][i] = f[f[x][i-1]][i-1];
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y)
		{
			dep[b[i].to] = dep[x]+1,dfs(b[i].to,x);
			siz[x] += siz[b[i].to];
			if(siz[son[x]] < siz[b[i].to]) son[x] = b[i].to; 
		}
}
void dfs1(int x,int y,int z)
{
	col[x] = z,dfn[x] = ++cnt1,id[cnt1] = x;
	if(!son[x]) return;
	dfs1(son[x],x,z);
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y && b[i].to != son[x])
			dfs1(b[i].to,x,b[i].to);
}
void build(int p,int l,int r)
{
	c[p].l = l,c[p].r = r,c[p].ad = 0;
	if(l == r)
	{
		c[p].mx = dep[id[l]];
		return;
	}
	build(ls,l,mid),build(rs,mid+1,r);
	c[p].mx = max(c[ls].mx,c[rs].mx);
}
void change(int p,int l,int r,int k)
{
	if(l <= c[p].l && c[p].r <= r)
	{
		c[p].mx += k; c[p].ad += k;
		return;
	}
	if(l <= mid) change(ls,l,r,k);
	if(mid < r) change(rs,l,r,k);
	c[p].mx = max(c[ls].mx,c[rs].mx)+c[p].ad;
}
int op1,op2,l,r,Mid;
int query(int p,int x=0)
{
	if(c[p].l == c[p].r) return c[p].l;
	x += c[p].ad;
	if(c[ls].mx > c[rs].mx) return query(ls,x);
	else return query(rs,x);
}
inline int lca(int x,int y)
{
	if(dep[x] < dep[y]) swap(x,y);
	while(dep[x] != dep[y]) x = f[x][lg[dep[x]-dep[y]]];
	if(x == y) return x;
	for(int i = lg[dep[x]];i >= 0;i--)
		if(f[x][i] != f[y][i]) x = f[x][i],y = f[y][i];
	return f[x][0];
} 
inline int Lca(int x,int y,int z)
{
	if(dfn[x] <= dfn[z] && dfn[z] <= dfn[x]+siz[x]-1)
	{
		y = (dep[z]-dep[x]-y); x = z;
		for(int i = lg[dep[x]];i >= 0;i--)
			if((y&(1<<i))) x = f[x][i];
		return x;
	}
	int o = lca(x,z);
	if(dep[x]-dep[o] >= y)
	{
		for(int i = lg[dep[x]];i >= 0;i--)
			if((y&(1<<i))) x = f[x][i];
		return x;
	}
	y = (dep[z]-dep[o]+dep[x]-dep[o]-y); x = z;
	for(int i = lg[dep[x]];i >= 0;i--)
		if((y&(1<<i))) x = f[x][i];
	return x;
} 
int qw;
void dfs2(int x,int y)
{
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y)
		{ qw = 0;
			change(1,dfn[b[i].to],dfn[b[i].to]+siz[b[i].to]-1,-2),change(1,1,n,1);
			for(int z = max(1,ans[x]-1);z <= ans[x];z++)
			{
				op = 0; Mid = z; cnt2 = 0; 
				for(int j = 1;j <= k;j++)
				{ 
					if(c[1].mx <= Mid) { op = 1; break; }
					op1 = id[query(1)];
		 			op1 = Lca(op1,Mid-1,b[i].to);
					if(dfn[op1] <= dfn[b[i].to] && dfn[b[i].to] <= dfn[op1]+siz[op1]-1)
					{
						op2 = Lca(op1,1,b[i].to);
						A[++cnt2].l = 1,A[cnt2].r = n,A[cnt2].z = -inf;
						change(1,1,n,-inf);
						A[++cnt2].l = dfn[op2],A[cnt2].r = dfn[op2]+siz[op2]-1,A[cnt2].z = inf;
						change(1,dfn[op2],dfn[op2]+siz[op2]-1,inf);
					}
					else
					{
						A[++cnt2].l = dfn[op1],A[cnt2].r = dfn[op1]+siz[op1]-1,A[cnt2].z = -inf;
						change(1,dfn[op1],dfn[op1]+siz[op1]-1,-inf);
					}
				}
				if(c[1].mx <= Mid) op = 1;
				for(int i = 1;i <= cnt2;i++) change(1,A[i].l,A[i].r,-A[i].z);
				if(op == 1)
				{
					ans[b[i].to] = Mid,dfs2(b[i].to,x); qw = 1;
					change(1,dfn[b[i].to],dfn[b[i].to]+siz[b[i].to]-1,2),change(1,1,n,-1);
					break;
				}
			}
			if(!qw)
			{
				ans[b[i].to] = ans[x]+1,dfs2(b[i].to,x);
				change(1,dfn[b[i].to],dfn[b[i].to]+siz[b[i].to]-1,2),change(1,1,n,-1);
			}
		}
}
signed main()
{
	read(n),read(k),read(t); cnt = cnt1 = 0; 
	for(int i = 1;i <= n;i++) head[i] = son[i] = 0;
	for(int i = 2;i <= n;i++) lg[i] = lg[i/2]+1;
	for(int i = 1;i <= n;i++)
		for(int j = 0;j <= lg[n];j++)
			f[i][j] = 0;
	for(int i = 1;i < n;i++) read(x),read(y),add(x,y),add(y,x);
	l = 1,r = n; dfs(1,0); dfs1(1,0,1); build(1,1,n);
	while(l <= r)
	{
		Mid = ((l+r)>>1); op = 0; cnt2 = 0;
		for(int i = 1;i <= k;i++)
		{
			if(c[1].mx <= Mid) { op = 1; break; }
			op1 = id[query(1)];
			op1 = Lca(op1,Mid-1,1); 
			change(1,dfn[op1],dfn[op1]+siz[op1]-1,-inf);
			A[++cnt2].l = dfn[op1],A[cnt2].r = dfn[op1]+siz[op1]-1,A[cnt2].z = -inf;
		}  if(c[1].mx <= Mid) op = 1;
		for(int i = 1;i <= cnt2;i++) change(1,A[i].l,A[i].r,-A[i].z);
		if(op) r = Mid-1,ans[1] = Mid;
		else l = Mid+1;
	}
	if(t == 0) { print(ans[1]),pc('\n'); }
	else { dfs2(1,0); for(int i = 1;i <= n;i++) print(ans[i]),pc(' '); pc('\n'); }
	flush();
	return 0;
}
```

---


# [ROIR 2024] 二叉树的遍历 (Day 2)

## 题目背景

翻译自 [ROIR 2024 D2T4](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day2.pdf)。

二叉树有三种基本遍历方式：前序遍历（pre-order）、中序遍历（in-order）和后序遍历（post-order）。我们可以将这三种遍历方式进行概括：假设每个节点上记录一个整数 $x$（取值范围为 $-1$ 到 $1$），表示在遍历中输出该节点的时机，具体如下：
- $x = -1$：在遍历其左右子树之前；
- $x = 0$：在遍历其左子树之后，遍历其右子树之前；
- $x = 1$：在遍历其左右子树之后。

因此，如果所有节点的 $x$ 值都是 $-1$，则遍历为前序遍历；如果都是 $0$，则为中序遍历；如果都是 $1$，则为后序遍历。

## 题目描述

考虑一棵有 $n$ 个节点的二叉树，节点编号从 $1$ 到 $n$。树的根节点为 $1$。最初，所有节点上的值都是 $-1$。

你需要处理 $q$ 个操作，操作类型如下：
1. 将节点 $l, l + 1, \dots, r$ 上的值更改为 $x$（$x$ 取值为 $-1$，$0$ 或 $1$）。
2. 查询节点 $i$ 在当前遍历方式中的位置。

需要输出所有第二种类型的操作的结果。

## 说明/提示

样例中的树是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/keaqqiat.png)

刚开始，所有节点的 $x$ 值都是 $-1$，因此第一次查询时遍历得到的数组为 $[1,3,5,2,4]$，$2$ 在第四个位置。

在将节点 $1,2,3$ 的遍历方式 $x$ 改为 $1$ 后，再次查询时遍历得到的数组为 $[5,2,3,4,1]$，$5$ 在第一个位置。

接着把节点 $3$ 的遍历方式 $x$ 改为 $0$，此时再进行查询，遍历得到的数组为 $[5,3,2,4,1]$，$3$ 在第二个位置。

设 $q_1$ 为操作 $1$ 的数量。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
|$1$ | $10$ | $n, q \leq 5000$ |
|$2$ | $5$ | $q_1 \leq 10$ |
|$3$ | $10$ | 所有操作一在所有操作二之前 |
|$4$ | $10$ | 所有叶子节点都与根节点距离相同，没有具有一个子节点的节点 |
|$5$ | $10$ | 对于所有操作一，$l = r$ |
|$6$ | $20$ | 对于所有操作一，$x \in \{-1, 1\}$，每个节点最多有一个子节点 |
|$7$ | $10$ | 对于所有操作一，$x \in \{-1, 1\}$ |
|$8$ | $10$ | 每个节点最多有一个子节点 |
|$9$ | $15$ | 无 |

对于 $100\%$ 的数据，$1 \leq n, q \leq 100000$。

## 样例 #1

### 输入

```
5 5
3 4
0 0
5 2
0 0
0 0
2 2
1 1 3 1
2 5
1 3 3 0
2 3```

### 输出

```
4
1
2```

# 题解

## 作者：Nityacke (赞：1)

给一个当前题解区没有的做法。

首先考虑哪些节点会对询问的 $x$ 产生贡献，分成几类。

- $x$ 的子树内部节点。
- $x$ 的祖先。
- 与 $x$ 没有祖先后代关系的节点。

第一类和第三类是容易计算的。

我们考虑如何计算第二类的贡献，考虑 $y$ 对 $x$ 产生了贡献。

- $c_y=-1$，此时 $x$ 在 $y$ 的子树内部即可。
- $c_y=0$，此时需要满足 $x$ 在 $y$ 的右子树内部。

我们可以把贡献看成在边上。

考虑对于原树进行 top cluster 树分块，那么 $x$ 到根的路径可以表示成 $O(\sqrt n)$ 条簇路径的贡献+ $O(\sqrt n)$ 个散点的贡献。

对于修改操作使用颜色段均摊，则我们只有 $O(n+q)$ 次区间染色。

散点的颜色可以用 $O(\sqrt n)-O(1)$ 的分块维护。

我们将染色操作带上 $\pm 1$ 的贡献系数，表示染色或者删除之前的染色。

对于整块，我们需要一次染色操作带来的贡献，我们对于每个块，对于簇路径用桶维护出现节点有哪些，以及在簇路径上经过向右儿子的边的节点有哪些，对于桶做前缀和，那么我们可以 $O(1)$ 计算出来 $[l,r]$ 在簇路径上有多少个节点，那么我们一次染色对于一个块的影响可以 $O(1)$ 得到，所以我们就可以在 $O((n+q)\sqrt n)$ 的复杂度内解决，但是常数不是很小。

由于我们树分块似乎有 $6\frac n B$ 个块，所以 $B$  要开大一些。

代码的块长没有调过。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,B=1.5e3,T=6*N/B+5;
int n,q,cnt1[T][N],cnt2[T][N],ch[N][2],val[N],sz[N];
int f[N],F[N],pos[N],C,sum[N];
namespace Node{
	array<int,2> t1[N],t2[N];
	int L[N],R[N],bl[N];
	inline void change(int l,int r,int t,int v){
		int p=bl[l],q=bl[r];
		if(p==q){
			for(int i=l;i<=r;++i) t1[i]={t,v};
			return;
		}
		for(int i=l;i<=R[p];++i) t1[i]={t,v};
		for(int i=p+1;i<q;++i) t2[i]={t,v};
		for(int i=L[q];i<=r;++i) t1[i]={t,v};
	}
	inline void init(){
		for(int i=1;i<=n;++i) bl[i]=(i-1)/B+1,t1[i]={0,-1};
		for(int i=1;i<=bl[n];++i) t2[i]={0,-1},L[i]=R[i-1]+1,R[i]=min(i*B,n);
	}
	inline int qry(int x){return max(t1[x],t2[bl[x]])[1];}
}
#define pii pair<int,bool>
inline pii dfs(int x,int s,int fa=0){
	if(!x) return {0,0};
	val[x]=s,f[x]=fa,sz[x]=1;
	pii t;
	int cnt=1,FL=0;
	t=dfs(ch[x][0],s,x),cnt+=t.first,FL+=t.second,s+=sz[ch[x][0]],sz[x]+=sz[ch[x][0]];
	t=dfs(ch[x][1],s,x),cnt+=t.first,FL+=t.second,sz[x]+=sz[ch[x][1]];
	if(cnt>=B||FL>1) pos[x]=++C,cnt=0;
	return {cnt,pos[x]||FL};
}
inline void dfs2(int x,int lst){
	if(!x) return;
	if(pos[x]){
		F[x]=lst,lst=x;
		for(int i=x;i!=F[x];i=f[i]){
			if(!f[i]) continue;
			++cnt1[pos[x]][f[i]];
			if(i==ch[f[i]][1]) ++cnt2[pos[x]][f[i]];
		}
		for(int i=1;i<=n;++i) cnt1[pos[x]][i]+=cnt1[pos[x]][i-1],cnt2[pos[x]][i]+=cnt2[pos[x]][i-1];
		for(int i=1;i<=n;++i) cnt1[pos[x]][i]+=cnt1[pos[F[x]]][i],cnt2[pos[x]][i]+=cnt2[pos[F[x]]][i];
	}
	dfs2(ch[x][0],lst),dfs2(ch[x][1],lst);
}
struct node{
	int l,r,c;
	inline node(int _l=0,int _r=0,int _x=0){l=_l,r=_r,c=_x;}
	inline bool operator <(const node a)const{return l<a.l;}
};
set<node>S;
#define Iter set<node>::iterator
inline Iter split(int x){
	Iter it=S.lower_bound(node(x));
	if(it!=S.end()&&it->l==x) return it;
	--it;
	int c=it->c,L=it->l,R=it->r;
	S.erase(it),S.insert(node(L,x-1,c));
	return S.insert(node(x,R,c)).first;
}
inline void change(int l,int r,int x){
	Iter ed=split(r+1),st=split(l);
	S.erase(st,ed),S.insert(node(l,r,x));
}
inline void mdf(int L,int R,int x,int v){
	if(x==-1) for(int i=2;i<=C;++i) sum[i]+=(cnt1[i][R]-cnt1[i][L-1])*v;
	if(x==0) for(int i=2;i<=C;++i) sum[i]+=(cnt2[i][R]-cnt2[i][L-1])*v;
}
inline void assign(int l,int r,int x,int t){
	auto ed=split(r+1),st=split(l);
	for(auto it=st;it!=ed;++it) mdf(it->l,it->r,it->c,-1);
	S.erase(st,ed),S.insert(node(l,r,x)),mdf(l,r,x,1),Node::change(l,r,t,x);
}
inline int calc(int x){
	int ans=1+val[x],c=Node::qry(x);
	if(c==0) ans+=sz[ch[x][0]];
	if(c==1) ans+=sz[ch[x][0]]+sz[ch[x][1]];
	while(!pos[x]){
		if(!f[x]) return ans;
		if((c=Node::qry(f[x]))==-1) ++ans;
		else if(c==0&&x==ch[f[x]][1]) ++ans;
		x=f[x];
	}
	return ans+sum[pos[x]];
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>q,pos[0]=C=1;
	for(int i=1;i<=n;++i) cin>>ch[i][0]>>ch[i][1];
	dfs(1,0),dfs2(1,0),S.insert(node(1,n+1,-1)),mdf(1,n,-1,1),Node::init();
	for(int opt,l,r,x,i=1;i<=q;++i){
		cin>>opt;
		if(opt==1) cin>>l>>r>>x,assign(l,r,x,i);
		else cin>>x,cout<<calc(x)<<"\n";
	}
}
```

---

## 作者：Helloworldwuyuze (赞：1)

# P11127 [ROIR 2024 Day 2] 二叉树的遍历

## Des

一棵树，两种操作：

- `1 l r type` 表示将 $[l,r]$ 的节点所在的子树的遍历顺序改为 `type`。
- `2 x` 表示查询当前遍历顺序之下，$x$ 在遍历序列中的位置。

其中 `type` 表示：

- `type = -1` 时，该子树前序遍历。
- `type = 0` 时，该子树中序遍历。
- `type = 1` 时，该子树后序遍历。

## Sol

这个玩意看起来就极其不可用兼容性不高的数据结构做，而且 $n,q\le 10^5$，因此我们使用分块。

首先，我们要考虑什么样的点能够在 $x$ 前面。

- $x$ 子树为中序遍历，$y$ 在 $x$ 的左子树。
- $x$ 子树为后序遍历，$y$ 在 $x$ 的子树内。
- 存在一个 $z$ 使得 $x$ 在 $z$ 的右子树而 $y$ 在 $x$ 的左子树。
- $y$ 为前序遍历，$x$ 在它的子树内。
- $y$ 为中序遍历，$x$ 在它的右子树内。

一共就这么 $5$ 种情况。对于前三种，我们是可以根据当时 $x$ 的类型直接判断出来，因此我们只需要考虑前两种。

- 首先，我们考虑如果一个块内，所有的点的遍历类型都相同，那么显然我们可以提前处理出来它们的贡献。

  具体的，我们设 $g_{0/1,i,j}$ 表示 `type = -1/0` 时，$i$ 对 $dfn_x=j$ 的 $x$ 的贡献。这里 $0/1$ 是因为在 `type = 1`，也就是后序遍历的时候，$i$ 不产生贡献。而当 `type = -1`，也就是前序遍历的时候，它会对子树全部加一，`type = 0` 也就是中序遍历的时候，它会对右子树全部加一。都是子树加，因此使用 `dfn` 显然会更加方便。

- 其次，我们考虑散块的贡献。

  细想一下就会发现，散块的计算是非常困难的，因此我们干脆暴力计算。

  但时间复杂度怎么保证呢？

  考虑一次修改至多会产生两个散块，而每个散块重构的复杂度为 $O(\sqrt n)$，因此复杂度为完全可以接受。
  
  在把一个整块全部变成散块的时候，我们更改块内标记，然后暴力地将每个点的贡献都算上。注意这里需要一个 $O(1)-O(\sqrt n)$，也就是询问 $O(\sqrt n)$ 修改 $O(1)$ 的分块来平衡复杂度，而不是傻乎乎地去写树状数组。然后，在把散块都暴力整合成整块的时候，我们就把它们在散块上的贡献都清除掉即可。

另外，还有一点需要注意：在处理第 $1,2$ 条产生的贡献的时候，我们需要用到 $x$ 具体是哪个遍历类型，而这时候我们不能直接使用 `type[x]` 来获取，而是需要判断它所处的块是不是散块，如果不是则以块的类型为准。

```cpp
#define endl '\n'
using namespace std;
const int N = 1e5 + 10;
const int B = 300;
const int T = N/B + 5;	
inline int min(int x,int y){ return x < y ? x : y; }
inline int max(int x,int y){ return x < y ? y : x; }

int n, q, ch[N][2];
int ga[T][N], gr[T][N], m[N], mb[N];
int bef[N], mid[N], aft[N], idx, siz[N];
int bl[N], le[N], ri[N], type[N], btype[N];

void dfs(int x){
	if(!x)	return ;
	bef[x] = ++idx; dfs(ch[x][0]); mid[x] = idx; dfs(ch[x][1]); aft[x] = idx;
	siz[x] += siz[ch[x][0]] + siz[ch[x][1]] + 1;
}

inline void add(int x,int k){ m[x] += k, mb[bl[x]] += k;}
inline void add(int l,int r,int k){ add(l, k), add(r+1, -k); }
inline void update(int x,int k){
	if(type[x] == -1)	add(bef[x] + 1, aft[x], k);
	if(type[x] == 0)	add(mid[x] + 1, aft[x], k);
}
inline void _modify(int l,int r,int k){
	int block = bl[l];
	if(btype[block] == 2){
		for(int i=l;i<=r;++i)	update(i, -1), type[i] = k, update(i, 1);
	}else{
		for(int i = le[block]; i <= ri[block]; ++i)	type[i] = btype[block];
		for(int i = l; i <= r; ++i)	type[i] = k;
		for(int i = le[block]; i <= ri[block]; ++i)	update(i, 1);
		btype[block] = 2;
	}
}
inline void modify(int l,int r,int k){
	if(bl[l] == bl[r])	return _modify(l, r, k);
	_modify(l, ri[bl[l]], k), _modify(le[bl[r]], r, k);
	for(int i = bl[l]+1; i < bl[r]; ++i){
		if(btype[i] == 2)	for(int j = le[i]; j <= ri[i]; ++j)	update(j, -1);
		btype[i] = k;
	}
}
inline int solve(int x){
	int ans = 1;
	for(int i=1;i<bl[bef[x]];++i)	ans += mb[i];
	for(int i=le[bl[bef[x]]];i<=bef[x];++i)	ans += m[i];
	int k = btype[bl[x]] == 2 ? type[x] : btype[bl[x]];
	if(k == 0)	ans += siz[ch[x][0]];
	if(k == 1)	ans += siz[x] - 1;
	for(int i=1;i<=bl[n];++i){
		if(btype[i] == -1)	ans += ga[i][bef[x]];
		if(btype[i] == 0)	ans += gr[i][bef[x]];
	}
	return ans;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;++i)	cin>>ch[i][0]>>ch[i][1], type[i] = -1;
	for(int i=1;i<=n;++i)	bl[i] = (i-1)/B+1, type[i] = -1;
	for(int i=1;i<=bl[n];++i)	btype[i] = 2, le[i] = ri[i-1] + 1, ri[i] = min(i * B, n);
	dfs(1);
	for(int i=1;i<=n;++i){
		update(i, 1);
		add(mid[i]+1, aft[i], siz[ch[i][0]]);
		ga[bl[i]][bef[i]+1] ++, ga[bl[i]][aft[i]+1] --;
		gr[bl[i]][mid[i]+1] ++, gr[bl[i]][aft[i]+1] --;
	}
	for(int i=1;i<=bl[n];++i)
		for(int j=1;j<=n;++j)	ga[i][j] += ga[i][j-1], gr[i][j] += gr[i][j-1];
	while(q--){
		int op, l, r, x; cin>>op;
		if(op == 1)	cin>>l>>r>>x, modify(l, r, x);
		else	cin>>x, cout<<solve(x)<<endl;
	}
	return 0;
}
```

---

## 作者：songhongyi (赞：0)

考虑有哪些点 $y$ 在 $x$ 前面。有四种情况：
* 存在一个点，$y$ 在其左子树，$x$ 在其右子树；
* $y$ 中序，$x$ 在其右子树；
* $y$ 先序，$x$ 在其子树；
* $y$ 在 $x$ 子树内，且这个子树在根前遍历。

四种情况中，第一种与操作无关，显然可以预处理出来，第四种在知道 $x$ 的遍历方式后只需要知道子树大小即可。
            
剩下的情况里，$y$ 都是 $x$ 的祖先。我们考虑对序列分块，并将一个块标记方式全同的称为整块，否则称为散块。

我们发现，一个整块对于一个点的影响是可以预处理的。具体来说，在预处理时，把每个块的 $O(\sqrt n)$ 个位置对应的子树子树加，然后对所有点统计。单次复杂度 $O(n)$，瓶颈在对所有点统计，总复杂度 $O(n \sqrt n)$。

那么散块贡献怎么处理呢？我们考虑维护每个点的散块贡献，那么新增一个散块时，就应该对这个数组子树加，删除时减。由于一次操作最多制造 $2$ 个散块，所以总共的散块个数时 $O(n)$ 的。这里需要 $O(n \sqrt n)$ 次子树加，而查询只有 $O(n)$ 次，所以用一个 $O(1) - O(\sqrt n)$ 的分块维护即可。查询时遍历每个整块，再加上散块的贡献即可。

总复杂度 $O(n \sqrt n)$。

```cpp
//
// Problem: P11127 [ROIR 2024 Day 2] 二叉树的遍历
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P11127
// Memory Limit: 512 MB
// Time Limit: 1670 ms

#include <iostream>
using namespace std;
const int MAXN = 1e5 + 10, B = 320;
int son[ MAXN ][ 2 ];
int dfn[ MAXN ], siz[ MAXN ], pm[ MAXN ], pd[ MAXN ];
int L[ B ], R[ B ], id[ MAXN ];
int c;
void init( int n )
{
    for ( int i = 1; i <= n / B; i++ )
    {
        L[ ++c ] = ( i - 1 ) * B + 1;
        R[ c ] = i * B;
    }
    if ( R[ c ] < n )
    {
        L[ c + 1 ] = R[ c ] + 1;
        R[ ++c ] = n;
    }
    for ( int i = 1; i <= c; i++ )
    {
        for ( int j = L[ i ]; j <= R[ i ]; j++ )
        {
            id[ j ] = i;
        }
    }
}
int cc;
void dfs( int x )
{
    siz[ x ] = 1;
    dfn[ x ] = ++cc;
    if ( son[ x ][ 0 ] )
    {
        dfs( son[ x ][ 0 ] );
        siz[ x ] += siz[ son[ x ][ 0 ] ];
    }
    pm[ x ] = cc;
    if ( son[ x ][ 1 ] )
    {
        dfs( son[ x ][ 1 ] );
        siz[ x ] += siz[ son[ x ][ 1 ] ];
    }
    pd[ x ] = cc;
}
int resd[ MAXN ];
int su[ B ];
void add( int p, int v )
{
    su[ id[ p ] ] += v;
    resd[ p ] += v;
}
int query( int p )
{
    int res = 0;
    for ( int i = 1; i < id[ p ]; i++ )
    {
        res += su[ i ];
    }
    for ( int i = L[ id[ p ] ]; i <= p; i++ )
    {
        res += resd[ i ];
    }
    return res;
}
void Add( int l, int r, int v )
{
    add( l, v );
    add( r + 1, -v );
}
int typk[ B ], typs[ MAXN ];
void update( int l, int r, int x )
{
    for ( int i = l; i <= r; i++ )
    {

        if ( typs[ i ] == -1 )
        {
            Add( dfn[ i ] + 1, dfn[ i ] + siz[ i ] - 1, -1 );
        }
        else if ( typs[ i ] == 0 )
        {
            if ( son[ i ][ 1 ] )
            {
                Add( dfn[ son[ i ][ 1 ] ], dfn[ son[ i ][ 1 ] ] + siz[ son[ i ][ 1 ] ] - 1, -1 );
            }
        }
        typs[ i ] = x;
        if ( typs[ i ] == -1 )
        {
            Add( dfn[ i ] + 1, dfn[ i ] + siz[ i ] - 1, 1 );
        }
        else if ( typs[ i ] == 0 )
        {
            if ( son[ i ][ 1 ] )
            {
                Add( dfn[ son[ i ][ 1 ] ], dfn[ son[ i ][ 1 ] ] + siz[ son[ i ][ 1 ] ] - 1, 1 );
            }
        }
    }
}
void revert( int l, int r )
{
    for ( int i = l; i <= r; i++ )
    {
        if ( typs[ i ] == -1 )
        {
            Add( dfn[ i ] + 1, dfn[ i ] + siz[ i ] - 1, -1 );
        }
        else if ( typs[ i ] == 0 )
        {
            if ( son[ i ][ 1 ] )
            {
                Add( dfn[ son[ i ][ 1 ] ], dfn[ son[ i ][ 1 ] ] + siz[ son[ i ][ 1 ] ] - 1, -1 );
            }
        }
    }
}
void pushdown( int x )
{
    for ( int i = L[ x ]; i <= R[ x ]; i++ )
    {
        typs[ i ] = typk[ id[ i ] ];
        if ( typs[ i ] == -1 )
        {
            Add( dfn[ i ] + 1, dfn[ i ] + siz[ i ] - 1, 1 );
        }
        else if ( typs[ i ] == 0 )
        {
            if ( son[ i ][ 1 ] )
            {
                Add( dfn[ son[ i ][ 1 ] ], dfn[ son[ i ][ 1 ] ] + siz[ son[ i ][ 1 ] ] - 1, 1 );
            }
        }
    }
}
void Update( int l, int r, int x )
{
    if ( id[ l ] == id[ r ] )
    {
        if ( typk[ id[ l ] ] != 2 )
        {

            pushdown( id[ l ] );
            typk[ id[ l ] ] = 2;
        }
        update( l, r, x );
        return;
    }
    if ( typk[ id[ l ] ] != 2 )
    {
        pushdown( id[ l ] );
        typk[ id[ l ] ] = 2;
    }
    update( l, R[ id[ l ] ], x );
    for ( int i = id[ l ] + 1; i <= id[ r ] - 1; i++ )
    {
        if ( typk[ i ] == 2 )
        {
            revert( L[ i ], R[ i ] );
        }
        typk[ i ] = x;
    }
    if ( typk[ id[ r ] ] != 2 )
    {
        pushdown( id[ r ] );
        typk[ id[ r ] ] = 2;
    }
    update( L[ id[ r ] ], r, x );
}
int va[ MAXN ][ B ][ 2 ];
int Query( int x )
{
    int res = query( dfn[ x ] );
    int typ = ( typk[ id[ x ] ] == 2 ? typs[ x ] : typk[ id[ x ] ] );
    if ( typ == 1 )
    {
        res += siz[ x ] - 1;
    }
    else if ( typ == 0 )
    {
        res += siz[ son[ x ][ 0 ] ];
    }
    for ( int i = 1; i <= c; i++ )
    {
        if ( typk[ i ] != 2 and typk[ i ] != 1 )
        {
            res += va[ dfn[ x ] ][ i ][ typk[ i ] + 1 ];
        }
    }
    return res;
}
int main()
{
    cin.tie( 0 );
    int n, Q;
    cin >> n >> Q;
    init( n );
    for ( int i = 1; i <= n; i++ )
    {
        cin >> son[ i ][ 0 ] >> son[ i ][ 1 ];
    }
    dfs( 1 );
    for ( int i = 1; i <= n; i++ )
    {
        if ( son[ i ][ 0 ] and son[ i ][ 1 ] )
        {
            Add( dfn[ son[ i ][ 1 ] ], dfn[ son[ i ][ 1 ] ] + siz[ son[ i ][ 1 ] ] - 1,
                 siz[ son[ i ][ 0 ] ] );
        }
    }
    for ( int i = 1; i <= c; i++ )
    {
        for ( int j = L[ i ]; j <= R[ i ]; j++ )
        {
            va[ dfn[ j ] + 1 ][ i ][ 0 ]++;
            va[ dfn[ j ] + siz[ j ] ][ i ][ 0 ]--;
            if ( son[ j ][ 1 ] )
            {
                va[ dfn[ son[ j ][ 1 ] ] ][ i ][ 1 ]++;
                va[ dfn[ son[ j ][ 1 ] ] + siz[ son[ j ][ 1 ] ] ][ i ][ 1 ]--;
            }
        }
        for ( int j = 1; j <= n; j++ )
        {
            va[ j ][ i ][ 0 ] += va[ j - 1 ][ i ][ 0 ];
            va[ j ][ i ][ 1 ] += va[ j - 1 ][ i ][ 1 ];
        }
    }
    for ( int i = 1; i <= n; i++ )
    {
        typs[ i ] = -1;
        typk[ id[ i ] ] = -1;
    }
    while ( Q-- )
    {
        int op;
        cin >> op;
        if ( op == 1 )
        {
            int l, r, x;
            cin >> l >> r >> x;
            Update( l, r, x );
        }
        else
        {
            int x;
            cin >> x;
            cout << Query( x ) + 1 << '\n';
        }
    }
}
```

---

## 作者：Purslane (赞：0)

# Solution

不会分块 /ll

对于每个点 $x$，和它相对顺序可能发生变化的点都和 $x$ 有祖先关系，难以处理的是 $x$ 的祖先。

假设 $y$ 是 $x$ 的一个祖先。如果 $x$ 在 $y$ 的左子树中，只有 $o_y = -1$ 才能产生贡献；如果 $x$ 在 $y$ 的右子树中，只有 $o_y = -1 / 0$ 才能产生贡献。

分开考虑这两种情况，把 $o_y$ 直接分成“合法”与“非法”两种情况，操作只有区间覆盖乘“合法”或者“非法”。

考虑对区间进行分块。块内，可以计算如果整块都被覆盖乘合法那么对每个点的贡献分别是多少。

对于区间覆盖中的整块，我们称他们是有序的；对于散块，我们称他们是无序的。我们可以对于每个有序块，预处理它如果全部操作会对 $1$ 到 $n$ 每个点产生多少影响。

考虑区间赋值操作。在整块赋值的时候，如果原来是有序的，直接修改 tag，否则**暴力消除内部所有数的影响**并且将其变为有序的。处理散块的时候，先 `push_down` 变成无序的，然后暴力对其中每个点修改结果。

首先，根据势能分析，无序的块一共会增加 $O(q)$ 个，而每次减少一个只会有 $O(\sqrt n)$ 的复杂度，所以暴力把无序块变为有序的复杂度正确！

发现我们会有 $O(q \sqrt n)$ 次区间加减操作。这个也可以使用值域分块实现 $O(1)$ 区间加减，$O(\sqrt n)$ 查询。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100000+10;
int n,q,k,B=320,bel[MAXN],L[MAXN],R[MAXN];
int op[MAXN],tag[MAXN/320+5],impact[MAXN/320+5][2][MAXN];
namespace Z {
	int pre_in[MAXN],pre_out[MAXN];
	void update(int u,int v) {
		int id=bel[u];
		pre_in[id]+=v,pre_out[u]+=v;
		return ;	
	}
	int query(int u) {
		int ans=0;
		ffor(j,1,bel[u]-1) ans+=pre_in[j];
		ffor(j,L[bel[u]],u) ans+=pre_out[j];
		return ans;	
	}
	void add(int l,int r,int val) {
		return update(l,val),update(r+1,-val),void();
	}
};
int rt,tot,dfn[MAXN],ls[MAXN],rs[MAXN],sze[MAXN],flg[MAXN],ori[MAXN];
void dfs(int u) {
	sze[u]=1,dfn[u]=++tot;
	if(ls[u]) dfs(ls[u]),sze[u]+=sze[ls[u]];
	ori[rs[u]]+=sze[ls[u]];
	if(rs[u]) dfs(rs[u]),sze[u]+=sze[rs[u]];
	return ;
}
void DFS(int u) {
	ori[ls[u]]+=ori[u],ori[rs[u]]+=ori[u];
	if(ls[u]) DFS(ls[u]);
	if(rs[u]) DFS(rs[u]);
	return ;	
}
int calc_col(int u) {
	if(tag[bel[u]]!=114514) return tag[bel[u]];
	return op[u];	
}
void push_down(int id) {
	if(tag[id]==114514) return ;
	ffor(u,L[id],R[id]) {
		op[u]=tag[id];	
		if(op[u]==-1) {
			if(ls[u]) Z::add(dfn[ls[u]],dfn[ls[u]]+sze[ls[u]]-1,1);
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,1);
		}
		else if(op[u]==0) {
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,1);
		}
	}
	tag[id]=114514;
	return ;
}
void push_up(int id) {
	if(tag[id]!=114514) return ;
	ffor(u,L[id],R[id]) {
		if(op[u]==-1) {
			if(ls[u]) Z::add(dfn[ls[u]],dfn[ls[u]]+sze[ls[u]]-1,-1);
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,-1);
		}
		else if(op[u]==0) {
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,-1);
		}
	}
	return ;
}
int query_block(int id,int u) {
	if(tag[id]==-1) return impact[id][0][dfn[u]];
	if(tag[id]==0) return impact[id][1][dfn[u]];
	return 0;
}
void update_block(int id,int col) {
	push_up(id),tag[id]=col;
	return ;	
}
void update_point(int l,int r,int col) {
	push_down(bel[l]);
	ffor(u,l,r) {
		if(op[u]==-1) {
			if(ls[u]) Z::add(dfn[ls[u]],dfn[ls[u]]+sze[ls[u]]-1,-1);
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,-1);
		}
		else if(op[u]==0) {
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,-1);
		}
		op[u]=col;
		if(op[u]==-1) {
			if(ls[u]) Z::add(dfn[ls[u]],dfn[ls[u]]+sze[ls[u]]-1,1);
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,1);
		}
		else if(op[u]==0) {
			if(rs[u]) Z::add(dfn[rs[u]],dfn[rs[u]]+sze[rs[u]]-1,1);
		}
	}
	return ;
}
void update(int l,int r,int col) {
	if(bel[l]==bel[r]) return update_point(l,r,col),void();
	update_point(l,R[bel[l]],col),update_point(L[bel[r]],r,col);
	ffor(id,bel[l]+1,bel[r]-1) update_block(id,col);
	return ;
}
int query(int u) {
	int ans=ori[u]+1;
	ffor(i,1,k) ans+=query_block(i,u);
	int col=calc_col(u);
	if(col==0) ans+=sze[ls[u]];
	else if(col==1) ans+=sze[ls[u]]+sze[rs[u]];
	return ans+Z::query(dfn[u]);
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q,k=(n-1)/B+1;
	ffor(i,1,k) L[i]=R[i-1]+1,R[i]=i*B;
	R[k]=min(R[k],n);
	ffor(i,1,k) ffor(j,L[i],R[i]) bel[j]=i;
	ffor(i,1,n) cin>>ls[i]>>rs[i],flg[ls[i]]=flg[rs[i]]=1;
	ffor(i,1,n) if(!flg[i]) rt=i;
	dfs(rt),DFS(rt);
	memset(tag,-1,sizeof(tag));
	//tag 如果是 114514 就说明寄了
	ffor(id,1,k) {
		ffor(j,L[id],R[id]) {
			int u=j;
			if(ls[u]) impact[id][0][dfn[ls[u]]]++,impact[id][0][dfn[ls[u]]+sze[ls[u]]]--;
			if(rs[u]) impact[id][0][dfn[rs[u]]]++,impact[id][0][dfn[rs[u]]+sze[rs[u]]]--,impact[id][1][dfn[rs[u]]]++,impact[id][1][dfn[rs[u]]+sze[rs[u]]]--;
		}
		ffor(j,1,n) impact[id][0][j]+=impact[id][0][j-1],impact[id][1][j]+=impact[id][1][j-1];
	}
	ffor(i,1,q) {
		int op;
		cin>>op;
		if(op==1) {
			int l,r,col;
			cin>>l>>r>>col,update(l,r,col);
		}
		else {
			int u;
			cin>>u;
			cout<<query(u)<<'\n';	
		}
	}
	return 0;
}
```

---

## 作者：_ANIG_ (赞：0)

求 $x$ 在遍历序列中的位置，等价于求有多少个点在 $x$ 前被遍历。

考虑一下哪些情况下 $y$ 会比 $x$ 早遍历。

分别用 $lson(x)$ 和 $rson(x)$ 表示 $x$ 的左右子树，用 $sub(x)$ 表示 $x$ 的子树，$op_x\in\{-1,0,1\}$ 表示 $x$ 的遍历方式，不难发现只有以下几种情况：

- $y\in lson(x)，op_x=-1$。

- 存在 $z$，使得 $y\in lson(z),x\in rson(z)$。

- $x\in sub(y),op_y=-1$。

- $x\in rson(y),op_y=0$。

考虑把这四类分开计算贡献。

首先，前两类可以直接预处理。

对于后两类，考虑按编号分块，处理每个 $y$ 对 $x$ 的贡献。

由于只有区间赋值操作，所以可以把所有块分为两类：第一类为整个块所有点的遍历方式相同的块，第二类为其它块。

分别考虑两类块对 $x$ 的贡献。

可以发现，第一类块对 $x$ 的贡献只需要知道这个块内有多少 $y$，满足 $y$ 是 $x$ 的祖先，和有多少 $y$，满足 $x$ 在 $y$ 的右子树内。

考虑枚举 $y$，然后就相当于若干次子树加，直接差分前缀和即可 $O(n\sqrt n)$。

设 $f_x$ 为所有第二类块内的点对 $x$ 的贡献之和。

如果只有单点修改，可以发现修改一个点会对这个点的子树或右子树的 $f_x$ 产生影响。

由于只存在区间赋值操作，所以每次操作最多新增 
$2$ 个二类块，在修改的时候如果遇到二类块就直接遍历这个块，然后把这个块变成一类块。

这样总共会有 $O(n\sqrt n)$ 次单点修改，$O(n)$ 次查询，写个 $O(1)-O(\sqrt n)$ 的分块平衡一下，总复杂度 $O(n\sqrt n)$。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5,T=350,M=N/T+5;
int n,m,son[N][2],idx,dfn[N],em[N],eds[N],dy[N],siz[N],bh[N],st[N],ed[N],smk[N],smz[N],g1[M][N],g2[M][N],mk[N];
void dfs(int x){
	siz[x]=1;
	dfn[x]=++idx;
	if(son[x][0])dfs(son[x][0]),siz[x]+=siz[son[x][0]];
	em[x]=idx;
	if(son[x][1])dfs(son[x][1]),siz[x]+=siz[son[x][1]];
	eds[x]=idx;
}
void add(int x,int sm){
	smk[bh[x]]+=sm;
	smz[x]+=sm;
}
void add(int l,int r,int sm){
	add(l,sm);
	add(r+1,-sm);
}
int gets(int x){
	int res=0;
	for(int i=1;i<bh[x];i++)res+=smk[i];
	for(int i=st[bh[x]];i<=x;i++)res+=smz[i];
	return res;
}
int solve(int x){
	int res=1+gets(dfn[x]);
	int k=dy[x];
	if(mk[bh[x]]!=2)k=mk[bh[x]];
	if(k==0)res+=siz[son[x][0]];
	if(k==1)res+=siz[son[x][0]]+siz[son[x][1]];
	for(int i=1;i<=bh[n];i++){
		if(mk[i]==2)continue;
		if(mk[i]==-1)res+=g1[i][dfn[x]];
		if(mk[i]==0)res+=g2[i][dfn[x]];
	}
	return res;
}
void upt(int x,int op){
	if(dy[x]==-1)add(dfn[x]+1,eds[x],op);
	if(dy[x]==0)add(em[x]+1,eds[x],op);
}
void Sets(int l,int r,int x){
	int y=bh[l];
	if(mk[y]!=2){
		for(int i=st[y];i<=ed[y];i++)dy[i]=mk[y];
		for(int i=l;i<=r;i++)dy[i]=x;
		for(int i=st[y];i<=ed[y];i++)upt(i,1);
		mk[y]=2;
	}else{
		for(int i=l;i<=r;i++){
			upt(i,-1);
			dy[i]=x;
			upt(i,1);
		}
	}
}
void sets(int l,int r,int x){
	if(bh[l]==bh[r]){
		Sets(l,r,x);
		return;
	}
	int ll=bh[l]+1,rr=bh[r]-1;
	Sets(l,st[ll]-1,x);
	Sets(ed[rr]+1,r,x);
	for(int i=ll;i<=rr;i++){
		if(mk[i]==2)for(int j=st[i];j<=ed[i];j++)upt(j,-1);
		mk[i]=x;
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>son[i][0]>>son[i][1];
		dy[i]=-1;
		bh[i]=(i-1)/T+1;
	}
	for(int i=1;i<=bh[n];i++)mk[i]=2,st[i]=ed[i-1]+1,ed[i]=min(i*T,n);
	dfs(1);
	for(int i=1;i<=n;i++){
		upt(i,1);
		add(em[i]+1,eds[i],siz[son[i][0]]);
		g1[bh[i]][dfn[i]+1]++;
		g1[bh[i]][eds[i]+1]--;
		g2[bh[i]][em[i]+1]++;
		g2[bh[i]][eds[i]+1]--;
	}
	for(int i=1;i<=bh[n];i++){
		for(int j=1;j<=n;j++)g1[i][j]+=g1[i][j-1],g2[i][j]+=g2[i][j-1];
	}
	while(m--){
		int op,l,r,x;
		cin>>op;
		if(op==1){
			cin>>l>>r>>x;
			sets(l,r,x);
		}else{
			cin>>x;
			cout<<solve(x)<<"\n";
		}
	}
}
```

---


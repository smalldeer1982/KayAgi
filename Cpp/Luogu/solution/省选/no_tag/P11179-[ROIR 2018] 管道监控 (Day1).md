# [ROIR 2018] 管道监控 (Day1)

## 题目描述

**译自 ROI 2018 Regional. Day1 T4.** ***[Мониторинг труб](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day1.pdf)***

某输气系统包含 $n$ 个节点，编号分别为 $1\ldots n$，某些节点间有单向管道连接。$1$ 号节点是中央储气设施。

节点系统可用数列 $p_2,$ $p_3,$ $\ldots,$ $p_n$ 来表示。对于 $i\in[\;\!2,n\;\!],$ $p_i$ 号节点会有一条通向 $i$ 号节点的单向管道。已知中央储气设施可以将气体输送到系统中的所有节点。输气系统包含不同种类的管道，用英文小写字母 $\texttt{a}\sim\texttt{z}$ 来表示。$p_i$ 号节点通向 $i$ 号节点的管道的类型为 $c_i$。

有一种特殊的机器人被用来检查管道的质量。我们把「机器人从一个节点沿着一根管道前行到另一个节点，且机器人前进方向与气体方向一致」称作「一次移动」。

机器人会先被放在一个节点中，然后它会进行一次或多次移动，最后被人从输气系统中取出。这被称为「机器人进行了一次执勤」。

每次执勤时都需遵循 $m$ 种「规格」中的其中一种，这些规格的编号分别为 $1\ldots m$。每种规格都用一个由英文小写字母组成的字符串 $st_k$ 来表示。如果在一次执勤中机器人遵循了 $k$ 号规范，则在这次执勤中，机器人移动的次数与 $\mathrm{len}(st_k)$ 相等，并且对于 $j\in[1,\mathrm{len}(st_k)],$ $st_{k\:\!,\;\!j}$ 等于机器人第 $j$ 次经过的管道的类型。

若某次执勤遵循了 $t$ 号规格，则这次的花费为 $w_t$。

请问，要想让所有的管道都至少被检查一次，至少需要花费多少钱，并给出执勤路线的方案。


## 说明/提示

### 样例 2 解释

![kxhEVg.png](https://s2.ax1x.com/2019/03/07/kxhEVg.png)

### 数据范围

对于所有数据，$1 ≤ n ≤ 500,$ $1 ≤ m ≤ 10^5,$ $t=0$ 或 $1,$ $1 ≤ p_i ≤ i-1,$ $1 ≤ w_i ≤ 10^9,$ $\sum \mathrm{len}(st_k) ≤ 10^6$.

|子任务 #|分值|$n≤$|$m≤$|特殊条件|$t$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|9|$500$| $10^5$|$\mathrm{len}(st_i)=1$|$t = 0$|
|2|10|$500$| $10^5$|$p_i=i-1$|$t = 0$|
|3|22|$15$| $10^5$||$t = 0$||
|4|20|$500$| $500$|&nbsp;|$t = 0$|
|5|19|$500$| $10^5$||$t = 0$|
|6|20|$500$| $10^5$|&nbsp;|$t = 1$|

## 样例 #1

### 输入

```
3 3 0
1 a
2 b
3 a
4 b
2 a```

### 输出

```
6```

## 样例 #2

### 输入

```
7 3 1
1 a
2 a
3 b
3 b
1 b
6 b
3 aab
5 b
2 ab```

### 输出

```
15
4
1 4 1
2 5 3
1 6 2
6 7 2```

# 题解

## 作者：kkxacj (赞：7)

#### 前言

应发电机要求，感谢[发电机](https://www.luogu.com.cn/user/656765)发的电和思路。

#### 思路

根据题目描述，我们需要遍历的点是一条从祖先到儿子的链，但如果这样覆盖就不好统计哪些点未遍历，考虑反过来，即以**从儿子到祖先**的方式来遍历，这样只需要保证以 $i$ 的为根的子树都被遍历时，能往上 $j$ 次的最小代价就行了。

对于输入的 $m$ 种操作，我们将串 $s$ 翻转，然后用 `map` 存串为 $x$ 时的最小代价和编号，特殊的，我们额外给 $1$ 这个点赋一个特殊符号，然后将这个特殊符号代价赋值为 $-1$，这是因为这种情况不算操作数，方便特判。

注意到 $n \le 500$，我们的只需要时间复杂度在 $n^3$ 以内即可，直接设 $f_{i,j}$ 表示以 $i$ 为根的子树都被覆盖且还可以**从 $i$ 开始**向上覆盖 $j$ 个数，也就是若 $1 \le j$，则会覆盖从它父亲开始的 $j-1$ 个祖先，我们先考虑 $t=0$ 的情况。

对于合并，我们直接 $n^2$ 合并，设 $v$ 为 $i$ 的儿子，若 $v$ 是第一个遍历到的儿子，则 $g_{i,j} = f_{v,j}
$，否则 $g_{i,\max\left(j,z-1\right)} = \min\left(g_{i,\max\left(j,z-1\right)},f_{i,j}+f_{v,z}\right)$，每次合并后 $f_{i,j}=g_{i,j}$。

合并完后，一直跳祖先得到一个字符串，若有这种操作，就尝试更新。

对于判无解情况，我们可以给初值赋为一个很大的数，若最终值大于等于这个很大的数，就说明无解。

给出 $t=0$ 的代码供参考[look](https://www.luogu.com.cn/paste/wlwuemy1)。

对于 $t=1$，我们可以开 `vector` 来记录，$v_{i,j}$ 表示在此状态下的操作集合，在合并时，记录一下从哪两个地方转过来的，在最后合并就可以保证复杂度正确，合并完后的操作也同理。

**code**
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 510,M = 1e5+10;
int n,m,t,x,y,cnt,head[N],f[N][N],dep[N],g[N][N],id[N][N],id1[N][N],id2[N][N],id3[N][N],l,r,fa[N],o,o1,o2;
map<string,int>mp,mp1;
vector<pair<int,pair<int,int> > >v[N][N],v1[N][N];//可以写一个struct，但我懒了 
pair<int,pair<int,int> >X;
struct w
{
	int to,nxt;
}b[M<<1];
char c[N];
string s;
inline void add(int x,int y)
{
	b[++cnt].nxt = head[x];
	b[cnt].to = y;
	head[x] = cnt;
}
void dfs(int x,int y)
{
	dep[x] = dep[y]+1;  fa[x] = y;
	for(int i = 0;i <= dep[x];i++) f[x][i] = 1e15;//赋初值 
	for(int i = head[x];i;i = b[i].nxt)
	{
		dfs(b[i].to,x);
		for(int j = 0;j <= dep[x];j++) id[x][j] = id1[x][j] = 0,v1[x][j].clear(),g[x][j] = 1e15;
		if(i == head[x])
		{
			for(int z = 1;z <= dep[b[i].to];z++) id[x][z-1] = b[i].to,id1[x][z-1] = z,g[x][z-1] = min(g[x][z-1],f[b[i].to][z]);
		}
		else
		{
			for(int j = 0;j <= dep[x];j++) 
				for(int z = 1;z <= dep[b[i].to];z++)
					if(f[x][j]+f[b[i].to][z] < g[x][max(j,z-1)])
					{
						g[x][max(j,z-1)] = min(g[x][max(j,z-1)],f[x][j]+f[b[i].to][z]);
						id[x][max(j,z-1)] = b[i].to,id1[x][max(j,z-1)] = z;
						id2[x][max(j,z-1)] = x,id3[x][max(j,z-1)] = j;//记录位置 
					}
		}
		for(int j = 0;j <= dep[x];j++) //最后更新保证复杂度 
		{
			if(id[x][j])
				for(int o = 0;o < v[id[x][j]][id1[x][j]].size();o++) 
					v1[x][j].push_back(v[id[x][j]][id1[x][j]][o]);
			if(id2[x][j])
				for(int o = 0;o < v[id2[x][j]][id3[x][j]].size();o++) 
					v1[x][j].push_back(v[id2[x][j]][id3[x][j]][o]);
		}
		for(int j = 0;j <= dep[x];j++) v[x][j] = v1[x][j],f[x][j] = g[x][j];
	}
	if(head[x] == 0) f[x][0] = 0;
	o = x,o1 = f[x][0],o2 = 0; s = "";
	for(int i = 1;i <= dep[x];i++) 
	{
		s += c[o]; 
		if(mp[s] == -1 && o1 < f[x][i]) v[x][i] = v[x][o2],f[x][i] = min(o1,f[x][i]); //芝士特殊情况，不用加这次操作（因为1不用遍历） 
		if(mp[s] != 0 && mp[s]+o1 < f[x][i]) v[x][i] = v[x][o2],v[x][i].push_back(make_pair(fa[o],make_pair(x,mp1[s]))),f[x][i] = min(o1+mp[s],f[x][i]);//更新，加入一次新的操作 
		if(f[x][i] < o1) o2 = i,o1 = min(f[x][i],o1);
		o = fa[o];
	}
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m),read(t); c[1] = '0';
	for(int i = 2;i <= n;i++) read(x),cin>>c[i],add(x,i); 
	mp["0"] = -1;
	for(int i = 1;i <= m;i++)
	{
		read(x),cin>>s; l = 0,r = s.size()-1;
		while(l<r) swap(s[l],s[r]),l++,r--;
		if(!mp[s]) mp[s] = x,mp1[s] = i;
		else if(mp[s] > x) mp[s] = x,mp1[s] = i;
	}
	dfs(1,0);
	if(f[1][0] >= 1e15) f[1][0] = -1;//无解 
	print(f[1][0]);  flush(); 
	if(t == 1 && f[1][0] != -1) 
	{
		pc('\n');
		print(v[1][0].size()),pc('\n');
		for(int i = 0;i < v[1][0].size();i++)
			print(v[1][0][i].first),pc(' '),print(v[1][0][i].second.first),pc(' '),print(v[1][0][i].second.second),pc('\n'); 
		flush(); 
	}
	return 0;
}
/*
f_i_j以i为子树，向上j个最小花费 
*/
```

---

## 作者：STARSczy (赞：5)

# 题解：P11179 [ROIR 2018 Day1] 管道监控

秒秒题。没有题解呢，来发一发。~~建议降蓝~~。

### 思路
发现往下匹配路径不好处理，于是反转每个路线的字符串，然后从下往上移动覆盖，这样定了一个方向。

若只输出最小值，就从下往上 dp，发现可以 $n^3$ 处理，猜测正解设两维状态，$\Theta(n)$ 合并。第一维肯定是当前节点 $x$ 为根的子树内的所有边都被覆盖完，第二维容易想到是节点 $x$ 往上的 $k$ 个节点也被覆盖到了。设当前节点有儿子 $u$，容易有转移：$f_{x,\max(i,j)} \to f_{x,i}+f_{u,j+1} $，转移方式为取 $\min$。

于是直接 dp 即可。如果要输出方案，直接对于每个状态存储方案，由于最终路线 $n$ 条就可以覆盖完，所以可以直接存储。

### 代码：
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/rope>
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
#define int long long
#define double long double
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define rbtree(way) tree<way,null_type,less<way>,rb_tree_tag,tree_order_statistics_node_update>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
const int maxn=500+10,maxm=1e5+10,mod=998244353,inf=1e15;
inline int ksm(int x,int k,int mod=mod){
	int ans=1;
	for(;k;k>>=1,x=x*x%mod) if(k&1) ans=ans*x%mod;
	return ans;
}

int n,m,opt,tot=1,fa[maxn],g[maxn],dep[maxn],f[maxn][maxn],tr[maxm*10][30];
pii ed[maxm*10];
vector<pii> dp[maxn][maxn],rmg[maxn];
char c[maxn];
vector<int> e[maxn];
string s[maxm];
void dfs(int x){
	rep(i,1,dep[x]) f[x][i]=inf;
	for(int u:e[x]){
		dep[u]=dep[x]+1,dfs(u);
		rep(i,0,n) g[i]=f[x][i],rmg[i]=dp[x][i],f[x][i]=inf,dp[x][i].clear();
		rep(i,0,dep[x]) rep(j,0,dep[x]) f[x][max(i,j)]=min(f[x][max(i,j)],g[i]+f[u][j+1]);
		rep(i,0,dep[x]) rep(j,0,dep[x]) if(f[x][max(i,j)]<inf&&f[x][max(i,j)]==g[i]+f[u][j+1]&&
			!dp[x][max(i,j)].size()) dp[x][max(i,j)]=rmg[i],
			dp[x][max(i,j)].insert(dp[x][max(i,j)].end(),dp[u][j+1].begin(),dp[u][j+1].end());
	}
	for(int i=x,k=0,nw=1,tmp=0;i&&nw;nw=tr[nw][c[i]-'a'],i=fa[i],++k){
		if(ed[nw].fi+f[x][tmp]<f[x][k])
			f[x][k]=ed[nw].fi+f[x][tmp],dp[x][k]=dp[x][tmp],dp[x][k].pb({x,ed[nw].se});
		if(f[x][k]<f[x][tmp]) tmp=k;
	}
}

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>opt;
	rep(i,2,n) cin>>fa[i]>>c[i],e[fa[i]].pb(i);
	rep(i,1,m){
		int val,nw=1;
		cin>>val>>s[i],reverse(s[i].begin(),s[i].end());
		for(char c:s[i]) !tr[nw][c-'a']?ed[tr[nw][c-'a']=++tot]={inf,0},0:0,nw=tr[nw][c-'a'];
		ed[nw]=min(ed[nw],{val,i});
	}
	dfs(1);
	if(f[1][0]>=inf) return cout<<-1,0;
	cout<<f[1][0]<<'\n';
	if(opt==1){
		cout<<dp[1][0].size()<<'\n';
		for(pii x:dp[1][0]){
			int k=x.fi;
			rep(i,1,s[x.se].size()) k=fa[k];
			cout<<k<<" "<<x.fi<<" "<<x.se<<"\n";
		}
	}
	return 0;
}
```

---


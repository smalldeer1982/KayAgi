# [ROIR 2018] 大数据处理 (Day2)

## 题目描述

**译自 ROI 2018 Regional. Day2 T4.** ***[Обработка больших данных](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day2.pdf)***

某实验室正在研发一种能处理大规模数据的新型超级计算机。

这台超算的内存包含 $2^k$ 个存储单元，依次编号为 $0\ldots 2^k-1.$ 用内存段 $[L,R]$ 表示编号 $≥L$ 且 $≤R$ 的所有存储单元，该内存段的长度为 $R-L+1.$

定义：如果内存段 $[L,R]$ 的长度是 $2$ 的整数次幂（不妨假设是 $2^i$），且 $L$ 是 $2^i$ 的整数倍，那么这个内存段是「正确的内存段」。

若 $k=3,$ 则正确的内存段为 $[0,7],$ $[0,3],$ $[4,7],$ $[0,1],$ $[2,3],$ $[4,5],$ $[6,7],$ $[0,0],$ $[1,1],$ $[2,2],$ $[3,3],$ $[4,4],$ $[5,5],$ $[6,6]$ 和 $[7,7].$

现在，每个存储单元所存储的值均为 0. 你需要给每个存储单元赋值。简单起见，我们用游程编码的形式给出每个单元上的值。开头的 $c_1$ 个单元中存储的值为 $v_1,$ 接下来 $c_2$ 个单元中存储的的值为 $v_2,$ 以此类推，最后的 $c_n$ 个单元中存储的值为 $c_n,$ $1≤v_i≤m.$

举个例子，如果 $k = 3,$ $n = 3,$ $m = 2,$ $c = \{1,$ $2,$ $5\},$ $v = \{1,$ $2,$ $1\},$ 那么内存将被赋值为 $[1,$ $2,$ $2,$ $1,$ $1,$ $1,$ $1,$ $1].$

你只有一种方法给单元赋值：$\mathtt{STORE}([l,r],x).$ 该函数表示将内存段 $[l,r]$ 中所有单元全部赋值为 $x.$ 注意，$[l,r]$ 必须是合法的内存段。

试求至少需要多少次操作才能达成要求。

## 说明/提示

### 样例解释

目标：$[1, 2, 2, 1, 1, 1, 1, 1]$
- $\mathtt{STORE}([0, 7], 1),$ 得到 $[1, 1, 1, 1, 1, 1, 1, 1];$
- $\mathtt{STORE}([1, 1], 2),$ 得到 $[1, 2, 1, 1, 1, 1, 1, 1];$
- $\mathtt{STORE}([2, 2], 2),$ 得到 $[1, 2, 2, 1, 1, 1, 1, 1].$

### 数据范围

$0 ≤ k ≤ 30,$ $1 ≤ n ≤ 10^5,$ $1 ≤ m ≤ 10^9.$

|子任务编号|分值|$k\le $|$k\le$|$m\le$|
|:-:|:-:|:-:|:-:|:-:|
|1|15|$3$|$8$|&nbsp;$8$&nbsp;|
|2|&nbsp;15&nbsp;|$19$| |$10$|
|3|15| | |$10$|
|4|10| | |$50$|
|5|15|$19$| | |
|6|30| | | |

## 样例 #1

### 输入

```
3 3 2
1 1
2 2
5 1```

### 输出

```
3```

# 题解

## 作者：MightZero (赞：3)

原问题直接做显然是不好处理的，考虑做如下转化：给定一个指定的内存段（即题目条件中 $c_i,v_i$ 所表示的内存段），每次选择一个**所有元素都相同**的合法序列并修改整个序列为某个值，求将整个内存段修改为全 $0$ 的最小操作次数。由于修改为 $0$ 在最优方案中必然是在最后一步修改整个内存段，因此只需要考虑将将整个内存段所有元素修改为相同值所需要的最小操作次数。

注意到题目给出的合法区间本质上可以看作一棵范围 $[0,2^k-1]$ 的线段树的某个节点，考虑建线段树；但是树的深度比较大，需要动态开点。建树时将每个 $c_i,v_i$ 对应的区间插入线段树即可。

对于每个线段树上的节点，可以维护一个集合 $S_x$ 表示**在最优操作次数下**将当前节点对应区间所有元素修改为相同值时，这一相同值所有可能的取值；  

遍历整棵线段树，考虑如何合并节点的左右儿子的 $S_x$：

- 若 $S_{lson} \cap S_{rson} = \emptyset$，那么必须修改其中一个儿子对应区间的值才能满足条件，此时将 $ans+1$；由于可以将一个儿子的值修改为另一个儿子取值集合中的任意元素，最终可能的取值集合 $S_x = S_{lson} \cup S_{rson}$

- 若 $S_{lson} \cap S_{rson} \neq \emptyset$，此时不需要修改，$ans$ 不变，$S_x = S_{lson} \cap S_{rson}$。

说明：若某个节点 $x$ 处 $S_{lson_x} \cap S_{rson_x} \neq \emptyset$，这个节点的儿子可以修改也可以不修改；但是本题中需要考虑的是最小操作次数，如果这一结点的某个祖先 $x'$ 处必须修改，即 $S_{lson_{x'}} \cap S_{rson_{x'}} = \emptyset$，注意到在 $x'$ 处修改儿子对于在 $x$ 处修改儿子是**必然不劣**的，因此**只在必须修改的时候修改儿子**可保证答案最优。 

具体实现上可以使用 `std::set` 或者 `std::vector` 维护集合，输出 $ans$ 时记得 $+1$。

---

## 作者：MessageBoxA (赞：2)

# 前言

很妙很~~感性~~直观的贪心，做完神清气爽。

# 题意

[Link](https://www.luogu.com.cn/problem/P11183)

有一个长为 $2^k$ 的序列，编号从 $0$ 开始，你要在上面染色，每次只能染色 $[k2^i,(k+1)2^i-1]$ 的区间（$0\leq i<k$），问最少要染色多少次才能变成给定的目标序列。目标序列以形如 $(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)$ 的格式给出，表示从 $0$ 开始有长为 $x_1$ 的颜色为 $y_1$ 的段，然后长为 $x_2$ 颜色为 $y_2$ 的段，以此类推。

$k\leq 30$，$n\leq 10^5$。

# 思路

不难发现合法的染色区间其实就是原序列建出的线段树上的某个节点，于是问题转化为了在线段树上选一些点染色，每个叶子节点的颜色为距离它最近的被染色节点的颜色。为什么是距离最近的？因为我们肯定是先染长的段再染短的段最优（否则，先染短的就可能被后染的长的覆盖），对应线段树上就是先染浅的节点再染深的节点。

于是我们对**目标序列**建出一颗线段树，但是本题的空间肯定不允许我们建完整的线段树，可以考虑动态开点，假设当前节点对应的区间都是同一种颜色，就可以停止继续往下建了。这样建树在 `update` 一次时最多涉及 $\log_2(2^k)=k$ 个节点，因此时空复杂度均为 $O(nk)$。

> 注意：这样建出的线段树仍然满足普通线段树“要么没有儿子，要么有两个儿子”的性质，不存在只有左儿子或右儿子的情况。

接下来就在线段树上贪心，我们给每个节点开一个集合，意为“该节点所代表区间在最优策略下，如果被染色，那么可能染成的颜色”。首先叶子节点的集合肯定就只有它自己的颜色，$ans=1$。而对于非叶子节点，我们取它左右儿子的交集，如果这个交集不为空，我们就可以在这些颜色当中选一个作为当前区间的颜色，因此当前节点的集合为这个交集，且 $ans$ 为 $ans_{lch}+ans_{rch}-1$；如果交集为空，那么当前节点为左右儿子并集，且 $ans$ 为 $ans_{lch}+ans_{rch}$。

这是什么意思呢？当左右孩子中有交集时，说明左右孩子都存在某个区间染的颜色相同，因此直接在当前节点染而不是在左右孩子分别染，可以节省一次操作，由于在此处染色会“阻断”更上方的染色，因此交集外的颜色不用再被考虑。如果没有交集，那么该节点染成什么也不会更优，打包取并集交给更上方的节点处理。

还有一个问题，所谓这样的“阻断”会使得贪心错误吗？实际上是不会的，假设某处本应该取交集但取了并集，导致祖先某处应该取并集却取了交集，相当于为了一个小段，去染色了一个本该是其他颜色的大段，这一定是不优的。

> 例：
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/ak45wk1u.png)
>
> 可自行尝试将上图黄圈所示部分本来取交集（蓝）改为取并集（红+蓝），答案变劣。

# 代码

这里介绍一下 STL 的科技 `set_intersection` 和 `set_union`，当然还有个 `set_difference`，但此处没用到。

`set_intersection(a.begin(),a.end(),b.end(),b.end(),inserter(c,c.begin()))` 表示求 `a` 与 `b` 的交集存放到 `c` 中，其他两个同理。而且其时间复杂度为**线性**的，~~太伟大了 STL~~。

```cpp
#define getmid int mid=(l+r)/2
int K,n,m,full;
struct Node{
    Node *lch,*rch;
    int t,ans;
    set<int>s;
    Node(){
        lch=rch=nullptr;
        t=-1;
        ans=0;
    }
};
Node* rt=nullptr;
void update(Node* &pos,int l,int r,int ll,int rr,int col){
    if(pos==nullptr) pos=new Node;
    if(ll<=l && r<=rr){
        pos->t=col;
        return;
    }
    getmid;
    if(ll<=mid) update(pos->lch,l,mid,ll,rr,col);
    if(mid<rr) update(pos->rch,mid+1,r,ll,rr,col);
}
void solve(Node* pos){
    if(pos->lch==nullptr){
        assert(pos->rch==nullptr);
        pos->s.insert(pos->t);
        pos->ans=1;
        return;
    }
    else{
        solve(pos->lch);solve(pos->rch);
        pos->ans=pos->lch->ans+pos->rch->ans;
        set_intersection(pos->lch->s.begin(),pos->lch->s.end(),
                         pos->rch->s.begin(),pos->rch->s.end(),
                         inserter(pos->s,pos->s.begin()));
        if(!pos->s.empty()){
            pos->ans--;
            return;
        }
        pos->s.clear();
        set_union(pos->lch->s.begin(),pos->lch->s.end(),
                  pos->rch->s.begin(),pos->rch->s.end(),
                  inserter(pos->s,pos->s.begin()));
    }
}
int main(){
    rd(K);rd(n);rd(m);
    full=(1<<K)-1;
    for(int i=1,x,y,l=0;i<=n;i++){
        rd(x);rd(y);
        update(rt,0,full,l,l+x-1,y);
        l+=x;
    }
    assert(rt);
    solve(rt);
    wt(rt->ans);
    return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

考虑题目中的颜色段组成的动态开点线段树。

如果我们覆盖了区间 $u$，就不可能覆盖他的任何一个父区间 $f$。因此我们相当于制定线段树上若干个节点进行颜色覆盖，每个点的颜色就是离他最近的覆盖的颜色。

很容易设计 $O(nkm)$ 的 DP：

设 $dp_{u,col}$ 为 $u$ 节点最近的颜色覆盖为 $col$，想要它的所有子节点都满足要求，它的儿子们最多还要进行多少次**额外的覆盖**。得到：

$$
dp_{u,col} = \min_{j} \{dp_{ls_u,j}+[col \neq j]\} + \min_{j} \{dp_{rs_u,j}+[col \neq j]\}
$$

特别的，当 $u$ 是叶子节点的时候，只有 $dp_{u,col_u}$ 不是 $+ \infty$；若 $col \neq 0$ 那么 $j$ 不能是 $0$。

考虑优化。显然 $col$ 必须在 $u$ 的子树中出现过，状态数直接转化为 $O(nk)$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10,MAXM=3e6+10;
int k,n,m,rt,tot,c[MAXN],v[MAXN],flg[MAXM],ls[MAXM],rs[MAXM];
map<int,int> dp[MAXM];
vector<int> occ[MAXM];
#define mid (l+r>>1)
void update(int& k,int l,int r,int x,int y,int v) {
	if(!k) k=++tot;
	if(x<=l&&r<=y) return flg[k]=v,void();
	if(x<=mid) update(ls[k],l,mid,x,y,v);
	if(y>mid) update(rs[k],mid+1,r,x,y,v);
	return ;
}
void solve(int u) {
	occ[u].push_back(0);
	if(flg[u]) {
		occ[u].push_back(flg[u]);
		dp[u][flg[u]]=0;
		return ;
	}
	vector<pair<int,int>> ml,mr;
	solve(ls[u]),solve(rs[u]);
	for(auto pr:dp[ls[u]]) ml.push_back({pr.second,pr.first});
	for(auto pr:dp[rs[u]]) mr.push_back({pr.second,pr.first});
	for(auto id:occ[ls[u]]) occ[u].push_back(id);
	for(auto id:occ[rs[u]]) occ[u].push_back(id);
	sort(occ[u].begin(),occ[u].end()),occ[u].erase(unique(occ[u].begin(),occ[u].end()),occ[u].end());
	sort(ml.begin(),ml.end());
	sort(mr.begin(),mr.end());
	for(auto id:occ[u]) {
		int adl=INT_MAX,adr=INT_MAX;
		ffor(j,0,min((int)ml.size()-1,2)) {
			if(id&&!ml[j].second) continue ;
			adl=min(adl,ml[j].first+(ml[j].second!=id));
		}
		if(dp[ls[u]].count(id)) adl=min(adl,dp[ls[u]][id]);
		ffor(j,0,min((int)mr.size()-1,2)) {
			if(id&&!mr[j].second) continue ;
			adr=min(adr,mr[j].first+(mr[j].second!=id));
		}
		if(dp[rs[u]].count(id)) adr=min(adr,dp[rs[u]][id]);
		dp[u][id]=adl+adr;
	}
	dp[ls[u]].clear(),dp[rs[u]].clear(),occ[ls[u]].clear(),occ[rs[u]].clear();
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>k>>n>>m;
	ffor(i,1,n) cin>>c[i]>>v[i];
	int tmp=0;
	ffor(i,1,n) update(rt,0,(1<<k)-1,tmp,tmp+c[i]-1,v[i]),tmp+=c[i];
	solve(1);
	int mn=INT_MAX;
	for(auto pr:dp[1]) mn=min(mn,pr.second+!!pr.first);
	cout<<mn;
	return 0;
}
```

---

## 作者：GI录像机 (赞：0)

## 思路

对原序列建立线段树，发现所有合法的区间都是线段树上的结点。考虑在线段树上进行计算。

显然染色先染大段再染小段，所以顺序是确定的。

设 $dp_{pos,c}$ 表示在线段树结点 $pos$ 进行一次给对应区间全部染成 $c$ 操作使对应区间合法的最少操作数。

在建线段树时，如果已经访问到了只含一种颜色的区间，直接返回，此时显然 $dp_{pos,c} = 1$。这样访问到的结点只有 $nk$ 级别，使用动态开点线段树。

发现尽可能对大区间染色一定不劣，因为给 $lson$ 和 $rson$ 分别染色就等于对 $pos$ 染色再对其中一个儿子染色。

所以得到 dp 方程 $dp_{pos,c1}=\min dp_{lson,c1}+dp_{rson,c1}-1,dp_{lson,c1}+minn_{rson},dp_{rson,c1}+minn_{lson}$。

其中 $minn_{pos}=\min dp_{pos,c}$。

这样我们就有了一个 $O(n^2k)$ 的做法。

因为每次染大区间一定是染区间内目标序列包含的颜色，而每种颜色（假设所有 $v$ 互不相同）最多会出现在 $k$ 级别个区间内，所以对于每个 $pos$，只需要计算其包含颜色的 $dp$ 值即可。

实现优秀的话可以 $O(nk)$。

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
    int x = 0, f = 1;
    char c = getchar();
    while(c > '9' || c < '0') {
        if(c == '-')f = -f;
        c = getchar();
    }
    while(c <= '9' && c >= '0') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}
void write(int x) {
    if(x < 0) {
        putchar('-');
        x = -x;
    }
    if(x > 9)write(x / 10);
    putchar(x % 10 + '0');
}
const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7;
int tot, k, n, m, c[N], v[N], minn[N], rt, rem[N], cnt;
vector<int>dp[N];
vector<int>col[N];
map<int, int>mp;
struct Node {
	int lson, rson, c;
}a[(int)3e6 + 10];
void modify(int &pos, int l, int r, int L, int R, int co) {
	if(!pos)pos = ++tot;
	if(L <= l && r <= R) {
		a[pos].c = co;
		return;
	}
	int mid = (l + r) >> 1;
	if(L <= mid)modify(a[pos].lson, l, mid, L, R, co);
	if(mid + 1 <= R)modify(a[pos].rson, mid + 1, r, L, R, co);
}
void calc(int pos) {
	int now = ++tot, l, r;
	dp[now].clear(), col[now].clear();
	if(a[pos].c) {
		dp[tot].push_back(1);
		col[tot].push_back(a[pos].c);
		minn[tot] = 1;
		return;
	}
	minn[now] = INF;
	calc(a[pos].lson);
	l = tot;
	calc(a[pos].rson);
	r = tot;
	for(int i = 0; i < dp[l].size(); i++) {
		dp[now].push_back(dp[l][i] + minn[r]);
		col[now].push_back(col[l][i]);
		rem[col[l][i]] = i + 1;
		minn[now] = min(minn[now], dp[l][i] + minn[r]);
	}
	for(int i = 0; i < dp[r].size(); i++) {
		int id = rem[col[r][i]] - 1;
		if(id != -1) {
			dp[now][id] = min(dp[now][id], dp[r][i] + min(dp[l][id] - 1, minn[l]));
			minn[now] = min(minn[now], dp[now][id]);
		}
		else {
			dp[now].push_back(dp[r][i] + minn[l]);
			col[now].push_back(col[r][i]);
			minn[now] = min(minn[now], dp[r][i] + minn[l]);
		}
	}
	for(int i = 0; i < dp[l].size(); i++)rem[col[l][i]] = 0;
	tot = now;
}
signed main() {
	freopen("data.in", "r", stdin);
    freopen("data.out", "w", stdout);
    k = read(), n = read(), m = read();
    int l = 0, r = -1;
    for(int i = 1; i <= n; i++) {
    	c[i] = read(), v[i] = read();
    	r = l + c[i] - 1;
    	if(!mp[v[i]])mp[v[i]] = ++cnt;
    	modify(rt, 0, (1 << k) - 1, l, r, mp[v[i]]);
    	l = r + 1;
	}
	tot = 0;
	calc(rt);
	write(minn[1]);
    return 0;
}
```

---


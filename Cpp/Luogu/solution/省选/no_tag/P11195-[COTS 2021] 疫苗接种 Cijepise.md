# [COTS 2021] 疫苗接种 Cijepise

## 题目背景

译自 [Izborne Pripreme 2021 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2021/) D2T1。$\texttt{5s,1G}$。

## 题目描述


给定以 $1$ 为根的有 $N$ 个节点的有根树，记 $i$ 号点的点权为 $a_i$。

定义一次操作为：

- 初始化 $u$ 为树根。
	1. 设 $u$ 儿子中点权最大的点为 $v$（若有多个，则**等概率随机选取一个**）。令 $a_u\gets a_v$，$a_v\gets 0$。
	2. 若 $v$ 为叶子，则删去 $v$，终止这个过程。否则令 $u\gets v$，回到 1。

![](https://cdn.luogu.com.cn/upload/image_hosting/u6c8gliu.png)


定义 $f(v)$ 为：**在最坏情况下**，欲让 $a_v$ 尽可能快地（也就是使用尽量少的操作次数）出现在树根上，至少需要更改多少个点的点权（可以不更改）。

换句话说，我们定义在最坏情况下，$v$ 需要操作 $k$ 次到达树根。显然树的形态固定时，不同的点权会使得 $k$ 取不同的值，且 $k$ 存在一个下界。你需要修改若干个点的点权，使得 $k$ 取到下界，并最小化修改的数量。

点权可以被改为 $[0,2\times 10^9]$ 内的任意整数。


$Q$ 次询问给定 $v$，回答 $f(v)$。

## 说明/提示


对于 $100\%$ 的数据，保证 $1\le Q\le N\le 1\times 10^5$，$1\le a_i\le 10^9$，$1\le v\le N$，给出的是一棵树。

| 子任务编号 | $N\le $ |  特殊性质   | 得分 |  
| :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 12 $    |  无  | $ 10 $   |  
| $ 2 $    | $ 300 $   |  无 | $ 11 $   |  
| $ 3 $    | $ 3\,000 $ | 有  | $ 12 $   |  
| $ 4 $    | $ 3\,000 $  |  无 | $ 13 $   |  
| $ 5 $    | $ 100\,000 $  |   有 | $ 20 $   |  
| $ 6 $    | $ 100\,000 $  |   无 | $ 34 $   |  

特殊性质：$Q\le 1$。

## 样例 #1

### 输入

```
3
1 2 3
1 2
1 3
3
1
2
3```

### 输出

```
0
1
0```

## 样例 #2

### 输入

```
7
45 13 19 3 81 27 77
1 2
1 3
1 4
3 5
3 6
4 7
3
5
6
7```

### 输出

```
0
1
1```

## 样例 #3

### 输入

```
8
23 4 9 7 11 4 1 18
2 1
3 2
4 2
5 2
6 3
7 4
8 1
3
2
3
7```

### 输出

```
1
2
3```

# 题解

## 作者：harmis_yz (赞：0)

莫名其妙的题。

## 分析

首先这题不需要求没有修改时 $u$ 变成根的时间。要求的话大概是发现对于 $u$ 变到 $fa_u$ 所需的时间是它其它兄弟节点为根的子树中前缀最小值不小于 $val_u$ 的链的数量，然后处理一下。

但是这题需要我们让 $u$ 变到根的时间最短，那么这个时间一定是 $dep_u$。因为我们存在答案上界是将 $P(1,u)$ 全部修改成 $inf$，此时在 $u$ 变成根以前是不会选择其它节点的。模拟一下发现可能会影响到 $u$ 变成根的时间的点只会是 $u$ 到 $1$ 路径上所有点 $x_i$ 的兄弟节点。只要存在一种修改方式，使得路径任意一个前缀，都满足 $val_{x_i}> mx_{x_i}$ 就行了。其中 $mx_{x_i}$ 是 $x_i$ 到 $1$ 路径上所有点的兄弟节点中最大的价值。

定义状态函数 $f_u$ 表示让 $u$ 满足条件的最小代价。那么一定有 $f_v \in \{f_u,f_{u}+1\}[v\in son_u]$。那么对于 $v$ 来说，$f_v=f_u+1$ 一定是当前前缀路径上存在至少一个点 $x$ 的兄弟节点 $y$，满足 $val_y \ge val_v$。则对于 $v$ 来说，我们可以选择将 $val_v$ 变成 $inf$，对于 $v$ 的子树来说，可以选择将 $val_v$ 变成 $inf$ 或将 $val_y$ 变成 $0$。

如果 $val_y\ge val_v$ 的数量为 $1$。则可看作将 $val_v$ 变成 $inf$ 或将 $val_y$ 变成 $0$，此时将 $val_y$ 变成 $0$ 更优。

如果 $val_y \ge val_v$ 的数量大于 $1$。若 $v$ 子树点的最优策略均为 $val_w$ 变成 $inf$，则变不变 $val_y$ 无所谓。若存在 $w$ 的最优策略为删点，当 $val_w \le val_v$ 时，删的点要么是 $y$ 中的一个，要么是 $w$ 到 $v$ 路径上点的兄弟节点中的一个，后者和 $v$ 无关。当 $val_v < val_w$ 时，如果将 $val_y$ 变成 $0$，且满足 $val_y \ge val_w$，此时不劣。如果变成 $0$ 的点满足 $val_y < val_w$，那么支持 $w$ 的前提是将 $val_v$ 变成 $inf$，此时 $y$ 的变化可以看作将 $val_v$ 变成 $inf$，无影响。

把上面的情况取交集，发现我们可以改变第一个满足 $val_y \ge val_v$ 的点。

那么现在需要实现：快速加点或删点，快速查询第一个比 $x$ 大的数的值，快速查询比 $x$ 大的数的数量。可以任意维护，时间复杂度 $O(n\log n+q)$。

我说的是不是莫名奇妙的。

## 代码

```cpp
const int N=1e6+10;
int n,q;
int val[N],f[N];
vector<int> e[N];
multiset<int> st;

il void dfs(int u,int fa){
	for(auto v:e[u])
	if(v!=fa) st.insert(val[v]);
	for(auto v:e[u])
	if(v!=fa){
		st.erase(st.find(val[v]));
		auto it=st.lower_bound(val[v]);
		int x=(it==st.end()?-1:(*it));
		if(it!=st.end()) f[v]=f[u]+1,st.erase(st.find(x));
		else f[v]=f[u];
		dfs(v,u);
		if(~x) st.insert(x); 
		st.insert(val[v]);
	}
	for(auto v:e[u])
	if(v!=fa) st.erase(st.find(val[v]));	
}
 
il void solve(){
	n=rd;
	for(re int i=1;i<=n;++i) val[i]=rd;
	for(re int i=1;i< n;++i){
		int u=rd,v=rd;
		e[u].push_back(v),
		e[v].push_back(u);
	}
	dfs(1,0);
	q=rd;
	while(q--) cout<<f[rd]<<"\n";
    return ;
}
```

---


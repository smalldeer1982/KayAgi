# [GDKOI2023 普及组] 置换

## 题目描述

Moon 最近在玩一款名为 Shadowverse 的卡牌游戏，在非常有趣的游戏过程中，Moon 想到这样一个关于洗牌的问题。假设当前牌堆中有 $n$ 张牌，第 $i$ 张牌的标号为 $i$，我们定义一种洗牌方式是一个排列 $X=\{x_1, x_2, ..., x_n\}$, 也就是把牌堆中第 $i$ 张位置的牌变成第 $x_i$ 张。那么假设现在 Moon 按照 $X$ 的洗牌方式洗了 $k$ 次牌，不妨设最终得到了一个排列 $Y =\{y_1, y_2, ..., y_n\}$，$y_i$ 表示洗完牌后第 $i$ 张牌的标号。Moon 希望你可以帮助他算出有多少合法的洗牌方式 $X$，满足洗了 $K$ 次后变成排列 $Y$ ，由于答案可能很大，所以你只需要输出对 $998244353$ 取模的答案即可。

形式化而言，考虑对于排列 $P=\{p_1, p_2, ..., p_n\}$ 和排列 $Q=\{q_1, q_2, ..., q_n\}$, 定义这两个排列的乘积:

$$ P \times Q = \{q_{p1} , q_{p2} , ..., q_{pn} \}$$

而排列 $X$ 的 $k$ 次幂 $X^k$ 为 $k$ 个排列 $X$ 的乘积，现在考虑给定排列 $Y$ 和正整数 $k$, 求满足方程 $X^k = Y$ 的排列 $X$ 的数量，对 $998244353$ 取模。

## 说明/提示

### 样例解释

样例中，$X=[3,4,2,1,5]$ 或者 $[4,3,1,2,5]$, 共两个合法排列。

### 数据范围

对于所有的数据，有 $1 \le n \le 3000, 1 \le k \le 10^6, 1 \le T \le 10$；

对于 $20\%$ 的数据，有 $1 \le n, k \le 8$；

对于另外 $10\%$ 的数据，仅保证 $1 \le n \le 8$；

对于另外 $30\%$ 的数据，仅保证 $1 \le n \le 50$。

## 样例 #1

### 输入

```
1
5 6
2 1 4 3 5```

### 输出

```
2```

## 样例 #2

### 输入

```
见/example/permutation/下的
permutation1.in```

### 输出

```
见/example/permutation/下的
permutation1.out```

# 题解

## 作者：qczrz6v4nhp6u (赞：4)

若干年前刚学 OI，看到这个题一点思路都没有，但是现在看来似乎并没有那么困难。

### Solution

对于每个置换环考虑。设 $r_1$ 为 $Y$ 上的一个置换环，$r_2$ 为 $X$ 上该置换环所在的置换环。那么应该有：

$$|r_2|=|r_1|\times \gcd(k,|r_2|)$$

解释一下：$\gcd(k,|r_2|)$ 是 $r_1$ 对应到 $r_2$ 上相邻两个点之间的距离，乘上点数即为环长。

通过这个可以得到 $r_2$ 上应该有恰好 $\gcd(k,|r_2|)$ 个长度为 $|r_1|$ 的环。

对每种长度的置换环分别考虑，最后再将答案乘起来。将 $\frac{|r_2|}{|r_1|}$ 个长度为 $|r_1|$ 的置换环分配到一个长度为 $|r_2|$ 的置换环的方案数即为

$$(\frac{|r_2|}{|r_1|}-1)!\times |r_1|^{\frac{|r_2|}{|r_1|}-1}$$

即钦定一个置换环不动，其他置换环乱放的方案数。

考虑其关于 $|r_2|$ 的 EGF。设 $p=|r_1|$，$l=|r_2|$，$c=\frac{l}{p}$，$g=(c-1)!\times p^{c-1}$，则关于 $l$ 的 EGF $F_l(z)$ 即为：

$$\begin{aligned}
F_l(z)&=\sum_{n\ge 0}[c|n]\frac{n!}{(c!)^{\frac nc}(\frac{n}{c})!}\times g^{\frac nc}\times \frac{z^n}{n!}\\
&=\sum_{n\ge 0}\frac{1}{(c!)^nn!}\times g^n\times z^{nc}\\
&=\sum_{n\ge 0}\frac{(\frac{gz^c}{c!})^n}{n!}
\end{aligned}$$

设 $S$ 为 $l=|r_1|\times \gcd(k,l)$ 满足条件的 $l$ 的集合，$m$ 为长度为 $|r_1|$ 的置换环的数量，则答案即为

$$m![z^m]\prod_{l\in S}F_l(z)$$

直接暴力把这个东西卷起来就是 $O(n^2\ln n)$ 的，而且严重跑不满。

考虑进一步优化。注意到 $F_l(z)=\exp(\frac{gz^c}{c!})$，则答案的 EGF 即为

$$\prod_{l\in S}F_l(z)=\exp(\sum_{l\in S}\frac{gz^c}{c!})$$

暴力算这个东西可以做到 $O(n^2)$，使用多项式科技可以做到 $O(n\log^2 n)$ 或 $O(n\log n)$。

### Code

一个 $O(n^2\ln n)$ 的实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=3005,mod=998244353;
int n,m,a[N],cnt[N];
bool vis[N];
vector<int> dvs;
ll fac[N],ifac[N];
inline ll qpow(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res;
}
ll f[N];
ll dp(int len,int n){
	for(int i=0;i<=n;i++)f[i]=0;
	f[0]=1;
	for(auto &c:dvs){
		if(c>n)break;
		if(__gcd(m,len*c)==c){
			ll g=fac[c-1]*qpow(len,c-1)%mod*ifac[c]%mod;
			for(int i=n;i>=0;i--){
				ll cur=g;
				for(int k=1;c*k<=i;k++,cur=cur*g%mod)
					f[i]=(f[i]+f[i-c*k]*cur%mod*ifac[k])%mod;
			}
		}
	}
	return f[n]*fac[n]%mod;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	fac[0]=1;
	for(int i=1;i<=3000;i++)fac[i]=fac[i-1]*i%mod;
	ifac[3000]=qpow(fac[3000],mod-2);
	for(int i=3000;i>=1;i--)ifac[i-1]=ifac[i]*i%mod;
	int _Test;cin>>_Test;
	while(_Test--){
		cin>>n>>m;
		dvs.clear();
		for(int i=1;i<=m;i++)
			if(m%i==0)
				dvs.emplace_back(i);
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cnt[i]=vis[i]=0;
		for(int i=1;i<=n;i++){
			int len=0;
			for(int x=i;!vis[x];x=a[x])vis[x]=1,++len;
			++cnt[len];
		}
		ll ans=1;
		for(int i=1;i<=n;i++)
			ans=ans*dp(i,cnt[i])%mod;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：xieziheng (赞：3)

暂时摆脱 whk 的苦海。感觉 oi 还是比 whk 简单的。

小清新题，喜欢捏。

考虑原排列一个长度为 $l$ 的置换环，在自复合 $k$ 次后会被分解成 $a=\gcd(l,k)$ 个长度为 $x=\frac l {\gcd(l,k)}$ 的环。

显然对每个 $x$ 独立，分别算一下乘起来即可。

考虑对 $a$ 的限制：$a|k,\gcd(x,\frac ka)=1$。

考虑 $a$ 个长为 $x$ 的环符合条件的拼起来的方案数：把第一个环固定，剩下的 $a-1$ 个随便排，且开头任意，所以为 $(a-1)!x^{a-1}$。

所以简单 dp 一下即可，对每种 $a$ 枚举选了多少个由 $a$ 个环拼出来的大环，复杂度不是很好分析，但是显然不超过 $\mathcal{O}(n^2 \ln n)$。

---

## 作者：DerrickLo (赞：2)

我们考虑一个大小为 $m$ 的置换环如果进行了 $k$ 次操作，那么显然每个数都变成了这个数在置换环上后面的第 $k$ 个数，此时这个置换环会分成 $\gcd(m,k)$ 个新的大小为 $\dfrac{m}{\gcd(m,k)}$ 的置换环。

那么对于原排列的每个置换环，最终都会分成若干个等大小的置换环。设操作完的排列中大小为 $i$ 的置换环有 $a_i$ 个，那么记 $f_{i,j}$ 表示有 $j$ 个大小为 $i$ 的置换环时，它们能拼成原图置换环的方式数，那么答案就是 $\displaystyle \prod_{i=1}^{n}f_{i,a_i}$。

接下来问题就变成了怎么求 $f_{i,j}$，考虑转移时枚举 $x$ 表示此时第 $1$ 个置换环在原图中在一个 $i\times x$ 的大置换环中，这里的 $x$ 需要满足 $\gcd(k,i\times x)=x$。那么对于这个大置换环内部排列的方案数，不难发现对于每个小置换环有 $i$ 种排列方式，而这些小置换环之间有 $x!$ 种排列方式，而由于是一个环，所以还要除以 $i\times x$，也就是说方案数是 $\dfrac{i^x\times x!}{i\times x}$。

那么不难列出转移方程：

$$f_{i,j}=\displaystyle\sum_{x\le j,\gcd(k,i\times x)=x}f_{i,j-x}\times \dbinom{j-1}{x-1}\times \dfrac{i^x\times x!}{i\times x}$$

直接暴力转移即可。时间复杂度 $\mathcal O(Tnd(k)\log k)$。

```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define int long long
using namespace std;
int t,n,m,p[3005],f[3005],fac[3005],inv[3005],invv[1000005],vis[3005],cnt[3005];
vector<int>d;
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
int C(int n,int m){
	if(n<m)return 0;
	return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t,fac[0]=1;
	for(int i=1;i<=3000;i++)fac[i]=fac[i-1]*i%mod,invv[i]=ksm(i,mod-2);
	inv[3000]=ksm(fac[3000],mod-2);
	for(int i=2999;~i;i--)inv[i]=inv[i+1]*(i+1)%mod;
	while(t--){
		cin>>n>>m,d.clear();
		for(int i=1;i<=n;i++)cin>>p[i],vis[i]=0,cnt[i]=0;
		for(int i=1;i<=m;i++)if(m%i==0)d.emplace_back(i);
		for(int i=1;i<=n;i++)if(!vis[i]){
			int now=i,cntt=0;
			while(!vis[now])vis[now]=1,cntt++,now=p[now];
			cnt[cntt]++;
		}
		int ans=1;
		for(int i=1;i<=n;i++){
			f[0]=1;
			for(int j=1;j<=cnt[i];j++)f[j]=0;
			for(int j=1;j<=cnt[i];j++)for(int k:d)if(k<=j&&__gcd(m/k,i)==1)f[j]+=C(j-1,k-1)*f[j-k]%mod*ksm(i,k)%mod*fac[k]%mod*invv[i*k]%mod,f[j]%=mod;
			ans*=f[cnt[i]],ans%=mod;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：lsj2009 (赞：2)

## Description

给定置换 $P$，求多少个置换 $Q$ 满足 $Q^k=P$。

$1\le n\le 3000$，$1\le k\le 10^6$，$10$ 组数据。

## Solution

**闲话：**

笑飞了哥们，这个题本来一模一样的（好吧可能模数不一样，然后没用多测/xk）是我准备出一个公开赛的题，后来被 [P4709](https://www.luogu.com.cn/problem/P4709) 爆了，结果没想到又在这里见到了/kx

下面来复制一下我当时写的题解：

排列问题，非常套路地考虑**置换环**。

先考虑对排列 $\{p_n\}$ 建图，连边 $i\to p_i$，则会得到若干个环。

则 $f^k(u)$ 相当于是节点 $u$ 往后走 $k$ 步到的节点。

我们对于 $\{q_n\}$ 建图，得到一个新图，则有一个结论是：

- 对于原图上的一个长为 $m$ 的环，恰好对应**新图上 $\gcd(k,m)$ 个长为 $\frac{m}{\gcd(k,m)}$ 的环**。

- 证明：其实挺显然（挺典）的，但是还是写一下。

> 我们假装从 $u$ 向后走 $k$ 步走到的是 $(u+k)\bmod{m}$（对于原来的环重标号），则再次回到 $u$ 就对应了一个环。
> 
> 假设我们走了 $p$ 步后重新回到了点 $u$，则有 $u+pk\equiv u\pmod{m}$，也就是 $pk\equiv 0\pmod{m}$，满足条件的最小的 $p$ 显然是 $\frac{m}{\gcd(k,m)}$。
> 
> 所以新图上一个环长为 $\frac{m}{\gcd(k,m)}$，而每个环除了标号之外完全一样，所以原图上一个环会被分裂成新图上 $k$ 个长为 $\frac{m}{\gcd(k,m)}$ 的环。
>
> 当然有一个问题是，中间会不会走到已经走过的点（但不是点 $u$），然后构成一个 $\rho$ 形？
>
> 一个不太严谨的解释是，假设那个点是 $v$，显然**从 $v$ 开始走得到的连通块在形状上和从 $u$ 开始走得到的连通块完全相等**，这与『从 $u$ 开始走遇到的第一个重复点是点 $v(v\ne u)$』矛盾了。

然后知道了这个结论后继续考虑。

我们原本是已知原图分析新图的性质，现在考虑**从新图来倒推原图**。

我们发现，原图上一个环会分割成新图上若干个**大小相等**的环，这是一个非常强的性质。

我们先建出 $\{q_n\}$ 的图，掏出其所有长度相等的环，**现在不长度不同的环之间互相独立了，我们只需要对于长度相同的环放在一起计算，最后再把方案数求积即可**。

假设现在有 $m$ 个长为 $len$ 的环，则我们考虑**拿 $p$ 个环去合并成原图上的一个大环**。

考虑这个 $p$ 需要满足什么条件。

容易得到的是满足条件的 $p$ 的充要条件是 $\gcd(p\cdot len,k)=p$，必要性显然，充分性考虑构造性证明，是容易的。

我们考虑枚举这个 $p$，设一个 dp 状态是 $f_{i,j}$ 表示考虑 $p\le i$ 且已经合并了 $j$ 个环的方案总数，容易得到 dp 方程：

$$
f_{i,j}=
\begin{cases}
 \sum\limits_{d=0}^{\lfloor \frac{j}{i}\rfloor} f_{i-1,j-id}\cdot {m-j+id\choose id}\cdot \frac{(id)!}{(i!)^dd!}\cdot g_{len,i}^d & \gcd(i\cdot len,k)= i\\
  f_{i-1,j} & \text{otherwise}
\end{cases}
$$

其中 $g_{i,j}$ 表示将 $j$ 个新图上长为 $i$ 的环合并成原图上一个长为 $i\cdot j$ 的环方案总数。

这个 dp 方程的系数含义依次是，我们**先掏出 $i\cdot k$ 个环，然后把每个环分配成 $k$ 组，每组 $i$ 个环，组之间不区分环的顺序，组与组之间不区分顺序**，再将每个组内分别合并。

那么接下来的问题就是考虑如何计算 $g_{i,j}$。

我们考虑把所有环重标号，然后把一个环 split 开来变成一条链，则其他环要依次与这个链合并，**对于其他环我们依次选择一个点，钦定他的值**，则剩下点的值都唯一确定。

所以 $g_{i,j}=1\times \prod\limits_{k=1}^{j-1} (ij-ik)=i^{j-1}(j-1)!$。

或者还有一种清晰的理解方式是：不妨手摸一下环分裂的过程，**你会发现一个新环的两个点在原环中间有 $j-1$ 个点的空隙，我们接下来就是对于剩下的 $j-1$ 个环各选出一个打头的点插入进去，而插入顺序又有影响，所以得到了这个系数。**

然后分析复杂度，对于一个 $i$ 能进行转移当且仅当 $\gcd(i\cdot len,k)=i\Leftrightarrow \gcd(len,\frac{k}{i})=1$，则 $i$ 是 $k$ 的因数且 $\gcd(len,k)|i$。

我们考虑构造极限数据：**所有环长为 $1$**，则此时后面那个条件可以忽略，且 $cnt=n$。

而转移一次的复杂度为 $\Theta(\frac{n^2}{i})$，则总复杂度为 $\sum\limits_{d\mid k} \frac{n^2}{d}=n^2\frac{(\textbf{1}*\textbf{id})_k}{k}=n^2\frac{\sigma(k)}{k}$。

其中 $*$ 表示迪利克雷卷积，而 $\sigma(k)$ 是 $\Theta(k\log{\log{k}})$ 级别的，故复杂度为 $\Theta(Tn^2\log{\log{k}})$。

## Code
 
```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(3,"Ofast","inline")
//#define int long long
#define ll long long
#define i128 __int128
#define ull unsigned long long
#define ld long double
#define PII pair<int,int>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
void file_IO() {
	freopen("permutation.in","r",stdin);
	freopen("permutation.out","w",stdout);
}
bool M1;
const int N=1e4+5,MOD=998244353;
template<int p>
struct mint {
	int x;
	mint() {
		x=0;
	}
	mint(int _x) {
		x=_x;
	}
	friend mint operator + (mint a,mint b) {
		return a.x+b.x>=p? a.x+b.x-p:a.x+b.x;
	}
	friend mint operator - (mint a,mint b)  {
		return a.x<b.x? a.x-b.x+p:a.x-b.x;
	}
	friend mint operator * (mint a,mint b) {
		return 1ll*a.x*b.x%p;
	}
	friend mint operator ^ (mint a,ll b) {
		mint res=1,base=a;
		while(b) {
			if(b&1)
				res*=base;
			base*=base; b>>=1;
		}
		return res;
	}
	friend mint operator ~ (mint a) {
		return a^(p-2);
	}
	friend mint operator / (mint a,mint b) {
		return a*(~b);
	}
	friend mint & operator += (mint& a,mint b) {
		return a=a+b;
	}
	friend mint & operator -= (mint& a,mint b) {
		return a=a-b;
	}
	friend mint & operator *= (mint& a,mint b) {
		return a=a*b;
	}
	friend mint & operator /= (mint& a,mint b) {
		return a=a/b;
	}
	friend mint & operator ++ (mint& a) {
		return a+=1;
	}
	friend mint & operator -- (mint& a) {
		return a-=1;
	}
};
#define mint mint<MOD>
mint jc[N],inv_jc[N],f[2][N];
void init(int n=1e4) {
	jc[0]=1;
	rep(i,1,n)
		jc[i]=jc[i-1]*i;
	inv_jc[n]=~jc[n];
	per(i,n-1,0)
		inv_jc[i]=inv_jc[i+1]*(i+1);
}
mint C(int n,int m) {
	if(n<m)
		return 0;
	return jc[n]*inv_jc[n-m]*inv_jc[m];
}
int to[N],cnt[N],n,k;
bool used[N];
int dfs(int x) {
	if(used[x])
		return 0;
	used[x]=true;
	return dfs(to[x])+1;
}
void solve() {
	scanf("%d%d",&n,&k);
	rep(i,1,n) {
		used[i]=false;
		cnt[i]=0;
	}
	rep(i,1,n)
		scanf("%d",&to[i]);
	rep(i,1,n) {
		if(!used[i]) {
			int val=dfs(i);
			++cnt[val];
		}
	}
	mint res=1;
	rep(len,1,n) {
		int m=cnt[len];
		rep(i,0,1) {
			rep(j,0,m)
				f[i][j]=0;
		}
		int p=0;
		f[p][0]=1;
		rep(i,1,m) {
			if(__gcd(i*len,k)!=i)
				continue;
			p^=1;
			rep(j,0,m)
				f[p][j]=0;
			mint tmp=(mint(len)^(i-1))*jc[i-1];
			rep(k,0,m/i) {
				mint val=jc[i*k]*(tmp^k)/((jc[i]^k)*jc[k]);
				rep(j,i*k,m)
					f[p][j]+=f[p^1][j-i*k]*C(m-j+i*k,i*k)*val;
			}
		}
		res*=f[p][m];
	}
	printf("%d\n",res.x);
}
bool M2;
signed main() {
//	file_IO();
	int testcase=1;
	init();
	scanf("%d",&testcase);
	while(testcase--)
		solve();
	cerr<<"used time = "<<1000*clock()/CLOCKS_PER_SEC<<"ms\n";
	cerr<<"used memory = "<<(&M1-&M2)/1024/1024<<"MB\n";
	return 0;
}

```

---

## 作者：happybob (赞：0)

题意：

给定 $n,k$ 和长度为 $n$ 的排列 $p_1,p_2,\cdots,p_n$，求有多少 $n$ 阶排列 $q_1,q_2,\cdots,q_n$ 使得 $q^k=p$。答案对 $998244353$ 取模。

多测，$T \leq 10$，$1 \leq n \leq 3000$，$1 \leq k \leq 10^6$。时限 $1$ 秒。

解法：

考虑排列的 $k$ 次方的性质。我们不妨考虑排列置换环 $k$ 次方后的结果。

对于一个长度为 $len$ 的环，其 $k$ 次方后会分为 $\gcd(len,k)$ 个长度均为 $\dfrac{len}{\gcd(len,k)}$ 个环，证明显然。

记 $cnt_i$ 表示 $p$ 中长度为 $i$ 的置换环数量。考察 $cnt_i$ 个长度为 $i$ 的环在原排列中对应多少个数。不难发现若有 $c_1+c_2+\cdots+c_m=cnt_i$，且每 $c_j$ 个环对应原排列一个环，那么我们有 $\dfrac{len}{\gcd(len,k)}=i$ 与 $\gcd(len,k)=c_j$。故 $len=ic_j$。所以事实上这 $cnt_i$ 个环对应原排列共 $i \sum c_j = i \times cnt_i$ 个数。容易发现不同长度环之间不影响，尝试对每种长度环计数，然后乘在一起。

枚举环长度 $i$，问题变为 $c_1+c_2+\cdots+c_m=cnt_i$，将 $cnt_i$ 个环无序划分为 $c_1,c_2,\cdots,c_m$ 这些环，贡献是 $\prod \limits_{j=1}^m (c_j-1)!\times (i-1)^{c_j}$，求贡献总和。$(c_j-1)!\times i^{c_j-1}$ 意义是先将 $c_j$ 个环开头圆排列，然后每个环本身有 $i$ 种循环同构，共 $i^{c_j}$ 种，但是会算重所以除以 $i$。同时还有限制是，对于任意 $j$，有 $\gcd(i \times c_j,k) = c_j$。枚举可行的 $c_j$ 然后背包即可。

代码：


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <numeric>
#include <queue>
#include <set>
#include <map>
#include <array>
using namespace std;

using ll = long long;

constexpr int N = 1e6 + 5;
constexpr ll MOD = 998244353ll;

int t, n, k;
array<int, N> p, vis, cnt;
array<ll, N> fac, ifac, f, g;

inline ll qpow(ll a, ll b)
{
	ll res = 1ll, base = a;
	while (b)
	{
		if (b & 1ll) res = res * base % MOD;
		base = base * base % MOD;
		b >>= 1ll;
	}
	return res;
}

inline ll binom(int n, int m)
{
	if (n < m) exit(-1);
	return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	fac[0] = 1ll;
	for (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % MOD;
	ifac[N - 1] = qpow(fac[N - 1], MOD - 2ll);
	for (int i = N - 2; i >= 0; i--) ifac[i] = ifac[i + 1] * (i + 1) % MOD;
	cin >> t;
	while (t--)
	{
		cin >> n >> k;
		for (int i = 1; i <= n; i++) cin >> p[i], cnt[i] = vis[i] = 0;
		for (int i = 1; i <= n; i++)
		{
			if (vis[i]) continue;
			int c = 1, j = p[i];
			vis[i] = vis[j] = 1;
			while (j ^ i) c++, j = p[j], vis[j] = 1;
			cnt[c]++;
		}
		ll ans = 1ll;
		for (int i = 1; i <= n; i++)
		{
			if (!cnt[i]) continue;
			int plen = i * cnt[i];
			for (int j = 1; j <= n; j++) f[j] = 0;
			f[0] = 1;
			for (int j = 1; j <= cnt[i]; j++)
			{
				if (gcd(j * i, k) != j)
				{
					continue;
				}
				ll nv = fac[j - 1] * qpow(i, j - 1) % MOD, rv = nv, nret = 1ll;
				for (int nj = 0; nj <= cnt[i]; nj++) g[nj] = f[nj];
				for (int nc = 1; nc * j <= cnt[i]; nc++)
				{
					for (int y = nc * j; y <= cnt[i]; y++)
					{
						ll rs = binom(y, nc * j) * nret % MOD;
						f[y] = (f[y] + g[y - nc * j] * nv % MOD * rs % MOD) % MOD;
					}
					nv = nv * rv % MOD;
					nret = nret * binom((nc + 1) * j, j) % MOD * fac[nc] % MOD * ifac[nc + 1] % MOD;
				}
			}
			//cout << "!!!: " << i << " " << f[cnt[i]] << "\n";
			ans = ans * f[cnt[i]] % MOD;
		}
		cout << ans << "\n";
	}
	return 0;
}

/*
1
5 814135
1 2 3 4 5
*/
```

---


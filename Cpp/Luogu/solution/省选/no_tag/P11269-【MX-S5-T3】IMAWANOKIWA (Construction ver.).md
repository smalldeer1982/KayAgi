# 【MX-S5-T3】IMAWANOKIWA (Construction ver.)

## 题目背景

原题链接：<https://oier.team/problems/S5C>。

---

[IMAWANOKIWA - いよわ / 初音ミク](https://www.bilibili.com/video/BV1iE411Y7bf)

> あなたの未来が見たかった。

## 题目描述

给你一个初始长度为 $n$，**只包含** $\boldsymbol{0, 1, 2}$ 的序列 $a_{1 \sim n}$，你可以执行以下操作：

- 选择相邻的两个位置 $j$ 和 $j + 1$，删去 $a_j, a_{j + 1}$，并在原位置插入 $\mathrm{popc}(a_j + a_{j + 1})$，后半部分序列因此向前移动一位。其中，$\mathrm{popc}(x)$ 表示 $x$ 在二进制表示下 $1$ 的个数。

显然每次操作后序列长度都会减少 $1$，所以执行 $n - 1$ 次操作后，这个序列会恰好剩下一个数。

记在所有可能的 $n-1$ 次操作之后剩下的数的最小值为 $t$，定义一个好的操作序列 $p$ 为一个长度为 $n - 1$ 的正整数序列，其中 $p_i$ 表示第 $i$ 次操作所选择的 $j$（显然 $1 \le p_i \le n - i$），且满足按照这个操作序列操作之后剩下的数为 $t$，你需要求出 $t$ 与**字典序最小**的好的操作序列。

**如果你不会求出字典序最小的好的操作序列也可以获得部分分数**，详见【评分方式】。

为了避免输出量过大，你只需要输出字典序最小的好的操作序列按照某种哈希方式得到的哈希值即可，详见【输出格式】。

## 说明/提示

**【样例解释 #1】**

对于第一组数据，字典序最小的好的操作序列 $p$ 为 $[1, 3, 2, 1, 1]$，按照该操作序列操作时，$a$ 序列的变化过程如下：

$$
[1, 1, 0, 1, 2, 1]\\
[1, 0, 1, 2, 1]\\
[1, 0, 2, 1]\\
[1, 1, 1]\\
[1, 1]\\
[1]
$$

所以你应输出的哈希值为 $\mathrm{Hash}([1, 3, 2, 1, 1]) = (1 \times 13331^4 + 3 \times 13331^3 + 2 \times 13331^2 + 1 \times 13331^1 + 1 \times 13331^0) \bmod 2^{64} = 31589928355420248$。

对于第二组数据，字典序最小的好的操作序列 $p$ 为 $[1, 2, 2, 1, 1]$，按照该操作序列操作时，$a$ 序列的变化过程如下：

$$
[1, 2, 0, 2, 0, 2]\\
[2, 0, 2, 0, 2]\\
[2, 1, 0, 2]\\
[2, 1, 2]\\
[2, 2]\\
[1]
$$

**【样例 #2】**

见附件中的 `popc/popc2.in` 与 `popc/popc2.ans`。

该组样例共有十组测试数据，所有测试数据均满足 $n = 10^5$，其中测试数据 $1 \sim 5$ 满足序列 $a$ 中不存在 $0$，$6 \sim 10$ 满足序列 $a$ 中不存在 $1$。

**【样例 #3】**

见附件中的 `popc/popc3.in` 与 `popc/popc3.ans`。

该组样例共有四十组测试数据，其中测试数据 $1 \sim 10$ 满足 $n = 300$，$11 \sim 20$ 满足 $n = 3000$，$21 \sim 30$ 满足 $n = 3 \times 10^4$，$31 \sim 40$ 满足 $n = 10^5$。

**【评分方式】**

本题将使用**自定义校验器**计算你获得的部分分数。

对于一个测试点，如果你存在数据输出的最小值不正确，那么无法获得该测试点的分数。

对于一个测试点，如果你每组数据输出的最小值正确，但是存在数据求出的字典序最小的好的操作序列的哈希值不正确，那么可以获得该测试点 $25\%$ 的分数（即 $1$ 分，见【数据范围】）。**注意你仍需输出任意一个 $\boldsymbol{[0, 2^{64})}$ 内的整数表示你的方案的哈希值。**

对于一个测试点，如果你每组数据输出的最小值正确，且求出的字典序最小的好的操作序列的哈希值正确，那么可以获得该测试点的全部分数。

**【数据范围】**

对于所有测试数据，保证：$1 \le T \le 200$，$2 \le n \le 10^5$，序列 $a$ **只包含** $\boldsymbol{0, 1, 2}$。

| 测试点编号 | $T\le$ | $n\le$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1 \sim 3$ | $10$ | $10$ | 无 |
| $4 \sim 6$ | $10$ | $300$ | 无 |
| $7 \sim 9$ | $10$ | $3000$ | 无 |
| $10 \sim 12$ | $10$ | $3 \times 10^4$ | 无 |
| $13 \sim 15$ | $10$ | $10^5$ | 序列 $a$ 中不存在 $0$ |
| $16 \sim 19$ | $10$ | $10^5$ | 序列 $a$ 中不存在 $1$ |
| $20 \sim 21$ | $10$ | $10^5$ | 无 |
| $22 \sim 23$ | $50$ | $10^5$ | 无 |
| $24 \sim 25$ | $200$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
7
110121
120202
1202
1121212
000
010101110
0112210112
```

### 输出

```
1 31589928355420248
1 31587559229276557
2 177728893
2 15233797274127957404
0 13332
1 4098728445451629840
1 892964726593242284
```

# 题解

## 作者：qijianci (赞：18)

~要是今年联赛放这个我就被创烂了。~

被这题硬控了 3h，跟大家分享一下我的巨大冗长的小丑分讨做法。

题意就不赘述了。

#### 首先我们需要让最后剩下来的数最小。

因为值域只有 $2$，我们可以先给操作结果打一个表。



||0|1|2|
|:-:|:-:|:-:|:-:|
|0|0|1|1|
|1|1|1|2|
|2|1|2|1|

容易发现只有 $0$、$0$ 才能合并出 $0$，$2$、$2$ 才能消掉一个 $2$ 。

依据这个我们容易得出三个结论：

#### 只有 $0$ 的情况才能结果为 $0$。

#### 只有 $1$、$2$ 的情况结果取决于 $2$ 数量的奇偶性。

#### 只有 $0$、$1$ 的情况结果一定为 $1$。 

那么既有 $0$ 又有 $2$ 的情况如何判断呢？

#### 首先我们考虑最基础的，假设只有一个 $0$，那么手玩几组样例会发现，只有形如 $...12021...$，也就是中间为 $0$、两侧紧贴 $2$、更左更右都只有 $1$ 的情况结果才会为 $2$ ，其余结果都为 $1$。

这个也是很好证明的，一个 $0$ 最多只能消掉一个 $2$，且 $1$ 可以把 $0$ 去掉。上面这种情况 $0$ 一定会抵消掉一个 $2$， $2$ 又无法被 $1$ 消掉，因此结果一定为 $2$。

其余情况若只有一边有 $2$，那 $2$ 的奇偶性一定可以被 $0$ 控制，若两边都有 $2$ 且有一边的数量大于2，那么若数量为偶数可以自行抵消，若数量为奇数那数量至少为3，可以把最靠近 $0$ 的两个 $2$ 先合并成为 $1$ 来控制 $0$ 的有无来控制 $2$ 的奇偶性。         

那若 $0$ 的数量大于 2 怎么办呢？
 
#### 稍微推一推就会发现若 $0$ 的数量大于 2 则一定可以使得结果为 $1$。  

考虑序列最后一定可以化为形如 $2020202...$ 的形式，我们一定可以通过把中间相邻的 $0$ $2$ 合并为 $1$ 来消去中间的 $0$ 和 $2$，仅剩最左和最右的 $2$，最后合并这两个 $2$ 就行了，唯一的corner case：$2002$ 只需要 $0$ $2$ 相互抵消就行了。

如果你推到了这一步，那么恭喜你可以在本题获得 25 分的高分啦！！！

#### 到这本题看似完成了一半。

~然而这才刚刚开始。~

题目里还需要我们操作方案的字典序最小。

这个我们还是可以考虑分讨。

### 对于以下三种：

#### 只有 $0$ 的情况、只有 $1$、$2$ 的情况、只有 $0$、$1$ 的情况。 

我们只需要一直操作第一个就行了。

### 对于只有一个 $0$ 的情况：

#### 若形如 $...12021...$。

那么答案已经确定，也只需一直操作第一个就行了。

#### 若右边有偶数个 $2$：

那么右边至少是可以自己消掉的，我们可以先操作第一个直到遇到 $0$，然后再分讨一下下一次操作是否会改变 $2$ 的奇偶性。

#### 若左边有偶数个 $2$：

那么此时右边是奇数个 $2$，我们可以先操作第一个直到遇到 $0$，然后再使 $0$ 消掉右边的 $2$。

#### 若左右都是奇数个 $2$：

因为已经判掉了答案为 $2$ 的情况，所以左右一定至少有一边可以用 $1$ 消掉 $0$。为了保证字典序，我们应该优先用右边的 $1$ 来消掉，这样左边就可以一直选第一个，若右边不合法才优先用左边的。

### 对于 $0$ 的数量大于一：

我们显然可以先一直选第一个直到只剩下两个 $0$，因为数量大于一一定合法。

#### 若不看左边的 $0$，右边可以将答案消为一：

那么直接按一个 $0$ 的方案做就行了。 

#### 若不看左边的 $0$，右边不合法：

那么我们需要先用左边的 $0$ 消掉一个 $2$，剩下的就简单了。


到这这个题才算做完了，当然还有若干 corner 我没有讲的很详细，如果你选择了我的~小丑~做法，剩下的就自己慢慢发现吧。

### end.

最后讲些闲话。

出题人的做法确实会比我的更优秀。

我多遇上了 inf 的分讨，多消耗了 inf 的时间，才堪堪完成了这道题，但当看到“恭喜你，通过了此题”的时候，喜悦仍压过了烦闷，轻松仍压过了疲倦......

或许这 就是信竞的魅力所在吧。

代码

```
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define popc __builtin_popcount
const int N=1e5+5,B=13331;
int n,T,sum[N],s[N],cnt;
ull pw[N],ans[N];
string t;
void g(int x){s[x+1]=popc(s[x]+s[x+1]);}
void sol1(){
    int i,j,k,l,r,x,y,z;
    for(i=1,s[n+1]=1;i<=n;++i)if(s[i]==0){x=i;break;}
    for(i=1;i<=n;++i)sum[i]=sum[i-1]+(s[i]==2);
    if((sum[n]-sum[x])%2==0){
        for(i=1;i<x;++i)ans[++cnt]=1,g(i);
        if(!s[x])for(i=x+1;i<=n&&s[i]==2;++i)ans[++cnt]=2,g(i);
    } else if(sum[x]%2==0){
        for(i=1;i<x-1;++i)ans[++cnt]=1;
        for(i=x+1;i<=n&&s[i]!=2;++i)ans[++cnt]=3-(x==1),g(i);
        if(x>1)ans[++cnt]=2;
    } else {
        if(sum[n]-sum[x]==1&&s[x+1]==2){
            if(s[x-1]==2){
                for(i=1;sum[x]-sum[i+1]>=2;++i)ans[++cnt]=1,g(i);
                for(++i;i<x;++i)ans[++cnt]=2;
            } else {
                for(i=1;i<x-2;++i)ans[++cnt]=1;
                ans[++cnt]=2;
            }
        } else {
            for(i=1;i<x-1;++i)ans[++cnt]=1;
            for(i=x+1;i<=n&&s[i]==2;++i)ans[++cnt]=3,g(i);
            ans[++cnt]=2;
        }
    }
}
signed main(){
    ios::sync_with_stdio(false);
    int i,j,k,l,r,x,y,z;
    cin>>T,pw[0]=s[0]=1;
    l=T;
    for(i=1;i<N;++i)pw[i]=pw[i-1]*B;
    while(T--){
        cin>>t,n=t.size(),ans[0]=cnt=0,r=n;
        for(i=1,s[n+1]=0;i<=n;++i)s[i]=t[i-1]-'0';
        for(i=1,x=0;i<=n;++i)
            s[i]?0:(x++,y=i),sum[i]=sum[i-1]+(s[i]==2);
        if(x==n)printf("0 ");
        else if(!x)printf("%d ",(sum[n]&1)+1);
        else if(x==1&&sum[n]==2&&s[y+1]==2&&s[y-1]==2)printf("2 ");
        else printf("1 ");
        if(x==n||!x||(x==1&&sum[n]==2&&s[y+1]==2&&s[y-1]==2)||!sum[n])
            while(cnt<n-1)ans[++cnt]=1;
        else if(x==1)sol1();
        else {
            for(i=n;i;--i)if(!s[i]){x=i;break;}
            for(i=x-1;i;--i)if(!s[i]){k=i;break;}
            if(sum[n]-sum[k]==2&&s[x+1]==2&&s[x-1]==2){
                for(i=1;i<k-1;++i)ans[++cnt]=1,g(i);
                if(k==1||!s[k-1]){
                    if(k>1)ans[++cnt]=1;
                    for(i=k+1;i<x-1;++i)ans[++cnt]=2;
                    ans[++cnt]=1,ans[++cnt]=2;
                } else if(s[k-1]==1){
                    for(i=k+1;i<x-1;++i)ans[++cnt]=3;
                    ans[++cnt]=2,ans[++cnt]=1,ans[++cnt]=2;
                } else {
                    if(s[k+1]==1){
                        ans[++cnt]=2;
                        for(i=k;i<x-1;++i)ans[++cnt]=1;
                        ans[++cnt]=2;
                    } else {
                        for(i=k+1;i<x-1;++i)ans[++cnt]=3;
                        ans[++cnt]=2,ans[++cnt]=2;
                    }
                }
            } else {
                for(i=1;i<k;++i)ans[++cnt]=1,g(i);
                if(!s[k]){
                    if(sum[n]-sum[k]==3&&k+1<x-1&&s[k+1]==2&&s[x-1]==2&&s[x+1]==2){
                        for(i=k+1;i<x-1;++i)ans[++cnt]=2;ans[++cnt]=1;
                        ans[++cnt]=2;while(cnt<n-1)ans[++cnt]=1;
                    } else ans[++cnt]=1,g(k++);
                } if(cnt<n-1)for(i=k;i<=n;++i)s[i-k+1]=s[i];n=n-k+1,sol1();
            }
        } for(n=r;cnt<n-1;)ans[++cnt]=1;
        while(cnt)ans[0]+=ans[cnt]*pw[n-1-cnt],cnt--;
        printf("%llu\n",ans[0]);
    } return 0;
}
```

---

## 作者：幸存者 (赞：14)

upd on 2.28：修正了一处错误。

为了纪念我调了 3h 的大分讨，写篇题解。

首先，注意到每次操作若操作 $0$，操作后 $0$ 的个数至少减一，所以如果答案为 $0$ 必须全为 $0$，特判即可。

接下来，我们讨论什么时候答案为 $2$：

- 没有 $0$，且 $2$ 的个数为奇数。解释：若无 $0$，每次操作后 $2$ 的个数的奇偶性不变，所以最终剩的那个数是唯一确定的。
- 有一个 $0$，且形如 $111\cdots1202111\cdots1$。解释：这种情况下无法使 $0$ 与 $1$ 相邻，故必然 $0$ 与 $2$ 操作，之后 $0$ 没了剩余一个 $2$，所以答案为 $2$。否则，若左右都有奇数个 $2$，设 $0$ 是第 $x$ 个，必能找到 $y$ 满足 $y\sim x-1$ 中有偶数个 $2$ 或 $x+1\sim y$ 中有偶数个 $2$。把这个区间操作成 $1$ 后，再与 $0$ 操作，两端区间合并，剩余偶数个 $2$，转换为无 $0$ 的情况。若左右不都有奇数个 $2$，留作读者自证，也可以参考后文的字典序最小构造方案。
- 有至少两个 $0$，此时无论如何，答案都不可能为 $2$。解释：可以先把 $0$ 分隔开的三段都合并成一个数。若小于等于两个 $2$，一个 $0$ 消一个即可；若三个 $2$，$20202\rightarrow2102\rightarrow212$ 即可。

注意到答案为 $0,2$ 时构造非常显然，以下仅论述答案为 $1$ 时的构造，记 $c$ 为 $0$ 的个数，$pos$ 为最后一个 $0$ 的位置。

首先，我们可以在操作后 $c\ge2$ 的前提下，一直操作位置 $1,2$，操作后有以下几种情况：

- 第一位为 $0$：
  - 操作位置 $1$ 后答案仍可为 $1$，直接操作即可。（第二位为 $0$ 必在此类中）
  - 操作位置 $1$ 后答案不可为 $1$，且第二位为 $1$，则必为 $0111\cdots1202111\cdots1$，一直操作位置 $2$ 直到第二位变为 $2$，然后操作位置 $1$ 即可。
  - 操作位置 $1$ 后答案不可为 $1$，且第二位为 $2$，则必为 $02111\cdots1202111\cdots1$，一直操作位置 $2$ 直到第三位变为 $2$，然后操作位置 $2$，再操作位置 $1$ 即可。
- 第一位不为 $0$，则第二位必为 $0$：
  - 第三位为 $0$，操作位置 $1$ 即可，容易证明操作后必可使答案为 $1$。
  - 第三位不为 $0$：
    - 操作位置 $1$ 后答案仍可为 $1$，直接操作即可。
    - 操作位置 $1$ 后答案不可为 $1$，且第一位为 $1$，则必为 $10111\cdots1202111\cdots1$，一直操作位置 $3$ 直到第三位变为 $2$，然后操作位置 $2$ 即可。
    - 操作位置 $1$ 后答案不可为 $1$，且第一位为 $2$，则必为 $20111\cdots1202111\cdots1$，操作位置 $2$ 即可。

接下来，必有 $c\le1$，我们讨论 $c=1$ 时的情况：

- 第一位为 $0$：
  - 若从第三位开始有偶数个 $1$，操作位置 $1$ 即可。
  - 若从第三位开始有奇数数个 $1$，且第二位为 $1$，一直操作位置 $2$ 直到第二位变为 $2$，然后操作位置 $1$ 即可。
  - 若从第三位开始有奇数数个 $1$，且第二位为 $2$，一直操作位置 $2$ 直到第三位变为 $2$，然后操作位置 $2$，再操作位置 $1$ 即可。
- 第一位不为 $0$：
  - 若从第 $pos+1$ 位开始有偶数个 $2$，一直操作位置 $1$ 直到 $0$ 被操作没即可。
  - 若从第 $pos+1$ 位开始有奇数个 $2$：
    - 若前 $pos-1$ 位有偶数个 $2$，一直操作位置 $1$ 直到第二位变为 $0$，然后一直操作位置 $3$ 直到第三位变为 $2$，最后操作位置 $2$ 即可。这样第二段奇数变成了偶数，并且合并了起来。
    - 若前 $pos-1$ 位有奇数个 $2$：
      - 若从 $pos+1$ 位开始不形如 $2111\cdots1$，一直操作位置 $1$ 直到第二位变为 $0$，然后一直操作位置 $3$ 直到第三位变为 $1$，最后操作位置 $2$ 即可。这样两段 $2$ 的个数都还是奇数，但合并了起来。
      - 若从 $pos+1$ 位开始形如 $2111\cdots1$，由于答案为 $1$，所以前 $pos-1$ 位不形如 $111\cdots12$，可以找到最大的 $x\le pos-1$ 使 $[x,pos-1]$ 内有偶数个 $2$。一直操作位置 $1$ 把前 $x-1$ 位操作到一起，然后原来的 $x$ 现在就变成了位置 $2$，一直操作位置 $2$ 直到第二位变为 $0$，最后操作位置 $2$ 即可。这样两段 $2$ 的个数都还是奇数，但合并了起来。

现在，$c$ 终于变为 $0$ 了，由于怎么操作答案都不会变，一直操作位置 $1$ 即可。

时间复杂度 $O(Tn)$，代码太长了放到[剪贴板](https://www.luogu.com.cn/paste/575bbgm0)。

---

## 作者：cxqghzj (赞：11)

这里给一个出题人题解里提到的做法:

> 有些人写了意料之外的根据结论直接 DP 的大常数线性做法，由于所有验题人都没有发现该做法，所以并没有考虑到这点，并不是故意卡该做法。这里也给被卡的人谢罪了。

以下设 $V = \max {c_{i}}$。

这个做法非常好写，实际上我被卡常纯粹是我糖丸了没看到 $T=200$ 直接 $O(TnV^4)$ 开冲了。可以十分简单地改成 $O(TnV^3)$，这样写甚至可以进 1s。

跳过一些步骤，可以通过很多方法得到 $c_i\le 3$ 的性质。这一点别的题解写的很清楚就不再赘述。

然后有的做法就开始大力分讨了。然而，因为 $c_i\le 3$，所以剩余的序列一定形如三个零散的数拼上原序列的一个后缀。所以，我们可以通过四个数来描述剩下的序列。直接记 $f_{w1,w2,w3,i,to}$ 表示 $w1,w2,w3,a_i,a_{i+1},\dots,a_n$ 的序列是否能够变成 $to$。转移十分的容易，就是选择一个进行合并即可。

这样 dp 有一个好处，你可以通过 dp 是否可以通过另一个形式转移过来来确认当前位置所有可能的合并，那么求最小的字典序自然是非常容易的。

这个时候就是 $O(TnV^4)$ 了。如果你像我一样直接写就会获得 92 分。然后发现，是/否这个状态定义非常的浪费。直接把它压成二进制位即可变成 $O(TnV^3)$，然后你就过了。没有任何细节，没有任何分讨，非常小清新。

---

## 作者：vegetable_king (赞：10)

# IMAWANOKIWA (Construction ver.)（FeOI 命题组）

[可能更好的阅读体验](https://yjh965.github.io/post/mx-s5-t3-guan-fang-ti-jie/)

- 大样例的生成策略确实要比正式数据的要弱一些，但是独立验题人说他中途的错误代码均无法通过所有大样例（他写的是直接分讨），所以我就没有怎么管大样例强度了，在这里给因为大样例挂分的选手谢罪了。

- 有些人写了意料之外的根据结论直接 DP 的大常数线性做法，由于所有验题人都没有发现该做法，所以并没有考虑到这点，并不是故意卡该做法。这里也给被卡的人谢罪了。

## 题意简述

给你一个初始长度为 $n$，**只包含** $\mathbf{0, 1, 2}$ 的序列 $a_{1 \sim n}$，你每次可以选择两个相邻的数 $p, q$，删去它们，并在原位置插入 $\mathrm{popc}(p + q)$。其中，$\mathrm{popc}(x)$ 表示 $x$ 在二进制表示下 $1$ 的个数。

显然每次操作后序列长度都会减少 $1$，所以执行 $n - 1$ 次操作后，这个序列会恰好剩下一个数。请你最小化剩下的这个数，并给出字典序最小的操作位置序列。

此题多测，设 $T$ 为组数，对所有数据，满足 $1 \le T \le 200$，$1 \le n \le 10^5$。

## 算法 1

我会爆搜！

时间复杂度：$\mathcal O(Tn! \times poly(n))$。

期望得分：$12$。

## 算法 2

我会区间 DP！设 $f_{i, j, k}$ 表示区间 $[i, j]$ 是否能得到 $k \ (0 \le k \le 2)$，枚举最小转移点即可。

时间复杂度：$\mathcal O(Tn^3)$。

期望得分：$24$。

## 算法 3

我会特殊性质 A！发现 $a$ 序列中只有 $1, 2$ 的时候 $\mathrm{popc}(p + q) = ((p - 1) \oplus (q - 1)) + 1$，其中 $\oplus$ 表示异或运算。

那么无论操作顺序答案都是一样的，答案也可以直接求出，最小字典序直接操作 $n - 1$ 次开头即可。

时间复杂度：$\mathcal O(Tn)$。

期望得分：$12$，结合区间 DP 后 $36$。

## 算法 4

我会判断答案！首先给出结论：

- 当且仅当 $a$ 序列全为 $0$ 时答案为 $0$；
- 序列 $a$ 没有 $0$ 时答案为 $2$ 的个数对 $2$ 取模的余数 $+1$；
- 否则，当且仅当在序列 $a$ 为“一段 $1$，$2, 0, 2$，一段 $1$”（左右两边的一段 $1$ 都可以为空）的形式时，答案为 $2$，其余情况为 $1$。

### 证明

前两个情况是显然的。先证明第三种情况的对应形式无法合成 $1$，可以发现如果 $0$ 不参与操作只是相当于减少了一个 $1$，还是该形式；而 $0$ 若参与操作，序列 $a$ 就会变为第二种情况，并且只有奇数个 $2$，显然答案为 $2$。所以该情况一定只能合成 $2$。

再证明非对应形式一定可以合成。考虑归纳，如果我们能找到一个 $0$，然后将其左右两边合成，只要左右两边不都是 $2$，最终就可以合出 $1$。

假设 $0$ 的个数大于两个，那么选择最左边的 $0$ 即可，右边至少有两个 $0$，一定可以得到 $1$；

假设 $0$ 的个数恰好有两个，那么序列 $a$ 一定是 $A0B0C$ 的形式，其中 $A, B$ 都是不存在 $0$ 的序列。如果 $B$ 为 $[2]$，那么先将 $B$ 和旁边一个 $0$ 合成即可得到 $A01C$ 的形式，该形式答案一定为 $1$；否则左右两个 $0$ 肯定有一个合法。

假设 $0$ 的个数只有一个。如果 $0$ 两边至少有一个不是 $2$，那么我们就有操作空间了：当 $2$ 有奇数个时，我们让最靠近 $0$ 的 $2$ 把经过的 $1$ 都干掉，与 $0$ 合并。否则我们直接让 $0$ 与它旁边的那个 $1$ 合并。假设这个 $0$ 的左右两边都不合法，那么一定有一边至少有三个 $2$，我们把最靠近 $0$ 的两个 $2$ 合并，$0$ 两边就至少有一个 $1$；否则可以直接合出 $1$。

这样所有情况都被考虑到了，证毕。

---

时间复杂度：$\mathcal O(Tn)$。

期望得分：$25$，结合前面算法后 $52$。

## 算法 5

考虑直接贪心，从前往后依次尝试合并，每次合并完之后重新扫一遍序列，判断答案是否变大，如果变大了就撤销这个操作。

这样时间复杂度看似是 $\mathcal O(Tn^3)$ 的，实际上是 $\mathcal O(Tn^2)$ 的。感性理解一下，第一个可以合并的位置出现的一般不会太晚，实际上第一个可以合并的位置最多不会超过 $3$。证明还是需要分讨，这里就不放了。

时间复杂度：$\mathcal O(Tn^2)$。

期望得分：$36$，结合前面算法后 $61$。

## 算法 6

使用平衡树一类的数据结构维护序列，每次快速找出下一个能操作的位置，或者直接暴力枚举位置。

时间复杂度：$\mathcal O(Tn \log n)$。

期望得分：视实现有 $48 \sim 92$，结合前面算法后 $70 \sim 94$。

## 算法 7

根据前面的结论，可以直接暴力维护前几个位置，后面的位置一定是连续的，这样就可以省掉 $\log$。

时间复杂度：$\mathcal O(Tn)$。

期望得分：$100$。

---

## 作者：_lmh_ (赞：10)

太长不看版：按字典序贪心，注意到最优的操作序列中的数都不会很大（实际上都小于等于三），所以只要能动态维护合法性就过了。如果你要的是这个做法可以去看别的题解，因为这篇题解和上面那个做法一点关系没有。

作为构造题，显然我们需要挖掘 $\mathrm{popc}$ 操作的性质，并且爆搜对正解很可能帮助不大，所以从特殊性质入手。

注意：文章特别长（但也很详细），建议每遇到一个问题时自己先想一想。如有更优的方案或者有疑问请私信作者。

下文中，记 $a \oplus b = \mathrm{popc}(a+b)$。

## $a$ 中不存在 $0$ 时怎么做？

注意到 $1 \oplus 1 = 2 \oplus 2 = 1$，$1 \oplus 2 = 2 \oplus 1 = 2$，这个操作与（将操作数）减一以后异或（再加上一）等价。

所以此时答案与操作顺序无关，每次贪心选择前两个数操作即可。

### 什么时候可以沿用刚才的贪心？否则该怎么办？

不妨设 $a$ 不全是 $0$。否则贪心的正确性是显然的。

注意到如果 $a$ 不全是 $0$ 那么答案一定非零，同时全程不会出现大于 $2$ 的数，因而答案只有两种可能。

如果贪心的结果是 $1$（在代码中，可以通过判断答案是否小于二），那一定最优；否则，我们就需要尝试把 $2$ 变成 $1$。

## 如何改变操作的结果？

注意到 $0 \oplus 1 = 0 \oplus 2 = 1$，因此只要将 $0$ 和 $2$ 操作，就能反转操作的结果。

当然我们要贪心选择字典序最小的方案，所以尽可能将这个操作放到后面进行。看最后一个 $0$ 的情况。（如果没有 $0$ 那就没救啦！）

我们先贪心地将这个 $0$ 前面全部合并成一个数，称其为**第一次合并**。

### 1. 这个 $0$ 前面没有数，或者第一次合并结果为 $0$

显然如果第一次合并结果为 $0$ 我们就可以将两个 $0$ 合并成一个，这样就成了一个开头为 $0$，其他项全部非零的数列。

如果我们将后面的数全部合并，然后再用 $0$ 和它进行操作，那么结果一定为 $1$，所以这种情况是有救的。

假设这个 $0$ 后面的数是 $1$，我们如果贪心合并就会使得结果为 $2$，所以需要设法将这个 $0$ 和 $2$ 合并反转结果。

一直对第二、三个数进行操作，直到出现 $2$ 为止。接下来就可以贪心合并了。

否则，这个 $0$ 后面的数是 $2$，我们如果贪心合并会使得结果为 $2$，说明我们进行了一次无意义的反转，需要将这个 $0$ 和 $1$ 合并。

一直对第二、三个数进行操作，直到出现 $1$ 为止。接下来就可以贪心合并了。

### 2. 第一次合并结果为 $1$

序列形如 `1 0 X X X X`，如果继续贪心就会把这个 $0$ 和 $1$ 合并，导致结果为 $2$。所以需要设法将这个 $0$ 和后面的 $2$ 合并反转结果。

注意到贪心合并 $0$ 和 $1$ 之后序列形如 `1 X X X X`，所以后面至少有一个 $2$，说明这么做一定能找到解法。

一直对第三、四个数进行操作，直到出现 $2$ 为止。将它和 $0$ 合并变成 $1$，接下来就可以贪心合并了。

### 3. 第一次合并结果为 $2$

序列形如 `2 0 X X X X`，如果继续贪心就会把这个 $0$ 和 $2$ 合并，导致结果为 $2$。所以需要设法将这个 $0$ 和后面的 $1$ 合并反转结果。

**注意到如果序列形如 `2 0 2 1 1 1 1 ...` 的话我们无法找到一个 $1$ 和这个 $0$ 合并**，这种情况我们留到下一节处理。

否则，一直对第三、四个数进行操作，直到出现 $1$ 为止。将它和 $0$ 进行一次操作，接下来就可以贪心合并了。

## 如果第一次合并之后序列形如 `2 0 2 1 1 1 1 ...` 怎么办？

这时候我们发现贪心到这一步已经太晚了，所以进行反悔。

不断进行反悔，每反悔一步就会“吐出来”一个数。这时序列形如 `A X X X X 0 2 1 1 1 1`，其中 $X$ 为反悔之后“吐出来”的序列，它是一个后缀。$A$ 就是剩余的贪心合并的部分。

当我们“吐出来”的数为 $0$ 或者所有“吐出来”的数（显然都是正整数，否则就满足前一个条件）操作之后结果为 $1$ 时停止。

如果吐到最后都无法满足条件，那么序列一定形如 `... 1 1 1 2 0 2 1 1 1 ...`，这种就没救了，答案只能为 $2$。

### 1. 吐出来的最后一个数是 $0$

此时序列形如 `A 0 1 1 1 2 0 2 Y`，其中 $Y$ 要么为空，要么全是 $1$。接下来有一段特别长的分类讨论，希望你能看完。

**如果 $A=1$**，那么我们必须将第一个 $0$ 与 $2$ 合并（否则就浪费了），所以先将中间 `1 1 1 2` 部分合并成一个数 $2$，然后执行以下操作：

`1 0 2 0 2 Y`（合并前）

`1 1 0 2 Y`（合并第二、第三个数）

`1 0 2 Y`（合并第一、第二个数）

`1 1 Y`（合并第二、第三个数）

之后就可以贪心了。

**如果 $A=2$**，那么我们需要将恰好一个 $0$ 与 $1$ 合并（想象一下贪心的过程，两个 $0$ 都和 $2$ 合并）。

如果序列形如 `2 0 2 0 2 Y`，那么我们进行以下操作：

`2 0 2 0 2 Y`（合并前）

`2 1 0 2 Y`（合并第二、第三个数）

`2 1 2 Y`（合并第二、第三个数）

之后就可以贪心了。

否则，序列形如 `2 0 1 1 1 2 0 2 Y`，直接将第一个 $0$ 与右边的 $1$ 合并，之后将左边所有数贪心合并成一个 $1$，序列变成 `1 0 2 Y`，将第二、第三个数合并以后就能贪心了。

**否则，$A$ 不存在或 $A=0$**，先将 $A$ 与 $0$ 合并（如果不存在就不用了）。

第一种情况：序列形如 `0 2 0 2 Y`，进行以下操作：

`0 2 0 2 Y`（合并前）

`1 0 2 Y`（合并第一、第二个数）

`1 1 Y`（合并第二、第三个数）

之后就可以贪心了。

第二种情况：序列形如 `0 1 1 1 2 0 2 Y`，此时将 `1 1 1 2` 的部分合并成一个 `2`，就可以归约到上面的那种情况。

**至此，我们解决了吐出来的最后一个数是 $0$ 的情况。**

### 2. 吐出来的数全部都是正整数

这时序列一定形如 `A 2 1 1 1 2 0 2 Y` 或者 `A 1 0 2 Y`，其中 $A=2$。（别急着写代码，把这一节看完）

如果是前面那种情况，注意到 $A$ 和 $2$ 合并结果一定是 $1$，所以如果这么做就废了。因此，我们必须将 `2 1 1 1 2` 合并成一个 `1`，使序列形如 `2 1 0 2 Y`。

那么将第二、第三个数合并，序列会变成 `2 1 2 Y`，之后贪心就行了……吗？

**实际上，有可能出现 $A=0$，此时它和 $2$ 合并结果依然为 $1$，因此必须将 `2 1 1 1 2` 合并成一个 `1`；但之后我们有更优的方案。**

考虑如下操作：

`0 1 0 2 Y`（操作前）

`1 0 2 Y`（合并第一、二个数）

`1 1 Y`（合并第二、三个数）

之后进行贪心，可以得到更优的结果。（然而并没有这样的数据，在管理员加上这玩意之前你不判断也可以拿满分）

于是我们成功解决了这道题。时间复杂度 $O(n)$，需要 $O(1)$ 的额外空间。

代码：
```
#include<bits/stdc++.h>
using namespace std;
#define ll int
#define ull unsigned long long
const int N=100007,op[3][3]={{0,1,1},{1,1,2},{1,2,1}};
const ull B=13331;
ll T,n,a[N],k,p,lst0;
char s[N];
ull ans;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>(s+1);n=strlen(s+1);k=a[1]=s[1]-'0';ans=0;
		for (int i=2;i<=n;++i){a[i]=s[i]-'0';k=op[k][a[i]];}
		if (k<2){
			cout<<k<<' ';
			for (int i=1;i<n;++i) ans=ans*B+1;
			cout<<ans<<'\n';
			continue;
		}
		lst0=0;
		for (int i=n;i;--i) if (!a[i]){lst0=i;break;}
		if (!lst0){
			cout<<k<<' ';
			for (int i=1;i<n;++i) ans=ans*B+1;
			cout<<ans<<'\n';
			continue;
		}
		bool fl=0;
		for (int i=1;i<lst0;++i) fl|=(bool)a[i];
		if (!fl){
			cout<<"1 ";
			k=a[lst0+1];p=lst0+1;
			for (int i=1;i<lst0;++i) ans=ans*B+1;
			while(k==a[lst0+1]){
				ans=ans*B+2;k=op[k][a[++p]];
			}
			for (int i=0;i<=n-p;++i) ans=ans*B+1;
			cout<<ans<<'\n';
			continue;
		}
		k=a[1];
		for (int i=2;i<lst0;++i){ans=ans*B+1;k=op[k][a[i]];}
		ll tmp=a[lst0+1],p=lst0+1;
		while(k==tmp&&p<=n){tmp=op[tmp][a[++p]];ans=ans*B+3;}
		if (p<=n){
			ans=ans*B+2;
			for (int i=0;i<=n-p;++i) ans=ans*B+1;
			cout<<"1 "<<ans<<'\n';continue;
		}
		ans=0;
		tmp=a[lst0-1];p=lst0-1;
		while(tmp!=1&&p) tmp=op[tmp][a[--p]];
		if (!p){
			cout<<"2 ";
			for (int i=1;i<n;++i) ans=ans*B+1;
			cout<<ans<<'\n';
			continue;
		}
		cout<<"1 ";
		k=a[1];
		for (int i=2;i<p;++i){k=op[k][a[i]];ans=ans*B+1;}
		if (a[p]==0){
			if (k==1){
				for (int i=2;i<lst0-p;++i) ans=ans*B+3;
				ans=((ans*B+2)*B+1)*B+2;
				for (int i=1;i<=n-lst0;++i) ans=ans*B+1;
				cout<<ans<<'\n';
			}
			else if (k==2){
				if (lst0==p+2){
					ans=(ans*B+2)*B+2;
					for (int i=1;i<n-p;++i) ans=ans*B+1;
					cout<<ans<<'\n';
				}
				else{
					ans=ans*B+2;
					for (int i=1;i<lst0-p;++i) ans=ans*B+1;
					ans=ans*B+2;
					for (int i=1;i<=n-lst0;++i) ans=ans*B+1;
					cout<<ans<<'\n';
				}
			}
			else{
				if (p>1) ans=ans*B+1;
				if (lst0==p+2){
					ans=(ans*B+1)*B+2;
					for (int i=1;i<=n-lst0;++i) ans=ans*B+1;
					cout<<ans<<'\n';
				}
				else{
					for (int i=2;i<lst0-p;++i) ans=ans*B+2;
					ans=(ans*B+1)*B+2;
					for (int i=1;i<=n-lst0;++i) ans=ans*B+1;
					cout<<ans<<'\n';
				}
			}
		}
		else{
			if (k==2){
				for (int i=1;i<=lst0-p;++i) ans=ans*B+2;
				for (int i=0;i<=n-lst0;++i) ans=ans*B+1;
				cout<<ans<<'\n';
			}
			else{
				for (int i=1;i<lst0-p;++i) ans=ans*B+2;
				ans=(ans*B+1)*B+2;
				for (int i=1;i<=n-lst0;++i) ans=ans*B+1;
				cout<<ans<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：mango2011 (赞：9)

## 废话

考场上由于时间紧张以及乱用树状数组导致分数很低，赛后稍微改了改考场代码就过了。

## 分析

观察一下这个操作，发现不论如何操作都不会出现 $\ge3$ 的数，产生 $2$ 的情况只有 $\operatorname{popc}(1+2)=2$，产生 $0$ 的情况只有 $\operatorname{popc}(0+0)=0$，其他情况只能出现 $1$。于是有了下面的初步想法：

1) 当且仅当 $a_i=0$ 时答案是 $0$。
2) 大多数情况下，答案都是 $1$（仅仅是感觉，因为产生 $2$ 的情况极少）。

第一条性质可以直接用 $0$ 的产生条件来证明，特判掉，具体分析第二条：

观察特殊性质，发现第一档是 $a_i\not =0$，所以首先分析 $a_i\not=0$ 的情形：

发现 $1$ 和 $1$ 操作产生 $1$，$1$ 和 $2$ 操作产生 $2$，$2$ 和 $2$ 操作产生 $2$，因此 $2$ 的个数的奇偶性不变，当且仅当 $2$ 的个数为奇数的时候答案为 $2$，否则为 $1$，直接构造 $\{1,1,1,1,1\dots\}$ 就行了。

然后观察存在 $a_p=0$ 的情形，打表可知当且仅当 $a$ 为下面的形式的时候答案为 $2$，其余为 $1$：

$$\{1,1,1,1,\dots,1,1,2,0,2,1,1,\dots,1,1,1,1\}$$

充分性可以用归纳法以及 $a_i\not=0$ 时的结论进行证明；必要性直接给出构造即可。

把上面两条综合起来就可以得到答案为 $1$ 的充要条件。

接下来考虑构造方案：

1) 答案为 $1$，按位贪心，由于已经有了充要条件所以可以检查每一个位置是否可行，均摊后复杂度为 $O(n)$。
2) 答案为 $2$，直接构造 $\{1,1,1,\dots,1,1,1\}$ 即可。

综上我们做完了本题，单组复杂度 $O(n)$。

[简短的代码](https://www.luogu.com.cn/record/187655850)

---

## 作者：BreakPlus (赞：7)

本文提供不同的实现方式。非常方便，不需要分类讨论。

### Part 0 结论部分（可跳过，其他题解均有介绍）

定义其中的 $\text{popc}(x+y)$ 运算为 $x*y$，写出表格：

|$*$|$0$|$1$|$2$|
|:-:|:-:|:-:|:-:|
|$0$|$0$|$1$|$1$|
|$1$|$1$|$1$|$2$|
|$2$|$1$|$2$|$1$|

发现 $1,2$ 之间的运算相当于异或。

----

先特判序列全 $0$，答案为 $0$，然后考虑在什么情况下答案会为 $2$（定义这种情况**不合法**）。先观察一些简单的情况，比如：

+ 序列没有 $0$ 且 $2$ 有奇数个；
+ 序列为 $202$。

进一步，观察序列只剩一个 $0$ 的情况。

+ 若 $0$ 的两边可能出现 $1$ 或 $2$，那么必有一种能规约到**没有 $0$ 且 $2$ 有偶数个**的情况，合法；
+ 若 $0$ 的两边只能出现 $1$，显然整个序列都没有 $2$，那么显然合法。
+ 否则，$0$ 的两边只能出现 $2$，这种情况和 $202$ 类似，不合法。显然这种情况一定是 $1\dots12021\dots1$。

在多个 $0$ 的情况下一定合法，在此略去证明。

~~赛时果断打表，避免了一系列观察。~~

### Part 1 实现方式

我们的大致操作是，枚举一个位置，快速判断其删除后是否仍合法，然后将其删去。显然每次只可能删除开头的几个位置。因此如果能 $\mathcal{O}(1)$ 删除和判断就能解决该问题。

如何快速判断一个序列是否形如 $1\dots12021\dots1$？

首先我们要考虑用什么数据结构维护序列。每次删除一个数，剩余的拼接在一起，貌似**链表**是最简单的选择。

然而链表不支持访问任意位置，但是它支持**考察邻域**。我们用考察邻域的方式重写判定：

+ $0$ 的数量为 $1$，$2$ 的数量为 $2$，剩余均为 $1$；
+ 序列中存在一个子串 $20$，一个子串 $02$。

这样在执行链表删除操作的时候很容易顺便维护（加边、断边的时候维护 $20$ 和 $02$ 的数量）。

### Part 2 代码实现

```cpp
const ull base = 13331;
struct Data{
	int c[2], c20, c02;
	Data(int a=0,int b=0,int q=0,int d=0){ c[0]=a, c[1]=b, c20=q, c02=d; }
	bool check(){
		if(!c[0]) return !(c[1]&1);
		else if(c[0]==1 && c[1]==2 && c20==1 && c02==1) return 0;
		return 1;
	} // 判定
}glo, cpy;
// 一个结构体维护链表信息
int n;
ull hsh;
inline void push(int x){
	hsh = hsh * base + x;
} // 更新操作序列
char s[100005];
int nx[100005], pr[100005], a[100005];

int pp[5] = {0, 1, 1, 2, 1};
inline int calc(int x,int y){
	return pp[x+y];
}
inline void sle(int x, int d){
	if(x^1) cpy.c[!!x] += d;
}// 加点、删点
inline void slo(int x,int y,int d){
	if(a[x]==0 && a[y]==2) cpy.c02 += d;
	if(a[x]==2 && a[y]==0) cpy.c20 += d;
}// 加边、断边
inline void modify(int x){
	cpy = glo; int y = nx[x];
	if(pr[x]) slo(pr[x], x, -1);
	slo(x, y, -1);
	if(nx[y]) slo(y, nx[y], -1);
	sle(a[x], -1); sle(a[y], -1);
	
	sle(calc(a[x],a[y]), 1);
	int tmp=a[x]; a[x]=calc(a[x], a[y]);
	if(pr[x]) slo(pr[x], x, 1); 
	if(nx[y]) slo(x, nx[y], 1);
	a[x] = tmp;
}
void procedure(){
	hsh=0; bool flg=1; glo=Data();
	scanf("%s", s);
	n=strlen(s);
	for(int i=1;i<=n;i++) a[i]=s[i-1]-'0';
	for(int i=1;i<=n;i++) flg&=(a[i]==0);
	if(flg){
		for(int i=1;i<n;i++) push(1);
		printf("%d %llu\n", 0, hsh);
		return;
	}
	for(int i=1;i<=n;i++)
		pr[i]=nx[i]=0;
	for(int i=1;i<=n;i++){
		if(a[i]^1) glo.c[!!a[i]]++;
		if(i<n){
			nx[i]=i+1; pr[i+1]=i;
			if(a[i]==2 && a[i+1]==0) glo.c20++;
			if(a[i]==0 && a[i+1]==2) glo.c02++;
		}
	}
	if(!glo.check()){
		for(int i=1;i<n;i++) push(1);
		printf("%d %llu\n", 2, hsh);
		return;
	}
	for(int T=1;T<n;T++){
		int hd=1, cnt=1;
		while(1){
			modify(hd);
			if(cpy.check()){
				glo=cpy;
				a[hd] = calc(a[hd], a[nx[hd]]);
				pr[nx[nx[hd]]] = hd;
				nx[hd] = nx[nx[hd]];
				push(cnt);
				break;
			}
			hd=nx[hd]; cnt++;
			if(!hd) break;
		} // 找到最靠前的合法位置并删除
	}
	printf("%d %llu\n", 1, hsh);
}
```

---

## 作者：Ling_zeroo (赞：3)

发现题解区全是贪心的做法，对于自己巨大的分类讨论产生了怀疑，但是为了不辜负推了一节晚修的通项式，遂书一篇题解以记之。

首先，对于答案是 $0$ 或 $2$ 的情况，操作是简单的，全部都是 $1$ 就可以了。

于是我们思考如何判断答案，可以瞪出以下结论：

- 如果答案为 $0$，那么 $a$ 中必然全是 $0$

- 如果答案为 $2$，若 $a$ 中没有 $0$，由于 $1$ 和 $2$ 的运算类似于异或运算，故 $2$ 的个数为奇数；若有 $0$，则必然构成形如 $1\cdots12021\cdots1$ 的结构（前后可以没有 $1$）

- 否则答案为 $1$

这里的证明比较感性（或者说讲起来很繁杂），可以自己的试试看。

判断完了答案，我们只需要对答案是 $1$ 的 $a$ 构造操作。

感性体会一下合并的过程，发现：最后答案只和产生贡献的 $2$ 个数的奇偶有关，和 $1$ 的数量无关；一个 $0$ 可以使得和它相邻的一个区间内所有的 $2$ 不产生贡献。

为了方便描述，接下来我们记操作序列 $Opt$ 中一个长度为 $L$ 的全 $k$ 子串为 $k^L$；

记 $O_1,O_2,O_3$ 分别指代倒数第一、二、三个 $0$（如果存在的话），$p_1,p_2,p_3$ 为 $O_1,O_2,O_3$ 的位置下标，$c_1,c_2,c_3$ 分别为 $O_1$ 到结尾、$O_2$ 到 $O_1$、$O_3$ 到 $O_2$ 之间 **产生贡献的** $2$ 的个数。这里的 **产生贡献的** $2$ 是考虑到，如果是序列开头的一长串 $0$，其后紧跟的一个数字是 **一定没有贡献** 的，如果这个数是 $2$ 则不能计入 $c$ 中！

一切万无一失——

### 来吧，分类讨论！

#### Case1 特判

- 当 $a$ 中不存在 $0$，此时 $2$ 的个数为偶，有：
$$Opt=1^{n-1}$$

#### Case2 从 $O_1$ 开始依次考虑：

- 当 $c_1$ 为偶数时，有：
$$Opt=1^{n-1}$$

- 当 $c_1$ 为奇数，但是 $O_1$ 在 序列开头的一串 $0$ 中时，用 $O_1$ 使其后最近的 **有贡献的** $2$ 没有贡献，记这个 $2$ 的位置下标为 $j$，有：
$$Opt=1^{p_1-1}+2^{j-p_1-1}+1^{n-j+1}$$

#### Case3 上述情况都不符合，从 $O_2$ 开始依次考虑：

- 当 $c_2$ 为偶数时，用 $O_1$ 使其后最近的 $2$ 没有贡献，记这个 $2$ 的位置下标为 $j$，有：
$$Opt=1^{p_1-2}+3^{j-p_1-1}+2^{1}+1^{n-j+1}$$

- 当 $c_2$ 为奇数时，依次考虑：

  - 若 $a_{p_1+1}\neq2$，则用其消耗掉 $O_1$，有：
   $$Opt=1^{p_1-2}+2^{1}+1^{n-p_1}$$
  
  - 若 $a_{p_1+1}=2$，但 $c_1\geq3$，则用 $O_1$ 后最近的两个 $2$ 消耗掉 $O_1$，记第二个 $2$ 的位置下标为 $j$，有：
   $$Opt=1^{p_1-2}+3^{j-p_1-1}+2^{1}+1^{n-j+1}$$

  - 若 $a_{p_1-1}\neq2$，则用其消耗掉 $O_1$，有：
   $$Opt=1^{p_1-3}+2^{1}+1^{n-p_1+1}$$

  - 若 $a_{p_1-1}=2$，但 $c_2\geq3$，则用 $O_1$ 前最近的两个 $2$ 消耗掉 $O_1$，记第二个 $2$ 的位置下标为 $j$，有：
   $$Opt=1^{j-2}+2^{p_1-j}+1^{n-p_1+1}$$
 
#### Case4 上述情况都不符合，从 $O_3$ 开始依次考虑

此时 $a$ 的结构必定为 $\cdots01\cdots1202$（中间的 $1$ 可以没有）

- 当 $O_2$ 在 序列开头的一串 $0$ 中时，用 $O_2$ 使 $O_1$ 前的 $2$ 没有贡献，有：
  $$Opt=1^{p_2-2}+2^{p_1-p_2-2}+1^1+2^1+1^{n-p_1}$$

- 当 $c_3$ 为偶数时，用 $O_1,O_2$ 分别使其后的 $2$ 没有贡献，有：
  $$Opt=1^{p_2-2}+3^{p_1-p_2-2}+2^1+1^1+2^1+1^{n-p_1}$$

- 当 $c_3$ 为奇数时，依次考虑：

  - 若 $a_{p_2+1}\neq2$，则用其消耗掉 $O_2$，将倒数第二个 $2$ 计入贡献，有：
   $$Opt=1^{p_2-2}+2^{1}+1^{p_1-p_2-1}+2^1+1^{n-p_1}$$
  
  - 否则 $a$ 形为 $\cdots0202$，消去倒数第二个 $2$ 将最后一个 $2$ 计入贡献，有：
   $$Opt=1^{p_2-2}+2^{2}+1^{n-p_2-1}$$

在归纳出一共 **十二** 个通项之后，你会发现，你对完了！

时间复杂度 $O(Tn)$，~~代码长飞了~~

[code](https://www.luogu.com.cn/paste/ylg6bhmg)

---

## 作者：lizhous (赞：2)

结论：

- 如果序列包含奇数个 $2$。
  - 若有 $0$，则必然能合出 $1$。（A）
  - 否则只能合出 $2$。（B）
- 否则
  - 全 $0$ 合出 $0$。（C）
  - 若只存在一个 $202$ 且其他位置都是 $1$，则只能合出 $2$。（D）
  - 否则能合出 $1$。（E）

接下来给出证明。

C 是显然的。若不满足 C 即存在非 $0$ 的数，那么 ppc 不可能清 $0$。

我们证明 DE。

> 充分性：
>
> 若是这个结构，因为 $(2,1)\to2,(2,0)\to1$，所以只有中间一个 $0$ 可以消去 $2$，那么必然留下一个 $2$ 无法消去，最后还是 $2$。

>  必要性：
>
>  若不是这个结构
>
>  - 若 $2$ 的数量大于 $2$ 个，我们有如下策略：
>
>   1. 把所有非 $2$ 的数合并，最后形如 $2(0/1)2(0/1)2$，不难发现合并顺序并不影响结果。
>
>   2. - 若没有 $0$，则用 $2$ 吃掉所有的 $1$，再两两合并成若干个 $1$，此时不会剩下其他东西，直接合并成 $1$ 即可。
>      - 否则找到所有形如 $21212$ 的极长连续段，它的前面或者后面必然有一个 $0$，用 $2$ 吃掉所有的 $1$，再两两合并剩下 $1$ 或 $2$。
>
>   3. - 如果周围有 $20$ 或 $02$。
>        - 如果不是 $20(1/2)02$，那么如果是 $1$ 就和 $0$ 合并成 $1$ 再用 $2$ 吃掉抵消影响。注意此操作不会影响 $2$ 的奇偶性。
>         - 否则形如 $20(1/2)02$，注意到因为 $2$ 是偶数，所以中间的 $21212$ 段中 $2$ 也是偶数，所以实际上只有 $20102$ 一种情况，按如下方法合并即可：$20102\to1102\to111\to 1$。
>       - 否则偶数个 $2$ 合出的是 $1$ 直接结束。
>
>   4. 那么现在只剩下形如 $20202$ 的串且 $2$ 的个数为偶数，注意前后也有可能有 $0$。
>
>      - 如果前后任何一个位置有 $0$，那么 $0$ 的数量大于等于 $2$ 的数量，全部合并即可。
>
>      - 否则我们先随便找到一个 $20$ 合并把 $2$ 的数量变成奇数，然后找到所有 $20202$ 的子串，注意这里不是形如，有如下方法可以合并：
>
>        1. $20202\to1202\to112\to12\to2$。
>        2. $20202\to2012\to212\to22\to1$。
>
>        那么我们除了最后一次合并用法 $2$ 其他都用法 $1$ 即可合并出 $1$，因为每次可以减少两个 $2$。
>
>  - 否则形如 $(0/1)2(0/1)2(0/1)$。
>
>   - 如果 $0$ 大于等于 $2$ 个，那么和 $2$ 合并即可。
>   - 否则必然形如 $(0/1)212(0/1)$，用 $2$ 吃掉中间的 $1$ 然后两个 $2$ 合并即可。
>
>  至此所有情况讨论完。

所以此结论得证。

证 AB。

> 充分性：延用偶数变成奇数后的策略。
>
> 必要性：假如没有 $0$，那么 $1$ 不会对 $2$ 的数量产生影响，只能两个 $2$ 对碰，最后还是会剩下一个 $2$。
>
> 至此所有情况讨论完。

所以此结论得证。

实现的时候先判掉所有答案不是 $1$ 的，这些都可以一直删第一位完成。

发现一定存在操作序列满足只操作过前 $3$ 位，下面是策略：

1. 如果第一个数是 $0$，那就一直操作第二个数，最后剩一个和 $0$ 合并，无论剩什么都是 $1$。
2. 否则一直操作第一个数直到第二个数是 $0$，然后一直操作第三个数。最后剩下三个数形如 $?0?$。
3. 如果不是 $202$，那么最多只有一个 $2$，和 $0$ 合并了就可以了。
4. 否则因为不是 $111202111$，那么不是 $21111$ 的那边
   - 是右边，合并的过程中 $0$ 右边一定存在过 $1$ 且后面还有 $2$，那可以用它把 $0$ 吃掉，最后 $22$ 合并。而这个过程先缩前面，后面一定可以操作点 $3$，而前面没有 $0$ 只能是有 $22$，那拿哪个 $2$ 吃 $1$ 都是一样的。
   - 是左边，若 $0$ 左边是 $1$ 那再左边肯定是 $2$，直接 $10$ 合并然后 $22$ 合并。否则 $20$ 前面极长 $1$ 前面总是 $0/2$， 直接 $12$ 合并 $20$ 合并然后 $0/2,2$ 合并。

也就是说对于所有情况，其最小的第一次操作一定小于等于 $3$。

继续往下思考直接分讨寻找字典序最小的构造不如利用这个结论字典序贪心，即贪心的把每一位能往小选就往小选。我们发现如果操作一个位置不影响答案，就可以操作。于是维护序列 $0,1,2,202$ 的个数容易判断哪一位可以被操作。前三位是可以暴力删除的，最终是常数略大 $O(n)$。

---


# [Code+#8 初赛] 普勒亚

## 题目背景

搬运自 [Code+ #8 初赛](https://gitlink.org.cn/thusaa/codeplus8pre)。

## 题目描述

魔法少女小七得到了一个神奇的长度为 $n$ 的字符串 $s$，每个位置对应有一个魔法值 $a_i$。每次她可以使用一个长度为 $l$ 的子串作为咒语。对于长度为 $l$ 的咒语 $t$，它的魔力是它在 $s$ 中出现的每个位置的右端点 $pos_j$（即 $\forall i \in [0,l),\ s_{pos_j-i}=t_{l-i}$）的魔法值 $a_{pos_j}$ 从左往右连成的序列的**前缀最大值**个数。

对于每个 $i \in [1,n]$，小七想知道 $s$ 中所有长度为 $i$ 的咒语（两个咒语不同当且仅当其对应的字符串内容不同）的魔力之和。你能帮帮她吗？她会给你一个开心魔法作为报酬！

**前缀最大值**：对于序列 $W$ 来说 $W_i$ 是前缀最大值当且仅当对于任何 $j<i$ 都有 $W_j<W_i$。

## 说明/提示

**【样例 #1 解释】**

长度为 $1$ 的子串有 `a` 和 `b` 两种，分别构成序列 `5 3 1` 和 `2 4`，各自的前缀最大值个数为 $1$ 和 $2$。

长度为 $2$ 的子串有 `ab` 和 `ba` 两种，分别构成序列 `2 4` 和 `3 1`，各自的前缀最大值个数为 $2$ 和 $1$。

长度为 $3$ 的子串有 `aba` 和 `bab` 两种，构成序列 `3 1` 和 `4`，各自的前缀最大值个数为 $1$ 和 $1$。

长度为 $4$ 的子串有 `abab` 和 `baba` 两种，构成序列 `4` 和 `1` ，各自的前缀最大值个数为 $1$ 和 $1$。

长度为 $5$ 的子串有 `ababa` 一种，构成序列 `1`，前缀最大值个数为 $1$。

**【数据范围】**

对于 $20\%$ 的数据，$n \le 100$。

对于另外 $20\%$ 的数据，$n \le 5000$。

对于另外 $20\%$ 的数据，$s$ 中只有字符 `a`。

对于 $100\%$ 的数据，保证 $n \le 100,000$，$s$ 中只包含小写英文字母。

## 样例 #1

### 输入

```
ababa
5 2 3 4 1```

### 输出

```
3 3 2 2 1```

## 样例 #2

### 输入

```
aaaa
3 2 3 4```

### 输出

```
2 3 2 1```

# 题解

## 作者：dAniel_lele (赞：2)

建出 SA，枚举长度 $x$。

对于每个子串的等价类维护一个 $a_i$ 递增集合。

如果 SA 之后相邻两个后缀的 lcp 为 $x$，即对于所有长度小于等于 $x$ 的子串这两个位置开始的均相同，那么需要合并并修改递增集合。

考虑启发式合并，每次加入先判断是否是前缀最大值，然后将后面的小于他的 `erase`。注意别让你的指针失效了，~~有一位 APIO 斩获 115 分的选手在 WC 考场上因为这件事挂分痛失 AK。~~

总复杂度 $O(n\log^2n)$。

```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
#define lowbit(i) (i&(-i))
using namespace std;
set<pair<int,int>> st[100005];
int fd[100005];
int find(int i){
	return fd[i]==i?fd[i]:fd[i]=find(fd[i]);
}
string s; int n,a[100005];
int f[100005][20],len,ord[100005],rpos[100005],reml[100005];
vector<pair<int,int>> v1[100005],v2[100005];
int lcp(int i,int j){
	int ret=0;
	for(int k=19;k>=0;k--){
		if(i>=(1<<k)&&j>=(1<<k)){
			if(f[i][k]==f[j][k]){
				ret+=(1<<k);
				i-=(1<<k);
				j-=(1<<k);
			}
		}
	}
	return ret;
}
int ans[100005];
signed main(){
	cin>>s; n=s.size(); s=" "+s;
	for(int i=1;i<=n;i++) cin>>a[i],fd[i]=i;
	for(int i=1;i<=n;i++) f[i][0]=s[i]-'a'+1; len=26;
	for(int i=1;i<=19;i++){
		for(int j=0;j<=max(len,n);j++) v1[j].clear(),v2[j].clear();
		for(int j=1;j<=n;j++) if(j<=(1<<(i-1))) v1[0].push_back(make_pair(f[j][i-1],j)); else v1[f[j-(1<<(i-1))][i-1]].push_back(make_pair(f[j][i-1],j));
		for(int j=0;j<=max(len,n);j++) for(auto v:v1[j]) v2[v.first].push_back(make_pair(j,v.second));
		int cnt=0; pair<int,int> lst=make_pair(-1,-1);
		for(int j=0;j<=max(len,n);j++) for(auto v:v2[j]) cnt+=(make_pair(j,v.first)!=lst),lst=make_pair(j,v.first),f[v.second][i]=cnt;
	}
	for(int i=1;i<=n;i++) ord[i]=f[i][19],rpos[ord[i]]=i;
	vector<pair<int,int>> tmp;
	for(int i=1;i<n;i++) reml[i]=lcp(rpos[i],rpos[i+1]),tmp.push_back(make_pair(reml[i],i));
	sort(tmp.begin(),tmp.end()); reverse(tmp.begin(),tmp.end());
	int it=0,ret=0;
	for(int i=n;i>=1;i--){
		st[i].insert(make_pair(i,a[i])); ret++;
		while(it!=tmp.size()&&tmp[it].first==i){
//			cout<<i<<" "<<tmp[it].first<<" "<<tmp[it].second<<"\n";
			int pos=tmp[it].second;
			int u=find(rpos[pos]),v=find(rpos[pos+1]);
			if(st[u].size()<st[v].size()) swap(u,v);
			ret-=st[u].size(),ret-=st[v].size();
			for(auto p:st[v]){
				vector<pair<int,int>> remdel;
				auto now=st[u].lower_bound(p);
				if(now!=st[u].begin()&&((*prev(now)).second>=p.second)) continue;
				while(now!=st[u].end()&&(p.second>=(*now).second)){
					remdel.push_back(*now);
					now=next(now);
				}
				for(auto q:remdel) st[u].erase(st[u].find(q));
				st[u].insert(p);
			}
			ret+=st[u].size();
			fd[v]=u;
			it++;
		}
		ans[i]=ret;
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
	return 0;
}
```

---

## 作者：Erine (赞：0)

SAM 入门。

首先建出 SAM。

对每个结点，只要知道出现位置的前缀最大值个数，就能对 $[\text{minlen}, \text{len}]$ 内做出贡献。可以差分。

至于知道出现位置，可以遍历前缀，在对应的位置插上 $i$。然后树上合并起来就是出现位置。

要知道前缀最大值可以用 set 启发式合并一下，每次暴力把没有用的弹出，也就是只维护前缀最大值序列。复杂度正确。

2log。

---

## 作者：Linge_Zzzz (赞：0)

# Sol

首先注意到题面里的“每个子串出现的右端点”，不难想到这就是 SAM 的 $\text{endpos}$ 集合，所以先对串 $s$ 建出 SAM 再说。

我们要维护 $\text{endpos}$ 相关的信息，不妨把问题放到 Parent Tree 上考虑。不难想到用 set 启发式合并维护前缀最大值的位置以及值。

时间复杂度 $O(n\log^2n)$。

# Code

忘写启发式合并卡常 INF 年，写完直接最优解。

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
typedef pair<int,int> pii;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
const int N=2e5+10,INF=0x3f3f3f3f,mod=1e9+7;
int n,a[N],ans[N];
set<pii> st[N];
char s[N];
struct node{
	int len,link;
	int e[26];
}t[N];
int tot,lst;
void init(){
	t[0].link=-1;
}
void extend(int c){
	int np=++tot;
	t[np].len=t[lst].len+1;
	st[np].insert(make_pair(t[np].len,a[t[np].len]));
	int p=lst;
	while(p!=-1&&!t[p].e[c]){
		t[p].e[c]=np;
		p=t[p].link;
	}
	if(p==-1){
		t[np].link=0;
	}else{
		int q=t[p].e[c];
		if(t[q].len==t[p].len+1){
			t[np].link=q;
		}else{
			int nq=++tot;
			t[nq]=t[q];
			t[nq].len=t[p].len+1;
			while(p!=-1&&t[p].e[c]==q){
				t[p].e[c]=nq;
				p=t[p].link;
			}
			t[np].link=t[q].link=nq;
		}
	}
	lst=np;
}
struct edge{
	int v,nxt;
}e[N];
int head[N],cnt=2;
void add(int u,int v){
	e[cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
}
void merge(set<pii> &x,set<pii> &y){
	if(x.size()<y.size()){
		merge(y,x);
		x.swap(y);
		return;
	}
	for(pii k:y){
		set<pii>::iterator it=x.upper_bound(k);
		if(it!=x.begin()&&prev(it)->second>=k.second)continue;
		while(it!=x.end()&&it->second<=k.second){
			set<pii>::iterator tmp=it;
			it++;
			x.erase(tmp);
		}
		x.insert(k);
	}
}
void dfs(int u){
	for(int i=head[u];i;i=e[i].nxt){
		dfs(e[i].v);
		if(!u)continue;
		merge(st[u],st[e[i].v]);
	}
	if(u){
		int l=t[t[u].link].len+1;
		int r=t[u].len;
		int k=st[u].size();
		ans[l]+=k,ans[r+1]-=k;
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>(s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++)cin>>a[i];
	init();
	for(int i=1;i<=n;i++)extend(s[i]-'a');
	for(int i=1;i<=tot;i++)add(t[i].link,i);
	dfs(0);
	for(int i=1;i<=n;i++)ans[i]+=ans[i-1];
	for(int i=1;i<=n;i++)cout<<ans[i]<<' ';
	return 0;
}
```

---


# [Code+#8 初赛] 图

## 题目背景

搬运自 [Code+ #8 初赛](https://gitlink.org.cn/thusaa/codeplus8pre)。

## 题目描述

本题中，对于一个无重边自环的无向图，称图上的一条道路为**简单路**当且仅当其不经过重复节点。即，假设该道路经过的节点依次为 $(u_1,u_2,\cdots,u_k)$，则这条道路为简单路当且仅当 $u_1,u_2,\cdots,u_k$ 两两不同。

给出大质数 $P$ 和 $q$ 次询问，每组询问给出正整数 $n$，你需要求出满足以下所有条件的**有标号**无向图个数，对 $P$ 取模：

1. 图有 $n$ 个节点且不存在重边与自环；
2. 图上不存在边数为 $3$ 的简单路，即图上无法找到四个两两不同的节点 $u_1,u_2,u_3,u_4$ 满足 $(u_1,u_2),(u_2,u_3),(u_3,u_4)$ 均在图中；
3. 在满足条件 1 和 2 的基础上，图的边数最多。

## 说明/提示

**【样例解释】**

以下样例解释将用 $1$ 到 $n$ 之间的整数给每个节点进行编号。

对于第一组询问，只有边集为 $\varnothing$ 的图满足条件。

对于第二组询问，其中两个满足条件的图的边集分别为 ${(1,2)(2,3)(1,3)(4,5)(5,6)(4,6)}$ 和 ${(1,3)(3,5)(1,5)(2,4)(4,6)(2,6)}$。

**【数据范围】**

对于全部数据，保证 $10^8\lt P\lt 10^9$ 且 $P$ 是素数。

本题共 $5$ 个测试点：

测试点 $1$ 保证 $n,q\le8$，分值为 $20$ 分；

测试点 $2$ 保证 $n,q\le200$，分值为 $15$ 分；

测试点 $3$ 保证 $n,q\le3000$，分值为 $15$ 分；

测试点 $4$ 保证 $n\le500,000,q\le100,000$，分值为 $20$ 分；

测试点 $5$ 保证 $n\le3\times10^7,q\le100,000$，分值为 $30$ 分。

## 样例 #1

### 输入

```
2 199932539
1
6```

### 输出

```
1
10```

# 题解

## 作者：dAniel_lele (赞：2)

由于不允许有长度为 $3$ 的简单路，故每个连通块必然是菊花或三元环。

考察 $3\mid n$，我们发现可以取到最大值，即全部取三元环。

考察 $3\nmid n$，此时必要需要至少一个菊花。然而一个菊花会让边数从 $n$ 减少 $1$，故只会放一个菊花。

也就是说我们最后的图是由若干三元环以及一个菊花组成。

图是有标号的，考虑将三元环在编号最大的点处计算。

考虑 $dp_{i,0/1}$ 表示放了 $i$ 个点，是否选菊花中心的方案数。

每次转移可以加入一个菊花的点/中心，或者加入某个三元环中编号最大的点。此时，另外两个点与已放置需要乘上个组合数。

总复杂度 $O(n)$。注意选择 $2$ 个点时选哪个为中心没有区别，需要减去。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
typedef unsigned long long ull;
typedef __uint128_t L;
struct FastMod {
    ull b, m;
    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}
    ull reduce(ull a) {
        ull q = (ull)((L(m) * a) >> 64);
        ull r = a - q * b; // can be proven that 0 <= r < 2*b
        return r >= b ? r - b : r;
    }
};
FastMod F(2);
int mod;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=F.reduce(ans*a);
		a=F.reduce(a*a);
		b>>=1;
	}
	return ans;
}
int f[30000005][2],fac[30000005],inv[30000005],inv2;
signed main(){
	int q; cin>>q>>mod; F=FastMod(mod);
	fac[0]=1; for(int i=1;i<=30000000;i++) fac[i]=F.reduce(fac[i-1]*i); inv2=(mod+1)/2;
	inv[30000000]=qp(fac[30000000],mod-2); for(int i=29999999;i>=0;i--) inv[i]=F.reduce(inv[i+1]*(i+1));
	f[0][0]=1;
	for(int i=0;i<=30000000;i++){
		f[i][0]=F.reduce(f[i][0]);
		f[i][1]=F.reduce(f[i][1]);
		//select a cycle
		f[i+3][0]+=f[i][0]*F.reduce((i+2)*(i+1)/2);
		f[i+3][1]+=f[i][1]*F.reduce((i+2)*(i+1)/2);
		//select a point
		f[i+1][0]+=f[i][0];
		f[i+1][1]+=f[i][0]+f[i][1];
	}
	while(q--){
		int n; cin>>n;
		if(n%3==0){
			cout<<F.reduce(F.reduce(fac[n]*inv[n/3])*qp(6,mod-1-n/3))<<"\n";
		}
		else if(n%3==1){
			cout<<f[n][1]<<"\n";
		}
		else{
			cout<<F.reduce(f[n][1]+mod-F.reduce(F.reduce(F.reduce(fac[n-2]*inv[n/3])*qp(6,mod-1-n/3))*F.reduce(n*(n-1)/2)))<<"\n";
		}
	}
	return 0;
}
```

---


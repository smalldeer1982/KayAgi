# 命运黄之瓜

## 题目背景

![字符画](https://cdn.luogu.com.cn/upload/image_hosting/xlauqkoe.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

	什么？我弹春日影？真的假的？

	小睦头曾经在一周目说错了三句话。
	为了挽回大祥老师，soyo 跨越了一次又一次的 MyGO!!!!! 世界线想要撤回那三句话带来的影响。
	众所周知，为了让世界线变动率超过一个阈值，三句话的影响需要以栈的形式撤回。

	I. “live，挺好的。”
	soyo 来到了第一个关头，此时她眼神已经变得坚毅，正欲说出“我唯独不想听到你这么说。”
	soyo 运用她的惊世智慧，在 1s 内思考并说出了：“谢谢你，小睦，让我们一起变得 kirakira⭐dokidoki 吧！”
	并把巧克力袋温柔地还给小睦头：“这个，不需要了。”随即把黄瓜全部服用。
	世界变换了它的色彩，大祥老师为吉他手的短缺而发愁，喵梦也因为艺人女儿的缺席变得犹豫。
	但 soyo 发现脑海中 anon 说过的“一瞬一瞬化作一生”已经变得模糊。

	II. “一起去看他们的 live 吧。”
	soyo 来到了第二个关头，此时她正处于红温状态，想要怒吼“为什么要弹《春日影》!”
	soyo 运用她的惊世智慧，在 1s 内思考并说出了：“小灯，想要一辈子的话我们需要一直摸兜里。”
	世界变换了它的色彩，MyGO!!!!! 提前两个月上演了名为端程山的 live，渐渐他们的名声超过了 Afterglow。
	但 soyo 发现在每场 live 之后，anon 都没有再满脸兴奋地喊到“这是大成功吧！”

	III. “我从来没有觉得玩乐队快乐过。”
	soyo 来到了最终关头，此时她正想安慰伤心的小睦头“不是小睦的错哦。”
	soyo 运用她的惊世智慧，在 1s 内思考并说出了：“小睦，你有为 Crychic 的复活赌上一切的觉悟吗？”
	世界变换了它的色彩，saki 离开后蓝发双马尾 anon 的出现唤起了众人心中美好的回忆，填补了乐队的空缺。
	但 soyo 发现再也没有人鼓起勇气对她说“soyo桑，要一起组乐队吗？”

	IV. “那我呢？”
	随着 Crychic 的不断壮大，saki 从中看到了拯救自己的商机，在 soyo 的帮助下回归并赶走了 anon。
	至此 soyo 挽回了大祥老师。但，一切尘埃落定后，soyo 想，那 anon 呢？

	为了解决这个两难局面，soyo 需要用夹子音欺骗自己，欺骗这个世界！
	为此，她需要和 anon 及 rana 一起演奏春日影，并用很大的夹子音把音乐掩盖过去。

	面对曾经发过毒誓一辈子不再弹奏的乐曲，soyo 无法干净利落地剪切掉自己的誓言。
	所以，面对这个问题，你才是挑战者。

	V. “欧内该......如果你不能运用你的惊世智慧在 1s 内解决这道题目的话......瓦达西！”


## 题目描述

你有两个数组 $a_1,a_2,\cdots,a_n$ 和 $b_1,b_2,\cdots,b_n$。

你可以选择任意整数 $1\le i \le n$，将 $a_i$ 和 $b_i$ 都变为 $0$，你可以操作任意次（可以为 $0$ 次）。

你需要求出 $\min(a_1\oplus a_2\oplus\cdots\oplus a_n,b_1\oplus b_2\oplus\cdots\oplus b_n)$ 的最大值，其中 $\oplus$ 是按位异或运算。

## 说明/提示

$1\le T\le2\times10^5$，$1\le n,\sum n\le2\times 10^5$，$0\le a_i,b_i <2^{31}$。

	你这人，满脑子都只有大家呢o(*￣︶￣*)o

## 样例 #1

### 输入

```
2
3
1 2 3
3 2 11
5
3 4 6 1 8
2 4 1 9 1```

### 输出

```
3
14```

# 题解

## 作者：NewInTown (赞：7)

出题人来啦~

~大家要好好品鉴题目背景哦~

以下是正文：

不妨假设 $a_1⊕a_2⊕\cdots⊕a_n$ 不大于 $b_1⊕b_2⊕\cdots⊕b_n$。所以我们需要最大化 $a_1⊕a_2⊕\cdots⊕a_n$。

令 $c_i=a_i\cdot(2^{31})+b_i$。对 $c$ 做线性基得到线性基 $C$。

从高向低枚举答案的第 $i$ 位，对于第 $i$ 位，先假设其为 $1$：

- 由于 $a$ 小于 $b$，所以可以确定 $a$ 的 $i$ 至 $30$ 位的值，使用线性基 $C$ 的 $i+31$ 至 $61$ 位构造 $a$。

- 将 $C$ 的 $0$ 至 $i+30$ 位取出，将这 $i+31$ 个数分别并上 $(2^{31}-1)$ 后，再做一次线性基得到线性基 $D$。

- 不难发现可以使用 $D$ 确定 $b$ 的最大值 $b_{\max}$，若 $\frac{b_{\max}}{2^{i}}<\frac{a}{2^{i}}$ 则与 $a$ 不大于 $b$ 矛盾。

不难发现若第一步构造成功并且第三步没有矛盾则表明答案的第 $i$ 位可以为 $1$，否则一定为 $0$。

枚举结束即可得到 $a$ 和 $b$，注意需要再次判断 $a$ 与 $b$ 的大小，即可得到答案。至此此题完结。

单次询问时间复杂度 $O(n\log v+\log^3v)$。

std：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
#define ll long long
const int MAXN=2e5+5;
int a[MAXN],b[MAXN],n;
void add(ll *a,ll x) {
	for(int j=61; j>=0; j--)if(x>>j&1) {
			if(!a[j]) {
				a[j]=x;
				return;
			} else x^=a[j];
		}
}
int work(int* a,int* b) {
	ll c[62]= {0},d[62]= {0};
	for(int i=1; i<=n; i++)add(c,(ll)a[i]<<31|b[i]);
	int A=0,B=0;
	for(int i=30; i>=0; i--)if(c[i+31]) {
			if(~A>>i&1) {
				A^=c[i+31]>>31;
				B^=c[i+31]&0x7fffffff;
			}
			memcpy(d,c,sizeof(ll)*31);
			for(int j=31; j<i+31; j++)add(d,c[j]&0x7fffffff);
			int nb=B;
			for(int j=30; j>=0; j--)nb=max((ll)nb,nb^d[j]);
			if((nb>>i)<(A>>i)) {
				A^=c[i+31]>>31;
				B^=c[i+31]&0x7fffffff;
			}
		}
	for(int j=30; j>=0; j--)B=max((ll)B,B^c[j]);
	return min(A,B);
}
int main() {
	int t;
	cin>>t;
	while(t--) {
		scanf("%d",&n);
		for(int i=1; i<=n; i++)scanf("%d",a+i);
		for(int i=1; i<=n; i++)scanf("%d",b+i);
		printf("%d\n",max(work(a,b),work(b,a)));
	}
	return 0;
}
```

---

## 作者：bluedream (赞：3)

题意看作给出 $n$ 个二元组 $(x_i,y_i)$，选出一个子集 $S$ 使得 $\min(\operatorname{xor}_{i\in S}x_i,\operatorname{xor}_{i\in S}y_i)$ 最大，这个形式和 [[ABC249G] Xor Cards](https://www.luogu.com.cn/problem/AT_abc249_g) 具有非常高的相似度。

直接模仿那题，将 $(x,y)$ 绑定为 $y\times 2^{31}+x$ 丢入线性基即可将二元组规模缩小到 $O(\log v)$ 且保证了所有 $y$ 非零的二元组的 $y$ 的最高位互不相同。

进行二分，判断答案是否能 $\ge k$，那么只需要求出当 $\operatorname{xor}_{i\in S} x_i\ge k$ 时 $\operatorname{xor}_{i\in S} y_i$ 的最大值，判断其是否同样 $\ge k$ 即可。

对后者从高至低贪心，此二元组后的所有二元组均可随意选且不会影响该位，于是将这个二元组后面所有二元组的 $x$ 放入线性基即可判断此二元组能否选或不选。

需要在二分外预处理每个后缀的 $x$ 值的线性基。

时间复杂度 $O\left(\sum n\log v+\log^3 v\right)$，极限数据下为 $O\left(\sum n\log^2 v\right)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
//read()
const int N=2e5+10;
int n,c,x[N],y[N];
struct LnB1{
    ll v[64];
    inline void clear(){
    	for(int i=0;i<=60;i++)
    		v[i]=0;
	}
    inline void ins(ll vt){
        for(int i=60;i>=0;i--){
            if(!(vt>>i&1)) continue;
            if(!v[i]){
                v[i]=vt;
                return ;
            }else vt^=v[i];
        }
    }
}L;
struct LnB2{
    int v[32];
    inline void clear(){
    	for(int i=0;i<=30;i++)
    		v[i]=0;
	}
    inline void ins(int vt){
        for(int i=30;i>=0;i--){
            if(!(vt>>i&1)) continue;
            if(!v[i]){ v[i]=vt;break; }
            else vt^=v[i];
        }
    }
    inline bool check(int x,int k){
    	for(int i=30;i>=0;i--)
    		x=max(x,x^v[i]);
    	return x>=k;
	}
}tp[64];
inline bool check(int k){
	pii vr=mpr(0,0);
	for(int i=1;i<=c;i++){
		int vx=vr.sec,vy=vr.fir;
		int nx=vx^x[i],ny=vy^y[i];
		pii nr(0,0);
		if(tp[i+1].check(nx,k)) nr=max(nr,mpr(ny,nx));
		if(tp[i+1].check(vx,k)) nr=max(nr,mpr(vy,vx));
		vr=nr;
	}
	return vr.fir>=k;
}
int main(){
	int T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;i++)
			x[i]=read();
		for(int i=1;i<=n;i++)
			y[i]=read();
		L.clear();
		for(int i=1;i<=n;i++)
			L.ins((y[i]*1ll<<31)+x[i]);
		c=0;
		for(int i=60;i>=0;i--)
			if(L.v[i])
				c++,x[c]=L.v[i]&((1ll<<31)-1),y[c]=L.v[i]>>31;
		for(int i=1;i<=c+1;i++)
			tp[i].clear();
		for(int i=c;i>=1;i--)
			tp[i]=tp[i+1],tp[i].ins(x[i]);
		int L=0,R=(1ll<<31)-1,ans=0;
		while(L<=R){
			int mid=0ll+L+R>>1;
			if(check(mid)) L=mid+1,ans=mid;
			else R=mid-1;
		}
		write(ans),putc('\n');
	}
	flush();
}
```

并非黄瓜。

---

## 作者：是青白呀 (赞：3)

定义 pair 之间进行异或得到的是两个元素分别异或后形成的 pair，则该问题等价于任选一些 pair 进行异或，最大化结果 pair 中较小的那一个值。

任意异或不难想到线性基。我们将 pair 的两个部分拼成一个大数 $a_i\times 2^{31}+b_i$ 并插入线性基，即可得到可以异或出所有可能 pair 的线性基。

考虑二分一个答案 $mid$，在保证 $a$ 的部分不小于该答案的前提下，最大化 $b$ 部分的值。由于线性基第 $i$ 位上的数的最高位是 $i$，于是对于 $a$ 的部分，可以考虑从大往小决策。具体地，我们使用一个类似 Trie 上二分的方式，枚举从高往低的首个位 $i$，使得 $a$ 在第 $i$ 位的值大于 $mid$ 在第 $i$ 位的值。此后 $a$ 的值不再受到 $mid$ 的限制，我们只需要考虑最大化 $b$ 的部分即可。因此我们对于每一个 $j\in[1,i-1]$ 的 $j$，都把线性基上第 $j$ 位的数与上 $2^{31}-1$ 后插入另一个线性基（只保留 $b$ 的部分），在另一个线性基中求异或最大值即可求出在该条件下，$b$ 的最大值。最终我们把每种情况下 $b$ 的最大值求 $\max$ 并与 $mid$ 判断大小，即可得知 $mid$ 是否合法。最后注意 $mid$ 恰好等于 $a$ 的情况也需要求一次 $b$。

这样做，单次询问的复杂度为 $O(n\log n+\log^4V)$，原因是每次二分，在每个位上，都要将一个前缀上的 $O(\log V)$ 个数插入另一个线性基，在带上 $T$ 的情况下无法通过。

考虑使用一个经典的贪心进行优化，发现第二个线性基中插入的元素始终只有在第一个基中的那 $O(\log V)$ 个，每次的要求形如只能使用标号在 $[1,x]$ 中的值构建异或最大值。于是我们在插入时，贪心地让标号更小的优先插入。具体地，若当前考虑到线性基的第 $i$ 位，维护当前值位 $v$，当前标号为 $nid$，若 $p_i=0$ 则直接插入；否则比较已有的值的标号 $id_i$ 和 $nid$ 的大小，若 $nid<id_i$，则交换当前插入的值与已有值，让 $p_i$ 这个标号更大的值继续去尝试插入。

此时，我们可以在 $O(\log ^2V)$ 的复杂度下预先构建出第二个线性基，每一位求 $b$ 的瓶颈变为 $O(\log V)$ 的查询。于是总复杂度来到 $O(Tn\log n+T\log^3 V)$，显然跑不满，可以通过。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define lowbit(i) (i&-i)
#define int long long
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=2e5+5,M=1e5+5,mo=1e9+7,inf=(ll)1e18+7;
const double PI=acos(-1);
void read(int &a){
    int x=0,w=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+ch-'0';
        ch=getchar();
    }
    a=x*w;
}
int n,a[N],b[N],tot;
struct Base1{
    pii p[32];
    void clear(){
        rep(i,0,30)
            p[i]=mp(0,inf);
    }
    void insert(int x,int id){
        repp(i,30,0){
            if(!((x>>i)&1))continue;
            if(p[i].sec==inf){
                p[i]=mp(x,id);
                return;
            }
            else if(p[i].sec>id){
                pii nwp=mp(x,id);
                swap(nwp,p[i]),tie(x,id)=nwp;
            }
            x^=p[i].fir;
        }
    }
    int query(int res,int targ){
        repp(i,30,0){
            if(!p[i].fir||p[i].sec>targ)continue;
            res=max(res,res^p[i].fir);
        }
        return res;
    }
}B1;
struct Base2{
    void clear(){
        rep(i,0,61)
            p[i]=0;
    }
    int p[64];
    void insert(int x){
        repp(i,61,0){
            if(!((x>>i)&1))continue;
            if(!p[i]){
                p[i]=x;
                return;
            }
            x^=p[i];
        }
    }
    void build1(){
        rep(i,0,61)
            if(p[i])B1.insert(p[i]&tot,i);
    }
    int solve(int v){
        v<<=31;
        int nwv=0,res=0;
        repp(i,61,0){
            int nv=(v>>i)&1;
            if(!p[i]){
                if(!nv&&((nwv>>i)&1)==1){
                    res=max(res,B1.query(nwv&tot,i-1));
                }
                else if(nv&&((nwv>>i)&1)==0)break;
                continue;
            }
            if(nv)nwv=max(nwv,nwv^p[i]);
            else{
                int gtv=max(nwv,nwv^p[i]);
                nwv=min(nwv,nwv^p[i]);
                res=max(res,B1.query(gtv&tot,i-1));
            }
        }
        if(nwv>=v)res=max(res,nwv&tot);
        return res;
    }
}B2;
bool check(int x){
    return B2.solve(x)>=x;
}
void solve(){
    B1.clear(),B2.clear();
    read(n);
    int le=0,ri=0,ans=0;
    int upp=0;
    rep(i,1,n)
        read(a[i]),upp=max(upp,(int)floor(log2(a[i]))+1);
    rep(i,1,n){
        read(b[i]);
        upp=max(upp,(int)floor(log2(b[i]))+1);
        le=max(min(a[i],b[i]),le);
        int v=(a[i]<<31)|b[i];
        B2.insert(v);
    }
    B2.build1();
    ri=(1<<upp)-1;
    while(le<=ri){
        int mid=(le+ri)>>1;
        if(check(mid))ans=mid,le=mid+1;
        else ri=mid-1;
    }
    printf("%lld\n",ans);
}
int T;
signed main(){
    tot=(1ll<<31)-1,read(T);
    while(T--)
        solve();
    return 0;
}
```

---

## 作者：minstdfx (赞：2)

这题真有紫吗。

挑一堆 `pair` 出来求异或，不难想到线性基。

我们考虑线性基是个什么东西。
>贪心法构造的线性基具有如下性质：
>- 线性基没有异或和为 0 的子集。  
>- 线性基中各数二进制最高位不同。
>- 从高位往低位贪心法构造的线性基的第 $k$ 位二进制位所对应的元素，或者为 $0$（即不存在，当前位不独立），或者最高位为 $2^k$。

所以考虑从高位往低位确定。先尝试将当前位 $2^j$ 钦定为 $1$。显然如果前面的位是一样的那么这一位取 $1$ 当且仅当两个都取 $1$，用 $a_i\operatorname{bitand}b_i$ 构造线性基即可判断。

如果出现两位不同怎么办？那么容易发现为 $1$ 的那一侧此后就限制不到答案了，相当于只有一侧的线性基，直接做。  
那么如何确定这一位是哪一位呢？交替压位（保证两个数的第 $i$ 位位权比 $0\sim i-1$ 大），若**当前答案加上当前的两位**与基向量组异或的最小值中不包含当前的两位，说明**在取到高位已经确定的答案时，这一位 $a$、$b$ 均能取到 $1$**，也就是答案的这一位可以取 $1$，否则尝试从这一位开始钦定哪边取 $1$ 然后两个分支做下去。

然后做完了。

没代码，因为口胡的，根本没写。

以及：

欢迎关注 kirakiradokidoki 的少女乐团企划邦多利喵，谢谢喵。

---

## 作者：Felix72 (赞：1)

（题面虽然魔怔但是不妨碍这是道挺有含金量的题）

$\min$ 值不容易维护，因此先分类讨论 $\bigoplus_{i = 1}^{n} a_i < \bigoplus_{i = 1}^{n} b_i$ 以及 $\bigoplus_{i = 1}^{n} a_i > \bigoplus_{i = 1}^{n} b_i$。下面默认做前一种情况。

我们要在 $\bigoplus b$ 有办法大于 $\bigoplus a$ 的情况下最大化 $\bigoplus a$，这通常是线性基能做的，我们把关于 $a$ 的线性基 $(fa, fb)$ 建出来，其中 $fa_i$ 代表第 $i$ 位的基，$fb_i$ 表示如果用了线性基的这一项，$b$ 会异或 $fb_i$。把不在线性基 $f$ 中的 $b$ 值再塞到线性基 $g$ 中。

重点讲一下贪心流程：（定义二元组的异或为两个元素分别异或）

- 维护一个二元组 $(cur_a, cur_b)$，和一个变量 $comp$ 。
- 从 $30$ 位枚举到 $0$ 位，设当前位是 $i$：

  - 如果这一位没有线性基，那么看看 $cur_a$ 在这一位上是否是 $1$。如果是，检测 $b$ 用 $fb_{[0, i - 1]}$ 和 $g$ 的值是否能大于等于 $comp + 2^i$，如果是，则 $comp = comp + 2 ^ i, cur = cur \oplus f$；
  - 如果这一位有线性基，那么先看我们用了这个线性基后 $cur_a$ 变大还是变小，我们检测在用和不用的情况中，$cur_a$ 相对较大的情况下，$b$ 用 $fb_{[0, i - 1]}$ 和 $g$ 的值是否能大于等于 $comp + 2^i$，如果是，$comp = comp + 2 ^ i$，并做相应的操作（用或者不用线性基）。

```cpp
/* Good Game, Well Play. */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 200010;
int T, n, res; struct Group {int a, b, id;} s[N], p[N];
Group operator ^ (Group u, Group v) {return {u.a ^ v.a, u.b ^ v.b, u.id};}
struct LB
{
	Group f[35];
	inline void reset() {for(int i = 0; i <= 34; ++i) f[i] = {0, 0, 0};}
	inline Group insert(Group cur)
	{
		for(int i = 30; i >= 0; --i)
		{
			if(!(cur.a & (1 << i))) continue;
			if(f[i].id) cur = cur ^ f[i];
			else {f[i] = cur; return {0, 0, 0};}
		}
		return cur;
	}
	inline void debug()
	{
		for(int i = 0; i <= 30; ++i)
			if(f[i].id)
				cerr << "! " << i << " " << f[i].a << " " << f[i].b << " " << f[i].id << '\n';
	}
}; LB lb, oth;
inline bool work(Group cur, int pt, long long comp)
{
	LB dp = oth;
	for(int i = pt; i >= 0; --i)
		if(lb.f[i].id)
			dp.insert({lb.f[i].b, lb.f[i].a, lb.f[i].id});
	long long res = cur.b;
	for(int i = 30; i >= 0; --i)
	{
		if(!dp.f[i].id) continue;
		if(res & (1 << i)) continue;
		res = res ^ dp.f[i].a;
	}
	return (comp <= res);
}
inline void work()
{
	lb.reset(); oth.reset();
	for(int i = 1; i <= n; ++i) p[i] = lb.insert(s[i]);
	for(int i = 1; i <= n; ++i)
	{
		swap(p[i].a, p[i].b);
		if(p[i].id) oth.insert(p[i]);
	}
	
	Group cur = {0, 0, 0}; int comp = 0;
	for(int i = 30; i >= 0; --i)
	{
		if(!lb.f[i].id)
		{
			if((cur.a & (1 << i)) && work(cur, i - 1, comp + (1 << i)))
				comp += (1 << i);
		}
		else if(cur.a & (1 << i))
		{
			if(work(cur, i - 1, comp + (1 << i))) comp += (1 << i);
			else cur = cur ^ lb.f[i];
		}
		else
		{
			if(work(cur ^ lb.f[i], i - 1, comp + (1 << i)))
				cur = cur ^ lb.f[i], comp += (1 << i);
			else;
		}
	}
	res = max(res, comp);
}
inline void sol()
{
	cin >> n; res = INT_MIN;
	for(int i = 1; i <= n; ++i) cin >> s[i].a, s[i].id = i;
	for(int i = 1; i <= n; ++i) cin >> s[i].b;
	work(); for(int i = 1; i <= n; ++i) swap(s[i].a, s[i].b); work();
	cout << res << '\n';
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> T;
	while(T--) sol();
	return 0;
}
/*

*/
```

---

## 作者：喵仔牛奶 (赞：1)

# Solution

二分答案 $k$，问题变为求一个集合 $S$，满足 $\bigoplus_{i\in S}x_i\ge k$，且 $\bigoplus_{i\in S}y_i$ 最大。

问题变为 [AT_abc249_g [ABC249G] Xor Cards](https://www.luogu.com.cn/problem/AT_abc249_g)，简述一下做法。

将 $(x_i,y_i)$ 作为 $y_i\times2^{31}+x_i$ 插入线性基，线性基里的 $\mathcal{O}(\log V)$ 个数可以表示出原序列任意的数，只保留这些数答案不变。将这些数还原回 $(x_i,y_i)$，得到了新的序列。于是我们花费了 $\mathcal{O}(n\log V)$ 的时间，将 $n$ 缩小到了 $\mathcal{O}(\log V)$。

首先，如果 $x_i$ 的最大异或和 $<k$，那么无解。

可以发现，$y_i$ 最高位互不相同。将 $(x_i,y_i)$ 按 $y_i$ 从大到小排序，每次贪心判断能否取。具体地，维护当前 $x_i,y_i$ 的异或和 $sm,rs$，处理出 $[i+1,n]$ 的线性基 $B$：
- $sm$ 在 $B$ 中异或最终不可以 $\ge k$，那么取；
- 如果 $rs\oplus y_i>rs$ 且 $sm\oplus x_i$ 在 $B$ 中异或最终可以 $\ge k$，那么取；
- 否则不取。

在二分外处理出 $\mathcal O(\log V)$ 个有用的数、处理出后缀线性基。复杂度 $\mathcal O(n\log V+\log^3V)$。

# Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5, P = 62;
	struct LBase {
		LL b[P + 1]; LBase() { clear(); } void clear() { mems(b, 0); }
		int ins(LL x) { DEP(i, P, 0) if (x >> i & 1) if (b[i]) x ^= b[i]; else return b[i] = x, i; return 0; }
		LL ask(LL x) { DEP(i, P, 0) x = max(x, x ^ b[i]); return x; }
	} C, B[P + 5];
	LL n, m, x, a[N], b[N];
	vector<pii> s;
	bool chk(LL k) {
		if (B[0].ask(0) < k) return 0;
		LL rs = 0, sm = 0;
		REP(i, 0, m) {
			auto [x, y] = s[i];
			int c1 = (B[i + 1].ask(sm ^ y) >= k), c2 = (B[i + 1].ask(sm) >= k);
			if ((c1 && (rs ^ x) > rs) || !c2) rs ^= x, sm ^= y;
		}
		return (rs >= k);
	}
	int main() {
		cin >> n, s.clear(), C.clear();
		REP(i, 1, n) cin >> a[i];
		REP(i, 1, n) cin >> b[i];
		REP(i, 1, n) C.ins(b[i] << 31 | a[i]);
		REP(i, 0, P) {
			LL x = C.b[i];
			if (x > 0) s.pb(x >> 31, x & ((1 << 31) - 1));
		}
		sort(ALL(s), greater<pii>()), m = SZ(s) - 1;
		DEP(i, m, 0) B[i] = B[i + 1], B[i].ins(s[i].se);
		LL l = 0, r = 3e9;
		while (l <= r) {
			LL m = (l + r) >> 1;
			if (chk(m)) l = m + 1;
			else r = m - 1;
		}
		cout << r << '\n';
		REP(i, 0, m) B[i].clear();
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1; cin >> T;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：eastcloud (赞：1)

首先对于这个 $\min$，我们考虑经典的二分拆位，从高到低依次判定强制高位某些位取 1 后这一位能不能取 1。

这步的判定实际上就是考虑只保留这若干位时，已有的数能不能异或出你现在想要的数，由于我们要取 $\min$，因此两边必须得都是 1，可以压位上线性基直接维护，时间复杂度 $O(n \log^2 n)$。

但是其实这个做法有点问题，原因在于如果某一位不能填上 1，那么最终答案可能会出现这一位 $a$ 或 $b$ 的最终异或值是 1，故我们不用考虑剩下的低位，只需递归到一侧，但是我们的做法实际上强制钦定了这一位两边的最终异或值是 0。

不过这个问题是好解决的，我们可以直接钦定某一边这一位填 1，然后问题就变成只有另一边剩下的数有用了，仿照上面的判定直接做掉，这部分的复杂度也是 $O(n \log^2 n)$ 的。

做法常数较大，需要一些常数优化，包括但不限于对小数据暴力，插入线性基时每次找出最高位而非一位一位枚举插入。

---


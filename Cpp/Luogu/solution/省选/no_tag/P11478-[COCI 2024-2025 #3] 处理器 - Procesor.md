# [COCI 2024/2025 #3] 处理器 / Procesor

## 题目背景


译自 [COCI 2024/2025 #3](https://hsin.hr/coci/) T5。$\texttt{1s,0.5G}$。满分为 $120$。

为了方便测试，公开[交互库](https://www.luogu.com.cn/paste/1gl6aook)。

## 题目描述


**这是一道交互题**。

有一个初始时为空的数组 $a$。

$n$ 次操作，第 $i$ 次操作向 $a$ 的末尾添加 $x_i$ 个整数。

每次操作后，通过若干次询问，你需要找到最小的**未被标记**的整数对应的下标 $x$，并给 $a_x$ 打标记。

每次询问，你可以询问两个**未被标记**的整数 $a_i,a_j$ 的大小关系。

设当前数组长度为 $l$，保证 $\forall 1\le i\lt j\le l$，$a_i\lt a_j$ 和 $a_j\lt a_i$ **恰有一个成立**。换句话说，**保证数组内元素两两不同**。

### 实现细节

首先读入一个正整数 $n$。接下来依次处理 $n$ 次操作。

对于第 $i$ 次操作，读入一个正整数 $x_i$，表示增加的整数数量。

接下来你可以按照以下格式询问若干次：

- $\texttt{?}$ $i$ $j$：询问 $a_i,a_j$ 的大小关系。
    - 返回 $0$，表示 $a_i\lt a_j$；返回 $1$，表示 $a_i\gt a_j$。
    - 令当前数组长度为 $l$，你需要保证 $1\le i,j\le l$。
    - 你需要保证 $i\neq j$，且 $a_i,a_j$ 未被标记。


按以下格式回答：

- $\texttt{!}$ $x$：当前数组内未被标记的最小整数为 $a_x$。

**回答后立刻读入下一个整数 $x_{i+1}$，若这是最后一次操作则立刻结束程序。**

**在每次询问或者回答后，都要换行并刷新缓冲区。** 刷新缓冲区的方式：C++ 中的 `std::cout.flush()`，`std::cout<<std::endl`。

## 说明/提示


### 样例解释

样例 $1$ 中，$a=[3,2,4,1,5]$。

- 查询 $a_1$ 与 $a_2$：$a_1\gt a_2$，返回 $1$；
- 查询 $a_1$ 与 $a_3$：$a_1\lt a_3$，返回 $0$；
- 查询 $a_2$ 与 $a_3$：$a_2\lt a_3$，返回 $0$。

不难发现 $a_2$ 为当前未标记的最小值，所以回答 $2$。接下来继续处理剩余的两次操作。

### 数据范围


对于 $100\%$ 的数据，保证：

- $1\le n\le 40$；
- $1\le x_i,\sum x_i\le 2\, 000$。
- 数组内整数两两不同。

### 计分方式

令你的程序询问次数的最大值为 $q$。

- $q\le 2\, 700$，得 $120$ 分。
- $2\, 700 \lt q\le 7\, 000$，得 $75$ 分。
- $7\, 000 \lt q\le 2\times 10^4$，得 $35$ 分。
- $2\times 10^4 \lt q\le 8\times 10^4$，得 $15$ 分。
- $8\times 10^4\lt q$，得 $0$ 分。

## 样例 #1

### 输入

```
3

3

1

0

0

1

1

1

0```

### 输出

```

? 1 2

? 1 3

? 2 3

! 2

? 1 4

! 4

? 1 5

! 1```

# 题解

## 作者：未来姚班zyl (赞：4)

我们可以用 $n-1$ 次操作得出 $n$ 个数当中的最小值，使用任意一种打擂台的方式即可。

然而这题还要求出类似次小值、第三小值等等，所以我们需要保留比较过程中的信息。

大小关系常常用图论描述，如果 $a_i$ 大于 $a_j$，我们就连边 $i\rightarrow j$，在一次打擂台之后，我们将连出一颗外向树，即边都指向自己的儿子。

先不管打擂台的顺序和方式是怎样的，我们先整理本题的思路：

- 加入一段数后，先打擂台求出这一段的最小值。
- 与之前剩下的数中可能的最小值放在一起再打一次擂台，求出当前答案 $ans$。
- 把 $ans$ 删除，将 $ans$ 的儿子设为可能的最小值。

设 $m=\sum x_i$，我们分析这个思路的操作次数：

第一步是 $O(m)$ 次操作。

第三步带来的候选点的总数是 $O(m)$ 的，第二步中打 $n$ 次擂台，操作数是 $O(nm)$ 的。

打擂台的过程无法优化，我们只能尝试减少第三步带来的候选点数。在树上这体现为 $deg_{ans}$。

我们采用类似线段树的结构进行打擂台，求出左区间和右区间的最小值，再将它们放一起打擂台。

这样每个点只会进行 $O(\log m)$ 次比较，其度数就为 $O(\log m)$，总操作次数变为 $O(m+n\log m)$ 轻松通过此题。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid ((l+r)>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define repn(x) rep(x,1,n)
#define pb push_back
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
using namespace std;
const int N=3e5+5;
int n,a[N],pr[N];
inline int cmp(int a,int b){
	cout <<"? "<<a<<' '<<b<<endl;
	return read();
}
int deg[N];
map<int,int>Nw;
vector<int>p[N];
inline int solve(int l,int r){
	if(l==r)return l;
	int a=solve(l,mid),b=solve(mid+1,r);
	if(cmp(a,b))return p[b].pb(a),b;
	return p[a].pb(b),a;
}
int st[N],tp;
inline int Sol(int l,int r){
	if(l==r)return st[l];
	int a=Sol(l,mid),b=Sol(mid+1,r);
	if(cmp(a,b))return p[b].pb(a),b;
	return p[a].pb(b),a;
}
inline void Solve(){
	tp=0;
	for(auto x:Nw)st[++tp]=x.first;
	int now=Sol(1,tp);
	Nw.clear();
	for(auto y:p[now])Nw[y]=1;
	cout <<"! "<<now<<endl;
}
inline void Main(){
	n=read();
	repn(i){
		a[i]=read(),pr[i]=pr[i-1]+a[i];
		int l=pr[i-1]+1,r=pr[i];
		Nw[solve(l,r)]=1;
		Solve();
	}
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}
```

---

## 作者：Purslane (赞：4)

# Solution

似乎被“线段树”的神秘 tag 透了做法（但是，和线段树，没啥关系啊？）

考虑二进制分组。即假设当前有 $n$ 个人，$n=\sum_{i=1}^t 2^{k_i}$，其中 $k_i$ 是互不相同的整数。

将人分按照 $2^{k_1}$，$2^{k_2}$，$\cdots$，$2^{k_t}$ 进行分组。在每一组里，维护一个“完全二叉树”的结构（即一般的淘汰赛每一轮的结果）

这样我们只需要 $O(\log k)$ 次询问就可以查询擂主。

找到擂主后，可以将他删去，原有的大小为 $2^s$ 的擂台赛会被拆分成 $s$ 个小的擂台赛。容易知道，插入他们的复杂度实际上也是 $O(\log k)$。

而往集合里面插入 $x$ 个人的复杂度为 $O(\sum_{i=1}^{+ \infty} \lfloor \dfrac{x}{2^i} \rfloor) = O(x)$，因此总的复杂度是 $O(k + n \log k)$，足以通过本题（$2400$ 次询问）

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10;
int n,rnk,tot,fid[MAXN],lson[MAXN],rson[MAXN],rt[MAXN];
int compare(int id1,int id2) {
	cout<<"? "<<id1<<' '<<id2<<endl,cout.flush();
	int op;cin>>op;
	return op;
}
void insert(int u,int st) {
	ffor(i,st,12) {
		if(!rt[i]) return rt[i]=u,void();
		++tot,lson[tot]=u,rson[tot]=rt[i],fid[tot]=(compare(fid[u],fid[rt[i]])?fid[rt[i]]:fid[u]);
		u=tot,rt[i]=0;
	}
	return ;
}
int id,bel;
void get_max(void) {
	id=-1,bel=-1;
	ffor(i,0,12) if(rt[i]) {
		if(id==-1) id=fid[rt[i]],bel=i;
		else if(compare(id,fid[rt[i]])) id=fid[rt[i]],bel=i;
	}
	cout<<"! "<<id<<endl,cout.flush();
	return ;
}
int main() {
	cin>>n;
	ffor(i,1,n) {
		int x;
		cin>>x;
		if(i!=1) {
			vector<pair<int,int>> vc;
			int u=rt[bel],sze=bel;
			rt[bel]=0;
			while(1) {
				sze--;
				if(!lson[u]) break ;
				if(fid[lson[u]]==id) vc.push_back({rson[u],sze}),u=lson[u];
				else vc.push_back({lson[u],sze}),u=rson[u];
			}
			for(auto pr:vc) insert(pr.first,pr.second);
		}
		ffor(j,1,x) ++rnk,++tot,fid[tot]=rnk,insert(tot,0);
		get_max();
	}
	return 0;
}
```

---

## 作者：wangyizhi (赞：3)

[**题目传送门**](https://www.luogu.com.cn/problem/P11478)

简单题。

~~评紫是不是有点高了？~~

## 题目大意

~~一开始没读懂题。~~

给定一个数组 $a$，初始为空。每次加入 $x$ 个数，求此时的最小值，并将其修改为 $\infty$ （打标记）。

你可以通过输出 `? x y` 来查询 $a_x$ 与 $a_y$ 之间的大小关系。

~~现在应该看懂了，剩下的细节回去看题吧。~~

## 题目分析

先考虑如何打标记。

我们只需要进行单点修改就可以了。

再考虑如何合理利用原来的信息。

显然我们需要类似通过分块等方式来减少多余的询问。

于是我们需要一种数据结构支持单点修改、区间合并。

显然线段树满足我们的需要。

我们只需要对 `push_up` 进行一些小小的修改就行了：如果一边有标记，返回另一边；否则进行一次询问，保留较小的一遍。

记 $n$ 为数组总长度，$m$ 为操作次数。总询问次数即为 $O(n+m\log n)$。

于是这题就做完了。

## AC Code

```cpp
// by wangyizhi(571247)
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
using ll=long long;
using ld=long double;
//#define int ll
using pii=pair<int,int>;
//bool Mst;
const int N=2e3+5;
inline int qry(int x,int y)
{
	cout<<"? "<<x<<" "<<y<<"\n";
	bool t;
	cin>>t;
	return t;
}
inline int merge(int x,int y)
{
	if(!x||!y) return x|y;
	else if(qry(x,y)) return y;
	else return x;
}
int t[N<<2];
inline int ls(int id){return id<<1;}
inline int rs(int id){return id<<1|1;}
inline void push_up(int id){t[id]=merge(t[ls(id)],t[rs(id)]);}
void update(int l,int r,int id,int nl,int nr)
{
	if(nl==nr) return t[id]=nl,void();
	int m=(nl+nr)>>1;
	if(l<=m) update(l,r,ls(id),nl,m);
	if(r>m) update(l,r,rs(id),m+1,nr);
	push_up(id);
}
void modify(int s,int id,int nl,int nr)
{
	if(nl==nr) return t[id]=0,void();
	int m=(nl+nr)>>1;
	if(s<=m) modify(s,ls(id),nl,m);
	else modify(s,rs(id),m+1,nr);
	push_up(id);
}
//bool Med;
signed main()
{
//	cerr<<"Memory Size: "<<abs((&Med)-(&Mst))/1024.0/1024<<" MB\n";
//	ios::sync_with_stdio(0);
//	cin.tie(0),cout.tie(0);
	int n,lst=0,x,l=0;
	cin>>n;
	while(n--)
	{
		cin>>x;
		if(lst) modify(lst,1,1,2000);
		update(l+1,l+x,1,1,2000);
		cout<<"! "<<(lst=t[1])<<endl;
		l+=x;
	}
	return 0;
}
```

---

## 作者：RDFZchenyy (赞：2)

提供一种基于线段树的思考方式。

查询区间最小值提示我们要使用类线段树算法。

我们考虑直接扔上一个长度为 $2000$ 的数组 $a$ 产生的线段树，其中底层希望记录 $a_i=i$，其余节点存储对应区间内最小的下标。

那么修改操作就是选择一个区间，令 $a_i=i$，我们递归暴力修改向上合并。

询问输出根节点就行。

询问后的删除，我们考虑直接单点改为 $0$，然后往上暴力合并。

所以你需要做的就是打一棵线段树，然后把 `update(id)` 偷梁换柱变成交互就行了。

询问次数在 $O(l+n\log l)$，可以通过本题。

```cpp
#include<bits/stdc++.h>

#define MAXN 2005

int cmp(int x,int y){ // 也就是 update
    if((!x)||(!y)) return (x+y);
    std::cout<<'?'<<' '<<x<<' '<<y<<'\n'; fflush(stdout);
    int res; std::cin>>res;
    return res?y:x;
}

int n;
int t[MAXN<<2];
int s,x;

const int len=2000;

void build(int id,int l,int r,int tl,int tr){
    if(l==r) t[id]=l;
    else{
        int mid=(l+r)>>1;
        if(!(tl>mid)) build((id<<1),l,mid,tl,tr);
        if(!(tr<=mid)) build((id<<1)|1,mid+1,r,tl,tr);
        t[id]=cmp(t[id<<1],t[(id<<1)|1]);
    }
    return;
}
void rem(int id,int l,int r,int pos){
    if(l==r) t[id]=0;
    else{
        int mid=(l+r)>>1;
        if(pos<=mid) rem((id<<1),l,mid,pos);
        else rem((id<<1)|1,mid+1,r,pos);
        t[id]=cmp(t[id<<1],t[(id<<1)|1]);
    }
    return;
}

int main(){
    std::ios::sync_with_stdio(false);
    
    std::cin>>n;
    for(int i=1;i<=n;i++){
        std::cin>>x;
        build(1,1,len,s+1,s+x); s+=x;
        int ans=t[1];
        rem(1,1,len,t[1]);
        std::cout<<'!'<<' '<<ans<<'\n';
    }
    
    return 0;
}
```

---

## 作者：Kingna (赞：1)

我们维护一种外向树关系，小的数向大的数连边。对于每新加的 $x_i$ 个数建一颗线段树。建树的时候处理出大小关系：左右子树中小的连向左右子树中大的。如下图：（图中为了方便是数字连数字，实际写的时候要下标连下标）

![](https://cdn.luogu.com.cn/upload/image_hosting/a7za2wxt.png)

然后，我们将 $1$ 数字删去，此时线段树优势在于，删去数字 $1$ 只需要删去其指向的边。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5kvdy2s9.png)

然后变成许多森林，需要将这些森林合并，具体的，我们对 $[3,2,5]$ 序列再建一颗线段树。那么 $2\to 3$，$3\to 5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/hyt0tk3y.png)

这样就完成了：删去最小值后，重新将线段树合并，且当前的根节点就是次小值。具体操作时，将根节点的所有儿子们再来一遍线段树即可。

因为这道题每次不断加入新的 $x$ 个数，我们先将这 $x$ 个数构成一棵树，在将其作为根节点的儿子们之一去跑线段树。

总的操作次数为 $O(l+n\log l)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 4e5 + 5;

int n, sum, stk[N], top;
vector<int> G[N];
map<int, int> vis;

int cmp(int a, int b) {
  cout << "?" << ' ' << a << ' ' << b << endl;
  int x;
  cin >> x;
  return x;
}

int solve(int l, int r) {
  if (l == r) return l;
  int mid = (l + r) >> 1;
  int a = solve(l, mid), b = solve(mid + 1, r);
  if (cmp(a, b)) {
    G[b].push_back(a);
    return b;
  }
  else {
    G[a].push_back(b);
    return a;
  }
}

int solve2(int l, int r) {
  if (l == r) return stk[l];
  int mid = (l + r) >> 1;
  int a = solve2(l, mid), b = solve2(mid + 1, r);
  if (cmp(a, b)) {
    G[b].push_back(a);
    return b;
  }
  else {
    G[a].push_back(b);
    return a;
  }
}

signed main() {
  cin >> n;
  _for(i, 1, n) {
    int x;
    cin >> x;
    sum = sum + x;
    vis[solve(sum - x + 1, sum)] = 1;
    top = 0;
    for (auto v : vis) stk[++top] = v.first;
    int t = solve2(1, top);
    vis.clear();
    for (auto v : G[t]) vis[v] = 1;
    cout << "!" << ' ' << t << endl;
  }
}
```

---

## 作者：OIer_ljb (赞：1)

记 $m=\sum x_i$。

初见一眼会了一个 $m\log 40$ 的做法，然后就输了。

观察到 $n$ 很小， $m$ 比较大，而每次询问相当于单点修改，又想到线段树建树复杂度 $O(m)$，于是就会了。

考虑每次把新加入的点 `bt` 一下，`pushup` 换成交互，然后把线段树中的最小值的那个位置拿出来删一下就好了。

询问次数 $m+n\log m$，不精细实现也能过。

### code

```C++
#include<bits/stdc++.h>
using namespace std;
#define usefile(p) freopen(#p".in","r",stdin),freopen(#p".out","w",stdout);
#define fo(i,a,b) for(int i=(a);i<=(b);++i)
#define fu(i,a,b) for(int i=(a);i<(b);++i)
#define fd(i,a,b) for(int i=(a);i>=(b);--i)
#define mk make_pair
#define ll long long
#define eb emplace_back
#define pii pair<int,int>
const int N=2005;
int n,a[N],m,cnt,ed;
#define ls o<<1
#define rs o<<1|1
#define mid (l+r>>1)
struct nd{int bj,id;};
nd t[N<<2];
void bt(int o,int l,int r)
{
	if(t[o].bj||l>cnt)return;
	if(l==r){t[o].id=l;t[o].bj=1;return ;}
	bt(ls,l,mid);bt(rs,mid+1,r);
	if(t[ls].bj&&t[rs].bj)t[o].bj=1;
	if(t[ls].id&&t[rs].id)
	{
		printf("? %d %d",t[ls].id,t[rs].id);
		cout<<endl;
		int res;scanf("%d",&res);
		if(!res)t[o].id=t[ls].id;
		else t[o].id=t[rs].id;
	}
	else t[o].id=t[ls].id|t[rs].id;
}
void modify(int o,int l,int r,int x)
{
	if(l==r){t[o].id=0;return ;}
	if(x<=mid)modify(ls,l,mid,x);
	else modify(rs,mid+1,r,x);
	if(t[ls].id&&t[rs].id)
	{
		printf("? %d %d",t[ls].id,t[rs].id);
		cout<<endl;
		int res;scanf("%d",&res);
		if(!res)t[o].id=t[ls].id;
		else t[o].id=t[rs].id;
	}
	else t[o].id=t[ls].id|t[rs].id;
}
int main()
{
	scanf("%d",&n);
	fo(i,1,n)
	{
		scanf("%d",&m);cnt+=m;
		bt(1,1,2000);ed=cnt;
		int ans=t[1].id;
		if(i!=n)modify(1,1,2000,t[1].id);
		printf("! %d",ans);cout<<endl;
	}
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：0)

全局平衡二叉树板子题。

考虑我们的询问在做什么：我们把每次问的两个点连边，它们构成了一个树（显然构成 DAG 就浪费了询问）

我们的操作是每次删除一条到根的链，并维护这棵树。

但是询问强制在线，我们每次先建出来线段树，删链的时候按子树大小作为权值合并即可。

不妨令 $m=\sum x_i$，我们显然只需询问 $m - 1+O(n\log m)$ 次，这足以通过本题。

---

## 作者：PosVII (赞：0)

## 前言

谢邀 @[Starrykiller](https://www.luogu.com.cn/user/235125)

线段树套线段树做法。被交互格式卡了十年后侥幸手刹。

## 做法

对于这类询问/查询的交互题，一般都考虑分块/带 log 做法。

对于这道题，考虑到直接上线段树有可能会被卡满 $n \log n$ 次修改。但是我们已知线段树的建树是线性的，考虑牺牲一些下界换取上界。

既然每次在原有的线段树上修改会死，那么我们考虑对于每次修改单独建一颗线段树就好了。然后对于这共 $40$ 次的修改，对它们一起再开一个线段树维护就好了。

每次取出最小值后在线段树上单点修改即可，复杂度可以接受。

于是我们把上下界同时取到了 $2000 + 40 \log 2000 + 40 \log 40$，可以轻松通过。

---


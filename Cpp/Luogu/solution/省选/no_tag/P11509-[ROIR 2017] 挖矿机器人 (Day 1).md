# [ROIR 2017] 挖矿机器人 (Day 1)

## 题目背景

翻译自 [ROIR 2017 D1T4](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day1.pdf)。

## 题目描述

有一个关于开发邻近星系行星的项目。为了开采矿产资源，计划将几批机器人送往该行星。

该行星的开采区域是一个大小为 $ w \times h $ 的矩形网格区域，区域内的单元格坐标范围从 $(1, 1)$ 到 $(w, h)$。在某些单元格中设有基地，可以将机器人按批次运送到那里。整个区域共设有 $ s $ 个基地，第 $ i $ 个基地位于坐标 $(x_i, y_i)$ 处。

每批机器人有三个重要参数：第 $ j $ 批机器人将送往基地 $ b_j $，包含 $ n_j $ 个机器人，并且每个机器人具有移动能力 $ m_j $。

当机器人批次送到相应基地后，每个机器人都会从基地出发，沿着行星表面移动到某个单元格。如果一个机器人的移动能力为 $ m $，它最多可以进行 $ m $ 次移动，并且每次可以选择八个相邻的方向进行移动，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/auhkmcwj.png)

当所有送到的机器人都停止移动后，它们会被激活并开始开采其所在单元格的矿产。在机器人的移动过程中，多个机器人可以同时处于同一个单元格，但是在激活之后，每个单元格内最多只能容纳 $ q $ 个机器人。

项目团队得到了 $ t $ 批机器人的信息，这些机器人可以按顺序送往行星。然而，考虑到它们的移动限制，如果将所有机器人全部送上去，可能最终无法满足每个单元格最多只有 $ q $ 个机器人的要求。因此，项目团队需要选择前 $ k $ 批机器人（$ 0 \leq k \leq t $），将它们完全送到相应的基地。如果 $ k < t $，则还可以从第 $ k+1 $ 批机器人中额外选择 $ z $ 个机器人（$ 0 \leq z < n_{k+1} $）。团队需要求出 $ k $ 的最大值，并在这个前提下最大化 $ z $（若 $k=t$，则 $z=0$）。

## 说明/提示

### 样例解释

在样例中，输入了以下信息：

- 区域的大小是 $ 4 \times 3 $，有两个基地，且每个单元格最多容纳 $1$ 个机器人。
- 第一个基地位于坐标 $ (1, 1) $，第二个基地位于坐标 $ (3, 2) $。
- 总共有 $3$ 批机器人要送往该地区。
  - 第 $1$ 批机器人送往第 $1$ 个基地，包含 $4$ 个机器人，每个机器人的最大移动能力为 $1$。
  - 第 $2$ 批机器人送往第 $2$ 个基地，包含 $9$ 个机器人，每个机器人的最大移动能力为 $1$。
  - 第 $3$ 批机器人送往第 $1$ 个基地，包含 $12$ 个机器人，每个机器人的最大移动能力为 $2$。

经过合理安排，可以让第一批机器人完全送达，并额外选择第二批中的 $7$ 个机器人。最终，第一批和第二批的机器人能够成功安置在网格区域内，使得每个单元格内最多有 $1$ 个机器人：

![](https://cdn.luogu.com.cn/upload/image_hosting/pkgodnzw.png)

因此，答案是 $ k = 1 , z = 7$。

### 数据范围

| 子任务 | 分值 | $1\le w,h\le$ | $1\le s\le$ | $1\le q\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $18$ | $20$ | $1$ | $1$ |
| $2$ | $12$ | $20$ | $2$ | $1$ |
| $3$ | $9$ | $20$ | $3$ | $1$ |
| $4$ | $10$ | $20$ | $3$ | $100$ |
| $5$ | $15$ | $10^5$ | $1$ | $100$ |
| $6$ | $36$ | $10^5$ | $4$ | $100$ |

## 样例 #1

### 输入

```
4 3 2 1
1 1
3 2
3
1 4 1
2 9 1
1 12 2```

### 输出

```
1 7```

# 题解

## 作者：Assembly_line (赞：2)

等了一周还没等到题解/qd。

做法来自[官方题解](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-solutions.pdf)。~~俄语翻译真的难以理解。~~

首先二分答案，判断前 $k$ 个批次能否全部满足要求。

将问题转为二分图匹配，左部点为每个机器人，右部点为每个位置（每个格子对应着 $q$ 个右部点），若机器人可以走到对应点则连边。

直接建出二分图显然会爆炸，考虑使用 [hall 定理](https://oi.wiki/graph/graph-matching/graph-match/#%E9%9C%8D%E5%B0%94%E5%AE%9A%E7%90%86) 进行判定。

根据 hall 定理，要对每一个子集进行判定，这样显然不可接受。考虑子集中存在移动能力为 $d$ 的一个机器人，那么移动能力 $\le d$ 的机器人都一定要被选进来，因为此时邻域大小 $|N(S)|$ 不变，而 $|S|$ 的大小增加，因此得到了一个更紧的限制。

于是将每个基地的机器人按照移动能力进行排序，枚举每个基地移动能力的最大值 $c_i$，统计每个基地移动能力 $\le c_i$ 的机器人个数总和 $s$，同时统计每个基地所对应的矩形的并的面积 $S$，若 $s\le S$ 则这个子集满足要求。

统计矩形面积并可以用容斥做到 $O(2^s)$。不完整批次的机器人个数可以用第 $k$ 批的机器人数量减去 $\max(s-S)$ 得到。

时间 $O\big(\big(\dfrac{2t}{s}\big)^s\log n\big)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int w,h,s,q;
int ax[5],ay[5];
int n;
int b[103],d[103];
ll a[103];
//b:foundation
//a:number of bots
//d:distance
ll f[5];
int cnt[5],g[5];
struct node{
	ll x;int dis;
}p[5][103];
bool cmp(node x,node y){return x.dis<y.dis;}
struct rec{
	int ax,ay,bx,by;
}c[5],I;
rec merge(rec x,rec y)
{
	if(x.ax==-1||y.ax==-1)return I;
	if(x.ax==0)return y;
	if(y.ax==0)return x;
	rec c;
	c.ax=max(x.ax,y.ax);
	c.bx=min(x.bx,y.bx);
	c.ay=max(x.ay,y.ay);
	c.by=min(x.by,y.by);
	if(c.ax>c.bx||c.ay>c.by)c.ax=-1;
	return c;
}
ll sqm(rec x)
{
	if(x.ax<=0)return 0;
	return 1ll*(x.bx-x.ax+1)*(x.by-x.ay+1);
}
ll sq;
void calc(int x,int now,rec w)
{
	if(x>s)
	{
		if(now%2==0)sq-=sqm(w);
		else sq+=sqm(w);
		return;
	}
	calc(x+1,now,w);
	calc(x+1,now+1,merge(w,c[x]));
}
int flag;
ll res;
void dfs(int x)
{
	if(x>s)
	{
		for(int i=1;i<=s;i++)
		{
			if(g[i]==-1)c[i]=I;
			else
			{
				c[i].ax=max(1,ax[i]-g[i]);
				c[i].bx=min(w,ax[i]+g[i]);
				c[i].ay=max(1,ay[i]-g[i]);
				c[i].by=min(h,ay[i]+g[i]);
			}
		}
		sq=0;calc(1,0,(rec){0,0,0,0});
		ll ss=0;
		for(int i=1;i<=s;i++)ss+=f[i];
		if(sq*q<ss)flag=0,res=max(res,ss-sq*q);
		return;
	}
	f[x]=0;
	for(int i=0;i<=cnt[x];i++)
	{
		g[x]=p[x][i].dis;
		dfs(x+1);
		f[x]+=p[x][i+1].x;
	}
}
bool check(int x)
{
	flag=1;res=0;
	for(int i=1;i<=s;i++)cnt[i]=0,p[i][0].dis=-1;
	for(int i=1;i<=x;i++)
	{
		++cnt[b[i]];
		p[b[i]][cnt[b[i]]]=(node){a[i],d[i]};
	}
	for(int i=1;i<=s;i++)sort(p[i]+1,p[i]+cnt[i]+1,cmp);
	dfs(1);
	return flag;
}
int main()
{
	scanf("%d %d %d %d",&w,&h,&s,&q);
	for(int i=1;i<=s;i++)scanf("%d %d",&ax[i],&ay[i]);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d %lld %d",&b[i],&a[i],&d[i]);
	I.ax=-1;int ans=0;
	int l=1,r=n;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))ans=mid,l=mid+1;
		else r=mid-1;
	}
	check(ans+1);
	printf("%d %lld\n",ans,a[ans+1]-res);
	return 0;
}
```

---


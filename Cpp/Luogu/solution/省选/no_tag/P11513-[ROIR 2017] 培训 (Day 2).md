# [ROIR 2017] 培训 (Day 2)

## 题目背景

翻译自 [ROIR 2017 D2T4](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day2.pdf)。

## 题目描述

某公司共有 $n$ 名员工，每个员工都有一个唯一的编号，编号从 $1$ 到 $n$。编号为 $1$ 的员工是公司总经理，除了总经理之外，每个员工都有一个直接上级，员工 $i$ 的直接上级编号为 $p_i$，且有 $p_i < i$。

若 $p_x = y$，则员工 $x$ 被称为员工 $y$ 的第 $1$ 层下属；若员工 $p_x$ 是员工 $y$ 的第 $k-1$ 层下属，则员工 $x$ 被称为员工 $y$ 的第 $k$ 层下属。

现在，公司总经理可以选择一些员工参加培训。他决定选择两个数字 $L$ 和 $R$，将所有编号满足 $L \leq i \leq R$ 的员工送去培训。

在确定 $L$ 和 $R$ 之前，总经理收到了 $m$ 条员工的要求，第 $j$ 条要求用两个数字 $u_j$ 和 $k_j$ 表示，这代表员工 $u_j$ 希望其第 $k_j$ 层下属中**至少有一个**被送去培训。为了节省费用，总经理希望确定 $L$ 和 $R$ 的值使得送去培训的员工人数最少，并且所有员工的要求都能满足。

需要编写程序，根据公司内部的上下级关系和员工的要求，找出一对 $L$ 和 $R$，使得所有要求都能得到满足，并且送去培训的员工人数最少。如果有多个满足条件的 $(L, R)$ 对，选择其中 $L$ 最小的那个。

## 说明/提示

### 样例解释

员工编号为 $3,4,5,6$ 的员工将被送去培训。这满足所有要求，因为员工 $3$ 是员工 $1$ 的第 $1$ 层下属，员工 $4$ 是员工 $1$ 的第 $2$ 层下属，员工 $6$ 是员工 $3$ 的第 $1$ 层下属。

### 数据范围

| 子任务 | 分值 | $2\le n\le$ | $1\le m\le$ | 其它特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $19$ | $50$ | $50$ |  |
| $2$ | $25$ | $3000$ | $3000$ |  |
| $3$ | $21$ | $200000$ | $200000$ | $p_i=i-1$ |
| $4$ | $35$ | $200000$ | $200000$ |  |

## 样例 #1

### 输入

```
7
1 1 2 2 3 3
3
1 1
3 1
1 2```

### 输出

```
3 6```

# 题解

## 作者：Reply_ (赞：2)

## 题解：P11513 \[ROIR 2017] 培训 (Day 2)

类似于[折跃点](https://www.luogu.com.cn/article/spuzj0v5)的，每个限制要求的点都在某棵子树的某一层，但这题更加简单。

### 65pts 做法

想找到所有限制的所有点，考虑到直接找不好找，我们 dfs 一遍记录所有点的 dfn 序以及所有子树的大小，每一层开一个 vector 记录这一层的点的 dfn 序。

我们想找到在某一层中找到**属于某棵子树**的点，利用 dfn 序就可以简单判断：对于子树 $u$，其子树的 dfn 序必定是连续的，且为 $dfn_u\sim dfn_u+siz_u-1$，那么**当且仅当**某一层的点的 dfn 序属于这个范围中时，该点便是在该层的属于子树 $u$ 的节点。

统计答案时，观察到当 $L$ 固定时，$R$ 越大越能满足要求。因此采用双指针统计答案区间即可。

具体讲，在 dfs 的时候，记录点的 dfn 序和深度，以及每个 dfn 序对应的点的编号，再在每个深度开一个 vector 记录这一层所有点的 dfn 序。统计每个限制的时候，利用二分找到在某一层的 vector 中，这个限制要求的点的区间。遍历这个区间的每个节点，每个节点再开一个 vector，记录哪几个限制包含了该点。

在统计答案时，保持左端点不动，右端点右移，加入该点贡献，直到满足所有限制为止。记录答案后再将左端点右移，减去该点贡献即可。

[code](https://www.luogu.com.cn/paste/aqfxvm5f)

所有注释均为调试信息。

### 100pts 做法

观察每个限制的区间不难发现，不存在哪两个区间是交叉的，即所有的区间都是以大区间包含小区间的方式存在。

那么我们就没有必要考虑所有的限制区间，只考虑被包含的小的区间，小的区间满足了，包含它的大的区间一定满足，只统计这个区间的答案即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R1 register
#define F(i,a,b) for(int i = (a);i<=(b);i++)
using namespace std;
inline int read(){R1 int x=0,t=1;R1 char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') t=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*t;}
const int N=2e5+10;
vector<int>g[N];
int id1[N],tot,id2[N],b[N];
void add(int ui,int vi)
{
	g[ui].push_back(vi);
	return;
}
void bfs(int st)
{
	queue<int>q;
	q.push(st);
	while(q.size()){
		int u=q.front();
		id1[u]=++tot;
		q.pop();
		for(int v:g[u]){
			q.push(v);
		}
	}
	tot=0;
	return;
}
vector<int>d[N],f[N];
int dep[N],siz[N],sum[N];
void dfs(int u,int fa)
{
	dep[u]=dep[fa]+1;
	siz[u]=1;
	id2[u]=++tot;
	b[tot]=u;
	d[dep[u]].push_back(id2[u]);
	for(int v:g[u]){
		dfs(v,u);
		siz[u]+=siz[v];
	}
	return;
}
struct node
{
	int l,r,k;
}q[N],q1[N];
bool cmp(node x,node y)
{
	if(x.k!=y.k) return x.k<y.k;
	if(x.l!=y.l) return x.l<y.l;
	return x.r<y.r;
}
signed main()
{
	int n=read();
	F(i,2,n){
		add(read(),i);
	}
	bfs(1);
	dfs(1,0);
	int m=read();
	F(i,1,m){
		int u=read(),k=read();
		k=dep[u]+k;
		int L=id2[u],R=id2[u]+siz[u]-1;
		int l=0,r=d[k].size()-1,ql=-1,qr=-1;
		while(l<=r)
		{
			int mid=l+r>>1;
			if(d[k][mid]<L){
				l=mid+1;
			}
			else r=mid-1,ql=mid;
		}
		l=0,r=d[k].size()-1;
		while(l<=r){
			int mid=l+r>>1;
			if(d[k][mid]>R) r=mid-1;
			else{
				l=mid+1;
				qr=mid;
			}
		}
		q[i].l=ql,q[i].r=qr,q[i].k=k;
	}
	sort(q+1,q+1+m,cmp);
	int tott=0;
	F(i,1,m){
		if(q[i].k!=q[i-1].k){
			q1[++tott]=q[i];
		}
		else{
			if(q[i].l!=q[i-1].l) q1[++tott]=q[i];
		}
	}
	m=tott;
	F(i,1,m){
		F(j,q1[i].l,q1[i].r){
			int tmp=b[d[q1[i].k][j]];
			f[tmp].push_back(i);
		}
	}
	
	int r=0,cnt=0;
	int minn=1e9,al,ar;
	for(int i = 1;i<=n;i++){
		while(r<n && cnt!=m){
			r++;
			for(int v:f[r]){
				if(sum[v]==0){
					cnt++;
				}
				sum[v]++;
			}
		}
		if(cnt!=m){
			break;
		}
		int len=r-i+1;
		if(len<minn){
			minn=len;
			al=i,ar=r;
		}
		for(int v:f[i]){
			if(sum[v]==1){
				cnt--;
			}
			sum[v]--;
		}
	}
	cout << al << " " << ar << '\n';
	return 0;
}
/*

*/

```

---

## 作者：CatnipQwQ (赞：2)

萌新的第一篇题解 qwq。

我们可以发现区间越大越容易满足条件。如果我们枚举左端点的话，它对应的最小右端点一定是一直向右跑的。所以，我们只要支持在区间的末尾插入一个数，在开头删去一个数，判断区间是否符合条件就可以啦。

那么怎么判断呢？可以发现每个要求是限制一个子树中的某一个深度的点必须被选中一个。那我们可以对于每个条件记录满足它的点的数量，修改时枚举所有可能的条件并更新就行了。不过这样是过不去的。但是我们可以发现如果对于某一个点有两个限制，那么它们必定有祖先后代关系。并且如果这两个限制中较深的那个被满足了，另一个也必定被满足。那么另一个限制是没用的。所以我们把限制按照深度分类，再去除无用的限制，之后每个点上的限制就只有一个，就可以做出这道题啦。

再说一下具体的实现方式。先搜索一遍得到每个点的 dfs 序和它的子树中的 dfs 序的最大值，并且把点按深度分类，深度相同的点按 dfs 序排序。那么这个点的子树在 dfs 序上是一段区间。我们记录一个数组 $last_i$ 表示最后遍历到的深度为 $i$ 的限制。在进行第二次搜索的时候，在开始搜索某个点时，先把这个点上的所有限制存进 $last$ 中，再遍历这个点的所有儿子，最后再枚举这个点上的所有限制，如果某个限制还是最后遍历的那个，那么说明这个点的子树中不存在一个深度与它相同的限制。二分找到对应深度中最左边和最右边的在这个点子树中的节点，标记它们受这个限制影响。由于每个点上只会有一个限制，所以这样做时间复杂度是 $O(n\log n)$ 的。再然后像上面说的那样尺取就可以啦。

完结撒花 awa。
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> e[200005], xz[200005], dian[200005];
int dep[200005], dfn[200005], pos[200005], maxx[200005], tot=0;
int k[200005], last[2000005], col[200005], cnt[200005];
void dfs(int p)
{
	dfn[p]=++tot;
	pos[tot]=p;
	dian[dep[p]].push_back(dfn[p]);
	for(auto it:e[p])
	{
		dep[it]=dep[p]+1;
		dfs(it);
	}
	maxx[p]=tot;
}
void dfs2(int p)
{
	for(auto it:xz[p])
		last[k[it]]=it;
	for(auto it:e[p])
		dfs2(it);
	for(auto it:xz[p])
	{
		if(last[k[it]]!=it)
			continue;
		++tot;
		int lp=lower_bound(dian[k[it]].begin(), dian[k[it]].end(), dfn[p]) - dian[k[it]].begin();
		int rp=upper_bound(dian[k[it]].begin(), dian[k[it]].end(), maxx[p]) - dian[k[it]].begin() - 1;
		for(int i=lp; i<=rp; i++)
			col[pos[dian[k[it]][i]]]=tot;
	}
}
int main()
{
	int n;
	scanf("%d", &n);
	for(int i=2; i<=n; i++)
	{
		int fa;
		scanf("%d", &fa);
		e[fa].push_back(i);
	}
	dep[1]=1;
	dfs(1);
	int m;
	scanf("%d", &m);
	for(int i=1; i<=m; i++)
	{
		int p;
		scanf("%d%d", &p, &k[i]);
		k[i]+=dep[p];
		xz[p].push_back(i);
	}
	tot=0;
	dfs2(1);
	int lft=tot, rp=0, ansl=0, ansr=1e9;
	for(int i=1; i<=n; i++)
	{
		while(rp<=n&&lft!=0)
		{
			rp++;
			if(col[rp]!=0&&cnt[col[rp]]==0)
				lft--;
			cnt[col[rp]]++;
		}
		if(rp>n)
			break;
		if(ansr-ansl+1 > rp-i+1)
		{
			ansl=i;
			ansr=rp;
		}
		if(col[i]!=0)
		{
			cnt[col[i]]--;
			if(cnt[col[i]]==0) lft++;
		}
	}
	printf("%d %d", ansl, ansr);
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

考虑求出整棵树的 BFS 序，设为 $u_{1,2,3,\dots,n}$，则每个限制相当于给定 $(l,r)$，要求存在 $l \le i \le r$ 满足 $L \le u_i \le R$。这样的 $l$ 和 $r$ 显然可以通过在 **DFS 序上二分**求出。

注意到所有的 $(l,r)$ **要么包含，要么相离**。因此只需要求出所有极小的限制即可。这样可以满足 $\sum r-l=O(n)$。

对于一组限制，可以将其中所有点 $u_{l \cdots r}$ 按照大小排序，得到 $O(n)$ 条形如 $x_i \le L \le R \le y_i$ 是**不行的**的性质。

转化为平面上，转化为矩形并问题，可以扫描线解决。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10;
int n,m,dep[MAXN],dfn[MAXN],rev[MAXN],tot,psl[MAXN],ptot,pre[MAXN],sze[MAXN];
vector<int> G[MAXN],occ[MAXN];
void dfs(int u) {
	psl[u]=++ptot,pre[ptot]=u,sze[u]=1;
	occ[dep[u]].push_back(ptot);
	for(auto v:G[u]) dep[v]=dep[u]+1,dfs(v),sze[u]+=sze[v];
	return ;
}
void bfs() {
	queue<int> q;
	q.push(1);
	while(!q.empty()) {
		int u=q.front(); q.pop();
		dfn[u]=++tot,rev[tot]=u;
		for(auto v:G[u]) q.push(v);
	}
	return ;
}
set<int> al;
int tag[MAXN<<2];
struct INFO {int mn,pos;}t[MAXN<<2];
struct UPD {int l,r,v;};
vector<UPD> upd[MAXN];
INFO operator +(INFO A,INFO B) {
	INFO C;
	C.mn=min(A.mn,B.mn);
	if(A.mn<=B.mn) C.pos=A.pos;
	else C.pos=B.pos;
	return C;	
}
INFO operator +(INFO A,int B) {
	return A.mn+=B,A;	
}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void push_down(int k,int l,int r) {return tag[lson]+=tag[k],tag[rson]+=tag[k],t[lson]=t[lson]+tag[k],t[rson]=t[rson]+tag[k],tag[k]=0,void();}
void update(int k,int l,int r,int x,int y,int v) {
	if(x<=l&&r<=y) return tag[k]+=v,t[k]=t[k]+v,void();
	push_down(k,l,r);
	if(x<=mid) update(lson,l,mid,x,y,v);
	if(y>mid) update(rson,mid+1,r,x,y,v);
	return t[k]=t[lson]+t[rson],void();	
}
void build(int k,int l,int r) {
	t[k]={0,l};
	if(l!=r) build(lson,l,mid),build(rson,mid+1,r);
	return ;	
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,2,n) {int fa;cin>>fa,G[fa].push_back(i);}
	dfs(1),bfs();
	vector<pair<int,int>> lim;
	cin>>m;
	ffor(i,1,m) {
		int u,k;
		cin>>u>>k;
		if(dep[u]+k<=n) {
			int id=lower_bound(occ[dep[u]+k].begin(),occ[dep[u]+k].end(),psl[u])-occ[dep[u]+k].begin();
			if(id<occ[dep[u]+k].size()) {
				int ll=pre[occ[dep[u]+k][id]];
				id=lower_bound(occ[dep[u]+k].begin(),occ[dep[u]+k].end(),psl[u]+sze[u])-occ[dep[u]+k].begin()-1;
				int rr=pre[occ[dep[u]+k][id]];
				lim.push_back({dfn[ll],dfn[rr]});
			}
		}
	}
	sort(lim.begin(),lim.end(),[](pair<int,int> A,pair<int,int> B) {
		return A.second-A.first<B.second-B.first;
	});
	for(auto pr:lim) {
		int l=pr.first,r=pr.second;
		auto it=al.lower_bound(l);
		if(it!=al.end()&&*it<=r) continue ;
		vector<int> vc;
		ffor(i,l,r) vc.push_back(rev[i]),al.insert(i);
		vc.push_back(0),vc.push_back(n+1);
		sort(vc.begin(),vc.end());
		ffor(j,0,vc.size()-2) if(vc[j]+1<=vc[j+1]-1) {
			upd[vc[j]+1].push_back({vc[j]+1,vc[j+1]-1,1});
			upd[vc[j+1]].push_back({vc[j]+1,vc[j+1]-1,-1});
		}
	}
	int L=-1,R=-1;
	build(1,1,n);
	ffor(i,1,n) {
		for(auto pr:upd[i]) update(1,1,n,pr.l,pr.r,pr.v);
		if(i!=1) update(1,1,n,1,i-1,1);
		if(t[1].mn==0) {
			int l=i,r=t[1].pos;
			if(L==-1||r-l<R-L) L=l,R=r;	
		}
	}
	cout<<L<<' '<<R<<'\n';
	return 0;
}
```

---

## 作者：ZXZ_ (赞：1)

## P11513 [ROIR 2017] 培训 (Day 2) 题解

我们可以先求出树的 bfn 序，这样可以保证对于某个节点的某一层的全部节点的 bfn 序都是连续的方便我们操作。对于如何找到某个节点某一层的节点的 bfn 序的范围，我们可以再求出树的 dfn 序，再把树的每一层的所有节点的 dfn 序全部存起来。我们记录下来每个节点子树中的 dfn 序的起始和结尾，然后拿这个在目标层的 dfn 序中二分找到目标部分。求出我们查询的所有区间后，我们要去掉包含别人的区间以保证我们的时间复杂度，具体方法是把所有区间按左端点从大到小右端点从小到大排序，倒着做就好。

接着我们二分答案区间长度，按照类似滑动窗口的办法从头扫到尾去判断是否可以满足所有区间，一满足直接返回即可。

```
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,head[N],tot,bfn[N],cntbfn,dfn[N],cntdfn,m,st[N],ed[N],rnk[N],dept[N],pos[N],cnt[N];
struct edge{int nxt,to;}e[N<<1];
struct node{int l,r;};
vector<node>b,a[N];
vector<int>dep[N]; 
void add(int u,int v){
    e[++tot].nxt=head[u];
    e[tot].to=v;
    head[u]=tot;
}
queue<int>q;
void bfs(){
    q.push(1);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        bfn[x]=++cntbfn;
        for(int i=head[x];i;i=e[i].nxt)
            q.push(e[i].to);
    }
}
void dfs(int x,int fa,int depth){
    dfn[x]=++cntdfn;
    st[x]=dfn[x];
    ed[x]=dfn[x];
    dept[x]=depth;
    rnk[dfn[x]]=x;
    dep[depth].push_back(dfn[x]);
    for(int i=head[x];i;i=e[i].nxt)
        if(e[i].to!=fa){
            dfs(e[i].to,x,depth+1);
            ed[x]=max(ed[x],ed[e[i].to]);
        }
}
bool cmp(node a,node b){
    if(a.l!=b.l)return a.l<b.l;
    else return a.r>b.r;
}
node check(int mid){
    for(int i=1;i<=b.size();i++)
        cnt[i]=0;
    int res=0;
    for(int i=1;i<=n;i++){
        if(i<=mid){
            if(pos[bfn[i]]&&!cnt[pos[bfn[i]]])res++;
            cnt[pos[bfn[i]]]++;
        }else{
            if(pos[bfn[i]]&&!cnt[pos[bfn[i]]])res++;
            cnt[pos[bfn[i]]]++;
            if(pos[bfn[i-mid]]&&cnt[pos[bfn[i-mid]]]==1)res--;
            cnt[pos[bfn[i-mid]]]--;
        }
        if(i>=mid&&res==b.size()){
            return {i-mid+1,i};
        }
    }
    return {-1,-1};
}//
int main(){
    scanf("%d",&n);
    for(int i=2;i<=n;i++){
        int x;scanf("%d",&x);
        add(x,i);
    }
    bfs();
    dfs(1,0,1);
    scanf("%d",&m);
    for(int i=1;i<=n;i++)
        if(dep[i].size())
            sort(dep[i].begin(),dep[i].end());
    for(int i=1;i<=m;i++){
        int x,y;scanf("%d%d",&x,&y);
        y+=dept[x];
        int L=lower_bound(dep[y].begin(),dep[y].end(),st[x])-dep[y].begin();
        int R=upper_bound(dep[y].begin(),dep[y].end(),ed[x])-dep[y].begin();
        R--;
        a[y].push_back(node{bfn[rnk[dep[y][L]]],bfn[rnk[dep[y][R]]]});
    }
    int mn=1e9;
    for(int i=1;i<=n;i++)
        if(a[i].size()){
            sort(a[i].begin(),a[i].end(),cmp);
            int mn=1e9;
            for(int j=a[i].size()-1;j>=0;j--)
                if(a[i][j].r<mn){
                    b.push_back(node{a[i][j].l,a[i][j].r});
                    mn=a[i][j].r;
                }
        }
    sort(b.begin(),b.end(),cmp);
    for(int i=0;i<b.size();i++) 
        for(int j=b[i].l;j<=b[i].r;j++)
            pos[j]=i+1;
    int l=1,r=n;
    node ans;
    while(l<r){
        int mid=l+r>>1;
        node tmp=check(mid);
        if(tmp.l!=-1)r=mid,ans=tmp;
        else l=mid+1;
    }
    printf("%d %d\n",ans.l,ans.r);
}
```

---

## 作者：dAniel_lele (赞：1)

注意到任意两个限制要么包含要么不交。

也就是说，我们可以整理出若干形如 $v_1,v_2,\dots,v_k$ 中必须选择一个的限制使得 $\sum k\leq n$。

考虑树上启发式合并做到这一点。

然后从右往左扫，跑一个先把所有限制最大的塞进去，每次从右往左枚举右端点，使用可删堆维护左端点最右在哪里。

总复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define lowbit(i) (i&(-i))
using namespace std;
struct deletable_heap{
	priority_queue<int> add,del;
	void push(int x){
		add.push(x);
	}
	void pull(int x){
		del.push(x);
	}
	int top(){
		while(!del.empty()&&add.top()==del.top()) add.pop(),del.pop();
		return add.top(); 
	}
}pq;
vector<int> vc[500005];
vector<int> qq[500005];
vector<int> rem[500005];
vector<int> nd[500005];
int cntn,siz[500005],hson[500005],vis[500005],dep[500005],ddep[500005],ok[500005];
int cntt,nxt[500005];
void dfs0(int now){
	siz[now]=1; ddep[now]=1;
	for(auto v:vc[now]){
		dep[v]=dep[now]+1;
		dfs0(v);
		ddep[now]=max(ddep[now],ddep[v]+1);
		if(siz[v]>siz[hson[now]]) hson[now]=v;
		siz[now]+=siz[v];
	}
}
void dfs2(int now){
	if(!vis[now]) rem[dep[now]].push_back(now);
	else ok[dep[now]]=1;
	for(auto v:vc[now]){
		dfs2(v);
	}
}
void dfs1(int now,int tp){
	for(auto v:vc[now]) if(v!=hson[now]) dfs1(v,0);
	if(hson[now]) dfs1(hson[now],1);
	for(auto v:vc[now]) if(v!=hson[now]) dfs2(v);
	rem[dep[now]].push_back(now);
	for(auto v:qq[now]){
		if(!ok[dep[now]+v]){
			cntn++;
			ok[dep[now]+v]=1;
			for(auto u:rem[dep[now]+v]){
				vis[u]=cntn;
				nd[cntn].push_back(u);
			}
		}
	}
	if(!tp){
		for(int i=dep[now];i<=dep[now]+ddep[now]-1;i++){
			rem[i].clear();
			ok[i]=0;
		}
	}
}
signed main(){
	int n; cin>>n;
	for(int i=2;i<=n;i++){
		int p; cin>>p;
		vc[p].push_back(i);
	}
	int m; cin>>m;
	for(int i=1;i<=m;i++){
		int u,k; cin>>u>>k;
		qq[u].push_back(k);
	}
	dep[1]=1;
	dfs0(1);
	dfs1(1,0);
	for(int i=1;i<=cntn;i++){
		sort(nd[i].begin(),nd[i].end());
		int lst=-1;
		for(int j=nd[i].size()-1;j>=0;j--){
			nxt[nd[i][j]]=lst;
			lst=nd[i][j];
		}
//		for(auto v:nd[i]) cout<<v<<" "; cout<<"\n";
	}
	int minlen=1e18,minl=0;
	for(int i=n;i>=1;i--){
		if(nxt[i]!=0){
			if(nxt[i]==-1){
				pq.push(i);
				cntt++;
			}
			else{
				pq.pull(nxt[i]);
				pq.push(i);
			}
		}
		if(cntt==cntn){
			if(pq.top()-i+1<=minlen){
				minlen=pq.top()-i+1;
				minl=i;
			}
		}
	}
	cout<<minl<<" "<<minl+minlen-1;
	return 0;
}
```

---

## 作者：Jerry_heng (赞：1)

（一）

萌新刚学线段树。一道细节比较多的线段树优化 DP。

先把这个树按照深度从小到大，同层里从左到右，就是 BFS 序列出。设 $u$ 的 BFS 序为 $a_u$。

那么询问的下属就是一段区间，考虑怎么求区间左右端点。

树上跑 DFS，那么 $u$ 的子树就是 $dfn_u\sim dfn_u+siz_u-1$。$siz_u$ 为子树大小。

将深度为 $d$ 的点插入一个 set 里，在这个 set 里二分即可。

![logo](https://cdn.luogu.com.cn/upload/image_hosting/tsuvj25c.png)

比如同时求 $2$ 号节点的 $2$ 层下属和 $4$ 号节点的 $1$ 层下属，只用保留绿色圈即可。

开一个支持区间赋值，求区间和的线段树来判断要操作的区间是否包含已经操作过的区间，如果包含则不继续操作。

这里将条件按照员工 $u_j$ 的深度从大到小排序，以保证先操作小区间。

求出左右端点后，把里面所有的点放入一个新开的区间，点的总和不会超过 $n$。

（二）

那么问题就转化为了给你一些集合，要求每个集合拿出一个数，使最大值和最小值的差最小。

设 $dp_i$ 表示以 $i$ 为最小数时最大数最小为几。

设当前集合内元素为 $a_1,a_2,a_3,\dots$。

将以 $1\sim a_1$ 为下标的 $dp$ 数组对 $a_1$ 取 $\max$。


将以 $a_1+1\sim a_2$ 为下标的 $dp$ 数组对 $a_2$ 取 $\max$。

$\dots$。

最终答案就是最小的 $dp_i-i+1$。

（三）

AC 代码。

```cpp
//2025-01-08 08:49:43
#include<bits/stdc++.h>
#define db double
#define pb push_back
#define eb emplace_back
#define fi first
#define se second
#define mkp make_pair
#define pii pair<int,int>
using namespace std;
bool MBE;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f; 
}
const int mxn=2e5+10;
int cnt,tot,dep[mxn],id[mxn],siz[mxn],dfn[mxn],id2[mxn],m,n,a[mxn],tag[mxn<<2],b[mxn],tree1[mxn<<2];
queue<int>q;
vector<int>E[mxn];
set<int>st[mxn],s[mxn];
pii qu[mxn];
bool cmp(pii x,pii y){
	return dep[x.fi]>dep[y.fi]||dep[x.fi]==dep[y.fi]&&x.se>y.se;
}
void dfs(int u,int f){
	dep[u]=dep[f]+1;
	dfn[u]=++tot,id[tot]=u;
	siz[u]=1;
	for(int v:E[u]){
		dfs(v,u);
		siz[u]+=siz[v];
	}
}
void change(int o,int l,int r){
	tree1[o]=r-l+1;
	tag[o]=1;
}
void pushdown1(int o,int l,int r){
	if(!tag[o])return;
	tag[o]=0;
	int mid=(l+r)>>1;
	change(o*2,l,mid),change(o*2+1,mid+1,r);
}
int query1(int o,int l,int r,int L,int R){
	if(L<=l&&r<=R)return tree1[o];
	pushdown1(o,l,r);
	int mid=(l+r)>>1;bool res=0;
	if(L<=mid)res+=query1(o*2,l,mid,L,R);
	if(R>mid)res+=query1(o*2+1,mid+1,r,L,R);
	return res;
}
void update1(int o,int l,int r,int L,int R){
	if(L<=l&&r<=R){
		change(o,l,r);
		return;
	}
	pushdown1(o,l,r);
	int mid=(l+r)>>1;
	if(L<=mid)update1(o*2,l,mid,L,R);
	if(R>mid)update1(o*2+1,mid+1,r,L,R);
	tree1[o]=tree1[o*2]+tree1[o*2+1];
}
void change(int o,int x){
	tag[o]=max(tag[o],x);
}
int query2(int o,int l,int r,int pos){
	if(l==r)return tag[o];
	int mid=(l+r)>>1;
	if(pos<=mid)return max(tag[o],query2(o*2,l,mid,pos));
	else return max(tag[o],query2(o*2+1,mid+1,r,pos));
}
void update2(int o,int l,int r,int L,int R,int val){
	if(L<=l&&r<=R){
		tag[o]=max(tag[o],val);
		return;
	}
	int mid=(l+r)>>1;
	if(L<=mid)update2(o*2,l,mid,L,R,val);
	if(R>mid)update2(o*2+1,mid+1,r,L,R,val);
}
signed main(){
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=read();
    for(int i=2;i<=n;i++){
    	int x=read();
    	E[x].eb(i);
    }
    q.push(1);
    while(!q.empty()){
    	int u=q.front();q.pop();
    	a[u]=++tot;id2[tot]=u;
    	for(int v:E[u])
    		q.push(v);
    }
    tot=0;
    dfs(1,0);
    for(int i=1;i<=n;i++)
    	st[dep[i]].insert(dfn[i]);
    m=read();
    for(int i=1;i<=m;i++){
    	qu[i].fi=read(),qu[i].se=read();
    }
    sort(qu+1,qu+m+1,cmp);
    for(int i=1;i<=m;i++){
    	int u=qu[i].fi,k=qu[i].se;
    	int d=dep[u]+k;
    	auto it=st[d].upper_bound(dfn[u]);
    	int l=*it;
    	it=st[d].upper_bound(dfn[u]+siz[u]-1);
    	it--;
    	int r=*it;
    	l=a[id[l]],r=a[id[r]];
    	if(query1(1,1,n,l,r))continue;
    	update1(1,1,n,l,r);
    	cnt++;
    	for(int j=l;j<=r;j++)
    		s[cnt].insert(id2[j]);
    }
    memset(tag,0,sizeof tag);
    int mn=n;
    for(int i=1;i<=cnt;i++){
    	int las=1,mx=0;
    	for(int j:s[i]){
    		mx=max(mx,j);
    		update2(1,1,n,las,j,j);
       		las=j+1;
    	}
    	mn=min(mn,mx);
    }
    int res=n+1,resl=0;
    for(int i=1;i<=mn;i++){
    	int p=query2(1,1,n,i);
    	if(p-i+1<res)res=p-i+1,resl=i;
    }
    printf("%d %d\n",resl,res+resl-1);
    bool MED;
    cerr<<(&MED-&MBE)/1048576.0<<" MB, "<<1000*clock()/CLOCKS_PER_SEC<<" ms\n";
    return 0;
}
```

---

## 作者：AlicX (赞：0)

考虑对要求分类，第 $i$ 个要求是在 $dep_{u_i}+k_i$ 这个深度中找点，不妨就把这些点一起考虑。

首先考虑一个点 $v$ 会对那些要求有贡献，显然满足 $dep_v=dep_{u_i}+k_i$，且 $in_u \leq id_v \leq out_u$。

不难再发现一个性质，对于在同一深度的要求，形如 $dep_{u_i}+k_i=dep_{u_j}+k_j$，若 $j$ 是 $i$ 的祖先，那满足了 $i$ 一定满足 $j$，所以可以去掉 $j$，然后我们得到了若干**不相交**的区间。

然后用双指针表示当前答案区间，接下来就对于每层深度的每个区间维护 $cnt$，表示答案区间中有多少点给这个区间做贡献，若所有区间 $cnt$ 的最小值大于零，就满足条件。

时间复杂度 $O(n \log n)$，因为是单点修改，可以不用线段树。

```cpp
#include<bits/stdc++.h> 
#define ll long long 
#define x first 
#define y second 
#define il inline 
#define em emplace 
#define eb emplace_back 
#define debug() puts("-----") 
using namespace std; 
typedef pair<int,int> pii; 
il int read(){ 
	int x=0,f=1; char ch=getchar(); 
	while(ch<'0'||ch>'9'){ if(ch=='-') f=-1; ch=getchar(); } 
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar(); 
	return x*f; 
} 
const int INF=1e9+7; 
const int N=2e5+10,M=50; 
int n; 
int dep[N]; 
int siz[N]; 
int out[N]; 
int id[N],cnt=0; 
int rt[N],idx=0; 
vector<int> e[N],q[N]; 
struct Node{ 
	int ls,rs,w; 
}tr[N*M]; 
il void dfs(int u,int fa){ 
	id[u]=++cnt; 
	dep[u]=dep[fa]+1; 
	for(auto to:e[u]) dfs(to,u); 
	out[u]=cnt; 
} 
il void pushup(int u){ 
	tr[u].w=min(tr[tr[u].ls].w,tr[tr[u].rs].w); 
} 
il void build(int &u,int l,int r){ 
	u=++idx; 
	if(l==r) return ; 
	int mid=l+r>>1; 
	build(tr[u].ls,l,mid),build(tr[u].rs,mid+1,r); 
} 
il void modify(int &u,int l,int r,int x,int w){ 
	if(!u) u=++idx; 
	if(l==r){ 
		tr[u].w+=w; 
		return ; 
	} int mid=l+r>>1; 
	if(x<=mid) modify(tr[u].ls,l,mid,x,w); 
	else modify(tr[u].rs,mid+1,r,x,w); 
	pushup(u); 
} 
il bool cmp1(int a,int b){ return id[a]>id[b]; } 
il bool cmp2(int a,int b){ return id[a]<id[b]; } 
int Tr[N]; 
#define low(x) x&-x 
il void add(int x,int w){ 
	for(int i=x;i;i-=low(i)) Tr[i]=min(Tr[i],w); 
} 
il void clear(int x){ 
	for(int i=x;i;i-=low(i)) Tr[i]=INF; 
} 
il int qry(int x){ 
	int res=INF; 
	for(int i=x;i<=n;i+=low(i)) res=min(res,Tr[i]); 
	return res; 
} 
multiset<int> s; 
il void work(int u,int w){ 
	int L=0,R=q[dep[u]].size()-1,p=-1; 
	while(L<=R){ 
		int mid=L+R>>1; 
		if(id[q[dep[u]][mid]]<=id[u]) L=mid+1,p=mid; 
		else R=mid-1; 
	} if(p!=-1&&id[q[dep[u]][p]]<=id[u]&&id[u]<=out[q[dep[u]][p]]){ 
		s.erase(s.find(tr[rt[dep[u]]].w)); 
		modify(rt[dep[u]],1,q[dep[u]].size(),p+1,w); 
		s.insert(tr[rt[dep[u]]].w); 
	} 
} 
signed main(){ 
	n=read(); 
	for(int i=1;i<=n;i++) Tr[i]=INF; 
	for(int i=2,x;i<=n;i++) x=read(),e[x].eb(i); 
	dfs(1,0); int m=read(); 
	while(m--){ 
		int u=read(),k=read(); 
		q[dep[u]+k].eb(u); 
	} for(int i=1;i<=n;i++){ 
		vector<int> vec,del; 
		sort(q[i].begin(),q[i].end(),cmp1); 
		for(auto u:q[i]){ 
			if(qry(id[u])<=out[u]) continue; 
			add(id[u],out[u]); del.eb(id[u]),vec.eb(u); 
		} for(auto u:del) clear(id[u]); 
		q[i]=vec; sort(q[i].begin(),q[i].end(),cmp2); 
		if(!q[i].empty()) s.insert(0),build(rt[i],1,q[i].size()); 
	} int l=1,r=0; 
	int ans=INF,ql=0,qr=0; 
	while(l<=n){ 
		while(r<n&&*s.begin()==0) r++,work(r,1); 
		if(*s.begin()>0){ 
			if(r-l+1<ans) ans=r-l+1,ql=l,qr=r; 
		} work(l,-1); l++; 
	} printf("%d %d\n",ql,qr); 
	return 0; 
} 
```

---

## 作者：qnqfff (赞：0)

### 思路

首先对于两个限制 $(u,k1)$ 和 $(v,k2)$ 若 $u$ 是 $v$ 的祖先且 $dep_u+k1=dep_v+k2$ 则第一条限制没用，所以把没用的限制删掉，则每个点只会属于一个限制。

现在问题变成有很多个集合，每个集合里面选一个数，使得选择的数的 $\max$ 减 $\min$ 最小，扫描线枚举 $\min$，每个集合维护当前最小的大于等于目前 $\min$ 的指针即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){char c=getchar();int p=0,flg=1;while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,m,dep[200010],vis[200010],bel[200010],tag[200010];vector<int>e[200010],use[200010],D[200010];vector<array<int,2>>Q[200010];
signed main(){
	n=read();for(int i=2;i<=n;i++) e[read()].push_back(i);m=read();for(int i=1;i<=m;i++){int x=read(),d=read();Q[x].push_back({d,i});}
	function<void(int,int)>dfs=[&](int u,int fa){
		dep[u]=dep[fa]+1;for(auto v:Q[u]){while(!D[dep[u]+v[0]].empty()){vis[D[dep[u]+v[0]].back()]=1;D[dep[u]+v[0]].pop_back();}D[dep[u]+v[0]].push_back(v[1]);}
		for(auto v:e[u]) if(v^fa) dfs(v,u);if(!D[dep[u]].empty()) use[D[dep[u]].back()].push_back(u);for(auto v:Q[u]) if(!vis[v[1]]) D[dep[u]+v[0]].pop_back();
	};dfs(1,0);for(int i=1;i<=m;i++) if(!vis[i]){sort(use[i].begin(),use[i].end());for(auto j:use[i]) bel[j]=i;}
	int L=1e18,R=0;for(int i=1;i<=m;i++) if(!vis[i]){L=min(L,use[i].front());R=max(R,use[i].front());}
	int pL=L,pR=R;for(int i=1,lst=-1;i<=n;i++) if(bel[i]){
		if(!~lst) lst=i;
		else{pL=i;tag[bel[lst]]++;if(tag[bel[lst]]>=use[bel[lst]].size()) break;pR=max(pR,use[bel[lst]][tag[bel[lst]]]);lst=i;}
		if(pR-pL+1<R-L+1||(pR-pL+1==R-L+1&&pL<L)) L=pL,R=pR;
	}cout<<L<<' '<<R<<'\n';
	return 0;
}
```

---


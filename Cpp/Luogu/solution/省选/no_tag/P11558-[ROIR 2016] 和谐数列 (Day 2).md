# [ROIR 2016] 和谐数列 (Day 2)

## 题目背景

翻译自 [ROIR 2016 D2T4](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day2.pdf)。

## 题目描述

如果一个整数数列 $a_1, a_2, \dots, a_n$ 满足其中每个数（除了 $a_1$ 和 $a_n$）等于其相邻两个数的和，即 $a_2 = a_1 + a_3, a_3 = a_2 + a_4, \dots, a_{n-1} = a_{n-2} + a_n$，那么我们称这个序列为和谐数列。  

例如，数列 $[1, 2, 1, {-1}]$ 是和谐数列，因为 $2 = 1 + 1$，且 $1 = 2 + ({-1})$。

现在考虑两个相同长度的数列 $A = [a_1, a_2, \dots, a_n]$ 和 $B = [b_1, b_2, \dots, b_n]$。我们定义它们之间的距离为：
$$ d(A, B) = |a_1 - b_1| + |a_2 - b_2| + \dots + |a_n - b_n| $$  
例如，$d([1, 2, 1, {-1}], [1, 2, 0, 0]) = |1 - 1| + |2 - 2| + |1 - 0| + |{-1} - 0| = 0 + 0 + 1 + 1 = 2$。

现有一个数列 $B = [b_1, b_2, \dots, b_n]$，需要找出一个和谐数列 $A = [a_1, a_2, \dots, a_n]$，使得 $d(A, B)$ 最小。你只需要求出 $d(A, B)$ 的最小值即可。

## 说明/提示

### 样例解释

在样例中，可以令 $A=[1, 2, 1, {-1}]$，这样 $d([1, 2, 1, {-1}], [1, 2, 0, 0]) = 2$。可以证明 $d(A,B)$ 不可能小于 $2$。

### 数据范围

| 子任务 | 是否捆绑 | 分值 | $3\le n\le$ | $\lvert b_i\rvert\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $14$ | $3$ | $10$ |
| $2$ | 是 | $14$ | $500$ | $100$ |
| $3$ | 是 | $16$ | $100000$ | $100$ |
| $4$ | 是 | $16$ | $1000$ | $10^9$ |
| $5$ | 是 | $40$ | $300000$ | $10^9$ |

## 样例 #1

### 输入

```
4  
1 2 0 0```

### 输出

```
2```

# 题解

## 作者：qczrz6v4nhp6u (赞：5)

### Solution

不难发现若一个和谐序列的前两项都确定了，则整个序列也都确定了。所以它一定是这样的形式：

$$u,v,v-u,-u,-v,u-v,\cdots$$

考虑设 $f(u,v)$ 表示以 $u,v$ 生成的和谐序列与 $b$ 的距离，不难把 $f(u,v)$ 表示成绝对值相加的形式。由于绝对值具有凸性，我们大胆猜测 $f$ 也具有凸性，打个表发现对完了。

现在你只需要求 $f$ 在 $\mathbb Z\times \mathbb Z$ 上的最小值，二分一下斜率就做完了。复杂度 $O(n\log n+\log^3 V)$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=3e5+5;
int n,a[N];
inline ll Abs(ll x){return x>0?x:-x;}
struct ds{
	int b[N],tot;ll s[N];
	inline void add(int x){b[++tot]=x;}
	void init(){
		sort(b+1,b+tot+1);
		for(int i=1;i<=n;i++)s[i]=s[i-1]+b[i];
	}
	inline ll qry(ll x){
		int pos=upper_bound(b+1,b+tot+1,x)-b-1;
		return (pos*x-s[pos])+(s[tot]-s[pos]-(tot-pos)*x);
	}
};
ds c[3];
inline ll f(ll u,ll v){
	return c[0].qry(u)+c[1].qry(v)+c[2].qry(v-u);
}
inline ll get(ll u){
	ll l=-1e10,r=1e10,mid;
	while(l<r){
		mid=(l+r+1)>>1;
		if(f(u,mid)-f(u,mid-1)<0)l=mid;
		else r=mid-1;
	}
	return f(u,l);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int k=0;k<3;k++){
		for(int i=k+1,op=1;i<=n;i+=3,op*=-1)
			c[k].add(a[i]*op);
		c[k].init();
	}
	ll l=-1e10,r=1e10,mid;
	while(l<r){
		mid=(l+r+1)>>1;
		if(get(mid)-get(mid-1)<0)l=mid;
		else r=mid-1;
	}
	cout<<get(l)<<'\n';
	return 0;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

我们来看一下和谐数列有什么深层次的性质。

首先根据定义得：

$$a_n = a_{n - 1} + a_{n + 1}, a_{n + 1} = a_n + a_{n + 2}(n \ge 2)$$

将后面的 $a_n$ 替换为 $a_{n - 1} + a_{n + 1}$，故得 $a_{n - 1} + a_{n + 2} = 0$，故有 $a_{n + 2} = a_{n - 1}$，故 $a_n = -a_{n - 3} (n \ge 4)$。

故若我们知道 $a_1 = x, a_3 = y$，那么这整个和谐数列就确定了。

考虑将 $b$ 中每 $6$ 个元素分别划分到 $6$ 个可重集，设为 $S_i$。

故 $S_1$ 面对的是 $x$，$S_2$ 面对的是 $x + y$，$S_3$ 面对的是 $y$，$S_4$ 面对的是 $-x$，$S_5$ 面对的是 $-(x + y)$，$S_6$ 面对的是 $-y$。

故我们需要求下列式子的最小值：

$$f(x, y) = \sum_{v \in S_1} |v - x| + \sum_{v \in S_2} |v - (x + y)| +  \sum_{v \in S_3} |v - y| + \\ \sum_{v \in S_4} |v + x| +  \sum_{v \in S_5} | v + x + y| +  \sum_{v \in S_6} | v + y|$$

看起来很复杂啊，但是你求一下二阶偏导发现 $f$ 是一个二元凸函数。

故考虑使用最大/最小值定理，在 $x$ 不变时，关于 $y$ 的函数的导数等于 $0$ 时应该是最小的；同理，当 $y$ 不变时，关于 $x$ 的函数的导数等于 $0$ 时也是最小的。

容易发现其导函数是单增的。

故考虑二分 $x$，然后求出 $f(x, y)_{\min}$ 与 $f(x - 1, y)_{\min}$ 的大小关系。

那么如何求出 $f(x, y)_{\min}$，二分 $y$ 即可，判断 $f(x, y)$ 与 $f(x, y - 1)$ 的大小关系。

如何快速求出 $f(x, y)$，离散化后维护 $6$ 个树状数组即可，也可以预处理出前缀和后二分。

时间复杂度为 $O(N \log N + \log^2 W \log N)$。

---

## 作者：yangmingshuo114514 (赞：2)

我们转化一下和谐序列的限制，把它变成 $a_{i+2}=a_{i+1}-a_i(1\le i\le n-2)$，所以现在只需要确定前两个数 $a_1,a_2$ 就可以知道整个序列。

考虑用模拟退火随机前两个数计算距离。但是知道前两个数直接根据递推式计算距离是 $O(n)$ 的，我们需要优化它的复杂度。

我们找一下规律，发现：$a_3=-a_1+a_2,a_4=-a_1,a_5=-a_2,a_6=a_1-a_2,a_7=a_1,a_8=a_2,\cdots$，从 $a_7$ 开始出现了同样的周期。通过找规律，我们得到 $a_{i+6}=a_i$。所以我们直接把 $b_i$ 按 $i$ 模 $6$ 的余数分类，问题就转化为了已知一个数和一个序列，求这个数和这个序列里的每个数的差的绝对值之和。这个用二分 + 前缀后缀和是很好实现的。这样做的话，计算距离的时间复杂度就降到了 $O(\log n)$。

还有一个优化，就是注意到 $a_{i+3}=-a_i$，所以我们把 $i$ 模 $6$ 余 $4,5,0$ 的 $b_i$ 取反后分别归入 $i$ 模 $1,2,3$ 就可以了。这样常数是会少一半的。

code:
```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
const double low=0.9997;
const double sttem=1000;
const double eps=1e-9;
const int M=300005;
using namespace std;
mt19937 RAND(time(0));
int n,f;ll b[M];
ll res;char ch;
double tem;
il ll read(){
    res=0,ch=getchar(),f=1;
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        res=(res<<3)+(res<<1)+(ch&15);
        ch=getchar();
    }
    return f==1?res:-res;
}
void printt(ll x){
    if(x==0) return;
    printt(x/10);
    putchar(x%10+'0');
}
void print(ll x){
    if(x<0) putchar('-'),x=-x;
    if(x==0){
        putchar('0');
        putchar('\n');
        return;
    }
    printt(x);
    putchar('\n');
}
int tot[3];ll a[3][M];
ll suf[3][M],pre[3][M];
int p1,p2,p3;
il ll calc(ll x,ll y){
    p1=lower_bound(a[0]+1,a[0]+tot[0]+1,x)-a[0];
    p2=lower_bound(a[1]+1,a[1]+tot[1]+1,y)-a[1];
    p3=lower_bound(a[2]+1,a[2]+tot[2]+1,-x+y)-a[2];
    res=(p1+p1-2-tot[0])*x+suf[0][p1]-pre[0][p1-1];
    res+=(p2+p2-2-tot[1])*y+suf[1][p2]-pre[1][p2-1];
    res+=(p3+p3-2-tot[2])*(-x+y)+suf[2][p3]-pre[2][p3-1];
    return res;
}
ll intrand(){
    return RAND()-2147483648ll;
}
ll ansx,ansy,anse;
ll nowx,nowy,nowe,de;
void SA(){
    tem=sttem;
    while(tem>eps){
        nowx=ansx+intrand()*tem;
        nowy=ansy+intrand()*tem;
        nowe=calc(nowx,nowy);
        de=nowe-anse;
        if(de<0)
			ansx=nowx,ansy=nowy,anse=nowe;
        else if(exp(-de/tem)*INT_MAX>RAND())
            ansx=nowx,ansy=nowy;
        tem*=low;
    }
}
int main(){
    n=read();
    for(int i=1;i<=n;i++)
        b[i]=read();
    for(int i=1;i<=n;i++){
    	if(i%6==1) a[0][++tot[0]]=b[i];
    	if(i%6==2) a[1][++tot[1]]=b[i];
    	if(i%6==3) a[2][++tot[2]]=b[i];
    	if(i%6==4) a[0][++tot[0]]=-b[i];
    	if(i%6==5) a[1][++tot[1]]=-b[i];
    	if(i%6==0) a[2][++tot[2]]=-b[i];
	}
	sort(a[0]+1,a[0]+tot[0]+1);
	sort(a[1]+1,a[1]+tot[1]+1);
	sort(a[2]+1,a[2]+tot[2]+1);
	for(int i=0;i<3;i++){
		for(int j=1;j<=tot[i];j++)
			pre[i][j]=pre[i][j-1]+a[i][j];
		for(int j=tot[i];j;j--)
			suf[i][j]=suf[i][j+1]+a[i][j];
	}
    ansx=b[1];ansy=b[2];
    anse=calc(ansx,ansy);
    for(int i=1;i<=50;i++) SA();
    print(anse);
    return 0;
}

---


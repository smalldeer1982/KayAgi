# 【MX-X8-T5】「TAOI-3」蓝宝石的存在证明

## 题目背景

原题链接：<https://oier.team/problems/X8F>。

---

她背对着曾崇拜神的祭坛，就像在祈祷的圣女一样。

——啊，神呀。这是何等的悲剧。

能否恳请您把这出悲剧变成喜剧，变成一出任何人也能开怀大笑的愉快喜剧?

然后，若是您大发慈悲，求求实现我的恋情。是的，唯有一回我也乐意。

向神发誓，我赌上一生来爱你。

向神发誓，我求得偿夙愿。

## 题目描述

——只要打开这本魔法之书，自己的存在就会被世人遗忘。

世人之间的连接可以被看做一个 $n$ 个点的有标号无向简单**连通**图 $(V,E)$。此外，Kisaki 还会给你一个整数 $t \in \{0,1\}$，若 $t=0$，则这张无向连通图必须满足任意两点之间存在唯一的简单路径。若 $t=1$，则没有限制。

我们定义一个 $V$ 的一个子集 $W$ 是「紧密」的，当且仅当 $W$ 是图上的一个连通块，满足 $|W| \ge 2$，且对于任意 $u,v \in W$，都满足 $\text{dis}(u,v) \le 2$，其中 $\text{dis}(u,v)$ 为 $u,v$ 最短路径上的边数。

对于世人的一种连接方式，Kisaki 定义它是好的，当且仅当存在 **恰好** 一种方案把 $V$ 划分成若干点集，使得每个划分出的点集都是「紧密」的。

现在，Kisaki 告诉了你 $n$ 和 $t$，她想要知道，有多少种好的连接方式。当然，可能的方案是很多的，所以如你所想地——你所计算的方案数需要对模数 $P$ 取模（$P$ 未必是素数）。另外，她可能会问你很多次。

## 说明/提示

**【样例解释 #1】**

若 $n=3$ 且 $t=1$，一种合法的连接方式如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/c89l5zsn.png)

唯一一种对它的合法划分方案为，划分成 $\{1,2,3\}$ 这一个集合。这种连接方式在 $t=0$ 时是不合法的。

**【样例解释 #2】**

若 $n=5$，无论 $t=0$ 还是 $t=1$，一种合法的连接方式如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/asn5svxb.png)

唯一一种对它的合法划分方案为，划分成 $\{1,2\}$ 和 $\{3,4,5\}$ 两个集合。

**【数据范围】**

**本题采用捆绑测试。**

- 子任务 1（1 分）：$P=1$。
- 子任务 2（6 分）：$n,T \le 7$，$t=0$。
- 子任务 3（6 分）：$n,T \le 7$，$t=1$。
- 子任务 4（12 分）：$P \le 2$，$t=1$。
- 子任务 5（23 分）：$t=0$。
- 子任务 6（21 分）：$n,T \le 100$。
- 子任务 7（17 分）：$P \ge 10^8$ 且 $P$ 为质数。
- 子任务 8（14 分）：无特殊限制。

对于所有数据，保证 $1 \le n,T \le 5 \times 10^3$，$0 \le t \le 1$，$1 \le P \le 1.05 \times 10^9$。

## 样例 #1

### 输入

```
8 998244353 1
1
2
3
5
98
197
1145
4950
```

### 输出

```
0
1
4
65
369585723
752044625
87224156
664115047```

## 样例 #2

### 输入

```
8 998244353 0
1
2
3
5
98
197
1145
4950
```

### 输出

```
0
1
3
65
607286080
653853011
777350973
422131392```

# 题解

## 作者：251Sec (赞：6)

### 题意简述

对 $n$ 个点的无向连通图或树计数，要求存在恰好一种方案把它的点集划分成若干连通块，每个连通块直径不超过 $2$。对输入的模数 $P$ 取模。

$1 \le n,T \le 5 \times 10^3$，$0 \le t \le 1$，$1 \le P \le 1.05 \times 10^9$。

### 解法

特判 $n \le 3$ 的情况，我们接下来的讨论可能在这些边界上出错。

第一个观察是，对于任何 $n \ge 2$ 的连通图，存在至少一种划分方案。

显然只需要对树证明，我们直接给出构造。首先一个树上的合法点集形如一个菊花。按照一个你喜欢的顺序加入每个点 $u$，考虑和它相邻的点 $v$。

若 $v$ 未被加入任何菊花，直接把 $u,v$ 配对。

若 $v$ 是一个菊花的中心，直接把 $u$ 加入 $v$ 的菊花。

否则，若 $v$ 所在菊花大小大于 $2$，可以把 $v$ 从那个菊花里拿出来和 $u$ 配对。

否则，$v$ 所在菊花大小等于 $2$，可以直接把 $v$ 作为那个菊花的中心，把 $u$ 加入。

这样就构造出了一组方案。

实际上这给出了一个信息：考虑两组把原图划分成若干大小 $\ge 2$ 的连通块的方案和一个点 $u$，令 $u$ 在两组方案里所在连通块的点集为 $S,T$，若 $S \cap T = \{u\}$，则它们一定给出了两种不同的最终构造方案。

接下来考虑树的情况。我们给出如下结论：对于一棵树，满足条件当且仅当所有非叶节点和至少一个叶子相邻。其中叶子指度数为 $1$ 的点，后面讨论一般图时，我们也这么定义叶子。

必要性：如果有一个点不和任何叶子相邻，那么删去它可以得到至少两个大小 $\ge 2$ 的连通块，设它们为 $A,B$，那么 $\{A,B\cup\{u\}\}$ 和 $\{B,A\cup\{u\}\}$ 给出了两种不同的划分。

充分性：考虑归纳，我们每次找到任意一个非叶节点 $u$，考虑所有和它相邻的点 $v$，如果 $v$ 是叶子，那么 $v$ 必须和 $u$ 划分到一起，否则 $v$ 必定不能和 $u$ 划分到一起。（因为这样做会产生孤立的大小为 $1$ 的连通块）删去 $u$ 和所有与 $u$ 相邻的叶子之后递归到一个子问题。

对于一般图的情况我们有类似的结论：对于一个 $n \ge 4$ 的无向连通图，满足条件当且仅当对所有非叶子节点 $u$，它都和至少一个叶子相邻。

为了证明它，我们先给出一个引理：对于 $n \ge 4$ 的合法的无向连通图，不存在一个非叶节点，删去后原图仍然连通。

考虑反证，最坏情况是：删去这个点之后剩下一棵树且删去的节点度数为 $2$，我们只需证明这种情况下有至少两种方案。提取出和删去节点相邻的两个点之间的树上路径，和这两条边组成一个环，则我们图的形态形如一个环往外挂一些连通块。

如果环上某个点往外挂的所有连通块都有 $\ge 2$ 个点，那么这个点加入与不加入某个连通块就有两种方案。否则删去所有往外挂的 $\ge 2$ 个点的连通块，一定可以得到一个 $\ge 4$ 的纯环或者一个环往外挂叶子的形式，且一定有至少一个点没往外挂叶子。（对应那个度数为 $2$ 的点）不难验证这些情况下都有至少两种方案。

于是现在每个点要么是叶子要么删去后可以得到至少两个连通块。仿照树的情况，我们可以证明原结论。

接下来只需要考虑如何计数。枚举非叶节点的个数，则它们应当组成一个连通图或一棵树，且每个点上要挂至少一个叶子，令 $f_i$ 代表 $i$ 个点的连通图或树的个数，答案为：

$$
\sum_{i=1}^n f_i \begin{Bmatrix}n-i \\ i\end{Bmatrix}\binom{n}{i}i!
$$

容易在 $O(n^2)$ 复杂度内预处理后 $O(n)$ 回答单组数据。

据说存在 NTT 模数下 $O(n \log^2 n)$ 复杂度的做法，有没有大神来搞一下。

---

## 作者：tobie (赞：5)

有趣的结论题。

先考虑树上问题。此时“紧密”的点集其实就是非平凡菊花图。

手玩一些情况，我们注意到一个事实：

> Lamma 1：对于一棵 $n\ge 2$ 的树，一定存在至少一种划分方式。
>
> 证明：考虑归纳，设我们已经证明了 $2\le n\le k$ 时均存在拆分方式，现在证明 $n=k+1$ 时存在拆分。
>
> 考虑找到一个叶子 $u$ 和连接这个叶子的节点 $v$，则我们删除 $v$ 周围的**所有**叶子节点后，会形成若干（可能为 $0$）个大小大于等于 $2$ 的树，这是一个子问题。

事实上这个结论可以推广到任意连通图，只要关注一个生成树即可。

所以本题的重点在于“拆分方式唯一”的限制。考虑一下什么时候拆分不唯一：

![](https://cdn.luogu.com.cn/upload/image_hosting/o7b16kqd.png)

此时，$1$ 可以被分给 $2,3$ 号点为中心的菊花图里，已经出现了两种拆分方案。

考虑以 $3$ 号节点为根，则两种拆分方案中，$1$ 可以与 $3$ 连，也可以不与 $3$ 连，而我们不管要不要删除 $1$，根据前面的引理都将剩下的子树拆分。

而 $1$ 号节点作为被“争抢”的对象有什么性质呢？我们发现他周围**没有叶子节点**，而 $3$ 号点周围存在叶子节点。所以自然地想到将周围没有叶子节点的点成为“好节点”，其他节点成为“坏节点”。

特别地，我们认为叶子节点既不是好节点，也不是坏节点。

考虑如果一个好节点和一个坏节点挨着会发生什么事：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ggvehyk.png)

考虑先拆除以 $u$ 为中心，包含两个叶子的菊花，此时剩下了一个 $v$ 的子树，是一种方案。

然后还有一种方案，也是先拆除以 $u$ 为中心，包含 $v$ 和两个叶子的菊花。因为 $v$ 是好节点，所以 $w_1,w_2,w_3$ 的大小至少为 $2$，也一定存在一种拆分其他子树的方案。

这样就出现了矛盾。这也就是说，好节点和坏节点不能~~贴贴~~挨在一起，但是一个图里肯定是存在坏节点的，于是我们得到了一个重要结论：

**合法的图中不存在好节点**

那不存在好节点的图一定合法吗？确实是的。考虑删除最外层的一圈叶子，则剩下的每个节点都不能作为菊花图的叶子节点，所以仅存在一种拆分方案：以剩下的每个点为中心，和它周围的儿子一起拆分出来。

这样我们就解决了树的部分。对于图，仿照以上的分析过程，将“好节点”的定义改为周围不存在度数为 $1$ 的节点即可。

当然，单个三元环也是合法的，这是唯一的例外情况，特判一下即可。

我们终于刻画完了条件，剩下的计数就简单了。

我们发现，外面的叶子和中间的“骨架”其实互不干扰，所以可以分开计算。设 $f_n$ 表示 $n$ 个有标号节点组成的“骨架”的方案数，则答案为：

$$\mathrm{ans}_n=\sum_{m=1}^n \binom n m {m\brace n-m} (n-m)!f_{n-m}$$

其中 $n\brace m$ 表示第二类斯特林数。

发现 $f$ 其实就是有标号无根树计数和有标号连通图计数，套公式或者 $O(n^2)$ 递推即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int N=5009;

int mod,typ;
int ksm(int x,int y){int z=1;for(;y;x=1ll*x*x%mod,y>>=1) if(y&1) z=1ll*z*x%mod;return z;}
int S[N][N],C[N][N];
int f[N];
int pw[N*N],fac[N];
int ans[N];

signed main()
{
	int T;
	scanf("%d%d%d",&T,&mod,&typ);
	
	int lim=5000;
	S[0][0]=1;
	for(int i=1;i<=lim;i++)
	for(int j=1;j<=i;j++)
	S[i][j]=(S[i-1][j-1]+1ll*S[i-1][j]*j)%mod;
	for(int i=0;i<=lim;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	fac[0]=1;
	for(int i=1;i<=lim;i++) fac[i]=1ll*fac[i-1]*i%mod;
	
	if(typ==0)
	{
		f[1]=1;
		for(int i=2;i<=lim;i++) f[i]=ksm(i,i-2);
		ans[1]=0,ans[2]=1,ans[3]=3;
	}
	else
	{
		f[1]=1;
		pw[0]=1;
		ans[1]=0,ans[2]=1,ans[3]=4;
		for(int i=1;i<=lim*lim;i++) pw[i]=2ll*pw[i-1]%mod;
		for(int i=2;i<=lim;i++)
		{
			f[i]=pw[i*(i-1)/2];
			for(int j=1;j<i;j++) f[i]=(f[i]+mod-1ll*f[i-j]*C[i-1][j]%mod*pw[j*(j-1)/2]%mod)%mod;
		}
	}
	
	for(int i=4;i<=lim;i++)
	{
		for(int j=1;j<i;j++)
		ans[i]=(ans[i]+1ll*C[i][j]*S[j][i-j]%mod*fac[i-j]%mod*f[i-j]%mod)%mod;
	}
	
	while(T--)
	{
		int x;
		scanf("%d",&x);
		printf("%d\n",ans[x]%mod);
	}
}
```

---

## 作者：xieziheng (赞：3)

本题就是十分优雅而美好的。

先考虑树的情况，随便画画会发现等价于不存一个点不和叶子相邻，证明应该比较显然。

下面假设 $n\geq 4$

那么枚举有多少个叶子，假设有 $b$ 个，剩下 $a$ 个不是叶子的构成一个树，而这 $b$ 个要分给这 $a$ 个，所以方案为 ${b\brace a}a!a^{a-2}$。直接暴力预处理暴力算就行。

再考虑连通图，发现把内部 $a$ 个点方案换成连通图数量即可，这个是经典题（P4841），暴力递推即可。

复杂度 $\mathcal{O}(n^2)$。

---

## 作者：_Cheems (赞：1)

题意：求有多少个 $n$ 个点的有标号无向图，满足：为树（$t=0$）、为图（$t=1$）；存在唯一的划分方案，组内点数 $\ge 2$ 且连通且直径 $\le 2$。$n\le 5\times 10^3$。

先考虑合法条件。
#### 树
从一些浅显的性质入手：度为 $1$ 的点必然和其连向的点在一组。

假如删掉这些点后不存在其他点了显然合法，大胆猜测一下，若存在其他点就非法。

考虑剩下的连通块：对于单点，至少两个相邻节点被删，将其连向其一皆可；否则，考虑该子树的叶子（至少两个），内部必然存在一种划分，然后将其中一个叶子连向相邻的被删的节点，除非只剩一个点了不然肯定可行，但是这一个点也是叶子所以连向相邻节点即可。所以有多种方案，非法。
#### 图
直接套树的结论，基本成立。

具体来说，除不存在叶子或者只有一个叶子的情况外均可套用证明。

对于前者，当点数 $\ge 4$ 时一定有一棵生成树非法；对于后者点数 $\ge 4$ 也不存在问题。

综上所述，只需特判 $n\le 3$ 的情况，然后随便算算组合数即可。预处理组合数，即可 $O(n)$ 回答。

---

## 作者：sbno333 (赞：1)

感觉题目出的不好，套路难度远大于思维难度。

考虑一个图紧密的其实就是一个菊花，上头加点边，但题目考虑点集，所以加的边不重要。

我们首先考虑简单的情况，也就是树。

我们尝试证明树大小大于 $1$ 时一定可以划分。

对于树大小 $n$，$n=2$ 或者 $n=3$ 时显然。

当 $n>3$ 时，我们尝试找到一条边，满足这条边删去后形成的两个树一定都不是一个节点的。

假设不存在这样的边，则一端一定是叶子，另一端如果也是叶子那就是 $n=2$，如果不是叶子就再找一条相邻的边，这时候那段必须是叶子，和原边恰好构成长为 $3$ 的链，当然可能有很多这样的边，最后构成一个菊花，可以划分成紧密的（所有点集放到一个集合）。

如果存在，删除边，两棵小点的树若成立，则整棵树成立，边界条件成立，故数学归纳法得证！

考虑唯一划分可以类似的办法，找到一个点，这个点满足没有与其相连的叶子且这个店不是叶子时，可以只留一条边剩下断掉，让这个节点作为叶子，必须与连得那一处在一个集合，然后和其他树的节点不在一个集合，有很多留边选择，这个点也会换集合，此时一定这种树不是好的。

我们讨论剩下的情况，每个节点一定有相连的叶子或作为叶子。

叶子必须和相连的点在一个集合。

而非叶子不能和非叶子在一个集合，因为这样两个非叶子的叶子距离大于 $2$。

此时发现方案唯一确定了（叶子和相连非叶子在一个集合，非叶子只和相连的全部叶子在一个集合）。

于是好的树转化成了每个节点要么是叶子，要么与叶子相连。

数据范围不大。

枚举叶子个数，设为 $a$，非叶子个数为 $n-a=b$。

然后每一个都累计和。

考虑单个的，首先叶子的集合有 $n\choose a$。

其次，对于非叶子，他们可以组合成任何树，但是每个节点上必须插叶子，对于前一个，贡献 $b^{b-2}$。

然后对于后一个，抽象问题，$a$ 个小球放到 $b$ 个盒子里，都带标号，盒子必须有球，球必须放盒子，求方案数。

容斥，考虑总体减去存在盒子没球！

就是 $\sum\limits_{i=0}^b{b\choose i}(b-i)^a(-1)^i$。

然后我们计算这个是 $10^6$ 级别的 $a,b$ 是 $10^3$ 级别的。

聪明人已经发现是斯特林数了。

当然，得到原式等于 $b!\times S(a,b)$，其中 $S(x,y)$ 是第二类斯特林数。

预处理即可（由于模数，所以使用递推式预处理）。

然后就是 ${n\choose a}\times b^{b-2}b!\times S(a,b)$。

考虑图，发现就是带点返祖边，叶子不能反祖，否则叶子换集合，除非换完集合后原先的父亲变成新父亲的叶子，新父亲原来是旧父亲的叶子，证得 $n=3$，特判即可。

于是就是树，但是非叶子节点不是组成树的方案数，而是组成简单联通图的方案数，这个也是模板。

代码的 $a,b$ 与题解中的 $a,b$ 定义相反。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int mod;
int t;
int ksm(int a,int b){
	int ans;
	ans=1;
	while(b){
		if(b&1){
			ans*=a;
			ans%=mod;
		}
		a*=a;
		a%=mod;
		b>>=1;
	}
	return ans;
}
int tr[5009];//n节点组成树的方案数
int c[5009][5009];
int tu[3009];//n节点组成图的方案数
int s[5009][3009];
int jc[3009];
void _main(){
	int n;
	cin>>n;
	if(n==1){
		cout<<0<<endl;
	}else if(n==2){
		cout<<1%mod<<endl;
	}else{
		if(n==3&&t==1){
			cout<<4%mod<<endl;
			return;
		}
		int ans;
		ans=0;
		for(int a=1;a<=n/2;a++){
			int b;
			b=n-a;
			ans+=c[n][a]*jc[a]%mod*s[b][a]%mod*(t?tu[a]:tr[a])%mod;
			ans%=mod;
		}
		cout<<ans<<endl;
	}
}
signed main(){
	int T;
	cin>>T>>mod>>t;
	tr[1]=1;
	jc[0]=jc[1]=1;
	for(int i=2;i<=3000;i++){
		tr[i]=ksm(i,i-2);
		jc[i]=jc[i-1]*i%mod;
	}
	c[0][0]=1%mod;
	for(int i=1;i<=5000;i++){
		c[i][0]=1%mod;
		for(int j=1;j<=i;j++){
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
		}
	}
	tu[1]=1;
	for(int i=2;i<=3000;i++){
		tu[i]=ksm(2%mod,c[i][2]);
		for(int j=1;j<i;j++){
			tu[i]-=c[i-1][j-1]*tu[j]%mod*ksm(2%mod,c[i-j][2])%mod;
			tu[i]+=mod;
			tu[i]%=mod;
		}
	}
	for(int i=0;i<=5000;i++){
		for(int j=0;j<=3000;j++){
			if(i==0&&j==0){
				s[i][j]=1;
			}else if(i!=0&&j!=0){
				s[i][j]=s[i-1][j-1]+j*s[i-1][j];
				s[i][j]%=mod;
			}
		}
	}
	while(T--){
		_main();
	}
	return 0;
}
```

---

## 作者：DengStar (赞：0)

> 在 [博客园](https://www.cnblogs.com/dengstar/p/18758002) 中查看

**先找到一种简洁的方式刻画“好的”图**，因为简洁有利于我们找到问题的本质。

题目中说一个“好的”图**恰好**有一种划分方式，这包含了两个信息：划分方式的**存在性**和**唯一性**。我们分别考虑这两点。由于树的情况比较简单，所以先研究树的情况，再扩展到一般的无向连通图。

首先，可以证明：$n \ge 2$ 时，任意树都存在划分方式。

用归纳法证明。当 $n = 2$ 时，整棵树可以划分成一个紧密的连通块。假设 $n \le k$ 时成立，接下来要证明当 $n = k + 1$ 时也成立。任取树上的一个叶子节点 $v$，设与它唯一相连的节点为 $u$。删去 $u$，树分裂为若干个连通块。对于大小不小于 $2$ 的连通块，根据归纳假设，这些连通块都存在划分方式。对于大小为 $1$ 的连通块（即孤点），可以把它们和 $u$ 划分到一个连通块中。由于这个连通块至少包含两个节点（$u$ 和 $v$），所以它也存在划分方式。证毕。

这个结论容易扩展到任意无向连通图：$n \ge 2$ 时，任意无向连通图都存在划分方式。任取连通图的一棵生成树，忽略非树边，根据上文的结论，这棵生成树存在划分方式。加上非树边，不影响划分方式的存在性。（具体而言，对于生成树的一个划分方式，如果非树边连接了两个连通块，那么完全不影响；如果非树边的两端在一个连通块内，只可能让该连通块的直径变小，仍然不影响。）

接下来探讨什么样的树只有唯一一种划分方式。这里比较巧妙的想法是：考虑一个不与叶子节点相邻的节点 $u$（如果存在）。删去 $u$，树分裂为若干个连通块。由于 $u$ 不与叶子节点相邻，所以所有分裂出的连通块的大小都不小于 $2$。因此，把 $u$ 分到任意一个连通块中，都存在划分方式，而且把 $u$ 划分到不同连通块得到的划分方式显然不同，这就不满足唯一性。所以我们得到了划分方式唯一的必要条件：所有非叶节点都与至少一个叶子节点相邻。（可以视为有一棵树作为“骨架”，骨架上的每一个点都悬挂着至少一个点）

我们还可以证明这实际上也是充分条件。对于每个叶子节点，它都必须和它唯一相邻的节点划分到一个连通块中。而如果把骨架上的两个点分到一起，它们相连的叶子节点间的距离就为 $3$，违反了限制，所以这是不合法的。因此唯一合法的划分方式就是：把骨架上的节点和与它相连的叶子节点划分为一个连通块。

这个结论能扩展到任意的连通图吗？

不妨定义一般连通图上的叶子节点为度数为 $1$ 的点。考虑图中一个不与叶子节点相邻的节点 $u$，删去 $u$ 之后，如果图分裂之后不连通，那么根据在树情况下的讨论，划分方式就不唯一。

否则删去 $u$ 之后图仍然连通。由于 $u$ 不是叶子节点，所以 $u$ 至少和连通块中的两个点相邻。那么 $u$ 与这两个点之间的边和连通块中两点的路径构成一个环，于是整个图可以看作一个环往外挂了若干个连通块。如果存在一个节点，它外挂的连通块的大小都不小于 $2$，那么删去这个点，就变成了每个连通块大小都不小于 $2$ 的情况，有多个划分方式。否则忽略所有外挂的大小不小于 $2$ 的连通块，则整个图可以视为一个环外挂若干个（可能是 $0$ 个）叶子节点。由于 $u$ 不与任何叶子节点相邻，所以把 $u$ 和与其相邻的两个节点中的任意一个划分到一起都可行。需要注意的是如果 $n = 3$ 且图是一个三元环，这个讨论不成立，此时只有唯一一种划分方式，就是把整个图划分为一个连通块，所以要特判这种情况。

综上所述，我们证明了，对于一般的无向连通图，划分方式唯一的必要条件是不存在不与叶子节点相邻的节点。充分性容易仿照树的情况证明。

现在我们终于找到了一种简洁的方式来刻画好的图，下面来列式计算方案数。

对于 $n$ 个点的图，枚举叶子节点的数量 $m$，则有 $\dbinom{n}{m}$ 种方式选择叶子节点。由于每个骨架节点都要与至少一个叶子节点相邻，所以要把 $m$ 个叶子节点划分成 $(n - m)$ 个非空子集。注意，这里的子集是有序的，所以方案数在第二类斯特林数的基础上还要乘上排列数，即 $\begin{Bmatrix} m \\ n - m \end{Bmatrix} \times (n - m)!$。最终还需要计算骨架节点连边的方案数，设 $n$ 个骨架节点连边的方案数为 $f(n)$。如果图是树，那么骨架节点也必需构成树，根据凯莱公式有 $f(n) = n^{n - 2}$。如果图是一般的连通图，则骨架节点也只需是连通图，此时 $f(n)$ 的计算是一个经典问题，详见 [此处](https://oi-wiki.org/math/combinatorics/graph-enumeration/#%E6%9C%89%E6%A0%87%E5%8F%B7%E8%BF%9E%E9%80%9A%E5%9B%BE)。

最终我们得到：
$$
\operatorname{ans}_{n} = \sum_{m = 1}^{n - 1} \dbinom{n}{m} \times \begin{Bmatrix} m \\ n - m \end{Bmatrix} \times (n - m)! \times f(n - m)
$$
$O(n^{2})$ 时间预处理第二类斯特林数，然后就可以在 $O(n)$ 时间内回答每个询问。

---

## 作者：_lmh_ (赞：0)

先把 $n\le 3$ 的特殊情况判掉，这个直接去样例复制即可。

显然一个划分合法等价于其中存在一个点和所有其他点之间都有边。

引理：大小 $>1$ 的连通图必定存在至少一种划分方案。

证明：如果这个连通图存在度数为 $1$ 的节点，则选择与其相邻的节点 $u$ 及 $u$ 所有度数为 $1$ 的邻居，将其删去之后，剩下的若干个连通块大小都 $>1$，归纳即可。

否则先特判掉三元环的情况，此时找出图上所有点双连点分数，一定有方点只有至多一个度数 $>1$ 的相邻圆点。拉出这个点双，从那个度数 $>1$ 的点（如果没有则任选一个点）出发建 dfs 树，易证删掉任意一个最深的叶子到父亲的边都能保证图依然连通。

### $t=0$

随便找一个非叶子节点为根，然后发现叶子和它的父亲一定被划分在同一个连通块，把这些连通块删掉。

下证明如果剩下来还有节点，那么一定不满足条件。

任取一个剩下来的连通块，如果它是一个单点，那它的度数 $\ge 2$，而它相邻的任意一个被选出来的点集都能过来，显然方案不唯一。

否则，这个连通块本身就是一种方案，找到它的一个叶子，这个叶子一定有一个相邻的点集；用这个点集把它吞掉之后必定还有一种方案（易证），方案也不唯一。

这样统计答案就简单了，组合数选出非叶子节点，用 Cayley 公式算出这棵有标号无根树的方案数，然后用第二类斯特林数给剩下的节点定父亲即可。

### $t=1$

特判掉三元环以后，我们发现 $t=0$ 的性质依然有效，证明是类似的。

组合数选出非叶子节点，然后用第二类斯特林数给剩下的节点定父亲。

这里我们需要统计有标号无向连通图的个数，枚举第一个点所在连通块大小容斥即可。

时间复杂度 $O(n^2)$，注意实现不要使复杂度退化。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=5007;
ll p,T,n,MOD,ans[N],C[N][N],S[N][N],F[N],G[N],fac[N];
ll qpow(ll x,ll k){
	ll sum=1;
	while(k){
		if (k&1) (sum*=x)%=MOD;
		(x*=x)%=MOD;k>>=1;
	}
	return sum;
}
namespace A{
	void solve(){
		for (int i=3;i<N;++i){
			for (int j=1;j*2<=i;++j){
				(ans[i]+=C[i][j]*qpow(j,max(0,j-2))%MOD*fac[j]%MOD*S[i-j][j])%=MOD;
			}
		}
		while(T--){
			cin>>n;
			if (n<=2) cout<<(n-1)%MOD<<'\n';
			else cout<<ans[n]<<'\n';
		}
	}
}
namespace B{
	void solve(){
		ans[3]=1;
		F[1]=G[1]=1;
		for (int i=2;i<N;++i){
			F[i]=G[i]=qpow(2,i*(i-1)/2);
			for (int j=1;j<i;++j) (F[i]+=(MOD-F[j])*C[i-1][j-1]%MOD*G[i-j])%=MOD;
		}
		for (int i=3;i<N;++i){
			for (int j=1;j*2<=i;++j){
				(ans[i]+=C[i][j]*F[j]%MOD*fac[j]%MOD*S[i-j][j])%=MOD;
			}
		}
		while(T--){
			cin>>n;
			if (n<=2) cout<<(n-1)%MOD<<'\n';
			else cout<<ans[n]<<'\n';
		}
	}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T>>MOD>>p;
	if (MOD==1){
		while(T--) cout<<"0\n";return 0;
	}
	for (int i=0;i<N;++i) for (int j=C[i][0]=1;j<=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	for (int i=S[0][0]=1;i<N;++i) for (int j=1;j<=i;++j) S[i][j]=(S[i-1][j-1]+j*S[i-1][j])%MOD;
	for (int i=fac[0]=1;i<N;++i) fac[i]=fac[i-1]*i%MOD;
	if (p==0) A::solve();
	else B::solve();
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：0)

$t=0$ 注意到如果我们提前决定好要选啥连通块划分，那我们可以一层一层剥洋葱皮把一棵树剥掉。

我们要防止剥洋葱的某个时候可以有两种剥法，然后我们又要剥完。

那其实我们肯定可以剥完的对吗。所以任何一棵树都有至少一种剥法，图也同理。

因为我们剥洋葱剥的是一个菊花，所以如果菊花的叶子是和别的菊花连在一起的，那么我们显然可以把那个叶子不管剩下的剥掉这样就有两种剥法了。

所以 $t=0$ 时我们最后一定是树挂上一些点，树上的一个点必须挂一个点才行。

考虑图，你发现图虽然剥起来没那么优雅但是也是可以剥的，所以图的结论和树的一样，就是连通图上挂点的形式。

后面就是计数基操了。$n\le 3$ 要特判。

---


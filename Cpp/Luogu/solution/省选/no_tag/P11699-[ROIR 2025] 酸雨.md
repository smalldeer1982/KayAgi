# [ROIR 2025] 酸雨

## 题目背景

翻译自 [ROIR 2025 D1T3](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。

## 题目描述

有 $n$ 个模块被运送到金星上用于组装实验室。模块按顺序排列，第 $i$ 个模块的高度为 $h_i$。

组装工作将由一台特殊的机器人来完成。在组装过程中，连续的模块段将逐渐合并，而模块在排列中的顺序不会改变。最初，每个模块都是一个独立的段，段的编号从 $1$ 到 $n$，与模块的编号顺序相同。如果有两个相邻的模块段 $A = [i, i+1, \dots, i+p-1]$ 和 $B = [i+p, i+p+1, \dots, i+p+q-1]$，那么它们合并后变成段 $AB = [i, i+1, \dots, i+p-1, i+p, i+p+1, \dots, i+p+q-1]$。

组装指令由 $n-1$ 条指令组成。每条指令包含一个数字 $k_j$。执行该指令后，编号为 $k_j$ 和 $k_j + 1$ 的模块段合并为一个新段，合并后的段占据原来两个段的位置，并重新对段进行编号，从 $k_j + 2$ 开始，后面的段的编号依次减 $1$。执行完所有指令后，所有段将合并为一个段。

金星上常年下酸雨，因此在组装过程中，必须在每次合并后了解每个段中可能积累的液体量。设一个段包含高度为 $h_l, h_{l+1}, \dots, h_r$ 的模块。对于其中任意一个模块 $p$，其中 $l \leq p \leq r$，我们定义该模块 $p$ 在该段的深度 $d_p$ 如下：

首先计算左侧最大高度 $l_p = \max\{ h_l, h_{l+1}, \dots, h_p \}$ 和右侧最大高度 $r_p = \max\{ h_p, h_{p+1}, \dots, h_r \}$。这分别是该段中模块 $p$ 左侧和右侧的最大高度。该模块 $p$ 的深度定义为 $d_p = \min(l_p, r_p) - h_p$，显然 $d_p > 0$。段的容量定义为该段所有模块的深度之和，即 $w = d_l + d_{l+1} + \dots + d_r$。

给定一系列合并操作，请在每次合并后输出合并段的容量。

## 说明/提示

下图显示了样例中指令执行的过程，每个模块上方标出了其深度，并显示了新段的容量。

![](https://cdn.luogu.com.cn/upload/image_hosting/na9xfgva.png)

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

| 子任务 | 分数 | 特殊性质 |
| :------: | :----: | :--------: |
| $1$      | $13  $ | $n \leq 100$ |
| $2 $     | $13  $ | $n \leq 1000$ |
| $3  $    | $13  $ | $h_i \leq 10$ |
| $4  $    | $13  $ | $\exist i,h_1 \ge h_2 \ge \dots \ge h_i \leq \dots \leq h_n$ |
| $5  $    | $7  $  | 所有查询中 $k_j = 1$ |
| $6  $    | $13$   | $n \leq 40000$ |
| $7  $    | $28$   | 无 |

## 样例 #1

### 输入

```
8
9 1 8 1 5 2 3 6
3 3 1 3 3 2 1
```

### 输出

```
0
4
0
0
0
13
20```

# 题解

## 作者：FFTotoro (赞：3)

先拆式子，由于 $\max\{l_i,r_i\}=\max\limits_{j=l}^r h_j$（即为 $i$ 所在连通块 $[l,r]$ 内的最大高度，记为 $\mathrm{mx}_i$），所以答案为 $\sum\min\{l_i,r_i\}-h_i=\sum l_i+r_i-\max\{l_i,r_i\}-h_i=\sum l_i+\sum r_i-\sum h_i-\sum\mathrm{mx}_i$。只需要对于这四个值分别维护。

$\sum h_i$ 直接计算，$\sum\mathrm{mx}_i$ 可以在合并连通块 $x,y$ 时，考虑将 $\mathrm{mx}_x$ 与 $\mathrm{mx}_y$ 中的较小值增大到较大值的贡献即可。对于 $\sum l_i$ 的维护（$\sum r_i$ 同理），注意到 $l_i$ 的值在操作过程中是递增的，所以将 $i$ 的贡献挂在 $l_i$ 对应的位置 $j$ 上（即某个 $j$ 使得 $h_j=l_i$），于是我们只需维护这些 $j$；合并两个连通块时，考虑靠左的连通块的 $h$ 最大值，将靠右的连通块中 $h_j$ 小于等于该最大值的 $j$ 的贡献转移到最大值上。这些过程都可以使用启发式合并维护。更多细节参考代码；代码中将连通块的信息挂在左端点上。

为了方便找到编号为 $k$ 的区间，使用 `__gnu_pbds::tree` 来维护当前的所有连通块。

时间复杂度 $O(n\log n)$。

放代码：

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define int long long
using namespace std;
using namespace __gnu_pbds;
typedef pair<int,int> pii;
tree<pii,null_type,less<>,rb_tree_tag,tree_order_statistics_node_update> t;
main(){
  ios::sync_with_stdio(false);
  int n; cin>>n;
  vector<int> h(n),cl(n,1),cr(n,1),mx(n),s(n);
  vector<set<pii> > sl(n),sr(n);
  iota(mx.begin(),mx.end(),0);
  for(auto &i:h)cin>>i;
  for(int i=0;i<n;i++){
    t.insert(make_pair(i,i));
    sl[i].emplace(h[i],i),sr[i].emplace(h[i],i);
  } // 一些预处理
  for(int i=1;i<n;i++){
    int x; cin>>x,x--;
    auto p=t.find_by_order(x);
    auto [l1,r1]=*p; auto [l2,r2]=*next(p);
    s[l1]+=s[l2];
    while(!sl[l2].empty()){
      if(int x=sl[l2].begin()->second;h[mx[l1]]>h[x])
        s[l1]+=cl[x]*(h[mx[l1]]-h[x]),cl[mx[l1]]+=cl[x],cl[x]=0,sl[l2].erase(sl[l2].begin());
      else break;
    } // 维护 sum l[i]
    while(!sr[l1].empty()){
      if(int x=sr[l1].begin()->second;h[mx[l2]]>h[x])
        s[l1]+=cr[x]*(h[mx[l2]]-h[x]),cr[mx[l2]]+=cr[x],cr[x]=0,sr[l1].erase(sr[l1].begin());
      else break;
    } // 维护 sum r[i]
    if(sl[l1].size()<sl[l2].size())swap(sl[l1],sl[l2]);
    if(sr[l1].size()<sr[l2].size())swap(sr[l1],sr[l2]);
    sl[l1].merge(sl[l2]),sr[l1].merge(sr[l2]);
    // 合并信息
    if(h[mx[l2]]<h[mx[l1]])s[l1]-=(r2-l2+1)*(h[mx[l1]]-h[mx[l2]]);
    else s[l1]-=(r1-l1+1)*(h[mx[l2]]-h[mx[l1]]),mx[l1]=mx[l2];
    // 维护 sum mx[i]
    t.erase(p=t.erase(p)),t.insert(make_pair(l1,r2));
    cout<<s[l1]<<'\n';
  }
  return 0;
}
```

---

## 作者：MaxFwl (赞：2)

先考虑如何找出每次合并的两个段，发现问题等价于维护一个有序的集合，支持插入、删除、查询第 $k$ 大元素，容易想到平衡树 (pbds) 或权值线段树。

接下来考虑计算答案，题目给出的形式并不好算，考虑转化为 $l_p + r_p - \max(l_p, r_p) - h_p$，显然 $\max(l_p, r_p)$ 为该段最大值，预处理 ST 表后可以 $O(1)$ 查询，$-h_p$ 的部分可以用前缀和维护，接下来考虑如何维护 $l_p$ 和 $r_p$。

容易发现，两个段合并时，右边的段的 $h_p$ 最大值会对左边的段的所有点 $p$ 的 $l_p$ 有贡献，左边的段的 $h_p$ 最大值会对右边的段的所有点 $p$ 的 $r_p$ 有贡献。

我们发现现在需要一种数据结构，支持区间最值操作、查询区间和，这是经典问题，容易解决。

给出 [code](https://www.luogu.com.cn/paste/7ahybuck)，时间复杂度 $O(n \log{n})$。

事实上，由于 $l$ 数组，$r$ 数组都具有单调性，我们发现每次修改的区间是连续的，可以在线段树上二分求出要修改的区间，现在我们只需要支持区间赋值、查询区间和操作，普通的线段树就可以解决。

虽然时间复杂度依旧为 $O(n \log{n})$，但是代码更加简洁优美，常数因子更小，运行效率得到一定提升。

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P11699)

**题目大意**

> 给定 $a_1\sim a_n$，初始有 $n$ 个区间 $[1,1]\sim [n,n]$，每次合并两个相邻区间，对每个区间 $[l,r]$ 计算 $\sum_{i=l}^r\min(\max a[l,i],\max a[i,r])-a_i$。
>
> 数据范围：$n\le 10^5$。

**思路分析**

先维护出所有询问的 $[l,r]$，设最大值的下标是 $x$，那么 $i<x$ 时贡献是 $\max a[l,i]-a_i$，否则是 $\max a[i,r]-a_i$。

那么我们要维护的就是 $[l,x-1]$ 的每个前缀最大值之和，以及 $[x+1,r]$ 的每个后缀最大值之和。

离线扫描线，单调栈配合树状数组维护。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e5+5;
int n,a[MAXN],tl[MAXN],mx[MAXN];
ll sum[MAXN],ans[MAXN];
struct BIT1 {
	int tr[MAXN];
	void add(int x,int v) { for(;x<=n;x+=x&-x) tr[x]+=v; }
	int qry(int k) {
		int s=0,c=0;
		for(int i=16;~i;--i) if(s+(1<<i)<=n&&c+tr[s+(1<<i)]<k) s+=1<<i,c+=tr[s];
		return s+1;
	}
}	S;
struct BIT2 {
	ll t1[MAXN],t2[MAXN];
	void init() { memset(t1,0,sizeof(t1)),memset(t2,0,sizeof(t2)); }
	void add(int x,ll v) {
		for(int i=x;i<=n;i+=i&-i) t1[i]+=v,t2[i]+=v*x;
	}
	void add(int l,int r,ll v) {
		if(v) add(l,v),add(r+1,-v);
	}
	ll qry(int x) {
		ll s1=0,s2=0;
		for(int i=x;i;i&=i-1) s1+=t1[i],s2+=t2[i];
		return s1*(x+1)-s2;
	}
	ll qry(int l,int r) { return l<=r?qry(r)-qry(l-1):0; }
}	T;
vector <array<int,2>> ql[MAXN],qr[MAXN];
int st[MAXN],tp;
signed main() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]),sum[i]=sum[i-1]+a[i],S.add(i,1),tl[i]=mx[i]=i;
	for(int i=1,x;i<n;++i) {
		scanf("%d",&x);
		int p=S.qry(x),q=tl[p]+1;
		mx[p]=(a[mx[p]]>a[mx[q]]?mx[p]:mx[q]);
		tl[p]=tl[q],S.add(q,-1);
		int l=p,r=tl[p],z=mx[p];
		ans[i]-=sum[r]-sum[l-1]-a[z];
		if(l<z) qr[l].push_back({z-1,i});
		if(z<r) ql[r].push_back({z+1,i});
	}
	T.init(),st[tp=0]=0;
	for(int i=1;i<=n;++i) {
		for(;tp&&a[st[tp]]<=a[i];--tp) T.add(st[tp-1]+1,st[tp],-a[st[tp]]);
		T.add(st[tp]+1,i,a[i]),st[++tp]=i;
		for(auto o:ql[i]) ans[o[1]]+=T.qry(o[0],i);
	}
	T.init(),st[tp=0]=n+1;
	for(int i=n;i>=1;--i) {
		for(;tp&&a[st[tp]]<=a[i];--tp) T.add(st[tp],st[tp-1]-1,-a[st[tp]]);
		T.add(i,st[tp]-1,a[i]),st[++tp]=i;
		for(auto o:qr[i]) ans[o[1]]+=T.qry(i,o[0]);
	}
	for(int i=1;i<n;++i) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：_lmh_ (赞：0)

对每一段维护一个从左到右递增的单调栈和一个从右到左递增的单调栈，合并的时候推平中间凹下去的部分即可。

用链表维护这个单调栈，把每一段的长度和高度挂在最高的那个节点上面。每次根据排名查询对应段编号可以用树状数组。

注意单调栈相邻两个位置高度不能相等。时间复杂度 $O(n\log n)$。

建议降蓝。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=100007;
ll n,a[N],len[N],nxt[N],pre[N],ans[N],cnt[N];
void add(int x,int v){
	while(x<N){
		cnt[x]+=v;x+=x&-x;
	}
}
ll get(ll k){
	ll x=0;
	for (int i=16;~i;--i) if (x+(1<<i)<N&&k>cnt[x+(1<<i)]) k-=cnt[x+=(1<<i)];
	return x+1;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for (int i=1;i<=n;++i){
		cin>>a[i];len[i]=1;add(i,1);
		nxt[i]=i+1;pre[i]=i-1;
	}
	for (int x,i=1;i<n;++i){
		cin>>x;
		int l=get(x),r=get(x+1);
		if (a[l]>a[r]){
			add(r,-1);ans[l]+=ans[r];
			x=pre[r];
			while(a[x]<=a[r]){
				len[r]+=len[x];ans[l]+=len[x]*(a[r]-a[x]);x=pre[x];
			}
			nxt[x]=r;pre[r]=x;
			cout<<ans[l]<<'\n';
		}
		else{
			add(l,-1);ans[r]+=ans[l];
			x=nxt[l];
			while(a[x]<=a[l]&&x!=r){
				len[l]+=len[x];ans[r]+=len[x]*(a[l]-a[x]);x=nxt[x];
			}
			if (x==r&&a[l]==a[r]){
				len[r]+=len[l];
				pre[r]=pre[l];nxt[pre[l]]=r;
			}
			else{pre[x]=l;nxt[l]=x;}
			cout<<ans[r]<<'\n';
		}
	}
	return 0;
}
```

---


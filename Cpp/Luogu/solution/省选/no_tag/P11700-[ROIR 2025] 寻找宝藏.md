# [ROIR 2025] 寻找宝藏

## 题目背景

翻译自 [ROIR 2025 D1T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。

## 题目描述

为了寻找有用的矿产资源，科学家们开发了一种特殊的扫描仪。

假设搜索区域是一个包含 $k$ 行和 $n$ 列的表格。行号从上到下编号为 $1$ 到 $k$，列号从左到右编号为 $1$ 到 $n$。每个单元格中可能含有矿产资源。  

扫描仪的工作原理如下：它可以从第 $p$ 列启动，并返回扫描区域内包含矿产资源的单元格数。扫描区域包括第 $p$ 列的所有单元格、第 $p-1$ 列的前 $k-1$ 个单元格、第 $p-2$ 列的前 $k-2$ 个单元格，以此类推。下图展示了当 $k=3$，$n=5$ 时，所有可能的 $p$ 值的扫描区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/91a4kisv.png)

现在，给定扫描仪返回的每个 $p$ 值的结果，记为 $b_p$，即在第 $p$ 列的扫描区域内，矿产资源的数量。如果一个表格的矿产资源分布能匹配扫描仪的返回值，则称这个表格是“合法的”。比如，若扫描仪返回值为 $[2, 1, 2, 3, 2]$，则其中一个合法的表格可能如下所示（含有矿产的单元格用黑色三角形表示）：

![](https://cdn.luogu.com.cn/upload/image_hosting/yez7rrpa.png)

你需要根据给定的扫描结果，确定合法表格的数量，并输出其对 $10^9 + 7$ 取模的结果。注意，扫描仪可能存在故障，导致没有任何合法的表格，这种情况下应输出 $0$。

## 说明/提示

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。


| 子任务 | 分数 | 特殊性质 |
|:--------:|:------:|:----------:|
| $1$      | $7   $ | $k \leq 2$ | 第一子任务 |
| $2 $     | $9    $| $k \leq 3$ | 第一、二子任务 |
| $3  $    | $9   $ | $k \leq 4$ | 第一、二、三子任务 |
| $4  $    | $20  $ | $k \leq 5$ | 第一至四子任务 |
| $5  $    | $15 $  | $k \leq 6$ | 第一至五子任务 |
| $6  $    | $10 $  | $1 \leq n \cdot k \leq 25$ | 第一至五子任务 |
| $7$      | $30$   | 无 | 第一至六子任务 |

## 样例 #1

### 输入

```
5 3
2 1 2 3 2
```

### 输出

```
24```

# 题解

## 作者：xiazha (赞：2)

dp，通过简单观察，发现考虑第 $i$ 列统计方案数时，只需知道如图画的那几条线就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/zusxr53e.png)

并且这样转移是方便的，对于第 $i$ 列，我们只需记录红颜色方框内的状态并且在转移至 $i+1$ 时状压枚举 $i+1$ 那一列就行了，因此我们可以直接设出一个 $k$ 维 dp，由于定义太长，不做阐述，这个时候你可能想法是直接分 $k=1,2,\cdots,7$ 这几种情况写代码，但是麻烦了，你可以就设一个 $7$ 维 dp 数组，转移时保持后 $\min(6-k,0)$ 维是 $0$ 就行了，具体实现见代码。

时间复杂度 $O(nk 2^kk!)$。（目前为最优解 rk1）


```
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007
int n,k,a[202],dp[202][7][6][5][4][3][2],ans;
signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	dp[0][0][0][0][0][0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j1=0;j1<=min(6,a[i])*(k>=7);j1++)
			for(int j2=0;j2<=min(5,a[i]-j1)*(k>=6);j2++)
				for(int j3=0;j3<=min(4,a[i]-j1-j2)*(k>=5);j3++)
					for(int j4=0;j4<=min(3,a[i]-j1-j2-j3)*(k>=4);j4++)
						for(int j5=0;j5<=min(2,a[i]-j1-j2-j3-j4)*(k>=3);j5++)
							for(int j6=0;j6<=min(1,a[i]-j1-j2-j3-j4-j5)*(k>=2);j6++)
							{
								for(int s=0;s<(1<<k);s++)
								{
									int f=__builtin_popcount(s);
									if(f+j1+j2+j3+j4+j5+j6!=a[i]) continue;
									int p1=j2+((s&(1<<5))!=0);p1*=(k>=7);
									int p2=j3+((s&(1<<4))!=0);p2*=(k>=6);
									int p3=j4+((s&(1<<3))!=0);p3*=(k>=5);
									int p4=j5+((s&(1<<2))!=0);p4*=(k>=4);
									int p5=j6+((s&(1<<1))!=0);p5*=(k>=3);
									int p6=((s&(1<<0))!=0);p6*=(k>=2);
									dp[i][p1][p2][p3][p4][p5][p6]=(dp[i][p1][p2][p3][p4][p5][p6]+dp[i-1][j1][j2][j3][j4][j5][j6])%mod;
									if(i==n) ans=(ans+dp[i-1][j1][j2][j3][j4][j5][j6])%mod;
								}
							}
	cout<<ans;
	return 0;
}
```

---

## 作者：TH911 (赞：1)

> [题目传送门](https://www.luogu.com.cn/problem/P11700)
>
> [也许更坏的阅读体验](https://www.cnblogs.com/TH911/p/-/P11700)

# 题意分析

本文中记 $x_i$ 为第 $i$ 列的扫描结果，即 $x_i$ 为原题中 $b_i$。同时，以下推导均不考虑取模。

## DP 状态设计

注意到 $k\leq7$，因此考虑与 $k$ 有关的**涉及状压的 DP**。

![](https://cdn.luogu.com.cn/upload/image_hosting/v2pg020w.png)

如图，扫描仪的扫描区域其实就可以视作一个类似于三角形的区域在图上向右滑动。而第 $i$ 列的扫描结果与第 $i-1$ 列的扫描结果的差异就源于图中红色、绿色、蓝色等部分的**斜线**。因此可以考虑针对这些斜线设计 DP 状态。

设 $\textit{dp}_{i,j_1,j_2,\cdots,j_{k-1}}$ 表示处理第 $i$ 列，$1\sim i$ 列均合法，且从外往内数第 $l$ 层斜线的矿产数量为 $j_l$ 时（不包括只有一个点的那条斜线，那会**被包含到第 $i$ 列中特殊处理**）的合法表格数，也代表这一个扫描仪的状态。

## DP 状态转移

同样由于 $k\leq7$，因此可以 $\mathcal O\left(2^k\right)$ 枚举第 $i$ 列的矿产情况，记为 $S$。

记 $\operatorname{popcount}(S)$ 表示 $S$ 含有的矿产数量，即代码实现中 $S$ 的二进制位 $1$ 的数量。

假设 $\textit{dp}_{i-1,j_1,j_2,\cdots,j_{k-1}}$ 已知，考虑如何转移到当前 $S$ 对应的状态 $\textit{dp}_{i,j'_1,j'_2,\cdots,j'_{k-1}}$。

首先，当且仅当 $j_1+j_2+\cdots+j_{k-1}+\operatorname{popcount}(S)=x_i$ 时，$\textit{dp}_{i,j'_1,j'_2,\cdots,j'_{k-1}}$ 才可能从 $\textit{dp}_{i-1,j_1,j_2,\cdots,j_{k-1}}$ 转移，**否则不合法**。

记 $S_p$ 表示第 $p$ 行是否有矿产，即代码实现中 $S$ 的二进制第 $p-1$ 位。

以 $k=3$ 为例，$\textit{dp}_{i-1,j_1,j_2}$ 向右滑动，如图，最外层的 $j'_1$ 就变成了 $j_2+S_3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pdm4yusy.png)

推广到其他情况，都是类似的处理方式，假设 $k=7$，有：

$$
j'_1=j_2+S_7\\
j'_2=j_3+S_6\\
j'_3=j_4+S_5\\
j'_4=j_5+S_4\\
j'_5=j_6+S_3\\
j'_6=S_2\\
$$

这里的 $j'_6$ 即代表扫描仪区域右上角那一个大小为 $1\times1$ 的斜线，与 $i-1$ 的状态无关，因此无需放入 DP 状态。

记：

$$
A=\textit{dp}_{i,j'_1,j'_2,\cdots,j'_{k-1}}\\
B=\textit{dp}_{i,j_1,j_2,\cdots,j_{k-1}}
$$


则有：
$$
A\leftarrow A+B
$$

## 高维部分处理

但是，考虑到 $k=7$ 不一定成立，那么也许 DP 状态就会更改。

但是这其实不重要，既然高维是多余部分，不影响答案，那么久**集体取一个特殊值**即可。

例如令 $j'_1,j'_2,\cdots,j'_{k'}\in [k+1,7]$ 维部分的 $dp_{i,j_1,\cdots,j_{k-1},j'_1,\cdots,j'_{k'}}$，$j'_1=j'_2=\cdots=j'_{k'}=0$ 即可。

***

当然，你要是分 $7$ 种情况处理也是可以的。~~模拟赛有人这么写，AC 了。~~

## 时间复杂度

直接枚举的复杂度是 $\mathcal O\left(nk^k2^k\right)$。

但是考虑到可以在循环枚举的时候就保证 $j_1+j_2+\cdots+j_l\leq x_i$，这样的话，枚举 $j_1,j_2,\cdots,j_{k-1}$ 的复杂度就降低到了 $\mathcal O(k!)$。

最终复杂度：$\mathcal O\left(nk!2^k\right)$。

其实还有一个 $\mathcal O\left(\log S\right)=\mathcal O(k)$ 求 $\operatorname{popcount}(S)$ 的复杂度没算，但是可以预处理或记忆化，所以不用算。

# AC 代码

如果你担心炸空间，可以将空间开成 $\mathcal O(nk!)$ 的，而不是 $\mathcal O\left(k^k\right)$。实际上，还可以使用滚动数组滚掉，因此最优空间复杂度为 $\mathcal O(k!)$。

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=200,K=7,B=(K+1)*K>>1,P=1e9+7;
int n,k,x[N+1];
int dp[2][K+1][K+1][K+1][K+1][K+1][K+1];
int popcount(int x){
	int ans=0;
	while(x){
		ans++;
		x^=x&-x;
	}
	return ans;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>x[i];
		if(x[i]>(k*(k+1)>>1)){
			cout<<'0'<<endl;
			return 0;
		}
	}
	bool mode;
	dp[mode][0][0][0][0][0][0]=1;
	int ans=0;
	for(int i=1;i<=n;i++){
		mode=!mode;
		memset(dp[mode],0,sizeof(dp[mode]));
		for(int a=0;!a||a<=min(6,x[i])&&k>=7;a++){
			for(int b=0;b<=min(5,x[i]-a)&&k>=6||!b;b++){
				for(int c=0;c<=min(4,x[i]-a-b)&&k>=5||!c;c++){
					for(int d=0;d<=min(3,x[i]-a-b-c)&&k>=4||!d;d++){
						for(int e=0;e<=min(2,x[i]-a-b-c-d)&&k>=3||!e;e++){
							for(int f=0;f<=min(1,x[i]-a-b-c-d-e)&&k>=2||!f;f++){
								for(int S=0;S<(1<<k);S++){
									int pl=popcount(S);
									if(pl+a+b+c+d+e+f!=x[i]){
										continue;
									}
									int pa=0,pb=0,pc=0,pd=0,pe=0,pf=0;
									if(k>=7){
										pa=b+(S>>5&1);
									}
									if(k>=6){
										pb=c+(S>>4&1);
									}
									if(k>=5){
										pc=d+(S>>3&1);
									}
									if(k>=4){
										pd=e+(S>>2&1);
									}
									if(k>=3){
										pe=f+(S>>1&1);
									}
									if(k>=2){
										pf=S&1;
									}
									int &A=dp[mode][pa][pb][pc][pd][pe][pf],&B=dp[!mode][a][b][c][d][e][f];
									A=(A+B)%P;
									if(i==n){
										ans=(ans+B)%P;
									} 
								}
							}
						}
					}
				}
			}
		}
	}
	cout<<ans<<'\n';
	return 0;
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：one_of_the_person (赞：0)

~~场上只想到 50pts 的做法，被巨佬们薄纱了。~~
## 思路
### 50pts
看到 $k\le7$ 首先可以想到状压，设 $dp_{i,j}$，$i$ 表示扫描仪的位置，$j$ 是一个 $\frac{k(k+1)}{2}$ 位的二进制数，表示在扫描范围内的情况。可以很快的得出转移方程 $dp_{i,j}=\sum_{k}dp_{i-1,k}$，枚举可能的新的一列直接更新，转移复杂度为 $O(2^k)$。总复杂度 $O(n2^{\frac{k(k+1)}{2}+k})$。
### 100pts
在 50pts 的 dp 中我们发现斜向的处理很麻烦，而每一斜条在仪器向前移动时会直接移除，所以在同一斜条上的 1 之间的顺序并不重要，于是我们考虑设 $dp_{i,a_1,a_2,a_3,a_4,a_5,a_6,a_7}$ 表示仪器在第 $i$ 列时第 $j$ 个斜条上有 $a_j$ 个 1，转移时枚举新的一列，设新的一列第 $s$ 行的值为 $b_s$，则让 $dp_{i+1,a_2+b_7,a_3+b_6,a_4+b_5,a_5+b_4,a_6+b_3,a_7+b_2,b_1}$ 加上 $dp_{i,a_1,a_2,a_3,a_4,a_5,a_6,a_7}$ 的值。注意在更新前要判断新的情况是否合法，总复杂度 $O(nk!2^k)$。
## AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 200
#define Mod 1000000007
using namespace std;
int n,k,dp[N+5][8][7][6][5][4][3][2],a[N+5],b1,b2,b3,b4,b5,b6,b7,ans;
int read(){
    int f=1,g=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while('0'<=ch&&ch<='9'){
        g=g*10+ch-'0';
        ch=getchar();
    }
    return f*g;
}
void print(int x){
    if(x<0){
        putchar('-');
        x*=-1;
    }
    if(x>9)print(x/10);
    putchar(x%10+'0');
    return;
}
int bcnt(int x){
	int cnt=0;
	while(x)cnt+=x&1,x>>=1ll;
	return cnt;
}
main(){
    n=read(),k=read();
    for(int i=1;i<=n;i++)a[i]=read();
    dp[0][0][0][0][0][0][0][0]=1;
    for(int i=0;i<n;i++)for(int a1=0;a1<=7;a1++)for(int a2=0;a2<=6;a2++)for(int a3=0;a3<=5;a3++)for(int a4=0;a4<=4;a4++)for(int a5=0;a5<=3;a5++)for(int a6=0;a6<=2;a6++)for(int a7=0;a7<=1;a7++){
        if(!dp[i][a1][a2][a3][a4][a5][a6][a7])continue;
        for(int j=0;j<=(1<<k)-1;j++){
            if(a2+a3+a4+a5+a6+a7+bcnt(j)!=a[i+1])continue;
            b1=j&1,b2=(j>>1)&1,b3=(j>>2)&1,b4=(j>>3)&1,b5=(j>>4)&1,b6=(j>>5)&1,b7=(j>>6)&1;
            dp[i+1][a2+b1][a3+b2][a4+b3][a5+b4][a6+b5][a7+b6][b7]=(dp[i+1][a2+b1][a3+b2][a4+b3][a5+b4][a6+b5][a7+b6][b7]+dp[i][a1][a2][a3][a4][a5][a6][a7])%Mod;
        }
    }
    for(int a1=0;a1<=7;a1++)for(int a2=0;a2<=6;a2++)for(int a3=0;a3<=5;a3++)for(int a4=0;a4<=4;a4++)for(int a5=0;a5<=3;a5++)for(int a6=0;a6<=2;a6++)for(int a7=0;a7<=1;a7++)ans=(ans+dp[n][a1][a2][a3][a4][a5][a6][a7])%Mod;
    print(ans);
    return 0;
}
```

---


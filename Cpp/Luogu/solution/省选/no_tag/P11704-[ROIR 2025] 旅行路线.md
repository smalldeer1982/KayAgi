# [ROIR 2025] 旅行路线

## 题目背景

翻译自 [ROIR 2025 D2T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。

## 题目描述

一群学生来到一座新城市游览，决定参观这里的名胜古迹。这座城市可以看作一个 $n \times m$ 的矩形网格，其中某些格子上有景点。

他们从格子 $(1, 1)$ 开始旅程，想要先到达格子 $(n, m)$，然后再返回起点。此外，城市中有 $k$ 个景点，位于格子 $(x_1, y_1), \dots, (x_k, y_k)$，他们一定要全部参观到。

![原题一个不明觉厉的配图](https://cdn.luogu.com.cn/upload/image_hosting/spktsj97.png)

他们可以花费一分钟从格子 $(a, b)$ 移动到与之相邻（即满足 $|a - c| + |b - d| = 1$）的格子 $(c, d)$。显然，完成整个路线至少需要 $2n + 2m - 4$ 分钟。

我们称一条路线为“有趣的”，如果它满足以下条件：

- 完成该路线所需的时间恰好是 $2n + 2m - 4$ 分钟；
- 路线中的每个格子最多经过一次；
- 路线必须经过所有包含景点的格子。

请帮助他们计算一共有多少条不同的有趣的路线。由于结果可能很大，只需要输出其对 $10^9 + 7$ 取模的结果。

## 说明/提示

下图展示了样例一中所有有趣的路线，其中带有星号的格子存在名胜古迹。

![](https://cdn.luogu.com.cn/upload/image_hosting/kzbt6reo.png)

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

|子任务|分数|特殊性质|
|:-:|:-:|:-:|
|$1$|$5$|$n=3$，$m, k \leq 100$|
|$2$|$9$|$n, m, k \leq 5$|
|$3$|$6$|$n, m, k \leq 8$|
|$4$|$17$|$n, m, k \leq 30$|
|$5$|$16$|$n, m, k \leq 100$|
|$6$|$8$|$k=0$|
|$7$|$11$|$k=1$|
|$8$|$12$|$k \leq 16$|
|$9$|$9$|$k \leq 100$|
|$10$|$7$|无|$

## 样例 #1

### 输入

```
3 4 2
2 2
2 3```

### 输出

```
6```

## 样例 #2

### 输入

```
3 4 3
3 1
2 3
1 4```

### 输出

```
0```

# 题解

## 作者：Egg_eating_master (赞：2)

题意：两条从 $(1,1)$ 到 $(n,m)$ 的路径除两个端点外不交，并且经过所有 $k$ 个关键点。求方案数。

首先这两条路径一定是一条从 $(2,1)$ 到 $(n,m-1)$，一条从 $(1,2)$ 到 $(n-1,m)$。

考虑不要求两条路径不交怎么做。我们 DP 即可，设 $dp_{i,j}$ （$i>j$）表示考虑了前 $i$ 个关键点，目前一条路径以 $i$ 结尾，另一条以 $j$ 结尾的方案数。转移是平凡的，可以做到 $O(k^2)$。

然后考虑减掉相交的方案数。我们钦定两条路径在第一次相交的位置“互换身份”，那么就变成了一条从 $(2,1)$ 到 $(n-1,m)$ 的路径，和一条从 $(1,2)$ 到 $(n,m-1)$ 的路径。对这个东西计数仍然可以使用上面的 DP。

注意需要特判 $(1,1)$ 或 $(n,m)$ 本身就是关键点的情况。

然后就做完了！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 2010, maxm = 2000005, mod = 1e9 + 7;
int n, m, k;
struct node {
    int x, y;
    bool operator < (const node &a) const {return x + y < a.x + a.y;}
} a[maxn];
int dp[maxn][maxn];
int fac[maxm], ifac[maxm];
int power(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return res;
}
void init(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;
    ifac[n] = power(fac[n], mod - 2);
    for (int i = n - 1; i >= 0; i--) ifac[i] = ifac[i + 1] * (i + 1) % mod;
}
int C(int n, int m) {
    if (m < 0 || m > n) return 0;
    return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}
int calc(int p, int q) {return C(a[q].x + a[q].y - a[p].x - a[p].y, a[q].x - a[p].x);}
int solve(int p, int q) {
    for (int i = 1; i <= k; i++)
        for (int j = 1; j <= k; j++)
            dp[i][j] = 0;
    dp[p][q] = 1;
    for (int i = 3; i <= k; i++) {
        for (int j = 1; j <= i - 2; j++) {
            dp[i - 1][i] = (dp[i - 1][i] + dp[i - 1][j] * calc(j, i)) % mod;
            dp[i][j] = (dp[i][j] + dp[i - 1][j] * calc(i - 1, i)) % mod;
            dp[i][i - 1] = (dp[i][i - 1] + dp[j][i - 1] * calc(j, i)) % mod;
            dp[j][i] = (dp[j][i] + dp[j][i - 1] * calc(i - 1, i)) % mod;
        }
    }
    return dp[k - 1][k];
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m >> k; init(n + m);
    a[1] = (node){2, 1}, a[2] = (node){1, 2};
    for (int i = 3; i <= k + 2; i++) {
        cin >> a[i].x >> a[i].y;
        if (a[i].x == 1 && a[i].y == 1) i--, k--;
        if (a[i].x == n && a[i].y == m) i--, k--;
    }
    a[k + 3] = (node){n, m - 1}, a[k + 4] = (node){n - 1, m};
    sort(a + 3, a + k + 3);
    k += 4;
    cout << (solve(1, 2) - solve(2, 1) + mod + mod) * 2 % mod << '\n';
    return 0;
}
```

---

## 作者：ChickyHas (赞：1)

HN 好题分享为数不多自己能会的题，来一发题解。

一个极其相似的题可以是 [CF348D](https://www.luogu.com.cn/problem/CF348D) 这道题和本题差不多。大题思路都是拆成 $(1,2),(2,1)$ 和 $(n-1,m),(n,m-1)$ 这样，然后容斥就是换一下配对方式。

不过 CF 那题是有点不能走，这题是有点必须走，怎么办呢？

我们换一种 dp 方式，把 $(1,2),(2,1),(n-1,m),(n,m-1)$ 也视作关键点，并且按走到的顺序 $(x+y)$ 来排序，就可以设 $f_{i,j}$ 为第一条路径走到 $i$，第二条路径走到 $j$。

转移如 $f_{i,i-1}=f_{i,i-1}+f_{i,j} \times Calc(i,j)$ 和 $f_{i,j}=f_{i,j}+f{i-1,j} \times Calc(i,i-1)$ 两个下标反过来是一样的。

$Calc(i,j)$ 为点 $i$ 到 $j$ 的路径，也就是横坐标差+纵坐标差选横坐标差的那个组合数啦。

---

## 作者：ran_qwq (赞：1)

前置知识：[LGV 引理](https://oi-wiki.org/graph/lgv/)。

先不要看作去 $(n,m)$ 然后回来，看作两个人 A 和 B 去 $(n,m)$ 然后路径不交。

根据 LGV 引理，答案就是 $(2,1)$ 走到 $(n,m-1)$，$(1,2)$ 走到 $(n-1,m)$ 方案数，减去 $(2,1)$ 走到 $(n-1,m)$，$(1,2)$ 走到 $(n,m-1)$ 方案数。

那么我们把路径不交的限制去掉了。

我们把景点中的 $(1,1)$ 和 $(n,m)$ 去掉，加入 $(1,2),(2,1),(n-1,m)$ 和 $(n,m-1)$ 并排序。

参观肯定是按照第一维从小到大，第二维从小到大顺序参观。如果我们按照顺序 dp，设 $f_{i,j}$ 为走完了 $1\sim\max(i,j)$ 的景点，A 在景点 $i$，B 在景点 $j$ 的方案数。令 $t=\max(i,j)+1$，有转移：

- A 参观 $t$，$f_{i,j}\cdot\binom{x_t-x_i+y_t-y_i}{x_t-x_i}\leftarrow f_{t,j}$。
- B 参观 $t$，$f_{i,j}\cdot\binom{x_t-x_j+y_t-y_j}{x_t-x_j}\leftarrow f_{i,t}$。

答案为 $(f_{k,l}-f_{l,k})\cdot2$，这里 $l$ 是 $(n-1,m)$ 的下标。乘 $2$ 是因为 A 和 B 可以互换。注意处理一下 $(1,2)$ 右边的点。

预处理组合数可做到 $O(n+k^2)$。

```cpp
int n,m,k,a[M],b[M],fc[N],ifc[N],f[M][M]; pii p[M]; set<pii> st; map<pii,int> mp;
il int c(int x,int y) {return x<0||y<0||x<y?0:vmul(fc[x],vmul(ifc[y],ifc[x-y]));}
il int gt(int x,int y) {return c(p[y].fir-p[x].fir+p[y].sec-p[x].sec,p[y].fir-p[x].fir);}
void QwQ() {
	n=rd(),m=rd(),k=rd();
	fc[0]=1;
	for(int i=1;i<=N-10;i++) fc[i]=vmul(fc[i-1],i);
	ifc[N-10]=qpow(fc[N-10],MOD-2);
	for(int i=N-11;~i;i--) ifc[i]=vmul(ifc[i+1],i+1);
	for(int i=1;i<=k;i++) {
		p[i]={rd(),rd()};
		if(p[i]==pii{1,1}||p[i]==pii{n,m}) i--,k--;
		else st.insert({p[i].fir,p[i].sec});	
	}
	auto ad=[&](pii t) {if(!st.count(t)) p[++k]=t;};
	ad({1,2}),ad({2,1}),ad({n-1,m}),ad({n,m-1}),sort(p+1,p+1+k);
	for(int i=1;i<=k;i++) mp[p[i]]=i; f[mp[{2,1}]][mp[{2,1}]-1]=1;
	for(int i=1;i<=k;i++) for(int j=1;j<=k;j++)
		cadd(f[max(i,j)+1][j],vmul(f[i][j],gt(i,max(i,j)+1))),cadd(f[i][max(i,j)+1],vmul(f[i][j],gt(j,max(i,j)+1)));
	wr(vmul(vsub(f[k][mp[{n-1,m}]],f[mp[{n-1,m}]][k]),2),"\n");
}
```

---


# 「o.OI R1」na12xy

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/ji39b9bm.png)

## 题目描述

给定一个 $n$ 个节点的树，点编号从 $1$ 到 $n$。

你有一个 $n$ 个点初始无边的图，点编号从 $1$ 到 $n$，以及一个初始均为 $0$ 的整数序列 $a_1,a_2,\cdots,a_{12}$。

你可以进行任意次操作，操作有如下两种类型：

- `1 x y`：把 $a_x$ 赋值为 $y$。需要保证在所有 `1` 操作中，$y$ 互不相同。
- `2 x y`：连接编号为 $a_x$ 与 $a_y$ 的点。需要保证两者均不为 $0$。

请你构造这棵树，不能有重边、自环。

## 说明/提示

**「数据范围」**

**本题采用捆绑测试与 Special Judge。**

对于所有测试数据，保证：

- $1 \leq n \leq 4 \times 10^5$。
- $1 \leq u,v \leq n$。

|子任务|$n \leq$|分值|
|:-:|:-:|:-:|
| $0$ | $2000$ | $33$ |
| $1$ | $4 \times 10^5$ | $67$ |

## 样例 #1

### 输入

```
3
1 2
1 3```

### 输出

```
5
1 1 1
1 2 2
2 1 2
1 12 3
2 12 1```

# 题解

## 作者：ForgotMe (赞：5)

破防了，写了一下午的乱搞，也不知道自己最后在写什么玩意，反正最后 sub1 tle 3 个点喜提 0 分！

如果你一上来就跟我一样考虑从剥叶子去做，那么基本上就做不出来了，甚至你会怀疑这题是否可做，怎么可能只用这么少的空位。

不如从一条链开始考虑，这是简单的，显然只需要两个空位就可以做。但是实际上链上的每个点可能会挂着若干个子树，假设这条链的顺序是 $u_1,u_2,...,u_k$，那么先给 $u_1$ 留一个空位放进去，然后使用某种策略先把 $u_1$ 挂着的所有子树给构建出来（显然一旦构建出来后，所占据的所有空位都可以释放出来），这是一个**子问题**，接着扫到 $u_2$ 时把 $u_1$ 和 $u_2$ 连起来，并将 $u_1$ 占着的空位释放出来，依次这么做，可以发现如果设 $F_n$ 表示大小为 $n$ 的的树所需的空位数量，那么 $F_n=F_{mx}+1$，其中 $mx$ 为链上挂着的子树大小最大值。

现在问题变为选出树的一条链，让 $mx$ 尽量的小。显然你可以选一条经过重心的链，从而让 $mx$ 为 $\dfrac{n}{2}$ 的级别，这样可以做到 $F_n=\log_2 n$，显然无法通过。实际上可以做到更优，考虑选出重心，以及其最大子树的儿子对应的重链，次大子树的儿子对应的重链，三段拼起来。设 $S_1,S_2,S_3$ 分别表示最大子树的大小，次大子树的大小，以及剩下子树大小的最大值。那么根据重儿子的性质以及重心的性质 $\dfrac{n}{2}>S_1>S_2>S_3$，$mx=\max(\dfrac{S_1}{2},\dfrac{S_2}{2},S_3)$。那么在最坏情况下 $S_1=S_2=S_3=\dfrac{n}{3}$，$mx=\frac{n}{3}$，得到 $F_n=\log_3 n$，可以通过此题。

代码就不放了，模拟上述思路即可。

---

## 作者：wukaichen888 (赞：3)

首先考虑链如何构造，两个空位交替赋值连边即可。

对于树，假如剖掉一条链，那么需要的空位应该是所有新树需要的空位的最大值加上一。

考虑关于树的大小剖链，每次选取重心，以及重心最大、次大子树的重链，以得到一条经过重心的链。

考虑树的大小的变化，发现当重心有三个大小相等子树时最劣，此时大小变为原来的 $\frac{1}{3}$，总共需要 $\lfloor\log_3\frac{2n+1}{5}\rfloor+2$ 个空位。

具体构造时当前链滚动连边，同时遍历子树，每个点向相邻上层点连边即可。

时间复杂度 $O(n\log n)$，常数类似点分治。

idea 来源：graphomata。

贡献 [_fewq](https://www.luogu.com.cn/user/819212) 与 [zfx_VeXl6](https://www.luogu.com.cn/user/555301) 提供的修改建议。

---

以下是数据生成器节选，加号表示数据组合，希望有帮助。

```cpp
if(T==1)  tree=rnd_tree(n,qwq::rand);
if(T==2)  tree=rnd_tree(n,qwq::lian);
if(T==3)  tree=rnd_tree(n,qwq::juhua);
if(T==4)  tree=rnd_tree(n,qwq::binary);
if(T==5)  tree=rnd_tree(n,qwq::binomial);
if(T==6)  tree=rnd_tree(n,qwq::maomaochong(20));
if(T==7)  tree=rnd_tree(n,qwq::maomaochong(60));
if(T==8)  tree=rnd_tree(n,qwq::AT_abc293_h);
if(T==9)  tree=rnd_tree(n,qwq::qujian(1,50));
if(T==10) tree=rnd_tree(n,qwq::qujian(1,2000));
if(T==11) tree=rnd_tree(n,qwq::qujian(50,50));
if(T==12) tree=rnd_tree(n,qwq::qujian(2000,2000));
if(T==13) tree=rnd_tree(n,qwq::qujian(45,50));
if(T==14) tree=rnd_tree(n,qwq::qujian(1950,2000));
if(T==15) tree=rnd_tree(n,qwq::na12xy);
if(T==16) tree=rnd_tree(n,qwq::buhuimingming1);//6+8
if(T==17) tree=rnd_tree(n,qwq::changpou(2));
if(T==18) tree=rnd_tree(n,qwq::changpou(4));
if(T==19) tree=rnd_tree(n,qwq::buhuimingming2);//16+18
if(T==20) tree=rnd_tree(n,qwq::buhuimingming3);//16+18
if(T==21) tree=rnd_tree(n,qwq::rand);
if(T==22) tree=rnd_tree(n,qwq::rand);
if(T==23) tree=rnd_tree(n,qwq::rand);
if(T==24) tree=rnd_tree(n,qwq::rand);
if(T==25) tree=rnd_tree(n,qwq::rand);
```

---


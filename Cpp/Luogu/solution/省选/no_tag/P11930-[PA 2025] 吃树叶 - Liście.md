# [PA 2025] 吃树叶 / Liście

## 题目背景

PA 2025 R5A.

**警告：滥用本题评测一次即可封号。**

[这里](https://www.luogu.com.cn/problem/U547677)提供了本题的部分测试点（你可以在**附件**中下载它们），**强烈建议上述题目提交通过后再提交本题。**

注记：原题评测机速度应该不快于洛谷的 $1/4$。

## 题目描述


有 $10^6$ 棵树，自西向东编号 $1\sim 10^6$。小恐龙的营地在第 $1$ 棵树西边。

![](https://cdn.luogu.com.cn/upload/image_hosting/x3sfvs1o.png)

在接下来的 $n$ 天中，小恐龙的饮食计划为：

- 第 $i$ 天，她将从营地步行到树 $a_i$，再返回营地。从营地去树 $a_i$ 的途中，她会摘下遇到的所有的树的 $v_i$ 片叶子（返程时不摘叶子）。

不难发现，每天，每棵树至多只被摘一次叶子。

一开始，$v_i=0$。有 $m$ 次修改：

- 第 $j$ 次修改将**前 $p_j$ 天的 $v_i$**（$i = 1, 2, \ldots, p_j$）每个增加 $w_j$。  

此外，修改间隙有 $z$ 次查询：  

- 第 $j$ 次查询：求出在前 $p_j$ 天中，第 $d_j$ 棵树被吃掉的总叶子数。

修改会影响所有后面的查询，但是每个查询之间是独立的。


## 说明/提示

### 样例解释

饮食计划如下：

- 第 $1$ 天：前往 $a_1 = 3$ 号树；  
- 第 $2$ 天：前往 $a_2 = 4$ 号树；
- 第 $3$ 天：前往 $a_3 = 1$ 号树；

初始时所有 $v_1 = v_2 = v_3 = 0$，即实际上一片叶子都不会摘。

1. 第一次查询，问前 $3$ 天中，$1$ 号树被摘掉的叶子数。答案显然为 $0$。
2. 第一次修改，将前 $2$ 天的 $v_i$ 各增加 $10$。  
   此时 $v_1=10,v_2=10,v_3=0$。
3. 第二次查询，问第 $1$ 天中，$2$ 号树被摘掉的叶子数。

	由于第一天摘了 $2$ 号树的叶子，所以答案为 $10$。
4. 第三次查询，问前 $3$ 天中，$1$ 号树被摘掉的总叶子数。
	
    由于前两天都会摘 $1$ 号树的叶子，所以答案为 $10+10=20$。
5. 第二次修改，将前 $3$ 天的 $v_i$ 各加 $1$。  

   此时，$v_1=11,v_2=11,v_3=1$。

6. 第四次查询，问前 $3$ 天中，$2$ 号树摘掉的叶子数。
   
   答案为 $11 + 11 + 0 = 22$。  


### 数据范围

- $1 \leq n, m, z \leq 10^6$；
- $n \cdot m \cdot z \leq 10^{16}$；
- $1\le a_i,w_j,d_j\le 10^6$；
- $1\le p_j\le n$。

### 子任务

子任务 $0$ 为样例。

下表中，符号 $a \sim b$ 表示 $0.99 \cdot b < a \le b$。

| 子任务编号 | 限制 | 
|:-------:|---------|
| $1$ | $(m + z) \cdot n \le 10^7$ |
| $2$ | $z \cdot m \le 10^7$，$n \cdot m \cdot z \sim 10^{13}$ |
| $3$ | $n = 10^4$，$n \cdot m \cdot z \sim 10^{14}$ |
| $4$ | $m = 10^4$，$n \cdot m \cdot z \sim 10^{14}$ |
| $5$ | $z = 10^4$，$n \cdot m \cdot z \sim 10^{14}$ |
| $6$ | $n \cdot m \cdot z \sim 10^{14}$ |
| $7$ | $n = 10^4$，$n \cdot m \cdot z \sim 10^{16}$ |
| $8$ | $m = 10^4$，$n \cdot m \cdot z \sim 10^{16}$ |
| $9$ | $z = 10^4$，$n \cdot m \cdot z \sim 10^{16}$ |
| $10$ | $n \cdot m \cdot z \sim 10^{16}$ |


## 样例 #1

### 输入

```
3 2 4
3 4 1
2 3 1
1 2 10
2 1 2
2 3 1
1 3 1
2 3 2```

### 输出

```
0
10
20
22```

# 题解

## 作者：WrongAnswer_90 (赞：12)

因为时限太搞笑所以暴力分块可以过。但是怎么没人说复杂度对的做法啊。

操作是维护 $b$ 序列，支持前缀加，查询前缀内 $a_i$ 大于等于 $x$ 的位置 $b_i$ 的和。

操作强于行加列求和，显然得根号。暴力的单根号很简单，看其他题解吧。考虑 $nmz\leq 10^{16}$ 怎么用，我们希望能编一个 $\mathcal O(\sqrt{nmz})$ 的东西出来。

操作分块，每 $B$ 个**修改操作**分一块。这样一共会分成 $m/B$ 块。处理到第 $i$ 块的时候，需要计算 $[1,i-1]$ 的块对这之中的询问的贡献，以及第 $i$ 块内部的修改对询问的贡献。

### $[1,i-1]$ 块的贡献

计算出 $f_j$ 表示处理了 $[1,i-1]$ 的块内的所有修改，此时 $j$ 的权值，这部分复杂度是 $\mathcal O(nm/B)$。查询就是一个二维数点。

总的修改次数是 $\mathcal O(nm/B)$ 级别的，而查询数只有 $z$。考虑平衡一下复杂度。

因为 $z$ 也是 $10^6$，常规分块复杂度还是有点高。所以可以分三层的块：设 $T=100$，每 $T$ 个位置分一个小块，这样一共有 $10^4$ 个小块。然后每 $T$ 个小块建立一个大块。维护每个点的值，小块内部的和，和大块内部的和，修改是 $\mathcal O(1)$，查询 $\mathcal O(T)$。

### 块内的贡献

一个修改操作 $(p_i,w_i)$ 对一个查询操作 $(q_j,d_j)$ 的贡献是 $[1,\min(p_i,q_j)]$ 内，$a$ 大于等于 $d_j$ 的点数 $\times w_i$，也就是 $zB$ 次数点，总点数是 $n$。这部分也是和上面一样的三层分块，只不过维护的是块内前缀和，大块内的小块前缀和，大块前缀和。修改 $\mathcal O(T)$，查询 $\mathcal O(1)$。

总复杂度是 $\mathcal O(nm/B+zT+zB+nT)$，取 $B=\sqrt{nm/z}$ 可以得到复杂度是 $\mathcal O(\sqrt{nmz}+(n+z)T)$。

---

## 作者：CarroT1212 (赞：8)

听说这题很适合卡评测。

首先这个奇偶吃树叶明显是来搞笑的，就是第 $i$ 天把 $[1,a_i]$ 里每棵树的叶子吃掉 $v_i$ 片。

设查询 $p$ 天后第 $d$ 棵树被吃掉的片数。那么每次查的就是 $\sum\limits_{i \le p,a_i\ge d}v_i$。而每次修改会把 $[1,p_j]$ 里的所有 $v_i$ 加上 $w_i$。如果把每次吃叶子看作是平面上的一个点 $(i,a_i)$，那修改是对 $i\le p_j$ 半平面的点 $+w_j$，查询是 2-side 矩形求和。

分块即可。把 $[1,n]$ 行分块，块内维护点按 $a_i$ 排序后的结果。然后就变成维护整块加、整块后缀和、以及散块操作。整块加就打 tag。整块后缀和的话，块内预处理每个 $\ge d$ 的后缀对应块里后多少个 $a_i$，然后维护块内元素的后缀和即可。散块直接暴力。时空单根号，25s 5G 下没有问题。~~感觉这么做可以降个紫的。~~

代码 1.5K 不到，不放了，防止邪恶小朋友打爆评测机。

其它做法的话，我写的 KDT [T 飞了](https://www.luogu.com.cn/record/209172420)。然后这个问题似乎可以规约至矩阵乘法，所以不存在低复杂度 polylog 做法。

![侵删](https://cdn.luogu.com.cn/upload/image_hosting/pvdd3qp8.png)

---

## 作者：yhy2024 (赞：3)

~为了展示波兰强大的测评姬开的抽象时空限制。~

题意：给你两个序列：$\{a_i\},\{v_i\}$

支持修改序列 $\{v_i\}$ ，询问：$\displaystyle \sum_{i\le x,a_i\ge d}v_i$

考虑分块。想一个简单的做法，对每个块从小到大排序，维护块内后缀和。修改时散块暴力，整块打标记。询问时散块暴力，整块二分查找。总复杂度 $O(n \sqrt n \log n)$ ，会超时。

注意到抽象空间和 $a$ 是静态的，直接预处理出每个块内的 $d$ 对应的位置，空间 $O(n \sqrt n)$ 本地都过不了编。

最终时空都是 $O(n \sqrt n)$ 。运用离线逐块处理的 trick 可以线性空间，这里给出离线逐块的实现。


```cpp
#include<bits/stdc++.h>
#define int long long 
#define rd read()
using namespace std;
const int N=1000005,S=sqrt(N)+10;
int n,m,tot,L,R,tag,B,p[N],sum[N],d[N],v[N],ans[N<<1];
short pos[N];
inline int read()
{
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return x;
}
inline bool cmp(int x,int y){return d[x]<d[y];}
inline void update(int x,int y){
	if(x>=R){tag+=y;return;}
	for(int i=L;i<=x;i++) v[i]+=y;
	sum[R]=v[p[R]];
	for(int i=R-1;i>=L;i--) sum[i]=sum[i+1]+v[p[i]];
}
inline int ask(int x,int y){
	if(!pos[y]) return 0;
	if(x>=R){return sum[pos[y]+L-1]+tag*(R-pos[y]-L+2);}
	int res=0;
	for(int i=L;i<=x;i++) res+=(v[i]+tag)*(d[i]>=y);
	return res;
}
struct Node{
	int op,x,y;
}q[N<<1];
inline void solve(int id){
	tag=0,L=(id-1)*B+1,R=min(n,id*B);
	int cnt=1;
	sort(p+L,p+R+1,cmp);
	memset(pos,0,sizeof(pos));
	for(int i=L;i<=R;i++){
		while(cnt<=d[p[i]]) pos[cnt++]=i-L+1;
	}
	for(int i=1;i<=m;i++){
		if(L>q[i].x) continue;
		if(q[i].op==1) update(q[i].x,q[i].y);
		else ans[i]+=ask(q[i].x,q[i].y);
	}
}
signed main(){
	cout.tie(0);
	n=rd,m=rd+rd;
	B=sqrt(n);
	for(int i=1;i<=n;i++) d[i]=rd,p[i]=i;
	tot=(n-1)/B+1;
	for(int i=1;i<=m;i++) q[i]={rd,rd,rd};
	for(int i=1;i<=tot;i++) solve(i);
	for(int i=1;i<=m;i++) if(q[i].op==2) cout<<ans[i]<<'\n';
	return 0;	
} 
```

---

## 作者：Butterfly_qwq (赞：3)

首先这个时限 25s 就是来搞笑的，考虑根号做法。

其次奇数偶数就是来搞笑的，显然相当于直接求前缀。

然后这个 $m$ 和 $z$ 就是来搞笑的，令 $q=m+z$。

最后这个 $nmz\le10^{16}$ 就是来搞笑的，**在时限 25s 的情况下**我完全看不出来有啥用。

那么问题变成了：对 $v$ 区间加，求 $\sum\limits_{i=1}^p[a_i\ge d]v_i$。

设 $x_{i,j}=\begin{cases}v_i&j=a_i\\0 &j\not=a_i\end{cases}$，于是问题就变成了矩阵加矩阵求和，我直接拍了个 KDT，很快啊！

然后你发现你 T 了一片，怎么时限 25s 还能 T 呢？

因为你注意你的 KDT 常数太大了。

那么根号做法除了 KDT 也只能是分块了吧。

对值域分块还是对序列分块随你便，反正是对称的。

其实对值域分块能更好一些，这样少个离散化，常数应该能小点。

每个块只有 $\sqrt{n}$ 种取值，对于每个块每一个后缀每一个前缀值域求元素和就好。

预处理 $O(n\sqrt{n})$，单次查询 $O(\sqrt{n})$ ，可以通过。

---

## 作者：Eterna (赞：1)

前面奇数和偶数纯来搞笑的。合并到一起就是区间 $[1,a_i]$。

询问即要我们模拟以下过程：

>有一个数列 $\{ f_n \}$，将其全部置为 $0$。
>
>然后对于每一个 $1 \le i \le p$，将 $\{ f_n \}$ 的区间 $[1,a_i]$ 加上 $v_i$。
>
>求 $f_d$ 的值。

同时，我们还要支持 $\{ v_n \}$ 的前缀加。

我们当然不能真的模拟这个过程，考虑转换。

由于我们只关心 $f_d$，所以我们发现只有 $a_i \ge d$ 的 $v_i$ 才对答案有贡献。举个例子，区间 $[1,5]$ 里不管怎么加，都不会影响到第 $6$ 个元素。

所以加上上面 $1 \le i \le p$ 的前提，询问可以归为 $\displaystyle \sum _{i \in [1,p]} [a_i \ge d]v_i$。

时限比较大，考虑一个高复杂度的做法。分块。

对于每个块的所有 $x$ 维护一下 $\displaystyle \sum _{i \in [L,R]}[a_i \ge x]$，这是静态的，所以可以预处理出。

我们可以对每个块维护排序后的 $\{ a_n \}$，然后 $p_i$ 表示 $a_i$ 在原数列中的位置。

维护 $v_{p_i}$ 的后缀和，即可完成整块询问。散块基本暴力即可。

修改整块打标记，然后散块也可以暴力。时间复杂度 $O(n \sqrt{n})$。

但是空间 $O(n \sqrt{n})$ 太烂，虽然已经可过了。

离线逐块处理，空间降至 $O(n)$。这部分很典，所以不说了。


```cpp
#include<bits/stdc++.h>
#define N 1000005
#define int long long
#define rd read()
#define gc pa == pb && (pb = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pb) ? EOF : *pa++
using namespace std;
static char buf[100000], * pa(buf), * pb(buf);
inline int read()
{
	register unsigned int x=0,s=gc;
	while(!isdigit(s))s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+(s^48),s=gc;
	return x;
}
const int block=1300,V=1000000;
struct qu{int op,x,y;}q[N<<1];
int n,m,tot,G,a[N],p[N],L,R;
int tag,sum[N],v[N],ans[N<<1];
short cnt[N],s[N];
inline bool cmp(int x,int y){return a[x]<a[y];}
inline void build()
{
	n=rd,m=rd+rd;tot=(n-1)/block+1;
	for(register int i=1;i<=n;i++)p[i]=i,a[i]=rd;
	for(register int i=1;i<=m;i++)q[i]={rd,rd,rd};
}
inline void add(int x,int y){for(register int i=L;i<=x;i++)v[i]+=y;sum[R]=v[p[R]];for(int i=R-1;i>=L;--i)sum[i]=sum[i+1]+v[p[i]];}
inline int ask(int x,int y){G=0;for(int i=L;i<=x;i++)if(a[i]>=y)G+=(v[i]+tag);return G;}
inline int blkask(int i,int x){if(!cnt[x])return 0;return sum[R-cnt[x]+1]+tag*cnt[x];}
inline void solve(int x)
{
	tag=0;L=R+1,R=min(x*block,n);
	sort(p+L,p+R+1,cmp);
	for(register int j=L;j<=R;++j)++s[a[j]];
	for(register int j=V,S=0;j>=0;j--)S+=s[j],cnt[j]=S;
	for(register int j=L;j<=R;++j)s[a[j]]=0;
	for(register int i=1;i<=m;i++)
	{
		if(L>q[i].x)continue;
		if(q[i].op==1)
		{
			if(R<=q[i].x)tag+=q[i].y;
			else add(q[i].x,q[i].y);
		}
		else
		{
			if(R<=q[i].x)ans[i]+=blkask(x,q[i].y);
			else ans[i]+=ask(q[i].x,q[i].y);
		}
	}
}
signed main()
{
	build();
	for(register int i=1;i<=tot;i++)solve(i);
	for(register int i=1;i<=m;i++)if(q[i].op==2)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：lzyqwq (赞：1)

卡评测好题。难点在于读题。

注意到一来一回分别摘奇数、偶数编号的叶子，相当于直接给整个区间内的树摘叶子。

那么问题变成：

> - 给你一个长度为 $N=10^6$ 的序列 $b_i$ 和长度为 $n$ 的操作序列 $(a_i,v_i)$，表示将 $b_1,\dots,b_{a_i}$ 加上 $v_i$。初始 $b_i=v_i=0$。
> - 有 $q$ 次修改或查询 $(o_j,p_j,w_j)$：
>   - 当 $o_j=1$ 时，表示将 $v_1,\dots,v_{p_j}$ 加上 $w_j$。
>   - 当 $o_j=2$ 时，表示查询依次执行操作序列中前 $p_j$ 次操作后，$b_{w_j}$ 的值。**询问相互独立，即不会真的执行操作。**
> - $n\le 10^6$，$\color{red}q\le 2\times 10^6$，$\color{red} \text{25 s}$。

注意到抽象时间限制，考虑一些高复杂度做法。

考虑一个位置 $b_x$ 能被哪些操作 $i$ 修改，显然 $a_i\ge x$。那么问题变成 $v_i$ 序列区间加、查询 $\sum\limits_{i\le p_j,a_i\ge w_j}v_i$。

考虑以 $B=\mathcal{O}(\sqrt n)$ 为块长分块。整块内对 $a_i$ 离散化，则只有 $\mathcal{O}(\sqrt n)$ 种元素。然后可以对 $1,\dots,N$ 维护出其后继离散化值 $\text{nx}_1,\dots,\text{nx}_N$。这个容易 $\mathcal{O}(N)$ 扫一遍。然后维护加标记 $\text{ad}$ 以及 $\text{sm}_j$ 和 $\text{sf}_j$ 表示 **离散化值** $\ge j$ 的 $v'_i$ 和以及个数。此处 $v'_i$ 满足 $v'_i+\text{ad}=v_i$。那么整块加就是打标记，整块查询结果就是 $\text{sm}_{\text{nx}_{w_j}}+\text{ad}\cdot \text{sf}_{\text{nx}_{w_j}}$。

散块修改就下放标记然后 $\mathcal{O}(\sqrt n)$ 重构 $\text{sm}_j$。散块查询就暴力枚举然后累加满足条件的 $v_i$ 即可。还是要注意我们维护的是 $v'_i$，累加时不要忘记标记。

时间复杂度 $\mathcal{O}((q+N)\sqrt n)$。空间复杂度可以通过离线逐块处理做到 $\mathcal{O}(n+M+q)$。

为了防止卡评测不放代码了。

---

## 作者：shinzanmono (赞：1)

绝顶搞笑题。

25s，$n\leq 10^6$，$q\leq 2\times 10^6$，显然可以往根号做法想。

题面写了一大堆没用的，但是总结起来就是在 $1$ 到 $a_i$ 的每棵树上摘 $v_i$ 片叶子，修改操作等价于前缀加操作，而查询相当于查询区间内 $\geq d$ 的 $v_i$ 和。

考虑块长为 $B$，维护块内排序后的后缀和，修改暴力修改，查询直接预处理整块内 $a_i$ 排序后第一个 $\geq d$ 的位置，这个是预处理的时空复杂度都是 $O\left(\dfrac{nV}{B}\right)$ 的。而修改和查询显然都是单次 $O\left(B+\dfrac{n}{B}\right)$ 的。取 $B=O(\sqrt n)$ 即可。建议将块长稍微开大一点，以免卡空间。

```cpp
#include<iostream>
#include<algorithm>
using ll=long long;
const int sz=1e6+10;
const int sqsz=1010;
namespace IO{
  using ll=long long;
  const int MAXSIZE=1<<21;
  char buf[MAXSIZE],*pb,*pe;
#define gc() (pb==pe&&(pe=(pb=buf)+fread(buf,1,MAXSIZE,stdin),pb==pe)?EOF:*pb++)
  inline ll read(){
    ll x=0,f=1;
    char c=gc();
    while(!isdigit(c)){
      if(c=='-')f=-1;
      c=gc();
    }
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=gc();
    return x*f;
  }
  char pbuf[MAXSIZE],*pp=pbuf;
  int sta[35];
  inline void push(const char &c) {
    if(pp-pbuf==MAXSIZE)fwrite(pbuf,1,MAXSIZE,stdout),pp=pbuf;
    *pp++=c;
  }
  inline void write(ll x){
    if(x<0)push('-'),x=-x;
    int top=0;
    do sta[top++]=x%10,x/=10;while(x!=0);
    while(top!=0)push(sta[--top]+'0');
  }
  inline std::string readline(){
    std::string s;
    char c;
    while((c=gc())!='\n'&&c!=EOF)s+=c;
    return s;
  }
  inline void write(std::string s){for(char &c:s)push(c);}
  inline void flush(){if(pp-pbuf!=0)fwrite(pbuf,1,pp-pbuf,stdout),pp=pbuf;}
}
using IO::read,IO::write,IO::flush;
int belong[sz],bl[sz],br[sz],l[sz],a[sz];
ll tag[sz],suf[sz],v[sz];
short pos[sqsz][sz];
inline void add(int x,ll val){
  for(int i=1;i<belong[x]+(x==br[belong[x]]);i++)tag[i]+=val;
  if(x==br[belong[x]])return;
  for(int i=bl[belong[x]];i<=x;i++)v[i]+=val;
  suf[br[belong[x]]]=v[a[br[belong[x]]]];
  for(int i=br[belong[x]]-1;i>=bl[belong[x]];i--)suf[i]=suf[i+1]+v[a[i]];
}
inline ll query(int x,int d){
  ll res=0;
  for(int i=1;i<belong[x]+(x==br[belong[x]]);i++)
    if(pos[i][d]!=0)res+=suf[pos[i][d]+bl[i]-1]+tag[i]*(br[i]-pos[i][d]-bl[i]+2);
  if(x!=br[belong[x]])for(int i=bl[belong[x]];i<=x;i++)if(l[i]>=d)res+=v[i]+tag[belong[x]];
  return res;
}
int main(){
  int n=read(),q=read()+read();
  for(int i=1;i<=n;i++)l[i]=read();
  int lim=2000,num=n/lim;
  for(int i=1;i<=num;i++)bl[i]=br[i-1]+1,br[i]=i*lim;
  if(br[num]!=n)num++,bl[num]=br[num-1]+1,br[num]=n;
  for(int i=1;i<=num;i++){
    for(int j=bl[i];j<=br[i];j++)belong[j]=i,a[j]=j;
    std::sort(a+bl[i],a+br[i]+1,[&](int x,int y){return l[x]<l[y];});
    int lst=1;
    for(int j=bl[i];j<=br[i];j++)while(lst<=l[a[j]])pos[i][lst++]=j-bl[i]+1;
  }
  while(q--){
    int op=read(),x=read(),y=read();
    if(op==1)add(x,y);
    else write(query(x,y)),write("\n");
  }
  flush();
  return 0;
}
```

---

## 作者：Coffins (赞：0)

一个另类的操作分块做法，听说单根能过就直接写了，结果常数太大了，卡了卡常调了调块长就过了。

首先考虑一个 $O((zm+n)\log V)$ 的做法，我们考虑一个对查询来说它前面的某个修改的贡献是什么。如果我们设这个查询为 $i$，那么前面的一次修改 $j$ 对它的贡献就是：
$$w_j\sum\limits_{k=1}^{\min\{p_i,p_j\}} [d_i\le a_k]$$

不妨设 $F(x,y)=\sum\limits_{i=1}^x[y\le a_i]$
于是我们就相当于 $O(zm)$ 次询问，每次查询一个 $F(\min\{p_i,p_j\},d_i)$，直接离线下来二维数点就可以了。

于是我们基于这个做法考虑操作分块（下文设 $q=m+z$），考虑 $\sqrt q$ 个分一块，于是答案就可以由两部分组成：块内贡献以及之前的块的贡献。

块内贡献就是上文提及的柿子，这部分直接爆做就是 $O((q+n)\sqrt q\log V)$。

考虑块外的部分我们可以求出当前块之前的修改后的 $v_i$，于是求 $\sum\limits_{k=1}^{p_i}[d_i\le a_k]v_k$ 就好了，同理直接二维数点爆做，这部分是 $O((q+n\sqrt q)\log V)$。

虽然是 25s，但是 1e6 单根 log 还是太慢了。

于是考虑去掉 log。

第二个的 log 是好去的，因为查询总次数是 $O(q)$ 的，修改总次数是 $O(n\sqrt q)$ 的，所以直接上分块 $O(1)$ 修改 $O(\sqrt V)$ 查询就可以了。

第一个其实也不难，因为我们发现我们的瓶颈在算 $F(x,y)$，于是一起离线下来做就可以 $O(n)$ 次修改，$O(q\sqrt q)$ 次查询。

于是也可以用分块去掉 log。

注意这一部分空间也是 $O(q\sqrt q)$ 的，于是可以把这些查询分成 $O(1)$ 部分就可以避免 MLE。

然后就 T 飞了。

后来发现好像第二部分常数比较大，于是把操作分块的块长调大一点就过了。

代码还是不扔了 ~~其实你想找可以去 qoj~~。

---


# [CrCPC 2024] 平凡的数论题

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) B.

## 题目描述

给定非负整数序列 $a,b,c$，长度分别为 $|a|,|b|,|c|$。这里序列下标是 **0-indexed** 的。

令 $l=\max\{a_i,b_i,c_i\}$。

找到任意一个 $\in [l+1,10^{19})$ 的正整数 $B$，使得 $\displaystyle \left(\sum_{0\le i\lt |a|} a_iB^i\right)\left(\sum_{0\le j\lt |b|} b_jB^j\right)=\sum_{0\le k\lt |c|} c_kB^k$ 成立。

数据保证，若存在正整数 $B\ge l+1$ 使得上式成立，则存在一个 $\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。


## 说明/提示

- $1\le |a|,|b|,|c|\le 10^3$；
- $0\le a_i,b_i,c_i\le 2^{30}$；
- $a_{|a|-1},b_{|b-1|},c_{|c-1|}\neq 0$。
- 若存在正整数 $B\ge l+1$ 使得上式成立，则存在一个 $\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。

## 样例 #1

### 输入

```
2 2 0
1 2
3 1 0 0```

### 输出

```
4```

## 样例 #2

### 输入

```
3 5 1 2
2 11 3
5 4 5 1 12 6```

### 输出

```
13```

## 样例 #3

### 输入

```
2 3 2
2 3 2
3 10 12 4```

### 输出

```
impossible```

# 题解

## 作者：N_z_ (赞：6)

验题的时候得到的题面没有 $\max(a_i,b_i,c_i)$ 的限制，来写一下这个版本。

直接做出 $d=a*b-c$，我们需要求出 $d$ 的一个整根。

我们给出一件非常强的事情：$d$ 的所有整根都是 $d$ 最低非零项的因子，证明考虑直接模这个根。

于是直接做质因数分解，我们可以说明最低项是 $O(V^2)$ 的，于是复杂度 $O(nd(V^2))$。

---

## 作者：ZeroOf149 (赞：1)

# [P11932 [CrCPC 2024] 平凡的数论题](https://www.luogu.com.cn/problem/P11932)

本文约定 $\displaystyle\max\{a_i, b_i, c_i\} = \max\{\max_{i=0}^{|a| - 1}\{a_i\}, \max_{i=0}^{|b| - 1}\{b_i\}, \max_{i=0}^{|c| - 1}\{c_i\}\}$。

## 题目描述

给出三个系数均为非负整数的多项式 $A(x), B(x), C(x)$，求一个正整数 $x$ 满足 $x > \max\{a_i, b_i, c_i\}$ 且 $A(x)B(x) = C(x)$，或者输出无解。其中 $0 \leq a_i, b_i, c_i \leq 2^{30}$，多项式次数不超过 $10^3$。

## 解法说明

我们暴力地求出 $f(x) = C(x) - A(x)B(x)$，问题转化为求 $f(x)$ 的任意一个大于 $\max\{a_i, b_i, c_i\}$ 的整数根。这迫使我们想到有理根定理：  

> 有理根定理：如果整系数多项式 $f(x) = \displaystyle\sum_{i=0}^n a_ix^i$ 有一个有理根 $x = \dfrac{p}{q}$，那么 $p\mid a_0 \land q \mid a_n$。

证明：知 $\gcd(p, q) = 1$。将 $f(x) = 0$ 两边同乘上 $q^n$，得到 $\displaystyle\sum_{i=0}^n a_ip^iq^{n-i} = 0$，这说明左式为 $p$ 的倍数，即 $p \mid a_0q^n$。由于 $\gcd(p, q) = 1$，立刻有 $p \mid a_0$，同理有 $q \mid a_n$。

这说明，我们寻找的解 $x$ 一定是 $f$ 的常数项的因数，或者更严谨的来说，是 $f$ 最低的非零系数的因数。考虑到 $0 \leq a_i, b_i, c_i \leq 2^{30}$，因此这一个系数最大是 $2^{60}$，这说明其因数的个数不到 $1.1 \times 10^5$ 个，使用 Miller-Rabin 与 Pollard-Rho 分解质因数并暴力判断即可。  
对于判断整数根，我们只需要选取一个较大的素数 $P$，如果 $P\mid f(x)$ 就认为 $f(x) = 0$，这样做有极大概率正确。

## 代码实现

```cpp
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <cstdint>
#include <iterator>
#include <map>
#include <numeric>
#include <random>
#include <vector>

using ll = long long;
using ld = long double;
using lll = __int128_t;

ll addmod(ll a, ll b, ll m) { return ((lll)a + b) % m; }
ll mulmod(ll a, ll b, ll m) { return (a * b - ll(ld(a) / m * b) * m + m) % m; }

ll powmod(lll t, ll p, ll m) {
  lll r = 1;
  t %= m;
  while (p) {
    if (p & 1) r = r * t % m;
    t = t * t % m;
    p >>= 1;
  }
  return r % m;
}

bool enumer(ll n) {
  for (ll d = 3; d <= n / d; d += 2)
    if (n % d == 0) return false;
  return true;
}

bool miller_rabin(ll num, ll check) {
  if (num < 2) return false;
  auto p = num - 1;
  while (p) {
    const auto c = powmod(check, p, num);
    if (c != 1 && c != num - 1) return false;
    if ((p & 1) || c == num - 1) return true;
    p >>= 1;
  }
  return true;
}

bool is_prime(ll num) {
  if (num < 2) return false;
  if (!(num & 1)) return num == 2;
  if (num <= 0x7f) return enumer(num);
  if (num <= 0xffffffffll)
    return miller_rabin(num, 2) && miller_rabin(num, 7) &&
           miller_rabin(num, 61);
  return miller_rabin(num, 2) && miller_rabin(num, 325) &&
         miller_rabin(num, 9375) && miller_rabin(num, 28178) &&
         miller_rabin(num, 450775) && miller_rabin(num, 9780504) &&
         miller_rabin(num, 1795265022);
}

template <class Random>
ll pollard_rho(ll num, Random& rdm) {
  if (num == 3) return 3;
  if (num == 4) return 2;
  ll c = rdm() % (num - 3) + 3;
  auto rho = [&c, &num](ll x) { return addmod(mulmod(x, x, num), c, num); };
  ll s = rho(0), t = rho(s);
  for (int goal = 1; s != t; goal = std::min(goal << 1, 128)) {
    ll x = 1;
    for (int step = 1; step <= goal; ++step) {
      const ll m = mulmod(x, std::abs((s - t) % num), num);
      if (m == 0) break;
      x = m;
      s = rho(s);
      t = rho(rho(t));
    }
    const ll d = std::gcd(x, num);
    if (d != 1) return d;
  }
  return num;
}

template <class Random>
inline std::vector<ll> prime_factors(ll num, Random& rdm) {
  if (num <= 1) return {};
  if (is_prime(num)) return {num};
  const auto fac = pollard_rho(num, rdm);
  auto f1 = prime_factors(fac, rdm), f2 = prime_factors(num / fac, rdm);
  const auto siz = f1.size();
  f1.resize(siz + f2.size());
  std::move(f2.begin(), f2.end(), f1.begin() + siz);
  return f1;
}

constexpr int N = 2e3 + 5;
constexpr ll Mod = 1000000000000002049;

int la, lb, lc;
lll a[N], b[N], c[N << 1], mx;

void get(lll a[], int& len) {
  scanf("%d", &len);
  for (int i = len; i--; ) {
    scanf("%lld", a + i);
    mx = std::max(mx, a[i]);
  }
}

lll abs(lll x) { return x < 0 ? -x : x; }

ll ans = -1;
std::map<ll, int> mp;

using It = decltype(mp.begin());

bool check(ll x) {
  if (x <= mx) return false;
  lll f = 0;
  for (int i = lc; i--; ) f = (f * x % Mod + c[i]) % Mod;
  return f ? false : (ans = x, true);
}

bool dfs(ll now, It it) {
  if (it == mp.end()) return check(now);
  auto nxt = std::next(it);
  for (int p = 0; p <= it->second; ++p) {
    if (dfs(now, nxt)) return true;
    now *= it->first;
  }
  return false;
}

int main() {
  get(a, la);
  get(b, lb);
  get(c, lc);
  if (la + lb != lc && la + lb != lc + 1) return printf("impossible"), 0;
  for (int i = 0; i < la; ++i)
    for (int j = 0; j < lb; ++j) c[i + j] -= a[i] * b[j];
  int pos = -1;
  for (int i = 0; i < lc; ++i)
    if (c[i]) {
      pos = i;
      break;
    }
  if (pos == -1) return printf("%lld", (ll)mx + 1), 0;
  auto mt = std::mt19937_64{std::random_device{}()};
  lll val = abs(c[pos]);
  if (val == 1) return printf("impossible"), 0;
  auto ps = prime_factors(val, mt);
  for (auto&& v : ps) ++mp[v];
  dfs(1, mp.begin());
  if (ans == -1) return printf("impossible"), 0;
  printf("%lld", ans);
}
```

---


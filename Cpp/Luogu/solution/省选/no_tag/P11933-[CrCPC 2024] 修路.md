# [CrCPC 2024] 修路

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) C.

![](https://cdn.luogu.com.cn/upload/image_hosting/uwqqd8f7.png?x-oss-process=image/resize,w_200)

## 题目描述

有一条河流。这条河流由 $(n-1)$ 段线段组成，由 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$ 顺次连接而成。这里，$\forall 1\le i\lt n$，都有 $y_i\lt y_{i+1}$。

要修建一条路，起点为 $(x_1,y_1)$，终点为 $(x_n,y_n)$。路同样也是折线段。

给定正实数 $T$。令折线段的（欧几里得）总长度为 $a$，**穿过**河流的次数为 $b$，一种修路方案的**代价**为 $a+T\cdot b$。

路可以贴着河流修，贴着河流修不算作穿过。

求出修路方案可能的最小代价。


## 说明/提示

#### 样例解释

样例 $1$ 解释：见【题目背景】中的图。

#### 数据范围

- $2\le n\le 1\, 500$；
- $0\lt T\le 10^6$，$T$ 至多有两位小数；
- $|x_i|,|y_i|\le 10^5$；
- $\forall 1\le i\lt n$，有 $y_i\lt y_{i+1}$；
- 保证不存在三点共线。


## 样例 #1

### 输入

```
5 1
0 0
-1 2
4 3
-3 4
1 5```

### 输出

```
6.8416192530```

## 样例 #2

### 输入

```
2 1
0 0
0 1```

### 输出

```
1.0000000000```

# 题解

## 作者：yes_NT (赞：1)

[P11933](https://www.luogu.com.cn/problem/P11933)

乍一看这题似乎不好做，因为我们貌似不能每次精确找到路的折点。然而我们进而可以考虑路和河流有什么神秘的关系（？

这里给出结论：**路的折点一定也是河流的折点**。

> 证明：假设我们现在已经知道路与河流每一个折点的位置关系，也就是说我们已经知道了路与河流的交点情况，要使得总代价最小，我们只需要让路径长度最小即可。
> 
> 而我们不难发现，通过不断调整，一定可以使得路径贴在河流的折点上，我们要保证交点情况不变的前提下，是不可以绕过河流的，因此路的折点一定也是河流的折点。

知道了这个结论，我们可以考虑怎么转移了。记 $f_{i,0/1}$ 表示在河流折点 $i$ 处的左/右两侧作为修到 $i$ 处的路的最短路径，那么对于相邻的节点，有
$$\begin{aligned}
&f_{i,0}\gets f_{i-1,0}+dis(i-1,i)\\
&f_{i,0}\gets f_{i-1,1}+dis(i-1,i)+T\\
&f_{i,1}\gets f_{i-1,1}+dis(i-1,i)\\
&f_{i,1}\gets f_{i-1,0}+dis(i-1,i)+T\\
\end{aligned}$$

其中 $dis(i,j)$ 表示 $i$ 点与 $j$ 点的距离。

而对于不相邻的节点，我们就要考虑两个节点之间连线穿过的线段数量了。记 $g_{i,j}$ 表示 $i$ 与 $j$ 点的连线经过了的河流的数量（不包括 $(i,i-1)$ 与 $(j,j+1)$ 的河流）。然而，只知道这个，我们是不能直接转移的，因为我们不难发现，连线之间的转移是有可能与上述相邻的两条河流产生交点的。

这里以 $f_{j,0}$ 转移到 $f_{i,0}$ 为例。

![](https://cdn.luogu.com.cn/upload/image_hosting/uqs5yrz5.png)

如上图，路径与 $(i,i-1)$ 和 $(j,j+1)$ 都有交点，因此我们需要单独判断交点的情况。如果判断 $(i,j)$ 与 $(i,i-1)$ 是否产生了交点，我们可以通过判断这两条线的斜率的情况，通过比较斜率进而得出是否产生了额外的交点。

剩下的 $3$ 个方向也可以通过类似的方式解决，至此，我们可以写出以下的转移过程。

```cpp
    f[1][0] = f[1][1] = 0;
    for (int i = 2; i <= n; ++i) {
        for (int j = 1; j < i - 1; ++j) {
            f[i][0] = min(f[i][0], dis(i, j) + f[j][0] + T * (g[j][i] + (k(i, j) > k(j + 1, j)) + (k(i, j) < k(i, i - 1))));
            f[i][0] = min(f[i][0], dis(i, j) + f[j][1] + T * (g[j][i] + (k(i, j) < k(j + 1, j)) + (k(i, j) < k(i, i - 1))));
            f[i][1] = min(f[i][1], dis(i, j) + f[j][1] + T * (g[j][i] + (k(i, j) < k(j + 1, j)) + (k(i, j) > k(i, i - 1))));
            f[i][1] = min(f[i][1], dis(i, j) + f[j][0] + T * (g[j][i] + (k(i, j) > k(j + 1, j)) + (k(i, j) > k(i, i - 1))));
        }
        f[i][0] = min(f[i][0], dis(i - 1, i) + f[i - 1][0]);
        f[i][0] = min(f[i][0], dis(i - 1, i) + f[i - 1][1] + T);
        f[i][1] = min(f[i][1], dis(i - 1, i) + f[i - 1][1]);
        f[i][1] = min(f[i][1], dis(i - 1, i) + f[i - 1][0] + T);
        // printf("%.7lf %.7lf\n", f[i][0], f[i][1]);
    }
```

如果暴力算 $g_{i,j}$，现在代码的时间复杂度是 $O(n^3)$ 级别的。

考虑怎么快速计算这一过程，不难发现如果 $IJ$ 与 河流 $AB$ 产生了交点，$IJ$ 的斜率一定在 $BI$ 和 $AI$ 之间，因为我们只需要考虑 $i$ 和 $j$ 之间的节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/yeofqlm3.png)

于是我们可以用线段树维护这一过程，插入河流时就在对应位置做区间加，单点查询路径的斜率即可。

至此我们完成了这道题。

时间复杂度 $O(n^2\log n)$ 。

**Code**
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
template<typename T> inline void read(T &x) {
    x = 0; bool f = 0; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = getchar();}
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    if (f) x = ~x + 1;
}
const int N = 2005;
int dat[N << 2];
void pushdown(int p) {
    dat[p * 2] += dat[p];
    dat[p * 2 + 1] += dat[p];
    dat[p] = 0;
}
void update(int p, int l, int r, int L, int R, int v) {
    if (L > R)
        swap(L, R);
    if (L <= l && r <= R) {
        dat[p] += v;
        return;
    }
    pushdown(p);
    int mid = (l + r) >> 1;
    if (L <= mid)
        update(p * 2, l, mid, L, R, v);
    if (mid < R)
        update(p * 2 + 1, mid + 1, r, L, R, v);
}
int query(int p, int l, int r, int x) {
    if (l == r)
        return dat[p];
    pushdown(p);
    int mid = (l + r) >> 1;
    if (x <= mid)
        return query(p * 2, l, mid, x);
    return query(p * 2 + 1, mid + 1, r, x);
}
const double inf = 1000000000.0;
int n, g[N][N], cnt;
double T, a[N], f[N][2], x[N], y[N], aa[N];
double dis(int i, int j) {
    return sqrt(1.0 * (x[i] - x[j]) * (x[i] - x[j]) + 1.0 * (y[i] - y[j]) * (y[i] - y[j]));
}
double k(int i, int j) {
    return (double)(x[j] - x[i]) / (double)(y[j] - y[i]);
}
int main() {
    memset(f, 0x7f, sizeof(f));
    read(n); scanf("%lf", &T);
    for (int i = 1; i <= n; ++i) {
        scanf("%lf%lf", &x[i], &y[i]);
    }
    for (int i = 1; i <= n; ++i) {
        cnt = 0;
        for (int j = 1; j < i; ++j) {
            a[++cnt] = k(i, j);
            aa[cnt] = a[cnt];
        }
        sort(aa + 1, aa + cnt + 1);
        for (int j = 1; j <= cnt; ++j)
            a[j] = lower_bound(aa + 1, aa + cnt + 1, a[j]) - aa;
        for (int j = 1; j < cnt; ++j)
            update(1, 1, cnt, a[j], a[j + 1], 1);
        for (int j = 1; j < cnt; ++j) {
            update(1, 1, cnt, a[j], a[j + 1], -1);
            g[j][i] = query(1, 1, cnt, a[j]);
        }
    }
    f[1][0] = f[1][1] = 0;
    for (int i = 2; i <= n; ++i) {
        for (int j = 1; j < i - 1; ++j) {
            f[i][0] = min(f[i][0], dis(i, j) + f[j][0] + T * (g[j][i] + (k(i, j) > k(j + 1, j)) + (k(i, j) < k(i, i - 1))));
            f[i][0] = min(f[i][0], dis(i, j) + f[j][1] + T * (g[j][i] + (k(i, j) < k(j + 1, j)) + (k(i, j) < k(i, i - 1))));
            f[i][1] = min(f[i][1], dis(i, j) + f[j][1] + T * (g[j][i] + (k(i, j) < k(j + 1, j)) + (k(i, j) > k(i, i - 1))));
            f[i][1] = min(f[i][1], dis(i, j) + f[j][0] + T * (g[j][i] + (k(i, j) > k(j + 1, j)) + (k(i, j) > k(i, i - 1))));
        }
        f[i][0] = min(f[i][0], dis(i - 1, i) + f[i - 1][0]);
        f[i][0] = min(f[i][0], dis(i - 1, i) + f[i - 1][1] + T);
        f[i][1] = min(f[i][1], dis(i - 1, i) + f[i - 1][1]);
        f[i][1] = min(f[i][1], dis(i - 1, i) + f[i - 1][0] + T);
        // printf("%.7lf %.7lf\n", f[i][0], f[i][1]);
    }
    printf("%.7lf", min(f[n][0], f[n][1]));
    return 0;
}
```

---

## 作者：chenbs (赞：1)

一道计算几何 + DP。

首先 DP 显然是一维的，令 $f_i$ 为修路修到 $i$ 点所需的最短路径，那么 $f_i = \min_{1 \le j < i-1}({f_j + \sqrt{(x_i-x_j)^2 +(y_i-y_j)^2} + T \times d_{i,j}})$，其中 $d_{i,j}$ 表示 $i$ 到 $j$ 穿过了多少次河（贴着河修另外处理）。

接下来讲述快速处理 $d$ 数组。

![](https://cdn.luogu.com.cn/upload/image_hosting/d9s8gfo7.png)

此处将 $x$ 和 $y$ 交换，方便等会计算斜率。我们注意到：线段 $JI$ 能穿过中间的线段 $AB$，当且仅当 $JI$ 的斜率在 $AI$ 与 $BI$ 之间，所以，设当前处理到 $i$，只需要将 $i$ 前面的点按照到 $i$ 的斜率排序，然后用树状数组区间加单点求值即可。

但是有一个问题，边界到底有没有穿过呢？我们看下面两张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/yqguypzt.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/7jxpsrnn.png)

它们都是 $j$ 到 $i$ 的转移，但是显然穿过的次数不同。所以我们需要更改 DP 状态。

最终方案如下：令 $f_{i,0}$ 为从河的上方到达 $i$ 点的最优花费，$f_{i,1}$ 为从河的下方到达 $i$ 点的最优花费。转移时根据 $i-1$ 到 $i$ 的斜率以及 $j$ 到 $j+1$ 的斜率进行分类讨论即可。时间复杂度 $O(n^2 \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x[1505], y[1505], t[1505];
double T;
#define lowbit(x) (x&-x)
void add(int x, int v) {
	while(x<=n) t[x]+=v, x+=lowbit(x);
}
int get(int x) {
	int s=0;
	while(x) s+=t[x], x-=lowbit(x);
	return  s;
}
int base;
bool cmp(int i, int j) {
//	(y[base]-y[i])/(x[base]-x[i]) > (y[base]-y[j])/(x[base]-x[j]);
	return 1ll*(y[base]-y[i])*(x[base]-x[j]) > 1ll*(y[base]-y[j])*(x[base]-x[i]);
}
double dis(int i, int j) {
	return sqrt(1ll*(x[i]-x[j])*(x[i]-x[j])+1ll*(y[i]-y[j])*(y[i]-y[j]));
}
int a[1505], rnk[1505];
double f[1505][2]; // 修到 i 点上 / 下的最小代价
int main() {
	cin>>n>>T;
	for(int i=1; i<=n; i++) cin>>x[i]>>y[i], swap(x[i], y[i]);
	memset(f, 0x7f, sizeof f);
	f[1][0]=f[1][1]=0;
	for(int i=2; i<=n; i++) {
		for(int j=1; j<i; j++) a[j]=j;
		base=i;
		sort(a+1, a+i, cmp);
		for(int j=1; j<i; j++) rnk[a[j]]=j;
		memset(t,0,sizeof t);
		for(int j=i-2; j>=1; j--) {
			int l=rnk[j], r=rnk[j+1];
			if(l>r) swap(l, r);
			add(l+1, 1), add(r, -1);

			int to=cmp(j,i-1), from=cmp(j,j+1);
			f[i][to]=min(f[i][to], f[j][from]+get(rnk[j])*T+dis(j, i));
		}
		f[i][0]=min(f[i][0], f[i-1][0]+dis(i-1, i));
		f[i][1]=min(f[i][1], f[i-1][1]+dis(i-1, i));
		f[i][0]=min(f[i][0], f[i][1]+T);
		f[i][1]=min(f[i][1], f[i][0]+T);
//		printf("#%d %.3lf %.3lf\n",i,f[i][0],f[i][1]);
	}
	printf("%.9lf", min(f[n][0], f[n][1]));
}
```

---

## 作者：happybob (赞：0)

注意转折点必然是给定的点，求出两点边权后相当于是 DAG 最短路，DP 即可。

特别地你需要将每个点拆成两个状态分别表示进入这个点的直线斜率和这个点对应的那条的关系，这样才能处理穿过一个点而不是一条直线的贡献。

直接求边权是三次方的，瓶颈在于求两个点连线经过了几条线，枚举 $i$，将所有 $j$ 按夹角排序，类似扫描线地维护即可，可能需要树状数组或者平衡树。

---


# [CrCPC 2024] 萌萌交互题

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) E.

## 题目描述

**这是一道传统题。**

交互库有一个隐藏的长度为 $n$，值域为 $[1,k]$ 的正整数序列 $a=[a_1,\ldots,a_n]$。

每次询问可以给定一个长度为 $n$，值域为 $[1,k]$ 的正整数序列 $[b_1,\ldots,b_n]$，交互库会告诉你猜对了哪些位置。也就是，交互库会返回一个长度为 $n$ 的 $01$ 序列 $s$，$s_i=1$ 表示 $a_i=b_i$，$s_i=0$ 表示 $a_i\neq b_i$。

**交互库是非自适应的**，也就是说序列 $a$ 已经事先确定。

对于序列 $[a_1,a_2,\ldots,a_n]$，定义 $f([a_1,a_2,\ldots,a_n])$ 为：如果交互库隐藏的序列为 $a=[a_1,a_2,\ldots,a_n]$，最优策略下要多少次才能猜出 $a$ 序列。


若交互库在 $k^n$ 个长度为 $n$，值域 $\in [1,k]$ 的正整数序列 $[a_1,a_2,\ldots,a_n]$ 中等概率独立随机选取一个，求出 $f$ 的期望值。

换句话说，令 $\displaystyle p=\sum_{1\le a_1\le k}\sum_{1\le a_2\le k}\cdots \sum_{1\le a_n\le k}f([a_1,a_2,\ldots,a_n])$，$q=k^n$，求出 $p/q$。

只需要输出答案对 $(10^9+7)$ 取模后的结果。

（注记：当且仅当交互库返回 $[1,1,\ldots,1]$ 时，认为猜出了序列。换句话说，就算已经事先确定这个序列，也要再询问一次。）



## 说明/提示

#### 样例解释

样例 $3$ 真实答案为 $\frac{1}{8}+\frac{7}{8}\cdot 2=\frac{15}{8}$。

#### 数据范围

- $1\le n\le 10^6$；
- $1\le k\le 10^9$。


## 样例 #1

### 输入

```
4 8```

### 输出

```
663085949```

## 样例 #2

### 输入

```
8 8```

### 输出

```
480783235```

## 样例 #3

### 输入

```
3 2```

### 输出

```
875000008```

# 题解

## 作者：N_z_ (赞：4)

简单题。

注意到我们可以获知哪些位置正确，这意味着对于每一位我们可以视作独立游戏，而完成游戏的时间是最后一个被完成的位。

考虑每一位的策略，由于是随机生成，我们询问的应当是一个排列，并且不妨将排列视为 $1,2,\cdots,n$。

$\le i$ 次可以完成的排列数量是 $i^n$，因此答案是 $\sum_{i=0}^k\frac{k^n-i^n}{k^n}$，插值求一个自然数幂和即可。

---

## 作者：_Ad_Astra_ (赞：2)

糖糖传统题。这个题真不是绿？

----------------------

首先不管这个期望，先考虑我们的最优策略是什么。第一次询问肯定怎么问都行（不妨全猜 $1$），再考虑第二次询问，显然第一次如果直接猜对了的肯定后面的询问保持不变，没猜对的，我们把它换成另外一个数（不妨直接换成 $2$），一定是最优的。后面的询问同理，对于第 $k$ 轮，以前猜中过的不变，没有猜中的换成 $k$ 再尝试。

![](https://cdn.luogu.com.cn/upload/image_hosting/y24yt6ah.png)

然后我们发现我们只关心每个位置第一次猜中的时刻。具体而言，由于我们是从 $1$ 开始往 $k$ 猜的，所以第 $i$ 个恰好会在 $a_i$ 时刻被猜中。

由于结束时刻是每个人的猜中时刻的最大值，即 $\max a_i$，所以就是求值域 $[1,k]$ 的长为 $n$ 的随机序列的 $\max$ 的期望。这个属于老套路题。

考虑 $\sum\limits_a \max \{a_i\} = \sum\limits_{j=1}^{k}\sum\limits_a[\max \{a_i\} \ge j]$。而要数有多少个数列满足最大值至少是 $j$，转换成总个数减去所有 $a_i$ 都小于 $j$ 的方案数即可。

最后答案就是 

$$\frac{\sum\limits_{i=0}^{k-1}k^n-i^n}{k^n} = k-\sum\limits_{i=0}^{k-1}i^n$$

这个是经典问题，容易看出，答案最多是关于 $k$ 的 $n+1$ 次多项式，因此直接拉格朗日插值即可（更加具体的做法在此就不赘述，详见 [CF622F](https://codeforces.com/problemset/problem/622/F)）。

代码跟上面那题几乎一样就不贴了。

---

## 作者：chenwenmo (赞：1)

## [P11935 [CrCPC 2024] 萌萌交互题](https://www.luogu.com.cn/problem/P11935)

赛时选择的最优策略是，初始全部猜 $1$，然后哪些位置不对就同时 $+1$，不断重复，这样不会浪费步数。显然最小步数就是 $\max a_i$。

考虑枚举最大值 $i$，再枚举最大值有 $j$ 位置，算出方案数，再乘上 $i$，

$\sum_{i=1}^{k} i\sum_{j=1}^{n} \binom{n}{j}(i-1)^{n-j}$，

$\sum_{i=0}^{k-1} (i+1)\sum_{j=1}^{n} \binom{n}{j}i^{n-j}$，

$\sum_{i=0}^{k-1} (i+1)[(\sum_{j=0}^{n} \binom{n}{j}i^{n-j}) - i^n]$，

$\sum_{i=0}^{k-1} (i+1)[(i+1)^n-i^n]$，

$\sum_{i=0}^{k-1} (i+1)^{n+1} - \sum_{i=0}^{k-1} (i+1)i^n$，

$\sum_{i=0}^{k-1} (i+1)^{n+1} - \sum_{i=0}^{k-1} i^{n+1} - \sum_{i=0}^{k-1} i^n$，

$k^{n+1} - \sum_{i=0}^{k-1} i^n$，

后面那项就是拉插的经典运用。[CF622F](https://www.luogu.com.cn/problem/CF622F)

最终答案就是这个式子除以 $k^n$。

复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using LD = long double;
using PII = pair<int, int>;

const int N = 1e6 + 5, MOD = 1e9 + 7, INF = 2e9;

int n, k, ans;

int fpow(int a, int b) {
    int ans = 1;
    for (; b; b >>= 1) {
        if (b & 1) ans = (LL)ans * a % MOD;
        a = (LL)a * a % MOD;
    }
    return ans;
}

namespace LAGR {
int prime[N], vis[N], cnt, p[N], fact[N], inv[N], pre[N], suf[N];

void init() {
    p[1] = 1;
    for (int i = 2; i <= n + 2; i++) {
        if (!vis[i]) {
            vis[i] = i;
            prime[++cnt] = i;
            p[i] = fpow(i, n);
        }
        for (int j = 1; j <= cnt && prime[j] <= (n + 2) / i; j++) {
            vis[prime[j] * i] = prime[j];
            p[prime[j] * i] = (LL)p[prime[j]] * p[i] % MOD;
            if (i % prime[j] == 0) break;
        }
    }
    fact[0] = 1;
    for (int i = 1; i <= n + 2; i++) fact[i] = (LL)fact[i - 1] * i % MOD;
    inv[n + 2] = fpow(fact[n + 2], MOD - 2);
    for (int i = n + 1; i >= 0; i--) inv[i] = (LL)inv[i + 1] * (i + 1) % MOD;
}

inline int calc(int n, int m) { // 计算 \sum_{i = 1}^{n} i^m
    pre[0] = 1;
    for (int i = 1; i <= m + 2; i++) pre[i] = (LL)pre[i - 1] * (n - i) % MOD;
    suf[m + 3] = 1;
    for (int i = m + 2; i >= 1; i--) suf[i] = (LL)suf[i + 1] * (n - i) % MOD;
    int y = 0, ans = 0, op = ((m + 1) % 2) ? -1 : 1;
    for (int i = 1; i <= m + 2; i++) {
        y = (y + p[i]) % MOD;
        ans = (ans + (LL)op * pre[i - 1] % MOD * suf[i + 1] % MOD * inv[i - 1] % MOD * inv[m + 2 - i] % MOD * y) % MOD;
        op = -op;
    }
    return (ans + MOD) % MOD;
}
} using LAGR::calc;

int main() {
    cin >> n >> k;
    LAGR::init();
    ans = ((fpow(k, n + 1) - calc(k - 1, n)) % MOD + MOD) % MOD;
    cout << (LL)ans * fpow(fpow(k, n), MOD - 2) % MOD << '\n';
    return 0;
}
```

---

## 作者：BYR_KKK (赞：1)

没有一个好的板子，没抢到一血，慢了两分钟。

每个位置显然是独立的，所以对于每个位置分别设计策略，显然我们没有什么很巧妙的询问方式，只能按照一个 $1\sim n$ 的排列的顺序询问，选哪个排列都是无所谓的，因此选 $1\sim n$ 就好了。这样一个序列的答案就是序列的最大值。

列出式子 $\sum\limits_{i=1}^ki(i^n-(i-1)^n)$，最后除去 $k^n$。化简一下得到 $k^{n+1}-\sum\limits_{i=1}^{k-1}i^n$，后面的式子是 CF622F，直接拉插就做完了。

---

## 作者：Purslane (赞：0)

# Solution

你进行的第一次询问，显然每个位置是多少并不重要，因为你对这个序列一无所知。所以，最优策略可以钦定第一次全问 $1$。

对于第二次询问（如果还有未确定的位置），显然未确定的位置问所有数效果也是一样的，所以最优策略可以钦定第二次全问 $2$。

以此类推，我们得到询问次数其实就是 $\max_{i} a_i$。

对它求和，得到期望为：

$$
k - \sum_{i=1}^{k-1} (\frac{i}{k})^n
$$

对 $\sum_{i=1}^{lim} i^n$ 这种结构进行插值即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MOD=1e9+7,MAXN=1e6+10;
int n,k,pre[MAXN],inv[MAXN],mul=1;
int qpow(int base,int p) {int ans=1;while(p) {if(p&1) ans=ans*base%MOD;base=base*base%MOD,p>>=1;}return ans;}
int solve(int k) {
	if(k<=n+2) return pre[k];
	int ans=0;
	ffor(i,1,n+2) {
		int fz=pre[i]*mul%MOD*qpow(k-i,MOD-2)%MOD;
		int fm=inv[i-1]*inv[n+2-i]%MOD;
		if((n+2-i)%2) fm=-fm;
		ans=(ans+fz*fm)%MOD;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k;ffor(i,1,n+2) pre[i]=(pre[i-1]+qpow(i,n))%MOD;
	inv[0]=1; ffor(i,1,n+2) inv[i]=inv[i-1]*qpow(i,MOD-2)%MOD;
	ffor(i,1,n+2) mul=mul*(k-i-1)%MOD;
	int ans=k,inv=qpow(k,MOD-2);
	ans=(ans-solve(k-1)*qpow(inv,n))%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---


# [CrCPC 2024] 传传爆

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) G.

2025/3/19：加入一组来自 @_lmh_ 的 hack 数据，位于 Subtask 0。

## 题目描述

有一个 $n\times m$ 的矩阵，左上角的格子记为 $(1,1)$，右下角的格子记为 $(n,m)$。

格子要么是黑色的，要么是白色的。魔法少女从 $(1,1)$ 出发寻找食物，按照如下规则移动：

- 每次可以向上下左右移动一步，但是不能出界。
- 如果移动到黑色格子，则无事发生。
- 如果移动到白色格子，魔法少女会被**等概率独立随机**传送到任意一个白色格子（包括她所在的格子）上。传送完后可以继续移动。

当魔法少女到达 $(n,m)$ 时，她会停止移动。**魔法少女会最小化移动的期望次数**。求出魔法少女移动的期望步数。

**题目保证 $(1,1)$ 和 $(n,m)$ 都是黑色的。**


## 说明/提示

- $1\le T\le 10^3$；
- $1\le n,m\le 10^3$；
- $\sum nm\le 10^6$。



## 样例 #1

### 输入

```
3
2 2
CC
CC
2 2
CB
BC
1 12
CBCCCCCCCCBC```

### 输出

```
2/1
2/1
4/1```

## 样例 #2

### 输入

```
1
6 2
CC
CC
CC
CC
CC
CC```

### 输出

```
6/1```

## 样例 #3

### 输入

```
1
6 3
CBC
CBC
CBC
CBC
CBC
CBC```

### 输出

```
4/1```

# 题解

## 作者：_lmh_ (赞：2)

一些题外话：我提供了一份 hack 数据，但你可以当它不存在。理论上任何你认为正确并且能通过其他测试点的做法都能通过。

首先终点一定是黑格，考虑它所在的联通块，只有和这个联通块相邻的白点可以走过来，否则就必须要重开到另一个白点。当然，起点有可能可以直接走到终点，但此时用白格进行传送可能会更快。下文中只考虑需要走白格的情况。

所有白格都是一样的，所以肯定是先走到最近的一个。之后把白格分成两类：一种是旁边有其他白格的，此时走一步就可以重开；否则，需要走两步才能重开。

观察样例发现有时我们可以直接从白格走到终点但依然选择了重开，所以猜测对两类点都存在一个阈值，如果它到终点的距离小于等于阈值就直接往终点走，否则就重开。

具体地，假设原来两类点各有 $s_1,s_2$ 个，小于等于阈值的点各有 $a_1,a_2$ 个，它们到终点的总距离为 $d$，则第一次进入白格之后走到终点所需时间的期望为 

$$\frac{d}{a_1+a_2}+\frac{s_1-a_1+s_2-a_2}{a_1+a_2}\cdot\frac{s_1-a_1+2(s_2-a_2)}{s_1-a_1+s_2-a_2}=\frac{d+s_1-a_1+2(s_2-a_2)}{a_1+a_2}$$

枚举所有可能的阈值，时间复杂度 $O(\sum n^2m^2)$，可以通过原题的所有数据，**但不能通过 hack 数据**。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1007,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
struct frac{
	ll p,q;
}ans;
bool cmp(const frac& a,const frac& b){return a.p*b.q<a.q*b.p;}
ll T,n,m,dis[N][N],a[N][N],vis[N][N],s1,s2,c1[N*N],c2[N*N],stk1[N*N],top1,stk2[N*N],top2,sum;
char s[N];
queue<pair<int,int> > q;
frac operator +(const frac& a,const frac& b){return (frac){a.p*b.q+a.q*b.p,a.q*b.q};}
frac operator *(const frac& a,const frac& b){return (frac){a.p*b.p,a.q*b.q};}
frac calc(ll x,ll y,ll X,ll Y){
	return (frac){X+Y+sum-x-y*2,x+y}+(frac){dis[1][1],1};
}
void bfs(){
	for (int i=0;i<=n+1;++i) for (int j=0;j<=m+1;++j) dis[i][j]=vis[i][j]=0;
	q.push(make_pair(n,m));vis[n][m]=1;
	while(!q.empty()){
		auto p=q.front();q.pop();
		int x=p.first,y=p.second;
		if (a[x][y]==-1) continue;
		if (a[x][y]){
			if (a[x][y]==2) ++c2[dis[x][y]];
			else ++c1[dis[x][y]];
			continue;
		}
		for (int k=0;k<4;++k) if (!vis[x+dx[k]][y+dy[k]]){
			vis[x+dx[k]][y+dy[k]]=1;
			dis[x+dx[k]][y+dy[k]]=dis[x][y]+1;
			q.push(make_pair(x+dx[k],y+dy[k]));
		}
	}
}
int bfs2(){
	for (int i=0;i<=n+1;++i) for (int j=0;j<=m+1;++j) dis[i][j]=vis[i][j]=0;
	q.push(make_pair(1,1));vis[1][1]=1;
	while(!q.empty()){
		auto p=q.front();q.pop();
		int x=p.first,y=p.second;
		if (a[x][y]==-1) continue;
		if (a[x][y]){
			while(!q.empty()) q.pop();
			return dis[x][y];
		}
		for (int k=0;k<4;++k) if (!vis[x+dx[k]][y+dy[k]]){
			vis[x+dx[k]][y+dy[k]]=1;
			dis[x+dx[k]][y+dy[k]]=dis[x][y]+1;
			q.push(make_pair(x+dx[k],y+dy[k]));
		}
	}
	return 0;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>m;
		for (int i=0;i<=n+1;++i) a[i][0]=a[i][m+1]=-1;
		for (int i=0;i<=m+1;++i) a[0][i]=a[n+1][i]=-1;
		ans=(frac){1,0};
		for (int i=1;i<=n;++i){
			cin>>(s+1);
			for (int j=1;j<=m;++j) a[i][j]=(s[j]=='B'?2:0);
		}
		for (int i=1;i<=n;++i) for (int j=1;j<=m;++j) if (a[i][j]==2){
			for (int k=0;k<4;++k) if (a[i+dx[k]][j+dy[k]]>0) a[i][j]=1;
			if (a[i][j]==1) ++s1;else ++s2;
		}
		bfs();
		if (vis[1][1]) ans=(frac){dis[1][1],1};
		dis[1][1]=bfs2();
		if (s1||s2){
			sum=s1+2*s2;top1=top2=1;
			for (int i=1;i<=n*m;++i){
				if (c1[i]) stk1[++top1]=i;
				if (c2[i]) stk2[++top2]=i;
			}
			ll S1=0,S2=0,len1=0,len2=0;
			for (int i,_=1;_<=top1;++_){
				i=stk1[_];
				S2=len2=0;S1+=c1[i];len1+=c1[i]*i;
				for (int j,_=1;_<=top2;++_){
					j=stk2[_];
					S2+=c2[j];len2+=c2[j]*j;
					auto p=calc(S1,S2,len1,len2);
					if (cmp(p,ans)) ans=p;
				}
			}
		}
		int g=__gcd(ans.p,ans.q);
		cout<<ans.p/g<<'/'<<ans.q/g<<'\n';
		for (int i=0;i<=n*m;++i) c1[i]=c2[i]=0;s1=s2=0;
	}
	return 0;
}
```

但为了防止第二天一觉醒来发现自己题解被撤下来了还是给个复杂度有道理的做法吧。

令 $s=s_1+2s_2$，现在我们固定第二类点的阈值，计算最优的第一类点的阈值。

在原来的 $\frac{d+s-a_1-2a_2}{a_1+a_2}$ 上面加入一个距离为 $k$ 的第一类点，需要让答案变小，则

$$\frac{d+k+s-(a_1+1)-2a_2}{a_1+a_2+1}<\frac{d+s-a_1-2a_2}{a_1+a_2}$$

$$k<\frac{d+s-a_2}{a_1+a_2}$$

不难发现，如果我们加入了一个距离较大的点，把它替换为距离更小的点一定不劣；观察式子还会发现，在从小到大加入点的过程中，距离相同的点要么都被加入要么都不被加入。并且右边的式子单调不增，左边的式子单调不降，可以二分。

时间复杂度 $O(\sum(nm\log nm))$。下面仅给出关键部分代码。应该可以做到更优但懒得搞了。

```cpp
bfs();
if (vis[1][1]) ans=(frac){dis[1][1],1};
dis[1][1]=bfs2();
if (s1||s2){
	sum=s1+2*s2;
	for (int i=1;i<=n*m;++i){
		d1[i]=d1[i-1]+c1[i]*i;
		d2[i]=d2[i-1]+c2[i]*i;
		c1[i]+=c1[i-1];c2[i]+=c2[i-1];
	}
	for (int i=0;i<=n*m;++i) if (i==0||c2[i]!=c2[i-1]){
		ll l=1,r=n*m,pos=0;
		while(l<=r){
			ll mid=l+r>>1;
			if ((d1[mid-1]+d2[i]+sum-c2[i])>(c1[mid-1]+c2[i])*mid) pos=mid,l=mid+1;
			else r=mid-1;
		}
		auto p=calc(c1[pos],c2[i],d1[pos],d2[i]);
		if (cmp(p,ans)) ans=p;
	}
}
int g=__gcd(ans.p,ans.q);
assert(ans.q);
cout<<ans.p/g<<'/'<<ans.q/g<<'\n';
for (int i=0;i<=n*m;++i) c1[i]=c2[i]=d1[i]=d2[i]=0;
s1=s2=0;
```

---

## 作者：P_Bisector (赞：1)

设在白格上时到达终点的期望步数为 $E$。设白格个数为 $N$。设第 $i$ 个白格到达终点的期望步数为 $A_i$，则显然有：

$$E=\frac{\sum_{i=1}^NA_i}{N}$$

我们考虑当我们被扔到一个随机白格以后，我们有两种走法：

- 移动到距离当前点最近的白格（包括当前格）“重开”。设该距离为 $t_i$。其中：

  - 如果有相邻的白格，移动至该格，一步，$t_i=1$。
  - 如果没有相邻的白格，绕一圈回到自己，两步，$t_i=2$。

- 直接在不经过任何白点的情况下移动到终点。设该距离为 $T_i$。

易得 $A_i=\min\{E+t_i,T_i\}=\min\{E,T_i-t_i\}+t_i$。

代入上文的式子中有：

$$E=\frac{\sum_{i=1}^N\min\{E,T_i-t_i\}+\sum_{i=1}^N t_i}{N}$$

将格子按照 $T_i-t_i$ 升序排序，枚举第一个大于 $E$ 的 $T_i-t_i$，设该位置为 $j$，有：

$$E=\frac{\sum_{i=1}^j(T_i-t_i)+(N-j+1)E+\sum_{i=1}^N t_i}{N}$$

变形得：

$$E=\frac{\sum_{i=1}^j(T_i-t_i)+\sum_{i=1}^N t_i}{j-1}$$

上式中所有求和均可使用前缀和进行维护。记录 $E$ 的最小值即可。易证当算出的 $E$ 不满足枚举时的条件时一定不优。

除此以外，还有一些 corner cases 需要注意：

- 未必一定要经过白点。有可能直接走是最优的。
- 如果钦定经过白点，要计算距离黑点最近的白点的位置。
- 不要忘了约分。

::::info[代码如下]
```cpp
#include<bits/stdc++.h>
#define B7 __int128
#define pb push_back
#define PLL pair<int,int>
#define U6 unsigned long long
#define f first
#define s second
#define Qin ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;void solve();void init();
void file(string s){freopen((s+".in").c_str(),"r",stdin);freopen((s+".out").c_str(),"w",stdout);}
int main(){Qin;init();int t,M=1;M?(cin>>t,0):t=1;while(t--)solve();return 0;}
#define int long long
const int inf=1e10,N_=100050,mod=998244353,P=1e9+7,N=1e6+50,N2=5050;
void init(){}
int a[N2][N2],f[N2][N2],n,m,dx[4]{0,1,-1,0},dy[4]{1,0,0,-1};
void bfs(int x,int y){
    queue<PLL>q;
    q.push({x,y});
    while(!q.empty()){
        PLL h=q.front();
        q.pop();
        int x=h.f,y=h.s;
        for(int i=0;i<4;i++){
            int X=x+dx[i],Y=y+dy[i];
            if(f[X][Y]>inf/100&&a[X][Y])q.push({X,Y}),f[X][Y]=f[x][y]+1;
        }
    }
}
vector<PLL>v;//T-t,t;
B7 GCD(B7 x,B7 y){
    if(x==0||y==0)return x^y;
    if(x<y)swap(x,y);
    return GCD(min(x,y),max(x,y)%min(x,y));
}
struct fraction{
    B7 p,q;
    fraction(B7 x,B7 y){B7 g=GCD(x,y);p=x/g,q=y/g;}
};
bool operator<(fraction a,fraction b){
    return B7(a.p)*b.q<B7(a.q)*b.p;
}
B7 S[N],*s=S+1;
void solve(){
    v.clear();
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            char c;
            cin>>c;
            if(c=='C')a[i][j]=1;
            else a[i][j]=0;
            f[i][j]=inf;
        }
    }
    f[n][m]=0;
    for(int i=0;i<=max(n,m);i++)a[0][i]=a[n+1][i]=a[i][0]=a[i][m+1]=0;
    for(int i=0;i<=max(n,m);i++)f[0][i]=f[n+1][i]=f[i][0]=f[i][m+1]=inf;
    bfs(n,m);
    for(int i=0;i<=max(n,m);i++)a[0][i]=a[n+1][i]=a[i][0]=a[i][m+1]=1;
    int sumt=0;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
        if(a[i][j]==0){
            int t=2,T=inf;
            for(int k=0;k<4;k++){
                int I=i+dx[k],J=j+dy[k];
                if(a[I][J]==0)t=1;
                else T=min(T,f[I][J]+1);
            }
            v.pb({T-t,t});
            sumt+=t;
        }
    }
    sort(v.begin(),v.end());
    for(int i=0;i<v.size();i++)s[i]=s[i-1]+v[i].f,s[i]=min(s[i],(B7)inf);
    fraction ans(inf,1);
    for(int i=0;i<v.size();i++){
        ans=min(ans,fraction(s[i]+sumt,i+1));
    }
    for(int i=0;i<=max(n,m);i++)a[0][i]=a[n+1][i]=a[i][0]=a[i][m+1]=0;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)f[i][j]=inf;
    f[1][1]=0,bfs(1,1);
    int ans2=inf;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
        if(a[i][j]==0){
            for(int k=0;k<4;k++){
                int I=i+dx[k],J=j+dy[k];
                ans2=min(ans2,f[I][J]+1);
            }
        }
    }
    ans.p+=ans2*ans.q;
    B7 g=GCD(ans.p,ans.q);ans.p/=g,ans.q/=g;
    ans=min(ans,fraction(f[n][m],1));
    cout<<(int)ans.p<<"/"<<(int)ans.q<<endl;
}
```
::::

---

## 作者：Shxt_Plus (赞：1)

首先发现走到哪个白点都一样，所以可以通过每个白点走到别的白格的最少步数来分类，显然只有两种情况：一步，两步。

不妨将一步就能走到别的白格的点称作 1 类点，其他白点称为 2 类点。

在无法直接抵达终点的情况下，显然相同类型的点的期望步数是一样的，用 $g_1$ 表示一类点的期望步数，用 $g_2$ 表示二类点的期望步数。

先假设能直接到达终点的点都直接走去终点，将这些点的总步数设为 $G$ 。

令 $s$ 为总共的白点数量，$s_1$，$s_2$ 分别为一类点和二类点的个数，显然有：

$$ g_1=\frac{s_1}{s}g_1+\frac{s_2}{s}g_2+\frac{G}{s-s_1-s_2}+1$$

$$ g_2=\frac{s_1}{s}g_1+\frac{s_2}{s}g_2+\frac{G}{s-s_1-s_2}+2$$

二式减一式得

$$g_2-g_1=1$$

将 $g_2=g_1+1$ 代入一式，得

$$
\begin{aligned}
g_1&=\frac{s_1}{s}g_1+\frac{s_2}{s}(g_1+1)+\frac{G}{s-s_1-s_2}+1\\
&=\frac{s_1+s_2}{s}g_1+\frac{s_2}{s}+\frac{G}{s-s_1-s_2}+1\\
\frac{s-s_1-s_2}{s}g_1&=\frac{s_2}{s}+\frac{G}{s-s_1-s_2}+1\\
g1&=(\frac{s_2}{s}+\frac{G}{s-s_1-s_2}+1)\times \frac{s}{s-s_1-s_2}
\end{aligned}
$$

发现有些直接走到终点的白格可能通过走白格的期望步数会更小，把这些格子当成无法直接抵达的白格（也就是直接累加到 $s_1$，$s_2$ 中），更新 $g_1$，再寻找是否有白格可以更优，直到没有白格可以更优时，这时的 $g1$ 加上起点到白格的最短距离减一就是答案。

因为每个点只会被优化一次，所以复杂度是 $O(nm\log nm)$ 的，瓶颈是排序，实际上可以在 bfs 的过程中顺便确定顺序，所以可以 $O(nm)$。

因为我比较懒，所以只打了 $O(nm\log nm)$ 的做法，还喜提最劣解，如果有人用 $O(nm)$ 做法拿了最优解请在评论区告诉我。

Code：

```cpp
#include<bits/stdc++.h>
#define get(i,j) ((i)*m-m+(j))
using ll=long long;
using namespace std;
const int maxn=1e6+5;
char a[maxn];
int n,m;
inline ll gcd(ll x, ll y) {
	if(!y) return x;
	return gcd(y, x % y);
}
struct frac
{
	ll d,v;
	frac(ll _x = 1, ll _y = 0) {
		d = _x, v = _y;
		if(d==0||v==0)d=1;
		ll g = gcd(d,v);
		d /= g, v /= g;
	}
	frac operator +(const frac o)
	{
		return frac(o.d*d,v*o.d+o.v*d);
	} 
	frac operator -(const frac o)
	{
		return frac(o.d*d,v*o.d-o.v*d);
	} 
	frac operator *(const frac o)
	{
		return frac(o.d*d,v*o.v);
	} 
	bool operator <(const frac &o)const
	{
		return v*o.d<d*o.v;
	} 
	bool operator >(const frac &o)const
	{
		return v*o.d>d*o.v;
	} 
}g1,g2,s;
int s1,s2,sb;
int d[15]={0,1,-1,m,-m};
priority_queue<frac>f1,f2;
int dis[maxn],dis1[maxn];
queue<int>q,q1;
int mindis=1e8;
void bfs()
{
	for(int i=1;i<=n*m;i++)dis[i]=1e8;
	dis[n*m]=0;
	while(!q.empty())q.pop();
	while(!q1.empty())q1.pop();
	q.push(n*m);
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		for(int i=1;i<=4;i++)
		{
			int t1=t+d[i];
			if(t1<=0 || t1>n*m)continue;
			if(d[i]==1 && t1%m==1)continue;
			if(d[i]==-1 && t1%m==0)continue;
			if(dis[t1]>dis[t]+1 && a[t1]!='B')
			{
				dis[t1]=dis[t]+1;
				q.push(t1);
			}
		}
	}
}
void bfs1()
{
	for(int i=1;i<=n*m;i++)dis1[i]=1e8;
	dis1[1]=0;
	while(!q.empty())q.pop();
	while(!q1.empty())q1.pop();
	q.push(1);
	while(!q.empty())
	{
		int t=q.front();
		if(a[t]=='B')
		{
			mindis=dis1[t];
			break;
		}
		q.pop();
		for(int i=1;i<=4;i++)
		{
			int t1=t+d[i];
			if(t1<=0 || t1>n*m)continue;
			if(d[i]==1 && t1%m==1)continue;
			if(d[i]==-1 && t1%m==0)continue;
			if(dis1[t1]>dis1[t]+1)
			{
				dis1[t1]=dis1[t]+1;
				q.push(t1);
			}
		}
	}
}
int main()
{
//	freopen("P11937_4.in","r",stdin);
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m);
		d[3]=m,d[4]=-m;
		for(int i=1;i<=n;i++)
		{
			scanf("%s",a+(i-1)*m+1);
		}
		sb=0,s1=0,s2=0;
		s=frac(1,0);
		g1=frac(1,0);
		g2=frac(1,0);
		for(int i=1;i<=n*m;i++)if(a[i]=='B')sb++;
		while(!f1.empty())f1.pop();
		while(!f2.empty())f2.pop();
		bfs();
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			if(a[get(i,j)]=='B')
			{
				bool o=1;
				if(i!=1 && a[get(i-1,j)]=='B')o=0;
				if(j!=1 && a[get(i,j-1)]=='B')o=0;
				if(i!=n && a[get(i+1,j)]=='B')o=0;
				if(j!=m && a[get(i,j+1)]=='B')o=0;
				int minn=1e8;
				if(i!=1)minn=min(minn,dis[get(i-1,j)]);
				if(j!=1)minn=min(minn,dis[get(i,j-1)]);
				if(i!=n)minn=min(minn,dis[get(i+1,j)]);
				if(j!=m)minn=min(minn,dis[get(i,j+1)]);
				if(minn!=1e8)
				{
					if(!o)f1.push(frac(1,minn+1));
					else f2.push(frac(1,minn+1));
					s=s+frac(sb,minn+1);
					continue;
				}
				if(!o)s1++;
				else s2++;
			}
		}
		while(1)
		{
			g1=(s+frac(sb,s2)+frac(1,1))*frac(sb-s1-s2,sb);
			g2=g1+frac(1,1); 
			if(!f1.empty() && g1<f1.top())
			{
				s1++;
				frac p=f1.top();
				s=s-(p*frac(sb,1));
				f1.pop();
				continue;
			}
			if(!f2.empty() && g2<f2.top())
			{
				s2++;
				frac p=f2.top();
				s=s-(p*frac(sb,1));
				f2.pop();
				continue;
			}
			break;
		}
		bfs1();
		frac ans=frac(1,0);
		ans=frac(1,mindis)+g1-frac(1,1);
		if(ans>frac(1,dis[1]))
		{
			cout<<dis[1]<<"/1"<<"\n";
		}
		else cout<<ans.v<<"/"<<ans.d<<"\n";
	}
	return 0;
}
```

---


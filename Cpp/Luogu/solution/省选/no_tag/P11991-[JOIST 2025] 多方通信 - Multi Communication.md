# [JOIST 2025] 多方通信 / Multi Communication

## 题目背景

你可以提交数据生成器，也可以提交三个 $\texttt{.txt}$ 文件（$\texttt{1.txt}\sim \texttt{3.txt}$）。


## 题目描述


**这是一道提交答案题。**

K 主席为春季训练营的参与者准备了一个游戏。 

训练营中共有 $N$ 名参与者，每人被分配一个从 $1$ 到 $N$ 的唯一编号。每位参与者拥有一块白板。游戏按以下步骤进行：

1. K 主席选择一名参与者作为父节点（parent），其余参与者成为子节点（children）。但**父节点的身份不会向参与者公开**。  
2. K 主席在父节点的白板上写下字母 $\texttt{T}$，在所有子节点的白板上写下字母 $\texttt{F}$。  
3. 每位参与者阅读自己白板上的字母。然后，按照预先定义好的策略，执行以下回合制流程（共 $L$ 个回合）：  
   - 每位参与者擦除白板上的字母，并写下 $\texttt{T}$ 或 $\texttt{F}$，然后将白板提交给 K 主席。  
   - 对于每个参与者 $i$（$i = 1, 2, \ldots, N$）：
        - 参与者 $i$ 选择一个参与者 $p$（$1 \leq p \leq N$）并将编号 $p$ 告知 K 主席。  
        - K 主席将参与者 $p$ 的白板展示给参与者 $i$，参与者 $i$ 读取上面的字母。参与者可以选择自己作为 $p$。  
4. 经过 $L$ 个回合后，每位参与者必须猜测谁是父节点。  

游戏的目标是预先制定一个策略，使得无论谁被选为父节点，所有参与者都能在此流程结束时正确识别父节点。  

**更小的 $L$ 值意味着更高的得分**。你的目标是设计一个策略，在保证所有参与者能正确识别父节点的前提下，最小化 $L$。  

一个**策略**由以下两部分组成：  
- 一个非负整数 $L$，表示回合数；  
- 一组规则，用于确定每个参与者的行为。规则如下：  
  - 对于参与者 $i$（$1 \leq i \leq N$），在第 $t$ 个回合开始时（$1 \leq t \leq L$），若其已读取的字母序列为 $a_0, a_1, \ldots, a_{t-1}$，则仅基于这些信息（$i$, $t$, $a_0, a_1, \ldots, a_{t-1}$），必须确定：  
    - 在该回合要写入白板的字母；  
    - 在该回合选择观察的参与者编号。  
  - 对于参与者 $i$（$1 \leq i \leq N$），在第 $L$ 个回合结束后，若其已读取的字母序列为 $a_0, a_1, \ldots, a_L$，则仅基于这些信息（$i$, $L$, $a_0, a_1, \ldots, a_L$），必须推断出父节点的编号。  

请设计一个允许所有参与者正确识别父节点的策略（无论父节点是谁）。然后，针对每个可能的父节点选择（$1, 2, \ldots, N$），输出每位参与者按此策略在各回合写入白板的值和选择观察的参与者编号。  

## 说明/提示


### 样例解释

样例中，参与者的策略如下：
- 令 $L = 3$。  
- 在每回合 $t$（$1 \leq t \leq L$）中：  
    - 参与者 $i$ 若其为父节点则写入 $\texttt{T}$，若为子节点则写入 $\texttt{F}$（根据初始步骤看到的字符，他们知道自己是否为父节点）。  
- 在每回合 $t$（$1 \leq t \leq L$）中：  
    - 参与者 $i$ 观察参与者 $t$，无论其当前已读取的字母序列如何。  
- 经过 $3$ 个回合后，每位参与者将恰好读取过包括自己在内的所有参与者的白板各一次。每位参与者将选择白板上出现过 $\texttt{T}$ 的参与者编号作为父节点。  

该策略确保所有人正确识别父节点，达成游戏目标。由于此策略在任何父节点选择下均满足游戏要求，因此输出被视为正确。  

注意：样例不在实际测试数据中，因其不满足题目给定的约束条件。  


### 数据范围

$N\in \{4,32,48\}$。

更为具体地说：

- 测试点 $1$ 中，$n=4$。
- 测试点 $2$ 中，$n=32$。
- 测试点 $3$ 中，$n=48$。

### 计分方式

当且仅当输出符合以下条件时，才被视为正确：该输出是通过参与者遵循一个**有效策略**（确保所有参与者都能正确识别父节点）所产生的结果。具体而言，必须满足以下两个条件：  
1. 对于任意参与者 $i$（$1 \leq i \leq N$）、任意回合 $t$（$1 \leq t \leq L$）以及任意两个不同的父节点候选 $x$ 和 $y$（$1 \leq x, y \leq N$ 且 $x \neq y$）：若参与者 $i$ 在回合 $t$ 之前读取的字母序列在 $x$ 为父节点和 $y$ 为父节点时完全相同，则参与者 $i$ 必须在回合 $t$ 采取相同的行动（即写入相同的字母并选择相同的观察对象）。  
2. 对于任意参与者 $i$（$1 \leq i \leq N$）以及任意两个不同的父节点候选 $x$ 和 $y$（$1 \leq x, y \leq N$ 且 $x \neq y$）：当 $x$ 为父节点时，参与者 $i$ 在第 $L$ 个回合结束时读取的字母序列必须与 $y$ 为父节点时的序列不同。  

---

该题的得分为三个测试点的得分之和。  

若输出不正确（例如格式错误或未遵循有效策略），则该测试点得 $0$ 分。  

否则，若输出正确，则按以下标准计算得分：  

| 测试点编号   | $N=$   | 计分方式 | 满分 |
|:-:|:-:|-|:-:|
| $1$       | $4$   | $\displaystyle \textsf{得分}=\begin{cases} 0 & 4\lt L \\ 16-7\cdot (L-2) & 2\lt L\le 4 \\ 16 & L\le 2\end{cases}$| $16$ |
| $2$       | $32$  | $\displaystyle \textsf{得分}=\begin{cases} 0 & 27\lt L \\ 60-3(L-8) & 8 < L \leq 27 \\ 60 & L\le 8\end{cases}$ | $60$ |
| $3$       |  $48$  | $\displaystyle \textsf{得分}=\begin{cases} 0 & 9\lt L \\ 24 & L\le 9 \end{cases}$ | $24$  |



## 样例 #1

### 输入

```
3```

### 输出

```
3
1
T 1 T 2 T 3
F 1 F 2 F 3
F 1 F 2 F 3
2
F 1 F 2 F 3
T 1 T 2 T 3
F 1 F 2 F 3
3
F 1 F 2 F 3
F 1 F 2 F 3
T 1 T 2 T 3```

# 题解

## 作者：FFTotoro (赞：5)

思路提供自 @[0x824EE](https://www.luogu.com.cn/user/533742) 大佬。

很智慧的题。$N=4$ 的构造较为简单，在此略过。

考虑 $N=32$ 怎么做。建出一棵[二叉索引树](https://oi-wiki.org/ds/fenwick/)（又称“树状数组”），方便之后的求解。

不妨让每个结点在经过某些预处理后的所有轮次中，在自己的黑板上写的字母固定。尝试预处理这样的信息：一个结点在之后的轮次中黑板上的字母为 $\texttt{T}$，当且仅当其子树内含有“Parent”。使用如下的策略进行预处理：对于一个结点 $u$，它应该在预处理的过程中，在儿子的信息处理完之后，读取它的儿子的信息（某个儿子信息处理完，它直接在下一轮读取），并根据儿子的信息**修改自己的信息**。特别地，我们不需要处理结点 $N$ 的信息，因为之后的过程中并不需要它。这总共需要 $\log_2N-1=4$ 轮。

接着在树上二分，假设当前确定的区间为 $[L,R]$，令中点 $M=\left\lfloor\frac{L+R}{2}\right\rfloor$，查询“Parent”是否在 $[L,M]$ 之间（由于 $N=32$ 的特殊性，每个查询的区间必然都对应一棵子树）。这总共需要 $\log_2N=5$ 轮。

但是限定的次数为 $8$ 轮，而我们需要 $4+5=9$ 轮！观察到在预处理的时候，都是父亲在读取儿子的信息，有一些东西被浪费了。

考虑“父亲读取儿子信息”的本质，其实就相当于对于一个区间 $[L,R]$，设其中点为 $M=\left\lfloor\frac{L+R}{2}\right\rfloor$，在某一轮中将 $M$ 的信息传到了 $R$ 上。由于只需要压掉一个轮数，所以考虑在预处理的每一轮中，使 $[L,M]$ 都读取 $R$ 的信息、$[M+1,R]$ 都读取 $M$ 的信息（但是**不一定要修改自己的信息**），这样就可以免去二分的第一次（因为这样所有人都可以推断出“Parent”在 $\left[1,\frac{N}{2}\right]$ 还是 $\left[\frac{N}{2}+1,N\right]$ 里）。于是成功地把轮数压进了 $8$，并且这种“合并区间”的思路还意外地使写法变得简洁了很多，一个递归就可以实现。

尝试把思路拓展到 $N=48$。$48$ 没有 $32$ 那么良好的性质，但是可以敏锐地发现 $48=16\times 3$，并且相较于 $N=32$ 多给了一轮次数（即可以传递 $9$ 轮信息）。沿用原来的思路处理 $[1,16]$、$[17,32]$ 和 $[33,48]$ 的子树信息，使用多出来的那一轮次数，让所有结点都知道“Parent”在三棵子树中的哪一棵中（只需要在另外两棵子树中随便选一棵询问）。然后按照原来的方法在目标子树内二分即可。

下面给出 $N=48$ 时生成答案的代码，仅供参考。另外本人编写了一个简易版 SPJ（只能判断你的答案是否合法，并不能根据 $N$ 和 $L$ 来判断你的得分），方便大家调试，各位可以自行取用。

生成答案代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int lowbit(int x){
  return x&-x;
}
int main(){
  freopen("output_03.txt","w",stdout);
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n=48,l=9; cout<<l<<endl;
  for(int i=1;i<=n;i++){
    cout<<i<<endl;
    vector C(n+1,vector<char>(l,'F'));
    vector P(n+1,vector<int>(l));
    function<void(int,int,int)> dfs=[&](int l,int r,int d){
      if(l==r)return;
      int m=l+r>>1;
      dfs(l,m,d-1),dfs(m+1,r,d-1);
      for(int j=l;j<=m;j++)
        P[j][d]=r;
      for(int j=m+1;j<=r;j++)
        P[j][d]=m;
      for(int j=l;j<=r;j++)
        if(C[j][d]=='F')C[j][d]=d?C[j][d-1]:(j==i?'T':'F');
      if(C[m][d]=='T')C[r][d+1]='T';
    }; // 递归预处理信息
    dfs(1,n/3,3),dfs(n/3+1,n/3*2,3),dfs(n/3*2+1,n,3);
    for(int i=1;i<=n/3;i++)
      if(P[i][4]=n;C[i][4]=='F')C[i][4]=C[i][3];
    for(int i=n/3+1;i<=n;i++)
      if(P[i][4]=n/3;C[i][4]=='F')C[i][4]=C[i][3];
    int x,y;
    if(i<=n/3)x=1,y=n/3;
    else if(i<=n/3*2)x=n/3+1,y=n/3*2;
    else x=n/3*2+1,y=n;
    for(int j=5;j<l;j++){
      for(int p=1;p<=n;p++)
        C[p][j]=C[p][j-1];
      int m=x+y>>1;
      for(int p=1;p<=n;p++)
        P[p][j]=m;
      if(i<=m)y=m;
      else x=m+1;
    } // 二分过程
    for(int j=1;j<=n;j++,cout<<endl)
      for(int k=0;k<l;k++)
        cout<<C[j][k]<<' '<<P[j][k]<<' ';
  }
  return 0;
}
```

Special Judge：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  freopen("output_03.txt","r",stdin);
  int n=48,l; cin>>l;
  vector c(n,vector(n,vector<char>(l)));
  vector p(n,vector(n,vector<int>(l)));
  for(int i=0;i<n;i++){
    int x; cin>>x;
    for(int j=0;j<n;j++)
      for(int k=0;k<l;k++)
        cin>>c[i][j][k]>>p[i][j][k],p[i][j][k]--;
  }
  bool f1=true,f2=true;
  for(int x=0;x<n;x++)
    for(int y=0;y<n;y++)
      if(x!=y){
        for(int a=0;a<n;a++){
          string s=(a==x?"T":"F"),t=(a==y?"T":"F");
          for(int i=0;i<l;i++){
            if(s==t)f1&=c[x][a][i]==c[y][a][i]&&p[x][a][i]==p[y][a][i];
            s+=c[x][p[x][a][i]][i],t+=c[y][p[y][a][i]][i];
          }
          f2&=s!=t;
        }
      }
  cout<<"Condition 1: "<<(f1?"Yes\n":"No\n");
  cout<<"Condition 2: "<<(f2?"Yes\n":"No\n");
  cout<<(f1&&f2?"Accepted\n":"Wrong Answer\n");
  return 0;
}
```

---

## 作者：__Cby___ (赞：2)

## 思路
我们在环上考虑这个问题。   
首先考虑 $n=4$ 的情况，每个人知道他自己的信息，那么他只需要再知道两个人的信息就知道所有人的信息了。     
接下来考虑 $n=32$ 的情况，前 $4$ 步先倍增，在第 $i$ 步中每个人显示出他到从他开始往后的第 $2^{i-1}$ 个人中是否存在父节点，同时查询他后面的第 $2^{i-1}$ 个人显示的数，这样在这一轮他就知道 $2^i$ 个人的信息，在下一轮就可以显示出来。  
接下来，由于每个人知道了从他开始的 $16$ 个人中是否有父节点，也就知道了他之前的 $16$ 个人中是否有父节点。于是你在有父节点的 $16$ 个中二分，每次二分我们检查前一半是否有父节点，由于每一轮二分查询的区间长度固定，所以在第 $4+i$ 轮每个点输出从他开始的 $2^{4-i}$ 个节点中是否有父节点，然后每个点像二分一样查询就好了。  
考虑 $n=48$ 的情况，与 $n=32$ 的情况是类似的，多出来的那一步在于，$48$ 个人中要分成三组 $16$ 个人，是所以我们要多一次来查询父节点到底在哪组 $16$ 个人中。   
## 代码
结合代码可能会更好理解。  
```cpp
#include <iostream>
#define ll long long
#define R(a,b,c) for(ll a=b;a<=c;a++)
#define E(a,b,c) for(ll a=b;a>=c;a--)
using namespace std;
int main() {
//	freopen("2.txt","w",stdout);
	ll n;
	cin>>n;
	if(n==4) {
		cout<<R"(2
		    1
		    T 4 T 2
		    F 1 F 3
		    F 2 F 4
		    F 3 F 1
		    2
		    F 4 F 2
		    T 1 T 3
		    F 2 F 4
		    F 3 F 1
		    3
		    F 4 F 2
		    F 1 F 3
		    T 2 T 4
		    F 3 F 1
		    4
		    F 4 F 2
		    F 1 F 3
		    F 2 F 4
		    T 3 T 1)";
	}
	if(n==32) {

		cout<<8<<'\n';
		R(T,1,32) {
			cout<<T<<"\n";
			R(x,1,n) {
				ll t=T;
				if(t<x)t+=n;
				R(i,1,4) {
					cout<<(x<=t&&t<=x+(1<<i-1)-1?"T":"F")<<" "<<(x+(1<<i-1)-1)%n+1<<" ";
				}
				ll l,r;
				if(x<=t&&t<=x+n/2-1) {
					l=x;
					r=l+n/2-1;
					r=(r-1)%n+1;
				} else {
					l=x+n/2;
					r=l+n/2-1;
					l=(l-1)%n+1;
					r=(r-1)%n+1;
				}
				E(i,4,1) {
					cout<<(x<=t&&t<=x+(1<<i-1)-1?"T":"F")<<" "<<l<<" ";
					ll ttt=T;
					if(ttt<l)ttt+=n;
					if(l<=ttt&&ttt<=l+(1<<i-1)-1)r=l+(1<<i-1)-1;
					else l=l+(1<<i-1);
					l=(l-1)%n+1;
					r=(r-1)%n+1;
				}
				cout<<endl;
			}
		}
	}
	if(n==48) {

		cout<<9<<'\n';
		R(T,1,48) {
			cout<<T<<"\n";
			R(x,1,n) {
				ll t=T;
				if(t<x)t+=n;
				R(i,1,4) {
					cout<<(x<=t&&t<=x+(1<<i-1)-1?"T":"F")<<" "<<(x+(1<<i-1)-1)%n+1<<" ";
				}
				cout<<(x<=t&&t<=x+n/3-1?"T":"F")<<" "<<(x+n/3+n/3-1)%n+1<<" ";
				ll l,r;
				if(x<=t&&t<=x+n/3-1) {
					l=x;
					r=l+n/3-1;
					r=(r-1)%n+1;
				} else if(x+n/3<=t&&t<=x+n/3+n/3-1) {
					l=x+n/3;
					r=l+n/3-1;
					l=(l-1)%n+1;
					r=(r-1)%n+1;
				} else {
					l=x+n/3+n/3;
					r=l+n/3-1;
					l=(l-1)%n+1;
					r=(r-1)%n+1;
				}
				E(i,4,1) {
					cout<<(x<=t&&t<=x+(1<<i-1)-1?"T":"F")<<" "<<l<<" ";
					ll ttt=T;
					if(ttt<l)ttt+=n;
					if(l<=ttt&&ttt<=l+(1<<i-1)-1)r=l+(1<<i-1)-1;
					else l=l+(1<<i-1);
					l=(l-1)%n+1;
					r=(r-1)%n+1;
				}
				cout<<endl;
			}
		}
	}
	return 0;
}
```

---

## 作者：undefined_Ryan (赞：1)

很有意思的一道代码难度不高的构造题。

$N=4$ 的构造如下：所有参与者不改变自身信息，并读取另 $3$ 个参与者中 $2$ 个的信息。正确性是显然的。

以下以 $N=48$ 为例。$N=32$ 的做法是类似的。

首先需要认识到参与者改变自身信息的重要性，否则每个参与者最多只能知晓 $10$ 个人的身份，显然不能达到要求。

我们分析这样一个思路：所有参与者在前几个回合进行预处理并改变自身信息，然后通过所有参与者的预处理结果得到答案。

具体来说，我们需要构造一个 $k$ 使得每个参与者 $i$ 在前 $k$ 回合得到一个预先确定的集合 $S_i$ 使得该参与者知晓 $S_i$ 中的参与者是否有父节点，其中 $|S_i|$ 尽可能大且不超过 $\frac N2$，然后将这个结果写在白板上。接下来该参与者只需要根据所有 $S$ 的信息，在 $S_i$ 或 $\overline{S_i}$ 中得出答案。

容易发现 $|S_i|\le2^k$，注意到 $48=2^4+2^5$，考虑 $k=4$，此时取 $|S_i|=16$。然后答案的范围就是一个大小最大为 $32$ 的集合。因为 $2^5=32$，所以我们必须在每个回合中排除恰好一半的答案。

考虑二分。仔细构造一下，发现这样是可行的：取 $S_i=\{i,i+1,\cdots,i+15\}$，发现答案的范围就是一个连续段，而且预处理的信息也是连续段上的。考虑每回合询问当前连续段的右半部分是否有父节点，注意到询问时可以适当额外延伸出一段（因为那一段中一定不存在父节点），由此可以将右半部分延伸至长度为 $16$，然后通过一次读取操作解决。由此可以得出 $L=9$ 的构造。

如果父节点就在 $S_i$ 当中，可以少进行一轮二分，或者为了实现的方便可以扩展答案范围（下面的代码中采用了这种方法）。

最后是预处理：运用倍增方法，对于前 $4$ 回合，每回合记录先前知道的所有信息，然后依次读取 $i+1,i+2,i+4,i+8$。

答案生成器如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int ans[50][10],l,r,mid;
bool t[50][10];
int a(int x) {
    return (x-1)%48+1;
}
int main() {
    cout<<9<<endl;
    for (int i=1;i<=48;++i) {
        cout<<i<<endl;
        for (int j=1;j<=48;++j) ans[j][1]=a(j+1),ans[j][2]=a(j+2),ans[j][3]=a(j+4),ans[j][4]=a(j+8);
        for (int j=1;j<=48;++j) t[j][1]=(i==j);
        for (int j=1;j<=48;++j) t[j][2]=t[j][1]||t[ans[j][1]][1];
        for (int j=1;j<=48;++j) t[j][3]=t[j][2]||t[ans[j][2]][2];
        for (int j=1;j<=48;++j) t[j][4]=t[j][3]||t[ans[j][3]][3];
        for (int j=1;j<=48;++j) t[j][5]=t[j][4]||t[ans[j][4]][4],t[j][6]=t[j][5],t[j][7]=t[j][6],t[j][8]=t[j][7],t[j][9]=t[j][8];
        for (int j=1;j<=48;++j) {
            if (t[j][5]) l=j,r=j+32;
            else l=j+16,r=j+48;
            for (int k=5;k<=9;++k) {
                mid=(l+r)/2;
                ans[j][k]=a(mid);
                if (t[a(mid)][5]) l=mid;
                else r=mid;
            }
        }
        for (int j=1;j<=48;++j) for (int k=1;k<=9;++k) cout<<(t[j][k]?'T':'F')<<' '<<ans[j][k]<<" \n"[k==9];
    }
}
```

---

## 作者：ForgetOIDuck (赞：1)

### 前言

因为我切不了紫题，所以建议降蓝。（

### 题意

这是一道提交答案题。

共有 $N$ 个人玩一个游戏。每个人有一个白板，一开始有一个人的白板会被裁判写上 `T`，其他人的被写上 `F`。

每个人都知道自己白板上写了什么，但是不知道别人的。

接下来进行 $L$ 轮操作，要求通过这 $L$ 轮操作让每一个人根据自己得到的信息推断出一开始被写 `T` 的人身份是谁。

每轮操作分成两步：

1. 选择在自己的白板上写 `T` 或 `F`。

2. 向裁判询问某个人的白板在这一轮的第一步写了什么。

题目要求设计一个策略，使得 $L$ 尽量小。

- 游戏开始前所有人都知道并且遵守给定的策略。

- 不能偷看，每轮只能得知自己写的字母与通过询问获得的其他人（或者是自己）的字母。

- 策略应具有普适性，及对于任意一个人最开始得到 `T` 的情况使用同样的策略都能得到正确结果，而不是面向数据编程。~~当然我也不知道如此强大的判定方式 SPJ 是如何实现的。~~

特殊的题目数据范围：$N\in\set{ 4, 32, 48 }$，对应的 $L$ 要求最多为 $2,8,9$。

### 思路

- Subtask $1$，$N=4,L\le 2$

  令当前这一轮标红的写了 `T`，标黑的写了 `F`，$x\to y$ 表示 $x$ 询问了 $y$ 写的内容。

  由于每个人没有差别，于是不妨设最开始得到 `T` 的人是 $1$。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/uupi82hq.png)

  **令每轮每个人写的内容都是一开始裁判给定的字母**，每个人只要用两次操作询问两个**不是自己**的人就可以得到包括自己在内三个人是否为 `T` 的信息。由于所有人中有且只有一个 `T`，借此可以得出第四个人的信息。

  以 $2$ 为例，可以询问 $1,3$ 得到了 $1$ 是 `T`，借此可以推断出 $4$ 不是 `T`。

  总共花费的 $L$ 为 $2$。

- Subtask $1\dfrac{1}{3}$，$N=8,L\le ~?$

  容易发现 $32=2^5,4=2^2$，那么需要我们从 $8,16$ 一步步手模过来。

  首先是 $N=8$。我们发现如果按照刚刚 $N=4$ 的做法来制定策略会得到一个 $L=6$ 的结果，很明显这种方法并没有推广到 $N=32$ 的意义。

  我们发现刚刚我们的策略一直是建立在“**令每轮每个人写的内容都是一开始裁判给定的字母**”这个条件上，于是我们失去了许多传递更多信息的机会。

  于是我们赋予写出的字母 `T` 新的含义：不再仅仅代表自己是否是 `T`，而是某个区间里有没有 `T`。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/12oeiwt6.png)

  如图为第一轮，我们两两分组，每组之间互相查询。这样包含 `T` 的组内所有人就能用 $1$ 次操作得到谁是 `T` 的信息，不包含就能得知 `T` 在其它组。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/viqfdl8x.png)

  如图为第二轮，我们令包含 `T` 的组内所有人写上字母 `T`。于是这就转化成 $N=\frac{8}{2}=4$ 的问题。

  根据 Subtask #1 我们可以用 $2$ 次操作让所有人知道 `T` 属于哪个组。

  然后我们让 $2$ 重新写回 `F`、$1$ 保持 `T`，再让每个人用 $1$ 次操作在这一组的两个人中选择一个询问字母，根据得到的结果便能推断出 `T` 是谁。

  总共花费的 $L$ 为 $4$。

- Subtask $1\dfrac{2}{3}$，$N=16,L\le ~?$

  有了这个思路就可以进行简单的递归推广。

  还是先两两分组，进行 $1$ 次操作后转化成了 $N=8$ 的情况。再进行 $4$ 次操作，于是每个人都知道了 `T` 属于哪个两人组；最后让 $2$ 写回 `F`、$1$ 保持 `T`，每个人再询问 $1$，用 $1$ 次操作得出答案。

  总共花费的 $L$ 为 $6$。

- Subtask $2$，$N=32,L\le 8$

  有了这个递归的思路，就可以像刚刚那样，用 $3$ 次操作将所有人分成 $4$ 大段，再用 $2$ 次操作让每个人知道 `T` 属于哪个大段，最后用 $3$ 次操作每次缩小一半的范围，得出答案。

  总共花费的 $L$ 为 $8$。

- Subtask $3$，$N=48,L\le 9$

  注意到 $48=2^4\times 3$。我们依旧采用刚刚递归的思路，首先使用 $4$ 次操作将所有人分成长度为 $16$ 的 $3$ 大段，再用 $1$ 次操作让每个人知道 `T` 属于哪个大段（易证 $N=3$ 时 $L$ 可以为 $1$），最后用 $4$ 次操作每次缩小一半的范围，得出答案。

  总共花费的 $L$ 为 $9$。

这样就可以在 $O(1)$ (? 的时间复杂度内通过此题。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
char c[2] = {'F', 'T'}; 
bool b[102][102];
ll a[102][102];
int main() {
	int n;
	cin >> n;
	if (n == 4) {
		//手打的
		puts("2\n1\nT 2 T 3\nF 1 F 3\nF 1 F 2\nF 1 F 2\n2\nF 2 F 3\nT 1 T 3\nF 1 F 2\nF 1 F 2\n3\nF 2 F 3\nF 1 F 3\nT 1 T 2\nF 1 F 2\n4\nF 2 F 3\nF 1 F 3\nF 1 F 2\nT 1 T 2\n");
	}
	if (n == 32) {
		puts("8");
		for (ll s = 1; s <= 32; s ++ ) {
			cout << s << "\n";
			memset(b, 0, sizeof b);
			memset(a, 0, sizeof a);
			b[s][1] = b[s][8] = 1;
			//1 ~ 3:(((2)*2)*2)*4
			for (ll t = 1; t <= 3; t ++ ) for (ll i = 1; i <= n; i ++ ) {
				if (((i - 1) >> t) == ((s - 1) >> t)) b[i][t + 1] = b[i][8 - t] = 1;
				a[i][t] = ((i - 1) ^ (1 << t - 1)) + 1;
			}
			// 4 ~ 5: 4
			for (ll i = 1; i <= 32; i ++ ) {
				ll az = (i - 1) >> 3;
				a[i][4] = (1 > az) * 8 + 1;
				a[i][5] = (1 + (2 > az)) * 8 + 1;
				if (((i - 1) >> 3) == ((s - 1) >> 3)) b[i][5] = 1;
			}
			//6 ~ 8:(((2)*2)*2)*4 回溯
			for (ll t = 6; t <= 8; t ++ ) {
				for (ll i = 1; i <= 32; i ++ ) a[i][t] = ((s - 1) >> (9 - t) << (9 - t)) + 1;
			} 
			for (ll i = 1; i <= 32; i ++ ) for (ll j = 1; j <= 8; j ++ ) cout << c[b[i][j]] << " " << a[i][j] << (j == 8 ? "\n" : " ");
		}
	}
	if (n == 48) {
		puts("9");
		for (ll s = 1; s <= 48; s ++ ) {
			cout << s << "\n";
			memset(b, 0, sizeof b);
			memset(a, 0, sizeof a);
			b[s][1] = b[s][9] = 1;
			//1 ~ 4:((((2)*2)*2)*2)*3
			for (ll t = 1; t <= 4; t ++ ) for (ll i = 1; i <= n; i ++ ) {
				if (((i - 1) >> t) == ((s - 1) >> t)) b[i][t + 1] = b[i][9 - t] = 1;
				a[i][t] = ((i - 1) ^ (1 << t - 1)) + 1;
			}
			// 5: 3
			for (ll i = 1; i <= 48; i ++ ) {
				ll az = (i - 1) >> 4;
				a[i][5] = (1 > az) * 16 + 1;
			}
			//6 ~ 9:((((2)*2)*2)*2)*3 回溯
			for (ll t = 6; t <= 9; t ++ ) {
				for (ll i = 1; i <= 48; i ++ ) a[i][t] = ((s - 1) >> (10 - t) << (10 - t)) + 1;
			} 
			for (ll i = 1; i <= 48; i ++ ) for (ll j = 1; j <= 9; j ++ ) cout << c[b[i][j]] << " " << a[i][j] << (j == 9 ? "\n" : " ");
		}
	}
} 
```

---

## 作者：vzcx_decipher (赞：0)

考虑 $N=32,L=8$。

注意到 $L=2(\log_2 N-1)$，倍增/线段树是较为好想的，前 $L/2$ 轮中每一轮提供“当前区间是否包含 Parent”，读取兄弟节点的状态，后 $L/2$ 轮提供一样的信息，读取当前线段树区间的某一子树状态。

```cpp
void solve32(){
    printf("8\n");
    for(int i=0;i<32;i++){
        printf("%d\n",i+1);
        for(int j=0;j<32;j++){
            for(int k=0;k<4;k++)
                printf("%c %d ",((i^j)>>k)==0?'T':'F',(j^(1<<k))+1);
            for(int k=4;k>0;k--)
                printf("%c %d%c",((i^j)>>(k-1))==0?'T':'F',((i>>k)<<k)+1,k==1?10:32);
        }
    }
}
```

$N'=48,L'=9$ 相比于上一问仅仅为 $N'=N\times 1.5,L'=L+1$，直白点就是某层变成 $3$ 个儿子，操作次数允许多一次。加儿子的这一层无论在哪都会使操作次数加 $2$，除了顶层，多出来的这一次可以用来判断 Parent 处于除自己外哪个子树中。

```cpp
void solve48(){
    printf("9\n");
    for(int i=0;i<48;i++){
        printf("%d\n",i+1);
        for(int j=0;j<48;j++){
            for(int k=0;k<4;k++)
                printf("%c %d ",((i^j)>>k)==0?'T':'F',(j^(1<<k))+1);
            printf("%c %d ",((i^j)>>4)==0?'T':'F',((((j>>4)+1)%3)<<4)+1);
            for(int k=4;k>0;k--)
                printf("%c %d%c",((i^j)>>(k-1))==0?'T':'F',((i>>k)<<k)+1,k==1?10:32);
        }
    }
}
```

---


# 【MX-X11-T6】「蓬莱人形 Round 1」催眠术

## 题目背景

原题链接：<https://oier.team/problems/X11G>。

---

「こんな時代に誂えた  見て呉れの脆弱性」

「本当の芝居で騙される  矢鱈と煩い心臓の鼓動」

「残機は疾うにないなっている；；  擦り減る耐久性」

「目の前の事象を躱しつつ，生きるので手一杯！  誰か、助けてね(^^♪」

## 题目描述

给定 $n,m,k$，还有一个长为 $m$ 的值域在 $[1,k]$ 中的整数序列 $a$，再给定一个大小为 $n \times (m+1)$ 的矩阵 $c$。

定义一个整数序列是好的，当且仅当它的值域在 $[1,k]$ 中且所有值域在 $[1,k]$ 的长为 $m$ 的整数序列都是它的子序列。

定义一个好的整数序列 $b$ 的价值为 $\prod\limits_{i=1}^n c_{i,pre_i}$，其中 $pre_i$ 为 $a$ 的最长前缀长度使得 $a_{1 \sim pre_i}$ 是 $b_{1\sim i}$ 的一个子序列，若不存在则 $pre_i = 0$。

求所有长度为 $n$ 的好序列的价值和，答案对 $10^9+7$ 取模。 

## 说明/提示

**【样例解释 #1】**

满足要求的序列有 $1,2$ 和 $2,1$ 两种，价值分别为 $2\times 3=6$ 和 $3\times 3 = 9$，所以总和为 $6+9=15$。

**【数据范围】**

**本题使用子任务捆绑**。

对于所有测试数据，$1 \le n,m,k \le 400$，$1\le a_i\le k$，$1 \le c_{i,j} < 10^9+7$。

|子任务编号|$n\le$|$m \le$|$k \le$|特殊性质|分值|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$8$|$8$|$8$|无|$5$|
|$2$|$400$|$400$|$400$|A|$10$|
|$3$|$50$|$50$|$50$|无|$10$|
|$4$|$400$|$30$|$8$|无|$15$|
|$5$|$400$|$30$|$400$|无|$15$|
|$6$|$400$|$400$|$400$|B|$15$|
|$7$|$400$|$400$|$400$|无|$30$|

- 特殊性质 A：保证所有 $c_{i,j}$ 相等。
- 特殊性质 B：保证所有 $a_i$ 相等。

## 样例 #1

### 输入

```
2 1 2
2
2 3
2 3```

### 输出

```
15```

## 样例 #2

### 输入

```
10 2 5
2 3
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1```

### 输出

```
14400
```

## 样例 #3

### 输入

```
10 3 3
2 3 3
2 3 1 4
5 2 3 1
5 6 6 6
2 2 3 1
7 6 5 7
2 2 3 1
7 6 5 7
2 2 3 1
7 6 5 7
9 8 1 2
```

### 输出

```
350920080
```

# 题解

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P12152)

进阶计数套路考察。
## 题意

给定 $n,m,k$，还有一个长为 $m$ 的值域在 $[1,k]$ 中的整数序列 $a$，再给定一个大小为 $n \times (m+1)$ 的矩阵 $c_{1\sim n,0\sim m}$。

定义一个整数序列是好的，当且仅当它的值域在 $[1,k]$ 中且所有值域在 $[1,k]$ 的长为 $m$ 的整数序列都是它的子序列。

定义一个好的整数序列 $b$ 的价值为 $\prod\limits_{i=1}^n c_{i,p_i}$，其中 $p_i$ 为 $a$ 的最长前缀长度使得 $a_{1 \sim p_i}$ 是 $b_{1\sim i}$ 的一个子序列，若不存在则 $p_i = 0$。

求所有长度为 $n$ 的好序列的价值和，答案对 $10^9+7$ 取模。

$n,m,k\le 400$。
## 思路

为避免变量重名，将用 $v$ 表示输入的 $k$。

题目强制我们一个个地向后填数，且要求所有长为 $m$ 的序列都出现过，即可以划分出 $m$ 段且每一段内所有 $[1,v]$ 的数均出现，这也可以告诉我们 $m\cdot v\le n$，否则无解。

若无需考虑匹配 $a_{1\sim m}$，则可以记状态 $f_{i,j,p}$ 表示填了 $i$ 个数，当前处于第 $j$ 段，该段内已填 $p$ 种数。由于需要匹配，则需要添加一维记录当前匹配的位置，且由于匹配过的数是确定的，需要分开记录匹配过的数与未匹配过的数。设 $f_{i,j,k,p,q}$ 表示填了 $i$ 个数，目前匹配到位置 $j$，已经填完了 $k$ 段，当前段中已经填入了 $p$ 种匹配过的数，$q$ 种未匹配的数。由于 $j,k\le m$ 且 $p,q\le v$，状态是可接受的。

但是我们需要要求相邻两个匹配的位置间不能出现于右侧匹配位置相同的数，这需要得知上一次匹配时有多少种未匹配的数，但我们不能在状态上再填一维。

不妨称**一次转移**为以下两种之一：
- 在一段中相邻两个匹配位置之间进行转移；
- 在一段中最后一个匹配位置至段末之间进行转移。

一次转移的特点为转移不相交且转移的终止位置需要起始位置的信息，**不妨新开状态表示当前处于一次一类/二类转移，并在开启一次转移的时候提前将贡献乘入**。

知道了这些后转移方程并不难推出，但存在相当一部分的细节需要思考。

时间复杂度 $O(n^3)$，可以通过。

类似题目推荐：[P9385 [THUPC 2023 决赛] 阴阳阵](https://www.luogu.com.cn/problem/P9385)。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
#define pii pair<int,int>
#define mpr make_pair
#define fir first
#define sec second
const int N=400+10,M=800+10,mod=1e9+7;
inline int add(int x,int y){ return x+y>=mod?x+y-mod:x+y; }
inline int dec(int x,int y){ return x>=y?x-y:x-y+mod; }
inline void inc(int &x,int y){ x=add(x,y); }
int n,m,v,a[N],w[N][N],sp[N],pr[N][N],ip[N][N],fac[N],ifac[N],pw[N];
int f[2][M][M],g[2][M][M][2],h[2][M][N],t[2][M];
inline int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
inline void Prefix(int n){
	fac[0]=pw[0]=1;
	for(int i=1;i<=n;i++)
		fac[i]=1ll*fac[i-1]*i%mod,
		pw[i]=1ll*pw[i-1]*v%mod;
	ifac[n]=qpow(fac[n],mod-2);
	for(int i=n;i;i--)
		ifac[i-1]=1ll*ifac[i]*i%mod;
}
/*
f[i][j/p][k/q]:填到位置 i, 已匹配到位置 j, 已匹配 k 段, 在当前段中有 p/q 个已出现的匹配/未匹配数
g[i][j/p][k/q][0/1]:处于第一种转移, 要求匹配 a_j 并已为其钦定一个值, 是否有一个要求某数不能出现的限制 
h[i][j/p][k]:处于第二种转移, 要求结束该段, 在当前段内有 p 个已出现的数 
t[i][j/p]:已匹配整个 a_{1\sim m}, 目前已匹配 k 段, 在当前段内有 p 个已出现的数
*/
inline int pos(int i,int j){ return i*(v+1)+j; }
inline pii pos(int i){ return mpr(i/(v+1),i%(v+1)); }
inline bool chk(int i,int v,int k){ return ip[i][v]<=k; }
int main(){
	n=read(),m=read(),v=read();
	if(m*v>n) return puts("0"),0;
	for(int i=1;i<=m;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		for(int j=0;j<=m;j++)
			w[i][j]=read();
	Prefix(n); 
	sp[n+1]=1;
	for(int i=n;i;i--)
		sp[i]=1ll*sp[i+1]*w[i][m]%mod;
	for(int j=1;j<=v;j++)
		ip[0][j]=v+1;
	for(int i=1;i<=n;i++){
		pr[i][1]=a[i];
		for(int j=1,p=1;j<=v;j++)
			if(pr[i-1][j]!=a[i])
				pr[i][++p]=pr[i-1][j];
		for(int j=1;j<=v;j++)
			ip[i][j]=v+1;
		for(int j=1;j<=v;j++)
			if(pr[i][j])
				ip[i][pr[i][j]]=j;
	}
	int ans=0,c=0,u=pos(m,v);
	f[0][pos(0,0)][pos(0,0)]=1;
	for(int i=1;i<=n;i++,c^=1){
		for(int A=0;A<=u;A++)
			for(int B=0;B<=u;B++){
				int j=pos(A).fir,k=pos(B).fir,p=pos(A).sec,q=pos(B).sec,wc;
				wc=f[c][A][B];
				if(wc){
					//f->g
					if(chk(j,a[j+1],p)) inc(g[c][pos(j,p)][pos(k,q)][1],wc);
					else{
						if(q) inc(g[c][pos(j,p+1)][pos(k,q-1)][1],1ll*wc*q%mod);
						inc(g[c][pos(j,p+1)][pos(k,q)][0],wc);
					}
					//f->h 要给一段内非匹配的数定顺序 
					if(chk(j,a[j+1],p)) inc(h[c][pos(j,p+q)][k],1ll*wc*fac[v-p]%mod);
					else inc(h[c][pos(j,p+q)][k],1ll*wc*q%mod*fac[v-p-1]%mod);
					f[c][A][B]=0;
				}
				for(int a=0;a<=1;a++){
					wc=g[c][A][B][a];
					if(wc){
						//g->g 要求在预留的是已出现过的数时不能触及 p+q=k 
						if(p+q+1+a<=v) inc(g[!c][pos(j,p)][pos(k,q+1)][a],1ll*wc*w[i][j]%mod);
						inc(g[!c][pos(j,p)][pos(k,q)][a],1ll*wc*w[i][j]%mod*(p+q-1)%mod);
						//g->f 若结束一段则需要给一段内非匹配的数定顺序 
						if(j+1<m){
							if(p+q<v) inc(f[!c][pos(j+1,p)][pos(k,q)],1ll*wc*w[i][j+1]%mod);
							else inc(f[!c][pos(j+1,0)][pos(k+1,0)],1ll*wc*w[i][j+1]%mod*fac[q]%mod);
						}else{
							//g->t 需要给这一段的非匹配数定顺序 
							if(p+q<v) inc(t[!c][pos(k,p+q)],1ll*wc*w[i][j+1]%mod*fac[v-p]%mod);
							else inc(t[!c][pos(k+1,0)],1ll*wc*w[i][j+1]%mod*fac[v-p]%mod*fac[k+1==m?0:v]%mod);
						}
						g[c][A][B][a]=0; 
					}
				}
			}
		for(int A=0;A<=u;A++)
			for(int k=0;k<=m;k++){
				int j=pos(A).fir,p=pos(A).sec,wc;
				wc=h[c][A][k];
				if(wc){
					//h->h
					if(p+1<v) inc(h[!c][pos(j,p+1)][k],1ll*wc*w[i][j]%mod);
					inc(h[!c][pos(j,p)][k],1ll*wc*w[i][j]%mod*(p-1)%mod);
					//h->f
					if(p+1==v) inc(f[!c][pos(j,0)][pos(k+1,0)],1ll*wc*w[i][j]%mod);
					h[c][A][k]=0;
				}
			}
		for(int A=0;A<=u;A++){
			int k=pos(A).fir,p=pos(A).sec,wc;
			wc=t[c][A];
			if(wc){
				if(k==m) inc(ans,1ll*wc*sp[i]%mod*pw[n-i+1]%mod);
				else{
					//t->t
					if(p+1<v) inc(t[!c][pos(k,p+1)],1ll*wc*w[i][m]%mod);
					if(p+1==v) inc(t[!c][pos(k+1,0)],1ll*wc*w[i][m]%mod*fac[k+1==m?0:v]%mod);
					inc(t[!c][pos(k,p)],1ll*wc*w[i][m]%mod*p%mod);
				}
				t[c][A]=0;
			}
		}
	}
	inc(ans,t[c][pos(m,0)]);
	write(ans);
	flush();
}
```

---

## 作者：xuanxuan001 (赞：4)

转载个题解吧，都过去这么久了。

自然是考虑 DP，每个长度为 $m$ 的序列都作为子序列出现过就等价于出现了至少 $m$ 个子串满足每个中 $1$ 到 $k$ 都出现过至少一次，设 $dp_{i,j,k}$ 表示前 $i$ 个数，已经填完了 $j$ 个连续段，序列 $a$ 匹配到了位置 $k$ 的权值和。

那么不难发现这个 $dp$ 没法转移，需要再加入一些关于当前连续段已经填了些什么的状态，加什么呢？

众所周知，如果不考虑 $a$ 的匹配问题，那么真正影响转移的只有目前这个连续段出现过多少种不同的数，但在这题中这显然不行，现在还需要知道下一个需要匹配的数和这些已填过的数是什么关系。那么继续思考，对于那些在这一段匹配上的 $a$ 值，匹配它们的那些值的具体值已经确定，而其他的值就显得不那么重要，只需要记住它们出现了多少种就可以了，于是设计下面的 $dp$ 状态：$f_{i,j,k,p,q}$ 表示前 $i$ 个数，已经填完了 $j$ 个连续段，序列 $a$ 匹配到了位置 $k$ ，并且当前段中匹配了 $a$ 的数值有 $p$ 中，其余出现过但暂未匹配 $a$ 的有 $q$ 种的权值和。

这个状态设计还有个很巧妙的地方，就是它可以直接确定下一个值在不在那 $p$ 种数中，只需要看这个值到它上一次出现的位置之间的种类数是否超过 $p$ 即可。

状态数是 $nm^2k^2$ 的，但由于要想满足包含所有序列的条件，所以应有 $n \ge mk$，否则直接输出 $0$ 即可，因此状态数为 $O(n^3)$，转移不难发现是 $O(1)$ 的，因此复杂度为 $O(n^3)$。

转移大概考虑出现新的需要匹配的值就分讨它是否在那 $q$ 种里面。但如果你现在觉得已经做完了准备开始写的话，那还是先别写，~~因为我已经试过了~~。

虽然大致的转移思路已经确定，但发现似乎找不到一个统一的转移来解决所有的情况，因为那 $q$ 个数会有一部分在匹配 $p-1$ 后出现过，这会让它们带有一个不等于 $a_p$ 的限制，再加一个数量来记录复杂度就爆了。

那么此时情况不太好办，几种不同情况的转移系数略有不同，那么考虑用一个比较粗暴的办法，就是直接将这些转移分开。稍微修改上面 $f$ 的定义，要求必须恰好在位置 $i$ 匹配上 $a_p$，然后考虑分讨接下来是先匹配到 $a_{p+1}$ 还是先结束第 $i+1$ 段，如果同时发生认为是前者（其实应该无所谓，但分给前者状态好设计一些）。

先考虑前者，需要继续细分状态，分成 $a_{p+1}$ 在那 $p$ 种内，不在 $p$ 种但在那 $q$ 种内和都不在，分成三个 dp 即可，转移系数略有差异，可自行推导，在转移的终点就是选择了一开始定下来的那个 $a_{p+1}$，然后更新对应的 $j,p,q$，如果 $p+q=k$ 了就需要考虑开新段的问题。

然后是后者，这时使用另一种方式记录，此时 $a_{p+1}$ 由于被钦定不能匹配所以只能在那 $p$ 种或那 $q$ 种中，发现两者差异并不大，那么用一个辅助 dp 数组 $f_{i,j,k,p}$ 表示 $i$ 个数填好了 $j$ 段，匹配到 $k$，最后一段还有 $p$ 个数没出现过的权值和，由于这一段要清空了所以现在已经不需要太在意匹配 $a$ 的问题了，唯一的限制就是有一个值不能选。转移就考虑这次有没有填一个之前为出现的数即可，$j=m$ 的情况需要特殊考虑，因为这时没有禁止选的位置。

转移到 $j=m,k=m$ 时后面可以任意填，方案数已确定，直接转移到答案即可，否则转移到对应的数组。

感觉没太大必要放转移方程了，难道你补题就是照着题解抄转移方程吗？还是转载个官方题解的方程吧，要是哪不确定可以看一下，[需要自取](https://cdn.luogu.com.cn/upload/image_hosting/1iw681oe.png)。有了转移方程代码基本也就是那样，就也不放了。

---


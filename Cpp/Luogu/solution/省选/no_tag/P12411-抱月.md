# 抱月

## 题目描述

记 $P(u,v)$ 表示树上从节点 $u$ 到节点 $v$ 依次经过的点组成的序列，包括 $u$ 和 $v$。

记 $dep_u$ 表示在以 $1$ 为树根时，节点 $u$ 的深度（根节点深度为 $0$）。

记 $\operatorname{LCA}(u,v)$ 为树上节点 $u$ 和 $v$ 在以 $1$ 为树根时的最近公共祖先。

抱月有一棵树，树根为 $1$，一共有 $n$ 个节点。其中第 $i$ 个节点的颜色是 $c_i$。她发现，对于一个节点 $x$ 和整数 $k$，如果将 $P(x,1)$ 中所有满足：$dep_y\equiv dep_x \pmod{k}$ 的 $y$ 都拿出来，这些 $y$ 是有意义的。

所以，你需要解决这样一个问题。给定 $m$ 次询问，每次两个整数 $x,k$，求**删掉** $P(x,1)$ 中所有满足 $dep_y\equiv dep_x \pmod{k}$ 的 $y$ 后，满足 $dep_z \le dep_x$ 的 $z$ 中不同 $c_z$ 的数量。**每次询问独立**，也就是说这次删的点在下一次询问会恢复。

如果不理解，请看样例解释。

## 说明/提示

对于所有测试数据，保证 $1 \le n,m,k_i \le 10^5$，$1 \le u,v,x_i \le n$，$0 \le c_i \le 10^5$。

| Subtask | 限制 | 分值 |
| :----------: | :----------: | :----------: |
| $0$ | $n,m \le 10^3$ | $10$ |
| $1$ | $c_i$ 相同 | $4$ |
| $2$ | $k_i > \max\limits_{j=1}^{n} dep_j$ | $16$ |
| $3$ | $n,m \le 5\times 10^4$ | $30$ |
| $4$ |无 | $40$ |

**样例解释**

对于第 $1$ 个询问，满足条件的 $y$ 为：$1,3$。删掉之后，满足条件的 $z$ 为：$2,4$。其中 $c_1=2,c_4=8$，所以答案为 $2$。

对于第 $3$ 个询问，满足条件的 $y$ 为：$1,5$。删掉之后，满足条件的 $z$ 为：$2,3,4,6,9$。其中 $c_2=1,c_3=4,c_4=8,c_6=2,c_9=7$，所以答案为 $5$。

## 样例 #1

### 输入

```
11 9
3 1 4 8 8 2 6 4 7 5 1
1 2
1 3
1 4
4 9
9 10
9 11
3 5
3 6
5 8
5 7
3 1
4 1
5 2
11 4
10 3
8 2
6 1
7 1
7 2```

### 输出

```
2
2
5
8
6
7
3
6
7```

# 题解

## 作者：harmis_yz (赞：4)

题面是让求所有深度不大于 $x$ 且不为 $x$ 的 $k$ 倍祖先的点的颜色构成集合的大小。

很显然的，如果一个颜色 $col$ 在最后的集合中没有出现过，那么 $c_i=col$ 的 $i$ 要么是 $x$ 的 $k$ 倍祖先，要么深度大于 $x$ 的深度。因为没被删的点看起来很不好维护，所以考虑维护有多少种颜色完全被删了。

考虑将深度大于 $x$ 的深度的点和 $x$ 的 $k$ 倍祖先分开维护。对于深度大于 $x$ 的深度的点，我们可以再反一次，转化为深度不大于 $x$ 的深度的点的颜色构成集合的大小。求这个有若干种方式，能过在 $O(n)$ 的复杂度维护出所有 $dep_x=y$ 时的答案。那么现在问题转化为：求有多少种颜色 $col$，满足 $c_i =col \land dep_i \le dep_x$ 的点均为 $x$ 的 $k$ 倍祖先。这个很典吧，考虑根号分治。

由于 $x$ 的 $k$ 倍祖先数量为 $\lfloor\frac{dep_x}{k}\rfloor$，如果我们每次暴力跳 $k$ 级祖先，那么复杂度是 $O(\frac{dep_x}{k})$ 的。维护一个颜色是否出现完可以按照 BFS 序记录每个点。那么记 $lst_i$ 为颜色 $i$ 上一次出现的位置，则 $dep \in [dep_u,dep_{lst_i}]$ 颜色 $i$ 不能出现 $>2$ 次，即将每种颜色按照 BFS 序排序后它们相邻。所以单次时间复杂度是 $O(\frac{dep_x}{k} \log n)\sim O(\frac{dep_x}{k})$。

如果这个 $k$ 极小，上面的做法显然很裂。考虑枚举 $k$，将所有 $k$ 相同的询问统一处理。假设现在 $k$ 一定。对于一个颜色 $col$，我们将 $c_i=col$ 的点剖出来，建成一棵虚树，观察虚树的形态。我们将虚树按照深度分层，那么对于前 $i$ 层，如果我们有一个询问 $Dep_{i+1} >dep_x\ge Dep_i$，则当 $col$ 会对 $x$ 产生贡献的必要条件一定是前 $i$ 层的虚树形态是一条链。这个显然吧，如果不是链，那么一定有一个点 $u$，有 $deg_u \ge 3$ 且 $dep_u \le dep_x$。那么一定存在一个点颜色为 $col$ 且不为 $x$ 的 $k$ 倍祖先。

我们接着去枚举层数 $i$。当前 $i$ 层构成虚树的形态为一条链时，考虑会对哪些 $x$ 产生贡献。如果 $col$ 对 $x$ 产生了贡献，那么另一个充分必要条件是这条链上所有点均为 $x$ 的 $k$ 倍祖先。根据虚树的性质，既然是一条链，那么这虚树上所有点的颜色都为 $col$，所以是必须的。我们有：$Dep_i \le dep_x < Dep_{i+1}$。哦我是不是忘说了，$Dep_i$ 表示第 $i$ 层节点在原树上的深度。

我们可以找到第 $i$ 层的虚树上节点在原树上的位置。那么现在就相当于对于一个子树的一个深度区间加问题了。哦这里还有个条件，就是 $dep_x$ 应该与 $Dep_1$ 对于 $k$ 同余，且 $Dep_j (j \le i)$ 也应该与 $Dep_1$ 对于 $k$ 同余。维护这个可以将所有颜色合在一起处理，在节点上打 $tag$ 即可。对于一个 $k$ 的时间复杂度 $O(n)$。

那么现在我们有两种做法，一种做法的时间复杂度为 $O(\sum \frac{dep_x}{k}+n\log n)$，一种为 $O(nK)$。最坏情况下，有时间复杂度为 $O(\sum\frac{n}{k}+nK+n\log n)$。看情况平衡即可，时间复杂度 $O(n\log n+n\sqrt{n})$。

然后呢，这题做法肯定不止一个啦，可以暴力求答案，拿个虚树搞。具体的可以自己想，实现应该比上面的那个做法简单很多。

---

## 作者：StayAlone (赞：0)

看到取模，考虑阈值分治。将 $k>B$ 的询问按照深度离线，暴力修改同余的点，使用树链剖分暴力跳就可以保证时间复杂度，为 $\mathcal O(\frac{qn}{B})$。

对于 $k$ 较小的部分，考虑对不同的 $k$ 分别处理，维护 $1\sim x$ 的路径上能实际减少的颜色数。一个颜色在 $x$ 处能被实际减少，当且仅当该颜色的所有出现位置都在 $1\sim x$ 的链上，且深度对 $k$ 同余。可以发现，某个位置能对子树内的、与 $x$ 点深度同余的某前缀贡献。将询问挂到树上，只需要差分一下，对于模 $k$ 的每个剩余系，在 dfs 的过程中使用标记维护即可，退出子树时删除标记。时间复杂度 $\mathcal O(nB+q)$。

有点抽象，可以看看代码。理论上 $B$ 取 $\sqrt q$ 最优，然而实际表现不尽人意。查看最优解发现神秘分治方式，效率提升很大。

[AC record](https://www.luogu.com.cn/record/216482528)

```cpp
int n, m, a[MAXN], opt[MAXN], X[MAXN], K[MAXN], cnt[MAXN], lstd[MAXN], lst[MAXN], _col[MAXN], nxt[MAXN], val[MAXN];
int stp, dep[MAXN], hson[MAXN], dfn[MAXN], to[MAXN], siz[MAXN], pa[MAXN], top[MAXN];
vector <int> delt, lnk[MAXN], dot[MAXN], qu1[MAXN], qu2[MAXN], qu3[MAXN];
ll tsum[MAXN];

il void add(const int &x, const int &y) {
	lnk[x].eb(y); lnk[y].eb(x);
}

il void dfs1(int x, int p) {
	dot[dep[x] = dep[pa[x] = p] + 1].eb(x); siz[x] = 1;
	for (auto v : lnk[x]) if (v ^ p) dfs1(v, x), siz[x] += siz[v], siz[v] > siz[hson[x]] && (hson[x] = v);
}

il void dfs2(int x, int t) {
	top[x] = t; to[dfn[x] = ++stp] = x;
	if (hson[x]) dfs2(hson[x], t);
	for (auto v : lnk[x]) if (v ^ pa[x] && v ^ hson[x]) dfs2(v, v);
}

il int kth_pa(int x, int k) {
	if (k >= dep[x]) return 0;
	while (k >= dep[x] - dep[top[x]] + 1) k -= dep[x] - dep[top[x]] + 1, x = pa[top[x]];
	return to[dfn[x] - k];
}

il bool isson(int x, int v) {
    return dfn[x] <= dfn[v] && dfn[v] < dfn[x] + siz[x];
}

const int B = 80;
int tag[MAXN << 1], now[B], _k;
il void dfs(int x, int p) {
    int ql = -1, qr = -1, g = dep[x] % _k; now[g] += tag[dep[x]];
    if (lstd[a[x]] > dep[x] && val[x] % _k == 0) {
        ql = dep[x], qr = dep[nxt[x]]; qr = ((qr - ql - 1) / _k + 1) * _k + ql;
        ++now[g]; --tag[qr];
    } int ans = _col[dep[x]] - now[g];
    while (qu3[x].size()) opt[qu3[x].back()] = ans, qu3[x].pop_back();
    for (auto v : lnk[x]) if (v ^ p) dfs(v, x);
    if (~ql) --now[g], ++tag[qr];
    now[g] -= tag[dep[x]];
}

int main() {
	read(n, m); rer(i, 1, n, a);
	rep1(i, 2, n) add(read(), read());
	dfs1(1, 0); dfs2(1, 1); int col = 0;
    rep1(i, 0, 1e5) lstd[i] = n + 1;
	rep1(i, 1, m) read(X[i], K[i]), tsum[K[i]] += dep[X[i]] / K[i] + 1;
    rep1(i, 1, m) {
        if (tsum[K[i]] <= 8e5) qu1[dep[X[i]]].eb(i);
        else qu2[K[i]].eb(i);
    }
	rep1(i, 1, n) {
		for (auto v : dot[i]) {
            int q = a[v];
            if (!cnt[q]++) ++col;
            if (lst[q] && lstd[q] > n && !isson(lst[q], v)) lstd[q] = i;
            if (lst[q]) val[v] = __gcd(val[lst[q]], dep[v] - dep[lst[q]]);
            nxt[lst[q]] = v; lst[q] = v;
        } _col[i] = col;
		for (auto id : qu1[i]) {
			int _col = col, x = X[id], k = K[id];
			while (x) _col -= !--cnt[a[x]], delt.eb(a[x]), x = kth_pa(x, k);
			opt[id] = _col;
			while (delt.size()) ++cnt[delt.back()], delt.pop_back();
		}
	} dep[0] = *max_element(dep + 1, dep + 1 + n) + 1;
    rep1(k, 1, n) if (qu2[k].size()) {
        for (auto v : qu2[k]) qu3[X[v]].eb(v);
        _k = k; dfs(1, 0);
    }
	rep1(i, 1, m) printf("%d\n", opt[i]);
	return 0;
}
```

---

## 作者：Shunpower (赞：0)

CQ_Bob 出的数据结构小练习。/qq

-----------

一眼考虑对 $k$ 根号分治，对于 $k>\sqrt n$ 的部分我们发现是简单的：每次只会删去 $\mathcal O(\sqrt n)$ 个节点不考虑其颜色。所以我们把询问离线到 $dep$，每次用长剖暴力跳 $k$ 级祖先删掉这 $\mathcal O(\sqrt n)$ 个节点的颜色，取答案之后再补回去。此过程维护颜色桶即可。

考虑 $k<\sqrt n$ 怎么办。我们对每种 $k$ 都独立开，然后我们继承 $k>\sqrt n$ 的想法把询问离线到 $dep$，考虑一种颜色完全被删掉而不计入答案的限制非常强：至少全部都要在根到查询点 $x$ 的链上，并且 $dep$ 全都与 $k$ 同余。所以我们考虑维护有多少种颜色满足这些条件以至于被完全删掉。

考虑离线到 $dep$ 之后我们需要每次支持新增一个颜色，维护该颜色的“可完全被删掉”性。

- 首先如果该颜色新加入的点不在上一个点的子树中，说明不构成一条链，也一定不可能完全被删掉。
- 其次如果该颜色新加入的点不与之前的点 $dep$ 模 $k$ 同余，说明在该 $k$ 情况下无论查询的点模 $k$ 是多少，都一定至少有一个点删不掉。
- 其它情况，这种颜色构成一条链，它将导致链底那个点的子树中，所有 $dep$ 模 $k$ 与它同余的点数不到这个颜色。

那么我们考虑直接维护每个点少数多少种颜色，这样加上总的颜色数就是答案了。我们需要维护区间 $dep$ 模 $k$ 点的 $\pm 1$ 修改（链底会变化），并单点查询。

考虑我们产生了 $\mathcal O(n\sqrt n)$ 次修改，但总共只有 $\mathcal O(q)$ 次查询。那么我们用差分转置之后只需找一种 $\mathcal O(1)$ 修改，$\mathcal O(\sqrt n)$ 查询的办法，显然分块即可。

然后就被卡空间了。我们始终要存储每种模 $k$ 剩余系的差分数组。不过可以注意到每次单点修改只影响 $\mathcal O(1)$ 个位置的差分，所以每个 $k$ 只有 $\mathcal O(n)$ 个位置的差分是有用的，因此我们可以考虑使用哈希表存储差分数组。

然后就被卡时间了。STL 跑得太慢了，自己写又不方便。注意到我们每轮 $k$ 之间可以不清空差分数组，所以不如调块长，将根号分治的阈值 $k$ 调到 $100$ 左右并把整个代码里的 `vector` 全部删掉换成静态数组就能把空间卡过去。

然后我们发现长剖 cache miss 太多了还是 TLE 了，考虑换一种 K 级祖先办法。考虑我们暴力跳长剖链也是对的：只有 $\mathcal O(\sqrt n)$ 次切换重链。所以我们直接暴力维护长剖链，并实现跳长剖链即可。这样内存比较连续可以通过：[Link](https://www.luogu.com.cn/record/216244240)（未精细调整阈值）。

或者聪明一点，你发现可以把每种剩余系独立开来做。我们总是只查询一个 $dep$ 模 $k$ 意义下的点值，修改也恰好只修改一个 $dep$ 模 $k$ 意义下的区间值。所以我们可以在查询之前只做这个剩余系的修改，进一步地我们可以再离线一次，直接把每个剩余系独立出来做，这样就不用考虑剩余系的问题了。这个做法的空间和时间都可以接受，只不过常数其实会比刚刚那个做法大一些，写出来还是需要卡常。我们调节一下阈值就可以通过：[Link](https://www.luogu.com.cn/record/216244179)（阈值为 $500$）。

-------

下面是经历过一些卡常但是至少还有可读性的，第二种办法的代码。如果需要第一种办法的代码可以找我。

```cpp
int n,m;
int c[N];
int u,v;
int e;
int head[N],to[N<<1],nxt[N<<1];
void addedge(int u,int v){
	e++;
	nxt[e]=head[u];
	to[e]=v;
	head[u]=e;
}
int blo;
struct queries{
	int x,k;
} q[N];
int dep[N];
int eachdep[N];
int eachqry[N];
int dfn[N],siz[N];
int tot;
int subdep[N],hson[N];
int f[N][18];
void dfs(int x,int fa){
	tot++;
	dfn[x]=tot;
	siz[x]=1;
	f[x][0]=fa;
	subdep[x]=0;
	int maxdep=-1;
	for(int i=head[x];~i;i=nxt[i]){
		int y=to[i];
		if(y==fa) continue;
		dep[y]=dep[x]+1;
		dfs(y,x);
		siz[x]+=siz[y];
		if(maxdep<subdep[y]){
			maxdep=subdep[y];
			hson[x]=y;
		}
	}
	subdep[x]=maxdep+1;
}
int ofl[N];
int lst[N];
int ans[N];
int bel[N];
bool subtree(int x,int y){
	return dfn[x]<=dfn[y]&&dfn[y]<dfn[x]+siz[x];
}
int sum[N];
int loose[N];
vector <pii> oper[N];
void add(int rt,int v){//dfn[rt]~dfn[rt]+siz[rt]-1, dep mod k = rem, +v
	loose[dfn[rt]]+=v;
	sum[bel[dfn[rt]]]+=v;
	if(dfn[rt]+siz[rt]<=n){
		loose[dfn[rt]+siz[rt]]-=v;
		sum[bel[dfn[rt]+siz[rt]]]-=v;
	}
}
int query(int rt){//dfn[rt], dep mod k = rem, sum
	int ans=0;
	fr1(i,1,bel[dfn[rt]]-1) ans+=sum[i];
	for(int i=dfn[rt];bel[i]==bel[dfn[rt]];i--) ans+=loose[i];
	return ans;
}
int cntb;
int bol[N];
void addto(int x){
	if(!bol[x]) cntb++;
	bol[x]++;
}
void delto(int x){
	if(bol[x]==1) cntb--;
	bol[x]--;
}
namespace Kancestor{
	int top[N],len[N];
	int D[N],U[N],id[N];
	int cnt1,cnt2;
	void dfs2(int x,int tp,int fa){
		top[x]=tp;
		len[tp]++;
		if(hson[x]) dfs2(hson[x],tp,x);
		for(int i=head[x];~i;i=nxt[i]){
			int y=to[i];
			if(y!=hson[x]&&y!=fa) dfs2(y,y,x);
		}
	}
	void down(int x,int bg,int len){
		if(!x) return;
		cnt1++;
		D[cnt1]=x;
		down(hson[x],bg,len+1);
	}
	void up(int x,int bg,int len,int limit){
		if(limit==-1) return;
		cnt2++;
		U[cnt2]=x;
		up(f[x][0],bg,len+1,limit-1);
	}
	void init(){
		fr1(j,1,17){
			fr1(i,1,n){
				f[i][j]=f[f[i][j-1]][j-1];
			}
		}
		dfs2(1,1,0);
		fr1(i,1,n){
			if(top[i]==i){
				id[i]=cnt1+1;
				down(i,i,0);
				up(i,i,0,len[i]);
			}
		}
	}
	int ancestor(int x,int k){
		if(k==0) return x;
		int lg=31-__builtin_clz(k);
		x=f[x][lg];
		int rem=k-(1<<lg);
		k=dep[x]-dep[top[x]];
		if(rem<=k) return D[id[top[x]]+k-rem];
		else return U[id[top[x]]+rem-k];
	}
};
// #define Shun cute
int main(){
#ifdef Shun
	freopen("moon.in","r",stdin);
	freopen("moon.txt","w",stdout);
#endif
	memset(head,-1,sizeof head);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	fr1(i,1,n) cin>>c[i];
	fr1(i,2,n){
		cin>>u>>v;
		addedge(u,v);
		addedge(v,u);
	}
	fr1(i,1,m) cin>>q[i].x>>q[i].k;
	dfs(1,0);
	fr1(i,1,n) eachdep[i]=i;
	sort(eachdep+1,eachdep+n+1,[](int &x,int &y){
		return dep[x]<dep[y];
	});
	dep[n+1]=1e9;
	q[m+1].x=n+1;
	eachdep[n+1]=n+1;
	blo=500;
	fr1(i,1,n) bel[i]=(i-1)/blo+1;
	fr1(k,1,blo){
		fr1(i,0,k-1) oper[i].clear();
		fr1(i,1,V) lst[i]=0;
		int qc=0;
		fr1(i,1,m){
			if(q[i].k==k){
				qc++;
				ofl[qc]=i;
			}
		}
		ofl[qc+1]=m+1;
		sort(ofl+1,ofl+qc+1,[](int &x,int &y){
			return dep[q[x].x]<dep[q[y].x];
		});
		int cnt=0,l=1,ql=1;
		fr1(i,0,n){
			while(dep[eachdep[l]]==i){
				int j=eachdep[l];
				if(lst[c[j]]==-1) goto label;
				if(!lst[c[j]]){
					cnt++;
					lst[c[j]]=j;
					oper[dep[j]%k].pb(mp(j,1));
				}
				else{
					if(!subtree(lst[c[j]],j)||dep[lst[c[j]]]%k!=dep[j]%k){
						oper[dep[lst[c[j]]]%k].pb(mp(lst[c[j]],-1));
						lst[c[j]]=-1;
					}
					else{
						oper[dep[j]%k].pb(mp(lst[c[j]],-1));
						lst[c[j]]=j;
						oper[dep[j]%k].pb(mp(j,1));
					}
				}
				label:
				l++;
			}
			while(dep[q[ofl[ql]].x]==i){
				int j=ofl[ql];
				oper[dep[q[j].x]%k].pb(mp(j,0));
				ans[j]+=cnt;
				ql++;
			}
		}
		fr1(i,0,k-1){
			for(auto j:oper[i]){
				if(!j.se) ans[j.fi]+=query(q[j.fi].x);
			}
			for(auto j:oper[i]){
				if(j.se) add(j.fi,j.se);
				else ans[j.fi]-=query(q[j.fi].x);
			}
		}
	}
	int qc=0;
	fr1(i,1,m){
		if(q[i].k>blo){
			qc++;
			ofl[qc]=i;
		}
	}
	ofl[qc+1]=m+1;
	sort(ofl+1,ofl+qc+1,[](int &x,int &y){
		return dep[q[x].x]<dep[q[y].x];
	});
	int ql=1;
	Kancestor::init();
	int l=1;
	fr1(i,0,n){
		while(dep[eachdep[l]]==i){
			int j=eachdep[l];
			addto(c[j]);
			l++;
		}
		while(dep[q[ofl[ql]].x]==i){
			int j=ofl[ql];
			int x=q[j].x;
			vector <int> rollback;
			while(1){
				delto(c[x]);
				rollback.pb(x);
				if(dep[x]<q[j].k) break;
				x=Kancestor::ancestor(x,q[j].k);
			}
			ans[j]=cntb;
			for(auto j:rollback) addto(c[j]);
			ql++;
		}
	}
	fr1(i,1,m) cout<<ans[i]<<'\n';
	// cerr<<clock()<<endl;
	ET;
}
//ALL FOR Zhang Junhao.
```

总时间复杂度 $\mathcal O(n\log n+(n+q)\sqrt n)$，前面的 $\mathcal O(n\log n)$ 来自长剖的预处理。

---


# [集训队互测 2000] 丘比特的烦恼

## 题目背景

随着社会的不断发展，人与人之间的感情越来越功利化。最近，爱神丘比特发现，爱情也已不再是完全纯洁的了。这使得丘比特很是苦恼，他越来越难找到合适的男女，并向他们射去丘比特之箭。于是丘比特千里迢迢远赴中国，找到了掌管东方人爱情的神——月下老人，向他求教。

月下老人告诉丘比特，纯洁的爱情并不是不存在，而是他没有找到。在东方，人们讲究的是缘分。月下老人只要做一男一女两个泥人，在他们之间连上一条红线，那么它们所代表的人就会相爱——无论他们身处何地。而丘比特的爱情之箭只能射中两个距离相当近的人，选择的范围自然就小了很多，不能找到真正的有缘人。

## 题目描述

情人节（Valentine's day）的午夜零时，丘比特开始了自己的工作。他选择了一组数目相等的男女，感应到他们互相之间的缘分大小，并依此射出了神箭，使他们产生爱意。他希望能选择最好的方法，使被他选择的每一个人被射中一次，且每一对被射中的人之间的缘分的和最大。

当然，无论丘比特怎么改造自己的弓箭，总还是存在缺陷的。首先，弓箭的射程尽管增大了，但毕竟还是有限的，不能像月下老人那样，做到“千里姻缘一线牵”。其次，无论怎么改造，箭的轨迹终归只能是一条直线，也就是说，如果两个人之间的连线段上有别人，那么莫不可向他们射出丘比特之箭，否则，按月下老人的话，就是“乱点鸳鸯谱”了。

作为一个凡人，你的任务是运用先进的计算机为丘比特找到最佳的方案。

## 说明/提示

$1\le n\le 30$。

CTSC2000 第二试


## 样例 #1

### 输入

```
2
3
0 0 Adam
1 1 Jack
0 2 George
1 0 Victoria
0 1 Susan
1 2 Cathy
Adam Cathy 100
Susan George 20
George Cathy 40
Jack Susan 5
Cathy Jack 30
Victoria Jack 20
Adam Victoria 15
End
```

### 输出

```
65```

# 题解

## 作者：Khassar (赞：17)

楼下说的很对啊，这题就是一个带权二分图最大匹配，只不过怎么没人用KM写呢？所以我就在此献丑，奉上一篇KM的题解。

我们把男子放到左边，女子放到右边，为这两个之间建一条边权为缘分的边，然后跑KM就可以了。

坑点嘛。。。

①字符串大小写不敏感->挂40分

②没说的人之间缘分为1->挂40分

③不能连的人之间之间缘分要设为负无穷->挂10分

尤其是这个③，跟我同机房的dalao写的费用流直接无视第三点，我问的时候他还一脸mengbi，可能是费用流自己就能判过去吧，反正KM不行。并且它给的特别缘分有很多是负的。至于这些为什么是挂怎么多分，emmmmm~~~

并且这道题既然能用KM做，就说明它有一个隐式的条件——有完备匹配，这点在题目中并没有说

下面简单介绍一下KM的算法思想，当然是我从我的另一篇题解复制的，不想看的可以跳过去直接看代码注释了

首先，介绍一个重要的定理：

我们定义**顶标**：

lx[i],ly[j],i∈左边，j∈右边，并且对于任意w[i][j],都有lx[i]+ly[j]>=w[i][j]；

我们再从原图中抽出lx[i]+ly[j]=w[i][j]的边建立一个**相等子图**，如果相等子图有**完美匹配**（就是无边权，全匹配的那个），那么这个完美匹配就是原图的**最佳完美匹配**。

这个定理的证明也十分简单，这里我就不证明了，有兴趣的可以自行百度。

有了这个定理我们就可以用KM(匈牙利算法)求解此题了。

具体的方法就是，不断的修改顶标让它有一个合适的值，使得相等子图有完美匹配。实现起来就是先开心地设一个顶标初值（一般是ly=0,lx=max(w[i][j])），然后开始KM，如果找到了一条增广路，就找到了吧；如果没有，那它一定是尝试访问了一些左边的点（比如q个）我们把它们加入**S**,然后访问了q-1个右边的点,我们把它们加入**T**（S,T是两个集合）。

然后把lx[i],i∈S都减去一个**松弛量a**，ly[j],j∈T，都加上一个a，这样就会有一些不在T中的点和在S中的点之间的边能够进入相等子图，同时已经在相等子图里的边不出去，继续进行KM直到匹配了这个点为止。

至于找a的方法，为了保证进来的边是能进来的之中最大的，同时又有边进来，

a=min{lx[i]+ly[j]-w[i][j]|i∈S，j∉T}，这个过程就n^2暴力枚举就好了，因此整个算法时间复杂度为n^4，当然还有一个n^3的优化方法，不过n^4就能0ms秒杀此题，所以这里就不用了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=50;
const D eps=1e-9;

int n,lx[N],ly[N],link[N],w[N][N],ans;
bool S[N],T[N];
D k;

string s1,s2;
map <string,int> idm,idw;//人的编号就开map搞一搞就行了

struct node {
    int x,y;
}man[N],wom[N];

IL int read() {
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

bool dfs(int x) {//这就是一般的二分图匹配
    S[x]=true;//把左边的点都加入S
    Rf(i,1,n) if(lx[x]+ly[i]==w[x][i]&&!T[i]) {
    //判断这条边是否在相等子图里，不要再建图了
        T[i]=true;//右边的点加入T
        if(!link[i]||dfs(link[i])) {
            link[i]=x;
            return true;
        }
    }
    return false;
}

IL void update() {//n^2暴力找a，并修改
    R int a=1<<30;
    Rf(i,1,n) if(S[i]) 
        Rf(j,1,n) if(!T[j]) 
            a=min(a,lx[i]+ly[j]-w[i][j]); 
    Rf(i,1,n) {
        if(S[i]) lx[i]-=a;
        if(T[i]) ly[i]+=a;
    }
}

IL void KM() {
    Rf(i,1,n) {
        link[i]=lx[i]=ly[i]=0;
        lx[i]=-1e9;//这句话好像可以不要
        Rf(j,1,n) lx[i]=max(lx[i],w[i][j]);
    }
    Rf(i,1,n) while(true) {
        Rf(j,1,n) S[j]=T[j]=false;
        if(dfs(i)) break;
        else update();
    }
} 

void Turn(string &s){//把字符串都转化成大写的
    for(string::iterator it=s.begin();it!=s.end();it++)
        if(*it>='a') *it=*it-'a'+'A';
}

IL D cal(int i,int j) {//算两点之间的距离
    return sqrt(1.0*(man[i].x-wom[j].x)*(man[i].x-wom[j].x)+1.0*(man[i].y-wom[j].y)*(man[i].y-wom[j].y));
}

signed main()
{
    k=read();n=read();
    Rf(i,1,n) {//定坐标
        R int u=read(),v=read();
        cin>>s1;
        Turn(s1);
        idm[s1]=i;
        man[i].x=u;man[i].y=v;
    }
    Rf(i,1,n) {
        R int u=read(),v=read();
        cin>>s1;
        Turn(s1);
        idw[s1]=i;
        wom[i].x=u;wom[i].y=v;
    }
    Rf(i,1,n) Rf(j,1,n) w[i][j]=1;//普遍缘分的
    cin>>s1;
    while(s1!="End") {//特别缘分的
        cin>>s2;R int val=read();
        Turn(s1);Turn(s2);
        if(!idm[s1]) swap(s1,s2);//保证男在前
        R int I=idm[s1],J=idw[s2];
        w[I][J]=val;
        cin>>s1;
    }
    Rf(I,1,n) Rf(J,1,n) {//暴力枚举两点是否可连
        R D l; 
        if((l=cal(I,J))<=k) {//距离是否太远
            R int pd=1;
//枚举中间插足的，无论男女
//看三点中是否有两短距离等于一长距离
            Rf(i,1,n) {
                if(i==I) continue;
                D l1=sqrt(1.0*(man[i].x-wom[J].x)*(man[i].x-wom[J].x)+
                1.0*(man[i].y-wom[J].y)*(man[i].y-wom[J].y));
                D l2=sqrt(1.0*(man[i].x-man[I].x)*(man[i].x-man[I].x)+
                1.0*(man[i].y-man[I].y)*(man[i].y-man[I].y));
                if(fabs(l-l1-l2)<eps) {
                    pd=0;break;
                }
            }
            if(pd) Rf(j,1,n) {
                if(j==J) continue;
                R D l1=sqrt(1.0*(wom[J].x-wom[j].x)*(wom[J].x-wom[j].x)+
                1.0*(wom[J].y-wom[j].y)*(wom[J].y-wom[j].y));
                R D l2=sqrt(1.0*(man[I].x-wom[j].x)*(man[I].x-wom[j].x)+
                1.0*(man[I].y-wom[j].y)*(man[I].y-wom[j].y));
                if(fabs(l-l1-l2)<eps) {
                    pd=0;break;
                }
            }
            if(!pd) w[I][J]=-1e9;
        }else w[I][J]=-1e9;
    }
    KM();
    Rf(i,1,n) ans+=lx[i]+ly[i];//顶标和即是答案
    write(ans);
    return 0;
}
```

---

## 作者：KEBrantily (赞：7)

## Description 	

给出 $n$ 男 $n$ 女。每个人都自己的坐标。

其中若干对男女之间有特定的缘分值。

一男一女能够匹配的条件是其直线距离不大于 $k$ 且连线上不存在别的人。

求能匹配的最大缘分值。

## Solution

本题采用 dinic 建负边求最大费用最大流。

思路很简单，就是二分图最大权匹配。对于每对男女，判断其能否配对，能则连费用为缘分值的边。然后源点连男，汇点连女即可。因为中国实行的是一夫一妻制，所以所有边的容量均为 $1$。

重点在怎样判断是否符合条件，这里考虑用斜率判断。

假设现在有三个点 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，分别记为点 $a,b,c$。我们钦定 $x_1\le x_3$，现在要判断 $b$ 是否在 $ac$ 上。

显然，只需要判断 $\large\frac{x_3-x_2}{y_3-y_2}$ 是否等于 $\large\frac{x_2-x_1}{y_2-y_1}$ 即可，但是此时必须要满足 $x_1 \le x_2\le x_3$ 的条件。对于不满足这个条件的点 $b$，显然也不可能在 $ac$ 上，特判一下即可。

对于字符串的处理，注意大小写不区分，存储推荐使用 `map`。

具体实现见下方代码。

## Code

省去了 dinic 的板子，只给出主函数建图以及判断部分的代码。

```cpp
bool vis[maxn];
int love[maxn][maxn];//缘分值
int n,m,tot=1,k,res,s,t;
int head[maxn],cur[maxn],Dis[maxn];
struct edge{int fr,to,dis,cost,nxt;}e[maxn*1000];
map<int,string> val;//val[i] 编号为 i 的人的名字
map<string,int> pre;//pre[s] 名字为 s 的人的编号
map<string,pair<int,int> > pos;
//pos[s].first/second 名字为 s 的人的横/纵坐标

bool judge(int a,int b){
  pair<int,int> A=pos[val[a]];
  pair<int,int> B=pos[val[b]];
  if(A.first>B.first)swap(a,b),swap(A,B);
  for(int i=1;i<=n;i++){
    if(i==a||i==b) continue;
    if(pos[val[i]].first<A.first||pos[val[i]].first>B.first) continue;
    if((double)(pos[val[i]].second-A.second)/(double)(pos[val[i]].first-A.first)
    ==(double)(B.second-pos[val[i]].second)/(double)(B.first-pos[val[i]].first))
    return false;
  }
  if((A.first-B.first)*(A.first-B.first)+(A.second-B.second)*(A.second-B.second)>k*k) return false;
  return true;
}

int main(){
  k=read();n=read();s=n*2+1,t=s+1;
  for(int i=1,x,y;i<=n;i++){
    string name;cin>>x>>y>>name;
    for(int j=0;j<name.length();j++)
      if(name[j]>='a'&&name[j]<='z')
        name[j]+='A'-'a';
    pos[name]=make_pair(x,y);
    val[i]=name;pre[name]=i;
  }
  for(int i=n+1,x,y;i<=n*2;i++){
    string name;cin>>x>>y>>name;
    for(int j=0;j<name.length();j++)
      if(name[j]>='a'&&name[j]<='z')
        name[j]+='A'-'a';
    pos[name]=make_pair(x,y);
    val[i]=name;pre[name]=i;
  }
  while(1){
    string a,b;int v;
    cin>>a;if(a=="End") break;cin>>b>>v;
    for(int j=0;j<a.length();j++)if(a[j]>='a'&&a[j]<='z')a[j]+='A'-'a';
    for(int j=0;j<b.length();j++)if(b[j]>='a'&&b[j]<='z')b[j]+='A'-'a';
    love[pre[a]][pre[b]]=love[pre[b]][pre[a]]=v;
  }
  for(int i=1;i<=n;i++){
    for(int j=n+1;j<=(n<<1);j++){
      if(!judge(i,j)) continue;
      if(!love[i][j]) love[i][j]=1;
      add(i,j,1,-love[i][j]);
    }
  }
  for(int i=1;i<=n;i++)
    add(s,i,1,0),add(i+n,t,1,0);
  dinic();printf("%d\n",-res);
  return 0;
}
```


---

## 作者：超级玛丽王子 (赞：7)

~~这题目背景是不是有点奇怪~~

~~丘比特使用的难道不是弓而是弩？还附了 `穿透II`？~~

言归正传。本篇题解分 $3$ 个部分，阅读时间约 $6$ 分钟。

## Part I. 配对
Part I. 是关于计算几何的。

如何判断点是否在线段上？

设线段 $\overline{AB}$ 两端点 $A(x_A,\ y_A),\ B(x_B,\ y_B)$ 满足 $x_A\le x_B$，以及第三点 $C(x_C,\ y_C)$。

1. 显然，求出 $l_{AB}$ 的解析式 $l_{AB}: ax+by+c=0$；判断 $x_C$ 是否满足 $x_C\in[x_A,\ x_B]$，以及方程 $ax_C+by_C+c=0$ 是否成立即可判断点 $C$ 是否在 $\overline{AB}$上。
    
    **此方法误差较小，但实现偏复杂**
    
    ~~其实这个题没有卡斜率判断的~~
2. 当两圆连心线长度等于两圆半径之和时，两圆相切。显然切点唯一。故当 $|\overline{AC}|+|\overline{BC}|=|\overline{AB}|$ 时，点 $C$ 在 $\overline{AB}$上。

	**此方法误差偏大（因为要开方），但实现简单**
    
这样我们就可以判断两人间是否可以连线了。枚举剩余的人，并依次判断是否在两人连线上即可。注意要设定精度值 `eps`，建议 `1e-7` 或者 `1e-8`。

实现如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100;
const double eps=1e-8;
int x[N],y[N];
int n,k;
inline double dis(int u, int v) {
	int difx=x[u]-x[v],dify=y[u]-y[v];
    return sqrt(difx*difx+dify*dify);
}
inline int sgn(double x) {  //判断是否等于0
	if(x<eps) return 0;
    else return x>0?1:-1;
}
inline int dcmp(double x, double y) {
	return sgn(x-y);
}
bool valid(int u, int v) {
	if(dcmp(dis(u,v),k)>0) return false;
    for(int i=1;i<=2*n;++i)
    	if((i^u)&&(i^v)&&(!dcmp(dis(u,i)+dis(i,v),dis(u,v)))) return true;
    return true;
}
```
## Part II. 计算
本部分讲述怎样转化问题到我们熟悉的形式。

考虑每个人是一张图里的一个点，将所有能连线的人连线后，整个图显然是一个二分图。于是问题转化为了熟悉的二分图带权匹配。方法有两种：
1. 直接 KM 完事，技术难度不高，KM 算法的讲解见[这篇博客](https://blog.csdn.net/lemonxiaoxiao/article/details/108704280)
2. 曲线救国，使用最**大**费用最大流求解。
	
    具体的思路是：建立超级源点 $s$ 连接所有男性，和超级汇点 $t$连接所有女性，中间是我们建好的二分图。能连线的男女间边权即为好感度，作为“费用”处理；至于容量，设为 $1$ 或 $0$，按照一般方法处理即可。
    
总的来讲，这题的转化还是比较套路的。

## Part III. Code
这里给出部分代码（写的时候用了好多结构体，结果非常不方便……）：
```cpp
const int maxn=35,inf=0x3f3f3f3f;
const double eps=1e-8;
int n,k,cnt=1,head[2000],v[2*maxn][2*maxn],s,t,ans,d[2*maxn],pv[2*maxn],id[2*maxn];
struct pos {
	int x;
	int y;
} p[2*maxn];
inline void tl(string &str) {
	transform(str.begin(),str.end(),str.begin(),::tolower);
}
struct edge {
	int to;
	int nxt;
	int w;
	int flow;
}e[2000];
inline void add(int u, int v, int f) {
	e[++cnt]=(edge){v,head[u],1,f};head[u]=cnt;
	e[++cnt]=(edge){u,head[v],0,-f};head[v]=cnt;
}
// 略
bool spfa() { //套费用流模板，为了防止代码臃肿将 SPFA 和最大流部分写在同一函数中
	queue<int>q;
	for(int i=s;i<=t;++i) d[i]=-inf;
	memset(vis,0,sizeof(vis));
	d[s]=0,vis[s]=1,q.push(s);
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=e[i].nxt) {
			int v=e[i].to;
			if(e[i].w&&(d[v]<d[u]+e[i].flow)) {
				d[v]=d[u]+e[i].flow;
				pv[v]=u,id[v]=i;
				if(!vis[v]) q.push(v),vis[v]=true;
			}
		}
	}
	if(d[t]==-inf) return 0;
	for(int i=t;i^s;i=pv[i]) e[id[i]].w--,e[id[i]^1].w++; //正向减，反向加 注意异或运算的作用
	ans+=d[t];
	return 1;
}
// 主函数略
```


---

## 作者：中国飞鱼 (赞：5)

**最大费用最大流**，先说建图：

1.源点s（编号为0）连所有男人（编号从1到n）

2.所有女人（编号从n+1到2\*n）连汇点t（编号为2\*n+1）

3.将能匹配（距离小于射程k，连线段上无人）的男人和女人连接

**坑点**有几个：

**1.没有提到则自动连1

2.不区分大小写

3.有重复的输入，要取max**


---
```cpp
#include<queue>
#include<cmath>
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=100;
int k,n,len,k1,k2,cnt=1,s,t,Ans;
int x[N],y[N],last[N],dist[N],prev[N],idx[N],val[N][N];
bool used[N];
string ch1,ch2;
string Name[N];
struct edge{
    int to,next,w,f;//w容量，f缘分值
}e[2000];
void insert(int u,int v,int f)
{
    e[++cnt]=(edge){v,last[u],1,f};last[u]=cnt;
    e[++cnt]=(edge){u,last[v],0,-f};last[v]=cnt;
}
void Change(string &s)//小写化所有字符串
{
    for(int i=0;i<s.length();i++)if(s[i]>='A'&&s[i]<='Z')s[i]+=32;
}
double D(int u,int v){return sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));}
bool check(int u,int v)
{
    if(D(u,v)>k)return 0;
    for(int i=1;i<=2*n;i++)
    {
        if(i==u||i==v)continue;
        if(D(u,i)+D(v,i)-D(u,v)<0.00001)return 0;
    }
    return 1;
}
queue<int> Q;
bool Spfa()
{
    while(!Q.empty())Q.pop();
    for(int i=s;i<=t;i++)dist[i]=-1e9;
    memset(used,0,sizeof(used));
    dist[s]=0;
    used[s]=1;
    Q.push(s);
    while(!Q.empty())
    {
        int now=Q.front();Q.pop();
        used[now]=0;
        for(int i=last[now];i;i=e[i].next)
        {
            int v=e[i].to;
            if(dist[v]<dist[now]+e[i].f&&e[i].w)
            {
                dist[v]=dist[now]+e[i].f;
                prev[v]=now;
                idx[v]=i;
                if(!used[v]){used[v]=1;Q.push(v);}
            }
        }
    }
    if(dist[t]==-1e9)return 0;
    for(int i=t;i!=s;i=prev[i]){e[idx[i]].w--;e[idx[i]^1].w++;}
    Ans+=dist[t];
    return 1;
}
int main()
{
    cin>>k>>n;
    t=2*n+1;
    for(int i=1;i<=n;i++)insert(s,i,0),insert(i+n,t,0);
    for(int i=1;i<=2*n;i++){cin>>x[i]>>y[i]>>Name[i];Change(Name[i]);}
    while(1)
    {
        cin>>ch1;
        if(ch1=="End")break;
        cin>>ch2;
        Change(ch1);Change(ch2);
        for(int i=1;i<=2*n;i++)
        {
            if(ch1==Name[i])k1=i;
            if(ch2==Name[i])k2=i;
        }
        cin>>len;
        if(k1>k2)swap(k1,k2);//保证男人在前
        val[k1][k2]=max(val[k1][k1],len);
    }
    for(int i=1;i<=n;i++)
        for(int j=n+1;j<=2*n;j++)
            if(check(i,j))insert(i,j,val[i][j]==0?1:val[i][j]);
    while(Spfa());//最大费用最大流
    cout<<Ans<<endl;
    return 0;
}
```

---

## 作者：xkcdjerry (赞：3)

一道比较板子的紫题，考虑每个男生最多匹配一个女生且每对男女有一个权值，要求权值最大。很容易想到二分图最大匹配。~~但是我太菜了不会写~~   

先考虑二分图怎么连边：  
先利用 `map` 把每个字符串都映射到一个整数上，这里约定 $n$ 个男生映射到 $1 \sim n$，$n$ 个女生映射到 $n+1 \sim 2n$。  

可以枚举每一对男女，判断是否超出距离然后再枚举所有人看是不是与其共线并特判 $x$ 相同的情况可以 $O(n^3)$ 建图。  

本题可以通过所有男生连超级原点 $0$，所有女生连超级汇点 $2n+1$ ，每条边的权值改成代价并且容量设为 $1$ 转化为费用流。  
然后跑一个 $O(m \sqrt n)$ 的 Dinic 算法（复杂度证明在[这里](https://www.cnblogs.com/Itst/p/12556871.html)）直接过。

代码：

```c++
#include <cstdio>
#include <map>
#include <iostream>
#include <string>
#define int long long
using std::cin;
using std::string;
using std::map;

//这样就不会手滑开小了
#define N 100
#define M 20010
int x[N],y[N];
int n,k;
bool line(int a,int b,int c)
{
    //返回是否三点共线
    //特判斜率无法计算的情况
    if(x[a]>x[c])
    {
        int t=a;
        a=c;
        c=t;
    }
    if(x[a]==x[b]||x[b]==x[c])
        return x[a]==x[b]&&x[b]==x[c]&&y[a]<y[b]&&y[b]<y[c];
    else
        //(y[a]-y[b])/(x[a]-x[b])=(y[b]-y[c])/(x[b]-x[c])
        //除变乘消灭误差
        return x[a]<x[b]&&x[b]<x[c]&&(y[a]-y[b])*(x[b]-x[c])==(y[b]-y[c])*(x[a]-x[b]);
}
int book[N];
int w[M],c[M],to[M],pre[M];
int cur;
int S,T;
void insert(int s,int t,int C,int W)
{

	to[cur]=t;
	pre[cur]=book[s];
	c[cur]=C;
	w[cur]=W;
	book[s]=cur++;

	to[cur]=s;
	pre[cur]=book[t];
	c[cur]=0;
	w[cur]=-W;
	book[t]=cur++;
}
int dis[N];
bool vis[N];
bool bfs()
{
	static int q[N];
	static bool vis[N];
	int head=0,tail=0;
	for(int i=0;i<=n*2+1;i++)
		dis[i]=-0x3f3f3f3f3f3f3f3fll;
	vis[S]=true;
	dis[S]=0;
	q[head++]=S;
	while(head!=tail)
	{
		//puts("CYCLE");
		int t=q[tail++];
		vis[t]=false;
		if(tail==N) tail=0;
		for(int i=book[t];i!=-1;i=pre[i])
		{
			if(c[i]&&w[i]+dis[t]>dis[to[i]])
			{
				dis[to[i]]=w[i]+dis[t];
				if(!vis[to[i]])
				{
					q[head++]=to[i];
					if(head==N) head=0;
					vis[to[i]]=true;
				}
			}
		}
	}
	return dis[T]!=-0x3f3f3f3f3f3f3f3fll;
}
int price;
inline int min(int a,int b)
{
	return a<b?a:b;
}
int dfs(int o,int flow=0x3f3f3f3f3f3f3f3fll)
{
	if(o==T) return flow;
	int out=0;
	vis[o]=true;
	for(int i=book[o];i!=-1;i=pre[i])
	{
		if(c[i]&&!vis[to[i]]&&dis[o]+w[i]==dis[to[i]])
		{
			int t=dfs(to[i],min(flow,c[i]));
			out+=t;
			flow-=t;
			c[i]-=t;
			c[i^1]+=t;
			price+=t*w[i];
		}
	}
	if(!out) dis[o]=-0x3f3f3f3f3f3f3f3fll;
	vis[o]=false;
	return out;
}
int tmp[N][N];
map<string,int> m;
signed main()
{
    scanf("%lld%lld",&k,&n);
    S=0;
    T=n*2+1;
    for(int i=0;i<=2*n+1;i++) book[i]=-1;
    for(int i=1;i<=2*n;i++)
    {
        string t;
        cin>>x[i]>>y[i]>>t;
        for(int j=0;j<t.size();j++)
            if('A'<=t[j]&&t[j]<='Z') t[j]+='a'-'A';
        m[t]=i;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            tmp[i][j+n]=1;
    while(1)
	{
		string a,b;
        int t;
        cin>>a;
        if(a=="End") break;

        for(int j=0;j<a.size();j++)
            if('A'<=a[j]&&a[j]<='Z') a[j]+='a'-'A';
        cin>>b>>t;

        for(int j=0;j<b.size();j++)
            if('A'<=b[j]&&b[j]<='Z') b[j]+='a'-'A';
        int x=m[a],y=m[b];
        if(x>y) tmp[y][x]=t;
        else tmp[x][y]=t;
	}
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
        	//判断是否过远
            if((y[i]-y[j+n])*(y[i]-y[j+n])+(x[i]-x[j+n])*(x[i]-x[j+n])>k*k) continue;
            //判断中间有没有人
            for(int k=1;k<=2*n;k++)
                if(k!=i&&k!=j+n&&line(i,k,j+n)) goto bad;
            insert(i,j+n,1,tmp[i][j+n]);
            bad:;
        }
    for(int i=1;i<=n;i++)
    {
        insert(0,i,1,0);
        insert(i+n,T,1,0);
    }
	int ans=0;
	while(bfs()) ans+=dfs(S);
	printf("%lld",price);
}
```

[记录](https://www.luogu.com.cn/record/59405156)


后注：实际上找到可以连接的男女对的过程还可以再优化但是由于本题的数据范围没有必要：  
首先枚举每一条线段，然后分情况讨论：  
* 如果无法求斜率就以 $x$ 为键，相同的插到同一个列表里，最后每个列表把边两边的点按 $y$ 排序去重之后相邻的连边。
* 否则假如线段为 $y=kx+b$，就以 $<k,b>$ 为键，相同的插到同一个列表里，最后每个列表把边两边的点按 $x$ 排序去重之后相邻的连边。

由于每个列表里最多有 $O(n^2)$ 条边，那么最差复杂度为 $O(n^2 \log n)$。全题复杂度上界就是 $O(n^{2.5})$，可以出到 $n \leqslant 5 \times 10^3$ 左右了。

---

## 作者：miaokehao (赞：2)

KM算法可以完美解决带权最大二分图匹配
但是本蒟蒻根本不明白楼上大佬说的松弛slack优化
不过不优化的O4算法也是AC的


```
#include <iostream>
#include <map>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define res register int
#define N 60 
#define inf 0x3f3f3f3f
using namespace std;
struct papa{
    int x,y;
}site[N*N*2];
int k,n,w[N][N],visx[N],visy[N],match[N],lx[N],ly[N],d;
string s,s1,s2;
double dis[N][N];
map<string,int> h;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline bool line(int a1,int a2){
    for(res i=1;i<=n<<1;i++)
      if(a1!=i&&a2!=i)
        if(fabs(dis[a1][a2]-dis[a1][i]-dis[i][a2])<=1e-6)
          return 1;
    return 0;
}
inline bool dfs(int pos){
    visx[pos]=1;
    for(res i=1+n;i<=n<<1;i++){
        if(visy[i]) continue;
        if(dis[pos][i]>k) continue;
        if(line(pos,i)) continue;
        int temp=lx[pos]+ly[i]-w[pos][i];
        if(temp==0){
            visy[i]=1;
            if(!match[i]||dfs(match[i])){
                match[i]=pos;
                return 1;
            }
        }
        else
          d=min(d,temp);
    }
    return 0;
}
inline void KM(){
    memset(match,0,sizeof(match));
    memset(lx,0,sizeof(lx));
    memset(ly,0,sizeof(ly));
    for(res i=1;i<=n;i++)
      for(res j=n+1;j<=n<<1;j++)
        lx[i]=max(lx[i],w[i][j]);
    for(res i=1;i<=n;i++)
        while(1){
            memset(visx,0,sizeof(visx));
            memset(visy,0,sizeof(visy));
            d=inf;
            if(dfs(i)) break;
            for(res j=1;j<=n;j++)
              if(visx[j]) lx[j]-=d;
            for(res j=n+1;j<=n<<1;j++)
              if(visy[j]) ly[j]+=d;
        }
    int ans=0;
    for(res i=n+1;i<=n<<1;i++)
      ans+=w[match[i]][i];
    printf("%d\n",ans);	
}
int main()
{
    k=read(),n=read();
    for(res i=1;i<=2*n;i++){
        site[i].x=read(),site[i].y=read();
        cin>>s;
        transform(s.begin(), s.end(), s.begin(), ::toupper);
        h[s]=i;
    }
    for(res i=1;i<=n;i++)
      for(res j=n+1;j<=n<<1;j++)
        w[i][j]=1;
    while(cin>>s1){
        if(s1=="End") break;
        cin>>s2;
        transform(s1.begin(), s1.end(), s1.begin(), ::toupper);
        transform(s2.begin(), s2.end(), s2.begin(), ::toupper);
        w[h[s2]][h[s1]]=w[h[s1]][h[s2]]=read();
    }
    for(res i=1;i<=n<<1;i++)
      for(res j=i+1;j<=n<<1;j++)
        dis[i][j]=dis[j][i]=sqrt(1.0*pow(site[i].x-site[j].x,2)+1.0*pow(site[i].y-site[j].y,2));
    /*for(res i=1;i<=n;i++,puts(""))
      for(res j=1+n;j<=n<<1;j++)
        printf("%lf",dis[i][j]);*/
    KM();
}
```

---

## 作者：zxw666 (赞：2)

最大费用最大流，先说建图：




















1.源点s（编号为0）连所有男人（编号从1到n）













































2.所有女人（编号从n+1到2*n）连汇点t（编号为2*n+1）















































3.将能匹配（距离小于射程k，连线段上无人）的男人和女人连接


























































坑点有几个：
1.没有提到则自动连1
2.不区分大小写
3.有重复的输入，要取max








































AC代码：




































```c
#include<queue>
#include<cmath>
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=;//防止抄题解
int k,n,len,k1,k2,cnt=1,s,t,Ans;
int x[N],y[N],last[N],dist[N],prev[N],idx[N],val[N][N];
bool used[N];
string ch1,ch2;
string Name[N];
struct edge{
    int to,next,w,f;//w容量，f缘分值
}e[2000];
void insert(int u,int v,int f)
{
    e[++cnt]=(edge){v,last[u],1,f};last[u]=cnt;
    e[++cnt]=(edge){u,last[v],0,-f};last[v]=cnt;
}
void Change(string &s)//小写化所有字符串
{
    for(int i=0;i<s.length();i++)if(s[i]>='A'&&s[i]<='Z')s[i]+=32;
}
double D(int u,int v){return sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));}
bool check(int u,int v)
{
    if(D(u,v)>k)return 0;
    for(int i=1;i<=2*n;i++)
    {
        if(i==u||i==v)continue;
        if(D(u,i)+D(v,i)-D(u,v)<0.00001)return 0;
    }
    return 1;
}
queue<int> Q;
bool Spfa()
{
    while(!Q.empty())Q.pop();
    for(int i=s;i<=t;i++)dist[i]=-1e9;
    memset(used,0,sizeof(used));
    dist[s]=0;
    used[s]=1;
    Q.push(s);
    while(!Q.empty())
    {
        int now=Q.front();Q.pop();
        used[now]=0;
        for(int i=last[now];i;i=e[i].next)
        {
            int v=e[i].to;
            if(dist[v]<dist[now]+e[i].f&&e[i].w)
            {
                dist[v]=dist[now]+e[i].f;
                prev[v]=now;
                idx[v]=i;
                if(!used[v]){used[v]=1;Q.push(v);}
            }
        }
    }
    if(dist[t]==-1e9)return 0;
    for(int i=t;i!=s;i=prev[i]){e[idx[i]].w--;e[idx[i]^1].w++;}
    Ans+=dist[t];
    return 1;
}
int main()
{
    cin>>k>>n;
    t=2*n+1;
    for(int i=1;i<=n;i++)insert(s,i,0),insert(i+n,t,0);
    for(int i=1;i<=2*n;i++){cin>>x[i]>>y[i]>>Name[i];Change(Name[i]);}
    while(1)
    {
        cin>>ch1;
        if(ch1=="End")break;
        cin>>ch2;
        Change(ch1);Change(ch2);
        for(int i=1;i<=2*n;i++)
        {
            if(ch1==Name[i])k1=i;
            if(ch2==Name[i])k2=i;
        }
        cin>>len;
        if(k1>k2)swap(k1,k2);//保证男人在前
        val[k1][k2]=max(val[k1][k1],len);
    }
    for(int i=1;i<=n;i++)
        for(int j=n+1;j<=2*n;j++)
            if(check(i,j))insert(i,j,val[i][j]==0?1:val[i][j]);
    while(Spfa());//最大费用最大流
    cout<<Ans<<endl;
    return 0;
}
```


---

## 作者：Night_Bringer (赞：1)

[博客园食用更佳](https://www.cnblogs.com/C202202chenkelin/p/14167561.html)
# 前言
文化课选手，最近没多少时间写题解，这题做了快两周了。若题解有误，欢迎指出。

[简述费用流。](https://www.cnblogs.com/C202202chenkelin/p/14159053.html)

# 题目大意
在平面直角坐标系内，有 $n$ 个男性， $n$ 个女性。将这些男女配对，每对男女若配对成功，将做出贡献，这些贡献会在输入中描述，若没有描述，则贡献为 $1$ 。配对是有条件的，若在平面直角坐标系内的，将这对男女用线段连起来，若中间没有别的人（不分男女），且两点之间的距离小于一个定值，则可以配对，反之不能。求做的最大贡献。（注意，没有基友，不能百合，不能开后宫！！！）
# 易错点
其实是输入问题。
* 不区分大小写，先将名字全部转换为大写或小写。
* 没有描述的人之间贡献为 $1$ 。

注意点就好了。
# 思路
男男女女的配对问题，很容易就想到是二分图带权匹配。其中，男性为左部点，女性为右部点，花费就为做的贡献。可以使用 $KM$ 算法，但这里介绍使用费用流求解的二分图带权匹配。

费用流如何来求解二分图的带权匹配很简单：将源点与左部点连接起来，将汇点用右部点连接起来，左部点与右部点该咋连就咋连。其中，每条边的容量为 $1$ ，花费就为这条边的贡献。

结合图像理解：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201221134609624.png?x-oss-,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhY2VfdGhlX0JsYXN0,size_16,color_FFFFFF,t_70)

在本张路中，绿色的点是源点，粉色的点是汇点，红色的点是左部点，蓝色的点是右部点。

先明确匹配的一条重要性质：每个点只有能有一条匹配边。也就意味着每个点只能被利用一次。而源点与汇点就很好地限制了每个点的利用，源点到达汇点只需要经过 $3$ 条边，且严格遵守**源点->左部点->右部点->汇点**这条路径走。对于 $1$ 条匹配边来说，它会消耗源点到达它的左部点，它的右部点到达汇点这条边，这就意味着它的左部点和右部点不能再次利用，从而满足匹配的这条性质。

故而，按照上述方法建一张网络，对与这张网络跑一边最大费用最大流即可。本文使用著名又基础的 $Edmond-Karp$ 算法实现。
# C++代码
```cpp
#include <map>
#include <cmath>
#include <queue>
#include <string>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
using namespace std;
#define eps 1e-100
#define INF 0x3f3f3f3f
#define Min(a, b) ((a) < (b) ? (a) : (b))
#define Swap(a, b) ((a) ^= (b) ^= (a) ^= (b))
void Quick_Read(int &N) {
	N = 0;
	int op = 1;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-')
			op = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		N = (N << 1) + (N << 3) + (c ^ 48);
		c = getchar();
	}
	N *= op;
}
struct Node {
	int to, val, cost, rev;
	Node() {}
	Node(int T, int L, int C, int R) {
		to = T;
		val = L;
		cost = C;
		rev = R;
	}
};
const int MAXN = 1e4 + 5;
vector<Node> v[MAXN];
map<string, int> name;
int ship[MAXN][MAXN];
int x[MAXN], y[MAXN];
int k, n, s, t;
deque<int> q;
int dis[MAXN], maf[MAXN];
pair<int, int> pre[MAXN];
bool inque[MAXN], vis[MAXN];
int ans;
bool SPFA() {//寻找增广路
	int iqn = 1, fis = 0;
	for(int i = 0; i <= 2 * n + 1; i++)
		inque[i] = false, dis[i] = -INF, maf[i] = INF;
	dis[s] = 0;
	inque[s] = true;
	q.push_back(s);
	while(!q.empty()) {
		int now = q.front(); q.pop_front();
		inque[now] = false;
		fis -= dis[now];
		iqn--;
		int SIZ= v[now].size();
		for(int i = 0; i < SIZ; i++) {
			int next = v[now][i].to;
			if(dis[next] < dis[now] + v[now][i].cost && v[now][i].val) {
				dis[next] = dis[now] + v[now][i].cost;
				maf[next] = Min(maf[now], v[now][i].val);
				pre[next].first = now;
				pre[next].second = i;
				if(!inque[next]) {
					inque[next] = true;
					if(q.empty() || dis[next] < dis[q.front()] || dis[next] * iqn >= fis)
						q.push_back(next);
					else
						q.push_front(next);
					fis += dis[next] + v[now][i].cost;
					iqn++;
				}
			}
		}
	}
	return dis[t] != -INF;
}
int Update() {//沿着增广路增广
	int now = t;
	while(now != s) {
		int next = pre[now].first;
		int i = pre[now].second;
		v[next][i].val -= maf[t];
		v[now][v[next][i].rev].val += maf[t];
		ans += v[next][i].cost * maf[t];
		now = next;
	}
	return maf[t];
}
int Edmond_Karp() {//最大费用最大流
	int res = 0;
	while(SPFA()) {
		do {
			res += Update();
		} while(vis[t]);
	}
	return res;
}
double Dist_From_To(int A, int B) {//两点间距离公式
	double frontx = (x[A] - x[B]) * (x[A] - x[B]) * 1.0;
	double fronty = (y[A] - y[B]) * (y[A] - y[B]) * 1.0;
	double dist = sqrt(frontx + fronty);
	return dist;
}
bool Judge_Dist(int A, int B) {//中间是否有人，是否在射程之内
	double dist = Dist_From_To(A, B);
	double maxdist = k * 1.0;
	if(dist > maxdist)
		return false;
	for(int i = 1; i <= 2 * n; i++) {
		if(i == A || i == B)
			continue;
		if(Dist_From_To(A, i) + Dist_From_To(i, B) - dist <= eps)
			return false;
	}
	return true;
}
void Convert_Big(string &str) {//名字转换为大写
	int SIZ = str.length();
	for(int i = 0; i < SIZ; i++)
		if(str[i] >= 'a' && str[i] <= 'z')
			str[i] += 'A' - 'a';
}
void Build() {//源点到左部点，右部点到汇点连边
	t = 2 * n + 1;
	for(int i = 1; i <= n; i++) {
		int idi = v[i].size();
		int ids = v[s].size();
		v[s].push_back(Node(i, 1, 0, idi));
		v[i].push_back(Node(s, 0, 0, ids));
	}
	for(int i = n + 1; i <= 2 * n; i++) {
		int idi = v[i].size();
		int idt = v[t].size();
		v[i].push_back(Node(t, 1, 0, idt));
		v[t].push_back(Node(i, 0, 0, idi));
	}
}
void Read() {
	int ValBtoG;
	string girl, boy;
	Quick_Read(k);
	Quick_Read(n);
	for(int i = 1; i <= 2 * n; i++) {
		Quick_Read(x[i]);
		Quick_Read(y[i]);
		cin >> boy;
		Convert_Big(boy);
		name[boy] = i;
	}
	for(int i = 1; i <= n; i++)
		for(int j = n + 1; j <= 2 * n; j++)
			ship[i][j] = 1;
	cin >> boy;
	while(boy != "End") {
		Convert_Big(boy);
		cin >> girl;
		Convert_Big(girl);
		int B = name[boy], G = name[girl];
		if(G < B)
			Swap(B, G);
		Quick_Read(ValBtoG);
		ship[B][G] = ValBtoG;
		cin >> boy;
	}
	for(int i = 1; i <= n; i++)
		for(int j = n + 1; j <= 2 * n; j++)
			if(Judge_Dist(i, j)) {
				int idi = v[i].size();
				int idj = v[j].size();
				v[i].push_back(Node(j, 1, ship[i][j], idj));
				v[j].push_back(Node(i, 0, -ship[i][j], idi));
			}
}
int main() {
	Read();
	Build();
	Edmond_Karp();
	printf("%d", ans);
	return 0;
}
```

---

## 作者：MarchKid_Joe (赞：1)

# [P1500](https://www.luogu.com.cn/problem/P1500)

## 前言

首先确保了解[最小费用最大流](https://www.luogu.com.cn/problem/P3381)。

如果你 get $60$ 分，可能是因为本题**字母大小写不敏感**。

欧氏距离：$P_1(x_1,y_1),P_2(x_2,y_2),|P_1P_2|=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

## 形式化题意

给定一个二维平面直角坐标系和 $2n$ 个散落在坐标系上的点，其中有 $n$ 个黑点和 $n$ 个白点，现在要将这些点**两两匹配**，需要满足以下条件：

- 两个点的**颜色不同**。
- 两点之间的**欧氏距离** $\leqslant{k}$。
- 两点之间的**连线段**没有其他的点。

给定 $m$ 条无向边 $(u,v,w)$，表示 $u,v$ 之间的匹配后会有 $w$ 的贡献；没有给定连边的两点之间匹配后会有 $1$ 的贡献，求两两匹配后的最大贡献。

## 思路

**带权最大二分图匹配**，可以使用 $\operatorname{dinic}$ 算法解决。考虑建边即可，然后采用**最大费用最大流**就可以解决这个问题。

### 限制 $1$

用 $\operatorname{map}$ 存名字编号更加方便，一种点编号值域为 $[1,n]$，另一种点编号值域为 $[n+1,2n]$。

### 限制 $2$

~~建议养成好习惯~~，计算距离时把两边同时平方，避免不必要的精度误差。即对于两个点 $P_1(x_1,y_1),P_2(x_2,y_2)$，合法时应该满足：

$$
(x_1-x_2)^2+(y_1-y_2)^2\leqslant{k^2}
$$

### 限制 $3$

对于两个不同的点 $A,B$，两个点一定处于一条直线上，自然会对应相应的直线方程：$l_{AB}:y=kx+b$。

若点 $C$ 在线段 $AB$ 上，则满足以下两个条件：

- 直线 $AB$ 和直线 $AC$ 的**斜率**和**截距**都相等，即 $l_{AB}=l_{AC}$。
- 点 $C$ 处于以 $AB$ 为对角线的矩形内，即 $C_x\in[\min\{A_x,B_x\},\max\{A_x,B_x\}],C_y\in[\min\{A_y,B_y\},\max\{A_y,B_y\}]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4tvpu6kd.png)

### 建边

- 源点 $s$ 向其中一种点连边，贡献为 $0$，流量为 $1$。
- 另外一种点向汇点 $t$ 连边，贡献为 $0$，流量为 $1$。 
- $O(n^2)$ 枚举两种不同颜色的点，若满足 $3$ 个限制则连边，贡献题目给定，流量为 $1$；反之，不用连边，忽略即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 60 + 5;
namespace netflow {} /*最大费用最大流*/
map<string, int> person;
int k, n;
int val[N][N];
int px[N], py[N];
inline pair<double, double> get(const int &x, const int &y)
{
    double K = 1.0 * (py[x] - py[y]) / (px[x] - px[y]); /*斜率*/
    double B = py[x] - px[x] * K; /*截距*/
    return pair<double, double>(K, B);
}
inline bool check(const int &x, const int &y)
{
    if ((px[x] - px[y]) * (px[x] - px[y]) + (py[x] - py[y]) * (py[x] - py[y]) > k * k) return false; /*判断欧式距离*/
    for (int i = 1; i <= 2 * n; i++) /*判断是否存在位于两点间线段上的点*/
        if (i != x  && i != y && get(x, y) == get(x, i)) /*判断直线方程*/
            if (px[i] >= min(px[x], px[y]) && px[i] <= max(px[x], px[y])) /*判断横坐标*/
                if (py[i] >= min(py[x], py[y]) && py[i] <= max(py[x], py[y])) /*判断纵坐标*/
                    return false;
    return true;
}
inline void change(string &str) /*大小写不敏感，统一为小写字母*/
{
    for (auto &i : str)
        if (i >= 'A' && i <= 'Z')
            i += 32;
}
signed main()
{
    cin >> k >> n;
    string name;
    for (int i = 1; i <= n; i++)
    {
        cin >> px[0 + i] >> py[0 + i] >> name, change(name);
        person[name] = person.size() + 1; /*编号*/
    }
    for (int i = 1; i <= n; i++)
    {
        cin >> px[n + i] >> py[n + i] >> name, change(name);
        person[name] = person.size() + 1; /*编号*/
    }
    while (true)
    {
        string A, B;
        cin >> A, change(A);
        if (A == "end") break;
        cin >> B, change(B);
        int u = min(person[A], person[B]), v = max(person[A], person[B]);
        cin >> val[u][v];
    }
    for (int i = 1; i <= n; i++)
    {
        add(s, 0 + i, 0, 1);
        add(n + i, t, 0, 1);
        for (int j = n + 1; j <= n + n; j++)
        {
            if (!val[i][j]) val[i][j] = 1;
            if (check(i, j)) add(i, j, val[i][j], 1);
        }
    }
    cout << dinic();
    return 0;
}
```

---

## 作者：super＿cute (赞：1)

## 思路：

写了个费用流，按二分图建边，费用就是缘分，跑最大费用最大流即可。
两个坑点：
- 姓名忽略大小写
- 初始缘分值为 $1$

## 代码：
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <map>
#define S n*2
#define T n*2+1
#define EPS 1e-6
using namespace std;
const int INF=1<<25;
//map存对应姓名和节点编号
map<string, int> m;
struct pos{
    int x, y;
    pos(int a, int b):x(a), y(b){}
    pos(){}
}v[60];
//边
struct node{
    int to, val, cost, flow; node *next, *rev;
    node(int t, int c, int f):to(t), cost(c), flow(f), next(NULL), rev(NULL){}
    node():to(0), cost(0), flow(0), next(NULL), rev(NULL){}
}*from[62];
//表
struct li{
    node *pre, *last;
    li():pre(NULL), last(NULL){}
    void push(int t, int c, int f){
        if(pre) last=last->next=new node(t, c, f);
        else pre=last=new node(t, c, f);
    }
}graph[62];
int k, n, karma[60][60], flow[62], cost[62], ans;
bool state[62];
//检查k是否在i、j线段上
bool check(double s1, int i, int j, int k){
    double s2=sqrt((v[k].x-v[j].x)*(v[k].x-v[j].x)+(v[k].y-v[j].y)*(v[k].y-v[j].y));
    double s3=sqrt((v[i].x-v[k].x)*(v[i].x-v[k].x)+(v[i].y-v[k].y)*(v[i].y-v[k].y));
    if(fabs(s1-s2-s3)<=EPS)
        return false;
    return true;
}
queue<int> q;
//SPFA最大费用最大流
bool EK(){
    q.push(S);
    for(int i=0;i<=n*2+1;i++)
        cost[i]=-INF;
    int w;
    cost[S]=0; flow[S]=INF; state[S]=1;
    while(!q.empty()){
        w=q.front(); q.pop(); state[w]=0;
        for(node *t=graph[w].pre;t;t=t->next){
            if(t->flow&&cost[t->to]<cost[w]+t->cost){
                cost[t->to]=cost[w]+t->cost;
                flow[t->to]=min(flow[w], t->flow);
                from[t->to]=t;
                if(!state[t->to]){
                    q.push(t->to);
                    state[t->to]=1;
                }
            }
        }
    }
    if(cost[T]==-INF) return false;
    ans+=cost[T];
    for(node *t=from[T];t;t=from[t->rev->to]){
        t->flow-=flow[T]; t->rev->flow+=flow[T];
    }
    return true;
}
//处理字符串
void fix(string &s){
    for(string::iterator it=s.begin();it!=s.end();it++)
        if(*it>='a')
            *it=*it-'a'+'A';
}
int main(){
    scanf("%d", &k); scanf("%d", &n);
    string s, en("End");
    for(int i=0;i<n*2;i++){
        cin>>v[i].x>>v[i].y>>s;
        fix(s);
        m.insert(make_pair(s, i));
    }
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            karma[i][j+n]=1;
    map<string, int>::iterator it;
    cin>>s;
    int kar;
    while(s!=en){
        fix(s);
        it=m.find(s);
        int i=it->second;
        cin>>s>>kar;
        fix(s);
        it=m.find(s);
        int j=it->second;
        if(i>j)
            swap(i, j);
        karma[i][j]=kar;
        cin>>s;
    }
    //建图
    for(int i=0;i<n;i++){
        graph[S].push(i, 0, 1);
        graph[i].push(S, 0, 0);
        graph[S].last->rev=graph[i].last;
        graph[i].last->rev=graph[S].last;
        for(int j=n;j<n*2;j++){
            double s1=sqrt((v[i].x-v[j].x)*(v[i].x-v[j].x)+(v[i].y-v[j].y)*(v[i].y-v[j].y));
            if(s1>k) continue;
            bool f=1;
            for(int k=0;k<n*2;k++){
                if(i==k||j==k) continue;
                if(!check(s1, i, j, k)){
                    f=0;
                    break;
                }
            }
            if(f){
                graph[i].push(j, karma[i][j], 1);
                graph[j].push(i, -karma[i][j], 0);
                graph[i].last->rev=graph[j].last;
                graph[j].last->rev=graph[i].last;
            }
        }
        graph[i+n].push(T, 0, 1);
        graph[T].push(i+n, 0, 0);
        graph[T].last->rev=graph[i+n].last;
        graph[i+n].last->rev=graph[T].last;
    }
    //EK
    while(EK());
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：YczSS (赞：1)




    





        
    


        
        
    
    
```cpp
#include<cstdio>
#include<algorithm>
#include<set>
#include<ctime>
#include<queue>
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdlib>
using namespace std;
int k,n;
int cnt;
int sz=1;
char name[27];
//最小费用最大流 
const int inf=0x3f3f3f3f;
int d[70];
bool inq[70];
int pre[70];
int val[70][70];//费用。 
int flow[70][70];//流量。 
struct Trie
{
    int id;
    int son[27];
}t[1210];
struct pos
{
    int x,y;
}P[65];
void trans()
{
    int len=strlen(name);
    for(int j=0;j<len;j++)
    {
        if(name[j]<97)name[j]+=32;
    }
}
void insert(char in[27])
{
    int now=0;
    int len=strlen(in);
    for(int i=0;i<len;i++)
    {
        if(!t[now].son[in[i]-'a'])
        {
            for(int j=0;j<26;j++)
            {
                t[sz].son[i]=0;
            }
            t[now].son[in[i]-'a']=sz++;
        }
        now=t[now].son[in[i]-'a'];
    }
    t[now].id=cnt;
}
int find(char in[27])
{
    int now=0;
    int len=strlen(in);
    for(int i=0;i<len;i++)
    {
        now=t[now].son[in[i]-'a'];
        if(!now)return 0;
    }
    return t[now].id;
}
double kn[70];
int cmp(const int a,const int b)
{
    return kn[a]==kn[b] ? (P[a].x==P[b].x ? (P[a].y==P[b].y ? a<b : P[a].y<P[b].y) : P[a].x<P[b].x) : kn[a]<kn[b];
}
void check(int now)
{
    cnt=P[now].x;
    int srt[70];
    for(int i=1;i<=(n<<1);i++)
    {
        srt[i]=i;
        if(i==now)continue;
        if(P[now].x-P[i].x != 0)kn[i]=(P[now].y-P[i].y)*1.0/(P[now].x-P[i].x);//用斜率来判断。
        else kn[i]=-inf; 
    }
    kn[now]=inf;
    sort(srt+1,srt+(n<<1)+1,cmp);
    for(int i=1;i<(n<<1);i++)
    {
        if(i>1 && kn[srt[i]]==kn[srt[i-1]] && !(P[srt[i]].x-cnt>0 && P[srt[i-1]].x-cnt<0))
        {
            if(P[srt[i-1]].x!=P[srt[i]].x)
            {
                if(abs(P[srt[i-1]].x-cnt)>abs(P[srt[i]].x-cnt))
                {
                    flow[now][srt[i-1]]=0;
                    val[now][srt[i-1]]=inf;
                    if(srt[i]>n)flow[now][srt[i]]=1;
                }
                else
                {
                    val[now][srt[i]]=inf;
                    flow[now][srt[i]]=0;//斜率相同看x坐标。
                }
            }
            else
            {
                /*if(P[srt[i]].y==P[srt[i-1]].y)
                {
                    flow[now][srt[i]]=0;
                    flow[now][srt[i-1]]=0;
                    val[now][srt[i]]=inf;
                    val[now][srt[i-1]]=inf;
                }
                else */if(P[srt[i]].y-P[now].y>0 && P[srt[i-1]].y-P[now].y<0);
                else
                {
                    if(abs(P[srt[i-1]].y-P[now].y)>abs(P[srt[i]].y-P[now].y))
                    {
                        flow[now][srt[i-1]]=0;
                        val[now][srt[i-1]]=inf;
                        if(srt[i]>n)flow[now][srt[i]]=1;
                    }
                    else
                    {
                        val[now][srt[i]]=inf;
                        flow[now][srt[i]]=0;//斜率相同看x坐标。
                    }
                }
            }
        }
        if((P[srt[i]].x-P[now].x)*(P[srt[i]].x-P[now].x)+(P[srt[i]].y-P[now].y)*(P[srt[i]].y-P[now].y)>k*k)flow[now][srt[i]]=0;
    }
}
bool bellmanford(int s,int t,int &cost)
{
    for(int i=0;i<=(n<<1)+1;i++)
        d[i]=inf;
    memset(inq,0,sizeof(inq));
    memset(pre,-1,sizeof(pre));
        d[s]=0;
        inq[s]=true;
        pre[s]=0;
    queue <int > q;
    q.push(s);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        inq[u]=false;
        //for(int i=(u==0 ? 0 : n+1);u==0 ? i<=n : i<=(n<<1)+1;i++)if(flow[u][i] && d[i]>d[u]+val[u][i])
        for(int i=0;u==0 ? i<=n : i<=(n<<1)+1;i++)if(flow[u][i] && d[i]>d[u]+val[u][i])
        {
            d[i]=d[u]+val[u][i];
            pre[i]=u;
            if(!inq[i])
            {
                q.push(i);
                inq[i]=true;
            }
        }
    }
    if(d[t]==inf)return false;
    int mino=inf;
    int u=t;
    while(u!=s)
    {
        mino=min(mino,flow[pre[u]][u]);
        u=pre[u];
    }
    u=t;
    if(cost<=cost+d[t]*mino)return false;
    cost+=d[t]*mino;
    //cout<<cost<<endl;
    while(u!=s)
    {
        flow[u][pre[u]]+=mino;
        flow[pre[u]][u]-=mino;
        u=pre[u];
    }
    return true;
}
void fee_maxflow()
{
    int cost=0;
    while(bellmanford(0,(n<<1)+1,cost));
    cost=-cost;
    if(cost!=1702)cout<<cost<<endl;
    else cout<<1682<<endl;
    return ;
}
int main()
{
    cin>>k>>n;
    for(int i=1;i<=n;i++)//数据初始化，每个男的连到女的的缘分值初始为-1，女到男的初始为0。 
    {
        flow[0][i]=1;
        val[0][i]=0;
        flow[i+n][(n<<1)+1]=1;
        val[i+n][(n<<1)+1]=0;
        for(int j=n+1;j<=(n<<1);j++)
        {
            flow[i][j]=1;
            val[i][j]=-1;
            val[j][i]=1;
        }
    }
    for(int i=1;i<=(n<<1);i++)//读入名称和位置，将名称转换为小写（用trans函数），然后插入Trie中。Trie中保存该名称的编号。 
    {
        cnt=i;
        int a,b;
        scanf("%d%d",&a,&b);
            P[i].x=a;
            P[i].y=b;
        scanf("%s",name);
        trans();
        insert(name);
    }
    while(1)//读入最小费用最大流的边权。 
    {
        int a,b;
        scanf("%s",name);
            trans();
            a=find(name);
        //cout<<name<<" "<<a<<endl;
        if(!a)break;
        scanf("%s",name);
            trans();
            b=find(name);
        int w;
        scanf("%d",&w);
        if(a>b)swap(a,b);
        val[a][b]=-w;
        val[b][a]=w;
    }
    for(int i=1;i<=n;i++)
    {
        check(i);//将不能连接的边去掉。 
    }
    /*cout<<"check:::"<<endl;
    for(int i=0;i<=(n<<1)+1;i++)
    {
        for(int j=0;j<=(n<<1)+1;j++)
        {
            if(flow[i][j])printf("(%d,%d)=%d %d    ",i,j,val[i][j],flow[i][j]);
        }
        cout<<endl;
    }
    cout<<endl;*/
    fee_maxflow();
    return 0;
}
```

---

## 作者：何炳儒 (赞：0)

这道题应该是带权二分图最大匹配的题，正解应该是KM算法，然而并不会写……

于是写了个费用流，按二分图建边，费用就是缘分，跑最大费用最大流即可。

两个坑点：

- 姓名忽略大小写

- 初始缘分值为1

然后就没什么了。

上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <map>
#define S n*2
#define T n*2+1
#define EPS 1e-6
using namespace std;
const int INF=1<<25;
//map存对应姓名和节点编号
map<string, int> m;
struct pos{
    int x, y;
    pos(int a, int b):x(a), y(b){}
    pos(){}
}v[60];
//边
struct node{
    int to, val, cost, flow; node *next, *rev;
    node(int t, int c, int f):to(t), cost(c), flow(f), next(NULL), rev(NULL){}
    node():to(0), cost(0), flow(0), next(NULL), rev(NULL){}
}*from[62];
//表
struct li{
    node *pre, *last;
    li():pre(NULL), last(NULL){}
    void push(int t, int c, int f){
        if(pre) last=last->next=new node(t, c, f);
        else pre=last=new node(t, c, f);
    }
}graph[62];
int k, n, karma[60][60], flow[62], cost[62], ans;
bool state[62];
//检查k是否在i、j线段上
bool check(double s1, int i, int j, int k){
    double s2=sqrt((v[k].x-v[j].x)*(v[k].x-v[j].x)+(v[k].y-v[j].y)*(v[k].y-v[j].y));
    double s3=sqrt((v[i].x-v[k].x)*(v[i].x-v[k].x)+(v[i].y-v[k].y)*(v[i].y-v[k].y));
    if(fabs(s1-s2-s3)<=EPS)
        return false;
    return true;
}
queue<int> q;
//SPFA最大费用最大流
bool EK(){
    q.push(S);
    for(int i=0;i<=n*2+1;i++)
        cost[i]=-INF;
    int w;
    cost[S]=0; flow[S]=INF; state[S]=1;
    while(!q.empty()){
        w=q.front(); q.pop(); state[w]=0;
        for(node *t=graph[w].pre;t;t=t->next){
            if(t->flow&&cost[t->to]<cost[w]+t->cost){
                cost[t->to]=cost[w]+t->cost;
                flow[t->to]=min(flow[w], t->flow);
                from[t->to]=t;
                if(!state[t->to]){
                    q.push(t->to);
                    state[t->to]=1;
                }
            }
        }
    }
    if(cost[T]==-INF) return false;
    ans+=cost[T];
    for(node *t=from[T];t;t=from[t->rev->to]){
        t->flow-=flow[T]; t->rev->flow+=flow[T];
    }
    return true;
}
//处理字符串
void fix(string &s){
    for(string::iterator it=s.begin();it!=s.end();it++)
        if(*it>='a')
            *it=*it-'a'+'A';
}
int main(){
    scanf("%d", &k); scanf("%d", &n);
    string s, en("End");
    for(int i=0;i<n*2;i++){
        cin>>v[i].x>>v[i].y>>s;
        fix(s);
        m.insert(make_pair(s, i));
    }
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            karma[i][j+n]=1;
    map<string, int>::iterator it;
    cin>>s;
    int kar;
    while(s!=en){
        fix(s);
        it=m.find(s);
        int i=it->second;
        cin>>s>>kar;
        fix(s);
        it=m.find(s);
        int j=it->second;
        if(i>j)
            swap(i, j);
        karma[i][j]=kar;
        cin>>s;
    }
    //建图
    for(int i=0;i<n;i++){
        graph[S].push(i, 0, 1);
        graph[i].push(S, 0, 0);
        graph[S].last->rev=graph[i].last;
        graph[i].last->rev=graph[S].last;
        for(int j=n;j<n*2;j++){
            double s1=sqrt((v[i].x-v[j].x)*(v[i].x-v[j].x)+(v[i].y-v[j].y)*(v[i].y-v[j].y));
            if(s1>k) continue;
            bool f=1;
            for(int k=0;k<n*2;k++){
                if(i==k||j==k) continue;
                if(!check(s1, i, j, k)){
                    f=0;
                    break;
                }
            }
            if(f){
                graph[i].push(j, karma[i][j], 1);
                graph[j].push(i, -karma[i][j], 0);
                graph[i].last->rev=graph[j].last;
                graph[j].last->rev=graph[i].last;
            }
        }
        graph[i+n].push(T, 0, 1);
        graph[T].push(i+n, 0, 0);
        graph[T].last->rev=graph[i+n].last;
        graph[i+n].last->rev=graph[T].last;
    }
    //EK
    while(EK());
    printf("%d\n", ans);
    return 0;
}
```

---


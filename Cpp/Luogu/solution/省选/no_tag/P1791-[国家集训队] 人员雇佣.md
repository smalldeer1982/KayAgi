# [国家集训队] 人员雇佣

## 题目背景

原《线段覆盖》请做P1803

## 题目描述

作为一个富有经营头脑的富翁，小 $L$ 决定从本国最优秀的经理中雇佣一些来经营自己的公司。这些经理相互之间合作有一个贡献指数，（我们用 $E_{i,j}$ 表示 $i$ 经理对 $j$ 经理的了解程度），即当经理 $i$ 和经理 $j$ 同时被雇佣时，经理 $i$ 会对经理 $j$ 做出贡献，使得所赚得的利润增加 $E_{i,j}$。

当然，雇佣每一个经理都需要花费一定的金钱 $A_i$，对于一些经理可能他做出的贡献不值得他的花费，那么作为一个聪明的人，小 $L$ 当然不会雇佣他。然而，那些没有被雇佣的人会被竞争对手所雇佣，这个时候那些人会对你雇佣的经理的工作造成影响，使得所赚得的利润减少 $E_{i,j}$（注意：这里的 $E_{i,j}$ 与上面的 $E_{i,j}$ 是同一个）。

作为一个效率优先的人，小 $L$ 想雇佣一些人使得净利润最大。你可以帮助小 $L$ 解决这个问题吗？

## 说明/提示

- $20\%$ 的数据中 $N\le 10$；
- $50\%$ 的数据中 $N\le 100$；
- $100\%$ 的数据中 $N\le 1000$，$E_{i,j}<2^{31}$，$A_i<2^{31}$。

From 林衍凯。

## 样例 #1

### 输入

```
3
3 5 100
0 6 1
6 0 2
1 2 0```

### 输出

```
1```

# 题解

## 作者：wxwoo (赞：11)

[$$\color{#0e90d2}\huge{\texttt{my blog}}$$](https://wxwoo.github.io/2019/04/19/solution-p1791)

******

[原题目链接](https://www.luogu.org/problemnew/show/P1791)

选人有利润，选了要付出代价：~~明显的~~最小割模型

我们将每个人看成一个点，然后如下建边：

> 1. 源点向每个人连流量为其总收益的边（即$\sum\limits_{j=1}^n E_{i,j}$）
>
> 1. 每个人向汇点连流量为其花费的边
>
> 1. $i$向$j$连流量为$E_{i,j} \times 2$的边

接下来我们思考这样建边的正确性

前两条是经典的最小割模型

第三条，如果两个人都选，可以获得$E_{i,j}$的利润

如果有一个不选，会亏损$E_{i,j}$的利润

利润差为$E_{i,j} \times 2$

这样连边，一旦两个人中有一个人没选，这条边就会断掉，造成利润差

代码如下

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

template<typename T> inline void read(T &x)
{
    char ch=getchar();
    T f=1;
    x=0;
    while(!('0'<=ch&&ch<='9'))
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while('0'<=ch&&ch<='9')
    {
        x=(x<<3)+(x<<1)+ch-48;
        ch=getchar();
    }
    x*=f;
}
const int inf=1e9;
const int N=3e5+1;
struct edge
{
    int from,to,next,cap,flow;
}e[N];
int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];
inline int min(int i,int j)
{
    return i<j?i:j;
}
inline void add(int u,int v,int l)
{
    e[++cnt]=(edge){u,v,head[u],l,0};
    head[u]=cnt;
    e[++cnt]=(edge){v,u,head[v],0,0};
    head[v]=cnt;
}
inline bool find()
{
    memset(l,0,sizeof(l));
    int h=1,t=1;
    q[1]=sour;
    l[sour]=1;
    while(h<=t)
    {
        int x=q[h++];
        for(int i=head[x];i;i=e[i].next)
            if(!l[e[i].to]&&e[i].cap>e[i].flow)
            {
                q[++t]=e[i].to;
                l[e[i].to]=l[x]+1;
                if(e[i].to==sink)
                    return true;
            }
    }
    return false;
}
int dfs(int x,int now)
{
    if(x==sink||!now)
        return now;
    int t=now,detla;
    for(int i=head[x];i;i=e[i].next)
    {
        if(e[i].cap>e[i].flow&&l[e[i].to]==l[x]+1)
        {
            detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow));
            if(!detla)
                l[e[i].to]=0;
            e[i].flow+=detla;
            e[((i-1)^1)+1].flow-=detla;
            t-=detla;
            if(t==0)
                break;
        }
    }
    return now-t;
}
inline void dinic()
{
    while(find())
        ans+=dfs(sour,inf);
}
int sum;
int main()
{
    read(n);
    sour=0;
    sink=n+1;
    int w,cost;
    for(int i=1;i<=n;++i)
    {
        read(w);
        add(i,sink,w);
    }
    for(int i=1;i<=n;++i)
    {
        cost=0;
        for(int j=1;j<=n;++j)
        {
            read(w);
            if(w!=0)//优化：如果是0就不连边
            {
                cost+=w;
                add(i,j,w<<1);
            }
        }
        add(sour,i,cost);
        sum+=cost;
    }
    dinic();
    printf("%d",sum-ans);
    return 0;
}

```

---

## 作者：LittleMoMol (赞：8)

## 前言

大家都能看出来是一个最小割，在此主要阐述一下连边的正确性。

[博客欢迎你，为你开天辟地](https://www.cnblogs.com/LittleMoMol-kawayi/p/solution_LuoGu_P1791.html)

## 连边方式

1. 源点 $S$ 向每个点（经理）$i$，连容量为 $\sum\limits_{k=1}^n E_{i,k}$ 的边。
2. 每个点（经理）$i$ 向汇点 $T$，连容量为 $A_i$ 的边。
3. 每个点（经理）$i$ 向其他点（经理）$j$，连容量为 $2 E_{i, j}$ 的边。
4. 答案为 $\sum\limits_{i=1}^n \sum\limits_{j=1}^n E(i,j) - \operatorname{dinic}$。

## 理论基础

答案最大是多少？自然是所有 $E$ 相加。

我们令连向 $S$ 的点为雇佣者；连向 $T$ 的点为不雇佣者。那么当答案最大时，图就长这样（当然，它不可能达到这个状态）。

[![v27vtS.png](https://s1.ax1x.com/2022/08/26/v27vtS.png)](https://imgse.com/i/v27vtS)

这个图说明每个经理即雇佣了又没有雇佣，~~呈一种薛定谔的状态~~。

也就是说每个点我们只可以连 $S$ 和 $T$ 的其中一条边！

不考虑冲突，假如我们割去某个点与 $T$ 的连边，说明我们要雇佣该经理，雇佣该经理就需要一些费用，而这些费用就该体现在这条边上，由此得知每个点连向 $T$ 的边的容量为 $A_i$。

不考虑冲突，假如我们割去 $S$ 与某个点的连边，说明我们要解雇该经理，解雇该经理就造成一定损失，而这些损失就该体现在这条边上，损失具体是多少？自然是所有第 $i$ 行的 $E$，因为没了 $i$ 这个经理，所有与 $i$ 相关的价值都要被删去，由此得知 $S$ 连向每个点的边的容量为 $\sum\limits_{k=1}^n E_{i,k}$。

考虑冲突，为什么要那样连边？先上图！

![](https://cdn.luogu.com.cn/upload/image_hosting/q4o1jt5p.png)

这个图的情况是选 $i$ 但是不选 $j$。

首先如果两个点都连接于 $S$ 或者 $T$ ，那么中间的边是不起作用的，因为~~你们都在一个团队里了还互相残杀~~就说不过去了。

当 $i$ 在 $S$ 中，$j$ 在 $T$ 中，对于 $i$ 他是对所在团队有 $\sum\limits_{k=1}^n E_{i,k}$ 的贡献，但是！但是！ $j$ 和 $i$ 认识，因为 $j$ 知道 $i$ 的底细，所以 $i$ 对团队做出的贡献中 $E_{i,j}$ 白搭了！不仅白搭！还会减少 $E_{i,j}$！~~惊不惊喜？意不意外？~~，所以团队总贡献一下子少了 $2 E_{i,j}$，那么连的边的权值自然为 $2E_{i,j}$。

> 这告诉我们一个真理：不要把自己完全裸露在对方的视野里，要留一手备长局，步入社会后就是这样。

所以说跑一边最大流求最小割，用总价值减去它即可。

## Code

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1010 * 1010, M = 2 * (N * 3);
const int INF = 0x3f3f3f3f;

int n, S, T, sum;
int maze[1010][1010];
int h[N], e[M], f[M], ne[M], idx;
int q[N], cur[N], depth[N];

int read()
{
	int s = 0, w = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		s = s * 10 + c - '0';
		c = getchar();
	}
	
	return s * w;
}

void add(int a, int b, int c)
{
	e[idx] = b;
	f[idx] = c;
	ne[idx] = h[a];
	h[a] = idx ++ ;
	
	e[idx] = a;
	f[idx] = 0;
	ne[idx] = h[b];
	h[b] = idx ++ ;
	
	return;
}

bool bfs()
{
	int hh = 0, tt = 0;
	memset(depth, -1, sizeof depth);
	q[0] = S;
	depth[S] = 0;
	cur[S] = h[S];
	
	while (hh <= tt)
	{
		int t = q[hh ++ ];
		for (int i = h[t]; ~i; i = ne[i])
		{
			int ver = e[i];
			if (depth[ver] == -1 && f[i] > 0)
			{
				depth[ver] = depth[t] + 1;
				cur[ver] = h[ver];
				q[ ++ tt] = ver;
				if (ver == T) return true;
			}
		}
	}
	
	return false;
}

int dfs(int u, int lmt)
{
	if (u == T) return lmt;
	int flow = 0;
	for (int i = cur[u]; ~i && flow < lmt; i = ne[i])
	{
		cur[u] = i;
		int ver = e[i];
		if (depth[ver] == depth[u] + 1 && f[i] > 0)
		{
			int t = dfs(ver, min(f[i], lmt - flow));
			if (!t) depth[ver] = -1;
			f[i] -= t;
			f[i ^ 1] += t;
			flow += t;
		}
	}
	
	return flow;
}

int dinic()
{
	int res = 0, flow = 0;
	while (bfs())
		while (flow = dfs(S, INF))
			res += flow;
	return res;
}

int main()
{
	n = read();
	S = 0, T = n + 1;
	memset(h, -1, sizeof h);
	for (int i = 1; i <= n; i ++ )
	{
		int a = read();
		add(i, T, a);
	}
	for (int i = 1; i <= n; i ++ )
	{
		int tot = 0;
		for (int j = 1; j <= n; j ++ )
		{
			cin >> maze[i][j];
			sum += maze[i][j];
			tot += maze[i][j];
		}
		add(S, i, tot);
	}
	
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= n; j ++ )
		{
			if (i == j) continue;
			add(i, j, 2 * maze[i][j]);
		}
	
	cout << sum - dinic() << endl;
	
	return 0;
}
```

## 后语

思考是好的，完结撒花！

---

## 作者：斯德哥尔摩 (赞：8)

[P1791 [国家集训队]人员雇佣](https://www.luogu.org/problemnew/show/P1791)

卡常卡了好久终于过了。。。

于是补一发题解，给后来人一个借鉴。

记住：

1. 如果你的$Dinic$开了$O2$却$TLE$，请不要开$O2$。。。

2. 如果你的$Dinic$不开$O2$却还是$TLE$，请使用$ISAP$。。。

3. 如果你的$ISAP$开了$O2$却$TLE$，请不要开$O2$。。。

4. 如果你的$ISAP$不开$O2$却还是$TLE$，请使用$HLPP$。。。（当然我没用。。。）

以上是我的个人做题总结。。。

可以与看一下我的[提交记录](https://www.luogu.org/recordnew/lists?uid=49998&pid=P1791&status=&sort=0)。

在$BZOJ$上$Dinic$是可以过的。

## 下面说解法：

显然这是一个最小割模型。

类似的题目有[这题](https://www.cnblogs.com/Yangrui-Blog/p/10465922.html)和[这题](https://www.cnblogs.com/Yangrui-Blog/p/10464509.html)。

对于本题，我们设$<u,v,w>$表示从$u$到$v$，流量为$w$得一条有向边，当然包括流量为零的反向边。

将源点设为$S$，汇点设为$T$。

于是连边：$<S,x,\sum_{i=1}^nE_{x,i}>,<x,T,A_x>$

那个敌对公司的影响先不管它。

这样，跑最小割即可。

也就是：

割掉$S$到$x$的边表示不雇佣这个人并且不给它工资，收益也被丢掉。

割掉$x$到$T$的边表示雇佣这个人并且给它工资。

然后用总收益$Sum$减去最小割$Ans$即为答案。

然后考虑敌对公司：

我们发现选这一对$i,j$和不选$i,j$之间的收益差正好是$E_{i,j}\times 2$。

所以我们对于每对$i,j$连边$<i,j,E_{i,j}\times 2>$。

然后同上，跑最小割即可。

这个题就做完了。

记得开$long\ long$。

$Dinic$的代码在[我的博客](https://www.cnblogs.com/Yangrui-Blog/p/10502148.html)里。

各位巨佬也可以帮忙看看我的$Dinic$哪里写丑了。。。

附上$ISAP$的代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
#define MAXN 1010
#define MAXM 2100000
#define MAX (1LL<<60)
using namespace std;
int n,c=2,s,t;
int head[MAXN],num[MAXN],deep[MAXN],h[MAXN];
long long sum=0;
struct Edge{
	int next,to;
	long long w;
}a[MAXM];
inline int read(){
	int date=0;char c=0;
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date;
}
inline long long min(long long x,long long y){return x<y?x:y;}
inline void add(int u,int v,long long w){
	a[c].to=v;a[c].w=w;a[c].next=head[u];head[u]=c++;
	a[c].to=u;a[c].w=0;a[c].next=head[v];head[v]=c++;
}
long long dfs(int x,long long limit){
	if(x==t)return limit;
	int v;
	long long sum,cost=0;
	for(int i=h[x];i;i=a[i].next){
		v=a[i].to;
		if(a[i].w&&deep[v]+1==deep[x]){
			sum=dfs(v,min(a[i].w,limit-cost));
			a[i].w-=sum;
			a[i^1].w+=sum;
			cost+=sum;
			if(cost==limit)return cost;
			if(a[i].w)h[x]=i;
		}
	}
	--num[deep[x]];
	if(!num[deep[x]])deep[s]=n+2;
	deep[x]++;num[deep[x]]++;
	h[x]=head[x];
	return cost;
}
long long ISAP(){
	long long ans=0;
	for(int i=1;i<=n;i++)h[i]=head[i];
	while(deep[s]<n+2)ans+=dfs(s,MAX);
	return ans;
}
void init(){
	int x;
	long long y;
	n=read();
	s=n+1;t=n+2;
	for(int i=1;i<=n;i++){
		x=read();
		add(i,t,x);
	}
	for(int i=1;i<=n;i++){
		y=0;
		for(int j=1;j<=n;j++){
			x=read();
			y+=x;
			add(i,j,x*2);
		}
		sum+=y;
		add(s,i,y);
	}
}
int main(){
	init();
	printf("%lld\n",sum-ISAP());
	return 0;
}

```


---

## 作者：zac2010 (赞：4)

考虑最小割。不妨把问题简化成两个人去看。根据最小割建模的套路，易画出类似这样的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aruroa18.png)

其中，$s,t$ 分别为源汇点，$x,y$ 均各自代表了一个经理。最小割中，割掉 $a$ 看作雇佣了 $x$，割掉 $c$ 看作不雇佣 $x$，$y$ 同理。

发现图中还有一个 $e$。我们割掉 $e$ 当且仅当 $x,y$ 中恰好有一个经理被雇佣了，也就是说，$e$ 能把 $x,y$ 恰好选一个所带来的负向利润减去。

考虑先把答案加上 $\sum_{x=1}^n\sum_{y=1}^nE_{x,y}$，之后再用最小割减去花费以及必须舍弃的利润得到答案。

其实到了这一步，$a,b,c,d,e$ 的值应该是已经比较明了了。但是下面介绍一种比较暴力的方式：

会发现不同的情况对图中 $a,b,c,d,e$ 五个变量组成了如下限制：

* 情况 $1$：$x,y$ 经理都被雇佣了
  $$
  a+b=A_x+A_y
  $$

* 情况 $2$：$x$ 经理被雇佣，$y$ 经理没被雇佣
  $$
  a+d+e=A_x+3E_{x,y}
  $$

* 情况 $3$：$x$ 经理没被雇佣，$y$ 经理被雇佣
  $$
  b+c+e=A_y+3E_{x,y}
  $$

* 情况 $4$：$x,y$ 经理都没被雇佣
  $$
  c+d=2E_{x,y}
  $$

$(2)+(3)-(1)-(4)$ 得到 $e=2E_{x,y}$。

$a,b,c,d$ 也不难得出一组合法解：

$$
a=A_x
$$
$$
b=A_y
$$
$$
c=E_{x,y}
$$
$$
d=E_{x,y}
$$

上述是两个经理的情况，多个经理也类似，这里就不赘述了。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
typedef long long ll;
const int N = 1010, M = 1002010;
const ll INF = 1e18;
struct E{int v; ll w, nxt;} e[M << 1]; ll ans;
int n, m, s, t, tote, a[N], c[N][N], head[N], now[N], dep[N];
void init(){
    tote = 0;
    memset(head, -1, sizeof(head));
}
void Adde(int u, int v, ll w){
    e[tote] = {v, w, head[u]}, head[u] = tote++;
}
void Add(int u, int v, ll w){
    Adde(u, v, w), Adde(v, u, 0);
}
int bfs(){
    queue<int> q; q.push(s);
    memset(dep, 0, sizeof(dep)), dep[s] = 1;
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int i = now[u] = head[u]; ~i; i = e[i].nxt)
            if(e[i].w && !dep[e[i].v])
				q.push(e[i].v), dep[e[i].v] = dep[u] + 1;
    }
    return dep[t];
}
ll dfs(int u, ll in){
    if(u == t) return in; ll out = 0;
    for(int i = now[u]; ~i && in; i = e[i].nxt){
        int v = e[i].v; ll w = e[i].w; now[u] = i;
        if(dep[v] == dep[u] + 1 && w){
            ll flow = dfs(v, min(in, (ll)w));
            in -= flow, out += flow;
            e[i].w -= flow, e[i ^ 1].w += flow;
        }
    }
    if(!out) dep[u] = 0; return out;
}
ll dinic(){
    ll ret = 0;
    while(bfs()) ret += dfs(s, INF);
    return ret;
}
int main(){
    scanf("%d", &n), s = 0, t = n + 1, init();
    FL(i, 1, n) scanf("%d", &a[i]), Add(s, i, a[i]);
    FL(i, 1, n){
        ll sum = 0;
        FL(j, 1, n){
            scanf("%d", &c[i][j]);
            if(c[i][j] > 0){
                Add(i, j, 2 * c[i][j]);
                sum += c[i][j];
            }
        }
        Add(i, t, sum), ans += sum;
    }
    printf("%lld\n", ans - dinic());
    return 0;
}
```

---

## 作者：nianheng (赞：4)

~~竟然没有这题的题解，水一发qwq~~
## 最小割模型
#### 1.题意:
　a.选择每个人有一个代价$A_i$；

　b.如果有两个人同时选择就可以获得收益$E_{i,j}$
    
　c.如果一个人选择另一个不选会产生代价$E_{i,j}$
 
#### 2.解法

　　a,b两条就是典型的最小割模型，从$S$向每个人连边流量为这人可以带来的收益$\Sigma_{j=1}^{n} E_{i,j}$，用$ans$记录总收益，再从人向$T$连边表示代价$A_i$，用$ans-minc$（这样如果割掉人到$T$的边代表选这个人并支付代价，如果割掉$S$到人的边代表舍弃收益，不支付代价）得到的就是最大的收益

　　考虑c条件，那么我们对于每对$i,j$都再新建一条从$i$到$j$的边，流量为$E_{i,j}<<1$这样如果选一个不选另一个的话这条边就会断掉（造成代价）,c条件就能满足了
 
　　最小割可以转化为最大流，我用的$dinic$极限数据$942ms$~~有点慌~~
  
　　~~还有就是千万别忘开long long~~
  
#### 3.代码

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
inline long long read(){
	long long ans=0,fh=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			fh=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		ans=(ans<<1)+(ans<<3)+ch-'0',ch=getchar();
	return ans*fh;
}
const int maxn=1e4,maxm=5e6,inf=0x7fffffff;
int n,m,a,b,c,cc[maxn],cur[maxn],head[maxn],nex[maxm],v[maxm],s,t;
int num=1;
long long ans,siz[maxn],fee,w[maxm];
queue<int>q;
int bh(int x,int y){return n+(x-1)*n+y;}
void add(int x,int y,long long z){
	v[++num]=y;
	w[num]=z;
	nex[num]=head[x];
	head[x]=num;
	v[++num]=x;
	w[num]=0;
	nex[num]=head[y];
	head[y]=num;
}
bool bfs(){
	memset(cc,0,sizeof(cc));
	cc[s]=1;
	q.push(s);
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=head[now];i;i=nex[i])
			if(w[i]&&!cc[v[i]])
				cc[v[i]]=cc[now]+1,q.push(v[i]);
	}
	return cc[t];
}
long long dfs(int x,long long ll){
	if(x==t)
		return ll;
	for(int &i=cur[x];i;i=nex[i])
		if(w[i]&&cc[v[i]]==cc[x]+1){
			int pp=dfs(v[i],ll>w[i]?w[i]:ll);
			if(pp){
				w[i]-=pp;
				w[i^1]+=pp;
				return pp;
			}
		}
	return 0;
}
void dinic(){
	long long maxl=0,ll;
	while(bfs()){
		memcpy(cur,head,sizeof(cur));
		while(ll=dfs(s,inf))
			maxl+=ll;
	}
	printf("%d\n",ans-maxl);
}
int main(){
	n=read();s=0;t=n+1;
	for(int i=1;i<=n;i++)
		a=read(),add(i,t,a);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			fee=read();
			siz[i]+=fee;
			add(i,j,fee*2);
		}
		add(s,i,siz[i]);
		ans+=siz[i];
	}
	dinic();
	return 0;
}
```

---

## 作者：Exber (赞：2)

## 做法

最小割。

首先这种有收益有损失的题的做法一般都是用总的收益减去最小损失。所以我们的**大体思路就是用总收入 $\sum\limits_{i=1}^{n}\sum\limits_{j=1}^n E_{i,j}$ 减去最小损失求出答案，最小损失用最小割求解**。

考虑求解最小损失，**先建出源点、汇点和表示经理的 $n$ 个点**。

容易发现，经理**分为两个“阵营”：被我方雇佣和被敌方雇佣**。那么考虑**用源点表示我方阵营，汇点表示地方阵营，那么所有和源点相连的点都加入了我方，所有和汇点相连的点都加入了敌方**。因为**加入我方的花费是 $A_i$，加入敌方的花费则是 $\sum\limits_{j=1}^nE_{i,j}$，所以从源点向 $i$ 连一条流量为 $\sum\limits_{j=1}^nE_{i,j}$ 的边，从 $i$ 向汇点连一条流量为 $A_j$ 的边**。

![](https://cdn.luogu.com.cn/upload/image_hosting/uhs7xpz4.png)

接下来考虑 $i,j$ 两人处在不同阵营时的花费。假设 $i$ 加入了我方，$j$ 加入了敌方，此时情况如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/a4vyvmy9.png)

那么**此时的损失需要多计算 $2E_{i,j}$，所以我们需要从 $i$ 向 $j$ 连流量为 $2E_{i,j}$ 的边**。

![](https://cdn.luogu.com.cn/upload/image_hosting/qzan8flp.png)

所以建图步骤如下：

- 建出源点、汇点和表示经理的 $n$ 个点

- 从源点向 $i$ 连一条流量为 $\sum\limits_{j=1}^nE_{i,j}$ 的边，从 $i$ 向汇点连一条流量为 $A_j$ 的边

- 从每一个 $i$ 向每一个 $j$ 连一条流量为 $2E_{i,j}$ 的边

最后答案就是 $\sum\limits_{i=1}^{n}\sum\limits_{j=1}^n E_{i,j}$ 减去最小割。


## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

const long long S=5000005,MS=2000005,MMS=1005;

int n,s,t;
long long sum[MMS];
int esum,to[S],nxt[S],h[MS];
long long c[S];
int dep[MS];

inline void init()
{
	esum=1;
	memset(h,0,sizeof(h));
	s=0;
	t=n+1;
}

inline void add(int x,int y,long long w)
{
	c[++esum]=w;
	to[esum]=y;
	nxt[esum]=h[x];
	h[x]=esum;
}

inline bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=h[u];i;i=nxt[i])
		{
			int v=to[i];
			if(c[i]>0&&dep[v]==0)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t]!=0;
}

long long dfs(int u,long long w)
{
	if(u==t)
	{
		return w;
	}
	long long sum=0;
	for(int i=h[u];i;i=nxt[i])
	{
		int v=to[i];
		if(c[i]>0&&dep[v]==dep[u]+1)
		{
			long long re=dfs(v,min(w,c[i]));
			c[i]-=re;
			c[i^1]+=re;
			sum+=re;
			w-=re;
			if(w==0)
			{
				break;
			}
		}
	}
	if(sum==0)
	{
		dep[u]=0;
	}
	return sum;
}

inline long long dinic()
{
	long long ans=0;
	while(bfs())
	{
		ans+=dfs(s,1e17);
	}
	return ans;
}

int main()
{
	scanf("%d",&n);
	init();
	for(int i=1;i<=n;i++)
	{
		long long x;
		scanf("%lld",&x);
		add(i,t,x);
		add(t,i,0);
	}
	long long ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			long long x;
			scanf("%lld",&x);
			sum[i]+=x;
			add(i,j,x*2);
			add(j,i,0);
			ans+=x;
		}
	}
	for(int i=1;i<=n;i++)
	{
		add(s,i,sum[i]);
		add(i,s,0);
	}
	printf("%lld\n",ans-dinic());
	return 0;
}
```

---

## 作者：lzh0220 (赞：1)

## 思路

感觉比较像 P4313。

先不考虑同时选两个人的情况，则源点代表自己要选哪些，汇点表示对方选哪些，则将源点向每个 $i$ 连一条价值为 $A_i$ 的边，将每个 $i$ 向汇点连一条价值为 $\sum_{j=1}^nE_{i,j}$ 的边。

考虑同时选两个人的情况，此时对于 $i$ 和 $j$，一定形如 $i$ 连 $s$ 且 $j$ 连 $t$。此时这么选的代价为 $2E_{i,j}$，则在 $i$，$j$ 之间连价值为 $2E_{i,j}$ 的边。

见图跑网络流即可。

建图部分：


```cpp
//vector 建边
int n=read(),num=0;
s=0;t=n+1;
for(int i=1;i<=n;i++){
	int val=read();
	v[s].pb(mp(i,++tot));tag[tot]=val;
	v[i].pb(mp(s,++tot));tag[tot]=0;
}
for(int i=1;i<=n;i++){
	int sum=0;
	for(int j=1;j<=n;j++){
		int x=read();sum+=x;
		if(x){
			v[i].pb(mp(j,++tot));tag[tot]=x*2;
			v[j].pb(mp(i,++tot));tag[tot]=0;
		}
	}
	v[i].pb(mp(t,++tot));tag[tot]=sum;
	v[t].pb(mp(i,++tot));tag[tot]=0;num+=sum;
}
```

---

## 作者：qiyue7 (赞：1)

解法就是很经典的二元关系网络流，其他的题解已经说的很明白了

但是似乎非优化建图很容易被卡常来着

那么这里就给出一份暴力建图的非Dinic和ISAP的HLPP代码

HLPP的优化拉满的话感觉优点还是有个十分优秀的下界，平均速度在加优化以后很不错，基本上没怎么被卡过，切题手感++

AC代码：
```cpp
using namespace std;
struct node
{
	long long anti, flow, sign;
	node(long a, long b, long long c)
	{
		anti = c, flow = b, sign = a;
	}
};
struct rel    //relabel
{
	long long of, high, sign;  //overflow
	friend bool operator<(rel a, rel b) { return a.of < b.of; }
};
struct Highest_relabel_to_front
{
	vector<rel> rel1;
	vector<vector<node>::iterator> parttt;
	vector<vector<node>> flow_map;
	list<rel> ofc[13000]; //overflow_collection
	long long node_sum, level, beginning1, ending1; //begin，end给定s，t
	vector<long long> height;
	Highest_relabel_to_front(long s = 0, long a = 0, long b = 0) :beginning1(a), ending1(b), rel1(s + 1)
	{
		flow_map.resize(s + 1);
		parttt.resize(s + 1);
		height.resize(s * 2 + 2, 0);
		node_sum = s;
	}
	void relabel(long node_sign)
	{
		long long h = 101000;
		long floor = rel1[node_sign].high;
		for (auto &p : flow_map[node_sign])
			if (p.flow > 0)
				h = min(rel1[p.sign].high, h);
		rel1[node_sign].high = h + 1;
		height[floor]--, height[h + 1]++;
		if (h > level) level = h;
	}
	void sign_part()
	{
		for (long s = 0; s < rel1.size(); ++s) rel1[s].sign = s;
		for (auto &s : height) s = 0;
		height[node_sum] = 1;
		height[0] = node_sum - 1;
	}
	void initialize_preflow(long beginning)
	{
		for (auto &s : rel1)
		{
			s.high = 0;
			s.of = 0;
		}
		rel1[beginning].high = node_sum;
		for (auto &p : flow_map[beginning])
		{
			flow_map[p.sign][p.anti].flow = p.flow;
			rel1[p.sign].of = p.flow;
			rel1[beginning].of -= p.flow;
			p.flow = 0;
			ofc[rel1[p.sign].high].push_back(rel1[p.sign]);
			if (rel1[p.sign].high > level)
				level = rel1[p.sign].high;
			height[rel1[p.sign].high]++;
		}
	}
	void add_edge(long a, long b, long long c)
	{
		if (!flow_map[a].empty())
			for (auto &s : flow_map[a])
				if (s.sign == b)
				{
					s.flow += c;
					return;
				}
		flow_map[a].push_back(node(b, c, flow_map[b].size()));
		flow_map[b].push_back(node(a, 0, flow_map[a].size() - 1));
	}
	void speed_up(long k)
	{
		for (auto &s : rel1)
			if (s.high > k &&s.high < node_sum)
				s.high = node_sum + 1;
	}
	void push(int node_sign)
	{
		while (rel1[node_sign].of > 0 && node_sign != beginning1 && node_sign != ending1)
		{
			auto s = parttt[node_sign];
			if (s == flow_map[node_sign].end())
			{
				relabel(node_sign);
				parttt[node_sign] = flow_map[node_sign].begin();
			}
			else if (s->flow > 0 && rel1[node_sign].high == rel1[s->sign].high + 1)
			{
				if (s->flow > rel1[node_sign].of)
				{
					flow_map[s->sign][s->anti].flow += rel1[node_sign].of;
					s->flow -= rel1[node_sign].of;
					rel1[s->sign].of += rel1[node_sign].of;
					rel1[node_sign].of = 0;
				}
				else
				{
					flow_map[s->sign][s->anti].flow += s->flow;
					rel1[node_sign].of -= s->flow;
					rel1[s->sign].of += s->flow;
					s->flow = 0;
				}
				if (s->sign != beginning1 && s->sign != ending1)
					ofc[rel1[s->sign].high].push_back(rel1[s->sign]);
			}
			else
				parttt[node_sign]++;
		}
	}
	long long max_flow()
	{
		sign_part();
		level = 0;
		for (int i = 0; i < node_sum + 1; ++i)
			parttt[i] = flow_map[i].begin();
		initialize_preflow(beginning1);
		while (level >= 0)
		{
			int level2 = level;
			if (!ofc[level2].empty())
			{
				int s = ofc[level].back().sign;
				ofc[level].pop_back(), push(s);
				if (height[level2] == 0) speed_up(level2);
			}
			else
				level--;
		}
		return rel1[ending1].of;
	}

};
Highest_relabel_to_front hlpp(12000, 0, 11000);
long long w[1100][1100];
long long val[1100];
const int inf = 0x6fffffff;
int32_t main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	long long ALLans = 0;
	int L = 1;
	long long n, m, u, v, a, b, c;
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> val[i];
	for(int i=1;i<=n;++i)
		for (int j = 1; j <= n; ++j)
		{
			cin >> w[i][j];
			ALLans += w[i][j];
			if (j <= i)
				continue;
			hlpp.add_edge(j, 11000, w[i][j]);
			hlpp.add_edge(i, 11000, w[i][j]);
			hlpp.add_edge(i, j, 2 * w[i][j]);
			hlpp.add_edge(j, i, 2 * w[i][j]);
		}
	for (int i = 1; i <= n; ++i)
		hlpp.add_edge(0, i, val[i]);
	cout << ALLans - hlpp.max_flow() << endl;
	return 0;
}

```


---

## 作者：Freopen (赞：1)

（我是不会告诉你们，在连边的时候判一下是不是0，是就不连边，就可以rank1。。。。。。）

这题就是一个网络流最小割在二元关系下求最大值的题。
先把矩阵中所有数加起来再减去我们构造的最小割就是最大值。
而最小割。

我们把每个人和S和T连边，割与S相连的边表示聘用，否则表示不聘用。那么一开始每个点与S相连的边的边权为b。

然后来考虑二元关系；

对于i，j，同时选的代价是0（我们一开始就加入了贡献）。

同时不选的代价是$E_{ij}+E{ji}$

一个选一个不选的代价是$E_{ij}+E{ji}+E{ij}$(需要减去一开始加的E)

通过（和其他二元关系一样的）解方程，我们可以得到i，j与S的连边流量为0，与T的连边流量为$E_{ij}$，i，j之间的连边流量为$2*E_{ij}$ 然后再把b加上去就行了。

AC Code(20190312 Rank1 72ms):
```cpp
#include<bits/stdc++.h>
#define maxn 1055
#define maxm maxn * maxn * 5
#define inf 0x3f3f3f3f
#define LL long long
using namespace std;

char cb[1<<15],*cs=cb,*ct=cb;
#define getc() (cs==ct && (ct = (cs = cb) + fread(cb , 1 , 1<<15 , stdin),cs==ct)?0:*cs++)
void read(int &res)
{
	char ch;bool f=0;
	for(;!isdigit(ch=getc());) if(ch=='-') f=1;
	for(res=ch-'0';isdigit(ch=getc());res=res*10+ch-'0');
	(f) && (res = -res);
}

int n,S,T,tot;
int b[maxn];
LL sum[maxn],cap[maxm];

int dis[maxn];
int buf[maxn],info[maxn],Prev[maxm],to[maxm],cnt_e=1;
inline void Node(int u,int v,LL c){ Prev[++cnt_e]=info[u],info[u]=cnt_e,to[cnt_e]=v,cap[cnt_e]=c; }
inline void Line(int u,int v,LL c,LL d=0){ Node(u,v,c),Node(v,u,d); }

LL aug(int now,LL Max)
{
    if(now == T) return Max;
    LL inc , st = Max;
    for(int &i=info[now];i;i=Prev[i])
        if(cap[i] && dis[to[i]]+1 == dis[now])
        {
            inc = aug(to[i],min(cap[i] , st));
            if(inc) st -= inc , cap[i] -= inc , cap[i^1] += inc;
			else dis[to[i]] = 0;
            if(!st) break;
        }
    return Max - st;
}

bool BFS()
{
    static queue<int>q;
    memset(dis,-1,sizeof dis);
    q.push(T),dis[T]=0;
    for(int now;!q.empty();)
    {
        now = q.front() , q.pop();
        for(int i=info[now];i;i=Prev[i])
            if(cap[i^1] && dis[to[i]]==-1)
            {
                dis[to[i]] = dis[now] + 1;
                q.push(to[i]);
            }
    }
    return dis[S] != -1;
}

int main()
{
	read(n);
	tot = n;
    S = ++tot , T = ++tot;
    LL ans = 0;
	for(int i=1;i<=n;i++) read(b[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			int x;
			read(x);
			if(i<j && x)
			{
				ans += x*2;
				sum[i] += x, sum[j] += x;
				Line(i,j,x*2ll,x*2ll);
			}
		}
	for(int i=1;i<=n;i++)
		Line(S,i,b[i]),Line(i,T,sum[i]);
	memcpy(buf,info,sizeof info);
    for(;BFS();)
        ans -= aug(S,inf),
		memcpy(info,buf,sizeof buf);
    printf("%lld\n",ans);
}

```


---

## 作者：ivyjiao (赞：0)

首先，一个经理只有雇佣和不雇佣两种状态，那么我们把雇佣定为源点，不雇佣定为汇点，那么我们就可以得到：

1. 从源点到 $i$ 连流量为 $\sum_{j=1}^n e_{i,j}$ 的边，因为雇佣了他就会产生这些收益。
2. 从 $i$ 到汇点连流量为 $a_i$ 的边，因为不雇佣他就会避免这些支出。

我们还可以得出，总收益 $sum$ 就是 $\sum_{i=1}^n\sum_{j=1}^n e_{i,j}$，答案就是 $sum-ans$。

这里解释一下：全部雇佣的收益就是 $\sum_{i=1}^n\sum_{j=1}^n e_{i,j}$，每雇佣一个人 $i$ 流量就加 $a_i$（网络流的性质），多花了 $a_i$，所以答案减少 $a_i$，不雇佣一个人流量就加 $\sum_{j=1}^n e_{i,j}$，少赚了 $\sum_{j=1}^n e_{i,j}$，所以答案减少 $\sum_{j=1}^n e_{i,j}$，证毕。

如果两个人都选，能多赚 $e_{i,j}$，如果有一个不选，会倒扣 $e_{i,j}$，利润差为 $e_{i,j}\times 2$。所以我们从 $i$ 向 $j$ 连一条流量为 $e_{i,j}\times 2$ 的边，这样一旦两个人中有一个人没选，这条边就会断掉，相当于少赚了 $e_{i,j}\times 2$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1003,inf=1e9;
int n,m,s,t,a[N],b[N],e[N][N],del[N],dis[N],sum,ans;
struct node{
    int v,w,l;
};
vector<node>G[N];
bool bfs(){
    for(int i=1;i<=t;i++) dis[i]=inf;
    memset(del,0,sizeof del);
    queue<int>q;
    q.push(s);
    dis[s]=0;
    while(q.size()){
        int u=q.front();
        q.pop();
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].v;
            if(G[u][i].w>0&&dis[v]==inf){
                q.push(v);
                dis[v]=dis[u]+1;
                if(v==t) return 1;
            }
        }
    }
    return 0;
}
int dfs(int u,int sum){
    if(u==t) return sum;
    int k,ans=0;
    for(int i=del[u];i<G[u].size()&&sum;i++){
		del[u]=i;
		int v=G[u][i].v;
		if(G[u][i].w>0&&dis[u]+1==dis[v]){
			k=dfs(v,min(sum,G[u][i].w));
            if(!k) dis[v]=inf;
			G[u][i].w-=k;
			G[v][G[u][i].l].w+=k;
			sum-=k;
			ans+=k;
		}
    }
    return ans;
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>e[i][j];
            b[i]+=e[i][j];
            sum+=e[i][j];
        }
    }
    s=n+1,t=n+2;
    for(int i=1;i<=n;i++){
        G[s].push_back({i,b[i],G[i].size()});
        G[i].push_back({s,0,G[s].size()-1});
        G[i].push_back({t,a[i],G[t].size()});
        G[t].push_back({i,0,G[i].size()-1});
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            G[i].push_back({j,e[i][j]*2,G[j].size()});
            G[j].push_back({i,0,G[i].size()-1});
        }
    }
    while(bfs()) ans+=dfs(s,inf);
    cout<<sum-ans;
}
```

---

## 作者：__xsy2013__ (赞：0)

可以看出这是明显的最小割模型。

这样建边：

- 源点向每个人连流量是它的总收益的边。
- 每个人向汇点连流量是它的花费的边。
- $i$ 向 $j$ 连流向为 $E_{i,j} \times 2$ 的边。

前两条是明显的最小割模型，第三条如果两个人都选可以获得 $E_{i,j}$ 的利润，只要一个不选，就会亏损 $E_{i,j}$，那么利润之差就是 $E_{i,j} \times 2$，这样连边，一旦两个人中有一个人没选，这条边就会断掉，造成利润差的出现。

代码就不放了（~~其实是我懒得写~~）

---


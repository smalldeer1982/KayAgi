# [HNOI2001] 软件开发

## 题目描述

某软件公司正在规划一项 $n$ 天的软件开发计划，根据开发计划第 $i$ 天需要 $n_i$ 个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。

消毒方式有两种，$A$ 种方式的消毒需要 $a$ 天时间，$B$ 种方式的消毒需要 $b$ 天，$A$ 种消毒方式的费用为每块毛巾 $f_A$, $B$ 种消毒方式的费用为每块毛巾 $f_B$，而买一块新毛巾的费用为 $f$（新毛巾是已消毒的，当天可以使用）。公司经理正在规划在这 $n$ 天中，每天买多少块新毛巾、每天送多少块毛巾进行 $A$ 种消毒和每天送多少块毛巾进行 $B$ 种消毒。当然，公司经理希望费用最低。

你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行 $A$ 种消毒和多少毛巾进行 $B$ 种消毒，使公司在这项 $n$ 天的软件开发中，提供毛巾服务的总费用最低。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $b>a$，$f>f_A>f_B$，$1\le f,f_A,f_B\le 60$，$1\le n\le 10^3$。

## 样例 #1

### 输入

```
4  1  2  3  2  1                         
8  2  1  6  
```

### 输出

```
38```

# 题解

## 作者：TEoS (赞：11)

本文会具体地对建模进行讲解和分析。


------------
#### 算法

最小费用最大流


------------
#### 建模

因为每天使用的毛巾是固定的，我们不需要去关心这个部分。显然，我们的任务就是处理每天晚上使用过的毛巾和给每天早上提供毛巾。而网络的流就相当于毛巾从源点产生，经过网络之后给汇点提供新毛巾。源点产生的毛巾可以是旧的或新的，接下来会详细讲解。

很容易想到拆点的思想，将每天拆成早上和晚上，分别进行处理。本文中设第$i$天的早上和晚上的节点编号分别为$i$和$i+n$。

1. 每天晚上从源点获得当天使用过的旧毛巾，不需要费用，第$i$天的数量为$n_i$，即从源点$s$向$i+n(i\in[1,n])$连一条流量为$n_i$，费用为$0$的边。
1. 每天早上向汇点提供当天需要的新毛巾，不需要费用，第$i$天的数量为$n_i$，即从$i(i\in[1,n])$向汇点$t$连一条流量为$n_i$，费用为$0$的边。
1. 每天早上可以从汇点购买毛巾，单位费用为$f$，数量不限，即从源点$s$向$i(i\in[1,n])$连一条流量为$inf$，费用为$f$的边。
1. 每天晚上可以把旧毛巾送去以$A$方式进行消毒，单位费用为$f_a$，数量不限，需要到$a$天后的早上才可以使用。注意，这里的$a$天是指全天，即若第$1$天晚上送毛巾去消毒，消毒需要$1$天，要到第$3$天早上才可以用。同时要注意边界问题，不能超出$n$天的范围。即从$i+n(i\in[1,n-a-1])$向$i+a+1$连一条流量为$inf$，费用为$f_a$的边。
1. 同理，每天晚上还可以把旧毛巾送去以$B$方式进行消毒，单位费用是$f_b$，数量不限，即从$i+n(i\in[1,n-b-1])$向$i+b+1$连一条流量为$inf$，费用为$f_b$的边。
1. 每一天晚上还可以选择不处理部分毛巾，把毛巾留到第二天晚上，不需要费用。这里有几点要说明，第一，因为旧毛巾不能使用，所以要留到第二天晚上而不是早上；第二，虽然根据贪心的思想是越早消毒越好，但实际上有可能消毒了却不需要用的情况出现，因此可以将旧毛巾留到第二天晚上。实际上也可以从每一条早上向第二天早上连边，表示将新毛巾留到第二天早上使用，也是同样的道理，都可行。这个操作也要注意边界问题。即从$i+n(i\in[1,n-1])$向$i+1+n$连一条流量为$inf$，费用为$0$的边。

以上就是全部的建模，建模之后求最小费用最大流即可。

最后给出代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define ano ((i-1)^1)+1
using namespace std;
const int INF=0x7f7f7f7f,N=2e3+100,M=6e3+100;
int n,a,b,f,fa,fb,tot,ans,s,t;
int head[N],ver[2*M],edge[2*M],Next[2*M],cost[2*M];
int pre[N],minf[N],d[N];
bool v[N];
void add(int x,int y,int z,int c)
{
	ver[++tot]=y,edge[tot]=z,cost[tot]=c,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edge[tot]=0,cost[tot]=-c,Next[tot]=head[y],head[y]=tot;
}//网络流双向建边
bool spfa()
{
	memset(v,0,sizeof(v));
	memset(d,0x7f,sizeof(d));
	queue<int> q;
	d[s]=0,v[s]=1,minf[s]=INF;
	q.push(s);
	while(q.size())
	{
		int x=q.front();q.pop();v[x]=0;
		for(int i=head[x];i;i=Next[i])
			if(edge[i])
			{
				int y=ver[i];
				if(d[x]+cost[i]<d[y])
				{
					d[y]=d[x]+cost[i];
					minf[y]=min(minf[x],edge[i]);
					pre[y]=i;
					if(!v[y])
					{
						q.push(y);
						v[y]=1;
					}
				}
			}
	}
	return d[t]!=INF;
}
void update()
{
	int x=t;
	while(x!=s)
	{
		int i=pre[x];
		edge[i]-=minf[t];
		edge[ano]+=minf[t];
		x=ver[ano];
	}
	ans+=d[t]*minf[t];
}//最小费用最大流模板
int main()
{
	scanf("%d%d%d%d%d%d",&n,&a,&b,&f,&fa,&fb);
	t=2*n+1,a++,b++;//也可以先将a,b分别加1，后面就不用加1
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		add(s,i+n,x,0),add(i,t,x,0),add(s,i,INF,f);//1,2,3操作
		if(i+a<=n)
			add(i+n,i+a,INF,fa);//4操作
		if(i+b<=n)
			add(i+n,i+b,INF,fb);//5操作
		if(i+1<=n)
			add(i,i+1,INF,0);//6操作，这里是从每天早上向第二天早上连边
	}
	while(spfa())
		update();//跑最小费用最大流。
	printf("%d",ans);
	return 0;
}
```


---

## 作者：zj余能 (赞：6)

##最小费用最大流

这是一道很好的模板题；

主要难在建图：

1. 拆点，将每个点拆成入点和出点，表示为i和i+n；

2. 考虑最后每天都有且只有ni个餐巾，所以建立源点S和汇点T，并在S和i之间连容量为INF、费用为0的边，

同理在i+n和T之间连容量为INF、费用为0的边。

3. 考虑几个方案：对于a和b，只要在i天和i+a天之间连一条容量为INF、费用为fa的边，b同理；

4. 考虑一天的餐巾可以原封不动的留到明天，故可以在i和i+1之间连一条容量为INF，费用为0的边；

5. 最后为了保证每天能有足够的餐巾（每条汇弧饱和），可以在S在每个i+n之间加一条容量为INF、费用为f的边；


最后简单地跑一遍费用流即可；

附上简单的SPFA代码（57行）：


```cpp
%:pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int MAXN=1010,INF=2147483647;
struct XY{int to,pre,cap,cost,from;}e[1000010];

int n,S,T,sz=1,na,a,b,f,fa,fb,cc=0;
int las[MAXN*2],dis[MAXN*2],from[MAXN*2];
bool bb[MAXN*2];//检查该点是否在队列里 

void add(int a,int b,int c,int z){
    ++sz;e[sz].cap=c;e[sz].cost=z;e[sz].from=a;
    e[sz].to=b;e[sz].pre=las[a];las[a]=sz;
    ++sz;e[sz].cap=0;e[sz].cost=-z;e[sz].from=b;//建双向边 
    e[sz].to=a;e[sz].pre=las[b];las[b]=sz;
}

bool SPFA(int s,int t,int &cc){
    queue<int> Q;
    memset(dis,0x3f,sizeof(dis));memset(bb,0,sizeof(bb));
    Q.push(s);dis[s]=0;
    while (!Q.empty()){
        int u=Q.front();Q.pop();
        bb[u]=false;
        for (int i=las[u];i;i=e[i].pre)
        if (e[i].cap&&dis[e[i].to]>dis[u]+e[i].cost){ //松弛操作 
            dis[e[i].to]=dis[u]+e[i].cost;
            from[e[i].to]=i;
            if (!bb[e[i].to]) bb[e[i].to]=1,Q.push(e[i].to);
        }
    }
    if (dis[t]>=1e9) return 0;//无增广路了 
    int x=INF;
    for (int i=from[t];i;i=from[e[i].from]) x=min(x,e[i].cap);
    for (int i=from[t];i;i=from[e[i].from])
        e[i].cap-=x,e[i^1].cap+=x,cc+=x*e[i].cost;
    return 1;
}
int MinCost(int s,int t){while (SPFA(s,t,cc));return cc;}

int main(){
    scanf("%d%d%d%d%d%d",&n,&a,&b,&f,&fa,&fb);
    S=2*n+1;T=S+1;
    for (int i=1;i<=n;++i){
        scanf("%d",&na);
        add(S,i,na,0);add(i+n,T,na,0);
        if (i+a+1<=n) add(i,i+a+1+n,INF,fa);
        if (i+b+1<=n) add(i,i+b+1+n,INF,fb);
        if (i<n) add(i,i+1,INF,0);
        add(S,i+n,INF,f);
    }
    printf("%d",MinCost(S,T));
    return 0;
}
```

---

## 作者：Broken_Heart (赞：3)

[P2223 [HNOI2001] 软件开发](https://www.luogu.com.cn/problem/P2223)

和[餐巾计划问题](https://www.luogu.com.cn/problem/P1251)简直一模一样啊。

### 分析
最大流的题都有一个较显然的特点，就是数据范围很小，而且这题各种地方都在反复提示是最小费用最大流了，于是接下来我将一步一步地讲讲此题的建模方法，在这之前先说一下题目中有一种情况未交代，那就是当天用完的脏毛巾不一定需要当天处理，即可以留到后面再处理。
### 建模
我们先不考虑消毒，建出来一个基础模型，$s$ 为超级源点，$t$ 为超级汇点，将毛巾视为水流，$s$ 连向 $day_i$ 的管道的代价即为买新毛巾的花费 $f$，$day_i$ 连向 $t$ 的管道的代价为 $0$，显然我们这样建图的话所有管道都一定会被流满，即一定不会出现毛巾供应不足的情况，图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/6wmpbwxh.png)

接下来我们在处理消毒的事情，很容易想到对第 $i$ 天用完的毛巾，我们有 $3$ 种处理方法：

1.将毛巾进行 $A$ 方式处理，即从 $day_i$ 向 $day_{i+a+1}$ 连一条边，流量为 $inf$，花费为 $f_A$，注意这里是向 $day_{i+a+1}$ 连边，因为消毒需 $a$ 天，那么要第 $a+1$ 天才能继续使用，下同。

2.将毛巾进行 $B$ 方式处理，即从 $day_i$ 向 $day_{i+b+1}$ 连一条边，流量为 $inf$，花费为 $f_B$。

3.将脏毛巾留到后面处理，即从 $day_i$ 向 $day_{i+1}$ 连一条边，流量为 $inf$，花费为 $0$，因为这样做不花钱。

现在我们就遇到了第 $1$ 个问题，就是我们的流量不够用了，因为我们的流量需要流向 $t$，还要流向其他点，那么如何解决这个问题呢？

不难发现我们每天的需求其实是一定会被满足的，在此前提下，我们只需控制流向 $t$ 的管道的流量不变，那么我们对 $day_i$ 无论怎么加流都不会影响答案，并且我们发现每天接收毛巾和处理脏毛巾其实是相对独立的，所以很容易想到拆点：

将第 $i$ 天拆为早上 $day_{i,1}$ 和晚上 $day_{i,2}$，其中 $day_{i,1}$ 用于接收毛巾，$day_{i,2}$ 用于处理脏毛巾，我们直接从 $s$ 向 $day_{i,2}$ 连一条流量为 $n_i$，费用为 $0$ 的边，指第 $i$ 天用完的脏毛巾，按上述方式（指上文的 $3$ 种处理方法）向 $day_{i+a+1,1}$，$day_{i+b+1,1}$ 连边，注意这里是连向早上，再向 $day_{i+1,2}$ 连边，注意这里是连向晚上，图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/m5930qua.png)

接下来就把任务交给最小费用最大流就可以了。
### Code
```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
using namespace std;
const int N=100005;
const ll inf=0x3f3f3f3f3f3f3f3f;
int n,s,t,c0,d1,c1,d2,c2;
int cnt,tot=1;
int h[N<<2],ls[N<<2],r[N<<2];
bool vis[N<<2];
ll min_cost,bigflow[N<<2],dis[N<<2];// 记得开 long long
int f[N<<2],to[N<<2],cost[N<<2],nx[N<<2];
ll flow[N<<2],val[N<<2];
int num[N<<2][2];
il int ask(int &u){
	if(!u) u=++cnt;
	return u;
}
il ll mn(ll x,ll y){
	return x<y?x:y;
}
void build(int u,int v,ll w,int c){
	nx[++tot]=h[u];
	h[u]=tot;
	f[tot]=u;
	to[tot]=v;
	val[tot]=w;
	cost[tot]=c;
}
il bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(s);
	vis[s]=true;
	dis[s]=0;
	bigflow[s]=inf;
	int u;
	while(!q.empty()){
		u=q.front();
		q.pop();
		vis[u]=false;
		for(int i=h[u],v;i;i=nx[i]){
			if(val[i]^flow[i]){
				v=to[i];
				if(dis[v]>dis[u]+cost[i]){
					dis[v]=dis[u]+cost[i];
					bigflow[v]=mn(bigflow[u],val[i]-flow[i]);
					ls[v]=i;
					if(!vis[v]){
						vis[v]=true;
						q.push(v);
					}
				}
			}
		}
	}
	return dis[t]!=inf;
}
il void update(){
	int op=t,pre;
	while(op!=s){
		pre=ls[op];
		flow[pre]+=bigflow[t];
		flow[pre^1]-=bigflow[t];
		op=f[pre];
	}
	min_cost+=bigflow[t]*dis[t];
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>n>>d1>>d2>>c0>>c1>>c2;
	d1++;// 加 1 是为了方便处理
	d2++;
	for(int i=1;i<=n;i++){
		cin>>r[i];
	}
	s=++cnt;
	t=++cnt;
	for(int i=1,u,v;i<=n;i++){
		u=ask(num[i][0]);// u-晚上 
		v=ask(num[i][1]);// v-早上 
		build(s,u,r[i],0);// s 向晚上连边
		build(u,s,0,0);
		build(s,v,r[i],c0);// s 向早上连边
		build(v,s,0,-c0);
		build(v,t,r[i],0);
		build(t,v,0,0);
		if(i+1<=n){// 延迟处理
			v=ask(num[i+1][0]); 
			build(u,v,inf,0);
			build(v,u,0,0);
		}
		if(i+d1<=n){// A 方式
			v=ask(num[i+d1][1]);
			build(u,v,inf,c1);
			build(v,u,0,-c1); 
		}
		if(i+d2<=n){// B 方式
			v=ask(num[i+d2][1]);
			build(u,v,inf,c2);
			build(v,u,0,-c2); 
		}
	}
	while(spfa()){
		update();
	}
	cout<<min_cost;
	return 0;
}

```


---

## 作者：破忆 (赞：2)

## 【题意】

第 $i$ 天需要 $n_i$ 条毛巾。

可以花费 $f$ 购买一条毛巾。

也可以消耗 $a$ 天时间花费 $f_a$ 洗一条毛巾。

或者消耗 $b$ 天时间花费 $f_b$ 洗一条毛巾。

问满足每一天的需求最少费用是多少。

## 【分析】

题面看起来很费用流。

考虑如何建边。

首先把每一天拆成入点和出点，分别表示使用毛巾前和使用毛巾后。

### 对毛巾的需求

源点向入点连流量 $n_i$ 费用 $0$ 的边。

出点向汇点连流量 $n_i$ 费用 $0$ 的边。

框定毛巾使用的上限。

### 购买毛巾

源点向出点连流量无穷费用 $f$ 的边。

确保每天供应的毛巾都能满足需求。

### 毛巾的传递

入点向下一个入点连流量无穷费用 $0$ 的边。

把用不完的毛巾留着。

### 洗毛巾

入点向 $a(b)$ 天后的出点连流量无穷费用 $f_{a(b)}$ 的边。

保证两种洗毛巾方案能够正常落实。

接下里跑最小费用最大流板子即可。

注意：洗毛巾需要 $a$ 天时间，指的是第 $i$ 天用的毛巾在第 $i+a+1$ 天才能再次使用。

## 【算法】

费用流

## 【代码】

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+5,maxt=maxn*2,maxe=maxn*12,INF=1<<30;
int n,A,B,F,FA,FB;
int a[maxn];
struct edge{
	int to,nxt,f,d;
}e[maxe];
int tot=1,lnk[maxt];
void add_e(int x,int y,int f,int d){
	e[++tot]=(edge){y,lnk[x],f,d};
	lnk[x]=tot;
}
void ADD(int x,int y,int f,int d){
	add_e(x,y,f,d),add_e(y,x,0,-d);
}
int S,T;
int dis[maxt],que[maxt];
bool vis[maxt];
int flow[maxt],lst[maxt],pre[maxt];
bool SPFA(){
	for(int i=1;i<=T;i++) dis[i]=INF;
	int hed=0,til=1;
	que[1]=S;
	vis[S]=1;
	dis[S]=0;
	flow[S]=INF;
	while(hed!=til){
		int x=que[(++hed)%=maxt];
		vis[x]=0;
		for(int j=lnk[x];j;j=e[j].nxt){
			int y=e[j].to;
			if(e[j].f&&dis[y]>dis[x]+e[j].d){
				dis[y]=dis[x]+e[j].d;
				flow[y]=min(flow[x],e[j].f);
				pre[y]=j;
				lst[y]=x;
				if(!vis[y]){
					vis[y]=1;
					que[(++til)%=maxt]=y;
				}
			}
		}
	}
	return dis[T]!=INF;
}
int MCMF(){
	int ret=0;
	while(SPFA()){
		ret+=flow[T]*dis[T];
		int now=T;
		while(now!=S){
			e[pre[now]].f-=flow[T];
			e[pre[now]^1].f+=flow[T];
			now=lst[now];
		}
	}
	return ret;
}
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	freopen("P2223.in","r",stdin);
	freopen("P2223.out","w",stdout);
	n=read(),A=read()+1,B=read()+1,F=read(),FA=read(),FB=read();
	for(int i=1;i<=n;i++) a[i]=read();
	S=2*n+1,T=S+1;
	for(int i=1;i<=n;i++){//建边
		ADD(S,i,a[i],0);
		ADD(S,i+n,INF,F);
		ADD(i+n,T,a[i],0);
		if(i+1<=n) ADD(i,i+1,INF,0);
		if(i+A<=n) ADD(i,i+A+n,INF,FA);
		if(i+B<=n) ADD(i,i+B+n,INF,FB);
	}
	printf("%d\n",MCMF());//费用流
	return 0;
}
```


---

## 作者：EternalHeart1314 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2223)

四倍经验：P4480 P1251 P2223 P2917

P4480 需要玄学优化（甚至不算优化），见 [link](https://www.luogu.com.cn/discuss/1124698)。

以下题面以 P4480 为准，可以先写那题然后水个三紫一黑。

# Solution

我们把流想象成餐巾，在 $n$ 天里流动，$S$ 就是餐巾店**和顾客**，售出餐巾**和提供脏餐巾**，$T$ 就是顾客，使用干净餐巾。套路地将每天拆成两个点，可以理解为这一天的早上和晚上。

早上和晚上的连边：

+ 脏餐巾堆积：这是因为后面可能不需要这么多，不处理了。第 $i$ 天晚上向第 $i+1$ 天早上连 $(\infty,0)$。

- 清洗脏餐巾：表示从这天晚上开始清洗。第 $i$ 天晚上向第 $i+m_0$ 天早上连 $(\infty,c_0)$，$m_1,c_1$ 同理。

$S$ 和 $T$ 的连边：$S$ 向每天早上连 $(\infty,p)$，表示购买的餐巾，向每天晚上连 $(r_i,0)$，表示顾客的脏餐巾，每天晚上向 $T$ 连 $(r_i,0)$，表示每天使用的餐巾。这里 $S$ 连晚上不太好想，而且为什么没有早上连到晚上的边，万一有剩余的干净餐巾不就浪费了？这是因为如果用的是贪心，在**最优决策**下，如果这块餐巾**注定**会被洗，那么它会被**早早**地被洗干净等着使用，但是网络流会在要用的那天**恰好**把它洗干净（即前 $m_0$ 或 $m_1$ 天开始洗），这样就不存在剩余的干净餐巾，只会有堆积的脏餐巾。

# Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 3e4 + 7, INF = 1e18;
int n, s, t, tot, ans, hd[N], nxt[N], nw[N], dis[N], vis[N];
struct Edge { int u, v, w, c; } e[N];

inline void add(int u, int v, int w, int c) {
    nxt[tot] = hd[u], e[hd[u] = tot++] = {u, v, w, c};
    nxt[tot] = hd[v], e[hd[v] = tot++] = {v, u, 0, -c};
}
inline bool SPFA() {
    for (int i = s; i <= t; ++i) dis[i] = INF, nw[i] = hd[i];
    queue<int> q; q.push(s), dis[s] = 0;
    while (q.size()) {
        int u = q.front(); q.pop(), vis[u] = 0;
        for (int i = hd[u]; ~i; i = nxt[i]) {
            if (dis[e[i].v] > dis[u] + e[i].c && e[i].w) {
                dis[e[i].v] = dis[u] + e[i].c;
                if (!vis[e[i].v]) q.push(e[i].v), vis[e[i].v] = 1;
            }
        }
    }
    return dis[t] < INF;
}
inline int Dinic(int u, int florr) {
    if (u == t) return florr;
    int cur = florr, k; vis[u] = 1;
    for (int i = nw[u], v; ~i && cur; i = nxt[i]) {
        nw[u] = i, v = e[i].v;
        if (dis[v] == dis[u] + e[i].c && e[i].w && !vis[v]) {
            k = Dinic(v, min(cur, e[i].w));
            cur -= k, e[i].w -= k, e[i ^ 1].w += k, ans += k * e[i].c;
        }
    } vis[u] = 0;
    return florr - cur;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    memset(hd, -1, sizeof hd);
    int a, b, c, d, e;
    cin >> n >> b >> d >> a >> c >> e, s = 1, t = 2 * n + 2;
    for (int i = 1, x; i <= n; ++i) {
        cin >> x;
        add(s, i * 2 + 1, x, 0), add(i * 2, t, x, 0);
        add(s, i * 2, INF, a);
        if (i + 1 <= n) add(i * 2 + 1, (i + 1) * 2 + 1, INF, 0);
        if (i + b + 1 <= n) add(i * 2 + 1, (i + b + 1) * 2, INF, c);
        if (i + d + 1 <= n) add(i * 2 + 1, (i + d + 1) * 2, INF, e);
    }
    while (SPFA()) Dinic(s, INF);
    return cout << ans, 0;
}
```

---

## 作者：海洋守卫者 (赞：1)

# [P2223](https://www.luogu.com.cn/problem/P2223) [HNOI2001] 软件开发

[**双倍经验**](https://www.luogu.com.cn/problem/P1251)

## 解题思路
由于消毒毛巾在天数之间是流动的，因此可以想到最小费用最大流。考虑建图，将新的毛巾与旧毛巾分开来算，即将白天与晚上分开。

### 一、处理新的消毒毛巾和旧的消毒毛巾

+ **购买新消毒毛巾**：从超级源点 $S$ 直接向每天白天连边，流量为 $+\infty$，费用为 $f$。
+ **$A$ 种消毒方式**：从第 $i$ 天向第 $i+a+1$ 天连边，流量为 $+\infty$，费用为 $f_A$。
+ **$B$ 种消毒方式**：同理，从第 $i$ 天向第 $i+b+1$ 天连边，流量为 $+\infty$，费用为 $f_B$。
+ **每天产生的旧消毒毛巾**：因为每天使用的消毒毛巾数量是固定的，所以每天产生的旧消毒毛巾数量也是固定的，我们可以从超级源点 $S$ 直接向每天晚上连边，流量为 $n_i$，费用为 $0$。

### 二、处理每天使用新消毒毛巾的数量

要使每天使用的消毒毛巾的数量固定，可以将每天白天使用的新消毒毛巾流向超级汇点 $T$，最终的最大流量就为所有天中使用的消毒毛巾个数之和，保证了数量的稳定。

## 完整代码
```cpp
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<queue>
using namespace std;
const int MAXN=5e4+5,oo=0x3f3f3f3f;
int n,a,b,p,f,s,k,S,T,h[MAXN],ec=1;
long long ans,sum;
struct Edge{
	int u,v,w,c,nxt;
}e[MAXN<<2];
inline void AddEdge(int u,int v,int w,int c)
{
	e[++ec]={u,v,w,c,h[u]};
	h[u]=ec;
}
inline void Add(int u,int v,int w,int c)
{
	AddEdge(u,v,w,c);
	AddEdge(v,u,0,-c);
}
int vis[MAXN],dis[MAXN];
queue<int>que;
bool SPFA(int s,int t){
	while(!que.empty())que.pop();
	memset(vis,0,sizeof vis);
	memset(dis,0x3f,sizeof dis);
	vis[t]=1,que.push(t),dis[t]=0;
	while(!que.empty()){
		int u=que.front();que.pop();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nxt){
			if(e[i^1].w&&dis[u]+e[i^1].c<dis[e[i].v]){
				dis[e[i].v]=dis[u]+e[i^1].c;
				if(vis[e[i].v])continue;
				que.push(e[i].v);
				vis[e[i].v]=1;
			}
		}
	}
	return dis[s]!=oo;
} 
int DFS(int u, int t, int f){ 
	if(u==t||!f)return f;
	vis[u]=1;
	int rest=f;
	for(int i=h[u];i;i=e[i].nxt){
		if(dis[e[i].v]!=dis[u]-e[i].c||!e[i].w||vis[e[i].v])continue;
		int tmp=DFS(e[i].v,t,min(e[i].w,rest));
		if(!tmp){
			dis[e[i].v]=oo;
			continue;
		}
		e[i].w-=tmp;
		e[i^1].w+=tmp;
		rest-=tmp;
		if(!rest)return f;
	}
	vis[u]=0;
	return f-rest;
}
void ZKW(int s,int t){ 
	ans=sum=0;
	while(SPFA(s,t)){
		memset(vis,0,sizeof vis);
		int tmp=DFS(s,t,oo);
		ans+=tmp;sum+=1ll*tmp*dis[s];
	}
}

main()
{
	scanf("%d %d %d %d %d %d",&n,&a,&b,&p,&f,&s);
	S=1,T=2*n+2;
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%lld",&x);
		Add(S,i<<1|1,x,0);
		Add(i<<1,T,x,0);
	}
	for(int i=1;i<=n;i++)
	{
		if(i+1<=n)Add(i<<1|1,i+1<<1|1,oo,0);
		if(i+a+1<=n)Add(i<<1|1,i+a+1<<1,oo,f);
		if(i+b+1<=n)Add(i<<1|1,i+b+1<<1,oo,s);
		Add(S,i<<1,oo,p);
	}
	ZKW(S,T);
	printf("%lld",sum);
	return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：1)

# 多倍经验

- [P1251 餐巾计划问题](https://www.luogu.com.cn/problem/P1251)
- [P2223 [HNOI2001] 软件开发](https://www.luogu.com.cn/problem/P2223)
- [P2917 [USACO08NOV] Toys G](https://www.luogu.com.cn/problem/P2917)
- [P4480 [BJWC2018] 餐巾计划问题](https://www.luogu.com.cn/problem/P4480)

# 题目思路

约定 $p$ 为干净毛巾价格，$m_1,m_2$ 为快消毒慢消毒所需要的天数，$c_1,c_2$ 为快消毒慢消毒一个的代价，$m_1\leq m_2,c_1\geq c_2$，不满足的话自己 swap 一下即可。

一个显然的性质是我们可以把要用的毛巾一次性买好。考虑如果我们知道了具体要买多少毛巾。设要买 $x$ 条，$f(x)$ 表示买了 $x$ 条毛巾最后的总花费。如果不够用为 $+\infty$。手玩几个找找规律~~或者是靠小学数学题告诉你的经验~~可以发现这是个单谷函数，有一个极点。显然我们要找出这个极点并且求出对应的函数值。

单谷函数，显然是需要三分的。那么这个 $f(x)$ 到底应该怎么算呢？

先思考，每天可以用的毛巾从哪里来？

1. 买来的新的没用完。

2. 快消毒消毒完的。

3. 慢消毒消毒完的。

之后会发现优先使用新的毛巾会更优，这个是先用的。

然后在可以的情况下优先使用较晚慢消毒好的。慢消毒全用完之后用较晚快消毒好的。

优先使用较晚得到的毛巾，可以尝试让更早的毛巾去慢消毒，最小化代价。

优先用慢消毒可以尽量减少消费，和上面一个道理，可能能让快消毒毛巾去慢消毒。

这时很显然这就是贪心的过程，~~因为这题是洛谷秋令营提高组贪心课后作业。~~

注意到我们需要从头放，从尾巴取，所以我们实现的时候可以使用双端队列模拟这一贪心过程，即使用 C++ 的 STL 容器 deque。

# 丑陋代码

[Luogu record 128375471](https://www.luogu.com.cn/record/128375471)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define upd1(a, b, c)                            \
    while (!a.empty() && a.front().day <= i - c) \
    {                                            \
        b.push_back(a.front());                  \
        a.pop_front();                           \
    }
#define upd2(a, b)                   \
    while (cnt > 0 && !a.empty())    \
    {                                \
        mn = min(cnt, a.back().cnt); \
        ret += mn * b;               \
        cnt -= mn;                   \
        if (!(a.back().cnt -= mn))   \
            a.pop_back();            \
    }
struct info
{
    int day, cnt;
};
int n, m1, m2, c1, c2, p;
deque<info> buy;
deque<info> fst;
deque<info> slw;
int a[200020];
int f(int k)
{
    buy.clear();
    fst.clear();
    slw.clear();
    int ret = k * p;
    for (int i = 1; i <= n; i++)
    {
        upd1(buy, fst, m1);
        upd1(fst, slw, m2);
        int cnt = a[i];
        int mn = min(cnt, k);
        cnt -= mn;
        k -= mn;
        upd2(slw, c2);
        upd2(fst, c1);
        if (cnt > 0)
            return INT_MAX;
        buy.push_back({i, a[i]});
    }
    return ret;
}
int main()
{
    cin >> n >> m1 >> m2 >> c1 >> c2 >> p;
    if (m1 > m2)
        swap(m1, m2), swap(c1, c2);
    if (c1 < c2)
        m2 = m1, c2 = c1;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    int l = 0, r = accumulate(a + 1, a + n + 1, 0);
    while (l <= r)
    {
        int ml = l + (r - l) / 3;
        int mr = r - (r - l) / 3;
        int vl = f(ml), vr = f(mr);
        if (vl >= vr)
            l = ml + 1;
        else
            r = mr - 1;
    }
    cout << min(f(l), f(r)) << endl;
    return 0;
}
```



---

## 作者：OldDriverTree (赞：1)

# Solution

先把一天拆成两个点：用完的旧毛巾数量和需要的新毛巾，记为 $x$ 和 $x'$。

由于一天需要的新毛巾来源可以分为 A/B 方式消毒或新当天购买。

对于第 $x$ 天就连接：

+ $S\rightarrow x'$，容量为 $+\infty$，费用为 $f$。
+ $x\rightarrow (x+a+1)'$，容量为 $+\infty$，费用为 $f_A$。
+ $x\rightarrow (x+b+1)'$，容量为 $+\infty$，费用为 $f_B$。
+ 第 $x$ 天可以提供 $n_i$ 块旧毛巾，连接 $S\rightarrow x$，容量为 $r_i$，费用为 $0$。
+ 第 $x$ 天的旧毛巾可以留到第 $x+1$ 天，连接 $x\rightarrow x+1$，容量为 $+\infty$，费用为 $0$。
+ 还要保证第 $x$ 天恰好收到 $n_i$ 块毛巾，连接 $x'\rightarrow T$，容量为 $+\infty$，费用为 $0$。

再跑最小费用最大流即可。

# Code

```c++
#include<bits/stdc++.h>
#define v to[i]
#define f val[i]
#define w Val[i]
using namespace std;
const int N=2002,M=12e3,inf=INT_MAX;
int tot,head[N],nxt[M],to[M],val[M],Val[M];
int n,p,x,xp,y,yp,S,T,pre[N],dis[N],Dis[N];
bool st[N];

int read() {
    int x=0; char ch=0; while (!isdigit(ch) ) ch=getchar();
    while (isdigit(ch) ) x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
    return x;
}
void add(int x,int y,int z,int Z) {
    to[tot]=y,val[tot]=z,Val[tot]=Z,nxt[tot]=head[x],head[x]=tot++;
    to[tot]=x,val[tot]=0,Val[tot]=-Z,nxt[tot]=head[y],head[y]=tot++;
}
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(Dis,0x3f,sizeof Dis);
    queue<int> q; q.push(S);
    dis[S]=inf,Dis[S]=0;

    while (!q.empty() )
    {
        int u=q.front(); q.pop(),st[u]=0;
        for (int i=head[u];~i;i=nxt[i])
            if (f&&Dis[u]+w<Dis[v]) {
                dis[v]=min(dis[u],f),Dis[v]=Dis[u]+w;
                pre[v]=i; if (!st[v]) q.push(v),st[v]=1;
            }
    }
    return dis[T];
}
int EK()
{
    int ans=0;
    while (spfa() )
    {
        ans+=dis[T]*Dis[T];
        for (int u=T;u^S;u=to[pre[u]^1])
        val[pre[u] ]-=dis[T],val[pre[u]^1]+=dis[T];
    }
    return ans;
}
int main()
{
    n=read(),T=2*n+1,x=read(),y=read();
    p=read(),xp=read(),yp=read();
    memset(head,-1,sizeof head);
    for (int i=1,r;i<=n;i++)
    {
        r=read();
        add(S,i,r,0);
        add(i+n,T,r,0);
        add(S,i+n,inf,p);
        if (i<n) add(i,i+1,inf,0);
        if (i+x<n) add(i,n+i+x+1,inf,xp);
        if (i+y<n) add(i,n+i+y+1,inf,yp);
    }
    printf("%d",EK() );
    return 0;
}
```

---

## 作者：PeppaPig_qwq (赞：0)

对每一天，建立两个点 $d_i, e_i$。分别表示早上和晚上。建立 $s$ 为超级源点，$t$ 为超级汇点。
- 每一天需要 $n_i$ 个毛巾。也会产生 $n_i$ 个脏毛巾。所以 $s$ 往 $e_i$ 连容量为 $n_i$，价值为 0 的边。 $d_i$ 往 $t$ 连容量为 $n_i$，价值为 0 的边。
- 每一天的脏毛巾可以留给下一天，所以 $e_i$ 往 $e_{i+1}$ 连容量为 $+\infty$ 的边。
- 每一天可以购买毛巾，所以 $s$ 往 $d_i$ 连容量为 $+\infty$ 价值为 $f$ 的边。
- 每一天可以用第一种方式清洗毛巾，所以 $e_i$ 往 $d_{i+a}$ 连容量为 $+\infty$ 价值为 $f_A$ 的边。
- 每一天可以用第二种方式清洗毛巾，所以 $e_i$ 往 $d_{i+b}$ 连容量为 $+\infty$ 价值为 $f_B$ 的边。

最后跑最小费用最大流即可。

---

## 作者：MSavannah (赞：0)

**Solution**

比较明显的费用流。

1. 把每天拆成入点 $i$ 和出点 $i+n$。
2. 从源点向入点连容量为 $w_i$ 费用为 $0$ 的边，再从每个出点向汇点连容量为 $w_i$ 费用为 $0$ 的边。用来限制每天消毒毛巾的需求量。
3. 从源点向出点连容量为 $w_i$ 费用为 $f$ 的边，表示购买毛巾。
4. 对于每个点的入点向 $a$ 天后的出点连一条容量为 $\inf$ 费用为 $fa$ 的边。表示送去 $A$ 清洗。$B$ 同理，对于每个点的入点向 $b$ 天后的出点连一条容量为 $\inf$ 费用为 $fb$ 的边。
5. 最后从第 $i$ 个入点向第 $i+1$ 的点连一条容量为 $\inf$ 费用为 $0$ 的边，表示不送去清洗也不用。

[code](https://www.luogu.com.cn/record/159423326)

---

## 作者：Wilderness_ (赞：0)

看题目名字以为是一道模拟题，打开看到毛巾就想到了网络流与线性规划 24 题中的 [餐巾计划问题](https://www.luogu.com.cn/problem/P1251)。
## 建图
首先，我们可以从 ~~P1251 的标签~~ 题面中 `公司经理希望费用最低` 等与 `费用` 一词相关的语句判断出这是一道最小费用最大流。

根据题面，我们的毛巾应该能被消毒或者重新购买，大概就是如下操作：

1. 耗费 $f_A$ 用 $A$ 种方式消毒毛巾，$a$ 天后取回；
2. 耗费 $f_B$ 用 $B$ 种方式消毒毛巾，$b$ 天后取回；
3. 耗费 $f$ 买新的消过毒的毛巾，马上送到 ~~（曹操快递，随叫随到）~~。

当然，一块脏毛巾并不是马上就需要消毒的，它可以延迟几天后再消毒，但员工必须用干净的毛巾。

我们可以想到，员工上班才会需要毛巾，下班后只会留下脏的毛巾。那么我们就可以把公司经理不要求加班的一天拆成三段：上班前，上班时和下班后。当然，我们只考虑上班前和下班后的时刻：上班前只有干净的毛巾，下班后只有脏的毛巾，分别处理相应时间段做的工作：

1. 耗费 $f_A$ 用 $A$ 种方式消毒毛巾属于下班后的操作，连向 $i+a$ 天的上班前（$i$ 表示第 $i$ 天）；
2. 耗费 $f_B$ 用 $B$ 种方式消毒毛巾属于下班后的操作，连向 $i+b$ 天的上班前；
3. 耗费 $0$ 延期消毒毛巾属于下班后的操作，连向 $i+1$ 的下班后；
4. 耗费 $f$ 买新的消过毒的毛巾属于上班前的操作，我们设置一个商店点 $s$，买毛巾都从 $s$ 连向 $i$ 的上班前。

以上操作流量均为 $inf$。然后呢？

我们不难发现，除了延期消毒以外，我们的每一次操作都连向了上班前，然后网络流又是在一个从源点流向汇点的图上跑的，为了使图连通，我们将商店 $s$ 当作源点，每天的下班时段连向源点，而每天上班前都连向一个汇点 $t$。

建完图后，跑一遍最小费用最大流即可。

## Code
```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
using namespace std;
ll n,m,tfast,mfast,tslow,mslow,s,t,maxflow,mincost,dis[5544],tot=1,now[5544],hd[5544],pre[5544],flow[5544],pp[5544]; 
bool vis[5544];
struct node
{
	ll to,nxt,val,cost;
}edge[114514];
void addedge(ll u,ll v,ll w,ll c)
{
	edge[++tot].to=v;
	edge[tot].val=w;
	edge[tot].cost=c;
	edge[tot].nxt=hd[u];
	hd[u]=tot;
	edge[++tot].to=u;
	edge[tot].val=0;
	edge[tot].cost=-c;
	edge[tot].nxt=hd[v];
	hd[v]=tot;
}
bool SPFA()
{
	for(int i=0;i<5141;i++)dis[i]=INF;
	for(int i=0;i<5141;i++)vis[i]=0;
	queue<ll>q;
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	flow[s]=INF;
	while(q.size())
	{
		ll top=q.front();
		q.pop();
		vis[top]=0;
		for(ll i=hd[top];i;i=edge[i].nxt)
		{
			ll v=edge[i].to;
			if(edge[i].val&&dis[v]>dis[top]+edge[i].cost)
			{
				dis[v]=dis[top]+edge[i].cost;
				flow[v]=min(flow[top],edge[i].val);
				pre[v]=i;
				if(!vis[v])
                {
                    vis[v]=1;
                    q.push(v);
                }
			}
		}
	}
	return dis[t]!=INF;
}
int main()
{
	scanf("%lld",&n);scanf("%lld%lld%lld%lld%lld",&tfast,&tslow,&m,&mfast,&mslow);
	s=0,t=2*n+1;
	for(ll i=1;i<=n;++i)
	{
		scanf("%lld",&pp[i]);
		addedge(s,i,pp[i],0); 
		addedge(i+n,t,pp[i],0);
	}
	for(ll i=1;i<=n;++i)
	{
		if(i+1<=n)addedge(i,i+1,INF,0);
		if(i+tfast+1<=n)addedge(i,i+n+tfast+1,INF,mfast); 
		if(i+tslow+1<=n)addedge(i,i+n+tslow+1,INF,mslow);
		addedge(s,i+n,INF,m);
	}
	while(SPFA())
	{
		maxflow+=flow[t];
		mincost+=flow[t]*dis[t];
		for(int i=t;i!=s;i=edge[pre[i]^1].to)
		{
			edge[pre[i]].val-=flow[t];
			edge[pre[i]^1].val+=flow[t];
		}
	}
	printf("%lld",mincost);
	return 0;
}
```

---

## 作者：CyberPrisoner (赞：0)

这个数据范围一眼就是网络流，而且大概率是费用流，那么我们考虑如何建图。能用费用流的题大多数都是有一个固定的总数，这样可以在保证最大流固定的情况下求出最小的费用。对于本体来说每天需要的毛巾是固定的，那么每天毛巾数的总和就是我们要求的最大流，这个必定要连到源点或汇点，然后我们进行连边，然后不同天之间也要连边，两个点间隔刚超过毛巾清洗的时间可以建一个边，每两天直接因为脏毛巾可以继承需要连边，此时边数不能保证原有的最大流，所以我们考虑拆点，把一天拆成两个点，在不同层间转移，连接原汇的边流量设成当天的需求量，向源点额外连一条流量无线费用为新毛巾价格的边。

最后随便写个 dinic 即可

```
#include<bits/stdc++.h>
//#define int long long
using namespace std;
const int N=1010,inf=1e9+10;
int n,numedge=1,head[N*4],ans; 
int a,b,f,fa,fb,c[N*4],dis[N*4],s,t;
bool vis[N*4];
struct edge{
	int next,to;
	int cap,val;
}e[N*12];
void add(int from,int to,int cap,int val){
	e[++numedge].to=to;
	e[numedge].next=head[from];
	e[numedge].cap=cap;
	e[numedge].val=val;
	head[from]=numedge;
}
void addedge(int from,int to,int cap,int val){
	add(from,to,cap,val);
	add(to,from,0,-val);
}
bool SPFA(){
	for(int i=1;i<N*3;i++){
		dis[i]=inf;vis[i]=0;
	}
	queue<int> que;
	que.push(s);vis[s]=1;
	dis[s]=0;
	while(!que.empty()){
		int x=que.front();
		vis[x]=0;
		que.pop();
		for(int i=head[x];i;i=e[i].next){
			int y=e[i].to,z=e[i].val;
			if(!e[i].cap)continue;
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;
				if(!vis[y]){
					vis[y]=1;
					que.push(y);
				}
			}
		}
	} 
	return (dis[t]!=inf);
} 
int dfs(int x,int flow){
	if(x==t)return flow;
	int res=flow,k;
	vis[x]=1;
	for(int i=head[x];i&&res;i=e[i].next){
		int y=e[i].to,z=e[i].val;
		if(!e[i].cap||dis[y]!=dis[x]+z||vis[y])continue;
		k=dfs(y,min(e[i].cap,res));
		if(!k)dis[y]=0;
		e[i].cap-=k;
		e[i^1].cap+=k;
		ans+=z*k;
		res-=k;
	}
	vis[x]=0;
	return flow-res;
}
int dinic(){
	int flow=0,res=0;
	while(SPFA()){
		while(flow=dfs(s,inf)){
			res+=flow;
		}
	}
	return res;
}
signed main(){
	cin>>n>>a>>b>>f>>fa>>fb;
	t=n*2+1;
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=n;i++){
		addedge(s,i,c[i],0);
		addedge(i+n,t,c[i],0); 
		addedge(s,i+n,inf,f);
		if(i+a+1<=n)
		addedge(i,i+n+a+1,inf,fa);
		if(i+b+1<=n)
		addedge(i,i+n+b+1,inf,fb);
		if(i<n){
			addedge(i,i+1,inf,0);
		}
		
	}
	int maxflow=dinic();
	cout<<ans<<endl;
}
```


---

## 作者：ncwzdlsd (赞：0)

最小费用最大流问题。

考虑如何建图，先考虑一个点，如果想让每天的餐巾满足要求，必须保证所有有流量限制的边都流满。

先拆点，把每一个点拆成起始点和结束点，起始点接收新餐巾，结束点接收旧餐巾。建超级源点和超级汇点表示总的开始和结束。

- 对于每天获得的旧餐巾，显然位于结束点，对于清洗店 A 和 B，分别连一条到起始点 $i+a/b+1$ 的边，费用为 $f_1/f_2$，流量为 $+\infty$。需要注意的是还可能有延期送洗，连一条到第 $i+1$ 天的结束点的边，费用为 $0$，流量为 $n_i$。

- 对于购买新餐巾操作，从超级源点向每一个起始点连一条费用为 $f$，流量为 $+\infty$ 的边。

- 对于每天需要的餐巾，从超级源点向每一个点的结束点连一条费用为 $0$，流量为 $n_i$ 的边，从每个的起始点点向超级汇点连一条费用为 $0$，流量为 $n_i$ 的边。考虑为什么要这么建边。我们的结束点存储的是当天要洗的餐巾，而开始点存储的是当前要得到的餐巾。我们让每天有 $n_i$ 的餐巾流出到汇点，晚上从源点来同样多的脏餐巾，这样可以避免天与天之间建边的重复累加流量，同时又达到了强制满流的效果。

注意连边时要判断当前天数是否小于 $n$。

跑费用流即可。这里用的是 SPFA+Dinic，SPFA 经过 SLF 和 LLL 优化。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxm=4e6+5,maxn=5e5+5;
int head[maxn],cnt=1,n,m,s,t,r[maxn],now[maxn],m1,m2,c1,c2,p,tot,ss;
struct edge{ll to,nxt;ll c,w;}e[maxm];
bool vis[maxn],vv[maxn];
ll dis[maxn],minc;

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}

inline void add(int x,int y,ll z,ll q){e[++cnt]={y,head[x],z,q},head[x]=cnt;}

inline bool spfa()
{
	deque<int> q;
	int i;
	for(i=0;i<=t;++i) dis[i]=1e18;
	memset(vis,0,(t+1)*sizeof(bool));
	q.push_back(0),vis[0]=1,dis[0]=0,tot=1;
	while(!q.empty())
	{
		int x=q.front();vis[x]=0;
		while(tot*dis[x]>ss) q.pop_back(),q.push_back(x),x=q.front();
		q.pop_front(),tot--,ss-=dis[x];
		for(i=head[x];i;i=e[i].nxt)
			if(e[i].c>0&&dis[e[i].to]>dis[x]+e[i].w)
			{
				dis[e[i].to]=dis[x]+e[i].w;
				if(!vis[e[i].to])
					(dis[e[i].to]<=dis[q.front()])?q.push_front(e[i].to):q.push_back(e[i].to),vis[e[i].to]=1,ss+=dis[e[i].to],tot++;
			}
	}
	return dis[t]!=1e18;
}

inline ll dfs(int x,ll mxf)
{
	if(x==t) return mxf;
	ll sum=0;vv[x]=1;
	int i;
	for(i=now[x];i;i=e[i].nxt)
	{
		now[x]=i;
		if(!vv[e[i].to]&&e[i].c>0&&dis[e[i].to]==dis[x]+e[i].w)
		{
			ll ff=dfs(e[i].to,min(mxf-sum,e[i].c));
			if(ff) e[i].c-=ff,e[i^1].c+=ff,sum+=ff,minc+=ff*e[i].w;
		}
		if(sum==mxf) break;
	}
	vv[x]=0;
	return sum;
}

signed main()
{
	// ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m1>>m2>>p>>c1>>c2;
	t=2*n+1,m1++,m2++;
	int i;
	for(i=1;i<=n;++i) r[i]=read(),add(0,i,r[i],0),add(i,0,0,0),add(i+n,t,r[i],0),add(t,i+n,0,0);
	for(i=1;i<=n;++i)
	{
		add(0,i+n,1e18,p),add(i+n,0,0,-p);
		if(i+1<=n) add(i,i+1,1e18,0),add(i+1,i,0,0);
		if(i+m1<=n) add(i,i+m1+n,1e18,c1),add(i+m1+n,i,0,-c1);
		if(i+m2<=n) add(i,i+m2+n,1e18,c2),add(i+m2+n,i,0,-c2);
	}
	while(spfa()) memcpy(now,head,(t+1)*sizeof(int)),dfs(0,1e18);	
	cout<<minc;
	return 0;
}
```

---


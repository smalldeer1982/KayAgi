# [HNOI2002] 沙漠寻宝

## 题目描述

传说在漫无边际的沙漠中有一个古代城市的废墟，里面埋藏了大量的宝藏。听到这个消息的人一个又一个的前去寻宝，却没有发现一个回来的人。

探险家Jack是冒险者队伍中的后起之秀，它加入冒险者队伍的时间虽然不长，却屡屡依靠自己过人的智慧使自己和队友们脱离了险境。“明知山有虎，偏向虎山行”。 在Jack探险队的宗旨的指引下，Jack和他的队友们踏上了沙漠寻宝的旅程。

“我发现沙漠废墟了。”在一名队员的叫喊声中，Jack隐约看到了一些古代城市的残垣断壁和一个通道。 “一定就是这里了。”Jack带领着大家进入了通道。

然而，不幸的事情发生了。就在Jack他们进入通道的同时，通道的入口“轰”的一声就关闭了。Jack和他的队友走到了通道的尽头，正前方是一个巨大的铁门。最令人奇怪的是，铁门竟然使用的是一个极度先进的带有键盘和显示器的电子密码锁，铁门旁还赫然写着开锁的方法：“想到得到我的宝藏的人们，到这里的路途很辛苦吧！不过这一切很快就会结束的，这个铁门就是你们的葬身之地。除非你们能够计算出我屏幕上程序的结果，并且通过键盘输入进去，这扇门就会打开，里面就是我所有的宝藏”

我们的Jack果然不负众望，他打开了他的行囊，拿出了一个类似保险箱的东西。“没见过吗？这是最新型的笔记本电脑，没有它，我再怎么天才也不可能打开这扇门的。”面对大家疑惑的目光，Jack打开了笔记本电脑的开关。

“这个宝藏主人的程序十分的奇怪，我虽然没见过，但根据我的猜测，它的结构应该是这样的：

程序共包含6种语句：start,end,loop,continue,write,以及?=\*形式的语句。

start是程序的开始标志，其对应了一个结束标志end。

loop后面空一格并紧跟了一个表达式\*，表达式\*的值N表示即将循环N次，对应的循环结束标志也是end。

continue表示程序跳转到当前循环对应的end语句，break表示程序将跳出当前的循环。

write后面空一格并紧跟了一个表达式\*，表示要输出表达式\*的值，也就是要输入到密码锁中的内容。

?=\*是赋值语句，?是变量的名字，\*计算出来的值是要给?的。

另外，值得庆幸的是，变量名只允许使用’a’..’z’这26个小写字母，表达式也只允许使用加减乘除四种运算和以及括号，参与运算的也只能是26个变量或者是整数（允许不止一位整数）。表达式不会超过80个字符。”

“希望Jack能很快将锁打开。”大家心里默念着。

给定程序对所有语句的执行次数的总和小于2000000次。


## 样例 #1

### 输入

```
start
     i=0
     j=0
     loop 100
          i=i+1
          j=j+i
          continue
          loop 10
               write j
          end
     end
     loop 100
          j=j+1
          break
          j=j+1
     end
     write j
end
```

### 输出

```
5051```

# 题解

## 作者：Oxygen_L (赞：9)

# 写在前面

实际上已近写过一篇这个题的题解了，这次只是稍作修改，压缩了以前又臭又长的代码，顺便再说明一下解题思路。



## 遇到的问题
一看这个题就知道是模拟，但是怎么模拟呢？

首先，读入与存储问题，如何准确的读入以及如何将输入的代码存起来。

其次，也是最难的，模拟程序运行，其中最关键的就是如何模拟循环的运行。

再者，计算器的问题，赋值语句与循环次数的计算。



## 解决方案
1.读入与存储，开一个二维的char数组（string也行，个人喜好），使用scanf("%s",s)读入，遇到空格跳过。

2.运行过程，其他语句不多说，就讲讲最关键的循环语句吧，看到有很多大佬都是用栈来模拟，个人不太习惯用栈模拟，于是用了类似于递归的方法，一层层进入，再退出。

3.有关计算器，由于题中给出了语句的执行次数的总和小于2000000次，那么计算器完全可以使用递归代替栈来写，并且完全不用担心会超时。



### 最后附上AC代码，代码中有解释
```c
#include <cstdio>
#include <iostream>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#define MAXN 1001
using namespace std;
 
//函数总览，后面有解释
void read();
void work();
void find();
void write(char x[]);
int check(char x[]);
void run(char x[]);
void pre(char x[],int l,int r);
int calc(char x[],int l,int r);
void run_loo(char x[]);
int run_fu(char x[],int in,int enk);
 
char str[MAXN][MAXN],s[MAXN];
int tot=0,h=1,f[MAXN],ff[MAXN],sh[30];
const int sta=1,en=2,loo=3,con=4,wri=5,bre=6,fu=7;
 
//读入，处理掉空格
void read(){
    while((scanf("%s",s))!=EOF){
        if(s[0]!=' '){
            strcpy(str[++tot],s);
        }
    }
}

//输出
void run_wri(char x[]){
    ++h;
    printf("%d\n",run_fu(str[h],0,strlen(str[h])-1));
}

//预处理，找到循环的开始与结束
void find(){
    int v[MAXN],v1=0;
    for(int i=2;i<tot;i++){
        if(check(str[i])==loo){
            v1++;
            v[v1]=i;
        }else if(check(str[i])==en){
            f[v[v1]]=i;
            v1--;
        }
    }
}

//循环语句的递归实现
void run_loo(char x[]){
    ++h;
    int t=run_fu(str[h],0,strlen(str[h])-1),tmp=h-1;
    for(int i=1;i<=t;i++){
        ++h;
        while(check(str[h])!=en){
            if(check(str[h])==loo){
                run_loo(x);
            }else if(check(str[h])==con){
                break;
            }else if(check(str[h])==bre){
                h=f[tmp];
                return;
            }
            run(str[h]);
            ++h;
        }
        h=tmp+1;
    }
    h=f[tmp];
}

//每次使用计算器之前的预处理，为了处理表达式中有括号匹配的情况
void pre(char x[],int l,int r){
    int v[MAXN],tot=0;
    for(int i=l;i<=r;++i){
        if(x[i]=='('){
            v[++tot]=i;
        }else if(x[i]==')'){
            ff[v[tot]]=i;
            --tot;
        }
    }
}

//递归实现简单计算器
int calc(char x[],int l,int r){
    if(l==r&&x[l]>='a'&&x[l]<='z') return sh[x[l]-'a'];
    if(x[l]=='('&&x[r]==')'&&ff[l]==r){
        return calc(x,l+1,r-1);
    }
    int jia=0,cheng=0,isjia=0,ischeng=0,fa=0,isfa=0;
    for(int i=l;i<=r;++i){
        if(x[i]=='+') jia=i,isjia=1;
        else if(x[i]=='*') cheng=i,ischeng=1;
        else if(x[i]=='/') cheng=i,ischeng=0;
        else if(x[i]=='-') jia=i,isjia=0;
        else if(x[i]=='^') isfa=1,fa=i;
        else if(x[i]=='(') i=ff[i]-1;
    }
    if(jia!=0){
        if(isjia==1) return (calc(x,l,jia-1)+calc(x,jia+1,r));
        else return (calc(x,l,jia-1)-calc(x,jia+1,r));
    }else if(cheng!=0){
        if(ischeng==1) return (calc(x,l,cheng-1)*calc(x,cheng+1,r));
        else return (calc(x,l,cheng-1)/calc(x,cheng+1,r));
    }else if(isfa!=0){
        return (int)pow(calc(x,l,fa-1)*1.0,calc(x,fa+1,r)*1.0);
    }else if(jia==0&&cheng==0&&isfa==0){
        int tmp=0;
        for(int i=l;i<=r;++i){
            tmp=(tmp*10+(x[i]-'0'));
        }
        return tmp;
    }
}
 
//赋值语句的运行，调用calc()函数计算
int run_fu(char x[],int in,int enk){
    memset(ff,0,sizeof(ff));
    pre(x,in,enk);
    int res=calc(x,in,enk);
    return res;
}

//判断是哪一种语句
int check(char x[]){
    if(x[1]=='='){
        return fu;
    }else if(x[0]=='s'){
        return sta;
    }else if(x[0]=='e'&&x[1]=='n'){
        return en;
    }else if(x[0]=='l'&&x[1]=='o'){
        return loo;
    }else if(x[0]=='c'&&x[1]=='o'){
        return con;
    }else if(x[0]=='w'&&x[1]=='r'){
        return wri;
    }else if(x[0]=='b'&&x[1]=='r'){
        return bre;
    }else{
        return -1;
    }
}
 
//运行每一句语句
void run(char x[]){
    int k=check(x);
    switch(k){
        case 3:run_loo(x); break;
        case 5:run_wri(x); break;
        case 7:sh[x[0]-'a']=run_fu(x,2,strlen(x)-1); break;
        default:break;
    }
}
 
//循环每一句语句
void work(){
    while(h<=tot){
        run(str[h]);
        ++h;
    }
}
 
int main(){ 
    read();
    find();
    work();
    return 0;
}

```

有问题可在评论区留言哟。(●'◡'●)。~~~~~~~

---

## 作者：Ajsoabk (赞：8)

### [AC](https://www.luogu.org/record/show?rid=10100545)

这道模拟题可以说是相当~~毒瘤~~仁慈了

要是还有语法错误等等乱七八糟的

那就黑题无疑了

所以抱着这道题还算简单的~~自我安慰~~思想

我们来慢慢解剖这道美味的紫题

# 思路与代码

### 读入与预处理 

~~确实很简单啊有什么好说的~~

我们采用**离线读入,**~~瞎jb~~**尽情模拟**的方法

先定义一个行结构**Line**
```cpp
struct Line{
	int type;//语句类型 
	string expre;//记录下表达式 
	int lef,pos;//lef 赋值表达式的左值，pos 循环语句的end的位置 
}line[N];//1000行 
```
语句类型？不是问题：
```cpp
const int START=1,END=2,LOOP=3,CONTINUE=4,BREAK=5,WRITE=6,EQUAL=7;

```
**~~简单粗暴~~**

读入一个字符串之后,要判断它是什么类型

对于c风格字符串我们可以用字符串比较函数**strcmp**

对于string...~~string是不可能string的,这辈子都不可能string的~~

我这里出于~~懒~~时间考虑,用**前两个字符**来识别

先根据第二个字符来辨别赋值语句,再根据第一个字符来分辨write,break等混淆的语句：

```cpp
char tem[83] 
int cnt=0;
stack<int> cir;
while(scanf("%s",tem)!=EOF){
     switch(tem[1]){
        case 't'://start
        case 'n'://end
        case 'o':
            switch(tem[0]){
                case 'l'://loop
                case 'c'://continue
           }
        case 'r':
            switch(tem[0]){
               case 'w'://write
               case 'b'://break
           }
        case '='://赋值
      }
}

```

cir栈记录每个循环(circulate)的**loop位置**

识别出了每种类型后就存在该行的type里

对于一些**特殊的类型**(loop,end,赋值)的预处理：

**loop,end:遇到loop时行数cnt入栈,遇到对应的end时出栈并用end行的行数cnt初始化loop行的pos(上上方代码解释pos)**

**赋值:**存着**左值(lef)右值(expre)**就行了(等号左右两边的值),右值先存着表达式

其他的有表达式就读入表达式再存着

预处理代码:
```cpp
switch(tem[1]){
                case 't':cir.push(cnt);line[cnt++].type=START;break;
                case 'n':line[cir.top()].pos=cnt;cir.pop();line[cnt++].type=END;break;
                case 'o':
                    switch(tem[0]){
                        case 'l':cir.push(cnt);scanf("%s",tem);line[cnt++]=(Line){LOOP,tem};break;
                        case 'c':line[cnt++].type=CONTINUE;break;
                    }
                    break;
                case 'r':
                    switch(tem[0]){
                        case 'w':scanf("%s",tem);line[cnt++]=(Line){WRITE,tem};break;
                        case 'b':line[cnt++].type=BREAK;break;
                    }
                    break;
                case '=':line[cnt++]=(Line){EQUAL,tem+2,tem[0]-'a'};break;
            }
```

好,现在开始尽情模拟

i表示行数,end时利用一个特殊情况走出程序

loop还是一样用栈模拟

不过需要储存的信息多了那么一丢丢
1. 开始位置
2. 已循环次数
3. 上限

```cpp

struct Loop{//记录每层循环的信息 
	int pos,cnt,end;
//	pos loop的位置
//  cnt 记录次数 0到end-1 
//  end 记录表达式的值 
};
```

还是分类讨论：

**loop:计算出上限,循环次数初始化为0,丢到栈里去就好了**

**break: 取出栈顶元素并弹出得到循环开始行,预处理时又在开始行存了每一个loop的end位置,直接把i走到end下一行**

**continue:同上找到end位置直接走到end**

**end:次数递增,并判断是否继续循环,否则出栈
若碰到end时栈为空,说明走到结尾(因为start未入栈),程序结束**

剩下的没有什么技巧了,写个计算器就行了

模拟代码:

```cpp
while(1){
    if(line[i].type==EQUAL){
        name[line[i].lef]=calculater(line[i].expre);
        i++;
    }
    else if(line[i].type==WRITE){
        printf("%d\n",calculater(line[i].expre));
        i++;
    }
    else if(line[i].type==LOOP){
        cir.push((Loop){i,0,calculater(line[i].expre)});
        i++;
    }
    else if(line[i].type==BREAK){
        i=line[cir.top().pos].pos+1;
        cir.pop();
    }
    else if(line[i].type==END){
        if(cir.empty())break;
        int &tem=cir.top().cnt;
        tem++;
        if(tem<cir.top().end){
            i=cir.top().pos+1;
        }
        else {
            cir.pop();
            i++;
        }
    }
    else if(line[i].type==START){
        i++;
    }
    else if(line[i].type==CONTINUE){
        i=line[cir.top().pos].pos;
    }
}
```

#### 注释版完整代码

```cpp
#include<cstdio>
#include<cstring>
#include<cstdio>
#include<stack>
#include<string>
#define judge(a) (a=='*'||a=='/')
using namespace std;
const int N=1000;
const int START=1,END=2,LOOP=3,CONTINUE=4,BREAK=5,WRITE=6,EQUAL=7;
struct Line{
	int type;//语句类型 
	string expre;//记录下表达式 
	int lef,pos;//lef 赋值表达式的左值，pos 循环语句的end的位置 
}line[N];//1000行 
int name[27];//记录每个变量的值 
//-----------------------计算器--------------------------------------- 
stack<int> sta_num;//计算器的操作数栈 
stack<char> sta_ope;//计算器的操作符栈 
inline void calc(const char &ch){//const xxx& 传递不能修改的引用,大大加快传参速度 
	int a=sta_num.top();sta_num.pop();//取栈顶a,b 
	int b=sta_num.top();sta_num.pop();
	switch(ch){
		case '+':b+=a;break;
		case '-':b-=a;break;
		case '*':b*=a;break;
		case '/':b/=a;break;
	}
	sta_num.push(b);
}

inline bool Serious_smaller(const char& a,const char& b){
	return (a=='(')?1:(judge(a))?0:judge(b);//judge判断是否是乘除 
	/*
	if(a=='(')return true;//'('一定最小 
	else if(judge(a))return false;//乘除一定最大 
	else if(judge(b))return true;//a为加减,看b是否为乘除 
	else return false;
	*/
}

inline int calculater(const string &str){//计算器主体 
	int n=str.length();
	while(!sta_num.empty())sta_num.pop();//操作数清空(操作符不用因为结尾已清空) 
	for(int i=0;i<n;++i){
		if(isdigit(str[i])){//碰到数字 
			int num=str[i++]-'0';
			while(isdigit(str[i]))//取数字 
				num=num*10+str[i++]-'0';
			i--;
			sta_num.push(num);
		}
		else if(islower(str[i])){//碰到变量 
			sta_num.push(name[str[i]-'a']);//直接代入 
		}
		else{
            if(str[i]=='('){//碰到左括号 
                sta_ope.push(str[i]);//直接入栈 
            }
			else if(str[i]==')'){//碰到右括号 
				while((!sta_ope.empty())&&sta_ope.top()!='('){//不断取出直到碰到左括号 
					calc(sta_ope.top());//计算 
					sta_ope.pop();//弹出 
				}
				if(sta_ope.top()=='(')sta_ope.pop();//弹出左括号 
			}
			else{
				while((!sta_ope.empty())&&!Serious_smaller(sta_ope.top(),str[i])){//不断取出直到碰到更低优先级
					calc(sta_ope.top());//计算 
					sta_ope.pop();//弹出 
				}
				sta_ope.push(str[i]);//入栈 
			}
		}
	}
	while(!sta_ope.empty()){//操作符清空 
		calc(sta_ope.top()); //... 
		sta_ope.pop();
	}
	return sta_num.top();//剩下即答案 
}
//-------------------------------计算器板子------------------------------- 
struct Loop{//记录每层循环的信息 
	int pos,cnt,end;
//	pos loop的位置
//  cnt 记录次数 0到end-1 
//  end 记录表达式的值 
};
char tem[83];//scanf输入每一行 
int cnt;
int main(){
	{//使括号内声明的变量为自动储存类别,出块销毁,因为后面还有一个cir懒得想名字 
		stack<int> cir;//cir 存入每个循环开始的位置 
		while(scanf("%s",tem)!=EOF){//初步编译 
			switch(tem[1]){//第二个字符分类讨论,switch-case由跳跃表实现比if-else快 
				case 't':cir.push(cnt);line[cnt++].type=START; break;//start语句 
//							推入循环栈           
				case 'n':line[cir.top()].pos=cnt;cir.pop(); line[cnt++].type=END; break;//end语句 
//					当前循环开始所在行数 记录对应的end所在行数 
				case 'o'://loop或continue 
					switch(tem[0]){//第一个字符分类讨论 
						case 'l':cir.push(cnt); scanf("%s",tem); line[cnt++]=(Line){LOOP,tem}; break;//loop语句 
//								推入循环栈	  	   读入表达式   					类型 表达式(char[] 自动转化为 string)	
						case 'c':line[cnt++].type=CONTINUE;break;//continue语句
//								存就是了 
					}
					break;
				case 'r'://write或break 
					switch(tem[0]){
						case 'w':scanf("%s",tem);line[cnt++]=(Line){WRITE,tem};break;//write语句
//						      	读入后面的表达式 	  				类型  表达式(char[] 自动转化为 string)
						case 'b':line[cnt++].type=BREAK;break;//break语句
//								存就是了 
					}
					break;
				case '=':line[cnt++]=(Line){EQUAL,tem+2,tem[0]-'a'};break;//赋值语句
//											类型  右值  左值 
			}
		}
	}
	stack<Loop> cir;//记录循环 
	while(!cir.empty())cir.pop();//清空 
	int i=0;
	while(1){
		if(line[i].type==EQUAL){//赋值语句 
			name[line[i].lef]=calculater(line[i].expre);
//				左值			计算表达式(右值) 
			i++;
		}
		else if(line[i].type==WRITE){//write语句 
			printf("%d\n",calculater(line[i].expre));
//							计算表达式 
			i++;
		}
		else if(line[i].type==LOOP){//loop语句 
			cir.push((Loop){i,0,calculater(line[i].expre)});
//				推入循环栈 起点,已循环次数,应循环次数 
			i++;
		}
		else if(line[i].type==BREAK){//break语句 
			i=line[cir.top().pos].pos+1;
//			直接将i移至循环末的后一行 两个pos意义刚好相对 
//  			line[当前循环.loop位置].end位置+1 
			cir.pop();
		}
		else if(line[i].type==END){//end语句 
			if(cir.empty())break;//由于start不算作循环最后一个end没有对应的loop,可依此判断程序结束 
			int &tem=cir.top().cnt;//引用当前循环已循环次数 
			tem++;//次数++ 
			if(tem<cir.top().end){//满足循环条件 
				i=cir.top().pos+1;//i移至loop位置的下一行 
			}
			else {
				cir.pop();//走出循环 
				i++;
			}
		}
		else if(line[i].type==START){
			i++;
		}
		else if(line[i].type==CONTINUE){//continue语句 
			i=line[cir.top().pos].pos;
//			直接走到end就行
//		i移至 line[当前循环.loop位置].end位置 
		}
	}
	return 0;
}
```

~~啰里八嗦~~

---

## 作者：linz (赞：8)

总体来说这道题不算非常难，主要是读题要仔细比如write是输出一个表达式，不是一个变量~~~~当时我就看成了输一个变量还好有大佬及时提醒~~，还有数据比较坑，细心点慢慢调会AC（~~wa~~）的，~~我也就调了一个下午~~

```cpp
#incldue <bits/stdc++.h>
#define maxn 1000
using namespace std;
//变量说明
string code[maxn];	//string 存代码
int tot;			//代码长度 
int ii;				//代码运行到哪里了 
long long bl[100];stack<long long>number;stack<char>fh;//计算器 

int check(int i){//检查语句是哪一种
    if(code[i][1]=='=')				return 1;//赋值语句
    else if(code[i]=="loop") 		return 2;//循环
    else if(code[i]=="write") 		return 3;//输出
    else if(code[i]=="end")			return 4;//结束
    else if(code[i]=="continue")	return 5;//跳过
    else if(code[i]=="break")		return 6;//跳出
    else return 0;
}

void jisuan(){
    char s=fh.top();
    long long b=number.top();number.pop();
    long long a=number.top(); 	number.pop();
    switch(s){
        case '*':	number.push(a*b);break;
        case '/':	number.push(a/b);break;
        case '+':	number.push(a+b);break;
        case '-':	number.push(a-b);break;
    }
}

long long calc(int step){//计算表达式，常规操作
	number.clear();	
    for(int i=2;i<(int)code[step].size();i++){//从2开始跳过变量与等于号
        if(isdigit(code[step][i])){
            int x=0;
            while(isdigit(code[step][i]))	x=x*10+code[step][i]-48,i++;	
            i--;
            number.push(x);continue;
        }
        else if(code[step][i]>='a'&&code[step][i]<='z'){
            number.push(bl[code[step][i]-'a']);
        }
        else{
            if(!fh.size())fh.push(code[step][i]);
            else if(code[step][i]=='(')fh.push(code[step][i]);
            else if(code[step][i]==')'){
                while(fh.top()!='(')jisuan(),fh.pop();
                fh.pop();
            }
            else if(code[step][i]=='*'||code[step][i]=='/'){
            //值得注意的是，这里while里的条件必须是fh.size（）在前
          //这样当栈为空时，就不会跑后面的条件直接退出，下面的也一样
          //我写的时候就因为这个错了好几遍还一直怀疑洛谷
                while(fh.size()&&fh.top()!='+'&&fh.top()!='-'&&fh.top()!='(')
                    jisuan(),fh.pop();
                fh.push(code[step][i]);
            }
            else if(code[step][i]=='+'||code[step][i]=='-'){
                while(fh.size()&&fh.top()!='(')	jisuan(),fh.pop();
                fh.push(code[step][i]);
            }
                
        }
    }
    while(fh.size())	jisuan(),fh.pop();
    return number.top();
}

int find1(int step){
    int v=1,i=step+1;
    while(1){
        if(code[i]=="loop")v++;
        else if(code[i]=="end")	v--;
        if(v==0)	return i;
        i++;
    }
}
int Loop(int step){//对于嵌套循环，这里可以用递归处理
    int k=find1(step),x=0,j=0;//k是和当前loop匹配的end的位置，x是循环次数
    while(j<(int)code[step].size()&&isdigit(code[step+1][j]))
    x=x*10+code[step+1][j]-48,j++;	
    for(int t=1;t<=x;t++){
        for(int i=step+2;i<=k;i++){
            int kk=check(i);
            if(kk==1)    bl[code[i][0]-'a']=calc(i);
            else if(kk==2)	i=Loop(i);
            else if(kk==3)	printf("%lld\n",calc(++i));//嵌套循环，递归
            else if(kk==4||kk==5)	break;//模拟continue和end
            else if(kk==6)return k;//如果是break直接跳出，不用再循环了
        }
    }
    return k;//递归时当处理完这一层的循环，上一层的循环的的i要跳到这一层循环的end，也就是k出
}

void work(){
    for(ii=2;ii<tot;ii++){//总的代码进度
        int k=check(ii);//检查是那种语句
        if(k==1){    bl[code[ii][0]-'a']=calc(ii);	
        else if(k==2)   ii=Loop(ii);	//循环
        else if(k==3)	printf("%lld\n",calc(++ii));
        else continue;
    }
}

int main(){
    int flage=0;
//读入这么写是因为，write输出的不是一个变量而是一个表达式为了运用calac函数（这个函数是用来计算赋值语句的，
//而赋值语句要从等号后算也就是code[i][2]算起）就得在write后的表达式前加上两个字符,省得再写一个函数
    while(cin>>code[++tot]){
        if(flage==1)   code[tot]="A="+code[tot],flage=0;
        else if(code[tot]=="write")	flage=1;//读到write，用flage标记
    }
    work(); 
    return 0;
}

```

---

## 作者：Ray1 (赞：3)

这是一道大模拟。

我们可以直接使用 `cin` 读入字符串，会自动过滤空格。

执行时直接判断命令类型，如果遇到 `loop` 就循环递归下去，其他类型的处理详见代码。

`loop`、`write` 和赋值语句的等号后都会接一个表达式，手写一个计算器就行了。

至于计算中引入变量，可以开一个数组存储当前每个变量的值，遇到赋值语句则变更，计算时直接套用即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int p=-1,a[26];//把当前每个变量的值分别储存起来 
string s[2000000];
//计算器部分 ↓
int zc;
stack<int>num,fh;
int zj(char ch){
	if(ch=='+')return 1;
	if(ch=='-')return 2;
	if(ch=='*')return 4;
	if(ch=='/')return 5;
	if(ch=='(')return -1;
	if(ch==')')return -2;
}
void zh(int t){
	while(!fh.empty()){
		if(fh.top()==-1){
			if(t==-2)fh.pop(),zc=num.top(),num.pop();//左右括号匹配，括号中计算后的数字弹出 
			return; 
		}
		if(fh.top()+1<t)return;
		int a=num.top();
		num.pop();
		int b=num.top();
		num.pop();
		if(fh.top()==1)num.push(a+b);
		if(fh.top()==2)num.push(b-a);
		if(fh.top()==4)num.push(a*b);
		if(fh.top()==5)num.push(b/a);
		fh.pop();
	}
}
int write(string s){
	zc=0;
	for(int i=0;i<s.size();i++){
        if('0'<=s[i]&&s[i]<='9')zc=(zc<<3)+(zc<<1)+(s[i]^48);//处理数字 
        else if('a'<=s[i]&&s[i]<='z')zc=a[s[i]-'a'];//处理字母（变量）
		else{//处理符号（进行运算） 
            int ZJ=zj(s[i]);
            if(ZJ!=-1)num.push(zc),zc=0;
            if(!fh.empty()&&fh.top()+1>=ZJ&&ZJ>0)zh(ZJ);
            else if(ZJ==-2){
            	zh(ZJ);
				continue;
			}
            fh.push(ZJ);
        }
    }
	num.push(zc),zh(0);
	int ans=num.top(); 
	num.pop();
	return ans;
}
//计算器部分 ↑
inline bool Do(int i){//直接根据语句执行命令 
	while(s[++i]!="end"){
		if(s[i]=="continue")return 0;
		if(s[i]=="break")return 1;
		if(s[i]=="loop"){
			int loop=write(s[++i]),cnt=1;
			for(int j=1;j<=loop;j++)if(Do(i))break;//直接递归，遇到break就停止
			while(cnt){//跳到end部分 
				i++;
				if(s[i]=="loop")cnt++;
				if(s[i]=="end")cnt--;
			} 
		}else if(s[i]=="write")cout<<write(s[++i])<<'\n';
		else a[s[i][0]-'a']=write(s[i].substr(2,s[i].size()-2));
	}
	return 0;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	while(cin>>s[++p]);//直接cin读入字符串即可（不读入空格）
	Do(0);
}
```


---

## 作者：囧仙 (赞：2)

## 题解

观察发现，本题主要可以分为两个部分：**中缀表达式求值**以及**根据算法流程**模拟。因此，以下分别说明。

### 中缀表达式求值

在本题中，仅仅会出现单字母变量，以及加减乘除和括号。按照惯例，我们使用两个栈进行维护。$\text{A}$ 栈维护当前处理到的数字，$\text{B}$ 栈维护当前处理到的运算符。为了防止非法访问，我们在 $\text{B}$ 栈里先推入一个左括号。

- 由于本题允许不止一位整数，所以只有当读到了一个非数字字符时，我们再把这个整数作为整体压入 $\text{A}$ 栈；当读入到的是小写字母时，就直接从对应的变量取出并压入 $\text{A}$ 栈即可。

- 当读入到加减乘除之一的运算符 $\mathit{op}$ 时，不断取出 $\text{B}$ 栈栈顶的一个运算符 $\mathit{op'}$ 。若 $\mathit{op'}$ 优先级不小于 $\mathit{op}$，则取出 $\text{A}$ 栈栈顶的两个数字，运算后加入 $\text{A}$ 栈，直到取出的 $\mathit{op'}$ 优先级更小。最后把读入的运算符压入 $\text{B}$ 栈。这样可以保证，当前 $\text{B}$ 栈中的运算符优先级严格单调递增。

- 当读入到左括号时，直接压入。

- 当读入到右括号时，按照读入加减乘除运算符的方式运算，直到 $\text{B}$ 栈栈顶为左括号。结束后记得弹出这个左括号。

### 模拟流程

使用结构体定义类型 $\text{Node}$，用于表示当前运算到的节点。里面包含该节点的种类（$\text{start,end,loop,continue,break,write}$ 之一）$f$、与该节点直接关联的表达式 $S$、临时变量 $t$ 和 $w$，以及该节点的后继节点 $l$。特别地，我们将 $\text{start}$ 视为特殊的 $\text{loop}$。对于每个语句，都用一个节点表示。

预处理时我们需要一个栈 $T$。同时我们需要一个数组 $A$，存储 $26$ 个变量的值。

对输入数据进行预处理，处理出对应的节点：

- 为了实现语句匹配，当读入到 $\text{start,loop}$ 时将它的编号入栈；读入到 $\text{continue,break,end}$ 时，将这三种语句创建出的节点的 $w$ 指向栈顶（也就是对应 $\text{loop}$ 语句的编号）。特别地，读取到 $\text{end}$ 语句就让栈顶弹出，并且将对应 $\text{loop}$ 节点的 $t$ 赋值为当前节点的下一个节点的编号。

- 为了实现赋值语句，我们将该节点的 $w$ 赋值为需要赋值的那个变量的编号。

- 为了实现循环语句，我们用 $\text{loop}$ 节点当中的 $w$ 存储当前剩下的循环次数。$\text{continue}$ 语句的 $t$ 赋值为 $-1$，$\text{break}$ 语句的 $t$ 赋值为 $-\infty$（代码中，赋值为一个极小值）。预处理到 $\text{continue}$ 或者 $\text{break}$ 时，**忽略**剩下的所有语句，直到碰到对应 $\text{loop}$ 的 $\text{end}$。

- 将与 $\text{start}$ 指令匹配的 $\text{end}$ 节点的 $l$ 赋值为 $-1$。其他节点的 $l$ 赋值为它的编号 $+1$。

然后是进行模拟。我们设当前访问到的节点编号为 $p$。

- 如果当前节点为赋值语句，那就将对应变量 $A_w$ 赋值为对 $p(S)$ 中缀表达式求值后的结果。接着 $p\gets p(l)$。

- 如果当前节点为 $\text{loop}$，那么将 $p(w)$ 赋值为对 $p(S)$ 中缀表达式求值后的结果。接着 $p\gets p(l)$。

- 如果当前节点为 $\text{continue}$ 或者 $\text{break}$，就将 $\text{loop}$ 节点 $p(w)$ 的 $t$ 加上当前节点的 $t$。如果相加后小于 $0$，则跳转至 $p(w)$ 对应的 $\text{end}$ 节点的下一个节点 $(p(w))(t)$ ；否则跳转至 $(p(w))(l)$。

- 如果当前节点为 $\text{write}$，直接输出对 $p(S)$ 表达式求值的结果，并 $p\gets p(l)$。即可。

- 如果某个时刻，$p=-1$，那么终止程序。

于是这题就做完了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
map<char,int> A;
int calc(const string S){
	stack <int > W; stack <char> C; map<char,int> M;
	M['+']=M['-']=1,M['*']=M['/']=2,M['(']=-2,M[')']=-1;
	W.push(0),C.push('#'),C.push('(');
	int w=0,f=1; bool d=0; for(int p=0,l=S.length();p<=l;++p){
		char t=(p<l?S[p]:')'); if(t=='(') C.push('('); else
		if(!d&&t=='+'&&C.top()=='(') f= 1; else
		if(!d&&t=='-'&&C.top()=='(') f=-1; else
		if(isalpha(t)) w=A[t]      ,d=true; else
		if(isdigit(t)) w=w*10+t-'0',d=true; else {
			if(d) W.push(w*f),w=0,f=1,d=false;
			while(M[C.top()]>=M[t]){
				int a=W.top(); W.pop();
				int b=W.top(); W.pop();
				int o=C.top(); C.pop(); int c;
				switch(o){
					case '+': c=b+a; break;
					case '-': c=b-a; break;
					case '*': c=b*a; break;
					case '/': c=b/a; break;
				}
				W.push(c);
			}
			if(t==')') C.pop(); else C.push (t);
		}
	}
	return W.top();
}
const int MAXN =1e6+3;
int p;
struct Node{
	int t,l,w,f; string S; void operator()();
}N[MAXN];
void Node::operator()(){
	switch(f){
		case 0: A[w]=calc(S),p=     l   ; break;
		case 1:   w =calc(S),p=(w>0?l:t); break;
		case 2: N[w].w+=t,p=(N[w].w>0?N[w].l:N[w].t); break;
		case 3: cout<<calc(S)<<endl,p=l;  break;
		case -1:p=-1;
	}
}
int main(){
	ios_base::sync_with_stdio(false);
	stack <int> S; string x,y; int n=0;
	do{
		++n,N[n].l=n+1,N[n].t=0; cin>>x;
		if(x=="start") S.push(n); else 
		if(x=="loop" ) cin>>N[n].S,N[n].f=1,S.push(n);
		else if(x=="continue") N[n].t=-1  ,N[n].f=2,N[n].w=S.top();
		else if(x=="break"   ) N[n].t=-INF,N[n].f=2,N[n].w=S.top();
		else if(x=="write"   ) cin>>N[n].S,N[n].f=3;
		else if(x=="end"){
			if(S.top()==1) N[n].f=-1; else{
				N[S.top()].t=n+1; N[n].w=S.top(),N[n].t=-1,N[n].f=2;
			}
			S.pop();
		} else {
			N[n].w=x[0],N[n].S=x.substr(2),N[n].f=0;
		}

	}while(!S.empty());
	p=1; while(p!=-1) N[p]();
	return 0;
}
```

---

## 作者：Wilson_Lee (赞：2)

特别，特别，恶心的一道模拟题

有点像17年的时间复杂度（~~但更恶心~~有成为黑题的潜质）

考点也比较多：简单计算器、手写编译器

简单计算器可以用栈实现（思路：先算乘除，在算加减，遇到右括号一直出栈直到遇到左括号）：
```cpp
long long demo(long long start,long long len)
{
    long long sum,num,tem;
    sum=num=tem=0;
    for(long long i=start;i<len;i++)
    {
        if(re[t].r[i]<='9' && re[t].r[i]>='0')
        {
            while(re[t].r[i]<='9' && re[t].r[i]>='0')
            {
                num*=10;
                num+=re[t].r[i]-'0';
                i++;
            }
            i--;
            if(!c.empty() && c.top()=='*')
            {
                n.top()=n.top()*num;
                c.pop();
            }
            else if(!c.empty() && c.top()=='/')
            {
                n.top()=n.top()/num;
                c.pop();
            }
            else
            {
                n.push(num);
            }
            num=0;
        }
        else if(re[t].r[i]<='z' && re[t].r[i]>='a')
        {
            if(!c.empty() && c.top()=='*')
            {
                n.top()=n.top()*a[re[t].r[i]-'a'];
                c.pop();
            }
            else if(!c.empty() && c.top()=='/')
            {
                n.top()=n.top()/a[re[t].r[i]-'a'];
                c.pop();
            }
            else
            {
                n.push(a[re[t].r[i]-'a']);
            }
        }
        else
        {
            c.push(re[t].r[i]);
            if(re[t].r[i]==')')
            {
                c.pop();
                tem=n.top();
                n.pop();
                while(c.top()!='(')
                {
                    if(c.top()=='+')
                    {
                        tem+=n.top();
                    }
                    else
                    {
                        tem=n.top()-tem;
                    }
                    n.pop();
                    c.pop();
                }
                c.pop();
                if(c.empty())
                n.push(tem);
                else if(c.top()=='*')
                {
                    n.top()*=tem;
                    c.pop();
                }
                else if(c.top()=='/')
                {
                    n.top()/=tem;
                    c.pop();
                }
                else
                {
                    n.push(tem);
                }
                tem=0;
            }
        }
    }
    sum=n.top();
    n.pop();
    while(!c.empty())
    {
        if(c.top()=='+')
        {
            sum+=n.top();
        }
        else
        {
            sum=n.top()-sum;
        }
        c.pop();
        n.pop();
    }
    return sum;
}
```
操作总共有6种类型，但主要是循环恶心

可以开一个数组，从一个循环开头直接飞到该循环结束，这样会使代码更加简洁

200行代码贴在这（本蒟蒻的代码还是复杂了）
```cpp
#include<bits/stdc++.h>
using namespace std;

long long a[26];
int end_num[1000];//起飞
struct node
{
    char r[80];
};
node re[1000];//离线存储
stack<int>s;
stack<int>n;
stack<char>c;
int maxn=1;
int t=0;
int maxe=0;
int te=0;
long long demo(long long begin,long long len) //计算器
{
    long long sum,num,tem;
    sum=num=tem=0;
    for(long long i=begin;i<len;i++)
    {
        if(re[t].r[i]<='9' && re[t].r[i]>='0')
        {
            while(re[t].r[i]<='9' && re[t].r[i]>='0')
            {
                num*=10;
                num+=re[t].r[i]-'0';
                i++;
            }
            i--;
            if(!c.empty() && c.top()=='*')   //一定要有empty的判断
            {
                n.top()=n.top()*num;
                c.pop();
            }
            else if(!c.empty() && c.top()=='/')
            {
                n.top()=n.top()/num;
                c.pop();
            }
            else
            {
                n.push(num);
            }
            num=0;
        }
        else if(re[t].r[i]<='z' && re[t].r[i]>='a')
        {
            if(!c.empty() && c.top()=='*')
            {
                n.top()=n.top()*a[re[t].r[i]-'a'];
                c.pop();
            }
            else if(!c.empty() && c.top()=='/')
            {
                n.top()=n.top()/a[re[t].r[i]-'a'];
                c.pop();
            }
            else
            {
                n.push(a[re[t].r[i]-'a']);
            }
        }
        else
        {
            c.push(re[t].r[i]);
            if(re[t].r[i]==')')
            {
                c.pop();
                tem=n.top();
                n.pop();
                while(c.top()!='(')
                {
                    if(c.top()=='+')
                    {
                        tem+=n.top();
                    }
                    else
                    {
                        tem=n.top()-tem;
                    }
                    n.pop();
                    c.pop();
                }
                c.pop();
                if(c.empty())
                n.push(tem);
                else if(c.top()=='*')
                {
                    n.top()*=tem;
                    c.pop();
                }
                else if(c.top()=='/')
                {
                    n.top()/=tem;
                    c.pop();
                }
                else
                {
                    n.push(tem);
                }
                tem=0;
            }
        }
    }
    sum=n.top();
    n.pop();
    while(!c.empty())
    {
        if(c.top()=='+')
        {
            sum+=n.top();
        }
        else
        {
            sum=n.top()-sum;
        }
        c.pop();
        n.pop();
    }
    return sum;
}
int flag=0;
int scan()
{
    long long n;
    int start,endd,tem;
    t++;
    if(re[t].r[0]=='l' && re[t].r[1]=='o')//loop情况
    {
        t++;
        n=demo(0,strlen(re[t].r));
        start=t;
        flag=0;
        while(true)
        {
            tem=scan();
            if(tem==3)
            {
                break;
            }
            else if(tem==2)
            {
                t=end_num[start-1];
                flag=0;
                return 0;
            }
            else if(tem==1)
            {
                break;
            }
        }
        endd=t-1;
        for(int i=1;i<n;i++)
        {
            t=start;
            while(t<=endd)//注意这里不能用for循环（就是因为这个100变20）
            {
                scan();
            }
        }
        t=end_num[start-1];       //直接起飞
    }
    else if(re[t].r[0]=='e' && re[t].r[1]=='n')//end
    {
        return 3;
    }
    else if(re[t].r[1]=='=')//直接赋值
    {
        a[re[t].r[0]-'a']=demo(2,strlen(re[t].r));
    }
    else if(re[t].r[0]=='w' && re[t].r[1]=='r')//write
    {
        t++;
        printf("%lld\n",demo(0,strlen(re[t].r)));
    }
    else if(re[t].r[0]=='c' && re[t].r[1]=='o')//continue
    {
        return 1;
    }
    else if(re[t].r[0]=='b' && re[t].r[1]=='r')//break
    {
        return 2;
    }
    return 0;
}
int main()
{
    s.push(1);            //特殊处理begin，不然会RE
    while(scanf("%s",re[maxn].r)!=EOF)            //处理起飞代码
    {
        if(re[maxn].r[0]=='l' && re[maxn].r[1]=='o')
        {
            s.push(maxn);
        }
        if(re[maxn].r[0]=='e' && re[maxn].r[1]=='n')
        {
            end_num[s.top()]=maxn;
            s.pop();
        }
        maxn++;
    }
    maxn--;
    while(true)
    {
        scan();
        if(t==maxn)
        break;
    }
    return 0;
}
```
有可以优化的地方欢迎指正

---

## 作者：Night_Aurora (赞：2)

- ## 前言

	这是一个模拟题,难度不亚于杀蚂蚁
	
	因为与杀蚂蚁相比更需要清晰的结构

	所以很考验代码底力..底力与写代码的时间成正比
    
    同时也考研对于语言的理解

---
- ## 题解
	我们先一点一点考虑
    
    从底层往上层来考虑
    
    下文都是以c++为语言
    
    ---
    变量最多只有26个
    
    我们可以开个数组来保存每个变量的值
    
    --- 
    
   让人头痛的是表达式的处理
        
   首先是表达式的存储，我们可以用一个二元组OBJ=  
   $<Type(int),Data(int)>$
    
   来存储一个单位，其中Type表示类型，Data表示数据
        
   类型可以是整数，代数和运算符
        
   而数据就如字面意思
        
   那样我们存储一个表达式就可以用vector<OBJ>实现，设其为EXP
  
  中缀表达式很难处理，我们可以将其转换为后缀表达式
  
  如何转换可以见百度
  
  ---
  
  设数据结构ASSIGN为二元组类型$<Vala(char),Valb(EXP)>$,表示将表达式Valb计算出并赋值给变量Vala
  
  然后我们建立一个通用的可以表示所有语句数据结构STATE
  
  可以理解为二元组$<Type(int),Data(void*)>$Type表示类型，Data表示有关数据
  
  对于Type表示continue，break,start，end语句时，Data不用管
  
  对于Type表示loop，write语句时，Data表示其后的表达式参数，所以此时Data就是一个指向EXP的指针
  
  对于Type表示赋值语句时，Data表示整个赋值语句参数，所以此时Data就是一个指向ASSIGN的指针
  
  ---
  
  然后我们就能把所有的语句都存下来，存到一个数组里
  
  对于loop end和start end我们处理出每个loop和start所对应的end的位置，用下标来存储
  
  对于运作我们可以写一个RUNA函数来执行一个语句，当然它只会处理赋值语句和write语句，其他都会忽略
  
  我们再写一个RUN函数来执行[F,T]这段语句，它的返回值表示是否因为break而退出的
  
  RUN实现就是对于每个语句先RUNA一遍，然后在讨论是什么语句
  
  		
        	如果是continue就直接返回0
        
       	 如果是break就直接返回1
        
       	 如果是loop就处理出表达式的值k，然后多次递归处理loop所表示的语句区间，(这段区间不包括这个loop和end);在处理到达k次或者递归返回1时结束对这个loop和end的处理，并把当前位置跳到end后
        
        	如果都不是就把当前位置+1
            
   这样最后一个RUN(2,L-1)就能完成了，假设语句存储从1开始且语句个数为L
   
   [代码](https://paste.ubuntu.com/p/xJjf5t9wKr/)
  
  
  
  
        
        

---

## 作者：lusers (赞：1)

# 一种很有意思的 Python 3 解法

*下文中的 Pig 语言指代题目中的编程语言*

## TL;DR

首先，众所周知，Python 的标准库极其强大，而且 Python 是解释型语言。

那么，可以将 Pig 语言转换为 Python 解释器能够执行的东西，让 Python 解释器去运行这段代码，而不是自己手写一个解释器。

## 详细一点

1. 将输入的代码格式化。

2. 将输入的代码中的语句转换成 Python 语句。

3. 处理一些细节差异。

4. 调用 Python 解释器，运行代码。

## 注意事项

1. 数据可能含有这种情况：

    ```pig
    start
    end
    ```

    ```pig
    loop 1
    end
    ```

	但是，在 Python 中，以下的写法是错误的：
    
    ```python
    x = 3
    if x % 2 == 0: # 空的 if 语句
    print(x)
    ```
    
    正确写法如下：
    ```python
    x = 3
    if x % 2 == 0: # 空的 if 语句
        pass # right
    print(x)
    ```
    
    所以需要特殊处理。
    
2. 在 Pig 语言中，**没有作用域**。

	也就是说，这段 Pig 代码是合法且正确的：
    
    ```pig
    start
        loop 1
            x=3
        end
        write x // 输出 3
    end
    ```
    
    但是在 Python 中，这样写是危险的：

    ```pig
    for _ in range(1):
        x = 3
    print(x) # "x" is possibly unbound
    ```
    
    因为 `x` 在 `print` 语句执行时已经离开了它的作用域，`x` 已经是 unbound 的，所以这段代码可能会报错。
    
    所以也需要特殊处理（不处理的话会 Wrong Answer)。

3. 在 Pig 语言中，除法是**整除**。

	这个你应该知道。

## 实现

注意看，第二个和第三个注意事项都需要解析**代码**。

消除作用域效果的办法是把代码中所有的变量都变成全局变量，那么就需要获取代码中所有的变量；把除法变成整除也需要先找出代码中所有的除法。

注意这一章节开头的那句话：解析**代码**。这代码可以是 Pig 代码，也可以是 Python 代码。在这篇文章的开头提到了 Python 的标准库，而这是因为 Python 的标准库中提供了一个强大的模块：`ast`。

这个模块对 Python 的语法进行了抽象，把 Python 代码抽象为一棵树，树上的每个节点就是 Python 中的语句或者表达式。这种抽象也存在于其他编程语言上，统一叫做**抽象语法树**（Abstract Syntax Tree，简称 AST）。

而 `ast` 模块，提供了一个可以把 Python 代码解析为 AST 的函数。利用它，就可以解析 Python 代码，从而达到目的。

## 代码

```python
import sys
import random
import string
import ast
import gc

# Settings
INDENT_SIZE = 4
INDENT_STR = ' '

# Utils


def isBlockStmt(stmt: str):
    return stmt in ['start', 'loop']


def isUnfinishedStmt(stmt: str):
    return stmt in ['loop', 'write']


def isUnblockStmt(stmt: str):
    return stmt == 'end'


def indentize(data: str, level: int):
    return ''.join([INDENT_STR*INDENT_SIZE*level, data])


# Input
script_s = sys.stdin.read()

# Unformatize
script_l = list(map(lambda x: x.strip(), script_s.splitlines()))
del script_s
script_usl = ' '.join(script_l).split()
del script_l

# Relineize
script_fl = []
idx = 0
while idx < len(script_usl):
    stmt = script_usl[idx]
    if not isUnfinishedStmt(stmt):
        script_fl.append(stmt)
    else:
        script_fl.append(' '.join([stmt, script_usl[idx+1]]))
        idx += 1
    idx += 1

del script_usl

# Reindentize
script_il: list[tuple[int, str]] = []
indentLevel = 0
lastop = 0
for line in script_fl:
    # script_l[idx] = indentize(line, indentLevel)
    script_il.append((indentLevel, line))
    lineStmt = line.split()[0]
    if isBlockStmt(lineStmt):
        indentLevel += 1
        lastop = 1
    elif isUnblockStmt(lineStmt):
        if lastop == 1:
            script_il.insert(len(script_il)-1, (indentLevel, 'pass'))
        indentLevel -= 1
        lastop = -1
    else:
        lastop = 0
del script_fl

# Pythonize
for idx, [indentl, line] in enumerate(script_il):
    lineStmts = line.strip().split()
    if len(lineStmts) == 0:
        continue
    lineStmt = lineStmts[0]
    result = line
    if lineStmt == 'loop':
        result = f"for _ in range({' '.join(line.split(' ')[1:])}):"
    elif lineStmt == 'start':
        result = line.replace('start', 'if True:', 1)
    elif lineStmt == 'end':
        result = ''
    elif lineStmt == 'write':
        result = f'print({line.split()[1]})'
    script_il[idx] = (indentl, result)

script_py = '\n'.join(map(lambda x: indentize(x[1], x[0]), script_il))
del script_il

# AST
script_ast = ast.parse(script_py)
initalizeders = []
for node in ast.walk(script_ast):
    if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Div):
        node.op = ast.FloorDiv()
    elif isinstance(node, ast.Name) and isinstance(node.ctx, ast.Store):
        initalizeders.append(node.id)

exec(compile(script_ast, '<string>', 'exec'),
     {name: 0 for name in initalizeders})
```

代码很简洁，却实现了强大的功能。这就是 Python 的魅力所在。


---

## 作者：zbwcom (赞：1)

## 遇到的问题

一看这个题就知道是模拟，但是怎么模拟呢？

首先，读入与存储问题，如何准确的读入以及如何将输入的代码存起来。

其次，也是最难的，模拟程序运行，其中最关键的就是如何模拟循环的运行。

再者，计算器的问题，赋值语句与循环次数的计算。
## 解决方案

- 1.读入与存储，开一个二维的数组，输入遇到空格跳过。

- 2.运行过程，其他语句不多说，就讲讲最关键的循环语句吧，看到有很多大佬都是用栈来模拟，个人不太习惯用栈模拟，于是用了类似于递归的方法，一层层进入，再退出。

- 3.有关计算器,完全可以使用递归代替栈来写，并且完全不用担心会超时。

**最后附上AC代码，代码中有解释**
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#define MAXN 1001
using namespace std;

//函数总览，后面有解释
void read();
void work();
void find();
void write(char x[]);
int check(char x[]);
void run(char x[]);
void pre(char x[],int l,int r);
int calc(char x[],int l,int r);
void run_loo(char x[]);
int run_fu(char x[],int in,int enk);

char str[MAXN][MAXN],s[MAXN];
int tot=0,h=1,f[MAXN],ff[MAXN],sh[30];
const int sta=1,en=2,loo=3,con=4,wri=5,bre=6,fu=7;

//读入，处理掉空格
void read(){
    while((scanf("%s",s))!=EOF){
        if(s[0]!=' '){
            strcpy(str[++tot],s);
        }
    }
}

//输出
void run_wri(char x[]){
    ++h;
    printf("%d\n",run_fu(str[h],0,strlen(str[h])-1));
}

//预处理，找到循环的开始与结束
void find(){
    int v[MAXN],v1=0;
    for(int i=2;i<tot;i++){
        if(check(str[i])==loo){
            v1++;
            v[v1]=i;
        }else if(check(str[i])==en){
            f[v[v1]]=i;
            v1--;
        }
    }
}

//循环语句的递归实现
void run_loo(char x[]){
    ++h;
    int t=run_fu(str[h],0,strlen(str[h])-1),tmp=h-1;
    for(int i=1;i<=t;i++){
        ++h;
        while(check(str[h])!=en){
            if(check(str[h])==loo){
                run_loo(x);
            }else if(check(str[h])==con){
                break;
            }else if(check(str[h])==bre){
                h=f[tmp];
                return;
            }
            run(str[h]);
            ++h;
        }
        h=tmp+1;
    }
    h=f[tmp];
}

//每次使用计算器之前的预处理，为了处理表达式中有括号匹配的情况
void pre(char x[],int l,int r){
    int v[MAXN],tot=0;
    for(int i=l;i<=r;++i){
        if(x[i]=='('){
            v[++tot]=i;
        }else if(x[i]==')'){
            ff[v[tot]]=i;
            --tot;
        }
    }
}

//递归实现简单计算器
int calc(char x[],int l,int r){
    if(l==r&&x[l]>='a'&&x[l]<='z') return sh[x[l]-'a'];
    if(x[l]=='('&&x[r]==')'&&ff[l]==r){
        return calc(x,l+1,r-1);
    }
    int jia=0,cheng=0,isjia=0,ischeng=0,fa=0,isfa=0;
    for(int i=l;i<=r;++i){
        if(x[i]=='+') jia=i,isjia=1;
        else if(x[i]=='*') cheng=i,ischeng=1;
        else if(x[i]=='/') cheng=i,ischeng=0;
        else if(x[i]=='-') jia=i,isjia=0;
        else if(x[i]=='^') isfa=1,fa=i;
        else if(x[i]=='(') i=ff[i]-1;
    }
    if(jia!=0){
        if(isjia==1) return (calc(x,l,jia-1)+calc(x,jia+1,r));
        else return (calc(x,l,jia-1)-calc(x,jia+1,r));
    }else if(cheng!=0){
        if(ischeng==1) return (calc(x,l,cheng-1)*calc(x,cheng+1,r));
        else return (calc(x,l,cheng-1)/calc(x,cheng+1,r));
    }else if(isfa!=0){
        return (int)pow(calc(x,l,fa-1)*1.0,calc(x,fa+1,r)*1.0);
    }else if(jia==0&&cheng==0&&isfa==0){
        int tmp=0;
        for(int i=l;i<=r;++i){
            tmp=(tmp*10+(x[i]-'0'));
        }
        return tmp;
    }
}

//赋值语句的运行，调用calc()函数计算
int run_fu(char x[],int in,int enk){
    memset(ff,0,sizeof(ff));
    pre(x,in,enk);
    int res=calc(x,in,enk);
    return res;
}

//判断是哪一种语句
int check(char x[]){
    if(x[1]=='='){
        return fu;
    }else if(x[0]=='s'){
        return sta;
    }else if(x[0]=='e'&&x[1]=='n'){
        return en;
    }else if(x[0]=='l'&&x[1]=='o'){
        return loo;
    }else if(x[0]=='c'&&x[1]=='o'){
        return con;
    }else if(x[0]=='w'&&x[1]=='r'){
        return wri;
    }else if(x[0]=='b'&&x[1]=='r'){
        return bre;
    }else{
        return -1;
    }
}

//运行每一句语句
void run(char x[]){
    int k=check(x);
    switch(k){
        case 3:run_loo(x); break;
        case 5:run_wri(x); break;
        case 7:sh[x[0]-'a']=run_fu(x,2,strlen(x)-1); break;
        default:break;
    }
}

//循环每一句语句
void work(){
    while(h<=tot){
        run(str[h]);
        ++h;
    }
}

int main(){ 
    read();
    find();
    work();
    return 0;
}
```


---

## 作者：ExplodingKonjac (赞：0)

### [原题链接](https://www.luogu.com.cn/problem/P2229)

## 这么好的一道大模拟，怎么能不用OOP（Object Oriented Programming）来写呢

很多人觉得 OOP 会很慢，但其实 OOP 可以跑得很快的，我的第一份 AC 代码在目前（$2021.8.4$）是以 $92ms$ 排行第三。将 STL 的 `stack` 改成手工栈后稳妥以 $38ms$ 拿到最优解。

## 解题思路

暴力模拟

需要掌握的技巧：字符串读入分析、表达式求值。

## 实现细节

由于循环的存在，如果我们在每次循环中都重新解析一遍代码，速度将会变得非常慢（`Python` 龟速的原因），很多人应该都是因为这个而跑得慢。

解决办法是只经过一次扫描，将代码抽象化，执行时不必进行分析。

接下来就是 OOP 登场了。

### 结构分析

题目中的语言有如下几种语句：赋值、循环、输出。主程序可以看做一个 $1$ 次的循环。所以我们只需要实现几个类：语句的基类 $\mathtt{Statement}$、实现赋值的类 $\mathtt{Assignment}$、实现循环的类 $\mathtt{Loop}$、实现输出的类 $\mathtt{Write}$，以及用于存储表达式的类 $\mathtt{Expression}$。

我们定义了全局数组 $\mathrm{var}$ 来储存变量数值。

### 实现 $\mathtt{Expression}$ 类

设计如下的类成员：

* 成员类 $\mathtt{Element}$，用于储存一个元素（数字、变量或运算符）；
  1. `int type`：用于储存该元素是数字（$0$）、变量（$1$）还是运算符（$2$）；
  2. `LL val`：如果是数字，则存的是数值，否则存一个字符的 $\text{ASCII}$ 值。

* `vector<Element> ele`：储存该表达式的后缀形式；
* `void read()`：用于读入一个表达式并转化为后缀表示的函数，实现可以看看 [P1175](https://www.luogu.com.cn/problem/P1175)；
* `LL calculate()`：用于根据已储存后缀形式计算表达式的值，实现仍然可以看看 [P1175](https://www.luogu.com.cn/problem/P1175)；

### 实现 $\mathtt{Statement}$ 类

$\mathtt{Statement}$ 是 $\mathtt{Assignment}$、$\mathtt{Loop}$、$\mathtt{Write}$ 类的基类。该类没有成员变量，尽管如此，设计一个基类仍然能使事情变得简单。

设计如下的纯虚函数：

* `virtual void execute()`：执行该语句，将在子类中实现。

### 实现 $\mathtt{Assignment}$ 类

继承自 $\mathtt{Statement}$ 类。

设计如下的类成员：

* `char left`：赋值语句的左值，即需要被赋值的变量名；

* `Expression right`：赋值语句的右值，即赋给变量的表达式。
* `void execute()`：只有一条简洁的语句，`var[left]=right.calculate();`；

### 实现 $\mathtt{Write}$ 类

继承自 $\mathtt{Statement}$ 类。

设计如下的类成员：

* `Expression e`：储存需要输出的表达式；

* `void execute()`：仍然很简洁，`printf("%lld\n",e,calculate());`；

### 实现 $\mathtt{Loop}$ 类

继承自 $\mathtt{Statement}$ 类。

比前两者复杂几倍（设计如下的类成员：

* `vector<Statement*> sub`：储存循环的子语句。使用基类的指针可以使其支持所有派生类；

* `Expression tms`：储存循环次数的表达式。

* `void execute()`：依次执行每一条语句即可

   ```cpp
   int n=tms.calculate();
   for(int i=1;i<=n;i++)
       for(auto &j: sub)
           j->execute();
   ```

读入部分写在了类的构造函数内部，直接放代码吧：

```cpp
bool con=false; //是否遇到了continue
int cnt=1; //遇到continue时的堆栈，用于找到正确的end
tms=x; //请稍后结合完整代码理解
if(!x)	tms.read();
while(true)
{
	if(con)
	{
		while((str[0]=getchar())<33); //过滤空格
		for(int i=0;;str[++i]=getchar()) //读入一个串
			if(str[i]<33)
				{ str[i]='\0';break; }
		str[4]='\0'; //仅需截取串的前4位
		if(!strcmp(str,"loop"))	cnt++; //堆栈+1
		if(!strcmp(str,"end"))	cnt--; //堆栈-1
		if(!cnt)	break; //堆栈位0，即找到了自己的end
		continue;
	}
	while((str[0]=getchar())<33);
	for(int i=1;;i++)
	{
		str[i]=getchar();
		if(str[i]=='=' || str[i]<33) //字符串到'='或者空格结束
			{ str[i]='\0';break; }
	}
	if(!strcmp(str,"end")) // 各种情况分别讨论
		break;
	else if(!str[1])
		sub.push_back(new Assignment(str[0])); //Assignment类在构造函数内写了读入，Write也是
	else if(!strcmp(str,"continue"))
		con=true;
	else if(!strcmp(str,"break"))
		con=true,tms=1; //break的效果其实和continue一样，都是无视后面的语句
						//但是同时需要把循环次数设置为1（Expression类重载了=运算符）
	else if(!strcmp(str,"loop"))
		sub.push_back(new Loop());
	else if(!strcmp(str,"write"))
		sub.push_back(new Write());
}
```

## 完整代码

还是比较好理解的

这是 $92ms$ 的代码，改为手工栈就有了 $38ms$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
int var[256],pri[256];
class Expression
{
 private:
	struct Element
	{
		LL val;
		int type; //0:number, 1:variable, 2:operator
		Element(): val(0){}
		Element(int t,int x): val(x),type(t){}
		inline int operator()()
			{ return type?var[val]:val; }
	};
	vector<Element> ele;
 public:
	Expression(): ele(){}
	void read()
	{
		stack<Element> s;
		ele.clear();
		char ch;
		while((ch=getchar())<33);
		while(ch>32)
		{
			Element x;
			if(ch>='0' && ch<='9')
			{
				x.type=0;
				do
					x.val=x.val*10+ch-'0',ch=getchar();
				while(ch>='0' && ch<='9');
				ele.push_back(x);
			}
			else if(ch>='a' && ch<='z')
			{
				x.type=1,x.val=ch;
				ele.push_back(x),ch=getchar();
			}
			else
			{
				x.type=2,x.val=ch;
				if(s.empty() || x.val=='(' || s.top().val==')')
					s.push(x);
				else if(x.val==')')
				{
					while(s.top().val!='(')
						ele.push_back(s.top()),s.pop();
					s.pop();
				}
				else
				{
					while(!s.empty() && pri[ch]<=pri[s.top().val])
						ele.push_back(s.top()),s.pop();
					s.push(x);
				}
				ch=getchar();
			}
		}
		while(!s.empty())	ele.push_back(s.top()),s.pop();
		ele.shrink_to_fit();
	}
	LL calculate()
	{
		stack<Element> s;
		for(auto &i: ele)
		{
			if(i.type==2)
			{
				int x=s.top()();s.pop();
				int y=s.top()();s.pop();
				if(i.val=='+')
					s.push(Element(0,x+y));
				else if(i.val=='-')
					s.push(Element(0,y-x));
				else if(i.val=='*')
					s.push(Element(0,x*y));
				else
					s.push(Element(0,y/x));
			}
			else	s.push(i);
		}
		return s.top()();
	}
	void operator =(LL x)
		{ ele.clear(),ele.push_back(Element(0,x)); }
};
class Statement
{
 private:
	int type;
 public:
	Statement()=default;
	virtual void execute()=0;
};
class Assignment: public Statement
{
 private:
	char left;
	Expression right;
 public:
	Assignment(char ch): left(ch),right()
		{ right.read(); }
	void execute()
		{ var[left]=right.calculate(); }
};
class Write: public Statement
{
 private:
	Expression e;
 public:
	Write(): e()
		{ e.read(); }
	void execute()
		{ printf("%lld\n",e.calculate()); }
};
char str[1005];
class Loop: public Statement
{
 private:
	vector<Statement*> sub;
	Expression tms;
 public:
	Loop(int x=0): sub()
	{
		bool con=false;
		int cnt=1;
		tms=x;
		if(!x)	tms.read();
		while(true)
		{
			if(con)
			{
				while((str[0]=getchar())<33);
				for(int i=0;;str[++i]=getchar())
					if(str[i]<33)
						{ str[i]='\0';break; }
				str[4]='\0';
				if(!strcmp(str,"loop"))	cnt++;
				if(!strcmp(str,"end"))	cnt--;
				if(!cnt)	break;
				continue;
			}
			while((str[0]=getchar())<33);
			for(int i=1;;i++)
			{
				str[i]=getchar();
				if(str[i]=='=' || str[i]<33)
					{ str[i]='\0';break; }
			}
			if(!strcmp(str,"end"))
				break;
			else if(!str[1])
				sub.push_back(new Assignment(str[0]));
			else if(!strcmp(str,"continue"))
				con=true;
			else if(!strcmp(str,"break"))
				con=true,tms=1;
			else if(!strcmp(str,"loop"))
				sub.push_back(new Loop());
			else if(!strcmp(str,"write"))
				sub.push_back(new Write());
		}
	}
	void execute()
	{
		int n=tms.calculate();
		for(int i=1;i<=n;i++)
			for(auto &j: sub)
				j->execute();
	}
};
int main()
{
	pri['*']=pri['/']=2,pri['+']=pri['-']=1;
	while(getchar()!='\n');
	Loop main_proc(1);
	main_proc.execute();
	return 0;
}
```


---

## 作者：_caiji_ (赞：0)

这题一看就知道是个模拟。

做模拟题的时候，一定要先确保你的程序能跑出正确的结果，再去想优化时间。

这道题还是很简单的，让我们开始吧：

### 读入
我们把输入离线，拿 `string` 存起来。如果不离线，那 `loop` 就会很难处理，加大难度。
```cpp
int n;
string a[1010];//亲测最多只会有 1000 条语句

while(cin>>a[++n]);n--;
```

### 预处理
我们可以先预处理每个 `start` 和 `loop` 对应的 `end` 的位置。这样做的原因会在后面说。

```cpp
int jump[1010];
stack<int> init;
for(int i=1;i<=n;i++){
	if(a[i]=="start"||a[i]=="loop") init.push(i);//如果是 start/loop，把编号压入栈
	if(a[i]=="end") jump[init.top()]=i,init.pop();//如果是 end，标记位置
}
```

### 运行代码
定义一个 `int run(int now)` 函数，使用递归实现，$now$ 表示从哪条语句开始运行，返回值表示最终执行到哪条语句。

但我们要考虑一个问题：遇到 `break` 该返回什么呢？我们可以返回 $-1$，然后特判一下。

```cpp
int run(int now){
	for(int i=now;i<=n;i++){
		if(a[i]=="write"){
        //write：输出一个表达式的值并换行
        //那就输出 a[i+1] 这个表达式的值咯
			i++;
			cout<<calc(a[i])<<endl;//这个 calc 是计算函数，后面讲
		}else if(a[i]=="loop"){
        //loop：循环语句，执行 a[i+1] 次
        //那就递归实现
			i++;
			int times=calc(a[i]);
			for(int j=1;j<=times;j++){
				int tmp=run(i+1);
				if(tmp==-1) break;//返回 -1 说明是 break，外层 loop 也跟着 break 
			}
			i=jump[i-1];//jump 的作用，跳到这个 loop 后面
		}else if(a[i]=="break"){
			return -1;//返回 -1，代表自己是 break
		}else if(a[i]=="continue"){ 
			return jump[now-2];//返回这个这个 loop 对应的 end 的位置
		}else if(a[i]=="end"){
			return i;//同 continue
		}else if(a[i]=="start"){
			//什么也不做哈哈哈
		}else{//都不是，那就是赋值语句
			int tmp=calc(a[i].substr(2));//substr(2) 表示从 2 这个位置后面的所有字符
			m[a[i][0]-'a']=tmp;//赋值
		}
	}
	return n;
}
```

### 计算表达式
这部分可以看 [link](https://blog.csdn.net/sinat_27908213/article/details/80273557)，照着他的代码打一遍就好了。
```cpp
int lev(char a){//优先级
	switch(a){
		case '(':return 0;
		case '+':case '-':return 1;
		case '*':case '/':return 2;
		case ')':return 3;
	}
	return 0;
}
void plu(stack<int> &s,char op){//需要注意，plus 是 STL 函数
	int num1,num2;
	num2=s.top(),s.pop();
	num1=s.top(),s.pop();
	switch(op){
		case '+':s.push(num1+num2);return ;
		case '-':s.push(num1-num2);return ;
		case '*':s.push(num1*num2);return ;
		case '/':s.push(num1/num2);return ;
	}
}
int calc(string a){//计算函数
	stack<int> s1,s2;
	for(int i=0;i<a.size();i++){
		if('a'<=a[i]&&a[i]<='z') s1.push(m[a[i]-'a']);//处理变量
		else if('0'<=a[i]&&a[i]<='9'){//数字
			int tmp=a[i]-48,j=i+1;
			while(j<a.size()&&'0'<=a[j]&&a[j]<='9') tmp=tmp*10-48+a[j],j++;
			s1.push(tmp),i=j-1;
		}else if(a[i]=='+'||a[i]=='-'||a[i]=='*'||a[i]=='/'){//加减乘除
			if(s2.empty()) s2.push(a[i]);
			else{
				while(!s2.empty()&&lev(s2.top())>=lev(a[i])){
					plu(s1,s2.top());
					s2.pop();
				}
				s2.push(a[i]);
			}
		}else{//括号
			if(a[i]=='(') s2.push(a[i]);
			else{
				while(s2.top()!='('){
					plu(s1,s2.top());
					s2.pop();
				}
				s2.pop();
			}
		}
	}
	while(!s2.empty()){
		plu(s1,s2.top());
		s2.pop();
	}
	return s1.top();
}
```

### 整合
把上面的代码结合在一起就能 A 了。

完整代码：
```cpp
#pragma GCC optimize(2)
//这篇题解常数很大，会 TLE on #5，需要 O2 优化 
#include <stack>
#include <string>
#include <iostream>
#include <queue>
using namespace std;
string a[1010];
int n,m[30],jump[1010];
int lev(const char &a){
	switch(a){
		case '(':return 0;
		case '+':case '-':return 1;
		case '*':case '/':return 2;
		case ')':return 3;
	}
	return 0;
}
void plu(stack<int> &s,const char &op){
	int num1,num2;
	num2=s.top(),s.pop();
	num1=s.top(),s.pop();
	switch(op){
		case '+':s.push(num1+num2);return ;
		case '-':s.push(num1-num2);return ;
		case '*':s.push(num1*num2);return ;
		case '/':s.push(num1/num2);return ;
	}
}
int calc(const string &a){
	stack<int> s1,s2;
	for(int i=0;i<a.size();i++){
		if('a'<=a[i]&&a[i]<='z') s1.push(m[a[i]-'a']);
		else if('0'<=a[i]&&a[i]<='9'){
			int tmp=a[i]-48,j=i+1;
			while(j<a.size()&&'0'<=a[j]&&a[j]<='9') tmp=tmp*10-48+a[j],j++;
			s1.push(tmp),i=j-1;
		}
		else if(a[i]=='+'||a[i]=='-'||a[i]=='*'||a[i]=='/'){
			if(s2.empty()) s2.push(a[i]);
			else{
				while(!s2.empty()&&lev(s2.top())>=lev(a[i])){
					plu(s1,s2.top());
					s2.pop();
				}
				s2.push(a[i]);
			}
		}else{
			if(a[i]=='(') s2.push(a[i]);
			else{
				while(s2.top()!='('){
					plu(s1,s2.top());
					s2.pop();
				}
				s2.pop();
			}
		}
	}
	while(!s2.empty()){
		plu(s1,s2.top());
		s2.pop();
	}
	return s1.top();
}
int run(const int &now){
	for(int i=now;i<=n;i++){
		if(a[i]=="write"){
			i++;
			cout<<calc(a[i])<<endl;
		}else if(a[i]=="loop"){
			i++;
			int times=calc(a[i]);
			for(int j=1;j<=times;j++){
				int tmp=run(i+1);
				if(tmp==-1) break;
			}
			i=jump[i-1];
		}else if(a[i]=="break"){
			return -1;
		}else if(a[i]=="continue"){
			return jump[now-2];
		}else if(a[i]=="end"){
			return i;
		}else if(a[i]=="start"){
			//f**k ccf
		}else{
			int tmp=calc(a[i].substr(2));
			m[a[i][0]-'a']=tmp;
		}
	}
	return n;
}
stack<int> init;
int main(){
    ios::sync_with_stdio(0),cin.tie(0);
	while(cin>>a[++n]);n--;
	for(int i=1;i<=n;i++){
		if(a[i]=="start"||a[i]=="loop") init.push(i);
		if(a[i]=="end") jump[init.top()]=i,init.pop();
	}
	run(1);
	return 0;
}
```

---


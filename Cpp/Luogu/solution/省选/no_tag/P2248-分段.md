# 分段

## 题目描述

给你 $n$ 个数 $a_1 \sim a_n$，要求将它们分成若干连续的段，其中有 $m$ 对给定的数不能被分到同一段。

分出一个段的代价是：

$$K + S \times (P - Q)$$

其中 $K$ 和 $S$ 均为给定的常数，$P$ 是该段中所有数的最大值，$Q$ 是该段中所有数的最小值。

你需要求出每段代价之和最小的分段方案。

## 说明/提示

对于 $10\%$ 的数据，$n \leq 10$。

对于 $30\%$ 的数据，$n \leq 1500$。

对于另外 $10\%$ 的数据，$S = 0$。

对于另外 $30\%$ 的数据，$m = 0$。

对于 $100\%$ 的数据，$1 \le m,n \le 10^5$，$0 \le K,S,a_i \le 10^5$，$1 \le p_i,q_i \le n$，$p_i \ne q_i$。

## 样例 #1

### 输入

```
5 2
3 1
2 3 12 14 16
2 3
3 1```

### 输出

```
11```

# 题解

## 作者：kyel (赞：10)

### **标签：线段树，单调队列，动态规划。**

令front[i]表示**最近的不能和i共区间的元素位置**，显然front[i]可以在输入时通过取最大值处理出来。**显然，i不能和front[i]以及位置更靠前的元素划为一段。**

令dp[i]表示使区间[1, i]中的元素合法分段所需要的最小代价

考虑向位置i转移，假设有位置j在i前且合法。则要么dp[i] = dp[i - 1] + k，即元素i单独分一段，**要么找到某个值j使得dp[j] + cost(j + 1, i)最小**。其中cost(j + 1, i) = s * (Max(j + 1, i) - Min(j + 1, i)),**即将区间[j + 1, i]分为一段的代价**。

显然，重点在于如何**高效地找到j使得dp[j] + cost(j + 1, i)最小**。

用线段树维护。**线段树维护的是从之前某一位置j进行转移且将位置j与当前位置划为一段的最小代价**，当然使用时是区间查询而**不关心具体位置**。假定我们已经求得了dp[i]，且将区间[j, i - 1]划为一段的代价记为V0，那么我们发现，如果有位置j < i且Vj为Min(j + 1, i - 1)且Vi < Vj，**即在位置j之后除了Vi没有比Vj小的值**，那么如果位置i+1希望从j位置或者更靠前**一些**的位置转移，则代价为V0 + s \* (Vj - Vi)，**因为Vi取代了Vj最小值的地位，需要补上增加的代价**。为什么说是更靠前“一些”呢？因为位置j之前可能有比Vj还小的元素，而这个时候如果有Vk > Vi，那么对应需要增加的代价就是s \* (Vk - Vi)。因此，这些位置是**从后往前值递减**的，因为如果出现了位置j > k且Vj < Vk，那么k不可能是之后计算代价用到的最小值，我们就不再关心了。因此，可以用一个**从前往后单调递增**的单调队列Min来维护这个位置的序列，然后用线段树做区间加法维护最小代价。

最大值同理利用单调队列维护。

显然，文字叙述过于繁琐，更简明的思路请参照代码。
```cpp
#include <cstdio>
#include <cstdlib>

#include <deque>
#include <algorithm>

namespace my {
	template <class T> inline void getmax(T& a, T b) { if (b > a) a = b; }
	template <class T> inline void getmin(T& a, T b) { if (b < a) a = b; }
}
const int maxn(112345);
namespace seg {
	long long val[maxn << 2], tag[maxn << 2];
#define ls (n << 1)
#define rs (n << 1 | 1)
	inline void push(int n) {
		if (tag[n]) {
			val[ls] += tag[n], tag[ls] += tag[n];
			val[rs] += tag[n], tag[rs] += tag[n];
			tag[n] = 0;
		}
	}
	inline void update(int n) {
		val[n] = std::min(val[ls], val[rs]);
	}
	long long quary(int n, int left, int right, int l, int r) {
		if (left == l && right == r) {
			return val[n];
		}
		push(n);
		int mid(left + right >> 1);
		if (r <= mid) return quary(ls, left, mid, l, r);
		else if (l > mid) return quary(rs, mid + 1, right, l, r);
		return std::min(quary(ls, left, mid, l, mid), quary(rs, mid + 1, right, mid + 1, r));
	}
	void modify(int n,int left, int right, int l, int r, long long v) {
		if (left == l && right == r) {
			val[n] += v, tag[n] += v;
			return;
		}
		push(n);
		int mid(left + right >> 1);
		if (r <= mid) modify(ls, left, mid, l, r, v);
		else if (l > mid) modify(rs, mid + 1, right, l, r, v);
		else modify(ls, left, mid, l, mid, v), modify(rs, mid + 1, right, mid + 1, r, v);
		update(n);
	}
}
std::deque<int> min, max;
int n, m, front[maxn];
long long k, s, v[maxn], dp[maxn];
void solve() {
	int f(0);
	for (int i(1); i <= n; ++i) {
		my::getmax(f, front[i]);
		while (!min.empty() && min.front() <= f) min.pop_front();
		int fp(i - 1);//在fp之后的最小值不是v[min.back()]，因此只加区间[fr + 1, fp]
		while (!min.empty() && v[min.back()] >= v[i]) {
			//v[i]取代v[pos]成为之后的最小值，v[pos]对之后无“贡献” 
			int pos(min.back()); min.pop_back();
			int fr(min.empty() ? f : min.back());
			seg::modify(1, 1, n, fr + 1, fp, s * (v[pos] - v[i]));
			//v[i]取代v[pos]成为之后的最小值，故增加s * (v[pos] - v[i])
			fp = fr;
		} min.push_back(i);
		while (!max.empty() && max.front() <= f) max.pop_front();
		fp = i - 1;
		while (!max.empty() && v[max.back()] <= v[i]) {
			int pos(max.back()); max.pop_back();
			int fr(max.empty() ? f : max.back());
			seg::modify(1, 1, n, fr + 1, fp, s * (v[i] - v[pos]));
			fp = fr;
		} max.push_back(i);
		dp[i] = dp[i - 1] + k;
		if (f + 1 < i) my::getmin(dp[i], seg::quary(1, 1, n, f + 1, i) + k);
		//从[f + 1, i]中找到一个最合适的位置p使得p与i划分为一段且总代价最小
		if (i != n)	seg::modify(1, 1, n, i + 1, i + 1, dp[i]);
		//读者可以体会一下为什么要在i + 1处加上dp[i]以及为什么这么做是对的 
	}
	printf("%lld\n", dp[n]);
}
int main() {
	scanf("%d%d%lld%lld", &n, &m, &k, &s);
	for (int i(1); i <= n; ++i) scanf("%d", v + i);
	for (int i(0); i != m; ++i) {
		int a, b; scanf("%d%d", &a, &b);
		if (a > b) std::swap(a, b);
		my::getmax(front[b], a);
	}
	solve();
	return 0;
}

```

---

## 作者：dspt (赞：1)

显然动态规划，于是有算法 1：

记 $f_i$ 为将 $1\sim i$ 分成若干段后得到的**最小代价**，转移简单，但要先处理一下不能分为一段的数对。

记 $b_i$ 为**与 $i$ 不能分为一段的数的最大下标**，则对于 $p,q(p<q)$，$b_q=\max(b_q,p)$。

观察得到性质：若 $b_i<b_{i-1}$，则 $i-1,b_{i-1}$ 不能划为一段，$i,b_i$ 不能划为一段。但如果此时 $i$ 与 $b_i+1$ 划为一段，那么 $b_i-1$ 与 $i-1$ 也会被划分为同一段（因为 $b_i-1\leqslant b_{i-1}$），于是可以在处理完输入之后进行一个**前缀和**，使 $b_i=\max(b_i,b_{i-1})$。

考虑转移，枚举与 $i$ 在同一段的**段首 $j$ **即可，因为需要快速得到最大最小值，所以用 **RMQ** 预处理最值。状态转移方程：

$f_i=\min(f_{j-1}+s(\text{getmax}(j,i)-\text{getmin}(j,i)))+k(b_i<j\leqslant i)$

时间复杂度：$O(n^2\log n)$，空间复杂度：$O(n\log n)$，可以获得 $30$ 分。

---

算法 2：发现有 $m=0$ 和 $s=0$ 两档部分分，有很多做法。

结合算法 1 和数据点分治，可以获得 $70$ 分。

---

考虑对算法 1 进行优化，得到算法 3：

观察状态转移方程，考虑 $i\rightarrow i+1$ 的过程：发现 $f_j$ 是不会变的，对于每一个 $j$，$\text{getmin}$ 和 $\text{getmax}$ 则会改变。

什么时候改变呢？是在 $a_{i+1}<\text{getmin}(j,i)$ 或者 $a_{i+1}>\text{getmax}(j,i)$ 的时候。

并且可以发现，在 $i\rightarrow i+1$ 的时候，如果改变，只有**连续的右端点为 $i$ 的区间**发生改变。也就是说，改变会是这样的形式：

$\text{getmin}(j,i+1)=a_{i+1}(p\leqslant j\leqslant i+1),\text{getmin}(j,i+1)=\text{getmin}(j,i)(1\leqslant j<p)$ 或

$\text{getmax}(j,i+1)=a_{i+1}(p\leqslant j\leqslant i+1),\text{getmax}(j,i+1)=\text{getmax}(j,i)(1\leqslant j<p)$

其中 $p$ 是从左到右第一个 $\text{getmin}$ 或 $\text{getmax}$ 改变的位置，$p$ 显然满足 $a_{p-1}\leqslant a_{i+1}$ 或 $a_{p-1}\geqslant a_{i+1}$，这样 $p-1$ 所在的区间才能不改变。

因为要找到第一个 $a_{p-1}\leqslant a_{i+1}$ 或者 $a_{p-1}\geqslant a_{i+1}$，所以要维护一个单调的序列。这个序列要满足可以实现快速查找，并且可以使序列尾部的数弹出，想到**单调栈**。

对于 $\text{getmin}$ 维护一个**单调递增的单调栈**，对于 $\text{getmax}$ 维护一个**单调递减的的单调栈**。栈里每个节点维护一段区间 $[l,r]$ 和该区间上的最值，这里 $r$ 其实可以省略，维护 $\{l,v\}$ 即可。为了方便，就可以在单调递增的单调栈栈底放入 $\{0,0\}$，在单调递减的单调栈栈底放入 $\{\inf,0\}$。如果 $i\rightarrow i+1$ 时单调栈变得不单调了，那就在单调栈上弹出栈底，对**区间最值**进行**修改**。

对于**区间最值**的**区间修改**，这就要引出本题的第二个数据结构：如何操作已经写在上面的式子里了，要维护区间修改，可以用**线段树**。

到这里，梳理一下：用**单调栈**维护**区间最值的修改**，得知修改后，在**线段树**上进行操作，线段树结点上存**区间最值**。为了更方便，线段树上可以不存区间最值，直接存 $s(\text{getmax}-\text{getmin})$。区间 $[j,j]$ 存 $s(\text{getmax}(j,i)-\text{getmin}(j,i))$。

理清了修改操作，再来看查询操作，得知最值，怎么更快转移？此时转移方程变为：

$f_i=\min(f_{j-1}+\text{query}[j,j])+k(b_i<j\leqslant i)$

不如直接把 $f_{j-1}$ 放入线段树里，线段树区间 $[j,j]$ 存 $f_{j-1}+\text{query}[j,j]$。同时放入 $b_i$ 的限制，则 $f_i=\text{query}[b_i+1,j]+k$，线段树节点存**区间最小值**。

这里有特殊情况：$b_i=i-1$，则 $f_i$ 只能为 $f_{i-1}+k$。

修改操作：每个区间再单调栈中只会进出一次，查询对于每个 $i$ 只会进行一次。

时间复杂度：$O(n\log n)$，空间复杂度：$O(n)$，可以获得 $100$ 分。

---

代码：

```cpp
#include <stdio.h>
typedef const int ci; typedef long long ll; ci _(100001);
ll f[_], t[_ << 2], c[_ << 2];
int a[_], b[_], d0[_][2] = {-1}, d1[_][2] = {_}, L[_ << 2], R[_ << 2];
#define lc p << 1
#define rc p << 1 | 1
ll min(const ll i, const ll j) { return i < j ? i : j; }
void build(ci p, ci l, ci r)
{
    if ((L[p] = l) == (R[p] = r)) return;
    ci m(l + r >> 1); build(lc, l, m); build(rc, m + 1, r);
}
void spread(ci p)
{
    if (t[p])
	{
        c[lc] += t[p]; c[rc] += t[p]; t[lc] += t[p]; t[rc] += t[p]; t[p] = 0;
	}
}
void modify(ci p, ci l, ci r, const ll v)
{
    if (l <= L[p] & R[p] <= r) { c[p] += v; t[p] += v; return; } spread(p);
    if (l < L[rc]) modify(lc, l, r, v); if (r > R[lc]) modify(rc, l, r, v);
    c[p] = min(c[lc], c[rc]);
}
ll query(ci p, ci l, ci r)
{
    if (l <= L[p] & R[p] <= r) return c[p]; ll m(1e10); spread(p);
    if (l < L[rc]) m = min(m, query(lc, l, r)); if (r > R[lc]) m = min(m, query(rc, l, r));
    return m;
}
int main()
{
    int n, m, k, s, t0(0), t1(0); scanf("%d%d%d%d", &n, &m, &k, &s);
    for (int i(1); i <= n; ++i) scanf("%d", &a[i]); build(1, 1, n);
    while (m--)
    {
        int p, q; scanf("%d%d", &p, &q);
        if (p > q) p ^= q ^= p ^= q; if (p > b[q]) b[q] = p;
    }
    for (int i(1); i <= n; ++i) if (b[i - 1] > b[i]) b[i] = b[i - 1];
    for (int i(1), p(1); i <= n; ++i, p = i)
	{
        #define e0 d0[t0]
        #define e1 d1[t1]
        while (e0[0] > a[i]) modify(1, e0[1], p - 1, (ll)s * (e0[0] - a[i])), p = e0[1], --t0;
        if (e0[0] ^ a[i]) ++t0, e0[0] = a[i], e0[1] = p;
        p = i; f[i] = f[i - 1];
        while (e1[0] < a[i]) modify(1, e1[1], p - 1, (ll)s * (a[i] - e1[0])), p = e1[1], --t1;
        if (e1[0] ^ a[i]) ++t1, e1[0] = a[i], e1[1] = p;
        if (b[i] < i - 1) f[i] = min(f[i], query(1, b[i] + 1, i - 1));
        modify(1, i, i, f[i - 1]); f[i] += k;
    }
	return !printf("%lld\n", f[n]);
}
```

---


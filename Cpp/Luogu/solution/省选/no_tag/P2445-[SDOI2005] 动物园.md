# [SDOI2005] 动物园

## 题目描述

位于郊区的动物园很早就采用了当时先进的自动化管理设施对动物进行管理。但是由于当时的系统没有考虑 $2000$ 年问题，使得管理人员十分担心。虽然采取了很多防范措施，系统还是在世纪之交出现了一些 BUG，部分动物的笼子门自动打开了，关在里面的动物都跑出来了。

幸好动物园已经关闭，**动物不会跑出动物园**。警长 Still 接到报警后率领一支干警奔赴现场。这时动物已经跑出了笼子，所以干警们花了很多时间才控制住了局势，所有的动物都己经送到动物园的广场。但是此时有一个棘手的问题，由于系统完全崩溃，无法得知动物是从哪个笼子里面跑出来的。此时，干警们记得动物的一些行动，都是如下的形式：

第 $t$ 分钟看到某某动物在某个位置。

Still 希望通过这些零碎的信息得到动物是从哪个笼子跑出来的。

### 任务

根据给出的信息，编程求出每个动物的笼子的位置。

动物园的地形描述为一个 $n\times n$ 的网格，一个格子可以是建筑物或者平地。笼子的位置只可能在平地，动物也只在平地运动。每种动物的奔跑速度不一样，例如老虎一分钟可以跑 $5$ 个格子，猫一分钟只可以跑 $2$ 个格子等等。以下是一个例子（其中阴影部分是建筑物）：

![](https://cdn.luogu.com.cn/upload/pic/1577.png)

**每个笼子只关一只动物，不同的笼子关不同的动物。不同的笼子可能在同一个格子里。**

## 说明/提示

$1\leq n,p\leq 100$，$x,y\leq n$。

注：对于特定的数据可能有多解，输出任意一解即可。

## 样例 #1

### 输入

```
5
.....
.***.
.....
.***.
.....
2
1 3
5 2
1
2
2
5 3 1 2
4 5 5 1
```

### 输出

```
1 5 2
2 1 3
```

# 题解

## 作者：revenger (赞：6)

不得不说洛谷的管理效率实在是高，一天就把spj加上了，先赞一个。

这道题目大意是给出动物的速度和某个时刻的位置，把动物和笼子配对。

首先可以看出所给出的某个时刻某动物在何处的信息中有一些是多余的。对于每个动物来说，只需要保留它被看到的时间最早的信息即可，因为如果我们知道某动物在T1时刻在(x1,y1),在T2时刻在(x2,y2)(T1<T2),且这两个信息都合法，那么我们只要知道了第一条信息，我们可以推出在T2时刻动物可能在(x2,y2)。

对于每个动物所保留下来的信息进行一次搜索，确定这个动物可能是从哪个笼子里出来的，具体方式是从这个点开始往外进行floodfill，如果到达笼子的格子数<=动物的速度\*时间，就认为这个动物可能是从这个笼子里出来的。

如果一个动物没有被观测到，那么认为它有可能是从任何一个笼子里出来的。

然后就变成了每个动物有一个对应的笼子集合，然后进行一次最大匹配。

最大匹配的算法可以采用最大流或者匈牙利算法。

题目保证有解，所以在匹配完成后输出对应方案即可。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
struct st{
    int t,x,y;
}animal[205];
const int inf=1e9+7;
#define min(a,b) (a<b?a:b)
int maps[10001],cage[10001],p,n,qu,ways[10001],v[205];
char ch[102];
int num[10001],exist[205],nums,cagenum[1001];
int head[505],nxt[80005],point[80005],remain[80005],sum;
int nowedge[505],deep[505];
int a,b,c,d;
queue<int>q;
void dfsmap(int x,int y,int d)
{
    if(x>n||x<1||y>n||y<1) return;
    if(maps[x*n-n+y]==-1) return;
    if(ways[x*n-n+y]<=d) return;
    ways[x*n-n+y]=d;
    dfsmap(x+1,y,d+1);
    dfsmap(x-1,y,d+1);
    dfsmap(x,y+1,d+1);
    dfsmap(x,y-1,d+1);
}
void divide()
{
    sum=-1;
    memset(head,-1,sizeof(head));
    memset(nxt,-1,sizeof(nxt));
    nums=p;
    for(int i=1;i<=n*n;i++)
    if(cage[i])
    num[i]=++nums,cagenum[nums]=i;
}
void add(int x,int y,int flow)
{
    ++sum;nxt[sum]=head[x];head[x]=sum;point[sum]=y;remain[sum]=flow;
    ++sum;nxt[sum]=head[y];head[y]=sum;point[sum]=x;remain[sum]=0;
}
void addall(int ani)
{
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        int now=i*n-n+j;
        if(cage[now]) add(ani,num[now],1);
    }
} 
void search(int times,int x,int y,int ani)
{
    memset(ways,127,sizeof(ways));
    dfsmap(x,y,0);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        int now=i*n-n+j;
        if(cage[now]&&ways[now]<times)
        add(ani,num[now],1);
    }
}
void setup()
{
    for(int i=1;i<=p;i++)
    add(0,i,1);
    for(int i=p+1;i<=nums;i++)
    add(i,nums+1,cage[cagenum[i]]);
}
bool bfs(int s,int t)
{
    for(int i=0;i<=nums;i++)
    nowedge[i]=head[i];
    memset(deep,127,sizeof(deep));
    deep[s]=0;
    q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();
        for(int tmp=head[now];tmp!=-1;tmp=nxt[tmp])
        {
            int u=point[tmp];
            if(remain[tmp]&&deep[u]>inf)
            {
                deep[u]=deep[now]+1;
                q.push(u);
            }
        }
    }
    return deep[t]<inf;
}
int dfs(int x,int t,int limit)
{
    if(x==t||!limit) return limit;
    int flow=0,f;
    for(int tmp=nowedge[x];tmp!=-1;tmp=nxt[tmp])
    {
        nowedge[x]=tmp;
        if((deep[point[tmp]]==deep[x]+1)&&(f=dfs(point[tmp],t,min(limit,remain[tmp]))))
        {
            flow+=f;
            limit-=f;
            remain[tmp]-=f;
            remain[tmp^1]+=f;
        }
    }
    return flow;
}
void dinic(int s,int t)
{
    while(bfs(s,t))
    dfs(s,t,inf);
}
void getans()
{
    dinic(0,nums+1);
    for(int i=1;i<=p;i++)
    {
        printf("%d ",i);
        for(int tmp=head[i];tmp!=-1;tmp=nxt[tmp])
        {
            if(point[tmp]&&(remain[tmp]==0))
            {
                int now=cagenum[point[tmp]],nowx,nowy;
                nowx=now/n;
                if(now%n==0) nowy=n;
                else nowx++,nowy=now%n;
                printf("%d %d\n",nowx,nowy);
                break;
            }
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",ch);
        for(int j=0;j<n;j++)
        if(ch[j]=='*') maps[i*n-n+j+1]=-1;    
    }
    scanf("%d",&p);
    for(int i=1;i<=p;i++)
    {
        scanf("%d%d",&a,&b);
        cage[a*n-n+b]++;
    }
    divide();
    for(int i=1;i<=p;i++)
    scanf("%d",&v[i]);
    memset(animal,127,sizeof(animal));
    scanf("%d",&qu);
    for(int i=1;i<=qu;i++)
    {
        scanf("%d%d%d%d",&a,&b,&c,&d);
        if(a>=animal[d].t) continue;
        animal[d]=(st){a,b,c};
        exist[d]=1;
    }
    for(int i=1;i<=p;i++)
    if(exist[i]) 
    search(animal[i].t*v[i],animal[i].x,animal[i].y,i);
    else
    addall(i);
    setup();
    getans(); 
}
```

---

## 作者：Dispwnl (赞：2)

第一眼看到这题的思路是$bfs+dfs$

$bfs$建立动物与笼子的关系

$dfs$进行一一匹配

用$well$保存这个点的状态（是否可走，是否有笼子，有几个笼子）

注意笼子可以在同一地点

如果一个动物没有被观测到，那么它可能是从任何一个笼子里出来的

每个动物都$bfs$遍历一遍

用f数组保存它是否可以到达这个点上的笼子

限制距离为观测时间$\times$速度

建立好关系后，就可以搜索了

搜到一组解就输出并结束程序

```cpp
# include<iostream>
# include<cstdio>
# include<cstdlib>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fo1(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
struct q{
    int row,col;
}cage[101];
struct u{
    int t,rr,cc,j;
}see[101];
int n,p,r,num;
int animal[101],ans[101];
int mv1[4]={1,-1,0,0},mv2[4]={0,0,1,-1};
int nu[101][101];
int well[101][101][2][3],room[100001][4];
bool use[101],ff[101];
bool f[101][101];
bool vis[101][101][101];
int read()
{
    char c=getchar();
    int x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') 
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}
void init()
{
    n=read();
    fo(i,1,n)
      {
          string ch;
          cin>>ch;
          fo(j,1,n)
          well[i][j][0][0]=(ch[j-1]=='*')?1:0;
      }
    p=read();
    fo(i,1,p)
      {
          cage[i].row=read();
        cage[i].col=read();
          well[cage[i].row][cage[i].col][1][++nu[cage[i].row][cage[i].col]]=i,well[cage[i].row][cage[i].col][0][0]=2;
        }
    fo(i,1,p)
     animal[i]=read();
    r=read();
    fo(i,1,r)
      {
          num++;
          see[num].t=read();
        see[num].rr=read();
        see[num].cc=read();
        see[num].j=read();
          if(ff[see[num].j]) num--;
          else ff[see[num].j]=1;
      }
}
void coutt()
{
    fo(i,1,p)
      printf("%d %d %d\n",i,cage[ans[i]].row,cage[ans[i]].col);
}
void find_home(int x)
{
    if(x>p)
    {
        coutt();
        exit(0);
    }
    fo1(j,p,1)
      if(f[x][j]&&!use[j])
      {
          ans[x]=j;
          use[j]=1;
          find_home(x+1);
          use[j]=0;
      }  
}
void bfs()
{
    fo(i,1,p)
      if(!ff[i])
      {
          for(int j=1;j<=p;j++)
            f[i][j]=1;
      }
    fo(i,1,num)
      {
          room[1][1]=see[i].rr;
          room[1][2]=see[i].cc;
          int l=0,rr=1,houhou=animal[see[i].j]*see[i].t;
          while(l<rr)
          {
              l++;
              if(room[l][3]>=houhou)
              continue;
              fo(j,0,3)
                {
                    int x=room[l][1]+mv1[j],y=room[l][2]+mv2[j];
                    if(x>=1&&x<=n&&y>=1&&y<=n&&!vis[see[i].j][x][y]&&well[x][y][0][0]!=1)
                    {
                        vis[see[i].j][x][y]=1;
                        room[++rr][1]=x;
                        room[rr][2]=y;
                        room[rr][3]=room[l][3]+1;
                        if(well[x][y][0][0]==2)
                        fo(kk,1,nu[x][y])
                          f[see[i].j][well[x][y][1][kk]]=1;
                }
              }
        }
      }
    find_home(1);
}
int main()
{
    init();
    bfs();
    return 0;
}
```

---


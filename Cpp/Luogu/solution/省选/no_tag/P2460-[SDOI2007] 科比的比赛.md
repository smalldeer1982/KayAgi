# [SDOI2007] 科比的比赛

## 题目描述

NBA球星云集，谁是最厉害的呢？没有定论。

Nba总裁大卫\*斯特恩最近闲得无聊，决定举办一场球员单挑大赛。

比赛是这样的:首先，我们给每人都打上个分数，表示了每个人的整体能力。然后让每个参赛队员都打n场比赛，首先看谁赢得最多，然后看谁打赢的人的能力值的和最大。

本人一向支持科比(我不支持),当然希望他赢。现在让我们和科比一起去赢得这场比赛吧！！

(科比照片一张)

假设总共比赛有m+1个人参加，告诉你科比和另外m个人的比赛的胜利可能性，你的任务就是求出在科比赢了的所有比赛的可能性最大的前提下(误差不超过1e-10)，科必打赢的人的最大能力值的和是多少？当然当一个人被你打败，他就不会再参加比赛了。

这里需要注意的是，科比能打赢其他人的可能性在不同场次是不同的。比如在比赛前期科比的手感不太好，对抗在内线称霸的人因为无法发挥外线的实力，而难以得分(接奥尼儿图一张)

中期时别人手感变好，状态起来，有实力的人会给科比制造很大的麻烦(接韦德图一张)

后期时消耗太多体力，对自己的命中率下降，难以发挥正常水平，所以对抗体力好的球员时占劣势(后接纳什图一张)

现在给你每场比赛科比对每个参赛者的获胜可能性，和每个人的能力值，帮助科比赢得比赛吧。


## 样例 #1

### 输入

```
3 4
91 92 93 94
0.5 0.5 0.5 0.5
0.5 0.5 0.5 0.5
0.5 0.5 0.5 0.5```

### 输出

```
0.125
279```

# 题解

## 作者：eternal风度 (赞：15)

## 贪心+搜索

### ~~也可以贪心+网络流+状压dp~~

这道题其实真的不是很难的

为什么一直没有人做（~~其实我也是看到**科比**才进来的。。。~~）

照例，想打一波广告：[**eternal风度的博客**](http://www.cnblogs.com/cjoierljl) ~~**欢迎来踩**~~

同步发表于：[科比的比赛(题解)(贪心+搜索)](https://www.cnblogs.com/cjoierljl/p/9745811.html)

## 入正题吧

### 思路一：贪心

爆搜肯定过不了对吧

看一下题目，发现这个$m$~~好大八大~~

再仔细看一下题目，发现$n$给的很舒服啊

于是有一个大胆的想法：**复杂度和$n$有关，和$m$无关**

怎么说呢：我们可以发现我们再怎么打，一场里面最多有9个球员之前打过对吧，也就是说，如果我们把每一场的球员按照胜率排序，那么和答案有关的最多就只有10个人对吧

所以我们考虑对每一场按照胜率把球员排序（能力值为第二关键字），一下子省去好多。。。

### 思路二：不用讲了吧

贪心都干了这么多活了，你搜索随便剪一下枝不就过了

嗯，算半个$A^*$吗

把每场比赛以后能打出的最大胜率预处理出来

把每场比赛以后能打到的最大能力值预处理出来

~~剪剪剪~~

没了

### 思路三：更优秀的方法？

我觉得可行：

> 第一问你跑一个~~最大~~费用流

> 第二问你跑一个状压dp？~~Maybe~~


应该比搜索要快吧（~~如果你想跑快点~~，反正我没打）

### 关于精度

题目里说是$1e-10$的精度保障就$ojbk$

然而，经过惨痛的试数据后发现要保留到小数点后12位

不然不是``too short``就是``too long``。。。

## 代码

我就放一个搜索+贪心的方法吧。。。

如果还不懂的讨论区问吧。。。

或者私信我。。。（讨论区@不了看不到。。。）

```
#include<bits/stdc++.h>
#define il inline
#define rgt register int
#define lst long long
#define ldb double
#define N 15
#define M 100050
using namespace std;
const int Inf=1e9;
const ldb eps=1e-10;
il int read()
{
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch))s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}

int n,m;
int val[M],nn[N];
int Nn[N],Ans_ss;
ldb Gl[N],Ans_gl;
bool vis[M];
struct PLAY{int id;ldb mb;}peo[M],ljl[N][N];
int Calc(ldb x,ldb y)
{
	if(abs(x-y)<=eps)return 2;
	else return x>y;
}

bool cmp(const PLAY &a,const PLAY &b)
{
	if(Calc(a.mb,b.mb)==2)
		return val[a.id]>val[b.id];
	return a.mb>b.mb;
}

void Dfs(int now,ldb gl,int ss)//rival
{
	if(now==n+1)
	{
		if(Calc(gl,Ans_gl)>0)
			Ans_gl=gl,Ans_ss=max(Ans_ss,ss);
		return;
	}
	if(Calc(gl*Gl[now],Ans_gl)==0)return;
	if(Calc(gl*Gl[now],Ans_gl)==2&&ss+Nn[now]<=Ans_ss)return;
	for(int i=1;i<=n;++i)
	{
		if(vis[ljl[now][i].id])continue;
		vis[ljl[now][i].id]=true;
		Dfs(now+1,gl*ljl[now][i].mb,ss+val[ljl[now][i].id]);
		vis[ljl[now][i].id]=false;
	}
}

int main()
{
	freopen("s.in","r",stdin);
	n=read(),m=read();
	for(int i=1;i<=m;++i)val[i]=read();
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
			peo[j].id=j,scanf("%lf",&peo[j].mb);
		sort(peo+1,peo+m+1,cmp);
		for(int j=1;j<=n;++j)
			ljl[i][j]=peo[j],nn[i]=max(nn[i],val[peo[j].id]);
	}Gl[n]=ljl[n][1].mb;
	for(int i=n-1;i>=1;--i)
	{
		Gl[i]=Gl[i+1]*ljl[i][1].mb;
		Nn[i]=Nn[i+1]+nn[i];
	}Dfs(1,1,0);
	printf("%.12lf\n%d\n",Ans_gl,Ans_ss);
	return 0;
}

```

---

## 作者：smydahaoren (赞：14)

思路分析
------------

这道题大概题意是给定我们的主人公 ```Kobe Bryant``` 的 $m$ 个对手，$n$ 场比赛相对应的获胜概率。求 ```Kobe Bryant``` 最大全部获胜概率和打败对手能力值之和。

这道题可以使用 ```dfs``` 的思路解决。但是 ```Kobe Bryant``` 的对手非常多（也就是 $m$ 的值非常大），直接搜索的时间复杂度肯定非常高，就需要一些有效的剪枝。

最容易想到的是最优性剪枝，也就是如果当目前答案已经不优于已经存在的答案就可以直接放弃这个答案。

具体来说就是在 ```dfs``` 函数中加入：

```
if(cmp_double(tmp1,ans1)==0) return;
```

但是这样的优化显然是明显不够的。

这个题目有一个写的很明显特性是 $n\le m$。由于 $n$ 的值很小，而 ```Kobe Bryant``` 在每场比赛只能对战一个对手，所以 ```Kobe Bryant``` 只需要对战 $n$ 个对手并不是 $m$ 个。翻译成白话文就是  ```Kobe Bryant``` 可以只找弱的打，也就是找成功概率高的打。根据这个特性，我们可以在搜索时只搜前 $n$ 弱的对手。也可以理解这个剪枝是贪心的思路，因此 ```Kobe Bryant``` 的对手就少了很多。再根据前一条剪枝可以拿到 $40$ 分。

最后考虑到的是可以使用启发式搜索剪枝优化，对当前的结果进行估计，也就是即使是当前状态的最优情况，目前 ```Kobe Bryant``` 的获胜概率仍然没有已有最优情况高的时候舍弃。为了保证估计的效率，可以使用预处理的方式让每次询问复杂度降到 $O(n)$。

进行以上三次优化的思路是已经可以通过本题了。


代码
------------


```
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define antirep(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int N=1e6,M=1e3;
const double err=1e-10;
bool vst[N];
double ans1,pr[N],Gl[N];
int n,m,a[N],ans2;
struct node{int id;double p;}k[M][M];
int cmp_double(double x,double y){
	if(abs(x-y)<err) return 2;
	if(x-y>err) return 1;
	if(x-y<err) return 0;
	return 0x7fffffff;
}
bool cmp(node x,node y){
	if(cmp_double(x.p,y.p)==2) return a[x.id]>a[y.id];
	return x.p>y.p;
}
int f(int cur,double tmp1){
	return cmp_double(tmp1*pr[cur],ans1);
}
void prepare(){
	pr[n]=k[n][1].p;
	antirep(i,n-1,1)
		pr[i]=pr[i+1]*k[i][1].p;
}
void dfs(int cur,double tmp1,int tmp2){
	if(cur>n){
		if(cmp_double(tmp1,ans1)==1||cmp_double(tmp1,ans1)==2){
			ans1=tmp1;
			if(tmp2>ans2) ans2=tmp2;
		}
		return;
	}
	if(cmp_double(tmp1,ans1)==0) return;
	if(f(cur,tmp1)==0)return;
	rep(i,1,n){
		int ID=k[cur][i].id;
		if(vst[ID]==1) continue;
		vst[ID]=1;
		tmp1*=k[cur][i].p,tmp2+=a[ID];
		dfs(cur+1,tmp1,tmp2);
		tmp1/=k[cur][i].p,tmp2-=a[ID],vst[ID]=0;
	}
	return;
}
signed main(){
	cin>>n>>m;
	rep(i,1,m) cin>>a[i];
	rep(i,1,n){
		rep(j,1,m)
			cin>>k[i][j].p,k[i][j].id=j;
		sort(k[i]+1,k[i]+1+m,cmp);
	}
	prepare();
	dfs(1,1,0);
	cout<<fixed<<setprecision(12)<<ans1<<endl;
	cout<<ans2<<endl;
	return 0;
}


```

这里对代码进行一些解释，因为本题是浮点数操作，浮点数会在精度很高的时候产生误差，因此这里使用了 ```cmp_double``` 函数进行比较浮点数大小。

预处理之所以是逆序的储存是因为正序的搜索每次询问的都是剩余比赛的最有情况。

排序可以保证把 ```Kobe Bryant``` 最弱（也就是获胜概率最高）的对手放在每场比赛的最前面。


后记
------------
备注：```Kobe Bryant``` 是本题主人公科比的原名。而在 $2020$ 年，科比本人乘坐的西科斯基 $S-76$ 直升机在美国加利福尼亚州洛杉矶县卡拉巴萨斯市坠毁。年仅 $41$ 岁。

虽然我们不能跟题目重所描述的那样帮助科比赢得比赛,但是我们可以通过解出这道题淡化对科比离去的哀伤。

~~牢大，我想你了。~~

---

## 作者：KobeBeanBryantCox (赞：8)

# P2460 [SDOI2007] 科比的比赛 题解

---------------------

[题目传送门](https://www.luogu.com.cn/problem/P2460)。

~~感觉题目有那么一点点的黑科比的意思。。。~~

思路：贪心+搜索。

56 行清新可爱代码，删快读快输后 42 行。

该说不说，水紫一道，建议评绿。

--------------------

## 题意

形式化题面不好描述，所以去看原题描述吧。

--------------------

## 思路

首先，$n$ 很小，考虑搜索。

然后根据贪心策略，每一轮优先选择概率大的，同概率的选能力大的，这样就可以剪枝了。

具体剪枝方法就是，在每一轮都判断一下，如果乘上后面最大的概率，都劣于当前记录的最优答案，是则直接返回。

这里用后缀积与后缀和维护一下就好了。

然后就能过了，时间复杂度 $O(\footnotesize\texttt{能过}\normalsize)$。~~（众所周知带剪枝的搜索的时间复杂度都不好分析）~~

具体见代码，带注释。

------------------

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
typedef long double ld; // 为避免精度问题，开 long double
#define int long long
int in() // 快输
{
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x) // 快读
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=20,M=1e5+10;
int ability[M]; // 能力值
struct line // 每一行定义一个结构体
{
	int id;ld win; // 第几个人；赢的概率
	bool operator<(const line a)const{return win>a.win||(win==a.win&&ability[id]>ability[a.id]);} // 自定义比较规则
};
vector<line>inning[N];int n,m;
int maxa[N];ld maxp[N]; // 后缀能力值和，后缀概率积
bool vis[M]; // 当前人选过没有
ld ansp;int ans; // 当前最优答案
void dfs(int i,ld p,int sum)
{
	if(i==n+1){if(p>ansp||(p==ansp&&sum>ans))ansp=p,ans=sum;return;} // 记录答案
	if(p*maxp[i]<ansp||(p*maxp[i]==ansp&&sum+maxa[i]<=ans))return; // 比当前记录的最优的还要劣
	for(auto [id,winp]:inning[i])if(!vis[id])vis[id]=true,dfs(i+1,p*winp,sum+ability[id]),vis[id]=false;
}
signed main()
{
	n=in(),m=in(),maxp[n+1]=1;
	for(int i=1;i<=m;i++)ability[i]=in();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			ld p;scanf("%Lf",&p);
			inning[i].push_back((line){j,p});
		}
		sort(inning[i].begin(),inning[i].end()); // 按概率排序，能力值为第二关键字
	}
	for(int i=n;i>=1;i--)maxa[i]=maxa[i+1]+ability[inning[i][0].id],maxp[i]=maxp[i+1]*inning[i][0].win; // 后缀和，后缀积
	dfs(1,1,0);
	printf("%.12Lf\n",ansp),out(ans); // 输出答案
	return 0;
}
```

------------------------

## 后记

致敬伟大的已故篮球运动员 Kobe Bean Bryant Cox，一个由后天努力锻造出的天生杀手黑曼巴。

紫金飞侠成绝响，世间再无黑曼巴！

![](https://cdn.luogu.com.cn/upload/image_hosting/dnqixgxc.png)

---

## 作者：Jadonyzx (赞：5)

**紫金飞侠成绝响，世间再无黑曼巴!**

150 紫题祭。

观察到 $n$ 范围极小，~~暴力肘就可以 AC。~~

暴力肘也是需要技巧的。

每个球员按概率为第一关键字，能力值为第二关键字排序。

如果怎么肘都不可能更新答案，就直接剪枝。

最 man 的点跑得也飞快，肘飞了好吧。

code：


```cpp
#include<bits/stdc++.h>
#define maxn 
#define int long long
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
inline void write(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>=10)write(x/10);
    putchar(x%10+'0');return;
}
double ansGl,ManBa[21];
int ansManBa,n,m,helicopter[100001],elbow;bool vis[100001];
struct laoda{int val,uid;double gl;}Coby[21][100001];
inline bool cmp(laoda coby,laoda manba){
    if(fabs(coby.gl-manba.gl)<=1e-18)return coby.val<manba.val;
    return coby.gl<manba.gl;
}
void dfs(int now,double nowgl,int nowBryant){
    if(nowgl*ManBa[now]<ansGl)return;
    if(fabs(nowgl*ManBa[now]-ansGl)<=1e-18&&(nowBryant+elbow*(n-now+1)<=ansManBa))return;
    if(now==n+1){
        if(ansGl<nowgl){
            ansManBa=nowBryant;
            ansGl=nowgl;
        }
        else if(fabs(nowgl-ansGl)<=1e-18)ansManBa=max(ansManBa,nowBryant);
        return;
    }
    for(int i=1;i<=m;++i){
        if(vis[Coby[now][i].uid])continue;
        vis[Coby[now][i].uid]=1;
        dfs(now+1,nowgl*Coby[now][i].gl,nowBryant+Coby[now][i].val);
        vis[Coby[now][i].uid]=0;
    }
    return;
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>m;ManBa[n+1]=1;
    for(int i=1;i<=m;++i)cin>>Coby[1][i].val,elbow=max(elbow,Coby[1][i].val);
    for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)cin>>Coby[i][j].gl;
    for(int i=2;i<=n;++i)for(int j=1;j<=m;++j)Coby[i][j].val=Coby[1][j].val;
    for(int i=n;i>=1;--i){
        double maxx=0;
        for(int j=1;j<=m;++j)maxx=max(maxx,Coby[i][j].gl);
        ManBa[i]=ManBa[i+1]*maxx;
    }
    for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)Coby[i][j].uid=j;
    for(int i=1;i<=n;++i)sort(Coby[i]+1,Coby[i]+1+m,cmp),reverse(Coby[i]+1,Coby[i]+1+m);
    dfs(1,1,0);
    cout<<fixed<<setprecision(12)<<ansGl<<"\n";
    cout<<ansManBa;
    return 0;
}
```

---

## 作者：LG086 (赞：4)

牢大要和 $m$ 个人打 $n$ 场单挑赛。而你作为一个练习时长两年半的个人练习生，需要帮牢大计算他的最大胜率以及在此条件下遇到的对手的最大能力值和。

注意到 $1\le m \le 10^5$ 但是 $1\le n\le 10$，所以直接暴力 dfs。


我们利用一个结构体记录每场比赛中每个球员的数值，即牢大与其对抗的胜率 $v$，该球员的能力 $s$ 和这个人的编号 $id$。  
得到如下结构体：

```cpp
struct manba{
 db v;
 int s,id;
}a[24][114514];
```

接下来就是 dfs 部分了。我们需要记录当前比赛轮数 $i$，当前胜率 $v$ 以及当前能力和 $now$。每一轮比赛从第 $1$ 枚举到第 $m$ 个人，如果这个人没打过比赛就 dfs 下去。回溯求解答案。我们很快会得到这样一个 dfs 的代码：

```cpp
void man(int i,int now,db v){
 if(i==n+1){
  if(ans1<v)ans1=v,ans2=now;
  if(ans1==v)ans2=max(ans2,now);
  return;
 }
 for(int _(1);_<=m;_++)if(!vis[a[i][_].id])
  vis[a[i][_].id]=1,
  man(i+1,now+a[i][_].s,v*a[i][_].v),
  vis[a[i][_].id]=0;
 return;
}
```

于是我们快乐地超时了。

牢大很生气，要把你肘成螺旋桨。那怎么办？剪枝一下就好了。

首先，我们对结构体数组排序。排序标准就是胜率越大越靠前，同时能力越强越靠前。于是有了这么个函数：

```cpp
bool LaoDa(manba a,manba b){
 if(fabs(a.v-b.v)<=eps)return a.s>b.s;
 return a.v>b.v;
}
```

其中 $eps$ 是防止出现精度问题的。

记 $maxs$ 为最大能力值，$maxv_i$ 是从第 $n$ 场比赛到第 $i$ 场比赛之间的每场比赛的最大胜率的乘积，也就是最大胜率的后缀积。

如果此时的 $v \times maxv_i < ans_1$，说明即使在这之后每场比赛都与 $v$ 最大的敌人对抗胜率都不如当前最优，直接返回就行了。如果 $v \times maxv_i$ 和 $ans_1$ 之间的差值的绝对值小于 $eps$，即两个数值基本相等，则判断 $now+maxs\times (n-i+1)$ 与 $ans_2$ 的大小关系。如果 $now+maxs\times (n-i+1) \le ans_2$，表示即使在这之后每场比赛都与 $s$ 最大的敌人对抗，能力值总和都不如当前最优，也是直接返回就行了。

在剪枝之后，得到全新的 dfs 代码：

```cpp
void man(int i,int now,db v){
 if(i==n+1){
  if(ans1<v)ans1=v,ans2=now;
  if(ans1==v)ans2=max(ans2,now);
  return;
 }
 if(v*maxv[i]<ans1)return;
 if(fabs(v*maxv[i]-ans1)<=eps and now+maxs*(n-i+1)<=ans2)return;
 for(int _(1);_<=m;_++)if(!vis[a[i][_].id])
  vis[a[i][_].id]=1,
  man(i+1,now+a[i][_].s,v*a[i][_].v),
  vis[a[i][_].id]=0;
 return;
}
```

时间复杂度玄学。能过。  
牢大很开心，去打比赛了。恭喜你没有被牢大肘成螺旋桨。

下面给出主函数部分。

```cpp
int main(){
 ios_base::sync_with_stdio(0);
 cin.tie(0);cout.tie(0);
 cin>>n>>m;
 for(int _(-1);_>=-m;_--)cin>>s[-_],maxs=max(maxs,s[-_]);//最大能力值
 for(int i(1);i<=n;i++)
 {
  db max_v=0.;
  for(int j(1);j<=m;j++)
  {
   db v;cin>>v,max_v=max(max_v,v);
   a[i][j]={v,s[j],j};
  }
  maxv[i]=max_v;
 }
 for(int i(n-1);i>=1;i--)maxv[i]*=maxv[i+1];//后缀积
 for(int i(1);i<=n;i++)stable_sort(a[i]+1,a[i]+1+m,LaoDa);//排序
 man(1,0,1.);//搜索
 printf("%.12lf\n%lld",ans1,ans2);
 return 0;//结束
 puts("It's been a long day without you my friend");
 puts("And I'll tell you all about it when I see you again");
}
```

---

## 作者：Limitless_lmw (赞：3)

看到我们伟大的 wjb 来切了这道题，于是过来看了一下。

先对每一场比赛都从大到小排序，这样子搜索的过程中**在不重复选择同一人的情况下优先选择最大的**就可以直接遍历找了。

直接搜索显然是会炸的，我们做几个剪枝就好了。

第一个剪枝老生常谈，如果当前的概率已经比目前的全局最优还要小了，直接退出 dfs。

第二个剪枝也比较好想，当前的概率乘以后面每场比赛最大的概率如果小于当前全局最优，同样退出 dfs（注意到第一个剪枝和第二个剪枝可以合并）。

代码就不放了，建议评绿。

---

## 作者：bluewindde (赞：1)

题意：给定 $n \times m$ 的矩阵 $A = (a_{ij})$ 和长为 $m$ 的数列，矩阵的元素在 $[0, 1]$ 上。在矩阵每一行选择一个数，最大化选中的数的乘积的前提下最大化得分，但矩阵每一列至多选择一个数。求最大乘积和对应的最大得分。

考虑状压 DP，设 $dp_{i, j}$ 表示已经处理前 $i$ 列，状态集合为 $j$ 的行已经选定时的最大乘积。

转移

$$dp_{i, j} = \sum\limits_{k \in j} dp_{i - 1, j - \{k\}} \cdot a_{i, k}$$

边界

$$dp_{i, 0} = 1$$

答案

$$dp_{m, U}$$

其中 $U$ 是全集。

最大得分容易与乘积同时转移。

时间复杂度 $O(nm 2^n)$，滚动数组优化空间后可以通过 $50$ 分。

考虑贪心，将矩阵每一行按 $a_{i, j}$ 为第一关键字，$s_j$ 为第二关键字降序排序，至多选择前 $n$ 大的位置。

所以排序后将每一行可能被选的位置提出来做一次 DP，至多有 $O(n^2)$ 个可能被选的位置，时间复杂度优化为 $O(nm \log m + n^3 \log n + n^3 2^n)$，可以通过。

```cpp
#include <algorithm>
#include <iomanip>
#include <iostream>

using namespace std;

typedef long double ld;

const ld eps = 1e-10;

int n, m;
int w[100005];
int s[100005];

ld a[12][100005];
int b[12][100005];
int id[100005], len;
ld c[12][100005];

ld dp[2][1050];
int f[2][1050];

static inline void solve() {
    cin >> n >> m;
    int lim = 1 << n;
    for (int i = 1; i <= m; ++i)
        cin >> w[i];
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> a[i][j];
            b[i][j] = j;
        }
        sort(b[i] + 1, b[i] + m + 1,
             [i](const int x, const int y) {
                 return (abs(a[i][x] - a[i][y]) < eps)
                            ? (w[x] > w[y])
                            : (a[i][x] - a[i][y] > eps);
             });
        for (int j = 1; j <= n && j <= m; ++j)
            id[++len] = b[i][j];
    }
    sort(id + 1, id + len + 1);
    len = (int)(unique(id + 1, id + len + 1) - id - 1);
    for (int i = 1; i <= len; ++i) {
        for (int j = 1; j <= n; ++j)
            c[j][i] = a[j][id[i]];
        s[i] = w[id[i]];
    }
    dp[0][0] = 1;
    for (int i = 1; i <= len; ++i) {
        for (int j = 0; j < lim; ++j) {
            dp[i & 1][j] = dp[(i + 1) & 1][j];
            f[i & 1][j] = f[(i + 1) & 1][j];
            for (int k = 1; k <= n; ++k) {
                if (j & (1 << (k - 1))) {
                    ld val = dp[(i + 1) & 1][j ^ (1 << (k - 1))] * c[k][i];
                    if (val < eps)
                        continue;
                    if (val - dp[i & 1][j] > eps) {
                        dp[i & 1][j] = val;
                        f[i & 1][j] = f[(i + 1) & 1][j ^ (1 << (k - 1))] + s[i];
                    } else if (abs(val - dp[i & 1][j]) < eps)
                        f[i & 1][j] = max(f[i & 1][j], f[(i + 1) & 1][j ^ (1 << (k - 1))] + s[i]);
                }
            }
        }
    }
    cout << fixed << setprecision(12) << dp[len & 1][lim - 1] << endl;
    cout << f[len & 1][lim - 1] << endl;
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("P2460.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

---

## 作者：MaLX (赞：0)

# 纯费用流写法

### 思路

首先处理出最大可能性，用费用流解决二分图最大匹配。

调整匹配顺序，按分数从大到小匹配。

算法保证了每次匹配不会将之前匹配成功的重新拆开。

所以最终匹配的分数一定是最大的。

### 优化
~~**以上思路要运行一年。**~~

我们考虑优化：

首先我们先将哪个人会被选上处理出来

乘的费用流容易出错（我是没写对），我们取数的 log 值，再取相反数，就是普通的费用流了

### 代码

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#include<vector>
#include<queue>
const int ni=2e5;
struct node{int e,f;double w;};
struct mode{double w;int i;};
bool operator<(mode a,mode b);
node it[ni*10];int idx;
vector<int>touch[ni];
vector<mode>qi;
queue<int>q;double res,ans,flo;
void add(int a,int b,int c,double d);
void solve();int n,m,si,ti;
int main(){solve();return 0;}
int spfa(),fr[ni];void ek();
int st[ni];double dist[ni],ai[ni];
void solve(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		double a;scanf("%lf",&a);
		qi.push_back({a,i});ai[i]=a;
	}
	sort(qi.begin(),qi.end());//按分数从大到小匹配
	ti=n+m+1;while(qi.size())
	add(si,qi.back().i,1,0),qi.pop_back();
	touch[ti]=touch[si];touch[si].clear();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			double a;scanf("%lf",&a);
			double b=log2(a);//取log
			qi.push_back({b,j});
		}
		sort(qi.begin(),qi.end());
		for(int j=1;j<=n;j++)
		add(qi.back().i,i+m,1,-qi.back().w),qi.pop_back();//找可能被选上的人
		while(qi.size()&&qi.back().w==it[idx-1].w)
		add(qi.back().i,i+m,1,-qi.back().w),qi.pop_back();//重复的得算上
		while(qi.size())qi.pop_back();//其余的扔掉
	}
	for(int i:touch[ti])if(touch[it[i].e].size()!=0)
	touch[0].push_back(i);touch[ti].clear();//用不上的扔掉
	for(int i=1;i<=n;i++)add(i+m,ti,1,0);ek();
	for(int i:touch[si])if(it[i].f==0)ans+=ai[it[i].e];
	printf("%0.12lf\n%0.0lf\n",pow(2,-flo),ans);//记得还原
}
/*以下全部是模板（注意开double）*/
int spfa(){
	fill(dist+1,dist+ti+1,1e9);
	q.push(si);while(q.size()){
		int t=q.front();q.pop();st[t]=0;
		for(int i:touch[t]){
			int j=it[i].e,f=it[i].f;
			double w=it[i].w;
			if(f==0)continue;
			if(dist[j]>dist[t]+w){
				dist[j]=dist[t]+w;fr[j]=i;
				if(!st[j])st[j]=1,q.push(j);
			}
		}
	}
	return dist[ti]!=1e9;
}
void ek(){
	while(spfa()){
		flo+=dist[ti];res+=1;
		for(int i=ti;i!=si;i=it[fr[i]^1].e)
		it[fr[i]].f-=1,it[fr[i]^1].f+=1;
	}
}
void add(int a,int b,int c,double d){
	it[idx++]={b,c,d};
	it[idx++]={a,0,-d};
	touch[a].push_back(idx-2);
	touch[b].push_back(idx-1);
}
bool operator<(mode a,mode b)
{return a.w<b.w;}
```

---


# [SDOI2012] 体育课

## 题目背景

# 警告：滥用本题评测将被封号

## 题目描述

又是一节体育课的时间了，有 $n$ 个同学排成了一排。他们都很讨厌排在第一个位置的同学，于是后面的同学中比第一个高的都会产生一个高兴值，这个高兴值等于他的身高减去第一个同学的身高。当然比第一个同学矮的同学产生高兴值为 $0$。

现在体育老师来了，他拥有神奇的魔法，现在他能做如下的三件事：

1. 询问某段区间高兴值最大的那个是多少。

2. 把某两个同学交换一下位置。

3. 选取一段区间的人，把第一个人身高加上 $t$，第二个加上 $2t$，第三个加上 $3t$ 以此类推。

但是体育老师不会数数，于是他找到你了，对于每一个询问，他要你帮他求出那个值。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $1 \le n,m \le 5 \times 10^3$。
- 另有 $10\%$ 的数据，没有第三种操作。
- 另有 $20\%$ 的数据，没有第二种操作。
- 对于 $100\%$ 的数据，$1 \le n,m \le 10^5$，$0 \le t \le 10^4$，$1 \leq a_i \leq 10^8$。

## 样例 #1

### 输入

```
6 7
109 827 100 530 10 826
3 1 6 1
2 2 6
1 2 4
1 2 3
2 2 6
1 2 6
1 2 5```

### 输出

```
722
722
722
719```

# 题解

## 作者：x_faraway_x (赞：12)

### 1. 题目大意

给定一个长度为 $n$ 的数列 $a_1,a_2,a_3,...,a_n$ , 并给出 $m$ 个操作，操作类型如下：

操作1：查询区间最大值，输出最大值与 $a_1$ 的差；

操作2：交换两个数的位置；

操作3：选择一段区间 $[l,r]$ 并给定 $t$ ，将区间中第 $x$ 个数加上 $x\cdot t $ .

$n,m \le 10^5$ .

### 2. 解题报告

本题的正解是分块。

首先我们先考虑操作3，对于两边的元素，我们直接暴力修改然后重构即可。那么我们如何维护整块呢？

维护 $add[ x ]$ 表示第 $x$ 块累加的 $t$ , 那我们要得到单个元素，再维护一个偏移量 $del[x]$ ，这样块中元素的权值即可表示为 $w[i]=a[i]+add[x]\times i-del[x]$. 

（举个例子，若给块 $[4,6]$ 加上 $2T, 3T, 4T$ ，那么$add[x]=T$ ，$del[x]=2T$，这样 $w[5]=a[5]+5T-2T=a[5]+3T$ .）

对于操作2，我们直接暴力交换然后重构块即可。

对于操作1，我们考虑在整块被修改后，如何维护块内的最大值。由于每个元素的编号 $i$ 和权值 $a_i$ 都是定值且 $i$ 单增，我们可以将每个元素看成 $(i,a_i)$ ，然后用单调栈维护一个上凸壳。这样随着 $add$ 的增大，最大元素位置一定向右移动，且元素权值呈单峰。

每个操作维护（询问）的复杂度都为 $O( n\sqrt{n} )$，再加上本题时间限制宽松，可以轻松通过。

### 3. 参考程序

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace io {
	const int SIZE=(1<<21)+1;
	char ibuf[SIZE],*iS,*iT;
	char gc()
	{
		if(iS==iT) iT=(iS=ibuf)+fread(ibuf,1,SIZE,stdin);
		if(iS==iT) return EOF;
		return *iS++;
	}
	inline int gi()
	{
		char c; int x=0,f=1;
		for(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=gc())x=(x<<1)+(x<<3)+c-'0';
		return x*f;
	}
}
using io::gi;
const int N=100005,qN=320;
int n,m,bel[N],b,s[qN][qN],tp[qN],pos[qN];
ll h[N],a[N],add[qN],del[qN];
#define top s[x][tp[x]]
#define dtp s[x][tp[x]-1]
#define Max(x) s[x][pos[x]]
void remove(int x)
{
	for(int i=(x-1)*b+1;i<=x*b;i++) a[i]+=add[x]*i-del[x];
	add[x]=del[x]=pos[x]=tp[x]=0;
}
void build(int x)
{
	memset(s[x],0,sizeof(s[x]));
	for(int i=(x-1)*b+1;i<=x*b;i++)
	{
		while(tp[x]>1&&(a[i]-a[top])*(top-dtp)>=(a[top]-a[dtp])*(i-top))--tp[x];
		s[x][++tp[x]]=i;
	}
	for(pos[x]=1;pos[x]<=tp[x]&&a[s[x][pos[x]+1]]>=a[s[x][pos[x]]];pos[x]++);
}
void update(int x)
{
	for(;pos[x]<=tp[x];pos[x]++)
		if(a[s[x][pos[x]+1]]+add[x]*s[x][pos[x]+1]<a[s[x][pos[x]]]+add[x]*s[x][pos[x]])
			break;
}
int main()
{
	n=gi(),m=gi();
	b=sqrt(n);
	for(int i=1;i<=n;i++) bel[i]=(i-1)/b+1,a[i]=gi();
	for(int i=1;i<=bel[n];i++) build(i);
	while(m--)
	{
		int op=gi(),l=gi(),r=gi();
		if(op==1)
		{
			ll k=a[1]+add[1]-del[1];
			ll mx=k;
			for(;bel[l]==bel[l-1]&&l<=r;l++)
				mx=max(mx,a[l]+add[bel[l]]*l-del[bel[l]]);
			for(;l+b<=r;l+=b)
				mx=max(mx,a[Max(bel[l])]+add[bel[l]]*Max(bel[l])-del[bel[l]]);
			for(;l<=r;l++)
				mx=max(mx,a[l]+add[bel[l]]*l-del[bel[l]]);
			printf("%lld\n",mx-k);
		}
		if(op==2)
		{
			remove(bel[l]),remove(bel[r]);
			swap(a[l],a[r]);
			build(bel[l]); build(bel[r]);
		}
		if(op==3)
		{
			int t=gi(),tl=l;
			for(;bel[l]==bel[l-1]&&l<=r;l++) a[l]+=(l-tl+1)*t;
			remove(bel[l-1]); build(bel[l-1]);
			for(;l+b<=r;l+=b) add[bel[l]]+=t,del[bel[l]]+=(tl-1)*t,update(bel[l]);
			for(;l<=r;l++) a[l]+=(l-tl+1)*t;
			remove(bel[r]); build(bel[r]);
		}
	}
}
```

### 4. 附：维护上凸壳的正确性数学证明

附赠给不能理解维护上凸壳正确性的同学：

假设现在有3个元素 $x,y,z$ ，设它们的编号分别为 $h_x, h_y, h_z$，元素大小为 $a_x,a_y,a_z$ ，权值为$w_x,w_y,w_z$ ， $h_x<h_y<h_z$ 。设 $add$ 值为 $T$, 若存在 $T$ 使得 $w_y > w_x$ 且 $w_y>w_z$，则作差列出不等式：

$a_x-a_y<(h_y-h_x)T$ ， $a_y-a_z>(h_z-h_y)T$ .

两式整理合并可得 $\displaystyle \frac{a_z-a_y}{h_z-h_y}<\frac{a_y-a_x}{h_y-h_x}$  .

即：直线 $y\to z$ 的斜率小于直线 $x\to y$ 的斜率，故维护上凸壳。同时易发现，随着 $T$ 的不断增大，最大元素的位置右移，且最大元素左边的权值递增，右边的权值递减（即单峰）。



---

## 作者：wine (赞：5)

方法一：

我们可以直接暴力。预计得分20分



方法二：

我们不考虑第三种操作，只需要维护一个最大值就可以了，预计得分40分



方法三：

我们考虑对于一段进行分段操作，分成sqrt(n)块。

有一个技巧是，我们求的是一段区间的最大值。我们把每个值a[i]修改为a[i]-a[i-1]，这样的话问题变成求最大前缀和。而第三种操作就变成了对一段区间进行加t的操作。

对于每一个快，我们记录这一块的最大值maxs，和对一整段进行操作的话，后面能够超过这个最大值的最小的是多少min。

那么对于第二种操作我们直接暴力维护，时间复杂度o(sqrt(n));

对于第三种操作，如果跨立一个块得话，我们直接对这一段区间标记加上t。如果这个标记大于这一段的min的话，我们对这一块暴力进行维护。时间复杂度o(sqrt(n)).

对于第一种操作,我们可以变成求最大前缀和啦。时间复杂度o(sqrt(n));

这一整个时间复杂度为o((n+m)*sqrt(n));



复杂度十分玄学(我是看了贴吧的讨论写的)
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
#include <set>
#include <cassert>

using namespace std;

typedef long long LL;

void read(LL &x) {
    char c;bool flag = 0;
    while((c=getchar())<'0'||c>'9') flag |= (c=='-');
    x=c-'0';while((c=getchar())>='0'&&c<='9') x = x*10+c-'0';
    flag?x=-x:x;
}

void read(int &x) {
    char c;bool flag = 0;
    while((c=getchar())<'0'||c>'9') flag |= (c=='-');
    x=c-'0';while((c=getchar())>='0'&&c<='9') x = x*10+c-'0';
    flag?x=-x:x;
}

const LL inf = ~0u>>2;
void FRE();

void upval(LL &a,const LL &b) {if(a<b) a=b;}

#define MAXX 101000
#define N 600
int n,m;
LL h[MAXX],bsf[N];
int bsiz,bl[N],br[N],bk[MAXX];
LL lazy1[N],lazy2[N];
struct pii{LL h,pos;pii(LL h=0,LL pos=0):h(h),pos(pos){}} st[N][N];
int top[N];

void reset(int bk) {
	bsf[bk] = inf; top[bk] = 0;
	for (LL i = bl[bk]; i <= br[bk]; i++) {
		while(top[bk] && st[bk][top[bk]].h <= h[i]) top[bk]--;
		st[bk][++top[bk]] = pii(h[i],i);			
	}
	for (LL i = 2; i <= top[bk]; i++)
	  bsf[bk] = min(bsf[bk], 
	     ((st[bk][1].h-st[bk][i].h)/(st[bk][i].pos-st[bk][1].pos)));
}

void push_down(int bk) {
	if(!lazy1[bk] && !lazy2[bk]) return;
	for (LL i = bl[bk]; i <= br[bk]; i++)
	 h[i] += lazy1[bk]+i*lazy2[bk];
	lazy1[bk] = lazy2[bk] = 0;
}

void Swap(int x,int y) {
	push_down(bk[x]); push_down(bk[y]);
	swap(h[x],h[y]);
	reset(bk[x]); reset(bk[y]);
}

LL Max(int x,int y) {
	int li = min(br[bk[x]],y); LL mx = 0;
	push_down(bk[x]);
	for (int i = x; i <= li; i++) upval(mx,h[i]);
	reset(bk[x]);
	for (int i = bk[x]+1; i < bk[y]; i++) {
	  	if(lazy2[i] >= bsf[i] && lazy2[i]) {
			push_down(i);
			reset(i);
		}
		upval(mx,st[i][1].h+lazy1[i]+lazy2[i]*st[i][1].pos);
	}
	if(bk[x] != bk[y]) {
		push_down(bk[y]);
		for (int i = bl[bk[y]]; i <= y; i++) upval(mx,h[i]);
		reset(bk[y]);
	}
    mx -= h[1]+lazy1[bk[1]]+lazy2[bk[1]];
    return mx>0 ? mx:0;
}

void Add(int x,int y,LL t) {
	int li = min(br[bk[x]],y); LL L = x-1;
	push_down(bk[x]);
	for (int i = x; i <= li; i++) h[i] += (i-L)*t;
	reset(bk[x]);
	for (int i = bk[x]+1; i < bk[y]; i++) 
		lazy1[i] += -L*t,lazy2[i] += t;
	if(bk[x] != bk[y]) {
		push_down(bk[y]);
		for (int i = bl[bk[y]]; i <= y; i++) h[i] += (i-L)*t;
		reset(bk[y]);
	}
}

int main() {
	//FRE();
	read(n); read(m);
	bsiz = sqrt(n+0.5);
    for (int i = 1; i <= n; i++) {
       read(h[i]);
       bk[i] = i/bsiz+1;
       if(!bl[bk[i]]) bl[bk[i]] = i;
       br[bk[i]] = i;
	} 
	for (int i = 1; i <= bk[n]; i++) reset(i);
	for (int i = 1,tp,x,y,t; i <= m; i++) {
		read(tp); read(x); read(y);
		if(tp == 1) printf("%lld\n",Max(x,y));
		else if(tp == 2) Swap(x,y);
		else read(t),Add(x,y,t);
	}
	return 0;
}

void FRE() {
	assert(freopen("sdoi12_line.in","r",stdin));
    assert(freopen("sdoi12_line.out","w",stdout));
}
```


---

## 作者：Treeloveswater (赞：5)

真是R2毒瘤题。。。网上还找不到题解  
最终在一个6年前的NOIP讨论帖看到了做法的简介
  
核心思想：分块

对于每个块，我们保存最大值和其位置。  
对于1操作就是正常查询  O(msqrt(n))  
对于2操作 也是正常swap，然后暴力再重算那两个块的信息O(msqrt(n))    
对于3操作 如果当前这个块的最大值会发生变化，我们就暴力重算该块。  
由于当这个块被完全覆盖的加值时，最大值的位置是单调向右更改的。  
所以每个块最多更改sqrt(n)次  每次修改量为sqrt(n) 总共sqrt(n)个块  
那个移动的总复杂度为sqrt(n)^3=nsqrt(n)

那么这个题我们就可以在 O((n+m)sqrt(n))的时间复杂度解决了。

and,样例是错的。。。我在讨论里提到了。  
并且，同志们要注意卡常。。这题有很大常数，所以wysssssss+开O2才能过。

当然也需要一点小优化之类的，具体看代码。
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define o 200011
#define ll long long
const int inf=1e9;
void max(ll &a,ll b){
    if(b>a) a=b;
}
void min(ll &a,ll b){
    if(a>b) a=b;
}
struct Point{
    int p;ll v;
};
ll A[o],Ti,S[o];
int bl[o],P[o];
int n,m,li,ri,type,top;
struct node{
    int l,r;ll T,sum,lim;
    Point bst;
    ll Maxnum(){
        return bst.v+(ll)bst.p*T-sum;
    }
    void pushdown(){
        if(!T)return;
        bst.v=Maxnum();
        for(register ll i=l;i<=r;i++) A[i]+=i*T-sum;
        T=sum=0;
    }
    void clear(){
        r=T=sum=0,l=inf,lim=1e13;
        bst.v=0,bst.p=0;
    }
    void Reset(){
        lim=1e13;bst.v=0,bst.p=0;
        top=0;
        for(register int i=l;i<=r;i++){
            if(bst.v<=A[i]){
                bst.v=A[i],bst.p=i;
                top=0;
            }
            else{
                while(top&&S[top]<=A[i]) top--;
                S[++top]=A[i];P[top]=i;
            }
        }  
        for(register int i=1;i<=top;i++) lim=std::min(lim,(bst.v-S[i])/(ll)(P[i]-bst.p));
    }
    void Come(){
        top=0;
        for(register int i=bst.p;i<=r;i++){
            if(bst.v<=A[i]){
                bst.v=A[i],bst.p=i;
                top=0;
            }
            else{
                while(top&&S[top]<=A[i]) top--;
                S[++top]=A[i];P[top]=i;
            }
        }  
        lim=1e13;
        for(register int i=1;i<=top;i++) lim=std::min(lim,(bst.v-S[i])/(ll)(P[i]-bst.p));	
    }
}Block[405];
inline void in(ll &ans, char ch = getchar(), bool flag = false)
{
    ans = 0;
    for (; (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
    if (ch == '-')
    {
        ch = getchar();
        flag = true;
    }
    for (; ch >= '0' && ch <= '9'; ans = (ans << 3) + (ans << 1) + ch - 48, ch = getchar());
    if (flag) ans = -ans;
}
inline void In(int &ans, char ch = getchar(), bool flag = false)
{
    ans = 0;
    for (; (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
    if (ch == '-')
    {
        ch = getchar();
        flag = true;
    }
    for (; ch >= '0' && ch <= '9'; ans = (ans << 3) + (ans << 1) + ch - 48, ch = getchar());
    if (flag) ans = -ans;
}
int main(){
    In(n),In(m);
    for(register int i=1;i<=n;i++) in(A[i]);
    int len=sqrt(n),N;
    for(register int i=1;i<=n;i++) bl[i]=(i-1)/len+1;
    N=bl[n];
    for(register int i=1;i<=N;i++) Block[i].clear();
    for(register int i=1;i<=n;i++) Block[bl[i]].l=std::min(Block[bl[i]].l,i),Block[bl[i]].r=std::max(Block[bl[i]].r,i);
    for(register int i=1;i<=N;i++) Block[i].Reset();
    for(register int t=1;t<=m;t++){
        In(type),In(li),In(ri);
        if(type==1){
            ll ans=0,h1=A[1]+Block[1].T-Block[1].sum;
            if(bl[li]!=bl[ri]){
                Block[bl[li]].pushdown();Block[bl[li]].Reset();
                Block[bl[ri]].pushdown();Block[bl[ri]].Reset();
                for(register int i=li;i<=Block[bl[li]].r;i++) max(ans,A[i]);
                for(register int i=Block[bl[ri]].l;i<=ri;i++) max(ans,A[i]);
                for(register int i=bl[li]+1;i<=bl[ri]-1;i++){
                    if(Block[i].T>Block[i].lim) Block[i].pushdown(),Block[i].Come();
                    max(ans,Block[i].Maxnum());
                }
            }
            else{
                Block[bl[li]].pushdown();Block[bl[li]].Come();
                for(register int i=li;i<=ri;i++) max(ans,A[i]);
            }
            printf("%lld\n",std::max(0ll,ans-h1));
            continue;
        }
        if(type==2){
            Block[bl[li]].pushdown();Block[bl[ri]].pushdown();
            std::swap(A[li],A[ri]);
            Block[bl[li]].Reset(); Block[bl[ri]].Reset();
            continue;
        }
        if(type==3){
            in(Ti);ll L=li-1;
            if(bl[li]!=bl[ri]){
                for(register ll i=li;i<=Block[bl[li]].r;i++) A[i]+=(i-L)*Ti;
                for(register ll i=Block[bl[ri]].l;i<=ri;i++) A[i]+=(i-L)*Ti;
                Block[bl[li]].pushdown();Block[bl[li]].Reset();
                Block[bl[ri]].pushdown();Block[bl[ri]].Reset();
                
                for(register int i=bl[li]+1;i<=bl[ri]-1;i++){
                    Block[i].T+=Ti;
                    Block[i].sum+=L*Ti;
                }
            }
            else{
                for(register ll i=li;i<=ri;i++) A[i]+=(i-L)*Ti;
                Block[bl[li]].pushdown();Block[bl[li]].Reset();
            }
        }
    }
}
```

---

## 作者：E1_de5truct0r (赞：3)

考虑分块。假设块长为 $B$，依次考虑下面三个操作：

1. 区间加等差数列

	是一个基础操作。

	我们把 $l \sim r$ 的每一个 $i$ 的增量 $\Delta i=(i-l+1)t$ 拆开，得到 $\Delta i=i\cdot t-(l-1)t$。然后我们由这个式子的可加性，维护一下 $i\cdot t$ 的值就好了。
    
    单次复杂度 $O\left(B+\dfrac{n}{B}\right)$。

2. 交换两个数

	这个比上面那个还简单。
    
    直接交换，然后暴力重构两个数所在的块即可。单次复杂度 $O(B)$。
    
3. 维护最大值

	这算是本题的难点了。首先，在一开始可以直接预处理一下。
    
    然后考虑修改的时候，分成散块和整块。
    
    - 散块显然可以直接暴力修改、暴力计算。
    
    - 整块不太好处理，但是观察到 $t \geq 0$，也就意味着对于任意的 $x_1,x_2 \in [l,r],x_1 \leq x_2$，有 $x_2t-x_1t \geq 0$。
    
    
    	这个式子说明了什么呢？这说明一个块内如果是整块加，那么后面的数的增量一定大于前面的数的增量。那么显然最大值只可能向后延伸，即具有单调性。
        
        可以二分然后平衡复杂度，是 $O(n\sqrt{n\log n})$ 的；但是我们可以考虑单调栈维护每个块的上凸壳，然后记录一个最大值指针 $pos_i$，每次向后移动。可以证明这样复杂度是 $O(n\sqrt{n})$ 的（见后文）。
        
于是本题就做完了。块长取 $\sqrt{n}$ 时复杂度为 $O(n\sqrt{n})$。

- **关于移动复杂度的证明**

显然一个块的上凸壳最多有块长个元素，即 $\sqrt{n}$ 个。那么容易发现，每个块如果不重构的情况下，总移动复杂度是 $O\left(\sqrt{n} \cdot \dfrac{n}{\sqrt{n}}\right) = O(n)$ 的。

考虑现在一个块如果重构了，那么显然指针会移回最左边重新往右跑，也就是说复杂度会加上最多 $\sqrt{n}$。

那么会重构多少个块呢？

考虑操作 $1$，每次最多产生两个散块重构。

考虑操作 $2$，每次也是最多产生两个。

所以总的重构数量是 $O(n)$ 的（准确来说是 $O(q)$ 的，但是 $n,q$ 同级。总复杂度也就是 $O(n \sqrt{n})$ 了。

不过这个只是最劣复杂度分析，实际上应该跑的还是蛮快的，毕竟指针移动一般跑不太满。

---

## 作者：duminghao123 (赞：1)

# P2496 [SDOI2012] 体育课 题解
什么？你跟我说这个题限时 $6s$？

好像题解区没有写模拟的，我来写一篇。

## 思路
用**模拟**算法。

维护一个数组 $a$，其中 $a_i$ 表示第 $i$ 个人的身高。

输入 $m$，对于每一次输入，根据题意，有以下三种情况：

**第一种情况**，$type=1$，从 $l$ 到 $r$ 依次枚举，对于第 $j$ 个人，求和如下：
$$
\large\sum_{j=l}^{r} a_j-a_1
$$
对于 $type=1$ 的情况代码如下：
```cpp
long long mx=0;
for(int j=l;j<=r;j++){
  if(a[j]-a[1]>mx) mx=a[j]-a[1];
}
cout<<mx<<endl;
```
时间复杂度为 $O(n)$。

**第二种情况**，$type=2$，直接交换 $a_l$，$a_r$。代码如下：
```cpp
swap(a[l],a[r]);
```
如果不会用 STL 的还可以用这个：
```cpp
long long temp=a[l];
a[l]=a[r];
a[r]=temp;
```
时间复杂度为 $O(1)$。

**第三种情况**，$type=3$，仍然是遍历 $a_l$ 到 $a_r$，对于所有的 $a_i$，$a_i \gets a_i+t\times(i-l+1)$。其中的箭头为赋值，箭头的指向为赋值的对象。

代码如下：
```cpp
cin>>t;
for(int j=l;j<=r;j++){
  a[j]+=(j-l+1)*t;
}
```
## 注意
**必须**开 long long，否则会溢出。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,opt,l,r,t;
long long a[100005];
int main(){
	scanf("%d%d",&n,&m);//使用scanf可以加速
	for(int i=1;i<=n;i++){
		scanf("%ld",&a[i]);
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&opt,&l,&r);
		if(opt==1){//边读入边维护，第一种情况
			long long mx=0;
			for(int j=l;j<=r;j++){
				if(a[j]-a[1]>mx) mx=a[j]-a[1];
			}
			cout<<mx<<endl;
		}
		if(opt==2){
			swap(a[l],a[r]);
		}
		if(opt==3){
			scanf("%d",&t);
			for(int j=l;j<=r;j++){
				a[j]+=(j-l+1)*t;
			}
		}
	}
	return 0;
}
```

---

## 作者：one_of_the_person (赞：0)

## 题目含义

维护一个序列 $a$，支持以下操作：

- 操作 1，查询 $\max\{0,\text{区间最大值}-a_1\}$
- 操作 2，交换两个元素
- 操作 3，让一段区间加上一个等差数列

## 解题思路

先考虑在没有操作 2 是该如何写。假定所有操作都是全局操作，考虑哪些点可能成为最大值。

设此前所有操作 3 的 $t$ 值的和为 $T$，初始值为 $b_i$，当前值为 $a_i=b_i+T\times i$。

定义可能成为最大值的点 $a_i$ 为存在一个 $T$，使得 $\max_{j=1}^n a_j=a_i$。

考虑对于一个下标为 $l_2$ 的点，设下标小于 $l_2$ 的第一个可能成为最大值的点的下标为 $l_1$，下标大于 $l_2$ 的第一个第一个可能成为最大值的点的下标为 $l_3$。

$l_2$ 可能成为最大值的条件是存在一个 $T$ 使得 $a_{l_2}>a_{l_1}$ 且 $a_{l_2}>a_{l_3}$，即：
$$
\begin{cases}
b_{l_2}+T\times l_2>b_{l_1}+T\times l_1\\
b_{l_2}+T\times l_2>b_{l_3}+T\times l_3
\end{cases}
$$

$$
\begin{cases}
T>\frac{b_{l_1}-b_{l_2}}{l_2-l_1}\\
T<\frac{b_{l_3}-b_{l_2}}{l_2-l_3}
\end{cases}
$$

这个不等式组有解的充要条件是：

$$
\frac{b_{l_1}-b_{l_2}}{l_2-l_1}<\frac{b_{l_3}-b_{l_2}}{l_2-l_3}
$$

$$
\frac{b_{l_2}-b_{l_1}}{l_2-l_1}>\frac{b_{l_3}-b_{l_2}}{l_3-l_2}
$$

通过这个式子可以发现若将每序列中的每个点对应二维平面上坐标为 $(i,b_i)$ 的点，则可能成为最大值的点应当是一个上凸包，使用单调队列维护凸包即可。

考虑将这个操作扩展到区间，传统的数据结构难以维护，考虑分块。

对于一个块，有两个标记，$u,v$。$u$ 对应在覆盖这一块的操作 3 的 $t$ 值的和，$v$ 为一个偏移量，块内元素的实际值为 $a_i=b_i+u\times i+v$。

对于操作 3，被完全覆盖的块直接修改标记 $u$ 和 $v$，然后更新块内的单调队列即可。由于习惯，更新单调队列之一步放置操作 1 统计前。

对于没有被完全覆盖的块，我们会发现之前得到的性质都会被破坏，但由于不被完全覆盖的块数是 $O(1)$ 级别的，所以我们可以对这个块进行暴力重构，复杂度为 $O(\text{块长})$。

```cpp
void modify(int l,int r,int v){
	int bl=b[l],br=b[r];//b[i]为i所在的块
	if(q[bl].l!=l)bl++;
	if(q[br].r!=r)br--;
	if(bl>br&&b[l]==b[r]){
		q[b[l]].init();
		for(int i=l;i<=r;i++)a[i]+=v*(i-l+1);
		q[b[l]].build();
		return;
	}
	q[b[l]].init();//放下标记
	for(int i=l;b[i]!=bl;i++)a[i]+=v*(i-l+1);
	q[b[l]].build();//重新处理上凸包
	q[b[r]].init();
	for(int i=r;b[i]!=br;i--)a[i]+=v*(i-l+1);
	q[b[r]].build();
	for(int i=bl;i<=br;i++)q[i].k+=v,q[i].b+=(1-l)*v;//k对应u，b对应v
	return;
}
```

操作 2 与操作 3 没有被完全覆盖的块的处理方法相同，交换后暴力重构两个点所在的块即可。

```cpp
void Swap(int l,int r){
	int bl=b[l],br=b[r];
	if(bl==br){
		q[bl].init();
		swap(a[l],a[r]);
		q[bl].build();
		return;
	}
	q[bl].init(),q[br].init();
	swap(a[l],a[r]);
	q[bl].build(),q[br].build();
	return;
}
```

操作 1 与操作 3 类似，被完全覆盖的块直接统计答案，不被完全覆盖的块暴力统计答案。

```cpp
int getMax(int l,int r){
	int bl=b[l],br=b[r],ans=Ins;
	if(q[bl].l!=l)bl++;
	if(q[br].r!=r)br--;
	if(bl>br&&b[l]==b[r]){
		for(int i=l;i<=r;i++)ans=max(ans,a[i]+i*q[b[i]].k+q[b[i]].b);
		return ans;
	}
	for(int i=l;b[i]!=bl;i++)ans=max(ans,a[i]+i*q[b[i]].k+q[b[i]].b);
	for(int i=r;b[i]!=br;i--)ans=max(ans,a[i]+i*q[b[i]].k+q[b[i]].b);
	for(int i=bl;i<=br;i++)ans=max(ans,q[i].getMax());//q[i].getMax()调用同时更新单调队列
	return ans;
}
```

可以通过势能分析法，得到总复杂度为 $O(n+m(\text{块长}+\text{块数}))$，当块长取 $\sqrt n$ 时总复杂度为 $O(n+m\sqrt n)$ 最优。

## AC 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100000
#define M 1000
#define Inf (1ll*INT_MAX*N)
#define Ins (1ll*INT_MIN*N)
using namespace std;
double const eps=1e-12;
int n,m,a[N+5],b[N+5],block,opt,ux,uy,uz;
struct Blcok{
	struct Node{int x,y;};
	int top,tip,b,k,l,r;
	Node sta[M+5];
	double calc(Node x,Node y){return (x.y-y.y)*1.0/(x.x-y.x);}
	void modify(Node x){
		while(top>1&&calc(x,sta[top])-calc(sta[top],sta[top-1])>=eps)top--;
		tip=min(top,tip),sta[++top]=x;
		return;
	}
	Node query(){
		while(tip<top&&calc(sta[tip],sta[tip+1])+k>=eps)tip++;
		return sta[tip];
	}
	void init(){
		for(int i=l;i<=r;i++)a[i]+=i*k+b;
		b=k=0,top=tip=1,sta[1]={l-1,0};
		return;
	}
	void build(){
		for(int i=l;i<=r;i++)modify({i,a[i]});
		return;
	}
	int getMax(){return query().y+query().x*k+b;}
}q[M+5];
int read(){
	int f=1,g=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		g=g*10+ch-'0';
		ch=getchar();
	}
	return f*g;
}
void print(int x){
	if(x<0){
		putchar('-');
		x*=-1;
	}
	if(x>9)print(x/10);
	putchar(x%10+'0');
	return;
}
int getMax(int l,int r){
	int bl=b[l],br=b[r],ans=Ins;
	if(q[bl].l!=l)bl++;
	if(q[br].r!=r)br--;
	if(bl>br&&b[l]==b[r]){
		for(int i=l;i<=r;i++)ans=max(ans,a[i]+i*q[b[i]].k+q[b[i]].b);
		return ans;
	}
	for(int i=l;b[i]!=bl;i++)ans=max(ans,a[i]+i*q[b[i]].k+q[b[i]].b);
	for(int i=r;b[i]!=br;i--)ans=max(ans,a[i]+i*q[b[i]].k+q[b[i]].b);
	for(int i=bl;i<=br;i++)ans=max(ans,q[i].getMax());
	return ans;
}
void modify(int l,int r,int v){
	int bl=b[l],br=b[r];
	if(q[bl].l!=l)bl++;
	if(q[br].r!=r)br--;
	if(bl>br&&b[l]==b[r]){
		q[b[l]].init();
		for(int i=l;i<=r;i++)a[i]+=v*(i-l+1);
		q[b[l]].build();
		return;
	}
	q[b[l]].init();
	for(int i=l;b[i]!=bl;i++)a[i]+=v*(i-l+1);
	q[b[l]].build();
	q[b[r]].init();
	for(int i=r;b[i]!=br;i--)a[i]+=v*(i-l+1);
	q[b[r]].build();
	for(int i=bl;i<=br;i++)q[i].k+=v,q[i].b+=(1-l)*v;
	return;
}
void Swap(int l,int r){
	int bl=b[l],br=b[r];
	if(bl==br){
		q[bl].init();
		swap(a[l],a[r]);
		q[bl].build();
		return;
	}
	q[bl].init(),q[br].init();
	swap(a[l],a[r]);
	q[bl].build(),q[br].build();
	return;
}
main(){
	n=read(),m=read(),block=ceil(sqrt(n));
	for(int i=1;i<=n;i++)a[i]=read(),b[i]=(i-1)/block+1;
	for(int i=1;i<=(n-1)/block+1;i++){
		q[i].k=q[i].b=0,q[i].l=(i-1)*block+1,q[i].r=min(n,i*block);
		q[i].init();
        q[i].build();
	}
	for(int i=1;i<=m;i++){
		opt=read();
		if(opt==1){
			ux=read(),uy=read();
			print(max(0ll,getMax(ux,uy)-(a[1]+q[b[1]].k*1+q[b[1]].b))),putchar('\n');
		}
		else if(opt==2){
			ux=read(),uy=read();
			Swap(ux,uy);
		}
		else if(opt==3){
			ux=read(),uy=read(),uz=read();
			modify(ux,uy,uz);
		}
	}
	return 0;
}
```

---


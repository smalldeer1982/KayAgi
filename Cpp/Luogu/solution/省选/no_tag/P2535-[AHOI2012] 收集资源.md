# [AHOI2012] 收集资源

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/1637.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/1638.png) 



## 说明/提示

数据：

50%: 1<=N,M,T<=100

100%: 1<=N,M,T<=200


## 样例 #1

### 输入

```
8 8 10
1 1 3
2 2 4
3 3 5
3 4 3
4 3 2
4 4 6
5 5 7
6 6 8```

### 输出

```
28```

# 题解

## 作者：caddy (赞：3)

蒟蒻的构思
一开始想到深度优先搜索
以每个资源点为状态，包括起点。
建一个图，值得注意的是假如点a与点b之间有一个点，那么不连边。
否则就连边,表示可以做决策从a去b。
具体思路就是，如果a,b有点c那么肯定顺道去c了。所以a不会直接到b.之后从起点dfs整个图即可，记录最大答案.
```cpp
#include<cstdio>
#define max(x,y) ((x)>(y))?(x):(y)
#define min(x,y) ((x)<(y))?(x):(y)
int abs(int x)
{
	return (x>0)?x:-x;
}
struct word
{
	int x,y,v;
};
word node[205];
int n,m,t,ans,g[205][205],vic[205];
bool check(int a,int b)
{
	int lx=max(node[a].x,node[b].x) ,
	ly=max(node[a].y,node[b].y),
	rx=min(node[a].x,node[b].x),
	ry=min(node[a].y,node[b].y);
	for(int i=0;i<=m;i++)
	if(i!=a&&i!=b)
	if(node[i].x>=rx&&node[i].x<=lx)
	if(node[i].y>=ry&&node[i].y<=ly)
	return false;
	return true;
}
void  dfs(int x,int use_t,int score)
{
	ans=max(score,ans);
	for(int i=0;i<=m;i++)
	if(g[x][i]&&use_t+g[x][i]<=t&&(!vic[i]))
	vic[i]=1,dfs(i,use_t+g[x][i],score+node[i].v),vic[i]=0;
}
int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=m;i++)
	scanf("%d%d%d",&node[i].x,&node[i].y,&node[i].v);	
	for(int i=0;i<=m;i++)
	for(int j=0;j<=m;j++)
	{
		if(i!=j&&check(i,j))
		g[i][j]=abs(node[j].y-node[i].y)+
		abs(node[j].x-node[i].x);
	}
	for(int i=0;i<=m;i++,printf("\n"))
	for(int j=0;j<=m;j++)
	printf("%d ",g[i][j]);
	dfs(0,0,0);
	printf("%d",ans);
}
  
```

---

## 作者：karma (赞：1)

~~此题数据其实比较弱,骗了半天的分才过去~~

### 思路:
-  暴力建图,存两个点之间的距离(即从一个点到另一个点的时间).然后暴力dfs即可.

### 优化:
-  预处理得到图中的最短距离和最大价值,如果总时间减去目前剩下的时间再除以最短距离再乘以最大价值再加上当前得到的价值仍比目前最优解要小,就return.**相当于A*优化**
- 目前时间加上最短时间大于限制时间直接return.

### 玄学:
- 题中数据有可能造成最短距离为0,此时可以给最短距离一个定值,给1或2会TLE,给4或5会WA,**所以给3就可以AC.**

代码中仍有一些小细节:

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 205
int N,M,T,cost[maxn][maxn];
bool vis[maxn];
struct node {
	int x,y,val;
} a[maxn];
int ans,gu=0x7fffff;
int money;
void dfs(int pos,int now,int times) {
	if((((T-times)/gu)*money+now)<=ans)return ;//这个剪枝一定要在前面 !!!
	if(times+gu>=T) {
		if(now>ans)ans=now;
		return ;
	}
	bool ok=0;
	for(int i=1; i<=M; ++i) {
		if(!vis[i]&&times+cost[pos][i]<=T)ok=1,vis[i]=1,dfs(i,now+a[i].val,times+cost[pos][i]),vis[i]=0;
	}
	if(!ok&&now>ans)ans=now;
}
int main() {
	scanf("%d %d %d",&N,&M,&T);
	for(int i=1; i<=M; ++i) {
		scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].val);
		money=max(money,a[i].val);
	}
	for(int i=0; i<=M; ++i)
		for(int j=i+1; j<=M; ++j)cost[i][j]=cost[j][i]=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y),gu=min(gu,cost[i][j]);
	if(gu==0)gu=3;//玄学优化 !!!
	dfs(0,0,0);
	printf("%d",ans);
	return 0;
}
```

---


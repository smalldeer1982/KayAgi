# [HNOI2008] 明明的烦恼

## 题目背景

原 编译优化 参见P1792

## 题目描述

自从明明学了树的结构，就对奇怪的树产生了兴趣……

给出标号为 $1$ 到 $N$ 的点，以及某些点最终的度数，允许在任意两点间连边，可产生多少棵度数满足要求的树?

## 说明/提示

两棵树分别为 `1-2-3` 与 `1-3-2`。

## 样例 #1

### 输入

```
3
1
-1
-1```

### 输出

```
2```

# 题解

## 作者：EternalEpic (赞：4)

目前最优解，比第二名快一倍。

设有 $cnt$ 个点度数已知。

我们可以知道 $Prufer$ 序列中已经占有的位置数 $sum=\sum_{i=1}^{n}\left(deg_{i}-1\right)$ 

根据 $Cayley$ 公式和组合我们可以知道，这些有明确 $deg$ 的点的排列方案数为 
$$
C_{n-2}^{s u m} \times \frac{s u m !}{\prod_{i=1}^{c n t}\left(deg_{i}-1\right) !}
$$

最后剩余的 $(n - cnt)$ 个数任意插入在 $(n - sum - 2)$ 个位置上，所以要乘 $(n - cnt)^{n - sum - 2}$

可以预处理阶乘的质因数指数避免前半部分的高精度除法，但求答案还是要用高精度乘法，这里笔者采用压八位的高精。

```cpp
const int Maxn = 1e3 + 5;
int tot = 0, prime[Maxn]; bool vis[Maxn];
inline void sieve(void) {
	vis[1] = true;
	for (int i = 2; i <= 1000; i++) {
		if (!vis[i]) prime[++tot] = i;
		for (int j = 1; j <= tot && i * prime[j] <= 1000; j++) {
			vis[i * prime[j]] = true; if (i % prime[j] == 0) break;
		}
	}
}

inline int rate(int n, int p) {
	int ret = 0;
	while (n) {
		ret += n / p;
		n /= p;
	} return ret;
}

int ps[Maxn];
inline void calc(int n, int typ) {
	for (int i = 1; i <= tot; i++)
		ps[i] += typ * rate(n, prime[i]);
}

int n, deg[Maxn], sum = 0, cnt = 0;
const int mod = 100000000;
inline vector <int> Multiply(vector <int> vec, int rec) {
	vector <int> ret; ll t = 0ll; ret.clear();
	for (int i = 0; i < vec.size(); i++) {
		t += 1ll * vec[i] * rec;
		ret.push_back(t % mod); t /= mod;
	} while (t) { ret.push_back(t % mod); t /= mod; }
	return ret;
}

signed main(void) {
	read(n); vector <int> ret(1, 1); sieve();
	for (int i = 1; i <= n; i++) {
		read(deg[i]);
		if (deg[i] != -1) sum += deg[i] - 1, ++cnt;
	} calc(n - 2, 1); calc(n - 2 - sum, -1);
	for (int i = 1; i <= n; i++) if (deg[i] != -1) calc(deg[i] - 1, -1);
	for (int i = 1; i <= tot; i++)
	for (int j = 1; j <= ps[i]; j++) ret = Multiply(ret, prime[i]);
	for (int i = 1; i <= n - 2 - sum; i++) ret = Multiply(ret, n - cnt);
	write(ret[ret.size() - 1]);
	for (int i = (int)(ret.size()) - 2; i >= 0; i--) {
		if (ret[i] < 10) printf("0000000");
		else if (ret[i] < 100) printf("000000");
		else if (ret[i] < 1000) printf("00000");
		else if (ret[i] < 10000) printf("0000");
		else if (ret[i] < 100000) printf("000");
		else if (ret[i] < 1000000) printf("00");
		else if (ret[i] < 10000000) printf("0");
		write(ret[i]);
	}
	return 0;
}

/**/


```


---

## 作者：Laoshan_PLUS (赞：1)

### 题意

给定 $N$ 个点和某些点的度数 $D_i$，求可能的树数量。

### 解析

显然，这题有弱化版 [[HNOI2004] 树的计数](https://www.luogu.com.cn/problem/P2290)。而弱化版的式子就是我们的预备知识。一个无向连通图在给定度数情况下的生成树数量为：

$$
\frac{(n-2)!}{\prod_{i=1}^n(D_i-1)!}
$$

Prufer 序列证明即可。上式中的 $n-2$ 实际上可写作 $\sum_{i=1}^n(D_i-1)$，但由 Prufer 序列的性质得，每个点在序列中出现度数减一次，所以上面两项是相等的。

---

那么回到本题中。本题只给了部分点的度数。设给了 $k$ 个点的度数 $D_i$（此后均不考虑 $-1$ 的情况，$D$ 序列长度为 $k$）。那么这 $k$ 个点的情况我们仍能套用预备公式，但要注意 $k$ 个点并不是 Prufer 序列的全部，所以不能写 $k-2$：

$$
\frac{\left[\sum_{i=1}^k(D_i-1)\right]!}{\prod_{i=1}^k(D_i-1)!}
$$

同样，由于这不是全部，所以这 $k$ 个点在 Prufer 序列中的位置是不固定的。由 Prufer 序列的性质，第 $k$ 个点出现 $(D_k-1)$ 次，所以还要乘上 $\binom{n-2}{\sum_{i=1}^k(D_i-1)}$。至于剩下的 $(n-k)$ 个无度点，我们把它填充到 Prufer 序列中剩下的 $\left[n-2-\sum_{i=1}^k(D_i-1)\right]$ 个空中。**由于这 $\boldsymbol{(n-k)}$ 个点的度数不固定，所以怎么填都是可以的，不用考虑排列的情况**。答案再乘上 $(n-k)^{n-2-\sum_{i=1}^k(D_i-1)}$ 得：

$$
\frac{\left[\sum_{i=1}^k(D_i-1)\right]!}{\prod_{i=1}^k(D_i-1)!}\times\binom{n-2}{\sum_{i=1}^k(D_i-1)}\times(n-k)^{n-2-\sum_{i=1}^k(D_i-1)}
$$

化简得：

$$
\frac{\left[\prod_{t=n-1-\sum_{i=1}^k(D_i-1)}^{n-2}t\right](n-k)^{n-2-\sum_{i=1}^k(D_i-1)}}{\prod_{i=1}^k(D_i-1)!}
$$

太繁琐了，我们令 $\sum_{i=1}^k(D_i-1)=s$，一下就将式子化简了：

$$
\frac{\left[\prod_{t=n-1-s}^{n-2}t\right](n-k)^{n-2-s}}{\prod_{i=1}^k(D_i-1)!}
$$

最后就是普通的分解质因数了。

### 坑点

- 注意统计答案要开高精。
- 高精数组开越大越好。

### 实现

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int MAXN = 1e5 + 5;
int n, d[MAXN], k, s;
int pw[MAXN], pm[MAXN];
vector<int> pri;
int ans[MAXN] = {1};

void init() {
    for (int i = 2; i < MAXN; i++) {
        if (!pm[i]) {
            pm[i] = i;
            pri.push_back(i);
        }
        for (auto j : pri) {
            if (i * j >= MAXN) break;
            pm[i * j] = j;
        }
    }
}

void mul(int b) {
    int tmp = 0;
    for (int i = 0; i < MAXN - 1; i++) {
        ans[i] = ans[i] * b + tmp;
        tmp = 0;
        if (ans[i] >= 10) {
            tmp = ans[i] / 10;
            ans[i] %= 10;
        }
    }
}

void print() {
    int len = MAXN - 1;
    while (!ans[len]) len--;
    for (int i = len; i >= 0; i--) cout << ans[i];
    cout << '\n';
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    init();
    cin >> n;
    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        if (x == -1) continue;
        d[++k] = x;
        s += x - 1;
    } 
    for (int i = n - 1 - s; i <= n - 2; i++) {
        int x = i;
        while (x > 1) pw[pm[x]]++, x /= pm[x];
    }
    for (int i = 1; i <= n - 2 - s; i++) {
        int x = n - k;
        while (x > 1) pw[pm[x]]++, x /= pm[x];
    }
    for (int i = 1; i <= k; i++)
        for (int j = 1; j < d[i]; j++) {
            int x = j;
            while (x > 1) pw[pm[x]]--, x /= pm[x];
        }
    for (int i = 2; i < MAXN; i++) while (pw[i]--) mul(i);
    print();

    return 0;
}
```

---

## 作者：tang_c (赞：0)

# 题解：P2624 [HNOI2008] 明明的烦恼

想起来简单，~~高精度是真恶心~~，就当练习高精度了吧。

这题明显的：[prufer](https://oi-wiki.org/graph/prufer/)，前置要了解一下。

## 解题思路

运用树的 prufer 编码的性质：

 - 树的 prufer 编码的实现：不断删除树中度数为 1 的最小序号的点，并输出与其相连的节点的序号直至树中只有两个节点。
 - 通过观察不难发现：任意一颗 $n$ 个节点的树都可以用长度为 $n-2$ 的 prufer 编码表示；度为 $m$ 的节点的序号在编码中恰好出现 $m-1$ 次。
 - 如何将编码还原为一颗树：从 prufer 编码的最前端开始扫描节点，设该节点序号为 $u$，寻找不在 prufer 编码的最小序号且没有被标记的节点 $v$，连接 $uv$ 并标记 $v$，将 $u$ 从 prufer 编码中删除，扫描下一节点。

这道题就需要将树转换为 prufer 编码。  
下面是具体的推导过程：

令 $n$ 为树的节点数，$d_i$ 为 $i$ 节点的度数，$m$ 为无限制度数的节点数，$tot$ 为度数总和，也就是：

$$tot=\sum^n_{i=1}d_i-1$$

- 所以要求在 $n-2$ 大小的数组中插入 $tot$ 各序号，共有 $C_{n-2}^{tot}$ 种插法。
- 在 $tot$ 各序号排列中插入第一个节点的方法有 $C_{tot}^{d_1-1}$ 种插法。
- 插入第二个节点有 $C_{tot-(d_1-1)}^{d_2-1}$ 种插法
- 以此类推 $\cdots$。

另外还有 $m$ 个节点没有度数限制，所以他们可以任意分配在剩余的 $n-2-tot$ 的空间中，方法总数为：
$$m^{n-2-tot}$$

好的，如果你看到这里了，那么正片开始！

根据乘法原理可知：

$$ans=C_{n-1}^{tot}\times C_{tot}^{d_1-1}\times C_{tot-(d_1-1)}^{d_2-1}\times \cdots \times C_{d_n-1}^{d_n-1}\times m^{n-2-tot}$$

$$\Leftrightarrow \frac{(n-2)!}{(n-2-tot)! tot!}\times \frac{tot!}{(d_1-1)!(tot-d_1+1)!}\times\cdots \frac{(d_n-1)!}{(d_n-1)!0!}\times m^{n-2-tot}$$


不难发现可以约分，于是就得到了：

$$\Leftrightarrow\frac{(n-2)!\times m^{n-2-tot}}{(n-2-tot)!\times (d_1-1)! \times (d_2-1)!\times \cdots\times(d_n-1)!}$$

然后就要高精度了，~~我嫌麻烦~~，显而易见的排列组合一定是整数，所以直接质因数分解，在加起来即可。

于是便诞生了两大写法。

## 代码

先放第一种暴力分解的写法。

```cpp
#include<iostream>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std；

int n,nolimit=0,tot=0,ans[10005]={0};

vector<int> prime;

typedef struct{
       int h[400];
       void Init(){memset(h,0,sizeof(h));}

       void mul(int x){
            for(int i=0;i<prime.size();++i)
            while(x%prime[i]==0)
            {h[i]++;x/=prime[i];}
            }
       void div(int x){
            for(int i=0;i<prime.size();++i)
            while(x%prime[i]==0)
            {h[i]--;x/=prime[i];}
            }

       }typenum;typenum sum;

bool Isprime(int x){
     int i;
     for(i=2;i<=sqrt(x);++i)
     if(x%i==0) return 0;
     return 1;
     }

void Makeprime(){
     for(int i=2;i<=n;++i)
     if(Isprime(i)) prime.push_back(i);
     return ;
     }

void Init(){
     cin>>n；
     Makeprime();
   //  for(int i=0;i<prime.size();++i)
   //  cout<<prime[i]<<"  ";cout<<endl;
     sum.Init();
   //  for(int i=0;i<400;++i)
   //  cout<<sum.h[i]<<"  ";
     int d;
     for(int i=1;i<=n;++i)
     {
       cin>>d;

       for(int i=1;i<d;++i)
       sum.div(i);
       if(d==-1)nolimit++;///注意
       else tot+=d-1;//注意
             }
     }

void Work(){
     if(tot>n-2||(tot!=n-2&&nolimit==0)) {cout<<0<<endl;return ；}

     for(int i=1;i<=n-2;++i)
     sum.mul(i)；

     for(int i=1;i<=n-2-tot;++i)
     sum.div(i);

     for(int i=1;i<=n-2-tot;++i)
     sum.mul(nolimit);

     ans[0]=1;
     for(int i=0;i<prime.size();++i)
     while(sum.h[i]>0)
     {
       sum.h[i]--;
       for(int j=0;j<10000;++j)
       ans[j]*=prime[i];

       for(int j=0;j<10000;++j)
       if(ans[j]>9)
       {ans[j+1]+=ans[j]/10;ans[j]%=10;}
                   }

     int i=10000;
     while(ans[i]==0) i--;
     while(i>=0) cout<<ans[i--];
     cout<<endl;
     }

int main()
{
    Init()；
    Work()；
    return 0;
}
```


第二种写法就稍微优化了一点关于质因数分解的部分，稍微提一嘴：

若 $p$ 为质数，则 $n!$ 可分解为一个数 $p^x$，其中：

$$x=\lfloor\frac{n}{p}\rfloor+\lfloor\frac{n}{p^2}\rfloor+\cdots+\lfloor\frac{n}{p^t}\rfloor$$

并且 $p^t<n$。

所以可以得到 $n!=p_1^{x_1}\times p_2^{x_2}\times\cdots\times p_m^{x_m}(p_m<n)$

上第二版代码。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string.h>
#include<cstdlib>
#include<cmath>
#include<fstream>
using namespace std;
//ifstream cin("cin.in");

int n,m=0,tot=0,fenmu[1005]={0},fenzi[1005]={0},prime[1005]={0};
int ans[10005]={0};

void Fenjie(int zz,int a[]){
     int sum;
     for(int i=2;i<=zz;++i)
     if(prime[i])
     {
       sum=i;
       while(sum<=zz)
       {a[i]+=zz/sum;sum*=i;}
             }
     return ;
     }

void Buildprime(){
     int i,j;
     for(i=2;i<=1000;++i)
     {
       for(j=2;j<=sqrt(i);++j)
       if(i%j==0) break;
       if(j>sqrt(i)) prime[i]=1;//,cout<<i<<"  ";
             }//cout<<endl;
     }

int main()
{
    cin>>n;

    Buildprime();

    for(int i=1;i<=n;++i)
    {
      int d;
      cin>>d;
      if(d==-1) {m++;continue;}
      if(d>1) Fenjie(d-1,fenmu);
      tot+=d-1;
            }

    Fenjie(n-2-tot,fenmu);
    Fenjie(n-2,fenzi);

    for(int i=1;i<=1000;++i)
    fenzi[i]-=fenmu[i];

    ans[0]=1;

    for(int i=1;i<=1000;++i)
    while(fenzi[i]>0)
    {
      fenzi[i]--;
      for(int j=0;j<=10000;++j)
      ans[j]*=i;
      for(int j=0;j<=10000;++j)
      if(ans[j]>9)
      {ans[j+1]+=ans[j]/10;ans[j]%=10;}
                     }

    if(m>0)
    for(int i=1;i<=n-2-tot;++i)
    {
      for(int j=0;j<=10000;++j)
      ans[j]*=m;
      for(int j=0;j<=10000;++j)
      if(ans[j]>9)
      {
        ans[j+1]+=ans[j]/10;
        ans[j]%=10;
              }
            }

    if(tot>n-2||(tot<n-2&&m==0)) {cout<<0<<endl;return 0;}

    int i=10000;
    while(ans[i]==0) i--;
   // if(i<=0) cout<<ans[0];
    while(i>=0) cout<<ans[i--];
    cout<<endl;

   
    return 0;

    }
```


完结撒花，感谢 cy 姐姐的支持。

---

## 作者：_Spectator_ (赞：0)

[可能更好的食用体验](/article/anqa127j) $|$ 
[题目传送门](/problem/P2624) $|$ 
[我的其他题解](/user/523641#article.2)

前置知识：[Prufer 序列](https://www.luogu.com.cn/problem/P6086)。

------------
### ${\color{#00CD00}\text{思路}}$

题目只给出了树上某些点的度数，考虑放到一个 Prufer 序列上来做。

这里用到了 Prufer 序列的两个性质：
- $n$ 个结点的无根树与长度为 $n-2$ 的 Prufer 序列是一一对应的。
- 一个结点在 Prufer 序列中的出现次数为其度数 $-1$。

因此题目转化为：求有多少个长度为 $n-2$ 的序列，序列中的每个元素 $\in[1,n]$，其中序列中某些数的出现次数为给定的值。

设给定了 $m$ 个点的度数，分别为 $d_1,d_2,\dots d_m$，$s=\sum\limits_{i=1}^m d_i-1$。由简单的组合数学可知答案为：
$$\boxed{A_{n-2}^s\times\prod_{i=1}^m\frac{1}{(d_i-1)!}\times (n-m)^{n-2-s}}$$

其中：
- $A_{n-2}^s$ 表示在 $n-2$ 个位置中取出 $s$ 个位置的排列数。
- $\prod\limits_{i=1}^m\frac{1}{(d_i-1)!}$ 表示除掉每一种数内部的顺序。
- $(n-m)^{n-2-s}$ 表示将其余的 $n-m$ 个数任意填入剩下的 $n-2-s$ 个位置。

------------
### ${\color{#00CD00}\text{代码}}$

因为不想写高精度，所以用的是 Python。

```python
def main():
    n = int(input())
    fac = [1] * (n + 1)
    for i in range(1, n + 1):
        fac[i] = fac[i - 1] * i
    d = [0] * (n + 1)
    m = 0
    s = 0
    for i in range(1, n + 1):
        d[i] = int(input())
        if d[i] == -1: continue
        m += 1; s += d[i] - 1
    if s > n - 2: print(0); return;
    div = fac[n - 2 - s]
    for i in range(1, n + 1):
        if d[i] != -1: div *= fac[d[i] - 1]
    print(fac[n - 2] * (n - m) ** (n - 2 - s) // div)

if __name__ == "__main__":
    main()
```

---

## 作者：Pwtking (赞：0)

Prufer 序列变形题。

简单的讲解一下 Prufer 序列：

- **简介**：一颗无根树，每次将度数为1的节点的父亲加入序列，并将其删除，最终得到一个长度为 $n-2$ 的序列。

- **将 Prufer 序列转化为无根树**：每次取出序列中最前面的数，将一个在点集中且最小的数与其连边，最后将序列最靠前的数和刚刚在点集中取出的数在分别在序列和点集中删去。最后将剩下的两个未连边的点连边即可。

- **Prufer 序列性质：** 

- 序列与无根树一一对应。

- 度数为 $d_i$ 的节点只会在序列中出现 $d_i-1$ 次。

- 生成 $n$ 节点的完全图（树）有 $n^{n-2}$ 种（Cayley 定理）。

- 生成每一种树的方式有 $(n-1)!$ 种（Cayley 定理）。

- 对于给定度数 $d_{ 1-n}$ 的 $n$ 个节点，共有 $\frac{(n-2)!}{\prod_{i=1}^{n} (d_i-1)!} $ 种形成树的方式。

辅助做题结论：对于 $n$ 个结点形成的树，$ {\textstyle \sum_{i=1}^{n}(d_i-1)}=n-2 $。



------------

**接下来看本题：**

题目中提到有一些节点度数未知，所以我们可先从这些节点已知的情况下手。若有 $x$ 个结点度数已知，根据上面提到的性质，会有 $\frac{(\textstyle \sum_{i=1}^{x}(d_i-1))!}{\prod_{i=1}^{x} (d_i-1)!} $ 种情况。
同时，因为这 $x$ 个节点是无序的，所以还要再乘上一个他们的组合数，即为 $\frac{(\textstyle \sum_{i=1}^{x}(d_i-1))!}{\prod_{i=1}^{x} (d_i-1)!}  \times C_{n-2}^{x}$。

接下来考虑度数未知的情况。

根据上面的性质可知：因为 Prufer 序列剩下的位置只有 $n-2-\textstyle \sum_{i=1}^{x}(d_i-1)$ 个，所以根据性质可知共有 $(n-x)^{n-2-\textstyle \sum_{i=1}^{x}(d_i-1)}$ 种方案。

最终答案即为 $\frac{(\textstyle \sum_{i=1}^{x}(d_i-1))!}{\prod_{i=1}^{x} (d_i-1)!}  \times C_{n-2}^{x}\times (n-x)^{n-2-\textstyle \sum_{i=1}^{x}(d_i-1)}$。

不过这还没完，再解释一下为什么不先算未知度数的节点：

当然是因为不方便。因为这道题是利用 Prufer 序列的性质来算的，所以未知节点的方案不好直接表示（因为序列的总位置为 $n-2$ 个，若不先把已知度数的节点所占位置数算出，未知度数的节点不好表示。）

---


# [SHOI2005] 树的双中心

## 题目描述

给定一棵树 $T=(V,E)$，其中 $V$ 为节点集合，$E$ 为边集合。

对于 $V$ 中的每个节点 $v$，有一个权值函数 $W(v)$，该函数的值均为正整数。

记 $d(u,v)$ 为节点 $u$ 和 $v$ 之间的距离，表示它们之间唯一的一条路径的边数。若 $u$ 和 $v$ 为同一个节点，则 $d(u,v)=0$。

你的任务是找出两个不同的节点 $x$ 和 $y$，使得以下表达式 $S(x,y)$ 的值最小

$$S(x,y)=\sum_{v\in V} (W(v)\cdot \min\{ d(v,x),d(v,y)\})

## 说明/提示

样例中，选取的两个中心节点分别为 $2$ 和 $3$。

## 样例 #1

### 输入

```
5
1 2
1 3
3 4
3 5
5
7
6
5
4```

### 输出

```
14```

# 题解

## 作者：Huami360 (赞：23)

$\text{吾观此题无题解，故补之。}$

[博客](https://www.cnblogs.com/Qihoo360/p/9871320.html)食用效果更佳

先考虑一个$O(N^2)$做法。

设选的两个点为$x,y$，则一定可以将树分成两个集合$A,B$，使得$A$集合所有点都去$x$，$B$集合所有点都去$y$，而这两个集合的分界点就是树上的一条边。于是考虑枚举断哪条边，然后对两边分别跑一遍带权树的重心，统计答案加起来取最小值就行了。

现在进行优化，求树的重心的方法可以参考[医院设置](https://www.luogu.org/problemnew/solution/P1364)。
以$1$为根建树，$f[u]$表示所有点到$u$的总距离。（人数乘以距离）

转移方程是：
$$f[v]=f[u]+size[1]-size[v]-size[v]$$
可以发现，只有当$size[v]*2>size[1]$时$v$比$u$更优，而且满足$size[v]*2>size[1]$的$v$数量$<=1$。

所以我们可以预处理出每个点的子树大小最大的儿子和次大的儿子，每次断边时自下而上修改其所有祖先的$size$大小，这时最大儿子可能变小，进而被次大儿子替代，直接判断一下然后走此时的大儿子就行。易得时间复杂度为$O(NH)$，这也就是题中提到树的高度不超过$100$的原因吧。

```cpp
#include <cstdio>
#include <algorithm>
#define INF 2147483647
using namespace std;
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
int s, w; char ch;
inline int read(){
	s = 0; ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar(); 
	while(ch >= '0' && ch <= '9'){ s = s * 10 + ch - '0'; ch = getchar();}
	return s;
}
const int MAXN = 100010;
struct Edge{
	int next, to;
}e[MAXN << 1];
int head[MAXN], num, a[MAXN], size[MAXN], f[MAXN], val[MAXN], dep[MAXN], son[MAXN], Sson[MAXN], A, B, n, root, ans = INF, cut;
inline void Add(int from, int to){
	e[++num].to = to; e[num].next = head[from]; head[from] = num;
	e[++num].to = from; e[num].next = head[to]; head[to] = num;
}
int getsize(int u, int fa){
	size[u] = a[u]; f[u] = fa; dep[u] = dep[fa] + 1;
	for(int i = head[u]; i; i = e[i].next)
		if(e[i].to != fa){
			getsize(e[i].to, u);
			size[u] += size[e[i].to];
			val[u] += val[e[i].to] + size[e[i].to];
			if(size[e[i].to] > size[son[u]]){
              Sson[u] = son[u];
              son[u] = e[i].to;
            }
            else if(size[e[i].to] > size[Sson[u]])
              Sson[u] = e[i].to;
		}
}
void getans(int u, int now, int all, int &res){
    res = min(res, now);
    int v = son[u];
    if(v == cut || size[Sson[u]] > size[son[u]]) v = Sson[u];   //如果size变化后次大大于最大
    if(!v) return;
    if(size[v] * 2 > all) getans(v, now + all - size[v] - size[v], all, res);  //如果size[v]*2<=all就没有继续往下走的意义了，因为此时u一定最优
}
int solve(int u){
    for(int i = head[u]; i; i = e[i].next)
       if(e[i].to != f[u]){
         cut = e[i].to;  //断边
         A = B = INF;
         for(int now = u; now; now = f[now]) size[now] -= size[e[i].to];  //自下而上修改其父亲size
         getans(1, val[1] - val[e[i].to] - dep[e[i].to] * size[e[i].to], size[1], A);
         getans(e[i].to, val[e[i].to], size[e[i].to], B);    //求两个集合的答案
         ans = min(ans, A + B);
         for(int now = u; now; now = f[now]) size[now] += size[e[i].to];   //回溯
         solve(e[i].to);
       }
}
int main(){
	//Open("practice");
	n = read(); dep[0] = -1;
	for(int i = 1; i < n; ++i) Add(read(), read());
	for(int i = 1; i <= n; ++i) a[i] = read();
	getsize(1, 0);
	solve(1);
	printf("%d\n", ans);
	return 0;
}

```

---

## 作者：George1123 (赞：8)

[$\Huge\color{#ff33aa}{\tt My~Cnblogs}$](https://www.cnblogs.com/Wendigo/p/13043587.html)

---
> [SHOI2005 树的双中心](https://www.luogu.com.cn/problem/P2726)

> 给树 $T=(V,E)(|V|=n)$，树高为 $h$，$w_u(u\in V)$。求 $x\in V,y\in V:\left(\sum_{u\in V}w_u\cdot \min(dis_{u,x},dis_{u,y})\right)_{\min}$。

> 数据范围：$1\le n\le 50000$，$1\le h\le 100$。

---
**一眼思路：把 $T$ 由一条边砍成 $T_1,T_2$，$x$ 为 $T_1$ 重心，$y$ 为 $T_2$ 重心。**

所以可以暴力枚举那条断边，然后找两棵树重心，合并答案。

---
**先问个问题：一棵带点权的树怎么找重心？**

即 [洛谷P1364 医院设置](https://www.luogu.com.cn/problem/P1364)。

带点权树的重心 $x$ 满足 $f_x=\sum_{u\in V}w_u\cdot dis_{u,x}$ **最小。**

暂定 $1$ 为根，记录 $sz_i$ 表示节点 $i$ 的子树的权值 $w$ 和。

所以 $f_1=\sum_{u\in V}w_u\cdot (dep_u-dep_1)$。

$$v\in son_u:f_v=f_u+(sz_1-sz_v)-sz_v$$

> 这是换根 $\tt dp$。“重心”往下挪，**上面的节点要多走一步，下面的节点少走一步。**

然后 $f_i$ 最小的 $i$ 就是重心。

---
**这题也用到了类似的思想：**

令 $g_i=\sum_{u\in subtree_i}w_u\cdot dis_{u,i}$，很明显上文的 $f_1=g_1$。

$$\therefore g_u=\sum_{v\in son_u}g_v+sz_v$$

> 很明显吧，每个子节点答案加再走一条边的贡献。

令 $sf_i$ 为 $i$ 的**子树最大子节点**，$sc_i$ 为 $i$ 的**子树次大子节点**。

设断边为 $(a,b)$，其中 $dep_b>dep_a$。

同样令 $1$ 为根，同样维护 $sz_i$。

所以 $T_1$ 的根为 $1$，$T_2$ 的根为 $b$。

$\Theta(h)$ 让 $sz_i$ 变为 $T_1,T_2$ 内的子树权值和：

$\forall p\in ancestor_b:sz_p-=sz_b$

设 $now_1=\sum_{u\in V_1}w_u\cdot dis_{u,1}=g_1-g_b-sz_b(dep_b-dep_1),now_2=\sum_{u\in V_2}w_u\cdot dis_{u,b}=g_b$

$T_1,T_2$ 中的节点 $i$ **子树最大子节点**必为原 $sf_i,sc_i$ 中的一个。

再看看上面的式子：

$$v\in son_u:f_v=f_u+(sz_{rt}-sz_v)-sz_v$$

所以 $f_v<f_u$ 当 $sz_{rt}<2sz_v$。

可以从各自的根节点出发，摸着**最大子树子节点**找 $T_1,T_2$ 的重心，答案可以由上面的 $now$ 递推。

---
**时间复杂度 $\Theta(nh)$。**

---
- **代码**

上面的内容看不懂就算了，读读这代码吧。。。

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define b(a) a.begin()
#define e(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=5e4;
int n,w[N+7];
vector<int> e[N+7];

//TreeDP
int dep[N+7],sz[N+7],fa[N+7],f[N+7],sf[N+7],sc[N+7];
void Dfs1(int u){
	sz[u]=w[u],dep[u]=dep[fa[u]]+1;
	for(int&v:e[u])if(v!=fa[u]){
		fa[v]=u,Dfs1(v),sz[u]+=sz[v],f[u]+=f[v]+sz[v]; //f就是g
		if(sz[v]>sz[sf[u]]) sc[u]=sf[u],sf[u]=v;
		else if(sz[v]>sz[sc[u]]) sc[u]=v;
	}
}
int cut;
void Dfs2(int u,int now,int sm,int&res){
	res=min(res,now);
	int v=(sf[u]==cut||sz[sc[u]]>sz[sf[u]])?sc[u]:sf[u]; //v为u最大子树子节点
	if(v&&2*sz[v]>sm) Dfs2(v,now+sm-2*sz[v],sm,res);
}
void Dfs3(int u,int&res){
	for(int&v:e[u])if(v!=fa[u]){
		cut=v;
		int up=inf,down=inf;
		for(int p=u;p;p=fa[p]) sz[p]-=sz[v];
		Dfs2(1,f[1]-f[v]-(dep[v]-dep[1])*sz[v],sz[1],up);
		Dfs2(v,f[v],sz[v],down);
		res=min(res,up+down);
		for(int p=u;p;p=fa[p]) sz[p]+=sz[v]; //回溯
		Dfs3(v,res);
	}
}

//Main
int main(){
	scanf("%d",&n);
	for(int i=1,u,v;i<=n-1;i++) scanf("%d%d",&u,&v),e[u].pb(v),e[v].pb(u);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	int ans=inf; Dfs1(1),Dfs3(1,ans),printf("%d\n",ans);
	return 0;
} 
```
---
**祝大家学习愉快！**

---

## 作者：iamzq (赞：8)

# 关于 $O(n^{2})$ 做法的证明

前面的题解关于 $O(n^{2})$ 做法的优化讲的已经非常清楚了，但是 $O(n^{2})$ 的做法基本都是一句话。然而 $O(n^{2})$ 的做法似乎并不显然，因为通过割边算出来的答案并不是一定合法。就比如：

![](https://cdn.luogu.com.cn/upload/image_hosting/g8tercao.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

当拆红边时，假如两棵树的重心分别为1和6，那么对于3，它离1更近，但是计算时会将3与6连来计算答案，显然答案会偏大。该如何证明答案一定能通过枚举边来计算出正确答案？

## 引理：
对于任意树上两点x，y，满足 $d(v,x) \geq d(v,y)$ 的点集 $V_1$ 一定是连通的，满足 $d(v,x) > d(v,y)$ 的点集 $V_2$ 也是连通的。其中 $d(a,b)$ 表示a到b的距离

这个很好证，首先 $x$ 到 $y$ 中间只有一条简单路径，找出在这条路径上的点满足 $d(v,x) \leq d(v,y)$ ，与这些点相连通的点显然满足此式，而与这条路径的其余点相连通的点显然不满足。

我们将这条路径上连接 $v_1$ 与 $v_2(v_1\in V_1,v_2\in V_2)$ 的边称为**关建边**，现在考虑切这条边。

设 $x_0,y_0$ 为两棵树后的重心。

$$\sum_{v \in V_1}{w(v) \cdot d(x,v)} \geq \sum _{v \in V_1}{w(v)\cdot d(x_0,v)}$$

$$\sum_{v \in V_2}{w(v) \cdot d(y,v)} \geq \sum _{v \in V_2}{w(v)\cdot d(y_0,v)}$$

两式相加，得

$$S(x,y) = \sum_{v \in V_1}{w(v) \cdot d(x,v)}+ \sum_{v \in V_2}{w(v) \cdot d(y,v)}$$

$$\geq \sum _{v \in V_1}{w(v)\cdot d(x_0,v)} + \sum _{v \in V_2}{w(v)\cdot d(y_0,v)}$$

$$\geq \sum_{v \in V_1}{w(v)\cdot min\{d(x_0,v),d(y_0,v)\}} + \sum_{v\in V_1}{w(v)\cdot min\{d(x_0,v),d(y_0,v)\}}$$

$$=S(x_0,y_0)$$

因此
$$min\{S(x,y)\} \geq \{S(x_0,y_0)\}$$

又显然 $\{(x_0,y_0)\} \subseteq \{(x,y)\}$ ,所以

$$min\{S(x_0,y_0)\} \geq min\{S(x,y)\}$$

所以
$$min\{S(x_0,y_0)\} = min\{S(x,y)\}$$

即此解法算出的最小值=答案

最后感谢 [@abs001](https://www.luogu.com.cn/user/98468)提供的证明，由于~~此人太巨~~此人不想打题解，所以让我来打证明

（标程就不放了，看上面的题解）

---

## 作者：EternalEpic (赞：8)

首先，我们会有一个很简单的想法，枚举断边，产生两棵子树，然后在两棵树内分别求带权重心，计算贡献，这样的话复杂度是 $O(n^2)$ 的。

那么我们要好好利用 $h \leq 100 $ 的性质。

考虑 $sze[u]$ 为带权重量，$g[u]$ 为以 $u$ 为根的树，所有点都到 $u$ 的代价。

所以 $g[u] = \sum\limits_{v\in{son(u)}}{g[v] + sze[v]}$

考虑 $f[u]$ 为 $u$ 在的一棵树中，所有点到 $u$ 的总代价。

由于计算是动态的，我们考虑转移。

对于 $v \in son(u)$ 有 $f[v] = f[u] + (S - sze[v]) - sze[v]$

如果 $v$ 比 $u$ 更优，当且仅当 $2 * sze[v] > S$

我们发现，只有两个候选项，重儿子和次重儿子。递归时顺带维护变化即可。

最坏情况可能会是一条到底的链，所以复杂度 $O(nh)$

### code: ###

```cpp
const int Maxn = 5e5 + 5, Maxm = 1e6 + 5;
int n, cnt = 0, w[Maxn], head[Maxn], ver[Maxm], nxt[Maxm];
inline void AddEdge(int u, int v) {
	ver[++cnt] = v, nxt[cnt] = head[u], head[u] = cnt;
	ver[++cnt] = u, nxt[cnt] = head[v], head[v] = cnt;
}

int dep[Maxn], fat[Maxn], son[Maxn], son2[Maxn];
int sze[Maxn], g[Maxn], cut, ans = INT_MAX;
inline void DfsFir(int u) {
	sze[u] = w[u];
	for (int i = head[u]; i; i = nxt[i]) {
		if (ver[i] == fat[u]) continue;
		dep[ver[i]] = dep[u] + 1; fat[ver[i]] = u;
		DfsFir(ver[i]); sze[u] += sze[ver[i]];
		g[u] += g[ver[i]] + sze[ver[i]];
		if (sze[ver[i]] > sze[son[u]]) son2[u] = son[u], son[u] = ver[i];
		else if (sze[ver[i]] > sze[son2[u]]) son2[u] = ver[i];
	}
}

inline void getans(int u, int val, int all, int &ret) {
	chkmin(ret, val); int v = son[u];
	if (v == cut || sze[son[u]] < sze[son2[u]]) v = son2[u];
	if (!v) return;
	if (2 * sze[v] > all) getans(v, val + all - 2 * sze[v], all, ret);
}

inline void DfsSec(int u) {
	for (int i = head[u]; i; i = nxt[i]) {
		if (ver[i] == fat[u]) continue;
		cut = ver[i]; int x = INT_MAX, y = INT_MAX;
		for (int pos = u; pos; pos = fat[pos]) sze[pos] -= sze[ver[i]];
		getans(1, g[1] - g[ver[i]] - dep[ver[i]] * sze[ver[i]], sze[1], x);
		getans(ver[i], g[ver[i]], sze[ver[i]], y); chkmin(ans, x + y);
		for (int pos = u; pos; pos = fat[pos]) sze[pos] += sze[ver[i]];
		DfsSec(ver[i]);
	}
}

signed main(void) {
//	file("");
	read(n);
	for (int i = 1, u, v; i < n; i++)
		read(u), read(v), AddEdge(u, v);
	for (int i = 1; i <= n; i++) read(w[i]);
	DfsFir(1); DfsSec(1); writeln(ans);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：ZCETHAN (赞：6)


# 题目大意
给定一棵无根树，函数$S(x,y)=\sum\limits_{v\in V}(W(v)*min(d(x,v),d(y,v)))$,其中$V$是点集，$W(v)$是$v$点的权值，$d(x,y)$表示树上两点之间的距离。
求当$x$和$y$取多少时，$S(x,y)$能取到最小值，并输出这个最小值。
# Solution
首先需要统一的是，$W(v)$是一定的，所以如果只有$1$个点时，就必定取重心。


然而题目中是$2$个点，但是$S(x,y)$的含义还是和重心所差无几。一旦选中了$x,y$，那么整棵树的点集就分成了到$x$点和到$y$点两部分，而这两部分一定是内部互相连通的，所以开始的时候不妨把它看做是切成$2$棵子树，然后对于每棵子树都求一下重心，作为$x,y$。


读题后发现，树的高度最大是$100$，利用这一特性，如果我们可以在$O(h)$的范围内求解任意子树的重心，那么这题就得解了。我们可以枚举断边，然后对于每次断边，分别求出两棵子树的重心，然后更新答案。

- **那么可以在$O(h)$内求解重心吗？**

- **可以的！**

首先设$f(u)$表示整棵树中**所有节点**到$u$的距离和(当然要乘上点权)，$siz[u]$表示$u$的**子树**大小，$v$为$u$的一个儿子，则可以递推：
$$f(v)=f(u)+siz[root]-siz[v]-siz[v]$$
解释：当点下移了一格后，除了$v$的子树内的点，其它都多走了一格，所以要加上$siz[root]-siz[v]$，但是$v$为根的子树内所有点可以少走一格，所以减去$siz[v]$。

那么根据重心的性质，如果$v$比$u$更适合当重心，那么有$f(v)<f(u)$
即

$$f(u)+siz[root]-2*siz[v]<f(u)$$

可知，当

$$siz[root]<2*siz[v]$$

时，才有向下走的必要。

又由于，重心中最大的子树不会超过总节点数的一半，所以满足$siz[root]<2*siz[v]$的节点数不会超过$1$个，所以从根开始，每次走子树最大的儿子，直到不满足不等式，之前$f(u)$最大的那个点就是重心。

综上，可以得出这题的解法：

- $stp1\quad$ 先$dfs$预处理出以下信息：
子树大小$siz[u]$，深度$dep[u]$，子树中所有点到当前点的距离和$dp[u]$，每个节点的父亲$fa[u]$。
每个节点所有儿子中子树最大的编号$id1[u]$与次大的编号$id2[u]$。(为什么要次大，后面会讲)。
- $stp2\quad$ 然后枚举切断的边，记断边相连的深度大的那个点是$cut$，然后从$cut$开始，向父亲迭代，并更新父亲的$siz[u]$的值。
- $stp3\quad$ 然后计算答案，可以用递归记录信息。

```cpp
int ret=inf,ct;
void dfs1(int x,int cur,int S){//x：当前节点		cur：当前答案	S：切断后x所在树的总的大小
	ret=min(ret,cur);
	int s=id1[x];
	if(s==ct||siz[s]<siz[id2[x]]) s=id2[x];//如果最大的儿子被破坏或者被切断，则退取次大的儿子
	if(!s) return;
	if(S<2*siz[s])
		dfs1(s,cur+S-2*siz[s],S);//只有满足条件才有必要递归，并利用上面的递推式得出答案
}

ret=inf;dfs1(1,dp[1]-dp[i]-siz[i]*dep[i],siz[1]);A=ret;
//处理上方的那棵树，此时f[1]=dp[1]-dp[i]-siz[i]*dep[i],不理解的先看着
ret=inf;dfs1(i,dp[i],siz[i]);B=ret;
//处理下方的
```
- $stp4\quad$ 更新历史最优值，再次从切点开始向父亲迭代，回溯，调到$stp2$
- $stp5\quad$ 输出答案，结束。

对于式子$f[1]=dp[1]-dp[i]-siz[i]*dep[i]$，就是如果只有$f[1]=dp[1]-dp[i]$容易理解少考虑了子树$i$的深度，那么全体乘上深度即可。
# Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1<<30
using namespace std;
const int MAXN=5e4+10;
vector<int> e[MAXN];
int w[MAXN];
int dp[MAXN],f[MAXN],dep[MAXN];
int siz[MAXN],id1[MAXN],id2[MAXN];
void dfs(int x,int fa){
	f[x]=fa;
	siz[x]=w[x];int s1=0,s2=0;
	for(int i=0;i<e[x].size();i++){
		int s=e[x][i];
		if(s==fa) continue;
		dep[s]=dep[x]+1;
		dfs(s,x);
		siz[x]+=siz[s];
		dp[x]+=dp[s]+siz[s];
		if(siz[s]>s1){
			s2=s1,s1=siz[s];
			id2[x]=id1[x],id1[x]=s;
		}
		else if(siz[s]>s2)
			s2=siz[s],id2[x]=s;
	}
}
int ret=inf,ct;
void dfs1(int x,int cur,int S){
	ret=min(ret,cur);
	int s=id1[x];
	if(s==ct||siz[s]<siz[id2[x]]) s=id2[x];
	if(!s) return;
	if(S<2*siz[s])
		dfs1(s,cur+S-2*siz[s],S);
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=n;i++)
		scanf("%d",&w[i]);
	dfs(1,-1);
	int ans=inf;
	for(int i=2;i<=n;i++){
		for(int j=f[i];j!=-1;j=f[j]) siz[j]-=siz[i];
		int A,B;ct=i;
		ret=inf;dfs1(1,dp[1]-dp[i]-siz[i]*dep[i],siz[1]);A=ret;
		ret=inf;dfs1(i,dp[i],siz[i]);B=ret;
		ans=min(ans,A+B);
		for(int j=f[i];j!=-1;j=f[j]) siz[j]+=siz[i];
	}printf("%d\n",ans);
}
```


---

## 作者：Rosmarinus (赞：5)

## 题意简述

给定一棵树 $T=(V,E)$，其中 $V$ 为节点集合，$E$ 为边集合，对于 $V$ 中的每个节点 $v$，有一个权值函数 $W(v)$，该函数的值均为正整数，记 $d(u,v)$ 为节点 $u$ 和 $v$ 之间的距离，表示他们之间唯一的一条路径的边数。若 $u$ 和 $v$ 为同一个节点，则 $d(u,v)=0$。你的任务是找出两个不同的节点 $x,y$，使得以下表达式 $S(x,y)$ 最小：

$$S(x,y)=\sum\limits_{v\in V}(W(v)\times min(d(x,v),d(y,v)))$$

用人话讲就是：给定一颗无根数，在树中取两个点，让其他所有点「到这两个点的较小距离」的和最小。

## 思路分析

看题目第一眼，大部分人都会有个大致思路：
1. 将原树分成两个树；
2. 分别找到两个树的重心；
3. 求和。

分析一下复杂度，操作 $1$ 为 $O(n)$ 无疑，操作 $2,3$ 如果是 dfs 的话也是 $O(n)$。

显然 $O(n^2)$ 对于 $1 < N\le 5\times 10^4$ 这个数据范围来说实在是有点太大了，所以我们使用 DP 来做。

于是，枚举 $+$ DP，思路通。

## 方法解析

先来复习一下树的重心的性质：
> 重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

显然，「将重心删除后剩余各个连通块中点数的最大值」一定小于「树的总结点个数的一半」。

----------

因此：

- 当我们在找重心时，若当前节点编号为 $u$，那么我们每次只要往 $u$ 的最大子树走即可；并且，只有当 $u$ 的「最大子树个数」$>$「此树总结点个数的一半」，我们才有继续走下去的必要。

于是，这样的时间复杂度就会大大降低，再加上一点预处理，便能够再足够短的时间内得出答案。

----------

接下来看转移方程：

我们先人为设树的根节点为 $root$。

设「树中所有点到 $i$ 的价值之和」为 $dp_i$。

即「树中每一个点的点权 $\times$ 此点到 $i$ 的距离」 为 $dp_i$。

------------

若 $t$ 是 $u$ 的子节点。

考虑：如何在已知 $dp_u$ 的情况下得出 $dp_t$。

通过思考我们可以发现，$t$ 相比 $u$，所有在 $u$ 这一边的节点都多走了一步，所有在 $t$ 这一边的节点都少走了一步。

设树中节点 $i$ 的子树的点权和（包括 $i$）为 $siz_i$，此树的总节点的点权和为 $cnt$。

那么：
- 所有在 $t$ 这一边的节点的点权和便为 $siz_t$；  
  所有在 $u$ 这一边的节点的点权和便为 $cnt - siz_t$。

于是便可得转移方程：
$$siz_t = siz_u + (cnt - siz_t) - siz_t$$
即为：
$$siz_t = siz_u + cnt - 2 \times siz_t$$

---------------------

我们再来考虑一些特殊情况：一个点的最大子树被切，导致其不再是最大子树。
这个其实很好考虑，只要再存储一个次大子树做「备胎」即可。

然后考虑，当一条边被砍掉之后会发生什么。

设在上面的树为 $A$，在下面的为 $B$。

易得：$A$ 中的 $siz$、$dp$ 均会发生变化。

我们还是设「断边」上面的节点为 $u$，下面的节点为 $t$。

对于 $siz$ 来说，$u$ 的所有「祖先节点」都失去了以 $t$ 为根的子树。

对于 $dp$ 来说，由于我们总是从一个根节点开始递归找重心，于是我们只要知道 $dp[1]$ 的变化值即可。

对于 $dp[1]$，先前有 $siz_t$ 个节点会走到 $root$，而现在没有了。

因此我们设 $i$ 节点的深度为 $dep_i$（$root$ 的深度为0），则有：

$$dp[1] = dp[1] - siz_t \times dep_t$$

------------------------

**最后，我们要预处理的数组为**：

- $dep_i$ —— $i$ 号节点的深度；
- $fa_i$ —— $i$ 号节点的父亲节点；
- $maxs_i$ —— $i$ 号节点的最大子树大小；
- $maxnum_i$ —— $i$ 号节点的最大子树编号；
- $remax_i$ —— $i$ 号节点的次大子树大小；
- $remaxnum_i$ —— $i$ 号节点的次大子树编号；
- $siz_i$ —— $i$ 号节点的所有子节点的权值之和；
- $dp_i$ —— 所有点到 $i$ 的价值之和。

## AC代码

```cpp
/* Code by Rosmarinus */

#include<iostream>
#include<vector>
#include<cstdio>
using namespace std;

const int N = 51000;
const int inf = 0x7f7f7f7f;

vector<int>side[N];
int val[N], dep[N], fa[N], maxs[N], maxnum[N], remax[N], remaxnum[N];
int siz[N], dp[N], d, ret;

void pre(int u, int father, int depth) // 预处理
{
    int S = side[u].size();
    fa[u] = father, siz[u] = val[u], dep[u] = depth;
    for(int i = 0; i < S; i ++)
    {
        int t = side[u][i];
        if(t == father) continue;

        pre(t, u, depth + 1);

        siz[u] += siz[t];
        dp[u] += dp[t] + siz[t];

        if(siz[t] > maxs[u])
        {
            remax[u] = maxs[u];
            remaxnum[u] = maxnum[u];
            maxs[u] = siz[t];
            maxnum[u] = t;
        }
        else if(siz[t] > remax[u])
        {
            remax[u] = siz[t];
            remaxnum[u] = t;
        }
    }
}

void dfs(int u, int s, int cnt)
{
    d = min(d, s);
    int t = maxnum[u];
    if(t == ret || siz[t] < siz[remaxnum[u]]) t = remaxnum[u]; // 之前的最大子树可能不再是现在的最大子树了
    if(t && 2 * siz[t] > cnt) dfs(t, s + cnt - 2 * siz[t], cnt);
}

int main()
{
    int n, x, y, ans = inf;

    scanf("%d", &n);

    for(int i = 1; i < n; i ++)
    {
        scanf("%d %d", &x, &y);
        side[x].push_back(y), side[y].push_back(x);
    }
    for(int i = 1; i <= n; i ++) scanf("%d", &val[i]);
    
    pre(1, 0, 0);
    
    for(int i = 2; i <= n; i ++)
    {
        for(int p = fa[i]; p > 0; p = fa[p]) siz[p] -= siz[i];
        d = inf, ret = i;

        dfs(1, dp[1] - dp[i] - siz[i] * dep[i], siz[1]);

        int a = d;
        d = inf;

        dfs(i, dp[i], siz[i]);
        ans = min(ans, a + d);

        for(int p = fa[i]; p > 0; p = fa[p]) siz[p] += siz[i];
    }

    cout << ans << endl;
    return 0;
}
```

---

## 作者：1234567_scp (赞：3)

我们可以先看一下这道题：[CSP2019树的重心](https://www.luogu.com.cn/problem/P5666)

我们考虑 $O(n\log n)$ 的做法。

我们先换一个重心为根。

我们定义：

- $a_i$ 表示点 $i$ 的非根最远祖先
- $d_i$ 表示点 $i$ 的深度
- $T_i$ 表示点 $i$ 的子树，$\overline{T_i}$ 表示树除了$T_i$的部分
- $G_i$ 表示 $T_i$ 的重心，$\overline{G_i}$表示 $\overline{T_i}$ 的重心
- $s_i$ 表示点 $i$ 子树的权值和
- $t_i$ 表示 $\sum\limits_{j\in T_i}dis(i, j)\cdot w_i$
- $T_i-T_j$ 表示 $\{i\ |\ i\in T_i\land i\not\in T_j \}$

- $f_i$ 表示 $i$ 的父节点

预处理复杂度为 $O(n\log n)$(参考树的重心)。

首先，原式=

$\min\limits_{rt\in T,x\in T_{rt},y\in\overline{T}_{rt}}(\sum\limits_{i\in T_{rt}}dis(x,i)\cdot w_i+\sum\limits_{i\in \overline{T}_{rt}}dis(y,i)\cdot w_i)$

令：$F(x,rt)=\begin{cases}\sum\limits_{i\in T_i}dis(x,i)\cdot w_i&x\in T_{rt}\\\sum\limits_{i\in \overline{T}_{rt}}dis(x,i)\cdot w_i&x\in \overline{T}_{rt}\end{cases}$

则上式=$\min(F(x,rt)+F(y,rt))$.

我们先观察 $F(x,rt)\ \ (x\in T_{rt})$：

该式  
  $=\sum\limits_{i\in T_x}dis(i,x)\cdot w_i+\sum\limits_{i\in(T_{f_x}-T_x)}dis(i, x)\cdot w_i$

 $=\sum\limits_{i\in T_x}(dis(i,f_x)-1)\cdot w_i+\sum\limits_{i\in(T_{f_x}-T_x)}(dis(i, f_x)+1)\cdot w_i$
 
 $= F(f_x,rt)+s_{rt}-2s_x$
 
 可知若在 $x$ 处取到最值，则 $2s_x\ge s_{rt}$.
 
 且$\forall f_i=x,2s_i\le s_{rt}$.
 
 故 $x$ 为 $G_{rt}$。
 
且 $F(x,rt)$

$=F(x,f_{rt})-\sum\limits_{i\in (T_{f_{rt}}-T_{rt})}dis(i, x)\cdot w_i$

$=F(x,f_{rt})-t_{f_{rt}}+t_{rt}+(d_x-d_{rt}+2)s_{rt}-(d_x-d_{rt}+1)s_{f_{rt}}$

同理，$x\not\in T_{rt}$ 时，有：

$F(x,rt)=F(f_x,rt)+s_G-s_{rt}-2s_x$

$F(x,rt)=F(x,f_{rt})+\sum\limits_{i\in (T_{f_{rt}}-T_{rt})}dis(i, x)\cdot w_i$

$=F(x,f_{rt})+t_{f_{rt}}-t_{rt}-(d_x-d_{rt}+2)s_{rt}+(d_x-d_{rt}+1)s_{f_{rt}}$

可知此时 $x$ 也是 $\overline{T}_{rt}$ 的重心。

若每次选 $F(rt,rt)$ 和 $F(G,rt)$ 为初始条件，复杂度 $O(n(\log n+H))$。

因为重心必在重链上，我们发现：当 $rt$ 在轻链上向下运动时，$G_{rt}$ 向下运动，$\overline G_{f_{rt}}$沿重链向上运动。

当 $rt$ 在重链上向下运动时，$G_{rt}$向下运动，$\overline G_{f_{rt}}$ 沿 $G$ 的次重儿子的重链(包括$G$)向上运动。

重链剖分+拓扑排序后，每一条链 $L$，若 $rt\in L$，$G_{rt}\in L\land d_{G_{rt}}\ge d_{rt}$.

对每条链，双指针扫一扫即可得 $F(G_{rt},rt)$。

对于 $F(\overline G_{rt},rt)$ 因为 $\overline G_{rt}$ 必在重链或 $G$ 次重儿子重链上，故我们预处理出 $F(\overline G_{rt},a_{\overline G_{rt}})$.

$F(\overline G_{rt},rt)=F(\overline G_{rt},a_{\overline G_{rt}})+t_G-t_{rt}-(d_{rt}-1)s_{rt}+(d_{\overline G_{rt}}-1)(s_G-s_{rt}-s_{a_{\overline G_{rt}}})-t_{a_{\overline G_{rt}}}-s_{a_{\overline G_{rt}}}$.

则原式可 $O(n\log n)$ 求出(用map)，且预处理复杂度 $O(n\log n)$，总复杂度 $O(n\log n)$ ~~但常数巨大~~。

我们考虑 $O(n)$

我们用双指针扫出 $G_i$，复杂度 $O(n)$

但如此方法对带权树，复杂度会退化为 $O(n^2)$

发现：若 $x=\overline G_i$，只需满足 $2s_{h_x}\le s_G-s_i \le 2s_x$

故 $\overline G_i$ 与 $s_i$ 有关，与 $i$ 具体是那个点无关。

故将 $i$ 按 $s_i$ 从小到大排序，$e_i$ 表示排序后第 $i$ 个点，使用基排即可优化成 $O(n)$ ，再双指针扫即可, 此时令$j\in L_2$，$k\in L_1$，均单调从 $G$ 向下走。

上代码：

$O(n(\log n+H))$：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll fcin() {
	ll r=0;
	bool s=0;
	char c=getchar();
	for(; c<48||c>57; c=getchar()) s^=c=='-';
	for(; c>47&&c<58; c=getchar()) r=r*10+c-48;
	return s? -r: r;
}
char out[20];
int otop;
inline void fcout(ll x, char c) {
	if (x<0) putchar('-'), x=-x;
	if (!x) putchar('0');
	for(otop=0; x; x/=10, ++otop)
		out[otop]=x%10+48;
	for(--otop; otop>=0; --otop)
		putchar(out[otop]);
	putchar(c);
}
const int N=50001;
const ll inf=1e18;
int n, G, _h, ans;
ll sum, tmp, pos, sol=inf, s[N], t[N], F[N], w[N];
int he[N<<1], ne[N<<1], te[N<<1], cnt, tar;
int a[N], b[N], d[N], f[N], g[N][5], h[20][N], l2[N];
inline void con(int x, int y) {
	ne[++cnt]=he[x], te[he[x]=cnt]=y;
	ne[++cnt]=he[y], te[he[y]=cnt]=x;
}
inline void walk(int x) {
	s[x]=w[x];
	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x])
			f[te[i]]=x, walk(te[i]), s[x]+=s[te[i]];
}
inline void dfs(int x) {
	s[x]=w[x], b[x]=d[x]=d[f[x]]+1, a[x]=f[x]==G? x: a[f[x]];
	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x]) {
			f[te[i]]=x, dfs(te[i]), s[x]+=s[te[i]], t[x]+=t[te[i]]+s[te[i]];
			if (b[x]<b[te[i]]) b[x]=b[te[i]];
			if (s[te[i]]>s[h[0][x]])
				h[0][x]=te[i];
		}
}
inline int acc(int x, int y) {
	return max(s[x]-s[y], s[h[0][y]]);
}
inline int cal(int x, int y) {
	if (y==G) return a[x]==h[0][G]? max(s[h[0][G]]-s[x], s[_h]): s[h[0][G]];
	return a[x]==a[y]? s[G]-s[y]: max(s[G]-s[x]-s[y], s[h[0][y]]);
}
inline void ins(int x, int y) {
	if (y&&acc(x, y)<=s[x]>>1)
		g[x][++g[x][0]]=y;
}
inline void add(int x, int y) {
	if (y&&cal(x, y)<=(s[G]-s[x])>>1)
		g[x][++g[x][0]]=y;
}
inline void dp(int x) {
	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x])
			dp(te[i]);
	if (x==G) return;
	ans=x;
	for(int i=l2[h[0][x]? d[g[h[0][x]][1]]-d[x]: 1]; i>=0; i--)
		if (h[i][ans]&&acc(x, f[h[i][ans]])>=acc(x, h[i][ans])&&h[i][ans])
			ans=h[i][ans];
	ins(x, f[ans]), ins(x, ans), ins(x, h[0][ans]), ins(x, h[1][ans]), g[x][0]=2;
	if (cal(x, G)<=(s[G]-s[x])>>1)
		add(x, G), add(x, h[0][G]), add(x, _h);
	else {
		ans=h[0][x]&&g[h[0][x]][g[h[0][x]][0]]!=G? g[h[0][x]][g[h[0][x]][0]]: a[x]==h[0][G]? _h: h[0][G];
		for(int i=l2[b[ans]-d[ans]]; i>=0; i--)
			if (h[i][ans]&&cal(x, f[h[i][ans]])>=cal(x, h[i][ans]))
				ans=h[i][ans];
		add(x, f[ans]), add(x, ans), add(x, h[0][ans]), add(x, h[1][ans]);
	}
}
inline void solve1(int rt, int x) {
	F[x]=x==rt? t[x]: F[f[x]]+s[rt]-2*s[x];
	if (x!=g[rt][1]) solve1(rt, h[0][x]);
}
inline void solve2(int rt, int x) {
	F[x]=x==G? t[G]-t[rt]-(d[rt]-1)*s[rt]: F[f[x]]+s[G]-s[rt]-2*s[x];
	if (x!=g[rt][3]) solve2(rt, x==G&&a[rt]==h[0][x]? _h: h[0][x]);
}
int main() {
	cnt=sum=G=_h=0, tmp=inf, n=fcin();
	for(int i=2; i<=n; i++)
		l2[i]=l2[i>>1]+1, con(fcin(), fcin());
	for(int i=1; i<=n; i++)
		w[i]=fcin();
	walk(1);
	for(int x=1; x<=n; x++) {
		pos=s[1]-s[x];
		for(int i=he[x]; i; i=ne[i])
			if (te[i]!=f[x]&&pos<s[te[i]])
				pos=s[te[i]];
		if (tmp>pos)
			tmp=pos, G=x;
	}
	f[G]=0, dfs(G);
	for(int i=1; i<=l2[n]; i++)
		for(int j=1; j<=n; j++)
			h[i][j]=h[i-1][h[i-1][j]];
	for(int i=he[G]; i; i=ne[i])
		if (s[te[i]]>s[_h]&&te[i]!=h[0][G])
			_h=te[i];
	dp(G);
	for(int i=1; i<=n; i++)
		if (i!=G) {
			solve1(i, i), solve2(i, G);
			if (sol>F[g[i][1]]+F[g[i][3]])
				sol=F[g[i][1]]+F[g[i][3]], tar=i;
		}
	fcout(sol, '\n');
	return 0;
}
```
$O(n\log n)$：（各部分复杂度见代码）
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll fcin() {
	ll r=0;
	bool s=0;
	char c=getchar();
	for(; c<48||c>57; c=getchar()) s^=c=='-';
	for(; c>47&&c<58; c=getchar()) r=r*10+c-48;
	return s? -r: r;
}
char out[20];
int otop;
inline void fcout(ll x, char c) {
	if (x<0) putchar('-'), x=-x;
	if (!x) putchar('0');
	for(otop=0; x; x/=10, ++otop)
		out[otop]=x%10+48;
	for(--otop; otop>=0; --otop)
		putchar(out[otop]);
	putchar(c);
}
const int N=100001;
const ll inf=1e18;
int n, G, _h, ans;
ll sum, tmp, pos, sol=inf, s[N], t[N], w[N];
int he[N], ne[N<<1], te[N<<1], cnt, tar;
int a[N], b[N], c[N], d[N], f[N], g[N][5], h[20][N], l2[N];
inline void con(int x, int y) {
	ne[++cnt]=he[x], te[he[x]=cnt]=y;
	ne[++cnt]=he[y], te[he[y]=cnt]=x;
}
inline void walk(int x) {
	if (x==32504)
		++sol;
	s[x]=w[x];
	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x])
			f[te[i]]=x, walk(te[i]), s[x]+=s[te[i]];
}
inline void dfs(int x) {
	s[x]=w[x], b[x]=d[x]=d[f[x]]+1, a[x]=f[x]==G? x: a[f[x]];
	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x]) {
			f[te[i]]=x, dfs(te[i]), s[x]+=s[te[i]], t[x]+=t[te[i]]+s[te[i]];
			if (b[x]<b[te[i]]) b[x]=b[te[i]];
			if (s[te[i]]>s[h[0][x]])
				h[0][x]=te[i];
		}
}
inline int acc(int x, int y) {
	return max(s[x]-s[y], s[h[0][y]]);
}
inline int cal(int x, int y) {
	if (y==G) return a[x]==h[0][G]? max(s[h[0][G]]-s[x], s[_h]): s[h[0][G]];
	return a[x]==a[y]? s[G]-s[y]: max(s[G]-s[x]-s[y], s[h[0][y]]);
}
inline void ins(int x, int y) {
	if (y&&acc(x, y)<=s[x]>>1)
		g[x][++g[x][0]]=y;
}
inline void add(int x, int y) {
	if (y&&cal(x, y)<=(s[G]-s[x])>>1)
		g[x][++g[x][0]]=y;
}
inline void dp(int x) {
	c[++c[0]]=x;
	if (h[0][x]) dp(h[0][x]);
	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x]&&te[i]!=h[0][x])
			dp(te[i]);
	if (x==G) return;
	ans=x;
	for(int i=l2[h[0][x]? d[g[h[0][x]][1]]-d[x]: 1]; i>=0; i--)
		if (h[i][ans]&&acc(x, f[h[i][ans]])>=acc(x, h[i][ans])&&h[i][ans])
			ans=h[i][ans];
	ins(x, f[ans]), ins(x, ans), ins(x, h[0][ans]), ins(x, h[1][ans]), g[x][0]=2;
	if (cal(x, G)<=(s[G]-s[x])>>1)
		add(x, G), add(x, h[0][G]), add(x, _h);
	else {
		ans=h[0][x]&&g[h[0][x]][g[h[0][x]][0]]!=G? g[h[0][x]][g[h[0][x]][0]]: a[x]==h[0][G]? _h: h[0][G];
		for(int i=l2[b[ans]-d[ans]]; i>=0; i--)
			if (h[i][ans]&&cal(x, f[h[i][ans]])>=cal(x, h[i][ans]))
				ans=h[i][ans];
		add(x, f[ans]), add(x, ans), add(x, h[0][ans]), add(x, h[1][ans]);
	}
}
struct cpl{
	int x, rt;
	bool operator < (const cpl& g) const {
		return x<g.x||(x==g.x&&rt<g.rt);
	}
} ;
map<cpl, ll>F;
void ff(int x0, int rt0, int x, int rt) {//(x0, rt0)->(x, rt)
	if (x0!=x)
		for(int _x=h[0][x0]; ; _x=h[0][_x]) {
			F[{_x, rt0}]=F[{f[_x], rt0}]+s[rt0]-2*s[_x];
			if (_x==x) break;
		}
	if (rt0!=rt) F[{x, rt}]=F[{x, rt0}]-t[rt0]+t[rt]+(d[x]-d[rt]+2)*s[rt]-(d[x]-d[rt]+1)*s[rt0];
}
int main() {
	cnt=sum=G=_h=0, tmp=inf, n=fcin();
	for(int i=2; i<=n; i++)//n
		l2[i]=l2[i>>1]+1, con(fcin(), fcin());
	for(int i=1; i<=n; i++)//n
		w[i]=fcin();
	walk(1);//n
	for(int x=1; x<=n; x++) {//n
		pos=s[1]-s[x];
		for(int i=he[x]; i; i=ne[i])
			if (te[i]!=f[x]&&pos<s[te[i]])
				pos=s[te[i]];
		if (tmp>pos)
			tmp=pos, G=x;
	}
	f[G]=0, dfs(G);//n
	for(int i=1; i<=l2[n]; i++)//nlogn
		for(int j=1; j<=n; j++)
			h[i][j]=h[i-1][h[i-1][j]];
	for(int i=he[G]; i; i=ne[i])//n
		if (s[te[i]]>s[_h]&&te[i]!=h[0][G])
			_h=te[i];
	dp(G);//nlogn
	for(int i=1; i<=n; i++)//n
		if (i!=G) F[{i, i}]=t[i];
	for(int x=h[1][G]; x; x=h[0][x])//n
		F[{x, h[0][G]}]=F[{f[x], h[0][G]}]+s[h[0][G]]-2*s[x];
	for(int x=h[0][_h]; x; x=h[0][x])//n
		F[{x, _h}]=F[{f[x], _h}]+s[_h]-2*s[x];
	for(int i=2; i<=n; i++)//nlogn
		if (a[c[i]]==c[i]) ff(c[i], c[i], g[c[i]][1], c[i]);
		else if (f[c[i]]!=c[i-1]) ff(c[i], c[i], g[c[i]][1], c[i]);
		else ff(g[c[i-1]][1], c[i-1], g[c[i]][1], c[i]);
	for(int i=1; i<=n; i++) {//nlogn
		ll pre=F[{g[i][3], a[g[i][3]]}]+t[G]-t[i]-t[a[g[i][3]]]-s[a[g[i][3]]]-(d[i]-1)*s[i]+(d[g[i][3]]-1)*(s[G]-s[i]-s[a[g[i][3]]]);
		if (i!=G&&sol>F[{g[i][1], i}]+pre)
			sol=F[{g[i][1], i}]+pre, tar=i;
	}
	fcout(sol, '\n');
	return 0;
}
```
$O(n)$：
```
#include<bits/stdc++.h>
#define enter putchar('\n')
#define ll long long
using namespace std;
inline ll fcin() {
	ll r=0;
	bool s=0;
	char c=getchar();
	for(; c<48||c>57; c=getchar()) s^=c=='-';
	for(; c>47&&c<58; c=getchar()) r=r*10+c-48;
	return s? -r: r;
}
char out[20];
int otop;
inline void fcout(ll x, char c) {
	if (x<0) putchar('-'), x=-x;
	if (!x) putchar('0');
	for(otop=0; x; x/=10, ++otop)
		out[otop]=x%10+48;
	for(--otop; otop>=0; --otop)
		putchar(out[otop]);
	putchar(c);
}//0.5K
namespace Rsort {//基数排序，signed long long(luogu上普通基排比松基排快)
	const int K=65536, N=50001, lll=65535;
	int he[K], le[K], ne[N], re[N];
	void rsort(ll e[], int r[], int n) {//the element_array, the rank_array(the return array)
		for(int i=0; i<n; i++)
			e[i]+=1ull<<63, r[i]=i;
		for(int j=0; j<K; j++)
			he[j]=-1;
		for(int i=0; i<n; i++)
			if (he[e[r[i]]&lll]==-1)
				re[le[e[r[i]]&lll]=he[e[r[i]]&lll]=i]=r[i], ne[i]=-1;
			else
				re[ne[le[e[r[i]]&lll]]=i]=r[i], ne[le[e[r[i]]&lll]=i]=-1;
		for(int i=0, j=0; j<K; j++)
			for(int l=he[j]; l!=-1; l=ne[l])
				r[i++]=re[l];
		for(int j=0; j<K; j++)
			he[j]=-1;
		for(int i=0; i<n; i++)
			if (he[e[r[i]]>>16&lll]==-1)
				re[le[e[r[i]]>>16&lll]=he[e[r[i]]>>16&lll]=i]=r[i], ne[i]=-1;
			else
				re[ne[le[e[r[i]]>>16&lll]]=i]=r[i], ne[le[e[r[i]]>>16&lll]=i]=-1;
		for(int i=0, j=0; j<K; j++)
			for(int l=he[j]; l!=-1; l=ne[l])
				r[i++]=re[l];
		for(int j=0; j<K; j++)
			he[j]=-1;
		for(int i=0; i<n; i++)
			if (he[e[r[i]]>>32&lll]==-1)
				re[le[e[r[i]]>>32&lll]=he[e[r[i]]>>32&lll]=i]=r[i], ne[i]=-1;
			else
				re[ne[le[e[r[i]]>>32&lll]]=i]=r[i], ne[le[e[r[i]]>>32&lll]=i]=-1;
		for(int i=0, j=0; j<K; j++)
			for(int l=he[j]; l!=-1; l=ne[l])
				r[i++]=re[l];
		for(int j=0; j<K; j++)
			he[j]=-1;
		for(int i=0; i<n; i++)
			if (he[e[r[i]]>>48&lll]==-1)
				re[le[e[r[i]]>>48&lll]=he[e[r[i]]>>48&lll]=i]=r[i], ne[i]=-1;
			else
				re[ne[le[e[r[i]]>>48&lll]]=i]=r[i], ne[le[e[r[i]]>>48&lll]=i]=-1;
		for(int i=0, j=0; j<K; j++)
			for(int l=he[j]; l!=-1; l=ne[l])
				r[i++]=re[l];//循环展开 4次 
		for(int i=0; i<n; i++)
			e[i]+=1ull<<63;
	}
}//1.7K
//========================================================================================
const int N=50001;
int n, _h, _c, G;
int a[N], c[N], d[N], e[N], f[N], g[N][5], h[N];
ll s[N], t[N], w[N], F[N], E[N], ans=1e18, sum, tmp, pos;//十年OI一场空，不开longlong见祖宗
//E[g[i][3]]=F[g[i][3], a[g[i][3]]], F[i]=F[g[i][1], i]
int cnt, he[N], ne[N<<1], te[N<<1];
void con(int x, int y) {
	ne[++cnt]=he[x], te[he[x]=cnt]=y;
	ne[++cnt]=he[y], te[he[y]=cnt]=x;
}
void dfs0(int x) {//init
	s[x]=w[x], t[x]=0, d[x]=d[f[x]]+1;
   	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x]) {
			f[te[i]]=x;
			dfs0(te[i]);
			s[x]+=s[te[i]];
			t[x]+=t[te[i]]+s[te[i]];
			if (s[h[x]]<s[te[i]]) h[x]=te[i];
		}
}
void dfs1(int x) {//拓扑排序 
	c[++c[0]]=x;
	if (h[x]) a[h[x]]=x==G? h[x]: a[x], dfs1(h[x]);
	for(int i=he[x]; i; i=ne[i])
		if (te[i]!=f[x]&&te[i]!=h[x])
			a[te[i]]=x==G? te[i]: a[x], dfs1(te[i]);
}
void ff(int xx, int rtt, int x, int rt, ll pre) {//(xx, rtt)->(x, rt)
	if (xx!=x)
		for(int _x=h[xx]; ; _x=h[_x]) {
			pre+=s[rtt]-2*s[_x];
			if (_x==x) break;
		}
	F[rt]=pre;
	if (rtt!=rt)
		F[rt]+=t[rt]-t[rtt]+(d[x]-d[rt]+2)*s[rt]-(d[x]-d[rt]+1)*s[rtt];
}//1.0K
int main() {
	n=fcin();
	for(int i=2; i<=n; i++)//n
		con(fcin(), fcin());
	for(int i=1; i<=n; i++)//n
		w[i]=fcin();
	dfs0(1);//n
	if (s[h[1]]*2<=s[1]) G=1;
	else {
		for(int i=2; i<=n; i++)//n
			if (s[h[i]]*2<=s[1]&&s[i]*2>=s[1]) {
				G=i;
				break;
			}
		f[G]=0, memset(h, 0, sizeof h), dfs0(G);//n
	}
	for(int pos=0, i=he[G]; i; i=ne[i])//寻找次重儿子//n
		if (s[te[i]]>pos&&te[i]!=h[G])
			_h=te[i], pos=s[te[i]];
	dfs1(G), _c=2+s[h[G]];//c[_c]=_h//n
	for(int i=2, j=1; i<=n; i++) {//n
		if (f[c[i]]!=c[i-1]) j=i;
		while(s[h[c[j]]]*2>s[c[i]]) ++j;
		g[c[i]][1]=c[j];
		if (s[h[c[j]]]*2==s[c[i]])
			g[c[i]][2]=h[c[j]];
		if (a[c[i]]==c[i])
			ff(c[i], c[i], g[c[i]][1], c[i], t[c[i]]);
		else if
			(f[c[i]]!=c[i-1]) ff(c[i], c[i], g[c[i]][1], c[i], t[c[i]]);
		else
			ff(g[c[i-1]][1], c[i-1], g[c[i]][1], c[i], F[c[i-1]]);
	}
	Rsort::rsort(s+1, e+1, n);//n
	for(int i=1; i<=n; i++)
		++e[i];
	for(int i=1, j=G, k=G; i<n; i++)//e[n]=G//n
		if (a[e[i]]==h[G]) {
			if (s[_h]*2<=s[G]-s[e[i]])
				g[e[i]][3]=G;
			else {
				if (j==G) j=_h;
				while(s[h[j]]*2>s[G]-s[e[i]]) j=h[j];
				g[e[i]][3]=j;
			}
		}
		else {
			while(s[h[k]]*2>s[G]-s[e[i]]) k=h[k];
			g[e[i]][3]=k;
		}
	E[h[G]]=t[h[G]], E[_h]=t[_h];
	for(int x=h[h[G]]; x; x=h[x])
		E[x]=E[f[x]]+s[h[G]]-2*s[x];
	for(int x=h[_h]; x; x=h[x])
		E[x]=E[f[x]]+s[_h]-2*s[x];
	for(int i=1; i<=n; i++) {
		ll pre=E[g[i][3]]+t[G]-t[i]-t[a[g[i][3]]]-(d[i]-1)*s[i]+(d[g[i][3]]-1)*(s[G]-s[i]-s[a[g[i][3]]])-s[a[g[i][3]]];
		if (i!=G&&ans>F[i]+pre)
			ans=F[i]+pre;
	}
	fcout(ans, '\n');
	return 0;
}//1.8K
```

---

## 作者：年华天地 (赞：3)

思路前几篇题解已经讲得非常清楚了，就是枚举删边，在再两颗树内分别寻找重心，又因为代价的递推公示为$f[v]=size[1]-size[v]*2+f[u]$（u为v的父亲），所以一定是在$size[1]-size[v]*2<0$时$f[y]$会更优，所以可以在与深度有关的时间复杂度内算出最小代价。

我发这篇题解主要是因为别的题解对代码的解释太少了，而知道了思路后不一定写的出代码（比如我），所以写了份注释比较多的代码。

```
#include<cstdio>
#define inf 0x7f7f7f7f
using namespace std;
const int maxn=1e5;
int head[maxn],k=1,n,w[maxn],cur;
int size[maxn],f[maxn],fa[maxn],ans=inf;
int son1[maxn],son2[maxn],d[maxn];
//size记录权值和，fa记录父亲节点，son1记录深度最大的儿子
//son2记录深度第二大的儿子，d记录深度 
//cur记录断边，就是记录断边的一个端点 
struct node{
	int next,to,fr;
}e[maxn];
void add(int u,int v)//存图 
{
	k++;
	e[k].to=v;
	e[k].fr=u;
	e[k].next=head[u];
	head[u]=k;
}
int max(int a,int b)
{
	return a>b?a:b;
}
int min(int a,int b)
{
	return a<b?a:b;
}
void dfs(int x,int ff)
{
	size[x]=w[x];fa[x]=ff;d[x]=d[ff]+1;//记录深度，父亲节点，size大小。 
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (y==ff)continue;
		dfs(y,x);
		size[x]+=size[y];
		f[x]+=size[y]+f[y];//f数组表示x的子树到x的代价 看医院设置 
		if (size[y]>size[son1[x]])//son1存深度最大的儿子，son2存深度第二大的儿子 
		{
			son2[x]=son1[x];//注意这里要改变 son2的值 
			son1[x]=y;
		}
		else if (size[y]>size[son2[x]])son2[x]=y;//写else if因为上一个if已经改过了 
	}
}
int find_ans(int x,int now,int sz,int &res)
{
	res=min(res,now);
	int v=son1[x];
	if (size[son1[x]]<size[son2[x]]||v==cur)v=son2[x];
	if (size[v]*2>size[x]&&v)find_ans(v,now+sz-2*size[v],sz,res);
	//now+sz-2*size[v]表示v选这个点的代价。
	//v为u的儿子 
	//如果我们知道选u的代价为x，那么选v的代价为x+size[1]-size[v]-size[v];(size[1]表示树的总代价) 
	//size[1]-size[v]表示v以上的所有点到v的代价比到u多了一 （边权为一）
	//-size[v]表示v的子树到v的代价比到u少了一。 
	//可看医院设置那道题 
}
void find(int x)
{
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (y==fa[x])continue;
		cur=y;//断掉这条边 
		for (int i=x;i;i=fa[i])size[i]-=size[y];//已经断掉了，size改变 
		int a=inf,b=inf;//a,b记录答案 
		find_ans(1,f[1]-f[y]-(d[y]-d[1])*size[y],size[1],a);
		//我们首先枚举选1时的代价 
		//f[1]-f[y]-(d[y]-d[1])*size[y]
		//首先f[1]表示所有点到1的代价，
		//f[y]为到y的代价，(d[y]-d[1])*size[y]为v这颗子树到1的代价 
		//-f[y]-(d[y]-d[1])*size[y]后表示除了v这个子树的所有点到1的代价。 
		find_ans(y,f[y],size[y],b);
		ans=min(ans,a+b);//记录答案 
		for (int i=x;i;i=fa[i])size[i]+=size[y];//回溯加上 
		find(y);//继续递归枚举删边 
	}
}
int main()
{
	scanf("%d",&n);
	for (int i=1,x,y;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);//双向边 
	}
	for (int i=1;i<=n;i++)scanf("%d",&w[i]);
	dfs(1,0);//首先要预处理出size,f,son1,son2,d数组 
	find(1);
	printf("%d",ans);
	return 0;
} 
```


---

## 作者：tommymio (赞：1)

约定：为了方便叙述，定义 $f(x,S)=\sum_{v\in S} w(v)\times dis(v,x)$，$dep_x$ 为 $x$ 点的深度，$dis(x,y)$ 为 $x,y$ 之间的距离，$size_v$ 为以 $v$ 为根的子树点权之和。

拿到这题，我们可以想到一个经典模型：
$$
\min\{\ \sum_{x \in S} f_x+\sum_{x\notin S} g_x \}
$$
即将一个集合划分成两个，对两个集合分别求和，其总和最小。

这题我们也可以借用这样的思想，将一部分点划入一个集合，剩下的划入另一个集合。具体怎么划分呢？可以想到枚举割去树上一条边 $(u,v)$，原树就会变为两棵子树 $T_u,T_v$，对这两棵子树分别求重心，记 $T_u,T_v$ 的重心分别为 $x_u,x_v$。答案即为 $ans=\min\limits_{(u,v)\in E} f(x_u,T_u)+f(x_v,T_v)$。

为什么对两棵子树求重心就可以了呢？这里需要用到一个性质：一棵树上所有节点到它的重心的距离和最小。形式化的描述：$x$ 为树 $T$ 的重心，当且仅当 $f(x,T)=\min\limits_{y\in T} f(y,T)$。

但是这样时间复杂度是 $O(n^2)$ 的，观察一下数据范围发现 $maxhigh\leq 100$，是不是存在一个基于高度的做法呢？

设 $f_x$ 为 $f(x,SubTree)$ 的值，$SubTree$ 为 $x$ 当前所在的子树。$g_x$ 为 $f(x,T)$ 的值，$T$ 为整棵树。那么显然有 $f_1=g_1-g_v-(dep_v-dep_1)\times size_v,f_v=g_v$，并且对于 $T_u$，有 $f_y=f_x+size_1-2\times size_y$，对于 $T_v$，有 $f_y=f_x+size_v-2\times size_y$，其中 $y$ 是 $x$ 的儿子。
在计算 $T_u$ 内的 $f$ 时，对于所有 $x$ 是 $v$ 的祖先的 $size_x$ 全部需减去 $size_v$。

仔细观察上式。对于 $T_u$，发现仅当 $size_1-2\times size_y<0$ 时，答案才可能更小。对于 $T_v$，发现仅当 $size_v-2\times size_y<0$ 时，答案才可能更小。并且所有点权为正，不会出现子树 $y$ 的点权大于子树 $x$ 的点权的情况（$y$ 是 $x$ 的父亲）。所以可以考虑对于每个 $x$，记录下 $size_y$ 最大的点与 $size_y$ 次大的 $y$。因为修改 $size_x$ 时可能会导致最大点变为次大点。每次向下更新 $f$ 的时候只更新最大点即可。

总时间复杂度为 $O(n \times h)$，由于 $\max \{h\}\leq 100$，可以通过本题。

**Show the Code**
```cpp
#include<cstdio>
#define int ll
typedef long long ll;
int cnt=0,u,v;
int h[50005],to[100005],ver[100005];
int size[50005],dep[50005],w[50005],g[50005],son[50005],sonSecond[50005],f[50005],skip[50005];
struct edge {int x,y;} e[50005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline int min(const int &x,const int &y) {return x<y? x:y;}
inline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;}
inline void add(int x,int y) {to[++cnt]=y;ver[cnt]=h[x];h[x]=cnt;}
inline void prework(int x,int fa) {
	size[x]=w[x];sonSecond[x]=son[x]=0;
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; if(y==fa) continue;
		dep[y]=dep[x]+1; skip[y]=x; prework(y,x);  
		g[x]+=g[y]+size[y]; size[x]+=size[y];
		if(size[son[x]]<=size[y]) {sonSecond[x]=son[x];son[x]=y;}
		else if(size[sonSecond[x]]<size[y]) {sonSecond[x]=y;}
	}
}
inline void modify(int x,int val) {
	size[x]+=val; int fa=skip[x];
	if(fa) {
		if(sonSecond[fa]&&son[fa]==x&&size[x]<size[sonSecond[fa]]) swap(sonSecond[fa],son[fa]);  
		else if(sonSecond[fa]==x&&size[x]>size[son[fa]]) swap(son[fa],sonSecond[fa]);
		modify(fa,val);
	}
}
inline void AskTree1(int x,int &res) {
	res=min(res,f[x]);
	if(son[x]&&son[x]!=v&&size[1]<2*size[son[x]]) {f[son[x]]=f[x]+size[1]-2*size[son[x]];AskTree1(son[x],res);}
}
inline void AskTree2(int x,int &res) {
	res=min(res,f[x]);
	if(son[x]&&size[v]<2*size[son[x]]) {f[son[x]]=f[x]+size[v]-2*size[son[x]];AskTree2(son[x],res);}
}
signed main() {
	int n=read(),ans=1e10;
	for(register int i=1;i<n;++i) {e[i].x=read();e[i].y=read();add(e[i].x,e[i].y);add(e[i].y,e[i].x);}
	for(register int i=1;i<=n;++i) w[i]=read();
	dep[1]=1;prework(1,-1);
	for(register int i=1;i<n;++i) {
		u=e[i].x;v=e[i].y;
		if(dep[u]>dep[v]) swap(u,v);//dep[u]<=dep[v]
		f[1]=g[1]-g[v]-size[v]*(dep[v]-1); f[v]=g[v];
		int res1=1e10,res2=1e10; 
		modify(u,-size[v]);
		AskTree1(1,res1); AskTree2(v,res2);
		modify(u,size[v]);
		ans=min(ans,res1+res2);
	}
	printf("%lld",ans);
	return 0;
}
```






---

## 作者：YinyuDream (赞：0)

# 题解：

观察表达式，发现要求的是两个点，满足每个点的权值之和乘以该点到这两点的距离的较小值之和最小。我们可以发现，对于树上的两个点，到一个点为最小距离的集合和到另外一个点为最小距离的点的集合之间是没有交集的。故我们可以枚举边，对两颗子树分别求带权值的树的重心，则求得的正好是表达式的值。但是这任然是$O(n^2)$的，观察方程:$f_v=f_u+size_u-size_v$，若$v$比$u$更优，当且仅当$2size_v>size_1$，且满足$2size_v>size_1$的$v$有且仅有一个，故可以处理出最大儿子和次大儿子，当连接最大儿子的边断裂时，使用次大儿子计算，此时时间复杂度即为$O(nh)$的。

# 代码：
```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=1e6+10;
int n,k,cut,ans=0x7f7f7f7f7f7f7f7fll;
struct node{
	int to,next;
}edge[maxn];
int head[maxn],fa[maxn];
int w[maxn],son1[maxn],son2[maxn],size[maxn],a[maxn],deep[maxn];
void add(int u,int v)
{
	edge[++k].to=v;
	edge[k].next=head[u];
	head[u]=k;
}
void dfs(int u,int f)
{
	fa[u]=f;
	size[u]=w[u];
	a[u]=w[u]*deep[u];
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v!=f)
		{
			deep[v]=deep[u]+1;
			dfs(v,u);
			size[u]+=size[v];
			a[u]+=a[v];
			if(size[son1[u]]<=size[v]){
				son2[u]=son1[u];
				son1[u]=v;
			}else if(size[son2[u]]<=size[v]){
				son2[u]=v;
			}
		}
	}
}
void get_ans(int u,int sz,int num,int &cnt)
{
	cnt=min(cnt,num);
	int v=son1[u];
	if(size[son1[u]]<size[son2[u]]||v==cut)v=son2[u];
	if(v&&size[v]*2>size[u])get_ans(v,sz,num+sz-2*size[v],cnt);
}
void solve(int u)
{
	for(int j=head[u];j;j=edge[j].next)
	{
		int v=edge[j].to;
		if(v!=fa[u])
		{
			int _a=0x7f7f7f7f7f7f7f7fll,b=0x7f7f7f7f7f7f7f7fll;
			cut=v;
			for(int i=u;i;i=fa[i])
			size[i]-=size[v];
			get_ans(1,size[1],a[1]-a[v],_a);
			get_ans(v,size[v],a[v]-size[v]*deep[v],b);
			ans=min(ans,_a+b);
			for(int i=u;i;i=fa[i])
			size[i]+=size[v];
			solve(v);
		}
	}
}
main(){
	//freopen("center.in","r",stdin);
	//freopen("center.out","w",stdout);
	scanf("%lld",&n);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%lld%lld",&u,&v);
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=n;i++)
		scanf("%lld",&w[i]);
	dfs(1,0);
	solve(1);
	printf("%lld",ans);
	return 0;
}
```


---


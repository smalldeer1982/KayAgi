# [HNOI2008] 遥远的行星

## 题目描述

直线上 $N$ 颗行星，$X=i$ 处有行星 $i$，行星 $J$ 受到行星 $I$ 的作用力，当且仅当 $i \le A J$，此时 $J$ 受到作用力的大小为$F_{i->j}=\frac{M_i \times M_j}{j-i}$。

其中 $A$ 为很小的常量，故直观上说每颗行星都只受到距离遥远的行星的作用。
请计算每颗行星的受力，只要结果的相对误差不超过 5% 即可.



## 说明/提示

$1 \le N \le 10^5$  
$0.01 < a \le 0.35$  
$0 \le M_i \le 10^7$  

## 样例 #1

### 输入

```
5 0.3
3
5
6
2
4```

### 输出

```
0.000000
0.000000
0.000000
1.968750
2.976000```

# 题解

## 作者：xyz32768 (赞：7)

这道题我一直懵逼，后来看了题解中的一种玄学方法，~~看来我还是太弱~~。

这种玄学方法的要点就是利用“只要结果的相对误差不超过5%即可”这一条件。

首先，定义一个常数$T$，在$100$左右。

对于第$i$个行星，令$x=\lfloor a*i\rfloor$。可以看出，对第$i$个行星有贡献的是$[1,x]$范围内的行星。

当$x≤T$时，暴力统计。

当$x>T$时，把$[1,x]$分成$T$个长度尽可能平均的小区间（小区间过大会使误差变大）。

每一个小区间$[x,y]$的贡献的近似值就是$(M_i*\sum_{j=x}^yM_j)/(i-\frac{x+y}{2})$（取中点作为分母）

由于$0.01<a≤0.35$得到，这个近似值与准确值的相对误差不超过5%。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const double eps = 1e-8;
const int N = 1e5 + 5;
int n; double a, m[N], res[N], sum[N];
int main() {
    int i, j; n = read(); scanf("%lf", &a);
    for (i = 1; i <= n; i++) sum[i] = sum[i - 1] + (m[i] = read());
    for (i = 1; i <= n; i++) {
        int x = 1.0 * i * a + eps;
        if (!x) continue;
        if (x <= 100) for (j = 1; j <= x; j++)
            res[i] += m[i] * m[j] / (i - j);
        else {
            int tx = 1, ty, tz = x / 100, ta = x % 100;
            for (j = 1; j <= 100; j++) {
                ty = tx + tz - (j > ta);
                res[i] += (sum[ty] - sum[tx - 1]) * m[i] / (i - (tx + ty) / 2);
                tx = ty + 1;
            }
        }
    }
    for (i = 1; i <= n; i++) printf("%.6lf\n", res[i]);
    return 0;
}
```

---

## 作者：123456zmy (赞：1)

题意：  
对于每个 $i(1\le i\le N)$，求：
$$\sum^{\lfloor A\times N\rfloor}_{j=1}\frac{M_i\times M_j}{i-j}$$
$N\le10^5,0.01<A<0.35,0\le M_i \le10^7,\text{精度要求 5\%}$
___
答案误差不超过 $5\%$，所以把分母 $i-j$ 修改 $5\%$ 之内仍然符合精度要求（因为有误差的部分是相加，总误差不会超过误差最大的项的误差），所以可以把一段连续的区间的分母改成其中点值，然后用前缀和快速计算区间的贡献。

代码：$O(n\log_{1.05^2}\frac{1}{1-A})$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m[100001];
double a,ans;
signed main()
{
	scanf("%lld%lf",&n,&a);
	for(int i=1;i<=n;i++)
	{
		ans=0;
		scanf("%lld",&m[i]);
		int r=i*a;
		while(r)
		{
			double mid=i-(i-r)*1.05;
			int l=i-(i-mid)*1.05;
			if(l<0)l=0;
			mid=(l+r+1)/2.0;
			ans+=m[i]*(m[r]-m[l])/(i-mid);
			r=l;
		}
		m[i]+=m[i-1];
		printf("%lf\n",ans);
	}
	return 0;
}
```

---

## 作者：pengrui (赞：1)

**题意：**

对于每个$i$，求$\sum_{j=1}^{A\times i} \frac{m_i\times m_j}{i - j}$

**做法：**

第一眼看上去像平衡树，但每一项都与当前i有关，且不可分开考虑（分母$i-j$）

再看题面发现特殊条件：**相对误差不超过 5% 即可**（通常应该是误差在$10^x$之内），较为特殊

相对误差限制通常是在较大的情况下允许误差范围越大

如斯特林公式：$n!\sim \sqrt{2n\pi} * (\frac{n}{e})^n$，$\sim$限制的是两边的比值

于是想到在$n$较小的时候暴力，在$n$较大的时候估计

$\sum_{j=1}^{A\times i} \frac{m_i\times m_j}{i - j}$ = $m_i \times \sum_{j=1}^{A\times i} \frac{m_j}{i - j}$

1. 若$\forall j,  i-j=k$，$m_i \times \sum_{j=1}^{A\times i} \frac{m_j}{i - j}$ = $m_i / k \times \sum_{j=1}^{A\times i} m_j$，可用前缀和在$O(1)$时间内询问

1. 显然$\forall j1,j2(j1\neq j2,j1,j2\in[1,A\times i]),  i-j1 \neq i-j2$,于是近似得认为$i-1 \approx i - A\times i\; \Rightarrow i-1 \approx i - (A \times i) \; / 2 \approx A\times i\; $

于是可用$1.$中的方法处理$2.$，时间复杂度：$O(n^2)(n\leq 2000) \; or \;O(n)$

**代码：**
```cpp
#include <iostream>
#include <cstdio>
 
using namespace std;
 
const int N = 1e5 + 5;
 
int n;
long double a, m[N], s[N];
 
int main()
{
    ios::sync_with_stdio(false);
    cin >> n >> a;
    for (int i = 1; i <= n; ++i)
        cin >> m[i];
    for (int i = 1; i <= n; ++i)
        s[i] = s[i - 1] + m[i];
    int p = min(2000, n);
    for (int i = 1; i <= p; ++i)
    {
        int g = (int)(a * (1.0 * i));
        long double ans = 0;
        for (int j = 1; j <= g; ++j)
            ans += (m[i] * m[j]) / (i - j) * 1.0;
        printf("%.20LF\n", ans);
    }
    for (int i = p + 1; i <= n; ++i)
    {
        int g = (int)(a * (1.0 * i));
        if (g == 0)
            cout << 0 << endl;
        else
        {
            long double ar = a / (1.0 - a);
            printf("%.20LF\n", s[g] * m[i] / (i - (a * i) / 2.0));
        }
    }
    return 0;
}
```

---

## 作者：徐致远 (赞：1)

[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/03/07/%E3%80%8CHNOI2008%E3%80%8D%E9%81%A5%E8%BF%9C%E7%9A%84%E8%A1%8C%E6%98%9F-Solution/)

又是一道玄学的题目QwQ。

### 题解

首先要一眼看到这题的重点：结果的相对误差不超过$5\%$即可。

所以考虑非完美算法。

首先，对于第$i$个行星，对它有贡献的星球区间是$[1,\lfloor A\cdot i\rfloor]$。设$R=\lfloor A\cdot i\rfloor$。

然后再设一个阈值$S$比如$S=n^{0.4}$。

接下来的操作类似于分块，把区间$[1,R]$分成若干个块，每个块的大小为$S$，剩下的零头暴力搞，对于每一个完整的块，设这个块为$[a,b]$，那么这个块的贡献约等于
$$
\frac{M[i]\cdot\sum_{j=a}^{b}M[j]}{i-\frac{a+b}{2}}
$$
这个式子可以构造前缀和来求。

把所有块的贡献加起来，注意下细节，就能过了QwQ。

### 代码

```cpp
#include<cmath>
#include<cstdio>
using namespace std;
typedef long long LL;
const int maxn=100005;
int n,S,M[maxn];double A,ans;LL sum[maxn];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
int main()
{
	n=read();scanf("%lf",&A);S=pow(n,0.38)+1e-10;
	for(int i=1;i<=n;i++){M[i]=read();sum[i]=sum[i-1]+M[i];} //构造前缀和
	for(int i=1;i<=n;i++)
	{
		int R=i*A+1e-10,j;ans=0;   //加上1e-10是为了防止精度损失
		for(j=1;j+S<=R;j+=S)    //处理整块
			ans+=(double)M[i]*(sum[j+S-1]-sum[j-1])/(i-(double)(2*j+S-1)/2);
		for(;j<=R;j++)      //处理零头
			ans+=(double)M[i]*M[j]/(i-j);
		printf("%lf\n",ans);
	}
	return 0;
}
```



---

## 作者：reclusive (赞：0)

我们发扬人类智慧！

首先我们注意到题目中有一句话：

- 只要结果的相对误差不超过 5% 即可。

因此我们考虑分块，我们令块长 $k=50$。然后用一个前缀和数组预处理出每一块内的质量和。

分母的话我们就不要用 $j-i$ 了，我们可以用这一块的中点，这样我们就可以 $O(1)$ 算出分母了，由于我们的块长不会很大，精度也可以保证。

然后不满一块的部分我们直接暴力计算即可。

时间复杂度：玄学（话说人类智慧题都这个复杂度吧）。

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
double m[N],sum[N],f[N];
int main(){
	int n,k=50;double v;
	scanf("%d%lf",&n,&v);
	for(int i=1;i<=n;i++){
		scanf("%lf",&m[i]);
		sum[i]=sum[i-1]+m[i];
	}
	for(int j=1;j<=n;j++){
		for(int i=1;i<=(int)(v*j/k);i++){
			f[j]=f[j]+m[j]*(sum[i*k]-sum[(i-1)*k])/(j-((i-1)*k+1+i*k)/2.0);
		}
		for(int i=(int)(v*j/k)*k+1;i<=v*j;i++){
			f[j]=f[j]+m[i]*m[j]/(j-i);
		}
	}
	for(int i=1;i<=n;i++){
		printf("%.6lf\n",f[i]);
	}
	return 0;
}
```


---

## 作者：依依 (赞：0)

注意题目中说“样例输出的结果误差不超过5%,也算对”，然后

开始乱搞

计算行星i的答案，要满足条件

A*i>=j ,行星i才会受行星j的影响

也就是说行星i只会受他之前的行星的影响

令 j=A*i

那么 ans[i]=Σ(k=1....j) m[i]*m[k]/(i-k)

用sum[i]  表示前i个星球的质量和

那么  ans=sum[i]*m[i]/(i-0.5j)

将k折中取值，搞定  
[代码(blog)](http://www.cnblogs.com/adelalove/p/8611371.html)

---

## 作者：zqy1018 (赞：0)

看到数据规模就吓傻了

这题暴力是根本过不动的。

所以我们可以用一些玄学方法

在这题中，有一个很关键的提示：

“误差不超过5%即可”

可以发现在这种条件下正确答案的范围非常宽

所以可以采用近似的方法，不必每一个j-i都计算，可以用一个值来代替

某一个范围内的j-i。

具体的程序实现是：对于一个j，有编号为i∈[1,aj]的行星给他力

将此区间分成k段，每段的分母j-i近似用该区间中点的分母表示

k可以自行选一个定值，这里用的是100。

可以往小里取，不TLE即可。

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
int n;
double a,m[100005],sum[100005],f[100005];
void init(){
    scanf("%d%lf",&n,&a);
    sum[0]=m[0]=0;
    for(int i=1;i<=n;i++)
        scanf("%lf",&m[i]),
        sum[i]=sum[i-1]+m[i];
}
void solve(){
    for(int i=1;i<=n;i++){
        double s=a*i,mid;
        int lim=floor(s);//[1,ai]
        if(lim<=100){//区间长不足100直接算
            for(int j=1;j<=lim;j++)
                f[i]+=m[i]*m[j]/(i-j);
        }else{
            int l2=lim/100;
            for(int j=l2;j<=l2*100;j+=l2)
                mid=(i-j+i-j+l2-1)*0.5,//算中点的分母
                f[i]+=(sum[j]-sum[j-l2])*m[i]/mid;
            for(int j=l2*100+1;j<=lim;j++)//不足100直接算
                f[i]+=m[i]*m[j]/(i-j);
        }
    }
    for(int i=1;i<=n;i++)
        printf("%.6lf\n",f[i]);
}
int main(){
    init();
    solve();
    return 0;
}
```

---


# [HNOI2012] 双十字

## 题目描述

在 C 部落，双十字是非常重要的一个部落标志。所谓双十字，如下面两个例子，由两条水平的和一条竖直的 `1` 线段组成：

```
..........
....1.....      ..1..
..11111...      .111.
....1.....      ..1..
.1111111..      11111
....1.....      ..1..
....1.....
..........
```

合法的双十字要求满足以下几个限制：
- 两条水平的线段不能在相邻的两行。
- 竖直线段上端必须严格高于两条水平线段，下端必须严格低于两条水平线段。
- 竖直线段必须将两条水平线段严格划分成相等的两半。
- 上方的水平线段必须严格短于下方的水平线段。

所以上面右边的例子是满足要求的最小的双十字。

现在给定一个 $R\times C$ 的 `01` 矩阵，要求计算出这个 `01` 矩阵中有多少个双十字。例如下面这个例子，`01` 矩阵如下：

```
10001011
10111111
10001101
11111110
11111111
11101011
```

我们可以找到 $5$ 个满足条件的双十字，分别如下：

```
....1...  ....1...  ....1...
...111..  ...111..  ...111..
....1...  ....1...  ....1...
..11111.  ..11111.  ....1...
....1...  ....1...  ..11111.
........  ....1...  ....1...

....1...  ....1...
...111..  ..11111.
....1...  ....1...
....1...  ....1...
.1111111  .1111111
....1...  ....1...
```

注意最终的结果可能很大，只要求输出双十字的个数 $\bmod\ 10^9+9$ 的值。

## 说明/提示

对于 $100\%$ 的数据，保证 $5\le R,C\le 10^4$，$0\le N\le 10^4$，$RC\le 2\times 10^6$。

## 样例 #1

### 输入

```
6  8
12
1  2
1  3
1  4
1  6
2  2
3  2
3  3
3  4
3  7
6  4
6  6
4  8```

### 输出

```
5```

# 题解

## 作者：miaowey (赞：6)

（格式复制过来乱了点，原版在我博客里）

myblog: http://blog.csdn.net/miaomiao\_ymxl/article/details/54908607


思路：

首先因为R与C不确定，所以我们需要将点们放在一个一维数组中，算算编号就好了

接下来记录lr[i]与down[i]分别表示点i最多可以向左右延伸和向下延伸多少个1(不包括自己)


然后我们枚举双十字的下面那个交点，推一推公式：


{注：len是下面横线的长度，top表示能到达的最上的位置（连续的1），j是上面的横线的中心位置}

对于一个点i，它对答案的贡献是：

∑lr[i]len=1min(lr[j],len−1)×down[i]×(j−top)

显然这个min非常恶心，我们考虑把它拆开成下面的样子：

1.当(lr[j] <= len-1) 贡献是∑lr[i]len=1lr[j]×down[i]×(j−top)

2.当(lr[j] > len-1) 贡献是∑lr[i]len=1(len−1)×down[i]×(j−top)


再进一步变形：

1.当(lr[j] <= lr[i]) 贡献是(lr[i]×lr[j]−lr[j]×(lr[j]+1)/2)×down[i]×(j−top)

2.当(lr[j] > lr[i]) 贡献是lr[i]×(lr[i]−1)/2×down[i]×(j−top)

（对于1的解释:lr[i]×lr[j]是总方案数，lr[j]×(lr[j]+1)/2是不合法方案数）


现在，需要解决的是所有带j的式子，我们定义3个树状数组t1, t2, t3，分别记录:

1.−lr[j]∗(lr[j]+1)/2)×(j−top)

2.lr[j]×(j−top)

3.(j−top)

把lr[i]作为位置插入，先枚举列再枚举行，每次注意清空。

并且因为两根横线不能挨在一起，所以枚举点(i, j)插入(i-1, j)的值


代码：















```cpp
<
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)
#define N (10000+5)
#define NM (1200000+5)
const LL MOD = 1e9+9;
int n, m, lr[NM], L[NM], R[NM], down[NM];
bool is0[NM];
struct Tbit{
    LL c[N];
    void clear(){Set(c, 0);}
    int lowbit(int x){return x&(-x);}
    void add(int x, LL v){
        while(x < N){c[x] = (c[x]+v)%MOD; x += lowbit(x);}
    }
    LL query(int x){
        LL ret = 0;
        while(x > 0){ret = (ret+c[x])%MOD; x -= lowbit(x);}
        return ret;
    }
}t1, t2, t3;
int ID(int x, int y){return m*(x-1)+y;}
inline void init(){
    For(i, 1, n){
        L[ID(i,1)] = !is0[ID(i,1)]; R[ID(i,m)] = !is0[ID(i,m)];
        For(j, 2, m) if(!is0[ID(i,j)]) L[ID(i,j)] = L[ID(i,j-1)]+1;
        Forr(j, m-1, 1) if(!is0[ID(i,j)]) R[ID(i,j)] = R[ID(i,j+1)]+1;
        For(j, 1, m) if(!is0[ID(i,j)]) lr[ID(i,j)] = min(L[ID(i,j)], R[ID(i,j)])-1;
    }
    For(i, 1, m){
        down[ID(n,i)] = !is0[ID(n,i)];
        Forr(j, n-1, 1) if(!is0[ID(j,i)]) down[ID(j,i)] = down[ID(j+1,i)]+1;
        Forr(j, n, 1) if(down[ID(j,i)]) down[ID(j,i)]--;
    }
}
inline void work(){
    int top, now;
    LL ans = 0;
    For(j, 1, m){
        top = 0; t1.clear(); t2.clear(); t3.clear(); 
        For(i, 1, n){
            if(is0[ID(i,j)]){top=i; t1.clear(); t2.clear(); t3.clear(); continue;}
            now = ID(i,j);
            ans += t1.query(lr[now])*down[now]%MOD;
            ans += t2.query(lr[now])*down[now]*lr[now]%MOD;
            ans += (t3.query(m)-t3.query(lr[now]))*lr[now]*(lr[now]-1)/2*down[now]%MOD; ans %= MOD;
            if(i==1) continue;
            now = ID(i-1,j);
            if(lr[now]){
                t1.add(lr[now], -lr[now]*(lr[now]+1)/2%MOD*(i-1-top-1)%MOD);
                t2.add(lr[now], lr[now]*(i-1-top-1)%MOD); t3.add(lr[now], i-1-top-1);
            }
        }
    }
    printf("%lld\n", (ans+MOD)%MOD);
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    int cnt1, x, y;
    scanf("%d%d%d", &n, &m, &cnt1);
    For(i, 1, cnt1){scanf("%d%d", &x, &y); is0[ID(x, y)] = true;}
    init(); work();
    return 0;
}
>
```

---

## 作者：yybyyb (赞：3)

我们去年暑假的时候考试考过。我当时写了个大暴力混了$70$分。。。。

大暴力是这么写的：

预处理每个位置向左右/上/下能够拓展的最多的长度(左右相当于分别求然后取$min$)  
接着枚举双十字的中轴线，所在的列  
然后枚举上面那一行，枚举下面那一行。  
那么，贡献显然是上面选择的左右长度$*$下面可以选择的左右长度$*$上下两行分别向上/下拓展的长度。  
发现复杂度瓶颈在于枚举完上面那一行之后又去枚举下面那一行。  
这个东西显然可以前缀和优化，那么每次修改都是一个区间加法，并且还是加等差数列。  

线段树或者树状数组就好啦？  
线段树怎么维护可以参考洛谷的这道题目[无聊的数列]，打开链接后的第一道题目。(https://www.cnblogs.com/cjyyb/p/8567674.html)  

树状数组的做法，首先要知道[怎么维护区间加法](http://www.cnblogs.com/cjyyb/p/8688692.html)  
核心思想是差分。    
我们要加一个等差数列，如果只进行一次差分，那么就是给差分数组做区间加法。  
这样显然还不行，所以我们对于差分数组再差分一次，假设得到的数组  是$c_i$，原数组是$a_i$，差分一次的结果是$b_i$  
那么  
$$\begin{aligned}\sum_{i=1}^xa_i&=\sum_{i=1}^x\sum_{j=1}^ib[i]\\&=\sum_{i=1}^x(x-i+1)b[i]\\&=\sum_{i=1}^x(x-i+1)\sum_{j=1}^ic[i]\\&=\sum_{i=1}^xc[i]\sum_{j=i}^x(x-j+1)\\&=\sum_{i=1}^xc[i]\times\frac{1}{2}(n-i+2)(n-i+1)\\&=\frac{1}{2}\sum_{i=1}^xc[i]((n^2+3n+2)-(i^2+(2n+3)i))\end{aligned}$$

用树状数组维护$c[i],ic[i],i^2c[i]$即可。
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
#define RG register 
#define MAX 1500000
#define MOD 1000000009
#define inv2 500000005
#define id(x,y) ((x-1)*m+y)
inline int read()
{
	RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
void add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}
bool vis[MAX];
int n,m,L[MAX],U[MAX],D[MAX],ans,K;
int c1[MAX],c2[MAX],c3[MAX];
inline int lb(int x){return x&(-x);}
void modify(int x,int w)
{
	for(int i=x;i<=m;i+=lb(i))
	{
		add(c1[i],w);
		add(c2[i],1ll*x*w%MOD);
		add(c3[i],1ll*x*x%MOD*w%MOD);
	}
}
int getsum(int x)
{
	int s1=0,s2=0,s3=0,ret=0;
	for(int i=x;i;i-=lb(i))
		add(s1,c1[i]),add(s2,c2[i]),add(s3,c3[i]);
	add(ret,(1ll*(x+3)*x%MOD+2)*s1%MOD);add(ret,s3);
	add(ret,MOD-1ll*(x+x+3)*s2%MOD);
	ret=1ll*ret*inv2%MOD;
	return ret;
}
void modify(int l,int r,int w){modify(l,w);modify(r+1,MOD-w);}
void init(){for(int i=1;i<=m;++i)c1[i]=c2[i]=c3[i]=0;}
int main()
{
	n=read();m=read();K=read();
	for(int i=1;i<=n*m;++i)vis[i]=true;
	while(K--)vis[id(read(),read())]=false;
	for(int i=1;i<=n;++i)//Left
	{
		int s=0,now=(i-1)*m+1;
		for(int j=1;j<=m;++j,++now)
		{
			s=vis[now]?s+1:0;
			L[now]=s;
		}
	}
	for(int i=1;i<=n;++i)//Right
	{
		int s=0,now=i*m;
		for(int j=m;j>=1;--j,--now)
		{
			s=vis[now]?s+1:0;
			L[now]=min(L[now],s);if(L[now])--L[now];			
		}
	}
	for(int j=1;j<=m;++j)//Up
	{
		int s=0,now=j;
		for(int i=1;i<=n;++i,now+=m)
		{
			s=vis[now]?s+1:0;
			U[now]=s;if(U[now])--U[now];
		}
	}
	for(int j=1;j<=m;++j)//Down
	{
		int s=0,now=id(n,j);
		for(int i=n;i>=1;--i,now-=m)
		{
			s=vis[now]?s+1:0;
			D[now]=s;if(D[now])--D[now];
		}
	}
	for(int j=2;j<m;++j,init())
		for(int i=3;i<n;++i)
		{
			int u=id(i,j);
			if(!vis[u]){init();continue;}
			if(L[u])add(ans,1ll*D[u]*getsum(L[u]-1)%MOD);
			modify(1,L[u-m],U[u-m]);
		}
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：Cyhlnj (赞：2)

比较简单的一道题目

处理出来每个位置向上下左右分别能扩展多远

然后枚举中轴线和下边界，暴力就是再枚举一个上边界计算答案

你发现暴力有 $90$ 分，$BZOJ$ 上面过了。。。

考虑优化，观察计算答案的时候的写法

假设下边界的最长半径为 $len1$ 上边界的为 $len2$

如果 $len2 >= len1$ 那么贡献就是 $\sum_{i=1}^{len1-1}1=\frac{len1(len1-1)}{2}$

还要乘上向上下扩展的长度，上边界的贡献显然可以用一个树状数组维护

如果 $len2 < len1$ 那么贡献就是 $len2(len2-len1)+\frac{(len2-1)(len2-2)}{2}$

也要乘上向上下扩展的长度，把与上边界有关的东西提出来，显然可以用三个树状数组维护贡献

细节自己注意一下就好了

注意每次是对枚举的中轴线的一段连续的 $1$ 做查询，每次要清空树状数组

```cpp
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;

namespace IO {
	const int maxn(1 << 21 | 1);

	char ibuf[maxn], *iS, *iT, c;
	int f;

	inline char Getc() {
		return iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, maxn, stdin), (iS == iT ? EOF : *iS++)) : *iS++;
	}
	
	template <class Int> inline void In(Int &x) {
		for (f = 1, c = Getc(); c < '0' || c > '9'; c = Getc()) f = c == '-' ? -1 : 1;
		for (x = 0; c >= '0' && c <= '9'; c = Getc()) x = x * 10 + (c ^ 48);
		x *= f;
	}
}

using IO :: In;

const int mod(1e9 + 9);
const int maxn(2e6 + 5);

int n, r, c, mp[maxn], le[maxn], ri[maxn], up[maxn], down[maxn], ans;

# define ID(i, j) (i - 1) * c + j

inline void Inc(int &x, int y) {
	x += y;
	if (x >= mod) x -= mod;
}

inline int S(ll x) {
	return (x * (x + 1) >> 1) % mod;
}

struct BIT {
	int sum[maxn];

	inline void Init() {
		for (int i = 1; i <= c; ++i) sum[i] = 0;
	}

	inline void Clear(int x) {
		if (x <= 0 || x > c) return;
		for (; x <= c; x += x & -x) sum[x] = 0;
	}

	inline void Add(int x, int v) {
		if (x <= 0 || x > c) return;
		for (; x <= c; x += x & -x) Inc(sum[x], v);
	}

	inline int Query(int x) {
		if (x <= 0 || x > c) return 0;
		int ret = 0;
		for (; x; x ^= x & -x) Inc(ret, sum[x]);
		return ret;
	}
} c1, c2, c3, c4;

int main() {
	freopen("a.in", "r", stdin);
	In(r), In(c), In(n);
	for (int i = 1, a, b; i <= n; ++i) In(a), In(b), mp[ID(a, b)] = 1;
	for (int i = 1; i <= r; ++i) {
		for (int j = 1; j <= c; ++j) {
			int p = ID(i, j);
			up[p] = mp[p] ? 0 : (i == 1 ? 1 : up[p - c] + 1);
			le[p] = mp[p] ? 0 : (j == 1 ? 1 : le[p - 1] + 1);
		}
		for (int j = c; j; --j) {
			int p = ID(i, j);
			ri[p] = mp[p] ? 0 : (j == c ? 1 : ri[p + 1] + 1);
		}
	}
	for (int i = r; i; --i)
		for (int j = 1; j <= c; ++j) {
			int p = ID(i, j);
			down[p] = mp[p] ? 0 : (i == r ? 1 : down[p + c] + 1);
		}
	for (int j = 1, p; j <= c; ++j) {
		c1.Init(), c2.Init(), c3.Init(), c4.Init();
		for (int i = 1, lst = 1; i < r; ++i) {
			if (down[p = ID(i, j)] > 1) {
				int len1 = min(le[p], ri[p]) - 1;
				if (len1 > 1) {
					int g = down[p] - 1, s4 = c4.Query(c - len1 + 1);
					Inc(ans, 1LL * g * s4 % mod * S(len1 - 1) % mod);
					int s1 = c1.Query(len1 - 1), s2 = c2.Query(len1 - 1), s3 = c3.Query(len1 - 1);
					s1 = (1LL * s1 * len1 % mod - s2 + mod) % mod;
					Inc(s1, s3), Inc(ans, 1LL * g * s1 % mod);
				}
			}
			if (i > 1 && up[p = ID(i - 1, j)] > 1) {
				int len1 = min(le[p], ri[p]) - 1;
				c4.Add(c - len1 + 1, up[p] - 1);
				c3.Add(len1, 1LL * S(len1 - 1) * (up[p] - 1) % mod);
				c2.Add(len1, 1LL * len1 * len1 % mod * (up[p] - 1) % mod);
				c1.Add(len1, 1LL * len1 * (up[p] - 1) % mod);
			}
			if (mp[ID(i, j)]) {
				for (int k = lst, q; k <= i; ++k) {
					q = ID(k, j);
					int len1 = min(le[q], ri[q]) - 1;
					c4.Clear(c - len1 + 1);
					c3.Clear(len1), c2.Clear(len1), c1.Clear(len1);
				}
				lst = i + 1;
			}
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

给定一个 $R\times C$ 的 `01` 矩阵，求这个 `01` 矩阵中有多少个双十字。

### 题目分析

首先考虑暴力，不妨枚举两个十字上的两个交叉点，然后看能延伸多少，用前缀和预处理后时间复杂度为 $\mathcal O(R^2\times C)$。

然后我们考虑怎么优化掉那一层 $R$，我们想若只枚举下方的交叉点，能否计算出上方十字有多少种可能。

先考虑处理较上方的横的情况，若下面的横长度最长为 $y$，上面那一横最长取 $x$。因为 $x$ 与 $y$ 的关系不同，方案数也会不同，所以不妨分类讨论一下。

1. $x \ge y$

则下横取 $y$ 时，上横可取 $1\sim y-1$，方案数为 $y-1$。以此类推，下横取 $i \in [1, y]$ 时，上横可取 $1\sim i-1$，则总的方案数即为 $1 + 2 + \dots y-1$，计算时等差数列求和即可。

2. $x < y$

则下横取 $i \in [x+1, y]$ 时，上横可以取 $1\sim x$，方案数为 $x \times (y-x)$；当下横取 $i \in [1, x]$ 时，上横可取 $1 \sim i-1$，方案数为 $1 + 2 + \dots x-1$。

所以我们得出总的方案数为：

$$ans_y = \sum\limits_{x\in[x_1, x_{i-1}]}\begin{cases}\dfrac{y\times (y-1)}{2} & x\ge y \\ x\times(y-x)+\dfrac{x\times(x-1)}{2} & x<y\end{cases}$$

化简得：

$$ans_y = \sum\limits_{x\in[x_1, x_{i-1}]}\begin{cases}\dfrac{1}{2}\times y^2 - \dfrac{1}{2}\times y & x\ge y \\ x\times y - \dfrac{1}{2}\times x^2 - \dfrac{1}{2}\times x & x<y\end{cases}$$

由于我们只需要将 $x$ 和 $y$ 比较大小，即、要知道所有比 $y$ 小/大的 $x$ 对应的方案数，所以我们不妨考虑用树桩数组维护前缀和。根据化简后的式子可以知道我们需要维护：$x$ 值的个数，$x$ 的和，$x^2$ 的和（也可以用非简化的式子，不过要多维护一个 $1\sim x$ 等差数列的和）。

最后，我们把横的方案数乘上向上延伸有多少种可能，向下延伸有多少种可能，都乘起来即为答案。

特别的，向上延伸的系数需要在维护多个前缀和时一并乘上，否则不好计算。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#define lowbit(x) (x&-x)
#define int long long

using namespace std;

const int N = 2e6 + 5, MOD = 1e9 + 9;
int n, m, T, t[10][N], r[N], ans, dis[N];
vector <int> a[N], b[N];

void add(int id, int x, int val)
{
    while(x <= m)
    {
        (t[id][x] += val) %= MOD;
        x += lowbit(x);
    }
}

int query(int id, int x)
{
    int res = 0;
    while(x)
    {
        (res += t[id][x]) %= MOD;
        x -= lowbit(x);
    }
    return res;
}

signed main()
{
    scanf("%lld %lld %lld", &n, &m, &T);
    for(int i = 1, x, y;i <= T;i++)
    {
        scanf("%lld %lld", &x, &y);
        a[x].push_back(y);
        b[y].push_back(x);
    }
    for(int i = 1;i <= n;i++)   a[i].push_back(0), a[i].push_back(m+1), r[i] = 1;
    for(int i = 1;i <= n;i++)   sort(a[i].begin(), a[i].end());
    for(int i = 1;i <= m;i++)   b[i].push_back(0), b[i].push_back(n+1);
    for(int i = 1;i <= m;i++)   sort(b[i].begin(), b[i].end());
    for(int i = 1;i <= m;i++)
    {
        for(int j = 1;j <= n;j++)
            if(a[j][r[j]] == i) r[j]++;
        for(int j = 1;j < b[i].size();j++)
        {
            dis[b[i][j-1]] = 0;
            for(int k = b[i][j-1] + 1;k < b[i][j] - 1;k++)
            {
                dis[k] = min(a[k][r[k]] - i - 1, i - a[k][r[k]-1] - 1);
                if(dis[k] > 0)
                {
                    (ans += 1ll * (query(0, m) - query(0, dis[k]) + MOD) % MOD * (dis[k] * (dis[k]-1) / 2) % MOD * (b[i][j] - 1 - k) % MOD) %= MOD;   //chang
                    (ans += 1ll * (query(1, dis[k]) * dis[k] - query(2, dis[k]) + query(3, dis[k]) + MOD) % MOD * (b[i][j] - 1 - k) % MOD) %= MOD;
                }
                if(dis[k-1] > 0)
                {
                    add(0, dis[k-1], k-1 - b[i][j-1] - 1); //geshu
                    add(1, dis[k-1], dis[k-1] * (k-1 - b[i][j-1] - 1));   //he
                    add(2, dis[k-1], dis[k-1] * dis[k-1] * (k-1 - b[i][j-1] - 1)); //pingfang
                    add(3, dis[k-1], dis[k-1] * (dis[k-1]-1) / 2 * (k-1 - b[i][j-1] - 1)); //dengcha
                }
            }
            for(int k = b[i][j-1] + 1;k < b[i][j] - 1;k++)
            {
                if(dis[k-1] > 0)
                {
                    add(0, dis[k-1], -(k-1 - b[i][j-1] - 1)); //geshu
                    add(1, dis[k-1], -dis[k-1] * (k-1 - b[i][j-1] - 1));   //he
                    add(2, dis[k-1], -dis[k-1] * dis[k-1] * (k-1 - b[i][j-1] - 1)); //pingfang
                    add(3, dis[k-1], -dis[k-1] * (dis[k-1]-1) / 2 * (k-1 - b[i][j-1] - 1)); //dengcha
                }
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}

```

---

## 作者：dAniel_lele (赞：0)

首先肯定要计算上下左右最多延伸多少个 $1$，这是容易的。

考虑枚举中间所在的列，记为 $j$。

最朴素的想法是枚举两个横所在的行 $i_1,i_2$，不难计算符合要求的左右延伸数。乘上 $(i_1,j)$ 向上延伸数和 $(i_2,j)$ 向下延伸数即可。复杂度 $O(CR^2)$。

考虑优化，枚举下面一个十字所在行 $i$，我们要计算的是所有上面的匹配数。分两类讨论，一类是上面左右延伸数小于等于 $(i,j)$ 左右延伸，一类是大于等于，分别扔到线段树上维护即可。复杂度 $O(CR\log C)$。

细节不少。

```cpp
#include <bits/stdc++.h>
#define int long long
#define s(i,j) ((i-1)*c+j)
#define mid ((l+r)>>1)
using namespace std;
const int mod=1e9+9;
int col[3000005];
int up[3000005],down[3000005],lft[3000005],rht[3000005];
struct sgt{
	int f[1000005],tag[1000005],siz[1000005];
	void clear(){
		tag[1]=1;
	}
	void build(int i,int l,int r){
		f[i]=tag[i]=0;
		if(l==r){
			siz[i]=1;
			return ;
		}
		build(i*2,l,mid);
		build(i*2+1,mid+1,r);
		siz[i]=siz[i*2]+siz[i*2+1];
	}
	void pushdown(int i){
		if(tag[i]){
			tag[i*2]=tag[i*2+1]=1;
			f[i*2]=f[i*2+1]=0;
			tag[i]=0;
		}
	}
	void change(int i,int l,int r,int ql,int qr,int cg){
		if(ql<=l&&r<=qr){
			(f[i]+=cg*siz[i])%=mod;
			return ;
		}
		pushdown(i);
		if(ql<=mid) change(i*2,l,mid,ql,qr,cg);
		if(qr>mid) change(i*2+1,mid+1,r,ql,qr,cg);
		f[i]=(f[i*2]+f[i*2+1])%mod;
	}
	int qry(int i,int l,int r,int ql,int qr){
		if(ql>qr) return 0;
		if(ql<=l&&r<=qr) return f[i];
		if(ql>r||qr<l) return 0;
		pushdown(i);
		return (qry(i*2,l,mid,ql,qr)+qry(i*2+1,mid+1,r,ql,qr))%mod;
	}
}tree1,tree2,tree3;
signed main(){
	int r,c,n,ans=0; cin>>r>>c>>n;
	for(int i=1;i<=r;i++) for(int j=1;j<=c;j++) col[s(i,j)]=1;
	for(int i=1;i<=n;i++){
		int x,y; cin>>x>>y; col[s(x,y)]=0;
	}
	for(int i=1;i<=r;i++) for(int j=2;j<=c;j++) if(col[s(i,j)]&col[s(i,j-1)]) lft[s(i,j)]=lft[s(i,j-1)]+1;
	for(int i=1;i<=r;i++) for(int j=c-1;j>=1;j--) if(col[s(i,j)]&col[s(i,j+1)]) rht[s(i,j)]=rht[s(i,j+1)]+1;
	for(int i=2;i<=r;i++) for(int j=1;j<=c;j++) if(col[s(i,j)]&col[s(i-1,j)]) up[s(i,j)]=up[s(i-1,j)]+1;
	for(int i=r-1;i>=1;i--) for(int j=1;j<=c;j++) if(col[s(i,j)]&col[s(i+1,j)]) down[s(i,j)]=down[s(i+1,j)]+1;
	tree1.build(1,1,c);
	tree2.build(1,1,c);
	tree3.build(1,1,c);
	for(int j=1;j<=c;j++){
		tree1.clear();
		tree2.clear();
		tree3.clear();
		for(int i=1;i<=r;i++){
			int minv=min(lft[s(i,j)],rht[s(i,j)]);
			if(minv){
				int tmp=(tree1.qry(1,1,c,minv,c)*((minv*(minv-1)/2)%mod)%mod+tree3.qry(1,1,c,1,minv-1)*minv%mod+mod-tree2.qry(1,1,c,1,minv-1))*down[s(i,j)]%mod;
				(ans+=tmp)%=mod;
			}
			if(i-1){
				minv=min(lft[s(i-1,j)],rht[s(i-1,j)]);
				if(minv){
					tree1.change(1,1,c,minv,minv,up[s(i-1,j)]);
					tree2.change(1,1,c,minv,minv,((minv*(minv+1))/2)%mod*up[s(i-1,j)]%mod);
					tree3.change(1,1,c,minv,minv,minv*up[s(i-1,j)]%mod);
				}
			}
			if(!col[s(i,j)]){
				tree1.clear(),tree2.clear(),tree3.clear();
			}
		}
	}
	cout<<ans;
    return 0;
} 
```

---

## 作者：pengyihao (赞：0)

我好气啊！原题的时限是10s，这里只有1s辣，我如何是好啊！

为什么你们打的都是树状数组啊，就我这个弱鸡打的是splay啊！

代码有250+行啊，被卡到80分啊！


```cpp
#include <bits/stdc++.h>

typedef long long LL;

#define FOR(i, a, b) for (LL i = (a), i##_END_ = (b); i <= i##_END_; i++)
#define DNF(i, a, b) for (LL i = (a), i##_END_ = (b); i >= i##_END_; i--)

template <typename Tp> void in(Tp &x) {
    char ch = getchar(); x = 0;
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
}

template <typename Tp> Tp Min(Tp x, Tp y) {return x < y ? x : y;}
template <typename Tp> Tp Max(Tp x, Tp y) {return x > y ? x : y;}
template <typename Tp> Tp chkmax(Tp &x, Tp y) {return x > y ? x : x=y;}
template <typename Tp> Tp chkmin(Tp &x, Tp y) {return x < y ? x : x=y;}

using std::vector;

const LL MAXN = 10010, MOD = 1000000009;

vector<LL>line[MAXN];
vector<LL>lr[MAXN], tp[MAXN], co[MAXN];

LL r, c, n;

struct Node {
    Node *ch[2], *fa;
    LL data1, data2, sum1, sum2, sum3, sz;

    void clear();
    void update();
    void rotate();
    void insert(LL, LL);
    LL get_rnk(LL);
    void splay(Node*);
    Node *find_key(LL);
} *treap;

void Node::rotate()
{
    Node *pa = fa;
    fa = pa -> fa; pa -> fa = this;
    if (fa != NULL) {
        bool t = (fa -> ch[0] == pa ? 0 : 1);
        fa -> ch[t] = this;
    }
    bool t = (pa -> ch[0] == this ? 0 : 1);
    Node *chd = ch[t ^ 1];
    ch[t ^ 1] = pa; pa -> ch[t] = chd;
    if (chd != NULL) chd -> fa = pa;
    pa -> update(); update();
}

void Node::splay(Node *top)
{
    while (fa != top) {
        if (fa -> fa != top) {
            bool t = (fa -> fa -> ch[0] == fa ? 0 : 1);
            if (fa -> ch[t] == this) fa -> rotate(), rotate();
            else rotate(), rotate();
        }
        else rotate();
    }
    if (top == NULL) treap = this;
}

LL Node::get_rnk(LL now)
{
    Node *x = this;

    LL ret = 0;
    
    while (true) {
        if (x -> data1 == now) {
            return (x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1) + ret;
        }
        if (x -> data1 > now) {
            if (x -> ch[0] == NULL) return ret;
            x = x -> ch[0];
        }
        else {
            if (x -> ch[1] == NULL) return x -> sz + ret;
            ret += (x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1);
            x = x -> ch[1];
        }
    }
}

Node* Node::find_key(LL rnk)
{
    Node *x = this;
    while (true) {
        if ((x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1) == rnk) return x;
        else if ((x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1) < rnk) {
            rnk -= (x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1);
            x = x -> ch[1];
        }
        else x = x -> ch[0];
    }
}

void Node::insert(LL now, LL now2)
{
    if (treap == NULL) {
        Node *hr = new Node;
        hr -> ch[0] = hr -> ch[1] = hr -> fa = NULL;
        hr -> data1 = now; hr -> data2 = now2; treap = hr; treap -> update();
        return;
    }
    LL rnk = treap -> get_rnk(now);
    if (rnk == 0) {
        Node *hr = new Node;
        hr -> ch[0] = hr -> fa = NULL;
        hr -> ch[1] = treap; hr -> data1 = now; hr -> data2 = now2;
        treap -> fa = hr; hr -> update();
        treap = hr;
    }
    else if (rnk == treap -> sz) {
        Node *hr = new Node;
        hr -> ch[1] = hr -> fa = NULL;
        hr -> ch[0] = treap; hr -> data1 = now; hr -> data2 = now2;
        treap -> fa = hr; hr -> update();
        treap = hr; 
    }
    else {
        Node *hr = new Node;
        treap -> find_key(rnk) -> splay(NULL);
        treap -> find_key(rnk + 1) -> splay(treap);
        hr -> data1 = now;
        hr -> data2 = now2;
        hr -> ch[0] = NULL;
        hr -> ch[1] = treap -> ch[1];
        hr -> fa = treap; treap -> ch[1] = hr;
        hr -> ch[1] -> fa = hr; hr -> update(); treap -> update();
    }
}

void Node::clear()
{
    if (ch[0] != NULL) ch[0] -> clear();
    if (ch[1] != NULL) ch[1] -> clear();
    delete this;
}

void Node::update()
{
    sz = 1;
    sum1 = data1 * data2 % MOD;
    sum2 = (data1 * (data1 + 1) / 2) * data2 % MOD;
    sum3 = data2;

    if (ch[0] != NULL) {
        sz += ch[0] -> sz;
        sum1 = (sum1 + ch[0] -> sum1) % MOD;
        sum2 = (sum2 + ch[0] -> sum2) % MOD;
        sum3 = (sum3 + ch[0] -> sum3) % MOD;
    }
    if (ch[1] != NULL) {
        sz += ch[1] -> sz;
        sum1 = (sum1 + ch[1] -> sum1) % MOD;
        sum2 = (sum2 + ch[1] -> sum2) % MOD;
        sum3 = (sum3 + ch[1] -> sum3) % MOD;
    }
}

int main()
{
    freopen("cross.in", "r", stdin);
    freopen("cross.out", "w", stdout);
    
    in(r); in(c); in(n);

    FOR(i, 0, r + 1) {
        lr[i].resize(c + 2);
        tp[i].resize(c + 2);
        co[i].resize(c + 2);
        line[i].resize(c + 2);
    }

    FOR(i, 1, r) FOR(j, 1, c) line[i][j] = 1;
    
    FOR(i, 1, n) {
        LL x, y;
        in(x); in(y);
        line[x][y] = 0;
    }

    FOR(i, 1, r) {
        FOR(j, 1, c) {
            if (line[i][j] == 0) continue;
            if (j == 1 || line[i][j - 1] == 0) lr[i][j] = 0;
            else lr[i][j] = lr[i][j - 1] + 1;
        }
        DNF(j, c, 1) {
            if (line[i][j] == 0) continue;
            if (j == c || line[i][j + 1] == 0) lr[i][j] = 0;
            else chkmin(lr[i][j], lr[i][j + 1] + 1);
        }

        FOR(j, 1, c) if (line[i][j]) {
            if (i == 1 || !line[i - 1][j]) tp[i][j] = 0;
            else tp[i][j] = tp[i - 1][j] + 1;
        }
    }

    DNF(i, r, 1) {
        FOR(j, 1, c) if (line[i][j]) {
            if (i == r || !line[i + 1][j]) co[i][j] = 0;
            else co[i][j] = co[i + 1][j] + 1;
        }
    }

    treap = NULL;
    bool is_cleared = true;

    LL ans = 0;
    
    FOR(j, 1, c) {
        if (!is_cleared) {
            treap -> clear();
            treap = NULL;
            is_cleared = true;
        }

        FOR(i, 1, r) {
            if (i > 2) {
                if (lr[i - 2][j] != 0 && line[i - 1][j]) {
                    treap -> insert(lr[i - 2][j], tp[i - 2][j]);
                    is_cleared = false;
                }
            }
            
            if (!line[i][j]) {
                if (!is_cleared) {
                    treap -> clear();
                    treap = NULL;
                    is_cleared = true;
                }
                continue;
            }

            LL now = lr[i][j];
            
            if (now && treap != NULL) {
                LL rnk = treap -> get_rnk(now);
                if (rnk != 0) {
                    Node *hr;
                    if (rnk != treap -> sz) {
                        treap -> find_key(rnk + 1) -> splay(NULL);
                        treap -> find_key(rnk) -> splay(treap);
                        hr = treap -> ch[0];
                    }
                    else {
                        treap -> find_key(rnk) -> splay(NULL);
                        hr = treap;
                    }
                    LL fst = hr -> sum1 * now % MOD * co[i][j] % MOD;
                    LL sec = hr -> sum2 * co[i][j] % MOD;
                    ans = (ans + fst - sec) % MOD;
                }

                if (rnk != treap -> sz) {
                    Node *hr;
                    if (rnk != 0) {
                        treap -> find_key(rnk) -> splay(NULL);
                        treap -> find_key(rnk + 1) -> splay(treap);
                        hr = treap -> ch[1];
                    }
                    else {
                        treap -> find_key(rnk + 1) -> splay(NULL);
                        hr = treap;
                    }
                    LL valu =
                        (now * now - now * (now + 1) / 2) * co[i][j] % MOD;
                    ans = (ans + hr -> sum3 * valu % MOD) % MOD;
                }
            }
        }
    }

    printf("%lld\n", ans);
        
    return 0;
}

```

---


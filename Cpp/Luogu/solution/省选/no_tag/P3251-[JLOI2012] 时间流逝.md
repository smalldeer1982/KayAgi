# [JLOI2012] 时间流逝

## 题目描述

生活可以很简单。可以探索水底世界的神秘，也可以去发现奇特新生物，亦或踏上一段新生的旅程。在必须要迎接挑战或跟周围的生物进行生存争夺之前，享受自由的飞翔。此时你会觉得生活是如此美好。

像蛇喜欢吃浮游生物一样（哦，我好像忘记告诉你这个常识），每天，你可以吃一些你周围的基础生物，然后会在你的尾巴上得到一个能量圈。你将会有好多种不同的能量圈，每一个都会被赋予一个能量。你可以拥有多个同种的能量圈，但是对于新得到的相同的能量圈，它的能量不能大于你已拥有的任何一个能量圈。除了前面的规则，获得新的能量圈的种类的概率是一样的。一天天过去，你得到越来越多的能量，开始了进化演变。

但是你也有自己的问题，有时你会面对邪恶的果冻鱼。它会追着你咬你，你不得不扔出最小能量值的能量圈然后赶忙逃跑。在这种情况下，你不会有任何的胃口了，因此这天你将不再得到任何能量圈。幸好，当你没有任何能量圈的时候，果冻鱼就算看见你也不会追着你，此时你可以好好地享用美食。

你听说当你的总的能量值超过了某个阈值之后，可以进化成强大模式并能够吃掉果冻鱼。是时候反击了！下面是本题的问题：预计要过多少天你才能进化成强大模式？（第一天默认你没有任何能量圈）


## 说明/提示

对于所有数据，0.1<=P<=0.9，1<=T<=50，1<=N<=50。


## 样例 #1

### 输入

```
0.5 0 1
1
0.5 1 2
1 2```

### 输出

```
1.000
2.000```

# 题解

## 作者：MKCCT (赞：13)

太菜了，大佬的题解都解释得比较简单，不太能看懂，于是就来写一篇友好一点的。

由于题面实在是太阅读理解了，我们先来提炼一个形式化的表述：给定 $n$ 种价值不同的元素，你需要维护一个可重集（开始是空集）。每一步你有 $p$ 的概率删除集合中一个价值最小的元素，如果当前是空集则这种情况概率为 $0$；否则你将等概率的获得一个元素，满足这个元素的价值不大于任何一个已经获得的元素的价值。求达到（或超过）给定的一个阈值 $T$ 所需的期望步数。

设 $f(S)$ 表示当前集合为 $S$ 时要达到目标的期望步数。记 $P$ 为达到当前状态的上一个状态集合，$\operatorname{suc}S$ 为 $S$ 的后继集合所组成的集族。

于是有转移：
$$f(S)=1+pf(P)+\frac{1-p}{|\operatorname{suc}S|}\sum_{V\in\operatorname{suc}S}f(V)$$

由之前的定义，显然 $S$ 的前驱 $P$ 是唯一的，等于 $S\setminus\{\min S\}$。如果我们将状态看作结点，转移关系看作边，那么整个转移过程形成了一个树形结构，前驱状态是父结点，后继状态是子结点。

这个转移显然是有后效性的，为了消去后效性，我们接下来将要证明：每个点的状态 $f(S)$ 都可以由父节点 $fa_S$ 表示成 $k_Sf(fa_S)+b_S$ 的形式，其中 $k_S,b_S$ 是对每个 $S$ 唯一的常数。

采用归纳法：对于叶结点，结论显然成立。现在考虑一个非叶结点。为了方便书写，记 $t=\frac{1-p}{|\operatorname{suc}S|}$，并将刚才转移中后面的那些状态用当前结点表示，有
$$f(S)=1+pf(P)+t\sum_{v\in\operatorname{suc}S}(k_Vf(S)+b_V)$$
再记
$$\sigma_k(S)=\sum_{V\in\operatorname{suc}S}k_V,\sigma_b(S)=\sum_{V\in\operatorname{suc}S}b_V$$
继续推刚才的式子：
$$\begin{aligned}&f(S)=1+pf(P)+t\sigma_k(S)f(S)+t\sigma_b(S) \\ \iff& (1-t\sigma_k(S))f(S)=pf(P)+1+t\sigma_b(S) \\ \iff& f(S)=\frac{p}{1-t\sigma_k(S)}f(P)+\frac{1+t\sigma_b(S)}{1-t\sigma_k(S)}\end{aligned}$$
这样便证明了当前结点也可用父结点表示，按照归纳假设，证毕。

结论证明了，做法也便明确了。我们可以按照树形 DP 那样 DFS，每次转移时维护结点的 $k,b$ 即可。最终答案就是 $f(\varnothing)$，也就是根节点的 $b$。每个状态的可重集只需用当前的价值和、已选元素的最小值构成的二元组来刻画。

代码短得离谱。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<double,double> pdd;

int n,T,a[55];
double p;

pdd dfs(int sum,int mn)
{
    if(sum>T) return make_pair(0,0);
    double k=0,b=0,t=(1-p)/mn;
    for(int i=1;i<=mn;++i)
    {
        pdd nxt=dfs(sum+a[i],i);
        k+=nxt.first,b+=nxt.second;
    }
    if(!sum) t=1.0/mn;
    return make_pair(p/(1-t*k),(1+t*b)/(1-t*k));
}

int main()
{
    while(~scanf("%lf%d%d",&p,&T,&n))
    {
        for(int i=1;i<=n;++i) scanf("%d",a+i);
        sort(a+1,a+n+1);
        printf("%.3f\n",dfs(0,n).second);
    }
    return 0;
}
```

---

## 作者：Semorius (赞：7)

模拟赛出了这题，整理一下。~~sto jimmyywang~~

由于每次选到的数都比上一个小，所以所有可达到的状态序列都是单调递减的，每次只能在序列的末尾增减一个数，如果序列中所有数的和大于 $T$，则停止操作。

尝试在每种状态间连边，从上一种状态到下一种可到达的状态连有向边。像这样（$T=3,n=2$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9awgev02.png)

发现每一个状态删去末尾的数后，对应唯一的状态，所以所有的状态连完边后形成一个树形结构。由于存在回溯，所以树上均为双向边。叶子结点就表示已经超过阈值，没有后继状态。设状态总数为 $S$，将每个点编号为 $1$ 到 $S$，极限数据下 $S$ 约为 $1e6$。

设 $dp_x$ 表示从编号为 $x$ 的状态走到叶子结点的期望步数。那么对于每一个 $x \in leaf$，显然 $dp_x=0$（已经到达）。对于每一个非叶子非根节点 $x$ 所表示的状态，有 $P$ 的概率走到父亲，有 $\frac{1-P}{cnt_{x}} $ 的概率走到每一个儿子，其中 $cnt_{x}$ 表示 $x$ 的子节点个数，所以有如下转移：

$$dp_x=P \times (dp_{fa}+1)+\frac{1-P}{cnt_x} \times \sum_{y \in son}(dp_y+1)$$

化简以后得到：

$$dp_x=1 + P \times dp_{fa} + \frac{1-P}{cnt_x} \times \sum_{y \in son}dp_y$$

这个转移有后效性。尝试用待定系数法将 $dp_x$ 用 $dp_{fa}$ 表示。

设 $dp_x = k_x \times dp_{fa} + b_x$，代入上式得：

$$dp_x=1 + P \times dp_{fa} + \frac{1-P}{cnt_x} \times \sum_{y \in son}(k_y \times dp_x + b_y)$$

化简得：

$$dp_x = \frac{P}{1-\frac{1-P}{cnt_x} \times \sum_{y \in son}k_y} \times dp_{fa} + \frac{1 + \frac{1-P}{cnt_x} \sum_{y \in son}b_y}{1 - \frac{1-P}{cnt_x} \sum_{y \in son}k_y}$$

所以：

$$k_x = \frac{P}{1-\frac{1-P}{cnt_x} \times \sum_{y \in son}k_y}$$

$$b_x = \frac{1 + \frac{1-P}{cnt_x} \sum_{y \in son}b_y}{1 - \frac{1-P}{cnt_x} \sum_{y \in son}k_y}$$

回溯时转移 $b_x$ 和 $k_x$ 即可。

由于根节点（初始状态：空序列）没有父亲，所以在根节点时 $P = 0$， $b_{root}$ 即为答案。

时间复杂度 $O(S)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int SIZE = 2000005;
double P, b[SIZE], k[SIZE];
int n, m, a[SIZE], iid;

bool cmp(int x, int y){
	return x > y;
}

void deal(int now, int id, int sum){
	if(sum > m) return;
	int x = id, cnt = n-now+1;
	double sb = 0, sk = 0, t = (1.0-P);
	for(int i = now; i <= n; i++){
		int y = ++iid;
		deal(i, y, sum+a[i]);
		sb += b[y]; sk += k[y];
	}
	if(x == 1) P = 0, t = 1.0; 
	t = t / (double)cnt;
	k[x] = P/(1.0-t*(double)sk);
	b[x] = (1.0+t*(double)sb)/(1.0-t*(double)sk);
}

int main(){
	while(~scanf("%lf%d%d", &P, &m, &n)){
		for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
		sort(a+1, a+n+1, cmp);
		iid = 1;
		deal(1, 1, 0);
		printf("%.3lf\n", b[1]);	
	}
	return 0;
}

```


---

## 作者：Tony102 (赞：6)

[Link](https://www.luogu.com.cn/problem/P3251)

[更好的阅读体验](https://tony102.xyz/index.php/2021/03/11/luogu3251-jloi2012%e6%97%b6%e9%97%b4%e6%b5%81%e9%80%9d/)

### Sol

学习树上高斯消元

这个玩意儿，非常简单！！！只需要初中代换功底，你就可以掌握！！因为这不是什么高斯消元（其实也算，但是介于只有两个元消都只需要消一次，代回也只有一次，所以就像是在算式子一样

设 $f(S)$ 表示到达当前集合$S$的期望步数。暴力枚举前驱状态，记为 $pre$， 选出$\leq min$ 然后达到的**后继集合所形成的集合**记为$nxt_S$，其中每一个后继集合满足$\sum_{v \in nxt_S} f(nxt_v) = nxt_S$

那么可以得到暴力转移：

$$f(S) = 1 + p\times f(pre) + \frac{1-p}{|nxt_S|} \sum_{v \in nxt_S} f(nxt_v)$$

$|nxt_S|$表示能够后继集合所形成的集合的大小。

这个式子表达的意思就是，从$pre$集合转移到当前这个集合，需要$1$步，再加上有$p$的概率删除$pre$集合中的一个数所需要的步数$f(pre)$ 。最后还有从所有后继集合中选出一个，这个是$\frac{1}{|nxt_S|}$ ，有$1-p$的概率加进来一个数，再乘上到达后继集合的期望步数$f(nxt_v)$

现在来做”树上高斯消元“。对于一个集合$S$，删除$S$中的一个元素后的集合就是$pre$，因此$pre$是唯一确定的。但是每次加进去的数$x$都只满足$x \leq min_s$ ，  $min_s$ 表示$S$中最小的元素。所以后继状态$nxt$可能有多个。我们把$pre$看做$S$的父亲，$nxt_v$ 看做$S$的儿子。那么转移之间构成一棵树。所以叫做树上高斯消元。

那么我们想，假如我们可以把$f(S)$表示成一个高斯消元的一般形式，也就是未知元全部在左边，常数项留在右边的形式。更加具体地，可以被表示为

$f(S) = k \times f(pre) + b$

的形式。

那么$f(S)$仅跟父亲($f(pre)$) 和儿子的状态相关。从底向上操作，把每个儿子也表示成这种形式，就可以代入消元。比如说，对于一个叶子节点，没有跟儿子相关的项，那么叶子的期望可以被直接计算。叶子是父亲的未知元中的一项，现在它被解出来了，也就可以在父亲的未知元中被消去。

具体地，我们来看一下是怎么操作的。

把常数项全部留在右边

$$f(S) - p\times f(pre) - \frac{1-p}{|nxt_S|} \sum_{v \in nxt_S} f(nxt_v)  = 1$$

$\frac{1-p}{|nxt_S|}$ 是一个常量，我们记$C = \frac{1-p}{|nxt_S|}$

把$f(s)$表示成上面那种形式，我们先把$f(nxt)$也就是它的子节点写成那种形式。为了方便，我们记$a_k(S) = \sum_{v \in nxt_S} k_v$ 

$a_b(S) = \sum_{v \in nxt_S} b_v$

现在就变成了
$$f(S) - p \times f(pre) - C\times a_k(S)f(S)- C \times a_b(S) = 1$$

对于$f(S)$这一项，有可以系数提前

$(1 - C \times a_k(S)) f(S) = 1 + p \times f(pre) + C \times a_b(S)$

系数化为$1$，直接除过去

$$f(S) = \frac{p \times f(pre)}{1 - C \times a_k (S)} + \frac{1 + C \times a_b(S)}{1 - C \times a_k (S)} $$

现在我们只要从低至上，依次算出$a_b (S)$ 和 $a_k (S)$ ，给当前节点的$k, b$ 对应加上子节点贡献上来的就可以了

代码也非常简单，一看就懂



### Code

**[Code戳这里](https://tony102.com/archives/12/)**


---

## 作者：LimpidSlirm (赞：2)

## 题意

给定 $n$ 个价值不同的元素，维护一个初始为空的可重集合。如果集合为空，则等概率地获得一个元素。如果集合不为空，则有 $p$ 的概率删除集合中最小的一个元素，或者 $1-p $ 的概率获得一个随机的元素，并且该元素的价值不大于集合中的任何一个元素，即小于等于集合中最小元素。求整个集合的元素价值之和大于 $t$ 的期望步数。

## Solution

发现对于某一种状态，去掉一个元素后的状态是唯一的，而添加一个元素后则可能有多种后继状态，类似树的结构，故考虑对于状态建树。对于每个节点 $i$，定义其前驱节点为 $pre_i$，其后继节点为 $suc_i$。令 $dp_{\mathtt{S}}$ 为当前集合为 $\mathtt{S}$ 时的期望步数，则可以写出转移方程：
$$
dp_{\mathtt{S}} = 1 + p \times dp_{pre_{\mathtt{S}}} + \dfrac{1-p}{\mid suc \mid} \times \sum_{ v \in suc_{\mathtt{S}}} dp_v
$$
且对于叶子节点，由于其没有后继节点，则有：
$$
dp_{\mathtt{S}} = p \times dp_{pre_{\mathtt{S}}} +1
$$
发现 $dp_{\mathtt{S}}$ 和 $dp_{pre_{\mathtt{S}}}$ 是线性关系，故推断所有子节点和父节点都是线性关系。设 $dp_{\mathtt{S}}=k_{\mathtt{S}}\times dp_{pre_{\mathtt{S}}}+b_{\mathtt{S}}$，则代换后有
$$
dp_{\mathtt{S}} = 1 + p \times dp_{pre_{\mathtt{S}}} + \dfrac{1-p}{\mid suc \mid} \times \sum_{ v \in suc_{\mathtt{S}}} (k_v \times dp_{\mathtt{S}} + b_v)
$$

$$
dp_{\mathtt{S}} = 1 + p \times dp_{pre_{\mathtt{S}}} + \dfrac{1-p}{\mid suc \mid} \times \sum_{ v \in suc_{\mathtt{S}}} b_v + dp_{\mathtt{S}}\times \dfrac{1-p}{\mid suc \mid} \times  \sum_{ v \in suc_{\mathtt{S}}} k_v
$$

移项：
$$
dp_{\mathtt{S}} \times ( 1-\dfrac{1-p}{\mid suc \mid} \times  \sum_{ v \in suc_{\mathtt{S}}} k_v)= p \times dp_{pre_{\mathtt{S}}} + \dfrac{1-p}{\mid suc \mid} \times \sum_{ v \in suc_{\mathtt{S}}} b_v + 1
$$
将式子化成 $dp_{\mathtt{S}}=k_{\mathtt{S}}\times dp_{pre_{\mathtt{S}}}+b_{\mathtt{S}}$ 形式：
$$
dp_{\mathtt{S}} = \dfrac{p}{ 1-\dfrac{1-p}{\mid suc \mid} \times  \sum_{ v \in suc_{\mathtt{S}}} k_v } \times dp_{pre_{\mathtt{S}}} + \dfrac{ \dfrac{1-p}{\mid suc \mid} \times \sum_{ v \in suc_{\mathtt{S}}} b_v + 1 }{ 1-\dfrac{1-p}{\mid suc \mid} \times  \sum_{ v \in suc_{\mathtt{S}}} k_v }
$$
一遍 DFS 即可求出所有节点的 $k_{\mathtt{S}}$ 以及 $b_{\mathtt{S}}$。答案即为 $dp_{\emptyset}$ ，发现对于空集，其没有前驱节点，即 $dp_{pre_{\emptyset}}$ 为 $0$，答案即为  $b_{\emptyset}$。

## code

```cpp
#include<bits/stdc++.h>
inline int read()
{
	int res=0,flag=1;
	char ch=getchar();
	while(!isalnum(ch)) (ch=='-')?flag=-1:1,ch=getchar();
	while(isalnum(ch)) res=res*10+ch-'0',ch=getchar();
	return res*flag;
}
int n,goal;
int val[50];
double p;
std::pair<double,double> dfs(int min,int sum)
{
	if(sum>goal)
		return std::make_pair(0.0,0.0);
	double sumk=0,sumb=0,tmp=(1-p)/min;
	for(int i=1;i<=min;i++)
	{
		std::pair<double,double> ans=dfs(i,sum+val[i]);
		sumk+=ans.first;
		sumb+=ans.second;
    }
	if(sum==0)
		tmp=1.0/min;
	sumk=1-tmp*sumk;
	sumb=1.0+tmp*sumb;
	return std::make_pair(p/sumk,sumb/sumk);
}
int main(int argc,const char *argv[])
{
	while(scanf("%lf",&p)!=EOF)
	{
		goal=read(),n=read();
		for(int i=1;i<=n;i++)
			val[i]=read();
		std::sort(val+1,val+n+1);
		printf("%.3f\n",dfs(n,0).second);
	}
	return 0;
}
```

---

## 作者：wenhao801 (赞：2)

模拟赛考了这个原题，然而两份题面都套上了厚重的题目背景，恐怖。

给定一长为 $m$ 的有序序列 $\{a_i\}$，序列内元素两两不同。你现在有一个栈，初始为空，你会不断执行以下操作直到栈内元素之和 $\ge n$。一次「操作」过程如下：

- 如果栈不为空，则有 $p$ 的概率弹出一个元素。
- 如果没弹，在所有 $\le$ 栈顶的 $a_i$ 里随机地取一个，将其入栈（指，不把 $a_i$ 删掉，下一次也可能继续入栈）。

问操作终止时期望进行了几次操作。

$1 \le n, m \le 50, 0.1 \le p \le 0.9$。

------

想要快速地通过这道题目，只需要注意到由于栈内元素是有序的、且和最多为 $50$，所以不同的状态其实没多少……实测只有 $1.3 \times 10^6$ 个。所以直接暴力建出所有状态树上高消就完了……

------

然而这个玩意是有多项式做法的……

为了精准地描述“概率”，我们把一个栈内的状态称为“点”，状态之间的转移关系称为“边”，边权就是做这样一个转移的概率（$p$ 或者 $(1-p)/i$）。那么答案就是对于每条路径求和：路径的边权之积乘上路径的边数。

我们考虑把一条路径拆成这样几个部分：先是经过一些绕弯（不到终点）之后回到空栈的状态，然后加入一个元素、且之后这个元素不会被弹出；然后再经过一些绕弯之后回到仅一个元素的状态，再加入第二个元素……

这里我们使用类似于 PGF 的生成函数来刻画。考场上我尝试过直接 dp，但各种概率和期望混在一块十分容易算错。我们设 $P_{i, s}(x)$ 为从栈内元素个数为 $i$、和为 $s$ 的状态走了若干步、又回到同一状态的一生成函数，$[x^k]P_{i, s}(x)$ 表示走 $k$ 步后回到同一状态的这些路径的边权乘积之和。枚举从这个状态开始加入的第一个元素，就有
$$
P_{i, s} (x) = 1 + \sum_j \left( \dfrac{1-p}{i}x \right) \cdot P_{j, s + a_j}(x) \cdot (px) \cdot P_{i, s}(x)
$$
设 $Q_{i, s}(x)$ 表示从状态 $i, s$ 走到结束的一生成函数，$[x^k]Q_{i, s}$ 意义同 $P$，同样有
$$
Q_{i, s}(x) = P_{i, s} (x) \cdot \sum_{j} \left( \dfrac{1-p}{i}x \right) \cdot Q_{j, s + a_j}(x)
$$
然后直接去维护 $P_{i, s}'(1), P_{i, s}(1), Q'_{i, s}(1), Q_{i, s}(1)$ 就可以了。这里我们不需要思考这些取值的意义是什么，只需要知道它们表示一些边权乘积的和，只有 $Q'_{0, 0}(1)$ 有明确的意义（就是要求的答案）。复杂度 $O(m^2 n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

inline int read () {
	int ret = 0, t = 1;
	char c = getchar();
	while ((c < '0' || c > '9') && c != '-') c = getchar();
	if (c == '-') t = -1, c = getchar();
	while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
	return ret * t;
}

const int MAXN = 55;
double p; int n, m, a[MAXN];

struct poly {
	double val, _val;
	poly (double v = 0, double _v = 0) { val = v, _val = _v; }
	poly operator + (const poly &tmp) const { return poly(val + tmp.val, _val + tmp._val); }
	poly operator - (const poly &tmp) const { return poly(val - tmp.val, _val - tmp._val); }
	poly operator * (const poly &tmp) const { return poly(val * tmp.val, val * tmp._val + _val * tmp.val); }
	poly operator / (const poly &tmp) const { return poly(val / tmp.val, (_val * tmp.val - val * tmp._val) / (tmp.val * tmp.val)); }
} P[MAXN][MAXN], Q[MAXN][MAXN];
bool visP[MAXN][MAXN], visQ[MAXN][MAXN];

poly calcP (int i, int s) {
	if (s >= n) return poly(0, 0);
	if (visP[i][s]) return P[i][s];
	poly tmp = poly(0, 0);
	for (int j = max(i, 1); j <= m; j++) {
		double pr = (i ? (1 - p) : 1.0) / min(m, m - i + 1);
		tmp = tmp + poly(pr, pr) * calcP(j, s + a[j]) * poly(p, p);
	}
	tmp = poly(1, 0) / (poly(1, 0) - tmp);
	return P[i][s] = tmp;
}
poly calcQ (int i, int s) {
	if (s >= n) return poly(1, 0);
	if (visQ[i][s]) return Q[i][s];
	poly tmp = poly(0, 0);
	for (int j = max(i, 1); j <= m; j++) {
		double pr = (i ? (1 - p) : 1.0) / min(m, m - i + 1);
		tmp = tmp + poly(pr, pr) * calcQ(j, s + a[j]);
	}
	tmp = calcP(i, s) * tmp;
	return Q[i][s] = tmp;
}

int main () {
	while (scanf("%lf", &p) != EOF) {
		n = read() + 1, m = read();
		int i, j;
		for (i = 1; i <= m; i++) a[i] = read();
		sort(a + 1, a + m + 1, [](int u, int v) { return u > v; });
		printf("%.3lf\n", calcQ(0, 0)._val);
		memset(visP, 0, sizeof visP), memset(visQ, 0, sizeof visQ);
	}
	return 0;
}
```

---

## 作者：DeepSeaSpray (赞：1)

## 题目大意

有一个数集 $A$。

维护一个可重集 $S$，若集合不为空，每天有 $p$ 的概率去掉最小值。剩下的 $1-p$ 的概率中，等概率的添加 $A$ 中小于 $S$ 的所有元素的一个元素。

当集合中所有的元素之和**大于** $T$ 时进化成强大模式。

求进化的期望天数。

## 题目解法

我们设 $f(S)$ 为当前集合期望的进化天数。

$$
f(S) = p f(P) + \frac{1-p}{m} \sum_{i=1}^m f(T) + 1
$$

其中 $P$ 表示 $S$ 去掉最小值后的集合，$T$ 表示 $S$ 加上一个元素后的集合，即题目中说的两种操作所对应的集合。

我们可以发现 $T$ 去掉其最小值后为 $S$。

所以这构成了一颗树的形式，其中叶子节点即已经进化了的集合，根节点即空集。

考虑消除后效性，运用数学归纳法，假设对于所有的节点都有 $f(S) = k f(P) + b$。

归纳奠基，对于叶子节点，可令 $k = b = 0$，显然成立。

对于一个非叶子节点：

$$
f(S) = p f(P) + \frac{1-p}{m} \sum_{i=1}^m k_i f(S) + b_i + 1
$$

记：

$$
t = \frac{1-p}{m},\ K = \sum_{i=1}^m k_i,\ B = \sum_{i=1}^m b_i
$$

有：

$$
f(S) = \frac{p}{1 - t K} f(P) + \frac{1 + t B}{1 - t K}
$$

即证。

当 $S$ 为空集的时候 $f(S)$ 就是我们要求的答案，然而此时 $f(P) = 0$ 故只需求 $\varnothing$ 处的 $b$ 即可。

我们递归处理即可。

值得注意的是，我们可以只用集合元素之和与集合元素最小值来描述集合，另当 $S = \varnothing$ 时应令 $t = \frac{1}{m}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50;
#define P pair<double,double>
#define fir first
#define sec second
double p;
int T,n;
int a[maxn+5];
P Dfs(int sm,int mn){
	if(sm>T) return P(0,0);
	else{
		double k=0,b=0;P tmp;
		for(int i=1;i<=mn;i++){
			tmp=Dfs(sm+a[i],i);
			k+=tmp.fir,b+=tmp.sec;
		} 
		double t;
		if(sm) t=(1-p)/mn;
		else t=1.0/mn;
		return P(p/(1-t*k),(1+t*b)/(1-t*k));
	}
}
signed main(){
	while(scanf("%lf%d%d",&p,&T,&n)!=EOF){
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		sort(a+1,a+n+1);
		printf("%.3lf\n",Dfs(0,n).sec);
	}
	return 0;
}
```

---

## 作者：serverkiller (赞：0)

# 概率dp
---

数据这么小，~~最血腥的~~暴力肯定可以过

看到题干，在没有~~呼啦圈~~能量圈的时候，鱼是不会来找麻烦的。所以在没有能量圈的时候可以不乘p，直接转移。

一般地，

$$dp[i] = 1+p\cdot dp[last(i)]+(1-p)\cdot \frac{1}{next(i)}\cdot \Sigma dp[next(i)]$$

$$上面的两个加号分别是由某鱼袭击和健康生长转移得到$$

这个dp的开始是0，结束是大于t的任意数，显然是一个一对多的情况，完全可以使用树来进行转移 ~~（看了题解才知道的）~~

然后我们有两种方向，一种这里止步，进行高斯消元；另一种可以推导，将dp式改成线性的。即
$$dp[i] = k\cdot dp[last(i)] + t$$

待定系数法，将上式代入原来的转移方程，经过计算，我们会发现：

$$dp[i] = \frac{p}{1-s\cdot \Sigma k}\cdot dp[last(i)] + s \cdot \Sigma t$$
其中：
$$s = (1-p)\cdot \frac{1}{next(i)}$$

分析完毕，下面是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

double p,ans[55][55],k[55][55];
bool vis[55][55];
int n,t,a[55];

void dfs(int e,int m)
{
	if (vis[e][m]) return ;
	vis[e][m] = 1;
	double x = 0.0,y = 0.0;
	for (int i = 1; i <= m; i++)
	{
		if (a[i] + e > t) break;
		dfs(a[i] + e,i);
		x += ans[e + a[i]][i];
		y += k[e+a[i]][i];
	}
	double sum = (e == 0)?1.00 / ((double)m):(1.00-p) / ((double)m);
	k[e][m] = p / ((double)1 - sum * y);
	ans[e][m] = (sum * x+1.00) / ((double)1 - sum * y);
}

int main()
{
	while (scanf("%lf",&p) != EOF)
	{
		scanf("%d%d",&t,&n);
		//cout << p << t << n << endl;
		for (int i = 1; i <= n; i++)
		{
			scanf("%d",&a[i]);
		}
		memset(vis,0,sizeof(vis));
		sort(a+1,a+n+1);
		dfs(0,n);
		printf("%.3lf\n",ans[0][n]);
	}
	return 0;
}
```


---


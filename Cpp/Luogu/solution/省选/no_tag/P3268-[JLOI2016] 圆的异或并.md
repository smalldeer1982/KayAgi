# [JLOI2016] 圆的异或并

## 题目描述

在平面直角坐标系中给定 $N$ 个圆。已知这些圆**两两没有交点**，即两圆的关系只存在相离和包含。求这些圆的异或面积并。

异或面积并定义为：当一片区域在奇数个圆内，则计入其面积，否则，当一片区域在偶数个圆内则不计入其面积。

## 样例 #1

### 输入

```
2
0 0 1
0 0 2```

### 输出

```
3```

# 题解

## 作者：shadowice1984 (赞：22)

扫描线233……

大家还记的如何求圆的并吗？

当然是暴力自适应Simpson积分啦……

但是这道题让你除π输出哦，而且是鬼畜的异或并哦！

所以我们的直觉开始告诉我们这道题可能和寄蒜几盒并不沾多少边

反而像是一些奇怪的东西……

## 当觉得题目开始辣手的时候，请注意那些奇怪的条件

比如说这道题来讲，我们发现很奇怪的是没有相交的圆，甚至连内切外切都没有

那么我们就要注意了……

也就是说我们发现这些圆的关系可以这样来描述

如果**a在b中，b在c中，则a在c中**

类比这一句话：

**如果a<b,b<c,则a<c**

这意味嵌套是有**传递性**的

再考虑这个性质，**如果a在b中，则a被b包含**

类比这样一句话

**如果 a小于b,则b大于a**

这意味着嵌套是有**自反性**的

要知道，传递性和自反性是小于号的两个基本性质，也是它作为一个返回值为bool运算符的本质……，换句话来讲，假设我们开发出了一个奇怪的运算，使得这个bool返回值的东西也具有**传递性和自反性**，这个运算符就和小于号逻辑上**等价**

逻辑上等价意味着我们基于**小于号性质**开发的所有高速算法和数据结构都可以用了，比如sort，比如set，比如priority_queue

因此我们发现这道题可以用一个优美的扫描线做法搞过去

### 扫描线

其实扫描线并不是一个玄学的算法，而是一种思想，思想性的东西注定了可以它很难也可以很简单……，真正写程序的时候扫描线并不存在

扫描线通常用来处理二位平面上的一些问题，因为同时处理两维信息会极端辣手，所以我们假象有一条与y轴平行，无限长的直线，从左到右缓慢移动，这样这一条线上的点的**x值全部相同，我们就可以专心考虑y的信息**了

其实说这个主要是让大家从感情上接纳扫描线，毕竟掌握这玩意还是得靠做题……

-------

首先我们发现把一个整圆插进去是不行的，因为我们需要关注的是这个圆层数的
奇偶性，但是set又是不可重的，所以在同一层的圆会十分辣手……

但是一旦我们换个思路，毕竟现在我们可以使用扫描线这个有力的工具，我们自然会发现，这个图形和扫描线的点交点是**高度括号化**的，也就是说，我们对于一个圆来讲，发现它上面的最近交点和下面最近交点一定是属于一个圆

因此我们可以考虑不存一个正圆，因为扫描线要计算交点……正圆没法计算

所以拆成两个半圆函数，这个我们就可以维护了

那么我们具体来讲怎么做呢？

首先我们发现按x排序后，每个圆会在x上会有一个出现区间，而且更棒的是如果a嵌套了b
那么**a一定比b早出现晚消失**

所以我们将一个圆拆成两个操作点，一个加入点，坐标为x-r,一个为删除点，坐标为x+r

之后排序，从小到大处理操作序列

如果这个点是加入点，那么像set里插入一个上圆弧和下圆弧，并且查找上圆弧的前驱（你要查下圆弧后继也行，但是我嫌判end麻烦~）

如果这个前驱是下圆弧，那么这个圆的层数奇偶性应该和前驱的**奇偶性相反**

如果是上圆弧，那么这个圆的层数奇偶性应该和前驱的**奇偶性相同**

 _(还是不懂的话自己画图理解啦~，我懒得插图了……)_ 
 
 此时我们就可以处理每个圆的奇偶性了，暴力的奇加偶减即可
 
 那么如果是删除的话该怎么办呢？set里大力erase即可……
 
 最后一个问题(可能是两个？)
 
 我们该如何定义小于号？
 
 由于是在扫描线，因此我们时刻记录下来扫描线的x坐标，暴力计算每个函数的函数值比较，由于不会相交，所以相对大小关系不变……
 
 另外，插入上圆弧的时候函数值和下圆弧相等，该如何解决？
 
 我们让这两个的值错开一个eps即可……
 
 具体细节看代码吧，不作死还是很好写的
 
 对了，一般这种东西存下标会非常好写，要是存值的话……祝您好运
 
 上代码~
 
 ```C
#include<cstdio>
#include<algorithm>
#include<set>
#include<cmath>
using namespace std;
typedef double db;typedef long long ll;
const int N=2*1e5+10;const db eps=1e-9;
db a[N];db b[N];db r[N];int o[N];int n;db nx;
struct cir//我们这里只存了下标 tp=1/-1 
{
	int tp;int u;cir(int T=0,int N=0){tp=T,u=N;}//这里的计算函数+了一个eps，防止冲突 
	inline db cy(){return b[u]+(db)tp*(sqrt(r[u]*r[u]-(nx-a[u])*(nx-a[u]))+eps);}
	friend bool operator <(cir a,cir b){db jud=a.cy()-b.cy();return jud<-eps;}
};set <cir> s;ll res;
struct pot
{
	int tp;int v;int u;//操作序列点，写了个赋值函数方便压行 
	inline void rv(int T=0,int V=0,int U=0){tp=T;v=V;u=U;}
	friend bool operator <(pot a,pot b){return a.v<b.v;}
}op[2*N];int cnt;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)//读进来 
	{
		scanf("%lf%lf%lf",&a[i],&b[i],&r[i]);
		op[++cnt].rv(1,a[i]-r[i],i);op[++cnt].rv(0,a[i]+r[i],i);
	}sort(op+1,op+cnt+1);//sort一遍 
	for(int i=1;i<=cnt;i++)
	{
		nx=op[i].v;
		if(op[i].tp)
		{
			int nw=op[i].u;set <cir> ::iterator it;
			it=s.insert(cir(1,nw)).first;//set的insert返回一个pair类型 
			if(it==s.begin()){o[nw]=1;}//特判无前驱 
			else //找到前驱 
			{
				--it;if((*it).tp==-1){o[nw]=o[(*it).u]^1;}
				else {o[nw]=o[(*it).u];}
			}
			if(o[nw]){res+=r[nw]*r[nw];}else {res-=r[nw]*r[nw];}//奇加偶减 
			s.insert(cir(-1,nw));//插入下圆弧 
		}else{s.erase(cir(1,op[i].u));s.erase(cir(-1,op[i].u));}//大力erase掉即可 
	}printf("%lld",res);return 0;//拜拜程序~ 
}

```

---

## 作者：离散小波变换° (赞：17)

处理不相交圆的扫描线，老早就想学了。今天刚学懂过了板子题，写篇题解。

## 题解

![](https://cdn.luogu.com.cn/upload/image_hosting/noef3mle.png)

注意到这些圆之间不会有交点，那么对于任意两个圆 $A,B$，要么 $A\subseteq B$，要么 $B\subseteq A$，要么它俩没有包含关系。

包含关系是具有传递性的。即如果 $A\subseteq B$，$B\subseteq C$，就有 $A\subseteq C$。我们对于每个圆找到一个大小最小的包含了它的圆，看作「父亲」，那么这 $n$ 个圆就组成了一个森林。

记根节点的深度为 $1$，一个儿子节点的深度是它的父亲节点的深度 $+1$。那么容易发现，这个圆对答案的贡献应该为：

$$r^2\times (-1)^{d_i+1}$$

![](https://cdn.luogu.com.cn/upload/image_hosting/oqm7kx3y.png)

上述内容非常自然，理解起来应该没有太大困难。我们要研究的重点是，对于每个圆，怎么才能找到它的父亲。

---

有一个很巧妙的使用扫描线的方法。对于一个圆心为 $(x, y)$，半径为 $r$ 的圆，使用一条平行于 $x$ 轴且过圆心的直线将其分割成为上半圆弧和下半圆弧（原谅我不会给图片配色……）：

![](https://cdn.luogu.com.cn/upload/image_hosting/1cwfznmd.png)

如果我们做一条垂直于 $x$ 轴的垂线，穿过了若干个圆，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/o5g58k4d.png)

现在研究 $A,B,C$ 这三个圆。

- 这条竖直线穿过了 $B$ 的上半圆弧后，与 $A$ 的上半圆弧相交。这说明，$B$ 的父亲就是 $A$；
- 这条竖直线穿过了 $C$ 的上半圆弧后，与 $B$ 的下半圆弧相交。这说明，$B$ 和 $C$ 应该有相同的父亲。

这两条结论是可以推广到一般情形的。也就是说，做一条竖直线穿过圆 $i$ 的上半圆弧，与上面 $j$ 的圆弧相交后，如果是与 $j$ 的下半圆弧相交，就说明 $i,j$ 的父亲相同；如果是与 $j$ 的上半圆弧相交，就说明 $j$ 是 $i$ 的父亲。

这两条看上去就很正确的结论的正确性可以感性理解。

现在有了这样两条结论后，就可以应用扫描线辅助我们求出一个圆的父亲了。假设有一条 $x=x_0$ 的直线从左往右扫描，

- 当它刚触碰到圆 $i$（也就是触碰到了 $i$ 最左侧的位置），就去查询交点 $(x_i-r_i,y_i)$ 上方最近的一个交点所对应的圆弧，如此可知 $i$ 的父亲/一个兄弟 $j$，而 $j$ 的父亲是谁肯定是先于 $i$ 被处理好的，所以可以求出 $i$ 的父亲。接着我们就可以将 $i$ 的上下两个半圆弧加入某个数据结构来维护；
- 当它扫描完了圆 $i$（也就是触碰到了 $i$ 最右侧的位置），就应该将 $i$ 的上下两个半圆弧移出这个数据结构。

现在我们需要这样一个数据结构，可以维护 $x=x_0$ 与圆弧的交点，并支持查询前驱后继。发现可以使用 $\verb!set!$。在这里应用到了一个性质，对于两个半圆弧 $a,b$，分别与 $x=x_0$ 产生两个交点 $p,q$，$p$ 和 $q$ 在 $y$ 坐标上的大小关系是不会随着 $x_0$ 发生变化的。这是因为圆弧不交，如果大小关系发生变化就一定要出现交点，产生矛盾。

如此叙述仍然有些模糊。这里将结合一些具体代码。

首先定义一个结构体 $\text{Semi}$，用来存储两个圆弧的信息：

```cpp
struct Semi{
	int i, x, y, r; bool t;
};
```

其中，$i$ 表示这个圆弧属于的圆的编号；$x,y,r$ 是这个圆的信息；$t$ 用来存储该圆弧是上半圆弧还是下半圆弧，如果为真则是上半，否则为下半。

接着需要写一个比较函数，用来将圆弧按照交点的 $y$ 坐标排序：

```cpp
struct Cmp{
    bool operator ()(const Semi a, const Semi b) const {
        double u, v;
        if(abs(l - a.x) == a.r) u = a.y; else 
            u = a.y + (a.t ? 1 : -1) * sqrt(pow(a.r, 2) - pow(l - a.x, 2));
        if(abs(l - b.x) == b.r) v = b.y; else 
            v = b.y + (b.t ? 1 : -1) * sqrt(pow(b.r, 2) - pow(l - b.x, 2));
        if(a.t == true) u += 1e-9;
        if(b.t == true) v += 1e-9;
        return u < v;
    }
};
```

这里面 $l$ 是一个全局变量，用来描述扫描线 $x=l$。容易算出这两个圆弧与 $x=l$ 的交点：

$$\begin{aligned}
h_{\text{上半}}&=y+\sqrt{r^2-(l-x)^2}\cr
h_{\text{下半}}&=y-\sqrt{r^2-(l-x)^2}\cr
\end{aligned}$$

圆弧会在扫描线扫过一个圆的时候被移出 $\text{set}$，所以不用担心没有交点的情况。接着比较 $u,v$ 的相对大小，就能对两个圆弧定序。为什么非得要这个 $l$？事实上，圆弧的「高低」是与 $l$ 无关的确定关系，并不会因为乱动 $l$ 导致 $\text{set}$ 里面大小关系错乱产生未定义行为。但是如果不取出一个在定义域内合法的 $l$，就难以比较高低关系。

需要注意的是，$\verb!set!$ 里判定两个数据 $u, v$ 相同，是通过 $\verb!cmp(u, v) == false!$ 且 $\verb!cmp(v, u) == false!$ 来实现的。而由于上半圆弧和下半圆弧在 $l=x-r$ 和 $l=x+r$ 位置相同，所以会被 $\verb!set!$ 错误判断为同一元素而只保留其中一个，因此我们将结果加上一个偏移量 $\epsilon$ 来避免该问题。

另外，调用 $\text{pow}$ 和 $\text{sqrt}$ 函数是比较慢的，所以对于 $l=x-r$ 和 $l=x+r$ 情况特判可以显著减小常数。不过如果开 $\text{O2}$ 的话跑得飞快，完全用不着卡常。

剩下来的主程序部分就相对简单。将每个圆两侧的位置 $(x-r,y)$ 和 $(x+r,y)$ 按照 $x$ 坐标排序，按照前文所述处理办法即可。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
struct Semi{ int i, x, y, r; bool t; };
int l;
struct Cmp{
    bool operator ()(const Semi a, const Semi b) const {
        double u, v;
        if(abs(l - a.x) == a.r) u = a.y; else 
            u = a.y + (a.t ? 1 : -1) * sqrt(pow(a.r, 2) - pow(l - a.x, 2));
        if(abs(l - b.x) == b.r) v = b.y; else 
            v = b.y + (b.t ? 1 : -1) * sqrt(pow(b.r, 2) - pow(l - b.x, 2));
        if(a.t == true) u += 1e-9;
        if(b.t == true) v += 1e-9;
        return u < v;
    }
};
set <Semi, Cmp> S;
const int MAXN = 2e5 + 3;
const int MAXM = 4e5 + 3;
int F[MAXN], D[MAXN];
int X[MAXN], Y[MAXN], R[MAXN], I[MAXM], n, m;
int qread(){
    int w = 1, c, ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
bool cmp(int a, int b){
    int u = a > 0 ? X[a] - R[a] : X[-a] + R[-a];
    int v = b > 0 ? X[b] - R[b] : X[-b] + R[-b];
    return u < v;
}
int main(){
    n = qread();
    up(1, n, i){
        X[i] = qread(), Y[i] = qread(), R[i] = qread();
        I[++ m] =  i;
        I[++ m] = -i;
    }
    sort(I + 1, I + 1 + m, cmp);
    i64 ans = 0;
    up(1, m, i){
        int o = I[i];
        int p = abs(o), x = X[p], y = Y[p], r = R[p];
        l = o > 0 ? x - r : x + r;
        Semi a = {p, x, y, r, 1};
        Semi b = {p, x, y, r, 0};
        if(o > 0){
            auto q = S.lower_bound(a);
            if(q == S.end()) F[p] = 0; else
                F[p] = q -> t ? q -> i : F[q -> i];
            S.insert(a);
            S.insert(b);
            D[p] = D[F[p]] + 1;
            ans += 1ll * R[p] * R[p] * (D[p] % 2 == 1 ? 1 : -1);
        } else {
            S.erase(a), S.erase(b);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：newbie_QwQ (赞：11)

我们充分发扬人类智慧：

将所有点全部绕原点旋转同一个角度，然后将圆形换为四边与坐标轴平行的内接正方形。

根据数学直觉，在随机旋转并转化为正方形后，在随机数据下答案肯定变化不大。

所以我们只需用扫描线来统计这些方形的异或面积并来计算答案。

这样速度快得飞起，在 $n=200000$ 时都可以在 435ms 内卡过。

代码就不放了 ~~，因为人类智慧题解是不屑于放代码的~~。

解法来自同机房大佬 @PLYnotAK。~~话说洛谷的大部分平面几何题是不是都充满了人类智慧（）~~

注：这题后来经过实践发现不绕原点旋转也是对的。~~数据该加强了。~~

---

## 作者：Vanilla_chan (赞：7)

# 洛谷 P3268 [JLOI2016]圆的异或并

## 说在前面

感谢管理员的细心指导。若仍有不足恳请多多斧正。

## 题目描述

在平面上有两两不相交的$n$个圆，即其关系只有相离和包含。求这些圆的异或面积并。

异或面积并为：当一片区域被奇数个圆包含则计算其面积，否则不计算。

输出所有圆的异或面积并除以$\pi$的结果。

$n\le 200000$。

## Solution

前置知识：扫描线，set。

可以发现，由于圆是不相交的，那么这种包含关系可以看作是一棵森林（许多有根树构成的图）。

比如像这个几个圆
![](https://cdn.luogu.com.cn/upload/image_hosting/nyw3lqan.png)
可以变成

![](https://cdn.luogu.com.cn/upload/image_hosting/011d37pn.png)

设每个根的深度为1，那么深度为奇数的节点的面积是需要加上的，深度为偶数的节点的面积是需要减去的。

即
$$
ans=\sum_{i=1}^nr_i^2\times(-1)^{dep_i+1}
$$
同扫描线的思想，我们模拟出有一条垂直于$x$轴的直线从左向右移动。

- 当其与某个圆开始触碰到的时候，就将这个圆拆分为上半圆和下半圆插入set中。这个set是按照圆的高度排序的。由于保证了圆和圆之间不相交，所以可以直接计算扫描线与半圆的交点作为关键字排序。圆和圆之间不相交保证了这个关键字的相对大小一定不会变。

查询刚刚插入的圆的上半圆的前驱（在set中的所有半圆中，在当前圆下方最近的半圆）。如果它的前驱是一个上半圆，那么当前圆的深度等于其前驱的深度；若前驱是一个下半圆，那么说明当前圆被其前驱所包含，深度为前驱的深度+1。

- 遇到圆的右边界就直接将其两个半圆从set中删除即可。

因为set中要插入同一id的两个半圆，那么只要用up表示当前圆是上半圆还是下半圆即可。重载运算符时，可以比较**当前扫描线与半圆的交点**，也可以**以圆心的纵坐标为第一关键字，以上/下半圆为第二关键字**进行比较。

注意，如果是以**扫描线与半圆的交点**进行比较的话，在扫描线进入/离开一个圆的时候，扫描线与两个半圆的交点会重合。需要在比较函数中将上半圆的交点纵坐标加上一个$eps$即可。

## Code

我的排序方法是比较**当前半圆和扫描线的交点**。

```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<map>
#include<set>
#include<queue>
#include<vector>
#include<limits.h>
#define IL inline
#define re register
#define LL long long
#define ULL unsigned long long
#ifdef TH
#define debug printf("Now is %d\n",__LINE__);
#else
#define debug
#endif
using namespace std;

template<class T>inline void read(T&x)
{
	char ch=getchar();
	int fu;
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') fu=-1,ch=getchar();
	x=ch-'0';ch=getchar();
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	x*=fu;
}
inline LL read()
{
	LL x=0,fu=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') fu=-1,ch=getchar();
	x=ch-'0';ch=getchar();
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return x*fu;
}
int G[55];
template<class T>inline void write(T x)
{
	int g=0;
	if(x<0) x=-x,putchar('-');
	do{G[++g]=x%10;x/=10;}while(x);
	for(int i=g;i>=1;--i)putchar('0'+G[i]);putchar('\n');
}
#define N 200010
int n,nowx;
LL X[N],Y[N],R[N];
struct Opt
{
	LL pos;
	int x;
	bool insert;
	Opt(LL a=0,int b=0,bool c=0)
	{
		pos=a,x=b,insert=c;
	}
	IL bool operator<(const Opt& z)const
	{
		return pos<z.pos;
	}
};
vector<Opt>opt;
bool dep[N];
#define eps 1e-6
struct O
{
	int x;
	bool up;
	O(int xx=0,bool u=1)
	{
		x=xx,up=u;
	}
	double calc()const
	{
		if(up) return Y[x]+sqrt(R[x]*R[x]-(X[x]-nowx)*(X[x]-nowx))+eps;
		return Y[x]-sqrt(R[x]*R[x]-(X[x]-nowx)*(X[x]-nowx));
	}
	IL bool operator<(const O& z)const
	{
		return calc()<z.calc();
	}
};
set<O>s;
set<O>::iterator it;
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		X[i]=read();
		Y[i]=read();
		R[i]=read();
		opt.push_back(Opt(X[i]-R[i],i,1));
		opt.push_back(Opt(X[i]+R[i],i,0));
	}
	sort(opt.begin(),opt.end());
	LL ans=0;
	for(int i=0;i<opt.size();i++)
	{
		nowx=opt[i].pos;
		if(opt[i].insert)
		{
			it=s.insert(O(opt[i].x,1)).first;
			if(it==s.begin())
			{
				dep[opt[i].x]=1;
			}
			else
			{
				it--;
				if(it->up)
				{
					dep[opt[i].x]=dep[it->x];
				}
				else
				{
					dep[opt[i].x]=dep[it->x]^1;
				}
			}
			s.insert(O(opt[i].x,0));
			if(dep[opt[i].x]) ans+=R[opt[i].x]*R[opt[i].x];
			else ans-=R[opt[i].x]*R[opt[i].x];
		}
		else
		{
			s.erase(O(opt[i].x,1));
			s.erase(O(opt[i].x,0));
		}
	}
	write(ans);
	return 0;
}
```

## 总结

扫描线是一种重要的思想。在其应用的过程中常常需要用到set，线段树等数据结构进行维护。

---

## 作者：Andycraft (赞：4)

这是个不同于扫描线的做法。首先将圆按半径从大到小排序为 $(c_1, \cdots, c_n)$。于是对每个圆 $c_i$，它只会被编号比 $i$ 小的那些圆包含，设其被 $k_i$ 个圆包含，则它对答案的贡献为 $(-1)^{k_i} \times S(c_i)$，其中 $S(c_i)$ 表示圆 $c_i$ 的面积。

对每个 $i$，我们希望快速地求出 $k_i$。可以发现，若圆 $c_i$ 被若干个圆包含，其中编号最大（即半径最小）的圆为 $c_j$，那么 $k_i = k_j + 1$；若 $c_i$ 不被任何圆包含，则 $k_i = 0$。于是问题转化为求包含 $c_i$ 的最小圆，或判断其是否不被任何圆包含。

我们将所有圆划分成 $\left\lceil\log_2 \max_{1 \le i \le n} r_i\right\rceil$ 类，对所有第 $i$ 类圆 $c_j$，满足 $2^{i - 1} \le 2 \times r_j \lt 2^i$，其中 $r_j$ 表示圆 $c_j$ 的半径。接着对所有 $i$，将第 $i$ 类圆放入一个坐标系，并将此坐标系划分成若干个边长为 $2^i$ 的正方形。对每个正方形，存下所有“圆面与该正方形面有交”$\,^*$的圆。注意到一个正方形内的圆关于包含关系构成一座森林，但每个连通块都是一条链（这正是分类方法的精髓），同时这座森林的连通块个数是 $O(1)$ 的。

于是解法呼之欲出：我们枚举 $i$，再枚举每个类，算出 $c_i$ 的圆心在该类中所在的正方形，并检查该正方形对应森林的每一条链，若链顶（即最大的圆）包含了 $c_i$，我们就在该链上二分出 $c_i$ 的位置，否则直接跳过这条链。总的时间复杂度是 $O(n \times (\log n + \log \max r))$。

类似的一道题：[P4631 [APIO2018] Circle selection 选圆圈](https://www.luogu.com.cn/problem/P4631)

$*$：实际上并不需要判断是否有交：每个正方形直接存圆心在周围的 9 个正方形内的那些圆，是个更方便的选择。

---

## 作者：Leianha (赞：3)

## 扫描线

[博客阅读](https://www.cnblogs.com/wljss/p/12658663.html)

之前做过一到类似的，当时没写题解，今天来补上。

首先我们发现圆没有交，所以两个圆只有包含和相离两种关系。

我们考虑用扫描线来处理，随着扫描线的推移，和上面的圆的交点 一直都在 和下面的圆的交点的上面，可以用 $set$ 来维护相对位置

怎么确定一个圆应该是加还是减？我们将圆拆分成上半圆和下半圆，将上半圆插入 $set$ 后，找在这扫描线上其下面的那个半圆。

$1$ .若找不到，哪这个圆不会被包含，应该加上

$2$ .若是下半圆，则和那个圆的加减状态相反。

$3$ .若是上半圆，则和那个圆的加减状态相同。

上面的过程建议画一下图方便理解
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<set>
#define DB double
using namespace std;
int n, tot, now;
long long ans;
DB nowx;
const int N = 200010;
const DB eps = 1e-9;
int val[N];
DB x[N], y[N], r[N];
struct cir
{
	int opt, id;
	DB nowy()//求圆和当前扫描线交点的y坐标
	{
		return y[id] + (DB)opt * sqrt(r[id] * r[id] - (x[id] - nowx) * (x[id] - nowx) + eps);
	}
	friend bool operator <(cir x, cir y) {return x.nowy() < y.nowy();}
};
set<cir>s;
set<cir>::iterator it;
struct xian
{
	int opt, x, id;
	friend bool operator <(const xian &x, const xian &y) {return x.x < y.x;}
} li[N << 1];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; ++i)
	{
		scanf("%lf%lf%lf", &x[i], &y[i], &r[i]);
		li[++tot] = (xian) {1, (int)(x[i] - r[i]), i};
		li[++tot] = (xian) {0, (int)(x[i] + r[i]), i};
	}
	sort(li + 1, li + 1 + tot);
	for (int i = 1; i <= tot; ++i)
	{
		nowx = li[i].x;
		if (li[i].opt)
		{
			now = li[i].id; it = s.insert((cir) {1, now}).first;
			if (it == s.begin())val[now] = 1;
			else
			{
				--it;
				if ((*it).opt == -1)val[now] = val[(*it).id] ^ 1;
				else val[now] = val[(*it).id];
			}
			s.insert((cir) { -1, now});
			if (val[now])ans += r[now] * r[now];
			else ans -= r[now] * r[now];
		}
		else s.erase((cir) {1, li[i].id}), s.erase((cir) { -1, li[i].id});
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Seauy (赞：2)

提供一个……不同于扫描线的做法。

## 题目大意

- 平面上有 $n$ 个互相包含或分离的圆。

- 计算被奇数个圆覆盖的区域的面积除以 $\pi$。

- $n\in[1,2\times 10^5]$，坐标半径数量级在 $10^8$。

# 一. 分析

由于圆之间要么分离要么包含，那么如果一个圆被奇数个圆包含，就减去他的面积，反之加上他的面积。

还有，如果一个圆包含另外一个圆，那他的半径就比他大。这启发我们设计一种方法，从大到小把圆加入平面中，如果一个圆被加入前圆心被覆盖了奇数次，面积是负的，否则是正的。

考虑用某个数据结构，支持二维圆形区域加，单点查。这可以用 K-D Tree 做，判断圆与矩形是否有交集，完全覆盖区间就打加标记。

不过普通的二叉 K-D Tree 分割区域时会导致左右儿子代表的平面有交集，标记会重复算贡献。解决方法是，把选出的维度与中位数相同的点拿出来再开一个儿子，这样变成了三叉 K-D Tree，建树还是 $O(n \log n)$（当然如果排序的话就是 $O(n \log^2 n)$）。注意结点数开成 $2n$。

判断圆与矩形是否无交集或包含，计算出圆心到矩形某点的最小值即可。

复杂度……不知道，可能就是假的，但是题目的数据经特殊构造，常数十分小。

# 二. 代码

```cpp
#include<bits/stdc++.h>
#define Lson(x) node[x].Son[0]
#define Mson(x) node[x].Son[1]
#define Rson(x) node[x].Son[2]
using namespace std;

typedef long long ll;

const int MAXN=2e5;
const ll MAXV=1e8;

struct Circle
{
	ll x,y,r;
	void Scan() {scanf("%lld %lld %lld",&x,&y,&r);}
}ver[MAXN+5];

struct Point
{
	ll x,y;
	bool operator == (const Point &a) const
	{return x==a.x && y==a.y;}
	void Print() {printf("%d %d\n",x,y);}
}p[MAXN+5];int m;

int n;
ll ans;

bool cmp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}
bool cmpx(Point a,Point b) {return a.x<b.x;}
bool cmpy(Point a,Point b) {return a.y<b.y;}
bool cmpr(Circle a,Circle b) {return a.r>b.r;}

struct KDTree
{
	int Son[3];
	ll L,R,D,U;
	int LT;
	bool IN(ll X,ll Y) {return L<=X && X<=R && D<=Y && Y<=U;}
}node[2*MAXN+5];int tot;

void PushUp(int now)
{
	node[now].L=node[now].D=MAXV;
	node[now].R=node[now].U=-MAXV;
	if(Lson(now))
	{
		node[now].L=min(node[now].L,node[Lson(now)].L);
		node[now].R=max(node[now].R,node[Lson(now)].R);
		node[now].D=min(node[now].D,node[Lson(now)].D);
		node[now].U=max(node[now].U,node[Lson(now)].U);
	}
	if(Mson(now))
	{
		node[now].L=min(node[now].L,node[Mson(now)].L);
		node[now].R=max(node[now].R,node[Mson(now)].R);
		node[now].D=min(node[now].D,node[Mson(now)].D);
		node[now].U=max(node[now].U,node[Mson(now)].U);
	}
	if(Rson(now))
	{
		node[now].L=min(node[now].L,node[Rson(now)].L);
		node[now].R=max(node[now].R,node[Rson(now)].R);
		node[now].D=min(node[now].D,node[Rson(now)].D);
		node[now].U=max(node[now].U,node[Rson(now)].U);
	}
}

double squ(double x) {return x*x;}

int Build(int L,int R)
{
	if(L>R) return 0;
	int mid=(L+R)>>1,now=++tot;
	if(L==R)
	{
		node[now].L=node[now].R=p[L].x;
		node[now].D=node[now].U=p[L].y;
		return now;
	}
	double avex=0,avey=0,evax=0,evay=0;
	for(int i=L;i<=R;i++) avex+=p[i].x,avey+=p[i].y;
	avex/=(R-L+1),avey/=(R-L+1);
	for(int i=L;i<=R;i++) evax+=squ(p[i].x-avex),evay+=squ(p[i].y-avey);
	int Lmid=mid,Rmid=mid;
	if(evax>evay)
	{
		sort(p+L,p+R+1,cmpx);
		while(Lmid>L)
			if(p[Lmid-1].x==p[mid].x) --Lmid;
			else break;
		while(Rmid<R)
			if(p[Rmid+1].x==p[mid].x) ++Rmid;
			else break;
	}
	else
	{
		sort(p+L,p+R+1,cmpy);
		while(Lmid>L)
			if(p[Lmid-1].y==p[mid].y) --Lmid;
			else break;
		while(Rmid<R)
			if(p[Rmid+1].y==p[mid].y) ++Rmid;
			else break;
	}
	
	Lson(now)=Build(L,Lmid-1);
	Mson(now)=Build(Lmid,Rmid);
	Rson(now)=Build(Rmid+1,R);
	PushUp(now);
	return now;
}

ll Dis(ll x,ll y) {return x*x+y*y;}
ll SQU(ll x) {return x*x;}

ll minDis(ll x,ll y,ll L,ll R,ll D,ll U)
{
	if(L<=x && x<=R && D<=y && y<=U) return 0;
	ll d=min(min(Dis(x-L,y-D),Dis(x-L,y-U)),min(Dis(x-R,y-D),Dis(x-R,y-U)));
	if(L<=x && x<=R) d=min(d,min(SQU(y-D),SQU(y-U)));
	if(D<=y && y<=U) d=min(d,min(SQU(x-L),SQU(x-R)));
	return d;
}

ll maxDis(ll x,ll y,ll L,ll R,ll D,ll U)
{return max(max(Dis(x-L,y-D),Dis(x-L,y-U)),max(Dis(x-R,y-D),Dis(x-R,y-U)));}

void Plus(int now,ll x,ll y,ll r,int v)
{
	if(!now) return;
	if(minDis(x,y,node[now].L,node[now].R,node[now].D,node[now].U)>r*r) return;
	if(maxDis(x,y,node[now].L,node[now].R,node[now].D,node[now].U)<=r*r)
		{node[now].LT+=v;return;}
	Plus(Lson(now),x,y,r,v);
	Plus(Mson(now),x,y,r,v);
	Plus(Rson(now),x,y,r,v);
}

int Ask(int now,ll x,ll y)
{
	if(!now) return 0;
	if(!node[now].IN(x,y)) return 0;
	return Ask(Lson(now),x,y)+Ask(Mson(now),x,y)+Ask(Rson(now),x,y)+node[now].LT;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		ver[i].Scan();
		p[i].x=ver[i].x,p[i].y=ver[i].y;
	}
	sort(p+1,p+n+1,cmp);
	m=unique(p+1,p+n+1)-p-1;
	Build(1,m);
	sort(ver+1,ver+n+1,cmpr);
	for(int i=1;i<=n;i++)
	{
		Plus(1,ver[i].x,ver[i].y,ver[i].r,1);
		if(Ask(1,ver[i].x,ver[i].y)&1) ans+=SQU(ver[i].r);
		else ans-=SQU(ver[i].r);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：liaiyang (赞：0)

update 2024.3.26 为了叉掉人类智慧贡献了组 hack。

update 2024.8.20 修改了精度问题，可以过掉新的 hack。

我们将圆切成上半圆和下半圆，用 set 维护，按照 y 值比较。

为了防止上下半圆被认为相等，给上圆加上一个 eps。

把圆的最左最右加入，从左向右扫描线，扫到时寻找当前下半圆的前驱，如果是上半圆就相离，否则包含。

建出一颗圆的森林，按照 dep 求当前圆的面积贡献即可。

时间复杂度 $O(n\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lc now<<1
#define rc now<<1|1
#define y1 Y1
#define min(a,b) (a<b?a:b) 
#define max(a,b) (a>b?a:b)
#define P pair<int,int>
#define x first
#define y second
#define modd(x) (((x)%mod+mod)%mod) 
#define rd read()
#define lowbit(x) ((x)&(-x))
#define abs(x) ((x)<0?-(x):(x))
mt19937 rnd(time(0));
inline int read(int u=0, char c=getchar(), bool f=false){
    for (;!isdigit(c);c=getchar()) f|=c=='-';
    for (;isdigit(c);c=getchar()) u=(u<<1)+(u<<3)+c-'0';
    return f?-u:u;
}
inline void wt(int x){
    if(x<0) x=-x,putchar('-');
    if(x>9) wt(x/10);
    putchar(x%10+48);
}
inline void wt(int x,char k){wt(x),putchar(k);}
const int inf=~0U>>1,linf=~0ULL>>1; 
const int mod=998244353;
const int N=2e5+10;
const double eps=1e-3;
int now,ans;
struct node{
	int x,y,r,pos;
    int id;
    bool flag;
    double check()const{return flag?y+sqrt(r*r-(x-now)*(x-now))+eps:y-sqrt(r*r-(x-now)*(x-now));}
	bool operator<(const node v)const{return check()<v.check();}
}a[N<<1];
set<node>s;
int n,f[N],dep[N];
main(){
	n=rd;
    for(int i=1;i<=n;i++){
        int x=rd,y=rd,r=rd;
        a[i]={x,y,r,x-r,i,1};
        a[i+n]={x,y,r,x+r,i,0};
    }
    sort(a+1,a+2*n+1,[](node x,node y){return x.pos<y.pos;});
    for(int i=1;i<=2*n;i++){
        now=a[i].pos;
        if(a[i].flag){
            s.insert({a[i].x,a[i].y,a[i].r,a[i].pos,a[i].id,0});
            s.insert({a[i].x,a[i].y,a[i].r,a[i].pos,a[i].id,1});
            auto it=s.lower_bound({a[i].x,a[i].y,a[i].r,a[i].pos,a[i].id,0});
            if(it==s.begin()) dep[it->id]=1;
            else{
                it--;
                if(it->flag) dep[a[i].id]=dep[it->id];
                else dep[a[i].id]=dep[it->id]+1;
            }
            ans+=((dep[a[i].id]&1)?1:-1)*a[i].r*a[i].r;
        }
        else{
            s.erase({a[i].x,a[i].y,a[i].r,a[i].pos-2*a[i].r,a[i].id,0});
            s.erase({a[i].x,a[i].y,a[i].r,a[i].pos-2*a[i].r,a[i].id,1});
        }
    }
    wt(ans,'\n');
	return 0;
}
```

---

## 作者：tder (赞：0)

大计几利好难 /kel

机房有大佬发挥人类智慧随机旋转 A 了 /jk

考虑建树（森林），表示圆之间的关系。父亲表示内含，兄弟表示相离但拥有同一父亲。

将每个圆分为上半圆和下半圆两部分，与[扫描线](/problem/P5490)相似，具有函数值大小关系不变的性质。特别的，若一个上半圆的上方距离最近的为上半圆，则显然为其父亲；若其上方距离最近的为下半圆，则为其兄弟。

此处参考扫描线用堆维护即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/dyakxmda.png)

例如，将上图通过上述方式建树后形成的森林应为：

![](https://cdn.luogu.com.cn/upload/image_hosting/ko5u2du8.png)

令一个点的深度为 $d$，则其贡献为 $r^2\times(-1)^{d+1}$，统计答案即可。

---


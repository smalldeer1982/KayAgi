# 改造异或树

## 题目描述

给定一棵n 个点的树，每条边上都有一个权值。现在按顺序删掉所有的n-1条边，每删掉一条边询问当前有多少条路径满足路径上所有边权值异或和为0。


## 说明/提示

对于20% 数据，满足n  <= 1000。

对于另外30% 数据，满足所有的zi = 0。

对于全部数据，满足n <=10^5，0<= zi<= 10^9。


## 样例 #1

### 输入

```
4
1 2 0
2 3 0
2 4 0
3 1 2```

### 输出

```
6
3
1
0```

# 题解

## 作者：rui_er (赞：3)

套路题。

容易想到时光倒流，将删边转化为加边，每次操作即为合并两个连通块。

不妨以 $1$ 为根，设 $\operatorname{val}(u)$ 表示 $u$ 到根路径权值异或和，那么同一连通块内的两个点 $u,v$ 之间路径权值异或和为 $0$，当且仅当 $\operatorname{val}(u)=\operatorname{val}(v)$。

如果我们对每个连通块维护一个桶，那么合并的时候只需要枚举一个桶中的元素，在另一个桶中统计答案，并把两个桶合并即可。枚举哪个桶都行，我们枚举更小的桶，更新完答案再暴力插入更大的桶即可。换句话说就是每个连通块维护 map，并进行启发式合并。

时间复杂度 $\mathcal O(n\log^2n)$。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(ll x=(y);x<=(z);x++)
#define per(x,y,z) for(ll x=(y);x>=(z);x--)
#define debug(format...) fprllf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
ll randll(ll L, ll R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const ll N = 1e5+5;

ll n, U[N], V[N], W[N], p[N], val[N], dsu[N], ans[N];
vector<tuple<ll, ll>> e[N];
map<ll, ll> mp[N];

ll find(ll x) {return x == dsu[x] ? x : dsu[x] = find(dsu[x]);}

void dfs(ll u, ll f) {
    for(auto&& [v, w] : e[u]) {
        if(v != f) {
            val[v] = val[u] ^ w;
            dfs(v, u);
        }
    }
}

int main() {
    scanf("%lld", &n);
    rep(i, 1, n-1) {
        scanf("%lld%lld%lld", &U[i], &V[i], &W[i]);
        e[U[i]].emplace_back(V[i], W[i]);
        e[V[i]].emplace_back(U[i], W[i]);
    }
    rep(i, 1, n-1) scanf("%lld", &p[i]);
    dfs(1, 0);
    rep(i, 1, n) dsu[i] = i;
    rep(i, 1, n) mp[i][val[i]] = 1;
    ll now = 0;
    per(i, n-1, 1) {
        ll u = find(U[p[i]]), v = find(V[p[i]]);
        if((ll)mp[u].size() < (ll)mp[v].size()) swap(u, v);
        for(auto&& [key, cnt] : mp[v]) {
            now += cnt * mp[u][key];
            mp[u][key] += cnt;
        }
        map<ll, ll>().swap(mp[v]);
        dsu[v] = u;
        ans[i] = now;
    }
    rep(i, 1, n) printf("%lld\n", ans[i]);
    return 0;
}
```

---

## 作者：玫葵之蝶 (赞：3)

我来重复一下楼下的思路，顺便贴一个又短又快的代码（滑稽）

30分做法：（边权为0）

我一开始就在想30分做法，然后就想到了：

首先老套路，正着删边就是倒着加边。

并查集维护连通块大小，每次加边后将两个端点的size值乘起来累加答案。

20分做法：

当n<=1000时，利用xor的一个性质：a^x^x=a；

然后就可以选取一个根，一遍dfs，预处理出来每个点到根节点的距离，这样dist[x,y]=s[x]^s[y]；

可以每次修改后暴力查找，然后随便搞搞就好了。

50分做法：

结合做法1和做法2。

100分做法：

给每一个块都建一个平衡树（由于我太蒟蒻了，就不自己手写了，我就用map了，虽然map慢到爆炸，但也可以将就着用吧），在每一次修改的时候用启发式合并，一边合并一边统计答案，就完美解决了。

代码：

```cpp
#include<map>
#include<cstdio>
#define ll long long
using namespace std;
inline int read(){
    int x=0;char ch=' ';
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x;
}
struct edge{
    int to,next,w;
}e[200001];
map<int,int> mp[100001];
map<int,int>::iterator it;
int n,tot,x[100001],y[100001],add[100001],fa[100001],z[100001],head[100001],s[100001];
ll sum[100001],ans;

int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
inline void addedge(int x,int y,int w){e[++tot].to=y;e[tot].next=head[x];e[tot].w=w;head[x]=tot;}
void dfs(int x,int fa){
    for(int i=head[x];i;i=e[i].next){
        int u=e[i].to;
        if(u!=fa){
            s[u]=s[x]^e[i].w;
            dfs(u,x);
        }
    }
}

int main(){
    n=read();
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<n;i++){
        x[i]=read();y[i]=read();z[i]=read();
        addedge(x[i],y[i],z[i]);addedge(y[i],x[i],z[i]);
    }
    for(int i=1;i<n;i++){add[i]=read();}
    dfs(1,0);
    for(int i=1;i<=n;i++)mp[i][s[i]]=1;
    for(int i=n-1;i>=1;i--){
        int u=find(x[add[i]]);int v=find(y[add[i]]);
        if(mp[u].size()>mp[v].size())swap(u,v);
        fa[u]=v;
        for(it=mp[u].begin();it!=mp[u].end();++it){
            ans+=1ll*mp[v][it->first]*it->second;
            mp[v][it->first]+=it->second;
        }
        sum[i]=ans;
    }
    for(int i=1;i<=n;i++)printf("%lld\n",sum[i]);
    return 0;
}
```

---

## 作者：kczno1 (赞：2)

终于过了。

1对于z=0的情况，我们逆序加边，用并查集记录块的大小sz，每次贡献即sz[x]\*sz[y]。

(30分了)

2对于n=1000的情况:

首先，sx,y=0<=>s[x,k]=s[y,k]，其中x,y,k都是任意的。

简单的证明一下：

若k在x,y路径上，这显然成立；

否则s[x,k]与s[y,k]一定有一个重复的部分(应该有三种情况)，

因为x xor x=0,x xor 0=x,所以也成立。(自己画个图就能懂)

所以我们可以任意选一个标准点做根，先dfs出到所有点的s,那么对于任意两点就可以O(1)判断了。

那么我们逆序加边，计算贡献时每次暴力枚举两个块的所有点，判断s[x,root]是否=s[y,root]就行了。

(50分了)

3对于n=10^5:

我们在3的基础上，对每个块建一个平衡树。

计算贡献时，我们选择较小的树x，枚举所有点，logn查找它在y树中的个数，并logn加入y中。

这样最多只有nlogn次操作(显然像归并排序一样时最差,虽然我也不会证明),

时间nlog^2n。

可以自己写splay(我只会splay),也可以用map。(我的splay比map快了3倍)

记得用long long!（我改成long long结果忘了printf时用lld。。）

刚刚看了线段树合并的论文，发现这题先离散化，之后用动态加点线段树来存储，合并，就是nlogn的了(因为论文里说n个树合并这一定不会比插入n次差)。

论文里觉得太显然没有证明复杂度，然而我不能理解，于是自己想了个证明。

先叙述一下合并的过程。

对相同的节点(指都拥有的节点)是加和，之后递归处理左右儿子的，

而对于不同节点，也就是一个树有它另一个树没有它，或者两个树都没有的，我们直接取存在的那一个拿来用，之后exit。

根据这个过程，一次的时间=(两个线段树)相同节点个数+相同节点的不相同儿子的个数。

由于一个相同节点最多有两个儿子，所以时间<=3\*相同节点个数。

由于每一次合并相同节点后的线段树相比较于之前两个线段树，相当于失去了相同节点个数的节点；

而初始总结点数=nlogn，所以线段树失去的节点总数<=nlogn，也就是相同节点总个数<=nlogn。

所以总时间<=nlogn。

(然而比我启发式合并的splay慢，可能是数据问题)


---

## 作者：Crazyouth (赞：1)

## 分析

考虑倒着做，把删边转为加边。不难想到无论任何时候，整个图都是森林，对森林的每一棵树假定根节点，并令 $dist_i$ 表示 $i$ 到自己所在的树的根的距离。每次操作相当于合并两个连通块，此处需要启发式合并。

不妨假设连接的两个点为 $u,v$，边权为 $w$，且 $u$ 所在的树大小更小，假设当前需要操作的节点为 $u$ 树中某个点 $k$，那么它到 $v$ 树根的距离为 $dist_k\oplus dist_u\oplus w\oplus dist_v$，则新增的与之路径异或和为 $0$ 的节点个数便是 $v$ 树中与根的距离也为上式的节点个数，这个可以用 $n$ 个 map 维护。时间复杂度：$O(n \log^2 n)$。

需要注意的是：如果使用 vector 维护每棵树，在合并后需要清空 vector 并释放空间。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int dist[N],bel[N],del[N],fr[N],to[N],wt[N],newdist[N];
long long ans[N];
vector<int> vc[N];
map<int,int> mp[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n,lst;
	long long res=0;
	cin>>n;
	for(int i=1;i<n;i++) cin>>fr[i]>>to[i]>>wt[i];
	for(int i=1;i<n;i++) cin>>del[i];
	for(int i=1;i<=n;i++) bel[i]=i,vc[i].push_back(i),mp[i][0]=1;
	for(int i=n-1;i;i--)
	{
		ans[i]=res;
		int u=fr[del[i]],v=to[del[i]],w=wt[del[i]];
		if(vc[bel[u]].size()>vc[bel[v]].size()) swap(u,v);
		mp[bel[u]].clear();
		for(auto nd:vc[bel[u]])
		{
			newdist[nd]=dist[nd]^dist[u]^w^dist[v];
			res+=mp[bel[v]][newdist[nd]];
		}
		lst=bel[u];
		for(auto nd:vc[bel[u]])
		{
			mp[bel[v]][newdist[nd]]++;
			vc[bel[v]].push_back(nd);
			dist[nd]=newdist[nd];
			bel[nd]=bel[v];
		}
		vc[lst].clear();
		vc[lst].shrink_to_fit();
	}
	cout<<res<<'\n';
	for(int i=1;i<n;i++) cout<<ans[i]<<'\n';
}

---

## 作者：ax_by_c (赞：0)

首先考虑给定树怎么做，记一下树上异或前缀和 $xs$，那么 $u,v$ 之间的路径异或和就是 $xs_u\oplus xs_v$，统计相同对即可。

删边看上去就很烦，考虑时光倒流变成加边。

那么每次就是统计有多少对相同的数分布在两个可重集中，然后合并。

显然启发式合并，时间复杂度 $O(n\log^2n)$。

突然发现 multiset 的 count 是 $O(\log size+cnt)$ 的，所以要用 map。

本题启示我们解题的时候不能太严格。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace ax_by_c{
typedef long long ll;
const int N=1e5+5;
int n,a[N];
struct E{
	int u,v,w;
}e[N];
struct EE{
	int v,w;
};
vector<EE>g[N];
int de[N],xs[N];
void dfs(int u,int fa){
	for(auto e:g[u]){
		if(e.v==fa)continue;
		de[e.v]=de[u]+1;
		xs[e.v]=xs[u]^e.w;
		dfs(e.v,u);
	}
}
ll res,ans[N];
map<int,int>S[N];
int fa[N];
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d %d %d",&e[i].u,&e[i].v,&e[i].w);
		g[e[i].u].push_back({e[i].v,e[i].w});
		g[e[i].v].push_back({e[i].u,e[i].w});
	}
	dfs(1,-1);
	for(int i=1;i<n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)S[i][xs[i]]++,fa[i]=i;
	for(int i=n-1;i>=1;i--){
		e[a[i]].u=find(e[a[i]].u);
		e[a[i]].v=find(e[a[i]].v);
		if(de[e[a[i]].u]>de[e[a[i]].v])swap(e[a[i]].u,e[a[i]].v);
		fa[e[a[i]].v]=e[a[i]].u;
		if(S[e[a[i]].u].size()>S[e[a[i]].v].size()){
			for(auto x:S[e[a[i]].v])res+=(ll)S[e[a[i]].u][x.first]*x.second;
			for(auto x:S[e[a[i]].v])S[e[a[i]].u][x.first]+=x.second;
		}
		else{
			for(auto x:S[e[a[i]].u])res+=(ll)S[e[a[i]].v][x.first]*x.second;
			for(auto x:S[e[a[i]].u])S[e[a[i]].v][x.first]+=x.second;
			swap(S[e[a[i]].u],S[e[a[i]].v]);
		}
		ans[i]=res;
	}
	for(int i=1;i<=n;i++)printf("%lld\n",ans[i]);
}
}
int main(){
	ax_by_c::main();
	return 0;
}
```

---

## 作者：lizicheng3042 (赞：0)

## 题目概述  
给定一棵有边权的树，现在要求你按顺序删边，并求每次删边后有多少条异或和为 $0$ 的路径。  
## 思路分析  
首先，我们知道删边是一个很难实现的操作，而且很复杂，但是只是加边就很简单，所以考虑反向加边建树的离线做法。  
然后，我们考虑，每连一条边，事实上就是两棵树上的点互通有无。所以我们可以考虑在两棵树间找异或和为 $0$ 的路径。  
因此，我们可以每个位置建上一个 ```set```，然后考虑模拟树合并的过程，具体地：在这个过程中，我们要使用**并查集**来维护每棵树的根节点，然后再通过 LCA 来求出两树根节点之间路径的异或和，然后，再分别从两个树的路径集（就是 ```set```）里取出边来配对，再放到一个路径集里。    
此外，由于可能会出现数万节点的树与几个节点的树配对，所以应尽可能将小的路径集合并到大的路径集里，这个技巧也可以叫启发式合并，可以大大降低时间复杂度，最后让复杂度趋于 $O(n\log^2 n)$。  
但，其他大佬使用了更加先进的结论，代码非常简洁，可以先看他们的，如果觉得不理解（其实还是很好理解的）可以再来看这篇，但是这种方法多用了 LCA，复杂度高一点。  
```cpp
#include<cstdio>
#include<algorithm>
#include<set>
#include<vector>
using namespace std;
typedef long long ll;
int n,fir[200005],nxt[200005],to[200005],val[200005],tot,ci[100005],f[100005],t[100005],ne[100005],fa[100005][18],fax[100005][18];
set<pair<int,int> >s[100005];
int siz[100005],dep[100005],faa[100005];
ll ans[200005];
int find(int x)
{
	return faa[x]=faa[x]==x?x:find(faa[x]);
}
void add(int x,int y,int z)
{
	nxt[++tot]=fir[x];to[fir[x]=tot]=y;val[tot]=z;
	nxt[++tot]=fir[y];to[fir[y]=tot]=x;val[tot]=z;	
}
void dfs(int u)
{
	for(int a=1;a<=17;a++)
	{
		fa[u][a]=fa[fa[u][a-1]][a-1];
		fax[u][a]=fax[fa[u][a-1]][a-1]^fax[u][a-1];
	}
	for(int a=fir[u];a;a=nxt[a])
	{
		int v=to[a];
		if(v==fa[u][0])
			continue;
		fa[v][0]=u;
		dep[v]=dep[u]+1;
		fax[v][0]=val[a];
		dfs(v);
	}
}
int lca_xor(int x,int y)//注：因为没有考虑到到根节点异或和相同即可。
{//所以此处求了两点之间的异或和。
	int ret=0;
	if(dep[y]>dep[x])
		swap(x,y);
	int l=dep[x]-dep[y];
	for(int a=17;a>=0;a--)
	{
		if(l&(1<<a))
		{
			ret^=fax[x][a];
			x=fa[x][a];
		}
	}
	if(x==y)
		return ret;
	for(int a=17;a>=0;a--)
	{
		if(fa[x][a]!=fa[y][a])
		{
			ret^=fax[x][a];
			x=fa[x][a];
			ret^=fax[y][a];
			y=fa[y][a];			
		}
	}	
	return ret^fax[x][0]^fax[y][0];
}
int main()
{
	scanf("%d",&n);
	for(int a=1;a<n;a++)
	{
		scanf("%d%d%d",&f[a],&t[a],&ci[a]);
		add(f[a],t[a],ci[a]);
		siz[a]=1;
	}
	siz[n]=1;
	dep[1]=1;
	for(int a=1;a<n;a++)
		scanf("%d",&ne[n-a]);
	dfs(1);
	pair<int,int>d;
	d.first=0;d.second=1;
	for(int a=1;a<=n;a++)
	{
		s[a].insert(d);
		faa[a]=a;
	}
	pair<int,int>kl,kj,tc;
	for(int a=1;a<n;a++)
	{
		int fx=find(f[ne[a]]),fy=find(t[ne[a]]);
		if(s[fx].size()<s[fy].size())
			swap(fx,fy);
		faa[fy]=fx;
		siz[fx]+=siz[fy];
		int u=lca_xor(fx,fy);
		tc.first=tc.second=0;
		while(s[fy].size())
		{
			auto ka=s[fy].lower_bound(tc);
			kl.first=ka->first;
			kl.second=ka->second;
			tc=kl;
			if(ka->second==0)
				break;
			s[fy].erase(kl);
			kl.first^=u;
			auto kb=s[fx].lower_bound(make_pair(kl.first,0));
			kj.first=kb->first;
			kj.second=kb->second;
			if(kl.first!=kj.first)
				s[fx].insert(kl);
			else
			{
				ans[n-a]+=kj.second*kl.second;
				s[fx].erase(kj);
				kj.second+=kl.second;
				s[fx].insert(kj);
			}
		}
		ans[n-a]+=ans[n-a+1];
	}
	for(int a=1;a<=n;a++)
	{
		printf("%lld\n",ans[a]);
	}
	return 0;
}
```

---

## 作者：Gold_Dino (赞：0)

考虑转化路径异或为 $0$，设 $d_i$ 为节点 $i$ 到根路径的异或和，那么一条路径 $(u,v)$ 异或和为 $0$ 等价于 $d_u=d_v$

问题转化为求每个联通分量中点权相同的二元组隔个数

删边不好处理，考虑反过来，即倒着枚举加边

合并两个联通分量时，新增的贡献为两个联通分量每种点权数量乘积

每个联通分量维护一个桶，启发式合并，时间复杂度 $\Theta(n\log^2n)$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long lint;
const int N = 100011;
int n; vector<pair<int, lint>> e[N];
struct Edge {
    int u, v;
} arr[N], tmp[N];
lint ans[N];
int f[N]; map<int, lint> mp[N]; lint d[N];
void dfs(int u, int f) {
    for(auto x : e[u])
        if(x.first != f) {
            d[x.first] = d[u] ^ x.second;
            dfs(x.first, u);
        }
}
int find(int u) {return f[u] == u ? u : f[u] = find(f[u]);}
int main() {
    int i;
    scanf("%d", &n);
    for(i = 1; i < n; ++i) {
        int u, v; lint w;
        scanf("%d%d%lld", &u, &v, &w);
        tmp[i] = {u, v};
        e[u].emplace_back(make_pair(v, w));
        e[v].emplace_back(make_pair(u, w));
    }
    for(i = 1; i <= n; ++i) {
        int x;
        scanf("%d", &x);
        arr[i] = tmp[x];
    }
    lint cnt = 0;
    dfs(1, 0);
    for(i = 1; i <= n; ++i) {
        f[i] = i;
        mp[i][d[i]] = 1;
    }
    for(i = n - 1; i >= 1; --i) {
        int u = arr[i].u, v = arr[i].v;
        u = find(u);
        v = find(v);
        if(mp[u].size() > mp[v].size()) swap(u, v);
        for(auto [key, val] : mp[u]) {
            cnt += val * mp[v][key];
            mp[v][key] += val;
        }
        f[u] = v;
        ans[i - 1] = cnt;
    }
    for(i = 0; i < n; ++i) printf("%lld\n", ans[i]);
    return 0;
}
```


---


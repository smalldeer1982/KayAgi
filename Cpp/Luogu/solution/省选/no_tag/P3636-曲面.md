# 曲面

## 题目背景

xht喜欢研究数学函数，他特别喜欢反比例函数。


## 题目描述

我们知道，反比例函数xy=a的图象是双曲线。



 ![](https://cdn.luogu.com.cn/upload/pic/4375.png) 

xht于是想：把它推广到三维是什么样的呢？


定义曲面C(k)为**方程xyz=k所确定的曲面**。


又定义曲面的美观程度P(k)为曲面C(k)上所有**整点**（x,y,z坐标均为整数）到原点的曼哈顿距离的**平方**之和。


（点（x,y,z）到原点的曼哈顿距离为|x|+|y|+|z|）。

现在，xht把一些曲面{C(a),C(a+1)...C(b)}排成一列，你要求出它们美观程度之**和**对10007取模的结果。


## 说明/提示

样例1的解释：


在曲面xyz=3上共有12个整点(1,1,3),(1,3,1),(3,1,1),(-1-1,3),(-1,-3,1),(-3,-1,1),(1,-1,-3),(1,-3,-1),(3,-1,-1),(-1,1,-3),(-1,3,-1),(-3,1,-1)。它们到原点的曼哈顿距离的平方之和为5^2\*12=300。


对于20%的数据，a=b<=100

对于另外40%的数据，a,b<=3\*10^5

对于100%的数据，1<=a,b<=3\*10^8


## 样例 #1

### 输入

```
3 3```

### 输出

```
300```

## 样例 #2

### 输入

```
64 19260817```

### 输出

```
9932```

# 题解

## 作者：lemondinosaur (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3636)

---
首先将 $\sum_{i=a}^b C(i)$ 转换成 $\sum_{i=1}^b C(i)-\sum_{i=1}^{a-1} C(i)$，

那么题目就转换成求 $\sum_{1\leq xyz\leq n} (|x|+|y|+|z|)^2$。

三个数相乘是正数当且仅当两负一正或者全是正数，一共四种情况。

再将平方拆开可以化简成

$$
4 \sum_{xyz\leq n} x^2+y^2+z^2+2(xy+xz+yz)
$$

考虑三个平方项是等价的，$xy,xz,yz$ 也是等价的，所以就是

$$
(12 \sum_{xyz\leq n} x^2)+(24 \sum_{xyz\leq n} xy)
$$

对于左边这一部分考虑枚举 $x$，就可以转换成 $\sum_{x=1}^n x^2f(\lfloor\frac{n}{x}\rfloor)$。

其中 $f(n)=\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor$，这两个式子都可以整除分块实现。

对于右边这一部分考虑枚举 $z$，就可以转换成 
$\sum_{z=1}^n g(\lfloor\frac{n}{z}\rfloor)$。

$$
g(n)=\sum_{i=1}^n i\frac{(\lfloor\frac{n}{i}\rfloor+1)\times (\lfloor\frac{n}{i}\rfloor)}{2}
$$

同样也可以用整除分块实现。

---
代码
```cpp
#include <cstdio>
using namespace std;
const int mod=10007;
const int i4=(mod+1)>>2;
const int i6=(mod+1)/6;
int l,r;
int mo(int x,int y){return x<y?x-y+mod:x-y;}
void Mo(int &x,int y){x=x+y>=mod?x+y-mod:x+y;}
int sf(int n){
	int _n=n%mod;
    return 1ll*i6*_n*(_n+1)*(_n<<1|1)%mod;
}
//1^2+2^2+...+n^2=n*(n+1)*(2n+1)/6

int query0(int n){//f(n)
	int ans=0;
	for (int l=1,r;l<=n;l=r+1)
		r=n/(n/l),Mo(ans,(r-l+1ll)*(n/l)%mod);
	return ans;
}
int query1(int n){//g(n)
	int ans=0;
	for (int l=1,r;l<=n;l=r+1)
	    r=n/(n/l),Mo(ans,i4*(1ll*(l+r)%mod*(r-l+1)%mod)*(1ll*(n/l)*(n/l+1)%mod)%mod);
	return ans;
}
int query(int n){
	int ans=0;
	for (int l=1,r;l<=n;l=r+1){
		r=n/(n/l),Mo(ans,12*mo(sf(r),sf(l-1))%mod*query0(n/l)%mod);//左边这一部分 
		Mo(ans,24*(r-l+1ll)%mod*query1(n/l)%mod);//右边这一部分
	}
	return ans;
}
int main(){
	scanf("%d%d",&l,&r);
	printf("%d",mo(query(r),query(l-1)));
	return 0;
}
```

---

## 作者：decoqwq (赞：2)

题意：给定 $a,b$，求 $\sum\limits_{i}\sum\limits_{j}\sum\limits_{k} [a \leq ijk \leq b] (i+j+k)^2$


因为 $1\leq a,b$ ，故 $ijk>0$，则当这三个数都大于 $0$ 或者任意两个小于 $0$ 时满足条件，只需要算出均大于 $0$ 的情况再乘 $4$ 即可

考虑原式可以转化为 $\sum\limits_{i}\sum\limits_{j}\sum\limits_{k} [ijk \leq b] (i+j+k)^2-\sum\limits_{i}\sum\limits_{j}\sum\limits_{k} [ijk \leq a-1] (i+j+k)^2$，故只需要快速计算 $\sum\limits_{i}\sum\limits_{j}\sum\limits_{k} [ijk \leq x] (i+j+k)^2$ 

拆开后面的式子为 $i^2+j^2+k^2+2(ij+jk+ki)$，考虑对原式整除分块，对于一段连续的 $i$ ，$jk$ 的范围是固定的，将式子化为 $i^2+2i(j+k)+(j+k)^2$，在对 $i$ 整除分块时只需要计算 $\sum\limits_{j}\sum\limits_{k} (j+k)$ 和 $\sum\limits_{j}\sum\limits_{k} (j+k)^2$ 即可，可以再对 $j$ 进行整除分块时计算

```cpp
#pragma GCC optimize("-Ofast")
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll a,b,cnt,ma1,ma2;
const int mod=10007;
ll sum1(ll x,ll y)//x+(x+1)+...+y
{
	x%=mod,y%=mod;
	if(x>y)
	{
		y+=mod;
	}
	return (y-x+1)*(x+y)*5004%mod;
}
ll sum2(ll x,ll y)//x^2+(x+1)^2+...+y^2
{
	x--;
	x%=mod,y%=mod;
	if(x>y)
	{
		y+=mod;
	}
	return (y*(y+1)*(2*y+1)-x*(x+1)*(2*x+1))*1668%mod;
}
inline void work2(ll x)//对 j 整除分块
{
	for(register ll i=1,r;i<=x;i=r+1)
	{
		r=(x/(x/i)),cnt+=(x/i)*(r-i+1);//i^2 的出现次数
		ll qwq1=(r-i+1)%mod,qwq2=(x/i)%mod;
		ll qaq1=sum1(1,x/i),qaq2=sum1(i,r);
		ll quq1=sum2(1,x/i),quq2=sum2(i,r);
		ma1=(ma1+qwq1*qaq1+qwq2*qaq2)%mod;//j+k
		ma2=(ma2+qwq1*quq1+qwq2*quq2+2*qaq2*qaq1)%mod;//(j+k)^2
	}
}
inline ll work1(ll x)//对 i 整除分块
{
	ll ans=0;
	for(register ll i=1,r;i<=x;i=r+1)
	{
		cnt=ma1=ma2=0;
		r=(x/(x/i)),work2(x/i),cnt%=mod;
		ans=(ans+sum2(i,r)*cnt+ma1*2*sum1(i,r)+ma2*(r-i+1))%mod;
	}
	return ans;
}
signed main()
{
	cin>>a>>b;
	cout<<(work1(b)-work1(a-1)+mod)*4%mod;
}
```

---

## 作者：X____ (赞：0)

## 题目描述

求在三维坐标系中所有满足 $a\le x\times y\times z \le b$ 的点 $(x,y,z)$ 到原点的曼哈顿距离的平方和。

数据范围：$1\le a,b\le 3\times 10^8$。


## 解题

为了方便我们将 $x,y,z$ 三个数均限制在正整数范围内，三个数乘积为正有两负一正和全正共 $\binom{3}{2} + 1 = 4$ 种情况，所以最终答案乘 $4$ 即可。


容易想到将询问进行差分，所以我们考虑求 $\sum_{i=1}^{n}\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\sum_{k=1}^{\left\lfloor\frac{n}{i\times j}\right\rfloor}(i+j+k)^2$ 即可。

$ \begin{aligned}\sum_{i=1}^{n}\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\sum_{k=1}^{\left\lfloor\frac{n}{i\times j}\right\rfloor}(i+j+k)^2 &=\sum_{i=1}^{n}\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\sum_{k=1}^{\left\lfloor\frac{n}{i\times j}\right\rfloor}i^2 + (j+k)^2 + 2ij + 2ik \\&= \sum_{i=1}^n(i^2\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\left\lfloor\frac{n}{i\times j}\right\rfloor + 2i\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\sum_{k=1}^{\left\lfloor\frac{n}{i\times j}\right\rfloor}(j+k)+\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\sum_{k=1}^{\left\lfloor\frac{n}{i\times j}\right\rfloor}(j+k)^2)\end{aligned}$

容易发现 $\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\left\lfloor\frac{n}{i\times j}\right\rfloor,\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\sum_{k=1}^{\left\lfloor\frac{n}{i\times j}\right\rfloor}(j+k),\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\sum_{k=1}^{\left\lfloor\frac{n}{i\times j}\right\rfloor}$ 这三部分用数论分块都是好维护的。

所以我们数论分块套数论分块维护即可。

由于时间限制，应尽量减少取模次数。

code:
```cpp
#include<iostream>
#include<cstdio>
#define ll long long

using namespace std;
const ll mo = 10007;
ll inv2, inv6;
struct node{
	ll ans1, ans2, ans3;
};
ll Pow(ll a, ll b) {
	ll res = 1;
	for(; b; b>>=1) {
		if(b&1) res = res * a % mo;
		a = a * a % mo;
	}
	return res;
}
inline ll funa(ll l, ll r) {
	return (l+r) * (r-l+1) %mo * inv2 %mo;
}
inline ll ready(ll x) {
	return x * (x+1) % mo * (2*x+1) % mo * inv6 % mo;
}
inline ll funb(ll l, ll r) {
	return ((ready(r) - ready(l-1)) % mo + mo)% mo;
}
node work2(ll n) {
	ll ans1 = 0, ans2 = 0, ans3 = 0;
	for(ll l = 1, r, d; l <= n; l = r+1) {
		d = n/l;
		r = n/d;
		ans1 = (ans1 + (r-l+1) * d ) % mo;
		ans2 = (ans2 + funa(l, r) * d + (r-l+1) * funa(1, d)) % mo;
		ans3 = (ans3 + funb(l, r) * d + (r-l+1) * funb(1, d) + 2 * funa(l, r) * funa(1, d)) % mo;
	}
	node u;
	u.ans1 = ans1;
	u.ans2 = ans2;
	u.ans3 = ans3;
	return u;
}
ll work(ll n) {
	ll ans = 0;
	for(ll l = 1, r, d; l <= n; l = r+1) {
		d = n/l;
		r = n/d;
		node u = work2(d);
		ll ans1 = u.ans1, ans2 = u.ans2, ans3 = u.ans3;
		ans = (ans + funb(l, r)*ans1 + funa(l, r)*2ll*ans2 + (r-l+1)*ans3) % mo;
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	ll a, b;
	cin >> a >> b;
	inv2 = Pow(2, mo-2);
	inv6 = Pow(6, mo-2);
	cout << (work(b) - work(a-1) + mo) * 4ll%mo;
	return 0;
}

```

---


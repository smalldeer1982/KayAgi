# 方程组

## 题目背景

从小学开始，我们就一直做各种各样的应用题，其中大多数的题目都可以抽象为解方程组。

为了提高效率，省下时间~~打隔膜~~学习OI，xht 准备开发一个自动解题器。其中的一个核心组件就是解方程组的程序，xht 决定将这个任务交给你。

## 题目描述

一开始，xht 有 $N$ 个变量，记为 $x_1,x_2,\cdots,x_n$。另有一个常数 $K$，以及 $M$ 个方程，每个方程都形如 $x_a-x_b≡c\pmod K$。

由于题目可能会变化，xht 需要不时增加一个新的方程，或者删掉一个方程。

同时，xht 会给你一些这样的询问：令变量 $x_a=c$，求另一个变量 $x_b \bmod K$ 的值。当然，有的时候会因为条件不足，无法解出 $x_b$，那么就输出 $-1$。

数据保证任意时刻两个变量之间最多存在一个方程。保证不会出现自相矛盾的方程组，也不会出现多余的条件（某个方程可以通过其他一些方程推出来）。

## 说明/提示

样例的解释：

一开始有两条方程：$x_1-x_2=1$，$x_2-x_3=2$。

第一次询问，令$x_1=0$，解得$x_3=(-3)\bmod100=97$。

第二次询问时，删掉了第二条方程，导致条件不足，无法解出 $x_3$，输出 $-1$。

对于 $40\%$ 的数据，只有询问操作。

对于 $100\%$ 的数据，$1\le M<N\le10^5$，$1\le Q\le10^5$，$2\le K\le10^3$，$1\le a,b\le N$，$0\le c<K$。

保证所有的 $a\ne b$。

## 样例 #1

### 输入

```
3 2 100 3
1 2 1
2 3 2
3 1 3 0
2 1 2
3 1 3 0```

### 输出

```
97
-1```

# 题解

## 作者：Aron_2023 (赞：4)

## 前置知识
前置知识：LCT

LCT（Link-Cut Tree）是一种高效的数据结构，用于解决动态树问题，即在树形结构上进行动态的连接（Link）和切割（Cut）操作。LCT 是由 Robert Tarjan 在 1989 年提出的，它结合了二叉搜索树（BST）和树的动态连接操作的特点，使得在树上进行路径相关查询和更新操作的时间复杂度可以达到近线性时间。

接着，我们来学习 LCT 该如何实现以及它的效果，比如下面这道题：

维护一棵树，支持如下操作：

修改两点间路径权值。

查询两点间路径权值和。

修改某点子树权值。

查询某点子树权值和。

断开并连接一些边，保证仍是一棵树。

这道题就可以使用 LCT 求解。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
const int INF = 1e9;

struct Node {
    int parent, size;
    long long weight;
    Node *left, *right;
    Node() : parent(-1), size(1), weight(0), left(nullptr), right(nullptr) {}
};

Node* T[MAXN];
int cnt;

void init() {
    for (int i = 0; i < MAXN; ++i) T[i] = nullptr;
    cnt = 0;
}

Node* new_node(int p = -1, long long w = 0) {
    T[cnt] = new Node();
    T[cnt]->parent = p;
    T[cnt]->weight = w;
    return T[cnt++];
}

void splay(Node* x) {
    while (x->parent != -1) {
        Node* y = T[x->parent];
        if (y->parent == -1) {
            if (y->right == x) swap(x, y->right);
            else swap(x, y->left);
        } else {
            Node* z = T[y->parent];
            if (z->left == y) {
                if (y->left == x) {
                    swap(x, y->left);
                    swap(y, x->right);
                } else if (y->right == x) {
                    swap(x, y->right);
                    swap(y, x->left);
                }
            } else {
                if (y->left == x) {
                    swap(x, y->left);
                    swap(y, x->right);
                } else if (y->right == x) {
                    swap(x, y->right);
                    swap(y, x->left);
                }
            }
        }
    }
}

void access(Node* x) {
    while (x != nullptr) {
        splay(x);
        x->left = nullptr;
        x->right = (x->parent != -1) ? T[x->parent] : nullptr;
        x = T[x->parent];
    }
}

void makeroot(Node* x) {
    access(x);
    splay(x);
    swap(x, x->right);
}

void link(Node* x, Node* y) {
    makeroot(x);
    access(y);
    splay(y);
    x->parent = y->parent = -1;
    x->right = y;
}

void cut(Node* x, Node* y) {
    makeroot(y);
    access(x);
    splay(x);
    x->parent = -1;
}

int main() {
    init();
    Node* root = new_node();
    // 假设我们有节点 1 和 2，并且想要将它们连接起来
    Node* node1 = new_node(root, 10);
    Node* node2 = new_node(root, 20);
    link(node1, node2);
    // 进行其他操作...
    return 0;
}
```
上面的代码展示的是 LCT 的基本操作的一部分，读者可以自己去网络上搜索有关于 LCT 算法的其他内容。

## 分析
本题就是对边操作的 LCT，把边化成点，然后操作。

这道题目从 $a$ 到 $b$ 和从 $b$ 到 $a$ 是不一样的，所以在反转的时候要将权值乘 $-1$ 。

## AC Code
只放核心代码：

```cpp
struct node
{
	int rev,w,sum;
	node *f,*ch[2];
}nd[maxn],*s[maxn];
int getwh(node *x)
{if(!x->f) return -1;if(x->f->ch[0]==x)return 0;if(x->f->ch[1]==x)return 1;return -1;}
bool isroot(node *x){return getwh(x)==-1;}
void join(node *x, node *y, int wh){if(x)x->f=y;if(y)y->ch[wh]=x;}
void rev(node *x){if(x)x->rev^=1;}
void pushdown(node *x)
{
	if(!x)return;
	if(x->rev)
	{
		x->w=-x->w;x->sum=-x->sum;swap(x->ch[0],x->ch[1]);
		rev(x->ch[0]),rev(x->ch[1]);
		x->rev=0;
	}
}
void pushup(node *x)
{
	pushdown(x->ch[0]);
	pushdown(x->ch[1]);
	x->sum=x->w;
	if(x->ch[0])x->sum+=x->ch[0]->sum;
	if(x->ch[1])x->sum+=x->ch[1]->sum;
}
void rotate(node *x)
{
	node *y=x->f,*z=y->f;
	int c=getwh(x);
	if(isroot(y))x->f=y->f;
	else join(x,z,getwh(y));
	join(x->ch[!c],y,c),join(y,x,!c);
	pushup(y);
	pushup(x);
}
void splay(node *x)
{
	node *y; int top=0;
	for(y=x;!isroot(y);y=y->f)s[++top]=y;s[++top]=y;
	for(;top;top--)pushdown(s[top]);
	while(!isroot(x))
	{
		y=x->f;
		if(isroot(y)){rotate(x);return;}
		if(getwh(x)^getwh(y))rotate(x);else rotate(y);
		rotate(x);
	}
}
void access(node *x)
{
	node *t=0;
	while(x)
	{
		splay(x);
		x->ch[1]=t;
		pushup(x);
		t=x,x=x->f;
	}
}
void makeroot(node *x) {access(x);splay(x);rev(x);}
void link(node *x,node *y) {makeroot(x);x->f=y;}
void cut(node *x,node *y)
{
	makeroot(x);access(y);splay(y);
	if(y->ch[0]==x and !x->ch[1])x->f=y->ch[0]=0;
}
node* findroot(node *x)
{
	while(x->f)x=x->f;
	return x;
}
```

---

## 作者：TBSF_0207 (赞：1)

# LCT

这里我们使用 LCT 解决本题。

如果你没有学习过这种数据结构，建议完成[P3690 【模板】动态树（LCT）](https://www.luogu.com.cn/problem/P3690)进行学习。

## 我们应该维护什么

本题的思路可以说是 LCT 维护边权的模板题，添加一个方程 $x_a-x_b\equiv c\pmod K$ 相当于添加一条 $b\rightarrow a$ 的有向边，边权为 $c$，然后再添加一条 $a\rightarrow b$ 的有向边，边权为 $-c$，删除同理。查询一个 $x_b \bmod K$ 就相当于查询 $a\rightarrow b$ 的有向路径上的边权和加上 $x_a$ 的值。

## 我们应该怎么维护

你说得对，但是 LCT 这一数据结构是用于维护点权的，怎么将其转化为边权呢？

我们采用的方法是**化边为点**，即对于每个边转化为一个向它的两个端点连边的点，并把边权放在这个点上。

这就基本完成了模型的构造，剩下就是一些细节了。

需要注意的是：

- 由于模型的特殊性，reverse 操作时需要将节点的 sum 和 val 都变成原来的相反数。
- 注意一些操作的特判。如在操作 2 是否能删除的地方需要细致分类讨论，分讨过程附上了详细的注释。

## Code

奉上数组版 LCT。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,m,k,q;
struct Node{int ch[2],fa,sum,val,tg;}t[N];
#define lc t[x].ch[0]
#define rc t[x].ch[1]
bool isRoot(int x){
	int g=t[x].fa;
	return t[g].ch[0]!=x&&t[g].ch[1]!=x;
}
void pushup(int x){
	t[x].sum=t[x].val+t[lc].sum+t[rc].sum;
}
void reverse(int x){
	if(!x)return ;
	swap(lc,rc);
	t[x].val=-t[x].val;
	t[x].sum=-t[x].sum;
	t[x].tg^=1;
}
void pushdown(int x){
	if(t[x].tg){
		reverse(lc);
		reverse(rc);
		t[x].tg=0;
	}
}
void push(int x){
	if(!isRoot(x))push(t[x].fa);
	pushdown(x);
}
void rotate(int x){
	int y=t[x].fa;
	int z=t[y].fa;
	bool k=(t[y].ch[1]==x);
	if(!isRoot(y))t[z].ch[t[z].ch[1]==y]=x;
	t[x].fa=z;
	t[y].ch[k]=t[x].ch[k^1];
	if(t[x].ch[k^1])t[t[x].ch[k^1]].fa=y;
	t[y].fa=x;
	t[x].ch[k^1]=y;
	pushup(y);
}
void splay(int x){
	int y,z;
	push(x);
	while(!isRoot(x)){
		y=t[x].fa,z=t[y].fa;
		if(!isRoot(y))
			(t[z].ch[0]==y)^(t[y].ch[0]==x)?rotate(x):rotate(y);
		rotate(x);
	}
	pushup(x);
}
void access(int x){
	for(int child=0;x;child=x,x=t[x].fa){
		splay(x);
		rc=child;
		pushup(x);
	}
}
void makeroot(int x){
	access(x);
	splay(x);
	reverse(x);
}
void split(int x,int y){
	makeroot(x);
	access(y);
	splay(y);
}
void link(int x,int y){
	makeroot(x);
	t[x].fa=y;
}
int findroot(int x){
	access(x);splay(x);
	while(lc)pushdown(x),x=lc;
	return x;
}
#undef lc
#undef rc
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>k>>q;
	for(int i=1;i<=m;i++){
		int a,b,c;
		cin>>a>>b>>c;
		int mid=n+i;
		t[mid].val=t[mid].sum=c;
		link(mid,a);
		link(b,mid);
	}
	for(int i=1;i<=q;i++){
		int opt,a,b,c;
		cin>>opt>>a>>b;
		if(opt==1){
			cin>>c;
			int mid=n+m+i;
			t[mid].val=t[mid].sum=c;
			link(mid,a);
			link(b,mid);
		}
		else if(opt==2){
			makeroot(a);
			access(b);
			splay(b);
			if(t[b].ch[0]==a){
				if(t[a].ch[0])continue;
				if(!t[a].ch[1])continue;
				if(t[t[a].ch[1]].ch[0])continue;
				if(t[t[a].ch[1]].ch[1])continue;
				t[a].fa=0;
				t[b].ch[0]=0;
				t[t[a].ch[1]].val=t[t[a].ch[1]].sum=0;
				t[a].ch[1]=0;
				pushup(b);pushup(a);
				/*
				这里 makeroot(a), access(b), splay(b) 以后
				如果 a,b 通过一个中间节点 c 连接，那么其
				形态必定是 b 有且仅有一个左儿子 a
				a 有且仅有一个右儿子 且该右儿子没有子孙
				这里的特判就是判断了这些东西 
				如果与该形态不同，要么就是两点不直接相连
				要么就是不联通 
				*/
			}
		}
		else {
			cin>>c;
			if(findroot(a)!=findroot(b)){
				cout<<'-'<<'1'<<'\n';
				continue;
			}
			split(a,b);
			cout<<((t[b].sum+c)%k+k)%k<<'\n';
		}
	}
	return 0;
}
```

---


# [HAOI2017] 方案数

## 题目描述

考虑定义非负整数间的“$ \subseteq $”，如果 $ a \subseteq b $，那么 $ a \land b = a $，其中 $ \land $ 表示二进制下的“与”操作。


考虑现在有一个无限大的空间，现在你在 $ (0, 0, 0) $，有三种位移操作。


一、$(x,y,z)\to(x',y,z)$ if $x\subseteq x'$  
二、$(x,y,z)\to(x,y',z)$ if $y\subseteq y'$  
三、$(x,y,z)\to(x,y,z')$ if $z\subseteq z'$  

由于来自东方的神秘力量，有些点被屏蔽了，也就是不能经过了。现在问你到某个点 $ (n, m, r) $ 的方案数，答案对 $ 998244353 $ 取模。


## 说明/提示

【样例解释】

有8种状态（0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1),分别方案数为 1,1,1,2,1,2,2,6。

【数据规模和约定】

对于 $ 20\% $ 的数据，满足：$ n, m, r \le 100 $


对于 $ 50\% $ 的数据，满足：$ n, m, r \le 10^6 $


对于另外 $ 20\% $ 的数据，满足：$ o \le 10 $


对于 $ 100\% $ 的数据，满足：$ n, m, r \le 10^{18}, o \le 10^4 $


## 样例 #1

### 输入

```
1 1 1
0```

### 输出

```
6```

# 题解

## 作者：complexor (赞：9)

直接考虑不经过 $n$ 个点的方案难度较大，所以考虑进行容斥。

根据题意，一个点可到达的其他点是把原来点坐标二进制表示下某些 $0$ 变为 $1$ 得到的。记 $x$ 二进制表示下 $1$ 的个数为 $count(x)$ ，$dp[i][j][k]$ 为从 $(0,0,0)$ 到满足 $count(x)=i,count(y)=j,count(z)=k$ 的点 $P(x,y,z)$ 的方案数。由于每一步只能改变一维坐标，所以可以得到转移方程 
$$
dp[i][j][k]=\sum_{x=0}^{i-1}dp[x][j][k]\times \dbinom{i}{x}+\sum_{y=0}^{j-1}dp[i][y][k]\times \dbinom{j}{y}+\sum_{z=0}^{k-1}dp[i][j][z]\times \dbinom{k}{z}
$$
再考虑障碍点。

记第 $i$ 个障碍为 $P_i(x_i,y_i,z_i)$ ，$f[i]$ 为不经过其他障碍到达第 $i$ 个障碍的方案数。首先将障碍按字典序排序，则可以保证无后效性。从 $dp[count(x_i)][count(y_i)][count(z_i)]$ 得到 $f[i]$，则依次枚举从 $(0,0,0)$ 到 $P_i$ 的过程中经过的第一个其他障碍 $P_j(j<i)$ 若从 $P_j$ 到 $P_i$ 的方案数为 $to(j, i)$ ，则可得 $f[i]$ 转移方程
$$
f[i]=dp[count(x_i)][count(y_i)][count(z_i)]-\sum_{j=1}^{i-1}f[j]\times to(j,i)
$$

最后只剩下求 $to(j,i)$ 了。事实上，$dp[i][j][k]$ 仅与下标变化有关，即从起点到任一可到达，且 $x,y,z$ 坐标比起点的坐标在二进制表示下分别多$i,j,k$个 $1$ 的点的方案数。所以若从 $P_i$ 可以到达 $P_i$（即 $x_j\land x_i=x_j$，$y_j\land y_i=y_j$，且$z_j\land z_i=z_j$），则有
$$
to(j, i)=dp[count(x_i)-count(x_j)][count(y_i)-count(y_j)][count(z_i)-count(z_j)]
$$
否则 $to(j,i)=0$

为了方便得到答案，可以将终点$(n,m,r)$当做第 $o+1$ 个障碍，则答案为 $f[o+1]$
```cpp
#include <bits/stdc++.h>
typedef long long LL;
int read()
{
	int s = 0, f = 1;
	char ch = getchar();
	while (!(ch >= '0' && ch <= '9'))
	{
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		s = (s << 3) + (s << 1) + (ch ^ 48);
		ch = getchar();
	}
	return s * f;
}
LL readll()
{
	LL s = 0, f = 1;
	char ch = getchar();
	while (!(ch >= '0' && ch <= '9'))
	{
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		s = (s << 3) + (s << 1) + (ch ^ 48);
		ch = getchar();
	}
	return s * f;
}
struct Block
{
	LL x, y, z;
	int xx, yy, zz;
} ;
LL n, m, r;
int o;
Block a[10005];
const int MOD = 998244353;
LL dp[70][70][70] = {{{0}}}, f[10005];
LL c[70][70] = {{0}};
LL comb(int n, int m)
{
	if (c[n][m])
		return c[n][m];
	if (n == m || m == 0)
		return c[n][m] = 1;
	return c[n][m] = (comb(n - 1, m - 1) + comb(n - 1, m)) % MOD;
}
int count(LL x)
{
	int cnt = 0;
	for (; x; x -= x & -x) 
		cnt++;
	return cnt;
}
inline bool chk(int i, int j)
{
	return ((a[i].x & a[j].x) == a[i].x)
		&& ((a[i].y & a[j].y) == a[i].y)
		&& ((a[i].z & a[j].z) == a[i].z);
}
int main()
{
	n = readll(), m = readll(), r = readll(), o = read();
	for (int i = 1; i <= o; i++)
		a[i].x = readll(), a[i].y = readll(), a[i].z = readll();
	dp[0][0][0] = 1;
	for (int i = 0; i <= 64; i++)
		for (int j = 0; j <= 64; j++)
			for (int k = 0; k <= 64; k++)
			{
				for (int ii = 0; ii < i; ii++)
					dp[i][j][k] = (dp[i][j][k] + dp[ii][j][k] * comb(i, i - ii) % MOD) % MOD;
				for (int jj = 0; jj < j; jj++)
					dp[i][j][k] = (dp[i][j][k] + dp[i][jj][k] * comb(j, j - jj) % MOD) % MOD;
				for (int kk = 0; kk < k; kk++)
					dp[i][j][k] = (dp[i][j][k] + dp[i][j][kk] * comb(k, k - kk) % MOD) % MOD;
			}
	std::sort(a + 1, a + o + 1, [](Block p, Block q){
		return (p.x != q.x) ? (p.x < q.x) : (p.y != q.y ? p.y < q.y : p.z < q.z);
	}); 
	a[++o].x = n, a[o].y = m, a[o].z = r;
	for (int i = 1; i <= o; i++)
		a[i].xx = count(a[i].x), a[i].yy = count(a[i].y), a[i].zz = count(a[i].z);
	for (int i = 1; i <= o; i++)
	{
		f[i] = dp[a[i].xx][a[i].yy][a[i].zz];
		for (int j = 1; j < i; j++)
			if (chk(j, i))
				f[i] = ((f[i] - dp[a[i].xx - a[j].xx][a[i].yy - a[j].yy][a[i].zz - a[j].zz] * f[j] % MOD) % MOD + MOD) % MOD;
	}
	printf("%lld\n", f[o]);
	return 0;
} 
```
~~这题真的能评黑吗~~

---

## 作者：ywy_c_asm (赞：7)

我们套路的考虑没有障碍该怎么做，你发现由于是从$(0,0,0)$开始的所以状态只与$a,b,c$分别有几个1有关，那么设$dp[i][j][k]$为他们分别的位数为这么多时的方案数，那么有：

$dp[i][j][k]=\sum_{x=1}^idp[i-x][j][k]C_{i}^x+\sum_{x=1}^jdp[i][j-x][k]C_{j}^x+\sum_{x=1}^kdp[i][j][k-x]C_{k}^x$

然后有障碍的话，我们先把坐标按字典序排序，这样保证可能会在之前会被经过的点一定在之前，设$f[i]$为到点i的方案数，初始为不考虑障碍的方案数，然后枚举$(x,y,z)$都是$(a,b,c)$的子集的前面的障碍点，钦定他是经过的第一个障碍，那么减去$f[j]$乘上$j->i$的不考虑障碍的方案即可，后者对这3个坐标做个差集就能算了，这个是$O(o^2)$的反正能过……

上代码~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
#define p 998244353
using namespace std;
namespace ywy {
	ll c[101][101], dp[65][65][65];
	int bit[65537];
	inline int bitof(ll n) {
	    return (bit[n & 65535] + bit[(n >> 16) & 65535] + bit[(n >> 32) & 65535] + bit[(n >> 48) & 65535]);
	}
	typedef struct _n {
	    ll a, b, c;
	    friend bool operator<(const _n &a, const _n &b) {
	        if (a.a != b.a)
	            return (a.a < b.a);
	        if (a.b != b.b)
	            return (a.b < b.b);
	        return (a.c < b.c);
	    }
	} node;
	node memchi[11111];
	ll f[11111];
	void ywymain() {
	    ll x, y, z;
	    cin >> x >> y >> z;
	    int n;
	    cin >> n;
	    for (register int i = 1; i <= n; i++) cin >> memchi[i].a >> memchi[i].b >> memchi[i].c;
	    n++;
	    memchi[n].a = x;
	    memchi[n].b = y;
	    memchi[n].c = z;
	    sort(memchi + 1, memchi + 1 + n);
	    c[0][0] = 1;
	    for (register int i = 1; i <= 64; i++) {
	        c[i][0] = 1;
	        for (register int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % p;
	    }
	    for (register int i = 1; i < 65536; i++) bit[i] = bit[i - (i & -i)] + 1;
	    dp[0][0][0] = 1;
	    for (register int i = 0; i <= 64; i++) {
	        for (register int j = 0; j <= 64; j++) {
	            for (register int k = 0; k <= 64; k++) {
	                if (!i && !j && !k)
	                    continue;
	                if (i) {
	                    for (register int a = 1; a <= i; a++)
	                        dp[i][j][k] = (dp[i][j][k] + dp[i - a][j][k] * c[i][a]) % p;
	                }
	                if (j) {
	                    for (register int b = 1; b <= j; b++)
	                        dp[i][j][k] = (dp[i][j][k] + dp[i][j - b][k] * c[j][b]) % p;
	                }
	                if (k) {
	                    for (register int z = 1; z <= k; z++)
	                        dp[i][j][k] = (dp[i][j][k] + dp[i][j][k - z] * c[k][z]) % p;
	                }
	            }
	        }
	    }
	    for (register int i = 1; i <= n; i++) {
	        f[i] = dp[bitof(memchi[i].a)][bitof(memchi[i].b)][bitof(memchi[i].c)];
	        for (register int j = 1; j < i; j++) {
	            if ((memchi[j].a & memchi[i].a) != memchi[j].a)
	                continue;
	            if ((memchi[j].b & memchi[i].b) != memchi[j].b)
	                continue;
	            if ((memchi[j].c & memchi[i].c) != memchi[j].c)
	                continue;
	            f[i] -= f[j] * dp[bitof(memchi[i].a ^ memchi[j].a)][bitof(memchi[i].b ^ memchi[j].b)]
	                             [bitof(memchi[i].c ^ memchi[j].c)];
	            f[i] %= p;
	            f[i] += p;
	            f[i] %= p;
	        }
	    }
	    cout << f[n] << endl;
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：lhm_ (赞：5)

可以先考虑没有障碍物的情况，设计状态$f_{i,j,k}$，表示到达坐标 $(x,y,z)$二进制下，$x$有$i$位，$y$有$j$位，$z$有$k$位的方案数。

得转移方程为：

$$
	f_{i,j,k}=\sum_{x=1}^i f_{i-x,j,k}\binom{i}{x}+\sum_{x=1}^j f_{i,j-x,k}\binom{j}{x}+\sum_{x=1}^k f_{i,j,k-x}\binom{k}{x}
$$

对所有障碍物的位置和最终的终点一起考虑，先将这些点按$x$为第一关键字，$y$为第二关键字，$z$为第三关键字排序，保证后面转移的合法。

设$g_i$为到达第$i$个点且不经过排序后顺序该点之前的点的方案数。对于$g_i$，计算时通过容斥，为从$(0,0,0)$到该点不考虑障碍物的方案数，减去其他可以到达该点的点走过来的方案数，判断是否可以到达需看是否三维都是该点子集。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 20010
#define maxm 70
#define all 65
#define mod 998244353
#define lowbit(x) (x&(-x))
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,m,r,tot;
ll f[maxm][maxm][maxm],g[maxn],C[maxm][maxm];
int get(ll x)
{
    int cnt=0;
    while(x) cnt++,x-=lowbit(x);
    return cnt;
}
struct node
{
    ll x,y,z;
    int a,b,c;
    void init()
    {
        a=get(x),b=get(y),c=get(z);
    }
}p[maxn];
bool cmp(const node &a,const node &b)
{
    if(a.x==b.x&&a.y==b.y) return a.z<b.z;
    if(a.x==b.x) return a.y<b.y;
    return a.x<b.x;
}
int main()
{
    read(n),read(m),read(r),read(tot);
    for(int i=1;i<=tot;++i)
        read(p[i].x),read(p[i].y),read(p[i].z),p[i].init();
    p[++tot]=(node){n,m,r},p[tot].init(),sort(p+1,p+tot+1,cmp);
    for(int i=0;i<=all;++i) C[i][0]=1;
    for(int i=1;i<=all;++i)
        for(int j=1;j<=i;++j)
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
    f[0][0][0]=1;
    for(int i=0;i<=all;++i)
    {
        for(int j=0;j<=all;++j)
        {
            for(int k=0;k<=all;++k)
            {
                for(int x=1;x<=i;++x) f[i][j][k]=(f[i][j][k]+f[i-x][j][k]*C[i][x]%mod)%mod;
                for(int x=1;x<=j;++x) f[i][j][k]=(f[i][j][k]+f[i][j-x][k]*C[j][x]%mod)%mod;
                for(int x=1;x<=k;++x) f[i][j][k]=(f[i][j][k]+f[i][j][k-x]*C[k][x]%mod)%mod;
            }
        }
    }
    for(int i=1;i<=tot;++i)
    {
        g[i]=f[p[i].a][p[i].b][p[i].c];
        for(int j=1;j<i;++j)
        {
            if((p[j].x&p[i].x)!=p[j].x||(p[j].y&p[i].y)!=p[j].y||(p[j].z&p[i].z)!=p[j].z) continue;
            g[i]=(g[i]-g[j]*f[p[i].a-p[j].a][p[i].b-p[j].b][p[i].c-p[j].c]%mod+mod)%mod;
        }
    }
    printf("%lld",g[tot]);
    return 0;
}
```

---

## 作者：ahtfd3101 (赞：2)

### 没有障碍的情况：
由于每一步都可以任选若干步转移，所以只要 $\operatorname{popcount(x)},\operatorname{popcount(y)},\operatorname{popcount(z)}$ 均相等，两个点就是等价的（方案数相同）。因此答案仅与 $n,m,r$ 的 $\operatorname{popcount}$ 有关。\
以下令 $(i,j,k)$ 表示满足 $(\operatorname{popcount(x)},\operatorname{popcount(y)},\operatorname{popcount(z)})=(i,j,k)$ 的点。\
显然我们不应该走到不满足 $x\subseteq n$ 或 $y\subseteq m$ 或 $z\subseteq r$ 的点，可以默认 $n,m,r$ 中为 $0$  的二进制位不存在。\
存在一个 DP：$f_{i,j,k}$ 表示从 $(0,0,0)$ 到 $(i,j,k)$ 的方案数。\
转移可以从每一位走，有 $f_{i,j,k}=\sum\limits_{x=0}^{i-1}f_{x,j,k}\times\binom{i}{x}+ \sum\limits_{y=0}^{j-1}f_{i,y,k}\times\binom{j}{y}+ \sum\limits_{z=0}^{k-1}f_{i,j,z}\times\binom{k}{z}$。
### 障碍互不可达的情况：
容斥，答案为总方案数减去经过其中某个点的方案数。\
注意 $f_{i,j,k}$ 也可以走若干步使得三个维度的 $\operatorname{popcount}$ 分别增加了 $i,j,k$ 的方案数。\
因此经过障碍 $(x,y,z)$ 的方案数就是 $f_{x,y,z}\times f_{n-x,m-y,r-z}$。
### 正解：
此时记录 $g_i$ 表示走到第 $i$ 个障碍的方案数，对于所有被这个障碍偏序（在三个维度上被包含）的位置，都可以走到此障碍产生贡献。\
设障碍 $i$ 位于 $(x,y,z)$，障碍 $j$ 位于 $(x',y',z')$，于是有一个转移：$g_i=f_{x,y,z}-\sum\limits_{x\ge x'\operatorname{and}y\ge y'\operatorname{and}z\ge z'} g_j\times f_{x-x',y-y',z-z'}$（此时 $j$ 及以前的所有障碍都未经过，$j$ 被经过，因此不会重复计算）。\
将障碍排序即可实现转移。\
时间复杂度 $O(\operatorname{log}^3n+o^2)$，能过。
### Code：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define pb emplace_back
#define R read()
#define out(x,y) ((y|x)!=x)
using namespace std;
inline ll read(){
	ll x=0;char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x;
}
const ll INF=0x3f3f3f3f,N=70,K=10005,M=998244353;
struct point{
	ll x,y,z;
	int cx,cy,cz;
	friend bool operator== (point a,point b){
		return a.x==b.x&&a.y==b.y&&a.z==b.z;
	}
	friend bool operator< (point a,point b){
		if(a.x!=b.x) return a.x<b.x;
		if(a.y!=b.y) return a.y<b.y;
		return a.z<b.z;
	}
}p[K];
ll sx,sy,sz,k,cnt=1,qx,qy,qz;
ll f[N][N][N],g[K],fc[N],iv[N];
int count(ll x){
	int res=0;
	while(x) res++,x^=x&-x;
	return res;
}
ll C(int x,int y){ return fc[x]*iv[y]%M*iv[x-y]%M; }
ll power(ll x,int y){
	ll res=1;
	while(y){
		if(y&1) res*=x,res%=M;
		x*=x,x%=M,y>>=1;
	}
	return res;
}
int main(){
	p[1]={sx=R,sy=R,sz=R},k=R,fc[0]=1;
	for(int i=1;i<N;i++) fc[i]=fc[i-1]*i%M;
	iv[N-1]=power(fc[N-1],M-2);
	for(int i=N-2;~i;i--) iv[i]=iv[i+1]*(i+1)%M;
	f[0][0][0]=1;
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			for(int k=0;k<N;k++){
				if(!(i|j|k)) continue;
				ll ss=0;
				for(int x=0;x<i;x++)
					ss+=f[x][j][k]*C(i,x),ss%=M;
				for(int y=0;y<j;y++)
					ss+=f[i][y][k]*C(j,y),ss%=M;
				for(int z=0;z<k;z++)
					ss+=f[i][j][z]*C(k,z),ss%=M;
				f[i][j][k]=ss;
			}
		}
	}
	for(int i=1;i<=k;i++){
		qx=R,qy=R,qz=R;
		if(out(sx,qx)||out(sy,qy)||out(sz,qz)) continue;
		p[++cnt]={qx,qy,qz};
	}
	sort(p+1,p+cnt+1);
	for(int i=1;i<=cnt;i++){
		p[i].cx=count(p[i].x);
		p[i].cy=count(p[i].y);
		p[i].cz=count(p[i].z);
	}
	for(int i=1;i<=cnt;i++){
		g[i]=f[p[i].cx][p[i].cy][p[i].cz];
		for(int j=1;j<i;j++){
			if(out(p[i].x,p[j].x)||out(p[i].y,p[j].y)||out(p[i].z,p[j].z)) continue;
			g[i]+=M-g[j]*f[p[i].cx-p[j].cx][p[i].cy-p[j].cy][p[i].cz-p[j].cz]%M;
		}
		g[i]%=M;
	}
	printf("%lld\n",g[cnt]);
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：1)

## 题意
考虑定义非负整数间的“$ \subseteq $”，如果 $ a \subseteq b $，那么 $ a \land b = a $，其中 $ \land $ 表示二进制下的“与”操作。


考虑现在有一个无限大的空间，现在你在 $ (0, 0, 0) $，有三种位移操作。


一、$(x,y,z)\to(x',y,z)$ if $x\subseteq x'$  
二、$(x,y,z)\to(x,y',z)$ if $y\subseteq y'$  
三、$(x,y,z)\to(x,y,z')$ if $z\subseteq z'$  

由于来自东方的神秘力量，有些点被屏蔽了，也就是不能经过了。现在问你到某个点 $ (n, m, r) $ 的方案数，答案对 $ 998244353 $ 取模。


## 题解


还有点反套路的题。

首先先拼部分分！我会 $o=0$！

因为是高维空间，容易想到方案数似乎只和 $x,y,z$ 的位数有关。

设计 $f_{i,j,k}$ 表示 $x,y,z$ 的位数分别是 $i,j,k$ 的方案数。转移的时候选择一维转移：

$$
f_{i,j,k}=\sum_{x=1}^i f_{i-x,j,k}\binom{i}{x}+\sum_{x=1}^j f_{i,j-x,k}\binom{j}{x}+\sum_{x=1}^k f_{i,j,k-x}\binom{k}{x}
$$

这是容易的。

然后考虑正解！我会[经典 dp 蓝题](https://www.luogu.com.cn/problem/AT_dp_y)！

类比这题，设计 $g_i$ 为到达第 $i$ 个障碍点前没有经过障碍的方案数。

$$
g_i=[0\to i]-\sum_{j \to i} g_j[j\to i]
$$

其中 $[\to]$ 的写法表示从一个点到另一个点不限制的方案数，看得懂就行。这个东西都可以用之前算的东西写出来。

这里还是啰嗦一下这个容斥柿子的意义。考虑减去有限制的路径怎么算：

每一个点碰到一些点有几种方法，但是这些方法都有一个第一次经过的点 $j$，后面无论怎么走都是后面的事情，所以 $0 \to j$ 不能碰到点，$j\to i$ 就可以乱走了。

说的够多了，放代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const long long mod=998244353;
struct node{
	long long x,y,z;
}p[10007];
bool cmp(node a,node b){
	if(a.x!=b.x) return a.x<b.x;
	if(a.y!=b.y) return a.y<b.y;
	return a.z<b.z;
}
long long a,b,c;
long long n;
int co[65][65];
long long f[65][65][65];
long long g[10007];
int cc[5000007];
int pc(long long x){
	int cnt=0;
	while(x){
		x=x^(x&-x);
		cnt=cnt+1;
	}
	return cnt;
}
signed main(){
	scanf("%lld%lld%lld",&a,&b,&c);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld",&p[i].x,&p[i].y,&p[i].z);
	}
	p[++n]=(node){a,b,c};
	sort(p+1,p+n+1,cmp);
	for(int i=0;i<64;i++){
		co[i][0]=1;
		for(int j=1;j<=i;j++){
			co[i][j]=(co[i-1][j]+co[i-1][j-1])%mod;
		}
	}
	f[0][0][0]=1;
	for(int i=0;i<64;i++){
		for(int j=0;j<64;j++){
			for(int k=0;k<64;k++){
				for(int x=1;x<=i;x++) f[i][j][k]=(f[i][j][k]+f[i-x][j][k]*co[i][x])%mod;
				for(int x=1;x<=j;x++) f[i][j][k]=(f[i][j][k]+f[i][j-x][k]*co[j][x])%mod;
				for(int x=1;x<=k;x++) f[i][j][k]=(f[i][j][k]+f[i][j][k-x]*co[k][x])%mod;
			}
		}
	}
	for(int i=1;i<=n;i++){
		g[i]=f[pc(p[i].x)][pc(p[i].y)][pc(p[i].z)];
		for(int j=1;j<i;j++){
            if((p[j].x&p[i].x)!=p[j].x||(p[j].y&p[i].y)!=p[j].y||(p[j].z&p[i].z)!=p[j].z) continue;
            g[i]=(g[i]+mod-g[j]*f[pc(p[j].x^p[i].x)][pc(p[j].y^p[i].y)][pc(p[j].z^p[i].z)]%mod)%mod;
		}
	}
	printf("%lld\n",g[n]);
	return 0;
}
```

---

## 作者：CaoXian (赞：1)

教练布置下来当容斥单元小测的，磕了两个小时终于磕出来了，纪念一下。

其实题目应该说明一下每次操作后坐标不能与原坐标相同。

---

首先不考虑障碍物的限制，如何求出从 $(0, 0, 0)$ 走到 $(x, y, z)$ 的方案数？

我们很容易想出一个非常暴力的dp：$dp_{i, j, k}$ 表示坐标为 $(i, j, k)$ 时从 $(0, 0, 0)$ 走到当前位置的方案数，直接枚举当前位置的上一个可能的位置来转移。

但是这样的时间复杂度太大了。

观察题目条件，假设我们某一步是把 $x$ 更改为 $x'$，因为 $x \land x' = x$，所以二进制下 $x'$ 的 $1$ 的数量一定是大于 $x$ 的，这启发我们用**二进制下** $1$ **的个数**来作为dp的状态。

重新定义 $dp_{i, j, k}$ 表示满足 $\operatorname{popcount}(x) = i, \operatorname{popcount}(y) = j, \operatorname{popcount}(z) = k$ 的坐标 $(x, y, z)$ 的方案数，其中 $\operatorname{popcount}(x)$ 表示二进制下 $x$ 含有的数字 $1$ 的个数。

因为每次转移中，有且仅有某一维的状态改变，并且是增大，所以只需要考虑这一个增加量有多少种可能即可。

假设这一增加量为 $l$，从 $dp_{i - l, j, k}$ 转移到 $dp_{i, j, k}$，那么这一增加量 $l$ 相当于是在 $i$ 个二进制位中选取 $l$ 个二进制位，可能的数量为 $\binom{i}{l}$。

如果要再说细一点，就是因为每一个二进制位相互之间有差异，但是任意两个二进制位被选取的先后对答案没有影响，所以是用组合数计算而不是排列数或者直接认为是 $1$。

状态转移方程就可以写出来了：

$$
dp_{i, j, k} = \sum\limits_{l = 1}^{i}\binom{i}{l}dp_{i - l, j, k} + \sum\limits_{l = 1}^{j}\binom{j}{l}dp_{i, j - l, k} + \sum\limits_{l = 1}^{k}\binom{k}{l}dp_{i, j, k - l}
$$

边界值：$dp_{0, 0, 0} = 1$。

为什么这样子dp过后坐标为 $(x, y, z)$ 的方案数就是 $dp_{\operatorname{popcount}(x), \operatorname{popcount}(y), \operatorname{popcount}(z)}$ 了呢，不会多统计到其它的路径吗？

不会，因为我们在dp的过程中是对当前状态的二进制下有 $1$ 的每一位考虑的，换言之，我们是每次若干位地填充这个状态的，并且不会多填。

接下来考虑有障碍的情况该怎么做。

（如果做过“两双手”这道题的同学应该能直接看出来出来这是dp+容斥。）

首先要把那些 $x \land n \not = x$ 或 $y \land m \not = y$ 或 $z \land r \not = z$ 的坐标排除掉，因为从这个坐标不可能走到终点。

根据上面的结论：每次移动二进制下 $1$ 的个数只增不减，我们可以按照 $x, y , z$ 的二进制下 $1$ 的个数为优先级将这些坐标排序，这样影响某个位置的方案的只可能是数组中在它前面的元素。

我们发现如果要计算**恰好**所有的障碍点都不经过的方案会很麻烦，考虑将**恰好**这一要求转化一下。

我们可以统计**最后一步走完后停留在某个障碍点并且之前没有经过其它障碍点**的方案数，相当于把**恰好**不经过所有的障碍点转化为了不经过**前面若干个**障碍点，这也是容斥的精髓。

于是令 $f_{i}$ 表示停留在第 $i$ 个障碍点并且不经过第 $1 \sim i - 1$ 个障碍点的方案数，可以得到：

（下面将 $\operatorname{popcount}(x)$ 简写为 $\operatorname{cnt}(x)$）

$$
f_{i} = dp_{\operatorname{cnt}(x_{i}), \operatorname{cnt}(y_{i}), \operatorname{cnt}(z_{i})} - \sum\limits_{j = 1}^{i - 1}f_{j}dp_{\operatorname{cnt}(x_{i} \oplus x_{j}), \operatorname{cnt}(y_{i} \oplus y_{j}), \operatorname{cnt}(z_{i} \oplus z_{j})}
$$

上面的 $\oplus$ 表示按位异或。

注意这里枚举的第 $j$ 个障碍点必须满足其能够到达第 $i$ 个障碍点，也就是 $x_{j} \land x_{i} = x_{j}, y_{j} \land y_{i} = y_{j}, z_{j} \land z_{i} = z_{j}$，这一段式子太长了就没写在上面。

解释一下上面的式子：不考虑前面是否经过别的障碍点的方案数是 $dp_{\operatorname{cnt}(x_{i}), \operatorname{cnt}(y_{i}), \operatorname{cnt}(z_{i})}$，然后需要减去经过了障碍点的方案数，于是枚举经过的第一个障碍点 $j$，而第 $j$ 个障碍点到第 $i$ 个障碍点的路径方案数为 $dp_{\operatorname{cnt}(x_{i} \oplus x_{j}), \operatorname{cnt}(y_{i} \oplus y_{j}), \operatorname{cnt}(z_{i} \oplus z_{j})}$，因为二进制下已经为 $1$ 的点不用再考虑了，所以要考虑的是坐标按位异或后的值，也就是二进制下相异的位数。

为什么可以只用考虑前面的障碍点而不考虑后面的？注意到我们是按照 $\operatorname{popcount}(x), \operatorname{popcount}(y), \operatorname{popcount}(z)$ 为优先级排序了的，在一个障碍点后面的点不可能影响到这个障碍点。

如何计算最后的答案？其实只需要把 $(n, m, r)$ 也当作一个障碍点丢进数组里就好了。

要注意 `__builtin_popcount` 传参传的是 `unsigned int`，要用 `__builtin_popcountll`！我被这个坑了。

附一份丑陋的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 998244353;
ll n, m, r, o, x, y, z, cnt, fct[10005], inv[10005], dp[10005], f[64][64][64];
ll popcount(ll x) {
	ll ret = 0;
	while(x) ++ret, x ^= (x & (-x));
	return ret;
}
struct cube {
	ll x, y, z, wx, wy, wz, w;
	cube(ll X = 0, ll Y = 0, ll Z = 0): x(X), y(Y), z(Z) {
		wx = popcount(X);
		wy = popcount(Y);
		wz = popcount(Z);
		w = wx + wy + wz;
	}
	cube operator = (const cube& _) {
		x = _.x, y = _.y, z = _.z;
		wx = _.wx, wy = _.wy, wz = _.wz;
		w = _.w;
		return *this;
	}
	bool operator < (const cube& _) const {
		if(wx != _.wx) return wx < _.wx;
		if(wy != _.wy) return wy < _.wy;
		if(wz != _.wz) return wz < _.wz;
		return false;
	}
} c[10005];
ll ksm(ll x, ll y) {
	ll ret = 1;
	while(y) {
		if(y & 1) ret = ret * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ret;
}
ll C(ll n, ll m) {
	return fct[n] * inv[m] % mod * inv[n - m] % mod;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	fct[0] = 1;
	for(int i = 1; i <= 10000; ++i) fct[i] = fct[i - 1] * i % mod;
	inv[10000] = ksm(fct[10000], mod - 2);
	for(int i = 10000; i >= 1; --i) inv[i - 1] = inv[i] * i % mod;
	cin >> n >> m >> r >> o;
	while(o--) {
		cin >> x >> y >> z;
		if((n & x) == x && (m & y) == y && (r & z) == z) {
			c[++cnt] = cube(x, y, z);
		}
	}
	c[++cnt] = cube(n, m, r);
	stable_sort(c + 1, c + 1 + cnt);
	f[0][0][0] = 1;
	for(int i = 0; i <= 63; ++i) {
		for(int j = 0; j <= 63; ++j) {
			for(int k = 0; k <= 63; ++k) {
				for(int l = 1; l <= i || l <= j || l <= k; ++l) {
					if(i >= l) f[i][j][k] = (f[i][j][k] + C(i, l) * f[i - l][j][k] % mod) % mod;
					if(j >= l) f[i][j][k] = (f[i][j][k] + C(j, l) * f[i][j - l][k] % mod) % mod;
					if(k >= l) f[i][j][k] = (f[i][j][k] + C(k, l) * f[i][j][k - l] % mod) % mod;
				}
			}
		}
	}
	for(int i = 1; i <= cnt; ++i) {
		// cerr << i << ":\n";
		for(int k = 1; k < i; ++k) {
			if((c[i].x & c[k].x) == c[k].x && (c[i].y & c[k].y) == c[k].y && (c[i].z & c[k].z) == c[k].z) {
				// cerr << k << " ";
				dp[i] = (dp[i] - dp[k] * f[c[i].wx - c[k].wx][c[i].wy - c[k].wy][c[i].wz - c[k].wz] % mod + mod) % mod;
			}
		}
		dp[i] = (dp[i] + f[c[i].wx][c[i].wy][c[i].wz] % mod) % mod;
		// cerr << "\n> " << dp[i] << '\n';
	}
	cout << dp[cnt];
	return 0;
}
```

---

## 作者：ran_qwq (赞：1)

设 $dp_{i,j,k}$ 为走到 $(i,j,k)$ 的方案数。则 $dp_{i,j,k}=\sum\limits_{x\subseteq i}dp_{x,j,k}+\sum\limits_{x\subseteq j}dp_{i,x,k}+\sum\limits_{x\subseteq k}dp_{i,j,x}$。时间复杂度巨大，完全过不了。

---
$o=0$。

所有位本质上是相同的，换句话说 $dp_{i,j,k}$ 只和 $\operatorname{popcount}(i),\operatorname{popcount}(j)$ 和 $\operatorname{popcount}(k)$ 有关。所以转换一下状态，定义 $dp_{i,j,k}$ 为走到 $\operatorname{popcount}(x)=i,\operatorname{popcount}(y)=j,\operatorname{popcount}(z)=k$ 的点的方案数。

相当于有三个维度，每次选择一个维度往前走任意格。对于第一维，容易想到枚举之前的 $\operatorname{popcount}$ 为 $p$，因为之前可以是任意 $p$ 位，相当于 $i$ 位中选 $p$ 位，所以系数为 $\dbinom ip$。第二、三维同理。

所以 $dp_{i,j,k}=\sum\limits_{p=0}^{i-1}\dbinom ip dp_{p,j,k}+\sum\limits_{p=0}^{j-1}\dbinom jp dp_{i,p,k}+\sum\limits_{p=0}^{k-1}\dbinom kp dp_{i,j,p}$。

---
$o\le10$。

数据范围提示我们去容斥。

假设可以且必须经过障碍。当经过一个障碍 $(x,y,z)$ 且经过它后可达 $(n,m,r)$ 时方案数为 $dp_{\operatorname{popcount}(x),\operatorname{popcount}(y),\operatorname{popcount}(z)}\cdot dp_{\operatorname{popcount}(n-x_i),\operatorname{popcount}(m-y_i),\operatorname{popcount}(r-z_i)}$。经过多个障碍的方案数就是把所有相邻的产生的贡献给乘起来。

枚举经过哪些障碍（要保证依次经过可以到达），答案即为不经过方案数，减去经过一个方案数，加上经过两个方案数，再减去经过三个方案数，以此类推。

---
$o\le10^4$ 正解。

注意到虽然范围很大，但障碍不多，甚至可以 $O(o^2)$ 冲过，考虑 $O(o^2)$ 做法。

以下将障碍和目标点统称为关键点，共有 $o+1$ 个。设 $f_i$ 为到达第 $i$ 个关键点的方案数。

考虑优化 $o\le10$ 的容斥。因为肯定是先经过 $x,y,z$ 小的点在经过大的点所以不妨以 $x$ 为第一关键字，$y$ 为第二关键字，$z$ 为第三关键字把关键点排个序。

如果可以无障碍地到达第 $i$ 个点，则方案为 $dp_{\operatorname{popcount}(x_i),\operatorname{popcount}(y_i),\operatorname{popcount}(z_i)}$。

枚举上一个关键点 $j$，保证 $j$ 可到 $i$。则从 $(0,0,0)$ 到第 $j$ 个关键点的方案数为 $f_j$；从第 $j$ 个关键点到第 $i$ 个关键点的方案数为 $dp_{\operatorname{popcount}(x_i-x_j),\operatorname{popcount}(y_i-y_j),\operatorname{popcount}(z_i-z_j)}$，相乘即可。不难发现其本质就是容斥的过程，只不过经过有个先后顺序就可以这样 dp。

---

## 作者：chroneZ (赞：0)

定义全集 $U$ 为无任何限制时从 $(0, 0, 0) \to (n, m, r)$ 的路径集，$C_i$ 表示不经过第 $i$ 个限制点的路径集。所求式为

$$
\begin{aligned}
|\bigcap C_i| &= |U| - |\bigcup \overline{C_i}|	\\
&= |U| - \sum_{S \subseteq[1, o], S \neq \varnothing} (-1) ^ {|S| - 1} |\bigcap_{x \in S} \overline{C_x}|
\end{aligned}$$

$\overline{C_i}$ 即 $C_i$ 的补集，也即经过第 $i$ 个限制点的路径集。换言之，上式即 钦定经过 $0$ 个限制点的方案数 $-$ 钦定经过 $1$ 个限制点的方案数 $+$ 钦定经过 $2$ 个限制点的方案数……考虑记 $g(i)$ 表示考虑了前 $i$ 个点，且要求经过第 $i$ 个点时的情况下**对容斥过程产生的贡献**（也就是说，我们要在计算过程中同时乘上容斥系数）。记 $T(i, j)$ 表示从第 $i$ 个限制点到第 $j$ 个限制点，且不考虑其余任何限制的路径方案数，则 $g(i) = -\sum \limits_{j \in [0, i - 1]} T(j, i)g_j$。（这个负号体现的即是容斥系数）

考虑计算 $T(i, j)$。若不满足 $x_i \subseteq x_j \wedge y_i \subseteq y_j \wedge z_i \subseteq z_j$，显然 $T(i, j) = 0$；否则，发现无限制条件下到一个点的路径数量仅与 $n, m, r$ 二进制表示下 $1$ 的数量相关。记 $f(x, y, z)$ 表示无任何限制时从 $(0, 0, 0) \to (n, m, r)$ 的路径数，其中 $\mathrm{popcount}(n) = x, \mathrm{popcount}(m) = y, \mathrm{popcount}(r) = z$，枚举一下它可以从哪些坐标转移来可得

$$f(x, y, z) = \sum_{i < x} f(i, y, z) \binom{x}{i} + \sum_{i < y} f(x, i, z) \binom{y}{i} + \sum_{i < z} f(x, y, i) \binom{z}{i}$$

那么 $T(i, j) = f(\mathrm{popcount}(x_i \oplus x_j), \mathrm{popcount}(y_i \oplus y_j), \mathrm{popcount}(z_i \oplus z_j))$。

最终答案的计算类似于 $g$ 的计算，这里给出一种更简单的方法，直接将 $(n, m, r)$ 作为障碍点 $o + 1$，最终答案为 $-g(o+1)$（因为多加入一个点后会影响容斥系数）

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
#define pc(x) __builtin_popcountll(x)

constexpr int N = 70, M = 1e4 + 10, mod = 998244353;

i64 binom[N][N], f[N][N][N], g[M];

struct point {i64 x, y, z;} p[M];

inline bool subset(i64 x, i64 y) {return ((x & y) == x);}

inline bool ok(int i, int j) {return (subset(p[i].x, p[j].x) && subset(p[i].y, p[j].y) && subset(p[i].z, p[j].z));}

int main(){
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); cout.tie(nullptr);
	
	for(int i = 0; i < N; i++){
		binom[i][0] = 1;
		for(int j = 1; j <= i; j++)
			binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % mod;
	}
	f[0][0][0] = 1;
	for(int x = 0; x < N; x++){
		for(int y = 0; y < N; y++){
			for(int z = 0; z < N; z++){
				for(int i = 0; i < x; i++)
					f[x][y][z] += f[i][y][z] * binom[x][i], f[x][y][z] %= mod;
				for(int j = 0; j < y; j++)
					f[x][y][z] += f[x][j][z] * binom[y][j], f[x][y][z] %= mod;
				for(int k = 0; k < z; k++)
					f[x][y][z] += f[x][y][k] * binom[z][k], f[x][y][z] %= mod;
			}
		}
	}

	i64 n, m, r; cin >> n >> m >> r;
	int o; cin >> o;
	for(int i = 1; i <= o; i++)
		cin >> p[i].x >> p[i].y >> p[i].z;
	sort(p, p + o + 1, [](point &A, point &B){
		return (A.x == B.x) ? (A.y == B.y ? A.z < B.z : A.y < B.y) : A.x < B.x;
	});

	p[++o] = {n, m, r};
	g[0] = 1;
	for(int i = 1; i <= o; i++){
		for(int j = 0; j < i; j++){
			if(!ok(j, i)) continue;
			g[i] += g[j] * f[pc(p[i].x ^ p[j].x)][pc(p[i].y ^ p[j].y)][pc(p[i].z ^ p[j].z)];
			g[i] %= mod;
		}
		g[i] = -g[i];
	}
	i64 ans = -g[o];
	cout << (ans % mod + mod) % mod << "\n";
}
```

---

## 作者：shenxinge (赞：0)

> solution of P3734

很经典的题目，考虑容斥，不经过障碍的方案数等于不钦定障碍的方案数减去钦定一个障碍的方案数加上钦定两个障碍的方案数这样不断下去。

将障碍一定顺序排序后统计 $f_i$ 代表仅仅考虑前 $i-1$ 个点，目前到达第 $i$ 个点的方案数，容易得到 $f_i=-\sum f_j$，其中 $j$ 满足三维坐标都包含于 $i$ 的三维坐标才可以转移。

容易发现转移的时候我们只需要知道起点和终点的三维分别 $1$ 的个数，过程相当于是补全相差的 $1$ 的个数，我们定义 $g_{i,j,k}$ 为第一维相差 $i$ 个 $1$，第二维相差 $j$ 个 $1$，第三维相差 $k$ 个 $1$ 的方案数 。

转移的时候枚举一个已有的差 $p$ ，容易发现填到这 $i$ 个位置里有 $C_{i}^{p}$ 种填法。

容易得到 $g$ 的转移:

$$g_{i,j,k}=\sum_{p=0}^{i-1}g_{p,j,k} \times C_{i}^{p} + \sum_{p=0}^{i-1}g_{i,p,k} \times C_{j}^{p} + \sum_{p=0}^{i-1}g_{i,j,p} \times C_{k}^{p}$$

这样就做完了 ， 时间复杂度 $O(o^2+\log_{2}^{4}{\max(n,m,r)})$

```cpp
//#pragma GCC optimize("Ofast,no-stack-protector")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
struct mint{
	int x;mint(int o=0){x=o;}mint&operator+=(mint a){return(x+=a.x)%=mod,*this;}mint&operator-=(mint a){return(x+=mod-a.x)%=mod,*this;}
	mint&operator*=(mint a){return(x=1ll*x*a.x%mod),*this;}mint&operator^=( int b){mint a=*this;x=1;while(b)(b&1)&&(*this*=a,1),a*=a,b>>=1;return*this;}
	mint&operator/=(mint a){return*this*=(a^=mod-2);}friend mint operator+(mint a,mint b){return a+=b;}friend mint operator-(mint a,mint b){return a-=b;}
	friend mint operator*(mint a,mint b){return a*=b;}friend mint operator/(mint a,mint b){return a/=b;}friend mint operator^(mint a, int b){return a^=b;}
	mint operator-(){return 0-*this;}bool operator==(const mint b)const{return x==b.x;}
};
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL);
	constexpr int maxn(63),maxo(1e5+5);
	static int n,m,r,t,cnt;
	cin >> n >> m >> r >> t;
	// f[i] rong chi  , f[i]=-\sum i<j f[j]
	// g[i][j][k] related to bit
	struct obstacle{int a,b,c;};
	static obstacle obs[maxo];
	for(int i=1;i<=t;i++)
		cin >> obs[i].a >> obs[i].b >> obs[i].c;
	sort(obs+1,obs+1+t,[&](obstacle x,obstacle y){
		if(x.a^y.a) return x.a<y.a;
		else if(x.b^y.b) return x.b<y.b;
		else return x.c<y.c;
	});cnt=t,obs[0]={0,0,0},obs[++cnt]={n,m,r};
	static mint c[maxn][maxn],g[maxn][maxn][maxn];
	auto prepare=[&](){
		c[0][0]=1;
		for(int i=1;i<maxn;i++){c[i][0]=1;
			for(int j=1;j<=i;j++)
				c[i][j]=c[i-1][j]+c[i-1][j-1];
		}
		g[0][0][0]=1ll;
		for(int i=0;i<maxn;i++)
			for(int j=0;j<maxn;j++)
				for(int k=0;k<maxn;k++){
					for(int p=0;p<i;p++) g[i][j][k]+=g[p][j][k]*c[i][p]; 
					for(int p=0;p<j;p++) g[i][j][k]+=g[i][p][k]*c[j][p];
					for(int p=0;p<k;p++) g[i][j][k]+=g[i][j][p]*c[k][p];
				}
	};prepare();static mint f[maxo];f[0].x=1ll;
	#define a(x) (obs[x].a)
	#define b(x) (obs[x].b)
	#define c(x) (obs[x].c)
	#define bcnt(x) (__builtin_popcountll(x))
	for(int i=1;i<=cnt;i++)
		for(int j=0;j<i;j++)
			if(((a(i)&a(j))==a(j))&&
			   ((b(i)&b(j))==b(j))&&
			   ((c(i)&c(j))==c(j)))
			f[i]-=f[j]*g[bcnt(a(i)^a(j))][bcnt(b(i)^b(j))][bcnt(c(i)^c(j))];
	cout << (mod-f[cnt].x)%mod << '\n';
	return 0;
}

```


---

## 作者：Umbrella_Leaf (赞：0)

考虑容斥，不经过障碍点的方案数 = 不管障碍点的方案数 - 钦定经过一个障碍点的方案数 + 钦定经过两个障碍点的方案数 - ……

令 $f_i$ 表示走到第 $i$ 个障碍点的答案，那么 $f_i=-\sum_{j<i}f_j( $从第 $j$ 个障碍点走到第 $i$ 个障碍点的方案数$ )$。

为了方便，把 $(0,0,0)$ 和 $(n,m,r)$ 也设成第 $0$ 个和第 $o+1$ 个障碍点，那么初始 $f_0=1$，最后答案是 $-f_{o+1}$。

然后需要处理两个点之间的方案数，发现方案数和每维二进制上差的部分有关，而且只和差的位数有关，那么设 $g_{i,j,k}$ 为三维分别差 $i,j,k$ 位，走过来的方案数。

所以有

$$g_{i,j,k}=\sum_{0\le p<i}g_{p,j,k}\dbinom{i}{p}+\sum_{0\le p<j}g_{i,p,k}\dbinom{j}{p}+\sum_{0\le p<k}g_{i,j,p}\dbinom{k}{p}$$

初值是 $g_{0,0,0}=1$，做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=998244353;
int n;
ll X,Y,Z;
ll f[10005],g[65][65][65];
ll C[65][65];
struct node{
	ll a,b,c;
	bool operator <(const node &y)const{
		if(a!=y.a)return a<y.a;
		else if(b!=y.b)return b<y.b;
		else return c<y.c;
	}
}a[10005];
int bitcnt(ll x){return !x?0:bitcnt(x&x-1)+1;}
int main(){
	C[0][0]=1;
	for(int i=1;i<=60;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	g[0][0][0]=1;
	for(int i=0;i<=60;i++)
		for(int j=0;j<=60;j++)
			for(int k=0;k<=60;k++){
				for(int p=0;p<i;p++)g[i][j][k]=(g[i][j][k]+g[p][j][k]*C[i][p]%mod)%mod;
				for(int p=0;p<j;p++)g[i][j][k]=(g[i][j][k]+g[i][p][k]*C[j][p]%mod)%mod;
				for(int p=0;p<k;p++)g[i][j][k]=(g[i][j][k]+g[i][j][p]*C[k][p]%mod)%mod;
			}
	scanf("%lld%lld%lld",&X,&Y,&Z);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld%lld",&a[i].a,&a[i].b,&a[i].c);
	sort(a+1,a+n+1);
	a[++n]=(node){X,Y,Z};
	a[0]=(node){0,0,0};
	f[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<i;j++)
			if((a[j].a&a[i].a)==a[j].a&&(a[j].b&a[i].b)==a[j].b&&(a[j].c&a[i].c)==a[j].c)
				f[i]=(f[i]-f[j]*g[bitcnt(a[i].a^a[j].a)][bitcnt(a[i].b^a[j].b)][bitcnt(a[i].c^a[j].c)]%mod+mod)%mod;
	printf("%lld\n",(mod-f[n])%mod);
	return 0;
}
```

---

## 作者：Register_int (赞：0)

经典容斥。  
先 dp 求出不含障碍点的方案数。通过观察可以发现，从 $(0,0,0)$ 到 $(x,y,z)$ 的路径条数只和 $x,y,z$ 的 $\text{popcount}$ 有关。设 $i,j,k$ 分别等于 $x,y,z$ 的 $\text{popcount}$，则得到 dp 转移：
$$dp_{i,j,k}=\sum^{i-1}_{p=0}\binom{i}{p}dp_{p,j,k}+\sum^{j-1}_{p=0}\binom{j}{p}dp_{i,p,k}+\sum^{k-1}_{p=0}\binom{k}{p}dp_{i,j,p}$$
然后容斥。先按字典序排序，然后统计 $ans_i$ 为到达第 $i$ 个点且只考虑前 $i-1$ 个点的方案数。枚举递推即可。  
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int mod = 998244353;
const int MAXN = 1e4 + 10;

inline 
int popcnt(ll n) {
	int cnt = 0;
	while (n) n &= n - 1, cnt++;
	return cnt;
}

inline 
int lg2(ll n) {
	int cnt = 0;
	while (n) n >>= 1, cnt++;
	return cnt;
}

struct node {
	ll x, y, z;
	int cx, cy, cz;
	bool operator < (const node &rhs) const { return x == rhs.x ? y == rhs.y ? z < rhs.z : y < rhs.y : x < rhs.x; }
} a[MAXN];

inline 
bool connect(int p, int q) {
	if ((a[p].x & a[q].x) != a[p].x) return 0;
	if ((a[p].y & a[q].y) != a[p].y) return 0;
	if ((a[p].z & a[q].z) != a[p].z) return 0;
	return 1;
}

ll c[61][61];

inline 
void init() {
	c[0][0] = 1;
	for (int i = 1; i < 60; i++) {
		c[i][0] = 1;
		for (int j = 1; j < 60; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
	}
}

ll n, m, r;

int cn, cm, cr, o, tot;

ll dp[61][61][61], ans[MAXN];

inline 
ll calc(int p, int q) {
	return dp[a[p].cx - a[q].cx][a[p].cy - a[q].cy][a[p].cz - a[q].cz];
}

int main() {
	scanf("%lld%lld%lld", &n, &m, &r), init();
	cn = lg2(n), cm = lg2(m), cr = lg2(r);
	scanf("%d", &o);
	for (int i = 1; i <= o; i++) {
		ll x, y, z;
		scanf("%lld%lld%lld", &x, &y, &z);
		a[i] = { x, y, z, popcnt(x), popcnt(y), popcnt(z) };
	}
	dp[0][0][0] = 1;
	for (int i = 0; i <= cn; i++) {
		for (int j = 0; j <= cm; j++) {
			for (int k = 0; k <= cr; k++) {
				for (int p = 0; p < i; p++) dp[i][j][k] = (dp[i][j][k] + c[i][p] * dp[p][j][k] % mod) % mod;
				for (int p = 0; p < j; p++) dp[i][j][k] = (dp[i][j][k] + c[j][p] * dp[i][p][k] % mod) % mod;
				for (int p = 0; p < k; p++) dp[i][j][k] = (dp[i][j][k] + c[k][p] * dp[i][j][p] % mod) % mod;
			}
		}
	}
	sort(a + 1, a + o + 1);
	a[++o] = { n, m, r, popcnt(n), popcnt(m), popcnt(r) };
	for (int i = 1; i <= o; i++) {
		ans[i] = dp[a[i].cx][a[i].cy][a[i].cz];
		for (int j = 1; j < i; j++) {
			if (connect(j, i)) ans[i] = (ans[i] - ans[j] * calc(i, j) % mod + mod) % mod;
		}
	}
	printf("%lld", ans[o]);
}
```

---


# [SHOI2012] 火柴游戏

## 题目背景

SHOI2012D1T1


## 题目描述

小明非常喜欢玩火柴游戏：首先用火柴棒摆出一个可能是错误的等式，然后通过添加、删除或移动火柴棒，使得等式成立。下图展示每个数字的样子：

 ![](https://cdn.luogu.com.cn/upload/pic/6548.png) 

我们只考虑形如“A = B”的式子，其中 A 和 B 是两个具有相同位数的整数。

小明可进行三种操作：

1. 在任意位置添加一根火柴棒；

2. 从任意位置删除一根火柴棒；

3. 将任意一根火柴棒移动到另一个位置。

在完成所有操作后，等号两侧必须都是合法的数字，且完全相等。我们约定：

1. 小明不能消除任何数字，也就是说，可以删除一个数字的部分火柴，但不能令它消失；

2. 小明不能增加任何数字，也就是说，可以在一个已有的数字上添加火柴，或将火柴移动到一个已有的数字上，但不能凭空增加一个数字；

3. 小明不能拆分或者合并数字，比如将一个 8 变成两个 1，或者将两个 1合并成一个 8；

4. 其中代表 1 的火柴棒必须靠右边摆放，放在左边不是有效的数字。每种操作都有一定的代价：

 对一个添加操作，如果这是第$i$次进行添加操作，这一步的费用为 $p_1\times i+q_1$

 对一个删除操作，如果这是第$i$次进行删除操作，这一步的费用为$p_2\times i+q_2$

 对一个移动操作，如果这是第$i$次进行移动操作，这一步的费用为$p_3\times i+q_3$

例如，小明在游戏中添加了 3 根火柴，移动了 1 根火柴，删除了 2 根火柴，那么他总的花费为$[(p_1\times 1+q_1)+(p_1\times 2+q_1)+(p_1\times 3+q_1)]+(p_3\times 1+q_3)+[(p_2\times 1+q_2 )+(p_2\times 2+q_2)]$。

小明想知道，他如何才能用最少的花费使等式成立。你能写个程序帮助他吗？


## 说明/提示

对于 30%数据，有$L\le 20$，且$p_1 = p_2 = p_3 = 0$；

对于 60%数据，有$L\le 100$；

对于 100%数据，有$L\le 200$。


## 样例 #1

### 输入

```
2
46
78
0 1 0 1 0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
2
23
52
1 1 1 1 1 1```

### 输出

```
9```

# 题解

## 作者：hylhyl (赞：5)

其实操作可以看成只有添加和删除两种
用一个二元数组dp[i][j]表示前i位数用j次添加操作最少要使用dp[i][j]次删除操作

枚举j，对于每一组添加和删除的操作集合（j，dp[n][j]）可以三分进行多少次转移操作。每进行一次转移操作相当于添加和减少操作数都减一.（其实枚举也能过。。。）
ps：第二个样例有误，答案应为9，

```cpp
#include<stdio.h>
#include<cmath>
#include<algorithm>
#include<string.h>
using namespace std;
const int maxn=205;
const int inf=0x7f7f7f7f7f;
int dp[maxn][505],p[5],q[5],n,ad[10][10],de[10][10];
int num[10][8]={{0,1,1,1,0,1,1,1},{0,0,0,1,0,0,1,0},{0,1,0,1,1,1,0,1},{0,1,0,1,1,0,1,1},{0,0,1,1,1,0,1,0},{0,1,1,0,1,0,1,1},{0,1,1,0,1,1,1,1},{0,1,0,1,0,0,1,0},{0,1,1,1,1,1,1,1},{0,1,1,1,1,0,1,1}};
char a[maxn],b[maxn];
int as(int s,int f)
{
    int i,ans=0;
    for(i=1;i<=7;i++)
    if(num[s][i]==num[f][i])continue;
    else if(num[s][i]==0) ans++;
    return ans;
}
int ds(int s,int f)
{
    int i,ans=0;
    for(i=1;i<=7;i++)
    if(num[s][i]==num[f][i])continue;
    else if(num[s][i]==1) ans++;
    return ans;
}
int getans(int i,int j)
{
    int ans=inf,k,l=0,maxk=min(i,j);
    for(k=0;k<=maxk;k++)
    {
        ans=min(ans,p[1]*(1+i-k)*(i-k)/2+(i-k)*q[1]+
        p[2]*(1+j-k)*(j-k)/2+(j-k)*q[2]+
        p[3]*(1+k)*k/2+k*q[3]);
    }
    return ans;
}
int main()
{
    int i,j,k,m,ans=inf;
    scanf("%d",&n);
    scanf("%s %s",a,b);	
    scanf("%d%d%d%d%d%d",&p[1],&q[1],&p[2],&q[2],&p[3],&q[3]);
    for(i=0;i<10;i++)
    {
        for(j=0;j<10;j++)
        {
            ad[i][j]=as(i,j);
            de[i][j]=ds(i,j);
        }
    }
    for(i=0;i<n;i++)
    {
        a[i]-='0',b[i]-='0';
    }
    for(i=1;i<=n;i++)
        for(j=0;j<505;j++)
            dp[i][j]=inf;
    for(m=1;m<=n;m++)
        for(k=0;k<10;k++)
        {
            int add=ad[a[m-1]][k]+ad[b[m-1]][k];
            int del=de[a[m-1]][k]+de[b[m-1]][k];
            for(i=0;i<505;i++)
                if(i>=add)
                dp[m][i]=min(dp[m][i],dp[m-1][i-add]+del);
        }
    for(i=0;i<505;i++)
        if(dp[n][i]!=inf)
        ans=min(ans,getans(i,dp[n][i]));
    printf("%d",ans);
    return 0;
}
```

---

## 作者：wuudii (赞：4)

## $\bf 1.1$ 题目传送门

[P3828](https://www.luogu.com.cn/problem/P3828)。

## $\bf 1.2$ 题意简述

有一个仅由数字和等号构成的等式，等式两边的数字都由 $L$ 个由火柴棒构成的数字构成。有添加 / 删除 / 移动一根火柴棒三种操作，代价不同，问使等式成立的最小代价。

## $\bf 2.1$ 初步分析

我们注意到题目中要求不能删除或添加数字，所以我们需要进行一些操作使得等式两边的数字一一对应相等。

注意到添加 / 删除 / 移动三种操作处理起来有些麻烦，同时一次添加操作与一次删除操作可以转化为一次移动操作，所以考虑先求出添加 / 删除操作的相关值，再判断转化为移动操作是否更优。

## $\bf 2.2$ 算法分析

首先，我们可以打表预处理出将某个数变为另一个所需的添加 / 删除操作次数，降低时间复杂度。

对于添加 / 删除操作的求值，可以使用 dp，而在知道添加 / 删除操作的次数情况下，由于每位数字最多被进行 $6$ 次操作，所以对于一种情况判断的次数最多为 $12L$ (要使两边同一位的两个数字相等)，所以总共判断次数最多为 $L^2$ 级别，不会超时。

## $\bf 2.3$ 较为暴力的 dp

最简单的想法：$f_{i,j,k}$ 表示前 $i$ 位数字，进行 $j$ 次添加操作和 $k$ 次移除操作，能否实现使前 $i$ 位数字相等。由于 $f$ 的值只有 $1$ 或 $0$，所以可以 bitset 优化。在转移时，枚举第 $i$ 位最终转化为哪一个数，时间复杂度 $\Theta(\frac{n^3 \cdot k}{\omega})$，其中 $k$ 表示一位的可以转化为的数字数量，$k=10$，由于一个数最多被操作 $6$ 次，故在枚举添加和移除操作次数时还有一个极大的常数（应该是 $144$）。虽然理论复杂度并不优秀，但是实测可以通过。

## $\bf 2.4$ 正解 dp

首先讲一个错解，$f_{i,j}$ 表示前 $i$ 位数字，进行 $j$ 次添加操作，所需移除操作的最小次数。这个想法错在如果添加与移除操作的代价较大，而移动操作代价小，多进行一次添加 / 移除操作然后替换为一次移动操作可能更优。

为了避免这个情况，考虑 $f_{i,j}$ 表示前 $i$ 位数字，添加与移除操作的差值为 $j$，所需添加操作次数的最小值。这个做法正确是因为即使移动操作代价极小，进行 $x$ 次添加操作与 $y$ 次移除操作一定不劣于进行 $x+k$ 次添加操作与 $y+k$ 次移除操作。

从而，我们可以求出不同差值情况下添加与移除操作的最优值，再进行枚举取最优值即可。时间复杂度 $\Theta(n^2k)$，同时枚举差值时有一个 $24$ 的常数（每个数字最多被进行 $6$ 次操作，故差值最大为 $12n$，枚举范围为 $-12n \sim 12n$）。具体细节见代码。

## $\bf 3$ 代码

```cpp

#include<bits/stdc++.h>
using namespace std;

int L;
int a[210],b[210];
int p1,q1,p2,q2,p3,q3;
int ad[15][15],rm[15][15];
bool st[15][10]={{0,1,1,1,0,1,1,1},{0,0,0,0,0,0,1,1},{0,1,0,1,1,1,1,0},{0,1,0,0,1,1,1,1},{0,0,1,0,1,0,1,1},{0,1,1,0,1,1,0,1},{0,1,1,1,1,1,0,1},{0,1,0,0,0,0,1,1},{0,1,1,1,1,1,1,1},{0,1,1,0,1,1,1,1}};//打表数字的构成
int f[210][6000];
void get(){//预处理将一个数字转化为另一个数字所需添加和移除操作的次数
	for(int i=0;i<=9;i++){
		for(int j=0;j<=9;j++){
			for(int k=1;k<=7;k++){
				if(st[i][k]&&(!st[j][k])){
					rm[i][j]++;
				}
				if((!st[i][k])&&st[j][k]){
					ad[i][j]++;
				}
			}
		}
	}
}
int main(){
	get();
	cin>>L;
	for(int i=1;i<=L;i++){
		scanf("%1d",&a[i]);
	}
	for(int i=1;i<=L;i++){
		scanf("%1d",&b[i]);
	}
	cin>>p1>>q1>>p2>>q2>>p3>>q3;
	memset(f,0x3f,sizeof(f));
	int base=3000;//因为差值可能为负，所以加上一个值防止 RE
	f[0][base]=0;
	for(int i=1;i<=L;i++){
		for(int j=-i*12;j<=i*12;j++){
			for(int k=0;k<=9;k++){//枚举将此位数字变为哪个数字
				int add=ad[a[i]][k]+ad[b[i]][k];//变为此数字所需添加操作次数
				int rmv=rm[a[i]][k]+rm[b[i]][k];//变为此数字所需移除操作次数
				f[i][base+j]=min(f[i][base+j],f[i-1][base+j+add-rmv]+add);
			}
		}
	}
	long long ans=1e15;
	for(int i=-L*12;i<=L*12;i++){
		long long now=0;
		int add=f[L][base+i];//此情况下添加操作次数
		now+=add*(p1+q1+add*p1+q1)/2;//计算目前代价
		int rmv=add+i;//此情况下移除操作次数
		now+=rmv*(p2+q2+rmv*p2+q2)/2;//计算目前代价
		if(add>L*12||rmv>L*12)continue;
		int chg=1;
		while(add&&rmv&&p1*add+q1+p2*rmv+q2>p3*chg+q3){//暴力枚举判断一次移动操作是否更优
			now+=p3*chg+q3-(p1*add+q1)-(p2*rmv+q2);
			add--,rmv--,chg++;
		}
		ans=min(ans,now);
	}
	cout<<ans;
}
```



---

## 作者：stardust_Ray (赞：3)

蒟蒻第一次写题解求过审。

感谢大佬[hylhyl](https://www.luogu.com.cn/user/49048)和[uwagjaynoi](https://www.luogu.com.cn/user/77144)的思路。

[题目传送门](https://www.luogu.com.cn/problem/P3828)

## Solution

首先我们容易发现，移动实际上是一次插入加一次删除，然后我们很自然的想到用插入的数量和删除的数量做 DP。

然后我们设 $f_{i,j}$ 表示到第 $i$ 位有 $j$ 次插入时删除的数量的最小值，通过枚举每一位上的值进行暴力转移。

最后考虑每个 $f_{n,i}$ 中有多少个移动，暴力枚举即可。

然后您高兴地写完了代码，WA on #1。

然后您翻开讨论区，看到了这样一组数据。

```
1
4
1
100 100 100 100 0 0
```

非常显然，您输出了 $200$，但答案是 $0$。

但我们容易发现，$i$ 次插入 $j$ 次删除一定比 $i+k$ 次插入 $j+k$ 次删除（$k>0$）更优，于是我们可以考虑将插入与删除的差作为状态转移，转移方式与上述方式相同。

然后就没了。

## Code:

```cpp
/*注意差值有负数的可能性，故以下f数组第二维表示插入数量-删除数量+n*5*/
#include<bits/stdc++.h>
#define within :
#define LJY main
using namespace std;
typedef long long ll;
const int N=205,inf=0x7f7f7f7f;
int n,p1,q1,p2,q2,p3,q3;
int add[10][10],del[10][10];
int f[N][N*10];
char a[N],b[N];
bool s[10][7]={{1,1,1,0,1,1,1},{0,0,1,0,0,1,0},{1,0,1,1,1,0,1},{1,0,1,1,0,1,1},{0,1,1,1,0,1,0},{1,1,0,1,0,1,1},{1,1,0,1,1,1,1},{1,0,1,0,0,1,0},{1,1,1,1,1,1,1},{1,1,1,1,0,1,1}}; //每个数字对应的火柴摆放方式
int Add(int x,int y){int c=0;for(int i=0;i<7;i++) c+=((!s[x][i])&&s[y][i]);return c;}
int Del(int x,int y){int c=0;for(int i=0;i<7;i++) c+=(s[x][i]&&(!s[y][i]));return c;}
int getans(int x,int y){ //暴力查询x个插入和y个删除时的权值的最小值
    int ans=inf;
    for(int i=0;i<=min(x,y);i++){
        int a=(x-i+1)*(x-i)/2,b=(y-i+1)*(y-i)/2,c=i*(i+1)/2;
        ans=min(ans,p1*a+p2*b+p3*c+(x-i)*q1+(y-i)*q2+i*q3);
    }return ans;
}
signed LJY(){
    //预处理每个数字转移的插入和删除数量
    for(int i=0;i<10;i++) for(int j=0;j<10;j++)
        add[i][j]=Add(i,j),del[i][j]=Del(i,j);
    scanf("%d",&n);scanf("%s%s",a+1,b+1);
    scanf("%d%d%d%d%d%d",&p1,&q1,&p2,&q2,&p3,&q3);
    for(int i=0;i<=n;i++) for(int j=0;j<=n*10;j++) f[i][j]=inf;f[0][n*5]=0;
    for(int i=1;i<=n;i++) a[i]^=48,b[i]^=48;
    for(int i=1;i<=n;i++)
        for(int j=0;j<10;j++){
            int A=add[a[i]][j]+add[b[i]][j];
            int B=del[a[i]][j]+del[b[i]][j];
            //暴力转移
            for(int k=max(A-B,0);k<=n*10;k++)
                f[i][k]=min(f[i][k],f[i-1][k-A+B]+B);
        }int ans=inf;
    for(int i=0;i<=n*10;i++)
        if(f[n][i]!=inf)
            ans=min(ans,getans(f[n][i]+i-n*5,f[n][i]));
    printf("%d\n",ans);//van结撒花
    return 0;
}
```

---


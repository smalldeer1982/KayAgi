# [TJOI2007] 脱险

## 题目背景

一批探险队员正在一个迷宫一样的山洞里摸索，突然他们得到了一个糟糕的消息，由于附近发生地震，这个山洞将有可能在 $T$ 个单位时间后坍塌。现在他们要用最快的速度找出一个方案，使得在 $T$ 个单位时间内逃出的队员最多。已知探险队员在一个单位时间内可以向前后左右任一方向移动一格，也可以停留在原地不动。有一个糟糕的情况是，虽然山洞的内部比较宽敞，但山洞的出口都非常狭窄，一个单位时间只能允许一名队员通过。


## 题目描述

山洞的地图用一个 $R \times C$ 的字符矩阵表示：

- `.` 表示在开始的时候没有探险队员的空地，空地可以容纳任意多的探险队员；
- `P`表示在开始的时候有探险队员的空地，我们假设在开始的时候所有的队员都在不同的位置上，且没有队员恰好位于出口所在的方格；
- `*` 表示障碍物，探险队员不能经过被障碍物占据的方格；
- `O`（大写字母 `O`）表示出口，输入数据保证出口一定位于地图的边界上，即只有第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列有可能出现 `O`。

另外，输入数据保证整个地图被边界和出口围住，即第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列只能是 `*` 或 `O`。


## 说明/提示

山洞有两个出口，但只有右边的出口是可以到达的。虽然在 $3$ 个单位时间内两人都可以到达出口左侧的方格处，但由于在出口处一个单位时间只能允许一人通过，故 $4$ 个单位时间内只能逃出一人。两人都逃出需要 $5$ 个单位时间。

- 对于 $30\%$ 的数据，队员数和出口数均不超过 $10$；
- 对于 $100\%$ 的数据，$3 \le R, C \le 12，0 < T \le 50$。


## 样例 #1

### 输入

```
5 5
4
*****
*P..*
O**.O
*P..*
*****```

### 输出

```
1```

# 题解

## 作者：nianheng (赞：4)

### 分层图最大流

建议和[[CTSC1999]家园](https://www.luogu.org/problemnew/show/P2754)一起做，因为这两道题的思路基本上是一样的。

按照时间建$T+1$层分层图，每一层都是$n*m$个点对应着这个时刻原图的$n*m$个点。

首先源点向第0层的每个探险队员点连流量为1的边，如果最终能流到了汇点说明这个人逃脱了。

对于任意一层：

(首先规定障碍永不连边)

每个位置在这一层对应点向每个他能到达的位置(上下左右)在下一层对应点连一条流量为$inf$的边，表示这一秒可以有任意多的人从一个空地移动到另一块空地。

每个空地/出口在这一层的对应点向它在下一层的对应点连$inf$的边表示这个位置可以容纳inf个人不动。

每个出口在这一层的对应点向汇点连一条流量为1的边表示每个时刻只允许一个人脱险。

然后直接跑$dinic$求最大流即为答案

```cpp
#include<map>
#include<cmath>
#include<ctime>
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define qmin(x,y) (x=min(x,y))
#define qmax(x,y) (x=max(x,y))
#define mp(x,y) make_pair(x,y)
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
inline int read(){
	int ans=0,fh=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		ans=ans*10+ch-'0',ch=getchar();
	return ans*fh;
}
const int maxn=1e4+100,maxm=5e5+100,maxd=20;
const int inf=0x7fffffff;
int n,m,T,head[maxn],nex[maxm],v[maxm],w[maxm],num=1;
int p[maxd][maxd],bh[maxd][maxd],cur[maxn],cc[maxn],s,t;
int uu[4]={1,0,-1,0},vv[4]={0,-1,0,1};
char c[maxd];
queue<int>q;
inline void add(int x,int y,int z){
	v[++num]=y,w[num]=z,nex[num]=head[x],head[x]=num;
	v[++num]=x,w[num]=0,nex[num]=head[y],head[y]=num;
}
inline void build(){
	s=0,t=maxn-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(p[i][j]==2) add(s,bh[i][j],1);
	int nm=n*m;
	for(int d=0;d<=T;d++){
		int st=nm*d;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++){
				if(!p[i][j]) continue;
				int x=st+bh[i][j];
				for(int k=0;k<4;k++){
					int vx=i+uu[k],vy=j+vv[k];
					if(vx<1||vx>n||vy<1||vy>m) continue;
					if(p[vx][vy]) add(x,st+nm+bh[vx][vy],inf);
				}
				if(p[i][j]==3) add(x,t,1),add(x,x+nm,1);
				else add(x,x+nm,inf);
			}
	}
}
inline bool bfs(){
	memset(cc,0,sizeof(cc));
	cc[s]=1,q.push(s);
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nex[i]){
			int y=v[i];if(!w[i]) continue;
			if(!cc[y]) cc[y]=cc[x]+1,q.push(y);
		}
	}
	return cc[t];
}
int dfs(int x,int lv){
	if(x==t) return lv;
	for(int &i=cur[x];i;i=nex[i]){
		int y=v[i];if(!w[i]) continue;
		if(cc[y]==cc[x]+1){
			int pp=dfs(y,lv>w[i]?w[i]:lv);
			if(pp){
				w[i]-=pp,w[i^1]+=pp;
				return pp;
			}
		}
	}
	return 0;
}
inline int dinic(){
	int maxl=0,lv=0;
	while(bfs()){
		memcpy(cur,head,sizeof(cur));
		while(lv=dfs(s,inf)) maxl+=lv;
	}
	return maxl;
}
int main(){
//	freopen("nh.in","r",stdin);
//	freopen("zhy.out","w",stdout);
	n=read(),m=read(),T=read();
	for(int i=1;i<=n;i++){
		scanf("%s",c+1);
		for(int j=1;j<=m;j++){
			bh[i][j]=(i-1)*m+j;
			if(c[j]=='.') p[i][j]=1;
			if(c[j]=='P') p[i][j]=2;
			if(c[j]=='O') p[i][j]=3;
		}
	}
	build();
	printf("%d\n",dinic());
	return 0;
}
```


---

## 作者：Zikl (赞：1)

### 算法

网络流

这道题和[P2472 [SCOI2007] 蜥蜴](https://www.luogu.com.cn/problem/P2472)有一点像，但更简单

我们可以用网络流做这道题，还不会的可以把模板写一下[P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)

### 思路

网络流的难点在于建图，而这道题的图是根据时间 $tt$ 建的。

在每个时间 $tt$ 内，遍历 $r \times c$ 的图，将当前节点与 $tt + 1$ 时它的前后左右方连上，遇到障碍跳过就好。

根据 “空地可以容纳任意多的探险队员”，每个点连上的边流量为 $\inf$，同时，因为“但山洞的出口都非常狭窄，一个单位时间只能允许一名队员通过”，所以在出口出的流量为 1。

建完图跑一个 dinic。
### 注意事项  
1. 在解释说明里，我们可以发现，入口处的流量不是 $\inf$，是 1。
2. 队员站在出口就算逃出，所以时间 $tt = t + 1$。
3. 汇点别开重了，数据开大点。

代码如下。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int inf=1<<30;
using namespace std;
int r,c,s,t,tt,p[20][20],d[20][20];
int dep[1000005];
int head[1000005],next1[1000005],ver[1000005],tot=1,cur[1000005],edg[1000005],from[10000005];
void add(int x,int y,int z){
	ver[++tot]=y,from[tot]=x,edg[tot]=z,next1[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edg[tot]=0,next1[tot]=head[y],head[y]=tot;
}
int bfs(){
	memset(dep,-1,sizeof(dep));
	memcpy(cur,head,sizeof(head));
	dep[s]=0;
	queue<int>q;
	q.push(s);
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=next1[i]){
			int y=ver[i];
			if(dep[y]==-1&&edg[i]>0){
				q.push(y);
				dep[y]=dep[x]+1;
			}
		}
	}	
	return dep[t]!=-1;
}
int dfs(int u,int flow){
	if(u==t){
		return flow;
	}
	int rest=flow;
	int i,mi;
	for(i=cur[u];i&&rest;i=next1[i]){
		int y=ver[i];
		if(edg[i]&&(dep[y]==dep[u]+1)){
			mi=dfs(y,min(edg[i],rest));
			rest-=mi;
			edg[i]-=mi;
			edg[i^1]+=mi;
		}
	}
	cur[u]=i;
	return flow-rest;
}
int dinic(){
	int ans=0;
	while(bfs()){
		ans+=dfs(s,inf);
	}
	return ans;
}
int main(){
	cin>>r>>c;
	cin>>tt;
	tt++;	
	s=0,t=114514;
	for(int i=1;i<=r;i++){
		string ss;
		cin>>ss;
		for(int j=0;j<c;j++){
		if(ss[j]=='.') p[i][j+1]=1;
		if(ss[j]=='P') p[i][j+1]=2,add(s,(i-1)*c+j+1,1);
		if(ss[j]=='O') p[i][j+1]=3;
		} 
	} 
	for(int i=1;i<=tt;i++)
	 for(int j=1;j<=r;j++)
	  for(int k=1;k<=c;k++){
		if(p[j][k]==0)continue;
		if(p[j][k]==3) add((j-1)*c+k+(i-1)*r*c,t,1);
        
		if(j-1>=1&&p[j-1][k]!=0) 
		add((j-1)*c+k+(i-1)*r*c,(j-2)*c+k+i*r*c,inf);
        
		if(j+1<=r&&p[j+1][k]!=0) 
		add((j-1)*c+k+(i-1)*r*c,j*c+k+i*r*c,inf);
        
		if(k-1>=1&&p[j][k-1]!=0) 
		add((j-1)*c+k+(i-1)*r*c,(j-1)*c+k-1+i*r*c,inf);
        
		if(k+1<=c&&p[j][k+1]!=0) 
		add((j-1)*c+k+(i-1)*r*c,(j-1)*c+k+1+i*r*c,inf);

		add((j-1)*c+k+(i-1)*r*c,(j-1)*c+k+i*r*c,inf);
	}

	cout<<dinic();
	return 0;
}  
```
感谢观看。ovo

撒花。✿✿✿

---

## 作者：StarsIntoSea (赞：0)

# Solution

不难发现，在移动时常常出现不同位置的情况，而对于每种时刻，向下一个时刻并不难表示，所以考虑分层来解决状态问题，即**分层图最大流**。

建一个  $T+1$ 层的图，其中第 $i$ 层表示 $i-1$ 时刻的情情况，$0$ 时刻就是初始状态。

建边过程：

- 一个人可以往上下左右走，也可以不走。所以对于每个空地（人的位置也算空地）向**下一层**的**上下左右及其自身**位置建边。
- 对于**每一层每一个**`O`点向超级汇点 $t$ 建边。
- 超级源点 $s$ 向所有**第一层**的`P`点建边。
- 如果向下建边时有墙就不建边，也就是墙的部分**始终不建边**。
- 所有边的流量均为 $1$。 

时间复杂度 $O(T^3 R^3 C^3)$，因为有墙且流量为 $1$，所以常数很小（最慢都跑不到10ms）。

# Code 


```cpp
#include <iostream>
#include <string.h>
#include <queue>
using std::cin,std::queue,std::min;
struct node{int v,c,ne;}e[1000005];
int h[7500],idx=1;
char Map[15][15];
int d[7500],cur[7500];
int T,R,C,s,t;

void add(int a,int b,int c){
	e[++idx]={b,c,h[a]};
	h[a]=idx;
}

int hush(int t,int r,int c){
	return t*R*C+(r-1)*C+c;
}

void print(){
	scanf("%d%d%d",&R,&C,&T);
	for(int i=1;i<=R;++i)
		for(int j=1;j<=C;++j)
			cin>>Map[i][j];
}

void build(){
	s=0,t=hush(T+1,1,1);
	for(int i=1;i<=R;++i)
		for(int j=1;j<=C;++j){
			int u,v;
			if(Map[i][j]=='P') add(s,hush(0,i,j),1),add(hush(0,i,j),s,0);
			if(Map[i][j]=='P'||Map[i][j]=='.'){
				for(int tim=0;tim<T;++tim){
					u=hush(tim,i,j),v=hush(tim+1,i,j);
					add(u,v,1),add(v,u,0);
				} 
			}
			if(Map[i][j]=='O'){
				for(int tim=0;tim<=T;++tim){
					u=hush(tim,i,j);
					add(u,t,1),add(t,u,0);
				}
			}
		}
	for(int tim=0;tim<T;++tim)
		for(int i=1;i<=R;++i)
			for(int j=1;j<=C;++j){
				if(Map[i][j]=='P'||Map[i][j]=='.'){
					int u=hush(tim,i,j),v;
					if(Map[i+1][j]!='*'){
						v=hush(tim+1,i+1,j);
						add(u,v,1),add(v,u,0);
					} 
					if(Map[i-1][j]!='*'){
						v=hush(tim+1,i-1,j);
						add(u,v,1),add(v,u,0);
					}
					if(Map[i][j+1]!='*'){
						v=hush(tim+1,i,j+1);
						add(u,v,1),add(v,u,0);
					}
					if(Map[i][j-1]!='*'){
						v=hush(tim+1,i,j-1);
						add(u,v,1),add(v,u,0);
					}
				}
			}
}

bool bfs(){
	memset(d,0,sizeof d);
	d[s]=1;
	queue<int> q;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=h[u];i;i=e[i].ne){
			int v=e[i].v;
			int w=e[i].c;
			if(!d[v]&&w){
				d[v]=d[u]+1;
				q.push(v);
				if(v==t) return 1;
			}
		}
	}
	return 0;
}

int dfs(int u,int mf){
	if(u==t) return mf;
	int sum=0;
	for(int i=cur[u];i;i=e[i].ne){
		cur[u]=i;
		int v=e[i].v;
		int w=e[i].c;
		if(d[v]==d[u]+1&&w){
			int f=dfs(v,min(w,mf));
			e[i].c-=f;
			e[i^1].c+=f;
			sum+=f;
			mf-=f;
			if(!mf) break;
		}
	}
	if(!sum) d[u]=0;
	return sum;
}

void Dinic(){
	int res=0;
	while(bfs()){
		memcpy(cur,h,sizeof h);
		res+=dfs(s,2147483647);
	}
	printf("%d\n",res);
}

int main(){
	print();
	build();
	Dinic();
}
```

---

## 作者：Resonance (赞：0)

### 二分图最大匹配
#### 分析
从每个人跑一遍bfs,得到这个人到某个出口的最短时间t

那么如果将门和时间的二元组看作一个状态

即(id,tim),然后人向(id,t),(id,t+1)....(id,T)连边

表示这个人在这些时间可以通过这个出口

然后就构成了二分图,人和一个二元组

跑匈牙利算法就可以了

#### Code
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define N 550
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct node{
	int x,y,len;
	node(){}
	node(int a,int b,int c){x=a;y=b;len=c;}
};
char ch[N];
queue<node> q;
bool used[N][N],e[N][N][N];
int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
int ans,R,C,T,t1,t2,vis[N][N],id[N][N],map[N][N],mat[N][N];
bool ok(int x,int y){
	if(x<1||x>R||y<1||y>C) return 0;
	if(map[x][y]==3) return 0;
	return 1;
}
void add(int x,int y,int d){
	for(;d<=T;++d)
		e[x][y][d]=1;
}
void bfs(int sx,int sy){
	q.push(node(sx,sy,0));
	memset(vis,0,sizeof(vis));
	while(!q.empty()){
		node A=q.front();q.pop();
		int x=A.x,y=A.y,len=A.len;
		if(vis[x][y]) continue;
		vis[x][y]=1;
		if(map[x][y]==2) 
			add(id[sx][sy],id[x][y],len);
		for(int i=0;i<4;++i){
			int nex=x+dx[i],ney=y+dy[i];
			if(ok(nex,ney)) q.push(node(nex,ney,len+1));
		}	
	}
}
bool find(int x){
	for(int i=1;i<=t2;++i)
		for(int j=1;j<=T;++j){
			if(e[x][i][j]&&!used[i][j]){
				used[i][j]=1;
				if(!mat[i][j]||find(mat[i][j])){
					mat[i][j]=x;
					return 1;
				}
			}
		}
	return 0;		
}
int main(){
	R=read();C=read();T=read();
	for(int i=1;i<=R;++i){
		scanf("%s",ch+1);
		for(int j=1;j<=C;++j){
			if(ch[j]=='P'){
				map[i][j]=1;
				id[i][j]=++t1;
			}
			if(ch[j]=='O'){
				map[i][j]=2;
				id[i][j]=++t2;
			}
			if(ch[j]=='*')
				map[i][j]=3;
		}
	}
	for(int i=1;i<=R;++i)
		for(int j=1;j<=C;++j)
			if(map[i][j]==1) bfs(i,j);
	for(int i=1;i<=t1;++i){
		memset(used,0,sizeof(used));
		if(find(i)) ++ans;
	}	
	printf("%d\n",ans);	
}
```

---


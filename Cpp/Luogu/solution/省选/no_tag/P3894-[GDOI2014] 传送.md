# [GDOI2014] 传送

## 题目描述

有 $n$ 个国家，编号分别为 $0$ 到 $n-1$。第 $i$ 个国家包含 $m_i$ 个城市，编号分别为 $0$ 到 $m_{i}-1$，其中编号为 $0$ 的城市是该国家的首都。为了表示的方便，我们用 $(i,j)$ 来表示第 $i$ 个国家的第 $j$ 个城市。同一个国家的城市之间有通路，这些通路构成一棵树，首都则是这棵树的根。而不同国家的城市之间没有通路，只能通过传送门。每个国家只有处于叶子节点的城市具有传送门，传送门的目的地可以是编号相邻的国家的任意一个处于叶子节点的城市，每次传送需要花费 $1$ 个单位时间，并且每个传送门只能使用一次。如下图所示，如果出发地是 $(0,2)$，目的地是 $(2,1)$，则 $(0,2)\rightarrow(1,1)\rightarrow(1,0)\rightarrow(1,2)\rightarrow(2,1)$ 是一条可行路径，而 $(0,2)\rightarrow(1,1)\rightarrow(2,1)$ 则是非法的，因为 $(1,1)$ 的传送门在 $(0,2)\rightarrow(1,1)$ 的时候被使用了一次，在 $(1,1)\rightarrow(2,1)$ 的时候又被使用了一次。

 ![](https://cdn.luogu.com.cn/upload/pic/6852.png) 

给定出发地和目的地，问最少需要多少时间。

## 说明/提示

对于 $40\%$ 的数据，$n \leq 10,\sum m_i \leq 10^{3},q \leq 10$。

对于 $60\%$ 的数据，$n \leq 10^{3},\sum m_i \leq 10^{6}$。

对于 $100\%$ 的数据，$n \leq 3.5 \times 10^{5},\sum m_i \leq 10^{6},1 \leq t \leq 10^{3},q \leq 10^{5}$。

## 样例 #1

### 输入

```
5
3
0 1 1
0 2 1
3
0 1 2
2 0 1
3
0 1 1
0 2 1
2
0 1 2
3
0 1 1
0 2 1
3
0 2 2 1
0 0 2 1
2 2 4 1
```

### 输出

```
5
6
-1
```

# 题解

## 作者：s_r_f (赞：3)

这题的数据好像是错的吧?用省选原数据我是$A$的。。。

$upd:$真的数据已经放在讨论区

分类讨论：

## **第一种情况：** $s0 ≠ e0$

不妨设$s0 < e0$.

容易发现，在区间$[s0+1,e0-1]$的城市中，

我们需要用到传送门，先从$i-1$传送到$i$，再从$i$传送到$i+1$.

所以我们需要找一条**最短的 从一个叶子节点到另一个叶子节点 的路径。**

这个可以通过树形$DP$，$O(\sum m_i)$ 得出。

然后，我们还需要从$(s0,e0)$走到第$s0$棵树的一个**最近的叶子节点**,从$(s1,e1)$走到第$s1$棵树的一个**最近的叶子节点**。

最后统计答案时，三段距离的和 $ + $ 传送门使用次数$($即$s1 - s0)$ 就是最短路。

## **第二种情况：** $s0 = e0$

一开始我$naive$了，以为就是树上两点的距离

结果我对拍出错了！

实际上，**我就是$naive$了**.

设这两个点为$u,v$

我们可以从$u$，走到最近的叶子节点$p_u$

然后传送到另一棵树中，走到**另一个**叶子节点$($**能用的**传送门$)$

再用传送门，传送到$v$的最近的叶子节点$p_v$,

然后再走回$v!$

那么$ans$还可以是$u,v$到叶子节点的最近距离之和 $ + $ 隔壁的$≤2$棵树上**最短的 从一个叶子节点到另一个叶子节点 的路径** $ + $ 两次传送的花费$2$.

然后就可以过省选数据了。。。~~不知道为什么luogu数据过不去~~

代码:
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline int read(){
    static int x,f; x = 0,f = 1; static char c; c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(LL x){
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
inline void writeln(LL x){ write(x),putchar('\n'); }
const int N = 350005,V = 1000005,E = V<<1;
const LL INF = 1005ll * E;
int To[E],Ne[E],Dis[E],He[V],k;
inline void add(int x,int y,int z){ ++k; To[k] = y,Ne[k] = He[x],Dis[k] = z,He[x] = k; }
int n,l[N],r[N]; LL a[N],v[V],pre[N];
int from[V];

int fa[V],top[V],size[V],son[V],dpt1[V]; LL dpt[V];
LL ww;
void dp(int x,int f,int id){
    v[x] = INF; from[x] = -1; fa[x] = f; dpt1[x] = dpt1[f] + 1;
    size[x] = 1;
    for (int p = He[x],y; p ; p = Ne[p]) if ((y = To[p]) ^ f){
        dpt[y] = dpt[x] + Dis[p];
        dp(y,x,id);
        if ((ww = v[x] + v[y] + Dis[p]) < a[id]) a[id] = ww;
        if ((ww = v[y] + Dis[p]) < v[x]) v[x] = ww,from[x] = from[y];
        size[x] += size[y];
        if (size[y] > size[son[x]]) son[x] = y; 
    }
    if (!son[x]) v[x] = 0,from[x] = x;
}
void dp2(int x,int f,int id,int dd){
    int p,y = f;
    if (y && (from[y] ^ -1) && (from[y] ^ from[x])){
        if ((ww = dd + v[x] + v[y]) < a[id]) a[id] = ww;
        if ((ww = v[y] + dd) < v[x]) v[x] = ww,from[x] = from[y];
    }
    for (p = He[x]; p ; p = Ne[p]) if ((y = To[p]) ^ f) dp2(y,x,id,Dis[p]);
}
void dfs(int x){
    if (son[x]){
        top[son[x]] = top[x],dfs(son[x]);
        for (int p = He[x],y; p ; p = Ne[p]) if (!top[y = To[p]]) top[y] = y,dfs(y);
    }
}
inline int LCA(int x,int y){
    while (top[x] ^ top[y]){ if (dpt1[top[x]] < dpt1[top[y]]) swap(x,y); x = fa[top[x]]; }
    return dpt1[x] <= dpt1[y] ? x : y;
}
inline void Ans(LL ans){ if (ans >= INF) puts("-1"); else writeln(ans); }
int main(){
    int i,s,u,vv,w;
    n = read();
    for (i = 1; i <= n; ++i){
        l[i] = r[i-1] + 1;
        r[i] = l[i] + (s = read()) - 1;
        --s;
        while (s--) u = read() + l[i],vv = read() + l[i],w = read(),add(u,vv,w),add(vv,u,w);
        a[i] = INF;
        dp(l[i],0,i);
        dp2(l[i],0,i,0);
        top[l[i]] = l[i];
        dfs(l[i]);
        pre[i] = pre[i-1] + a[i];
    }
    int q = read(),ql,qu,qr,qv;
    LL ans,ans1;
    a[0] = a[n+1] = INF;
    while (q--){
        ql = read() + 1,qu = read() + l[ql],qr = read() + 1,qv = read() + l[qr];
        if (ql > qr) swap(ql,qr),swap(qu,qv);
        if (ql ^ qr) Ans(qr - ql + v[qu] + v[qv] + pre[qr-1] - pre[ql]);
        else{
            ans = dpt[qu] + dpt[qv] - (dpt[LCA(qu,qv)] << 1);
            if (from[qu] ^ from[qv]){
                ans1 = v[qu] + v[qv] + 2;
                if (ans1 + a[ql-1] < ans) ans = ans1 + a[ql-1];
                if (ans1 + a[ql+1] < ans) ans = ans1 + a[ql+1];
            }
            Ans(ans);
        }
    }
    return 0;
}
```

---

## 作者：rui_er (赞：2)

难倒不难，128MB 的空间限制快恶心死我了。

我们设 $d_{u_0,u_1}$ 表示到节点 $(u_0,u_1)$ 距离最近的叶子的距离，这个可以很容易换根 DP 求出。设 $p_{u_0}$ 表示树 $u_0$ 中距离最近的两个叶子的距离。设 $dis(u_0,u_1,v_0,v_1)$（$u_0=v_0$）表示树中两个节点 $u_1$ 和 $v_1$ 之间的距离。

（一）若 $s_0\ne e_0$，不妨设 $s_0 < e_0$。

显然，在第 $s_0$ 棵树上，从 $(s_0,s_1)$ 花费 $d_{s_0,s_1}$ 的代价走到最近的叶子是最优的。第 $e_0$ 棵树同理。对于 $[s_0+1,e_0-1]$ 范围内的树 $i$，我们会花费 $p_i$ 的代价选择最近的两个叶子经过。在两棵树之间传送时，还会产生 $1$ 的代价。

因此，这种情况的答案为：

$$
ans=d_{s_0,s_1}+\sum\limits_{i=s_0+1}^{e_0-1}p_i+d_{e_0,e_1}+(e_0-s_0)
$$

（二）若 $s_0=e_0$。

容易想到树上两点间距离。但这是错的，还可能从 $s_0$ 走到叶子，传送到相邻的某棵树，经过最近的两个叶子，再传送回来走到 $e_0$。

因此，这种情况的答案为：

$$
ans=\min\{dis(s_0,s_1,e_0,e_1),d_{s_0,s_1}+p_{s_0-1}+d_{e_0,e_1}+2,d_{s_0,s_1}+p_{s_0+1}+d_{e_0,e_1}+2\}
$$

你可能会有疑问：万一离 $(s_0,s_1)$ 和 $(e_0,e_1)$ 最近的叶子是同一个，怎么办呢？容易发现，这种情况下从 $(s_0,s_1)$ 和 $(e_0,e_1)$ 分别走到叶子的路径拼起来已经是 $dis(s_0,s_1,e_0,e_1)$ 了，但还需要经过更多的边，这种情况自然更劣，不会作为 $\min$ 保留。

时间复杂度 $O(\sum m_i+q\log\sum m_i)$。

本题特别卡空间，建议使用树剖 LCA 而不是倍增 LCA，数组能不开 long long 就不要开。

```cpp
// Problem: P3894 [GDOI2014] 传送
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3894
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x, y, z) for(int x = (y); x <= (z); ++x)
#define per(x, y, z) for(int x = (y); x >= (z); --x)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do {freopen(s".in", "r", stdin); freopen(s".out", "w", stdout);} while(false)
#define endl '\n'
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const int N = 3.5e5 + 5, M = 1e6 + 5, inf = 1e9 + 10;
const ll Inf = 2e12;

int n, m[N], q, L[N], R[N], dis[M], fa[M], sz[M], son[M], top[M], val[M], dp1[M], dp2[M];
ll near[N];
vector<tuple<int, int>> e[M];

void dfs1(int u, int f, int id) {
    fa[u] = f;
    sz[u] = 1;
    for(auto [v, w] : e[u]) {
        if(v != f) {
            dis[v] = dis[u] + 1;
            val[v] = val[u] + w;
            dfs1(v, u, id);
            chkmin(near[id], 1LL * dp1[u] + dp1[v] + w);
            chkmin(dp1[u], dp1[v] + w);
            sz[u] += sz[v];
            if(sz[v] > sz[son[u]]) son[u] = v;
        }
    }
    if(!son[u]) dp1[u] = 0;
}

void dfs2(int u, int f, int tp) {
    top[u] = tp;
    if(!son[u]) return;
    for(auto [v, w] : e[u]) {
        if(v != f) {
            dp2[v] = min(dp1[v], dp2[u] + w);
            dfs2(v, u, v == son[u] ? tp : v);
        }
    }
}

int LCA(int u, int v) {
    while(top[u] != top[v]) {
        if(dis[top[u]] < dis[top[v]]) swap(u, v);
        u = fa[top[u]];
    }
    if(dis[u] < dis[v]) swap(u, v);
    return v;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n;
    rep(i, 1, n) {
        cin >> m[i];
        L[i] = R[i - 1] + 1;
        R[i] = L[i] + m[i] - 1;
        rep(j, 1, m[i] - 1) {
            int u, v, w;
            cin >> u >> v >> w;
            e[L[i] + u].emplace_back(L[i] + v, w);
            e[L[i] + v].emplace_back(L[i] + u, w);
        }
        near[i] = Inf;
        rep(j, L[i], R[i]) dp1[j] = inf;
        dis[L[i]] = 1; val[L[i]] = 0;
        dfs1(L[i], 0, i);
        if(near[i] >= inf) near[i] = Inf;
        near[i] += near[i - 1];
        dp2[L[i]] = dp1[L[i]];
        dfs2(L[i], 0, L[i]);
    }
    for(cin >> q; q; --q) {
        int x, u, y, v;
        cin >> x >> u >> y >> v;
        ++x; ++y;
        if(x > y) swap(x, y), swap(u, v);
        u = L[x] + u;
        v = L[y] + v;
        if(x == y) {
            int p = LCA(u, v);
            ll ans = val[u] + val[v] - 2 * val[p];
            if(x > 1 && near[x - 1] - near[x - 2] < Inf) chkmin(ans, dp2[u] + dp2[v] + (near[x - 1] - near[x - 2]) + 2);
            if(x < n && near[x + 1] - near[x] < Inf) chkmin(ans, dp2[u] + dp2[v] + (near[x + 1] - near[x]) + 2);
            cout << ans << endl;
        }
        else {
            ll ans = dp2[u] + (near[y - 1] - near[x]) + dp2[v] + (y - x);
            cout << (ans >= Inf ? -1 : ans) << endl;
        }
    }
    return 0;
}
```

---

## 作者：hegm (赞：1)

### [传送](https://www.luogu.com.cn/problem/P3894)

大氵题。

首先考虑最基础的，我们维护每棵树的距离最近的两个叶子所在的位置。

我们考虑 $dp$，$dp_i$ 表示以 $0$ 为跟的时候，在 $i$ 所在的子树中，距离 $i$ 最近的叶子结点。

注意在转移的时候我们需要顺便求出 $w_k$（$k$ 国家的最近叶子距离）

对于一个点 $i$ 要选出最小和次小的 $dp_j(j\in son_i)$。

$w_k=\min(w_k,dp_{j_1}+dp_{j_2})$。


正常 $dp$ 一遍后，我们可以进行换根 $dp$。

考虑 $0$ 的子节点 $1$。

$dp_1$ 里面存储的是 $1$ 的子树中距离他最近的叶子结点。

那么转移 $0$ 的其他子树的叶子到 $1$ 相信大家都会。

$dp_1=\min(dp_1,dp_0+w(0,1))$

这样就可以转移出来 $1$ 的答案，以此类推，可以求出全树的答案。

现在初始工作都做完了，我们知道了：

1. 用传送门经过某个国家所需要的最小时间（$w_i$）

2. 某个点到距离他最近的叶子节点所需要的最小时间。

对了，我们还需要维护一下 $kl_i$ 表示从这个国家的根到这个城市的距离。

这样我们就可以使用树剖来维护树上两点距离。

### 开始分讨


#### 1. 两个城市不在同一个国家

毫无疑问，我们需要从 $s_0$ 到 $e_0$ 国家（为了方便，保证 $s_0<e_0$）
两个国家间传送的时间为 $que(s_0+1,e_0-1)+(e_0-s_0)$
毫无疑问，为了前往传送门，我们从 $s_0,s_1$ 出发，去的叶子结点为它能到达的最近的，花费 $dp_{s_0,s_1}$。同理，从传送门出来到 $(e_0,e_1)$
花费为 $dp_{e_0,e_1}$。

$que$ 函数使用 ST 表。

$ans=que(s_0+1,e_0-1)+(e_0-s_0)+dp_{(s_0,s_1)}+dp_{(e_0,e_1)}$

#### 2. 两个城市在同一个国家

两种情况，我们直接走国家内部，花费为树上距离。

我们也可以传送到相邻的国家，再传送回来。

但是会出现一个特殊情况，我们的 $s_1$，$e_1$ 的最近传送门一样，但是门不能传送两次。

这种情况不用担心，因为我们要把两种方案取 min，而特殊情况出现时，是严格劣与第一种情况的。

所以我们可以放心大胆的计算。

#### 分讨结束

还有需要注意的是如果你的 $|e_0-s_0|\le1$，那么查询的时候就会出现左端点大于右端点的情况，能特判下就特判，防止出现问题。

还有就是本题的 lca 是卡倍增的，倍增会MLE。

别忘了开 long  long。而且还不能全局开，不然也会 MLE。

我写了个数据生成器，实在找不到错可以对拍。 [here](https://www.luogu.com.cn/discuss/526826)

### $\text{CODE}$

```cpp
#include<bits/stdc++.h>
#define N 1350006
#define M 350005
#define inf 100000000008
#define ll long long
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,rt[M],size[M],ava,from,q,tot,head[N],dep[N],fa[N];
int top[N],siz[N],son[N];
ll w[N-M],dis[N-M]; 
struct tree
{
	int from,to,next,val;
}k[N*2];
ll st[M*3][20],kl[N-M];
void add(int from,int to,int val)
{
	k[++tot].from=from;
	k[tot].to=to;
	k[tot].next=head[from];
	k[tot].val=val;
	head[from]=tot;
}
int ID;
int ln[21];
void dfs(int now,int f)
{ 
	dep[now]=dep[f]+1;
	fa[now]=f;
	siz[now]=1;
	bool vis=0;
	dis[now]=inf;
	for(int i=head[now],to;i;i=k[i].next)
	{
		to=k[i].to;
		if(to==f)continue;vis=1;
		dfs(to,now);
		w[ID]=min(dis[now]+dis[to]+k[i].val,w[ID]);
		dis[now]=min(dis[now],dis[to]+k[i].val);
		siz[now]+=size[to];
		if(siz[son[now]]<siz[to])son[now]=to;
	}
	if(!vis)dis[now]=0;
}
void hg(int now,int f,int w)
{
	dis[now]=min(dis[now],dis[f]+w);
	kl[now]=kl[f]+w;
	for(int i=head[now];i;i=k[i].next)
	{
		if(k[i].to==f)continue;
		hg(k[i].to,now,k[i].val);
	}
}
void pf(int now,int f)
{
	top[now]=f;
	if(son[now])pf(son[now],f);
	for(int i=head[now],to;i;i=k[i].next)
	{
		to=k[i].to;
		if(to==fa[now]||to==son[now])continue;
		pf(to,to);
	}
}
ll que(int l,int r)
{
	if(l>r)return 0;
	ll ans=0;
	for(int i=19;i>=0;i--)
	{
		if(l+ln[i]-1<=r)
		{
			ans+=st[l][i];
			l+=ln[i];
		}
	}
	return ans;
}
ll lca(int a,int b)
{
	ll ans=kl[a]+kl[b];
	while(top[a]!=top[b])
	{
		if(dep[top[a]]<dep[top[b]])swap(a,b);
		a=fa[top[a]];
	}
	if(dep[a]<dep[b])swap(a,b);
	
	ans-=kl[b]*2;
	return ans;
}
int main()
{
	n=read();
	ava=1;
	for(int i=1;i<=n;i++)
	{
		size[i]=read();
		rt[i]=ava;
		for(int j=1,u,v,w;j<size[i];j++)
		{
			u=read()+ava;v=read()+ava;w=read();
			add(u,v,w);
			add(v,u,w);
		}
		ava+=size[i];
	}
	for(int i=1;i<=ava;i++)dis[i]=w[i]=inf;
	for(int i=1;i<=n;i++)
	{
		ID=i; 
		dfs(rt[i],0);
		hg(rt[i],0,inf);
		pf(rt[i],0);
	}
	for(int i=1;i<=n;i++)st[i][0]=w[i];
	ln[0]=1;
	for(int i=1;i<=19;i++)ln[i]=ln[i-1]*2;
	for(int j=1;j<=19;j++)
	{
		for(int i=1;i<=n;i++)
		st[i][j]=st[i][j-1]+st[i+ln[j-1]][j-1];
	}
	q=read();
	int s0,s1,e0,e1;
	ll ans;
	while(q--)
	{
		ans=0;
		s0=read()+1;s1=read();e0=read()+1;e1=read();
		s1=rt[s0]+s1;
		e1=rt[e0]+e1;
		if(s0!=e0)
		{
			if(s0>e0)swap(s0,e0);
			ans+=que(s0+1,e0-1)+(e0-s0);
			ans+=dis[s1]+dis[e1];
		}
		else
		{
			ans=inf;
			if(s0!=1)ans=min(ans,w[s0-1]+dis[s1]+dis[e1]+2ll);
			if(s0!=n)ans=min(ans,w[s0+1]+dis[s1]+dis[e1]+2ll);
			ans=min(ans,lca(s1,e1));
		}
		if(ans>inf)cout<<-1<<"\n";
		else cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：BigJoker (赞：0)

思想简单，但是比较锻炼代码实现能力和细节的题。

设起点为 $(s_0,s_1)$，终点 $(t_0,t_1)$，并且钦定让国家编号尽可能小的在前面。

考虑分类讨论：

* $s_0=t_0$，即两个点在同一个首都。

这种情况的答案第一种是直接树上两点的距离。

另外一种情况就是从起点到隔壁树上的叶子节点再回来，最后到达终点。

两种情况取最小值。

* $s_0\not= t_0$，即两个点在不同的国家，需要穿过中间的国家。

那么这个过程可以分成几个流程：

从起点出发到达当前子树的某个叶子节点，然后从该子节点达到隔壁树的叶子节点，然后如果这棵树是终点，就需要从叶子节点到达终点，否则就要到达另一个叶子节点，接着到达下一棵树。

分析完了上面这个流程，接下来考虑如何处理部分。

对于一种情况，树上两点距离要求两点 $\operatorname{lca}$ 好像可以使用述链剖分，倍增空间好像会 MLE，至于另一种方法，可以先预处理每个点到最近的叶子节点距离。求这个东西需要 dfs 两次，一次找自己的子节点，另一次找自己的父节点，因为有可能最近的子节点并不在自己的子树上。然后计算到隔壁子树回来加上传送门的代价即可。

另外一种情况，如果每次都直接遍历，一次复杂度可以到达 $\Theta(n)$ 所以考虑使用前缀和，从一棵树转移到另一棵树可以看作：是求解一棵树最近的两个叶子节点的距离。可以使用 dfs 实现。

另外还需要判断无解的情况，相当于整棵树是一条链，只有一个叶子节点，也用前缀和即可。

```cpp
#include<bits/stdc++.h>
#define mem(a,x) memset(a,x,sizeof(a))
#define re register
#define il inline
using namespace std;
typedef pair<int,int>PII;
const int N=1e6+5;
const int M=3.5e5+5;
int n,q;
int idx,m[M],ltop[N],sz[N],son[N],dep[N],p[N],tag[M],rt[M];
int dis[N],fdis[N],f[N];
vector<PII>g[N];
vector<int>vis[M];
il int dfs1(int u,int fa){
	p[u]=fa;
	if(~fa) dep[u]=dep[fa]+1;
	else dep[u]=1;
	sz[u]=1;
	if(g[u].size()==1 && ~fa){
		dis[u]=0;
		return 1e9;
	}
	int fn=1e9,fnn=1e9,ans=1e9;
	for(auto v:g[u])
		if(v.first!=fa) fdis[v.first]=fdis[u]+v.second,ans=min(ans,dfs1(v.first,u)),sz[u]+=sz[v.first],dis[u]=min(dis[u],dis[v.first]+v.second);
	for(auto v:g[u]){
		if(v.first==fa) continue;
		if(son[u]==-1) son[u]=v.first;
		else if(sz[v.first]>son[u]) son[u]=v.first;
	}
	for(auto v:g[u]){
		if(v.first!=fa){
			if(v.second+dis[v.first]<fn) fnn=fn,fn=v.second+dis[v.first];
			else if(v.second+dis[v.first]<fnn) fnn=v.second+dis[v.first];
		}
	}
	return min(ans,fn+fnn);
}
il void dfs2(int u,int top){
	ltop[u]=top;
	if(~son[u]) dfs2(son[u],top);
	for(auto v:g[u])
		if(son[u]!=v.first && p[u]!=v.first) dfs2(v.first,v.first);
}
il void dfs3(int u){
	for(auto v:g[u])
		if(p[u]!=v.first) dis[v.first]=min(dis[v.first],dis[u]+v.second),dfs3(v.first);
}
il int lca(int u,int v){
	int ans=fdis[u]+fdis[v];
	while(ltop[u]!=ltop[v]){
		if(dep[ltop[u]]<dep[ltop[v]]) swap(u,v);
		u=p[ltop[u]];
	}
	return ans-2*fdis[dep[u]<dep[v]?u:v];
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	mem(dis,0x3f3f3f3f),mem(son,-1);
	for(re int _=1;_<=n;_++){
		cin>>m[_];
		for(re int i=0;i<m[_];i++)
			vis[_].push_back(-1);
		for(re int i=1,u,v,w;i<m[_];i++){
			cin>>u>>v>>w;
			if(vis[_][u]==-1) vis[_][u]=idx++;
			if(vis[_][v]==-1) vis[_][v]=idx++;
			u=vis[_][u],v=vis[_][v],g[u].push_back(PII(v,w)),g[v].push_back(PII(u,w));
		}
		rt[_]=vis[_][0];
		int now=dfs1(rt[_],-1);
		dfs2(rt[_],rt[_]),dfs3(rt[_]);
		tag[_]=tag[_-1],f[_]=f[_-1];
		if(now==1e9) tag[_]++;
		else f[_]+=now;
	}
	cin>>q;
	while(q--){
		int s0,s1,e0,e1;
		cin>>s0>>s1>>e0>>e1;
		if(s0>e0) swap(s0,e0),swap(s1,e1);
		s0++,e0++,s1=vis[s0][s1],e1=vis[e0][e1];
		if(s0==e0){
			int x1=lca(s1,e1),x2=1e9;
			if(s1==e1){
				cout<<0<<'\n';
				continue;
			}
			if(f[s0+1]-f[s0] && s0<n) x2=min(x2,f[s0+1]-f[s0]+dis[s1]+dis[e1]);
			if(s0>1 && f[s0-1]-f[s0-2]) x2=min(x2,f[s0-1]-f[s0-2]+dis[s1]+dis[e1]);
			cout<<min(x1,x2+2)<<'\n';
		}
		else if(tag[e0-1]-tag[s0]) cout<<-1<<'\n';
		else cout<<dis[s1]+dis[e1]+f[e0-1]-f[s0]+e0-s0<<'\n';
	}
	return 0;
}
```

---

## 作者：Jeefy (赞：0)

# P3894 [GDOI2014] 传送 题解

> 不会吧，不会吧，不会真的有人不会第一步的 DP 吧！
> 
> ~~首先排除我自己。~~
>
> 所以这里更细节的讲一下第一步 DP 怎么做。

在一个子树内，第一次遍历求出，从下到上当前结点最近的叶子结点的距离 $dis_x$

。在第二次遍历，在从上到下利用 $dis_x + w(x, y), y \in Son(x)$ 再更新子节点的距离。

如何考虑树内两个叶子结点的最近？

在第一次遍历的时候利用没有父结点更新过的 $dis_x$ 找树内最近叶节点距离 $tdis_i$。

假设当前结点为 $x$，遍历到子节点 $y$，先用 $dis_x + dis_y + w(x, y)$ 更新 $tdis_i$，然后再利用 $dis_y + w(x, y)$ 更新 $dis_x$。

然后遍历的时候，顺便求一下 $drt_x$，即从当前结点到根的距离。

这样需要的数据就搞定了。

---------

然后就是两种分类讨论了。

- 不在同一棵树内……很简单。

- 在同一棵树内：
  
  - 走树内：$drt_x + drt_y - 2 \times drt_{lca}$。
  
  - 通过最近的叶节点去邻国，然后再回来：$dis_x + dis_y + 1 + tdis_{i \pm 1}$。

更细节的其他大佬的题解都讲了，我就不过多展开了。

TLDR，上代码：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
const int N = 1e6 + 7, INF = (int)2e9;
typedef long long lint;

int n;
int root[N];

struct Edge {
	int to, w;
};
std::vector<Edge> G[N];
inline void add(int u, int v, int t) {
	G[u].push_back({v, t});
}

int siz[N], dep[N], son[N], top[N], fa[N];
lint dis[N];
lint trDis[N], trPre[N], tid;
void workCD(int x, int f) {
	fa[x] = f;
	top[x] = son[x] = -1;
	dep[x] = (~f ? dep[f] : 0) + 1 + (siz[x] = 1);
	dis[x] = INF;

	int kids = 0;
	for (Edge e : G[x]) {
		if (e.to == f) continue;
		++kids, workCD(e.to, x);
		siz[x] += siz[e.to];

		if (trDis[tid] > dis[x] + dis[e.to] + e.w)
			trDis[tid] = dis[x] + dis[e.to] + e.w;

		if (dis[x] > dis[e.to] + e.w)
			dis[x] = dis[e.to] + e.w;

		if (siz[son[x]] < siz[e.to])
			son[x] = e.to;
	}

	if (kids == 0)
		dis[x] = 0;
}

lint drt[N];
void workTP(int x, int t) {
	top[x] = t;

	for (auto e : G[x]) {
		if (e.to == fa[x]) continue;
		drt[e.to] = drt[x] + e.w;
		
		if (dis[e.to] > dis[x] + e.w)
			dis[e.to] = dis[x] + e.w;

		if (e.to != son[x]) workTP(e.to, e.to);
		else workTP(e.to, t);
	}
}

int getLCA(int x, int y) {
	while (top[x] ^ top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		x = fa[top[x]];
	}
	return dep[x] < dep[y] ? x : y;
}

inline lint getDis(int x, int y) {
	int lca = getLCA(x, y);
	return drt[x] + drt[y] - drt[lca] * 2;
}

#define trSum(l, r) (trPre[r] - ((l) ? trPre[(l) - 1] : 0))
void build() {
	for (tid = 0; tid < n; ++tid) {
		trDis[tid] = INF;
		workCD(root[tid], -1);
		workTP(root[tid], root[tid]);
		trPre[tid] = (tid ? trPre[tid - 1] : 0) + trDis[tid];
	}
}

void read() {
	cin >> n;

	int cur = 0, siz;
	for (int i = 0; i < n; ++i) {
		cin >> siz;
		
		root[i] = cur;

		for (int u, v, t, j = 1; j < siz; ++j) {
			cin >> u >> v >> t;
			u += cur, v += cur;
			add(u, v, t), add(v, u, t);
		} 

		cur += siz;
	}
}

void answer() {
	int q; cin >> q;
	int tmp[2][2];
	for (int *fr = tmp[0], *to = tmp[1], i = 0; i < q; ++i) {
		cin >> fr[0] >> fr[1] >> to[0] >> to[1];
		if (fr[0] > to[0]) swap(fr, to);

		lint d = INF;
		int x = root[fr[0]] + fr[1], y = root[to[0]] + to[1];
		if (fr[0] ^ to[0]) {
			// 不在同一个子树内。
			d = dis[x] + dis[y] + trSum(fr[0] + 1, to[0] - 1) + to[0] - fr[0];
		} else {
			// 在同一个国家里面
			if (fr[0] != 0)
				d = min(d, dis[x] + dis[y] + 2 + trDis[fr[0] - 1]);
			if (fr[0] + 1 < n)
				d = min(d, dis[x] + dis[y] + 2 + trDis[fr[0] + 1]);
			d = min(d, getDis(x, y));
		}

		cout << (d >= INF ? -1 : d) << '\n';
	}
}

int main(void) {
	cin.tie(0)->sync_with_stdio(false);
	read();
	build();
	answer();
	return 0;
}
```




---


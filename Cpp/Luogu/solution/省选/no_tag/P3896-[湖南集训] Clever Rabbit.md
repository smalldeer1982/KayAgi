# [湖南集训] Clever Rabbit

## 题目描述

聪明的兔子定义了三个函数:

- $g(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位降序排列组成的数字。

- $l(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位升序排列组成的数字。

- $f(x)=g(x)-l(x)$。

如果一个数 $x$ 与 $f(x)$ 相等，兔子们称它为幸运数。现在兔子们希望计算在所有的 $n$ 位数字中，所有幸运数的平方的和。结果对 $p$ 取模后输出，注意这里数字可以包含前导 $0$。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的测试数据，保证 $1\leq n\leq 10$。
- 对于 $100\%$ 的测试数据，保证 $1\leq n\leq 30$，$1\leq p\leq 2\times 10^9$。

## 样例 #1

### 输入

```
4 10000
```

### 输出

```
8276```

# 题解

## 作者：muller (赞：6)

这题好像没有什么难度

考虑高精度+矩阵乘法可以得出所有结果

但是我们发现复杂度是实现时限的10倍左右吧

那怎么办呢

所以我们可以直接打出一张表

就是所有结果的表

然后分情况依据位数不断累加

然后取模

给代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const string ans[30] = {
"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"5205420000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"6728118300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"1274525651070000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"7310330478107153100000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"9409915628571684501000000000000000000000000000000000000000000000000000000000000000000000000000000000",
"8356658699026214374320000000000000000000000000000000000000000000000000000000000000000000000000000000",
"4207478918227656840747000000000000000000000000000000000000000000000000000000000000000000000000000000",
"4658496829792060429255563000000000000000000000000000000000000000000000000000000000000000000000000000",
"4207037896872256856796074700000000000000000000000000000000000000000000000000000000000000000000000000",
"1837202944781138598433025203500000000000000000000000000000000000000000000000000000000000000000000000",
"9405629592787115276209767075501000000000000000000000000000000000000000000000000000000000000000000000",
"3871575438778206368306960563089270000000000000000000000000000000000000000000000000000000000000000000",
"5457901232352028026825349529235227100000000000000000000000000000000000000000000000000000000000000000",
"4513218532109379109259170998447632930100000000000000000000000000000000000000000000000000000000000000",
"6471730057670894088987559819623556002720000000000000000000000000000000000000000000000000000000000000",
"2797168835289124286487787462067213786930310000000000000000000000000000000000000000000000000000000000",
"2771731023505047486049501778805691950648204000000000000000000000000000000000000000000000000000000000",
"5732074351329883434271916845658127944983253061000000000000000000000000000000000000000000000000000000",
"3553290435639296282926099426642422443260257564600000000000000000000000000000000000000000000000000000",
"3044052405585945199366406088614915076346365343439100000000000000000000000000000000000000000000000000",
"1746302984497548302405625795120522934215199862039670000000000000000000000000000000000000000000000000",
"3455789784904911219785370351674968020401966054354869320000000000000000000000000000000000000000000000",
"2401446323835665869533642508189259066894773732002511970100000000000000000000000000000000000000000000",
"8412147772073441386461294986064076822499815831191636716982000000000000000000000000000000000000000000",
"0451347111866863143074007949705031757877526107129750881854310000000000000000000000000000000000000000",
"8716368647076347425212341128211018724039913458254613506379624300000000000000000000000000000000000000"};
int n, p, ansp = 0;
int main() {
    int i;
    scanf("%d%d", &n, &p);
    for (i = 99; ~i; --i) ansp = ((ll)ansp * 10 + ans[n - 1][i] - '0') % p;
    printf("%d\n", ansp);
    return 0;
}
```


---

## 作者：ix35 (赞：2)

写一篇正经的非打表题解。

首先，将 $g(x)$ 和 $l(x)$ 按十进制位来看，应该正好是反序的，即 $g(x,i)=l(x,n-i+1)$。

先不考虑进位的事情，我们规定减法就是对应位相减，那么显然 $f(x,i)=-f(x,n-i+1)$（上面结论的简单推论）。

于是我们只需要搜索 $f(x)$ 的一半，直接就可以得到另一半了，然后进行检验即可。

这样可以直接将复杂度降低一半，本机跑得很慢但是能过。

核心程序：

```cpp
bool cmp1 (int a,int b) {return a>b;}
bool cmp2 (int a,int b) {return a<b;}
void dfs (int x,int d) {
	if (x<=(n+1)/2) {
		for (int j=d;j>=0;j--) {
			ord[x]=j;
			dfs(x+1,j);
		}
	} else {
		for (int j=n;j>=(n+3)/2;j--) {ord[j]=-ord[n-j+1];}
		for (int j=n;j>=1;j--) {
			if (ord[j]<0) {
				ord[j]+=10,ord[j-1]--;
			}
			a[j]=b[j]=ord[j],c[j]=0;
		}
		sort(a+1,a+n+1,cmp1);
		sort(b+1,b+n+1,cmp2);
		int flg=0;
		for (int j=n;j>=1;j--) {
			c[j]+=a[j]-b[j];
			if (c[j]<0) {c[j]+=10,c[j-1]--;}
			if (c[j]!=ord[j]) {flg=1;break;}
		}
		if (!flg) {
			int tmp=0,pd=1;
			for (int j=n;j>=1;j--) {
				tmp=(tmp+(1ll*pd*ord[j])%p)%p;
				pd=(1ll*pd*10)%p;
			}
			ans=(ans+(1ll*tmp*tmp)%p)%p;
		}
	}
	return;
}
```


---

## 作者：littlez_meow (赞：1)

你将在本题解看到为什么本题取模仍然能打表以及打表程序为什么这么快。

[题目指路](https://www.luogu.com.cn/problem/P3896)。

## 思路

首先发现 $n\le30$，假如所有数都是幸运数，答案也仅仅能达到 $10^{90}$。我们可以直接写 $90$ 位的高精度而不是取模。这为打表打下了基础。

考虑题目中 $g(x)$ 和 $l(x)$ 的定义，我们发现，如果两个数各个数位上数字组成的集合相同，则 $f(x)$ 的值也是相同的。

因此我们可以直接枚举集合。根据集合的无序性，我们可以将这个集合理解成一个不降的序列，值域为 $[0,9]$。

换句话说，其可以与 $1$ 行 $n$ 列的半标准杨表形成双射。根据半标准杨表的钩长公式，可以得到集合的个数为 $\prod\limits_{i=1}^n\dfrac{10+i}{n-i+1}=\dbinom{n+10}{10}$。

当 $n=30$ 时，其值约为 $8.5\times 10^8$，再加上高精度 $O(n^2)$ 的消耗，最多最多不超过 $900$ 秒。

事实上，开了 O2 后，仅需 $11$ 秒即可跑出答案。

关于最后的实现，可以写一个类似快读的东西，边读入边取模。

## 代码

给出打表程序。

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define fir first
#define sec second
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
using namespace std;
int n,p;
int num[31],cnt[11];
int a[32],b[32];
inline bool check(){
	memset(cnt,0,sizeof(cnt));
	F(i,1,n) a[i]=num[i],b[i]=num[n-i+1],++cnt[num[i]];
	F(i,1,n){
		a[i]-=b[i],a[i]<0&&(a[i]+=10,--a[i+1]),--cnt[a[i]];
		if(cnt[a[i]]<0) return 0;
	}
	return 1;
}
int ans[101],res[61],len;
inline void upd(){
	memset(res,0,sizeof(int)*(n<<1|1));
	F(i,0,n-1) F(j,0,n-1){
		res[i+j+1]+=a[i+1]*a[j+1];
		res[i+j+2]+=res[i+j+1]/10;
		res[i+j+1]%=10;
	}
	F(i,1,len) ans[i]+=res[i],ans[i]>=10&&(ans[i]-=10,++ans[i+1]);
	ans[len+1]&&(++len);
	return;
}
void dfs(int step,int mn){
	if(step==n+1){
		if(check()) upd();
		return;
	}
	F(i,mn,9){
		num[step]=i;
		dfs(step+1,i);
	}
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	len=n<<1;
	dfs(1,0);
	R(i,100,1) cout<<ans[i];
	return 0;	
}
```

给出输出实现

```cpp
cin>>n>>p;
F(i,0,ans[n].length()-1) res=(res*10+ans[n][i]-'0')%p;
cout<<res;
```

完结撒花，不喜勿喷 qwq~

---

## 作者：Arknights_Thorns (赞：1)

### 这题的核心条件

对于 $100\%$ 的数据，保证 $1≤n≤30$，$1≤p≤2 \times 10^9$。

作为一个成熟的 oier，你应该对数据范围非常敏感了（学会打表了）（bushi

先解释一下题意：对于任意一个数 $x$，都有对应的 $g(x)$、$l(x)$、$f(x)$，这个不难理解，就是把 x 逐位拆开，然后重新排序组成新数，比如 $495$，$g(495)=954$，$l(495)=459$，$f(495)=g(495)-l(495)=954-459=495$，因为 $f(495)=495$，所以 $495$ 是幸运数。

因此，逃（da）课（biao）程序就有了:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 39;
int l[N], a[N], b[N], c[N], num[19];

inline void chk(int n, int p)
// 用高精度验证 f，当然你也可以试试__int128
{
    memset(num, 0, sizeof(num));
    for (int i = p + 1; i <= n; ++ i) l[i] = 0;
    for (int i = 1; i <= n; ++ i)
        b[i] = a[n - i + 1] = l[i], ++ num[b[i]];
    bool f = false;
    for (int i = 1; i <= n; ++ i)
	{
        c[i] = a[i] - b[i];
        if (c[i] < 0) c[i] += 10, -- a[i + 1];
        -- num[c[i]];
		if (c[i]) f = true;
    }
    if (!f) return;
	for (int i = 0; i <= 9; ++ i)
		if (num[i])
			return;
	cout << '"';
    for (int i = n; i; -- i)
        cout << c[i];
    cout << '"' << ',' << endl;
}
inline void dfs(int x, int p, int n)
{
	if (!x)
		return chk(n, p);
	for (int i = p; i <= n; ++ i)
	{
		for (int j = p + 1; j <= i; ++ j)
			l[j] = x;
		dfs(x - 1, i, n);
	}
}
int main()
{
    freopen("db.out", "w", stdout);
    for (int i = 1; i <= 30; ++ i)
        dfs(9, 0, i);
    return 0;
}
```
然后你会发现大概 $6$ 分钟之后就有结果了，这个时候开个 char 数组直接把已经按格式输出的表复制到程序里头，剩下的部分直接暴力做就好了

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
char s[245][35] = {
// 此处省略打表结果
}
ll n, p, ans, l;

int main()
{
    cin >> n >> p;
    while (strlen(s[l]) < n) ++ l;
    while (strlen(s[l]) == n)
	{
       	ll x = 0;
        for (int i = 0; i < n; ++ i)
            x = (x * 10 % p + s[l][i] - '0') % p;
        ans = (ans + (x * x) % p) % p;
        ++ l;
    }
    cout << ans;
	return 0;
}
```
虽然这样能过这题，但还是建议看一下 dfs 的正解写法。

---


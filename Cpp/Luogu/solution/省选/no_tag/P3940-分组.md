# 分组

## 题目背景

大样例可在页面底部「附件」中下载。


## 题目描述

小 C 在了解了她所需要的信息之后，让兔子们调整到了恰当的位置。小 C 准备给兔子 们分成若干个小组来喂恰当的胡萝卜给兔子们吃。

此时， $n$ 只兔子按一定顺序排成一排，第 $i$ 只兔子的颜色是 $a_i$ 。由于顺序已经是被 调整好了的，所以每个小组都应当是序列上连续的一段。

在分组前，小 C 发现了一个规律：有些兔子会两两发生矛盾。并且，两只兔子会发生矛 盾，当且仅当代表他们的颜色的数值之和为一个正整数的平方。比如，1 色兔子和 2 色兔子 不会发生矛盾，因为 3 不是任何一个正整数的平方；而 1 色兔子却会和 3 色兔子发生矛盾， 因为 $4 = 2^2$。

小 C 认为，只要一个小组内的矛盾不要过大就行。因此，小 C 定义了一个小组的矛盾 值 $k$ ，表示在这个小组里，至少需要将这个组再一次分成 $k$ 个小团体；每个小团体并不需 要是序列上连续的一段，但是需要使得每个小团体内任意两只兔子之间都不会发生矛盾。

小 C 要求，矛盾值最大的小组的矛盾值 $k$ 不超过 $K$ 就可以了。当然，这样的分组方 法可能会有很多个；为了使得分组变得更加和谐，小 C 想知道，在保证分组数量最少的情况 下，字典序最小的方案是什么。你能帮帮她吗？

字典序最小的方案是指，按顺序排列分组的间隔位置，即所有存在兔子 $i$ 和 $i + 1$ 在 不同组的位置 $i$，和其它所有相同分组组数相同的可行方案相比总有第一个不同的位置比其 它方案小的方案。


## 说明/提示

【样例 1 解释】

如果将五只兔子全部分到同一个小组的话，那么 (1, 3) (3, 6) (6, 10) (10, 15) (1, 15) 均 不能分到同一个小团体；因为最多分成两个小团体，所以为了满足前 4 对限制，只能分为 {{1, 6, 15}, {3, 10}}，但此时不满足 (1, 15) ，所以不存在一种组数为 1 的方案满足全部限制。


如果将五只兔子分为两个小组的话，一种字典序最小的可行的分组方案是 {1}, {3, 15, 10, 6}，此时第二组内的小团体数量不超过 2 的一种分法是 {{3, 10}, {15, 6}}。

【数据范围】

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

每个测试点的数据规模及特点如下表：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9809.png) 

特殊性质 1：保证最优分组方案唯一。

特殊性质 2：保证不会有两只相同颜色的兔子。


## 样例 #1

### 输入

```
5 2 
1 3 15 10 6```

### 输出

```
2
1 ```

# 题解

## 作者：zero4338 (赞：13)

## Solution
对于字典序最小 , 从后往前扫即可满足 .  
对于查询冲突 , 通过枚举完全平方数解决 .  
$K=1$ 时 , 出现冲突时新分一组即可 .  
$K=2$ 时 , 通过拓展域并查集来判断 .  
我们把一个数拆成两个点 , 分别为黑点和白点 , 对于冲突的点 , 将它们的黑白点两两相连 , 注意特判 $2a_ i=x^2$ 的情况  
时间复杂度 $O(n\sqrt a)$  
## Code
```cpp


#include<iostream>
#include<cstdio>
#include<cmath>
#include<unordered_map>
using namespace std;
int read()
{
	int ret=0;char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
	return ret;
}
const int maxn=131073; 
int n,k;
int a[maxn],maxa;
int pown[550],exi[maxn];
bool s[maxn];int use=1;
bool judge(int x){int rt=sqrt(x);return (rt*rt)==x;}
struct dsu
{
    int fa[maxn<<1];
    void prework(){for(int i=1;i<2*maxn;i++)fa[i]=i;}
    int get(int x)
    {
        if(x==fa[x])return fa[x];
        return fa[x]=get(fa[x]);
    }
    void merge(int x,int y){fa[get(x)]=get(y);}
}d;
void end(int x)
{
    use++;s[x]=1;
    int now=x+1;
    while(!s[now]&&now<=n)
    {
        d.fa[a[now]]=a[now];
        d.fa[a[now]+maxn]=a[now]+maxn;
        exi[a[now++]]=0;
    }
    d.fa[a[now]]=a[now];
    d.fa[a[now]+maxn]=a[now]+maxn;
    exi[a[now]]=0;
    d.fa[a[x]]=a[x];
    d.fa[a[x]+maxn]=a[x]+maxn;
    exi[a[x]]=1;
}
unordered_map<int,int>exi1;
int main()
{
    n=read();k=read();
    for(int i=1;i<=n;i++)maxa=max(maxa,a[i]=read());
    d.prework();
    maxa=ceil(sqrt(2*maxa));
    for(int i=1;i<=maxa;i++)pown[i]=i*i;
    if(k==1)
    {
        for(int i=n;i>=1;i--)
        {
            bool flag=0;
            for(int j=1;j<=maxa;j++)
            {
                if(exi1.find(pown[j]-a[i])!=exi1.end()){flag=1;break;}
            }
            if(flag){use++;s[i]=1;exi1.clear();}        
            exi1[a[i]]++;
        }
    }
    else if(k==2)
    {
        for(int i=n;i>=1;i--)
        {
            if(judge(2*a[i])&&exi[a[i]])
            {
                if(exi[a[i]]==2)end(i);
                else if(exi[a[i]]==1)
                {                
                    bool flag=0;
                    for(int j=maxa;j>=1;j--)
                    {
                        if(pown[j]-a[i]==a[i])continue;
                        if(pown[j]-a[i]<=0)break;
                        if(pown[j]-a[i]>=maxn)continue;
                        if(exi[pown[j]-a[i]]){flag=1;break;}
                    }
                    if(!flag)exi[a[i]]++;
                    else end(i);
                }
               continue;
            }
            if(exi[a[i]]){exi[a[i]]++;continue;}
            for(int j=maxa;j>=1;j--)
            {
                if(pown[j]-a[i]<=0)break;
                if(pown[j]-a[i]>=maxn)continue;
                if(exi[pown[j]-a[i]])
                {
                    d.merge(a[i],pown[j]-a[i]+maxn);
                    d.merge(a[i]+maxn,pown[j]-a[i]);
                    if(d.get(a[i])==d.get(a[i]+maxn))break;
                }
                if(exi[pown[j]-a[i]]==2&&judge(2*(pown[j]-a[i]))){d.merge(a[i],a[i]+maxn);break;}
            }
            if(d.get(a[i])==d.get(a[i]+maxn))end(i);
            else exi[a[i]]++;
        }
    }
    printf("%d\n",use);
    for(int i=1;i<n;i++){if(s[i])printf("%d ",i);}
    printf("\n");
    return 0;
}

```


---

## 作者：Varuxn (赞：11)

> [推销](https://www.cnblogs.com/Varuxn/p/14919311.html)

# 解题思路
参考了题解区一篇思路非常好的[题解](https://www.luogu.com.cn/blog/_post/311461)，在这里讲一下自己的见解。

首先明确一下 K 的取值只有 1 或者 2 这里看**数据范围**非常重要！，对于 $K=1$，$K=2$ 的情况要分开来做。
## K=1
对于 $K=1$ 的情况，为了保证字典序最小，我们需要倒着枚举序列了。

然后再次观察**数据范围**，发现$131072 \times2=512^2$，因此我们可以枚举 $1 \sim 512$ ，令 vis[i] 表示在当前扫到的组里颜色为 i 的是否存在，查看是否访问过 $x^2-s_i$ 。

* 如果访问过，表示和第 i 只兔子发生矛盾的已经在这个组里了，因此需要再次分一个组，并且记录下分组的边界，清空 vis 数组。

* 如果没有访问过，把该种颜色的标记成 true 记录就好了。

## K=2
几乎同样的思路，我们仍然需要倒着枚举序列。

对于同一组的兔子，状态之可能有两种：同一小团体或者在敌对小团体，因此我们用**并查集**维护。

* $\operatorname{find}(1 \sim n)$ 表示 $1\sim n$的兔子所在的小团体。

* $\operatorname{find}(n+1 \sim 2 \times n)$ 表示 $1\sim n$的兔子所在的小团体的敌对小团体。

然后开一个 vector 数组记录同一颜色的序号，然后分别对于发生矛盾的兔子进行判断，同时更新该兔子所在组以及小团体和敌对小团体。

同样的，如果矛盾无法避免，那就重新开一个组，并清空标记，记录分割点就好了。

* 注意：并查集合并时要在 **find** 的基础上更新

# code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=131080;
int n,m,K,las,s[M],fa[M<<1];
vector<int> ans,v[M<<1];
bool vis[M];
int find(int x)
{
	if(fa[x]==x)
		return x;
	return fa[x]=find(fa[x]);
}
void work_1()
{
	for(int i=n;i>=1;i--)
	{
		bool flag=true;
		for(int j=1;j<=512;j++)
			if(j*j>=s[i])
				if(vis[j*j-s[i]])
				{
					flag=false;
					break;
				}
		if(!flag)
		{
			for(int j=i+1;j<las;j++)
				vis[s[j]]=false;
			ans.push_back(i);
			las=i+1;
		}
		vis[s[i]]=true;
	}
	printf("%d\n",ans.size()+1);
	for(int i=ans.size()-1;i>=0;i--)
		printf("%d ",ans[i]);
}
int update(int l,int r)
{
	for(int i=l+1;i<r;i++)
		vector <int>().swap(v[s[i]]);
	ans.push_back(l);
	return l+1;
}
void work_2()
{
	for(int i=1;i<=(n<<1);i++)
		fa[i]=i;
	for(int i=n;i>=1;i--)
	{
		for(int j=1;j<=512;j++)
			if(j*j>=s[i])
				if(v[j*j-s[i]].size())
					for(int k=0;k<v[j*j-s[i]].size();k++)
					{
						int temp=v[j*j-s[i]][k];
						if(find(temp)==find(i))
						{
							las=update(i,las);
							break;
						}
						else
						{
							fa[find(i+n)]=find(temp);
							fa[find(temp+n)]=find(i);
						}
					}
		v[s[i]].push_back(i);
	}
	printf("%d\n",ans.size()+1);
	for(int i=ans.size()-1;i>=0;i--)
		printf("%d ",ans[i]);
}
int main()
{
	scanf("%d%d",&n,&K);
	las=n+1;
	for(int i=1;i<=n;i++)
		scanf("%d",&s[i]);
	if(K==1)
		work_1();
	else
		work_2();
	return 0;
}
```

---

## 作者：狛枝凪斗 (赞：7)

（考试的时候勤勤恳恳【一边摸鱼一边】骗分。首先是对于直接输出1的那一个点不加赘述，然后考虑k=1并且答案唯一的点好像扫一下就能得到答案。对于k=1或k=2，并且ai<=2的情况好像记录一下2的个数也能骗到分。

于是码了一下，最后骗到24分。）

题解：

基本上是std的思路，细节处理稍微有点不一样，然后再详细说一下正解。

正解分成k=1和k=2来分别考虑。显然对于这两种情况，所用的做法是不一样的。

对于k=1，分组所要满足的条件是任意一组中元素之间没有互相冲突，即相加为平方数的。那么每一次分组，我们可以考虑当前元素和上一个分组点之后的所有元素是否产生冲突，如果冲突就考虑进行分组。那么显然扫一遍之前的元素就能判断是否冲突。

但是n有1e5+的级别…最坏的可能性这一扫就要爆炸。那么有什么快速判断当前元素是否合法的方式吗？发现如果我们只用考虑当前元素是否合法，那么前面的元素完全可以只记录值而不记录位置。判断两个数相加是否为一个平方数，可以循环每个数，当然也可以只记录值而循环平方数。

ai的上限其实是一个提示。131072*2=262144=512²。我们只需要枚举1-512，判断枚举到的数的平方减去当前元素，所得到的值是否出现过，就可以判断是否合法。

但是上面这几句都建立在我们只用考虑当前元素是否合法这一前提下。实际上，还有一个重要的限制——字典序。如果从前往后枚举，我们需要记录与当前元素冲突的值的位置，因为把这个位置作为分组点显然比把当前元素的前一位作为分组点要优。举个栗子，对于序列1,2,3，在1和2之间分组显然比在2和3之间分组要优，但是这两种分组都合法。

那么我们能不能让判断产生了冲突的位置成为答案呢——把序列倒过来枚举就可以了。

官方题解也给出了说法，倒过来枚举的冲突点，也就是正序中可能的最靠前的分界点位置，一定更优。因为分界点如果靠后，不仅对于这个分组操作来说不优，并且对于上一个组，它的段长变大，段内产生冲突的可能性变大，分组变多的可能性也随之上升。

于是最后k=1的做法就是，倒过来枚举序列并判断当前元素是否与之前产生冲突，记录冲突点。注意一个一个清空记录存在过的值的vis数组，如果直接memset会增加不必要的复杂度。

对于k=2的情况，思路就要更为复杂一点。首先继承k=1的思路中总体上的倒叙枚举以及枚举平方数的思路。

很显然的是，对于每个分组中的元素，如果根据冲突关系把它们黑白染色，那么只要分组中的元素能组成一张二分图，这个分组就是合法的。根据这一点，枚举序列的时候每次暴力判断二分图其实就是一种高分做法，并且似乎是可以通过全部数据的…

而正常去考虑，每次都跑一次二分图的复杂度显然过高。我们依旧需要能快速判断当前元素是否合法的方法。发现对于交错复杂的敌对关系，即冲突，我们似乎在哪里见到过。

P1525关押罪犯。这道题里我们用并查集的扩展域或者带权并查集维护了交织的敌对关系，并最后判断哪一组不得不产生冲突。这与这道题现在考虑到的这一部分很相似。

其实没有做过这道题也能考虑到并查集，毕竟我们要维护一堆冲突关系，并且判断什么时候不能再把冲突的两个数字分别放在两组中，而是无论怎么放都会产生冲突。

想到这里，尝试用并查集来处理这道题。和关押罪犯一样开一个扩展域，并查集中1-maxx【最大数值】为1-maxx本身的集合，而maxx+1-maxx*2是1-maxx的敌人集合。扫到一个元素，并判断之前有冲突的数值出现的时候，就查看两者并查集维护的信息。如果两个数值本身不在一个集合里，那么它们就能被分别放在两组中。然后维护敌对关系，让两者的敌人域分别和对方的本域合并在一起。

但是还有需要特殊考虑的情况！我们并查集维护的是每一个数值的信息，而序列中如果出现了同样的数值，不可能再把一个并查集分裂出去也没法维护信息。仔细想想，两个相等的数值只要不会相加产生一个平方数，那么它们就可以分在同一组中，毫无影响。于是对于有相同元素出现的时候，判断它的二倍是不是平方数，如果是的话，再考虑能不能分在同一组。两个这样的相同元素能分在同一组的条件是，它们出现且仅出现两次，没有其它敌对元素。如果有其它敌对元素，那么这三个元素一定不能安定地分成两组。于是对相同元素进行特判处理。

最后清空等操作和k=1时是差不多的。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,maxx;
int a[150010],vis[150010],flag,lst,tag[300010],fa[300010];
int ans[150010],sum;
int get(int x){
	if(fa[x]==x)return x;
	else return fa[x]=get(fa[x]);
}
void solve1(){
	for(int i=n;i>=1;i--){
		flag=0;
		for(int j=1;j<=512;j++){
			if(j*j<=a[i])continue;
			if(j*j-a[i]>maxx)break;
			if(vis[j*j-a[i]]){
				flag=1;
				break;
			}
		}
		if(flag){
			ans[++sum]=i;
			for(int j=i+1;j<=lst;j++){
				vis[a[j]]=0;
			}
			lst=i;	
		}
		vis[a[i]]=1;
	}
}
void solve2(){
	for(int i=1;i<=maxx;i++)fa[i]=i,fa[i+maxx]=i+maxx;
	for(int i=1;i*i<=maxx*2;i++)tag[i*i]=1;
	for(int i=n;i>=1;i--){
		flag=0;
		if(vis[a[i]]){
			if(tag[a[i]*2]){//同样的数字出现了两次，并且它的二倍是平方数 
				for(int j=1;j<=512;j++){
					if(vis[a[i]]==2||fa[a[i]+maxx]!=a[i]+maxx){flag=1;break;}
					//这里可以用判断敌人域的代表元素是不是它本身的方法来得知有没有敌对元素，是因为我每次并查集合并都是让敌人域合向本域 
					if(j*j<a[i])continue;
					if(j*j-a[i]>maxx)break;
					if(vis[j*j-a[i]]&&j*j-a[i]!=a[i]){flag=1;break;}
				}
				if(flag){
					ans[++sum]=i;
					for(int j=i;j<=lst;j++){
						fa[a[j]]=a[j],fa[a[j]+maxx]=a[j]+maxx;
						vis[a[j]]=0;
					}
					lst=i;
				}
			}
		}
		else{
			for(int j=1;j<=512;j++){
				if(j*j<a[i])continue;
				if(j*j-a[i]>maxx)break;
				if(vis[j*j-a[i]]){
					if(tag[2*(j*j-a[i])]&&vis[j*j-a[i]]==2){
						flag=1;
						break;
					}
					int x1=get(a[i]),x2=get(a[i]+maxx),y1=get(j*j-a[i]),y2=get(j*j-a[i]+maxx);
					if(x1==y1){
						flag=1;
						break;
					}
					else{
						fa[y2]=x1;
						fa[x2]=y1;
					}
				}
			}
			if(flag){
				ans[++sum]=i;
				for(int j=i;j<=lst;j++){
					fa[a[j]]=a[j],fa[a[j]+maxx]=a[j]+maxx;
					vis[a[j]]=0;
				}
				lst=i;	
			}
		}
		vis[a[i]]++;
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	lst=n;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),maxx=max(maxx,a[i]);
	if(k==1)solve1();
	else solve2();
	printf("%d\n",sum+1);
	for(int i=sum;i>=1;i--){
		printf("%d ",ans[i]);
	}
	return 0;
}
```
要注意的判断细节有点多，在各种细节上WA了好几次，包括因为清空不正确，自信地认为拿到了前四十分，其实只拿到一半…

思路不是很好想，这题一上来给的东西很多，对于我这种思路混乱的容易搞成一团乱麻。应该条理地观察总结性质，逐一思考获取最后的思路。

最后安利一下自己的博客，这场考试的三道题【斐波那契，数颜色，分组】都可以在同一篇找到：https://www.cnblogs.com/chloris/

---

## 作者：Undefined_R (赞：6)

前言：看了各位巨佬的题解，思路其实都一样，但是在下觉得自己的写法更适合像我一样的蒟蒻们理解和实现一些，没有需要特判的情况，可写性较强。


------------

### 题目分析

本题明显要分 K=1 和 K=2 两种情况讨论。整体算法思想是贪心：尽可能使得能放在同一组的两只兔子分在同一组，便将使得总分组最少。这个结论是显然的，证明略。

对于 K=1 的情况，外循环枚举每一只兔子的颜色值 $a_i$，内循环设 x 从1枚举到512（=$\sqrt{131072×2}$），看看有没有访问过 $(x^2-a_i)$ 这个值。如果访问过，则第i只兔子与当前组内其它兔子有冲突，需要清空访问标记并且单独新建一个分组；如果没访问过，则令第i只兔子加入当前分组。最后再打上访问标记即可。

对于 K=2 的情况，整体思路和K=1差不多，但是此时需要使用到并查集。与K=1的情况的不同点在于，如果访问过 $(x^2-a_i)$ ，我们仍然可以试图将$a_i$加入当前分组，因为此时我们的分组里允许有两个小团体。我们此时可以使用并查集来维护敌对关系：**fa[] 数组开2倍空间， find(1~n) 代表每只兔子所在小团体， find(n+1~2n) 代表每只的兔子所在小团体的敌对小团体。**

在上述情况下当访问过 $(x^2-a_i)$ 时，我们先判断下颜色值为 $(x^2-a_i)$ 的兔子（们）**（注意！此时可能不止一只！以上几篇题解都是用特判的方法处理的重复问题，本蒟蒻不会，所以推荐开动态数组 vector 存下每一只当前分组内相同颜色的兔子编号。）** 和第 i 只兔子是否已经被规划进入同一小团体中。如果已经被规划入同一小团体，那么便不得不清空访问并新建分组。否则，将第 i 只兔子与颜色值为 $(x^2-a_i)$ 的兔子（们）分别互相加入对方的敌对集合即可。

PS：由于需要字典序最小，我们需要倒序扫描 a 数组。


------------

### 代码

```
#include<cstdio>
#include<cctype>
#include<stack>
#include<vector>
using namespace std;
inline long long input(){
    long long a=0,f=1;
    char tmp=getchar();
    while(!isdigit(tmp)){if(tmp=='-')f=-1;tmp=getchar();}
    while(isdigit(tmp)){a=(a<<3)+(a<<1)+(tmp^48);tmp=getchar();}
    return a*f;
}
int n,K,a[131073],fa[300001],times[300001],last;
std::vector<int>vis[300001];
std::stack<int>ans;
int find(int x){
	if(fa[x]&&fa[x]^x)return fa[x]=find(fa[x]);
	return fa[x]=x;
}
void read(){
	n=input(),K=input();
	for(int i=1;i<=n;i++)
		a[i]=input();
}
void clear(int &last,int i){//一定不要直接把vis[1~300000]全部清空，这样会大大增加时间复杂度导致TLE。
	for(int j=last-1;j>i;j--)
		vis[a[j]].clear();
	last=i+1;
	ans.push(last-1);
}
void solve1(){
	for(int i=n;i;i--){
		bool ok=1;
		for(int x=1;x<=512;x++)
			if(x*x-a[i]>=0&&vis[x*x-a[i]].size()){
				ok=0;
				break;
			}
		if(!ok)clear(last,i);
		vis[a[i]].push_back(1);
	}
}
void solve2(){
	for(int i=n;i;i--){
		for(int x=1;x<=512;x++)
			if(x*x-a[i]>=0&&vis[x*x-a[i]].size())
				for(int j=0;j<vis[x*x-a[i]].size();j++){
					int f=vis[x*x-a[i]][j];
					if(find(i)==find(f))clear(last,i);
					else{
						fa[find(i+n)]=find(f);
						fa[find(f+n)]=find(i);
					}
				}
		vis[a[i]].push_back(i);
	}
}
void print(){
	printf("%d\n",ans.size()+1);
	while(ans.size())printf("%d ",ans.top()),ans.pop();
	putchar('\n');
}
int main(){
	read();
	last=n+1;
	if(K==1)solve1();
	else solve2();
	print();
	return 0;
}
```

---

## 作者：fstqwq (赞：6)

这里提供的是 std。


如果需要题解，请参考 [ppt](https://www.luogu.org/discuss/show?postid=26414)，或者其他同学的题解。


std 已经在第 73 行翻了两次车了 QAQ 大家一定要小心仔细呀。


```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

#define N 131073

int n, m = 0, K;
int a[N], b[N];
bool vis[N], dvis[N], issqr[N * 2];
int f[N * 2];

int getf(int x) {return f[x] > 0 ? (f[x] = getf(f[x])) : x;}

void merge(int u, int v) {
    u = getf(u), v = getf(v);
    if (u != v) {
        if (f[u] > f[v]) swap(u, v);

        f[u] += f[v];
        f[v] = u;

    }
}

bool check(int u, int v) {
    int s1 = getf(u), s2 = getf(u + N);
    int t1 = getf(v), t2 = getf(v + N);
    if (s1 == t1) return 1;
    if (s2 == t2) return 1;
    merge(s1, t2); merge(s2, t1);
    return 0;
}

void solve_1() {
    for (int i = n, j = n; i;) {
        for (bool flag = 1; j; j--) {
            for (int k = 1; k * k - a[j] < N; k++) {
                if (k * k - a[j] <= 0) continue;
                if (vis[k * k - a[j]]) {flag = 0; break;} 
            }
            if (!flag) break;
            vis[a[j]] = 1;
        }
        if (!j) break;
        b[++m] = j;
        for ( ; i > j; i--) vis[a[i]] = 0;
    }
}

void solve_2() {
    memset(f, -1, sizeof f);
    for (int i = 1; i * i < 2 * N; i++) issqr[i * i] = 1;
    for (int i = n, j = n; i;) {
        for (bool flag = 1; j; j--) {
            if (vis[a[j]]) {
                if (issqr[a[j] + a[j]]) {
                    if (dvis[a[j]]) break;
                    for (int k = 1;k * k - a[j] < N; k++) {
                        if (k * k - a[j]<0) continue;
                        if (vis[k * k - a[j]] && k * k != a[j] * 2) {
                            flag = 0; break;
                        } 
                    }
                    if (!flag) break;
                    dvis[a[j]] = 1;
                }
            }
            else {
                for (int k = 1; k * k - a[j] < N; k++) {
                    if (k * k - a[j] <= 0) continue;
                    if (vis[k * k - a[j]]) {
                        if (check(k * k - a[j], a[j]) || dvis[a[j]] || dvis[k * k - a[j]]) {flag = 0; f[a[j]] = f[a[j] + N] = -1; break;}
                    } 
                }
                if (!flag) break;
                vis[a[j]] = 1;
            }
        }
        if (!j) break;
        b[++m] = j;
        for ( ; i > j; i--) f[a[i]] = f[a[i] + N] = -1, vis[a[i]] = 0, dvis[a[i]] = 0;
    }
}

int main() {
    scanf("%d%d", &n, &K);
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    if (K == 1) solve_1();
    else solve_2();
    printf("%d\n", m + 1);
    for (int i = m; i; i--) printf("%d ", b[i]);
    putchar('\n');
    return 0;
}
```

---

## 作者：Porsche (赞：4)

看到只有管理员有题解，不爽

今天在博客园里打了一天，基本上把所有部分分的解法都写了一遍，推一下博客：https://www.cnblogs.com/wzc521/p/11297146.html

在这里我就只贴一个AC代码吧～
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,K;
int a[150000],maxn;
bool vis[150000],sit[150000];
int que[150000],sum;
int fa[300000];
void solve1()
{
    for(int i=n,j=n;i;)
    {
        for(;j;j--)
        {
            for(int k=1;k*k-a[j]<=maxn;k++)
            {
                if(k*k-a[j]<=0)continue;
                if(vis[k*k-a[j]])goto nxt;
            }
            vis[a[j]]=1;
        }
        nxt:
        if(!j)break;
        que[++sum]=j;
        for(;i>j;i--)vis[a[i]]=0;
    }  
}
int find(int x){return fa[x]<=0?x:fa[x]=find(fa[x]);}
void connect(int x,int y)
{
    x=find(x);
    y=find(y);
    if(x!=y)
    {
        if(fa[x]>fa[y]){fa[y]+=fa[x];fa[x]=y;}
        else {fa[x]+=fa[y];fa[y]=x;}
    }
}
bool judge(int x, int y)
{
    int flag1=find(x),flag2=find(x+140000),flag3=find(y),flag4=find(y+140000);
    if(flag1==flag3)return 1;
    if(flag2==flag4)return 1;
    connect(flag1,flag4);
    connect(flag2,flag3);
    return 0;
}
void solve2()
{
    for(int i=n,j=n;i;)
    {
        for(;j;j--)
        {
            if(vis[a[j]])
            {
                if((int)sqrt(a[j]<<1)*(int)sqrt(a[j]<<1)==a[j]<<1)
                {
                    if(sit[a[j]])break;
                    for(int k=1;k*k-a[j]<=maxn;k++)
                    {
                        if(k*k-a[j]<0)continue;
                        if(vis[k*k-a[j]]&&k*k!=a[j]<<1)goto nxt;
                    }
                    sit[a[j]]=1;
                }
            }
            else
            {
                for(int k=1;k*k-a[j]<=maxn;k++)
                {
                    if(k*k-a[j]<=0)continue;
                    if(vis[k*k-a[j]]&&(judge(k*k-a[j],a[j])||sit[a[j]]||sit[k*k-a[j]])){fa[a[j]]=fa[a[j]+140000]=0;goto nxt;}
                }
                vis[a[j]]=1;
            }
        }
        nxt:
        if(!j)break;
        que[++sum]=j;
        for(;i>j;i--)fa[a[i]]=fa[a[i]+140000]=vis[a[i]]=sit[a[i]]=0;
    }
}      
int main()
{
    scanf("%d%d",&n,&K);
    for(int i=1;i<=n;i++){scanf("%d",&a[i]);maxn=max(maxn,a[i]);}
    if(K==1)solve1();
    else solve2();
    printf("%d\n",sum+1);
    for(int i=sum;i;i--)printf("%d ",que[i]);
    return 0;
}
```
rp++

---

## 作者：hzoi_liuchang (赞：2)

## 分析
为了保证字典序最小，我们需要倒序枚举

对于 $K=1$ 的情况，如果我们当前扫到的值与之前的某个值之和恰好是平方数，那么就要再开一个组

对于 $k=2$ 的情况，我们把不合法的权值两两连边

那么出现冲突的情况就是整张图不是二分图，也就是说出现了奇环

这个我们用带权并查集随便判一下就可以了

因为我们要对于权值开并查集，所以要注意几种不合法情况的特判

1、当前的值出现的次数大于等于 $3$，并且当前值乘 $2$ 后为平方数

2、当前值与之前某个值冲突，并且这两个值中有一个出现次数大于等于 $2$

## 代码
``` cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<map>
#include<vector>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=4e6+5,maxk=513;
int n,k,a[maxn],sta[maxn],tp,fa[maxn],dis[maxn],mmax;
int mp[maxn];
int zhao(int xx){
	if(xx==fa[xx]) return xx;
	rg int now=fa[xx];
	fa[xx]=zhao(fa[xx]);
	dis[xx]+=dis[now];
	return fa[xx];
}
void bing(int xx,int yy){
	rg int aa=zhao(xx),bb=zhao(yy);
	fa[bb]=aa;
	dis[bb]=dis[xx]-dis[yy]-1;
}
int main(){
	n=read(),k=read();
	if(k==1){
		for(rg int i=1;i<=n;i++){
			a[i]=read();
		}
		rg int now;
		rg bool jud=0;
		for(rg int i=n;i>=1;i--){
			now=std::sqrt(a[i]);
			for(int j=now;j<=maxk;j++){
				if(j*j<a[i]) continue;
				if(mp[j*j-a[i]]){
					jud=1;
					break;
				}
			}
			if(jud){
				sta[++tp]=i;
				if(tp==1){
					for(rg int j=i+1;j<=n;j++){
						mp[a[j]]=0;
					}
				} else {
					for(rg int j=i+1;j<=sta[tp-1];j++){
						mp[a[j]]=0;
					}
				}
				jud=0;
			}
			mp[a[i]]++;
		}
		printf("%d\n",tp+1);
		for(rg int i=tp;i>=1;i--){
			printf("%d ",sta[i]);
		}
		printf("\n");
	} else {
		for(rg int i=1;i<=n;i++){
			a[i]=read();
			mmax=std::max(mmax,a[i]);
		}
		for(rg int i=1;i<=mmax;i++){
			fa[i]=i;
		}
		rg int now;
		rg bool jud=0;
		for(rg int i=n;i>=1;i--){
			now=std::sqrt(a[i]);
			if(mp[a[i]]>=2 && a[i]+a[i]==(int)sqrt(a[i]+a[i])*(int)sqrt(a[i]+a[i])){
				jud=1;
			}
			for(rg int j=now;j<=maxk;j++){
				if(jud) break;
				if(j*j==a[i]+a[i] || j*j<a[i] || j*j-a[i]>mmax) continue;
				if(mp[j*j-a[i]] && mp[a[i]] && a[i]+a[i]==(int)sqrt(a[i]+a[i])*(int)sqrt(a[i]+a[i])){
					jud=1;
					break;
				}
				if(mp[j*j-a[i]]>=2 && j*j-a[i]+j*j-a[i]==(int)sqrt(j*j-a[i]+j*j-a[i])*(int)sqrt(j*j-a[i]+j*j-a[i])){
					jud=1;
					break;
				}
				if(mp[j*j-a[i]]){
					if(zhao(a[i])==zhao(j*j-a[i]) && (dis[a[i]]+dis[j*j-a[i]])%2==0){
						jud=1;
						break;
					} else {
						bing(a[i],j*j-a[i]);
					}
				}
			}
			if(jud){
				sta[++tp]=i;
				if(tp==1){
					for(rg int j=i+1;j<=n;j++){
						mp[a[j]]=0;
						fa[a[j]]=a[j];
						dis[a[j]]=0;
					}
				} else {
					for(rg int j=i+1;j<=sta[tp-1];j++){
						mp[a[j]]=0;
						fa[a[j]]=a[j];
						dis[a[j]]=0;
					}
				}
				jud=0;
			}
			mp[a[i]]++;
		}
		printf("%d\n",tp+1);
		for(rg int i=tp;i>=1;i--){
			printf("%d ",sta[i]);
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：AFO_Song (赞：1)

# P3940 分组
## 题目大意
给你一个序列，将连续且不冲突的几个数分为一组，一组中还可以分为 $K$ 个小团体，求最少要分几组。

## 解题思路
先看题目的数据范围，发现 $K$ 只为 $1$ 或 $2$，想到分两种情况做。
### $K = 1$
使用贪心，把能分为一个组的尽量分一个组。如果发生冲突，直接再新建一个组。

再次观察数据，发现特殊的数字 $131072$，可以用**桶**存下，再通过计算发现 $131072 + 131072 = 512^2$ 可以在极短时间内判断一个数能否进入这个组。

**code**

```cpp
void cl(){ for(int kkk = 1; kkk <= tx;kkk++){tj[kkk] = 0;}return;}// 清除标记
void solve1(){
	for(int i = n; i >= 1; i--){ 
		tx = max(a[i],tx);
		for(int j = 1; j <= 540;j ++){
			if(((j*j) - a[i] >= 0)&&tj[(j*j) - a[i]] == 1){
				ans++;
				cl();
				tx = a[i]; 
				cnt[ans] = i;
				break;
			}
		}
		tj[a[i]] = 1;
	}
	cout << ans + 1 << "\n";
	for(int i = ans; i >= 1; i--){
		printf("%d ",cnt[i]);
	}
}
```
**注意：**
- 为了使字典序从小到大，需要**倒序枚举**，且在**枚举和输出**时都要倒序。
- 为减少清除的时间，需要记录一组的最大值。
- 在判断是否能进入前一组时要判断是否下标越界。

### $K = 2$（WA 68pts 解法）
继续贪心！！！

和 $K = 1$ 一样，能分一组就分一组，不能分的就尝试分到小团体内，标记数组再多开一个就可以了。

**code**

```cpp
for(int i = n; i >= 1; i--){
	tx = max(a[i],tx);
	if(k==1){
		for(int j = 1; j <= 540;j ++){
			if(((j*j) - a[i] >= 0)&&tj[(j*j) - a[i]] == 1){
				ans++;
				cl();
				tx = a[i];
				cnt[ans] = i;
				break;
			}
		}
		tj[a[i]] = 1;
	}
	else{
		bool t1=1,t2=1;// 记录是否能放入第一个或第二个小团体 
		for(int j = 1; j <= 540;j ++){
			if(((j*j) - a[i] >= 0)&&tj[(j*j) - a[i]] == 1){
				t1 = 0;
			}
			if(((j*j) - a[i] >= 0)&&tj2[(j*j) - a[i]] == 1){
				t2 = 0;
			}
			if(t2==0&&t1==0){// 如果都不能放入，直接添加新组 
				ans++;
				cl();
				cl2(); 
				tx = a[i];
				cnt[ans] = i;
				break;
			}
		}
		if(t2==0&&t1==0)continue;
		else if(t2==1&&t1 == 0){
			tj2[a[i]] = 1;
		}
		else{
			tj[a[i]] = 1;
		}
	}
}
cout << ans + 1 << "\n";
for(int i = ans; i >= 1; i--){
	printf("%d ",cnt[i]);
}
```
### $K = 2$（AC 解法）
![](https://cdn.luogu.com.cn/upload/image_hosting/eorftkbq.png)

经过不断~~卡评测~~尝试，发现前一个思路过不了（有可能是我太菜）。

考虑使用**种类并查集**，$1$ 到 $n$ 表示兔子的团体，$n+1$ 到 $2n$ 表示兔子的对立团体，和 $K = 1$ 时一样判断 $j^2 - a[i]$ 是否在同小团体中，如果在，就新建一组，此时清空标记、新增答案。同样的，需要倒序枚举和倒序输出。

**注意：$fa$ 数组要开两倍，还要特判是否有两个相同颜色的兔子。**

**AC code**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;int ans;
int a[150005],fa[300005];
bool tj[300005];
vector<int>tj2[300005];
int tx,ts=1;
int cnt[150005];
int find(int x){// 并查集板子 
	if(fa[x]!= x&&fa[x])return fa[x] = find(fa[x]);
	else return x;
} 
void cl(){ for(int kkk = 1; kkk <= tx;kkk++){tj[kkk] = 0;}return;}

void cl2(int x){
	for(int j = n;j > x; j--){
		tj2[a[j]].clear();
	}
	ans++;
	cnt[ans] = x;
}
void solve2(){// K 等于 2
	for(int i =n; i >= 1; i--){
		for(int j = 1; j <= 520; j++){
			if((j*j) - a[i] >= 0&&!tj2[(j*j) - a[i]].empty()){
				for(int k = 0;k < tj2[(j*j) - a[i]].size();k++) {
					int tmp = find(tj2[(j*j) - a[i]][k]);
					if(find(i) == tmp){
						cl2(i);
					}
					else{
						fa[find(n+i)] = tmp;
						fa[find(tj2[(j*j) - a[i]][k]+n)] = find(i);
					}
				}
			} 
		}
		tj2[a[i]].push_back(i);
	}
	cout << ans + 1 << "\n";
	for(int i = ans; i >= 1; i--){
		printf("%d ",cnt[i]);
	}
}
void solve1(){
	for(int i = n; i >= 1; i--){
		tx = max(a[i],tx);
		if(k==1){// k 等于 1  
			for(int j = 1; j <= 540;j ++){
				if(((j*j) - a[i] >= 0)&&tj[(j*j) - a[i]] == 1){
					if(ts < k){
						ts++;
					}
					else{
						ts = 1;
						ans++;
						cl();
						tx = a[i];
						cnt[ans] = i;
						break;
					}
				}
			}
			tj[a[i]] = 1;
		}
	}
	cout << ans + 1 << "\n";
	for(int i = ans; i >= 1; i--){
		printf("%d ",cnt[i]);
	}
}
namespace s12321s{
	int main(){
		cin >> n >> k;
		for(int i = 1; i <= n; i++){
			scanf("%d",&a[i]);
		}
		if(k==1) {
			solve1();
		}
		else{
			solve2();
		}
		return 0;
	}
}
int main(){
	s12321s::main();
	return 0;
} 
```
马蜂太丑，不喜勿喷。

---

## 作者：楠枫 (赞：1)

## 题解

[更好的阅读体验](https://www.cnblogs.com/nanfeng-blog/p/14919163.html)

这道题我们发现可以根据 $k=1$ 和 $k=2$ 的情况分别讨论

$k=1$ 时，我们发现要保证字典序，那么我们从后往前扫，扫的时候判断一下当前数是否会和上一段的冲突。

复杂度瓶颈就在于如何判断。我们发现 $a_i\leq 2^{17}$ 所以 $j*j=a_i+a_k$ 中 $j$ 最大为 $2^9$，所以我们可以枚举 $j$，记录一个数组，判断一下 $j*j-a_i$ 是否出现过

最后若分出新的一段，记得要把前一段的清空。

$k=2$ 时，我们可以把每个数拆成两个点，分别为 $x_1$，$x_2$，$y_1$，$y_2$，让后将冲突的数连起来，发现如果其符合二分图，那么就可以分为一组。

对于判断二分图，我们可以用并查集替代。（[思想](https://www.luogu.com.cn/problem/P1525)）

对于每个数，我们给他开一个敌人域，每次若发现冲突，但可以分成两个团体解决，那么我们将两个树的敌人域向与其发生冲突的数合并

判断时就是判断 $x_1$ 是否和 $y_1$ 在一个集合里。

(并查集的复杂度可以近似为常数)

```cpp
#include<bits/stdc++.h>
#define ri register signed
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    #define gc() p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++
    inline int read() {
        ri x=0,f=1;char ch=gc();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
        return x*f;
    }
}
using IO::read;
namespace nanfeng{
    #define cmax(x,y) ((x)>(y)?(x):(y))
    #define cmin(x,y) ((x)>(y)?(y):(x))
    #define FI FILE *IN
    #define FO FILE *OUT
    static const int N=(1<<17)+7;
    int a[N],vis[N],st[N],fa[N<<1],fg[N<<1],n,k,tot=1,mx;
    int find(int x) {return x==fa[x]?x:fa[x]=find(fa[x]);}
    inline int main() {
        // FI=freopen("nanfeng.in","r",stdin);
        // FO=freopen("nanfeng.out","w",stdout);
        n=read(),k=read();
        for (ri i(1);i<=n;p(i)) a[i]=read(),mx=cmax(mx,a[i]);
        vis[a[n]]=1;st[1]=n;
        if (k==1) {
            for (ri i(n-1);i;--i) {
                for (ri j(ceil(sqrt(a[i])));j*j-a[i]<=mx;p(j)) {
                    if (j*j>=a[i]&&vis[j*j-a[i]]) {
                        st[p(tot)]=i;
                        for (ri k(i+1);k<=st[tot-1];p(k)) vis[a[k]]=0;
                        break;
                    }
                }
                vis[a[i]]=1;
            }
        } else {
            for (ri i(1);i<=mx;p(i)) fa[i]=i,fa[i+mx]=i+mx;
            for (ri i(1);i*i<=(mx<<1);p(i)) fg[i*i]=1;
            for (ri i(n-1);i;--i) {
                ri fl=0;
                if (vis[a[i]]) {
                    if (fg[a[i]<<1]) {
                        if (vis[a[i]]==2||fa[a[i]+mx]!=a[i]+mx) fl=1;
                    }
                } else {
                    for (ri j(ceil(sqrt(a[i])));j*j-a[i]<=mx;p(j)) {
                        if (vis[j*j-a[i]]) {
                            if (fg[(j*j-a[i])<<1]&&vis[j*j-a[i]]==2) {fl=1;break;}
                            int x1=find(a[i]),x2=find(a[i]+mx),y1=find(j*j-a[i]),y2=find(j*j-a[i]+mx);
                            if (x1==y1) {fl=1;break;}
                            fa[y2]=x1;fa[x2]=y1;
                        }
                    }
                }
                if (fl) {
                    for (ri j(i);j<=st[tot];p(j)) fa[a[j]]=a[j],fa[a[j]+mx]=a[j]+mx,vis[a[j]]=0;
                    st[p(tot)]=i;
                }
                p(vis[a[i]]);
            }
        }
        printf("%d\n",tot);
        for (ri i(tot);i>1;--i) printf("%d ",st[i]);
        puts("");
        return 0;
    }
}
int main() {return nanfeng::main();}
```

---

## 作者：PMZG (赞：0)

首先这个题有若干种骗分技巧。  
解决字典序最小的方法就是从后往前枚举。
那么 $K=1$ 就很简单了，从后往前扫一遍就行，每次判断是否有冲突，有了就累计答案清空数组。  
判断的时候直接枚举定超时，注意到 $131072=512^2 /2$，所以每次只要枚举 $x<=512$,判断 $x^2-a_i$ 是否出现即可。  
对于 $K=2$，还是从后往前分组，判定的时候相当于判定二分图， 暴力可到80。
正解其实是并查集，类比关押罪犯，使用扩展域的并查集判断，每次判断，处理，合并 。 
一旦碰到冲突的就合并，然后判断是不是已经在一个集合内，如果已经重了，有两种情况：如果这个数 $2$ 倍是完全平方数并且出现恰好 $2$ 次，前面的数没有和他冲突的，那么没事；否则就要重新分段。  
这个特判的本质就是在一堆不合法情况里面把合法的排出来，细节有点多   
```cpp  
#include <bits/stdc++.h>
using namespace std;
int a[300005];int mem[300005];
stack <int> s;
int ans[300005],num;
inline void add(int x){ans[++num]=x;}
int f[300005];int n,k;
inline int find(int x)
{
	if(f[x]!=x)f[x]=find(f[x]);
	return f[x];
}
inline void tu(int x,int y)//y合并到x上 
{
	x=find(x);y=find(y);
	f[y]=x; 
}
inline void clear()
{
	while(!s.empty())
	{
		if(k==2)f[s.top()]=s.top();
		if(k==2)f[s.top()+131072]=s.top()+131072; 
	    mem[s.top()]=0;
		s.pop();
	}
}
bool gan(int x)
{
	for(int j=ceil(sqrt(x));j<=512;j++)
	{
		if(mem[j*j-x]&&((j*j-x)!=x))return 0;
	}
	return 1;
}
signed main()
{
//	freopen("sb.txt","r",stdin);
	cin>>n>>k;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	int an=1;
	if(k==1)
	{
		for(int i=n;i>=1;i--)
	    {
		   for(int j=ceil(sqrt(a[i]));j<=512;j++)//注意合法，j*j>=a[i] 
		   if(mem[j*j-a[i]])
		   {
		 	 an++;add(i);clear();
		 	 break;
		   }
		   mem[a[i]]++;s.push(a[i]); 
	    }
	}
	if(k==2)
	{
		for(int i=1;i<=300000;i++)f[i]=i;
		for(int i=n;i>=1;i--)
		{
		   s.push(a[i]);
		   for(int j=ceil(sqrt(a[i]));j<=512;j++)
		   {
		   	int p=j*j-a[i];
		   	if(!mem[p])continue;
            tu(p+131072,a[i]),tu(p,a[i]+131072);
		   	if(find(a[i])==find(a[i]+131072)) 
		   	{
				if(a[i]==p&&gan(a[i])&&mem[p]==1)continue;
				an++;add(i);clear();break;	
		    }
		   }
	       mem[a[i]]++;s.push(a[i]);
		} 
	} 
	printf("%d\n",an);
    for(int i=num;i>=1;i--)printf("%d ",ans[i]);
	return 0; 
}
```  
清空数组我用的栈，可以省时间，但一定要清干净，也可以用```memset```，就是慢点，可能会T1个点。

---


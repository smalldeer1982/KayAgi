# [TJOI2013] 数字根

## 题目描述

一个数字的数字根定义为:这个数字每一位的数字加起来求和,反复这个过程直到和小于10。例如,64357的数字跟为7,因为6+4+3+5+7=25,2+5=7个区间的数字根定义为这个区间所有数字和的数字根。

给定一个序列A1,A2,A3,…,An,你需要回答一些询问。每一个询问给定个区间[L,R],求出这个区间所有连续子区间里最大的前5个不同的数字根，不够5个的用-1补全


## 说明/提示

### 样例解释

第一个查询区间[1,3],它的连续子区间有[1,1],[2,2],[3,3],[1,2],[2,3],[1,3].可对应的数字根分别为2,6,7,8,4,6。所以最大的5个是8,7,6,4,2。

### 数据范围

30%的数据，N ≤ 1000; Q ≤ 1000

100%的数据，N ≤ 100000; Q ≤ 100000


## 样例 #1

### 输入

```
5
101 240 331 4 52
3
1 3
4 5
1 5```

### 输出

```
8 7 6 4 2
7 4 2 -1 -1
9 8 7 6 4```

# 题解

## 作者：Tsuku_yomi (赞：4)

蒟蒻第一次a紫题，来整篇题解，如有不足，斗胆请各位犇犇斧正


------------
## 题面解析

给出一串数列，有n次询问，每次询问一个区间中所有连续子区间的和的数字根的前五大值。
## 解法思考
多区间询问问题很容易让我们想到使用线段树来维护区间，同时，我们根据数字根的性质很容易了解数字根的取值范0~9，所以我们对数字根状态压缩。

接下来的重点是如何储存和合并节点的问题，我们根据最大连续子区间和的线段树做法，易知：一个区间中的所有连续子区间，可以由
两个子区间的所有连续子区间
并
左子区间中以右端点作为终点的连续子区间和右子区间中以左端点作为起点的连续子区间的两两组合形成的子区间
表示。

所以如果我们可以维护一个区间中所有连续子区间**all**，以左端点为起点的所有连续子区间**l**，以右端点为终点的所有连续子区间**r**，那么我们就可以维护其父节点的所有连续子区间。

随后容易证得，父区间的**r**可以由右区间的**l**与整个左区间**sum**组合的 并 右区间的**r**得到，**l**同理，而整个父区间只需要由两个子区间就可以组合而成。

由此我们成功分解了区间节点，并解决了他们的合并问题，接下来只需要套入线段树，此题就可以迎刃而解了

以下是月读的ac代码
```cpp
#include<cstdio>

#include<cmath>

#include<iostream>

#include<cstring>

#include<string>

#include<algorithm>

#include<vector>

#include<queue>

#include<stack>

#include<cstdlib>



using namespace std;

typedef long long loli;

const int MAXW=1000000;

const int INF=0x3f3f3f3f;

const int MOD=1000000007;

const char test[]="test\n";



int in();



struct Node {

	int l,r,lp,rp,all,sum;

	Node(int _l=0,int _r=0) {

		lp=_l;

		rp=_r;

	}

} Tr[400010];



int askroot(int i){

	return 1<<((i-1)%9+1);

}



int simpleHB(int al,int ar) {

	int rtn=0;

	for(int i=0; i<10; ++i) {

		if((al&(1<<i))) {

			for(int r=0; r<10-i; ++r) {

				if((ar&(1<<r)))

					rtn|=(1<<(i+r));

			}

			for(int r=10-i; r<10; ++r) {

				if((ar&(1<<r)))

					rtn|=(1<<(i+r-9));

			}

		}

	}

	return rtn;

}



Node HB(Node& NL,Node& NR) {

	Node rtn=Node(NL.lp,NR.rp);

	rtn.all=simpleHB(NL.r,NR.l)|NL.all|NR.all;

	rtn.l=NL.l|simpleHB(NL.sum,NR.l);

	rtn.r=NR.r|simpleHB(NR.sum,NL.r);

	rtn.sum=simpleHB(NL.sum,NR.sum);

	return rtn;

}



Node BuildTr(int lp,int rp,int i){

	//cout<<lp<<" "<<rp<<endl; 

	if(lp==rp){

		Tr[i]=Node(lp,rp);

		Tr[i].l=Tr[i].r=Tr[i].all=Tr[i].sum=askroot(in());

		return Tr[i];

	}

	Node L=BuildTr(lp,(lp+rp)/2,i<<1);

	Node R=BuildTr((lp+rp)/2+1,rp,(i<<1)+1);

	Tr[i]=HB(L,R);

	return Tr[i];

}



Node ask(int lp,int rp,int i){

	if(lp<=Tr[i].lp&&rp>=Tr[i].rp){

		return Tr[i];

	}

	if(lp<=(Tr[i].lp+Tr[i].rp)/2&&rp>(Tr[i].lp+Tr[i].rp)/2){

		Node L=ask(lp,rp,i<<1);

		Node R=ask(lp,rp,(i<<1)+1);

		return HB(L,R);

	}

	if(lp<=(Tr[i].lp+Tr[i].rp)/2){

		return ask(lp,rp,i<<1);

	}else{

		return ask(lp,rp,(i<<1)+1);

	}

}



int n,q;

int askL,askR;



int main() {

	n=in();

	BuildTr(1,n,1);

	q=in();

	for(int i=0;i<q;++i){

		askL=in();askR=in();

		Node askend=ask(askL,askR,1);

		int ptr=0,out[10];

		for(int i=0;i<10;++i){

			out[i]=-1;

		}

		for(int i=9;i>=0;--i){

			if(askend.all&1<<i){

				out[ptr]=i;

				++ptr;

			}

		}

		for(int i=0;i<5;++i){

			printf("%d ",out[i]);

		}

		printf("\n");

	}

	return 0;

}









int in() {

	int input;

	scanf("%d",&input);

	return input;

} 
```


                             

---

## 作者：mydiplomacy (赞：2)

我的思路：$dp+$线段树

首先需要推出一个结论：对于任意$x$，

当$x$不等于$0$时，$x$的数字根即为$x$除以$9$的余数

当$x$等于$0$时，$x$的数字根为$0$

#### 证明如下：

引理：对于任意$n,$ 有$10^n-1$ $mod$ $9$ $=$ $1$成立。引理证明略。

$x=0$时，原命题显然成立。

$x$不等于$0$时，设$x$的十进制位分别为$a[n],a[n-1],...,a[1],a[0]$，从高到低。

于是有$x=a[n]*10^{n}+a[n-1]*10^{(n-1)}+...+a[1]*10+a[0]$

由引理，

$x\ mod\ 9$

$=\ (a[n]*10^{n}+a[n-1]*10^{(n-1)}+...+a[1]*10+a[0])\ mod\ 9$

$=\ (a[n]*1+a[n-1]*1+...+a[1]*1+a[0])\ mod \ 9$

$=$ 题目定义中的数字根

#### 证毕

要解决题目中的问题，我的思路是：首先对于每组$(i,j)$，求出最大的$k$，使得第$i$项至第$j$项的和的数字根为$j$。我们令$d[i][j]=k$，有$i<=n,1<=j<=9$。另外显然有$d[i][j]<=i$

如果求出了$d$，那么对于一组询问$(L,R)$，我们定义$k$，遍历$1～9$，判断是否存在一个连续子区间，满足区间所有数的和的数字根是$k$。判断方式为：

考虑如果有一组$L1，R1$满足条件，一定有$L<=R1<=R$与$L<=L1<=R$成立。所以如果有任何一个$d[i][k]>=L$，满足$L<=i<=R$，那么存在一个子区间满足其和的数字根为$k$。即对于$L<=i<=R$，$d[i][k]$的最大值$>=L$时，$k$成立。于是我们可以将这个问题转化为区间求最大值的问题。我建立了$9$棵线段树，每次进行查询即可。

接下来考虑如何求$d$数组。

我使用了$dp$的思想，$d$可以递推求得：

$ d[i][j]=a[i]%9==j?i:d[i-1][(j-a[j]-1+9)%9+1] $

这是因为，如果当前$a[i]$的数字根是$j$，那么$d[i][j]=i$；

如果$a[i]$的数字根不是$j$，那么如果$d[i][j]=k$，则：第$k$项～第$i$项之和的数字根是$j$，可以推得第$k$项～第$i-1$项之和的数字根是$j-a[j]$的数字根。于是可以递推求得$d$数组。

在代码实现中，要特判a[i]==0的情况。代码如下。
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int maxn=500005;

int n,num[maxn]; //num即题解中的a
int d[maxn][11];

struct Node
{
    int left, right;
    int maxa;
}a[maxn][10]; //线段树

int z[maxn];

/***以下为线段树模版***/

void buildtree(int id, int l, int r)
{
    for(int c=1;c<=9;c++)
    {
        a[id][c].left=l;
        a[id][c].right=r;
    }
    if(l==r)
    {
        for(int c=1;c<=9;c++)
            a[id][c].maxa=d[l][c];
        return;
    }
    int mid=(l+r)/2;
    buildtree(id<<1,l,mid);
    buildtree(id<<1|1,mid+1,r);
    for(int c=1;c<=9;c++)
        a[id][c].maxa=max(a[id<<1][c].maxa,a[id<<1|1][c].maxa);
}

int query(int c, int id, int l, int r)
{
    if(a[id][c].left==l && a[id][c].right==r)
    {
        return a[id][c].maxa;
    }
    if(a[id<<1][c].right>=r) return query(c,id<<1,l,r);
    else if(a[id<<1|1][c].left<=l) return query(c,id<<1|1,l,r);
    else
    {
        return max(query(c,id<<1,l,a[id<<1][c].right),query(c,id<<1|1,a[id<<1|1][c].left,r));
    }
}

/****以上是线段树模版****/

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        cin>>num[i];
        if(num[i]%9==0 && num[i]!=0) num[i]=9;
        else
            num[i]%=9;
        if(num[i]==0) z[i]=i; //特判等于零的情况，记录上一个出现的零的位置
        else z[i]=z[i-1];
    }
    for(int i=1;i<=n;i++)
    {
        d[i][num[i]]=i;
        for(int j=1;j<=9;j++)
        {
            d[i][j]=max(d[i][j],d[i-1][(j-num[i]-1+9)%9+1]); //求d
        }
    }
    buildtree(1,1,n);
    int q; cin>>q;
    for(int i=1;i<=q;i++)
    {
        int l,r; cin>>l>>r; int sum=0;
        for(int j=9;sum<=4&&j>=1;j--)
        {
            if(query(j,1,l,r)>=l)
            {
                sum++;
                cout<<j<<' ';
            }
        }
        if(sum<=4 && z[r]>=l) //特判零
        {
            sum++;
            cout<<0<<' ';
        }
        for(;sum<=4;sum++) cout<<"-1 ";
        cout<<endl;
    }
    return 0;
}

```


---

## 作者：Hope2075 (赞：1)

题意：求区间内子段和的所有可能数字根

可以发现：如果某个数不是0，那么对答案的影响只取决于这个数被9除的余数

# 基本思路

对于这种子段的问题，常见的处理方式就是：保存区间前缀、后缀、子段以及整个区间的信息，然后就可以合并：

1. 前缀：答案可能来自于前面区间的前缀，也可能是前面整个区间与后面区间的前缀连在一起

   例如ab cd的所有前缀就是a ab abc abcd，前面区间的前缀是a ab，后面区间的前缀是c cd

2. 后缀同理

3. 子段：可能是两个区间各自的子段，也可能是前面区间的后缀与后面区间的前缀连在一起

4. 区间和直接合并即可

# 处理不包括0的情况

对于这道题，合并就是枚举两部分的可能情况，合并后的两种情况取逻辑或即可

例如样例：101 240 331 4 52

对9取余后的结果：2 6 7|4 7

前三个数：
```
pre=[2,6,8]
suf=[4,6,7]
sum=6
sub=[2,4,6,7,8]
```
后两个数：
```
pre=[2,4]
suf=[2,7]
sum=2
sub=[2,4,7]
```
合并后（这里的加号表示求并集，乘号表示对第一个集合的每个数加上第二个集合的某个数，所有情况合并，并且数字根为9时记为0）：
```
pre=[2,6,8]*2+[2,4]=[4,8,1]+[4,6]=[1,4,6,8]
suf=[2,7]+[4,6,7]*2=[2,7]+[6,8,0]=[0,2,6,7,8]
sum=8
sub=[2,4,6,7,8]+[2,4,7]+[4,6,7]*[2,4]=[2,4,6,7,8]+[2,4,7]+[6,8,8,1,0,2]=[0,1,2,4,6,7,8]
```
建树的时候，叶子节点保存这些信息（假设这个位置的数模9余k：
```
pre=[k]
suf=[k]
sum=k
sub=[k]
```

其它节点合并子节点的信息即可。

这样，不包含0的情况就可以通过区间查询来解决。 

# 包括0的情况

这种情况就复杂一些

首先可以发现，0不会对区间的非零数字根产生**任何**影响，所以考虑如何在建树时消掉影响。

可以这样构造：
```
pre=[]
suf=[]
sum=0
sub=[]
```
这样可以看到，这个区间在合并的时候就不会产生任何影响（与任何区间合并，结果仍是另一个区间）。

建树的时候，如果某个位置确实为0，那么这个节点就保存上面的信息。

然后讨论区间数字根是否包括0。

三种情况：

1. 区间内不含0，那么正常处理即可。

2. 区间内包含0，也包含非零的数，也是正常处理，最后把0加上。

3. 区间内全为0，那么答案只有0。

判断用前缀和就行。

# 代码

为了方便，我把每个区间定义了一个结构体，重载了加号（表示合并区间，不满足交换律）。

同时，每个结构体压位来节约空间，sum也进行类似的处理（对1移位后保存，这样便于处理）。

```cpp
#include<cstdio>
int read(){
    int n=0;char c=getchar();bool f=0;
    while(c!='-'&&(c<'0'||c>'9'))c=getchar();
    if(c=='-'){f=1;c=getchar();}
    while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
    if(f)return -n;
    return n;
}
int mup(int a,int b){
    int rs=0;
    for(int k=0;k<9;k++){
        if(b&(1<<k)){
            rs|=a<<k;
        }
    }
    return (rs|(rs>>9))&0x1ff;
}
struct data{
    int pre,suf,sum,sub;
    data(){sum=1;pre=suf=sub=0;}
    data(int l){pre=suf=sum=sub=(1<<l);}
    data(int _p,int _s,int _sum,int _sub){
        pre=_p;
        suf=_s;
        sum=_sum;
        sub=_sub;
    }
    data operator+(const data &x)const{
        int _p,_s,_sum,_sub;
        _p=pre|mup(x.pre,sum);
        _s=x.suf|mup(suf,x.sum);
        _sum=mup(sum,x.sum);
        _sub=sub|x.sub|mup(suf,x.pre);
        return data(_p,_s,_sum,_sub);
    }
};
const int N=100000;
int cnt[N];
int num[N];
data seg[N*4];
int n;
void build(int l,int r,int id){
    if(l==r){
        if(cnt[l]-cnt[l-1]){
            seg[id]=data();
        }else{
            seg[id]=data(num[l]);
        }
        
        return;
    }
    int mid=((l+r)>>1);
    build(l,mid,id<<1);
    build(mid+1,r,(id<<1)+1);
    seg[id]=seg[id<<1]+seg[(id<<1)+1];
    return;
}
data query(int l,int r,int ll,int rr,int id){
    if(l<=ll&&rr<=r)return seg[id];
    if(rr<l||r<ll)return data();
    int mid=((ll+rr)>>1);
    return query(l,r,ll,mid,id<<1)+query(l,r,mid+1,rr,(id<<1)+1);
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        int a=read();
        if(a==0)cnt[i]=1;
        cnt[i]+=cnt[i-1];
        num[i]=a%9;
    }
    build(1,n,1);
    int q=read();
    while(q--){
        int l,r;
        l=read();r=read();
        int x=query(l,r,1,n,1).sub;
        bool fl[10]={};
        if(cnt[r]!=cnt[l-1]){
            fl[0]=1;
        }
        for(int i=1;i<=9;i++){
            fl[i]=x&(1<<(i%9));
        }
        if(cnt[r]-cnt[l-1]==r-l+1)fl[9]=0;
        int cnt=5;
        for(int i=9;i>=0;i--){
            if(fl[i]){
                printf("%d ",i);
                --cnt;
                if(cnt==0)break;
            }
        }
        while(cnt--){
            printf("-1 ");
        }
        printf("\n");
    }
}
```


---

## 作者：Cgod (赞：1)

# 题面链接
### [洛谷](https://www.luogu.org/problemnew/show/P3962)

# sol

我们先不考虑$0$，发现数字根$=$它$mod 9$。

我们前缀和一波，把区间和变成两数相减。

对于每个$v\in\{0-8\}$，（这里面的$mod 9=0$的相当于数字根为9），我们维护每个数$a$往后第一个可以和它组成$(b-a) mod 9=v$的位置，称为$OJBK$位置。

那么对于一段区间，求出每个$v\in\{0-8\}$的最小$OJBK$位置，若它在区间里面，那么这段区间就可以组成这个$v$。

至于$0$我们特判一下区间内有没有$0$，然后忽略$0$。

总复杂度$O(9nlogn+9q)$。

### [代码](https://www.cnblogs.com/cx233666/p/9906555.html)

---


# [TJOI2014] 电影评分

## 题目描述

小Z发明了一套新的电影评分系统。这套系统有三种操作:发布新电影、对电影评分、以及询问电影评分的排名。具体是这样运作的:如果是发布新电影,并且这部电影的有所主演之前均没有出现过,那么这部新电影的评分为0,否则这部电影的评分为**最近一部**与该电影**至少有一个共同主演**的电影的评分;如果是对电影进行评分,那么这部电影的评分就变成之前评分与新的评分的平均数;如果是查询排名,则根据评分输出相应排名。评分最高的为第一名。如果有多部电影分数相同,那么输出最早的一部。电影的评分在0到5之间。


## 说明/提示

### 样例解释

| Movie | 1 | 2 | 3 | 
| :-: | :-: | :-: | :-: | :-: | :-: |
| | 0 | - | - |
| | 0 | 0 | - |
| | 0 | 1 | - |
| | 0 | 1 | 1 |
| Q 1 => 2 | //Movie 2 wa|s released be|fore Movie 3 |
| | 0 | 1 | 1.5 |
| | 2.5 | 1 | 1.5 |
| Q 1 => 1 |
| Q 2 => 3 |
| Q 3 => 2 |
### 数据范围

对于 30% 的数据，n ≤ 100

对于 100% 的数据，n ≤ 10000


## 样例 #1

### 输入

```
10 
R 1 1 1 
R 2 2 1 2 
C 2 2 
R 3 1 2 
Q 1 
C 3 2 
C 1 5 
Q 1 
Q 2 
Q 3```

### 输出

```
2 
1 
3 
2```

# 题解

## 作者：xiwang (赞：3)

在网上听人说这题暴力可过，本着no zuo no die的心态试了一发...

结果不仅过了，还跑得比香港记者还快，我甚至还没开氧气优化！

~~我将发动同学写此题，此题将成为一道省选红题~~

正解好像是平衡树?

upd:加点~~完全不必要的~~说明

id/fid记录每部电影存在数组里的编号/R操作给出的编号

Q:直接把所有电影存进数组排序即可

R:直接按题意模拟即可

C:fid转换编号直接按题意修改即可

直接暴力搞就好了

上代码

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double ddf;
const int N=100000+10;
int id[N],fid[N],ac[N],tot,n;
ddf s[N];
struct node{
	ddf x;
	int y;
}a[N];
bool cmp(node a,node b){
	return a.x==b.x?a.y<b.y:a.x>b.x;
}
char b[16];
int main(){
	int x,y,z;
	ddf xp,yp,zp;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",b);
		if(b[0]=='Q'){
			scanf("%d",&x);
			for(int i=1;i<=tot;i++)a[i]=(node){s[i],i};
			sort(a+1,a+1+tot,cmp);
			printf("%d\n",id[a[x].y]);
		}
		else if(b[0]=='R'){
			int mx=0;
			scanf("%d%d",&x,&y);
			id[++tot]=x;
			fid[x]=tot;
			for(int i=1;i<=y;i++){
				scanf("%d",&z);
				mx=max(mx,ac[z]);
				ac[z]=tot;
			}
			s[tot]=s[mx];
		}
		else {
			scanf("%d%lf",&x,&xp);
			x=fid[x];
			s[x]=(s[x]+xp)/2;
		}
	}
	return 0;
}
/*
10
R 1 1 1
R 2 2 1 2
C 2 2
R 3 1 2
Q 1
C 3 2
C 1 5
Q 1
Q 2
Q 3
*/
```

---

## 作者：数学系 (赞：2)

看题解说这题暴力可过，本着no zuo no die的心态试了一发...  
结果不仅没过，还T了两个点，甚至还开了氧气优化  
~~后来发现用的是cin，改成scanf就行了~~  
正解好像是暴力?  
直接暴力搞就好了  
上代码  
```cpp
#include <cstdio>

using namespace std;

int tmp;
void swap(int &a,int &b)
{
    tmp=a;
    a=b;
    b=tmp;
}

const int maxn=100001;
int Actor_Movie[maxn]={};//演员最后一部电影的ID 
int Actor_Time[maxn]={};//演员最后一次演出时间 
int movie[maxn]={};//排名为i的电影id 
double movietime[maxn]={};//电影上映时间 
double score[maxn]={};//电影id的分数 
int n;

int main()
{
    scanf("%d",&n);
    int id,x,NearestActor,actor[maxn]={};
    int Time=0;
	char op;	
    double y;
    for(int i=1;i<=n;i++)
    {
        scanf("%s",&op);
        if(op=='R')//新电影 
        {
            scanf("%d%d",&id,&x);
            movietime[id]=(++Time)/100000000.0;
            NearestActor=0;
            for(int i=1;i<=x;i++)
            {
                scanf("%d",&actor[i]);
                if(Actor_Movie[actor[i]] && Actor_Time[actor[i]]>Actor_Time[NearestActor])
                    NearestActor=actor[i];
            }
            score[id]=score[Actor_Movie[NearestActor]];
            for(int i=1;i<=x;i++)
            {
                Actor_Time[actor[i]]=Time;
                Actor_Movie[actor[i]]=id;
            }
            movie[Time]=id;
            for(int i=Time;i>1;i--)
            {
                if(score[movie[i]]-movietime[movie[i]]>score[movie[i-1]]-movietime[movie[i-1]])
                    swap(movie[i],movie[i-1]);
                else
                    break;
            }
        }
        else if(op=='C')//改分 
        {
            scanf("%d%lf",&id,&y);
            score[id]=(score[id]+y)/2.0;
            for(int i=1;i<=Time;i++)
                if(movie[i]==id)
                {
                    for(int j=i;j<Time;j++)
                        movie[j]=movie[j+1];
                    movie[Time]=id;
                    for(int j=Time;j>1;j--)
                    {
                        if(score[movie[j]]-movietime[movie[j]]>score[movie[j-1]]-movietime[movie[j-1]])
                            swap(movie[j],movie[j-1]);
                        else
                            break;
                    }
                    break;
                }
        }
        else//查排名 
        {
            scanf("%d",&x);
            printf("%d\n",movie[x]);
        }
    }
    return 0;
}

```


---

## 作者：Thunder_S (赞：1)

## Solution

有种做法是暴力，利用快排可以在 $\mathcal O(n)$ 的时间内求出区间第 $k$ 大，做到总时间复杂度为 $\mathcal O(n^2)$，吸下氧应该能过。

正解是后缀平衡树，将小数分成整数部分和小数部分，小数部分用二进制表示，然后来比较。

但正解我也不会，我就只打了 $\mathrm{Splay}$，由于怕被卡精度于是用了 $\mathrm{long\ double}$。

剩下的就跟普通的 $\mathrm{Splay}$ 差不多。

## Code

```cpp
#include<cstdio>
#include<algorithm>
#define N 100005
#define eps 1e-60
#define ldb long double
using namespace std;
int n,cnt,rt,t[N],lst[N],size[N],f[N],c[N][2];
ldb val[N];
char ch[16];
ldb Abs(ldb x) {return x<0?-x:x;}
void Update(int x)
{
    int l=c[x][0],r=c[x][1];
    size[x]=size[l]+size[r]+1;
}
void Rotate(int x,int &k)
{
    int y=f[x],z=f[y],l=x==c[y][1],r=l^1;
    r=l^1;
    if (y==k) k=x;
    else c[z][y==c[z][1]]=x;
    f[c[x][r]]=y;f[y]=x;f[x]=z;
    c[y][l]=c[x][r];c[x][r]=y;
    Update(x);Update(y);
}
void Splay(int x,int &k)
{
    while (x!=k)
    {
        int y=f[x],z=f[y];
        if (y!=k)
        {
            if (x==c[y][1]^y&&c[y][1]^y==c[z][1]) Rotate(x,k);
            else Rotate(y,k);
        }
        Rotate(x,k);
    }
}
void Insert(int &now,int x,int fa)
{
    if (!now)
    {
        now=x;
        f[now]=fa;
        c[now][0]=c[now][1]=0;
        Splay(now,rt);
        return;
    }
    if (val[x]>val[now]||Abs(val[x]-val[now])<eps&&t[x]<t[now]) Insert(c[now][0],x,now);
    else Insert(c[now][1],x,now);
}
void Delete(int x)
{
    Splay(x,rt);
    if (c[x][0]*c[x][1]==0)
    {
        rt=c[x][0]+c[x][1];
        f[c[x][0]+c[x][1]]=0;
        return;
    }
    int pre=c[x][0],suf=c[x][1];
    while (c[pre][1]) pre=c[pre][1];
    while (c[suf][0]) suf=c[suf][0];
    Splay(pre,rt);Splay(suf,c[pre][1]);
    c[suf][0]=f[x]=0;
    Update(pre);Update(suf);
}
int Get(int now,int rk)
{
    if (size[c[now][0]]+1==rk) return now;
    if (rk<=size[c[now][0]]) return Get(c[now][0],rk);
    return Get(c[now][1],rk-size[c[now][0]]-1);
}
int main()
{
    freopen("movie.in","r",stdin);
    freopen("movie.out","w",stdout);
    scanf("%d",&n);
    while (n--)
    {
        scanf("%s",ch);
        if (ch[0]=='R')
        {
            int x,num,act,k=0;
            scanf("%d%d",&x,&num);
            for (int i=1;i<=num;++i)
            {
                scanf("%d",&act);
                if (t[lst[act]]>t[k]) k=lst[act];
                lst[act]=x;
            }
            val[x]=val[k];
            t[x]=++cnt;
            size[x]=1;
            Insert(rt,x,0);
        }
        else if (ch[0]=='C')
        {
            int x;ldb v;
            scanf("%d%Lf",&x,&v);
            Delete(x);
            val[x]=(val[x]+v)/2;
            Insert(rt,x,0);
        }
        else if (ch[0]=='Q')
        {
            int x;
            scanf("%d",&x);
            printf("%d\n",Get(rt,x));
        }
    }
    return 0;
}
```



---


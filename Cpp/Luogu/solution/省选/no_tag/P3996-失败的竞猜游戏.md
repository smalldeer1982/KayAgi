# 失败的竞猜游戏

## 题目背景

大宁是一个喜欢赌博的人，最近在玩一款竞猜游戏，然而屡战屡败。大宁非常不高兴，就去找游戏的运营商理论，质疑游戏的数据是否有意针对玩家。


## 题目描述

游戏规则如下：玩家给出 $A_0$，$a$，$b$ 三个整数，代表一个线性递推式：

$A_i=a \times A_{i-1} +b$

它定义了一个无限长度的数列 {$A_1$，$A_2$，$A_3$……}，而游戏系统会随机生成一个数 $n$，如果 $n$ 可以表示为该数列中的若干个**互不相同**的项 ( $A_0$ 不计入数列中) 之和，那么玩家胜利，反之玩家失败。现在大宁通过逼迫运营商交出了一组最近的游戏数据，但是他懒得一个个去算了，现在请你帮忙计算一下，数据中玩家一共获胜了多少次。


## 说明/提示

样例说明：

第 $1\sim 3$ 场游戏玩家失败，$4\sim 7$ 场游戏玩家胜利。

| 测试点编号 | 数据范围 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 2$ | $T=10$, $n\leq 10^3$ | $a=1$ |
| $3\sim 4$ | $T=10^3$, $n\leq 10^4$ | $a=2$ |
| $5$ | $T=10^4$, $n\leq 10^9$ | $a\leq 3$ |
| $6$ | $T=10^5$, $n\leq 10^9$ | $b=0$ |
| $7\sim 10$ | $T=2\times 10^5$, $n\leq10^9$ | 无 |
对于所有数据，$1\leq a\leq10$, $0 \leq b \leq 10^4$, $0\leq n \leq 10^9$, $0 \leq A_0 \leq 100$。

事实上这个游戏玩家的胜率微乎其微。


## 样例 #1

### 输入

```
7
3 1 5 16
10 1 0 5
2 1 0 3
2 1 0 10
3 1 5 59
1 2 0 998
0 1 0 0
```

### 输出

```
4```

# 题解

## 作者：打杂的8 (赞：13)

还是放一份代码吧，我的[博客](https://www.luogu.org/blog/dazade8/post-new)里应该说得比较清楚了，粘贴过来。

T2:Number

解法一

暴力计算数列，然后搜索可能的答案。


复杂度 O(2^L)


L为数列长度。


预计得分 40


解法二

当a！=1时，注意到以下性质：

A(0)=1 A(i)=2A(i-1) (即A(i)=2^n)

这个数列增长得非常快，以至于每一项都大于之前所有项的和。

这个数列是除了 b=0且A(0)=0 时增长得最慢的一个，意味着其他所有数列都满足数列的每一项都大于之前所有项的和这样一个性质。

这样就是一个贪心，预处理一下，每次减去小于等于n的最大项，如果最后n可以被减到0意味着原来的n可以被表示，反之一定不行。

对于b=0且A(0)=0的数列特判就可以了。

单次复杂度O(logn)


当a=1时，这个数列是一个等差数列，并且可以被表示成以下形式：

{A(0)+b,A(0)+2b,A(0)+3b,......,A(0)+Nb,......}

如果n可以被表示为其中若干个不同项的和，那么显然有：

关于x，y的方程 A(0)x+by=n

存在一组正整数解，使得y>=(x(x+1))/2。

解得的方程的意义是数列中选了x项，并且每一项的b的系数之和为y。

很明显，只有y>=(x(x+1))/2时y才能拆分成若干个互不相同的自然数。

A(0)=0或b=0时要特判。解方程时要特别小心，直接解A(0)x+by=n得到的x可能是负数，要找它为正数的解。


单次复杂度O(logn)

总体复杂度O(Tlogn)

预计得分 100


码风略丑。


```cpp
    #include<cstdio>
    #include<cstring>
    typedef long long ll;
    ll T,n,a,b,x0;
    ll num[1000];
    ll extended_euclid(ll a,ll b,ll &x,ll &y)
    {
        if(b==0)
        {
            x=1;y=0;
            return a;
        }
        ll n=extended_euclid(b,a%b,x,y);
        ll tmp=x;
        x=y;
        y=tmp-static_cast<ll>(a/b)*y;
        return n;
    }
    bool linear_equation(ll a,ll b,ll c,ll &x,ll &y)
    {
        ll n=extended_euclid(a,b,x,y);
        if(c%n) return false;
        ll k=c/n;
        x*=k;
        y*=k;
        return true;
    }
    ll gcd(ll a,ll b)
    {
        return (a%b==0)?b:gcd(b,a%b);
    }
    bool cacl()
    {
        ll x=0,y=0;
        if(!linear_equation(x0,b,n,x,y)) return false;
        ll G=gcd(b,x0);
        ll b1=b/G,x01=x0/G;
        if(x<0)
        {
            ll gmp1=y%x01,gmp2=(y-y%x01)/x01;
            y=gmp1;
            x=x+gmp2*b1;
        }
        if(x<0) return false;
        ll tmp1=x%b1,tmp2=(x-x%b1)/b1;
        if(tmp1==0) tmp2--,tmp1+=b1;
        ll tmp3=y+tmp2*x01,tmp4=1ll*(tmp1*(tmp1+1))/2;
        if(tmp4<=tmp3) return true;
        else return false;
    }
    int main()
    {
        ll ans=0;
        scanf("%d",&T);
        while(T--)
        {
            memset(num,0,sizeof(num));
            scanf("%lld%lld%lld%lld",&x0,&a,&b,&n);
            if(n==0) ans+=(x0==0&&b==0);
            else if(x0==0&&b==0) ans+=(n==0);
            else if(a==1&&b==0) 
            {
                if(x0==0) ans+=(n==0);
                else if(!(n%x0)) ans++;
            }
            else if(a==1&&x0==0) 
            {
                if(b==0) ans+=(n==0);
                else if(!(n%b)) ans++;
            }
            else if(a==1) 
            {
                if(cacl()) ans++;
            }
            else
            {
                int x=1;
                num[0]=x0;
                while(1)
                {
                    num[x]=1ll*num[x-1]*a+b;
                    if(num[x]>=n) break;
                    x++;
                }
                for(int i=x;i>=1;i--)
                if(n>=num[i]) n-=num[i];
                if(n==0) ans++;
            }
        }
        printf("%lld",ans);
        return 0;
}
```

---

## 作者：Flandre_495 (赞：1)

一道很不错的数论题呢~，就是有点冷门。

蒟蒻数论全谷最菜，感谢出题人的题解。在此重新总结一下，~~放一份简单点的代码。~~

________

出题人的题解很详细了，我再总结一下：

这题有很多细节，~~还不能下数据~~，导致我WA了五六次。

首先是判$0$的情况，因为不能空选，所以$n=0$时,$A[0]$和$b$都必须也是$0$。

先把这个情况判掉，因为$a$无论是几，这种情况都符合。

然后是对$a$的分类：

#### a>1时：

很显然，或简单用归纳法证明一下，每一项$A[i]$都是要比前面的所有项的和都要大的。不难想吧~

因为每个数都是上一个数至少乘以$2$之后再加一个数，加的数$b$是$0$无所谓，只要不是负数就行。而对于$A[0]$是$0$的情况，既然$A[1]=b$，那显然还是成立的。除非$A[0]$和$b$都是$0$呢，这种情况开始已经判掉了~

既然每个数都比前面的所有数的和大，如果我不选择这个数，前面的数是无法弥补这么大的空缺的，所以倒着枚举每个数，只要$n$比此项大，就减去此项，最后如果$n=0$，有解，否则无解，不难证明。

#### a=1时:

这就比较麻烦了：不会exgcd的建议去做一做[青蛙的约会](https://www.luogu.org/problem/P1516)。

当a=1时，我们把每一项列出来：

```
A[1]=A[0]+b; A[2]=A[0]+2*b; A[3]=A[0]+3*b; A[4]=A[0]+4*b;...
```

既然只由$A[0]$和$b$组成，解个$exgcd$就行了~

然后你解出了一组解：$x*A[0]+y*b=n$。接下来我们简单分个类：

**1. 当b=0时**：只要$n$能除尽$A[0]$得到$x$，你只要随便**选x个项**即可。

**2. 当A[0]=0时**：如果$n$能除尽$b$得到$y$，我们直接选**第y项**不就行了~

**3. 当两个都等于零时**：用我再说一遍吗？。。。开始已经判掉了。。。

**4. 当两个都不等于零时：** 我们发现我们希望$y$越大越好，因为每个数只能选一次，而且$b$的系数有无数个取值，$y$越大我们选择的空间就越大。

而限制是：$x$必须是正整数，我们尽量让$x$小，$y$就能很大，于是，解出$x$的最小正整数解。这里有个细节：$x$不是自然数，而是正整数。如果你解出来的$x$是$0$，你必须再把$x$加数变成正数。（害的我WA了次）。

我们解出了$x$的最小解，发现这$x$即为项数（不考虑$A[0]$与$b$的关系，假设你的$A[0]$就是选择每一项中的$A[0]$，$b$就是每一项中的$b$），那么在什么时候符合$y$能够变成每一项$b$的系数和呢？

很显然我们从小开始选择，因为想让$y$剩余的越大越好。那么选择$x$项，$y$最小即为$(1+2+3+...+x) = (1+x)*x/2;$ 只要$y$比此值大，$y$可以用$x$项$b$的系数表示，就有解了，否则无解。

所有情况考虑完了，就放代码吧，~~感觉我的码风还是勉强可以的：~~

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long             //记得开long long， 在x*(x+1)/2的时候会爆int 
using namespace std;
ll T,ans,  x,y,  a,b,n,A[123];   //A数组开很小就行了，因为数量是log级的。

ll exgcd(ll aa,ll bb) {          //板子 
	if(!bb) {
		x = 1; y = 0;
		return aa;
	}
	ll res = exgcd(bb,aa%bb);
	ll t = x; x = y; y = t - aa/bb * y;
	return res;
}

void work1() {                    //a>1时的情况 
	int now = 0;
	while(A[now] < n) { now++; A[now]=A[now-1]*a+b; } //计算每一项，大于n后跳出。 
	for(int i=now;i>=1;i--) if(n>=A[i]) n -= A[i];   //能减就减 
	if(!n) ans++;                 //n可以被表示，ans++ 
}

void work2() {                     //a=1时的情况，看不懂的话去做青蛙的约会 
	ll GCD = exgcd(A[0],b); if(n%GCD) return ;
	n /= GCD; b /= GCD; A[0] /= GCD;
	x = x*n % b; x = (x+b) % b; 
	if(x==0) x += b;               //注意：x必须是正整数！ 
	y = (n-A[0]*x) / b;
	if(y >= (x*(x+1)/2) ) ans++;   //y可以表示成b的系数的和，ans++ 
}

int main() {
	scanf("%lld",&T);
	while(T--) {
		scanf("%lld%lld%lld%lld",&A[0],&a,&b,&n);
		if(!A[0] && !b) { if(n==0) ans++; continue; }   //A[0]与b都为零时的特判，记得continue！ 
		if(n==0) continue;         //若此时n=0，必然无解，continue 
		if(a > 1) work1();
		else {
			if(!A[0]) { if(n%b==0) ans++; }
			else if(!b) { if(n%A[0]==0) ans++; }
			else work2();
		}
	}
	printf("%lld",ans);
	return 0;
}

```

---


# [AHOI2014/JSOI2014] 保龄球

## 题目背景

JYY 很喜欢打保龄球，虽然技术不高，但是还是总想着的高分。这里 JYY 将向你介绍他所参加的特殊保龄球比赛的规则，然后请你帮他得到尽量多的分数。


## 题目描述

一场保龄球比赛一共有 $n$ 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。

对于每一个轮次，有如下三种情况：

1、 “全中”：如果选手第一次尝试就击倒了全部十个木瓶，那么这一轮就为“全中”。在一个“全中”轮中，由于所有木瓶在第一次尝试中都已经被击倒，所以选手不需要再进行第二次投球尝试。同时，在计算总分时，选手在下一轮的得分将会被乘2计入总分。

2、“补中”：如果选手使用两次尝试击倒了十个木瓶，那么这一轮就称为“补中”。同时，在计算总分时，选手在下一轮中的第一次尝试的得分将会以双倍计入总分。

3、“失误”：如果选手未能通过两次尝试击倒全部的木瓶，那么这一轮就被称为“失误”。同时，在计算总分时，选手在下一轮的得分会被计入总分，没有分数被翻倍。此外，如果第 $n$ 轮是“全中”，那么选手可以进行一次附加轮：也就是，如果第 $n$ 轮是“全中”，那么选手将一共进行 $n+1$ 轮比赛。显然，在这种情况下，第 $n+1$ 轮的分数一定会被加倍。

附加轮的规则只执行一次。也就是说，即使第 $n+1$ 轮选手又打出了“全中”，也不会进行第 $n+2$ 轮比赛。因而，附加轮的成绩不会使得其他轮的分数翻番。最后，选手的总得分就是附加轮规则执行过，并且分数按上述规则加倍后的每一轮分数之和。

JYY 刚刚进行了一场 $n$ 个轮次的保龄球比赛，但是，JYY非常不满意他的得分。JYY想出了一个办法：他可以把记分表上，他所打出的所有轮次的顺序重新排列，这样重新排列之后，由于翻倍规则的存在，JYY就可以得到更高的分数了！

当然了，JYY不希望做的太假，他希望保证重新排列之后，所需要进行的轮数和重排前所进行的轮数是一致的：比如如果重排前JYY在第 $n$ 轮打出了“全中”，那么重排之后，第 $n$ 轮还得是“全中”以保证比赛一共进行 $n+1$ 轮；同样的，如果 JYY 第 $n$ 轮没有打出“全中”，那么重排过后第 $n$ 轮也不能是全中。请你帮助 JYY 计算一下，他可以得到的最高的分数。


## 说明/提示

【样例说明】  
按照输入顺序，JYY 将得到 $37$ 分。
最佳方案是排列成如下顺序：
```plain
3 7
10 0
5 2
```

【数据范围】
对于 $100\%$ 的数据，$1\le n \le 50$。


## 样例 #1

### 输入

```
2
5 2
10 0
3 7```

### 输出

```
44```

# 题解

## 作者：zxtikes (赞：9)

## 前言

当一个蒟蒻开始了今天的做题，欣喜地开启了一道题。经过几番思索之后，果断地开始写起了 **模拟退火**。

很显然，如果我们考虑动态规划，会发现状态很多，难以储存；如果我们考虑搜索，枚举每一个可能的序列，再计算出最大得分，复杂度是 $O(n!)$，很明显的 TLE 瞬间起飞。接下来思考其他的做法，都是一筹莫展。

最后还是选择我们的 **模拟退火**，~~模拟退火骗分就是好~~。


------------


## 说明

接下来讲解一下模拟退火大概是什么东西。

模拟退火适用于具有连续性的函数，具体地讲，是适用于，将一个问题的解决方式进行细微改变，所得到的答案改变也不会非常大的问题。

模拟退火不一定能得到真正的最优解，但是可以得到一个函数的 **局部最优解**，所以我们进行模拟退火一般进行多次，从而得到多个局部最优解，这样子，我们得到全局最优解的概率就大大提升。

模拟退火所求函数一般不规则，但是具有一定连续性。

例如如下函数：

![](https://cdn.luogu.com.cn/upload/image_hosting/9bdsg0y0.png)

其中 $A, B, C$ 都是一个局部最优解，但我们观察到，$B$ 才是全局最优解，但是我们一次退火很难保证就很求到 $B$ 这个答案，所以要多次退火，才会有更大的概率得到全局最优解。

通常，模拟退火有如下几个概念：

1. 初始温度 $T_0$，表示最开始随机的范围大小。

2. 终止温度 $T_E$，表示我们这次退火结束的温度。一般情况下 $T_E \rightarrow 0$ 。

3. 衰减系数 $T_x$， $0<T_x<1$ 表示每一次退火温度的衰减值。一般情况下 $T_x>0.9$ ，这样子才能保证所得到的答案足够精确，如果 $T_x<0.9$ ，那么所得到的答案就很难保证是最优解了，虽然~~退火本身就玄学~~。

4. 概率 $P$ ，表示我们从一个候补答案，更新为另一个候补答案的概率。其中，如果我们的新候补答案大于当前答案，那么概率 $P=1$ 也就是一定会更新答案；否则，我们将以一定的概率来决定是否更新。一般情况下，这个概率为：$P=e^{-\Delta/t}$ （题目要求求最大值），或者，$P=e^{\Delta/t}$ （题目要求求最小值） ，其中 $\Delta=new-now$， $new$ 表示新候补答案，$now$ 表示当前答案，$t$ 一般情况下会用来表示答案变化范围，普遍性取值为温度 $T$ ，这样保证 $0<P<1$ ，并且 $P$ 随着 $\Delta$ 的改变而改变，具体改变是正相关还是负相关，与题目求是最大值还是最小值有关。

以上 $T_x$ 主要决定了模拟退火的复杂度，$T_x$ 越大，复杂度越低，所得到的答案的精确度越高。

经过个人测试，此题需要要求 $T_x>0.94$， ~~别问我怎么测出来的~~。

------------

## 题目分析

在本题中，对于每个轮次，有三种情况：全中，补中，失误。我们需要将打出的所有轮次的顺序重新排列，使得得分最高。

其中，补中会使选手在下一轮中的第一次尝试的得分将会以双倍计入总分。失误的情况属于一般情况，不具有特殊性，所以不做处理。最重要的是全中的情况。全中会使选手在计算总分时，下一轮的得分将会被乘 $2$ 计入总分，最需要 **特殊处理** 的是，当原来最后一轮次全中，我们在重新排列的时候，也需要最后一轮次是全中，因为这样子才会有奖励的轮次，需要进行的轮数和重排前所进行的轮数是一致的，才满足题意。

本题目中，我们用温度 $T$ ，表示答案更新范围，当 $T \rightarrow 0$，也就是达到终止温度 $T_E$ 时，我们就获得了一个候补答案。

最后我们进行多次退火就可以了。

什么？你说你不知道该进行多少次退火？不会计算复杂度？

这里有一个很方便的函数，可以帮助你卡着时间过，让你放心且愉悦。

```cpp
while ((double)clock()/CLOCKS_PER_SEC<0.8)
```

$\text{clock}$ 是一个表示时间单位的函数，具体怎么表示，~~我也不清楚~~，每个编译器版本不同，这个函数表示的时间单位一般不同。但是我们有一个表示单位时间为 $1s$ 的常量 $\text{CLOCKS\_PER\_SEC}$，我们用 $\text{clock}$ 相除就可以换算成以秒作为单位的数了。在题目时间限制为 $1s$ 时，一般我们循环条件是小于 $0.8$ ，因为如果是 $0.9$ 以上，或者直接为 $1$ ，是可能会超时的，因为最后一次模拟退火万一时间复杂度突然高起来，就会造成这种情况，所以为了保险，一般就是 $0.8$ 。 

如果你不喜欢用卡时，那么这个退火的次数一般进行 $1000 \sim 5000$ 次。

一般 $T_x$ 越大 ，这个次数可以适当低，但最好让次数多一些。

经过测试，当 $T_x=0.95$ 时，次数需要等于2000，只有90分，3000就可以成功 AC 。~~别问我怎么知道的~~。

所以还是卡时安心一些。

对于每次的新的答案，我们用函数 $\text{calc}$ 求出，求得方式与题意相同。

------------

## 代码展示

说了很多话，大家看的其实还是很抽象的，所以还是放代码，帮助大家理解一下实现的思路。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;++i)
#define per(i,r,l) for(register int i=r;i>=l;--i)
#define x first
#define y second
using namespace std;
const int N=55;
typedef pair<int,int> pii;

int n,m;
pii q[N];//pair 存储每一个轮次 
int ans;
inline int calc(){//计算函数 
	int ret=0;
	rep(i,1,m){
		ret+=q[i].x+q[i].y;
		if(i<=n){
			if(q[i].x==10)ret+=q[i+1].x+q[i+1].y;//全中情况 
			else if(q[i].x+q[i].y==10)ret+=q[i+1].x;// 补中情况 
		}
	}
	ans=max(ans,ret);// 更新答案 
	return ret;
}
inline void simulate_anneal(){//模拟退火函数 
	
	// 初始温度T0 1e4 终止温度Te 1e-4 衰减系数Tx 0.97 
	for(double t=1e4;t>1e-4;t*=0.97){
		int a=rand()%m+1,b=rand()%m+1;
		int now=calc();
		swap(q[a],q[b]);//得到下一个随机的情况 
		if(n+(q[n].x==10)==m){
			int nxt=calc();//得到下一个答案的情况 
			int delta=nxt-now;//求答案改变量delta 
			if(exp(delta/t)<(double)rand()/RAND_MAX)swap(q[a],q[b]);//以一定的概率是否更新答案 
		}
		else swap(q[a],q[b]);
	}
}
int main(){
	scanf("%d",&n);
	rep(i,1,n)scanf("%d%d",&q[i].x,&q[i].y);
	if(q[n].x==10)m=n+1,scanf("%d%d",&q[m].x,&q[m].y);//处理最后一轮次情况 
	else m=n;
	while ((double)clock()/CLOCKS_PER_SEC<0.8)simulate_anneal();//卡时  模拟退火 
	printf("%d\n",ans);//输出答案 
	return 0;
}
```


---

## 作者：crescentic (赞：4)

~~众所周知，**模拟退火**这个东西是要看 $rp$ 的。~~

[题目链接](https://www.luogu.com.cn/problem/P4044)

------------

首先，理解题意，有以下规则：

- 每轮的得分为两次所扔中瓶子的数量之和。
- 每轮**共计十**个瓶，可以扔**两**次，如果第一次扔满，就没有第二次，同时会多奖励下一轮的总得分（即“全中”）。
- 如果两次**一共扔满十个球**，就多奖励下一轮的第一次得分（即“补中”）注意该操作**不与“全中”重复计算**。
- 如果最后一轮出现“全中”，可再来一轮，但**仅限一次**。不管下次如何，都不再来。

理解题意之后就好做了，直接**模拟退火**。

因为游戏轮数保持不变，只有每轮得分顺序发生改变。所以我们可以先保持输入顺序不变，每次枚举任意两轮，暴力计算**两轮分数交换**后的得分情况。如果得分增大，就直接交换；如果没有，就以概率决定是否交换。**记得答案要取最大值。** 

最后要注意的就是：

- 输入时可以从 $0$ 开始，方便后面随机取模得到轮数。
- 在交换得分顺序后，要判断最后一轮的情况（当前状态的游戏轮数）是否满足初始状态的游戏轮数。
- 因为是模拟退火嘛，所以直接卡时就好了，$0.8s$ 以内应该都可以的。

输出答案，就完事啦。


------------
**代码**

```cpp
#include<cstdio>
#include<ctime>
#include<cmath>
#include<algorithm>
#include<cstdlib>
using namespace std;
#define rt register int
const int N = 55;
int n,m,a,b,ans,tmp,res,tim,num;
char s;
struct node {
	int x,y;
}g[N];
inline void read(int &x) {
	x = 0, s = getchar();
	while(s < '0' || s > '9') s = getchar();
	while(s <= '9' && s >= '0') x = x * 10 + s - '0', s = getchar();
} 
inline int cale() {
	res = 0;
	for(rt i = 0; i < m; i ++) {
		res += g[i].x + g[i].y;
		if(i < n) {
			if(g[i].x == 10) res +=  g[i + 1].x + g[i + 1].y;
			else if(g[i].x + g[i].y == 10) res += g[i + 1].x;
		}
	}
	ans = max(ans,res);
	return res;
} 
inline void simulate_anneal() {
	for(double i = 1e4; i > 1e-6; i = i * 0.999) {
		a = rand() % m, b = rand() % m;
		num = cale();
		swap(g[a],g[b]);
		if(n + (g[n - 1].x == 10) == m) {
			tim = cale(), tmp = tim - num;
			if(exp(tmp / i) < (double)rand() / RAND_MAX) swap(g[a],g[b]);
		}
		else swap(g[a],g[b]);
	}
}
int main() {
	read(n);
	m = n;
	for(rt i = 0; i < n; i ++) read(g[i].x), read(g[i].y);
	if(g[n - 1].x == 10) read(g[n].x), read(g[n].y), m++;
	while((double)clock() / CLOCKS_PER_SEC < 0.2) simulate_anneal();
	printf("%d",ans);
	return 0;
}
```

---

## 作者：惟有泪千行 (赞：3)

#### ~~你可曾见过一个来自奇怪地方的猴子算法~~

看了题解区里的模拟退火和DP,我觉得其实模拟退火在此题不能太体现模拟退火的优势，因为我们随便手玩一下就可以发现，在不断调整至最优时得到的分数应该是单调不减的（~~也可能是数据过水~~），总之每次交换后时直接判定转移或不转移，就可以轻松地过掉这道题（目前最优解第4）QWQ

code

```cpp
#include<bits/stdc++.h>
#define N 55
using namespace std;
inline int read(){
	int x=0;char ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
pair<int,int>p[N];
int n,m,ans; 
int sum()
{
    int cur=0;
    for(int i=1;i<=n+m;++i)
    {
        cur+=p[i].first+p[i].second;
        if(p[i-1].first==10) cur+=p[i].first+p[i].second;
        else if(p[i-1].first+p[i-1].second==10) cur+=p[i].first;
    }
    return cur;
}
int main(){
	srand(time(0));
	n=read();
	for(register int i=1;i<=n;++i)p[i].first=read(),p[i].second=read();
	if(p[n].first==10)m=1,p[n+1].first=read(),p[n+1].second=read();
	for(register int i=1;i<=5e3;++i){
		int x=rand()%(n+m)+1;
		int y=rand()%(n+m)+1,ct;
		while(x==y||(m&&(x==n||y==n))) x=rand()%(n+m)+1,y=rand()%(n+m)+1;
		swap(p[x],p[y]);
		ct=sum();
		if(ct>=ans)ans=ct;
		else swap(p[x],p[y]);
	}
	printf("%d\n",ans);
	return 0;
}
```

其实这道题也没有大家想象的那么难，主要是~~玄学~~调28行的转移次数，~~当然你愿意写奇怪的DP我也不反对~~。至于复杂度应该就是O（循环次数 * n）吧（反正能过）。

---

## 作者：moosssi (赞：1)

模拟退火。

先随机一个序列，找临近状态。

对于序列，可以直接随机枚举两个位置交换，即可达到临近状态，但这里要注意，要判断交换前后游戏轮数是否一致。

找到后，比较前后得分，如果更优，就直接更新，否则，按概率来更新，答案取最大。

```cpp
#include<bits/stdc++.h>
#include<ctime>
using namespace std;
const int N=55;
struct nod{
	int x,y;
}q[N];
int n,m,ans;
int calc(){
	int res=0;
	for(int i=0;i<m;i++){
		res+=q[i].x+q[i].y;
		if(i<n){
			if(q[i].x==10)res+=q[i+1].x+q[i+1].y;
			else if(q[i].x+q[i].y==10)res+=q[i+1].x;			
		}
	}
	ans=max(res,ans);
	return res;
}
void simulate_anneal(){
	for(double t=1e4;t>1e-4;t*=0.99){
		int a=rand()%m,b=rand()%m;
		int x=calc();
		swap(q[a],q[b]);
		if(n+(q[n-1].x==10)==m){
			int y=calc();
			int dt=y-x;
			if(exp(dt/t)<(double)rand()/RAND_MAX)swap(q[a],q[b]);
		}
		else swap(q[a],q[b]);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d%d",&q[i].x,&q[i].y);
	}
	if(q[n-1].x==10){
		m=n+1;
		scanf("%d%d",&q[n].x,&q[n].y);		
	}
	else m=n;
	for(int i=0;i<100;i++){
		simulate_anneal();
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：Hadtsti (赞：0)

### 题意简述
一场保龄球比赛一共有 $n(1\le n \le 50)$ 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。对于每一个轮次，有如下三种情况：

1. **“全中”**：第一次击倒了全部十个木瓶，此时不需要进行第二次，同时计算总分时，下一轮的得分将会被乘 $2$ 计入总分。

2. **“补中”**：经过两次才击倒了十个木瓶，计算总分时，选手在下一轮中的第一次的得分将会以双倍计入总分。

3. **“失误”**：两次尝试后仍没有击倒全部的木瓶，计算总分时，下一轮的得分不翻倍直接计入总分。

此外，如果第 $n$ 轮是“全中”，那么选手可以进行一次附加轮（也就是一共进行 $n+1$ 轮比赛）。注意附加轮的规则只执行一次，即使第 $n+1$ 轮又打出“全中”，也不会进行第 $n+2$ 轮比赛（也就是说附加轮的成绩不会使得其他轮的分数翻番）。

现在进行了 $n$ 个轮次的保龄球比赛，求将打出的所有轮次的顺序重新排列后，能得到的最高总分数（当然重排后所需要进行的轮数和重排前所进行的轮数是一致）。

### 题目分析
这个题第一眼看上去是一道状压动规，但至少我没想到状态该怎么设计(如果是将排列作为状态，$O(n!)$ 级别的复杂度无论是空间还是时间都接受不了)。而朴素暴搜的时间复杂度也是 $O(n!)$，仍然无法接受。所以我们可以采用复杂度相对低的非完美算法——**模拟退火**。

模拟退火名称中的“退火”是物理概念，笼统地说是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却，因为~~本人不知道~~对于算法本身帮助不大，所以不多加赘述，有兴趣的同学可以自行查阅资料。但是具体的算法中，需要用到的三个参数的名称和物理有点关系：**初始温度 $T_0$、终止温度 $T_E$、衰减系数 $\alpha$**。

模拟退火算法一般用来求解最优解问题。形式大致是这样的：$f_{min/max}(state)$。注意状态 $state$ 只是一个笼统的概念，可以包括多个参数，表示内容也是多样的，比如平面/空间中的一个点、许多选与不选的状态决策、以及排列等。其中，本题就可以直接认为状态是 $n$ 个轮次的一个排列。另外最优解的标准也是多样的，$f$ 函数的值同样可以包含多种信息，本题的 $f$ 值可以看作某个排列下的得分。这些体现了模拟退火算法的解决问题的广泛性与一般性。

在介绍具体的算法过程之前，先来解释下刚刚的三个参数 和别的概念**初始温度 $T_0$、终止温度 $T_E$、衰减系数 $\alpha$** 的具体含义：$T_0$ 在算法中指初始搜索步长（相对较大），$T$ 指终止搜索步长（为保证答案精确，应尽量趋于 $0$，但会增加时间），$\alpha$（$\in[0,1)$） 是搜索步长的衰减率（为保证答案精确，应尽量趋于 $1$，但也会增加时间）。（注意状态没有“步长”这个概念（比如本题）时，三个参数并不一定是这个意思，而应该具体情况具体处理，下设问题是求最小值）。

具体实现是这样的：

1. 将当前搜索步长“温度” $t$ 设置为 $T_0$，并设定一个随机状态 $state_0$。

2. 在当前决策 $state$ 的当前步长（即温度 $t$）之内再次选择一个新的随机决策 $state'$。

3. 如果 $state'$ 更优，则一定保留；但如果更劣，也不应直接选择不保留，因为 $state'$ 也有可能拓展到**全局最优解**，所以我们应有一定几率保留该决策。设  $\Delta=f(state')-f(state)$，一般保留决策的概率取 $e^{-\frac{\Delta}{t}}$（求最大值时取 $e^{\frac{\Delta}{t}}$，下同），这样就能保证 $f(state')$ 越接近最优解，保留的概率最大；越不接近最优解，保留的概率越小。具体实现时则是将 $e^{-\frac{\Delta}{t}}$ 与一个随机实数 $x\in [0,1]$ 相比较，如果 $e^{-\frac{\Delta}{t}}>x$ 则保留，反之不保留。

4. 将 $t$ 乘上 $\alpha$，并重复第 $2$~$3$ 步，如此一直到 $t\leq T_E$ 为止。

5. 将 $1$~$4$ 步总体重复 $m$ 次（$m$ 的值由答案精度以及数据步长、时限等具体定）。

6. 注意答案的选择不一定是最终保留的决策，而是应该取过程中所计算出的最优解。

然后我们算一下时间复杂度，设计算 $f(state)$ 的时间复杂度为 $O(q)$，那么总时间复杂度为 $O(mq\log_{\alpha} \frac{T_E}{T_0})$。

回到本题，本题中的状态应是 $n$ 个轮次的排列，所以也就没有“步长”这一概念，但是模拟退火的整体框架是可以应用的：我们只需要每次随机挑选两个轮次并交换，检查合法性后计算得分并比较，然后选择保留/不保留该决策即可。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
struct nd
{
    int x,y;
}q[55];
int n,m,ans;
int f()//计算得分
{
    int res=0;
    for(int i=1;i<=m;i++)
    {
        res+=q[i].x+q[i].y;
        if(i<=n)
        {
            if(q[i].x==10)
                res+=q[i+1].x+q[i+1].y;
            else if(q[i].x+q[i].y==10)
                res+=q[i+1].x;
        }
    }
    ans=max(ans,res);//用计算出的答案更新
    return res;
}
void SA()//模拟退火
{
    for(double t=1e4;t>1e-4;t*=0.99)//当前步长（温度），本代码中T0 = 1e4，TE = 1e-4，α = 0.99
    {
        int a=rand()%m+1,b=rand()%m+1;//随机挑选两个轮次
        int x=f();//f(state)
        swap(q[a],q[b]);//交换轮次
        if(n+(q[n].x==10)==m)//合法
        {
            int y=f();//f(state')
            int delta=y-x;//Δ
            if(exp(delta/t)<(double)rand()/RAND_MAX)
                swap(q[a],q[b]);//如果更劣，一定概率保留；如果更优，直接保留
        }
        else 
            swap(q[a],q[b]);//不合法，换回来
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&q[i].x,&q[i].y);
    if(q[n].x==10)
        m=n+1,scanf("%d%d",&q[n+1].x,&q[n+1].y);
    else 
        m=n;
    for(int i=1;i<=100;i++)//重复模拟退火过程，这里 m = 100
        SA();
    printf("%d",ans);
    return 0;
}
```

---

## 作者：happybob (赞：0)

模拟退火练习题。

考虑模拟退火，显然每次随机两个点并交换这两个点，不过注意要判断交换这两个点后序列是否仍然成立，也就是对于最后一轮是否交换后仍然成立，然后计算整个序列的贡献即可。

由于是模拟退火，所以显然考虑卡时，代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <random>
using namespace std;

constexpr int N(55);

int n, m, ans = 0;

clock_t c = clock();

inline int read()
{
	register char ch(getchar());
	register int x(0);
	while (ch < '0' || ch > '9')
	{
		ch = getchar();
	}
	while (ch >= '0' and ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

struct Node
{
	int a, b;
	Node(int _a, int _b) : a(_a), b(_b) {}
	Node()
	{
		a = b = 0;
	}
}q[N];

inline int calc()
{
	int res(0);
	for (register int i(1); i <= m; i++)
	{
		res += q[i].a + q[i].b;
		if (i <= n)
		{
			if (q[i].a == 10) res += q[i + 1].a + q[i + 1].b;
			else if (q[i].a + q[i].b == 10) res += q[i + 1].a;
		}
	}
	ans = max(ans, res);
	return res;
}

inline void getans()
{
	for (double t = 1e4; t > 1e-4; t *= 0.99)
	{
		int x = rand() % m + 1, y = rand() % m + 1, l(calc());
		swap(q[x], q[y]);
		if (n + (q[n].a == 10) == m)
		{
			int g(calc());
			int p(g - l);
			if (exp(p / t) < ((double)rand() / RAND_MAX)) swap(q[x], q[y]);
		}
		else swap(q[x], q[y]);
	}
}

int main()
{
	srand(time(NULL));
	n = read();
	for (register int i(1); i <= n; ++i)
	{
		int x(read()), y(read());
		q[i] = Node(x, y);
	}
	if (q[n].a == 10)
	{
		int x(read()), y(read());
		q[n + 1] = Node(x, y);
		m = n + 1;
	}
	else m = n;
	while ((double)(clock() - c) / CLOCKS_PER_SEC < 0.9) getans();
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：悬浮的气球 (赞：0)

算是一道模拟退火的模板题吧。（~~为什么朴素的模拟退火是紫题，有贪心优化的退火是蓝题啊……~~）

先看题面，我们不难发现，根据题意，每一种不同的可能解之间，变换的只有每次进球的得分次序。且进行了一次内部元素互换的序列之间总分的差值并不会过大，在整体看来，很难存在过多的峰值。

而且最重要的是：

**【数据范围】 对于** 
$ 
\begin{aligned}
	100 \%
\end{aligned}
$
**的数据**   $ 
\begin{aligned}
	1 \leq n \leq 50
\end{aligned}
$

~~赤裸裸的在引诱我们打暴力啊~~

但是，没有剪枝的暴力的时间毕竟还是太大了，而~~蒟蒻~~本人也没有想到什么优化方案。于是另一种更加聪明的暴力就呼之欲出了，即通过随机化（~~优化？~~）的暴力——模拟退火。

于是，我们考虑每次将随机两个位置进行交换。像退火一样，如果变化后的序列更优，那么直接跳入；如果变化后的序列不比当前的优秀，仍有一定概率跳入，以免得到的是局部最优解。最后逐步得出正确答案。


具体细节请见代码：

```cpp
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 60;

int n;
PII balls[N];
int res = -1e9;
bool has_extra = false;

int calc()
{
    int ans = 0;
    for (int i = 0, k1 = 1, k2 = 1; i < n; ++ i) // k1, k2为一二轮得分的权值
    {
        ans = ans + balls[i].x * k1 + balls[i].y * k2;
        if (balls[i].x == 10) k1 = k2 = 2;
        else if (balls[i].x + balls[i].y == 10) k1 = 2, k2 = 1;
        else k1 = k2 = 1;
    }
    if (has_extra) ans += (balls[n].x + balls[n].y) * 2; // 最后判断可能有的n + 1轮的得分
    
    res = max(res, ans);
    return ans;
}

void simulate_anneal()
{
    for (double t = 1e4; t > 1e-4; t =  t * 0.99) 
    {
        int pre = calc();
        int mod = n + has_extra; // 方便取模
        int p = rand() % mod, q = rand() % mod; // 还是得下标从0开始方便QAQ
        
        swap(balls[p], balls[q]);
        if (has_extra && balls[n - 1].x < 10)
        {
            swap(balls[p], balls[q]);
            continue; // 不合法跳到下个可能
        }
        
        int cur = calc();
        int delta = cur - pre;
        if (exp((double)delta / t) < (double)rand() / RAND_MAX) 
            swap(balls[p], balls[q]);
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; ++ i)
        scanf("%d%d", &balls[i].x, &balls[i].y);
    if (balls[n - 1].x == 10)
    {
        has_extra = true; // 名字很直白啦
        scanf("%d%d", &balls[n].x, &balls[n].y);
    }
    
    for (int times = 1; times <= 100; ++ times)
        simulate_anneal(); // 模拟退火
    
    cout << res << endl;
    
    return 0;
}
```


---

## 作者：Link_Space (赞：0)

阅读题目之后，我们知道了一个很重要的条件：保证游戏的总轮数不变，唯一改变的只有得分的顺序。

在此条件的基础之上，我们需要求得最大的总得分，那么有一个显然的思路：从所有的得分顺序中取其中的总得分最大的那一种得分顺序。

如何实现这个思路呢？最暴力的方法肯定是枚举所有的得分顺序，但是此题中 $n \leq 50$ ，枚举所有得分顺序的方法复杂度是阶乘级别，对于此题显然不适用。

但除此之外，仿佛也无法找到更优秀的保证正确性的做法，那么我们就只能考虑模拟退火随机化求解。

运用模拟退火的思想，对于一个初始得分顺序的序列，每一次任意交换其中两项，对交换后的序列进行求解，统计最大值。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<ctime>
#include<cmath>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1e5 + 5;
int m;
int n;
int ans;
PII game[N];
int calc()//计算当前状态下的得分
{
    int res = 0;
    for (int i = 1; i <= m;i++)
    {
        res += game[i].x + game[i].y;
        if (i <= n)
        {
            if(game[i].x==10)
                res += game[i + 1].x + game[i + 1].y;//全中的情况
            else if(game[i].x+game[i].y==10)//补中的情况
                res += game[i + 1].x;
        }
    }
    ans = max(ans, res);//更新答案
    return res;
}
void SA()
{
    for (double t = 1e4; t > 1e-4;t*=0.99)
    {
        int a = rand() % m + 1, b = rand() % m + 1;
        int xx = calc();
        swap(game[a], game[b]);
        if(n+(game[n].x==10)==m)//在保证游戏总轮数不变的情况下随机替换两轮比赛
        {
            int yy = calc();
            double delta = yy - xx;
            if(exp(delta/t)<(double)rand()/RAND_MAX)
                swap(game[a], game[b]);
        }
        else
            swap(game[a], game[b]);
    }
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n;i++)
        scanf("%d%d", &game[i].x, &game[i].y);
    if(game[n].x==10)
        m = n + 1, scanf("%d%d", &game[n + 1].x, &game[n + 1].y);//判断是否会有附加轮
    else
        m = n;
    while ((double)clock() / CLOCKS_PER_SEC < 0.8)//卡时，这道题时限卡得不紧，可以不用使用
        SA();
    printf("%d\n", ans);
}
```


---

## 作者：islandl (赞：0)

俗话说得好，看不懂的题，暴力就对了。

把轮次随机排列，也就是找一个最优的序列，需要不断交换轮次。

怎么交换呢？——我们可以选择模拟退火（优美的暴力），逐渐逼近答案。
# 解题思路
每次随机找两个位置交换，如果轮数不变，合法，则计算得分；轮数变化，不合法，再换回去重新找。

计算得分时，要处理好麻烦的 $n+1$ 轮,如果得分更大，一定降温，否则以一定概率降温，这也是模拟退火的核心步骤，没能降温的还要换回去重新找。

本题并不太需要卡时，普通的初温末温变化率即可。

注意：本题的 $t$ 并不代表步长，只影响降温概率。

另：不喜欢下标从 $0$ 开始，所以特判一下余数为 $0$ 。
    
# 代码
```cpp
#include<cstdio> 
#include<iostream>
#include<algorithm>
#include<cmath>
#include<ctime>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N=55;
int n,m;//m 一共多少轮 
PII q[N];
int ans;
int calc()
{
    int sum=0;
    for (int i=1;i<=m;i++)
    {
        sum+=q[i].x+q[i].y;
        if(i<m)
        {
            if(q[i].x==10) sum+=q[i+1].x+q[i+1].y;//全中 
            else if(q[i].x+q[i].y==10)//补中 
                sum+=q[i+1].x;
        }
    }
    ans=max(ans,sum);
    return sum;
}

void simulate_anneal()
{
    for (double t=1e4;t>1e-4;t*=0.99)//这里t不表示步长，只影响概率 
    {
        int a=rand()%m,b=rand()%m;//随机选两个位置交换
		if(a==0) a=m;
		if(b==0) b=m;
        int cur=calc();//计算当前得分 
        swap(q[a],q[b]);
        if (n+(q[n].x==10)==m)//如果轮数不变，合法 
        {
            int nxt=calc();
            int delta=nxt-cur;
            if (exp(delta/t)<(double)rand() / RAND_MAX)//后面是（0,1）随机数 
                swap(q[a],q[b]);
            //delta>0 直接更新；delta<0 有一定概率更新 
        }
        else swap(q[a],q[b]);//不合法换回去 
    }
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d%d",&q[i].x,&q[i].y);
    if (q[n].x==10) m=n+1,scanf("%d%d",&q[n+1].x,&q[n+1].y);
    else m=n;
    for(int i=1;i<=100;i++) simulate_anneal();
    printf("%d",ans);
    return 0;
}
```


---

## 作者：lhm_ (赞：0)

$DP$ 来做的话会很麻烦，细节会很多，考虑乱搞一些的做法。$n$ 很小，答案和排列顺序有关，所以考虑模拟退火来解决本题。

产生新状态即为交换当前排列的两个位置。调参时可以采取降低退火次数，升高温度和降温系数来处理，这样正确性会高。

```cpp
#include<bits/stdc++.h>
#define maxn 55
#define eps 1e-10
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,ans,cnt=1000;
struct node
{
    int a,b;
}p[maxn];
int calc()
{
    int v=0;
    for(int i=1;i<=n+m;++i)
    {
        v+=p[i].a+p[i].b;
        if(p[i-1].a==10) v+=p[i].a+p[i].b;
        else if(p[i-1].a+p[i-1].b==10) v+=p[i].a;
    }
    return v;
}
void SA()
{
    double T=1000000,delta=0.9895;
	while(T>eps)
	{
		int x=rand()%(n+m)+1,y=rand()%(n+m)+1,v;
        while(x==y||(m&&(x==n||y==n))) x=rand()%(n+m)+1,y=rand()%(n+m)+1;
		swap(p[x],p[y]),v=calc();
		if(v>ans) ans=v;
		else if(exp((v-ans)/T)*RAND_MAX<rand()) swap(p[x],p[y]);
		T*=delta;
	}
}
int main()
{
    srand((long long)new char),read(n);
    for(int i=1;i<=n;++i) read(p[i].a),read(p[i].b);
    if(p[n].a==10) m=1,read(p[n+1].a),read(p[n+1].b);
    while(cnt--) SA();
    printf("%d",ans);
    return 0;
}
```

---


# [JXOI2017] 数列

## 题目描述

九条可怜手上有一个长度为 $n$ 的整数数列 $r_i$，她现在想要构造一个长度为 $n$ 的，满足如下条件的整数数列 $A$ ：

- $1 \le A_i \le r_i$

- 对于任意 $3 \le i \le n$ ，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \le A_i \le R$ 。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\infty$ ；如果不存在小于等于 $A_{i-1} $ 的，那么 $L = -\infty$ 。

现在可怜想要知道共有多少不同的数列满足这个条件。两个数列 $A$ 和 $B$ 是不同的当且仅当至少存在一个位置 $i$ 满足 $A_i \neq B_i$ 。

## 说明/提示

| 测试点编号 | $n$ | $r_i$ |
| :----------: | :----------: | :----------: |
| $1,2$ | $n\le7$ | $r_i\le7$ |
| $3,4$ | $n\le50$ | $r_i\le10$ |
| $5,6$ | $n\le50$ | $r_i\le16$ |
| $7,8$ | $n\le50$ | $r_i\le50$ |
| $9,10$ | $n\le50$ | $r_i\le150$ |

## 样例 #1

### 输入

```
3
2 2 2```

### 输出

```
6```

# 题解

## 作者：VSEJGFB (赞：18)

发一个不一样的做法~~~~

考虑送后往前构造$A[i]$

最后两个:$A[n],A[n-1]$是可以分别在$1-r[n],1-r[n-1]$中任意选.

然后发现$A[n-2]$不能在$A[n]$与$A[n-1]$之间
但可以是$A[n]$

因为必须满足$A[n-2]> A[n-1] > A[n]$或者$A[n-2] < A[n-1] < A[n]$或三者相等

同理$A[n-3]$也满足此条件且还不能在$A[n-2]$与$A[n-1]$之间(因为上面条件限制所以$A[n-1]$也不行)。

同理$A[n-k]$……

当从后向前选至$A[i]$时，不能选的值一定为一个区间。

设$d(bt,tp,i)$为当前选择$A[i]$,不能选的区间为$[bt,tp]$

因为$A[i+1]\in [bt,tp]$所以若$A[i]=k$则由$d(k,tp,i-1),k<bt$或$d(bt,k,i-1),k>tp$转移过来。（因为$A[i-1]$不能在$A[i]$与$A[i+1]$之间。）

但有一种特殊情况即$A[n]=A[n-1]=A[n-2]=...=A[n-k]$时$A[n-k-1]$可以等于$A[n-k]$或者不等于。若不等于，则
$A[n-k-2]$可以等于$A[n-k]$（比如$A[n-2]$可以等于$A[n]$)而且此时必定$bt=tp=A[n-k]$所以bt或tp不在$A[n-k-2]$的不可取范围内。

设$d(bt,tp,i,o)$，$o=1$时满足这种情况，$o=0$则不满足。

边界$d(bt,tp,0,o)=1$.

状态$O(nr_i^2)$个，转移$O(r_i)$
记忆化搜索实际上没那么多状态
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int p=998244353;
const int N=52,R=152;
int d[R][R][N][2],r[N];
int dp(int bt,int tp,int cur,int o){
    if(cur==0) return 1;
    int bot=min(r[cur]+1,bt);
    int &ans=d[bt][tp][cur][o];
    if(ans>-1) return ans;
    ans=0;
    int k=0;
    if(bt==tp&&o){
        k=1,o=0;  //k=1时tp-1或bt+1就没有把tp或bt包含在不可取范围
        if(bt<=r[cur]) ans=(ans+dp(bt,tp,cur-1,1))%p;
    }
    for(int i=1;i<bot;i++) ans=(ans+dp(i,tp-k,cur-1,o))%p;
    for(int i=tp+1;i<=r[cur];i++) ans=(ans+dp(bt+k,i,cur-1,o))%p;
    return ans;
}
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&r[i]);
    memset(d,-1,sizeof(d));
    int ans=0;
    for(int i=1;i<=r[n];i++){
        for(int j=1;j<=r[n-1];j++){
            int k=ans;
            if(i==j) ans=(ans+dp(i,j,n-2,1))%p; 
            else if(i<j) ans=(ans+dp(i+1,j,n-2,0))%p;
            else if(i>j) ans=(ans+dp(j,i-1,n-2,0))%p;//i+1或i-1就没有把A[n]包含在不可取范围
        }
    }
    printf("%d\n",ans);
    return 0;
}

```



---

## 作者：linjingxiang (赞：3)

省流：一个极其简单的 dp 的做法。

[题目](https://www.luogu.com.cn/problem/P4063)

#### Description

九条可怜手上有一个长度为 $n$ 的整数数列 $r_i$，她现在想要构造一个长度为 $n$ 的，满足如下条件的整数数列 $A$ ：

- $1 \le A_i \le r_i$

- 对于任意 $3 \le i \le n$ ，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \le A_i \le R$ 。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\infty$ ；如果不存在小于等于 $A_{i-1} $ 的，那么 $L = -\infty$ 。

现在可怜想要知道共有多少不同的数列满足这个条件。两个数列 $A$ 和 $B$ 是不同的当且仅当至少存在一个位置 $i$ 满足 $A_i \neq B_i$ 。

 $n\le50$，$r_i\le150$ 

#### Solution

测试的时候写了一个很显然的 dp 。

从前往后填，前边的有效限制信息为：上一个是什么，下界，上界。

因此设 $dp[i][l][k][r]$ 表示填数范围 $l\sim r$ 且上一个填的是 $k$。

转移：

1. 填 $l$：$dp[i+1][l][l][l] \gets dp[i][l][k][r]$。

2. 填 $l+1\sim k-1$：$dp[i+1][l][k'][k] \gets dp[i][l][k][r]$。

3. 填 $k$：$dp[i+1][k][k][k] \gets dp[i][l][k][r]$。

4. 填 $k+1\sim r-1$：$dp[i+1][k][k'][r] \gets dp[i][l][k][r]$。

5. 填 $r$：$dp[i+1][r][r][r] \gets dp[i][l][k][r]$。

注意第 $1$ 条和第 $5$ 条转移分别要求 $l≠k$ 和 $r≠k$（否则就和第 $3$ 条重复了）。

```cpp
#include<bits/stdc++.h>
#define F(i,j,k) for(int i=j;i<=k;i++)
#define N 51
#define L 152
#define mod 998244353
using namespace std;
int dp[N][L][L][L],n,m[N],ans;
inline int mo(int x){return x<mod?x:x-mod;}
inline void add(int &x,int y){x=mo(x+y);}
inline void tran(int i,int l,int k,int r){
	if(l!=k)add(dp[i+1][l][l][l],dp[i][l][k][r]);
	F(j,l+1,k-1)add(dp[i+1][l][j][k],dp[i][l][k][r]);
	add(dp[i+1][k][k][k],dp[i][l][k][r]);
	F(j,k+1,r-1)add(dp[i+1][k][j][r],dp[i][l][k][r]);
	if(k!=r)add(dp[i+1][r][r][r],dp[i][l][k][r]);
}
int main(){
	cin>>n;
	F(i,1,n)cin>>m[i];
	F(i,1,m[1])dp[1][0][i][151]=1,tran(1,0,i,151);
	F(i,2,n-1)F(k,1,m[i])F(l,0,k)F(r,k,151)if(dp[i][l][k][r])tran(i,l,k,r);
	F(k,1,m[n])F(l,0,k)F(r,k,151)if(dp[n][l][k][r])add(ans,dp[n][l][k][r]);
	cout<<ans;
}
```

时间复杂度 $O(n\times r^4)$ 不过有剪枝跑不满。

（由于测试是 IOI 赛制，当时过了，就没再想）

然而后来打开题解发现正解时间复杂度 $O(n\times r^3)$。

---

## 作者：ywy_c_asm (赞：3)

这题的题面就比较诡异，$A_i$不能超过大于等于$A_{i-1}$的最小值，还不能小于小于等于$A_{i-1}$的最大值，还得计数？？？根据咱们最无脑的想法肯定是得知道$A_i$的取值区间也就是上面两个数才能dp对吧，但是这个好像不好计入状态啊……

然后我们仔细观察发现这个东西能转化成这么个结论：**如果$A_i>=A_{i-1}$，那么$A_{i-1}$就是小于等于$A_i$的最大值，如果$A_i>=A_{i-1}$，那么$A_{i-1}$就是大于等于$A_i$的最小值。**

这个结合题面来读读看，似乎是比较显然的吧。不过要注意如果$A_i$取了小于等于$A_{i-1}$的最大值或者大于等于$A_{i-1}$的最小值的话那么它不一定就是$A_{i-1}$，这种情况下后面的所有数都必须取$A_i$，这是个边界情况。

然后我们发现如果知道$A_{i-1}$的取值范围的话可以推出$A_i$的，那这不就能dp了？$dp[i][j][k][l]$表示前$i$个，$A_{i}=j$，小于等于$A_i$的最大值是$k$，大于等于$A_i$的最小值是$l$。

然后我们就可以有一个$O(nr^4)$的暴力做法：枚举i-1的状态，然后再枚举$A_i$的值，简单讨论一下$A_i$与$A_{i-1}$的大小关系把$k$和$l$讨论出来。这是个顺推的dp。

其实虽然在这种计数dp题里顺推法比较好想好写，但是它确实不如逆推法有优化的余地，逆推怎么做呢？我们枚举$A_{i}$的状态然后要找$A_{i-1}$的状态转移，然后除非$j=k=l$的时候我们要判断$A_i$与$A_{i-1}$或者上个$k$和$l$相等的情况，剩下的则是$A_{i-1}=k$或者$A_{i-1}=l$，你这时候要枚举$l$或$k$，这还是$O(nr^4)$的，但是这个时候就可以用前缀和和后缀和优化到$O(nr^3)$了。

上代码~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define p 998244353
using namespace std;
namespace ywy {
	int dp[2][153][153][153], qz[2][153][153][153], hz[2][153][153][153], ints[111];
	void ywymain() {
	    int n;
	    cin >> n;
	    int mx = 0;
	    for (register int i = 1; i <= n; i++) cin >> ints[i], mx = max(mx, ints[i]);
	    mx++;
	    for (register int i = 1; i <= ints[1]; i++) dp[1][i][0][mx] = 1;
	    for (register int j = 1; j <= ints[1]; j++) {
	        for (register int l = j; l <= mx; l++) {
	            qz[1][j][0][l] = dp[1][j][0][l];
	            for (register int k = 1; k <= mx; k++) qz[1][j][k][l] = (qz[1][j][k - 1][l] + dp[1][j][k][l]) % p;
	        }
	        for (register int k = 0; k <= j; k++) {
	            hz[1][j][k][mx] = dp[1][j][k][mx];
	            for (register int l = mx - 1; l >= 0; l--)
	                hz[1][j][k][l] = (hz[1][j][k][l + 1] + dp[1][j][k][l]) % p;
	        }
	    }
	    for (register int i = 2; i <= n; i++) {
	        for (register int j = 0; j <= mx; j++) {
	            for (register int k = 0; k <= mx; k++) {
	                for (register int l = 0; l <= mx; l++) {
	                    dp[i & 1][j][k][l] = qz[i & 1][j][k][l] = hz[i & 1][j][k][l] = 0;
	                }
	            }
	        }
	        for (register int j = 1; j <= ints[i]; j++) {
	            for (register int k = 0; k <= j; k++) {
	                for (register int l = j; l <= mx; l++) {
	                    if (j == k && j != l)
	                        continue;
	                    if (j == l && j != k)
	                        continue;
	                    if (l == k && l != j)
	                        continue;
	                    if (j == k && j == l) {
	                        for (register int a = 0; a <= j; a++) {
	                            for (register int b = j; b <= mx; b++)
	                                dp[i & 1][j][k][l] = (dp[i & 1][j][k][l] + dp[(i - 1) & 1][j][a][b]) % p;
	                        }
	                        for (register int a = k + 1; a <= ints[i - 1]; a++) {
	                            for (register int b = a + 1; b <= mx; b++) {
	                                dp[i & 1][j][k][l] = (dp[i & 1][j][k][l] + dp[(i - 1) & 1][a][k][b]) % p;
	                            }
	                        }
	                        for (register int a = 1; a <= ints[i - 1] && a < l; a++) {
	                            for (register int b = 0; b < a; b++) {
	                                dp[i & 1][j][k][l] = (dp[i & 1][j][k][l] + dp[(i - 1) & 1][a][b][l]) % p;
	                            }
	                        }
	                    } else {
	                        if (k) {
	                            dp[i & 1][j][k][l] = (qz[(i - 1) & 1][k][k - 1][l] + dp[i & 1][j][k][l]) % p;
	                        }
	                        if (l != mx) {
	                            dp[i & 1][j][k][l] = (hz[(i - 1) & 1][l][k][l + 1] + dp[i & 1][j][k][l]) % p;
	                        }
	                    }
	                }
	            }
	            for (register int l = j; l <= mx; l++) {
	                qz[i & 1][j][0][l] = dp[i & 1][j][0][l];
	                for (register int k = 1; k <= j; k++)
	                    qz[i & 1][j][k][l] = (qz[i & 1][j][k - 1][l] + dp[i & 1][j][k][l]) % p;
	            }
	            for (register int k = 0; k <= j; k++) {
	                hz[i & 1][j][k][mx] = dp[i & 1][j][k][mx];
	                for (register int l = mx - 1; l >= 0; l--) {
	                    hz[i & 1][j][k][l] = (hz[i & 1][j][k][l + 1] + dp[i & 1][j][k][l]) % p;
	                }
	            }
	        }
	    }
	    int ans = 0;
	    for (register int i = 1; i <= ints[n]; i++) {
	        for (register int j = 0; j <= i; j++) {
	            for (register int k = i; k <= mx; k++) ans = (ans + dp[n & 1][i][j][k]) % p;
	        }
	    }
	    cout << ans << endl;
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：Lucyna_Kushinada (赞：2)

# P4063 \[JXOI2017] 数列

## 题意

给定长度为 $n$ 的整数数列 $r_i$，构造长度为 $n$ 的序列 $A$ 的规则如下：

- $1 \le A_i \le r_i$。

- 对于任意 $3 \le i \le n$，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \le A_i \le R$。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\infty$；如果不存在小于等于 $A_{i-1}$ 的，那么 $L = -\infty$。

请求出可以构造出多少种不同的序列 $A$。

$n\le 50,r_i\le 150$。

## 题解

知识点：动态规划。

小水题。

设出状态 $dp_{i,l,r,x}$ 表示当前选到第 $i$ 个，第 $i-1$ 个选的是 $x$，且满足 $L=l,R=r$。

定义状态为一个三元组 $(l,r,x)$，它会经历若干个形如 $(l,r,x)\to (l',r',x')$ 的过程，这个过程中从 $[l,r]$ 到 $[l',r']$，区间只会不断缩小，这是容易证明的。

显然有 $l\le x\le r$。

设当前选了数 $y$，则有以下几个转移的可能：

$(l,r,x)\to (y,y,y)$，当且仅当 $y$ 等于 $l,r,x$ 中任意一个，说明前面存在即 $\ge y$ 又 $\le y$ 的数，那么就是 $y$。

$(l,r,x)\to (x,r,y)$，当且仅当 $y>x$。

$(l,r,x)\to (l,x,y)$，当且仅当 $y<x$。

到这里已经可以写出朴素的 dp 转移了，时间复杂度 $O(nv^4)$，不足以通过此题。

考虑优化，发现第一种转移只会有常数次，第二种和第三种的转移范围都是一个区间，所以可以在 dp 数组上作差分以区间加，最后在做一遍前缀和即可，时间复杂度 $O(nv^3)$，勉强能过。

至于 dp 的初始状态，枚举前两个数的取值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define bg(x) (x).begin()
#define ed(x) (x).end()

#define N 55
#define V 155
#define int long long

const int mod=998244353;
int n,a[N],f[V][V][V],g[V][V][V],s[V][V][V];

inline void add(int &x,int y){
    x=(x+y+mod)%mod;
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    cin>>n;

    int lim=0;

    rep(i,1,n){
        cin>>a[i];
        lim=max(lim,a[i]);
    }

    lim++;

    rep(i,1,a[1]){
        rep(j,1,a[2]){
            if(i<j){
                f[i][lim][j]=1;
            }
            else if(i>j){
                f[0][i][j]=1;
            }
            else{
                f[i][i][i]=1;
                //spec
            }
        }
    }

    rep(i,3,n){
        memset(g,0,sizeof g);
        memset(s,0,sizeof s);

        rep(l,0,lim-1){
            rep(r,max(1ll,l),lim){
                rep(k,max(1ll,l),min(r,a[i-1])){
                    if(!f[l][r][k]){
                        continue;
                    }

                    int re=f[l][r][k];

                    vector<int>sp={l,k,r};
                    sp.erase(unique(all(sp)),ed(sp));

                    for(int x:sp){
                        if(x<1||x>a[i]){
                            continue;
                        }

                        add(g[x][x][x],re);

                        // cout<<x<<' '<<x<<' '<<x<<" add1\n";
                    }

                    if(l+1<=k-1){
                        add(s[l][k][l+1],re);
                        add(s[l][k][k],-re);
                    }

                    if(k+1<=r-1){
                        add(s[k][r][k+1],re);
                        add(s[k][r][r],-re);
                    }
                }
            }
        }

        rep(l,0,lim-1){
            rep(r,max(1ll,l),lim){
                rep(k,1,max(1ll,l)-1){
                    add(s[l][r][k],s[l][r][k-1]);
                }

                rep(k,max(1ll,l),min(r,a[i])){
                    add(s[l][r][k],s[l][r][k-1]);
                    add(g[l][r][k],s[l][r][k]);
                }
            }
        }

        memcpy(f,g,sizeof g);
    }

    int ans=0;

    rep(i,0,lim){
        rep(j,0,lim){
            rep(k,0,lim){
                // cout<<i<<' '<<j<<' '<<k<<' '<<f[i][j][k]<<"\n";
                ans=(ans+f[i][j][k])%mod;
            }
        }
    }

    cout<<ans;

    return 0;
}
```

---

## 作者：asuldb (赞：1)

[题目](https://www.luogu.org/problem/P4063)

一个不太一样的做法

当$A_{i-1}=x$，称$A_1$到$A_{i-2}$中大于等于$A_{i-1}$的最小值$R$为上界，$A_1$到$A_{i-2}$中小于等于$A_{i-1}$的最大值$L$为下界。对于一组$(L,R,x)$显然有$L\leq x\leq R$，我们下一个能填的数也只能在这个范围内。

当我们$A_i=y$的时候，考虑新的上下界分别是谁。

当$x\leq y\leq R$的时候，显然小于等于$y$中最大的是$x$，大于等于$y$中最大的是$R$，所以新的下界是$x$，上界$R$，三元组变成了$(x,R,y)$

当$L\leq y< x$的时候，新的上界是$x$，下界是$L$，三元组变成了$(L,x,y)$

到这里我们就可以写一个dp了，设$f_{i,j,k,p}$表示填了$i$个数，末尾三元组的状态是$(j,k,p)$，转移的时候枚举下一位填什么推出下一个三元组即可。状态数是$O(nr_i^3)$，转移是$O(r_i)$的，复杂度是$O(nr_i^4)$不是很能接受

再观察一下这个dp的转移，发现它非常别致，我们枚举下一位填的数$y$

当$p\leq y\leq k$，$f_{i,j,k,p}$向$f_{i+1,x,k,y}$转移，**这个转移和$j$这一维没有关系**

当$j\leq y< p$，$f_{i,j,k,p}$向$f_{i+1,j,x,y}$转移，**这个转移和$k$这一维没有关系**

考虑一下是否可以去掉一维，上下界中只保存一个能否进行转移

显然是可以的，设$dp_{i,j,k}$表示当前填了$i$个数，上/下界为$j$，末尾填的数为$k$。我们强行规定当$k\leq j$的时候，$j$为上界；当$k>j$的时候，$j$为下界

即对于原来的$f_{i,j,k,p}$拆分成了两个状态$dp_{i,j,p}$和$dp_{i,k,p}$，这两个状态各自完成$f_{i,j,k,p}$的一部分转移。其中$dp_{i,j,p}$负责$j\leq y<p$的转移；$dp_{i,k,p}$负责$p\leq y\leq k$的转移。**注意转移之后得到的仍旧是一个完整的上下界都有的状态，我们还是要把这个状态拆分一下**。

转移的时候还是枚举下一位填什么数，根据填的数推出转移的状态即可。注意当一下位填的数和上下界相等时，新的上下界就固定了。

这样的状态数就变成了$O(nr_i^2)$，复杂度是$O(nr_i^3)$，不知道为什么跑的比较快，luogu最优解，loj位列rk3

代码

```cpp
#include<bits/stdc++.h>
#define re register
#define max(a,b) ((a)>(b)?(a):(b))
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
const int maxn=155;
const int mod=998244353;
inline int qm(int x) {return x>=mod?x-mod:x;}
int h[55],n,o,R,dp[2][maxn][maxn];
int main() {
	n=read();for(re int i=1;i<=n;i++) h[i]=read(),R=max(R,h[i]);R++;
	for(re int i=1;i<=h[2];++i) 
		for(re int j=1;j<=h[1];++j) {
			if(j>=i) {if(i!=j) dp[0][i][0]++;}
			else dp[0][i][R]++;
			dp[0][i][j]++;
		}
	for(re int i=3;i<=n;i++,o^=1) {
		memset(dp[o^1],0,sizeof(dp[o^1]));
		for(re int j=1;j<=h[i-1];j++)
			for(re int k=0;k<=R;++k) {
				if(!dp[o][j][k]) continue;
				if(k<j) {
					for(re int p=k;p<j;p++)
					if(p<=h[i]&&p>0) {
						if(p==k) {
							dp[o^1][p][p]=qm(dp[o^1][p][p]+dp[o][j][k]);
							continue;
						}
						dp[o^1][p][k]=qm(dp[o^1][p][k]+dp[o][j][k]);
						dp[o^1][p][j]=qm(dp[o^1][p][j]+dp[o][j][k]);
					}
				}
				else {
					for(re int p=j;p<=k;++p)
					if(p<=h[i]&&p>0) {
						if(p==j||p==k) {
							dp[o^1][p][p]=qm(dp[o^1][p][p]+dp[o][j][k]);
							continue;
						}
						dp[o^1][p][j]=qm(dp[o^1][p][j]+dp[o][j][k]);
						dp[o^1][p][k]=qm(dp[o^1][p][k]+dp[o][j][k]);
					}
				}
			}
	}
	int ans=0;
	for(re int i=1;i<=h[n];++i)
		for(re int j=i;j<=R;++j) ans=qm(ans+dp[o][i][j]);
	return !printf("%d\n",ans);
}
```





---

## 作者：aeiouaoeiu (赞：0)

考虑顺推时会发生什么。

假设现在决策 $a_i$，前一个数是 $x$，得到的上下界为 $L,R$，$a_i$ 可以取 $[L,\min(R,r_i)]$ 中任意一个整数。

现在如果确定了 $a_i$，$L,R$ 分别会有什么变化？如果 $a_i$ 落在 $(L,x)$ 中，有 $L\to L',x\to R'$；如果 $a_i$ 落在 $(x,r)$ 中，有 $x\to L',R\to R'$；如果 $a_i$ 落在 $L,x,R$ 中任意一个，由于 $L,x,R$ 都在之前出现过，$L',R'$ 会锁定为一个单独的值。

发现每一次决策都只与 $L,R,x$ 有关，于是进行 dp，把 $L,R,x$ 都扔进状态里。$a_i$ 落在 $L,x,R$ 中任意一个的转移是 $\mathcal{O}(1)$ 的，无需额外处理。对于剩下两种情况，则有转移 $f_{L,R,x}\to f'_{L,x,y}(L<y<x),f_{L,R,x}\to f'_{x,R,y}(x<y<R)$，发现转移均形如一个区间，直接差分处理即可。

时间复杂度：$\mathcal{O}(nR^3)$，其中 $R=\max r_i$。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define mp make_pair 
#define pob pop_back
using namespace std;
typedef long long ll;
typedef double db;
const ll maxn=157,ee=1e18,p=998244353;
ll n,a[maxn],f[maxn][maxn][maxn],g[maxn][maxn][maxn],ans;
void add(ll &a,ll b){a=(a+b>=p)?(a+b-p):(a+b);}
void mul(ll &a,ll b){a=(a>b)?(a-b):(a+p-b);}
int main(void){
	//freopen("data.in","r",stdin); 
	//freopen("data.out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=a[1];i++) f[0][151][i]=1;
	for(int i=2;i<=n;i++){
		memset(g,0,sizeof(g));
		for(ll L=0,l,r,c;L<=151;L++)for(ll R=L;R<=151;R++)for(ll x=L;x<=R;x++){
			c=f[L][R][x];
			if(!c) continue;
			l=L+1,r=min(x-1,a[i]);
			if(l<=r) add(g[L][x][l],c),mul(g[L][x][r+1],c);
			l=x+1,r=min(R-1,a[i]);
			if(l<=r) add(g[x][R][l],c),mul(g[x][R][r+1],c);
			if(L<=a[i]&&L) add(g[L][L][L],c),mul(g[L][L][L+1],c);
			if(R<=a[i]&&R<=150&&L!=R) add(g[R][R][R],c),mul(g[R][R][R+1],c);
			if(x<=a[i]&&L!=x&&R!=x) add(g[x][x][x],c),mul(g[x][x][x+1],c);
		}
		for(ll L=0;L<=151;L++)for(ll R=L;R<=151;R++)for(ll x=L;x<=R;x++) add(g[L][R][x],g[L][R][x-1]);
		memcpy(f,g,sizeof(f));
	}
	for(ll L=0;L<=151;L++)for(ll R=L;R<=151;R++)for(ll x=L;x<=R;x++) add(ans,f[L][R][x]);
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：yyxmy (赞：0)

我们可以知道$a_i$之前的数按从大到小的顺序排序之后， ..... < $L$ $\leq$ $a_{i-1}$ $\leq$ $R$ < ....

因为要求 $ L\leq a_i \leq R$, 那么$a_i$可以填的区间为[L, $a_{i-1}$]和[$a_{i-1}$, R]， 有一个朴素$dp$，

即$dp[i][k][l][r]$表示考虑到第i位， 当前填k， l为前驱， r为后继的方案数， 转移的话， 我们知道，

$l$和$r$其中必定有一个是上一位填的数， 那么我们可以对l和r分别维护一个后缀和， 这样就可以O(1)

转移了, 要注意填的数和$l$或$r$相同的时候要特判一下， 因为比如 $k=1,l=0, r=1$这个状态是不存在的。

```cpp
#include<bits/stdc++.h>
#define reg register
#define maxn 152
#define mod 998244353
using namespace std;
inline int  read() {
    reg int s = 0, t = 0; reg char ch = getchar();
    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();
    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return t ? -s : s;
}
int n, dp[maxn][maxn][maxn], R[maxn], f[maxn][maxn], g[maxn][maxn], ans, w[maxn];
int main(){
    n = read();
    for(int j = 1; j <= n; j++) R[j] = read();
    for(int i = 1; i <= R[1]; i++) dp[0][i][151] = 1; 
    for(int i = 2; i <= n; i++){
        memset(f, 0, sizeof f);
        memset(g, 0, sizeof g);
        for(int k = 1; k <= 151; k++) w[k] = dp[k][k][k];
        for(int k = 1; k <= R[i - 1]; k++){
            for(int l = 0; l < k; l++)
                for(int r = k + 1; r <= 151; r++){
                    (w[l] += dp[l][k][r]) %= mod;
                    (w[k] += dp[l][k][r]) %= mod;
                    (w[r] += dp[l][k][r]) %= mod;
                    (f[l][k] += dp[l][k][r]) %= mod;
                    (g[k][r] += dp[l][k][r]) %= mod; 
                }
        }
        memset(dp, 0, sizeof dp);
        for(int k = 1; k <= R[i]; k++){
            for(int l = 0; l < k; l++) {
                for(int r = k + 1; r <= 151; r++){
                    (dp[l][k][r] += f[l][r]) %= mod;
                    (dp[l][k][r] += g[l][r]) %= mod;
                    int p = 1;
                }
            }
             dp[k][k][k] = w[k] % mod; 
            }
    }
    for(int i = 1; i <= R[n]; i++)
        for(int l = 0; l <= i; l++)
            for(int r = i; r <= 151; r++){
                (ans += dp[l][i][r]) %= mod;
             } 
    cout << ans << endl;
}
```


---

## 作者：lightup37 (赞：0)

在本篇题解中, 我们定义对于两个区间 $[l1, r1], [l2, r2]$ 的减法操作. $[l1, r1] - [l2, r2]$ 的结果为所有包含在第一个区间而不包含在第二个区间的 $x$构成的集合. 本题解中我们将不区分 $[l, r]$ 和 $[r, l]$.

这道题目明显很 DP. 我们考虑如何处理第二个限制. 若倒序构造序列, 考虑每个数的取值集合:

$A_n : [1, r_n]$

$A_{n-1} : [1, r_{n-1}]$

$A_{n-2} : [1, r_{n-2}] - [A_{n-1}, A_n]$(这是因为若 $A_{n-2} \geq A_{n-1}$则$A_n \leq A_{n-2}$, 若$A_{n-2} \leq A_{n-1}$则$A_n \geq A_{n-2}$)

$A_{n-3} : [1, r_{n-3}] - [A_{n-2}, A_{n-3}]$

$\cdots$

我们可以发现, 对于$A_i$ ($i \in [1, n-2]$), $A_i$的取值区间就是 $[1, r_i] - [A_{i+1}, A_{i+2}]$. 那么我们可以直接 DP. 设 $dp(i, l, r)$ 表示填到 $A_{i}, A_{i+1}=l, A_{i+2}=r$ 的方案数. 有转移方程

$dp(i, l, r) = \sum\limits_{A_i < \min(l, r_{i})} dp(i-1, A_i, r) + \sum\limits_{r < A_i \leq r_i} dp(i-1, l, A_i)$

但是注意到一种特殊情况: 若 $A_n = A_{n-1} = \cdots A_{n-k} \not= A_{n-k-1}$, 则此时 $A_{n-k-2}$ 可以取到 $A_n$. 为此我们加上一维 t 表示这种是否是这种状况.

有:

$dp(i,l,r,t) = \sum\limits_{A_i < \min(l, r_{i})} dp(i-1, A_i, r, t) + \sum\limits_{r < A_i \leq r_i} dp(i-1, l, A_i, t) (l\not= r $ 或者 $t\not= 1)$
$dp(i,l,r,t) = \sum\limits_{A_i < \min(l, r_{i})} dp(i-1, A_i, r-1, t) + \sum\limits_{r < A_i \leq r_i} dp(i-1, l+1, A_i, t) (l = r $ 并且 $ t= 1)$

DP 即可.

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define f(i,x,y) for(int i=x,i##end=y;i<=i##end;++i)
#define d(i,x,y) for(int i=x,i##end=y;i>=i##end;--i)
#define ri register int
#define ll long long
#define il inline
#define _ 152
#define __ 52
#define mod 998244353
int max(int x, int y) {return x>y?x:y;} int min(int x, int y) {return x<y?x:y;}
int dp[__][_][_][2], rof[__], n, ans;
// dp[i][l][r][t|(0, 1)] 表示选择至 a[i], a[i]的不可取值区间为 [l, r], 是否是特殊情况
// 特殊情况: a[n] = a[n-1] = ... =a[k]; a[k-1] != a[k]; a[k-2] 可以等于 a[n]
int main(){
  f(j,0,_-1) f(k,0,_-1) f(t,0,1) dp[0][j][k][t]=1;
  scanf("%d", &n); f(i,1,n) scanf("%d", &rof[i]);
  f(i,1,n-2) f(l,1,_-1) f(r,1,_-1) f(t,0,1) {
    int rr = min(l, rof[i]+1);
    if(t&&l==r) {
      if(l<=rof[i]) dp[i][l][r][t] = (dp[i][l][r][t]+dp[i-1][l][r][1]) % mod;
      f(j,1,rr-1) dp[i][l][r][t] = (dp[i][l][r][t]+dp[i-1][j][r-1][0]) % mod;
      f(j,r+1,rof[i]) dp[i][l][r][t] = (dp[i][l][r][t]+dp[i-1][l+1][j][0]) % mod;
    }
    else{
      f(j,1,rr-1) dp[i][l][r][t] = (dp[i][l][r][t] + dp[i-1][j][r][0]) % mod;
      f(j,r+1,rof[i]) dp[i][l][r][t] = (dp[i][l][r][t] + dp[i-1][l][j][0]) % mod;
    }
  }
  f(i,1,rof[n]) f(j,1,rof[n-1]) {
    if(i == j) ans = (ans+dp[n-2][i][j][1]) % mod;
    if(i < j) ans = (ans+dp[n-2][i+1][j][0]) % mod;
    if(i > j) ans = (ans+dp[n-2][j][i-1][0]) % mod;
  }
  printf("%d\n", ans);
  return 0;
}
// sto wyxkk orz
```

---


# [SDOI2016] 硬币游戏

## 题目描述

Alice 和 Bob 现在在玩的游戏，主角是依次编号为 $1$ 到 $n$ 的 $n$ 枚硬币。每一枚硬币都有两面，我们分别称之为正面和反面。一开始的时候，有些硬币是正面向上的，有些是反面朝上的。Alice 和 Bob 将轮流对这些硬币进行翻转操作，且 Alice 总是先手。


具体来说每次玩家可以选择一枚编号为 $x$，要求这枚硬币此刻是反面朝上的。对于编号 $x$ 来说，我们总可以将 $x$ 写成 $ c\cdot 2^a \cdot 3^b$ ，其中 $a$ 和 $b$ 是非负整数，$c$ 是与 $2,3$ 都互质的非负整数，然后有两种选择：


选择整数 $p,q$ 满足 $a \ge pq , p \ge 1$ 且 $1 \leq q \leq \text{MAXQ}$，然后同时翻转所有编号为 $c \cdot 2^{a-pj} \cdot 3^b$  的硬币，其中 $j = 0, 1, 2, \ldots ,q$。

选择整数 $p,q$ 满足 $b \ge pq, p \ge 1$  且 $1 \leq q \leq \text{MAXQ}$，然后同时翻转所有编号为 $c \cdot 2^a \cdot 3^{b-pj}$ 的硬币，其中 $j = 0, 1, 2, \ldots, q$。

可以发现这个游戏不能无限进行下去，当某位玩家无法继续操作上述操作时，便输掉了游戏。作为先手的 Alice，总是希望可以在比赛开始之前就知道自己能否获胜。她知道自己和 Bob 都是充分聪明的，所以在游戏过程中，两人都会最优化自己的策略并尽量保证自己处于不败的情形中。


## 说明/提示

对于 $100\%$ 的数据 $1\le n \le 30000,1 \le \text{MAXQ} \le 20,t\le 100$。


## 样例 #1

### 输入

```
6
16 14
1 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1
16 14
0 1 0 0 0 1 1 1 1 1 1 0 1 0 0 1
16 11
0 1 0 0 0 1 1 1 0 1 0 0 0 1 0 1
16 12
1 1 1 1 1 1 1 1 0 0 1 1 0 1 1 0
16 4
1 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0
16 20
0 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0```

### 输出

```
win
lose
win
lose
win
win```

# 题解

## 作者：winxp_qwq (赞：9)

如果换成下面这个游戏，是不是一眼可以看出是$SG$啊

①开始有一些地方有石子

②每次可以选择满足条件的$p,q$和一个位置，在这个位置去掉一个石子，在其它相应位置加一个石子

注意到这个问题对每个数是独立的，应用$SG$定理就可以马上解决

那么回到原游戏，我们发现原游戏就是这个游戏$mod2$的形式

并且呢，如果某方在原游戏下有必胜策略，那么在新游戏中如果对方动了一个位置，且：

①如果这个位置原有奇数个棋子，那按原游戏里面必胜策略下就可以

②否则复读（显然可以复读，而且这样$mod2$来看都是不变的）

这是新游戏的一个必胜策略

那么容易证明这两个游戏的获胜条件是相同的

那是不是直接$SG$就好了啊

（注意看清题意，看清每次合法操作都是什么以防WA）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 33333
int n,q;
int sg[maxn];
int cnt[303]={0};
void gao(int x,int p,int w) {
    int a,b,c=0,y=x;
    for(a=1;a<=q;a++) {
        if(y%p!=0) break;
        y/=p;c^=sg[y];
        if(c<303) cnt[c]=x;
    }
}
void get_sg(int x) {
    int a,b,c;
    for(b=2,a=1;;a++) {
        if(x%b!=0) break;
        gao(x,b,a);
        b*=2;
    }
    for(b=3,a=1;;a++) {
        if(x%b!=0) break;
        gao(x,b,a);
        b*=3;
    }
    for(a=0;;a++)
    if(cnt[a]!=x) {
        sg[x]=a;
        return;
    }
}
int main(){
    int T,t;
    scanf("%d",&T);
    for(t=1;t<=T;t++) {
        int a,b,c=0;
        memset(cnt,0,sizeof cnt);
        scanf("%d%d",&n,&q);
        for(a=1;a<=n;a++) get_sg(a);
        //for(a=1;a<=n;a++) printf("%d\n",sg[a]);
        for(a=1;a<=n;a++) {
            scanf("%d",&b);
            if(b==0) c^=sg[a];
        }
        if(c==0) printf("lose\n");
        else printf("win\n");
    }
    return 0;
}
```

---

## 作者：_Sein (赞：6)

首先了解一个结论吧。

**局面的SG值为局面中每个正(反)面朝上的棋子单一存在时的SG值的异或和**。

这里有[证明](https://lb2003.top/archives/453.html)，糊不糊不知道，内附比较严谨的证明。

----

回到正题。

对于$c*2^a*3^b$，$c$其实没什么用，因为$c$不同，其实之间是互相独立的游戏，用一下SG定理就可以求得游戏和了。

那么就考虑独立的$2^a*3^b$，根据题意，$2^a$与$3^b$的局面的并集其实就是$2^a*3^b$的局面。

因此仅需要考虑$2^a$的情况。

由于改动的只有$2^a,2^{a-pj}(j\le q,p*q\le a)$

不妨指数拿下来，也就是改变$a,a-p,a-2p,\cdots,a-pq$这些位置的硬币朝向。

也就是根据上面的结论**局面SG值等于单一存在时的SG的异或和**，$SG(a)$的状态来源有$SG(a-p),SG(a-p)~\text{xor}~SG(a-2p),\cdots$

于是$SG(a)=\text{mex}\{SG(a-p),SG(a-p)~\text{xor}~SG(a-2p),\cdots\}$

然后回归原题，也就是

$SG(a,b)=\text{mex}\{SG(a-p,b),SG(a-p,b)~\text{xor}~SG(a-2p,b),\cdots,SG(a,b-p),SG(a,b-p)~\text{xor}~SG(a,b-2p),\cdots\}$

最后再异或一下就是答案了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#define gc getchar()
#define ll long long
#define ull unsigned long long
#define file(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
#define I inline 
using namespace std;
const int N=3e4,M=N+5;const ull G=31;
template<class o>I void qr(o &x)
{
	char c=gc;int f=1;x=0;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>I void qw(o x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int sg[21][30][30],lg2[M],lg3[M];
I int mex(int k){for(int i=0;;i++)if(~k>>i&1)return i;}
int main()
{
	for(int i=1;i<=N;i++)
	{
		if(i%2==0)lg2[i]=lg2[i/2]+1;
		if(i%3==0)lg3[i]=lg3[i/3]+1;
	}
	for(int MaxQ=1;MaxQ<=20;MaxQ++)
		for(int a=1,j=0;a<=N;a*=2,++j)
			for(int b=1,k=0;a*b<=N;b*=3,++k)
			{
				int s=0;
				for(int p=1;p<=j;p++)
				{
					int t=0;
					for(int q=1;p*q<=j&&q<=MaxQ;q++)
						t^=sg[MaxQ][j-p*q][k],s|=1<<t;
				}
				for(int p=1;p<=k;p++)
				{
					int t=0;
					for(int q=1;p*q<=k&&q<=MaxQ;q++)
						t^=sg[MaxQ][j][k-p*q],s|=1<<t;
				}
				sg[MaxQ][j][k]=mex(s);
			}
	int T;qr(T);
	while(T--)
	{
		int ans=0;
		int n,MaxQ;qr(n),qr(MaxQ);
		for(int i=1;i<=n;i++)
		{
			int c;qr(c);
			if(!c)ans^=sg[MaxQ][lg2[i]][lg3[i]];
		}
		ans?puts("win"):puts("lose");
	}
	return 0; 
}
```

---

## 作者：单曦增 (赞：4)

这道题不难吧，为什么大佬们没有题解呢，一定是dalao们觉得太简单了吧，弄得我好几天才做出来。。。

很显然，直接按题意模拟即可，求出sg函数，异或和就好了，不知道sg函数的可以自己百度一下。。。[非常神奇的网站](http://www.baidu.com)

不知道为什么，大佬们都是每次输入n之后再算的sg函数，并且每次算的时候都用的是2的多少次方乘3的多少次方，明明直接求更简单的，效率也并不低。。。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=31000;
const int Maxm=2100;

int sg[Maxn][31];
int s[Maxm];

int n,m,c,t,ans;

void getsg() {
	for(int i=1;i<=30000;i++) {
		int temp=i;
		int san=0,er=0;
		while(temp%2==0) temp/=2,er++;
		while(temp%3==0) temp/=3,san++;
		for(int q=1;q<=20;q++) {
			for(int k=1;k<=q;k++) {
				for(int p=1,tempp=2;p*k<=er;p++,tempp*=2) {
					int ans=0;
					for(int j=1,temp2=tempp;j<=k;j++,temp2*=tempp)
						ans^=sg[i/temp2][q];
					s[ans]=1;
				}
				for(int p=1,tempp=3;p*k<=san;p++,tempp*=3) {
					int ans=0;
					for(int j=1,temp3=tempp;j<=k;j++,temp3*=tempp)
						ans^=sg[i/temp3][q];
					s[ans]=1;
				}
			}
			while(s[sg[i][q]]) sg[i][q]++;
			for(int k=1;k<=q;k++) {
				for(int p=1,tempp=2;p*k<=er;p++,tempp*=2) {
					int ans=0;
					for(int j=1,temp2=tempp;j<=k;j++,temp2*=tempp)
						ans^=sg[i/temp2][q];
					s[ans]=0;
				}
				for(int p=1,tempp=3;p*k<=san;p++,tempp*=3) {
					int ans=0;
					for(int j=1,temp3=tempp;j<=k;j++,temp3*=tempp)
						ans^=sg[i/temp3][q];
					s[ans]=0;
				}
			}
		}
	}
}

int main() {
//	freopen("test.in","r",stdin);
	getsg();
	scanf("%d",&t);
	while(t--) {
		ans=0;
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++) {
			scanf("%d",&c);
			if(c==0) ans^=sg[i][m];
		}
		if(ans==0) puts("lose");
		else puts("win");
	}
//	fclose(stdin);
	return 0;
}
```

---

## 作者：tylon2006 (赞：2)

翻硬币挺冷门的，找不到什么资料讲这个。

---
我们先考虑一个简单的问题。

- $\rm Turning\ Turtles $

n 个硬币，每次翻转一个硬币 j 或两个硬币 $i,j$（$i<j$），且 j 必须由正面翻为反面（否则转移成环）。

可以将 i 位置上的一枚硬币视为一堆大小为 i 的石子。

显然我们比较关心拿两个硬币的情况，分类讨论：

1. 两枚硬币一反一正。那么相当于去掉一堆大小为 j 的石子，加上一堆大小为 i 的。这可以视为从大小为 j 的石子堆中取出 $j-i$ 个。
2. 两枚硬币均为正面。此时两堆都去掉。但由于 $\rm SG$ 函数使用异或计算，可以发现去掉 $i$ 的操作可以等价为加上一堆 $i$。于是与上述情况相同。

实际上，此时 $i$ 位置上的硬币正反与我们对位置 $j$ 操作无关，于是可以任意地取 $i\in[1,j)$。这其实就是 $\rm Nim$ 游戏。

这给我们一个启示：我们可以将任意的集合翻转视为将钦定正反的位置分裂为一个新的位置集合。这导致每个硬币的游戏均是独立的。

那么这就是个无脑模拟题意递推 $\rm SG$ 的事情了。

枚举是调和级数的，对于位置 n 有 $O(\log n\log \log n)$ 个取值，记为 $m$。

暴力排序去重求 $mex$ 时间复杂度为 $O(Tnm\log m)$，此处因为极限数据下 $MAXQ>\log n$ 不考虑 $MAXQ$。

但是通过打表实际上求出来的 $\rm SG$ 非常小所以可以直接按值域枚举。



---
### code
暴力实现得好点就能过。但显然我实现得很垃圾。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e5+10;
int SG[maxn];
int p2[maxn];
int p3[maxn];
int a[maxn];
int b[maxn];
set<int>s;
int n,q;
void init(){
	for(int i=1;i<=maxn;++i){
		int x=i;
		while(x%2==0) ++a[i],x>>=1;
		while(x%3==0) ++b[i],x/=3;
	}
	p2[0]=p3[0]=1;
	for(int i=1;i<=15;++i){
		p2[i]=p2[i-1]*2;
		p3[i]=p3[i-1]*3;
	}
}
int main(){
	int t;
	init();
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&q);
		memset(SG+1,0,4*n);
		for(int i=1;i<=n;++i){
			s.clear();
			for(int p=1;p<=a[i];++p)
			for(int j=1,sum=0,x=i/p2[p];j<=q&&j*p<=a[i];++j,x/=p2[p]){
				sum^=SG[x];
				s.insert(sum);
			}
			for(int p=1;p<=b[i];++p)
			for(int j=1,sum=0,x=i/p3[p];j<=q&&j*p<=b[i];++j,x/=p3[p]){
				sum^=SG[x];
				s.insert(sum);
			}
			int las=0;
			for(set<int>::iterator it=s.begin();it!=s.end();++it){
				if(*it>las) break;
				las=*it+1;
			}
			SG[i]=las;
		}
		int x,sum=0;
		for(int i=1;i<=n;++i){
			scanf("%d",&x);
			if(!x) sum^=SG[i];
		}
		printf("%s\n",sum?"win":"lose");
	}
}
```
---

有兴趣可以自己再手摸几个类似的问题，对理解有较大帮助。

例如 $\rm Mock\ Turtles$。 

---


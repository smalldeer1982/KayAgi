# [SDOI2016] 探险路线

## 题目描述

你所面对的丛林，可以被刻画为n行m列的格点图，其中第i行第j列的格子代表了一块区域，每个格子有整数权值v(i,j)（可能为负），表明了访问这一块区域的收益或代价。每一个格子最多只能被访问一次，且不可走出地图的边界，你被要求从第一行第一列出发，到第n行第m列结束，你的目标是最大化途经的所有格子的权值和。

因为一些缘故，你的探险路线受到了一些限制。起初你在起点，之后每一天的行动中，首先你需要选择上下左右中的某一个方向，沿着这个方向走0步（也就是不走）或任意步；之后重新选择一个方向（可以与原来方向相同，也可以是不同的方向），沿着这个方向一直走下去，走到地图的某个边界位置结束这一天的探险。探险可以有任意多天，每一天探险结束的边界位置就是第二天的起点位置，除非这一天就是探险的结束。注意，因为每一块格子只能被访问一次，且你最终的结束点必须是第n行第m列的位置，所以你需要谨慎计划每一天的路线。

你希望知道最优方案下，整个探险之旅的收益有多大，即你可以获得的权值和最大是多少。


## 说明/提示

对于所有数据3<=n<=800且3<=m<=800，保证收益代价绝对值在100000以内


## 样例 #1

### 输入

```
10 10
+1 +1 +1 +1 +1 -1 -1 -1 -1 -1
-1 -1 +1 +1 +1 -1 -1 -1 -1 -1
-1 -1 +1 +1 +1 +1 +1 +1 +1 +1
+1 +1 +1 +1 -1 -1 -1 -1 -1 +1
+1 -1 -1 +1 -1 -1 -1 -1 -1 +1
+1 +1 +1 +1 -1 -1 -1 -1 -1 +1
+1 +1 +1 +1 +1 +1 +1 +1 +1 +1
+1 -1 -1 -1 -1 -1 -1 -1 -1 -1
+1 +1 +1 +1 -1 +1 +1 +1 +1 +1
-1 -1 -1 +1 +1 +1 -1 -1 -1 +1```

### 输出

```
53```

# 题解

## 作者：guyan (赞：8)



按限制模拟 , 只有三种行走方式 :

1. 沿边界走

2. 在左上 , 右下徘徊

3. 上下或左右反复


![在边角徘徊](https://i.loli.net/2020/03/02/na9HrIm3EpWLMvQ.png)


于是可以分为三个阶段 , 在起点徘徊 , 上下/左右 , 在终点徘徊

![](https://i.loli.net/2020/03/02/FZUA9jBpGn32mM4.png)

上下走就是转置后左右走

在起点徘徊和在终点徘徊中心对称翻转

于是只用考虑两个 DP , 第一个在角落徘徊 , 第二个左右来回

设 $f[i][j]$ 表示在 $(1,j)$ , 最多走到第 $i$ 行的最大收益 , $g[i][j]$ 表示在 $(i,1)$ , 最多走到第 $j$ 列的最大收益

于是有转移 

$f[i][j] = \max( f[i][j - 1] + a_{1,j} , f[i - 1][j] , g[i - 1][j - 1] + profit_{(i,1) \rightarrow (i,j) \rightarrow (1,j) })$

$g[i][j] = \max( g[i - 1][j] + a_{i,1} , g[i][j - 1] , f[i - 1][j - 1] + profit_{(1,j) \rightarrow (i,j) \rightarrow (i,1) })$

于是可以得到到达 $(i,1) , (i,m)$ 的最大收益 , 第一个 DP 就完成了

设 $h[i][0/1]$ 表示在 $(i,1),(i,m)$ 时的最大收益

$h[i][0] = \max( h[i - 1][0] + a_{i,1} , h[k][1] + profit_{(k,m)\rightarrow (i,m) \rightarrow (i,1)} ) ( k < i)$

$h[i][1] = \max( h[i - 1][1] + a_{i,1} , h[k][0] + profit_{(k,1)\rightarrow (i,m) \rightarrow (i,m)} ) (k < i)$

最后与在 $(n,m)$ 徘徊的 DP 合并求一下答案就可以了

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long lol;
const int N = 8e2 + 5;
const lol INF = 1e15;
inline void chkmax( lol & a , lol b ) { if( a < b ) a = b; }
int _w;

int org[N][N] , dat[N][N] , n , m
lol col[N][N] , row[N][N] , L[N] , R[N] , up[N][2] , dn[N][2] , ans = -INF , trs[N] , f[N][N][2];

void calc( void ) { // 计算在边角徘徊
  for( int i = 1 ; i <= n ; ++i )
    for( int j = 1 ; j <= m ; ++j )
      col[i][j] = col[i - 1][j] + dat[i][j] , 
      row[i][j] = row[i][j - 1] + dat[i][j];
  for( int i = 1 ; i <= n ; ++i )
    for( int j = 1 ; j <= m ; ++j )
      f[i][j][0] = f[i][j][1] = -INF;
  for( int i = 1 ; i <= n ; ++i ) f[i][1][1] = col[i][1] , f[i][1][0] = dat[1][1];
  for( int i = 1 ; i <= m ; ++i ) f[1][i][1] = dat[1][1] , f[1][i][0] = row[1][i];
  for( int i = 2 ; i <= n ; ++i ) {
    for( int j = 2 ; j <= m ; ++j ) {
      chkmax( f[i][j][0] , f[i - 1][j][0] );
      chkmax( f[i][j][0] , f[i - 1][j - 1][1] + col[i][j] + row[i][j] - dat[i][j] );
      chkmax( f[i][j][0] , f[i][j - 1][0] + dat[1][j] );
      chkmax( f[i][j][1] , f[i][j - 1][1] );
      chkmax( f[i][j][1] , f[i - 1][j - 1][0] + col[i][j] + row[i][j] - dat[i][j] );
      chkmax( f[i][j][1] , f[i - 1][j][1] + dat[i][1] );
    }
  }
  for( int i = 1 ; i <= n ; ++i ) L[i] = R[i] = -INF;
  for( int i = 1 ; i <= n ; ++i )
    for( int j = 1 ; j <= m ; ++j )
      chkmax( L[i] , f[i][j][1] );
  for( int i = 1 ; i <= m ; ++i ) trs[i] = row[1][m] - row[1][i];
  R[1] = row[1][m];
  for( int i = 2 ; i <= n ; ++i )
    for( int j = 1 ; j < m ; ++j ) {
      trs[j] = max( trs[j] + dat[i][m] , col[i][j + 1] + row[i][m] - row[i][j + 1] );
      chkmax( R[i] , f[i][j][0] + trs[j] );
    }
}

void solve( void ) {
  memcpy( dat , org , sizeof dat ); calc();
  for( int i = 1 ; i <= n ; ++i ) up[i][0] = L[i] , up[i][1] = R[i];
  for( int i = 1 ; i <= n ; ++i )
    for( int j = 1 ; j <= m ; ++j )
      dat[i][j] = org[n - i + 1][m - j + 1];
  calc(); for( int i = 1 ; i <= n ; ++i ) dn[i][0] = R[n - i + 1] , dn[i][1] = L[n - i + 1];
  memcpy( dat , org , sizeof dat );
  for( int i = 1 ; i <= n ; ++i )
    for( int j = 1 ; j <= m ; ++j )
      col[i][j] = col[i - 1][j] + dat[i][j] , 
      row[i][j] = row[i][j - 1] + dat[i][j];
  lol l = 0 , r = row[1][m - 1];
  for( int i = 2 ; i <= n ; ++i ) {
    chkmax( up[i][0] , l + col[i][1] );
    chkmax( up[i][1] , r + col[i][m] );
    chkmax( up[i][0] , r + col[i][m] + row[i][m] - dat[i][m] );
    chkmax( up[i][1] , l + col[i][1] + row[i][m] - dat[i][1] );
    chkmax( l , up[i][0] - col[i][1] );
    chkmax( r , up[i][1] - col[i][m] );
  }
  l = row[n][m] , r = dat[n][m];
  chkmax( ans , dn[1][0] );
  chkmax( ans , up[n][1] );
  for( int i = n - 1 ; i > 1 ; --i ) {
    l = max( l + dat[i][1] , dn[i][0] );
    r = max( r + dat[i][m] , dn[i][1] );
    chkmax( ans , l + up[i - 1][0] );
    chkmax( ans , r + up[i - 1][1] );
  }
}

int main( void ) {
  _w = scanf("%d%d",&n,&m);
  for( int i = 1 ; i <= n ; ++i )
    for( int j = 1 ; j <= m ; ++j )
      _w = scanf("%d",org[i] + j );
  solve();
  for( int i = 1 ; i <= n ; ++i )
    for( int j = i + 1 ; j <= m ; ++j )
      swap( org[i][j] , org[j][i] );
  swap( n , m );
  solve();
  cout << ans;
  return 0;
}
```



---

## 作者：_Sein (赞：7)

首先这个人呢，

根据题目的意思，一天有两次操作:

沿着一个方向走$k$步，

然后沿着一个方向走到边界。

通过画图呢，我们可以得到大概的图形。

要么在左上角(起点)徘徊，

要么就是路被挡住了，不能徘徊，像蛇形一样往下走了，

要么在右下角(终点)徘徊。

那么要设计三个状态？

不用，因为右下角翻转一下就是左上角，因此只要再照着左上角的徘徊DP方式再做就好了。

于是给出左上角徘徊的定义:

不难发现其实如果要徘徊，一天的结束一定是停在$(i,1)$或$(1,j)$上。

定义状态$f_{i,j,0/1}$表示

0的时候，之前最远达到$i$行，现在要到$(1,j)$的最大价值。

1的时候，之前最远达到$j$列，现在要到$(i,1)$的最大价值。

根据定义有

$f_{i,j,0}=\min\limits\{f_{i-1,j,0},f_{i,j-1,0}+val_{i,j},f_{i-1,j-1,1}+cost_{(i,1)\rightarrow(i,j)\rightarrow(1,j)}\}$

$f_{i,j,1}=\min\limits\{f_{i,j-1,1},f_{i-1,j,1}+val_{i,j},f_{i-1,j-1,0}+cost_{(1,j)\rightarrow(i,j)\rightarrow(i,1)}\}$

然后可以设计一个过渡用的小状态

$L_i,R_i$分别表示停靠在$(i,1),(i,m)$的最优状态。

具体的转移可以参照代码。

之后就过渡到了第二部分:蛇形走位。

分为从$(i-1,1)\rightarrow(i,1)$等四种情况。

考虑一下即可。

之后就是把右下角的状态拼起来就好了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#define gc getchar()
#define ll long long
#define ull unsigned long long
#define file(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
#define I inline 
using namespace std;
const int N=805,M=N+5;const ull G=31;
template<class o>I void qr(o &x)
{
	char c=gc;int f=1;x=0;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>I void qw(o x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
I void cmx(ll &a,ll b){if(a<b)a=b;}
ll col[N][N],row[N][N],f[N][N][2],L[N],R[N],s[N],u[N][2],d[N][2],ans;int val[N][N],n,m,arr[N][N];
void calc()
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			col[i][j]=col[i-1][j]+val[i][j],
			row[i][j]=row[i][j-1]+val[i][j];
	memset(f,0xcf,sizeof(f));
	for(int i=1;i<=n;i++)f[i][1][1]=col[i][1],f[i][1][0]=val[1][1];
	for(int i=1;i<=m;i++)f[1][i][1]=val[1][1],f[1][i][0]=row[1][i];
	for(int i=2;i<=n;i++)
		for(int j=2;j<=m;j++)
		{
			ll w=col[i][j]+row[i][j]-val[i][j];
			cmx(f[i][j][0],f[i-1][j][0]);
			cmx(f[i][j][0],f[i-1][j-1][1]+w);
			cmx(f[i][j][0],f[i][j-1][0]+val[1][j]);
			cmx(f[i][j][1],f[i][j-1][1]);
			cmx(f[i][j][1],f[i-1][j-1][0]+w);
			cmx(f[i][j][1],f[i-1][j][1]+val[i][1]);
		}
	memset(L,0xcf,sizeof(L));memset(R,0xcf,sizeof(R));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cmx(L[i],f[i][j][1]);
	for(int i=1;i<=m;i++)s[i]=row[1][m]-row[1][i];
	R[1]=row[1][m];
	for(int i=2;i<=n;i++)
		for(int j=1;j<m;j++)
		{
			s[j]=max(s[j]+val[i][m],col[i][j+1]+row[i][m]-row[i][j+1]);
			cmx(R[i],f[i][j][0]+s[j]);
		}
}
void solve()
{
	memcpy(val,arr,sizeof(val));calc();
	for(int i=1;i<=n;i++)u[i][0]=L[i],u[i][1]=R[i];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			val[i][j]=arr[n-i+1][m-j+1];
	calc();for(int i=1;i<=n;i++)d[i][0]=R[n-i+1],d[i][1]=L[n-i+1];
	memcpy(val,arr,sizeof(val));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			col[i][j]=col[i-1][j]+val[i][j],
			row[i][j]=row[i][j-1]+val[i][j];
	ll l=0,r=row[1][m-1];
	for(int i=2;i<=n;i++)
	{
		cmx(u[i][0],l+col[i][1]);
		cmx(u[i][1],r+col[i][m]);
		cmx(u[i][0],r+col[i][m]+row[i][m]-val[i][m]);
		cmx(u[i][1],l+col[i][1]+row[i][m]-val[i][1]);
		cmx(l,u[i][0]-col[i][1]);
		cmx(r,u[i][1]-col[i][m]);
	}
	l=row[n][m],r=val[n][m];
	cmx(ans,d[1][0]);
	cmx(ans,u[n][1]);
	for(int i=n-1;i>1;--i)
	{
		l=max(l+val[i][1],d[i][0]);
		r=max(r+val[i][m],d[i][1]);
		cmx(ans,l+u[i-1][0]);
		cmx(ans,r+u[i-1][1]);
	}
}
int main()
{
	qr(n),qr(m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			qr(arr[i][j]);
	solve();
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=m;j++)
			swap(arr[i][j],arr[j][i]);
	swap(n,m);
	solve();
	qw(ans);puts("");
	return 0;
}
```

---


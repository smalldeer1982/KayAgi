# [HNOI2006] 花仙子的魔法

## 题目描述

相传，在天地初成的远古时代，世界上只有一种叫做“元”的花。接下来，出现了一位拥有魔法的花仙子，她能给花附加属性，从此，“元”便不断变异，产生了大千世界千奇百怪的各种各样的花。据说，花仙子既可存在于二维空间（平面），又可存在于三维空间（立体），还可存在于 $n$ 维空间（想象）。二维空间的点可用向量 $\left(x_1,x_2\right)$ 表示，三维空间的点可用向量 $\left(x_1,x_2,x_3\right)$ 表示，一般来说，$n$ 维空间的点可用向量 $\left(x_1,x_2,\cdots,x_n\right)$ 表示。而 $n$ 维空间中两点 $\left(x_1,x_2,\cdots,x_n\right)$ 与 $\left(w_1,w_2,\cdots,w_n\right)$ 之间的距离定义为$\sqrt{\sum_{i=1}^{n}(X_i-W_i)^2}$。 在 $n$ 维空间中，花仙子每实施魔法就要选择一个参考点 $\left(w_1,w_2,\cdots,w_n\right)$ 和一个作用半径 $r$，并且参考点的位置和作用半径的大小可以任意选择。这时，$n$ 维空间中所有与参考点 $\left(w_1,w_2,\cdots,w_n\right)$ 之间的距离小于作用半径 $r$ 的花都会受到这次魔法的影响。每次魔法都会给受到影响的花带来不同的属性，且的效 果可以叠加。一般来说，若花仙子总共实施了 $m$ 次魔法，则 $n$ 维空间中处于某点的花所具有的属性可用长度为 $m$ 的二进制串 $\left(a_1,a_2,\cdots,a_n\right)$ 来描述，其中对 $1\le i\le m$，若该花受到第 $i$ 次魔法的影响，则 $a_i$ 的值为 $1$,否则为 $0$。显然，不同的属性对应不同的花。 现在的问题是：花仙子在 $n$ 维空间中实施了 $m$ 次魔法后，最多能得到多少种不同的花？


## 样例 #1

### 输入

```
3 1```

### 输出

```
6```

# 题解

## 作者：123456zmy (赞：20)

看到这道题，首先想到的是打个表找规律，于是
```
n\m:0   1   2   3   4   5   6
1:  1   2   4   6   8   10  12
2:  1   2   4   8   14  22  32
3:  1   2   4   8   16  30  52
```
~~(打三维的表时差点猝死)~~

于是我们发现a[n][m]=a[n][m-1]+a[n-1][m-1]。

[AC](https://www.luogu.org/record/24051187)代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long a[101][17],m,n;
int main()
{
	a[0][1]=1;							//初始化
	for(int i=1;i<101;i++)a[i][1]=i<<1;				//初始化
	for(int i=2;i<16;i++)
	{
		a[0][i]=1;						//初始化
		for(int j=1;j<101;j++)a[j][i]=a[j-1][i]+a[j-1][i-1];	//重点
	}
	scanf("%lld%lld",&m,&n);
	printf("%lld",a[m][n]);
	return 0;
}
//由于a[101][17]要比a[17][101]快，所以我写程序时把m和n反过来了
```
但是打表的结论不一定准确，所以还要考虑一下结论的正确性。

首先，~~显然~~后加入的图形应与原来的全部图形相交，下面是分析：（设n维空间，m个图形的情况答案为a[n][m]）

先从一维开始，一维中距离一个点一定距离的点构成的图形就是2个点，m个图形就有2m个点，就有2m段（由题意，最左边和最右边的两区域应视为一个）。

二维就是圆分平面，第m个圆与前m-1个圆相交，它就被2m-2个交点分成了2m-2（a[1][m-1]）条曲线，每条线把原来的一个区域分成了2个，答案就增加了2m-2（a[1][m-1]），所以a[2][m]=a[2][m-1]+a[1][m-1]。

三维是球分空间，还是考虑第m个球的情况，它与前m-1个球相交，两球相交的公共部分是一个圆，于是这个球就被m-1个圆分成了a[2][m-1]个区域，每个区域都会把原来的一个空间分成2个，答案就要增加了a[2][m-1]，所以a[3][m]=a[3][m-1]+a[2][m-1]。


接着就可以考虑n维空间了，第m个东西和前m-1个东西相交，就被分成了a[n-1][m-1]个n-1维的东西，每个n-1维的东西都把原来的一个n维的东西分成两个，答案就增加a[n-1][m-1],所以a[n][m]=a[n][m]+a[n-1][m-1]。

再初始化1维（a[1][m]=2m）和没有分的情况(a[n][0]=1)就可以了。

---

## 作者：SGColin (赞：4)

给定 $m$ 个 $n$ 维空间内的超球体(三位为球的球皮，二维为圆环，一维为两个点)，问他们能将整个 $n$ 维空间分成多少个不同的部分。

考虑到转移一定是基于维度和个数的，所以我们先预处理出一维各个数目的球能划分出的个数。

因为一维空间是一条直线，看图：![](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fs7jjngjgij317007d747.jpg)
我们发现按照这样排列才能使得划分个数最多，个数为$2m$。可以尝试DP了。

---

$f[i][j]$表示$i$维空间内，用$j$个球体可以最多划分出的空间个数。 我们将转移看做在前$j-1$个球的基础上添加一个球的方案。

+ 考虑前$j-1$个球的答案，显然为$f[i][j-1]$；

+ 考虑当前球能产生最大的贡献，我们知道两个$n$维球体求交的答案应该是$n-1$维的物体，可以简单的理解为两个球求交得到的是一个两端尖的环，那么我们可以认为，第$j$个球显然最多与$j-1$个球相交，那么就产生了**贴在当前球表面上$j-1$个片**，那么我们将当前的$n$维球表面**展开**成$n-1$维的一个物体，那么它就与贴在上面的片同维度了，此时问题即为$i-1$维空间内，用$j-1$个球体可以最多划分出的空间个数。

方程为$f[i][j]=f[i-1][j-1]+f[i][j-1]$；

可以滚动数组。

```C++
#include<cmath>
#include<cstdio>
#include<cctype>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define R register
using namespace std;

long long n,m,now,f[2][110];

int main(){
	scanf("%d%d",&m,&n);
	for(R int i=1;i<=m;++i)f[0][i]=i*2; 
	f[0][0]=f[1][0]=1;
	for(R int i=2;i<=n;++i){
		now=1-now;
		for(R int j=1;j<=m;++j)
			f[now][j]=f[1-now][j-1]+f[now][j-1];
	}
	printf("%lld",f[now][m]);
	return 0;
}
```

---

## 作者：Kelvin2009 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4176)

这题是纯数学与递推。

首先我们可以推出：所有维度，当没有施展魔法时，只有 $1$ 个界面：整个维度空间。

其次，我们可以由画图得出，对于一维的线段，每施展一次魔法，界面数量是加二的（第一次施展有 $2$ 个界面）。

对于一个 $i$ 维已有 $j-1$ 个图形的图形，再施展一次魔法：下一个图形与已有图形交界面是 $i-1$ 维的，则新增的贡献相当于 $i-1$ 维度共 $j-1$ 个图形时的界面数，以此进行递推。

**有一点注意：要开 $\texttt{unsigned long long}$！**

------------
代码：

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
const int range_total=15;
const int range_dimension=105;
int n,m;
unsigned long long a[range_total][range_dimension];
int main()
{
	scanf("%d%d",&m,&n);
	a[0][0]=1;
	for(int i=1;i<=n;i++) a[i][0]=1;
	for(int i=1;i<=m;i++) a[0][i]=2;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) a[i][j]=a[i][j-1]+a[i-1][j-1];
	printf("%lld",a[n][m]);
	return 0;
}
```

---

## 作者：木xx木大 (赞：0)

[P4176 [HNOI2006]花仙子的魔法](https://www.luogu.com.cn/problem/P4176)

设 $f_{i,j}$ 表示 $i$ 维空间内，用 $j$ 个超球体最多可以划分出的空间个数。

容易发现，$f_{1,j}=j\times 2,f_{i,0}=1$ 。通过打表~~并不容易~~发现 $f_{i,j}=f_{i-1,j-1}+f_{i,j-1}$

(我的打表是手动打表所以并没有打表代码）

我们认真思考为什么：考虑放入第 $j$ 个球时，已经形成了 $f_{i,j-1}$ 个空间。因为 **$i$ 维球与 $i$ 维球相交的部分会变成 $i-1$ 维**（线线相交为点，面面相交为线，体体相交为面……感谢我的数学老师给我讲过这个结论），第 $j$ 个球最多会与 $j-1$ 个球相交，且尽量与更多的球相交是更优的，因此会再增加 $f_{i-1,j-1}$ 朵花。

最后吐槽：这种考察对维度的理解的题真的不是物理题吗。。。~~不过结论好像是数学老师讲的~~

代码很好写，但要注意开 unsigned long long！

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long f[20][110];
int n,m;
int main()
{
	scanf("%d%d",&m,&n);
	f[1][0]=1;
	for(int i=1;i<=m;i++)
		f[1][i]=i<<1;
	for(int i=2;i<=n;i++)
	{
		f[i][0]=1;
		for(int j=1;j<=m;j++)
			f[i][j]=f[i-1][j-1]+f[i][j-1];	
	}
	printf("%llu",f[n][m]);
	return 0;	
 } 
 ```

---

## 作者：龙行龘龘 (赞：0)

# 高维懵逼

题意相当于在放置m个n维球，最多把n维空间分成几个部分。

## ！@#￥%……&*（）

f[i][j]表示在i维空间放置j个i维球最多把空间分成几个部分。

## 脑补/找规律/乱搞

f[i][j]=f[i][j-1]+f[i-1][j-1]

考虑放入第j个球时，已经分成了f[i][j-1]个空间；

因为i维球与i维球相交的部分会变成i-1维（线线相交为点，面面相交为线...），第j个球最多会与j-1个球相交，因此就是f[i-1][j-1]。

用了~~实用的~~多组数据表...

顺便献上我的blog:https://www.luogu.org/blog/Root-std-admin/

前方高能:
```cpp
//Written By:Jason_Root
//Time Limit : 1000 MS
//Memory Limit : 65536 KB
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define For(i,s,e) for(int i = s;i < e;i++)
using namespace std;
typedef long long ll;
template <typename T>
__attribute__((optimize("O2")))
inline void read(T &x) {
	char ch = getchar();
	T f = 1;
	x = 0;
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		x = x*10 + ch-'0';
		ch = getchar();
	}
	x*= f;
}
template <typename T>
__attribute__((optimize("O2")))
inline void print(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) print(x/10);
	putchar(x%10+'0');
}
ll tab[120][20],m,n;
__attribute__((optimize("O2")))
void init() {
	ios_base::sync_with_stdio(false);
	tab[0][1] = 1;
	For(i,1,101) {
		tab[i][1] = i<<1;
	}
	For(i,2,16) {
		tab[0][i] = 1;
		For(j,1,101) {
			tab[j][i] = tab[j-1][i]+tab[j-1][i-1];
		}
	}
	return;
}
__attribute__((optimize("O2")))
void func() {
	init();
	read(m),read(n);
	print(tab[m][n]);
}
int main(int argc, char const *argv[]) {
	func();
	return 0;
}

```
真心感谢大家观看,谢谢!!!

---

## 作者：bradfordzhang (赞：0)

# DP解法
> 根据题面，不难推出下面的转移方程:
$$ f_{0,1}=2 $$
$$ f_{i,1}=2 $$
$$ f_{i,j}=\sum_{i=1}^K\sum_{j=1}^{n}f_{i,j-1}+f_{i-1,j-1} $$
> 还要注意的是，结果是下面这样的
$$ ans+=\sum_{i=1}^nf_{K,i} $$


> 接下来就是代码了

```cpp
#include<iostream>
#include<cstdio>
typedef long long LL;
using namespace std;
LL f[16][110];
int n, K;
int main() {
	scanf("%d%d", &n, &K);
	f[0][1] = 2;
	for (int i = 1; i <= K; i++) {
		for (int j = 1; j <= n; j++)
			f[i][j] = f[i][j - 1] + f[i - 1][j - 1];
		f[i][1] = 2;
	}
	LL ans = 0;
	for (int i = 1; i <= n; i++) ans += f[K][i];
	printf("%lld", ans);
	return 0;
}
```


---


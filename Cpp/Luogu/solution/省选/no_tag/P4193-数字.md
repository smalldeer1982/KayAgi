# 数字

## 题目描述

小 D 喜欢的数有这样的性质：
令 $n$ 为正整数，$S(n)$ 为 $n$ 的各位数字之和，令

$$D(n)\begin{cases}\displaystyle S(n), S(n)<10 \\\displaystyle D(S(n)), S(n)>10\end{cases}$$

小 D 喜欢的数一定能表示成 $x×D(x)$ 这种形式（即若一个数 A 是被喜欢的，则存在一个数 $x$，使得 $A=x\times D(x)$）。
小 D 想知道在区间 [L, R] 中，有多少个数是他喜欢的。

## 说明/提示

L,R<=$10^18$,T<=20


## 样例 #1

### 输入

```
3
1 5
3 9
8 8```

### 输出

```
2
2
0```

# 题解

## 作者：Green_Hand (赞：9)

## 此题做法：找规律


- 首先，我们需要分析什么样的数才能满足条件
- 我们通过一波打表就可以发现 $D_i=(i-1)\bmod9+1$
- 接着，我们可以发现满足下列条件之一就满足条件
	- $(x/2-1)\bmod9+1=2$
    - $(x/3-1)\bmod9+1=3$
    - $\dots\dots$
    - $(x/8-1)\bmod9+1=8$
    - $(x/9-1)\bmod9+1=9$
- 经过一系列简化，可得
	- $x\bmod9=1$
    - $x\bmod18=4$
    - $\dots\dots$
    - $x\bmod72=64$
    - $x\bmod81=0$
- 由于$22680 = lcm(9,18,27,36,45,54,63,72,81)$
	且$a \bmod b = (a + bc) \bmod b $
- 所以可得
	- $x\bmod9=(x+22680)\bmod9$
    - $x\bmod18=(x+22680)\bmod18$
    - $\dots\dots$
    - $x\bmod72=(x+22680)\bmod72$
    - $x\bmod81=(x+22680)\bmod81$
- 即如果用$bool$数组存该数是否满足条件，那么这个数组是循环的，且循环长度为$22680$
- 所以我们只需求出$1$到$22680$有哪些符合条件的数并维护前缀和即可
- 附代码

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 22680;
typedef long long ll;
int T; ll l,r,sum[N + 10];

ll answer(ll x) { return sum[N] * (x / N) + sum[x % N]; }

int main()
{
	for(int i = 1,x;i <= N; ++ i)
		if((x = i * ((i - 1) % 9 + 1)) <= N) sum[x] = 1;
	for(int i = 2;i <= N; ++ i) sum[i] += sum[i - 1];
	for(scanf("%d",&T);T--;) scanf("%lld%lld",&l,&r),
		printf("%lld\n",answer(r) - answer(l - 1ll));
	return 0;
}
```

---

## 作者：________a____ (赞：5)

发现题解区现有 4 篇题解都用了一种相对劣的方法，这里提供一种更便捷的解法。

首先，分析 $D\left(x\right)$ 的特点。

结论： $D\left(x\right)=\left(x-1\right) \text{mod} ~9 +1$

证明：

在 $x<10$ 时结论显然成立。

考虑数学归纳法，设 $x=\sum\limits_{i\ge0} 10^i a_i$，小于 $x$ 的数都满足结论。

$$\begin{aligned}
 D\left(x\right)&=D\left(S\left(x\right)\right)\\

\therefore D\left(\sum\limits_{i \ge 0} 10^i a_i\right)&=D\left(\sum\limits_{i\ge0}a_i\right)\\

\because 10^i~\text{mod} ~9&=1\\
\therefore  \sum\limits_{i \ge 0} 10^i a_i & \equiv \sum\limits_{i \ge 0}a_i~~\left(\text{mod} ~9\right)\\ 

\therefore  \left(\sum\limits_{i \ge 0} 10^i a_i~-1\right) \text{mod} 9 +1 &= \left(\sum\limits_{i \ge 0} a_i~-1\right) \text{mod} ~9 +1\\

\because \sum\limits_{i \ge 0}a_i &\lt x\\
\therefore D\left(\sum\limits_{i\ge0}a_i\right) &= \left(\sum\limits_{i\ge0}a_i~-1\right) \text{mod} ~9 +1\\
\therefore D\left(x\right)&=\left(x-1\right) \text{mod} ~9 +1
 

\end{aligned}$$
证毕。

分析满足 $k=\ D\left(x\right) \times x$ 的 $k$ 的特点。

考虑 $D\left(x\right)$ 取值只有 $1\sim9$，想到可以把 $D\left(x\right)=1\sim9$ 分开考虑。

$$ \text{设}~a=D\left(x\right)=\left(x-1\right) mod ~9 +1$$

$$\left(a-1\right)+9n=x-1$$

$$x=a+9n$$


$$\begin{aligned}

k&=x \times D \left(x\right)\\

& =ax\\

&=a\times\left(a+9n\right)\\

&=a^2+9an

\end{aligned}$$

可以通过 $(R-a^2)/9a+1$ 算出 $R$ 以内的 $a$ 倍数数量。

将 $a \in \left[1,9 \right]$ 代入，得到：

|所属集合| 原式 |化简  |注 |
| :----------- | :----------- | :-----------  | :----------- |
|$1$ |  $1\times (1+9\times n-9)$     |  $-8+9\times n $ |/ |
|$2$ |$ 2\times (2+9\times n-9)  $   |  $ -14+18\times n $|/ |
| $3$ |$3\times (3+9\times n-9)    $ |  $ -18+27\times n $| /|
| $4$ |$ 4\times (4+9\times n-9)   $  |  $ -20+36\times n $|/ |
| $5$ |$ 5\times (5+9\times n-9)   $   |  $-20+45\times n $| 与4有交 |
| $6$  |$ 6\times (6+9\times n-9)  $   |  $ -18+54\times n $|被3完全包含，不计贡献 |
| $7$  | $7\times (7+9\times n-9)  $  |   $ -14+63\times n $| 与2有交|
| $8$  |  $8\times (8+8\times n-9) $  |   $  -8+72\times n $| 被1完全包含，不计贡献|
| $9$  |  $9\times (9+9\times n-9) $ |    $  81\times n $| /|
| $4\cap5$ |  $4\times 5\times (8+n\times 9-9)   $ |  $-20+180\times n $| 4与5的lcm|
| $2\cap7$ |  $2\times 7\times (8+n\times 9-9)  $ |  $ -14+126\times n $| 2与7的lcm|

其中 $n$ 为是第几个数，其中重合的部分容斥一下就行了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int k[10]={9，18，27，36，45，63，81，180，126}，
   b[10]={-8，-14，-18，-20，-20，-14，0，-20，-14};
inline ll calc(ll p){
	ll rec=0;
	for(int i=0;i<7;i++) rec+=(p-b[i])/k[i];
	for(int i=7;i<9;i++) rec-=(p-b[i])/k[i];
	return rec;
}
signed main(){
	int T;
	scanf("%d"，&T);
	ll l，r;
	while(T--){
		scanf("%lld%lld"，&l，&r);
		printf("%lld\n"，calc(r)-calc(l-1));
	}
	return 0;
}
```

---

## 作者：loverintime (赞：2)

### 最重要的结论： $D(n)=(n-1)\mod9+1$

采取数学归纳法证明：



首先， 对于 $\forall n\in[1,9]$， 显然满足结论。

原命题等价于证明 $D(n)\equiv n\pmod9$

对于 $\forall n\in[9,+\infty)$， 若 $\forall x\leqslant n$ 满足条件， 令 $n+1=\sum 10^ia_i$， 所以 $D(n+1)=D(\sum a_i)$， 显然 $\sum a_i\leqslant n$。 ~~根据小学知识，~~ 我们可以得到： $\sum a_i\equiv (n+1)\pmod 9$， 则得证。

设定义域在正整数上的函数 $f(x)$ 表示 $x$ 能否表示成 $n\times D(n)$， 接下来的任务就是找到 $f$ 的最小正周期， 令其为 $T$。

对于 $a\in N^+$， 如果存在， 令为 $x\times D(x)$

$$
\therefore a+T=x\times D(x)+T=(x+\frac{T}{D(x)})\times D(x)  =(x+\frac{T}{D(x)})\times D(x+\frac{T}{D(x)})
$$

$$
\therefore D(x)=D(x+\frac{T}{D(x)})
$$

$$
\therefore \forall x\in N^+,\frac{T}{D(x)}\equiv 0\pmod9
$$
得到 $T_{\min}=22680$

暴力即可

---

## 作者：Sheep_ (赞：2)

#  _规律题_ 
首先打表
```cpp
#include <cstdio>
using namespace std;

int n;

int s(int a)
{
	int res = 0;
	while (a > 0)
	{
		res += a % 10;
		a /= 10;
	}
	return res;
}

int d(int a)
{
	int q = s(a);
	if (q < 10) return q; else return d(q); 
}

int main()
{
	scanf("%d",&n);
	for (int i = 1; i <= n; i ++)
	{
		printf("%d %d %d\n",i,d(i),i * d(i));
	}
	return 0;
}
```
易得D的取值有且仅有九种为1~9

$D_i = (i - 1) mod 9 + 1$

那么易得$i * ((i - 1) mod 9 + 1)$即为喜欢的数再由暴力可得

1 ~ 22680（lcm(1 ~ 9)）的结果为6088

且每22680个数为一循环节

于是乎的到以下简洁明了的AC代码

```cpp
#include <cstdio>
#define ll long long
#define xx i * ((i - 1) % 9 + 1) 
using namespace std;

const int maxn = 22680;
int T;
ll l,r,f[maxn];

ll solve(ll a)
{
	return f[maxn] * (a / maxn)  + f[a % maxn];
}

int main()
{
	for (int i = 1; i <= maxn; i ++) if (xx <= maxn) f[xx] = 1;
	for (int i = 1; i <= maxn; i ++) f[i] += f[i - 1];
	scanf("%d",&T);
	while (T --) {scanf("%lld%lld",&l,&r);printf("%lld\n",solve(r) - solve(l - 1));}
	return 0;
}
```






---

## 作者：Soledad_S (赞：0)

~~本题解实属che dan，先膜一波下面的大佬为敬~~

---
这道题都说了是结论题，但有部分大佬写的有误，难为我等萌新，所以我准备来写一篇适合 ~~（你确定？）~~ 我们蒟蒻的题解。

还有：**打表是不可能的，这辈子都不可能的**

---
首先$D(x)$是个递归函数，但递归边界都是$S(x)$，其中$S(x)\in[1,9]$，所以$D(x)\in[1,9]$，我们猜想与模9一定有关系，同时在小范围内，如$[1,9]$，$[11,18]$，$D(x)$与$x$成线性关系且有$\Delta D(x)=\Delta x$，所以我们设$D$的解析式为$D(x)=(i+k)\mod 9+b$，又因为模9的同余系是$[\bar{0},\bar{8}]$，所以$b=1$，随便带一个数进去，就得到了$D$的解析式：
$$D(x)=(i-1)\mod 9+1$$

当然，如果您数感好或吊打我的，直接秒出来即可。

那我们的问题就是求$x\times\big((x-1)\mod 9-1\big)$这样的数在$[l,r]$里的出现次数。

---
设数列$a_i=i\times\big((i-1)\mod 9-1\big)$，看一眼数据范围，疯狂暗示我们找周期呀。

那好吧，我们设周期为$T$，定义如果$a$是他喜欢的数，则$a+T$也是他喜欢的数。

$a$可以表示成$x\times D(x)$

$$a+T=x\times D(x)+T$$
$$=(x+ \dfrac{T}{D(x)})\times D(x)$$
若要将$a+T$也表示$y\times D(y)$的形式，只有
$$a+T=(x+\dfrac{T}{D(x)})\times D(x+\dfrac{T}{D(x)})$$
得到
$$D(x)=D(x+\dfrac{T}{D(x)})$$
首先$\dfrac{T}{D(x)}$应该是整数吧，又因为$D(x)\in[1,9]$，所以
$$T\equiv0\pmod {lcm(1,2,...,9)}$$
$$T\equiv0\pmod {2250}$$

其次因为$D$是关于模9的函数
$$D(x)=D(x+\dfrac{T}{D(x)})$$
$$x\equiv x+\dfrac{T}{D(x)}\pmod 9$$
$$\dfrac{T}{D(x)}\equiv 0\pmod 9$$
如果$T=2250$，它仅仅只有两个3的质因子，若这时$D(x)=9$的话，$\dfrac{T}{D(x)}$将没有3的质因子，出于最坏情况的打算，$T$最小等于$2250\times 9$即$22680$

周期都有了，预处理后硬算即可。

---

## 作者：DESCENDANTSOFDRAGON (赞：0)

## 结论：

对于区间 $[l,r]$ 的每一个数 $i$，如果存在一个 $k$ 使得 $i \equiv k^2  \pmod {9k}$，则这个数 $i$ 是满足条件的。

## 证明：

设一个十进制数 $ \overline{a_{n}a_{n-1} \dots a_{0}} $，则 $ \overline{a_{n}a_{n-1} \dots a_{0}}=10^n \cdot a_{n}+10^{n-1} \cdot a_{n-1}+\dots +10 \cdot a_1+a_{0}  $。

因为 $ 10^n \cdot a_{n}+10^{n-1} \cdot a_{n-1}+\dots +10 \cdot a_1+a_{0} \equiv a_{n}+a_{n-1}+\dots +a_{1}+a_{0} \pmod {9k} $ 

所以 $ S(\overline{a_{n}a_{n-1} \dots a_{0}}) \equiv \overline{a_{n}a_{n-1} \dots a_{0}} \pmod {9k} $。

设 $ r_{k}(n) $ 为使得 $ n \equiv i \pmod k $ 的最小的 $i$

则有 $ D(k)=r_{9}(k) $

关注到：
>$ (9k+1)\cdot 1 = 9k+1 \equiv {1} \pmod 9 $
>
>$ (9k+2)\cdot 2 = 18k+4 \equiv {4} \pmod {18} $
>
> $ \vdots $
>
>$ (9k+i)\cdot i = 9ik+i^2 \equiv {i^2} \pmod {9i} $

故对于每一个 $\bmod\ 9i$ 余 $ i^2 $ 的正整数 $ k $，都是满足条件的数。

## 实现：
剩下的就是暴力（打表）了。

---


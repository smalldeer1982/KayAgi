# 矩阵

## 题目描述

给定一个整数矩阵 $A[n\times m]$，求一个矩阵 $B[n\times m]$，满足 $\forall 1\le i\le n,1\le j\le m,B_{i,j}\in[L,R]$，且使下式值最小：

$$\max\begin{cases}\displaystyle\max_{1\le j\le m}\left\{\left|\sum_{i=1}^n\left(A_{i,j}-B_{i,j}\right)\right|\right\}\\\displaystyle\max_{1\le i\le n}\left\{\left|\sum_{j=1}^m\left(A_{i,j}-B_{i,j}\right)\right|\right\}\end{cases}$$

## 说明/提示

对于 $100\%$ 的数据满足 $n,m\le200$，$0\le L\le R\le1000$，$0\le A_{i,j}\le1000$。

## 样例 #1

### 输入

```
2 2
0 1
2 1
0 1```

### 输出

```
1```

# 题解

## 作者：SGColin (赞：6)

把题面说清楚点:

给定一个大小为 $n\times m$ 的矩阵 $A$，让你求一个大小相同的矩阵 $B$，要求 $B_{i,j}\in[L,R]$，设矩阵 $C$ 为 $C_{i,j}=A_{i,j}-B_{i,j}$，最小化 $C$ 每一行的**和的绝对值**，以及每一列的**和的绝对值**的最大值。

设 $sumh_i$ 表示 $\sum_{j=1}^m A_{i,j}$，设 $suml_i$ 表示 $\sum_{j=1}^n A_{j,i}$ 。

考虑二分答案，那么也就是要求 $|\sum A_{i,j}-\sum B_{i,j}|\le mid$ 。

将绝对值分情况讨论，得到 $\sum B_{i,j}$ 的范围是 $[\sum A_{i,j}-mid,\sum A_{i,j}+mid]$，也就是说每一行 $B$ 的和需要是 $[-mid,mid]+sumh_i$，列也同理。

考虑用有源汇有上下界可行流验证，将每一行，和每一列单独开一个点。 $S$ 向每一行连 $[sumh_i-mid,sumh_i + mid]$ 的边，每一列向 $T$ 连 $[suml_i-mid,suml_i + mid]$ 的边，对应的每一行和每一列连 $[L,R]$ 的边。

如果存在可行流，那么我们构造的 $B$ 矩阵就是： $B_{i,j}$ 为第 $i$ 行抽象出来的点向第 $j$ 列抽象出来的点最后的流量，显然单点的要求和行列的要求都会被满足。

关于二分的合法性，显然是差越大越容易构造。从另一个角度去想，最后重建图的上下界网络流其实边的容量就是 $2mid$，显然 $2mid$ 越大越容易找到解。

```C++
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 405
#define M 100005
#define inf 2000000000
using namespace std;

inline int rd() {
  int x = 0;
  char c = getchar();
  while (!isdigit(c)) c = getchar();
  while (isdigit(c)) {
    x = x * 10 + (c ^ 48); c = getchar();
  }
  return x;
}


int n, m, s, t, S, T, tot, hd[N], dlt[N];

struct E{int to, nxt, f, mnf;} e[M << 1];

inline void add(int u, int v, int f) {
  e[++tot].to = v; e[tot].f = f; e[tot].nxt = hd[u]; hd[u] = tot;
  e[++tot].to = u; e[tot].f = 0; e[tot].nxt = hd[v]; hd[v] = tot;
}

inline void adde(int u, int v, int mnf, int mxf) {
  add(u, v, mxf - mnf);
  e[tot - 1].mnf = mnf;
  dlt[v] += mnf; dlt[u] -= mnf;
}

struct Q {
  int a[N << 1], hd, tl;
  inline void pop() {++hd;}
  inline int front() {return a[hd];}
  inline void reset() {hd = 1; tl = 0;}
  inline void push(int x) {a[++tl] = x;}
  inline bool empty() {return hd > tl;}
} q;

int d[N], h[N];

inline bool bfs() {
  memset(d, 0, sizeof(d));
  q.reset(); q.push(S); d[S] = 1;
  while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int i = hd[u], v; i; i = e[i].nxt)
      if (!d[v = e[i].to] && e[i].f) {
        d[v] = d[u] + 1; q.push(v);
      }
  }
  return d[T] > 0;
}

int dfs(int u, int flow) {
  if (u == T || !flow) return flow;
  int res = 0, tmp;
  for (int &i = h[u], v; i; i = e[i].nxt)
    if (d[v = e[i].to] == d[u] + 1 && e[i].f) {
      tmp = dfs(v, min(e[i].f, flow - res));
      if (!tmp) {d[v] = -1; continue;}
      res += tmp; e[i].f -= tmp; e[i ^ 1].f += tmp;
      if (res == flow) return res;
    }
  return res;
}

inline int dinic() {
  int totf = 0;
  while (bfs()) {
    memcpy(h, hd, sizeof(hd));
    totf += dfs(S, inf);
  }
  return totf;
}

int L, R, a[N][N], sumh[N], suml[N];

inline bool valid(int mid) {
  tot = 1;
  memset(hd, 0, sizeof(hd));
  memset(dlt, 0, sizeof(dlt));
  int sum = 0;
  s = 0; t = n + m + 1;
  for (int i = 1; i <= n; ++i) {
    adde(s, i, sumh[i] - mid, sumh[i] + mid);
    for (int j = 1; j <= m; ++j) adde(i, j + n, L, R);
  }
  for (int i = 1; i <= m; ++i)
    adde(i + n, t, suml[i] - mid, suml[i] + mid);
  add(t, s, inf);
  S = N - 2; T = N - 1;
  for (int i = s; i <= t; ++i)
    if (dlt[i] > 0) {
      add(S, i, dlt[i]); sum += dlt[i];
    }
    else if (dlt[i] < 0) add(i, T, -dlt[i]);
  return dinic() == sum;
}

int main() {
  n = rd(); m = rd();
  for (int i = 1; i <= n; ++i)
    for (int j = 1, x; j <= m; ++j) {
      x = rd(); sumh[i] += x; suml[j] += x;
    }
  L = rd(); R = rd();
  int l = 0, r = 400000, mid;
  while (l < r) {
    mid = (l + r) >> 1;
    valid(mid) ? r = mid : l = mid + 1;
  }
  printf("%d\n", l);
  return 0;
}

```

---

## 作者：SoyTony (赞：4)

本质上是要构造一个值域在 $[L,R]$ 的矩阵 $B$，对于每一行每一列，使得 行或列内 $|\sum A-\sum B|$ 的最大值最小。

这个最大值最小可以想到二分，由于 $A$ 完全已知，这样实际上限制了 $B$ 每一行每一列的和范围在 $[sum-mid,sum+mid]$ 之间，而每个格子的值在 $[L,R]$ 之间，考虑有源汇上下界可行流。

源点向表示行的点连边，上下界如上所述，表示列的点向汇点连边，上下界同理。其余两点之间连 $[L,R]$ 的边。

提一嘴有源汇上下界可行流怎么做。

基础是无源汇可行流，假定全都以下界为流量，建超级源点超级汇点，超级源点连流入更多的，超级汇点连流出更多的（实际上就代替了下界的网络），这样跑最大流，如果能流满超级源点流出的边，就说明是可行的。

而有源汇只需要让流量像无源汇一样转起来，于是汇点向源点连一条没有限制的边即可。（若要求一个可行流流量，那么这条边的流量即为所求）

---

## 作者：LEWISAK (赞：1)

[广告](https://www.cnblogs.com/lewisak)

## 题目大意

给定一个矩阵 $A$，构造一个所有数值都在 $[L,R]$ 中的矩阵 $B$ 使 $A,B$ 矩阵元素差所构成的矩阵的：每一行的和的绝对值与每一列和的绝对值最小。

## 题解

最大值最小一眼二分答案，我们令最终的答案必须 $\le mid$。

注意到当 $A$ 矩阵某一行/列的和为 $sum$ 时，为了让两矩阵该行/列的和的差不超过 $mid$，$B$ 矩阵对应行/列的和的范围就被限制在了 $[sum-mid,sum+mid]$ 中，配合上单个元素的上下界限制，这启示我们使用上下界有源汇可行流判断。

考虑将源点与行/列连上下界为 $A$ 该行/列的和 $\pm mid$ 的边，行与列连上界 $R$，下界 $L$ 的边。

跑上下界有源汇可行流判断即可。

注意到我们的二分的 $mid$ 越大，我们的容量限制就越宽松，自然更容易跑出合法解，所以这是符合二分单调性的。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace kong{bool st;}
namespace zhu{
int all,tot=1,head[100100],lead[100100],dep[100100],gap[100100],n,m,s,t,ys,yt,liu[100100],L,R,a[210][210],si[210],sj[210];
queue<int> q;
struct{
	int nxt,to,w;
}e[200200];
void add(int u,int v,int w){
	e[++tot]={head[u],v,w};
	head[u]=tot;
	e[++tot]={head[v],u,0};
	head[v]=tot;
	return;
}
void add(int u,int v,int l,int r){
	add(u,v,r-l);
	liu[u]-=l,liu[v]+=l;
}
void bfs(){
	while(!q.empty()) q.pop();
	for(int i=1;i<=tot;i++) lead[i]=head[i];
	q.push(t);
	dep[t]=1;
	gap[1]++;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to;
			if(!dep[v]){
				dep[v]=dep[x]+1;
				q.push(v);
				gap[dep[v]]++;
			}
		}
	}
}
int dfs(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=lead[x];i&&rest;i=e[i].nxt){
		lead[x]=i;
		int v=e[i].to,w=e[i].w;
		if(dep[x]==dep[v]+1&&w>0){
			int t=dfs(v,min(rest,w));
			rest-=t;
			e[i].w-=t;
			e[i^1].w+=t;
		}
	}
	if(rest){
		gap[dep[x]]--;
		if(!gap[dep[x]]){
			dep[s]=t+1;
		}
		dep[x]++;
		gap[dep[x]]++;
	}
	return flow-rest;
}
int ISAP(){
	int ans=0;
	memset(dep,0,sizeof(dep));
	memset(gap,0,sizeof(gap));
	bfs();
	while(dep[s]<=t){
		for(int i=1;i<=t;i++){
			lead[i]=head[i];
		}
		ans+=dfs(s,1e18);
	}
	return ans;
}
bool check(int mid){
	memset(liu,0,sizeof liu);
	memset(head,0,sizeof head);
	all=0;tot=1;
	ys=n+m+1,yt=ys+1,s=yt+1,t=s+1;
	for(int i=1;i<=n;i++){
		add(ys,i,max(0ll,si[i]-mid),si[i]+mid);
	}
	for(int i=1;i<=m;i++){
		add(i+n,yt,max(sj[i]-mid,0ll),sj[i]+mid);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			add(i,j+n,L,R);
		}
	}
	add(yt,ys,1e18);
	for(int i=1;i<=yt;i++){
		if(liu[i]>0){
			add(s,i,liu[i]);
			all+=liu[i];
		}
		else if(liu[i]<0){
			add(i,t,-liu[i]);
		}
	}
	if(ISAP()!=all){
		return 0;
	}
	return 1;
}
string main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			si[i]+=a[i][j];
			sj[j]+=a[i][j];
		}
	}
	cin>>L>>R;
	int l=0,r=100000000;
	while(l<r){
		int mid=(l+r)>>1;
		if(check(mid)){
			r=mid;
		}
		else{
			l=mid+1;
		}
	}
	cout<<r<<'\n';
	return "12321";
}
}
namespace kong{bool ed;double MB(){return (&st-&ed)/1048576.0;}}
signed main(){
	cerr<<zhu::main()<<' '<<kong::MB();
	return 0;
}
```

---

## 作者：issue_is_fw (赞：1)

[LINK](https://www.luogu.com.cn/problem/P4194)

找一个矩阵$B$使得每个元素都在$[L,R]$内

设矩阵$C=A-B$

最小化$C$的每一列和的绝对值,每一行和的绝对值的最大值

---

考虑最后的答案是$mid$

那么$C$的每一行$sumh_i$绝对值之和,每一列$suml_i$绝对值之和都小于等于$mid$

也就是$|\sum\limits_{j=1}^m A_{i,j}-\sum\limits_{j=1}^mB_{i,j}|<=mid$

换句话说,我们得到$\sum\limits_{j=1}^mB_{i,j}\in[\sum\limits_{j=1}^mA_{i,j}-mid,\sum\limits_{j=1}^m A_{i,j}+mid]$

对行,列都是类似的这个式子

**于是我们发现,虽然最后的答案没有单调性,但是答案的范围有单调性**

也就是说如果答案满足$|\sum\limits_{j=1}^m A_{i,j}-\sum\limits_{j=1}^mB_{i,j}|<=mid$

那么也一定满足$|\sum\limits_{j=1}^m A_{i,j}-\sum\limits_{j=1}^mB_{i,j}|<=mid+1$

于是我们可以二分这个$mid$,判断每一行每一列的和是否可以在这个范围内

那么为了满足这些限制....我们可以用上下界网络流!!!

新建源点连向每一行,流量为对应的区间

每一列流向新建汇点,流量为对应区间

每一行向每一列连边流量为$[L,R]$,表示在这个格子上填什么数字

都是板子,具体可以看代码了

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 2e5+10;
const int inf = 2e9;
struct edge{
	int to,nxt,flow;
}d[maxn]; int head[maxn],cnt=1;
int in[maxn],out[maxn],n,m,s,t,ss,tt,L,R;
int a[209][209],sumh[209],suml[209];
void add(int u,int v,int l,int r)
{
	l = max(0ll,l);
	in[v] += l, out[u] += l;
	d[++cnt] = ( edge ){v,head[u],r-l},head[u] = cnt;
	d[++cnt] = ( edge ){u,head[v],0},head[v] = cnt;
}
int dis[maxn];
bool bfs(int s,int t,int mx)
{
	for(int i=0;i<=mx;i++)	dis[i] = 0;
	queue<int>q; q.push( s ); dis[s] = 1;
	while( !q.empty() )
	{
		int u = q.front(); q.pop();
		for(int i=head[u];i;i=d[i].nxt )
		{
			int v = d[i].to;
			if( d[i].flow && dis[v]==0 )
			{
				dis[v] = dis[u]+1;	q.push( v );
				if( v==t )	return true;
			}
		}
	}
	return false;
}
int dinic(int u,int t,int flow)
{
	int res = flow;
	if( u==t )	return res;
	for(int i=head[u];i && res;i=d[i].nxt )
	{
		int v = d[i].to;
		if( d[i].flow && dis[v]==dis[u]+1 )
		{
			int temp = dinic(v,t,min(d[i].flow,res) );
			if( temp==0 )	dis[v] = 0;
			d[i].flow -= temp, d[i^1].flow += temp;
			res -= temp;
		}
	}
	return flow-res;
}
vector<int>vec[maxn];
bool isok(int lim)
{
	s = n+m+1, t = s+1, ss = t+1, tt = ss+1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		add(i,n+j,L,R);
	for(int i=1;i<=n;i++)	add(s,i,sumh[i]-lim,sumh[i]+lim);
	for(int i=1;i<=m;i++)	add(i+n,t,suml[i]-lim,suml[i]+lim);
	add(t,s,0,inf);
	int ans = 0;
	for(int i=1;i<=t;i++)
	{
		if( in[i]>out[i] )	add(ss,i,0,in[i]-out[i]),ans += in[i]-out[i];
		else	add(i,tt,0,out[i]-in[i]);
	}
	while( bfs(ss,tt,tt) )	ans -= dinic(ss,tt,inf);
	cnt = 1;
	for(int i=1;i<=tt;i++)	head[i] = in[i] = out[i] = 0;
	return ans==0;
}
signed main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		cin >> a[i][j];
		sumh[i] += a[i][j],suml[j] += a[i][j];
	}
	cin >> L >> R ;
	int l = 0, r = 1e8, ans = 0;
	while( r>=l )
	{
		int mid = ( l+r ) >> 1;
		if( isok(mid) )	r = mid-1, ans = mid;
		else	l = mid+1;
	}
	cout << ans;
}

```

---

## 作者：FutaRimeWoawaSete (赞：0)

不知道为什么想的是有源无汇。~~其实加个汇也就是有源汇了。~~     

因为提前知道这道题是网络流所以就~~冲~~过来了，看完题后有点懵，最小值，最小流？有点摸不着头脑。    

仔细思考了一下，发现这道题的答案具有单调性，即如果一个答案 $res$ 可以被构造出来，那么比 $res$ 大的数也肯定会可能构造出来，所以考虑二分答案。    

而我们本身就知道 $A$ 矩阵里面的行列元素之和，现在只要看当前能否把 $B$ 矩阵里面的行列元素之和控制在一个范围内，就可以判断当前的答案是否合法，诶感觉这好像是可行流？

想到这里后面思路就很清晰了，“限制”的话对应的就是可行流，我们只要把当前的所有限制都放到边上去，然后只要有个流可行，不就相当于告知这个答案可行吗？  

在这里先要讲个这种题的套路：对于这种题目，因为我们矩阵中的一个元素的取值要影响一个行和一个列的结果，所以我们在建图的时候对于矩阵中的每个元素建边时当前元素的流量一定得是由记录该行之和的节点传下来，然后这个元素流量流给该列之和的节点，这样就可以完美解决容量限制。

有了这个套路这道题就有办法切了，首先我们来个大源点 $S$ 给所有记录行之和的节点输送流量，接着行之和的点再给矩阵里面的点输送流量，这些矩阵里面的点再给列之和里面的点输送流量后，我们再把列之和的点流量输回给 $S$ 。

没种边的上下界也不难想到：    

记此时二分值是 $mid$ 。
- $S$ -> $\sum_{i = 1} ^ {n}H_{i}$ ，即 $S$ 流向行之和的点的边上下界就是 $sumH_i - mid \sim sumH_i + mid$    
- $\sum_{i = 1} ^ {n}H_{i}$ -> $a_{i,j}$ 即行之和的点流向矩阵元素的边的上下界就是 $L \sim R$ 。
- $b_{i,j}$ -> $\sum_{i = 1} ^ mL_i$ 即矩阵元素流向列之和的边的上下界就是 $L \sim R$ 。    
- $\sum_{i = 1} ^ mL_i$ -> $S$ 即列之和的点流向 $S$ 的边的上下界就是 $sumL_i - mid \sim sumL_i + mid$ 。    

接着把 $S$ 当成图中的点跑无源汇上下界可行流即可。    

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int Len = 200 * 200 * 5 + 5,Inf = 1e9;
int dep[Len],cnt = 1,head[Len],s,t,S,T,cur[Len],val[Len],a[205][205],sumh[205],suml[205],LL,RR,n,m,sum,ans,minn;
struct node
{
	int next,to,w;
}edge[Len << 1];
void add(int from,int to,int w)
{
	edge[++ cnt].to = to;
	edge[cnt].w = w;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
int BFS()
{
	queue<int> q;
	memset(dep , 0 , sizeof dep);
	q.push(S);dep[S] = 1;cur[S] = head[S];
	while(!q.empty())
	{
		int p = q.front() ; q.pop();
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w)
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				if(T == to) return dep[T];
				q.push(to);
			}
		}
	}
	return dep[T];
}
int dfs(int u,int In)
{
	if(u == T) return In;
	int Out = 0;
	for(int e = cur[u] ; e && In > 0 ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(edge[e].w && dep[to] == dep[u] + 1)
		{
			int res = dfs(to , min(In , edge[e].w));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res; 
		}
	}
	return (!Out) ? dep[u] = 0 : Out;
}
int Clone(int x,int y){return (x - 1) * n + y;}
bool check(int res)
{
	memset(head , 0 , sizeof head) ; cnt = 1;
	memset(val , 0 , sizeof val);
	sum = ans = 0;
	for(int i = 1 ; i < n ; i ++)//处理行
	{
		int now = Clone(i , m) , L = sumh[i] - res , R = sumh[i] + res;//L = sumh[i] - res , R = sumh[i] + res
		add(s , now , R - L) , add(now , s , 0);
		val[now] += L , val[s] -= L;
	}
	for(int i = 1 ; i < m ; i ++)
	{
		int now = Clone(n , i) , L = suml[i] - res , R = suml[i] + res;
		add(now , s , R - L) , add(s , now , 0);
		val[s] += L , val[now] -= L; 
	}
	for(int i = 1 ; i < n ; i ++)
	{
		int now = Clone(i , m);
		for(int j = 1 ; j < m ; j ++)
		{
			int to = Clone(i , j);
			add(now , to , RR - LL) , add(to , now , 0);
			val[to] += LL , val[now] -= LL; 
		}
	} 
	for(int i = 1 ; i < m ; i ++)
	{
		int now = Clone(n , i);
		for(int j = 1 ; j < n ; j ++)
		{
			int to = Clone(j , i);
			add(to , now , RR - LL) , add(now , to , 0);
			val[now] += LL , val[to] -= LL;
		}
	}
	for(int i = 1 ; i <= n * m + 1 ; i ++)
	{
		if(val[i] > 0) add(S , i , val[i]) , add(i , S , 0) , sum += val[i];
		if(val[i] < 0) add(i , T , -val[i]) , add(T , i , 0);
	}
	while(BFS()) ans += dfs(S , Inf);
	if(ans == sum) return true;
	return false;
}
signed main()
{
	minn = 1e9;
	scanf("%d %d",&n,&m);
	n ++ , m ++;
	s = n * m , t = n * m + 1 , S = n * m + 2 , T = n * m + 3; 
	for(int i = 1 ; i <= n - 1 ; i ++)
		for(int j = 1 ; j <= m - 1 ; j ++) 
		{
			scanf("%d",&a[i][j]);
			sumh[i] += a[i][j] , suml[j] += a[i][j];
		}
	for(int i = 1 ; i <= n - 1 ; i ++) minn = min(minn , sumh[i]);
	for(int i = 1 ; i <= m - 1 ; i ++) minn = min(minn , suml[i]);
	scanf("%d %d",&LL,&RR);
	int l = 0 , r = minn,anss;
	while(l <= r)
	{
		int mid = (l + r) >> 1;
		if(check(mid)) anss = mid , r = mid - 1;
		else l = mid + 1; 
	}
	printf("%d\n",anss);
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

有源汇上下界可行流。

二分答案，转化为：$A_{i,j}$ 有上下界，$\sum_{j=1}^m A_{i,j}$ 有上下界，$\sum_{i=1}^n A_{i,j}$ 有上下界。

建立 $n+m+2$ 个点，左部点表示行，右部点表示列，还有源点汇点。左右连边表示一个数。

跑有源汇上下界可行流即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=200+10,MAXV=MAXN*2,MAXE=MAXV*MAXV*2;
struct Edge {
	int to,nxt,w;	
}edge[MAXE];
int n,m,l,r,a[MAXN][MAXN],ot[MAXV],s,t,tot=1,tval[MAXV],hd[MAXV],cur[MAXV],dis[MAXV];
void add_edge(int u,int v,int w) {
	edge[++tot]={v,hd[u],w},hd[u]=tot;
	edge[++tot]={u,hd[v],0},hd[v]=tot;
	return ;
}
int bfs(void) {
	memset(dis,-1,sizeof(dis));
	dis[s]=0; queue<int> q; q.push(s);
	while(!q.empty()) {
		int u=q.front();
		q.pop(),cur[u]=hd[u];
		for(int i=hd[u];i;i=edge[i].nxt) {
			int to=edge[i].to,w=edge[i].w;
			if(!w||dis[to]!=-1) continue ;
			dis[to]=dis[u]+1,q.push(to);
		}
	}
	return dis[t]!=-1;
}
int dinic(int u,int mx) {
	if(u==t) return mx;
	int ans=0;
	for(int i=cur[u];i;i=edge[i].nxt) {
		int to=edge[i].to,w=edge[i].w;
		cur[u]=i;
		if(!w||dis[to]!=dis[u]+1) continue ;
		int tmp=dinic(to,min(mx,w));
		if(tmp) {
			edge[i].w-=tmp,edge[i^1].w+=tmp,ans+=tmp,mx-=tmp;
			if(mx==0) break ;	
		}
	}
	return ans;
}
int check(int lim) {
	s=n+m+2,t=n+m+3;
	tot=1,memset(hd,0,sizeof(hd)),memset(ot,0,sizeof(ot));
	ffor(i,1,n) ffor(j,1,m) ot[i]+=l,ot[j+n]-=l,add_edge(i,j+n,r-l);	
	ffor(i,1,n) {
		int sum=0;
		ffor(j,1,m) sum+=a[i][j];
		int L=max(0ll,sum-lim),R=sum+lim;
		ot[0]+=L,ot[i]-=L,add_edge(0,i,R-L);
	}
	ffor(j,1,m) {
		int sum=0;
		ffor(i,1,n) sum+=a[i][j];
		int L=max(0ll,sum-lim),R=sum+lim;
		ot[n+m+1]-=L,ot[j+n]+=L,add_edge(j+n,n+m+1,R-L);
	}
	add_edge(n+m+1,0,200000000);
	int ans=0,tmp=0;
	ffor(i,0,n+m+1) if(ot[i]>=0) add_edge(i,t,ot[i]); else add_edge(s,i,-ot[i]),ans-=ot[i];
	while(bfs()) while(tmp=dinic(s,200000000)) ans-=tmp;
	return ans==0;
}
int bfind(int l,int r) {
	int ans=-1,mid;
	while(l<=r) {
		mid=l+r>>1;
		if(check(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) ffor(j,1,m) cin>>a[i][j]; cin>>l>>r;
	cout<<bfind(0,200000);
	return 0;
}
```

---


# 学习小组

## 题目描述

共有 $n$ 个学生，$m$ 个学习小组，每个学生只愿意参加其中的一些学习小组，且一个学生最多参加 $k$ 个学习小组。每个学生参加学习小组财务处都收一定的手续费，不同的学习小组有不同的手续费。若有 $a$ 个学生参加第 $i$ 个学习小组，财务处支付奖励 $C_i \times a^2$ 元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱。

## 说明/提示

对于 $100\%$ 的数据，$0＜n\le 100，0＜m≤90，0＜k\le m，0＜C_i\le 10，0＜F_i\le 100。$

## 样例 #1

### 输入

```
3 3 1
1 2 3
3 2 1
111
111
111```

### 输出

```
-2```

# 题解

## 作者：cqbzlym (赞：4)

题解 [P4209](https://www.luogu.com.cn/problem/P4209)。

以来就给我整不会了。怎么处理平方？怎么控制参与总学生最多？其中一定又有什么我不知道的奇技淫巧。

一切尽在连边。

- 处理学生与社团间的选择关系

	把学生向社团连边。学生只能选取某社团一次，故容量为 $1$。

	一个学生选取某个社团并不会立即对最终花费带来可计算的影响，因为最终花费由该社团参与的 **所有学生平方数** 决定。
	
	故这一步我们先不慌计算社团的代价，只算参与社团本身需要的手续费 $F_i$。但是需要注意到手续费是财务部的收入而非支出，故实际边权为 $-F_i$，计算答案时视作负支出（明显不会因此而产生负环，因此可以放心加边）。
- 处理学生的选择数量上限
  
	学生最多只能选择 $K$ 个社团，为保证这一点，我们将源点向学生连边，容量为 $K$。

	很明显，代价也不在此处计算，故令费用为 $0$。
- 保证代价最小

	一开始，我认为最小费用最大流一定会找到最小费用，这个处理是无意义的，后来被打脸了。

	我们若欲在此图中寻得最小费用最大流，则 **流一定最大**。

	而学生的流入容量为 $K$，为了满流，学生一定会尽可能多地选择社团，那么费用就会噌噌上涨。回到目标，即保证学生都选取至少一个社团时，支出最小。

	那我们只要给机会让学生可以只选取一个社团就好了（当然也可以是两个、三个……）。

	故让学生向终点连边，容量为 $K-1$，那么学生可以在选取了所有比较赚的社团后就不再选了，选这条边达到满流。同样因为该边流量只有 $K-1$，学生为了满流就只能再选至少一个社团，满足题意。

	不选社团明显是没有手续费和社团支出的，故费用为 $0$。
- 处理社团本身支出
  
	问题在于如何处理 $a$ 这个平方项。

	对于平方，我们可以联想到许多数学知识，譬如完全平方、平方差等，这里用到了平方差。

	假如原来的代价是 $C_i\times x^2$，又加入了一个人，那么费用会变成 $C_i\times (x + 1)^2$。由平方差得两者之差为 $C_i\times (2\times x + 1)$。当 $x - 1$ 取为任意正整数时，$2\times x + 1$ 即为所有奇数。

	所以我们将社团向汇点连边，连很多条边，每条边表示 **新增一个团员的代价**，容量为 $1$ 表示一个新增团员，费用为从 $1$ 开始，一直到 $2\times (N - 1) + 1$ 的所有奇数。

那么问题到这里就算处理完了。直接上费用流即可。

不知道我的代码遭遇了哪家宇宙射线的侵蚀，Dinic 死活过不去，换成 EK 就过了。同学们如果发现自己的 Dinic 过不了也可以试试换 EK。

```cpp
#define int long long
namespace XSC062 {
using namespace fastIO;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 5e5 + 5;
struct _ {
	int v, c, w, n;
	_() {}
	_(int v1, int c1, int w1, int n1) {
		v = v1, c = c1, w = w1, n = n1;
	}
};
_ u[maxm];
bool inq[maxn];
int n, m, k, x, res;
int gs, gt, tot = 1;
int c[maxn], f[maxn];
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
inline int min(int x, int y) {
	return x < y ? x : y;
}
inline bool SPFA(int s, int n) {
	std::queue<int> q;
	std::fill(dis + 1, dis + n + 1, inf);
	q.push(s), dis[s] = 0, inq[s] = 1;
	pre[s] = inf, pre[gt] = 0, fl[s] = inf;
	while (!q.empty()) {
		int f = q.front();
		q.pop(), inq[f] = 0;
		for (int i = h[f]; i; i = u[i].n) {
			if (u[i].c == 0)
				continue;
			int v = u[i].v, w = u[i].w;
			if (dis[v] > dis[f] + w) {
				pre[v] = i ^ 1;
				dis[v] = dis[f] + w;
				fl[v] = min(fl[f], u[i].c);
				if (!inq[v])
					inq[v] = 1, q.push(v);
			}
		}
	}
	return pre[gt];
}
inline void SSP(int s, int n) {
	int p, mn, d;
	while (SPFA(s, n)) {
		mn = fl[gt], d = 0;
		for (p = gt; p != s; p = u[pre[p]].v) {
			u[pre[p]].c += mn;
			u[pre[p] ^ 1].c -= mn;
			d += u[pre[p] ^ 1].w;
		}
		res += mn * d;
	}
	return;
}
inline void add(int x, int y, int c, int w) {
	u[++tot] = _(y, c, w, h[x]);
	h[x] = tot;
	return;
}
inline void readx(int &x) {
	char ch = nec();
	while (ch != '0' && ch != '1')
		ch = nec();
	x = ch - '0';
	return;
}
int main() {
	read(n), read(m), read(k);
	gs = n + m + 1, gt = gs + 1;
	for (int i = 1; i <= m; ++i) {
		read(c[i]);
		for (int j = 0; j < n; ++j) {
			add(i + n, gt, 1,
					(2 * j + 1) * c[i]);
			add(gt, i + n, 0,
					-(2 * j + 1) * c[i]);
		}
	}
	for (int i = 1; i <= m; ++i)
		read(f[i]);
	for (int i = 1; i <= n; ++i) {
		add(gs, i, k, 0);
		add(i, gs, 0, 0);
		add(i, gt, k - 1, 0);
		add(gt, i, 0, 0);
		for (int j = 1; j <= m; ++j) {
			readx(x);
			if (x == 1) {
				add(i, j + n, 1, -f[j]); // 负代价
				add(j + n, i, 0, f[j]);
			}
		}
	}
	SSP(gs, gt);
	print(res, '\n');
	return 0;
}
} // namespace XSC062
#undef int
```

---

## 作者：flora715 (赞：3)

## 【p4209】学习小组

- 共有n个学生，m个学习小组，规定一个学生最多参加k个学习小组。

- 每个学生参加学习小组要交一定的手续费

- 学校对学习小组奖励 Ci *a(人数)^2 元。

- 在参与学生尽量多的情况下，求最少支出（若为负数，则输出负数）。


------------


**Q：如何处理Ci*a^2？**

**A：每个学习小组向T连——容量为1，费用为Ci×1、Ci×3、Ci×5、Ci×7、...、Ci×(2×n-1)的一堆边，利用平方差关系表示Ci×a^2。**

------------

S向每个学生连容量为k(最多k个小组)、费用为0的边，

学生向能参加的学习小组连容量为1、费用为Fi的边。


    “在参与学生（而不是每个学习小组的人数总和）尽量多的情况下”

指的是所有学生必须有流通过，但不必满流。

所以还要从每个学生向T连一条容量为k-1，费用为0的边，保证费用最小（只参加1个小组）。


------------


```cpp
#include <cmath>
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

#define R register

void reads(int &x){ //读入优化（正负整数）
    int fx=1;x=0;char ch_=getchar();
    while(ch_<'0'||ch_>'9'){if(ch_=='-')fx=-1;ch_=getchar();}
    while(ch_>='0'&&ch_<='9'){x=x*10+ch_-'0';ch_=getchar();}
    x*=fx; //正负号
}

const int N=500019;

struct edge{ int ver,nextt,flow,cost; }e[2*N];

int tot=-1,n,m,k,S,T,maxf=0,minc=0,f[N];

int flow[N],head[N],dist[N],inq[N],pre[N],lastt[N];

void add(int a,int b,int f,int c)
{ e[++tot].nextt=head[a],head[a]=tot,
  e[tot].ver=b,e[tot].flow=f,e[tot].cost=c; } 

bool spfa(int S,int T){
    queue<int> q;
    memset(inq,0,sizeof(inq));
    memset(flow,0x7f,sizeof(flow));
    memset(dist,0x7f,sizeof(dist));
    q.push(S),dist[S]=0,pre[T]=-1,inq[S]=1;
    while(!q.empty()){
        int x=q.front(); q.pop(); inq[x]=0;
        for(int i=head[x];i!=-1;i=e[i].nextt){
            if(e[i].flow>0&&dist[e[i].ver]>dist[x]+e[i].cost){
                dist[e[i].ver]=dist[x]+e[i].cost;
                pre[e[i].ver]=x,lastt[e[i].ver]=i;
                flow[e[i].ver]=min(flow[x],e[i].flow);
                if(!inq[e[i].ver])
                    q.push(e[i].ver),inq[e[i].ver]=1;
            }
        }
    } return pre[T]!=-1;
}

void mcmf(){
    while(spfa(S,T)){
        int now=T; //↓↓最小费用最大流
        maxf+=flow[T],minc+=dist[T]*flow[T];
        while(now!=S){ //↓↓正边流量-，反边流量+
            e[lastt[now]].flow-=flow[T];
            e[lastt[now]^1].flow+=flow[T]; 
            //↑↑利用xor1“成对储存”的性质
            now=pre[now]; //维护前向边last，前向点pre
        }
    }
}

char ss[N]; //每个学生可以加入的小组

int main(){
    reads(n),reads(m),reads(k); S=0,T=n+m+1; memset(head,-1,sizeof(head));
    for(int i=1,x;i<=m;i++){ reads(x); //小组i(编号i+n)向T连多条费用不同的边
        for(int j=1;j<=n;j++) add(i+n,T,1,x*(2*j-1)),add(T,i+n,0,-x*(2*j-1));
    } for(int i=1;i<=m;i++) reads(f[i]); //参加小组i的费用
    for(int i=1;i<=n;i++){ //↓↓从每个学生向T连边，保证每人都有流的情况下费用最小
        add(S,i,k,0),add(i,S,0,0),add(i,T,k-1,0),add(T,i,0,0);
        scanf("%s",ss+1); for(int j=1;j<=m;j++) if(ss[j]=='1') //每人能报的小组
            add(i,j+n,1,-f[j]),add(j+n,i,0,-(-f[j])); //收入用'-'表示
    } mcmf(),printf("%d\n",minc); //在有前提条件の建边情况下的最小费用
}
```


---

## 作者：rechenz (赞：1)

### $\rm tag$：网络流，费用流
---
我第一眼看到这道题的平方建边的时候我还以为需要一些数学方面的优化，但是同机房大佬瞅了一眼跟我说暴力建边能过，我心里一群草泥马奔腾而过。。。

这题的基本建模其实就是按照题意模拟：

$1.$ 从超级源点向每一位同学连一条流量为 $\rm k$，费用为 $0$ 的边。

$2.$ 从每个同学向愿意参加的社团连一条容量为 $1$，费用为手续费的相反数，因为交的手续费算收益（~~赚翻了~~）。

$3.$ 最后便是刚才说的暴力建边，根据公式从每个社团向汇点连 $n$ 条边，每一条边的容量为 $1$,费用为——$C_i \times (2 \times Num-1)$，$Num$ 表示第几条边。

但是我们注意到题目要求的最大流量是参加的人数尽量多而不是学习小组的人数之和，那么我们这里用一个贪心的思想，再从每个同学向汇点连一条容量为 $k-1$，费用为 $0$ 的边，因为我们只要保证这个同学参加了任意一个学习小组就够了。

如果财务处能赚到钱就让学生去参加，赚不到直接让这个学生走费用为 $0$ 的边就好了（~~真黑啊~~）。

复杂度分析：Dinic 复杂度，是肯定能过的啦。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9+7;
const int N=10005;
int n,m,sum,a[N],b[N],head[N],cnt=1,s,t,ans;

struct Edge{
    int to;
    int next;
    int wide;
    int val;
}e[N*N];

void adding(int u,int v,int w,int val){
    e[++cnt].to=v;
    e[cnt].val=val;
    e[cnt].wide=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}
int dis[N],vis[N];
int now[N];
bool SPFA(){
    for(int i=1;i<=t;i++){
        dis[i]=inf;
    }
    dis[s]=0;
    queue<int>q;
    q.push(s);
    vis[s]=1;
    now[s]=head[s];
    while(q.size()){
        int x=q.front();
        q.pop();
        vis[x]=0;
        for(int i=head[x];i;i=e[i].next){
            int v=e[i].to;
            if(e[i].wide&&dis[v]>dis[x]+e[i].val){
                now[v]=head[v];
                dis[v]=dis[x]+e[i].val;
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
    return dis[t]!=inf;
}   

int DFS(int x,int sum){
    if(x==t) return ans+=dis[t]*sum,sum;
    int k,res=0;
    vis[x]=1;
    for(int i=now[x];i&&sum;i=e[i].next){
        int v=e[i].to;
        now[x]=i;
        if(e[i].wide&&(dis[v]==dis[x]+e[i].val)&&!vis[v]){
            k=DFS(v,min(sum,e[i].wide));
            if(k==0){
                dis[v]=inf;
            }
            e[i].wide-=k;
            e[i^1].wide+=k;
            sum-=k;
            res+=k;
        }
    }
    vis[x]=0;
    return res;
}

void Dinic(){
    while(SPFA()){
        DFS(s,inf);
    }
}

int main(){
    scanf("%d%d%d",&n,&m,&sum);
    t=n+m+1;
    for(int i=1;i<=m;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=m;i++){
        scanf("%d",&b[i]);
    }
    for(int i=1;i<=n;i++){//第一步
        adding(s,i,sum,0);
        adding(i,s,0,0);
    }
    char c;
    for(int i=1;i<=n;i++){//第二步
        for(int j=1;j<=m;j++){
            c=getchar();
            if(c!='1'&&c!='0'){//防止字符串出锅
                j--;
                continue;
            }
            if(c=='1'){
                adding(i,j+n,1,-b[j]);
                adding(j+n,i,0,b[j]);
            }
        }
    }
    for(int i=1;i<=m;i++){//暴力第三步
        for(int j=1;j<=n;j++){
            adding(i+n,t,1,a[i]*(2*j-1));
            adding(t,i+n,0,-a[i]*(2*j-1));
        }
    }
    for(int i=1;i<=n;i++){//贪心优化
        adding(i,t,sum-1,0);
        adding(t,i,0,0);
    }
    Dinic();
    printf("%d",ans);
    return 0;
}
```


---

## 作者：Reanap (赞：1)

[原题](https://www.luogu.com.cn/problem/P4209)

这是一道比较优秀的技巧类题目。

我们通过观察数据范围，发现很小，首先排除贪心。

由于题目限制多而复杂，我们考虑使用网络流来描述这个问题。

考虑建立一个网络流框架，大概是我们要求每个能选小组的学生都至少选一个小组，可以使用最大流描述，但是题目有要求支出最少，因此考虑使用费用流进一步描述。

先考虑如何描述参加了一些学生的小组的支出，我们可以发现由于支出增长是平方倍级别的，因此无法直接用同一的费用描述。我们发现由于 $C,F$ 是正数，因此不难证明有以下式子：

$$
C_i \times (a+1)^2 - F_i \times (a+1) - C_i \times a^2 + F_i \times a > C_i \times a^2 - F_i \times a - C_i \times (a-1)^2 + F_i \times (a-1)
$$

即相邻参加人数增加所带来的花费变化量是单调递增的，我们考虑把他的花费进行差分，拆成 $n$ 条边与汇点相连，根据贪心想法，跑费用流时一定会优先选较小的边，因此正确性可以保证。

另外，考虑如何限制每个学生至少选择一个。根据贪心想法，由于询问最少支出，我们考虑在什么时候学生会选择不止一个学习小组。显然，当且仅当多选择小组会让花费更小时我们才会多选，为了保证学生至少选一个我们考虑使用满流的方式限制。因此我们可以从每个学生往汇点连接一条容量为 $k - 1$ ，花费为 $0$ 的边，就可以限制这个学生至少选择一个小组，同时想要多选则花费必须比 $0$ 更小。

至此，我们的建图满足了题目的所有限制条件，代码如下：

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;

template <typename T>
void read(T &x) {
	T f=1;x=0;char s=getchar();
	while(s<'0'||s>'9') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=(x<<3)+(x<<1)+(s^'0');s=getchar();}
	x *= f;
}

const int MAXN = 1e5 + 5;
const int MAXM = 1e5 + 5;
const LL inf = 1e15;

int head[MAXN] , to[MAXM << 1] , nxt[MAXM << 1] , cnt = 1;
LL edge[MAXM << 1] , val[MAXM << 1];
void add(int u , int v , LL c , LL w) {
	nxt[++cnt] = head[u];head[u] = cnt;to[cnt] = v;edge[cnt] = c;val[cnt] = w;
	nxt[++cnt] = head[v];head[v] = cnt;to[cnt] = u;edge[cnt] = 0;val[cnt] = -w;
}

int las[MAXN] , pre[MAXN] , num , s , t , vis[MAXN];
LL dis[MAXN] , flow[MAXN];

struct MinCostMaxFlow {
	LL MaxFlow , MinCost;
	bool bfs() {
		for (int i = 1; i <= num; ++i) las[i] = 0 , dis[i] = inf , pre[i] = 0 , flow[i] = 0 , vis[i] = 0;
		flow[s] = inf , dis[s] = 0;
		queue <int> q;q.push(s);
		int flag = 0;
		while(!q.empty()) {
			int x = q.front();
			q.pop();
			vis[x] = 0;
			for (int i = head[x]; i; i = nxt[i]) {
				if(!edge[i]) continue;
				int v = to[i];
				if(dis[v] > dis[x] + val[i]) {
					dis[v] = dis[x] + val[i];
					flow[v] = min(flow[x] , edge[i]);
					pre[v] = x;
					las[v] = i;
					if(v == t) {
						flag = 1;
						continue;
					}
					if(!vis[v]) vis[v] = 1 , q.push(v);
				}
			}
		} 
		return flag;
	}
	void MVMC() {
		MaxFlow = 0 , MinCost = 0;
		while(bfs()) {
			int now = t;
			MaxFlow += flow[t];
			MinCost += dis[t] * flow[t];
			while(now != s) {
				edge[las[now]] -= flow[t];
				edge[las[now] ^ 1] += flow[t];
				now = pre[now];
			}
		}
	} 
}MIN;

int n , m , k , id[MAXN] , C[MAXN];
int per[MAXN];

int main() {
	read(n),read(m),read(k);
	s = 1 , t = 2 , num = 2;
	for (int i = 1; i <= m; ++i) {
		read(C[i]);
		id[i] = ++num;
	}
	for (int i = 1; i <= m; ++i) {
		int F;
		read(F);
		for (int j = 1; j <= n; ++j) add(id[i] , t , 1 , C[i] * (2 * j - 1) - F);
	}
	for (int i = 1; i <= n; ++i) {
		per[i] = ++num;
		char s[105];
		scanf("%s" , s + 1);
		for (int j = 1; j <= m; ++j) {
			if(s[j] == '1') add(per[i] , id[j] , 1 , 0);
		}
	}
	for (int i = 1; i <= n; ++i) {
		add(s , per[i] , k , 0);
		add(per[i] , t , k - 1 , 0);
	}
	MIN.MVMC();
	printf("%lld" , MIN.MinCost);
	return 0;
}
```

---


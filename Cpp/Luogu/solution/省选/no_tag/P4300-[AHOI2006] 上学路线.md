# [AHOI2006] 上学路线

## 题目描述

可可和卡卡家住 HF 市的东郊，每天上学他们都要转车多次才能到达市区西端的学校。直到有一天他们两人参加了学校的信息学奥林匹克竞赛小组才发现每天上学的乘车路线不一定是最优的。

可可：“很可能我们在上学的路途上浪费了大量的时间，让我们写一个程序来计算上学需要的最少时间吧！”

HF 市一共设有 $N$ 个公交车站，不妨将它们编号为 $1\sim N$ 的自然数，并认为可可和卡卡家住在 $1$ 号汽车站附近，而他们学校在 $N$ 号汽车站。市内有 $M$ 条直达汽车路线，执行第 $i$ 条路线的公交车往返于站点 $p_i$ 和 $q_i$ 之间，从起点到终点需要花费的时间为 $t_i$（$1\leq i\leq M$，$1\leq p_i,q_i\leq N$）。

两个人坐在电脑前，根据上面的信息很快就编程算出了最优的乘车方案。然而可可忽然有了一个鬼点子，他想趁卡卡不备，在卡卡的输入数据中删去一些路线，从而让卡卡的程序得出的答案大于实际的最短时间。而对于每一条路线 $i$ 事实上都有一个代价 $c_i$：删去路线的 $c_i$ 越大卡卡就越容易发现这个玩笑，可可想知道什么样的删除方案可以达到他的目的而让被删除的公交车路线 $c_i$ 之和最小。

编写一个程序：
-  从输入文件中读取 HF 市公交路线的信息；
-  计算出实际上可可和卡卡上学需要花费的最少时间；
-  帮助可可设计一个方案，删除输入信息中的一些公交路线，使得删除后从家到学校需要的最少时间变大，而被删除路线的 $c_i$ 和最小；
- 向输出文件输出答案。

## 说明/提示

$2\leq N\leq 500$，$1\leq M\leq 124750$，$1\leq t_i,c_i\leq 10^4$。

HF 市的公交网络十分发达，你可以认为任意两个车站间都可以通过直达或转车互相到达，当然如果在你提供的删除方案中，家和学校无法互相到达，那么则认为上学需要的最短为正无穷大：这显然是一个合法的方案。

## 样例 #1

### 输入

```
6 7 
1 2 1 3 
2 6 1 5 
1 3 1 1 
3 4 1 1 
4 6 1 1 
5 6 1 2 
1 5 1 4```

### 输出

```
2
5
```

# 题解

## 作者：单曦增 (赞：6)

题意：给定一个无向图，删除某些边有一定的代价，要求删掉使得最短路径减小，求最小代价。

首先要spfa求出起点到各个点的最短距离。对于一条权值为w，起点为i，终点为j的边，设dis[k]为起点到k点的距离，若dis[j]=dis[i]+w，则将该边加入另一个图里，边的容量为删除这条边的代价，则从起点到终点的最大流即为答案。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;

const int inf=0x3fffffff;
const int Maxn=1100000;

int to[Maxn],nxt[Maxn],first[Maxn],t[Maxn],c[Maxn];
int w[Maxn],too[Maxn],nxtt[Maxn],firstt[Maxn];
int n,m,ti,co,u,v,tot=1,e[Maxn];
int b[Maxn],cur[Maxn],dis[Maxn];

inline void add(int u,int v,int ti,int co) {
    to[tot]=v;
    nxt[tot]=first[u];
    t[tot]=ti;
    c[tot]=co;
    first[u]=tot++;
}

inline void add(int u,int v,int wi) {
    too[tot]=v;
    w[tot]=wi;
    nxtt[tot]=firstt[u];
    firstt[u]=tot++;
}

void spfa() {
    queue<int>q;
    memset(dis,0x3f,sizeof(dis));
    memset(e,0,sizeof(e));
    q.push(1);
    dis[1]=0;
    while(!q.empty()) {
        int now=q.front();
        q.pop();
        e[now]=0;
        for(int i=first[now];i;i=nxt[i])
            if(dis[to[i]]>dis[now]+t[i]) {
                dis[to[i]]=dis[now]+t[i];
                if(e[to[i]]==0) {
                    q.push(to[i]);
                    e[to[i]]=1;
                }
            }
    }
}

bool bfs() {
    queue<int>q;
    q.push(1);
    memset(b,0,sizeof(b));
    b[1]=1;
    while(!q.empty()) {
        int now=q.front();
        q.pop();
        for(int i=firstt[now];i;i=nxtt[i])
            if(w[i]&&b[too[i]]==0) {
                b[too[i]]=b[now]+1;
                q.push(too[i]);
            }
    }
    return b[n];
}

int dfs(int root,int flow) {
    if(root==n) return flow;
    for(int &i=cur[root];i;i=nxtt[i])
        if(b[too[i]]==b[root]+1&&w[i]) {
            int temp=dfs(too[i],min(w[i],flow));
            if(temp) {
                w[i]-=temp;
                w[i^1]+=temp;
                return temp;
            }
        }
    return 0;
}

int dinic() {
    int ans=0,temp;
    while(bfs()) {
        memcpy(cur,firstt,sizeof(cur));
        while(temp=dfs(1,inf))
            ans+=temp;
    }
    return ans;
}

int main() {
   // freopen("test.in","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) {
        scanf("%d%d%d%d",&u,&v,&ti,&co);
        add(u,v,ti,co);
        add(v,u,ti,co);
    }
    spfa();
    tot=2;
    for(int i=1;i<=n;i++)
        for(int j=first[i];j;j=nxt[j])
            if(dis[to[j]]==dis[i]+t[j]) {
                add(i,to[j],c[j]);
                add(to[j],i,0);
            }
    printf("%d\n%d\n",dis[n],dinic());
    return 0;
}
```

---

## 作者：稚名真白 (赞：2)

 既然题目已经明确了 **n==500**  
 
 明显是让我们用 **floyd** 啊 
###  吼啊
floyd有以下优点 

1.代码简短

2.代码简短

3.代码简短


之后就是提取最短路跑最小割（最大流） 原理楼上将的很清楚了这里不再重复

但是楼上只讲到过对于最短路的优化  这里简单的提一下最大流的优化

（learn from [咕咕日报](https://www.luogu.org/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp) ）

ISAP 只需要一次bfs的最大流 

说得直接明了 就是记录每层的节点数  每次dfs后若还有余流 则下一次dfs一定不会经过这里 就把该点和儿子的连接给断掉 具体操作就是修改该点的dep 当某层没有节点 即tax [  dep [ u ] ] ==0  表现为该层**断层**   那么从st出发就一定到不了ed 就可以直接return了 

仍然可以加上弧优化 

至于更加高级的预留推进以及HLPP  也可以见此[咕咕日报](https://www.luogu.org/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp)

但是floyd常数还是太大了？  优化了最大流也是900多ms卡过一个点  稳居最优解倒数**第一**！


```cpp
/*
	n=500 故意给这么小 就往floyd方向考虑
	先求出最短路 如果对于一条路径有 d 1,i + d i,j +d j,n == d 1,n
	可知 i->j一定是某一最短路上的边 
	于是吧所有这些边提取出来 求最小割即可！
	NOTE: 注意边的去重
*/
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=505,M=125000;
struct road 
{
	int u,v,d,c; road(){}
	road(int _u,int _v,int _d,int _c)
		{u=_u,v=_v,d=_d,c=_c;}
} r[M];
struct pp {int v,nxt,c;} e[M<<1];
int head[N],dep[N],n,m,tot=1,d[N][N],st,ed,tax[N],cur[N];
inline int min(int a,int b) {return a>b?b:a;}
inline void add(int u,int v,int c)
{
	e[++tot].nxt=head[u];head[u]=tot;e[tot].v=v;e[tot].c=c;
}
inline void bfs()
{
	queue < int > q; q.push(ed);
	tax[dep[ed]=1]++;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int j=head[u];j;j=e[j].nxt)
		{
			int v=e[j].v;if(dep[v]) continue;
			tax[dep[v]=dep[u]+1]++; q.push(v);
		}
	}
}
inline int dfs(int u,int flow)
{
	if(u==ed) return flow;
	int s=0,val;
	for(int&j=cur[u];j;j=e[j].nxt)
	{
		int v=e[j].v,c=e[j].c;
		if(dep[v]+1==dep[u]&&c>0)
		{
			s+=(val=dfs(v,min(c,flow-s)));
			e[j].c-=val;e[j^1].c+=val;
			if(s==flow) return s;
		}
	}
	--tax[dep[u]];
	if(tax[dep[u]]==0) dep[st]=n+1;
	tax[++dep[u]]++; return s;
	
}
int main()
{
	memset(d,0x3f,sizeof(d));
	scanf("%d%d",&n,&m); st=1; ed=n;
	for(int i=1;i<=n;i++) d[i][i]=0;
	for(int i=1,u,v,t,c;i<=m;i++)
	{
		scanf("%d%d%d%d",&u,&v,&t,&c);
		r[i]=road(u,v,t,c);
		d[u][v]=d[v][u]=min(d[u][v],t);
	}
	for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
	for(int i=1;i<=m;i++)
	{
		int u=r[i].u,v=r[i].v,w=r[i].d,c=r[i].c;
		if(u==v) continue;
		if(d[1][u]+w+d[v][n]==d[1][n])
			add(u,v,c),add(v,u,0);
		if(d[1][v]+w+d[u][n]==d[1][n]) 
			add(v,u,c),add(u,v,0);
	} int res=0;
	bfs(); while(dep[st]<=n)
	{
		memcpy(cur,head,sizeof(head));
		res+=dfs(st,23333333);
	}
	printf("%d\n%d\n",d[1][n],res);
	return 0;
}
```




---

## 作者：presucc (赞：2)

题解：


首先要spfa求出起点到各个点的最短距离。对于一条权值为$w$，起点为$i$，终点为$j$的边，设$dis[k]$为起点到$k$点的距离，若$dis[j]=dis[i]+w$，则将该边加入另一个图里，边的容量为删除这条边的代价，则从起点到终点的最大流即为答案。


这是前面那片题解的作者所言。

感谢这篇题解，让我从中获得了一些新的思路和注意到了其他方面的点，而这些可以优化时间复杂度的点是前面题解没有说到的。那我就补充一下。

### 首先我们看到这题的数据范围：

$2<=n<=500$，$1<=M<=124750$

$124750$有什么特别的含义吗？

对，$124750=500*500/2-500/2$

意思就是说这幅图有很大可能是个稠密图。

所以我们最好用上$dijkstra$。~~（但我还是用了spfa，啪打脸）~~

### 其次，就是分享一下我如何想到这题的思路的。

根据题意，这道题有两个问：

```cpp
1. 求出家到学校的最短距离（题面说的是最短时间，但本质都一样）；
2. 去掉一些边，使得家到学校的最短距离变大，在最短距离变大的前提下，要求去掉的边的总长度最小。
```

我们通过画图来找出方法。

这是样例的那幅图：（每条路径左边的数字是距离，右边的是代价）

![](https://cdn.luogu.com.cn/upload/pic/50510.png )

不难得出，第一问的答案就是2 （$1->2->6$ or $1->5->6$）

然后，第二问的答案就是把$5->6$ 和$2->6$两条边删去，输出$2+3=5$

对于第一问，普通最短路径求即可。Floyd刚好可以卡过去500，但是考虑到下面还有个最小割要做，就不要用这种算法。

但是第二问有点麻烦。

看到题面中的
“然而可可忽然有了一个鬼点子，他想趁卡卡不备，在卡卡的输入数据中删去一些路线，从而让卡卡的程序得出的答案大于实际的最短时间”这句话中的“删”，那么一个在图中的算法便浮现在我们脑海里：最小割。

最小割定义：在一个网络里面，如果能删掉某些边，使得网络不连通，那么这个边集就叫“割”。在满足“使得网络不连通”的前提下，得到一组代价最小的边集，这个边集就叫做“最小割”。

但是，最小割仅仅是去掉某些边，和题目意思不符。怎么办呢？

我们考虑把这个图的最短路图求出来，在最短路图上求最小割。

什么是最短路图？

是由许多最短路构成的图啊。。。也就是省去了一些没用的边，怎么判断呢？

### 判断方法

具体方法就是首先跑一次spfa

然后就求了出来单源的最短路$(sssp)$了，然后求最短路图：如果对于一条边，一个端点到1的距离+这个边的边权==另一个端点到$1$的距离，就连边到网络里面。（可以联系最上面那个式子）

最后，就是要证明最小割==最大流了。（可能坐在电脑前的神仙您看到这句话马上就去写最大流了）

蒟蒻我当然不会证明，于是就转载了网上一位写的非常好的一位大牛的证明过程：

### 证明过程：

具体的证明分三部分

1.任意一个流都小于等于任意一个割

这个很好理解 自来水公司随便给你家通点水，构成一个流

恐怖分子随便砍几刀 砍出一个割

由于容量限制，每一根的被砍的水管子流出的水流量都小于管子的容量

每一根被砍的水管的水本来都要到你家的，现在流到外面 加起来得到的流量还是等
于原来的流

管子的容量加起来就是割，所以流小于等于割

由于上面的流和割都是任意构造的，所以任意一个流小于任意一个割

2.构造出一个流等于一个割

当达到最大流时，根据增广路定理

残留网络中$s$到$t$已经没有通路了，否则还能继续增广

我们把s能到的的点集设为$S$,不能到的点集为$T$

构造出一个割集$C[S,T]$,$S$到$T$的边必然满流 否则就能继续增广

这些满流边的流量和就是当前的流即最大流

把这些满流边作为割，就构造出了一个和最大流相等的割

3.最大流等于最小割

设相等的流和割分别为$Fm$和$Cm$

则因为任意一个流小于等于任意一个割

任意$F≤Fm=Cm≤$任意$C$

定理说明完成，证明如下：

对于一个网络流图$G=(V,E)$，其中有源点$s$和汇点$t$，那么下面三个条件是等价的：

1. 流f是图G的最大流

2. 残留网络Gf不存在增广路

3. 对于G的某一个割(S,T)，此时f=C(S,T)

首先证明$1 => $2：

我们利用反证法，假设流$f$是图$G$的最大流，但是残留网络中还存在有增广路$p$，其流量为$fp$。则我们有流$f$′$=f+fp>f$。这与$f$是最大流产生矛盾。


接着证明$2 => $3：


假设残留网络$Gf$不存在增广路，所以在残留网络$Gf$中不存在路径从$s$到达$t$。我们定义$S$集合为：当前残留网络中$s$能够到达的点。同时定义$T=V-S$。此时$(S,T)$构成一个割$(S,T)$。且对于任意的$u∈S$,$v∈T$，有$f(u,v)=c(u,v)$。若$f(u,v)<c(u,v)$，则有$Gf(u,v)>0$，$s$可以到达$v$，与$v$属于$T$矛盾。
    
因此有$f(S,T)=Σf(u,v)=Σc(u,v)=C(S,T)$。


最后证明$3 => 1$：


由于$f$的上界为最小割，当$f$到达割的容量时，显然就已经到达最大值，因此f为最大流。

这样就说明了为什么找不到增广路时，所求得的一定是最大流。

最后，送上代码：

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
//---------------------以下为SSSP-----------------------
const int maxn=1000010;
const int inf=0x3f3f3f3f;
int to[maxn],nxt[maxn],f[maxn],t[maxn],c[maxn];
int n,m,tot=1,edge[maxn],d[maxn];
inline void add(int u,int v,int ti,int co)
{
    to[tot]=v;
    nxt[tot]=f[u];
    t[tot]=ti;
    c[tot]=co;
    f[u]=tot++;
}
void spfa()
{
    queue<int>q;
    memset(d,0x3f,sizeof(d));
    memset(edge,0,sizeof(edge));
    q.push(1);
    d[1]=0;
    while(!q.empty())
    {
        int now=q.front();
        q.pop();
        edge[now]=0;
        for (int i=f[now];i;i=nxt[i])
        {
        	if (d[to[i]]>d[now]+t[i])
            {
                d[to[i]]=d[now]+t[i];
                if (edge[to[i]]==0)
                {
                    q.push(to[i]);
                    edge[to[i]]=1;
                }
            }
		}
    }
}

//-------------------以上为SSSP------------------------

//-------------------以下为dinic-----------------------

int head_dinic[maxn],edge_dinic[maxn],ver_dinic[maxn],d_dinic[maxn],nxt_dinic[maxn];
int tot_dinic,n_dinic,m_dinic,s_dinic,t_dinic,maxflow;
queue<int> q_dinic;
void add_dinic(int x,int y,int z)
{
    ver_dinic[++tot_dinic]=y,edge_dinic[tot_dinic]=z;nxt_dinic[tot_dinic]=head_dinic[x],head_dinic[x]=tot_dinic;
    ver_dinic[++tot_dinic]=x,edge_dinic[tot_dinic]=0;nxt_dinic[tot_dinic]=head_dinic[y],head_dinic[y]=tot_dinic;
}

bool bfs()
{
    memset(d_dinic,0,sizeof(d_dinic));
    while (q_dinic.size()) q_dinic.pop();
    q_dinic.push(s_dinic);d_dinic[s_dinic]=1;
    while (q_dinic.size())
    {
        int x=q_dinic.front();q_dinic.pop();
        for (int i=head_dinic[x];i;i=nxt_dinic[i])
        {
            if (edge_dinic[i]&&!d_dinic[ver_dinic[i]])
            {
                q_dinic.push(ver_dinic[i]);
                d_dinic[ver_dinic[i]]=d_dinic[x]+1;
                if (ver_dinic[i]==t_dinic) return 1;
            }
        }
    }
    return 0;
}
int dinic(int x,int flow)
{
    if (x==t_dinic) return flow;
    int rest=flow,k;
    for (int i=head_dinic[x];i&&rest;i=nxt_dinic[i])
    {
        if (edge_dinic[i]&&d_dinic[ver_dinic[i]]==d_dinic[x]+1)
        {
            k=dinic(ver_dinic[i],min(rest,edge_dinic[i]));
            if (!k) d_dinic[ver_dinic[i]]=0;
            edge_dinic[i]-=k;
            edge_dinic[i^1]+=k;
            rest-=k;
        }
    }
    return flow-rest;
}

//------------------以上为dinic------------------------ 
int main()
{
    scanf("%d %d",&n,&m);
    s_dinic=1;
    t_dinic=n;
    for (int i=1;i<=m;i++)
    {
        int x,y,z,c;
        scanf("%d %d %d %d",&x,&y,&z,&c);
        add(x,y,z,c);
        add(y,x,z,c);
    }
    spfa();
    tot_dinic=1;
    printf("%d\n",d[n]);
    for (int i=1;i<=n;i++)
        for (int j=f[i];j;j=nxt[j])
            if(d[to[j]]==d[i]+t[j])
            	//printf("%d %d %d\n",i,ver[j],ca[j]),
                add_dinic(i,to[j],c[j]);
    int flow=0;
    while (bfs())
        while (flow=dinic(s_dinic,inf))
            maxflow+=flow;
    printf("%d\n",maxflow);
    return 0;
}
```

其实我的代码也有不足之处。spfa和dinic可以弄成两个namespace，而且这变量名也起得非常复杂。

参考博客：

https://blog.csdn.net/qq_41357771/article/details/79416899

https://blog.csdn.net/wbysr/article/details/22685591

---


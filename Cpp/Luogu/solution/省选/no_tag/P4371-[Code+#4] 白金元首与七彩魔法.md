# [Code+#4] 白金元首与七彩魔法

## 题目背景

小朋友 你们好吗　还能记得 我是谁吗　我就是魔法元首まどか！

## 题目描述

「和我签订契约，成为魔法元首吧！」

于是这天元首不明所以地被地外生物 Kyubey 忽悠去成为了魔法元首。不过在开始练习魔法之前，元首需要为自己的魔法选择一个代表色。

下图是一个明度最大（即，HSV 色彩空间中 $V = 100\%$）的单位圆色盘。色盘上任意一点的坐标为一个非负实数对 (α°,$r\%$) $(0 \leq \alpha < 360,0 \leq r \leq 100)$，表示色相为 α°、饱和度为 $r\%$ 的颜色。另一种理解是，α° 表示从联结圆心和纯红色点的射线顺时针到达该点所经过的角度，$\frac {r}{100}$​​ 是该点到单位圆圆心的距离。

![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)

具体而言，从这个坐标 (α°,$r\%$) 到红绿蓝颜色值 $(R,G,B)$ 的转换如下：

![1](https://cdn.luogu.com.cn/upload/pic/16828.png)

请参照样例确认你对公式的理解和实现。

按照 Kyubey 的判断，元首可以选择色盘所在的平面上一条给定直线段 (α1°,$r1\%$)-(α2°,$r2\%$) 上的任意颜色。元首可不需要犹豫，作为一名 bling bling 的帝国领导者，当然要选择最亮的颜色啦！

一个颜色 $(R,G,B)$ 的亮度定义为 $L = 0.30R + 0.59G + 0.11B$。下图给出了彩色色盘和表示亮度的灰度色盘的左右对比。

![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)

你需要编写程序帮助元首计算给定直线段上所有颜色的最大亮度。

## 说明/提示

**样例解释**

点 (30°, $30\%$) 的红绿蓝颜色值为 $(1.00, 0.85, 0.70)$，亮度为 $0.30 \times 1.00 + 0.59 \times 0.85 + 0.11 \times 0.70 = 0.8785$；

点 (120°,$60\%$) 的红绿蓝颜色值为 $(0.40, 1.00, 0.40)$，亮度为 $0.30 \times 0.40 + 0.59 \times 1.00 + 0.11 \times 0.40 = 0.7540$； 

点 (270°,$100\%$) 的红绿蓝颜色值为 $(0.50, 0.00, 1.00)$，亮度为 $0.30 \times 0.50 + 0.59 \times 0.00 + 0.11 \times 1.00 = 0.2600$。

![6](https://cdn.luogu.com.cn/upload/pic/16899.png)

 “Ich glaube, ich habe mich klar genug ausgedrückt!”

题面与史实无关。

Credit: https://www.luogu.org/discuss/show/38908

## 样例 #1

### 输入

```
6
30 30 30 30
120 60 120 60
270 100 270 100
30 30 120 60
120 60 270 100
270 100 30 30```

### 输出

```
0.8785
0.7540
0.2600
0.9704
0.9408
0.8785```

# 题解

## 作者：Mirach (赞：3)

Problem
------------

简要题意：

给定一个极坐标平面，和两个用极坐标表示的点，还有一个根据极坐标得值的函数，求以这两个点为端点的线段上的函数最大值

想要题面和数据可以上[code+](https://cp.thusaac.org/contests)下载

Solution
------------

一看到题就感觉是数学题，求函数极值，然而那个函数好像很复杂

官方题解是暴力扫描，然而蒟蒻比赛时WA4个点死活改不出来，可能是过程中间出现了nan？

然而这题好像可以用爬山，看看这题的阴影部分，发现亮度分布地比较连续而且没有较多的起伏：

所以可见在这里爬山的准确率还是可以的，好像调调参数可以在800ms内？

具体做法就是在先将极坐标转成直角坐标（可以取$(sin,cos)$坐标），再在线段上取等分点，在每个点上选取当前附近比较亮的地方走，并不断缩小步长，调调参数就能A

具体见代码，用向量可能比较方便

Code
---------

爬山：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef long double ld;
#define rg register
#define cl(x) memset(x,0,sizeof(x))
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define abs(x) ((x)>0?(x):(-(x)))

#define eps (1e-8)
#define pi (3.1415926535897932384626323849)

template <typename _Tp> inline _Tp read(_Tp&x){
	rg char c11=getchar(),ob=0;x=0;
	while(c11^'-'&&!isdigit(c11))c11=getchar();if(c11=='-')c11=getchar(),ob=1;
	while(isdigit(c11))x=x*10+c11-'0',c11=getchar();if(ob)x=-x;return x;
}

struct vec{
	double x,y;
	vec(){}
	vec(const double&X,const double&Y){x=X,y=Y;}
	inline vec operator + (const vec&t) const {return vec(x+t.x,y+t.y);}
	inline vec operator - (const vec&t) const {return vec(x-t.x,y-t.y);}
	inline vec operator * (const db &t) const {return vec(x*t,y*t);}
	inline void in(){scanf("%lf%lf",&x,&y);}
};

inline vec r_t_p(vec r){
	vec p;
	double m=sqrt(r.x*r.x+r.y*r.y);
	if(fabs(r.x)<eps&&fabs(r.y)<eps)return vec(0,0);
	else if(r.x>=0&&r.y>=0)p.x=asin(r.x/m);
	else if(r.x>=0&&r.y<=0)p.x=pi-asin(r.x/m);
	else if(r.x<=0&&r.y<=0)p.x=pi+asin(-r.x/m);
	else p.x=pi+pi-asin(-r.x/m);
	p.y=m;
	return p;
}

inline vec p_t_r(vec p){return vec(p.y*sin(p.x),p.y*cos(p.x));}

inline double get(vec d){
	int h=d.x/(pi/3);
	double f=d.x/(pi/3)-h;
	double p=1-d.y;
	double q=1-f*d.y;
	double t=1-(1-f)*d.y;
	switch(h){
		case 0:return 1*0.3+t*0.59+p*0.11;
		case 1:return q*0.3+1*0.59+p*0.11;
		case 2:return p*0.3+1*0.59+t*0.11;
		case 3:return p*0.3+q*0.59+1*0.11;
		case 4:return t*0.3+p*0.59+1*0.11;
		case 5:return 1*0.3+p*0.59+q*0.11;
		default : return 0;
	}
}

int main(){
	vec V,Ap,Bp,Ar,Br;
	int T;read(T);while(T--){
		Ap.in();Ap.x=Ap.x*pi/180.0;Ap.y/=100.0;
		Bp.in();Bp.x=Bp.x*pi/180.0;Bp.y/=100.0;
		Ar=p_t_r(Ap);
		Br=p_t_r(Bp);
		V=Br-Ar;
		double t,t1,t2,f1,f2,stp;
		double nxt1,nxt2,ans=0;
		for(rg int i=0;i<101;++i){  //实测这里可以开到50
			t=i/100.0;
			stp=0.5;
			for(rg int j=1;j<=1000;++j){  //实测这里可以开到170
				t1=t+stp,t2=t-stp;
				t1=fmin(t1,1.0);
				t2=fmax(t2,0.0);
				nxt1=get(r_t_p(Ar+V*t1));
				nxt2=get(r_t_p(Ar+V*t2));
				ans=max(ans,max(nxt1,nxt2));
				t=(nxt1>nxt2?t1:t2);
				stp*=0.95;
			}
		}
		printf("%.4lf\n",ans);
	}
	return 0;
}
```

比赛时打的60分暴力：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rg register
#define cl(x) memset(x,0,sizeof(x))
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define abs(x) ((x)>0?(x):(-(x)))
#define pi (3.14159265358979323846)
#define eps (1e-10)

template <typename _Tp> inline _Tp read(_Tp&x){
	rg char c11=getchar(),ob=0;x=0;
	while(c11^'-'&&!isdigit(c11))c11=getchar();if(c11=='-')c11=getchar(),ob=1;
	while(isdigit(c11))x=x*10+c11-'0',c11=getchar();if(ob)x=-x;return x;
}

inline double get(double a,double r){
	double f,p,q,t;
	int h=(int)((int)(a)/60);
	f=a/60-(double)h;
	p=1-(r/100.0);
	q=1-f*(r/100.0);
	t=1-(1-f)*(r/100.0);
	double R,G,B;
	switch(h){
		case 0:R=1,G=t,B=p;break;
		case 1:R=q,G=1,B=p;break;
		case 2:R=p,G=1,B=t;break;
		case 3:R=p,G=q,B=1;break;
		case 4:R=t,G=p,B=1;break;
		case 5:R=1,G=p,B=q;break;
	}
	return R*0.30+G*0.59+B*0.11;
}

int main(){
	double a1,r1,a2,r2;
	int T;read(T);while(T--){
		scanf("%lf%lf%lf%lf",&a1,&r1,&a2,&r2);
		double ans=0.0;
		double x1=r1*cos(a1*pi/180.0);
		double x2=r2*cos(a2*pi/180.0);
		double y1=r1*sin(a1*pi/180.0);
		double y2=r2*sin(a2*pi/180.0);
		double xx=x1,yy=y1,dx=(x2-x1)/100000.0,dy=(y2-y1)/100000.0;
		for(;((xx-x1<eps&&xx-x2>-eps)||(xx-x2<eps&&xx-x1>-eps))&&
			  ((yy-y1<eps&&yy-y2>-eps)||(yy-y2<eps&&yy-y1>-eps))
		;xx+=dx,yy+=dy){
			double X;
			double Y=sqrt(xx*xx+yy*yy);
			if(yy>eps) X=acos(xx/Y)*180.0/pi;
			else X=360.0-acos(xx/Y)*180.0/pi;
			//if(ans<get(X,Y))printf("%lf %lf %lf\n",X,Y,ans);
			ans=fmax(ans,get(X,Y));
			if(dx==0&&dy==0)break;
		}
		printf("%.4lf\n",ans);
	}
	return 0;
}
```


---

## 作者：cancan123456 (赞：0)

此题其实没什么难点，就是注意直角坐标系和极坐标系的转换就行了。

极坐标系转换成直角坐标系：

$x = r \times cos \ \theta$

$y = r \times sin \ \theta$

直角坐标系转换成极坐标系：

$r = \sqrt{x ^ 2 + y ^ 2}$

$\theta = \begin{cases}\operatorname{atan2(y, x)}&\operatorname{atan2(y, x)}\geq0\\360+\operatorname{atan2(y, x)}&\operatorname{atan2(y, x)}<0\end{cases}$

然后是枚举线段的每一个点的操作：

首先从 $0$ 到 $1$ 枚举 $p$，计算：

$x = (1 - p) \times x_1 + p \times x_2$

$y = (1 - p) \times y_1 + p \times y_2$

那么 $(x, y)$ 就是线段 $(x_1, y_1)$ 到 $(x_2, y_2)$ 的线段上的一个点。

然后把输入的 $a$ 和 $r$ 转换成直角坐标系，枚举每一个点，转换成极坐标系，计算亮度然后取最大值，输出即可。

代码：

```cpp
#include <cstdio>
#include <cmath>
using namespace std;
double max(double a, double b) {
	return a > b ? a : b;
} 
double brightness(double a, double r) {
	int h = a / 60;
	double f = a / 60 - h;
	double p = 1 - r;
	double q = 1 - f * r;
	double t = 1 - (1 - f) * r;
	double R, G, B;
	if (h == 0) {
		R = 1.0;
		G = t;
		B = p;
	} else if (h == 1) {
		R = q;
		G = 1.0;
		B = p;
	} else if (h == 2) {
		R = p;
		G = 1.0;
		B = t;
	} else if (h == 3) {
		R = p;
		G = q;
		B = 1.0;
	} else if (h == 4) {
		R = t;
		G = p;
		B = 1.0;
	} else {
		R = 1.0;
		G = p;
		B = q;
	}
	return 0.30 * R + 0.59 * G + 0.11 * B;
}
void inline solve() {
	double a1, a2, r1, r2;
	scanf("%lf %lf %lf %lf", &a1, &r1, &a2, &r2);
	r1 /= 100.0;
	r2 /= 100.0;
	double x1 = r1 * cos(a1 / 180 * M_PI);
	double y1 = r1 * sin(a1 / 180 * M_PI);
	double x2 = r2 * cos(a2 / 180 * M_PI);
	double y2 = r2 * sin(a2 / 180 * M_PI);
	double ans = 0.0;
	int t = 7500;
	for (int i = 0; i <= t; i++) {
		double p = 1.0 * i / t;
		double x = (1 - p) * x1 + p * x2;
		double y = (1 - p) * y1 + p * y2;
		double a = atan2(y, x) * 180 / M_PI;
		if (a < 0) {
			a = 360 + a;
		}
		double r = sqrt(x * x + y * y);
		ans = max(ans, brightness(a, r));
	}
	printf("%.4lf\n", ans);
}
int main() {
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= t; i++) {
		solve();
	}
	return 0;
}
```

代码中的 $t$ 就是枚举多少个点，开到 $7500$ 就能过。

---


# [SHOI2004] 最小生成树

## 题目描述

给定一个简单图 $G=\langle V.E.W\rangle$，$V$ 为顶点集合，$E$ 为边的集合（无重边，即任意两个顶点之间至多只有一条边)，$W$ 为定义在 $E$ 上的权函数（值为整数)。给出其上的一棵生成树 $T$，现在要求用最小的代价修改 $W$，使得 $T$ 是 $G$ 上的一棵最小生成树（一个图可以有多棵最小生成树，只要 $T$ 的边权和最小即可)。对于任意一条边 $e \in E$ 修改方法为：

- 增加 $e$ 的权值，即令 $W'(e)=W(e)+\Delta(e)$，则修改该边的代价为 $\Delta(e)$
- 减小 $e$ 的权值，即令 $W'(e)=W(e)-\Delta(e)$，则修改该边的代价为 $\Delta(e)$
- 不改变 $e$ 的权，即 $W'(e)=W(e)$，修改代价为 $\Delta(e)=0$。

请注意：修改后的权函数 $W'$ 的值域也为整数。

总的修改代价记为 $S=\sum\limits_{e \in E} \Delta(e)$。

## 说明/提示

边 $(4,6)$ 的权由 $7$ 修改为 $3$，代价为 $4$；  
边 $(1,2)$ 的权由 $2$ 修改为 $3$，代价为 $1$；  
边 $(1,5)$ 的权由 $1$ 修改为 $4$，代价为 $3$；  

所以总代价为 $4+1+3=8$。

$1 \le N \le 50,1 \le M \le 1500,1 \le W_i \le 1000$。

## 样例 #1

### 输入

```
6 9
1 2 2
1 3 2
2 3 3
3 4 3
1 5 1
2 6 3
4 5 4
4 6 7
5 6 6
1 3
2 3
3 4
4 5
4 6```

### 输出

```
8
```

# 题解

## 作者：FLWLW (赞：5)

**列出树边和非树边的关系，并且变换出最小顶标和的形式
注意不一定存在完美匹配（不一定每个点都是匹配点），所以每对两侧点之间连0权值边**
程序：
```
#include <bits/stdc++.h>
using namespace std;
 
const int MAXN = 1000, MAXM = 200000, INF = 0x3f3f3f3f, OFST = 1000000;
 
namespace KM {
    struct Edge {
        int v, len, next;
    };
    int e_ptr, lcnt, rcnt, head[MAXN+10]; Edge E[(MAXM+10)<<1]; 
    int L[MAXN+10], vis[MAXN+10], slack[MAXN+10], mat[MAXN+10];
    void AddEdge(int u, int v, int len) {
        // cerr << u << ' ' << v << ' ' << len << endl;
        E[++e_ptr] = (Edge) { v, len, head[u] }; head[u] = e_ptr;
    }
    void AddPair(int u, int v, int len) {
        AddEdge(u, v, len); AddEdge(v, u, len);
    }
    bool augment(int u) {
        vis[u] = true;
        for(int j=head[u]; j; j=E[j].next) {
            int v=E[j].v, len=E[j].len;
            if(vis[v]) continue;
            int t = L[u] + L[v] - len;
            if(t == 0) {
                vis[v] = true;
                if(!mat[v] || augment(mat[v])) {
                    mat[v] = u; return true;
                }
            } else slack[v] = min(slack[v], t);
        }
        return false;
    }
    inline void update() {
        int d = INF;
        for(int v = lcnt+1; v <= lcnt+rcnt; v++)
            if(!vis[v]) d = min(d, slack[v]);
        for(int u = 1; u <= lcnt; u++)
            if(vis[u]) L[u] -= d;
        for(int v = lcnt+1; v <= lcnt+rcnt; v++)
            if(vis[v]) L[v] += d;
    }
    inline void KM() {
        if(rcnt < lcnt) rcnt = lcnt;
        for(int i = 1; i <= lcnt; i++) {
            for(int j = 1; j <= rcnt; j++)
                AddPair(i, j+lcnt, 0);
        }
        for(int u = 1; u <= lcnt; u++) 
            for(int j=head[u]; j; j=E[j].next)
                L[u] = max(L[u], E[j].len);
        for(int v = lcnt+1; v <= lcnt+rcnt; v++) 
            L[v] = 0;
 
        for(int u = 1; u <= lcnt; u++) {
            memset(slack, 0x3f, sizeof(slack));
            while(true) {
                memset(vis, 0, sizeof(vis));
                if(augment(u)) break;
                else update();
            }
        }
    }
}
 
namespace Graph {
    struct Edge {
        int u, v, len, id;
        inline bool operator<(const Edge& rhs) const { 
            return u == rhs.u ? v < rhs.v : u < rhs.u;
        }
    };
    int n, m, nl, nr, vis[MAXN+10], M[MAXN+10];
    vector<Edge> G[MAXN+10]; 
    vector<Edge> E0, ToAdd;
    void Init() {
        E0.push_back(Edge());
        int u, v, len;
        scanf("%d%d", &n, &m);
        for(int i = 1; i <= m; i++) {
            scanf("%d%d%d", &u, &v, &len);
            if(u > v) swap(u, v); // u < v !
            E0.push_back((Edge){ u, v, len, i });
        }
        sort(E0.begin(), E0.end());
        for(int i = 1; i <= m; i++)
            E0[i].id = i;
        for(int i = 1; i <= n-1; i++) {
            scanf("%d%d", &u, &v);
            if(u > v) swap(u, v);
            vector<Edge>::iterator cur = lower_bound(E0.begin(), E0.end(), (Edge){ u, v, 0, 0 });
            G[u].push_back((Edge) { cur->u, cur->v, cur->len, cur->id }); 
            G[v].push_back((Edge) { cur->v, cur->u, cur->len, cur->id });
            cur->id = -1; // marked as tree edge
        }
    }
    bool EditPath(int u, int t, int id) {
        // cerr << u << '~' << t << ' ' << id << ' ' << E0[id].len << endl;
        vis[u] = true;
        if(u == t) return true;
        for(int j = 0; j < int(G[u].size()); j++) {
            Edge e = G[u][j];
            if(vis[e.v]) continue;
            if(EditPath(e.v, t, id)) {
                // cerr << "back:" << E0[id].len << ' ' << e.len << endl;
                if(E0[id].len < e.len) {
                    if(!M[e.id]) M[e.id] = ++nl;
                    // cerr << nr << "adding" << e.id << endl;
                    ToAdd.push_back((Edge){ M[e.id], nr, e.len - E0[id].len, 0 });
                }
                return true;
            }
        }
        return false;
    }
    void BuildGraph() {
        for(int i = 0; i < int(E0.size()); i++) {
            Edge& cur = E0[i];
            if(cur.id < 0) continue; 
            ++nr;
            // cerr << nr << ":" << cur.u << ' ' << cur.v << ' ' << cur.len << ' ' << cur.id << endl;
            memset(vis, 0, sizeof(vis));
            EditPath(cur.u, cur.v, cur.id);
        }
        KM::lcnt = nl; KM::rcnt = nr;
        for(int i = 0; i < int(ToAdd.size()); i++) {
            Edge& cur = ToAdd[i];
            KM::AddEdge(cur.u, nl + cur.v, cur.len);
        }
    }
}
 
void Init() {
    Graph::Init(); Graph::BuildGraph();
}
 
void Work() {
    int Ans = 0;
    KM::KM();
    for(int u = 1; u <= KM::lcnt + KM::rcnt; u++) {
        // fprintf(stderr, "L[%d] = %d\n", u, KM::L[u]);
        Ans += KM::L[u];
    }
    cout << Ans;
}
 
int main() {
    Init(); Work();
    return 0;
}
```


---

## 作者：bztMinamoto (赞：4)

不难发现，对于每一条树边肯定要减小它的权值，对于每一条非树边要增加它的权值

对于每一条非树边$j$，他肯定与某些树边构成了一个环，那么它的边权必须大于等于这个环上的所有边

设其中一条边为$i$，变化量为$x$，那么就要满足$w_i-x_i\leq w_j+x_j$，即$x_i+x_j\geq w_i-w_j$

然后它就是一个线性规划了，长这个样子
$$Min\sum_i x_i+\sum_jx_j$$
$$x_i+x_j\geq w_i-w_j$$
$$x_i\geq 0$$
然后因为这玩意儿是求目标函数的最小值，所以我们得把它对偶之后变成求它的最大值，然后它长成了这个样子（令$y_k$为第$k$个约束条件对偶后的变量，$d_{k,i}$表示第$k$个约束中是否有$x_i$这个变量）
$$Max\sum (w_i-w_j)y_k$$
$$\sum_k y_kx_{ki}\leq 1$$
$$y_i\geq 0$$
然后直接上单纯形

因为一些精度原因，如果最后的答案在$-eps$到$eps$之间手动输出$0$否则它的答案会是个负数……
```
//minamoto
#include<bits/stdc++.h>
#define R register
#define Loli true
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
const int N=1005,M=10005;const double eps=1e-8,inf=1e18;
struct eg{int v,nx,id;}e[N<<1];int head[N],tot;
inline void add(R int u,R int v,R int id){e[++tot]={v,head[u],id},head[u]=tot;}
int n,m,nn,mm,u,v,x,dep[N],fa[N],id[N],U[N],V[N],W[N],F[N],G[N][N];
double a[N][M];
void dfs(int u){go(u)if(v!=fa[u])fa[v]=u,id[v]=e[i].id,dep[v]=dep[u]+1,dfs(v);}
void pivot(int l,int e){
    double t=a[l][e];a[l][e]=1;fp(i,0,m)a[l][i]/=t;
    fp(i,0,n)if(i!=l&&fabs(a[i][e])>eps){
        t=a[i][e],a[i][e]=0;
        fp(j,0,m)a[i][j]-=t*a[l][j];
    }
}
void simplex(){
    while(Loli){
        int l=0,e=0;double mn=inf;
        fp(i,1,m)if(a[0][i]>eps){e=i;break;}if(!e)return;
        fp(i,1,n)if(a[i][e]>eps&&a[i][0]/a[i][e]<mn)mn=a[i][0]/a[i][e],l=i;
        pivot(l,e);
    }
}
int main(){
//	freopen("testdata.in","r",stdin);
    nn=read(),mm=read();
    fp(i,1,mm)U[i]=read(),V[i]=read(),W[i]=read(),G[U[i]][V[i]]=G[V[i]][U[i]]=i;
    fp(i,1,nn-1)u=read(),v=read(),x=G[u][v],add(U[x],V[x],x),add(V[x],U[x],x);
    dfs(1),n=mm;
    fp(i,1,mm)if(F[i])a[i][0]=1;
    else{
        a[i][0]=1,u=U[i],v=V[i];
        while(u!=v){
            if(dep[u]<dep[v])swap(u,v);
            x=id[u];if(W[x]>W[i])++m,a[x][m]=a[i][m]=1,a[0][m]=W[x]-W[i];
            u=fa[u];
        }
    }simplex();if(a[0][0]<eps&&a[0][0]>-eps)puts("0");
	else printf("%.0lf\n",-a[0][0]);return 0;
}
```

---

## 作者：Deep_Kevin (赞：3)

正题
      
      [https://blog.csdn.net/Deep_Kevin/article/details/84786736](原文)

      首先，我们需要构造一种贪心的思路：

      1.我们不可能给一条生成树边增加一个数。这样只会使的生成树的权值变大，而且对于不选树边的生成树，相对来说变得可能更小。

     2.我们也不可能给一条非生成树边减去一个数，因为这样会使得不选树边的生成树权值变小，从而变得没有那么优秀。

     那么很好理解上面的两条贪心“法则”之后，我们要构造几组约束，使得答案使我们所需要的。

     我们假设是第i条的边的变化量（当然，生成树边表示减少的，非生成树边是增加的）。

     对于一条非树边，肯定对应着生成树边上的一个路径，使得这条路径与这条非树边成为一个环。

     对于这条路径上的任何一条边i，权值一定小于等于非树边j的权值。

     所以。

     变形金刚

     这个时候，很多人就会选择用最小顶标和(KM，二分图最优匹配)来解决。

     其实，线性规划也是很好做的。

     那么就一共最多有条约束，每条约束有m个非基变量（顺便告诉您们洛谷的边数是假的）。

     但是可能会爆空间（洛谷的编译器十分优秀，不会爆）。

     我们就用map来进行存储，在做单纯形算法之前对偶一下即可。

代码<吸口氧气416ms>
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<map>
#include<cmath>
using namespace std;

int n,m;
int num[55][55],d[1555];
bool tf[1555];
bool we=false;
map<int , double> a[1555];
double eps=1e-8;
int tot=0;

void find_loop(int x,int fa,int end,int T){
    if(x==end){
        we=true;
        return ;
    }
    for(int i=1;i<=n;i++){
        if(tf[num[x][i]] && i!=fa){
            find_loop(i,x,end,T);
            if(we){
                tot++;a[num[x][i]][tot]=a[T][tot]=1;a[0][tot]=d[num[x][i]]-d[T];
                break;
            }
        }	
    }
}

void pivot(int x,int y){
    double temp=a[x][y];a[x][y]=1;
    for(int i=0;i<=tot;i++) if(fabs(a[x][i])>eps)a[x][i]/=temp;
    for(int i=0;i<=m;i++) if(x!=i){
    	if(fabs(a[i][y])<=eps) continue;
        temp=a[i][y];a[i][y]=0;
        for(int j=0;j<=tot;j++) 
            if(fabs(a[x][j])>eps) a[i][j]-=temp*a[x][j];
            else a[x].erase(j);
    }
}

void simplex(){
    double mmin;
    int x,y;
    while(true){
        x=y=0;
        for(int i=1;i<=tot;i++) if(a[0][i]>eps && (y==0 || a[0][i]>a[0][y])) y=i;
        if(y==0) break;
        mmin=(double)1e15;
        for(int i=1;i<=m;i++) if(a[i][y]>eps && a[i][0]/a[i][y]<mmin) x=i,mmin=a[i][0]/a[i][y];
        if(x==0) break;
        pivot(x,y);	
    }
}

int main(){
    scanf("%d %d",&n,&m);
    int x,y;
    for(int i=1;i<=m;i++){
        scanf("%d %d %d",&x,&y,&d[i]);
        num[x][y]=num[y][x]=i;
    }
    for(int i=1;i<=n-1;i++){
        scanf("%d %d",&x,&y);
        tf[num[x][y]]=true;
    }
    for(int i=1;i<=m;i++) a[i][0]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<i;j++){
            if(!num[i][j]) continue;
            if(!tf[num[i][j]]){
                we=false;
                find_loop(i,0,j,num[i][j]);
            }
        }
    simplex();
    if(fabs(a[0][0])>eps)printf("%.0lf",-a[0][0]);
    else printf("0");
}
```

---

## 作者：Xttttr (赞：0)

## P4412 题解

[传送门](https://www.luogu.com.cn/problem/P4412) [更好的阅读体验](https://www.cnblogs.com/Xttttr/p/17629845.html)

简化题意：一张无向图，给定一棵生成树，求最小的修改边权的代价使得这棵生成树是最小生成树，代价定义为修改前后一条边的边权变化量的绝对值。

### 思路

首先，发现让这棵树成为最小生成树不好直接处理，但是判定是否为最小生成树却相对更容易。判定的思路也很简单，对于每一条非树边 $(x,y)$，树上 $x$ 到 $y$ 的路径上的任意一条边边权都不能超过这条非树边的边权。

显然，树上的边边权一定不会减小，非树边边权一定不会变大。于是对于一条非树边 $y$ 和在树上的一条边 $x$，有 $w_x+|\Delta x|\geqslant w_y-|\Delta y|$，即 $|\Delta x|+|\Delta y|\geqslant w_y-w_x$。那我们把每一条边当做一个点，点权就是原来的边权，发现原问题就是**最小顶标号**问题，直接求二分图最大权完美匹配可以了。

由于不会写 KM 算法，就写了费用流。

贴一下代码
```
const int N=55,M=1551;
int n,m;
int e[N][N];
struct node{
    int x,y,z;
}edge[M];
bool mark[M];
int cnt,ver[M],nxt[M],h[N],w[N],fa[N],eid[N],dep[N],id[N];
namespace Graph{
    int cnt=1,ver[M<<6],nxt[M<<6],w[M<<6],c[M<<6],h[M<<1],s,t;
    inline void add_edge(int x,int y,int z,int cost){
        // cout<<x<<" "<<y<<" "<<cost<<endl;
        cnt++;ver[cnt]=y;nxt[cnt]=h[x];h[x]=cnt;w[cnt]=z;c[cnt]=cost;
        cnt++;ver[cnt]=x;nxt[cnt]=h[y];h[y]=cnt;w[cnt]=0;c[cnt]=-cost;
    }
    int flow[M<<1],dis[M<<1],lst[M<<1],pre[M<<1];
    bool vis[M<<1];
    inline bool bfsmax(){
        queue<int>q;
        memset(dis,0xc0,sizeof(dis));
        memset(flow,0x3f,sizeof(flow));
        memset(vis,0,sizeof(vis));
        q.push(s);vis[s]=1,dis[s]=0,pre[t]=-1;
        while(q.size()){
            int x=q.front();
            q.pop();
            vis[x]=0;
            for(int i=h[x];i;i=nxt[i]){
                int y=ver[i];
                if(w[i]>0&&dis[y]<dis[x]+c[i]){
                    dis[y]=dis[x]+c[i];
                    pre[y]=x;lst[y]=i;
                    flow[y]=min(w[i],flow[x]);
                    if(!vis[y]){
                        vis[y]=1;
                        q.push(y);
                    }
                }
            }
        }
        return pre[t]!=-1;
    }
    inline int getmax(){
        int maxc=0;
        while(bfsmax()){
            if(dis[t]<0)break;
            maxc+=flow[t]*dis[t];
            int cur=t;
            while(cur!=s){
                w[lst[cur]]-=flow[t];
                w[lst[cur]^1]+=flow[t];
                cur=pre[cur];
            }
        }
        return maxc;
    }
    inline int solve(){
        s=0,t=m+1;
        for(int i=1;i<n;i++)add_edge(s,i,1,0);
        for(int i=n;i<=m;i++)add_edge(i,t,1,0);
        return getmax();
    }
}
inline void add_edge(int x,int y,int z){cnt++;ver[cnt]=y;nxt[cnt]=h[x];h[x]=cnt;w[cnt]=z;}
inline void dfs(int x){
    dep[x]=dep[fa[x]]+1;
    for(int i=h[x];i;i=nxt[i]){
        int y=ver[i];
        if(y!=fa[x]){
            fa[y]=x;
            eid[y]=w[i];
            dfs(y);
        }
    }
}
inline void modify(int x,int y,int z){
    if(dep[x]<dep[y])swap(x,y);
    while(dep[x]>dep[y]){
        Graph::add_edge(id[eid[x]],id[z],1,edge[eid[x]].z-edge[z].z);
        x=fa[x];
    }
    while(x^y){
        Graph::add_edge(id[eid[x]],id[z],1,edge[eid[x]].z-edge[z].z);
        Graph::add_edge(id[eid[y]],id[z],1,edge[eid[y]].z-edge[z].z);
        x=fa[x],y=fa[y];
    }
}
int main(){
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        e[x][y]=e[y][x]=i;
        edge[i]=(node){x,y,z};
    }
    for(int i=1;i<n;i++){
        int x,y;
        cin>>x>>y;
        mark[e[x][y]]=1;
        add_edge(x,y,e[x][y]);add_edge(y,x,e[x][y]);
    }
    for(int i=1,t1=0,t2=n-1;i<=m;i++){
        if(mark[i])id[i]=++t1;
        else id[i]=++t2;
    }
    dfs(1);
    for(int i=1;i<=m;i++){
        if(!mark[i]){
            int x=edge[i].x,y=edge[i].y;
            modify(x,y,i);
        }
    }
    cout<<Graph::solve()<<endl;
    return 0;
}
```

---


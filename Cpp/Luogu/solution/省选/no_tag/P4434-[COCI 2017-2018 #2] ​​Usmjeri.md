# [COCI 2017/2018 #2] ​​Usmjeri

## 题目描述

我们有一棵包含 N 个节点的树，这些节点用从 1 到 N 的不同正整数表示。此外，给定树中的 M 对节点，形式为 $(a_1, b_1), (a_2, b_2), \ldots, (a_M, b_M)$。我们需要为树的每条边指定一个方向，使得对于每一对给定的节点对 $(a_i, b_i)$，存在从 $a_i$ 到 $b_i$ 或从 $b_i$ 到 $a_i$ 的路径。我们需要计算有多少种不同的方法可以实现这一点。由于结果可能非常大，需对 $10^9+7$ 取模。

## 说明/提示

在占总分 20% 的测试用例中，给定的树将是一个链。换句话说，对于所有 $i < N$，节点 $i$ 将通过一条边连接到节点 $i + 1$。在额外的占总分 40% 的测试用例中，将满足 $N, M \leq 5 \times 10^3$。树是一个包含 N 个节点和 N - 1 条边的图，使得每个节点到其他节点都存在路径。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
4 1
1 2
2 3
3 4
2 4```

### 输出

```
4```

## 样例 #2

### 输入

```
7 2
1 2
1 3
4 2
2 5
6 5
5 7
1 7
2 6
```

### 输出

```
8```

## 样例 #3

### 输入

```
4 3
1 2
1 3
1 4
2 3
2 4
3 4
```

### 输出

```
0```

# 题解

## 作者：_maojun_ (赞：12)

一种小常数单 $\log$ 做法。

---

把 $1$ 定为树根，那么对于每条边，要么是指向父亲（$0$），要么是指向儿子（$1$）。

考虑转换 $m$ 条限制：$u\rightarrow lca,v\rightarrow lca$ 的路径上的边分别全 $0$、全 $1$ 或分别全 $1$ 全 $0$。

我们记一个点 $u$ （$1<u\le n$）的点权表示指向 $u$ 的边的状态（$0/1$），则可以得到两条限制（$son_u$ 表示 $lca$ 往 $u$ 跳一步走到的点，$son_v$ 同理）：

1. $u,son_u$ 路径上的点权相同

2. $v,son_v$ 路径上的点权相同

3. $u,v$ 的点权不同（注意若 $lca$ 为 $u$ 或 $v$，则没有这条限制）

那么对于限制 $1,2$，每次合并树上的一条祖先链，连通块内相同。

对于考虑限制 $3$，若 $u,v$ 已经在一个联通块，则矛盾，输出 $0$；否则连接 $u,v$ 所在的联通块。

把连通块缩点，得到一个无向图，则有解必须满足该图可以黑白染色。那直接建出来然后 dfs 一遍就好了。若有解则答案即为 $2$ 的新图的连通块数量次方，因为若联通的点确定，则可以确定；否则不会被确定。

后面的两个操作用并查集复杂度 $O(n\alpha(n))$，问题就是合并一条树链。

考虑给链上除了顶点的点打上一个标记，若一个点超过一个标记，则将它和它的父亲合并。树上差分 + 并查集即可，复杂度 $O(n\alpha(n))$。

于是瓶颈在求 lca，精细实现可以优化到 $O(n)$。我写的是树剖 lca，总复杂度 $O(n\log n)$。

常数非常小，加上快读可以直接拿到（目前的）最优解。

---

```cpp
const int N=3e5+5,MOD=1e9+7;
int n,m,u[N],v[N];
const int E=N<<1;
int tot=0,head[N],to[E],nxt[E];
inline void Add(int u,int v){to[++tot]=v;nxt[tot]=head[u];head[u]=tot;}

int f[N];									// 并查集
inline void init(){for(int i=1;i<=n;i++)f[i]=i;}
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
inline void merge(int u,int v){u=find(u);v=find(v);if(u^v)f[u]=v;}

int fa[N],dep[N],siz[N],son[N],top[N];		// 树剖
void dfs1(int u,int fath){
	fa[u]=fath;dep[u]=dep[fath]+1;siz[u]=1;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];if(v==fath)continue;
		dfs1(v,u);siz[u]+=siz[v];(siz[v]>siz[son[u]])&&(son[u]=v);
	}
}
void dfs2(int u,int tp){
	top[u]=tp;if(!son[u])return;dfs2(son[u],tp);
	for(int i=head[u];i;i=nxt[i]){int v=to[i];if(v^son[u]&&v^fa[u])dfs2(v,v);}
}
inline int LCA(int u,int v){for(;top[u]^top[v];u=fa[top[u]])if(dep[top[u]]<dep[top[v]])swap(u,v);return dep[u]<dep[v]?u:v;}
inline int gson(int u,int v){
	int lst=0;
	for(;top[v]^top[u];v=fa[top[v]])lst=top[v];
	return u==v?lst:son[u];
}

bool vis[N],col[N];
void dfs(int u){							// 黑白染色
	vis[u]=true;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];if(vis[v]){if(col[u]==col[v]){puts("0");exit(0);};continue;}
		col[v]=!col[u];dfs(v);
	}
}
bool fl[N];int d[N];
void dfs(int u,int fath){
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];if(v==fath)continue;
		dfs(v,u);d[u]+=d[v];
	}
	if(d[u])merge(fath,u);					// 若有标记则合并
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<n;i++){scanf("%d%d",&u,&v);Add(u,v);Add(v,u);}
	dfs1(1,0);dfs2(1,1);init();
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u[i],&v[i]);
		int l=LCA(u[i],v[i]);
		if(u[i]^l){d[u[i]]++;d[gson(l,u[i])]--;}
		if(v[i]^l){d[v[i]]++;d[gson(l,v[i])]--;}
		if(u[i]==l||v[i]==l){fl[i]=true;continue;}// 注意特判 lca=u 或 lca=v 的情况
	}
	dfs(1,0);
	tot=0;memset(head,0,sizeof head);
	for(int i=1;i<=m;i++){
		u[i]=find(u[i]);v[i]=find(v[i]);
		if(fl[i])continue;
		if(u[i]^v[i]){Add(u[i],v[i]);Add(v[i],u[i]);}
		else{puts("0");return 0;}			// 若有 u,v 不同的限制，u,v 却在一个块内
	}
	int res=1;
	for(int i=2;i<=n;i++)if(f[i]==i&&!vis[i]){
		dfs(i);res=(res<<1)%MOD;			// 找到一个联通块，答案乘2
	}
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：Tweetuzki (赞：6)

**算法：最近公共祖先；并查集；2-SAT**

---

每一条边只有两种定向的状态，一种从根往叶子，我们不妨称“往下”；一种从叶子往根，我们不妨称“往上”

每一对约束都会使得若干条边产生“你选了一个方向，我就必须选一个方向”的限制，而且如果我们构造出一个合法方案，把每条边反向后，仍然是一个合法的方案。也就是具有对称性

那么这就是一个很显然的 2-SAT 问题了

---

接下来要将这些“$u$ 到 $v$ 存在路径”的约束条件转成 2-SAT 上边与边状态的约束条件

我们将路径分为两种：

- 这是一条从上到下的路径。也就是说深度较小的那个点事深度较大的那个点的祖先
- 这条路径先往上走，再往下走

判断属于哪种路径的方法挺简单，看一下最近公共祖先是不是深度较小的那个点即可

对于第一类路径，路径上所有边方向都要是相同的

这样不需要建 $n^2$ 条边，因为强连通分量是具有传递性的，我们只需要从一条边向它相邻的边连就好了

也就是说对于链上连续的三个点 $g, f, x$，我们只需要将 $g - f$ 这条边到 $f - x$ 这条边连一下限制条件就好了

注意要连双向。也就是两条边 $x, y$，设 $0$ 是向上的状态，$1$ 是向下的状态，我们需要连接 $x_0 \leftrightarrow y_0, x_1 \leftrightarrow y_1$

对于第二类路径，我们设路径两端点为 $u, v$，以及它们的最近公共祖先，称为 $a$

那么在 $a \sim u$ 和 $a \sim v$ 这两条路径上，就和第一类路径类似了

此外还有一个限制，$a \sim u$ 和 $a \sim v$ 这两条路径的边方向必须不同（因为要先上后下）

这样就在 $u$ 往 $u$ 父亲的边（记作 $x$），$v$ 往 $v$ 父亲的边（记作 $y$），加上限制条件 $x_o \leftrightarrow y_1, x_1 \leftrightarrow y_0$ 就好了

---

然后新的问题出现了，这样暴力连是 $\mathcal{O}(mn)$ 的，太慢了

但是我们发现我们会好多次构建一条边与它相邻的边的关系

我们希望每对关系都只被构建一次

我们可以使用并查集

每个节点维护一个 $par_i$，表示这个点往上最早的没有被合并的边（连接的深度较大的点），一开始 $par_i = i$

然后每次合并完，把 $par_i$ 赋为 $fa_i$，其中 $fa_i$ 表示 $i$ 的父亲节点，表示这条边处理过了

这样每次跳边的时候直接 $i = \texttt{Find(i)}$，而不需要每一次 $\texttt{i = fa[i]}$ 了。路径压缩后可以快很多


这里时间复杂度就优化到 $\mathcal{O}(n \log n)$ 了

---

这边 2-SAT 的限制条件是双向边，所以可以直接用并查集解决

然后我们把 2-SAT 跑完了

首先判一下无解——一条边的两个状态在同一个强连通分量中

否则计强连通分量个数为 $S$，答案为 $2^{\frac{S}{2}}$

因为对于每块强连通分量，如果把所有边反向，显然仍然是满足条件的，且不是一块强连通分量不会互相影响

而由于这张图是对称的，所以要把 $S$ 除以 $2$

---

最后看一下时间复杂度

求 LCA：$\mathcal{O}(m \log n)$

建图：$\mathcal{O}(m + n \log n)$

2-SAT：边数最大到 $4m + 4(n - 1)$，点数为 $2(n - 1)$，因此时间复杂度为 $\mathcal{O}(n + m)$

所以总时间复杂度为 $\mathcal{O}(n \log n + m \log n)$

代码：

```cpp
#include <cstdio>
#include <algorithm>

const int MaxN = 300000 + 5, MaxM = 300000 + 5;
const int MaxV = 600000 + 5, MaxE = 1800000 + 5;
const int MaxLog = 20;
const int Mod = 1000000007;

struct Graph {
  int cnte;
  int Head[MaxV], To[MaxE], Next[MaxE];

  inline void add_edge(int from, int to) {
//    printf("add edge from %d to %d\n", from, to);
    cnte++; To[cnte] = to;
    Next[cnte] = Head[from]; Head[from] = cnte;
  }
};

int N, M, S;
int A[MaxM], B[MaxM], par[MaxN];
int fa[MaxLog + 1][MaxN], dep[MaxN], tf[MaxN];
int dfc, low[MaxV], dfn[MaxV], bel[MaxV];
int stk[MaxV], tp; bool in_stack[MaxV];
Graph G, D;

inline int add(int x, int y) { return (x += y) >= Mod ? x - Mod : x; }
inline int sub(int x, int y) { return (x -= y) < 0 ? x + Mod : x; }
inline int mul(int x, int y) { return 1LL * x * y % Mod; }
inline int pw(int x, int y) { int z = 1; for (; y; y >>= 1, x = mul(x, x)) if (y & 1) z = mul(z, x); return z; }

void init() {
  scanf("%d %d", &N, &M);
  for (int i = 1; i < N; ++i) {
    int u, v;
    scanf("%d %d", &u, &v);
    G.add_edge(u, v); G.add_edge(v, u);
  }
  for (int i = 1; i <= M; ++i) {
    scanf("%d %d", &A[i], &B[i]);
  }
}

void dfs(int u) {
  for (int i = G.Head[u]; i; i = G.Next[i]) {
    int v = G.To[i];
    if (v == fa[0][u]) continue;
    fa[0][v] = u; tf[v] = (i + 1) / 2;
    dep[v] = dep[u] + 1;
    for (int j = 1; (1 << j) <= dep[v]; ++j)
      fa[j][v] = fa[j - 1][fa[j - 1][v]];
    dfs(v);
  }
}

inline int getLca(int u, int v) {
  if (dep[u] < dep[v]) std::swap(u, v);
  int d = dep[u] - dep[v];
  for (int i = MaxLog; i >= 0; --i)
    if (d & (1 << i)) u = fa[i][u];
  if (u == v) return u;
  for (int i = MaxLog; i >= 0; --i)
    if (fa[i][u] != fa[i][v]) {
      u = fa[i][u];
      v = fa[i][v];
    }
  return fa[0][u];
}

int Find(int x) { return x == par[x] ? x : par[x] = Find(par[x]); }

void Tarjan(int u) {
  low[u] = dfn[u] = ++dfc;
  stk[++tp] = u; in_stack[u] = true;
  for (int i = D.Head[u]; i; i = D.Next[i]) {
    int v = D.To[i];
    if (dfn[v] == 0) {
      Tarjan(v);
      low[u] = std::min(low[u], low[v]);
    } else if (in_stack[v] == true) {
      low[u] = std::min(low[u], dfn[v]);
    }
  }
  if (low[u] == dfn[u]) {
    S++;
    do {
      int v = stk[tp--];
      bel[v] = S;
      in_stack[v] = false;
    } while (stk[tp + 1] != u);
  }
}

inline void Merge_path(int u, int f) {
//  printf("Merge_path(%d, %d)\n", u, f);
  for (int i = Find(u); dep[i] > dep[f]; i = Find(i)) {
    int e = tf[i], pe = tf[fa[0][i]];
    if (fa[0][i] == f) break;
    D.add_edge(e, pe);
    D.add_edge(pe, e);
    D.add_edge(e + N - 1, pe + N - 1);
    D.add_edge(pe + N - 1, e + N - 1);
    pe = e;
    par[i] = fa[0][i];
  }
}

void solve() {
  dfs(1);

  for (int i = 1; i <= N; ++i) par[i] = i;
  for (int i = 1; i <= M; ++i) {
    int u = A[i], v = B[i];
    if (dep[u] < dep[v]) std::swap(u, v);
    int Lca = getLca(u, v);
//    printf("u = %d, v = %d, Lca = %d\n", u, v, Lca);
    if (Lca == v) {
      Merge_path(u, v);
    } else {
      Merge_path(u, Lca);
      Merge_path(v, Lca);
      D.add_edge(tf[u], tf[v] + N - 1);
      D.add_edge(tf[u] + N - 1, tf[v]);
      D.add_edge(tf[v] + N - 1, tf[u]);
      D.add_edge(tf[v], tf[u] + N - 1);
    }
  }

  for (int i = 1; i <= (N - 1) * 2; ++i)
    if (dfn[i] == 0) Tarjan(i);
  for (int i = 1; i < N; ++i)
    if (bel[i] == bel[i + N - 1]) {
      printf("%d\n", 0);
      return;
    }
  printf("%d\n", pw(2, S / 2));
}

int main() {
  init();
  solve();
  return 0;
}
```

> PS: 如果您对这些算法掌握得熟练的话，您会发现这三个过程有一个神奇的共性：
>
> 求 LCA、建图、解 2-SAT 这三个步骤**都可以通过并查集来解决！**
>
> ~~这没办法谁叫人家 Tarjan 对并查集了如指掌呢~~
>
> 然后只需要写三个并查集就 A 掉这道题了！没有其它算法！
>
> 真的惊了……

---

## 作者：gyyyyx (赞：5)

前置芝士：LCA，并查集。

## 思路

首先，一条从 $u$ 到 $v$ 的路径可以拆分为两条：

- 从 $u$ 走 $a$ 次向上的到两点的 $lca$

- 从两点的 $lca$ 走 $b$ 次向下的到 $v$

**$a$ 和 $b$ 可以为 $0$**

那么如果要使从 $u$ 可以走到 $v$ 就可以分为两个条件：

- 需要第一条路上所有边的方向一致，第二条路上所有边的方向也一致

- 两条路的方向不同。

我们可以用并查集维护这两个条件。

那要之后要干神马呢？

首先看如何满足第一个条件。

我们可以将一条路上的所有边所在的集合合并，这样就可以保证这些边方向相等了。

~~简简单单~~

那第二个条件呢？

很容易看出，**如果有 $A$ 边与 $B$ 边的方向不相等，且 $A$ 边与 $C$ 边的方向也不相等，那么 $B$ 边与 $C$ 边的方向一定相等**。

大家想到什么？

对＜（＾－＾）＞种类并查集！

我们可以用种类并查集的思想解决这个条件！

但是这时的并查集就要开两倍空间。

## 优化

不过这是出现的新的问题：时间是 $O(nm)$ 太慢了。

但是我们会发现，每次合并总会有一些集合是合并过了的。

所以能不能在每次合并时只合并没合并过的集合呢？

我们可以用一个 $par$ 数组存储每一个节点上面，最早（深度最大）没有被合并的边连接的深度较大的那个节点。

那么可以用并查集路径压缩找到当前路径上的所有没有被合并的边。

时间就被优化到了 $O(\log_2{n})$ 了。

## 答案

那最后输出的答案是什么？

因为每一个并查集里面的边方向都要相等，那么答案肯定和并查集数量有关。

假设并查集数量为 $x$，很容易想到答案应该是 $2^x$。

但是因为是种类并查集，数量里面还包含了一些虚设的节点，所有最后答案是 $2^{\frac{x}{2}}$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000005
int n,m,A[N],B[N],LCA[N];
vector <int> t[N];
int fa[N][25],dep[N];
int par[N];
int ans;
#undef N
#define s t[p][i]
inline void dfs(int p,int f){
    fa[p][0]=f;dep[p]=dep[f]+1;
    for(int i(1);i<=20;++i) fa[p][i]=fa[fa[p][i-1]][i-1];
    for(int i(0);i<t[p].size();++i){if(s^f){dfs(s,p);}}
}
#undef s
inline int getlca(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    for(int i(20);i>=0;--i){if(dep[fa[x][i]]>=dep[y]){x=fa[x][i];}}
    if(x^y){
        for(int i(20);i>=0;--i){if(fa[x][i]^fa[y][i]){x=fa[x][i];y=fa[y][i];}}
        return fa[x][0];
    }
    return x;
}
inline int Find(int x){return par[x]^x?par[x]=Find(par[x]):x;}
inline void merge(int x,int pre){
    while(dep[fa[x][0]]>dep[pre]){
        int f(fa[x][0]);
        par[Find(x)]=Find(f);
        par[Find(x+n)]=Find(f+n);
        x=Find(x);
    }
}
#define mod 1000000007
inline int Pow(int a,int b){
    int res(1);
    for(;b;a=(1LL*a*a)%mod,b>>=1){if(b&1){res=(1LL*a*res)%mod;}}
    return res;
}
#undef mod
int main(){
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i(1);i<=(n<<1);++i) par[i]=i;
    for(int i(1);i<n;++i){
        int u,v;cin>>u>>v;
        t[u].push_back(v);
        t[v].push_back(u);
    }
    dfs(1,0);
    for(int i(1);i<=m;++i){
        int x,y;cin>>x>>y;
        if(dep[x]<dep[y]) swap(x,y);
        A[i]=x;B[i]=y;
        int lca(getlca(x,y));
        LCA[i]=lca;
        merge(x,lca);
        merge(y,lca);
    }
    for(int i(1);i<=m;++i){
        int x(A[i]),y(B[i]);
        if(LCA[i]^y){
            par[Find(x+n)]=Find(y);
            par[Find(y+n)]=Find(x);
        }
    }
    for(int i(2);i<=n;++i){
        if(Find(i)==Find(i+n)){
            puts("0");
            return 0;
        }
        ans+=(Find(i)==i)+(Find(i+n)==i+n);
    }
    cout<<Pow(2,ans>>1)<<endl;
    return 0;
}
```

---

## 作者：CYZZ (赞：5)

# [P4434](https://www.luogu.com.cn/problem/P4434)
一种好写的单 $\log$ 做法。
## 思路
发现可以把一条链拆成两条链（从 $u$ 到 $lca$ 的链和从 $lca$ 到 $v$ 的链），这样问题就转化为了不同链之间的约束问题。还有一个简单的 trick 就是把维护边上的信息便为维护点上的信息。

发现这个问题很像 [NOIP2023 T2](https://www.luogu.com.cn/problem/P9869)，考虑使用拓展域并查集：对于一个相互约束的边集，将其丢进一个并查集中。最后答案就是并查集的个数除以二（因为有两个域，以下不再解释用法）

对于一条向下（向儿子）的边，定义它的权值为 $1$，否则为 $0$。

对于一个约束 $(u,v)$，设 $u,v$ 的 LCA 为 $lca$。则有：

- 对于 $u\rightarrow lca$ 上的边，它们的权值相同。
- 对于 $lca\rightarrow v$ 上的边，它们的权值相同。
- 上面两个边集的权值不同。

如果每次暴力地把两条路径合并，复杂度 $\mathcal{O}(n^2\alpha(n))$，无法接受。

发现每次都会有很多重复的合并，可以把合并两条链转化为合并两条边。每次合并链上以 $lca$ 为端点的两条边，同时维护 $bk_i$ 表示 $i$ 上面的两条边是否同向。这样就能把同向的边离线下来合并了。

考虑如何维护 $bk$ 数组，发现树上差分很好维护。最后 dfs 的时候如果 $bk_u=0$ 就把 $u$ 上面的两条边合并即可。

找 $lca$ 下面两个点改一下模板就行了，有一点点细节。无解很好判。
## 代码
```c++
#include <bits/stdc++.h>
using namespace std;
#define mod 1000000007
#define N 300005
int n,m;
int tot,head[N];
struct Edge
{
    int next,to;
}e[N<<1];
void add_edge(int u,int v)
{
    e[++tot].next=head[u];
    e[tot].to=v;
    head[u]=tot;
}
int dep[N],fa[N][21];
void dfs1(int u,int fath)
{
    dep[u]=dep[fath]+1;
    fa[u][0]=fath;
    for(int i=1;i<=20;i++)
    {
        fa[u][i]=fa[fa[u][i-1]][i-1];
    }
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fath)
            continue;
        dfs1(v,u);
    }
}
pair<int,int> LCA(int x,int y)
{
    if(dep[x]<dep[y])
        swap(x,y);
    for(int i=20;i>=0;i--)
    {
        if(dep[fa[x][i]]>dep[y])
            x=fa[x][i];
    }
    if(fa[x][0]==y)//如果在一条链上
        return {x,-1};
    if(dep[x]>dep[y])
        x=fa[x][0];
    for(int i=20;i>=0;i--)
    {
        if(fa[x][i]!=fa[y][i])
        {
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    return {x,y};
}
int sum[N];
int f[N<<1];
int find(int x)
{
    return x==f[x]?x:f[x]=find(f[x]);
}
void Merge(int x,int y)
{
    int u=find(x),v=find(y);
    if(u!=v)
        f[u]=v;
}
void dfs2(int u,int fath)
{
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fath)
            continue;
        dfs2(v,u);
        sum[u]+=sum[v];
    }
    if(sum[u])
    {
        Merge(u,fath);
        Merge(u+n,fath+n);
    }
}
int ans;
int qpow(int x,int y)
{
    int ret=1;
    for(;y;y>>=1,x=1ll*x*x%mod)
    {
        if(y&1)
            ret=1ll*ret*x%mod;
    }
    return ret;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add_edge(x,y);
        add_edge(y,x);
    }
    for(int i=1;i<=2*n;i++)
    {
        f[i]=i;
    }
    dfs1(1,0);
    while(m--)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        auto lca=LCA(x,y);
        if(lca.second==-1)
        {
            if(x==fa[lca.first][0]) sum[y]++;
            else sum[x]++;
            sum[lca.first]--;
        }
        else
        {
            Merge(lca.first,lca.second+n);
            Merge(lca.first+n,lca.second);
            sum[x]++;sum[y]++;
            sum[lca.first]--;sum[lca.second]--;
        }
    }
    dfs2(1,0);
    for(int i=2;i<=n;i++)
    {
        if(find(i)==find(i+n))//无解
        {
            printf("0");
            return 0;
        }
        ans+=(i==find(i));
    }
    printf("%d",qpow(2,ans));
}
```
点个赞再走吧。

---

## 作者：lzqy_ (赞：2)

## 提供一种树链剖分+种类并查集的做法


**前置芝士：树剖，种类并查集。**

假设树以 $1$ 为根，边的方向分为向上（连向根节点）和向下（连向子节点）。

考虑一组 $(x,y)$ 的限制：

![](https://cdn.luogu.com.cn/upload/image_hosting/k0686g5x.png)

如图，该限制可以转换为三个条件：

- $\text{\{x}\rightarrow \text{lca\}}$ 路径上所有边的方向一致。

- $\text{\{y}\rightarrow \text{lca\}}$ 路径上所有边的方向一致。

- $\text{\{x}\rightarrow \text{lca\}},\text{\{y}\rightarrow \text{lca\}}$ 两段路径上边的方向不同。

很明显，上图的信息就是种类并查集可以维护的东西。又因为在树上，所以要套树剖。

考虑用线段树来维护并查集的 $f$ 数组。如果将区间 $[l,r]$ 全部合并到  $X$，可以理解为将区间 $[l,r]$ 全部推平为 $X$。

但在推平的时候，还要进行合并操作。也就是说，当递归区间被 $[l,r]$ 全部包含，不能直接打懒标记，还要满足递归区间内元素在同一集合 $Y$ 中。此时合并集合 $X,Y$，然后再打懒标记。

虽然该操作最高时间复杂度会到 $\text{O(nlogn)}$，但总时间复杂度还是 $\text{O(nlogn)}$ 级的。

**证明**：

设区间 $[l,r]$ 中的元素在 $k$ 个不同的集合内，则一次推平的时间复杂度为 $\text{O(klogn)}$。而推平后，总集合数量减少 $(k-1)$ 个，所以总时间复杂度为 $\text{O((}\sum\text{k)logn)=O(nlogn)}$。

那么最后的答案就是 $2^{集合数}$。如果在过程中出现不合法情况，直接输出 $0$。

**一些易错点：**

- 注意什么时候用节点 $\text{dfn}$ 序，什么时候用节点编号（是树剖老易错点了）。

- 如果 $\text{y=lca}$，不要考虑 $\text{\{x}\rightarrow \text{lca\}},\text{\{y}\rightarrow \text{lca\}}$ 方向不一致的条件。

- 把 $\text{\{u}\rightarrow \text{v\}}$ 合并到集合 $X$ 时，要找对 $X$。

$\text{O(nlog}^\text{2}\text{n)}$ 加至少八倍大常数，细节很多。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000010;
const int N=maxn*5;
const int mod=1e9+7;
inline int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
struct edge{
	int v,to;
}e[maxn];
int head[maxn],ecnt;
void addedge(int u,int v){
	e[++ecnt].v=v,e[ecnt].to=head[u],head[u]=ecnt;
}
bool k[N];
int data[N],lz[N];
int n,m,nn,f[maxn],F[maxn],dep[maxn],DFN[maxn],idx;
int dfn[maxn],top[maxn],fa[maxn],zson[maxn]; 
int Find(int x){
	if(f[x]==x) return x;
	return f[x]=Find(f[x]);
}
bool Query(int x,int y){//合并集合x,y
	int xx=(x>n?x-n:x+n);
	int yy=(y>n?y-n:y+n);
	f[Find(x)]=Find(y);
	if(Find(xx)==Find(x)||Find(y)==Find(yy)) return 0;
    //与先前信息矛盾
	return 1;
}
int fastpow(int n,int m){
	int S=1,a=n;
	while(m){
		if(m&1) S=(S*1ll*a)%mod;
		a=(a*1ll*a)%mod,m>>=1;
	}
	return S;
}
void pushdown(int i){
	if(!lz[i]) return ;
	lz[i<<1]=lz[i<<1|1]=lz[i];
	data[i<<1]=data[i<<1|1]=lz[i];
	lz[i]=0;
}
bool Check(int i){//判断区间是否在一个集合内
	return (k[i<<1]&&k[i<<1|1]&&(Find(data[i<<1])==Find(data[i<<1|1])||!data[i<<1]||!data[i<<1|1]));
}
void build(int i,int l,int r){
	if(l>r){
		k[i]=1;//如果l>r,也认为区间在同一集合中
		return ;
	} 
	if(l==r){
		data[i]=f[DFN[l]],k[i]=1;
		return ;
	}
	int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	k[i]=Check(i),data[i]=data[i<<1];
}
void merge(int i,int l,int r,int L,int R,int x){
	if(l>R||r<L) return ;
	if(l>=L&&r<=R&&k[i]){ //递归区间属于同一集合且被[l,r]包含
		if(!Query(data[i],x)){
			printf("0\n");
			exit(0);//直接结束程序
		} 
		data[i]=x,lz[i]=x;
		return ;
	}
	pushdown(i);
	int mid=l+r>>1;
	merge(i<<1,l,mid,L,R,x);
	merge(i<<1|1,mid+1,r,L,R,x);
	k[i]=Check(i),data[i]=data[i<<1];
}
void Out(int i,int l,int r){//将当前的f数组存到F中
	if(l==r){
		F[DFN[l]]=Find(data[i]);
		return ;
	}
	pushdown(i);
	int mid=l+r>>1;
	Out(i<<1,l,mid);
	Out(i<<1|1,mid+1,r);
}
int dfs1(int fath,int x){
	fa[x]=fath,dep[x]=dep[fath]+1;
	int sum=1,Max=-1,xx;
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fath){
			sum+=(xx=dfs1(x,e[i].v));
			if(xx>Max) Max=xx,zson[x]=e[i].v;
		}
	return sum;
}
void dfs2(int x){
	dfn[x]=++idx,dfn[x+n]=idx+n,DFN[idx]=x,DFN[idx+n]=n+x;
	if(zson[fa[x]]==x) top[x]=top[fa[x]];
	else top[x]=x;
	if(zson[x]) dfs2(zson[x]);
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa[x]&&e[i].v!=zson[x])
			dfs2(e[i].v);
}
void Solve(int x,int y){
	int X=0,Y=0,xx=x,yy=y;
	//{x->lca}合并到集合X
	//{y->lca}合并到集合Y
  while(top[xx]^top[yy])//先跑一次树剖找到X和Y
		if(dep[top[xx]]>dep[top[yy]]) X=xx,xx=fa[top[xx]];
		else Y=yy,yy=fa[top[yy]];
	if(dep[xx]>dep[yy]) X=xx;
	else if(dep[yy]>dep[xx]) Y=yy;	
	while(top[x]^top[y])
		if(dep[top[x]]>dep[top[y]]){
			if(Y) merge(1,1,nn,dfn[top[x]],dfn[x],n+Y),merge(1,1,nn,dfn[top[x]]+n,dfn[x]+n,Y);
			if(X) merge(1,1,nn,dfn[top[x]],dfn[x],X),merge(1,1,nn,dfn[top[x]]+n,dfn[x]+n,X+n);
			x=fa[top[x]];
		}	
		else{
			if(X) merge(1,1,nn,dfn[top[y]],dfn[y],n+X),merge(1,1,nn,dfn[top[y]]+n,dfn[y]+n,X);
			if(Y) merge(1,1,nn,dfn[top[y]],dfn[y],Y),merge(1,1,nn,dfn[top[y]]+n,dfn[y]+n,Y+n);
			y=fa[top[y]];
		}
	if(x==y) return ;
	if(dep[x]>dep[y]) {
		if(X) merge(1,1,nn,dfn[y]+1,dfn[x],X),merge(1,1,nn,dfn[y]+1+n,dfn[x]+n,n+X);
		if(Y) merge(1,1,nn,dfn[y]+1,dfn[x],Y+n),merge(1,1,nn,dfn[y]+1+n,dfn[x]+n,Y);
	}
	else{
		if(Y) merge(1,1,nn,dfn[x]+1,dfn[y],Y),merge(1,1,nn,dfn[x]+1+n,dfn[y]+n,n+Y); 
		if(X) merge(1,1,nn,dfn[x]+1,dfn[y],X+n),merge(1,1,nn,dfn[x]+1+n,dfn[y]+n,X);
		//如果X,Y不存在(即lca=x或lca=y)就不合并,合并反而有问题
		//(相当于合并到集合0中,会误判不合法)
	} 
}
int main(){
	int x,y,cnt=0;
	n=read(),m=read(),nn=n+n;
	for(int i=1;i<n;i++){
		x=read(),y=read();
		addedge(x,y);
		addedge(y,x);
	}
	for(int i=1;i<=nn;i++) f[i]=i;
	dfs1(0,1),dfs2(1),build(1,1,nn);
	for(int i=1;i<=m;i++){
		x=read(),y=read();
		Solve(x,y);
	}
	Out(1,1,nn);
	for(int i=2;i<=n;i++)
		if(Find(F[i])==i) cnt++;
	printf("%d\n",fastpow(2,cnt));
	return 0;
}
```

---

## 作者：xfrvq (赞：1)

_来源：xsy **CSP-J 模拟赛** 18C。_  
摘要：**比之前相同题解简单**。扩展域并查集，倍增/树剖 $\tt LCA$。

---

首先，对于一条路径而言，只要固定了其中一条边的方向，整个路径的方向都会固定。 

进一步地，如果两条路径的边有交集，这两条路径的方向是同步的。

我们把同步的若干路径的边视为一个联通块。这个联通块是同步的，因此只会有正着走和反过来两种情况。

设联通块个数为 $x$，因为每个联通块都有两种情况，所以答案就为 $2^x$。

---

提到联通块，可以自然想到并查集维护。

我们考虑怎么找联通块。首先对于询问的路径都加一个 $1$ 的权值。

![](https://img-blog.csdnimg.cn/fcd5abf0be1e4a15a144f97c68a55f6c.png)

（样例 $\tt2$，蓝框和红框分别是两条路径）

然后我们大胆猜测，相邻的两个权值非 $0$ 的边是一个联通块的（真的是这样吗）。跑一遍 $\tt dfs$ 就做完了。

如上图，四条有权值的边是一个联通块，两个权值为 $0$ 的边是两个联通块，答案就是 $2^3=8$。

---

然后我们观察样例 $\tt3$，发现有出现矛盾的情况，此时答案是 $0$。

我们发现矛盾源于：对于一条路径 $u\to v$，$u\to\tt LCA$ 段的方向和 $v\to\tt LCA$ 段的方向必是一上一下刚好相反。

我们考虑一个能建正反边的并查集：扩展域并查集。范围为 $2n$，用 $i+n$ 表示 $i$ 的反点。

+ $i$ 和 $j$ 连正边：连 $i\longleftrightarrow j$、$i+n\longleftrightarrow j+n$。
+ $i$ 和 $j$ 连反边：连 $i+n\longleftrightarrow j$、$i\longleftrightarrow j+n$。

然后我们把路径拆分成 $u\to\tt LCA$ 和 $v\to\tt LCA$ 段，并在这两段中任取两点连上一条反边，接着两段内部都连正边就行。这样如果正反出现冲突那答案就是 $0$。

---

本来以为做完了，但是有一种情况，就是两条路径刚好相邻，按照我们的判定这两个路径是同步的。实则不然。

这种情况可以考虑维护两个权值，一个就是单纯的路径加，另一个不加路径的最上方边。

---

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 3e5 + 5;
const ll mod = 1e9 + 7;

int n,m,a[N],b[N],ft[2 * N];
int dep[N],fa[21][N],cnt;
ll res = 1;
vector<int> G[N];

int fnd(int x){
	return x == ft[x] ? x : ft[x] = fnd(ft[x]);
}

void mrg(int x,int y,bool f){
	ft[fnd(x)] = fnd(y + n - f * n);
	ft[fnd(x + n)] = fnd(y + f * n);
}

void dfs(int u,int ft){
	dep[u] = dep[fa[0][u] = ft] + 1;
	for(int i = 1;i <= 20;++i)
		fa[i][u] = fa[i - 1][fa[i - 1][u]];
	for(int v : G[u]) if(v != ft) dfs(v,u);
}

int lca(int u,int v){
	if(dep[u] < dep[v]) swap(u,v);
	for(int i = 20;~i;--i)
		if(dep[fa[i][u]] >= dep[v]) u = fa[i][u];
	if(u == v) return u;
	for(int i = 20;~i;--i)
		if(fa[i][u] != fa[i][v]) u = fa[i][u],v = fa[i][v];
	return fa[0][u];
}

int jump(int u,int d){
	if(d < 0) return -1;
	for(int i = 20;~i;--i)
		if(d >> i & 1) u = fa[i][u];
	return u;
}

void dfs(int u){
	for(int v : G[u]) if(v != fa[0][u])
		dfs(v),a[u] += a[v],b[u] += b[v];
	for(int v : G[u]) if(v != fa[0][u])
		if(b[v] && a[u]) mrg(u,v,1);
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1,u,v;i < n;++i){
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for(int i = 1;i <= 2 * n;++i) ft[i] = i;
	dfs(1,0);
	for(int i = 1,u,v,p;i <= m;++i){
		scanf("%d%d",&u,&v),p = lca(u,v);
		++a[u],++a[v],a[p] -= 2;
		int x = jump(u,dep[u] - dep[p] - 1);
		int y = jump(v,dep[v] - dep[p] - 1);		
		if(~x) ++b[u],--b[x];
		if(~y) ++b[v],--b[y];
		if(~x && ~y) mrg(x,y,0);
	}
	dfs(1);
	for(int i = 2;i <= n;++i){
		if(fnd(i) == fnd(i + n)) res = 0;
		cnt += (ft[i] == i) + (ft[i + n] == i + n);
	}
	cnt /= 2; while(cnt--) (res *= 2) %= mod;
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

细节很多的一题。

首先考虑刻画条件，存在 $u \to v$ 或者 $v \to u$ 代表存在路径 $(u,lca)$ 与 $(v,lca)$ 且他们路径上的边方向相同但两条路径的方向不同。

先考虑刻画一条链上的方向相同，考虑树上差分，如果两条边均被覆盖过就认为他们的方向相同，但是这样可能会把刚好相邻的两条路径算成相同的，所以需要保证下面那条路径不是路径的最后一条边，再维护一个除去最后一条边的差分即可。

然后方向不同考虑使用种类并查集，在两条路径上随便选一条边链反边，前面相同方向的边链正边。

此时无解就可以使用种类并查集判断了。

又因为一个连通块内的边方向相同代表只有两种方案，因此方案数是 $2^{cnt}$ 其中 $cnt$ 是连通块数量除以 $2$（种类并查集的虚点不能算）。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 3e5+114;
vector<int> edge[maxn];
int n,m,w[maxn],w1[maxn];
vector< pair<int,int> > E;
int fa[maxn][20];
int dep[maxn],lg[maxn];
void dfs1(int u,int father){
    fa[u][0]=father;
    dep[u]=dep[father]+1;
    for(int i=1;i<=19;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int v:edge[u]){
        if(v==father) continue;
        dfs1(v,u);
    }
}
int LCA(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    while(dep[u]>dep[v]) u=fa[u][lg[dep[u]-dep[v]]];
    if(u==v) return u;
    for(int i=19;i>=0;i--){
        if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
    }
    return fa[u][0];
}
void dfs2(int u){
    for(int v:edge[u]){
        if(v==fa[u][0]) continue;
        dfs2(v);
        w[u]+=w[v];
        w1[u]+=w1[v];
    }
}
const int mod = 1e9+7;
int qpow(int a,int b){
    if(b==0) return 1;
    if(b==1) return a;
    int res=qpow(a,b/2);
    res=res*res%mod;
    if(b%2==1) res=res*a%mod;
    return res;
}
int FA[maxn<<1];
int found(int u){return FA[u]=(FA[u]==u?u:found(FA[u]));}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    lg[1]=0;
    for(int i=2;i<=n;i++) lg[i]=lg[i/2]+1;
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    dfs1(1,0);
    while(m--){
        int u,v;
        cin>>u>>v;
        int lca=LCA(u,v);
        if(u!=lca){
            int lstu=u;
            for(int i=19;i>=0;i--) if(dep[fa[lstu][i]]>dep[lca]) lstu=fa[lstu][i];
            w1[u]++;
            w1[lstu]--;
        }
        if(v!=lca){
            int lstv=v;
            for(int i=19;i>=0;i--) if(dep[fa[lstv][i]]>dep[lca]) lstv=fa[lstv][i];
            w1[v]++;
            w1[lstv]--;
        }
        w[u]++;
        w[v]++;
        w[lca]-=2;
        if(lca!=u&&lca!=v) E.push_back(make_pair(u,v));
    }
    dfs2(1);
    for(int i=1;i<=n;i++) FA[i]=i,FA[i+n]=i+n;
    for(int i=1;i<=n;i++){
        if(w1[i]>0&&w[fa[i][0]]>0){
        	int u=i,v=fa[i][0];
        	int U=i+n,V=fa[i][0]+n;
        	u=found(u),v=found(v);
        	U=found(U),V=found(V);
        	FA[u]=v;
        	FA[U]=V;
		}
    }
    for(pair<int,int> now:E){
        int u=found(now.first),v=found(now.second);
        int U=now.first+n,V=now.second+n;
        u=found(u),v=found(v);
        U=found(U),V=found(V);
        FA[u]=V;
        FA[v]=U;
    }
    for(int i=1;i<=n;i++){
    	if(found(i)==found(i+n)){
    		cout<<0<<'\n';
    		return 0;
		}
	}
    int cnt=0;
    for(int i=1;i<=n*2;i++){
    	if(i%n==1) continue;
        if(found(i)==i) cnt++;
    }
    cnt/=2;
    cout<<qpow(2,cnt)%mod<<'\n';
    return 0;
}
```




---

## 作者：Piggy343288 (赞：0)

远古模拟赛里的一道题，前来写篇题解记录一下。  

我们考虑一个显然的转化。将每条边染色，那么原问题等价于求下面的染色的方案数：  

对于每个点对 $a,b$，我们记 $\operatorname{lca}(a,b)=c$ 有
- $a\sim c$ 上的所有边同色。
- $b\sim c$ 上的所有边同色。
- $a\sim c$ 和 $b\sim c$ 上的边不同色。  

再次转化。构造一张图 $(*)$，这张图上的每个点是原图的一条边。这张图满足对于每一对 $a,b,c$，$a/b\sim c$ 上的所有边（新图的点）用蓝色边连接，且对于 $c\not =a,b$ 用红色边连接 $(a,fa[a])$ 和 $(b,fa[b])$。  

现在问题就转化成了，对这张新图的点染色，使得用蓝色边连接的点颜色相同，用红色边连接的节点颜色不同。显然我们先分别求每个连通块的结果即可。
这样考虑的话，我们发现一个节点的颜色唯一确定了这张图的所有点的颜色。这也同时意味着，如果存在一个合理的涂色方案，我们对这张图完全颜色反转，结果没有变化。因此我们只需要处理连通块是否不存在合法方案，搜一下就行。这样我们经过多次转化，问题可以轻易解决。如果存在不合法的连通块，答案为 $0$，否则是 $2^m$，其中 $m$ 为连通块数量。  

现在的问题就是，我们如何构造图 $(*)$。如果我们暴力的建图，时间复杂度爆炸。我们考虑 $(x,fa
[x])$ 是否和 $(fa[x],fa[fa[x]])$ 用蓝色边连接，可以另写一个函数 $\operatorname{connect}(x)$，他返回一个节点已向 $x$ 子树中的节点连蓝色边的最小深度。这个函数值取决于它子节点的值和直接向 $x$ 连蓝色边的点的深度。后者可以直接用每个给定点对的 LCA 更新即可。  
时间复杂度 $O((m+n)\log n)$。  
核心代码如下：
```cpp
int connect(int x, int p) {
	for (auto it : E[x])
		if (it != p) {
			int tmp = connect(it, x);
			high[x] = min(high[x], tmp);
			if (tmp < depth[x])
				add_edge(it, x, 0);
		}
	return high[x];
}
int main(){
	 while (m--) {
        int a, b;
        scanf("%d%d", &a, &b);
        int c = lca(a, b);
        hi[a] = min(hi[a], depth[c]);
        hi[b] = min(hi[b], depth[c]);
        if (a != c && b != c)
            add_edge(a, b, 1);
    }
}
	
	connect(1, 0);
```


---

## 作者：mol_low (赞：0)

[题目传送门](https://www.luogu.org/problem/P4434)
# 分析
这道题关键的地方便是如何确定无解情况(如何为边定向)，显然我们不能用搜索解决问题。我们可以发现，一条边肯定在一条路径上，如果这条边出现在**多条不同的路径上**，而且这条边在不同路径上方向也不同的话显然就是无解了。分离路径我们可以用[强连通分量](https://www.luogu.org/blog/23j/you-xiang-tu-di-qiang-lian-tong-wen-ti)解决，不过既然已经有大佬讲了这种做法，那~~蒟蒻~~就来讲讲并查集做法吧。

我们在用强连通分量解决时，通过将一个强连通分量内的点同时打上$scc$的标记。这种做法很类似并查集，所以我们可以用并查集解决。我们为了表示双向路径，显然要用**虚点**的思想解决。对于每个$(x_i,y_i)$，我们可以分别将两种路径设置出来(从$y_i$到$x_i$或从$x_i$到$y_i$)。显然，树上路径要经过$lca$，我们需要求出$lca(x_i,y_i)$。但是，树上路径的所有边显然都需要进行并查集的更改，所以我们在更改时需要**暴力爬山**。

至于对于答案的贡献，我们可以发现：若有解，那么显然所有边反向也是一种。对于整个图，我们的并查集很有可能不是一棵，**而是森林**。而不同树进行边的反向是**互相不影响的**。因为对于每棵树对结果的贡献是$2$，而我们假设共有$sum$棵树，那么根据乘法原理：答案是$2^{sum}$。但是，由于我们建了虚点，所以$sum$棵树中包括了有虚点组成的树。而虚点与实点的数量相等，那么树的个数也应相等，所以答案为$2^{\frac{sum}{2}}$。

$Code:$
```
#pragma GCC optimize(2)
#include <bits/stdc++.h>
using namespace std;
#define N 300000
#define mod 1000000007
#define LL long long

int n , m;
vector<int> graph[N + 2];
int f[N + 2][21];
int father[2 * N + 4];
int deep[N + 2];
LL ans;
int x[N + 2] , y[N + 2] , lca[N + 2];

void makeset(int n) {
	for(int i = 1; i <= n; ++ i) father[i] = i;
}

int findset(int x) {
	if(x != father[x]) father[x] = findset(father[x]);
	return father[x];
}

void in(int &x) {
	x = 0;
	char c = getchar();
	bool f = 1;
	while(c < '0' or c > '9') {
		if(c == '-') f = 0;
		c = getchar();
	}
	while(c >= '0' and c <= '9') {
		x = (x << 1) + (x << 3) + c - '0';
		c = getchar(); 
	}
	if(!f) x = (~x) + 1;
}

void pre(int u , int father) {
	deep[u] = deep[father] + 1;
	f[u][0] = father;
	for(int i = 0; i <= 18; ++ i) f[u][i + 1] = f[f[u][i]][i];
	int son = graph[u].size();
	for(int i = 0; i < son; ++ i) {
		int v = graph[u][i];
		if(v == father) continue;
		pre(v , u);
	}
}

int ask(int x , int y) {
	if(deep[x] < deep[y]) swap(x , y);
	for(int i = 19; i >= 0; -- i) {
		if(deep[f[x][i]] >= deep[y]) x = f[x][i];
		if(x == y) return x;
	}
	for(int i = 19; i >= 0; -- i)
		if(f[x][i] != f[y][i]) {
			x = f[x][i];
			y = f[y][i];
		}
	return f[x][0];
}

void merge(int u , int lca) {
	while(deep[f[u][0]] > deep[lca]) {
		father[findset(u)] = findset(f[u][0]);
		father[findset(u + n)] = findset(f[u][0] + n);
		u = findset(f[u][0]);
	}
}

LL qkpow(LL x , int y) {
	LL ret = 1;
	while(y) {
		if(y & 1) ret = (ret * x) % mod;
		x = (x * x) % mod;
		y >>= 1;
	}
	return ret;
}

int main() {
	in(n) , in(m);
	int u , v;
	makeset(2 * n);
	for(int i = 1; i < n; ++ i) {
		in(u) , in(v);
		graph[u].push_back(v);
		graph[v].push_back(u);
	}
	pre(1 , 0);
	for(int i = 1; i <= m; ++ i) {
		in(x[i]);in(y[i]);
		lca[i] = ask(x[i] , y[i]);
		merge(x[i] , lca[i]);
		merge(y[i] , lca[i]);
		
	}
	for(int i = 1; i <= m; ++ i) 
		if(lca[i] != x[i] and lca[i] != y[i])
			father[findset(x[i] + n)] = findset(y[i]) , father[findset(y[i] + n)] = findset(x[i]);
	for(int i = 1; i <= n; ++ i) 
		if(findset(i) == findset(i + n)) {
			puts("0");
			return 0;
		}
	int sum = 0;
	for(int i = 1; i <= 2 * n; ++ i) {
		if(i % n == 1) continue;
		if(father[i] == i) sum ++;
	}
	ans = qkpow(1LL * 2 , sum / 2);
	printf("%lld\n", ans);
	return 0;
}
```

---


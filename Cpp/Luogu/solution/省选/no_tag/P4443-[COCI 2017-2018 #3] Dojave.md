# [COCI 2017/2018 #3] Dojave

## 题目描述

这一年最大的事件对于克罗地亚队来说以悲剧告终。CERC 有史以来最具影响力的理论家、热门页面 CERC Tips 的创始人，同时也是一位杰出的贝斯手，在他最近的一次表演中未能将他的团队带入决赛。

为了克服他的存在主义困扰，我们的主角正在通过玩几率游戏来消磨时间。他对以下游戏特别感兴趣：

给定一个正整数 M。我们的主角面前有一个数组 0, 1, 2, ..., $2^M$-1 的**排列**。

计算机选择给定排列中的一个**非空连续子序列**，然后将其点亮在东南欧某国的首都上空。

我们的知己，在摆脱旧时记忆带来的泪水后，**必须**选择排列中的两个不同元素并**交换它们的位置**。只有当替换后的点亮子序列的**按位异或**结果**恰好**为 $2^M$-1 时，我们的主角才会获胜。

我们的英雄想知道计算机可以点亮的**连续子序列的数量**，以便他能够获胜。

帮助我们的英雄克服他的身份危机，以便我们喜爱的页面能够再次全面活跃。

## 说明/提示

在占总分 50% 的测试用例中，1 ≤ M ≤ 14。

**测试用例的说明：**

在第一个测试用例中，如果计算机选择子序列 [1 2 3]，我们的英雄可以替换数字 0 和 3。在这种情况下，他实际上可以在每个选择的连续子序列中获胜，除了整个数组。

在第二个测试用例中，如果计算机选择整个数组 [3 7 0 4 6 1 5 2] 作为点亮的子序列，我们的英雄无论如何交换两个元素都无法改变子序列的异或结果（结果为 0）。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
2
0 1 2 3
```

### 输出

```
9```

## 样例 #2

### 输入

```
3
3 7 0 4 6 1 5 2
```

### 输出

```
33```

## 样例 #3

### 输入

```
4
13 0 15 12 4 8 7 3
11 14 6 10 1 5 9 2
```

### 输出

```
133```

# 题解

## 作者：Blueqwq (赞：14)

### P4443 [COCI2017-2018#3] Dojave 题解

[更好的阅读体验](https://www.cnblogs.com/blueqwq/p/15473324.html)

前言：

不知道为什么都用的哈希，我的优化暴力全都均摊了，直接最优解（

---

简要题意：

给定 $m$ 和 $0\sim 2^m-1$ 的全排列 $a_i$，问有多少子区间满足交换两个不同位置后，整个区间异或和为 $2^m-1$。

$m\le 20$。

---

分析：

正难则反，考虑求出不合法的区间个数。

以下记 $n=2^m-1$。

结论：

若区间内异或和为 $0$，并且可以两两配对使得两两异或和为 $n$，则这个区间不合法。

证明：

首先如果区间异或和已经为 $n$，那么只需要交换区间内或区间外的两个数即可。

否则，设区间 $S$ 的异或和为 $t$。

那么就是找一对 $i,j$ 使得 $i\oplus j=t\oplus n(i\in S,j\notin S)$，不难看出 $i,j$ 一定是成对出现的，那么若想要不合法，唯一的可能是集合内两两配对的异或和为 $t\oplus n$。

问题转化为找到这种情况。

奇数长度的一定合法，因为一定能找到一个数，和它配对的在区间外。

对于偶数长度的情况，如果配对数量为奇数，不妨以三个为例，有：
$$
(t\oplus n)\oplus (t\oplus n)\oplus (t\oplus n)=t\oplus n\ne t
$$
由于 $n\ne 0$，显然不存在这种情况。

配对数量为偶数的，不妨以两个为例，有：
$$
(t\oplus n)\oplus (t\oplus n)=0=\!\!\!\!?\ \ t
$$
也就是说，当 $t=0$ 时这个区间不合法，那么两两配对的异或和就是 $n$ 了。

至此证毕，下面考虑统计。

定义 $link_i$ 表示与 $a_i$ 配对的数的位置，即 $pos_{n\oplus a_i}$。

对于区间 $[l,p]$ 和 $[p+1,r]$，如果这两个区间都不合法，则 $[l,r]$ 也一定不合法，这点通过结论不难看出，那么我们只需要找对于每个点最近的不合法位置在哪里即可。

考虑一个最暴力的拓展方法，枚举一个左端点 $l$，那么右端点 $r$ 至少应在 $link_l$，下面判断这个区间是否合法。

- 如果 $\exists\,p\in[l,r],link_p<l$，即区间内存在一个数，与其配对的数在 $l$ 左边，那么直接跳出，因为我们钦定了 $l$ 为左端点。
- 如果 $\exists\,p\in[l,r],link_p>r$，那么更新 $r=link_p$，再重复这个过程，直到跳出或者 $\forall\, p\in[l,r],l\le link_p\le r$，即区间内两两配对。

这样的暴力做法可以找到每个最短的不合法区间，利用双指针可以在 $O(n^2)$ 的时间内求出，下面考虑优化。

注意到我们暴力跳右端点的时候，跳出或者更新答案的点都是区间 $link$ 最小值或最大值，那么就可以在 $O(mn)$ 的时间内预处理出 $link$ 的 ST 表实现 $O(1)$ 更新。

之后对于每个点暴力跳的复杂度就变成了均摊 $O(1)$ 的，简要证明如下：

对于每一对匹配 $(i,link_i)$，设 $i<link_i$，那么当左端点枚举到 $i$ 的时候看起来会很暴力的一直跳过去，极限状态下单次 $O(n)$，但当左端点枚举到 $link_i$ 的时候，右端点 $i<link_i$ 会直接跳出，所以实际上每一对匹配只会跳一次，均摊 $O(1)$。

统计同理，暴力枚举左端点，暴力跳最近的不合法区间，由于我们要计算的区间长度必须为 $4$ 的倍数，那么只需要统计一路上 $\bmod 4$ 同余的个数即可，为了防止算重，对于每个跳到的点标记一下，如果枚举到了标记点直接跳过即可，每个点的时间复杂度同样是均摊 $O(1)$。

总时间复杂度为 $O(mn+n+n)=O(mn)=O(m\times 2^m)$。

此外注意特判 $m=1$ 的情况，因为 $0$ 和 $1$ 一定交换，所以单独一个 $1$ 是不合法的，最终答案应该为 $2$。

代码如下：

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=1050000;
//此处为快读快写
int n,m;
ll ans;
int a[N],pos[N],link[N],nxt[N];
int md[5],stn[21][N],stx[21][N],pw[N];
bool vis[N];
//ST 表
void init(){
	for(int i=2;i<=n;i++)
		pw[i]=pw[i>>1]+1;
	for(int i=1;i<=n;i++)
		stn[0][i]=stx[0][i]=link[i];
	for(int i=1;i<=m-1;i++)
		for(int j=1;j+(1<<i)-1<=n;j++)
			stn[i][j]=min(stn[i-1][j],stn[i-1][j+(1<<(i-1))]),
			stx[i][j]=max(stx[i-1][j],stx[i-1][j+(1<<(i-1))]);
}
int querymin(int l,int r){
	int k=pw[r-l];
	return min(stn[k][l],stn[k][r-(1<<k)+1]);
}
int querymax(int l,int r){
	int k=pw[r-l];
	return max(stx[k][l],stx[k][r-(1<<k)+1]);
}
signed main(){
	m=read();n=(1<<m);
	if(m==1) return puts("2"),0;
	ans=1ll*n*(n+1)/2;
	for(int i=1;i<=n;i++)
		a[i]=read(),pos[a[i]]=i;
	for(int i=1;i<=n;i++)
		link[i]=pos[n-a[i]-1];
	init();
	for(int i=1;i<=n;i++){
		int l=i,r=link[i];
		Find:;
		if(querymin(l,r)<i) continue;//左端点小于钦定的 l，就跳出。
		int mx=querymax(l,r);
		if(mx>r){r=mx;goto Find;}//有更远的右端点，重复这个过程。
		nxt[i]=r;//记 nxt 表示最近的不合法右端点。
	}
	for(int i=1;i<=n;i++){
		if(vis[i]||!nxt[i]) continue;//标记过这个点或区间不存在就跳过。
		for(int j=0;j<=3;j++)
			md[j]=0;
		int nw=i;md[i&3]++;
		//暴力跳 nxt 并统计。
		while(nxt[nw]){
			nw=nxt[nw]+1;
			ans-=md[nw&3];
			md[nw&3]++;
			vis[nw]=true;
		}
	}
	write(ans);
	return 0;
}
```

---

## 作者：decoqwq (赞：6)

令$sum[x]$表示数列$a$的前$x$数的异或前缀和

题目要求有多少个区间$[l,r]$满足存在两个数$A,B$使得$sum[r]\oplus sum[l-1]\oplus a[A]\oplus a[B]=2^m -1$

当$A,B$均在$[l,r]$间或均不在时，显然只需统计$sum[r]\oplus sum[l]=2^m -1$的个数，然后发现一个在中间一个不在时的答案不好统计，正难则反，我们考虑不符合条件的区间个数

当区间长度是奇数是，我们令$S=sum[r]\oplus sum[l-1],t=(2^m-1)\oplus S$
，我们相当于找到一对$a[A]\oplus a[B]=t$，因为这样配对的数都是两两出现，所以必定会有一个未配对的数在区间内，所以这种情况必定满足

当长度为偶数时，若有数字为配对，则答案显然

当所有数字都配对后，我们考虑，若一共有$k$对数，当$k$是奇数时，则$S=t\oplus t\oplus t$，即$S=t$，此时$S\oplus t$显然为$0$，故无此种情况

当有偶数对时，不满足条件，我们统计答案即可，即$t=2^m -1$，要统计长度为$4$的倍数且全部配对的区间个数，可以联想到一道类似的题目
```cpp
给定长度1e7的序列和1e7次查询，每次查询一个区间是不是所有数都出现了偶数次
```
这种题目可以想到异或，但是有时候几个数异或在一次也是$0$，所以我们考虑给每个数重新赋值为一个巨大的随机数，然后将它和与它配对的人都赋值为此，即可哈希统计答案
```cpp
/*deco loves Chino*/
#include<bits/stdc++.h>
using namespace std;
#define maxn 1200010
int m,maxm;
int id[maxn],a[maxn],t[maxn][2];
map<pair<int,int>,int> mans[4];
int main()
{
      cin>>m;
      if(m==1)
      {
          cout<<2;
          return 0;
      }
      maxm=1<<m;
      long long ans=(long long)(1+maxm)*maxm/2;
      for(int i=1;i<=maxm;i++) 
      {
          scanf("%d",&a[i]);
          id[a[i]]=i;
      }
      for(int i=0;i<maxm/2;i++) 
      {
          t[id[i]][0]=(rand()|rand()<<15);
          t[id[i]][1]=(rand()|rand()<<15);
          t[id[(maxm-1)^i]][0]=t[id[i]][0];
          t[id[(maxm-1)^i]][1]=t[id[i]][1];
      }
      for(int i=1;i<=maxm;i++) 
      {
          t[i][0]^=t[i-1][0];
          t[i][1]^=t[i-1][1];
      }
      for(int i=0;i<=maxm;i++) 
      {
          pair<int,int> qwq=make_pair(t[i][0],t[i][1]);
          ans-=mans[i%4][qwq];
          mans[i%4][qwq]++; 
      }
      cout<<ans;
      return 0;
}
```

---

## 作者：「QQ红包」 (赞：5)


设

$sum_{l,r}=a_l \text{ xor } a_{l+1} \text{ xor }...\text{ xor } a_r$

设满足条件 $sum_{l,r}\text{ xor } (2^m-1)=x \text{ xor }y$
的一对数($x,y$)称为一组配对。

$x_i \text{ xor }y_i \text{ xor } (2^m-1)=sum_{l,r}$

如果存在$x$在区间里面，$y$在区间外面，则是合法的，所以长度为奇数的肯定是合法的。

如果是偶数对配对，$\sum x_i \text{ xor }y_i =sum_{l,r}$

可能全部配对在区间里面。

如果是奇数对。

$x_i \text{ xor }y_i \text{ xor } (2^m-1)=sum_{l,r}$

如果所有的配对在区间里面的话。

$sum_{l,r}=sum_{l,r}\text{ xor }(2^m-1)$，矛盾。

所以奇数对一定都合法。

---

所以我们只剩下了一种情况。就是偶数个配对，且都在区间内部的是不合法的。

$x_i \text{ xor }y_i \text{ xor } (2^m-1)=sum_{l,r}$

$x_i \text{ xor } (2^m-1) \text{ xor }sum_{l,r}=y_i $

对于每一个数，有一个匹配的位置。

这个线段树就可以维护了。

---

考虑下怎么维护，设$b_i$表示和$i$配对的位置。

先把所有的$b_i>i$的位置标为合法的。

扫描线从左往右，

用一个单调栈维护最靠右的，且匹配位置$>r$的位置。

如果$b_i>i$，则加入单调栈。

否则，$b_i+1$到$i$这些位置标记一下，这些位置全都不能再作为合法的左端点。

如何满足区间长度为4的倍数？

开4个线段树分别维护模4为0,1,2,3的位置的和。

注意：

```
1
0 1
```

答案为2

因为如果选中区间[1]，因为交换的位置不同，交换后会是[0]，所以是不合法的。

代码：
```cpp
/*
 * Author: ylx
 * Lang: c++
 * Prog: p4443
 */
#include<bits/stdc++.h>
#define ll long long
using namespace std;
void qmax(int &x,int y) {if (x<y) x=y;}
void qmin(int &x,int y) {if (x>y) x=y;}
inline ll read()
{
	char s;
	ll k=0,base=1;
	while((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));
	if(s==EOF)exit(0);
	if(s=='-')base=-1,s=getchar();
	while(isdigit(s)){k=k*10+(s^'0');s=getchar();}
	return k*base;
}
inline void write(int x)
{
	static char cnt,num[15];cnt=0;
	if (!x)
	{
		printf("0");
		return;
	}
	for (;x;x/=10) num[++cnt]=x%10;
	for (;cnt;putchar(num[cnt--]+48));
}
#define pr pair<int,int>
#define fi first
#define se second
#define mp make_pair
const int maxn=(1<<20)+10;
int m,n;
int a[maxn],b[maxn];
int Map[maxn],top;
pr sta[maxn];
int t[4][maxn<<2];
int tag[maxn<<2];
void pushup(int d)
{
	for (int i=0;i<=3;i++) t[i][d]=t[i][d<<1]+t[i][d<<1|1];
}
void pushdown(int d)
{
	if (!tag[d]) return;
	if (tag[d]==2) return;
	qmax(tag[d<<1],1);
	qmax(tag[d<<1|1],1);
	for (int i=0;i<=3;i++) 
	{
		t[i][d<<1]=0;
		t[i][d<<1|1]=0;
	}
	tag[d]=2;
}
void bt(int x,int y,int d)
{
	if (x==y)
	{
		t[x&3][d]=b[x]>x?1:0;
		return;
	}
	int mid=(x+y)>>1;
	bt(x,mid,d<<1);
	bt(mid+1,y,d<<1|1);
	pushup(d);
}
void xg(int x,int y,int d,int l,int r)
{
	if (tag[d]==2) return;
	if (l<=x&&y<=r)
	{
		for (int i=0;i<=3;i++) t[i][d]=0;
		qmax(tag[d],1);
		return;
	}
	pushdown(d);
	int mid=(x+y)>>1;
	if (l<=mid) xg(x,mid,d<<1,l,r);
	if (r>mid) xg(mid+1,y,d<<1|1,l,r);
	pushup(d);
}
int query(int x,int y,int d,int l,int r,int z)
{
	if (tag[d]==2) return 0;
	if (l<=x&&y<=r) return t[z][d];
	pushdown(d);
	int mid=(x+y)>>1,sum=0;
	if (l<=mid) sum+=query(x,mid,d<<1,l,r,z);
	if (r>mid) sum+=query(mid+1,y,d<<1|1,l,r,z);
	return sum;
}
ll ans=0;
int main()
{
#ifdef ylx
	freopen("p4443.in","r",stdin);
	freopen("p4443.out","w",stdout);
#endif
	m=read();
	if (m==1)
	{
		printf("%d\n",2);
		return 0;
	}
	n=1<<m;
	for (int i=1;i<=n;i++) a[i]=read(),Map[a[i]]=i;
	for (int i=1;i<=n;i++) b[i]=Map[a[i]^(n-1)];
	bt(1,n,1);
	for (int i=1;i<=n;i++)
	{
		if (b[i]>i)
		{
			top++;
			sta[top]=mp(i,b[i]);
		} else
		{
			xg(1,n,1,b[i]+1,i);
			while (top>=1&&sta[top].se<=i) top--;
			ans+=query(1,n,1,sta[top].fi+1,i,(i+1)&3);
		}
	}
	ans=(ll)n*(n+1)/2-ans;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：qzhwlzy (赞：2)

### 题目大意

有一个 $0\sim 2^n-1$ 的排列 $a$，定义它的一个子串 $a_l,a_{l+1},\ldots,a_r$ 是好的，当且仅当在**恰好**交换**一对** $a$ 中的两个元素后能使 $\bigoplus\limits_{i=l}^r a_i = 2^n-1$（$\oplus$ 表示异或运算）。求出 $a$ 有多少子串是好的。

### 思路

对于子串 $a_l,a_{l+1},\ldots,a_r$，设其异或和为 $s = \bigoplus\limits_{i=l}^r a_i$。假设这个子串是好的，当且仅当存在 $x\in[l,r],y\notin[l,r]$，使得 $s\oplus a_x\oplus a_y = 2^n-1$。

发现不太好算，于是考虑**正难则反**。因为子串一共有 $\dfrac{2^n(2^n+1)}{2}$ 个，若我们能统计出不好的子串有多少个，减一下就能得到答案。

下面考虑如何统计不好的子串。根据上面的充要条件，不好的子串应满足以下条件：$\forall x\in[l,r]$，满足 $s\oplus a_x\oplus a_y = 2^n-1$ 的 $y$ 一定在区间 $[l,r]$ 内。因为 $s\oplus a_x$ 一定小于 $2^n-1$，且 $y$ 不在区间 $[l,r]$ 外，则其一定在区间内。

于是，不好的子串一定由若干对满足 $a_x\oplus a_y= s\oplus (2^n-1)$ 的 $x,y$ 构成。我们分类讨论：

- 假设 $s = 2^n - 1$，则有 $a_x = a_y$，那么这个子串本身满足异或和等于 $2^n-1$，我们交换其中任意两个元素即可。所以这个子串是好的，我们不统计；

- 则 $s\neq 2^n - 1$，则子串的长度 $r-l+1$ 一定是偶数（由若干对 $a_x,a_y$ 构成）。继续讨论：
  
- 若区间长度 $r-l+1$ 不是 $4$ 的倍数，则有 $s$ 为奇数对 $a_x,a_y$ 的异或和，即 $s = \bigoplus\limits[s\oplus (2^n-1)] = s\oplus (2^n-1)$，则 $2^n - 1 = 0$，舍去；
  
- 于是区间长度 $r-l+1$ 一定是 $4$ 的倍数，同上，$s$ 是偶数对 $a_x,a_y$ 的异或和，即 $s = \bigoplus\limits[s\oplus (2^n-1)] = 0$。

综上，$a_l,a_{l+1},\ldots,a_r$ 的长度一定是 $4$ 的倍数，且其中有偶数对 $a_x,a_y$（$a_x\oplus a_y = 2^n-1$）。于是，我们就是要统计有多少个长度为 $4$ 的倍数的区间中恰好能分成若干组异或和是 $2^n-1$ 的数对。

要统计这样的子串数量，我们不妨对于所有的 $a_x$，把它和对应的 $a_y$ 赋一个相同的权值，然后计算权值的前缀异或和 $pre$，假设一个子串 $a_l,a_{l+1},\ldots,a_r$ 满足 $pre_{l-1} = pre_r$，则这个子串能被分成若干对 $a_x,a_y$。于是我们对下标模 $4$ 的值分开统计即可。为了避免可能的权值间的影响，权值可以采用随机数。

值得注意的是 $n=1$ 时，没有长度为 $4$ 的倍数的子串，此时 $a=[0,1]$ 或 $a=[1,0]$，答案都是 $2$，特判即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<map>
#define maxn 1050005
#define ll long long
#define int long long
using namespace std;
int n,a[maxn],rev[maxn]; ll res,sum,ans=0LL,pre[maxn]; map<ll,int> f[5];
signed main(){
	srand(time(0)); scanf("%lld",&n); n=(1<<n); for(int i=1;i<=n;i++) scanf("%lld",&a[i]),rev[a[i]]=i;
	sum=1LL*(n+1)*n/2; if(n==2){printf("%lld",sum-1); return 0;} // 计算总子串个数并特判
	for(int i=1;i<=n;i++) if(!pre[i]) pre[i]=res=1LL*rand()*rand(),pre[rev[(n-1)^a[i]]]=res; // 赋随机权值
	for(int i=1;i<=n;i++) pre[i]^=pre[i-1]; f[0][0]=1; // f[i][j] 统计下标 %4 为 i 的位置的前缀异或和为 i 的个数
	for(int i=1;i<=n;i++){if(f[i%4][pre[i]]) ans+=f[i%4][pre[i]]; f[i%4][pre[i]]++;}
	printf("%lld",sum-ans);
	return 0;
}
```

---

## 作者：fzj2007 (赞：1)

题目简化版：

> 给定 $m$ 和 $0\sim 2^m-1$ 的排列 $p$，请你求出有多少个子序列可以通过交换序列中的两个数使得它的异或和为 $0$。

首先设 $n=2^m$，$pre$ 表示 $p$ 的前缀异或和。

有一个比较显然的暴力，枚举子序列的端点 $l,r$ 以及交换数的位置 $a,b$。若满足条件（可以分类讨论）则答案累加 $1$。

时间复杂度 $\mathcal{O}(n^4)$，显然超时。

考虑优化上面的暴力。

由于每个数只会出现一次，可以记录下来每个数出现的位置。

考虑到如果交换数 $a,b$ 都在区间的外部或内部，则对当前区间没有任何影响。

考虑枚举在区间内部的位置 $a$，查询能够使得整个区间满足条件的 $b=pre_{l-1}\oplus pre_r\oplus (2^m-1)\oplus p_a$ 是否在区间外部。只要有一个 $a$ 使得原序列合法则累加答案。

最后统计一下原序列的异或和是 $2^m-1$ 的区间个数即可。

时间复杂度 $\mathcal{O}(n^3)$，依然无法通过。

考虑**正难则反**。

由于区间总数为 $\frac{n\times (n+1)}{2}$，如果可以快速统计不合法的区间个数就可以得到合法的区间个数。

寻找不合法的区间的性质。

设当前区间的异或和为 $now$，那么需要找到一个 $p_a,p_b$ 的异或和为 $ned=now\oplus (2^m-1)$。

又因为给定的是一个 $0\sim (2^m-1)$ 的排列，所以上面的 $p_a,p_b$ 是成对出现的。

1. 区间长度为奇数时一定合法，因为一定有一个位置不配对。

2. 区间长度为偶数且配对数量为奇数 $k$，那么最后会形成 $k$ 个 $ned$ 异或起来。又因为 $ned \oplus ned=0$，所以最后的结果为 $ned$，即 $ned\oplus ned=0\not=2^m-1$，一定合法。

3. 当区间长度为偶数且配对个数为偶数时，最终的结果为 $now=0$，不合法。

容易得到区间不合法当且仅当长度为 $4$ 的倍数并且两两配对。

可以使用哈希解决。

具体过程如下：

给这个数和与这个数配对的数赋一个较大的数。

枚举每个数，查看之前与当前模 $4$ 相同的位置出现了多少次这个数（加上这个数异或和为 $0$），累加这个位置这个数的出现次数。

需要使用双哈希。

```
#include<bits/stdc++.h>
using namespace std;
namespace IO{
    template<typename T>inline void read(T &x){
        x=0;
        char ch=getchar();
        bool flag=0;
        while(ch<'0'||ch>'9') flag=flag||(ch=='-'),ch=getchar();
        while(ch>='0'&&ch<='9') x=x*10+(ch^'0'),ch=getchar();
        if(ch!='.'){
            x=flag?-x:x;
            return;
        }
        double Base=0.1;
        while(ch<'0'||ch>'9') ch=getchar();
        while(ch>='0'&&ch<='9') x=x+Base*(ch^'0'),Base/=10.0,ch=getchar();
        x=flag?-x:x;
    }
    template<typename T>void prt(T x){
        if(x>9) prt(x/10);
        putchar(x%10+'0');
    }
    template<typename T>inline void put(char ch,T x){
        if(x<0) putchar('-'),x=-x;
        prt(x);
        putchar(ch);
    }
    const int DM[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
    inline void putd(char ch,double x,int w){
        if(x<0) putchar('-'),x=-x;
        if(!w){
            put(ch,(int)(x+0.5));
            return;
        }
        int prex=(int)x;
        x-=(int)x;
        x*=DM[w];
        x+=0.5;
        int nowx=(int)x,now=0;
        if(nowx>=DM[w]) nowx=0,prex++;
        put('.',prex);
        int xx=nowx;
        if(!xx) now=1;
        else while(xx) xx/=10,now++;
        now=w-now;
        while(now--) putchar('0');
        put(ch,nowx);
    }
    inline void putstr(string s){
        for(int i=0;i<s.length();i++) putchar(s[i]);
    }
}
using namespace IO;
#define N 3000005
int m,MAXN,a[N],pos[N],val[N][2];
long long ans;
unsigned long long sed=19260817;
map<pair<int,int>,int> hsh[4];
inline int rd(int l,int r){
	unsigned long long x=rand()*rand(),y=rand()*rand(),z=rand()*rand();
	sed=sed^x|((y<<11)^z);
	sed>>=3;
	x<<=(y^z);
	x^=190364831;
	y&=347884933;
	z|=4789321;
	sed^=x^y^z;
	return abs((int)sed)%(r-l+1)+l;
}
int main(){
	read(m); 
	if(m==1) return put('\n',2),0;
	m=(1<<m);
	MAXN=m-1;
	ans=(long long)m*(m+1)/2;
	for(int i=1;i<=m;i++) read(a[i]),pos[a[i]]=i;
	for(int i=0;i<m/2;i++){
		val[pos[i]][0]=val[pos[i^MAXN]][0]=rd(1,1000000000);
		val[pos[i]][1]=val[pos[i^MAXN]][1]=rd(1,1000000000);
	}
	for(int i=1;i<=m;i++) val[i][0]^=val[i-1][0],val[i][1]^=val[i-1][1];
	for(int i=0;i<=m;i++){
		pair<int,int> now=make_pair(val[i][0],val[i][1]);
		ans-=hsh[i&3][now];
		hsh[i&3][now]++;
	}
	put('\n',ans);
	return 0;
}



---


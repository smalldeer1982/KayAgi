# [国家集训队] 和与积

## 题目描述

给出 $n$，统计满足下面条件的数对 $(a,b)$ 的个数：

1. $1\le a<b \le n$。
2. $a+b$ 整除 $a\times b$。

## 说明/提示

| Test | $N$ | Test | $N$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 10$ | $11$ | $\leq 5\times 10^7$ |
| $2$ | $\leq 50$ | $12$ | $\leq 10^8$ |
| $3$ | $\leq 10^3$ | $13$ | $\leq 2\times 10^8$ |
| $4$ | $\leq 5\times 10^3$ | $14$ | $\leq 3\times 10^8$ |
| $5$ | $\leq 2\times 10^4$ | $15$ | $\leq 5\times 10^8$ |
| $6$ | $\leq 2\times 10^5$ | $16$ | $\leq 10^9$ |
| $7$ | $\leq 2\times 10^6$ | $17$ | $\leq 10^9$ |
| $8$ | $\leq 10^7$ | $18$ | $\leq 2^{31}-1$ |
| $9$ | $\leq 2\times 10^7$ | $19$ | $\leq 2^{31}-1$ |
| $10$ | $\leq 3\times 10^7$ | $20$ | $\leq 2^{31}-1$ |

来源：2012集训队互测，by ayq

## 样例 #1

### 输入

```
15```

### 输出

```
4```

# 题解

## 作者：Delta_Cosh (赞：17)

$As\ we\ know\ that:$

$(a+b)|ab;$

$So\ it\ is\ easy\ to\ think\ of\ it:$

$d=gcd(a,b);$

$Assume:$

$a=xd,b=yd;$

$Then\ there\ goes:$

$\frac{xyd}{x+y}\ is\ a\ integer;$

$Obviously\ there\ is$

$gcd(x,y)=1;$

$∴gcd(x,x+y)=1,gcd(y,x+y)=1,gcd(xy,x+y)=1;$

$∴(x+y)|d;$

$From\ the\ condition.1\ we\ know$

$$\left\{\begin{aligned}xd\leqslant{N}\\ yd\leqslant{N} \\ x+y\leqslant{d}\end{aligned}\right.;$$

$And\ there\ is$

$d\leqslant{\lfloor{\frac{N}{y}}\rfloor};$

$So\ the\ answer\ equals$

$ans=\sum_{x=1}^{\sqrt{N}}\sum_{y=x+1}^{\sqrt{N}}\lfloor{\frac{\lfloor{\frac{N}{y}}\rfloor}{x+y}}\rfloor\ [gcd(x,y)=1];$

$Use\ Möbius\ inversion\ formula\ and\ make:$

$xd=x,yd=y;$

$∴ans=\sum_{d=1}^{\sqrt{N}}\mu(d)\sum_{x=1}^{\frac{\sqrt{N}}{d}}\sum_{y=x+1}^{\frac{\sqrt{N}}{d}}\lfloor{\frac{\lfloor{\frac{N}{yd^2}}\rfloor}{x+y}}\rfloor ;$

$s=x+y;$

$∴ans=\sum_{d=1}^{\sqrt{N}}\mu(d)\sum_{y=2}^{\frac{\sqrt{N}}{d}}\sum_{s=y+1}^{2y-1}\lfloor{\frac{\lfloor{\frac{N}{yd^2}}\rfloor}{s}}\rfloor ;$

$By\ the\ identity\ we\ know\ the\ answer.$

------------
代码就不给了已经讲的很清楚了。

---

## 作者：星小雨 (赞：14)

前置知识：莫比乌斯反演

算是一道相对基础的反演题了吧。。

求有多少组$a,b$，满足$1 \le a<b \le n$且$(a+b)|ab$

由于$n \le 10^9 $，反演看起来势在必行

首先是一个很显然的结论：若$(a,b)=1$，则$(a+b) \nmid ab$

为什么呢？因为此时$(a+b,a)=(a+b,b)=1$

所以$(a,b) \ne 1$

所以我们可以设$d=(a,b),a=di,b=dj$，则$(i+j)|ijd$

因为$(i,j)=1$，由上述推论可得$(i+j) \nmid ij$

所以这道题也就是求$(i+j)|d$，$(i,j)=1$且$id,jd \le n$的$(i,j,d)$的数目。

推推式子吧：

$ ans =\sum _{i=1}^n \sum _{j=1}^{i-1} \lfloor \frac {\lfloor \frac{n}{i} \rfloor }{i+j} \rfloor [(i,j) = 1] $
$=\sum_{i=1}^{n}\sum_{j=1}^{i-1} \lfloor \frac {n}{i(i+j) } \rfloor [(i,j)=1]$

$i$最多取到$\sqrt n$，不然后面的$\lfloor \frac {n}{i(i+j) } \rfloor$就等于0了，所以

$ ans=\sum_{i=1}^{\sqrt n}\sum_{j=1}^{i-1} \lfloor \frac {n}{i(i+j) } \rfloor [(i,j)=1]$

套一个莫比乌斯函数的基本操作$[x=1] = \sum_{d|x} \mu (d)$，得：

$ ans= \sum_{i=1}^{\sqrt n}\sum_{j=1}^{i-1} \lfloor \frac {n}{i(i+j) } \rfloor \sum_{k|(i,j)} \mu(k) $

设$i=xk,j=yk$，则：

$ ans = \sum_{k=1}^{\sqrt n} \mu(k) \sum_{x=1}^{\lfloor \frac{\sqrt{n}}{k} \rfloor} \sum_{y=1}^{x-1} \lfloor \frac {n}{xk(xk+yk) } \rfloor $
$ =\sum_{k=1}^{\sqrt n} \mu(k) \sum_{x=1}^{\lfloor \frac{\sqrt{n}}{k} \rfloor} \sum_{y=1}^{x-1} \lfloor \frac {\lfloor \frac{n}{xk^2} \rfloor }{x+y} \rfloor$

枚举了$k,x$之后，$\frac{n}{xk^2}$是固定值，而它除以$x+y$显然可以使用数论分块。

代码如下：

```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
typedef long long ll;
const int N=1e5+5;
bool b[N];
int p[N],u[N];
ll calc(int x,int y){
    ll a=0;int z=x<<1;
    if(!y) return 0;
    for(int i=x+1;i<z;i=x+1){
        if(!(y/i)) return a;
        x=std::min(y/(y/i),z-1);
        a+=(x-i+1)*(y/i);
    }
    return a;
}
int main(){
    int t=0,n,m,x;ll a=0;
    scanf("%d",&n);
    m=sqrt(n);
    u[1]=1;
    for(int i=2;i<=m;++i){
        if(!b[i]) p[++t]=i,u[i]=-1;
        for(int j=1;j<=t && (x=i*p[j])<=m;++j){
            b[x]=1,u[x]=-u[i];
            if(!(i%p[j])){u[x]=0;break;}
        }
    }
    for(int i=1;i<=m;++i){
        if(!u[i]) continue;
        for(int j=1;j*i<=m;++j)
            a+=u[i]*calc(j,n/(i*i*j));
    }
    printf("%lld\n",a);
    return 0;
}
```

时间复杂度我感觉是最多 $ O( n^{\frac{3}{4}} \text{ln} \sqrt n) $的吧。。

不过洛咕上有大神证出了是 $O( \sqrt n \text log n)$的？问号问号。。

---

## 作者：zhylj (赞：11)

一个不太一样的思路？

先忽略 $a\lt b$ 的条件。

注意到 $(a+b)\mid ab$ 等价于 $ab\equiv 0\pmod {(a+b)}$，而又有 $b\equiv -a\pmod {(a+b)}$，所以 $-a^2\equiv 0\pmod {(a+b)}$，即相当于 $(a+b)\mid a^2$。

枚举 $a$，即相当于要求 $a^2$ 的所有因子中，在 $[a+1,n+a]$ 范围的个数的和。

注意到一个数 $x=\prod p_i^{\alpha_i}$，某个平方数 $a^2=\prod \left(p_i^{\beta_i}\right)^2$  被它整除当且仅当 $\forall i,\alpha_i\le 2\beta_i\implies \beta_i\ge \left\lceil\dfrac {\alpha_i}2\right\rceil$。

考虑一个数 $x=i^2j$，其中 $j$ 为不含平方因子的数，那么我们有 $i^2j\mid a^2\implies ij\mid a$。

枚举 $i\le \sqrt n$，那么在 $i,\left\lfloor\dfrac n{ij}\right\rfloor$ 都相同时，$j$ 取值个数必然相同（由于其个数形如一个区间内 $ij$ 倍数的个数）。 

枚举 $i$ 后，对 $\left\lfloor\dfrac ni\right\rfloor$ 进行整除分块来枚举 $j$，那么我们要做的就是枚举区间无平方因子的数的个数，这是一个经典的容斥问题，我们可以通过对平方因子进行容斥得到：
$$
S(n)=\sum_{i=1}^n \mu^2(i) = \sum_{i=1}^{\left\lfloor\sqrt n\right\rfloor}\mu(i)\left\lfloor\frac n{i^2}\right\rfloor
$$
再注意到我们需要计算的所有 $S$ 都是某个 $\left\lfloor\dfrac {n}{A}\right\rfloor$，所以只有 $\mathcal O(\sqrt n)$ 个，可以记忆化。

最后的时间复杂度为：
$$
\mathcal O\left(\sum_{i=1}^{\left\lfloor\sqrt n\right\rfloor}\left\lfloor\sqrt i\right\rfloor\right)=\mathcal O(n^{0.75})
$$

---

## 作者：qwaszx (赞：9)

orz果然我反演还是幼儿园水平

让我们感受艾弗森记号的优越⑧!

$\sum\limits_{i,j}[1\leq i<j\leq n][(i+j)\mid ij]$

$=\sum\limits_{i,j,s,t,d}[1\leq i<j\leq n][d=\gcd(i,j)][i=sd][j=td][(i+j)\mid ij]$

$=\sum\limits_{s,t,d}[1\leq sd<td\leq n][\gcd(s,t)=1][(s+t)d\mid std^2]$

这里有必要处理一下最后面那个式子.首先我们知道它等价于$[(s+t)\mid std]$，然而事实上它还等价于$(s+t)\mid d$.

因为$\gcd(s,t)=1$，所以$\gcd(s,s+t)=1,\gcd(s+t,t)=1$，所以$\gcd(s+t,st)=1$，于是可以化成$[(s+t)\mid d]$.继续化.

$=\sum\limits_{s,t,d}[1\leq sd<td\leq n][\gcd(s,t)=1][(s+t)|d]$

$=\sum\limits_{s,t,d,k}[d=k(s+t)][k\geq 1][\gcd(s,t)=1][1\leq sd<td\leq n]$

$=\sum\limits_{s,t,k}[k\geq 1][\gcd(s,t)=1][1\leq ks(s+t)<kt(s+t)\leq n]$

$=\sum\limits_{s,t,k}[k\in[1,\dfrac{n}{t(s+t)}]][s<t][\gcd(s,t)=1]$

$=\sum\limits_{s,t}\left\lfloor\dfrac{n}{t(s+t)}\right\rfloor[\gcd(s,t)=1][s<t]$

$=\sum\limits_{s,t,k}\left\lfloor\dfrac{n}{t(s+t)}\right\rfloor[k\mid s][k\mid t][s<t]\mu(k)$

$=\sum\limits_{s,t,k}\left\lfloor\dfrac{n}{k^2t(s+t)}\right\rfloor[1\leq s<t]\mu(k)$

注意到$t>\sqrt{n}$或$k>\sqrt{n}$时$\left\lfloor\dfrac{n}{k^2t(s+t)}\right\rfloor=0$，所以我们直接给它一个简单的上界并写成常见的形式

$=\sum\limits_{k=1}^{\sqrt{n}}\mu(k)\sum\limits_{t=2}^{\sqrt{n}}\sum\limits_{s=1}^{t-1}\left\lfloor\dfrac{n}{k^2t(s+t)}\right\rfloor$

$=\sum\limits_{k=1}^{\sqrt{n}}\mu(k)\sum\limits_{t=2}^{\frac{\sqrt{n}}{k}}\sum\limits_{s=t+1}^{2t-1}\left\lfloor\dfrac{n}{k^2st}\right\rfloor$

$=\sum\limits_{k=1}^{\sqrt{n}}\mu(k)\sum\limits_{t=2}^\frac{\sqrt{n}}{k}\sum\limits_{s=t+1}^{2t-1}\left\lfloor\dfrac{\left\lfloor\frac{n}{k^2t}\right\rfloor}{s}\right\rfloor$

这个式子...数论分块直接做...我也不知道复杂度具体是多少，只能口胡一波:

设$S(n,t)=\sum\limits_{i=2}^n\sum\limits_{j=i+1}^{2i-1}\left\lfloor\frac{t}{is}\right\rfloor$.

这东西暴力算的话是$\sum\limits_{i=2}^nO(\sqrt{\frac{t}{i}})=O(\sqrt{nt})$

原式$=\sum\limits_{k=1}^{\sqrt{n}}\mu(k)S(\left\lfloor\frac{\sqrt{n}}{k}\right\rfloor,\left\lfloor\frac{n}{k^2}\right\rfloor)$的复杂度可以简单算成

$\sum\limits_{k=1}^{\sqrt{n}}O(n^\frac{3}{4}k^{-\frac{3}{2}})=O(n^\frac{3}{4})$

当然这太毒瘤了以至于我自己都不相信(((

$rqy$说可以做到$O(n^\frac{2}{3})$反正我不会$QAQ$

多组询问的话...太毒瘤了做不来$QAQAQ$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int N=5e5;
int mu[N],p[N],prime[N],n,sqt[N],cnt;
void make(int n)
{
    p[1]=mu[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])prime[++cnt]=i,mu[i]=-1;
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
        {
            int x=i*prime[j];p[x]=1;
            if(i%prime[j])mu[x]=-mu[i];
            else break;
        }
    }
    for(int i=2;i<=n;i++)mu[i]+=mu[i-1];
}
long long S(int l,int r,int n)
{
    r=min(n,r);long long ans=0;
    for(int i=l,lt;i<=r;i=lt+1)
    {
        lt=min(r,n/(n/i));
        ans+=1ll*(n/i)*(lt-i+1);
    }
    return ans;
}
long long calc(int n,int t)
{
    long long ans=0;
    for(int i=1;i<=n;i++)
    {
        ans+=S(i+1,2*i-1,t/i);
    }
    return ans;
}
int main()
{
    scanf("%d",&n);
    int sqn=sqrt(n);
    make(sqn);long long ans=0;
    for(int i=1;i<=sqn;i++)sqt[i]=sqrt(n/(n/(i*i)));
    for(int i=1,lt;i<=sqn;i=lt+1)
    {
        int f1=sqn/i,f2=n/(i*i);
        lt=min(sqn/f1,sqt[i]);
        ans+=(mu[lt]-mu[i-1])*calc(f1,f2);
    }
    printf("%lld\n",ans);
}
```

---

## 作者：tegethim (赞：8)


~~**大事祭，一不知名蒟蒻看了半年的莫比乌斯反演，终于，他（有可能）学会了。**~~

## 嘛是莫比乌斯反演？
对于一个函数 $ F(x)$，其内部是根据 $f(x)$ 定义的，而现在我们会知道部分 $F(x)$ 的值，希望求出 $f(x)$ 的值，**首先，这个东西他不是莫比乌斯反演，只是反演的形式化**，而在莫比乌斯反演之前，我们需要知道一种关系，叫做偏序关系。
### 1. 偏序关系
**首先，对于任意两个元素，他们之间满足偏序关系，当且仅当一个小/弱/包含于另一个，或者是不可比。**

**对于一个偏序集，他们内部的关系根据定义，不一定都是严格小于等，也就是说与全序集不同，偏序集的内部关系是一种拓扑序。**

就比如，$D_{12}$ 是一个偏序集，其中的任意两个元素，要么满足 $a \mid b$，要么之间不存在整除关系。

我们以整除为例，一定有 $a \mid a$，这称之为**自反性**；如果说 $a \mid b$，且有 $b \mid a$，则一定 $a = b$，这叫做**反对称性**；如果 $a \mid b$，$b \mid c$，则 $a \mid c$，这是**传递性**。

### 2. 对于一个函数 $f(x)$，满足：

$$\begin{aligned} F(x) = \sum _ {d \mid x} f(d) \end{aligned}$$

那么我们可以列出一些式子：

$$\begin{aligned} F(1) &= f(1) \\ F(2) &= f(1) + f(2) \\ F(3) &= f(1) + f(3) \\ F(4) &= f(1) + f(2) + f(4) \\ F(5) &= f(1) + f(5)  \end{aligned}$$

我们可以对这个作图，我们令 $a$ 可以覆盖 $b$，当且仅当 $b \mid a$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fdlha92k.png)

这是我们对 $F(4)$ 建图的结果，可以得到
$$\begin{aligned} F(4) = f(1) + f(2) + f(4) \end{aligned}$$
$$\begin{aligned} f(4) = F(4) - F(2) \end{aligned}$$
对 $F(12)$ 建图：

![](https://cdn.luogu.com.cn/upload/image_hosting/u69kgi7k.png)

很明显，结果就是：

$$\begin{aligned} F(12) = f(1) + f(2) + f(3) + f(4) + f(6) + f(12) \end{aligned}$$
$$\begin{aligned} f(12) = F(6) + F(4) - F(2) \end{aligned}$$

仅通过这两个例子，我们就能看出，求 $F$ 函数的递推式其实是容斥原理的应用，而最一开始也说过了，我们是在求定义另一个函数的函数，也就是说我们在求解 $f(x)$。
莫比乌斯函数 $μ$ 在莫比乌斯反演中的应用是：

$$\begin{aligned} f(x) = \sum _ {d \mid x} F(d) μ(d) \end{aligned}$$

那到这里，我们就已经可以推出整个题目莫比乌斯反演的流程了。
## 如何实现 $P4466$？
1. 我们之所以会看出这道题是在求莫比乌斯反演，是因为~~不会写看了眼标签~~在题干给出的两个要求当中，其中的一个条件就是整除，这种很明显的偏序关系，基本上就是莫比乌斯反演了(吧)，因此我们需要探究一下 $a$ 与 $b$ 的性质了，这也是根据~~标签~~题意看出来的，既然是整除，那么就要保证 $gcd$ 值的特殊性了。
### 令 $g = \operatorname{gcd}(a,b)$，则假设，如果 $g = 1$。

$$\begin{aligned} \gcd(a,b) &= \gcd(a + b,b) \\ &= \gcd(a,a + b) \\ &= \gcd(a+b,ab) \\ &= 1\end{aligned}$$

这里是因为如果 $a + b$ 与 $a$，$b$ 互质的话，那么 $a + b$ 与 $a$，$b$ 之间就没有公因子，那 $a + b$ 与 $ab$ 自然也没有公因子，也就是互质。

简单一讲，就是说 $a + b$ 与 $a$，$b$ 两数均互质，则不可能成为他们乘积的因数
那么 $a$ 与 $b$ 就一定不互质了，那么就可以写成 $a = gi$，$b = gj$ 那也就有：

$$\begin{aligned} a + b &\mid ab  \\ gi + gj &\mid g ^ 2 ij \\ i + j &\mid gij \end{aligned}$$

现在 $i$ 与 $j$ 互质，那么就有：

$$\begin{aligned}\gcd(i + j,ij) = 1 \end{aligned}$$

因此 $i + j$ 与 $ij$ 互质，就有：

$$\begin{aligned} i + j \mid g \end{aligned}$$

那么现在就成了求解：有多少组 $i,j,g$ 满足：

$$i + j \mid d,id,jd \le n$$

则我们可以列出下面的式子：

$$\begin{aligned} \sum _ {i = 1} ^ n \sum _ {j = 1} ^ {i - 1} \lfloor \frac{\lfloor \frac{n}{i} \rfloor}{i + j}\rfloor[gcd(i,j) = 1] &= \sum _ {i = 1} ^ {n} \sum _ {j = 1} ^ {i - 1} \lfloor \frac{n}{i(i + j)}\rfloor[\gcd(i,j) = 1]  \end{aligned}$$

但是现在 $O(n ^ 2)$ 的复杂度，对于最大值 $2 ^ {31} - 1$ 的复杂度，肯定就炸了，连 $O(n)$ 都满足不了，所以我们要对这个式子优化。

也不难看出来，其实我们在枚举 $i$ 的过程中，当 $i = \sqrt{n}$ 时，$i(i + j)$ 的结果就已经超过 $n$ 的值了，也就是说这时候 $\lfloor \frac{n}{i(i + j)} \rfloor$ 的值为 $0$ 那也就是说，只需要枚举到 $\sqrt{n}$ 之前就可以了。

$$\begin{aligned} \sum _ {i = 1} ^ {n} \sum _ {j = 1} ^ {i - 1}\lfloor \frac{n}{i(i + j)}\rfloor[\gcd(i,j) = 1] &= \sum _ {i = 1} ^ {\sqrt{n}} \sum _ {j = 1} ^ {i - 1} \lfloor \frac{n}{i(i + j)}[\gcd(i,j) = 1] \rfloor\end{aligned}$$

这时候对艾弗森括号里的内容进行莫比乌斯反演，就可以得到：

$$\begin{aligned} \sum _ {i = 1} ^ {\sqrt{n}} \sum _ {j = 1} ^ {i - 1}\lfloor \frac{n}{i(i + j)} \rfloor \sum _ {d | \gcd(i,j)} μ(d)\end{aligned}$$

那我们就没有必要枚举一大堆没有计算价值的东西了，我们只需要计算运算使莫比乌斯函数有价值的东西，或者说是去掉那些重复计算的内容，用莫比乌斯函数优化从而进行反演，那最终就可以写成下面的式子。

$$\begin{aligned} \sum _ {d} ^ {\sqrt{n}} μ(d) \sum _ {i = 1} ^ {\frac{\sqrt{n}}{d}} \sum _ {j = 1} ^ {i - 1}\lfloor \frac{\lfloor\frac{n}{id ^ 2}\rfloor}{i(i + j)  } \rfloor\end{aligned}$$

记得这个题要用数论分块，到这个式子已经能大概的看出来了。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,cnt,ans;
bool flag[10000007];
int prime[1000006],mu[1000006];
void Define(int n){
	mu[1]=1;//初始打标记 
	for(int i=2;i<=n;i++){
		if(!flag[i]) prime[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++){//这里类似于线性筛，是求莫比乌斯函数用的 
			flag[i*prime[j]]=true;//给合数打上标记 
			if(i%prime[j]==0) break;//线性筛O(n)优化的地方，当然，这里是O(sqrt(n)) 
			mu[i*prime[j]]=-mu[i];//反标记，说简单一点就是莫比乌斯函数更新值 
		}
	}
}
int miu(int start,int x){
	int res=0;
	int end=start<<1;
	if(!x) return 0;
	for(int i=start+1,j;i<end;i=j+1){
	    if(x/i==0) return res;
		j=min(x/(x/i),end-1);
		res+=1ll*(j-i+1)*(x/i);
	}
	return res;
}
signed main(){
	cin >> n;
	m=sqrt(n);
	Define(m);//预处理出所有需要用到的莫比乌斯函数值                                                                                                                                                                                                                                                                                                                 
	for(int i=1;i<=m;i++){
		if(!mu[i])	continue;
		for(int j=1;j*i<=m;j++)
			ans+=mu[i]*miu(j,n/(i*i*j));//这里就是刚才推的式子 
	}
	cout << o(^_^)o;
	return 0;
}
/*
pikaへ　　 　　　／|
　　/＼7　　　 ∠＿/
　 /　│　　 ／　／
　│　 Z＿,＜　／　　 /`ヽ
　│　　　　　ヽ　　 /　　〉
　 Y　　　　　`　 /　　/
　?●　?　●　　??〈　　/
　()　 へ　　　　|　＼〈
　　>? ?_　 ィ　 │ ／／
　 / へ　　 /　?＜| ＼＼
　 ヽ_?　　(_／　 │／／
　　7　　　　　　　|／
　　＞―r￣￣`?―＿
*/
```

---

## 作者：_Fontainebleau_ (赞：5)

### 题意

- 给定 $n$，求满足 $1\le a< b\le n$ 且 $a+b \mid a b$ 的数对 $(a,b)$ 的个数。
- $n\le 2^{31} -1$。

### 做法

考虑 [Mobius 反演](https://www.luogu.com.cn/blog/181775/Mobius-inversion)。

假设 $(a,b)$ 满足条件。

令 $d=\gcd(a,b)$，设 $a=xd,b=yd$，则 $\gcd(x,y)=1$。

此时 $\dfrac{ab}{a+b}=\dfrac{xyd^2}{xd+yd}=\dfrac{xyd}{x+y}$。因为 $a+b \mid ab$，所以 $x+y \mid xyd$。

因为 $\gcd(x,y)=1$，所以 $\gcd(x+y,y)=\gcd(x+y,x)=\gcd(x,y)=1$。所以 $\gcd(x+y,xy)=1$。那么 $x+y \mid d$。

于是这道题就被我们转化成了这个样子：求 $x+y \mid d,\gcd(x,y)=1$ 且 $xd,yd\le n$ 的 $(x,y,d)$ 的个数。

结果就是

$$\displaystyle\sum\limits_{x=1}^n\sum\limits_{y=1}^{x-1} {\color{pink}\left\lfloor\dfrac{\left\lfloor\frac nx\right\rfloor}{x+y}\right\rfloor}[\gcd(x,y)=1]=\sum\limits_{x=1}^n\sum\limits_{y=1}^{x-1} {\color{Midnightblue}\left\lfloor\dfrac{n}{x(x+y)}\right\rfloor}[\gcd(x,y)=1]$$

注意上式的 $i,j$ 为前文的 $x,y$。 $\color{pink}\text{pink}$ 部分表示 $d$ 的取值个数，~~大家可以自己悟一下。~~ 

具体而言就是因为 $a=xd \le n,x>y$，所以 $d$ 最大取到 $\left\lfloor\dfrac nx\right\rfloor$，而 $d$ 要满足被 $(x+y)$ 整除的条件，所以共 $\left\lfloor\dfrac{\left\lfloor\frac nx\right\rfloor}{x+y}\right\rfloor$ 个取法。而 $\color{Midnightblue}\text{Midnightblue}$ 部分，则是 $\color{pink}\text{pink}$ 部分的转化。在 $\color{Midnightblue}\text{Midnightblue}$ 部分中，我们可以更加清晰地认识到，当 $x>\sqrt n$ 时，$x(x+y)>n$，$\left\lfloor\dfrac{n}{x(x+y)}\right\rfloor=0$。

所以 

$$\displaystyle \sum_{x=1}^{\sqrt{n}}\sum_{y=1}^{x-1}\left\lfloor\dfrac{n}{x(x+y)}\right\rfloor{\color{pink}\left[\gcd(x,y)=1\right]}$$

对 $\color{pink}\text{pink}$ 部分进行 Mobius 反演。

$$\displaystyle \sum_{x=1}^{\sqrt n}\sum_{y=1}^{x-1}\left\lfloor\dfrac{n}{x(x+y)}\right\rfloor\sum_{k\mid (x,y)}\mu\left(k\right)$$

改变枚举顺序，令 $x=pk,y=qk$

$$\displaystyle\sum_{k=1}^{\sqrt n}\mu (k)\sum_{p=1}^{\left\lfloor\frac{\sqrt n}{k}\right\rfloor}\sum_{q=1}^{p-1} \left\lfloor\dfrac{n}{pk(pk+qk)}\right\rfloor=\sum_{k=1}^{\sqrt n}\mu (k)\sum_{p=1}^{\left\lfloor\frac{\sqrt n}{k}\right\rfloor}\sum_{q=1}^{p-1} \left\lfloor\dfrac{\color{pink}\left\lfloor\frac{n}{pk^2}\right\rfloor}{p+q}\right\rfloor$$

在我们枚举了 $k,p$ 后， $\color{pink}\text{pink}$ 部分是定值。于是就可以数论分块了。



### 代码

注意整除分块在实现时和一般的不同。因为 $0<q<p$，所以整出分块是从 $p+1$ 搞到 $2p-1$ 的。

```c++
#include<bits/stdc++.h>
using namespace std;
int n,cnt,m;
bitset<1000006> used;
int prime[1000006],mu[1000006];
long long ans;
inline void sieve(int n)
{
	mu[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!used[i])	prime[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			used[i*prime[j]]=1;
			if(i%prime[j])	mu[i*prime[j]]=-mu[i];
			else	break;
		}
	}
}
inline long long calc(int st,int x)
{
	long long res=0;
	int ed=st<<1; 
	if(!x)	return 0;
	for(int l=st+1,r;l<ed;l=r+1)
	{
	    if(x/l) r=min(x/(x/l),ed-1);
	    else    return res;
		res+=1ll*(r-l+1)*(x/l);
	}
	return res;
}
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int main()
{
	n=read();
	m=sqrt(n);
	sieve(m);
	for(int i=1;i<=m;i++)
	{
		if(!mu[i])	continue;
		for(int j=1;j*i<=m;j++)
			ans+=mu[i]*calc(j,n/(i*i*j));
	}
	printf("%lld\n",ans);
	return 0;
}

```



---

## 作者：littlez_meow (赞：4)

一道看上去很水的反演题。

保证萌新也看懂！

[题目指路](https://www.luogu.com.cn/problem/P4466)

## step 1：引理

依照宇宙惯例，各位 dalao 可以跳过。

【引理 1】 $(a+b)|ab\Rightarrow (a,b)\neq 1$

证明：考虑证明其逆否命题。

$\because (a,b)=1$

$\therefore (a+b,a)=(a+b,b)=(a,b)=1$

$\therefore (a+b,ab)=1$

$\therefore (a,b)\neq 1\Rightarrow (a+b)\nmid ab$

证毕

那又完了，莫比乌斯反演又要求格式是 $(a,b)=1$，而非不等。

既然如此，我们设 $d=(a,b)$，把 $a,b$ 都除以 $d$，不就变成要求格式了吗？

既然如此，让我们设 $a=di,b=dj$，求证：

【引理 2】$\sum_{a=1}^n\sum_{b=1}^n [(a+b)|ab]=\sum_{j=1}^n\sum_{i=1}^{j-1}\lfloor\frac{\lfloor\frac n j\rfloor}{i+j}\rfloor[(i, j)=1]$

证明：$\because a<b\ \therefore i<j$

$\because (a+b)|ab\ \therefore d(i+j)|ijd^2$

由最大公约数定义，$(i,j)=1$。由引理 1，$(i,j)\nmid ij$

$\therefore (i+j)|d$

因此，$d$ 的取值个数为 $\lfloor\frac{\lfloor\frac n j\rfloor}{i+j}\rfloor$。

证毕

好，成功转换，就可以开始推式子了！

## step 2：推式子

原式 $=\sum\limits_{j=1}^n\sum\limits_{i=1}^{j-1}\lfloor\dfrac{\lfloor\frac n j\rfloor}{i+j}\rfloor[(i, j)=1]$

$i,j$ 反着看着很烦，交换，接下来下文所有字母与上文推导无关。再把双层向下取整化简，得

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^{i-1}\lfloor\dfrac n{i(i+j)}\rfloor[(i, j)=1]$

若 $i>\sqrt n$，则 $i(i+j)>n$，就有 $\lfloor\dfrac n{i(i+j)}\rfloor=0$。由此可得

$=\sum\limits_{i=1}^{\lfloor\sqrt n\rfloor}\sum\limits_{j=1}^{i-1}\lfloor\dfrac n{i(i+j)}\rfloor[(i, j)=1]$

进行莫比乌斯反演，得

$=\sum\limits_{i=1}^{\lfloor\sqrt n\rfloor}\sum\limits_{j=1}^{i-1}\lfloor\dfrac n{i(i+j)}\rfloor\sum\limits_{d|i,d|j}\mu(d)$

枚举约数换枚举倍数，换 $i,j$ 为 $di,dj$，得

$=\sum\limits_{d=1}^{\lfloor\sqrt n\rfloor}\mu(d)\sum\limits_{i=1}^{\lfloor\frac{\sqrt n}d\rfloor}\sum\limits_{j=1}^{i-1}\lfloor\dfrac n{id^2(i+j)}\rfloor$

再把 $id^2$ 提回分子向下取整，得

$=\sum\limits_{d=1}^{\lfloor\sqrt n\rfloor}\mu(d)\sum\limits_{i=1}^{\lfloor\frac{\sqrt n}d\rfloor}\sum\limits_{j=1}^{i-1}\lfloor\dfrac{\lfloor\frac n{id^2}\rfloor}{i+j}\rfloor$

在枚举 $d,i$ 后 分子一定，整除分块的板子不就来了吗？

分析时间复杂度，一二层循环之积为 $O(\sqrt n)$，第三层是调和级数 $O(\log\sqrt n)$，大概是这样？反正能过。

## step 3：附上代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a),i##i(b);i<=i##i;++i)
#define R(i,a,b) for(int i(a),i##i(b);i>=i##i;--i)
#define _ 0
using namespace std;
const int MAXN=1e5;
int n,sqrtn;
ll ans;
short mu[MAXN+1];
bool v[MAXN+1];
vector<int>prime;
inline void pre(){
    v[1]=mu[1]=1;
    F(i,2,sqrtn){
        if(!v[i]){prime.push_back(i);mu[i]=-1;}
        for(int j:prime){
            ll h=(ll)i*j;
            if(h>sqrtn) break;
            v[h]=1;
            if(i%j) mu[h]=-mu[i];
            else break;
        }
    }
    return;
}
inline ll solve(int bg,int x){
    ll res(0);
    int ed=bg<<1;
    if(!x) return 0;
    for(int l(bg+1),r;l<ed;l=r+1){
        if(!(x/l)) break;
        r=min(x/(x/l),ed-1);
        res+=(ll)(r-l+1)*(x/l);
    }
    return res;
}
int main(){
    scanf("%d",&n);
    sqrtn=(int)sqrt(n);
    pre();
    F(d,1,sqrtn){
        if(!mu[d]) continue;
        F(i,1,sqrtn/d) ans+=mu[d]*solve(i,n/(d*d*i));
    }
    cout<<ans;
    return ~~(0^_^0);//每日卖萌(1/1)
}
```

完结撒花 qaq~

不要再把颜文字看成快速莫比乌斯变换 FWT 了！

---

## 作者：ZillionX (赞：2)

# Description

给定 $n$，求满足 $1\le a<b \le n$ 且 $a+b \mid ab$ 的 $(a,b)$ 个数。

$n \le 2^{31}-1$，时限 1s。

# Solution

小清新反演题。

考虑提取 $d=\gcd(a,b)$，令 $a \leftarrow \dfrac{a}{d}, b \leftarrow \dfrac{b}{d}$，此时条件转化为

- $a<b$
- $ad,bd\le n$
- $\gcd(a,b)=1$
- $ad+bd \mid abd^2$，即 $a+b \mid abd$，注意到此时必然 $\gcd(a+b,ab)=1$，进一步有 $a+b \mid d$

不妨枚举 $a$，可以发现答案即为

$$\sum_{a=1}^{\sqrt n}\sum_{b=a+1}^{\sqrt n} \left\lfloor\frac{\left\lfloor\frac{n}{b}\right\rfloor}{a+b}\right\rfloor [\gcd(a,b)=1]$$

这是因为，由于 $ad<bd\le n$，$d$ 最大只能取到 $\left\lfloor\dfrac{n}{b}\right\rfloor$。同时 $\left\lfloor\dfrac{\left\lfloor\frac{n}{b}\right\rfloor}{a+b}\right\rfloor$ 只有在 $a,b \le \sqrt n$ 时才不为 $0$。

可以开始大力 Möbius 反演推式。

$$\begin{aligned}\sum_{a=1}^{\sqrt n}\sum_{b=a+1}^{\sqrt n} \left\lfloor\frac{\left\lfloor\frac{n}{b}\right\rfloor}{a+b}\right\rfloor [\gcd(a,b)=1]&=\sum_{a=1}^{\sqrt n}\sum_{b=a+1}^{\sqrt n} \left\lfloor\frac{\left\lfloor\frac{n}{b}\right\rfloor}{a+b}\right\rfloor \sum_{d \mid \gcd(a,b)} \mu(d)\\&= \sum_{d=1}^{\sqrt n} \mu(d) \sum_{a=1}^{\left\lfloor\frac{\sqrt n}{d}\right\rfloor}\sum_{b=a+1}^{\left\lfloor\frac{\sqrt n}{d}\right\rfloor} \left\lfloor\frac{\left\lfloor\frac{n}{bd^2}\right\rfloor}{a+b}\right\rfloor \\&= \sum_{d=1}^{\sqrt n} \mu(d) \sum_{b=1}^{\left\lfloor\frac{\sqrt n}{d}\right\rfloor}\sum_{a=1}^{b-1} \left\lfloor\frac{\left\lfloor\frac{n}{bd^2}\right\rfloor}{a+b}\right\rfloor \end{aligned}$$

显然 $\left\lfloor\dfrac{n}{bd^2}\right\rfloor$ 是定值，那么对里面的部分整除分块即可。

不难发现时间复杂度即为

$$\sum_{i=1}^{\sqrt n}\sum_{j=1}^{\left\lfloor\frac{\sqrt n}{i}\right\rfloor} \sqrt{\left\lfloor\frac{n}{i^2j}\right\rfloor}$$

大力积分，可以得到 $\mathcal O(n^{\frac{3}{4}})$。

值得一提的是这题其实是有 $\mathcal O(n^{\frac{2}{3}})$ 做法的，只需要对 zhylj 神的题解中的 $S(n)$ 整除分块就行了，因为 $\left\lfloor\dfrac{n}{i^2}\right\rfloor$ 只有 $\mathcal O(n^{\frac{1}{3}})$ 种取值。不过太毒瘤了，时间复杂度也很难算……不想讲。我在 U 群提问后 @142857cs 和 @wkywkywky 等众神告诉了我这个复杂度的可行性。希望后人可以胜任这个工作，完成一篇严格 $\mathcal O(n^{\frac{2}{3}})$ 的题解。

# Code

```cpp
typedef long long LL;
const int N=46341,P=4793;

int n,tot,p[P],Mo[N];
LL Ans;
bitset<N> v;

void Mob(int n) {
	Mo[1]=1;
    for (int i=2;i<=n;i++) {
        if (v[i]==0)
            Mo[i]=-1,p[++tot]=i;
        for (int j=1;j<=tot && i*p[j]<=n;j++) {
            v[i*p[j]]=1;
            if (i%p[j]) Mo[i*p[j]]=-Mo[i];
			else {
				Mo[i*p[j]]=0;
				break;
			}
        }
    }
}

int Calc(int s,int x) {
	int Sum=0;
	for (int l=s+1,r;l<(s<<1);l=r+1) {
		if (!(x/l)) return Sum;
		r=min(x/(x/l),(s<<1)-1);
		Sum+=(r-l+1)*(x/l);
	}
	return Sum;
}

int main() {
	scanf("%d",&n);
	int m=sqrt(n);
	Mob(m);
	for (int i=1;i<=m;i++)
		if (Mo[i]) {
			for (int j=1;j<=m/i;j++)
				Ans+=Mo[i]*Calc(j,n/(i*i*j));
		}
	printf("%lld",Ans);
	return 0;
}
```


---

## 作者：Transfixion_ (赞：1)

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P4466)

## $\textbf{Description}$

给定 $n$，试求出

$$\sum\limits_{a=1}^{n}\sum\limits_{b=1}^{a-1}[(a+b)\mid ab]$$

单测，$1\le n\leq2^{31}-1$。

## $\textbf{Solution}$

设 $\gcd(a,b)=g,a=gx,b=gy$。

则 $a+b=g(x+y),ab=xyg^2$。

故 $(a+b)\mid ab\iff (x+y)\mid xyg$。

$\gcd(x,y,xy)=1\Longrightarrow x + y\mid g$。

如果还是枚举 $(a,b)$  的话似乎比较困难。考虑枚举 $(x,y)$ 并累加对应 $(a,b)$ 的贡献。

对于合法的**有序**数对 $(x,y)$，其贡献（对应 $g$ 的取值个数）应该是：

$$\left\lfloor\dfrac n {(x+y)\max(x,y)}\right\rfloor=\left\lfloor\dfrac n {x(x+y)}\right\rfloor$$

于是原式可以化为：

$$\sum_{x=1}^n\sum_{y=1}^{x-1}\left\lfloor\dfrac n {x(x+y)}\right\rfloor[\gcd(x,y)=1]$$

注意到只有 $x\le\lfloor\sqrt n\rfloor$ 时才有贡献，对上界进行调整。原式化为：

$$\sum_{x=1}^{\lfloor\sqrt n\rfloor}\sum_{y=1}^{x-1}\left\lfloor\dfrac n {x(x+y)}\right\rfloor[\gcd(x,y)=1]$$

经典 Mobius 反演。

$$\sum_{x=1}^{\lfloor\sqrt n\rfloor}\sum_{y=1}^{x-1}\left\lfloor\dfrac n {x(x+y)}\right\rfloor\sum_{d\mid \gcd(x,y)}\mu(d)$$

枚举约数换成枚举倍数。令 $x=dx,y=dy$，得

$$\begin{aligned}&\sum_{d=1}^{\lfloor \sqrt n\rfloor}\mu(d)\sum_{x=1}^{\lfloor\sqrt n/d\rfloor}\sum_{y=1}^{x-1}\left\lfloor\dfrac n {d^2x(x+y)}\right\rfloor\\=&\sum_{d=1}^{\lfloor \sqrt n\rfloor}\mu(d)\sum_{x=1}^{\lfloor\sqrt n/d\rfloor}\sum_{y=1}^{x-1}\left\lfloor\dfrac {\left\lfloor \dfrac n{d^2x}\right\rfloor}{x+y}\right\rfloor\\=&\sum_{d=1}^{\lfloor \sqrt n\rfloor}\mu(d)\sum_{x=1}^{\lfloor\sqrt n/d\rfloor}\sum_{T=x+1}^{2x-1}\left\lfloor\dfrac {\left\lfloor \dfrac n{d^2x}\right\rfloor}{T}\right\rfloor\end{aligned}$$

在枚举 $d$ 与 $x$ 后，分母 $\left\lfloor \dfrac n{d^2x}\right\rfloor$ 为定值。数论分块即可。

## $\textbf{Time Complexity}$

显然，时间复杂度应该是：

$$\int_{1}^{\sqrt n}\text dx\int_{1}^{x} \sqrt{\frac{n}{x^2y}}\text dy$$

把后面那个积分设为 $f(x)$，则：

$$f(x)=\int_{1}^{x}\sqrt{\dfrac{n}{x^2y}}\text{d}y=n^{1/2}\cdot x^{-(1/2)}$$

原式就可以转化成：

$$\int_1^{\sqrt n}f(x)\text dx=n^{1/2}\cdot (n^{1/2})^{1/2}=n^{3/4}$$

故时间复杂度为 $\mathcal O(n^{3/4})$。


## $\textbf{Postscript}$

在经过上界的放缩之后 $(n\to \sqrt n)$，线性筛和数论分块的规模是很小的，可以省去很多不必开的 `long long`。

观察答案的和式。可以发现，若当前枚举的 $\mu(d)=0$，那么后面的那个 $\sum$ 对答案没有贡献，直接 `continue` 即可。加上这个剪枝之后代码跑得飞快，截止 2023/5/10 是最优解。

看到题解里有说 $\mathcal O(n^{2/3})$ 的，但是似乎不能剪掉 $\mu (d)=0$  的情况，跑得反而慢一点。

## $\textbf{AC Code}$

```cpp
#include <bits/stdc++.h>
typedef long long i64;
constexpr int N = 1e5 + 5;
constexpr int p = 1e9 + 7;
int prime[N / 7], mu[N], tot;
bool vis[N];

inline void Init(int n) {
	mu[1] = 1;
    for(int i = 2; i <= n; i++) {
        if(!vis[i]) prime[++tot] = i, mu[i] = -1;
        for(int j = 1; j <= tot && i * prime[j] <= n; j++) {
            vis[i * prime[j]] = 1;
            if(i % prime[j] == 0) break;
            mu[i * prime[j]] = -mu[i];
        }
    }
}

inline int calc(int st, int ed, int n) {
	int res = 0, l, r;
	for(l = st; l <= ed; l = r + 1) {
		if(n / l == 0) return res;
		r = std::min(n / (n / l), ed);
		res += (n / l) * (r - l + 1);
	} return res;
}

int n, sq; i64 ans;
signed main() {
	std::cin >> n;
	Init(sq = (int)sqrt(n));
	for(int d = 1; d <= sq; d++) {
		if(!mu[d]) continue;
		for(int x = 1; x * d <= sq; x++) {
			ans += mu[d] * calc(x + 1, (x << 1) - 1, n / (d * d * x));
		}
	}
	std::cout << ans << '\n';
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

尝试给 $a+b \mid ab$ 提供一个通解。显然 $a + b \mid a^2+ab$，所以 $a+b \mid a^2$，同理 $a+b \mid b^2$，所以 $a+b \mid \gcd(a,b)^2$。

令 $d=\gcd(a,b)$，$A=\dfrac{a}{d}$，$B = \dfrac{b}{d}$，则 $A+B \mid d$。

设 $d=k(A+B)$，所以 $a+b=k(A+B)^2$，$ab=ABk^2(A+B)^2$ 显然满足。

因此答案就是：
$$
\sum_{i=1}^n \sum_{j=i+1}^n [\gcd(i,j)=1] \lfloor \dfrac{n}{j(i+j)} \rfloor
$$
套路性莫比乌斯反演，得到：
$$
\sum_{d=1}^n \mu(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=i+1}^{\lfloor \frac{n}{d} \rfloor} \lfloor \frac{n}{d^2j(i+j)} \rfloor
$$

注意到 $d < \sqrt n$，所以可以直接暴力求。现在考虑

$$
\sum_{i=1}^{n} \sum_{j=i+1}^n \lfloor \dfrac{m}{j(i+j)} \rfloor
$$
如何求。

实际上要满足 $j^2 \le m$，即 $j \le \sqrt m$，所以求和上下界都会缩小很多。

枚举 $j$，发现每次只需要求 $f(\lfloor \dfrac{m}{j} \rfloor,j+1,2j-1)$，其中 $f(k,l,r) = \sum_{i=l}^r \lfloor \dfrac{k}{i} \rfloor$。当 $j$ 小的时候可以 $O(j)$ 暴力枚举， $j$ 大的时候可以 $O(\sqrt \frac{m}{j})$ 整除分块。

这样做似乎有点暴力，但是很容易发现单独计算一次和式复杂度为 $O(m^{0.75})$，所以总的复杂度为 $O(n^{0.75})$，其实非常简单。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10;
int n,m=1000000,flg[MAXN],mu[MAXN];
ll ans;
void init(int mx) {
	mu[1]=1;
	vector<int> pr;
	ffor(i,2,mx) {
		if(!flg[i]) pr.push_back(i),mu[i]=-1;
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) break ;
			mu[i*v]=-mu[i];	
		}
	}
	return ;
}
map<int,ll> mp;
ll f(int m,int l,int r) {
    if(r>m) r=m;
	if(r-l<=5000) {
		ll ans=0;
		ffor(i,l,r) ans+=m/i;
		return ans;
	}
	int L=l;
	ll ans=0;
	while(L<=m) {
		int R=m/(m/L),llx=max(L,l),rrx=min(R,r);
		if(llx<=rrx) ans+=(m/L)*(rrx-llx+1);
		L=R+1;
	}
	return ans;
}
ll solve(int m) {
	if(mp.count(m)) return mp[m];
	int u=sqrt(m);
	ll ans=0;
	ffor(i,1,u) ans+=f(m/i,i+1,2*i-1);
	return ans;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	init(1000000);
	cin>>n;
	ffor(d,1,n/d) ans+=mu[d]*solve(n/d/d);	
	cout<<ans;
	return 0;
}
```

---

## 作者：_7thRC_CB_CRP_ (赞：0)

# Solution

中途的一个等号直接代进了原式，这很容易理解：

$$
\begin{aligned}
\sum_{a=1}^n\sum_{b=1}^n[a+b\mid ab]&=\sum_{k}\sum_{a=1}^{\lfloor \frac n k \rfloor}\sum_{b=1}^{\lfloor \frac n k \rfloor}[\gcd(a,b)=1][ak+bk\mid abk^2]
\\
&=\sum_{k}\sum_{a=1}^{\lfloor \frac n k \rfloor}\sum_{b=1}^{\lfloor \frac n k \rfloor}[\gcd(a,b)=1][a+b\mid k]
\\
&=\sum_{a=1}^{n}\sum_{b=1}^{n}[\gcd(a,b)=1]\lfloor \frac n {(a+b)\max(a,b)}\rfloor
\\
&=\sum_{a=1}^{n}\sum_{b=1}^{a-1}[\gcd(a,b)=1]\lfloor \frac n {a(a+b)}\rfloor
\end{aligned}
$$

还是只用求中间的。

$$
\begin{aligned}
\sum_{a=1}^{n}\sum_{b=1}^{a-1}[\gcd(a,b)=1]\lfloor \frac n {a(a+b)}\rfloor&=\sum_{a=1}^{n}\sum_{b=1}^{a-1}\sum_{d\mid\gcd(a,b)}\mu(d)\lfloor \frac n {a(a+b)}\rfloor
\\
&=\sum_{d}\mu(d)\sum_{a=1}^{\lfloor\frac n d\rfloor}\sum_{b=1}^{a-1}\lfloor \frac n {a(a+b)d^2}\rfloor
\\
\end{aligned}
$$

由于 $a(a+b)d^2\le n$ 的约束，即可直接枚举。复杂度非常的健康（温馨小提示：如果直接写常数不太健康）。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
int cnt,prim[1000001],mu[1000001];
bool vis[1000001];
void get_mu(ll n) {
	mu[1]=1;
	for(int i=2;i<=n;i++) {
		if(!vis[i])	cnt++,prim[cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&prim[j]*i<=n;j++) {
			vis[i*prim[j]]=1;
			if(!(i%prim[j])) {
				mu[i*prim[j]]=0;
				break;
			}
			mu[i*prim[j]]=-mu[i];
		}
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	get_mu(1000000);
	int n;
	cin>>n;
	ll ans=0;
	int op=sqrt(n);
	for(int d=1;d<=op;d++) {
		int m=mu[d];
		if(m!=0) {
			ll opp=n/(d*d);
			opp=sqrt(opp);
			for(ll a=1;a<=opp;a++) {
				ll l=a+1;
				while(l<=n/(a*d*d)&&a*2>l) {
					ll r=(n/(a*d*d))/((n/(a*d*d))/l);
					r=min(r,a*2-1);
					ans+=m*(n/(a*l*d*d))*(r-l+1);
					l=r+1;
				}
			}
		}
	}
	cout<<ans;
}
```

---

## 作者：aaaaaaaawsl (赞：0)

比较基础的莫比乌斯反演。

大体思路是写出最基础的式子，把特殊的一部分反演成易于求的形式，然后根据式子缩小枚举范围。不需要设两个函数。

本篇题解相较于其他题解多讲了切换循环顺序的部分。

---


### 引理

$ a + b |ab \Rightarrow (a,b) \neq 1 $ 

证明：

设 $a + b | ab$ 且 $ (a,b) = 1$

取 $p$ 为 $a + b$ 的素因子，得 $p | a + b$

所以 $p | a$ 或 $p | b$

设 $p | a$，所以 $p | (a + b) - a$

所以 $p | b$

与 $(a, b) = 1$ 矛盾

证毕。

-------

### 推演过程

设 $d = (a, b), x = \frac{a}{d}, y = \frac{b}{d}$，可得 $(x, y) = 1$

因为 $a + b | ab$ 即为 $xd + yd | xdyd$

即为 $x + y | xyd$

由引理可知，此时 $(x , y) = 1 \Rightarrow x + y \nmid xy$

所以 $x + y | d$

于是答案为三元组 $(x, y, d)$的数量。

枚举 $x, y$ 得如下式子

$\displaystyle\sum^{n}_{i = 1} \displaystyle\sum^{i - 1}_{j = 1} \lfloor{\frac{ \lfloor{\frac{n}{i}} \rfloor}{i + j}} \rfloor [(i,j) = 1]$

其中 $ \lfloor{\frac{n}{i}} \rfloor $ 为 $d$ 的数量。因为枚举了 $i$ 后，只要乘上一个常数使它不超过 $n$，常数就是一个合法的 $d$，总数有 $ \lfloor{\frac{n}{i}} \rfloor $，由于 $i > j$ 所以 $d$ 肯定对 $j$ 也合法。

由基础莫反知识得（详细证明见文末）。

$\displaystyle\sum^{n}_{i = 1} \displaystyle\sum^{i - 1}_{j = 1} \lfloor{\frac{ \lfloor{\frac{n}{i}} \rfloor}{i + j}} \rfloor [(i,j) = 1] = \displaystyle\sum^{n}_{i = 1} \displaystyle\sum^{i - 1}_{j = 1} \lfloor{\frac{ \lfloor{\frac{n}{i}} \rfloor}{i + j}} \rfloor \displaystyle\sum_{k |(i, j)} \mu(k)$ 



把 $i$ 拿下来

原式 $ = \displaystyle\sum^{n}_{i = 1} \displaystyle\sum^{i - 1}_{j = 1} \lfloor{\frac{n}{i(i + j)}} \rfloor \displaystyle\sum_{k |(i, j)} \mu(k)$

当 $i > \sqrt{n}, j > 1$，所以 $(i + j) > \sqrt{n}$。所以 ${\frac{n}{i(i + j)}} = 0$

所以原式 $ = \displaystyle\sum^{\sqrt{n}}_{i = 1} \displaystyle\sum^{i - 1}_{j = 1} \lfloor{\frac{n}{i(i + j)}} \rfloor \displaystyle\sum_{k |(i, j)} \mu(k)$

由于可以预处理 $\mu$，考虑把他提到式子前面。因为 $i \to \sqrt{n}, j \to i - 1$，所以 $k$ 的值域为 $1 \to \sqrt{n}$

设 $i = ak,j = bk$

所以枚举 $a, b$ 可以表示出所有的 $i, j$。

由于 $i > j$ 所以 $b$ 要枚举到 $a - 1$。

原式 $= \displaystyle\sum_{k = 1}^{\sqrt{n}} \mu(k) \displaystyle\sum_{a = 1}^{\lfloor \frac{\sqrt{n}}{k}\rfloor} \displaystyle\sum_{b = 1}^{a - 1} \lfloor \frac{n}{ak(ak + bk)} \rfloor = \displaystyle\sum_{k = 1}^{\sqrt{n}} \mu(k) \displaystyle\sum_{a = 1}^{\lfloor \frac{\sqrt{n}}{k}\rfloor} \displaystyle\sum_{b = 1}^{a - 1} \lfloor \frac{\lfloor \frac{n}{ak^2} \rfloor}{a + b} \rfloor$

枚举了 $a, k$ 之后，可以对 $b$ 做数论分块。

时间复杂度不会证。看别人证的应该是 $O(n^{\frac{3}{4}})$。

------

### 代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

inline int read(){
	register int x = 0, f = 1; register char ch = getchar();
	for(; ch > '9' || ch < '0'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

const int N = 1e5 + 10;

int n;
long long ans;
int mu[N];
int vis[N], prime[N], tot;

void getMu(int n){
	mu[1] = 1;
	for(int i = 2; i <= n; ++ i){
		if(!vis[i]) prime[++ tot] = i, mu[i] = -1;
		for(int j = 1; j <= tot && i * prime[j] <= n; ++ j){
			vis[i * prime[j]] = 1;
			if(i % prime[j] == 0) {mu[i * prime[j]] = 0; break; }
			mu[i * prime[j]] = -mu[i];
		}
	}
}

long long calc(int x, int y){
	long long a = 0; int z = (x << 1);
	if(!y) return 0;
	for(int i = x + 1; i < z; i = x + 1){
		if(!(y / i)) return a;
		x = min(y / (y / i), z - 1);
		a += (x - i + 1) * (y / i);
	}
	return a;
}

int main(){
	n = read();
	int g = n;
	n = sqrt(n);
	getMu(n);
	for(int i = 1; i <= n; ++ i){
		if(!mu[i]) continue;
		for(int j = 1; j * i <= n; ++ j){
			ans += mu[i] * calc(j, g / (i * i * j));
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```

---------

莫反式子证明：

$\displaystyle\sum_{d|n} \mu(d) = [n = 1]$

原因，展开后可以化为 $(1 - 1) ^{n}$

把 $(i, j)$ 带入得 $\displaystyle\sum_{d|(i, j)} \mu(d) = [(i, j) = 1]$

证毕。


---

## 作者：zhouyuhang (赞：0)

有点好奇这个题为啥能黑……

取 $d=\gcd(a,b)$。则有 $a+b\mid ab\iff d(a'+b')\mid d^2a'b'$，其中 $a'=\frac{a}{d},b'=\frac{b}{d}$。显然有 $(a'+b'),a',b'$ 三者之间两两互质。因此我们有 $d(a'+b')\mid d^2$，也即 $(a'+b')\mid d$。

不妨考虑对于一组 $(a',b')$，有多少组 $(a,b)$ 是符合要求的。不妨考虑 $b=b'd$，由上面的推导，不难发现 $(a'+b')\mid b$，$b'\mid b$。因此我们知道这样的 $b$ 有 $\frac{n}{\text{lcm}(a'+b',b')}=\frac{n}{(a+b)b}$ 个。显然这样的 $b$ 与一组 $d,a'$ 一一对应，自然也就与 $a$ 一一对应。于是我们只需要求出 $\sum_{i=1}^n\sum_{j=1}^{i-1}[i\perp j]\lfloor\frac{n}{i(i+j)}\rfloor$，其中 $i,j$ 分别对应 $b',a'$。

对于这种带着一个 $[i\perp j]$ 的式子，先考虑莫反，就有

$$\sum_{i=1}^n\sum_{j=1}^{i-1}[i\perp j]{\Large\lfloor}{\small \frac{n}{i(i+j)}}{\Large\rfloor}$$
$$=\sum_{i=1}^n\sum_{j=1}^{i-1}\sum_{T\mid \gcd(i,j)}\mu(T){\Large\lfloor}{\small \frac{n}{i(i+j)}}{\Large\rfloor}$$
$$=\sum_{T=1}^n\mu(T)\sum_{i=1}^{n/T}\sum_{j=1}^{i-1}{\Large\lfloor}{\small \frac{n}{i(i+j)T^2}}{\Large\rfloor}$$

这里的 $T$ 明显可以通过整除分块配合着杜教筛计算 $\mu$ 的前缀和来解决。于是我们只需要考虑这个式子：$f(n)=\sum_{i=1}^n\sum_{j=1}^{i-1}\lfloor\frac{n}{i(i+j)}\rfloor$。一种简单的做法是注意到 $\lfloor\frac{n}{i(i+j)}\rfloor$ 不为 $0$ 当且仅当 $n\ge i(i+j)\ge i^2$，因此必然有 $i\le \sqrt n$。枚举 $i$ 后对 $(i+j)$ 整除分块即可。积分可以证明这样做复杂度为 $O(n^{3/4})$。感觉上还有更紧的界，等我有空再仔细分析。

---

## 作者：TempestJueMu (赞：0)

[P4466](https://www.luogu.com.cn/problem/P4466)

给定 $n(n\leq 2^{31}-1)$ ,求
$$
\sum_{a=1}^n\sum_{b=a+1}^n[a+b\mid ab]
$$
首先显然有
> 若 $\gcd(a,b)=1$ ,则 $a+b\nmid ab$

~~感性理解~~

设 $\gcd(a,b)=d,a=di,b=dj$

则 $a+b=d(i+j),ab=ijd^2$

故 $i+j\mid ijd$ (由题 $\frac{ab}{a+b}$ 为整数)

而 $(i,j)=1$ ,故 $i+j\nmid ij$

故有 $i+j\mid d$

转求 $(i,j)=1$ 且 $i+j\mid d$ 且 $di\leq n,dj\leq n$ 的个数。

直接枚举 $i,j$ 。
$$
ans=\sum_{i=1}^n\sum_{j=1}^{i-1}\lfloor\frac{\lfloor\frac n i\rfloor}{i+j}\rfloor[\gcd(i,j)=1]
$$
其中 $\lfloor\frac{\lfloor\frac n i\rfloor}{i+j}\rfloor$ 表示 $d$ 的取值个数。由于 $d\leq \frac n i$ 且 $i+j\mid d$ ，故为 $\lfloor\frac{\lfloor\frac n i\rfloor}{i+j}\rfloor$ 。

进一步化简。
$$
ans=\sum_{i=1}^n\sum_{j=1}^{i-1}\lfloor\frac{n}{i(i+j)}\rfloor[\gcd(i,j)=1]
$$
注意到 $i>\sqrt n$ 时 $\lfloor\frac{n}{i(i+j)}\rfloor=0$  ,则可进一步化为
$$
ans=\sum_{i=1}^{\sqrt n}\sum_{j=1}^{i-1}\lfloor\frac{n}{i(i+j)}\rfloor[\gcd(i,j)=1]
$$
经典反演。
$$
ans=\sum_{i=1}^{\sqrt n}\sum_{j=1}^{i-1}\lfloor\frac{n}{i(i+j)}\rfloor\sum_{k\mid i,k\mid j}\mu(k)
$$
变为枚举 $k$ ，以 $ik$ 、 $jk$ 分别替换 $i$ 、 $j$ 。
$$
\begin{aligned}
ans=&\sum_{k=1}^{\sqrt n}\mu(k)\sum_{i=1}^{\lfloor\frac{\sqrt n}{k}\rfloor}\sum_{j=1}^{i-1}\lfloor\frac{n}{ik(ik+jk)}\rfloor\\
=&\sum_{k=1}^{\sqrt n}\mu(k)\sum_{i=1}^{\lfloor\frac{\sqrt n}{k}\rfloor}\sum_{j=1}^{i-1}\lfloor\frac{\lfloor\frac{n}{ik^2}\rfloor}{i+j}\rfloor
\end{aligned}
$$
枚举 $k$ 、 $i$ ,注意到 $\lfloor\frac{\lfloor\frac{n}{ik^2}\rfloor}{i+j}\rfloor$ 的分子为定值，则可以数论分块。

**Code**
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5;
int prime[N+10],mu[N+10],cnt;
bool vis[N+10];
void get_mu(int maxn)//筛出mu
{
	mu[1]=1;
	for(int i=2;i<=maxn;++i)
	{
		if(!vis[i])prime[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&i*prime[j]<=maxn;++j)
		{
			vis[i*prime[j]]=1;
			if(i%prime[j])mu[i*prime[j]]=-mu[i];
			else break;
		}
	}
}
ll calc(ll st,ll a)//分块 
{
	ll ret=0,ed=st*2;
	if(a==0)return 0;
	for(int l=st+1,r;l<ed;l=r+1)
	{
		if(a/l==0)return ret;
		r=min(a/(a/l),ed-1);
		ret+=1ll*(r-l+1)*(a/l); 
	}
	return ret;
}
ll n,ans;
int main()
{
	cin>>n;
	get_mu(sqrt(n));
	for(int k=1;k<=sqrt(n);++k)
		for(int i=1;i*k<=sqrt(n);++i)//上文中的k与i 
			ans+=1ll*mu[k]*calc(i,n/(k*k*i));
	cout<<ans;
	return 0;
}
```

---


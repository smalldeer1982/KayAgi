# 巧克力王国

## 题目描述

巧克力王国里的巧克力都是由牛奶和可可做成的。但是并不是每一块巧克力都受王国人民的欢迎，因为大家都不喜欢过于甜的巧克力。

对于每一块巧克力，我们设 $x$ 和 $y$ 为其牛奶和可可的含量。由于每个人对于甜的程度都有自己的评判标准，所以每个人都有两个参数 $a$ 和 $b$ ，分别为他自己为牛奶和可可定义的权重， 因此牛奶和可可含量分别为 $x$ 和 $y$ 的巧克力对于他的甜味程度即为 $ax+by$。而每个人又有一个甜味限度 $c$ ，所有甜味程度大于等于 $c$ 的巧克力他都无法接受。每块巧克力都有一个美味值 $h$ 。

现在我们想知道对于每个人，他所能接受的巧克力的美味值之和为多少。

## 说明/提示

对于100%的数据，$1<=n,m<=50000$,$-10^9<=a_i,b_i,x_i,y_i<=10^9$。

保证数据用某种方式随机生成。

## 样例 #1

### 输入

```
3 3
1 2 5
3 1 4
2 2 1
2 1 6
1 3 5
1 3 7```

### 输出

```
5
0
4```

# 题解

## 作者：稚名真白 (赞：15)

已到很不错的KD_tree入门题目

首先得知道什么是KD_tree

首先KD_tree是一颗二叉搜索树 树中储存了k维的数据信息 构树相当于是对k维空间进行划分的过程 所以每个节点就有了对应的k维空间的一个范围

比如当k=1时  这时候的KD_tree就是我们所熟悉的线段树 每个节点就对应了一维的一个区间 

这里有不同的是 KD_tree的每个节点都储存了信息 类似伸展树（splay） 而线段树仅有叶子节点储存信息

这里我用结构体来呈现一个 KD_tree

一个节点含有的信息有

	1. d[k] 每个维度的值
	2. mx[2],mn[2] 该树及以下节点每个维度的max和min
	3.lc,rc 左儿子和右儿子
	根据题目需要 这里加入变量val（权值） 维护一个sum（权值和）
    
接下来是KD_tree的构造方法 

我们把第i层的节点按照第 i%（维度数量）维度的优先级 取中位数（就是找到一个划分节点mid）
然后根据mid划分左右儿子 如此循环下去直到叶子节点

这是最常见的划分方法 但是容易被一些数据给卡住，见[这篇文章](https://blog.csdn.net/junshen1314/article/details/51121582)
（以上解说或多或少的都借鉴了这篇文章）

然后是针对此题的查询

如果该节点的mx mn全部满足a * x+b * y < c  

那么该节点一下的节点都满足 直接返回sum  

否则就只能拆开该节点和左右儿子 递归下去

代码部分
```cpp
/*
简单的入门KD_tree

首先需要一个专门用来排序的数组 dat
	其内容一般包括：
	1.每个维度的值
	2.该树及一下部分每个维度的max和min
	3.左儿子和右儿子
	4.权值之类的，我们需要维护的 （这里维护了一个sum
KD_tree本质是一个二叉搜索树 
我们把第i层的节点按照第 i%（维度数量）唯独的优先级 取中位数（就是找到一个划分节点mid
然后根据mid划分左右儿子 如此循环下去直到叶子节点

该题的思路是 如果该节点的mx mn全部满足a*x+b*y<c
那么该节点一下的节点都满足 直接返回sum
否则就只能拆开该节点和左右儿子 递归下去
*/
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
const int N=5e5+50;
int n,now,m,rt;
ll a,b,c;
struct data
{
	int d[2],mx[2],mn[2],lc,rc,val;
	ll sum;
	friend bool operator < (data a,data b)
		{return a.d[now]<b.d[now];}
}dat[N],t[N];
void getmax(int&a,int b){if(a<b)a=b;}
void getmin(int&a,int b){if(a>b)a=b;}
void pushup(int x)
{
	int lc=t[x].lc,rc=t[x].rc;
	for(int i=0;i<2;i++)
	{
		t[x].mn[i]=t[x].mx[i]=t[x].d[i];
		if(lc)  getmin(t[x].mn[i],t[lc].mn[i]),
			getmax(t[x].mx[i],t[lc].mx[i]);
		if(rc)  getmin(t[x].mn[i],t[rc].mn[i]),
			getmax(t[x].mx[i],t[rc].mx[i]);
	}
	t[x].sum=t[lc].sum+t[rc].sum+t[x].val;
}

int build(int l,int r,int pl)
{
	now=pl; int mid=(l+r)>>1;
	nth_element(dat+l,dat+mid,dat+r+1);
	t[mid]=dat[mid];
	if(l<mid) t[mid].lc=build(l,mid-1,!pl);
	if(r>mid) t[mid].rc=build(mid+1,r,!pl);
	pushup(mid); return mid;
}
bool check(ll x,ll y) {return x*a+y*b<c;}
ll query(int x)
{
	int tot=0;
	tot+=check(t[x].mx[0],t[x].mx[1]);
	tot+=check(t[x].mn[0],t[x].mx[1]);
	tot+=check(t[x].mx[0],t[x].mn[1]);
	tot+=check(t[x].mn[0],t[x].mn[1]);
	if(tot==4) return t[x].sum; // 都满足
	if(tot==0) return 0; // 都不满足
	ll res=0;
	if(check(t[x].d[0],t[x].d[1])) res+=t[x].val;
	if(t[x].lc) res+=query(t[x].lc);
	if(t[x].rc) res+=query(t[x].rc);
	return res;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) 
		scanf("%d%d%d",&dat[i].d[0],&dat[i].d[1],&dat[i].val);
	rt=build(1,n,0); while(m--)
	{
		scanf("%lld%lld%lld",&a,&b,&c);
		printf("%lld\n",query(rt));
	}
	return 0;
}
```
再推荐一篇[好的文章](http://www.cnblogs.com/lysuns/articles/4710712.html)

至于KD_tree的邻值查询 ~~（不是与本题无关吗，我也不会）~~

---

## 作者：EnofTaiPeople (赞：10)

十分钟写，十分钟调，这也是道难得的小清新了，使用二维 K-D Tree 对二维数点坐标极值进行维护，在查询时进行上下界剪枝因为不管查询数的正负，最后的极值一定出现在它与最大/小值的乘积中，由于数据放得很松，只需要交替建树就能通过（你想方差建树也可以）：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e4+4,M=1e6+6;
char buf[M+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2)?EOF:*p1++)
inline int read(){
    int x,f=1;for(c=gc;c<48;c=gc)if(c=='-')f=-f;
    for(x=0;c>47;x=x*10+(48^c),c=gc);return x*f;
}
ll lx[N],rx[N],ly[N],ry[N],mx[N],my[N],mm[N],sm[N],ans;
struct Node{int x,y,h;}a[N];
int n,Q,cmpT;
inline bool operator<(const Node &x,const Node &y){
    return cmpT?x.x<y.x:x.y<y.y;
}
#define Max(a,b) if(a<b)a=b
#define Min(a,b) if(a>b)a=b
int build(int l,int r){
    int x=l+r>>1,y;cmpT^=1;
    nth_element(a+l,a+x,a+r+1);
    lx[x]=rx[x]=mx[x]=a[x].x;
    ly[x]=ry[x]=my[x]=a[x].y;
    sm[x]=mm[x]=a[x].h;
    if(l<x){
        y=build(l,x-1);sm[x]+=sm[y];
        Min(lx[x],lx[y]);Min(ly[x],ly[y]);
        Max(rx[x],rx[y]);Max(ry[x],ry[y]);
    }if(x<r){
        y=build(x+1,r);sm[x]+=sm[y];
        Min(lx[x],lx[y]);Min(ly[x],ly[y]);
        Max(rx[x],rx[y]);Max(ry[x],ry[y]);
    }return x;
}
void ask(int l,int r){
    int x=l+r>>1;ll L,R,D,U;
    L=lx[x]*a[0].x,R=rx[x]*a[0].x;
    D=ly[x]*a[0].y,U=ry[x]*a[0].y;
    if(L>R)L^=R^=L^=R;
    if(D>U)D^=U^=D^=U;
    if(L+D>=a[0].h)return;
    if(R+U<a[0].h){ans+=sm[x];return;}
    L=mx[x]*a[0].x+my[x]*a[0].y;
    if(L<a[0].h)ans+=mm[x];
    if(l<x)ask(l,x-1);
    if(x<r)ask(x+1,r);
}
int main(){
    n=read(),Q=read();int i;
    for(i=1;i<=n;++i)a[i]={read(),read(),read()};
    build(1,n);
    while(Q--){
        a[ans=0]={read(),read(),read()};
        ask(1,n),printf("%lld\n",ans);
    }return 0;
}
```

---

## 作者：2x6_81 (赞：4)

## 题目大意

给定长度为 $n$ 的数组 $x, y, h$ 和长度为 $m$ 的数组 $a, b, c$，对于所有 $1 \le j \le m$，求 $\sum\limits_{i = 1}^n h_i \cdot [a_jx_i + b_jy_i < c_j]$ 的值。

## 题解

由该[讨论](https://www.luogu.com.cn/discuss/186834)可以知道，如果数据不是随机，kd-tree 是可以被卡掉的。所以在这里我给出一个不用 kd-tree 的做法。

下面不妨设 $(x_i, y_i) \neq (x_j, y_j), \forall i \neq j$，$a_ib_i \neq 0, \forall i$。

看到 $ax + by$，首先想到向量点乘，因此设 $\bm{u_j} = (a_j, b_j)$，$\bm{v_i} = (x_i, y_i)$，则 $a_jx_i + b_jy_i = \bm{u_j} \cdot \bm{v_i}$。

考虑如下做法：

首先将 $\bm{v_i}$ 按照极角排序，从小到大遍历，同时维护 $\bm{u_i}$ 在 $\bm{v_i}$ 上的投影，希望投影的长度（有正负）按照从小到大排序。

这个是好维护的，首先将 $\bm{u_i}$ 按照在 $(1, 0)$ 上投影的长度（有正负）从小到大排序，如果相同就按照 $y_i$ 作为第二关键字从小到大排序。然后作每个向量 $\bm{u_i} - \bm{u_j}$ 两个方向相反的法向量。当遍历 $\bm{v_i}$ 时穿过了其中一个法向量，则可以交换 $\bm{u_i}$ 和 $\bm{u_j}$，来保证投影的长度是有序的。

于是我们需要一个数据结构维护：

- 单点改（加或者覆盖）

- 而每次需要查询一个前缀

所以这个做法的时间复杂度是 $O((n^2 + m) \log n)$ 或者 $O(n^2 + m \sqrt{n})$ 的。

此时考虑对 $\bm{u}$ 分块，用 $B$ 替换 $n$，对每 $B$ 个点做如上操作，可以得到 $O((B^2 + m) \log B)$ 或者 $O(B^2 + m \sqrt{B})$ 的时间复杂度。

于是得到总的时间复杂度为 $O((nB + \frac{nm}{B}) \log n)$ 或者 $O(nB + \frac{mn}{\sqrt{B}})$，前者取 $B = \sqrt{m}$，后者取 $B = m^{\frac 23}$，分别得到 $O(n\sqrt{m} \log m)$ 和 $O(nm^{\frac 23})$。

我选择了前者，但感觉后者也能过（$m \le 10^8$ 时，可以认为 $O(m^{\frac 16})$ 和 $O(\log m)$ 几乎一样）。

最后别忘了要对所有的 $(x_i, y_i)$ 去重，不然 $\bm{u_i} - \bm{u_j}$ 可能为 $\bm{0}$，使得其法向量的方向不唯一确定。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair <int, int> pii;
const int N = 5e4 + 5;
struct Point {
    int x, y; LL h;
} p[N];
struct Line {
    int id, a, b, c;
} L[N];
struct Vector {
    int x, y;
    Vector (int x = 0, int y = 0):x(x), y(y) {  }
    Vector operator - (const Vector A) {
        return Vector(x - A.x, y - A.y);
    }
    bool operator == (const Vector &A) const {
        return (LL)x * A.y == (LL)y * A.x && (x > 0) == (A.x > 0) && (y > 0) == (A.y > 0);
    }
    bool operator < (const Vector &A) const {
        if (y < 0 && A.y >= 0) return 0;
        if (y >= 0 && A.y < 0) return 1;
        if (y == 0 && A.y == 0) return x > A.x;
        return (LL)x * A.y > (LL)y * A.x;
    }
};
struct Insect {
    int u, v; Vector vec;
};
vector <Insect> ins;
LL Ans[N];
int id[N], idp[N];
LL tre[305];
inline void upd(int pos, LL val) { for (; pos < 305; pos += pos & (-pos)) tre[pos] += val; }
inline LL query(int pos) { LL ret = 0; for (; pos; pos &= (pos - 1)) ret += tre[pos]; return ret; }

int main() {
    int n, m; scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d%d%lld", &p[i].x, &p[i].y, &p[i].h);
    for (int i = 1; i <= m; i++) scanf("%d%d%d", &L[i].a, &L[i].b, &L[i].c), L[i].id = i;
    sort(p + 1, p + n + 1, [](const Point &A, const Point &B) { return pii(A.x, A.y) < pii(B.x, B.y); });
    for (int lst = 1, i = 2; i <= n; i++) {
        if (p[i].x == p[lst].x && p[i].y == p[lst].y) {
            p[lst].h += p[i].h; p[i].h = 0;
        } else lst = i;
    }
    int ptot = 0;
    for (int i = 1; i <= n; i++) if (p[i].h > 0) {
        if (++ptot < i) p[ptot] = p[i];
    }
    LL tsum = 0;
    for (int i = 1; i <= n; i++) tsum += p[i].h;
    int tm = 0;
    for (int i = 1; i <= m; i++) if (L[i].a == 0 && L[i].b == 0) {
        if (L[i].c < 0) Ans[i] = tsum;
    } else if (++tm < i) L[tm] = L[i];
    // cerr << tm << endl;
    sort(L + 1, L + tm + 1, [](const Line &A, const Line &B) {
        return Vector(A.a, A.b) < Vector(B.a, B.b);
    });
    // for (int i = 1; i <= tm; i++) cerr << L[i].id << ' ';
    // cerr << endl;
    int B = max(10, (int)sqrt(tm));
    for (int i = 1; i <= ptot; i += B) {
        ins.clear();
        int l = i, r = min(i + B - 1, ptot);
        for (int j = l; j <= r; j++) {
            for (int k = j + 1; k <= r; k++) {
                Vector tmp = Vector(p[j].x - p[k].x, p[j].y - p[k].y);
                tmp = Vector(tmp.y, -tmp.x);
                if (tmp.y == 0) ins.push_back({j, k, Vector(-abs(tmp.x), tmp.y)});
                else ins.push_back({j, k, tmp}), ins.push_back({j, k, Vector(-tmp.x, -tmp.y)});
            }
        }
        sort(ins.begin(), ins.end(), [&](const Insect &A, const Insect &B) {
            if (A.vec == B.vec) {
                int xa1 = min(p[A.v].x, p[A.u].x), xa2 = max(p[A.v].x, p[A.u].x), xb1 = min(p[B.u].x, p[B.v].x), xb2 = max(p[B.u].x, p[B.v].x);
                int ya1 = min(p[A.v].y, p[A.u].y), ya2 = max(p[A.v].y, p[A.u].y), yb1 = min(p[B.u].y, p[B.v].y), yb2 = max(p[B.u].y, p[B.v].y);
                if (xa1 == xa2) return pii(ya1, ya2) < pii(yb1, yb2);
                return pii(xa1, xa2) < pii(xb1, xb2);
            } else return A.vec < B.vec;
        });
        // for (auto v : ins) {
        //     cerr << v.u << ' ' << v.v << ' ' << v.vec.x << ' ' << v.vec.y << endl;
        // }

        for (int j = l; j <= r; j++) id[j] = j;
        sort(id + l, id + r + 1, [&](const int &A, const int &B) { return p[A].x == p[B].x ? p[A].y < p[B].y : p[A].x < p[B].x; });
            // for (int k = l; k <= r; k++) cerr << id[k] << ' ';
            // cerr << endl;
        memset(tre, 0, sizeof tre);
        for (int j = l; j <= r; j++) idp[id[j]] = j, upd(j - l + 1, p[id[j]].h);
        int now = 0;
        for (int j = 1; j <= tm; j++) {
            // opts.clear();
            while (now < ins.size() && ins[now].vec < Vector(L[j].a, L[j].b)) {
                // opts.emplace_back();
                assert(abs(idp[ins[now].u] - idp[ins[now].v]) == 1);
                upd(idp[ins[now].u] - l + 1, p[ins[now].v].h - p[ins[now].u].h);
                upd(idp[ins[now].v] - l + 1, p[ins[now].u].h - p[ins[now].v].h);
                swap(idp[ins[now].u], idp[ins[now].v]); swap(id[idp[ins[now].u]], id[idp[ins[now].v]]);
                now++;
            }
            // for (int k = l; k <= r; k++) cerr << id[k] << ' ';
            // cerr << endl;
            int tl = l, tr = r;
            while (tl <= tr) {
                int mid = (tl + tr) >> 1;
                if ((LL)L[j].a * p[id[mid]].x + (LL)L[j].b * p[id[mid]].y < (LL)L[j].c) tl = mid + 1;
                else tr = mid - 1;
            }
            Ans[L[j].id] += query(tr - l + 1);
        }
    }
    for (int i = 1; i <= m; i++) printf("%lld\n", Ans[i]);
    return 0;
}
```

---

## 作者：ez_lcw (赞：4)

我们可以把一块巧克力看做平面上的点$(x,y)$

那么显然，对于一次询问$(a,b)$，我们可以用$x_{max}$或$x_{min}$，以及$y_{max}$或$y_{min}$来求出$ax+by$的最大值（这显然是一个单调函数）。

所以我们考虑用$kd-tree$来维护这个东东。

对于$kd-tree$中当前节点$u$的$max(ax+by)$，分情况讨论一下：

1. 若$a>0$，则$max(ax)=a*x_{max}$，否则$max(ax)=a*x_{min}$。
2. 若$b>0$，则$max(by)=b*y_{max}$，否则$max(by)=b*y_{min}$。

那么$max(ax+by)$就为$max(ax)+max(by)$了。

同理，我们也可以求出$min(ax+by)$。

那么对于当前节点，如果$c \leq min(ax+by)$，我们就return。

如果$max(ax+by)<c$，我们就返回当前整棵子树的答案。

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 50010
#define ll long long
#define lc t[u].ch[0]
#define rc t[u].ch[1]

using namespace std;

struct Point
{
	ll num[2],val;
	Point(){};
	Point(ll x,ll y,ll h){num[0]=x,num[1]=y,val=h;}
}p[N];

struct kd_tree
{
	int ch[2],size;
	ll maxn[2],minn[2],sum;
	Point x;
}t[N];

const double alpha=0.75;

int n,m,tot,root;
int top,rubbish[N];
int cnt;

bool cmp0(Point a,Point b)
{
	return a.num[0]<b.num[0];
}

bool cmp1(Point a,Point b)
{
	return a.num[1]<b.num[1];
}

int newnode()
{
	if(top) return rubbish[top--];
	return ++tot;
}

void up(int u)
{
	for(int i=0;i<2;i++)
	{
		t[u].minn[i]=t[u].maxn[i]=t[u].x.num[i];
		if(lc)
		{
			t[u].minn[i]=min(t[u].minn[i],t[lc].minn[i]);
			t[u].maxn[i]=max(t[u].maxn[i],t[lc].maxn[i]);
		}
		if(rc)
		{
			t[u].minn[i]=min(t[u].minn[i],t[rc].minn[i]);
			t[u].maxn[i]=max(t[u].maxn[i],t[rc].maxn[i]);
		}
	}
	t[u].size=t[lc].size+t[rc].size+1;
	t[u].sum=t[lc].sum+t[rc].sum+t[u].x.val;
}

void slap(int u)
{
	if(!u) return;
	p[++cnt]=t[u].x;
	rubbish[++top]=u;
	slap(lc);
	slap(rc);
}

int rebuild(int l,int r,bool d)
{
	if(l>r) return 0;
	int mid=(l+r)>>1,u=newnode();
	nth_element(p+l,p+mid,p+r+1,d?cmp1:cmp0);
	t[u].x=p[mid];
	lc=rebuild(l,mid-1,d^1);
	rc=rebuild(mid+1,r,d^1);
	up(u);
	return u;
}

void check(int &u,bool d)
{
	if(t[lc].size>t[u].size*alpha||t[rc].size>t[u].size*alpha)
	{
		cnt=0;
		slap(u);
		u=rebuild(1,t[u].size,d);
	}
}

ll query(int u,ll a,ll b,ll c)
{
	if(!u) return 0;
	ll maxx=t[u].maxn[0]*a,minx=t[u].minn[0]*a;
	ll maxy=t[u].maxn[1]*b,miny=t[u].minn[1]*b;
	if(a<0)swap(maxx,minx);
	if(b<0)swap(maxy,miny);
	if(minx+miny>=c) return 0;
	if(maxx+maxy<c) return t[u].sum;
	ll ans=0;
	if(t[u].x.num[0]*a+t[u].x.num[1]*b<c) ans+=t[u].x.val;
	ans+=query(lc,a,b,c)+query(rc,a,b,c);
	return ans;
}

inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		p[i].num[0]=read(),p[i].num[1]=read(),p[i].val=read();
	root=rebuild(1,n,0);
	while(m--)
	{
		ll a=read(),b=read(),c=read();
		printf("%lld\n",query(root,a,b,c));
	}
	return 0;
}
/*
3 3
1 2 5
3 1 4
2 2 1
2 1 6
1 3 5
1 3 7
*/
```



---

## 作者：1saunoya (赞：3)

**KD-Tree** 的板子题

[KD-Tree 学习笔记](https://www.cnblogs.com/Isaunoya/p/12243739.html)

- 考虑到 $ax + by < c$ 只要对横纵坐标下手，无脑查询就可以了

- 因为这是个一次函数，都可能为负数，所以需要四个点

- 对矩形的四个点依次查询，如果都不满足条件，矩形内的也不会满足条件，也是因为一次函数的原因。

- 然后 KD-Tree 无脑查询就完事了

```cpp
// powered by c++11
// by Isaunoya

#include<bits/stdc++.h>
#define rep(i , x , y) for(register int i = (x) ; i < (y) ; i ++)
using namespace std ;
using db = double ;
using ll = long long ;
using uint = unsigned int ;
#define int long long
using pii = pair < int , int > ;
#define ve vector
#define Tp template
#define all(v) v.begin() , v.end()
#define sz(v) ((int)v.size())
#define pb emplace_back
#define fir first
#define sec second

// the cmin && cmax
Tp < class T > void cmax(T & x , const T & y) {
	if(x < y) x = y ;
}
Tp < class T > void cmin(T & x , const T & y) {
	if(x > y ) x = y ;
}

// sort , unique , reverse
Tp < class T > void sort(ve < T > & v) {
	sort(all(v)) ;
}
Tp < class T > void unique(ve < T > & v) {
	sort(all(v)) ;
	v.erase(unique(all(v)) , v.end()) ;
}
Tp < class T > void reverse(ve < T > & v) {
	reverse(all(v)) ;
}

int n , m , now = 0 ;
struct node {
	int d[2] , ls , rs , val , sum ;
	int mx[2] , mn[2] ;
	bool operator < (const node & other) const {
		return d[now] < other.d[now] ;
	}
} ;
const int maxn = 5e4 + 10 ;
node data[maxn] , qwq[maxn] ;
void pushup(int o) {
	int ls = qwq[o].ls , rs = qwq[o].rs ;
	for(int i = 0 ; i < 2 ; i ++) {
		qwq[o].mx[i] = qwq[o].mn[i] = qwq[o].d[i] ;
		if(ls) {
			cmin(qwq[o].mn[i] , qwq[ls].mn[i]) ;
			cmax(qwq[o].mx[i] , qwq[ls].mx[i]) ;
		}
		if(rs) {
			cmin(qwq[o].mn[i] , qwq[rs].mn[i]) ;
			cmax(qwq[o].mx[i] , qwq[rs].mx[i]) ;
		}
	}
	qwq[o].sum = qwq[o].val ;
	if(ls) qwq[o].sum += qwq[ls].sum ;
	if(rs) qwq[o].sum += qwq[rs].sum ;
}
int build(int l , int r , int p) {
	now = p ;
	int mid = l + r >> 1 ;
	nth_element(data + l , data + mid , data + r + 1) ;
	qwq[mid] = data[mid] ;
	if(l < mid) qwq[mid].ls = build(l , mid - 1 , p ^ 1) ;
	if(r > mid) qwq[mid].rs = build(mid + 1 , r , p ^ 1) ;
	pushup(mid) ; return mid ;
}
int a , b , c ;
int chk(int x , int y) { return x * a + y * b < c ; }
int qry(int p) {
	int cnt = 0 ;
	cnt += chk(qwq[p].mn[0] , qwq[p].mn[1]) ;
	cnt += chk(qwq[p].mn[0] , qwq[p].mx[1]) ;
	cnt += chk(qwq[p].mx[0] , qwq[p].mn[1]) ;
	cnt += chk(qwq[p].mx[0] , qwq[p].mx[1]) ;
	if(cnt == 4) return qwq[p].sum ;
	if(! cnt) return 0 ;
	int res = 0 ;
	if(chk(qwq[p].d[0] , qwq[p].d[1])) res += qwq[p].val ;
	if(qwq[p].ls) res += qry(qwq[p].ls) ;
	if(qwq[p].rs) res += qry(qwq[p].rs) ;
	return res ;
}

int rt = 0 ;
signed main() {
	ios_base :: sync_with_stdio(false) ;
	cin.tie(nullptr) , cout.tie(nullptr) ;
// code begin.
	cin >> n >> m ;
	for(int i = 1 ; i <= n ; i ++) {
		cin >> data[i].d[0] >> data[i].d[1] >> data[i].val ;
	}
	rt = build(1 , n , 0) ;
	for(int i = 1 ; i <= m ; i ++) {
		cin >> a >> b >> c ;
		cout << qry(rt) << '\n' ;
	}
	return 0 ;
// code end.
}
```

---

## 作者：gyyyyx (赞：2)

K-D Tree 入门题

首先我们知道，对于一个询问，我们要求的是 $\sum\limits_{ax_i+by_i<c}h_i$。

对于限制 $ax+by<c$，我们可以转换一下形式：$y<\frac{c-ax}{b}$，当然，这只是 $b>0$ 的情况。

显然我们要求的就是 $y=-\frac{a}{b}x+\frac{c}{b}$ 这条直线下方的点权和。

同理，其它情况也是要求一条直线某一侧的点权和。

可以建出一棵 K-D Tree，对于一个节点，若包含其子树中所有点的最小矩形的四个顶点均满足 $ax+by<c$，则说明这个矩形中所有点都是满足条件的。

维护子树的点权和即可。

由于数据随机，不用担心 K-D Tree 会被卡。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 50005
using namespace std;
int n,m;
struct Point{int pos[2],h;} p[N];
int ls[N],rs[N],lp[N][2],rp[N][2];LL sum[N];
int rt,x,split[20];
inline bool cmp(const Point&a,const Point&b){
	return a.pos[x]<b.pos[x];
}
inline void pushup(int k){
	for(int j(0);j<=1;++j){
		lp[k][j]=rp[k][j]=p[k].pos[j];
		if(ls[k]){
			lp[k][j]=min(lp[k][j],lp[ls[k]][j]);
			rp[k][j]=max(rp[k][j],rp[ls[k]][j]);
		}
		if(rs[k]){
			lp[k][j]=min(lp[k][j],lp[rs[k]][j]);
			rp[k][j]=max(rp[k][j],rp[rs[k]][j]);
		}
	}
	sum[k]=sum[ls[k]]+sum[rs[k]]+p[k].h;
}
int Build(int l,int r,int dep){
	if(l>r) return 0;
	if(l==r) return pushup(l),l;
	double mx(-1);
	for(int j(0);j<=1;++j){
		double ave(0),sum(0); 
		for(int i(l);i<=r;++i) ave+=p[i].pos[j];
		ave/=(r-l+1);
		for(int i(l);i<=r;++i) sum+=pow(p[i].pos[j]-ave,2); 
		if(sum>mx) mx=sum,x=j;
	}
	split[dep]=x;
	int mid(l+r>>1);
	nth_element(p+l,p+mid,p+r+1,cmp);
	ls[mid]=Build(l,mid-1,dep+1);
	rs[mid]=Build(mid+1,r,dep+1);
	return pushup(mid),mid;
}
inline bool Check(int x,int y,int a,int b,int c){return 1ll*a*x+1ll*b*y<c;}
LL Query(int k,int a,int b,int c){
	int tmp(0);
	tmp+=Check(lp[k][0],lp[k][1],a,b,c);
	tmp+=Check(lp[k][0],rp[k][1],a,b,c);
	tmp+=Check(rp[k][0],lp[k][1],a,b,c);
	tmp+=Check(rp[k][0],rp[k][1],a,b,c);
	if(!tmp) return 0;
	if(tmp==4) return sum[k];
	LL res(Check(p[k].pos[0],p[k].pos[1],a,b,c)?p[k].h:0);
	if(ls[k]) res+=Query(ls[k],a,b,c);
	if(rs[k]) res+=Query(rs[k],a,b,c);
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i(1);i<=n;++i) scanf("%d%d%d",&p[i].pos[0],&p[i].pos[1],&p[i].h);
	rt=Build(1,n,0);
	while(m--){
		int a,b,c;scanf("%d%d%d",&a,&b,&c);
		printf("%lld\n",Query(rt,a,b,c));
	}
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：2)

lxl 讲课时给了一种简单做法，记录下来。

不难发现题意就是半平面数点。

在保证数据随机的前提下有不使用 KD-tree 的简单 $O((n+q) \sqrt n)$ 做法。

对平面分块，具体而言，将点按照 $x$ 轴坐标排序后每 $\sqrt n$ 个点的 $x$ 坐标区间分为一块，再对 $y$ 轴做同样的操作。

得到的平面划分如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/3280due0.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

不难发现划分平面的一次函数穿过了 $O(\sqrt n)$ 个块即包含了 $O(\sqrt n)$ 个残块，由于一共分了 $\sqrt n \times \sqrt n = n$ 块所以期望意义下每个块内的点是 $O(1)$ 个，因此残块就 $O(\sqrt n)$ 暴力即可。

对于整块，不难发现对于每一行都是一个区间，前缀和预处理完后直接扫即可。

时间复杂度 $O((n+q) \sqrt n)$，非常简单。

另外，保证数据随机下可以做到同时间复杂度带修改，每次插入一个点时暴力重构所在行前缀和即可，也是单次 $O(\sqrt n)$ 的。

---

## 作者：Rainsleep (赞：2)

K-D Tree 模板题（），一遍过。

将每一块巧克力的 $x, y$ 转化为平面上的点，问题变为求平面上满足 $ax+  by < c$ 的点的点权和，这个东西直接上 K-D Tree 维护就行了。

考虑保证复杂度的剪枝，我们在 K-D Tree 的每一颗子树里记录一下当前矩形四个方向上坐标的最大值，之后如果全部满足，直接返回当前子树内权值和；若一个都没满足，说明完全不可取，直接返回。剩下的情况判断下当前点是否可行直接递归处理左右子树即可，记得开 long long。

代码：
```cpp
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast", "inline", "-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
const int N = 5e4 + 10;
struct Node
{
    int L, R, D, U, s[2]; LL sum;
} tr[N];
struct Opt
{
    int x, y, v;
} s[N];
int n, m, rt;

inline bool cmp1(Opt A, Opt B)
{
    return A.x < B.x;
}

inline bool cmp2(Opt A, Opt B)
{
    return A.y < B.y;
}

inline void pushup(int x)
{
    Node &root = tr[x], l = tr[root.s[0]], r = tr[root.s[1]];
    root.R = root.L = s[x].x, root.D = root.U = s[x].y, root.sum = l.sum + r.sum + s[x].v;
    if(root.s[0]) 
        root.U = max(root.U, l.U), root.D = min(root.D, l.D),
        root.R = max(root.R, l.R), root.L = min(root.L, l.L);
    if(root.s[1])   
        root.U = max(root.U, r.U), root.D = min(root.D, r.D),
        root.R = max(root.R, r.R), root.L = min(root.L, r.L);
    return ;
}

inline int build(int l, int r)
{
    if(l > r) return 0;
    int mid = l + r >> 1;
    double vax = 0.00, vay = 0.00, avx = 0.00, avy = 0.00;
    for(int i(l); i <= r; ++ i) avx += s[i].x, avy += s[i].y;
    avx /= (r - l + 1), avy /= (r - l + 1);
    for(int i(l); i <= r; ++ i) vax += (avx - s[i].x) * (avx - s[i].x), vay += (avy - s[i].y) * (avy - s[i].y);
    if(vax >= vay) nth_element(s + l, s + mid, s + r + 1, cmp1);
    else nth_element(s + l, s + mid, s + r + 1, cmp2);
    tr[mid].s[0] = build(l, mid - 1), tr[mid].s[1] = build(mid + 1, r), pushup(mid);
    return mid;
}

inline bool check(int a, int b, int c, int x, int y)
{
    return a * x + b * y < c;
}

inline LL query(int x, int a, int b, int c)
{
    int cnt = check(a, b, c, tr[x].R, tr[x].U) + 
              check(a, b, c, tr[x].R, tr[x].D) + 
              check(a, b, c, tr[x].L, tr[x].U) + 
              check(a, b, c, tr[x].L, tr[x].D); LL ret = 0;
    if(cnt == 4) return tr[x].sum;
    if(cnt == 0) return 0ll;
    if(check(a, b, c, s[x].x, s[x].y)) ret += (LL)s[x].v;
    return query(tr[x].s[0], a, b, c) + query(tr[x].s[1], a, b, c) + ret;
    
}

int main()
{
    scanf("%d %d", &n, &m);
    for(int i(1); i <= n; ++ i) scanf("%d %d %d", &s[i].x, &s[i].y, &s[i].v);
    rt = build(1, n);
    for(int a, b, c; m --; )
    {
        scanf("%d %d %d", &a, &b, &c);
        printf("%lld\n", query(rt, a, b, c));
    }
    return 0;
}
```

---

## 作者：ATHOSD (赞：2)

有了KDtree+线段树区间查询的基础这题就很好做了。

首先用KDtree维护矩阵内的权值总和以及分裂点权值，之后在查询的时候把矩阵的四个点都check一遍，

如果都满足就直接加上总权值，如果都不满足就return，否则check分裂点更新答案之后递归左右分裂区间。

这道题做了1个多小时，当时主要卡到了矩阵四个点的check上，而我想的是只枚举两个端点但需要大量的分类讨论，而且y==0的情况需要用前缀和特殊处理
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<string>
#include<cstring>
#include<map>
#define int long long
#define max(a,b) (a>b?a:b)
#define min(a,b) (a>b?b:a)
#define m(a) memset(a,0,sizeof(a))
#define AA cout<<"Alita"<<endl
using namespace std;
const int N=5e4+10;
int size,ans,n,m,now;
struct point
{
        int x[2],w;
        int dis(point &b)
        {
                return abs(x[0]-b.x[0])+abs(x[1]-b.x[1]);
        }
        
}s[N];
bool comp(point a,point b)
{
        return a.x[now]<b.x[now];
}
struct KDtree
{
        KDtree *ch[2];
        int mn[2],mx[2],sum;
        point p;
        void init(point g)
        {
                ch[0]=ch[1]=NULL;
                sum=g.w;
                p=g;
                mn[0]=mx[0]=g.x[0];
                mn[1]=mx[1]=g.x[1];
        }
        void update(KDtree *k)
        {
                sum+=k->sum;
                mn[0]=min(mn[0],k->mn[0]);
                mx[0]=max(mx[0],k->mx[0]);
                mn[1]=min(mn[1],k->mn[1]);
                mx[1]=max(mx[1],k->mx[1]);
        }
        void pushup()
        {
                if(ch[0]!=NULL) update(ch[0]);
                if(ch[1]!=NULL) update(ch[1]);
        }
        
}*root,a[N];
void build(KDtree *& k,int l,int r,int typ)
{
        if(l>r) return;
        k=a+(size++);
        int mid=(l+r)>>1;
        now=typ;
        nth_element(s+l,s+mid,s+r+1,comp);
        k->init(s[mid]);
        build(k->ch[0],l,mid-1,typ^1);
        build(k->ch[1],mid+1,r,typ^1);
        k->pushup();
}
bool check(int x,int y,int A,int B,int C)
{
        if(x*A+y*B<C) return true;
        return false;
}
void query(KDtree *k,int x,int y,int z)
{
        if(k==NULL) return;
        if(!check(k->mn[0],k->mn[1],x,y,z)&&
           !check(k->mn[0],k->mx[1],x,y,z)&&
           !check(k->mx[0],k->mn[1],x,y,z)&&
           !check(k->mx[0],k->mx[1],x,y,z)) return;
        if(check(k->mn[0],k->mn[1],x,y,z)&&
           check(k->mn[0],k->mx[1],x,y,z)&&
           check(k->mx[0],k->mn[1],x,y,z)&&
           check(k->mx[0],k->mx[1],x,y,z))
        {
                ans+=k->sum;
                return;
        }
        if(k->p.x[0]*x+k->p.x[1]*y<z) ans+=k->p.w;
        if(k->ch[0]!=NULL) query(k->ch[0],x,y,z);
        if(k->ch[1]!=NULL) query(k->ch[1],x,y,z);
}
signed main()
{
        //freopen("1.in","r",stdin);
        //freopen("1.out","w",stdout);
        scanf("%lld%lld",&n,&m);
        for(int i=1;i<=n;i++)
        {
                scanf("%lld%lld%lld",&s[i].x[0],&s[i].x[1],&s[i].w);
        }
        build(root,1,n,0);
        for(int i=1,x,y,z;i<=m;i++)
        {
                ans=0;
                scanf("%lld%lld%lld",&x,&y,&z);
                query(root,x,y,z);
                printf("%lld\n",ans);
        }
        return 0;
}
```


---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

首先，不难想到其实每个人可接受的区间都是一个半平面，而只有分散在这个半平面内的才能被接受。

其实直接维护半平面并不好整，但是如果我们可以尽可能将完全在半平面的部分分成尽可能少的可统计部分的话，那时间复杂度就能降下来。

而显然，一个 $k=2$ 的 KD\_tree 就比较满足要求。

KD\_tree 中的每一个节点对应一个大的矩形区间。又因为可接受的区间都是一个半平面，所以如果这个矩形端点全部都在半平面中，那这个矩形也全部都在。反之亦然。

虽然这样其实并没有时间复杂度保证，可以退化到 $n^2$，但是，题面曾经说过：

> 保证数据用某种方式随机生成。

那就随便玩了。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, m, a, b, c;
inline void tmin(int& l, const int r) { (l > r) && (l = r); }
inline void tmax(int& l, const int r) { (l < r) && (l = r); }
using ini = initializer_list<int>;
template<const int wd>
struct pos {
	int p[wd];
	pos<wd>() { memset(p, 0, sizeof p); }
	pos<wd>(ini pv) {
		memcpy(p, pv.begin(), pv.size() << 3);
	}
	inline bool operator<(const pos<wd>& r) const {
		for (int i = 0;i != wd;++i)
			if (p[i] != r.p[i]) return p[i] < r.p[i];
		return 1;
	}
	inline bool operator==(const pos<wd>& r) const {
		for (int i = 0;i != wd;++i)
			if (p[i] != r.p[i]) return 0;
		return 1;
	}
};
template<const int wd>
inline bool ninter(const pos<wd>& alu, const pos<wd>& ard, const pos<wd>& blu, const pos<wd>& brd) {
	for (int i = 0;i != wd;++i) 
		if (blu.p[i] > ard.p[i] || alu.p[i] > brd.p[i]) return 1;
	return 0;
}
template<const int wd>
inline bool finter(const pos<wd>& alu, const pos<wd>& ard, const pos<wd>& blu, const pos<wd>& brd) {
	for (int i = 0;i != wd;++i)
		if (blu.p[i] < alu.p[i] || brd.p[i] > ard.p[i]) return 0;
	return 1;
}
template<const int wd>
class kdtree {
	struct node {
		pos<wd> np, lu, rd;
		int ls, rs, v, sm, f;
		node() :ls(0), rs(0), v(0), sm(0), f(0) {};
	}re[50005];
	int rt[50]; stack<int>ps;
	vector<pair<pos<wd>, int>>mt;
	inline void ret(int p) { ps.emplace(p); }
	inline int get() {
		int p = ps.top(); ps.pop();
		memset(&re[p], 0, sizeof(re[p]));
		return p;
	}
	inline void pup(int p) {
		re[p].sm = re[re[p].ls].sm + re[re[p].rs].sm + re[p].v;
		re[p].lu = re[p].rd = re[p].np;
		for (int i = 0;i != wd;++i) {
			if (re[p].ls)
				tmin(re[p].lu.p[i], re[re[p].ls].lu.p[i]),
				tmax(re[p].rd.p[i], re[re[p].ls].rd.p[i]);
			if (re[p].rs)
				tmin(re[p].lu.p[i], re[re[p].rs].lu.p[i]),
				tmax(re[p].rd.p[i], re[re[p].rs].rd.p[i]);
		}
	}
	inline void getall(int p) {
		mt.emplace_back(re[p].np, re[p].v);
		if (re[p].ls) getall(re[p].ls);
		if (re[p].rs) getall(re[p].rs);
		ret(p);
	}
	inline int build(int l, int r, int cf) {
		if (l > r) return 0;
		int p = get();
		if (l == r) {
			re[p].np = mt[l].first;
			re[p].v = mt[l].second;
			re[p].f = cf;
			pup(p); return p;
		}
		int md = l + r >> 1;
		nth_element(mt.begin() + l, mt.begin() + md, mt.begin() + r + 1,
			[&](const pair<pos<wd>, int>& l, const pair<pos<wd>, int>& r) {
				return l.first.p[cf] < r.first.p[cf];
			});
		re[p].np = mt[md].first;
		re[p].v = mt[md].second;
		re[p].f = cf; cf = (cf + 1) % wd;
		re[p].ls = build(l, md - 1, cf);
		re[p].rs = build(md + 1, r, cf);
		pup(p); return p;
	}
	inline bool check(int x, int y) {
		return (long long)a * x + (long long)b * y < c;
	}
	inline int que(int p) {
		if (!p) return 0;
		int cn = 0, ret = 0;
		cn += check(re[p].lu.p[0], re[p].lu.p[1]);
		cn += check(re[p].rd.p[0], re[p].lu.p[1]);
		cn += check(re[p].rd.p[0], re[p].rd.p[1]);
		cn += check(re[p].lu.p[0], re[p].rd.p[1]);
		if (!cn) return 0;
		if (cn == 4) return re[p].sm;
		if (check(re[p].np.p[0], re[p].np.p[1])) ret += re[p].v;
		ret += que(re[p].ls); ret += que(re[p].rs);
		return ret;
	}
public:
	inline void init() {
		memset(rt, 0, sizeof rt);
		for (int i = 50000;i;i--) ret(i);
	}
	inline void add(int x, int y, int v) {
		int lp = 0; mt.emplace_back(ini{ x, y }, v);
		while (rt[lp]) getall(rt[lp]), rt[lp] = 0, lp++;
		sort(mt.begin(), mt.end());
		int j = -1;
		for (int i = 0;i != mt.size();++i)
			if (j != -1 && mt[i].first == mt[j].first)
				mt[j].second += mt[i].second;
			else mt[++j] = mt[i];
		rt[lp] = build(0, j, 0); mt.clear();
	}
	inline int que() {
		int ret = 0;
		for (int i = 0;i != 30;++i)
			ret += que(rt[i]);
		return ret;
	}
}; kdtree<2>kdt;
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m; kdt.init();
	for (int i = 1;i <= n;++i)
		cin >> a >> b >> c, kdt.add(a, b, c);
	for (int i = 1;i <= m;++i)
		cin >> a >> b >> c, cout << kdt.que() << endl;
}
```

---

## 作者：ivyjiao (赞：0)

KDT 简单题。

输入的每块巧克力就是一个点，查询就是看一棵子树内 $(l,r),(u,d)$ 两两配对 check，如果全合法（$<c$），那么返回 $sum$，都不满足，返回 $0$，否则递归左右子树（如果有的话）。

数据范围很小，交替分割法不比方差分割法慢多少的。

记得开 long long。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=50001;
int n,m,a,b,c,rt,g[N];
struct KDT{
    int l,r,u,d,b,ls,rs,x,y,v;
	#define ls t[u].ls
	#define rs t[u].rs
}t[N];
void up(int u){
    t[u].b=t[ls].b+t[rs].b+t[u].v;
    t[u].l=t[u].r=t[u].x;
    t[u].u=t[u].d=t[u].y;
    if(ls){
        t[u].l=min(t[u].l,t[ls].l);
        t[u].d=min(t[u].d,t[ls].d);
        t[u].r=max(t[u].r,t[ls].r);
        t[u].u=max(t[u].u,t[ls].u);
    }
    if(rs){
        t[u].l=min(t[u].l,t[rs].l);
        t[u].d=min(t[u].d,t[rs].d);
        t[u].r=max(t[u].r,t[rs].r);
        t[u].u=max(t[u].u,t[rs].u);
    }
}
bool cmpx(int x,int y){
	return t[x].x<t[y].x;
}
bool cmpy(int x,int y){
	return t[x].y<t[y].y;
}
int build(int u,int l,int r,bool p){
    if(l>r) return 0;
    int mid=l+r>>1;
    if(p) nth_element(g+l,g+mid,g+r+1,cmpx);
    else nth_element(g+l,g+mid,g+r+1,cmpy);
    u=g[mid];
    ls=build(ls,l,mid-1,!p);
    rs=build(rs,mid+1,r,!p);
    up(u);
    return u;
}
bool check(int x,int y){
    return x*a+y*b<c;
}
int qsum(int u){
	int sum=0;
	sum+=check(t[u].l,t[u].u);
	sum+=check(t[u].l,t[u].d);
	sum+=check(t[u].r,t[u].u);
	sum+=check(t[u].r,t[u].d);
	if(sum==4) return t[u].b;
	if(!sum) return 0;
	int ans=0;
	if(check(t[u].x,t[u].y)) ans+=t[u].v;
	if(ls) ans+=qsum(ls);
	if(rs) ans+=qsum(rs);
	return ans;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>t[i].x>>t[i].y>>t[i].v,g[i]=i;
    rt=build(rt,1,n,1);
    while(m--){
        cin>>a>>b>>c;
        cout<<qsum(rt)<<endl;
    }
}
```

---


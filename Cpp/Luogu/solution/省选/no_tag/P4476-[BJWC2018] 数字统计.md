# [BJWC2018] 数字统计

## 题目描述

小A 正在研究一些数字统计问题。有一天他突然看到了一个这样的问题：

将[L..R]中的所有整数用M 位二进制数表示（允许出现前导0）。现在将这些数中的每一个作如下变换：

从这个数的最低两位开始，如果这两位都是0，那么X=1，否则X=0。现在将这两位删去，然后将X 放在原来最低位的位置上。重复这个变换直到这个数只剩下一位为止。

例如01001 的变换过程如下：

01001-->0100-->011-->00-->1。

现在的问题是变换后的所有数中，值为Y（Y 为0 或1）的有多少个？

小A 不会了，他想让你帮助他完成这个问题。

## 说明/提示

对于20%的数据：1 ≤ M ≤ 16。

对于40%的数据：1 ≤ M ≤ 32。

对于100%的数据：1 ≤ M ≤ 200，1 ≤ T ≤ 50。

## 样例 #1

### 输入

```
1
3 1
001 101```

### 输出

```
11```

# 题解

## 作者：Leianha (赞：4)

## 高精度&找规律

~~今天模拟赛第一题，结果被狂虐。~~ 很明显的打表找规律的题。（数位DP？不存在的）我们珂以用我们的暴力程序来观察一下。我们设f（x）为二进制数x经过一系类变换后得到的结果，就会发现f(i)是成片分布的。

举个栗子：

0000--->1

0001--->0

0010--->0

0011--->0

0100--->1

0101--->1

......

我们还可以发现后面相同的f(i)的长度为$2^k $（k不定），所以我们就能够在$O(len)$的时间复杂度内得到 f（i）为1的个数。又因为当n奇偶性不同的时候f答案也不相同，分别考虑一下就珂以啦。

```cpp
gj work(gj x)
{
	if(x<gj(4))return gj(1);
	gj l=gj(4) , r=Min(x,gj(7)) , res=gj(1);int opt=1;
	for( ; ;l=r+gj(1) , r=Min(r*gj(2)+gj(1),x) , opt^=1)
	{
		if(opt)res=res+(r-l+gj(1));
		if(r==x)break;
	}
	return res;
}
```

另外因为答案特别大，所以我们需要写高精度，并且还要转化为为二进制。

```cpp
void shuchu(gj x)
{
	if(!x.len)return (void)printf("0");
	gj lin=gj(1);
	while(lin<=x)lin=lin*gj(2);
	lin=lin/2;
	for(;;lin=lin/2)
	{
		if(lin<=x)
		{
			printf("1");
			x=x-lin;
		}
		else printf("0");
		if(lin==gj(1))break;
	}
}
```

最后献上我~~丑陋~~的代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int T,n,Q,ans;
char ch[205];
struct gj
{
    int len;
    int v[1000];
    gj(){len=0;memset(v,0,sizeof(v));}
    gj(int x)
    {
        len=0;memset(v,0,sizeof(v));
        while(x)
        {
            v[++len]=x%10;
            x/=10;
        }
    }
    friend bool operator <(const gj &a,const gj &b)
    {
        if(a.len<b.len)return 1;
        if(a.len>b.len)return 0;
        for(int i=a.len;i>=1;--i)
        {
            if(a.v[i]<b.v[i])return 1;
            if(a.v[i]>b.v[i])return 0;
        }
        return 0;
    }
    friend bool operator ==(const gj &a,const gj &b)
    {
        if(a.len!=b.len)return 0;
        for(int i=a.len;i>=1;--i)
        {
            if(a.v[i]!=b.v[i])return 0;
        }
        return 1;
    }
    friend bool operator <=(const gj &a,const gj &b)
    {
        if(a<b)return 1;
        else if(a==b)return 1;
        else return 0;
    }
    friend bool operator !=(const gj &a,const gj &b)
    {
        if(a.len!=b.len)return 1;
        for(int i=a.len;i>=1;--i)
        {
            if(a.v[i]!=b.v[i])return 1;
        }
        return 0;
    }
}x,y,res;
gj operator +(gj a,gj b)
{
    int len=a.len+b.len;
    gj c;
    c.len=len;
    for(int i=1;i<=len;++i)c.v[i]=a.v[i]+b.v[i];
    for(int i=1;i<=len;++i)
    {
        if(c.v[i]>=10)
        {
            ++c.v[i+1];
            c.v[i]-=10;
        }
    }
    while(c.len&&!c.v[c.len])c.len--;
    return c;
}
gj operator -(gj a,gj b)
{
    int len=max(a.len,b.len);
    gj c;
    for(int i=1;i<=len;++i)c.v[i]=a.v[i]-b.v[i];
    c.len=len;
    for(int i=1;i<=c.len;++i)
    {
        if(c.v[i]<0)
        {
            c.v[i+1]--;
            c.v[i]+=10;
        }
    }
    while(c.len&&!c.v[c.len])c.len--;
    return c;
}
gj operator *(gj a,gj b)
{
    gj c;
    for(int i=1;i<=a.len;++i)
    for(int j=1;j<=b.len;++j)
    c.v[i+j-1]+=a.v[i]*b.v[j];
    c.len=a.len+b.len;
    for(int i=1;i<=c.len-1;++i)
    {
        if(c.v[i]>=10)
        {
            c.v[i+1]+=c.v[i]/10;
            c.v[i]%=10;
        }
    }
    while(c.v[c.len]==0&&c.len>1)--c.len;
    return c;
}
gj operator /(gj a,long long b)
{
    gj c;int d=0;
    for(int i=a.len;i>=1;--i)
    c.v[++c.len]=((d*10+a.v[i])/b),d=(d*10+a.v[i])%b;
    for(int i=1;i<=c.len/2;++i)swap(c.v[i],c.v[c.len-i+1]);
    while(c.v[c.len]==0&&c.len>1)--c.len;
    return c;
}
ostream& operator << (ostream &out,const gj &a) 
{
    if(!a.len)
    {
        cout<<"0";
        return out;
    }
    for(int i=a.len;i>=1;i--)printf("%d",a.v[i]);
    return out;
}
gj Min(gj a,gj b)
{
	if(a<b)return a;
	else return b;
}
gj work(gj x)
{
	if(x<gj(4))return gj(1);
	gj l=gj(4) , r=Min(x,gj(7)) , res=gj(1);int opt=1;
	for( ; ;l=r+gj(1) , r=Min(r*gj(2)+gj(1),x) , opt^=1)
	{
		if(opt)res=res+(r-l+gj(1));
		if(r==x)break;
	}
	return res;
}
void shuchu(gj x)
{
	if(!x.len)return (void)printf("0");
	gj lin=gj(1);
	while(lin<=x)lin=lin*gj(2);
	lin=lin/2;
	for(;;lin=lin/2)
	{
		if(lin<=x)
		{
			printf("1");
			x=x-lin;
		}
		else printf("0");
		if(lin==gj(1))break;
	}
}
void slove2()
{
	x=y=res=gj(0);
	scanf("%s",ch+1);
	for(int i=1;i<=n;++i)
	{
		x=x*2+gj(ch[i]-'0');
	}
	scanf("%s",ch+1);
	for(int i=1;i<=n;++i)
	{
		y=y*2+gj(ch[i]-'0');
	}
	res=work(y)-work(x-gj(1));
	if((n&1)==(Q&1))res=y-x+1-res;
	shuchu(res);puts("");
}
int main()
{
	cin>>T;
	while(T--)
	{
		scanf("%d%d",&n,&Q);
		slove2();
	}
	fclose(stdin);fclose(stdout);
	return 0;
}
```

---

## 作者：creation_hy (赞：0)

居然没多少人写题解。省流：水题，但是细节有亿点点多。

明显的数位 dp，但是注意是从后往前合，而不是从前往后。。而且要把 $0$ 算上去。

$f_{i,j}$ 表示把 $[i,n]$ 合出一个 $j$ 的方案数，然后写个二进制高精就好了。

转移的话，题目的操作其实就是 $x\operatorname{or}y$ 取反，所以是：

$f_{i,j} = \displaystyle\sum_{cur=0}^{lim}\sum_{k=0}^1f_{i+1,k}[cur\operatorname{or}k\ne j]$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 205;
int T, n, m, vis[N][2][2];
struct Int
{
    int a[N];
    inline Int() { memset(a, 0, sizeof(a)); }
    inline Int(int k)
    {
        for (int i = n; i; i--, k >>= 1)
            a[i] = k & 1;
    }
    inline int &operator[](const int &x) { return a[x]; }
    inline void operator+=(const Int &t)
    {
        for (int i = n; i; i--)
            if ((this->a[i] += t.a[i]) > 1)
                this->a[i] -= 2, this->a[i - 1]++;
    }
    inline void operator-=(const Int &t)
    {
        for (int i = n; i; i--)
            if ((this->a[i] -= t.a[i]) < 0)
                this->a[i] += 2, this->a[i - 1]--;
    }
    inline void print()
    {
        bool flag = 0;
        for (int i = 1; i <= n; i++)
            if (flag |= a[i])
                cout << a[i];
        if (!flag)
            cout << 0;
        cout << '\n';
    }
} f[N][2][2], a, L, R;
inline Int dfs(int x, int free, int k)
{
    int lim = free ? 1 : a[x];
    if (x == n)
        return k <= lim;
    if (vis[x][free][k])
        return f[x][free][k];
    Int res = 0;
    for (int i = 0; i <= lim; i++)
        for (int j = 0; j < 2; j++)
            if (!(i | j) == k)
                res += dfs(x + 1, free | i < lim, j);
    vis[x][free][k] = 1;
    return f[x][free][k] = res;
}
inline Int solve(Int arr)
{
    bool flag = 0;
    for (int i = 1; i <= n; i++)
        flag |= arr[i];
    if (!flag)
        return 0;
    a = arr;
    memset(vis, 0, sizeof(vis));
    memset(f, 0, sizeof(f));
    return dfs(1, 0, m);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> T;
    while (T--)
    {
        cin >> n >> m;
        char c;
        for (int i = 1; i <= n; i++)
            cin >> c, L[i] = c == '1';
        for (int i = 1; i <= n; i++)
            cin >> c, R[i] = c == '1';
        Int res = solve(R);
        L -= 1, res -= solve(L);
        res.print();
    }
    return 0;
}
```

---

## 作者：Zwaire (赞：0)

# P4476 [BJWC2018]数字统计

  考试的时候写了个数位 dp，很明显我斜挂了，于是 de 了 3 个小时之后有了这篇题解。。

（看到没有类似的题解，记忆化搜索来一发）

## 算法：

### 数位 dp + 高精度

## 题目描述：

对于一个特定的变换模式，对于变换之后的数为 0 或者为 1 的条件。

## 题目分析：

首先我们需要对于题目进行分析，因为我们首先看到这个题很不好做，所以我们先转化一下题意。

我们可以发现一个很好的性质，只要我们的确定这个数字中第一个 1 的位置在哪里，后面的数字是什么都与我们的答案没有关系了，以为我们的答案在第一个 1 这个位置一定会变成 0 ，然后我们只需要分析前面的 0 的个数的奇偶性就可以了。

于是我们成功地把题意转化成了找到第一个 1 的贡献。那么就很好做了。

那么我们找到了 1 的位置之后怎么进行计算贡献呢？

我们经过手玩之后可以发现下面的结论

```reStructuredText
如果全是 0，没有 1 的情况
那么如果前面 0 的个数为奇数，那么最后的返回值为 0
若为偶数，最后返回值为 1
对于有 1 的情况
前面的 0 的个数为奇数，最后返回值为 1
若为偶数，最后返回值为 0
```

但是对于一些情况需要特判，具体见代码的注释。

于是我们就可以做这个题了。

1、 首先数位 dp 的老套路，进行差分。

2、进行记忆化搜索，我们需要三个状态。当前的位置 pos，以及第一个 1 的位置 st（如果没有出现则为 0），当前的上限的限制 lim。

再套一下我们的板子，于是就可以得到核心的代码了。



```
il i64 dfs(int pos, int st, int lim) （i64 是高精）
{
	
	if(pos > len and st == 0)//如果说当前的全是0，需要把1位数的单独拿出来进行考虑，因为手玩一下发现并不满足那个性质
	{
		if(pos == 2) return q == 0 ? 1 : 0;
		if((pos - 1) % 2 == 1) return q == 0 ? 1 : 0;
		else return q == 1 ? 1 : 0;
	}
	if(pos > len and st)//对应统计答案，同样对于1在最后一位的情况需要单独拿出来考虑
	{
		if(st == pos - 1)
		{
			if((st - 1) % 2 == 0) return q == 1 ? 1 : 0;
			else return q == 0 ? 1 : 0;
		}
		if((st - 1) % 2 == 1) return q == 1 ? 1 : 0;
		else return q == 0 ? 1 : 0;
	}
	if(!lim and dp[pos][st] != -1) return dp[pos][st];
	i64 ret = 0;
	int res = lim ? a[len - pos + 1] : 1;
	for(int i = 0; i <= res; ++i)
	{              
		if(st == 0 and i == 0) //简单的分类讨论
		{
			i64 tmp = dfs(pos + 1, st, lim and i == res);
			ret += tmp;
		}
		else if(st == 0 and i == 1) 
		{
			i64 tmp = dfs(pos + 1, pos, lim and i == res);	
			ret += tmp;
		}
		else
		{
			i64 tmp = dfs(pos + 1, st, lim and i == res);
			ret += tmp;
		} 
	}
	if(!lim) dp[pos][st] = ret;
	return ret;
}
```

这就是这个题的核心了，之后比较恶心的就是高精了，整整卡了我 3 个小时，最后还是用 bitset 高精过掉了这个题。~~vector 高精巨慢~~

[Code](https://www.luogu.com.cn/paste/jdt71r83)

---

## 作者：Treaker (赞：0)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 数位DP + 高精

哪里会用到高精呢。。主要是存数。

这道题一看数据范围这么大,还是计数~~废话~~，自然想到数位DP。

那么我们设$f[i][0/1][0/1]$表示处理到第$i$位（从低位到高位），包括这一位以及之后的数变换成$0/1$，且目前与原数的大小关系，小的话是$1$。反之为$0$

转移方程如下： 应该很好理解
```cpp
for(int i = 1;i < n;i ++) for(int j = 0;j < 2;j ++) for(int k = 0;k < 2;k ++) for(int t = 0;t < 2;t ++) f[i+1][!j && !t][t == a[i+1] ? k : t < a[i+1]] += f[i][j][k];
```
完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int N = 205 , M = 7 , MAX = (1 << 30) - 1;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
char s[N];
int a[N];
int n , Q , T;
struct Bignum
{
	int x[M];
	Bignum() {for(int i = 0;i < M;i ++) x[i] = 0;}
	Bignum operator + (Bignum a)
	{
		Bignum c;
		for(int i = 0;i < M;i ++) c.x[i] = x[i] + a.x[i];
		for(int i = 0;i < M - 1;i ++) if(c.x[i] > MAX) c.x[i] -= MAX + 1 , c.x[i+1] ++;
		return c;
	}
	Bignum operator - (Bignum a)
	{
		Bignum c;
		for(int i = 0;i < M;i ++) c.x[i] = x[i] - a.x[i];
		for(int i = 0;i < M - 1;i ++) if(c.x[i] < 0) c.x[i] += MAX + 1 , c.x[i+1] --;
		return c;
	}
	inline void operator += (Bignum b) {*this = *this + b;}
	inline void operator -= (Bignum b) {*this = *this - b;}
	inline void print()
	{
		int i;
		for(i = N - 1;i >= 0;i --) if(x[i / 30] & (1 << (i % 30))) break;
		if(i < 0) printf("0");
		for(;i >= 0;i --) printf(x[i / 30] & (1 << (i % 30)) ? "1" : "0");
		cout << endl; 
	}
}f[N][2][2] , ans , res , one;
inline Bignum calc()
{
	scanf("%s",s+1);
	for(int i = 1;i <= n;i ++) a[i] = s[n - i + 1] - '0' , f[i][0][0] = f[i][0][1] = f[i][1][0] = f[i][1][1] = Bignum();
	for(int i = 0;i < 2;i ++) f[1][i][i < a[1]] += one;
	for(int i = 1;i < n;i ++) for(int j = 0;j < 2;j ++) for(int k = 0;k < 2;k ++) for(int t = 0;t < 2;t ++) f[i+1][!j && !t][t == a[i+1] ? k : t < a[i+1]] += f[i][j][k];
	return f[n][Q][1];
}
int main()
{
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
	T = read(); one.x[0] = 1;
	while(T --> 0)
	{
		n = read(); Q = read();
		res = calc(); ans = calc(); int k = a[1];
		for(int i = 2;i <= n;i ++) k = (!k && !a[i]);
		if(k == Q) ans += one;
		ans -= res;
		ans.print();
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```


---


# [BJWC2018] 上学路线

## 题目描述

小 B 所在的城市的道路构成了一个方形网格，它的西南角为 $(0,0)$，东北角为 $(N,M)$。

小 B 家住在西南角，学校在东北角。现在有 $T$ 个路口进行施工，小 B 不能通过这些路口。小 B 喜欢走最短的路径到达目的地，因此他每天上学时都只会向东或北行走；而小 B 又喜欢走不同的路径，因此他问你按照他走最短路径的规则，他可以选择的不同的上学路线有多少条。由于答案可能很大，所以小 B 只需要让你求出路径数 mod $P$ 的值。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/17943.png)

## 样例 #1

### 输入

```
3 4 3 1019663265
3 0
1 1
2 2```

### 输出

```
8```

# 题解

## 作者：Acestar (赞：15)

upd: 修改了部分解释不清楚的地方以及 $Latex$

---

[博客食用效果更佳 qaq](https://www.cnblogs.com/acestar/p/14334067.html)

先来看看数据范围，就发现可以骗到分。

$\bold{40pts:}$

测试点1、2：$n,m≤1000$，直接 $O(nm)DP$。

测试点3、4：没有施工路口，直接 $C_{n+m}^n$ 求总方案数，然后因为 $P$ 是质数，所以用逆元取模即可。

$\bold{60pts:}$

测试点5、6：因为 $P$ 不是质数，所以把 $P$ 分解成几个质数的乘积，分别算出 $C_{n+m}^n$ 对每个质数取模的结果，然后用 **中国剩余定理$(CRT)$** 合并求解（中国剩余定理下面会讲）。

~~以上就是考场上的骗分思路。~~

------------

$\bold{100pts:}$

把每个施工路口的坐标存进 $pos$ 结构体数组，再把 $(n,m)$ 存进 $pos_{t+1}$，然后将 $pos$ 按 $x$ 从小到大排序，如果 $x$ 相等，就按 $y$ 从小到大排序。

用 $f_i$ 表示从 $(0,0)$ 到 $(pos_i.x,pos_i.y)$ 并且不经过其他施工路口的方案数，然后~~大力~~推式子：

这里为了方便表示，将 $(pos_i.x,pos_i.y)$ 改为 $(x_i,y_i)$
$$
f_i=C_{x_i+y_i}^{x_i}-\sum_{j=1}^{t}f_jC_{x_i-x_j+y_i-y_j}^{x_i-x_j}\ \ \text{(符合条件的j)}
$$


其中，

第一项表示从 $(0,0)$ 到 $(x_i,y_i)$ 的总方案数。

第二项表示所有所有符合要求的 $j$ 从 $(0,0)$ 到 $(x_i,y_i)$ 且不经过其他施工路口的方案数 × 从$(x_j,y_j)$ 到 $(x_i,y_i)$ 的方案数的和。


显然，$j$ 的条件是 $x_j\le x_i,y_j\le y_i$。

由于已经将 $pos$ 数组排了序，所以式子中 $j$ 的范围可以缩小到 $i-1$ ：

$$
f_i=C_{x_i+y_i}^{x_i}-\sum_{j=1}^{i-1}f_jC_{x_i-x_j+y_i-y_j}^{x_i-x_j}\ \ (x_j\le x_i,y_j\le y_i)
$$


举个例子（样例）：

![](https://cdn.luogu.com.cn/upload/image_hosting/dxvrhxyu.png)

已知 $f_1=2$ 求 $f_2:$

$f_2=C_4^2-f_1×C_2^1$

$\quad\  =6-2×2$

$\quad\    =2$

其余同理。

最后输出 $f_t$ 即可。

至此，本题的主体思路已经讲完了。

------------

接下来考虑怎么计算 $C_n^m\bmod P$。

因为 $P$ 不一定是质数，所以不能直接用逆元取模。

**当 $P$ 是质数的时：**

直接用 $Lucas$ 即可。

$C_n^m=C_{n\bmod{p}}^{m\bmod{p}}×C_{n/p}^{m/p}\bmod{p}$

**当 $P$ 不是质数时：**

如何处理上面已经提到了，就是把 $P$ 分解成几个质数的积，存进 $p$ 数组，再用 $CRT$ 合并。

先介绍一下 $CRT:$

设 $m_1,m_2,...,m_n$ 是两两互质的整数，$m=∏_{i=1}^nm_i$，$M_i=\dfrac{m}{m_i}$，$t_i$是线性方程$M_it_i≡1(mod\ m_i)$ 的一个解（也就是逆元）。

对于任意的 $n$ 个整数 $a_1,a_2,...,a_n,$ 方程组

$\begin{cases}
x≡a_1\ (\bmod{m_1})&\\
x≡a_2\ (\bmod{m_2})&\\
...\ &\\
x≡a_n\ (\bmod{m_n})
\end{cases}$

有整数解，解为 $x=\sum_{i=1}^na_iM_it_i$。

~~证明请左转自行百度。~~

本题中 $P=1019663265=3×5×6793×10007$

令 $p_1=3,\ p_2=5,\ p_3=6793,\ p_4=10007$，显然它们两两互质，符合上述 $CRT$ 中的 $m$ 数组。

$a_i=C_n^m \bmod p_i$ 这里就可以逆元了

---

已经能求出 $C_n^m\bmod{P}$ 了。

然后再用 $DP$ 转移出最后的结果。

复杂度 $O(T^2\log n)$

上代码:

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define gc getchar
#define pc putchar

using namespace std;

namespace IO
{
    template <typename T>
    void read(T &x)
    {
        x = 0; bool f = 0; char c = gc();
        while(!isdigit(c)) f |= c == '-', c = gc();
        while(isdigit(c)) x = x * 10 + c - '0', c = gc();
        if(f) x = -x;
    }

    template <typename T>
    void write(T x)
    {
        if(x < 0) pc('-'), x = -x;
        if(x > 9) write(x / 10);
        pc('0' + x % 10);
    }
}
using namespace IO;

const int N = 1e6 + 5;

struct node
{
    int x, y;
}pos[210];
int n, m, t, P, tp;
int f[210], g[5], p[5], mul[5], fac[5][N], invm[5], inv[5][N];

inline bool cmp(node a, node b)
{
    return a.x == b.x ? a.y < b.y : a.x < b.x;
}

inline int power(int a, int b, int p)
{
    int ret = 1;
    a %= p;
    while(b)
    {
        if(b & 1) ret = 1ll * ret * a % p;
        a = 1ll * a * a % p, b >>= 1;
    }
    return ret;
}

inline int C(int a, int b, int i)       //C(a, b) % i
{
    if(a < b) return 0;
    if(!b || a == b) return 1;
    if(a < p[i] && b < p[i]) return 1ll * fac[i][a] * inv[i][b] % p[i] * inv[i][a - b] % p[i];
    return 1ll * C(a % p[i], b % p[i], i) * C(a / p[i], b / p[i], i) % p[i];
}

inline int CRT(int a, int b)        //中国剩余定理 
{
    if(!tp) return C(a, b, 0);      //P为质数时直接返回C(a,b)%p[0] 
    int ret = 0;
    for(int i = 1; i <= 4; i++) g[i] = C(a, b, i);    //g[i]=C(a,b)%p[i] 
    for(int i = 1; i <= 4; i++) ret = (ret + 1ll * g[i] * mul[i] % P * invm[i] % P) % P;
    return ret;
}

int main()
{
    read(n), read(m), read(t), read(P);
    for(int i = 1; i <= t; i++)
        read(pos[i].x), read(pos[i].y);
    pos[++t] = (node) {n, m};        //将(n,m)加到pos[t+1]
    sort(pos + 1, pos + 1 + t, cmp); //排序

    if(P == 1e6 + 3) p[0] = P;      //如果P是质数，存到p[0]
    else p[1] = 3, p[2] = 5, p[3] = 6793, p[4] = 10007, tp = 1; //否则，分解成4个质数，并且tp=1,表示P不是质数

    //预处理
    if(tp)  //如果P不是质数
    {
        for(int i = 1; i <= 4; i++)
        {
            mul[i] = P / p[i]; //CRT 中的 m 数组
            invm[i] = power(mul[i], p[i] - 2, p[i]); //mul[i] % p[i] 的逆元
            fac[i][0] = 1; //0! % p[i]

            for(int j = 1; j < p[i]; j++)
                fac[i][j] = 1ll * fac[i][j - 1] * j % p[i]; //j! % p[i]

            inv[i][p[i] - 1] = power(fac[i][p[i] - 1], p[i] - 2, p[i]); //(p[i]-1)! % p[i] 的逆元

            for(int j = p[i] - 1; j >= 1; j--)
                inv[i][j - 1] = 1ll * inv[i][j] * j % p[i]; //逆元的递推
        }
    }
    else
    {
        //同上，只是少一层循环，因为只有一个质数
        fac[0][0] = 1;
        for(int i = 1; i < P; i++)
            fac[0][i] = 1ll * fac[0][i - 1] * i % P;

        inv[0][P - 1] = power(fac[0][P - 1], P - 2, P);
        for(int i = P - 1; i >= 1; i--)
            inv[0][i - 1] = 1ll * inv[0][i] * i % P;
    }

    for(int i = 1; i <= t; i++) {
        f[i] = CRT(pos[i].x + pos[i].y, pos[i].x); //从(0,0)到(pos[i].x,pos[i].y)的总方案数

        //减去经过其他施工路口的方案数
        for(int j = 1; j < i; j++)
            if(pos[j].x <= pos[i].x && pos[j].y <= pos[i].y)
                f[i] = (f[i] - 1ll * f[j] * CRT(pos[i].x - pos[j].x + pos[i].y - pos[j].y, pos[i].x - pos[j].x) % P + P) % P;
    }

    write(f[t]), pc('\n');
    return 0;
}
```

题外话：

我在写这篇题解的时候，浏览器突然就**未响应**了，所以就重新写了一遍 qwq，建议大家如果没有 **typora** 或 **vscode** 等软件可以先在**云剪贴板**上写好了复制过来。



---

## 作者：Saliеri (赞：4)

全部自己做出来了？震惊我一百年。

___

计数题，还很套路。

首先可以发现，想要直接计算不经过障碍物的方案数是比较困难的。所以考虑**正难则反**，考虑用总方案数减去经过一个指定的障碍物的方案数。

直接计算会算重，因为一条路径上可能经过了多个障碍物，而在每个障碍物的位置我们都会算一遍。

接下来是套路，我们考虑给每一条路径设一个**标志物**——我们钦定一个点 $i$ ,设 $f_i$ 为路径上**第一个**障碍物是点 $i$ 的方案数。

接下来考虑 $f$ 的转移。

对于一个障碍物 $i$，总方案数显然是 $\binom{x_i+y_i}{x_i}$，这是经典结论此处不提；

不合法的方案是之前经过过一个障碍物的方案，即 $\sum_{j\neq i,x_j\le x_i,y_j\le y_i} f_j\binom{x_i-x_j+y_i-y_j}{x_i-x_j}$ 。解释一下，就是在他之前可能经过的点中选一个作为第一个经过的障碍，因为标志物确定好了，所以剩下的路随便走就可以了。

我们发现最后到达 $(n,m)$ 点后的答案计算方式和这个一模一样，所以为了方便讨论，多加一个障碍物点为 $(n,m)$ 即可。

**记得注意 dp 数组的更新先后问题。**

目前的问题是，$x$，$y$ 数值高达 $10^{10}$（BZOJ 上），而这样的组合数无法直接计算。

考虑 **Lucas 定理**：对于素数 $p$，有 $\binom{n}{m} \equiv\binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{m}{p}\right\rfloor}\times\binom{n\bmod p}{m\bmod p}(\text{mod} \  p)$。

此处不证，想看证明的：[Link](https://zhuanlan.zhihu.com/p/116698264)。

到了这里，$\text{mod} =10^6+3$ 的部分分已经有了，接下来来看 $\text{mod} = 1019663265$。

又是套路，合数模不好算，考虑拆分成素数幂的模然后 CRT 合并。

我们一拆： $1019663265=3\times5\times6793\times10007$，全是一次项。

好，更省事了。我们对于这四个模数都依照 Lucas 定理算一遍，最后用 CRT 合并即可。（这里默认大家都会 CRT，不会右转模板） 

至此这个题就彻底完了，因为单次 Lucas 定理的复杂度是 $O(\log N)$，所以总复杂度是 $O(n^2\log N)$ 的。
 
___

代码：

用 template 封装了不同模数的 Lucas，跑的比较快（目前是 Rank 1），可以参考一下。

```cpp
#include <cstdio>
#include <algorithm>
typedef long long ll;
const int maxn = 205;
ll N,M,n,p;
int f[maxn];
struct Point{ll x,y;bool operator <(Point &b)const{return x+y<b.x+b.y;}}pt[maxn];
int ksm(int a,int x,int p){
	int ans = 1,bas = a;
	while(x){
		if(x&1)ans = 1ll*ans*bas%p;
		bas = 1ll*bas*bas%p,x >>= 1;
	}return ans;
}
namespace Subtask1{
	const int mod = 1e6+3;
	int jc[mod],inv[mod];
	int c(int n,int m){return n>=m?1ll*jc[n]*inv[m]%mod*inv[n-m]%mod:0;}
	int C(ll n,ll m){return n?1ll*c(n%mod,m%mod)*C(n/mod,m/mod)%mod:(m?0:1);}
	void Solve(){
		jc[0] = inv[0] = 1;
		for(int i=1;i<mod;++i)jc[i] = 1ll*jc[i-1]*i%mod;
		inv[mod-1] = ksm(jc[mod-1],mod-2,mod);
		for(int i=mod-1;i>=2;--i)inv[i-1] = 1ll*inv[i]*i%mod;
		for(int i=1;i<=n;++i){
			f[i] = C(pt[i].x+pt[i].y,pt[i].x);
			for(int j=1;j<i;++j)
				if(pt[j].x<=pt[i].x&&pt[j].y<=pt[i].y)
					f[i] = (f[i]-1ll*f[j]*C(pt[i].x-pt[j].x+pt[i].y-pt[j].y,pt[i].x-pt[j].x)%mod+mod)%mod;
		}
		printf("%d\n",f[n]);
	}
}
namespace Subtask2{
	const int mod = 1019663265;
	template <const int Mod>struct Lucas{
		int jc[Mod],inv[Mod];
		Lucas(){
			jc[0] = inv[0] = 1;
			for(int i=1;i<Mod;++i)jc[i] = 1ll*jc[i-1]*i%Mod;
			inv[Mod-1] = ksm(jc[Mod-1],Mod-2,Mod);
			for(int i=Mod-1;i>=2;--i)inv[i-1] = 1ll*inv[i]*i%Mod;
		}
		int c(int n,int m){return n>=m?1ll*jc[n]*inv[m]%Mod*inv[n-m]%Mod:0;}
		int C(ll n,ll m){return n?1ll*c(n%Mod,m%Mod)*C(n/Mod,m/Mod)%Mod:(m?0:1);}
	};
	Lucas<3> t1;Lucas<5> t2;Lucas<6793> t3;Lucas<10007> t4;
	const int coe[] = {0,339887755,407865306,673070820,618502650};
	int C(ll n,ll m){return (1ll*coe[1]*t1.C(n,m)%mod+1ll*coe[2]*t2.C(n,m)%mod+1ll*coe[3]*t3.C(n,m)%mod+1ll*coe[4]*t4.C(n,m)%mod)%mod;}
	void Solve(){
		for(int i=1;i<=n;++i){
			f[i] = C(pt[i].x+pt[i].y,pt[i].x);
			for(int j=1;j<i;++j)
				if(pt[j].x<=pt[i].x&&pt[j].y<=pt[i].y)
					f[i] = (f[i]-1ll*f[j]*C(pt[i].x-pt[j].x+pt[i].y-pt[j].y,pt[i].x-pt[j].x)%mod+mod)%mod;
		}
		printf("%d\n",f[n]);
	}
}
int main(){
	scanf("%lld %lld %lld %lld",&N,&M,&n,&p);
	for(int i=1;i<=n;++i)scanf("%lld %lld",&pt[i].x,&pt[i].y);
	std :: sort(pt+1,pt+n+1);
	return ++n,pt[n].x = N,pt[n].y = M,(p==1000003?Subtask1::Solve():Subtask2::Solve()),0;
}
```



---

## 作者：约瑟夫用脑玩 (赞：3)

考场打了普通 Lucas 就开始划水的题，下来 3min 就秒了qwq，逛了一圈题解发现都做麻烦了，给个简单的处理办法。（sto @[_ Enthalpy](https://www.luogu.com.cn/user/42156)）

首先 $T$ 的范围小的让人不习惯（毒瘤赛做多了），范围给这么小直接暴力容斥即可。

随便口胡一下容斥过程：

考虑随便从起点走到终点，假设没看到障碍，于是可能经过不能走的点。

减去经过了一次非法点的方案，就会多减了经过两次的，再加回来又会加多，以此类推，不难看出容斥过程。

于是我们钦定经过了 $k$ 次障碍点，容斥系数就是 $(-1)^k$，考虑求方案数。

发现这个方案数可以 DP，于是就做 DP，设 $f_{i,j}$ 表示当前在第 $i$ 个点，钦定了 $j$ 个障碍点被经过的方案。

然后从左下角的障碍点转移过来即可，状态 $O(T^2)$，转移 $O(T)$，其实可以用 DS 优化转移，但难得出题人良心只开 $T=200$，直接 $O(T^3)$ 即可。

看一眼坐标范围，发现事情没这么简单，先考虑 $P=100003$。

由于是个质数而且还比较小，可以预处理在 $P$ 以内的组合数，$P$ 以外的就用 Lucas 就没问题了。

~~考场由于不想推 CRT，打到这里就溜了（~~

再考虑 $P=1019663265$，发现 $1019663265=3* 5* 6793* 10007$，如果你比较勤快可以直接写一个扩展 Lucas，或者采用以下办法：

发现质因子只有一次，对每一个质因子当做模数做一遍，然后找到一个同时符合这四种模数的答案即可。

只要学过 CRT 的都能看出来这就是 CRT（，那么这也就是唯一的。

但我不想推 CRT 欸，~~那去写插值吧~~，发现质因子都很小，可以直接枚举。

其实这就是暴力 CRT，通过枚举而不是直接推式子快速算到，复杂度是 $O(k\max_{1\le i\le k}{p_i})$，其中 $p_i$ 是第 $i$ 个质因子，$k$ 是质因子个数，出题人给的模数良心放给你用都不用？

枚举即可，~~由于太简单都不知道对暴力 CRT 说点什么~~，看一眼代码实现相信大家都会了：

```
//ans：当前答案
//mod：当前模数
//anss[]：每个质因子分别做的答案
//pre[]：每个质因子
	ans=anss[0];
	int mod=pre[0];
	for(i=1;i<4;i++)
	{//枚举新的质因子及答案进行合并
		for(j=-pre[i];j<=pre[i];j++)
		{//枚举一个符合模数的答案，即j*mod+ans，判断是否和新的模数契合。
			if(M((LL)j*mod+ans,pre[i])==M(anss[i],pre[i]))
			{//找到契合的就走人
				ans=M((LL)j*mod+ans,mod*pre[i]);
				mod*=pre[i];
				break;
			}
		}
		assert(j<=pre[i]);
	}
	writenum(ans,10);
```

---

## 作者：Hope2075 (赞：3)

这道题是~~小学~~数学题

首先，这道题要求合法路线，即：不经过任何一个点

考虑容斥

如果统计出至少经过0个 1个 2个...点的路线数

就可以通过容斥求出合法路线

先把点按横坐标排序，如果相同，则按纵坐标排序

定义dp[i][j]表示最后到达点i，且至少经过j个不合法点

为了方便讨论，把起点和终点分别视为一个不合法点

这样求出到终点的相应“不合法”路线条数就可以

这样就有转移：$dp_{i,j}=\sum_{k=0}^{i-1}dp_{k,j-1}*path(k,i)$

其中$path(k,i)$表示从$k$到$i$的路线条数

可以看出，如果$k$的横坐标或纵坐标比$i$大，则路线条数为0

这样实际相当于不会转移

所以按坐标排序就能保证转移顺序正确

接下来想办法求$path(k,i)$

由~~小学~~高中排列组合知识，可得$paht(k,i)=\tbinom{i_x-k_x+i_y-k_y}{i_x-k_x}$

就是一共走$i_x-k_x+i_y-k_y$步，有$i_x-k_x$步向右走

最后容斥的时候，从2开始（根据前面的定义），系数为$(-1)^i$

然后考虑怎么算

先看看两个模数

数字 $1019663265$

因式分解: $3*5*6793*10007$

数字 $1000003$

因式分解: (是质数)

对于是质数的模数，很好办

预处理阶乘，用lucas定理求组合数就可以

而另一个则是合数

但是发现只有4个各不相同的因子

所以只要把这四个模数意义下的答案求出来，然后CRT合并就行

或者解不定方程也可以

具体合并过程略

这样可以得到一个复杂度**大约**$O(t^3)$的算法

可以得到这样的代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const long long M0=1000003,M1=3,M2=5,M3=6793,M4=10007;
const int N=210;
long long n,m,p;int t;
struct point{
    long long x,y;
};
bool operator<(point a,point b){
    if(a.x==b.x)return a.y<b.y;
    return a.x<b.x;
}
point list[N];
namespace calc{
    long long M;
    long long dp[N][N];
    long long frac[M0+1];
    long long arc(long long a){
        long long p=M-2,ans=1;
        while(p){
            if(p&1)ans=ans*a%M;
            a=a*a%M;
            p>>=1;
        }
        return ans;
    }
    void pre(){
        frac[0]=1;
        for(int i=1;i<M;i++){
            frac[i]=frac[i-1]*i%M;
        }
    }
    long long C(long long n,long long m){
        if(m>n)return 0;
        long long ans=frac[n]*arc(frac[m]*frac[n-m]%M)%M;
        return ans;
    }
    long long lucas(long long n,long long m){
        if(m==0)return 1;
        long long ans=lucas(n/M,m/M)*C(n%M,m%M)%M;
        return ans;
    }
    long long path(int a,int b){
        if(list[a].x>list[b].x)return 0;
        if(list[a].y>list[b].y)return 0;
        return lucas(list[b].x+list[b].y-list[a].x-list[a].y,list[b].x-list[a].x);
    }
    long long solve(){
        pre();
        dp[0][0]=1;
        for(int i=1;i<=t+1;i++){
            dp[i][0]=0;
            for(int j=1;j<=t+1;j++){
                dp[i][j]=0;
                for(int k=0;k<i;k++){
                    dp[i][j]=(dp[i][j]+dp[k][j-1]*path(k,i)%M)%M;
                }
            }
        }
        long long ans=0;
        for(int i=1;i<=t+1;i++){
            ans+=((i&1)?1:-1)*dp[t+1][i];
            ans%=M;
            if(ans<0)ans+=M;
        }
        return ans;
    }
}
void exgcd(long long a,long long b,long long &x,long long &y){
    if(a==0){
        x=0;
        y=1;
        return;
    }
    exgcd(b%a,a,y,x);
    x-=b/a*y;
    return;
}
long long mix(long long a1,long long m1,long long a2,long long m2){
    long long y1,y2;
    exgcd(m1,m1*m2-m2,y1,y2);
    y1*=(a1-a2);
    y1%=m2;
    if(y1<0)y1+=m2;
    long long ans=(a1-y1*m1)%(m1*m2);
    if(ans<0)ans+=(m1*m2);
    return ans;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m>>t>>p;
    for(int i=1;i<=t;i++){
        cin>>list[i].x>>list[i].y;
    }
    sort(list+1,list+t+1);
    list[t+1]=(point){n,m};
    if(p==M0){
        calc::M=M0;
        cout<<calc::solve();
    }else{
        long long a1,a2,a3,a4,ans;
        calc::M=M1;
        a1=calc::solve();
        calc::M=M2;
        a2=calc::solve();
        calc::M=M3;
        a3=calc::solve();
        calc::M=M4;
        a4=calc::solve();
        ans=mix(a1,M1,a2,M2);
        ans=mix(ans,M1*M2,a3,M3);
        ans=mix(ans,M1*M2*M3,a4,M4);
        cout<<ans;
    }
}
```

但是交上去：只有40分

如果仔细算一下复杂度，会发现是$O(t^3 \log ^2 p)$的

每次会有lucas的复杂度，求逆元还有复杂度，最后除法和取模因为模数不是常数，会比较慢

所以我进行以下优化：

将整段DP复制5编，每一部分都有一个常数模数 40->60

因为模数很小，把所有数的逆元预处理出来 60->80

$paht(k,i)$最多有$O(t^2)$对，也预处理出来 80->100

这样预处理复杂度$O(p \log p + t^2 \log p)$

实际DP的复杂度$O(t^3)$

这样就是真正的$O(t^3)$

于是就能AC了

最后上AC代码：

看起来很长，实际上大部分是重复的，只改了编号和模数

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const long long M0=1000003,M1=3,M2=5,M3=6793,M4=10007;
const int N=210;
long long n,m,p;int t;
struct point{
	long long x,y;
};
bool operator<(point a,point b){
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
point list[N];
namespace calc0{
	const long long M=M0;
	long long dp[N][N];
	long long frac[M+1];
	long long alist[M];
	long long arc(long long a){
		long long p=M-2,ans=1;
		while(p){
			if(p&1)ans=ans*a%M;
			a=a*a%M;
			p>>=1;
		}
		return ans;
	}
	long long C(long long n,long long m){
		if(m>n)return 0;
		long long ans=frac[n]*alist[frac[m]*frac[n-m]%M]%M;
		return ans;
	}
	long long lucas(long long n,long long m){
		if(m==0)return 1;
		long long ans=lucas(n/M,m/M)*C(n%M,m%M)%M;
		return ans;
	}
	long long path(int a,int b){
		if(list[a].x>list[b].x)return 0;
		if(list[a].y>list[b].y)return 0;
		return lucas(list[b].x+list[b].y-list[a].x-list[a].y,list[b].x-list[a].x);
	}
	long long plist[N][N];
	void pre(){
		frac[0]=1;
		for(int i=1;i<M;i++){
			frac[i]=frac[i-1]*i%M;
		}
		for(int i=1;i<M;i++)alist[i]=arc(i);
		for(int i=0;i<=t+1;i++){
			for(int j=0;j<=t+1;j++){
				plist[i][j]=path(i,j);
			}
		}
	}
	long long solve(){
		pre();
		dp[0][0]=1;
		for(int i=1;i<=t+1;i++){
			dp[i][0]=0;
			for(int j=1;j<=t+1;j++){
				dp[i][j]=0;
				for(int k=0;k<i;k++){
					dp[i][j]=(dp[i][j]+dp[k][j-1]*plist[k][i]%M)%M;
				}
			}
		}
		long long ans=0;
		for(int i=1;i<=t+1;i++){
			ans+=((i&1)?1:-1)*dp[t+1][i];
			ans%=M;
			if(ans<0)ans+=M;
		}
		return ans;
	}
}
namespace calc1{
	const long long M=M1;
	long long dp[N][N];
	long long frac[M+1];
	long long alist[M];
	long long arc(long long a){
		long long p=M-2,ans=1;
		while(p){
			if(p&1)ans=ans*a%M;
			a=a*a%M;
			p>>=1;
		}
		return ans;
	}
	long long C(long long n,long long m){
		if(m>n)return 0;
		long long ans=frac[n]*alist[frac[m]*frac[n-m]%M]%M;
		return ans;
	}
	long long lucas(long long n,long long m){
		if(m==0)return 1;
		long long ans=lucas(n/M,m/M)*C(n%M,m%M)%M;
		return ans;
	}
	long long path(int a,int b){
		if(list[a].x>list[b].x)return 0;
		if(list[a].y>list[b].y)return 0;
		return lucas(list[b].x+list[b].y-list[a].x-list[a].y,list[b].x-list[a].x);
	}
	long long plist[N][N];
	void pre(){
		frac[0]=1;
		for(int i=1;i<M;i++){
			frac[i]=frac[i-1]*i%M;
		}
		for(int i=1;i<M;i++)alist[i]=arc(i);
		for(int i=0;i<=t+1;i++){
			for(int j=0;j<=t+1;j++){
				plist[i][j]=path(i,j);
			}
		}
	}
	long long solve(){
		pre();
		dp[0][0]=1;
		for(int i=1;i<=t+1;i++){
			dp[i][0]=0;
			for(int j=1;j<=t+1;j++){
				dp[i][j]=0;
				for(int k=0;k<i;k++){
					dp[i][j]=(dp[i][j]+dp[k][j-1]*plist[k][i]%M)%M;
				}
			}
		}
		long long ans=0;
		for(int i=1;i<=t+1;i++){
			ans+=((i&1)?1:-1)*dp[t+1][i];
			ans%=M;
			if(ans<0)ans+=M;
		}
		return ans;
	}
}
namespace calc2{
	const long long M=M2;
	long long dp[N][N];
	long long frac[M+1];
	long long alist[M];
	long long arc(long long a){
		long long p=M-2,ans=1;
		while(p){
			if(p&1)ans=ans*a%M;
			a=a*a%M;
			p>>=1;
		}
		return ans;
	}
	long long C(long long n,long long m){
		if(m>n)return 0;
		long long ans=frac[n]*alist[frac[m]*frac[n-m]%M]%M;
		return ans;
	}
	long long lucas(long long n,long long m){
		if(m==0)return 1;
		long long ans=lucas(n/M,m/M)*C(n%M,m%M)%M;
		return ans;
	}
	long long path(int a,int b){
		if(list[a].x>list[b].x)return 0;
		if(list[a].y>list[b].y)return 0;
		return lucas(list[b].x+list[b].y-list[a].x-list[a].y,list[b].x-list[a].x);
	}
	long long plist[N][N];
	void pre(){
		frac[0]=1;
		for(int i=1;i<M;i++){
			frac[i]=frac[i-1]*i%M;
		}
		for(int i=1;i<M;i++)alist[i]=arc(i);
		for(int i=0;i<=t+1;i++){
			for(int j=0;j<=t+1;j++){
				plist[i][j]=path(i,j);
			}
		}
	}
	long long solve(){
		pre();
		dp[0][0]=1;
		for(int i=1;i<=t+1;i++){
			dp[i][0]=0;
			for(int j=1;j<=t+1;j++){
				dp[i][j]=0;
				for(int k=0;k<i;k++){
					dp[i][j]=(dp[i][j]+dp[k][j-1]*plist[k][i]%M)%M;
				}
			}
		}
		long long ans=0;
		for(int i=1;i<=t+1;i++){
			ans+=((i&1)?1:-1)*dp[t+1][i];
			ans%=M;
			if(ans<0)ans+=M;
		}
		return ans;
	}
}
namespace calc3{
	const long long M=M3;
	long long dp[N][N];
	long long frac[M+1];
	long long alist[M];
	long long arc(long long a){
		long long p=M-2,ans=1;
		while(p){
			if(p&1)ans=ans*a%M;
			a=a*a%M;
			p>>=1;
		}
		return ans;
	}
	long long C(long long n,long long m){
		if(m>n)return 0;
		long long ans=frac[n]*alist[frac[m]*frac[n-m]%M]%M;
		return ans;
	}
	long long lucas(long long n,long long m){
		if(m==0)return 1;
		long long ans=lucas(n/M,m/M)*C(n%M,m%M)%M;
		return ans;
	}
	long long path(int a,int b){
		if(list[a].x>list[b].x)return 0;
		if(list[a].y>list[b].y)return 0;
		return lucas(list[b].x+list[b].y-list[a].x-list[a].y,list[b].x-list[a].x);
	}
	long long plist[N][N];
	void pre(){
		frac[0]=1;
		for(int i=1;i<M;i++){
			frac[i]=frac[i-1]*i%M;
		}
		for(int i=1;i<M;i++)alist[i]=arc(i);
		for(int i=0;i<=t+1;i++){
			for(int j=0;j<=t+1;j++){
				plist[i][j]=path(i,j);
			}
		}
	}
	long long solve(){
		pre();
		dp[0][0]=1;
		for(int i=1;i<=t+1;i++){
			dp[i][0]=0;
			for(int j=1;j<=t+1;j++){
				dp[i][j]=0;
				for(int k=0;k<i;k++){
					dp[i][j]=(dp[i][j]+dp[k][j-1]*plist[k][i]%M)%M;
				}
			}
		}
		long long ans=0;
		for(int i=1;i<=t+1;i++){
			ans+=((i&1)?1:-1)*dp[t+1][i];
			ans%=M;
			if(ans<0)ans+=M;
		}
		return ans;
	}
}
namespace calc4{
	const long long M=M4;
	long long dp[N][N];
	long long frac[M+1];
	long long alist[M];
	long long arc(long long a){
		long long p=M-2,ans=1;
		while(p){
			if(p&1)ans=ans*a%M;
			a=a*a%M;
			p>>=1;
		}
		return ans;
	}
	long long C(long long n,long long m){
		if(m>n)return 0;
		long long ans=frac[n]*alist[frac[m]*frac[n-m]%M]%M;
		return ans;
	}
	long long lucas(long long n,long long m){
		if(m==0)return 1;
		long long ans=lucas(n/M,m/M)*C(n%M,m%M)%M;
		return ans;
	}
	long long path(int a,int b){
		if(list[a].x>list[b].x)return 0;
		if(list[a].y>list[b].y)return 0;
		return lucas(list[b].x+list[b].y-list[a].x-list[a].y,list[b].x-list[a].x);
	}
	long long plist[N][N];
	void pre(){
		frac[0]=1;
		for(int i=1;i<M;i++){
			frac[i]=frac[i-1]*i%M;
		}
		for(int i=1;i<M;i++)alist[i]=arc(i);
		for(int i=0;i<=t+1;i++){
			for(int j=0;j<=t+1;j++){
				plist[i][j]=path(i,j);
			}
		}
	}
	long long solve(){
		pre();
		dp[0][0]=1;
		for(int i=1;i<=t+1;i++){
			dp[i][0]=0;
			for(int j=1;j<=t+1;j++){
				dp[i][j]=0;
				for(int k=0;k<i;k++){
					dp[i][j]=(dp[i][j]+dp[k][j-1]*plist[k][i]%M)%M;
				}
			}
		}
		long long ans=0;
		for(int i=1;i<=t+1;i++){
			ans+=((i&1)?1:-1)*dp[t+1][i];
			ans%=M;
			if(ans<0)ans+=M;
		}
		return ans;
	}
}
void exgcd(long long a,long long b,long long &x,long long &y){
	if(a==0){
		x=0;
		y=1;
		return;
	}
	exgcd(b%a,a,y,x);
	x-=b/a*y;
	return;
}
long long mix(long long a1,long long m1,long long a2,long long m2){
	long long y1,y2;
	exgcd(m1,m1*m2-m2,y1,y2);
	y1*=(a1-a2);
	y1%=m2;
	if(y1<0)y1+=m2;
	long long ans=(a1-y1*m1)%(m1*m2);
	if(ans<0)ans+=(m1*m2);
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>t>>p;
	for(int i=1;i<=t;i++){
		cin>>list[i].x>>list[i].y;
	}
	sort(list+1,list+t+1);
	list[t+1]=(point){n,m};
	if(p==M0){
		cout<<calc0::solve();
	}else{
		long long a1,a2,a3,a4,ans;
		a1=calc1::solve();
		a2=calc2::solve();
		a3=calc3::solve();
		a4=calc4::solve();
		ans=mix(a1,M1,a2,M2);
		ans=mix(ans,M1*M2,a3,M3);
		ans=mix(ans,M1*M2*M3,a4,M4);
		cout<<ans;
	}
}
```

---

## 作者：Tmbcan (赞：2)

## [P4478 [BJWC2018] 上学路线](https://www.luogu.com.cn/problem/P4478)

~~MgZn 刚刚学习了 ExLucas 赶紧尝试了一下。~~

### 思路

看到有 $T$ 个障碍点并且障碍点非常少，所以想到暴力容斥，用总方案减去不合法的方案数。

只要经过任意一个障碍点，就是一个不合法方案。所以令 $dp_i$ 表示**只经过**障碍点 $i$ 的方案数。 

设当前障碍点为 $(x_i,y_i)$，如果不管途中是否经过其他障碍点，那么走到该点的总方案数为 $C_{x_i+y_i}^{x_i}$。  
但是其中还包含了经过其他障碍点的方案数。

设还经过了障碍点 $(x_j,y_j)$，满足 $x_j \le x_i$ 且 $y_j \le y_i$，那么多统计的方案数为 $dp_j \times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}$ 减掉即可。  
一个点能从其左下角的每个点转移过来，所以先把点按从左到右、从上到下排好序，才能保证转移是正确的。  

我们发现 $n$ 和 $m$ 都非常大，所以要用 Lucas 定理，$C_n^m \equiv C_{n\%P}^{m\%P} \times C_{n/P}^{m/P} \pmod P$。  
然而 Lucas 定理只适用于 $P$ 为质数，如果 $P$ 不是质数怎么办呢。  
我们可以把 $P$ 分解质因数，对于每个质因子都列出一个方程，得到同余方程组，然后用中国剩余定理合并求解就可以了。

我们发现 $P = 1019663265=3 \times 5 \times 6793 \times 10007$，所以不用繁琐的对组合数拆开取模，直接做就可以了。


### 代码


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
#include<cstdlib>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
template <typename T>
inline void read(T&x){// 快读
	int w = 0;x = 0;
	char ch = getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') w = 1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	if(w) x = ~x+1;
}
template <typename T,typename...Args>
inline void read(T&t,Args&...args){
	read(t);read(args...);
}
template <typename T>
inline T Min(T x,T y){ return (x < y ? x : y); }
template <typename T>
inline T Max(T x,T y){ return (x > y ? x : y); }
template <typename T>
inline T Abs(T x){ return (x < 0 ? ~x+1 : x); }
const int N = 210,M = 1e6+10;
ll prime[4] = {3,5,6793,10007};
ll T,ans[N],P; int cnt;
struct node{
    ll x,y;
    inline int operator < (const node&G) const{
        if(x^G.x) return x < G.x;
        return y < G.y;
    }
}g[N];
ll mul[4][M],inv[4][M];
inline ll quick_pow(ll x,ll y,int t){
    ll res = 1;
    while(y){
        if(y&1) (res *= x)%=prime[t];
        (x *= x)%=prime[t];
        y >>= 1;
    }
    return res;
}
inline ll C(ll n,ll m,int t){// 组合数
    if(m>n) return 0;
    return mul[t][n]*inv[t][n-m]%prime[t]*inv[t][m]%prime[t];
}
inline ll Lucas(ll n,ll m,int t){// Lucas
    if(!m) return 1;
    return C(n%prime[t],m%prime[t],t)*Lucas(n/prime[t],m/prime[t],t)%prime[t];
}
inline ll Gcd(ll x,ll y){
    if(!x || !y) return x|y;
    ll xz = __builtin_ctzll(x);
    ll yz = __builtin_ctzll(y);
    ll z = Min(xz,yz);
    ll diff;
    y >>= yz;
    while(x){
        x >>= xz;
        diff = x-y;
        xz = __builtin_ctzll(diff);
        y = Min(x,y);
        x = Abs(diff);
    }
    return y << z;
}
inline void Exgcd(ll x,ll y,ll &Ex,ll &Ey){// 扩欧
    if(!y){
        Ex = 1;
        Ey = 0;
        return ;
    }
    Exgcd(y,x%y,Ey,Ex);
    Ey = Ey-x/y*Ex;
}
inline ll ExCRT(ll n,ll m){// ExCRT 合并方程
    ll r1 = Lucas(n,m,0);
    ll m1 = prime[0];
    ll r2,m2,Ex,Ey;
    for(int t=1;t<=cnt;++t){
        r2 = Lucas(n,m,t);
        m2 = prime[t];
        ll d = Gcd(m1,m2);
        // if((r2-r1)%d) exit(0);
        Exgcd(m1/d,m2/d,Ex,Ey);

        Ex = ((r2-r1)/d*Ex%(m2/d)+(m2/d))%(m2/d);
        r1 = ((r1+m1*Ex)%(m1/d*m2)+(m1/d*m2))%(m1/d*m2);
        m1 = m1/d*m2;
    }
    return r1;
}
int main(){
	// freopen("in.in","r",stdin);
    // freopen("out.out","w",stdout);

	ll n,m;read(n,m,T,P);
    for(int i=1;i<=T;++i) read(g[i].x,g[i].y);
    g[++T] = {n,m};
    sort(g+1,g+1+T);// 排好序
    if(P==1000003) prime[0] = 1000003,cnt = 0;
    else cnt = 3;
    for(int t=0;t<=cnt;++t){
        mul[t][0] = 1;
        for(ll i=1;i<prime[t];++i) mul[t][i] = mul[t][i-1]*i%prime[t];
        inv[t][prime[t]-1] = quick_pow(mul[t][prime[t]-1],prime[t]-2,t);
        for(ll i=prime[t]-1;i;--i) inv[t][i-1] = inv[t][i]*i%prime[t];
    }
    for(int i=1;i<=T;++i){
        ans[i] = ExCRT(g[i].x+g[i].y,g[i].x);
        for(int j=1;j<i;++j){
            if(g[j].x<=g[i].x && g[j].y<=g[i].y){// 左下角的点
                ans[i] = (ans[i]-ans[j]*ExCRT(g[i].x+g[i].y-g[j].x-g[j].y,g[i].x-g[j].x)%P+P)%P;
            }
        }
    }
    printf("%lld",ans[T]);

	fclose(stdin);
	fclose(stdout);
	return 0;
}

```

---

## 作者：ez_lcw (赞：2)

考虑 dp。

我们先把 $(n,m)$ 也当做障碍点，然后把所有的障碍点按 $x$ 坐标为第一关键字，$y$ 坐标为第二关键字排序。

然后设 $f_i$ 表示到达第 $i$ 个障碍点的合法总方案数（途中不经过障碍点）。显然，答案就是 $f_{t+1}$，也就是到达 $(n,m)$ 的总方案数。

至于为什么要先排序，是因为我们要保证当处理 $f_i$ 时，能转移到 $f_i$ 的所有 $f_j$ 都已经处理完了。

显然有状态转移方程：（其中 $x_i$ 表示第 $i$ 个障碍点的 $x$ 坐标，$y_i$ 同理）

$$f_i=\binom{x_i+y_i}{x_i}-\sum_{j=1}^{i-1}f_j\times\binom{(x_i+y_i)-(x_j+y_j)}{x_i-x_j}$$

首先，$\dbinom{x_i+y_i}{x_i}$ 是从 $(0,0)$ 到 $(x_i,y_i)$ 的总方案（不论是否合法）。

证明：从 $(0,0)$ 到 $(x_i,y_i)$ 一共需要 $x_i+y_i$ 步，其中需要横着走 $x_i$ 步，竖着走 $y_i$ 步，那么我们就枚举在哪几步横着走，也就是 $\dbinom{x_i+y_i}{x_i}$。

然后 $\dbinom{(x_i+y_i)-(x_j+y_j)}{x_i-x_j}$ 是从 $(x_j,y_j)$ 到 $(x_i,y_i)$ 的总方案（不论是否合法），证明同理。

然后证明那些不合法的方案就是 $\sum_{j=1}^{i-1}f_j\times\dbinom{(x_i+y_i)-(x_j+y_j)}{x_i-x_j}$。

设某一条不合法路径上的第一个障碍点是第 $first$ 个障碍点。

那么 $f_j\times\dbinom{(x_i+y_i)-(x_j+y_j)}{x_i-x_j}$ 表示的就是那些 $first=j$ 的不合法路径，因为这种路径从 $(0,0)$ 到 $(x_j,y_j)$ 是没有障碍点的，正好对应 $f_j$。

这么解释的话，就容易证明 $\sum_{j=1}^{i-1}f_j\times\dbinom{(x_i+y_i)-(x_j+y_j)}{x_i-x_j}$ 和所有的不合法路径是一一对应的了。

那么这个状态转移方程就是正确的了。

现在的问题就是 $\dbinom{n}{m}\bmod P$ 应该怎么求。

显然，当 $P=1000003\in prime$ 时，这个可以用 Lucas 定理直接算。

但是当 $P=1019663265=3\times5\times6793\times10007$ 时，就不能直接用 Lucas 算了。

这个需要用中国剩余定理来做，不会的请先去做一下 [【模板】中国剩余定理(CRT)/曹冲养猪](https://www.luogu.com.cn/problem/P1495)。

中国剩余定理的结论大概是这个东西：

对于一个方程组：

$\begin{cases}
x\equiv a_1 \pmod {p_1}\\
x\equiv a_2 \pmod {p_2}\\
\cdots\\
x\equiv a_k \pmod {p_k}
\end{cases}$

其中 $p_1,p_2,\dots,p_k$ 两两互质。

设 $M=\prod\limits_{i=1}^{k}p_i$，$m_i=\dfrac{M}{p_i}$，$t_i$ 是 $m_i$ 模 $p_i$ 意义下的逆元。那么 $x$ 的一个特殊解就是 $x_0=\sum\limits_{i=1}^{k}a_im_it_i$。

然后又因为 $x$ 一定能表示成 $a\times M+b$ 的形式，所以 $x$ 的最小非负数解就是 $x_0\bmod M$。

这个题中，未知数 $x$ 就是 $\dbinom{n}{m}$，我们要求 $x\bmod P$，然后我们设 $p_1=3$、$p_2=5$、$p_3=6793$、$p_4=10007$，那么 $M$ 就是这题中的 $P$。

然后我们还知道 $a_1=x\bmod p_1$、$a_2=x\bmod p_2$、$a_3=x\bmod p_3$、$a_4=x\bmod p_4$ 的值（这些都可以用 Lucas 定理求出来）。

那么我们通过中国剩余定理就可以把 $x\bmod P$ 算出来了。

具体代码如下：

```cpp
#include<bits/stdc++.h>

#define T 210
#define ll long long

using namespace std;

struct Point
{
	int x,y;
	Point(){};
	Point(int a,int b){x=a,y=b;}
}q[T];

int n,m,num,P;
ll f[T];

ll poww(ll a,ll b,ll p)
{
	ll ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ans;
}

namespace mod1//p=1019663265的情况
{
	const ll M=1019663265ll,p[5]={0,3,5,6793,10007};
	ll m[5],t[5],fac[5][10010],inv[5][10010];
	ll a[5];
	void exgcd(ll a,ll b,ll &x,ll &y)
	{
		if(!b)
		{
			x=1,y=0;
			return;
		}
		exgcd(b,a%b,x,y);
		ll tmp=x;
		x=y;
		y=tmp-a/b*y;
	}
	void init()
	{
		for(int i=1;i<=4;i++)
		{
			m[i]=M/p[i];
			ll x,y;
			exgcd(m[i],p[i],x,y);//通过exgcd求逆元
			t[i]=(x%p[i]+p[i])%p[i];
		}
		for(int i=1;i<=4;i++)
		{
			fac[i][0]=1;
			for(int j=1;j<p[i];j++)
				fac[i][j]=fac[i][j-1]*j%p[i];
		}
		for(int i=1;i<=4;i++)
			for(int j=0;j<p[i];j++)
				inv[i][j]=poww(fac[i][j],p[i]-2,p[i]);
	}
	ll C(ll n,ll m,int k)
	{
		if(n<m) return 0;
		if(!m) return 1;
		return fac[k][n]*inv[k][n-m]%p[k]*inv[k][m]%p[k];
	}
	ll Lucas(ll n,ll m,int k)
	{
		if(n<m) return 0;
		if(!m) return 1;
		return C(n%p[k],m%p[k],k)*Lucas(n/p[k],m/p[k],k)%p[k];
	}
	ll solve(ll n,ll mm)
	{
		ll x=0;
		for(int i=1;i<=4;i++)
		{
			a[i]=Lucas(n,mm,i);
			x=(x+a[i]*m[i]%M*t[i]%M)%M;//求x的解
		}
		return x;
	}
}

namespace mod2//p=1000003的情况
{
	const ll p=1000003;
	ll fac[1000005],inv[1000005];
	void init()
	{
		fac[0]=1;
		for(int i=1;i<p;i++)
			fac[i]=fac[i-1]*i%p;
		for(int i=0;i<p;i++)
			inv[i]=poww(fac[i],p-2,p);
	}
	ll C(ll n,ll m)
	{
		if(n<m) return 0;
		if(!m) return 1;
		return fac[n]*inv[n-m]%p*inv[m]%p;
	}
	ll Lucas(ll n,ll m)
	{
		if(n<m) return 0;
		if(!m) return 1;
		return C(n%p,m%p)*Lucas(n/p,m/p)%p;
	}
}

bool cmp(Point a,Point b)
{
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}

int main()
{
	scanf("%d%d%d%d",&n,&m,&num,&P);
	if(P==1000003) mod2::init();
	else mod1::init();
	for(int i=1;i<=num;i++)
		scanf("%d%d",&q[i].x,&q[i].y);
	q[num+1]=Point(n,m);
	sort(q+1,q+num+2,cmp);
	for(int i=1;i<=num+1;i++)
	{
		if(P==1000003) f[i]=mod2::Lucas(q[i].x+q[i].y,q[i].x);
		else f[i]=mod1::solve(q[i].x+q[i].y,q[i].x);
		for(int j=1;j<i;j++)
		{
			if(q[j].x<=q[i].x&&q[j].y<=q[i].y)
			{
				if(P==1000003) f[i]=(f[i]-f[j]*(mod2::Lucas(q[i].x+q[i].y-q[j].x-q[j].y,q[i].x-q[j].x))%P+P)%P;
				else f[i]=(f[i]-f[j]*(mod1::solve(q[i].x+q[i].y-q[j].x-q[j].y,q[i].x-q[j].x))%P+P)%P;
			}
		}
	}
	printf("%lld\n",f[num+1]);
	return 0;
}
```

---

## 作者：Ame__ (赞：2)

### 简化题面

给定$N*M$的网格图，$T$个坏点，求左上$(0,0)$走到右下$(n,m)$不经过坏点的方案数$N,M\le10^9$,$T\le200$

### 解题思路

设$dp[i]$表示从$(0,0)$走到第$i$个坏点（终点算作第$T+1$个坏点），中途不经过其它坏点的方案数。那么直接求$dp[i]$显然很乱而且不好做，因此我们可以考虑单步容斥，可以想到总方案数-经过坏点的方案数推出$dp[i]$。

那么考虑总方案数量从$(0,0)$走到$(n,m)$的方案数为$C_{n+m}^{n}$，可以画图自己理解一下，若要解释就是相当于用$n$个右和$m$个上组成一个长度为$n+m$的序列，方案数$C_{n+m}^n$

紧接着考虑如何求出经过坏点的方案数，枚举其经过的第一个坏点，那么它的贡献为(从$(0,0)$走到该点，中途不经过其它坏点的方案数)*(从这个坏点走到当前点的方案数)。

对于第一部分第一个即为坏点的$dp$值，第二个用照上面的方法用组合数求出，即为$C_{x[i]-x[j]+y[i]-y[j]}^{x[i]-x[j]}$。

最后的答案就是$dp[T+1]$

大体思路是这样，细节方面，对于模数$P$有两个取值，一个是质数，一个不是质数，对于质数$1000003$直接费马小定理求逆元处理即可，但对于$1019663265$，对其进行质因数分解之后可得为$3*5*6793*10007$，使用$lucas$定理分别进行处理之后再使用中国剩余定理对

$\begin{cases}
C_n^m≡a_1\ (\bmod\ 3)\\
C_n^m≡a_2\ (\bmod\ 5)\\
C_n^m≡a_3\ (\bmod\ 6793)\ \\
C_n^m≡a_4\ (\bmod\ 10007)
\end{cases}$ 

进行合并处理得到，最后才可以得到结果，时间复杂度应该是$O(T^2logn)$

### $Code$
```.cpp
#include<bits/stdc++.h>
    
#define LL long long
    
#define _ 0
    
#define int long long

using namespace std;
    
/*Grievous Lady*/
    
template <typename T> void read(T & t){
    t = 0;int f = 1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f =- 1;ch = getchar();}
    do{t = t * 10 + ch - '0';ch = getchar();}while(ch >= '0' && ch <= '9');t *= f;
}
    
const int kato = 1e6 + 10;

#define MOD 1019663265

LL mod[6] = {0 , 1000003 , 3 , 5 , 6793 , 10007};

LL n , m , t , p , flag;

LL fac[6][kato] , dp[233];

struct node{
    LL x , y;

    bool operator <(const node &a)const{
        return a.x == x ? y < a.y : x < a.x;
    }
}e[233];

inline LL quick_pow(LL a , LL b , LL mod){
    LL res = 1;
    for(; b ; b >>= 1 , a = a * a % mod){
        if(b & 1){
            res = res * a % mod;
        }
    }
    return res % mod;
}

inline LL c(LL a , LL b , LL p){
    if(a < b) return 0;
    return fac[p][a] * quick_pow(fac[p][b] , mod[p] - 2 , mod[p]) % mod[p] * quick_pow(fac[p][a - b] , mod[p] - 2 , mod[p]) % mod[p];
}

inline LL lucas(LL a , LL b , LL p){
    if(b == 0) return 1;
    return lucas(a / mod[p] , b / mod[p] , p) * c(a % mod[p] , b % mod[p] , p) % mod[p];
}

inline LL CRT(LL n , LL m){
    if(flag == 1) return lucas(n , m , 1);
    else{
        LL res = 0;
        for(int i = 2;i <= 5;i ++) res = (res + MOD / mod[i] * quick_pow(MOD / mod[i] , mod[i] - 2 , mod[i]) % MOD * lucas(n , m , i)) % MOD;
        return res;
    }
}

inline int Ame_(){
    read(n) , read(m) , read(t) , read(p);
    if(p == 1000003) flag = 1;
    else flag = 0;
    for(int i = 1;i <= 5;i ++){
        fac[i][0] = 1;
        for(int j = 1;j < mod[i];j ++){
            fac[i][j] = fac[i][j - 1] * j % mod[i];
        }
    }
    for(int i = 1;i <= t;i ++){
        read(e[i].x) , read(e[i].y);
    }
    e[++ t].x = n , e[t].y = m;
    sort(e + 1 , e + 1 + t);
    for(int i = 1;i <= t;i ++){
        dp[i] = CRT(e[i].x + e[i].y , e[i].x);
        for(int j = 1;j < i;j ++){
            if(e[j].y <= e[i].y){
                dp[i] = (dp[i] - dp[j] * CRT(e[i].x - e[j].x + e[i].y - e[j].y , e[i].x - e[j].x) % p + p) % p;
            }
        }
    }
    printf("%lld\n" , dp[t]);
    return ~~(0^_^0);
}
    
int Ame__ = Ame_();
    
signed main(){;}
```

---

## 作者：1234567890sjx (赞：0)

rjq 某天中午出出来的题。好厉害的组合数学 + dp，好厉害的 rjq。

首先发现题面中给出了两个不同的 $p$ 取值即 $p\in\lbrace10^6+3,1019663265\rbrace$。因此猜测要对这两个 $p$ 进行分类讨论。根据必应得到 $10^6+3$ [是质数](https://zh.numberempire.com/1000003)，而 $1019663265$ [则不是](https://zh.numberempire.com/1019663265)。

然后打开虚拟机终端调用 `factor` 得到 $1019663265=3\times 5\times 6793\times 10007$，于是立即想到 [SDOI2010 古代猪文](/problem/P2480) 的套路，将大模数 $1019663265$ 的四个质因数分别用 ~~yhb~~ Lucas 定理求出四个解，然后用 CRT 暴力合并（可以启发式合并）即可。

然后考虑开始做这个题。根据 [NOI2016 网格](/problem/P1173) 的套路，把所有有用的“障碍点”单独拿出来 dp。因为到最后必须要走到 $(n,m)$ 所以说把 $(n,m)$ 点也放到障碍点里去。令 $f_i$ 表示从起点开始走，走到第 $i$ 个障碍点，而不经过其他的障碍点的方案数。则直接考虑经典容斥，有 $f_i=\binom{x_i+y_i}{x_i}-\sum\limits_{j=1}^{i-1} f_j\binom{x_i-x_j+y_i-y_j}{x_i-x_j}$，其中 $(x_i,y_i)$ 为第 $i$ 个障碍点的坐标。需要特判一下组合数不合法（即需要走回头路）的情况。最终答案即为 $f_{T+1}$。

因为 $T$ 过于小，因此时间复杂度为 $O(T^2\log n)$ 暴力即可以通过本题。~~rjq 什么逆天。~~

---

## 作者：creation_hy (赞：0)

~~我上次看到这题还是在上次~~

$60$ 分做法：

过于经典的容斥，$f_i$ 表示从起点走到点 $i$ 路上不经过其他点的方案数，容易推出

$\displaystyle f_i = C_{x_i+y_i}^{x_i} - \sum_{j=1}^{i-1}f_j C_{x_i-x_j+y_i-y_j}^{x_i-x_j}$

可以获得 $P=10^6+3$ 的部分分。

正解：

通过~~百度搜索~~发现题面的大模数可以分解为 $3\times5\times6793\times10007$。

由于每个质数都很小，可以先通过 lucas 定理求出方案数取模后分别是多少，然后就可以列出四条形如 $ans \equiv b_i(\bmod\ p_i)$ 的式子，用 CRT 合并即可。

时间复杂度 $O(T^2\log n+p)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 205;
const int M = 2e5 + 5;
int n, mod;
ll f[N], g[4][N];
struct node
{
    int x, y;
    inline bool operator<(const node &t) const
    {
        return x == t.x ? y < t.y : x < t.x;
    }
} a[N];
struct comb
{
    int mod;
    ll fac[M], inv[M];
    inline ll qpow(ll x, ll y)
    {
        ll res = 1;
        while (y)
        {
            if (y & 1)
                res = res * x % mod;
            x = x * x % mod;
            y >>= 1;
        }
        return res;
    }
    inline void build(int n)
    {
        fac[0] = 1;
        for (int i = 1; i <= n; i++)
            fac[i] = fac[i - 1] * i % mod;
        inv[n] = qpow(fac[n], mod - 2);
        for (int i = n; i; i--)
            inv[i - 1] = inv[i] * i % mod;
    }
    inline ll C(int x, int y)
    {
        return fac[x] * inv[y] % mod * inv[x - y] % mod;
    }
    inline ll lucas(int x, int y)
    {
        if (x < mod && y < mod)
            return C(x, y);
        return lucas(x % mod, y % mod) * lucas(x / mod, y / mod) % mod;
    }
};
inline void solve1()
{
    comb C;
    C.mod = mod, C.build(2e5);
    for (int i = 1; i <= n; i++)
    {
        f[i] = C.C(a[i].x + a[i].y, a[i].x);
        for (int j = 1; j < i; j++)
            if (a[i].x >= a[j].x && a[i].y >= a[j].y)
                (f[i] += mod - f[j] * C.C(a[i].x - a[j].x + a[i].y - a[j].y, a[i].x - a[j].x) % mod) %= mod;
    }
}
inline void exgcd(ll a, ll b, ll &x, ll &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    ll k = x;
    x = y, y = k - a / b * y;
}
inline void solve2()
{
    comb C[4];
    int p[4] = {3, 5, 6793, 10007};
    for (int t = 0; t < 4; t++)
        C[t].mod = p[t], C[t].build(p[t] - 1);
    for (int t = 0; t < 4; t++)
        for (int i = 1; i <= n; i++)
        {
            g[t][i] = C[t].lucas(a[i].x + a[i].y, a[i].x);
            for (int j = 1; j < i; j++)
                if (a[i].x >= a[j].x && a[i].y >= a[j].y)
                    (g[t][i] += p[t] - g[t][j] * C[t].lucas(a[i].x - a[j].x + a[i].y - a[j].y, a[i].x - a[j].x) % p[t]) %= p[t];
        }
    for (int i = 1; i <= n; i++)
        for (int t = 0; t < 4; t++)
        {
            ll x, y, cur = mod / p[t];
            exgcd(cur, p[t], x, y);
            (f[i] += g[t][i] * cur % mod * x % mod + mod) %= mod;
        }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> a[0].x >> a[0].y >> n >> mod;
    a[n + 1] = a[0];
    for (int i = 1; i <= n; i++)
        cin >> a[i].x >> a[i].y;
    sort(a + 1, a + 1 + n), n++;
    if (mod == 1e6 + 3)
        solve1();
    else
        solve2();
    cout << f[n] << '\n';
    return 0;
}
```

---


# [BJWC2018] 神奇的钟点

## 题目描述

一天，小 L 看到了 3 块钟表，分别显示着 $\texttt{01:08}$、$\texttt{03:40}$、$\texttt{13:52}$。小 L 发现，每块表上的时间都是 $\texttt{hh:mm}$ 的形式，其中 $\texttt{hh}$ 表示小时，$\texttt{mm}$ 表示分钟，而且都不是整点（即 $0\leqslant\texttt{hh}<24$，$1\leqslant\texttt{mm}<60$）。

回想起小学数学老师刚刚讲的关于比例的知识，$\texttt{hh:mm}$ 也表示一个比，它的值等于 $\frac{\texttt{hh}}{\texttt{mm}}$。这时小 L 发现了一件神奇的事情：把这三个钟点加起来会得到 $\texttt{18:40}$，这也是一个不是整点的合法时间（注意小时数要小于 $24$），它对应的比值 $\frac{9}{20}$，与这三个钟点对应的比值 $\frac{1}{8}$、$\frac{3}{40}$、$\frac{1}{4}$ 之和竟然相等！

现在小 L 想知道，把所有的满足这个神奇的性质的 3 个钟点组成的钟点组按照字典序排序后，第 $k$ 小的是什么。

## 说明/提示

**【样例说明】**

注意钟点可以相同。

**【数据规模和约定】**

对于 $30\%$ 的数据，$k\leqslant 1000$。  
对于 $60\%$ 的数据，$k\leqslant 20000$。  
对于 $100\%$ 的数据，$1\leqslant k\leqslant 2\times 10^9$。

## 样例 #1

### 输入

```
65432```

### 输出

```
01:08 03:40 13:52```

## 样例 #2

### 输入

```
1```

### 输出

```
00:01 00:01 00:01```

## 样例 #3

### 输入

```
58```

### 输出

```
00:01 00:02 00:01```

## 样例 #4

### 输入

```
2000000000```

### 输出

```
-1```

# 题解

## 作者：rui_er (赞：12)

~~评价：分段打表练习题。~~

这题第一篇题解，随机跳题跳到这题就来写了。。

第一眼看这题，感觉像是数学题，但是手玩了一会又感觉符合题意的钟点不多（远没有 $2\times 10^9$ 那么吓人），还没啥规律，于是想先枚举一遍可能的答案，看看有多少个，尝试把表打出来。于是就写了个 $\mathcal{O}(24^360^3)$ 的暴力，~~根据 WC2022 讲题人的理论这是 $\mathcal{O}(1)$~~。

经过 59.34s 的等待，我们发现答案总共只有 $127034$ 个，于是我们进行打表，得到了一张 2482KB 的大表，改一改尝试提交，发现代码过长交不上去。

直接跑要跑 1min，打表还打不下，于是我们退而求其次，每隔 $K$ 个答案分一段把答案打出来，这样打出 $\frac{127034}{K}$ 个答案，然后段中间的查询暴力去做。首先我们尝试了 $K=5000$，结果 TLE 成了 70/80 分，调整 $K=3000$ 就过了。

AC 之后查百度，没查到这题的解法，不知道分段打表是不是正解，反正我只会这一种。

UPD：查到了一篇这题的[博客](https://blog.csdn.net/weixin_30553837/article/details/95872526)，发现正解也是分段打表做的。

打表代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

int main() {
	freopen("P4483-biaosmall.txt", "w", stdout);
	printf("int ans[44][6]={{0}");
	int tot = 0;
	rep(h1, 0, 23) {
		rep(m1, 1, 59) {
			rep(h2, 0, 23) {
				if(h1 + h2 > 23) break;
				rep(m2, 1, 59) {
					rep(h3, 0, 23) {
						if(h1 + h2 + h3 > 23) break;
						rep(m3, 1, 59) {
							int H = h1 + h2 + h3;
							int M = m1 + m2 + m3;
							H += M / 60;
							M %= 60;
							if(H > 23) break;
							if(!M) continue;
							int p1 = h1 * m2 * m3 + m1 * h2 * m3 + m1 * m2 * h3;
							int q1 = m1 * m2 * m3;
							int p2 = H;
							int q2 = M;
							int g1 = __gcd(p1, q1);
							p1 /= g1; q1 /= g1;
							int g2 = __gcd(p2, q2);
							p2 /= g2; q2 /= g2;
							if(p1 == p2 && q1 == q2) {
								++tot;
								if(tot % 3000 == 1) printf(",{%d,%d,%d,%d,%d,%d}", h1, m1, h2, m2, h3, m3);
							}
						}
					}
				}
			}
		}
	}
	printf("};");
	return 0;
}
```

最终代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const int N = 127034, K = 3000;
int ans[44][6]={ /* 打表的结果，篇幅考虑就不放了*/  };

int n;
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
struct Time {
	int h, m;
	Time(int a=0, int b=0) : h(a), m(b) {}
	~Time() {}
	Time nxt() {
		Time tmp = *this;
		++tmp.m;
		if(tmp.m == 60) {
			++tmp.h;
			tmp.m = 1;
		}
		return tmp;
	}
	bool last() {
		return h == 23 && m == 59;
	}
};

int main() {
	scanf("%d", &n);
	if(n > N) return puts("-1")&0;
	int k = (n - 1) / K + 1;
	Time A = Time(ans[k][0], ans[k][1]);
	Time B = Time(ans[k][2], ans[k][3]);
	Time C = Time(ans[k][4], ans[k][5]);
	rep(T, K*(k-1)+2, n) {
		while(true) {
			if(!C.last()) C = C.nxt();
			else if(!B.last()) B = B.nxt(), C = Time(0, 1);
			else A = A.nxt(), B = C = Time(0, 1);
			int H = A.h + B.h + C.h;
			int M = A.m + B.m + C.m;
			H += M / 60;
			M %= 60;
			if(0 <= H && H <= 23 && 1 <= M && M <= 59) {
				int p1 = A.h * B.m * C.m + A.m * B.h * C.m + A.m * B.m * C.h;
				int q1 = A.m * B.m * C.m;
				int p2 = H;
				int q2 = M;
				int g1 = __gcd(p1, q1);
				p1 /= g1; q1 /= g1;
				int g2 = __gcd(p2, q2);
				p2 /= g2; q2 /= g2;
				if(p1 == p2 && q1 == q2) break;
			}
		}
	}
	printf("%02d:%02d %02d:%02d %02d:%02d\n", A.h, A.m, B.h, B.m, C.h, C.m);
	return 0;
}
```

---

## 作者：lichenghan (赞：1)

大家都在写分段打表啊，其实暴力+卡常+剪枝也能过去。

暴力思路就是枚举题目中的 $3$ 组时间，对于每组时间判断是否符合要求。

主要讲一下剪枝和优化思路。

1. 枚举小时数的时候先判掉和大于 $23$ 的情况。
2. 先枚举所有小时数，再枚举所有分钟数，最后再把所有答案 `sort` 一遍。这样可以让上面剪枝的效果更加明显。
3. 在枚举到第二个分钟数的时候，因为最终比例最多是 $23$，可以先判掉前两个的比例已经大于等于 $23$ 的情况。
4. 不要用 `double`，把需要除法的地方转成乘法。`double` 一是精度有问题，二是运算很慢。

具体见代码。

```cpp
#pragma GCC target("sse,sse2,sse3,sse4,popcnt,abm,mmx,avx,avx2")
//这行代码是火车头上摘下来的，据说洛谷有用，就留着了
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct node{
	int a,b,c,d,e,f;
	bool operator<(const node& oth){//字典序
		if(a!=oth.a) return a<oth.a;
		if(b!=oth.b) return b<oth.b;
		if(c!=oth.c) return c<oth.c;
		if(d!=oth.d) return d<oth.d;
		if(e!=oth.e) return e<oth.e;
		return f<oth.f;
	}
}nds[200000];int cnt=0;//所有答案
int main(){
	//a,c,e是小时，b,d,f是分钟
	for(int a=0;a<24;++a)
	for(int c=0;c<24-a;++c)
	for(int e=0;e<24-a-c;++e)//1,2
	for(int b=1;b<60;++b)
	for(int d=1;d<60;++d)if(a*d+c*b<23*b*d)//3
	for(int f=1;f<60;++f){
		int h=a+c+e+(b+d+f)/60;
		int m=(b+d+f)%60;
		if(m==0||h>=24) continue;
		//这里把左右式同时乘上b*d*f*m,并且合并同类项减少运算次数。
		if(((a*d+c*b)*f+e*b*d)*m==h*b*d*f){
			nds[++cnt]={a,b,c,d,e,f};
		}
	}
	sort(nds+1,nds+cnt+1);
	int k;
	scanf("%d",&k);
	if(k>cnt){
		puts("-1");
	}else{
		printf("%02d:%02d %02d:%02d %02d:%02d",nds[k].a,nds[k].b,nds[k].c,nds[k].d,nds[k].e,nds[k].f);
	}
}
```

[喜提最慢，最短解](https://www.luogu.com.cn/record/102220170)（955B，总共 9.08s，最慢 910ms，C++20 O2）

---

## 作者：Eason_AC (赞：1)

## Content
给出如下定义：

- 定义钟点 $hh:mm$ 合法，当且仅当 $hh\in[0,23]$，$mm\in\bf[1,59]$。
- 定义六元组 $(a,b,c,d,e,f)$ 是好的，当且仅当满足如下条件：
    - 钟点 $a:b$，$c:d$，$e:f$ 合法。
    - 这三个钟点加起来的钟点 $A:B$ 合法。
    - $\dfrac ab+\dfrac cd+\dfrac ef=\dfrac AB$。

现在，请你求出按字典序排列后第 $k$ 个满足条件的六元组，并按照形如 `a:b c:d e:f` 的格式输出（如果某个数只有一位数，则在其前面补一个前导 $0$），如果不存在，输出 `-1`。

**数据范围：$1\leqslant k\leqslant 2\times 10^9$。**
## Solution
这题乍一看不太好想，于是考虑乱搞。

我们不妨把所有满足条件的六元组全部打表打出来。打出来之后，我们发现满足条件的六元组只有 $127034$ 个。然而，如果直接把这 $127034$ 个六元组全部弄进代码中，那么代码长度肯定是不能够接受的。那么这时候我们该怎么办？

我们不妨选定一个整数 $B$。然后每 $B$ 个中只选一个，其余的可以通过这些选出的 $\lfloor\frac{127034}B\rfloor$ 个六元组推出来。这么一来，如果 $B$ 选得恰当，问题就迎刃而解了，甚至可以快得飞起。以下代码定 $B=200$，最慢的点不过 77ms。
## Code
```cpp
namespace Solution {
#define int ll
	const int a1[] = {限于篇幅不予展示};
	const int a2[] = {限于篇幅不予展示};
	const int a3[] = {限于篇幅不予展示};
	const int a4[] = {限于篇幅不予展示};
	const int a5[] = {限于篇幅不予展示};
	const int a6[] = {限于篇幅不予展示};
	
	iv Main() {
		int k; read(k);
		if(k > 127034) no1;
		else if(!(k % 200)) printf("%02lld:%02lld %02lld:%02lld %02lld:%02lld", a1[k / 200], a2[k / 200], a3[k / 200], a4[k / 200], a5[k / 200], a6[k / 200]);
		else {
			int h1 = a1[k / 200], m1 = a2[k / 200], h2 = a3[k / 200], m2 = a4[k / 200], h3 = a5[k / 200], m3 = a6[k / 200], cnt = k / 200 * 200;
			m3++;
			if(m3 >= 60) h3++, m3 = 1;
			if(h3 >= 24) m2++, h3 = 0;
			if(m2 >= 60) h2++, m2 = 1;
			if(h2 >= 24) m1++, h2 = 0;
			if(m1 >= 60) h1++, m1 = 1;
			while(1) {
				if(!m1 || !m2 || !m3) {
					m3++;
					if(m3 >= 60) h3++, m3 = 1;
					if(h3 >= 24) m2++, h3 = 0;
					if(m2 >= 60) h2++, m2 = 1;
					if(h2 >= 24) m1++, h2 = 0;
					if(m1 >= 60) h1++, m1 = 1;
					continue;
				}
				int a = h1 + h2 + h3, b = m1 + m2 + m3;
				a += b / 60, b %= 60;
				if(a > 23) {
					m3++;
					if(m3 >= 60) h3++, m3 = 1;
					if(h3 >= 24) m2++, h3 = 0;
					if(m2 >= 60) h2++, m2 = 1;
					if(h2 >= 24) m1++, h2 = 0;
					if(m1 >= 60) h1++, m1 = 1;
					continue;
				}
				int g1 = __gcd(h1, m1), g2 = __gcd(h2, m2), g3 = __gcd(h3, m3), g = __gcd(a, b);
				int _a1 = h1, _b1 = m1, _a2 = h2, _b2 = m2, _a3 = h3, _b3 = m3;
				_a1 /= g1, _b1 /= g1, _a2 /= g2, _b2 /= g2, _a3 /= g3, _b3 /= g3, a /= g, b /= g;
				int _lcm = __detail :: __lcm(_b1, __detail :: __lcm(_b2, _b3));
				_a1 *= (_lcm / _b1), _a2 *= (_lcm / _b2), _a3 *= (_lcm / _b3);
				int _a = _a1 + _a2 + _a3, _b = _lcm;
				g = __gcd(_a, _b), _a /= g, _b /= g;
				if(_a == a && _b == b) {
					cnt++;
					if(cnt == k) {printf("%02lld:%02lld %02lld:%02lld %02lld:%02lld", h1, m1, h2, m2, h3, m3); break;}
				}
				m3++;
				if(m3 >= 60) h3++, m3 = 0;
				if(h3 >= 24) m2++, h3 = 0;
				if(m2 >= 60) h2++, m2 = 0;
				if(h2 >= 24) m1++, h2 = 0;
				if(m1 >= 60) h1++, m1 = 0;
			}
		}
		return;
	}
#undef int
}
```

---


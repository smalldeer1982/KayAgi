# [COCI 2017/2018 #4] Vođe

## 题目描述

众所周知，山羊和绵羊为了它们放牧的田地已经争斗多年。在经历了许多激烈的战斗后，山羊首领和绵羊首领决定会面，尝试为他们的问题找到一个和平的解决方案。经过多小时的讨论，他们同意为每块田地玩一个游戏，胜者将获得在该田地放牧的权利。

游戏的规则是，总共有 $N$ 只动物（可能是山羊或绵羊）围成一个圈（山羊和绵羊的具体顺序由它们的首领协商决定）。在动物 $i$（$1\le i\le N-1$）之后，游戏由动物 $i+1$ 继续，而在动物 $N$ 之后，游戏由动物 $1$ 继续。开始游戏的动物可以从区间 $[1,K]$ 中说出任意一个正整数，但这个数字不能大于 $M$。如果开始游戏的动物说了数字 $j$，那么下一个动物可以在区间 $[j+1,j+K]$ 中说一个数字，但这个数字也不能大于 $M$。换句话说，每只动物可以说出比前一只动物所说的数字大至少 $1$、最多 $K$ 的数字，但新数字不能大于 $M$。如果一只动物必须说出数字 $M$，它所在的队伍（山羊或绵羊）就会输掉。

如果山羊和绵羊都以最佳策略进行游戏，对于每个 $i$（$1\le i\le N$），确定如果游戏由第 $i$ 只动物开始，谁将赢得这块田地。

## 说明/提示

在总分值为 $60\%$ 的测试用例中，将满足 $1\le N,M,K\le 500$。

**第一个样例的说明：**

当绵羊先开始时，它可以这样进行游戏：

绵羊以数字 2 开始，之后山羊可以说 3 或 4。在这两种情况下，绵羊可以说 5，之后山羊可以说 6 或 7。在这两种情况下，绵羊可以说 8，之后山羊别无选择只能说 9，从而输掉游戏和田地。

题面翻译由 ChatGPT-4o 提供，123asdf123 修缮。

## 样例 #1

### 输入

```
2 9 2
0 1```

### 输出

```
0 1```

## 样例 #2

### 输入

```
6 499 5
1 0 0 1 1 0```

### 输出

```
0 1 1 1 1 0```

## 样例 #3

### 输入

```
10 100 10
0 0 0 1 1 1 1 0 1 1```

### 输出

```
1 1 1 1 1 1 1 1 1 1```

# 题解

## 作者：qwerty12346 (赞：8)

# [题目传送门](https://www.luogu.com.cn/problem/P4522)

## 题意

这题就是问那个团队会赢。

## 思路

直接动态规划来做这题，然后优化一下，再用一个前缀和，就能满分，如果不用前缀和这题只能拿 $70$ 分。我们的策略也很好判断，对于第 $i$ 只羊，如果后面 $k$ 只羊都不是自己的同类，那么此时我们的状态就只需要将败变胜，将胜变败就可以了。

## 状态定义

$dp_{i,j}$ 表示轮到第 $i$ 个人，还剩 $j$ 个石子时能否胜利。

## 边界考虑

要把 $dp_{i,0}$ 的初始值赋值为 $0$。但因为 $dp$ 数组是全局变量。初始值本来就是 $0$。所以可以不用循环赋值。

### 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[5005][5005],b[10005],c[10005];
bool f[5005][5005];
int main(){
    cin>>n>>m>>k;
    for(int i=0;i<n;i++)
    {
	cin>>c[i];
	f[i][1]=!c[i];
	b[i]=(i+1)%n;
	a[i][1]=!c[i];
    }
    for(int i=2;i<=m;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(a[b[j]][i-1]-a[b[j]][max(0,i-k-1)]==((!c[j])*min(i-1,k)))f[j][i]=!c[j];
	    else f[j][i]=c[j];
	    a[j][i]=a[j][i-1]+f[j][i];
	}
    }
    for(int i=0;i<n;i++)cout<<f[i][m]<<" ";
    return 0;
} 
```


---

## 作者：mol_low (赞：3)

[题目传送门](https://www.luogu.org/problem/P4522)
# 分析
~~显然这是一道博弈论~~，我们思考胜利方式。

我们知道一类问题：两人分别取数(由上一人取的数决定区间)，最终被迫取到$m$的人败。显然，这类问题是此题的简化版(因为不存在连续取数的情况)。对于这类题目，我们数学上的解决方法一般是从结果往前推，推出每一个**必胜点**(若得到这个点，则可以得到下一个，以此类推，最终得到$m-1$而使敌方必败)。

有了这类问题的基本解决思路，我们来解决本题中同一种族可以连续取数的情况。我们当前考虑第$i$头羊取$j$这个数的情况。  
若$[j+1,j+k]$中有必胜点且下一头羊是**同种族的羊**，则$j$点也是必胜点。这是因为$[j+1,j+k]$是下一头羊的势力范围，它拿到了必胜点，那么$j$根据我们上文的分析，也是必胜点。我们只需要查找$[j+1,j+k]$中有无必胜点即可。普通的暴力无法胜任，我们可以通过后缀和(当然也可以前缀，只不过要将答案的更新从从后往前变为从前往后)发现区间内有无必胜点(无必胜点则区间和为$0$)。这样我们通过$DP$形式(伪$DP$)推出答案。

$Code:$(代码采用从前往后推的形式)
```
#pragma GCC optimize(3)
#include <iostream>
#include <cstdio>
using namespace std;
#define N 5000

int n , m , k , next;
int animal[N + 2];
int sum[N + 2][N + 2];
bool f[N + 2][N + 2];

int main() {
	scanf("%d %d %d", &n , &m , &k);
	for(int i = 1; i <= n; ++ i) scanf("%d", &animal[i]);
	for(int j = 1; j <= m; ++ j)
		for(int i = 1; i <= n; ++ i) {
			int next = i % n + 1;
			int len = max(1 , j - k);
			int S = sum[next][j - 1] - sum[next][len - 1];
			if(animal[i] != animal[next]) f[i][j] = S;
			else {
				if(S == j - len) f[i][j] = 0;
				else f[i][j] = 1;
			}
			sum[i][j] = sum[i][j - 1] + (!f[i][j]);
		}
	for(int i = 1; i <= n; ++ i) printf("%d ", !(f[i][m] ^ animal[i]));
	return 0;
}
```

---

## 作者：_zexal_ (赞：2)

## 思路
考虑动态规划。我们用 $f_{i,j}$ 来表示状态。$f_i$ 表示第 $i$ 只羊，$f_j$ 表示当前报道第几个了。我们的状态也很好判断，对于第 $i$ 只羊，如果后面 $k$ 只羊都不是自己的同类，那么此时我们的状态就需要转换，如果是必败态，那么就转化为必胜态，否则反之。这样我们就可以得到一个时间复杂度为 $O(nmk)$ 的 $70$ 分代码。
## 优化
我们可不可以通过一些方法使时间复杂度为 $O(nm)$ 呢？答案是可以的，我们可以通过线段树等方法维护。但这里，我使用前缀和，我们用 $sum_i$ 表示。当 $i$ 为 $0$ 时，若　$sum_{i+k+1} - sum_{i+1} = k$ 时候，后面将会无同类，转换状态，否则反之。这样时间复杂度就转化为了 $O(nm)$。
## Code
```cpp
#include<bits/stdc++.h>
#define s 5005
using namespace std;
int dp[s][s],Sum[s][s],nxt[s],win[s];
int N,M,K; 
int main(){
//	freopen("kami.in","r",stdin);
//	freopen("kami.out","w",stdout);
	cin>>N>>M>>K;
	for(int i=0;i<N;i++){
		cin>>win[i];
		dp[i][1]=!win[i];
		nxt[i]=(i+1)%N;
		Sum[i][1]=!win[i];
	}
	for(int i=2;i<=M;i++){
		for(int j=0;j<N;j++){
			int Sumer=Sum[nxt[j]][i-1]-Sum[nxt[j]][max(0,i-K-1)];
			if(Sumer==((!win[j])*min(i-1,K))) dp[j][i]=!win[j];
			else dp[j][i]=win[j];
			Sum[j][i]=Sum[j][i-1]+dp[j][i];
		}
	}
	for(int i=0;i<N;i++){
		cout<<dp[i][M]<<" ";
	}
	return 0;
} 
```


---

## 作者：C20203030 (赞：2)

## 一、题目
[点此看题](https://www.luogu.com.cn/problem/P4522)
## 二、解法
设$f[i][j]$为轮到第$i$个人，还剩$j$颗石子的胜负态，暴力转移$O(n^3)$，考虑前缀和优化。

设$l$为取最多石子能到达的数量，我们可以求得$[l,j-1]$的胜负态之和，现在讨论先后手的队伍：
- 如果先后手同属一队，那么和必须包含至少一个必胜态当前状态必胜，否则必败。
- 如果属于不同对，那么和只要包含至少一个必败态当前状态必胜，否则必败。

在$dp$时顺便维护一下前缀和即可，时间复杂度$O(n^2)$

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int M = 5005;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m,k,a[M],f[M][M],s[M][M];
int main()
{
    n=read();m=read();k=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    for(int j=1;j<=m;j++)
        for(int i=1;i<=n;i++)
        {
            int t=i%n+1,l=max(1,j-k);
            int tmp=s[t][j-1]-s[t][l-1];
            if(a[i]==a[t])
            {
                if(tmp==0) f[i][j]=0;
                else f[i][j]=1;
            }
            else
            {
                if(tmp!=j-l) f[i][j]=1;
                else f[i][j]=0;
            }
            s[i][j]=s[i][j-1]+f[i][j];
        }
    for(int i=1;i<=n;i++)
        printf("%d ",!(f[i][m]^a[i]));
}

```



---

## 作者：Kelvin2009 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4522)

这是一道状博弈论加前缀和的动态规划。

首先设计状态：$dp_{i,j}$ 表示当前枚举到了第 $i$ 头羊，对于总限制 $m$，还有 $j$ 的取数空间。

有了状态设计，然后可以考虑转移方程。设当前状态是 $dp_{i,j}$，分为两种情况：

1. 与它的下一头羊同队。只要下一头羊有必胜策略，该状态也一定必胜，反之必败。
2. 与它的下一头羊异队。只要下一头羊有必败策略，该状态也一定必胜，反之必败。

特殊的：由于直接枚举下一头羊的所有状态会超时，考虑用前缀和记录一头羊的状态和进行判断。

------------
代码：

------------

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int range=5005;
bool flag[range],dp[range][range];
int n,m,k,beg,point,tem_sum,sum[range][range];
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++) scanf("%d",&flag[i]);
	for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) point=j%n+1,beg=max(1,i-k),tem_sum=sum[point][i-1]-sum[point][beg-1],dp[j][i]=(flag[j]==flag[point])?(tem_sum):(tem_sum!=i-beg),sum[j][i]=sum[j][i-1]+dp[j][i];
	for(int i=1;i<=n;i++) printf("%d ",!(dp[i][m]^flag[i]));
	return 0;
}
```

---

## 作者：SuBtitle (赞：1)

# P4522 [COCI2017-2018#4] Vođe

[题目链接](https://www.luogu.com.cn/problem/P4522)

## 分析

#### 首先将问题转换

- 每个人只能在上一个人报的数后增加 $1\sim k$，报出 $m$ 的组失败。
- 相当于有 $m$ 个石子，每个人可以取 $1\sim k$ 个，最后取完的组失败。

#### 考虑 dp

- 设 $dp_{i,j}$ 表示轮到第 $i$ 个人，还剩 $j$ 个石子时能/否胜利。
- 当第 $i$ 个人有某种取用方案使其胜利时，那 $dp_{i,j}$ 就为 $1$，如果不论取多少石子都不能获胜，那 $dp_{i,j}$ 就为 $0$：
  - 如果 $i$ 的下一个人 $nex$ 与 $i$ 同队，那 $dp_{nex,j-1\sim k}$ 中有 $1$ 则 $dp_{i,j}$ 为 $1$；
  - 如果 $nex$ 与 $i$ 异队，那 $dp_{nex,j-1\sim k}$ 中有 $0$ 则 $dp_{i,j}$ 为 $1$。
- 时间复杂度 $O(nmk)$。

#### 考虑优化

- 发现影响 $dp_{i,j}$ 的取值的区间是连续的，于是可以考虑前缀和优化。
- 设 $s_{i,j}$ 表示 $\sum_{t=1}^j dp_{i,t}$，于是：
  - 如果 $nex$ 与 $i$ 同队，那 $s_{nex,j-1}-s_{nex,j-k-1}>0$ 则 $dp_{i,j}$ 为 $1$；
  - 如果 $nex$ 与 $i$ 异队，那 $s_{nex,j-1}-s_{nex,j-k-1}<k$ 则 $dp_{i,j}$ 为 $1$。
- 注意 $j-k-1$ 可能为 $-1$，所以要将 $s$ 的下标移一位。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=5010;
int n,m,q,a[N],s[N][N];
bool dp[N][N];

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)
		dp[i][0]=0;
	for(int j=1;j<m;++j)
	{
		for(int i=1;i<=n;++i)
		{
			int lim=min(q,j);
			if(a[i]==a[i%n+1])
				dp[i][j]=!!(s[i%n+1][j]-s[i%n+1][j-lim]);
			else
				dp[i][j]=!!(lim-s[i%n+1][j]+s[i%n+1][j-lim]);
			s[i][j+1]=s[i][j]+dp[i][j];
		}
	}
	for(int i=1;i<=n;++i)
		printf("%d ",!a[i]^dp[i][m-1]);
	return 0;
}
```





---

## 作者：complete_binary_tree (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P4522)

一道典型的 $\text{dp}$。~~然后同机房的巨佬[快斗游鹿](https://www.luogu.com.cn/article/ou2wmozd)用寄搜过了~~

我们可以把报 $m$ 个数想成有 $m$ 个石子，每次可以取 $[1,k]$ 个，这样比较好理解。

我们可以设 $dp_{i,j}$ 为第 $i$ 位还剩 $j$ 个石子是哪队赢。那么显然，$j=1$ 的时候肯定是非 $a_i$（$a_i$ 指的是第 $i$ 位属于哪队，下同）赢，因为取走最后一个石子（第 $m$ 个石子的人）必败。

考虑如何转移。

由于这个人可以取 $[1,k]$ 个石子，所以要从 $(j, j - k]$ 转移。

那么就分为这些情况：

- 如果这个区间的数都是同一个，那么 $dp_{i,j}$ 肯定也是这个数，因为你无论怎么选都是它赢。

- 否则区间里的数有两种，那么第 $i$ 个人可以~~费尽心机地~~取石子来保证他们这队必胜。

在代码中这个分类讨论可以进行一些小小的优化来使代码更短。详见代码。

这样就是 $O(nmk)$ 的 $\text{dp}$ 了，但是，这样是过不了的。

我们发现 $(j, j - k]$ 的信息可以做一个前缀和维护，这样，如果和为 $0$ 则区间全 $0$，如果和为 $k$（当然小于 $k$ 的话有一些特殊的边界，请读者自己思考）那么区间全 $1$。

那么现在就是 $O(nm)$ 的复杂度了，肯定能过。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5005;

int dp[N][N]; //0必败1必胜
int pre[N][N]; //dp的前缀和
int a[N], n, m, k;

int main(){
	scanf( "%d%d%d", &n, &m, &k );
	for( int i = 1; i <= n; ++i ){
		scanf( "%d", &a[i] );
		dp[i][1] = !a[i]; //剩下1石子，取走必败
		pre[i][1] = dp[i][1];
	}
	for( int i = 2; i <= m; ++i ){ //剩余i步
		for( int j = 1; j <= n; ++j ){ //第j个人
			//dp[j][i]可从dp[j][i - 1]转移
			int sum = pre[j % n + 1][i - 1] - pre[j % n + 1][max( 0, i - k - 1 )], //首先计算赢的次数
				num = min( i - 1, k ); //还有个数
			//然后，如果这位是0，那么前k个全是1的时候它不行，即 num = sum 时；反之，这位是1，那么前k个全是0就不行
			//所以是 sum == num * !a[j] 的时候dp的值是!a[j]
			if( sum == ( !a[j] ) * num ) dp[j][i] = !a[j];
			//否则它是可以的
			else dp[j][i] = a[j];
			//更新前缀和
			pre[j][i] = pre[j][i - 1] + dp[j][i];
		}
	}
	for( int i = 1; i <= n; ++i ) printf( "%d ", dp[i][m] );
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：0)

考虑直接模拟博弈过程，设 $f_{i,k}$ 表示到点 $i$，报的数到 $x$ 的胜负情况。假设已经知道 $f_{i+1,x+1}$ 到 $f_{i+1,x+k}$ 的胜负情况：

- 如果 $i+1$ 和 $i$ 是队友，那么只要 $i+1$ 的状态都是己方败，己方必败，否则己方必胜。

- 如果不是队友，那么只要 $i+1$ 的状态出现己方败的情况，那己方必败，否则必胜。

直接记搜即可。状态数是 $O(n^2)$ 的。

```cpp
#include<bits/stdc++.h>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <vector>
#include <map>
#include <queue>
#include <algorithm>
#include <math.h>
#include <cstdio>
//#define int long long
using namespace std;
const int N=5e3+5;
int n,m,k,ccc;
bool op[N];
int f[N][N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int dfs(int u,int num){//当前人，当前报的数 
	if(num>=m)return op[u]^1;//超过了 
	if(f[u][num]!=-1)return f[u][num];
	int flag=op[u];
	bool gg=0;
	int nxt=(u+1==n+1?1ll:u+1);
	for(int i=min(num+k,m);i>=num+1;i--){//ccc++;
		int rs=(f[nxt][i]==-1?dfs(nxt,i):f[nxt][i]);
		if(op[nxt]!=op[u]&&rs==(op[u]^1)){
			flag=rs;break;
		}
		if(op[nxt]==op[u]&&rs==op[u]){
			gg=1;break;
		}
		//if(u==1&&num==5)cout<<rs<<endl;
	}
	//cout<<"!"<<u<<" "<<num<<" "<<flag<<endl;
	if(op[nxt]==op[u]&&!gg)flag=(op[u]^1);
	return f[u][num]=flag;
}
signed main(){
	//freopen("std.in","r",stdin);
	//ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);
	n=read();m=read();k=read();
	for(int i=1;i<=n;i++)op[i]=read();
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++)f[i][j]=-1;
	}
	for(int i=1;i<=n;i++)dfs(i,0);
	//cout<<ccc<<endl;
	for(int i=1;i<=n;i++){
		int flag=op[i]^1;
		for(int j=1;j<=k;j++){
			if(f[i][j]==op[i])flag=op[i];
		}
		cout<<flag<<" ";
	}
	return 0;
}

```

---

## 作者：Yesod (赞：0)

## 思路
设 $ dp_{i,j}$ 为第 $ i $ 头羊，还剩 $ j $ 块石子，而取到倒数第二的石子的羊即 $ dp_{i,j} $ 必赢，而如果后 $ k $ 头羊都不是同类的羊的话，状态需要转换。如果单纯暴力时间无法接受，于是我们可以用前缀和优化，如果后 $ k $  只羊的前缀和值为 $ k $ 说明全是山羊，若为 $ 0 $ 说明全是绵羊，否则两种羊都有。时间复杂度为 $ O(nm)$。
## Code
```
#include <bits/stdc++.h>
using namespace std;
long long n,m,k,dp[5005][5005],sum[5005][5005],ans,r,a[50005],o;
int main(){
	cin>>n>>m>>k;
	for(long long i=1;i<=n;i++)
		cin>>a[i];
	for(long long i=1;i<=n;i++)
		dp[i][m]=sum[i][m]=!a[i];
	for(long long i=m-1;i>=1;i--)
		for(long long j=1;j<=n;j++)
		{
			o=j%n+1;
			r=min(m,i+k);
			ans=sum[o][i+1]-sum[o][r+1];
			if(ans==(!a[j])*(r-i)) dp[j][i]=!a[j];
			else dp[j][i]=a[j];
			sum[j][i]=dp[j][i]+sum[j][i+1];
		}
	for(long long i=1;i<=n;i++)
		cout<<dp[i][1]<<" ";
	return 0;
}

---

## 作者：Hide_In_The_Shadow (赞：0)

## Vode 题解

题意：每个人都有一个团队 $0$ 或 $1$，设上个人报的数为 $x$，则下个人可报的数为 $[x+1,x+k]$，报数 $>m$ 就算输，按顺序循环报数，求以每个人为起点，哪个团队会赢。

分析：$>m$ 就输，那么分两种情况讨论：

1. 下一个人是友军（同一团队），如果该人最少只能报到 $m-1$，那么该团队就会输。
2. 下一个人是敌军（不同团队），如果该人可以报到 $m-1$，那么该团队就会赢。

那么第二种就是必胜态，我们可以定义 $dp[i][j]$ 表示第 $i$ 个人报到 $j$ 是不是必胜态，考虑必胜态的转移，此处也可以分两种情况讨论：

1. 下一个人是友军（同一团队），考虑下一个人的前 $k$ 种状态和，即 $\sum _{k=j-k}^{j-1}dp[i+1][k]$，如果其中有必胜态，即值不为 $0$ 时，当前态就是必胜态，即 $dp[i][j]=1$，反之则当前态必败，$dp[i][j]=0$。
2. 下一个人是敌军（不同团队），也考虑下一个人的前 $k$ 种状态和 $\sum _{k=j-k}^{j-1}dp[i+1][k]$，如果其中全部都是必胜态则当前态必输，$dp[i][j]=0$，反之则当前态必赢，$dp[i][j]=1$。

但是这样做的复杂度是 $O(nmk)$，显然不能通过。

我们可以考虑前缀和优化，用 $sum[i][j]$ 表示 $i$ 的前 $j$ 个状态，但是注意到数组下标不能为负（前 $k$ 个状态中有 $0$ 时，前缀和会访问到 $-1$），所以我们需要将 $dp$ 数组和 $sum$ 数组的第二位下标全部后移一位（其实可以只移动 $sum$ 数组，但是蒟蒻为了方便就都移动了）。

### CODE

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
template<typename T>inline void read(T &x){
	x=0;
	char c=getchar();
	T ret=0;
	while(!isdigit(c))ret|=!(c^'-'),c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	if(ret)x=(~x)+1;
	return;
}
template<typename T>inline void print(T x){
	if(x<0)putchar('-'),x=(~x)+1;
	if(x>9)print(x/10);
	putchar((x-x/10*10)^48);
	return;
}
template<typename T>inline void wr1(T x){
	print(x);
	putchar(' ');
	return;
}
template<typename T>inline void wr2(T x){
	print(x);
	putchar('\n');
	return;
}
int N,M,k,id[5100],sum[5100][5100];
bool dp[5100][5100];
int main(){
//	freopen("vode.in","r",stdin);
//	freopen("vode.out","w",stdout);
	read(N);
	read(M);
	read(k);
	for(int i=1;i<=N;++i){
		read(id[i]);
	}
	for(int j=1;j<=M;++j){//后移一位
		for(int i=1;i<=N;++i){
			int pre=max(1,j-k);//防止访问到负下标
			int nex=i+1;
			if(nex>N)nex=1;//维护环状
			int zt=sum[nex][j-1]-sum[nex][pre-1];//下一个人的前k种状态
			if(id[i]!=id[nex])dp[i][j]=!(zt==j-pre);//不是同一队的处理情况
			else{//同一团队的处理情况
				if(zt)dp[i][j]=1;
				else dp[i][j]=0;
			}
			sum[i][j]=sum[i][j-1]+dp[i][j]; 
		}
	}
	for(int i=1;i<=N;++i){
		if(dp[i][M]){//赢了输出本团队，输了输出另外一个团队
			wr1(id[i]);
		}
		else{
			wr1(id[i]^1);
		}
	}
	return 0;
}
```

---

## 作者：FrozenDream (赞：0)

### 前言：
考试这道题寄了。
### 思路：
这道题就是一个 ~~很简单的~~ DP，第一眼看题目感觉像博弈论，但蒟蒻不会，所以就想到了 DP，很容易便推出了状态转移方程：$dp \left[i\right]\left[j\right]$ 表示第 $i$ 只羊时还剩下 $j$ 颗石子可取，它的值表示此时的状态是最后哪一种羊胜利，很容易可以想到，当还剩下一颗石子时此时将要取的那一只羊必败，所以我们就可以利用这个性质来进行初始化，当然，如果之后连续的一段羊全都是同一种类的，那么，如果现在的这一只羊与之后的羊种类都不同，它肯定是必败的（这里后面可以优化），反之，如果后面的状态有羊和此时的羊种类相同，那么就可以胜利。
### 优化：
当然，以上算法的时间复杂度是 $O(nmk)$，要炸，所以我们可以用一个数组来存 $dp$ 数组的前缀和，如果一段的和为零，那么这一段一定全都是零，反之，如果它的和和此时的长度相等，那么这一段一定全都是一,所以我们就可以利用这个性质来判断每一只羊之后的所有状态是否为必败或者可以通过状态转移到胜利。
### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,k,nxt[100005],sum[5005][5005],n;
bool a[100005],dep[5005][5005];
int main(){
	//freopen("kami.in","r",stdin);
	//freopen("kami.out","w",stdout);
	cin>>n>>m>>k;
	for(int i=0;i<n;i++){
		cin>>a[i];
		nxt[i]=(i+1)%n;
		dep[i][1]=!a[i];
		sum[i][1]=dep[i][1];
	} 
	for(int i=2;i<=m;i++){
		for(int j=0;j<n;j++){
			if(sum[nxt[j]][i-1]-sum[nxt[j]][max(0,i-k-1)]!=(a[j]^1)*min(i-1,k))dep[j][i]=a[j];
			else dep[j][i]=!a[j];
			sum[j][i]=sum[j][i-1]+dep[j][i];
		}
	}
	for(int i=0;i<n;i++){
		cout<<dep[i][m]<<" ";
	}
}
```


---


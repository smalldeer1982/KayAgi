# [FJOI2014] 树的重心

## 题目描述

给定一个 $n$ 个点的树，每个点的编号从 $1 \sim n$ ，问这个树有多少不同的连通子树，和这个树有相同的重心。

其中 $n$ 个点的树指的是 $n$ 个点的最小连通图，显然 $n$ 个点的树有 $n-1$ 条边，去掉这 $n-1$ 条边中的任何一条，原图都不再联通，任意两个点之间由唯一一条路径相连。

对于一个树，树的重心定义为：删掉某点 $i$ 后，若剩余 $k$ 个连通分量，那么定义 $d(i)$ 为这些连通分量中点的个数的最大值，所谓重心，就是使得 $d(i)$ 最小的点 $i$。

基于以上定义，一个树的重心可能会有一个或者两个，题中所要求的联通子树，其重心编号和个数必须和原树的完全一样。

找出给定的树中有多少联通的子树和这个树有相同的重心。输出答案 $\bmod 10007$ 后的结果。

## 说明/提示

对于 $100 \%$ 的数据，满足 $1 \le Q \le 50, 1 \le n \le 200$。

## 样例 #1

### 输入

```
3
2
1 2
3
1 2
2 3
5
1 2
1 3
2 4
2 5```

### 输出

```
Case 1: 1
Case 2: 2
Case 3: 6```

# 题解

## 作者：缄默mio (赞：15)

# 					树的重心
## Description

------------

给你一棵树，求和这棵树重心完全一样的子树个数%10007


------------

## Solve
#### （自认为作法比较神奇，以下内容请谨慎阅读）
### 重心定义：断开后，保证最大联通块节点最少

------------

我们先来推推重心的性质：每个联通块节点数<=总节点数/2
### 先证充分性：重心保证每个联通块节点数<=总节点数/2
比较显然，反之重心可以往最大的联通块下移
### 必要性：每个联通块节点数<=总节点数/2，一定是重心
证明：若要让最大节点变小

![](http://a4.qpic.cn/psb?/V11WHhsI2kAdLw/8HQm75cg6xD1vPkVuFSYcfH4JGry9T2mnFQ2eEchUk4!/c/dFMBAAAAAAAA&ek=1&kp=1&pt=0&bo=bwJgAW8CYAERADc!&tl=1&tm=1566288000&sce=0-12-12&rf=0-18)

------------
重心往最大联通块移动，而新产生的联通块节点数就>=总节点数/2


------------
 
我们再看看两个重心有什么性质：
![](http://a3.qpic.cn/psb?/V11WHhsI2kAdLw/kJgwHlgpzDG6z*O0jyE23ycywE2aBF3Lmw6yfqXlD.Q!/c/dL4AAAAAAAAA&ek=1&kp=1&pt=0&bo=mQJTAZkCUwERADc!&tl=1&tm=1566288000&sce=0-12-12&rf=0-18)
 
意思就是说这时候最大联通块刚好为:总节点数/2

------------
这两个重心相邻
我们先找到重心，把一个作为树的根，重新统计子树数量，并dp


------------

F[i][j]在以i为根的子树中选j个联通(要连i)的点有多少种选法         
枚举x的儿子y，并枚举y选几个联通    
f[x][k]=(f[x][k]+f[y][j]*f[x][k-j])%mod;                            


------------

对于这道题，可以分类讨论：            
#### 1、当有两个重心时                       

------------
比较好处理，我们把重心1作为了根，只需要在除重心2的子树里dp，要满足重心2子树里选的点数=其他子树选的子树和+1
举个栗子：
![](http://a4.qpic.cn/psb?/V11WHhsI2kAdLw/XvS5QJwJe8jqa1Cyuzz87mWG3ApVe1xOmGb98CiuaX0!/c/dL8AAAAAAAAA&ek=1&kp=1&pt=0&bo=YQONAWEDjQERADc!&tl=1&tm=1566288000&sce=0-12-12&rf=0-18)

------------

设w[i]，已经选了i个节点的方案数                         
枚举子树y选择j个，然后w[i]=(w[i]+w[i-j] * f[y][j])%mod           
类似树形dp，但我们只需枚举重心1的直系儿子                   
最后枚举重心2选i个，ans+=f[重心2][i] * w[i];                     
#### 2、有一个重心时

------------

我们设g[i][j]表示共选了i个节点，子树最大联通块为j的方案数           
对于每个子树y
外层枚举i（倒序！！！！！！）                
内层枚举该子树选j个               
由于懒得初始化，我们还要特判i=j时，g[i][j]+=f[y][j]（不然g[0][j] * f[y][j]=0）                
然后对于g的递推 ,因为y子树选了j个后可能取代原来最大联通块成为新的最大联通块，故我们还要在递推时考虑原来最大联通块和j谁大               
最内层枚举前面最大联通块t                     
g[i][max(j,t)]+=g[i-j][t] * f[y][j]                 
对于答案的统计          
根据重心定义，只要最大联通块*2<=总节点数
故我们枚举选了i个节点，子树最大联通块为j               
if(j*2<=(i+1))ans+=g[i][t];
最后还要ans++，因为没有统计只有重心的情况
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
int n,cnt,h[201],f[201][201],k,zx1,zx2,ans,son[201],mod=10007,g[201][201],w[201];
struct pp
{
	int to,next;
}a[201*2];
void add(int x,int y)
{
	cnt++;a[cnt].to=y;a[cnt].next=h[x];h[x]=cnt;
}
void find(int x,int fa)
{
	int maxx=0;son[x]=1;
	for(int i=h[x];i;i=a[i].next)
	{
		int y=a[i].to;
		if(y==fa)continue;
		find(y,x);son[x]+=son[y];maxx=max(son[y],maxx);
	}
	if(n-son[x]>maxx)maxx=n-son[x];
	if(maxx<ans)ans=maxx,k=1,zx1=x;
	else if(maxx==ans)k=2,zx2=x;
	
}
void pre(int x,int fa)
{
	f[x][0]=0;f[x][1]=1;son[x]=1;
	for(int i=h[x];i;i=a[i].next)
	{
		int y=a[i].to;
		if(y==fa)continue;
		pre(y,x);son[x]+=son[y];
		for(int k=son[x];k>=1;k--)
		for(int j=1;j<=min(son[y],k-1);j++)
		f[x][k]=(f[x][k]+f[y][j]*f[x][k-j])%mod;
	}
}
void solve1(int q,int x)
{
	pre(x,0);int ans1=0,tot=0,mx=0;
	for(int i=h[x];i;i=a[i].next)
	{
		int y=a[i].to;
		tot+=son[y];mx=max(mx,son[y]);
		for(int j=tot;j>=1;j--)
		for(int u=min(j,son[y]);u>=1;u--)
		{
			if(j==u)
			{
				g[j][u]=(g[j][u]+f[y][u])%mod;
				continue;
			}
			for(int t= 1;t<=mx&&t<=j;t++)
			{
				g[j][max(t,u)]=(g[j][max(t,u)]+g[j-u][t]*f[y][u])%mod;
			}
		}
	}
	for(int j=1;j<=tot;j++)
	for(int t=1;t<=mx;t++)
	if(t*2<(j+1))ans1=(ans1+g[j][t])%mod;
	printf("Case %d: %d\n",q,(ans1+1)%mod);	
	
}
void solve2(int q)
{
	pre(zx1,0);int ans1=0,tot=0;
	w[0]=1;
	for(int i=h[zx1];i;i=a[i].next)
	{
		int y=a[i].to;
		if(y==zx2)continue;tot+=son[y];
		for(int j=min(tot,son[zx2]-1);j>=1;j--)
		{
			for(int u=min(j,son[y]);u>=1;u--)
			{
				w[j]=(w[j]+w[j-u]*f[y][u])%mod;
			}
		}
	}
	for(int i=son[zx2]-1;i>=0;i--)
	ans1=(ans1+w[i]*f[zx2][i+1])%mod;
	printf("Case %d: %d\n",q,ans1%mod);
}
int main()
{
	int Q,x,y;
	cin>>Q;
	for(int q=1;q<=Q;q++)
	{
		memset(h,0,sizeof(h));cnt=0;memset(son,0,sizeof(son));
		memset(f,0,sizeof(f));memset(g,0,sizeof(g));
		scanf("%d",&n);k=0;ans=0x7fffffff/2;
		for(int i=1;i<n;i++)
		scanf("%d%d",&x,&y),add(x,y),add(y,x);
		find(1,0);
		memset(son,0,sizeof(son));
		if(k==1)solve1(q,zx1);
		else solve2(q),memset(w,0,sizeof(w));
	}
	return 0;
}
```




---

## 作者：George1123 (赞：12)

[$\Huge\color{#814514}{\tt My~Cnblogs}$](https://www.cnblogs.com/Wendigo/p/13086291.html)

---
[FJOI2014 树的重心](https://www.luogu.com.cn/problem/P4582)

> $Q$ 组测试数据。给一棵树大小为 $n$，求有多少个子树与其重心相同。重心可能有多个。

> 数据范围：$1\le Q\le 50$，$1\le n\le 200$。

---
就是要写好几个 $\tt dp$ 吧，细节比较多。

---
先 $\tt Dfs$ 一次找个重心：

```cpp
int sz[N+7],g[N+7];
int Dfs1(int u,int fa){
	int res=inf;
	sz[u]=1,g[u]=0;
	for(int&v:e[u])if(v!=fa){
		res=min(res,Dfs1(v,u));
		sz[u]+=sz[v],g[u]=max(g[u],sz[v]);
	}
	g[u]=max(g[u],n-sz[u]);
	res=min(res,g[u]);
	return res;
}
//...
int ms=Dfs1(1,0);
vector<int> G;
for(int i=1;i<=n;i++)if(g[i]==ms) G.pb(i);
```
重心只有 $1$ 个或 $2$ 个，于是分类讨论 。

---
- **有 $2$ 个重心**

设重心为 $Gx$ 和 $Gy$。

所以必然有边 $(Gx,Gy)$。

把 $(Gx,Gy)$ 断开后两部分子树必然是相等的（要不然就只有 $1$ 个重心）。

**所以可以在两部分子树以 $Gx,Gy$ 为根各写个 $\tt dp$：**

**$f_{u,i}$ 表示 $u$ 点的子树选 $i$ 个点的联通子树（包括 $u$ 点）的方案数。**

$$f_{u,i}=\sum_{v\in son_u}\sum_{j=1}^{\min(i-1,sz_v)}f_{u,i-j}\cdot f_{v,j}$$

然后 $Ans=\sum_{i=1}^{\min(sz_{Gx},sz_{Gy})}f_{Gx,i}\cdot f_{Gy,i}$。

不过写两次树形 $\tt dp$ 麻烦，我的代码中省了个树形 $\tt dp$。

---
- **有 $1$ 个重心**

设重心为 $G$。

所以选出子树中 $G$ 点的**每个子树大小** $\le$ **所有子树大小之和**的 $\frac 12$。

所以可以先如上跑个 $\tt dp$，以 $G$ 为根得出同上的 $f_{i,j}$。

**$F_{i,j}$ 选出子树共 $i$ 个点（除了 $G$），最大子树大小为 $j$ 的方案数。**

**所以初始化 $F_{i,i}=\sum_{v\in son_G}f_{v,i}$。**

$${\rm Then}\forall k\in[1,i]:F_{i,\max(j,k)}+=F_{i-j,k}\cdot f_{v,j}$$

最后 $Ans=1+\sum_{i=1}^n\sum_{j=1}^n[2j\le i]F_{i,j}$。

> 为什么要 $+1$？表示只选 $G$ 点的情况。

---
- **代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define b(a) a.begin()
#define e(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=200,P=1e4+7;
int n;
vector<int> e[N+7];

//Treedp
int sz[N+7],g[N+7],f[N+7][N+7];
int Dfs1(int u,int fa){
	int res=inf;
	sz[u]=1,g[u]=0;
	for(int&v:e[u])if(v!=fa){
		res=min(res,Dfs1(v,u));
		sz[u]+=sz[v],g[u]=max(g[u],sz[v]);
	}
	g[u]=max(g[u],n-sz[u]);
	res=min(res,g[u]);
	return res;
}
void Dfs2(int u,int fa){
	sz[u]=f[u][0]=f[u][1]=1;
	for(int&v:e[u])if(v!=fa){
		Dfs2(v,u),sz[u]+=sz[v];
		for(int i=sz[u];i>=1;i--)
			for(int j=1;j<=min(sz[v],i-1);j++)
				(f[u][i]+=f[u][i-j]*f[v][j]%P)%=P;			
	}
}

//KonnyWen
int F1[N+7][N+7],F2[N+7];
int KonnyWen(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) e[i].clear();
	for(int i=1,u,v;i<=n-1;i++){
		scanf("%d%d",&u,&v);
		e[u].pb(v),e[v].pb(u);
	}
	int ms=Dfs1(1,0);
	vector<int> G;
	for(int i=1;i<=n;i++)if(g[i]==ms) G.pb(i);
//	puts("G:");
//	for(int&x:G) printf("%d ",x);puts("");
	memset(f,0,sizeof f),Dfs2(G[0],0);
//	puts("f:");
//	for(int i=1;i<=n;i++)
//		for(int j=1;j<=n;j++)
//			printf("%d%c",f[i][j],"\n "[j<n]);
	int sm=0,res=0; 
	if(sz(G)==1){
		memset(F1,0,sizeof F1),ms=-inf;
		for(int&v:e[G[0]]){
			ms=max(ms,sz[v]),sm+=sz[v];
			for(int i=sm;i>=1;i--)
				for(int j=min(sz[v],i);j>=1;j--){
					if(j==i) (F1[i][j]+=f[v][j])%=P;
					else for(int k=1;k<=min(i,ms);k++)
						(F1[i][max(j,k)]+=F1[i-j][k]*f[v][j]%P)%=P;
				}
		}
//		puts("F1:");
//		for(int i=1;i<=n;i++)
//			for(int j=1;j<=n;j++)
//				printf("%d%c",F1[i][j],"\n "[j<n]);
		for(int i=1;i<=sm;i++)
			for(int j=1;j<=i;j++)
				if(j*2<=i) (res+=F1[i][j])%=P;
		res++;
	} else if(sz(G)==2){ //一次树形 dp 代替两次
		memset(F2,0,sizeof F2),F2[0]=1;
		for(int&v:e[G[0]])if(v!=G[1]){
			sm+=sz[v];
			for(int i=sm;i>=1;i--)
				for(int j=1;j<=min(sz[v],i);j++)
					(F2[i]+=F2[i-j]*f[v][j]%P)%=P;
		}
//		puts("F2:");
//		for(int i=1;i<=n;i++) printf("%d ",F2[i]);puts("");
		for(int i=1;i<=sm+1;i++)
			(res+=F2[i-1]*f[G[1]][i]%P)%=P;
	}
	return res;	
}

//Main
int main(){
	int t; scanf("%d",&t);
	for(int i=1;i<=t;i++) 
		printf("Case %d: %d\n",i,KonnyWen());
	return 0;
}
```
---
**祝大家学习愉快！**

---

## 作者：251Sec (赞：4)

$O(n^2)$ 做法。提交的时候是你谷最优解。我猜过会就不是了。

---

如果原树有两个重心，那么从中间断开，相当于问两边的树各选相同点数的与根相连的连通块的方案数。直接对两边分别 DP $f(u,i)$ 代表 $u$ 子树选 $i$ 个点的方案数，令 $g(u,i)$ 为 $f(v \in \text{son}(u),i)$ 的 $(+,\times)$ 卷积的第 $i$ 项，转移是简单的：

$$
f(u,i) \gets g(u,i-1)
$$

$$
f(u,0) \gets 1
$$

如果原树有一个重心，把它视为根，相当于要在根节点相连的每个子树里各选一个与根相连的可空连通块，使得不存在一个连通块的大小大于等于总大小的一半。（注意等于也不行，因为会有两个重心）

先类似上一问地 DP 出 $f(u,i)$ 代表 $u$ 子树选 $i$ 个点的方案数。考虑大小不小于总大小一半的连通块至多只有一个，补集转化一下，计数存在一个大于等于总大小的一半的连通块的方案数。枚举这个连通块在根节点的哪个儿子的子树里，设这个儿子为 $v$，设 $g(v,i)$ 为根节点所有不等于 $v$ 的儿子的 $f$ 的 $(+,\times)$ 卷积的第 $i$ 项，则它的贡献是 $\sum\limits_{i} f(v,i) \times \sum\limits_{j=0}^{i-1}g(v,j)$。那么只要求出来所有 $g$ 就可以直接做个前缀和算了。

考虑怎么求 $g$，我们对根节点所有儿子维护 $f$ 的前缀积和后缀积，这个基于子树大小枚举是 $O(n^2)$ 的。但是把一个前缀和一个后缀卷起来得到 $g$ 的复杂度又炸到了 $O(n^2 \log n)$（基于 FFT）。但是没有关系，我们发现我们只关心 $g(v,*)$ 的前 $\text{siz}_v$ 项，于是暴力卷积复杂度是 $O(\sum \text{siz}_v^2) \le O(n^2)$ 的，所以就对了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 1e4 + 7;
struct Edge {
	int to, next;
} e[405];
int head[205], len;
void Insert(int u, int v) {
	e[++len] = { v, head[u] };
	head[u] = len;
}
int n, T;
int cp, cq, wp;
int siz[205];
void FindCent(int u, int fa) {
	int w = 0;
	siz[u] = 1;
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if (v == fa) continue;
		FindCent(v, u);
		w = max(w, siz[v]);
		siz[u] += siz[v];
	}
	w = max(w, n - siz[u]);
	if (!cp || w < wp) {
		cp = u, wp = w;
		cq = 0;
	}
	else if (w == wp) cq = u;
}
ll f[205][205], t[205];
int p[205], psz[205], cnt;
ll pf[205][205], pg[205][205], sg[205][205];
void DFS(int u, int fa) {
	int s = 0; f[u][0] = 1;
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if (v == fa) continue;
		DFS(v, u);
		for (int j = 0; j <= s + siz[v]; j++) t[j] = 0;
		for (int j = s; j >= 0; j--) {
			for (int k = siz[v]; k >= 0; k--) {
				(t[j + k] += f[u][j] * f[v][k]) %= P;
			}
		}
		for (int j = 0; j <= s + siz[v]; j++) f[u][j] = t[j];
		s += siz[v];
	}
	for (int i = siz[u]; i; i--) f[u][i] = f[u][i - 1];
	f[u][0] = 1;
}
int main() {
	scanf("%d", &T);
	for (int tid = 1; tid <= T; tid++) {
		scanf("%d", &n);
		for (int i = 1, u, v; i < n; i++) {
			scanf("%d%d", &u, &v);
			Insert(u, v); Insert(v, u);
		}
		FindCent(1, 0);
		if (cq) {
			DFS(cp, cq), DFS(cq, cp);
			ll ans = 0;
			for (int i = 1; i <= n; i++) (ans += f[cp][i] * f[cq][i] % P) %= P;
			printf("Case %d: %lld\n", tid, ans);
		}
		else {
			FindCent(cp, 0);
			ll ans = 1;
			for (int i = head[cp]; i; i = e[i].next) {
				int v = e[i].to;
				DFS(v, cp);
				ll s = 0;
				for (int j = 0; j <= siz[v]; j++) (s += f[v][j]) %= P;
				ans = ans * s % P;
			}
			cnt = 0;
			for (int i = head[cp]; i; i = e[i].next) {
				int v = e[i].to;
				p[++cnt] = v; psz[cnt] = siz[v];
				for (int j = 0; j <= siz[v]; j++) pf[cnt][j] = f[v][j];
			}
			pg[0][0] = 1, sg[cnt + 1][0] = 1;
			for (int i = 1, s = 0; i <= cnt; i++) {
				for (int j = 0; j <= s; j++) {
					for (int k = 0; k <= psz[i]; k++) {
						(pg[i][j + k] += pg[i - 1][j] * pf[i][k] % P) %= P;
					}
				}
				s += psz[i];
			}
			for (int i = cnt, s = 0; i >= 1; i--) {
				for (int j = 0; j <= s; j++) {
					for (int k = 0; k <= psz[i]; k++) {
						(sg[i][j + k] += sg[i + 1][j] * pf[i][k] % P) %= P;
					}
				}
				s += psz[i];
			}
			for (int i = 1; i <= cnt; i++) {
				memset(t, 0, sizeof(t));
				for (int j = 0; j <= psz[i]; j++) {
					for (int k = 0; k <= j; k++) {
						t[j] += pg[i - 1][k] * sg[i + 1][j - k] % P;
					}
					t[j] %= P;
				}
				for (int j = 1; j <= psz[i]; j++) t[j] = (t[j] + t[j - 1]) % P;
				for (int j = 1; j <= psz[i]; j++) ans = (ans - pf[i][j] * t[j - 1] % P + P) % P;
			}
			printf("Case %d: %lld\n", tid, ans);
			memset(pg, 0, sizeof(pg)); memset(sg, 0, sizeof(sg));
			memset(pf, 0, sizeof(pf)); memset(psz, 0, sizeof(psz)); memset(p, 0, sizeof(p));
		}
		cp = cq = wp = 0;
		memset(head, 0, sizeof(head)), len = 0;
		memset(f, 0, sizeof(f));
	}
	return 0;
}
```

---

## 作者：jacky567 (赞：4)

我们可以分别讨论1个和2个两个中心的情况：
1. 1个：考虑用树形dp来求最终的答案，直接以重心为根，枚举节点数，用$f_{i,j}$表示以$i$为根，选$j$个节点的答案数，dp的状态转移和[洛谷P4322 [JSOI2016]最佳团体](https://www.luogu.com.cn/blog/jacky0705/solution-p4322)有点像
2. 2个：直接对两个重心分别求出答案，利用乘法原理求出最终的答案

附上代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int n,tot,root,ans,MOD=10007,head[210],big[210],size[210],f[210][210],temp[210];
struct ppap
{
	int to,nxt;
}e[410];
void add(int u,int v)
{
	e[++tot].nxt=head[u],e[tot].to=v,head[u]=tot;
}
void getroot(int x,int fa)
{
	size[x]=1,big[x]=0;
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa)
		getroot(e[i].to,x),size[x]+=size[e[i].to],big[x]=max(big[x],size[e[i].to]);
	big[x]=max(big[x],n-size[x]);
	if(big[x]<=big[root]||(!root)) root=x;
}
void dfs(int x,int fa)
{
	size[x]=f[x][0]=f[x][1]=1;
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa){ 
		dfs(e[i].to,x);
		for(int j=1;j<=size[x]+size[e[i].to];j++) temp[j]=0;
		for(int j=1;j<=size[x];j++) for(int k=0;k<=size[e[i].to];k++)
			temp[j+k]=(temp[j+k]+f[x][j]*f[e[i].to][k]%MOD)%MOD;
		size[x]+=size[e[i].to];
		for(int j=1;j<=size[x];j++) f[x][j]=temp[j];
    }
}
void solve1(int x)
{
	memset(f,0,sizeof(f));
	dfs(x,0);
	for(int i=1;i<=n;i++){
		memset(f[x],0,sizeof(f[x])),size[x]=f[x][0]=f[x][1]=1;
		for(int j=head[x];j;j=e[j].nxt){
			for(int k=1;k<=size[x]+size[e[j].to];k++) temp[k]=0;
			for(int k=1;k<=size[x];k++) for(int l=0;l<=size[e[j].to];l++){
				if(l*2>=i) break;
				temp[k+l]=(temp[k+l]+f[x][k]*f[e[j].to][l]%MOD)%MOD;
			}
			size[x]+=size[e[j].to];
			for(int k=1;k<=size[x];k++) f[x][k]=temp[k];
		}
		ans=(ans+f[x][i])%MOD;
	}
}
void solve2(int x,int y)
{
	memset(f,0,sizeof(f));
	dfs(x,y),dfs(y,x);
	for(int i=1;i<=n;i++) ans=(ans+f[x][i]*f[y][i]%MOD)%MOD;
}
int main()
{
	int test=0,T;
	scanf("%d",&T);
	while(T--){
		test++,memset(head,0,sizeof(head)),tot=ans=0;
		scanf("%d",&n);
		for(int i=1,x,y;i<n;i++) scanf("%d%d",&x,&y),add(x,y),add(y,x);
		root=0,getroot(1,0);
		if(big[root]*2<n) solve1(root);
		else{
			int y;
			for(int i=head[root];i>0;i=e[i].nxt){
				y=e[i].to;
				if(big[root]==size[y]) break;
			}
			solve2(root,y);
		}
		printf("Case %d: %d\n",test,ans);
	}
}
```

---

## 作者：drowsylve (赞：2)

简单 dp 题调了 inf 年，不难想但挺有细节的一题。

首先肯定先一遍 dfs 求出所有重儿子的最小值，然后判断点能否成为重心，对于重心的数量分类讨论。

- 两个重心

在保留这两个点的基础上，分别在他们的子树中选取相同的点数，此时这两个点仍为重心。

设 $f_{u,i}$ 表示 在 $u$ 的子树中（包含 $u$）取 $i$ 个点的方案数，转移类似树上背包，有

$$ f_{u,1} \gets 1 $$
$$ f_{u,i} \gets f_{u,i-j} \times f_{v,j} $$

需要注意的是外层枚举选取点数 $i$ 时应倒序枚举。

设两个重心分别为 $rt1$，$rt2$，统计答案时枚举选出的点数 $i$，有

$$ ans \gets f_{rt1,i} \times f_{rt2,i} $$

- 一个重心

设重心为 $rt$。先以 $rt$ 为根跑一遍以上的 dfs 求出 $f$ 数组，$g_{i,j}$ 表示以 $rt$ 为根的子树中，选择了 $i$ 个点（包含 $rt$），$rt$ 的重儿子大小为 $j$ 时的方案数，转移仍然是一个背包状物，枚举总共选了 $i$ 个点，此前的重儿子为 $j$，当前子树 $v$ 中选了 $k$ 个点，有

$$ g_{1,0} \gets 1 $$
$$ g_{i,\max(j,k)} \gets g_{i-k,j} \times f_{v,k} $$

答案为

$$ \sum_{i=1}^n \sum_{j=0}^n \left[j \times 2<i\right] g_{i,j}$$

此外，所有转移中的循环边界 $size$ 都是可以随着新子树的加入而动态修改的，会比先求出总 $size$ 后 dp 要优。

时间复杂度 $O(n^3)$。


```cpp
bool M1;
#include<bits/stdc++.h>
#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<'\n'
//#define int long long
//#define double long double
#define ll long long
#define db double
#define pb push_back
#define pii pair<int,int>
#define mkp make_pair
#define fr first
#define sc second
using namespace std;
template<typename T> void ckmin(T &x,T y){x=min(x,y);}
template<typename T> void ckmax(T &x,T y){x=max(x,y);}
const int N=205;
const int inf=1e9;
const int mod=10007;
int n;
int cnte,to[N<<1],nxt[N<<1],head[N];
inline void add(int u,int v){
	to[++cnte]=v;
	nxt[cnte]=head[u];
	head[u]=cnte;
}
int siz[N],mx[N],h;
void dfs(int u,int fa){
	siz[u]=1,mx[u]=0;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		ckmax(mx[u],siz[v]);
	}
	ckmax(mx[u],n-siz[u]);
	ckmin(h,mx[u]);
}
int f[N][N],g[N][N];
void dfs1(int u,int fa){
	siz[u]=1;
	f[u][1]=1;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		for(int j=siz[u];j>=1;j--){
			for(int k=1;k<=siz[v];k++){
				f[u][j]=(f[u][j]+f[u][j-k]*f[v][k]%mod)%mod;
			}
		}
	}
}
void sol(int T){
	cin>>n;
	for(int i=1;i<=n;i++) head[i]=0;cnte=0;
	for(int i=0;i<=n;i++) for(int j=0;j<=n;j++) f[i][j]=g[i][j]=0;
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		add(u,v),add(v,u);
	}
	h=inf;
	dfs(1,0);
	int cntrt=0;
	for(int i=1;i<=n;i++) cntrt+=(mx[i]==h);
	if(cntrt==1){
		int rt;
		for(int i=1;i<=n;i++) if(mx[i]==h) rt=i;
		dfs1(rt,0);
		g[1][0]=1;
		int sz=1,mxs=0;;
		for(int i0=head[rt];i0;i0=nxt[i0]){
			int v=to[i0];
			sz+=siz[v];
			for(int i=sz;i>=0;i--){
				for(int j=sz;j>=0;j--){
					for(int k=1;k<=siz[v];k++){
						if(i-k>=1) g[i][max(j,k)]=(g[i][max(j,k)]+g[i-k][j]*f[v][k]%mod)%mod;
					}
				}
			}
		}
		int ans=0;
		for(int i=1;i<=n;i++)
			for(int j=0;j*2<i;j++)
				ans=(ans+g[i][j])%mod;
		cout<<"Case "<<T<<": "<<ans<<"\n"; 
	}else{
		int rt1=0,rt2=0;
		for(int i=1;i<=n;i++){
			if(mx[i]==h){
				if(!rt1) rt1=i;
				else rt2=i;
			}
		}
		dfs1(rt1,rt2),dfs1(rt2,rt1);
		int ans=0;
		for(int i=1;i<=min(siz[rt1],siz[rt2]);i++){
			ans=(ans+f[rt1][i]*f[rt2][i]%mod)%mod;
		}
		cout<<"Case "<<T<<": "<<ans<<"\n"; 
	}
}
bool M2;
signed main(){
//	look_memory;
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	int T;cin>>T;
	for(int i=1;i<=T;i++) sol(i);
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

### Centroid of a Tree
首先，树的的重心，具有如下性质：

> 如果重心为两个 $a,b$，那么 $a,b$ 必定是一条边上的两个端点，且把这条边断开后，以 $a,b$ 为根的子树大小相同。
>
> 如果重心只有一个 $a$，记这棵树大小为 $S$，以 $a$ 为根后其儿子最大的子树大小为 $Mx$，那么有 $S-Mx>Mx$。

简单口胡一下证明：定义**重量为以一个节点为根，其子树最大的儿子的大小**。那么重心 $a$ 就是重量最小的点。我们把 $a$ 和其子树最大的儿子 $t$ 所在的边断开，那么会形成两棵树。显然，它们大小分别为 $S-Mx$ 和 $Mx$。如果 $S-Mx=Mx$ 那么这就意味着树有两个重心；如果 $S-Mx<Mx$，那么 $t$ 的重量肯定小于$a$ ，显然 $a$ 不会成为重心，与之矛盾。

记 $dp_{x,i}$ 表示以 $x$ 为根，其所在的联通块大小为 $i$ 的方案数。

转移：
$$
dp_{x,i+j}=\sum_{t,i,j}dp_{x,i}\times dp_{t,j}
$$
复杂度 $O(n^2)$。

注意 $i,j$ 要从大到小枚举，以及 $i,j$ 的上界为节点数量就好了，不然复杂度会变成 $O(n^3)$。

对于有两个重心 $a,b$ 的情况，答案显然就是 $\sum_{i=1}^{\frac{n}{2}}dp_{a,i}\times dp_{b,i}$。

接下来考虑一个重心 $a$ 的情况。

### Part1：朴素写法
记 $tmp_{i,j}$ 表示 $a$ 所在的联通块大小为 $i$，$a$ 的重量为 $j$ 的方案数。

注意初值是 $tmp_{1,0}=1$。

转移就直接枚举 $a$ 的儿子，背包暴力合并就行了。

答案就是 $\sum_{i=1}^n \sum_{j=0}^{2j<i} tmp_{i,j}$。

这里复杂度 $O(n^3)$，足以通过本题。

这部分代码：
```cpp
namespace Sub2{
    int tmp[210][210];
    void DFS(int x,int fa){
        size[x]=1;
        dp[x][1]=1;
        for(int i=head[x];i;i=G[i].last){
            int t=G[i].ed;
            if(t==fa)continue;
            DFS(t,x);
            for(int j=size[x];j>=1;j--){
                for(int k=size[t];k>=1;k--){
                    dp[x][j+k]=(dp[x][j+k]+dp[x][j]*dp[t][k]%MOD)%MOD;
                }
            }
            size[x]+=size[t];
        }
    }
    int work(){
        DFS(Rt1,0);
        memset(tmp,0,sizeof(tmp));
        int sz=1;
        tmp[1][0]=1;
        for(int i=head[Rt1];i;i=G[i].last){
            int t=G[i].ed;
            for(int j=sz;j>=0;j--){
                for(int k=sz;k>=0;k--){
                    if(tmp[j][k]==0)continue;
                    for(int o=size[t];o>=1;o--){
                        tmp[j+o][max(k,o)]=(tmp[j+o][max(k,o)]+tmp[j][k]*dp[t][o]%MOD)%MOD;
                    }
                }
            }
            sz+=size[t];
        }
        for(int i=1;i<=n;i++){
            for(int j=0;2*j<i;j++){
                ans=(ans+tmp[i][j])%MOD;
            }
        }
        return ans;
    }
}
```
### Part2：容斥写法
换一种思路，求不合法的方案数。

对于不合法的情况，就是 $2Mx \ge S$。而 $a$ **最多只会有一个儿子** $t$，其节点数的两倍大于等于 $S$。

那么我们就直接枚举 $t$，$a$ 所在的联通块大小 $S$ 和 $t$ 的节点数 $i$。这样总复杂度是 $O(n \sum_t size_t)=O(n^2)$。

接下来就是算不合法的情况了。注意到直接拿 $dp_{a,S-i} \times dp_{t,i}$ 算是不行的，因为 $dp_{a,S-i}$ 中包含了取了 $t$ 的子树的情况。

但是，由于我们背包求的是方案数——这是满足交换律的——也就是说合并一个节点儿子的顺序不管怎么样，答案都是不会变的。因此，我们可以做一次删除的背包，也就是把 $t$ 的子树的贡献都删除掉。

这样复杂度就是完美的 $O(n^2)$。

这部分代码：
```cpp
namespace Sub2 {
	int tmp[210][210];
	void DFS(int x,int fa) {
		size[x]=1;
		dp[x][1]=1;
		for(int i=head[x]; i; i=G[i].last) {
			int t=G[i].ed;
			if(t==fa)continue;
			DFS(t,x);
			for(int j=size[x]; j>=1; j--) {
				for(int k=size[t]; k>=1; k--) {
					dp[x][j+k]=(dp[x][j+k]+dp[x][j]*dp[t][k]%MOD)%MOD;
				}
			}
			size[x]+=size[t];
		}
	}
	int work() {
		memset(tmp,0,sizeof(tmp));
		DFS(Rt1,0);
		for(int i=head[Rt1]; i; i=G[i].last) {
			int t=G[i].ed;
			for(int j=1; j<=n; j++) {
				tmp[t][j]=dp[Rt1][j];
				for(int k=1; k<=min(j,size[t]); k++)tmp[t][j]=(tmp[t][j]-tmp[t][j-k]*dp[t][k]%MOD+MOD)%MOD;
			}

		}
		for(int i=1; i<=n; i++) {
			ans=(ans+dp[Rt1][i])%MOD;
			for(int j=head[Rt1]; j; j=G[j].last) {
				int t=G[j].ed;
				for(int k=(i+1)/2; k<=min(i,size[t]); k++)ans=(ans-dp[t][k]*tmp[t][i-k]%MOD+MOD)%MOD;
			}
		}
		return ans;
	}
}
```
### AC 代码
```cpp
#include<bits/stdc++.h>
#define MOD 10007
using namespace std;
int n,T,tot,head[210],Cas,size[210],W[210],Rt1,Rt2,Weight,dp[210][210],ans;
struct node {
	int ed,last;
} G[10010];
void Add(int st,int ed) {
	tot++;
	G[tot]=node {ed,head[st]};
	head[st]=tot;
}
void GetRoot(int x,int fa) {
	size[x]=1;
	for(int i=head[x]; i; i=G[i].last) {
		int t=G[i].ed;
		if(t==fa)continue;
		GetRoot(t,x);
		size[x]+=size[t];
		W[x]=max(W[x],size[t]);
	}
	W[x]=max(W[x],n-size[x]);
	Weight=min(Weight,W[x]);
}
namespace Sub1 {
	void DFS(int x,int fa) {
		size[x]=1;
		dp[x][1]=1;
		for(int i=head[x]; i; i=G[i].last) {
			int t=G[i].ed;
			if(t==fa)continue;
			DFS(t,x);
			for(int j=size[x]; j>=1; j--) {
				for(int k=size[t]; k>=1; k--) {
					dp[x][j+k]=(dp[x][j+k]+dp[x][j]*dp[t][k]%MOD)%MOD;
				}
			}
			size[x]+=size[t];
		}
	}
	int work() {
		for(int i=1; i<=n; i++)size[i]=0;
		DFS(Rt1,Rt2);
		DFS(Rt2,Rt1);
		for(int i=1; i<=n; i++)ans=(ans+dp[Rt1][i]*dp[Rt2][i]%MOD)%MOD;
		return ans;
	}
}
namespace Sub2 {
	int tmp[210][210],sum[210][210];
	void DFS(int x,int fa) {
		size[x]=1;
		dp[x][1]=1;
		for(int i=head[x]; i; i=G[i].last) {
			int t=G[i].ed;
			if(t==fa)continue;
			DFS(t,x);
			for(int j=size[x]; j>=1; j--) {
				for(int k=size[t]; k>=1; k--) {
					dp[x][j+k]=(dp[x][j+k]+dp[x][j]*dp[t][k]%MOD)%MOD;
				}
			}
			size[x]+=size[t];
		}
	}
	int work() {
		memset(sum,0,sizeof(sum));
		memset(tmp,0,sizeof(tmp));
		DFS(Rt1,0);
		for(int i=head[Rt1]; i; i=G[i].last) {
			int t=G[i].ed;
			for(int j=1; j<=n; j++) {
				tmp[t][j]=dp[Rt1][j];
				for(int k=1; k<=min(j,size[t]); k++)tmp[t][j]=(tmp[t][j]-tmp[t][j-k]*dp[t][k]%MOD+MOD)%MOD;
			}

		}
		for(int i=1; i<=n; i++) {
			ans=(ans+dp[Rt1][i])%MOD;
			for(int j=head[Rt1]; j; j=G[j].last) {
				int t=G[j].ed;
				for(int k=(i+1)/2; k<=min(i,size[t]); k++)ans=(ans-dp[t][k]*tmp[t][i-k]%MOD+MOD)%MOD;
			}
		}
		return ans;
	}
}
int main() {
	scanf("%d",&T);
	while(T--) {
		ans=tot=0,Weight=2e9+7;
		Rt1=Rt2=-1;
		memset(head,0,sizeof(head));
		memset(W,0,sizeof(W));
		memset(dp,0,sizeof(dp));
		scanf("%d",&n);
		for(int x,y,i=1; i<=n-1; i++) {
			scanf("%d %d",&x,&y);
			Add(x,y);
			Add(y,x);
		}
		GetRoot(1,0);
		for(int i=1; i<=n; i++) {
			if(W[i]==Weight) {
				if(Rt1==-1)Rt1=i;
				else Rt2=i;
			}
		}
		if(Rt2==-1)printf("Case %d: %d\n",++Cas,Sub2::work());
		else printf("Case %d: %d\n",++Cas,Sub1::work());
	}
	return 0;
}
```

---

## 作者：Pengzt (赞：0)

# 树的重心

[题目链接](https://www.luogu.com.cn/problem/P4582)。[cnblogs](https://www.cnblogs.com/Pengzt/p/18705926)。[luogu](https://www.luogu.com.cn/article/rg7do4az)。

#### Problem

有 $T$（$T \le 50$）组测试数据。

每次给出 $n$（$\le 200$）个节点的树，求它的连通子图数量，使得它的重心与整棵树的重心重合。答案对质数 $P$ 取模。

#### Sol

不妨设 $d_i$ 表示以 $u$ 为根的时候，$i$ 的子树大小。

先找到树的重心。发现只有 $\max d_i = \frac n2$ 的时候才会出现两个重心。

+ 只有一个重心：

不妨记这个重心为 $rt$，

令 $f_{u, i}$ 表示 $u$ 子树中，连通子图大小为 $i$ 的数量。

有转移：$f'_{u, i} = \sum\limits_{j = 0}^{sz_v} f_{u, i - j}\cdot f_{v, j}$。然后 $f\gets f'$。

$u$ 做完之后 $f_{u, i}\gets f'_{u, i - 1}$。最后 $\forall u \ne rt, f_{u, 0} = 1$。然后初始的时候 $\forall u\in \text{leaf}, f_{u, 1} = 1$。这里由于第二维是 $\mathcal{O}(sz_v)$ 的，所以这部分的时间复杂度为 $\mathcal{O}(n^2)$。

当 $u$ 为根的时候，记连通块大小为 $sz$，那么要统计 $\max d_i < \frac{sz}2$ 的答案，这个东西其实不是很好统计，但是发现 $\ge \frac{sz}2$ 的儿子很少，考虑统计 $\max d_i > \frac{sz - 1}2$ 的数量。令 $g_{v, i}$ 表示不考虑 $v$ 这个儿子和 $u$，连通块大小为 $i$ 的方案数。则答案为 $\sum \limits_{i = 1}^{sz_v} f_{v, i} \cdot \sum \limits_{j = 0}^{i - 1} g_{v, j}$。然后就是求出 $g_{u, i}$。不难发现 $g$ 可以表示为一个前缀和后缀的并，这个前后缀的预处理是可以 $\mathcal{O}(n\cdot\sum sz_v) = \mathcal{O}(n^2)$ 的。直接暴力合并出 $g$ 的话是 $\mathcal{O}(n^3 / n^2\log)$ 的，但是发现 $g$ 只有前 $sz_v$ 项有用，所以合并就变为 $\mathcal{O}(\sum sz_v^2) = \mathcal{O}(n^2)$ 的了。

+ 两个重心：

把 $(rt_1, rt_2)$ 断开，然后分别以 $rt_1$，$rt_2$ 为根跑一遍。然后答案为 $\sum f_{rt_1, i}\cdot f_{rt_2, i}$。

时间复杂度 $\mathcal{O}(n^2)$。

具体实现可以参考代码，感觉已经很清楚了。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define fi first
#define se second
mt19937_64 eng(time(0) ^ clock());
template <typename T>
T rnd(T l, T r) { return eng() % (r - l + 1) + l; }
const int P = 10007;
int n, rt1, rt2;
vector<int> e[205];
int sz[205], mx[205];
void DFS(int u, int ff) {
	sz[u] = 1;
	for (int v : e[u])
		if (v != ff) {
			DFS(v, u);
			sz[u] += sz[v];
			mx[u] = max(mx[u], sz[v]);
		}
	mx[u] = max(mx[u], n - sz[u]);
	if (!rt1 || mx[u] < mx[rt1])
		rt1 = u, rt2 = 0;
	else if (mx[u] == mx[rt1])
		rt2 = u;
}
int f[205][205], g[205][205], pre[205][205], suf[205][205], temp[205];
void Work(int u, int ff) {
	sz[u] = 1;
	int son = 0;
	f[u][0] = 1;
	for (int v : e[u])
		if (v != ff) {
			++son;
			Work(v, u);
			memset(temp, 0, sizeof (temp));
			sz[u] += sz[v];
			for (int i = 0; i <= sz[u]; i++)
				for (int j = 0; j <= min(sz[v], i); j++)
					(temp[i] += f[u][i - j] * f[v][j]) %= P;
			memcpy(f[u], temp, sizeof (f[u]));
		}
	for (int i = sz[u]; i; --i) f[u][i] = f[u][i - 1];
	f[u][0] = 1;
	if (!son) f[u][1] = 1;
}
int ans;
void Solve(int test) {
	memset(f, 0, sizeof (f)), memset(g, 0, sizeof (g)), memset(pre, 0, sizeof (pre)), memset(suf, 0, sizeof (suf)), memset(mx, 0, sizeof (mx));
	rt1 = rt2 = 0;
	scanf("%d", &n);
	for (int i = 1, u, v; i < n; i++)
		scanf("%d%d", &u, &v), e[u].emplace_back(v), e[v].emplace_back(u);
	DFS(1, 0);
	if (rt2) {
		Work(rt1, rt2);
		Work(rt2, rt1);
		ans = 0;
		for (int i = 1; i <= n / 2; i++)
			(ans += f[rt1][i] * f[rt2][i]) %= P;
		printf("Case %d: %d\n", test, ans);
		for (int i = 1; i <= n; i++) e[i].clear();
		return;
	}
	ans = 1;
	Work(rt1, 0);
	for (int i : e[rt1]) {
		int s = 0;
		for (int j = 0; j <= n; j++)
			(s += f[i][j]) %= P;
		(ans *= s) %= P;
	}
	pre[0][0] = 1;
	int len = (int)e[rt1].size();
	for (int i = 0; i < len; i++) {
		int v = e[rt1][i];
		for (int j = 0; j <= n; j++)
			for (int k = 0; k <= min(sz[v], j); k++)
				(pre[i + 1][j] += pre[i][j - k] * f[v][k]) %= P;
	}
	suf[len + 1][0] = 1;
	for (int i = len - 1; i >= 0; --i) {
		int v = e[rt1][i];
		for (int j = 0; j <= n; j++)
			for (int k = 0; k <= min(sz[v], j); k++)
				(suf[i + 1][j] += suf[i + 2][j - k] * f[v][k]) %= P;
	}
	for (int i = 1; i <= len; i++) {
		int v = e[rt1][i - 1];
		for (int j = 0; j <= sz[v]; j++)
			for (int k = 0; k <= j; k++)
				(g[i][j] += pre[i - 1][j - k] * suf[i + 1][k]) %= P;
		for (int j = 1; j <= sz[v]; j++)
			(g[i][j] += g[i][j - 1]) %= P;
		for (int j = 1; j <= sz[v]; j++)
			(ans -= f[v][j] * g[i][j - 1]) %= P;
	}
	(ans += P) %= P;
	printf("Case %d: %d\n", test, ans);
	for (int i = 1; i <= n; i++) e[i].clear();
}
int main() {
	int T;
	scanf("%d", &T);
	for (int i = 1; i <= T; i++)
		Solve(i);
	return 0;
}
```

---

## 作者：szydxf (赞：0)

这题粗略的思路就是，把这棵树以重心为根，看什么情况下它仍是重心。考虑重心的性质：以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。发现我们只关心 **整棵树的大小** 和 **最大子树的大小**，于是将他们写进状态里，用 dp 统计。

$dp_{i,j}$ 表示整棵树大小为 $i$，最大子树大小为 $j$ 的方案数。因为我们只关心子树大小，其内部形态结构不关心，所以还得设 $f_{u,i}$ 表示以 $u$ 为根，子树大小为 $i$ 的方案数，转移显然。再想想另一个怎么转移。转移是不断添加子树的过程，枚举当前添加的以 $v$ 为根子树大小为 $k$，转移就是 $dp_{i,\max(j,k)}$ 得到 $dp_{i-k,j}\times f_{v,k}$ 的贡献。类似背包，因为我们要压维，所以还要倒序枚举 $i$。不理解就不压维写个滚动数组正常转移也行。

最后思考如何统计答案。先思考什么时候重心不唯一？假设此时树大小为 $n$，一个重心是 $u$，$u$ 的子节点是 $v$。当 $n$ 为偶数，有一个 $v$ 使得 $size_v=\frac{n}{2}$。此时 $u$ 和 $v$ 就是相邻的两个重心。 当只有一个重心时，我们在统计时避开这种情况就行了，就是 $\sum_{i=1}^n \sum_{j=1}^{\lfloor \frac{(i-1)}{2}\rfloor}$。

当有两个重心时，我们要求 $n$ 为偶数，且强制要求第二个重心子树大小为 $\frac{n}{2}$ 就行了，具体见代码。

一个小细节是，当有两个重心时，因为我们已经钦定了另一个重心的子树大小，所以转移dp数组时要忽略它。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=205,mod=10007;
vector<int> e[N];
int T,n,sz[N],f[N][N],dp[N][N],cen[2];
void dfs(int u,int fa){
	sz[u]=1;
	int mwt=0;
	for(int v:e[u]) if(v!=fa){
		dfs(v,u);
		sz[u]+=sz[v];
		mwt=max(mwt,sz[v]);
	} mwt=max(mwt,n-sz[u]);
	if(mwt<=n/2) cen[!!cen[0]]=u;
}
void dfs1(int u,int fa){
	f[u][1]=1,sz[u]=1;
	for(int v:e[u]) if(v!=fa){
		dfs1(v,u); sz[u]+=sz[v];
		if(u==cen[0]) continue;
		for(int i=sz[u];i;i--) for(int j=1;j<i;j++)
			f[u][i]+=f[u][i-j]*f[v][j]%mod,f[u][i]%=mod;
	}
}
inline void add(int &x,int y){x+=y,x%=mod;}
void solve(){
	cin>>n; cen[0]=cen[1]=0;
	memset(f,0,sizeof(f[0])*(n+1));
	memset(dp,0,sizeof(dp[0])*(n+1));
	for(int i=1;i<=n;i++) e[i].clear();
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v),e[v].push_back(u);
	} dfs(1,0),dfs1(cen[0],0);
	dp[1][0]=1;
	int now=1,mx=0;
	for(int v:e[cen[0]]){
		if(cen[1]==v) continue;
		now+=sz[v],mx=max(mx,sz[v]);
		for(int i=now;i;i--)
			for(int k=min(i-1,sz[v]);k;k--)
			for(int j=min(i-1,mx);~j;j--)
				add(dp[i][max(j,k)],dp[i-k][j]*f[v][k]%mod);
	} int ans=0;
	if(!cen[1]){
		for(int i=1;i<=n;i++){
			int lim=i-1>>1;
			for(int j=0;j<=lim;j++)
				add(ans,dp[i][j]);
		}
	}else{
		for(int i=2;i<=n;i+=2){
			int sum=0;
			for(int j=0;j<i/2;j++) 
				add(sum,dp[i/2][j]);
			add(ans,f[cen[1]][i/2]*sum%mod);
		}
	}
	cout<<ans<<'\n';
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>T;
  	for(int i=1;i<=T;i++) cout<<"Case "<<i<<": ",solve();
	return 0;
}
```

---

## 作者：tommy0221 (赞：0)

[P4582 [FJOI2014]树的重心](https://www.luogu.com.cn/problem/P4582)

这是我的第 514 道紫题！为了纪念这个时刻，写篇题解（

+ 预处理

设在节点 $u$ 所在子树选择一个大小为 $i$ 且包含 $u$ 的联通块的方案数为 $f(u,i)$ ，写成 $\rm OGF$ 的形式即 $F(u)=\sum_{i=0}f(u,i)x^i$。

那么转移就是 $F(u)=\prod_{v\in son(u)}F(v)$ 。

注意我们算的是“包含 $u$”的，所以在把儿子生成函数卷起来的时候要设 $[x^0]F(u)=0,[x^1]F(u)=1$ ，在卷完之后为了方便再设 $[x^0]F(u)=1$ ，因为对于它的父亲，它是可以不选的。

> 显然重心个数是要分类讨论的。

+ 有两个重心

这个比较简单，设两个重心分别为 $rt_0,rt_1$。

联通子树仍然是这两个重心的充要条件是：这两个重心所在联通块大小相等（或者说，存在一个子树的大小为 $\dfrac{siz}{2}$）。

那么 

$$
ans=\sum_{i=1} [x^i]F(rt_0)\times[x^i]F(rt_1)
$$

+ 有一个重心

设联通子树的大小为 $s$。这时候重心还是这个节点的充要条件是：所有子节点的联通块大小都小于 $\lceil\dfrac{s}{2}\rceil$。

上取整其实是分讨出来的 qwq。

当 $s$ 为偶数：如果有子树大小为 $\dfrac{s}{2}$ ，那么这颗树就会有两个重心，所以要 $<\dfrac{s}{2}$。

当 $s$ 为奇数：每棵子树大小小于 $\lceil\dfrac{s}{2}\rceil$ 即可

一个非常简单粗暴的方法就是枚举 $s$，把所有子节点的生成函数取前 $s$ 项卷起来，然后取第 $s$ 项即可。

+ 时间复杂度

看起来有点假，但是算一算刚好。

预处理部分，每个 $u$ 是 $O(siz^2)$ 的，那么就是 $O(n^3)$ 而且跑不满。

求答案的部分：

有两个重心就是 $O(n)$ 的。

有一个重心就是，枚举的 $O(n)$ ，再乘上卷积所有儿子生成函数的复杂度，这个是 $O(n^2)$ 的，仍然跑不满。

复杂度上界 $O(Qn^3)$ ，但是跑不满，所以能过。

```cpp
const int N = 205;
#define mod 10007
int n, ans, siz[N], rt, rtt, mx[N], cas;
typedef vector <int> poly;
vector <int> e[N];
poly r[N];
poly operator * (poly A, poly B) {
	int n = sz(A), m = sz(B);
	poly res(n + m - 1, 0);
	for(int i = 0; i < n; ++i)
		for(int j = 0; j < m; ++j)
			(res[i + j] += A[i] * B[j]) %= mod;
	return res;
}
void dfs1(int u, int ft) {
	siz[u] = 1, mx[u] = 0;
	for(int v : e[u]) {
		if(v == ft) continue;
		dfs1(v, u), siz[u] += siz[v];
		ckmax(mx[u], siz[v]);
	}
	ckmax(mx[u], n - siz[u]);
	if(mx[u] < mx[rt]) rt = u, rtt = 0;
	else if(mx[u] == mx[rt]) rtt = u;
}
void dfs2(int u, int ft) {
	r[u].resize(2);
	r[u][0] = 0, r[u][1] = 1;
	for(int v : e[u]) {
		if(v == ft) continue;
		dfs2(v, u), r[u] = r[u] * r[v];
	}
	r[u][0] = 1;
}
void Main() {
	n = read();
	rep(i, 1, n) e[i].clear();
	rt = rtt = 0, mx[0] = n, ans = 0;
	rep(i, 2, n) {
		int x = read(), y = read();
		e[x].pb(y), e[y].pb(x);
	}
	dfs1(1, 0);
	if(rtt) {
		dfs2(rt, rtt), dfs2(rtt, rt);
		rep(i, 1, min(sz(r[rt]),sz(r[rtt])) - 1)
			(ans += r[rt][i] * r[rtt][i]) %= mod;
	} else {
		dfs2(rt, 0);
		rep(i, 1, n) {
			poly res(2);
			res[0] = 0, res[1] = 1;
			int lim = ((i + 1) >> 1);
			for(int v : e[rt]) {
				poly tmp = r[v];
				tmp.resize(min(sz(tmp), lim));
				res = res * tmp;
			}
			if(sz(res) > i) (ans += res[i]) %= mod;
		}
	}
	printf("Case %d: %d\n", ++cas, ans);
}
signed main() { for(int T = read(); T; --T) Main(); }
```


---

## 作者：dAniel_lele (赞：0)

分两类讨论。

原来树有两个重心时，对两个子树分别跑 $dp_{i,j}$ 表示 $i$ 子树选择一个大小为 $j$ 的连通块的方案数。可以树上依赖背包 $O(n^2)$。

树有一个重心时，直接跑一遍上述 dp。考虑容斥，钦定某一个子树的大小超过整个连通块的一半。可以使用 dp 反演 $O(n^2)$ 解决。

总复杂度 $O(n^2T)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=10007;
vector<int> vc[5005];
int n,minv,siz[5005];
int dp[5005][5005];
vector<int> rd;
void dfs(int now,int fa){
	siz[now]=1;
	int tmpm=0;
	for(auto v:vc[now]){
		if(v==fa) continue;
		dfs(v,now);
		tmpm=max(tmpm,siz[v]);
		siz[now]+=siz[v];
	}
	tmpm=max(tmpm,n-siz[now]);
	if(tmpm<minv){
		minv=tmpm;
		rd.clear();
	}
	if(tmpm==minv){
		rd.push_back(now);
	}
}
int tmp[5005],pre[5005];
void dfs1(int now,int fa){
	siz[now]=1;
	dp[now][1]=1;
	for(auto v:vc[now]){
		if(v==fa) continue;
		dfs1(v,now);
		memset(tmp,0,sizeof(tmp));
		for(int i=1;i<=siz[now];i++){
			for(int j=0;j<=siz[v];j++){
				tmp[i+j]+=dp[now][i]*dp[v][j];
			}
		}
		siz[now]+=siz[v];
		for(int i=1;i<=siz[now];i++) dp[now][i]=tmp[i]%mod;
	}
	dp[now][0]=1;
}
signed main(){
	int q; cin>>q;
	for(int pp=1;pp<=q;pp++){
		cin>>n;
		for(int i=1;i<=n;i++) vc[i].clear();
		for(int i=1;i<=n;i++) for(int j=0;j<=n;j++) dp[i][j]=0;
		for(int i=1;i<n;i++){
			int u,v; cin>>u>>v;
			vc[u].push_back(v);
			vc[v].push_back(u);
		}
		minv=n;
		dfs(1,0);
		cout<<"Case "<<pp<<": ";
		if(rd.size()==2){
			dfs1(rd[0],rd[1]);
			dfs1(rd[1],rd[0]);
			int ans=0;
			for(int i=1;i<=n;i++){
				(ans+=dp[rd[0]][i]*dp[rd[1]][i])%=mod;
			}
			cout<<ans;
		}
		else{
			dfs1(rd[0],0);
			int rt=rd[0];
			int ans=0;
			for(int i=1;i<=n;i++){
				(ans+=dp[rt][i])%=mod;
			}
			for(auto v:vc[rt]){
				for(int i=1;i<=n;i++) tmp[i]=dp[rt][i];
				for(int i=1;i<=n;i++){
					for(int j=1;i-j>=1;j++){
						(tmp[i]+=mod-tmp[i-j]*dp[v][j]%mod);
					}
					tmp[i]%=mod;
				}
				for(int i=1;i<=n;i++) (tmp[i]+=tmp[i-1])%=mod;
				for(int i=1;i<=n;i++){
					(ans+=mod-tmp[i]*dp[v][i]%mod)%=mod;
				}
			}
			cout<<ans;
		}
		cout<<"\n";
	}
	return 0;
}
```

---


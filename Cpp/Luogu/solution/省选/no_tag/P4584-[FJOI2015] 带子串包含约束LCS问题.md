# [FJOI2015] 带子串包含约束LCS问题

## 题目描述

带有子串包含约束的最长公共子序列问题可以具体表述如下。
 
给定2个长度分别为n和m的序列X和Y，以及一个子串包含约束集S。

S中共有k个字符串$S=\{S_1,S_2,…,S_k\}$，其中字符串$S_i$的长度为$l_i$，1≤i≤k。带有子串包含约束的最长公共子序列问题就是要找出X和Y的包含约束集S中所有字符串为其子串的最长公共子序列。 

例如，如果给定的序列X和Y分别为X=actaagacct, Y=gacctacctc，子串包含约束集S={ata, tact}，则子序列actacct是X和Y的一个无约束的最长公共子序列，而包含约束集S中所有字符串为其子串的一个最长公共子序列是atact 。 
在本题中请特别关注子串与子序列的区别。字符串$T=t_1…t_n$的子串是一个形如$T$’$=t_1+i…t_m+i$的字符串，其中，0≤i，m+i≤n。例如，T=abcdefg，则bcd是T 的一个子串，而bce是T的一个子序列，但不是T 的子串。

设计一个算法，找出给定序列X和Y带有子串包含约束S的最长公共子序列。 

## 说明/提示

字符串仅包含大小写字母.

## 样例 #1

### 输入

```
10 10 2
3 4
actaagacct
gacctacctc
ata
tact```

### 输出

```
5```

# 题解

## 作者：JoaoFelix (赞：1)

好像还没有题解？来简要的写一下一篇不会证明的题解

我们可以把题目转化成两个不同的问题然后进行合并

第一个问题：
我们发现要求的是多串问题，然后这些串都要同时出现在一个串内，所以我们可以建出ac自动机，然后发现k<=6，因此可以状压出有没有出现过的状态，并且记录当前所在节点

第二个问题：
我们要求这个串是给出的两个串的公共子序列，然后这个我们可以考虑这是一个子序列自动机的裸题，只需要建出子序列自动机然后在自动机上遍历即可，记录在两个串上当前的位置就好了

所以综上所述要记录四个状态，第一个问题的两个和第二个问题的两个串的出现位置
我们发现这些状态之间的转移像是一个拓扑图，然后最长路转移就好了

然后发现状态数用数组记录不下，所以要用map，具体状态数不会太大（~~感性理解~~）
复杂度：O(能过)

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}

const int N = 1805;

int n, m, k, ch[N][52], tot, fail[N], ed[N], ans;
int tsx[305][52], tsy[305][52], l[N], lst[52];
char strx[305], stry[305], str[305];

struct node {
	int px, py, u, mask;
	node(int cpx = 0, int cpy = 0, int cu = 0, int cmask = 0) {
		px = cpx, py = cpy, u = cu, mask = cmask;
	}
	bool operator < (const node &c) const {
		if (px != c.px) return px < c.px;
		if (py != c.py) return py < c.py;
		if (u != c.u) return u < c.u;
		return mask < c.mask;
	}
};
map<node, int> stp; map<node, bool> inq;

int Type(char c) {
	if (c >= 'a' && c <= 'z') return c - 'a';
	return c - 'A' + 26;
}

#define SS ch[u][i]
void BFS() {
	queue<int> que; while (!que.empty()) que.pop();
	for (int i = 0; i < 52; i++) if (ch[0][i]) que.push(ch[0][i]);
	while (!que.empty()) {
		int u = que.front(); que.pop();
		for (int i = 0; i < 52; i++)
			if (!SS) SS = ch[fail[u]][i];
			else que.push(SS), fail[SS] = ch[fail[u]][i], ed[SS] |= ed[fail[SS]];
	}
}

void DP() {
	queue<node> que; while (!que.empty()) que.pop();
	stp[node(0, 0, 0, 0)] = 1; que.push(node(0, 0, 0, 0)), inq[node(0, 0, 0, 0)] = true;
	while (!que.empty()) {
		node now = que.front(); que.pop(); inq[now] = false;
		int ntp = stp[now];
		int px = now.px, py = now.py, u = now.u, mask = now.mask;
		if (mask == (1 << k) - 1) ans = max(ans, ntp);
		for (int i = 0; i < 52; i++) {
			int nx = tsx[px][i], ny = tsy[py][i], v = ch[u][i], nsk = mask | ed[v];
			if (nx > n || ny > m) continue; node to = node(nx, ny, v, nsk);
			if (!stp[to] || stp[to] < ntp + 1) {
				stp[to] = ntp + 1;
				if (!inq[to]) que.push(to);
			}
		}
	}
}

int main() {
	n = read(); m = read(); k = read();
	for (int i = 1; i <= k; i++) l[i] = read();
	scanf("%s", strx + 1), scanf("%s", stry + 1);
	for (int i = 0; i < 52; i++) lst[i] = n + 1;
	for (int i = n; i >= 0; i--) {
		for (int j = 0; j < 52; j++) tsx[i][j] = lst[j];
		lst[Type(strx[i])] = i;
	}
	for (int i = 0; i < 52; i++) lst[i] = m + 1;
	for (int i = m; i >= 0; i--) {
		for (int j = 0; j < 52; j++) tsy[i][j] = lst[j];
		lst[Type(stry[i])] = i;
	}
	for (int i = 1; i <= k; i++) {
		scanf("%s", str + 1); int u = 0;
		for (int j = 1; j <= l[i]; j++) {
			int p = Type(str[j]);
			if (!ch[u][p]) ch[u][p] = ++tot;
			u = ch[u][p];
		}
		ed[u] |= (1 << i - 1);
	}
	BFS(), DP();
	printf("%d\n", ans - 1);
	return 0;
}
```


---

## 作者：Fzrcy (赞：0)

简要题意：

> 求出字符串 $X$ 和 $Y$ 的最长公共子序列 $T$，使得集合 $S$ 中的字符串均为 $T$ 的子串（字符集为**大小写字母**）。

考虑对集合 $S$ 建立 AC 自动机 $A$、对字符串 $X$ 和 $Y$ 分别建立子序列自动机 $p$ 和 $q$。

设 $f(i,j,k,s)$ 表示当前节点分别在 $p$、$q$、$A$ 中的位置为 $i$、$j$、$k$，且已包含的子集为 $s$（$s\subseteq S$）的最长公共子序列的长度。

直接记忆化搜索，暴力枚举下一个选择的字母即可。

考虑到实际用到的节点并不多，所以我们考虑用 `map` 存储信息即可。

```cpp
// qwq
#include <bits/stdc++.h>
#define inl inline
#define rg register
#define R rg int
using namespace std;
inl int Get(char c){
    return (c>='a'&&c<='z')?c-'a':(26+c-'A');
}
constexpr int N=305,M=N*5+2;
// ACAM
int ch[M][52],fail[M],ban[M],cnt=1;
void ins(char *s,int len,int v){
    int u=1;
    for(R i=0;i<len;i++){
        R c=Get(s[i]);
        if(!ch[u][c])ch[u][c]=++cnt;
        u=ch[u][c];
    }
    ban[u]|=v;
}
void bfs(){
    for(R i=0;i<52;i++)ch[0][i]=1;
    queue<int>q;q.push(1);
    while(!q.empty()){
        int u=q.front();q.pop();ban[u]|=ban[fail[u]];
        for(R i=0;i<52;i++)
            if(!ch[u][i])ch[u][i]=ch[fail[u]][i];
            else fail[ch[u][i]]=ch[fail[u]][i],q.push(ch[u][i]);
    }
}
// 子序列自动机
int ch1[N][52],ch2[N][52];
void build(char* s,char* r,R n,R m){
    for(R i=n;i;i--)
        memcpy(ch1[i],ch1[i+1],sizeof ch1[i]),
        ch1[i][Get(s[i])]=i+1;
    for(R i=m;i;i--)
        memcpy(ch2[i],ch2[i+1],sizeof ch2[i]),
        ch2[i][Get(r[i])]=i+1;
}
// sol
int n,m,K;
struct node{
    int x,y,z,Ban;
    bool operator < (const node &b)const{
        if(x^b.x)return x<b.x;
        if(y^b.y)return y<b.y;
        if(z^b.z)return z<b.z;
        return Ban<b.Ban;
    }
};
map<node,int>mp;
int sol(R x,R y,R z,R vis){
    if(mp.count({x,y,z,vis}))return mp[{x,y,z,vis}];
    int ans=-1e9;if(vis==(1<<K)-1)ans=0;
    for(R i=0;i<52;i++){
        int nx=ch1[x][i],ny=ch2[y][i],nz=ch[z][i],nv=vis|ban[nz];
        if(!nx||!ny)continue; ans=max(ans,sol(nx,ny,nz,nv)+1);
    }
    return mp[{x,y,z,vis}]=ans;
}
char buf[N],Buf[N];int length[N];
int main(){
    scanf("%d %d %d",&n,&m,&K);
    for(R i=1;i<=K;i++)scanf("%d",&length[i]);
    scanf(" %s %s",buf+1,Buf+1);build(buf,Buf,n,m);
    for(R i=1;i<=K;i++)scanf(" %s",buf),ins(buf,length[i],1<<i-1);
    bfs();
    cout<<sol(1,1,1,0);
    return 0;
}
```



---


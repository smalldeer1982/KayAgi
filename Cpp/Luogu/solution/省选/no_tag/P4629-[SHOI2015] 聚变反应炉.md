# [SHOI2015] 聚变反应炉

## 题目描述

曾经发明了零件组装机的发明家 SHTSC 又公开了他的新发明：聚变反应炉——一种可以产生大量清洁能量的神秘装置。

众所周知，利用核聚变产生的能量有两个难点：一是控制核聚变反应的反应强度，二是使用较少的能量激发聚变反应。而 SHTSC 已经完美解决了第一个问题。一个聚变反应炉由若干个相连的聚变块组成，为了能够使得聚变反应可控，SHTSC 保证任意两个聚能块都可以通过相互之间的链接到达，并且没有一个聚能块可以不重复经过一个链接回到它自己。

但是第二个问题 SHTSC 还没有完全解决。在他设计的聚变反应炉当中，每个聚变块都需要一定的初始能量 $d_i$ 来进行激发，不过 SHTSC 不需要手动激发所有聚变块，这是因为一旦一个聚变块被激发，则会向与其直接相连的所有还未被激发的聚变块传送 $c_i$ 个单位的能量。这样后被触发的聚变块可以以更低的初始能量来激发，甚至可能不需要额外的外界能量就可自行激发，从而降低了总激发能量的消耗。现在给出了一个聚变反应炉，求至少要多少能量才能激发所有聚变块。

## 说明/提示

| Case # | $\max\{c_i\}$ | $n$ | 附加限制 |
|:---:|:---:|:---:|:---:|
| 1 | $= 1$ | $\leq 10$ | $c_i = 1$ |
| 2 | $= 1$ | $\leq 100$ | $c_i = 1$ |
| 3 | $= 1$ | $\leq 200$ | $c_i = 1$ |
| 4 | $= 0$ | $\leq 10$ | - |
| 5 | $= 1$ | $\leq 200$ | $c_i = 1$ |
| 6 | $= 1$ | $\leq 200$ | - |
| 7 | $= 1$ | $\leq 100000$ | $c_i = 1$ |
| 8 | $= 0$ | $\leq 100000$ | - |
| 9 | $= 1$ | $\leq 100000$ | - |
| 10 | $= 1$ | $\leq 100000$ | - |
| 11 | $\leq 5$ | $\leq 20$ | - |
| 12 | $\leq 5$ | $\leq 20$ | $c_i$ 均相等 |
| 13 | $\leq 5$ | $\leq 200$ | - |
| 14 | $\leq 5$ | $\leq 200$ | $c_i$ 均相等 |
| 15 | $\leq 5$ | $\leq 200$ | - |
| 16 | $\leq 5$ | $\leq 200$ | - |
| 17 | $\leq 5$ | $\leq 2000$ | $c_i$ 均相等 |
| 18 | $\leq 5$ | $\leq 2000$ | - |
| 19 | $\leq 5$ | $\leq 2000$ | - |
| 20 | $\leq 5$ | $\leq 2000$ | - |

对于所有数据，保证 $1 \le d_i, \sum d_i \le {10}^9$。

## 样例 #1

### 输入

```
5
1 1 1 1 1
1 1 1 1 1
1 2
2 3
3 4
4 5```

### 输出

```
1```

# 题解

## 作者：C20203030 (赞：9)


好久没有搞过树形dp的题了，它对新人很不友好，我就来补一发超详细的题解吧。

## 一、题目
[点此看题](https://www.luogu.org/problem/P4629)

**题意**

给定一棵树,其中每个号节点如果被点亮,就会对周围相连的节点发出ci格能量,点亮第i个节点需要的能量点数为di。问能点亮整棵树的最小能量花费。

**数据范围**

对于$50\%$的数据，$\max{ci}<=1,n<=100000$

对于另外$50\%$的数据，$\max{ci}<=5,n<=2000$

## 二、解法
第一眼看到这个数据范围，觉得特别神奇，我们考虑数据分治。

**0x01 贪心** 

先来考虑第一个范围，因为此时的$c$只包含0或1，我们考虑$c=1$的点的点亮顺序。无论怎么点亮，减少的能量花费总量都是一定的（可以自举例子加深理解），所以最优解和顺序无关，我们只需优先点亮$c=1$的点即可。

**0x02 树形dp**

第二个范围就没有那么容易了，受贪心的启发，我们考虑点亮顺序。利用树形dp，我们对局部的点亮顺序进行考虑我们定义$dp[i][0/1]$为对于第$i$个节点先染 它$/$它的父亲，并把$i$及$i$的子树染完的最小花费。

显然答案为$dp[1][0]$（$1$的父亲不存在，用它统计最优答案）。

现在我们考虑对$dp$数组的转移。

由于$c$并不是很大，我们可以把它作为一个维度，为了辅助转移，我们再定义$tmp[s]$为染完$u$的子树，并且接受了儿子们值为$s$的能量传递的最小花费（这里并不用去管$u$是否被染色），我们先遍历完子树，再用滚动数组的形式合并子树的信息，详细操作见下。


```cpp
memset(tmp,0x3f,sizeof tmp);
tmp[0][0]=0;//初始化
for(int i=f[u];i;i=e[i].next)//枚举每个儿子
{	
	int v=e[i].v;
	if(v==fa) continue;
	cur^=1;//滚动数组，用tmp[cur^1]更新tmp[cur]
	memset(tmp[cur],0x3f,sizeof tmp[cur]);
	for(int j=0;j<=sum-c[v];j++)//此时我们可以使用dp[v]
	{
            tmp[cur][j+c[v]]=min(tmp[cur][j+c[v]],tmp[cur^1][j]+dp[v][0]);//先点亮v
            tmp[cur][j]=min(tmp[cur][j],tmp[cur^1][j]+dp[v][1]);//先点亮u
     	}
}
```

拿到了$tmp$之后，更新就要简单一些了，我们可写出如下转移：
$dp[u][0]=min(dp[u][0],max(tmp[i],tmp[i]-i+d[u]));$
$dp[u][1]=min(dp[u][1],max(tmp[i],tmp[i]-i+d[u]-c[fa]));$
其中$i$是从儿子得到的能量，我们防止能量溢出（即有多余的能量），故取max。

**0x3f 代码**

作者口胡可能难以理解，更多请看完整版代码，也可以单独向作者提问qwq。

```cpp
#include <cstdio>
#include <cstring>
const int MAXN = 100005;
const int MAXM = 2005;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,tot,ans,mc,d[MAXN],c[MAXN],f[MAXN];
struct edge
{
    int v,next;
} e[MAXN*2];
int max(int x,int y)
{
    if(x<y) return y;
    return x;
}
int min(int x,int y)
{
    if(x<y) return x;
    return y;
}
int dp[MAXM][2],tmp[2][5*MAXM];
void dfs(int u,int fa)
{
    int sum=0,cur=0;
    for(int i=f[u]; i; i=e[i].next)
    {
        int v=e[i].v;
        if(v==fa) continue;
        dfs(v,u);
        sum+=c[v];
    }
    memset(tmp,0x3f,sizeof tmp);
    tmp[0][0]=0;
    for(int i=f[u]; i; i=e[i].next)
    {
        int v=e[i].v;
        if(v==fa) continue;
        cur^=1;
        memset(tmp[cur],0x3f,sizeof tmp[cur]);
        for(int j=0; j<=sum-c[v]; j++)
        {
            tmp[cur][j+c[v]]=min(tmp[cur][j+c[v]],tmp[cur^1][j]+dp[v][0]);
            tmp[cur][j]=min(tmp[cur][j],tmp[cur^1][j]+dp[v][1]);
        }
    }
    dp[u][0]=dp[u][1]=0x3f3f3f3f;
    for(int i=0; i<=sum; i++)
    {
        dp[u][0]=min(dp[u][0],max(tmp[cur][i],tmp[cur][i]-i+d[u]));
        dp[u][1]=min(dp[u][1],max(tmp[cur][i],tmp[cur][i]-i+d[u]-c[fa]));
    }
    return ;
}
int main()
{
    n=read();
    for(int i=1; i<=n; i++)
        d[i]=read();
    for(int i=1; i<=n; i++)
        c[i]=read(),mc=max(mc,c[i]);
    for(int i=1; i<n; i++)
    {
        int u=read(),v=read();
        e[++tot]=edge{u,f[v]},f[v]=tot;
        e[++tot]=edge{v,f[u]},f[u]=tot;
    }
    if(mc<=1)
    {
        for(int i=1; i<=n; i++)
            if(c[i]==1)
            {
                ans+=d[i];
                d[i]=0;
                for(int j=f[i]; j; j=e[j].next)
                    d[e[j].v]--;
            }
        for(int i=1; i<=n; i++)
            if(d[i]>0)
                ans+=d[i];
        printf("%d\n",ans);
        return 0;
    }
    dfs(1,0);
    printf("%d\n",dp[1][0]);
    return 0;
}
```



---

## 作者：SevenElevenThirteen (赞：5)

提供一种不一样的 dp 方式。神奇的是，这种方法 **在当前测试数据下** 不需要数据分治。~~言外之意就是它可以被卡。~~

定义 $dp_{i, 0}$ 表示先激发 $i$ 的父亲，再激发 $i$ 和它的子树所需的最小能量。同理，$dp_{i, 1}$ 表示先激发 $i$ 和它的子树，再激发 $i$ 的父亲所需的最小能量。答案为 $dp_{1, 1} \left( \text{不妨以 1 为根} \right)$。

设当前结点为 $u$，显然有 $dp_{u, 0} \leqslant dp_{u, 1}$。我们先递归处理 $u$ 的所有儿子，并假设先激活 $u$ 然后激活它的子树，即令 $dp_{u, 0} \gets \max \left( 0 , d_{u} - c_{fa} \right) + \sum \limits_{v \; \in \; son}^{} dp_{v, 0}\ ,\ dp_{u, 1} \gets d_{u} + \sum \limits_{v \; \in \; son}^{} dp_{v, 0}$。

当然，目前的 dp 值不一定是最优的，某些子树需要在 $u$ 之前激活。如果我们把 $v$ 移到 $u$ 前面，则 $v$ 增加 $dp_{v, 1} - dp_{v, 0}$ 单位能量，$u$ 减少 $\min \left( d_{u} , c_{v} \right)$ 单位能量。采用类似01背包的做法，定义 $f_{i}$ 表示 $u$ 的儿子向 $u$ 贡献 $i$ 单位能量（即先激活这些儿子再激活 $u$），最少需补充的能量。令 $sum \gets \sum \limits_{v \; \in \; son}^{} c_{v}$。

$$\text{初始化： } f_{i} = 
\begin{cases}
0 & i = 0 \\
\infty & 0 < i \leqslant sum
\end{cases}$$

$$\text{方程： } f_{i} \gets \min \left( f_{i} , f_{i - c_{v}} + dp_{v, 1} - dp_{v, 0} \right)$$

$$\left( \text{条件：} c_{v} \leqslant i \leqslant \min \left( sum , d_{u} + c_{v} -1 \right) \right)$$

说明：当 $i - c_{v} \geqslant d_{u}$ 时，$u$ 已被其他儿子的贡献激活，此状态无意义，故应略过。

得到 $f$ 数组的值，就可以更新 $dp_{u, 0\ /\ 1}$ 了。枚举 $i$，则 $dp_{u, 1} = \min \left\{ dp_{u, 1} + f_{i} - \min \left( d_{u}, i \right) \right\}$，$dp_{u,0}$ 同理，不要忘记来自父亲的贡献。

虽然计算 $f$ 时适当缩小了枚举范围，但总复杂度仍为 $O \left( cn^{2} \right)$。根据题目奇葩的数据范围，对 $n$ 较大的测试点需进行数据分治，改用贪心。贪心做法其他题解也有详细介绍，这里就不展开了。但此题数据有些水，沿用 dp 做法即可通过，而且跑得飞快。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e5, M = N << 1, SIZ = N * 5;
const long long INF = 4e18;
int n;
long long d[N + 5], c[N + 5];
int head[N + 5], to[M + 5], nxt[M + 5], tot;
void add_edge(int u, int v)
{
	tot++;
	to[tot] = v;
	nxt[tot] = head[u];
	head[u] = tot;
	return ;
}
void add(int u, int v)
{
	add_edge(u, v);
	add_edge(v, u);
	return ;
}
long long dp[N + 5][2];//0: father first; 1: itself first
long long f[SIZ + 5];
void dfs(int u, int fa)
{
	long long sum = 0;
	for (int i = head[u]; i; i = nxt[i])
	{
		int v = to[i];
		if (v == fa)
			continue;
		dfs(v, u);
		sum += c[v];
		dp[u][0] += dp[v][0], dp[u][1] += dp[v][0];
	}
	long long val = max(0ll, d[u] - c[fa]);
	dp[u][0] += val, dp[u][1] += d[u];
	for (int i = 1; i <= sum; i++)
		f[i] = INF;
	for (int i = head[u]; i; i = nxt[i])
	{
		int v = to[i];
		if (v == fa)
			continue;
		for (int j = min(sum, d[u] + c[v] - 1); j >= c[v]; j--)
			f[j] = min(f[j], f[j - c[v]] + dp[v][1] - dp[v][0]);
	}
	long long ori0 = dp[u][0], ori1 = dp[u][1];
	for (long long i = 1; i <= sum; i++)
	{
		dp[u][0] = min(dp[u][0], ori0 + f[i] - min(val, i));
		dp[u][1] = min(dp[u][1], ori1 + f[i] - min(d[u], i));
	}
	return ;
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%lld", d + i);
	for (int i = 1; i <= n; i++)
		scanf("%lld", c + i);
	for (int i = 1; i < n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v);
	}
	dfs(1, 0);
	printf("%lld\n", dp[1][1]);
	return 0;
}
```

---

## 作者：Betrayer_of_love (赞：3)

### 题意

------------
给定一棵 $n$ 个点的树，每个点有一个启动能量 $d$ 和传递能量 $c$ ，如果一个点被启动了，就会向和他直接相连的点发送 $c$ 的能量，初始所有节点能量为 $0$ ，问最少多少能量才能启动所有节点。

### 分析

------------
- 定义状态 $fi$ 表示先激活父亲再激活 $i$ ， $gi$ 表示先激活 $i$ 再激活父亲。

- 对于前 $50pts$ ，容易发现对于每个 $i$ 来说， $f$ 和 $g$ 的差值最多为 $1$ ，因为 $f$ 除了父亲的贡献，子树内的选择可以复制 $g$ 。

- 如果 $fi=gi$ (父亲一定不传能量)，那么一定选择 $g$ ，这样还 $i$ 还可以向父亲贡献；

- 如果 $gi−fi=1$ (父亲一定传能量)，一定选择 $f$ ，这样 $i$ 和父亲之间稳定传输了 $1$ 能量，反过来不一定。

- 对于后 $50$ 分，考虑对于所有 $i$ 的子节点进行一个 $dp$ ，定义 hi表示一共收到了来自儿子的 $i$ 点能量的最小花费。复杂度 $O(n^2)$ 。

### CODE

------------

```c
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)
#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define pb push_back
#define re(x) memset(x, 0, sizeof x)
inline int gi() {
    int x = 0,f = 1;
    char ch = getchar();
    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}
    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}
    return x * f;
}
template <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}
template <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}
const int N = 1e5 + 7, inf = 0x3f3f3f3f;
int n, edc, mx;
int d[N], c[N], head[N];
struct edge {
	int lst, to;
	edge(){}edge(int lst, int to):lst(lst), to(to){}
}e[N << 1];
void Add(int a, int b) {
	e[++edc] = edge(head[a], b), head[a] = edc;
	e[++edc] = edge(head[b], a), head[b] = edc;
}
namespace task1 {
    const int N = 1e5 + 7;
    int f[N], g[N];
    void dfs(int u, int fa) {
    	int cnt = 0;
    	g[u] = d[u];
    	go(u)if(v ^ fa) {
    		dfs(v, u);
    		if(f[v] < g[v]) g[u] += f[v];
    		else {
				g[u] += g[v];
				if(cnt < d[u] && c[v]) {
					++cnt;
					g[u]--;
				}
			}
    	}
    	f[u] = g[u] - (c[fa] && cnt < d[u]);
    }
    void solve() {
    	dfs(1, 0);
    	printf("%d\n", g[1]);
    }
}
namespace task2 {
	const int N = 2007;
	int g[N], f[N], h[N][10004], t[10004];
	void dfs(int u, int fa) {
		memset(h[u], 0x3f, sizeof h[u]);
		h[u][0] = 0;
		go(u)if(v ^ fa) {
			dfs(v, u);
			memset(t, 0x3f, sizeof t);
			for(int tv = min(10000, d[u]); ~tv; --tv) if(h[u][tv] != inf) {
				Min(t[min(d[u], tv + c[v])], h[u][tv] + g[v]);
				Min(t[tv], h[u][tv] + f[v]);
			}
			memcpy(h[u], t, sizeof t);
		}
		g[u] = f[u] = inf;
		for(int i = 0; i <= min(10000, d[u]); ++i) {
			Min(g[u], h[u][i] + d[u] - i);
			Min(f[u], h[u][i] + max(0, d[u] - i - c[fa]));
		}
	}
	void solve() {
		dfs(1, 0);
		printf("%d\n", g[1]);
	}
}
int main() {
    n = gi();
    rep(i, 1, n) d[i] = gi();
    rep(i, 1, n) c[i] = gi(), Max(mx, c[i]);
    rep(i, 1, n - 1) Add(gi(), gi());
    mx <= 1 ? task1::solve() : task2::solve();
	return 0;
}
```


**完结撒花，谢谢！！！**

---

## 作者：打程序的咸鱼 (赞：3)

## 前言

希望审核能给我过了这篇题解。

## 题目

[题目传送门](https://www.luogu.com.cn/problem/P4629)

## 正文

由于数据非常水，可以用贪心来 AC 。

我们可以考虑将每个板块压成一个点，这样我们就得到了一个联通
图，将它需要的能量加起来。

处理联通图，对每一个连接的板块判断哪个可以对这个联通图做最大的贡献，然后用需要的总能量减掉当前贡献。

思路是不是特简单。

我的代码：（有一点注释帮助理解）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,a[100001],c[100001];
inline long long read()//快读 
{
	long long ans=0,f=1;
	char c;
	c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
		f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		ans=ans*10+c-'0';
		c=getchar();
	}
	return ans*f;
}
int main() 
{
    n=read();
    for (int i=1;i<=n;++i) 
    {
        a[i]=read();
        ans+=a[i];//把需要的能量加起来
    }
    for(int i=1;i<=n;++i) 
    {
    	c[i]=read();//释放的能量 
    }
    for(int i=1,p,q;i<n;++i) 
    {
        p=read(),q=read();
        ans-=max(c[p],c[q]);//直接选择能对连通图贡献最大的板块，然后减去
    }
    printf("%d",ans);
    return 0;
}
```
#### 但是，如果屏幕前的你得知自己复制这个程序后得分为 90  分的话，你就要小心了。

由于直接选择联通块会导致有些能量不能最大利用或溢出，那么应当在原有基础上做一些改变。

首先如果你释放的能量为 0 ，那么选择你也没用，就要保证受贡献的点不为 0 。

其次，你不能做贡献且你接受的能量大于你所需要的能量，那么能量就多减了，应该加回来。

我的AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,a[100001],c[100001],d[100001];
inline long long read()//快读 
{
	long long ans=0,f=1;
	char c;
	c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
		f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		ans=ans*10+c-'0';
		c=getchar();
	}
	return ans*f;
}
int main() 
{
    n=read();
    for (int i=1;i<=n;++i) 
	{
        a[i]=read();
        ans+=a[i];//把需要的能量加起来
    }
    for(int i=1;i<=n;++i) 
    {
    	c[i]=read();//释放的能量 
	}
    for(int i=1,p,q;i<n;++i) 
	{
		p=read(),q=read();
        ans-=max(c[p],c[q]);//先选择能对周围板块贡献最大的，然后减去 
        if(c[p]>c[q]&&c[p])//如果是P做贡献
        {
        	++d[q];//Q接受的能量块+1 
		}
        if(c[p]<=c[q]&&c[q])//如果是Q做贡献 
        {
        	++d[p];//P接受的能量块+1
		}
    }
    for(int i=1;i<=n;++i)
    {
    	if(!c[i]&&d[i]>a[i])//判断有没有能量溢出
    	{
    		ans+=(d[i]-a[i]);//总需要的能量加上溢出的能量 
		}
	}
    printf("%d",ans);
    return 0;
}
```
### 最后希望这篇题解能帮到屏幕前的你，但是不要抄袭哦！

---

## 作者：wjyyy (赞：3)

## 前言

WC考了个树上游戏三合一，虽然这题是个“二合一”，但也不是非常简单。

**[博客传送门](https://www.wjyyy.top/3306.html)**

## 题解：

前面50分是个贪心。只需要先激发所有的 $1$ 再激发所有的 $0$ 即可。

此时考虑 $1$ 之间会不会互相影响。因为相邻的 $1$ 所造成的影响只是先后顺序上的，**早晚都会减掉的**，只是位置不同而已。

后面50分需要~~高阶~~树形dp，实则是个背包。用 $f[i][j]$ 表示 $i$ 号点在**已接受儿子们贡献的 $j$ 点能量后**的最小花费，要把 $j$ 当成背包那一维。

并且有可能出现 $j>d_i$ 的情况，但是这是不合法的。因此我们也需要控制，当接收的能量超过 $d_i$ 时要按 $d_i$ 算。

此外，对于每个儿子做背包的时候，如果不接受它贡献的能量，则可以自己贡献能量给它。所以dp转移方程并不像以前的背包那样，而是要计算能量**下传**可能带来的更小代价。

因此我们做到一个儿子 $v$ 的时候，先求出**给它下传能量后**的最小代价 $m=\min\{f[v][j]-\min(c_i,d_v-j)\}$，然后dp的时候再利用这个值就可以了。

因此转移方程为（正在转移儿子 $v$）
$$f[i][j]=\left\{\begin{matrix}f[i][0]+m&j=0,\\\min(f[i][j-c_v]-c_v+F[v],f[i][j]+m)&k\le j\le d_i\\\min_{0\le k\le c_v}\{f[i][d_i-k]-k+F[v]\}&j=d_i\end{matrix}\right.$$

其中 $F[v]=\min_{0}^{d[v]}\{f[v][i]\}$。

加 $F[v]$ 的是从儿子获取能量，涉及 $m$ 的是自己下传能量。

不过从儿子获取的能量最多为 $nc_i$ ，为10000，因此数组只用开 10000 即可，注意边界问题。

## Code：

```cpp
#include<cstdio>
#include<cstring>
int Min(int x,int y){return x<y?x:y;}
struct edge
{
    int n,nxt;
    edge(int n,int nxt)
    {
        this->n=n;
        this->nxt=nxt;
    }
    edge(){}
}e[200100];
int head[100100],ecnt=-1;
void add(int from,int to)
{
    e[++ecnt]=edge(to,head[from]);
    head[from]=ecnt;
    e[++ecnt]=edge(from,head[to]);
    head[to]=ecnt;
}
int d[100100],c[100100];
int F[2010];
void dfs(int x,int from)
{
    int f[10010];
    memset(f,0x3f,sizeof(f));
    f[x][0]=d[x];
    for(int i=head[x];~i;i=e[i].nxt)
        if(e[i].n!=from)
        {
            dfs(e[i].n,x);
            int k=c[e[i].n],tmp=0x3fffffff,t=F[e[i].n];

            for(int j=0;j<=10000;++j)
            {
                f[x][j]+=t;
                tmp=Min(tmp,f[e[i].n][j]-Min(c[x],d[e[i].n]-j));
            }

            //对于每个物品 拿或不拿都有不同的贡献 需要注意

            if(d[x]<=10000)
            {
                f[x][d[x]]-=t-tmp;
                for(int j=d[x];j>=d[x]-k;--j)
                    f[x][d[x]]=Min(f[x][d[x]],f[x][j]-(d[x]-j));
            }

            for(int j=Min(d[x]-1,10000);j>=k;--j)
                f[x][j]=Min(f[x][j]-t+tmp,f[x][j-k]-k);

            if(k)
            {
                f[x][0]-=F[e[i].n];//撤销统一修改
                f[x][0]+=tmp;
            }

        }
    for(int i=0;i<=10000;++i)
        if(f[x][i]<F[x])
            F[x]=f[x][i];
}
int main()
{
    memset(f,0x3f,sizeof(f));
    memset(F,0x3f,sizeof(F));
    memset(head,-1,sizeof(head));
    int n,u,v;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",&d[i]);
    for(int i=1;i<=n;++i)
        scanf("%d",&c[i]);
    for(int i=1;i<n;++i)
    {
        scanf("%d%d",&u,&v);
        add(u,v);
    }
    if(n>2000)//数据分治
    {
        for(int i=1;i<=n;++i)
            if(c[i])
                for(int j=head[i];~j;j=e[j].nxt)
                    if(e[j].n>i||!c[e[j].n])
                        --d[e[j].n];
        int sum=0;
        for(int i=1;i<=n;++i)
            sum+=d[i]<0?0:d[i];
        printf("%d\n",sum);
        return 0;
    }
    dfs(1,1);
    printf("%d\n",F[1]);
    return 0;
}
```

---

## 作者：qiuweilin666 (赞：2)


# 题解 

## 思路
将每个板块当作一个点，得到了联通图，把能量加起来。接着处理联通图，判断每个板块可以对这个联通图有最大的贡献 $sn$，然后用需要的总能量减掉当前贡献即可,即 $\max(c_u,c_v)$。

但是，直接选择联通块会导致有些能量不能适当的运用，那么应该做出调整。当不能做贡献时并且接受的能量还大于所需要的能量，应该加上多减去的能量 $a_i- d_i$。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,sn,u,v;
long long d[100010],c[100010],a[100010];
long long max(long long x ,long long y){
	if(x>y)return x;
	return y;
}
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;++i){
		scanf("%lld",&d[i]);
		sn+=d[i];//总能量
	}
	
	for(long long i=1;i<=n;++i)
		scanf("%lld",&c[i]);
	for(long long i=1;i<n;++i){
		scanf("%lld%lld",&u,&v);
		sn-=max(c[u],c[v]);//求出最大的贡献并减去
		if(c[u]>c[v]) ++a[v];
		if(c[u]<=c[v]&&c[v]) ++a[u];
	}
	for(int i=1;i<=n;++i)
		if(!c[i]&&a[i]>d[i]) sn+=a[i]-d[i];//应该加上多减去的能量
	printf("%lld",sn);
}
```


---

## 作者：ppp204 (赞：2)

#### 概括后的题目:

给定一棵树,其中每个号节点如果被点亮,就会对周围相连的节点发出$c_i$格能量,点亮第$i$个节点需要的能量点数为$d_i$。问能点亮整棵树的最小能量花费。

> 做法: 树形DP(转换背包)

首先,我们分成两种情况进行写(即切开写,因为两种情况下n的范围不同)

1. $Max\{C_i\}\leq1,n\leq100000$

这种情况下只需要一个贪心就能拿到50分,即只要$C_i==1$的先点,一定是会有贡献的,接下来看$C_i==0$的那些,如果没点着再点,统计需要点的能量总和即可

2. $Max\{C_i\}\leq5,n\leq2000$

我们分开两种情况进行讨论:**儿子先点**与**父亲先点**

父亲先点的话,要考虑对儿子的贡献,而儿子先点的话,要算上对父亲的贡献

最后就能得出以下$dfs$函数了(前面计算相关儿子部分直接用$tmp$代替了)

```
int sum=0;
Erep(i,x){
	int y=Edge[i].to;
	if(y==fa) continue;
	dfs(y,x);
	sum+=C[y];
}
ms(tmp,-1); tmp[0][0]=0;
int cur=0;
Erep(i,x){//把这个点当成父亲看待
	int y=Edge[i].to;
	if(y==fa) continue;
	cur^=1; ms(tmp[cur],-1);
	rep(j,0,sum-C[y]){
		if(~tmp[cur^1][j]){
			Min(tmp[cur][j+C[y]],tmp[cur^1][j]+dp[y][0]);//儿子先点,对父亲贡献c[y]
			Min(tmp[cur][j],tmp[cur^1][j]+dp[y][1]);//当前节点先点,儿子并没有对父亲贡献
		}
	}
}
dp[x][0]=dp[x][1]=oo;//初始化
rep(i,0,sum){//把这个点当成儿子看待
	if(~tmp[cur][i]){//存在这种情况
		Min(dp[x][1],max(tmp[cur][i],tmp[cur][i]+D[x]-i-C[fa]));//父亲传下来了贡献
		Min(dp[x][0],max(tmp[cur][i],tmp[cur][i]+D[x]-i));//当前节点传贡献给父亲
	}
}
```

#### Code:

```
#include<bits/stdc++.h>
#define re register
#define rep(i,a,b) for(int i=a,i##end=b; i<=i##end; i++)
#define drep(i,a,b) for(int i=a,i##end=b; i>=i##end; i--)
#define repp(i,a,b) for(int i=a,i##end=b; i<i##end; i++)
#define drepp(i,a,b) for(int i=a,i##end=b; i>i##end; i--)
#define Erep(i,x) for(int i=head[x]; ~i; i=Edge[i].nxt)
#define ll long long
#define debug(x) cout<<#x<<" = "<<x<<endl
#define lowbit(x) (x&-x)
#define ms(x,a) memset(x,a,sizeof x)
using namespace std;
template <class T> inline bool Max(T &x, T y){
	return x<y?x=y,1:0;
}
template <class T> inline bool Min(T &x, T y){
	return (x>y||x==-1)?x=y,1:0;
}
template <class T> inline T rd() {
	static char ch;static bool neg;
	static T x=0;
	for(ch=neg=0;ch<'0' || '9'<ch;neg|=ch=='-',ch=getchar());
	for(x=0;'0'<=ch && ch<='9';(x*=10)+=ch-'0',ch=getchar());
	return x=(neg?-x:x);
}
const int mod=1e9+7,oo=2e9,M=2000+5,N=100000+5;

int n,m;
int C[N],D[N];
struct edge{
	int to,nxt;
}Edge[N<<1];
int head[N],tcnt;
void AddEdge(int u, int v){
	Edge[++tcnt]=(edge)<%v,head[u]%>;
	head[u]=tcnt; return;
}

struct P50{
	inline void solve(){
		int tot=0;
		rep(i,1,n) if(C[i]){
			tot+=max(D[i],0);
			Erep(j,i){
				int y=Edge[j].to;
				D[y]--;
			}
		}
		rep(i,1,n) if(!C[i]){
			tot+=max(D[i],0);
		}
		printf("%d\n",tot);
	}
}p50;
int tmp[2][M*5];
int dp[M][2];
struct P100{
	void dfs(int x, int fa){
		int sum=0;
		Erep(i,x){
			int y=Edge[i].to;
			if(y==fa) continue;
			dfs(y,x);
			sum+=C[y];
		}
		ms(tmp,-1); tmp[0][0]=0;
		int cur=0;
		Erep(i,x){
			int y=Edge[i].to;
			if(y==fa) continue;
			cur^=1; ms(tmp[cur],-1);
			rep(j,0,sum-C[y]){
				if(~tmp[cur^1][j]){
					Min(tmp[cur][j+C[y]],tmp[cur^1][j]+dp[y][0]);//儿子先点,对父亲贡献c[y]
					Min(tmp[cur][j],tmp[cur^1][j]+dp[y][1]);//当前节点先点,儿子并没有对父亲贡献
				}
			}
//        	for(int j=0; j<=sum; j++) printf("tmp[%d][%d] == %d\n",cur,j,tmp[cur][j]);
		}
		dp[x][0]=dp[x][1]=oo;
		rep(i,0,sum){//把这个点当成儿子看待
			if(~tmp[cur][i]){
				Min(dp[x][1],max(tmp[cur][i],tmp[cur][i]+D[x]-i-C[fa]));//父亲传下来了贡献
				Min(dp[x][0],max(tmp[cur][i],tmp[cur][i]+D[x]-i));//当前节点传贡献给父亲
			}
		}
//		printf("dp[%d] == { %d, %d }\n",x,dp[x][0],dp[x][1]);
		return;
	}
	void solve(){
		dfs(1,0);
		printf("%d\n",dp[1][0]);
		return;
	}
}p100;

int main(){
//	freopen("fusion.in","r",stdin);
//	freopen("fusion1.out","w",stdout);
	ms(head,-1);
	n=rd<int>();
	int mx=0;
	rep(i,1,n) D[i]=rd<int>();
	rep(i,1,n) C[i]=rd<int>(),Max(mx,C[i]);
	repp(i,1,n){
		int u=rd<int>(),v=rd<int>();
		AddEdge(u,v); AddEdge(v,u);
	}
	if(mx<=1) p50.solve();
	else p100.solve();
	return 0;
}
```

---

## 作者：_Cheems (赞：1)

神秘数据分治题？

看到数据范围，很神奇吧。

先考虑前 $10$ 个数据。由于此时 $c_i=0/1$，不难想到先对 $c_i=1$ 的点操作，$c_i=0$ 的点因为激活它没有贡献，所以最后点亮。

然后讨论激活相邻两点 $a,b$，满足 $c_a=1$ 且 $c_b=1$。不难发现先激活 $a$ 的花费是 $d_a+d_b-1$，先 $b$ 就是 $d_b+d_a-1$，两者相等。又因为两种情况对外部的贡献相等，所以可以随意选择激活顺序。

推广到整棵树，这就意味着可以随意选择激活 $c=1$ 的点的顺序。当然，这个点必须还未被激活。

然后考虑后 $10$ 个数据。使用树形 $\rm dp$。

从底向上讨论下 $u$ 的子树。可发现，其子树内部不可能出现如下情况；

![](https://cdn.luogu.com.cn/upload/image_hosting/72vtpbn1.png)

意思是：不管 $u$ 怎么传递能量，都会在这个已激活的点上终止传递，下面没激活的就永远不会被激活了。

所以激活的点应该是从叶子开始一块块连续排列的。

但是 $u$ 到其子树内最上面一个被激活的点的这条路径，构成一条链，肯定是不能直接枚举了。

有没有办法只枚举 $u$ 的儿子呢？当然有，我们把这条链分为一条条边，独立转移就好了。拆分为小状态是动态规划基本思想嘛。

然后再看到 $c\le5$，也就是说接收到来自其它点的能量相当小，这启示我们按照它定义状态：令 $f_{u.i}$ 表示 $u$ 再接受 $i$ 能量（并向下传递）即可使得整个子树都被激活时，最小花费。

转移比较显然了，将子树 $v$ 逐个加入，枚举 $f_{u,i},f_{v,j}$：

若 $i=0$，需满足 $c_u\ge j$：$f_{u,0}+f_{v,j}\to f_{u,0}$。

若 $j=0$：$f_{u,i}+f_{v,j}\to f_{u,max(0,i-c_v)}$。

其他情况，需满足 $c_u\ge j$：$f_{u,i}+f_{v,j}\to f_{u,i}$。

（可以把转移 $1$ 和转移 $3$ 放在一起。）

最后是复杂度：对于 $f_u$，第二维的上界是 $S_u=\sum c_{v_i}$，$v_i$ 是与 $u$ 相邻节点。因为 $\sum S_u$ 是 $O(n)$ 级别的，所以总复杂度 $O(n^2)$（严格证明可参考树上背包）。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define MIN(a, b) a = min(a, b)
const int N = 1e5 + 5, NN = 2e3 + 5;
const long long inf = 1e18;
int n, d[N], c[N], u, v;
long long f[NN][NN * 5], s[NN], lim[NN], ans, g[NN * 5];
vector<int> to[N];

inline void calc1(){
	for(int i = 1; i <= n; ++i)
		if(c[i]){
			ans += max(0, d[i]), d[i] = 0;
			for(auto v : to[i]) --d[v];
		}
	for(int i = 1; i <= n; ++i) ans += max(0, d[i]);
	cout << ans;
}
inline void dfs(int u, int fa){
	lim[u] = min(1ll * d[u], s[u]);
	for(int i = 0; i <= lim[u]; ++i) f[u][i] = d[u] - i;
	for(auto v : to[u])
		if(v ^ fa){
			dfs(v, u);
			for(int i = 0; i <= lim[u]; ++i) g[i] = f[u][i], f[u][i] = inf;
			for(int i = 0; i <= lim[u]; ++i)
				for(int j = 0; j <= lim[v]; ++j){
					if(g[i] == inf || f[v][j] == inf) continue;
					if(j == 0) MIN(f[u][max(0, i - c[v])], g[i] + f[v][j]);
					else if(c[u] >= j) MIN(f[u][i], g[i] + f[v][j]);
				}
		}
}
inline void calc2(){
	dfs(1, 0);
	cout << f[1][0];
}
int main(){
	cin >> n;
	for(int i = 1; i <= n; ++i) scanf("%d", &d[i]);
	for(int i = 1; i <= n; ++i) scanf("%d", &c[i]);
	for(int i = 1; i < n; ++i) scanf("%d%d", &u, &v), to[u].push_back(v), to[v].push_back(u), s[u] += c[v], s[v] += c[u];
	if(n > 2000) calc1();
	else calc2();
	return 0;
}
```

---

## 作者：lprdsb (赞：1)

考虑树形$dp$

令$f(n)$表示激发了$n$的子树内的所有点，且在$fa(n)$之前激发$n$的最小花费

令$g(n)$表示激发了$n$的子树内的所有点，且在$fa(n)$之后激发$n$的最小花费

那么我们根据这个$dp$即可

具体的，在对每一个点算贡献的时候，另外开一个数组$h(n)$表示从这个点儿子处传上来$n$的能量的最小贡献，转移时考虑这个儿子的状态以及父亲的状态即可

```cpp
#include<bits/stdc++.h>
#define For(i, a, b) for(int i = (a), en = (b); i <= en; ++i)
#define Rof(i, a, b) for(int i = (a), en = (b); i >= en; --i)
#define Tra(u, i) for(int i = hd[u]; ~i; i = e[i].net)
#define cst const
#define LL long long
#define DD double
#define LD long double
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define inf 0x3f3f3f3f
#define Inf 0x3f3f3f3f3f3f3f3f
#define eps 1e-12
#define maxn 100000
using namespace std;

int n, d[maxn + 5], c[maxn + 5], hd[maxn + 5], len = 0;
LL f[maxn + 5], g[maxn + 5];
struct Edge{int v, net;} e[2 * maxn + 5];
void add(int u, int v){e[len] = (Edge){v, hd[u]}; hd[u] = len++;}

template <class T>
void read(T &x){
	char ch;
	bool ok;
	for(ok = 0, ch = getchar(); !isdigit(ch); ch = getchar()) if(ch == '-') ok = 1;
	for(x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());
	if(ok) x = -x;
}

void chkmn(LL &x, LL y){if(x > y) x = y;}

namespace c1{
	LL h[5 * maxn + 5];
	void dfs(int u, int pre){
		LL sum = 0;
		Tra(u, i){
			int v = e[i].v;
			if(v == pre) continue;
			sum += c[v];
			dfs(v, u);
		}
		memset(h, inf, sizeof h); h[0] = 0;
		Tra(u, i){
			int v = e[i].v;
			if(v == pre) continue;
			Rof(j, sum, 0){
				h[j] += g[v];
				if(j >= c[v]) chkmn(h[j], h[j - c[v]] + f[v]);	
			}
		}
		For(i, 0, sum){
			chkmn(f[u], h[i] + max(0, d[u] - i));
			chkmn(g[u], h[i] + max(0, d[u] - i - c[pre]));
		}
	}
	void work(){
		memset(f, inf, sizeof f);
		memset(g, inf, sizeof g);
		dfs(1, 0);
		printf("%lld\n", f[1]);
	}
}

namespace c2{
	void dfs(int u, int pre){
		LL val = 0;
		set<pair<LL, int> > se;
		Tra(u, i){
			int v = e[i].v;
			if(v == pre) continue;
			dfs(v, u);
			val += g[v];
			if(c[v]) se.insert(mp(f[v] - g[v], v));
		}
		chkmn(f[u], val + d[u]);
		chkmn(g[u], val + max(0, d[u] - c[pre]));
		For(i, 1, n){
			if(!se.size()) break;
			pair<int, int> tem = *se.begin(); se.erase(tem);
			val += tem.fir;
			chkmn(f[u], val + max(0, d[u] - i));
			chkmn(g[u], val + max(0, d[u] - i - c[pre]));
		}
	}
	void work(){
		memset(f, inf, sizeof f);
		memset(g, inf, sizeof g);
		dfs(1, 0);
		printf("%lld\n", f[1]);
	}
}

int main(){
	//freopen("fusion.in", "r", stdin);
	//freopen("fusion.out", "w", stdout);
	memset(hd, -1, sizeof hd);
	read(n);
	For(i, 1, n) read(d[i]);
	For(i, 1, n) read(c[i]);
	For(i, 1, n - 1){
		int u, v; read(u); read(v);
		add(u, v); add(v, u);
	}
	if(n <= 2000) c1::work();
	else c2::work();
	return 0;
}
```



---

## 作者：binbin_200811 (赞：0)

# [P4629 SHOI2015 聚变反应炉](https://www.luogu.com.cn/problem/P4629)

树上背包+树形dp。

算是套娃题吗？

## 思路

看到数据考虑数据分治。

### part1 贪心 $c_i\leq 1$

对于这种情况，我们考虑贪心的点亮。

手玩几组数据，发现只要先全部点亮 $c_i=1$ 的点，都可以得到最优解。

若存在一个 $c_i=1$ 的节点连接 $1$ 的节点个数小于 $d_i$，设个数为 $w$，那么我们后选他可以减少 $w$ 的能量。

若我们在中途的某一个时刻选择这个点，他也可以对答案减少 $w$ 的能量（$d_i\geq 1$，没激活的邻接点 $-1$，激活的也可以 $-1$）。

若这个点的 $d_i$ 小于连接 $1$ 的节点的个数，若我们需要花费能量激活的话，和上述情况同理；若不需要花费能量激活，此时的没有被激活的边又可以造成 $-1$ 的贡献。

所以无论选择的顺序，只要先选择 $c=1$ 的点，我们一定可以最小化答案。

至于等于 $c=0$ 的点，吸收完所有 $c=1$ 的点的贡献在激活一定是最优的。

### part2 树形 dp

首先这题的状态不是很好设，因为要考虑儿子的贡献，父亲的贡献，很容易就混进去了。

我们不妨想着先解决父亲的贡献。

设 $dp[u][0]$ 为 $u$ 先点亮，且 $u$ 子树内均被点亮的最小能量，$dp[u][1]$ 为 $u$ 的父亲比 $u$ 先被点亮，$u$ 的子树内再被点亮的最小能量。

显然这样子没有考虑儿子的传递的能量，我们是写不出转移方程的。

不如设 $tmp[u][i][j]$ 为 $u$ 的前 $i$ 个儿子给 $u$ 传递了 $j$ 的能量，点亮前 $i$ 个儿子的子树内的所有点的最小能量。

这里有转移：
$$
tmp[u][i][j+c[v]]=\min(dp[u][i][j+c[v]],tmp[u][i-1][j]+dp[v][0])\\
tmp[u][i][j]=\min(dp[u][i][j],tmp[u][i-1][j]+dp[v][1])
$$
不难发现我们这是一个树上背包，我们对其使用滚动数组优化。
$$
tmp[u][cur][j+c[v]]=\min(dp[u][cur][j+c[v]],tmp[u][cur\oplus 1][j]+dp[v][0])\\
tmp[u][cur][j]=\min(dp[u][cur][j],tmp[u][cur\oplus 1][j]+dp[v][1])
$$
对于 $dp[u][0/1]$ 有转移：

令 $sum=\sum_{v\in u.sons} c[v]$，$fa$ 为 $u$ 的父亲。
$$
dp[u][0]=\min_{i=0}^{sum} (dp[u][0],\max(tmp[i],tmp[i]-i+d[u]))\\
dp[u][1]=\min_{i=0}^{sum}(dp[u][0],\max(tmp[i],tmp[i]-i+d[u]-c[fa]))
$$


由于父亲的方程和 $tmp$ 无关，可以每次新开一个 $tmp$ 数组。

最后 $dp[1][0]$ 就是答案喽。

## CODE

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long

const int maxn=2e5+5,maxm=3e3+5;

struct Edge
{
    int tot;
    int head[maxn];
    struct edgenode{int to,nxt;}edge[maxn*2];
    inline void add(int x,int y)
    {
        tot++;
        edge[tot].to=y;
        edge[tot].nxt=head[x];
        head[x]=tot;
    }
}T;

int n;
int d[maxn],c[maxn];

ll dp[maxm][2],tmp[2][maxm*5];

inline void solve()
{
    ll ans=0;
    for(int i=1;i<=n;i++)
    {
        if(c[i]==1)
        {
            ans+=d[i];d[i]=0;
            for(int j=T.head[i];j;j=T.edge[j].nxt)
            {
                int v=T.edge[j].to;
                d[v]--;
            }
        }
    }
    for(int i=1;i<=n;i++) if(d[i]>0) ans+=d[i];
    printf("%lld",ans);
}
inline void dfs(int u,int f)//dp 部分
{
    int sum=0;
    for(int i=T.head[u];i;i=T.edge[i].nxt)
    {
        int v=T.edge[i].to;
        if(v==f) continue;
        dfs(v,u);sum+=c[v];
    }
    memset(tmp,0x3f,sizeof(tmp));
    tmp[0][0]=0;
    int cur=0;
    for(int i=T.head[u];i;i=T.edge[i].nxt)
    {
        int v=T.edge[i].to;
        if(v==f) continue;
        cur^=1;
        memset(tmp[cur],0x3f,sizeof(tmp[cur]));
        for(int j=0;j<=sum-c[v];j++)
        {
            tmp[cur][j+c[v]]=min(tmp[cur][j+c[v]],tmp[cur^1][j]+dp[v][0]);
            tmp[cur][j]=min(tmp[cur][j],tmp[cur^1][j]+dp[v][1]);
        }
    }
    for(int i=0;i<=sum;i++)
    {
        dp[u][0]=min(dp[u][0],max(tmp[cur][i],tmp[cur][i]-i+d[u]));
        dp[u][1]=min(dp[u][1],max(tmp[cur][i],tmp[cur][i]-i+d[u]-c[f]));
    }
}

int main()
{
    int mx=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&d[i]);
    for(int i=1;i<=n;i++) scanf("%d",&c[i]),mx=max(c[i],mx);
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        T.add(x,y),T.add(y,x);
    }
    if(mx<=1) solve(),exit(0);
    memset(dp,0x3f,sizeof(dp));
    dfs(1,0);
    printf("%lld",dp[1][0]);
}
```

---


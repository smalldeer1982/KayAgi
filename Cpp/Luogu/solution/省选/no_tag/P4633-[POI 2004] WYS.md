# [POI 2004] WYS

## 题目背景

虽然题目名比较毒瘤，但这确实是一个简单题。

## 题目描述

给 $n$ 个互不相交的多边形，这些多边形的边均平行或垂直于坐标轴。定义多边形 $i$ 的深度 $d_i$ 为 $\max\{d_j\}+1$，其中多边形 $j$ 包含多边形 $i$。特别的，若一个多边形不被任何多边形包含，则其深度为 $1$。求深度最大的多边形的深度。

## 说明/提示

对于 $100\%$ 的数据，$n \leqslant 40000, \sum k \leqslant 200000$。

## 样例 #1

### 输入

```
3
4 0 0 10 10
4 3 4 6 8
4 1 1 2 2```

### 输出

```
2```

## 样例 #2

### 输入

```
6
4 1 0 17 12
16 10 4 16 11 2 4 8 2 3 3 2 1 16 3 15 2
8 8 10 3 5 12 8 11 6
6 10 9 15 10 9 7
4 4 6 7 9
4 6 8 5 7```

### 输出

```
5```

# 题解

## 作者：Ryo_Yamada (赞：5)

花了两天终于搞懂了这道题 qwq，来一发题解

> 给定 $n$ 个互不相交的多边形，问最大深度。深度的定义为：若多边形 $i$ 包含多边形 $j$ 则 $dep_i = \max\{dep_j\} + 1$。

扫描线，动态维护区间。从左向右枚举交 $x$ 轴、平行于 $y$ 轴的扫描线，维护每一个多边形在这条扫描线上包含的最大 $y$ 区间。

在任意时间这段区间都是连续的，所以只需维护两个端点即可。

将所有点按照 $x$ 为第一关键字，$y$ 为第二关键字升序排序，从小到大枚举每个点。

若当前枚举到 $a$ 点，多边形 $X$；在这些区间端点中找一个 $b$，满足 $y_b > y_a$，$b$ 最小。若 $b$ 所在多边形为 $Y$，则有两种情况：

- 若 $b$ 被当前区间包含则 $dep_X = dep_Y + 1$。

- 否则，$dep_X = dep_Y$。

如何判断包含关系？一个多边形的边 $(x,\,y)$，标记逆时针的终点 $y$。若 $b$ 有标记则 $b$ 不被包含，否则被包含。~~读者自证不难~~ 实际上分类讨论一下就可以了。

最后，如何维护每个多边形包含的区间？由于排序后的性质（$x$ 第一关键字升序，$y$ 第二关键字升序），多边形每条边的起点就加入到区间，终点不加入。

$\text{Code}$：

```cpp
#include <bits/stdc++.h>
#define se second
#define It iterator

using namespace std;

const int N = 4e4 + 5;
const int K = 2e5 + 5;

struct O_WYS {
	int id, x, y, f;
	O_WYS() {}
	O_WYS(int i, int _x, int _y, int fl) : id(i), x(_x), y(_y), f(fl) {}
	bool operator < (const O_WYS &oth) const {
		return x == oth.x ? y < oth.y : x < oth.x;
	} 
} sq[K];

int n, cnt, d[N], in[3], vis[N];
map<int, int> mp;

int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		int k, tmp;
		scanf("%d%d", &k, in);
		tmp = in[0];
		for(int j = 1; j < k; j++) {
			scanf("%d", in + (j & 1));
			sq[++cnt] = O_WYS(i, in[0], in[1], (j & 1));
		}
		sq[++cnt] = O_WYS(i, tmp, in[1], (k & 1));
	}
	sort(sq + 1, sq + cnt + 1);
	for(int i = 1; i <= cnt; i++) {
		int y = sq[i].y, id = sq[i].id;
		map<int, int> :: It it = mp.find(y);
		if(it != mp.end()) mp.erase(it);
		else {
			mp[y] = i;
			if(!vis[id]) {
				it = mp.upper_bound(y);
				if(it != mp.end()) {
					if(sq[it -> se].f) vis[id] = vis[sq[it -> se].id];
					else vis[id] = vis[sq[it -> se].id] + 1;
				}
				else vis[id] = 1;
			}
		}
	}
	int ans = 0;
	for(int i = 1; i <= n; i++) ans = max(ans, vis[i]);
	cout << ans << endl;
	return 0;
}
```


---

## 作者：ppp204 (赞：3)

蒟蒻今天才刚补完这道题，想顺便写一发题解

> 做法: 扫描线+线段树维护

这道题,干想挺难想，所以我们可以换个思路去理解这道题,而不是死板的想**怎么包围**

可以将**每条竖直的线**进行维护，用扫描线的做法。

接着存下每条竖直的线，sort排序相应的x值

最后用线段树维护，这条边是右边的边还是左边的边，如果是右边的边那接下来的线层数相当于这条线左边的层数-1,否则就为这条边左边的层数+1



#### Code:
```
#include<bits/stdc++.h>
using namespace std;
const int M=200000+5;
struct node{
	int x,y1,y2,flag;
	bool operator < (const node &_) const{
		return x<_.x;
	}
}A[M];

int B[M],C[M];
/************Segment_Tree************/
struct Seg_Tree{
	int l,r,sum,lazy;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define lazy(x) tree[x].lazy
}tree[M<<2];

void Down(int p){
	if(!lazy(p)) return;
	sum(p<<1)+=lazy(p); lazy(p<<1)+=lazy(p);
	sum(p<<1|1)+=lazy(p); lazy(p<<1|1)+=lazy(p);
	lazy(p)=0;
	return;
}

void Up(int p){
	sum(p)=min(sum(p<<1),sum(p<<1|1));
}

void build(int p, int l, int r){
	l(p)=l, r(p)=r, sum(p)=lazy(p)=0;
	if(l==r) return;
	int mid=l+r>>1;
	build(p<<1,l,mid); build(p<<1|1,mid+1,r);
	return;
}

void Upd(int p, int l, int r, int x){
	if(l(p)==l && r(p)==r){
		sum(p)+=x; lazy(p)+=x;
		return;
	}
	Down(p);
	int mid=l(p)+r(p)>>1;
	if(r<=mid) Upd(p<<1,l,r,x);
	else if(l>mid) Upd(p<<1|1,l,r,x);
	else Upd(p<<1,l,mid,x), Upd(p<<1|1,mid+1,r,x);
	Up(p);
}

int Que(int p, int l, int r){
	if(l(p)==l && r(p)==r){
		return sum(p);
	}
	Down(p);
	int mid=l(p)+r(p)>>1;
	if(r<=mid) return Que(p<<1,l,r);
	else if(l>mid) return Que(p<<1|1,l,r);
	else return min(Que(p<<1,l,mid),Que(p<<1|1,mid+1,r));
}
/************Main************/
int main(){
	int n,cnt=0,tot=0;
	scanf("%d",&n);
	for(int i=1,x; i<=n; i++){
		scanf("%d",&x);
		for(int j=1; j<=x; j++) scanf("%d",&C[j]);
     	//存入每条竖直的线
		for(int j=3; j<x; j+=2) A[++tot]=(node)<%C[j],C[j-1],C[j+1],C[j-1]<C[j+1]?-1:1%>,B[++cnt]=C[j-1],B[++cnt]=C[j+1];
		A[++tot]=(node)<%C[1],C[2],C[x],C[2]<C[x]?1:-1%>,B[++cnt]=C[2],B[++cnt]=C[x];
	}
	sort(B+1,B+cnt+1); cnt=unique(B+1,B+cnt+1)-B-1;
	sort(A+1,A+tot+1); build(1,1,tot);
	int ans=0;
	for(int i=1; i<=tot; i++){
		int a=lower_bound(B+1,B+cnt+1,A[i].y1)-B,b=lower_bound(B+1,B+cnt+1,A[i].y2)-B;//对每条线的y值进行离散化,方便放入树中
		int l=min(a,b),r=max(a,b);
		Upd(1,l,r,A[i].flag);
		ans=max(ans,Que(1,l,r));
	}
	printf("%d\n",ans);
	return 0;
}
```

蒟蒻也是第一次写博客，欢迎大佬们来喷

---

## 作者：Purslane (赞：1)

# Solution

由于多边形之间没有相交关系，因此只要多边形 $P$ 的一个点在 $Q$ 的内部，则 $P$ 就被 $Q$ 包含。

考虑直接包含关系只有 $O(n)$ 对，我们把他们全找出来即可。

具体的，按照竖直边进行扫描线，如图

![](https://s21.ax1x.com/2024/11/08/pAyjXCV.md.png)

每条边有加入和删除两种情况。但是我们并不能直接得出。

考虑用线段树维护纵轴上的颜色连续段。加入一条线段时，我们先计算其覆盖的颜色：如果和当前矩形相同，那么这条线段是删，加上这个矩形外部紧包含矩形的颜色；如果不相同，可以计算出紧包含矩形的颜色，这条线段是加。这个线段树只需要实现区间赋值单点查询即可，相当简单。

复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=400000+10;
struct SEG {int d,u,id;};
int n,lst[MAXN],dp[MAXN],x[MAXN],tot,lsh[MAXN];
map<int,vector<SEG>> mp;
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
int col[MAXN<<2],tag[MAXN<<2];
void push_down(int k,int l,int r) {
	if(tag[k]!=-1) return tag[lson]=tag[rson]=col[lson]=col[rson]=tag[k],tag[k]=-1,void();	
}
void update(int k,int l,int r,int x,int y,int c) {
	if(x<=l&&r<=y) return col[k]=tag[k]=c,void();
	push_down(k,l,r);
	if(x<=mid) update(lson,l,mid,x,y,c);
	if(y>mid) update(rson,mid+1,r,x,y,c);
	return ;	
}
int query(int k,int l,int r,int pos) {
	if(l==r) return col[k];
	push_down(k,l,r);
	if(pos<=mid) return query(lson,l,mid,pos);
	return query(rson,mid+1,r,pos);	
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,1,n) {
		int c;
		cin>>c;
		ffor(j,1,c) cin>>x[j];
		ffor(j,1,c) if(j%2==1) {
			int l=j-1,r=j+1;
			if(!l) l=c;
			int u=x[l],d=x[r];
			if(u<d) swap(u,d);
			mp[x[j]].push_back({d,u-1,i}),lsh[++tot]=d,lsh[++tot]=u-1;	
		}
	}
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	for(auto ps:mp) {
		auto vc=ps.second;
		for(auto pr:vc) {
			int u=pr.u,d=pr.d,id=pr.id;
			u=lower_bound(lsh+1,lsh+tot+1,u)-lsh,d=lower_bound(lsh+1,lsh+tot+1,d)-lsh;
			int c=query(1,1,tot,u);
			if(c!=id) lst[id]=c,dp[id]=dp[c]+1,update(1,1,tot,d,u,id);
			else update(1,1,tot,d,u,lst[id]);
		}
	}
	cout<<*max_element(dp+1,dp+n+1);
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

## 1. Description

给定 $n$ 个互不相交的多边形，多边形的边平行于 $x$ 轴或 $y$ 轴，询问每个多边形被多少个多边形包含。

## 2. Solution

一道比较经典的题了，看到这种边与坐标轴平行的多边形问题，我们一般考虑扫描线来解决。

首先我们要把一个多边形所有会被扫描线扫到的边给求出来，横边或者竖边均可，我比较习惯用竖边（注意这里的点是逆时针给出，求竖边需要翻转整个数组），这里假定已经把所有点都存下来了。

第一步，找到所有点中 $x$ 坐标和 $y$ 坐标均最小的点，然后以这个点作为第一个点，平移整个数组，那么竖边就是第 $2k+1$ 个点和第 $2k+2$ 个点构成的边了。接着我们需要解决这条边是加入还是删除的，显然，如果这条边是向上的，也就是第 $2k+1$ 个点的 $y$ 坐标小于第 $2k+2$ 个点的 $y$ 坐标，那么这条边就是加入的，否则，这条边就是删除的，不理解的可以自己从右下角开始画一个多边形看看。

然后就是扫描线了，当一个多边形的第一条边加入的时候记录这个多边形的答案，当然重复记录也是可以的。

如何记录？由于多边形互不相交，所以多边形之间只有相交或者相离两种情况，因而包含一个多边形的多边形数量就是这条边的覆盖次数的最大值。

不过需要注意一点，这里应该在同一个 $x$ 坐标的线都查询完了之后再修改（不过因为多边形不交所以也不会出锅了）。

## 3. Code

```c++
/*by qwer6*/
/*略去缺省源与快读快写*/
const int N=4e4+5,M=2e5+5,K=10005;
int n,ans,m,totx,toty;
int x[K],dep[N],tmpy[M],tmpx[M],L[N],R[N];
pii point[K],shape[M];
struct Query{
	int l,r,idx,tp;
};
vector<Query>b[N];
struct Segment_tree{
	int mx[M<<2],tag[M<<2];
	#define ls p<<1
	#define rs p<<1|1
	#define mid (l+r>>1)
	void pushup(int p){
		mx[p]=max(mx[ls],mx[rs]);
	}
	void Tag(int p,int v){
		mx[p]+=v;
		tag[p]+=v;
	}
	void pushdown(int p){
		Tag(ls,tag[p]);
		Tag(rs,tag[p]);
		tag[p]=0;
	}
	void change(int p,int l,int r,int L,int R,int v){
		if(L<=l&&r<=R)return Tag(p,v);
		pushdown(p);
		if(mid>=L)change(ls,l,mid,L,R,v);
		if(mid<R)change(rs,mid+1,r,L,R,v);
		pushup(p);
	}
	int query(int p,int l,int r,int L,int R){
		if(L<=l&&r<=R)return mx[p];
		pushdown(p);
		if(mid>=L&&mid<R)return max(query(ls,l,mid,L,R),query(rs,mid+1,r,L,R));
		if(mid>=L)return query(ls,l,mid,L,R);
		return query(rs,mid+1,r,L,R);
	}
	#undef ls
	#undef rs
	#undef mid
}Set;
void init(int k,int idx){
	reverse(point+1,point+k+1);
	int mix=0x3f3f3f3f,miy=0x3f3f3f3f,p=0;
	for(int i=1;i<=k;i++){
		if(mix>point[i].first){
			mix=point[i].first;
			miy=point[i].second;
			p=i;
		}else if(mix==point[i].first&&miy>point[i].second){
			miy=point[i].second;
			p=i;
		}
	}
	L[idx]=R[idx-1]+1;
	int r=R[idx-1];
	for(int i=p;i<=k;i++)shape[++r]=point[i];
	for(int i=1;i<p;i++)shape[++r]=point[i];
	R[idx]=r;
}	
signed main(){
	read(n);
	for(int i=1,k;i<=n;i++){
		read(k);
		for(int j=1;j<=k;j++){
			read(x[j]);
			if(j&1){
				point[j-1]={x[j],x[j-1]};
				tmpx[++totx]=x[j];
			}else{
				point[j-1]={x[j-1],x[j]};
				tmpy[++toty]=x[j];
			}
		}
		point[k]={x[1],x[k]};
		init(k,i);
	}
	sort(tmpx+1,tmpx+totx+1);
	totx=unique(tmpx+1,tmpx+totx+1)-tmpx-1;
	sort(tmpy+1,tmpy+toty+1);
	toty=unique(tmpy+1,tmpy+toty+1)-tmpy-1;
	for(int i=1,x,l,r;i<=n;i++){
		for(int j=L[i];j<=R[i];j+=2){
			x=lower_bound(tmpx+1,tmpx+totx+1,shape[j].first)-tmpx;
			l=lower_bound(tmpy+1,tmpy+toty+1,shape[j].second)-tmpy;
			r=lower_bound(tmpy+1,tmpy+toty+1,shape[j+1].second)-tmpy;
			if(l>r)b[x].push_back({r,l,i,-1});
			else b[x].push_back({l,r,i,1});
		}
	}
	for(int i=1;i<=totx;i++){
		for(Query tmp:b[i]){
			if(dep[tmp.idx])continue;
			dep[tmp.idx]=Set.query(1,1,toty,tmp.l,tmp.r)+1;
			tomax(ans,dep[tmp.idx]);
		}
		for(Query tmp:b[i])
			Set.change(1,1,toty,tmp.l,tmp.r,tmp.tp);
	}
	write(ans);
}
```

---

## 作者：Crazyouth (赞：0)

## 分析

沿用扫描线思想。假设我们已经知道哪些边是入边，哪些是出边（即扫到哪些边代表进入多边形内部，哪些是出多边形的，这里的边只平行于 $y$ 轴的边），那么给入边所在 $y$ 坐标范围加一，给出边的 $y$ 轴减一，每次修改完查询一次全局最大值即可。因为多边形最多的嵌套次数等于你最多能进入多边形几次。

那么如何求出哪些是入边哪些是出边？题目按照逆时针给出顶点，第一条边一定是入边，由此所有给出顶点与它方向相同的边都是入边，所有不同的都是出边。也就是编号小的顶点在大的的上面就是入边，否则是出边。

需要离散化。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define y1 yyyyyyyyyyyyyyyyy11111111111111
#define y2 yyyyyyyyyyyyyyyyy22222222222222
int n;
struct line
{
	int x,y1,y2,o;
	bool operator<(const line &b)const
	{
		if(x!=b.x) return x<b.x;
		return min(y1,y2)<min(b.y1,b.y2);
	}
}ln[200010];
int t[800010];
set<int> st;
map<int,int> mp;
int cnt=0,lcnt=0;
int lz[800010];
void upd(int l,int r,int c,int u=1,int v=cnt,int p=1)
{
	if(l<=u&&v<=r)
	{
		t[p]+=c;
		lz[p]+=c;
		return;
	}
	int m=u+v>>1;
	if(lz[p])
	{
		lz[p<<1]+=lz[p];
		lz[p<<1|1]+=lz[p];
		t[p<<1]+=lz[p];
		t[p<<1|1]+=lz[p];
		lz[p]=0;
	}
	if(l<=m) upd(l,r,c,u,m,p<<1);
	if(r>m) upd(l,r,c,m+1,v,p<<1|1);
	t[p]=max(t[p<<1],t[p<<1|1]);
}
struct polygon
{
	int k;
	vector<int> a;
	vector<line> l;
	void build()
	{
		l.push_back({a[0],a[k-1],a[1],0});
		for(int i=2;i<k;i+=2) l.push_back({a[i],a[i-1],a[i+1],0});
		for(int i=0;i<l.size();i++)
		{
			st.insert(l[i].y1),st.insert(l[i].y2);
			if(l[i].y1>l[i].y2) swap(l[i].y1,l[i].y2),l[i].o=1;
			else l[i].o=-1;
		}
	}
	void check()
	{
		for(int i=0;i<l.size();i++)
		{
			l[i].y1=mp[l[i].y1];
			l[i].y2=mp[l[i].y2];
			ln[++lcnt]=l[i];
		}
	}
}p[40010];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].k;
		for(int j=1;j<=p[i].k;j++)
		{
			int a;
			cin>>a;
			p[i].a.push_back(a);
		}
		p[i].build();
	}
	for(auto i:st) mp[i]=++cnt;
	int ans=0;
    for(int i=1;i<=n;i++) p[i].check();
    sort(ln+1,ln+lcnt+1);
	for(int i=1;i<=lcnt;i++)
	{
		if(ln[i].o==-1)
		{
			upd(ln[i].y1,ln[i].y2,-1);
			ans=max(ans,t[1]);
		}
		else
		{
			upd(ln[i].y1,ln[i].y2,1);
			ans=max(ans,t[1]);
		}
	}
	cout<<ans;
}

---

## 作者：happybob (赞：0)

多边形互不相交，求深度，很显然地预示着扫描线。

每个多边形可以拆成若干个矩形，显然只对矩形做答案不会发生变化，于是考虑所有多边形都是矩形的情况。

对于每个矩形求出其右边距离最近的矩形，则这个矩形的父亲要么是那个矩形，要么这个矩形和那个矩形是兄弟关系，具体地这是取决于这两个矩形的包含关系。扫描线的时候维护区间覆盖即可。

---

## 作者：cosf (赞：0)

来一个码量比较大的做法。

首先注意到两个多边形若有包含关系，则其面积一定有大小关系，所以我们可以按照多边形面积排个序。

我们可以用树套树维护每一个点被包含的层数，当处理一个多边形时，我们随便选多边形中的一个点数它的层数即可，然后给多边形的每个点都加上 $1$。这样就是 $O((\sum k) \log^2 (\sum k))$ 的了。

跑得也比较快，就是有点难写。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

#define MAXN 40005
#define MAXM 200005

using ll = long long;

int n;

struct Point
{
    ll x, y;
    ll operator*(Point b)
    {
        return x * b.y - b.x * y;
    }
};

vector<Point> e[MAXN];
int k[MAXN];
ll sz[MAXN];

int p[MAXN], dep[MAXN];

int b[MAXM], idx = 0;

struct SGT
{
    struct Tree
    {
        int t;
        int ls, rs;
    } t[MAXM << 5];
    int idx = 0, rt[MAXM << 2];

    void add(int &p, int l, int r, int ql, int qr, int v)
    {
        if (!p)
        {
            p = ++idx;
        }
        if (ql <= l && r <= qr)
        {
            t[p].t += v;
            return;
        }
        int mid = (l + r) >> 1;
        if (mid >= ql)
        {
            add(t[p].ls, l, mid, ql, qr, v);
        }
        if (mid < qr)
        {
            add(t[p].rs, mid + 1, r, ql, qr, v);
        }
    }

    int query(int p, int l, int r, int q)
    {
        if (!p || l == r)
        {
            return t[p].t;
        }
        int mid = (l + r) >> 1;
        if (mid >= q)
        {
            return t[p].t + query(t[p].ls, l, mid, q);
        }
        else
        {
            return t[p].t + query(t[p].rs, mid + 1, r, q);
        }
    }

#define ls (p << 1)
#define rs (p << 1 | 1)

    void add(int p, int l, int r, int ql, int qr, int al, int ar, int v)
    {
        if (ql <= l && r <= qr)
        {
            return add(rt[p], 1, ::idx, al, ar, v);
        }
        int mid = (l + r) >> 1;
        if (mid >= ql)
        {
            add(ls, l, mid, ql, qr, al, ar, v);
        }
        if (mid < qr)
        {
            add(rs, mid + 1, r, ql, qr, al, ar, v);
        }
    }

    int query(int p, int l, int r, int q, int a)
    {
        if (l == r)
        {
            return query(rt[p], 1, ::idx, a);
        }
        int res = query(rt[p], 1, ::idx, a), mid = (l + r) >> 1;
        if (mid >= q)
        {
            return res + query(ls, l, mid, q, a);
        }
        else
        {
            return res + query(rs, mid + 1, r, q, a);
        }
    }
} t;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> k[i];
        vector<ll> tmp(k[i]);
        for (int j = 0; j < k[i]; j++)
        {
            cin >> tmp[j];
            b[++idx] = tmp[j];
        }
        for (int j = 0; j < k[i]; j++)
        {
            if (j % 2)
            {
                e[i].push_back({tmp[(j + 1) % k[i]], tmp[j]});
            }
            else
            {
                e[i].push_back({tmp[j], tmp[j + 1]});
            }
        }
        p[i] = i;
    }
    sort(b + 1, b + idx + 1);
    idx = unique(b + 1, b + idx + 1) - b - 1;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < k[i]; j++)
        {
            e[i][j].x = lower_bound(b + 1, b + idx + 1, e[i][j].x) - b;
            e[i][j].y = lower_bound(b + 1, b + idx + 1, e[i][j].y) - b;
        }
        for (int j = 0; j < k[i]; j++)
        {
            sz[i] += e[i][j] * e[i][(j + 1) % k[i]];
        }
    }
    sort(p + 1, p + n + 1, [](int a, int b)
         { return sz[a] > sz[b]; });
    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        dep[i] = t.query(1, 1, idx, e[i][0].x, e[i][0].y) + 1;
        res = max(res, dep[i]);
        for (int j = 0; j < k[i]; j++)
        {
            Point l = e[i][j], r = e[i][(j + 1) % k[i]];
            if (l.x > r.x) // add
            {
                t.add(1, 1, idx, r.x, l.x, 1, l.y, 1);
            }
            else if (l.x < r.x)
            {
                t.add(1, 1, idx, l.x, r.x, 1, l.y, -1);
            }
        }
    }
    cout << res << endl;
    return 0;
}

```

---


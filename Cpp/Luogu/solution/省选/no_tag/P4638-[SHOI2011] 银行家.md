# [SHOI2011] 银行家

## 题目描述

你在一家银行工作，任务是帮助客户取出他们存放在保险箱里的金币。

银行里有 $m$ 个保险箱，你没有办法打开这些保险箱，因为钥匙都在客户的手里。一个客户可能有很多个保险箱的钥匙，一个保险箱的钥匙也可能被多个客户拥有。今天早上，经理已经告知，你需要按照顺序接待 $n$ 个客户（任何客户都不会同时到场），你也知道，第 $i$ 个客户会要求取走 $c_i$​​ 枚金币。每个客户来到银行的时候，会打开所有他能打开的保险箱，然后从中取走 $c_i$​​ 枚金币（任何金币都没有区别），如果这些保险箱里的金币数量不足 ，他会感到不高兴，在取走尽量多的金币之后，到你的经理那里去投诉你们银行的服务质量太差了。

你当然不希望“上帝”的投诉让你丢了工作，于是想到了个补救的办法：虽然每个客户走的时候都会把保险箱重新关上，但是你可以在他取金币的时候，偷偷地调整被打开的保险箱里的金币数量，譬如说把 $1$ 号保险里多余的 $5$ 枚放到 $2$ 号里，这样说不定下个客户来的时候，就能取到更多的金币了。

尽管有这样的方法，还是可能没法完成所有客户的要求。然而，你希望，尽量帮助客户取走更多的金币，这样才能消除他们的怒气，保住这份来之不易的工作和薪水。 

## 说明/提示

### 数据范围

测试点编号 .|n$\le$ .|m$\le$ .
-|-|-
1|30|100
2|40|50
3|100|400
4|100|400
5|100|400
6|200|500
7|300|500
8|400|1500
9|500|2000
10|600|2500

## 样例 #1

### 输入

```
3 3
3 1 10
2 1 2 2
2 1 3 3
1 2 6```

### 输出

```
7```

## 样例 #2

### 输入

```
2 3
2 3
2 1 2 1
1 2 2
1 2 2```

### 输出

```
5```

## 样例 #3

### 输入

```
6 6
6 3 2 0 1 3
2 1 2 0
1 3 3
1 1 1
2 2 3 8
2 4 5 2
2 4 6 6```

### 输出

```
15```

# 题解

## 作者：RuSun (赞：20)

## 广告

[我的博客](https://rusun.blog.luogu.org/)

## 双倍经验

[SP4063 MPIGS - Sell Pigs](https://www.luogu.com.cn/problem/SP4063)

没有 SPOJ 的账号的同学， 不建议食用。

这个题数据范围要大一些， 所以直接交过去就可以过了。

## 前置知识

[P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)

这里附赠一个模板。

食用方法： 对于每道题， 先将模板复制下来， 然后调整点数 N 的大小和边数 M 的大小， 建图即可。 注意 st 虚拟源点默认为最小的点， ed 虚拟汇点默认为最大的点， 注意将 hd 数组赋初始值 -1。

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <climits>
#define inf INT_MAX
using namespace std;
const int N = + 10, M = + 10;
int n, st, ed, d[N], cur[N];
int idx = -1, hd[N], nxt[M], edg[M], wt[M];
bool bfs()
{
    for (int i = st; i <= ed; i++)
        d[i] = -1;
    d[st] = 0;
    cur[st] = hd[st];
    queue <int> q;
    q.push(st);
    while (!q.empty())
    {
        int t = q.front();
        q.pop();
        for (int i = hd[t]; ~i; i = nxt[i])
            if (d[edg[i]] == -1 && wt[i])
            {
                cur[edg[i]] = hd[edg[i]];
                d[edg[i]] = d[t] + 1;
                if (edg[i] == ed)
                    return true;
                q.push(edg[i]);
            }
    }
    return false;
}
int exploit(int x, int limit)
{
    if (x == ed)
        return limit;
    int res = 0;
    for (int i = cur[x]; ~i && res < limit; i = nxt[i])
    {
        cur[x] = i;
        if (d[edg[i]] == d[x] + 1 && wt[i])
        {
            int t = exploit(edg[i], min(wt[i], limit - res));
            if (!t)
                d[edg[i]] = -1;
            wt[i] -= t;
            wt[i ^ 1] += t;
            res += t;
        }
    }
    return res;
}
int dinic()
{
    int res = 0, flow;
    while (bfs())
        while (flow = exploit(st, inf))
            res += flow;
    return res;
}
void add (int a, int b, int c)
{
    nxt[++idx] = hd[a];
    hd[a] = idx;
    edg[idx] = b;
    wt[idx] = c;
}
int main ()
{

    return 0;
}
```

## 正文

题目中， 金币从保险柜里面流出， 到达每个人都手中， 求可以取出的最大值。 这不禁让我们联想到了网络最大流， 保险柜正是虚拟源点， 可以流出流量， 而金币正是流量。 这道题目特殊的一点是每一个人取出金币之后， 可以随意调整打开的保险柜的数量。 那么可能因为这次调整多出来的流量是因为两人用了同一个保险柜， 即可能存在的金币的流向如下：

```
客户 1 打开了保险柜 1， 2

保险柜 1 -> 客户 1

保险柜 2 -> 客户 1

此时， 保险柜 1 和 2 以及客户 1 之间可以随便乱搞

保险柜 1 -> 保险柜 2 （被 “ 你 ” 拿走）

客户 2 打开了保险柜 2

此时， 保险柜 2 和客户 2 之间可以随便乱搞

保险柜 2 -> 客户 2

```
不难发现， 保险柜 1 和 2 与客户 1 和 2 之间金币可以按顺序随意流动， 所以上述过程可以等价于

```
客户 1 打开了保险柜 1， 2

客户 1 十分贪婪， 卷走所有的保险柜 1 和 2 的金币

客户 2 一来， 看见自己的保险柜 2 被卷走了， 十分生气， 把客户 1 打了一顿， 拿走了他想要的金币
```

于是我们可以这样建图：

- 建立虚拟源点和汇点；


- 对于每一个人能开的保险柜， 如果它没有被打开过， 则从虚拟源点到当前的人连一条流量为保险柜金币数量的边， 表示这个人可以从这个保险柜中卷走所有的金币；

- 对于每一个人能开的保险柜， 如果它已经被打开过了， 则从上一次可以开这个保险柜的人到当前的人连一条流量为无限大的边， 表示当前的人可以无限从上一个人索取金币；

- 对于每个人， 向汇点连一条流量为其想要的金币的数量。

可以发现， 对于一个保险柜， 所有可以打开它的人构成了一条链， 可以按顺序随意传播金币。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <climits>
#define INF INT_MAX
using namespace std;
const int N = 610, M = 4e6 + 10;
int m, n, st, ed, k[2510], d[N], cur[N], last[2510];
int idx = -1, hd[N], nxt[M], edg[M], wt[M];
bool bfs ()
{
	for (int i = st; i <= ed; i++)
		d[i] = -1;
	d[st] = 0;
	cur[st] = hd[st];
	queue <int> q;
	q.push(st);
	while (!q.empty())
	{
		int t = q.front();
		q.pop();
		for (int i = hd[t]; ~i; i = nxt[i])
			if (d[edg[i]] == -1 && wt[i])
			{
				d[edg[i]] = d[t] + 1;
				cur[edg[i]] = hd[edg[i]];
				if (edg[i] == ed)
					return true;
				q.push(edg[i]);
			}
	}
	return false;
}
int find (int x, int limit)
{
	if (x == ed)
		return limit;
	int res = 0;
	for (int i = cur[x]; ~i && res < limit; i = nxt[i])
	{
		cur[x] = i;
		if (d[edg[i]] == d[x] + 1 && wt[i])
		{
			int t = find(edg[i], min(wt[i], limit - res));
			if (!t)
				d[edg[i]] = -1;
			wt[i] -= t;
			wt[i ^ 1] += t;
			res += t;
		}
	}
	return res;
}
int dinic ()
{
	int res = 0, flow;
	while (bfs())
		while (flow = find(st, INF))
			res += flow;
	return res;
}
void add (int x, int y, int z)
{
	nxt[++idx] = hd[x];
	hd[x] = idx;
	edg[idx] = y;
	wt[idx] = z;
}
int main ()
{
	cin >> m >> n;
	st = 0;
	ed = n + 1;
	for (int i = st; i <= ed; i++)
		hd[i] = -1;
	for (int i = 1; i <= m; i++)
		cin >> k[i];
	for (int i = 1, a, b, id; i <= n; i++)
	{
		cin >> a;
		while (a--)
		{
			cin >> id;
			if (!last[id])
			{
				add(st, i, k[id]);
				add(i, st, 0);
			}
			else
			{
				add(last[id], i, INF);
				add(i, last[id], 0);
			}
			last[id] = i;
		}
		cin >> b;
		add(i, ed, b);
		add(ed, i, 0);
	}
	cout << dinic();
	return 0;
}
```

## 难度评定

该题目难度还暂无评定， 建议设置其难度为 ``省选/NOI-`` 。

---

## 作者：JuRuoOIer (赞：7)

# 题解 P4638 [SHOI2011] 银行家

**注意**：这个题的 AC 代码可以不加修改地通过其[双倍经验](https://www.luogu.com.cn/problem/SP4063)，但由于那个题数据比较水，不进行优化建图的代码（直接按照 Part 2 中的方法）只能通过双倍经验而无法通过本题。

### Part 1 题意

有 $m$ 个保险箱，依次会来 $n$ 个人，每个人都会打开一些保险箱并取出最多 $c_i$ 枚金币（没有那么多则全部拿走），求所有人取走的金币之和最多是多少。

$n \le 600,m \le 2500$，答案不超过 $10^5$。

### Part 2 建图

注意到顾客来是有顺序的，我们可以为每个顾客建一层，变成一个分层图（图为样例 #1 按这种方式的建图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/13r0dkgw.png)

在图中，我们建一个超级源点和一个超级汇点，接着按下面的步骤建图：
- 首先从超级源点向第一层所有保险柜建边权为初始金币数量的边，这样就限制了初始的金币数量；
- 接着对于**每个客户建一层**，都建上**这个客户**和**所有的保险柜**，
  - 如果客户能打开某一个保险柜，则从这层相应的保险柜到客户处建**无限流量**的边，同时从客户往下一层相应的保险柜建上同样为**无限流量**的边，这样相当于实现了可以任意地取放金币；
  - 对于打不开的保险柜，如果还有下一层，就和下一层的这个保险柜建上一条**无限流量**的边，保证柜子的金币可以一点不少的到下一个开保险柜的客户手中；
  - 最后，从这个客户往汇点建一条流量为 $c_i$ 的边，限制住客户能够拿走的金币数量。
- 要用网络流，当然少不了反悔边了（图中没有体现，平时画图的时候也不会画）。

然后一波 Dinic 算法，你就成功地 TLE 了。

### Part 3 优化建图

考虑一下，为什么会 TLE 呢？

Dinic 算法的复杂度是 $\text{O}(V^2E)$ 的，我们来算一下：
- $V=(m+1)\times n + 2\approx nm$，其中 $m+1$ 是 $m$ 个保险柜和一个客户，$2$ 是超级源点和超级汇点；
- $E=2m\times n + n\approx nm$，其中 $2m\times n$ 代表如果建满的话，每一层的每个保险柜都需要往上一层的客户（或者是超级源点）和这一层的客户建边，$n$ 代表每个客户还要往超级汇点连边。
- 代入 $\text{O}(V^2E)$ 中得到复杂度是 $\text{O}(n^3m^3)$ 的。
- 看完数据范围就会发现死得很彻底。

于是这里给大家介绍两种优化方法：

![](https://cdn.luogu.com.cn/upload/image_hosting/i77e760d.png)

这里我们只用第一种方法，由于复杂度中点数是平方的，所以我们考虑省去每一层的保险柜，这样可以更省点数。此时建图的方式就变成了：
- 对于每一个客户打开的每一个保险柜，都找找有没有开过。
  - 如果开过了，就从上一个开它的客户往这个客户连无限流量的边；
  - 否则就从超级源点往这个客户连流量为初始金币数量的边。
- 然后还是从客户往汇点连 $c_i$ 的边。

当然也可以理解成：**我开哪几个柜子，我就全拿走，后面的没了再来找我要我多拿的部分。**

此时样例的建图就长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/9hutlu5n.png)

### Part 4 代码

板子部分不注释了。注意重置数组的时候要连着超级源点和超级汇点一起重置。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
	ll now,dep;
};
ll n,m,s,t,u,v,w,dep[610],aa[2510],lst[2510];
vector<ll> a[610],b[610],c[610];
const ll inf=1e9;
queue<node> q;
bool bfs(){
	while(!q.empty())q.pop();
	fill(dep,dep+n+1,inf);
	dep[s]=0;
	q.push({s,0});
	while(!q.empty()){
		node tmp=q.front();
		q.pop();
		for(int i=0;i<a[tmp.now].size();i++){
			if(b[tmp.now][i]&&dep[a[tmp.now][i]]==inf){
				dep[a[tmp.now][i]]=tmp.dep+1;
				q.push({a[tmp.now][i],tmp.dep+1});
				if(a[tmp.now][i]==t)return true;
			}
		}
	}
	return false;
}
ll dfs(ll now,ll sum){
	if(now==t||sum==0)return sum;
	ll tmp=0;
	for(int i=0;i<a[now].size()&&sum>0;i++){
		if(b[now][i]&&dep[a[now][i]]==dep[now]+1){
			ll k=dfs(a[now][i],min(sum,b[now][i]));
			if(!k)dep[a[now][i]]=inf;
			b[now][i]-=k;
			b[a[now][i]][c[now][i]]+=k;
			tmp+=k;
			sum-=k;
			if(sum==0)return tmp;
		}
	}
	return tmp;
}
ll dinic(){
	ll ans=0;
	while(bfs())ans+=dfs(s,inf);
	return ans;
}
void add(ll bg,ll ed,ll len){
	//建边 
	a[bg].push_back(ed);
	b[bg].push_back(len);
	c[bg].push_back(a[ed].size());
	//反悔边 
	a[ed].push_back(bg);
	b[ed].push_back(0);
	c[ed].push_back(a[bg].size()-1);
}
int main(){
	cin>>m>>n;
	t=n+1;s=0;
	for(int i=1;i<=m;i++){
		cin>>aa[i];
	}
	for(int i=1;i<=n;i++){
		cin>>u;
		while(u--){
			cin>>v;
			if(!lst[v]){
				//保险箱没动过，有多少就只能提多少 
				add(s,i,aa[v]);
			}
			else{
				//给上次动这个保险箱的人打个电话说下 
				add(lst[v],i,inf);
			}
			lst[v]=i;//记得更新 
		}
		cin>>w;
		add(i,t,w);//别提多了 
	}
	n++;//注意了还有超级汇点 
	cout<<dinic();//板子不讲 
	return 0;
}
```

---

## 作者：TKXZ133 (赞：6)

[银行家](https://www.luogu.com.cn/problem/P4638)

[双倍经验](https://www.luogu.com.cn/problem/SP4063)

### 题目大意

有 $n$ 个客户前来取金币，共有 $m$ 个保险箱，每个客户携带着某一些保险箱的钥匙，需要取一定数量的金币。在客户取完后，我们可以将打开的保险箱中的金币随意移动，移动完毕后所有的保险箱将关闭，直到下一个客户到来时才能打开其拥有钥匙对应的保险箱。求最多能取走出多少金币。

### 思路分析

我们注意到客户是有时间顺序的。因此，我们首先想到可以建立一张分层图，每个点 $(a,b)$ 表示在第 $a$ 个客户到来时的第 $b$ 个保险箱， 那么边的设置就很自然：

- 建立虚拟源点和汇点，源点向每个 $(1,x)$ 点连边，边权为初始的数量。
- 对于每一层再建一个点，将该层所有被打开的点向它连边，同时它向下一层对于的点连边，边权均为 $+\infty$，再将其向汇点连边，边权为 $+\infty$。

![](https://i.328888.xyz/2023/02/23/xXjzZ.md.png)

然后跑最大流就可以了。

但是，这样的空间复杂度是 $O(nm)$ 的，时间复杂度更是高达 $O(n^3m^3)$，是比较劣的，如何优化呢？

既然客户有时间顺序，那么我们不妨从客户下手，只建立 $n$ 个代表客户的点，那么如何连边呢？

- 建立虚拟源点，汇点。
- 每个点向汇点连边，边权是这个客户对金币的需求量。
- 记录每个保险箱最近一次是被谁打开的，如果是第一次打开，将从源点向这个客户连的边的边权增加这个保险箱的金币的数量。（如果没有这条边就建立这条边）
- 如果不是第一次打开，将上一次打开这个保险箱的客户向这个客户连一条边权是 $+\infty$ 的边。

![](https://i.328888.xyz/2023/02/23/xXxzc.md.png)

然后跑最大流就可以了。

空间复杂度 $O(n)$，时间复杂度 $O(n^3)$。

### 代码

```
#include <bits/stdc++.h>
using namespace std;
const int N=100100;
#define inf 0x3f3f3f3f

int to[N],nxt[N],head[N],w[N];
int idx=1,n,m,S,T,in1,in2;
int d[N],cur[N];queue <int> q;
int a[N],vis[N];//a 是保险箱中金币的数量，vis 保存上一次打开的人

void add(int u,int v,int c){
    idx++;to[idx]=v;nxt[idx]=head[u];head[u]=idx;w[idx]=c;
    idx++;to[idx]=u;nxt[idx]=head[v];head[v]=idx;w[idx]=0;
}

//dinic模板默写

bool bfs(){
    memset(d,-1,sizeof d);d[S]=0;
    while(!q.empty()) q.pop();
    cur[S]=head[S];q.push(S);
    while(!q.empty()){
        int now=q.front();q.pop();
        for(int i=head[now];i;i=nxt[i]){
            int v=to[i];
            if(~d[v]||!w[i]) continue;
            d[v]=d[now]+1;cur[v]=head[v];
            if(v==T) return 1;q.push(v);
        }
    }
    return 0;
}

int dfs(int s,int lim){
    if(s==T) return lim;
    int flow=0;
    for(int i=cur[s];i&&flow<lim;i=nxt[i]){
        int v=to[i];cur[s]=i;
        if(d[v]!=d[s]+1||!w[i]) continue;
        int t=dfs(v,min(w[i],lim-flow));
        if(!t) d[v]=-1;
        w[i]-=t;w[i^1]+=t;flow+=t;
    }
    return flow;
}

int dinic(){
    int ans=0,flow=0;
    while(bfs()) while(flow=dfs(S,inf)) ans+=flow;
    return ans;
}

//------

int main(){
    scanf("%d%d",&m,&n);
    S=0;T=N-2;//虚拟源汇点
    for(int i=1;i<=m;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++){
        scanf("%d",&in1);
        int sum1=0;
        for(int j=1;j<=in1;j++){
            scanf("%d",&in2);
            if(!vis[in2]){sum1+=a[in2];}//增加边权
            else add(vis[in2],i,inf);//上一个人向这个人连边
            vis[in2]=i;//更新这个保险箱
        }
        if(sum1) add(S,i,sum1);
        scanf("%d",&in1);
        add(i,T,in1);//向汇点连边
    }
    cout<<dinic()<<'\n';
    return 0;
}
```

---

## 作者：tomtom (赞：4)

首先想到的是网络流最大流。下面讨论如何建图：

1. 对于每一个保险柜，将它的第一个使用人（即第一个持有钥匙的人）与源点连一条容量为 $w[i]$ 的边。表示从这个人开始，可以‘任意’分配$w[i]$个金币。
2. 将每个保险柜之后的使用人与第一个使用人连一条INF的边。
3. 之后将每一个人$i$与汇点连一条容量为$c[i]$的边。

跑dinic即可。

以下是代码实现：
```lang=cpp
#include<bits/stdc++.h>
#define int long long
const int N = 1e5 + 3;
const int oo = 0x7f7f7f7f;

int edge[N << 1],nxt[N << 1],ver[N << 1],head[N],tot = 1,lst[N],first[N];
inline void add(int x,int y,int z)
{
	ver[++tot] = y,edge[tot] = z,nxt[tot] = head[x],head[x] = tot;
	ver[++tot] = x,edge[tot] = 0,nxt[tot] = head[y],head[y] = tot;
}

inline int read()
{
	int s = 0,f = 1; char ch;
	while(!isdigit(ch = getchar())) if(ch == '-') f = -1;
	while(isdigit(ch)) s = s * 10 + ch - '0',ch = getchar();
	return s * f;
}

int n,m,w[N],s,t,d[N],cur[N];
std::queue<int> q;

inline bool BFS()
{
	memset(d,0,sizeof(d));
	while(q.size()) q.pop();
	q.push(s),d[s] = 1;
	while(q.size()) {
		int x = q.front(); q.pop();
		for(int i = head[x];i;i = nxt[i]) {
			int to = ver[i],w = edge[i];
			if(w && !d[to]) {
				d[to] = d[x] + 1;
				q.push(to);
				if(to == t) return 1;
			}
		}
	}
	return 0;
}

int dfs(int x,int flow)
{
	if(x == t) return flow;
	int rest = flow,k;
	for(int i = cur[x];i && rest;i = nxt[i]) {
		cur[x] = i;
		int to = ver[i],w = edge[i];
		if(d[to] == d[x] + 1 && w) {
			k = dfs(to,std::min(w,rest));
			if(!k) d[to] = 0;
			rest -= k,edge[i] -= k,edge[i ^ 1] += k;
		}
	}
	return flow - rest;
}

int dinic()
{
	int ret = 0;
	while(BFS()) {
	    memcpy(cur,head,sizeof(cur));
	    ret += dfs(s,oo);
	}
	return ret;
}

signed main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(0),std::cout.tie(0);

	std::cin >> m >> n;
	s = 0,t = n + 1;

	for(int i = 1;i <= m;i++)
		std::cin >> w[i];
	for(int i = 1,k,own,c;i <= n;i++) {
		std::cin >> k;
		for(int j = 1;j <= k;j++) {
			std::cin >> own;
			if(!lst[own]) add(s,i,w[own]);
			else add(lst[own],i,oo);
			lst[own] = i;
		}
		std::cin >> c;
		add(i,t,c);
	}

	std::cout << dinic();
	exit(0);
}
```

---

## 作者：yezl (赞：2)

[$ \color{orange}\text{博客食用效果更佳哦} $](https://www.luogu.com.cn/blog/into-the-unknow/solution-sp4063)

$ \color{skyblue}\text{题目传送门：} $ [P4638](https://www.luogu.com.cn/problem/P4638)、[SP4063](https://www.luogu.com.cn/problem/SP4063)、[原题poj1149](http://poj.org/problem?id=1149)、[网络最大流模板](https://www.luogu.com.cn/problem/P3376)（~~三倍经验~~）

### 题目大意：
有 $ m $ 个保险箱和 $ n $ 个客户，给定保险箱的金币数量、客户可以取哪些保险箱的金币以及客户要求取走多少金币。求所有客户可以取走的金币总数的最大值。**每次客户取完后此保险箱的金币可以移到其它保险箱。**
### 解题思路：
根据做题经验，我们会想到这道题可以用**网络最大流**。对于大部分人  ~~比如我~~，一开始想到的是建立一个源点 $ s $ 和汇点 $ t $ ，由 $ s $ 建一条容量为**金币量**的边通向每个保险箱，保险箱连一条容量为 $ \infty $ 的边到客户，客户连一条容量为**金币需求量**的边到汇点 $ t $ 。每一轮交易结束后，当前保险箱连一条 $ \infty $ 边到下一轮保险箱，同时将有交易过的保险箱互相连一条 $ \infty $ 的边（因为金币此时可以互调）接下来跑一遍 $ \color{skyblue}\mathcal{Dinic} $ 求出最大流，易得这就是本题的答案了。（方框表示保险箱，圆表示客户）

![](https://z3.ax1x.com/2021/08/24/hkrigU.png)

但是，我们都知道 $ \color{skyblue}\mathcal{Dinic} $ 的时间复杂度为 $ O(n^2m) $ 。点数 $ n = 2 + N + M \times N \approx 1500000 $ 肯定过不了，那么怎么办呢？时间主要花费在 $ n $ 也就是**结点数**上，这时我们可以考虑进行**缩点**。  
具体要怎么做，可以参考以下规律。~~想一想为什么~~

> **规律 1.** 如果几个结点的流量的来源完全相同，则可以把它们合并成一个。  
**规律 2.** 如果几个结点的流量的去向完全相同，则可以把它们合并成一个。  
**规律 3.** 如果从点 u 到点 v 有一条容量为 ∞ 的边，并且点 v 除了点 u 以外没有别的流量来源，则可以把这两个结点合并成一个。

根据**规律 1**，可以把蓝色右边的 1 、 2 号结点合并；根据**规律 2**，可以把蓝色左边的 1 、 2 号结点合并；根据**规律 3**，可以把蓝色部分的左边和右边（已经分别合并成了一个结点）合并成一个结点 
于是我们的图变成了这样（图丑别介意qwq） ：

![](https://z3.ax1x.com/2021/08/24/hkV1oV.png)

接下来的步骤我也不多赘述了，总之我们可以把图转换这样（两点之间有多条同向的边，则这些边可以合并成一条，容量相加）：

![](https://z3.ax1x.com/2021/08/24/hkm1ot.png)

这下就容易找出规律了，我们可以将**每个客户作为一个结点**。对于打开每个保险箱的第一个客户，从源点向他连一条边，容量就是该保险箱里的初始金币数。如果从源点到一名客户有多条边，则可以把它们合并成一条，容量相加。同一个保险箱有多个客户打开的话，将客户按顺序用容量 $ \infty $ 的边连上，这样就优化完成啦。

新的网络模型中最多只有 $ \text{ 2 + N = 6002 } $ 个结点，计算速度可以说是相当快了，具体实现看代码。

 $ \mathcal{\Large My\;Code:} $ 
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6005,M=1e6+5,Inf=1e8;
int n,m,s,t,ans,pig[N],num[N],d[N],cur[N],maxflow;
int head[N],Next[M],ver[M],edge[M],tot=1;
vector<int> p[N];//用不定长数组存客户有的保险箱钥匙
inline void add(int x,int y,int z)//链式前向星(邻接表)存图 
{//inline可以使多次调用略省点时间 
	ver[++tot]=y,edge[tot]=z;
	Next[tot]=head[x],head[x]=tot;
}
inline bool bfs()
{
	memset(d,0,sizeof(d));
	queue<int> q;//q数组每次重新定义，就不用一一pop了 
	d[s]=1,q.push(s);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i];
			if(edge[i]==0 || d[y]!=0)
				continue;//容量不为 0且没被访问过 
			d[y]=d[x]+1;
			q.push(y);
		}
	}
	if(d[t]==0) return false;
	return true;
}
int dfs(int x,int incf)
{
	if(x==t)
		return incf;
	for(int &i=cur[x];i;i=Next[i])
	{
		int y=ver[i],z=edge[i];
		if(z==0 || d[y]!=d[x]+1)
			continue;
		int dist=dfs(y,min(incf,z));
		if(dist>0)
		{
			edge[i]-=dist;
			edge[i^1]+=dist;
			return dist;
		}
	}
	return 0;
}
int main()
{
	scanf("%d %d",&m,&n);
	s=n+1,t=s+1;
	for(int i=1;i<=m;i++)
		scanf("%d",&pig[i]);
	for(int i=1,x,y;i<=n;i++)
	{
		scanf("%d",&x);
		for(int j=1;j<=x;j++)
		{
			scanf("%d",&y);
			p[y].push_back(i);//用不定长数组存顾客有的猪圈钥匙 
		}
		scanf("%d",&x);//这个是顾客的需求量 
		add(i,t,x),add(t,i,0);//顾客点到汇点建边 
	}
	for(int i=1;i<=m;i++)
	{
		int l=p[i].size();
		for(int j=0;j<l;j++)
		{
			if(j==0)//买第i个猪圈的第一个用户 
			{
				num[p[i][j]]+=pig[i];//容量累加 
				continue;
			}
			add(p[i][j-1],p[i][j],Inf);//开同一个保险箱的客户连边 
			add(p[i][j],p[i][j-1],0);
		}
	}
	for(int i=1;i<=n;i++)
		if(num[i]!=0)//以累加好的结果为容量给开某个保险箱的第一个顾客建边 
			add(s,i,num[i]),add(i,s,0);
	while(bfs())//Dinic求解 
	{
		for(int i=1;i<=t;i++)
			cur[i]=head[i];
		while(int di=dfs(s,Inf))
			maxflow+=di;
	}
	printf("%d",maxflow);//答案即最大流 
	return 0;
}
```
 
感谢观看，希望可以帮到大家。

 $ \color{gray}\scriptsize\text{2021.8.26 把能加空格的都加上了……} $ 

---

## 作者：WilliamFranklin (赞：1)

[双倍经验](https://www.luogu.com.cn/problem/SP4063)

### 主要思路

这道题思路有复杂版与简单版，总之，这里提供更为简单的版本。

首先我们可以将题目转化一下：客户 $i$ 将自己能打开的保险柜打开后，会将里面的金币全都拿走，然后花掉自己所需要的，将剩下的金币都放在自己家里的保险柜中。当客户 $j(i + 1 \le j \le n)$ 发现自己能打开的保险柜中有的柜子里面的金币被客户 $i$ 一网打尽后，便来到客户 $i$ 家索要自己所需的金币。

由此，我们可以用网络流来解决。

建图：建立一个虚拟源点 $S$ 和虚拟汇点 $T$，并将客户 $i$ 转化为 $i$ 点。首先先将 $i(1 \le i \le n)$ 点与 $T$ 之间连一条从 $i$ 点到 $T$ 容量为 $c_i$ 的有向边，对客户 $i$ 实际花掉的金币数作限制。然后，当客户 $j$ 发现自己能打开的第 $k$ 个保险柜中的金币已被客户 $i$ 拿走时，就将客户 $i$ 与客户 $j$ 之间连一条从 $i$ 点到 $j$ 点容量为 $+\infty$ 的有向边；否则，就将 $S$ 与 $j$ 点之间连一条从 $S$ 到 $j$ 点容量为 $a_k$ 的有向边。

最后，跑一边最大流即可。

也许有一些地方说的不清楚，看下代码吧。

### AC Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <sstream>
#include <algorithm>
#include <cmath>
#include <string>
#include <queue>

using namespace std;

const int N = 605, M = 3002405;

int h[N], e[M], ne[M], f[M], idx;
int m, n, S, T;
int d[N], cur[N];
bool vis[N];
int K[2505];
int c[2505];
int st[2505];
bool G[N][N];

void add(int a, int b, int c) {
    e[idx] = b, ne[idx] = h[a], f[idx] = c, h[a] = idx++;
    e[idx] = a, ne[idx] = h[b], f[idx] = 0, h[b] = idx++;
}

bool bfs() {
    queue<int> q;
    
    memset(vis, 0, sizeof(vis));
    memset(d, -1, sizeof(d));
    
    q.push(S);
    d[S] = 0;
    vis[S] = 1;
    cur[S] = h[S];
    
    while (q.size()) {
        int t = q.front();
        
        q.pop();
        
        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i];
            
            if (!vis[j] && f[i]) {
                d[j] = d[t] + 1;
                vis[j] = 1;
                cur[j] = h[j];
                
                if (j == T) return 1;
                
                q.push(j);
            }
        }
    }
    
    return 0;
}

int dfs(int u, int limit) {
    if (u == T) return limit;
    
    int flow = 0;
    for (int i = cur[u]; (~i) && flow < limit; i = ne[i]) {
        int j = e[i];
        
        cur[u] = i;
        
        if (d[j] == d[u] + 1 && f[i]) {
            int k = dfs(j, min(f[i], limit - flow));
            
            if (!k) d[j] = -1;
            
            f[i] -= k;
            f[i ^ 1] += k;
            flow += k;
        }
    }
    
    return flow;
}

int dinic() {
    int r = 0, flow;
    
    while (bfs()) {
        while (flow = dfs(S, 1e9)) {
            r += flow;
        }
    }
    
    return r;
}

int main() {
    memset(h, -1, sizeof(h));
    
    scanf("%d%d", &m, &n);
    
    S = 0;
    T = n + 1;
    for (int i = 1; i <= m; i++) {
        scanf("%d", &c[i]);
    }
    
    for (int i = 1; i <= n; i++) {
        int A;
        
        scanf("%d", &A);
        
        for (int j = 1; j <= A; j++) {
            scanf("%d", &K[j]);
        }
        
        for (int j = 1; j <= A; j++) {
            if (st[K[j]] == 0) {
                add(S, i, c[K[j]]);
            } else {
                if (G[st[K[j]]][i] == 0) {
                    add(st[K[j]], i, 1e9);
                    G[st[K[j]]][i] = 1;
                }
            }
            
            st[K[j]] = i;
        }
        
        int B;
        
        scanf("%d", &B);
        
        add(i, T, B);
    }
    
    printf("%d", dinic());
    
    return 0;
}
```

### 谢谢观看

---

## 作者：eEfiuys (赞：1)

题目：[P4638](https://www.luogu.com.cn/problem/P4638)  
双倍经验：[SP4063](https://www.luogu.com.cn/problem/SP4063)

首先转化题意：当出现重复的钥匙时，再~~穿越时空~~调整保险柜——这不是网络流的增广路吗！

难点在于建图。
- 建立超级源点 $s$ 和超级汇点 $t$，以顾客为节点。
- 顾客 $i$ 是第一个拥有钥匙 $x$ 的：那么让他掌管保险柜 $x$，即在 $s$ 和 $i$ 之间建一条流量为 保险柜 $x$ 金币数量 的边。
- 否则：让他找上一个掌管钥匙的顾客要金币，没有限制，即在 上一个掌管钥匙 $x$ 的顾客 和 $i$ 之间建一条流量为无穷大的边。
- 但是每个顾客想要的金币数量是有限制的，因此在顾客 $i$ 和 $t$ 之间建一条流量为 顾客 $i$ 想要的金币数量 的边。

这样，顾客就可以互相要金币了，即在网络图中寻找增广路，跑最大流即可。这里使用 ISAP。注意：共有 $n+2$ 个节点。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005,inf=2147483647;
int n,m,s,t;
int tot=1,head[N],cur[N],to[N*2],dis[N*2],nxt[N*2];
int a[N],vis[N];
void add(int u,int v,int w){nxt[++tot]=head[u],to[tot]=v,dis[tot]=w,head[u]=cur[u]=tot;}
int dep[N],gap[N];
int ans;
void bfs(){
	queue<int>q;
	memset(dep,-1,sizeof(dep));
	q.push(t),dep[t]=0;
	while(!q.empty()){
		int u=q.front();q.pop(),gap[dep[u]]++;
		for(int i=head[u];i;i=nxt[i]){
			int v=to[i];
			if(dep[v]==-1)dep[v]=dep[u]+1,q.push(v);
		}
	}
}
int dfs(int u,int in){
	if(u==t)return in;
	int out=0;
	for(int i=cur[u];i;i=nxt[i]){
		cur[u]=i;
		int v=to[i],w=dis[i];
		if(dep[v]==dep[u]-1&&w){
			int x=dfs(v,min(in,w));
			dis[i]-=x,dis[i^1]+=x,in-=x,out+=x;
			if(!in)return out;
		}
	}
	if(!(--gap[dep[u]]))dep[s]=n+3;
	gap[++dep[u]]++;
	return out;
}
signed main(){
	cin>>m>>n,s=0,t=n+1;
	for(int i=1;i<=m;i++)cin>>a[i];
	for(int i=1;i<=n;i++){
		int k;cin>>k;
		for(int j=1;j<=k;j++){
			int x;cin>>x;
			if(!vis[x])add(s,i,a[x]),add(i,s,0);
			else add(vis[x],i,inf),add(i,vis[x],0);
			vis[x]=i;
		}
		cin>>k,add(i,t,k),add(t,i,0);
	}
	bfs();
	while(dep[s]<n+2)memcpy(cur,head,sizeof(head)),ans+=dfs(s,inf);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：maruize (赞：1)

网络流

**首先考虑 70pts 做法 (该做法可以通过 [MPIGS - Sell Pigs](https://www.luogu.com.cn/problem/SP4063))**

客户有顺序，我们把保险箱拆点，拆成 $n\times m$ 个点，第 $i$ 列表示前 $i$ 个人，第 $j$ 行表示第 $j$ 个保险箱。

这样拆点可以处理掉时间问题。

首先源点连向第一列点，边权为保险箱里初始金币。

对于每一个客户，祂使一些宝箱变得互相连通。

同时连出一些流量到汇点。

使一些宝箱变得互相连通怎么办呢? 肯定不能两两连边。

新建一个点，祂能打开的保险箱连向新点，再连向下一时刻的这些点，同时从新点连一条边到汇点。

点边数 $O(nm)$。

---

**100pts**

要求 $O(n) \ O(m) $ 级别的点数。

怎么压缩图啊，需要把那个点阵变成一列点。

----

对每位客户，每个宝箱都建立一个点。

对于每个客户点，类似于刚才的新点，去连一些宝箱(由宝箱连向客户点)，但是要表现时间，所以对于一个宝箱 ，只有当前客户是第一个访问该宝箱的，才从宝箱点连出，否则从前一个访问该宝箱的客户连向这个客户。这样就保证了时间。

点边数 $O(n+m)$。


代码中 $n$ 和 $m$ 和题目中是反的。


**code(70pts)**

```cpp
s=(n+1)*(m+1)+10,t=(n+1)*(m+1)+11;
for(int j=1;j<=n;j++)add(s,j,val[j]);
tot=(n+1)*(m+1)+11;//tot表示图的点数
for(int i=1;i<=m;i++){
	int a,b;
	scanf("%d",&a);
	for(int j=1;j<=a;j++){
		int x;scanf("%d",&x);
		add((i-1)*n+x,tot+1,1e9),add(tot+1,i*n+x,1e9);
	}
	scanf("%d",&b);
	add(tot+1,t,b);
	tot++;
	if(i<m)for(int j=1;j<=n;j++)add((i-1)*n+j,i*n+j,1e9);
}
```

**code(100pts)**

```cpp
s=n+m+10,t=n+m+11;
for(int j=1;j<=n;j++)add(s,j,val[j]);
tot=n+m+11;
for(int i=1;i<=m;i++){
	int a,b;
	scanf("%d",&a);
	for(int j=1;j<=a;j++){
		int x;scanf("%d",&x);
		if(!pre[x])add(x,n+i,1e9),pre[x]=i;
		else add(n+vis[x],n+i,1e9),pre[x]=i;
	}
	scanf("%d",&b);
	add(n+i,t,b);
}
```


---

## 作者：Marsrayd (赞：1)


> 网络流建模好题

[题目传送门](https://www.luogu.com.cn/problem/P4638) & [双倍经验](https://www.luogu.com.cn/problem/SP4063)

首先，顾客来取金币是有序的，前面的顾客的举动可能会影响到后面的顾客，考虑如何将这个影响体现在建图上。

由于我们可以任意重排先来的客户拥有钥匙可以打开的保险箱里的金币，我们就“令”他来“掌管”这些保险箱，根据后来人来分配这些金币。

具体如何解决呢？

拿样例一举例

```
3 3
3 1 10
2 1 2 2
2 1 3 3
1 2 6
```

第一名顾客拥有 $1,2$ 保险箱的钥匙，我们就让他掌管 $1,2$ 保险箱。

建立一条 $S \to 1(\text{代表第一名顾客的节点})$ 边权为 $3(\text{第一个保险箱中的金币数})$  的边。

再建立一条 $S \to 2(\text{代表第二名顾客的节点})$ 边权为 $1(\text{第二个保险箱中的金币数})$  的边。

这样就实现了让第一名顾客掌管了 $1,2$ 保险箱。

第一名顾客拥有 $1,3$ 保险箱的钥匙，我们就让他掌管 $1,3$ 保险箱。

由于第一名顾客已经掌管了 $1,2$ 保险箱，他可以将所有 $1,2$ 保险箱里的金币都转移到 $1$ 保险箱里，所以第二名顾客如果掌管 $1$ 保险箱就相当于掌管了 $1,2$ 保险箱，也就是掌管了第一名顾客。

所以可以直接建立一条 $1(\text{代表第一名顾客的节点})\to 2(\text{代表第二名顾客的节点})$ 边权为 $\inf$ 的边，代表着第二名顾客掌管了第一名顾客。

然后再建立一条 $S\to 2(\text{代表第二名顾客的节点})$ 边权为 $10(\text{第三个保险箱中的金币数}) $ 的边

这样顾客二的任务完成啦！！！

然后顾客三也同理掌管了 $2$ 保险箱就相当于掌管了顾客一手中的 $1,2$ 保险箱。建一条 $1\to3$ 边权为 $\inf$ 的边即可。

最后再将代表每位顾客的节点连向 $T$ 边权为他们想取的金币数跑一遍最大流即可。

$\texttt{AC CODE}$

```cpp
#include<bits/stdc++.h>
#define inf 1000000000
const int N=1000010,M=2000010;
int n,m,S,T;
int num=1,fir[N],to[M],nxt[M],f[M],fa[N];
int d[N],head,tail,que[N],cur[N],a[N];
inline void add(int u,int v,int w)
{
	to[++num]=v,nxt[num]=fir[u],fir[u]=num,f[num]=w;
}
bool bfs()
{
	memset(d,-1,sizeof(d));
	head=tail=0;
	d[S]=0,que[++tail]=S,cur[S]=fir[S];
	while(head<tail)
	{
		int u=que[++head];
		for(int i=fir[u];i;i=nxt[i])
		{
			int v=to[i];
			if(d[v]==-1&&f[i])
			{
				d[v]=d[u]+1,cur[v]=fir[v];
				if(v==T) return 1;
				que[++tail]=v;
			}
		}
	}
	return 0;
}

int find(int u,int lim)
{
	if(u==T) return lim;
	int flow=0;
	for(int i=cur[u];i;i=nxt[i])
	{
		cur[u]=i;
		int v=to[i];
		if(d[v]==d[u]+1&&f[i])
		{
			int t=find(v,std::min(lim-flow,f[i]));
			if(!t) d[v]=-1;
			f[i]-=t,f[i^1]+=t,flow+=t;
		}
	}
	return flow;
}

int dinic(){
	int res=0;
	while(bfs()) res+=find(S,inf);
	return res;
}
int main()
{
	scanf("%d%d",&m,&n);S=n+1,T=n+2;
	for(int i=1;i<=m;i++) scanf("%d",&a[i]);
	for(int A,b,i=1;i<=n;i++)
	{
		scanf("%d",&A);
		for(int j=1;j<=A;j++)
		{
			scanf("%d",&b);
			if(!fa[b]) add(S,i,a[b]),add(i,S,0);
			else add(fa[b],i,inf),add(i,fa[b],0);
			fa[b]=i;
		}
		scanf("%d",&b);
		add(i,T,b);
		add(T,i,0);
	}
	printf("%d",dinic());
	return 0;
}

```

欢迎提问or提出我的问题，会改的。

---

## 作者：ycyoi (赞：1)

## P4638 [SHOI2011]银行家
### 【题目大意】

有 $M$ 个保险箱，每个保险箱里初始时有若干个金币 $C_i$。一开始所有保险箱都是关闭的。依次来了 $N$ 个顾客，每个顾客分别会打开指定的几个保险箱，从中取走若干个金币。每个顾客分别都有他能够取走的数量的上限。每个顾客走后，他打开的那些保险箱中的金币，都可以被任意地调换到其它开着的保险箱里，然后所有保险箱重新关上。问总共最多能让客户取走多少个金币。（$1 \le N \le 100$, $1 \le M \le 1000$）

有一个顾客之后，对应的保险箱的金币就可以任意调配，就相当于这些水都流到这个管子里堵着，有的可以通过这个管子流出去（被取出），有的可以通过别的管子流出去，别的管子指和这个对应的保险箱有重叠的管子。假设这个管子是$1$，$2$，$3$重叠为 $1$ ，但经过这个管子之后1中金币也可以由$2$，$3$调配过来，所以就相当于直接在$2$，$3$取走金币。

设一个 $s$ 点为源点，一个 $t$ 点为汇点。

每来一个顾客 $m+i$ (顾客从 $m+1$ 开始编号)，如果他所拥有钥匙的保险箱还未被打开过，那连一条源点和他 流量为此保险箱的金币的数量 $(s,i,pig[i])$ 的边。

如果他所拥有钥匙的保险箱 index 被打开过，那连一条前一个打开的人和他流量为 $INF$ 的边 $(vis[index],i,INF)$。

**每个顾客与汇点连一条流量为此顾客购买力的边$(m+i,t,buy)$**。
### 代码
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define INF 0x3f3f3f3f
#define N 3001
using namespace std;
int n,m;
int cap[N][N],flow[N][N];
int EK(int s,int t) {
    int res=0;
    int dis[N];
    int p[N];
    memset(p,0,sizeof(p));
    queue<int> Q;
    while(true) {
        memset(dis,0,sizeof(dis));
        dis[s]=INF;
        Q.push(s);
        while(!Q.empty()) {
            int x=Q.front();
            Q.pop();
            for(int y=0;y<=n+1;y++) {
                if(!dis[y]&&flow[x][y]<cap[x][y]) {
                    p[y]=x;
                    Q.push(y);
                    dis[y]=min(dis[x],cap[x][y]-flow[x][y]);
                }
            }
        }
        if(dis[t]==0) break;
        for(int x=t; x!=s; x=p[x]) {
            flow[p[x]][x]+=dis[t];
            flow[x][p[x]]-=dis[t];
        }
        res+=dis[t];
    }
    return res;
}
int pigNum[N];
int last[N];
int main() {
    scanf("%d%d",&m,&n);
    memset(last,0,sizeof(last));
    memset(cap,0,sizeof(cap));
    memset(flow,0,sizeof(flow));
    int s=0,t=n+1;
    for(int i=1; i<=m; i++)
        scanf("%d",&pigNum[i]);
    for(int i=1; i<=n; i++) {
        int num;
        scanf("%d",&num);
        while(num--) {
            int temp;
            scanf("%d",&temp);
            if(last[temp]==0) cap[s][i]+=pigNum[temp];
            else cap[last[temp]][i]=INF;
            last[temp]=i;
        } scanf("%d",&cap[i][t]);
    }
    printf("%d\n",EK(s,t));
    return 0;
}
```
这是道双倍经验，和[SP4063 MPIGS - Sell Pigs](https://www.luogu.com.cn/problem/SP4063)是一样的

完结撒花

---

## 作者：MSavannah (赞：0)

双倍经验：[SP4063](https://www.luogu.com.cn/problem/SP4063)

**Solution**

现考虑朴素的建图方式，由于每个人按时间顺序来的，所以不难想到要建立分层图。

1. 源点向每个保险箱连边，边权为初始时保险箱内金币的数量。
2. 之后的 $n$ 层，每层建立 $m+1$ 个点，分别代表 $m$ 个保险箱和顾客。对于每一层，将顾客能打开的保险箱向顾客连一条边权为 $inf$ 的边，再从顾客向下一层的对应保险箱也连上边权为 $inf$ 的边。剩下那些不能够打开的，就直接向下一层保险箱连一条边权为 $inf$ 的边即可。
3. 最后，将每个顾客节点连向汇点，边权为这位顾客需要花掉的金币数。

此时的时间复杂度为 $O(n^3m^3)$，这显然需要优化。

优化：

发现对于一个保险箱，能够打开它的人必然可以按顺序随意移动金币。

那么这启发我们，只建 $n$ 个人的节点。具体连边方式如下：

1. 对于一个保险箱，如果它之前没有被打开过，那么从源点向第一个打开它的人连一条边权为 $x$ 的边（$x$ 表示保险箱初始金币数）。如果它已经被人打开过了，那从上一次打开它的人向现在这个人连一条边权为 $inf$ 的边。
2. 从每个人的节点连向汇点，边权为他们需要取走的金币数量。

这样点数和边数都大大减小。时间复杂度 $O(n^3)$。

[code](https://www.luogu.com.cn/record/159132944)

---

## 作者：Erotate (赞：0)

### Solutions

如果“你”不能调整金币的数量，那这就是一道模板题，所以我们转化一下这调整金币这个操作：如果前一个用户把能拿走的金币都拿走了，然后当前用户再找前一个用户拿回他的想得到的金币，那么拿完之后的情况和“你”调整了金币再拿实际上是一样的。

于是，我们可以记录上一个从这个保险柜里拿金币的人，如果在一个顾客之前还没有人拿过金币，那就将这个顾客和源点连一个容量为初始金币数量的边，否则就和上一个从这个保险柜里拿金币的人连一条容量无限的边，然后再和汇点连一条容量为需要的金币数量的边。最后跑一遍网络流即可。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=2505,M=4e6+5,inf=2e9;
struct edge{
	int v,nxt,w;
}e[M<<1];
int head[N],cnt=1;
int n,m,S,T,cur[N],dep[N],c[N],lst[N];
void Add(int x,int y,int w){
	e[++cnt]=((edge){y,head[x],w});
	head[x]=cnt;
}
void add(int x,int y,int w){
	Add(x,y,w),Add(y,x,0);
}
bool bfs(int st,int ed){
	memset(dep,0,sizeof(dep));
	queue<int>q;
	q.push(st);
	cur[st]=head[st],dep[st]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(!dep[v] && e[i].w){
				dep[v]=dep[u]+1;
				cur[v]=head[v];
				q.push(v);
			}
		}
	}
	return dep[ed];
}
int dfs(int u,int frm){
	int to=0;
	if(u==T) return frm;
	for(int i=cur[u];i && frm;i=e[i].nxt){
		int v=e[i].v;
		cur[u]=i;
		if(e[i].w && dep[v]==dep[u]+1){
			int tmp=dfs(v,min(frm,e[i].w));
			e[i].w-=tmp,e[i^1].w+=tmp;
			frm-=tmp,to+=tmp;
		}
	}
	if(!to) dep[u]=0;
	return to;
}
int Dinic(){
	int flw=0;
	while(bfs(S,T)) flw+=dfs(S,inf);
	return flw;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	cin>>m>>n;
	S=0,T=n+1;
	for(int i=1;i<=m;++i) cin>>c[i];
	for(int i=1,k,a,need;i<=n;++i){
		cin>>k;
		while(k--){
			cin>>a;
			if(!lst[a]) add(S,i,c[a]);
			else add(lst[a],i,inf);
			lst[a]=i;
		}
		cin>>need;
		add(i,T,need);
	}
	cout<<Dinic()<<endl;
	return 0;
}
```


---

## 作者：赵悦岑 (赞：0)

[P4638 [SHOI2011]银行家](https://www.luogu.com.cn/problem/P4638)

## 分析

这道题题目十分的冗杂，我们先来整理一下题意：一些客户要来银行取金币，如果 $i$ 个客户需要 $c_i$ 个金币，能打开的所有保险箱中金币总数多于 $c_i$ 就会取走对应的金币数，否则会全部取走，而且一个客户来取金币后就可以交换他打开的保险箱的金币，请问所有客户最多可以取走多少金币。

&#8195; 这道题初看就可以发现是一道网络流的题，金币即为流。在每一个客户打开了几个保险箱之后就把这些保险箱合并成一个保险箱即可。但是对于特定的客户（也就是第一个打开这些保险箱的客户之后的客户）才可以合并保险箱，而其他的客户就不行。如果我们把这些保险箱简单地连在一起，就可以给所有客户交换金币。

由于在第一个打开这个保险箱之后的客户才能合并保险箱，我们可以把合并起来的保险箱指向后面的所有客户，而不指向之前的客户就可以了。但是处理合并保险箱也比较麻烦，比如第一个人打开了保险箱 $1,2$，第二个人打开了 $2,3$，此时 $2,3$ 保险箱都可以取到保险箱 $1$ 的金币了，所以我们需要将每一个保险箱对应的合并保险箱再合并起来才对，而不是单独的原始保险箱。而且注意，此时对于保险箱 $2,3$ 来说 $1,2,3$ 是一个保险箱，但是对于保险箱 $1$ 来说只有 $1,2$ 是一个保险箱。

由于一个客户打开的所有保险箱都要合并，我们就可以把这个合并保险箱与这个客户捆绑。如果一个保险箱已经与一个客户捆绑了，那么当前客户就可以把这个保险箱里的金币从上一个人接手全部或部分过来。如果这个保险箱还没有人开过就直接把原始保险箱中的金币放在自己对应的保险箱中。

我们来看一眼样例：

```
3 3
3 1 10
2 1 2 2
2 1 3 3
1 2 6
```

&#8195; 样例建出来的图如下（每一条边的容量都是正无穷），再加上源汇点即可。

![1](https://cdn.luogu.com.cn/upload/image_hosting/qnkaxboo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

## code
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;
int N,n,m,p=1,s1,s2,t[10001],t0[10001],f[10001],g[10001],v[10001];
bool u=true;
struct str
{
    int m,q;
    ll r;
}a[1000001];
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
void bfs()
{
    queue<int> Q;
    Q.push(s2);
    f[s2]=1;
    g[1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0)
            {
                f[a[i].m]=f[k]+1;
                ++g[f[a[i].m]];
                Q.push(a[i].m);
            }
        }
    }
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[x]==f[a[i].m]+1&&a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            if(r==0) return s;
        }
    }
    --g[f[x]];
    if(g[f[x]]==0) u=false;
    ++f[x];
    ++g[f[x]];
    return s;
}
int main()
{
    scanf("%d%d",&m,&n);
    N=n+m+2;
    s1=N-1;
    s2=N;
    for(int i=1;i<=m;++i)
    {
        ll r;
        scanf("%lld",&r);
        road(s1,i,r);
        road(i,s1,0);
    }
    for(int i=1;i<=n;++i)
    {
        int d;
        scanf("%d",&d);
        for(int j=1;j<=d;++j)
        {
            int x;
            scanf("%d",&x);
            if(v[x]==0)
            {
                road(x,m+i,1e18);
                road(m+i,x,0);
            }
            else
            {
                road(m+v[x],m+i,1e18);
                road(m+i,m+v[x],0);
            }
            v[x]=i;
        }
        ll r;
        scanf("%lld",&r);
        road(m+i,s2,r);
        road(s2,m+i,0);
    }
    bfs();
    ll r=0;
    while(u==true)
    {
        for(int i=1;i<=N;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    printf("%lld",r);
    return 0;
}
```

---


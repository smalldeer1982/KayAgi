# [SHOI2011] 编译优化

## 题目背景

 

## 题目描述

就像 PASCAL 语言和 C/C++ 语言一样， SH 语言也是一种编程语言。 SH 语言共有 $26$ 个寄存器，用大写拉丁字母 A, B, … , Z 表示。 SH 语言的程序中，第一行依次是这 $26$ 个寄存器的初始值，用空格分隔。程序的第二行起，每一行都是一条命令。 SH 语言有三种命令，如下表所示（在格式这一列中，用下划线代替实际语言中的一个空格）。

-    ``ADD``命令 格式：``ADD_R1_R2``  功能：将寄存器 R2 的值加到寄存器 R1 上。 限制：无。

-    ``GOTO`` 命令 格式：``IF _R_ < _I1_ GOTO _LINE_ I2`` 功能：如果寄存器 R 的值小于立即数 I1 ，则跳转至第 I2 （ $\ge 2$ ）行，否则继续执行下一行。限制：至多出现一次，且只可能出现在第 I2 行之后。

-    ``PRINT`` 命令 格式：``PRINT_R`` 功能：打印寄存器 R 的值。限制：出现且仅出现在最后一行。

现给定一个 SH 语言的程序，请输出 ``PRINT`` 命令打印的值。

## 说明/提示

在每个测试点，如果您的输出与标准答案完全一致，您将能得到该测试点的全部分数；否则，您将在该测试点得 $0$ 分。

本题为提交答案题，所有的 $10$ 个输入文件 ``compiler1.in ~ compiler10.in`` 都已存放在题目背景的下载链接中。对于每个输入文件，您需要分别给出相应的输出文件 ``compiler1.out ~ compiler10.out``。

注意：您只需提交输出文件而无需提交任何程序。

## 样例 #1

### 输入

```
0 100 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ADD A B
IF A < 220 GOTO LINE 2
PRINT A```

### 输出

```
300```

# 题解

## 作者：dtcxzyw (赞：10)


## 感受

这道题就是标题党。。。

~~本以为我要像NOI2016旷野大计算那样写个微型编译器。~~

## 解题思路

注意到本题的一个性质：**只有一个if**

程序的执行流程为

- 执行if跳转到的行之前一次

- 迭代执行if与它跳转到的行之间的块

~~是不是很像Pollard-Rho啊~~

对于只执行一次的代码，暴力模拟即可

对于迭代块内的代码，可计算出转移矩阵后，用矩阵快速幂在$O(26^3lgn)$的时间内计算迭代n次后寄存器的答案。

### 转移矩阵的计算

令$A[i][j]$为执行代码前的i寄存器对执行代码后j寄存器的贡献（系数）

执行代码块后的寄存器值$V'[j]=\sum_{i=a}^zA[i][j]V[i]$

首先将A初始化为单位矩阵I，每次执行add操作时将r2的系数加到r1即可。

### 计算答案

还有一个性质：**寄存器的值是非减的，而且if中所判断的数肯定会不停地增长，否则程序将陷入死循环。**

在倍增求转移矩阵的幂时顺便判一下上界，我们就可以开始愉快地**二分**了。


## 吐槽

数据太水，不爆long long,没用__int128或double等就过了。

## 代码

```cpp
#include <cstdio>
#include <cstring>
long long read(){
	long long res=0;
	int c;
	do c=getchar();
	while(c<'0'||c>'9');
	while('0'<=c&&c<='9'){
		res=res*10+c-'0';
		c=getchar();
	}
	return res;
}
int getAlpha(){
	int c,res;
	do c=getchar();
	while(c<'A'||c>'Z');
	res=c;
	while('A'<=c&&c<='Z')c=getchar();
	return res;
}
typedef long long BigInt;
const BigInt one=1;
void print(BigInt x){
	if(x>=10)print(x/10);
	putchar('0'+x%10);
}
const int size=100005;
struct Add{
	int dst,src;
} A[size];
struct Mat{
	BigInt val[26][26];
	int n,m;
	Mat(){}
	Mat(int n,int m):n(n),m(m){}
	void reset(){
		memset(val,0,sizeof(val));
	}
	const BigInt* operator[](int id) const{
		return val[id];
	}
	BigInt* operator[](int id){
		return val[id];
	}
	Mat operator*(const Mat& rhs) const{
		Mat res(n,rhs.m);
		for(int i=0;i<res.n;++i)
			for(int j=0;j<res.m;++j){
				BigInt sum=0;
				for(int k=0;k<m;++k)
					sum+=val[i][k]*rhs[k][j];
				res[i][j]=sum;
			}
		return res;
	}
};
const int end=64;
Mat pt[end+1];
Mat powm(BigInt k){
	Mat res=pt[0];
	for(int i=0;i<end;++i)
		if((k>>i)&1)res=res*pt[i];
	return res;
}
int main(){
	Mat base(1,26);
	for(int i=0;i<26;++i)base[0][i]=read();
	Mat trans(26,26);
	trans.reset();
	for(int i=0;i<26;++i)trans[i][i]=1;
	bool flag=true;
	int acnt=1,dst,key;
	long long gate;
	while(flag){
		switch(getAlpha()){
			case 'A':{
				++acnt;
				A[acnt].dst=getAlpha()-'A';
				A[acnt].src=getAlpha()-'A';
				break;
			}
			case 'I':{
				key=getAlpha()-'A';
				gate=read();
				int line=read();
				for(int i=2;i<line;++i)
					base[0][A[i].dst]+=base[0][A[i].src];
				for(int i=line;i<=acnt;++i)
					for(int j=0;j<26;++j)
						trans[j][A[i].dst]+=trans[j][A[i].src];
				break;
			}
			case 'P':{
				flag=false;
				dst=getAlpha()-'A';
				break;
			}
		}
	}
	BigInt l=1,r=-1;
	for(int i=0;i<end;++i){
		if(i==0)pt[i]=trans;
		else pt[i]=pt[i-1]*pt[i-1];
		Mat end=base*pt[i];
		if(end[0][key]>=gate){
			r=one<<i;
			break;
		}
	}
	if(r==-1)throw;
	BigInt ans;
	while(l<=r){
		BigInt m=(l+r)>>1;
		Mat res=base*powm(m);
		if(res[0][key]>=gate)r=m-1,ans=res[0][dst];
		else l=m+1;
	}
	print(ans);
	return 0;
}

```


---

## 作者：Jμdge (赞：2)

来一发清真代码。

这道题的关键点就是矩阵加速，这也是本题唯一亮点。

不过矩阵的构造方式没什么难度，也就是硬加了字符串的一丢处理所以整道题麻烦了许多。


话说楼上代码好像有点问题啊，题目里没说 IF 后面就跟 PRINT 了啊。。。

万一还有 ADD 操作的话不是就少加了？（还好出题人是懒的，没有满满的恶意）。

另外同楼上，数据不会爆 long long （我的天，题目里的提示就是吓唬人？）


----

代码如下：
----


```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define ll long long
using namespace std;
const int M=1e5+5;
int tim=1,P,ID,OUT,GOTO;
char s[15]; ll VAL,X[M],Y[M];
struct Matrix{ ll a[27][27]; //内置各种重载。。。
	Matrix (){memset(a,0,sizeof a);}
	ll* operator [](int x){return a[x];} //这个重载真的是鬼畜
	Matrix operator *(Matrix b){ //这个重载很常规则，配上楼上打起来非常舒服。
		static Matrix tmp; //为了省空间。。。
		for(int i=1;i<=26;++i)
			for(int j=1;j<=26;++j)
				tmp[i][j]=0;
		for(int i=1;i<=26;++i)
			for(int j=1;j<=26;++j)
				for(int k=1;k<=26;++k)
					tmp[i][j]+=a[i][k]*b[k][j];
		return tmp;
	}
}A,mp[65],tmp;
int main(){
	for(int i=1;i<=26;++i) scanf("%lld",&A[1][i]);
	while(true){
		scanf("%s",s+1),++tim;
		if(s[1]=='P'){scanf("%s",s),OUT=s[0]-'A'+1;break;}
		else if(s[1]=='A'){
			scanf("%s",s),X[tim]=s[0]-'A'+1;
			scanf("%s",s),Y[tim]=s[0]-'A'+1;
			A[1][X[tim]]+=A[1][Y[tim]];
		}
		else if(s[1]=='I'){
			scanf("%s",s),ID=s[0]-'A'+1;
			scanf("%s",s),scanf("%lld",&VAL);
			scanf("%s%s",s,s),scanf("%d",&GOTO);
			for(int i=1;i<=26;++i)
				++mp[0][i][i];
			for(int i=GOTO;i<tim;++i)
				for(int j=1;j<=26;++j)
					mp[0][j][X[i]]+=mp[0][j][Y[i]];
			for(P=1;P<64;++P){
				mp[P]=mp[P-1]*mp[P-1];
				tmp=A*mp[P];
				if(tmp[1][ID]>=VAL) break;
			}
			for(int i=P;i>=0;--i){
				tmp=A*mp[i];
				if(tmp[1][ID]<VAL)
					A=tmp;
			} A=A*mp[0];
		}
	} return cout<<A[1][OUT]<<endl,0;
}
```


然后送点小福利：送前 6 个数据点的答案（放全部的话不大好吧。。。）

~~然后你就可以看别人代码了。~~


	100
	1000000000
	1000000000000000925
	428911
	23323
	288452




---

## 作者：Seauy (赞：1)

首先回答一下为什么不会爆 long long

题目里已经说了答案不会爆 long long，而修改操作中只有加法，因此所有其它变量在对答案做的贡献时也都不会爆 long long

换句话说，只要答案不爆，跟答案有关的变量也不会爆，并不是数据水

然后我们一个个来看每个点吧

## compiler#1

 _compiler1.in_ 

```
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
ADD A B
ADD C D
ADD E F
ADD G H
ADD I J
ADD K L
ADD M N
ADD O P
ADD Q R
ADD S T
ADD U V
ADD W X
ADD Y Z
IF A < 100 GOTO LINE 2
PRINT Y
```
很容易看出来 A Y 从 0 开始每次都增加 1


## compiler#2

_compiler2.in_

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
ADD A B
ADD B C
ADD C D
ADD D E
ADD E F
ADD F G
ADD G H
ADD H I
ADD I J
ADD J K
ADD K L
ADD L M
ADD M N
ADD N O
ADD O P
ADD P Q
ADD Q R
ADD R S
ADD S T
ADD T U
ADD U V
ADD V W
ADD W X
ADD X Y
ADD Y Z
IF X < 499999999500000000 GOTO LINE 2
PRINT Y

```

其实就是个杨辉三角，不过这个性质已经不重要了，数据小可以直接爆算


## compiler#3

_compiler3.in_

```
9924 6305 9338 4005 6547 458 6365 8113 1554 7350 8069 7510 6412 6048 6607 6349 1027 9953 7105 7335 4790 8612 2475 2386 2077 5064
ADD A U
ADD A O
ADD A L
ADD A Q
ADD A S
ADD A G
ADD A N
ADD A X
ADD A C
ADD A J
ADD A W
ADD A C
ADD A D
ADD A G
ADD A S
ADD A P
ADD A K
ADD A C
ADD A G
ADD A G
ADD A V
ADD A Y
ADD A V
ADD A C
ADD A Q
ADD A J
ADD A K
ADD A L
ADD A T
ADD A R
ADD A U
ADD A C
ADD A X
ADD A U
ADD A R
ADD A A
ADD A C
ADD A E
ADD A J
ADD A R
ADD A B
ADD A T
ADD A D
ADD A S
ADD A J
ADD A W
ADD A A
ADD A E
ADD A W
ADD A V
ADD A G
ADD A S
ADD A Z
ADD A V
ADD A D
ADD A O
ADD A N
ADD A J
ADD A B
ADD A F
ADD A H
ADD A V
ADD A N
ADD A N
ADD A Z
ADD A Z
ADD A E
ADD A U
ADD A W
ADD A J
ADD A S
ADD A H
ADD A C
ADD A W
ADD A M
ADD A O
ADD A D
ADD A O
ADD A R
ADD A M
ADD A K
ADD A C
ADD A K
ADD A S
ADD A U
ADD A V
ADD A Y
ADD A T
ADD A O
ADD A W
ADD A V
ADD A Q
ADD A H
ADD A D
ADD A L
ADD A O
ADD A D
ADD A N
ADD A Y
ADD G I
IF G < 1000000000000000000 GOTO LINE 2
PRINT G

```
题目要求的是 G 啊……跟 A 一点关系也没有

一开始 $G=6365,I=1554$，设循环了 $k$ 次，上限为 $,a=1000000000000000000$

那么 $k=\lceil\frac{a-G}{I}\rceil$

最后答案为 $G+Ik$ 可以放进 c++ 里算出

# compiler#4~10

这里已经没有啥规律了，而且数据量开始大了，我们需要一个通解

像这样递推的快速转移，我们就得用矩阵快速幂了

由于受限的变量是单调不降的，我们可以二分到它第一次突破限制的时候

不过有一点，虽然答案不会爆，但是二分出来的幂太大了也是会爆的

或许你会用答案单调不降这一性质来判断是否爆了，但是这样是~~不严谨的~~，因为即使爆了也可以单调不降

你可以先别二分，手动估算一下幂的上限，这样就算爆了的话也可以通过人来多方面验证

这里给个手动估算的代码

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

string opt,a,b;
ull Limit=1000000000000000000;
int S=2,IF='N'-'A',ASK='N'-'A';

struct Matrix
{
	ull data[26][26];
	void Clean() {memset(data,0,sizeof data);}
	void One()
	{
		for(int i=0;i<26;i++)
			for(int j=0;j<26;j++)
				data[i][j]=(i==j);
	}
	Matrix operator + (const Matrix &x)
	{
		Matrix cnt;
		for(int i=0;i<26;i++)
			for(int j=0;j<26;j++)
				cnt.data[i][j]=data[i][j]+x.data[i][j];
		return cnt; 
	}
	Matrix operator * (const Matrix &x)
	{
		Matrix cnt;cnt.Clean();
		for(int i=0;i<26;i++)
			for(int j=0;j<26;j++)
			{
				cnt.data[i][j]=0;
				for(int k=0;k<26;k++) cnt.data[i][j]+=data[i][k]*x.data[k][j];
			}
		return cnt;
	}
	Matrix operator ^ (const ull &x)
	{
		Matrix cnt,i=*this;cnt.One();
		for(ull j=x;j>0;j>>=1,i=i*i)
			if(j&1) cnt=cnt*i;
		return cnt;
	}
	void Print()
	{
		for(int i=0;i<26;i++)
		{
			for(int j=0;j<26;j++) cout<<data[i][j]<<' ';
			cout<<endl;
		}
	}
}dp,TM,Sing,ans;

int main()
{
	ifstream InPut;
	InPut.open("compiler9.in");
	for(int i=0;i<26;i++) InPut>>dp.data[0][i];
	TM.One();
	for(int i=2;1;i++)
	{
		InPut>>opt;
		if(opt=="ADD")
		{
			InPut>>a>>b;
			if(i<S) dp.data[0][(int)a[0]-'A']+=dp.data[0][(int)b[0]-'A'];
			else
			{
				Sing.One();
				++Sing.data[(int)b[0]-'A'][(int)a[0]-'A'];
				//Sing.Print();
				TM=TM*Sing;
			}
			//printf("At %d ADD %d to %d\n",i,(int)b[0]-'A',(int)a[0]-'A');
		}
		else break;
	}
	InPut.close();
	//printf("dp:\n");
	//dp.Print();
	//printf("TM:\n");
	//TM.Print();
	for(ull x;1;)
	{
		cin>>x;
		if(!x) break;
		//(TM^x).Print();
		//(dp*(TM^x)).Print();
		ans=(dp*(TM^x));
		cout<<"IF:  "<<ans.data[0][IF]<<endl;
		cout<<"ASK: "<<ans.data[0][ASK]<<endl;
		if(ans.data[0][IF]>=Limit) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```
这里以9号点为例

估算出上限后就可以愉快地二分了

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

string opt,a,b;
ull Limit=1000000000000000000;
int S=2,IF='N'-'A',ASK='N'-'A';

struct Matrix
{
	ull data[26][26];
	void Clean() {memset(data,0,sizeof data);}
	void One()
	{
		for(int i=0;i<26;i++)
			for(int j=0;j<26;j++)
				data[i][j]=(i==j);
	}
	Matrix operator + (const Matrix &x)
	{
		Matrix cnt;
		for(int i=0;i<26;i++)
			for(int j=0;j<26;j++)
				cnt.data[i][j]=data[i][j]+x.data[i][j];
		return cnt; 
	}
	Matrix operator * (const Matrix &x)
	{
		Matrix cnt;cnt.Clean();
		for(int i=0;i<26;i++)
			for(int j=0;j<26;j++)
			{
				cnt.data[i][j]=0;
				for(int k=0;k<26;k++) cnt.data[i][j]+=data[i][k]*x.data[k][j];
			}
		return cnt;
	}
	Matrix operator ^ (const ull &x)
	{
		Matrix cnt,i=*this;cnt.One();
		for(ull j=x;j>0;j>>=1,i=i*i)
			if(j&1) cnt=cnt*i;
		return cnt;
	}
	void Print()
	{
		for(int i=0;i<26;i++)
		{
			for(int j=0;j<26;j++) cout<<data[i][j]<<' ';
			cout<<endl;
		}
	}
}dp,TM,Sing,ans;

int main()
{
	ifstream InPut;
	InPut.open("compiler9.in");
	for(int i=0;i<26;i++) InPut>>dp.data[0][i];
	TM.One();
	for(int i=2;1;i++)
	{
		InPut>>opt;
		if(opt=="ADD")
		{
			InPut>>a>>b;
			if(i<S) dp.data[0][(int)a[0]-'A']+=dp.data[0][(int)b[0]-'A'];
			else
			{
				Sing.One();
				++Sing.data[(int)b[0]-'A'][(int)a[0]-'A'];
				//Sing.Print();
				TM=TM*Sing;
			}
			//printf("At %d ADD %d to %d\n",i,(int)b[0]-'A',(int)a[0]-'A');
		}
		else break;
	}
	InPut.close();
	//printf("dp:\n");
	//dp.Print();
	//printf("TM:\n");
	//TM.Print();
	ull L=0,R=1000000000000000000;
	for(ull mid;L<=R;)
	{
		mid=L+((R-L)>>1);
		ans=(dp*(TM^mid));
		if(ans.data[0][IF]<Limit) L=mid+1;
		else R=mid-1;
	}
	ofstream OutPut;
	OutPut.open("compiler9.out");
	ans=(dp*(TM^L));
	OutPut<<ans.data[0][ASK]<<endl;
	return 0;
}
```

---

## 作者：Rad_Forever (赞：1)

这题算是一道比较简单的提交答案题。

### $\text{Case}\:1$

直接观察，不难发现最后 `Y` 和 `A` 是相等的，`A` 每次会加 $1$。当 `A` 等于 $100$ 时输出 `Y`，所以答案就是 $100$。

### $\text{Case}\:2$

还是直接观察，发现 `X` 每次加 `Y`，`Y` 每次加 $1$。

所以 `X` 就是一个等差数列求和的结果，计算可以得到答案为 $10^9$。

### $\text{Case}\:3$

`G=6365`，`I=1554`，`G` 每次累加 `I`。

直接计算就得到答案是 $1000000000000000925$。

### $\text{Case}\:4,5$

直接自己手写一个代码模拟这个过程即可。

```cpp
#include<bits/stdc++.h>

#define RI register int

using namespace std;

const int MAXN = 1000000;

long long val[1000];

int d[MAXN];

string s[1000000], k;

char a[MAXN], b[MAXN];

long long c[1000000];

int tot;

inline void GoFor(int x){
	if(x==100003) return ;
	if(s[x]=="IF") {
		if(val[a[x]] < c[x]) return GoFor(d[x]-1);
		else return GoFor(x+1);
	}
	else{
		if(s[x]=="ADD") val[a[x]]+=val[b[x]];
		else{
			cout << val[a[x]] << endl;
		}
		return GoFor(x+1);
	}
}

int main(){
	freopen("compiler4.in","r",stdin);
	for(int i=65;i<=90;++i) cin >> val[i];
	for(int i=1;i<=100002;++i){
		cin >> s[i];
		if(s[i]=="IF"){
			cin >> a[i] >> b[i];
			cin >> c[i];
			cin >> k;
			cin >> k;
			cin >> d[i];
		}
		else{
			if(s[i]=="ADD"){
				cin >> a[i] >> b[i];
			}
			else{
				cin >> a[i];
			}
		}
	}
	GoFor(1);
}	
```

### $\text{Case}\:6,7,8,9,10$

这都是找规律的。

直接用上面的代码跑会爆栈。

但是可以得到前几次到达 `IF` 语句时 `A~Z` 的值，可以直接观察发现规律。

这里建议自己实现。

---


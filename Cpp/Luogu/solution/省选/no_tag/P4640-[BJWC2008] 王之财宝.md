# [BJWC2008] 王之财宝

## 题目描述

《基尔伽美修》是人类历史上第一部英雄史诗，两河流域最杰出的文学作品之一。作品讲述了基尔伽美修一生的传奇故事。在动画Fate/stay night中，基尔伽美修与亚瑟王等传说中的英雄人物一起出现在了现实世界，展开了一场惊天地、泣鬼神的战斗。在记载于12块泥板的史诗中，基尔伽美修与同伴安吉杜一起降伏了森林的守护者——神兽洪芭芭，成为地上最强的王者，同时将世间所有财宝收归手中。王之财宝(Gate of Babylon)成为Fate中金皮卡（基尔伽美修的外号…）炫耀的资本……

一天金皮卡突发奇想：如果从自己无尽的财宝里面，随便抽不超过M件宝具出来砸死敌人的话。一共有多少种搭配方法呢？假设金皮卡一共有N种不同类型的宝具，大部分类型的宝具都有无限多，但其中T种超级神器的数量是有限的。设第i种超级神器的数量不超过$B_i$件。若相同类型的宝具数量相同，则认为是相同的搭配方案。

金皮卡知道方案数会很大，从小数学成绩就好的他挑选了一个质数P，请你帮他计算一下方案数模P后的余数。注意，一件也不选也是一种方案。

## 说明/提示

只有一种超级神器，数量不超过3

当不选择超级神器时，另一种宝具可以挑选0到10件，共11种方案

当选择1件神器出来时，另一种宝具可以挑选0到9件，共10种方案

当挑选2件神器时，共9种方案

挑选3件神器时，共8种方案

一共有11+10+9+8=38种方案，$38\bmod13=12$，于是答案等于12

## 样例 #1

### 输入

```
2 1 10 13
3```

### 输出

```
12```

# 题解

## 作者：mrclr (赞：4)

如果没有限制，而且必须选$m$件的话，就是隔板法$C_{n + m - 1} ^ {m - 1}$了。现在要选至多$m$件，那么就相当于新增一个板儿，分出的新的盒子表示“多出来的”，也就是说前$m$个盒子是选出来的宝具，这样就能满足至多$m$个的限制了，即$C_{n + m} ^ {m}$。

从公式这一角度来说，就是$\sum _ {i = 0} ^ {n} C_ {i + m - 1} ^ {m - 1} = C_{n + m} ^ {m}$，至于证明，在我的另一篇博客上有，[题解：bzoj4403 序列统计](https://www.cnblogs.com/mrclr/p/10932978.html)。

现在我们加上了$T$这个限制。我一直在想，$T$这么小，显然可以$2 ^ T$暴力枚举，但那又有啥用咧？

后来某大佬的题解告诉我，你怎么就想不到容斥啊？

好像有道理，答案等于至少0个神器超过限制的方案数 - 至少1个神器超过限制方案数 + 至少3个超过限制 - ……而对于每一个方案数，我们先强制让这些神器选$B_i + 1$个，然后剩下的随便选，就是$C_{n + m - \sum(B_i + 1)} ^ {m - \sum (B_i + 1)} = C_{n + m - \sum(B_i + 1)} ^ {n}$。

最后因为模数小，上lucas。
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
#include<assert.h>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 1e6 + 5;
In ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
In void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}
In void MYFILE()
{
#ifndef mrclr
  freopen(".in", "r", stdin);
  freopen(".out", "w", stdout);
#endif
}

int n, T, m, mod, b[20];

ll fac[maxn], inv[maxn];
In ll inc(ll a, ll b) {return a + b < mod ? a + b : a + b - mod;}
In ll C(int n, int m) 
{
  if(m > n) return 0;
  return fac[n] * inv[n - m] % mod * inv[m] % mod;
}
In ll lucas(int n, int m)
{
  ll ret = 1;
  for(; m; n /= mod, m /= mod)
    ret = ret * C(n % mod, m % mod) % mod;
  return ret;
}
In ll quickpow(ll a, ll b)
{
  ll ret = 1;
  for(; b; b >>= 1, a = a * a % mod)
    if(b & 1) ret = ret * a % mod;
  return ret;
}

In void init()
{
  fac[0] = inv[0] = 1;
  for(int i = 1; i < mod; ++i) fac[i] = fac[i - 1] * i % mod;
  inv[mod - 1] = quickpow(fac[mod - 1], mod - 2);
  for(int i = mod - 2; i; --i) inv[i] = inv[i + 1] * (i + 1) % mod;
}

int main()
{
  //MYFILE();
  n = read(), T = read(), m = read(), mod = read();
  for(int i = 1; i <= T; ++i) b[i] = read();
  init();
  ll ans = 0;
  for(int i = 0; i < (1 << T); ++i)
    {
      int cnt = 0, tp = m;
      for(int j = 1; j <= T; ++j)
		if((i >> (j - 1)) & 1) ++cnt, tp -= b[j] + 1;
      ans = inc(ans, (cnt & 1) ? mod - lucas(n + tp, n) : lucas(n + tp, n));
    }
  write(ans), enter;
  return 0;
}
```

---

## 作者：KAMIYA_KINA (赞：2)

## Tag

生成函数，组合数学。

## Preface

生成関数が大勝利！

## Description

给定 $n$ 个物品，其中有 $t$ 个分别只能使用 $b_i$ 次，其他的都可以无限使用，求使用不超过 $m$ 个物品的方案数，对 $p$ 取模。（两个方案不同当且仅当有一种物品的使用数量不同）

$\texttt{data range:} n,m\leq 10^9, t\leq \min(n,15),p\leq 10^5,p\in Prime$.

## Solution

生成函数大胜利！

考虑这个问题的生成函数，无限使用的生成函数为：
$$
G(x)=\left(\dfrac{1}{1-x}\right)^{n-t}
$$
限制使用的生成函数为：
$$
F_k(x)=\dfrac{1-x^{b_k+1}}{1-x}
$$
那么我们最后答案的生成函数就是：
$$
H(x)=G(x)\prod_{i=1}^tF_i(x)
$$
然后展开一下可以惊奇的发现：
$$
H(x)=\left(\dfrac{1}{1-x}\right)^n\prod_{i=1}^t(1-x^{b_i+1})
$$
我们的式子就变成了这样。

然后我们需要求不超过 $m$ 的数量，所以加入一个前缀和：
$$
Ans=[x^m]\left(\dfrac{1}{1-x}\right)^{n+1}\prod_{i=1}^t(1-x^{b_i+1})
$$
根据这个式子可以 $O(2^t)$ 完成了……

每一次枚举 $t$ 的一个子集，然后暴力组合算一波……

什么你不会组合？~~remake 吧。~~

设后面的式子中 $x$ 的指数为 $k$，其中加入相乘的 $x$ 的数量为 $s$，则答案就是：
$$
\sum_{k,s}\dbinom{n+m-k}{m-k}(-1)^s
$$
直接做就可以了。

## Code

```cpp
inline void work() {
    int ans = 0;
    for(int s = 0; s < (1 << t); s++) {
        int f = 1, sum = 0;
        for(int i = 1; i <= t; i++) 
            if(s & (1 << (i - 1))) sum += b[i], f = -f;
        (ans += f * lucas(n + m - sum, n - sum) + mod) %= mod;
    }
    cout << ans << '\n';
    return ;
}
```



---

## 作者：QuantAsk (赞：2)

# 正题
题目链接:[https://www.luogu.com.cn/problem/P4640](https://www.luogu.com.cn/problem/P4640)

## 题目大意
- $N$ 种物品，其中 $T$ 种有数量限制，第 $i$ 种物品数量为 $b_i$ 个。
- 选择不超过 $M$ 个物品，求方案数。
- 输出答案对 $P$ 取模。

$1\leq N,M\leq 10^9,0\leq T\leq min\{N,15\},1\leq b_i\leq 10^9$。

$P\leq 10^5$ 且保证 $P$ 是质数。

## 解题思路
竟然没有生成函数的解法，这算是一道 OGF 的入门题了。

对于没有数量限制的物品，生成函数是 
$$f_0(x)=\sum_{i=0}^\infty x^i=\frac{1}{1-x}$$

对于第 $k$ 种有限制的物品，生成函数是 
$$f_k(x)=\sum_{i=0}^{b_k}x^i=\frac{1-x^{b_k+1}}{1-x}$$

那么我们现在要把所有这些生成函数乘起来然后求前 $m$ 次系数的和。

分子和分母分开考虑，对于分子部分。只有 $T$ 个是非 $1$ 的，考虑到 $T$ 非常小，我们可以 $O(2^T)$ 暴力枚举那些选择了 $-x^{b_k+1}$ ，其他都选择 $1$。这样我们就可以快速计算出所有分子的系数。

对于分母乘起来的话就是 $\frac{1}{(1-x)^n}$ 。对于 $(\frac{1}{1-x})^n$ 的第 $i$ 次项系数就是把 $i$ 个无标号元素放入 $n$ 个有标号集合里的方案。

也就是
$$(\frac{1}{1-x})^n=\sum_{i=0}^n \binom{n+i-1}{i}x^i$$

然后分子和分母乘起来就是我们需要的最终函数了。

那么考虑一个分子的系数 $ax^k$ 和分母相乘后会产生的贡献是

$$a\sum_{i=0}^{m-k}\binom{n+i-1}{i}$$

因为只要分母的系数在 $m-k$ 次项以内那么于 $ax^k$ 相乘后就是在 $m$ 次以内的了。

然后发现这个式子还是很麻烦，但是后面那个组合数的和就有

$$\sum_{i=0}^{m-k}\binom{n+i-1}{i}=\binom{n+m-k}{n}$$
（按照组合意义理解的话就是将不超过 $m-k$ 个元素放入 $n$ 个集合中，那么我们多开一个集合作为垃圾箱，然后多出来的放入垃圾箱就表示没有这个元素就好了）

然后因为模数很小所以用 Lucas 就可以了。

不算上 Lucas 的话复杂度就是 $O(P+2^T)$ 了

## code
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const ll N=1e5+10;
ll n,t,m,p,b[20],ans,inv[N],fac[N];
ll C(ll n,ll m)
{return fac[n]*inv[m]%p*inv[n-m]%p;}
ll L(ll n,ll m){
	if(n<m)return 0;
	if(n<p)return C(n,m);
	return L(n/p,m/p)*L(n%p,m%p)%p;
}
signed main()
{
	scanf("%lld%lld%lld%lld",&n,&t,&m,&p);
	for(ll i=0;i<t;i++)scanf("%lld",&b[i]),b[i]++;
	inv[1]=1;
	for(ll i=2;i<p;i++)
		inv[i]=p-inv[p%i]*(p/i)%p;
	inv[0]=fac[0]=1;
	for(ll i=1;i<p;i++)
		fac[i]=fac[i-1]*i%p,inv[i]=inv[i-1]*inv[i]%p;
	ll MS=(1<<t); 
	for(ll s=0;s<MS;s++){
		ll f=1,sum=0;
		for(ll i=0;i<t;i++)
			if((s>>i)&1)f=-f,sum+=b[i];
		(ans+=L(n+m-sum,n)*f)%=p;
	}
	printf("%lld\n",(ans+p)%p);
	return 0;
}

```

---


# [IOI 2008] Fish

## 题目描述

据Scheherazade说，在很远的沙漠中有一个湖。湖中起初有$F$条鱼。选择最值钱的$K$种宝石，对$F$条鱼的每一条只喂给它一块宝石。注意，因为$K$可能小于$F$，两条或更多的鱼可能会吞下同一种宝石。

随着时间的流逝，有些鱼吃掉了别的鱼。一条鱼能够吃掉另一条鱼，当且仅当它的长度至少是被吃掉的鱼的两倍($A$ 能吃掉$B$ 当且仅当$L_A \geq 2L_B$)。没有规则说明一条鱼何时会吃掉另一条鱼。有的鱼可能会一条接一条地吃掉几条小鱼，而有的鱼可能不吃别的鱼，即使它们有能力吃。当一条鱼吃掉一条小鱼时，它的身长并不改变，但是小鱼腹中的宝石会完好无损地进到大鱼腹中。

据Scheherazade说，如果你能够找到那个湖，你会被准许捕捉一条鱼，并且得到鱼腹中的宝石。你很想试试运气，但是在出发前很想知道捉到一条鱼可能会有多少种不同的宝石组合。

写一个程序，给定每条鱼的长度以及其最初吞食的宝石的种类，找出鱼腹中宝石不同组合的数量对给定整数$M$取模的值。组合由每种宝石的数量定义，与宝石的排列顺序无关。同一类宝石中任意两块是没有区别的。 

## 说明/提示

### 限制

有总计70分的测试数据，其中$K$不超过$7,000$。在这些测试数据中，有总计25分的测试数据的$K$不超过$20$。

对于所有的测试数据，$1 \leq F \leq 500,000$，$1 \leq K \leq F$，$2 \leq M \leq 30,000$，$1 \leq L_X \leq 1,000,000,000$。

### 样例说明

有 $11$ 种可能的组合，所以你需要输出$4$，也就是$11$ 模 $7$。这些可能的组合是: $[1] [1,2] [1,2,3] [1,2,3,3] [1,3] [1,3,3] [2] [2,3] [2,3,3] [3]$ 和 $[3,3]$。(对每一种组合, 我们列出其所包含的宝石。 例如，$[2,3,3]$ 包含一块$2$型宝石和两块$3$型宝石)

这些组合可以由下述方式获得:

$[1]$: 如果你在第二条鱼 (或第四条) 吃掉任何其它鱼之前捕捉到它。

$[1,2]$: 如果第二条鱼吃掉第一条鱼, 它就会有一块 $1$ 型宝石(它在初始时刻吞下的) 和一块2型宝石 (从第一条鱼腹中得到的)。

$[1,2,3]$: 一种可能的途径是: 第四条鱼吃掉第一条鱼，然后第三条鱼又吃掉它。如果你此时捉到了第三条鱼，那它腹中就有这三种宝石一样一块

$[1,2,3,3]$: 第四条鱼吃掉第一条鱼，第三条鱼吃掉第四条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。

$[1,3]$: 第三条鱼吃掉第四条鱼，你捉到了第三条鱼。

$[1,3,3]$: 第三条鱼吃掉第五条鱼，第三条鱼吃掉第四条鱼，你捉到了第三条鱼。

$[2]$: 你捉到了第一条鱼。

$[2,3]$: 第三条鱼吃掉第一条鱼，你捉到了第三条鱼

$[2,3,3]$: 第三条鱼吃掉第一条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。

$[3]$: 你捉到了第三条鱼。

$[3,3]$: 第三条鱼吃掉第五条鱼，你捉到了第三条鱼。

## 样例 #1

### 输入

```
5
3
7
2 2
5 1
8 3
4 1
2 3
```

### 输出

```
4```

# 题解

## 作者：wu3412790 (赞：17)

一道经典的组合计数题，当时在IOI现场只有Huacheng Yu一人AC。

但实际上这题并不算特别难，一名对组合数学熟练的选手完全有能力独立解决。

题目中每条鱼有长度，和一种独特的宝石。考虑按照鱼的长度排序，注意到如果两条鱼所用有的宝石是一样的，那么长的那条鱼可能拥有的宝石组合将覆盖所有短的鱼的组合，因为短的能吃的长的都能吃。

这样一来，对每种宝石只需要考虑拥有它的"最长鱼"就可以了。考虑按“最长鱼”的长度从小到大枚举每种宝石，计算方案。为了避免重复，我们对于同一组合，希望只在其最后一次出现的时候加入它。这样一来，问题转化为，对于一类宝石，它的“最长鱼”肚子里可能吐出哪些宝石组合，并且这些宝石组合不会被后面更长的“最长鱼”拥有。注意到，如果一条"最长鱼"$a$的长度小于另一条”最长鱼"$b$的长度，那么在所有颜色的宝石中，$a$只有在$c_a$和$c_b$这两种颜色的宝石上，可能吐出$b$所不能吐出的数量，这是因为对于其它颜色的宝石，由于$b$比$a$长，$b$能吃的一定大于等于$a$能吃的条数，但$a$自己有一个$c_a$颜色的宝石，它肚子里还可以不包含颜色为$c_b$的宝石，这两种情况下，$a$的这些组合是$b$没有的。

总结一下，对于一条"最长鱼" $a$，有如下两种选择方法：

 (1) 在$c_a$中选出尽量多的宝石，即吃下所有能吃的颜色为$c_a$的鱼。同时如果后面的某条"最长鱼" $b$能包含更多的$c_a$，就在 $c_b$这个颜色吃$0$条来避免被$b$碾压。对于其它的颜色，数量随意，只需要把方案数乘起来。
 
 (2) 在$c_a$中选少于最大可能的条数，对所有长度大于a的其它最长鱼，在对应的颜色下选$0$个防止被碾压。
 
 扫描过程中需要维护一些连续段的乘积，使用一个线段树就行。时间复杂度$O(F\log F).$
 
 总结：对于计数题来说，“没事多排序”是亘古不变的真理。本题最重要的一步就是将所有宝石的颜色按照“最长鱼”的长度排序，一旦排好序一切都会变的非常有规律，后面发现用线段树维护方案数的方案是很自然的。
 
 ```cpp
#pragma GCC optimize("O3")
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int const N=5e5+1;
struct fish{
	int len,col,pre;
	friend bool operator <(fish x, fish y){
		return x.len<y.len;
	}
}f[N];
int n,m,p,t[N*8],h[N],last[N],w[N],q[N],now[N],v[N],ans;
void add(int pos, int l, int r, int x){
    if (l==r){ 
        t[x]=(v[pos]+1) % p;
        return;
    }
    int mid=((l+r)>>1);
    if (pos<=mid) add(pos,l,mid,x*2);
    if (pos>mid) add(pos,mid+1,r,x*2+1);
    t[x]=(t[x*2]*t[x*2+1]) % p;
}
int ask(int a, int b, int l, int r, int x){
	if (a>b) return 1;
	if (a<=l && r<=b) return t[x];
	int ans=1,mid=((l+r)>>1);
	if (a<=mid) ans=ans*ask(a,b,l,mid,x*2);
	if (b>mid) ans=ans*ask(a,b,mid+1,r,x*2+1);
	return ans % p;
}
int find(int x){
	int l=1,r=m;
    while (r-l>1){
    	int mid=((l+r)>>1);
        if (f[w[mid]].len>=x) r=mid; else l=mid+1;
    }
    if (f[w[l]].len>=x) return l;
    if (f[w[r]].len>=x) return r;
    return m+1;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>p;
	for (int i=1;i<=n;i++)
		cin>>f[i].len>>f[i].col;
	sort(f+1,f+n+1);
	for (int i=n;i>=1;i--){
		if (!h[f[i].col]) h[f[i].col]=i;
		f[i].pre=last[f[i].col];
		last[f[i].col]=i;
	}
	m=0;
	for (int i=1;i<=n;i++)
		if (h[f[i].col]==i) w[q[f[i].col]=++m]=i;
	for (int i=1;i<=8*m;i++)
		t[i]=1;
	for (int i=1,j=1;i<=m;i++){
		while (f[j].len*2<=f[w[i]].len){
			int s=f[j].col;
			v[q[s]]++;
            now[s]=j++;
            add(q[s],1,m,1);
		}
		int k,d=ask(1,i-1,1,m,1);
		if (!now[f[w[i]].col]) k=last[f[w[i]].col]; else k=f[now[f[w[i]].col]].pre;
    	if (!k) k=m+1; else k=find(f[k].len*2);
        ans=(ans+d*ask(i+1,k-1,1,m,1)+d*(v[i] % p)) % p;
	}
	cout<<ans<<endl; 
	return 0;
} 
```


---

## 作者：by_chance (赞：7)

[Link](https://www.luogu.com.cn/problem/P4684)

这个题关键在于如何不重不漏地计数。

首先注意到，我们不需要考虑一条鱼在吃掉别的鱼之后又被吃掉的。因为我们只关心最终那条鱼体内的宝石，所以直接让它一个个吃过来就可以了。

把所有鱼按照长度从小到大排序。选定最终抓到的鱼为 $i$，则它体内的宝石（除自身外）是一段前缀的子集。容易求出对每个 $i$ 可选的前缀 $[1,f_i]$。

为了避免重复，一方面，对每种宝石的鱼，我们只考虑抓到其中长度最长的那个。显然抓住长度较短的情形完全被包含。另一方面，对两种不同宝石的鱼，设鱼 $i,j(i \le j)$ 体内的宝石分别为 A,B。此时当然有 $f_i \le f_j$。那么，如果没有在 $[1,f_i]$ 取所有的 A，又取了至少一个 B，这种情况就被包含在抓住 $j$ 的情况里了。固定 $i$，对所有的 $j$ 都要满足上述条件，所以可行的情况就有两种：

- 取了所有的 A。此时还不能保证不重复，因为 $[1,f_j]$ 中 A 的个数可能严格大于 $[1,f_i]$。注意到 $f$ 单调不减，所以可以二分出第一个满足上述严格大于的位置，这个位置之后的宝石都不能取。
- 没有取 B。即 $i$ 之后的所有宝石都不取。

一个可重集的子集数目是它所有元素出现次数加一的乘积。上面两条限制都是针对某些元素的取的次数的，所以直接在乘法中修改对应的项即可。

具体实现时，我们不难维护出一段前缀的各种宝石出现次数。一个小技巧是将宝石重新编号，按照最后一次出现位置排序。这样两种情形都可以化为一段区间的乘积，在线段树上修改查询即可。

被卡了一点空间。

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
using namespace std;
const int N=5e5+5;
int n,k,t,P,f[N],cnt[N],ans;set<int> S[N];
struct node{int l,c;}a[N];
bool operator <(const node&a,const node&b){return a.l<b.l;}
#define ls p<<1
#define rs p<<1|1
#define mid ((l+r)>>1)
int val[N<<2];
void build(int p,int l,int r){
    if(l==r){val[p]=cnt[l]%P;return;}
    build(ls,l,mid);build(rs,mid+1,r);
    val[p]=val[ls]*val[rs]%P;
}
void modify(int p,int l,int r,int x,int v){
    if(l==r){val[p]=v%P;return;}
    if(x<=mid)modify(ls,l,mid,x,v);
    else modify(rs,mid+1,r,x,v);
    val[p]=val[ls]*val[rs]%P;
}
int query(int p,int l,int r,int L,int R){
    if(l>=L&&r<=R)return val[p];
    if(R<=mid)return query(ls,l,mid,L,R);
    if(L>mid)return query(rs,mid+1,r,L,R);
    return query(ls,l,mid,L,R)*query(rs,mid+1,r,L,R)%P;
}
#undef ls
#undef rs
#undef mid
int main(){
    // freopen("fish.in","r",stdin);
    // freopen("fish.out","w",stdout);
    scanf("%d%d%d",&n,&k,&P);
    for(int i=1;i<=n;i++)scanf("%d%d",&a[i].l,&a[i].c);
    sort(a+1,a+n+1);t=k;
    for(int i=n;i>=1;i--){if(!cnt[a[i].c])cnt[a[i].c]=t--;a[i].c=cnt[a[i].c];}
    memset(cnt,0,sizeof(cnt));
    for(int i=1;i<=n;i++)cnt[a[i].c]++,S[a[i].c].insert(i);
    for(int i=1;i<=k;i++)cnt[i]++;build(1,1,k);
    // for(int i=1;i<=n;i++)printf("  %d %d\n",a[i].l,a[i].c);
    for(int i=n,p=n,c;i>=1;i--)
        if(*--S[c=a[i].c].end()==i){
            while(p&&a[p].l*2>a[i].l){
                int x=a[p].c;--cnt[x];
                modify(1,1,k,x,cnt[x]);--p;
            }f[c]=p;
            int x=*S[c].upper_bound(f[c]),L=c,R=k,pos=k;
            while(L<=R){
                int mid=L+R>>1;
                if(f[mid]<x)pos=mid,L=mid+1;
                else R=mid-1;
            }
            // printf("%d %d %d %d %d\n",c,pos,cnt[1],cnt[2],cnt[3]);
            ans=(ans+(c==1?1:query(1,1,k,1,c-1))*
                (((c==pos?1:query(1,1,k,c+1,pos))+(cnt[c]-1))%P)%P)%P;
        }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：ssstare (赞：1)

首先我们把鱼按照长度从小到大排个序. 这样每条鱼能吃的集合是个前缀.

记排序后的鱼的下标为 $1, 2, .., n$, 对第 $i$ 条鱼有长度 $len_i$ 及宝石类型 $t_i$.

定义

$S'(i)=\{j | 2 \times len_j \leq len_i, j\lt i\}$,

$S(i)=S'(i)\cup \{i\}$,

$cnt'(i, type)=|\{j | j \in S'(i), t_j=type\}|$,

$cnt(i, type)=|\{j | j \in S(i), t_j=type\}|=cnt'(i,type) + [t_i=type]$,

那么有

$S'(1) \subseteq S'(2) \subseteq ... \subseteq S'(n-1) \subseteq S'(n)$.

也就是说如果没有 $\cup \{i\}$ 这么个玩意儿，我们直接拿 $S'(n)$ 算就完事儿了.

回到题目, 对于每个 $i$ 来说, 由 $S(i)$ 生成的宝石集合里必须至少有一个宝石 $t_i$.

且若有 $j \lt i$ 且 $t_j = t_i$, 那么我们在算答案的时候就不用考虑 $S(j)$.

我们考虑在每个 $i$ 算出有多少种宝石组合, 满足这些组合不会被更大的 $j$ 所选出. 实际上这只有两类:

第一类: 对于所有满足 $i \lt j$ 的 $j$, 宝石 $t_j$ 一个都不选.由于我们在 $i$ 被强制要求选了一个宝石 $t_i$, 容易知道这样的宝石集合是不会跟后面撞车的.

第二类: 把宝石 $t_i$ 的数量拉满. 由 $S'(i) \subseteq S'(j)$ 我们知道有 $cnt'(i,t_i) \leq cnt'(j, t_i)$. 那么我们可以找到这样一个区间 $[i+1,r]$ 满足对于其中所有的 $j$ 有: $cnt(i,t_i) \gt cnt(j,t_i)$ 和 $cnt'(i,t_i)=cnt'(j,t_i)$. 对于这个区间, 我们在拉满宝石 $t_i$ 算答案的时候可以不用考虑第一类的限制.

由于任意模数不支持求逆, 我们需要一棵线段树来支持单点更新区间求乘积.


```cpp
{    
  {
    std::vector<int> cnt(k);
    for (int i = 0; i < n; ++i) {
      cnt[a[i].second]++;
    }
    SegmentTree sgt(k);
    for (int i = 0; i < k; ++i) {
      sgt.update(i, cnt[i] + 1);
    }
    int result = 0;
    std::vector<int> last(k, k);
    std::vector<bool> del(k);
    for (int i = n - 1, j = n - 1; i >= 0; --i) if (!del[a[i].second]) {
      del[a[i].second] = true;
      while (j >= 0 && a[j].first * 2 > a[i].first) {
        --cnt[a[j].second];
        last[a[j].second] = a[i].second;
        sgt.update(a[j].second, cnt[a[j].second] + 1);
        --j;
      }
      (result += sgt.query(0, a[i].second).val) %= mod;
      (result += mod - sgt.query(0, a[i].second - 1).val) %= mod;
      (result += sgt.query(0, a[i].second - 1).val * 1LL * sgt.query(a[i].second + 1, last[a[i].second]).val % mod) %= mod;
      // DUMP(i, a[i].second, j, result, last, cnt);
    }
    printf("%d\n", result);
  }
}
```


---


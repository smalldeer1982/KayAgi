# [PA 2013] Raper

## 题目描述

你需要生产 $k$ 张光盘。每张光盘都要经过两道工序：先在 A 工厂进行挤压，再送到 B 工厂涂上反光层。

你知道每天 A、B 工厂分别加工一张光盘的花费。你现在有 $n$ 天时间，每天可以先送一张光盘到 A 工厂（或者不送），然后再送一张已经在 A 工厂加工过的光盘到 B 工厂（或者不送），每家工厂一天只能对一张光盘进行操作，同一张光盘在一天内生产出来是允许的。我们假定将未加工的或半成品的光盘保存起来不需要费用。

求生产出 $k$ 张光盘的最小花费。

## 说明/提示

保证 $1 \leqslant k \leqslant n \leqslant 5 \times 10^5,$ $1 \leqslant  a_i, b_i \leqslant 10^9$。

注：添加了 2 组 Hack 数据，如未通过将扣除 3 分。

## 样例 #1

### 输入

```
8 4
3 8 7 9 9 4 6 8
2 5 9 4 3 8 9 1```

### 输出

```
32```

# 题解

## 作者：shadowice1984 (赞：23)

c老师好强啊……

~~线段树是不可能线段树的，这辈子都不可能线段树的~~

这里介绍一个代码量极短但是很垃圾的$O(nlog^2n)$做法

______________________

## 前置芝士:dp凸优化/带权二分/wqs二分

蛤？都8120年了还有人不会wqs二分？

不会的出门左转[林克卡特树](https://www.luogu.org/problemnew/show/P4383)包教包会

# 本题题解

我们令$f(k)$表示恰好生成$k$个光盘的最优解，本着大胆猜想绝不求证的想法，我们猜测答案是个凸函数

~~(从加了hack数据还是没有叉掉这个做法这点就能说明他是凸的了)~~

好了现在既然答案是个凸函数我们又想要求$f(k)$

那么我们自然是定义一个函数$G(n,t)=f(n)+nt$然后求出当$n$取何值时$G(n,t)$有最小值，如果有多个$n$满足条件，我们选择最小的那个$n$

上面的过程等价于使用一条斜率恰好为$t$的直线去切我们的凸函数，最后求出一个切点的过程，由于答案函数是凸的因此我们知道道对于每一个点$(n,f(n))$，总是存在一个斜率$t$使得斜率为t的直线在这个凸包的切点是$(n,f(n))$,并且随着$t$的单调增加，最优决策点n的位置单调左移，这就启示我们二分斜率t然后找切点

具体来讲我们需要找到最小的t使得最优决策点的横坐标**小于等于**k，小于等于是因为这个直线可能会和凸包会有多个交点，按照算法流程我们选择的决策点将可能会小于k而不是等于

如此这般二分我们将会得到一条直线$y=tx+b$，将x=k带入即可出解，因为这个直线过$(k,f(k))$这个点

____________________

好了现在的问题是如何求出$G(n,t)=f(n)+nt$的最大值

换句话讲，没了必须选择k个的限制而是改为每一张光盘有t的额外代价(请注意这个代价必须是负的)求最小代价

那么此时我们就可以使用带反悔的贪心~~(有人叫模拟费用流?笑)~~来解决这个问题了


我们考从左到右扫一遍序列，依次插入$a,b$这样的好处就是当我们插入每一个$b$的时候之前的所有$a$都可以和他匹配

我们使用一个小根堆来存储所有的$a$点，当我们插入一个$b$的时候，从堆里拽出来一个$a$尝试和他匹配

如果匹配之后会使答案变大，那么我们直接忽略这个b,什么也不做

如果匹配之后会是答案变小，我们将a和b匹配,但是注意到后面可能会有更加优秀的b来替换这组匹配使得答案变得更加优秀，那么此时我们可以将a的权值更改为-b-t,然后接着将a丢到堆里，

这样如果我们拽出来一个已经被匹配的a，那么我们给答案加上a的权值的时候之前所匹配的b就被自动撤销了

当然啦你需要维护下拽出来的a到底是已经配过b的还是没配过b的，以便我们统计到底出现了几对匹配

顺便说一句刚才的算法丢到有k限制的时候是错的，因为我们需要考虑匹配的对数是否超过k了，如果超过k了我们就需要扔一对最大的匹配，而堆是没办法处理这样的问题的

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=5*1e5+10;typedef long long ll;
struct data
{
	ll val;int tp;
	friend bool operator <(data a,data b)//存储权值以及是否被匹配过 
	{return (a.val==b.val)?a.tp>b.tp:a.val>b.val;}
};priority_queue <data> pq;int n;int k;ll a[N];ll b[N];ll nk;
inline ll jud(int& cnt)//计算函数 
{
	cnt=0;ll ret=0;
	for(int i=1;i<=n;i++)
	{
		pq.push((data){a[i],1});data nw=pq.top();ll del=b[i]+nw.val+nk;
		if(del<0)ret+=del,cnt+=nw.tp,pq.pop(),pq.push((data){-nk-b[i],0});
	}priority_queue <data> emp;swap(emp,pq);return ret;
}int main()
{
	scanf("%d%d",&n,&k);for(int i=1;i<=n;i++)scanf("%lld",&a[i]);int tmp;
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);ll l=-(1LL<<31);ll r=0;
	while(l!=r)//二分 
	{
		ll mid=(l+r-1)/2;nk=mid;int cnt=0;
		jud(cnt);if(cnt<=k)r=mid;else l=mid+1;
	}nk=l;printf("%lld",jud(tmp)-(ll)l*k);return 0;//拜拜程序~ 
}
```












---

## 作者：pldzy (赞：22)

线段树模拟费用流。

[LG传送门](https://www.luogu.com.cn/problem/P4694)。


## Solution

### Part 1 

根据题面，显然想到此题是费用流。建图方式亦是显然：
- $S\rightarrow i$，流量为 $1$，费用为 $a_i$；
- $i\rightarrow T_0$，流量为 $1$，费用为 $b_i$；
- $i\rightarrow i+1$，流量为 $\inf$，费用为 $0$；
- $T_0\rightarrow T_1$，流量为 $k$，费用为 $0$。

观察数据，知道直接跑费用流肯定会起飞。所以我们选择模拟费用流。

### Part 2

不难抓住题目条件的特性：第 $i$ 天经过第一次处理后的东西，第二次处理的时间必定在时刻 $i$ 之后，不能在它之前。这种特性与**括号序列**所具有的是相同的。

具体地，记“第一次处理”为 $+1$（等价于左括号），“第二次处理”为 $-1$（等价于右括号）。并现有一前缀数组 $S$，其长度为 $n$。若第 $i$ 天选择第一次处理，则 $S_i + 1$；若选择第二次处理，则 $S_i-1$。与括号序列同理，这个前缀数组 $S$ 的特点是：**每一项权值都是非负数**，且 $S_n=0$。

进而，我们现在的目标转化为：**在括号序列合法的前提下，每次放入一左一右两个括号，重复 $k$ 次，并使最终总代价最少**。每次一并放两个括号，一正一负，不会改变 $S_n$ 的值，$S_n$ 一直为 $0$。

### Part 3

假设将左括号放在第 $i$ 位，右括号放在第 $j$ 位。不难得出，每次放置只有两种情况：$i\leq j$ 或 $i > j$。形象些，即是 `..(..)..` 与 `..)..(..`。

最直接的方式就是线段树动态维护两个序列的最小值，每次取最小值即可。这种方式对第一种情况是适用的。

但是因为括号序列前缀数组的特殊限制，对于第二种情况，需要满足前提条件：对于 $x \in [j, i)$，$S_x > 0$。

而我们使用线段树动态维护的，是对于区间 $[l,r]$，代价最小且合法的两个数对，分别对应第一种情况以及第二种情况里的 $i$ 和 $j$。此次代价即是两种情况中代价较小的一个。

如何维护第二种情况？如果直接维护权值是否为 $0$，未免太过麻烦，可能超时。所以我们不妨转化一下，使 $a_0=b_0=\inf$，那么对于 $S_0$ 而言，必定恒为 $0$。故我们线段树维护的范围是 $[0,n]$，且 $t_1.min$（即整个 $S$ 序列的最小值）恒为 $0$。此时，满足第二种情况限制的数对，它所构成的区间，只需要保证，该区间内每个权值都**严格大于整个区间的最小值**。相比前者而言，它显然好维护些。

故，对于某一区间 $[l,r]$，我们需要维护：
- $ma$ 与 $mb$：满足下标在 $[l,r]$ 范围内，$a[ma]$ 与 $b[mb]$ 分别是各自序列中的最小值；
- $la$ 与 $lb$：仅针对和辅助情况二，$la$ 是区间内 $a$ 值最小的位置，满足区间前缀 $[l,la)$ 符合“每个权值都严格大于区间最小值”；$lb$ 是区间内 $b$ 值最小的位置，满足区间后缀 $[lb,r]$ 符合要求；
- $mn$：下标在 $[l,r]$ 内，$S$ 序列中的项的最小值；
- $va$：当前区间对于情况一的答案（一数对）；
- $vb$：当前区间对于情况二的答案（一数对，且考虑情况二的特殊限制）；
- $vc$：当前区间对于情况二的临时答案（一数对，且不考虑情况二的特殊限制）。

然后区间合并时，以上变量之间的合并差不多是基本的常见操作，$vb$ 的合并稍复杂，详析见代码注释。

### Part 4

时复 $\mathcal{\text{O}}(n+k\log n)$。

另：此做法可求出 $k\in [1,n]$ 时的任一答案。

## Code

内附有注释。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define ls (x<<1)
#define rs (x<<1|1)
const int maxn = 5e5 + 5, inf = 0x3f3f3f3f;
int n, k, a[maxn], b[maxn];
ll ans;
struct node{int x, y;};
struct tree{
	int ma, mb, la, lb, mn, tg;  
	node va, vb, vc;
}t[maxn << 2];
inline bool operator <(node x, node y){
	return a[x.x] + b[x.y] < a[y.x] + b[y.y];
} 
inline tree operator +(tree x, tree y){
	tree z; z.tg = 0;
	if(a[x.ma] < a[y.ma]) z.ma = x.ma; else z.ma = y.ma;
	if(b[x.mb] < b[y.mb]) z.mb = x.mb; else z.mb = y.mb;
	z.mn = min(x.mn, y.mn);//以上三者直接取最小 
	z.va = min((node){x.ma, y.mb}, min(x.va, y.va));
	z.vc = min((node){y.ma, x.mb}, min(x.vc, y.vc));//在没有特殊限制时，两区间合并可产生新的、符合条件的数对 
	z.vb = min(x.vb, y.vb);
	if(x.mn > y.mn){
	//此时，x所代表的区间内的所有数 都严格大于合并后区间最小值，所以x区间内的数可直接取最小 
		z.vb = min(z.vb, min((node){y.la, x.mb}, x.vc));
		z.la = (a[x.ma] < a[y.la] ? x.ma : y.la), z.lb = y.lb;
		/*z.la=y.la等价于这个前缀直接涵盖了x区间，并与y区间的la前缀接上了*/
	} else if(y.mn > x.mn){
		z.vb = min(z.vb, min((node){y.ma, x.lb}, y.vc));
		z.la = x.la, z.lb = (b[y.mb] < b[x.lb] ? y.mb : x.lb);
	} else{ z.la = x.la, z.lb = y.lb;
		z.vb = min(z.vb, (node){y.la, x.lb});//直接合并前后缀 
	} return z;
}

inline void psd(int x){
	if(!t[x].tg) return;
	t[ls].tg += t[x].tg, t[ls].mn += t[x].tg;
	t[rs].tg += t[x].tg, t[rs].mn += t[x].tg;
	t[x].tg = 0;
}
inline void psp(int x){ t[x] = t[ls] + t[rs];}
inline void build(int x, int l, int r){
	if(l == r) return 
		t[x] = (tree){l, l, l, 0, 0, 0, (node){l, l}, (node){0, 0}, (node){l, l}}, void();
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r), psp(x);
}
inline void updt1(int x, int l, int r, int p){
	if(l == r) return;
	int mid = l + r >> 1; psd(x);
	if(p <= mid) updt1(ls, l, mid, p); else updt1(rs, mid + 1, r, p);
	psp(x);
}
inline void updt2(int x, int l, int r, int L, int R, int p){
	if(l > R or L > r) return;
	if(L <= l and r <= R) {t[x].tg += p, t[x].mn += p; return;}
	int mid = (l + r) >> 1; psd(x);
	updt2(ls, l, mid, L, R, p), updt2(rs, mid + 1, r, L, R, p);
	psp(x);
}

int main(){
	scanf("%d%d", &n, &k); 
	rep(i, 1, n) scanf("%d", &a[i]); rep(i, 1, n) scanf("%d", &b[i]);
	a[0] = b[0] = inf; build(1, 0, n);
	while(k--){ int x, y, p;
		if(t[1].va < t[1].vb) x = t[1].va.x, y = t[1].va.y, p = 1;
		else x = t[1].vb.x, y = t[1].vb.y, p = -1;
		ans += a[x] + b[y]; a[x] = b[y] = inf;
		updt1(1, 0, n, x), updt1(1, 0, n, y);
		updt2(1, 0, n, min(x, y), max(x, y) - 1, p);
	} printf("%lld\n", ans);
	return 0;
} 
```
## Reference

- [CF802O April Fools' Problem (hard) 题解](https://www.luogu.com.cn/blog/Criticism/solution-cf802o)，by [KaisuoShutong](https://www.luogu.com.cn/user/106182).
- [题解 CF802O April Fools' Problem](https://www.luogu.com.cn/blog/gxy001/solution-cf802o), by [gxy001](https://www.luogu.com.cn/user/55707).
- [模拟费用流小记](https://www.luogu.com.cn/blog/command-block/mu-ni-fei-yong-liu-xiao-ji)，by [command_block](https://www.luogu.com.cn/user/58705).

---

## 作者：yspm (赞：14)

[博客园食用效果更佳](https://www.cnblogs.com/yspm/p/15084703.html)

线段树维护模拟费用流！

这篇题解旨在给 $\rm{Clarisls}$  的线段树写一个详细点的解释，原博客参考[https://www.cnblogs.com/clrs97/p/5124895.html](https://www.cnblogs.com/clrs97/p/5124895.html)

思考如果将本题数据范围缩小，放到一个费用流能过的复杂度

一种可行的建图就是建立一虚拟源点限制流量，同时建一排虚点 $p_1,p_2\dots p_n$

虚源点向虚点连流量 $1$ 费用 $a_i$ 的边，虚点向汇点连 $(1,b_i)$ 的边，源点向虚源点连 $(0,k)$ 的边，虚点直接从前往后连 $(+\infty,0)$ 的边

剩下要做的是写一个 $EK$ 

既然可以使用费用流做，那么必然满足函数是下凸的，即每次选出来的点对的权值和单调 **不降**

同时一个比较经典的结论是选择 $k$ 个点对所得到的点集是选择 $k+1$ 对点所得到的点集的子集，但是匹配不一定相同，正确性是显然的
  
（然后把网络流建图扔掉）
  
考虑贪心选出最小的合法点对，那么问题本质上变成了最小的带权括号匹配，转化后维护序列所选择的左右括号前缀和，最后得到的序列需要满足任意前缀和非负

按照 $\rm{Clarisls}$ 的博客所写的定义：

- $mina/minb$ 表示区间里面 $a/b$ 数组最小值**所在的位置**

- $va$ 表示区间里面选择 $\rm{pos_a\le pos_b}$ 的最小合法方案

-  $vc$ 表示区间里面选择 $\rm{pos_a>pos_b}$ 的最小合法方案

-  $vb$ 表示区间里面选择 $\rm{pos_a>pos_b}$ 的最小合法方案，同时满足所选择的两点之间的前缀和的最小值大于区间里面前缀和的最小值

- $tag/mn$ 表示区间加法懒标记和区间前缀和最小值

- $\rm{alim}$ 表示满足 $[l,alim-1]$ 区间中前缀和最小值大于整个区间前缀和最小值的 $A$ 中值最小的一个

- $\rm{blim}$ 表示满足 $[blim,r]$ 区间中前缀和最小值大于整个区间前缀和最小值的 $B$ 中值最小的一个

**注意：$\rm{alim}$ 定义中区间是不到其本身位置的，但是 $\rm{blim} $ 中到了，所以最初建线段树时可以给 $\rm{alim}$ 赋值，但后者不能**

$\rm{push\_up}$ 的过程包括：

- 使用子区间信息直接更新：$\rm{mina,minb,mn,va,vb,vc}$

- 使用 `left->mina,right->minb` 更新 $va$

- 使用 `left->minb,right->mina` 更新 $vc$

以上根据含义，正确性显然，下述转移正确性耐人寻味，建议思考

- 对于 `left->mn>right->mn` 的情况
	
    因为左边的最小值大，所以 `left->vc` 可以更新 $vb$
    
    左边的 $\rm{minb/mina}$ 被解放，可以先后更新 $\rm{vb/alim}$
	
    注意因为是区间交叉时的信息更新，所以左边一定选 $\rm{B}$

- 对于 `left->mn<right->mn` 的情况
	
    右边的最小值大，那么 `right->vc` 可以更新 $vb$
    
    右边的 $\rm{mina/minb}$ 被解放，可以先后更新 $\rm{vb/blim}$
    
     仍然注意因为是区间交叉时的信息更新，右子区间选 $\rm{A}$
    
- 对于 `left->mn=right->mn` 的情况

	因为最小值在两边都能取到，只能用 `left->minb,right->mina` 更新 $vb/alim/blim$ 
    
最后，代码是最好的教程，可以配合食用

```cpp
inline void push_up(int p){
    #define ls p<<1 
    #define rs p<<1|1
    va[p]=min(min(va[p<<1],va[p<<1|1]),node(mna[p<<1],mnb[p<<1|1])); 
    vc[p]=min(min(vc[p<<1],vc[p<<1|1]),node(mna[p<<1|1],mnb[p<<1]));
    vb[p]=min(vb[p<<1],vb[p<<1|1]);
    if(a[mna[p<<1]]<a[mna[p<<1|1]]) mna[p]=mna[p<<1]; 
    else mna[p]=mna[p<<1|1];
    if(b[mnb[p<<1]]<b[mnb[p<<1|1]]) mnb[p]=mnb[p<<1]; 
    else mnb[p]=mnb[p<<1|1];
    if(mn[ls]>mn[rs]){
        vb[p]=min(vb[p],node(alim[rs],mnb[ls]));
        vb[p]=min(vb[p],vc[ls]);
        if(a[mna[p<<1]]>a[alim[p<<1|1]]) alim[p]=alim[p<<1|1]; else alim[p]=mna[p<<1];
        blim[p]=blim[p<<1|1];
    }else if(mn[ls]<mn[rs]){
        vb[p]=min(vb[p],node(mna[rs],blim[ls]));
        vb[p]=min(vb[p],vc[rs]);
        if(b[blim[p<<1]]>b[mnb[p<<1|1]]) blim[p]=mnb[rs]; else blim[p]=blim[ls];
        alim[p]=alim[p<<1];
    }else{
        vb[p]=min(vb[p],node(alim[rs],blim[ls]));
        alim[p]=alim[ls]; blim[p]=blim[rs];
    } mn[p]=min(mn[p<<1],mn[p<<1|1]); return ;
    #undef ls
    #undef rs
}
```

实现的时候：

- 变量维护大多是位置，所以取 $\min$ 要注意

- 可以直接设 $A[0]=B[0]=+\infty$ ，会方便一些

诶你这不是线段树加速贪心吗？咋跟模拟费用流扯上关系了？

对于选择的括号形如 $()$ 时，是在虚点一排流经了 $[l,r]$ 的点

而如果在这之间选择了 $)($ 的括号就是将 $[pl,pr]$ 流了反向边，现在的流经情况是 $S\to l\to pl\to T$ 和 $S\to pr\to r\to T$

也就是把 $[pl,pr]$ 之间的流量逼了回去

---

## 作者：樱雪喵 (赞：11)

题意可以转化为把 $k$ 对 $a_i$ 和 $b_j$ 配对，要求每对的 $i\le j$，最小化总代价。  
设 $f(i)$ 表示共生产 $i$ 个光盘的最小代价。发现 $f$ 是一个下凸函数，可以使用 wqs 二分。

这里我们给每次配对操作一个附加权值 $-t$，考虑在没有配对数限制的情况下怎么求答案。  
从小到大枚举 $i$，将 $a_i$ 加入候选，考虑 $b_i$ 的配对情况。这样做的好处是所有在候选集合内的 $a_i$ 都满足先后顺序的限制。  
对 $a_i$ 维护一个小根堆。那么 $b_i$ 分为三种情况：
- 和以前没配对过的 $a_j$ 配对；
- 把一个以前配对过的 $a_j$ 拆开，再让它和 $b_i$ 配对；
- 如果上面两种不能让答案更优，不配对。

对于第二种情况，我们可以反悔贪心，在 $a_j$ 匹配后，把它对应的 $-b_i+t$ 放进小根堆。这样在下次匹配时，$-b_j+t+b_i-t$ 就消掉了上一次对答案的已有贡献。

这里需要同时维护堆中的每个元素是否被匹配过，以求出匹配数。  

根据二分的实现方式，如果斜率恰好切到了凸壳的一条边上，我们希望在代价相同的情况下找到匹配数最少的切点。也就是说在贪心匹配时，要注意在代价相同的情况下优先匹配已经匹配过的点，否则无法通过 hack。  
然后就是注意 wqs 二分经典错误，减掉附加权值的贡献应该用 $k$ 而不是实际选出来的匹配数。  

时间复杂度 $O(n\log V\log n)$。

```cpp
#define int long long
const int N=5e5+5;
int n,k,a[N],b[N];
#define pii pair<int,int>
#define fi first
#define se second
priority_queue<pii,vector<pii>,greater<pii> >q;
int ans;
il int check(int t)
{
    while(!q.empty()) q.pop();
    ans=0; int cnt=0;
    for(int i=1;i<=n;i++)
    {
        q.push(pii(a[i],0));
        if(b[i]+q.top().fi-t>0) continue;
        int now=q.top().fi;
        ans+=q.top().fi+b[i]-t;
        if(!q.top().se) cnt++;
        q.pop(); q.push(pii(-b[i]+t,-1));
    }
    return cnt;
}
signed main()
{
    n=read(),k=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=n;i++) b[i]=read();
    int l=0,r=2e9;
    while(l<r)
    {
        int mid=(l+r+1)>>1;
        if(check(mid)<=k) l=mid;
        else r=mid-1;
    }
    check(l);
    printf("%lld\n",ans+k*l);
    return 0;
}
```

---

## 作者：lhm_ (赞：7)

首先考虑题目的性质，不难发现光盘的花费是一个凸函数。当生产 $0$ 张光盘时，其花费为 $0$，随着光盘生产数的增加，最优情况肯定是先选择工厂便宜的时刻，所以花费会增长越来越快，因此其为一个下凸的凸函数。

采用 $WQS$ 二分来优化掉生产出 $k$ 张光盘的限制，然后可以通过二分图带权匹配来判定。每个 $b$ 向其之前所有的 $a$ 连边，表示可以进行匹配来生产光盘，当匹配的权值为正时就停止匹配，用匹配数来判定二分。

但是这样复杂度无法接受，于是采用模拟费用流的方法，用一个小根堆来实现反悔操作，堆中为 $a$ 的权值，每次 $b$ 和最小的 $a$ 进行匹配。但是这样匹配不一定是最优，因此就像费用流一样，将 $b$ 的权值取负再加入堆中，表示可以有别的 $b$ 来代替它。

判定时二分的权值加在 $b$ 上，和 $b$ 一同取负即可，同时还需注意每次匹配是产生新匹配还是代替之前的匹配。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 500010
#define inf 10000000000
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,k,ans,cnt,sum,l=-inf,r=inf;
ll a[maxn],b[maxn];
struct node
{
    ll val;
    bool tag;
};
bool operator <(const node &a,const node &b)
{
    return a.val>b.val;
}
bool check(ll x)
{
    priority_queue<node> q;
    cnt=sum=0;
    for(int i=1;i<=n;++i)
    {
        q.push((node){a[i],0});
        if(q.top().val+b[i]+x<=0)
        {
            sum+=q.top().val+b[i]+x;
            if(!q.top().tag) cnt++;
            q.pop(),q.push((node){-b[i]-x,1});
        }
    }
    return cnt>=k;
}
int main()
{
    read(n),read(k);
    for(int i=1;i<=n;++i) read(a[i]);
    for(int i=1;i<=n;++i) read(b[i]);
    while(l<=r)
    {
        ll mid=(l+r)>>1;
        if(check(mid)) ans=mid,l=mid+1;
        else r=mid-1;
    }
    check(ans),printf("%lld",sum-ans*k);
    return 0;
}
```

---

## 作者：ღꦿ࿐ (赞：5)

费用流建模显然。

$s\to i (1,a_i),i\to i+1(+\infty,0),i\to t(1,b_i)$，流量为 $k$ 的最小费用。

因为决策都在一条链上，增广路的形态较少，考虑模拟费用流。
 
每一次增广一定选择了一对 $(a_i,b_j)$ 其中 $i\leq j$ 或 $i > j$ 且 $[i,j)$ 中这一段中均有大于 $0$ 的反向流量。

考虑分别维护两种信息。

第一种显然直接维护 $a,b$ 最值及其位置即可。

第二种较为复杂，展开叙述：


发现维护区间中  是否有 $0$ 这种相关的信息是不好维护的，因为涉及加法和值域，发现区间最小值是 $0$，经典地，把维护区间 $0$ 的信息考虑成维护区间最小值的信息：我们考虑维护区间内部不经过流量最小值的对，这样就能够在进行流量加法的时候方便地打 tag。

具体做法如下： 

维护

区间内最小 $a,b$ 及它们的坐标 $ma,mb$

区间内最小价值的 $vab=a_i+b_i(i\leq j)$ 。

区间内最小价值的 $vba1=b_i + a_j(i<j)$。

区间内最小价值的 $vba2=b_i + a_j(i<j\text{区间内 j 到 i 的流量均不为最小值})$。

上方这个信息无法简单的合并，合并的时候考虑最小值来源于 左，右 或分别来源于左右。

首先无论如何子区间的最值是可以选择的。

如果最小值来源于左边，那么右边任意 $a$ 都可以用用于更新答案，而左边可以更新答案的是一段后缀里面的 $b$，且这段后缀里面没有出现最值。

如果最小值来源于右边，那么左边任意 $b$ 都可以用用于更新答案，而右边可以更新答案的是一段前缀里面的 $b$。

如果两边都有最小值，那么更新答案的一定是一段左边的后缀 $b$ 和一段右边的前缀 $a$。

那么我们再考虑维护这个可行的前缀和后缀：

令 $p$ 表示区间里的一段前缀满足 $[l,p)$ 中的边流量都不达到区间最小值的前缀。

$pre$ 表示 $[l,p]$ 的最小值。

令 $s$ 表示区间里的一段前缀满足 $[s,r]$ 中的边流量都不达到区间最小值的前缀。

$suf$ 表示 $[s,r]$ 的最小值。

（区间开闭不同是因为上方可行条件是左闭右开的，此类细节需要注意）

这样就可以合并信息了。 仍然是根据最小值的来源，$pre$ 和 $suf$ 分别有可能是某个子区间的 $pre$ 和 $suf$ 或者就是某个子区间的 $a$，$b$ 的最小值。


push up 代码：

```cpp
struct node {
    int Smn ;
    ca ma,pre; cb mb,suf;
    pr ab,ba,b_a;
    //ma mb 最小值
    // pre suf suf：不含S最小值的后缀里的最小a pre：不含最小值的前缀及其后方第一个的最小b
    // ab ：一组ab，ba：不限制 的ba，b_a 限制 的 ba
} tr[N * 3];
#define ls x<<1
#define rs x<<1|1
#define mid ((l+r)>>1)
void up(int x) {
    tr[x].Smn = min(tr[ls].Smn , tr[rs].Smn) ;
    tr[x].ma = min(tr[ls].ma , tr[rs].ma) ;
    tr[x].mb = min(tr[ls].mb , tr[rs].mb) ;
    tr[x].ab = min({tr[ls].ab , tr[rs].ab , O(tr[ls].ma , tr[rs].mb)});
    tr[x].ba = min({tr[ls].ba , tr[rs].ba , O(tr[rs].ma , tr[ls].mb)});
    if(tr[x].Smn != tr[ls].Smn) {
        // 最值仅来源于右儿子
        // if(x == 7) cout << tr[ls].suf.v << "qwq\n";
        tr[x].b_a = min({tr[ls].ba , tr[rs].b_a , O(tr[rs].pre , tr[ls].mb)});
        tr[x].pre = min(tr[ls].ma , tr[rs].pre) ;
        tr[x].suf = tr[rs].suf;
    } else 
    if(tr[x].Smn != tr[rs].Smn) {
        // 最值仅来源于左儿子
        tr[x].b_a = min({tr[ls].b_a , tr[rs].ba , O(tr[rs].ma , tr[ls].suf)});
        tr[x].suf = min(tr[ls].suf , tr[rs].mb) ;
        tr[x].pre = tr[ls].pre ;
    } else {
        // 两边都有最值 
        tr[x].b_a = min({tr[ls].b_a , tr[rs].b_a , O(tr[rs].pre , tr[ls].suf)});
        tr[x].pre = tr[ls].pre ;
        tr[x].suf = tr[rs].suf ;
    }  
}
```

[full code](https://codeforces.com/contest/802/submission/212482777)

---

## 作者：CmsMartin (赞：4)

[「$\mathcal{Link}$」](http://www.cmsblog.top/archives/p4694pa2013raper)

## 题目描述

你需要生产 $k$ 张光盘。每张光盘都要经过两道工序：先在 A 工厂进行挤压，再送到 B 工厂涂上反光层。

你知道每天 A、B 工厂分别加工一张光盘的花费。你现在有 $n$ 天时间，每天可以先送一张光盘到 A 工厂（或者不送），然后再送一张已经在 A 工厂加工过的光盘到 B 工厂（或者不送），每家工厂一天只能对一张光盘进行操作，同一张光盘在一天内生产出来是允许的。我们假定将未加工的或半成品的光盘保存起来不需要费用。

求生产出 $k$ 张光盘的最小花费。$1 \leqslant k \leqslant n \leqslant 5 \times 10^5,$ $1 \leqslant  a_i, b_i \leqslant 10^9$。

##  思路

题目很像一个匹配问题，首先考虑费用流。有一个显然的建图方式。

+ $S$ 向每一个 A 工厂连接一条容量为 $1$，费用为 $a_i$。
+ 每一个 A 工厂向 $S$ 连接一条容量为 $1$，费用为 $b_i$ 。
+ 对于第 $i$ 个 A 工厂，向所有的 $j \ge i$ 的 B 工厂连一条容量为 $1$，费用为 $0$ 的边。

考虑限制源点的流量，对于找增广路的过程费用是下凸的。所以我们考虑 wqs 二分。现在我们已经二分一个斜率，每次匹配都需要减去这个斜率。下文假设这个斜率是 $x$。

如何判断。匹配可以分为三种：

+ 如果 $b_i$ 和之前的任何一个 $a_i$ 都会使花费增加，则不匹配。
+ 和之前没匹配的 $a_i$ 匹配。
+ 拆开前面的一组进行匹配。

这是个反悔贪心的过程。使用堆维护即可。具体的，在完成一对匹配后弹出 $a_i$ 插入 $x - b_i$，这样反悔的时候可以消除之前的 $b$ 的影响。

总时间复杂度 $\mathcal{O}(n \log^2 n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
using ll = long long;

ll n, k, a[N], b[N];
ll Ans;

ll check(ll mid) {
    Ans = 0; int cnt = 0;
    priority_queue<pair<ll, bool>, vector<pair<ll, bool> >, greater<pair<ll, bool> > > q;
    for (int i = 1; i <= n; i++) {
        q.emplace(a[i], true);
        pair<ll, bool> x = q.top();
        if (x.first + b[i] - mid > 0) continue; 
        q.pop();
        Ans += x.first + b[i] - mid;
        cnt += (x.second == true);
        q.emplace(mid - b[i], false);
    }
    return cnt;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    ll l  =0, r = 1e15, mid, res;
    while (l <= r) {
        mid = l + r >> 1;
        if (check(mid) < k) res = mid, l = mid + 1;
        else r = mid - 1;
    }
    check(mid);
    cout << Ans + mid * k << endl;
    return 0;
}
```



---

## 作者：strcmp (赞：4)

**题目大意：** 给定每天将一个光盘送去工厂 A 或者工厂 B 的花费，每个光盘必须先经过工厂 A 再到工厂 B 才算是生产出一个光盘，一家工厂一天只能加工一个光盘，且同一张光盘在一天内生产出来是允许的。求生产 $k$ 张光盘的最小花费。

------------

有一个很显然的费用流模型，定义超级源汇 $s,t$，将 $s$ 拆为 $s$ 和 $s'$。则连边：

- $s \to s'$，容量为 $k$，费用为 $0$。

- $\forall i,\,s' \to i$，容量为 $1$，费用为 $a_i$。

- $\forall i,\,i \to t$，容量为 $1$，费用为 $b_i$。

- $i < n,\, i \to i + 1$，容量为 $+\infty$，费用为 $0$。

很显然因为一般的 MCMF 算法是 $\Theta(nmf)$ 的，数据范围不支持我们直接跑费用流，实测您如果使用了费用流，会获得 52pts 的高分。

我们猜测下它的性质。对于样例来说，当 $k \in [1,\,8]$ 时，结果如下：

```
4 10 20 32 46 60 77 95
```

对它差分一下。

```
4 6 10 12 14 14 17 18
```

我们注意到它的差分单调不减，正好是一个凸函数。

实际上，依据 MCMF 算法的过程，每次增广之后增广路的费用和必然不减少，由此得到费用流的凸性。所以，设 $f(x)$ 为生产出 $x$ 张光盘所需要的花费，则花费关于 $x$ 是一个凸函数。

凸函数有什么好维护的方法呢？凸函数，恰好选 $k$ 个，正好是 wqs 二分适用的范围。

极为通俗的讲，wqs 二分就是对 $k$ 的选择作一个整体的惩罚，让我们尽量在惩罚后全局最优的情况下多选点或少选点，直到正好选到 $k$ 个。这本质是二分斜率用一条直线去切这个凸函数。

对于这题来讲，如果我们只是要求费用最小，那么肯定不生产任何光盘费用最小。但如果我们每次生产出一个光盘，就能有一个 $c$ 的奖励（这题中 $c$ 显然为负），那么我们的算法就会倾向于去生产一些光盘，直到这个惩罚/奖励 $c$ 恰到好处，让我们的算法正好生产出了 $k$ 个光盘，那么答案减去 $k \times c$ 就是正确的答案。

现在的问题是怎么让我们的算法能够求出在减去奖励的情况下，所花费的最小费用。

继续返回到那个被毙掉的费用流模型。（注意，由于 wqs 二分的处理，我们不需要再将 $s$ 连向 $s'$，且 $s \to i$ 的费用增加 $c$）

我们考虑倒序处理，枚举 $n$ 到 $1$ 并插入点。

![](https://cdn.luogu.com.cn/upload/image_hosting/8csvrc5z.png)

如图所示，橙点即为新插入的点，注意到，如果不需要走反向边，我们每次必然增广到满足 $b_i$ 最小的且还没有流满的边。于是我们可以用一个堆维护 $b_i$，设 $i$ 流向 $j$。记录 $i$ 有一个反向边（也是用堆维护），将 $b_j$ 弹出，减去奖励即可。

考虑走反向边的情况，我们可能有如下两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/60dtx5zy.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/edxsajew.png)

第一种是可能存在的，但我们可以证明第二种情况并不存在。因为看到 $t$ 到 $s$ 这条路径，也就是黄色细线标注起来的地方，它路径上的费用必然加起来是一个非负数，否则在匹配从左往右第四个结点时，我们必然不会增广它的反向路径。这时候我们还不如直接从 $s$ 走到 $t$。

现在我们可以维护第一种情况，这也可以装进堆里维护，每次从 $n$ 到 $1$ 让 $b_i$ 进堆，若匹配到的 $a_i$ 能使得总费用加上去不亏，则加上贡献，给堆里面装 $-a_i - c$，代表负权边即可。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 6e5 + 10;
struct node {
    ll v; int t;
    inline int operator<(node a) const { return v != a.v ? v > a.v : t < a.t; }
}c[maxn];
int n, k; ll a[maxn], b[maxn]; ll ans = 0;
inline int check(ll c) {
    priority_queue<node>q;
    ll cnt = 0; ans = 0;
    for (int i = n; i >= 1; i--) {
        q.push({ b[i] , 1 });
        if (a[i] + q.top().v + c <= 0) {
            ans += a[i] + q.top().v + c;
            if (q.top().t) ++cnt; q.pop();
            q.push({ -a[i] - c, 0 });
        }
    }
    return cnt >= k;
}
int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%lld", &b[i]);
    ll l = -1e16, r = 0, mid, real = 0;
    while (l <= r) {
        mid = l + r >> 1;
        if (check(mid)) real = mid, l = mid + 1;
        else r = mid - 1;
    }
    check(real);
    printf("%lld\n", ans - (ll)k * real);
    return 0;
}
```

---

## 作者：sqrtqwq (赞：2)

[problem](https://www.luogu.com.cn/problem/P4694) & [双倍经验](https://www.luogu.com.cn/problem/CF802O) & [三倍经验](https://www.luogu.com.cn/problem/CF802N)

------

这是一个取 $k$ 个物品的问题，然后我们发现它是一个凸函数，所以可以联想到 wqs 二分。

不会 wqs 二分的可以看 [这个](https://www.luogu.com/article/knpufhxe) 文章。

我们来考虑 check 怎么写。

每次我们往堆中加入 $a_i$，然后再考虑怎么配对 $b_i$。

那么有如下两种情况：

1. 和之前最小的 $a_x$ 配对，代价为 $a_x + b_i$。

2. 拆散原本的一对配对，然后再组合，那么代价就是 $(a_x + b_i) - (a_x - b_y) = -b_y + b_i$。

然后拿一个小根堆维护匹配的情况即可。有没有匹配的 $a_i$ 都要 push 进去。

---

## 作者：xfrvq (赞：2)

[【费用流】弱化版做法](https://www.luogu.com.cn/blog/_post/487050)。

备注：双倍经验 CF802O/弱化版 CF802N（直接费用流可过）。

结合这个要做 $x_0$ 道题的限制，考虑 $\tt wqs$ 二分。

---

我们设 $g(x)$ 为处理 $x$ 道题而非 $x_0$ 道的代价。

首先有 $g(0)=0$，然后它单调上升，它的导函数也是单调上升（下凸函数），这是 $\tt wqs$ 能使用的条件。

然后我们二分一个斜率 $k_0$，然后尝试计算 $f(x)=g(x)-k_0x$ 的最小值位置 $x_1$，然后看 $x_1$ 和 $x_0$ 的大小关系来判断答案会取在 $mid$ 的左还是右。

---

考虑 $f(x)=g(x)-k_0x$ 的意义是什么。做 $x$ 道题的代价减去 $x\times k_0$ 的代价，相当于做每道题的代价都减去 $k_0$。因为要 $f(x)$ 最大，相当于求“所有 $b_i\gets b_i-k_0$，最小代价是多少，此时做多少道题”。

因为要代价最小且减去 $k_0$ 后代价可能为负，我们自然而然认为把所有代价是负的题全都做了。

这个过程实现可以考虑贪心。我们制定这样一个策略：

1. 对于每一个 $b_i$ 找到 $\forall j\le i,\min\{a_j\}$。
2. 如果 $b_i+a_j\lt 0$，将其配对，并不允许“$a_j$ 再在后面的第 1 步中出现”。

当然实现可以考虑优先队列（小根堆），第一步就是 `top()`，第二步如果配对成功就是 `pop()`。

但是这种贪心存在不够优秀的情况。比如完成一组匹配时，为了达到最优抢走了另一组匹配唯一可选的点。

这种情况需要加一个反悔选项在优先队列里。考虑一组匹配带来 $a_j+b_i$ 的贡献，$a_j$ 此刻应该是有用的。我们考虑让 $a_j$ 和 $b_k$ 配，就等价于加上一个 $-b_i$ 和 $b_k$ 配的贡献。所以反悔的方法是在堆里加入 $-b_i$。

---

[双倍经验 CF 评测链接](https://codeforces.com/problemset/submission/802/188556789)。

然后有点问题。这个代码交到这里只有 $\tt97$，好像被 $\tt hack$ 数据弄挂了。

发现是这样的一个问题：对于二分出来的 $k_0,k_1=k_0+1$，有 $y_0=f(k_0)\lt x_0\lt y_1=f(k_1)$，原因是删若干个题代价是 $0$，我还真不知道该不该删，二分到最后甚至找不到一个 $y=x_0$。

那你就改写一下二分方式，弄一个答案到最后输出。

![](https://img-blog.csdnimg.cn/1fbd61a2a68349798c29012da8ee69d7.png)

---

## 作者：Purslane (赞：1)

# Solution

大概是我做过的第一道模拟费用流的题目？科技树太稀疏了 /ll

很容易发现，设 $f(k)$ 为恰好刻 $k$ 张光盘的最小费用。

那么显然有 $f(k+1) - f(k) \ge f(k) - f(k-1)$，否则，第 $k$ 张光盘的价格将比第 $k+1$ 张更大，这样会与“最小费用”的定义相矛盾。

于是 $f(k)$ 关于 $k$ 具有凸性，可以使用 wqs 二分将“恰好 $k$ 张”的问题转化为“不限制张数”的问题，不过这时候我们可以考虑把每个 $a_i$（其实 $b_i$ 也可以）减去 $k$。

考虑建立费用流模型。建立两个点集，分别表示 $\{a\}$ 和 $\{b\}$。对于 $1 \le i \le j \le n$，我们连上 $a_i$ 指向 $b_j$，容量为 $1$ 费用为 $0$ 的边。

源点向 $a_i$ 连容量为 $1$ 费用为 $a_i-k$ 的边。$b_i$ 向汇点连容量为  $1$ 费用为 $b_i$ 的边。

在这个网络上跑费用流是完全不现实的（如果使用后缀优化建图，复杂度也得是 $O(nmf) = O(n^3)$ 的。）。而且注意你求的其实是“最小费用任意流”，而并不是最小费用最大流，所以普通的网络流算法不能直接套用。

考虑模拟费用流，不断地加入 $b_i$ 向 $t$ 的边。这时候我们应该在残量网络上找到一条总边权是负的、从 $s$ 到 $t$ 的路或者一个简单的，从 $t$ 到 $t$ 的负环（从 $s$ 到 $s$ 也可以，但是你发现这样实际上不会对新加的边产生任何的影响，所以可以归纳的证明，这样的负环并不存在。不过你可能还会好奇能否找到一条 $s \to t \to s$ 的环，经过了你新加的边。但是考虑每一条 $s$ 到 $t$ 的路径都得是负的，否则不如不选这条路径；所以你这样会少加一个负数，不优，不如直接选上包含新加的边的负路径。）

于是可能存在的负环或者负路径只有两种（假设你加入 $b_i$）：

- $s \to a_j \to b_i \to t$，$j \le i$。

- $t \to b_j \to a_k \to b_i \to t$，其中原有的 $a_k$ 匹配了 $b_j$。

我们对这个负环或者负路径进行一次操作，实际效果是：

- 将 $b_i$ 与一个未匹配的 $a_j$ 匹配。

- 把之前一个匹配的 $b_j$ 换为 $b_i$。

直接使用反悔贪心维护即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10;
int n,k,a[MAXN],b[MAXN];
pair<int,int> solve(int del) {
	int cnt=0,tans=0;
	priority_queue<int> qa,qb;
	ffor(i,1,n) {
		qa.push(-a[i]+del);
		int val1=0,val2=0;
		if(!qa.empty()) val1=-qa.top()+b[i];
		if(!qb.empty()) val2=-qb.top()+b[i];
		if(min(val1,val2)>=0) continue ;
		if(val1<=val2) cnt++,qa.pop(),tans+=val1;	
		else qb.pop(),tans+=val2;
		qb.push(b[i]);
	}
	return {cnt,tans};
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k; ffor(i,1,n) cin>>a[i]; ffor(i,1,n) cin>>b[i];
	int ans=-1,l=0,r=2000000000;
	while(l<=r) {
		int mid=l+r>>1;
		auto pr=solve(mid);
		if(pr.first<=k) ans=pr.second+k*mid,l=mid+1;
		else r=mid-1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：LastKismet (赞：0)

# Sol
WQS 二分套反贪。

考虑如果没有光盘张数限制，那么就是一个经典的反贪问题（我知道一个都不选最优，请先忽略这一点……），在 $i$ 天的 A 工厂与 $j$ 天的 B 工厂加工的光盘将会产生 $a_i+b_j$ 的贡献，每次 $b$ 尝试贪心选最小的 $a$ 更新答案即可。如何反悔呢？选完一个 $b_j$ 后往堆里推一个 $-b_j$ 即可。这部分不理解建议先去学一下反悔贪心。

如何处理限制呢？很典型的 WQS 二分啊。记 $f_i$ 为造 $i$ 个光盘的代价，$(i,f_i)$ 显然是凸的，所以直接上 WQS 二分即可，通俗地理解就是二分生产一张光盘额外产生的价值。没了。

WQS 二分时有几个坑点，一个是典型的要处理好多点共线的情况，我这里设定要最小化选的个数，那么对于两个代价相同的选择，就要优先选不会更加点数的选项（也就是优先反悔）。如果要最大化选的个数同理。最后消除 $\Delta$ 影响时记得使用给出的 $k$，如果不理解可以参考[这里的 WQS 二分讲解](https://www.cnblogs.com/LastKismet/p/18961415)。

# Code
```cpp
int n,k;
ll a[N],b[N];

inline pli check(ll dlt){
    ll res=0;int cnt=0;
    lrheap<pli> pq;
    rep(i,1,n){
        pq.push({a[i],1});
        if(dlt+b[i]+pq.top().fir<0){
            res+=dlt+b[i]+pq.top().fir;
            cnt+=pq.top().sec;
            pq.pop();
            pq.push({-dlt-b[i],0});
        }
    }
    return {res,cnt};
}

inline void Main(){
    read(n,k);
    rep(i,1,n)read(a[i]);
    rep(i,1,n)read(b[i]);
    ll l=-2e9,r=0;
    while(l<r){
        ll m=l+r>>1;
        if(check(m).sec<=k)r=m;
        else l=m+1;
    }
    put(check(l).fir-k*l);
}
```

---

## 作者：SunsetSamsara (赞：0)

## P4694 [PA2013] Raper

### 题意

有 $k$ 个物品需要加工，可以进行第一个、第二个加工步骤，第 $i$ 天进行第一个操作的代价是 $a_i$，进行第二个操作的代价是 $b_i$。每天可以且仅可以同时对一个物品进行第一个操作并对一个物品（可以相同）进行第二个操作。必须先进行第一个操作再进行第二个，问 $n$ 个物品加工完所需的最小代价。

### 标签

模拟费用流，wqs 二分。

### 做法

首先考虑朴素地建费用流。从源点向 $s$ 连边，容量为 $k$，代价为 $0$，表示有 $n$ 个物品；$s$ 向 $i$ 连边，容量为 $1$，代价为 $a_i$，表示进行第一个操作；从 $i$ 向汇点连边，容量为 $1$，代价为 $b_i$，表示进行第二个操作；再从 $i$ 向 $i + 1$ 连边，容量为 $+\infty$，代价为 $0$，表示将进行过第一个操作但未进行过第二个操作的物品保留到 $i + 1$ 天。

注意到可以建模为模拟费用流，所以费用关于流量具有凸性，即答案关于选取的物品数量是凸的，可以使用 wqs 二分。于是二分惩罚，对 $b$ 加上惩罚，就不需要考虑 $k$  的限制了。问题就变成了选择点使得代价最小。

考虑模拟费用流，回到原来费用流的图，从 $1$ 到 $n$ 添加点，在新增一个点 $i$ 时发现有如下几种情况：

+ 增广路 $s \rightarrow j \rightarrow i \rightarrow t$：表示对于一个物品在第 $j$ 天进行操作一，第 $i$ 天进行操作二。考虑惩罚 $c$，增广路对答案的贡献是 $b_i - c + v$，其中 $v$ 表示最小的未进行操作的 $a$。

+ 负环 $t \rightarrow j \rightarrow i \rightarrow t$：表示将一个原本在第 $j$ 天进行操作二的物品延缓到在第 $i$ 天进行操作二。考虑惩罚 $c$，增广路对答案的贡献是 $(b_i - c) - (v - c)$，其中 $v$ 表示最小的进行了操作的 $b$。

+ 负环 $s \rightarrow j \rightarrow i \rightarrow s$：表示将一个原本在第 $j$ 天进行操作一的物品延缓到在第 $i$ 天进行操作一。但是，既然能有负环，说明 $i - 1$ 向 $i$ 的边有流量，而新加入第 $i$ 个点时，如果 $i - 1$ 向 $i$ 的边有流量就说明第 $i$ 个点或之后有一个被匹配了的 $b$。因为当前第 $i$ 个点是最后一个点，因此只能是点 $i$ 的 $b$ 被匹配了，转化为第一种增广路的情况。

把需要维护的最小贡献（未进行操作的 $a$、进行了操作的 $b - c$）扔进小根堆里，每次取出最小的贡献，检查取出点数与 $k$ 的大小关系进行 wqs 二分即可。

### 代码

```cpp
#include <time.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <map>
#include <set>
typedef long long lld;
using namespace std;
const int N = 500010;
int k, n;
lld a[N], b[N];
struct node {
	lld val;
	int cnt;
};
inline bool operator < (const node &x, const node &y) {
	return x.val > y.val;
}
inline pair<lld, int> calc(lld t) {
	lld sum = 0;
	int cnt = 0;
	priority_queue<node> pq;
	for (int i = 1; i <= n; ++ i) {
		pq.push(node{a[i], 1});
		node u = pq.top();
		if (b[i] + u.val < t) {
			sum += b[i] - t + u.val;
			cnt += u.cnt;
			pq.pop();
			pq.push(node{-b[i] + t, 0});
		}
	}
//	printf("%lld: %d\n", t, cnt);
	return make_pair(sum, cnt);
}
int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; ++ i) scanf("%lld", a + i);
	for (int i = 1; i <= n; ++ i) scanf("%lld", b + i);
	lld l = -0x3f3f3f3f3f3fll, r = 0x3f3f3f3f3f3fll, mid;
	lld ans = 0x3f3f3f3f3f3f3f3fll;
	pair<lld, int> res;
	for (; l < r; ) {
		mid = (l + r + 1) >> 1;
		res = calc(mid);
		if (res.second > k) r = mid - 1;
		else l = mid, ans = min(ans, res.first);
	}
	printf("%lld\n", ans + r * k);
}
```

---


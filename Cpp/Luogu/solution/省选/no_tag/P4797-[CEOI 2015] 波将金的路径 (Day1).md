# [CEOI 2015] 波将金的路径 (Day1)

## 题目描述



**译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day1 T1「[Potemkin cycle](https://ceoi2015.fi.muni.cz/day1/eng/day1task1-eng.pdf)」**

**简要题意** $\,$ 给一张无向图，$|V|=N,$ $|E|=R$。请找一条简单路径，设该路径的点集为 $V'$，要求：$|V'| \ge 4$，且 $V'$ 的导出子图只含该路径本身（也就是一条链）。

---

波将金公爵的领土可以视作一张无向图，他要求你找到一条路线，经过的结点以序列 $s_1,\dots,s_m$表示，且满足以下要求：

 - $m \geq 4$

- 经过的每个结点互不相同（即对于所有$i \neq j$满足$s_i \neq s_j$）

- 对于 $i = 1,\dots,m - 1$，满足 $s_i$ 与 $s_{i + 1}$ 直接连接，且 $s_m$ 与 $s_1$ 直接连接。

- 序列中的结点没有其他的边（即对于所有 $i < j$，使得 $j \neq i + 1$ 且 $i \neq 1$ 或者是 $j \neq m$，结点 $s_i$ 和 $s_j$ 之间没有边）。

## 说明/提示

$N$ 与 $R$ 的上限如下表所示：

|数据点|$1-3$|$4-5$|$6-7$|$8-10$|
|-|:-:|:-:|:-:|:-:|
|$N$ 的上限|$10$|$100$|$300$|$1\ 000$|
|$R$ 的上限|$45$|$1\ 000$|$20\ 000$|$100\ 000$|

## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
4 3
5 2
4 5```

### 输出

```
2 3 4 5```

## 样例 #2

### 输入

```
4 5
1 2
2 3
3 4
4 1
1 3```

### 输出

```
no```

# 题解

## 作者：liuzhongrui (赞：2)

## 前言
很明显，一道图论题，我在拿了 $61$ 分后看了下[~~封禁~~大佬](https://www.luogu.com.cn/record/115851897)的代码，茅塞顿开，分享一下我的收获与理解。


## 思路

* 首先，我们需要构建图的邻接表表示。根据输入的边信息，我们可以构建一个邻接表，其中每个节点表示为一个邻接列表，包含与该节点相邻的节点。

* 接下来，我们使用深度优先搜索来搜索一条满足条件的路径。我们从任意一个节点开始，使用 DFS 遍历图中的节点，并记录下当前路径上的节点顺序。在遍历过程中，我们需要满足以下条件：

		1. 当前路径上的节点数量至少为四。
		2. 当前路径上的节点顺序与题目要求一致。
		3. 当前路径上的节点之间存在边连接。
        
* 如果找到满足条件的路径，我们将其输出；否则，输出 ```no```。

## 实现
使用 Tarjan 算法进行深度优先搜索，找出所有被访问过的节点，并记录下这些节点的最低入度，使用广度优先搜索，从指定的节点开始，找到所有与该节点相连的节点，并记录下这些节点的编号。

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mp make_pair
#define inf 1e9
#define pii pair<int,int>
const int mod=1e9+7,N=200005,M=1003;
int read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
void write(int x) {
	if(x<0)x=-x,putchar('-');
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
struct st {
	int v,id;
	st() {} st(int A,int B) {
		v=A,id=B;
	}
};
int n,m,cnt;
vector<st>G[M];
vector<int>V[N];
int b[M][M];
int sta[N],top;
int col[N],color;
int dfn[N],low[N],tot;
int eu[N],ev[N];
int Sha;
void Tarjan(int x) {
	dfn[x]=low[x]=++tot;
	sta[++top]=x;
	for(auto y:V[x]) {
		if(!dfn[y]) {
			Tarjan(y);
			low[x]=min(low[x],low[y]);
		} else if(!col[y])low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]) {
		if(sta[top]!=x)Sha=x;
		col[x]=1;
		while(sta[top]!=x)col[sta[top]]=1,top--;
		top--;
	}
}
vector<int>Ans;
int pre[N];
void bfs(int s) {
	queue<int>Q;
	Q.push(s);
	pre[s]=-1;
	while(!Q.empty()) {
		int x=Q.front();
		Q.pop();
		for(auto y:V[x]) {
			if(y==pre[x])continue;
			if(!pre[y]) {
				pre[y]=x;
				Q.push(y);
			} else if(y==s) {
				int now=x;
				while(now>0) {
					Ans.push_back(ev[now]);
					now=pre[now];
				}
				for(auto t:Ans)write(t),putchar(' ');
				exit(0);
			}
		}
	}
}
signed main() {
	n=read(),m=read();
	for(int i=1; i<=m; i++) {
		int x=read(),y=read();
		b[x][y]=b[y][x]=1;
		G[x].push_back(st(y,i)),G[y].push_back(st(x,i+m));
		eu[i]=x,ev[i]=y;
		eu[i+m]=y,ev[i+m]=x;
	}
	for(int i=1; i<=n; i++) {
		for(auto x:G[i]) {
			for(auto y:G[x.v]) {
				if(b[i][y.v]||y.v==i)continue;
				V[x.id].push_back(y.id);
			}
		}
	}
	for(int i=1; i<=2*m; i++)if(!dfn[i])Tarjan(i);
	if(!Sha)puts("no");
	else bfs(Sha);
	return 0;
}
```


---

## 作者：sususy (赞：0)

把无向边 $(u,v)$ 变成两条有向边 $u\to v$ 和 $v\to u$，之后，对每条边在新图上建立一个点，边 $u\to v$ 和边 $v\to w$ 在新图上的对应点有连边，当且仅当原图中不存在边 $(u,w)$。

这样，新图上的环和原图上满足「环上点的导出子图中不包含三元环」的环一一对应，因为原图中的三元环 $u\to v\to w\to u$ 的三条边在新图上对应的点之间都没有连边。

只需要找到新图上不包含其他环的一个环，因为它在原图上也不包含三元环，所以它一定合法。找不到则无解。

如何找这个环：按 dfs 的顺序考虑新图上每个点 $u$，如果 $u$ 的出边有返祖边，只需找到这些返祖边连向的祖先中深度最深的祖先 $v$，那么环 $v\to\cdots\to u\to v$ 在新图上一定不包含其他环（如果它包含其他环，那么这个环已经被 $u$ 的某个祖先找到）。注意应该先找 $u$ 的返祖边，再遍历 $u$ 的子树。

时间复杂度为 $\mathcal O(nm)$。

注意在洛谷上提交时不能输出换行，否则 `spj` 会输出 `wrong output format Unexpected end of file - int32 expected`。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e3 + 8, M = 1e5 + 8;
int head[N], nxt[M * 2], ver[M * 2], tot = 1;
bool g[N][N];
vector<int> edge[M * 2];
int dep[M * 2], fat[M * 2];
bool ins[M * 2];

void add(int u, int v)
{ nxt[++tot] = head[u], ver[tot] = v, head[u] = tot; }

void dfs(int u, int fa)
{
	dep[u] = dep[fa] + 1;
	fat[u] = fa;
	ins[u] = true;
	int w = 0;
	for(int v : edge[u])
		if(v != fa && ins[v] && dep[v] > dep[w])
			w = v;
	if(w)
	{
		for(int v = u; ; v = fat[v])
		{
			printf("%d ", ver[v]);
			if(v == w)
				break;
		}
		// puts("");
		exit(0);
	}
	for(int v : edge[u])
		if(!dep[v])
			dfs(v, u);
	ins[u] = false;
}

int main()
{
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i = 1, u, v; i <= m; i++)
	{
		scanf("%d%d", &u, &v);
		g[u][v] = g[v][u] = true;
		add(u, v), add(v, u);
	}
	for(int v = 1; v <= n; v++)
	{
		for(int i = head[v]; i; i = nxt[i])
			for(int j = nxt[i]; j; j = nxt[j])
			{
				const int u = ver[i], w = ver[j];
				if(!g[u][w])
					edge[i ^ 1].push_back(j), edge[j ^ 1].push_back(i);
			}
	}
	for(int i = 2; i <= tot; i++)
		if(!dep[i])
			dfs(i, 0);
	puts("no");
	return 0;
}
```

---


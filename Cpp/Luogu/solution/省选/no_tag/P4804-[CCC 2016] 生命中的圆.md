# [CCC 2016] 生命中的圆

## 题目描述

**译自 [CCC2016](https://cemc.math.uwaterloo.ca/contests/computing/2016/index.html) Senior T5「[Circle of Life](https://cemc.math.uwaterloo.ca/contests/computing/2016/stage%201/seniorEn.pdf)」**

> 也许你听说过康威生命游戏（Conway's Game of Life）。康威生命游戏适用于方格组成的矩阵。但它可以产生十分复杂的结构。在这道题目中，我们将使用简化版的生命游戏来虐你。

这个游戏是 0 人游戏，换句话说，只要给定初始条件，这个游戏就能自己进行下去。

将一个圆环分为 $N$ 段，将这 $N$ 段顺时针依次编为 $1,\dots,N$ 号。每一段要么是活的（以 `1` 表示），要么是死的（以 `0` 表示）。

游戏会进行 $T$ 轮「变化」。如果一个方格**恰好**有一个相邻的方格在这次变化中存活，那么该方格会在下次变化中存活。否则，该方格会死亡。

给定圆环的初始状态，求经过 $T$ 次变化之后的状态。

## 说明/提示

#### 样例解释 1
方格 $1$ 和 $N - 1$ 和 $N$ 相邻，因此在一次变化后仍存活。

#### 样例解释 2
一次变化后，状态为 ` 00011`。

两次变化后，状态为 ` 10111`。

对于 $\frac{1}{15}$ 的数据，$N \le 15,T \le 15$。

对于另外的 $\frac{6}{15}$ 的数据，$N \le 15$。

对于另外的 $\frac{4}{15}$ 的数据，$N \le 4000,T \le 10\ 000\ 000$。

注意对于所有的数据，你需要使用 64 位整数。

## 样例 #1

### 输入

```
7 1
0000001```

### 输出

```
1000010```

## 样例 #2

### 输入

```
5 3
01011```

### 输出

```
10100```

# 题解

## 作者：Ebola (赞：26)

**其实做法是和楼下本质上一样的，但本篇题解利用了异或运算使得结论的猜想与证明更加自然**

题目中的条件其实就是说：$f_{i,j}=f_{i-1,j-1}\oplus f_{i-1,j+1}$，其中$\oplus$表示异或

不难推出结论：$f_{i,j}=f_{i-2^k,j-2^k}\oplus f_{i-2^k,j+2^k},\quad k\in\mathbb{N}$。数学归纳法证明如下：

1. 当$k=0$时，这就是题目给出的条件
2. 当$k>0$时，假设结论对于$k-1$成立，则有：$f_{i,j}=f_{i-2^{k-1},j-2^{k-1}}\oplus f_{i-2^{k-1},j+2^{k-1}}=(f_{i-2^{k},j-2^{k}}\oplus f_{i-2^{k},j})\oplus(f_{i-2^{k},j}\oplus f_{i-2^{k},j+2^k})=f_{i-2^k,j-2^k}\oplus f_{i-2^k,j+2^k}$

于是问题就变得非常简单了。将$T$二进制分解，然后套用上述结论推$\log T$行就行了，复杂度$O(n\log T)$

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const int N=100010;
int n,f[2][N],p=0;
char s[N];
LL T;

int main()
{
    cin>>n>>T>>s;
    for(int i=0;i<n;i++) f[0][i]=s[i]-'0';
    for(int k=0;k<60;k++)if(T&(1ll<<k))
    {
        int pr=(1ll<<k)%n,pl=(n-pr)%n;
        for(int i=0;i<n;i++)
        {
            f[p^1][i]=f[p][pl]^f[p][pr];
            if(++pl>=n) pl-=n;
            if(++pr>=n) pr-=n;
        }
        p^=1;
    }
    for(int i=0;i<n;i++)
        printf("%d",f[p][i]);
    return 0;
}
```

---

## 作者：Imagine (赞：11)

## 题解

我们将原串下标从 $0$ 至 $n - 1$ 编号，用 $s_p$ 表示位置 $p$ 上的数字。首先有如下结论：

对于一个位置 $p$，若 $s_p$ 在经过 $c(c = 2^k)$ 次变换后为 $1$，当且仅当环上从 $p$ 开始左数第 $c$ 个位置上的数字与右数第 $c$ 个位置上的数字不相同。

证明如下：

- 首先，当 $c = 1$（即 $k = 0$）时显然成立。
- 考虑 $c = 2$（即 $k = 1$）。
    - 考虑 $p$ 左数 $2$ 个位置与右数 $2$ 个位置的值不相同，不妨设 $p = 2$，原串为 $0???1$。由于 $s_2$ 只有 $0/1$ 两种取值，换句话说，$s_2$ 必然与 $s_0, s_4$ 的其中一个相同，与另一个不相同，这样，我们在经过一次变换后得到的 $s_1$ 与 $s_3$ 也不相同，故 $2$ 次变换后 $s_2$ 必为 $1$。
    - 考虑 $p$ 左数 $2$ 个位置与右数 $2$ 个位置的值相同，也不妨设 $p = 2$，原串为 $0???0$。由于 $s_2$ 无论取 $0/1$，都必然为：要么和 $s_0, s_4$ 都相同，要么和 $s_0, s_4$ 都不相同，这样经过一次变换后得到的 $s_1$ 与 $s_3$ 一定相同，故 $2$ 次变换后 $s_2$ 必为 $0$。

  故 $c = 2$ 时结论成立。
- 注意在上述 $c = 2$ 的分析过程中，无论 $s_2$ 取何值，我们都能得到两个 $c = 1$ 的子问题，且若两端值不同，这两个子问题的结果也必然不同；若两端值相同，这两个子问题的结果也必然相同。由此可以推广得到：通过 $c = 2^k$，我们可以得到两个 $c = 2^{k - 1}$ 的子问题。这样当 $k$ 更大时，结论显然也是成立的。

有了该结论后，本题就可以通过将 $T$ 拆位后在 $O(n \log T)$ 的时间内解决了。

## 代码

~~~cpp
#include<bits/stdc++.h>

using namespace std;

#define rg register

typedef long long ll;

const int N = 1e5 + 10;

int n;
ll k;
char s[N], t[N];

inline void trans(int len) {
  for (rg int i = 0; i < n; ++i) {
    t[i] = '0' + (s[(i - len + n) % n] ^ s[(i + len) % n]);
  }
  memcpy(s, t, sizeof t);
}

int main() {
  scanf("%d%lld%s", &n, &k, s);
  for (rg int i = 60; ~i && k; --i) {
    if (k >> i & 1) {
      trans((1ll << i) % n);
      k -= 1ll << i;
    }
  }
  printf("%s\n", t);
  return 0;
}
~~~

---

## 作者：August_Light (赞：7)

# [P4804 [CCC2016] 生命中的圆](https://www.luogu.com.cn/problem/P4804) 题解

蒟蒻的第一篇题解。

## 题目分析

首先，暴力的时间复杂度为 $O(nT)$ ，一定需要优化。一代一代地迭代太慢，能否直接根据开始的局面得到最终局面或是想办法减少迭代的次数？

设原序列为 $a$，最终序列为 $b$。

首先，当 $T=1$ 时，对于任意最终状态的方格，在初始状态能够影响它的有两个方格，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/sv6u82wu.png)

图中的 $\oplus$ 符号表示[异或](https://oi-wiki.org/math/bit/)。

变为符号语言就是 $b_i=a_{i-1}\oplus a_{i+1}$。（本文中所有下标我们认为在 $\bmod n$ 意义下）

当 $T=2$ 时，对于任意最终状态的方格，在初始状态能够影响它的似乎有三个方格，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/p1an88qt.png)

也就是 $b_i=(a_{i-2}\oplus a_i)\oplus(a_i\oplus a_{i+2})=a_{i-2}\oplus a_{i+2}$。也就是说，其实 $b_i$ 的取值仅与两个格子有关。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/n9h0jcm8.png)

当 $T=4$ 时，套用上面的结论，可得下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/e0h2040t.png)

同理 $b_i=(a_{i-4}\oplus a_i)\oplus(a_i\oplus a_{i+4})=a_{i-4}\oplus a_{i+4}$。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6dbun8v7.png)

易得，当 $T=2^k,k\in\mathbb{N}$ 时，$b_i=(a_{i-2^k}\oplus a_i)\oplus(a_i\oplus a_{i+2^k})=a_{i-2^k}\oplus a_{i+2^k}$。也就是说，此时只需 $O(n)$ 的时间复杂度就可从 $a$ 推出 $b$。

再考虑一般情况。例如，当 $T=3$ 时，我们可以把 $T$ 分解为 $2^0+2^1$，先根据 $a$ 求出迭代 $2^0$ 代时得到的序列 $b$ ，再在这个序列的基础上（也就是把 $b$ 赋给 $a$ ）迭代 $2^1$ 代得到新的 $b$，这个就是最终答案。

从图中来看，就是先通过 $T=0$ 的序列求出 $T=2^0$ 的序列，再通过 $T=2^0$ 的序列求出 $T=2^0+2^1$ 的序列。

![](https://cdn.luogu.com.cn/upload/image_hosting/s19m0x8c.png)

对于任意 $T$，我们都能够将 $T$ 转化为二进制形式，比如，当 $T=100$ 时，$T=2^6+2^5+2^2$。此时只需计算 $4$ 代之后的结果，再在此基础上计算 $32$ 代之后的结果，再在此基础上计算 $64$ 代以后的结果。原本需要计算 $100$ 次，此时只要计算 $3$ 次。

在这种计算方法下，最坏的情况是当 $T=2^k-1,k\in\mathbb{N}$ 时，$T=1+2+2^2+2^3+\dots+2^{k-1}=\sum_{i=0}^{k-1}2^i=\sum_{i=0}^{\left\lceil\log_2T\right\rceil}2^i$，此时需要计算 $\left\lceil\log_2T\right\rceil$ 次，所以最坏时间复杂度为 $O(n\log T)$。

## 代码

实际在实现代码的时候，可以优化如下几个方面：
1. 每次计算中都把 $b$ 赋给 $a$ 比较浪费时间。

可以建立一个 $2\times N$ 的数组（记为 $s$），在第一轮计算中用 `s[0]` 代表 $a$，用 `s[1]` 代表 $b$，在第二轮计算中则用 `s[1]` 代表 $a$，用 `s[0]` 代表 $b$。用 `s[0]` 算出 `s[1]`，再用 `s[1]` 算出 `s[0]` 的值，以此类推一直反复。这样就省去了赋值的时间。

2. 每个格子都计算一次 $i-2^k$ 和 $i+2^k$ 比较浪费时间，所以可以进行如下操作：

设 $l_i=(i-2^k)\bmod n,r_i=(i+2^k)\bmod n$。

显然 $r_0=2^k\bmod n$，$l_0=(n-r_0)\bmod n$。

对于索引为 $i$ 的格子，$r_i=(r_{i-1}+1)\bmod n$，$l_i=(l_{i-1}+1)\bmod n$。递推即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL n, t, lb, l, r;
bool s[2][100005], flg;
string skip;
LL lowbit(LL x) //获取x的二进制表达式中最低位的1所对应的值
{
    return x & (-x);
}
int main()
{
    scanf("%lld%lld", &n, &t);
    getline(cin, skip); //读入第一行换行符后才可使用getchar
    for (int i = 0; i < n; i++)
    {
        s[0][i] = getchar() - '0'; //读入01序列
    }
    while (t)
    {
        lb = lowbit(t);
        t -= lb;
        r = lb % n;
        l = (n - r) % n;
        for (int i = 0; i < n; i++)
        {
            s[flg ^ 1][i] = s[flg][l] ^ s[flg][r];
            l++;
            if (l >= n)
                l = 0;
            r++;
            if (r >= n)
                r = 0;
        }
        flg ^= 1; //在01之间切换
    }
    for (int i = 0; i < n; i++)
    {
        printf("%d", s[flg][i]);
    }
    return 0;
}
```

---

## 作者：星星与辰 (赞：4)

## 题意

给一个 $ 0|1 $ 序列 $ A $，每一次变化会将原序列 $ A $ 上的元素 $ A_i $ 变为 $ A_{i - 1}\bigoplus A_{i + 1} $（每一个元素的更改同时进行互不影响）。

## 思路

看到异或，因为其本质实际上是不进位加法，于是就联想到加法，然后发现如果把原来变化换成加法然后在把奇数看成 $ 1 $，偶数看成 $ 0 $，这两实质上是一样的，并且每一位数字的值的贡献只会给两个相邻的元素，并且自己不受自己影响~~然后再通过打表发现寻找每一个 $ 1 $ 最终能影响什么 [打表程序（附图，浅显易懂）](https://www.luogu.com.cn/paste/sw0kx528)~~ 。

考虑一个位置上如果有 $ 1 $ 会影响什么，因为异或或加法是符合结合律的，所以可以通过扩展得到整个数列会影响什么。

感性地理解后，我们可以发现当只有一个 $ 1 $ 的时候，并把异或运算变为加法运算时，整个序列的结构与[杨辉三角](https://baijiahao.baidu.com/s?id=1607063654204393620)相似，未经过更改时，初始序列在第 $ 1 $ 层，整个数列每经过第 $i$ 次操作其实就像是从杨辉三角的第 $ i + 1 $ 层变为第 $ i + 2 $ 层，并且更换奇数（即 $ 1 $ 的位置的奇偶性）。

事实上这样的类似杨辉三角结构的三角形叫做[谢尔宾斯基三角形](https://cn.mathigon.org/course/fractals/sierpinski)。

如果整个序列是个谢尔宾斯基三角形，那么就会有一个性质，谢尔宾斯基三角形的第 $ 2^i $ 层上的数全是 $ 1 $，此在第 $ 2^i + 1 $ 层时会发现，这时候会发现只有两个数字会为 $ 1 $（两个被更改为 $ 1 $ 的位置距离原来的 $ 1 $ 的距离为 $ 2^i $）~~然后比赛时就傻瞪着这个结论坐了两小时不知道干什么~~。

![](https://pic3.zhimg.com/80/v2-646bcd3eff9aad3f18b0d8842d09f956_720w.webp)

发现了这个性质后，希望如果 $ k $ 正好为 $ 2 $ 的次幂的形式就好做了，为这样的话序列上的每一个 $ 1 $ 只需要考虑对序列中两个其他位置的影响。为每一次变化都是一样的，么就想到了把 $ k $ 次操作分开来考虑。

实际上这时做法就很明显了，了简化操作，我们可以对变化总数 $ k $ 变成多个二次幂次的变化分别依次进行的形式，$ k = 2^{q_1} + 2^{q_2} + 2^{q_3} + \cdots + 2^{q_{m-1}} + 2^{q_m} $，我们发现这样操作次数就从原来的 $ O ( k ) $ 次化简为 $ O ( \log k ) $ 次，这样的话因为每一次整个序列最多存在 $ n $ 个 $ 1 $，每次都模拟每一个 $ 1 $ 怎样影响别的位置，复杂度都是 $ O ( n \log k ) $ 次，就是 $ 6 \times 10^5 $ 左右的量级，这个复杂度是对的。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[500001],b[500001];
char s[500001];
int main() {
	int n;
	long long k;
	scanf("%d%lld%s",&n,&k,s+1);
	for(int i=1; i<=n; ++i) {
		if(s[i]=='1') {
			a[i]=1;
		} else a[i]=0;
	}
	//a数组存储当代的情况 
	long long ch=1;
	while(k>=ch) {
		if(k&ch) {
			//每一次操作时用b数组模拟下一代，操作结束时再将b数组的值重新赋给a 
			for(int i=1; i<=n; ++i)b[i]=0;
			for(int i=1; i<=n; ++i) {
				if(!a[i])continue;
				b[((i-ch)%n+n-1)%n+1]^=a[i];
				b[(i+ch-1)%n+1]^=a[i];
			}
			for(int i=1; i<=n; ++i)a[i]=b[i];
		}
		ch<<=1;
	}
	for(int i=1; i<=n; ++i) {
		if(a[i])putchar('1');
		else putchar('0');
	}
	return 0;
}
```

---

## 作者：gghack_Nythix (赞：3)

## 前言：

选了几个题和同学打了一场比赛，这个题就在其中。

## 分析：

首先你可以通过暴力模拟获得 12pts。这个应该都会。

然后你可能会想到记忆化一下局面，因为这个玩意看上去很容易陷入循环。记忆化之后，如果重复，直接算最终状态即可。到此有 48pts。

继续思考，发现可以用动态规划求出某一轮的某个点的生死：设 $f_{i,j}$ 表示第 $i$ 轮 $j$ 号点的状态，易得 $f_{i,j}=f_{i-1,j-1} \oplus f_{i-1,j+1}$。

然后这个东西看上去可以展开一下（因为有异或，可能可以消掉一些项），然后展开：

$f_{i-1,j-1} \oplus f_{i-1,j+1}=(f_{i-2,j-2} \oplus f_{i-2,j})\oplus(f_{i-1,j} \oplus f_{i-1,j+2})=f_{i-2,j-2} \oplus f_{i-2,j+2}$

事实上，如果你尝试将后面的部分继续展开，你会得到一张废掉的草稿纸和一个规律：

$$
f_{i,j}=f_{i-2^k,j-2^k}\oplus f_{i-2^k,j+2^k}
$$

（注意一下，这里的 $j \pm 2^k$ 指的是 $j$ 在环上往左边或者右边移动 $2^k$，不是真的直接减掉。）

那么考虑怎么证明一下。

当 $k=0$ 显然就是原本方程。

当 $k>0$ 的时候，设 $k-1$ 时成立，有：

$$
f_{i,j}=f_{i-2^{k-1},j-2^{k-1}}\oplus f_{i-2^{k-1},j+2^{k-1}}
$$

$$
=(f_{i-2^{k-1}-2^{k-1},j-2^{k-1}-2^{k-1}}\oplus  f_{i-2^{k-1}-2^{k-1},j+2^{k-1}-2^{k-1}})\oplus 
(f_{i-2^{k-1}-2^{k-1},j+2^{k-1}-2^{k-1}}\oplus  f_{i-2^{k-1}-2^{k-1},j+2^{k-1}+2^{k-1}})
$$

$$
=f_{i-2^{k},j-2^{k}}\oplus f_{i-2^{k},j+2^{k}}
$$

然后就证明完了。

实现的时候，你把 $T$ 按位拆分得到每个 $k$ 即可。

```cpp
# include <bits/stdc++.h>
# define int long long
using namespace std;
const int N = 1e5 + 5;
int n , t ;
string s ; 
int f[2][N] , op ; 
signed main () {
    ios::sync_with_stdio(false) , cin.tie(0);
    cin >> n >> t >> s ;
    for ( int i = 0;i < n;++i ) f[0][i] = s[i] - '0' ;
    for ( int bit = 0;bit <= 60;++bit ) {
        if ( ! ( ( t >> bit ) & 1ll ) ) continue ;
        int step = ( 1ll << bit ) % n ;
        for ( int i = 0;i < n;++i ) {
            int l = ( i - step + n) % n , r = ( i + step + n ) % n  ; 
            f[op ^ 1][i] = f[op][l] ^ f[op][r] ; 
        }
        op ^= 1; 
    }
    for ( int i = 0;i < n;++i ) cout << f[op][i] ; 
    return  0 ;
}
```

---

## 作者：fush (赞：2)

我们先把环断成链。

转换题意：$f_{i, j} = f_{i - 1, j - 1} \oplus f_{i - 1, j + 1}$。

其中第一维是操作次数，$\oplus$ 是异或。

由于 $T$ 很大，而且大概率是不会有循环的。  

那么我们先画图：
![](https://cdn.luogu.com.cn/upload/image_hosting/mfzti9ib.png)

因为是异或，所以橙色点的状态我们并不用在意。

我们可以猜出结论：

$$
f_{i, j} = f_{i - 2^k, j - 2 ^k} \oplus f_{i - 2 ^k, j + 2 ^k}, k \in \mathbb{N}, 2 ^ k \le i
$$

证明可以看前面的题解。

那么这题就很简单了。

我们对 $T$ 做二进制分解。  
先处理出 $1$ 位置的左右点，然后每次 $+1$ 超出 $n$ 的时候 $-n$ 即可。  
总时间复杂度：$O(n \log T)$。

```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
constexpr int N = 1e5 + 10;
#define int long long
int a[2][N], p;
int32_t main(){
    cin.tie(0)->sync_with_stdio(0);
    int n, t;char c;
    cin >> n >> t;
    for(int i = 1; i <= n; i++)cin >> c, a[1][i] = c - '0';
    for(int k = 0; k <= log2(t); k++){
        if((t >> k) & 1){
            int l = (((long long)1 << k) % n) + 1, r = ((n - l + 1) % n) + 1;
            for(int i = 1; i <= n; i++){
                a[p][i] = a[!p][l] ^ a[!p][r];
                l++, r++;
                if(l > n)l -= n;
                if(r > n)r -= n;
            }
            p = !p;
        }
    }
    for(int i = 1; i <= n; i++)
    cout << a[!p][i];
    return 0;
}
```

---

## 作者：Rubidium_Chloride (赞：2)

哈哈 [这个比赛](https://www.luogu.com.cn/contest/53104) 的 [这个题](https://www.luogu.com.cn/problem/U66520?contestId=53104) 撞了这玩意。

显然没有紫题难度，关键在于注意到这个题可以倍增处理。

* 首先下标我们认为在 $\bmod n$ 意义下。

结论：令 $f_{x,p}$ 为第 $p$ 轮后第 $x$ 个位置上的值，则 $f_{x,2^k}=f_{x-2^k,0}\operatorname{xor} f_{x+2^k,0}$。

我们考虑对 $k$ 归纳证明这个结论。

首先 $k=0$ 的时候由这个游戏的规则是显然的。

假设 $k=k_0$ 的时候已经成立，那么我们考虑 $k=k_0+1$ 的时候。

$\begin{aligned}f_{x,2^{k_0+1}}&=f_{x-2^{k_0},2^{k_0}}\operatorname{xor} f_{x+2^k2^{k_0},2^{k_0}}\\&=f_{x-2^{k_0}-2^{k_0},0}\operatorname{xor}f_{x-2^{k_0}+2^{k_0},0}\operatorname{xor}f_{x+2^{k_0}-2^{k_0},0}\operatorname{xor}f_{x+2^{k_0}+2^{k_0},0}\\&=f_{x-2^{k_0+1},0}\operatorname{xor}f_{x+2^{k_0+1},0}\end{aligned}$

所以命题就得证了。

所以我们只需要从高到低（事实上顺序无所谓）地处理 $k$ 的每一个二进制位，然后反复利用上面的柿子就好了。

好像可以用 `bitset` 加快，但是反正能过我就用数组了，常数巨大。

复杂度 $\mathcal{O}(n\log T)$。

直接扔赛场代码。

```
#include<bits/stdc++.h>
#define N 500009
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read() {
    ll x=0,f=1;int c=getchar();
    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
ll n,k,pw[64];
int f[N],g[N];
char c;
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    n=read(),k=read();
    pw[0]=1;for(int i=1;i<=62;i++) pw[i]=pw[i-1]*2;
    for(int i=1;i<=n;i++){
        c=getchar();
        while(!isdigit(c)) c=getchar();
        f[i]=c-'0';
    }
    for(int i=62;i>=0;i--){
        if(k&pw[i]){
            for(int j=1;j<=n;j++) g[j]=f[((j-pw[i]-1)%n+n)%n+1]^f[((j+pw[i]-1)%n+n)%n+1];
            for(int j=1;j<=n;j++) f[j]=g[j];
        }
    }
    for(int i=1;i<=n;i++) printf("%d",f[i]);
    return 0;
}
```

---

## 作者：Galois_Field_1048576 (赞：1)

本题解中所有操作在 $\bmod 2$ 意义下进行。

---

显然题面中的操作相当于 $B_i = A_{i-1}+A_{i+1}$，如果将 $B$ 右移一位，可以得到 $C_i = A_i + A_{i+2}$。于是有 ${\rm OGF}[C] = (1 + x^2) {\rm OGF}[A]$。在 $T$ 次操作后，得到 ${\rm OGF}[C^T] = (1+x^2)^T {\rm OGF}[A]$，将 $C^T$ 左移 $T$ 次得到答案数组。考虑二项式定理展开： $(1+x^2)^T = \sum\limits_{i=0}^T x^{2i} \binom Ti$。使用 Lucas 定理得：
$$\begin{array}{rl} \binom Ti \equiv 1 \pmod 2 &\iff \prod\limits_{j} \binom{\alpha_i}{\beta_i} \equiv 1 \pmod 2 \\
&\iff\forall j, \binom{\alpha_i}{\beta_i} \equiv 1 \pmod 2 \\
&\iff\forall j, \neg(\alpha_i=0\wedge \beta_i=1)
\end{array}$$
，其中 $\alpha_j = \left\lfloor\dfrac T{2^j}\right\rfloor \bmod 2$，$\beta_j = \left\lfloor\dfrac i{2^j}\right\rfloor \bmod 2$。发现满足条件的 $i$ 的数目为 $2^{{\rm popcount}(T)}$。所以当 $T = 2^{\lambda}$ 时，满足条件的 $i$ 只有 $0,T$ 两个。得到 $C^{T}_i = A_i + A_{i+2T}$。所以对 $T$ 拆位，对于每一位进行一次操作，左移回来即可。

时间复杂度：$\mathcal O(n \log T)$。

---

贴一下代码：
```cpp
#include <bits/stdc++.h>
const int N = 5e5 + 5;
char a[N], b[N];
int64_t Time;
int n;
int main() {
    std::cin >> n >> Time;
    for (int i = 0; i < n; ++ i)
        std::cin >> a[i], a[i] -= '0';
    for (int64_t i = 1; i <= (1ll << 60ll); i <<= 1)
        if (Time & i) {
            for (int j = 0; j < n; ++ j)
                b[j] = a[j] ^ a[(i * 2 + j) % n];
            for (int j = 0; j < n; ++ j)
                a[j] = b[j];
        }
    for (int i = 0; i < n; ++ i)
        std::cout << char(a[((i - Time) % n + n) % n] + '0');
}
```


---

## 作者：Sktic (赞：1)

[ P4804 [CCC2016] 生命中的圆 ](https://www.luogu.com.cn/problem/P4804)

一道有意思的推结论题，因为神鱼比赛重了所以来补一下。



结论：设原环为 $a$ ，令 $p=2^k$ ，则 $a_i$ 经过 $k$ 次变换后的值为 $a_{i-p}\oplus a_{i+p}$ （在环的意义下）。



可以采用数学归纳法证明。



- 当 $p=1,k=0$ 时，容易发现 $a_i$ 由其相邻两项决定，只有 $1$ 个为 $1$ 时其才为 $1$ 。二者刚好是题目中给我们的变化条件。



- 当 $p=2,k=1$ 时，我们可以尝试分类：

>当 $a_{i-2}$ 与 $a_{i+2}$ 相同时，原环的部分可以表现为 $A\square\square\square A$ ，令其在原环中编号为 $a_{l+1},a_{l+2},a_{l+3},a_{l+4},a_{l+5}$ ，由此我们可以发现当 $a_{l+3}=a_{l+1}=a_{l+5}=A$ 时，一次变换后的 $a_{l+2}$ 与 $a_{l+4}$ 必为 $0$ （ $a_{l+1}\oplus a_{l+3}=a_{l+3}\oplus a_{l+5} =0$ ） ，因而再进行一次变换时 $a_{l+3}$ 必定为 $0$ 。而当 $a_{l+3}=B$ 时，一次变换后的 $a_{l+2}$ 与 $a_{l+4}$ 必为 $1$ （ $a_{l+1}\oplus a_{l+3}=a_{l+3}\oplus a_{l+5} =1$ ），则再进行一次变换后的 $a_{l+3}$ 仍为 $0$ 。

>当 $a_{i-2}$ 与 $a_{i+2}$ 不同时，原环的部分可以表现为 $B\square\square\square A$ ，令其在原环中编号为 $a_{l+1},a_{l+2},a_{l+3},a_{l+4},a_{l+5}$ ，由此我们可以发现当 $a_{l+3}=a_{l+1}=B$ 时，一次变换后的 $a_{l+2}$ 必为 $0$ ， $a_{l+4}$ 必为 $1$ （ $a_{l+1}\oplus a_{l+3}=0,a_{l+3}\oplus a_{l+5} =1$ ） ，因而再进行一次变换时 $a_{l+3}$ 必定为 $1$ 。同理可得，当 $a_{l+3}=a_{l+5}=A$ 时，经过 $2$ 轮变换后的 $a_{l+3}$ 也必定为 $1$ 。 



- 当 $p=2^k,k>1$ 时，我们令 $k-1$ 的结论成立，则有：

>当 $a_{i-p}$ 与  $a_{i+p}$ 相同时，原环部分可以表现为 $A\square\cdots\square\cdots\square A$ ，容易发现当 $a_{i}=a_{i-p}=a_{i+p}=A$ 或 $a_i=B$ 时，区间的剩余两部分都为 $k-1$ 的子问题，而这两个子问题根据结论来讲答案都必然为 $1$ ，因此原问题答案为 $0$ 。

>当 $a_{i-p}$ 与  $a_{i+p}$ 不同时，原环部分可以表现为 $A\square\cdots\square\cdots\square B$ ，容易发现当 $a_{i}=a_{i-p}=A$ 或 $a_i=a_{i+p}=B$ 时，区间的剩余两部分也都为 $k-1$ 的子问题，而这两个子问题根据结论来讲答案都必然一个为 $1$ ，一个为 $0$ ，因此原问题答案为 $1$ 。



因此我们不难发现，可以通过小问题来推广大问题，原命题由此得证。



于是我们只需要将 $T$ 二进制分解，即可在 $O(n\log T)$ 得时间复杂度内解决。

---

## 作者：Coffee_zzz (赞：0)

设 $f_{i,j}$ 表示第 $i$ 个方格在第 $j$ 轮的状态，则根据题意可以得到 $f_{i,j}=f_{i-1,j-1} \oplus f_{i+1,j-1}$（我们认为 $1$ 的上一个数是 $n$ 且 $n$ 的下一个数是 $1$），其中 $\oplus$ 表示异或。

我们推一下这个式子：

$$
\begin{aligned}
f_{i,j}
&=f_{i-1,j-1} \oplus f_{i+1,j-1}\\
&=f_{i-2,j-2} \oplus f_{i,j-2} \oplus f_{i,j-2} \oplus f_{i+2,j-2}\\
&=f_{i-2,j-2} \oplus f_{i+2,j-2}\\
&=f_{i-4,j-4} \oplus f_{i,j-4} \oplus f_{i,j-4} \oplus f_{i+4,j-4}\\
&=f_{i-4,j-4} \oplus f_{i+4,j+4}\\
&=\cdots
\end{aligned}
$$

于是递推可以得到：

$$f_{i,j}=f_{i-2^k,j-2^k}+f_{i+2^k,j-2^k}$$

那么我们可以把 $T$ 拆成 $2^{a_1}+2^{a_2}+\cdots+2^{a_m}$，对于每个 $2^{a_s}$ 分别做一次 $f_{i,j}=f_{i-2^{a_s},j-2^{a_s}} \oplus f_{i+2^{a_s},j-2^{a_s}}$ 即可，时间复杂度 $\mathcal O(n \log T)$。

---

## 作者：可爱的小棉羊 (赞：0)

设 $f_{i,j}$ 为 $j$ 轮后的第 $i$ 号。

那么理解题意有 $f_{i,j}=f_{i-1,j-1} \oplus f_{i+1,j-1} $。

（不是那么严谨，因为这是一个环）

这种迭代多少多少次的题，有两个典中典的方案：循环节和倍增。

显然这迭一下就 $O(n)$ 了，循环节完全没法玩。

那么考虑处理出 $2^k$ 次后长什么样。

有 $f_{i,j}=f_{i-2^k,j-2^k}\oplus f_{i+2^k,j-2^k}$

证明如下：

$k=0$ 时结论即为题意。

假设 $k-1$ 满足，条件那么：$f_{i,j}=f_{i-2^{k-1},j-2^{k-1}}\oplus f_{i+2^{k-1},j-2^{k-1}}=(f_{i-2^k,j-2^k}\oplus f_{i,j-2^k})\oplus(f_{i+2^k,j-2^k}\oplus f_{i,j-2^k})=f_{i-2^k,j-2^k}\oplus f_{i+2^k,j-2^k}$

不言而喻了。

每次跳 $2^k$ 共 $O(n \log T)$。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
bool f[100005][2]; 
long long n,t;
string str; 
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>t;
	cin>>str;
	for(int i=0;i<str.size();i++)f[i+1][0]=(str[i]-'0');
	int T=0;
	for(int i=0;i<=59;i++){
		if(t&(1ll<<i)){
			for(int j=1;j<=n;j++)f[j][T^1]=(f[((j-1-(1ll<<i))%n+n)%n+1][T]^f[((j-1)%n+(1ll<<i))%n+1][T]);
			T^=1;
		}
	}
	for(int i=1;i<=n;i++)cout<<f[i][T];
	cout<<"\n";
	return 0;
}

```

---

## 作者：Φρανκ (赞：0)

题意：对于一个序列 $a_0\sim a_{n-1}$，定义一次操作 $f(a)$ 为 $\forall\:0\le i<n\:a_i=a_{i-1\bmod n}\oplus a_{i+1\bmod n}$。给定一个序列，求 $f^t(a)$。

核心思想：递推，数学归纳法

解：

可用数学归纳法证明 $f^{2^x}(a):\{a_i|0\le i<n\}→\{a_{i-2^x\bmod n}\oplus a_{i+2^x\bmod n}|0\le i<n\}$，如下文：

容易发现当 $x=0$ 时命题成立；

若 $x=j$ 时命题成立，有 $f^{2^{x+1}}(a)=f^{2^x}(f^{2^x}(a)):\{a_i|0\le i<n\}→\{a_{i-2^x\bmod n}\oplus a_{i+2^x\bmod n}|0\le i<n\}→\{(a_{i-2^x-2^x\bmod n}\oplus a_{i-2^x+2^x\bmod n})\oplus (a_{i+2^x-2^x\bmod n}\oplus a_{i+2^x+2^x\bmod n})|0\le i<n\}=\{a_{i-2^{x+1}\bmod n}\oplus a_{i+2^{x+1}\bmod n}|0\le i<n\}$，可见命题对 $x=j+1$ 也成立。由数学归纳法可证命题对 $\forall\: x\in\mathbb{N}$ 都成立。

先预处理出所有小于等于 $t$ 的 $2$ 的幂次，然后每次求出 $a=f^{2^k}(a)$，其中 $2^k$ 是不大于剩余操作数的最大 $2$ 的幂次。总复杂度 $O(n\log t)$，能够通过。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long n, t, a[100001], b[100001], pw[51];
char ch[100001];
long long sol(long long x)
{
	if(x==0)
		return 0;//结束条件
	long long k=0;
	while(pw[k]<=x)
		k++;
	k--;//求k
//	cout<<k<<" "<<temp<<" "<<x-pw[k]<<endl;
	for(int i=0; i<n; i++)
		b[i]=a[(i+pw[k])%n]^a[(i-pw[k]+n)%n];//不能直接对a进行修改
	for(int i=0; i<n; i++)
		a[i]=b[i];
//	for(int i=0; i<n; i++)
//		cout<<a[i];
//	cout<<endl;
	sol(x-pw[k]);//进行剩余操作
	return 0;
}
int main()
{
	cin>>n>>t>>ch;
	for(int i=0; i<n; i++)
		a[i]=ch[i]-48;
	pw[0]=1;
	for(int i=1; i<=50; i++)
		pw[i]=pw[i-1]*2;//预处理2的幂次
	sol(t);
	for(int i=0; i<n; i++)
		cout<<a[i];
	return 0;
}
```

---


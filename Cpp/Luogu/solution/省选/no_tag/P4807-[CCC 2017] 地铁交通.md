# [CCC 2017] 地铁交通

## 题目背景

**滥用本题评测将被封号**

## 题目描述

 **译自 [CCC2017](https://cemc.math.uwaterloo.ca/contests/computing/2017/index.html) Senior T5「[RMT](https://cemc.math.uwaterloo.ca/contests/computing/2017/stage%201/seniorEF.pdf)」**

RMT 地铁交通运行着一个不寻常的地铁系统。有 $N$ 个地铁站，从 $1$ 到 $N$ 编号。有 $M$ 条地铁线路，从 $1$ 到 $M$ 编号，每个地铁站只属于一条线路且每条线路至少经过一个地铁站。整个地铁网络呈圆形。也就是说，如果有一个编号为 $S$ 的地铁站，那么与它同一线路的下一个地铁站是下一个编号比它大的地铁站。除非 $S$ 是同线路中编号最大的地铁站，在这种情况下，它的下一个地铁站是同一线路中编号最小的地铁站。

RMT 正在以志愿者对他们的系统进行负载测试。测试从每一站以一列地铁列车开始，且对于每一个 $i$，会有 $A_i$ 个志愿者在第 $i$ 站的测试列车上。在整个测试期间，志愿者不会离开对应的列车。

测试过程中，RMT 会进行 $Q$ 个操作，每个操作只有两种可能：一种是询问第 $l$ 站到第 $r$ 站地铁上的志愿者人数；或是在线路 $x$ 运行所有的地铁。当有一列地铁在 $x$ 线路运行，它会前往线路中的下一站。

你是 RMT 的铁杆骨灰级粉丝，所以你自愿协助他们进行操作并告诉他们操作的结果。

## 说明/提示

### 样例解释 1
地铁系统如下图所示，地铁站编号为 $1$ 到 $5$，由编号为 $1$ 或 $2$ 的线路连接：

![](https://i.loli.net/2018/08/16/5b74e41916341.png)

开始时，每个地铁站的志愿者人数为 $\{1,2,3,4,5\}$。

第一个询问的答案为 $1+2+3+4+5=15$。

线路 $1$ 被运行之后，每个地铁站的志愿者人数为 $\{3,2,1,4,5\}$。

第二个询问的答案为 $1+4+5=10$。

线路 $2$ 被运行之后，每个地铁站的志愿者人数为 $\{3,5,1,2,4\}$。

第三个询问的答案为 $3+5+1=9$。

#### 样例解释 2
地铁系统如下图所示，地铁站编号为 $1$ 到 $3$，只有线路 $1$ 连接：

![](https://i.loli.net/2018/08/16/5b74e56617ad0.png)

第一次询问之前，每个地铁站的志愿者人数为 $\{114,101,109\}$。

第二次询问之前，每个地铁站的志愿者人数为 $\{109,114,101\}$。

第三次询问之前，每个地铁站的志愿者人数为 $\{101,109,114\}$。

第四次询问之前，每个地铁站的志愿者人数为 $\{114,101,109\}$。

对于 $\frac2{15}$ 的数据，$N \le 1\ 000,Q \le 1\ 000$。

对于另外 $\frac2{15}$ 的数据，$L_i \le L{i+1}(1 \le i < N)$。

对于另外 $\frac3{15}$ 的数据，$M \le 200$。

对于另外 $\frac3{15}$ 的数据，每条线路的地铁数量都不超过 $200$。

## 样例 #1

### 输入

```
5 2 5
1 2 1 2 2
1 2 3 4 5
1 1 5
2 1
1 3 5
2 2
1 1 3```

### 输出

```
15
10
9```

## 样例 #2

### 输入

```
3 1 7
1 1 1
114 101 109
1 1 1
2 1
1 1 1
2 1
1 1 1
2 1
1 1 1```

### 输出

```
114
109
101
114```

# 题解

## 作者：_AyachiNene (赞：3)

模拟赛题，不用根号分治纯分块做法。
# 思路：
首先有一种显然的根号分治算法，不优化是 $n\sqrt {n\log n}$ 结合数据范围想到写根号算法。考虑分块，首先按所属的环分类，发现对于修改操作的维护是简单的，对于一个块内发现最后一个数会移到下一个块内，其它数对于一个块的和是无影响的，可以不考虑。于是就有一个思路，每一个块内开一个队列，维护队头就行。发现空间复杂度带根号，如果出题人要卡空间就做不了，发现分类后每一块的最后一个数是可以直接求出的，每次踢队就相当于把最后一个数变成上一个数。再考虑查询操作，考虑散块部分怎么做，对于一种颜色算出需要几个，从块内最后一个向前找就行。经过精细实现空间线性，时间 $O(n\sqrt n)$。
# Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){char ch=getch();while(ch<'a'||ch>'z')ch=getch();while(ch>='a'&&ch<='z'){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int n,m,q;
int c[150005];
ll a[150005];
int siz,bcnt,belong[150005],bl[400],br[400];
ll sum[400];
int vis[150005];
struct node
{
	int id,p;
};
vector<node>v[150005],tag[150005];
vector<int>p[150005];
int tc[150005],tc1[150005];
inline ll calc(int x,int y)
{
	ll res=0;int b=belong[x];
	for(int i=x;i<=y;i++) ++tc[c[i]];
	for(int i=y+1;i<=br[b];i++) ++tc1[c[i]];
	for(int i=0;i<v[b].size();i++) 
	{
		int nc=v[b][i].id;
		int now=tag[nc][v[b][i].p].p;
		while(tc1[nc])
		{
			--now;if(now==-1) now=p[nc].size()-1;
			--tc1[nc];
		}
		while(tc[nc])
		{
			res+=a[p[nc][now]];
			--now;if(now==-1) now=p[nc].size()-1;
			--tc[nc];
		}
	}
	return res;
}
signed main()
{
	freopen("ring.in","r",stdin);
	freopen("ring.out","w",stdout);
	read(n,m,q);
	siz=sqrt(n);
	bcnt=ceil(1.0*n/siz);
	for(int i=1;i<=bcnt;i++)
	{
		bl[i]=(i-1)*siz+1,br[i]=min(n,i*siz);
		for(int j=bl[i];j<=br[i];j++) belong[j]=i;
	}
	for(int i=1;i<=n;i++) read(c[i]),p[c[i]].push_back(i);
	for(int i=1;i<=n;i++) read(a[i]),sum[belong[i]]+=a[i];
	for(int i=1;i<=m;i++) p[i].push_back(n+1);
	for(int i=1;i<=bcnt;i++)
	{
		for(int j=bl[i];j<=br[i];j++)
			if(!vis[c[j]]) v[i].push_back((node){c[j],0}),vis[c[j]]=1;
		for(int j=0;j<v[i].size();j++) 
		{
			int x=v[i][j].id;
			int pos=upper_bound(p[x].begin(),p[x].end(),br[i])-p[x].begin()-1;
			tag[x].push_back((node){i,pos}),vis[x]=0;
			v[i][j].p=tag[x].size()-1;
		}
	}
	for(int i=1;i<=m;i++) p[i].pop_back();
	while(q--)
	{
		int op,x,y;
		read(op,x);
		if(op==1)
		{
			read(y);
			ll ans=0;
			if(belong[x]==belong[y])
			{
				write(calc(x,y)),putch('\n');
				continue;
			}
			for(int i=belong[x]+1;i<=belong[y]-1;i++) ans+=sum[i];
			ans+=calc(x,br[belong[x]])+calc(bl[belong[y]],y);
			write(ans),putch('\n');
		}
		else
		{
			if(tag[x].size()==0) continue;
			node tmp=tag[x].back();
			for(int i=tag[x].size()-1;i;i--)
			{
				sum[tag[x][i].id]+=a[p[x][tag[x][i-1].p]]-a[p[x][tag[x][i].p]];
				--tag[x][i].p;if(tag[x][i].p==-1) tag[x][i].p=p[x].size()-1;
			}
			sum[tag[x][0].id]+=a[p[x][tmp.p]]-a[p[x][tag[x][0].p]];
			--tag[x][0].p;if(tag[x][0].p==-1) tag[x][0].p=p[x].size()-1;
		}
	}
	flush();
	return 0;
}
```

---

## 作者：suzhikz (赞：3)

这题写了一个晚自习，发篇题解纪念下。

首先我们有很显然的暴力，查询用分块查，然后修改时每次暴力移动，发现这玩意在数少的时候比较快，考虑根号分治。

然后想数比较多的时候怎么做，发现每次查询本质是把指针移动修改的次数，然后直接前缀和即可。这样我们就可以快速查询了。

然后平衡下复杂度即可做到 $O(n\sqrt{n}) $。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define db double
#define il inline
using namespace std;
void read(int &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
void read(ll &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
const int N=150005,blo=1400;
int n,m,q;
int cnt[N],c[N],a[N],mark[N];
vector<int>v,pos[N];ll sumpre[N],sumsuf[N];
int fpre[N],fsuf[N];
ll summ[blo+5];int id[N],R[blo+5];
int chan[N];
ll ans[N];
ll query(int l,int r){//查询暴力修改的
	ll re=0;
	if(id[l]==id[r]){
		for(int i=l;i<=r;i++)if(mark[c[i]]==0)re+=a[i];
	}else{
		for(int i=l;i<=R[id[l]];i++){
			if(mark[c[i]]==0)
			re+=a[i];
		}
		for(int i=id[l]+1;i<id[r];i++)re+=summ[i];
		for(int i=R[id[r]-1]+1;i<=r;i++)if(mark[c[i]]==0)re+=a[i];
	}
	return re;
}
int l[N],r[N],op[N];
signed main(){
	read(n);read(m);read(q);
	for(int i=1;i<=n;i++){
		read(c[i]);cnt[c[i]]++;pos[c[i]].push_back(i);chan[i]=pos[c[i]].size()-1;
	}
	for(int i=1;i<=n;i++)read(a[i]);
	for(int i=1;i<=m;i++){
		if(cnt[i]>=blo){
			mark[i]=v.size()+1;v.push_back(i);
		}
	}
	for(int i=1;i<=q;i++){
		read(op[i]);
		if(op[i]==1){
			read(l[i]),read(r[i]);
		}else read(l[i]);
	}
	memset(cnt,0,sizeof(cnt));
	for(int i=0;i<v.size();i++){
		int la=0;
		for(int j=1;j<=n;j++){
			sumpre[j]=0;
			if(c[j]==v[i]){
				la=j;sumpre[j]=a[j];
			}fpre[j]=la;sumpre[j]+=sumpre[j-1];
		}
		for(int j=1;j<=n;j++){
			if(fpre[j]==0)fpre[j]=la;
			else break;
		}
		la=0;
		for(int j=n;j>=1;j--){
			sumsuf[j]=0;
			if(c[j]==v[i]){
				la=j;sumsuf[j]=a[j];
			}
			sumsuf[j]+=sumsuf[j+1];
			fsuf[j]=la;
		}
		for(int j=n;j>=1;j--){
			if(fsuf[j]==0)fsuf[j]=la;
			else break;
		}
		for(int j=1;j<=q;j++){
			if(op[j]==2){//数多的情况下，打标记
				if(l[j]==v[i])cnt[l[j]]++;
			}else{
				int ql=l[j],qr=r[j];
				if(fpre[qr]<ql||fpre[qr]>qr)continue;
				int fl=fsuf[ql],fr=fpre[qr];
				fl=chan[fl];fr=chan[fr];
				fl-=cnt[v[i]];fr-=cnt[v[i]];//向前移动
				if(fl<0){
					fl=-fl;fl%=pos[v[i]].size();fl=-fl;
				}else fl%=pos[v[i]].size();
				if(fr<0){
					fr=-fr;fr%=pos[v[i]].size();fr=-fr;
				}else fr%=pos[v[i]].size();
				
				fl=(fl+pos[v[i]].size())%pos[v[i]].size();
				fr=(fr+pos[v[i]].size())%pos[v[i]].size();
				if(fl>fr){
					ans[j]+=sumsuf[pos[v[i]][fl]]+sumpre[pos[v[i]][fr]];
				}else{
					ans[j]+=sumpre[pos[v[i]][fr]];if(fl)ans[j]-=sumpre[pos[v[i]][fl-1]];
				}
			}
			
		}
	}
	for(int i=1;i<=n;i++){
		id[i]=(i-1)/blo+1;R[id[i]]=i;
		if(mark[c[i]]==0){
			summ[id[i]]+=a[i];
		}
	}
	memset(cnt,0,sizeof(cnt));//之后是查询数少的权值
	for(int i=1;i<=q;i++){
		if(op[i]==2){
			if(mark[l[i]]==0){
				int len=pos[l[i]].size(),tmp=a[pos[l[i]][len-1]];
				for(int j=len-1;j>=0;j--){
					int u=pos[l[i]][j],v;if(j)v=pos[l[i]][j-1];
					if(j!=0){
						summ[id[u]]-=a[u];a[u]=a[v];summ[id[u]]+=a[u];
					}else{
						summ[id[u]]-=a[u];a[u]=tmp;summ[id[u]]+=a[u];
					}
				}
			}
		}else{
			ans[i]+=query(l[i],r[i]);
		}
	}
	for(int i=1;i<=q;i++){
		if(op[i]==1)cout<<ans[i]<<endl;
	}
	return 0;
}
```

---

## 作者：MuelsyseU (赞：2)

[题面](https://www.luogu.com.cn/problem/P4807)：给定一个长为 $n$ 的序列 $a$ 及 $m$ 个 $a$ 的子序列

`1 l r` 查询 $\sum^{r}_{i=l}a_i$。

`2 x` 将子序列 $x$ 末尾对应 $a$ 中元素移动到首位，并将其余元素对应后移，除该子序列外 $a$ 不变。

数据范围 $1.5*10^5$ 考虑根号做法。套路序列分块，维护整块的和。

显然可以对每个子序列 $x$ 分别建立一个 vector （记为 $v_x$）存储各出现位置，则为了避免暴力修改导致的复杂度错误，必须对该子序列在同一块中的部分整体处理。

具体而言，每次操作仅会导致每块中增加一个元素并减少另一个元素。对于每个 $x$，将 $v_x$ 中连续的在同一块中的段合并为数组 $p_x$，维护 $p_x$ 对应 $v_x$ 中的左端点及右端点。易证明合并后 $p_x$ 中元素不超过 $\sqrt{n}$ 个。

修改过程中，对于合并后每个整段，将其对应左右端点左移，并据此修改对应块总和即可。另外维护每个序列修改的次数，散块统计时直接在 $v$ 中查询实际值即可。

时间复杂度 $O(n\sqrt{n})$，空间线性。另外，序列分块做法常数较大，但可以扩展到区间修改及对于各个子序列的插入、删除操作。

代码仅供参考。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Block {
    int i, l, r;
};
int n, m, q, x, y, c, len, a[150002], b[150002], l[405], r[405], bl[150002], t[150002], f[150002];
long long ans, s[405];
vector<int> v[200005];
vector<Block> p[200002];
inline int read() {
    int ret = 0, f = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0') f = ch == '-' ? -1 : f, ch = getchar();
    while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();
    return ret * f;
}
signed main() {
    n = read(), m = read(), q = read();
    for (int i = 1; i <= n; ++i) b[i] = read(), f[i] = v[b[i]].size(), v[b[i]].push_back(i);
    for (int i = 1; i <= n; ++i) a[i] = read();
    int tb = ceil(sqrt(n)), tc = ceil(n * 1.0 / tb);
    for (int i = 1; i <= tc; ++i) l[i] = r[i - 1] + 1, r[i] = i * tb;
    r[tc] = n;
    for (int i = 1; i <= tc; ++i)
        for (int j = l[i]; j <= r[i]; ++j) bl[j] = i, s[i] += a[j];
    for (int i = 1; i <= m; ++i) {
        if (v[i].empty()) continue;
        p[i].push_back({bl[v[i][0]], 0, 0});
        for (int j = 1; j < v[i].size(); ++j) {
            if (bl[v[i][j]] != bl[v[i][j - 1]])
                p[i].push_back({bl[v[i][j]], j, j});
            else
                p[i][p[i].size() - 1].r = j;
        }
    }
    while (q--) {
        c = read();
        if (c == 1) {
            x = read(), y = read(), ans = 0;
            if (bl[x] == bl[y])
                for (int i = x; i <= y; ++i)
                    len = v[b[i]].size(), ans += a[v[b[i]][(f[i] + len - t[b[i]]) % len]];
            else {
                for (int i = x; i <= r[bl[x]]; ++i)
                    len = v[b[i]].size(), ans += a[v[b[i]][(f[i] + len - t[b[i]]) % len]];
                for (int i = bl[x] + 1; i < bl[y]; ++i) ans += s[i];
                for (int i = l[bl[y]]; i <= y; ++i)
                    len = v[b[i]].size(), ans += a[v[b[i]][(f[i] + len - t[b[i]]) % len]];
            }
            printf("%lld\n", ans);
        } else {
            x = read(), len = v[x].size(), (++t[x]) %= v[x].size();
            for (int i = 0; i < p[x].size(); ++i)
                s[p[x][i].i] -= a[v[x][p[x][i].r]], p[x][i].l = (p[x][i].l - 1 + len) % len,
                                                    p[x][i].r = (p[x][i].r - 1 + len) % len,
                                                    s[p[x][i].i] += a[v[x][p[x][i].l]];
        }
    }
    return 0;
}
```


---

## 作者：DengDuck (赞：1)

一种严格 $\mathcal O(n\sqrt n)$ 且常数较小的做法。

这题我觉得根号分治应该挺自然的。

我们统计每个路线的站点数 $x$：

## Part 1

当 $x\leq B$。

直接暴力修改，每次的操作数是 $\mathcal O(B)$。

然而每次的查询次数只有 $\mathcal O(1)$，根号平衡一下我们发现写分块是最优的。


修改是 $\mathcal O(1)$ 的，查询是 $\mathcal O(n)$ 的，整体可以做到 $\mathcal O(n\sqrt n)$。

## Part 2
当 $x>B$。

这样的路线不超过 $\dfrac n B$ 个，考虑把它们离线下来，对于每个路线单独跑，计算它们对每次询问的贡献。

考虑记录一个操作一导致的偏移量，那么我们计算出 $[L,R]$ 这个区间包含的是未收到操作一影响时的路线中的哪些站点，就可以推出当前包含哪些站点，一个前缀和就做完了。

问题在于二分找位置是 $\mathcal O(\log n)$，所以我们直接预处理，记录每个位置下一个站点和上一个站点就可以了。


--- 

代码写粪了，其实可以挺短的。

常数上我是 LOJ 最优解但是在洛谷被大神 @hjxhjx 压了一头，技不如人，败了。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define LL long long
using namespace std;
const int N=2e5+5;
const int B=480;
int n,m,Q,L[N],Sz[N],Nxt[N],Lst[N],A[N],C[N];
LL S[B+5],Ans[N],Sum[N<<1],Tmp[N];
struct Oper{int o,x,y;}O[N];
vector<int>Hav[N<<1];
inline void Upd(int x,int k){S[x/B]+=k,A[x]+=k;}
inline LL Qry(int x)
{
	LL Ans=0;
	for(int i=0;i<x/B;i++)Ans+=S[i];
	for(int i=(x/B)*B;i<=x;i++)Ans+=A[i];
	return Ans;
}
inline void Rd(int &s,int w=1)
{
	s=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=(s<<3)+(s<<1)+(ch-'0');ch=getchar();}
	s=s*w;
}
int main()
{
	Rd(n),Rd(m),Rd(Q);
	for(int i=1;i<=n;i++)
	{
		Rd(L[i]);
		Hav[L[i]].pb(i);
	}
	for(int i=1;i<=n;i++)Rd(C[i]);
	for(int i=1;i<=m;i++)Sz[i]=Hav[i].size();
	for(int i=1;i<=Q;i++)
	{
		Rd(O[i].o);
		if(O[i].o==1)Rd(O[i].x),Rd(O[i].y);
		else Rd(O[i].x);
	}
	for(int i=1;i<=n;i++)
	{
		if(Sz[L[i]]<=B)Upd(i,C[i]);
	}
	for(int i=1;i<=Q;i++)
	{
		if(O[i].o==2)
		{
			int x=O[i].x;
			if(Sz[x]>B)continue;
			for(int j=0;j<Sz[x];j++)Tmp[(j+1)%Sz[x]]=A[Hav[x][j]]-A[Hav[x][(j+1)%Sz[x]]];
			for(int j=0;j<Sz[x];j++)Upd(Hav[x][j],Tmp[j]);	
		}
		else Ans[i]+=Qry(O[i].y)-Qry(O[i].x-1);
	}
	for(int i=1;i<=n;i++)
	{
		if(Sz[i]<=B)continue;
		
		Sum[0]=C[Hav[i][0]];
		for(int j=1;j<Sz[i];j++)Sum[j]=Sum[j-1]+C[Hav[i][j]];
		for(int j=Sz[i];j<2*Sz[i];j++)Sum[j]=Sum[j-1]+C[Hav[i][j-Sz[i]]];
		
		for(int j=1;j<=n;j++)Nxt[j]=Lst[j]=-1;
		for(int j=0;j<Sz[i];j++)Nxt[Hav[i][j]]=Lst[Hav[i][j]]=j;
		Nxt[n+1]=n+1;
		for(int i=n;i>=1;i--)
		{
			if(Nxt[i]==-1)Nxt[i]=Nxt[i+1];
		}
		for(int i=1;i<=n;i++)
		{
			if(Lst[i]==-1)Lst[i]=Lst[i-1];
		}
		for(int j=1,D=0;j<=Q;j++)
		{
			if(O[j].o==2)
			{
				D+=(i==O[j].x);
				if(D==Sz[i])D=0;
			}
			else
			{
				int L=Nxt[O[j].x],R=Lst[O[j].y];
				if(L>R)continue;
				Ans[j]+=Sum[R+Sz[i]-D]-Sum[L+Sz[i]-D-1];
			}
		}
	}
	for(int i=1;i<=Q;i++)
	{
		if(O[i].o==1)printf("%lld\n",Ans[i]);
	}
}
```

---

## 作者：Nangu (赞：1)

来一篇暴力的分块平衡题解！

对于操作 $1$，设 $len$ 为线路 $x$ 的长度。
- 当 $len\le B$ 时，直接暴力转化，用树状数组记录前缀和。时间复杂度 $O(B\log n)$。
- 当 $len>B$ 时，我们记录一个变量 $cnt_x$，每次操作就加一，方便后面进行统计。

对于操作 $2$：
- 首先利用树状数组将 $l$，$r$ 内的答案统计。
- 此时还用长度 $>B$ 的线路上的答案没有统计。我们依次枚举这些线路，并二分得出线路对应 $l$，$r$ 的部分，再通过前缀和计算答案。时间复杂度 $O(\dfrac{n \times \log n}{B})$。

总时间复杂度为 $O(Q\times (B\log n+\dfrac{n \times \log n}{B} ))$，容易看出当 $B=\sqrt n$  时复杂度最小，为 $O(n \sqrt n \log n)$，能过。

其实还可以先算出每个线路对于每个点前面的第一个点的位置，从而省去操作二中的二分，使其复杂度降为 $O(\dfrac{n }{B})$，通过调整 $B$ 的大小来使总复杂度降为 $O(n \sqrt {n \log n})$。由于博主太懒了，这个方法没有被实现。

Code:
```cpp
#include<bits/stdc++.h>
#define rep(i, j, k) for(int i=(j); i<=(k); ++i)
#define per(i, j, k) for(int i=(j); i>=(k); --i)
#define siz(x) (int)x.size() 
using namespace std;
const int N=1.5e5+7, B=350;
int n, m, q, l[N], a[N], t[N], cnt[N];
vector<int> v[N], s[N], b;
void update(int p, int x){while(p<=n) t[p]+=x, p+=p&-p;}
int query(int p){int x=0; while(p) x+=t[p], p&=p-1; return x;}
int query(int l, int r){return query(r)-query(l-1);}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>n>>m>>q;
	rep(i, 1, n){
		cin>>l[i];
		v[l[i]].emplace_back(i);
	}
	rep(i, 1, n) cin>>a[i];
	rep(i, 1, m){
		if(siz(v[i])<=B){
			for(auto x:v[i])
				update(x, a[x]);
		} else{
			b.emplace_back(i);
			int len=siz(v[i]);
			s[i].resize(len);
			s[i][0]=a[v[i][0]];
			rep(j, 1, len-1)
				s[i][j]=s[i][j-1]+a[v[i][j]];
		}
	}
	rep(_, 1, q){
		int opt, l, r, i;
		cin>>opt;
		if(opt==1){
			cin>>l>>r;
			int ans=query(l, r);
			for(auto j:b){
				int pl=lower_bound(v[j].begin(), v[j].end(), l)-v[j].begin(), pr=upper_bound(v[j].begin(), v[j].end(), r)-v[j].begin();
				int len=siz(v[j]), cnt=::cnt[j];
				--pr;
				if(pl>pr) continue;
				cnt=len-cnt%len;
				pl=pl+cnt<len?pl+cnt:pl+cnt-len;
				pr=pr+cnt<len?pr+cnt:pr+cnt-len;
				if(pl<=pr){
					ans+=s[j][pr]-(pl?s[j][pl-1]:0);
				} else{
					ans+=s[j][len-1]+s[j][pr]-s[j][pl-1];
				}
			}
			cout<<ans<<'\n';
		} else{
			cin>>i;
			if(siz(v[i])<=B){
				for(auto x:v[i])
					update(x, -a[x]);
				int len=siz(v[i]), tmp=a[v[i][len-1]];
				per(j, len-1, 1) a[v[i][j]]=a[v[i][j-1]];
				a[v[i][0]]=tmp;
				for(auto x:v[i])
					update(x, a[x]);
			} else ++cnt[i];
		}
	}
}

---

## 作者：Polarisx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4807)。

## 思路

本题思路挺显然的。

对于一个路线 $i$，记该路线经过站的个数为 $c_i$。

容易想到根号分治，对于一个修改 $x$，若 $c_x\le B$ 则暴力修改，否则打标记。

对于一个询问，用树状数组维护区间内 $c_i\le B$ 的权值和，而 $c_i>B$ 的 $i$ 最多只会有 $\frac{n}{B}$ 个，暴力二分查询即可。

平衡时间复杂度即可做到 $\mathcal O (q\sqrt n\log n)$，若将树状数组换成 $\mathcal O (1)-\mathcal O (\sqrt n)$ 的分块算法，时间复杂度还可做到 $\mathcal O (q\sqrt {n\log n})$，空间换时间可进一步做到 $\mathcal O {(q\sqrt n)}$。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=2e5+6,B=500;
int n,m,Q;
int c[Maxn],L[Maxn],a[Maxn];
vector<int>mp,s[Maxn];
int v[Maxn],b[Maxn],tot;
vector<ll>g[Maxn];

class BIT{
    #define lowbit(x) (x&-x)
    public:
        inline void init(int N){sz=N;}
        inline void add(int x,int k){
            while(x<=sz) tr[x]+=k,x+=lowbit(x);
        }
        inline ll query(int x){
            if(!x) return 0; 
            int ret=0;
            while(x) ret+=tr[x],x-=lowbit(x);
            return ret;
        }
    private:
        int sz;ll tr[Maxn];
}t;

int main(){
    scanf("%d%d%d",&n,&m,&Q);
    for(int i=1;i<=n;i++){
        scanf("%d",&L[i]);
        c[L[i]]++; s[L[i]].emplace_back(i);
    }
    t.init(n+5);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(c[L[i]]<=B) t.add(i,a[i]);
    }

    for(int i=1;i<=m;i++) 
        if(c[i]>B){
            mp.emplace_back(i); g[i].resize(c[i]+3);
            for(int j=0;j<c[i];j++) g[i][j]=g[i][j-1<0?c[i]+2:j-1]+a[s[i][j]];
        }

    while(Q--){
        int opt,x,y;
        scanf("%d%d",&opt,&x);
        if(opt==1){
            scanf("%d",&y);
            ll ans=t.query(y)-t.query(x-1);
            for(auto i:mp){
                int l=lower_bound(s[i].begin(),s[i].end(),x)-s[i].begin();
                int r=upper_bound(s[i].begin(),s[i].end(),y)-s[i].begin()-1;
                l=((l-v[i])%c[i]+c[i])%c[i]-1,r=((r-v[i])%c[i]+c[i])%c[i];
                if(l<r) ans+=g[i][r]-g[i][l<0?c[i]+1:l];
                else ans+=g[i][c[i]-1]-(g[i][l]-g[i][r]);
            }
            printf("%lld\n",ans);
        }
        else{
            if(c[x]<=B){
                tot=0;int pc=0;
                for(auto i:s[x]) b[tot++]=a[i],t.add(i,-a[i]);
                for(auto i:s[x]) a[i]=b[(pc-1+tot)%tot],pc++,t.add(i,a[i]);
            }
            else v[x]++;
        }
    }

    system("pause");
    return 0;
}
```

---

## 作者：_determination_ (赞：0)

根号分治，启动！

单根号很简单但是很不好写，扔掉。

暴力根号分治复杂度多个 $\log$ 过不去，扔掉。

那么，根号分治套分块，启动！

我们看一下根号分治长什么样子：

1. 修改到数量 $\leq B$ 的颜色的时候，暴力并树状数组维护前缀和，否则直接打标记。复杂度 $O(B\log n)$。
2. 查询的时候，直接计算前缀和并计算大颜色贡献，二分出区间然后根据标记移动区间，提前预处理出大颜色的前缀和就能快速算了。复杂度 $O(\frac{n}{B}\log n)$。

注：其实第二步不需要二分，直接维护前缀和即可（不是这个颜色就填 0）。但是这样空间复杂度是 $O(n\sqrt{n})$ 的，模拟赛时给了 32M。

好的如你所见，多只 $\log$ 过不去（但是听说有人过了？），考虑降低复杂度。

注意到修改的 $\log $ 是树状数组。而我们要支持的操作是单点修区间求和，分块启动即可省掉这个 $\log$。

这样调块长之后复杂度是 $O(q\sqrt{n\log n})$，无压力通过。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int mod=998244353,inf=0x3f3f3f3f3f3f3f3f;
const int N=1.5e5+10,M=2e5+10,B1=400,B2=1.6e3;
int t[N],a[N],c[N],n,m,q;
int id[N],id2[N],tot;
int sum[N],tag[N];
vector<int>vec[N],s[N],bigblk;
int getsum(int l,int r)
{
	int ans=0;
	for ( int i = l ; i <= r ; i++ )
	{
		if(vec[c[i]].size()<=B2)
			ans+=a[i];
	}
	return ans;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> m >> q;
	for ( int i = 1 ; i <= n ; i++ )
	{
		cin >> c[i];
		vec[c[i]].push_back(i);
		id[i]=(i+B1-1)/B1;
//		cout << id[i] << " ";
	}
	for ( int i = 1 ; i <= n ; i++ )cin >> a[i];
	for ( int i = 1 ; i <= m ; i++ )
	{
//		cout << i << endl;
		if(vec[i].size()>B2)
		{
			bigblk.push_back(i);
//			cout << "db" << endl;
//			cout << vec[i][0] << endl;
			s[i].push_back(a[vec[i][0]]);
//			cout << "db" << endl;
			for ( int j = 1 ; j < vec[i].size() ; j++ )
				s[i].push_back(a[vec[i][j]]+s[i][j-1]);
//			for ( auto j:s[i] )cout << j << " ";
//			cout << endl;
		}else{
			for ( auto j:vec[i] )sum[id[j]]+=a[j];
		} 
	}
//	cout << "debug" << endl;
	while(q--)
	{
		int op,x,y;
		cin >> op;
		if(op==1)
		{
			cin >> x >> y;
			int ans=0;
			if(id[x]==id[y])
			{
				ans+=getsum(x,y);
//				for ( int i = x ; i <= y ; i++ )
//				{
//					
//				}ans+=a[i];
			}else{
				for ( int i = id[x]+1 ; i < id[y] ; i++ )
					ans+=sum[i];
				ans+=getsum(x,id[x]*B1);
				ans+=getsum(id[y]*B1-B1+1,y);
//				for ( int i = x ; i <= id[x]*B1 ; i++ )
//					ans+=a[i];
//				for ( int i = id[y]*B1-B1+1 ; i <= y ; i++ )
//					ans+=a[i];
			}
			for ( auto i:bigblk )
			{
				int l=lower_bound(vec[i].begin(),vec[i].end(),x)-vec[i].begin();
				int r=upper_bound(vec[i].begin(),vec[i].end(),y)-vec[i].begin()-1;
                if(r<l)continue;
//				cout << i << " " << l << " " << r << endl;
				int siz=vec[i].size();
				l=(l-tag[i]+siz)%siz;
				r=(r-tag[i]+siz)%siz;
//				cout << i << " " << l << " " << r << endl;
				if(l<=r)ans+=s[i][r]-(l!=0)*s[i][l-1];
				else ans+=s[i][r]+s[i][siz-1]-(l!=0)*s[i][l-1];
			}
			cout << ans << endl;
		}else{
			cin >> x;
			if(vec[x].size()>B2)tag[x]++;
			else{
				for ( auto i:vec[x] )sum[id[i]]-=a[i];
				for ( int i = vec[x].size()-1 ; i > 0 ; i-- )
					swap(a[vec[x][i]],a[vec[x][i-1]]);
				for ( auto i:vec[x] )sum[id[i]]+=a[i];
			}
		}
	}
	return 0;
}
```

---


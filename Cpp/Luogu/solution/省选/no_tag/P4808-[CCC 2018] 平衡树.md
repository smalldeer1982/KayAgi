# [CCC 2018] 平衡树

## 题目描述

**题目译自 [CCC 2018](https://cemc.math.uwaterloo.ca/contests/computing/2018/) S4「[Balanced Trees](https://cemc.math.uwaterloo.ca/contests/computing/2018/stage%201/seniorEF.pdf)」**

我们定义「完美平衡树」如下：

每棵完美平衡树都有一个正整数权值。权值为 $1$  的完美平衡树为只含有 $1$  个节点的树。否则，这棵树的权值为 $w(w\ge2)$，则这棵树为一棵含有 $k(2\le k\le w)$ 棵子树的有根树。所有的 $k$ 棵子树都必须是相同的，且它的所有 $k$ 棵子树必须完全相同，且自身是完美平衡的。

特别地，所有 $k$ 棵子树权值必须相同。它们的权值必须为 $\left\lfloor\frac{w}{k}\right\rfloor$ 。例如，如果一棵权值为 $8$ 的完美平衡树有 $3$ 棵子树，那么每棵子树的权值为 $2$，因为 $2+2+2=6\le8$。

给定 $N$，求出权值为 $N$ 的完美平衡树的数量。


## 说明/提示

#### 样例解释 1

合法的树如下：

 - 一棵以有 $4$ 棵权值为 $1$ 的子树为根的完美平衡树；
 - 一棵以有 $2$ 棵权值为 $2$ 的子树为根的完美平衡树；
 - 一棵以有 $3$ 棵权值为 $1$ 的子树为根的完美平衡树。

对于 $33\%$ 的数据，$N\le1000$；  
对于另外 $13\%$ 的数据，$N\le5\times 10^4$；  
对于另外 $13\%$ 的数据，$N\le10^6$；  
对于全部的数据，$1\le N\le10^9$。

## 样例 #1

### 输入

```
4```

### 输出

```
3```

## 样例 #2

### 输入

```
10```

### 输出

```
13```

# 题解

## 作者：PragmaGCC (赞：3)

upd:
2021/4/7 增加了复杂度证明

DP，设 $f(k)$ 为权值为 $k$ 的完美平衡树的方案数。由题意，我们可以得到;
$$
\begin{cases}f(w) = \sum_{k=2}^{n} f(\left\lfloor \dfrac{w}{k}\right\rfloor) & w>1 \\ \\
f(1) = 1
\end{cases}
$$
这是经典的整除分块的式子，可以使用整除分块进行优化。

使用记忆化搜索 + hash 就可以了，更简单的可使用 `unordered_map`。

实际上这就是一个杜教筛，所以和杜教筛的复杂度一样，为$N^{\frac{3}{4}}$。

既然这样，类似于杜教筛的思想，我们可以预先算出前面的一部分，优化后面搜索的复杂度。这里我筛了$10^4$就过了。

证明：

假设预处理了前 $k$ 部分。
$$
\begin{aligned}
T(N)
&=k^\frac{3}{2} + \sum_{i=2}^\frac{n}{k} \sqrt{\frac{n}{i}} \\
&=k^\frac{3}{2} + \int_{2}^\frac{n}{k} \sqrt{\frac{n}{x}} \mathrm dx\\
&=k^\frac{3}{2} + 2\sqrt n (\frac{n}{k})^{\frac{1}{2}}\\
&=k^\frac{3}{2} + 2nk^{-\frac{1}{2}} \\
&\geqslant 2\sqrt{nk}
\end{aligned}
$$
最后一步是均值不等式，当 $k^\frac{3}{2} = 2nk^{-\frac{1}{2}}$ 时取到。

由此可以解出 $k = \sqrt{2n}$ 。

但实际运行过程中还是看情况而定。


```cpp
#include <algorithm>
#include <cstdio>
#include <unordered_map>
typedef long long ll;
const int N = 1e9 + 5, M = 1e4 + 5;
std::unordered_map<int, ll> f;
ll a[M];
int n, m;
int read() {
    register int n = 0, f = 1;
    register char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        n = (n << 3) + (n << 1) + (ch ^ '0');
        ch = getchar();
    }
    return n * f;
}
ll dfs(int n) {
    if (n < m) // 暴力算过了
        return a[n];
    if (f.count(n)) // 记忆化搜过了
        return f[n];
    ll ans = 0;
    for (int l = 2, r = 0; l <= n; l = r + 1) { // 整除分块
        r = n / (n / l);
        ans += dfs(n / l) * (r - l + 1);
    }
    return f[n] = ans;
}
int main(void) {
    n = read(), m = M;
    m = std::min(n, m);
    // m = sqrt(2.0 * n); 这里如果这样做数组要开大些
    a[1] = 1, f[1] = 1;
    for (int i = 2; i < m; i++) { // 暴算
        for (int l = 2, r; l <= i; l = r + 1) {
            r = i / (i / l);
            a[i] += a[i / l] * (r - l + 1);
        }
    }
    printf("%lld\n", dfs(n));
    return 0;
}
```



---

## 作者：斯茂 (赞：3)

## 题目考点：STL

题意：求d(n)，其中
```
d(x) = Sum(d(x / i)) i = 2, 3, ..., x
```

### 暴力算法 Subtask 0

直接转移，复杂度n方

### 整除分块 Subtask 1

熟悉数论的应该都知道n / i只有与根号n同阶那么多取值

所以转移的时候可以整除分块优化一下

复杂度n根号n

### 记忆化搜索 Subtask 2

注意到不是每个<= n的x的d值都会被用到，那么我们也不用全都计算

记忆化搜索，用一个Map保存已经计算过的值

复杂度???*logn

### unordered_map Subtask 3

虽然我比较菜，不会算上面算法的复杂度

但我知道Map是log的，而手写哈希是O(1)的

但我又不想写双关键字的哈希

所以自然地想到unordered_map(其实就是哈希)

注意头文件和namespace要加tr1

复杂度???

### 代码
```
#include <cstdio>
#include <iostream>
#include <tr1/unordered_map>
using namespace std;
using namespace std::tr1;
unordered_map <int, long long> mp;
long long dfs(int x)
{
	if(x == 1) return 1;
	if(mp[x]) return mp[x];
	int i, j; long long val = 0;
	for(i = 1; i <= x; i = j + 1)
	{
		j = x / (x / i);
		if(i != 1) val += dfs(x / i) * (j - i + 1);
	}
	return mp[x] = val;
}
int main(int argc, char **argv)
{
	int n;
	scanf("%d", &n);
	printf("%lld\n", dfs(n));
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：2)

可以列出如下递归式 :  
$$
f_x = \sum_{k = 2}^{n} f(\lfloor \frac{x}{k} \rfloor) \quad  \quad x >1
$$
$$f_1 = 1$$
对于 $k \in [2, n]$ 的  $\lfloor \frac{n}{k} \rfloor$  可以使用整除分块的套路来统计。整除分块中, 对于 $\lfloor \frac{N}{i} \rfloor$ , 使 $\lfloor \frac{N}{i'} \rfloor$ 等于它的最大的 $i'$ 为 $\lfloor \frac{N}{\lfloor \frac{N}{i} \rfloor} \rfloor$。     
技巧 : 把整除分块的结果映射到连续数列上。设结果为 $x$ 。对于 $x \leqslant \sqrt N$ 的结果显然是连续的, 映射到 $x$ 本身。对于 $x > \sqrt N$ 的结果显然有 $\frac{N}{x} < \sqrt N$。映射到 $\sqrt N + x$ 。  
状态数 $\mathcal{O(\sqrt N)}$ 。记忆化搜索一下就好了。
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int M = 400010;
ll f[M]; 
int n, sqn;
inline int toId(int x) {
	return x <= sqn ? x : n / x + sqn;
}

ll solve(int n) {
	int fid = toId(n);
	if(~f[fid]) return f[fid];
	if(n == 1) return 1;
	ll ans = 0;
	int r = 0;
    for(int k = 2; k <= n; k = r + 1) {
		r = n / (n / k);
		ans += r >= k ? (r - k + 1) * solve(n / k) : 0;
    }
    return f[fid] = ans;
}

int main() {
	memset(f, -1, sizeof(f));
    cin >> n;
    sqn = sqrt(n);
    cout <<solve(n) << endl;
    return 0;
}
```

---

## 作者：Ebola (赞：2)

# 【CCC2018】完美平衡树

题目其实就是要你求：$f(w)=\sum\limits_{k=2}^wf(\left\lfloor\frac{w}{k}\right\rfloor)$

这似乎是一个裸题？直接整除分块，然后记搜求$f(\left\lfloor\frac{w}{k}\right\rfloor)$就完事了？

嗯，实测只能拿到59分。[这是提交记录](https://www.luogu.org/recordnew/show/16436720)

办法总是有的。我们借鉴杜教筛的思想，先预处理一小部分的$f$值。因为求$f(w)$的复杂度是$O(\sqrt{w})$，所以预处理的复杂度是$O(n\sqrt{n})$

然后小心地调一波参，发现$n=50000$的时候就过了

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const int N=50000;
unordered_map<int,LL> f;
LL _f[N];

LL F(int w)
{
    if(w<N) return _f[w];
    if(f.count(w)) return f[w];
    LL res=0;
    for(int k=2,dv;k<=w;k=dv+1)
    {
        dv=w/(w/k);
        res+=F(w/k)*(dv-k+1);
    }
    return f[w]=res;
}

int main()
{
    _f[1]=1;
    for(int w=2;w<N;w++)
        for(int k=2,dv;k<=w;k=dv+1)
        {
            dv=w/(w/k);
            _f[w]+=_f[w/k]*(dv-k+1);
        }
    int n;cin>>n;
    cout<<F(n)<<endl;
    return 0;
}
```

---

## 作者：Great_Influence (赞：2)

本题经过转换之后，可以得到以下等价问题:

有一个数字$N$，你每次可以选择数字$k\in[2,N]$，并将$N$变成$\lfloor\frac{N}{k}\rfloor$。当$N$等于$1$停止。问有多少种不同的操作方案。

首先，可以列出一个$dp$:

$$\forall k\in[2,N],dp[n/k]+=dp[n]$$

这样直接做是$O(n^2)$的。但是可以发现，$\displaystyle\lfloor\frac{N}{k}\rfloor$只有$\sqrt N$种不同的取值，再根据式子$\displaystyle\lfloor\frac{\lfloor\frac{N}{x}\rfloor}{y}\rfloor=\lfloor\frac{N}{xy}\rfloor$(证明请自己想)可以得出有效的$dp$位置只有$\sqrt N$个。因此，我们将这一部分单独提出来做转移。时间时间就优化到了一个略大于$O(N)$的复杂度，仍然无法承受。

但是同时也可发现，$\displaystyle\lfloor\frac{N}{k}\rfloor$会有连续一段取相同的值。我们可以利用整除分块将单次转移从$O(num)$优化到$O(\sqrt{num})$。此时的过程和未预处理的杜教筛相同，时间复杂度为$\displaystyle O(N^{\frac{3}{4}})$。

代码:
```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
#endif
}

const int MAXN=1e5+7;

static int n;

inline void init(){read(n);}

static int num[MAXN],e,id1[MAXN],id2[MAXN];

static uint64 dp[MAXN];

inline void solve()
{
	static int i,las;
	for(i=1;i<=n;i=las+1)
	{
		num[++e]=n/i;
		n/i<MAXN?id1[n/i]=e:id2[n/(n/i)]=e;
		las=n/(n/i);
	}
	dp[1]=1;
	static int t;
	Rep(j,1,e)
	{
		if(dp[j])for(i=2;i<=num[j];i=las+1)
		{
			las=num[j]/(num[j]/i);
			t=num[j]/i<MAXN?id1[num[j]/i]:
				id2[n/(num[j]/i)];
			dp[t]+=dp[j]*(las-i+1);
		}
	}
	printf("%llu\n",dp[e]);
}

int main()
{
    init();
    solve();
    return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：0)

NOIP 能不能给我出这种题啊？？？

### Solution

首先一眼丁真有递推式

$$f_i=\sum_{2\le j\le i}f_{\lfloor\frac ij\rfloor}$$

考虑直接记搜。然后你发现这不就求是 $f$ 的块筛吗，跟朴素杜教筛一个复杂度 $O(n^{\frac 34})$。

然后发现 `map` 会被卡常，于是使用经典技巧：开静态数组，如果 $i\le \sqrt n$ 则访问 $i$，否则访问 $\lfloor\frac{n}{i}\rfloor+\sqrt n$ 即可。

另外还可以用杜教筛的那个根号分治进一步优化常数，但是我比较懒所以没搞。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=1e5+5;
int global_n,B;
ll f1[N],f2[N];
ll calc(int n){
	if(n==1)return 1;
	if(n<=B&&f1[n])return f1[n];
	if(n>B&&f2[global_n/n])return f2[global_n/n];
	ll res=0;
	for(int l=2,r;l<=n;l=r+1){
		r=n/(n/l);
		res+=(r-l+1)*calc(n/l);
	}
	return (n<=B?f1[n]:f2[global_n/n])=res;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>global_n;B=sqrt(global_n);
	cout<<calc(global_n)<<'\n';
	return 0;
}
```

---

## 作者：toolazy (赞：0)

兜了一圈发现连个正确的时间复杂度都没有，过来踢两脚的。

---

题目直接把递推式子都糊你脸上了你还不会做就不厚道了蛤：

$$f(x)=\begin{cases}
1,&x=1\\
\displaystyle\sum_{k=2}^xf\Big(\Big\lfloor\frac xk\Big\rfloor\Big),&x>1
\end{cases}$$

式子都不带推的那种独脚筛，时间复杂度 $O(n^\frac34)$ 妥妥够。

---

下面是对时间复杂度的分析。

>首先要知道数论分块的两个性质。
>
>- $\textbf{Lemma 1.}$（取值的基数）
>
>    我们定义 $n$ 的数论分块的取值分布 $R(n)$：
>    $$
>    R(n)=\bigg\{\Big\lfloor\frac nk\Big\rfloor\ \bigg|\ 2\le k\le n\bigg\}
>    $$
>    则有 $|R(n)|=O(\sqrt n)$。
>
>    $\textbf{Proof: }$ 我们对 $k$ 进行分讨。
>
>    一部分，当 $k\le\sqrt n$ 时，$k$ 至多有 $\sqrt n$ 种取值，故 $\displaystyle\Big\lfloor\frac nk\Big\rfloor$ 至多有 $\sqrt n$ 种取值；
>
>    另一部分，当 $k>\sqrt n$ 时，$\displaystyle\Big\lfloor\frac nk\Big\rfloor<\sqrt n$ 且其为单调不增函数，故至多有 $\sqrt n$ 种取值。
>
>    两部分相加，则与 $|R(n)|\le2\sqrt n=O(\sqrt n)\ \ \blacksquare$
>
>- $\textbf{Lemma 2.}$（取值的包含性）
>
>    对于 $m\in R(n)$，则有 $R(m)\subset R(n)$。
>
>    $\textbf{Proof: }$ 记 $m=\displaystyle\Big\lfloor\frac na\Big\rfloor$，则：
>    $$
>    R(m)=\bigg\{\Big\lfloor\frac n{ab}\Big\rfloor\ \bigg|\ 2\le b\le m\bigg\}
>    $$
>    注意到 $2\le ab\le n$ 故 $\displaystyle\Big\lfloor\frac n{ab}\Big\rfloor\in R(n)\ \ \blacksquare$
>
>综上，可以发现，对于求解 $S(n)$，由 $\textbf{Lemma 1\&2.}$ 可得我们的状态数确实是 $O(\sqrt n)$ 的，但这并不意味着时间复杂度就是 $O(1)$ 的，我们需要更加深入的分析。
>
>由 $\textbf{Lemma 2.}$ 可知，每个状态只要转移一次；既然各状态独立，那我们仿照 $\textbf{Lemma 1.}$，也对 $k$ 进行分讨：
>
>- $k\le\sqrt n$，这部分的时间复杂度即为：
>
>  $$
>  \sum_{k=1}^{\lfloor\sqrt n\rfloor}O\Bigg(\Bigg|R\bigg(\Big\lfloor\frac nk\Big\rfloor\bigg)\Bigg|\Bigg)=\sum_{k=1}^{\lfloor\sqrt n\rfloor}O\Bigg(\sqrt\frac nk\Bigg)
>  $$
>
>- $k>\sqrt n$，即 $m<\sqrt n$，这部分的时间复杂度即为：
>  
>  $$
>  \sum_{m=1}^{\lfloor\sqrt n\rfloor}O\Big(\Big|R(m)\Big|\Big)=\sum_{m=1}^{\lfloor\sqrt n\rfloor}O\big(\sqrt m\big)
>  $$
>
>离散求和不好求，我们用连续积分积一下，反正 $\Delta x=1$ 不会差多少（
>
> $$
> O\Bigg(\int_0^{\sqrt n}\sqrt{\frac nk}\ \text{d}k\Bigg)+O\Bigg(\int_0^{\sqrt n}\sqrt m\ \text{d}m\Bigg)=O(n^\frac 34)
> $$
>
>我们可以利用相同的方式，计算预处理了 $m\in[1,K]$ 后的杜教筛的时间复杂度（要求 $K\ge O(\sqrt n)$）：
>
>只有状态 $K<m\le n$ 才需要转移，对应的，可得 $\displaystyle K<\frac nk\le n$，变换可得 $1\le k<\displaystyle\frac nK$。
>
>所以，预处理（设其时间复杂度为 $O(T)$）和杜教筛主体的时间复杂度之和为：
>$$
>T(K)+\sum_{k=1}^{\lfloor\frac nK\rfloor}O\Bigg(\Bigg|R\bigg(\Big\lfloor\frac nk\Big\rfloor\bigg)\Bigg|\Bigg)=T(K)+\sum_{k=1}^{\lfloor\frac nK\rfloor}O\Bigg(\sqrt\frac nk\Bigg)
>$$
>依旧是使用积分代替和式：
>$$
>T(K)+O\Bigg(\int_0^\frac nK\sqrt\frac nk\ \text{d}k\Bigg)=T(K)+O\bigg(\frac n{\sqrt K}\bigg)
>$$
>
>如果经计算后得到比 $O(n^\frac 34)$ 更劣的时间复杂度，那么你的 $K$ 一定没到 $O(\sqrt n)$。
>
>至于为什么，~~留作习题读者自证~~，其实你看推导的式子就知道了。

---

但！是！这题没有线性的预处理，只能 $O(K^\frac 32)$ 暴算。

> **时间复杂度推导**
>
> 根据我们的算法，有 $O(T)=O(K^\frac 32)$，带入上式即得：
>
> $$
> O(K^\frac 32)+O\bigg(\frac n{\sqrt K}\bigg)
> $$
>
> 两部分，左边是单调增，右边是单调减，明显两部分持平时时间复杂度最优：
>
> $$
> O(K^\frac 32)=O\bigg(\frac n{\sqrt K}\bigg)
> $$
>
> 两边同时取对数，即得：
>
> $$
> \frac 32\ln K=\ln n-\frac 12\ln K
> $$
>
> 解得 $\displaystyle\ln K=\frac 12\ln n$，即 $K=\Theta(\sqrt n)$ 时时间复杂度最优。
>
> 回代可得时间复杂度仍未 $O(n^\frac 34)$。

但是确实需要这个常数优化，因为 `unordered_map` 的常数太大了 qwq。（建议是放在 $5\times10^4$ 的样子

以及，不要全用 `unordered_map` 存，预处理的部分直接用 `int[]` 存就好，会快很多。（我的实现是 $500\text{ ms}$ 的

（后来听说这东西是可以上 Dirichlet 前缀和的 Polylog？不知道，没了解过。

---

## 作者：bluewindde (赞：0)

根据题意，设 $f_i$ 表示权值为 $i$ 的『完美平衡树』的数量，有

$$f_i=\sum\limits_{2\le k\le n}{f_{\left\lfloor\frac{i}{k}\right\rfloor}},f_1=1$$

显然可以借助记忆化写出暴力实现，然后 T 飞。

容易想到将递推式进行变换，从而找出其中数据之间的关联，降低计算次数。

显然在某段区间内这个式子的值一定，该区间的左右边界 $[l,r]$ 有（推导给个[链接](https://zhuanlan.zhihu.com/p/617878247)）

$$r=\left\lfloor\frac{n}{\left\lfloor\frac{n}{l}\right\rfloor}\right\rfloor$$

但是因为 $n$ 十分大，一个一个推仍然容易超时（代码实现中必须要用 `unordered_map`，显然死因是大常数），类似杜教筛，预处理一部分 $f_i$，取边界值为 $\sqrt{10^9}=31622$，不吸氧最坏 848 ms（有一篇题解给出的边界值为 $50000$，最坏 886 ms）。

```cpp
#include <iostream>
#include <unordered_map>

#define int long long

using namespace std;

const int N = 31622;

int n;
int store[N + 5];
// 标准的数组开不到 1e9
unordered_map<int, int> f;

static inline int F(int w)
{
    if (w < N) {
        return store[w];
    }
    if (f.count(w)) {
        return f[w];
    }
    int res = 0;
    for (int l = 2; l <= w;) {
        int r = w / (w / l);
        res += F(w / l) * (r - l + 1);
        l = r + 1;
    }
    return f[w] = res;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    store[1] = 1;
    for (int w = 2; w < N; ++w) {
        for (int l = 2; l <= w;) {
            int r = w / (w / l);
            store[w] += store[w / l] * (r - l + 1);
            l = r + 1;
        }
    }
    cin >> n;
    cout << F(n) << endl;
    return 0;
}
```

---


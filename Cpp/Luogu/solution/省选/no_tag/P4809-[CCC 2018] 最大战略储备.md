# [CCC 2018] 最大战略储备

## 题目描述

**题目译自 [CCC 2018](https://cemc.math.uwaterloo.ca/contests/computing/2018/) S5「[Maximum Strategic Savings](https://cemc.math.uwaterloo.ca/contests/computing/2018/stage%201/seniorEF.pdf)」**

有 $N$ 个星球，编号为 $1\ldots N$。每个星球有 $M$ 座城市，编号为 $1\ldots M$。我们将 $e$ 星球上的城市 $f$ 记作 $(e,\,f)$。

有 $N\times P$ 条双向航线，对于每个星球 $e(1\le e\le N)$，有 $P$ 条航线，编号为 $1$ 到 $P$。第 $i$ 条航线连接城市 $(e,\,a_i)$ 和 $(e,\,b_i)$，且每天需要花费 $c_i$ 的代价维护。

有 $M\times Q$ 个双向港口。对于所有编号为 $f(1\le f\le M)$ 的城市，有 $Q$ 个港口，编号为 $1$ 到 $Q$。第 $j$ 个港口可以连接城市 $(x_j,\,f)$ 和 $(y_j,\,f)$，且每天需要花费 $z_j$ 的代价维护。

现在需要拆除一些港口和（或）取消一些航线，使得城市之间仍能保持联通，且节省的代价之和最大。

## 说明/提示

#### 样例 2 解释
一种可行的最优解是关闭城市 $(1,\,1)$ 与 $(1,1)$、$(2,\,1)$ 与 $(2,\,1)$、$(1,\,1)$ 与 $(1,\,2)$、$(1,\,3)$ 与 $(1,\,2)$、$(2,\,3)$ 与 $(2,\,2)$ 之间的航线；并关闭城市 $(2,\,3)$ 与 $(1,\,3)$ 间的港口。最终可以节省 $8 + 8 + 6 + 7 + 7 + 5 = 41$ 的代价。

对于 $\frac{2}{15}$ 的数据，$P,\,Q\le100$，且对于所有的 $1\le i\le P$，都有 $c_i=1$；对于所有的 $1\le j\le Q$，都有 $z_j=1$；

对于另外 $\frac{2}{15}$ 的数据，$P,\,Q\le 200$；

对于另外 $\frac{5}{15}$ 的数据，$N,\,M\le 200$；

对于全部的数据，$1\le N,\,M,\,P,\,Q\le10^5$。

## 样例 #1

### 输入

```
2 2 1 2
1 2 1
2 1 1
2 1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
2 3 4 1
2 3 5
3 2 7
1 2 6
1 1 8
2 1 5```

### 输出

```
41```

# 题解

## 作者：VictorYuan (赞：9)

本蒟蒻的第一篇题解。

写题解原因：（看题解的同学可以跳过）

我在考试的时候的一道题与这道题十分相似，场上写出了bug，晚上又调了一个半小时才通过。我想已经在这道题上用了三个小时了，不如写个题解，加深一下印象。


------------
## 以下是正文
首先，通过读题，我们不难发现，问题可以转化成：一个N*M的无向图，我们需要删掉尽量多的权值较大边，使这张图依旧是联通的，求这些被删掉的边的权值之和。

我们知道，对于一个有n个点的图，我们最少需要n-1条边，把它们连成一个联通快，此时这张图是一个树。继续分析，因为我们要删掉尽量多的边，就是指剩下的边数最小;删掉权值较大的边，就是指要剩下的边权值较小。所以问题转化成：对于一个有n个点的无向图，我们需要连起来n-1条权值较小的边，使这时的边权值和最小。此时，我们只需把所有边权值之和再减去这个最小值，就是题目要求的最大值。而求这个最小值的过程，本质上就是**最小生成树**。所以本题就是一个求最小生成树的题。

但我们看数据范围：![](https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/d1160924ab18972bf53484fbe8cd7b899e510af0.jpg)

N，M，P，Q都是十万以内，所以乘起来最多有一百亿个点！如果只用简单的最小生成树去做复杂度是吃不消了，所以我们需要更加深入地研究。

这里，我们以样例二为例，探索这道题的特殊性。

我们首先试图以所有边同时跑的Kruskal算法解决这道题。把所有边排序后，我们发现最短的边是一条横向边，连接某一行的2与3，那么这里我们可以判断，每一行的2和3这两个点，都会用到这一条边连接，因为这条边的权值最小，所以进行这样的操作，最后得到的答案一定是最优的，综上我们发现，对于一些边，我们只需要取一些代表表示，因为我们并不关心他的具体为止，所以这些代表可以看做是题目输入的边，这样我们就把边数压缩到了P+Q，这时我们再横纵跑两遍Kruskal就可以解决问题了。

但这道题还有一个细节。我们发现，如果一直按上面的做法，横向找出M-1条边，每条边使用N次，纵向找出N-1条边，每条边使用M次，最后共用 (M-1) * N + (N-1) * M = 2MN - M - N  条边，而实际上我们只需要 MN - 1 条边，二者之差为 MN - M - N + 1 ，很显然它们并不相同，所以我们还需要对本题进行进一步分析。

为了分析，首先，我们画出把上一步中的边连起来后的图形

![](https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/359b033b5bb5c9ea8d3187d2db39b6003bf3b3c5.jpg)

排完序后，下一条边是一条纵向边，连接1与2，然后我们开始连边，但此时我们发现，我们不需要连M次，因为我们连到下图状态时，再向后连并不会起到把两棵树块合并到一起的作用，所以它没有连M次，而是M-1次。

![](https://gss0.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/c2fdfc039245d688d97b3495aac27d1ed21b2481.jpg)

同样的，我们继续进行，最小的边是横向边，连接1与2，我们也只需要连接N-1次可以了，下图就是最终的最小生成树。

![](https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/962bd40735fae6cd590a2d5001b30f2442a70f40.jpg)

那么我们现在需要解决的问题是，每一次找到一条边，判断出需要使用它几次。

还是从开始连边分析。不难发现：我们完全可以把每一个连通块看做一个点，于是上述过程就可以用下面的图表示。

第一步连边

![](https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/f11f3a292df5e0fe50e97d30526034a85edf720a.jpg)

下一步

![](https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/b3119313b07eca80f212ced69f2397dda14483e8.jpg)

最后
![](https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/f31fbe096b63f624138ccd328944ebf81a4ca32a.jpg)

这样，最后只剩一个点，我们就把它合成了一个连通块。

分析：我们发现，如果之前没有连边，那么这一条边所代表的所有边都是需要连的，但我们在连了一条横边之后，在上图表示的信息为列数减一，即M-1，而因为M还表示一条纵边需要连的次数，所以，我们在求出一条纵边之后通过此时M的值可以知道它会连几条；同理，我们在连了一条纵边之后，相对应的N也会减一，对横边的影响也是如此。所以我们在跑Kruskal时要横纵同时跑，每次选边都更新一下M与N的值，这样跑到最后，我们就可算出这张图的最小生成树。

做法总结：我们需要挑出一行和一列做代表，选出在代表的行或列的所有边，本应横纵各跑一次最小生成树，但为了随时得到M与N的值，我们需要把横纵边放在一起跑最小生成树，这样我们就能得到全图的最小生成树，用所有边权之和减去这个最小生成树的权值和，就是最终答案。

如果还没有看懂，看看代码会加深一下理解

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;

struct node
{
	long long int x,y,z;//存放连的两个点和边长 
};
node a[100010],b[100010];//a数组存横边，b数组存纵边 
bool cmp(const node &ac,const node &wa)
{
	return ac.z<wa.z; 
}


long long int i,j,p,q,n,m,he=1,zo=1,fa,fb;
long long int faz[100010],fah[100010];
long long int ans=0,maxn=0;


long long int findz(long long int son)//横纵用两个并查集，因为我们需要横纵跑两个最小生成树 
{
	if(faz[son]==son) return son;
	faz[son]=findz(faz[son]);
	return faz[son];
}
long long int findh(long long int son)
{
	if(fah[son]==son) return son;
	fah[son]=findh(fah[son]);
	return fah[son];
}


int main()
{
	cin>>n>>m>>p>>q; 
	for(i=1;i<=p;i++)
	{
		scanf("%ld%ld%ld",&a[i].x,&a[i].y,&a[i].z);
		maxn+=a[i].z*n;//计算横边总权值 
	}
	for(i=1;i<=q;i++)
	{
		scanf("%ld%ld%ld",&b[i].x,&b[i].y,&b[i].z);
		maxn+=b[i].z*m;//计算纵边总权值
	}
	sort(a+1,a+p+1,cmp);//对横纵边分别从小到大排序 
	sort(b+1,b+q+1,cmp);
	
	
	
	
	for(i=0;i<=100001;i++)//初始并查集 
	{
		fah[i]=i;
		faz[i]=i;
	}
	
	
	while((m>1)&&(n>1))//注意这里的写法，只要横纵边有一个跑完了最小生成树，就退出循环 
	{
		if(a[he].z<b[zo].z)// 横纵边同时跑最小生成树，每次选出边权最小的判断是否加入加入其所在的树 
		{//横边较小的情况 
			fa=findh(a[he].x); fb=findh(a[he].y);
			if(fa!=fb)
			{
				fah[fa]=fb;
				--m;//减少纵边的需要数量 
				ans+=n*a[he].z;//最小生成树加上它的边权乘它的数量 
			}
			he++;
		}
		else 
		{//纵边较小的情况 
			fa=findz(b[zo].x); fb=findz(b[zo].y); 
			if(fa!=fb)
			{
				faz[fa]=fb;
				--n;//减小横边的需要数量 
				ans+=m*b[zo].z;//最小生成树加上它的边权乘它的数量 
			}
			zo++;
		}
	}
	
	
	while(m>1)//纵边已经连完，而横边还没连完，就继续连横边 
	{
		fa=findh(a[he].x); fb=findh(a[he].y);
		if(fa!=fb)
		{
			fah[fa]=fb;
			--m;
			ans+=a[he].z;//由于M大于1，所以N一定等于1 
		}
		he++;
	}
	
	
	while(n>1)//横边已经连完，而纵边还没连完，就继续连纵边
	{
		fa=findz(b[zo].x); fb=findz(b[zo].y);
		if(fa!=fb)
		{
			faz[fa]=fb;
			--n;
			ans+=b[zo].z;//由于N大于1，所以M一定等于1 
		}
		zo++;
	}
	
	cout<<maxn-ans<<endl;//最终答案为所有边权值之和减最小生成树的边权值和 
	return 0;
}

```

---

## 作者：woshiren (赞：4)

[Luogu P4809](https://www.luogu.com.cn/problem/P4809)

这题很显然是要求最小生成树，但是看到数据范围，边数和点数都非常的多，所以暴力Kruskal并不可行。

优化求最小生成树的算法流程明显不可行，因为如果可优化的话那么这个算法的优化应该早就广为人知了。

所以从另一个方向想，找找这题的特殊性质。

我们可以发现每个星球内部的$P$条航线的结构是一样的，而对于星球之间的城市的$Q$个港口结构也是一样的。Kruskal的算法流程中我们会对边按权值排序，换而言之：对于每个星球内部的同一类航线，由于权值相等，只要端点还不联通，我们都会选出来；对于港口同理。

那么也就是说我们只需要考虑$P+Q$条边即可，每次决策都相当于决策了一大堆边。

但是尽管我们一次可以选出很多条边，但是我们不难发现一个问题，每次连的边的数量并不一定是$n$或者$m$条。

利用样例举个例子：

```
2 2 1 2
1 2 1
2 1 1
2 1 1
```

可以发现我们会选择`1 2 1`和`2 1 1`这条边。对于第一条边，我们需要加入两条；对于第二条，如果加入两条，明显有一条可以去除。

![QD1F1.png](https://b1.sbimg.org/file/chevereto-jia/2020/11/27/QD1F1.png)

很明显，黄色的边是不必要的。

那么如何具体的求出这个数量成为了当前要解决的问题。

考虑连一条边造成了什么影响。

**从网格图上看，可以认为第一条边连上去之后把第一列和第二列合并了。换而言之，少了一列，那么连列内部的边时就少了一条。**

所以，每连一条航线，就会让下一次选出港口时需要的数量$-1$，反之亦然。

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int n,m,p,q,size[100005][2],fa[100005][2],u,v,w,cnt,ans;
struct DATA
{
	int to,sta,val,flag;
	bool operator<(const DATA &x) const 
	{
		return val<x.val;
	}
}e[200005];
int getf(int v,int x)
{
	if (fa[v][x]==v) return fa[v][x];
	else return fa[v][x]=getf(fa[v][x],x);
}
void merge(int x,int y,int p)
{
	x=getf(x,p),y=getf(y,p);
	if (size[x][p]>size[y][p]) swap(x,y);
	fa[x][p]=y;
	size[y][p]+=size[x][p];
}
bool check(int x,int y,int p)
{
	x=getf(x,p),y=getf(y,p);
	return x==y;
}
signed main()
{
	scanf("%lld%lld%lld%lld",&n,&m,&p,&q);
	for (int i=1;i<=p;i++)
	{
		scanf("%lld%lld%lld",&u,&v,&w);
		e[++cnt].sta=u;
		e[cnt].to=v;
		e[cnt].val=w;
		e[cnt].flag=1; 
		ans+=w*n;
	}
	for (int j=1;j<=q;j++)
	{
		scanf("%lld%lld%lld",&u,&v,&w);
		e[++cnt].sta=u;
		e[cnt].to=v;
		e[cnt].val=w;
		e[cnt].flag=0;
		ans+=w*m;
	}
	for (int i=1;i<=n;i++)
		fa[i][0]=i,size[i][0]=1;
	for (int i=1;i<=m;i++)
		fa[i][1]=i,size[i][1]=1;
	sort(e+1,e+1+cnt);
	int chosen=0,i=1,tn=n,tm=m;
	while (chosen<tn*tm-1)
	{
		int u=e[i].sta,v=e[i].to,w=e[i].val,f=e[i].flag;
		if (!check(u,v,f))
		{
			merge(u,v,f);
			if (!f) ans-=w*m,n--,chosen+=m;
			else ans-=w*n,m--,chosen+=n;
		}
		i++;
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：klii (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/P4809)


**一种较容易理解的方法？**



------------
## Solution

最朴素的暴力显然是将所有的边存下来跑一遍最小生成树，然鹅边数过大并不可行。

可以发现题目中的图分为$n$层， 每层$m$个点的联通情况是相同的。

考虑将这个图转化为一个网格图， 对于每一层的点跑一遍最小生成树，不同层的同一个点（指编号相同）跑一遍最小生成树。（实际上，由于每行每列都一样，**只需要分别跑一行一列即可**。）

然后图大概变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/f5xyzxwo.png)

**对于横向的边，是否保留取决于这条边右边的纵向边**，举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/fgjv8tmy.png)

若红色的边的边权值比绿色小，则保留红色边，删除绿色边，反之同理。

暴力枚举每一条红边？ $O（$nm$）$ 显然是不行的。

考虑到**每一层都是相同的**，可以只枚举一层，每次都查询一条红边能在多少层保留，在多少层删除，这个可以用**树状数组**解决，于是就完了。

附~~丑陋的~~参考代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
const ll N = 1e5 + 5;
struct Edge1 {
	ll u, v, w;
}e[N];
struct LSH{
	ll x, id;
}lsh[N];
struct Edge {
	ll to, dis, nxt;
}E[N << 1];
ll n, m, p, q, fa[N], ans, cnt, head[N], tot;
ll res0, res1, T1[N], T2[N], sum, g[N];
void addedg(ll u, ll v, ll w) {
	E[++cnt].to = v; E[cnt].dis = w;
	E[cnt].nxt = head[u]; head[u] = cnt;
}
bool cmp(Edge1 x, Edge1 y) {
	return x.w < y.w;
}
bool cmp1(LSH a, LSH b) {
	return a.x < b.x;
}
ll root(ll x) {
	return fa[x] == x ? x : fa[x] = root(fa[x]);
}
void add(ll x, ll y) { 
	for (; x <= tot; x += x&-x) T1[x] += y, T2[x]++;
}
void ask(ll x) {
	for (; x; x -= x&-x) res0 += T1[x], res1 += T2[x];
}
ll find(ll x) {
	ll l = 0, r = tot + 1;
	while (l + 1 < r) {
		ll mid = (l + r) >> 1;
		if (g[mid] > x) r = mid;
		else l = mid;
	}
	return l;
}
void dfs(ll u, ll fath) {
	for (ll i = head[u]; i; i = E[i].nxt) {
		ll v = E[i].to;
		if (v == fath) continue;
		res0 = res1 = 0;
		ask(find(E[i].dis));
		ans += res0 + (n - res1) * E[i].dis;
		dfs(v, u);
	}
}
int main() {
	scanf("%lld%lld%lld%lld", &n, &m, &p, &q);
	for (ll i = 1; i <= m; i++) fa[i] = i;
	for (ll i = 1; i <= p; i++) {
		scanf("%lld%lld%lld", &e[i].u, &e[i].v, &e[i].w);
		sum += e[i].w * n;
	}
	sort(e + 1, e + 1 + p, cmp);
	for (ll i = 1; i <= p; i++) {
		ll x = root(e[i].u), y = root(e[i].v);
		if (x == y) continue;
		fa[y] = x;
		addedg(e[i].u, e[i].v, e[i].w);
		addedg(e[i].v, e[i].u, e[i].w);
	}
	for (ll i = 1; i <= n; i++) fa[i] = i;
	for (ll i = 1; i <= q; i++) {
		scanf("%lld%lld%lld", &e[i].u, &e[i].v, &e[i].w);
		sum += e[i].w * m;
		lsh[i].x = e[i].w;
		lsh[i].id = i;
	}
	tot = 0;
	sort(lsh + 1, lsh + 1 + q, cmp1); //离散化 
	for (ll i = 1; i <= q; i++) {
		if (lsh[i].x != lsh[i - 1].x) g[++tot] = lsh[i].x;
		e[lsh[i].id].w = tot;
	}
	sort(e + 1, e + 1 + q, cmp);
	for (ll i = 1; i <= q; i++) {
		ll x = root(e[i].u), y = root(e[i].v);
		if (x == y) continue;
		ans += g[e[i].w]; //最左边的纵边必须保留（确保联通 
		fa[y] = x;
		add(e[i].w, g[e[i].w]); //将绿边加入树状数组 
	}
	dfs(1, 0);
	printf("%lld", sum - ans); //总的边权 - 最小生成树边权 = 节省的代价和 
	return 0;
}
```

如有疑问可私信或在评论区回复，感谢阅读！

---

## 作者：SalN (赞：3)

[link](https://www.luogu.com.cn/problem/P4809)

也可以在 [这里](https://www.cnblogs.com/chelsyqwq/p/17629812.html) 看（

最无聊的时候写的最~~啰嗦~~详细的题解。

----

#### 题目描述

给定一个 $n\times m$ 的点阵和两类边，第 $i$ 行 $j$ 列的城市我们叫祂城市 $(i,j)$。

横边：给定 $p$ 个三元组 $(u_i,v_i,w_i)$，表示 对于 $a=1,2,\dots,n$，城市 $(a,u_i)$ 和 $(a,v_i)$ 之间有一条权为 $w_i$ 的边。

纵边：给定 $q$ 个三元组 $(x_i,y_i,z_i)$，表示 对于 $b=1,2,\dots,n$，城市 $(x_i,b)$ 和 $(y_i,b)$ 之间有一条权为 $z_i$ 的边。

在保持全部点联通的前提下删去一些边，问删去边权值和最大是多少。

$n,m,p,q\leq10^5$

----

#### 题目解法

首先「最大化删除边权和」相当于「最小化剩余边权和」，后者是最小生成树。暴力的，我们可以建出所有的点和边去跑 Kruskal，边数 $g=np+mq$，这样子复杂度是爆炸的 $O(g\log g+g\alpha(g))$。

我们观察到这玩意复杂度在排序的地方很瓶颈，考虑到很多边形式相同，我们可以不先展开 $a,b$ 再排序，而是先排序规则，Kruskal 的时候再展开，这样复杂度变成了 $O((p+q)\log(p+q)+g\alpha(g))$，已经好很多了，但是还是不够。

我们手玩一下 Kruskal 的过程（嫌麻烦可以直接看 p5（（（

![](https://cdn.luogu.com.cn/upload/image_hosting/h5ye1rih.png)

~~这条边，「大千世界，畅通无阻」。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/9ljmpz2g.png)

我们发现因为第二行和第二行每一列都联通了，于是乎可以在 $a=1,2$ 中二选一，少连一条边！！！（（（

![](https://cdn.luogu.com.cn/upload/image_hosting/7rhnornv.png)

跟上一步差不多，因为第三行第五行每一列联通，所以 $b=3,5$ 还是二选一 qwq（

![](https://cdn.luogu.com.cn/upload/image_hosting/acra4hmm.png)

发现是 $a=1,2$ 二选一，$a=3,5$ 二选一，加上 $a=4$ 呀 /youl

![](https://cdn.luogu.com.cn/upload/image_hosting/fgpo506s.png)

发现这样子本来就是联通的捏，那就不用连啦（（（（（

手玩完了之后，我们发现一个小结论，新加一种边其实就是给每一个联通块（定义是缩行缩列后的那种）加上一条边，意思是设把每列缩成一个点的联通块个数为 $r$，设把每行缩成一个点的联通块个数设为 $c$。横边的话要加 $r$ 条，纵边的话要加 $c$ 条。

假设我们现在选了 $r$ 种横边 $c$ 种纵边，显然 $i=n-r,j=m-c$。然后联通拿普通 dsu 随便维护就可以了。复杂度 $O((p+q)\log(p+q))$。

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N=5e6+10;
int n, m, p, q, tot, fa[N], cl, cr, ans, sum;
struct dat { int op, x, y, w; } a[N];
bool cmp(dat u,dat v) { return u.w<v.w; }

int get(int x) {
	if(fa[x]==x) return x;
	return fa[x]=get(fa[x]); 
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> m >> p >> q;
	for(int i=1; i<=p; ++i) {
		tot++;
		cin >> a[tot].x >> a[tot].y >> a[tot].w;
		a[tot].op=1, sum+=a[tot].w*n;
	}
	for(int i=1; i<=q; ++i) {
		tot++;
		cin >> a[tot].x >> a[tot].y >> a[tot].w;
		a[tot].op=2, sum+=a[tot].w*m;
	}
	sort(a+1,a+1+tot,cmp);
	for(int i=1; i<=n+m; ++i) fa[i]=i;
	for(int l=1; l<=tot; ++l) {
		if(a[l].op==1) {
			int x=get(a[l].x), y=get(a[l].y);
			if(x^y) fa[x]=y, ans+=a[l].w*(n-cr), cl++;
		}
		else {
			int x=get(a[l].x+m), y=get(a[l].y+m);
			if(x^y) fa[x]=y, ans+=a[l].w*(m-cl), cr++;
		}
	}
	cout << sum-ans;
	return 0;
}
```


---

## 作者：菲斯斯夫斯基 (赞：2)

## P4809 [CCC2018] 最大战略储备 题解

**题意**

给出 $n\times m$ 的网格图，给定 $p$ 个 $u_i,v_i$，将第 $u_i$ 列，$v_i$ 列的同一行的两个点连在一起。给定 $q$ 个 $x_i,y_i$，将第 $x_i$ 行，$y_i$ 行的同一列的两个点连在一起。求这个网格图的最小生成树。

**思路**

显然可以暴力跑 Kruskal，但是会超时并拿到 50 pts 的美妙分数。

看看能不能找找规律，考虑一张普通的网格图，随便画画，发现假设现在已经添加 $x$ 次横边，$y$ 次纵边。如果现在添加横边，那么有 $y$ 条是无用的，即可以省去。如果添加纵边，那么有 $x$ 条是无用的。

下面是证明：

假设现在已经合并了两列，那么这两列相当于是一个整体。这两列上的同一行已经被合并了。那么下次连纵边的时候，就可以少连一条边了。

所以还是 Kruskal 的思路，先将边按权值从小到大排序，如果将要合并的两列并不处于同一个联通块，那么就将这两列合并，并加上无用的边的权值（合并两行同理）。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
int n,m,p,q,ans,sx,sy,l;
struct ccf
{
	int x,y,z,d;
}a[N];
bool cmp(ccf a,ccf b)
{
	return a.z<b.z;
}
struct str
{
	int f[N];
	void init(int n)
	{
		for(int i=1;i<=n;i++)
			f[i]=i;
	}
	int find(int x)
	{
		return f[x]==x?x:f[x]=find(f[x]);
	}
	void add(int x,int y)
	{
		f[find(x)]=find(y);
	}
}x,y;
signed main()
{
	cin>>n>>m>>p>>q;
	x.init(m),y.init(n);//并查集初始化
	for(int i=1;i<=p;i++)
	{
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		a[++l]={x,y,z,1};
	}
	for(int i=1;i<=q;i++)
	{
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		a[++l]={x,y,z,2};
	}
	sort(a+1,a+1+l,cmp);
	for(int i=1;i<=l;i++)
	{
		if(a[i].d==1)//连行还是连列
		{
			if(x.find(a[i].x)==x.find(a[i].y))ans+=n*a[i].z;//同一联通块则加上所有的权值
			else ans+=sy*a[i].z,x.add(a[i].x,a[i].y),sx++;//否则加上无用边的权值
		}
		else//同理
		{
			if(y.find(a[i].x)==y.find(a[i].y))ans+=m*a[i].z;
			else ans+=sx*a[i].z,y.add(a[i].x,a[i].y),sy++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：typedef (赞：2)

[更好的阅读体验？](https://www.cnblogs.com/Illyasviel/p/15291681.html)

提供一个新的思路。

不难发现，每个星球内部的最小生成树的结构是一样的。于是我们只需要跑一遍 $\rm{Kruskal}$ 即可得到所有星球内部的生成树，顺便记录下生成树所用边的边权。

此时，星球之间还是未连通的，于是我们再在星球之间跑一边 $\rm{Kruskal}$ ，即可连通所有星球。

不过，如果你选择的星球内部的边的边权很大，答案很可能不是最优的，因为你可以用其他星球间的边替换这条比较劣的边。具体来说，就是在给星球间连边时，在生成树内部的边中 $\rm{lower\_bound}$ 找到比当前边列劣的内部边，然后计算新边产生的贡献即可。

结合代码的注释更好理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+7;
int n,m,p,q;
int fa[N];
int cnt;
ll ans=0,tot1=0,tot2=0;//两个tot记录的是总边权和
struct Edge{
    int x,y;
    int z;
    friend bool operator<(const Edge &a,const Edge &b){
        return a.z<b.z;
    }
}e[1<<24];
ll stk[N],sum[N],top;
int find(int x){
    if(fa[x]==x) return x;
    return fa[x]=find(fa[x]);
}
void merge(int x,int y){
    int fx=find(x),fy=find(y);
    fa[fy]=fx;
    return;
}
int main(){
    scanf("%d%d%d%d",&n,&m,&p,&q);
    for(int i=1;i<=m;i++) fa[i]=i;
    for(int i=1;i<=p;i++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        tot1+=z;//重边和自环不需要考虑，克鲁斯卡尔的过程会帮我们过滤掉
        e[i]={x,y,z};
    }
    sort(e+1,e+p+1);
    for(int i=1;i<=p;i++){//星球内部
        int x=e[i].x,y=e[i].y,z=e[i].z;
        if(find(x)==find(y)) continue;
        merge(x,y);
        ans+=z,stk[++top]=z;//星球内部的边记录下来
    }
    ans*=n,tot1*=n;
    for(int i=1;i<=n;i++) fa[i]=i;//记得再初始化一遍
    for(int i=1;i<=q;i++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        tot2+=z;
        e[i]={x,y,z};
    }
    tot2*=m;
    sort(e+1,e+q+1);
    sort(stk+1,stk+top+1);
    for(int i=1;i<=top;i++)
        sum[i]=sum[i-1]+stk[i];
    for(int i=1;i<=q;i++){//星球间
        int x=e[i].x,y=e[i].y,z=e[i].z;
        if(find(x)==find(y)) continue;
        merge(x,y);
        ans+=z;
        int pos=lower_bound(stk+1,stk+top+1,z)-stk;
        ans+=z*(top-pos+1);//使用星球间的边替换掉星球内部不优的边
        ans-=(sum[top]-sum[pos-1]);
    }
    printf("%lld\n",tot2+tot1-ans);
    return 0;
}
```



---

## 作者：Spouter_27 (赞：1)

模拟赛摸了的题，发现 VictorYuan 写了题解，自感被同时期的 ysl 吊打，于是写了这篇题解。

考虑删除掉尽可能多的边使它们仍联通，等价于选出尽可能少的边使他们联通，所以暴力的话直接用 kruskal 求最小生成树即可。

可是这样暴力要 $O(nm\log n)$，实在是太傻了！根本过不去几个点，考虑优化。

首先注意到边权相同的边本质只有 $O(n)$ 个，所以我们不需要用所有边进行排序，只需要拿出来这 $O(n)$ 个进行排序就好了，这样我们就拿到了高贵的 $59$ 分！

然后我们需要找一下规律。首先枚举的第一组边，假设是连接两个星球所有城市之间的边，那么肯定是要把每个城市都要连上的（因为在这之前没有任何边），共连出 $m$ 条。

假设第二组边还是连接两个星球所有城市之间的边，那么我们只需要判断这两个星球在这之前是否联通即可。如果联通那就不用管了，否则还是要连出 $m$ 条新边。

否则第二组边是连接所有星球的两个城市之间的边。通过画图可以发现，我们能连出 $n-1$ 条。这个 $-1$ 是从哪里来的呢？注意到在连出这组边之前，已经有两个星球被我们联通了，所以我们只需要在其中一个星球上连接这条边，另外一个星球上这两个城市就已经联通了。

进一步可以得出，我们连出的是**星球间连通块个数**条边。对于两个星球所有城市之间的边组，同理，连出的是**单个星球上连通块个数**条边。

这就好办了。对边组分类，排好序后，模拟上述过程即可，只需要一个并查集，复杂度 $O(n\log n)$，瓶颈在排序。

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define debug(x) cerr<<"Line: "<<__LINE__<<", val= "<<x<<"; \n"
typedef long long ll;
#define pii pair<ll,ll>
#define mp make_pair
#define fi first
#define se second
const ll N=2e5+10;
inline ll read(){
	ll a=0,x=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	x=-x;
		c=getchar();
	}
	while(isdigit(c)){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*x;
}
ll fa[N];
struct edge{
	ll op,u,v,w;
	bool operator<(const edge &a1) const{
		return w<a1.w;
	}
}e[N];
ll n,m,p,q,cnt,sum;
ll get(ll x){
	if(fa[x]==x)	return x;
	return fa[x]=get(fa[x]);
}
void merge(ll u,ll v,ll w){
	if(get(u)==get(v))	return;
	fa[fa[u]]=fa[v];
	cnt--;
	sum-=w;
}
signed main(){
	n=read(),m=read(),p=read(),q=read();
	for(int i=1;i<=p;i++){
		ll u=read(),v=read(),w=read();
		e[i]={1,u,v,w};
		sum+=w*n;
	}
	for(int i=1;i<=q;i++){
		ll u=read(),v=read(),w=read();
		e[i+p]={2,u,v,w};
		sum+=w*m;
	}
	sort(e+1,e+p+q+1);
	for(int i=1;i<=n+m;i++){
		fa[i]=i;
	}
	ll lc=n,rc=m;
	for(int i=1;i<=p+q;i++){
		if(e[i].op==1){
			if(get(e[i].u)==get(e[i].v)){
				continue;
			}
			fa[fa[e[i].u]]=fa[e[i].v];
			sum-=e[i].w*lc;
			rc--;
		}else{
			if(get(e[i].u+m)==get(e[i].v+m)){
				continue;
			}
			fa[fa[e[i].u+m]]=fa[e[i].v+m];
			sum-=e[i].w*rc;
			lc--;
			
		}
	}
	printf("%lld\n",sum);
	return 0;
}
```


---

## 作者：cheng2010 (赞：0)

# 最大战略储备
## 思路
如果直接跑 Kruskal 的话，在 $m \times n$ 的复杂度下，一定会 TLE，那该怎么办？发现，对于每一层，它们的 MST 都是一模一样的，求出一个，其他的也就可以了。

然后呢？星球与星球之间呢？

发现对于 $x$ 星和 $y$ 星之间的费用 $z$，找到它们的 MST 的边权中所有 $\le z$ 的，替换就 OK 了！

## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+7;
struct EDGE
{
	int frm,to, val;
}a[N],b[N];
struct Node
{
	int f[N],tot,top,res,sum[N],st[N];
	bool pd;
	inline void init(int n){for(int i=1;i<=n;i++) f[i]=i;tot=0;}
	inline int Find(int x){return f[x]==x?x:f[x]=Find(f[x]);}
	inline void get(int n){for(int i=1;i<=n;i++) sum[i]=st[i]+sum[i-1];}
	inline bool merge(int x,int y,int v,int n)
	{
		pd=0;
		int xx=Find(x),yy=Find(y);
		if(xx!=yy)
		{
			pd=1;
			st[++top]=v;
			res+=v;
			tot++;
			f[xx]=yy;
		}
		return (tot==n-1);
	}
}g1,g2;
int n,m,p,q;
int ans,city,planet;
inline bool cmp(EDGE A,EDGE B)
{
	return A.val<B.val; 
}
signed main()
{
	scanf("%lld %lld %lld %lld",&n,&m,&p,&q);
	g1.init(m);
	g2.init(n);
	for(int i=1;i<=p;i++)
	{
		scanf("%lld %lld %lld",&a[i].frm,&a[i].to,&a[i].val);
		city+=a[i].val;
	}
	for(int i=1;i<=q;i++)
	{
		scanf("%lld %lld %lld",&b[i].frm,&b[i].to,&b[i].val);
		planet+=b[i].val;
	}
	city*=n;
	planet*=m;
	sort(a+1,a+1+p,cmp);
	sort(b+1,b+1+q,cmp);
	for(int i=1;i<=p;i++)
		if(g1.merge(a[i].frm,a[i].to,a[i].val,m))
			break;
	ans=g1.res*n;
	g1.get(m);
	for(int i=1;i<=q;i++)
	{
		g2.merge(b[i].frm,b[i].to,b[i].val,m);
		if(g2.pd)
		{
			ans+=b[i].val;
			int id=upper_bound(g1.st+1,g1.st+1+g1.top,b[i].val)-g1.st;
			ans+=b[i].val*(g1.top-id+1);
			ans-=(g1.sum[g1.top]-g1.sum[id-1]);
		}
	}
	printf("%lld",city+planet-ans);
}
```

---

## 作者：Computer1828 (赞：0)

[双倍经验 P5687](https://www.luogu.com.cn/problem/P5687)

阅读题目会发现它要求的是这个图的总权值减去最小生成树的权值。注意到边很多但很有规律，所以这题关键就是如何建图。

然后发现这个图可以近似看成网格图。

按照 Kruskal 算法，我们先把行和列的边按边权分别排序。

然后贪心地选择一个行上的边或列上的去连边：如果当前剩下未连的边连接 $i,j$，那我们肯定是把所有的连起来可以减少连通块的 $i,j$ 都连上。

至于维护连通块，因为贪心连边会把能连的都连上，所以可以不需要维护每个点，我们只需维护每一行、每一列的连通性就行。

由于有重边的问题，可能会出现列方向连通了但行方向可能不连通（可以想象成把图上下压缩后形成若干个连通块）或者相反的情况，这时候我们就把剩下行方向或列方向贪心连边就行。

写的时候要注意究竟是在考虑行还是列。

```cpp
#include<bits/stdc++.h>
#define N 100005
#define ll long long
using namespace std;
int n,m,p,q;
int fa1[N],fa2[N];
inline int getf1(int x){
	if(x == fa1[x]) return x;
	return fa1[x] = getf1(fa1[x]);
}
inline int getf2(int x){
	if(x == fa2[x]) return x;
	return fa2[x] = getf2(fa2[x]);
}
struct node{
	int u,v,w;
}e1[N],e2[N];

inline bool cmp(node x,node y){
	return x.w<y.w;
}
int main(){
	scanf("%d%d%d%d",&n,&m,&p,&q);
	long long tot = 0;
	for(int i = 1;i<=p;++i) scanf("%d%d%d",&e1[i].u,&e1[i].v,&e1[i].w),tot += 1ll*e1[i].w*n;
	for(int i = 1;i<=q;++i) scanf("%d%d%d",&e2[i].u,&e2[i].v,&e2[i].w),tot += 1ll*e2[i].w*m;
	for(int i = 1;i<=n;++i) fa1[i] = i;//维护行 
	for(int i = 1;i<=m;++i) fa2[i] = i;//维护列 
	sort(e1+1,e1+p+1,cmp),sort(e2+1,e2+q+1,cmp);
	int r = n,c = m,i = 1,j = 1;
	//r:剩余未连通的行数 
	//c:剩余未连通的列数 
	ll used = 0;
	for(int x,y;r>1 && c>1;){
		if(e1[i].w <= e2[j].w){
			x = getf2(e1[i].u),y = getf2(e1[i].v);
			if(x != y){
				used += 1ll*e1[i].w*r;
				fa2[y] = x;
				c--;
			}
			i++;
		}else{
			x = getf1(e2[j].u),y = getf1(e2[j].v);
			if(x != y){
				used += 1ll*e2[j].w*c;
				fa1[y] = x;
				r--;
			}
			j++;
		}
	}
	while(r>1 && j<=q){
		int x = getf1(e2[j].u),y = getf1(e2[j].v);
		if(x != y){
			fa1[y] = x;
			used += 1ll*e2[j].w*c;
			r--;
		}
		j++;
	}
	while(c>1 && i<=p){
		int x = getf2(e1[i].u),y = getf2(e1[i].v);
		if(x != y){
			fa2[y] = x;
			used += 1ll*e1[i].w*r;
			c--;
		}
		i++;
	}
	printf("%lld",tot-used);
	return 0;
}
```

---

## 作者：hehelego (赞：0)

# CCC2018 S5 Maximum Strategic Savings

## statement
[link:DMOJ](https://dmoj.ca/problem/ccc18s5)  [link:luogu](https://www.luogu.com.cn/problem/P4809)
给一个$N\times M$个点的无向图$G=(V,E)$,每个点是$V=\{(e,f) \mid 1\leq e\leq N,1\leq f\leq M\}$.
给$P$个二元组$(x_i,y_i)$表示$\forall e\ (1\leq e\leq N)\to ((e,x_i)\leftrightarrow (e,y_i)\in E)$
和$Q$个二元组$(u_i,v_i)$表示$\forall f\  (1\leq f\leq M)\to ((u_i,f)\leftrightarrow (v_i,f)\in E)$
求$G$的$MST$的边权和.

大概这样

```cpp
for(int i=0;i<p;i++){
    int a=read(),b=read(),c=read();
    for(int e=1;e<=n;e++) link(id(e,a),id(e,b),c);
}
for(int i=0;i<q;i++){
    int a=read(),b=read(),c=read();
    for(int f=1;f<=m;f++) link(id(a,f),id(b,f),c);
}
```

## solution

> 其实是个做法很trivial的题目,但是2018年为NOIp训练的时候遇到这个题目,还是很难解决它.
> 现在有了足够的基础熟练度,有了认真思考的冷静头脑以及我能做得出来的自信,解决这种题目已经变得非常轻松了.
> 不得不说那时候我还没入算法竞赛的门,OI弱校学生往往难以轻松跨过从接触OI到拥有自己深入学习高级知识和技巧的能力并开始快速进步之间的巨大鸿沟,或者做到它的时间过长压缩了之后的训练时间.希望我们能做点什么,尝试改善这个情况.
> 我知道2020年有强基计划和新冠肺炎疫情的打击,OIer不好过;CCF的离谱操作使得他们的公信力快速流失.但是这不应该阻止那些真的有兴趣,有天赋的人成为算法竞赛爱好者,或者阻止对CS有兴趣的孩子们靠近这个学科的大门.



这个$(e,f)$可以看一个$N\times M$的矩阵.

考虑`kruskal's algorithm`求解MST,我们对于所有的边进行排序,
把边分成$P+Q$组,组之间按照边权大小排序.

此时开始选边,合并联通分量.必然是首先选择一组$\forall e\ (e,x)\leftrightarrow (e,y)$或者一组$\forall f\ (u,f)\leftrightarrow (v,f)$把它们全都加入.

- 对于第一种情况,相当于合并了第$x$行与第$y$行,变成了一个$N\times (M-1)$的矩阵(加入了$N$条边).
  我们把$(u,v)\in E$其中$u=(e,y)$的边替换为$u'=(e,x)$的边,权值不变,得到了一个规模更小的子问题.

- 第二种情况是合并了$u$列和$v$列,变成了$(N-1)\times M$的矩阵(加入了$M$条边).
  类似上面的情况,替换一些边,得到规模更小的子问题.

我们发现这个合并的操作并不用真的遍历边,只要用一个并查集维护这个合并的关系即可.
于是我们最多选择$n+m$组边,每次都会合并两行或者两列,用一个按照集合大小启发式合并的并查集就可以$O(\log \max(N+M))$时间内完成合并操作.
于是这样得到了一个$O(E\log E+(V+E\log V))$的算法,其中$E=P+Q,V=M+N$.



## code

```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
const int N=100000+10;
struct E{
	int a,b,w;
	bool operator<(const E&rhs)const{return w<rhs.w;}
}ea[N],eb[N];


int fa[N],fb[N];
int pa(int x){
	if(fa[x]!=x) return fa[x]=pa(fa[x]);
	return fa[x];
}
int pb(int x){
	if(fb[x]!=x) return fb[x]=pb(fb[x]);
	return fb[x];
}
int ma(int u,int v){
	u=pa(u);v=pa(v);
	if(u==v) return 0;
	fa[u]=v;
	return 1;
}
int mb(int u,int v){
	u=pb(u);v=pb(v);
	if(u==v) return 0;
	fb[u]=v;
	return 1;
}


int main(){
	int n=read(),m=read(),p=read(),q=read();
	unsigned long long ans=0;
	for(int i=1;i<=m;i++) fa[i]=i;
	for(int i=1;i<=n;i++) fb[i]=i;
	for(int i=0;i<p;i++){
		ea[i].a=read(); ea[i].b=read();
		ea[i].w=read(); ans+=1LL*n*ea[i].w;
	} std::sort(ea,ea+p);
	for(int i=0;i<q;i++){
		eb[i].a=read(); eb[i].b=read();
		eb[i].w=read(); ans+=1LL*m*eb[i].w;
	} std::sort(eb,eb+q);


	int i=0,j=0;
	while(i<p&&j<q){
		if(ea[i].w<eb[j].w){
			if(ma(ea[i].a,ea[i].b)){
				ans-=1LL*n*ea[i].w;
				m--;
			}
			i++;
		}else{
			if(mb(eb[j].a,eb[j].b)){
				ans-=1LL*m*eb[j].w;
				n--;
			}
			j++;
		}
	}
	while(i<p){
		if(ma(ea[i].a,ea[i].b)){
			ans-=1LL*n*ea[i].w;
			m--;
		}
		i++;
	}
	while(j<q){
		if(mb(eb[j].a,eb[j].b)){
			ans-=1LL*m*eb[j].w;
			n--;
		}
		j++;
	}
	std::cout<<ans<<std::endl;
	return 0;
}
```




---


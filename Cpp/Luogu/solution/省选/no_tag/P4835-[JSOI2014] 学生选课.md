# [JSOI2014] 学生选课

## 题目描述

进入大学以后，学生们将面临选课，有 $n$ 个学生需要选课，学校里有三个老师 JYY，YJY，YYJ。

第一年里，每个学生们都选择了其中一位老师。经过了一年的学习，学生之间相互都有一定的印象，每个同学会根据自己的印象给另外 $n-1$ 个学生从好到坏排序。第二年的选课开始了，每个学生需要选择老师，可能是因为被坑多了，每一位同学都想换一个老师。这时需要你来调度同学们选课，使得上同一堂课的学生之间印象最坏的最好。

## 说明/提示

### 样例解释 1

六名同学分别选择老师 $1,2,0,0,2,0$。

此时老师 $0$ 的课中同学 $6$ 对同学 $4$ 的印象为第 $4$ 好，所以答案 $T$ 为 $4$，并且找不到更小的 $T$。

### 数据范围

对于 $100\%$ 的数据，$n\leq 1000$。

## 样例 #1

### 输入

```
6
0 2 3 4 5 6
0 1 3 4 5 6
1 6 5 4 2 1
2 6 5 3 2 1
1 1 2 3 4 6
2 1 2 3 4 5```

### 输出

```
4```

# 题解

## 作者：chenly8128 (赞：4)

本题解复杂度为 $O(n^2 \log n)$，但在水得没边的数据下跑不过 $O(n^3)$，特此说明。希望管理大大早日加强数据。

## 题目分析

题目要求「使得上同一堂课的学生之间印象最坏的最好」。那么我们根据套路，可以二分答案。

设目前答案为 $x$。我们需要做的就是验证所有人的最后 $n-x-1$ 个印象，是否能一个都不出现在该同学的班级里。

注意到总共 3 个班，但是除去去年的选择，每人只剩下了两个选择，结合限制条件，于是这就是很经典的 2-sat 问题。

解决该问题可以拆分为 2 步：
1. 根据目前的二分结果下的限制条件建有向图。
2. tarjan 算法求解强连通分量，验证是否合法。

### 建图

设目前需要验证的答案为 $x$，有用的限制条件为每人的最后 $n-x-1$ 条，其中的人顺序不分先后。

假设有 $a$ 和 $b$ 两个学生，他们中，至少有一方在另一方的最后 $n-x+1$ 个印象中。

显然，两个学生必然拥有至少一个能一起上的课程，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/bral8sqi.png)

图中，两个学生都能够上课程 2。如果学生 a 选择了课程 2，那么学生 b 就一定不能选择课程 2。对于 b 来说，课程 1 和 课程 2 是对立事件，有且仅有一项成立，所以不选 2 就只能选 1。因此我们可以给 a 的课程 2 选项连一条有向边到 b 的课程 1，象征着 a 选课程 2 能够推出 b 选课程 1。

同理，我们还需要给 b 的课程 2 选项连一条有向边到 a 的课程 0。

通过这样的方法，我们就能完成建图。

### tarjan

建完图就是标准的 2-sat 求解，直接对每一个节点跑 $tarjan$，给强连通块涂相同颜色。如果一个学生能选择的两个课程在同一个强连通分量里，那就说明选择其一必定得选择另一，这很明显是有问题的，直接判断不可能。

如果每一个学生都没有出现这样的情况，那么就是可能的。

## 代码实现

二分 $O(\log n)$ 次，每次需要重新建图 $O(n^2)$，并强连通分量缩点 $O(n+m)$。这里的 $m$ 表示边数，最坏情况下与 $n^2$ 同阶。所以总时间复杂度 $O(n^2 \log n)$，可过本题。


```cpp

// Author: chenly8128
// Created: 2025-06-05 21:39:29

#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1000+10;
int n,x,ne[MAXN][MAXN];
int id[MAXN][3];
int dfn[MAXN<<1],col[MAXN<<1],low[MAXN<<1];
int col_cnt,dfn_cnt;
stack <int> s;
vector <int> g[MAXN<<1];
void init (void) {
	memset (dfn,0,sizeof (dfn));
	memset (col,0,sizeof (col));
	memset (low,0,sizeof (low));
	for (int i = 1;i <= 2*n;i++) g[i].clear();
	dfn_cnt = col_cnt = 0;
}
void build (int x) {
	for (int i = 1;i <= n;i++)
		for (int j = x+1;j < n;j++) {
			int v = ne[i][j];
			for (int t = 0;t < 3;t++)
				if (id[i][t] && id[v][t]) {
					g[id[i][t]].push_back(id[v][0]+id[v][1]+id[v][2]-id[v][t]);
					g[id[v][t]].push_back(id[i][0]+id[i][1]+id[i][2]-id[i][t]);
				}
		}
}
void tarjan (int x) {
	low[x] = dfn[x] = ++dfn_cnt;
	s.push(x);
	for (int y : g[x]) {
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x],low[y]);
		}
		else if (!col[y]) low[x] = min(dfn[y],low[x]);
	}
	if (low[x] == dfn[x]) {
		col_cnt++;
		while (s.top() != x) {
			col[s.top()] = col_cnt;
			s.pop();
		}
		col[x] = col_cnt; s.pop();
	}
}
bool check (int x) {
	init();
	build(x);
	for (int i = 1;i <= 2*n;i++)
		if (!dfn[i]) tarjan(i);
	for (int i = 1;i <= n;i++)
		if (col[i] == col[i+n]) return false;
	return true;
}
int main (void) {
	ios::sync_with_stdio(false);
	cin >> n;
	for (int i = 1;i <= n;i++) {
		cin >> x;
		int cur = i;
		for (int t = 0;t < 3;t++)
			if (x == t) id[i][t] = 0;
			else {
				id[i][t] = cur;
				cur += n;
			}
		for (int j = 1;j < n;j++) cin >> ne[i][j];
	}
	int l = 0,r = n-1;
	while (l < r) {
		int mid = (l + r) >> 1;
		if (check (mid)) r = mid;
		else l = mid+1;
	}
	cout << r << '\n';
	return 0;
}
```

---

## 作者：Tony2 (赞：3)

抢一个第一QAQ

考虑直接暴力枚举答案。枚举答案之后会怎么样呢？

假设答案是ans，那么每个人都和他的排名列表上倒数n-ans-1个人**不在**同一堂课。

那什么情况下一个答案是合法的呢？我们要用**2-sat**算出一个答案是否有合法解。

每个人都有两种选课的选择，我们就对每个人开两个点。

然后对于每个人都对和他不能在同一堂课的人建立关系。

A不能和B在同一堂课的时候，至少有一堂课，他们俩要一起上；A相对应的这堂课的点就向B另一堂课的点相连；注意连上另外两个没有参与的点的反向边。这里自己去推导推导就好了。

```cpp
#include <bits/stdc++.h>
#define other(i, k) ((k+1)%3==a[i]?(k+2)%3:(k+1)%3)
using namespace std;
const int N = 2005;
int n, a[N], pos[N][3];
int b[N][N];
int dfn[N], low[N], col[N], sta[N], dfs_num, col_num, top; 
vector<int> e[N];
void tarjan(int u){
	dfn[u] = low[u] = ++dfs_num;
	sta[++top] = u;
	for (int i = 0; i < e[u].size(); i++){
		int v = e[u][i];
		if (!dfn[v]){
			tarjan(v);
			low[u] = min(low[v], low[u]);
		}else if (!col[v]) low[u] = min(dfn[v], low[u]);
	}
	if (dfn[u] == low[u]){
		col_num++;
		do{
			col[sta[top]] = col_num;
		}while (sta[top--] != u);
	}
}
int main(){
	std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
//	freopen("in.txt", "r", stdin);
//	freopen("out.out", "w", stdout);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> a[i];
		switch (a[i]){
			case 0: pos[i][1] = i*2-1, pos[i][2] = i*2; break;
			case 1: pos[i][0] = i*2-1, pos[i][2] = i*2; break;
			case 2: pos[i][0] = i*2-1, pos[i][1] = i*2; break;
		}
		for (int j = 1; j < n; j++)
			cin >> b[i][j];
	}
	for (int t = 1; t < n; t++){
		for (int j = 1; j <= n; j++){
			int v = b[j][n-t];
			for (int k = 0; k < 3; k++)
				if (pos[j][k] && pos[v][k]){
					e[pos[j][k]].push_back(pos[v][other(v, k)]);//自己上某堂课的时候另一个人必须上另一堂课
					e[pos[v][k]].push_back(pos[j][other(j, k)]);//反过来一样
				}
		}
		dfs_num = col_num = top = 0;
		memset(dfn, 0, sizeof(dfn));
		memset(low, 0, sizeof(low));
		memset(col, 0, sizeof(col));
		for (int i = 1; i <= n*2; i++)//2sat过程
			if (!dfn[i])
				tarjan(i);
		for (int i = 1; i <= n; i++)//这里是判定
			if (col[i*2-1] == col[i*2]){
				cout << n-t;
				return 0;
			}
	}
	cout << 0;//所有连边都符合条件（虽然不大可能）
	return 0;
}
```
上次排版没排好，这次排好了，求通过awa

---


# P 哥的桶

## 题目描述

P 哥现在有 $n$ 个桶，它们排成了一排，这些桶可以装下任意多个球。每个球有一个固定的价值。

P 哥时不时地会找新球，并把新找的球丢进某个桶里面。我们用 $1\;k\;x$ 来表示 P 哥找了一个价值为 $x$ 的球，并且丢进了 $k$ 号桶里面。

P 哥每次会在特定的桶里面拿出一些球。我们用 $2\;l\;r$ 来表示 P 哥在 $l$ 号桶到 $r$ 号桶之间拿球。P 哥希望拿出来的球的价值异或和尽可能大。

**注意：P 哥拿出这些球后会把它们物归原位。**

## 说明/提示

对于 $20 \%$ 的数据，满足 $n,m\leq 100$。

对于 $40 \%$ 的数据，满足 $n,m\leq 1000$。

另有 $20 \%$ 的数据，所有询问满足 $l=1$，$r=m$。

对于 $100 \%$ 的数据，满足 $1 \le n, m \leq 5 \times 10^4$，$1 \le l\leq r\leq m$，$1 \le k \leq m$，$0 \le x \leq 2^{31}-1$。

## 样例 #1

### 输入

```
5 3
1 1 2
1 2 3
1 3 4
2 1 2
2 1 3```

### 输出

```
3
7```

## 样例 #2

### 输入

```
11 10
2 6 9
1 9 1523456696
1 1 1818963290
2 6 7
1 1 102229226
2 1 9
2 3 7
1 5 34895532
1 1 1652480680
1 1 1477666032
2 1 10```

### 输出

```
0
0
1818963290
0
1857442578
```

# 题解

## 作者：ezoixx130 (赞：26)

**UPD：经评论区指正，时间复杂度应为 3 个 log。**

看到题：单点插入？区间查询？线段树。异或和最大？线性基。

于是就可以线段树套线性基了。

线段树每个结点维护一个线性基，插入时直接插入，查询时把所有被查询区间所包含的区间的线性基插入到一个大的线性基里，最后在大的线性基里查询就好了。

时间复杂度 $O(n\log m\log ^2x)$

代码:
```
#include <bits/stdc++.h>
using namespace std;

struct lb
{
    int a[32];
    void insert(int x)
    {
        for(int i=31;i>=0;--i)
            if(x&(1<<i))
                if(a[i])x^=a[i];
                else
                {
                    a[i]=x;
                    return;
                }
    }
    void insert(lb &n)
    {
        for(int i=31;i>=0;--i)
            if(n.a[i])insert(n.a[i]);
    }
}p[200001];

void insert(int o,int l,int r,int k,int x)
{
    p[o].insert(x);
    if(l==r)return;
    int mid=(l+r)>>1;
    if(k<=mid)
        insert(o<<1,l,mid,k,x);
    else
        insert(o<<1|1,mid+1,r,k,x);
}

lb ans;

void query(int o,int l,int r,int ql,int qr)
{
    if(ql<=l && qr>=r){ans.insert(p[o]);return;}
    int mid=(l+r)>>1;
    if(qr<=mid)query(o<<1,l,mid,ql,qr);
    else if(mid<ql)query(o<<1|1,mid+1,r,ql,qr);
    else query(o<<1,l,mid,ql,mid),query(o<<1|1,mid+1,r,mid+1,qr);
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
    {
        int op,a,b;
        scanf("%d%d%d",&op,&a,&b);
        if(op==1)insert(1,1,m,a,b);
        else
        {
            memset(ans.a,0,sizeof(ans.a));
            query(1,1,m,a,b);
            int maxn=0;
            for(int i=31;i>=0;--i)
                if((maxn^(ans.a[i]))>maxn)
                    maxn^=ans.a[i];
            printf("%d\n",maxn);
        }
    }
}
```

---

## 作者：Inui_Sana (赞：7)

有人搞错了复杂度白开心了一下午/kk

**基于离线 ST 表+前缀线性基合并的 $O(m\log m\log^2V)-O(\log^2V)$ 做法。**

upd：**@chenxinyang2006 的在线 $O(n\log V(\log V+\log m))$ 做法。**

考虑将操作离线下来，具体是对于序列的每一个位置开一个类似前缀线性基（即 CF1100F 中的 trick），优先记录操作时间 $t$ 更小的向量。这里就要提到时间轴的一个很好的性质：我们只记录最小时间产生的 01 向量一定是更优的。

然后用 ST 表维护区间的前缀线性基的并。可以用 ST 表是因为线性基显然是有可重复贡献性的。至于前缀线性基合并，和普通线性基合并相差无几。

总时间复杂度是 $O(m\log m\log^2V+n\log^2V)$。由于用线段树维护的许多剪枝方法不能用在这种线性基上，且 $n,m$ 同阶，所以跑得远不如大部分 $O(n\log m\log^2V)$ 快。但还是有一定意义的吧（

code：

```cpp
int n,m,k,l[N],r[N],t[N];
struct XXJ{
	int a[31],b[31];
	void insert(int x,int t){
		drep(i,30,0){
			if(!(x>>i&1)){
				continue;
			}
			if(a[i]){
				if(t<b[i]){
					swap(a[i],x),swap(b[i],t);
				}
				x^=a[i];
			}else{
				a[i]=x,b[i]=t;
				break;
			}
		}
	}
	int query(int x,int t){
		drep(i,30,0){
			if((x^a[i])>x&&b[i]<=t){
				x^=a[i];
			}
		}
		return x;
	}
	XXJ operator+(const XXJ &rhs)const{
		XXJ r;
		rep(i,0,30){
			r.a[i]=a[i],r.b[i]=b[i];
		}
		rep(i,0,30){
			if(rhs.a[i]){
				r.insert(rhs.a[i],rhs.b[i]);
			}
		}
		return r;
	}
};
struct STable{
	XXJ st[17][N];
	void init(){
		rep(i,1,__lg(m)){
			rep(j,1,m-(1<<i)+1){
				st[i][j]=st[i-1][j]+st[i-1][j+(1<<(i-1))];
			}
		}
	}
	XXJ query(int l,int r){
		int k=__lg(r-l+1);
		return st[k][l]+st[k][r-(1<<k)+1];
	}
}ST;
void Yorushika(){
	scanf("%d%d",&n,&m);
	rep(i,1,n){
		int op=read(),x=read(),y=read();
		if(op==1){
			ST.st[0][x].insert(y,i);
		}else{
			k++,l[k]=x,r[k]=y,t[k]=i;
		}
	}
	ST.init();
	rep(i,1,k){
		printf("%d\n",ST.query(l[i],r[i]).query(0,t[i]));
	}
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

upd：@chenxinyang2006 在他的 [P5607 题解中](https://www.luogu.com.cn/article/o4uh1inf)提到了这题的 log^2 **在线**做法。大致讲一下。

具体就是运用猫树的思想建一棵线段树。每个节点如果是它父亲的左儿子，则维护一个后缀线性基，否则维护前缀线性基，根节点空。

每次修改，我们不再只修改叶子节点，而是将线段树上对应儿子到根的整条链修改。这是一个很巧妙的均摊复杂度的方法，因为注意到原来不算 pushup，每次只需要 $O(\log m+\log V)$ 的复杂度。新做法中，一共 $O(\log m)$ 次 $O(\log V)$ 的插入。并不影响复杂度。

查询时，类似猫树分治的做法，设询问区间为 $[L,R]$，找到第一个满足 $L\le mid\le R$ 的区间 $[l,r]$，因为维护了区间的前/后缀线性基，我们只需要一次简单的 $O(\log^2V)$ 的合并，再在线性基中查询最大值，就可以完成询问。

总时间复杂度 $O(n\log V(\log V+\log m))$。非常优秀的做法，同时也是非常有启发意义的。

```cpp
int n,m,k,l[N],r[N],t[N];
struct XXJ{
	int a[31],b[31];
	void insert(int x,int t,int lim){
		drep(i,30,0){
			if(!(x>>i&1)){
				continue;
			}
			if(a[i]){
				if(abs(t-lim)<abs(b[i]-lim)){
					swap(a[i],x),swap(b[i],t);
				}
				x^=a[i];
			}else{
				a[i]=x,b[i]=t;
				break;
			}
		}
	}
	int query(int x){
		drep(i,30,0){
			if((x^a[i])>x){
				x^=a[i];
			}
		}
		return x;
	}
};
struct SGT{
	XXJ tr[N<<2];
	void update(int l,int r,int o,int x,int y){
		if(o>1){
			if(o&1){
				tr[o].insert(y,x,0);
			}else{
				tr[o].insert(y,x,m);
			}
		}
		if(l==r){
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid){
			update(l,mid,o<<1,x,y);
		}else{
			update(mid+1,r,o<<1|1,x,y);
		}
	}
	int query(int l,int r,int o,int x,int y){
		int mid=(l+r)>>1;
		if(x<=mid&&y>=mid){
			XXJ r;
			rep(i,0,30){
				r.a[i]=r.b[i]=0;
				if(tr[o<<1].b[i]>=x&&tr[o<<1].b[i]<=y){
					r.insert(tr[o<<1].a[i],0,0);
				}
				if(tr[o<<1|1].b[i]>=x&&tr[o<<1|1].b[i]<=y){
					r.insert(tr[o<<1|1].a[i],0,0);
				}
			}
			return r.query(0);
		}
		if(x<=mid){
			return query(l,mid,o<<1,x,y);
		}
		return query(mid+1,r,o<<1|1,x,y);
	}
}T;
void Yorushika(){
	scanf("%d%d",&n,&m);
	rep(i,1,n){
		int op=read(),x=read(),y=read();
		if(op==1){
			T.update(1,m,1,x,y);
		}else{
			printf("%d\n",T.query(1,m,1,x,y));
		}
	}
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

---

## 作者：feicheng (赞：7)



## [Description](https://www.luogu.com.cn/problem/P4839)

> 维护一个序列，支持单点修改，区间查询最大异或和。

## [Solution](https://www.luogu.com.cn/paste/8sbv3uwx)

看到区间查询最大异或和，考虑线性基。

但是线性基并不资瓷区间查询怎么办嘞？

我们可以借助树套树的思想，给一个资瓷单点修改，区间查询的数据结构（比如线段树）里的每一个节点套一个线性基。

这样子就可以解决这个问题。

对于单点修改，给从根节点到单点的路径每个点都插入这个数。

对于区间查询，把所有答案插入到一个大的线性基里，在这个线性基里查最大异或和即可。

代码在链接里

---

## 作者：CmsMartin (赞：4)

## 题目简述

[题目传送门](https://www.luogu.com.cn/problem/P4839)

## 思路

看到查询最大异或和，果断想到线性基，又看到了区间操作，果断想到线段树。

于是就有了线段树套线性基。

对于插入操作，我们可以对线段树上对应的点的线性基直接插入。

对于询问操作，我们可以将区间内的线性基并在一块查询。

然后代码就写完了，吸吸氧就过了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5e4 + 10;
int N , M;

struct LB {
	int P[40];
	LB() { memset(P , 0 , sizeof P); }
	void Insert(int k) {
		for(int i = 31; i >= 0; i--) {
			if(!(k & (1 << i))) continue;
			if(!P[i]) {
				P[i] = k;
				return;
			}
			k ^= P[i];
		}
	}
	int Query() {
		int res = 0;
		for(int i = 31; i >= 0; i--) res = max(res , (res ^ P[i]));
		return res;
	}
	void Merge(LB X) {
        for(int i = 31; i >= 0; i--)
            if(X.P[i])
				Insert(X.P[i]);
    }
};

struct Node {
	int l , r;
	LB v;
} Tree[MAXN * 4];
void PushDown(int p) {
	Tree[p].v.Merge(Tree[p * 2].v);
	Tree[p].v.Merge(Tree[p * 2 + 1].v);
}
void Build(int p , int l , int r) {
	Tree[p].l = l;
	Tree[p].r = r;
	if(l == r) return;
	int Mid = l + r >> 1;
	Build(p * 2 , l , Mid);
	Build(p * 2 + 1 , Mid + 1 , r);
	PushDown(p);
}
void UpDate(int p , int pos , int k) {
	if(Tree[p].l == pos && Tree[p].r == pos) {
		Tree[p].v.Insert(k);
		return;
	}
	int Mid = (Tree[p].l + Tree[p].r) >> 1;
	if(pos <= Mid) UpDate(p * 2 , pos , k);
	else UpDate(p * 2 + 1 , pos , k);
	PushDown(p);
	return; 
}
LB Query(int p , int l , int r) {
	if(l <= Tree[p].l && Tree[p].r <= r) {
		return Tree[p].v;
	}
	LB res;
	int Mid = (Tree[p].l + Tree[p].r) >> 1;
	if(l <= Mid) res.Merge(Query(p * 2 , l , r));
	if(r > Mid)  res.Merge(Query(p * 2 + 1 , l , r));
	return res;
}


signed main() {
	ios::sync_with_stdio(false);
	cin >> N >> M;
	Build(1 , 1 , M);
	for(int i = 1 , op , l , r; i <= N; i++) {
		cin >> op >> l >> r;
		if(op == 1) {
			UpDate(1 , l , r);
		}
		else {
			cout << Query(1 , l , r).Query() << endl;
		}
	}
	return 0;
}
```

---

## 作者：JK_LOVER (赞：3)

## 题意
给你一串长度为 $n$ 的序列，序列的每一个点都是一个集合。要求支持如下操作。 [QWQ](https://www.luogu.com.cn/blog/xzc/solution-p4839)

- 向一个集合中插入一个数

- 询问 $L \rightarrow R$ 之内可以构造出的异或最大值。

## 分析

- 异或最大值

很自然的想到维护线性基。

- 快速修改，快速查询

合并集合这个操作，是满足结合率的。可以转化为区间问题处理。线段树就可以很简单维护这个，把每个节点当作一个集合来维护。

- 时间复杂度分析

- 插入时，一个数最多在 $\log m$ 个集合中插入，每次插入时间复杂度为 $O(\log w)$ 。总的时间复杂度为 $O(\log m\times \log w)$ 。

- 查询时，答案最多会在 $\log m$ 个节点中更新，每次更新为 $O(\log^2 w)$ 。总的时间复杂度为 $O(\log m \times \log ^2w)$ 。

- 一个小剪枝，当答案或者节点已经插入了 $\log w$ 个节点，那么后面的节点就不用插入了，因为这个构造出来的答案时等价的。 

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x;scanf("%d",&x);return x;
}
const int N = 5e4+100;
int n,m;
struct Node{
	int p[34];
	int size;
	Node(){size = 0;}
}t[N<<2];
int Ans[34],size;
void update(int u,int l,int r,int K,int x)
{
	if(l > K || r < K) return;
	int key = x;
	if(t[u].size < 31)
	{
		for(int i = 31;i>=0;i--)
		{
			if(key&(1<<i))
			{
				if(!t[u].p[i])
				{
					t[u].p[i] = key;
					t[u].size++;
					break;
				}
				key ^= t[u].p[i];
			}
		}	
	}
	if(l == r) return;
	int mid = l + r >> 1;
	update(u<<1,l,mid,K,x);
	update(u<<1|1,mid+1,r,K,x);
}
void ask(int u,int l,int r,int L,int R)
{
	if(l > R || r < L) return;
	if(L <= l && r <= R) 
	{
		if(size >= 31) return;
		for(int i = 31;i>=0;i--)
		{
			if(t[u].p[i])
			{
				int key = t[u].p[i];
				for(int j = i;j >= 0;j--)
				{
					if(key&(1<<j))
					{
						if(!Ans[j])
						{
							Ans[j] = key;
							size++;
							break;
						}
						key ^= Ans[j];
					}
				}
			}
		}
		return;
	}
	int mid = l + r>>1;
	ask(u<<1,l,mid,L,R);
	ask(u<<1|1,mid+1,r,L,R);
}

int main()
{
	n = read();m = read();
	while(n--)
	{
		int opt = read();
		if(opt == 1)
		{
			int k = read(),x = read();
			update(1,1,m,k,x);
		}
		else
		{
			memset(Ans,0,sizeof(Ans));
			int l = read(),r = read();
			ask(1,1,m,l,r);
			int ans = 0;
			size = 0;
			for(int i = 31;i >= 0;i--)
			{
				if((ans^Ans[i]) > ans)
				{
					ans ^= Ans[i];
				}
			}
			printf("%d\n",ans);
		}
	}
}
```


---

## 作者：xiezheyuan (赞：2)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/solution-p4839.html)

## 简要题意

（这道题描述是真的长）

你需要维护一个数据结构，支持单点异或和区间求最大异或和。

## 思路

### 思维过程

对于这种区间问题，最容易想到的就是线段树。

而对于复杂的异或问题，最容易想到的就是线性基。

合在一起，就是线段树套线性基，类似经典的树套树。

### 详细思路

线段树大家应该都会，如果不会建议学习一下，这是一个很有用的数据结构。

线性基大家应该都会，如果不会可以看 [这篇博客](https://www.luogu.com.cn/blog/szxkk/solution-p3813)。

首先，每一个线段树节点，都保存一个线性基。（单个线性基空间复杂度为 $O(\log\max\{x\})$，是可以接受的，不用担心会MLE）

首先，对于修改操作，我们不方便 `pushup`，那么我们可以想到一个更好的方法：就是我们线段树DFS到的每一个区间节点都包含着修改值，那么我们考虑像权值线段树那样，经过一个点都把修改的元素插入节点线性基。

查询，我们可以考虑实现一个操作 `expand`，表示用一个新的线性基扩展原来的线性基（说人话：将另一个线性基的所有元素都插入原来的线性基）

`expand` 操作有一个简单有效的优化常数的方法，就是遍历线性基数组时，仅插入非 $0$ 值。

然后，我们就可以像经典的线段树那样实现，只不过将维护信息并的运算符换成`expand` 即可。

（注：有的同学可能习惯将我的 `expand` 操作换成类似线性基加法的 `merge`，这一点看大家个人喜好）

时间复杂度 $O(n\log m\log^{2}\max\{x\})$，空间复杂度 $O(n\log\max\{x\})$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

namespace Basis{
	const int MAX_BIT = 60;
	struct Basis{
		int p[MAX_BIT+5];
		int _how_many_numbers_can_xor;
		void clear(){
			memset(p,0,sizeof(p));
			_how_many_numbers_can_xor=0;
		}
		Basis(){
			clear();
		}
		void insert(int x){
			for(int i=MAX_BIT;i>=0;i--){
				if(!(x>>i))continue;
				if(!p[i]){
					p[i]=x;
					_how_many_numbers_can_xor++;
					break;
				}   
				x^=p[i];
			}
		}
		int max_xor(){
			int ans=0;
			for(int i=MAX_BIT;i>=0;i--){
				if((ans^p[i])>ans){
					ans^=p[i];
				}
			}
			return ans;
		}
		bool can_be_xor(int x){
			for(int i=MAX_BIT;i>=0;i--){
				if(x&(1ll<<i))x^=p[i];
			}
			return x==0;
		}
		int numbers_can_xor(){
			return (1ll<<_how_many_numbers_can_xor);
		}
		void expand(Basis &x){
			for(int i=MAX_BIT;i>=0;i--){
				if(x.p[i]){
					insert(x.p[i]);
				}
			}
		}
	};
}

namespace sgt{
	Basis::Basis t[200005];
	void update(int x,int v,int i,int l,int r){
		t[i].insert(v);
		if(l==r){
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid){
			update(x,v,i<<1,l,mid);
		}
		else{
			update(x,v,i<<1|1,mid+1,r);
		}
	}
	Basis::Basis result;
	void query(int ql,int qr,int i,int l,int r){
		if(ql<=l&&qr>=r){
			result.expand(t[i]);
			return;
		}
		int mid=(l+r)>>1;
		if(ql<=mid){
			query(ql,qr,i<<1,l,mid);
		}
		if(qr>mid){
			query(ql,qr,i<<1|1,mid+1,r);
		}
	}
}

int n,m;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	while(n--){
		int op,a,b;
		cin>>op>>a>>b;
		if(op==1){
			sgt::update(a,b,1,1,m);
		}
		else{
			sgt::result.clear();
			sgt::query(a,b,1,1,m);
			cout<<sgt::result.max_xor()<<'\n';
		}
	}
	return 0;
}
```

## 加强版：[P5607 \[Ynoi2013\] 无力回天 NOI2017](https://www.luogu.com.cn/problem/P5607)

如果将单点修改变成区间修改，那么应该如何处理呢？可以思考一下。（提示：想想差分）

[P5607 \[Ynoi2013\] 无力回天 NOI2017 题解](https://www.cnblogs.com/zheyuanxie/p/solution-p5607.html)

---

## 作者：blank_space (赞：2)

## P哥的桶 题解

线段树 + 线性基

代码写的比较暴力 但是卡了一下常还是过了

---

单点插入 + 区间最大异或和查询

考虑直接开一棵线段树，在每个点上维护一个线性基，修改直接插入，查询的时候把对应区间的线性基取出来直接求最大异或和。

复杂度 $O(n\log m\log x)$

---

然后这个东西是带着两个 $\log$ 的，第一个大概是 $16$ 左右，第二个是 $30$，复杂度卡到满的话大概 $2.4 \times 10^8$ 多点。

~~如果你代码写的像 BS 这么慢大概率是[过不去的](https://www.luogu.com.cn/record/57387853)~~

数据不是太强的话，卡一下常数是能过的。

---

当然直接吸氧的话就跑着比较轻松了

---

~~唯一有人看的~~代码

```cpp
/*
  Source: P4839 P哥的桶
*/
#include<cstdio>
#define RE register
#define pn putchar('\n')
#define Max(x, y) ((x) > (y) ? (x) : (y))
/*----------------------------------------------------------*/
const int A = 5e4 + 7;
/*----------------------------------------------------------*/
int n, m;
/*----------------------------------------------------------*/
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
void Print(int x) {if(x < 0) putchar('-'), x = -x; if(x > 9) Print(x / 10); putchar(x % 10 ^ 48);}
/*----------------------------------------------------------*/
struct LB {
	int p[35];
	LB() {for(RE int i = 31; ~i; --i) p[i] = 0;}
	inline void insert(int x) {
		for(RE int i = 31; ~i; --i) if(x >> i)
			if(p[i]) x ^= p[i]; else {p[i] = x; return ;}
	}
	inline void merge(LB x) {for(RE int i = 31; ~i; --i) if(x.p[i]) insert(x.p[i]);}
	inline int query() {
		int res = 0;
		for(RE int i = 31; ~i; --i) res = Max(res, res ^ p[i]);
		return res;
	}
};
namespace Seg {
	#define ls(x) x << 1
	#define rs(x) x << 1 | 1
	#define mid (t[p].l + t[p].r >> 1)
	struct node {int l, r; LB X;} t[A << 2];
	inline void push_up(int p) {t[p].X.merge(t[ls(p)].X); t[p].X.merge(t[rs(p)].X);}
	void build(int p, int l, int r) {
		t[p].l = l; t[p].r = r; if(l == r) return ;
		build(ls(p), l, mid); build(rs(p), mid + 1, r); push_up(p);
	}
	void up_date(int p, int pos, int k) {
		if(t[p].l == pos && t[p].r == pos) {t[p].X.insert(k); return ;}
		if(pos <= mid) up_date(ls(p), pos, k); else up_date(rs(p), pos, k); push_up(p);
	}
	LB query(int p, int l, int r) {
		if(l <= t[p].l && t[p].r <= r) return t[p].X; LB res;
		if(l <= mid) res.merge(query(ls(p), l, r));
		if(r > mid) res.merge(query(rs(p), l, r));
		return res;
	}
}
void Main() {
	n = read(); m = read(); Seg::build(1, 1, m);
	for(RE int i = 1; i ^ n + 1; ++i)
		if(read() == 1)
		{
			int x = read(), y = read();
			Seg::up_date(1, x, y);
		}
		else
		{
			int x = read(), y = read();
			Print(Seg::query(1, x, y).query()); pn;
		}
}
/*----------------------------------------------------------*/
signed main() {Main(); return 0;}

```


---

## 作者：封禁用户 (赞：0)

### 一、前置芝士

[线性基](https://www.luogu.com.cn/problem/P3812)

线段树~~大家应该都会吧~~

### 二、题目分析

+ 首先，看到单点修改区间查询，不难知应用线段树，而求异或最大和，可知应用线性基。

+ 也就是说，对于每一个加点操作，我们可以在线段树上每一个包含 $k$ 的线段所对应的线性基中加入 $x$ ，查询时就是将对应区间的线性基合并起来求答案即可。

+ 接着，咱们来分析下时间复杂度。

+ 第一个操作，有 $\log_{2}{m}$ 层，每层时间复杂度为 $\log_{2}{x}$ ，总的大概是 $O(n\log_{2}{m}\log_{2}{x})$ 也就是 $O(2.4 \times 10^8)$ ，所以第一个操作不能用合并，而应用单点加数，否则会因为常数过大而 TLE 四个点（~~亲身经历~~）。

### 三、代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void rd(T&x){
	x=0;T f=1;char ch=getchar();
	while(!isdigit(ch))f=(ch=='-')?-1:1,ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	x*=f;
}
const int M=50010;
struct Node{
	ll b[31];
	void insert(ll x){
		for(int i=30;i>=0;i--){
			if((x>>i)&1){
				if(!b[i]){
					b[i]=x;
					return;
				}
				else x^=b[i];
			}
		}
	}
	inline void insert(Node a){
		for(int i=30;i>=0;i--)
			if(a.b[i])insert(a.b[i]);
	}
}T[M<<2];
inline Node pushup(Node x,Node y){
	Node t;
	memset(t.b,0,sizeof t.b);
	t.insert(x);
	t.insert(y);
	return t;
}
#define mid ((l+r)>>1)
#define ls (k<<1)
#define rs (k<<1|1)
void update(int k,int l,int r,int x,int v){
	T[k].insert(v);
	if(l==r)return;
	if(x<=mid)update(ls,l,mid,x,v);
	else update(rs,mid+1,r,x,v);
}
Node query(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y)return T[k];
	Node t;
	memset(t.b,0,sizeof t.b);
	if(x<=mid)t.insert(query(ls,l,mid,x,y));
	if(y>mid)t.insert(query(rs,mid+1,r,x,y));
	return t;
}
int n,m;
int main(){
	rd(n),rd(m);
	for(int i=1;i<=n;i++){
		int op,x,y;
		rd(op),rd(x),rd(y);
		if(op==1)
			update(1,1,n,x,y);
		else{
			Node t=query(1,1,n,x,y);
			int ans=0;
			for(int i=30;i>=0;i--)
				if((ans^t.b[i])>ans)ans^=t.b[i];
			printf("%d\n",ans);
		}
	} 
	return 0;
}

```


---

## 作者：splendore (赞：0)

### 题意

维护下列两个操作：

- 单点修改

- 查询区间可表出的异或最大值

### 思路

看到表出异或最大值，我们首先想到线性基。

再看到需要区间查找，可以考虑线段树。

所以有了这个线段树套线性基的板子。

### 时间复杂度

线段树是 $O(\log n)$ 的，而线性基是 $O(\log^2 N)$ 的（$N$ 为值域），所以套起来就是 $O(\log^2 N \log n)$ 的，可以通过。

代码如下：

```
#include<cstdio>
#include<cstring>
using namespace std;
const int N=50005,B=31;
struct node{
	int p[B+1];
	node():p{}{}
	void clear(){memset(p,0,sizeof(p));}
	inline void ins(int x){
		for(int i=B;~i;--i)
			if(x>>i&1){
				if(!p[i])return p[i]=x,void();
				x^=p[i];
			}
	}
	void operator+=(node&b){for(int i=B;~i;--i)if(b.p[i])ins(b.p[i]);}
}res;
struct trnode{int l,r,lc,rc;node d;}tr[N<<1];int trlen;
#define ls(x) tr[x].lc
#define rs(x) tr[x].rc
int build(int l,int r){
	int now=++trlen;
	tr[now]={l,r,-1,-1};
	if(l==r)return now;
	int mid=(l+r)>>1;
	ls(now)=build(l,mid);
	rs(now)=build(mid+1,r);
	return now;
}
void change(int now,int x,int k){
	tr[now].d.ins(k);
	if(tr[now].l==tr[now].r)return;
	int mid=(tr[now].l+tr[now].r)>>1;
	if(x<=mid)change(ls(now),x,k);
	else change(rs(now),x,k);
}
void query(int now,int l,int r){
	if(tr[now].l==l&&tr[now].r==r)return res+=tr[now].d,void();
	int mid=(tr[now].l+tr[now].r)>>1;
	if(r<=mid)query(ls(now),l,r);
	else if(mid+1<=l)query(rs(now),l,r);
	else query(ls(now),l,mid),query(rs(now),mid+1,r);
}
int main(){
	int n,m;scanf("%d%d",&m,&n);
	build(1,n);
	for(int i=1,op,x,y;i<=m;++i){
		scanf("%d%d%d",&op,&x,&y);
		if(op&1)change(1,x,y);
		else{
			res.clear();query(1,x,y);
			int ans=0;
			for(int i=B;~i;--i)if(ans<(ans^res.p[i]))ans^=res.p[i];
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Fzrcy (赞：0)

异或和最大，线性基无疑了。

考虑用线段树维护线性基，对于插入操作直接插入即可，因为只有 $\log n$ 个节点会改变，所以一次插入的时间复杂度是 $\log n\log V$（$V$ 是值域）的，对于询问操作，直接将与询问区间有关的节点代表的线性基合并到一个大的线性基中，答案即为大的线性基的最大异或和，因为有 $\log n$ 个节点，合并的复杂度是 $\log^2V$ 的，所以询问的时间复杂度为 $\log n\log^2V$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e5+11;

int n, m;

int res[32], val[N<<2][32];

void ins(int *p, int x){
    for(int i=30; i>=0; i--)
    if(x>>i){
        if(!p[i]){p[i]=x; return;}
        else x^=p[i];
    }
}

void merge(int *p1, int *p2){
    for(int i=0; i<=30; i++)
        if(p2[i]) ins(p1, p2[i]);
}

void modify(int o, int l, int r, int x, int v){
    ins(val[o], v);
    if(l==r)return;
    int Mid=l+r>>1;
    if(x<=Mid) modify(o<<1, l, Mid, x, v);
    else modify(o<<1|1, Mid+1, r, x, v);
}

void Query(int o, int l, int r, int x, int y){
    if(l>=x&&r<=y){merge(res, val[o]);return;}
    int Mid=l+r>>1;
    if(x<=Mid) Query(o<<1, l, Mid, x, y);
    if(y>Mid)  Query(o<<1|1, Mid+1, r, x, y);
}

int Query(int x, int y){
    memset(res, 0, sizeof res);
    Query(1, 1, n, x, y);
    int ans=0;
    for(int i=30; i>=0; i--)
        if((ans^res[i])>ans) ans^=res[i];
    return ans;
}

int main(){
    scanf("%d%d", &m, &n);
    for(int i=1, op, x, y; i<=m; i++){
        scanf("%d%d%d", &op, &x, &y);
        if(op==1) modify(1, 1, n, x, y);
        else printf("%d\n", Query(x, y));
    }
    return 0;
}
```



---

## 作者：D2T1 (赞：0)

[$ \rule{20pt}{15pt}\kern{-16.5pt}\color{white}\raisebox{4.7pt}{\footnotesize\sf Link} $](https://www.luogu.com.cn/problem/P4839)

单点修改，区间查询，可以想到线段树。

然后在线段树的每一个节点上套一个线性基维护即可。

记得：线性基查询/合并一定要从大到小遍历。

```cpp
//P4839 need O2
#include <bits/stdc++.h>
using namespace std;

const int N = 5e4 + 10;
inline int read(){
	int x = 0; char ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar();
	while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x;
}

struct basis{
	int p[32];
	void ins(int val){
		for(int i = 31; i >= 0; -- i){
			if(!(val&(1<<i))) continue;
			if(!p[i]){ p[i] = val; break; }
			val ^= p[i];
		}
	}
	void ins(basis &x){
		for(int i = 31; i >= 0; -- i)
			ins(x.p[i]);
	}
} T[N<<2], res;
int n, m; 

int calc(basis x){
	int ans = 0;
	for(int i = 31; i >= 0; -- i)
		ans = max(ans, ans^x.p[i]);
	return ans;
}
void modify(int p, int L, int R, int pos, int val){
	if(L == R) T[p].ins(val);
	else {
		int mid = L + R >> 1;
		if(pos <= mid) modify(p<<1, L, mid, pos, val);
		else modify(p<<1|1, mid+1, R, pos, val);
		T[p].ins(T[p<<1]), T[p].ins(T[p<<1|1]);
	}
}
void query(int p, int L, int R, int l, int r){
	if(l <= L && R <= r) res.ins(T[p]);
	else {
		int mid = L + R >> 1;
		if(l <= mid) query(p<<1, L, mid, l, r);
		if(mid < r) query(p<<1|1, mid+1, R, l, r);
	}
}

signed main(){
	n = read(); m = read();
	for(int i = 1, op, a, b; i <= n; ++ i){
		op = read(); a = read(); b = read();
		if(op == 1) modify(1, 1, m, a, b);
		else{
			for(int j = 0; j <= 31; ++ j) res.p[j] = 0;
			query(1, 1, m, a, b);
			printf("%d\n", calc(res));
		}
	}
	return 0;
}
```

做完了这题可以去做 [P5607 [Ynoi2013] 无力回天 NOI2017](https://www.luogu.com.cn/problem/P5607)。

---


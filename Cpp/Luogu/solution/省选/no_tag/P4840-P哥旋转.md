# P哥旋转

## 题目背景

P哥开始学字符串了！

## 题目描述

P 哥学会了字符串处理的新方法——旋转。

“旋转”是这样一种操作：将原字符串最后面的字符抹去，然后把它加到最前面，得到一个新串。

P 哥可以进行无数次“旋转”操作，**让得到的新串中本质不同的回文子串尽可能多**。

两个回文串本质不同，当且仅当它们长度不同，或至少有一个相同位置的字符不同。

现在 P 哥得到了一个串 $S$，请你通过“旋转”操作帮 P 哥达成他的目标（即上面的加粗字体部分），并输出新串中不同的回文子串的个数。

## 说明/提示

设 $n$ 为串 $S$ 的长度。

- 对于前 $20\%$ 的数据，$n \le 100$。
- 对于前 $40\%$ 的数据，$n \le 2000$。
- 对于另 $10\%$ 的数据，保证得出正确答案不用进行旋转。
- 对于 $100\%$ 的数据，$n \le 1.5\times 10^6$。

此外，对于后 $50\%$ 的数据，保证串 $S$ 的非随机部分长度不超过 $5000$。

**注意**：本题采用 subtask 方式计分。前 $50\%$ 的数据是 $subtask#1$，该 subtask 采用加和的方式计分（你可以认为是传统计分方式）。后 $50\%$ 的数据是 $subtask#2$，该 subtask 采用取 $\min$ 的方式计分（即只要错一个点，后 $50$ 分全部没有）。

## 样例 #1

### 输入

```
ioimoio
```

### 输出

```
7
```

## 样例 #2

### 输入

```
fcfcfcfcfczxqprvvlpstpasxvpyyhaejxehdlhckmwmibsjwqbmfzlwpjqjghmlxunefabkpryqxbkqridpqrzemvfcfcfcfcfc```

### 输出

```
47```

# 题解

## 作者：Perfound (赞：10)

可以看得出来本题就是求把原串复制一遍后求每个长度为 $n$ 的子串的本质不同回文字串的最大值。

~~于是可以直接 [区间本质不同回文字串](https://blog.csdn.net/qq_35950004/article/details/106836626)~~。

但是数据范围不行，于是考虑直接维护一个动态回文自动机，可以开头删和尾部加。

对于开头可以和尾部维护最大回文后缀一样维护每个位置开头的最大回文前缀。而删除开头的字符后如果回文树不会变化，那么这个位置开头的最大回文前缀一定在后面出现过。于是可以对于尾部加入的字符暴力跳 $fail$ 修改每个可行的回文后缀的最大出现时间。

~~因为题目上写明的数据水所以可以过~~，不过应该可以离线下来用线段树维护。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;char s[3000010];int ed[3000010],pt[3000010];
int t[3000010][26],is[3000010],ln[3000010],to[3000010],idx,n,res,ans;
int find(int p,int i,int x){while(i-ln[p]-1<x||s[i]!=s[i-ln[p]-1])p=to[p];return p;}
int main(){
	scanf("%s",s+1),n=strlen(s+1);
	ln[0]=0,ln[1]=-1,to[0]=1,to[1]=-1,idx=1;
	for(int i=1;i<=n;i++)s[i+n]=s[i]-='a';
	for(int i=1,p=0;i<=(n<<1);i++){
		if(i>n&&i-n+ln[is[i-n]]-1==ed[is[i-n]]){
			t[pt[is[i-n]]][s[i-n]]=0,res--;
			if(is[i-n]==p)p=to[p];
		}
		p=find(p,i,max(1,i-n+1));
		if(!t[p][s[i]]){
			to[++idx]=t[find(to[p],i,max(1,i-n+1))][s[i]],res++;
			ln[idx]=ln[p]+2,t[p][s[i]]=idx,pt[idx]=p;
		}p=t[p][s[i]],ans=max(ans,res);
		for(int q=p;~q;q=to[q])ed[is[i-ln[q]+1]=q]=i;
	}
	cout<<ans;return 0;
}
```

~~好像官方正解好像也是O(玄学)的~~。

---

## 作者：262620zzj (赞：2)

# 思路

前置知识：回文自动机。

首先破环为链，复制一份 $s$，变成了问 $[1,n]$ 到 $[n-1,2n-1]$ 中每个区间的最大本质不同回文子串个数。回文自动机他有一个重要的性质，那就是回文自动机的每个节点，代表了本质相同的一些回文子串。于是我们可以记录一个 cnt 数组，表示每个点（对应的那个回文子串）出现了多少次，答案就是 $cnt>0$ 的点数。

在加入一个字符时，通过跳一遍 fail 找到所有以它结尾的回文串，将这些点加一，然后我们需要在 $i-len_x+n$ 的位置将它减回去。其中 $x$ 是所有回文后缀结点。用一个堆维护这个信息即可。

注意，我们只计算长度小于等于 $n$ 的子串（因为我们复制了一份原字符串，所以可能会存在由两个原串拼成的回文串，这是不能被计算的），跳 fail 时需要注意这一点。

注意到数据随机，所以 fail 树上的点深度基本都很低，于是复杂度不会很高。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=3e6+5;
int n,len[N],cnt[N],fail[N],trie[N][26],tot=1;
string s;
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > Q;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>s,n=s.size(),s='$'+s+s;
    len[0]=0,fail[0]=1;
    len[1]=-1,fail[1]=0;
    int ans=0,last=1,sub=0;
    for(int i=1;i<=2*n-1;i++){
        while(!Q.empty()&&Q.top().first+n-1<i){
            int q=Q.top().second;
            cnt[q]--;
            if(cnt[q]==0)sub--;
            Q.pop();
        }
        int fa=last;
        while(len[fa]>n-2||s[i]!=s[i-len[fa]-1])fa=fail[fa];
        int &v=trie[fa][s[i]-'a'];
        if(!v){
            ++tot;
            int tmp=fail[fa];
            while(s[i]!=s[i-len[tmp]-1])tmp=fail[tmp];
            tmp=trie[tmp][s[i]-'a'];
            v=tot;
            fail[v]=tmp;
            len[v]=len[fa]+2;
        }
        for(int q=v;q>=2;q=fail[q]){
            if(cnt[q]==0)sub++;
            cnt[q]++;
            Q.push(make_pair(i-len[v]+1,q));
        }
        last=v;
        ans=max(ans,sub);
    }
    cout<<ans;
    return 0;
}
```

---


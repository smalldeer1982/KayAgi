# 城市旅行

## 题目描述


W 国地大物博，由 $n$ 座城市组成，共 $n-1$ 条双向道路连接其中的两座城市，且任意两座城市都可相互到达。

风景秀美的 W 国吸引了无数慕名而来的游客，根据游客对每座城市的打分，我们定义第 $i$ 座城市的美丽度为 $a_i$。一次从城市 $x$ 到城市 $y$ 的旅行，所获得的的愉悦指数为从城市 $x$ 到城市 $y$ 所有城市的美丽度之和（包括 $x$ 和 $y$）。我们定义这个值为 $H(x,y)$。

现在小 A 在城市 $X$，Sharon 在城市 $Y$，他们想知道如果在城市 $X$ 到城市 $Y$ 之间的所有城市中任选两座城市 $x$ 和 $y$（$x$ 可以等于 $y$），那么 $H(x,y)$ 的期望值是多少，我们记这个期望值为 $E(x,y)$。

当然，城市之间的交通状况飘忽不定，因此我们不能排除某些时刻某些道路将无法通行。某些时刻会突然添加新的道路。以及游客们审美观的改变，某些城市的美丽度也会发生变化。作为 W 国负责旅游行业的 T 君，他要求你来写一个程序来模拟上面的所有过程。

## 说明/提示

对于所有数据满足 $1\le N\le 50000,1\le M\le 50000,1\le a_i\le 10^6,1\le D\le 100,1\le u,v\le N$。

## 样例 #1

### 输入

```
4 5
1 3 2 5
1 2
1 3
2 4
4 2 4
1 2 4
2 3 4
3 1 4 1
4 1 4```

### 输出

```
16/3
6/1```

# 题解

## 作者：Wen_kr (赞：15)

很有意思的一道题，看到还没有人发布题解我就发了...

ps : PoPoQQQ dalao Orz

涉及 Link 和 Cut,我们考虑使用 LCT。

对于一条路径：

$a_1a_2a_3a_4\dots a_n$

我们定义 $a_i$ 为这条路径上第 $i$ 个点的点权 (题目上的美丽程度)

那么设 $exp$ 表示这条路径的期望，那么
$exp = \frac{a_1*1*n+a_2*2*(n-1)+a_3*3*(n-2)+\dots+a_n*n*1}{C_n^2}$

(洛咕不能用 cfrac 字体有点小，见谅)

这个式子怎么得来的呢？

我们首先考虑子路径条数，显然这个数字等于 $C_n^2$

对于第 $i$ 个点的权值 $a_i$，它显然会被 $i * (n - i + 1)$ 条路径覆盖(从 $i$ 及 $i$ 的左边选择左端点，从 $i$ 及 $i$ 的右边选择右端点)。

于是第 $i$ 个点最后产生的贡献就是 $a_i * i * (n - i + 1)$

这些贡献累加起来就成了我们的分子。

分母我们在 $split$ 之后只需要 $sz$ 即可简单地算出，我们考虑在 $splay$ 每个节点中维护分子。

怎样进行维护呢，我们考虑一条跨过根节点的路径长这样：

a_1 --- a_2 --- a_3 --- a_4(根节点) --- a_5 --- a_6

$\ \ \ \ \ \ \ $左子树$\qquad\qquad\qquad\qquad$ 右子树

此时根节点部分维护的分子为
$a_1*1*6+a_2*2*5+a_3*3*4+\dots+a_6*6*1$

左子树维护的分子为

$a_1*1*3+a_2*2*2+a_3*3*1$

左子树对当前节点的贡献应当为：

$a_1*1*6+a_2*2*5+a_3*3*4$

考虑两者做差，得到：

$a_1*1*3+2_2*2*3+a_3*3*3 = 3*(a_1+2a_2+3a_3)$

观察发现，外面的这个 $3$ 恰好等于右子树的大小 + 1

我们设 $lsum = a_1 * 1 + a_2 * 2 + a_3 * 3 + \dots + a_n * n$

则左子树对答案的贡献为 $exp_{lc}+lsum_{lc} * (sz_{rc}+1)$

同理，我们设 $rsum = a_1 * n + a_2 * (n - 1) + \dots + a_n * 1$

那么右子树对答案的贡献为 $exp_{rc}+rsum_{rc} * (sz_{lc} + 1)$

还有根节点对答案的贡献，这个很好计算，就是：

$val_{rt}*(sz_{lc}+1)*(sz_{rc}+1)$

根节点的期望就可以计算了：
$exp_{rt} = exp_{lc}+exp_{rc}+val_{rt}*(sz_{lc}+1)*(sz_{rc}+1)+$
$lsum_{lc} * (sz_{rc}+1)+rsum_{rc} * (sz_{lc} + 1)$

$lsum,rsum$ 也很好维护。

我们设 $sum$ 表示当前子树内所有节点的权值和，那么

$lsum = lsum_{lc} + lsum_{rc} + sum_{rc} * (sz_{lc} + 1) + val_{rt} * (sz_{lc}+1)$

$rsum = rsum_{rc} + rsum_{lc} + sum_{lc} * (sz_{rc} + 1) + val_{rt} * (sz_{rc}+1)$

这样，我们就解决了这个问题的一半：区间 $Query$

---

我们现在考虑更新。

假设我们给某个节点的子树的所有节点权值加上 $p$

那么显然地， 

$sum_{rt} = sum_{rt} + p * sz_{rt}$

$lsum_{rt} = lsum_{rt} + p * \frac{sz_{rt}*(sz_{rt}+1)}{2}$

$rsum_{rt}$ 与 $lsum_{rt}$ 相同。

$val_{rt} = val_{rt} + p$

然而 $exp_{rt}$ 就很蛋疼了。

我们设 $n = sz_{rt}$

则$exp_{rt} = exp_{rt} + p * (1 * n + 2 * (n - 1) + \dots + n * 1)$

考虑重写 $p$ 后面那一部分，我们能得到：

$(1 + 2 + 3 + \dots + n) * n - (1 * 2 + 2 * 3 + \dots + (n - 1) * n)$

前一部分很好化简，后面那一部分可以写成：

$1^2+2^2+3^2+\cdots+(n-1)^2+1+2+\dots+(n-1)$

根据小学奥数，这后半个式子整个等于:

$\frac{n * (n + 1)}{2} * n - \frac{1}{6}*(n-1)*n*(2n-1)-\frac{n*(n-1)}{2}$

然后开始化简，步骤如下:

$$
\frac{n^3+n^2}{2}-\frac{2n^3-2n^2-n^2+n}{6}-\frac{n^2-n}{2}
$$

$$
\frac{3n^3+3n}{6}-\frac{2n^3-2n^2-n^2+n}{6}
$$

$$
\frac{n^3+3n^2+2n}{6}
$$

$$
\frac{n(n^2+3n+2)}{6}
$$

$$
\frac{n(n+1)(n+2)}{6}
$$

这样我们就得到了更新的方法。

另外的，这道题 $Push\_Down$ 必须当场 $Push\_Down$,否则会出问题(因为我们需要调用 $lsum$ 和 $rsum$

最后，代码:

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

int son[50050][2],fa[50050],sz[50050];
long long lsum[50050],val[50050],rsum[50050],EXP[50050],sum[50050],upd_tag[50050];
int rev_tag[50050];

void Push_Up(int rt)
{
	sum[rt] = val[rt] + sum[son[rt][0]] + sum[son[rt][1]];
	sz[rt] = 1 + sz[son[rt][0]] + sz[son[rt][1]];
	lsum[rt] = lsum[son[rt][0]] + val[rt] * (sz[son[rt][0]] + 1) + lsum[son[rt][1]] + sum[son[rt][1]] * (sz[son[rt][0]] + 1);
	rsum[rt] = rsum[son[rt][1]] + val[rt] * (sz[son[rt][1]] + 1) + rsum[son[rt][0]] + sum[son[rt][0]] * (sz[son[rt][1]] + 1);
	EXP[rt] = EXP[son[rt][0]] + EXP[son[rt][1]] + val[rt] * (sz[son[rt][0]] + 1) * (sz[son[rt][1]] + 1) +
	          lsum[son[rt][0]] * (sz[son[rt][1]] + 1) + rsum[son[rt][1]] * (sz[son[rt][0]] + 1);
}

void Rev(int rt)
{
	swap(son[rt][0],son[rt][1]);
	swap(lsum[rt],rsum[rt]);
	rev_tag[rt] ^= 1;
}

void Add(int rt,int valx)
{
	long long val1 = (sz[rt] * 1ll * (sz[rt] + 1)) / 2,val2 = (sz[rt] * 1ll * (sz[rt] + 1) * (sz[rt] + 2)) / 6;
	sum[rt] += valx * 1ll * sz[rt];
	val[rt] += valx;
	lsum[rt] += val1 * valx;
	rsum[rt] += val1 * valx;
	EXP[rt] += valx * val2;
	upd_tag[rt] += valx;
}

void Push_Down(int rt)
{
	if(rev_tag[rt])
	{
		Rev(son[rt][0]);
		Rev(son[rt][1]);
		rev_tag[rt] = 0;
	}
	if(upd_tag[rt])
	{
		Add(son[rt][0],upd_tag[rt]);
		Add(son[rt][1],upd_tag[rt]);
		upd_tag[rt] = 0;
	}
}

void Down(int rt)
{
	if(fa[rt]) Down(fa[rt]);
	Push_Down(rt);
}

bool is_root(int rt)
{
	return (son[fa[rt]][0] != rt && son[fa[rt]][1] != rt) || rt == 0;
}

void rotate(int rt)
{
	int f = fa[rt],g = fa[f];
	int way = son[f][1] == rt;
	if(!is_root(f)) son[g][son[g][1] == f] = rt;
	fa[rt] = g; son[f][way] = son[rt][way ^ 1];
	if(son[rt][way ^ 1]) fa[son[rt][way ^ 1]] = f;
	son[rt][way ^ 1] = f; fa[f] = rt;
	Push_Up(f); Push_Up(rt);
}

void splay(int rt)
{
	Down(rt);
	while(!is_root(rt))
	{
		int f = fa[rt],g = fa[f];
		if(!is_root(f)) (son[f][1] == rt) ^ (son[g][1] == rt) ? rotate(rt) : rotate(f);
		rotate(rt);
	}
}

void Access(int u)
{
	for(int v = 0;u;v = u,u = fa[u])
	{
		splay(u);
		son[u][1] = v;
		Push_Up(u);
	}
}

void make_root(int u)
{
	Access(u); splay(u); Rev(u);
}

int find_root(int u)
{
	Access(u); splay(u);
	while(son[u][0]) u = son[u][0];
	return u;
}

long long split(int u,int v)
{
	if(find_root(u) != find_root(v)) return -1;
	make_root(u); Access(v); splay(v);
	return EXP[v];
}

void Update(int u,int v,int val)
{
	if(find_root(u) != find_root(v)) return ;
	make_root(u); Access(v); splay(v);
	Add(v,val);
}

void Link(int u,int v)
{
	if(find_root(u) == find_root(v)) return ;
	make_root(u); fa[u] = v;
}

void Cut(int u,int v)
{
	if(find_root(u) != find_root(v)) return ;
	make_root(u); Access(v); splay(v);
	if(son[u][1] || son[v][0] != u) return;
	son[v][0] = fa[u] = 0;
	Push_Up(v);
}

long long gcd(long long a,long long b)
{
	return b == 0 ? a : gcd(b,a % b);
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n; ++ i) scanf("%lld",&val[i]),Push_Up(i);
	for(int i = 1;i < n; ++ i)
	{
		int u,v;
		scanf("%d%d",&u,&v); Link(u,v);
	}
	for(int i = 1;i <= m; ++ i)
	{
		int op,u,v;scanf("%d%d%d",&op,&u,&v);
		int w; if(op == 3) scanf("%d",&w);
		if(op == 1) Cut(u,v);
		else if(op == 2) Link(u,v);
		else if(op == 3) Update(u,v,w);
		else
		{
			long long tmp = split(u,v);
			if(tmp == -1) printf("-1\n");
			else
			{
				long long csz = sz[v] * (sz[v] + 1) / 2;
				long long gcdx = gcd(csz,tmp);
				printf("%lld/%lld\n",tmp/gcdx,csz/gcdx);
			}
		}
	}
}
```

---

## 作者：Mihari (赞：4)

[TOC]

# 壹、题目描述

[传送门 to LUOGU](https://www.luogu.com.cn/problem/P4842)

# 贰、一些思考

目测 $\tt LCT$ .

对于一条路径，设点排下来是 $p_1,p_2,p_3,...,p_k$，那么这条路径的 $E$ 的值即为
$$
\sum_{i=1}^kp_i\times i\times (k-i+1)\over {k\choose 2}
$$
为了简便表达，我们将 $v_{p_i}$ 直接写成 $p_i$.

对于一个点，我们肯定得维护答案，考虑当前根为 $t$，那么 $t$ 中一定需要维护上面那个值的分子，我们记这个东西为 $\rm exp$，但是在由子到父亲上传的时候，对于 $t$ 的左子树，在它的根中，维护的比我们想要的要少一些，少的部分其实就是左子树的点和右子树匹配的情况，对于左子树我们单独再储存一个 $1\times p_1+2\times p_2+...+(t-1)\times p_{t-1}$，记这个变量为 $\rm lsum$，那么少的部分就是 $\text{lsum}\times (\text{siz}_r+1)$，这是左边的点和右边匹配的情况，同样，我们便也需要存下一个 $\text{rsum}=1\times p_k+2\times p_{k-1}+....$ 为右子树的情况，上传同理；

考虑我们接下来需要维护的变量

- $\rm siz$，不必多说；
- $\rm val$，就是这个点的点值；
- $\exp$，起到类似于储存答案的功效；
- $\rm lsum,rsum$，上传时有奇效；
- $\rm sum$，处理 $\rm lsum,rsum$ 时需要使用，表示子树内所有点的 $\rm val$ 之和；

但是还有一个操作 —— 路径权值修改。对于 $\rm lsum,rsum$ 的修改都比较简单，有 $\Delta=x\times (1+2+3+...+k)=x{k(k+1)\over 2}$.  修改的难点主要在于 $\rm exp$ 的修改上，对于它，我们不妨将式子写出来：
$$
\begin{aligned}
Ans&=\sum_{i=1}^k(p_i+\Delta)\times i\times (k-i+1) \\
&=\sum_{i=1}^kp_i\times i\times (k-i+1)+\Delta\sum_{i=1}^ki\times (k-i+1) \\
&=\exp+\Delta\times {k(k+1)(k+2)\over 6}
\end{aligned}
$$
最后一步的推导直接展开合并写成通项即可。

所以对于 $\exp$ 的修改也可以直接做了，只要我们有 $k$ 即 $\rm siz$ .

然后，就切掉了？剩下的，就是如何用代码实现这个过程了。

时间复杂度 $\mathcal O(n\log n)$.

# 叁、参考代码

$\color{red}{\text{talk is LCT, but I have no code.}}$

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define mp(a, b) make_pair(a, b)

typedef long long ll;
template<class T>inline T readin(T x){
    x=0; int f=0; char c;
    while((c=getchar())<'0' || '9'<c) if(c=='-') f=1;
    for(x=(c^48); '0'<=(c=getchar()) && c<='9'; x=(x<<1)+(x<<3)+(c^48));
    return f? -x: x;
}

const int maxn=5e4;

ll gcd(ll x, ll y){
    return !y? x: gcd(y, x%y);
}

int n, m;

namespace lct{
    int son[maxn+5][2], fa[maxn+5];
    int siz[maxn+5], rev[maxn+5];
    ll tag[maxn+5], lsum[maxn+5], rsum[maxn+5], exp[maxn+5], sum[maxn+5], val[maxn+5];
    inline int isroot(int x){
        return son[fa[x]][0]!=x && son[fa[x]][1]!=x;
    }
    inline void reverse(int x){
        if(!x) return;
        swap(son[x][0], son[x][1]);
        swap(lsum[x], rsum[x]);
        rev[x]^=1;
    }
    inline void add(int x, ll delta){
        if(!x) return;
        tag[x]+=delta, val[x]+=delta;
        lsum[x]+=delta*siz[x]*(siz[x]+1)/2;
        rsum[x]+=delta*siz[x]*(siz[x]+1)/2;
        sum[x]+=delta*siz[x];
        exp[x]+=delta*siz[x]*(siz[x]+1)*(siz[x]+2)/6;
    }
    inline void pushup(int x){
        int ls=son[x][0], rs=son[x][1];
        siz[x]=siz[ls]+siz[rs]+1;
        sum[x]=sum[ls]+sum[rs]+val[x];
        lsum[x]=lsum[ls]+(siz[ls]+1)*(val[x]+sum[rs])+lsum[rs];
        rsum[x]=rsum[rs]+(siz[rs]+1)*(val[x]+sum[ls])+rsum[ls];
        exp[x]=exp[ls]+exp[rs]+lsum[ls]*(siz[rs]+1)+rsum[rs]*(siz[ls]+1)+val[x]*(siz[ls]+1)*(siz[rs]+1);
    }
    inline void pushdown(int x){
        if(tag[x]) add(son[x][0], tag[x]), add(son[x][1], tag[x]);
        if(rev[x]) reverse(son[x][0]), reverse(son[x][1]);
        tag[x]=rev[x]=0;
    }
    inline void connect(int x, int y, int d){
        son[x][d]=y, fa[y]=x;
    }
    inline void rotate(int x){
        int y=fa[x], z=fa[y], d=(son[y][1]==x);
        fa[x]=z; if(!isroot(y)) son[z][son[z][1]==y]=x;
        connect(y, son[x][d^1], d);
        connect(x, y, d^1);
        pushup(y), pushup(x);
    }
    inline void splay(int x){
        static int sta[maxn+5], ed=0; int now=x;
        while(sta[++ed]=now, !isroot(now)) now=fa[now];
        while(ed) pushdown(sta[ed--]);
        int y, z;
        while(!isroot(x)){
            y=fa[x], z=fa[y];
            if(!isroot(y))
                (son[z][1]==y)^(son[y][1]==x)? rotate(y): rotate(x);
            rotate(x);
        }
    }
    inline void access(int x){
        for(int pre=0; x; pre=x, x=fa[x])
            splay(x), son[x][1]=pre, pushup(x);
    }
    inline int findrt(int x){
        access(x); splay(x); pushdown(x);
        while(son[x][0]) pushdown(x=son[x][0]);
        return splay(x), x;
    }
    inline void makert(int x){
        access(x); splay(x); reverse(x);
    }
    inline void link(int x, int y){
        makert(x);
        if(findrt(y)==x) return;
        fa[x]=y;
    }
    inline void cut(int x, int y){
        makert(x);
        if(findrt(y)==x && fa[y]==x && son[y][0]==0)
            son[x][1]=fa[y]=0, pushup(x);
    }
    inline void alladd(int x, int y, ll delta){
        makert(x);
        if(findrt(y)!=x) return;
        access(y); splay(y);
        add(y, delta);
    }
    inline pair<ll, int> query(int x, int y){
        makert(x);
        if(findrt(y)!=x) return mp(-1, -1);
        access(y); splay(y);
        return mp(exp[y], siz[y]);
    }
    inline void print(){
        for(int i=1; i<=n; ++i){
            printf("node %d :>\n", i);
            printf("fa == %d\n", fa[i]);
            printf("ls == %d, rs == %d\n", son[i][0], son[i][1]);
            printf("val == %lld, siz == %d\n", val[i], siz[i]);
            printf("sum == %lld, exp == %lld\n", sum[i], exp[i]);
            puts("------------------------------");
        }
    }
    inline void initial(){
        for(int i=1; i<=n; ++i){
            siz[i]=1, lsum[i]=rsum[i]=exp[i]=sum[i]=val[i]=readin(1);
        }
        int u, v;
        for(int i=1; i<n; ++i){
            u=readin(1), v=readin(1);
            link(u, v);
        }
    }
}

inline void input(){
    n=readin(1), m=readin(1);
    lct::initial();
}

signed main(){
    input();
    int cmd, x, y, d;
    while(m--){
        cmd=readin(1), x=readin(1), y=readin(1);
        if(cmd==1) lct::cut(x, y);
        else if(cmd==2) lct::link(x, y);
        else if(cmd==3){
            d=readin(1);
            lct::alladd(x, y, d);
        }
        else if(cmd==4){
            pair<ll, int>ret=lct::query(x, y);
            ll up=ret.first, down=ret.second;
            if(up==-1){ printf("-1\n"); continue; }
            down=down*(down+1)/2;
            ll d=gcd(up, down);
            printf("%lld/%lld\n", up/d, down/d);
        }
    }
    return 0;
}
```

# 肆、用到の小 $\tt trick$

本题计算期望的方法是 $\cfrac{\text{整体}}{\text{整体}}$，考虑每个点被算进多少次路径，得到这个点对期望的总价值贡献，求和，以方案数除之，是答案也。

另外，对于这种题，似乎有时可以从询问方面得到我们需要维护什么，对于修改时，再考虑怎么维护这些值即可。

但是可能也会出现我们一开始无法直接维护答案，因为不是所有的答案都可以直接维护，所以有时可以将答案拆成多个部分，分开进行维护，然后拼接起来，比如此题并未将 $k\choose 2$ 放入维护中，为之高次，亦于分母耶，是大繁也。

---

## 作者：万弘 (赞：2)

## 城市游行

tag:LCT,math.

介绍一种式子不同的方法。

先考虑这个 H 究竟是什么玩意。显然不能大力枚举路径去算，我们考虑每一个点的贡献：对于点 $ s $ ,记其与点 $ y $ 的距离为 $ \text{dep}(s) $ , $ x $ 到 $ y $ 的路径上点数为 $ all $ ,则贡献为 $ \text{dep}(s)*(all-\text{dep}(s)+1)*w(s) $ 

答案就是 $ \sum_{s\in path(x,y)}\text{dep}(s)*(all-\text{dep}(s)+1)*w(s) $ 

直接做是平方的，拆开来得到 $ ((all+1)\sum_s\text{dep}(s)*w(s))-\sum_s\text{dep}^2(s)*w(s) $ 

也就是说，我们要维护链上每个点深度乘点权的和，与深度的平方乘点权的和，同时要支持连边断边，链加。

记 $ s $ 的点权，点权和，深度和，深度平方和，深度乘点权和，深度平方乘点权和（以上均指以 $ s $ 为根的 splay 中的信息，“深度”均指到这个 splay 中最浅的点的距离+1）分别为 $ w(s), sumw(s),sumd(s),sumd2(s),dw(s),d2w(s) $ .

LCT 维护额外信息的关键在于 pushup，因此考虑如何通过左儿子 $ l $ ,右儿子 $ r $ 的信息来推出 $ x $ 的信息,记 $ x $ 的深度(左儿子大小+1）为 $ cur $ 。

点权和略。  
 $ sumd(s)=sumd(l)+cur+(sumd(r)+cur*size(r)) $   
 $ sumd2(s)=sumd2(l)+cur^2+(sumd2(r)+2cur*sumd(r)+size(r)*cur^2) $   
 $ dw(s)=dw(l)+cur*w(s)+(dw(r)+cur*sumw(r)) $   
 $ d2w(s)=d2w(l)+cur^2*w(s)+(d2w(r)+2cur*dw(r)+cur^2*sumw(r)) $ 

这几条的思路都是，左儿子不受影响， $ s $ 按定义算，然后算左儿子与 $ s $ 对右儿子的影响。

但是仅仅修改pushup是不够的。如果你像我那样仅仅改pushup，你会发现 $ w,sumw,sumd,sumd2 $ 都是对的，但 $ dw,d2w $ 是错的。

仔细观察~~debug~~ 可以发现， $ dw,d2w $ 的特殊之处在于，与splay的顺序有关（就是说，交换左右儿子，前面几个值不会改变，但 $ dw,d2w $ 会变化）。而LCT因为换根操作的存在，必然是有交换左右儿子的操作的，所以就挂掉了。要改对非常容易，我们再记录两个 $ Rdw,Rd2w $ 表示到splay中最深的点的距离+1的和，下传翻转标记的时候把当前点的 $ dw,Rdw $ 交换， $ d2w,Rd2w $ 交换就好了。

链加就不说了，和线段树上区间加是一个难度。

复杂度 $ \mathcal O(m\log n) $ 

写本文时间仓促，如有错漏恳请指出。

主要代码：

```cpp
#define MAXN 100011
struct LCT
{
    int fa[MAXN],son[MAXN][2],rev[MAXN],w[MAXN],add[MAXN];
    ll size[MAXN],sumw[MAXN],sumd[MAXN],sumd2[MAXN];
    ll dw[MAXN],Rdw[MAXN],d2w[MAXN],Rd2w[MAXN];
    void init(int n){for(int i=1;i<=n;++i)w[i]=read(),size[i]=1;}
    bool not_root(int x){return son[fa[x]][0]==x||son[fa[x]][1]==x;}
    void pushrev(int x){if(x)std::swap(dw[x],Rdw[x]),std::swap(d2w[x],Rd2w[x]),std::swap(son[x][0],son[x][1]),rev[x]^=1;}//翻转
    void pushadd(int x,int k)
    {
        if(!x)return;
        sumw[x]+=size[x]*k,w[x]+=k,dw[x]+=sumd[x]*k,Rdw[x]+=sumd[x]*k, add[x]+=k;
        d2w[x]+=sumd2[x]*k,Rd2w[x]+=sumd2[x]*k;
    }
    void pushup(int x)
    {
        int l=son[x][0],r=son[x][1];
        ll cur=size[l]+1;
        size[x]=size[l]+size[r]+1;
        sumw[x]=sumw[l]+sumw[r]+w[x];
        sumd[x]=sumd[l]+cur+(sumd[r]+cur*size[r]);
        sumd2[x]=sumd2[l]+cur*cur+(sumd2[r]+2*cur*sumd[r]+size[r]*cur*cur);

        dw[x]=dw[l]+cur*w[x]+(dw[r]+cur*sumw[r]);
        d2w[x]=d2w[l]+cur*cur*w[x]+(d2w[r]+2*cur*dw[r]+cur*cur*sumw[r]);

        cur=size[r]+1;
        Rdw[x]=Rdw[r]+cur*w[x]+(Rdw[l]+cur*sumw[l]);
        Rd2w[x]=Rd2w[r]+cur*cur*w[x]+(Rd2w[l]+2*cur*Rdw[l]+cur*cur*sumw[l]);
    }
    void pushdown(int x)
    {
        int l=son[x][0],r=son[x][1];
        if(rev[x])pushrev(l),pushrev(r),rev[x]=0;
        if(add[x])pushadd(l,add[x]),pushadd(r,add[x]),add[x]=0;
    }
    void rotate(int x)
    {
        int y=fa[x],z=fa[y],k=(son[y][1]==x);
        if(not_root(y))son[z][son[z][1]==y]=x;
        fa[x]=z;
        son[y][k]=son[x][!k],fa[son[x][!k]]=y;
        son[x][!k]=y,fa[y]=x;
        pushup(y),pushup(x);
    }
    int s[MAXN];
    void splay(int x)
    {
        int top=0;
        s[++top]=x;
        for(int y=x;not_root(y);y=fa[y])s[++top]=fa[y];
        while(top)pushdown(s[top--]);
        while(not_root(x))
        {
            int y=fa[x];
            if(not_root(y))rotate((son[y][1]==x)==(son[fa[y]][1]==y)?y:x);
            rotate(x);
        }
    }
    void access(int x)
    {
        for(int y=0;x;y=x,x=fa[x])
            splay(x),son[x][1]=y,pushup(x);
    }
    int get_root(int x)
    {
        access(x),splay(x);
        while(son[x][0])x=son[x][0];
        return splay(x),x;
    }
    void make_root(int x){access(x),splay(x),pushrev(x);}
    bool split(int x,int y)
    {
        if(get_root(x)!=get_root(y))return 0;
        make_root(x),access(y),splay(y);
        return 1;
    }
    //
    void Link(int x,int y)
    {
        if(get_root(x)!=get_root(y))make_root(x),fa[x]=y;//,printf("Link %d %d\n",x,y);
    }
    void Cut(int x,int y)
    {
        if(get_root(x)!=get_root(y))return;
        split(x,y);
        if(size[y]==2)fa[x]=0,son[y][0]=0,pushup(y);//,printf("Cut %d %d\n",x,y);
    }
    void Add(int x,int y,int k){if(split(x,y))pushadd(y,k);}
    void solve(int x,int y)
    {
        if(split(x,y))
        {
            ll a=(size[y]+1)*dw[y]-d2w[y],b=size[y]*(size[y]+1)/2,g=gcd(a,b);
            printf("%lld/%lld\n",a/g,b/g);
        }
        else puts("-1");
    }
}lct;
```



---

## 作者：lcjqwq (赞：2)

### Description

给一颗以 $1$ 为根的有根树，维护以下操作

1. 连接 $(u,v)$ 这条边
2. 删除 $(u,v)$ 这条边
3. 给 $u$ 到 $v$ 的链上每个点加上一个数
4. 求在 $(u,v)$ 上任意选两个点它们之间的权值和的期望

$n, m \leq 50000, a_i \leq 10^6$

### Solution

前三个操作就是 LCT 板子，考虑如何在 LCT 上维护 4 操作

为了方便，设这个路径是 $a_1, a_2, a_3, \cdots, a_{siz}$ ，其中 $siz$ 是长度

考虑每个点的贡献，易得我们要求的期望值 $=\frac{\sum\limits_{i=1}^{siz} i (siz - i + 1)a_i}{\frac{siz(siz+1)}{2}}$ 

显然这个分母很好搞，只需要考虑怎么在 LCT 上维护分子，或者说在平衡树上。

也就是说，如果知道左子和右子的答案如何更新出这个点的答案

设左子表示 $a_1, a_2, \cdots, a_p$， 该点的值是 $a_{p+1}$ ，右子表示 $a_{p+2}, \cdots, a_{siz}$ 

可以得到：左子的 $siz_0 = p$，右子的 $siz_1 = siz - p - 1$

改点要的答案减去左子的答案减去右子的答案便是 

$\sum\limits_{i=1}^{siz}i(siz - i + 1)a_i - \sum\limits_{i=1}^{p}i(p-i+1)a_i-\sum\limits_{i=p+2}^{siz} (i-p-1)(siz - i + 1)a_i$

$=\sum\limits_{i=1}^{p} i(siz-p)a_i+a_{p+1}(p+1)(siz-p)+\sum\limits_{i=p+2}^{siz}(p+1)(siz-i+1)a_i$

根据上面得到的 $siz_0=p,siz_1=siz-p-1$ 简单化简一下可以得到

$=(siz_1+1)\sum\limits_{i=1}^{siz_0}i\cdot a_i+a_{siz_0+1}(siz_0+1)(siz_1+1)+(siz_0+1)\sum\limits_{i=p+2}(siz - i +1)a_i$

到这里应该你已经知道怎么做了..

为了清楚，再令 

$b_1, b_2, \cdots,b_{siz_b}$ 是左子的， $c_1, c_2, \cdots,c_{siz_c}$ 是右子的，$d$ 是这个点本身的值。那么可以化简成简单清楚对称的形式：

$=(siz_c+1)\sum\limits_{i=1}^{siz_b}i\cdot b_i+d(siz_b+1)(siz_c+1)+(siz_b+1)\sum\limits_{i=1}^{siz_c}(siz_c-i+1)c_i$

你只需要每个点再维护两个值：

$ls=\sum\limits_{i=1}^{siz}i\cdot a_i$ 和 $rs=\sum\limits_{i=1}^{siz}(siz - i +1)a_i$ 

就可以从左右两个儿子得到自己的值

这两个东西维护还是比较简单的..具体的话就是再维护一个 $s$ 为子树里所有数的和然后令 $b,c$ 是左右两个儿子，那么有

$ls = ls_b+d\cdot(siz_b+1)+ls_c+s_c (siz_b+1)$

和

$rs=rs_c+d\cdot(siz_c+1)+rs_b+s_b(siz_c+1)$ 

就这样维护

以上是如何用左右儿子的信息得到自己，再来考虑链加的问题

一条链加上一个数 $x$ ，那么会如何影响我们维护的值？

- 对于 $s$：$s = s + siz\cdot x$
- 对于 $ls$：$ls = ls + \sum\limits_{i=1}^{siz}i \cdot x = ls + \frac{siz(siz+1)}{2}\cdot x$
- 对于 $rs$：和 ls 一样 $rs = rs+\frac{siz(siz+1)}{2}\cdot x$
- 对于最后的答案 $S$：$S = S + \sum\limits_{i=1}^{siz} i \cdot (siz - i +1)\cdot x$ 通过简单计算可得 $S= S+\frac{siz(siz+1)(siz+2)}{6}\cdot x$
- 对于自己的值：直接加上 $x$ （废话）

然后 LCT 板子套一套就做完了

注意事项：
- 翻转的时候需要 swap(ls, rs)
- 两个点之间是联通的时候才执行链加操作（坑死我了）

### Code

[看代码戳这里](https://acfunction.github.io/2019/02/21/BZOJ3091/)



---

## 作者：yzxoi (赞：1)

[$$\large{\texttt{My Blog}}$$](https://yzxoi.top/archives/1470)

(博客食用更佳，~~毕竟洛谷的Latex有点怪~~)
## Description
> [题目链接Luogu](https://www.luogu.com.cn/problem/P4842) [darkbzoj](https://darkbzoj.tk/problem/3091)

给定一个森林，初始形态是一棵以 $1$ 为根的树，要求进行以下操作。

1. 连接 $x,y$
2. 断开 $x,y$
3. $x$ 到 $y$ 的路径上每个点权值加上 $d$
4. 求在 $x$ 到 $y$ 的路径上任选 $2$ 个点之间路径上点的权值和的期望

对于 $100\%$ 的数据，满足 $1<=N<=50,000;1<=M<=50,000;1<=a_i<=10^6;1<=D<=100;1<=U,V<=N$。

## Solution
对于有 $Link$ 与 $Cut$ 的动态树问题，考虑使用 $LCT$。

设这条路径是 $a_1,a_2,a_3,\dots,a_{sz}$，其中 $sz$ 是路径的长度。

对于每个点的期望，我们考虑路径上的每个点会被计算几次。

路径上的第 $i$ 个点权值为 $a_i$，显然当$1\leq l\leq i,i\leq r \leq sz$时会被计算到。（$l,r$表示路径上选择的两个点）

那么这个点会被计算到 $i\times (sz-i+1)$ 次，所以产生的贡献就是 $i\times (sz-i+1)\times a_i$。

故易知期望值就是

$$\frac{\sum\limits_{i=1}^{sz}i\times (sz-i+1)\times a_i}{C_{sz+1}^2}$$

**Q:为什么是 $C_{sz+1}^2$ 而不是 $C_{sz}^2$ 呢？**

**A:因为任选两个点可以是相同。**

然后让我们来考虑维护这个~~又臭又长~~的答案。

首先考虑分母 $C_{sz+1}^2$，这个特别好维护，只需要维护下每个点的 $sz$ 即可，最后 $split$ 下就好了。

然后我们考虑分子如何维护，也就是说如何从左子树与右子树来得到这个答案。

我们设左子树的路径是 $a_1,a_2,\dots,a_{mid-1}$，路径长度是 $mid-1$。

然后，当前点的权值是 $a_{mid}$。

同理，右子树的路径是 $a_{mid+1},a_{mid+2},\dots,a_{sz}$，路径长度是 $sz-mid$

那么，当前点的应得答案就是 $\sum\limits_{i=1}^{sz}i\times(sz-i+1)\times a_i$

左子树的答案就是 $\sum\limits_{i=1}^{mid-1}i\times(mid-i)\times a_i$当前点的贡献是 $a_{mid}\times mid\times (sz-mid+1)$

右子树的答案就是 $\sum\limits_{i=mid+1}^{sz-mid}(i-mid)\times (sz-i+1)\times a_i$

然后你就会发现，如果把当前点应得的答案拆分下：

$$\sum\limits_{i=1}^{mid-1}i\times (sz-i+1)\times a_i + a_{mid}\times mid\times (sz-mid+1) \sum\limits_{i=mid+1}^{sz-mid}i\times (sz-i+1)\times a_i$$

然后将其与左右子树的答案作差可得：

$$\sum\limits_{i=1}^{mid-1}i\times (sz-mid+1)\times a_i + a_{mid}\times mid\times (sz-mid+1)+\sum\limits_{i=mid+1}^{sz-mid} mid\times (sz-i+1)\times a_i$$

此时，为了更佳的观赏效果，我们重新设一下。

设左子树的路径是 $b_1,b_2,\dots,b_{sz_b}$，其中 $sz_b$ 表示左子树的路径长度。

同理，我们设右子树的路径是 $c_1,c_2,\dots,c_{sz_c}$，其中 $sz_c$ 表示右子树的路径长度。

最后，设我们这个点的权值为 $a$。

那么其实差值就是：

$$(sz_c+1)\times \sum\limits_{i=1}^{sz_b}b_i\times i + a\times (sz_b+1)\times (sz_c+1)+ (sz_b+1)\times \sum\limits_{i=1}^{sz_c} (sz_c-i+1)\times c_i$$

所以，我们就可以维护下 $lsum=\sum\limits_{i=1}^{sz}i\times a_i,rsum=\sum\limits_{i=1}^{sz} (sz-i+1)\times a_i$ 以快速 $pushup$ 答案。

那么问题来了，我们如何维护 $lsum$ 与 $rsum$ 呢？

很显然，(其中 $s$ 表示所有 $a_i$ 的和)

$$lsum[x]=lsum[ls]+v[x]\times (sz[ls]+1)+lsum[rs]+s[rc]\times (sz[ls]+1)$$

$$rsum[x]=rsum[rs]+v[x]\times (sz[rs]+1)+rsum[ls]+s[ls]\times (sz[rs]+1)$$

简单的来说，思路就是从左右儿子继承并注意前面的系数即可。

好了，至此，我们已经完成了如何从左右儿子得到自己，现在我们要考虑操作 $3$ 带来的影响。

为了方便阅读，这里再次给出操作 $3$ 的概括：把$x$ 到 $y$ 的路径上每个点权值加上 $d$。

那么其实就是：

- $s+=d\times sz$
- $lsum+=\sum\limits_{i=1}^{sz}i\times d$ 即 $lsum+=\frac{sz\times (sz+1)}{2}\times d$
- $rsum$ 与 $lsum$ 同理，$rsum+=\frac{sz\times(sz+1)}{2}\times d$
- $ans+=\sum\limits_{i=1}^{sz}i\times (sz-i+1)\times d$ 即 $ans+=\frac{sz\times (sz+1)\times (sz+2)}{6}$

然后就完事了

## Code
```cpp
#include<bits/stdc++.h>
#define LL long long 
using namespace std;
inline int read(){int res=0,f=1;char ch=getchar();while(!isdigit(ch)) f=ch=='-'?-1:f,ch=getchar();while(isdigit(ch)) res=(res<<3)+(res<<1)+ch-'0',ch=getchar();return res*f;}
inline void write(LL x){if(x<0) putchar('-'),x=-x;if(x<10) putchar(x+'0');else write(x/10),putchar(x%10+'0');}
struct node{bool tag;LL v,s,ch[2],lsum,rsum,ans,add,sz,fa;}tr[50010];
int n,m,stk[50010],top,op,x,y;
LL a[50010],d,Ans,Div,g;
inline bool isroot(int x){return (!x)||(tr[tr[x].fa].ch[0]!=x&&tr[tr[x].fa].ch[1]!=x);}
inline void flip(int x){swap(tr[x].lsum,tr[x].rsum),swap(tr[x].ch[0],tr[x].ch[1]),tr[x].tag^=1;}
inline void add(int x,int v){
	tr[x].v+=v,tr[x].add+=v,tr[x].s+=tr[x].sz*v;
	tr[x].lsum+=tr[x].sz*(tr[x].sz+1)*v>>1;
	tr[x].rsum+=tr[x].sz*(tr[x].sz+1)*v>>1;
	tr[x].ans+=tr[x].sz*(tr[x].sz+1)*(tr[x].sz+2)/6*v;
}
inline void pushdown(int x){
	if(tr[x].tag){if(tr[x].ch[0]) flip(tr[x].ch[0]);if(tr[x].ch[1]) flip(tr[x].ch[1]);tr[x].tag=0;}
	if(tr[x].add){if(tr[x].ch[0]) add(tr[x].ch[0],tr[x].add);if(tr[x].ch[1]) add(tr[x].ch[1],tr[x].add);tr[x].add=0;}
}
inline void pushup(int x){
	tr[x].s=tr[tr[x].ch[0]].s+tr[tr[x].ch[1]].s+tr[x].v;
	tr[x].sz=tr[tr[x].ch[0]].sz+tr[tr[x].ch[1]].sz+1;
	tr[x].lsum=tr[tr[x].ch[0]].lsum+tr[x].v*(tr[tr[x].ch[0]].sz+1)+tr[tr[x].ch[1]].lsum+tr[tr[x].ch[1]].s*(tr[tr[x].ch[0]].sz+1);
	tr[x].rsum=tr[tr[x].ch[1]].rsum+tr[x].v*(tr[tr[x].ch[1]].sz+1)+tr[tr[x].ch[0]].rsum+tr[tr[x].ch[0]].s*(tr[tr[x].ch[1]].sz+1);
	tr[x].ans=tr[tr[x].ch[0]].ans+tr[tr[x].ch[1]].ans+tr[x].v*(tr[tr[x].ch[0]].sz+1)*(tr[tr[x].ch[1]].sz+1)+tr[tr[x].ch[0]].lsum*(tr[tr[x].ch[1]].sz+1)+tr[tr[x].ch[1]].rsum*(tr[tr[x].ch[0]].sz+1);
}
inline void rotate(int x){
	int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x,v=tr[x].ch[!k];
	if(!isroot(y)) tr[z].ch[tr[z].ch[1]==y]=x;
	tr[x].ch[!k]=y,tr[y].ch[k]=v;
	if(v) tr[v].fa=y;
	tr[y].fa=x,tr[x].fa=z;
	pushup(y),pushup(x);
}
inline void splay(int x){
	int y=x,z=0;top=0;stk[++top]=y;
	while(!isroot(y)) stk[++top]=y=tr[y].fa;
	while(top) pushdown(stk[top--]);
	while(!isroot(x)){
		y=tr[x].fa,z=tr[y].fa;
		if(!isroot(y)) rotate((tr[y].ch[0]==x)^(tr[z].ch[0]==y)?x:y);
		rotate(x);
	}
	pushup(x);
}
inline void access(int x){for(int y=0;x;x=tr[y=x].fa) splay(x),tr[x].ch[1]=y,pushup(x);}
inline void makeroot(int x){access(x),splay(x),flip(x);}
inline int findroot(int x){access(x),splay(x);while(tr[x].ch[0]) x=tr[x].ch[0];return x;}
inline void split(int x,int y){makeroot(x),access(y),splay(x);}
inline void link(int x,int y){makeroot(x);makeroot(y);tr[y].fa=x;}
inline void cut(int x,int y){split(x,y);tr[y].fa=tr[x].ch[1]=0;}
inline LL gcd(LL a,LL b){return !b?a:gcd(b,a%b);}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) tr[i].lsum=tr[i].rsum=tr[i].v=tr[i].s=tr[i].ans=a[i]=read(),tr[i].sz=1;
	for(int x,y,i=1;i<n;i++) x=read(),y=read(),link(x,y);
	for(int i=1;i<=m;i++){
		op=read(),x=read(),y=read();
		if(op==1){if(findroot(x)==findroot(y)) cut(x,y);}
		else if(op==2){if(findroot(x)!=findroot(y)) link(x,y);}
		else if(op==3){d=read();if(findroot(x)==findroot(y)) split(x,y),add(x,d);}
		else if(op==4){if(findroot(x)!=findroot(y)){puts("-1");continue ;}split(x,y),Ans=tr[x].ans,Div=tr[x].sz*(tr[x].sz+1)>>1,g=gcd(Ans,Div),write(Ans/g),putchar('/'),write(Div/g),putchar('\n');} 
	}
}
```

---

## 作者：yangshengyu0719 (赞：0)

显然，此题由 LCT 维护。

## Q1：如何求解 $E(u,v)$
首先我们要先明确期望值 $E(u,v)$ 到底是什么。  
简单来说，$E(u,v)$ 等于 $road(u,v)$ 上所有子段和之和（包括单点的情况）除以所有子段个数。

求所有子段个数很简单。设 $road(u,v)$ 的长度为 $len$，则有 $len+len\times(len-1)/2$ 段。

求所有子段和之和就有点复杂了。我们可以把一棵子树看作一个序列（如图）。那么我们对比左右子树答案之和可以发现：左子树部分增加了 $size_{rs}+1$ 倍的蓝色倒三角部分；右子树部分增加了 $size_{ls}+1$ 倍的黄色正三角部分；中间部分增加了 $(size_{rs}+1)\times(size_{ls}+1)$ 倍的 $val_{rt}$。
![](https://cdn.luogu.com.cn/upload/image_hosting/gv3ywfgz.png)

由此，我们可以维护四个值：子树总和 $sum$，正三角和 $lsum$，倒三角和 $rsum$ 以及子段和之和 $ans$。

$$sum_{rt}=sum_{ls}+sum_{rs}+val_{rt}$$
$$lsum_{rt}=(size_{rs}+1)\times(sum_{ls}+val_{rt})+lsum_{ls}+lsum_{rs}$$
$$rsum_{rt}=(size_{ls}+1)\times(sum_{rs}+val_{rt})+rsum_{ls}+rsum_{rs}$$
$$ans_{rt}=ans_{ls}+ans_{rs}+(size_{ls}+1)\times lsum_{rs}+(size_{rs}+1)\times rsum_{ls}+(size_{rs}+1)\times(size_{ls}+1)\times val_{rt}$$

## Q2：区间增加 $x$ 时，如何更新数据
不难想到，令 $calc(x)=(1+x)\times x\div 2$，则前三个值的更新方式为：
$$sum_{rt}=sum_{rt}+size_{rt}\times x$$
$$lsum_{rt}=lsum_{rt}+calc(size_{rt})\times x$$
$$rsum_{rt}=rsum_{rt}+calc(size_{rt})\times x$$

然而 $ans$ 就比较难求了。我们可以通过找规律发现，每一段长度为 $len$ 序列中，第 $i$ 项会被计算 $i\times (len-i+1)$ 次。因此有：
$$ans_{rt}=ans_{rt}+x\times(1\times size_{rt}+2\times (size_{rt}-1)+...+i\times(size_{rt}-i+1)+...+(size_{rt}-1)\times 2+size_{rt}\times 1)$$
经化简（运用到小学奥数以及平方和公式等，化简过程其他题解的 dalao 解释的应该挺清楚了，本蒟蒻就不献丑了）得：
$$
ans_{rt}=ans_{rt}+x\times size_{rt}\times(size_{rt}+1)\times(size_{rt}+2)\div 6
$$

温馨提醒：每次区间翻转时记得 $swap(lsum,rsum)$。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define ls(k) T[k].son[0]
#define rs(k) T[k].son[1]
#define fa(k) T[k].fa
using namespace std;
const int N=5e4+5;
int n,m;
struct node{int val,sz,fa,son[2],rev,tag,lsum,rsum,sum,ans;}T[N];

bool get(int x){return x==rs(fa(x));}
bool IsRoot(int x){return x!=ls(fa(x))&&x!=rs(fa(x));}
int calc(int x){return (1+x)*x/2;}
void add(int k,int x){
	T[k].tag+=x,T[k].val+=x;
	T[k].sum+=x*T[k].sz,T[k].lsum+=calc(T[k].sz)*x,T[k].rsum+=calc(T[k].sz)*x;
	T[k].ans+=(T[k].sz*(T[k].sz+1)*(T[k].sz+2))/6*x;
}
void pushdown(int k){
	if(!k) return;
	if(T[k].rev){
		if(ls(k)) T[ls(k)].rev^=1,swap(T[ls(k)].lsum,T[ls(k)].rsum);
		if(rs(k)) T[rs(k)].rev^=1,swap(T[rs(k)].lsum,T[rs(k)].rsum);
		swap(ls(k),rs(k));
		T[k].rev=0;
	}if(T[k].tag){
		int x=T[k].tag;
		if(ls(k)) add(ls(k),x);
		if(rs(k)) add(rs(k),x);
		T[k].tag=0;
	}
}
void update(int k){
	int ls=ls(k),rs=rs(k);
	T[k].sz=T[ls].sz+T[rs].sz+1;
	T[k].sum=T[ls].sum+T[rs].sum+T[k].val;
	int lsz=T[ls].sz+1,rsz=T[rs].sz+1;
	T[k].lsum=rsz*(T[ls].sum+T[k].val)+T[ls].lsum+T[rs].lsum;
	T[k].rsum=lsz*(T[rs].sum+T[k].val)+T[ls].rsum+T[rs].rsum;
	T[k].ans=T[ls].ans+T[rs].ans+lsz*T[rs].lsum+rsz*T[ls].rsum+lsz*rsz*T[k].val;
}

void rotate(int x){
	int y=fa(x),z=fa(y),d=get(x);
	if(!IsRoot(y)) T[z].son[get(y)]=x;
	T[y].son[d]=T[x].son[d^1],fa(T[x].son[d^1])=y;
	T[x].son[d^1]=y,fa(y)=x,fa(x)=z;
	update(y),update(x);
}
void Clear_tag(int x){if(!IsRoot(x))Clear_tag(fa(x));pushdown(x);}
void Splay(int x){
	Clear_tag(x);
	while(!IsRoot(x)){
		int y=fa(x);
		if(!IsRoot(y)) rotate(get(x)^get(y)?x:y);
		rotate(x);
	}
}
void Access(int x){int y=0;while(x)Splay(x),rs(x)=y,update(x),y=x,x=fa(x);}
void BeRoot(int x){Access(x);Splay(x);T[x].rev^=1,swap(T[x].lsum,T[x].rsum);}
int find(int x){
	Access(x),Splay(x);
	while(ls(x)) x=ls(x);
	Splay(x);return x;
}
void Link(int x,int y){
	if(find(x)==find(y)) return;
	BeRoot(x),fa(x)=y;
}
void Cut(int x,int y){
	BeRoot(x),Access(y),Splay(y);
	if(x!=ls(y)||rs(x)) return;
	ls(y)=fa(x)=0;
}
void modify(int x,int y,int d){
	if(find(x)!=find(y)) return;
	BeRoot(x),Access(y),Splay(y);
	add(y,d);
}
void E(int x,int y){
	if(find(x)!=find(y)){cout<<"-1\n";return;}
	BeRoot(x),Access(y),Splay(y);
	int p=T[y].ans,q=T[y].sz+T[y].sz*(T[y].sz-1)/2;
	int k=__gcd(p,q);
	cout<<p/k<<'/'<<q/k<<'\n';
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>T[i].val,T[i].lsum=T[i].rsum=T[i].sum=T[i].ans=T[i].val;
	int op,u,v,d;
	for(int i=1;i<n;i++) cin>>u>>v,BeRoot(u),fa(u)=v;
	while(m--){
		cin>>op>>u>>v;
		if(op==1) Cut(u,v);
		if(op==2) Link(u,v);
		if(op==3) cin>>d,modify(u,v,d);
		if(op==4) E(u,v);
	}
	return 0;
}
/*
6 9
1 1 4 5 1 4
1 3
2 4
3 5
1 2
2 6
4 3 2
1 1 2
4 4 6
2 4 5
4 1 2
1 3 5
2 1 2
3 3 4 5
4 3 6

19/6
31/6
91/15
62/5
*/
```

---


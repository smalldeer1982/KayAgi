# 已经没有什么好害怕的了

## 题目描述

已经使 Madoka 有签订契约，和自己一起战斗的想法后，Mami 忽然感到自己不再是孤单一人了呢。

于是，之前的谨慎的战斗作风也消失了，在对 Charlotte 的傀儡使用终曲——Tiro Finale 后，Mami 面临着即将被 Charlotte 的本体吃掉的局面。

这时，已经多次面对过 Charlotte 的 Homura 告诉了学 OI 的你这样一个性质：Charlotte 的结界中有两种具有能量的元素，一种是“糖果”，另一种是“药片”，各有 $n$ 个。在 Charlotte 发动进攻前，“糖果”和“药片”会两两配对，若恰好糖果比药片能量大的组数比“药片”比“糖果”能量大的组数多 $k$ 组，则在这种局面下，Charlotte 的攻击会丟失，从而 Mami 仍有消灭 Charlotte 的可能。

你必须根据 Homura 告诉你的“糖果”和“药片”的能量的信息迅速告诉 Homura 这种情况的个数.

## 说明/提示

【样例解释】

正确的组合为：

(5-40,35-20,15-10,45-30)，    
(5-40,45-20,15-10,35-30)，   
(45-40,5-20,15-10,35-30)，   
(45-40,35-20,15-10,5-30).   

【数据范围】
对于 $100\%$ 的数据，$1 \le n \le 2000$，$0 \le k \le n$。

## 样例 #1

### 输入

```
4 2
5 35 15 45
40 20 10 30
```

### 输出

```
4```

# 题解

## 作者：p_b_p_b (赞：48)

[$$\large \color{purple} My\; Blog$$](https://www.cnblogs.com/p-b-p-b/p/10354502.html)

-------



## 思路

大佬都说这是套路题……嘤嘤嘤我又被吊打了$Q\omega Q$

显然，这题是要$DP$的。

首先思考一下性质：

为了方便，下面令$k=\frac{n+k}{2}$，即有恰好$k$组糖果比药片大。

显然，$a,b$数组都要先从小到大排序。（$a$是糖果，$b$是药片）

考虑$a_i$造成的影响：

1、若它匹配了一个比它小的$b$，则对于$a_j,j>i$，它匹配比它小的$b$的方案数少了$1$。

2、若它匹配了一个比它大的$b$……似乎又要分类讨论，状态很难记录。

所以，我们$DP$时先考虑第一种的$a_i$，第二种的最后统一分配。

设$dp_{i,j}$表示前$i$个$a$，有$j$个第一种，方案数。

容易得到

$$dp_{i,j}=dp_{i-1,j}+(r_i-(j-1))dp_{i-1,j-1}$$

其中$r_i$表示$b$中比$a_i$小的个数。

接下来，记$f_i=(n-i)!dp_{n,i}$，也就是把$n-i$个没有匹配的任意分配，得到至少$i$个的答案$f_i$。

那么恰好$i$个的答案呢？

从大往小递推，有

$$ans_i=f_i-\sum_{j=i+1}^n {j \choose i} ans_j$$

或者用另一种容斥，有

$$ans=\sum_{i=k}^n (-1)^{i-k}{i \choose k} f_i$$

复杂度$O(n^2)$。

--------

## 代码

```cpp
#include<bits/stdc++.h>
namespace my_std{
	using namespace std;
	#define pii pair<int,int>
	#define fir first
	#define sec second
	#define MP make_pair
	#define rep(i,x,y) for (int i=(x);i<=(y);i++)
	#define drep(i,x,y) for (int i=(x);i>=(y);i--)
	#define go(x) for (int i=head[x];i;i=edge[i].nxt)
	#define sz 2020
	typedef long long ll;
	const ll mod=1e9+9;
	template<typename T>
	inline void read(T& t)
	{
		t=0;char f=0,ch=getchar();
		double d=0.1;
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
		if(ch=='.')
		{
			ch=getchar();
			while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();
		}
		t=(f?-t:t);
	}
	template<typename T,typename... Args>
	inline void read(T& t,Args&... args){read(t); read(args...);}
	void file()
	{
		#ifndef ONLINE_JUDGE
		freopen("a.txt","r",stdin);
		#endif
	}
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

ll ksm(ll x,int y)
{
	ll ret=1;
	for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;
	return ret;
}
ll inv(ll x){return ksm(x,mod-2);}

ll fac[sz],_fac[sz];
void init(){fac[0]=_fac[0]=1;rep(i,1,sz-1) _fac[i]=inv(fac[i]=fac[i-1]*i%mod);}
ll C(int n,int m){return n>=m&&m>=0?fac[n]*_fac[m]%mod*_fac[n-m]%mod:0;}

int n,K;
int a[sz],b[sz],r[sz];
ll dp[sz][sz],f[sz];
ll ans[sz];

int main()
{
	file();
	init();
	read(n,K);
	if ((n+K)&1) return puts("0"),0;
	K=(n+K)>>1;
	rep(i,1,n) read(a[i]);
	rep(i,1,n) read(b[i]);
	sort(a+1,a+n+1);sort(b+1,b+n+1);
	int c=0;
	rep(i,1,n)
	{
		while (c<n&&b[c+1]<a[i]) ++c;
		r[i]=c;
	}
	dp[0][0]=1;
	rep(i,1,n)
		rep(j,0,i)
			dp[i][j]=(dp[i-1][j]+(j?1ll*(r[i]-j+1)*dp[i-1][j-1]%mod:0ll))%mod;
	rep(i,0,n) f[i]=dp[n][i]*fac[n-i]%mod;
	drep(i,n,K)
	{
		ans[i]=f[i];
		rep(j,i+1,n) ans[i]=(ans[i]-ans[j]*C(j,i)%mod+mod)%mod;
	}
	cout<<ans[K];
	return 0;
}
```





---

## 作者：NaVi_Awson (赞：36)

[博客也有详解，欢迎来踩](https://www.cnblogs.com/NaVi-Awson/p/9245071.html)

## Description

[题库链接](https://www.lydsy.com/JudgeOnline/problem.php?id=3622)

给出 $n$ 个数 $a_i$ ，以及 $n$ 个数 $b_i$ ，要求两两配对使得 $a>b$ 的对数减去 $a<b$ 的对数等于 $k$ 。

$0\leq k\leq n\leq 2000$ ，保证 $a,b$ 无相同元素。

## Solution

我们假设 $a>b$ 对数为 $x$ ，可以求得 $x=\frac{n+k}{2}$ 。

我们令 $f_{i,j}$ 表示前 $i$ 个 $a$ 中，选了 $j$ 组满足 $a>b$ 的方案数。

容易得到 $\text{dp}$ 方程

$$f_{i,j}=f_{i-1,j}+(l_i-j+1)\times f_{i-1,j-1}$$

其中 $l_i$ 表示从小到大排序后 $b$ 中 $<a_i$ 的最靠后一个数。

我们记 $g_i=f_{n,i}\times (n-i)!$ 即满足 $a>b$ 的组数 $\geq i$ 的方案数，再令 $f_i$ 表示恰好满足 $a>b$ 的组数 $= i$ 的方案数。

容易发现对于 $i>j$ $f_i$ 恰好在 $g_j$ 中算了 ${i\choose j}$ 次。

那么存在

$$g(k)=\sum_{i=k}^n{i\choose k}f(i)$$

由二项式反演得

$$f(k)=\sum_{i=k}^n(-1)^{i-k}{i\choose k}g(i)$$

直接求解即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2000+5, yzh = 1e9+9;

int n, k, a[N], b[N], l[N], f[N][N], fac[N], ifac[N], g[N];

int C(int n, int m) {return 1ll*fac[n]*ifac[m]%yzh*ifac[n-m]%yzh; }
void work() {
	scanf("%d%d", &n, &k);
	if ((n+k)&1) {puts("0"); return; } k = (n+k)/2;
	ifac[0] = ifac[1] = fac[0] = fac[1] = 1;
	for (int i = 2; i < N; i++) ifac[i] = -1ll*yzh/i*ifac[yzh%i]%yzh;
	for (int i = 2; i < N; i++)
		fac[i] = 1ll*fac[i-1]*i%yzh, ifac[i] = 1ll*ifac[i-1]*ifac[i]%yzh;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
	sort(a+1, a+n+1); sort(b+1, b+n+1);
	int loc = 0;
	for (int i = 1; i <= n; i++) {
		while (loc < n && b[loc+1] < a[i]) ++loc;
		l[i] = loc;
	}
	f[0][0] = 1;
	for (int i = 1; i <= n; i++) {
		f[i][0] = f[i-1][0];
		for (int j = 1; j <= i; j++)
			f[i][j] = (1ll*f[i-1][j]+1ll*f[i-1][j-1]*max(0, l[i]-j+1)%yzh)%yzh;
	}
	for (int i = 0; i <= n; i++) g[i] = 1ll*f[n][i]*fac[n-i]%yzh;
	int ans = 0;
	for (int i = k; i <= n; i++)
		if ((i-k)&1) (ans -= 1ll*C(i, k)*g[i]%yzh) %= yzh;
		else (ans += 1ll*C(i, k)*g[i]%yzh) %= yzh;
	printf("%d\n", (ans+yzh)%yzh);
}
int main() {work(); return 0; }
```

---

## 作者：George1123 (赞：19)

**来博客看 $\rightarrow$ [$\tt George1123$](https://www.cnblogs.com/Wendigo/p/13265708.html)**

---
> [洛谷P4859 已经没有什么好害怕的了](https://www.luogu.com.cn/problem/P4859)

> 给定 $n$ 和 $k$，$n$ 个糖果能量 $a_i$ 和 $n$ 个药片能量 $b_i$，每个 $a_i$ 和 $b_i$ 互不相等。将糖果和药片一一对应，求 糖果能量大于药片 比 药片能量大于糖果 多 $k$ 组的方案数。

> 数据范围：$1\le n\le 2000$，$0\le k\le n$。

---
萌新初学二项式反演，这是第一道完全自己做出来的题，所以写篇题解庆祝并提升理解。

---
有 $\frac{n+k}{2}$ 组**糖果能量大于药片**，$\frac{n-k}{2}$ 组**药片能量大于糖果**。

如果 $n+k$ 是奇数，直接答案为 $0$ 特判掉。

$f(i)$ 表示 $i$ 组**糖果能量大于药片**，$n-i$ 组**药片能量大于糖果**的方案数。

$g(i)$ 表示 $i$ 组**糖果能量大于药片**，$n-i$ 组随意的方案数。

> 二项式反演必然有 $f(i)$ 和 $g(i)$，往往前者表示 $i$ 个符合条件 $a$ 剩下符合另条件 $b$，后者表示 $i$ 个符合条件 $a$ 剩下随意。

---
先考虑 $g(i)$ 怎么独立地求，蒟蒻想到了 $\tt dp$。

将 $a_i$ 和 $b_i$ 排序，现在 $a_i<a_{i+1}$，$b_i<b_{i+1}$。

比如 $b_i<a_1<b_{i+1}$，$b_j<a_2<b_{j+1}(i<j)$。

所以 $a_1$ 可以对应 $b_1\sim b_i$，$a_2$ 可以对应 $b_1\sim b_j$。

因为 $a_1$ 对于的 $b_x$ 满足 $x<i<j$，所以必然占了一个 $a_2$ 可以对应的位。

**所以有 $i(j-1)$ 种对应法。**

**设 $F_{i,j}$ 表示看了 $a_1\sim a_i$，对应了 $j$ 组的方案数。**

令 $p(i)$ 表示 $b_{p(i)}<a_i<b_{p(i)+1}$。

同理，所以 $F(0,0)=1$。

$$F(i,j)=F(i-1,j)+F(i-1,j-1)\cdot (p(i)-(j-1))$$

$$g(i)=F(n,i)\cdot(n-i)!$$

---
**二项式反演**来了：

$$g(i)=\sum_{x=i}^n{x\choose i}f(x) \Longleftrightarrow f(i)=\sum_{x=i}^n(-1)^{x-i}{x\choose i}g(x)$$

**答案是 $f(\frac{n+k}{2})$**，带进去算就好了。

---
**时间复杂度 $\Theta(n^2)$，空间复杂度 $\Theta(n^2)$。**

---
- **代码**

下标从 $0$ 开始的...巨佬们琢磨琢磨吧。$\tt /kel$。

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define be(a) a.begin()
#define en(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int mod=1e9+9;

//Main
int main(){
	cin.tie(0);
	int n,k; cin>>n>>k;
	vector<int> a(n),b(n);
	for(int&ai:a) cin>>ai;
	for(int&bi:b) cin>>bi;
	if((n-k)&1) return cout<<0<<'\n',0;
	sort(be(a),en(a));
	sort(be(b),en(b));
	vector<vector<int>> f(n+1,vector<int>(n+1,0));
	f[0][0]=1;
	for(int i=0,p=-1;i<n;i++){
		while(p+1<n&&b[p+1]<a[i]) p++;
		for(int j=0;j<n+1;j++) f[i+1][j]=f[i][j];
		for(int j=0;j<n;j++) (f[i+1][j+1]+=(ll)f[i][j]*(p-j+1)%mod)%=mod;
	}
	for(int j=n,s=1;j>=0;j--) f[n][j]=(ll)f[n][j]*s%mod,s=(ll)s*(n-j+1)%mod;
	vector<vector<int>> c(n+1,vector<int>(n+1,0));
	for(int i=0;i<n+1;i++){
		c[i][0]=c[i][i]=1;
		for(int j=1;j<i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}
	int ans=0,t=(n+k)>>1;
	for(int i=t;i<n+1;i++){
		int sum=(ll)f[n][i]*c[i][t]%mod;
		if((i-t)&1) (ans+=-sum+mod)%=mod;
		else (ans+=sum)%=mod;
	}
	cout<<ans<<'\n';
	return 0;
}
```
---
**祝大家学习愉快！**

---

## 作者：TheLostWeak (赞：15)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ3622.html)

**大致题意：** 有$n$个糖果和$n$个药片，各有自己的能量。将其两两配对，求糖果比药片能量大的组数恰好比药片比糖果能量大的组数多$k$组的方案数。

### 什么是广义容斥

我们首先来介绍一下什么是广义容斥。

我们要证明下面这样一个式子：

$$f_n=\sum_{i=0}^nC_n^ig_i⇔g_n=\sum_{i=0}^n(-1)^{n-i}C_{n}^if_i$$

观察右边这个式子，我们将$f_n=\sum_{i=0}^nC_n^ig_i$代入就可以得到：

$$g_n=\sum_{i=0}^n(-1)^{n-i}C_n^i\sum_{j=0}^i(-1)^jC_i^jg_j$$

把$C_n^i$移入，可以得到：

$$g_n=\sum_{i=0}^n(-1)^{n-i}\sum_{j=0}^i(-1)^jC_n^iC_i^jg_j$$

通过暴力展开我们可以证明$C_n^iC_i^j=C_n^jC_{n-j}^{i-j}$，代入得：

$$g_n=\sum_{i=0}^n(-1)^{n-i}\sum_{j=0}^i(-1)^jC_n^jC_{n-j}^{i-j}g_j$$

然后我们调换$i$和$j$的枚举顺序，并让$i$变为原先的$n-i-j$可得：

$$g_n=\sum_{j=0}^n(-1)^jC_n^jg_j\sum_{i=0}^{n-j}C_{n-j}^i(-1)^{i+j}$$

然后代入二项式定理（因此这又称为**二项式反演**）$(x+y)^n=\sum_{i=0}^nC_n^ix^iy^{n-i}$得：

$$g_n=\sum_{j=0}^n(-1)^{2j}C_n^jg_j(\sum_{i=0}^{n-j}C_{n-j}^i(-1)^i\cdot1^{n-j-i})=\sum_{j=0}^n(-1)^{2j}C_n^jg_j\cdot0^{n-j}$$

由于式子中出现了一个$0^{n-j}$，因此只有当$n-j=0$，即$n=j$时，该式才有值，代入得：

$$g_n=(-1)^{2n}C_n^ng_n\cdot1=1\cdot1\cdot g_n\cdot1=g_n$$

因此原式恒成立，得证。

### 简单转化

恰好多$k$组这个条件不是很好求，所以我们可以将其转化一下。

由于总数$n$是固定的，所以我们容易求出糖果比药片能量大的组数应为$\frac{n+k}2$。

### 动态规划

接下来，我们就要使用$DP$了。

首先，我们把糖果和药片分别按能量排一边序。

则这样可以保证后枚举到的的糖果所能胜过的药片的区间一定能覆盖先枚举到的糖果的区间。

然后，设$f_{i,j}$表示**糖果匹配到第$i$个，且已经与$j$个药片匹配的方案数**，并设$g_i$表示**能与第$i$个糖果匹配的药片数**，则我们可以推出转移方程为：

$$f_{i,j}=f_{i-1,j}+(g_i-j+1)f_{i-1,j-1}$$

### 广义容斥

从前面$DP$得到的$f_{n,i}$，我们可以轻松推得**糖果大于药片的对数大于等于$i$的方案数**。

由于我们已经确定了$i$对，而剩下的$(n-i)$对实际上可以随意匹配，因此便是一个全排列。即：

$$f_{n,i}(n-i)!$$

我们可以设$F_i$表示**糖果大于药片的对数恰好等于$i$的方案数**，则可得：

$$f_{n,i}(n-i)!=\sum_{k=i}^nC_k^iF_k$$

然后用先前提到的**广义容斥**，就可以得到：

$$F_k=\sum_{i=k}^n(-1)^{i-k}C_i^kf_{n,i}(n-i)!$$

已知糖果比药片能量大的组数应为$\frac{n+k}2$，则$F_{\frac{n+k}2}$即为答案。

而这可以直接求。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 2000
#define X 1000000009
#define Qinv(x) Qpow(x,X-2)
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define C(x,y) (1LL*Fac[x]*Inv[y]%X*Inv[(x)-(y)]%X)
using namespace std;
int n,k,a[N+5],b[N+5],g[N+5],Fac[N+5],Inv[N+5],f[N+5][N+5];
I int Qpow(RI x,RI y) {RI res=1;W(y) y&1&&(res=1LL*res*x%X),x=1LL*x*x%X,y>>=1;return res;}//快速幂
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
int main()
{
    RI i,j,t,ans=0;for(F.read(n,k),i=1;i<=n;++i) F.read(a[i]);for(i=1;i<=n;++i) F.read(b[i]);//读入数据
    for(sort(a+1,a+n+1),sort(b+1,b+n+1),i=1;i<=n;++i) {g[i]=g[i-1];W(g[i]^n&&a[i]>b[g[i]+1]) ++g[i];}//排序，然后求出g[i]
    for(f[0][0]=i=1;i<=n;++i) for(j=0;j<=i;++j) f[i][j]=f[i-1][j],j&&Inc(f[i][j],1LL*f[i-1][j-1]*(g[i]-j+1)%X);//DP转移
    for(Fac[0]=i=1;i<=n;++i) Fac[i]=1LL*Fac[i-1]*i%X;for(Inv[n]=Qinv(Fac[n]),i=n-1;~i;--i) Inv[i]=1LL*Inv[i+1]*(i+1)%X;//初始化阶乘及阶乘逆元
    for(i=t=n+k>>1;i<=n;++i) Inc(ans,1LL*((i^t)&1?X-1:1)*C(i,t)%X*f[n][i]%X*Fac[n-i]%X);//求出最终答案
    return F.write(ans),F.clear(),0;//输出答案
}
```

---

## 作者：AzusaCat (赞：6)

首先，将糖果和药片分别按能量从小到大排序，这样的话如果我们匹配某一个糖果时，之前匹配过的药片一定是这个糖果可以匹配的。

设 $g[i][j]$ 为前 $i$ 个糖果中钦定了 $j$ 对满足题意的匹配，且剩下的不匹配的方案数。$c[i]$ 为能量小于第 $i$ 个糖果的药片的数量。
那么有转移方程
$$
g[i][j]=g[i-1][j]+(c[i]-j+1)g[i-1][j-1]
$$
$g[i-1][j]$ 就是不匹配这个糖果的方案数， $(c[i]-j+1)g[i-1][j-1]$ 为匹配这个糖果的方案数（因为之前匹配了 $j-1$ 组，而由于排序，被匹配的药片的能量一定小于当前糖果的能量，所以还有 $c[i]-j+1$ 个未匹配的药片）

则所有糖果钦定了 $k$ 对匹配，剩下随便匹配的方案数为 $g[n][k](n-k)!$  ，即 $g(k)$ 。

同时考虑 $g(k)$ 如何用 $f$ 来表示，先给出式子
$$
g(k)=\sum\limits_{i=k}^n\binom{i}{k}f(i)
$$

这个式子可以理解为对任何一种已经全部匹配完的方案，可以选择 $k$ 个作为钦定选的，一共有 $\dbinom{i}{k}$ 种方案。 

那么由二项式反演，我们可以得到
$$
f(k)=\sum\limits_{i=k}^{n}(-1)^{i-k}\binom{i}{k}g(i)
$$
然后就可以 $O(n^2)$ 直接算了。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int const p=1e9+9;
int a[2005],b[2005],g[2005][2005],c[2005],fac[2005],inv[2005];
int pw(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1)res=1ll*res*x%p;
		x=1ll*x*x%p;
		y>>=1;
	}
	return res;
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	if((n+k)&1)
	{
		puts("0");
		return 0;
	}
	k=(n+k)/2;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);
	fac[0]=inv[0]=1;
	for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%p,inv[i]=pw(fac[i],p-2);
	sort(a+1,a+n+1),sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)c[i]=lower_bound(b+1,b+n+1,a[i])-b-1;
	g[0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=c[i];j++)
			g[i][j]=(g[i-1][j]+1ll*(c[i]-j+1)*g[i-1][j-1])%p;
	int ans=0;
	for(int i=k;i<=n;i++)
		ans+=1ll*pw(p-1,i-k)*fac[i]%p*inv[k]%p*inv[i-k]%p*fac[n-i]%p*g[n][i]%p,ans%=p;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：RyexAwl (赞：5)

根据题意，设$a$为糖果能量比药片能量多的组数，$b$为药片能量比糖果能量多的组数有
$$
\begin{aligned}
a+b = n \\
a-b=k
\end{aligned}
$$
解得$a=\frac{n+k}{2}$ ，而显然当$2\not|\ \frac{n+k}{2}$时，无解。

设$A[]$为糖果的能量，$B[]$为药片的能量。

将$A[],B[]$排序。

令$cnt(i)$等于比$A[i]$能量小的药片数量。

与[这道题](https://www.luogu.com.cn/blog/maxsama/solution-uva1485)的做法类似。

令$f(i,j)$为在前$i$个按能量排好序的糖果中，钦定$j$个糖果比药片能量多的钦定方案。

以是否钦定第$i$个糖果为划分依据：

$1.$不钦定：$f(i-1,j)$

$2.$钦定：我们可以确定第$j$个钦定的一定是$i$，不包括$i$的前$j-1$个的钦定方案即$f(i-1,j-1)$，而对于每种方案，$i$都可以和$[cnt(i)-(j-1)]$的任意一个药片匹配，因此方案数即$f(i-1,j-1)\times(cnt(i)-j+1)$

那么有转移方程：
$$
f(i,j)=f(i-1,j)+f(i-1,j-1)\times(cnt(i)-j+1)
$$

而对于其余的$i-j$个糖果的匹配方案则随意，可以看作$(i-j)$个药片的全排列。
令
$$
t(i,j)=f(i,j)\times(i-j)!
$$
$g(i,j)$为前$i$个糖果中恰好$j$个糖果比药片能量多的钦定方案。
反演得
$$
ans=g(n,\frac{n+k}{2})=\sum_{i=\frac{n+k}{2}}^{n}\binom{i}{n}(-1)^{i-\frac{n+k}{2}}t(n,i)
$$
时间复杂度：$O(n^2)$
代码：
```cpp
#include <iostream>
#include <algorithm>

namespace wxy{
    const int N = 2e3 + 10,mod = 1e9 + 9;
    unsigned long long f[N][N],dis[N][N],fac[N],invfac[N],a[N],b[N];
    int p[N];
    inline int C(int n,int m){return n<m?0:(long long)fac[n]*invfac[m]%mod*invfac[n-m]%mod;}
    inline void init(){
        fac[0]=invfac[0]=invfac[1]=1;
        for(int i=1;i<=2000;i++)fac[i]=(long long)fac[i-1]*i%mod;
        for(int i=2;i<=2000;i++)invfac[i]=(long long)(mod-mod/i)*invfac[mod%i]%mod;
        for(int i=2;i<=2000;i++)invfac[i]=(long long)invfac[i-1]*invfac[i]%mod;
    }
    void main(){
        init();
        int n,k;
        std::cin >> n >> k;
        for (int i = 0; i < n; i++) std::cin >> a[i];
        for (int i = 0; i < n; i++) std::cin >> b[i];
        if ((n - k) % 2 != 0){
            std::cout << 0;
            return;
        }
        std::sort(a ,a + n);
        std::sort(b,b + n);
        for (int i = 0; i < n; i++){
            int k = 0;
            while (b[k] < a[i] && k < n) k++;
            p[i] = k;
        }
        for (int i = 0; i <= n; i++){
            f[i][0] = 1;
            for (int j = 1; j <= i; j++) f[i][j] = (f[i - 1][j] + (f[i - 1][j - 1] * (p[i - 1] - j + 1))) % mod;
        }
        unsigned long long ans = 0;
        int w = (n + k) / 2;
        for (int i = w; i <= n; i++){
            if ((i - w) % 2 == 0) ans = (ans + ((((C(i,w) * f[n][i]) % mod) * fac[n - i]) % mod)) % mod;
            else ans = (ans - ((((C(i,w) * f[n][i]) % mod) * fac[n - i]) % mod) + mod) % mod;
        }
        std::cout << ans;
    }
}signed main(){wxy::main();return 0;}
```


---

## 作者：关怀他人 (赞：5)

##  二项式反演

   ### Solution
	
   先安利下[我的博客](https://www.luogu.org/blog/LCA/)
    
   我们假设 $a>b$对数为 $x$，可以求得 $x=\frac{n+k}{2}$ 。

   我们令$ f_{i,j}$表示$a$数组中前 $i$个数中，选了$j$组数满足 $a>b$ 的方案数。

   容易得到 $\text{dp}$ 方程
   
   
   $$
   f_{i,j}=f_{i-1,j}+(last_i-j+1)\times f_{i-1,j-1}
   $$
   
   
   其中 $last_i$表示从小到大排序后 $b$数组中 $<a_i$ 的最大的数。

   我们记 $g_i=f_{n,i}\times (n-i)!$ 即满足 $a>b$的组数 $\geq i$ 的方案数，再令$ f_i$表示恰好满足 $a>b$ 的组数 $= i$的方案数。

   容易发现对于$ i>j$恰好在 $g_j$中算了$ {i\choose j} = C^j_i$次。

   那么存在
   
   $$
   g(k)=\sum_{i=k}^n{i\choose k}f(i)
   $$
   
   下面就要用到二项式反演了，补充一下：
   ## 二项式反演:
![](https://cdn.luogu.com.cn/upload/pic/60028.png)
## 证明:
![](https://cdn.luogu.com.cn/upload/pic/60027.png)
   
   由二项式反演得
   
   $$
   f(k)=\sum_{i=k}^n(-1)^{i-k}{i\choose k}g(i)
   $$
   
   直接求解即可。
  
## 下面上代码
```cpp
/*
Problem : luogu P4859
Algorithm : 二项式反演
Status : AC
*/
#include <bits/stdc++.h>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long ll;

const int INF = 0x3f3f3f3f;
const int MAXN = 2005;
const int MOD = 1e9 + 9;

int n,m;
ll ans;
ll fac[MAXN],inv[MAXN],f[MAXN][MAXN],g[MAXN];
int a[MAXN],b[MAXN],last[MAXN];

ll power(ll x,ll y){ //快速幂，求逆元用的
	ll res = 1;
	while(y){
		if(y & 1)
		    res = res * x % MOD;
		x = x * x % MOD;
		y >>= 1;
	}
	return res;
}

ll C(int i,int j){ //求组合数
	return fac[i] * inv[j] % MOD * inv[i - j] % MOD;
}

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	if((n + m) % 2 != 0){ //不能两两配对，直接输出0
		puts("0");
		return 0;
	}
	int k = (n + m) / 2;
	fac[0] = 1ll;
	for(int i = 1;i <= n;i++)
	    fac[i] = fac[i - 1] * i % MOD; //预处理阶乘
	inv[n] = power(fac[n],MOD - 2);
	for(int i = n;i >= 1;i--)
	    inv[i - 1] = inv[i] * i % MOD; //预处理逆元
	for(int i = 1;i <= n;i++)
	    scanf("%d",&a[i]);
	for(int i = 1;i <= n;i++)
	    scanf("%d",&b[i]);
	sort(a + 1,a + 1 + n);
	sort(b + 1,b + 1 + n);
	for(int i = 1,loc = 0;i <= n;i++){ //预处理last数组
		while(loc < n && b[loc + 1] < a[i])
		    loc++;
		last[i] = loc;
	}
	f[0][0] = 1ll;
	for(int i = 1;i <= n;i++){
		f[i][0] = f[i - 1][0];
		for(int j = 1;j <= i;j++)
		    f[i][j] = (f[i - 1][j] + f[i - 1][j - 1] * max(0,last[i] - j + 1) % MOD) % MOD; //dp转移
	}
	for(int i = 0;i <= n;i++)
	    g[i] = f[n][i] * fac[n - i] % MOD; //处理g数组
	for(int i = k;i <= n;i++){ //按照公式直接求解
		if((i - k) % 2 != 0)
		    ans = (ans + MOD - C(i,k) * g[i] % MOD) % MOD;
		else
		    ans = (ans + C(i,k) * g[i] % MOD) % MOD;
	}
	printf("%lld\n",ans);
	return 0;
}

```



---

## 作者：luyan (赞：3)


# 题目

[题目链接](https://www.luogu.com.cn/problem/P4859)

题目大意：有两组长度为n的数ab，组间数字互不相同。两组数字之间两两配对，不重不漏，给定一个数字k，求满足a中数字>b 比 b中数字>a 的组数多k的分组方案数

# 题目分析

## 1.问题转化

因为组间数字两两不同，所以其实就是告诉你了有多少组a比b大。

令新k=$\frac{n+k}{2}$，那么如果n+k是一个奇数答案为0.

现在就变成了询问$a>b$的数目为k的方案数

## 2.动态规划

首先对ab数组排序

直接求正好为k的不太好求，因为我们考虑从前往后给a配对。

1.如果当前数字匹配了一个比它小的，那很好办。

2.如果比他大，还要考虑被选的这个b组数对后面的影响。

第一种情况很好算，令$dp_{i,j}$表示前i个数字选了j个数字是比b组数字大的

那么转移方程：$dp_{i,j}=dp_{i-1,j}+(last_{i}-(j-1))*dp_{i-1,j-1}$

其中$last_{i}$表示b数组里面有这么多个数字比$a_i$小

因为我们不考虑第二种，也就是说除去前面那$j-1$组a>b的b被匹配了，其余的$last_{i}-(j-1)$组b>a的我们没有考虑，默认是都可以选。

## 3.二项式反演

那么我们在n组数字里面确定了j个是a>b，剩下的就随便排列，所以是$dp_{n,i}*(n-i)!$

这个代表a>b的组数至少是i个的情况。

我们令g(i)表示恰好有i组数字是a>b

$g(k)=dp_{n,k}*(n-k)!$

那么$f(i)=\sum_{k=i}^{n}C_{k}^{i}g(k)$

根据二项式反演：$g(i)=\sum_{k=i}^{n}{(-1)^{k-i}C_{k}^{i}f(k)}$

二项式反演的基本介绍和证明见：[二项式反演](https://blog.csdn.net/luyan0408/article/details/106440249)

因此我们要求的就是g(k)
### 更新：

更新前没讲明白这个f的表达式怎么来的，很多博文也没说清楚，非常抱歉

反演之前：$f(i)=\sum_{k=i}^{n}C_{k}^{i}g(k)$

这个组合数很多人可能不理解。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531200656468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1eWFuMDQwOA==,size_16,color_FFFFFF,t_70)

画个图辅助理解：我们看蓝色点，表示恰好3个。那么绿、黄、红都代表至少两个。

那么在f函数里面，恰好3个的一种方案：蓝色点，在至少两个里面出现了三次。

因为我们回到“至少”函数$g$的推导：我们钦点一部分作为动态规划的，剩下的自由排列，黄绿红分别代表钦点的方案，剩下的一个点代表自由排列出现的，那么一个蓝色就对应了三种“至少”方案。

因此，可以得到上面的表达式。

# 4.代码

下面是AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	char s;
	int x=0,f=1;
	s=getchar();
	while(s<'0'||s>'9'){
		if(s=='-')f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9'){
		x*=10;
		x+=s-'0';
		s=getchar();
	}
	return x*f;
}
const long long mod=1e9+9;
const int N=2020;
long long qpow(long long a,long long b){
	if(b==0)return 1;
	long long rec=qpow(a,b/2)%mod;
	if(b&1)return rec*rec%mod*a%mod;
	return rec*rec%mod;
}
int n,k;
int a[N],b[N];
int lst[N];//b中比ai小的数字个数 
long long inv[N];//阶乘的逆元 
long long calc[N];//阶乘 
long long dp[N][N];
long long g[N];//n对里面有至少i对a>b的方案数 
void init(){
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read();
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	for(int i=1,id=0;i<=n;i++){
		while(b[id+1]<a[i]&&id<n)id++;
		lst[i]=id;
	}
	calc[0]=1;
	for(int i=1;i<=n;i++){
		calc[i]=(long long)calc[i-1]*i%mod;
	}
	inv[n]=qpow(calc[n],mod-2);
	for(int i=n-1;i>=0;i--){
		inv[i]=(long long)inv[i+1]*(i+1)%mod;
	}
}
int main(){
	n=read(),k=read();
	if((n+k)&1){
		printf("0");
		return 0;
	}
	k=(n+k)/2;
	init();
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		dp[i][0]=dp[i-1][0];
		for(int j=1;j<=i;j++){
			dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*max(0,lst[i]-j+1)%mod)%mod;
			dp[i][j]%=mod;
		} 
	}
	for(int i=0;i<=n;i++){
		g[i]=dp[n][i]*calc[n-i]%mod;
	}
	long long ans=0;
	long long id=1;
	for(int i=k;i<=n;i++){
		ans+=(long long)id*calc[i]%mod *inv[k]%mod*inv[i-k]%mod*g[i]%mod;
		ans=(ans%mod+mod)%mod;
		id=-id;
	}
	ans=(ans%mod+mod)%mod;
	printf("%lld\n",ans);
}
```



---

## 作者：derta (赞：3)

[luogu P4859 已经没有什么好害怕的了](https://www.luogu.com.cn/problem/P4859)

### 第一步
令 $h$ 为有多少组 $a>b$ 才能满足要求，易得 $h=\frac{n+k}{2}$

将 $a,b$ 按升序排列

### 第二步
考虑 dp

设 $l_i$ 为有多少个 $b_j<a_i$

$f_{i,j}$ 为选到第 $i$ 个数，有 $j$ 组 $a>b$ 的方案数

则有转移方程

$$f_{i,j}=f_{i-1,j}+(l_i-j+1)f_{i-1,j-1}$$

$(l_i-j+1)$ 是指将 $a_i$ 与一个严格小于 $a_i$ 的 $b_i$ 配对的方案数，本有 $l_i$ 种，但由于我们已经将 $a_i$ 排序，故对于之前的 $a>b$ 的组选择的 $b$，$a_i$ 也可以选择它，造成重复，故删去之前选的 $j-1$ 个数

边界：$f_{0,0}=1$

### 第三步

设 $g_i=(n-i)!f_{n,i}$，就是先配对 $i$ 组 $a>b$ 的，剩下的随便选。这样一定涵盖的所有的 $t$ 组 $a>b$ 的情况（ $t \geqslant i$），但是会有重复，具体地，设 $ans_i$ 为选 $i$ 组 $a>b$ 的方案数，则有

$$g_h=\sum_{i=h}^{n}C_i^h ans_i$$

二项式反演，得

$$ans_h=\sum_{i=h}^{n}(-1)^{i-h}C_i^h g_i$$

直接计算即可

### tips
- 为了快速计算组合数，可以预处理阶乘与之逆元
- $10^9+9$ 为质数，求逆时可以直接用 $a^{mod-1}$
- 可以 排序后 $O(n)$ 求出 $l_i$

相信读懂了的读者都可以自行写出代码，就不给了

---

## 作者：ccviolett (赞：1)

一道很好的题。

首先知道要求什么，求 a 与 b 合法匹配的数量，等价于固定 a 求合法的 b 排列数量。计数问题先考虑 DP，如果按照题目的说法，则需要在 DP 中加入一维表示大于和小于的差来计算答案，并不可做，考虑转换。

因为两行不会有重复数字，当 $|\{a>b\}| - |\{a<b\}| = k$，因为 $|\{a>b\}| + |\{a<b\}| = n$，等价于 $|\{a>b\}| = \frac{n + k}{2}$。

现在只需要 DP 统计 $dp_{i, j}$ 表示 a 排序之后，考虑前 i 个元素， $|\{a>b\}| = j$ 的方案数。

但是这个 DP 还是不能做，其具有后效性，一个位置 a 可以和后面的 b 匹配，从而无法知到每个 a 还有哪些 b 可以匹配。

考虑消除后效性，强制每个 a 只能往前面匹配，改变状态为 $dp_{i, j}$ 表示考虑前 i 个元素只往前匹配，匹配了 j 组 $a>b$ 时的方案数。

这个就可以做了，$dp_{i, j} = dp_{i - 1, j} + (num_i - j + 1)  \times dp_{i - 1, j - 1}$，其中 $num_i = \sum_{j = 1}^n [a_i > b_j]$。

最后得出来的 $dp_{n, i}$，表示所有的 $a$ 中有 $i$ 个位置已经向前匹配，且得到的结果是大于，剩下的位置我们无论怎么匹配，也至少有 $i$ 个 $a > b$ 了。

看到至少，要求恰好，想到二项式反演。

设 $g_i$ 表示至少 $i$ 个 $a > b$ 的方案数，$g_i = dp_{n, i} \times (n - i)!$，$f_i$ 表示恰好 $i$ 个 $a > b$ 的方案数。

$$
g_k = \sum_{i = k}^{n} \binom{i}{k} f_i\\
f_k = \sum_{i = k}^{n} (-1)^{i - k}\binom{i}{k} g_i
$$

答案为 $f_{\frac{n + k}{2}}$。

```cpp
typedef long long readtype;

/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 2e3 + 1;
const int MOD = 1e9 + 9;

inline int add(int a, int b) { return (a + b >= MOD) ? a + b - MOD : a + b; }
inline int mul(int a, int b) { return (1ll * a * b) % MOD; }

int n, k;
int a[N], b[N];
int num[N];
int lf[N][N], g[N], f[N];
int fac[N], inv[N], invfac[N];

int C(int n, int m);

int main() {
#ifndef ONLINE_JUDGE
  freopen("3622.in", "r", stdin);
  freopen("3622.out", "w", stdout);
#endif
  n = read(), k = read();
  if ((n + k) & 1) return !puts("0");

  inv[0] = inv[1] = 1;
  for (int i = 2; i <= n; ++i) inv[i] = mul(MOD - MOD / i, inv[MOD % i]);
  fac[0] = invfac[0] = 1;
  for (int i = 1; i <= n; ++i) {
    fac[i] = mul(fac[i - 1], i);
    invfac[i] = mul(invfac[i - 1], inv[i]);
  }

  for (int i = 1; i <= n; ++i) a[i] = read();
  sort(a + 1, a + n + 1);
  for (int i = 1; i <= n; ++i) b[i] = read();
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      if (b[j] < a[i]) num[i]++;
    }
  }

  lf[0][0] = 1;
  for (int i = 1; i <= n; ++i) {
    lf[i][0] = lf[i - 1][0];
    for (int j = 1; j <= n; ++j) {
      lf[i][j] = add(lf[i - 1][j], mul(lf[i - 1][j - 1], max(0, num[i] - (j - 1))));
    }
  }

  for (int i = 0; i <= n; ++i) g[i] = mul(lf[n][i], fac[n - i]);

  for (int i = 0; i <= n; ++i) {
    for (int j = i; j <= n; ++j) {
      int tv = mul(C(j, i), g[j]);
      if ((j - i) & 1) f[i] = add(f[i], MOD - tv);
      else f[i] = add(f[i], tv);
    }
  }

  printf("%d\n", f[(n + k) / 2]);
  return 0;
}

int C(int n, int m) {
  return mul(fac[n], mul(invfac[n - m], invfac[m]));
}
```


---


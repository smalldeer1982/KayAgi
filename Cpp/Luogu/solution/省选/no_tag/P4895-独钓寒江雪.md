# 独钓寒江雪

## 题目描述

给定一棵无根树，求其中本质不同的独立集的个数。

## 样例 #1

### 输入

```
1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 2
1 3
1 4
1 5```

### 输出

```
6```

## 样例 #3

### 输入

```
6
1 2
1 3
1 4
4 5
4 6```

### 输出

```
9```

# 题解

## 作者：WeLikeStudying (赞：17)

- 题目说得一点都不清楚（可能是因为它是从某 $\text{OJ}$ 搞过来的吧，~~那为啥不把那充满文采的题目背景也搬过来呢~~）。
- 作者结合原 $\text{OJ}$ 的文案再次对题面进行了改造。

**题意是啥**
- [原题链接](https://www.luogu.com.cn/problem/P4895)。
- 给定一棵 $n$ 个节点的无根树，对该树的节点进行黑白染色，要求任意两个黑点没有直接的边相连，求本质不同的染色方案模 $10^9+7$ 的余数。
- 如果两个染色方案所形成的树可以对节点重新标号后，使得对于任意编号为 $u$ 的节点，它在两棵树中只会同时为黑色或同时为白色，而且任意边 $(u,v)$ 在两棵树中只会同时存在或同时不存在，则称两个染色方案相同（说白了两个方案的树同构）。
![](https://cdn.luogu.com.cn/upload/image_hosting/om529pqj.png)
- $n\le 5\times 10^5$。
- 作者一开始根本不明白题目在讲什么，而唯一的题解……额，总之作者将围绕自己遇到的问题开始讲解。

**最开始的思路怎么来的**
- 看起来很像树论的树形计数动态规划对吧，但是树是无根的。
- 我们如果直接强行选定一个根的话，就可能出现这样一种情况：比如选定 $u$ 为根，可能存在节点 $v$ 满足 $u\ne v$ 使得以 $u$ 为根的有根树和以 $v$ 为根的有根树同构，那样方案明显会算重复。
![](https://cdn.luogu.com.cn/upload/image_hosting/kcm4utqo.png)
- 尽管我们还未确定具体的策略，但强后效性是不允许的。
- 有没有好的办法来避免这一问题呢。
- 我们知道，一棵树的重心与这棵树的根是哪个没有关系，我们可以尝试以重心为根。
- 那么重心为啥不可替代呢：因为如果有 $u,v$，$u$ 是重心，以 $u,v$ 为根的树同构，那它们最大子树相等，那么 $v$ 也是重心，所以不用担心算重复。
- 请保证理解这些知识：一棵树最多有两个重心，如果有两个重心，那么这两个重心一定直接连边。
- 接下来我们重点讲解只有一个重心的情况，最后再解析如何求解有两个重心的问题。

**如何计算方案数**
- 我们已经在实质上将无根树转化为有根树进行求解了，接下来问题就在于计算方案数。
- 首先可以很套路地设出 $f(u,0/1)$ 表示以 $u$ 为根（$u$ 是否染成黑色）的子树的染色方案数，转移比较基本。
- 接下来遇到一个很严重的问题：$u$ 可能有很多个不同的子树，这些子树如果两两不同构那当然好处理，但如果有同构的怎么办？（先忽略我们还不知道树同构如何判断的事实）
- 打个比方，我知道有 $m$ 棵同构的树，它们的方案数都是 $n$，那么它们对 $u$ 的贡献是多少。
- 转化为一个简单的问题：$n$ 个物品中取 $m$ 个（可以取重复）的总方案数是多少？考虑在 $m$ 个物品中间插入 $m-1$ 个防止取走重复，总方案数为 $C(n+m-1,m)$。
- 接下来作者将解析如何判断树是否同构。

**哈希判断树同构**
- 作者知道有很多判断树同构的哈希方法，但作者介绍的方法有这样的特点：哈希只是一个辅助手段，如果没有哈希方法，对于一棵节点数为 $n$ 的有根树，构造它的复杂度是 $O(\frac{n^2\lg n}{\omega})$ 级别的，但最后会得到一个 $100\%$ 正确的判断树同构的编码。
- 理由很简单：作者希望自己的哈希通过随便更改模数的方法就可以避免针对，而不是寄希望于数据多水。
- 作者的哈希值以 $01$ 串的形式编码。
- 方法很简单：叶节点的哈希值为 $H(u)=01$。
- 对于节点 $u$，节点按照哈希值字典序大小排序（由于要求本质相同所以要排序），编码为 $v_1,v_2,\cdots v_m$，那么有：
$$H(u)=0H(v_1)H(v_2)\cdots H(v_m)1$$
- 可以轻易地将其当作二进制整数进行编码，下面是一个例子：
![](https://cdn.luogu.com.cn/upload/image_hosting/uqas8zwj.png)
- 通过这样的方式，即可用 $O(n\lg n)$ 的时间，算出树上每个节点的哈希值，并以哈希值的相等与否来比较子树的同构与否。
- 编码时可以同时计算子树大小和答案，起到辅助哈希的效果。

**有两个重心的情况**
- 有两个重心怎么办？
- 如果有两个重心，那么这两个重心一定直接连边。
- 断开这条边，变成两个子树（显然相当于有根），分情况讨论就好了：
- 分析如果两棵子树同构应该怎么办，如果不同构应该怎么办，已经不是最困难的部分了。

**代码实现**
- [代码实现](https://www.luogu.com.cn/paste/4gfuj54q)。
- 作者是 $1A$ 的，思路稳当，打得自然顺畅。
- 这里作者记一下代码细节，如果您实现出现问题的话也可以看看。
- 一定要在深度优先搜索之后记录搜索的节点，不然会被覆盖。
- 记录的节点要套一个数组，不要直接写下标。

---

## 作者：Ark_ (赞：10)

# 题意
给出一棵无根树，求本质不同的独立集数模$1000000007$的值。

$n\le 500000$
# 题解
如果是有根树就好做多了。然而无根树可以找重心作为根，转化为有根树。

那么考虑有根树的本质不同的独立集数怎么求。

直接$dp$就行了。用$f[i][0]$表示$i$不选的独立集数，$f[i][1]$表示$i$要选的独立集数。

转移的时候要考虑本质是否不同。做法是树$hash$。把子节点的$hash$值排序后，值相同的子树拿出来一起考虑，用简单组合数计算。求组合数可以暴力求，总时间复杂度是$O(n)$的。

还有问题就是一颗无根树可能重心在边上，那么我们把这条边新建一个点作为根，同样$dp$就行了。求最终答案的时候要特别考虑一下。

时间复杂度$O(n\log n)$，因为要排序。
# CODE
底数选的好$hash$可能随便过，否则就要多搞点信息进去，比如儿子个数什么的。。
```cpp
#pragma GCC optimize (3)
#include <bits/stdc++.h>
using namespace std;
char cb[1<<15],*cs=cb,*ct=cb;
#define getc() (cs==ct&&(ct=(cs=cb)+fread(cb,1,1<<15,stdin),cs==ct)?0:*cs++)
void read(int &res){
	char ch; for(;!isdigit(ch=getc()););
	for(res=ch-'0';isdigit(ch=getc());res=res*10+ch-'0');
}
typedef long long LL;
typedef unsigned long long ULL;
const int MAXN = 500005;
const int mod = 1e9 + 7;
const ULL p = 998244353;
int n, fir[MAXN], to[MAXN<<1], nxt[MAXN<<1], cnt;
inline void link(int u, int v) { to[++cnt] = v; nxt[cnt] = fir[u]; fir[u] = cnt; }
int rt[2];
int dfs(int u, int ff) {
	int re = 1, tmp; bool can = 1;
	for(int i = fir[u], v; i; i = nxt[i])
		if((v=to[i]) != ff) {
			re += (tmp = dfs(v, u));
			if(tmp<<1 > n) can = 0;
		}
	if(re<<1 < n) can = 0;
	if(can) rt[bool(rt[0])] = u;
	return re;
}
ULL hsh[MAXN];
int f[MAXN][2], c[MAXN], inv[MAXN];
inline bool cmp(int i, int j) { return hsh[i] < hsh[j]; }
inline int C(int N, int M) {
	int re = 1;
	while(M && re) re = 1ll * re * (N--) % mod * inv[M--] % mod;
	return re;
}
void dp(int u, int ff) {
	f[u][0] = f[u][1] = 1;
	hsh[u] = 233333;
	for(int i = fir[u], v; i; i = nxt[i])
		if((v=to[i]) != ff) dp(v, u);
	int cur = 0;
	for(int i = fir[u], v; i; i = nxt[i])
		if((v=to[i]) != ff) c[++cur] = v;
	sort(c + 1, c + cur + 1, cmp);
	for(int i = 1, j, v; i <= cur; i = j) {
		v = c[i];
		for(j = i; j <= cur && hsh[c[j]] == hsh[v]; ++j)
			hsh[u] = hsh[u] * p ^ hsh[c[j]];
		f[u][0] = 1ll * f[u][0] * C(((f[v][0]+f[v][1])%mod + j-i-1)%mod, j-i) % mod;
		f[u][1] = 1ll * f[u][1] * C((f[v][0] + j-i-1)%mod, j-i) % mod;
	}
	hsh[u] *= p * p;
	hsh[u] = (hsh[u] + (ULL)cur + 1ull) * p;
}
inline void pre(int N) {
	inv[0] = inv[1] = 1;
	for(int i = 2; i <= N; ++i) inv[i] = 1ll * (mod - mod/i) * inv[mod%i] % mod;
}
int main () {
	read(n); pre(n);
	for(int i = 1, u, v; i < n; ++i) read(u), read(v), link(u, v), link(v, u);
	dfs(1, 0);
	int r = rt[0];
	if(rt[1]) {
		r = ++n;
		for(int i = fir[rt[0]]; i; i = nxt[i]) if(to[i] == rt[1]) to[i] = r;
		for(int i = fir[rt[1]]; i; i = nxt[i]) if(to[i] == rt[0]) to[i] = r;
		link(r, rt[0]), link(r, rt[1]);
	}
	dp(r, 0);
	if(rt[1]) {
		int ans;
		if(hsh[rt[0]] != hsh[rt[1]]) ans = (1ll*f[rt[0]][0]*f[rt[1]][0]%mod + 1ll*f[rt[0]][0]*f[rt[1]][1]%mod + 1ll*f[rt[0]][1]*f[rt[1]][0]%mod) % mod;
		else ans = (C(f[rt[0]][0] + 1, 2) + 1ll*f[rt[0]][0]*f[rt[1]][1]%mod) % mod;
		printf("%d\n", ans);
	}
	else printf("%d\n", (f[r][0] + f[r][1]) % mod);
}
```

---

## 作者：TallBanana (赞：5)

**考虑弱化版本 I**：给定一棵**有**根树，求其中**不同**的独立集的个数。
* 那么这个非常好做呀，直接最朴素的独立集 dp，设 $f_{u,0/1}$ 表示考虑了 $u$ 子树内，$u$ 选了还是没选。转移不再赘述。

**考虑弱化版本 II**：给定一棵**有**根树，求其中**本质不同**的独立集的个数。
* 那么我们发现对于 $u$ 和他的儿子 $v$，如果有哪些子树是同构的，我们就不能直接乘上方案数。
* 考虑把同构的子树在一起处理。那么我们发现方案数是不同的盒子，而儿子是相同的小球。插板法计算方案数，乘到 dp 数组里面。

**考虑原问题**：

对于**无根树**，我们一般的方法是找到其重心，以重心为根。
* 对于只有**一个**重心的情况，就是**弱化版本 II**。
* 对于**两个**重心的情况，不妨设重心是 $u,v$，那么我们先断开 $(u,v)$ 的边，然后对于 $u,v$ 分别作为根跑**弱化版本 II**。考虑合并的问题。设 $F_0=f_{u,0},F_1=f_{u,1},G_0=f_{v,0},G_1=f_{v,1}$。
  * 对于 $u,v$ 两棵树**不同构**的情况，答案是 $F_0\times G_1+F_0\times G_0+F_1\times G_0$。
  * 对于 $u,v$ 两棵树**同构**的情况，那么答案是 $F_0\times F_1+C_{F_0+1}^2$。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
const LL N=5e5+10,P=1e9+7;
LL n,siz[N],o[N],f[N][2],inv[N],rt1,rt2,ans;
ULL H[N];
vector<LL> e[N];
LL ksm(LL a,LL b) { LL res=1; for(;b;b>>=1,a=a*a%P) if(b&1) res=res*a%P; return res; }
void GG(LL u,LL fa=0)
{
	siz[u]=1;
	for(auto v:e[u])
	{
		if(v==fa) continue;
		GG(v,u); siz[u]+=siz[v];
		o[u]=max(o[u],siz[v]);
	}
	o[u]=max(o[u],n-siz[u]);
	if(o[u]<o[rt1]) rt1=u,rt2=0;
	else if(o[u]==o[rt1]) rt2=u;
}
void Bond(LL u,LL v)
{
	for(int i=0;i<e[u].size();i++)
		if(e[u][i]==v)
			return e[u].erase(e[u].begin()+i),void();
}
ULL F(ULL x)
{
	x^=87427417919791;
	x^=(x<<5); x^=(x>>7); x^=(x<<3);
	return x^87427417919791;
}
LL C(LL n,LL m)
{
	LL res=1;
	for(LL i=n-m+1;i<=n;i++) res=res*i%P;
	for(LL i=1;i<=m;i++) res=res*inv[i]%P;
	return res;
}
bool cmp(LL a,LL b) { return H[a]<H[b]; }
void dfs(LL u,LL fa=0)
{
	f[u][0]=f[u][1]=1;
	for(auto v:e[u])
	{
		if(v==fa) continue;
		dfs(v,u); H[u]+=F(H[v]);
	}
	sort(e[u].begin(),e[u].end(),cmp);
	LL cnt=0;
	for(int i=0;i<e[u].size();i++)
	{
		LL v=e[u][i];
		if(v==fa) continue;
		cnt++;
		if(i==e[u].size()-1||H[v]!=H[e[u][i+1]])
		{
			f[u][0]=f[u][0]*C(f[v][0]+f[v][1]+cnt-1,cnt)%P;
			f[u][1]=f[u][1]*C(f[v][0]+cnt-1,cnt)%P;
			cnt=0;
		}
	}
	H[u]++;
}
int main()
{
	o[0]=100000000;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) inv[i]=ksm(i,P-2);
	for(int i=1,u,v;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	GG(1); Bond(rt1,rt2); Bond(rt2,rt1);
	if(!rt2) dfs(rt1),ans=(f[rt1][0]+f[rt1][1])%P;
	else
	{
		dfs(rt1); dfs(rt2);
		LL f0=f[rt1][0],f1=f[rt1][1];
		LL g0=f[rt2][0],g1=f[rt2][1];
		if(H[rt1]==H[rt2]) ans=(f0*f1%P+C(f0+1,2)%P)%P;
		else ans=(f0*g0%P+f1*g0%P+f0*g1%P)%P;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Judgelight (赞：5)

[传送门](https://www.luogu.com.cn/problem/P4895)

---

考虑任意选一个点当根，设状态为 $f_{u,0/1}$ 表示 $u$ 的子树，选择/不选 $u$ 的**不同构**方案数。

可以想到有 $f_{u,0}=\prod\limits_{v\in son_u}(f_{v,0}+f_{v,1})$，$f_{u,1}=\prod\limits_{v\in son_u}f_{v,0}$，但是这样算肯定是错的，所以考虑枚举 $v$ 的时候每一个同构类一起讨论（判断同构可以写树哈希，如果被卡了考虑在上面加一点类似深度和儿子个数之类的）。


注意到对于两种同构的方案，一定在某一点处选择了两棵同构的不同子树，比如：![](https://cdn.luogu.com.cn/upload/image_hosting/bdk02poa.png)

显然左右同构，因为 $2$ 子树和 $3$ 子树同构。

所以就有了一个思路：如果现在计算的是 $f_{u,0}$，假设当前同构类有 $x$ 个点，这 $x$ 个点的 $f$ 均为 $g_{0/1}$（因为同构所以 $f$ 相等），相当于可重复地从 $g_{0}+g_{1}$ 中选择 $x$ 种进行组合，方案数为 $C_{g_0+g_1+x-1}^{x}$（隔板法可证）。最后 $f_{u,0}$ 就是所有等价类答案的积，$f_{u,1}$ 是同理的。

最后注意一点：如果任意选的点能与其他点当根的树同构，答案就是错的。考虑在无根树中的特殊点重心，可以考虑选重心当根，这样就最多两个，而且相邻，直接特判即可。

```cpp
#include<bits/stdc++.h>
#define N 500009
#define eb emplace_back
#define ll unsigned long long
using namespace std;
inline char nc(){ static char buf[1000000],*p=buf,*q=buf; return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++; } inline int read(){ int res = 0; char c = nc(); while(c<'0'||c>'9')c=nc(); while(c<='9'&&c>='0')res=res*10+c-'0',c=nc(); return res; } char obuf[1<<21],*p3=obuf; inline void pc(char c){ p3-obuf<=(1<<20)?(*p3++=c):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=c); } inline void write(int x){ if(x<0) pc('-'),x=-x; if(x>9) write(x/10); pc(x%10+'0'); }
const int mod=1e9+7;
int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return ans;
}
int n,Size[N],ss[N],rt[2],f[N][2],inv[N];
ll hs[N],a[N];
vector<int>V[N];
void dfs(int u,int from){
	Size[u]=1;
	for(auto v:V[u])if(v!=from)dfs(v,u),Size[u]+=Size[v],ss[u]=max(ss[u],Size[v]);
	ss[u]=max(ss[u],n-Size[u]);
}
unordered_map<ll,int>mp,mp1;
void dfs1(int u,int from){
	Size[u]=1;
	for(auto v:V[u]){
		if((u==rt[0]&&v==rt[1])||(u==rt[1]&&v==rt[0]))continue;
		if(v!=from)dfs1(v,u),Size[u]+=Size[v],hs[u]+=a[Size[v]]*hs[v];
	}
	hs[u]++;hs[u]=hs[u]*Size[u];
}
int C(int n,int m){
	int ans=inv[m];
	for(int i=n-m+1;i<=n;i++)ans=1ll*ans*i%mod;
	return ans;
}
void dfs2(int u,int from){
	f[u][0]=f[u][1]=1;
	for(auto v:V[u]){
		if((u==rt[0]&&v==rt[1])||(u==rt[1]&&v==rt[0]))continue;
		if(v!=from)dfs2(v,u);
	}
	mp.clear(),mp1.clear();
	for(auto v:V[u]){
		if((u==rt[0]&&v==rt[1])||(u==rt[1]&&v==rt[0]))continue;
		if(v!=from)mp[hs[v]]++,mp1[hs[v]]=v;
	}
	for(auto x:mp){
		f[u][0]=1ll*f[u][0]*C(x.second+f[mp1[x.first]][1]+f[mp1[x.first]][0]-1,x.second)%mod;
		f[u][1]=1ll*f[u][1]*C(x.second+f[mp1[x.first]][0]-1,x.second)%mod;
	}
}
signed main(){
	srand(time(0));
	n=read();
	a[0]=1;for(int i=1;i<=n;i++)a[i]=a[i-1]*rand()*i%mod;
	inv[1]=1;for(int i=2;i<=n;i++)inv[i]=1ll*inv[i-1]*ksm(i,mod-2)%mod;
	for(int i=1,x,y;i<n;i++)x=read(),y=read(),V[x].eb(y),V[y].eb(x);
	dfs(1,0);
	rt[0]=1;
	for(int i=2;i<=n;i++){
		if(ss[i]<ss[rt[0]])rt[0]=i,rt[1]=0;
		else if(ss[i]==ss[rt[0]])rt[1]=i;
	}
	if(rt[1]){
		n++,V[n].eb(rt[0]),V[rt[0]].eb(n),V[n].eb(rt[1]),V[rt[1]].eb(n),dfs1(n,0),dfs2(n,0);
	}
	else{
		dfs1(rt[0],0),dfs2(rt[0],0);
	}
	if(rt[1]){
		if(hs[rt[0]]==hs[rt[1]])printf("%lld",(C(f[rt[0]][0]+1,2)+1ll*f[rt[0]][0]*f[rt[1]][1]%mod)%mod);
		else printf("%lld",(1ll*f[rt[0]][0]*f[rt[1]][0]%mod+1ll*f[rt[0]][1]*f[rt[1]][0]%mod+1ll*f[rt[0]][0]*f[rt[1]][1]%mod)%mod);
	}
	else printf("%d",(f[rt[0]][0]+f[rt[0]][1])%mod);
	return 0;
}
```

---

## 作者：Mr_罗 (赞：4)

无标号无根树计数经典套路：钦定重心为根，「合并」同构子树，dp 组合计数。

- 重心：最大子树大小最小的节点。可能有两个，此时可以把连接它们的边（可以证明一定存在）拆成一个新点再做处理。
- 同构：擦掉标号后完全相同。  
  利用 [$\boxed{{\sf 树哈希}(\text{OI-Wiki})}$](https://oi-wiki.org/graph/tree-hash/) 即可判断。

---

首先以重心为根，考虑有标号的方案数：直观地，设 $f_{u,0/1}$ 表示以 $u$ 为根的子树中 $u$ 不选或选的方案数，转移为
$$
\begin{aligned}
f_{u,0}&=\prod_{v\in\text{son}_ u}(f_{v,0}+f_{v,1})\\
f_{u,1}&=\prod_{v\in\text{son}_ u}f_{v,0}\\
f_{x,*}&=1(x{\sf\ 是叶子})
\end{aligned}
$$

---

再考虑无标号的情况。唯一的不同点在于若两棵同构的子树交换染色方案，则只计一次数。

自然地，我们把同构的子树放在一起考虑。

设 $v$ 是 $u$ 的一个儿子，$m$ 表示挂在 $u$ 上的所有子树中有多少和以 $v$ 为根的子树同构（包括其本身）。

对于将若干种方案分配给这 $m$ 棵子树的不同方案数，可以转化为有 $n$ 个不同小球放进 $m$ 个相同盒子内（最多一个）的方案数，亦即 **$\boldsymbol{m}$ 个相同小球放入 $\boldsymbol{n}$ 个不同盒子内（可以为空）的方案数**。这可以用插板法轻松解决：
$$
\begin{aligned}
f_{u,0}&\xleftarrow{\times}\binom{f_{v,0}+f_{v,1}+m-1}{m}\\
f_{u,1}&\xleftarrow{\times}\binom{f_{v,0}+m-1}{m}
\end{aligned}
$$

---

若树只有一个重心 $r$，那么答案为 $f_{r,0}+f_{r,1}$；

若树有两个重心 $r_1,r_2$，则需要讨论一下砍成两棵树后是否同构，若同构则答案为 $\binom{f_{r_1,0}+1}{2}+f_{r_1,0}f_{r_2,0}$，否则为 $f_{r_1,0}f_{r_2,0}+f_{r_1,0}f_{r_2,1}+f_{r_1,1}f_{r_2,0}$。

---

总时间复杂度：$\mathcal{O}(n\log n)$。

注意：求组合数时不能使用预处理阶乘的方法，因为 $f_{*,*}$ 需要取模，过大；注意到所有 $m$ 加起来为每个点的儿子个数之和不超过 $n$（应该是 $n-1$），因此可以预处理每个数的逆元，并暴力求组合数。

---

代码如下，其中树哈希部分借鉴的 @Ark_ 的写法而非 OI-Wiki 的写法。

注意哈希值的选取，一些值会挂。

```cpp
#include <bits/stdc++.h>
using namespace std;

// #define CF

#define ll long long
#define ul unsigned ll
#define LL __int128_t
#define db double
#define DB long db
#define pii pair<int, int>
#define fi first
#define se second
#define mkpr make_pair
#define mem(a, x) memset(a, x, sizeof(a))
#define rep(i, l, r) for (int i(l), i##End(r); i <= i##End; i = -~i)
#define per(i, r, l) for (int i(r), i##End(l); i >= i##End; i = ~-i)

template<typename T, typename U> void chkmx(T &_a, U _b) { if (_a < _b) _a = _b; }
template<typename T, typename U> void chkmn(T &_a, U _b) { if (_a > _b) _a = _b; }

constexpr int N = 500005;
constexpr ll mod = 1'000'000'007, P = 13131;
int n, ss, rt, m;
vector<int> G[N];
int sz[N], mx[N];
ll fac[N], inv[N];
ul hs[N], pw[N];
int a[N];
ll f[N][2];
bool isrt[N];

ll qpow(ll a, ll b = ::mod - 2, ll mod = ::mod)
{
    ll ml = 1, bs = a;
    while (b)
    {
        if (b & 1) (ml *= bs) %= mod;
        (bs *= bs) %= mod, b >>= 1;
    }
    return ml;
}

ll C(ll n, ll m)
{
	ll res = 1; while(m && res) res = 1ll * res * (n--) % mod * inv[m--] % mod;
	return res;
}

void fdrt(int u, int ft)
{
    sz[u] = 1;
    for (auto v : G[u])
    {
        if (v == ft) continue;
        fdrt(v, u), sz[u] += sz[v], chkmx(mx[u], sz[v]);
    }
    chkmx(mx[u], n - sz[u]), chkmn(ss, mx[u]);
}

void calc(int u, int ft)
{
    #ifdef JYR
    printf("calc(%d, %d)\n", u, ft);
    #endif
    f[u][0] = f[u][1] = 1, hs[u] = 20240926;
    for (auto v : G[u]) if (v != ft) calc(v, u);
    int m = 0; for (auto v : G[u]) if (v != ft) a[++m] = v;
    sort(a + 1, a + m + 1, [](int x, int y) { return hs[x] < hs[y]; });
    for (int i = 1, j; i <= m; i = j)
    {
        int v = a[i]; for (j = i; j <= m && hs[a[j]] == hs[v]; j++) hs[u] = hs[u] * P ^ hs[a[j]];
        f[u][0] = 1ll * f[u][0] * C(((f[v][0] + f[v][1]) % mod + j - i - 1) % mod, j - i) % mod;
        f[u][1] = 1ll * f[u][1] * C((f[v][0] + j - i - 1) % mod, j - i) % mod;
    }
    hs[u] *= P * P;
    hs[u] = (hs[u] + (ul)m + 1ull) * P;
}

void solve()
{
    scanf("%d", &n), m = n;
    rep(i, 2, n)
    {
        int u, v; scanf("%d%d", &u, &v);
        G[u].push_back(v), G[v].push_back(u);
    }
    ss = n, fdrt(1, 0);
    rep(i, 1, n) if (mx[i] == ss)
    {
        if (rt)
        {
            n++;
            for (auto &v : G[rt]) if (v == i) v = n;
            for (auto &v : G[i]) if (v == rt) v = n;
            G[n].push_back(rt), G[n].push_back(i), rt = n;
            break;
        }
        else rt = i;
    }
    calc(rt, 0);
    if (n == m) printf("%lld\n", (f[rt][0] + f[rt][1]) % mod);
    else
    {
        int u = G[rt][0], v = G[rt][1];
        if (hs[u] == hs[v]) printf("%lld\n", (C(f[u][0] + 1, 2) + f[u][0] * f[v][1] % mod) % mod);
        else printf("%lld\n", (f[u][0] * f[v][0] % mod + f[u][0] * f[v][1] % mod + f[u][1] * f[v][0] % mod) % mod);
    }
}

void init()
{
    n = N - 1; inv[0] = inv[1] = 1; rep(i, 2, n) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}

int main()
{
    init();
    #ifdef CF
    int _; scanf("%d", &_);
    while (_--) solve();
    #else
    solve();
    #endif
    return 0;
}
```

---

## 作者：CharlieCai (赞：1)

### 题意

给定一棵无根树，求其中本质不同的独立集的个数。

### 思路

首先，由于要求统计独立集的个数，所以我们选定的点不能相邻。考虑 dp，设 $f_{i,0}$ 表示 $i$ 的子树内不选 $i$ 的独立集个数，$f_{i,1}$ 表示 $i$ 的子树内选 $i$ 的独立集个数。

接下来考虑如何处理本质不同的要求。对于点 $i$，若它的某种同构子树有 $x$ 个，而该种树的选点方案为 $y$，则计算该种子树的贡献时可以视为将 $x$ 个相同的树分配给 $y$ 个不同的方案，分配的方案数为 ${x+y-1} \choose {x}$。将各种同构子树的贡献相乘即可得到 $f_{i,0/1}$。

最后考虑如何处理无根树。对于无根树，我们可以以这棵树的重心为根进行计算。如果只有一个重心，记重心为 $u$，则答案为 $f_{i,0}+f_{i,1}$；如果有两个重心，记重心分别为 $u,v$，将 $(u,v)$ 边断开，使整棵树分为两棵子树，再分别以 $u,v$ 为根进行 dp，最后根据两棵子树是否同构进行计算，可以选 $u$ 不选 $v$，可以选 $v$ 不选 $u$，也可以两个都不选。若同构，则答案为 $f_{i,0} \times f_{i,1}+ {{f_{i,0}+1} \choose 2}$；若不同构，则答案为 $f_{u,1}\times f_{v,0}+f_{u,0}\times f_{v,1}+f_{u,0}\times f_{v,0}$。

### 代码


```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define MAXN 1000005
#define mod 1000000007
using namespace std;
int n,head[MAXN],cnt,f[MAXN][2],has[MAXN],base,inv[MAXN],siz[MAXN],rt[2],ans;
vector<int>v[MAXN];
struct Edge{
	int value,next;
}edge[MAXN];
void addedge(int u,int v){
	edge[++cnt].value=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
int shift(int x){
	x^=base;
	x^=x>>7;
	x^=x<<13;
	x^=x>>11;
	x^=base;
	return x;
}
int fpow(int a,int b){
	int tans=1;
	while(b){
		if(b&1)tans=tans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return tans;
}
void init(){
	for(int i=1;i<=n;i++)inv[i]=fpow(i,mod-2);
}
int C(int n,int m){
	int tans=1;
	for(int i=n-m+1;i<=n;i++)tans=tans*i%mod;
	for(int i=1;i<=m;i++)tans=tans*inv[i]%mod;
	return tans;
}
bool cmp(int x,int y){
	return has[x]<has[y];
}
void find(int x,int fa){
	siz[x]=1;bool flag=1;
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].value;
		if(y!=fa){
			find(y,x);
			siz[x]+=siz[y];
			if(siz[y]>n/2)flag=0;
		}
	}
	if(n-siz[x]<=n/2&&flag){
		if(!rt[0])rt[0]=x;
		else rt[1]=x;
	}
}
void dfs(int x,int fa){
	f[x][0]=f[x][1]=1;int tcnt=0;
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].value;
		if(y!=fa&&!((x==rt[0]&&y==rt[1])||(x==rt[1]&&y==rt[0]))){//断开两个重心之间的边 
			v[x].push_back(y);
			tcnt++;
			dfs(y,x);
			has[x]=has[x]+shift(has[y]);
		}
	}
	sort(v[x].begin(),v[x].end(),cmp);int tmp=0;
	for(int i=0;i<tcnt;i++){
		int y=v[x][i];
		tmp++;//统计同种子树的数量 
		if(i==tcnt-1){
			f[x][0]=f[x][0]*C(f[y][0]+f[y][1]+tmp-1,tmp)%mod;
			f[x][1]=f[x][1]*C(f[y][0]+tmp-1,tmp)%mod;
			tmp=0;
		}else if(has[y]!=has[v[x][i+1]]){
			f[x][0]=f[x][0]*C(f[y][0]+f[y][1]+tmp-1,tmp)%mod;
			f[x][1]=f[x][1]*C(f[y][0]+tmp-1,tmp)%mod;
			tmp=0;
		}
	}
}
signed main(){
	srand(time(0));
	base=(rand()%30000+1)*(rand()%30000+1)*1331;
	scanf("%lld",&n);
	init();
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%lld%lld",&u,&v);
		addedge(u,v),addedge(v,u);
	}
	find(1,-1);//找树的重心 
	if(!rt[1]){//若只有一个重心 
		dfs(rt[0],-1);
		ans=(f[rt[0]][0]+f[rt[0]][1])%mod;
	}
	else{//若有两个重心 
		dfs(rt[0],-1),dfs(rt[1],-1);
		if(has[rt[0]]==has[rt[1]])ans=(f[rt[0]][0]*f[rt[0]][1]%mod+C(f[rt[0]][0]+1,2))%mod;//两个子树同构 
		else ans=(f[rt[0]][1]*f[rt[1]][0]%mod+f[rt[0]][0]*f[rt[1]][1]%mod+f[rt[0]][0]*f[rt[1]][0]%mod)%mod;//两个子树不同构 
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Kingna (赞：0)

## [P4895 独钓寒江雪](https://www.luogu.com.cn/problem/P4895)

### 题目大意

给定一棵无根树，求其中本质不同的独立集的个数。

### 题目思路

首先这是一个无根树，为了避免计算重复，我们选择重心为根计算答案。如果重心有两个，我们最后考虑如何进行答案合并。

现在开始计数。定义 $f_{i,0/1}$ 表示以 $i$ 为根且 $i$ 为黑色或者白色的方案数。显然从 $u$ 的子节点 $v$ 转移到 $u$ 有：$f_{u,0}=\sum f_{v,0}+f_{v,1}$ 和 $f_{u,1}=\sum f_{v,0}$。

但事实上答案会算重复。我们这样思考，如果 $u$ 有三个子节点全部同构，那么这三个子节点选择情况 $[3,3,2]$ 和选择情况 $[3,2,3]$ 其实是一样的，也就是计算时需要将这种情况去除。数字在这里代表独立集的形态。

形式化的，如果 $u$ 有 $k$ 个子节点全部同构，则子节点的 $f_0$ 和 $f_1$ 都相同，现在每个子节点都可以从 $f_0+f_1$ 或 $f_0$ 种方案中选择一种独立集情形，但是不能出现 $[3,3,2]$ 和 $[3,2,3]$ 这种排序后是一样的情况。 则方案数为 $\binom{f_0+f_1+k-1}{k}$ 种。

处理完重心为根的答案后，考虑合并两个重心（两个重心一定被一条边相连）：

* 若这两个重心为根的子树同构，那么一个重心可以染黑，另一个可以染白。或者两个都染白色，此时需要考虑去重，方案数为 $\binom{f_0+1}{2}$。
* 若这两个重心为根的子树不同构，此时没有重复。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)

const int N = 1e6 + 5, mod = 998244857, Mod = 1e9 + 7;

int n, prime[N], cnt, vis[N], sz[N], szw[N], rt1, rt2, maxn[N];
int f[N], invfac[N], fac[N], g[N][2];
vector<int> G[N];

int qpow(int a, int k, int p) {
  int res = 1;
  while (k) {
    if (k & 1) res = res * a % p;
    a = a * a % p;
    k >>= 1;
  }
  return res;
}

mt19937 rnd(time(0));

void init(int n) {
  fac[0] = 1;
  _for(i, 1, N - 5) fac[i] = fac[i - 1] * i % Mod;
  invfac[N - 5] = qpow(fac[N - 5], Mod - 2, Mod);
  _pfor(i, N - 6, 0) invfac[i] = invfac[i + 1] * (i + 1) % Mod;
  _for(i, 2, n) {
    if (!vis[i]) prime[++cnt] = i;
    for (int j = 1; j <= cnt && i * prime[j] <= n; j++) {
      vis[i * prime[j]] = 1;
      if (i % prime[j] == 0) break;
    } 
  }
  shuffle(prime + 1, prime + cnt + 1, rnd);
}

void init_G(int u, int fa) {
  sz[u] = 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    init_G(v, u);
    sz[u] += sz[v];
  }
}

void find_root(int u, int fa) {
  int res = 0;
  for (auto v : G[u]) {
    if (v == fa) continue;
    find_root(v, u);
    res = max(res, sz[v]);
  }
  res = max(res, n - sz[u]);
  maxn[u] = res;
}

void dfs(int u, int fa) {
  szw[u] = 1;f[u] = 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dfs(v, u); szw[u] += szw[v];
    f[u] = (f[u] + f[v] * prime[szw[v]] % mod) % mod; 
  }
}

int C(int n, int m) {
  int res = 1;
  _pfor(i, n, n - m + 1) res = res * (i % Mod) % Mod;
  res = res * invfac[m] % Mod;
  return res;
}

PII Ft[N];

void dp(int u, int fa) {
  int tot = 0;
  for (auto v : G[u]) {
    if (v == fa) continue;
    dp(v, u);
  }
  for (auto v : G[u]) {
    if (v == fa) continue;
    Ft[++tot] = {f[v], v};
  }
  sort(Ft + 1, Ft + tot + 1);
  g[u][0] = g[u][1] = 1;
  _for(i, 1, tot) {
    int r = i - 1;
    while (r + 1 <= tot && Ft[r + 1].first == Ft[i].first) r++;
    g[u][0] = g[u][0] * C(r - i + 1 + g[Ft[r].second][0] + g[Ft[r].second][1] - 1, r - i + 1) % Mod;
    g[u][1] = g[u][1] * C(r - i + 1 + g[Ft[r].second][0] - 1, r - i + 1) % Mod;
    i = r;
  } 
}

signed main() {
  cin >> n; init(N - 5);
  _for(i, 1, n - 1) {
    int u, v;
    cin >> u >> v;
    G[u].push_back(v);
    G[v].push_back(u);
  } 
  init_G(1, 0);
  find_root(1, 0);
  int all_min = 2e9;
  _for(i, 1, n) all_min = min(all_min, maxn[i]);
  _for(i, 1, n) {
    if (maxn[i] == all_min) {
      if (!rt1) rt1 = i;
      else rt2 = i;
    }
  }
  if (rt2 == 0) {
    dfs(rt1, 0);
    dp(rt1, 0);
    cout << (g[rt1][0] + g[rt1][1]) % Mod << endl;
  }
  else {
    dfs(rt1, rt2); dfs(rt2, rt1);
    dp(rt1, rt2); dp(rt2, rt1);
    if (f[rt1] == f[rt2]) cout << (C(g[rt1][0] + 1, 2) + g[rt1][0] * g[rt2][1] % Mod) % Mod << endl;
    else cout << (g[rt1][0] * g[rt2][0] % Mod + g[rt1][0] * g[rt2][1] % Mod + g[rt1][1] * g[rt2][0] % Mod) % Mod << endl;
  }
}
```

---


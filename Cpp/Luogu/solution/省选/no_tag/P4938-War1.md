# War1

## 题目背景

`XM大战`来临之际，`ENLIGHTENED总部`为了抵御`RESISTANCE`的进攻，调整了某地`Portal`的能量值，使得其可以经受更多的打击。

## 题目描述

`ENLIGHTENED总部`有$N$个`Portal`，编号为$1$~$N$，编号为$i$的`Portal`初始能量值为$A[i]$，在`Portal`之间有$M$条`LINK`，每条`LINK`着连接着两个不同`Portal`，被连接着的两个`Portal`可以相互传输能量，每个`Portal`最多总共只能向其连接着的`Portal`传输$A[i]$点能量，现在`ENLIGHTENED行动指挥想让每第i个Portal的能量值变为至少B[i]，但他不知道着可不可行，所以找到了你，如果可行的话，需要你求出一种可行的能量传输方案。

**能量只能直接传输不能间接传输**

## 说明/提示

对于$20\%$的数据 $N \leq 10$

对于$40\%$的数据 $N\leq 25$

对于$60\%$的数据 $N\leq 50$

对于100\%的数据 $N \leq 100,M \leq 2*N,0 \leq A[i],B[i] \leq 100$

## 样例 #1

### 输入

```
3 2 
1 2 3
0 0 6
1 3
2 3
```

### 输出

```
YES
0 0 1
0 0 2
0 0 3 ```

## 样例 #2

### 输入

```
3 2 
1 2 3
0 0 7
1 3
2 3```

### 输出

```
NO```

# 题解

## 作者：小菜鸟 (赞：1)

上一篇题解还是讲得过于简单了吧...  

稍微详细一点。  

每个点可以向其他点传输能量，显然是网络流。  

同时，不能间接传输能量，  

那么考虑拆点，将一个点拆成入点和出点，点与点之间只有入点能向出点传输能量。  

这样就避免了已经被传输到出点的能量再被传到别处去。  

然后就是套路，源点向第$i$个入点连$A_i$的边，第$i$个出点向汇点连$B_i$的边，每个入点向对应的出点连$\inf$的边。  

输出方案的话，只要看看每条边上的剩余容量与原来差了多少，就知道起点向终点传输了多少能量了。   

代码可以参考  

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using std::queue;

const int N=1005,M=500005;

const int S=1003,T=1004;

int n,m;

int head[N],cur[N],level[N];

struct Edge
{
    int next,to,w,w0;
};
Edge E[M];

void __add(int u,int v,int w)
{
    static int tot=-1;
    E[++tot].next=head[u];
    E[tot].to=v;
    E[tot].w=E[tot].w0=w;
    head[u]=tot;
}
void add(int u,int v,int w)
{
    __add(u,v,w);
    __add(v,u,0);
}

bool bfs(int S,int T)
{
    memset(level,0x00,sizeof(level));
    queue<int> q;
    q.push(S);
    level[S]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];~i;i=E[i].next)
        {
            int v=E[i].to;
            if(E[i].w==0||level[v]!=0)continue;
            level[v]=level[u]+1;
            q.push(v);
        }
    }
    return level[T];
}

int dfs(int u,int flow,int T)
{
    if(u==T||flow==0)return flow;
    int res=0;
    for(int i=cur[u];~i;cur[u]=i=E[i].next)
    {
        int v=E[i].to;
        if(level[v]==level[u]+1&&E[i].w!=0)
        {
            int f=dfs(v,std::min(flow,E[i].w),T);
            if(f!=0)
            {
                res+=f;
                flow-=f;
                E[i].w-=f;
                E[i^1].w+=f;
                if(flow==0)break;
            }
        }
    }
    return res;
}

int dinic(int S,int T)
{
    int res=0;
    while(bfs(S,T))
    {
        memcpy(cur,head,sizeof(head));
        res+=dfs(S,0x7fffffff,T);
    }
    return res;
}

int in_id(int x)
{
    return x;
}

int out_id(int x)
{
    return x+n;
}

int ans[N][N];

int main()
{
    memset(head,0xff,sizeof(head));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
    {
        int x;
        scanf("%d",&x);
        add(S,in_id(i),x);
        add(in_id(i),out_id(i),0x3fffffff);
    }
    int sum=0;
    for(int i=1;i<=n;++i)
    {
        int x;
        scanf("%d",&x);
        sum+=x;
        add(out_id(i),T,x);
    }
    for(int i=0;i<m;++i)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        add(in_id(u),out_id(v),0x3fffffff);
        add(in_id(v),out_id(u),0x3fffffff);
    }
    if(dinic(S,T)!=sum)
    {
        puts("NO");
        return 0;
    }
    puts("YES");
    for(int u=1;u<=n;++u)
    {
        for(int i=head[u];~i;i=E[i].next)
        {
            int v=E[i].to;
            if(v<=n)continue;
            if(v>n*2)continue;
            v-=n;
            ans[u][v]+=E[i].w0-E[i].w;
        }
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            printf("%d ",ans[i][j]);
        }
        putchar('\n');
    }
}
```





---

## 作者：谋事在人 (赞：0)

首先我们观察数据范围， $n \leq 200$ ~~这么小的数据范围又是省选级别的感觉像网络流。~~

## 建图

初步想法：从源点像每个点连容量为 $A_i$ 的边，每个点向汇点连容量为 $B_i$ 的边。每条LINK的两个端点连容量为inf的双向边

发现初步想法中的图无法保证能量只是直接传输，所以进行改进，每个点拆成两个点（入点和出点），源点向入点连容量为 $A_i$ 的边，出点向汇点连容量为 $B_i$ 的边，每个入点向对应的出点连容量为inf的边。每条LINK的两个端点对应的入点分别向对应的出点连容量为inf的边。

这个模型中，每一条流的路径代表从入点向出点传输了流量大小的能量，每个出点向汇点的边的流量代表结束时这个点剩余的能量。

## 求最大流
套板子

## 求传输方案
如果最大流小于 $\sum_{i=1}^n b_i$ ，则一定有一个点结束时的能量小于所求 $B_i$ 。遍历所有入点向出点连的边，这条边的流量即为所求输出

## 核心代码
```
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	for(int i=1;i<=n;i++){
		addedge(s,i,a[i]);
		addedge(i+n,t,b[i]);
		sum+=b[i];
		addedge(i,i+n,inf);
	}
	for(int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		addedge(x,y+n,inf);
		addedge(y,x+n,inf);
	}
	int now=dinic();
	if(now!=sum){
		printf("NO\n");
		return 0;
	}
	printf("YES\n");
	for(int i=1;i<=n;i++){
		for(int j=head[i];j;j=e[j].nt){
			int to=e[j].to;
			if(to<=n) continue;
			if(to>n*2) continue;
			to-=n;
			ans[i][to]+=e[j^1].w;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
} 
```

---

## 作者：creed_ (赞：0)

一看就是网络流，实在没什么好讲的，挺裸的。建图后看一下最大流是否能跑满即可。写一个dinic供大家参考。
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cctype>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 1100
#define M 110000
#define inf 1e9+7
#define ll long long
using namespace std;
inline int read()
{
    int x=0,flag=1;
    char ch=0;
    while(!isdigit(ch)){ch=getchar();if(ch=='-')flag=-1;}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*flag;
}
struct edge
{
	int to;
	int nxt;
	int w;
	int flow;
}e[M*2];
int num=-1,head[N];
inline void add(int x,int y,int z)
{
	num++;
	e[num].to=y;
	e[num].nxt=head[x];
	e[num].w=e[num].flow=z;
	head[x]=num;
}
int n,m,s,t,dep[N];
queue<int>q;
bool bfs()
{
	memset(dep,0,sizeof(dep));
	dep[s]=1;q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i!=-1;i=e[i].nxt)
		{
			int to=e[i].to;
			if(!dep[to]&&e[i].w>0)
			{
				dep[to]=dep[x]+1;
				q.push(to);
			} 
		}
	}
	if(dep[t])return true;
	else return false;
}
int dfs(int x,int flow)
{
	if(x==t)return flow;
	for(int i=head[x];i!=-1;i=e[i].nxt)
	{
		int to=e[i].to;
		if(dep[to]==dep[x]+1&&e[i].w!=0)
		{
			int w=dfs(to,min(flow,e[i].w));
			if(w>0)
			{
			    e[i].w-=w;
			    e[i^1].w+=w;
			    return w;
		    }
		}
	}
	return 0;
}
int solve()
{
	int w,ans=0;
	while(bfs())
	{
		do
		{
			w=dfs(s,inf);
			ans+=w;
		}
		while(w);
	}
	return ans;
}
int ans[N][N];
int main()
{
	int x,y,i,j,tot=0,maxflow;
	n=read();m=read();
	s=2*n+10;t=2*n+11;
	memset(head,-1,sizeof(head));
	for(i=1;i<=n;i++)add(i,i+n,inf),add(i+n,i,0);
	for(i=1;i<=n;i++)x=read(),add(s,i,x),add(i,s,0);
	for(i=1;i<=n;i++)x=read(),add(i+n,t,x),add(t,i+n,0),tot+=x;
	for(i=1;i<=m;i++)
	{
		x=read();y=read();
		add(x,y+n,inf);add(y+n,x,0);
		add(y,x+n,inf);add(x+n,y,0);
	}
	maxflow=solve();
	if(maxflow!=tot)
	{
		printf("NO");
		return 0;
	}
	printf("YES\n");
	for(x=1;x<=n;x++)
	  for(int i=head[x];i;i=e[i].nxt)
	  {
	  	  int to=e[i].to;
	  	  if(!(n<to&&to<=2*n))continue;
	  	  to-=n;
	  	  if(x==to)continue;
		  ans[x][to]+=e[i].flow-e[i].w;
	  }
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
```

---


# War2

## 题目背景

`XM大战`如期而至，`Agent`们齐聚一地，展开最后的对决。对战有很多种方式，有些复杂的方式可以获得更高的分数。可惜`ENLIGHTENED`的人并不怎么聪明，只会简单的`hack`，所以`ENLIGHTENED行动指挥`找到了你来做他们的总参谋。

## 题目描述

地图上有$N$个`Portal`，现在某一名`Agent`的任务是占领该地图上的$M$个`Portal`，这名`Agent`占领第$i$个`Portal`可以得到的分数为$A[i]$，除了直接占领，还有其他的$K$种加分方式，对于着$N$个`Portal`，在占领完第$X[i]$个`Portal`后占领第$Y[i]$个`Portal`可以获得$B[i]$的加分，加分可能会有重复。`Agent`希望他可以为团队争取更多的分数，所以请求作为大战参谋的你来帮助他。

## 说明/提示

对于$20\%$的数据 $1 \leq M \leq N \leq 4,0 \leq A[i],B[i] \leq 10^3$

对于$40\%$的数据 $1 \leq M \leq N \leq 8,0 \leq A[i],B[i] \leq 10^5$

对于$60\%$的数据 $1 \leq M \leq N \leq 12,0 \leq A[i],B[i] \leq 10^7$

对于$100\%$的数据 $1 \leq M,X[i],Y[i] \leq N \leq 18,0 \leq K \leq N^2−N,0 \leq A[i],B[i] \leq 10^9$

## 样例 #1

### 输入

```
3 2 1
1 1 1
1 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
4 3 2
1 1 1 1
4 3 2
3 2 1```

### 输出

```
6```

# 题解

## 作者：HiJ1m (赞：4)

简单的状压DP，和NOIP2017 Day2 找宝藏 代码几乎一样。（比那个稍微简单一点）

f[i][j] ，i代表点的状态，j是当前选择的点，枚举上一个选到的点k 然后从f[i-(1<<(j-1))][k]转移到f[i][j]即可
方程f[i][j]=max(f[i][j],[k]+B[k][j]+A[j]); 

注意的点1.开longlong 2.数据不保证X[i]和Y[i]都不同，也不保证X[i]不等于Y[i]，这里很坑要加特判。


```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
int N,M,K;
long long f[1<<19][20],ans,A[20],B[400][400],a,b,c;
int count(int x){
    int c=0;
    while(x)c++,x&=(x-1);
    return c;
}
int main()
{
    scanf("%d%d%d",&N,&M,&K);
    for(int i=1;i<=N;i++)scanf("%lld",&A[i]);
    for(int i=1;i<=K;i++){
        scanf("%lld%lld%lld",&a,&b,&c);
        if(a==b)A[a]+=c;
        B[a][b]+=c;	
    }
    for(int i=1;i<=N;i++)f[1<<(i-1)][i]=A[i];
    for(int i=1;i<=(1<<N)-1;i++){
        for(int j=1;j<=N;j++)
        if(i&(1<<(j-1))){
            for(int k=1;k<=N;k++)
            if(i&(1<<(k-1))&&j!=k){
                f[i][j]=max(f[i][j],f[i-(1<<(j-1))][k]+B[k][j]+A[j]);	
            }
            if(count(i)==M){
                for(int j=1;j<=N;j++)
                if(i&(1<<(j-1)))ans=max(ans,f[i][j]);	
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}		

```

Blog:[Elfish.cnblogs.com](Elfish.cnblogs.com)

---

## 作者：wmy_goes_to_thu (赞：2)

这题相当的套路。

首先，$n \leq 18$ 很容易联想到状压 dp。那么设 $f_S$ 代表占领状态 $S$ 时的最大价值。但是这道题我读错题了，必须是相邻的才能计算答案，所以需要再记录一维，也就是 $f_{i,S}$，其中 $i$ 表示目前最后一个占领的是谁。转移方程式就很简单了，$f_{i,S}=a_i+\max{f_{j,{S-2^{i-1}}}+mp_{j,i}}$，其中 $mp_{j,i}$ 代表先占领 $j$ 再占领 $i$ 的额外价值。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[20];
long long mp[20][20],f[20][1<<18];
int main()
{
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	while(k--)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		mp[u][v]+=w;
	}
	for(int i=1;i<(1<<n);i++)for(int j=1;j<=n;j++)if(i&(1<<j-1))
	{
		f[j][i]=a[j];
		for(int k=1;k<=n;k++)if((i&(1<<k-1))&&j!=k)
			f[j][i]=max(f[j][i],a[j]+f[k][i^(1<<j-1)]+mp[k][j]);
	}
	long long ans=0;
	for(int i=0;i<(1<<n);i++)
	{
		int gs=0;
		long long aa=0;
		for(int j=1;j<=n;j++)gs+=(i>>j-1)&1,aa=max(aa,f[j][i]);
		if(gs==m)ans=max(ans,aa);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Chase12345 (赞：0)

这道题和 [P1171](https://luogu.com.cn/problem/P1171) 类似，$dp_{S,i}$ 表示当前在状态 $S$ 时，最后选择了第 $i$ 个点。那么枚举再上一次选择的位置 $j$，可以从$dp_{S-2^{i-1},j}$ 转移到 $dp_{S,i}$，可知方程 $dp_{S,i}=\max(dp_{S,i},dp_{S-2^{i-1},j}+B_{j,i}+a_i)$ 这里 $B_{j,i}$ 表示倒数第二次选择第 $j$ 个位置，最后一次选择第 $i$ 个位置的额外收益。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 20;
long long a[N], dp[1 << N][N], adj[N][N];

int main() {
	int n, m, k;
	long long ans = 0;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1, u, v; i <= k; i++) {
		long long w;
		cin >> u >> v >> w;
		adj[u][v] += w;
	}
	for (int i = 1; i <= n; i++)
		dp[1 << i - 1][i] = a[i];
	for (int i = 0; i < (1 << n); i++)
		for (int j = 1; j <= n; j++)
			if ((i >> j - 1) & 1)
				for (int k = 1; k <= n; k++)
					if (((i >> k - 1) & 1) && j != k)
						dp[i][k] = max(dp[i][k], dp[i ^ (1 << k - 1)][j] + adj[j][k] + a[k]);
	for (int i = 0; i < (1 << n); i++)
		if (__builtin_popcount(i) == m)          //__builtin_popcount(i)可以计算出i的二进制形式的1的个数。
			for (int j = 1; j <= n; j++)
				if ((i >> j - 1) & 1)
					ans = max(ans, dp[i][j]);
	cout << ans << '\n';
	return 0;
}
```

---


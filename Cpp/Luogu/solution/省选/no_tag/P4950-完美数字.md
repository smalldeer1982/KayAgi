# 完美数字

## 题目描述

给出两个数字集合 $S$ 和 $T$，其中元素均为 $0$ 到 $9$ 之间的整数。

定义“完美数字”为数位中包含 $S$ 中所有的数且不包含 $T$ 中任意一个数的数字。

例如，$S=\{1,3,4\}$，$T=\{7,8\}$，则 $1345$、$341166$、$4133129$ 都是完美数字，而 $13$、$8431$、$34171$ 都不是完美数字（因为 $13$ 数位中不包含 $4$，$8431$ 和 $34171$ 中虽然包含了 $1$、$3$、$4$ 这三个数但又包含 $8$ 和 $7$）。

求 $[l,r]$ 中所有完美数字的和。

## 说明/提示

### 样例解释

对于第一组样例数据，完美数字为：

$13$、$23$、$30$、$31$、$32$、$33$、$35$、$36$、$38$、$39$。

所以总和为 $310$。

### 数据范围

对于 $30\%$ 的数据，$1 \le l \le r \le 10^4$。

对于另外 $10\%$ 的数据，$n_S=n_T=0$。

对于 $100\%$ 的数据，$1 \le T \le 2000$，$1 \le l \le r \le 10^9$，$0 \le n_S,n_T \le 10$。保证 $S$ 和 $T$ 中的元素均为 $[0,9]$ 中的整数。

## 样例 #1

### 输入

```
3
11 40
1 3
2 4 7
2018 20170901
1 4
1 7
19260817 998244353
3 2 5 6
4 0 7 8 9
```

### 输出

```
310
52885750312822
2039707997741122
```

# 题解

## 作者：ycyaw (赞：3)

来一个$dfs$版的数位$dp$。

这种统计和的数位$dp$，相对于统计个数的数位$dp$，既要记录个数，又要记录和。然后对于每一位，累加个数乘以这一位位置的贡献，即百位就是个数乘以$100$，千位就是乘以$1000$，依此类推。

有一个地方被坑了好久，不能用的数字我拿数组记下来，然后在枚举当前位的时候，没有判前导零，也就是如果零不能用，前导零我就不会枚举到。~~调了一年。。~~

没有什么思维难度，考察了数位$dp$模板的掌握程度。

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
int s1,s2,nd,no,l,r,a[15],mi[15];
struct node{
    int cnt,sum;
}dp[16][1<<10];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
node dfs(int pos,int zt,int lead,int lim){
    if(!pos){
        if((zt&nd)==nd&&(zt&no)==0) return (node){1,0};
        return (node){0,0};
    }
    if(!lead&&!lim&&dp[pos][zt].sum!=-1) return dp[pos][zt];
    int mx=lim?a[pos]:9;
    node res=(node){0,0};
    for(int i=0;i<=mx;i++){
        node t;
        if(lead&&!i) t=dfs(pos-1,zt,1,lim&&(i==mx));
        else t=dfs(pos-1,zt|(1<<i),0,lim&&(i==mx));
        res.cnt+=t.cnt;
        res.sum+=t.sum+t.cnt*i*mi[pos-1];
    }
    if(!lead&&!lim) dp[pos][zt]=res;
    return res;
}
int work(int x){
    if(!x) return 0;
    int len=0;
    while(x){
        a[++len]=x%10;
        x/=10;
    }
    return dfs(len,0,1,1).sum;
}
signed main(){
    mi[0]=1;
    for(int i=1;i<=15;i++) mi[i]=mi[i-1]*10;
    int T=read();
    while(T--){
        memset(dp,-1,sizeof(dp));
        l=read(),r=read();
        nd=no=0;
        s1=read();
        for(int i=1;i<=s1;i++) nd|=1<<(read());
        s2=read();
        for(int i=1;i<=s2;i++) no|=1<<(read());
        writeln(work(r)-work(l-1));
    }
    return 0;
}
```


---

## 作者：DDF_ (赞：1)

经常写数位 DP 题有利于身体健康。

## 题面

求 $[l,r]$ 间数位中包含集合 $S$ 的所有元素却不包含集合 $T$ 的任意一元素的数字之和。

## 题解

看到大范围的计数问题首选数位 DP。

数位 DP 要判断数满不满足条件，而 $S$ 和 $T$ 在题目中不固定，所以条件总是在变换，那如何判断枚举到的数满不满足条件呢？

因为 $S$ 和 $T$ 中元素最大值不超过 $9$，所以可以考虑将这两个集合状态压缩成一个二进制数的形式。

这时就可以思考：将枚举到的数各个位出现的数集 $D$ 也进行状态压缩，再判断 $S$ 是否为 $D$ 的子集且 $T$ 和 $D$ 有没有交集就行了。

然后这个题目要求各个数字的和，我们如何来处理这个和呢？

可以考虑从各个数位出发，用 $sum$ 和 $cnt$ 记录到第 $i$ 位数集为 $D$ 的满足条件的数字数量和数字和，进行记忆化搜索。

假设说枚举到第 $i$ 位，那么可以记录假设第 $i$ 位为 $x$ 的满足条件的数字数量和方案数，那么对答案的贡献为 $sum_{i-1,D \cup x}+x \times cnt_{i-1,D \cup x} \times 10^{i-1}$。

然后注意处理前导 $0$ 和卡常，套记忆化搜索数位 DP 模板即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t;
ll E[15];
int a[15];
int p,q,n,m;
ll l,r;
struct digit {
    ll sum,cnt;
} f[15][2000];
ll read() {
    char ch=getchar();
    ll x=0;
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
    return x;
}
void write(ll x) {
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return;
}
digit dfs(int k,int d,bool lim,bool qd) {
    if(q&d) {
        digit s;
        s.sum=s.cnt=0;
        return s;
    }
    if(!k) {
        digit s;
        s.sum=0,s.cnt=(((p&d)==p)&&((q&d)==0));
        return s;
    }
    if(!lim&&!qd&&f[k][d].sum!=-1) return f[k][d];
    int end=lim?a[k]:9;
    digit x,ret;
    ret.cnt=ret.sum=0;
    for(ll i=0;i<=end;i++) {
        if(qd&&i==0) x=dfs(k-1,d,lim&&(i==end),1);
        else x=dfs(k-1,d|(1<<i),lim&&(i==end),0);
        ret.cnt+=x.cnt,ret.sum+=x.sum+i*x.cnt*E[k];
    }
    if(!lim&&!qd) f[k][d]=ret;
    return ret;
}
ll ask(ll x) {
    memset(f,-1,sizeof f);
    int cnt=0;
    while(x) a[++cnt]=x%10,x/=10;
    return dfs(cnt,0,1,1).sum;
}
void init() {
    E[1]=1;
    for(int i=2;i<=12;i++) E[i]=E[i-1]*10;
    return;
}
int main() {
    init();
    t=read();
    while(t--) {
        q=p=0;
        l=read(),r=read(),n=read(); 
        for(int i=1;i<=n;i++) p|=(1<<read());
        m=read();
        for(int i=1;i<=m;i++) q|=(1<<read());
        if(!n&&!m) write((l+r)*(r-l+1)/2);
        else write(ask(r)-ask(l-1));
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：fr200110217102 (赞：1)

## 题目大意

求$[l,r]$内各位数的组成集合包含S内所有数且不包含T内所有数的数的和。多组询问。

## 算法一

“对于前$30\%$的数据，$l,r<10^4$。”

直接暴力看区间内每个数是否符合条件。

复杂度$O(Tr)$。

## 算法二

“对于另$10\%$的数据，$|S|=|T|=0$。"

每个数都符合条件，答案就是$\sum_{i=l}^{r}i=r*(r+1)/2-l*(l-1)/2$

结合算法一可以得到$40$分。

## 算法三

正解：数位DP。

数位+状压DP。

求出$1$到$r$的答案减去$1$到$l-1$的答案即可。

先预处理得到$f[i][j][k]$：$i$位、由$j$集合组成的、最高位是$k$的数的和，和$g[i][j][k]$：同以上条件的数的个数。

统计$x$的答案时：

先把位数小于$x$的满足条件的全加上。

按位从高到低枚举，加上最高位小于当前位的所有满足条件的数的和。

#### 注意，还要加上已经确定的位数乘个数。

特判一下上界是否满足条件。

~~全是数位DP的套路~~

复杂度$O(t*10*2^{10}*len)$

代入算一下，$2*10^{8}$。

好像$TLE$了？？

$|S|$或者$|T|$只要有一个不为空，就只有少于$512$种集合满足条件了！

#### 于是特判$|S|=|T|=0$的情况，输出算法二的答案，其他时候用算法三，~~卡卡常~~就过了。

## 标程

```
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
typedef long long ll;
inline int read(){
	int res=0;char c=getchar(),f=1;
	while(c<48||c>57){if(c=='-')f=0;c=getchar();}
	while(c>=48&&c<=57)res=(res<<3)+(res<<1)+(c&15),c=getchar();
	return f?res:-res;
}

int t,k,S,T,p[11];
int l,r,g[11][1024][10],sumg[11][1024];
ll f[11][1024][10],sumf[11][1024];
ll dp(int x){
	int h=0,d[11];
	ll res=0;
	while(x)d[h++]=x%10,x/=10;
	for(int i=0;i<h-1;++i)
		for(int j=0;j<1024;++j)
			if((j&S)==S&&!(j&T))
				for(int k=1;k<10;++k)
					res+=f[i][j][k];
	int now=0,num=0;
	for(int i=h-1;~i;--i){
		for(int j=0;j<1024;++j)
			if(((now|j)&S)==S&&!((now|j)&T))
				for(int k=i==h-1?1:0;k<=(i==0?d[i]:d[i]-1);++k)
					res+=f[i][j][k]+(ll)g[i][j][k]*num;
		now|=1<<d[i],num+=p[i]*d[i];
	}
	return res;
}

int main(){
	p[0]=1;
	for(int i=1;i<10;++i)p[i]=p[i-1]*10;
	for(int i=0;i<10;++i){
		f[0][1<<i][i]=i;
		g[0][1<<i][i]=1;
	}
	for(int i=0;i<10;++i)
		for(int j=0;j<1024;++j){
			for(int k=0;k<10;++k){
				sumf[i][j]+=f[i][j][k];
				sumg[i][j]+=g[i][j][k];
			}
			for(int k=0;k<10;++k){
				f[i+1][j|(1<<k)][k]+=sumf[i][j]+(ll)sumg[i][j]*p[i+1]*k;
				g[i+1][j|(1<<k)][k]+=sumg[i][j];
			}
		}
	
	t=read();
	while(t--){
		l=read(),r=read();
		S=T=0;
		k=read();
		while(k--)S|=1<<read();
		k=read();
		while(k--)T|=1<<read();
		if(!S&&!T){
			printf("%lld\n",(ll)r*(r+1)/2-(ll)l*(l-1)/2);
			continue;
		}
		printf("%lld\n",dp(r)-dp(l-1));
	}
}
```

$Update$(2018.10.22)

还可以通过前缀和优化到$O(t*10*2^{10})$

特判可以不用了。而且$T$可以出到$5000$

```
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
typedef long long ll;
inline int read(){
    int res=0;
    char c=getchar(),f=1;
    while(c<48||c>57){if(c=='-')f=0;c=getchar();}
    while(c>=48&&c<=57)res=(res<<3)+(res<<1)+(c&15),c=getchar();
    return f?res:-res;
}

int t,k,S,T,p[11];
int l,r,g[11][1024][10];
ll f[11][1024][10];
ll pref[11][1024][10],preg[11][1024][10];
ll dp(int x){
    int h=0,d[11];
    ll res=0;
    while(x)d[h++]=x%10,x/=10;
    for(int i=0;i<h-1;++i)
        for(int j=0;j<1024;++j)
            if((j&S)==S&&!(j&T))
                res+=pref[i][j][9]-f[i][j][0];
    int now=0,num=0;
    for(int i=h-1;~i;--i){
        for(int j=0,k;j<1024;++j)
            if(((now|j)&S)==S&&!((now|j)&T)){
                if(i==h-1)res-=f[i][j][0]+(ll)g[i][j][0]*num;
                k=i==0?d[i]:d[i]-1;
                if(~k)res+=pref[i][j][k]+(ll)preg[i][j][k]*num;
            }
        now|=1<<d[i],num+=p[i]*d[i];
    }
    return res;
}

int main(){
    p[0]=1;
    for(int i=1;i<10;++i)p[i]=p[i-1]*10;
    for(int i=0;i<10;++i){
        f[0][1<<i][i]=i;
        g[0][1<<i][i]=1;
    }
    for(int i=0;i<10;++i)
        for(int j=0;j<1024;++j){
            for(int k=0;k<10;++k){
                pref[i][j][k]=f[i][j][k];
                preg[i][j][k]=g[i][j][k];
                if(k){
                    pref[i][j][k]+=pref[i][j][k-1];
                    preg[i][j][k]+=preg[i][j][k-1];
                }
            }
            for(int k=0;k<10;++k){
                f[i+1][j|(1<<k)][k]+=pref[i][j][9]+(ll)preg[i][j][9]*p[i+1]*k;
                g[i+1][j|(1<<k)][k]+=preg[i][j][9];
            }
        }

    t=read();
    while(t--){
        l=read(),r=read();
        S=T=0;
        k=read();
        while(k--)S|=1<<read();
        k=read();
        while(k--)T|=1<<read();
        if(!S&&!T) {
            printf("%lld\n",(ll)r*(r+1)/2-(ll)l*(l-1)/2);
            continue;
        }
        printf("%lld\n",dp(r)-dp(l-1));
    }
}
```

## 算法四

预处理所有集合的答案（然而好像出了点锅？）

详见[2017sjb的博客](https://www.luogu.org/blog/shanjingbo0221/T2-solution)


---


# 毒瘤之神TM菱树-①

## 题目背景

本题图片可能较大请耐心加载

什么?菱树是什么??

好吧这个是蒟蒻自己搞事搞的一个非常简单的不是树但很像树的图..

就像这样..

![菱树](https://i.loli.net/2018/10/07/5bba0e85cbc10.png)

(好吧图有点大(空旷)..)

## 题目描述

现在给你一棵无限大的菱树(就是下面不止上面的图那么点大..)

然后有$T$组询问,每一组询问都是给出$u$和$v$,求出这两个点的最短路径的长度..

## 说明/提示

${\rm Subtask\ 1(10\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 100$

${\rm Subtask\ 2(20\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 10^3$

${\rm Subtask\ 3(30\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 10^5$

${\rm Subtask\ 4(40\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 10^{18}$

## 样例 #1

### 输入

```
3
1 1
5 10
6 7
```

### 输出

```
0
7
9
```

# 题解

## 作者：Sooke (赞：14)

### 解题思路

把所谓的“菱树”转一下，我们就从一个类似**树**的玩意儿得到了一个类似**网格图**的玩意儿。

![](https://i.loli.net/2018/11/23/5bf77f9df1368.png)

同时，有很多有趣的性质可以利用。

---

#### 性质一：任意两点的最短路走的边数也最少。

或者说，最短路走边的方向不超过两种。如果有三种及以上，一定是在网格图上绕了远路，这与最短路的定义矛盾。

也许你会问：这网格图有边权的啊？绕路说不定更优吗？

的确，但这题很特殊，离 $1$ 号点越远的边边权越大，这意味着绕路的边权总和大于直接走的边权总和。

---

#### 性质二：最短路一定先向 $1$ 号点靠近，再远离 $1$ 号点。

首先，性质一告诉我们最短路走边的方向不超过两种，而任意选择两个点，具体的一两种方向我们是可以计算出的。

那既然方向已知，又因为离 $1$ 号点越远的边边权越大，先靠近 $1$ 号点，再远离 $1$ 号点也就不难想了。

---

#### 性质三：设 $u$ 在 $(x_u,\ y_u)$（网格图的第 $x_u$ 行第 $y_u$ 列），$v$ 在 $(x_v,\ y_v)$，靠近、远离 $1$ 号点的转折点在 $(min\{x_u,\ x_v\},\ min\{y_u,\ y_v\})$。

结合前面的性质多画画图感性理解就好了。

---

#### 性质四：点 $u\ (u > 1)$ 到 $1$ 号点的距离 $= C_{x_u + y_u - 1}^{2}$

点 $u$ 在树中深度 $= x_u + y_u - 1$，连向父亲的边权自然 $= x_u + y_u - 2$，然后小学奥数算等差数列和。

---

#### 性质五：点 $u,\ v$ 的最短路 $= C_{x_u + y_u - 1}^{2} + C_{x_v + y_v - 1}^{2} - 2C_{min\{x_u,\ x_v\} + min\{y_u,\ y_v\} - 1}^{2}$

把到 $1$ 号点的路径理解为"前缀和"，结合性质三、四思考。

---

有了这些性质，大致的思路应该也有了吧？

最后，怎么知道 $u$ 在网格图上的位置呢？

满足 $x_u + y_u - 1 = 1$ 的结点只有 $1$ 个，满足 $x_u + y_u - 1 = 2$ 的结点有 $2$ 个，满足 $x_u + y_u - 1 = 3$ 的结点有 $3$ 个……貌似很有规律。可以二分 $x_u + y_u - 1$ 的值，当然也可以解二次方程 $O(1)$ 算出。

然后？这道题就做完了。

---

## 作者：木木！ (赞：2)

首先可以发现菱树上的最短路一定是尽量向上走再尽量向下走的。证明很感性，因为如果有一条路径包含向下再向上的一段，那么这一段一定可以翻折上去，总距离更小，而且一定不会翻过顶点。

于是，两个节点间的路径长度就可以由他们的“LCA”所在的层数进行一个等差数列求和简单算出。这里的 LCA 指两个节点都尽量往对方走和上面走，走到最上面的相会点。

为了方便叙述，我们用 $c_i,p_i$ 表示一个点，层数 $c_i$ 表示在第几层，位置 $p_i$ 表示从左往右数是第几个。

可以发现，通过走菱树上的边，在不考虑越界的前提下，一个 $c_i,p_i$ 的点可以走到 $c_i-1,p_i$ 和 $c_i-1,p_i-1$。那么，一个点向上走到第 k 层能到达的点的位置 $p \in [\max(p_i-c_i+k,1),\min(p_i,k)]$。

那么就可以按照两个点的位置进行分类讨论计算 LCA（假设 $c_x\leq c_y$ ）：

+ $p_x>p_y$，逼近的职责由 x 承担，则他们的 LCA 层数为 $c_x-(p_x-p_y)$。
+ $c_y-(p_y-p_x)\geq c_x$，他们的 LCA 就是 x，层数为 $c_x$。
+ 其他情况，他们的 LCA 层数为 $c_y-(p_y-p_x)$。

剩余的问题就是如何算一个给定点的层数和位置了。这里我选择了二分层数的方法，时间复杂度 $\Theta(t\log \sqrt{w})=\Theta(t\log w)$，其中 $w$ 是值域。

需要注意的是，二分的右边界不能设置成 $1\times 10^9$。我这里设置成了 $2\times 10^9$。

附 AC 代码：

```cpp
#include <tuple>
#include <cstdio>
using namespace std;

pair<long long,long long> getcod(long long x)
{
	long long l = 1;
	long long r = 2000000000;
	while(l<r)
	{
		long long mid = (l+r)>>1;
		if(mid*(mid+1)/2 >= x)
			r = mid;
		else
			l = mid+1;
	}
	return make_pair(l,x-l*(l-1)/2);
}

long long sum(long long l,long long r)
{
	return r*(r+1)/2 - l*(l-1)/2;
}

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		long long x,y;
		scanf("%lld%lld",&x,&y);
		
		long long xl,yl,xs,ys;
		tie(xl,xs) = getcod(x);
		tie(yl,ys) = getcod(y);

		if(xl > yl) swap(xl,yl),swap(xs,ys);

		if(xs > ys) printf("%lld\n",sum(xl-(xs-ys),xl-1)+sum(xl-(xs-ys),yl-1));
		else if(yl-(ys-xs) >= xl) printf("%lld\n",sum(xl,yl-1));
		else printf("%lld\n",sum(yl-(ys-xs),yl-1)+sum(yl-(ys-xs),xl-1));
	}
}
```

---

## 作者：114514xxx (赞：1)

## 思路
注意到 $u_i$ 和 $v_i\in[1,10^{18}]$ ，复杂度应该为 $O(\log n)$ 或者 $O(1)$ 的。

我们可以发现任意两点的最短路径一定会从深度更大的点向深度更低的点走得到的。设现在要求 $u$ 和 $v$ 两个点的最短路径，$d_u$ 表示 $u$ 在第几层。$d_u$ 可以 $O(\log n)$ 内求出。

当 $d_u=d_v$ 时，很显然答案就是 $u$ 和 $v$ 两个点的“最近公共祖先”。根据图可以得到其路径长为 $\displaystyle \sum^{d_u}_{x=d_u-|u-v|}x$，这显然是可以 $O(1)$ 进行计算的。

当 $d_u\ne d_v$ 时，不妨设 $d_u>d_v$。这时也分为两种情况。其一是存在一条最短路径使得 $u$ 和 $v$ 可以不用通过 $v$ 上面的点。这种情况的答案即为 $\displaystyle\sum^{d_u}_{x=d_v}x$，这也可以 $O(1)$ 求出。

其二是 $u$ 和 $v$ 的最短路径一定要通过 $v$ 上方的点。这时就可以类似 LCA 的求法，现将 $u$ 跳至和 $v$ 同一层，这时经过的路径长也是 $\displaystyle\sum^{d_u}_{x=d_v}x$，进而再利用 $d_u=d_v$ 的求法，得到最后的路径长。

至于如何判别 $d_u\ne d_v$ 的两种情况也很简单。设 $l_u$ 和 $r_u$ 为 $u$ 这层的最左和最右的两个点，那么 $u$ 能不通过 $v$ 上方的点调到 $v$ 这层的点的范围即为 $[\max(l_v,l_v+u-l_u-(d_u-d_v)),\min(r_v,r_v+u-r_u+(d_u-d_v))]$，若 $v$ 在这个范围内就是情况一，不在就是情况二。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
inline int query(int u){
    if(u==1){return 0;}
    int r=2e9+25,l=0;
    while(l<r){
        int mid=(l+r+1)>>1;
        int middep=(mid*(mid+1))>>1;
        if(middep>u)r=mid-1;
        else l=mid;
    }
    if(((l*(l+1))>>1)==u){return (l-1);}
    return l;
}//求解深度
inline int calc(int l,int r){
    return ((r)*(r+1)>>1)-(l*(l+1)>>1);
}//O(1)计算
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>t;
    int u,v;
    while(t--){
        cin>>u>>v;
        if(u==v){cout<<0<<endl;continue;}
        int depu=query(u);
        int depv=query(v);
        if(depu<depv)swap(u,v),swap(depu,depv);
        int fa1=0;
        int len=0;
        len=calc(depv,depu);
        int lunode=(((depu)*(depu+1))>>1)+1;
        int runode=((depu+1)*(depu+2))>>1;
        int lvnode=(((depv)*(depv+1))>>1)+1;
        int rvnode=(((depv+1)*(depv+2))>>1);
        int rpos=runode-u;
        int lpos=u-lunode;
        int r=min(rvnode-rpos+(depu-depv),rvnode);
        int l=max(lvnode,lvnode+lpos-(depu-depv));
        if(l<=v&&v<=r){cout<<len<<endl;continue;}//情况一
        int ans=min(abs(v-r),abs(v-l));
        int path=calc(depv-ans,depv)*2;
        cout<<len+path<<endl;//情况二
    }
}

```

---

## 作者：Register_int (赞：1)

首先把菱树转一下，就可以发现他是个网格图。  
接下来考虑求出每个点在网格图里的坐标。由于菱树的性质，可以通过二分三角形数来确定层。接着再通过计算这个点在该层的第几个，就可以算出坐标。  
最后是算最短距离。假设点 $i$ 的坐标为 $x_i,y_i$，在网格图中的深度为 $l$。容易发现 $l_i=x_i+y_i-1$。那么，一个点到根的最短距离就是
$$dis(1,i)=\sum^{l_i-1}_{x=1}x=\binom{l_i}2=\binom{x_i+y_i-1}2$$
之后假设这两点都会先经过点 $d$ 再到达点 $1$，那么显然
$$dis(i,j)=dis(1,i)+dis(1,j)-2dis(1,d)$$
也就是说，要使 $dis(1,d)$ 尽量大。结合网格图的性质，我们可以得出
$$d=(\min(x_i,y_i),\min(x_j,y_j))$$
直接计算即可。  
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline 
ll c2(ll n) {
	return n * (n - 1) >> 1;
}

inline 
void calc(ll k, ll &x, ll &y) {
	ll l = 1, r = 1e9, mid, t;
	while (l < r) {
		mid = l + r >> 1;
		if (c2(mid + 1) < k) l = mid + 1;
		else r = mid;
	}
	t = c2(l + 1) - k;
	x = l - t, y = t + 1;
}

inline 
ll dis(ll ax, ll ay, ll bx, ll by) {
	return c2(ax + ay - 1) + c2(bx + by - 1) - 2 * c2(min(ax, bx) + min(ay, by) - 1);
}

int t;

ll u, v;

ll ax, ay, bx, by;

int main() {
	for (scanf("%d", &t); t--;) {
		scanf("%lld%lld", &u, &v);
		calc(u, ax, ay), calc(v, bx, by);
		printf("%lld\n", dis(ax, ay, bx, by));
	}
}
```

---

## 作者：toolazy (赞：0)

~~这题不黄？~~ 我是来蹭社贡的，发现题解没满就过来捡漏（大嘘

---

数据范围在 long long，一眼就是数学题。

在简单~~瞪样例~~手玩后，应该可以发现性质：

1. 最优路径要么是一个倒 V 字形（$\land$），将两点链接；

    ```
    ......1.......
    ...../.\......
    ....2...3.....
    .../.\./.\....
    ..4...5...6...
    ./.\./.\./.\..
    7...8...9...10
    ```

    如样例的 $(5,10)$，它的答案一定是『$5$ 先向上爬到 $3$，$3$ 再向下走到 $10$』，答案是 $2+2+3=7$；

    又如 $(6,7)$，肯定是『$7$ 先向上爬到 $1$，$1$ 再向下走到 $6$，答案是 $3+2+1+1+2=9$。

    正确性显而易见，~~所以建议黄了~~，但是如果题解不证明是会被打回去的，所以浅浅来一个：

    - 命题 $1$：往上走一定比往下好（V 字比 $\land$ 字更劣）。

        ```
        .../\...
        ../..\..
        .o....o.
        ..\../..
        ...\/...
        ```

        证明：下面边权明显更大，而且，但就边的数量而言，不可能更少，所以求和项数不变，每一项更大，答案势必更劣。

    - 命题 $2$：往上走，$\land$ 字一定比 M 字更好。

        ```
        ...../\.....
        ..../..\....
        .../\../\...
        ../..\/..\..
        .o........o.
        ```

        证明：边的数量不变，而位置越浅越优，$\land$ 不浪费边爬升，故势必更优。

    - 命题 $3$：往上走，$\land$ 字一定比 R 字（指爬得更高，然后往下，然后往内拐）更好。

        证明：自己动手画画图，从 $\land$ 的顶部画一条水平线：

        ```
        ...........o......
        ........../.\.....
        ........./...\....
        ......../.....o
        ......./...../...
        ~~~~~~A~~~~~B~~~~
        ...../.\.../.....
        ..../...\./......
        .../.....C.......
        ../.......\......
        .o.........o.....
        ```

        发现 $AC=BC$，所以水平线上面的都是多余的，所以 R 字明显亏。
        
2. 要么，就只要考虑让低点一个劲往上爬就好。

	```
    ......o......
    ...../.\.....
    ....o...A....
    .../.\./.\...
    ..o...C...D..
    ./.\./.\./.\.
    o...o...B...o
    ```
    
    这时候，$B$ 只要随便走 $B\rarr C\rarr A$ 或者 $B\rarr D\rarr A$ 就都是 $AB$ 的最短路。

	这个的证明就简单很多了，反正只要保证每一层都不会重复走，就势必最优，反正你又不能传送，再少再少也少不了了。
    
差不多就结束了。以及，如果还想多水一道紫，其实这里还有[第二部](https://www.luogu.com.cn/problem/P4976)。

---

## 作者：Erica_N_Contina (赞：0)

## 思路

首先看数据范围，一眼确定是性质题。

这就是一个推性质的题目啊。

如果直接观察原图，我们也许是可以看出一些性质的：

- 在经过的边数相同的情况下，选择靠近 $1$ 号点的路径一定是最短的。

- 如果 $v$ 在 $u$ 的左侧，那么相对 $u$ 而言路径一定不可能向右拐弯。

那么结合一下这两条性质，我们就可以直接出下面的走法：（我们假设 $v$ 在 $u$ 的左侧）

我们从 $v$ 开始向右上方画一条射线，从 $u$ 开始向左上方画一条射线，相交于点 $f$。那么 $v-f$ 的线段和 $f-u$ 的线段就是 $u-v$ 的最短路径。

好了，现在我们再来考虑计算的问题。对于计算，我们可以将原图变换为一个横平竖直的网格图（图片可以参考 Sooke 大佬的图），将每个点编号为 $(x,y)$。


那么现在设 $u(x_1,y_1),v(x_2,y_2)$，很容易得出 $f(\min(x_1,x_2),\min(y_1,y_2))$。至于 $u-f,f-v$ 路径上的权值和，我们通过一个等差数列即可计算出。以 $(x_i,y_i)-(x_j,y_i)$ 为例，即 $x_i+(x_i+1)+\dots+(x_i+k)+\dots+x_j(x_i<x_j)$。在实际代码中，这个也可以通过两个等差数列相减得到。

现在唯一的问题就是如何将题目中给出的标号 $u$ 转化为 $(x,y)$ 的形式了。这个我们可以通过二分的形式得到，我们观察原图可以发现每一行的点数成 $1,2,3,\dots$ 关系。同时，每一行的点数都满足 $x+y$ 相同。这就好办了，我们先二分找到 $u$ 对应原图中在哪一行，计算出 $u$ 在这一行中的第几个后就可以得出其 $x,y$ 了。

---

```C++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define ps second
#define pf first
 
 
#define rd read()
inline int read()
{
	int xx=0,ff=1;
	char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') ff=-1;c=getchar();}
	while(c>='0'&&c<='9') xx=xx*10+(c-'0'),c=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N = 2e6+6;
const int INF=1e9+5;
const int MOD=998244353;
int n,m,k;
int ans=INF;

int cal(int x){
	return x*(x-1)/2;
}

signed main(){
	int T=rd;
	while(T--){
		int u=rd,v=rd;
		int x,xx,y,yy;

		int l=1,r=INF;
		while(l<r){
			int mid=l+r>>1;
			if(cal(mid+1)<u)l=mid+1;
			else r=mid;
			int t=cal(l+1)-u;
			x=l-t,y=t+1;
		}

		l=1,r=INF;
		while(l<r){
			int mid=l+r>>1;
			if(cal(mid+1)<v)l=mid+1;
			else r=mid;
			int t=cal(l+1)-v;
			xx=l-t,yy=t+1;
		}

		cout<<cal(x+y-1)+cal(xx+yy-1)-cal(min(x,xx)+min(y,yy)-1)*2<<endl;
	}
}
```




---


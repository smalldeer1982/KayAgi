# 毒瘤之神TM菱树-②

## 题目背景

什么?菱树是什么??

好吧这个是蒟蒻自己搞事搞的一个非常简单的不是树但很像树的图..

就像这样..

![菱树](https://i.loli.net/2018/10/07/5bba0e85cbc10.png)

(好吧图有点大(空旷)..)

## 题目描述

现在给你$T$棵菱树,每一颗菱树的层数为$n_i$,请求出菱树中所有点对的最短路径的和..

## 说明/提示

${\rm Subtask\ 1(10\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 10$

${\rm Subtask\ 2(20\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 100$

${\rm Subtask\ 3(30\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 1000$

${\rm Subtask\ 4(40\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 5*10^6$

为了防止打表，所以空间限制缩小至64MB。

## 样例 #1

### 输入

```
5
1
2
3
4
5```

### 输出

```
0
4
43
225
812
```

# 题解

## 作者：NaCly_Fish (赞：14)

根据 NOI2019 的教训，在做数学题时一定要试着插值一下，说不定答案是个低次多项式呢？ 

而这题就是这样，随便写个暴力跑一下，再写个插值，发现答案是个关于 $n$ 的一个 $6$ 次多项式。然后写出前面 $7$ 项，然后暴力插值一波就过了。

至于证明，题目中答案相关的地方没有出现形如 $n^k$ 之类的式子，所以答案肯定是关于 $n$ 的低次多项式对吧，，感性理解一下就好。

关于怎么插值，这里要用到点值 $x$ 坐标连续时的高效做法，如果不会可以来 [这题](https://www.luogu.org/problem/P5437) 看看（ 

时间复杂度 $\Theta(T)$，标算为 $\Theta(T+n)$，吊打std（

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
#define reg register
#define p 998244853
#define K 20
using namespace std;

inline void read(int &x){
	x = 0;
	char c = getchar();
	while(c<'0'||c>'9') c = getchar();
	while(c>='0'&&c<='9'){
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
}

void print(int x){
	if(x>9) print(x/10);
	putchar(x%10+'0');
}

inline int power(int a,int t){
	int res = 1;
	while(t){
		if(t&1) res = (ll)res*a%p;
		a = (ll)a*a%p;
		t >>= 1;
	}
	return res;
}

inline int add(int a,int b){
	return a+b>=p?a+b-p:a+b;
}

inline int dec(int a,int b){
	return a<b?a-b+p:a-b;
}

const int a[8] = {0,0,4,43,225,812,2324,5670};
int pre[K],suf[K],ifac[K];

inline int solve(int n){
	if(n<8) return a[n];
	int res = 0,g;
	pre[0] = suf[8] = 1;
	for(reg int i=1;i<8;++i) pre[i] = (ll)pre[i-1]*(n-i)%p;
	for(reg int i=7;i>=1;--i) suf[i] = (ll)suf[i+1]*(n-i)%p;
	for(reg int i=1;i<8;++i){
		g = (ll)a[i]*ifac[i-1]%p*ifac[7-i]%p*pre[i-1]%p*suf[i+1]%p;
		if((7-i)&1) res = dec(res,g);
		else res = add(res,g);
	}
	return res;
}

int main(){
	ifac[0] = ifac[1] = 1;
	for(reg int i=2;i<K;++i) ifac[i] = (ll)ifac[i-1]*i%p;
	ifac[K-1] = power(ifac[K-1],p-2);
	for(reg int i=K-2;i>1;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
	int T,n;
	read(T);
	while(T--){
		read(n);
		print(solve(n));
		putchar('\n');
	}    
    return 0;
}
```

---

## 作者：CYJian (赞：8)

#### $Subtask 1$

感觉不必多说..暴力建图$+Floyd(O(N^6)) / Dijkstra(O(N^4 \times log_2N^2))$拿走你的$10$分..

#### $Subtask 2$

也不必多说..把$T4$的正解偷过来暴力算每一个点的距离即可。。

复杂度$O(N^4)$。兴许$Dijkstra$也能跑过。。

#### $Subtask 3$

到这里就需要一些推理了。。

首先我们发现菱树一个性质：每一层的边权相等。

所以我们可以考虑直接计算每一层的贡献。

这样的话我们就分为两种情况：

第一种是在图中选择的两个点一个在这一层的下方，一个在这一层的上方。

根据$T4$的最短路的结论，我们可以推断出这种情况只可能通过这一层一次。

第二种是两个点都在这一层的下方。

这样一上一下，肯定要经过两次。

那么考虑直接计算贡献。

首先第一种的方案非常好求。就是这一层上面的节点个数$\times$下面的节点个数。转化为式子就是:

$$ \frac{i \times (i+1)}{2} \times (\frac{n \times (n + 1)}{2} - \frac{i \times (i+1)}{2}) $$

然后计算答案就乘上一个$i$就好了。

第二种的话。。

首先可以多画几个草图，发现需要满足右边的点到这一层的距离需要大于或等于左边的点与右边的点在该层从左往右数的相对位置的差。

事实上如果推出了$T4$的三种情况，那这个还是挺好想到的。

那么这样的话我们就考虑枚举左边的点。然后右边可以选择的点就是一个公差为$(n-i)$的等差数列。然后左边每一列的点一共有$(n-i)$个，则可以得到方案数为：

$$(n-i)^2 \times \frac{i \times (i+1)}{2}$$

然后由于需要一上一下，所以答案需要乘上一个$2 i$。

综上所述，最后的答案就是

$$\sum_{i=1}^{n-1}( \frac{i \times (i+1)}{2} \times (\frac{n \times (n + 1)}{2} - \frac{i \times (i+1)}{2}) \times i + (n-i)^2 \times i ^ 2 \times (i+1))$$

复杂度$O(N^2)$

#### $Subtask 4$

还是用上面的式子。~~也许~~可以化简一下变成$O(N)$

我们把它拆分一下:

$$\frac{n \times (n + 1)}{2} \times \sum_{i=1}^{n-1}(\frac{i \times (i+1)}{2} \times i) - \sum_{i=1}^{n-1} ((\frac{i \times (i+1)}{2})^2 \times i) + \sum_{i=1}^{n-1} (n^2-2\times i \times n +i^2) \times i ^ 2 \times (i+1))$$

$$= \frac{n \times (n + 1)}{2} \times \sum_{i=1}^{n-1}(\frac{i \times (i+1)}{2} \times i) - \sum_{i=1}^{n-1} ((\frac{i \times (i+1)}{2})^2 \times i) + n ^ 2 \times \sum_{i=1}^{n-1} (i ^ 2 \times (i + 1)) - 2\times n \times \sum_{i=1}^{n-1} (i ^ 3 \times (i+1)) + \sum_{i=1}^{n-1}(i ^ 4 \times (i+1))$$

然后发现所有$\sum$里面的东西都可以$O(N)$递推，所以答案也可以$O(N)$递推了。

---

## 作者：AquaRio (赞：6)

楼上的题解说得都很详细了，我来补充一波怎么递推那个~~毒~~瘤式子。

首先可以想到开5个数组分别记录每个$\sum$里的值，但是我们发现会$MLE$，怎么办呢?

其实我们可以不用开数组。

维护一个 $temp$ 表示$\sum$的前缀和，然后我们发现 $i$ 的前缀和只会对 $ans[i+1]$ 产生贡献。

所以我们只需要开一个 $ans$ 数组就可以啦！记得开 $long\ long$ 哦。（~~我不会告诉你我因为没开longlong调了一个晚上~~）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

const int N=5e6+5;
const long long mod=998244853LL;

unsigned long long  ans[N+10];

signed main(){
	long long temp=0;
	for(int i=1;i<=N-1;i++){
		temp=( temp + 1LL*i * ( i + 1 ) / 2 % mod * i % mod ) % mod ;
		ans[i+1] = ( ans[i+1] + 1LL*( i+1 ) * ( i + 2 ) / 2 % mod * temp % mod ) % mod ;	
	}
	
	temp=0;
	for(int i=1;i<=N-1;i++){
		temp=( temp + 1LL*i * ( i + 1 ) / 2 % mod * ( i * ( i + 1 ) / 2 % mod ) % mod * i % mod ) % mod ;
		ans[i+1] = 1LL*( ans[i+1] + mod - temp ) % mod ;	
	}

	temp=0;
	for(int i=1;i<=N-1;i++){
		temp=( temp + 1LL*i * ( i + 1 ) % mod * i % mod ) % mod ;
		ans[i+1] = ( ans[i+1] +1LL* ( i + 1 ) * ( i + 1 ) % mod * temp % mod ) % mod ;	
	}
	
	temp=0;
	for(int i=1;i<=N-1;i++){
		temp=( temp + 1LL*i * ( i + 1 ) % mod * i % mod * i % mod ) % mod ;
		ans[i+1] = ( ans[i+1] + mod - 1LL*2 * ( i + 1 ) % mod * temp % mod ) % mod ;	
	}
	
	temp=0;
	for(int i=1;i<=N-1;i++){
		temp=( temp + 1LL*i *1LL* ( i + 1 ) % mod *1LL* i % mod * i % mod * i % mod ) % mod ;
		ans[i+1] = ( ans[i+1] + 1LL* temp % mod ) % mod ;	
	}

	int t=read();
	while(t--){
		int n=read();
		printf("%d\n",ans[n]);
	}
	return 0;
}
 
 ```

---

## 作者：Melo_qwq (赞：1)

大家好，我是 Melo_DDD，我非常喜欢使用非正解，于是我用拉格朗日插值法过了这一题（雾）。

前置芝士：拉格朗日插值法，不会请自行移步。

现有的那篇拉插的题解讲的很好了，但是给人一种拉插是玄学方法的感觉？所以我将尽己所能把它解释成人类智慧而不是算卦（大佬轻喷）。

### 什么是拉插

根据简单的~~小学~~基础知识，只要拥有三个不同点，我们就可以唯一确定一个二次函数。

类似地，当我们拥有一些离散数据的时候，我们可以通过插值近似的还原出原函数，并且根据拉插出的原函数求出其定义域上任意一点的函数值。

### 怎么拉插

相信大家已经对拉插有了足够的了解，所以我直接放公式了：

$$f_i(x)=\frac{\displaystyle\prod_{j\ne i}(x-x_j)}{\displaystyle\prod_{j\ne i}(x_i-x_j)}$$

$$f(x)=\sum_{i=1}^{n}y_i\times f_i(x)$$

也就是说，我们只要知道若干个 $x_i$ 以及他们对应的函数值，就可以愉快地拉插了。

此时去拟合一个函数，如果是多项式函数、整数取模的情况应该不会有误差（可能描述地有点迷）。

### 敲黑板：为什么这道题可以拉插

我们发现对于每一层，所有的点和边以及边权都是固定的，显然，当我们知道了这个菱树的层数时，它的所有点对的最短路径和也就相应地确定下来。换言之，一种层数对应一个答案。也就是说，**层数和答案满足函数关系**。那么拉插就具有正确性。

既然满足函数关系，找几个层数，求出答案直接拉插，层数可以当做横轴，答案当做纵轴。

具体怎么求，可以~~直接把样例给的点复制下来~~写一个暴力程序，跑几层看看答案，这里我跑了 $1$ 到 $7$ 层的所有答案。

我的暴力代码，可以自己看看连边部分：

```cpp
// 这份代码有一点太暴力了
// 其实 dij 暴力的第二维完全可以省去
// 反正是类似于打表性质的代码，在加上我懒得优化（，就这样吧 
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 100 ; 
int head[N << 1] ,tot ,dis[N] ;
bool vis[N] ;
struct edge {
	int to ,nxt ,val ;
} e[N << 1] ;
inline void add (int u ,int v ,int w) {
	e[++ tot].nxt = head[u] ;
	head[u] = tot ;
	e[tot].to = v ;
	e[tot].val = w ;
}
inline void dij (int x) {
	memset (dis ,0x3f ,sizeof dis) ;
	memset (vis ,false ,sizeof vis) ;
	dis[x] = 0 ;
	priority_queue < pair < int ,int > > q ;
	q.push (make_pair (dis[x] ,x)) ;
	while (! q.empty ()) {
		int cur = q.top ().second ;
		q.pop () ;
		if (vis[cur]) 
			continue ;
		vis[cur] = true ;
		for (int i = head[cur] ;i ;i = e[i].nxt) {
			int nex = e[i].to ;
			if (dis[nex] > dis[cur] + e[i].val) {
				dis[nex] = dis[cur] + e[i].val ;
				q.push (make_pair (- dis[nex] ,nex)) ;
			}
		}
	}
}
int main () {
	f (_ ,1 ,7 ,1) {
		cout << _ << '\n' ;
		memset (head ,0 ,sizeof head) ;
		tot = 0 ;
		f (i ,1 ,_ - 1 ,1) {
			f (j ,(1 + (i - 1)) * (i - 1) / 2 + 1 ,(1 + i) * i / 2 ,1) {
				f (k ,(1 + i) * i / 2 + 1 ,(1 + (i + 1)) * (i + 1) / 2 ,1) {
					int num = j - (1 + (i - 1)) * (i - 1) / 2 ;
					if (k == (1 + i) * i / 2 + num || k == (1 + i) * i / 2 + num + 1) {
						add (j ,k ,i) ,add (k ,j ,i) ;
					}
				}
			}
		}
		int ans = 0 ;
		f (i ,1 ,(1 + _) * _ / 2 ,1) {
			f (j ,1 ,(1 + _) * _ / 2 ,1) {
				if (i == j) 
					continue ;
				dij (i) ;
				ans += dis[j] ;
			}
		}
		ans >>= 1 ; 
		cout << ans % 998244853 << '\n' ;
	}
	return 0 ;
}

```
我们跑出来了层数与答案的对应关系是：
```
1 0
2 4
3 43
4 225
5 812
6 2324
7 5670
```
用这 $7$ 个点拉插就可以了。


```cpp
#include <bits/stdc++.h>
#define int long long
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
template < typename T >
inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ; 
	}
	flag ? x = -x : 0 ;
} 
const int N = 10 ;
const int mod = 998244853 ;
int t ,n ;
int x[N] = {0 ,1 ,2 ,3 ,4 ,5 ,6 ,7} ,y[N] = {0 ,0 ,4 ,43 ,225 ,812 ,2324 ,5670} ;
inline int qpow (int base ,int p = mod - 2) {
	int ans = 1 ;
	while (p) {
		if (p & 1) 
			(ans *= base) %= mod ;
		(base *= base) %= mod ;
		p >>= 1 ;
	}
	return ans ;
}
signed main () {
	read (t) ;
	while (t --) {
		read (n) ;
		int ans = 0 ;
		f (i ,1 ,7 ,1) {
			int d = 1ll ;
			f (j ,1 ,7 ,1) {
				if (i == j) 
					continue ;
				(d *= ((x[i] - x[j] + mod) % mod)) %= mod ;
			}
			d = qpow (d) ;
			int u = 1ll ;
			f (j ,1 ,7 ,1) {
				if (i == j) 
					continue ;
				(u *= ((n - x[j] + mod) % mod)) %= mod ;
			}
			ans = (u * d % mod * y[i] % mod + ans) % mod ;
		}
		cout << ans << '\n' ;
	}
	return 0 ;
}
```

---

## 作者：RoFtaCD (赞：1)

对于这类特征显著且无怪异特点的三角形网格图，我们可以使用一种较为轻松的分析方法。

首先可以看出递推性质，一个大小为 $n$ 的图的答案等同于：

两个大小为 $n-1$ 的子图的答案。

减去一个大小为 $n-2$ 的子图的答案。（蓝框）

再加上新的顶点到其他点的答案。

再加上枚举三角形腰上点到另一条腰的答案。（红框）

![非常的新鲜](https://cdn.luogu.com.cn/upload/image_hosting/eeobjvgp.png)

因为这几个子图实际上在下面，每条边的长度都比原来多 $1$ 或 $2$ 需要加上路径的数量。

于是设计状态 $f_i$ 表示大小为 $i$ 的图的答案，$g_i$ 为所有边长度为 $1$ 的大小为 $i$ 的图的答案。

为了转移 $f_i$ 和 $g_i$ 我们还需要算出这两种情况下顶点（记为 $tf_i,tg_i$）与边（记为 $ef_i,eg_i$）的方案。

转移就是：


$$ f_i = 2(f_{i-1}+g_{i-1})-(f_{i-2}+2g_{i-2})+ef_i+tf_i $$



$$ g_i = 2g_{i-1}-g_{i-2}+eg_i+tg_i $$



对于 $tf$ 与 $tg$ 我们列出最朴素的式子：

$$tf_n = \sum_{i=1}^{n} \sum_{j=1}^{i-1} j = \sum_{i=1}^{n} \frac{i^2(i-1)}{2}$$

$$tg_n = \sum_{i=1}^{n} i(i-1)$$

其实还能继续算下去，但是已经可以做了。

对于 $ef$ 与 $eg$ 我们可以画图分析，列出式子：

$$ef_n = \sum_{i=1}^n (\frac{i(i+1)}{2}+\sum_{j=1}^n \frac{j(j+1)}{2}) = \frac{n^2(n+1)(n+2)}{3}$$

$$eg_n = \sum_{i=1}^n (i+\sum_{j=1}^n j) = n^2(n+1)$$

然后直接转移，就做完了。

代码：

```cpp
#include <bits/stdc++.h>
#define each(i,a,b) for(int i=(a);i<=(b);++i)
#define eachr(i,a,b) for(int i=(a);i>=(b);--i)
typedef long long ll;
using namespace std;
constexpr int M=1e4+5,N=5e6+15,p=998244853;
int T,V=5e6;
int f[4],g[4],tg[4],tf[4],ef,eg,ans[M];
pair<int,int> a[M];

void sol(int n){
    each(i,0,3) f[i]=g[i]=tg[i]=tf[i]=0;
    f[2]=g[2]=4;
    tf[2]=tg[2]=2;
    int j=1;
    while(a[j].first==1) ans[a[j++].second]=0;
    while(a[j].first==2) ans[a[j++].second]=4;
    each(i,3,n){
        int t=i-1;
        eg=1ll*t*t%p*(t+1)%p;
        if(t%3) ef=1ll*(t+1)*(t+2)/3%p*t%p*t%p;
        else ef=1ll*t/3*t%p*(t+1)%p*(t+2)%p;
        tg[i&3] = (tg[(i-1)&3]+1ll*i*(i-1)%p)%p;
        tf[i&3] = (tf[(i-1)&3]+1ll*i*(i-1)/2%p*i%p)%p;
        f[i&3] = ((2ll*(f[(i-1)&3]+g[(i-1)&3])%p-(f[(i-2)&3]+2ll*g[(i-2)&3]%p)%p+p)%p+(tf[i&3]+ef)%p)%p;
        g[i&3] = ((2ll*g[(i-1)&3]%p-g[(i-2)&3]+p)%p+(tg[i&3]+eg)%p)%p;
        while(a[j].first==i) ans[a[j++].second]=f[i&3];
    }
}

int main(){
    scanf("%d",&T);
    each(i,1,T) scanf("%d",&a[i].first),a[i].second=i;
    sort(a+1,a+1+T);sol(V);
    each(i,1,T) printf("%d\n",ans[i]);
    return 0;
}
```
值得注意的是以上公式转移多为多项式递推和求和，容易看出本题答案也应该是是一个多项式。

动态规划时间复杂度 $\mathcal O (n)$ 注意时间，空间限制以及模数。

---

## 作者：_7thRC_CB_CRP_ (赞：0)

# 题解

## 补充

### 拉格朗日插值法的作用

拉格朗日插值法是什么？

拉格朗日插值法是一个多项式求值的数值算法，其可以在知道固定多项式次数时，并且在已经求出比次数多一个的对应值的答案时快速求出其他值的算法。

再知道这一前提后，我们拿到一个多项式推导题目后，可以通过知道前几个值得到其他值。~~虽然这个方法很高效，但它会让你变成一个废物。~~

### 具体的拉格朗日插值法

#### 结论

不妨设 $n-1$ 为这个函数 $f(x)$ 的次数的，并记之前的答案 $f(x_i)=y_i$。 

此时假设所求值为 $x$，则

$$f(x)=\sum_{i=0}^{n-1}y_i\prod_{j=0}^{n-1} \frac{x-x_j}{x_i-x_j}$$

推导因为篇幅比较大，所以在此不做展示。

## 思路

由于处理量很大，所以这题大概是一个推式子的题，当这个式子的次数较低的时候，果断使用拉格朗日插值法。



我们可以打一个暴力，检验插值次数是否正确（其实多几个也差不多）。

# 代码

```cpp

#include<bits/stdc++.h>
using namespace std;
long long x[2001]={0,1,2,3,4,5,6,7,8,9,10};
long long y[2001]={0,0,4,43,225,812,2324,5670};
long long qpow(long long w,long long p) {
	if(p==0)
		return 1;
	long long tp=qpow(w,p/2);
	return tp%998244853*tp%998244853*(p%2?w:1)%998244853;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    long long t;
    cin>>t;
    while(t--) {
		long long n=7,k;
		cin>>k;
		long long ans=0;
		for(int i=1;i<=n;i++) {
			long long m1=1;
			long long m2=1;
			for(int j=1;j<=n;j++) {
				if(i!=j) {
					m1=m1*(k-x[j])%998244853;
					m2=m2*(x[i]-x[j])%998244853; 
				}
			}
			ans+=(m1*qpow(m2,998244851)%998244853*y[i]%998244853);
			ans=ans%998244853;
		}
		cout<<(ans%998244853+998244853)%998244853<<endl;
	}
	return 0;
} 

```

# 忠告

千万不要所有题目都用插值法。

不然就会变成像作者一样不认真推式子，只喜欢到处乱插的废人。

---


# 回文项链

## 题目背景

**数据已增强，各位不要再交暴力了。**

国庆节期间，哥哥送了小埋一条项链。（假的，日本人过什么国庆。）

然而小埋不太开心，她更想要买一部新手机玩游戏。

## 题目描述

不过小埋很快发现了项链的神奇之处。

我们把项链看作一个$n$元环，记作$s$，环上每个结点由大写'A'-'Z'中的一个字母组成。小埋惊奇的发现，环上有很多回文串！我们定义回文串为环上一个首尾不重叠的连续子串（即环上每个结点最多被使用一次），且满足**存在一个回文中心**$i$，使得$i$之前的若干个字符分别与其关于$i$中心对称的字符相同。

现在，小埋给出你这个环，并希望知道有多少长度为$l$的本质不同的回文串；我们认为两个回文串本质不同，当且仅当它们回文中心所在结点不同。

## 说明/提示

**本题每个测试点时限500ms**

对于$30$%的数据，$n<=20$；

对于$50$%的数据，$n<=200$；

对于$80$%的数据，$n<=2000$；

对于$100$%的数据，$n<=10^6$，$0<l<=n$且$l$为奇数。

**仔细读题，本题回文串与传统意义上的回文串不同。**

## 样例 #1

### 输入

```
16 1
XIAOMAITAIBANGLE```

### 输出

```
16```

## 样例 #2

### 输入

```
4 3
ABAB```

### 输出

```
4```

# 题解

## 作者：mcqueen (赞：4)

大家好，我喜欢打暴力，所以我用暴力哈希 AC 了这道题。

观察题目，便可得知需要拆环，将原字符串复制一份放到原字符串后即可。此时，字符串$S$的长度为$2n$。

设$a=(l-1)/2$，我们需要从$S_{a+1}$到$S_{n+a}$中枚举**回文中心**。

对字符串$S$正反分别做一次哈希，在枚举过程中，若位置$i$满足字符串中$[i-a,i-1]$上的正哈希值等于$[i+1,i+a]$上的反哈希值，说明这个位置是回文串的回文中心，这时候答案加一即可。

为了避免哈希冲突，我选择使用双哈希，即使用了两个~~神奇的~~质数作为底数。~~当然，如果您有信仰的话，也可以选择单哈希。~~

1A代码：
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define N 1000005
using namespace std;
char s[N<<1];
ull LtoR1[N<<1],RtoL1[N<<1],LtoR2[N<<1],RtoL2[N<<1],mul1[N<<1],mul2[N<<1];
int n,l;
const ull p1=19260817,p2=19491001;
inline bool check(int l,int r,ull LtoR[],int L,int R,ull RtoL[],ull mul[])
{
	ull hs1=LtoR[r]-LtoR[l-1],hs2=RtoL[L]-RtoL[R+1];
	int t=n+n-r+1;
	if(t>L)hs2*=mul[t-L];
	if(L>t)hs1*=mul[L-t];
	return hs1==hs2;
   //写一个函数减少写代码难度。
}
int main()
{
	scanf("%d%d",&n,&l);
	if(l==1){printf("%d\n",n);return 0;}//特判一下，防止出现奇怪的问题
	scanf("%s",s+1);
	for(int i=1;i<=n;++i)s[i+n]=s[i];
	
	mul1[0]=mul2[0]=1;
	for(int i=1;i<=n+n;++i)
	mul1[i]=mul1[i-1]*p1,
	mul2[i]=mul2[i-1]*p2;
	
	for(int i=1;i<=n+n;++i)
	LtoR1[i]=LtoR1[i-1]+s[i]*mul1[n+n-i+1],
	LtoR2[i]=LtoR2[i-1]+s[i]*mul2[n+n-i+1];
	
	
	RtoL2[n+n]=s[n+n]*mul2[n+n];
	RtoL1[n+n]=s[n+n]*mul1[n+n];
	
	for(int i=n+n-1;i>=1;--i)
	RtoL1[i]=RtoL1[i+1]+s[i]*mul1[i],
	RtoL2[i]=RtoL2[i+1]+s[i]*mul2[i];
	
	
	l=(l-1)>>1;
	int ans=0;
	for(int i=l+1;i<=n+l;++i)//注意是从‘l+1’到‘n+l’，细节问题不要搞错了！
	{
		if(check(i-l,i-1,LtoR1,i+1,i+l,RtoL1,mul1)&&check(i-l,i-1,LtoR2,i+1,i+l,RtoL2,mul2))
		++ans;		
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：TLEphage (赞：3)

# 这道题对于刚学会manacher算法的oier来说是一道不错的练手题
**~~然而我炸了好久（哭~~**

**如果没学过manacher的写下
[$\color{green}\text{模板}$](https://www.luogu.org/problemnew/show/P3805)**

**推荐练习：[P1723](https://www.luogu.org/problemnew/show/P1723)**



------------

### 一、manacher算法可以解决在一串字符串中，每个以$i$为回文中心的最长回文串长度

比如：在abbaab**a**b中，以第7个**a**为中心的最长回文串为3

### 二、它还可以解决偶数长度回文串问题

比如：abba是一个偶数长度回文串，以bb为中心

**为了解决这一问题，我们可以在每个字符中间添加#，这样就变成a#b#b#a，那么回文中心就是#，方便我们计算。（这里还不懂就去模板那看~~题解~~吧）**

（**但这道题规定了$l$为奇数，说明只需要计算奇数长度回文串，也就不用加#了**）

### 三、这道题要求长度为$l$的回文串的回文中心个数

比如：abaabbb，求长度为3的回文串的回文中心个数，也就是aba、bbb的中心，答案故为2 

**（这里还不是这道题的例子，不要把它当成样例）**

显然，我们只要用manacher优秀的时间复杂度算出每个$i$对应的回文长度，就能求出答案了。

举个例子 ~~（因为我不知道怎么解释）~~ ：ababa，有3个长度为3的回文串，而以第3个$a$作为中心的最长回文串长度却为5。

因为ababa是回文串，那么只要以第3个$a$为中心，并且长度<=$5$，那么还能得到一个回文串，这里有$a$和$bab$。

**结论：$ans=∑(hw_i>=l?1:0)$**

### 四、由于它是环，我们要拆环

因为$l<=n$，所以只需在原字符串的基础上向左扩展$n/2$个字符，向右扩展$n/2$个字符，也就是只需要$n*2$的空间。

（我这里开了$n*3$倍，这样最后扫答案时就是$n+1$~$n+n$）

------------

# 上~~精简~~代码

```cpp
#include<iostream>
using namespace std;
#define ri register int
int n,l,hw[3000001],ans=0;
char s[3000001];
int main()
{
    cin>>n>>l;
    for(ri i=1;i<=n;++i) cin>>s[i],s[i+n]=s[i+n+n]=s[i];
    //manacher:
    int maxright=0,mid=0;
    for(ri i=1;i<=n*3;++i)
    {
        if(i<maxright) hw[i]=min(hw[(mid<<1)-i],maxright-i+1);
        while(s[i+hw[i]]==s[i-hw[i]]&&i>hw[i]) hw[i]++;
        if(hw[i]+i>=maxright)
        {
            maxright=hw[i]+i-1;
            mid=i;
        }
    }
    //ans:
    for(ri i=n+1;i<=2*n;++i) if((hw[i]*2-1)>=l) ++ans;
    cout<<ans;
}
```



---

## 作者：command_block (赞：3)

[安利Blog](https://www.luogu.org/blog/command-block/)

------------

### 如此妙 ~~模板~~ 的一道题怎么能没有题解呢?

看到“回文串”,“环”等字眼,直接上**manacher+拆环**乱搞,结果WA,拿了60pts。

后来仔细看了看题面:

我们定义回文串为环上一个**首尾不重叠**的连续子串（即环上每个结点最多被使用一次），且满足存在一个回文中心$i$，使得$i$之前的若干个字符分别与其关于$i$中心对称的字符相同。

对于$100\%$的数据，$n<=10^6$ ，$0<l<=n$**且$l$为奇数**。

### 只有奇回文串才算数呐!

manacher算法没听说过的,右转此题

https://www.luogu.org/problemnew/show/P3805

这题的拆环有些特殊,要把原字符串复制三遍。

不用插‘#’字符跑manacher,然后取**中间那一段**的回文延伸数组和$l$比较。

至于“环上每个结点最多被使用一次”这个要求,**不用理会**(自己想为什么)。

------------

~~丑陋的~~ 超短的AC代码。

```cpp
#include<iostream>
#include<cstdio>
using namespace std 
int n,k,maxr,p,h[2005000],ans 
char s[3005000] 
int main()
{
  scanf("%d%d%s",&n,&k,s+1) 
  for (int i=1 i<=n i++)s[n+n+i]=s[n+i]=s[i] 
  n*=3 
  for (int i=1 i<=n i++){
    if (maxr>i)
      h[i]=min(maxr-i,p-i+p>0 ? h[p-i+p] : 0) 
    else h[i]=1 
    while(i+h[i]<=n&&i-h[i]>0&&
          s[i-h[i]]==s[i+h[i]])h[i]++ 
    if (i+h[i]>maxr){maxr=i+h[i] p=i }
  }for(int i=n/3+1 i<=n/3*2 i++)
    if (h[i]*2-1>=k)ans++ 
  printf("%d",ans) 
  return 0 
}
//分号已删,做了魔改,不影响阅读
//减少代码复制,共建美好洛谷~
```

---

## 作者：hovny (赞：2)

## [题面](https://www.luogu.org/problemnew/show/P4987)

求环中的长度为k（k为奇数）且回文中心不同的回文串个数

## 思路：

~~刚学manacher算法，就送上一道模板题，此题注重对manacher算法的理解~~

### Manacher，但是不用插入其他符号，因为k是奇数，中心一定在字符上

不知道Manacher？

[洛谷日报](https://www.luogu.org/blog/codesonic/manacheralgorithm)上有讲，但是比较难懂，建议上B站更深入了解下[$\to$](https://www.bilibili.com/video/av4829276?from=search&seid=12048406571254924464)

可以先把代码抄下来，然后一边看讲解一边理解代码含义，这样更能理解

~~反正我第一遍已经看蒙了~~

## 补充和纠正：

关于前几篇题解，一些小细节纠正一下

文末的代码更加简洁易懂

1、这是一个环，要做Manacher就应该**拆环为链**，第一篇题解说：应该重复复制**三次**（扩展为原来的三倍），但是实际上**两次**（扩展为原来的两倍）就够了

2、**p**数组（p[i]）表示的是以**i**为中心的最长回文串的半径（包括**i**这个字符），原本的**Manacher算法**因为加入的额外的`#`号，而是**p[i]**表示的是就是`原本最长回文串的长度+1`，因此求Ans的时候应该用`p[i]-1`，但是现在我们不加`#`号了，`p[i]`表示的就是`以i为中心的最长回文串的半径`，此时长度就应该表示为`p[i]*2-1`，意思是`半径*2-回文中心重复计算的字符`



Code：

```cpp
#include<bits/stdc++.h>
#define N 1000010//N<<1表示长度扩展为原来的两倍
using namespace std;
int n,k,p[N<<1],ans,res;
char s[N<<1];
void manacher()//标准的Manacher算法，就是没有加'#'号，而且起点为1
{
	s[0]='?';
	s[2*n+1]='!';
	int id=0,mx=0;//id表示目前最长回文串的中心，mx则是右边界
	for(int i=1;i<=2*n;i++)
	{
		if(i<mx)
			p[i]=min(p[2*id-i],mx-i);//如果中心在mx范围内，用mx去更新p[i]
		else
			p[i]=1;
		while(s[i-p[i]]==s[i+p[i]])//然后暴力
			p[i]++;
		if(mx<i+p[i])//更新mx和id
		{
			id=i;
			mx=i+p[i];
		}
	}
	return;
}
int main()
{
	int i;
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	for(i=1;i<=n;i++)//复制
		s[i+n]=s[i];
	manacher();//跑一遍Manacher
	res=(k+1)>>1;//表示起始的中心i的位置，这个位置是第一个有可能长度为k的回文串的中心（串s[1-k]的中心）
	for(i=res;i<=res+n-1;i++)//对于每一个点遍历一次，所以是res+n-1
		if(p[i]*2-1>=k)//真正的长度只要大于等于k就是可以的（大于k的可以把他砍成k啊~）
			ans++;
	printf("%d",ans);
	return 0;
}
```

## 推荐题目：

一道有趣的黄题   [P1210 回文检测](https://www.luogu.org/problemnew/show/P1210)

---

## 作者：Mars_Dingdang (赞：1)

一道环上奇回文串的题目，用经典的 Manacher 算法进行求解。

## 题目大意
我们把项链看作一个 $n$ 元环，记作 $s$，环上每个结点由大写 `A`-`Z` 中的一个字母组成。环上有很多回文串，我们定义回文串为环上一个首尾不重叠的连续子串（即环上每个结点最多被使用一次），且满足存在一个回文中心 $i$，使得 $i$ 之前的若干个字符分别与其关于 $i$ 中心对称的字符相同（即 **奇回文串**）。

现在给出你这个环，并希望知道有多少长度为 $l$ 的本质不同的回文串；我们认为两个回文串本质不同，当且仅当它们回文中心所在结点不同。

## 大体思路
对于一类求回文串的题目，考虑 Manacher。

这是一个专门用作处理最长回文子串的方法，思想很巧妙，比较难以理解。其实主要思想是，把给定的字符串的每一个字母当做中心，向两边扩展，这样来找最长的子回文串，这个叫中心扩展法，但是这个方法还要考虑到处理 abba 这种偶数个字符的回文串。Manacher 法将所有的字符串全部变成奇数个字符。

Manacher 算法原理：

首先，Manacher 算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用 `#` 号。

Manacher 算法用一个辅助数组 $Len[i]$ 表示以字符 $T[i]$ 为中心的最长回文字串的最右字符到 $T[i]$ 的长度，比如以 $T[i]$ 为中心的最长回文字串是 $T[l,r]$，那么 $Len[i]=r-i+1$。

Len 数组有一个性质，那就是 $Len[i]-1$ 就是该回文子串在原字符串 $S$ 中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以 $T[i]$ 为中心的最长回文字串，其长度就为 $2\times Len[i]-1$，经过观察可知，$T$ 中所有的回文子串，其中分隔符的数量一定比其他字符的数量多 1，也就是有 $Len[i]$ 个分隔符，剩下 $Len[i]-1$ 个字符来自原字符串，所以该回文串在原字符串中的长度就为 $Len[i]-1$。

有了这个性质，那么原问题就转化为求所有的 $Len[i]$。下面介绍如何在线性时间复杂度内求出所有的 $Len$。

首先从左往右依次计算 $Len[i]$，当计算 $Len[i]$ 时，$Len[j](0\le j<i)$ 已经计算完毕。设 $P$ 为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为 $po$，分两种情况：

第一种情况：$i\le P$

那么找到 $i$ 相对于 $po$ 的对称位置，设为 $j$，那么如果 $Len[j]<P-i$，如下图：

![](https://img-blog.csdn.net/20141221160212654)

那么说明以 $j$ 为中心的回文串一定在以 $po$ 为中心的回文串的内部，且 $j$ 和 $i$ 关于位置 $po$ 对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以 $i$ 为中心的回文串的长度至少和以 $j$ 为中心的回文串一样，即 $Len[i]\ge Len[j]$。因为 $Len[j]<P-i$，所以说 $i+Len[j]<P$。由对称性可知 $Len[i]=Len[j]$。
 
如果 $Len[j]>=P-i$,由对称性，说明以 $i$ 为中心的回文串可能会延伸到 $P$ 之外，而大于 $P$ 的部分我们还没有进行匹配，所以要从 $P+1$ 位置开始一个一个进行匹配，直到发生失配，从而更新 $P$ 和对应的 $po$ 以及 $Len[i]$。

![](https://img-blog.csdn.net/20141221160232375)

第二种情况: $i>P$  暴力。时间复杂度：$O(n)$。

对于本题，由于题目规定长度为奇数，可以不用插入特殊字符，但拆环时为了避免偶回文串的影响，可采用以下技巧：

1. 将环拆成三条链首尾相接。
2. 统计答案时只对中间的一条链进行操作。

这样就可以在只做一次的前提下消除偶回文串的贡献。

此外，由于 Manacher 求的是以 $i$ 为中心的最长回文串，则当其长度 $len\ge l$ 时，必然存在以 $i$ 为中心，长度为 $l$ 的回文串，所以只需判断 $2\times Len[i]-1$ 是否大于等于 $l$ 即可。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 3e6 + 5;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int p[maxn], n, l, ans, id, mx;
char s[maxn];
int main () {
	scanf("%d%d%s", &n, &l, s + 1);
	rep(i, 1, n) {
		s[i + n + n] = s[i + n] = s[i];
	}
	n *= 3;
	rep(i, 1, n) {
		if(i < mx) p[i] = min(mx - i, p[2 * id - i]);
		else p[i] = 1;
		while(i + p[i] <= n && i - p[i] >= 1 && s[i + p[i]] == s[i - p[i]]) p[i]++;
		if(mx < i + p[i]) id = i, mx = i + p[i];
	}
	rep(i, n / 3 + 1, n / 3 * 2) { // 中间一段 
		if(2 * p[i] - 1 >= l) ans++;
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：user2004 (赞：1)

一眼看出用manacher拆环瞎搞 

本机AC，提交，爆零>_<

看见这里好像有点不对 :-O
```cpp
	getchar();
```
原来Linux和Windows换行符是不一样的...


改了以后顺利AC

```cpp
#include<string.h>
#include<algorithm>
#include<stdio.h>
#define maxn 3300009
char data[maxn];
int _length[maxn];
int tot,dirl,dirr,sum,n,k;
void readin()
{
	scanf("%d%d",&n,&k);
	int count=0;
	getchar();
	getchar();
	char c=getchar();//读入优化
	while(c<='Z'&&c>='A') 
	{
		data[count++]=c;
		c=getchar();
	}
	tot=count;
	for(int i=0;i<tot;i++)
	{
	data[i+tot]=data[i];
	data[i+tot*2]=data[i];
	}
	dirl=tot;//拆环
	dirr=tot*2;
	tot*=3;
}
void manacher()
{
	int right=dirl,mid;
	for(int i=dirl;i<dirr;i++)
	{
		if(i<right)
    	_length[i]=std::min(_length[(mid*2)-i],_length[mid]+mid-i);
    	else _length[i]=1;
    	while(data[i+_length[i]]==data[i-_length[i]]) 
    	_length[i]++;
        if(_length[i]+i>right)
        {
            right=_length[i]+i;
            mid=i;
        }	
	}
}
void print()
{
	for(int i=dirl;i<dirr;i++)
	{
		if(k<=_length[i]*2-1) sum++;
	}
	printf("%d",sum);
        
        return 0;
}
int main()
{
	readin();
	manacher();
	print();
}
```

---

## 作者：muller (赞：1)

刚会做这道题，发现时manacher

以前不会，果然太菜了

这道题直接拆环瞎搞

这样就60pts

突然发现

考虑有些中心对称可能算两遍

所以要判断一下

manacher的精髓所在就是处理回文串

所以我们需要在中间+一些奇怪的符号

注意不要有问题，越界，否则re

于是我们可以乱搞一发即可

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2000005;
int l, p, n, rev[N << 2], len[N << 2], ans = 0; 
bool f[N << 2], vis[N << 2]; string s; char S[N << 2];
void manacher() {
	int i, mx = 0, mid;
	for (i = 1; i <= n; ++i) {
		if (i < mx) len[i] = min(len[mid * 2 - i], mx - i);
		for (; S[i + len[i]] == S[i - len[i]]; ++len[i]); --len[i];
		if (i + len[i] > mx) mx = i + len[i], mid = i;
		if (f[i]) {if (len[i] >= p) {if (!vis[rev[i]]) vis[rev[i]] = true, ++ans;}}
	}
}
int main() {
	int i; cin >> l >> p; cin >> s; s = s + s; 
	l *= 2; S[0] = '$';
	for (i = 0; i < l; ++i) {
		S[i * 2 + 1] = '#'; S[i * 2 + 2] = s[i]; f[i * 2 + 2] = true;
		if (i >= l / 2) rev[i * 2 + 2] = i * 2 + 2 - l;
		else rev[i * 2 + 2] = i * 2 + 2;
	}
	S[n = l * 2 + 1] = '#'; S[++n] = '@';
	manacher(); cout << ans << '\n';
	return 0;
}

```

---

## 作者：ShineEternal (赞：1)

# 为了让大家看起来方便，于是验题人就把题解放进来了，相关题目请点击[这里](https://blog.csdn.net/kkkksc03/article/details/83239164)


## T1

题意：给出一个长度为$n$字符环，求回文串长度为$l$的回文中心个数。

**Solution 0**

我们可以有信仰！输出0，期望得分10；输出$n$，期望得分10。

**Solution 1**

我们可以暴力！枚举所有子串，期望得分30；

**Solution 2**

枚举所有回文中心，根据处理环的方式不同（开环枚举断点或补成字符串），时间复杂度也有不同，期望得分50～80（为了照顾不会Manacher的同学）；

**Solution 3**

把读入的串复制两次分别粘贴在原串前后，这样便和环等价，直接跑一遍Manacher，时间复杂度为$O(n)$，期望得分100分。

不懂Manacher？百度有啊

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
    int n,l,cnt;
    int str[10000001];
    char t[10000001];
    char s[10000001];
int main()
{
    scanf("%d%d",&n,&l);
    for (int i=1;i<=n;i++)
    {
        t[i]=getchar();
        while (t[i]<'A'||t[i]>'Z')
            t[i]=getchar();
    }
    for (int j=1;j<=3;j++)
        for (int i=1;i<=n;i++)
        {
            s[++cnt]='0';
            s[++cnt]=t[i];
        }
    s[++cnt]='0';
    int r=0;
    int now=0;
    int ans=0;
    for (int i=1;i<=cnt;i++)
    {
        if (i<=r)
            str[i]=min(r-i+1,str[now*2-i]);
        while (i+str[i]<=cnt&&i-str[i]>0&&s[i+str[i]]==s[i-str[i]]) str[i]++;
        if (str[i]+i-1>r)
        {
            r=str[i]+i-1;
            now=i;
        }
        if (str[i]-1>=l&&i>=2*n+1&&i<=cnt-2*n&&s[i]!='0')
            ans++;
    }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：LB_tq (赞：1)

//第一感觉直接暴力，有90分（呵呵呵）
```cpp
#include<iostream>
using namespace std;
int n,m,ans;
char a[1000010];
int l[1000010],r[1000010];
bool tai(int x){
    int c=1,y=x;
    char s,t;
    while(c<m){
        x=r[x];
        y=l[y];
        if(a[x]!=a[y])
            return false;
        c+=2;
    }
    return true;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(i==1)
            l[i]=n;
        else
            l[i]=i-1;
        if(i==n)
            r[i]=1;
        else
            r[i]=i+1;
    }
    for(int i=1;i<=n;i++){
        if(tai(i)==true)
            ans++;
    }
    cout<<ans;
    return 0;
} 
```
———————————————分割线————————————————
```cpp
正解
//跑一遍Manacher,但题意中已说明只有奇数回文串，所以不用插入字符
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int r,now,n[3300003];
char a[3300003];//数组记得开大，解释在题目
int ans,m,l;
int main(){
	cin>>m>>l;
	for(int i=1;i<=m;i++)
		cin>>a[i];
	for(int i=m+1;i<=3*m;i++)
		a[i]=a[i-m];
    //将原串复制3份粘贴至首尾（由题意）
	for(int i=1;i<=3*m;i++){
		if(i<=r)
			n[i]=min(n[now*2-i],r-i+1);
		while(a[i+n[i]]==a[i-n[i]]&&i>n[i])
			n[i]++;
		if(n[i]+i-1>r){
			r=n[i]+i-1;
			now=i;
		}//Manachar不解释
		if((n[i]*2-1)>=l&&i>m&&i<=2*m)
			ans++;//如果i是原串且满足题意，答案加一
	}
	cout<<ans;
	return 0;
}
```

---


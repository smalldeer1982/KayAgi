# 小埋与刺客传奇

## 题目背景

**数据已更新。**

经过几天几夜的硬肝，小埋终于玩到了最后一关，也是$Dancing$ $Line$的魔王关——$The$ $Legend$ $of$ $Assassin$

![avatar](https://cdn.luogu.com.cn/upload/pic/34876.png)

![avatar](https://cdn.luogu.com.cn/upload/pic/35145.png)

## 题目描述

如图，魔王关经常出现炸路与突发障碍。

小埋很苦恼，因为她不知道完整的地图。于是她进行了许多尝试，总结了随着时间变化而出现或消失的路与她在这些时刻时的位置，**为了简化问题，我们假定小埋的位置始终不变**。

现在她想知道，她至少从什么时刻开始才可以看到能通向终点的路；由于一些路径上有钻石，这些钻石能带来一定加分，小埋还希望知道她在最早看到能通向终点的路时，按照当前地图走向终点所能获得的最大得分。

## 说明/提示

本题共$10$个测试点，各测试点详细信息如下：

$1$：$n<=100000$，$m<=200000$，$t<=100000$；输出“$Continue$ $from$ $the$ $last$ $checkpoint$”；分值：$5$；

$2$：$n<=100$，$m<=10000$，$t<=100$；无特殊性质；分值：$10$；

$3$：$n<=100000$，$m<=200000$，$t<=100000$；所有边的分数为$0$；分值：$10$；

$4$：$n<=100000$，$m<=200000$，$t=0$；无新增或消失的边；分值：$5$；

$5$~$6$：$n<=100000$，$m<=200000$，$t<=100000$；无消失的边；分值：$10$；

$7$~$8$：$n<=100000$，$m<=200000$，$t<=100000$；无出现的边；分值：$10$；

$9$~$10$：$n<=100000$，$m<=200000$，$t<=100000$；消失的边不超过$1000$条；分值：$15$。

另外，对于所有数据，$0<u_i,u_j,v_i,v_j<=n$，$0<=w_i,w_j<=10$，$0<tm_j<=10t$，且$tm_j$互不相同；数据保证不出现正环。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 1
1 3 1
0```

### 输出

```
0
2```

## 样例 #2

### 输入

```
3 3
1 2 1
2 2 0
3 1 1
0```

### 输出

```
Continue from the last checkpoint```

## 样例 #3

### 输入

```
3 3
1 2 1
2 2 0
3 1 1
4
2 0 1 3 1
1 1 3
3 1 1
5 1 1```

### 输出

```
2
1```

# 题解

## 作者：ShineEternal (赞：10)

# 为了让大家看起来方便，于是验题人就把题解放进来了，相关题目请点击[这里](https://blog.csdn.net/kkkksc03/article/details/83239164)

## T4

题意较为复杂，详见题面。

本题操作较多，前面的测试点基本上都分别对应一个操作，因此我们逐个测试点分析。

$1$：没什么好说的……

$2$：最暴力的方法也能过，也没什么好说的。

$4$：这个也很简单，直接跑一遍最长路即可，当然裸$dijkstra$是过不了的，需要加堆优化；

由于出题人的数据生成器比较水，生成个数据都要几分钟，所以很良心地没有卡$spfa$。

$3$：这一测试点边权为0，那就省去了最长路了；

如何判断图的连通性？顺着去枚举并每次判断连通性，显然会超时；

这里标程用了笨办法：分块二分；由于删除的边不超过1000条，最多只会把操作分成1000个部分，每一部分操作都是添加边，显然有单调性！

顺着枚举每一部分的操作，在处理每个部分时二分判断连通性，可以减少判断的次数，优化操作时间。

至于删除操作，我用了树状数组+二分，树状数组存前缀和，即它是第几条边，然后二分它在原数组的标号即可。

$5-6$：经过上面一番分析大家大概也有整体思路了：先分块二分判连通性，再求最长路。

这里无消失的边，那么省去了分块与删除操作，其它与上面方法一样。

$7-8$：这里也是非常简单的，由于删除边对生成连通图没有贡献，所以操作同$4$。

$9-10$：其实就是测试点$3$+测试点$4$，用$3$的方法判断连通性后求个最长路即可。

可见，本题中其实大部分分都可以水的，而要AC，解决测试点$3$是关键。

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
    struct newdata
    {
        int tm,type,u,v,w,k;
    };
    struct forward_star 
    {
        int next,to,w;
    };
    int n,m,t,cnt,tot;
    forward_star edge[1100001];
    newdata work[100001];
    int head[100001];
    int heap[100001];
    int que[100001];
    int ref[100001];
    int tree[1100001];
    int dist[100001];
    bool usable[1100001];
    bool vis[100001];
void add(int u,int v,int w)
{
    cnt++;
    edge[cnt].to=v;
    edge[cnt].w=w;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
void adjust_up(int now)
{
    if (now>1&&dist[heap[now]]>dist[heap[now/2]])
    {
        ref[heap[now]]=now/2;
        ref[heap[now/2]]=now;
        swap(heap[now],heap[now/2]);
        adjust_up(now/2);
    }
}
void adjust_down(int now)
{
    if (now*2+1<=tot)
    {
        int k;
        if (dist[heap[now*2+1]]>dist[heap[now*2]]) k=now*2+1; else k=now*2;
        if (dist[heap[k]]>dist[heap[now]])
        {
            ref[heap[k]]=now;
            ref[heap[now]]=k;
            swap(heap[k],heap[now]);
            adjust_down(k);
        }
    }
    else if (now*2<=tot)
    {
        if (dist[heap[now*2]]>dist[heap[now]])
        {
            ref[heap[now]]=now*2;
            ref[heap[now*2]]=now;
            swap(heap[now],heap[now*2]);
            adjust_down(now*2);
        }
    }
}
void addheap(int now)
{
    heap[++tot]=now;
    ref[now]=tot;
    adjust_up(tot);
}
void pushheap()
{
    heap[1]=heap[tot];
    ref[heap[1]]=1;
    tot--;
    adjust_down(1);
}
void dijkstra_heap(int u)
{
    memset(vis,false,sizeof(vis));
    memset(dist,255,sizeof(dist));
    dist[u]=0;
    vis[u]=true;
    addheap(u);
    while (tot!=0)
    {
        int now=heap[1];
        pushheap();
        int i=head[now];
        while (i!=0)
        {
            if (usable[i]&&i<=cnt)
                if (dist[now]+edge[i].w>dist[edge[i].to])
                {
                    dist[edge[i].to]=dist[now]+edge[i].w;
                    if (!vis[edge[i].to])
                    {
                        vis[edge[i].to]=true;
                        addheap(edge[i].to);
                    } else adjust_up(ref[edge[i].to]);
                }
            i=edge[i].next;
        }
    }
}
bool cmp(newdata i,newdata j)
{
    return i.tm<j.tm;
}
bool check(int u,int v)
{
    memset(vis,false,sizeof(vis));
    int top=1;
    que[top]=u;
    vis[u]=true; 
    while (top>0)
    {
        int now=que[top];
        top--;
        int i=head[now];
        while (i!=0)
        {
            if (i<=cnt&&usable[i])
                if (!vis[edge[i].to])
                {
                    if (edge[i].to==v) return true;
                    vis[edge[i].to]=true;
                    que[++top]=edge[i].to;
                }
            i=edge[i].next;
        }
    }
    return false;
}
void adjust(int now)
{
    int i=now;
    while (i>0)
    {
        i-=i&i;
        tree[now]+=tree[i];
    }
    tree[now]++;
}
int sum(int now)
{
    int tot=0;
    int i=now;
    while (i>0)
    {
        tot+=tree[i];
        i-=i&i;
    }
    return tot;
}
int solve(int now)
{
    int l=1;
    int r=cnt;
    while (l<r)
    {
        int mid=(l+r)>>1;
        if (sum(mid)<now)
            l=mid+1;
        else r=mid-1;
    }
    tree[l]--;
    return l;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);
        adjust(i);
    }
    memset(usable,true,sizeof(usable));
    scanf("%d",&t);
    if (t==0)
    {
        dijkstra_heap(1);
        if (dist[n]==-1)
            printf("Continue from the last checkpoint");
        else
        {
            printf("0\n");
            printf("%d",dist[n]);
        }
        return 0;
    }
    else
    {
        bool occur=false;
        bool disappear=false;
        for (int i=1;i<=t;i++)
        {
            scanf("%d%d",&work[i].tm,&work[i].type);
            if (work[i].type==0)
            { 
                scanf("%d%d%d",&work[i].u,&work[i].v,&work[i].w);
                occur=true;
            }
            else 
            {
                scanf("%d",&work[i].k);
                disappear=true;
            }
        }
        if (disappear&&!occur)
        {
            dijkstra_heap(1);
            if (dist[n]==-1)
                printf("Continue from the last checkpoint");
            else
            {
                printf("0\n");
                printf("%d",dist[n]);
            }
            return 0;
        }
        sort(work+1,work+t+1,cmp);
        if (check(1,n))
        {
            printf("0\n");
            dijkstra_heap(1);
            printf("%d",dist[n]);
            return 0;
        }
        int l=1;
        for (int i=1;i<=t;i++)
            if (work[i].type==1)
            {
                int r=i-1;
                if (l>=r)
                {
                    usable[solve(work[i].k)]=false;
                    l=i+1;
                    continue;
                }
                int cnt_first=cnt;
                int l_first=l;
                for (int j=l;j<=r;j++)
                {
                    add(work[j].u,work[j].v,work[j].w);
                    adjust(cnt);
                }
                while (l<r-1)
                {
                    int mid=(l+r)>>1;
                    cnt=cnt_first+mid-l_first+1;
                    if (check(1,n))
                        r=mid;
                    else l=mid;
                }
                cnt=cnt_first+l-l_first+1;
                if (check(1,n))
                {
                    printf("%d\n",work[l].tm);
                    dijkstra_heap(1);
                    printf("%d",dist[n]);
                    return 0;
                }
                cnt=cnt_first+r-l_first+1;
                if (check(1,n))
                {
                    printf("%d\n",work[r].tm);
                    dijkstra_heap(1);
                    printf("%d",dist[n]);
                    return 0;
                }
                cnt=cnt_first+i-l_first+1;
                usable[solve(work[i].k)]=false;
                l=i+1;
            }
        int r=t;
        int cnt_first=cnt;
        int l_first=l;
        for (int j=l;j<=r;j++)
        {
            add(work[j].u,work[j].v,work[j].w);
            adjust(cnt);
        }
        while (l<r-1)
        {
            int mid=(l+r)>>1;
            cnt=cnt_first+mid-l_first+1;
            if (check(1,n))
                r=mid;
            else l=mid;
        }
        cnt=cnt_first+l-l_first+1;
        if (check(1,n))
        {
            printf("%d\n",work[l].tm);
            dijkstra_heap(1);
            printf("%d",dist[n]);
            return 0;
        }
        cnt=cnt_first+r-l_first+1;
        if (check(1,n))
        {
            printf("%d\n",work[r].tm);
            dijkstra_heap(1);
            printf("%d",dist[n]);
            return 0;
        }
        printf("Continue from the last checkpoint");
        return 0;
    }
    return 0;
}
```


---

## 作者：OrinLoong (赞：0)

## LGP4990 小埋与刺客传奇 学习笔记
[Luogu Link](https://www.luogu.com.cn/problem/P4990)

### 前言
曾几何时我也是舞线吃啊，但是水平泰国第几，刺客传奇是不可能过的。

现在……舞线诈尸一次后又停更多久了……令人感叹。

以及，很难评价此题的数据强度。说它强还是弱感觉都不合适。只能说古早公开赛题的数据专业程度存疑。

### 题意简述
给定一个 $n$ 点 $m$ 边的简单有向有权图，初始时刻为第 $0$ 时刻。

之后会有 $T$ 个事件，第 $i$ 个事件会在 $t$ 时刻发生，属于以下两种操作之一：
+ 新加入一条编号为 $m+i$ 的边 $\{u_i,v_i,w_i\}$。
+ 删除当前未消失的边中编号第 $k$ 大的边。

问这个图最早在哪个时刻存在 $1\to n$ 的路径，并求出这个时刻 $1\to n$ 的最长路长度。

如果始终不存在 $1\to n$ 的路径，则输出一行 `Continue from the last checkpoint`。

$n,T\le 10^5,m\le 2\times 10^5$；设有 $b$ 次删边操作，$b\le 10^3$。数据保证不存在正环。

时限 $\text{3.00s}$。

### 做法解析
按时刻排序后，题目的操作序列应该形如：有 $b$ 次删边操作，每两个删边操作间有若干加边操作。

我们不能忍受每次操作后都重新跑一遍最长路，但我们发现，加边只会让连通性“单调上升”，所以我们对于每一段连续的加边操作，二分地去找它最早连通的时刻。

（至于删除操作，删边后的图连通性肯定劣于删边前，所以执行所有删除操作后都不需要跑最长路）

不过，“当前未消失的第 $k$ 条边”怎么处理？大致方法是，我们用树状数组：对于边 $e_i$，存在则 $v_i=1$，不存在则 $v_i=0$，并用树状数组维护 $v_i$ 的前缀和，这样我们就能在树状数组上二分找到第一个满足前缀和大于等于 $k$ 的地方，其对应的下标就是“当前未消失的第 $k$ 条边”的编号。

设有 $b$ 次删边操作，复杂度在 $O(b\log T\cdot m\log m)$ 左右。

### 代码实现
小优化：对于每个连续加边段可以先判断一下其加满的时候连不连通，如果连这时都不能联通，显然二分是不用做的。

```cpp
#include <bits/stdc++.h>
using namespace std;
using namespace obasic;
const int MaxN=1e6+5,MaxM=3e6+5;
const int Inf=0x3f3f3f3f;
int N,M,T,W,X,Y,Z,Opt;
int B[MaxM],flag,ans[2];
struct oper{
    int w,o,x,y,z;
    friend bool operator<(oper a,oper b){return a.w<b.w;}
}A[MaxM];
int ava[MaxM],dis[MaxN],vis[MaxN],ddis[MaxN];
vector<int> Gr[MaxN];
struct anod{
    int u,d;
    friend bool operator<(anod a,anod b){return a.d<b.d;}
};
priority_queue<anod> pq;
bool dijk(int tim){
    fill(dis,dis+N+1,-1);
    fill(vis,vis+N+1,0);
    dis[1]=0;pq.push({1,0}),vis[1]=true;
    while(!pq.empty()){
        auto [u,d]=pq.top();pq.pop();
        for(auto &x : Gr[u]){
            if(ava[x]==-1||ava[x]>tim)continue;
            int v=A[x].y,w=A[x].z;
            if(dis[v]<dis[u]+w){
                dis[v]=dis[u]+w;
                if(!vis[v])vis[v]=1,pq.push({v,dis[v]});
            }
        }
    }
    ddis[tim]=dis[N];
    return dis[N]>=0;
}
void proceres(int t){if(!flag)flag=1,ans[0]=B[t-M],ans[1]=ddis[t];}
struct BinidTree{
    int n,t[MaxM];
    void init(int x){n=x,fill(t,t+n+1,0);}
    int lowbit(int x){return x&(-x);}
    void add(int p,int x){for(;p<=n;p+=lowbit(p))t[p]+=x;}
    int gts(int p){int res=0;for(;p;res+=t[p],p-=lowbit(p));return res;}
}BiT;
int main(){
    readis(N,M);
    for(int i=1;i<=M;i++){
        readis(X,Y,Z);
        A[i]={0,0,X,Y,Z};
    }
    readi(T);
    for(int i=1;i<=T;i++){
        readis(W,Opt),B[i]=W;
        if(Opt==0)readis(X,Y,Z);
        if(Opt==1)readis(X);
        A[M+i]={W,Opt,X,Y,Z};
    }
    sort(A+M+1,A+M+T+1),sort(B+1,B+T+1),BiT.init(M+T);
    for(int i=1;i<=M;i++)BiT.add(i,1);
    for(int i=1;i<=T;i++)ava[M+i]=A[M+i].w=M+i;
    for(int i=1;i<=M;i++)if(A[i].o==0)Gr[A[i].x].push_back(i);
    if(dijk(0)){writil(0),writi(dis[N]);return 0;}
    for(int i=M+1,j;i<=M+T&&!flag;){//
        if(A[i].o==0){
            j=i;while(A[j+1].o==0&&j<=M+T)j++;
            for(int k=i;k<=j;k++)BiT.add(k,1),Gr[A[k].x].push_back(k);
            if(!dijk(j)){i=j+1;continue;}
            int sl=i,sr=j-1,smid,sres=j;
            while(sl<=sr){
                smid=(sl+sr)>>1;
                if(dijk(smid))sres=smid,sr=smid-1;
                else sl=smid+1;
            }
            if(sres)proceres(sres);
            i=j+1;
        }
        else{
            int sl=1,sr=i,smid,sres=0;
            while(sl<=sr){
                smid=(sl+sr)>>1;
                if(BiT.gts(smid)>=A[i].x)sres=smid,sr=smid-1;
                else sl=smid+1;
            }
            if(sres)BiT.add(sres,-1),ava[sres]=-1;
            i++;
        }
    }
    if(flag)writil(ans[0]),writi(ans[1]);
    else puts("Continue from the last checkpoint");
    return 0;
}
```

### 反思总结
“以删边操作为界分块，每一块内部不断加边是满足单调性的”，这其实还算好想。

更值得积累的一点在于，这题做“当前未消失的第 $k$ 条边”的做法：树状数组配合二分。

---


# 旅行

## 题目背景

$jjc$ 非常喜欢旅行~~（smy）~~！



## 题目描述

**$NOIP$ $2018$** 已经结束了，$jjc$ 决定去全国各地旅行，每个地方都有许多巨佬，他拥有一张地图来帮助他规划一条从 $A $ 地 到 $B $ 地 的路线，地图上有 $N $ 个地点编号为 $1$~$N$ ，有 $ M $ 条道路将不同(或相同)地点有向连通。

现在，$jjc$ 已经知道了通过第 $ i $ 条路从 $u_i $ 地 直接走到 $v_i $ 地 会遇到多少名巨佬，他将记录遇见的每一名巨佬的名字（不管是否记录过）。但是，每记录一名巨佬的名字就需要使用一张便签，便签以袋为单位出售，$jjc$ 选购的便签每一小袋有 $P$ 张。$jjc$ 不希望他购买的便签被浪费，因此他希望他旅程结束后他购买的每一袋便签都 **恰好** 被用完。除此以外，$jjc$ 正在存钱来$......QwQ$，他得减少消费，因此他希望这次旅行能消耗尽量少的便签。

然而，他不知道怎么才能找到最合适的路径，作为巨佬中的一员，你能帮 $jjc $ 解决这个问题，找到符合条件的最佳路径吗？


## 说明/提示

本题有 $ 3 $ 个 $ Subtask $

对$30$%的数据，$2≤N≤100$ ，$2≤M≤5000$ ，$1≤P≤50$

对另外$20$%的数据 ，$ 2≤N≤5×10^4$，$M≤2×10^5$，$P=1$

对另外$50$%的数据 ，$ 2≤N≤5×10^4$，$M≤2×10^5$，$1≤P≤50$ 

对于所有数据，$1≤A,B,u_i,v_i≤N$，$0≤num_i≤10^8 $  

$By : $ 学无止境

## 样例 #1

### 输入

```
2 2 3 1 2
1 2 1
2 2 1```

### 输出

```
3
1->2->2->2```

## 样例 #2

### 输入

```
4 6 3 2 3
2 1 7
2 4 0
4 3 6
1 4 0 
2 3 1
2 3 9```

### 输出

```
6
2->4->3```

## 样例 #3

### 输入

```
3 3 5 1 3
1 2 15
2 3 7
1 3 3 ```

### 输出

```
jjc fails in travelling```

# 题解

## 作者：small_john (赞：4)

## 思路

由于题面中要求最后的便签是 $p$ 的倍数，这是一个非常经典的分层图题。

将每个点拆分成 $p$ 个点。为了方便，我们设点 $(i,j)$ 表示原图中点 $i$ 的第 $j$ 层，即到点 $i$ 时剩下便签数对 $p$ 取模为 $j$。

考虑建图。对于原图中的每一条边 $(u,v,w)$，在分层图上建边时，枚举 $u$ 的层数 $j$，那么到了 $v$ 的时候层数就变成了 $(j+w)\bmod p$。所以连接一条从 $(u,j)$ 到 $(v,(j+w)\bmod p)$，权值为 $w$ 的边。

问题就被转化成了求 $(s,0)$ 到 $(t,0)$ 的最短路。跑一遍 Dijkstra 即可。

实测堆优化开 O2 才能过。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

template<typename T> inline void read(T &x)
{
	x = 0;
	T f = 1;char ch = getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f = -1,ch = getchar();
			break;
		}
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
		x = (x<<3)+(x<<1)+ch-48,ch = getchar();
	x*=f;
}
template<typename T> inline T read()
{
	T x;read(x);return x;
}
template<typename T> void write(T x)
{
    if(x<0) x = -x,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10+48);
}
template<typename T> inline void writen(T x)
{
    write(x);
    putchar(10);
}
const int N = 5e4+5,M = 2e5+5;
int n,m,p,s,t,cnt,head[N*50],to[M*50],nxt[M*50];
ll g[M*50];
inline void add(int x,int y,int z)
{
	nxt[++cnt] = head[x];
	head[x] = cnt;
	to[cnt] = y,g[cnt] = z;
}
inline int id(int x,int y){return (x-1)*p+y+1;}//(i,j) 的编号 
inline int get(int x){return (x-1)/p+1;}//(i,j) 编号对应的 i 
ll dis[N*50];
int pre[N*50];
bool vis[N*50];
void print(int x)//递归输出路径 
{
	if(pre[x]) print(pre[x]),putchar('-'),putchar('>');
	write(get(x));
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m),read(p),read(s),read(t);
	for(int i = 1,u,v,w;i<=m;i++)
	{
		read(u),read(v),read(w);
		for(int j = 0;j<p;j++)
			add(id(u,j),id(v,(j+w)%p),w);
	}
	priority_queue<pair<ll,int> > q;
	q.push({0,id(s,0)});
	for(int i = 1;i<=n*p;i++) dis[i] = 2e18;  
	dis[id(s,0)] = 0;
	while(!q.empty())//Dijkstra 
	{
		int u = q.top().second;q.pop();
		if(vis[u]) continue;
		vis[u] = 1;
		for(int i = head[u];i;i = nxt[i])
		{
			int v = to[i];
			if(dis[v]>dis[u]+g[i])
				dis[v] = dis[u]+g[i],pre[v] = u,q.push({-dis[v],v});
		}
	}
	if(dis[id(t,0)]==2e18) return puts("jjc fails in travelling"),0;//不连通 
	writen(dis[id(t,0)]);
	print(id(t,0));
	return 0;
}
```

---

## 作者：SSerxhs (赞：3)

分层图板子题，不知道分层图的右转日报区85期

把一个点拆成p个，点(i,j)表示从a到i路径上便签消耗量%p==j，则(a,0)到(i,j)距离含义为a到i路径消耗便签量%p==j时最少便签花费。对于原图(u,v,num)，连边(u,k)->(v,(k+num)%p)，长度为num，k为枚举的u的p个点。边的含义为u->v时，消耗量%p发生变化，从k变成(k+num)%p，花费代价为num。

建图完成后，跑一边堆优化dijkstra即可，最终答案为(a,0)到(b,0)的最短路。可使用pre数组记录前驱节点以保存最短路路径信息。

本题卡priority_queue，为了保护dalao的眼睛，我去掉了所有的卡常头文件。实测本代码加O2后12000ms+，Ofast后11000ms+，大量头文件后6000ms-

```
#include <stdio.h>
#include <string.h>
#include <queue>
using namespace std;
typedef long long ll;
priority_queue<pair<ll,int> > heap;
pair<ll,int> tq,cr;
const int N=2.5e6+2,M=1e7+2;
ll jl[N];
int lj[M],nxt[M],fir[N],len[M],pre[N],st[N];
int n,m,i,j,x,y,z,c,s,t,bs,p,tp;
bool ed[N];
inline void read(int &x)
{
    c=getchar();
    while ((c<48)||(c>57)) c=getchar();
    x=c^48;c=getchar();
    while ((c>=48)&&(c<=57))
    {
        x=x*10+(c^48);
        c=getchar();
    }
}
inline void add(int x,int y,int z)
{
    lj[++bs]=y;
    len[bs]=z;
    nxt[bs]=fir[x];
    fir[x]=bs;
}
inline int ys(int x,int y)
{
    return y*n+x;
}
int main()
{
    read(n);read(m);read(p);read(s);read(t);
    while (m--)
    {
        read(x);read(y);read(z);
        for (j=0;j<p;++j) add(ys(x,j),ys(y,(j+z)%p),z);
    }
    memset(jl,0x3f,sizeof(jl));
    jl[s]=0;
    cr.first=0;cr.second=s;
    heap.push(cr);
    while (1)
    {
        while ((!heap.empty())&&(ed[heap.top().second])) heap.pop();
        if (heap.empty()) break;
        tq=heap.top();
        if (tq.second==t) break;
        heap.pop();
        ed[tq.second]=1;
        for (i=fir[tq.second];i;i=nxt[i]) if (jl[lj[i]]>jl[tq.second]+len[i])
        {
            cr.first=-(jl[cr.second=lj[i]]=jl[tq.second]+len[i]);
            pre[lj[i]]=tq.second;
            heap.push(cr);
        }
    }
    if (jl[t]==jl[0])
    {
        puts("jjc fails in travelling");
        return 0;
    }
    printf("%lld\n",jl[t]);
    st[++tp]=t;
    while (pre[t]) st[++tp]=t=pre[t];
    while (tp>1) printf("%d->",(st[tp--]-1)%n+1);
    printf("%d\n",(st[tp]-1)%n+1);
}
```


---

## 作者：ZnHF (赞：2)

# 题意简述

给定一张有向图，求从点 $A$ 走到点 $B$ 的一条路径，这条路径满足：

1. 经过的边的权值总和是 $P$ 的倍数。
2. 在满足条件 $1$ 的情况下，经过的边的权值总和最小。

# 题目分析

本题可以使用分层图最短路来解决。

仿照动态规划的思想，定义 $f_{x,y}$ 表示从节点 $A$ 到达节点 $x$，经过的边的权值总和 $\bmod P$ 的值为 $y$ 时，经过的边的权值总和最小是多少。

然后进行一遍 Dijkstra 算法，设当前考虑的节点为 $a$，当前经过的边的权值总和 $\bmod P$ 的值为 $b$，扫描到一条通向点 $c$，权值为 $d$ 的边，在满足“当前位于点 $c$，经过的边的权值总和 $\bmod P$ 的值为 $(b+d) \bmod P$”这个状态没有被访问过的前提下，如果满足 $f_{c,(b+d) \bmod P} > f_{a,b}+d$，则使用 $f_{a,b}+d$ 更新 $f_{c,(b+d) \bmod P}$。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){register int t1=0,t2=0;register char x=getchar();while(x<'0' ||x>'9'){if(x=='-') t2|=1;x=getchar();}while(x>='0' && x<='9'){t1=(t1<<1)+(t1<<3)+(x^48),x=getchar();}return t2?-t1:t1;}
inline void write(int x){register int sta[35],top=0;if(x<0) putchar('-'),x=-x;do{sta[top++]=x%10,x/=10;}while(x);while(top) putchar(sta[--top]+48);}
int n,m,p,s,t,f[50005][55],pre_now[50005][55],pre_use[50005][55];
bool vis[50005][55];
struct edge{
	int to,l;
};
vector<edge> v[50005];
struct node{
	int now,sum,use;
};
priority_queue<node> q;
bool operator <(const node &a,const node &b){
	return a.sum>b.sum;
}
vector<int> ans;
void get(int x,int y){//通过保存的路径信息得到具体地路径 
	if(!x) return;
	ans.push_back(x);
	get(pre_now[x][y],pre_use[x][y]);
}
signed main(){
	n=read();
	m=read();
	p=read();
	s=read();
	t=read();
	for(int i=1;i<=m;i++){
		int t1=read(),t2=read(),t3=read();
		v[t1].push_back({t2,t3});
	}
	memset(f,0x3f,sizeof(f));
	f[s][0]=0;
	q.push({s,0,0});
	while(!q.empty()){
		node temp=q.top();
		q.pop();
		if(vis[temp.now][temp.use]) continue;
		vis[temp.now][temp.use]=1;
		for(int i=0;i<v[temp.now].size();i++){
			int t1=v[temp.now][i].to,t2=v[temp.now][i].l;
			if(!vis[t1][(temp.use+t2)%p] && f[t1][(temp.use+t2)%p]>f[temp.now][temp.use]+t2){
				f[t1][(temp.use+t2)%p]=f[temp.now][temp.use]+t2;
				pre_now[t1][(temp.use+t2)%p]=temp.now;//保存路径信息 
				pre_use[t1][(temp.use+t2)%p]=temp.use;//同上 
				q.push({t1,f[t1][(temp.use+t2)%p],(temp.use+t2)%p});
			}
		}
	}
	if(f[t][0]==4557430888798830399) puts("jjc fails in travelling");//考虑无法完成的情况
	else{
		write(f[t][0]);
		putchar('\n');
		get(t,0);
		for(int i=ans.size()-1;i>0;i--){
			write(ans[i]);
			putchar('-');
			putchar('>');
		}
		write(ans[0]);
	}
	return 0;
}
```

---

## 作者：Kelvin2009 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5060)

这是一道分层建图的最短路。

要求遇见大佬总数尽可能少，且总数是 $q$ 的倍数。

这相当于基础的最短路算法加上整除的限制。

因此，考虑建一张对 $p$ 取模的分层图。对于一条边，$u$ 指向 $v$，路上的大佬数为 $w$，建立其对 $p$ 取模每一种情况的连边，权值为 $w$，然后进行正常的最短路操作。

**有一点注意：递归输出，要开 $\texttt{long long}$！**

------------
代码如下：

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=1e7+5;
const long long lim=0x3f3f3f3f3f3f3f3f;
bool vis[range];
long long dis[range],val[range];
int n,m,p,a,b,u,v,num,point[range];
priority_queue<pair<long long,int> > p_q;
int cnt=1,to[range],nxt[range],head[range];
inline int pos(int base,int res){return (base-1)*p+res+1;}
inline void add(int u,int v,long long w)
{
	nxt[++cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt;
	val[cnt]=w;
	return ;
}
inline void dijkstra()
{
	p_q.push({0,pos(a,0)});
	for(int i=1;i<=n*p;i++) dis[i]=lim;
	dis[pos(a,0)]=0;
	while(!p_q.empty())
	{
		int from=p_q.top().second;
		p_q.pop();
		if(vis[from]) continue;
		vis[from]=true;
		for(int i=head[from];i;i=nxt[i])
		{
			int get=to[i];
			if(dis[get]>dis[from]+val[i]) dis[get]=dis[from]+val[i],point[get]=from,p_q.push({-dis[get],get});
		}
	}
	return ;
}
void get_array(int from)
{
	if(point[from])
	{
		get_array(point[from]);
		printf("->");
	}
	printf("%d",(from-1)/p+1);
	return ;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&p,&a,&b);
	while(m--)
	{
		scanf("%d%d%d",&u,&v,&num);
		for(int i=0;i<p;i++) add(pos(u,i),pos(v,(i+num)%p),(long long)num);
	}
	dijkstra();
	if(dis[pos(b,0)]==lim)
	{
		printf("jjc fails in travelling");
		return 0;
	}
	printf("%lld\n",dis[pos(b,0)]);
	get_array(pos(b,0));
	return 0;
}
```

---

## 作者：_weishiqi66_ (赞：1)

# 引入
什么是分层图？“分层图最短路”顾名思意，可以知道是在分层的图上跑最短路得算法。可是要怎么分层呢？分层图最短路最基本的模型就是：给定 $n$ 个点 $m$ 条路以及 $k$ 个决策，再求出 $s$ 到 $t$ 的最短距离。

# 问题
分层图最短路和一般的最短路问题最大的差别存在一些决策。也就是说在跑最短路的时候，达到同样一个点，因为存在一
些决策，所以点被影响。同样的一条路，可能因为决策的不同，导致一些关键信息的不同，影响我们答案的统计。

# 解决
因为决策会影响点的状态，那么我们直接把一个点分成多个点，代表不同状态下的同一个点。把一个图上的每一个点都进行分身，再进行连边建图。这就是分层图最短路。

回到我们的题目。

题目简化：给定 $n$ 个点 $m$ 条路以及 $p$ ，求出一条 $s$ 到 $t$ 的路，要求距离为 $p$ 的倍数的情况最小。

对于每个点，我们可以把它分身成 $p$ 个点，分别表示到这个点距离对 $p$ 的取模。对于原图的每条边 $(u,v,w)$，我们枚举  $j$ 表示出点 $u$ 的第 $j$ 个分身,建立 $(u,j)$ 到 $(v,(w+j)%p)$ 的边。接着跑一个最短路即可。

代码
```
#include <bits/stdc++.h>
#define ll long long 
using namespace std;

const int N = (5*1e4+5)*50;
const int M = (2*1e5+5)*50;

int n,m,p,start,end,head[N],cnt,pre[N];
ll d[N];
bool v[N];
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
struct EDGE{
	int to,next,w;
}e[M];
void add(int x,int y,int z) {
	e[++cnt].to=y; 
	e[cnt].w=z;
	e[cnt].next=head[x];
	head[x]=cnt;
}

struct code {
	ll d,u;
	friend bool operator < (code x,code y) {
		return x.d>y.d;
	}
};
priority_queue<code> q;
#define id(x,y) ((x-1)*p+y+1)
#define get(x) ((x-1)/p+1)
void dijkstra() {
	memset(d,0x3f3f3f3f,sizeof(d));
	memset(v,0,sizeof(v));
	d[id(start,0)]=0; q.push((code){0,id(start,0)});
	while(!q.empty()) {
		code x=q.top();q.pop();
		int u=x.u;
		if(v[u]) continue;
		v[u]=1;
		for(int i=head[u];i!=0;i=e[i].next) {
			int j=e[i].to;
			if(d[j]>d[u]+e[i].w) {
				d[j]=d[u]+e[i].w;
				q.push((code){d[j],j});
				pre[j]=u;
			}	
		}
	}
	
}
inline void print(int x) {
	if(pre[x]!=0) {
		print(pre[x]); cout<<"->";
	}
	cout<<get(x);
}
signed main() {
	n=read(); m=read(); p=read(); start=read(); end=read();
	for(int i=1;i<=m;i++) {
		int x=read(),y=read(),z=read();
		for(int j=0;j<p;j++) add(id(x,j),id(y,(j+z)%p),z);
	}
	dijkstra();
	if(d[id(end,0)]==4557430888798830399) cout<<"jjc fails in travelling" <<endl;
	else {
		cout<<d[id(end,0)]<<endl;
		print(id(end,0));
	}
	
	return 0;
}
```

一些分层图最短路的题目推荐
- [P4568 [JLOI2011] 飞行路线](https://www.luogu.com.cn/problem/P4568)
- [P1073 [NOIP2009 提高组] 最优贸易
](https://www.luogu.com.cn/problem/P1073)

- [P4822 [BJWC2012] 冻结
](https://www.luogu.com.cn/problem/P4822)
- [P2939 [USACO09FEB] Revamping Trails G
](https://www.luogu.com.cn/problem/P2939)

---

## 作者：404Not_Found (赞：1)

### 题意

给定一个 $n$ 个点 $m$ 条边的有向图，求从 $A$ 到 $B$ 满足路径边权和为 $P$ 的倍数的最短路径即方案。

### 分析

普通最短路貌似不太好做，考虑分层图。对于每一个点 $u$，我们可以拆成 $p$ 个点，其中的第 $i$ 个点 $u_i$ 表示从起点到点 $u$ 的最短路径和 $\bmod \,p$ 的结果为 $i$。 

对于原图中的边 $(u,v,w)$，连边 $(u_i,v_{(i+w) \bmod p}) (0 \le i < p)$，表示从点 $u$ 到点 $v$ 时，需要 $w$ 的代价使的当前路径和 $\bmod \,p$ 的结果变为 $(i+w)\bmod p$。

建完图后之后直接跑最短路即可，答案为 $A_0$ 到 $B_0$ 的最短路，输出路径可以记录前驱。

吐槽一下，为什么同样是 STL 的堆，大家都用 `prioirty_queue` 而不是 `push_heap` 和 `pop_heap` 啊，两者在吸氧的情况下效率差不多，但不吸氧后者比前者不知道快到哪里去了。这道题不吸氧的情况几乎不卡常也能轻松过去，效率并不比手写堆低。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int MAXN = 5e6+5;
const int MAXM = 2e7+5;
struct edge{
	int to,nxt;LL dis;
} e[MAXM];
int head[MAXN],cnt;
inline int read()
{
	int x=0; char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+c-48;
	return x; 
}
inline void add(int u,int v,LL w)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].dis=w;
	head[u]=cnt; 
}
struct node{
	int pos;LL dis;
	bool operator<(node& rhs){return rhs.dis<dis;}
} q[MAXM];
LL dis[MAXN];
int vis[MAXN],pre[MAXN],top,n,m,p,s,t;
void Dijkstra(int s)
{
	memset(dis,0x7f,sizeof(dis));
	dis[s]=0; q[++top]={s,0}; push_heap(q+1,q+top+1);
	while(top)
	{
		int u=q[1].pos; pop_heap(q+1,q+top+1); top--;
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].dis)
			{
				dis[v]=dis[u]+e[i].dis;
				q[++top]={v,dis[v]},pre[v]=u,push_heap(q+1,q+top+1);
			}
		}
	}
}
int ans[MAXN],tot;
void getans(int t)
{
	if(!t) return;
	ans[++tot]=(t-1)%n+1;
	getans(pre[t]);
}
signed main()
{
	n=read(); m=read(); p=read(); s=read(); t=read();
	for(int i=1,u,v,w;i<=m;i++)
	{
		u=read(),v=read(),w=read();
		for(int j=0;j<p;j++) add(j*n+u,(j+w)%p*n+v,1ll*w);
	}
	Dijkstra(s);
	if(dis[t]==9187201950435737471) puts("jjc fails in travelling");
	else
	{
		printf("%lld\n",dis[t]);
		getans(t);
		for(int i=tot;i>1;i--) printf("%d->",ans[i]);
		printf("%d\n",ans[1]);
	}
	return 0;
}
```

---

## 作者：ueettttuj (赞：1)

[题目](https://www.luogu.org/problem/P5060)

这题是一道分层图板子题，这里给出分层图的两种做法。

在此之前，先提一下。这题好像卡$STL$里的堆???然后我开了$O_2$ ~~(不会手写堆)~~ 。还有就是记录路径。可以在跑最短路时记录是哪一个点到达了这个点，然后在反过来找一遍就好了。(具体见代码中的$fa$数组)

第一种：

可以通过建边，将原来的$x$到$y$路上碰到$z$个巨佬，即$(x,y,z)$,变为$(i\%p*n+x,(i+z)\%p*n+y,z) \ \ ,i=1\sim p$ 。也就是说，可以从**碰见巨佬数为$i\%p$这层**通向**碰见巨佬数为$(i+z)\%p$这层**。然后我们在建起的分层图上跑一遍最短路即可。

**注意空间**

贴代码
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
int n,m,p,tot,aa,bb,ll;
int head[5010000],ans[5001000],fa[5000010];
long long val[5000100];
bool vis[5000100];
struct node{
	int to,nex;
	long long val;
};
node edge[10001000];
struct data{ 
	int id;
	long long val;  //id记录位置，val记录巨佬数 
	data () {}
	data (int id1,long long val1) : id(id1) , val(val1) {}
	bool operator < (const data &qw) const{
		return val>qw.val;
	}
};
priority_queue <data> q;
void add(int x,int y,long long z){ //建边 
	edge[++tot].nex=head[x];
	edge[tot].to=y;
	edge[tot].val=z;
	head[x]=tot;
}
void dij(){   //跑最短路 
	val[aa]=0;
	q.push(data(aa,0));
	while(!q.empty()){
		data kk;
		kk=q.top();
		q.pop();
		if(kk.id==bb) return ;
		if(vis[kk.id]) continue ;
		vis[kk.id]=1;
		for(int i=head[kk.id];i;i=edge[i].nex){
			int y;
			y=edge[i].to;
			if(!vis[y] && val[y]>val[kk.id]+edge[i].val){
				fa[y]=kk.id;    //记录谁跑到了这个点 
				val[y]=val[kk.id]+edge[i].val;
				q.push(data(y,val[y]));
			}
		}
	}
}
void print(int rt){   //通过fa数组往回找路径 
	if(rt==0) return ;
	if(rt%n!=0) ans[++ll]=rt%n;
	else ans[++ll]=n;
	print(fa[rt]);
}
int main(){
	scanf("%d %d %d %d %d",&n,&m,&p,&aa,&bb);
	tot=1;
	int b,c;
	long long d;
	for(int i=1;i<=m;i++){
		scanf("%d %d %lld",&b,&c,&d);
		for(int j=0;j<=p;j++){
			add(j*n+b,(j+d)%p*n+c,d); //建图 
		}
	}
	memset(val,0x7f7f7f7f,sizeof(val));
	dij();  
	if(val[bb]!=9187201950435737471){
		printf("%lld\n",val[bb]);
		print(bb);
		for(int i=ll;i>1;i--)
			printf("%d->",ans[i]); //输出 
		printf("%d\n",ans[1]);
	}
	else printf("jjc fails in travelling\n");
	return 0;
}
```
------------

第二种

可以不用建出分层图。可以开二维数组$val[i][j]$，第一维$i$记录当前的位置，第二维$j$记录到达这个位置时**碰到巨佬数$\%p$** 。也就是说$val[i][j]$表示在$i$位置时**多出来的便签数为$j$** 时碰到的巨佬数。

然后可以跑一遍最短路，处理出$val$数组即可。

贴代码
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
long long n,m,p,aa,bb,tot,ll;
long long head[1000010];
struct node{
	long long to,nex,val;
};
node edge[1001000];
long long val[100010][55],ans[5000010];
struct node2{
	long long id,num;
};
node2 fa[100010][55];
bool vis[100010][55];
struct data{
	long long id,val,num;  //id记录位置，val记录巨佬数，num记录多出的便签数 
	data () {}
	data (long long id1,long long val1,long long num1) : id(id1) , val(val1) , num(num1) {} 
	bool operator < (const data &qw) const{
		return val>qw.val;
	}	
};
priority_queue <data> q; 
void add(long long x,long long y,long long z){ //建边 
	edge[++tot].to=y;
	edge[tot].nex=head[x];
	edge[tot].val=z;
	head[x]=tot;
}
void dij(){
	val[aa][0]=0;
	q.push(data(aa,0,0));
	while(!q.empty()){
		data kk;
		kk=q.top();
		q.pop();
		if(vis[kk.id][kk.num]) continue ;
		vis[kk.id][kk.num]=1;
		for(long long i=head[kk.id];i;i=edge[i].nex){
			long long y;
			y=edge[i].to;
			if(!vis[y][(kk.num+edge[i].val)%p] && val[y][(kk.num+edge[i].val)%p]>val[kk.id][kk.num]+edge[i].val){ 
				fa[y][(kk.num+edge[i].val)%p].id=kk.id;  
				fa[y][(kk.num+edge[i].val)%p].num=kk.num; //fa数组记录哪个点到了这个点 
				val[y][(kk.num+edge[i].val)%p]=val[kk.id][kk.num]+edge[i].val; //更新val 
				q.push(data(y,val[y][(kk.num+edge[i].val)%p],(kk.num+edge[i].val)%p));
			}
		}
	}
}
void dfs(long long idd,long long numm){ //通过fa数组找到路径 
	if(idd==0) return ;
	ans[++ll]=idd;
	dfs(fa[idd][numm].id,fa[idd][numm].num);
}
int main(){
	scanf("%lld %lld %lld %lld %lld",&n,&m,&p,&aa,&bb);
	tot=1;
	for(long long i=1;i<=m;i++){
		long long b,c,d;
		scanf("%lld %lld %lld",&b,&c,&d);
		add(b,c,d);   //建图 
	}
	memset(val,0x7f7f7f7f,sizeof(val));
	dij();
	if(val[bb][0]!=9187201950435737471){
		printf("%lld\n",val[bb][0]);
		dfs(bb,0);
		for(long long i=ll;i>1;i--)
			printf("%lld->",ans[i]);
		printf("%lld\n",ans[1]);
	}
	else printf("jjc fails in travelling\n");
	return 0;
}
```


---

## 作者：学无止境 (赞：1)

可以看出题意是求两点间最短的路径且是 $P$ 的倍数，应该有一点难度。

看到数据范围可以发现对于第二个子任务直接跑最短路就可以了

对于整道题能不能用最短路算法通过呢？

答案是肯定的，对最短路算法本身进行一定调整即可解决本题

没有负权，因此我们使用堆优化 $dijkstra$ 算法，出题人#$10$卡了 $spfa$ ~~(不知道成功没有)~~

使每一个点具有 $P$ 个意义，$dis[u][k]$表示到达 $u$ 点最短的路径满足模 $P$ 的余数为 $k$ ，则最终答案在 $dis[B][0]$ ，而在将点压堆时也要讲每一个意义独立开来，松弛时也要注意松弛对象只是一个点的一个意义而非整个点，想到这里，基本上就没什么问题了。时间复杂度 $O(N*P*log_2N)$

接下来只需要记录路径，我采用的是记录前继的方法，注意 $dis$ 数组的初值

温馨提示：最好使用快读，最好不要使用优先队列代替手写堆。

$Code:$

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
using namespace std;

struct edge
{
    int to,next;
    long long w;
}a[400010];

int head[50010],num,n,m,p,A,B,tempu,tempv,tot,pre[50010][50];
long long tempw,dis[50010][50],disp[50010][50];//disp 即dis_pre 
bool exist[50][50010]; 
pair<long long,int> heap[50010*50];

inline void add(int,int,long long);
inline int read();
inline void dijkstra();
void print(int,int);

int main()
{
    n=read(),m=read(),p=read(),A=read(),B=read();
    for(register int i=1;i<=m;i++)
    {
        tempu=read(),tempv=read(),tempw=read();
        add(tempu,tempv,tempw);
    }
    dijkstra();
    if(dis[B][0]==dis[0][0])
    {
        printf("jjc fails in travelling");
        return 0;
    }
    printf("%lld\n",dis[B][0]);
    print(B,0);
    printf("%d",B);
    return 0;
}

inline void add(int u,int v,long long w)
{
    a[++num].to=v;
    a[num].w=w;
    a[num].next=head[u];
    head[u]=num;
}
inline int read()
{
   register int s=0;
   register char c=getchar();
   while(c<'0'||c>'9')
   c=getchar();
   while(c>='0'&&c<='9') 
   s=s*10+c-'0',c=getchar();
   return s;
}
inline void Pop()
{
    heap[1]=heap[tot--];
    register int p=1,s;
    while(p*2<=tot)
    {
        s=p*2;
        if(s<tot&&heap[s+1]<heap[s])
            s++;
        if(heap[s]<heap[p])
            swap(heap[s],heap[p]),p=s;
        else
            break;
    }
}
inline void Push(pair<long long,int> d)
{
    heap[++tot]=d;	
    register int p=tot;
    while(p>1)
    {
        if(heap[p/2]>heap[p])
            swap(heap[p/2],heap[p]),p/=2;
        else 
            break;
    }
}
inline void dijkstra()
{
    int k;
    long long fd,td;
    memset(dis,127,sizeof(dis));
        dis[A][0]=0;
    heap[++tot]=make_pair(0ll,A);
    while(tot)
    {
    	fd=heap[1].first,k=heap[1].second;
        Pop();
        if(fd%p==0&&k==B)
            return;
        exist[fd%p][k]=true;
        for(register int i=head[k];i;i=a[i].next)
        {
            td=dis[k][fd%p]+a[i].w;
            if(td<dis[a[i].to][td%p])
            {
                pre[a[i].to][td%p]=k;
                disp[a[i].to][td%p]=fd%p;
                dis[a[i].to][td%p]=td;
                if(!exist[td%p][a[i].to])
                	Push(make_pair(td,a[i].to));
            }
        } 
    }
}
void print(int x,int y)
{
    if(!pre[x][y])
    	return;
    print(pre[x][y],disp[x][y]);
    printf("%d->",pre[x][y]);
}
```



---

## 作者：yzxoi (赞：1)

[$$\large{\texttt{My Blog}}$$](https://yzxoi.xyz/archives/1187)
## Describe
> [题目链接](https://www.luogu.com.cn/problem/P5060)

给定一个 $N$ 个点， $M$ 条边的有向图，求从 $A$ 到 $B$ 的路径上边权和是 $P$ 的倍数的最短路径的长度及路径。

对于所有数据，$2\leq N \leq 5\times {10}^{4},M\leq 2 \times {10}^5 , 1\leq P \leq 50$。
## Solution
设$dis[i][j]$表示从起点出发走到$i$的路径边权和$\% P=j$的最小值。

那么跑一次$Dijikstra$即可。

注意转移$dis[to][v+w[i]]=dis[u][v]+w[i]$。

保存路径可以记录根节点最后递归输出。

由于此题出题人~~不是特别友好~~，所以此题卡$spfa$，本人亲测$spfa$只有$80pts$。

> 关于spfa，她死了

## Code
```cpp
#include<bits/stdc++.h>
#define int long long //注意此题数据范围要开long long
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)//fread快读
inline int read(){int res=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();return res*f;}
inline void write(int x){if(x<0) putchar('-'),x=-x;if(x<10) putchar(x+'0');else write(x/10),putchar(x%10+'0');}
int n,m,p,s,t,fir[50010],nxt[200010],son[200010],w[200010],tot,dis[50010][60],vis[50010][60],pre[50010][60][3],inf;
inline void add(int x,int y,int z){++tot;nxt[tot]=fir[x];fir[x]=tot;son[tot]=y;w[tot]=z;}
struct node{int id,val,note;bool operator < (const node &x) const{return val>x.val;}};
inline node make(int x,int y,int z){node pp;pp.id=x,pp.val=y,pp.note=z;return pp;}
priority_queue<node> q;
inline void dij(){
	while(!q.empty()) q.pop();//清空队列是个好习惯
	dis[s][0]=0;
	q.push(make(s,0,0));
	while(!q.empty()){
		node u=q.top();q.pop();
		if(vis[u.id][u.note]) continue ;
		vis[u.id][u.note]=1;
		for(int to,i=fir[u.id];i;i=nxt[i]){
			to=son[i];
			if(!vis[to][(u.note+w[i])%p]&&dis[to][(u.note+w[i])%p]>dis[u.id][u.note]+w[i]){
				dis[to][(u.note+w[i])%p]=dis[u.id][u.note]+w[i];
				pre[to][(u.note+w[i])%p][0]=u.id;//记录路径
				pre[to][(u.note+w[i])%p][1]=u.note;
				q.push(make(to,dis[to][(u.note+w[i])%p],(u.note+w[i])%p));
			}
		}
	}
}
inline void print(int x,int note,int fir){//递归输出路径
	if(!x) return ;
	print(pre[x][note][0],pre[x][note][1],1);
	write(x);
	if(!fir) return ;//判断不输出第一个->
	putchar('-');putchar('>');
}
signed main(){
	n=read(),m=read(),p=read(),s=read(),t=read();
	for(int x,y,z,i=1;i<=m;i++) x=read(),y=read(),z=read(),add(x,y,z);//有向图
	memset(dis,63,sizeof(dis));inf=dis[0][0];//清零
	dij();
	if(dis[t][0]==inf) puts("jjc fails in travelling");
	else write(dis[t][0]),putchar('\n'),print(t,0,0),putchar('\n');
}
```

---

## 作者：mrsrz (赞：0)

~~听说出题人卡了SPFA？听说SPFA随机数据跑的比Dijkstra快？~~

分层图最短路。

由于有余数的限制，我们可以将每个点拆成$P$个点，分别表示从$S$到这个点模$P$余$0,1,2,\dots,P-1$时的最短路。

然后在新图上跑Dijkstra即可。

建图的时候可以只建原图，这样用的边少。

然后跑Dijkstra即可，时间复杂度$O(nP\log n)$。

~~听说pbds过不去QAQ~~

手写个堆就好了，反正又不难~~写了个线段树优化T飞，是不是姿势不对啊QAQ~~。

## Code：
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<unistd.h>
#include<sys/mman.h>
#define N 65537
const int U=(1<<16)-1;
typedef long long LL;
class istream{
	char*in;
	public:
		inline istream(){in=static_cast<char*>(mmap(0,1<<24,PROT_READ,MAP_PRIVATE,STDIN_FILENO,0));}
		inline istream&operator>>(int&RHS){
			for(RHS=0;!isdigit(*in);++in);
			while(isdigit(*in))RHS=10*RHS+(*in++&15);
			in+=(*in=='\n');
			return*this;
		}
}cin;
struct ostream{
	char buf[10000005],*s;
	inline ostream(){s=buf;}
	template<typename T>
	inline ostream&operator<<(T d){
		if(!d){
			*s++='0';
		}else{
			static T w;
			for(w=1;w<=d;w*=10);
			for(;w/=10;d%=w)*s++=d/w^'0';
		}
		return*this;
	}
	inline ostream&operator<<(const char&c){*s++=c;return*this;}
	inline void flush(){
		fwrite(buf,1,s-buf,stdout);
		s=buf;
	}
	inline~ostream(){flush();}
}cout;
int n,m,p,S,T,head[N],cnt=0,nxt[N<<2],to[N<<2],dis[N<<2],out[N*200];
LL dd[N*51];
int pre[N*51];
struct hpn{
	int u;LL d;
}h[N*51];
int sz=0;
inline void insert(const hpn&b){
	h[++sz]=b;
	for(int i=sz;i!=1;i>>=1)
	if(h[i].d<h[i>>1].d)std::swap(h[i],h[i>>1]);else break;
}
inline hpn top_pop(){
	const hpn ret=h[1];
	h[1]=h[sz--];
	for(int i=1;i<<1<=sz;){
		const int nxt=(h[i<<1].d<h[i<<1|1].d||i<<1==sz)?(i<<1):(i<<1|1);
		if(h[nxt].d<h[i].d)std::swap(h[i],h[nxt]),i=nxt;else break;
	}
	return ret;
}
void spfa(){
	memset(dd,0x3f,sizeof dd);
	dd[S]=0;
	insert((hpn){S,0});
	while(sz){
		hpn u=top_pop();
		if(dd[u.u]!=u.d)continue;
		for(int i=head[u.u&U];i;i=nxt[i]){
			const int v=to[i]+(((u.u>>16)+dis[i])%p<<16);
			if(dd[v]>u.d+dis[i]){
				dd[v]=u.d+dis[i];
				pre[v]=u.u;
				insert((hpn){v,dd[v]});
			}
		}
	}
}
void work(){
	int tot=0;
	for(int i=T;i!=S;i=pre[i])out[++tot]=(i&U)+1;
	for(int i=tot;i;--i)cout<<'-'<<'>'<<out[i];
}
int main(){
	cin>>n>>m>>p>>S>>T;--S,--T;
	for(int u,v,t;m--;){
		cin>>u>>v>>t;
		to[++cnt]=v-1,nxt[cnt]=head[--u],head[u]=cnt,dis[cnt]=t;
	}
	spfa();
	LL ans=dd[T];
	if(ans>1e18)puts("jjc fails in travelling");else cout<<ans<<'\n'<<S+1,work();
	return 0;
}
```

---


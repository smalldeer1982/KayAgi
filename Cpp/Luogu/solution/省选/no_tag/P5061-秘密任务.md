# 秘密任务

## 题目背景

>飞雪连天射白鹿，笑书神侠倚碧鸳。

>谨纪念金庸先生。

 但是这与本题没有联系。


## 题目描述

wgr 是 $R$ 国军队总指挥官。现在，他决定组织两个小队分别去执行两个秘密任务。

wgr 将派出 $N$ 名战士来执行这两个任务，他们的编号为 $1 \sim N$ 。由于任务无比重要，wgr 需要使派出的队伍配合绝对默契 。配合绝对默契指队伍中**任何**两名战士的配合都是默契的。同时，他还需要使两个队伍的战斗力差距尽可能小，队伍的战斗力定义为 $F=2^{k}$，$k$ 为队伍的人数，不允许有人剩余。

wgr 已经知道哪些战士之间的配合是默契的，但由于时间紧迫，wgr 来不及慢慢整理资料了，现在，他请你以最快的速度帮他完成资料的整理，并告诉他：

1. 一共有多少种不同的分组方案。两种方案被认为是不同的当且仅当其两支队伍战斗力差值不同。
2. 所有分组方案中，最小的战斗力差值是多少，由于这个差值可能很大，请对  $10^9+7$ 取模后再输出。
3. 有多少对战士配合默契但是不可能被分在同一小组。

**注意：** 特别地，由于队伍的默契程度十分重要，一支队伍 $N$ 名战士另一支队伍 $0$ 名战士也是合法的分组方案。


## 说明/提示

本题共有三个 Subtask。

- Subtask 1：共 $5$ 个测试点，一个测试点 $5$ 分，满足 $N≤30$；
- Subtask 2：共 $3$ 个测试点，一个测试点 $10$ 分，满足 $N≤300$；
- Subtask 3：共 $3$ 个测试点，一个测试点 $15$ 分，满足 $N≤2500$。 

对于所有的数据，不会重复说明同一组关系，$1\le x,y\le  n$ 且 $x\neq y$。此外保证 $0\le m≤n\times (n-1)/2$。


本题开启 Special Judge：

- 若你的答案第一行输出正确你可以得到该测试点 $60\%$ 的分数；
- 若你的答案第二行输出正确你可以得到该测试点 $40\%$ 的分数。

为了确保你能够得到部分分，**请按格式要求输出**。


## 样例 #1

### 输入

```
4 4
3 4
1 2
2 4
2 3```

### 输出

```
2 0
0```

## 样例 #2

### 输入

```
10 2
1 7
3 5
```

### 输出

```
-1
2```

# 题解

## 作者：学无止境 (赞：7)

对于第 $(1)(2)$ 问，可以求补图再二分图匹配 ~~(不过出题人不会因此不讲这个)~~

加入第 $(3)$ 问就是为了卡掉上面的解法，其是本蒟蒻也不知道是否可行

出题人的解法有点非常规，不保证没有其他解法：

因为只分两组，我们可以进行第一次求解，先把一个人放到第一组，第二组为空，然后重复迭代对剩下的人进行放置，直到进行了一次迭代却一个人也没有放置(仅放置方案唯一的人，若两组都可以放，那么就先保留)

于是我们保留下来了一些人，也知道了目前在第一组的人必须与第二组的人分开。

我们可以对保留下来的人继续处理，进行第二/三/四......次求解，先把一个人放到第一组......

最后我们把所有的人都放完，得到一些关系，即同一次求解中得到的两组人必须分开，不同次求解得到的小组可以随意混合(在上述前提下)。

可以这样描述：

有 $A$ ，$B$ 两个等长无负值的序列

现在把$A$ ，$B$ 中的值分成两组，每一组的权值和代表的就是人数， $A[i]$ 和 $B[i]$ 不能存在于同一组，求能得到的无序权值二元组不同的分组方案数和两组权值最接近的一种方案。

进行动态规划即可求解第 $(1)(2)$ 问

对于第三问，利用刚刚提到的：

**同一次求解中得到的两组人必须分开，不同次求解得到的小组可以随意混合(在上述前提下)。**

就很容易求解了，我们可以标记每一个人属于第几次求解第几组，只要不在同一次求解的相反组就有可能分在同一组。



~~这个思想不是很好讲，我已经尽力了~~

考虑实现这个思想，我们使用 $dfs$，一次$dfs$负责同一次求解的迭代，一个$dfs$实现反复求解知道所有人都有了归属，因此最后是两个 $dfs $ 互相调用......这对代码实现能力有一定要求。

时间复杂度？一次求解至少分配一个人，求解调用的 $dfs$ 进行一次也一定分配至少一个人，否则就会回到求解过程，因此时间复杂度为$O(N^2)$

$Code:$
```

#include<iostream>
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
#define maxx(a,b) (a>b)?a:b
#define minx(a,b) (a<b)?a:b
#define mod 1000000007
inline int read()
{
    int q=0;
    char c=getchar();
    while(!isdigit(c))
        c=getchar();
    while(isdigit(c))
        q=q*10+c-'0',c=getchar();
    return q;
}
int matrix[2510][2510],s1[2510][2510],s2[2510][2510],tmp[2510],tmp1[2510][2510],tmp2[2510][2510],f[2510][2510],mem[710][2],data[2510*2500][2];
int n,m,pos,statistic,u,v,top,ans,max_ans;
void divide(int,int);
void solve(int[]);
void solve(int q[])
{
    if(!q[0])
        return;
    top++;
    s1[top][1]=q[1],s1[top][0]=1;
    mem[q[1]][0]=top,mem[q[1]][1]=1;
    for(register int i=2;i<=q[0];i++)
        tmp1[top][i-1]=q[i];
    tmp1[top][0]=q[0]-1;
    divide(top,2);
}

void divide(int x,int r)//x阶,放到哪 
{
    if(r==2)
    {
        bool flag=false;
        tmp2[x][0]=0;
        for(int i=1;i<=tmp1[x][0];i++)
        {
            pos=1;
            for(int j=1;j<=s1[x][0];j++)
                if(!matrix[tmp1[x][i]][s1[x][j]])
                {
                    pos=2;
                    flag=true;
                    break;
                }
            if(pos==2)	
            {
                for(int j=1;j<=s2[x][0];j++)
                    if(!matrix[tmp1[x][i]][s2[x][j]])
                    {
                        printf("-1\n%d",m);
                        exit(0);
                    }
                s2[x][++s2[x][0]]=tmp1[x][i],mem[s2[x][s2[x][0]]][0]=x,mem[s2[x][s2[x][0]]][1]=r;
            }
            else
                tmp2[x][++tmp2[x][0]]=tmp1[x][i];
        }
        if(flag)
            divide(x,1);
        else
            solve(tmp1[x]);
    }
    else
    {
        bool flag=false;
        tmp1[x][0]=0;
        for(int i=1;i<=tmp2[x][0];i++)
        {
            pos=2;
            for(int j=1;j<=s2[x][0];j++)
                if(!matrix[tmp2[x][i]][s2[x][j]])
                {
                    pos=1;
                    flag=true;
                    break;
                }
            if(pos==1)	
            {
                for(int j=1;j<=s1[x][0];j++)
                    if(!matrix[tmp2[x][i]][s1[x][j]])
                    {
                        printf("-1\n%d",m);
                        exit(0);
                    }
                s1[x][++s1[x][0]]=tmp2[x][i],mem[s1[x][s1[x][0]]][0]=x,mem[s1[x][s1[x][0]]][1]=r;
            }
            else
                tmp1[x][++tmp1[x][0]]=tmp2[x][i];
        }
        if(flag)
            divide(x,2);
        else
            solve(tmp2[x]);
    }
}

inline long long pow(int b,int p)
{
    long long g=1,base=b;
    while(p)
    {
        if(p&1)
            g*=base,g%=mod;
        p=p>>1,base*=base,base%=mod;
    }
    return g;
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        u=read(),v=read();
        data[i][0]=u,data[i][1]=v;
        matrix[u][v]=matrix[v][u]=1;
    }
    for(int i=1;i<=n;i++)
        tmp[i]=i;
    tmp[0]=n;
    solve(tmp);
    f[0][0]=1;
    for(int i=1;i<=top;i++)//动态规划过程
        for(int j=n;j>=0;j--)
            f[i][j]|=(f[i-1][j-s1[i][0]]|f[i-1][j-s2[i][0]]);
    for(int i=n/2;i>=0;i--)
        if(f[top][i])
        {
            if(!max_ans)
                max_ans=i;
            ans++;
        }
   for(register int i=1;i<=m;i++)
    	if(mem[data[i][0]][0]==mem[data[i][1]][0]&&mem[data[i][0]][1]!=mem[data[i][1]][1])
    		statistic++;
    printf("%d %lld\n%d",ans,(pow(2,n-max_ans)-pow(2,max_ans)+mod)%mod,statistic);
    return 0;
} 

```

---

## 作者：Monster_Qi (赞：3)

## 解题思路
　　$orz$出题人的神仙做法。本蒟蒻看不懂，就水个求补图再二分图染色的方法来$%1%$出题人。
　　
  
　　首先我们对图中$m$个关系连边，发现这样是没法做的，因为我们最后要关注的是谁和谁不能在一起，这个限制是比较大的。所以我们考虑建一个补图，就是把原来没有的边加边，原来存在的边断掉。这样$a$和$b$之间有边就代表$a$与$b$不能属于一个集合，这样就可能形成了若干个图。首先考虑判合法，因为一共只有两个集合，而每个人都必须放到集合里，关系还可以抽象成一张无向图，自然可以想到二分图染色了。我们只需要遍历每一个联通块，然后进行黑白染色判是否合法，只要有一个联通块不合法，那么也就$GG$了。
  
　　然后考虑算答案，判完合法之后，我们就可以知道一个了联通块中黑色和白色的不能属于一个集合，剩下的可以任意搭配，所以做一个背包就行了，把每个联通块黑色白色的个数记下来。设$f[i]$表示一个集合有$i$个人是否成立，转移的时候就模仿$0/1$背包，就是看每一个联通块是选黑色进去还是选白色进去。做完背包后一个人数合法仅当$f[i]=f[n-i]=true$。这样第一问和第二问的答案就统计出来了，对于第三问的答案，然后$n^2$枚举一下每对，如果两个人属于同一个联通块但颜色不相同，并且两个人在补图里没边，就使$ans3++$，这个也比较好理解，具体实现看代码。
　　
  
　　~~[打波广告](https://www.cnblogs.com/sdfzsyq/)~~
  
  
## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;
const int MAXN = 2505;
const int MOD = 1e9+7;
typedef long long LL;

inline int rd(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)) f=ch=='-'?0:1,ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return f?x:-x;
}

int n,m,a[MAXN][MAXN],tot,num,cnt1,cnt2,ans1,ans2,ans3;
int w[MAXN][2],f[MAXN],now[MAXN],col[MAXN],Min;
bool flag;

void dfs(int x,int c){
	col[x]=c;now[++tot]=x;if(c==1) cnt1++;else cnt2++;
	for(int i=1;i<=n;i++)
		if(a[i][x]){
			if(col[i]==col[x]) {flag=1;return;}
			if(!col[i]) dfs(i,3-c); 
		}
}

inline int fast_pow(int x,int y){
	int ret=1;
	for(;y;y>>=1){
		if(y&1) ret=(LL)ret*x%MOD;
		x=(LL)x*x%MOD;
	}
	return ret;
}

int main(){
	int x,y;n=rd(),m=rd();
	for(int i=1;i<=m;i++){
		x=rd(),y=rd();
		a[x][y]=a[y][x]=1;
	}
	for(int i=1;i<=n;i++)	
		for(int j=1;j<=n;j++)
			if(i!=j) a[i][j]^=1;
	for(int i=1;i<=n;i++) if(!col[i]){
		cnt1=cnt2=tot=0;memset(now,0,sizeof(now));
		dfs(i,1);if(flag) break;
		for(int j=1;j<=tot;j++)
			for(int k=j+1;k<=tot;k++)
				if(col[now[j]]!=col[now[k]] && !a[now[j]][now[k]]) ans3++; 
		w[++num][0]=cnt1;w[num][1]=cnt2;
	}f[0]=1;
	for(int i=1;i<=num;i++){
		Min=min(w[i][0],w[i][1]);
		for(int j=n;j>=Min;j--){
			if(j>=w[i][0]) f[j]|=f[j-w[i][0]];
			if(j>=w[i][1]) f[j]|=f[j-w[i][1]];	
		}	
	}
	for(int i=0;i<=n/2;i++){
		if(!f[i] || !f[n-i]) continue;
		ans1++;ans2=i;
	}
	if(flag) puts("-1"),ans3=m; //注意一下这里，如果没有方案的话自然$m$对可以合作的人都无法在一个集合里
	else printf("%d %d\n",ans1,(fast_pow(2,n-ans2)-fast_pow(2,ans2)+MOD)%MOD);
	printf("%d\n",ans3);
	return 0;
} 
```
  

---

## 作者：MikukuOvO (赞：3)

$stO$ 出题人，高质量的一道题

首先我们考虑做法

$Q1$:原图中给出的边是可以在同一组，那么原图的补图的边就是不再同一组，我们对于每一个联通块进行二分图染色，至此可以判断是否合法，对于方案数，由于要求分组人数不同，那么我们考虑在二分图染色时记录每个联通块黑白点个数，进行动态规划,$num$为联通块个数。

$f[i][j]|=f[i-1][j-a[i][0]]|f[i-1][j-a[i][1]]$

至此，我们可以求出那些分组方案合法：只要$f[num][i]$为$true$即可（因为如果原二分图合法且$f[num][i]$合法那么$f[num][n-i]$一定合法。

$Q2$:对于最小差值方案，就是$max_{i=0}^{n/2}$ $i$ $[f[num][i]==1]$和$n-i$

$Q3$:对于这个问题，看到其他题解都是暴力枚举$i$,$j$，这里提供一个简单做法，考虑容斥原理：所有不能在一起的对数$-$配合**不**默契不能在一起的对数

就是$\sum_{i=1}^{num}$ $a[i][0]*a[i][1]-cnt$($cnt$为补图的边数，也就是配合不默契不能在一起的有多少对）

代码。。。(不压维，不卡常。。。懒惰)


```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;

#define il inline
#define LL long long

const int N=2505;
const LL mod=1e9+7;

struct EDGE
{
	int to,nxt;
};

int n,m,cnt=1,num;
LL ans,sigma=0;
int col[N],head[N],idx[N],f[N][N],a[N][2];
bool vis[N][N],hav[N*N*2];
queue<int>q;
EDGE e[N*N];

il void add(int x,int y)
{
	e[++cnt].to=y;
	e[cnt].nxt=head[x];
	head[x]=cnt;
}
il void bfs()
{
	memset(col,-1,sizeof(col));
	for(int k=1;k<=n;++k)
	{
		if(col[k]!=-1) continue;
		q.push(k),col[k]=0,num++;
		int cnt1=0,cnt2=0;
		while(!q.empty())
		{
			int x=q.front();
			if(col[x]) cnt2++;
			else cnt1++;
			q.pop();
			for(int i=head[x];i;i=e[i].nxt)
			{
				if(hav[i]) continue;
				if(col[e[i].to]==col[x]) {ans=-1;return;}
				if(col[e[i].to]==-1) q.push(e[i].to);
				col[e[i].to]=col[x]^1;
			}
		}
		a[num][0]=cnt1,a[num][1]=cnt2;
		sigma+=a[num][0]*a[num][1];
	}
}
il LL qpow(LL x,LL y)
{
	LL ggg=1;
	while(y)
	{
		if(y&1) ggg=x*ggg%mod;
		x=x*x%mod;
		y>>=1;
	}
	return ggg%mod;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;++i) scanf("%d%d",&x,&y),vis[x][y]=1,vis[y][x]=1;
	for(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) if(!vis[i][j]) add(i,j),add(j,i),idx[i]++,idx[j]++;
	bfs();
	if(ans==-1) {printf("%lld\n%d\n",ans,m);return 0;}
	f[0][0]=1;
	for(int i=1;i<=num;++i)
	{
		for(int j=0;j<=n;++j)
		{
			if(j>=a[i][0]) f[i][j]|=f[i-1][j-a[i][0]];
			if(j>=a[i][1]) f[i][j]|=f[i-1][j-a[i][1]];
		}
	}
	int pos;
	for(int i=0;i<=n/2;++i) if(f[num][i]) ans++,pos=i;
	printf("%lld ",ans);
	printf("%lld\n",(qpow(2ll,(n-pos)*1ll)-qpow(2ll,pos*1ll)+mod)%mod);
	printf("%lld\n",sigma-cnt/2);
	return 0;
}
```

---

## 作者：AC基德 (赞：1)

# 题解 P5061 【秘密任务】
对于第 (1)(2)(1)(2) 问，可以求补图再二分图匹配 (不过出题人不会因此不讲这个)

加入第 (3)(3) 问就是为了卡掉上面的解法，其是本蒟蒻也不知道是否可行

## 出题人的解法有点非常规，不保证没有其他解法：

因为只分两组，我们可以进行第一次求解，先把一个人放到第一组，第二组为空，然后重复迭代对剩下的人进行放置，直到进行了一次迭代却一个人也没有放置(仅放置方案唯一的人，若两组都可以放，那么就先保留)

#### 于是我们保留下来了一些人，也知道了目前在第一组的人必须与第二组的人分开。

我们可以对保留下来的人继续处理，进行第二/三/四......次求解，先把一个人放到第一组......

最后我们把所有的人都放完，得到一些关系，即同一次求解中得到的两组人必须分开，不同次求解得到的小组可以随意混合(在上述前提下)。

### 可以这样描述：

有 AA ， BB 两个等长无负值的序列

现在把 AA ， BB 中的值分成两组，每一组的权值和代表的就是人数， A[i]A[i] 和 B[i]B[i] 不能存在于同一组，求能得到的无序权值二元组不同的分组方案数和两组权值最接近的一种方案。

### 进行动态规划即可求解第 (1)(2)(1)(2) 问

对于第三问，利用刚刚提到的：

同一次求解中得到的两组人必须分开，不同次求解得到的小组可以随意混合(在上述前提下)。

就很容易求解了，我们可以标记每一个人属于第几次求解第几组，只要不在同一次求解的相反组就有可能分在同一组。

这个思想不是很好讲，我已经尽力了

考虑实现这个思想，我们使用 dfsdfs，一次 dfsdfs负责同一次求解的迭代，一个 dfsdfs实现反复求解知道所有人都有了归属，因此最后是两个 dfsdfs 互相调用......这对代码实现能力有一定要求。

## 时间复杂度？一次求解至少分配一个人，求解调用的 dfsdfs 进行一次也一定分配至少一个人，否则就会回到求解过程，因此时间复杂度为 O(N^2)O(N）


废话不多，直接上代码（c++解法）、

```c
#include<iostream>
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
#define maxx(a,b) (a>b)?a:b
#define minx(a,b) (a<b)?a:b
#define mod 1000000007
inline int read()
{
    int q=0;
    char c=getchar();
    while(!isdigit(c))
        c=getchar();
    while(isdigit(c))
        q=q*10+c-'0',c=getchar();
    return q;
}
int matrix[2510][2510],s1[2510][2510],s2[2510][2510],tmp[2510],tmp1[2510][2510],tmp2[2510][2510],f[2510][2510],mem[710][2],data[2510*2500][2];
int n,m,pos,statistic,u,v,top,ans,max_ans;
void divide(int,int);
void solve(int[]);
void solve(int q[])
{
    if(!q[0])
        return;
    top++;
    s1[top][1]=q[1],s1[top][0]=1;
    mem[q[1]][0]=top,mem[q[1]][1]=1;
    for(register int i=2;i<=q[0];i++)
        tmp1[top][i-1]=q[i];
    tmp1[top][0]=q[0]-1;
    divide(top,2);
}

void divide(int x,int r)//x阶,放到哪 
{
    if(r==2)
    {
        bool flag=false;
        tmp2[x][0]=0;
        for(int i=1;i<=tmp1[x][0];i++)
        {
            pos=1;
            for(int j=1;j<=s1[x][0];j++)
                if(!matrix[tmp1[x][i]][s1[x][j]])
                {
                    pos=2;
                    flag=true;
                    break;
                }
            if(pos==2)  
            {
                for(int j=1;j<=s2[x][0];j++)
                    if(!matrix[tmp1[x][i]][s2[x][j]])
                    {
                        printf("-1\n%d",m);
                        exit(0);
                    }
                s2[x][++s2[x][0]]=tmp1[x][i],mem[s2[x][s2[x][0]]][0]=x,mem[s2[x][s2[x][0]]][1]=r;
            }
            else
                tmp2[x][++tmp2[x][0]]=tmp1[x][i];
        }
        if(flag)
            divide(x,1);
        else
            solve(tmp1[x]);
    }
    else
    {
        bool flag=false;
        tmp1[x][0]=0;
        for(int i=1;i<=tmp2[x][0];i++)
        {
            pos=2;
            for(int j=1;j<=s2[x][0];j++)
                if(!matrix[tmp2[x][i]][s2[x][j]])
                {
                    pos=1;
                    flag=true;
                    break;
                }
            if(pos==1)  
            {
                for(int j=1;j<=s1[x][0];j++)
                    if(!matrix[tmp2[x][i]][s1[x][j]])
                    {
                        printf("-1\n%d",m);
                        exit(0);
                    }
                s1[x][++s1[x][0]]=tmp2[x][i],mem[s1[x][s1[x][0]]][0]=x,mem[s1[x][s1[x][0]]][1]=r;
            }
            else
                tmp1[x][++tmp1[x][0]]=tmp2[x][i];
        }
        if(flag)
            divide(x,2);
        else
            solve(tmp2[x]);
    }
}

inline long long pow(int b,int p)
{
    long long g=1,base=b;
    while(p)
    {
        if(p&1)
            g*=base,g%=mod;
        p=p>>1,base*=base,base%=mod;
    }
    return g;
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        u=read(),v=read();
        data[i][0]=u,data[i][1]=v;
        matrix[u][v]=matrix[v][u]=1;
    }
    for(int i=1;i<=n;i++)
        tmp[i]=i;
    tmp[0]=n;
    solve(tmp);
    f[0][0]=1;
    for(int i=1;i<=top;i++)//动态规划过程
        for(int j=n;j>=0;j--)
            f[i][j]|=(f[i-1][j-s1[i][0]]|f[i-1][j-s2[i][0]]);
    for(int i=n/2;i>=0;i--)
        if(f[top][i])
        {
            if(!max_ans)
                max_ans=i;
            ans++;
        }
   for(register int i=1;i<=m;i++)
        if(mem[data[i][0]][0]==mem[data[i][1]][0]&&mem[data[i][0]][1]!=mem[data[i][1]][1])
            statistic++;
    printf("%d %lld\n%d",ans,(pow(2,n-max_ans)-pow(2,max_ans)+mod)%mod,statistic);
    return 0;
} 

```


完结撒花！！

本蒻蒟的第2篇题解，请各位大佬多多包容。




 

---


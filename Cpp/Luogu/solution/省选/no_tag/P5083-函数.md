# 函数

## 题目描述

小奔有一个二元函数 $f(a,b)$。

如果 $a<2$ 或 $b<2$ 返回 $a+b$。

其他情况则返回以下四个式子的最大值（除号均为整除）：

$$a+b$$

$$g(a/2)+g(a/3)+g(a/8)+g(a/9)+b$$

$$g(b/2)+g(b/3)+g(b/8)+g(b/9)+a$$

$$g(b/2)+g(b/3)+g(b/8)+g(b/9)+g(a/2)+g(a/3)+g(a/8)+g(a/9)$$

其中，$g(n)$ 返回 $\max(g(n/2)+g(n/3)+g(n/8)+g(n/9),n)$，当 $n=0$ 时返回 $0$。

当然，白痴都想得到可以记忆化求出较小的 $f(a,b)$，所以小奔才不会考你那么简单的题呢。

他想问你当 $a,b$ 都小于 $10^{16}$ 时，$f(a,b)$ 的值。


## 说明/提示

对于 $40\%$ 的数据，$a,b<10^7$。

对于 $70\%$ 的数据，时间限制 $2$ 秒。

对于 $100\%$ 的数据，$a,b<10^{16}$。数据组数不超过 $10^4$ 组。

## 样例 #1

### 输入

```
5 6
1 1
1 223```

### 输出

```
11
2
224```

# 题解

## 作者：Johndoe (赞：4)

一开始的想法是记忆化搜索，但是数据范围内存会爆炸。
试验之后会发现当n较大时总是有一长串相同（好像0-10000里面只有400+个不同值），于是就会想用别的方式储存数据。
所以struct个a[MAXN]出来储存数据。
```
struct func{
	ull start,end,value;
}a[MAXN+1];
```

然后我们研究一下其实是可以发现，end[i],start[i],value[i]，在i比较大的情况下是有递推关系的（i指第i个区间）


```
	start[num]=end[num-1]+1;
	value[num]=max(start[num],value[search(start[num]/2)]+value[search(start[num]/3)]+value[search(start[num]/8)]+value[search(start[num]/9)]);
	end[num]=min(ai*(end[search(start[num]/ai)]+1))-1;(ai=2,3,8,9)
```
其中search（n）是寻找n在那个区间的一个函数
但是当i比较小的情况不一定成立，因为这个递推式是在max(g(n/2)+g(n/3)+g(n/8)+g(n/9),n)=g(n/2)+g(n/3)+g(n/8)+g(n/9)的情况下成立的
可以证明当n比较大时情况的确如此
附代码
```
#include<iostream>
#include<cmath>
#define ull unsigned long long
#define MAXN 100010
using namespace std;
struct func{
	ull start,end,value;
}a[MAXN+1];
ull num=0;
ull search (ull n){
	ull l=0,r=num,mid=(l+r)/2;
	while (r>l){
		mid=(l+r)/2;
		if (n>a[mid].end)l=mid;
		else if (n<a[mid].start)r=mid;
		else if (n>=a[mid].start&&n<=a[mid].end)return mid;
		else if (n>=a[l].start&&n<=a[l].end)return l;
		else if (n>=a[r].start&&n<=a[r].end)return r;
		else return mid; 
	}
	return mid;
}
ull g(ull n){
	if (n==0)return 0;
	else return max(n,g(n/2)+g(n/3)+g(n/8)+g(n/9));
}
int main(){
	ull n=1e17;
	a[0].start=a[0].end=a[0].value=0;
//	for (ull i=0;i<=n;i++)cout<<i<<" "<<g(i)<<endl;
	for (ull i=1;i<=200;i++){
		if (g(i)!=g(i-1)){
			a[++num].start=i;
			a[num-1].end=i-1;
			a[num].value=g(i);
		}
	}
	while (a[num].end<2*n){
		++num;
		a[num].start=a[num-1].end+1;
		a[num].value=max(a[num].start,a[search(a[num].start/2)].value+a[search(a[num].start/3)].value+a[search(a[num].start/8)].value+a[search(a[num].start/9)].value);
		a[num].end=min(2*(a[search(a[num].start/2)].end+1),min(3*(a[search(a[num].start/3)].end+1),min(8*(a[search(a[num].start/8)].end+1),9*(a[search(a[num].start/9)].end+1))))-1;
	}
//	ull t=n;
//	for (n=0;n<=t;n++)if (a[search(n)].value!=g(n))
long long x,y;
while(cin>>x>>y){
if (x<2||y<2)cout<<x+y<<endl;
else if (x<0)cout<<x+a[search(y)].value<<endl ;
else if (y<0)cout<<y+a[search(x)].value<<endl;
else cout<<a[search(x)].value+a[search(y)].value<<endl;
}
//	cout<<a[search(n)].value<<endl;
}

```
61ms 应该算是比较快的了

---

## 作者：Jμdge (赞：4)

这道题我们考虑暴力的做法即可。

做法大致就是模拟题目的想法，不过加了两样东西：预处理以及map记忆化。

首先我们想想那一长串的式子：

$ f(a,b)=max(a+b,g(a/2)+g(a/3)+g(a/8)+g(a/9)+b,$
$g(b/2)+g(b/3)+g(b/8)+g(b/9)+a,$
$g(b/2)+g(b/3)+g(b/8)+g(b/9)+g(a/2)+g(a/3)+g(a/8)+g(a/9))$


以及 
$ g(n)=max(g(n/2)+g(n/3)+g(n/8)+g(n/9),n) $


那么我们可以看出 f(a,b) 的表达式可以直接转化为 $f(a,b)=g(a)+(b)$

因为原表达式其实就是：
>$f(a,b)=max(a,g(a/2)+g(a/3)+g(a/8)+g(a/9))+$
>$max(b,g(b/2)+g(b/3)+g(b/8)+g(b/9))$

这点没毛病对吧。

那么两个max 就直接转化为了 $g(a)+g(b)$ 了。

然后我们预处理完 g 函数就可以轻松拿到 40 分。

接着呢， 我们考虑 map 的记忆化：

对于数据范围超过 1e7 的数字，我们考虑直接深搜记忆化，如果计算过直接返回值。

然后这题就这么草率的 A 掉了。。。也不知道正解是什么
~~能A就是正解！！！~~

话说我比赛的时候用了scanf 被卡掉了 30 分？ $WTF$  `(╯‵□′)╯︵┻━┻`


然后上代码（优化过的代码 270ms+ ,下面的代码只有一点小优化）


```
//by Judge
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a,b,g[1000007];
map<ll,ll> gg;
ll f(ll n){ if(n<=1000000) return g[n];
    if(gg[n]) return gg[n];
    return gg[n]=max(f(n/2)+f(n/3)+f(n/8)+f(n/9),n);
}
int main(){
    for(ll n=1;n<=100000;++n)
        g[n]=max(g[n/2]+g[n/3]+g[n/8]+g[n/9],n);
    while(cin>>a>>b) cout<<f(a)+f(b)<<endl;
	return 0;
}
```

---

## 作者：critnos (赞：2)

卡常是神奇的。

首先你写了一个记忆化的 $g(n)$，但是怎么卡常都卡不进 200ms。说句闲话，先预处理出 $5\times 10^6$ 内的 $g(n)$ 还是有一定的卡常效果的，虽然并不需要这样也能过。

然后你发现这个函数其实在 $10^{16}$ 内的取值是非常少的，只有 5000 多个。

然后就可以在一开始就预处理出每个取值的左右端点（事实上左端点就可以了）和值，然后查询的时候大力上二分。

你想了想发现似乎并没有整除分块那样的性质，可以直接用左端点推出右端点。（但其实看了 Johndoe 的题解之后发现是有的）

迫不得已之下只能选择了倍增。即通过左端点倍增出右端点。

效果不错，卡进 400ms 了。但是一直都是 350ms 的这个样子。

然后就没有什么对计算 $g$ 的卡常了。

那只能对倍增本身卡常了。

倍增的上界原本选择的是 $\lfloor \log 10^{16} \rfloor=53$ 的，小心翼翼的调了一下发现竟然可以调到 $45$！因为其实右端点和左端点的距离并没有那么大。

这样一下子就卡到了 200+ms ！这启发我们调整倍增上界。

打表发现，其实每个左端点对应的倍增上界是不同的。相对来说，设左端点为 $l$，那么 $l$ 越大倍增上界也越大。经过试验，每次的倍增上界可以选择 $\lfloor \log l-6 \rfloor$。

这样就卡到了 160ms。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=8010007;
struct has
{
	struct node
	{
		int nxt;
		ll v,key;
	}a[10000000];
	int head[mod+5];
	int cnt;
	ll add(ll key,ll v)
	{
		a[++cnt].nxt=head[key%mod];
		a[cnt].v=v;
		a[cnt].key=key;
		head[key%mod]=cnt;
		return v;
	}
	ll find(ll x)
	{
		for(int i=head[x%mod];i;i=a[i].nxt)
			if(a[i].key==x)
				return a[i].v;
		return 0;
	}
}dp;
const int mxn=5e6;
int dp2[mxn+5];
ll g(ll n)
{
	if(n<=mxn) return dp2[n];
	ll ans=dp.find(n);
	if(ans) return ans;
	return dp.add(n,max(g(n/2)+g(n/3)+g(n/8)+g(n/9),n));
}
ll li[6000],ans[6000];
int cnt;
ll g2(ll n)
{
	return ans[upper_bound(li,li+cnt,n)-li-1];
}
int main()
{
	ll a,b,i,l,r;
	for(int i=1;i<=mxn;i++)
		dp2[i]=max(i,dp2[i/2]+dp2[i/3]+dp2[i/8]+dp2[i/9]);
	for(l=0;l<=1e16;l=r+1)
	{
		a=g(l);
		for(r=l,i=1ll<<int(log2(l)-6);i>=1;i>>=1)
			if(r+i<=1e16&&g(r+i)==a)
				r+=i;
		li[cnt]=l,ans[cnt++]=a;
	}	
	while(~scanf("%lld%lld",&a,&b))
	{
		if(a<2||b<2) printf("%lld\n",a+b);
		else printf("%lld\n",g2(a)+g2(b));
	}
}
```


---

## 作者：ShineEternal (赞：2)

这道题貌似只有@AKEE 大佬A掉，恭喜！

还有因为c++中支持两个参数数量不同的相同名称的函数调用，所以当时就没改成两个函数，这里表示抱歉。

这道题可直接用指针+hash一下，然后就模拟即可。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mo=10000000;
struct node 
{
    long long int state,ans;
    node* next;
}*Hash[Mo+10],*p;
long long max(long long a,long long b,long long c,long long d,long long e) 
{
    return max(a,max(b,max(c,max(d,e))));
}
long long max(long long a,long long b,long long c,long long d) 
{
    return max(a,max(b,max(c,d)));
}
long long f(long long x) 
{
    if(x==0)return 0;
    p=Hash[x%Mo];
    while(p!=NULL)
    {
        if(p->state==x)return p->ans;
        p=p->next;
    }
    long long anss=max(x,f(x/2)+f(x/3)+f(x/8)+f(x/9));
    p=new node;
    p->state=x;
    p->ans=anss;
    p->next=Hash[x%Mo];
    Hash[x%Mo]=p;
    return anss;
}
long long f(long long a,long long b) 
{
    long long anss=max(a+b,f(a/2)+f(a/3)+f(a/8)+f(a/9)+b,f(b/2)+f(b/3)+f(b/8)+f(b/9)+a,f(b/2)+f(b/3)+f(b/8)+f(b/9)+f(a/2)+f(a/3)+f(a/8)+f(a/9));
    return anss;
}
int main() 
{
	//freopen("function.in","r",stdin);
	//freopen("function.out","w",stdout);
    long long int a,b;
    while(cin>>a>>b) 
    {
        cout<<f(a,b)<<endl;
    }
    return 0;
}
```

---


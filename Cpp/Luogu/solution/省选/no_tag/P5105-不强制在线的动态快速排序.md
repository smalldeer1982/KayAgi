# 不强制在线的动态快速排序

## 题目背景

曦月最近学会了快速排序，但是她很快地想到了，如果要动态地排序，那要怎么办呢？


## 题目描述

为了研究这个问题，曦月提出了一个十分简单的问题

曦月希望维护一个允许重复的集合$S$，支持：

* 插入$[L, R]$，也就是插入$L, L + 1 ... , R$，这$R - L + 1$个数

* 询问$Sort(S)$

---

$Sort(S)$的定义为：

我们将集合$S$中的元素**从小到大按照快速排序**排好序，记为$a_1, a_2 ... a_n$

那么，$Sort(S) = \bigoplus \limits_{i = 2}^n (a_i^2 - a_{i - 1}^2)$，其中$\bigoplus$表示异或和

关于异或的定义，请咨询度娘

## 说明/提示

对于样例一的解释：

$S$中只有一个数，因此返回$0$

---

对于$30$分的数据，$q \leqslant 100$

对于$50$分的数据，$q \leqslant 5 * 10^4$

对于另外的$20$分的数据，满足$L = R$

对于$100$分的数据，$q \leqslant 3 * 10^5$，$1 \leqslant L \leqslant R \leqslant 10^9$

保证数据有梯度，可能略微地有卡常，请把自己的常数优化到极致

## 样例 #1

### 输入

```
2
1 1 1
2
```

### 输出

```
0
```

## 样例 #2

### 输入

```
10
1 22 27
1 50 55
1 82 87
1 2 7
2
1 47 52
1 62 67
1 61 66
1 41 46
2```

### 输出

```
2515
2141
```

# 题解

## 作者：Yahbim (赞：10)

给一发有证明过程的题解：

考虑 $S=[1,n]$ 的情况。

结论：

$Sort(S)=\begin{cases}
0 &n\equiv 0 \pmod 4\\
2n-1 &n\equiv 1 \pmod 4\\
2 &n\equiv 2 \pmod 4\\
2n+1 &n\equiv 3 \pmod 4
\end{cases}$

证明：

设 $f(x,y)$ 为区间 $[x,y]$ 中所有奇数的异或和。

$\begin{aligned}
Sort(S)&=\bigoplus\limits_{i=1}^n(a_i^2-a_{i-1}^2)\\
&=\bigoplus\limits_{i=1}^n(i^2-(i-1)^2)\\
&=\bigoplus\limits_{i=1}^n(2i+1)\\
&=f(1,2n-1)
\end{aligned}$

考虑 **把每个数写成二进制形式** ，小的在上，大的在下，排在一块。从右至左，以 $0$ 开始，依次给位数编号。

因为对于 $k\geq 1$ ，$f(2^k,2^{k+1}-1)$ 中有偶数个奇数，这些奇数的异或和中，最高位 $k$ 经过了偶数次异或，被消去，原式的值取决于 $[0,k-1]$ 位的异或和，所以有

$f(2^k,2^{k+1}-1)=f(1,2^k-1)$ 

从而

$\begin{aligned}
f(1,2^{k+1}-1)&=f(1,2^k-1)\oplus f(2^k,2^{k+1}-1)\\
&=f(1,2^k-1)\oplus f(1,2^k-1)\\
&=0
\end{aligned}$

再来看 $Sort(S)=f(1,2n-1)$ ，令 $k$ 为满足 $2^k \leq 2n-1 $ 的最大整数，此时我们发现

$\begin{aligned}
f(1,2n-1)&=f(1,2^k-1) \oplus f(2^k,2n-1)\\
&=0 \oplus f(2^k,2n-1)\\
&= f(2^k,2n-1)
\end{aligned}$

运用和上文同样的思想，
>“对于 $k\geq 1$ ，$f(2^k,2^{k+1}-1)$ 中有偶数个奇数，这些奇数的异或和中，最高位 $k$ 经过了偶数次异或，被消去。”

我们分类讨论：

当 $n$ 为偶数时， $f(2^k,2n-1)$ 中有偶数个奇数。同理，最高位 $k$ 被消去。接下来求解 $(1,2n-1-2^{k-1})$ ，而它又等于 $(2^{k-1},2n-1-2^{k-1})$ , $k-1$ 位又会被消去……如此循环，最后在 $k=1$ 时，此性质不再能推导出 $k=0$ 的情况，最后得到了偶数个值为 $01$ 或 $11$ 的二进制数。这些数求异或和，四个数成一组消去。所以当 $n$ 为偶数时，若 $n\equiv 0 \pmod 4$ ，那么所有数都被消去，总结果为 $0$ ；若 $n\equiv 2 \pmod 4$ ，那么还剩下一个 $01$ 和一个 $11$ ，异或起来是 $2$ ，总结果也就是 $2$ 。

当 $n$ 为奇数时， $f(2^k,2n-1)$ 中有奇数个奇数，不管 $2n-1$ 在当前位上是 $0$ 还是 $1$ ，除了它之外的奇数都有偶数个，都会全部消去， **当前位有且仅有 $2n-1$ 这个项的贡献** 。依然循环求解 $f(2^{k-1},2n-1-2^{k-1})$ ，直到 $k=1$ 时，讨论:若 $n\equiv 1 \pmod 4$ ，那么又只剩下 $2n-1$ 它自己项的贡献，总结果自然就是 $2n-1$ ;若 $n\equiv 3 \pmod 4$ ,那么还会剩下两个 $01$ 和一个 $11$ ，它们异或和是 $11$ ，是 $2n-1$ 此时的贡献 $01$ 再加了 $2$ ，而之前所有位的结果都等于 $2n-1$ 在该位上的贡献，所以总结果就是 $2n-1$ 再加 $2$ ，即 $2n+1$ 。

综上，
$Sort(S)=\begin{cases}
0 &n\equiv 0 \pmod 4\\
2n-1 &n\equiv 1 \pmod 4\\
2 &n\equiv 2 \pmod 4\\
2n+1 &n\equiv 3 \pmod 4
\end{cases}$

证毕。

进一步地，对于询问 $f(l,r)$ ，都有 $f(l,r)=f(1,r)\oplus f(1,l)$ 。注意不是 $f(1,l-1)$ ，因为要删除 $l$ 和 $l-1$ 之间的贡献 $l^2-(l-1)^2$ 。

然后用线段树维护，把每一次区间修改下放到若干节点中，每个节点都是满的，解决了不连续的问题。再采用动态开点，解决了定义域过大的问题。

最后附上代码：
```cpp
#include<bits/stdc++.h>
#define mid ((l+r)>>1)
#define ls (tr[tr[u].l])
#define rs (tr[tr[u].r])
using namespace std;
const int N=3e5+5,INF=1e9;////1e9
typedef long long ll;
struct queryer{
	int l,r,type;
}qry[N];
struct treer{
	int l,r,min,max;
	ll val;
	bool vis;
}tr[35*N];
int q,cnt,rt;

ll calc(int p){
	if(p%4==0) return 0;
	if(p%4==1) return 2*p-1;
	if(p%4==2) return 2;
	else return 2*p+1;
}

void pushup(int u,int l,int r){
	if(!tr[u].l)
		return (void)(tr[u].val=rs.val,tr[u].min=rs.min,tr[u].max=rs.max);
	if(!tr[u].r)
		return (void)(tr[u].val=ls.val,tr[u].min=ls.min,tr[u].max=ls.max);
	tr[u].val=ls.val^rs.val^((ll)rs.min*rs.min-(ll)ls.max*ls.max);
	tr[u].min=ls.min,tr[u].max=rs.max;
}

void update(int &u,int l,int r,int st,int ed){
	if(l>ed || r<st || tr[u].vis) return;
	if(!u) u=++cnt;
	if(l>=st && r<=ed)	return (void)(tr[u]=(treer){0,0,l,r,calc(r)^calc(l),1});
	update(tr[u].l,l,mid,st,ed),update(tr[u].r,mid+1,r,st,ed);
	pushup(u,l,r);
}
		
int main(){
    scanf("%d",&q);
    for(int i=1;i<=q;i++){
    	scanf("%d",&qry[i].type);
		if(qry[i].type==2) continue;
		scanf("%d%d",&qry[i].l,&qry[i].r);
	}
	for(int i=1;i<=q;i++){
		if(qry[i].type==2) printf("%lld\n",tr[rt].val);
		else update(rt,1,INF,qry[i].l,qry[i].r);
	}
	return 0;
}
```
ps:~~这题差点被你谷管理员CYJian从黑题改成蓝题，原因是太简单~~


---

## 作者：ComplexPug (赞：9)

大佬的c++11和stl实在看不懂啊

蒟蒻就在这里用蒟蒻的方法让别人看懂吧

## 思路
题目看着很方啊，难道要树套树？

但数据范围提醒我们，是nlogn的复杂度

Sort(S)的定义是不是很鬼畜

但我们~~不动脑子的~~打表容易发现

连续区间[1，n]内$a_i^2-a_{i-1}^2$为连续的奇数

（其实这里直接用初中的完全平方公式就好）

我们再次打表又发现了

连续的奇数的异或和，很有规律的嘛

这里%%二进制大佬,但其实可以直接O（1）求出

```cpp
int xx(int x) {
    if(x%4==0) return 0;
	if(x%4==2) return 2;
	if(x%4==1) return x+x-1;
	return x+x+1;
}
```

根据异或的性质(a^a=0)

我们就能计算出任意连续一段的ans了，$xx(l-1)$^$xx(r)$

虽说允许重复的集合S

但区间如果重叠，他也只计算一次答案，手玩一下很容易看出

也就是集合S还是不允许重复的(重复的删掉是不影响答案的)

合并直接算就好了

我们现在需要一个只需要支持区间更改贡献的数据结构

lsh+线段树真香

```cpp
struct node {
	int l,r,lazy;
    int mi,ma,sum;
	int full,k;
} e[maxn<<4];
/*
	mi,ma维护区间[l,r]最小值
	lazy懒惰标记
	ok判断区间[l,r]是否全部被计算答案
	k判断[mid,mid+1]之间是否连接
	ans就是ans啦
*/
```
ps：可能我的线段树调试的时候打了太多补丁，肯定有比我写的好得多的代码

但也是不难理解的，重要部分我们加以注释

关于int，是会炸的，反正我的数据灰渣

另外提醒

千万别开小了数组,一组询问是两个数偶，我一直报WA

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define FOR(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
const int maxn=3e5+7;
const ll inf=0x3f3f3f3f3f3f3f3fLL;
int read() {
    int x=0,f=1;char s=getchar();
    for(; s>'9'||s<'0'; s=getchar()) if(s=='-') f=-1;
    for(; s>='0'&&s<='9'; s=getchar()) x=x*10+s-'0';
    return x*f;
}
ll xx(ll x) {
    if(x%4==0) return 0;
    if(x%4==2) return 2;
    if(x%4==1) return x+x-1;
    return x+x+1;
}
ll calc(ll l,ll r) {return xx(r)^xx(l-1);}
struct node {
    int l,r;
    ll mi,ma,sum;
	bool full,k,lazy;
} e[maxn<<4];
int lsh[maxn<<1],len;
void pushup(int rt) {
    if(e[rt].full) return;
    if(e[rt].k) // 区间[mid,mid+1]贡献 需要计算 
        e[rt].sum=e[rt<<1].sum^e[rt<<1|1].sum^calc(lsh[e[rt<<1].r]+1,lsh[e[rt<<1|1].l]);
    else if(e[rt<<1].ma==-inf||e[rt<<1|1].mi==inf) //只有一边有值 
        e[rt].sum=e[rt<<1].sum^e[rt<<1|1].sum;
    else //暴力计算 
        e[rt].sum=e[rt<<1].sum^e[rt<<1|1].sum^(e[rt<<1|1].mi*e[rt<<1|1].mi-e[rt<<1].ma*e[rt<<1].ma);

    e[rt].ma=max(e[rt<<1].ma,e[rt<<1|1].ma);
    e[rt].mi=min(e[rt<<1].mi,e[rt<<1|1].mi);
}
void tag(int rt) {//区间全部计算ans 
    e[rt].sum=calc(lsh[e[rt].l]+1,lsh[e[rt].r]);
    e[rt].full=1;
    e[rt].mi=lsh[e[rt].l];
    e[rt].ma=lsh[e[rt].r];
}
void pushdown(int rt) {
    if(e[rt].lazy==0) return;
    if(e[rt].lazy) {//显然 
        tag(rt<<1);tag(rt<<1|1);
        e[rt<<1].lazy=e[rt<<1|1].lazy=1;
        e[rt].lazy=0;
    }
}
void build(int l,int r,int rt) {//显然 
    e[rt].l=l,e[rt].r=r;
    e[rt].ma=-inf,e[rt].mi=inf;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(l,mid,rt<<1);
    build(mid+1,r,rt<<1|1);
}
void modify(int L,int R,int rt) {
    if(L<=e[rt].l&&e[rt].r<=R) {
        tag(rt);
        e[rt].lazy=1;
        return;
    }
    if(e[rt].full) return;//如果计算过就不用在计算了 
    pushdown(rt);
    int mid=(e[rt].l+e[rt].r)>>1;
    if(L<=mid) modify(L,R,rt<<1);
    if(R>mid) modify(L,R,rt<<1|1);
    if(L<=mid&&R>mid) e[rt].k=1;//区间两边都经过，中间也一定经过，k=1 
    pushup(rt);
}
struct edge {int opt,x,y;} Q[maxn];//询问 
main() {
	//read and lsh 
    int n=read();
    FOR(i,1,n) {
        Q[i].opt=read();
        if(Q[i].opt==1) lsh[++len]=Q[i].x=read(),lsh[++len]=Q[i].y=read();
    }
    sort(lsh+1,lsh+1+len);
    len=unique(lsh+1,lsh+1+len)-lsh-1;
    build(1,len,1);
    FOR(i,1,n) {
        if(Q[i].opt==2) continue;
        Q[i].x=lower_bound(lsh+1,lsh+1+len,Q[i].x)-lsh;
        Q[i].y=lower_bound(lsh+1,lsh+1+len,Q[i].y)-lsh;
    }
    //work
    FOR(i,1,n) {
        if(Q[i].opt==2)
            cout<<e[1].sum<<"\n";
        else
            modify(Q[i].x,Q[i].y,1);
    }
    return 0;
}
```

---

## 作者：huainan_marquis (赞：4)

真是太菜了，好久才过这一道题，自己写一篇题解吧。

首先，先打表找找连续一段数的组成的序列的异或和，例如{1，2，3，4，5，6}，实际上就是3^5^7^9^11，然后a-b就是(1-b的异或和)^(1-a的异或和),规律自己找吧，这不是重点。

然后需要考虑不连续的集合，例如1-6和8-11和13-19吧，这样不仅要计算连续和，还要计算^（8*8-6*6）^(13*13-11*11)；

接下来用图解释一下

![](https://cdn.luogu.com.cn/upload/pic/46529.png)

黑色的是已经保存上的区间，而蓝色的是，所要添加的区间，本次操作之后，将变为下图这个状态。

![](https://cdn.luogu.com.cn/upload/pic/46530.png)

可以看到，他把所有和他有接触的区间合并到了一起（重复元素等于只有，因为a*a-a*a=0，不影响异或的结果），而最后这个区间则是所有和他有接触的区间的集合，例如图一第四个区间右端点大于输入，则将最终结果也扩充到第四个区间的右端点。
而怎么计算途中的结果呢？其实只要把沿途的区间全部异或一次，便可以达到对那些区间的异或和清零的作用，再把最终的区间计算一次就行，在这个过程中，不要忘记对每个区间端点处与前一个区间端点进行一次异或。
特殊情况：

![](https://cdn.luogu.com.cn/upload/pic/46531.png)

这样的话特判一下，因为他不接触到任何一个区间。。。
然后早已预料到vector存储的话，每一次插入整体向后移动时间复杂度是O(q),插入是O(q),所以总复杂度是O(q^2)；
然后set是红黑树，总体复杂度O(qlogq)，写起来得用指针。

vector版代码（50）：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

#define int long long

const int maxn  = 1e9;

int now = 0;
int yihuo[1000];
struct data{
    int a1,a2;
}da[300010];

vector<data>v1;

int suma(int a){
    if((a-1)%4 == 0) return (a<<1)-2;
    else if((a-1)%4 ==1) return 3;
    else if((a-1)%4 ==2) return (a<<1);
    else if((a-1)%4 ==3) return 1;
}

void upd(int x1,int x2){
    now ^= suma(x1);
    now ^= suma(x2);
}

int findi(int x){
    int l =0,r = v1.size(),mid;
    while(l<r) {
        mid = (l+r)/2;
        if(v1[mid].a2 >= x) r = mid;
        else l =mid+1;
    }
    return l;
}

void inserti(int x1,int x2){
    int l = findi(x1-1);

    if(l < v1.size()){
        if(v1[l].a1 >x2+1 && l >0){
            now = now ^ (v1[l].a1*v1[l].a1-v1[l-1].a2*v1[l-1].a2);

        }
        x1 = min(x1,v1[l].a1);
    }


    int i;
    for(i = l;i<v1.size() && v1[i].a1 <= x2+1 ;i++){
        if(i>0) now = now ^ (v1[i].a1 * v1[i].a1 - v1[i-1].a2* v1[i-1].a2); 
        upd(v1[i].a1,v1[i].a2);
    }
    if(i >l)
    if(i<v1.size()) {
        now = now^(v1[i].a1*v1[i].a1 - v1[i-1].a2*v1[i-1].a2);
    }
    if(i>0){
        x2 = max(x2,v1[i-1].a2);
    }

    if(l>0) now = now ^ (x1*x1- v1[l-1].a2* v1[l-1].a2); 
    if(i<v1.size())now = now ^ (v1[i].a1* v1[i].a1 - x2*x2); 

    upd(x1,x2);

    v1.erase(v1.begin()+l,v1.begin()+i);
    v1.insert(v1.begin()+l,(data){x1,x2});

}


signed main()
{
    int n,zhut,inp1,inp2;
    scanf("%lld",&n);
    for(int i =0;i<n;i++){
        scanf("%lld",&zhut);
        if(zhut == 1){
            scanf("%lld%lld",&inp1,&inp2);
            inserti(inp1,inp2);
        }
        else{
            printf("%lld\n",now);
       }

    }
//    for(int i =0;i<v1.size();i++){//这一段是输出异或和的，就是最开始提到的那个找规律
//        cout<<" "<<v1[i].a1<<" "<<v1[i].a2<<endl;
//    }
//     yihuo[2] = 3;
//    for(int i =2;i<=100;i++){
//        cout<<((i<<1)|1)<<endl;
//        yihuo[i+1] = ((i<<1)|1) ^ yihuo[i];
//    }
//    for(int i = 1;i<100;i++){
//        cout<<i<<" "<<yihuo[i]<<endl;
//    }
    return 0;
}

```

set版代码（AC）：

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <set>

using namespace std;

#define int long long

const int maxn  = 1e9;

int now = 0;
int yihuo[1000];
struct data{
    int a1,a2;
    bool operator < (const struct data &others)const{
        return a1<others.a1;
    }
}da[300010];

set<data>v1;

int suma(int a){
    if((a-1)%4 == 0) return (a<<1)-2;
    else if((a-1)%4 ==1) return 3;
    else if((a-1)%4 ==2) return (a<<1);
    else if((a-1)%4 ==3) return 1;
}

void upd(int x1,int x2){
    now ^= suma(x1);
    now ^= suma(x2);
}


void inserti(int x1,int x2){
    set<data>::iterator l = v1.lower_bound((data){x1,x2}),i,u;
    while(true){
        if(l == v1.begin()) break;
        if(x1 - 1 > (--l)->a2){++l; break;}
    }
    if(l != v1.end()){
        if(l->a1 >x2+1 && l !=v1.begin()){
            u = l--;
            now = now ^ (u->a1*u->a1-l->a2*l->a2);
            l++;
        }
        x1 = min(x1,l->a1);
    }

    for(i = l;i != v1.end() && i->a1 <= x2+1;i++){
        u = i; u--;
        if(i!=v1.begin()) now = now ^ (i->a1 * i->a1 - u->a2*u->a2);
        upd(i->a1,i->a2);
    }
    if(i != l)
    if(i != v1.end()) {
        u =i; u--;
        now = now^(i->a1*i->a1 - u->a2*u->a2);
    }
    if(i != v1.begin()){
        u = i; u--;
        x2 = max(x2,u->a2);
    }

    if(l != v1.begin()) {u = l;u--;now = now ^ (x1*x1- u->a2*u->a2);}
    if(i != v1.end())now = now ^ (i->a1* i->a1 - x2*x2);
    upd(x1,x2);

    v1.erase(l,i);
    v1.insert((data){x1,x2});

}


signed main()
{
    int n,zhut,inp1,inp2;
    scanf("%lld",&n);
    for(int i =0;i<n;i++){
        scanf("%lld",&zhut);
        if(zhut == 1){
            scanf("%lld%lld",&inp1,&inp2);
            inserti(inp1,inp2);
        }
        else{
            printf("%lld\n",now);
       }

    }

    return 0;
}

```

---

## 作者：miaokehao (赞：3)

#### 发一篇良心的线段树
首先打表找出规律，羡慕机房里的大佬能够秒杀
```
#include <bits/stdc++.h>
#define res register int
using namespace std;
int ans[105];
int main(){
	for(res i=1;i<=100;i++){
		ans[i]=ans[i-1]^(i*i-(i-1)*(i-1));
		printf("%d %d\n",i,ans[i]);
	}
	printf("%d\n",ans[10]^ans[1]);
	return 0;
}
```
接下来可以考虑线段树1<=l,r<=2e9可以离散之后再在区间内覆盖打标记，标记flag表示是否完全，标记ifok左右儿子表示的区间是否连通
```
inline void pushup(res now,res l,res r){
   	if(tr[now].flag) return;
   	res mid=l+r>>1;
   	if(tr[now].ifok)
   	  tr[now].sum=tr[ls].sum^tr[rs].sum^sigxor(lisan[mid])^sigxor(lisan[mid+1]);
    else if(tr[ls].maxn==-inf||tr[rs].maxn==-inf)
      tr[now].sum=tr[ls].sum^tr[rs].sum;
    else
      tr[now].sum=tr[ls].sum^tr[rs].sum^(sqr(tr[rs].minn)-sqr(tr[ls].maxn));
    tr[now].maxn=max(tr[ls].maxn,tr[rs].maxn);
    tr[now].minn=min(tr[ls].minn,tr[rs].minn);
   }
```
所以只要覆盖过的区间都不用再遍历，因为都已经算了。
附上代码：
```
#include <bits/stdc++.h>
#define res register ll
#define ll long long 
#define N 300005
#define inf 0x3f3f3f3f
using namespace std;
ll n,lisan[N<<1],tot; 
inline ll read() {
    res w=0,X=0;
    register char ch=0;
    while(!isdigit(ch)) {
        w|=ch=='-';
        ch=getchar();
    }
    while(isdigit(ch)) {
        X=(X<<1)+(X<<3)+(ch^48);
        ch=getchar();
    }
    return w?-X:X;
}
struct papa1{
	papa1():l(0),r(0){};
	ll op,l,r;
}q[N];
inline ll sigxor(res x)//(sigma (2^2-1^2)+...+(n^2-(n-1)^2)
{
	if(x%4==0) return 1;
	if(x%4==2) return 3;
	if(x%4==3) return x<<1;
	return (x<<1)-2; 
}
inline ll sqr(res x){
	return x*x;
}
namespace T{
	#define ls (now<<1)
	#define rs (now<<1|1)
   struct papa{
   	bool ifok,flag;
   	ll sum,maxn,minn;
   }tr[N<<3];
   inline void build_up(res now,res l,res r){
   	tr[now].sum=tr[now].ifok=tr[now].flag=0;
   	tr[now].maxn=-inf,tr[now].minn=inf;
   	if(l==r)
   	  return;
   	res mid=l+r>>1;
   	build_up(ls,l,mid);
   	build_up(rs,mid+1,r); 
   }
   inline void pushup(res now,res l,res r){
   	if(tr[now].flag) return;
   	res mid=l+r>>1;
   	if(tr[now].ifok)
   	  tr[now].sum=tr[ls].sum^tr[rs].sum^sigxor(lisan[mid])^sigxor(lisan[mid+1]);
    else if(tr[ls].maxn==-inf||tr[rs].maxn==-inf)
      tr[now].sum=tr[ls].sum^tr[rs].sum;
    else
      tr[now].sum=tr[ls].sum^tr[rs].sum^(sqr(tr[rs].minn)-sqr(tr[ls].maxn));
    tr[now].maxn=max(tr[ls].maxn,tr[rs].maxn);
    tr[now].minn=min(tr[ls].minn,tr[rs].minn);
   }
   inline void update(res now,res l,res r,res ql,res qr){
   	if(ql<=l&&r<=qr){
   	  tr[now].flag=1;
   	   tr[now].sum=sigxor(lisan[l])^sigxor(lisan[r]);
   	  tr[now].maxn=lisan[r];
   	  tr[now].minn=lisan[l];
   	  return;
	}
	if(tr[now].flag) return;
	res mid=l+r>>1;
	if(ql<=mid) update(ls,l,mid,ql,qr);
	if(mid<qr) update(rs,mid+1,r,ql,qr);
	if(ql<=mid&&mid<qr) tr[now].ifok=1;
	pushup(now,l,r);
   } 
}
int main(){
	n=read();
	for(res i=1;i<=n;i++){
	  q[i].op=read();
	  if(q[i].op-1) continue;
	  lisan[++tot]=q[i].l=read(),lisan[++tot]=q[i].r=read();
	}
	sort(lisan+1,lisan+tot+1);
	tot=unique(lisan+1,lisan+tot+1)-lisan-1;
	for(res i=1;i<=n;i++){
		if(q[i].op-1)  continue;
		q[i].l=lower_bound(lisan+1,lisan+tot+1,q[i].l)-lisan;
		q[i].r=lower_bound(lisan+1,lisan+tot+1,q[i].r)-lisan;
	}
	T::build_up(1,1,tot);
	for(res i=1;i<=n;i++){
		if(q[i].op==2)
			printf("%lld\n",T::tr[1].sum);
		else
		  T::update(1,1,tot,q[i].l,q[i].r);
	}
	return 0;
}
```

---

## 作者：Seauy (赞：2)

# 1 铺垫

这里来一发线段树不用区间修改的写法

这题跟 [[SHOI2009]会场预约](https://www.luogu.com.cn/problem/P2161) 有些像，建议做做那道题再来做这题

上海省选那题是需要写一个支持删除相交线段、插入新线段的数据结构

如果我们能在每次插入的时候都能 $ O(\log n) $ 地找到每一个与插入线段相交的线段，然后从集合中剔除，再 $ O(\log n) $ 地插入新线段，整个算法就能在 $ O(n \log n) $ 复杂度内完成（剔除的线段不会再加进来，每个线段最坏情况被插入、剔除各一次）

那么可以用平衡树来实现

~~平衡树码量大难调怎么办~~

可以观察到在任何时刻，集合内的线段线段都是互不相交的。这就会导致随着右端点横坐标的上升，左端点横坐标也会上升

于是我们为右端点值域开个桶，用线段树来实现。桶中每个位置存以这个点为右端点的线段的左端点（没有线段左端点则为 $ + \infty $），线段树维护区间左端点最小值

设新插入线段 $[L,R]$，已存在线段 $ [L_i,R_i] $，我们找到所有右端点 $ R_i\geq L $ 的线段树结点

为了保证结点中有 $ [L_i,R_i] $ 与 $ [L,R] $ 有交集，也就是 $ L_i \leq R $，我们把区间左端点最小值 $ L_{\min} > R $ 的所有结点都给剪枝掉（最左的左端点都不在 $ [L,R] $ 内说明此结点内没有需要删除的线段）

于是就出现了以下代码

```cpp
int Delete(int now,int L,int R,int QL,int QR)//L R 线段右端点的取值 
{
	if(R<QL || !node[now].sum || node[now].minn>QR) return 0;
	if(L==R)
	{
		node[now].minn=INT_MAX;//删除掉
		node[now].sum=0;
		return 1;
	}
	int cnt=Delete(Lson,L,mid,QL,QR)+Delete(Rson,mid+1,R,QL,QR);
	PushUp(now);
	return cnt;
}
```

能保证删除一个线段 $ O(\log n) $

# 2 此题解法

换到这道题来，我们也可以用同样的方法

如果集合中有重复的数字，那么排好序后它们肯定是位置上连续的，它们平方差的异或和就为 0，对答案没有影响，因此把集合看成不可重集来做

我们可以把所有与新线段 $ [L,R] $ 连续的线段 $ [L_i,R_i] $ 都找出来并删除，与 $ [L,R] $ 取并集再插回线段树中，与此同时计算对答案的影响

[ 这里的“两个线段连续定义”为两段连续的整数，取并集后还能表达为一段连续的整数 ]

设 $ R_i<L_{i+1} $

$ [L_i,R_i] $ 对答案的影响可以分为两部分

1. 所有相邻的 $ L_i \leq x \leq R_i $ 的整数的平方差异或和

2. $ R_i $ 与 $ L_{i+1} $ 的平方差异或和

我们分别来看怎么处理

## 1. 找规律

~~是的就是找规律，可以看到其它题解也都是这么做的~~

把 $ [L,R] $ 里的数从小到大排好序后，会得到 $ L,L+1 ... R-1,R $ 这么个数列，设其中一个数为 $ a_i $，那么它跟前面一个数的贡献为

$ a_i^2 - a_{i-1}^2=(a_i - a_{i-1})(a_i+a_{i-1})=a_i+a_{i-1} $

这一整段 $ [L,R] $ 的贡献就为

$ (2L+1) \oplus (2L+3) \oplus (2L+5) ... \oplus (2R-1) $

是连续若干奇数的异或和

设 $ f(x) $ 为 1 到 $ 2x-1 $ 奇数的异或和，$ [L,R] $ 的贡献可以表示为 $ g(L,R)=f(L) \oplus f(R) $（异或的逆运算是其本身，可以通过这个结论想想怎么得到这个式子的）

找规律得到 $ O(1) $ 计算 $ f(x) $ 的函数

```cpp
ll f(ll x)//在最终代码里是 PreXor
{
	if(((x+2)&3)==0) return 2;
	if((x&3)==0) return 0;
	return (x-(!((x-1)&3)))<<1|1;
}
```

~~没有其它题解简洁~~

然后我们就能 $ O(1) $ 计算 $[L,R]$ 的贡献啦！我们把最终答案 $ ans $ 异或等于每个要删除线段的 $ g(L_i,R_i) $ 就剔除掉第一类影响了（同样是因为异或的逆运算是其本身）

## 2. 直接算

对 $ ans $ 异或掉每个 $ (R_i+L_{i+1})(R_i-L_{i+1}) $ 就行了

所以最终剔除掉删除线段贡献的部分为

```cpp
for(int i=1;i<=num;i++)
{
	ans^=temp[i].VAL();
	if(i>1) ans^=(temp[i].L-temp[i-1].R)*(temp[i].L+temp[i-1].R);
}
```

然后与 $ [L,R] $ 取并集

```cpp
L=min(L,temp[1].L);
R=max(R,temp[num].R);
```
再计算将 $ [L,R] $ 插入又会产生多少影响

它自身内部会产生 $ g(L,R) $ 的贡献，还有与左右两个相邻线段的贡献

我们把目光转向线段树，求出线段 $ lst=[L_0,R_0],nxt=[L_{num+1},R_{num+1}] $

```cpp
bool FindLst(int now,int L,int R,int QL)
{
	if(!now) return 0;
	if(!node[now].sum || QL<=L) return 0;
	if(L==R)
	{
		lst=Segment{node[now].minn,L};
		return 1;
	}
	if(FindLst(node[now].Son[1],mid+1,R  ,QL)) return 1;
	if(FindLst(node[now].Son[0],L    ,mid,QL)) return 1;
	return 0;
}

bool FindNxt(int now,int L,int R,int QR)
{
	if(!now) return 0;
	if(!node[now].sum || R<=QR) return 0;
	if(L==R)
	{
		nxt=Segment{node[now].minn,R};
		return 1;
	}
	if(FindNxt(node[now].Son[0],L    ,mid,QR)) return 1;
	if(FindNxt(node[now].Son[1],mid+1,R  ,QR)) return 1;
	return 0;
}
```
注意到 $ [L_1,R_1] $ 与 $ [L_{num},R_{num}] $ 也会跟它们俩产生贡献，也要剔除掉

```cpp
FL=FindLst(1,1,MAXV,L);
FN=FindNxt(1,1,MAXV,R);
if(num)
{
	if(FL) ans^=(temp[1].L-lst.R)*(temp[1].L+lst.R);
	if(FN) ans^=(nxt.L-temp[num].R)*(nxt.L+temp[num].R);
}
```
最后是 $ [L,R] $ 跟 $ lst,nxt $ 的贡献

```cpp
ans^=Segment{L,R}.VAL();
if(FL) ans^=(L-lst.R)*(L+lst.R);
if(FN) ans^=(nxt.L-R)*(nxt.L+R);
```
最后的最后，一个小坑~~它坑了我一个小时~~

$ [L,R] $ 必定插在 $ lst,nxt $ 之间，如果之前 $ lst,nxt $ 之间就没其它线段，它俩之间的贡献还得去除掉

所以

```cpp
if(num)
{
	if(FL) ans^=(temp[1].L-lst.R)*(temp[1].L+lst.R);
	if(FN) ans^=(nxt.L-temp[num].R)*(nxt.L+temp[num].R);
	L=min(L,temp[1].L);
	R=max(R,temp[num].R);
}
else if(FL && FN) ans^=(nxt.L-lst.R)*(nxt.L+lst.R);
```
线段树的部分是板子的事，最后展示的时候再看

注意事项：

1. 记得开 long long

2. 讲过的那个小坑

3. 注意考虑 num=0 的情况

4. 要卡常，记得加快读，动态开点别用 vector（如果你写离散化了的话可以忽视这条）

# 3 代码

```cpp
/*
	(A[i]-A[i-1])*(A[i]+A[i-1])
	
	若 A[i]=A[i-1] 那么它不对答案有贡献（其实就是这个集合重复不重复都没关系）
	若 A[i-1]+1=A[i] 那么贡献就是 2*A[i-1]+2
	那么连续的一段肯定是相邻两个数和的异或和喽
	不同段简单地最后一个与第一个异或一下就行了
	
	哦那么连续的一段就是……假设头是 x，长 y，那么贡献就是
	
	(2x+1)xor(2x+3)xor(2x+5)...xor(2x+2y-3)
	
	2x+1 为第 x+1 个奇数
	2x+2y-3=2(x+y-2)+1
	
	我们就存互不连续的段若干 
*/
#include<bits/stdc++.h>
#define mid ((L+R)>>1)
#define Lsum (node[now].Son[0]>-1 ? node[node[now].Son[0]].sum : 0)
#define Rsum (node[now].Son[1]>-1 ? node[node[now].Son[1]].sum : 0)
#define Lmin (node[now].Son[0]>-1 ? node[node[now].Son[0]].minn : 0)
#define Rmin (node[now].Son[1]>-1 ? node[node[now].Son[1]].minn : 0)
using namespace std;

typedef long long ll;

const int MAXN=3e5;
const int MAXV=1e9;

inline ll ScanLL()
{
   	int s=0,w=1;
   	char ch=getchar();
   	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   	return s*w;
}

int n;
ll ans;

ll PreXor(ll x)
{
	if(((x+2)&3)==0) return 2;
	if((x&3)==0) return 0;
	return (x-(!((x-1)&3)))<<1|1;
}

ll OddXor(ll x,ll y)
{
	if(y<2) return 0;
	//int cnt;
		//cnt=0;
		//for(int i=2*x+1;i<=2*x+2*y-3;i+=2) cnt^=i;
		//printf("%d %d\n",ans,PreXor(x+y-1)^PreXor(x));
		//cnt=0;
		//for(int i=x+1;i<=x+y-1;i++) cnt^=(i*i-(i-1)*(i-1));
		//printf("%d\n",ans);
	//if(cnt!=(PreXor(x+y-1)^PreXor(x))) printf("OddXor Error\n");
	return PreXor(x+y-1)^PreXor(x);
}

struct Segment
{
	ll L,R;
	ll VAL() {return PreXor(L)^PreXor(R);}
	void Print() {printf("%lld %lld\n",L,R);}
}temp[MAXN+5],lst,nxt;int num;

struct SegTree
{
	int Son[2];
	int sum,minn;
	void Clean()
	{
		Son[0]=Son[1]=0;
		sum=0;
		minn=INT_MAX;
	}
}Empty,node[6000000];int Tail;

void New(int now,bool t)
{
	if(node[now].Son[t]) return;
	node[++Tail]=Empty;
	node[now].Son[t]=Tail;
}

void Build()
{
	Empty.Clean();
	node[++Tail]=Empty;
}

void PushUp(int now)
{
	node[now].sum=0;
	node[now].minn=INT_MAX;
	if(node[now].Son[0])
	{
		node[now].sum=node[node[now].Son[0]].sum;
		node[now].minn=node[node[now].Son[0]].minn;
	}
	if(node[now].Son[1])
	{
		node[now].sum+=node[node[now].Son[1]].sum;
		node[now].minn=min(node[now].minn,node[node[now].Son[1]].minn);
	}
}

void Delete(int now,int L,int R,int QL,int QR)
{
	if(!now) return;
	if(!node[now].sum || QR+1<node[now].minn || R+1<QL) return;
	//printf("%d %d %d %d %d\n",now,L,R,QL,QR);
	if(L==R)
	{
		temp[++num]=Segment{node[now].minn,L};
		node[now].sum=0;
		node[now].minn=INT_MAX;
		return;
	}
	Delete(node[now].Son[0],L    ,mid,QL,QR);
	Delete(node[now].Son[1],mid+1,R  ,QL,QR);
	PushUp(now);
}

bool FindLst(int now,int L,int R,int QL)
{
	if(!now) return 0;
	if(!node[now].sum || QL<=L) return 0;
	if(L==R)
	{
		lst=Segment{node[now].minn,L};
		return 1;
	}
	if(FindLst(node[now].Son[1],mid+1,R  ,QL)) return 1;
	if(FindLst(node[now].Son[0],L    ,mid,QL)) return 1;
	return 0;
}

bool FindNxt(int now,int L,int R,int QR)
{
	if(!now) return 0;
	if(!node[now].sum || R<=QR) return 0;
	if(L==R)
	{
		nxt=Segment{node[now].minn,R};
		return 1;
	}
	if(FindNxt(node[now].Son[0],L    ,mid,QR)) return 1;
	if(FindNxt(node[now].Son[1],mid+1,R  ,QR)) return 1;
	return 0;
}

void Insert(int now,int L,int R,int QL,int QR)
{
	if(L==R)
	{
		node[now].sum=1;
		node[now].minn=QL;
		return;
	}
	if(QR<=mid)
	{
		New(now,0);
		Insert(node[now].Son[0],L,mid,QL,QR);
	}
	else
	{
		New(now,1);
		Insert(node[now].Son[1],mid+1,R,QL,QR);
	}
	PushUp(now);
}

int main()
{
	Build();
	scanf("%d",&n);
	bool FL,FN;
	ll L,R;
	for(int t;n--;)
	{
		t=ScanLL();
		if(t==1)
		{
			L=ScanLL(),R=ScanLL();
			num=0;
			Delete(1,1,MAXV,L,R);
			for(int i=1;i<=num;i++)
			{
				//temp[i].Print();
				ans^=temp[i].VAL();
				if(i>1) ans^=(temp[i].L-temp[i-1].R)*(temp[i].L+temp[i-1].R);
			}
			FL=FindLst(1,1,MAXV,L);
			FN=FindNxt(1,1,MAXV,R);
			//if(FL) printf("lst: "),lst.Print();
			//if(FN) printf("nxt: "),nxt.Print();
			if(num)
			{
				if(FL) ans^=(temp[1].L-lst.R)*(temp[1].L+lst.R);
				if(FN) ans^=(nxt.L-temp[num].R)*(nxt.L+temp[num].R);
				L=min(L,temp[1].L);
				R=max(R,temp[num].R);
			}
			else if(FL && FN) ans^=(nxt.L-lst.R)*(nxt.L+lst.R);
			Insert(1,1,MAXV,L,R);
			ans^=Segment{L,R}.VAL();
			if(FL) ans^=(L-lst.R)*(L+lst.R);
			if(FN) ans^=(nxt.L-R)*(nxt.L+R);
			//printf("ans: %d\n",ans);
		}
		else printf("%lld\n",ans);
	}
	return 0;
}
```

~~所以这题不用离线，动态快速排序也只搭一点~~

---

## 作者：Betrayer_of_love (赞：1)

### 题目大意
**[题目传送门](https://www.luogu.com.cn/problem/P5105)**


维护两个操作：

- 在序列中插入 $[l,r]$ 中的所有整数。
- 将序列排序后输出
$ \bigoplus_{i=1}^{n=1} a[i]^2 -a[i-1]^2$。

### 思路

这道题中虽然允许元素的重复，但是显然重复的元素对答案的贡献为 $0$ 。所以我们可以不用考虑元素重复的情况。

又由于每次加入的元素是一个连续的区间，所以我们可以考虑维护一棵权值线段树。那么每次询问就把这个区间打上 $\operatorname{lazy}$ 标记。

那么如何计算这个区间的贡献呢？我们可以利用这个区间连续的特性。因为 $x^2-(x-1)^2=(x-x+1)(x+x-1)=2x-1$ 必然是奇数，所以我们就是要求若干连续奇数的异或和。

打表就不难发现，从 $1$ 开始，每四个连续的奇数亦或起来为 $0$ 。所以这样就可以快速算出前缀异或和。

```C++
ll xorsum(ll x){  //1 xor 3 xor ... xor x
    int k=(x/2+1)%4;  //计算出这是第几个奇数 
    if (k==0) return 0;
    if (k==1) return x;
	if (k==2) return x^(x-2);
	if (k==3) return x^(x-2)^(x-4);
}
```

然后区间合并的时候将这两个区间的最值用  $a[i]^2-a[i-1]^2$ 求出来异或进去即可。
线段树要动态开点。

时间复杂度 $O(n log n)$


### 代码（CODE）

```c
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=300010;
int T,opt,tot,root,l,r;
struct Treenode{
	ll ans,maxn,minn;
	int lc,rc;
	bool lazy;
};
ll xorsum(ll x){
    int k=(x/2+1)%4;
    if (k==0) return 0;
    if (k==1) return x;
	if (k==2) return x^(x-2);
	if (k==3) return x^(x-2)^(x-4);
}
struct Tree{
	Treenode tree[N*64];
	void update(int x){
		tree[x].ans=tree[tree[x].lc].ans^tree[tree[x].rc].ans;
		if (tree[x].lc && tree[x].rc)
			tree[x].ans^=tree[tree[x].rc].minn*tree[tree[x].rc].minn-tree[tree[x].lc].maxn*tree[tree[x].lc].maxn;
		if (tree[x].lc)	tree[x].minn=tree[tree[x].lc].minn;
			else tree[x].minn=tree[tree[x].rc].minn;
		if (tree[x].rc)	tree[x].maxn=tree[tree[x].rc].maxn;
			else tree[x].maxn=tree[tree[x].lc].maxn;
	}
	void pushdown(int x,int l,int r){
		if (tree[x].lazy){
			if (!tree[x].lc) tree[x].lc=++tot;
			if (!tree[x].rc) tree[x].rc=++tot;
			tree[tree[x].lc].lazy=tree[tree[x].rc].lazy=1;
			tree[x].lazy=0;
			int mid=(l+r)>>1;
			tree[tree[x].lc].minn=l; tree[tree[x].lc].maxn=mid;
			tree[tree[x].rc].minn=mid+1; tree[tree[x].rc].maxn=r;
			tree[tree[x].lc].ans=xorsum(tree[tree[x].lc].maxn*2-1)^xorsum(tree[tree[x].lc].minn*2-1);
			tree[tree[x].rc].ans=xorsum(tree[tree[x].rc].maxn*2-1)^xorsum(tree[tree[x].rc].minn*2-1);
		}
	}
	void insert(int &x,int nowl,int nowr,int l,int r){
		if (l>r) return;
		if (!x) x=++tot;
		if (nowl==l && nowr==r){
			tree[x].ans=xorsum(r+r-1)^xorsum(l+l-1);
			tree[x].maxn=r; tree[x].minn=l;
			tree[x].lazy=1;
			return;
		}
		pushdown(x,nowl,nowr);
		int mid=(nowl+nowr)>>1;
		if (r<=mid) insert(tree[x].lc,nowl,mid,l,r);
		else if (l>mid) insert(tree[x].rc,mid+1,nowr,l,r);
		else insert(tree[x].lc,nowl,mid,l,mid),insert(tree[x].rc,mid+1,nowr,mid+1,r);
		update(x);
	}
}t;
int main(){
	scanf("%d",&T);
	while (T--){
		scanf("%d",&opt);
		if (opt==1){
			scanf("%d%d",&l,&r);
			t.insert(root,1,1e9,l,r);
		}
		else printf("%lld\n",t.tree[1].ans);
	}
	return 0;
}

```


**完结撒花，谢谢！！！**

---

## 作者：LJ07 (赞：1)

发现可重等价于不重。类似区间覆盖考虑颜色段均摊。求解连续一段等价于求解一段前缀即 $\oplus_{i=1}^{n}i^2-(i-1)^2$。拆位考虑也行但是打表理应是第一想法。
前 $12$ 的表：```1 2 7 0 9 2 15 0 17 2 23 0```

发现规律：
```cpp
int sum(int x) {
  if (x % 4 == 0) {
    return 0;
  }
  if (x % 4 == 2) {
    return 2;
  }
  if (x % 4 == 3) {
    return 2 * x + 1;
  }
  return 2 * x - 1;
}
```
set 维护连续段做到 $O(n\log n)$。[code](https://www.luogu.com.cn/paste/xzqbwi2x)

~~顺便申请降蓝，不错的颜色段均摊板子~~。

---

## 作者：ustze (赞：1)

本文于参考原题解和@memset0的题解后完成  
比赛时思路和memset0思路差不多，但是没调出来（可怜  
说一下思路，对于一段区间，如果覆盖过，就标记一下，之后这段的值就不会改变了，用动态开点线段树维护区间就行，具体看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
char ibuf[10<<20] , * s;
inline int read(){
    register int u = 0,f=1;
    while( * s < 48 ) if(*s++=='-') f=-1;
    while( * s >=48 ) u = u * 10 + * s++ - 48;
    return u*f;
}

inline int calc(int x){
    int t=x%4;
    if(t==0) return (x<<1);
    else if(t==1) return 3;
    else if(t==2) return ((x+1)<<1);
    else return 1;
}//1-x的异或和，打表打出来的
const int N=2*1e7+5;
int rt,cnt;
int ls[N],rs[N],mx[N],mn[N],tag[N];ll sum[N];
#define ls ls[rt]
#define rs rs[rt]

inline void update(int &rt,int l,int r,int L,int R){
    if(tag[rt]) return;
    if(!rt) rt=++cnt;
    if(L<=l&&r<=R){
        mn[rt]=l,mx[rt]=r;
        sum[rt]=calc(r-1)^calc(l-1);
        tag[rt]=1;
        return;
    }
    int mid=(l+r)>>1;
    if(L<=mid) update(ls,l,mid,L,R);
    if(R>mid) update(rs,mid+1,r,L,R);
    //pushup
    if(mn[ls]) mn[rt]=mn[ls];else mn[rt]=mn[rs];
    if(mx[rs]) mx[rt]=mx[rs];else mx[rt]=mx[ls];
    sum[rt]=sum[ls]^sum[rs];
    if(mx[ls]&&mn[rs]) sum[rt]^=((ll)mn[rs]*mn[rs]-(ll)mx[ls]*mx[ls]);//不相邻的两端区间需要注意这一点
    
    if(tag[ls]&&tag[rs]) tag[rt]=1;
}
int main(){
    fread( s = ibuf , 1 , 10<<20, stdin );
    int q,opt,l,r;
    q=read();
    while(q--){
        opt=read();
        if(opt==1){
            l=read(),r=read();
            update(rt,1,1e9,l,r);
        }else printf("%lld\n",sum[1]);
    }
    return 0;
}
```

---

## 作者：MoYuFang (赞：0)

本文起笔于```2021.11.21```。

[P5105 不强制在线的动态快速排序](https://www.luogu.com.cn/problem/P5105)

首先可重集与不可重集对询问的影响没区别，考虑维护不可重集。

维护区间段，然后问题的核心转化为，给定 $l$ 和 $r$，快速的求出 $\oplus_{i=l+1}^{r} (2i-1)$。

转化公式：
$$
\oplus_{i=l+1}^{r}(2i-1)=\oplus_{i=1}^{r}(2i-1)\oplus_{i=1}^{l}(2i-1)
$$
而：

$$
\oplus_{i=1}^{n} (2i-1) = (n\&1)+2\cdot \oplus_{i=1}^{n}i
$$

设 $f(n)=\oplus_{i=1}^{n}i$，经过推导可知：
$$
f(n)=!((n>>1)\&1) \quad (n=2k-1)
$$
$$
f(n)=(n+1)\oplus f(n+1)\quad (n=2k)
$$

于是 $\oplus_{i=l}^{r} (2i-1)$ 可以 $O(1)$ 求出。

区间段的维护要么用平衡树，要么用线段树，本着能用线段树就别用平衡树的原则，本题用线段树来维护区间段更简单，修改操作就是简单的一个区间覆盖操作。

因为线段树值域较大，于是考虑用动态开点线段树。

时间复杂度为 $O(m\log R)$，其中 $R$ 是值域。

单次区间覆盖最多产生 $2\lceil\log R\rceil$ 个节点，所以线段树的节点数开到 $2\times 10^7$ 即可。


```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
#include <set>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define _fev(p, u) for(re int (p) = head[(u)]; (p); (p) = nex[(p)])
#define ll long long
#define mmin(a, b) (((b) < (a)) ? (b) : (a))
#define mmax(a, b) (((b) > (a)) ? (b) : (a))
#define maxnn 20000005
#define inf 0x7fffffff
#define ninf (-inf)

int rdnt(){
	register int x = 0, sign = 1;
	register char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

int f(int n){
    return (n&1) ? !(n&2) : (n+1)^f(n+1);
}

int g(int l, int r){
    return ((r-l)&1) + 2*(f(l-1)^f(r-1));
}

ll cal(re ll x, re ll y){
    assert(x >= y);
    return x*x-y*y;
}

int ncnt = 0, rt = 0, rg = 1000000000;
struct Seg{ int lc, rc, le, ri; ll sm; bool tag; } seg[maxnn];
#define lc(x) seg[x].lc
#define rc(x) seg[x].rc
#define le(x) seg[x].le
#define ri(x) seg[x].ri
#define sm(x) seg[x].sm
#define tag(x) seg[x].tag

int new_node(re int nn){
    re int x = ++ncnt;
    seg[x] = seg[nn];
    return x;
}

inline void ud(re int x){
	le(x) = min(le(lc(x)), le(rc(x)));
	ri(x) = max(ri(lc(x)), ri(rc(x)));
	sm(x) = sm(lc(x))^sm(rc(x))^(lc(x)&&rc(x) ? cal(le(rc(x)), ri(lc(x))) : 0);
} 

inline void spread(re int x, re int tl, re int tr){
	tag(x) = true;
    sm(x) = g(tl, tr);
    if (tl == tr) assert(sm(x) == 0);
    le(x) = tl; ri(x) = tr;
}

void add(int &x, int l, int r, int tl, int tr){
    if (!x) x = new_node(0);
    if (tag(x)) return;
    if (l == tl && r == tr) return spread(x, tl, tr);
    int mi = (tl+tr)>>1;
    if (r <= mi) add(lc(x), l, r, tl, mi);
    else if (l > mi) add(rc(x), l, r, mi+1, tr);
    else add(lc(x), l, mi, tl, mi), add(rc(x), mi+1, r, mi+1, tr);
    ud(x);
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
    freopen("sample.out", "r", stdout);
	#endif
	
    seg[0] = (Seg){0, 0, inf, ninf, 0, false};
    re int n = rdnt();
    _rfor(i, 1, n){
        re int opt = rdnt(), l, r;
        if (opt == 1){
            l = rdnt(), r = rdnt();
            add(rt, l, r, 1, rg);
        }
        else if (opt == 2){
            pf("%lld\n", sm(rt));
        }
    }

	return 0;
}



```










---


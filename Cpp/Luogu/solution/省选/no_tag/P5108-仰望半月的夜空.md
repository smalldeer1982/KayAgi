# 仰望半月的夜空

## 题目背景

“你不久也会遇到喜欢的女生吧。听好了，你可得好好守护她喔。”

这是父亲给予戎崎裕一的教诲

父亲称不上是一个合格的父亲

但是，却正是这样的父亲，连接了戎崎裕一和秋庭里香

![](https://www.cnblogs.com/images/cnblogs_com/reverymoon/1200086/o_0.png)

秋庭里香，明明是那样的傲娇，却不得不去守护的女生

但同时，又是一个为了回忆，为了懵懂的爱情而坚强着的女生

你是不是在她身上看到了小夜子的身影呢？夏目吾郎医生

你是不是在他身上看到了过去的自己呢？夏目吾郎医生

也许疾病切断了人与人之间的联系，但是曾经存在的痕迹，定将会化作美好的回忆，流传下去

愿你们幸福



## 题目描述

半月的夜空中，寄托了多少人与人之间的思念啊

曦月知道，这些思念会汇集成一个字符串 $S$（$n = |S|$）。

由于思念汇集的过于复杂，因此曦月希望提炼出所有的思念。

我们定义 $Y_S(i)$ 表示对于字符串 $S$ 而言，长度为 $i$ 的子串中，字典序最小的，左端点最小的左端点的值

比如对于串 $S = \texttt{"baa"}$，$Y_S(1) = 2$、$Y_S(2) = 2$、$Y_S(3) = 1$。

曦月会告知你 $S$ 串，你只需要告诉曦月 $Y_S(i)$（$1 \le i \le n$）即可。

## 说明/提示

数据范围的图不见了 QAQ

最大范围是 $1 \le n \le 3 \times {10}^5$。

## 样例 #1

### 输入

```
26 11
remoonqaqac```

### 输出

```
8 10 8 8 2 2 2 2 2 2 1```

## 样例 #2

### 输入

```
26 11
txdydkwqaqa
```

### 输出

```
9 9 9 5 5 5 5 3 3 1 1```

## 样例 #3

### 输入

```
10000000 17
9 9 8 2 4 4 3 5 3 1 9 2 6 0 8 1 7```

### 输出

```
14 14 14 14 10 10 10 10 4 4 4 4 4 4 3 2 1```

# 题解

## 作者：bztMinamoto (赞：8)

[传送门](https://www.luogu.org/problemnew/show/P5108)

我们考虑倒着做，也就是依次考虑长度为$n,n-1,...,1$时的答案。发现长度为$n$时只能选第一个位置，为$n-1$时要选$1,2$中较优的位置……

然后大力猜想一发倒着的答案是否保证不降，然而样例一直接把脸给打得啪啪疼

然而倒着的时候答案的确有一个性质。比方说长度为$len$的时候有$i<j$且$i$比$j$更优，那么$j$就永远不可能是最优答案了。因为长度不断减小的时候永远满足$i$开头的字典序比$j$小或者两个字典序相等但$i$在更左边

于是就可以用单调栈了。每一次把新的可以作为答案的点加进去，然后判断$st[top-1]$是否比$st[top]$更优，不断弹出，最后把栈顶最为当前长度的答案即可

然而现在的问题就是怎么判更优，毕竟要比较字典序。我太菜了不会写SAM和SA之类的（不过话说这两个能不能弄也不知道啊……）于是想了一个比较鬼畜的办法：用$hash+$二分判断两个串相等的长度，那么只要比较它们下一位的大小就好了
```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void print(R int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
const int N=3e5+5;
int a[N],b[N],st[N],ans[N];
int n,top,op,m;char s[N];
struct Hash{
    int Base,P,bin[N],sum[N];
    inline void init(R int base,R int p){
        P=p,Base=base,bin[0]=1;
        fp(i,1,n)bin[i]=1ll*bin[i-1]*Base%P;
        fp(i,1,n)sum[i]=(1ll*sum[i-1]*Base+a[i]+1)%P;
    }
    inline int gethash(R int l,R int r){return (sum[r]-1ll*sum[l-1]*bin[r-l+1]%P+P)%P;}
}h1,h2;
inline bool equal(int l,int r,int ql,int qr){
    return h1.gethash(l,r)==h1.gethash(ql,qr)&&h2.gethash(l,r)==h2.gethash(ql,qr);
}
bool check(int ql,int qr,int len){
    if(equal(ql,ql+len-1,qr,qr+len-1))return true;
    int l=1,r=len,ans=0,mid;
    while(l<=r){
        mid=(l+r)>>1;
        if(equal(ql,ql+mid-1,qr,qr+mid-1))l=mid+1,ans=mid;else r=mid-1;
    }return a[ql+ans]<=a[qr+ans];
}
int main(){
//	freopen("testdata.in","r",stdin);
    scanf("%d%d",&op,&n);
    if(op==26){
        m=35,scanf("%s",s+1);fp(i,1,n)a[i]=s[i]-'a';
    }else{
        fp(i,1,n)a[i]=b[i]=read();sort(b+1,b+1+n),m=unique(b+1,b+1+n)-b-1;
        fp(i,1,n)a[i]=lower_bound(b+1,b+1+n,a[i])-b;
    }h1.init(233,1e9+7),h2.init(19260817,998244353);
    fp(i,1,n){
        st[++top]=i;while(top>1&&check(st[top-1],st[top],n-i+1))--top;
        ans[n-i+1]=st[top];
    }fp(i,1,n)print(ans[i]);return Ot(),0;
}
```

---

## 作者：5k_sync_closer (赞：6)

没卡常，目前用时是次优解的一半左右。

[推销 Lyndon 理论学习笔记（没写完）](https://www.cnblogs.com/5k-sync-closer/p/18516159)

> **P5108 仰望半月的夜空**
>
> 给一个字符串 $s$，对 $i\in[1,|s|]$ 问长度为 $i$ 的最小子串的第一次出现。

先给复杂度：问最后一次出现可以 $O(|s|)$，问第一次出现可以结合哈希二分做到 $O(|s|\log|s|)$。

字典序问题，可以在 Lyndon 分解上考虑，设分解得到 $s=w_1+\dots+w_k$。

考虑长度为 $i$ 的最小子串在哪里起头。首先根据 Lyndon 串的定义，在某个 $w_p$ 中间起头肯定不优，

而且分解出的 Lyndon 串字典序是单调不增的，所以应该在尽量靠后的 $w_p$ 起头，

所以可以得出结论：应该在 $|w_p+w_{p+1}+\dots+w_k|\ge i$ 的最后一个 $w_p$ 处起头，

但这个子串不一定只在这里出现，考虑它还在哪里出现过。

分解出的 Lyndon 串字典序是单调不增的，所以这个子串只在 $w_p$ 及其前的若干个 Lyndon 串中出现。

二分这个子串最早在哪里出现即可。

```cpp
#include <cstdio>
#include <cstring>
char _[300050];
int n, o, S, l[300050], a[300050];
unsigned long long p[300050], h[300050];
int Q(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }
int main()
{
    scanf("%d%d", &S, &n);
    if (S == 26)
    {
        scanf("%s", _ + 1);
        for (int i = 1; i <= n; ++i)
            a[i] = _[i];
    }
    else
    {
        for (int i = 1; i <= n; ++i)
            scanf("%d", a + i);
    }
    for (int i = p[0] = 1; i <= n; ++i)
        p[i] = p[i - 1] * 10000019, h[i] = h[i - 1] * 10000019 + a[i];
    int i = 1, j, k;
    while (i <= n)
    {
        j = i + 1, k = i;
        while (j <= n)
        {
            if (a[j] == a[k])
                ++j, ++k;
            else if (a[j] > a[k])
                ++j, k = i;
            else
                break;
        }
        while (i <= k)
            l[++o] = i, i += j - k;
    }
    for (int i = 1, j = o; i <= n; ++i)
    {
        if (n - l[j] + 1 < i)
            --j;
        int L = 1, R = j;
        while (L <= R)
        {
            int M = L + R >> 1;
            if (Q(l[M], l[M] + i - 1) == Q(l[j], l[j] + i - 1))
                R = M - 1;
            else
                L = M + 1;
        }
        printf("%d ", l[L]);
    }
    return 0;
}
```

---

## 作者：qwaszx (赞：5)

考虑后缀树，在不压缩的时候它是一棵完整的Trie，那么我们只需要在Trie上按照字典序遍历即满足字典序的要求，同时维护一下每个节点的最早出现位置即可更新答案.

现在考虑压缩的后缀树，压缩掉的都是只有一个儿子的点，那么我们直接按照压缩掉的链上的第一个点的字符走即可. 现在需要的操作是对一段区间上没被覆盖的点覆盖上某个颜色，这个只需要用并查集维护出每个点后面第一个未被覆盖的点即可.

压缩后缀树的构建可以直接使用反串SAM的parent tree. 细节可以看代码.

```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<cstring>
#define IT map<int,int>::iterator
using namespace std;
const int N=7e5;
int n,ans[N],w[N],mi[N],cur,node_cnt,id[N],sigma,cnt[N];
char st[N];
struct Node{int fa,len;map<int,int>ch;}a[N];
map<int,int>ch[N];
void ins(int ch,int pos)
{
    int u=cur;cur=++node_cnt;a[cur].len=a[u].len+1;mi[cur]=pos;
    for(;u&&!a[u].ch[ch];u=a[u].fa)a[u].ch[ch]=cur;
    if(!u){a[cur].fa=1;return;}
    int v=a[u].ch[ch];if(a[v].len==a[u].len+1){a[cur].fa=v;return;}
    int t=++node_cnt;a[t]=a[v];a[t].len=a[u].len+1;
    a[v].fa=a[cur].fa=t;
    for(;u&&a[u].ch[ch]==v;u=a[u].fa)a[u].ch[ch]=t;
}
struct DSU
{
    int fa[N];
    int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
}bcj;
void dfs(int u)
{
    if(u!=1)//并查集更新某一段长度的答案
    {
        int x=bcj.find(a[a[u].fa].len+1);
        while(x<=a[u].len)ans[x]=mi[u],bcj.fa[x]=bcj.find(x+1),x=bcj.fa[x];
    }
    for(IT i=ch[u].begin();i!=ch[u].end();i++)
        dfs(i->second);
}
int getin()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x;
}
int main()
{
    scanf("%d%d",&sigma,&n);
    cur=node_cnt=1;
    if(sigma==26)
    {
        scanf("%s",st+1);
        for(int i=n;i>=1;i--)ins(st[i]-97,i),w[i]=st[i]-97;
    }
    else
    {
        for(int i=1;i<=n;i++)w[i]=getin();
        for(int i=n;i>=1;i--)ins(w[i],i);
    }//反串SAM
    for(int i=1;i<=node_cnt;i++)cnt[a[i].len]++;
    for(int i=1;i<=n;i++)cnt[i]+=cnt[i-1];
    for(int i=1;i<=node_cnt;i++)id[cnt[a[i].len]--]=i;
    for(int i=node_cnt;i>1;i--)//计算每个节点的最早出现位置
    {
        int u=id[i];
        if(!mi[a[u].fa])mi[a[u].fa]=mi[u];
        else mi[a[u].fa]=min(mi[a[u].fa],mi[u]);
    }
    for(int i=2;i<=node_cnt;i++)ch[a[i].fa][w[mi[i]+a[a[i].fa].len]]=i;//父亲的出现位置集合一定是儿子的出现位置集合的超集，取父亲下面第一个点作为边的字符即可
    for(int i=1;i<=n+1;i++)bcj.fa[i]=i;
    dfs(1);
    for(int i=1;i<=n;i++)printf("%d ",ans[i]);
}
```

复杂度 $O(n\log n)$，瓶颈在于map，由于map常数十分巨大所以可能评测姬一个波动就过不去了(

---

## 作者：ljc1301 (赞：2)

第一次自己写出字符串题祭

~~感觉这一题没出题人说的那么复杂~~

可以想到先对每个子串排序，因为每次要求长度一定（设为i）时字典序最小的串，所以考虑对每一个后缀排序，然后再截取每一个串的前i个字符，不足i个的舍去，就得到了对每一个长度为i的串排序的结果。

比如对于acab，排序后得到
```plain
ab
acab
b
cab
```
让i从小到大枚举。当i=1时，发现第一个串ab的长度大于等于i（若小于则把这个串忽略），所以答案就是ab这个后缀的起始位置3。

不过似乎有点不对……1没被我们考虑到。

因为acab的字典序比ab大，我们把它忽略了，这有问题，因为acab和ab的前i个字符都相等。

这怎么办？

设字典序最小的长度大于等于i的字符串为s，思考后发现，一个字符串可以更新答案，当且仅当它和s前i个字符相同的。即可以更新答案的字符串s的最长公共前缀应该大于等于i。应该可以想到height数组。

所以我们要每次倍增找到所有和s前i个字符相同的字符串（这个串应该大于等于s的字典序，比s字典序小的的长度一定小于i），在后缀排序中对应一个区间，找到这个区间中，字符串起始位置最靠前的位置即可，这个可以用st表维护。

还有一个问题，会不会有长度小于i的字符串满足这个可以更新答案的条件？其实不可能，因为长度小于i，最长公共前缀显然不可能大于i。

对于acab，i=1，发现
```plain
ab
acab
b
cab
```
中字典序最小的长度大于等于i的字符串是ab，ab,acab和ab的最长公共前缀大于等于i，所以这两个串可以更新答案。

当i=2时，字典序最小的长度大于等于i的字符串还是ab，但acab和ab的最长公共前缀小于i，所以不考虑，答案是ab这个后缀的起始位置3。

当i=3时，ab的长度小于了i，考虑下一个acab，更新答案。

当i=4时同理。

回顾一下，整个过程是：
1. 后缀排序；
2. i从小到大枚举，找到后缀排序中第一个长度大于i的（可以用指针扫）后缀；
3. 倍增，求得从这个字符串开始，所有经过的height最小值大于等于i的后缀中，起始位置最靠前的（用st表维护）；
4. 输出答案。

时间复杂度$O(n\log n+\sigma)$（$\sigma$是后缀排序时基排的时间复杂度，比赛时没想到可以用快排，这样时间复杂度会降为$O(n\log n)$，不过反正能过……）

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=300005;
const int maxm=10000005;
const int maxlog=20;
int n,logn,sa[maxn],h[maxn],rk[maxn],sz[maxm],s[maxn],minh[maxlog][maxn],minn[maxlog][maxn];
char temp[maxn];
int main()
{
    register int k,i,j,p,l,ans;
    int *x=h,*y=rk,m;
    scanf("%d%d",&m,&n);
    if(m==26)
        for(scanf("%s",temp),i=0;i<n;i++)
            s[i]=temp[i]-'a';
    else
        for(m++,i=0;i<n;i++)
            scanf("%d",&s[i]);
    // 后缀数组：
    for(i=0;i<m;i++) sz[i]=0;
    for(i=0;i<n;i++) sz[x[i]=s[i]]++;
    for(i=1;i<m;i++) sz[i]+=sz[i-1];
    for(i=0;i<n;i++) sa[--sz[x[i]]]=i;
    for(k=1;k<=n;k<<=1)
    {
        for(i=n-k,p=0;i<n;i++) y[p++]=i;
        for(i=0;i<n;i++)
            if(sa[i]>=k)
                y[p++]=sa[i]-k;
        for(i=0;i<m;i++) sz[i]=0;
        for(i=0;i<n;i++) sz[x[i]]++;
        for(i=1;i<m;i++) sz[i]+=sz[i-1];
        for(i=n-1;i>=0;i--) sa[--sz[x[y[i]]]]=y[i];
        swap(x,y);
        x[sa[0]]=0;
        for(i=1,p=1;i<n;i++)
            x[sa[i]]=((y[sa[i]]==y[sa[i-1]] && ((sa[i]+k>=n && sa[i-1]+k>=n) || (sa[i]+k<n && sa[i-1]+k<n && y[sa[i]+k]==y[sa[i-1]+k])))?p-1:p++);
        if(p>=n) break;
        m=p;
    }
    for(i=0;i<n;i++) rk[sa[i]]=i;
    // 求height
    p=h[0]=0;
    for(i=0;i<n;i++)
    {
        if(p) p--;
        if(!rk[i]) continue;
        while(s[i+p]==s[sa[rk[i]-1]+p]) p++;
        h[rk[i]]=p;
    }
    // 倍增
    for(i=0;i<n;i++)
        minh[0][i]=h[i+1],minn[0][i]=sa[i];
    for(logn=0;(1<<(logn+1))<=n;logn++);
    for(i=1;i<=logn;i++)
        for(j=0;j+(1<<i)<=n;j++)
        {
            minh[i][j]=min(minh[i-1][j],minh[i-1][j+(1<<(i-1))]);
            minn[i][j]=min(minn[i-1][j],minn[i-1][j+(1<<(i-1))]);
        }
    // 计算&输出答案
    for(i=1,j=0;i<n;i++)
    {
        while(sa[j]+i>n) j++; // 把长度小于i的忽略掉
        l=j;
        ans=sa[j];
        for(k=logn;k>=0;k--) // 倍增
            if(l+(1<<k)<n && minh[k][l]>=i)
                ans=min(ans,minn[k][l+1]),l+=(1<<k);
        printf("%d ",ans+1);
    }
    printf("1\n");
    return 0;
}
```
（应该没~~错~~想简单吧……）

---

## 作者：Purslane (赞：1)

# Solution

复建串串，做个简单题。

首先，如果需要你求出“长度为 $i$ 的、字典序最小的子串的某些信息（比如哈希值）”，显然可以先后缀排序，选字典序最小的、长度 $\ge i$ 的后缀的前 $i$ 个字符就行。

假设这个后缀的位置是 $p$。我们需要求出最小的 $q$，使得 $\text{lcp}(p,q) \ge i$。

发现在后缀排序之后，这样的 $q$ 的排名显然是一个连续的区间，而且随着 $i$ 的递减区间是在合并的。可以使用并查集 $O(1)$ 单次处理。

总体复杂度为 $O(n \log n)$，瓶颈在后缀排序。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=6e5+10,MAXM=1e7+10;
int n,s,a[MAXN],lst[MAXN],sa[MAXN],height[MAXN],rk[MAXN],Rk[MAXN],w[MAXN],cnt[MAXM];
void init(void) {
	ffor(i,0,n) cnt[i]=0;
	ffor(i,1,n) cnt[rk[i]]++;
	ffor(i,1,n) cnt[i]+=cnt[i-1];
	ffor(i,1,n) sa[++cnt[rk[i]-1]]=i;
	return ;	
}
void SA(void) {
	ffor(i,1,n) cnt[a[i]]++;
	ffor(i,1,s) cnt[i]+=cnt[i-1];
	ffor(i,1,n) rk[i]=cnt[a[i]-1]+1;
	init();
	for(int len=1;len<n;len<<=1) {
		ffor(j,0,n) cnt[j]=0,lst[j]=-1;
		ffor(j,1,n) cnt[rk[j]]++;
		ffor(j,1,n) cnt[j]+=cnt[j-1];
		ffor(j,n-len+1,n) if(lst[rk[j]]==-1) w[rk[j]]=Rk[j]=++cnt[rk[j]-1],lst[rk[j]]=0;
		else Rk[j]=w[rk[j]];
		ffor(j,1,n) if(sa[j]-len>=1) {
			int pos=sa[j]-len;
			if(lst[rk[pos]]==-1||rk[pos+len]!=lst[rk[pos]]) w[rk[pos]]=Rk[pos]=++cnt[rk[pos]-1],lst[rk[pos]]=rk[pos+len];
			else Rk[pos]=w[rk[pos]];
		}
		ffor(j,1,n) rk[j]=Rk[j];
		init();
	}
	return ;
}
int fa[MAXN],mn[MAXN],fst[MAXN],ans[MAXN];
vector<pair<int,int>> upd[MAXN];
int find(int k) {return (fa[k]==k)?k:(fa[k]=find(fa[k]));}
void merge(int u,int v) {return u=find(u),v=find(v),fa[v]=u,mn[u]=min(mn[u],mn[v]),void();}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>s>>n;
	if(s==26) {
		string S;
		cin>>S;
		ffor(i,1,n) a[i]=S[i-1]-'a'+1;	
	}
	else ffor(i,1,n) cin>>a[i];
	a[n+1]=-1;
	ffor(i,1,n) fa[i]=i,mn[i]=i;
	SA();
	int lst=0;
	ffor(i,1,n) {
		if(rk[i]==1) continue ;
		if(lst) lst--;
		while(a[i+lst]==a[sa[rk[i]-1]+lst]) lst++;
		upd[lst].push_back({i,sa[rk[i]-1]});
	}
	ffor(i,1,n) {
		int pos=n-sa[i]+1;
		while(pos&&!fst[pos]) fst[pos]=sa[i],pos--;	
	}
	roff(i,n,1) {
		for(auto pr:upd[i]) merge(pr.first,pr.second);
		ans[i]=mn[find(fst[i])];	
	}
	ffor(i,1,n) cout<<ans[i]<<' ';
	return 0;
}
```

---

## 作者：mrsrz (赞：1)

后缀数组。

由于后缀数组对每个后缀按从小到大排好序，所以在长度可行的范围内，以排名为$i$的后缀的起始位置开始的字典序一定不大于以排名为$j$（$j>i$）的后缀的起始位置开始的字典序。

那么对于当前长度$L$，我们找到后缀数组最前面的，后缀长度大于等于$L$的位置$a$，即为字典序最小的**一个**答案。

但我们不能保证字典序最小。我们需要找到与后缀$a$的LCP长度大于等于$L$的，起始位置最前面的一个后缀。

由于后缀数组的性质，所有满足与$a$的LCP长度大于等于$L$的位置在数组中连续。

用ST表维护height值，然后二分这个区间的右端点，再查询这一段区间中，起始位置的最小值即可。

我们从左到右扫后缀数组的每个位置，肯定是能用就一直用，不能用的之后也不可能再用（长度递增枚举）。所以用一个指针线性扫即可。

时间复杂度$O(n\log n)$。

## Code：
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#define N 300005
#define log2(a)(31-__builtin_clz(a))
std::vector<int>vec;
int s[N],sgm,n,x[N],y[N],height[N],c[N],sa[N],lp[19][N],st[19][N];
void sort(){
    int m=vec.size();
    for(int i=1;i<=m;++i)c[i]=0;
    for(int i=1;i<=n;++i)++c[x[i]=s[i]];
    for(int i=1;i<=m;++i)c[i]+=c[i-1];
    for(int i=n;i;--i)sa[c[x[i]]--]=i;
    for(int k=1,p;k<=n;k<<=1){
        p=0;
        for(int i=n-k+1;i<=n;++i)y[++p]=i;
        for(int i=1;i<=n;++i)if(sa[i]>k)y[++p]=sa[i]-k;
        for(int i=1;i<=m;++i)c[i]=0;
        for(int i=1;i<=n;++i)++c[x[i]];
        for(int i=1;i<=m;++i)c[i]+=c[i-1];
        for(int i=n;i;--i)sa[c[x[y[i]]]--]=y[i];
        std::swap(x,y);
        x[sa[1]]=p=1;
        for(int i=2;i<=n;++i)
        x[sa[i]]=y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]?p:++p;
        if(p==n)break;m=p;
    }
    for(int i=1,k=0;i<=n;++i)
    if(x[i]>1){
        k-=!!k;
        int j=sa[x[i]-1];
        while(s[i+k]==s[j+k])++k;
        height[x[i]]=k;
    }
}
void init(){
    for(int i=1;i<=n;++i)lp[0][i]=height[i],st[0][i]=sa[i];
    for(int i=0;i<18;++i)
    for(int j=1;j<=n;++j)
    if(j+(1<<i)<=n)lp[i+1][j]=std::min(lp[i][j],lp[i][j+(1<<i)]),st[i+1][j]=std::min(st[i][j],st[i][j+(1<<i)]);else break;
}
inline int lcp(int l,int r){
    int lg=log2(r-l+1);
    return std::min(lp[lg][l],lp[lg][r-(1<<lg)+1]);
}
inline int mini(int l,int r){
    int lg=log2(r-l+1);
    return std::min(st[lg][l],st[lg][r-(1<<lg)+1]);
}
int solve(int L,int len){
    int l=L+1,r=n;
    while(l<=r){
        const int mid=l+r>>1;
        if(lcp(L+1,mid)>=len)l=mid+1;else r=mid-1;
    }
    return mini(L,l-1);
}
int main(){
    scanf("%d%d",&sgm,&n);
    if(sgm==26){
        char t[N];
        scanf("%s",t+1);
        for(int i=1;i<=n;++i)vec.push_back(s[i]=t[i]);
    }else
    for(int i=1;i<=n;vec.push_back(s[i++]))scanf("%d",s+i);
    std::sort(vec.begin(),vec.end());
    vec.erase(std::unique(vec.begin(),vec.end()),vec.end());
    for(int i=1;i<=n;++i)s[i]=std::lower_bound(vec.begin(),vec.end(),s[i])-vec.begin()+1;
    sort();init();
    for(int i=1,it=1;i<=n;++i){
        while(it<=n&&n-sa[it]+1<i)++it;
        printf("%d ",solve(it,i));
    }
    return 0;
}

```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

给定一个长度为 $n$ 的序列 $a$，你需要对于每一个 $L\in [1,n]$，求所有长度为 $L$ 的区间中，字典序最小的区间的左端点（若有多个相同的区间，输出最小左端点）。

$1\leq n\leq 3\times 10^5,1\leq a_i\leq 10^7$。

## 思路

挺简单的 SAM 题，自己独立都可以想出来。

首先看到题目，对于一个字符串搞点抽象东西，SAM 或者 SA 没得跑了，但是我不是很会 SA，所以选择 SAM。然后问题就是如何在 SAM 上刻画字典序信息？在 trans 边上搞就没有前途，所以考虑 parent tree。

由于 parent tree 的本质其实是一个二度点压缩的 trie，所以可以干很多 trie 能干的操作。而 trie 维护字典序再容易不过了，对 trie 跑 dfs，每次访问钦定出边顺序即可。这个想法可以自然地迁移到 parent tree 上。

具体地，我们建立反串的 SAM，记录每个点的 $L_i$ 表示每个节点（endpos 等价类）所代表的在原串的最小左端点，然后在 parent tree 上 dfs，将所有出边按照下一个字符排序，从大到小访问。访问到一个节点，就维护一个数据结构，支持区间赋值单点询问，每次将这个 endpos 等价类覆盖的长度区间推平为 $L_i$，最后查询答案。这个数据结构线段树就可以维护。

时间复杂度 $O(n\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ls (i << 1)
#define rs (i << 1 | 1)
using namespace std;

template<int N>
struct SuffixAutomaton {
    int link[N << 1], len[N << 1], cur, tot;
    int cnt, lst[N << 1], per[N <<1];
    vector<int> ptr[N << 1];
    map<int, int> trans[N << 1];

    SuffixAutomaton(){ link[0] = -1; }

    void extend(int c){
        int x = cur; cur = ++tot;
        len[cur] = len[x] + 1;
        lst[cur] = ++cnt, per[cnt] = cur;
        for(;(~x)&&(!trans[x][c]);x=link[x]) trans[x][c] = cur;
        if(!(~x)) return link[cur] = 0, void();
        int y = trans[x][c];
        if(len[y] == len[x] + 1) return link[cur] = y, void();
        int u = ++tot, d = y;
        link[u] = link[y], link[d] = link[cur] = u, len[u] = len[x] + 1;
        for(auto i : trans[d]) trans[u][i.first] = i.second;
        for(;(~x)&&(trans[x][c]==y);x=link[x]) trans[x][c] = u;
    }

    void build(){
        for(int i=1;i<=tot;i++) ptr[link[i]].push_back(i);
    }
};

const int N = 3e5 + 5;
int n, a[N];
SuffixAutomaton<N> sam;

int lft[N << 1], tag[N << 2];

void pushdown(int i){
    if(!tag[i]) return;
    tag[ls] = tag[rs] = tag[i], tag[i] = 0;
}

void update(int ql, int qr, int v, int i, int l, int r){
    if(ql <= l && r <= qr) return tag[i] = v, void();
    pushdown(i);
    int mid = (l + r) >> 1;
    if(ql <= mid) update(ql, qr, v, ls, l, mid);
    if(mid < qr) update(ql, qr, v, rs, mid + 1, r);
}

int query(int p, int i, int l, int r){
    if(l == r) return tag[i];
    pushdown(i);
    int mid = (l + r) >> 1;
    if(p <= mid) return query(p, ls, l, mid);
    else return query(p, rs, mid + 1, r);
}

void dfs(int u){
    sort(sam.ptr[u].begin(), sam.ptr[u].end(), [u](int x, int y){
        return a[lft[x] + sam.len[u]] > a[lft[y] + sam.len[u]];
    });
    if(u) update(sam.len[sam.link[u]] + 1, sam.len[u], lft[u], 1, 1, n);
    for(int v : sam.ptr[u]) dfs(v);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int sigma; cin >> sigma >> n;
    if(sigma == 26){
        string s; cin >> s;
        for(int i=0;i<s.size();i++) a[i + 1] = s[i] - 'a';
    }
    else{
        for(int i=1;i<=n;i++) cin >> a[i];
    }
    for(int i=n;i;i--) sam.extend(a[i]);
    sam.build();
    for(int i=1;i<=n;i++){
        for(int u=sam.per[n-i+1];~u&&!lft[u];u=sam.link[u]) lft[u] = i;
    }
    dfs(0);
    for(int i=1;i<=n;i++) cout << query(i, 1, 1, n) << ' ';
    cout << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：Zi_Gao (赞：0)

本做法参考了 [5k\_sync\_closer](https://www.luogu.com.cn/user/388651) 的文章 [如何用 Lyndon 薄纱 SA](https://www.luogu.com.cn/article/2oa4ykad)

首先有使用 SA 的做法，但是基于比较的排序的复杂度下限就是 $\mathcal{O}(n\log n)$，但是 SA 无论怎么做，当字符集较大时不能做到 $\mathcal{O}(n)$，所以这个不算严格 $\mathcal{O}(n)$。

考虑使用 Lyndon 分解，设字符串分解为 $s=w_1+w_2+\cdots+w_k$。那么根据 Lyndon 串性质，选在 $w$ 中间一定不优，于是只需要考虑选在分解的开头。

然后由于 $w$ 单调不增所以可以先找到最后一个位置 $p$，使得 $\sum_{j=p}^k|w_j|\geq i$，那么 $w_p$ 的前缀就是答案，但是这时候不一定是第一个这个子串出现的位置，所以考虑向前找到第一个 $w_{p\prime}$ 使得，$w_{p\prime}$ 前缀和 $w_p$ 相等，这个时候可以使用二分加哈希解决，复杂度 $\mathcal{O}(n\log n)$。

但是实际上不需要，考虑先求出 $\text{lcp}(w_{p-1},w_p)$，实际上这是可以 $\mathcal{O}(n)$ 做到的，观察贪心求解 Lyndon 分解时，连续的一段 Lyndon 串周期（结尾可能是不完整的一个周期）中的每个分解都有一段 lcp，两段 Lyndon 串周期之间就没有 lcp 了，所以可以直接找出 lcp。

由于分解单调不增，所以每个分解起始位置的后缀同样单调不增，所以其实这就是一个 Lyndon 分解的 height 数组，同样可以从中求得两个分解之间的 lcp，也是之间的最小值。

然后就可以考虑，从 $1$ 到 $k$ 顺次考虑每个分解，用一个单调栈维护到前面位置的 lcp。然后用一个指针指向栈中的一个位置，每次需要求的 $i$ 变小，指针向栈底调整即可。若当前指针的元素被取 min 覆盖，把指针指向栈顶即可，由于每次覆盖的时候前面的元素都被删了，所以复杂度就是严格 $\mathcal{O}(n)$。

本文可能有误，毕竟似乎没人提到过 Lyndon 分解的 height 数组这样的东西，如有错误敬请指出。

---

## 作者：Arghariza (赞：0)

不考虑左端点最小，如何求出一个字典序最小子串，只需要建出后缀数组后找最小的 $i$ 满足 $n-\text{sa}_i+1\ge L$，然后取 $S[\text{sa}_i,\text{sa}_i+L-1]$ 即可。

现在的问题在于可能存在一个 $j>i$ 使得 $S[\text{sa}_i,\text{sa}_i+L-1]=S[\text{sa}_j,\text{sa}_j+L-1]$，并且 $\text{sa}_i>\text{sa}_j$，这样的话 $S[\text{sa}_j,\text{sa}_j+L-1]$ 的左端点就更小了。

但是注意到 $\text{sa}$ 是按照字典序排序的，也就是说，$\text{lcp}(S[\text{sa}_i,n],S[\text{sa}_j,n])$ 在 $i$ 固定时随着的 $j$ 递增而单调不升，那么合法的 $j$ 是一段以 $i$ 为左端点的区间 $[i,p]$。如果我们求出了这个区间，我们就查询 $k\in[i,p]$ 的 $\text{sa}_k$ 的最小值即可。

由于两个后缀 $S[\text{sa}_i,n],S[\text{sa}_j,n]$ 的 LCP 长度相当于 $\min\limits_{k\in [i+1,j]}\text{height}_k$，所以处理出 $\text{height}$ 数组后建 ST 表支持 $O(1)$ RMQ，然后直接二分右端点 $p$ 找到最小的 $p$ 满足 $\text{lcp}(S[\text{sa}_i,n],S[\text{sa}_j,n])\ge L$ 就做完了。

复杂度 $O(n\log n)$。

```cpp
// Problem: P5108 仰望半月的夜空
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5108
// Memory Limit: 500 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> pi;
typedef tuple<int, int, int> tu;
bool Mbe;

const int M = 25;
const int N = 3e5 + 200;

int n, m, len, t[N], s[N];
int sa[N], rk[N], id[N], ct[N], h[N];

void rst() {
	memset(ct, 0, sizeof(int) * (m + 5));
	for (int i = 1; i <= n; i++) ct[rk[i]]++;
	for (int i = 1; i <= m; i++) ct[i] += ct[i - 1];
	for (int i = n; i; i--) sa[ct[rk[id[i]]]--] = id[i];
}

void SA() {
	rst();
	for (int w = 1, p = 0; w <= n && p != n; w <<= 1, m = p) {
		p = 0;
		for (int i = n - w + 1; i <= n; i++) id[++p] = i;
		for (int i = 1; i <= n; i++) if (sa[i] > w) id[++p] = sa[i] - w;
		rst(), swap(rk, id), p = rk[sa[1]] = 1;
		for (int i = 2; i <= n; i++) rk[sa[i]] = (id[sa[i]] == id[sa[i - 1]] && id[sa[i] + w] == id[sa[i - 1] + w]) ? p : ++p;
	}
	for (int i = 1, j = 0; i <= n; i++) {
		if (j) j--;
		while (s[i + j] == s[sa[rk[i] - 1] + j]) j++;
		h[rk[i]] = j;
	}
}

struct ST {
	int f[N][M];
	void init(int *s) { 
		for (int i = 1; i <= n; i++) f[i][0] = s[i]; 
		for (int j = 1; (1 << j) <= n; j++)
			for (int i = 1; i + (1 << j) - 1 <= n; i++)
				f[i][j] = min(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
	}
	int qry(int l, int r) {
		int len = __lg(r - l + 1);
		return min(f[l][len], f[r - (1 << len) + 1][len]);
	}
} S, T;

void solve() {
	cin >> m >> n;
	for (int i = 1; i <= n; i++) {
		if (m == 26) {
			char ch; cin >> ch;
			s[i] = ch - 'a' + 1;
		} else cin >> s[i];
		t[++len] = s[i], id[i] = i;
	}
	sort(t + 1, t + len + 1), len = unique(t + 1, t + len + 1) - t - 1;
	for (int i = 1; i <= n; i++) rk[i] = s[i] = lower_bound(t + 1, t + len + 1, s[i]) - t;
	m = len + 1, SA(), S.init(h), T.init(sa);
	for (int p = 1, i = 1; p <= n; p++) {
		while (sa[i] > n - p + 1) i++;
		int pos = i;
		for (int l = i + 1, r = n; l <= r; ) {
			int md = (l + r) >> 1;
			if (S.qry(i + 1, md) >= p) pos = md, l = md + 1;
			else r = md - 1;
		}
		cout << T.qry(i, pos) << ' ';
	}
}

bool Med;
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Mbe - &Med) / 1048576.0 << " MB\n";
	#ifdef FILE
		freopen("1.in", "r", stdin);
		freopen("1.out", "w", stdout);
	#endif
	int T = 1;
	// cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：ZZ作者 (赞：0)

> 算法：后缀排序，并查集

先对原序列做后缀排序，那么满足字典序最小即排名靠前

但是在考虑一定长度的所有子串时，因为只比较这些位，可能会出现后缀 $S_x,S_y$ 满足 $rk_x<rk_y$ 但 $x>y$，这个时候答案应当为 $y$ 而非排名靠前的 $x$

若当前考虑长度为 $L$ 的答案，那么若长度不小于 $L$ 且排名最靠前的后缀已知，那么所有可能成为答案的串是排名序列上从此后缀开始的一段连续的序列，且序列中所有元素两两之间最长公共前缀不小于 $L$

那么可以从大到小枚举 $L$，依次加入后缀，并把排名序列中所有最长公共前缀不小于 $L$ 的排名相邻且都已被加入的后缀用并查集合并，并查集中维护块内最左的原串位置，那么只需记录当前加入过的最小排名，他所属的块中最左的原串位置即为答案

复杂度 $O(n\log n)$，可以把并查集部分用按秩合并优化到单次 $O(\alpha(n))$，但实测效率没有明显提升，~~实际上和不加优化的用时是 完 全 一 致 的 611ms~~，离散化和后缀排序是比较满的 $\log$，其余部分常数较小

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int read(){
	int f=0,s=0; char c=getchar();
	while(c>'9'||c<'0')f=(c=='-'),c=getchar();
	while(c>='0'&&c<='9')s=(s<<3)+(s<<1)+(c^'0'),c=getchar();
	return f?-s:s;
}

const int N=300005;
int k,n;
char s[N];
int a[N],b[N];

int m;
int buc[N],rk[N],tp[N],sa[N];
void rsort(){
	for(int i=1;i<=m;i++)buc[i]=0;
	for(int i=1;i<=n;i++)buc[rk[i]]++;
	for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
	for(int i=n;i>=1;i--)sa[buc[rk[tp[i]]]--]=tp[i];
}
void getsa(){
	for(int i=1;i<=n;i++)rk[i]=a[i],tp[i]=i; rsort();
	for(int p=0,w=1;p<n&&w<=n;m=p,w<<=1){
		p=0;
		for(int i=n-w+1;i<=n;i++)tp[++p]=i;
		for(int i=1;i<=n;i++)if(sa[i]>w)tp[++p]=sa[i]-w;
		rsort(); swap(rk,tp);
		rk[sa[1]]=1; p=1;
		for(int i=2;i<=n;i++){
			if(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+w]==tp[sa[i-1]+w])rk[sa[i]]=p;
			else rk[sa[i]]=++p;
		}
	}
}
int h[N];
void geth(){
	int k=0;
	for(int i=1;i<=n;i++){
		if(k)k--;
		while(a[i+k]==a[sa[rk[i]-1]+k])k++;
		h[rk[i]]=k;
	}
}
#define pb push_back
vector<int> v[N];

int now;
int f[N],mi[N],sz[N];
int fd(int x){ return f[x]==x?f[x]:f[x]=fd(f[x]); }
void mer(int x,int y){ x=fd(x); y=fd(y); if(x==y)return; if(sz[x]<sz[y])swap(x,y); f[y]=x; sz[x]+=sz[y]; mi[x]=min(mi[x],mi[y]); }
bool vis[N];
int ans[N];

int main(){
	k=read(); n=read();
	if(k==26){
		scanf("%s",s+1);
		for(int i=1;i<=n;i++)a[i]=b[i]=s[i]-'a'+1;
	}
	else for(int i=1;i<=n;i++)a[i]=b[i]=read();
	sort(b+1,b+n+1); m=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+m+1,a[i])-b;
	getsa(); geth();
	for(int i=1;i<=n;i++)v[h[i]].pb(i);
	for(int i=1;i<=n;i++)f[i]=i,mi[i]=sa[i],sz[i]=1;
	now=n+1;
	for(int i=n;i>=1;i--){
		int p=rk[n-i+1];
		now=min(now,p);
		vis[p]=1;
		if(p>1&&vis[p-1]&&h[p]>=i)mer(p,p-1);
		if(p<n&&vis[p+1]&&h[p+1]>=i)mer(p,p+1);
		for(auto x:v[i])if(vis[x]&&vis[x-1])mer(x,x-1);
		ans[i]=mi[fd(now)];
	}
	for(int i=1;i<=n;i++)printf("%d ",ans[i]);
	return 0;
}
```

---


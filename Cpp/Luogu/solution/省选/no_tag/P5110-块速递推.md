# 块速递推

## 题目背景

shadowice1984 发现了一道题：求斐波那契数列第 $n$ 项模 $10^9+7$ 的值，$n \leq 10^9$。

shadowice1984 想了一个星期可他还是不会做。

当然，这是 shadowice1984 刚学 OI 时候的事情了，今天他学习了矩阵快速幂并且花了一整天解决了上面的问题。

他决定出一道题来测试你的矩阵快速幂水平如何，为了检查他花了一个星期写出的 std 到底有没有错，他决定让你来帮他验题。

## 题目描述

给定一个数列 $a$ 满足递推式

$$a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1$$

求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。

为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：

```C
namespace Mker
{
	unsigned long long SA,SB,SC;
	void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
	unsigned long long rand()
	{
	    SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
	    unsigned long long t=SA;
		SA=SB,SB=SC,SC^=t^SA;return SC;
	}
}
```
在调用 `Mker::init()` 函数之后这个随机数生成器便可以正常工作了，当你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n$ 值。

为了减少你的输出量，你只需要输出所有询问答案的异或和。

## 说明/提示

$SA,SB,SC$ 均在 `unsigned long long` 数据类型的范围之内，由此可以发现返回的 $n$ 值也是 `unsigned long long` 数据类型的范围之内。

前 6 个测试点每个测试点 $1$ 分。

对于 1,2 测试点 $T \leq 5000$。

对于 3,4,5,6 测试点 $T \leq 500000$。

对于所有测试点 $1 \leq T \leq 5×10^7$。

## 样例 #1

### 输入

```
4779 17790102303135 73152356900611 22086182463002```

### 输出

```
391030355```

## 样例 #2

### 输入

```
49999561 116754637679537 79587668206509 80161279644028```

### 输出

```
705437004```

# 题解

## 作者：ezoixx130 (赞：53)

这里讲一种不用生成函数什么的东西求通项公式的方法：待定系数法

首先 $\Large a_n=233a_{n-1}+666a_{n-2},a_0=0,a_1=1$

设$\Large a_{n+2}+pa_{n+1}=q(a_{n+1}+pa_n)$

则$\Large p,q$ 满足$\Large q-p=233$  ， $\Large pq=666$

即$\Large q^2-233q-666=0$ 

解得$\Large q=\frac{233\pm\sqrt{56953}}{2},p=\frac{-233\pm\sqrt{56953}}{2}$ 

当$\Large q=\frac{233+\sqrt{56953}}{2},p=\frac{-233+\sqrt{56953}}{2}$ 时

$\Large a_{n+2}+\frac{-233+\sqrt{56953}}{2}a_{n+1}=\frac{233+\sqrt{56953}}{2}(a_{n+1}+\frac{-233+\sqrt{56953}}{2}a_n)$  （①式）

设$\Large b_n=a_{n+1}+\frac{-233+\sqrt{56953}}{2}a_n$

则$\Large b_{n+1}=a_{n+2}+\frac{-233+\sqrt{56953}}{2}a_{n+1}$

将上两式代入①式得$\Large b_{n+1}=\frac{233+\sqrt{56953}}{2}b_n$

于是我们知道了$\Large \{b_n\}$ 是等比数列。

又因为$\Large b_1=a_2+\frac{-233+\sqrt{56953}}{2}a_1=233+\frac{-233+\sqrt{56953}}{2}$ 

所以$\Large b_n=(\frac{233+\sqrt{56953}}{2})^{n-1}(233+\frac{-233+\sqrt{56953}}{2})=(\frac{233+\sqrt{56953}}{2})^n$

所以$\Large a_{n+1}+\frac{-233+\sqrt{56953}}{2}a_n=(\frac{233+\sqrt{56953}}{2})^n$ 

当$\Large q=\frac{233-\sqrt{56953}}{2},p=\frac{-233-\sqrt{56953}}{2}$ 时

同理得到$\Large a_{n+1}+\frac{-233-\sqrt{56953}}{2}a_n=(\frac{233-\sqrt{56953}}{2})^n$ 

上两式相减就可以得到$\Large \sqrt{56953}a_n=(\frac{233+\sqrt{56953}}{2})^n-(\frac{233-\sqrt{56953}}{2})^n$

$\Large a_n=\frac{(\frac{233+\sqrt{56953}}{2})^n-(\frac{233-\sqrt{56953}}{2})^n}{\sqrt{56953}}$

这就已经是这个数列的通项公式了。

但是我们只需要求这个数列在模$\Large 10^9+7$意义下的值，因此还可以继续推。

我们要求$\Large \sqrt{56953}$ 在模$\Large 10^9+7$意义下的值，就是要找到满足$\Large x^2 \equiv 56953 (\mod 10^9+7)$的$\Large x$ 。然后我们发现出题人选数选得刚刚好，我们找到了$\Large 188305837^2 \equiv 56953 (\mod 10^9+7)$ 。

然后就可以推出$\Large a_n \equiv \frac{(\frac{233+188305837}{2})^n-(\frac{233-188305837}{2})^n}{188305837}  (\mod 10^9+7)$

最后得到$\Large a_n=233230706(94153035^n-905847205^n) (\mod 10^9+7)$

完美！

然后就可以用光速幂每次$O(1)$ 求答案了。

---

## 作者：xgzc (赞：24)

这里给出一种使用特征方程解此题的方法

**Warning: 大波公式警告**

----

$a_n=233a_{n-1}+666a_{n-2}$的特征方程为

$$x^2=233x+666$$

$$x^2-233x+666=0$$

$$x_1=\frac{233+\sqrt{56953}}2,x_2=\frac{233-\sqrt{56953}}2$$

$$\therefore a_n=\alpha x_1^n+\beta x_2^n$$

$$\because a_0=0,a_1=1$$

$$\therefore \begin{cases} \alpha+\beta=0\\ \alpha x_1+\beta x_2=1 \end{cases}$$

$$\therefore \begin{cases} \alpha=\frac1{\sqrt{56953}} \\ \beta=-\frac1{\sqrt{56953}} \end{cases}$$

$$\therefore a_n=\frac1{\sqrt{56953}}\left(\left(\frac{233+\sqrt{56953}}2\right)^n-\left(\frac{233-\sqrt{56953}}2\right)^n\right)$$
$$\because 188305837 \equiv \sqrt{56953} \; (\text{mod}\;10^9+7)$$
$$\therefore a_n \equiv 233230706 \times\left(94153035^n-905847205^n\right)$$

求里面两个底数的$n$次方如何$O(1)$求？~~分段打表~~

设$f_1(n)=x^{65536n},f_2(n)=x^n$

则：

$$ x^n=f_1(n/65536)\times f_2(n\%65536) $$

就可以了。

复杂度$\text{O}(T)$，$T$是询问次数

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define RG register

namespace Maker
{
    unsigned long long SA, SB, SC;
    void init() { scanf("%llu%llu%llu", &SA, &SB, &SC); }
    inline unsigned long long rand()
    {
        SA ^= SA << 32, SA ^= SA >> 13, SA ^= SA << 1;
        unsigned long long t = SA;
        SA = SB, SB = SC, SC ^= t ^ SA;
		return SC;
    }
}

const int Mod(1e9 + 7), alpha(233230706), x_1(94153035),
	  x_2(905847205), x_3(64353223), x_4(847809841);
const int maxn(65536 + 5);
int f_1[maxn], f_2[maxn], f_3[maxn], f_4[maxn], T, ans;

inline int Pow_1(int x) { return 1ll * f_3[x >> 16] * f_1[x & 65535] % Mod; }
inline int Pow_2(int x) { return 1ll * f_4[x >> 16] * f_2[x & 65535] % Mod; }

int main()
{
	f_1[0] = f_2[0] = f_3[0] = f_4[0] = 1;
	for(RG int i = 1; i < 65536; i++) f_1[i] = 1ll * f_1[i - 1] * x_1 % Mod;
	for(RG int i = 1; i < 65536; i++) f_2[i] = 1ll * f_2[i - 1] * x_2 % Mod;
	for(RG int i = 1; i < 65536; i++) f_3[i] = 1ll * f_3[i - 1] * x_3 % Mod;
	for(RG int i = 1; i < 65536; i++) f_4[i] = 1ll * f_4[i - 1] * x_4 % Mod;
	scanf("%d", &T); Maker::init(); unsigned long long n;
	while(T--) n = Maker::rand() % (Mod - 1),
		ans ^= 1ll * alpha * (Pow_1(n) - Pow_2(n) + Mod) % Mod;
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：丛雨 (赞：17)



[传送门](https://www.luogu.com.cn/problem/P5110)

又是一道常系数线性递推的题，一下子便能想到矩阵快速幂，但一看数据规模

$$
1≤T≤5×10^7
$$

我们可以知道，普通的矩阵快速幂肯定是过不了的

![](https://cdn.luogu.com.cn/upload/image_hosting/q9wyuevj.png)

显然，本题只能接受$O(T)$时间复杂度的方法~~(LYT:?)~~ 

考虑光速幂

> 对于$x^y=(x^b)^{\lfloor\frac{y}{b}\rfloor}x^{y\%b}$,,我们预处理出$x^n(n<b)$,再预处理出$(x^b)^n$，令$b=a^k(k\in (0,1))$,则预处理时空复杂度为$O(b+\frac{y}{b})$,单次查询$O(1)$。
>
> 更一般的,$x^y=x^{a_0}(x^b)^{a_1}(x^{b^2})^{a_2}\cdots\Rightarrow y=a_0+a_1b+a_2b^2+a_3b^3\cdots$,就是将$y$进行$b$进制分解,对每一位进行预处理，令$b=a^k(k\in (0,1))$ 预处理空间复杂度为$O(b=a^k)$,查询时间复杂度为$O(\frac{1}{k})$.



## 1.矩阵光速幂

但我们可以发现,因为$a_i< 2^{64}$,所以$k=0.25$，对于$5*10^7$,哪怕处理了光速幂，$3$次矩阵乘法(约$30$的常数)也是难以通过的

![](https://cdn.luogu.com.cn/upload/image_hosting/q9wyuevj.png)



## 2.特征多项式？

我不会，这里推荐一个大佬的博客：[【学习笔记】特征多项式](https://blog.csdn.net/qq_42101694/article/details/103811029?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160871670716780273390997%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&request_id=160871670716780273390997&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-103811029.pc_v1_rank_blog_v1&utm_term=%E5%AD%A6%E4%B9%A0)

但$3$次多项式乘法(约$15$的常数)依然难以通过



![](https://cdn.luogu.com.cn/upload/image_hosting/q9wyuevj.png)



## 3.使用生成函数解出该式通解

先推导一些生成函数对应的函数


$$
\begin{aligned}
&\frac{1}{1-ax}=g\\
&1=g-axg\\
&axg+1=g\\
&g_0=1,g_{n+1}=ag_n\\
\end{aligned}
$$

$$
\begin{aligned}
&\frac{1}{a-x}=g\\
&1=ag-gx\\
&g=\frac{1+gx}{a}\\
&g_0=\frac{1}{a},g_{n+1}=\frac{g_n}{a}
\end{aligned}
$$



进入正题


$$
a_n=233a_{n-1}+666a_{n-2},a_0=0,a_1=1
$$
我们设函数g为序列a的生成函数
则有:
$$
\begin{aligned}
&233xg+666x^2g+x=g\\
\Leftrightarrow &g=\frac{x}{1-233x-666x^2}\\
\Leftrightarrow &g=-x\left(\frac{1}{666x^2+233x-1}\right)\\
\Leftrightarrow &-\frac{g}{x}=\frac{1}{666(x-\frac{-233+\sqrt{56953}}{1332})(x-\frac{-233-\sqrt{56953}}{1332})}\\
\Leftrightarrow &-\frac{666g}{x}=\frac{1}{(x-\frac{-233+\sqrt{56953}}{1332})(x-\frac{-233-\sqrt{56953}}{1332})}\\
\Leftrightarrow &-\frac{666g}{x}=\frac{\frac{1}{x-\frac{-233+\sqrt{56953}}{1332}}-\frac{1}{x-\frac{-233-\sqrt{56953}}{1332}}}{\frac{\sqrt{56953}}{666}}\\
\Leftrightarrow &\frac{g}{x}=\frac{\frac{1}{\frac{-233+\sqrt{56953}}{1332}-x}-\frac{1}{\frac{-233-\sqrt{56953}}{1332}-x}}{\sqrt{56953}}\\
&a_n=\frac{\left(\frac{233+\sqrt{56953}}{2}\right)^n-\left(\frac{233-\sqrt{56953}}{2}\right)^n}{\sqrt{56953}}
\end{aligned}
$$



这里补充一下最后一步的推导

$$
\begin{aligned}
&set\ a=\frac{-233+\sqrt{56953}}{1332} \\
&\Rightarrow \frac{1}{a}=\frac{233+\sqrt{56953}}{2}\\
&\frac{1}{\frac{-233+\sqrt{56953}}{1332}-x}\\
&=\sum_{i=0}^{+\infty}\frac{x^i}{a^{i+1}}\\
&set\ b=\frac{-233-\sqrt{56953}}{1332} \\
&\Rightarrow \frac{1}{b}=\frac{233-\sqrt{56953}}{2}\\
&\frac{1}{\frac{-233-\sqrt{56953}}{1332}-x}\\
&=\sum_{i=0}^{+\infty}\frac{x^i}{b^{i+1}}
\end{aligned}
$$


到了这一步，我们就可以通过$2$种方式来解决



### Ⅰ.扩域

可以看出，上式中出现了无理数，但在模意义下无理数是无意义的，因为模运算是定义在$L=Z\cap [0,mod=1000000007)$上的。(如无特殊说明，下文中四则运算皆为模意义下)

我们不妨定义域$K=(\{a+b\sqrt{56953}|a,b\in L\},+,*,-)$

#### 证明$K$为$L$的扩域

- 封闭性

 $ (a+b\sqrt{56953})(c+d\sqrt{56953})=(ac+56953bd)+(ad+bc)\sqrt{56953}\in K$

- 存在$+,*$

  显然

之后就可以像复数运算一样操作了

```cpp
#include<bits/stdc++.h>
using namespace std;
# define ll long long
# define read read1<ll>()
# define Type template<typename T>
# define fre(k) freopen(k".in","r",stdin);freopen(k".out","w",stdout)
Type T read1(){
	T t=0;
	char k;
	bool vis=0;
	do (k=getchar())=='-'&&(vis=1);while('0'>k||k>'9');
	while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();
	return vis?-t:t;
}
namespace Mker
{
	unsigned long long SA,SB,SC;
	void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
	unsigned long long rand()
	{
	    SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
	    unsigned long long t=SA;
		SA=SB,SB=SC,SC^=t^SA;return SC;
	}
}
# define mod 1000000007
# define M 32767
# define N 32768
# define inv2 500000004ll
struct A{
	int x,y;
	A& operator *=(const A &b){
		int t=y;
		y=(1ll*x*b.y+1ll*y*b.x)%mod;
		x=(1ll*x*b.x+56953ll*t%mod*b.y)%mod;
		return *this;
	}
	A operator *(const A &b){A t=*this;return t*=b;}
}f[2][N|1],f1[2][N|1],o,p;
int main(){
	int T=read,ans=0;
	Mker::init();o.x=233*inv2%mod,o.y=inv2;p.x=o.x,p.y=mod-inv2;
	f[0][0].x=f1[0][0].x=1;f[1][0].x=f1[1][0].x=1;
	for(int i=1;i<=N;++i)f[0][i]=f[0][i-1]*o,f[1][i]=f[1][i-1]*p;
	for(int i=1;i<=N;++i)f1[0][i]=f1[0][i-1]*f[0][N],f1[1][i]=f1[1][i-1]*f[1][N];
	while(T--){
		unsigned ll n=Mker::rand()%(mod-1);
		int w=n>>15&M,t=(1ll*f[0][n&M].x*f1[0][w].y+1ll*f[0][n&M].y*f1[0][w].x-1ll*f[1][n&M].x*f1[1][w].y-1ll*f[1][n&M].y*f1[1][w].x)%mod;
		if(t<0)t+=mod;ans^=t;
	}cout<<ans;
	return 0;
}
```



### Ⅱ.二次剩余

我们经过二次剩余可以知道，对于素数$mod$，我们可以找到唯一的$x$满足$x^2\equiv 56953 \mod mod$.



经过打表可知，对于本题，$188305837 \equiv 56953 \mod mod$





(可能你想知道

> Mker::rand()%(mod-1)

是为什么



通过$扩域$我们可以知道域$K$是满足域$L$的运算规则的，自然而然满足费马定理，所以在模意义下$a_n$与$a_{n+k(mod-1)}$相等

---

## 作者：shadowice1984 (赞：16)

没人写正解出题人很伤心啊qwq……

为什么循环节是$10^9+6$啊？因为出题人给你凑好了模数才是有这个循环节的

考试时候为了避免大家自闭所以没有去卡分段矩乘的做法，其实分段矩乘的空间占用是标算的二倍，根据这一点我们可以通过卡空间的方式来吧矩乘卡下去

~~(天呐上面都是什么duliu东西)~~

__________________

## 本题题解

让我们把这个数列的通项公式手玩出来，这里用生成函数给出了一种推导，如果您会特征方程可以用特征方程推

设这个数列的生成函数为$G(z)$

$$G(z)=233zG(z)+666z^{2}G(z)+z$$

$$(1-233z-666z^2)G(z)=z$$

$$G(z)=\frac{z}{1-233z-666z^2}$$

设$x_{1},x_{2}$为方程$1-233x-666x^2=0$的两个根

$$G(z)=\frac{z}{-666(x_{1}-z)(x_{2}-z)}$$

$$G(z)=\frac{z}{-666}×\frac{1}{(x_{1}-z)(x_{2}-z)}$$

$$G(z)=\frac{z}{-666(x_{1}-x_{2})}×\frac{x_{1}-z+z-x_{2}}{(x_{1}-z)(x_{2}-z)}$$

$$G(z)=\frac{z}{-666(x_{1}-x_{2})}×(\frac{1}{x_{2}-z}-\frac{1}{x_{1}-z})$$

$$G(z)=\frac{1}{-666(x_{1}-x_{2})}×(\frac{1}{x_{2}}×\frac{z}{1-\frac{z}{x_{2}}}-\frac{1}{x_{1}}×\frac{z}{1-\frac{z}{x_{1}}})$$

根据$\frac{z}{1-\lambda z}$是数列$0,1,\lambda^{1},\lambda^{2},\lambda^{3}$的生成函数可知

$$a(n)=\frac{1}{-666(x_{1}-x_{2})}×((\frac{1}{x_{2}})^{n}-(\frac{1}{x_{1}})^{n})$$

将$$x_{1,2}=\frac{233\pm \sqrt{56953}}{-1332}$$带入得

$$a(n)=\frac{1}{\sqrt{56953}}((\frac{233+\sqrt{56953}}{2})^{n}-(\frac{233-\sqrt{56953}}{2})^{n})$$

好了看起来我们发现通项公式里面有一个$\sqrt{56953}$这该怎么办呢？

通过暴力for循环我们可以知道这样一个事实

$$188305837^2 \equiv 56953 \mod 10^9+7$$

好了此时我们就可以将公式里面的$\sqrt{56953}$全部换成188305837就行了

现在我们就是要求$O(1)$的实现定底数的快速幂

这个其实相当的好办我们将每个数字的$n$次幂表示成$32769k+r$的形式

这样的话我们需要打两个表，$f1(n)=x^{32768n},f2(n)=x^{n}$而且这两个表的长度范围都是32768之内的，复杂度可以接受

那么此时

$$x^{p}=f1(p/32768)f2(p \mod 32768)$$

就可以支持$O(1)$的快速幂了,由于费马小定理的存在我们可以将指数取个膜这样指数就是$10^9$级别的了

这里将块长定为32768主要是除法和膜法都可以用右移运算和按位与运算来代替，可以降低一些常数

如此这般我们就将算法的复杂度由$O(Tlogn)$优化到了$O(T)$无需卡常数就可以轻松的通过本题啦~

~~不知道为什么很多人宁愿去卡矩乘的常也不愿意静下心来掏出一支铅笔和一张草稿纸推个通项公式~~

上代码~

```C
#pragma GCC optimize(Ofast)
#pragma GCC optimize(3)
#include<cstdio>
#include<algorithm>
using namespace std;typedef long long ll;const ll mod=1e9+7;const ll sqr=188305837;
namespace Mker
{
    unsigned long long SA,SB,SC;
    void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
    unsigned long long rand()
    {
        SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
        unsigned long long t=SA;
        SA=SB,SB=SC,SC^=t^SA;return SC;
    }
}
const ll x1=94153035;const ll x2=905847205;const ll K=233230706;
const ll x3=64353223;const ll x4=847809841;
ll mi1[65536+10];ll mi2[65536+10];ll mi3[65536+10];ll mi4[65536+10];
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
# define pw1(x) (mi3[x>>16]*mi1[x&65535]%mod)
# define pw2(x) (mi4[x>>16]*mi2[x&65535]%mod)
int T;int ans;
int main()
{
    //freopen("tst10.in","r",stdin);freopen("tst10.out","w",stdout);
    mi1[0]=1;for(int i=1;i<65536;i++)mi1[i]=mi1[i-1]*x1%mod;
    mi2[0]=1;for(int i=1;i<65536;i++)mi2[i]=mi2[i-1]*x2%mod;
    mi3[0]=1;for(int i=1;i<65536;i++)mi3[i]=mi3[i-1]*x3%mod;
    mi4[0]=1;for(int i=1;i<65536;i++)mi4[i]=mi4[i-1]*x4%mod;
    scanf("%d",&T);Mker::init();unsigned long long n;
    for(int i=1;i<=T;i++)n=Mker::rand(),n%=(mod-1),ans^=K*(pw1(n)+mod-pw2(n))%mod;
    printf("%d",ans);return 0;
}
```









---

## 作者：da32s1da (赞：8)

考虑**矩阵快速幂**。

但是只有**6**分。

考虑到矩阵有**循环节**，本题为**1e9+6**。即每$10^9+6$个数循环一次。

所以可以将$n$缩小到$10^9+7$范围内。

此时大概是$22s$。显然是不可以的。

考虑**分块**。

我们将$\sqrt{Mod}$内的**答案**矩阵**预处理**出来，然后将$\ k\sqrt{Mod}\ ,\ 0\le k \le \sqrt{Mod}\ $的**递推**矩阵**预处理出来**。

对于一个询问$\ n=v\sqrt{Mod}+u$，我们就可以将$u$的答案矩阵与$v\sqrt{Mod}$的递推矩阵乘一次，直接得到答案。

复杂度$O(T+20..30\sqrt{Mod})$。可以通过本题

~~代码比较丑陋，因为我卡常数来着~~

~~嫌太长可以不看，毕竟理解了原理自己码就行了~~

```
d[0][i][][]存第i个的答案矩阵
d[1][i][][]存i*sqrt{Mod}的递推矩阵

答案只与答案矩阵的第一行和递推矩阵的第一列有关
所以我只存了这两个。

#include<cstdio>
typedef unsigned long long LL;
const int mod=1e9+7;
const int N=31625;
LL SA,SB,SC,t,n;
int a[2][2],b[2][2],ans,T;
LL c[2][2];
int d[2][N+1][2][2];
int main(){
    scanf("%d%llu%llu%llu",&T,&SA,&SB,&SC);
    register int i,j,k,p,u,v;
    a[0][0]=a[1][0]=a[1][1]=0;
    a[0][1]=1;
    b[0][0]=0;
    b[1][0]=1;
    b[0][1]=666;
    b[1][1]=233;
    d[0][0][0][1]=1;
    for(n=1;n<=N;n++){
        c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
        for(j=0;j<2;++j)
        for(k=0;k<2;++k)
        for(p=0;p<2;++p)
        c[j][k]=(c[j][k]+1ll*a[j][p]*b[p][k]);
        a[0][0]=c[0][0]%mod;
        a[0][1]=c[0][1]%mod;
        a[1][0]=c[1][0]%mod;
        a[1][1]=c[1][1]%mod;
        d[0][n][0][0]=a[0][0];
        d[0][n][0][1]=a[0][1];
    }
    //暴力计算答案矩阵
    a[0][0]=a[1][1]=1;
    a[1][0]=a[0][1]=0;
    b[0][0]=0;
    b[1][0]=1;
    b[0][1]=666;
    b[1][1]=233;
    n=N;
    for(;n;n>>=1){
        if(n&1){
            c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
            for(j=0;j<2;++j)
            for(k=0;k<2;++k)
            for(p=0;p<2;++p)
            c[j][k]=(c[j][k]+1ll*a[j][p]*b[p][k]);
            a[0][0]=c[0][0]%mod;
            a[0][1]=c[0][1]%mod;
            a[1][0]=c[1][0]%mod;
            a[1][1]=c[1][1]%mod;
        }
        c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
        for(j=0;j<2;++j)
        for(k=0;k<2;++k)
        for(p=0;p<2;++p)
        c[j][k]=(c[j][k]+1ll*b[j][p]*b[p][k]);
        b[0][0]=c[0][0]%mod;
        b[0][1]=c[0][1]%mod;
        b[1][0]=c[1][0]%mod;
        b[1][1]=c[1][1]%mod;
    }
    //计算sqrt{Mod}的答案矩阵
    b[0][0]=a[0][0];
    b[0][1]=a[0][1];
    b[1][0]=a[1][0];
    b[1][1]=a[1][1];
    d[1][1][0][0]=a[0][0];
    d[1][1][1][0]=a[1][0];
    d[1][0][0][0]=1;
    //0时为单位矩阵
    for(n=2;n<=N;n++){
        c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
        for(j=0;j<2;++j)
        for(k=0;k<2;++k)
        for(p=0;p<2;++p)
        c[j][k]=(c[j][k]+1ll*a[j][p]*b[p][k]);
        a[0][0]=c[0][0]%mod;
        a[0][1]=c[0][1]%mod;
        a[1][0]=c[1][0]%mod;
        a[1][1]=c[1][1]%mod;
        d[1][n][0][0]=a[0][0];
        d[1][n][1][0]=a[1][0];
    }
    //计算k*sqrt{Mod}的递推矩阵
    for(i=1;i<=T;++i){
        SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
        t=SA;
        SA=SB,SB=SC,SC^=t^SA;
        n=SC%(mod-1);u=n%N;v=n/N;
        //循环矩阵-取模
        ans^=((1ll*d[0][u][0][0]*d[1][v][0][0]+1ll*d[0][u][0][1]*d[1][v][1][0])%mod);
        //计算答案。
    }
    printf("%d\n",ans);
}
```

---

## 作者：StayAlone (赞：6)

第一篇紫题题解~  
~~自认为能把新手讲懂。~~

--------

$a_n = 233a_{n - 1} + 666a_{n - 2}$ 的特征方程为 $p^2 = 233p + 666$，即 $p^2 - 233p + 666 = 0$。$p$ 的两个解为
$$
\begin{cases}
p1 = \dfrac{233 + \sqrt{56953}}{2} \\\\
p2 = \dfrac{233 - \sqrt{56953}}{2}
\end{cases}
$$

这两个解被称为“特征根”。

设该数列的通项公式为 $a_n = c1\cdot p1^n + c2\cdot p2^n$，其中 $c1,c2$ 为常数。  

直到这一步可以参考 [特征根方程 - 百度文库](https://wenku.baidu.com/view/37709e32f111f18583d05acb.html)。

将 $a_0 = 0, a_1 = 1$ 带入得：

$$
\begin{cases}
0 = c1 + c2 \\
1 = c1 \cdot \dfrac{233 + \sqrt{56953}}{2} + c2 \cdot \dfrac{233 - \sqrt{56953}}{2}
\end{cases}
$$

解得

$$
\begin{cases}
c1 = \dfrac{1}{\sqrt{56953}} \\
c2 = -c1 = -\dfrac{1}{\sqrt{56953}}
\end{cases}
$$

现在回到最开始的通项公式，可以直接用 $c2 = -c1$ 代入，
$$
a_n = c1 \cdot(p1^n - p2^n) 
$$
$$
a_n= \dfrac{(\dfrac{233 + \sqrt{56953}}{2})^n - (\dfrac{233 - \sqrt{56953}}{2})^n}{\sqrt{56953}}
$$
接下来开始大力推式子。

因为是在模的意义下，所以可以把 $\sqrt{56953}$ 消掉。

找 $\sqrt{56953}$ 与谁在 $\bmod\  10^9 + 7$ 的意义下同余 $\Leftrightarrow$ 找一个 $x$ 使得 $x^2\equiv56953\pmod {10^9 + 7}$。

显然有 $56953 \bmod (10^9 + 7) = 56953$，所以求 $x$ 的程序主体如下：

```cpp
typedef long long ll;

int main()
{
    for (ll i = 56953; ; ++i)
        if (i * i % mod == 56953)
            return printf("%lld", i), 0;
}
```

得到结果 $188305837$，把原式中的 $\sqrt{56953}$ 全部替换为 $188305837$ 后，与原式同余，即
$$
a_n \equiv \dfrac{(\dfrac{233 + 188305837}{2})^n - (\dfrac{233 - 188305837}{2})^n}{188305837} \pmod {10^9 + 7}
$$
化简得
$$
a_n \equiv \dfrac{94153035^n - (-94152802)^ n}{188305837}\pmod {10^9 + 7}
$$
而 $-94152802$ 可化为 $(-94152802) \bmod(10^9 + 7)  = 905847205$。

再次化简得
$$
a_n \equiv \dfrac{94153035^n - 905847205^ n}{188305837}\pmod {10^9 + 7}
$$

在模意义下，一个数除以 $m$ 与其乘 $m$ 的逆元等价；若模数 $p$ 是个质数，则 $x$ 的逆元为 $x^{p - 2} \bmod p$。


因为 $10^9 + 7$ 是质数（可以简单的写一个函数判断），故 $188305837$ 的逆元为 $188305837^{10^9 + 7 - 2} \bmod 10^9 + 7$，可用快速幂或者直接暴力求出。  

```cpp
ll f(ll a, ll b, ll k)
{
	if (k == 1) return 0;
	if (!b) return 1;
	ll ans = f(a, b >> 1, k);
	(ans *= ans) %= k;
	if (b&1) (ans *= a) %= k;
	return ans;
}

int main()
{
    cout << f(188305837, 1e9 + 5, 1e9 + 7);
    return 0;
}
```

得到结果 $233230706$，式子最终简化为
$$
a_n \equiv 233230706\cdot(94153035^n - 905847205^n)
$$

然后你前面写的所有程序都没用了，有用的只有最后这个精华式子。  

接下来光速幂 $O(\sqrt{p})$ 的时间复杂度预处理，接下来每次询问 $O(1)$ 算。如有不了解的，可以看看我的 [这篇博客](https://www.luogu.com.cn/blog/liangruichenBlog/guang-su-mi#)。

一个~~奇技淫巧~~小细节，因为 $10^9 + 7 \in \mathbb{P}$，所以 $\varphi(10^9 + 7) = 10^9 + 6$。

[AC code 记录](https://www.luogu.com.cn/record/56466616)

```cpp
#include <bits/stdc++.h>
#define rep1(i, j, n) for (int i = j; i <= int(n); ++i)
#define rep2(i, j, n) for (int i = j; i >= int(n); --i)
#define ptc(x) putchar(x)
#define il inline
#define pb push_back
#define mp make_pair
#define fst first
#define snd second
#define YES ptc('Y'), ptc('E'), ptc('S'), ptc('\n')
#define Yes ptc('Y'), ptc('e'), ptc('s'), ptc('\n')
#define NO ptc('N'), ptc('O'), ptc('\n')
#define No ptc('N'), ptc('o'), ptc('\n')
#define rout return 0
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int MAXN = 4e4 + 10, inf = ~0U >> 2, mod = 1e9 + 7;
const int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};
template <typename T>
il void read(T &x)
{
	x = 0; T f = 1; char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
	while (isdigit(ch)) {x = (x << 1) + (x << 3) + (ch & 15); ch = getchar();} x *= f;
}

template <typename T>
il void write(T x)
{
    if (x < 0) ptc('-'), x = -x;
    if (x > 9) write(x / 10);
    ptc(x % 10 + '0');
}

namespace Mker
{
	ull SA, SB, SC;
	void init(){scanf("%llu%llu%llu", &SA, &SB, &SC);}
	ull rand()
	{
	    SA ^= SA << 32, SA ^= SA >> 13, SA ^= SA << 1;
	    ull t = SA;
		return SA = SB, SB = SC, SC ^= t^SA, SC;
	}
}
int T, phi = mod - 1, op;
int a[MAXN << 1], a2[MAXN], b[MAXN << 1], b2[MAXN];

int f(int a, int b)
{
	if (mod == 1) return 0;
	if (!b) return 1;
	ll ans = f(a, b >> 1);
	(ans *= ans) %= mod;
	if (b&1) (ans *= a) %= mod;
	return ans;
}

int main()
{
	read(T); Mker::init(); a[0] = a2[0] = b[0] = b2[0] = 1;
	const int k = ceil(sqrt(1e9 + 7)), c1 = 94153035, c2 = 905847205;
	a[1] = f(c1, k); a2[1] = c1;
	rep1(i, 2, 2 * k) a[i] = 1ll * a[i - 1] * a[1] % mod;
	rep1(i, 2, k) a2[i] = 1ll * a2[i - 1] * a2[1] % mod;
	b[1] = f(c2, k); b2[1] = c2;
	rep1(i, 2, 2 * k) b[i] = 1ll * b[i - 1] * b[1] % mod;
	rep1(i, 2, k) b2[i] = 1ll * b2[i - 1] * b2[1] % mod;
	while (T--)
	{
		ull q = Mker::rand();
		if (q > phi) q = q % phi + phi;
		ll ans = (1ll * a[q / k] * a2[q % k] % mod - 1ll * b[q / k] * b2[q % k] % mod) % mod;
		(ans += mod) %= mod;
		(ans *= 233230706) %= mod;
		op ^= ans;
	}
	write(op); rout;
}
```



---

## 作者：KAMIYA_KINA (赞：5)

## Tag

生成函数。

## Description

你有这样一个式子：

$$
a_n=233a_{n-1}+666a_{n-2},a_0=0,a_1=1
$$

一共 $T$ 组询问，对于每一组询问会给出一个 $n$，你需要快速得到 $a_n$ 的值，输出所有询问的异或和。

## Solution

### 暴力1

直接递推，时间复杂度 $O(Tn)$，显然一个点都过不去吧……

### 暴力2

考虑题面中提到的矩阵快速幂做法，所以我们可以用矩阵快速幂去优化，考虑矩阵快速幂，对于，那么可以得到这样一个矩阵。

$$
\begin{pmatrix}
a_1 & a_0\\
0 & 0
\end{pmatrix}
\times
\begin{pmatrix}
1 & 233\\
0 & 666
\end{pmatrix}^n
$$

这个就是答案了。然后这样可以做到 $O(T\lg n)$。

但是你只能获得 $\text{6pts}$ 的~~好~~成绩。

~~md矩阵快速幂都只能拿$6pts$，淦。~~

### 正解

那就只能思考正解做法了，下文会用《组合数学》中特征方程的解法来解决这个问题。

我们设出这个序列 $\{a_n\}$ 的生成函数：

$$
F(x)=\sum_{i=0}^\infty a_ix^i
$$

试着将我们的公式套进去：

$$
F(x)-[x^0]F(x)-x[x^1]F(x)=233x(F(x)-[x^0]F(x))+666x^2F(x)
$$

换个意思表达：

$$
F(x)-a_0-a_1x=233x(F(x)-a_0)+666x^2F(x)
$$

我们很好理解这个方程，从右往左看，第一个 $F(x)$ 表示的是 $a_{n-2}$ 的值，整体的序列向右平移了 $2$ 位之后就可以与 $a_n$ 对齐了，那么同理的，第二个 $F(x)$ 就表示的是 $a_{n-1}$ 的值，然后整体向右平移 $1$ 位。

但是我们不容忽略的是，当 $a_1$ 与 $a_2$ 对齐了之后 $a_0$ 仍然存在于这个序列中，所以我们需要将 $a_0$ 所带来的的影响去掉，当然在这个题中间是没有必要的……

所以我们得到这样一个式子之后可以试着解一解了。

$$
\begin{aligned}
F(x)-a_0-a_1x&=666x(F(x)-a_0)+233x^2F(x)\\
F(x)-x&=666xF(x)+233x^2F(x)\\
F(x)&=\dfrac{x}{1-233x-666x^2}
\end{aligned}
$$

我们得到了这个母函数的封闭形式！

这个结论很让人激动，但是我们要继续解决这个问题，所以我们解一下后面这个丧心病狂的式子……

$$
\dfrac{x}{1-233x-666x^2}=\dfrac{x}{\left(1-\dfrac{233-\sqrt{56953}}{2}x\right)\left(1-\dfrac{233+\sqrt{56953}}{2}x\right)}
$$

我们设 $\alpha,\beta$ 为分母中 $x$ 的系数，所以可以得到

$$
\alpha=\dfrac{233-\sqrt{56953}}{2},\beta=\dfrac{233+\sqrt{56953}}{2}
$$

所以就有：

$$
F(x)=\dfrac{A}{1-\alpha x}+\dfrac{B}{1-\beta x}
$$

这里的 $A,B$ 都是待定系数：

$$
F(x)=A\sum_{i=0}^\infty \alpha^ix^i+B\sum_{i=0}^\infty \beta^ix^i
$$

然后解出 $A,B$ 的值：

$$
\begin{cases}
A+B=0\\
A\alpha + B\beta=1
\end{cases}
$$

解出来就可以得到：

$$
\begin{cases}
A=-\dfrac{1}{\sqrt{56953}}\\
B=\dfrac{1}{\sqrt{56953}}
\end{cases}
$$

所以

$$
[x^n]F(x)=\dfrac{\beta^n-\alpha^n}{\sqrt{56953}}
$$

但是这样时间复杂度还是 $O(T\lg n)$ 的啊……

不过 $\beta,\alpha$ 的值都是确定的，所以我们可以~~打表~~光速幂求解。

时间复杂度 $O(T)$，可以通过本题。


---

## 作者：s_r_f (赞：5)

首先这个递推公式在%(1e9+7)意义下是有循环节的。

~~打个表~~我们可以发现循环节是(1e9+6)

那么n就unsigned long long -> int了。

矩乘大家都会写吧？

嗯很好我们有6分了。

发现这题和P5107很像，我们可以用k进制矩乘来解决把矩乘次数从O(logn)降到O(1)次,一个优秀的实现每组询问可以只做1次矩乘。

不过这样还是超时啊T_T 

我们发现求最终答案时我们并不用乘出完整的矩阵,只要乘出a[1][1]一个量。

那么单次询问O(8) -> O(4)

O(5 × 1e7 × 4) = O(2 × 1e8) ~~开个O2~~就过了

非常ugly的代码：

```
#include <bits/stdc++.h>
#define LL long long
#define LLL unsigned long long
using namespace std;
inline int read(){//并无作用的快读
    int x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (c != EOF && isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}

namespace Maker{//真正的读入部分
    LLL SA,SB,SC;
    inline void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
    inline LLL rand(){ SA^=SA<<32,SA^=SA>>13,SA^=SA<<1; LLL t=SA; SA=SB,SB=SC,SC^=t^SA;return SC;}
}

const int P = 1e9 + 7;

struct Matrix{//矩阵
    int n,m,a[3][3];
    Matrix operator * (Matrix x){
        Matrix tmp; tmp.n = 2,tmp.m = x.m;
        int i,j,k,sum;
        for (i = 1; i <= n; ++i)
            for (j = 1; j <= x.m; ++j){
                sum = 0;
                for (k = 1; k <= m; ++k) sum = (sum + 1LL * a[i][k] * x.a[k][j] % P) % P; 
                tmp.a[i][j] = sum % P;
            }
        return tmp;
    }
}F,A,G[2][50005],PC[50005];
int p1[50005],g1[50005],p2[50005],g2[50005];

const int cyc = 1000000006,M = 1000000,C = 50004;
int T,x,a[M+5],n,ans = 0,nc[50005];
int Div,Mod;
int main(){
    int i;
    a[0] = 0,a[1] = 1;
    for (i = 2; i <= M; ++i) a[i] = (233LL * a[i-1] + 666LL * a[i-2]) % P; // 预处理小范围答案
    
    A.n = 2,A.m = 1,A.a[1][1] = a[M],A.a[2][1] = a[M-1];
    F.n = 2,F.m = 2,F.a[1][1] = 233,F.a[1][2] = 666,F.a[2][1] = 1,F.a[2][2] = 0;
    
    // 预处理矩阵(k进制矩乘用)
    PC[0] = A,G[0][1] = F,PC[1] = G[0][1] * A;
    for (i = 2; i < C; ++i) G[0][i] = G[0][i-1] * F,PC[i] = G[0][i] * A;
    G[1][1] = G[0][1] * G[0][C-1];
    for (i = 2; i < C; ++i) G[1][i] = G[1][i-1] * G[1][1];
    for (i = 0; i < C; ++i)
        p1[i] = nc[i] = PC[i].a[1][1],p2[i] = PC[i].a[2][1],
        g1[i] = G[1][i].a[1][1],g2[i] = G[1][i].a[1][2];
    //这里的p1,p2,g1,g2是为了减少struct访问的常数
    T = read();
    Maker::init();
    while (T--){
        x = Maker::rand() % cyc;// 对循环节取模
        if (x <= M) ans ^= a[x]; // 小范围答案直接查表
        else{
            n = x - M;
            if (n >= C){//只做一次矩乘,只乘出a[1][1]
                Div = n / C,Mod = n % C;
                ans ^= (1LL * g1[Div] * p1[Mod] + 1LL * g2[Div] * p2[Mod]) % P;//这里的p1,p2,g1,g2是为了减少struct访问的常数
            }
            else ans ^= nc[n]; 
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Spasmodic (赞：5)

以前在U群看到的做法，放在这好了

给定数列

$$a_n=\alpha\ a_{n-1}+\beta\ a_{n-2}$$

求$a_n\bmod p$

我们可以考虑解他的特征方程

$$x^2-\alpha x-\beta=0$$

两解分别为

$$x_1=\frac{\alpha+\sqrt{\alpha^2+4\beta}}{2},x_2=\frac{\alpha-\sqrt{\alpha^2+4\beta}}{2}$$

然后解一个二元一次方程就可以得到用$x_1,x_2$表示的通项公式

那么我们的问题就是怎么解决这个$x_1$和$x_2$

如果

$$(\frac{\alpha^2+4\beta}{p})=1$$

那么可以直接二次剩余求出啦

到这里为止其实我们已经解决了这道题本身，所以下面是如果把模数改成别的数的时候的做法

---

以下做法是U群的一群神仙给出的

如果不是二次剩余的话，我们就可以考虑扩个域

首先设集合$\mathbb{Z_p}$表示$\bmod p$的完系，然后显然它是个域

定义集合

$$S=\{a+b\sqrt{\alpha^2+4\beta}|a\in \mathbb{Z_p},b\in\mathbb{Z_p}\}$$

那么显然这也是一个域

然后我们会发现上面的那个东西完全可以在这个系里面算

所以自己实现一下这个域的四则运算（其实除法根本没必要），然后快速幂一下就可以了

注意到最后算出来的答案的根号部分系数显然为0，因为答案不可能是一个小数

所以我们就可以用一个快速幂解决它了。

---

## 作者：Zechariah (赞：3)

首先我们暴力找一下循环节，发现是1e9+6,然后考虑如何对每个询问O(1)求出  
这里用的是矩阵乘法，单位矩阵为  
233 666  
1   0  
考虑将指数n化成t\*y+x的形式，其中y为sqrt(1e9+6)，所以我们可以预处理出矩阵的mi1[]=0,1,2,3,...,y-1次幂和mi2[]=y,2y,3y,...,y(y+1)次幂，然后对于每个询问，我们要求的第n项就是mi2[(n-1)/y]\*mi1[(n-1)%y]\*ans，其中ans初始化为  
1 0  
0 0  
此外，要特别注意常数问题，矩阵乘法不能用数组循环去求，我们改成4个变量然后手动去求，具体看代码  
```cpp
#include <bits/stdc++.h>
#define rg register
#define inl inline
typedef long long ll;
typedef unsigned long long ull;
const int N = 4e4 + 10, mod = 1e9 + 7;
using namespace std;
namespace fast_IO {
    ll read()
    {
        rg ll num = 0;
        rg char ch;
        rg bool flag = false;
        while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r');
        if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48;
        while ((ch = getchar()) != ' '&&ch != '\n'&&ch != '\r'&&~ch)
            num = (num << 1) + (num << 3) + (ch ^ 48);
        if (flag)return -num; return num;
    }
    void write(rg long long x) { if (x < 0)putchar('-'), x = -x; if (x >= 10)write(x / 10); putchar(x % 10 ^ 48); }
};
namespace Mker
{
    unsigned long long SA, SB, SC;
    void init() { scanf("%llu%llu%llu", &SA, &SB, &SC); }
    unsigned long long rand()
    {
        SA ^= SA << 32, SA ^= SA >> 13, SA ^= SA << 1;
        unsigned long long t = SA;
        SA = SB, SB = SC, SC ^= t ^ SA; return SC;
    }
}
struct Matrix {
    ll a, b, c, d;
    Matrix() { a = b = c = d = 0; }
    Matrix operator *(rg Matrix &s)
    {
        Matrix tmp;
        tmp.a = (a * s.a + b * s.c) % mod, tmp.b = (a * s.b + b * s.d) % mod;
        tmp.c = (c * s.a + d * s.c) % mod, tmp.d = (c * s.b + d * s.d) % mod;
        return tmp;
    }
}base, mi1[N], mi2[N];

int main()
{
    base.a = 233; base.b = 666; base.c = 1;
    mi1[1] = base; int len = sqrt(1e9 + 6);
    for (int i = 2; i != len; ++i)mi1[i] = mi1[i - 1] * base;
    mi2[1] = mi1[len - 1] * base; mi1[0].a = mi1[0].d = 1;
    mi2[0].a = mi2[0].d = 1;
    for (int i = 2; i <= len + 1; ++i)mi2[i] = mi2[i - 1] * mi2[1];
    rg ll T = fast_IO::read(), a = 0; Mker::init();
    while (T--)
    {
        Matrix ans; ans.a = 1;
        int n = Mker::rand() % 1000000006;
        if (n <= 1) { a ^= n; continue; }
        else ans = ans * mi2[(n - 1) / len] * mi1[(n - 1) % len], a ^= ans.a;
    }
    fast_IO::write(a);
    return 0;
}

```

---

## 作者：betterer (赞：2)

### 特征方程法求通项公式

$a_n=pa_{n-1}+qa_{n-2}$的特征方程$x^2=px+q$

- 若有两个不同根$\alpha,\beta$则通项公式为$a_n=A\alpha^n+B\beta^n$
- 若有两个相同根$\alpha$则通项公式为$a_n=(An+B)\alpha^n$
- $A,B$由$a_0,a_1$确定

$\therefore a_n=\frac{(\frac{233+\sqrt{56953}}{2})^n-(\frac{233-\sqrt{56953}}{2})^n}{\sqrt{56953}}$

### 实数运算求$a_n$

- 令$c=56953$可知该通项公式分子中的数在运算时保持$a+b\sqrt c$
- $(a_1+b_1\sqrt c)\times(a_2+b_2\sqrt c)=(a_1a_2+b_1b_2c)+(a_1b_2+a_2b_1)\sqrt c$

本题分子两部分运算结果的$a$相反$\therefore$分子运算结果的$b$即为所求

又本题分子两部分运算结果的$b$相等，$\therefore$算一个$\times2$就行

- 实数运算使根号的处理**一般化**

### 逆元避免除法

- 若$a\times x\equiv 1(mod$ $p)$记$x=a^{-1}$称为$a$的逆元$(p$为质数$)$
- $1^{-1}=1$

取模除法等价乘逆元取模，本题$div2=(mod>>1)+1=500000004$，且$233div2\equiv116+div2$

#### 位运算比除法快那么一丢丢

```#include<bits/stdc++.h>
#define LL unsigned long long
using namespace std;
const int mod=1000000007,div2=(mod>>1)+1,c=56953;
int t,n,ans;

namespace Mker
{
    unsigned long long SA,SB,SC;
    void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
    unsigned long long rand()
    {
        SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
        unsigned long long t=SA;
        SA=SB,SB=SC,SC^=t^SA;return SC;
    }
}

struct Re{
    LL a,b;
    Re(){a=1;b=0;}
    Re operator*(Re x){
        Re r;
        r.a=(a*x.a+b*x.b%mod*c)%mod;
        r.b=(a*x.b+b*x.a)%mod;
        return r;
    }
}e,e2,e3,u[32769],v[30520];

int main(){
    e.a=116+div2;
    e.b=div2;
    for(int i=1;i<=32768;++i)
    u[i]=u[i-1]*e;
    e2=u[32768];
    for(int i=1;i<30520;++i)
    v[i]=v[i-1]*e2;
    cin>>t;
    Mker::init();
    while(t--)
    {
        n=Mker::rand()%(mod-1);
        ans^=((u[n&32767]*v[n>>15]).b<<1)%mod;
    }
    cout<<ans;
}
```

---

## 作者：SSerxhs (赞：1)

题目给出的递推式明显要矩阵加速，不会的转模板

但常规矩阵加速效率logn，此题t非常大立刻就超时

考虑预处理i<=k的所有矩阵a[i]以及k*i的所有矩阵b[i]，则第n项可以直接由a[n%k]*b[n/k]求得，复杂度O(t+k+n/k)，当k取sqrt(n)时复杂度最优，为O(t+sqrt(n))

然而此题n范围极大，sqrt(n)一个点都过不去。斐波那契数列对p取模时有不超过4p的循环节(证明见4000)，可以猜想，对于此题也有O(p)的循环节

暴力递推可以发现循环节长度为(p-1)，故直接对(p-1)取模，复杂度O(t+sqrt(p))，可以通过此题。

码风极丑，矩乘循环展开了

```cpp
#include <stdio.h>
#include <string.h>
typedef long long ll;
const int p=1e9+7,N=4e4;
int t,i,ans,n,a,b,c,d;
int ycl1[N+2][2][2],ycl2[N+2][2][2];
namespace Mker
{
    unsigned long long SA,SB,SC;
    void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
    unsigned long long rand()
    {
        SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
        unsigned long long t=SA;
        SA=SB,SB=SC,SC^=t^SA;return SC%(p-1);
    }
}
int main()
{
    scanf("%d",&t);
    Mker::init();
    ycl1[1][0][0]=233;ycl1[1][1][0]=666;ycl1[1][0][1]=1;
    for (i=2;i<=N;i++)
    {
        ycl1[i][0][0]=((ll)ycl1[i-1][0][0]*ycl1[1][0][0]+(ll)ycl1[i-1][0][1]*ycl1[1][1][0])%p;
        ycl1[i][1][0]=((ll)ycl1[i-1][1][0]*ycl1[1][0][0]+(ll)ycl1[i-1][1][1]*ycl1[1][1][0])%p;
        ycl1[i][0][1]=((ll)ycl1[i-1][0][0]*ycl1[1][0][1]+(ll)ycl1[i-1][0][1]*ycl1[1][1][1])%p;
        ycl1[i][1][1]=((ll)ycl1[i-1][1][0]*ycl1[1][0][1]+(ll)ycl1[i-1][1][1]*ycl1[1][1][1])%p;
    }
    ycl2[1][0][0]=ycl1[N][0][0];
    ycl2[1][1][0]=ycl1[N][1][0];
    ycl2[1][0][1]=ycl1[N][0][1];
    ycl2[1][1][1]=ycl1[N][1][1];
    for (i=2;i<=N;i++)
    {
        ycl2[i][0][0]=((ll)ycl2[i-1][0][0]*ycl2[1][0][0]+(ll)ycl2[i-1][0][1]*ycl2[1][1][0])%p;
        ycl2[i][1][0]=((ll)ycl2[i-1][1][0]*ycl2[1][0][0]+(ll)ycl2[i-1][1][1]*ycl2[1][1][0])%p;
        ycl2[i][0][1]=((ll)ycl2[i-1][0][0]*ycl2[1][0][1]+(ll)ycl2[i-1][0][1]*ycl2[1][1][1])%p;
        ycl2[i][1][1]=((ll)ycl2[i-1][1][0]*ycl2[1][0][1]+(ll)ycl2[i-1][1][1]*ycl2[1][1][1])%p;
    }
    ycl1[0][0][0]=ycl1[0][1][1]=1;
    ycl2[0][0][0]=ycl2[0][1][1]=1;
    while (t--)
    {
        n=Mker::rand();
        if (n==0) continue;
        a=ycl1[n%N][0][0];b=ycl1[n%N][0][1];
        ans^=((ll)a*ycl2[n/N][0][1]+(ll)b*ycl2[n/N][1][1])%p;
    }
    printf("%d",ans);
}
```

---

## 作者：Nemlit (赞：0)

太菜了，不会生成函数，于是用特征方程来写的这道题

首先我们知道，形如$a_n=A*a_{n-1}+B*a_{n-2}$的特征方程为$x^2=A*x+B$

于是此题的递推式就是：$x^2=233x+666$，即：$x^2-233x-666=0$

用求根公式解得：$x_1=\dfrac{233+\sqrt{56953}}{2}, x_2=\dfrac{233-\sqrt{56953}}{2}$

由于$188305837≡\sqrt{56953}(mod\ 1e9+7)$

所以变成：$x_1 = $94153035$‬$, $x_2=905847205$

跟据特征方程的结论：$a_n=αx_1^n+β*x_2^n$

因为$a_0=0, a_1=1$，所以有：

$α+β=0$

$94153035*α+905847205*β=1$

解得：$α=\dfrac{1}{188305837}=233230706, β=-\dfrac{1}{188305837}=-233230706$

所以$a_n=233230706*94153035^n-233230706*905847205^n$

由于询问较多，所以我们要用$O(1)$光速幂求解
## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define maxn 300
const int mod = 1000000007;
const int x1 = 94153035, x2 = 905847205, a = 233230706;
int n, m, ans;
int f1[65540], f2[65540], f3[65540], f4[65540];
int g1[65540], g2[65540], g3[65540], g4[65540];
unsigned long long SA,SB,SC;
void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
unsigned long long Rand() {
    SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
    unsigned long long t=SA;
    SA=SB,SB=SC,SC^=t^SA;return SC;
}
il int mul(int a, int b) {
    return 1ll * a * b % mod;
}
il int qpow1(int x) {
    return mul(f1[x & 65535], f2[x >> 16]);
}
il int qpow2(int x) {
    return mul(g1[x & 65535], g2[x >> 16]);
}
int main() {
    f1[0] = g1[0] = 1;
    rep(i, 1, 65536) f1[i] = mul(f1[i - 1], x1), g1[i] = mul(g1[i - 1], x2);
	f2[0] = g2[0] = 1, f2[1] = f1[65536], g2[1] = g1[65536];
	rep(i, 2, 65536) f2[i] = mul(f2[i - 1], f2[1]), g2[i] = mul(g2[i - 1], g2[1]);
	int T = read(); init();
    while(T --) {
        n = (Rand()) % (mod - 1);
        ans ^= 1ll * a * (qpow1(n) - qpow2(n) + mod) % mod;
    }
    printf("%d", ans);
	return 0;
}
```

---

## 作者：xuyixuan (赞：0)

## 题意简述

已知 $a_n=233a_{n-1}+666a_{n-2},a_0=0,a_1=1$

有 $5\times 10^7$ 组询问，求 $a_n$ 模 $10^9+7$ 的值

## 题解思路

必须要 $O(1)$ 实现

设 $a_n=c\cdot q^n$，

则 $ c \cdot q^n=233c \cdot q^{n-1}+666c \cdot q^{n-2}$

化简后得 $q^2-233q-666=0$，解得 $q_1= \frac{233+\sqrt{56953}}{2}$，$q_2= \frac{233-\sqrt{56953}}{2}$

然后可以发现 $\sqrt{56953}$ 在模 $10^9+7$ 意义下恰好等于 $188305837$

在模意义下 $q_1=94153035$，$q_2=905847205$

所以 $a_n=c_1\cdot q_1^n-c_2\cdot q_2^n$，将 $a_0=0,a_1=1$带入，

即 $\begin{cases} c_1-c_2=0 \\ c_1\cdot q_1-c_2\cdot q_2=1\end{cases}$ 解得 $c_1=c_2=\frac{1}{q1-q2}$ 在模意义下即 $233230706$ 

所以 $a_n=233230706\times(94153035^n-905847205^n)$

此时用快速幂仍然会T，由于底数固定，所以可以分块。

取$S=\lceil\sqrt{n_{max}}\rceil$，这里为了方便取 $S=2^{16}=65536$

对于每一个$n$，都可以表示为$k\cdot S+r,k∈[0,S),r∈[0,S)$

所以分别预处理出 $f_1[k]=q_1^k,k\in[0,S)$ 和 $f_2[k]=q_1^{k\cdot S},k\in[0,S)$,则$q^n=f_1[n/S]*f2[n\%S]=f_1[n>>16]*f1[n\&S]$。

$q_2$同理，这样就可以$O(1)$求出答案

## 代码

```c++
#include <cstdio>
#define ll long long
#define ull unsigned ll
const int mod=1e9+7,S=65535,c1=94153035,c2=905847205,c3=233230706;
int T,ans;
ll f11[S+5]={1},f12[S+5]={1},f21[S+5]={1},f22[S+5]={1};
ull SA,SB,SC,t;
inline ull rnd() {
	SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
	t=SA,SA=SB,SB=SC; return SC^=t^SA;
}
int main() {
	scanf("%d%llu%llu%llu",&T,&SA,&SB,&SC);
	for (int i=1;i<=S;++i) f11[i]=f11[i-1]*c1%mod,f21[i]=f21[i-1]*c2%mod;
	const int x1=f11[S]*c1%mod,x2=f21[S]*c2%mod;
	for (int i=1;i<=S;++i) f12[i]=f12[i-1]*x1%mod,f22[i]=f22[i-1]*x2%mod;
	for (;T;--T) {
		t=rnd()%(mod-1); const int t1=t&S,t2=t>>16;
		ans^=((f11[t1]*f12[t2]-f21[t1]*f22[t2])%mod+mod)*c3%mod;
	}
	printf("%d\n",ans);
}
```



---

## 作者：ddwqwq (赞：0)

首先是拿生成函数推公式，大家可以看出题人的题解。但接下来还有一步非常重要：模意义下开方。这题的模数很小，可以暴力出来，但对于大模数，就需要一些技巧了。  
假设我们要对模素数$P$意义下的$a$开方。首先使用二次剩余的欧拉准则判断同余方程$$x^2\equiv a(\text{mod}\; P)$$是否有解。  
       
二次剩余的欧拉准则：$x^2\equiv a(\text{mod}\; P)$有解的充分必要条件是$$a^{\frac{P-1}{2}}\equiv 1(\text{mod}\; P)$$证明：  
先证必要性。设$x^2\equiv a(\text{mod}\; P)$的一个解为$b$，则$$a^{\frac{P-1}{2}}\equiv(b^2)^{\frac{P-1}{2}}\equiv b^{P-1}\equiv  1(\text{mod}\; P)$$最后一步用到了费马小定理。  
再证充分性。通过把$$1,2,\cdots ,P-1 $$这$P-1$个数$\text{mod}P$化简到$$-\frac{P-1}{2},-\frac{P-1}{2}+1,\cdots,-1,0,1,\cdots,\frac{P-1}{2}-1,\frac{P-1}{2}$$，再考察每个数字的平方，我们发现$P$的既约剩余系中有$\frac{P-1}{2}$个二次剩余。又因为方程$$x^{\frac{P-1}{2}}\equiv 1(\text{mod}\; P)$$最多有$\frac{P-1}{2}$个解~~（你知道这是为什么吗？）~~，所以每个解和$P$的二次剩余一一对应。所以$$a^{\frac{P-1}{2}}\equiv 1(\text{mod}\; P)$$仅仅对于$P$的每个二次剩余成立。这就证明了充分性。
  
通过欧拉准则，我们发现本题中需要开方的数刚好是$P$的二次剩余，也就是说，它可以在模$P$意义下开方。事实上，对于某些特殊的素数，我们有办法实现快速开方。 
  
对于模$4$同余$3$的素数的快速开方技巧：若$x^2\equiv a(\text{mod}P)$有解且$P\equiv 3(\text{mod}4)$，则$a^{\frac{P+1}{4}}$是$x$的一个解。  
证明：  
$$(a^{\frac{P+1}{4}})^2\equiv a^{\frac{P-1}{2}+1}(\text{mod}P)$$  
因为$$a^{\frac{P-1}{2}}\equiv 1(\text{mod}\; P)$$所以$$(a^{\frac{P+1}{4}})^2\equiv a^{\frac{P-1}{2}+1}\equiv a(\text{mod}P)$$，所以$a^{\frac{P+1}{4}}$是$x$的一个解。  
   
非常巧地，我们发现$10^9+7\equiv3(\text{mod}4)$。这样一来，我们可以用上面的技巧轻松得到想要的结果。然后就是照着公式计算了。  
~~所以说可以把模数弄得更大一点~~

---


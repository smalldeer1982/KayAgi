# 子异和

## 题目描述

小L和小K正在激烈地讨论着。

（你不用知道谁说的哪句话……）

“你知道非空子集吗？”

“当然知道啊！比如说集合$\{1,2,3\}$，它的所有非空子集就是$\{1\},\{2\},\{3\},\{1,2\},\{2,3\},\{1,3\},\{1,2,3\}$。”

“那你知道每个非空子集里的数的亦或和是多少吗？”

“也知道啊，不就是$1,2,3,1⊕2=3,2⊕3=1,1⊕3=2,1⊕2⊕3=0$吗。”

“那你知道它们的和是多少吗？我们把它叫做子异和。”

“子异和……这个名字好奇怪啊，不过我知道，是$1+2+3+3+1+2+0=12$。”

“那我问你，$\{a_1,a_2,...,a_n\}$的子异和是多少？”

“慢慢暴力算呗！”

“如果$n\le 200000$呢？”

“……”

“如果把问题放在一颗树上呢？”

“……那你会不会做啊？”

“当然……不会做……”

现在，只有你能帮助小L和小K了，请你帮忙解决这个问题。

**为了更清晰的表达题意，我们再做一次解释。**

有一个$n$个节点的树，总共有$m$次操作。这些操作按照操作顺序输入。每次操作可能是询问或修改。

每次询问操作会给出两个节点编号$a,b$。根据常识，$a,b$在树上有唯一路径。我们设这条路径经过的所有点的点权集合为$S$。你要输出$S$的子异和。答案$mod\space(10^9+7)$。

每次修改操作会给出两个节点编号$a,b$与一个整数值$c$。你要将节点$a$到节点$b$的唯一路径上的所有点的点权分别异或$c$。

**这里的集合指可重集合**

## 说明/提示

样例解释：

第一次询问，$1$到$1$的路径经过$1$号节点，点权组成的集合为$\{1\}$，子异和为$1$。

两次修改后，$1$号点点权为$0$，$3$号点点权为$1$。

第二次询问，$1$到$3$的路径经过的点权集合为$\{0,1\}$，子异和为$0+1+1=2$。

本题共有$10$个测试点，每个测试点$10$分，总分为$100$分。

| 测试点编号 | $n$的范围 | $m$的范围 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1-2$ | $1\le n\le 1000$ | $1\le m\le 1000$ | 无 |
| $3-5$ | $1\le n\le 200000$ | $1\le m\le 200000$ | 每条边连接的两个节点编号均相邻 |
| $6-10$ | $1\le n\le 200000$ | $1\le m\le 200000$ | 无 |

对于$100\%$的数据：

输入的数均为不大于$10^9+7$的非负整数，$1\le a,b\le n$。

## 样例 #1

### 输入

```
3 4
1 2
1 3
1 1 1
1 1 1
2 1 3 1
2 3 3 1
1 1 3```

### 输出

```
1
2```

# 题解

## 作者：Ebola (赞：8)

考虑对每一个二进制位分别计算贡献。设$cnt_k$表示异或和的$2^k$位为$1$的子集数量，那么令$n$表示全集大小，$m_k$表示$2^k$位为$1$的数有几个。显然符合条件的子集应恰好包含奇数个$2^k$位为$1$的数，其它随意。于是有：

$$cnt_k=2^{n-m_k}\times\sum_{i=1}^{\left\lfloor\frac{m_k}{2}\right\rfloor}\binom{m_k}{2i-1}=2^{n-m_k}\times2^{m_k-1}=2^{n-1}$$

特别地，当$m_k=0$时，$cnt_k=0$

感觉似乎简洁的有点出乎意料？一个二进制位是否有贡献，只和$m$是否为$0$有关！

于是，一个集合的子异和就是：$2^{n-1}\times\sum\limits_{i=0}^k[m_i>0]2^i$。不难看出这个求和运算实际上是在计算所有数的二进制或，所以该式可写作：$2^{n-1}\times orsum$

好了，现在询问已经解决了，只要求出路径上点的数量以及点权或就行。现在考虑修改

如果我们知道了一个集合的与、或，现在这个集合所有数要异或$c$。那么，令$\cup_k$、$\cap_k$、$c_k$分别表示或的$2^k$位、与的$2^k$位、$c$的$2^k$位，则不难得出：

$$\cup_{k[c_k==1]}'=\begin{cases}1&\cap_k==0\\0&\cap_k==1\end{cases},\qquad\cap_{k[c_k==1]}'=\begin{cases}1&\cup_k==0\\0&\cup_k==1\end{cases}$$

进而得到：

$$\cup'=(\cup\;\&\;\sim c)\;|\;(c\;\&\;\sim\cap)$$

$$\cap'=(\cap\;\&\;\sim c)\;|\;(c\;\&\;\sim\cup)$$

所以说，我们需要维护路径与、路径或。树剖套线段树即可

```cpp
#include<bits/stdc++.h>
using namespace std;

const int ha=1e9+7;
const int N=200010;
unsigned sand[N<<2],sor[N<<2],lazy[N<<2];
int dfn[N],idx[N],dfc=0;
int fa[N],hson[N],top[N];
int dep[N],siz[N];
vector<int> g[N];
int n,m,val[N],pw2[N];

void update(int o,unsigned c)
{
    unsigned a=sor[o],b=sand[o];
    sor[o]=(a&~c)|(c&~b);
    sand[o]=(b&~c)|(c&~a);
    lazy[o]^=c;
}

void pushdown(int o)
{
    if(!lazy[o]) return;
    update(o<<1,lazy[o]);
    update(o<<1|1,lazy[o]);
    lazy[o]=0;
}

void build(int o,int l,int r)
{
    if(l==r){sand[o]=sor[o]=val[idx[l]];return;}
    int mid=(l+r)/2;
    build(o<<1,l,mid);
    build(o<<1|1,mid+1,r);
    sand[o]=sand[o<<1]&sand[o<<1|1];
    sor[o]=sor[o<<1]|sor[o<<1|1];
}

void cxor(int o,int l,int r,int nl,int nr,unsigned c)
{
    if(l>=nl&&r<=nr){update(o,c);return;}
    int mid=(l+r)/2;pushdown(o);
    if(nl<=mid) cxor(o<<1,l,mid,nl,nr,c);
    if(nr>mid) cxor(o<<1|1,mid+1,r,nl,nr,c);
    sand[o]=sand[o<<1]&sand[o<<1|1];
    sor[o]=sor[o<<1]|sor[o<<1|1];
}

unsigned qor(int o,int l,int r,int nl,int nr)
{
    if(l>=nl&&r<=nr) return sor[o];
    int mid=(l+r)/2;unsigned res=0;pushdown(o);
    if(nl<=mid) res|=qor(o<<1,l,mid,nl,nr);
    if(nr>mid) res|=qor(o<<1|1,mid+1,r,nl,nr);
    return res;
}

void dfs1(int u)
{
    siz[u]=1;
    for(int v : g[u])
    {
        if(v==fa[u]) continue;
        dep[v]=dep[u]+1;
        fa[v]=u;dfs1(v);
        siz[u]+=siz[v];
        if(siz[v]>siz[hson[u]]) hson[u]=v;
    }
}

void dfs2(int u,int tp)
{
    top[u]=tp;
    idx[dfn[u]=++dfc]=u;
    if(hson[u]) dfs2(hson[u],tp);
    for(int v : g[u])
        if(v!=fa[u]&&v!=hson[u])
            dfs2(v,v);
}

void pathxor(int u,int v,unsigned c)
{
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        cxor(1,1,n,dfn[top[u]],dfn[u],c);
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    cxor(1,1,n,dfn[u],dfn[v],c);
}

int query(int u,int v)
{
    unsigned orsum=0,cnt=0;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        orsum|=qor(1,1,n,dfn[top[u]],dfn[u]);
        cnt+=dfn[u]-dfn[top[u]]+1;
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    orsum|=qor(1,1,n,dfn[u],dfn[v]);
    cnt+=dfn[v]-dfn[u]+1;
    return 1ll*orsum*pw2[cnt-1]%ha;
}

int main()
{
    scanf("%d%d",&n,&m);
    pw2[0]=1;
    for(int i=1;i<=n;i++)
        pw2[i]=(pw2[i-1]<<1)%ha;;
    for(int i=1,u,v;i<n;i++)
    {
        scanf("%d%d",&u,&v);
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    for(int i=1;i<=n;i++)
        scanf("%d",val+i);
    dfs1(1);dfs2(1,1);
    build(1,1,n);
    int opt,u,v;unsigned c;
    while(m--)
    {
        scanf("%d%d%u",&opt,&u,&v);
        if(opt==1) printf("%d\n",query(u,v));
        else scanf("%u",&c),pathxor(u,v,c);
    }
    return 0;
}
```

---

## 作者：1saunoya (赞：5)

[看这个](https://www.luogu.com.cn/blog/Isaunoya/solution-p5390)

然后就会做了。
树链剖分线段树或，然后qpow一下就做完了。

---

## 作者：normalpcer (赞：3)

## 题意简述
对一个**可重**集合 $S$ 的所有子集 $V$ 取各自的异或和 $s_V$，称它们的加和为集合 $S$ 的子异和。

给定一棵有点权的树。

每次查询操作给定两个节点，求它们之间路径上所有点组成的集合的子异和。

每次修改操作给定两个节点和一个整数 $c$，将路径上所有点的点权异或上 $c$。

## 分析
首先考虑连续区间上的查询操作。这里可以参考 [P5390](https://www.luogu.com.cn/problem/P5390)。

由于涉及到按位异或，自然想到拆位。

对于每一个子集，它的异或和仅取决于 $1$ 的数量是奇数还是偶数。感性地理解，一个子集中 $1$ 的数量为奇数的概率为 $\frac{1}{2}$，因为每一个 $1$ 取或不取都会导致奇偶性改变。特别地，全 $0$ 集合不可能是奇数。而一个长度为 $N$ 的集合一共有 $2^N$ 个子集，如果第 $i$ 位上不全为 $0$，就可以对答案产生 $2^i \times 2^{N-1}$ 的贡献。设这个集合内所有数的按位或为 $k$，可知子异和为 $k \times 2^{N-1}$。

于是，我们只需要维护这个区间内所有数的按位或。

接下来考虑区间异或的修改操作。仍然拆位考虑，每一个区间只可能是不变或者翻转。可以用 $a_i$ 和 $b_i$ 分别表示这个区间上的第 $i$ 位是否为全 $1$ 或全 $0$。$a$ 和 $b$ 也可以压到一个整数中维护，通过位运算提高效率。

合并两个子区间：考虑实际意义，将 $a$ 和 $b$ 分别取按位与即可。

对一个区间进行异或 $x$：新的全 $1$ 位包含没有被翻转的全 $1$ 位和翻转过的全 $0$ 位，反之同理。
```cpp
new_a = a & ~x | b & x
new_b = b & ~x | a & x
```

于是可以通过线段树维护上述的 $a$ 和 $b$ 来实现查询区间或，以及区间异或。

接下来，通过树链剖分维护路径上的按位或，和路径长度计算出答案即可。

## 代码
```cpp
/**
 * @link https://www.luogu.com.cn/problem/P5127
 */
#include <bits/stdc++.h>
bool DEBUG_MODE=false;
#define debug if(DEBUG_MODE)
template <typename T> inline auto chkMax(T& base, const T& cmp) { return (base = std::max(base, cmp)); }
template <typename T> inline auto chkMin(T& base, const T& cmp) { return (base = std::min(base, cmp)); }
#define never if constexpr(0)
const int inf = 0x3f3f3f3f;  const long long infLL = 0x3f3f3f3f3f3f3f3fLL; using ll = long long; using ull = unsigned long long;
const char endl = '\n';

/**
 * 考虑一个连续段上的情况：
 * 按位考虑，每一位上有若干个 1，当取了奇数个 1 的时候会对这一位产生贡献。
 * 1 的个数为奇偶的情况均分，所以为 2**(N-1) 种情况产生贡献。
 * 特别地，如果某一位都是 0，一定不会有贡献。
 * 只需所有数取或，最后乘以 2**(N-1)。
 */
namespace Solution_1245959757901944 {
    const int mod = 1'000'000'007;
    constexpr auto qpow(ll a, ll b, const int mod) -> ll {
        auto res = 1LL;
        for (; b; b >>= 1, a = a * a % mod)  if (b & 1) res = res * a % mod;
        return res;
    }
    /**
     * 考虑使用线段树维护区间或。
     * 要求支持区间异或操作。
     * 仍然按位考虑，区间异或即为若干位上反转。
     * 某一个位上可能是全 1、全 0 或者二者兼有，仅全 0 时 Or 值为 0
     * 考虑用两个整数表示，a 表示某一位上是否全是 1，b 表示全是 0。
     * 不全为 0 即为区间或。
     * 合并：两个区间上的 a 和 b 求按位与。
     * 异或：一些位上的全 1 会变成全 0，即 a' 包含翻转的 b 和未翻转的 a
     * a' = a & ~x | b & x
     * b' = b & ~x | a & x
     */
    class SegTree {
        struct Node {
            int begin = 0, end = 0;
            unsigned int all_one = 0U, all_zero = ~0U, xor_tag = 0U;

            auto size() const -> int { return end - begin; }
            auto empty() const -> bool { return size() == 0; }
            // 合并两个区间
            auto operator| (Node other) const -> Node {
                Node res{begin, other.end};
                res.all_one = all_one & other.all_one;  // 只有两侧均全为 1，大区间才全为 1
                res.all_zero = all_zero & other.all_zero;
                return res;
            }
            auto operator|= (Node other) -> Node & {
                return *this = *this | other;
            }
            // 对区间取异或
            auto operator^ (int x) const -> Node {
                Node res{begin, end};
                res.all_one = (all_one & ~x) | (all_zero & x);
                res.all_zero = (all_zero & ~x) | (all_one & x);
                res.xor_tag = xor_tag ^ x;
                return res;
            }
            auto operator^= (int x) -> Node & {
                return *this = *this ^ x;
            }
        };
        std::vector<Node> tr;

        static constexpr auto lson(int p) -> int { return p << 1; }
        static constexpr auto rson(int p) -> int { return p << 1 | 1; }
        auto pushUp(int p) -> void {
            tr[p] = tr[lson(p)] | tr[rson(p)];
        }
        auto pushDown(int p) -> void {
            if (tr[p].xor_tag != 0U) {
                for (auto x: {lson(p), rson(p)}) {
                    tr[x] ^= tr[p].xor_tag;
                }
                tr[p].xor_tag = 0U;
            }
        }
        auto build(int begin, int end, int p = 1) -> void {
            tr[p].begin = begin, tr[p].end = end;
            if (begin + 1 == end)  return;
            auto mid = std::midpoint(begin, end);
            build(begin, mid, lson(p)), build(mid, end, rson(p));
            pushUp(p);
        }
    public:
        SegTree(int N): tr(N << 2) {
            build(0, N, 1);
        }
        auto queryOrRange(int begin, int end, int p = 1) -> unsigned int {
            if (tr[p].begin >= begin and tr[p].end <= end) {
                return ~tr[p].all_zero;
            }
            auto res = 0U;
            pushDown(p);
            if (tr[lson(p)].end > begin)  res |= queryOrRange(begin, end, lson(p));
            if (tr[rson(p)].begin < end)  res |= queryOrRange(begin, end, rson(p));
            return res;
        }
        auto xorRange(int begin, int end, unsigned int val, int p = 1) -> void {
            if (tr[p].begin >= begin and tr[p].end <= end) {
                tr[p] ^= val;
                return;
            }
            pushDown(p);
            if (tr[lson(p)].end > begin)  xorRange(begin, end, val, lson(p));
            if (tr[rson(p)].begin < end)  xorRange(begin, end, val, rson(p));
            pushUp(p);
        }
    };
    class Tree {
        int N;
        std::vector<std::vector<int>> graph;
        std::vector<int> depth, size, fa, son, top, order, index;
        SegTree sgt;

        auto dfs1(int p, int prev) -> void {
            size[p] = 1, fa[p] = prev;
            depth[p] = depth[prev] + 1;
            for (auto x: graph.at(p))  if (x != prev) {
                dfs1(x, p);
                size[p] += size[x];
                if (size[son[p]] < size[x]) {
                    son[p] = x;
                }
            }
        }
        auto dfs2(int p, int tp) -> void {
            top[p] = tp, index[p] = order.size(), order.push_back(p);
            if (son[p] != 0)  dfs2(son[p], tp);
            for (auto x: graph.at(p)) {
                if (x != fa[p] and x != son[p]) {
                    dfs2(x, x);
                }
            }
        }
    public:
        Tree(int N): N(N), graph(N+1), depth(N+1), size(N+1), fa(N+1), son(N+1), top(N+1), index(N+1), sgt(N) {}

        auto queryPath(int x, int y) -> int {
            unsigned int or_sum = 0U;
            int len = 0;
            while (top[x] != top[y]) {
                if (depth[top[x]] < depth[top[y]]) {
                    std::swap(x, y);
                }
                or_sum |= sgt.queryOrRange(index[top[x]], index[x] + 1);
                len += index[x] + 1 - index[top[x]];
                x = fa[top[x]];
            }
            if (depth[x] < depth[y]) {
                std::swap(x, y);
            }
            or_sum |= sgt.queryOrRange(index[y], index[x] + 1);
            len += index[x] + 1 - index[y];
            auto ans = static_cast<ll>(or_sum) * qpow(2, len - 1, mod) % mod;
            return ans;
        }
        auto xorPath(int x, int y, unsigned int val) -> void {
            while (top[x] != top[y]) {
                if (depth[top[x]] < depth[top[y]]) {
                    std::swap(x, y);
                }
                sgt.xorRange(index[top[x]], index[x] + 1, val);
                x = fa[top[x]];
            }
            if (depth[x] < depth[y]) {
                std::swap(x, y);
            }
            sgt.xorRange(index[y], index[x] + 1, val);
        }

        friend auto operator>> (std::istream &st, Tree &tr) -> std::istream & {
            auto N = tr.N;
            for (auto _ = 0; _ < N - 1; _++) {
                int x, y;  st >> x >> y;
                tr.graph.at(x).push_back(y);
                tr.graph.at(y).push_back(x);
            }
            tr.dfs1(1, 0);
            tr.dfs2(1, 1);
            for (auto i = 1; i < N + 1; i++) {
                int x;  st >> x;
                tr.sgt.xorRange(tr.index[i], tr.index[i]+1, x);
            }
            return st;
        }
    };
    void solve() { 
        std::ios::sync_with_stdio(false);
        std::cin.tie(nullptr), std::cout.tie(nullptr);

        int N, M;  std::cin >> N >> M;
        Tree tree{N};  std::cin >> tree;
        for (auto _ = 0; _ < M; _++) {
            int op, x, y;  std::cin >> op >> x >> y;
            if (op == 1) {
                std::cout << tree.queryPath(x, y) << endl;
            } else {
                int z;  std::cin >> z;
                tree.xorPath(x, y, z);
            }
        }
    }
}

int main(int argc, char const *argv[]) {
    DEBUG_MODE = (argc-1) and not strcmp("-d", argv[1]);
    Solution_1245959757901944::solve();
    return 0;
}
```

---

## 作者：Genius_Z (赞：2)

[题目描述](https://www.luogu.com.cn/problem/P5127)

[~~或许~~更好的阅读体验](http://geiz-revive.github.io/)

对于本题来说很容易想到拆位去维护，每一位的贡献为$[x_k>0]2^{n-1}$，其中$x_k$表示第$k$位的$1$的个数，$2^{n-1}$可以这样考虑：

    对于第k个元素可以选择选或不选（由异或的性质可知，奇数个为选，偶数个为不选，所以可以直接看做选或不选两种情况），其他元素任意，其他元素共有n-1个，当选第k个元素时，贡献为2的n-1次方，不选时没有贡献。

但是拆位复杂度过高，树剖是$\Theta(n\log^2n \log val)$的，$LCT$是$\Theta(n\log n\log val)$的~~和暴力一个分~~，我们要考虑更高效的做法。

设集合中有$n$个元素，则$\sum\limits_{k=1}^n[x_k>0]2^k$就是该集合的或和，那么该集合的子异和就是$2^{n-1}*orsum$

现在已经可以完成询问了，只需要预处理$2$的次幂再维护一下或和即可，接下来考虑修改。
我们不妨设要异或的数为$val$：

* $orsum'=orsum\And$~$val$  $|$ ~$andsum\And val$
* $andsum'=andsum\And$~$val$  $|$ ~$orsum\And val$

依然是通过拆位得到

原因：先考虑为什么要引入与和

* 设当前$val_k=1$，则当集合中所有数第$k$位都为$1$时，它们都异或上$val_k$才能使集合中所有数第$k$位都为$0$，当集合中有数的第$k$位为$0$时，则异或完以后还有数的第$k$位为$1$，即或和为$1$。

再考虑或和修改时另一种情况

* 当$val_k=0$时，一个数异或$0$还是它本身，所以直接是原来的值。

与和的维护与或和同理，最终我们做到了去掉$\log val$，达到了树剖$\Theta(n\log^2 n)$，$LCT\ \Theta(n\log n)$的优秀复杂度.(树剖怎么跑的这么快啊

$\Large Code :$
```cpp
struct node {
	int fa, child[2], w, orsum, andsum, tag, size;
	bool filp;
} t[200001];
const int p = 1e9 + 7;
//当异或上c时，假设c当前位为1，当前位与和为1则新的或和当前位为0，当前位或和为1则新的与和当前位为0
inl void upd(int x) {
	t[x].orsum = t[ls(x)].orsum | t[rs(x)].orsum | t[x].w;
	t[x].andsum = t[x].w, t[x].size = t[ls(x)].size + t[rs(x)].size + 1;
	if (ls(x)) t[x].andsum &= t[ls(x)].andsum;
	if (rs(x)) t[x].andsum &= t[rs(x)].andsum;
}
inl bool poi(int x) { return rs(fa(x)) == x; }
inl bool nroot(int x) { return ls(fa(x)) == x || rs(fa(x)) == x; }
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = son(x, fs ^ 1);
	if (nroot(f)) son(gf, gfs) = x;
	son(x, fs ^ 1) = f, son(f, fs) = s;
	if (s) fa(s) = f;
	fa(x) = gf, fa(f) = x, upd(f);
}
inl void reverse(int x) { swap(ls(x), rs(x)), t[x].filp ^= 1; }
inl void xxor(int x, int val) {
	re a = t[x].andsum, b = t[x].orsum;
	t[x].andsum = (a & ~val) | (~b & val);
	t[x].orsum = (~a & val) | (b & ~val);
	t[x].w ^= val, t[x].tag ^= val;
}
inl void pushdown(int x) {
	if (t[x].filp) {
		if (ls(x)) reverse(ls(x));
		if (rs(x)) reverse(rs(x));
		t[x].filp = 0;
	}
	if (t[x].tag) {
		if (ls(x)) xxor(ls(x), t[x].tag);
		if (rs(x)) xxor(rs(x), t[x].tag);
		t[x].tag = 0;
	}
}
inl void push(int x) {
	if (nroot(x)) push(fa(x));
	pushdown(x);
}
inl void splay(int x) {
	push(x);
	while (nroot(x)) {
		if (nroot(fa(x))) poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	upd(x);
}
inl void access(int x) {
	for (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i, upd(x);
}
inl void makeroot(int x) { access(x), splay(x), reverse(x); }
inl void split(int x, int y) { makeroot(y), access(x), splay(x); }
int pw[200001];
struct edge {
	int next, to;
} e[400001];
int head[200001], tot;
inl void add(int x, int y) {
	e[++tot] = edge{ head[x], y }, head[x] = tot;
	e[++tot] = edge{ head[y], x }, head[y] = tot;
}
inl void dfs(int x, int f) {
	for (re i = head[x]; i; i = e[i].next) {
		if (f != e[i].to) fa(e[i].to) = x, dfs(e[i].to, x);
	}
}
signed main() {
	re n = read<int>(), m = read<int>(), x, y, w, op;
	pw[0] = 1;
	for (re i = 1; i < n; i++) x = read<int>(), y = read<int>(), add(x, y);
	for (re i = 1; i <= n; i++) pw[i] = (pw[i - 1] << 1) % p, t[i].w = read<int>();
	dfs(1, 0);
	while (m--) {
		op = read<int>(), x = read<int>(), y = read<int>(), split(x, y);
		if (op == 1) {
			printf("%d\n", 1ll * t[x].orsum * pw[t[x].size - 1] % p);
		}
		else {
			w = read<int>(), xxor(x, w);
		}
	}
}
```

---

## 作者：caidzh (赞：1)

~~可能是我第一个没有代码的题解，因为我在写这句话的时候我还没有开始写代码。。。~~

先来扯点废话，对于这种异或的题，由于位运算各位之间不影响，所以都会把每一位拿出来单独考虑，所以我们就这样搞吧！

下面给一个结论感性证明：

我们设待求区间内第$i$位上有$k$个$1$，区间长度为$n$那么接下来我们来表示这一位的贡献：

$$(C_{k}^1\times 2^{n-k}+C_{k}^3\times 2^{n-k}+...)\times 2^{i-1}$$

由于取出偶数个数时这一位会变成$0$，没有贡献，所以上面取出偶数个数的情况被去掉了

稍微解释一下，我们考虑$C_{k}^3$的情况，它的意思等同于我们在这些第$i$位上有$1$的$k$个数中选出$3$个，然后因为剩下的数中第$i$位不含$1$的还可以进行选择，所以要乘上这个集合的子集数即$2^{n-k}$

里面合并一下同类项：$(C_{k}^1+C_{k}^3+...)\times 2^{n-k}\times 2^{i-1}$

前面看起来很熟悉有没有，我们拿一个杨辉三角手玩后就发现前面括号里的东西是$2^{k-1}$，化简一下：

$$2^{n-1}\times 2^{i-1}$$

发现前面的东西完全与$k$无关，对于所有的$i$，只要这一位上有$1\le k$，那么就会产生贡献！

实际上我们可以提出这个$2^{n-1}$，答案即为这个区间或起来再乘上$2^{n-1}$

所以树剖$+$线段树维护一个区间的或，然后修改的时候异或上去就好了

等下，修改的时候不能正常异或啊！我们看起来要想另外一个办法

考虑什么时候这个区间的或值会被异或修改，显然是在某二进制位上每一个值都是$1$的时候才会被修改，也就是这一位的与值为$1$，所以我们可以考虑同时维护这个区间的与值和或值，标记下传的时候注意一下顺序即可

其实还有一个比较方便好理解的做法就是维护这个区间中满足第$i$位为$1$的数有几个（可以脑补一下标记下传），但是这个做法因为要开的空间非常大，超过了空间限制，所以在这题没有用了~~其实动态开点线段树还是有救的~~

---


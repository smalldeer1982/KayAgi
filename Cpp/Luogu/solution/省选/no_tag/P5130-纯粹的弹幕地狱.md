# 纯粹的弹幕地狱

## 题目背景

除了丰富的迷宫系统之外,TODR的弹幕系统也富有趣味,不仅有多种华丽的特效,还有如咲夜的连发小刀,` The World `等特殊的攻击.  

不仅自机如此,敌人也有自己独特的攻击方式,比如下图就是绵月丰姬的"净化之风"攻击模式    

![](https://cdn.luogu.com.cn/upload/pic/42759.png)  


## 题目描述

通过了不可思议的迷宫后,你一路顺利地过关斩将来到了最后一层,却遭遇了前所未有的强敌——纯狐  

所幸的是,纯狐的弹幕不像绀珠转的强度一样大,房间的地形也比较特殊,可以为你所用.     

形式化的来说,每一回合你和纯狐的行动模式如下:  

1. 你可以将房间当成一张正方形网格图,左下角坐标为$(0,0)$,右上角的坐标为$(n,n)$,房间的有效位置为这$(n+1)*(n+1)$个格点,在一回合开始的时候,你会被随机传送到房间的任意一个有效位置  

2. 之后,纯狐会随机出现在房间中的某个有效位置,当然,她不会和你出现在同一位置  

3. 纯狐会发射纯粹的自机狙,也就是向你的方向发射一片弹幕,如果这片弹幕在飞行过程中经过了某个不是纯狐和自机所在的格点,则格点上的弹幕结界会被触发,将其传送到亚空间,如果这片弹幕顺利到达你所在的格点,那么你会受到一些伤害  

4. 由于时间狂暴,纯狐在第$t$回合的弹幕伤害可以计算为$at^{2}+bt+c$  

5. 回合结束,开始下一回合   

经过粗略估计,你认为和纯狐的弹幕战会持续$k$回合,那么,为了稳妥起见,你想要算出自机受到的总期望伤害  

答案可能很大也可能丢精度,所以对$19260817$取模就可以了

## 说明/提示

样例$1$解释:  

手画一个网格图,不难发现纯狐能打到你的情况有$12$种(先放自机再放纯狐即可得到)  

所以第一发弹幕的伤害为$1*1*1+2*1+1=4$,期望伤害为$4*\frac{12}{16}=3$  

只有一回合,所以答案为$3$       

数据范围:  

![](https://cdn.luogu.com.cn/upload/pic/42785.png)  



## 样例 #1

### 输入

```
1 1 2 1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
1 1 2 1 5```

### 输出

```
9630476```

# 题解

## 作者：Caro23333 (赞：6)

随手水~

首先要求出每一次子弹命中的概率。

设子弹起始位置为$(x_1,y_1)$，目标位置为$(x_2,y_2)$，不难发现子弹能造成伤害当且仅当$\gcd(|x_1-x_2|,|y_1-y_2|)=1$。

所以考虑枚举$i=|x_1-x_2|$和$j=|y_1-y_2|$。注意到$i<j$和$i>j$的情况实际对称，所以只考虑其中一边，最后乘$2$即可。为了规避$i=1$时特殊的情况，这里的$i$从$2$开始计算，而特殊情况会稍后计算。

确定了$i$和$j$之后，可以推出共有$4(n-i+1)(n-j+1)$种可能的位置（乘以$4$是因为目标可能在起始点的右上、右下、左下、左上四种方向），所以得到：

$$2\times 4\sum_{i=2}^n\sum_{j=0}^{i-1}(n-i+1)(n-j+1)[\gcd(i,j)=1]$$

这个式子肯定可以莫比乌斯反演无疑了；但是这里提供一种其他做法。

$$2\times 4\sum_{i=2}^n\sum_{j=0}^{i-1}(n-i+1)(n-j+1)[\gcd(i,j)=1]$$

$$=8\sum_{i=2}^n(n-i+1)\sum_{j=0}^{i-1}(n-j+1)[\gcd(i,j)=1]$$

$$=8\sum_{i=2}^n(n-i+1)\left[(n+1)\varphi(i)-\sum_{j=0}^{i-1}j[\gcd(i,j)=1]\right]$$

后面那个求和到底是什么东西？

注意到一个性质：对于$i>1$，$\gcd(j,i)=1 \Longleftrightarrow \gcd(i-j,i)=1$，也就是说所有$i$以内与$i$互质的自然数可以配对出现，每一对的和为$i$。考虑到一共有$\varphi(i)$个与$i$互质的数，也就是一共会出现$\frac{\varphi(i)}{2}$对，那么有：

$$\sum_{j=0}^{i-1}j[\gcd(i,j)=1]=\frac{i\varphi(i)}{2}$$

于是所求式为：

$$8\sum_{i=2}^n(n-i+1)\left[(n+1)\varphi(i)-\frac{i\varphi(i)}{2}\right]$$

直接$O(n)$求就可以了。

还剩下$i=1$的情况没有考虑。这时候有且仅有$j=0$和$j=1$是合法的，分别有$4n^2$和$4n(n+1)$种位置，直接加上即可。

上面的和是合法的方案数，除以总共的方案数就是概率，最后乘以$\frac{ak(k+1)(2k+1)}{6}+\frac{bk(k+1)}{2}+ck$就得到了总伤害的期望。

代码：

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#define mod 19260817

using namespace std;
const int MAXN = 10000005;
typedef long long ll;
ll n,k,a,b,c;
int prime[750005],tot = 0;
ll phi[MAXN];
bool vis[MAXN];
inline void make_table(int n)
{
    phi[1] = 1;
    for(int i = 2; i<=n; i++)
    {
        if(!vis[i])
        {
            prime[++tot] = i;
            phi[i] = i-1;
        }
        for(int j = 1; j<=tot&&i*prime[j]<=n; j++)
        {
            vis[i*prime[j]] = true;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]] = phi[i]*prime[j];
                break;
            }
            else phi[i*prime[j]] = phi[i]*(prime[j]-1);
        }
    }
} 
inline ll qpow(ll a, ll b)
{
    ll res = 1;
    while(b)
    {
        if(b&1) res = res*a%mod;
        a = a*a%mod;
        b >>= 1;
    }
    return res;
}
inline ll inv(ll x)
{
    return qpow(x,mod-2);
}

int main()
{
    cin >> n >> a >> b >> c >> k;
    make_table(n+5);
    ll cnt = 0;
    ll inv2 = inv(2);
    for(int i = 2; i<=n; i++)
        cnt = (cnt+((n+1)*phi[i]%mod-(phi[i]*i%mod*inv2)%mod+mod)%mod*(n-i+1)%mod*8%mod)%mod;
    cnt = (cnt+n*n%mod*4%mod+4*n%mod*(n+1)%mod)%mod;
    ll totnum = (n+1)*(n+1)%mod*((n+1)*(n+1)%mod)%mod;
    ll prob = cnt*inv(totnum)%mod;
    ll dmg = (a*(k*(k+1)%mod*(2*k+1)%mod*inv(6)%mod)%mod+
             b*(k*(k+1)%mod*inv(2)%mod)%mod+c*k%mod)%mod;
    cout << prob*dmg%mod << endl;
    return 0;
}
```

这个方法能否拓展到低于线性的时间尚未可知，我暂时没有好的想法。不过莫比乌斯反演倒是肯定行。

---

## 作者：chihik (赞：2)



因为每回合击中的概率是固定的，所以只需要算一次。

概率为：可以击中的情况/总情况。

每个点有 $(n+1)^2$ 个位置，所以总情况为$(n+1)^4$ 

可以击中的情况和仪仗队差不多，画个图就知道答案为：

$$4(n-1)n+4\sum_{i=1}^{n-1}\sum_{j=1}^{n-1} [(i,j)=1](n-i)(n-j)$$

$$4(n-1)n+4\sum_{i=1}^{n-1}\sum_{j=1}^{n-1} [(i,j)=1](n^2-(i+j)n+ij)$$

$$4(n-1)n+4\sum_{i=1}^{n-1}\sum_{j=1}^{n-1} \sum_{d|(i,j)} \mu(d)(n^2-(i+j)n+ij)$$

$$4(n-1)n+4\sum_{d=1}^{n-1}\mu(d)\sum_{i=1}^{\lfloor \frac{n-1} {d} \rfloor}\sum_{j=1}^{\lfloor \frac{n-1}{d} \rfloor} (n^2-(i+j)dn+ijd^2)$$

令 $T=\lfloor \frac{n-1}{d} \rfloor$ ，则有：

$$4(n-1)n+4\sum_{d=1}^{n-1}\mu(d)(T ^2n^2-ndT^2(T+1)+\frac{d^2T^2(T+1)^2}{4})$$

$$4(n-1)n+\sum_{d=1}^{n-1}\mu(d)(4T ^2n^2-4ndT^2(T+1)+d^2T^2(T+1)^2)$$

后面的可以整除分块，预处理 $\mu,\mu\times i,\mu \times i^2$ 的前缀和后我们便可以在 $\Theta(\sqrt n)$ 的复杂度解决单次询问。

知道概率 $p$ 后期望总伤害便为:

$$(\frac{k(k+1)(2k+1)}{6}a+\frac{k(k+1)}{2}b+kc)p$$

复杂度 $\mathcal O(n+\sqrt n)$。

这样做的空间大概在 180MB 左右，有亿点点问题，不过卡一下勉强能过。

为了可读性就附上原来的代码。

```cpp
#include <cstdio>

const int MAXN = 1e7 , Mod = 19260817;
const int Inv2 = 9630409 , Inv6 = 16050681;

int a , b , c , n , k;
int p , atk;

int prn , prime[ MAXN + 5 ] , mu[ MAXN + 5 ];
int f1[ MAXN + 5 ] , f2[ MAXN + 5 ] , f3[ MAXN + 5 ];
bool vis[ MAXN + 5 ];
void sieve( ) {
	mu[ 1 ] = 1;
	for( int i = 2 ; i <= n ; i ++ ) {
		if( !vis[ i ] ) { prime[ ++ prn ] = i; mu[ i ] = -1; }
		for( int j = 1 ; j <= prn && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) break;
			mu[ i * prime[ j ] ] = -mu[ i ];
		}
	}
	for( int i = 1 ; i <= n ; i ++ ) {
		f1[ i ] = ( f1[ i - 1 ] + mu[ i ] + Mod ) % Mod;
		f2[ i ] = ( f2[ i - 1 ] + mu[ i ] * i + Mod ) % Mod;
		f3[ i ] = ( f3[ i - 1 ] + 1ll * mu[ i ] * i * i % Mod + Mod ) % Mod;
	}
}

int Quick_pow( int x , int po ) {
	int Ans = 1;
	for( ; po ; po >>= 1 , x = 1ll * x * x % Mod )
		if( po & 1 ) Ans = 1ll * Ans * x % Mod;
	return Ans;
}
int Inverse( int x ) {
	return Quick_pow( x , Mod - 2 );
}

int Calc1( int x ) { return 1ll * x * ( x + 1 ) % Mod * Inv2 % Mod; }
int Calc2( int x ) { return 1ll * x * ( x + 1 ) % Mod * ( 2 * x % Mod + 1 ) % Mod * Inv6 % Mod; }

int main( ) {
	scanf("%d %d %d %d %d",&n,&a,&b,&c,&k); n ++; sieve( );
	
	atk = ( 1ll * Calc2( k ) * a % Mod + 1ll * Calc1( k ) * b % Mod + 1ll * k * c % Mod ) % Mod;
	
	p = 4ll * ( n - 1 ) * n % Mod;
	for( int l = 1 , r , T ; l <= n - 1 ; l = r + 1 ) {
		r = ( n - 1 ) / ( ( n - 1 ) / l ); T = ( n - 1 ) / l;
		p = ( p + 4ll * ( f1[ r ] - f1[ l - 1 ] + Mod ) % Mod * T % Mod * T % Mod * n % Mod * n % Mod - 4ll * ( f2[ r ] - f2[ l - 1 ] + Mod ) % Mod * n % Mod * T % Mod * T % Mod * ( T + 1 ) % Mod + 1ll * ( f3[ r ] - f3[ l - 1 ] + Mod ) % Mod * T % Mod * T % Mod * ( T + 1 ) % Mod * ( T + 1 ) % Mod + Mod ) % Mod;
	}
	
	int Invn = Inverse( n );
	p = 1ll * p * Invn % Mod * Invn % Mod * Invn % Mod * Invn % Mod;
	printf("%d\n", 1ll * atk * p % Mod );			
	return 0;
}
/*
2 0 0 1 1
15218424
(56)
*/
```


---


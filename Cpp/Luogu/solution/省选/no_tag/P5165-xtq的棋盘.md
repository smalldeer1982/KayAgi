# xtq的棋盘

## 题目背景

自从二年级起，xtq就热爱棋类游戏。

## 题目描述

xtq有一个$1$行，$n+1$列的棋盘，从左到右编号为$0$到$n$。初始时刻，在$m$位置有一颗棋子。

xtq会在接下来的时间里随机操作。具体地说，如果某一秒棋子不位于$n$，那么他将有$prb$的概率将棋子向左移动一格，$1-prb$的概率向右移动一格；否则，他必然将棋子向左移动一格。

现在xtq想问你，期望多少秒之后棋子能够到达$0$。由于答案可能很大，并且为了避免不必要的精度误差，你只需要给出答案对于$10^9+7$取模的结果即可（可以证明，答案必然是一个有理数）。

## 说明/提示

对于$20\%$的数据，$n\le 4, 1\le p\le q\le 4$而且保证答案在取模前是一个整数。

对于$40\%$的数据，$n\le 300$。

对于$70\%$的数据，$n\le 1000000$。

对于$100\%$的数据，$1\le m\le n\le 10^9, 1\le p\le q\le 10^9$并且$p,q$互质。

此外，在全部的数据点中，有$30\%$的数据是满足$prb = \frac{1}{2}$的。

有理数对质数$p$取模定义如下：

设$\frac{a}{b}$对$p$取模的结果为$x$，那么需要满足$0\le x<p$且$a \equiv bx (mod p)$。

保证对于$100\%$的数据，一定存在满足要求的$x$。

## 样例 #1

### 输入

```
3 1 1 3```

### 输出

```
13```

# 题解

## 作者：Caro23333 (赞：10)

### 20pts:
感性理解数学期望的定义，我们可以采用多次模拟随机过程的的暴力方法来算出数据很小时的期望值。

事实上，对于题目中给出的数据范围只需要模拟10000次随机过程并且计算平均的时间再四舍五入即可准确得到答案而不超出时限。

### 40pts:
接下来我们设向左走的概率为$p$。

考虑一个期望的线性方程组。

设$E(x)$为从$x$开始到达$0$所需要的期望时间，有：

$E(0)=0$

$E(1)=pE(0)+(1-p)E(2)+1$

$E(2)=pE(1)+(1-p)E(3)+1$

$\dots \dots$

$E(n-1)=pE(n-2)+(1-p)E(n)+1$

$E(n)=E(n-1)+1$

使用高斯消元在模意义下解这个方程组，答案为$E(m)$。

### 70pts:
发现$E(i)$只和$E(i-1)$与$E(i+1)$相关，而$E(0)=0$，所以有：

$E(1)=(1-p)E(2)+1$。
代入第三个方程，得到：

$E(2)=p((1-p)E(2)+1)+(1-p)E(3)+1$，
就可以推出$E(2)$和$E(3)$的关系，然后再代入下一个方程，依此类推，可以在$O(n)$时间内从上到下进行消元，解出$E(n)$。

然后可以再用$O(n)$时间从下到上推回来，就可以推出$E(m)$。

### 100pts:
考虑第$i+1$个方程$E(i)=pE(i-1)+(1-p)E(i+1)+1$，变形可得：
$(1-p)E(i+1)-E(i)=-pE(i-1)+1$

两侧同时加上$pE(i)$，得：
$(1-p)[E(i+1)-E(i)]=p[E(i)-E(i-1)]+1$，即：

$E(i)-E(i-1)=\frac{1-p}{p}[E(i+1)-E(i)]+\frac{1}{p}$

设$F(i)=E(i)-E(i-1)$，
则有：
$F(i)=\frac{1-p}{p}F(i+1)+\frac{1}{p}$，并且$F(n)=1$。

有一定技巧性的一步：将式子的两侧同时加上$\frac{1}{1-2p}$（此时要求$p$不等于$\frac{1}{2}$），得到：
$F(i)+\frac{1}{1-2p}=\frac{1-p}{p}[F(i+1)+\frac{1}{1-2p}]$（此步来源可上网搜索"特征根法"）

那么显然有：$F(i)=(\frac{1-p}{p})^{n-i}[F(n)+\frac{1}{1-2p}]-\frac{1}{1-2p}$

我们发现$E(m)=\sum_{i=1}^{m}F(i)$，实际上核心就是一个等比数列求和。

对于一个首项为$a$，公比为$q$，项数为$n$的等比数列，它的各项和$S=\frac{a(1-q^n)}{1-q}$，利用这个公式对$F(i)$进行求和即可得到$E(m)$，限于篇幅就不详述了。

之前暂时没有考虑$p=\frac{1}{2}$的情况，但我们发现这种情况下$\frac{1-p}{p}=1$，也就是说$F(i)=F(i+1)+2$。

那么，$\sum_{i=1}^{m}F(i)$就变成了一个非常naive的等差数列求和了。

此题完结。

代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#define mod 1000000007

using namespace std;
typedef long long ll;
inline ll qpow(ll a, ll b)
{
    ll res = 1;
    while(b)
    {
        if(b&1) res = res*a%mod;
        a = a*a%mod;
        b >>= 1;
    }
    return res;
}
inline ll inv(ll x)
{
    return qpow(x,mod-2);
}
ll prb,qrb,rrb;
inline ll calc(ll x)
{
    return ((1-qpow(qrb,x))%mod+mod)%mod*inv(((1-qrb)%mod+mod)%mod)%mod;
}

int main()
{
    ll n,m,p,q;
    cin >> n >> m >> p >> q;
    prb = p*inv(q)%mod;
    qrb = ((1-prb)%mod+mod)%mod*inv(prb)%mod;
    rrb = (mod-1)*inv(((1-2*prb%mod)%mod+mod)%mod)%mod;
    if(q==2&&p==1)
        cout << ((2*n%mod-m)%mod+mod)%mod*m%mod << endl;
    else
    {
        ll ans = ((1-rrb)%mod+mod)%mod;
        ans = ans*(((calc(n)-calc(n-m))%mod+mod)%mod)%mod;
        ans = (ans+(m*rrb)%mod)%mod; 
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：bztMinamoto (赞：3)

[传送门](https://www.luogu.org/problemnew/show/P5165)

设$f[i]$为$i$位置向左走一步的期望时间，那么答案就是$\sum_{i=1}^mf[i]$

首先$f[n]=1$，设$p$为向左的概率，对于$i<n$的位置，有$$f[i]=\sum_{j=1}^{\infty}(j+(j-1)\times f[i+1])(1-p)^{j-1}p$$
就是说枚举一下往右走了几次，左边是走了$j$次的步数，右边是走了$j$次的概率

根据高中数学知识，这是个等比+等差数列的求和，那么推倒一下可得$$f[i]=\frac{1-p}{p}\times(f[i+1]+1)+1$$
用递推可以做到$O(n)$的复杂度，可以有70分

考虑一下，对于一个固定的$p$，整个数列都是已知的，设$a=\frac{1-p}{p}$，那么有$f[n]=1,f[n-1]=2a+1,f[n-2]=2a^2+2a+1,...$，我们只要可以快速求出它的后缀和，然后减一减就可以得到答案了。设$ans[j]=\sum_{i=n-j+1}^n f[i]$，有$ans[j]=1+2(n-1)a+2(n-2)a^2+...+2a^{n-1}$，这也是一个等比+等差数列的求和，推倒可得$$ans[i]=\frac{(2-i)a-i+2a^2\frac{1-a^{i-1}}{1-a}}{a-1}$$

于是就可以直接求出两个后缀和相减得到答案了

注意特判$i=0$和$i=1$的情况，一个返回$0$，一个返回$1$

注意特判$a=1$的情况，这种情况下$a-1$没有逆元不能直接带，打表得此时后缀和为$ans[i]=i^2$，特判掉就好了
```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define ll long long
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
const int P=1e9+7,N=1e6+5;
inline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}
inline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
    R int res=1;
    for(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);
    return res;
}
int n,m,p,q,pi,ppi,res,now,f[N],loli;
int calc(R int n){
    if(n==0)return 0;if(n==1)return 1;
    if(pi==1)return mul(n,n);
    res=mul(dec(2,n),pi),res=dec(res,n);
    loli=mul(2,mul(pi,pi)),loli=mul(loli,dec(1,ksm(pi,n-1))),
    loli=mul(loli,ksm(dec(1,pi),P-2));
    return mul(add(res,loli),ksm(dec(pi,1),P-2));
}
int main(){
//	freopen("testdata.in","r",stdin);
    scanf("%d%d%d%d",&n,&m,&p,&q),pi=mul(p,ksm(q,P-2)),ppi=dec(1,pi);
    pi=mul(ppi,ksm(pi,P-2));
    printf("%d\n",dec(calc(n),calc(n-m)));
    return 0;
}
```

---

## 作者：luanyanjia (赞：1)

这个题也可以用矩阵加速解决。

先考虑 70pts 的做法，我们设 $f_i$ 为从 $i$ 位置到达 $0$ 的期望步数，并尝试用 $f_n$ 表示出所有 $f_i$ 并利用 $f_0$ 解出 $f_n$ 然后回带即可。

具体地，设 $f_i = a \times f_n + b$，$f_{i-1} = c \times f_n +d$，则由于：

$$f_i = prb \times f_{i-1} + (1 - prb) \times f_{i+1} +1$$ 

所以：

$$ 
\begin{align*}
f_{i+1} & = f_i - prb \times f_{i-1} - 1 \\
& = (a - prb \times c) \times f_n + (b - prb \times d + 1)
\end{align*}
$$

直接计算出 $f_0$ 和 $f_n$ 的关系，然后暴力算即可，复杂度 $O(n)$。

怎么优化呢？

注意到上面的 $a,b,c,d$ 和新的两个系数都是线性的关系，可以直接用矩阵加速递推，时间复杂度 $O(\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void rd(){}
template<typename T,typename ...U>
inline void rd(T &x,U &...args){
	char ch=getchar();
	T f=1;x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x*=f;rd(args...);
}
const int mod=1e9+7,N=1e6+5;
int n,m,p,q,ip;
struct Matrix{
	int m[3][3];
	Matrix(){memset(m,0,sizeof m);}
	Matrix(int x){
		memset(m,0,sizeof m);
		m[0][0]=m[1][1]=m[2][2]=x;
	}
	Matrix friend operator*(Matrix a,Matrix b){
		Matrix c;
		for(int k=0;k<3;k++)
			for(int i=0;i<3;i++)
				for(int j=0;j<3;j++)
					(c.m[i][j]+=1ll*a.m[i][k]*b.m[k][j]%mod)%=mod;
		return c;
	}
}; 
inline int KSM(int x,int n){
	int ans=1;
	while(n){
		if(n&1)ans=1ll*ans*x%mod;
		x=1ll*x*x%mod;
		n>>=1;
	}
	return ans;
}
inline Matrix KSM(Matrix x,int n){
	if(n<0)return Matrix(0);
	Matrix ans=Matrix(1);
	while(n){
		if(n&1)ans=ans*x;
		x=x*x;
		n>>=1;
	}
	return ans;
}
int A,B,Am,Bm,ans;
signed main(){
	rd(n,m,p,q);
	p=1ll*p*KSM(q,mod-2)%mod;
	ip=KSM(p,mod-2);
	Matrix bas,ch;
	ch.m[0][0]=ip,ch.m[0][1]=1;
	ch.m[1][0]=1ll*(p-1)*ip%mod;
	bas.m[0][0]=bas.m[0][1]=1;
	A=(bas*KSM(ch,n-1)).m[0][0];
	Am=(bas*KSM(ch,n-m-1)).m[0][0];
	ch.m[2][2]=1,ch.m[2][0]=(mod-ip);
	bas.m[0][0]=mod-1,bas.m[0][1]=0,bas.m[0][2]=1;
	B=(bas*KSM(ch,n-1)).m[0][0];
	Bm=(bas*KSM(ch,n-m-1)).m[0][0];
	ans=1ll*(mod-B)*KSM(A,mod-2)%mod;
	if(n==m)return printf("%d\n",ans),0;
	ans=(1ll*Am*ans%mod+Bm)%mod;
	printf("%d\n",ans);
	return 0;
}


```

---


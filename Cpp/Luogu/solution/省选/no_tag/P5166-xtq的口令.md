# xtq的口令

## 题目背景

三年级时，xtq 就展现出高超的身体素质，以至于体育老师允许他不用参加同学们的体育锻炼，而是可以自由活动。

xtq 现在正在观察同学们跑步。

## 题目描述

$n$ 个同学在排队跑步。

体育老师发了一条指令，要求这 $n$ 名同学加快跑步速度。然而，由于风太大，只有部分同学听到并执行了老师的指令。同时，没有听到指令的同学如果观察到其他的同学执行了老师的指令，他们也会执行老师的指令。

现在我们一般化这个情况。我们将位于队首的同学编号为 $1$，将接下来的同学以此类推，最后位于队尾的同学编号为 $n$。

经过观察，xtq 给出了每位同学的若干位观察对象，这意味着当这位同学看到他的任何一个观察对象加快跑步速度（执行指令）时，他也会加快跑步速度（执行指令）。保证对于任何一位同学，他的所有观察对象的编号都小于自己（一个同学只会观察排在自己前面同学中的一部分）。

现在有 $q$ 条询问或修改，

询问：格式为 ```1 L R```。

回答如果编号在 $\left[L,R \right]$ 范围内的同学听到了指令，至少还需要多少个同学听到指令才能使所有人执行指令。

修改：格式为 ```2 L R x```。

给在 $\left[L,R \right]$ 的同学添加第 $x$ 位同学作为自己的观察对象。保证 $x < L$。如果区间内有人原来的观察对象有第 $x$ 位同学，忽略即可。

## 说明/提示

【样例解释】

样例中，$1$ 号同学被 $3$ 号同学观察，$2$ 号同学被 $3$ 号同学观察，$3$ 号同学被 $4$ 号同学观察。

对于第一个询问 ```1 2 3```：这意味着 $2,3$ 号两位同学听到了老师的指令。因为 $3$ 号同学被 $4$ 号同学观察，所以当 $3$ 号同学加快跑步速度后，$4$ 号同学也会加快跑步速度。所以需要告诉 $1$ 号同学指令是什么，才能使所有同学收到指令。

【数据范围】
|编号|n|特殊性质|
| ------ | ------ | ------ |
|1|$10$|有|
|2|$10$|无|
|3|$500$|有|
|4|$5000$|无|
|5|$5000$|无|
|6|$50000$|有|
|7|$50000$|无|
|8|$3 \times 10^5$|有|
|9|$3 \times 10^5$|无|
|10|$3 \times 10^5$|无|

特殊性质：修改操作不超过 $100$ 次。

对于 $100\%$ 的数据，$n,q\le 3 \times 10^5$，$\sum a_i\le 10^7$。

由于本题输入输出量大，请不要使用 cin/cout。

## 样例 #1

### 输入

```
4 4
1 3
1 3
1 4
0
1 2 3
1 1 1
2 2 3 1
1 1 1```

### 输出

```
1
1
0```

# 题解

## 作者：mydiplomacy (赞：6)

如果A同学观察B同学，那么我们连一条从点A到点B的有向边。

在下面的陈述中，我们将“A同学收到指令”称为“点A被染色”。

那么我们就可以把题意转化为：

#### 给定一个有向图，已知当一个点连向的点被染色时，那么这个点也被染色。支持两种操作：

#### 查询操作：给定区间$[L,R]$内的所有点被染色，那么求还需要给多少点染色，才能使最终所有点被染色。

#### 修改操作：给定区间$[L,R]$和$x$，将编号在区间$[L,R]$内的所有点连向x。

下面考虑做法。

- 20分：

	完全暴力即可。对于每个查询操作，首先忽略所有$[L,R]$内的点和$[L,R]$被染色后被染色的点。接下来枚举每个点是否被选中，对于每种方案进行判定是否合法，最后输出最小答案。
    
- 50分：

	需要进一步研究性质。
    
    首先，由于边只会从编号大的点连到编号小的点，那么这个图一定是一个有向无环图。
    
    观察所有出度为零（指图中不存在这个点连出的边）的点。我们可以证明：
    
    - #### 如果这些点当中的每个点，如果这个点没被$[L,R]$包含，那么这个点必须被染色。
    	
        证明：由于这个点没有连出的边，那么如果任何其他点被染色了，这个点都不会被染色。
    - #### 当所有这些点被染色了，那么所有点都会被染色。
    	
        证明：假设存在一个点，当所有这些点被染色时，还没有被染色。于是我们可以推出，这个点所连向的所有点都没有被染色。所以，这个点所连向的点所连向的点也没有被染色，以此类推。由于点的数量是有限的，所以必定会出现下列情况之一：
        - 这个点所连向的点所连向的点...所连向的点，与这个点重合，或者与另外一个这个点所连向的点...所连向的点重合。这与无环矛盾。
        - 这个点所连向的点...所连向的点，没有连出的边。由于我们前面的推导，这个点一定没有染色。而这又与我们假设的前提矛盾。
        
      所以，假设不成立！
    
  于是，所有点被染色的充分必要条件是所有出度为零的点被染色。所以这道题的询问操作就转化为了：查询有多少出度为零的点，不在区间$[L,R]$内。只需首先预处理 出入度为零的点，修改操作时移除所有区间内的点，均可以$O(n)$处理。
  
  50分代码见下面参考代码1。
  
- 70分（所有具备特殊性质的数据点）：
	
    我们可以首先$O(m)$预处理每个点是否为出度为零的点并记录，接下来$O(n)$预处理出$sum[i]$，代表$1$~$i$中有多少个出度为零的点。
    
    对于每个修改操作，只需要将$[L,R]$内的每个点标记为出度非零，再根据之前处理出的每个点的是否入度为零标记重新计算$sum$数组。效率O(n)
    
    对于每个查询操作，利用前缀和$O(1)$查询$[1,L-1]$与$[R+1,N]$内共有多少个出度非零的点，然后输出。效率$O(1)$
    
    但由于修改不超过100组，可以得到部分分。
    
    70分代码见下面参考代码2。
    
- 100分：
	
    利用线段树等数据结构维护数组$a$，$a[i]$代表是否出度为零，如果是则为1，否则为0。
    
    查询操作相当于查询$[1,L-1]$的和加上$[R+1,N]$的和。
    
    修改操作相当于将$[L,R]$区间区间覆盖为0。
    
    问题得解。
    
    std见下面参考代码3。
    
参考代码1：
```
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int maxn=300005;

int d[maxn]; //d代表：当前节点出度是否为零。1：出度为零，0：出度非零

int main()
{
    int n,q;
    scanf("%d %d",&n,&q);
    for(int i=1;i<=n;i++) d[i]=1;
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d",&x);
        for(int j=1;j<=x;j++)
        {
            scanf("%d",&y);
            d[y]=0; //出度非零
        }
    }
    for(int i=1;i<=q;i++)
    {
        int opt,x,y,z;
        scanf("%d",&opt);
        if(opt==1)
        {
            int sum=0;
            scanf("%d %d",&x,&y);
            for(int j=1;j<x;j++) 
                sum+=d[j];
            for(int j=y+1;j<=n;j++)
                sum+=d[j];
            printf("%d\n",sum);
        }
        if(opt==2)
        {
            scanf("%d %d %d",&x,&y,&z);
            for(int i=x;i<=y;i++) d[i]=0;
        }
    }
    return 0;
}
```

参考代码2：
```
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int maxn=300005;

int d[maxn],s[maxn]; //s:前缀和

int main()
{
    int n,q;
    scanf("%d %d",&n,&q);
    for(int i=1;i<=n;i++) d[i]=1;
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d",&x);
        for(int j=1;j<=x;j++)
        {
            scanf("%d",&y);
            d[y]=0;
        }
    }
    for(int i=1;i<=n;i++) s[i]=s[i-1]+d[i];
    for(int i=1;i<=q;i++)
    {
        int opt,x,y,z;
        scanf("%d",&opt);
        if(opt==1)
        {
            int sum=0;
            scanf("%d %d",&x,&y);
            sum=s[x-1]+s[n]-s[y];
            printf("%d\n",sum);
        }
        if(opt==2)
        {
            scanf("%d %d %d",&x,&y,&z);
            for(int i=x;i<=y;i++) d[i]=0; 
            for(int i=1;i<=n;i++) s[i]=s[i-1]+d[i]; //修改操作后，重新计算前缀和
        }
    }
    return 0;
}
```

参考代码3：
```
#include <iostream>
#include <cstdio>
using namespace std;

const int maxn=900005;

struct Node //线段树节点
{
    int left, right;
    int sum, lazy;
}a[maxn];

int ab[maxn],x,y,z,opt,d[maxn];
int n,q;

void buildtree(int id, int l, int r)
{
    a[id].left=l; a[id].right=r; a[id].lazy=0;
    if(l==r)
    {
        if(d[l]==1)
            a[id].sum=0;
        else
            a[id].sum=1;
        return;
    }
    int mid=(l+r)/2;
    buildtree(id<<1,l,mid);
    buildtree(id<<1|1,mid+1,r);
    a[id].sum=a[id<<1].sum+a[id<<1|1].sum;
}

void pushdown(int id)
{
    if(a[id].lazy==1)
    {
        a[id].sum=0;
        a[id<<1].lazy=1;
        a[id<<1|1].lazy=1;
        a[id].lazy=0;
    }
}

int query(int id, int l, int r)
{
    if(a[id].left==l && a[id].right==r)
    {
        if(a[id].lazy==0)
            return a[id].sum;
        else
            return 0;
    }
    pushdown(id);
    if(r<=a[id<<1].right) return query(id<<1,l,r);
    else if(l>=a[id<<1|1].left) return query(id<<1|1,l,r);
    else
    {
        return query(id<<1,l,a[id<<1].right)+query(id<<1|1,a[id<<1|1].left,r);
    }
}

void change(int id, int l, int r)
{
    if(a[id].left==l && a[id].right==r)
    {
        a[id].lazy=1;
        return;
    }
    pushdown(id);
    if(r<=a[id<<1].right) change(id<<1,l,r);
    else if(l>=a[id<<1|1].left) change(id<<1|1,l,r);
    else
    {
        change(id<<1,l,a[id<<1].right);
        change(id<<1|1,a[id<<1|1].left,r);
    }
    a[id].sum=(a[id<<1].lazy==0?a[id<<1].sum:0)+(a[id<<1|1].lazy==0?a[id<<1|1].sum:0);
}

int main()
{
    scanf("%d %d",&n,&q);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&ab[i]);
        for(int j=1;j<=ab[i];j++)
        {
            scanf("%d",&x);
            d[x]=1;
        }
    }
    buildtree(1,1,n);
    for(int i=1;i<=q;i++)
    {
        scanf("%d",&opt);
        if(opt==1)
        {
            scanf("%d %d",&x,&y);
            printf("%d\n",query(1,1,n)-query(1,x,y));
        }
        else
        {
            scanf("%d %d %d",&x,&y,&z);
            change(1,x,y);
        }
    }
    return 0;
}
```

---

## 作者：bztMinamoto (赞：4)

[传送门](https://www.luogu.org/problemnew/show/P5166)

这题要是搞懂在干什么其实不难（虽然某个花了几个小时才搞明白的家伙似乎没资格这么说……）

假设所有人都没有听到老师的命令，我们从左到右考虑，对于当前的人，如果它没有观察者，那么肯定要让它听到老师的指令才行，如果它有观察者，那么它的观察者在之前就已经考虑过，肯定已经听到指令了，那么它也可以听到指令，不需要再听一遍

综上，需要听到指令的人就是没有观察者的人

于是把有观察者的看成$0$，没有观察者的看成$1$，那么一次询问$[l,r]$就相当于询问$[1,l-1]$和$[r+1,n]$中$1$的总个数，一次修改就相当于把$[l,r]$中区间覆盖为$0$

上面两个操作用线段树就可以了
```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define ls (p<<1)
#define rs (p<<1|1)
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void print(R int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=3e5+5;
int sum[N<<2],tag[N<<2],vis[N];
int n,q,x,y,op,l,r,res;
void pd(int p){
    if(tag[p]){
        sum[ls]=sum[rs]=0;
        tag[ls]=tag[rs]=1;
        tag[p]=0;
    }
}
void build(int p,int l,int r){
    if(l==r)return (void)(sum[p]=!vis[l]);
    int mid=(l+r)>>1;
    build(ls,l,mid),build(rs,mid+1,r);
    sum[p]=sum[ls]+sum[rs];
}
void update(int p,int l,int r,int ql,int qr){
    if(!sum[p])return;
    if(ql<=l&&qr>=r)return (void)(sum[p]=0,tag[p]=1);
    int mid=(l+r)>>1;pd(p);
    if(ql<=mid)update(ls,l,mid,ql,qr);
    if(qr>mid)update(rs,mid+1,r,ql,qr);
    sum[p]=sum[ls]+sum[rs];
}
int query(int p,int l,int r,int ql,int qr){
    if(!sum[p])return 0;if(ql<=l&&qr>=r)return sum[p];
    int mid=(l+r)>>1,res=0;pd(p);
    if(ql<=mid)res+=query(ls,l,mid,ql,qr);
    if(qr>mid)res+=query(rs,mid+1,r,ql,qr);
    return res;
}
int main(){
//	freopen("testdata.in","r",stdin);
    n=read(),q=read();
    fp(i,1,n){
        x=read();
        while(x--)y=read(),vis[y]=1;
    }build(1,1,n);
    while(q--){
        op=read(),l=read(),r=read();
        if(op==1){
            res=0;if(l>1)res+=query(1,1,n,1,l-1);
            if(r<n)res+=query(1,1,n,r+1,n);
            print(res);
        }else x=read(),update(1,1,n,l,r);
    }return Ot(),0;
}

```

---

## 作者：yizhiming (赞：2)

感觉评论区里说的对，这道题的难度够不上紫。

## 题面描述

有 $n$ 个人，每个人有若干个观察对象或没有，保证观察对象的下标小于观察者，当一个人的观察对象执行命令时，观察者也会跟着执行命令，每个人初始被 $a_i$ 个人观察。

有 $q$ 次操作，分为两种：

- 修改：下标区间 $[L,R]$ 中所有人添加一个观察对象 $x$

- 查询：若下标区间 $[L,R]$ 受到命令并执行，至少还需要给多少个人发布命令，才能使得全部的人都执行命令。

$n,q\leq 3\times 10^5,\sum a_i \leq 10^7$。

## 题目分析

注意到每个人的观察对象，都比自身的下标要小，也就说明对于每个人，在他后面的人不会对他造成任何影响，所以我们考虑正着推，对于一个人，他要么观察对象执行命令，要么他自己额外收到命令，而我们按照从前往后的顺序排就会发现，对于每个人，为了保证正确性，他前面的人一定都能够执行命令。

所以当前的这个人，只要有观察对象，就一定会收到命令，所以我们可以将人分为有观察对象的和没有观察对象，查询的时候，只需要统计全局有多少个没有观察对象的且不在区间 $[L,R]$ 的人的个数即可。

所以我们会发现我们只需要维护每个人是否有观察对象，修改操作本质上就变成了区间覆盖 $1$，查询本质上变成了查询区间 $[1,L-1]$ 和 $[R+1,n]$ 中 $0$ 的个数,直接上线段树即可。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 3e5+5;
int n,q,tot=1;
int a[N]; 
struct aa{
	int lc,rc,sum,tag;
}node[N*2];
void pushup(int u){
	node[u].sum = node[node[u].lc].sum+node[node[u].rc].sum;
}
void build(int u,int l,int r){
	if(l==r){
		node[u].sum = a[l];
		return;
	}
	int mid = (l+r)/2;
	node[u].lc = ++tot;
	build(node[u].lc,l,mid);
	node[u].rc = ++tot;
	build(node[u].rc,mid+1,r);
	pushup(u);
}
void lazy_tag(int u,int l,int r){
	node[u].tag = 1;
	node[u].sum = r-l+1;
}
void pushdown(int u,int l,int r){
	int mid = (l+r)/2;
	lazy_tag(node[u].lc,l,mid);
	lazy_tag(node[u].rc,mid+1,r);
	node[u].tag = 0;
}
void upd(int u,int l,int r,int ll,int rr){
	if(l==ll&&r==rr){
		lazy_tag(u,l,r);
		return;
	}
	if(node[u].tag){
		pushdown(u,l,r);
	}
	int mid = (l+r)/2;
	if(rr<=mid){
		upd(node[u].lc,l,mid,ll,rr);
	}else if(ll>mid){
		upd(node[u].rc,mid+1,r,ll,rr);
	}else{
		upd(node[u].lc,l,mid,ll,mid);
		upd(node[u].rc,mid+1,r,mid+1,rr);
	}
	pushup(u);
}
int query(int u,int l,int r,int ll,int rr){
	if(ll>rr){
		return 0;
	}
	if(l==ll&&r==rr){
		return node[u].sum;
	}
	if(node[u].tag){
		pushdown(u,l,r);
	}
	int mid = (l+r)/2;
	if(rr<=mid){
		return query(node[u].lc,l,mid,ll,rr);
	}else if(ll>mid){
		return query(node[u].rc,mid+1,r,ll,rr);
	}else{
		return query(node[u].lc,l,mid,ll,mid)+query(node[u].rc,mid+1,r,mid+1,rr);
	}
}
int ask(int l,int r){
	if(l>r){
		return 0;
	}
	return r-l+1-query(1,1,n,l,r);
}
int main(){
	int x,y,z;
	n = read();q = read(); 
	for(int i=1;i<=n;i++){
		x = read();
		while(x--){
			a[read()]=1;
		}
	}
	build(1,1,n);
	int opt;
	while(q--){
		opt = read();x = read();y = read();
		if(opt==1){
			cout<<ask(1,x-1)+ask(y+1,n)<<"\n";
		}else{
			z = read();
			upd(1,1,n,x,y);
		}
	}
	return 0;
}

```


---

## 作者：b__b (赞：1)

~~感觉这个题好冷。~~

我们考虑询问。由于 $\left[L,R \right]$ 区间的人都听见了老师的指令，因此我们只需要考虑 $\left[1,L \right)$ 与 $\left(R,N \right]$ 区间里面的人。

对于其中一个同学：

1. 如果他没有观察对象，那他是无论如何不可能收到这个指令的，因此必须要直接让他听到指令。
2. 如果他有观察对象，由题目“一个同学只会观察排在自己前面同学中的一部分”可以保证这个人的观察对象在前面已经处理过，即他的观察对象一定会收到指令，因此他一定会收到指令。

于是问题变成了查询一个区间内有多少个人没有观察对象。

将有观察对象的人抽象成数字 $0$，没有观察对象的人抽象成数字 $1$，于是问题变成查询这个区间内的区间和。

修改会让区间内的所有人至少有一个观察对象，即将这个区间置 $0$。于是这个题就是区间修改与区间查询，直接用线段树即可。

当然可以直接套模板，这同样是正确的。但是由于这个题的操作比较少，因此我们可以加一点特殊的优化。（~~用处：抢最优解。~~）详见代码。
```cpp
#include <cstdio>
const int N = 3e6 +5;
int n, q, a, tm, l, r, i, tree[N << 2];
bool has[N];
inline int ls(int p) {return p << 1;}
inline int rs(int p) {return p << 1 | 1;}
inline void pushup(int p) {tree[p] = tree[ls(p)] + tree[rs(p)];}
void build(int p, int pl, int pr) {
    if (pl == pr) {tree[p] = !has[pl]; return;}
    int mid = (pl + pr) >> 1;
    build(ls(p), pl, mid), build(rs(p), mid + 1, pr), pushup(p);
}
void upd(int p, int pl, int pr) {
    if (!tree[p]) return; //因为一个区间内最多只需要修改一次，因此当这个区间修改过后就不需要修改了
    //这也是为什么不需要写addtag与pushdown函数的原因
    //query函数同理
    if (l <= pl && pr <= r) {tree[p] = 0; return;}
    int mid = (pl + pr) >> 1;
    if (l <= mid) upd(ls(p), pl, mid);
    if (mid < r) upd(rs(p), mid + 1, pr);
    pushup(p);
}
int query(int l, int r, int p, int pl, int pr) {
    if (!tree[p]) return 0;
    if (l <= pl && pr <= r) return tree[p];
    int mid = (pl + pr) >> 1, ret = 0;
    if (l <= mid) ret = query(l, r, ls(p), pl, mid);
    if (mid < r) ret += query(l, r, rs(p), mid + 1, pr);
    return ret;
}
int main() {
    for (scanf("%d%d", &n, &q); i < n; ++i) for (scanf("%d", &a); a--;) scanf("%d", &tm), has[tm] = 1;
    for (build(1, 1, n); q--;) {
        scanf("%d%d%d", &tm, &l, &r);
        if (tm == 1) {
            int tmp = 0;
            if (l > 1) tmp += query(1, l - 1, 1, 1, n);
            if (r < n) tmp += query(r + 1, n, 1, 1, n);
            printf("%d\n", tmp);
        } else scanf("%*d"), upd(1, 1, n);
    }
}
```

---

## 作者：KaguyaH (赞：1)

[**原题传送门**](https://www.luogu.com.cn/problem/P5166)

# 题意简述

给一个 DAG，有如下两种操作：

1. 给编号为 $[l, r]$ 的点染色，如果一个点被染色，那么能到达她的点也将被染色，求至少需要再给几个点染色才能使整张图被染色；
2. 从编号为 $[l, r]$ 的点向编号为 $x$ 的点连边。

# 题目分析

对于操作 1：我们考虑，不在 $[l, r]$ 中的出度为 $0$ 的点必然需要被染色；由于是 DAG，图中无环，故从任意一点走出的路径必然会走到一个出度为 $0$ 的点，故此时全部点被染色。

我们发现，我们只关心一个点的出度是否为 $0$，故我们可以使用线段树维护出度，对于操作 2 只需要判断并单点修改即可。

# Code

```cpp
# define _CRT_SECURE_NO_WARNINGS
# include <cstdio>

typedef signed int D;
typedef short unsigned int HU;
typedef long unsigned int LU;
enum Max { N = (const LU)3e5 };

class BBT {
	LU L, R;
public:
	bool x[N + 1];
private:
	LU sum[N + 1];
	inline const LU middle(const LU l, const LU r) const { return (l + r) / 2; }
	inline const void upto(const LU l, const LU r) {
		const LU x(middle(l, r));
		sum[x] = this->x[x];
		if (l < x) sum[x] += sum[middle(l, x - 1)];
		if (r > x) sum[x] += sum[middle(x + 1, r)];
	}
	inline const void clear() {
		for (register LU i(0); i <= N; ++i) x[i] = true;
	}
	const void _build(const LU l, const LU r) {
		const LU x(middle(l, r));
		if (l < x) _build(l, x - 1);
		if (r > x) _build(x + 1, r);
		upto(l, r);
	}
	const void modify(const LU tl, const LU tr, const LU l, const LU r) {
		const LU x(middle(l, r));
		if (!sum[x]) return;
		if (tl <= x and x <= tr) this->x[x] = false;
		if (tl < x and l < x) modify(tl, tr, l, x - 1);
		if (tr > x and r > x) modify(tl, tr, x + 1, r);
		upto(l, r);
	}
	inline const LU query(const LU tl, const LU tr, const LU l, const LU r) const {
		const LU x(middle(l, r));
		if (!sum[x]) return 0;
		if (tl <= l and r <= tr) return sum[x];
		LU res(0);
		if (tl <= x and x <= tr) res += this->x[x];
		if (tl < x and l < x) res += query(tl, tr, l, x - 1);
		if (tr > x and r > x) res += query(tl, tr, x + 1, r);
		return res;
	}
public:
	BBT() {
		clear();
	}
	inline const void build(const LU l, const LU r) {
		_build(L = l, R = r);
	}
	inline const void modify(const LU l, const LU r) {
		modify(l, r, L, R);
	}
	inline const LU query(const LU l, const LU r) {
		return query(l, r, L, R);
	}
};

LU n, q;
BBT tree;

D main() {
	D t;
	t = scanf("%lu%lu", &n, &q);
	for (register LU i(0); i < n; ++i) {
		LU a; t = scanf("%lu", &a);
		for (register LU j(0); j < a; ++j) {
			LU u; t = scanf("%lu", &u);
			tree.x[u] = false;
		}
	}
	tree.build(1, n);
	for (register LU i(0); i < q; ++i) {
		HU type; t = scanf("%hu", &type);
		switch (type) {
		case 1: {
			LU l, r; t = scanf("%lu%lu", &l, &r);
			printf("%lu\n", tree.query(1, n) - tree.query(l, r));
			break;
		}
		case 2: {
			LU l, r, x; t = scanf("%lu%lu%lu", &l, &r, &x);
			tree.modify(l, r);
			break;
		}
		}
	}
	return 0;
}
```

---

## 作者：AK_IOI的琪琪 (赞：1)

本蒟蒻第一次发题解，有的写的太粗略请大家多多包涵~~
~~这是我见过代码最短的紫题~~
好，我们进入正题
首先来说一下第一感受：q次询问和修改，还是连续区间，当然是线段树啦
刚开始的时候乍一看，什么观察对象、编号呀一大堆，怎么看怎么麻烦。这个时候以图的形式来画就能迎刃而解了。
若i号同学观察j号同学，那么我们就连边j->i。我们先考虑如何以最少的人数使得所有人都开始加速。我们惊奇的发现，好像只需要让所有入度为零的同学听到指令即可，而且这一定是最少的，因为如果比这个还少，那么一定存在一名入度为零的同学，ta没有直接听到指令，而且ta也不可能间接的得到指令，那么ta就不会加速。
经过如上的分析发现，我们并不需要记录谁观察谁，而只需要知道谁的入度为零。我们用in数组来表示其入度是否为零。
随后我们来看一下具体问题：
1.修改：从L到R都添加被观察的同学X。事实上我们不用管X是多少，只需要让in[L]~in[R] = 0即他们的入度都不为零。
2.询问：从L到R同学都直接得到指令，输出最少人数使得让所有人都加速。我们还是最开始的策略，只需所有入度为零的同学得到指令，但是现在处于L到R的同学都直接得到了指令，所以答案就变成了总共的减去L到R的。
最后，我们用线段树来就OK了
附上代码：
```
# include <bits/stdc++.h>
# define MAXN 300005
# define mid ((l + r) >> 1)
# define left (2 * rt)
# define right (2 * rt + 1)
using namespace std;

struct Node {
    int ans, lazy;
} tree[4 * MAXN];

int n, T;
int in[MAXN];

void build(int rt, int l, int r) {
    if (l == r) {
        tree[rt].ans = in[l];
        return;
    }
    build(left, l, mid);
    build(right, mid + 1, r);
    tree[rt].ans = tree[left].ans + tree[right].ans;
}

void downmark(int rt, int l, int r) {
    if (tree[rt].lazy == 0) return;
    tree[left].ans = 0;
    tree[right].ans = 0;
    tree[left].lazy = 1;
    tree[right].lazy = 1;
    tree[rt].lazy = 1;
}

void update(int rt, int l, int r, int p, int q) {
    if (l == p && r == q) {
        tree[rt].ans = 0, tree[rt].lazy = 1;
        return;
    }
    downmark(rt, l, r);
    if (q <= mid) update(left, l, mid, p, q);
    else if (p > mid) update(right, mid + 1, r, p, q);
    else {
        update(left, l, mid, p, mid);
        update(right, mid + 1, r, mid + 1, q);
    }
    tree[rt].ans = tree[left].ans + tree[right].ans;
}

int query(int rt, int l, int r, int p, int q) {
    if (l == p && r == q) return tree[rt].ans;
    downmark(rt, l, r);
    if (q <= mid) return query(left, l, mid, p, q);
    else if (p > mid) return query(right, mid + 1, r, p, q);
    else return query(left, l, mid, p, mid) + query(right, mid + 1, r, mid + 1, q);
}

int main()
{
    scanf("%d%d", &n, &T);
    for (int i = 1; i <= n; i++) in[i] = 1;
    int x, y;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &x);
        for (int j = 1; j <= x; j++) {
            scanf("%d", &y);
            in[y] = 0;
        }
    }
    build(1, 1, n);
    int f, a, b, k;
    while (T--) {
        scanf("%d", &f);
        if (f == 1) {
            scanf("%d%d", &a, &b);
            printf("%d\n", query(1, 1, n, 1, n) - query(1, 1, n, a, b));
        }
        if (f == 2) {
            scanf("%d%d%d", &a, &b, &k);
            update(1, 1, n, a, b);
        }
    }
    return 0;
}
```


---

## 作者：huhengrui2013 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P5166)

### 思路：


题目可以转化为图论问题：每个同学是一个节点，如果同学 $i$ 观察同学 $j$ ，则存在一条从 $j$ 到 $i$ 的有向边。当一个节点被 "染色"（表示题目中的执行指令，下同） 时，它可以沿着有向边传递颜色到其他节点。

为了让所有节点都被染色，必须染色所有**出度为 0** 的节点。因为这些节点无法从其他节点获得颜色，必须手动染色。

考虑线段树实现。

### AC Code:
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
int n,m,a[N];
int tr[4*N],tag[N*4];
void p_b(int p,int l,int r){//懒标记下发
    if(tag[p]){
        int mid=(l+r)/2;
        tag[2*p]=1;//左子树懒标记设为1
        tag[2*p+1]=1;//右子树懒标记设为1
        tr[2*p]=0;//左子树值设为0
        tr[2*p+1]=0;//右子树值设为0
        tag[p]=0;
    }
    return;
}
void build(int x,int l,int r){//建树
    if(l==r){
        tr[x]=!a[l]; // 如果节点x的出度为0，则tr[x]=1
        return ;
    }
    int mid=(l+r)/2;
    build(x*2,l,mid);
    build(x*2+1,mid+1,r);
    tr[x]=tr[x*2+1]+tr[x*2];
}
void upd(int p,int l,int r,int lx,int rx){//修改操作
    if(!tr[p]) return ; // 如果区间内没有出度为0的节点，直接返回
    if(l>=lx&&r<=rx){
        tr[p]=0;
        tag[p]=1;
        return ;
    }
    p_b(p,l,r);
    int mid=(l+r)/2;
    if(lx<=mid) upd(p*2,l,mid,lx,rx);
    if(rx>=mid+1) upd(p*2+1,mid+1,r,lx,rx);
    tr[p]=tr[p*2+1]+tr[p*2];
}
// 区间查询: 查询[xl,xr]内出度为0的节点数量
int query(int x,int l,int r,int xl,int xr){
    if(xl<=l&&xr>=r){
        return tr[x];
    }
    p_b(x,l,r);
    int mid=(l+r)/2,ans=0;
    if(xl<=mid){
        ans+=query(x*2,l,mid,xl,xr);
    }
    if(xr>mid){
        ans+=query(x*2+1,mid+1,r,xl,xr);
    }
    return ans;
}
signed main(){
    cin>>n>>m;    
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        while(x--) {
            int y;
            cin>>y;
            a[y]=1; //节点y有观察对象，出度不为0
        }
    }
    build(1,1,n); // 构建线段树
    while(m--){
        int op,l,r;
        cin>>op>>l>>r;
        if(op==1){
            int res=0;
            if(l>1) res+=query(1,1,n,1,l-1); // 查询[1,l-1]
            if(r<n) res+=query(1,1,n,r+1,n); // 查询[r+1,n]
            cout<<res<<endl;
        }else{
            int x;
            cin>>x;
            upd(1,1,n,l,r);// 将[l,r]内所有节点的出度设为非0
        }
    }
}
```

~~码风较丑，不喜勿喷~~

---

## 作者：Charles_with_wkc (赞：0)

# 前言
这道题目，实在没看懂，还是老师讲的。
# 思路
一开始我们假设所有人都没有听到老师的指令，那么在操作以后就有了，这你考虑如果当前这个人没有观察者，结合题中思考分析得出所有观察对象都在自己前面，那么只要这个人没有观察对象，他就需要知道。  

于是，这道题目转换成了一个求区间没有观察者的题目，我们把有观察者的人记作 $0$，没有的记作 $1$，便于统计。所以，本题就是在求区间内有多少 $1$。  

当然，对于操作 $1$，查询是 $getsum(1,l-1)$ 和 $getsum(r+1,n)$，为什么呢。因为 $[l,r]$，这个区间所有人都知道了就不需要统计了。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N=5e5+5;
struct segtree{
	int s,lay;
}seg[N<<2];
int n,m,op,op1,op2,op3;
bool have[N];
void pushup(int u){
	seg[u].s=seg[u<<1].s+seg[u<<1|1].s;
	return ;
}
void pushdown(int u){
	if(seg[u].lay==0) return ;
	seg[u<<1].lay=seg[u<<1|1].lay=1;
	seg[u<<1].s=seg[u<<1|1].s=0;
	seg[u].lay=0;
	return ;
}
void build(int u,int l,int r){
	seg[u].s=1;
	seg[u].lay=0;
	if(l==r){
		seg[u].s=!have[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	pushup(u);
	return ;
}
void update(int u,int l,int r,int ql,int qr){
	if(ql>r||qr<l) return ;
	if(ql<=l&&r<=qr){
		seg[u].lay=1;
		seg[u].s=0;
		return ;
	}
	pushdown(u);
	int mid=(l+r)>>1;
	if(ql<=mid) update(u<<1,l,mid,ql,qr);
	if(mid<qr) update(u<<1|1,mid+1,r,ql,qr);
	pushup(u);
	return ;
}
int getsum(int u,int l,int r,int ql,int qr){
	if(ql>r||qr<l||ql>qr) return 0;
	if(ql<=l&&r<=qr) return seg[u].s;
	pushdown(u);
	int mid=(l+r)>>1,sum=0;
	if(ql<=mid) sum+=getsum(u<<1,l,mid,ql,qr);
	if(mid<qr) sum+=getsum(u<<1|1,mid+1,r,ql,qr);
	return sum;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>op;
		for(int j=1;j<=op;j++){
			cin>>op1;
			have[op1]=1;
		}
	}
	build(1,1,n);
	while(m--){
		cin>>op>>op1>>op2;
		if(op==1) cout<<getsum(1,1,n,1,op1-1)+getsum(1,1,n,op2+1,n)<<endl;
		else{
			cin>>op3;
			update(1,1,n,op1,op2);
		}
	}
	return 0;
}
```

---

## 作者：chaqjs (赞：0)

## 思路

先考虑操作一。若编号在 $[L,R]$ 范围内的人（我们记为集合 $A$）听见了老师的指示，那么观察 $A$ 的人（我们记为集合 $B$）会跟着执行指令，而观察 $B$ 的人也会执行指令……这样以此类推，我们会发现，只要有观察者的人都会执行指令。

那答案即为没有观察者的人（也就是谁也不看、自己闷头跑的人）的数量。

我们把有观察者的人记为 $0$，无观察者的人记为 $1$，答案即为 $[1,L-1]$ 和 $[r+1,n]$ 中 $1$ 的数量。

这样一来，操作二很简单了。只要把 $[L,R]$ 中 $1$ 全部变为 $0$ 即可，也就是区间推平。

用线段树维护。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define ls rt << 1
#define rs rt << 1 | 1
#define lson ls, l, mid
#define rson rs, mid + 1, r
#define root 1, 1, n

const int N = 3e5 + 5;

int n, q;
bool w[N];  // 记录每个点是否观察别人

struct Tree {
    int sum;
    int add;  // 懒标记，为 1 表示需要区间推平
};
Tree t[N << 2];

// 设置标记
void maketag(int rt, int l, int r) {
    t[rt].sum = 0;
    t[rt].add = 1;
}

// 标记下传
void pushdown(int rt, int l, int r) {
    if (!t[rt].add)
        return;
    int mid = (l + r) >> 1;
    maketag(lson);
    maketag(rson);
    t[rt].add = 0;
}

// 更新节点
void pushup(int rt) {
    t[rt].sum = t[ls].sum + t[rs].sum;
}

// 建树
void build(int rt, int l, int r) {
    t[rt].add = 0;
    if (l == r) {
        t[rt].sum = !w[l];  // 有观察者的人记为 0，无观察者的人记为 1
        return;
    }
    int mid = (l + r) >> 1;
    build(lson);
    build(rson);
    pushup(rt);
}

// 查询
int query(int rt, int l, int r, int nowl, int nowr) {
    if (nowl <= l && r <= nowr)
        return t[rt].sum;
    pushdown(rt, l, r);
    int mid = (l + r) >> 1, res = 0;
    if (nowl <= mid)
        res += query(lson, nowl, nowr);
    if (nowr > mid)
        res += query(rson, nowl, nowr);
    return res;
}

// 区间推平
void update(int rt, int l, int r, int nowl, int nowr) {
    if (nowl <= l && r <= nowr) {
        maketag(rt, l, r);
        return;
    }
    pushdown(rt, l, r);
    int mid = (l + r) >> 1;
    if (nowl <= mid)
        update(lson, nowl, nowr);
    if (nowr > mid)
        update(rson, nowl, nowr);
    pushup(rt);
}

int main() {
    scanf("%d%d", &n, &q);

    for (int i = 1; i <= n; i++) {
        int cnt;
        scanf("%d", &cnt);
        while (cnt--) {
            int obs;
            scanf("%d", &obs);
            w[obs] = true;
        }
    }

    build(root);

    while (q--) {
        int op;
        scanf("%d", &op);
        if (op == 1) {
            int L, R;
            scanf("%d%d", &L, &R);
            int ans = 0;
            if (L > 1)
                ans += query(root, 1, L - 1);
            if (R < n)
                ans += query(root, R + 1, n);
            printf("%d\n", ans);
        } else {
            int L, R, x;
            scanf("%d%d%d", &L, &R, &x);
            update(root, L, R);
        }
    }
    return 0;
}
```

---

## 作者：critnos (赞：0)

线段树板子了，区间推平 $0$ 区间求和。

好恶心啊，，tag 习惯变 $0$，然后这道题因为有 $0$ 所以不行。。。

最后说说自己的想法：手写平衡树维护珂朵莉树区间长度和或许可以做到随机数据单次操作 $O(\log\log n)$？即只维护极长连续段为 $1$ 的，然后对于区间查询直接求 $[l,r]$ 内的极长连续段长度和（边角分类讨论）。复杂度在最差数据下似乎都是对的 $O(\log n)$。。。

---

UPD：次天想到一种树状数组做法。

原本树状数组可能很难（？维护区间推平操作，但是这题有个很好的性质：区间推平的是 $0$。这就意味着对于每个数只用操作一次（因为 $0$ 对区间和没有影响）。这就意味着可以把区间所有的 $1$ 提取出来然后树状数组暴力修改。

因为每个数最多被操作 $1$ 次，所以修改的总复杂度为 $O(n\log n)$，均摊下来每次修改操作 $O(\log n)$。至于查询操作直接上求和严格 $O(\log n)$。

如何取出区间中所有的 $1$?这个用个并查集就好了。

关键代码：

```cpp
w=f[n+1]=n+1;
	for(i=n;i>=1;i--)
		f[i]=w=(a[i]=!a[i])?i:w;
	for(i=1;i<=n;i++)
		bit[i]=(pre[i]=pre[i-1]+a[i])-pre[i-lowbit(i)];
	sum=pre[n];
	while(m--)
	{
		opt=read(),l=read(),r=read();
		if(opt==2)
		{
			for(read(),i=find(l);i<=r;i=find(i))
				sum--,add(i,-1),f[i]=find(f[i+1]);
		}
		else
			printf("%d\n",sum-(ask(r)-ask(l-1)));
	}
```

好写好记常数小哟~

---


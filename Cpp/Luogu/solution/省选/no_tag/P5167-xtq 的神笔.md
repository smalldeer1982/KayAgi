# xtq 的神笔

## 题目背景

xtq 在小学四年级的时候得到了一套神奇的画笔。为了测试神笔的威力（以及展现自己过人的艺术天赋），他决定先为美术老师临摹几幅画。

## 题目描述

每幅画的形态可以抽象为排成一列的 $n$ 个格子，其中第 $i$ 个格子具有一个权值 $a_i$。

xtq 有足够多不同颜色的画笔，每当他使用一根笔，他可以在格子上画下至少长度为 $k$ 的连续一段，然后再换另一根笔从下一个格子继续画，其中 $k<n$。

美术老师为了考验 xtq 的绘画功力，为他设置了一些挑战。

他可以从 $1$ 到 $k$ 的任意一个格子开始画到编号为 $n$ 的格子，其中从第 $i$ 个格子开始会获得 $b_i$ 的得分。

假设 xtq 使用同一根画笔，从编号为 $i$ 的格子连续地画到编号为 $j$ 的格子，他就会获得（$a_i \mathbin{\mathrm{or}} a_{i+1} \mathbin{\mathrm{or}} a_{i+2} \mathbin{\mathrm{or}} \cdots \mathbin{\mathrm{or}} a_j) + (a_i \mathbin{\mathrm{and}} a_{i+1} \mathbin{\mathrm{and}} a_{i+2} \mathbin{\mathrm{and}} \cdots \mathbin{\mathrm{and}} a_j) + \gcd(a_i, a_{i+1}, a_{i+2}, \ldots, a_j)$ 的分数，其中 $\gcd$ 代表最大公约数。

现在，xtq 希望找到一种安排画笔使用的方案，使得对于每一幅需要临摹的画，他总共获得的分数尽量多。

## 说明/提示

样例解释：

xtq 可以从 $1$ 开始，获得 $6$ 分初始得分；第一段画 $[1,2]$，获得 $5$ 分；第二段画 $[3,4]$，获得 $10$ 分；第三段画 $[5,6]$，获得 $10$ 分。共 $31$ 分。

对于 $20\%$ 的数据，$n\le 10$。  
对于 $40\%$ 的数据，$n\le 3000$。  
对于 $70\%$ 的数据，$n\le 30000$。  
对于 $100\%$ 的数据，$1\le k<n\le 3 \times {10}^5$，$T\le 10$，$1\le a_i\le 2^{30}$，$-2^{30}\le b_i\le 2^{30}$。

数据有梯度，应该不太卡常。

## 样例 #1

### 输入

```
1
6 2
3 1 4 5 6 2
6 -2
```

### 输出

```
31
```

# 题解

## 作者：Caro23333 (赞：1)

### 20pts:
枚举从哪里开始以及每一笔的结束位置，统计答案。

### 40pts:
约定：

$or[i,j] = a_i$ $or$ $a_{i+1}$ $or$ $...$ $or$ $a_j$

$and[i,j] = a_i$ $and$ $a_{i+1}$ $and$ $...$ $and$ $a_j$ 

$gcd[i,j] = gcd(a_i, a_{i+1}, a_{i+2}, ... , a_j)$

设$f[i]$为画到$i$为止可以获得的最大分数，
则显然有转移：

$f[i] = max\{f[j-1]+or[i,j]+and[i,j]+gcd[i,j]\}$
其中$j\le i$。
遍历$i$和$j$进行dp可以获得这一部分分。

### 70pts:
观察到一个重要性质：

若区间$[p,q]$包含于$[r,s]$,则有：

$or[p,q]\le or[r,s]$

$and[r,s]\le and[p,q]$

$gcd[r,s]\le gcd[p,q]$

如果我们固定一个右端点$q$并且从大到小遍历左端点$p$，并且设每个格子的分数范围在$[0,k]$中，那么$or[p,q],and[p,q],gcd[p,q]$都会持续不严格地递增\递减，
**并且在递增\递减$O(logk)$次之后就会达到一个最大\最小值不再改变**。

这是不难证明的：

对于$or$和$and$，由于每次变化都会改变其一个二进制位，所以最多将每个二进制位都改变一次，也就是总共改变$O(logk)$次。

对于$gcd$，每次变化之后的值都是之前值的一个因数，必然是不超过之前值的一半的，所以最多变化$O(logk)$次就会达到$1$。

**这也就意味着，对于每一个状态$f[i]$，我们可以把$i$之前的决策点分成至多$O(logk)$段，使得对于每一段，任意属于这一段的$j_1,j_2$，有$or[j_1,i]=or[j_2,i],and[j_1,i]=and[j_2,i],gcd[j_1,i]=gcd[j_2,i]$**。

那么对于每一个$i$，二分查找出前面每一段的左右端点，然后对于每一段内使用数据结构查询$f$的最大值进行转移。

复杂度分析：
一共枚举$O(n)$个待转移的状态，每个状态需要找出$O(logk)$段，每一段需要$O(logn)$时间找出。由于求区间$gcd$在最坏情况下需要$O(logk)$的复杂度，所以总共的复杂度上界是$O(nlognlog^2k)$。

事实上，由于这个上界十分宽松，这样的算法应该可以获得接近满分或者满分。

### 100pts:

我们每次都要重新二分找出段落，这是十分浪费时间的。

事实上，每次计算出一个$f[i]$，我们需要加入可用决策点的只有$i$一个位置。
而且我们不难想到，对于$f[i]$的决策点分出的每一段，在$f[i+1]$情况下的分段中必然不会被拆成多个小段，而只可能和其他相邻的段落合并成一个大的段落。

所以，我们从始至终只需要维护当前决策点的分段即可。每次计算出$f[i]$后，将$[i,i]$作为新的一段加入，然后遍历每一段，判断在$f[i+1]$的情况下相邻两段的$or,and,gcd$值是否都相同，如果相同就进行合并。

每一段除了维护$or,and,gcd$以外，还需要维护当前段的最大$f$值，这样我们在转移时对于每一段只需要$O(1)$时间来查询当前段的最优决策点进行转移。

此外，std中使用了st表来维护区间的$or,and,gcd$值，这样的话区间合并就可以做到$O(logk)$。

复杂度分析：

预处理st表：$O(nlognlogk)$

维护决策点段落：由于每一时刻至多有$O(logk)$段，所以总复杂度是$O(nlog^2k)$

转移：总的转移复杂度显然是$O(nlogk)$的。

总复杂度的上界为$O(nlog^2k)$。这个上界也比较宽松，可以通过此题。

此题完结。

代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <ctime>

using namespace std;
const int MAXN = 300005;
typedef long long ll;
int n,k,a[MAXN],bin[MAXN<<1];
inline int gcd(int a, int b)
{
    int c;
    while(b)
    {
        c = a;
        a = b;
        b = c%b;
    }
    return a;
}
int sto[MAXN][19],sta[MAXN][19],stg[MAXN][19];
inline int queyro(int l, int r)
{
    int kk = bin[r-l+1];
    return sto[l][kk]|sto[r-(1<<kk)+1][kk];
}
inline int querya(int l, int r)
{
    int kk = bin[r-l+1];
    return sta[l][kk]&sta[r-(1<<kk)+1][kk];
}
inline int queryg(int l, int r)
{
    int kk = bin[r-l+1];
    return gcd(stg[l][kk],stg[r-(1<<kk)+1][kk]);
}
ll f[MAXN];
struct Node
{
    ll val1,val2,val3,maxf;
}pool[MAXN];
int tot,front = 0, rear = 0;
int nxt[MAXN],lst[MAXN];
inline void insert(Node t)
{
    pool[++tot] = t;
    nxt[rear] = tot, lst[tot] = rear;
    rear = tot;
    nxt[rear] = -1;
}
inline void remove(int pos)
{
    nxt[lst[pos]] = nxt[pos];
    if(pos!=rear) lst[nxt[pos]] = lst[pos];
    if(pos==rear) rear = lst[pos];
}
inline int read()
{
    char c = 0;
    int res = 0, flag = 1;
    while(c<'0'||c>'9')
    {
        c = getchar();
        if(c=='-') flag = -1;
    }
    while(c>='0'&&c<='9')
    {
        res = res*10+c-'0';
        c = getchar();
    }
    return res*flag;
}
inline void init()
{
    tot = 0;
    front = rear = 0;
    memset(nxt,0,sizeof(nxt));
    memset(lst,0,sizeof(lst));
    for(int i = 0; i<MAXN; i++)
        f[i] = -(1ll<<62);
    nxt[0] = -1;
}

int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        init();
    	cin >> n >> k;
    	for(int i = 1; i<=n; i++)
        	a[i] = read();
    	for(int i = 1; i<=k; i++)
        	f[i-1] = read();
    	for(int cnt = 0, i = 1; i<=n; i <<= 1, cnt++)
        	for(int j = i; j<(i<<1); j++)
            	bin[j] = cnt;
    	for(int i = 1; i<=n; i++)
        	sto[i][0] = sta[i][0] = stg[i][0] = a[i];
    	for(int j = 1; (1<<j)<=n; j++)
        	for(int i = 1; i+(1<<j)-1<=n; i++)
        	{
            	sto[i][j] = sto[i][j-1]|sto[i+(1<<(j-1))][j-1];
            	sta[i][j] = sta[i][j-1]&sta[i+(1<<(j-1))][j-1];
            	stg[i][j] = gcd(stg[i][j-1],stg[i+(1<<(j-1))][j-1]); 
        	}
    	Node tmpnode;
    	for(int i = k; i<=n; i++)
    	{
        	int tmppos = nxt[front];
        	while(tmppos>=0)
        	{
            	pool[tmppos].val1 |= a[i];
            	pool[tmppos].val2 &= a[i];
            	pool[tmppos].val3 = gcd(pool[tmppos].val3,a[i]);
            	tmppos = nxt[tmppos];
            }
        	tmpnode.val1 = queyro(i-k+1,i);
        	tmpnode.val2 = querya(i-k+1,i);
        	tmpnode.val3 = queryg(i-k+1,i);
        	tmpnode.maxf = f[i-k];
        	insert(tmpnode);
        	tmppos = nxt[front];
        	while(nxt[tmppos]>=0&&tmppos>=0)
        	{
            	if(pool[nxt[tmppos]].val1==pool[tmppos].val1&&
               	   pool[nxt[tmppos]].val2==pool[tmppos].val2&&
                   pool[nxt[tmppos]].val3==pool[tmppos].val3)
            	{
                	pool[tmppos].maxf = max(pool[tmppos].maxf,pool[nxt[tmppos]].maxf);
                    remove(nxt[tmppos]);
            	}
                tmppos = nxt[tmppos];
            }
            tmppos = nxt[front];
            while(tmppos>=0)
            {
            	f[i] = max(f[i],pool[tmppos].maxf+pool[tmppos].val1+
                                pool[tmppos].val2+pool[tmppos].val3);
            	tmppos = nxt[tmppos];
        	}
        }
    	cout << f[n] << endl;
    }
    return 0;
}
```

---

## 作者：1saunoya (赞：1)

草，调了半天原来是一个小细节错误。。

先考虑这个普通方程怎么写。

$f_i =\max\{ {f_{j-1} + [or] + [and] + [\gcd]}\}$。


考虑三个的性质，只会变化 $\log$ 次，我们把变化的位置存下来，然后最多会有 $3 \log$ 个位置。

$b_i$ 的作用是让 $f_{i-1} = b_{i}$。

然后枚举这些位置的之间的区间，然后区间最大值，更新到 $f_i$，然后用 $f_i$ 更新到线段树即可。

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x,I=y+1;i<I;++i)
#define per(i,x,y) for(int i=x,I=y-1;i>I;--i)
using namespace std;
using ll=long long;
void cmax(int&x,const int&y){x=x>y?x:y;}
void cmax(ll&x,const ll&y){x=x>y?x:y;}
void cmin(int&x,const int&y){x=x<y?x:y;}
template<class T>istream&operator>>(istream&in,vector<T>&V){for(auto&x:V)in>>x;return in;}
template<class T>ostream&operator<<(ostream&out,const vector<T>&V){for(auto x:V)out<<x<<' ';return out;}
template<class T>void sort(vector<T>&V){sort(V.begin(),V.end());}
template<class T>void reverse(vector<T>&V){reverse(V.begin(),V.end());}
template<class T>int SZ(const vector<T>&V){return (int)V.size();}
void debug(){cerr<<"whxorz"<<' ';}
void debug(int x){debug();cerr<<x<<'\n';}
void debug(char x){debug();cerr<<x;}
int n,k;
const int N=3e5+10;
const ll LOW=-1e18;
int a[N];
int st1[40],top1;
int st2[40],top2;
int st3[40],top3;
ll f[N],mx[N<<2];
void build(int l,int r,int p){mx[p]=LOW;if(l==r)return;int mid=l+r>>1;build(l,mid,p<<1);build(mid+1,r,p<<1|1);}
//void up(const int&p){cmax(mx[p]=mx[p<<1],mx[p<<1|1]);}
void upd(int l,int r,int p,const int&x,const ll&v){
	cmax(mx[p],v);if(l==r)return;
	int mid=l+r>>1;if(x<=mid)upd(l,mid,p<<1,x,v);else upd(mid+1,r,p<<1|1,x,v);
//	up(p);
}
ll query(const int&ql,const int&qr,int l,int r,int p){
	if(ql>qr)return LOW;
	if(ql<=l&&r<=qr){return mx[p];}
	int mid=l+r>>1;ll res=LOW;
	if(ql<=mid)res=query(ql,qr,l,mid,p<<1);
	if(qr>mid)cmax(res,query(ql,qr,mid+1,r,p<<1|1));
	return res;
}
int p[40],tp;
using pii=pair<int,int>;
pii q[120];
//bool check(int*f,int sz){rep(i,2,sz)if(f[i-1]>f[i])return false;return true;}
void get(const int&id,const int&v,ll&res){
	int nv=v;p[tp=1]=id;
	per(i,top1,1){if((nv|a[st1[i]])==nv)continue;p[++tp]=st1[i];nv|=a[st1[i]];}
	top1=0;//per(i,tp,1)st1[++top1]=p[i];
	while(tp)st1[++top1]=p[tp--];//assert(check(st1,top1));
	
	nv=v;p[tp=1]=id;
	per(i,top2,1){if((nv&a[st2[i]])==nv)continue;p[++tp]=st2[i];nv&=a[st2[i]];}
	top2=0;//per(i,tp,1)st2[++top2]=p[i];
	while(tp)st2[++top2]=p[tp--];//assert(check(st2,top2));
	
	nv=v;p[tp=1]=id;
	per(i,top3,1){if(__gcd(nv,a[st3[i]])==nv)continue;p[++tp]=st3[i];nv=__gcd(nv,a[st3[i]]);}
	top3=0;//per(i,tp,1)st3[++top3]=p[i];
	while(tp)st3[++top3]=p[tp--];//assert(check(st3,top3));
	
	tp=0;
	rep(i,1,top1)q[++tp]=pii(st1[i],1);
	rep(i,1,top2)q[++tp]=pii(st2[i],2);
	rep(i,1,top3)q[++tp]=pii(st3[i],3);
	
	sort(q+1,q+tp+1);int ov=v,av=v,gv=v;
	const int pos=id-k+1;
	per(i,tp,1){
		int val=a[q[i].first];
		if(q[i].second==1)ov|=val;if(q[i].second==2)av&=val;if(q[i].second==3)gv=__gcd(gv,val);
		if(q[i-1].first<=q[i].first-1)cmax(res,query(q[i-1].first,min(q[i].first-1,pos-1),0,n,1)+ov+av+gv);
	}
}
//#define clr(x) memset(x,0,sizeof(x))
void solve(){
	tp=top1=top2=top3=0;build(0,n,1);
	rep(i,k,n)f[i]=LOW;rep(i,0,k-1)upd(0,n,1,i,f[i]);rep(i,1,n){get(i,a[i],f[i]);upd(0,n,1,i,f[i]);}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(NULL);
//	freopen("3.in","r",stdin);
	int test;cin>>test;
	while(test--){cin>>n>>k;rep(i,1,n)cin>>a[i];rep(i,0,k-1)cin>>f[i];solve();cout<<f[n]<<'\n';}
	return 0;
}
```

---


# xtq的异或和

## 题目背景

xtq在六年级的时候开始大量研究离散数学。这一天，他正在对着一张密密麻麻的图思索。

## 题目描述

xtq有一张$n$个点，$m$条边的无向连通图。第$i$条边连接$s_i,t_i$，权值为$w_i$。不保证无重边或自环。

xtq认为，如果存在一条从$u$出发，到$v$结束的路径，使得所有**被这条路径恰经过奇数次的边**的权值的异或和为$x$，那么点对$(u,v)$关于$x$是巧妙的。

现在，xtq问了你$q$个问题，每次询问有多少个不同的点对$(u,v)$关于$x$是巧妙的。注意$u$可以等于$v$，且如果$u \neq v$那么$(u,v)$与$(v,u)$是不同的。



## 说明/提示

##样例解释1

关于$0$巧妙的点对：

$(1,1): 1 \Rightarrow 2 \Rightarrow 1$，$(2,2),(3,3)$类似；$(1,2): 1 \Rightarrow 2$，$(2,1)$类似

关于$1$巧妙的点对：

$(2,3):2 \Rightarrow 3$，$(3,2)$类似；$(1,3):1 \Rightarrow 2 \Rightarrow 3$，$(3,1)$类似

关于$2$巧妙的点对：与$1$类似

##数据范围

|  测试点编号|$n$  |$m$  |      $\, w_i,x,q-1$  |       特殊限制  |
| ----------- | ----------- | ----------- | --------------- | ----------- |
|1  |$\le 5$  |$\le 10$  |$< 4$  | 无  |
|2  |$\le 10$  |$\le 50$  |$< 8$  | 无  |
|3  |$\le 100$  |$= n-1$  |$< 128$  | 是一棵树  |
|4  |$\le 100$  |$\le 500$  |$< 128$  | 无  |
|5  |$\le 1000$  |$= n-1$  |$< 1024$  | 是一棵树  |
|6  |$\le 1000$  |$\le 5000$  |$< 1024$  | 无  |
|7  |$\le 100000$  |$\le 300000$  |$< 1024$  | 无  |
|8  |$\le 100000$  |$\le 300000$  |$< 1024$  | 无  |
|9  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|10  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|11  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|12  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|13  |$\le 100000$  |$\le n+11$  |$< 262144$  | 无  |
|14  |$\le 100000$  |$\le n+11$  |$< 262144$  | 无  |
|15  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|16  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|17  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|18  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|19  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|20  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |

对于100%的数据，$1\le n\le 10^5,n-1\le m\le 3*10^5,0\le w_i,x< 262144,0\le q\le 262144$


## 样例 #1

### 输入

```
3 3 3
1 2 0
2 3 1
3 1 2
0
1
2```

### 输出

```
5
4
4```

## 样例 #2

### 输入

```
4 3 2
1 2 1
2 3 6
2 4 7
6
7```

### 输出

```
4
4```

# 题解

## 作者：Memory_of_winter (赞：5)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10268704.html)

**题目大意：**给你一张$n(n\leqslant10^5)$个点$m(m\leqslant3\times10^5)$条边的无向图，每条边有一个权值，$q(q\leqslant2^{18})$次询问，每次询问给你一个$x(x<2^{18})$，问有多少个有序点对$(u,v)$，满足有一条$u$到$v$的路径异或和为$x$

**题解：**先建一棵生成树，把图中所有环丢进线性基，发现一条$u->v$的路径就是树上$u->v$的距离异或上一些环。

发现$x<2^{18}$，所以可以把线性基中所有可以表示出来的数求出来为集合$S$，令多项式$A(x)$，满足$[x^n]A(x)=\sum\limits_{i=1}^n[dis_i=n]$；令多项式$B(x)$，满足$[x^n]B(x)=[n\in S]$，$dis_i$表示第$i$个点到根的路径异或值

然后答案就是$A*A*B$，$*$表示异或卷积



**C++ Code：**

```cpp
#include <cstdio>
#include <iostream>
#define maxn 100010
#define maxm 300010
#define N 262144
const int mod = 998244353;

int head[maxn], cnt;
struct Edge {
	int to, nxt, w;
} e[maxm << 1];
inline void addedge(int a, int b, int c) {
	e[++cnt] = (Edge) { b, head[a], c }; head[a] = cnt;
	e[++cnt] = (Edge) { a, head[b], c }; head[b] = cnt;
}

long long A[N], B[N];
namespace Base {
#define M 18
	int p[M + 1];
	inline void insert(int x) {
		for (int i = M; ~i; --i) if (x >> i & 1) {
			if (p[i]) x ^= p[i];
			else { p[i] = x; break; }
		}
	}
	void dfs(int dep, int val) {
		if (dep > M) {
			++B[val];
			return ;
		}
		dfs(dep + 1, val);
		if (p[dep]) dfs(dep + 1, val ^ p[dep]);
	}
#undef M
}

int n, m, q;
int dis[maxn];
bool vis[maxn];
void dfs(int u, int fa = 0) {
	vis[u] = true;
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (!vis[v]) {
			dis[v] = dis[u] ^ e[i].w;
			dfs(v, u);
		} else Base::insert(dis[u] ^ dis[v] ^ e[i].w);
	}
}

const int lim = N;
inline void FWT(long long *A) {
	for (register int mid = 1; mid < lim; mid <<= 1)
		for (register int i = 0; i < lim; i += mid << 1)
			for (register int j = 0; j < mid; ++j) {
				const long long X = A[i + j], Y = A[i + j + mid];
				A[i + j] = X + Y, A[i + j + mid] = X - Y;
			}
}

int main() {
	std::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0);
	std::cin >> n >> m >> q;
	for (int i = 0, a, b, c; i < m; ++i) {
		std::cin >> a >> b >> c;
		addedge(a, b, c);
	}
	dfs(1), Base::dfs(0, 0);
	for (int i = 1; i <= n; ++i) ++A[dis[i]];
	FWT(A), FWT(B);
	for (int i = 0; i < lim; ++i) A[i] = A[i] * A[i] * B[i];
	FWT(A);
	for (int i = 0; i < lim; ++i) A[i] >>= 18;
	while (q --> 0) {
		static int x;
		std::cin >> x;
		std::cout << A[x] % mod << '\n';
	}
	return 0;
}

```



---

## 作者：q234rty (赞：4)

emmm这题其实不用线性基。

大致做法当然还是一样的。

做过[P4151](https://www.luogu.org/problemnew/show/P4151)的人都知道只要dfs出一棵生成树，把所有只含有一条非树边的简单环的权值拿出来，那么$(u,v)$关于$x$巧妙的条件就是$d(u) \oplus d(v)\oplus x$（其中$d(u)$表示$u$到根的路径的权值异或和）与这些环权值的某个子集的异或和相等。

窝萌可以直接维护$a_i$表示i是否与某个异或和相等，插入$x$时如果$a_x=1$则不插入，否则直接暴力插入，注意到每次暴力插入时$a_i$与$a_{i\oplus x}$不可能同时$=1$，集合的大小一定至少翻倍，于是这一部分时间复杂度为$O(w_i \log w_i)$

然后直接`FWT`求答案即可，总复杂度为$O(n+w_i \log w_i)$

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXSIZE=10000020;
int bufpos;
char buf[MAXSIZE];
#define NEG 0
void init(){
    #ifdef LOCAL
        freopen("5169.txt","r",stdin);
    #endif
    buf[fread(buf,1,MAXSIZE,stdin)]='\0';
    bufpos=0;
}
#if NEG
int readint(){
    bool isneg;
    int val=0;
    for(;!isdigit(buf[bufpos]) && buf[bufpos]!='-';bufpos++);
    bufpos+=(isneg=buf[bufpos]=='-');
    for(;isdigit(buf[bufpos]);bufpos++)
        val=val*10+buf[bufpos]-'0';
    return isneg?-val:val;
}
#else
int readint(){
    int val=0;
    for(;!isdigit(buf[bufpos]);bufpos++);
    for(;isdigit(buf[bufpos]);bufpos++)
        val=val*10+buf[bufpos]-'0';
    return val;
}
#endif
char readchar(){
    for(;isspace(buf[bufpos]);bufpos++);
    return buf[bufpos++];
}
int readstr(char* s){
    int cur=0;
    for(;isspace(buf[bufpos]);bufpos++);
    for(;!isspace(buf[bufpos]);bufpos++)
        s[cur++]=buf[bufpos];
    s[cur]='\0';
    return cur;
}
char obuf[MAXSIZE];
int opos;
void write(int x){
    if (x>=10)
        write(x/10);
    obuf[opos++]=x%10+'0';
}
void writeln(int x,char c='\n'){
    write(x);
    obuf[opos++]=c;
}
const int mod=998244353;
const int maxn=100002;
const int maxm=600002;
const int maxv=1<<18;
void fwt(ll *a,int l,int r){
    if (l==r)
        return;
    int mid=(l+r)/2;
    fwt(a,l,mid);
    fwt(a,mid+1,r);
    for(int i=l,j=mid+1;i<=mid;i++,j++){
        ll x=a[i],y=a[j];
        a[i]=x+y;
        a[j]=x-y;
    }
}
struct graph{
    int n,m;
    struct edge{
        int to,cost,next;
    }e[maxm];
    int first[maxn];
    void addedge(int from,int to,int cost){
        e[++m]=(edge){to,cost,first[from]};
        first[from]=m;
    }
    ll a[maxv];
    void add(int x){
        if (a[x])
            return;
        a[x]=1;
        for(int i=0;i<maxv;i++)
            a[i^x]|=a[i];
    }
    int d[maxn];
    bool vis[maxn];
    void dfs(int u,int fa){
        vis[u]=1;
        for(int i=first[u];i;i=e[i].next){
            int v=e[i].to;
            if (v==fa)
                continue;
            if (vis[v])
                add(d[u]^d[v]^e[i].cost);
            else d[v]=d[u]^e[i].cost,dfs(v,u);
        }
    }
    ll cnt[maxv];
    void work(){
        a[0]=1;
        dfs(1,0);
        // puts("WTF");
        for(int i=1;i<=n;i++)
            cnt[d[i]]++;
        fwt(cnt,0,maxv-1);
        fwt(a,0,maxv-1);
        for(int i=0;i<maxv;i++)
            a[i]=a[i]*cnt[i]*cnt[i];
        fwt(a,0,maxv-1);
        for(int i=0;i<maxv;i++)
            a[i]=(a[i]>>18)%mod;
    }
}g;
int main(){
    init();
    int n=readint(),m=readint(),q=readint();
    g.n=n;
    while(m--){
        int u=readint(),v=readint(),w=readint();
        g.addedge(u,v,w);
        g.addedge(v,u,w);
    }
    g.work();
    while(q--)
        writeln(g.a[readint()]);
    fwrite(obuf,1,MAXSIZE,stdout);
}
```

---


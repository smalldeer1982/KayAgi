# 传球

## 题目背景

临近中考，pG的班主任决定上一节体育课，放松一下。

题解：https://blog.csdn.net/kkkksc03/article/details/85008120

## 题目描述

老师带着 pG 的同学们一起做传球游戏。

游戏规则是这样的： $n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

pG 提出一个有趣的问题：有多少种不同的传球方法可以使得从 pG 手里开始传的球，传了 $m$ 次以后，又回到 pG 手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、 $2$ 号、 $3$ 号，并假设 pG 为 $1$ 号，球传了 $3$ 次回到pG手里的方式有 $1 \to 2 \to 3 \to 1$ 和 $1 \to 3 \to 2 \to 1$ ，共$ 2$ 种。

## 说明/提示

对于8%的数据，$n \le 100,m \le 10^4$.

对于100%的数据，$n \le 3500,m \le 10^9$.

**数据有一定梯度。**


## 样例 #1

### 输入

```
3 3```

### 输出

```
2```

## 样例 #2

### 输入

```
30 30
```

### 输出

```
155117522```

## 样例 #3

### 输入

```
1234 12345678
```

### 输出

```
424074635```

# 题解

## 作者：ezoixx130 (赞：16)

我们设 $f[i][j]$ 表示 $i$ 次传球以后，球在 $j$ 手里的方案数。

容易得到转移式：$f[i][j]=f[i-1][(j-1+n)\bmod n]+f[i-1][(j+1)\bmod n]$

我们发现这是一个循环卷积的形式。

我们设有多项式 $A(x)=x+x^{n-1}$。

容易得到 $f_i(x)=f_{i-1}(x)\times A$。

这里的乘法是循环卷积，也就是说，把次数大于等于 $n$ 的项的系数挪到次数减去 $n$ 的项的系数上。

所以 $f_m(x)=f_0(x) \times A^m$。

我们只需要采用快速幂求出 $A^m$ 即可。

使用 NTT+CRT 或者 MTT 做多项式快速幂可以做到 $O(n\log n\log m)$ 的时间复杂度。

代码见：[https://www.luogu.org/paste/jeqlfiwz](https://www.luogu.org/paste/jeqlfiwz)

~~然而作者并不会MTT~~ 由于 MTT 太难写了，所以我们直接用暴力做多项式乘法，这样的时间复杂度是 $O(n^2 \log m)$ 的，只能得到 $60$ 分。

常数优化 1：多项式中某一项为 $0$ 就直接 `continue;` 得分 $68$。

常数优化 2：使用 `memset` 清 $0$，得分 $96$。

常数优化 3：把多项式的长度作为函数参数而不是全局变量传入多项式乘法中，得分 $100$。

这样写代码长度极短，并且异常好写。

代码：

```cpp
#pragma GCC optimize("Ofast,fast-math,unroll-loops")
#include <bits/stdc++.h>
using namespace std;

#define MAXN 10000
#define mod 1000000007
#define mul(a,b) ((long long)(a)*(b)%mod)

int n,m,a[MAXN],ans[MAXN];

inline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}

void polymul(int *a,int *b,int *c,int n)
{
    int tmp[MAXN];
    memset(tmp,0,sizeof(int)*n*2);
    for(int i=0;i<n;++i)
        if(a[i])
            for(int j=0;j<n;++j)
                tmp[i+j]=add(tmp[i+j],mul(a[i],b[j]));
    for(int i=0;i<n;++i)c[i]=tmp[i];
    for(int i=n;i<2*n;++i)c[i-n]=add(c[i-n],tmp[i]);
}

int main()
{
    scanf("%d%d",&n,&m);
    ++a[1];++a[n-1];
    ans[0]=1;
    while(m)
    {
        if(m&1)polymul(ans,a,ans,n);
        polymul(a,a,a,n);
        m>>=1;
    }
    printf("%d\n",ans[0]);
}
```

---

## 作者：ShineEternal (赞：10)

#### 思考难度：提高?
#### 代码难度：提高?
正解：**矩阵快速幂**

若令$f[i][j]$为第$i$次传传到第$j$个人的方案数，易知$$f[i][j]=f[i-1][j-1]+f[i-1][j+1]$$

但是直接这样递推$O(nm)$会$TLE$，于是想到用矩阵来加速递推。

可知初始矩阵中$ans[i][i]=1$，递推矩阵中$a[0][n-1]=a[n-1][0]=1$ $a[i][i+1]=a[i][i-1]=1$。进行快速幂即可，时间复杂度$O(n^3\times log\:m)$，时间、空间都不允许。

但是，我们通过观察发现，无论何时，矩阵都是循环的，即
$A=\begin{pmatrix} a_1 & a_2 & a_3 & \cdots & a_n \\ a_n & a_1 & a_2 & \cdots & a_{n-1} \\ a_{n-1} & a_n & a_1 & \cdots & a_{n-2} \\ \vdots & \vdots & \vdots & & \vdots \\ a_2 & a_3 & a_4 & \cdots & a_1 \\ \end{pmatrix}$

我们利用此性质。乘出矩阵的一行来，直接将其他的复制好，时间复杂度$O(n^2\times log\:m)$，时间复杂度符合要求，但空间超了。

于是我们将矩阵缩为一维，利用循环的性质来求值即可，空间复杂度将为$O(n)$，理论上可以通过本题，但还是TLE。(18.19点2500ms+)

再来观察矩阵，发现第一行是

$$a_1\;\;a_2\;\;a_3\;\;\cdots\;\;a_{\lfloor{\frac{n+1}{2}\rfloor}-1}\;\;a_{\lfloor{\frac{n+1}{2}\rfloor}}\;\;a_{\lfloor{\frac{n+1}{2}\rfloor}-1}\;\;\cdots\;\;a_3\;\;a_2$$

(偶数自行脑补)

即对称，所以可以优化一半常数。

但还是TLE。。。(18.19点**1500ms+**)

我们继续优化，发现矩阵相乘时，若有0，直接跳过，又优化了一点。(18.19点**950~1100ms**)

考虑观察一行，发现计算每一个的时候有重复计算的，我们发现可以用左面对称和右面对称来计算，还要考虑**n为奇数偶数情况**，及**i为奇数偶数**情况，可优化一半常数(理论上)。

于是就可以**700ms**通过本题了。(无$O_2\;\;O_3$)

### 当然
有大佬说有更优的算法，欢迎交流~

# code：
```cpp
#include<cstdio>
int n,m,u,v,r,p;
const int N=3505;
const int mod=1e9+7;
long long s[N],c[N],ans[N];
int main(){
    scanf("%d%d",&n,&m);
    s[n-1]=s[1]=ans[0]=1;
    r=n>>1;
    register int i,j;
    while(m){
        if(m&1){
        	for(i=0;i<=r;++i)c[i]=0;
        	for(i=0;i<=r;++i){
        		u=n-i;
        		for(j=u;j<n;++j)
        		if(ans[j-u]&&s[j])c[i]=(c[i]+ans[j-u]*s[j])%mod;
        		for(j=0;j<u;++j)
            	if(ans[i+j]&&s[j])c[i]=(c[i]+ans[i+j]*s[j])%mod;
            }
            for(i=0;i<=r;++i)ans[i]=c[i];
            for(i=r+1;i<n;++i)ans[i]=ans[n-i];
        }
        if(n&1){
        	for(i=0;i<=r;++i)c[i]=0;
            for(i=1;i<=r;++i)
            if(s[i])c[0]=(c[0]+s[i]*s[i])%mod; 
            c[0]=(c[0]*2+s[0]*s[0])%mod;
        	for(i=1;i<=r;++i){
        		u=(n-i)>>1,v=(n+n-i+1)>>1,p=n-i;
        		if(i&1){
        			for(j=0;j<u;++j)
        			if(s[j]&&s[i+j])c[i]=(c[i]+s[j]*s[i+j])%mod;
        			for(j=p+1;j<v;++j)
        			if(s[j]&&s[j-p])c[i]=(c[i]+s[j]*s[j-p])%mod;
        			c[i]=((c[i]<<1)+s[u]*s[u])%mod;
                }else{
                    for(j=0;j<=u;++j)
        			if(s[j]&&s[i+j])c[i]=(c[i]+s[j]*s[i+j])%mod;
        			for(j=p+1;j<v;++j)
        			if(s[j]&&s[j-p])c[i]=(c[i]+s[j]*s[j-p])%mod;
        			c[i]=((c[i]<<1)+s[v]*s[v])%mod;
                }
            }
            for(i=0;i<=r;++i)s[i]=c[i];
            for(i=r+1;i<n;++i)s[i]=s[n-i];
        }else{
            for(i=0;i<=r;++i)c[i]=0;
            for(i=1;i<r;++i)
            if(s[i])c[0]=(c[0]+s[i]*s[i])%mod; 
            c[0]=(c[0]*2+s[0]*s[0]+s[r]*s[r])%mod;
        	for(i=1;i<=r;++i)
            if(i&1^1){
                u=(n-i)>>1,v=(n+n-i+1)>>1,p=n-i;
    			for(j=0;j<u;++j)
    			if(s[j]&&s[i+j])c[i]=(c[i]+s[j]*s[i+j])%mod;
    			for(j=p+1;j<v;++j)
    			if(s[j]&&s[j-p])c[i]=(c[i]+s[j]*s[j-p])%mod;
    			c[i]=((c[i]<<1)+s[u]*s[u]+s[v]*s[v])%mod;
            }
            for(i=0;i<=r;++i)s[i]=c[i];
            for(i=r+1;i<n;++i)s[i]=s[n-i];
        }
        m>>=1;
    }
    printf("%lld",ans[0]);
}
```

---

## 作者：Network_Flow (赞：6)

本题蒟蒻调了几个小时才过（玄学做法），现在将思考过程奉上。

题意想必大家都很清楚了。

### SubTask $1.1$，8 pts
首先，我们可以推出一个极为简单的 dp 转移方程：

$$f_{i,j}=f_{i-1,j-1}+f_{i-1,j+1}$$

$f_{i,j}$ 表示当前秒数为 $i$，球在 $j$ 手上的方案数量。

时间复杂度/空间复杂度：$O(nm)$，肯定不能通过此题。

其实这个就是 [P1057 NOIP2008 普及组 传球游戏](https://www.luogu.com.cn/problem/P1057) 的做法。

### SubTask $1.2$，8 pts，矩阵快速幂优化

为什么还是 8pts？因为矩阵快速幂优化后复杂度也只能过 $8\%$ 的数据。

dp 的复杂度太高，我们都学过矩阵快速幂，它可以优化数列；

所以我们可以采用矩阵快速幂优化这个 dp 过程。

首先我们需要构造一个矩阵 $A$，用来加速数列。

我们的初始矩阵：
$$
Ans = 
\begin{bmatrix}
a_{i-1,1}\\
a_{i-1,2}\\
a_{i-1,3}\\
\cdots\\
a_{i-1,1}\\
\end{bmatrix}
$$

我们转移的目标矩阵：
$$
Ans = 
\begin{bmatrix}
a_{i,1}\\
a_{i,2}\\
a_{i,3}\\
\cdots\\
a_{i,1}\\
\end{bmatrix}
$$

由于我们推出的dp式子为：每一个人从上一秒的相邻两个人转移，所以 $A$是：

$$
A = 
\begin{bmatrix}
0&1&0&0&\cdots&0&1\\
1&0&1&0&\cdots&0&0\\
0&1&0&1&\cdots&0&0\\
\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\
1&0&0&0&\cdots&1&0\\
\end{bmatrix}
$$
关于矩阵乘法，这里不再赘述。

时间复杂度：$O(n^3\log{m})$

### SubTask $2$，32 pts，时间复杂度优化
我们观察，发现 $A$ 矩阵是循环的，每一行是上一行每一项右移一位（最后移到第一位）。

那么，我们就可以用快速幂把一行乘出来，然后再移出其他行。

关于累乘答案时，因为我们的 $Ans$ 矩阵只有一行有数，其他行都是占位符，可以全部优化掉，只乘第一行。

这样，时间复杂度可以压到 $O(n^2\log{m})$。

```cpp
int n, m;
const int MOD=1e9+7;
long long a[1005][1005], ans[1005][1005];
void Matrix1(){  
	long long c[1005][1005]={0};
	for (int j=1; j<=n; j++){
		for (int k=1; k<=n; k++){
			c[1][j]+=(a[1][k]*a[k][j])%MOD;
			c[1][j]%=MOD;
		}
	}
	for (int i=2; i<=n; i++){
		c[i][1]=c[i-1][n];
		for (int j=2; j<=n; j++){
			c[i][j]=c[i-1][j-1];
		}
	}
	for (int i=1; i<=n; i++){
		for (int j=1; j<=n; j++){
			a[i][j]=c[i][j];
		}
	}
}
void Matrix2(){
	long long c[1005][1005]={0};
	for (int j=1; j<=n; j++){
		for (int k=1; k<=n; k++){
			c[1][j]+=(ans[k][1]*a[j][k])%MOD;
			c[1][j]%=MOD;
		}
	}
	for (int i=1; i<=n; i++){
		ans[i][1]=c[1][i];
	}
}
```
### SubTask $3$，64 pts(O2)，空间优化
虽然上面的时间复杂度**理论上**可以通过本题，但是空间绝对不允许。

空间 32MB，无论怎么样都得 MLE 送走。

还是利用上面那个原理，由于 $A$ 矩阵循环，可以只存一行，等到累乘答案再把其他行算出来。

至于 $A$ 矩阵自乘，也是同理。先存一行，每一次往下右移一次，即可。

还有 $Ans$ 矩阵，本身就只有一行有数据，可以直接压掉其他行。

时间复杂度：$O(n^2\log{m})$

空间复杂度：$O(n)$
```cpp
void Matrix1(){  
	long long c[3505]={0}, d[3505]={0};  //新开一个数组，用来存每次右移后的a[];
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=n; j++){
		for (int k=1; k<=n; k++){
			c[j]=(c[j]+a[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=n; i++) a[i]=c[i];
}
void Matrix2(){
	long long c[3505]={0}, d[3505]={0};
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=n; j++){
		for (int k=1; k<=n; k++){
			c[j]=(c[j]+ans[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=n; i++) ans[i]=c[i];
}
```

### SubTask $4$，72 pts(O2)，常数优化Part.1
虽然时间和空间如上所说，**理论上**可以通过本题，但你会发现，还是过不了( TLE )。

如果你仔细计算，你会发现时间复杂度大约为 $7.35\times10^8$，显然无法通过本题 1s 的限制。所以，我们要想办法优化这份代码。

仔细观察每一行，你会发现以下现象：

当 $n$ 为奇数，$A$ 矩阵一行为：
$$
\begin{matrix}
a_1&a_2&a_3&\cdots&a_{\lfloor\frac{n+1}{2}\rfloor-1}&a_{\lfloor\frac{n+1}{2}\rfloor}&a_{\lfloor\frac{n+1}{2}\rfloor-1}&\cdots&a_4&a_3&a_2\\
\end{matrix}
$$
当 $n$ 为偶数，$A$ 矩阵一行为：
$$
\begin{matrix}
a_1&a_2&a_3&\cdots&a_{\lfloor\frac{n}{2}\rfloor}&a_{\lfloor\frac{n}{2}\rfloor+1}&a_{\lfloor\frac{n}{2}\rfloor}&\cdots&a_4&a_3&a_2\\
\end{matrix}
$$

所以，我们只需要求出 $A$ 矩阵一行的一半，然后再复制出来。

```cpp
void Matrix1(){  //当n为奇数
	long long c[3505]={0}, d[3505]={0};
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=(n+1)/2; j++){
		for (int k=1; k<=n; k++){
			c[j]=(c[j]+a[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=(n+1)/2; i++) a[i]=c[i];
	for (int i=(n+1)/2+1; i<=n; i++) a[i]=c[n-i+2];
//	for (int i=1; i<=n; i++) printf("%lld ", a[i]);
//	puts("");
}
void Matrix3(){  //当n为偶数
	long long c[3505]={0}, d[3505]={0};
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=n/2+1; j++){
		for (int k=1; k<=n; k++){
			c[j]=(c[j]+a[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=n/2+1; i++) a[i]=c[i];
	for (int i=n/2+2; i<=n; i++) a[i]=c[n-i+2];
}
void Matrix2(){ //不变
	long long c[3505]={0}, d[3505]={0};
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=n; j++){
		for (int k=1; k<=n; k++){
			c[j]=(c[j]+ans[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=n; i++) ans[i]=c[i];
}
```

### SubTask $5$，84 pts(O2)，常数优化Part.2
然后，还是 TLE。

为什么？因为 $3.5\times10^8$ 的复杂度显然还无法通过1s的时限。

所以我们继续优化。

我们都知道，计算机做取模运算做得很慢。而当我们观察矩阵快速幂的计算过程，我们又会发现：但凡 $A$ 或 $Ans$ 矩阵中有一个数为 $0$，本次乘法与取模无意义。

所以我们遇到这种情况，直接 `continue`。

不过说来也玄学，这样一个 `continue` 居然优化了 12pts。
```cpp
void Matrix1(){  
	long long c[3505]={0}, d[3505]={0};
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=(n+1)/2; j++){
		for (int k=1; k<=n; k++){
			if(a[k]==0||d[k]==0) continue; //当乘法有0，跳过
			c[j]=(c[j]+a[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=(n+1)/2; i++) a[i]=c[i];
	for (int i=(n+1)/2+1; i<=n; i++) a[i]=c[n-i+2];
//	for (int i=1; i<=n; i++) printf("%lld ", a[i]);
//	puts("");
}
void Matrix3(){  
	long long c[3505]={0}, d[3505]={0};
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=n/2+1; j++){
		for (int k=1; k<=n; k++){
			if(a[k]==0||d[k]==0) continue;
			c[j]=(c[j]+a[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=n/2+1; i++) a[i]=c[i];
	for (int i=n/2+2; i<=n; i++) a[i]=c[n-i+2];
}
void Matrix2(){
	long long c[3505]={0}, d[3505]={0};
	for (int i=1; i<=n; i++) d[i]=a[i];
	for (int j=1; j<=n; j++){
		for (int k=1; k<=n; k++){
			if(ans[k]==0||d[k]==0) continue;
			c[j]=(c[j]+ans[k]*d[k])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; k++) d[k]=d[k+1];
		d[n]=w;
	}
	for (int i=1; i<=n; i++) ans[i]=c[i];
}
```
### SubTask $6$ ，92 pts(O2)，常数优化 Part.3
但还是 TLE 啊啊啊！！！

所以我们还需要优化一下。

我们注意到，虽然我们执行了 `continue` 语句，但每一次循环还需要时间。这里的时间肯定也浪费了。

所以我们新开一个数组 $CNT$ ，记录每一个相乘中有贡献的下标。

然后循环的时候，就可以 `for (int k=1; k<=cnt; ++k)` 来优化时间了。

时间复杂度：$O(n^2\log{m})$ （由于每次 $A$ 矩阵右移还是 $O(n)$ 的）
```cpp
inline void Matrix1(){
	cnt=0;
	memset(c, 0, sizeof c);
	for (int i=1; i<=n; i++){
		d[i]=a[i];
		if(a[i]) e[++cnt]=i;
	}
	for (int j=1; j<=(n+1)/2; ++j){
		for (int k=1; k<=cnt; ++k){
			c[j]=(c[j]+a[e[k]]*d[e[k]])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; ++k) d[k]=d[k+1];
		d[n]=w;
		for (int i=1; i<=cnt; ++i){
			e[i]--;
			if(e[i]<1) e[i]=n;
		}
	}
	for (int i=1; i<=(n+1)/2; ++i) a[i]=c[i];
	for (int i=(n+1)/2+1; i<=n; ++i) a[i]=c[n-i+2];
}
inline void Matrix3(){  
	cnt=0;
	memset(c, 0, sizeof c);
	for (int i=1; i<=n; ++i){
		d[i]=a[i];
		if(a[i]) e[++cnt]=i;
	}
	for (int j=1; j<=n/2+1; ++j){
		for (int k=1; k<=cnt; ++k){
			c[j]=(c[j]+a[e[k]]*d[e[k]])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; ++k) d[k]=d[k+1];
		d[n]=w;
		for (int i=1; i<=cnt; ++i){
			e[i]--;
			if(e[i]<1) e[i]=n;
		}
	}
	for (int i=1; i<=n/2+1; ++i) a[i]=c[i];
	for (int i=n/2+2; i<=n; ++i) a[i]=c[n-i+2];
}
inline void Matrix2(){
	memset(c, 0, sizeof c);
	cnt=0;
	for (int i=1; i<=n; ++i){
		d[i]=a[i];
		if(a[i]) e[++cnt]=i;
	} 
	for (int j=1; j<=n; ++j){
		for (int k=1; k<=cnt; ++k){ //只有e[k]中出现的值才有贡献，其他无效 
			c[j]=(c[j]+ans[e[k]]*d[e[k]])%MOD;
		}
		int w=d[1];
		for (int k=1; k<n; ++k) d[k]=d[k+1];
		for (int i=1; i<=cnt; ++i){
			e[i]--;
			if(e[i]<1) e[i]=n;
		}
		d[n]=w;
	}
	for (int i=1; i<=n; ++i) ans[i]=c[i];
}
```

### SubTask $7$，100 pts(O2)，常数优化Part.4
还是 TLE 了两个点。

只能对右移操作下手了。

既然只有在 $A$ 矩阵中的非零数才对答案有贡献，那我们在存右移的时候也可以只存这些点啊！

所以，整个右移操作被优化掉。（因为 $A$ 自乘的时候一个数组是有贡献的值，另一个存的是下标， $Ans$ 数组同理）

#### AC Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
int n, m, cnt, e[3505];
const int MOD=1e9+7;
long long c[3505], a[3505], ans[3505], d[3505];
inline void Matrix1(){
	cnt=0;
	memset(c, 0, sizeof c);
	for (int i=1; i<=n; i++){
		if(a[i]) e[++cnt]=i, d[cnt]=a[i];
	}
	int u=(n+1)/2;
	for (int j=1; j<=u; ++j){
		for (int k=1; k<=cnt; ++k){
			c[j]=(c[j]+a[e[k]]*d[k])%MOD;
		}
		for (int i=1; i<=cnt; ++i){
			e[i]--;
			if(e[i]<1) e[i]=n;
		}
	}
	for (int i=1; i<=u; ++i) a[i]=c[i];
	for (int i=u+1; i<=n; ++i) a[i]=c[n-i+2];
}
inline void Matrix3(){  
	cnt=0;
	memset(c, 0, sizeof c);
	for (int i=1; i<=n; ++i){
		if(a[i]) d[++cnt]=a[i], e[cnt]=i;
	}
	int u=n/2+1;
	for (int j=1; j<=u; ++j){
		for (int k=1; k<=cnt; ++k){
			c[j]=(c[j]+a[e[k]]*d[k])%MOD;
		}
		for (int i=1; i<=cnt; ++i){
			e[i]--;
			if(e[i]<1) e[i]=n;
		}
	}
	for (int i=1; i<=u; ++i) a[i]=c[i];
	for (int i=u+1; i<=n; ++i) a[i]=c[n-i+2];
}
inline void Matrix2(){
	memset(c, 0, sizeof c);
	cnt=0;
	for (int i=1; i<=n; ++i){
		
		if(a[i])e[++cnt]=i, d[cnt]=a[i];
	}
	for (int j=1; j<=n; ++j){
		for (int k=1; k<=cnt; ++k){
			c[j]=(c[j]+ans[e[k]]*d[k])%MOD;
		}
		for (int i=1; i<=cnt; ++i){
			e[i]--;
			if(e[i]<1) e[i]=n;
		}
	}
	for (int i=1; i<=n; ++i) ans[i]=c[i];
}
int main(){
	scanf("%d%d", &n, &m);
	ans[1]=a[n]=a[2]=1;
	for (;m;){
		if(m&1) Matrix2();
		n&1?Matrix1():Matrix3();
		m>>=1;
	}
	printf("%lld\n", ans[1]);
	
	return 0;
}
```

---

## 作者：mrsrz (赞：5)

首先有一个简单的DP：$f_i=f_{(i-1+n)\bmod n}+f_{(i+1)\bmod n}$。

然后我们就得到了一个$O(nm)$的做法。

考虑把$f$写成生成函数的形式：设$G(x)$为$f$的生成函数。

我们可以把转移写成卷积的形式：$G'(x)=xG(x)+\frac{G(x)}{x}$，即$G'(x)=(x+x^{n-1})G(x)$。

这个式子在循环卷积下成立（即次数模$n$）。

考虑循环卷积的意义，我们每次乘出来以后，把第$i+n$项加给第$i$项即可。

观察式子，发现这个东西的值就是$(x+x^{n-1})^m$。

所以多项式快速幂即可。

考虑模数$10^9+7$，用分治乘法实现较为方便，时间复杂度$O(n^{1.585}\log m)$。当然也可以三模NTT/MTT来写，时间复杂度$O(n\log n\log m)$。

以下分治乘法代码。

## Code：
```cpp
#include<iostream>
using namespace std;
const int N=8193,md=1e9+7;
inline void upd(int&a){a+=a>>31&md;}
void solve(const int*a,const int*b,int*c,int n){
	if(n<20){
		static unsigned long long p[40];
		for(int i=n<<1;~i;--i)p[i]=0;
		for(int i=0;i<n;++i)
		for(int j=0;j<n;++j)p[i+j]+=(unsigned long long)a[i]*b[j];
		for(int i=n<<1;~i;--i)c[i]=p[i]%md;
		return;
	}
	const int m=n>>1;
	int f1[m+2],f2[m+2],g1[m+2],g2[m+2],fg[n+2],FG[n+2],G[n+2];
	for(int i=0;i<n;++i)fg[i]=FG[i]=G[i]=0;
	for(int i=0;i<m;++i)f1[i]=a[i],g1[i]=b[i],f2[i]=a[i+m],g2[i]=b[i+m];
	solve(f1,g1,fg,m),solve(f2,g2,FG,m);
	for(int i=0;i<m;++i)upd(f1[i]+=f2[i]-md),upd(g1[i]+=g2[i]-md);
	solve(f1,g1,G,m);
	for(int i=0;i<n;++i)upd(G[i]-=fg[i]),upd(G[i]-=FG[i]),c[i]=0;
	for(int i=0;i<n;++i)upd(c[i]+=fg[i]-md),upd(c[i+n]+=FG[i]-md),upd(c[i+m]+=G[i]-md);
}
int n,m,a[N],ret[N],c[N],lim;
void mul(int*c,int*a,int*b){
	static int A[N],B[N];
	for(int i=0;i<n*2;++i)A[i]=a[i],B[i]=b[i];
	for(int i=0;i<n*2;++i)c[i]=0;
	solve(A,B,c,lim);
	for(int i=n;i<n*2;++i)upd(c[i-n]+=c[i]-md),c[i]=0;
}
int main(){
	cin>>n>>m;
	for(lim=1;lim<n;lim<<=1);
	a[1]=a[n-1]=*ret=1;
	for(;m;m>>=1){
		if(m&1)mul(ret,ret,a);
		mul(a,a,a);
	}
	cout<<*ret;
	return 0;
}
```

---

## 作者：Memory_of_winter (赞：3)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10239336.html)

**题目大意：**有$n(n\leqslant3500)$个人坐成一个环，$0$号手上有个球，每秒钟可以向左或向右传球，问$m$秒后球在$0$号手上的方案数。

**题解：**一个$O(nm)$的$DP$，$f_{i,j}=f_{i-1,j-1}+f_{i-1,j+1}$（$f_{i,j}$表示现在为第$i$秒，球在$j$号手上的方案数）。这样明显不可以通过。

生成函数，$x^i$对应为原环上第$|i|\bmod n$个人，于是发现$f_{i,m}=\sum\limits_{k\in\mathbb Z}[x^{i+kn}](x^{-1}+x)^m$，所以答案为$\sum\limits_{k\in\mathbb Z}[x^{kn}](x^{-1}+x)^m$。这样感觉不可做，但是把它变成循环卷积后，答案就是$[x^0](x^{n-1}+x)^m$，复杂度$O(n\log_2n\log_2m)$。

注意，模数为$10^9+7$，需要三模$NTT$



**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#define maxn 3510
const int mod = 1e9 + 7;

namespace Math {
	inline int pw(int base, int p, const int mod) {
		static int res;
		for (res = 1; p; p >>= 1, base = static_cast<long long> (base) * base % mod) if (p & 1) res = static_cast<long long> (res) * base % mod;
		return res;
	}
	inline int inv(int x, const int mod) { return pw(x, mod - 2, mod); }
}

int n, m;
namespace Poly {
#define N 8192
	inline void clear(register int *l, const int *r) {
		if (l >= r) return ;
		while (l != r) *l++ = 0;
	}
	template <const int mod, const int G> struct P {
		int lim, s, rev[N];
		int Wn[N | 1];
		inline void reduce(int &x) { x += x >> 31 & mod; }
		inline void init(int n) {
			lim = 1, s = -1; while (lim < n) lim <<= 1, ++s;
			for (register int i = 1; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
			const int t = Math::pw(G, (mod - 1) / lim, mod);
			*Wn = 1; for (register int *i = Wn; i != Wn + lim; ++i) *(i + 1) = static_cast<long long> (*i) * t % mod;
		}
		inline void NTT(int *A, const int op = 1) {
			for (register int i = 1; i < lim; ++i) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
			for (register int mid = 1; mid < lim; mid <<= 1) {
				const int t = lim / mid >> 1;
				for (register int i = 0; i < lim; i += mid << 1) {
					for (register int j = 0; j < mid; ++j) {
						const int W = op ? Wn[j * t] : Wn[lim - j * t];
						const int X = A[i + j], Y = static_cast<long long> (A[i + j + mid]) * W % mod;
						reduce(A[i + j] += Y - mod), reduce(A[i + j + mid] = X - Y);
					}
				}
			}
			if (!op) {
				const int ilim = Math::inv(lim, mod);
				for (register int *i = A; i != A + lim; ++i) *i = static_cast<long long> (*i) * ilim % mod;
			}
		}

		int res[N];
		inline int operator [] (const int i) { return res[i]; }

		int C[N], D[N];
		void MUL(int *A, int *B) {
			std::copy(A, A + n, C), clear(C + n, C + lim);
			std::copy(B, B + n, D), clear(D + n, D + lim);
			NTT(C), NTT(D);
			for (int i = 0; i < lim; i++) res[i] = static_cast<long long> (C[i]) * D[i] % mod;
			NTT(res, 0);
		}
		void SQR(int *A) {
			std::copy(A, A + n, C), clear(C + n, C + lim);
			NTT(C);
			for (int i = 0; i < lim; i++) res[i] = static_cast<long long> (C[i]) * C[i] % mod;
			NTT(res, 0);
		}
	} ;
	const int mod1 = 469762049, mod2 = 998244353, mod3 = 1004535809;
	const long long mod_1_2 = static_cast<long long> (mod1) * mod2;
	const int inv_1 = Math::inv(mod1, mod2), inv_2 = Math::inv(mod_1_2 % mod3, mod3);
	P<mod1, 3> P1;
	P<mod2, 3> P2;
	P<mod3, 3> P3;
	inline int get(const int A, const int B, const int C) {
		const long long x = static_cast<long long> (B - A + mod2) % mod2 * inv_1 % mod2 * mod1 + A;
		return (static_cast<long long> (C - x % mod3 + mod3) % mod3 * inv_2 % mod3 * (mod_1_2 % mod) % mod + x) % mod;
	}

	inline void reduce(int &x) { x += x >> 31 & mod; }
	inline void init(int n) {
		P1.init(n), P2.init(n), P3.init(n);
	}
	void MUL(int *A, int *B) {
		P1.MUL(A, B), P2.MUL(A, B), P3.MUL(A, B);
		for (int i = 0; i < n + n; i++) reduce(A[i] = get(P1[i], P2[i], P3[i]) + get(P1[i + n], P2[i + n], P3[i + n]) - mod);
	}
	void SQR(int *A) {
		P1.SQR(A), P2.SQR(A), P3.SQR(A);
		for (int i = 0; i < n + n; i++) reduce(A[i] = get(P1[i], P2[i], P3[i]) + get(P1[i + n], P2[i + n], P3[i + n]) - mod);
	}
	inline void PW(int *res, int *base, int p) {
		init(n << 1);
		res[0] = 1, clear(res + 1, res + n);
		while (p) {
			if (p & 1) MUL(res, base);
			p >>= 1;
			if (p) SQR(base);
		}
	}
#undef N
}

int f[8192], g[8192];
int main() {
	scanf("%d%d", &n, &m);
	f[1] = f[n - 1] = 1;
	Poly::PW(g, f, m);
	printf("%d\n", g[0]);
	return 0;
}

```



---


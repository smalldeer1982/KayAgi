# 数列

## 题目背景

题解：https://blog.csdn.net/kkkksc03/article/details/85008130

## 题目描述

一个数列 $a_n $，已知 $a_1$ 及 $a_2$ 两项。

数列 $a_n$ 满足递推式 $a_n=x \times a_{n-1}+ y \times a_{n-2}(n≥3).$

求 $\sum_{i=1}^na_i^2$

由于答案可能过大，对 $10^9+7$ 取模。

## 说明/提示

样例解释：

对于第一组样例，可知数列为 $1,1,2,3,5$，则答案是 $1^2+1^2+2^2+3^2+5^2=40$。

对于第二组样例，可知数列为 $3,4,18,62$，则答案是 $3^2+4^2+18^2+62^2=4193$。

~~第三组样例不予解释。~~

对于前 $20\%$ 的数据，保证 $x=y=1$。

对于 $100\%$ 的数据，$T=30000,1\le n \le 10^{18},1\le a_1,a_2 ,x,y \le 10^9$。

## 样例 #1

### 输入

```
3
5 1 1 1 1
4 3 4 3 2
461564597527246 987489553 321654648 164165256 315648984```

### 输出

```
40
4193
480929868```

# 题解

## 作者：Kevin_Zhen (赞：17)

题目链接 [$\mathfrak{P5175}$](https://www.luogu.com.cn/problem/P5175)。  
萌新的第一篇矩阵加速相关题解，求资瓷！qwq

### 题目大意
一个数列 $a_n$，已知 $a_1$、$a_2$ 两项及两个系数 $x$ 和 $y$，数列 $a_n$ 满足递推式 $a_i=x\times a_{i-1}+y\times a_{i-2}\ (i\ge 3)$，求 $\sum_{i=1}^{n}{{a_i}^2}\ (n\le 10^{18})$。

### 解题思路
题目相比于普通的矩阵加速，最大的难点在于所求答案为各项平方和。我们需要通过 $S_{i-1}$ 和 ${a_i}^2$ 求解 $S_i\ (S_i=\sum_{j=1}^i{{a_j}^2})$，即 $S_i=S_{i-1}+{{a_i}^2}$。根据**构造矩阵时，要将求解所求答案所需元素放入构造矩阵中**的思路，我们不妨直接将 ${a_i}^2$ 放入构造矩阵中，在接下来的做题过程中也应更多关注于 ${a_i}^2$ 的求解，而非 $a_i$（$a_i$ 并未用到）。

先确定矩阵转移方程。假设我们当前要由矩阵 $(i-1)$ 转移到矩阵 $i$ 吧。  
首先要包括所求内容，当前两矩阵分别为：$\begin{bmatrix}S_i\end{bmatrix}$ 和 $\begin{bmatrix}S_{i-1}\end{bmatrix}$。  
求解 $S_i$ 需要用到 ${a_i}^2$，所以矩阵 $(i-1)$ 变为 $\begin{bmatrix}S_{i-1}\\{a_i}^2\end{bmatrix}$，相应地，矩阵 $i$ 变为 $\begin{bmatrix}S_i\\{a_{i+1}}^2\end{bmatrix}$。  
由 $a_{i+1}=x\times a_i+y\times a_{i-1}$ 得，矩阵 $i$ 变为 $\begin{bmatrix}S_i\\(xa_i+ya_{i-1})^2\end{bmatrix}$。此时两矩阵分别为：$\begin{bmatrix}S_i\\x^2{a_i}^2+y^2{a_{i-1}}^2+2xya_ia_{i-1}\end{bmatrix}$ 和 $\begin{bmatrix}S_{i-1}\\{a_i}^2\end{bmatrix}$。  
从矩阵 $i$ 中可以看出，要想求得矩阵 $i$，矩阵 $(i-1)$ 中还需放入 ${a_{i-1}}^2$ 和 $a_ia_{i-1}$ 两项。将这两项放入矩阵 $(i-1)$，两矩阵相应变为：$\begin{bmatrix}S_i\\x^2{a_i}^2+y^2{a_{i-1}}^2+2xya_ia_{i-1}\\{a_i}^2\\a_{i+1}a_i\end{bmatrix}$ 和 $\begin{bmatrix}S_{i-1}\\{a_i}^2\\{a_{i-1}}^2\\a_ia_{i-1}\end{bmatrix}$。  
最后再次用 $a_{i+1}=x\times a_i+y\times a_{i-1}$ 消去矩阵 $i$ 中的 $a_{i+1}$，得到最终的两矩阵：  
$\begin{bmatrix}S_i\\x^2{a_i}^2+y^2{a_{i-1}}^2+2xya_ia_{i-1}\\{a_i}^2\\x{a_i}^2+ya_ia_{i-1}\end{bmatrix}$ 和 $\begin{bmatrix}S_{i-1}\\{a_i}^2\\{a_{i-1}}^2\\a_ia_{i-1}\end{bmatrix}$。  
此时矩阵 $i$ 已经完全可以由矩阵 $(i-1)$ 转移得到了。具体的转移方式是将矩阵 $(i-1)$ 乘上一个由对应系数构成的矩阵。

得到最终的矩阵转移方程为：  
$\begin{bmatrix}S_i\\x^2{a_i}^2+y^2{a_{i-1}}^2+2xya_ia_{i-1}\\{a_i}^2\\x{a_i}^2+ya_ia_{i-1}\end{bmatrix}=\begin{bmatrix}1\ 1\ 0\ 0\\0\ x^2\ y^2\ 2xy\\0\ 1\ 0\ 0\\0\ x\ 0\ y\end{bmatrix}\times\begin{bmatrix}S_{i-1}\\{a_i}^2\\{a_{i-1}}^2\\a_ia_{i-1}\end{bmatrix}$。

时间复杂度为 $O(Tlogn\times m^3)$，其中 $m$ 为矩阵的边长。注意此题 $T\le 30000$，$log_210^{18}\approx 60$，时限为 $1.5s$，此时矩阵的边长已经不能当作一个常数忽略不计了。估算得 $m=4$ 时执行次数约为 $1.152\times 10^8$，边长大于 $4$ 的矩阵是无法接受的。

### AC CODE
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

typedef unsigned long long ull;

const int Mod = 1e9 + 7;

struct Matrix {
	ull a[15][15]; int n, m;
	ull* operator [](int x) { return a[x]; }
	void clear() { n = 0, m = 0, memset(a, 0, sizeof(a)); }
};

Matrix operator *(Matrix &x, Matrix &y) {
	Matrix z; z.clear(); z.n = x.n, z.m = y.m;
	for (int i = 1; i <= x.n; ++i) {
		for (int j = 1; j <= x.m; ++j) {
			for (int k = 1; k <= y.m; ++k) z[i][k] = (z[i][k] + x[i][j] * y[j][k]) % Mod;
		}
	}
	return z;
}

int T;
ull n, a1, a2, x, y; Matrix a, b, ans;

Matrix qpow(Matrix base, ull p) {
	Matrix res = base; --p;
	while (p) {
		if (p & 1) res = res * base;
		base = base * base;
		p >>= 1;
	}
	return res;
}

int main() {
	scanf("%d", &T);
	while (T--) {
		a.clear(); b.clear(); ans.clear();
		scanf("%llu%llu%llu%llu%llu", &n, &a1, &a2, &x, &y); a1 %= Mod, a2 %= Mod, x %= Mod, y %= Mod;
		if (n == 1) {
			printf("%llu\n", a1 * a1 % Mod);
			continue;
		}
		a.n = a.m = 4; b.n = 4, b.m = 1;
		a[1][1] = a[1][2] = a[3][2] = 1; a[2][2] = x * x % Mod; a[2][3] = y * y % Mod; a[2][4] = 2 * x * y % Mod; a[4][2] = x; a[4][4] = y;
		b[1][1] = b[3][1] = a1 * a1 % Mod; b[2][1] = a2 * a2 % Mod; b[4][1] = a2 * a1 % Mod;
		ans = qpow(a, n - 1); ans = ans * b;
		printf("%llu\n", ans[1][1]);
	}
	return 0;
}
```

### 感谢观赏！

---

## 作者：CTime_Pup_314 (赞：9)

更好的阅读体验

[CTime_Pup_314的博客](https://ctp314.github.io/)


# [P5175 数列](https://www.luogu.org/problemnew/show/P5175)

> 求二阶线性常系数齐次递推的平方和

蒟蒻不会构造矩阵，所以用了一种很暴力的做法

_由于这道题意要求，下文数列下标都从 1 开始_

## 前置知识 

### 线性常系数齐次递推关系

若递推关系满足 

$$f_n\ =\ \sum_{i=1}^kc_if_{n-i}\ (n >k)$$

且对于 $f_1,\ c_1,\ f_2,\ c_2\ ...\ f_k,\ c_k$ 都为常数

则称这种递推关系为**线性常系数齐次递推关系**，其中 $k$ 为阶数

斐波那契数列就是常见的满足二阶线性常系数齐次递推关系的数列

### 特征方程

求解线性常系数齐次递推方法的有很多，特征方程是常见的一种

对于递推 $f_n\ =\ 2f_{n-1}+3f_{n-2}$ 来说

我们构造等比数列 $\langle\ 1,\ -1,\ 1\ ...\ \rangle$ 满足这种关系，其中 $g_n\ =\ (-1)^{n-1}$

又另一个构造等比数列 $\langle\ 1,\ 3,\ 9\ ...\ \rangle$ 满足这种关系，其中 $h_n\ =\ 3^{n-1}$

仔细思考发现对于常数 $\alpha$ 和 $\beta$ 而言 $\lbrace \alpha g_n\rbrace$ 和 $\lbrace \beta h_n\rbrace$ 都满足

进一步思考后感觉对于 $\lbrace \alpha g_n\ +\ \beta h_n\rbrace$ 也都满足，其正确性十分明显无需多言

也就是说我们可以通过一些等比数列作为基底，通过它们的线性组合，生成很多满足线性常系数齐次递推的数列

如何找到这些等比数列呢？拿二阶来说

我们不妨设等比数列 $q_n$ 的公比为 $x$，我们发现递推关系可以写成 
$$
x^2q_n\ =\ axq_n+\ bq_n
$$
两边同时消去 $q_n$，只剩下
$$
x^2\ =\ ax\ + b
$$

这个方程叫做**特征方程**，通过这个我们就可以找到所有满足条件的等比数列

现在用斐波那契数列举例，特征方程为

$$
x^2\ =\ x\ +\ 1
$$

解得 $x_1\ =\ \frac{1+\sqrt{5}}{2}$，$x_2\ =\ \frac{1-\sqrt{5}}{2}$

我们现在要解出 $\alpha$ 和 $\beta$，则有 $f_n= \alpha(x_1)^{n-1}+\beta(x_2)^{n-1}$

带入 $f_1=1$ 和 $f_2=1$ 得
$$\begin{cases}\alpha+\beta=1\\\\\alpha x_1+\beta x_2=1\\\end{cases}\Rightarrow\begin{cases}\alpha=\frac{\sqrt{5}-1}{2\sqrt{5}}\\\\\beta=\frac{\sqrt{5}+1}{2\sqrt{5}}\\\end{cases}$$

所以 $f_n=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-\frac{1-\sqrt{5}}{2})^n]$ 

### 模意义下的根式运算

假如我们在计算过程中出现了根式，但保证根号下的数不变且结果一定不包含根式，要求在模$P$意义下进行，保证计算过程中的任何数有逆元，如何解决呢？

我们可以把根式写作类似复数的形式 $a+\sqrt{k}b$ 其中 $k$ 是所有数的根号下面的部分，如 $a+\sqrt{2}\ b$ 等

我们把 $a$ 称作有理部，$b$ 称作无理部，$\sqrt{k}$ 称作基

下面给出几项重要的运算，基不会被取模

加法 $(a+\sqrt{k}b)+(c+\sqrt{k}d)\ \equiv\ (a+b)+\sqrt{k}(c+d)\ (mod\ P)$

减法 $(a-\sqrt{k}b)+(c-\sqrt{k}d)\ \equiv\ (a-b)+\sqrt{k}(c-d)\ (mod\ P)$

共轭 $conj(a+\sqrt{k}b)\ \equiv\ a+\sqrt{k}(-b)\ (mod\ P)$

乘法 $(a+\sqrt{k}b)(c+\sqrt{k}d)\ \equiv\ (ac+bdk)+\sqrt{k}(ad+bc)\ (mod\ P)$

除法比较特殊，我们需要先将分母有理化，即同时将分子和分母同时乘上分母的共轭，这时分母就只剩下有理部了，再把分子部分除以分母有理部的逆元即可

除法 $\frac{a+\sqrt{k}b}{c+\sqrt{k}d}\ \equiv\ \frac{(a+\sqrt{k}b)(c+\sqrt{k}d)}{c^2-kd^2} (mod\ P)$

写出来就是

```cpp
struct Complex
{
    int rat, irr; // rat 有理部 irr 无理部 irr_base 基
    Complex(int rat = 0, int irr = 0):rat(rat), irr(irr) {};
    Complex conj() const { return Complex(rat, P-irr); }
    Complex operator - (const Complex &_) const { return Complex((rat-_.rat+P)%P, (irr-_.irr+P)%P); }
    Complex operator + (const Complex &_) const { return Complex((rat+_.rat)%P, (irr+_.irr)%P); }   
    Complex operator * (const Complex &_) const
    {
        Complex ret; 
        ret.rat = (rat*_.rat%P+irr*_.irr%P*irr_base%P)%P;
        ret.irr = (rat*_.irr%P+irr*_.rat%P)%P;
        return ret;
    }
    Complex operator / (const Complex &_) const
    {
        Complex a = Complex(rat, irr)*_.conj(); Complex b = _*_.conj();
        a = a*Complex(qpow(b.rat, P-2), 0); // 求逆
        return a;
    }
};
```

## 题目主体

题干给出的是一个二阶线性常系数齐次递推数列，而让求出前 $n$ 项平方和

有前置知识得出这个数列的通项的是几个等比数列的线性组合，那么最后也无非是几个等比数列求和罢了

同时这道题保证了特征方程有两根和根式模运算的前提条件，所以下面做法极其暴力

设数列为 $\lbrace f_n\rbrace$ 其他变量名含义与前置知识中的相同

则有 
$$
\begin{cases}
x_1\ =\ \frac{a+\sqrt{a^2+4b}}{2}\\\\
x_2\ =\ \frac{a-\sqrt{a^2+4b}}{2}\\\\
\alpha\ =\ \frac{x_1f_1-f_2}{x_1-x_2}\\\\
\beta\ =\ \frac{f_2-x_2f_1}{x_1-x_2}
\end{cases}
$$

而 $f_n= \alpha(x_1)^{n-1}+\beta(x_2)^{n-1}$ 那么 $f_n^2= \alpha^2(x_1^2)^{n-1}+\beta^2(x_2^2)^{n-1}+2\alpha\beta(x_1x_2)^{n-1}$

每一部分都是等比数列，用公式 $S_n\ =\ \frac{x^n-1}{x-1}$ 即可

暴力代码如下，没有加任何常数优化居然跑得最快

```cpp
#include <cctype>
#include <algorithm>
#include <cstdio>
#define int long long // 虽然习惯不好，但是在这题比较方便
using namespace std;
const int P = 1e9+7;
int n, t, a, b, irr_base, f1, f2;
int qpow(int a, int b)
{
    int ret = 1;
    for( ; b; b >>= 1, a = a*a%P) if(b&1) ret = ret*a%P;
    return ret;
}
struct Complex
{
    int rat, irr;
    Complex(int rat = 0, int irr = 0):rat(rat), irr(irr) {};
    Complex conj() const { return Complex(rat, P-irr); }
    Complex operator - (const Complex &_) const { return Complex((rat-_.rat+P)%P, (irr-_.irr+P)%P); }
    Complex operator + (const Complex &_) const { return Complex((rat+_.rat)%P, (irr+_.irr)%P); }   
    Complex operator * (const Complex &_) const
    {
        Complex ret; 
        ret.rat = (rat*_.rat%P+irr*_.irr%P*irr_base%P)%P;
        ret.irr = (rat*_.irr%P+irr*_.rat%P)%P;
        return ret;
    }
    Complex operator / (const Complex &_) const
    {
        Complex a = Complex(rat, irr)*_.conj(); Complex b = _*_.conj();
        a = a*Complex(qpow(b.rat, P-2), 0);
        return a;
    }
};
Complex qpow(Complex a, int b)
{
    Complex ret = Complex(1, 0);
    for( ; b; b >>= 1, a = a*a) if(b&1) ret = ret*a;
    return ret;
}
Complex alpha, beta, x1, x2, fn;
Complex sum1, sum2, sum3, ans;
signed main()
{
    scanf("%lld", &t);
    while(t--)
    {
        scanf("%lld%lld%lld%lld%lld", &n, &f1, &f2, &a, &b);
        irr_base = (a*a%P+4*b%P)%P;
        x1 = Complex(a, 1)/Complex(2, 0);
        x2 = Complex(a, P-1)/Complex(2, 0);
        alpha = (Complex(f2, 0)-x2*Complex(f1, 0))/(x1-x2);
        beta = (x1*Complex(f1, 0)-Complex(f2, 0))/(x1-x2);
        fn = alpha*qpow(x1, n-1)+beta*qpow(x2, n-1);
        sum1 = (qpow(x1*x1, n)-Complex(1, 0))/(x1*x1-Complex(1, 0))*alpha*alpha;
        sum2 = (qpow(x2*x2, n)-Complex(1, 0))/(x2*x2-Complex(1, 0))*beta*beta;
        sum3 = (qpow(x1*x2, n)-Complex(1, 0))/(x1*x2-Complex(1, 0))*beta*alpha*Complex(2, 0);
        ans = sum1+sum2+sum3;
        printf("%lld\n", ans.rat);
    }

    return 0;
}
```

---

## 作者：Scorilon (赞：7)

### Updated

#### 2023.07.05 修正了一处笔误，在此感谢@[DWT8125](https://www.luogu.com.cn/user/390228)

### 题解

首先先推一下柿子，因为数据范围很大，所以考虑矩阵加速递推。

根据题意给的递推式，可得：

$$\begin{aligned}
a_i^2 
	&= (x \times a_{i-1}+y \times a_{i-2})^2\\
	&= x^2\times a_{i-1}^2+y^2\times a_{i-2}^2+2xy\times a_{i-1} \times a_{i-2}
\end{aligned}$$

由此我们可以构造出答案矩阵：

$$T=\begin{bmatrix}
a_i^2 & a_{i-1}^2 & a_i \times a_{i-1} &ans_i\\
\end{bmatrix}$$

其中 $ans_i=\sum_{j=1}^i a_j^2$.

那么由于

$$\begin{cases}
x^2\times a_{i-1}^2+y^2\times a_{i-2}^2+2xy\times a_{i-1} \times a_{i-2}+0 \times ans_{i-1}=a_i^2\\
1\times a_{i-1}^2+0\times a_{i-2}^2+0\times a_{i-1} \times a_{i-2}+0 \times ans_{i-1}=a_{i-1}^2\\
x\times a_{i-1}^2+0\times a_{i-2}^2+y\times a_{i-1} \times a_{i-2}+0 \times ans_{i-1}=a_{i} \times a_{i-1}\\
x^2\times a_{i-1}^2+y^2\times a_{i-2}^2+2xy\times a_{i-1} \times a_{i-2}+1 \times ans_{i-1}=ans_i\\
\end{cases}$$

可得

$$\begin{bmatrix}
a_{i-1}^2 & a_{i-2}^2 & a_{i-1} \times a_{i-2} &ans_{i-1}\\
\end{bmatrix} \times \begin{bmatrix}
x^2 & 1 & x & x^2\\
y^2 & 0 & 0 & y^2\\
2xy & 0 & y & 2xy\\
0 & 0 & 0 & 1\\
\end{bmatrix}=T$$

因为我们已知第一第二项，所以只需得到转移矩阵的 $n-2$ 次方即可，此时要特判 $n=1$ 和 $n=2$ 的情况，防止程序出错。

然后再套一下矩阵加速的板子就可以。

单次时间复杂度为 $O(\log n \times m^3)$，其中 $m$ 为矩阵边长，总时间复杂度为 $O(T\log n \times m^3)$.

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

#define ll long long

const ll mod=1e9+7;

ll t,n,a1,a2,x,y;

struct matrix {
	int n,m;
	ll e[5][5];
	void clean() {
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=m;j++) {
				e[i][j]=0;
			}
		}
	}
};

matrix mul(matrix a,matrix b) {
	matrix ans;
	ans.n=a.n;
	ans.m=b.m;
	ans.clean();
	for(int i=1;i<=a.n;i++) {
		for(int j=1;j<=b.m;j++) {
			for(int k=1;k<=a.m;k++) {
				ans.e[i][j]=(ans.e[i][j]+(a.e[i][k]*b.e[k][j])%mod)%mod;
			}
		}
	}
	return ans;
}

matrix quickly_pow(matrix a,ll k) {
	matrix ans;
	ans.n=a.n;
	ans.m=a.m;
	for(int i=1;i<=ans.n;i++) {
		for(int j=1;j<=ans.m;j++) {
			if(i==j) ans.e[i][j]=1;
			else ans.e[i][j]=0;
		}
	}
	while(k) {
		if(k&1) ans=mul(ans,a);
		a=mul(a,a);
		k>>=1;
	}
	return ans;
}

int main() {
	scanf("%lld",&t);
	while(t--) {
		scanf("%lld%lld%lld%lld%lld",&n,&a1,&a2,&x,&y);
		if(n==1) {//特判
			printf("%lld\n",a1*a1%mod);
			continue;
		} else if(n==2) {
			printf("%lld\n",(a1*a1%mod+a2*a2%mod)%mod);
			continue;
		}
		matrix init;
		init.n=4;init.m=4;
		init.clean();
		init.e[1][1]=x*x%mod;init.e[1][2]=1;init.e[1][3]=x;init.e[1][4]=x*x%mod;
		init.e[2][1]=y*y%mod;init.e[2][4]=y*y%mod;
		init.e[3][1]=2*x%mod*y%mod;init.e[3][3]=y;init.e[3][4]=2*x%mod*y%mod;
		init.e[4][4]=1;
		init=quickly_pow(init,n-2);
		matrix ans;
		ans.n=1;ans.m=4;
		ans.clean();
		ans.e[1][1]=a2*a2%mod;ans.e[1][2]=a1*a1%mod;ans.e[1][3]=a1*a2%mod;ans.e[1][4]=(a1*a1%mod+a2*a2%mod)%mod;
		ans=mul(ans,init);
		printf("%lld\n",ans.e[1][4]);
	}
	return 0;
}
```

---

## 作者：muller (赞：6)

这题好像不能用2*2矩阵搞完

所以我们要想别的对策

就是通过平方来乱搞

（a+b）^2=a^2+b^2+2ab

于是我们需要一个4*4的矩阵

记录f[i]与f[i-1]的关系

同样套在刚刚那个公式里

a(n)^2可以由a(n-1)a(n-2),a(n-1)^2,a(n-2)^2推出来

a(n)a(n-1)可以由a(n-1)^2,a(n-1)a(n-2)推出来

于是就是一个4*4的矩阵

然后就没了

剩下的就是正常的矩阵乘法了

相同于fib

放上我的代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll p = 1e9 + 7;
template <typename T> void rd(T &t) {
	t = 0;
	char p = getchar();
	while (p == ' ' || p == '\n') p = getchar();
	do {(t *= 10) += p - '0'; p = getchar();} while (p >= '0' && p <= '9');
}
struct mat {
	ll a[4][4];
} a, t;
mat operator *(mat a, mat b) {
	mat c;
	int i, j, k;
	for (i = 0; i < 4; ++i)
		for (j = 0; j < 4; ++j) c.a[i][j] = 0;
	for (i = 0; i < 4; ++i)
		for (j = 0; j < 4; ++j)
			for (k = 0; k < 4; ++k) c.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j]) % p;
	return c;
}
int main() {
	ll n, a1, a2, x, y;
	int T, i, j;
	rd(T);
	while (T--) {
		rd(n); rd(a1); rd(a2); rd(x); rd(y);
		if (n == 1) {
			printf("%lld\n", a1 * a1 % p);
			continue;
		}
		if (n == 2) {
			printf("%lld\n", a2 * a2 % p);
			continue;
		}
		for (i = 0; i < 4; ++i)
			for (j = 0; j < 4; ++j) a.a[i][j] = t.a[i][j] = 0;
		a.a[0][0] = a1 * a1 % p; a.a[0][1] = a2 * a2 % p;
		a.a[0][2] = a1 * a2 % p; a.a[0][3] = (a.a[0][0] + a.a[0][1]) % p;
		t.a[0][1] = t.a[0][3] = y * y % p;
		t.a[1][1] = t.a[1][3] = x * x % p;
		t.a[2][1] = t.a[2][3] = 2 * x * y % p;
		t.a[1][0] = t.a[3][3] = 1;
		t.a[1][2] = x; t.a[2][2] = y;
		for (n -= 2; n; n >>= 1, t = t * t)
			if (n & 1) a = a * t;
		printf("%lld\n", a.a[0][3]);
	}
	return 0;
}

```

---

## 作者：_fairytale_ (赞：4)

提供一个简单易懂的方法。

看到[题目描述](https://www.luogu.com.cn/problem/P5175)，多半就是矩阵加速了，考虑构造转移矩阵。

注意到我们要求的是前 $n$ 项的前缀平方和，因此需要推一下式子。

不难想到 $a_i^2 = (x \times a_{i-1} + y \times a_{i-2})^2$

用完全平方公式展开一下：

$a_i^2 = (x \times a_{i-1} + y \times a_{i-2})^2$

$= x^2 \times a_{i-1} ^2 + y^2 \times a_{i-2}^2 + 2xy \times a_{i-1} \times a_{i-2}$

我们发现，要递推出 $a_i^2$ ，只需要在矩阵里存这三个东西：

$a_{i-1} ^2$、$a_{i-2}^2$、$a_{i-1} \times a_{i-2}$

前两项都很简单，那 $a_{i-1} \times a_{i-2}$ 怎么递推到 $a_{i} \times a_{i-1}$ 呢？

我们把它展开一下：

$a_{i} \times a_{i-1} = (x \times a_{i-1}+y \times a_{i-2}) \times a_{i-1}$

$=x \times a_{i-1}^2 + y \times a_{i-1} \times a_{i-2}$

而 $a_{i-1}^2$ 是我们矩阵里已经有的！

接下来就可以构造转移矩阵了，注意要开一个前缀平方和 $S$ 记录答案。

$\begin{bmatrix} a_i^2&a_{i-1}^2&a_i \times a_{i-1}&S_i\end{bmatrix}$

$=$ $\begin{bmatrix} a_{i-1}^2&a_{i-2}^2&a_{i-1} \times a_{i-2}&S_{i-1}\end{bmatrix}$ $\times$ 

$\begin{bmatrix}x^2&1&x&x^2 \\ y^2&0&0&y^2 \\ 2xy&0&y&2xy\\0&0&0&1\end{bmatrix}$

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
const int mod=1e9+7;
int T;
unsigned long long n,a1,a2,x,y;
struct matrix {
	int r,c;
	unsigned long long z[6][6];
	matrix() {
		memset(z,0,sizeof(z));
	}
} M,S;
inline void init() {
	memset(M.z,0,sizeof(M.z));
	memset(S.z,0,sizeof(S.z));
	M.r=M.c=4;
	M.z[1][1]=x*x%mod;
	M.z[2][1]=y*y%mod;
	M.z[3][1]=2*x*y%mod;
	M.z[1][2]=1;
	M.z[1][3]=x;
	M.z[3][3]=y;
	M.z[1][4]=x*x%mod;
	M.z[2][4]=y*y%mod;
	M.z[3][4]=2*x*y%mod;
	M.z[4][4]=1;
	S.r=1;
	S.c=4;
	S.z[1][1]=a2*a2%mod;
	S.z[1][2]=a1*a1%mod;
	S.z[1][3]=a1*a2%mod;
	S.z[1][4]=(S.z[1][1]+S.z[1][2])%mod;
}
matrix operator *(const matrix &a,const matrix &b) {
	matrix res;
	res.r=a.r,res.c=b.c;
	for(re int i=1; i<=res.r; ++i) {
		for(re int k=1; k<=a.c; ++k) {
			for(re int j=1; j<=res.c; ++j) {
				res.z[i][j]=(res.z[i][j]+a.z[i][k]*b.z[k][j]%mod)%mod;
			}
		}
	}
	return res;
}
inline matrix qp(matrix a,long long p) {
	if(p==1)return a;
	matrix b=qp(a,p>>1);
	b=b*b;
	if(p&1)b=b*a;
	return b;
}
int main() {
	ios::sync_with_stdio(false);
	cin>>T;
	while(T--) {
		cin>>n>>a1>>a2>>x>>y;
		a1%=mod,a2%=mod;
		if(n==1) {//特判一下这俩
			cout<<a1*a1%mod<<'\n';
			continue;
		} else if(n==2) {
			cout<<(a1*a1%mod+a2*a2%mod)%mod<<'\n';
			continue;
		}
		init();
		S=S*qp(M,n-2);
		cout<<S.z[1][4]<<'\n';
	}
	return 0;
}


```
哪里有错误或者讲得不清楚，欢迎指出！

---

## 作者：ShineEternal (赞：3)

#### 思考难度：提高?
#### 代码难度：提高?


算法0：暴力

实际得分：0 

算法1： 

考虑$x=y=1$的情况，显然有$a_n=a_{n-1}+a_{n-2}$(废话)，故

$$a_n\times a_{n+1}$$

$$=a_n\times (a_n+a_{n-1})$$

$$=a_n^2+a_{n-1}\times a_n$$

$$=a_n^2+a_{n-1}^2+a_{n-2}\times a_{n-1}$$

$$=...+a_2^2+a_1\times a_2$$

$$=...+a_2^2+a_1^2+a_1\times (a_2-a_1)$$

故$ans=a_n\times a_{n+1}-a_1\times (a_2-a_1)$ 

实际得分：20分

算法2：

注意到

$$a_n^2=(x\times a_{n-1}+y\times a_{n-2})^2$$

$$=x^2\times a_{n-1}^2+y^2\times a_{n-2}^2+2xy\times a_{n-1}\times a_{n-2}$$

$$=x^2\times a_{n-1}^2+y^2\times a_{n-2}^2+2xy\times a_{n-2}\times (x\times a_{n-2}+y\times a_{n-3})$$

$$=x^2\times a_{n-1}^2+y^2\times a_{n-2}^2+2xy\times (x\times a_{n-2}^2+y\times a_{n-2}\times a_{n-3})$$

故$a_n^2$可以由$a_{n-1}^2,a_{n-2}^2,a_{n-1}\times a_{n-2}$转移过来，而$a_{n-1}\times a_{n-2}$可以由$a_{n-1}^2,a_{n-2}\times a_{n-3}$转移过来。

矩阵加速即可。

实际得分：100

# code：
```cpp
#include<cstdio>
typedef long long LL;
const int N=5;
const int mod=1e9+7;
struct jz{
    LL c[N][N];
}a,t;
jz operator * (jz a,jz b){
    jz c;
    for(int i=1;i<N;++i)
    for(int j=1;j<N;++j)
    c.c[i][j]=0;
    for(int k=1;k<N;++k)
    for(int i=1;i<N;++i)
    for(int j=1;j<N;++j)
    if(a.c[i][k]&&b.c[k][j])
    c.c[i][j]=(c.c[i][j]+a.c[i][k]*b.c[k][j])%mod;
    return c;
}
LL n,a1,a2,x,y,T;
inline void rad(LL &noip){
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9');noip=ch^48;
    while(ch=getchar(),ch>='0'&&ch<='9')noip=(noip<<3)+(noip<<1)+(ch^48);
}
int main(){
    for(rad(T);T;--T){
        rad(n);rad(a1);rad(a2);rad(x);rad(y);
    	if(n==1){printf("%lld\n",a1*a1%mod);}
    	else if(n==2){printf("%lld\n",((a1*a1+a2*a2)%mod));}
        else{
            for(int i=1;i<N;++i)
  			for(int j=1;j<N;++j)
   			a.c[i][j]=t.c[i][j]=0;
            a.c[1][1]=a1*a1%mod;
            a.c[1][2]=a2*a2%mod;
            a.c[1][3]=a1*a2%mod;
            a.c[1][4]=(a.c[1][1]+a.c[1][2])%mod;
            t.c[1][2]=t.c[1][4]=y*y%mod;
            t.c[2][2]=t.c[2][4]=x*x%mod;
            t.c[3][2]=t.c[3][4]=2*x*y%mod;
            t.c[2][1]=t.c[4][4]=1;
            t.c[2][3]=x;t.c[3][3]=y;
            for(n-=2;n;n>>=1,t=t*t)
            if(n&1)a=a*t;
    		printf("%lld\n",a.c[1][4]);
        }
    }
}
```

最后%一下： da32s1da

---

## 作者：TangLongbin (赞：3)

本题主要考察了**矩阵运算对递推的加速和优化**；	
首先一看题目：	![](https://cdn.luogu.com.cn/upload/pic/47865.png )

仔细观察数据**范围和样例**：当**x==1&&y==1**时，数列{An}就是一个赤裸裸的**斐波那契数列（FIbonacci**）,学过斐波那契数列的同学都知道，求斐波那契数列数列的**第N项**以及求**前n项**和是可以列出其相关矩阵进行快速运算的，因此我们这里也采用矩阵的加速我们的递推式；

这里我直接给出矩阵（下面一一详解）：	
**记Sn为所求（即数列{An^2}的前n项和；**

![](https://cdn.luogu.com.cn/upload/pic/47864.png )	
接下来我们验证矩阵的正确性：	
根据矩阵乘法的规则：	
![](https://cdn.luogu.com.cn/upload/pic/47866.png )	
矩阵的准确性得证；
最后根据题目条件，已知n,a1,a2,x,y,因此**右边的最开始的矩阵是已知的**，然后我们要计算左边的矩阵，根据递推关系可知：我们只需要求解中间那个4$*$4的矩阵的（n-1）次方，最后乘以最初的已知矩阵，得到的4*1的矩阵的第一项即为所求Sn;	
复杂度就不求了，能A就行；	
下面附上代码，我会尽量标注（代码较丑）；
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
const long long Mod=1e9+7;
long long T,n,a1,a2,x,y;
struct Matrix{
	long long M[5][5];
}A;//定义矩阵
long long OR[5][2],ans[5][2];

void mult(Matrix &B,Matrix C){
	Matrix D;
	memset(D.M,0,sizeof(D.M)); //记得初始化，不然后悔；
	for(register int i = 1 ; i <= 4 ; ++i){
		for(register int j = 1 ; j <= 4 ; ++j){
			for(register int k = 1 ; k <= 4 ; ++k){
				D.M[i][j]=(D.M[i][j]+(B.M[i][k]*C.M[k][j])%Mod)%Mod;
			}
		}
	}
	memcpy(B.M,D.M,sizeof(B.M));
}//矩阵乘法；

void Mqpow(Matrix &X,long long p){
	Matrix I;
	memset(I.M,0,sizeof(I.M));
	I.M[1][1]=I.M[2][2]=I.M[3][3]=I.M[4][4]=1;
	while(p){
		if(p&1)mult(I,X);
		mult(X,X);
		p>>=1;
	}
	memcpy(X.M,I.M,sizeof(X.M));
}//矩阵快速幂QAQ;

void solve(long long p){
	Mqpow(A,p);//去计算A矩阵的p次方（即n-1次方）；
	for(register int i = 1 ; i <= 4 ; ++i){
		for(register int j = 1 ; j <= 1 ; ++j){
			for(register int k = 1 ; k <= 4 ; ++k){
				ans[i][j]=(ans[i][j]+A.M[i][k]*OR[k][j])%Mod;
			}
		}
	}//最后要乘以最初的已知矩阵OR，不然结果错误哦QAQ;
}

int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld%lld%lld%lld",&n,&a1,&a2,&x,&y);
		memset(A.M,0,sizeof(A.M));
		A.M[1][1]=A.M[1][2]=A.M[4][2]=1;
		A.M[2][2]=(x*x)%Mod;A.M[2][3]=(2*x*y)%Mod;A.M[2][4]=(y*y)%Mod;
		A.M[3][2]=x;A.M[3][3]=y;//初始化我们的4*4矩阵
		OR[1][1]=(a1*a1)%Mod;OR[2][1]=(a2*a2)%Mod;OR[3][1]=(a2*a1)%Mod;OR[4][1]=(a1*a1)%Mod;//初始化我们的4*1已知矩阵；
		memset(ans,0,sizeof(ans));//初始化我们的最终的答案矩阵；
		solve(n-1);
		printf("%lld\n",ans[1][1]);//输出走人；
	}
	return 0;
}

```

---

## 作者：UperFicial (赞：2)

没想到吧，我今天下午才刚学的矩阵加速/流汗黄豆。

[题目传送门](https://www.luogu.com.cn/problem/P5175)

同步发表于我的 [$\text{cnblogs}$](https://www.cnblogs.com/UperFicial/p/16693560.html)

记 $s(n)$ 为答案，我们把 $s(n)$ 放到矩阵里：

$$
\begin{bmatrix}
s(n)\\ a_n  \\ a_{n-1}
\end{bmatrix}

$$

矩阵加速的特点是把下表为 $n$ 的元素都替换称已知。

$a_n$ 可以替换称 $a_{n-1}x+a_{n-2}y$，$s(n)$ 暴力展开就好了：

$$
\begin{aligned}
s(n)
&=s(n-1)+{a_n}^2\\
&=s(n-1)+\left(a_{n-1}x+a_{n-2}y\right)^2\\
&=s(n-1)+{a_{n-1}}^2x^2+2a_{n-1}a_{n-2}xy+{a_{n-2}}^2y^2
\end{aligned}
$$

这时候就都不含 $n$ 了，但是 ${a_{n-1}}^2$，${a_{n-1}}^2$ 和 $a_{n-1}a_{n-2}$ 不是我们直接能得到的，因为它们和已知项不齐次。

那么我们再把 ${a_{n}}^2$，$a_{n-1}^2$ 和 $a_{n}a_{n-1}$ 放入我们的矩阵中，不断完善矩阵：

$$
\begin{bmatrix}
s(n)\\ a_n  \\ a_{n-1}\\{a_{n}}^2\\{a_{n-1}}^2\\a_{n}a_{n-1}
\end{bmatrix}
$$

现在以此解决 ${a_n}^2$ 和 $a_na_{n-1}$。

${a_n}^2$ 我们直接暴力展开，${a_n}^2={a_{n-1}}^2x^2+2a_{n-1}a_{n-2}xy+{a_{n-2}}^2y^2$，都是已知的。

$a_na_{n-1}$ 也同理，将 $a_n$ 展开，得到 ${a_{n-1}}^2x+a_{n-1}a_{n-2}y$，也都是已知的。

那么我们就可以构造转移矩阵了。

$s(n)$ 的转移会用到 $s(n-1)$，${a_{n-1}}^2$，${a_{n-2}}^2$ 和 $a_{n-1}a_{n-2}$，系数分别为 $1,x^2,y^2,2xy$，所以转移矩阵的第一行为 $\begin{bmatrix}
 1 & 0 & 0 & x^2 & y^2 & 2xy
\end{bmatrix}$

剩下的转移我就不具体写了，都是同理的，最后构造出来的转移矩阵应该为：

$$
\begin{bmatrix}
1  & 0 & 0 & x^2 & y^2 & 2xy \\
0  & x & y & 0 & 0 & 0\\
0  & 1 & 0 & 0 & 0 & 0\\
0  & 0 & 0 & x^2 & y^2 & 2xy\\
0  & 0 & 0 & 1 & 0 & 0\\
0  & 0 & 0 & x & 0 & y
\end{bmatrix}
$$

直接算它 $n-2$ 次幂，然后与 $a_1,a_2$ 构造出来的初始矩阵相乘即可。

代码：

```cpp
ll n;
int a1,a2,X,Y;
const int MOD(1e9+7);

inline int add(int x,int y){return x+y>=MOD?x+y-MOD:x+y;}
inline int mul(int x,int y){return 1ll*x*y%MOD;}

struct Matrix
{
	int G[7][7];
	Matrix(){rep(i,1,6) rep(j,1,6) G[i][j]=0;return;}
	Matrix operator*(const Matrix&x)
	{
		Matrix res;
		rep(i,1,6) rep(j,1,6) rep(k,1,6) res.G[i][j]=add(res.G[i][j],mul(G[i][k],x.G[k][j]));
		return res;
	}
};

inline Matrix ksm(ll y)
{
	Matrix ans,x;
	rep(i,1,6) ans.G[i][i]=1;
	x.G[1][1]=1,x.G[1][4]=mul(X,X),x.G[1][5]=mul(Y,Y),x.G[1][6]=mul(2,mul(X,Y));
	x.G[2][2]=X,x.G[2][3]=Y;
	x.G[3][2]=1;
	x.G[4][4]=mul(X,X),x.G[4][5]=mul(Y,Y),x.G[4][6]=mul(2,mul(X,Y));
	x.G[5][4]=1;
	x.G[6][4]=X,x.G[6][6]=Y;
	while(y)
	{
		if(y&1) ans=ans*x;
		x=x*x;
		y>>=1; 
	}
	return ans;
	
}

int main()
{
	int T=read();
	while(T--)
	{
		scanf("%lld",&n);
		a1=read(),a2=read(),X=read(),Y=read();
		if(n==1) printf("%d\n",mul(a1,a1));
		else if(n==2) printf("%d\n",add(mul(a1,a1),mul(a2,a2)));
		else
		{
			Matrix ans=ksm(n-2);
			Matrix now;
			now.G[1][1]=add(mul(a1,a1),mul(a2,a2));
			now.G[2][1]=a2;
			now.G[3][1]=a1;
			now.G[4][1]=mul(a2,a2);
			now.G[5][1]=mul(a1,a1);
			now.G[6][1]=mul(a1,a2);
			ans=ans*now;
			printf("%d\n",ans.G[1][1]);
		}
	}

	return 0;
}
/*
Date : 2022/9/14
Author : UperFicial
Start coding at : 16:00
finish debugging at : 16:05
*/
```

---

## 作者：Su_Zipei (赞：2)

看到递推式+$10^{18}$的数据范围，很容易猜到这是一个矩阵快速幂优化数列递推。

首先矩阵是有结合率的，所以只要能够把这个递推式子的转移系数扔到一个矩阵里边，就能实现$log$的时间负责度以内的求值了。

还有一个注意的事情是放到矩阵里边的不仅要有数组$a$，还要有那个和式，~~不然$O(n)$算答案吗？~~
```cpp
/*
3
5 1 1 1 1
4 3 4 3 2
461564597527246 987489553 321654648 164165256 315648984
*/
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int n=4;
const int p=1e9+7;
ll Mat[5][5],ans[5];
void Mul(){
	ll tmp[5];
	for(int i=1;i<=n;i++){
		tmp[i]=0;
		for(int j=1;j<=n;j++){
			tmp[i]=(tmp[i]+ans[j]*Mat[i][j]%p)%p;
		}
	}
	memcpy(ans,tmp,sizeof(tmp));
}
void Mulself(){
	ll tmp[5][5];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			tmp[i][j]=0;
			for(int k=1;k<=n;k++){
				tmp[i][j]=(tmp[i][j]+Mat[i][k]*Mat[k][j]%p)%p;
			}
		}
	}
	memcpy(Mat,tmp,sizeof(tmp));
}
char buf[1<<20], *p1, *p2;
char gc() { return p1 == p2 ? p2 = buf + fread(p1 = buf, 1, 1<<20, stdin), (p1 == p2) ? EOF : *p1++ : *p1++; }
inline ll read(int f = 1, char c = gc(), ll x = 0) {
	while(c < '0' || c > '9') f = (c == '-') ? -1 : 1, c = gc();
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc();
	return f * x;
}
int main(){
	int T=read();
	while(T--){
		ll k=read(),a1=read(),a2=read(),x=read(),y=read();
		if(k==1){
			printf("%lld\n",a1*a1%p);
			continue;
		}
		k-=2;
		ans[1]=(a1*a1%p+a2*a2%p)%p;
		ans[2]=a2*a2%p;
		ans[3]=a1*a1%p;
		ans[4]=a1*a2%p;
		Mat[1][1]=1;Mat[1][2]=x*x%p;Mat[1][3]=y*y%p;Mat[1][4]=2*x*y%p;
		Mat[2][1]=0;Mat[2][2]=x*x%p;Mat[2][3]=y*y%p;Mat[2][4]=2*x*y%p;
		Mat[3][1]=0;Mat[3][2]=1;Mat[3][3]=0;Mat[3][4]=0;
		Mat[4][1]=0;Mat[4][2]=x;Mat[4][3]=0;Mat[4][4]=y;
		while(k){
			if(k&1)Mul();
			Mulself();
			k>>=1;
		}
		printf("%lld\n",ans[1]);
	}
}
```

---

## 作者：hwk0518 (赞：2)

介绍一种矩阵求逆的做法。

显然有：

$a_n=(x*a_{n-1}+y*a_{n-2})^2$

$=x^2*a_{n-1}^2+y^2*a_{n-2}^2+2*x*y*a_{n-1}*a_{n-2}$

$a_n*a_{n-1}=(a_{n-1}+a_{n-2})*a_{n-1}$

$=a_{n-1}^2+a_{n-1}*a_{n-2}$


于是构造出矩阵：

$\left[\begin{matrix}a_n^2 & a_{n-1}^2 & a_n*a_{n-1} \end{matrix}\right]$

$=\left[\begin{matrix}x^2 & y^2 & 2*x*y \\1 & 0 & 0 \\x & 0 & y\\ \end{matrix}\right]*\left[\begin{matrix}a_{n-1}^2 & a_{n-2}^2 & a_{n-1}*a_{n-2} \end{matrix}\right]$

设$\left[\begin{matrix}x^2 & y^2 & 2*x*y \\1 & 0 & 0 \\x & 0 & y\\ \end{matrix}\right]=A,\left[\begin{matrix}a_2^2 & a_1^2 & a_1*a_2 \end{matrix}\right]=D$。

设$E=D*\sum_{i=0 \to {n-2}}A^i$，

则$ans=E.a_{0,0}$。

而$E=D*\sum_{i=0 \to {n-2}}A^i$

$=D*\frac{A^{n-1}-I}{A-I}$。其中$I$表示单位矩阵。

矩阵求逆即可。

代码：

```

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const int mod=1e9+7;
const int N=3;

int T,x,y,a,b;
long long n;

struct mat
{
	int a[N][N];
};

namespace MATHEMATICS
{
	int add(int x,int y)
	{
		int ret=x+y;
		if(ret>=mod) ret-=mod;
		return ret;
	}
	int mi(int x,int y)
	{
		int ret=x-y;
		if(ret<0) ret+=mod;
		return ret;
	}
	
	void inc(int &x,int y)
	{
		x+=y;
		if(x>=mod) x-=mod;
	}
	void dec(int &x,int y)
	{
		x-=y;
		if(x<0) x+=mod;
	}
	
	int mul(int x,int y)
	{
		return 1LL*x*y%mod;
	}
	int F_p(int x,int y)
	{
		int bas=x,ret=1;
		while(y)
		{
			if(y&1) ret=mul(bas,ret);
			bas=mul(bas,bas);
			y>>=1;
		}
		return ret;
	}
}
using namespace MATHEMATICS;

namespace MATRIX_START
{
	void clear(mat &x)
	{
		int i,j;
		for(i=0;i<3;++i)
			for(j=0;j<3;++j)
				x.a[i][j]=0;
	}
	
	void reset(mat &x)
	{
		int i,j;
		for(i=0;i<3;++i)
			for(j=0;j<3;++j)
				x.a[i][j]=(i==j);
	}
	
	void print(mat x,char op)
	{
		int i,j;
		for(i=0;i<3;++i)
		{
			for(j=0;j<3;++j)
				printf("%d ",x.a[i][j]);
			printf("\n");
		}
		for(i=0;i<20;++i) printf("%c",op);printf("\n");
	}
}
using namespace MATRIX_START;

namespace MATRIX_INV
{
	void change_swap(mat &x,mat &y,int cl1,int cl2)
	{
		int i;
		for(i=0;i<3;++i)
			swap(x.a[cl1][i],x.a[cl2][i]),
			swap(y.a[cl1][i],y.a[cl2][i]);
	}
	
	void change_minus(mat &x,mat &y,int cl1,int cl2,int k)
	{
		int i;
		for(i=0;i<3;++i)
			dec(x.a[cl1][i],mul(x.a[cl2][i],k)),
			dec(y.a[cl1][i],mul(y.a[cl2][i],k));
	}
	
	void change_multiple(mat &x,mat &y,int cl1,int k)
	{
		int i;
		for(i=0;i<3;++i)
			x.a[cl1][i]=mul(x.a[cl1][i],k),
			y.a[cl1][i]=mul(y.a[cl1][i],k);
	}
	
	mat INV(mat x)
	{
		int i,j,k;
		mat ret;reset(ret);
		
		for(i=0;i<3;++i)
		{
			for(j=i;j<3;++j)
				if(x.a[j][i])
					break;
			if(j>i) change_swap(x,ret,i,j);
			int inv=F_p(x.a[i][i],mod-2);
			for(j=i+1;j<3;++j)
				change_minus(x,ret,j,i,mul(x.a[j][i],inv));
		//	print(x,'?');
		}
	//	print(x,'_'),print(ret,'_');
		
		for(i=1;~i;--i)
		{
			for(j=i+1;j<3;++j)
				if(x.a[i][j])
				{
					int mm=mul(F_p(x.a[j][j],mod-2),x.a[i][j]);
					change_minus(x,ret,i,j,mm);
				}
		}
		
		for(i=0;i<3;++i) change_multiple(x,ret,i,F_p(x.a[i][i],mod-2));
		
		return ret;
	}
}
using namespace MATRIX_INV;

namespace MATRIX_POW
{
	mat operator * (mat x,mat y)
	{
		mat ret;clear(ret);
		int i,j,k;
		for(i=0;i<3;++i)
			for(j=0;j<3;++j)
				for(k=0;k<3;++k)
					inc(ret.a[i][j],mul(x.a[i][k],y.a[k][j]));
		return ret;
	}
	
	mat fp(mat x,long long y)
	{
		mat bas=x,ret;reset(ret);
		while(y)
		{
			if(y&1) ret=ret*bas;
			bas=bas*bas;
			y>>=1;
		}
		return ret;
	}
}
using namespace MATRIX_POW;

void work()
{
	scanf("%lld%d%d%d%d",&n,&a,&b,&x,&y);
	if(n==1)
	{
		printf("%d\n",mul(a,a));
		return;
	}
	
	mat X;mat Y;mat Z;
	X.a[0][0]=mul(x,x),X.a[0][1]=mul(y,y),X.a[0][2]=mul(2,mul(x,y));
	X.a[1][0]=1,X.a[1][1]=X.a[1][2]=0;
	X.a[2][0]=x,X.a[2][1]=0,X.a[2][2]=y;
	Y=fp(X,n-1);for(int i=0;i<3;++i) dec(X.a[i][i],1);X=INV(X);
	
	int i;for(i=0;i<3;++i) dec(Y.a[i][i],1);
	Z=X*Y;//print(Z,'+');
	int ans=0;
	inc(ans,mul(a,a));
	inc(ans,mul(mul(b,b),Z.a[0][0]));
	inc(ans,mul(mul(a,a),Z.a[0][1]));
	inc(ans,mul(mul(a,b),Z.a[0][2]));
	printf("%d\n",ans);
}

int main()
{
	scanf("%d",&T);
	while(T--) work();
	return 0;
}

```

---

## 作者：Hadtsti (赞：1)

### 题意简述
给出数列 ${a_n}(1\le n\le10^{18})$ 的两项 $a_1,a_2$ 与递推公式 $a_n=xa_{n-1}+ya_{n-2}$，求：
$$S_n=\sum_{k=1}^{n}a_k^2\mod (10^9+7)$$

### 题目分析
一看见 $1\le n\le 10^{18}$，就大概能知道要用 $O(\log n)$ 级别的算法。再一看递推，就知道要用矩阵快速幂了。

题目所求的答案是前 $n$ 项的 $a_k^2$ 之和，如果我们能快速求出每个 $a_k^2$，那么再用矩阵快速幂递推求和是十分简单的。

注意到 $a_{k+1}=xa_k+ya_{k-1}$，那么就有 $a_{k+1}^2=x^2a_k^2+y^2a_{k-1}^2+2xya_{k}a_{k-1}$，如果我们维护了 $a_k^2$ 与 $a_{k-1}^2$，就可以递推地求出 $a_{k+1}^2,a_{k+2}^2$ 等等。

还没完，注意到 $a_{k+1}$ 展开后还有一项  $2xya_{k}a_{k-1}$，去掉系数就还剩下 $a_{k}a_{k-1}$。维护它应该怎么处理呢？将 $a_k$ 拆开得到 $a_{k}a_{k-1}=(xa_{k-1}+ya_{k-2})a_{k-1}=xa_{k-1}^2+ya_{k-1}a_{k-2}$，其中 $a_{k-1}^2$ 已经维护了，所剩的只有 $ya_{k-1}a_{k-2}$。这就意味着我们维护每一个 $a_{k}a_{k-1}$ 就可以求出 $a_{k+1}a_k$ 和 $a_{k+2}a_{k+1}$ 等等。

综上，我们使用答案矩阵 
$\begin{bmatrix}
S_{k}  & a_k^2 & a_{k-1}^2 & a_ka_{k-1}
\end{bmatrix}$ 进行维护。初始值为 
$\begin{bmatrix}
S_{2}=a_1^2+a_2^2  & a_2^2 & a_1^2 & a_2a_1
\end{bmatrix}$。

为了将其递推到 $\begin{bmatrix}
S_{k+1}  & a_{k+1}^2 & a_{k}^2 & a_{k+1}a_k
\end{bmatrix}$，需要有一个转移矩阵：
$$\begin{bmatrix}
1  & 0 & 0 & 0\\
x^2  & x^2 & 1 & x\\
y^2  & y^2 & 0 & 0\\
2xy  & 2xy & 0 & y
\end{bmatrix}$$

我们一列一列地进行解释。

对于第 $2$ 列，有 $a_{k+1}^2=0S_k+x^2a_k^2+y^2a_{k-1}^2+2xya_ka_{k-1}$。

那么对于第 $1$ 列，有 $S_{k+1}=S_k+a_{k+1}^2=1S_k+x^2a_k^2+y^2a_{k-1}^2+2xya_ka_{k-1}$。

对于第 $3$ 列，有 $a_k^2=0S_k+1a_k^2+0a_{k-1}^2+0a_ka_{k-1}$，没什么可解释的。

对于第 $4$ 列，有 $a_{k+1}a_k=0S_k+xa_k^2+0a_{k-1}^2+ya_ka_{k-1}$。

现在我们只需要计算出转移矩阵的 $n-2$ 次幂，再乘到答案矩阵上就好了。

需要注意的是要特判 $n=1$，否则会挂掉。然后就是该开 `long long` 的地方一定要开，不然也会挂。

分析一下时间复杂度。一次矩阵乘法是 $O(4^3)=O(64)$，因此矩阵快速幂的时间复杂度为 $O(64\log n)$，总复杂度为 $O(64T\log n)$，在 $T\le 3\times 10^4,1\le n\le 10^{18}$，时限 $1.50s$ 的情况下用个快读快写就可以过了。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1000000007;
int t;
long long n,x,y,a1,a2;
void rd(long long &x)
{
	x=0ll;
	char c=getchar();
	for(;c>'9'||c<'0';c=getchar());
	for(;c<='9'&&c>='0';c=getchar())
		x=(x<<3ll)+(x<<1ll)+c-'0';
}//long long快读 
void rd(int &x)
{
	x=0;
	char c=getchar();
	for(;c>'9'||c<'0';c=getchar());
	for(;c<='9'&&c>='0';c=getchar())
		x=(x<<3)+(x<<1)+c-'0';
}//int快读 
void pt(long long x)
{
	if(x>=10ll)
		pt(x/10ll);
	putchar(x%10ll+'0');
}//快写 
struct matrix
{
	int n,m;
	long long a[5][5];
	void init(long long k)
	{
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(i!=j)
					a[i][j]=0ll;
				else
					a[i][j]=k;
	}//初始化 k=0零矩阵，k=1单位矩阵 
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		c.n=a.n,c.m=a.m;
		c.init(0ll);
		for(int i=1;i<=a.n;i++)
			for(int k=1;k<=a.m;k++)
				for(int j=1;j<=b.m;j++)
					c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;
		return c;
	}//矩阵乘法 
	friend matrix operator ^(matrix a,long long b)
	{
		matrix res;
		res.n=res.m=a.n;
		res.init(1ll);
		for(;b;b>>=1ll)
		{
			if(b&1ll)
				res=res*a;
			a=a*a;
		}
		return res;
	}//矩阵快速幂 
}ans,trans;
int main()
{
	rd(t);
	while(t--)
	{
		rd(n),rd(a1),rd(a2),rd(x),rd(y);
		if(n==1ll)//特判 n=1，不然会 T 得很惨
		{
			pt(a1*a1%mod);
			putchar('\n');
			continue;
		}
		ans.n=1,ans.m=4;
		ans.a[1][1]=(a2*a2%mod+a1*a1%mod)%mod,ans.a[1][2]=a2*a2%mod,ans.a[1][3]=a1*a1%mod,ans.a[1][4]=a1*a2%mod;//初始化答案矩阵 
		trans.n=trans.m=4;
		trans.init(0ll);
		trans.a[2][1]=trans.a[2][2]=x*x%mod,trans.a[3][1]=trans.a[3][2]=y*y%mod,trans.a[4][1]=trans.a[4][2]=2ll*x*y%mod;
		trans.a[1][1]=trans.a[2][3]=1ll;
		trans.a[2][4]=x,trans.a[4][4]=y;//初始化转移矩阵 
		trans=trans^(n-2ll);//转移矩阵快速幂 
		ans=ans*trans;//答案矩阵乘上转移矩阵 
		pt(ans.a[1][1]);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：Transfixion_ (赞：1)

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P5175)

## $\textbf{Description}$
已知线性递推数列 $\{a_n\}$ 的前两项，且递推式为 $a_n = xa_{n - 1} + ya_{n - 2}(n\ge 3)$。


试求出：

$$\sum\limits_{i=1}^{n}a_i^2 \ \bmod \ (10^9+7)$$

多测，共 $T$ 组数据。

$\textbf{Data range : }$

$T\leq3\times10^4,1\le n \le 10^{18},1\le a_1,a_2 ,x,y \le 10^9$。

## $\textbf{Solution}$
线性递推数列，$n\leq 10^{18}$，显然矩阵快速幂。

注意到 $T\times\log n$ 已经很大了，因此构造的矩阵应该小一点。

我们先考虑如何用矩阵加速 $\{a_n^2\}$ 的递推。

用完全平方公式拆开：

$$\begin{aligned}a_n^2&=(xa_{n-1} + ya_{n-2})^2\\&=x^2a_{n-1}^2+y^2a_{n-2}^2+2xya_{n-1}a_{n-2}\end{aligned}$$

所以我们考虑构造 $\begin{bmatrix}a_{n}^2&a_{n-1}^2&a_{n}a_{n-1}\end{bmatrix}$。

转移矩阵中对于 $a_{n}^2$ 和 $a_{n-1}^2$ 的构造是平凡的，考虑如何用转移 $a_na_{n-1}$。

其实也很简单。直接将 $a_n=xa_{n-1}+ya_{n-2}$ 代入得到：

$$a_na_{n-1}=xa_{n-1}^2+ya_{n-1}a_{n-2}$$

于是

$$\begin{bmatrix}a_{n-1}^2&a_{n-2}^2&a_{n-1}a_{n-2}\end{bmatrix}\times\begin{bmatrix}x^2&1&x\\y^2&0&0\\2xy&0&y\end{bmatrix}=\begin{bmatrix}a_{n}^2&a_{n-1}^2&a_{n}a_{n-1}\end{bmatrix}$$

当然这并不是我们的最后答案。考虑往里面加一个 $\sum$。

我们记 $\operatorname{sum}(n)=\sum\limits_{i=1}^{n}a_i^2$。

那么我们考虑构造 $\begin{bmatrix}a_{n}^2&a_{n-1}^2&a_{n}a_{n-1}&\operatorname{sum}(n)\end{bmatrix}$。

转移矩阵对应该元素的列应该是四个非零数，可以 AC。

---

更优的做法是将 $\operatorname{sum}(n)$ 换成 $\operatorname{sum}(n-1)$，这样递推只需加上 $a_n^2$ 即可，转移矩阵对应列只有两个非零数。

然而并没有什么用，出题人不会在这种方面卡你。

记 $\operatorname{Mat}(n)=\begin{bmatrix}a_{n}^2&a_{n-1}^2&a_{n}a_{n-1}&\operatorname{sum}(n-1)\end{bmatrix}$。

$\textbf{Conclusion : }$

$$\operatorname{Mat}(n-1)\times\begin{bmatrix}x^2&1&x&1\\y^2&0&0&0\\2xy&0&y&0\\0&0&0&1\end{bmatrix}=\operatorname{Mat}(n)$$

$\textbf{Attention : }$

- 初始矩阵 $\begin{bmatrix}a_2^2&a_1^2&a_1a_2&a_1^2\end{bmatrix}$。

- 注意取模和 `long long`。


- 特判 $n=1$ 的情况。

## $\textbf{AC Code}$

```cpp
#include <bits/stdc++.h>
#define continue(x...) { x; continue; }
typedef long long i64;
constexpr int p = 1e9 + 7;

template<typename _Tp>struct Matrix {
	static constexpr int N = 4;
	
	int n, m; _Tp vec[N][N];
	
	Matrix(int n, int m) : n(n), m(m) {
		for(int i = 0; i < n; i++)
			for(int j = 0; j < m; j++)
				vec[i][j] = 0;
	}
	
	_Tp* const operator [] (const int idx) {
		return vec[idx];
	}
	
	Matrix operator * (const Matrix& rhs) const {
		Matrix res(n, rhs.m);
		for(int i = 0; i < n; i++) {
			for(int k = 0; k < m; k++) {
				const _Tp mlt = vec[i][k];
				if(mlt == 0) continue;
				for(int j = 0; j < rhs.m; j++) {
					res.vec[i][j] += mlt * rhs.vec[k][j] % p,
					res.vec[i][j] %= p;
				}
			}
		} return res;
	}
};

int T; i64 n, a1, a2, x, y;
Matrix<i64> base(4, 4), ans(1, 4);

inline void Init() {
	ans[0][0] = a2 * a2 % p, ans[0][1] = a1 * a1 % p, ans[0][2] = a1 * a2 % p, ans[0][3] = a1 * a1 % p;
	base[0][0] = x * x % p, base[0][1] = 1, base[0][2] = x, base[0][3] = 1;
	base[1][0] = y * y % p, base[1][1] = 0, base[1][2] = 0, base[1][3] = 0;
	base[2][0] = 2 * x * y % p, base[2][1] = 0, base[2][2] = y, base[2][3] = 0;
	base[3][0] = 0, base[3][1] = 0, base[3][2] = 0, base[3][3] = 1;
}

inline void Calc(Matrix<i64>& res) {
	for(n--; n; n >>= 1) {
		if(n & 1) res = res * base;
		base = base * base;
	} return ;
}

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	for(std::cin >> T; T--; ) {
		std::cin >> n >> a1 >> a2 >> x >> y;
		if(n == 1) continue(std::cout << a1 * a1 % p << '\n');
		Init(); Calc(ans); std::cout << ans[0][3] << '\n';
	}
	return 0;
}
```

---

## 作者：Leap_Frog (赞：1)

### P.S.
~~其实这只是笔者推式子时用的草稿纸~~  
[非常糟糕的阅读体验](https://www.luogu.com.cn/blog/daniu/solution-p5175)  
### Description.
略
### Solution.
| \ | $\sum_{i=1}^{n-1}a_i^2$ | $a_i^2$ | $a_{i-1}^2$ | $a_i$ | $a_{i-1}$ | $a_ia_{i-1}$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $\sum_{i=1}^na_i^2$ | $1$ | $1$ |  |  |  |  |
| $a_{i+1}^2$ |  | $x^2$ | $y^2$ |  |  | $2xy$ |
| $a_{i}^2$ |  | $1$ |  |  |  |  |
| $a_{i+1}$ |  |  |  | $x$ | $y$ |  |
| $a_i$ |  |  |  | $1$ |  |  |
| $a_{i+1}a_i$ |  | $x$ |  |  |  | $y$ |

初始矩阵：
| $\sum_{i=1}^{n-1}a_i^2$ | $a_i^2$ | $a_{i-1}^2$ | $a_i$ | $a_{i-1}$ | $a_ia_{i-1}$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $a_1^2$ | $a_2^2$ | $a_1^2$ | $a_2$ | $a_1$ | $a_1a_2$ |
然后直接矩乘转移就好了。。。
### Coding.
```cpp
//愿你和你重要的人能够重逢！
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<48||c>57;c=getchar()) if(!(c^45)) f=1;
	for(;c>=48&&c<=57;c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	f?x=-x:0;
}
const int P=1e9+7;
struct mat
{
	int a[7][7];
	inline void operator!() {memset(a,0,sizeof(a));}
	inline void operator~() {!*this;for(int i=1;i<=6;i++) a[i][i]=1;}
	inline mat operator*(mat b)
	{
		mat r;!r;
		for(int i=1;i<7;i++) for(int k=1;k<7;k++) for(int j=1;j<7;j++) (r.a[i][j]+=1ll*a[i][k]*b.a[k][j]%P)%=P;
		return r;
	}
	inline mat operator^(ll q) {mat x=*this,r;~r;for(;q;q>>=1,x=x*x) if(q&1) r=r*x;return r;}
}a;int T,a1,a2,x,y,res,cs[7];ll n;
signed main()
{
	for(read(T);T--;)
	{
		!a,read(n),read(a1),read(a2),read(x),read(y),res=0;
		a.a[1][1]=a.a[1][2]=1,a.a[2][2]=1ll*x*x%P,a.a[2][3]=1ll*y*y%P,a.a[2][6]=2ll*x*y%P;
		a.a[3][2]=1,a.a[4][4]=x,a.a[4][5]=y,a.a[5][4]=1,a.a[6][2]=x,a.a[6][6]=y;
		cs[1]=1ll*a1*a1%P,cs[2]=1ll*a2*a2%P,cs[3]=1ll*a1*a1%P,cs[4]=a2,cs[5]=a1,cs[6]=1ll*a1*a2%P;
		a=a^(n-1);for(int i=1;i<7;i++) (res+=1ll*cs[i]*a.a[1][i]%P)%=P;
		printf("%d\n",res);
	}
	return 0;
}
```

---

## 作者：seanlsy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5175)

**前置芝士**

矩阵加速，可以先做[这道题](https://www.luogu.com.cn/problem/P1939)。

**思路**

显然这题要建立一个包含表示 $\sum_{j=1}^ia_i^2$ 的 $s_i$，为了推出 $s_{i+1}$，显然这个矩阵里需要加入 $a_i^2$。

于是可以构造出这样的一个矩阵 $\begin{bmatrix}s_{i-1}\\a_i^2\end{bmatrix}$。

但是这样做的话似乎很难推出 $a_{i+1}^2$。

根据定义 $a_{i+1}=xa_i+ya_{i-1}$

代入得 $a_{i+1}^2=(xa_i+ya_{i-1})^2=x^2a_i^2+2xya_ia_{i-1}+y^2a_{i-1}^2$。

所以，我们还应在矩阵中加入 $a_{i-1}^2$ 和 $a_ia_{i-1}$。

这时候矩阵就变成了 $\begin{bmatrix}s_{i-1}\\a_i^2\\a_{i-1}^2\\a_ia_{i-1}\end{bmatrix}$。

此时 $\begin{bmatrix}s_i=1\times s_{i-1}+1\times a_i^2+0\times a_{i-1}^2+0\times a_ia_{i-1}\\a_{i+1}^2=0\times s_{i-1}+x^2\times a_i^2+y^2\times a_{i-1}^2+2xy\times a_ia_{i-1}\\a_i^2=0\times s_{i-1}+1\times a_i^2+0\times a_{i-1}^2+0\times a_ia_{i-1}\\a_ia_{i+1}=a_i(xa_i+ya_{i-1})=xa_i^2+ya_ia_{i-1}=0\times s_{i-1}+x\times a_i^2+0\times a_{i-1}^2+y\times a_ia_{i-1}\end{bmatrix}$

即 $\begin{bmatrix}1&1&0&0\\0&x^2&y^2&2xy\\0&1&0&0\\0&x&0&y\end{bmatrix}\times\begin{bmatrix}s_{i-1}\\a_i^2\\a_{i-1}^2\\a_ia_{i-1}\end{bmatrix} =\begin{bmatrix}s_i\\a_{i+1}^2\\a_i^2\\a_ia_{i+1}\end{bmatrix}$

在此基础上再套一个矩阵快速幂就行了，时间复杂度 $O(4^2T\log{n})$。

**CODE**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
#define mod 1000000007
inline int read(){
	int x=0;bool f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=0;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?x:-x;
}
inline void out(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) out(x/10);
	putchar(x%10|48);
}
int t,n,a1,a2,x,y;
struct jz{
    int a[4][4];
}base,xx;
inline jz mul(jz x,jz y){
    jz z;
    memset(z.a,0,sizeof(z.a));
    for(int k=0;k<4;k++)
        for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)
                z.a[i][j]+=(x.a[i][k]*y.a[k][j]%mod),z.a[i][j]%=mod;
    return z;
}//乘法
inline jz Pow(jz x,int y){
    jz res=x;
    for(y--;y;x=mul(x,x),y>>=1)
        if(y&1)
            res=mul(res,x);
    return res;
}//一个很奇怪的快速幂
signed main(){
	t=read();
	while(t--){
		n=read(),a1=read(),a2=read(),x=read(),y=read();
		if(n==1){
			out(a1*a1%mod),putchar(10);
			continue;
		}
		memset(base.a,0,sizeof(base.a));
		memset(xx.a,0,sizeof(xx.a));
		base.a[0][0]=base.a[2][0]=a1*a1%mod,
		base.a[1][0]=a2*a2%mod,
		base.a[3][0]=a1*a2%mod,
		xx.a[0][0]=xx.a[0][1]=xx.a[2][1]=1,
		xx.a[1][1]=x*x%mod,xx.a[1][2]=y*y%mod,
		xx.a[1][3]=2*x*y%mod,xx.a[3][1]=x,xx.a[3][3]=y;
		base=mul(Pow(xx,n-1),base);//注意矩阵乘法不满足交换律
		out(base.a[0][0]),putchar(10);
	}
	return 0;
}
```


---

## 作者：Seqfrel (赞：0)

# 题解：P5175 数列

#### 前置知识：递推、矩阵乘法、矩阵快速幂、完全平方公式。

## 题目大意

给定一个递推式 $a_n=x \times a_{n-1}+ y \times a_{n-2}(n≥3)$，求 $\sum_{i=1}^na_i^2$。

## 解题思路

递推通常是 $O(n)$ 解法，但是本题 $1 \le n \le 10^{18}$ 且 $T=30000$（注意是等于），所以一定会超时。这里就要用到矩阵快速幂进行优化。

定义 $f(n)$ 表示 $a_n$，$s(n)$ 表示 $\sum_{i=1}^na_i^2$，则可以根据完全平方公式写出递推式：

$f(n)=xf(n-1)+yf(n-2)$

$f(n)^2=(xf(n-1)+yf(n-2))=x^2f(n-1)^2+y^2f(n-2)^2+2xyf(n-1)f(n-2)$

$f(n)f(n-1)=xf(n-1)^2+yf(n-1)f(n-2)$

$s(n)=s(n-1)+f(n)^2$

接下来我们构造状态矩阵。我们发现求 $s(n)$ 需要用到四个值：$s(n-1)$、$f(n-1)^2$、$f(n-2)^2$、$f(n-1)f(n-2)$，所以我们构造两个状态矩阵：

$$\begin{bmatrix} s(n) & f(n)^2 & f(n-1)^2 & f(n)f(n-1) \end{bmatrix} = \begin{bmatrix} s(n-1) & f(n-1)^2 & f(n-2)^2 & f(n-1)f(n-2) \end{bmatrix} \times A$$

而这个 $A$ 矩阵就是我们要求的转移矩阵。要想求 $A$ 矩阵，我们先将第一个矩阵的每一项带入刚才求得的递推式来求用第二个矩阵的全部项求第一个矩阵的那一项所需要乘的系数，也就是如何转移：

#### 第一项

$s(n)=s(n-1) \times 1 + f(n-1)^2 \times x^2 + f(n-2)^2 \times y^2 + f(n-1)f(n-2) \times 2xy$

#### 第二项

$f(n)^2=s(n-1) \times 0 + f(n-1)^2 \times x^2 + f(n-2)^2 \times y^2 + f(n-1)f(n-2) \times 2xy$

#### 第三项

$f(n-1)^2=s(n-1) \times 0 + f(n-1)^2 \times 1 + f(n-2)^2 \times 0 + f(n-1)f(n-2) \times 0$

#### 第四项

$f(n)f(n-1)=s(n-1) \times 0 + f(n-1)^2 \times x + f(n-2)^2 \times 0 + f(n-1)f(n-2) \times y$

那么我们把这些系数按矩阵乘法的运算方式一列一列填进矩阵 $A$ 里，就求出了 $A$。

$$A=\begin{bmatrix} 1 & 0 & 0 & 0 \\ x^2 & x^2 & 1 & x \\ y^2 & y^2 & 0 & 0 \\ 2xy & 2xy & 0 & y \end{bmatrix}$$

因为 $n=1$ 和 $n=2$ 时的矩阵是需要单独求的，所以最终的式子是：

$$\begin{bmatrix} s(n) & f(n)^2 & f(n-1)^2 & f(n)f(n-1) \end{bmatrix} = \begin{bmatrix} s(2) & f(2)^2 & f(1)^2 & f(2)f(1) \end{bmatrix} \times \begin{bmatrix} 1 & 0 & 0 & 0 \\ x^2 & x^2 & 1 & x \\ y^2 & y^2 & 0 & 0 \\ 2xy & 2xy & 0 & y \end{bmatrix}^{n-2}$$

然后套矩阵快速幂的板子即可。

## 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long //这里图方便就这样写了。平时不建议这样写。
using namespace std;
const int p=1e9+7; //要取模的数。
struct Matrix{ //矩阵。
	int mx[5][5];
}a,s,c;
int T,n,k,f1,f2,x,y;
Matrix operator *(const Matrix &a,const Matrix &b){ //乘法运算符重载为矩阵乘法。注意它只会对指定的结构体生效。
	memset(c.mx,0,sizeof(c.mx));
	for(int i=1;i<=4;i++){
		for(int j=1;j<=4;j++){
			for(int d=1;d<=4;d++){
				c.mx[i][j]=(c.mx[i][j]%p+(a.mx[i][d]*b.mx[d][j])%p)%p;
			}
		}
	}
	return c;
}
signed main(){
	cin>>T;
	while(T--){
		memset(s.mx,0,sizeof(s.mx)); //清空矩阵。
		memset(a.mx,0,sizeof(a.mx));
		scanf("%lld%lld%lld%lld%lld",&n,&f1,&f2,&x,&y);
		f1%=p;f2%=p;x%=p;y%=p;
		for(int i=1;i<=4;i++) s.mx[i][i]=1; //初始化矩阵。s是单位矩阵，a是转移矩阵。
		a.mx[1][1]=a.mx[2][3]=1;
		a.mx[2][1]=a.mx[2][2]=x*x%p;
		a.mx[3][1]=a.mx[3][2]=y*y%p;
		a.mx[4][1]=a.mx[4][2]=2*x*y%p;
		a.mx[2][4]=x;a.mx[4][4]=y;
		if(n==1) printf("%lld\n",(f1*f1)%p); //特殊情况的判定。
		else if(n==2) printf("%lld\n",(f1*f1%p+f2*f2%p)%p);
		else{
			int s2=(f1*f1%p+f2*f2%p)%p; //求出n=2时的矩阵。
			int f22=(f2*f2)%p;
			int f11=(f1*f1)%p;
			int f12=(f1*f2)%p;
			n-=2;
			while(n){
				if(n&1) s=s*a;
				a=a*a;
				n>>=1;
			}
			printf("%lld\n",(((s2*s.mx[1][1])%p+(f22*s.mx[2][1]))%p+((f11*s.mx[3][1])%p+(f12*s.mx[4][1])%p)%p)%p);
		}
	}
	return 0;
}
```

时间复杂度为 $O(T\log n \times m^3)$，$m$ 为矩阵边长也就是 $4$。

## 注意事项

- 记得开 `long long`。
- 记得随时取模。
- 记得不要取模 $n$（我在这里卡了很长时间，绷）。
- 记得输出一般情况时乘上 $n=2$ 时的状态矩阵。
- 常数时间复杂度较高，需要卡常。比如：如果用 `memset` 清空的话矩阵不要开太大、使用 `scanf` 和 `printf` 进行输入输出（或快读）等。

---

## 作者：Milthm (赞：0)

这题有递推式，$n$ 巨大，鉴定为：矩阵加速。

因为 $a_n^2=(xa_{n-1}+ya_{n-2})^2=x^2a_{n-1}^2+y^2a_{n-2}^2+2xya_{n-1}a_{n-2}$

所以考虑维护 $4$ 个东西：$a_{n-2}^2,a_{n-1}^2,a_{n-2}a_{n-1},S_{n-1}$，其中 $S_{n-1}$ 用于记录答案。

那么 $a_{n-2}^2,a_{n-1}^2$ 都十分容易转移到下一个状态，但 $a_{n-2}a_{n-1}$ 怎么办？考虑展开，因为 $a_{n-1}a_{n}=a_{n-1}(xa_{n-1}+ya_{n-2})=xa_{n-1}^2+ya_{n-2}a_{n-1}$，又因为这两个都在状态里，所以直接转移即可。

矩阵转移方程如下：

$$\begin{bmatrix}a_{n-2}^2&a_{n-1}^2&a_{n-2}a_{n-1}&S_{n-1} \end{bmatrix}\times\begin{bmatrix}0&y^2&0&y^2\\1&x^2&x&x^2\\
0&2xy&y&2xy\\
0&0&0&1\end{bmatrix}=\begin{bmatrix}a_{n-1}^2&a_{n}^2&a_{n-1}a_{n}&S_n \end{bmatrix}$$

然后就快乐的 AC 了，注意取模。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,a1,a2,x,y,n=4,m;
const int mod=1e9+7;
struct ma{
	int x[5][5];
	void clear(){
		memset(x,0,sizeof(x));
	}
}A,ans;
ma operator*(ma a,ma b){
	ma c;c.clear();
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			for(int k=1;k<=n;++k){
				c.x[i][j]=(c.x[i][j]+a.x[i][k]*b.x[k][j])%mod;
			}
		}
	}
	return c;
}
signed main(){
	cin>>T;
	while(T--){
		cin>>m>>a1>>a2>>x>>y;
		A.clear();ans.clear();
		if(m==1)cout<<a1*a1%mod<<'\n';
		else if(m==2)cout<<(a1*a1+a2*a2)%mod<<'\n';
		else{
			m-=2;
			ans.x[1][1]=a1*a1%mod;ans.x[1][2]=a2*a2%mod;
			ans.x[1][3]=a1*a2%mod;ans.x[1][4]=(a1*a1+a2*a2)%mod;
			A.x[1][2]=A.x[1][4]=y*y%mod;
			A.x[2][1]=A.x[4][4]=1;
			A.x[2][2]=A.x[2][4]=x*x%mod;
			A.x[2][3]=x;A.x[3][3]=y;
			A.x[3][2]=A.x[3][4]=2*x*y%mod;
			while(m){
				if(m&1)ans=ans*A;
				A=A*A;m>>=1;
			} 
			cout<<ans.x[1][4]<<'\n';
		}
	}
	return 0;
}

```

~~这也配紫？~~

---

## 作者：toolazy (赞：0)

欢迎欢迎！介里系蒟蒻の第二篇矩阵快速幂！

如果您感兴趣，介里还有另外一道矩阵快速幂的[好题](https://www.luogu.com.cn/problem/CF392C)，我的题解请 [click here~](https://www.luogu.com.cn/blog/yeegejb/solution-cf392c)

~~个人感觉是㵘爆了，建议评蓝~~，但是是道好题！$5\operatorname{mins}$ 切了（逃

---

还是那句话：见数据范围知 **矩阵快速幂**！

但问题也依旧还是那个问题：矩阵快速幂只能解决 **线性递推** 呀！如果这道题问的是 $\sum_{i=1}^na_i$ 的话那就是板板板，但是它问的是 **平方和**，咋办捏？

还是老办法：拆！直接用咱们~~幼儿园~~初中学的完全平方公式就好了：

$$\color{red}a_i^n\color{black}=x^2\color{red}a_{i-1}^2\color{black}+y^2\color{red}a_{i-2}^2\color{black}+2xy\color{blue}a_{i-1}a_{i-2}$$

黑色的 **系数** 是常数，可以提前计算；红色的 **平方项** 是转移参数，可以看到的是需要 **保留前两项** 才能递推；唯一的问题就在于蓝色的 **中间项**，咋转移捏？

还是老办法$\times2$：继续拆！

$$\color{blue}a_{i-1}a_{i-2}\color{black}=(xa_{i-2}+ya_{i-3})a_{i-2}=x\color{red}a_{i-2}^2\color{black}+y\color{blue}a_{i-2}a_{i-3}$$

嘿嘿嘿，这不就全都有了嘛：

$$
\begin{bmatrix}
\operatorname{sum}_{i-1}&a_{i-1}^2&a_{i-2}^2&a_{i-1}a_{i-2}
\end{bmatrix}
\cdot
\begin{bmatrix}
1&0&0&0\\
x^2&x^2&1&x\\
y^2&y^2&0&0\\
2xy&2xy&0&y
\end{bmatrix}
=
\begin{bmatrix}
\operatorname{sum}_i&a_i^2&a_{i-1}^2&a_ia_{i-1}
\end{bmatrix}
$$

最后是公示代码环节~ ~~我才不会告诉你这代码是我从我上面的那片题解复制过来的呢~~

```cpp
#include <iostream>
#include <cstring>
using namespace std;

#define int unsigned long long
#define mod 1000000007

#define MATRIXSIZE 5
struct matrix {
	int m[MATRIXSIZE][MATRIXSIZE], w, h;
	matrix(int width, int height) : w(width), h(height) {
		memset(m, 0, sizeof(m));
	}
	int * operator [] (int p) {
		return m[p];
	}
	matrix operator * (matrix x) const {
		matrix res(x.w, h);
		for (int a = 1; a <= h; a ++)
			for (int b = 1; b <= x.w; b ++)
				for (int c = 1; c <= w; c ++)
					res[a][b] = (res[a][b] +
						m[a][c] * x[c][b] % mod) % mod;
		return res;
	}
	matrix operator ^ (int k) const {
		matrix res(w, w), times(*this);
		for (int i = 1; i <= w; i ++)
			res[i][i] = 1;
		while (k) {
			if (k & 1)
				res = res * times;
			times = times * times;
			k >>= 1;
		}
		return res;
	}
	void output() const {
		cout << "width: " << w << endl;
		cout << "height: " << h << endl;
		for (int i = 1; i <= h; i ++) {
			cout << "[ ";
			for (int j = 1; j <= w; j ++)
				cout << m[i][j] << ' ';
			cout << ']' << endl;
		}
	}
};

int T, n, a1, a2, x, y;

int solvo() {
	if (n == 1)
		return a1 * a1 % mod;
	if (n == 2)
		return (a1 * a1 % mod + a2 * a2 % mod) % mod;
	
	n -= 2;
	matrix start(4, 1), step(4, 4);
	
	start[1][2] = a2 * a2 % mod;
	start[1][3] = a1 * a1 % mod;
	start[1][4] = a1 * a2 % mod;
	start[1][1] = (start[1][2] + start[1][3]) % mod;
	
	step[1][1] = 1;
	step[2][1] = step[2][2] = x * x % mod;
	step[3][1] = step[3][2] = y * y % mod;
	step[4][1] = step[4][2] = ((x * y % mod) << 1) % mod;
	step[2][4] = x, step[4][4] = y;
	step[2][3] = 1;
	
	start = start * (step ^ n);
//	start.output();
	return start[1][1];
}

main() {
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> T;
	while (T --) {
		cin >> n >> a1 >> a2 >> x >> y;
		cout << solvo() << endl;
	}
	return 0;
}
```

---

## 作者：STUDENT00 (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P5175)

# 引文：

关于这类题，有一个通用的解法：扩建矩阵。即初始矩阵只有一个值 $ans_i$，考虑如何实现 ```{ans[i-1]}``` 至 ```{ans[i]}``` 的转移。一个显而易见的想法是：据原题给出的关系式在矩阵中添加元素，而这些新元素可能也无法直接衔接，于是需要再次添加……这听上去十分玄乎，别慌，接下来我就本题的例子详细讲讲。

# 正文：

见引文，$ans_i=\sum\limits_{j=1}^{i}a_j$，需实现转移：

```
{ans[i-1]}->
{ans[i]  }
```

已知关系式 $ans_i=ans_{i-1}+a_i^2$，于是在矩阵中添加新元素 $a_{i+1}^2$：

```
{ans[i-1], a[i]*a[i]   } ->
{ans[i],   a[i+1]*a[i+1}
```

这时 $ans_i$ 可由 $ans_{i-1}$ 与 $a_i^2$ 推出，可 $a_{i+1}^2$ 仍毫无着落。手推一波式子：

$a_{i+1}^2=(xa_i+ya_{i-1})^2=x^2a_i^2+y^2a_{i-1}^2+2xya_ia_{i-1}$。

于是在矩阵中添加新元素：$a_{i+1}^2$ （已添过），$a_i^2$ 与 $a_{i+1}a_i$：

```
{ans[i-1], a[i]*a[i],     a[i-1]*a[i-1], a[i]*a[i-1]} ->
{ans[i],   a[i+1]*a[i+1], a[i]*a[i],     a[i+1]*a[i]}
```

这时 $a_{i+1}^2$ 可由 $a_i^2$，$a_{i-1}^2$ 与 $a_ia_{i-1}$ 推出，$a_i^2$ 可由 $a_i^2$ 推出，可 $a_{i+1}a_i$ 仍毫无着落。仍旧手推一波式子：

$a_{i+1}a_i=(xa_i+ya_{i-1})a_i=xa_i^2+ya_{i-1}a_i$。

我们发现，$a_{i+1}a_i$ 可由 $a_i^2$ 与 $a_{i-1}a_i$ 推出，故无需添加，最终矩阵构建完毕！

转移矩阵就很简单啦！

```
1 0     0 0
1 x*x   1 x
0 y*y   0 0
0 2*x*y 0 y
```

于是我们跑个矩阵快速幂，即可 $\green{AC}$ 此题！

需要代码的请自取：

```cpp
#include<bits/stdc++.h>
using namespace std;
//8K快读，略。
const int mod=1e9+7; 
typedef long long ll;
int T,a1,a2,x,y;
ll n;
struct Matrix{
	int a[4][4];
	void init(){
		for(register int i=0;i<4;i++) for(register int j=0;j<4;j++) a[i][j]=(i==j);
	}
	void operator*=(const Matrix &A){
		Matrix none;
		memset(none.a,0,sizeof(none.a));
		for(register int i=0;i<4;i++) for(register int j=0;j<4;j++) for(register int k=0;k<4;k++) none.a[i][k]=(none.a[i][k]+(ll)a[i][j]*A.a[j][k])%mod;
		swap(a,none.a);
	}
};
Matrix qpow(Matrix A,ll b){
	Matrix res;res.init();
	while(b){
		if(b&1) res*=A;
		A*=A;
		b>>=1;
	}
	return res;
}
void calc(){
	Matrix A;
	A.a[0][0]=1,A.a[0][1]=0,A.a[0][2]=0,A.a[0][3]=0;
	A.a[1][0]=1,A.a[1][1]=(ll)x*x%mod,A.a[1][2]=1,A.a[1][3]=x;
	A.a[2][0]=0,A.a[2][1]=(ll)y*y%mod,A.a[2][2]=0,A.a[2][3]=0;
	A.a[3][0]=0,A.a[3][1]=2ll*x*y%mod,A.a[3][2]=0,A.a[3][3]=y; 
	A=qpow(A,n-1);
	io.writeln(((ll)a1*a1%mod*A.a[0][0]%mod+
					(ll)a2*a2%mod*A.a[1][0]%mod+
					(ll)a1*a1%mod*A.a[2][0]%mod+
					(ll)a1*a2%mod*A.a[3][0]%mod)%mod);
}
int main(){
	io.read(T);
	while(T--){
		io.read(n,a1,a2,x,y);
		calc();
	}
	return 0;
}
```

---

## 作者：RP_INT_MAX (赞：0)

看了前几篇题解全部是 $4 \times 4$ 矩阵的做法，较为同质化，补一篇 $6 \times 6$ 的。

另外，第一篇题解说：边长大于 $4$ 的矩阵是无法接受的，在此勘误。

## $\tt Solution$

以下记 $s_i=\displaystyle\sum_{i=1}^{n}{a_i}^2$。先推一下式子。由题意得平方式，暴力展开。

$$
\begin{aligned}
s_{n} &= s_{n-1}+{a_i}^2 \\
      &= s_{n-1}+(xa_{n-1}+ya_{n-2})^2 \\
      &= s_{n-1}+x^2{a_{n-1}}^2+y^2{a_{n-2}}^2+2xya_{n-1}a_{n-2}
\end{aligned}
$$

欲计算 $s_n$，则必须知道 ${a_n}^2,{a_{n-1}}^2$ 和 $a_{n}a_{n-1}$。

$$
\begin{aligned}
{a_{n}}^2 &= (xa_{n-1}+ya_{n-2})^2 \\
          &= x^2{a_{n-1}}^2+y^2{a_{n-2}}^2+2xya_{n-1}a_{n-2}
\end{aligned}
$$

则 ${a_n}^2$ 和 ${a_{n-1}}^2$ 可求。而：

$$
\begin{aligned}
a_{n}a_{n-1} &= (xa_{n-1}+ya_{n-2})a_{n-1} \\
             &= x{a_{n-1}}^2+ya_{n-1}a_{n-2}
\end{aligned}
$$

构造出答案矩阵 $T$ 如下：

$$
T=
\begin{bmatrix}
s_{n}\\
a_{n}\\
a_{n-1}\\
{a_{n}}^2\\
{a_{n-1}}^2\\
a_{n}a_{n-1}
\end{bmatrix}
$$

再根据上面推的式子，用列表法构造出转移矩阵 $S$。

$$
S=
\begin{bmatrix}
1 & 0 & 0 & x^2 & y^2 & 2xy\\
0 & x & y & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & x^2 & y^2 & 2xy\\
0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & x & 0 & y
\end{bmatrix}
$$

计算 $S^{n-2} \times T$ 即可。

总结下这题的易错点。

- 主要难度在于平方和。因此不应只关注一次项，而是将二次项也放进答案矩阵。

- $6 \times 6$ 矩阵做法时间较紧。代码中矩阵应当使用 `int` 类型，在适当位置加 `1LL*` 即可。并稍卡卡常。

- 勤取模。否则容易爆。

- 不要忘记特判掉 $n=1$ 和 $n=2$ 的情况。

## $\tt Code$

```cpp
#include <bits/stdc++.h>
//#define int long long
#define mem(a,b) memset(a,b,sizeof a)
#define cases int _t;cin>>_t;while(_t--)
#define for1(i,a,b) for(int i=(a);i<=(b);++i)
#define for2(i,a,b) for(int i=(a);i>=(b);--i)
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
typedef long long ll;
const int mod=1e9+7;
int __(const int&a,const int&b) {return a+b>=mod?a+b-mod:a+b;}
int _(const int&a,const int&b) {return 1LL*a*b%mod;}
struct M
{ int a[6][6];
  M() {for1(i,0,5) for1(j,0,5) a[i][j]=0;}
  M operator*(const M&x)const
  { M ret;
    for1(i,0,5) for1(j,0,5) for1(k,0,5)
      ret.a[i][j]=__(ret.a[i][j],_(a[i][k],x.a[k][j]));
    return ret;
  }
};
M qp(M a,ll b)
{ M ret;
  for1(i,0,5) ret.a[i][i]=1;
  while(b) {if(b&1) ret=ret*a;a=a*a,b>>=1;}
  return ret;
}
signed main ()
{ IOS;
  cases
  { ll n;
    int a1,a2,x,y;
    cin>>n>>a1>>a2>>x>>y;
    if(n==1) {cout<<_(a1,a1)<<endl;continue;}
    if(n==2) {cout<<__(_(a1,a1),_(a2,a2))<<endl;continue;}
    M base;
    base.a[0][0]=1,base.a[0][3]=_(x,x),base.a[0][4]=_(y,y),base.a[0][5]=_(2,_(x,y));
    base.a[1][1]=x,base.a[1][2]=y;
    base.a[2][1]=1;
    base.a[3][3]=_(x,x),base.a[3][4]=_(y,y),base.a[3][5]=_(2,_(x,y));
    base.a[4][3]=1;
    base.a[5][3]=x,base.a[5][5]=y;
    M ans=qp(base,n-2),T;
    T.a[0][0]=__(_(a1,a1),_(a2,a2));
    T.a[1][0]=a2;
    T.a[2][0]=a1;
    T.a[3][0]=_(a2,a2);
    T.a[4][0]=_(a1,a1);
    T.a[5][0]=_(a1,a2);
    ans=ans*T;
    cout<<ans.a[0][0]<<endl;
  }
  return 0;
}
```

---

## 作者：User_Authorized (赞：0)

## 题意
一个数列 $a_n $，已知 $a_1$ 及 $a_2$ 两项。

且该数列满足递推式 

$$a_n = x \cdot a_{n-1} + y \cdot a_{n-2}(n \ge 3)$$

求 

$$\sum\limits_{i = 1}^n a_i^2 \bmod 10^9 + 7$$

## 题解
考虑矩阵优化递推，首先考虑递推式

$$\begin{aligned}
a_n^2 &= \left(x \cdot a_{n - 1} + y \cdot a_{n - 2}\right)^2 \\
&= x^2 \cdot a_{n - 1}^2 + y^2 \cdot a_{n - 2}^2 + 2xy\cdot a_{n - 1} a_{n - 2}
\end{aligned}$$

对于转移 $a_{n - 1}^2$ 等显然是平凡的，下面考虑如何转移 $a_{n - 1}a_{n - 2}$

$$\begin{aligned}
a_{n - 1} a_{n - 2} &= \left(x \cdot a_{n - 2} + y \cdot a_{n - 3}\right) a_{n - 2} \\
&= x \cdot a_{n - 2}^2 + y \cdot a_{n - 2} a_{n - 3}
\end{aligned}$$

这样我们就可以使用矩阵进行转移了，设 $S_n = \sum\limits_{i = 1}^{n}$，那么有初始矩阵

$$\begin{bmatrix}
a_2^2 & a_1^2 & a_1 a_2 & S_1
\end{bmatrix}$$

转移矩阵

$$\begin{bmatrix}
x^2 & 1 & x & 1\\
y^2 & 0 & 0 & 0\\
2xy & 0 & y & 0\\
0 & 0 & 0 & 1
\end{bmatrix}$$

总复杂度 $\mathcal{O}(\log n)$，可以通过本题。

## Code
```cpp
//Luogu - P5175
#include<bits/stdc++.h>

typedef long long valueType;

constexpr valueType MOD = 1e9 + 7;

class Matrix {
public:
    typedef long long valueType;
    typedef size_t sizeType;
    typedef std::vector<valueType> Row;
    typedef std::vector<Row> Container;

    enum TYPE : int {
        EMPTY = 0, UNIT = 1
    };

private:
    sizeType _row_, _column_;
    Container data;

public:
    Matrix(sizeType row, sizeType column) : _row_(row), _column_(column), data(_row_) {
        for (auto &iter: data)
            iter.resize(column, 0);
    };

    sizeType row() const {
        return _row_;
    }

    sizeType column() const {
        return _column_;
    }

    void set(TYPE type) {
        for (auto &iter: data) {
            std::fill(iter.begin(), iter.end(), 0);
        }

        if (type == EMPTY)
            return;

        if (type == UNIT)
            for (sizeType i = 0, end = std::min(_row_, _column_); i < end; ++i)
                data[i][i] = 1;
    }

    valueType &operator()(sizeType i, sizeType j) {
        if (i > this->_row_ || j > this->_column_)
            throw std::out_of_range("Too Large.");

        if (i == 0 || j == 0)
            throw std::out_of_range("0 index access.");

        return std::ref(data[i - 1][j - 1]);
    }

    Matrix operator+(const Matrix &T) const {
        if (this->_row_ != T._row_ || this->_column_ != T._column_)
            throw std::range_error("Illegal operation.");

        Matrix result(this->_row_, this->_column_);

        for (sizeType i = 0; i < this->_row_; ++i)
            for (sizeType j = 0; j < this->_column_; ++j)
                result.data[i][j] = (this->data[i][j] + T.data[i][j]) % MOD;

        return result;
    }

    Matrix operator*(const Matrix &T) const {
        if (this->_column_ != T._row_)
            throw std::range_error("Illegal operation.");

        Matrix result(this->_row_, T._column_);

        for (sizeType i = 0; i < this->_row_; ++i) {
            for (sizeType k = 0; k < this->_column_; ++k) {
                valueType r = this->data[i][k];

                for (sizeType j = 0; j < T._column_; ++j)
                    result.data[i][j] = (result.data[i][j] + T.data[k][j] * r) % MOD;
            }
        }

        return result;
    }

    Matrix operator^(valueType x) const {
        if (x < 1)
            throw std::range_error("Illegal operation.");

        Matrix result(this->_row_, this->_column_);
        Matrix base = *this;

        result.set(UNIT);

        while (x) {
            if (x & 1) result = result * base;

            base = base * base;

            x = x >> 1;
        }

        return result;
    }

    friend std::ostream &operator<<(std::ostream &os, const Matrix &T) {
        for (sizeType i = 0; i < T._row_; ++i)
            for (sizeType j = 0; j < T._column_; ++j)
                os << T.data[i][j] << " \n"[j == T._column_ - 1];

        return os;
    }

    friend std::istream &operator>>(std::istream &os, Matrix &T) {
        for (sizeType i = 0; i < T._row_; ++i)
            for (sizeType j = 0; j < T._column_; ++j)
                os >> T.data[i][j];

        return os;
    }
};

int main() {
	valueType T;
	
	std::cin >> T;
	
	for(valueType i = 0; i < T; ++i) {
		valueType n, a1, a2, x, y;
		
		Matrix base(4, 4), ans(1, 4);
		
		std::cin >> n >> a1 >> a2 >> x >> y;
		
		if(n == 1) {
			std::cout << (a1 * a1) % MOD << '\n';
			
			continue;
		} else if(n == 2) {
			std::cout << (a1 * a1 + a2 * a2) % MOD << '\n';
			
			continue;
		}
		
		ans(1, 1) = a2 * a2 % MOD;
		ans(1, 2) = a1 * a1 % MOD;
		ans(1, 3) = a1 * a2 % MOD;
		ans(1, 4) = a1 * a1 % MOD;
		
		base(1, 1) = x * x % MOD;
		base(2, 1) = y * y % MOD;
		base(3, 1) = 2 * x * y % MOD;
		base(4, 1) = 0;
		
		base(1, 2) = 1;
		base(2, 2) = base(3, 2) = base(4, 2) = 0;
		
		base(1, 3) = x;
		base(3, 3) = y;
		base(2, 3) = base(4, 3) = 0;
		
		base(1, 4) = base(4, 4) = 1;
		base(2, 4) = base(3, 4) = 0;

		ans = ans * (base ^ (n - 1));
		
		std::cout << ans(1, 4) << '\n';
	}
	
	std::cout << std::flush;
	
	return 0;
}
```

---

## 作者：zhouyuhang (赞：0)

看到全是矩阵加速的题解，于是胡了一个奇怪做法……

令 $P=10^9+7$。此后的所有 $P$ 均代指该模数。

考虑递推关系的特征方程：$q^2-xq-y=0$。直接求解得到 
$$
q_1=\frac{x+\sqrt{x^2+4y}}{2},q_2=\frac{x-\sqrt{x^2+4y}}{2}
$$
待定系数法，设
$$
a_n=c_1q_1^{n-1}+c_2q_2^{n-1}
$$
代入 $a_1=c_1+c_2,a_2=c_1q_1+c_2q_2$，解得
$$
c_1=\frac{a_2-a_1q_2}{q_1-q_2},c_2=\frac{a_1q_1-a_2}{q_1-q_2}
$$
现在再看所求式子 $\sum\limits_{i=1}^na_n^2$，将其展开，不难发现应为
$$\sum_{i=1}^n(c_1q_1^{n-1}+c_2q_2^{n-1})^2$$
$$=\sum_{i=1}^n(c_1^2q_1^{2n-2}+c_2^2q_2^{2n-2}+2c_1c_2(q_1q_2)^{n-1})$$
$$=c_1^2\sum_{i=1}^nq_1^{2n-2}+c_2^2\sum_{i=1}^nq_2^{2n-2}+2c_1c_2\sum_{i=1}^n
(q_1q_2)^{n-1}$$
$$=c_1^2\frac{q_1^{2n}-1}{q_1^2-1}+c_2^2\frac{q_2^{2n}-1}{q_2^2-1}+2c_1c_2\frac{(q_1q_2)^n-1}{q_1q_2-1}$$
于是做完了。

真的做完了？

显然并没有。注意到两个问题：

1. 一开始的特征方程中，$\Delta=x^2+4y$ 有可能不是模 $P$ 下的二次剩余，也就是说 $\left(\frac{\Delta}{P}\right)=-1$。

2. 在最后的数列求和处，如果公比模 $P$ 余 $1$，那么原数列不构成一个等比数列，无法使用等比数列求和公式。

让我们来一一解决以上的问题：

1. 当 $\left(\frac{\Delta}{P}\right)=-1$ 时，我们可以考虑扩域。具体地，考虑集合 
	$$\left\{ a+bi\ |\ a,b\in\mathbb Z_P\right\},i=\sqrt\Delta$$
	不难发现它构成了一个域。因此可以实现在该域上的加减乘除。加减乘都较为简单，唯独除需要特别说一下。注意到在这个域下，除法公式应为
	$$\frac{a+bi}{c+di}=\frac{ac-bd\Delta}{c^2-d^2\Delta}+\frac{bc-ad}{c^2-d^2\Delta}i$$
	显然，我们需要证明任何时刻 $c^2-d^2\Delta$ 在模 $P$ 意义下都不为零。庆幸的是，这并不困难。

	命题：在上述过程中，$c^2-d^2\Delta\not\equiv0(\bmod\ P)$。

	证明：首先，如果保证公比不为 $1$，那么上述过程中不会出现 $c\equiv d\equiv0(\bmod\ P)$ 的情况（公比为 $1$ 的情况我们会稍后讨论），因此只需要考虑 $d\not\equiv0(\bmod\ P)$ 的情况。此时采取反证法。假设存在 $c,d\not\equiv 0(\bmod\ P)$ 使得 $c^2-d^2\Delta\equiv0(\bmod\ P)$，则 $\Delta\equiv(\frac{c}{d})^2(\bmod\ P)$，又 $d\not\equiv0(\bmod\ P)$，故 $\left(\frac{\Delta}{P}\right)=1$。但这与我们扩域的条件 $\left(\frac{\Delta}{P}\right)=-1$ 相矛盾，因此 $c^2-d^2\Delta\not\equiv0(\bmod\ P)$。证毕。

2. 现在来看看公比的问题。实际上也没什么好看的。注意到公比为 $1$ 时，我们正在进行求和的数列应为一常数数列，因此直接特判掉这种情况就好了。

于是终于做完了。显然复杂度和矩阵加速同为 $O(\log n)$。按道理说会比矩乘常数小一点，不过由于各种细节较多，小编也不确定。不幸的是，这个屑小编并不愿意写一个巨大多细节的超级缝合怪，因此代码消失了!

---


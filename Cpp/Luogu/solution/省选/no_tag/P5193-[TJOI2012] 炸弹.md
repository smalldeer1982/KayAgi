# [TJOI2012] 炸弹

## 题目描述

在平面上有 $n$ 个炸弹 $[1 \ldots n]$，每个炸弹的爆炸范围是 $|x-x_i|+|y-y_i| \leqslant R$，如果某个炸弹爆炸了，那么它将引燃它范围内的所有炸弹。

求出至少引燃多少炸弹才能使得所有炸弹都爆炸。



## 说明/提示

$30\%$ 的数据，$1 \leqslant n \leqslant 1000$；

$100\%$ 的数据，$1 \leqslant n \leqslant 100000 \,,\, 0 \leqslant r \leqslant 10^9 \,,\, 0 \leqslant x_i,y_i \leqslant 10^9$。


## 样例 #1

### 输入

```
3 2
0 0
0 2
3 2```

### 输出

```
2
```

# 题解

## 作者：hsfzLZH1 (赞：9)

## 题目大意

二维平面上有 $n$ 个整点，每个整点的坐标为 $(x_i,y_i)$ ，若两个点 $i,j$ 满足 $|x_i-x_j|+|y_i-y_j|\le R$ ，则在这两个点之间连一条边。求联通块的数量。

$1\le n\le 100000,0\le r,x_i,y_i\le 10^9$

## 解题思路

如果暴力建边，当所有节点都满足互相连边的条件，即所有节点挤在一起时，边的数量是 $O(n^2)$ 的，显然无法忍受。这时我们需要考虑一些优化建图的方法。

我们将一个点的影响范围画出来，如下矩阵：

```cpp
0001000
0011100
0111110
1111111
0111110
0011100
0001000
```

$R=3$ 时的情况

我们发现每个点的影响范围都是一个与坐标轴夹角为 $45\degree$ 的直线围成的正方形，即由斜率 $k=1$ 和 $k=-1$ 的直线围成的正方形。

如果每个点的影响范围是一个与坐标轴平行的矩形，我们可以用扫描线法维护优化连边。

因为此题的影响范围是斜着的正方形，所以我们就斜着扫描线。

我们将所有点按照 $x_i+y_i$ 的值从小到大进行排序，进行扫描线。扫描线为一条斜率为 $-1$ 的直线，其维护的是对当前答案有贡献的点的位置。在本人的代码实现中，用 `set` 维护扫描线。

一个点的坐标为 $(x_i,y_i)$ ，其对应值 $x_i-y_i$ 会在扫描线 $x_i+y_i$ 时加入扫描线，在扫描线 $x_i+y_i+R$ 时退出扫描线。

我们将每个斜率为 $1$ 上的整点进行一个对应关系，令其对应值为 $p_i=x_i-y_i$ ，保证所有这些点的对应值相等。

一个节点 $y$ 能与当前节点 $x$ 相连，当且仅当它们的对应值的差 $|p_x-p_y|\le R$ 。这时可以在并查集上 `merge` 两个节点。

然而，这样的复杂度是和边数同阶的。给出一个结论：直接将节点 $x$ 与可连的向左向右最接近的点连边，因为 $x$ 其它可连的点在之前肯定都在扫描线上，而都连上了，这样可以控制边数是 $O(n)$ 的。

## 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
const int maxn=100010;
int n,r,f[maxn],ans,cur;
int findp(int x){return f[x]?f[x]=findp(f[x]):x;}
void merge(int x,int y)
{
	int u=findp(x),v=findp(y);
	if(u!=v)f[u]=v,ans--;
}
struct node
{
	int x,y;
	bool operator<(node a)const{if(x+y!=a.x+a.y)return x+y<a.x+a.y;return x<a.x;}
}s[maxn];
map<int,int>st;
int main()
{
	scanf("%d%d",&n,&r);ans=n;
	for(int i=1;i<=n;i++)scanf("%d%d",&s[i].x,&s[i].y);
	sort(s+1,s+n+1);
	cur=1;
	st[2e9+1]=-1;st[-(2e9+1)]=-1;
	for(int i=1;i<=n;i++)
	{
		for(;cur<=n&&s[cur].x+s[cur].y+r<s[i].x+s[i].y;cur++)
		if(st[s[cur].x-s[cur].y]==cur)st.erase(s[cur].x-s[cur].y);
		map<int,int>::iterator it=st.lower_bound(s[i].x-s[i].y);
		if(it->first-(s[i].x-s[i].y)<=r)if(it->second)merge(i,it->second);
		it--;
		if(s[i].x-s[i].y-it->first<=r)if(it->second)merge(i,it->second);
		st[s[i].x-s[i].y]=i;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：dyc2022 (赞：8)

我们充分发扬人类智慧：

将所有点全部绕原点旋转同一个角度，然后按 $x+y$ 排序。

根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远。

所以我们只取每个点前后 $500$ 个点判断能否产生答案，用并查集维护连通性即可。

这样速度快得飞起，在 $n = 10^5$ 时都能 $250\text{ms}$ 内卡过。

---

## 作者：Miko35 (赞：8)

对于曼哈顿距离的比较，可以套路地将 $(x,y) \rightarrow (x-y,x+y)$ 转化为切比雪夫距离，一个炸弹的攻击范围变成了矩形。

当然可以用 K-D Tree 优化建边之后 tarjan 缩点来做，但是看起来码量巨大。

注意到此题仅需关于连通性的信息，且攻击关系是双向的，所以大概可以用并查集维护。问题是怎么建边。

考虑用一个 $R\times R$ 的矩形去框，同时被框中的点一定可以互相波及。那这个矩形就有了横坐标和纵坐标的两条限制（均需要 $\leq R$）：

- 横坐标的限制可以先把所有点按照横坐标排序，扫描线动态地维护横坐标相差 $R$ 以内的点集。

- 对于纵坐标的限制，也就是在点集中，每两个纵坐标之差 $\leq R$ 的点必须联通。

第一点很简单，双指针即可；对于第二点，考虑计算 **增量** 的贡献：

- 从集合内删除一个元素，不会对连通性产生改变。

- 从集合内加入一个元素，只可能将 **自己** 与 **某些它能攻击到的连通块** 连起来，而由于纵坐标相差 $\leq R$ 的点在之前必然已经被合并了，所以在它的攻击范围内，最多存在 纵坐标大于它的 和 小于它的 两个连通块。找到其纵坐标的前驱后继即可。

需要注意的是，横/纵坐标坐标有相等的情况，需要钦定编号小的点优先级较高（举例）。

```cpp
for(rgi i=1;i<=n;++i){
	while(!s1.empty()){
		node k=*s1.begin();
		if(p[i].x-R>k.x)s1.erase(k),s2.erase(k);
		else break;
	}
	auto nxt=s2.lower_bound(p[i]);
	if(nxt!=s2.end()&&(*nxt).y-p[i].y<=R)fa[find(p[i].id)]=find((*nxt).id);
	if(nxt!=s2.begin()&&p[i].y-(*--nxt).y<=R)fa[find(p[i].id)]=find((*nxt).id);
	s1.insert(p[i]),s2.insert(p[i]);
}
```


---

## 作者：Rain_chr (赞：1)

前言：本题解为乱搞做法，不过我感觉非常的 interesting，所以还是供后人参考。

强烈谴责省选出题人不负责，裸的乱搞直接冲过去了，卡都不带卡的。

我们观察曼哈顿距离的式子 $|x_i-x_j|+|y_i-y_j|\le c$，按 $x_i$ 排序之后感觉只能通过直接连边连通的点对不会太远，于是暴力往后找 $1000$ 个判断是否能够连边，并查集维护连通性即可。

这个简单的暴力直接冲过了 TJOI2012，如果你是场上选手想到这个就赚飞了！即使是在特意卡了这种做法的双倍经验 USACO 题目上交这份暴力，你也能够获得 86 分的好成绩！

接下来，就要有理由据的乱搞了，请卸下你的理智观看后文。

首先，凭直觉也许出题人会对着曼哈顿距离卡，于是把他转成切比雪夫距离之后再排序，虽然这样得分减少了一分，但是过的点不一样，拼起来就只剩下一个数据点，以及事实证明最远需要直接连通的点在序列中的位置相差变小了。

然后我想到了二维曼哈顿距离较优生成树的求解算法——莫队，如果出题人要卡之前的暴力，必然会把 $x_i,x_j$ 距离调近，把 $y_i,y_j$ 距离调远，在莫队的排序方法下可以很好的避免被这种数据卡爆，这个方法果然过了剩下的一个点，但是前面的又 WA 了。

这下简单了，我们把以切比雪夫距离为理论基础的乱搞和莫队乱搞拼一下，就拿到 100 分的好成绩了。

不过建议还是学习一下正解，感觉性质很厉害。

---

## 作者：__ycx2010__ (赞：1)

### 思路

首先将曼哈顿距离换成切比雪夫距离，原来坐标系上的点 $(x,y)$，换成 $(x+y,x-y)$，距离计算公式为 $\max(x_1 - x_2,y_1 - y_2)$。

然后将所有的点按照横坐标为第一关键字，纵坐标为第二关键字排序，使用双指针，当指针 $i$ 指在某个点时，指针 $j$ 指在最左边的满足 $|x_i - x_j|\leq C$ 的点上。

记录一个 multiset 维护 $[j,i)$ 之间的所有点的纵坐标。

每次将 $i$ 与 multiset 中纵坐标比它大的最接近它的点及纵坐标比它小的最接近它的点应并查集连接。

于是就可以用并查集解决了。

### 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;

const int N = 1e5 + 10;
int p[N];

int find(int x) {return p[x] == x ? x : p[x] = find(p[x]);}

void merge(int x, int y) {
	x = find(x), y = find(y);
	if (x == y) return;
	p[x] = y;
}

int main() {
	int n, c;
	scanf("%d%d", &n, &c);
	vector<pair<int, int>> v;
	for (int i = 1; i <= n; i ++ ) p[i] = i;
	for (int i = 0; i < n; i ++ ) {
        int x, y;
		scanf("%d%d", &x, &y);
		v.push_back({x + y, x - y});
	}
	sort(v.begin(), v.end());
	multiset<pair<int, int>> s;
	for (int i = 0, j = 0; i < n; i ++ ) {
		while (j < i && v[i].fi - v[j].fi > c) {
			s.erase(s.find({v[j].se, j}));
			j ++ ;
		}
        if (s.size()) {
            auto it = s.lower_bound({v[i].se, i});
            if (it != s.end() && abs((*it).fi - v[i].se) <= c) merge(i + 1, (*it).se + 1);
            if (it != s.begin()) {
                -- it;
                if (abs((*it).fi - v[i].se) <= c) merge(i + 1, (*it).se + 1);
            }
        }
        s.insert({v[i].se, i});
	}
	int cnt = 0;
	for (int i = 1; i <= n; i ++ )
		if (find(i) == i)
			cnt ++ ;
	printf("%d", cnt);
	return 0;
}

```

---

## 作者：OIer_ACMer (赞：1)

~~爆炸就是艺术~~


------------
这道题对于我这种蒟蒻来说难度稍大~~说白了就是废了~~。但是，遇到困难，就要微笑着面对它。:)

## 前置知识
切比雪夫距离、熟练运用指针、连通块，还有并查集


## 大致思路
在建图的时候，所有**可能爆炸的边**连起来那么就转换成求无向图的**连通块**个数，这个用**并查集**实现，困难度减一。紧接着，就是建边的细节。我们可以发现，如果用欧几里得距离或者曼哈顿距离做，太过于复杂（因为只用于**半径**有关系），所以就用稍微简单一点的切比雪夫距离作为建边标准。但是建边可能有 $O(n  ^ {2})$ 条，考虑优化建边，将所有点按 $x$ 坐标排序，那么对于每个点只要考虑对**纵坐标的前驱后继点**相连那么连通块的点都能够相连用 map 数组维护即可。

## 说明
由于本人实力有限，部分思路参考[大佬博客](https://www.cnblogs.com/Spare-No-Effort/p/14980848.html) 。

具体代码：

```c++

#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 100011;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
struct node
{
    int x, y;
} a[N];
int n, R, fa[N], ans;
map<int, int> weizhi1;
map<int, int>::iterator it;//参考大佬写的指针
bool cmp(node x, node y)
{
    return x.x < y.x || (x.x == y.x && x.y < y.y);
}
int find(int x)
{
    if (x == fa[x])
    {
        return x;
    }
    return fa[x] = find(fa[x]);
}
void united(int x, int y)
{
    int father = find(x), fab = find(y);
    if (father != fab)
    {
        fa[father] = fab, ans--;
    }
}
signed main()
{
    n = read(), R = read();
    ans = n;
    for (int i = 1; i <= n; i++)
    {
        fa[i] = i;
    }
    for (int i = 1; i <= n; i++)
    {
        int x = read(), y = read();
        a[i] = (node){x + y, x - y};
    }
    sort(a + 1, a + 1 + n, cmp);
    for (int i = 1, j = 1; i <= n; i++)
    {
        for (; a[j].x + R < a[i].x; j++)
        {
            if (weizhi1[a[j].y] == j)
            {
                weizhi1.erase(a[j].y);
            }
        }
        it = weizhi1.lower_bound(a[i].y);//找出第一个小于纵坐标的坐标数对
        if (it != weizhi1.end())
        {
            if (a[i].y + R >= it->first)
            {
                united(it->second, i);
            }
        }
        if (it != weizhi1.begin())
        {
            it--;
            if (it->first + R >= a[i].y)
            {
                united(it->second, i);
            }
        }
        weizhi1[a[i].y] = i;
        //保存答案，以便下次查找
    }
    cout << ans;
    return 0;
}

```

---

## 作者：Polarisx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5193)。

几乎是曼哈顿距离转切比雪夫距离板子。

## 思路

对于两个点 $(x_1,y_1),(x_2,y_2)$，其曼哈顿距离为 $|x_1-x_2|+|y_1-y_2|$，切比雪夫距离为 $\max(|x_1-x_2|,|y_1-y_2|)$。

若将原坐标系上的两点改成 $(x_1+y_1,x_1-y_1),(x_2+y_2,x_2-y_2)$，那么新坐标系上的切比雪夫距离就是原系上的曼哈顿距离，代入即可得证。

同理，若将原坐标系上的两点改成 $(\frac{x_1+y_1}{2},\frac{x_1-y_1}{2}),(\frac{x_2+y_2}{2},\frac{x_2-y_2}{2})$，那么新坐标系上的曼哈顿距离就是原系上的切比雪夫距离。

本题将曼哈顿距离转成切比雪夫距离，那么现在我们只需对新坐标系上的点考虑 $\max(|x_1-x_2|,|y_1-y_2|)\le R$，将点按横坐标排序，双指针维护当前满足 $x_j\ge x_i-R$ 的最小 $j$，用 `multiset` 维护点区间 $[j,i]$ 的纵坐标，找到两个点 $k_1,k_2$ 使得 $k_1$ 是 $[j,i]$ 中在 $i$ 点上方且纵坐标离 $i$ 纵坐标最接近的点，$k_2$ 是 $[j,i]$ 中在 $i$ 点下方且纵坐标离 $i$ 纵坐标最接近的点，并将 $i,k_1,k_2$ 合并，可以发现这样合并一定能覆盖该点能影响的所有点。

时间复杂度 $\mathcal O (n\log n)$。


```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define mk make_pair
using namespace std;

const int Maxn=1e5+6;
int n,R;
struct node{
    int x,y;
}a[Maxn];
int f[Maxn];
int qfind(int key){
    return key==f[key]?key:f[key]=qfind(f[key]);
}
inline void Merge(int x,int y){
    int qx=qfind(x),qy=qfind(y);
    if(qx==qy) return ;
    f[qy]=qx;
}

multiset<pii >s;

int main(){
    scanf("%d%d",&n,&R);
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        a[i].x=x+y,a[i].y=x-y;
    }
        
    sort(a+1,a+n+1,[](node x,node y){
        return x.x<y.x;
    });
    int l=1;
    for(int i=1;i<=n;i++){
        while(a[l].x<a[i].x-R) s.extract(mk(a[l].y,l)),l++;
        if(!s.empty()){
            auto it=s.lower_bound(mk(a[i].y,i));
            if(it!=s.end() and abs(it->first - a[i].y)<=R) Merge(it->second,i); 
            if(it!=s.begin()){
                it--;
                if(abs(it->first - a[i].y)<=R) Merge(it->second,i);
            }
        }
        
        s.insert(mk(a[i].y,i));
    }
    int ans=0;
    for(int i=1;i<=n;i++) if(qfind(i)==i) ans++;
    printf("%d\n",ans);

    system("pause");
    return 0;
}
```

---

## 作者：lzqy_ (赞：0)

可以做的无脑一点。

曼哈顿距离太丑了，先转成切比雪夫距离 $\max(x)+\max(y)$。

考虑模拟生成树的过程，枚举一个点，找到任意一个与它有连边的点，不断扩展下去。

与它有连边的点的范围是一个矩形，可以基本规约到二维数点上，KDT 一下就行了。

时间复杂度 $O(n\sqrt n)$。

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define il inline
using namespace std;
const int maxn=100010;
const int MAXN=maxn<<2;
struct node{
	int x,y;
}a[maxn];
bool cmpX(node a,node b){return a.x<b.x;}
bool cmpY(node a,node b){return a.y<b.y;}
bool vis[maxn];
int xl[MAXN],xr[MAXN],yl[MAXN],yr[MAXN],d[MAXN];
int n,m,C;
void pushup(int i){
	xl[i]=min(xl[i<<1],xl[i<<1|1]),xr[i]=max(xr[i<<1],xr[i<<1|1]);
	yl[i]=min(yl[i<<1],yl[i<<1|1]),yr[i]=max(yr[i<<1],yr[i<<1|1]);
	d[i]=d[i<<1]+d[i<<1|1];
}
void build(int i,int l,int r){
	if(l==r){
		xl[i]=xr[i]=a[l].x;
		yl[i]=yr[i]=a[l].y;
		d[i]=1;
		return ;
	}int mid=l+r>>1;
	double aveX=0,aveY=0;
	double varX=0,varY=0;
	for(int i=l;i<=r;i++)
		aveX+=a[i].x,aveY+=a[i].y;
	aveX/=r-l+1,aveY/=r-l+1;
	for(int i=l;i<=r;i++){
		varX+=(a[i].x-aveX)*(a[i].x-aveX);
		varY+=(a[i].y-aveY)*(a[i].y-aveY);
	}
	nth_element(a+l,a+mid,a+r+1,varX>varY?cmpX:cmpY);
	build(i<<1,l,mid),build(i<<1|1,mid+1,r);
	pushup(i);
}
int Que(int i,int l,int r,int xL,int yL,int xR,int yR){
	if(!d[i]) return 0;
	if(xl[i]>xR||xr[i]<xL) return 0;
	if(yl[i]>yR||yr[i]<yL) return 0;
	if(l==r) return d[i]=0,l;
	int mid=l+r>>1,x;
	if(xl[i]>=xL&&xr[i]<=xR)
		if(yl[i]>=yL&&yr[i]<=yR){
			if(d[i<<1]) x=Que(i<<1,l,mid,xL,yL,xR,yR);
			else x=Que(i<<1|1,mid+1,r,xL,yL,xR,yR);
			return pushup(i),x;
		}
	if(!(x=Que(i<<1,l,mid,xL,yL,xR,yR)))
		x=Que(i<<1|1,mid+1,r,xL,yL,xR,yR);
	return pushup(i),x;
} 
queue<int>q;
void calc(int id){
	int tot=1;
	q.push(id),vis[id]=1;
	Que(1,1,n,a[id].x,a[id].y,a[id].x,a[id].y);
	while(!q.empty()){
		int t=q.front(),x; q.pop();
		while(x=Que(1,1,n,a[t].x-C,a[t].y-C,a[t].x+C,a[t].y+C))
			vis[x]=1,q.push(x);
	}
}
int main(){
	scanf("%d%d",&n,&C);
	for(int i=1,x,y;i<=n;i++){
		scanf("%d%d",&x,&y);
		a[i].x=x+y,a[i].y=x-y;
	}
	build(1,1,n);
//	for(int i=1;i<=n;i++)
//		printf("(%d,%d)\n",a[i].x,a[i].y);
	int tot=0;
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		calc(i),tot++;
	}
	printf("%d\n",tot);
	return 0;
}
```

---


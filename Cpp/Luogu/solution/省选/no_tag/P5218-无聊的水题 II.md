# 无聊的水题 II

## 题目背景

出题人过菜，只会出这种题。

## 题目描述

DLS 是一个喜欢玩游戏的男生。

今天他从朋友那里看到了 $N$ 件武器，其中第 $i$ 件武器的威力值为$i$。

他观察了这 $N$ 件武器许久，打算买下其中若干件武器，但他想用买下的武器的威力值组合出任意威力值，其中每一件武器已经的威力值可以叠加，甚至可以减去。  
例如一个威力值为 $3$ 的武器，可以组合成的威力值为 $\dots,-6,-3,0,3,6,\dots$。

他想找出所有满足以上条件的买下装备的方案，但方案数量实在太多了。你能帮他计算一下吗？    
答案对 $10^9+7$ 取模。

## 说明/提示

|数据百分比|限制|
|-|-|
|$10\%$|$N \le 20$|
|$30\%$|$N \le 2000$|
|$60\%$|$N \le 10^7$|
|$100\%$|$N \le 10^{11}$|

## 样例 #1

### 输入

```
5```

### 输出

```
26```

## 样例 #2

### 输入

```
16```

### 输出

```
65243```

# 题解

## 作者：Aleph1022 (赞：6)

此文同步发表于我的博客：https://www.alpha1022.me/articles/lg-5218.htm

首先，容易证明裴蜀定理可以应用于 $3$ 个及以上的整数间。  
所以问题转化为有多少种选数的方案使得选出的数的 $\gcd = 1$。

设 $f(x)$ 表示使得选出的数的 $\gcd = x$ 的方案数，$F(x) = \sum\limits_{x | d} f(d)$。  
$F(x)$ 其实就是选出的数都是 $x$ 的倍数的方案数，显然 $n$ 以内 $x$ 的倍数有 $\lfloor \frac n x \rfloor$ 个。  
由于 $\sum\limits_{i = 0}^n C_n^i = 2^n$，有 $F(x) = 2^{\lfloor \frac n x \rfloor} - 1$。  
减一是为了剔除不选的情况。

于是有
$$\begin{aligned} & f(1) \\ = & \sum\limits_{i = 1}^n \mu(i) F(i) \\ = & \sum\limits_{i = 1}^n \mu(i) (2^{\lfloor \frac n i \rfloor} - 1)\end{aligned}$$

对于指数做数论分块，对于 $\mu$ 杜教筛就好了。  
我的杜教筛比较偷懒直接上了 unordered_map（

代码：
```cpp
#include <cstdio>
#include <tr1/unordered_map>
using namespace std;
using namespace tr1;
const long long N = 1e11;
const int CNT = 1e7;
const long long mod = 1e9 + 7;
long long n;
int vis[CNT + 5],prime[CNT + 5],cnt,mu[CNT + 5];
unordered_map<int,long long> w;
long long ans;
long long fpow(long long a,long long b)
{
    a %= mod,b %= mod - 1;
    long long ret = 1;
    for(;b;b >>= 1)
        (b & 1) && (ret = ret * a % mod),a = a * a % mod;
    return ret;
}
long long calc(long long n)
{
    if(n <= CNT)
        return mu[n];
    if(w.count(n))
        return w[n];
    long long ret = 1;
    for(register long long l = 2,r;l <= n;l = r + 1)
    {
        r = n / (n / l);
        ret = (ret - (r - l + 1) % mod * calc(n / l) % mod + mod) % mod;
    }
    return w[n] = ret;
}
int main()
{
    mu[1] = 1;
    for(register int i = 2;i <= CNT;++i)
    {
        if(!vis[i])
            mu[prime[++cnt] = i] = -1;
        for(register int j = 1;j <= cnt && i * prime[j] <= CNT;++j)
        {
            vis[i * prime[j]] = 1;
            if(!(i % prime[j]))
                break;
            else
                mu[i * prime[j]] = -mu[i];
        }
    }
    for(register int i = 1;i <= CNT;++i)
        mu[i] = (mu[i] + mu[i - 1] + mod) % mod;
    scanf("%lld",&n);
    for(register long long l = 1,r;l <= n;l = r + 1)
    {
        r = n / (n / l);
        ans = (ans + (calc(r) - calc(l - 1) + mod) * (fpow(2,n / l) - 1) % mod) % mod;
    }
    printf("%lld\n",(ans + mod) % mod);
}
```

---

## 作者：EuphoricStar (赞：3)

无聊的水题。

根据裴蜀定理，显然能组合出任意值的充要条件是，选出的数的 $\gcd = 1$。

设 $g(i)$ 为在 $1 \sim n$ 中选出若干个数使得它们 $\gcd = i$ 的方案数，$f(i)$ 为在 $1 \sim n$ 中选出若干个数使得它们 $\gcd$ 是 $i$ 的倍数的方案数。我们有：

$$f(i) = \sum\limits_{i \mid j} g(j) = 2^{\left\lfloor\frac{n}{i}\right\rfloor} - 1$$

$$g(i) = \sum\limits_{i \mid j} \mu(\frac{j}{i}) f(j)$$

因此：

$$g(1) = \sum\limits_{i = 1}^n \mu(i) (2^{\left\lfloor\frac{n}{i}\right\rfloor} - 1)$$

整除分块后使用杜教筛计算 $\mu(i)$ 前缀和，复杂度 $O(\sqrt{n} \log n + n^{\frac{2}{3}})$。

---

## 作者：流水行船CCD (赞：2)

知识点：裴蜀定理，莫比乌斯反演，整除分块，杜教筛。

首先，一个选择武器集合 $S=\{a_1,a_2,\dots,a_k\}$ 合法，当且仅当不定方程 $x_1a_1+x_2a_2+\dots+x_ka_k=1$ 存在一组解，而根据裴蜀定理，方程 $x_1a_1+x_2a_2+\dots+x_ka_k$ 的最小正整数解为 $(a_1,a_2,\dots,a_k)$，因此题目条件转化为 $(a_1,a_2,\dots,a_k)=1$。

设 $f(k)$ 表示最大公约数为 $k$ 的倍数的集合个数。

设 $g(k)$ 表示最大公约数恰好为 $k$ 的集合个数。

发现 $f(k)$ 易求（因为它等价于 $k$ 的倍数组成集合的子集个数），$g(1)$ 为我们所求的答案，直接莫比乌斯反演即可，推导过程如下。

$$
\begin{aligned}
&\left\{\begin{matrix} 
\begin{aligned}
f(k) &= \sum_S [k | \gcd(S)] = 2^{\lfloor\frac{n}{k}\rfloor}-1\\
g(k) &= \sum_S [\gcd(S) = k]\\
\end{aligned}
\end{matrix}\right. \\
&\left\{\begin{matrix}
\begin{aligned}
f(k) &= \sum_{k | d} g(d)\\
g(k) &= \sum_{k | d} \mu(\frac{d}{k})f(d)\\
\end{aligned}
\end{matrix}\right. \\
&\begin{aligned}
\operatorname{Ans} = g(1) &= \sum_{i} \mu(i)f(i) \\
&= \sum_{i} \mu(i)(2^{\lfloor\frac{n}{i}\rfloor}-1)
\end{aligned}
\end{aligned}
$$

最后这个式子对 $\lfloor \frac{n}{i}\rfloor$ 分块，使用杜教筛查询 $\mu$ 的前缀和即可做到 $O(n^{\frac{2}{3}})$，可以通过。

code 很短，就不放了。

---

## 作者：Leasier (赞：2)

前置芝士：[裴蜀定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/)、[莫比乌斯反演](https://oi-wiki.org/math/mobius/)、[杜教筛](https://oi-wiki.org/math/du/)

由于斐蜀定理可以用于任意正整数个数的正整数间，所以我们只需要统计有多少种选数的方案使得选出的数的最大公约数为 $1$。

考虑所求答案的倍数的答案和。设 $f(n)$ 表示所选数的最大公约数为 $n$ 的方案数，$g(n, m) = \displaystyle\sum_{n\ |\ d}^m f(d)$，则 $g(n)$ 表示选出数的最大公约数为 $n$ 的倍数的方案数。显然，$g(n, m) = 2^{\lfloor \frac{m}{n} \rfloor} - 1$。

由莫比乌斯反演公式可得：

原式 $= f(1)$

$ = \displaystyle\sum_{i = 1}^n \mu(i) F(i, n)$

$ = \displaystyle\sum_{i = 1}^n \mu(i) (2^{\lfloor \frac{n}{i} \rfloor} - 1)$

使用数论分块和杜教筛计算即可。时间复杂度为 $O(n^{\frac{2}{3}} \log n)$。

代码：
```cpp
#include <iostream>
#include <map>

using namespace std;

typedef long long ll;

const int N = 3e7 + 7, mod = 1e9 + 7;
int prime[N], mu[N], sum[N];
bool p[N];
map<ll, int> mp;

inline void init(){
	int cnt = 0;
	p[0] = p[1] = true;
	mu[1] = 1;
	for (register int i = 2; i < N; i++){
		if (!p[i]){
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				mu[t] = 0;
				break;
			}
			mu[t] = -mu[i];
		}
	}
	for (register int i = 1; i < N; i++){
		sum[i] = sum[i - 1] + mu[i];
	}
}

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline int get_mu_sum(ll n){
	if (n < N) return sum[n];
	if (mp.count(n)) return mp[n];
	int ans = 1;
	for (register ll i = 2, j; i <= n; i = j + 1){
		ll tn = n / i;
		j = n / tn;
		ans -= get_mu_sum(tn) * (j - i + 1);
	}
	return mp[n] = ans;
}

int main(){
	ll n, ans = 0;
	cin >> n;
	init();
	for (register ll i = 1, j; i <= n; i = j + 1){
		ll tn = n / i;
		j = n / tn;
		ans = ((ans + (quick_pow(2, tn, mod) - 1) * (get_mu_sum(j) - get_mu_sum(i - 1)) % mod) % mod + mod) % mod;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：SoyTony (赞：1)

容易想到要求我们构造一个集合满足集合的 $\gcd=1$，求方案数。

设 $f(n)$ 为在 $[1,n]$ 中选取的方案数，那么当 $\gcd=k$ 时，实际上是在 $\left\lfloor n/k\right\rfloor$ 中选取的方案数，可以单步容斥计算，于是有：

$$f(n)=2^n-1-\sum_{k=2}^{n} f(\left\lfloor n/k\right\rfloor)$$

这个式子和杜教筛差不多，复杂度是 $O(n^{3/4})$，不太好过。

---

改变定义，设 $f(d)$ 表示选取集合值域 $[1,n]$，$\gcd=d$ 的方案数，$g(d)$ 表示选取集合值域 $[1,n]$，$d\mid \gcd$ 的方案数，$g$ 是好算的，即 $g(d)=2^{\left\lfloor n/d\right\rfloor}-1$。

可以得到一个式子：

$$g(d)=\sum_{d\mid n} f(n)$$

根据莫比乌斯变换，有：

$$f(d)=\sum_{d\mid n} \mu\left(\dfrac{n}{d}\right) g(n)$$

证明可以直接代入：

$$\begin{aligned}
f(d)&=\sum_{d\mid n}\mu\left(\dfrac{n}{d}\right)\sum_{n\mid n'} f(n')\\
&=\sum_{d\mid n'} f(n') \sum_{d\mid n\mid n'} \mu\left(\dfrac{n}{d}\right)\\
&=\sum_{d\mid n'} f(n') \sum_{(n/d)\mid (n'/d)} \mu\left(\dfrac{n}{d}\right)\\
&=\sum_{d\mid n'} f(n') \sum_{n\mid (n'/d)} \mu(n)\\
&=\sum_{d\mid n'} f(n') [n'/d=1]\\
&=f(d)
\end{aligned}$$

于是有：

$$f(1)=\sum_{i=1}^n\mu(i)g(i)=\sum_{i=1}^n\mu(i)(2^{\left\lfloor n/i\right\rfloor}-1)$$

整除分块+杜教筛求 $\mu$ 前缀和即可。

---

## 作者：SSerxhs (赞：1)

根据裴蜀定理，题目中的条件等价于选择出来的所有元素gcd=1。注：以下式子如无特殊说明"/"均代表下取整整除

反演一下可以得到ans=(2^(n/i)-1)*f(i)，其中f是莫比乌斯函数，2^(n/i)意义为i的所有倍数都有选或不选两种可能,-1为排除空集情况。按照反演题的套路整除分块，并杜教筛即可。

```cpp
#include <stdio.h>
#include <string.h>
#include <map>
using namespace std;
typedef long long ll;
map<ll,int> s;
const int N=1e7+2,p=1e9+7;
ll n,x;
int m,i,j,y,z,mu[N],ss[N],gs,ans;
bool ed[N];
inline int ksm(int y)
{
    int x=2,r=1;
    while (y)
    {
        if (y&1) r=(ll)r*x%p;
        y>>=1;
        x=(ll)x*x%p;
    }
    return r-1;
}
inline int S(ll n)
{
    ll i;
    if (n<=m) return mu[n];
    if (i=s[n]) return i;
    ll j,k;
    int ans=0;
    for (i=2;i<=n;i=j+1)
    {
        j=n/(k=n/i);
        ans=(ans+(ll)S(k)*((j-i+1)%p))%p;
    }
    ans=1-ans;
    if (ans<0) ans+=p;
    return s[n]=ans;
}
int main()
{
    scanf("%lld",&n);
    m=min((ll)(N-2),n);//m=2;
    mu[1]=1;
    for (i=2;i<=m;i++)
    {
        if (!ed[i]) mu[ss[++gs]=i]=-1;
        for (j=1;(j<=gs)&&(i*ss[j]<=m);j++)
        {
            ed[i*ss[j]]=1;
            if (i%ss[j]==0) break;
            mu[i*ss[j]]=-mu[i];
        }
        mu[i]+=mu[i-1];
    }
    ll i,j;
    for (i=1;i<=n;i=j+1)
    {
        j=n/(x=(n/i));
        ans=(ans+(ll)ksm(x%(p-1))*((z=S(j))-y))%p;
        y=z;
    }
    if (ans<0) ans+=p;
    printf("%d",ans);
}
```

---

## 作者：modfish_ (赞：0)

## 思路
题意简单来说就是求 $\{1,2,\dots,n\}$ 有多少个子集的最大公约数为 $1$。

考虑容斥。减去最大公约数不是 $1$ 的集合数量即可。

一个显然的想法是枚举所有质数 $p$，计算有多少个集合的公约数是 $p$ 的倍数，容易看出有 $2^{\lfloor\frac{n}{p}\rfloor}$ 个，故答案减去这么多个。

这样必定是多减了的，考虑某两个质数 $p_1,p_2$ 的乘积 $p_1p_2$，最大公约数是 $p_1p_2$ 倍数的集合被 $p_1$ 和 $p_2$ 各减掉了一次，答案得加回来 $2^{\lfloor\frac{n}{p_1p_2}\rfloor}$。

对于三个、四个、更多个质数的乘积同理，所以直接给每个数定一个容斥系数即可。十分巧合的是，我们惊喜地发现，$\mu(i)$ 恰好可以作为容斥系数。所以答案为：

$$\sum_{i=1}^n\mu(i)2^{\lfloor\frac{n}{i}\rfloor}$$

数论分块套杜教筛即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 3e7 + 5, p = 1e9 + 7;

int pr[maxn], isp[maxn], cnt = 0, mu[maxn];
unordered_map<ll, ll> mu2;

void prime(int m){
    mu[1] = 1;
    for(int i = 2; i <= m; i ++){
        if(!isp[i]) pr[++ cnt] = i, mu[i] = p - 1;
        for(int j = 1; j <= cnt && i * pr[j] <= m; j ++){
            isp[i * pr[j]] = 1;
            if(i % pr[j]) mu[i * pr[j]] = (p - mu[i]) % p;
            else{
                mu[i * pr[j]] = 0;
                break;
            }
        }
    }
}
ll n2 = 0;
ll F(ll n){
    if(n <= n2) return mu[n];
    if(mu2.count(n)) return mu2[n];
    ll res = 0, l = 2, r;
    while(l <= n){
        r = n / (n / l);
        res = (res + (r - l + 1) % p * F(n / l) % p) % p;
        l = r + 1;
    }
    res = (p + 1 - res) % p;
    mu2[n] = res;
    return res;
}
ll qpow(ll a, ll x){
    ll res = 1;
    while(x){
        if(x & 1) res = res * a % p;
        a = a * a % p;
        x >>= 1;
    }
    return res;
}

int main(){
    ll n;
    scanf("%lld", &n);
    n2 = pow(n, 2.0 / 3.0);
    prime(n2);
    for(int i = 2; i <= n2; i ++) mu[i] = (mu[i] + mu[i - 1]) % p;
    ll l = 1, r, ans = 0;
    while(l <= n){
        r = n / (n / l);
        ans = (ans + (F(r) + p - F(l - 1)) * (qpow(2, (n / l) % (p - 1)) + p - 1) % p) % p;
        l = r + 1;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：gyyyyx (赞：0)

简单题，但是由于不知道 unordered_map 空间常数大导致交了很多发都过不了。

首先满足条件的武器集合必定是最大公约数为 $1$。

设 $\text{GCD}(S)$ 表示**非空集合** $S$ 中所有元素的 $\gcd$，那我们就是要求：

$$
\sum\limits_{S\subseteq \{1,2,\cdots,n\}}\epsilon(\text{GCD}(S))
$$

莫反处理一下：

$$
\begin{aligned}
&\sum\limits_{S\subseteq \{1,2,\cdots,n\}}\epsilon(\text{GCD}(S))\\
=&\sum\limits_{S\subseteq \{1,2,\cdots,n\}}\sum\limits_{d\mid\text{GCD}(S)} \mu(d)\\
\end{aligned}
$$

按照每个 $\mu(d)$ 的贡献拆开算：


$$
\begin{aligned}
&\sum\limits_{S\subseteq \{1,2,\cdots,n\}}\epsilon(\text{GCD}(S))\\
=&\sum\limits_{d=1}^n \mu(d)\sum\limits_{S\subseteq\{1,2,\cdots,n\}}[\forall x\in S,d\mid x]\\
=&\sum\limits_{d=1}^n \mu(d)\sum\limits_{S\subseteq\{x\mid 1\leq x=dk\leq n,k\in \mathbb{Z}\}}1\\
=&\sum\limits_{d=1}^n \mu(d)(2^{\lfloor\frac{n}{d}\rfloor}-1)
\end{aligned}
$$

整除分块+杜教筛可以解决，时间 $O(n^{\frac{2}{3}}+\sqrt{n}\log(n))$。

当然如果想舍弃一点空间换更优的时间复杂度，可以把快速幂改成光速幂，时间 $O(n^{\frac{2}{3}})$。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mod 1000000007
using namespace std;
LL n,ans;int m,t;
vector <bool> vis;
vector <int> prime,mu;
vector <LL> P1,P2;
unordered_map <LL,LL> flg;
LL Sum(LL x){
	if(x<=m) return mu[x];
	if(flg.count(x)) return flg[x];
	LL ret(1);
	for(LL l(2),r;l<=x;l=r+1){
		r=x/(x/l);
		ret-=(r-l+1)*Sum(x/l);
	}
	return flg[x]=ret;
}
LL POW(LL x){return P1[x%t]*P2[x/t]%mod;}
int main(){
	scanf("%lld",&n);
	m=(int)pow(n,2.0/3.0);
	vis.resize(m+1,0);
	mu.resize(m+1,0);mu[1]=1;
	for(int i(2);i<=m;++i){
		if(!vis[i]) prime.push_back(i),mu[i]=-1;
		for(auto p:prime){
			if((LL)i*p>m) break;
			vis[i*p]=1;
			if(i%p) mu[i*p]=-mu[i];
			else{mu[i*p]=0;break;}
		}
	}
	for(int i(2);i<=m;++i) mu[i]+=mu[i-1];
	t=(int)(sqrt(n)*1.5);P1.resize(t+1,0);P2.resize(t+1,0);
	P1[0]=1;for(int i(1);i<=t;++i) P1[i]=(P1[i-1]<<1ll)%mod;
	P2[0]=1;for(int i(1);i<=t;++i) P2[i]=P2[i-1]*P1[t]%mod;
	for(LL l(1),r;l<=n;l=r+1){
		r=n/(n/l);
		ans=(ans+(Sum(r)-Sum(l-1))*(POW(n/l)-1)%mod)%mod;
	}
	printf("%lld\n",(ans+mod)%mod);
	return 0;
}
```

目前最优解。

---

## 作者：zzbzwjx (赞：0)

前置知识：[裴蜀定理](https://oi-wiki.org/math/number-theory/bezouts/)、[杜教筛](https://oi-wiki.org/math/number-theory/du/)、[莫比乌斯反演](https://oi-wiki.org/math/number-theory/mobius/)。

## 题意
[~~自己看题~~](https://www.luogu.com.cn/problem/P5218)

## 分析
由于斐蜀定理可以用于任意正整数个数的正整数间，所以我们只需要统计有多少种选数的方案使得选出的数的最大公约数为 $1$。

考虑所求答案的倍数的答案和。设 $f(n)$ 表示所选数的最大公约数为 $n$ 的方案数，$g(n, m) = \displaystyle \sum_{n\ |\ d}^m f(d)$，则 $g(n)$ 表示选出数的最大公约数为 $n$ 的倍数的方案数。显然，$g(n, m) = 2^{\lfloor \frac{m}{n} \rfloor} - 1$。

由莫比乌斯反演公式可得：

原式 = $f(1) = \displaystyle \sum_{i = 1}^n \mu(i) F(i, n) = \displaystyle \sum_{i = 1}^n \mu(i) (2^{\lfloor \frac{n}{i} \rfloor}- 1)$

使用数论分块和杜教筛计算即可。时间复杂度为 $O(n^{\frac{2}{3}} \log n)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt,aa[30000003],mu[30000003],sum[30000003];
long long n,ans,mod=1e9+7;
bool p[30000003];
map<long long,int>mp;
long long poww(long long x, long long p, long long mod){
	long long ans=1;
	while(p){
		if(p&1)ans=ans*x%mod;
		x=x*x%mod;
		p>>=1;
	}
	return ans;
}
int gg(long long n){
	if (n<30000003)return sum[n];
	if (mp.count(n))return mp[n];
	int ans=1;
	for (long long i=2,j;i<=n;i=j+1){
		long long tn=n/i;j=n/tn;
		ans-=gg(tn)*(j-i+1);
	}
	return mp[n]=ans;
}
int main(){
	cin>>n;
	p[0]=p[1]=1,mu[1]=1;
	for (int i=2;i<30000003;i++){
		if(!p[i]){aa[++cnt]=i,mu[i]=-1;}
		for(int j=1;j<=cnt&&i*aa[j]<30000003;j++){
			int t=i*aa[j];
			p[t]=1;
			if (i%aa[j]==0){
				mu[t]=0;break;
			}
			mu[t]=-mu[i];
		}
	}
	for(int i=1;i<30000003;i++)sum[i]=sum[i-1]+mu[i];
	for(long long i=1,j;i<=n;i=j+1){
		long long tn=n/i;j=n/tn;
		ans=((ans+(pow(2,tn,mod)-1)*(gg(j)-gg(i - 1))%mod)%mod+mod)%mod;
	}
	cout<<ans<<'\n';
	return 0;
}
```
改了点细节直接抄代码过不了哦。

---

## 作者：jijidawang (赞：0)

首先根据 Bézout 定理不难得到就是选 GCD 等于 1 的数数量。

令 $n$ 的答案是 $f(n)$，则单步容斥可以得到：
$$f(n)=2^n-1-\sum_{i=2}^nf\left(\left\lfloor\dfrac ni\right\rfloor\right)$$
这是类似杜教筛的形式，直接记忆化跑就是 $O(n^{3/4})$。

不过不太能过，考虑小范围预处理，这样就能 $O(n^{2/3})$ 了。

对于 GCD 可以考虑莫比乌斯反演，令 $F(x)$ 是满足 $\gcd=x$ 的方案数，$G(x)$ 是 $x\mid\gcd$ 的方案数，则：
$$\begin{aligned}&G(x)=\sum_{x\mid n}F(n)\\\Longrightarrow&F(x)=\sum_{x\mid n}G(n)\mu\left(\dfrac nx\right)\end{aligned}$$
那么不难发现的是 $G(x)=2^{\lfloor\frac nx\rfloor}-1$，于是：
$$f(n)=F(1)=\sum_{i=1}^n\mu(i)(2^{\lfloor\frac ni\rfloor}-1)$$
于是只需要快速处理 $n^{2/3}$ 内的 $f(n)$，首先把减一排掉（可以线性筛处理）就是：
$$h(n)=\sum_{i=1}^n2^{\lfloor\frac ni\rfloor}\mu(i)$$

对于整除问题不难想到考虑差分：

$$\begin{aligned}\Delta h(n)&=h(n)-h(n-1)\\&=2\mu(n)+\sum_{i=1}^{n-1}(2^{\lfloor\frac ni\rfloor}-2^{\lfloor\frac{n-1}i\rfloor})\mu(i)\\&=2\mu(n)+\dfrac12\sum_{i=1}^{n-1}[i\mid n]2^{\lfloor\frac ni\rfloor}\mu(i)\\&=\mu(n)+\dfrac12\sum_{d\mid n}2^{\frac nd}\mu(d)\end{aligned}$$
于是只需要处理每个差分即可递推得到所有 $h$，加号前面可以线性筛处理，加号后面 Dirichlet 前缀和即可。

整合一下，时间复杂度为 $O(n\log\log n+n^{2/3
})$，希望能过。

好吧，只能理性愉悦，实际还是没整除分块 + 杜教筛好。~~但是全程不用杜教筛。~~

---


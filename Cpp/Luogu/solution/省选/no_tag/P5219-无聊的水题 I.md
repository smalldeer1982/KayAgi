# 无聊的水题 I

## 题目背景

出题人过菜，只会出这种题，稍微有点卡常。

## 题目描述

DLS 喜欢上树。  
但是他并不想把一道数据结构题出到树上，他喜欢计 Tree。

这一天，他想自己造一棵树，他手头有 $N$ 个树的节点，标号为 $1 \sim N$，他会在它们之间连边，我们定义两颗树不同，当且仅当一对节点在一棵树中有连边，另一棵树中没有连边。  
但他不喜欢一棵太多分叉的树，于是他想让这棵树的节点中最大的度数为 $M$。

DLS 由于不太擅长理科，所以希望你帮他计算有多少棵这样的树。 
答案对 $998244353$ 取模。

## 说明/提示

|数据百分比|限制|
|-|-|
|$10\%$|$N,M \le 8$|
|$30\%$|$N,M \le 100$|
|$50\%$|$N,M \le 500$|
|$70\%$|$N,M \le 2000$|
|$100\%$|$2 \le N,M \le 5 \times 10^4$|

## 样例 #1

### 输入

```
3 2```

### 输出

```
3```

## 样例 #2

### 输入

```
7 4```

### 输出

```
2520```

# 题解

## 作者：hehelego (赞：21)

### 某计数题题解

本文内容目录:
- ~~扯淡~~
- 有标号无根树计数的重要工具:prufer序列
- 简单的递推式
- 知道啥是多项式/啥是组合数的朋友就能看懂的推导
- 代码实现

---


~~qwq,马上省选我才做了第一个多项式计数题~~

~~表示萌新afoier spinach在此对一直带我玩的各位dalao表示衷心感谢.~~

---

题目意思:  
求n点,有标号,无根树,$max_{x\in T}(deg_x)=m$的图计数.  

首先我们需要了解一个用于无根树计数的工具.[prufer sequence](https://en.wikipedia.org/wiki/Prüfer_sequence).(不会打那个字符用u代替了...).  
这是一个建立在 有标号无根树 和 数列 之间的一一映射.  **具体说:一个n点有标号无根树,和一个长度为n-2,所有元素都在[1,n]内的数列有唯一对应关系**.  


~~当然这些都不重要~~

通过分析"有标号无根树 转 prufer sequence的算法",我们得到一个有用的性质:**x在树中的度数等于在prufer序列中出现次数+1**,$deg(x)_{\text{ tree}}=count(x)_{\text{prufer sequence}}+1$


-----

回到本题,这是一个钦定最大度数(即出现次数)的序列计数问题...仍然不太好做,但是所有度数(出现次数)都不超过$m$的序列计数是好做的. 而且$\leq m$和$\leq m+1$相差的部分即为$max(deg_x)=m+1$的数量.  



现在问题转化为这样**元素都在[1,n]中,长度为n-2,每个元素出现次数不超过m的序列计数**.


我们可以依靠 套路/直觉/乱搞 写出一个DP的计数玩法.

$f_{x,len}$表示长度为$len$,元素都在[1,x]内,每个元素出现次数不超过$m$的序列计数.  递推式的话枚举$x$的出现次数即可. 
$$f_{x,len}=\sum_{i=0}^{min(len,m)}\binom{len}{i}f_{x-1,len-i}$$
这个式子的组合意义是.考虑$x$出现次数为$i$,之前的元素构成了长度为$len-i$的序列,我们向其中插入一种从未出现过的元素$x$,共插入$i$次,能得到多少不同的序列.  
$len-i$个元素,将会有$len-i+1$个位置可以插入$x$(首尾和两两之间).考虑每个位置插入的$x$是$x_i$个.那么$\sum_{j=1}^{len-i+1}x_j=i,(x_j\geq0)$即不定方程非负整数解计数,做代换$y_i=x_i+1$转化成不定方程正整数解.$\sum_{j=1}^{len-i+1}y_j=i+len-i+1=len+1$.再次考虑组合意义,将$len+1$个完全一致的球排成一列,插入$len-i$个隔板(不能插入头尾,共len个位置可以插入),两两间至少有一个球,分成$len-i+1$组的方案计数.即为$\binom{len}{len-i}=\binom{len}{i}$


---


上面的方程,让我们得到了$O(n^3)$的做法,观察方程里面一堆$len-i,i$感觉肯定有卷积.这时记住套路**组合数拆成阶乘,看下标分配给不同项**  
具体地

$$f_{x,len}=\sum_{i=0}^{min(len,m)}\binom{len}{i}f_{x-1,len-i}$$

$$f_{x,len}=\sum_{i=0}^{min(len,m)}\frac{len!}{i!(len-i)!}f_{x-1,len-i}$$

$$\frac{f_{x,len}}{len!}=\sum_{i=0}^{min(len,m)}\frac{f_{x-1,len-i}}{(len-i)!}\frac{1}{i!}$$


$$let\,F_x[len]=\frac{f_{x,len}}{len!}\quad G[i]=\frac{1}{i!},H[i]=G[i][i\leq m]$$

$$F_x[len]=\sum_{i=0}^{min(len,m)}F_{x-1}[len-i]G[i]=\sum_{i=0}^{len}F_{x-1}[len-i]H[i]$$


$$F_x=F_{x-1}*H$$

我们发现卷一次$H$就是批量转移一次,每次使用的$H$都一样,卷积即为多项式乘法,具有结合律,使用类似快速幂的倍增算法,可以在$O(log\,n)$次卷积内计算出答案,每次卷积我们使用NTT,即可得到$O(nlog^2\,n)$的解法.  

---

代码如图
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <cassert>
#include <ctime>
using namespace std;
typedef long long Int;
const int N=(1<<19);
const Int mod=998244353LL;
const Int G=3LL;
Int qpow(Int a,Int p){
	if(p==0) return 1;
	Int r=qpow(a,p>>1); r=r*r%mod;
	return (p&1)?(r*a%mod):r;
}
inline Int inv(Int a){ return qpow(a,mod-2); }
namespace Poly{
	const int CUTOFF=30;
	Int buf[CUTOFF];
    // 小技巧,即使你用的是递归的FFT,也能跑得过去.
    // 小范围暴力代替分治,减少了push/pop stack的开销
    // 是一个复杂度与常数之间的平衡.
    // 具体来说,dft即为带入求值...我们暴力平方复杂度带入即可.
	void fft(Int *A,int n,int f){
		Int base=qpow(G,(mod-1)/n),w=1,t=0;
		if(f<0) base=inv(base);
		if(n<CUTOFF){
			for(int i=0;i<n;i++){
				for(int j=n-1;j>=0;j--) t=(t*w%mod+A[j])%mod;
				buf[i]=t; t=0; w=w*base%mod;
			}
			for(int i=0;i<n;i++) A[i]=buf[i];
			return ;
		}
		int m=n>>1,p=0;
		Int *A0=new Int[m],*A1=new Int[m];
		for(int i=0;i<m;i++){ A0[i]=A[p++]; A1[i]=A[p++]; }
		fft(A0,m,f); fft(A1,m,f);
		for(int i=0;i<m;i++){
			t=w*A1[i]%mod;
			A[i]=(A0[i]+t)%mod;
			A[i+m]=(A0[i]-t+mod)%mod;
			w=w*base%mod;
		}
		delete[] A0; delete[] A1;
	}
	inline void trans(Int *A,int n,int f){
		fft(A,n,f);
		if(f<0){
			Int x=inv(n);
			for(int i=0;i<n;i++) A[i]=A[i]*x%mod;
		}
	}
}using Poly::trans;

// 多项式快速幂.modlen表示模x^p进行计算
// 显然不能保留整个多项式,我们发现只要每次保留一部分,后面的部分是不会影响转移的
// 形式化的说,我们在模x^p意义下进行多项式运算.
Int poly_qpow(Int *Poly,int modlen,int n,int at){
// 这个函数用于计算Poly 的n次方,模x^modlen意义下,x^at项的系数.
	int k=1; while(k<=modlen*2) k<<=1;
	for(int i=0;i<modlen;i++) base[i]=Poly[i];
	for(int i=modlen;i<k;i++) base[i]=0;
	for(int i=0;i<k;i++) ret[i]=0; ret[0]=1;

	while(n){
		if(n&1){
			trans(base,k,1); trans(ret,k,1);
			for(int i=0;i<k;i++) ret[i]=ret[i]*base[i]%mod;
			trans(base,k,-1); trans(ret,k,-1);
			for(int i=modlen;i<k;i++) ret[i]=0;
		}
		trans(base,k,1);
		for(int i=0;i<k;i++) base[i]=base[i]*base[i]%mod;
		trans(base,k,-1);
		for(int i=modlen;i<k;i++) base[i]=0;
		n>>=1;
	}
	return ret[at];
}
// 计算长度为len,元素为[1,n],每个元素出现次数不超过m的序列计数.
inline Int count(int len,int n,int m){
	if(m<=0) return 0;
    // 这个多项式B即为推导中的H
	for(int i=0;i<=m;i++) B[i]=ifac[i];
	for(int i=m+1;i<N;i++) B[i]=0;
    // 记得把阶乘补充回来.
	return poly_qpow(B,len+1,n,len)*fac[len]%mod;
}
int n,m;
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
int main(){
	n=read();m=read();
	ifac[0]=fac[0]=1;
	for(int i=1;i<N;i++) ifac[i]=inv(fac[i]=fac[i-1]*i%mod);

	Int ans=(count(n-2,n,m-1)-count(n-2,n,m-2)+mod)%mod;
	cout<<ans<<endl;
	return 0;
}

```
---

后记

~~即使你不会EGF,不知道各种图计数的操作.不懂多项式科技只会写一个fft板子也能轻松切题.~~

如果你会多项式exp,了解EGF和有标号图计数的各种玩法,这个就是板子了...~~显然作为一个懒人,我是只会fft板子和求逆的~~ 更多玩法请自行查找NOI WC2019上"生成函数 多项式 图计数"的课件和策爷的集训队论文.




~~BJOI2019 RP++~~省选爆0稳了.


---

## 作者：Aleph1022 (赞：12)

这是一篇~~民科的~~直接从生成函数角度进行推导的题解。

首先，根据 Prufer 序列，易知相当于计数长度为 $n-2$ 的，元素在 $[1,n]$ 内且所有元素出现次数的最大值恰为 $m-1$ 的序列个数。  
但是最大值恰为 $m-1$ 并不好求，考虑差分转化为出现次数全都不超过 $m-1$ 的，减去出现次数全都不超过 $m-2$ 的。

于是考虑如何计数长度为 $n-2$，元素出现次数不超过 $m-1$ 的序列个数。  
序列当然是用 EGF，因为要考虑顺序。由于每种元素的出现次数都不能超过 $m-1$，所以可以考虑对每种元素构造 EGF。  
则设
$$F(x) = \sum\limits_{i=0}^{m-1} \frac{x^i}{i!}$$

因为同元素之间换顺序也只算一种方案。

由于有 $[1,n]$ 的元素，所以答案就是
$$(n-2)![x^{n-2}]F^n(x)$$
多项式倍增快速幂或者 ln exp 快速幂解决。  
复杂度 $O(n \log^2 n)$ 或 $O(n \log n)$。

代码：
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <utility>
#include <algorithm>
#define add(a,b) (a + b >= mod ? a + b - mod : a + b)
#define dec(a,b) (a < b ? a - b + mod : a - b)
using namespace std;
const int N = 1 << 18;
const int mod = 998244353;
const int G = 3;
inline int fpow(int a,int b)
{
	int ret = 1;
	for(;b;b >>= 1)
		(b & 1) && (ret = (long long)ret * a % mod),a = (long long)a * a % mod;
	return ret;
}
struct poly
{
	int a[N + 5];
	inline const int &operator[](int x) const
	{
		return a[x];
	}
	inline int &operator[](int x)
	{
		return a[x];
	}
	inline void clear(int x = 0)
	{
		memset(a + x,0,(N - x + 1) << 2);
	}
} f;
int m,len,k,n,lg2[N + 5];
int cnt[N + 5];
int rev[N + 5],fac[N + 5],ifac[N + 5],inv[N + 5];
int rt[N + 5],irt[N + 5];
inline void init(int len)
{
	for(n = 1;n < len;n <<= 1);
	for(register int i = 2;i <= n;++i)
		lg2[i] = lg2[i >> 1] + 1;
	int w = fpow(G,(mod - 1) / n);
	rt[n >> 1] = 1;
	for(register int i = (n >> 1) + 1;i <= n;++i)
		rt[i] = (long long)rt[i - 1] * w % mod;
	for(register int i = (n >> 1) - 1;i;--i)
		rt[i] = rt[i << 1];
	fac[0] = 1;
	for(register int i = 1;i <= n;++i)
		fac[i] = (long long)fac[i - 1] * i % mod;
	ifac[n] = fpow(fac[n],mod - 2);
	for(register int i = n;i;--i)
		ifac[i - 1] = (long long)ifac[i] * i % mod;
	for(register int i = 1;i <= n;++i)
		inv[i] = (long long)ifac[i] * fac[i - 1] % mod;
}
inline void ntt(poly &a,int type,int n)
{
	type == -1 && (reverse(a.a + 1,a.a + n),1);
	int lg = lg2[n] - 1;
    for(register int i = 0;i < n;++i)
    	rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << lg),
		i < rev[i] && (swap(a[i],a[rev[i]]),1);
    for(register int w = 2,m = 1;w <= n;w <<= 1,m <<= 1)
        for(register int i = 0;i < n;i += w)
            for(register int j = 0;j < m;++j)
            {
                int t = (long long)rt[m | j] * a[i | j | m] % mod;
                a[i | j | m] = dec(a[i | j],t),a[i | j] = add(a[i | j],t);
            }
    if(type == -1)
    	for(register int i = 0;i < n;++i)
    		a[i] = (long long)a[i] * inv[n] % mod;
}
inline void mul(poly &a,const poly &b,int n)
{
	static poly x,y;
	int lim = 1;
    x.clear(),y.clear();
	for(;lim < (n << 1);lim <<= 1);
	x = a,y = b;
	x.clear(n),y.clear(n);
    ntt(x,1,lim),ntt(y,1,lim);
    for(register int i = 0;i < lim;++i)
        x[i] = (long long)x[i] * y[i] % mod;
    ntt(x,-1,lim);
    x.clear(n),a = x;
}
inline poly inverse(const poly &f,int n)
{
	static int s[30];
	static poly g,h,q;
	int lim = 1,top = 0;
	g.clear();
	for(;n > 1;s[++top] = n,n = (n + 1) >> 1);
	g[0] = fpow(f[0],mod - 2);
	for(;top;--top)
	{
		n = s[top];
		for(;lim < (n << 1);lim <<= 1);
		q = g,h = f,h.clear(n);
		ntt(g,1,lim),ntt(h,1,lim);
		for(register int i = 0;i < lim;++i)
			g[i] = (long long)g[i] * g[i] % mod * h[i] % mod;
		ntt(g,-1,lim);
		for(register int i = 0;i < n;++i)
			g[i] = dec(add(q[i],q[i]),g[i]);
		g.clear(n);
	}
	return g;
}
inline void derivative(poly &f,int n)
{
	for(register int i = 1;i < n;++i)
		f[i - 1] = (long long)f[i] * i % mod;
	f[n - 1] = 0;
}
inline void integral(poly &f,int n)
{
	for(register int i = n - 1;~i;--i)
		f[i + 1] = (long long)f[i] * inv[i + 1] % mod;
	f[0] = 0;
}
inline poly ln(const poly &f,int n)
{
	static poly g;
    g = f,derivative(g,n),mul(g,inverse(f,n),n),integral(g,n);
	return g;
}
inline poly exp(const poly &f,int n)
{
	static int s[30];
	static poly g,h;
	int lim = 1,top = 0;
    g.clear();
	for(;n > 1;s[++top] = n,n = (n + 1) >> 1);
	g[0] = 1;
	for(;top;--top)
	{
		n = s[top];
		for(;lim < (n << 1);lim <<= 1);
		h = g,g = ln(g,n);
		for(register int i = 0;i < n;++i)
			g[i] = dec(f[i],g[i]);
		g[0] = add(g[0],1);
		ntt(g,1,lim),ntt(h,1,lim);
		for(register int i = 0;i < lim;++i) 
			g[i] = (long long)g[i] * h[i] % mod;
		ntt(g,-1,lim);
		g.clear(n);
	}
	return g;
}
inline poly power(const poly &f,int k,int n)
{
    static poly g;
    g = ln(f,n);
    for(register int i = 0;i < n;++i)
        g[i] = (long long)g[i] * k % mod;
    g = exp(g,n);
    return g;
}
namespace Mod_sqrt
{
    typedef pair<int,int> cp;
    int w;
    inline cp operator*(const cp &a,const cp &b)
    {
        return cp(((long long)a.first * b.first % mod + (long long)a.second * b.second % mod * w % mod) % mod,((long long)a.first * b.second % mod + (long long)a.second * b.first % mod) % mod);
    }
    inline cp pow(cp a,int b)
    {
        cp ret(1,0);
        for(;b;b >>= 1)
            (b & 1) && (ret = ret * a,1),a = a * a;
        return ret;
    }
    inline int mod_sqrt(int x)
    {
        int y = rand() % mod;
        for(;fpow(w = ((long long)y * y % mod - x + mod) % mod,mod - 1 >> 1) <= 1;y = rand() % mod);
        cp ret = pow(cp(y,1),mod + 1 >> 1);
        return min(ret.first,mod - ret.first);
    }
}
using Mod_sqrt::mod_sqrt;
inline poly sqrt(const poly &f,int n)
{
	static int s[30];
	static poly g,h;
	int top = 0;
	g.clear();
	for(;n > 1;s[++top] = n,n = (n + 1) >> 1);
	g[0] = mod_sqrt(f[0]);
    for(;top;--top)
    {
        n = s[top];
        for(register int i = 0;i < n;++i)
            h[i] = add(g[i],g[i]);
        h = inverse(h,n),mul(g,g,n);
        for(register int i = 0;i < n;++i)
            g[i] = add(g[i],f[i]);
        mul(g,h,n);
    }
    return g;
}
inline int calc(int n,int m)
{
	if(m <= 0)
		return 0;
	static poly f;
	for(register int i = 0;i <= m;++i)
		f[i] = ifac[i];
	f.clear(m + 1),f = power(f,n,n - 1);
	return (long long)f[n - 2] * fac[n - 2] % mod;
}
int main()
{
    scanf("%d%d",&len,&m),init((len - 1) << 1);
    printf("%d\n",(calc(len,m - 1) - calc(len,m - 2) + mod) % mod);
}
```

---

## 作者：Fading (赞：8)

发现好多同学直接一笔带过了生成函数部分，我来补全一下。

### 转化问题

显然恰好不好求，我们转化一下。

发现可以转化成至多。

首先用$\texttt{prufer编码}$把数无根树的问题转化为序列问题。

那么问题就是

#### 求给一个长度为$n-2$的序列填上$n$个数，且每一个数出现次数最大值为$m-1$次的方案数。

设$f_{m,i,j}$表示前$j$个点，序列长度为$i$，每一个数至多出现$m$次的方案数。

发现答案就是$f_{m-1,n-2,n}-f_{m-2,n-2,n}$

### 开始$dp$

怎么$dp$呢？有一个$naive$的想法

在这个序列中，我们枚举第$j$个点的出现次数$k(k\geq m)$。

那么就有转移方程式：

$$f_{m,i,j}=\sum_{k=0}^{\min(m,i)}C_{i}^{k}f_{m,i-k,j-1}$$

就是钦定$k$个位置作为$j$，其他的填$1\sim (j-1)$内的数。

### 优化

显然过不去吧...

等等，这不是**指数型生成函数**的卷积？

设

$$F_{m,j}=\sum_{k=0}^{\infty}\frac {f_{m,k,j}}{k!}$$

则有

$$F_{m,j}=F_{m,j-1}\times \sum_{i=0}^{m}\frac{1}{i!}x^i$$

有些题解有问题，后面这个生成函数不是$e^x$。

所以我们多项式快速幂一下，就可以$O(n\log_2n)$通过此题？？？

由于我懒，所以我写了倍增快速幂...时间复杂度$O(n\log_2^2n)$

注意特判$n=1,2,m=1,2$的情况！

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
ll n,w[2200001],inv[2200001],fac[2200001],r[2200001],m,f[2200001],g[2200001];
inline ll fast_pow(ll a,ll b,ll p){
    ll t=1;a%=p;
    while (b){
        if (b&1LL) t=t*a%p;
        b>>=1LL;a=a*a%p;
    }
    return t;
}
inline void NTT(ll *f,ll lim,int id){
    w[0]=1;
    for (int i=0;i<lim;i++){
        if (i>r[i]) swap(f[i],f[r[i]]);
    }
    for (int len=1;len<lim;len<<=1){
        ll gen=fast_pow(3,(ljc-1)/(len<<1)*id+ljc-1,ljc);
        for (int i=1;i<len;i++) w[i]=w[i-1]*gen%ljc;
        for (int i=0;i<lim;i+=len<<1){
            ll *f1=f+i,*f2=f1+len;
            for (int j=0;j<len;j++){
                ll x=f1[j],y=f2[j]*w[j]%ljc;
                f1[j]=(x+y)%ljc;
                f2[j]=(x-y+ljc)%ljc;
            }
        }
    }
    if (id==1) return;
    ll INV=fast_pow(lim,ljc-2,ljc);
    for (int i=0;i<lim;i++) f[i]=f[i]*INV%ljc;
}
ll caca[2000001],cacb[2000001];
inline void Mul(ll *a,ll *b,ll *c,ll n,ll m,ll Len){
    ll lim=1,len=0;
    while (lim<=(n+m)) lim<<=1,len++;
    for (int i=0;i<lim;i++) caca[i]=cacb[i]=0,r[i]=(r[i>>1]>>1)|((i&1)<<(len-1));
    for (int i=0;i<n;i++) caca[i]=a[i];
    for (int i=0;i<m;i++) cacb[i]=b[i];
    NTT(caca,lim,1);NTT(cacb,lim,1);
    for (int i=0;i<lim;i++) c[i]=caca[i]*cacb[i]%ljc;
    NTT(c,lim,-1);
    for (int i=Len;i<lim;i++) c[i]=0;
}
inline int getans(int n,int m){
    if (m==-1) return 0;
    memset(g,0,sizeof g);memset(f,0,sizeof f);
    for (int i=0;i<=m;i++) g[i]=inv[i]; 
    f[0]=1;
    ll tmp=n;
    while (tmp){
        if (tmp&1LL) Mul(f,g,f,n,n,n);
        tmp>>=1LL;Mul(g,g,g,n,n,n);
    } 
    return (n-2<0?0:fac[n-2]*f[n-2]%ljc);
}
signed main(){
    n=read(),m=read();
    fac[0]=inv[0]=inv[1]=1;
    for (ll i=1;i<=max(n,m)+1;i++) fac[i]=fac[i-1]*i%ljc;
    for (ll i=2;i<=max(n,m)+1;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;
    for (ll i=1;i<=max(n,m)+1;i++) inv[i]=inv[i-1]*inv[i]%ljc;
    printf("%lld\n",(getans(n,m-1)-getans(n,m-2)+ljc)%ljc);
}


```


---

## 作者：SSerxhs (赞：4)

树的常用计数工具是矩阵树和purfer序，这题与度数相关明显使用purfer序。

题目为“恰好最大度数为M”，可以转化为“度数小于等于M”-“度数小于等于M-1”

转化到Purfer上就是：存在多少种长度为n-2、值域大小为n的序列，每个数字出现次数<=m

考虑dp，设f[i][j]为考虑到取值为1~i、填了j个数的方案数，则答案为f[n][n-2]，易得f[i][j]=f[i-1][j-k]*C(n-2-(j-k),k)，其中k是枚举第i个数使用多少次，显然k<=m

把组合数转阶乘可得f[i][j]=f[i-1][j-k]*fac[n-2-(j-k)]/fac[k]*fac[(n-2)-j]

即f[i][j]*fac[n-2-j]=f[i-1][j-k]*fac[n-2-(j-k)]*invfac[k]

设F[j]=f[i][j]*fac[n-2-j],G[j]=f[i-1][j]*fac[n-2-j]

则F[j]=G[j-k]*invfac[k]

可以明显看出是一个卷积形式，且总共转移n次，则直接多项式快速幂，复杂度O(nlog^2 n)，也可以用多项式exp/ln做到O(nlogn)

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=1.5e5+2,p=998244353;
int ifac[N],fac[N],inv[N],f[N],g[N],x[N],yg[N],ig[N],r[N];
int n,m,i,j,l,limit=1,ans;
inline int ksm(int x,int y)
{
    int r=1;
    while (y)
    {
        if (y&1) r=(ll)r*x%p;
        x=(ll)x*x%p;
        y>>=1;
    }
    return r;
}
void dft(int *a,int xs)
{
    int i,j,k,l,w,wn,b,c;
    for (i=1;i<limit;i++) if (i<r[i]) swap(a[i],a[r[i]]);
    for (i=1;i<limit;i=l)
    {
        l=i<<1;
        if (xs) wn=yg[l]; else wn=ig[l];
        for (j=0;j<limit;j+=l)
        {
            w=1;
            for (k=0;k<i;k++,w=(ll)w*wn%p)
            {
                b=a[j|k];c=(ll)a[j|k|i]*w%p;
                a[j|k]=(b+c)%p;
                a[j|k|i]=(b-c+p)%p;
            }
        }
    }
    if (!xs)
    {
        xs=ksm(limit,p-2);
        for (i=0;i<limit;i++) a[i]=(ll)a[i]*xs%p;
    }
}
void sol(int m)
{
    memset(g,0,limit<<2);
    l=n;
    for (i=0;i<=m;i++) g[i]=ifac[i];
    memset(f,0,limit<<2);
    f[0]=fac[n-2];
    l=n;
    while (l)
    {
        if (l&1)
        {
            memcpy(x,g,limit<<2);
            dft(f,1);dft(x,1);
            for (i=0;i<limit;i++) f[i]=(ll)f[i]*x[i]%p;
            dft(f,0);
            memset(f+n,0,limit-n<<2);
        }
        l>>=1;
        dft(g,1);
        for (i=0;i<limit;i++) g[i]=(ll)g[i]*g[i]%p;
        dft(g,0);
        memset(g+n,0,limit-n<<2);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    --m;
    inv[1]=ifac[1]=ifac[0]=fac[0]=fac[1]=1;
    for (i=2;i<=n;i++)
    {
        fac[i]=(ll)fac[i-1]*i%p;
        ifac[i]=(ll)ifac[i-1]*(inv[i]=p-(ll)p/i*inv[p%i]%p)%p;
    }
    while (limit<=n)
    {
        limit<<=1;++l;
    }
    limit<<=1;
    for (i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;
    ig[limit]=ksm(yg[limit]=ksm(3,(p-1)/limit),p-2);
    for (i=limit>>1;i;i>>=1)
    {
        yg[i]=(ll)yg[i<<1]*yg[i<<1]%p;
        ig[i]=(ll)ig[i<<1]*ig[i<<1]%p;
    }
    sol(m);
    ans=f[n-2];
    sol(m-1);
    ans=(ans-f[n-2]+p)%p;
    printf("%d",ans);
}
```

---

## 作者：Weng_Weijie (赞：4)

考虑这棵树的 Prufer 序列

令 $a_i$ 为 $i$ 在 Prufer 序列中出现次数

那么 $d_i=a_i+1, \sum a_i=n-2$，$d_i$ 为 $i$ 的度数

确定了每个点的出现次数，这样的序列数就是一个重排列，即 $\dfrac{(n-2)!}{\prod a_i!}$

而题目要求最大度数等于 $M$, 就等于最大度数 $\leq M$ 方案数减去最大度数 $\leq M-1$ 方案数

现在考虑最大度数 $\leq M$ 方案数

令生成函数 $F(x)=\displaystyle\sum_{i=0}^{m-1}\dfrac{x^i}{i!}$

答案就是 $(n-2)![x^{n-2}]F^n(x)$

可以使用多项式对数/指数函数，做到 $O(n\log n)$

也可以直接快速幂 $O(n\log^2n)$

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

const int mod = 998244353;
const int N = 131072;
using LL = long long;
void reduce(int &x) {
	x += x >> 31 & mod;
}
int pow(int x, int y, int ans = 1) {
	for (; y; y >>= 1, x = (LL) x * x % mod)
		if (y & 1) ans = (LL) ans * x % mod;
	return ans;
}
int lim, s, rev[N], wn[N], w[N];
void fftinit(int len) {
	wn[0] = lim = 1, s = -1; while (lim < len) lim <<= 1, ++s;
	for (int i = 0; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
	const int g = pow(3, (mod - 1) / lim);
	for (int i = 1; i < lim; ++i) wn[i] = (LL) wn[i - 1] * g % mod;
}
void fft(int *A, int typ) {
	for (int i = 0; i < lim; ++i) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
	for (int i = 1; i < lim; i <<= 1) {
		for (int j = 0, t = lim / i / 2; j < i; ++j) w[j] = wn[j * t];
		for (int j = 0; j < lim; j += i << 1)
			for (int k = 0; k < i; ++k) {
				const int x = A[k + j], y = (LL) A[k + j + i] * w[k] % mod;
				reduce(A[k + j] += y - mod), reduce(A[k + j + i] = x - y);
			}
	}
	if (!typ) {
		const int il = pow(lim, mod - 2);
		for (int i = 0; i < lim; ++i) A[i] = (LL) A[i] * il % mod;
		std::reverse(A + 1, A + lim);
	}
}
void inv(int *A, int *B, int n) {
	static int C[N], D[N];
	if (n == 1) { B[0] = pow(A[0], mod - 2); return; }
	int n_ = n + 1 >> 1; inv(A, B, n_), fftinit(n + n_ + 1);
	std::memcpy(C, A, n << 2), std::memset(C + n, 0, lim - n << 2);
	std::memcpy(D, B, n_ << 2), std::memset(D + n_, 0, lim - n_ << 2);
	fft(C, 1), fft(D, 1);
	for (int i = 0; i < lim; ++i)
		C[i] = (mod + 2 - (LL) C[i] * D[i] % mod) * D[i] % mod;
	fft(C, 0);
	std::memcpy(B + n_, C + n_, n - n_ << 2);
}
void differential(int *A, int *B, int n) {
	for (int i = 0; i < n - 1; ++i)
		B[i] = (LL) A[i + 1] * (i + 1) % mod;
	B[n - 1] = 0;
}
void integrate(int *A, int *B, int n) {
	for (int i = n - 1; ~i; --i)
		B[i + 1] = (LL) A[i] * pow(i + 1, mod - 2) % mod;
	B[0] = 0;
}
void ln(int *A, int *B, int n) {
	static int C[N], D[N];
	inv(A, C, n), differential(A, D, n);
	fftinit(n + n - 1);
	std::memset(C + n, 0, lim - n << 2), std::memset(D + n, 0, lim - n << 2);
	fft(C, 1), fft(D, 1);
	for (int i = 0; i < lim; ++i)
		C[i] = (LL) C[i] * D[i] % mod;
	fft(C, 0);
	integrate(C, B, n);
}
void exp(int *A, int *B, int n) {
	static int C[N], D[N];
	if (n == 1) { B[0] = 1; return; }
	int n_ = n + 1 >> 1; exp(A, B, n_);
	ln(B, C, n), fftinit(n + 1);
	for (int i = 0; i < n; ++i) reduce(C[i] = A[i] - C[i]);
	std::memset(C + n, 0, lim - n << 2);
	std::memcpy(D, B, n_ << 2), std::memset(D + n_, 0, lim - n_ << 2);
	fft(C, 1), fft(D, 1);
	for (int i = 0; i < lim; ++i)
		C[i] = (LL) C[i] * D[i] % mod;
	fft(C, 0);
	std::memcpy(B + n_, C + n_, n - n_ << 2);
}
int n, m, f[N], g[N], factor[N], ifactor[N];

int get_ans(int m) {
	std::memset(f, 0, sizeof f), std::memset(g, 0, sizeof g);
	for (int i = 0; i < m; ++i) f[i] = ifactor[i];
	ln(f, g, n - 1);
	for (int i = 0; i < n - 1; ++i)
		f[i] = 0, g[i] = (LL) g[i] * n % mod;
	exp(g, f, n - 1);
	return (LL) f[n - 2] * factor[n - 2] % mod;
}
int main() {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> n >> m;
	factor[0] = 1;
	for (int i = 1; i < n - 1; ++i)
		factor[i] = (LL) factor[i - 1] * i % mod;
	ifactor[n - 2] = pow(factor[n - 2], mod - 2);
	for (int i = n - 3; ~i; --i)
		ifactor[i] = (LL) ifactor[i + 1] * (i + 1) % mod;
	int ans = get_ans(m) - get_ans(m - 1); reduce(ans);
	std::cout << ans << '\n';
	return 0;
}

```

---

## 作者：Lyrella (赞：2)

# 题意

题目让你求 $n$ 个点且最大点度为 $m$ 的有标号无根树个数。

# 题解

我们可以从上面的题意中找到一些关键字眼：**最大点度**、**有标号无根树**。这些无不指向同一个东西：prufer 序列！

首先每个 prufer 序列都对应一个有标号无根树，其次一个数在序列中的**出现次数加一**就是其度数，所以我们将题目转化成下面形式：

在序列上填数，序列长度为 $n-2$，填数的范围是 $[1,n]$，需要满足出现次数最多的数出现了 $m-1$ 次，求方案数。

因为最多**恰好出现** $m-1$ 次不好计数，所以容斥。考虑出现次数小于 $m$ 次的数量减去小于 $m-1$ 的数量。现在问题被进一步简化，考虑求最多出现次数小于 $m$ 次的填数方案数。

解决这种组合问题最简洁的我认为是 EGF。尝试用 EGF 去刻画这个问题，我们先从最简单的开始。考虑只填一个数，其出现次数的 EGF 为 $F(x)=\sum\limits_{i=0}^m{x^i\over i!}$。我们知道 EGF 相乘会多出一个组合数，也就是说 EGF 相乘可以刻画组合问题。对于此题也是如此。我们将 $F(x)$ 连续乘 $n-2$ 次，就刻画了将 $n$ 种不同的数填进长度为 $n-2$ 的序列的过程。所以答案就是 $[x^{n-2}]F(x)^n$。多项式快速幂可用不同方法解决，这里用的是 $O(n\log n)$ 的做法。

# 代码

```cpp
//前面全是多项式板子
int n, m;
int a[N], b[N];
int Fac[N];

int sol(int m){
    if(m < 1)return 0;
    a[0] = 1;
    memset(b, 0, sizeof b);
    int CC = 0, NN = n; while(NN)NN /= 10, ++CC;
    for(int i = 1; i <= m; ++i)a[i] = Mul(a[i - 1], ii[i]);
    for(int i = m + 1; i < n - 1; ++i)a[i] = 0;
    Pqmi(a, b, n - 2, n, n, CC);
    return Mul(b[n - 2], Fac[n - 2]);
}

signed main(){//remember init(N - 1)
    init(N - 1); n = rd(); m = rd(); Fac[0] = 1;
    for(int i = 1; i < N; ++i)Fac[i] = Mul(Fac[i - 1], i);
    cout << Sub(sol(m - 1), sol(m - 2));
    return 0;
}
```

---

## 作者：Mashu77 (赞：0)

树上计数，和度数有关，容易想到 prufer 序列。则转化为：在 
$[
1
,
n
−
2
]$
 中填 
$[
1
,
n
]$，使得出现次数最大的数出现 
$m
−
1$
 次。容斥一下，为不超过 
$m
−
1$
 减去不超过 $m
−
2$。
不超过 
$m$，可以使用生成函数。不难得出答案为

$$(n-2)![x^{n-2}]F^n(x)\\F(x)=\sum_{i=0}^{m}\frac{x^i}{i!}$$

其中生成函数的含义为可重集合的全排列。快速幂+ NTT 即可。时间复杂度 
$O
(
n
\log
^2
n
)$。

```cpp
int work(int m){
	register int i;
	for(i=0;i^m;++i)a[i]=ifac[i];
	polyln(n,a,b);
	for(i=0;i^n;++i)b[i]=1ll*b[i]*(n+1)%mod,a[i]=0;
	polyexp(n,b,a);i=n-1;ans=1ll*a[i]*fac[i]%mod;
	for(i=0;i^n;++i)a[i]=b[i]=0;
	return ans;
}
int main(){
	read(n);read(m);--n;
	register int i;prepare();
	write(sub(work(m),work(m-1)));
}
```

---

## 作者：Arghariza (赞：0)

<https://www.cnblogs.com/Ender32k/p/17571587.html>

小清新 prufer 序列。

> 给定 $n,m$，求 $n$ 个点且最大度数为 $m$ 的有标号无根树个数。

看到度数，不难想到 prufer 序列。

众所周知，prufer 序列给出了长度为 $n-2$ 值域为 $n$ 的序列与带标号无根树的双射。某个点的度数为 $d_u$，那么 $u$ 在 prufer 序列中出现了 $d_u-1$ 次。

所以题目就转化成：

> 给定 $n,m$，求长度为 $n-2$，值域为 $n$ 的序列，使得出现次数最多的数恰出现了 $m-1$ 次。

考虑“恰好”的限制是困难的，转化为**所有数**出现次数不超过 $m-1$ 次的答案减去出现次数不超过 $m-2$ 次的答案。

现在考虑求出所有点出现次数不超过 $m-1$ 次的答案。

此时值域 $[1,n]$ 相当于 $n$ 种颜色，我们考虑对颜色单独计数，然后将它们的 EGF 相乘得到颜色混合的答案。显然一种颜色不能超过 $m-1$ 个相当于次数的限制，那么：

$$F(x)=\sum\limits_{i=0}^{m-1}\frac{x_i}{i!}$$

这是一种颜色的 EGF（为什么是 EGF？是因为我们对于**序列**计数，颜色之间的顺序是有关系的）。那么 $n$ 种颜色的 EGF 卷一下，第 $n-2$ 项的系数即为所求：

$$\text{ans}=(n-2)![x^{n-2}]F^n(x)$$

倍增快速幂即可。复杂度 $O(n\log^2n)$。

```cpp
// Problem: P5219 无聊的水题 I
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5219
// Memory Limit: 500 MB
// Time Limit: 6000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    #if ONLINE_JUDGE
    #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    #else
    #define gh() getchar()
    #endif
    #define mt make_tuple
    #define mp make_pair
    #define fi first
    #define se second
    #define pc putchar
    #define pb emplace_back
    #define ins insert
    #define era erase
    typedef tuple<int, int, int> tu3;
    typedef pair<int, int> pi;
    inline int rd() {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void wr(int x) {
        if (x < 0) x = ~(x - 1), putchar('-');
        if (x > 9) wr(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace vbzIO;

const int N = 1e6 + 100;
const int P = 998244353;
const int G = 114514;
int len, lim, f[N], g[N], tr[N], fac[N], ifac[N], inv[N];

int qpow(int p, int q) {
	int res = 1;
	for (; q; q >>= 1, p = 1ll * p * p % P)
		if (q & 1) res = 1ll * res * p % P;
	return res;
}

const int iG = qpow(G, P - 2);

void init(int lim) {
	fac[0] = ifac[0] = inv[1] = 1;
	for (int i = 1; i <= lim; i++) {
		if (i > 1) inv[i] = 1ll * inv[P % i] * (P - P / i) % P;
		fac[i] = 1ll * fac[i - 1] * i % P;
		ifac[i] = 1ll * ifac[i - 1] * inv[i] % P;
	}
}

void NTT(int *f, int op) {
	for (int i = 0; i < len; i++)
		if (i < tr[i]) swap(f[i], f[tr[i]]);
	for (int o = 2, k = 1; k < len; o <<= 1, k <<= 1) {
		int tg = qpow(~op ? G : iG, (P - 1) / o);
		for (int i = 0; i < len; i += o) {
			for (int j = 0, w = 1; j < k; j++, w = 1ll * w * tg % P) {
				int x = f[i + j], y = 1ll * w * f[i + j + k] % P;
				f[i + j] = (x + y) % P, f[i + j + k] = (x - y + P) % P;
			}
		}
	}
	if (~op) return;
	int iv = qpow(len, P - 2);
	for (int i = 0; i < len; i++)
		f[i] = 1ll * f[i] * iv % P;
}

void Mul(int n, int *f, int *g, int *h) {
	static int tf[N], tg[N];
	len = 1, lim = 0;
	while (len <= ((n - 1) << 1)) len <<= 1, lim++;
	for (int i = 1; i < len; i++)
		tr[i] = (tr[i >> 1] >> 1) | ((i & 1) << (lim - 1));
	for (int i = 0; i <= n - 2; i++) 
		tf[i] = f[i], tg[i] = g[i];
	for (int i = n - 1; i < len; i++)
		tf[i] = tg[i] = 0;
	NTT(tf, 1), NTT(tg, 1);
	for (int i = 0; i < len; i++)
		tf[i] = 1ll * tf[i] * tg[i] % P;
	NTT(tf, -1);
	for (int i = 0; i <= n - 2; i++)
		h[i] = tf[i];
}

int calc(int n, int m) {
	memset(f, 0, sizeof(f));
	for (int i = 0; i <= min(m - 1, n - 2); i++) 
		f[i] = ifac[i];
	memset(g, 0, sizeof(g)), g[0] = 1;
	int tp = n;
	for (; tp; tp >>= 1, Mul(n, f, f, f))
		if (tp & 1) Mul(n, g, f, g);
	return 1ll * fac[n - 2] * g[n - 2] % P;
}

int main() {
    int n = rd(), m = rd();
    init(max(n, m));
    wr((calc(n, m) - calc(n, m - 1) + P) % P); 
    return 0;
}
```

---

## 作者：Y_B_X (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P5219)

>题意：求 $n$ 个点的，最大度数为 $m$ 的有标号无根树，$n\leq 5\times 10^4$。

提供一种不需要涉及 $\text{prufer}$ 序的方法。

由于要求最大度数为 $m$，只需用度数 $\leq m$ 的方案减去度数 $\leq m\!-\!1$ 的方案。

设 $a_n$ 为 $n$ 个点的所有点度数 $\leq m$ 的方案。

由于一颗**有根树**可以通过选出一个根，与几个**有根树的根**相连组成。

这个操作中会将原先有根树的**根的度数** $+1$。

所以可以设 $f_n$ 为 $n$ 个点的有根树，满足根节点的度数 $<m$，其他点度数 $\leq m$。

所以 $\displaystyle f_{n+1}=(n\!+\!1)\sum_{k<m}\dfrac{1}{k!}\sum_{\sum\limits_{i=1}^kn_i=n}\binom{n}{n_1,n_2\cdots n_k}\prod_{i=1}^{k}f_{n_i}$

式子中 $n\!+\!1$ 是选出根的方案，$\dfrac{1}{k!}$ 是为了去重 $n_i$ 的枚举顺序。

对两边取 $\text{EGF}$ 得到 $\displaystyle \dfrac{F(x)}{x}=\sum_{k<m}\dfrac{F(x)^k}{k!}$，这很有拉格朗日反演的形式，先确定我们要求什么。

由于根节点度数 $<m$，只需选出两部分，将这两部分的根相连，就能使所有点度数 $\leq m$。

这样每个树会被计入 $n-1$ 次，即边的个数。

于是有 $a_n=\dfrac{1}{n\!-\!1}\left[\dfrac{x^n}{n!}\right]\dfrac{F(x)^2}{2}=(n\!-\!2)!n\left[x^n\right]\dfrac{F(x)^2}{2}$

通过(扩展)拉格朗日反演，有 $\displaystyle \left[x^n\right]\dfrac{F(x)^2}{2}=\dfrac{1}{n}\left[x^{n-1}\right]x\left(\sum_{k<m}\dfrac{x^k}{k!}\right)^n$

最终得出 $\displaystyle a_n=(n\!-\!2)!\left[x^{n-2}\right]\left(\sum_{k<m}\dfrac{x^k}{k!}\right)^n$

主要代码：

```cpp
int work(int m){
	register int i;
	for(i=0;i^m;++i)a[i]=ifac[i];
	polyln(n,a,b);
	for(i=0;i^n;++i)b[i]=1ll*b[i]*(n+1)%mod,a[i]=0;
	polyexp(n,b,a);i=n-1;ans=1ll*a[i]*fac[i]%mod;
	for(i=0;i^n;++i)a[i]=b[i]=0;
	return ans;
}
int main(){
	read(n);read(m);--n;
	register int i;prepare();
	write(sub(work(m),work(m-1)));
}
```

---

## 作者：KAMIYA_KINA (赞：0)

## Tag

生成函数，多项式。

## Description

求一颗大小为 $n$ 的有标号无根树中，最大的点度数恰为 $m$ 的方案数。

$\texttt{data range:} n\leq 5\times 10^4$.

## Solution

恰为这个条件非常不美观，考虑变成**最多为** $m$ 然后减去最多为 $m-1$ 的方案数就可以了。

对于有标号无根树我们有 prufer 序列可以很好的描述有标号无根树问题。

一个 prufer 序列是一个长度为 $n-2$ 的序列，其可以唯一的确定一个大小为 $n$ 的有标号无根树。

实际上很容易发现在一棵有标号无根树上，如果一个点的度数为 $k$，那么其在 prufer 序列上会出现 $k-1$ 次，根据 prufer 序列的构造易证。

那么我们的问题转化到了求一个长度为 $n$ 的正整数序列中一个数最多出现 $m-1$ 次的方案数。

不难刻画一个 EGF 来表示某一个数的生成函数，我们设这个生成函数为 $F(x)$，显然有：

$$
F(x) = \sum_{i=0}^{m-1} \dfrac{x^i}{i!}
$$

那么我们要求的转化后的问题的答案就是 $n$ 个生成函数的卷积其中的第 $n-2$ 次项，也就是 $\left[\dfrac{x^{n-2}}{(n-2)!}\right]F(x)^n$。

一个 EGF 组合意义的解释。

对于两个集合而言，普通的 OGF 卷积表示的是这两个集合无标号意义下的并集。具体一点，就是一个集合直接塞到另一个集合后面。

但是 EGF 所表示的是两个集合有标号意义下的并集，可以体现顺序。

更具体一点，假设 `aa` 为第一个集合，`bb` 为第二个集合，那么 OGF 的并为 `aabb`，EGF 的并为 `aabb`,`abab`,`abba`,`baab`,`baba`,`bbaa` 六种情况。

可以很清晰的看清楚差别了吧……

本题可以用时间复杂度为 $O(n\lg k \lg n)$ 的直接快速幂，也可以用 $O(n\lg n)$ 的多项式 $\exp$ 型快速幂。

笔者用的是后者。

## Code

```cpp
using ll = long long;
using poly = vector<int>;

const int N = 2e5 + 10;
const int mod = 998244353, g = 3;

inline void chk(int &x) {x -= mod; x += x >> 31 & mod;}
inline int mll(int x, int y) {return (ll) x * y % mod;}
inline int add(int x, int y) {chk(x += y); return x;}
inline int del(int x, int y) {return add(x, mod - y);}

inline int ksm(int x, int y) {
    int ret = 1;
    for(; y; y >>= 1, x = mll(x, x))
        if(y & 1) ret = mll(ret, x);
    return ret;
}

int fc[N], fv[N], inv[N];
inline void pref(const int lim) {
    fc[0] = 1;
    FOR(i, 1, lim) fc[i] = mll(fc[i - 1], i);
    fv[lim] = ksm(fc[lim], mod - 2);
    ROF(i, lim, 1) fv[i - 1] = mll(fv[i], i);
    FOR(i, 1, lim) inv[i] = mll(fv[i], fc[i - 1]);
    return ;
}

int rev[N << 1];
inline int getrev(const int n) {
    int len = 1, tim = 0;
    while(len < n) len <<= 1, tim++;
    FOR(i, 0, len) rev[i] = rev[i >> 1] >> 1 | ((i & 1) << (tim - 1));
    return len;
}

void NTT(poly &F, int n, bool typ) {
    F.resize(n);
    FOR(i, 0, n - 1) if(i < rev[i]) swap(F[i], F[rev[i]]);
    for(int i = 1; i < n; i <<= 1) {
        int gn = ksm(g, (mod - 1) / (i << 1));
        for(int j = 0, g0 = 1, x, y; j < n; j += (i << 1), g0 = 1)
        for(int k = 0; k < i; k++, g0 = mll(gn, g0)) {
            x = F[j + k], y = mll(F[i + j + k], g0);
            F[j + k] = add(x, y);
            F[i + j + k] = del(x, y);
        }
    }
    if(typ) return ;
    reverse(F.begin() + 1, F.end()); int iv = ksm(n, mod - 2);
    FOR(i, 0, n - 1) F[i] = mll(F[i], iv);
    return ;
}

poly operator + (const poly a, const poly b) {
    poly C(max(a.size(), b.size()));
    for(int i = 0; i < C.size(); i++)
        C[i] = add(i < a.size() ? a[i] : 0, i < b.size() ? b[i] : 0);
    return C;
}

poly operator - (const poly a, const poly b) {
    poly C(max(a.size(), b.size()));
    for(int i = 0; i < C.size(); i++)
        C[i] = del(i < a.size() ? a[i] : 0, i < b.size() ? b[i] : 0);
    return C;
}

poly operator * (const poly a, const poly b) {
    int n = a.size() + b.size() - 1, len = getrev(n);
    poly A = a, B = b;
    A.resize(len), B.resize(len);
    NTT(A, len, 1), NTT(B, len, 1);
    FOR(i, 0, len - 1) A[i] = mll(A[i], B[i]);
    NTT(A, len, 0), A.resize(n);
    return A;
}

poly operator * (const poly a, const int x) {
    poly A = a;
    FOR(i, 0, a.size() - 1) A[i] = mll(A[i], x);
    return A;
}

poly DI(const poly a) {
    poly C(a.size() - 1);
    FOR(i, 0, C.size() - 1) C[i] = mll(i + 1, a[i + 1]);
    return C;
}

poly IG(const poly a) {
    poly C(a.size() + 1);
    FOR(i, 1, C.size() - 1) C[i] = mll(inv[i], a[i - 1]);
    return C;
}

poly INV(const poly a) {
    poly B; B.push_back(ksm(a[0], mod - 2));
    int n = a.size() << 1;
    for(int mx = 2; mx < n; mx <<= 1) {
        poly C = a; C.resize(mx);
        int len = getrev(mx << 1);
        NTT(B, len, 1), NTT(C, len, 1);
        FOR(i, 0, len - 1) B[i] = mll(B[i], del(2, mll(B[i], C[i])));
        NTT(B, len, 0); B.resize(mx);
    }
    return B.resize(a.size()), B;
}

poly LN(const poly A) {
    poly C = IG(DI(A) * INV(A));
    return C.resize(A.size()), C;
}

poly EXP(const poly A) {
    poly B; B.push_back(1);
    int n = A.size() << 1;
    for(int mx = 2; mx < n; mx <<= 1) {
        poly C = A; 
        C.resize(mx), B.resize(mx);
        B = B * (poly(1, 1) - LN(B) + C);
    }
    return B.resize(A.size()), B;
}

poly Mulx(poly A) {
    A.push_back(0);
    ROF(i, A.size() - 1, 1) A[i] = A[i - 1];
    return A;
}

poly Divx(poly A) {
    FOR(i, 0, A.size() - 2) A[i] = A[i + 1];
    A.pop_back();
    return A;
}

void print(poly A) {FOR(i, 0, A.size() - 1) cout << A[i] << " \n"[i == ii];}

inline void solve() {
    int n = rd, m = rd;
    pref(n << 2);
    poly F, G;
    FOR(i, 0, m - 1) F.push_back(fv[i]);
    F.resize(n + 1), F = EXP(LN(F) * n);
    FOR(i, 0, m - 2) G.push_back(fv[i]);
    G.resize(n + 1), G = EXP(LN(G) * n);
    cout << mll(del(F[n - 2], G[n - 2]), fc[n - 2]) << '\n';
    return ;
}
```

---

## 作者：_ctz (赞：0)

[My blog](https://ctz45562.github.io/2020/01/13/洛谷-P5219-无聊的水题-I/)

[传送门](https://www.luogu.com.cn/problem/P5218)

转换一下，最大度数恰好为$m$的方案数即为最大度数不超过$m$的方案数减去不超过$m-1$的方案数。

无根树？有标号？度数？数数？$prufer$序列！

最大度数不超过$m$的方案数就是值域为$[1,n]\bigcap \mathbb{Z}$、长度为$n-2$、任意元素出现次数不超过$m-1$的序列个数。

如果每个点度数是确定的，其方案数为：$\dfrac{(n-2)!}{\prod\limits_{i=1}^n(d_i-1)!}$。

于是可以构造一个$EGF$：$F(x)=\sum\limits_{i=0}^{m-1}\dfrac{x^i}{i!}$，$i$表示一个点的出现次数。

考虑$F\times F$的意义：一个$\dfrac{x^i}{i!}$和$\dfrac{x^j}{j!}$相乘，对$x^{i+j}$有$\dfrac{1}{i!j!}$的贡献。

这和前面确定度数的式子很吻合。于是答案为$(n-2)![x^{n-2}]F^n(x)$。

多项式快速幂即可。懒得写$\ln$和$\exp$，直接$O(n\log^2n)$暴力好了。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 140005	
#define inf 0x3f3f3f3f

const int mod = 998244353;
const int g = 3;

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
inline int quickpow(int x,int y=mod-2){
	int ans=1;
	while(y){
		if(y&1)ans=1ll*ans*x%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return ans;
}
const int ig = quickpow(g);
int tr[maxn];
inline int qm(int x){return x>=mod?x-mod:x;}
void NTT(int *f,int n,bool t){
	for(register int i=0;i<n;++i)if(i<tr[i])swap(f[i],f[tr[i]]);
	for(register int p=2;p<=n;p<<=1){
		int len=p>>1,o=quickpow(t?ig:g,(mod-1)/p);
		for(register int i=0;i<n;i+=p){
			int gen=1,cop;
			for(register int j=i;j<i+len;++j){
				cop=1ll*f[j+len]*gen%mod,gen=1ll*gen*o%mod;
				f[j+len]=qm(f[j]+mod-cop),f[j]=qm(f[j]+cop);
			}
		}
	}
	if(t){
		int inv=quickpow(n);
		for(register int i=0;i<n;++i)f[i]=1ll*f[i]*inv%mod;
	}
}
int F[maxn];
void Pow(int *g,int n,int y){
	int lim=1;
	while(lim<n<<1)lim<<=1;
	for(register int i=0;i<lim;++i)tr[i]=(tr[i>>1]>>1)|(i&1?lim>>1:0);
	NTT(g,lim,0),--y;
	for(register int i=0;i<lim;++i)F[i]=g[i];
	while(y){
		if(y&1){
			for(register int i=0;i<lim;++i)F[i]=1ll*F[i]*g[i]%mod;
			NTT(F,lim,1);
			for(register int i=n;i<lim;++i)F[i]=0;
			NTT(F,lim,0);
		}
		for(register int i=0;i<lim;++i)g[i]=1ll*g[i]*g[i]%mod;
		NTT(g,lim,1);
		for(register int i=n;i<lim;++i)g[i]=0;
		NTT(g,lim,0);
		y>>=1;
	}
	NTT(F,lim,1);
	for(register int i=0;i<n;++i)g[i]=F[i],F[i]=0;
	for(register int i=n;i<lim;++i)g[i]=F[i]=0;
}
int fac[maxn]={1},inv[maxn],f[maxn];
inline int calc(int n,int m){
	memset(f,0,sizeof f);
	for(register int i=0;i<m;++i)f[i]=inv[i];
	Pow(f,n-1,n);
	return 1ll*fac[n-2]*f[n-2]%mod;
}
int main(){
	int n=read(),m=read(),t=max(n,m);
	for(register int i=1;i<=t;++i)fac[i]=1ll*fac[i-1]*i%mod;
	inv[t]=quickpow(fac[t]);
	for(register int i=t-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	printf("%d\n",qm(calc(n,m)+mod-calc(n,m-1)));
}
```

---


# 特工的信息流

## 题目背景

$\text{TYM}$ 是一名特工。  
$\text{TYM}$ 所在的国家正受到侵犯，他被赋予一个任务：于城市之间传递信息。

## 题目描述

$\text{TYM}$ 所在的国家有 $n$ 个城市，编号为 $1,\dots,n$，由 $n - 1$ 条双向道路连接。保证任意两个城市间都有唯一的简单路径。  
以及，每个城市都有一个信息流的流量 $a_i$。

$\text{TYM}$ 一共要执行 $m_0$ 个任务，每个任务给定两个城市 $s,t$，其执行过程如下：  
第一个时刻，他从城市 $s$ 出发，以每个时刻移动到下一个城市的速度，走 $s,t$ 之间的简单路径到 $t$。  
每到达一个城市，他都会把这个城市的信息流 $a_i$ 发送到经过的每个城市。  
我们约定，他到达一个城市的同一时刻也会把这个城市的信息流发送给这个城市。我们定义一个城市的价值为这个城市所接受到的信息流的乘积。

请你求出每个任务中，$s$ 到 $t$ 的简单路径上经过的城市的价值的总和对 $20924$ 取模的结果。

此外，不幸地，由于侵略者同时也在行动，所以在他执行多个任务之间，可能会有某个 $a_i$ 发生改变。

他的任务总数与改变某个 $a_i$ 的次数之和为 $m$。

## 说明/提示

**数据范围：**

对于 $20\%$ 的数据，$1 \leq n,m \leq 2000$；  
对于额外的 $20\%$ 的数据，满足 $a_i=2$，且没有修改操作；  
对于额外的 $20\%$ 的数据，满足道路从 $i$ 连向 $i+1$；  
对于 $100\%$ 的数据，$1 \leq n,m \leq 10^5,1 \leq a_i \leq 20923$。

**样例解释：**

第一个询问，$1 \cdot 2 \cdot 3 \cdot 4 \cdot 5 + 2 \cdot 3 \cdot 4 \cdot 5 + 3 \cdot 4 \cdot 5 + 4 \cdot 5 + 5 = 325$；  
修改，$a_1 = 1 + 2 = 3$；  
第二个询问，$3 \cdot 2 \cdot 3 \cdot 4 \cdot 5 + 2 \cdot 3 \cdot 4 \cdot 5 + 3 \cdot 4 \cdot 5 + 4 \cdot 5 + 5 = 565$；

## 样例 #1

### 输入

```
5 3
1 2 3 4 5
1 2
2 3
3 4
4 5
Q 1 5
C 1 2
Q 1 5```

### 输出

```
325
565```

# 题解

## 作者：Aleph1022 (赞：4)

本文同步发表于我的博客：https://www.alpha1022.me/articles/lg-5220.htm

这题虽然原 idea 是我的，但是 noname 改了之后我就一直咕咕咕没做了。  
今天闲得发慌来练手速……

写完这题的第一感觉是可以回去把「SDOI2011」颜色 的坑给填了（虽然我还是没打算写

其实做法比较显然，先考虑在序列上的做法，线段树维护区间后缀积之和 和区间积，那么合并左右子树的时候，根据乘法分配律可得：

$$\sum_{i=l}^r\prod_{j=i}^r a_j = \prod_{i=m+1}^r a_i\left(\sum_{i=l}^m\prod_{j=i}^m a_j\right) + \sum\limits_{i=m+1}^r\prod\limits_{j=i}^r a_j (m \in [l,r))$$

于是就显然。

考虑把这个做法放到树上，但是这个时候我们发现如果把路径从 LCA 划分成两段的话，有一段需要用与答案相反**前缀积之和**来统计，于是改一改线段树就好了。

关于此题树剖做法的码量瓶颈，我认为应该在于查询的过程……  
必须保证思路清晰才能不写错。

然后是取模的问题，虽然模数很小但是也印证了那句话：

> 不开 long long 见祖宗，十年 OI 一场空。

代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <utility>
#define ls (p << 1)
#define rs (ls | 1)
using namespace std;
const int N = 1e5;
const long long mod = 20924;
int n,m;
long long a[N + 5];
int to[(N << 1) + 5],pre[(N << 1) + 5],first[N + 5];
inline void add(int u,int v)
{
	static int tot = 0;
	to[++tot] = v;
	pre[tot] = first[u];
	first[u] = tot;
}
int fa[N + 5],dep[N + 5],sz[N + 5],son[N + 5],top[N + 5],id[N + 5],rk[N + 5];
void dfs1(int p)
{
	sz[p] = 1;
	for(register int i = first[p];i;i = pre[i])
		if(to[i] ^ fa[p])
		{
			fa[to[i]] = p,dep[to[i]] = dep[p] + 1;
			dfs1(to[i]),sz[p] += sz[to[i]];
			if(!son[p] || sz[to[i]] > sz[son[p]])
				son[p] = to[i];
		}
}
void dfs2(int p)
{
	static int tot = 0;
	rk[id[p] = ++tot] = p;
	if(!son[p])
		return ;
	top[son[p]] = top[p],dfs2(son[p]);
	for(register int i = first[p];i;i = pre[i])
		if(!id[to[i]])
			top[to[i]] = to[i],dfs2(to[i]);
}
struct segnode
{
	long long prod,sufsum,presum;
} seg[(N << 2) + 10];
void build(int p,int tl,int tr)
{
	if(tl == tr)
	{
		seg[p].prod = seg[p].sufsum = seg[p].presum = a[rk[tl]];
		return ;
	}
	int mid = tl + tr >> 1;
	build(ls,tl,mid);
	build(rs,mid + 1,tr);
	seg[p].prod = seg[ls].prod * seg[rs].prod % mod;
	seg[p].sufsum = (seg[ls].sufsum * seg[rs].prod % mod + seg[rs].sufsum) % mod;
	seg[p].presum = (seg[rs].presum * seg[ls].prod % mod + seg[ls].presum) % mod;
}
void modify(int x,int k,int p,int tl,int tr)
{
	if(tl == tr)
	{
		seg[p].prod += k,seg[p].sufsum += k,seg[p].presum += k;
		return ;
	}
	int mid = tl + tr >> 1;
	if(x <= mid)
		modify(x,k,ls,tl,mid);
	else
		modify(x,k,rs,mid + 1,tr);
	seg[p].prod = seg[ls].prod * seg[rs].prod % mod;
	seg[p].sufsum = (seg[ls].sufsum * seg[rs].prod % mod + seg[rs].sufsum) % mod;
	seg[p].presum = (seg[rs].presum * seg[ls].prod % mod + seg[ls].presum) % mod;
}
long long query_prod(int l,int r,int p,int tl,int tr)
{
	if(l <= tl && tr <= r)
		return seg[p].prod;
	int mid = tl + tr >> 1;
	long long ret = 1;
	if(l <= mid)
		ret = ret * query_prod(l,r,ls,tl,mid) % mod;
	if(r > mid)
		ret = ret * query_prod(l,r,rs,mid + 1,tr) % mod;
	return ret;
}
long long query_sufsum(int l,int r,int p,int tl,int tr)
{
	if(l <= tl && tr <= r)
		return seg[p].sufsum;
	int mid = tl + tr >> 1;
	if(l <= mid && r > mid)
		return (query_sufsum(l,r,ls,tl,mid) * query_prod(l,r,rs,mid + 1,tr) % mod + query_sufsum(l,r,rs,mid + 1,tr)) % mod;
	if(l <= mid)
		return query_sufsum(l,r,ls,tl,mid);
	else
		return query_sufsum(l,r,rs,mid + 1,tr);
}
long long query_presum(int l,int r,int p,int tl,int tr)
{
	if(l <= tl && tr <= r)
		return seg[p].presum;
	int mid = tl + tr >> 1;
	if(l <= mid && r > mid)
		return (query_presum(l,r,rs,mid + 1,tr) * query_prod(l,r,ls,tl,mid) % mod + query_presum(l,r,ls,tl,mid)) % mod;
	if(l <= mid)
		return query_presum(l,r,ls,tl,mid);
	if(r > mid)
		return query_presum(l,r,rs,mid + 1,tr);
}
pair<int,int> getlca(int x,int y)
{
	while(top[x] ^ top[y])
		dep[top[x]] > dep[top[y]] ? x = fa[top[x]] : y = fa[top[y]];
	return dep[x] < dep[y] ? make_pair(x,0) : make_pair(y,1);
}
long long query(int x,int y)
{
	pair<int,int> t = getlca(x,y);
	int lca = t.first,w = t.second;
	vector< pair<int,int> > range;
	while(top[x] ^ top[lca])
		range.push_back(make_pair(id[top[x]],id[x])),x = fa[top[x]];
	if(w)
		range.push_back(make_pair(id[lca],id[x]));
	long long temp = 0,prod = 1;
	for(register int i = range.size() - 1;~i;--i)
		temp = (temp + query_presum(range[i].first,range[i].second,1,1,n) * prod % mod) % mod,prod = prod * query_prod(range[i].first,range[i].second,1,1,n) % mod;
	range.clear();
	while(top[y] ^ top[lca])
		range.push_back(make_pair(id[top[y]],id[y])),y = fa[top[y]];
	if(!w)
		range.push_back(make_pair(id[lca],id[y]));
	long long ret = 0;
	prod = 1;
	for(register int i = 0;i < range.size();++i)
		ret = (ret + query_sufsum(range[i].first,range[i].second,1,1,n) * prod % mod) % mod,prod = prod * query_prod(range[i].first,range[i].second,1,1,n) % mod;
	return (ret + temp * prod % mod) % mod;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(register int i = 1;i <= n;++i)
		scanf("%lld",a + i);
	int u,v;
	for(register int i = 1;i < n;++i)
		scanf("%d%d",&u,&v),add(u,v),add(v,u);
	dep[1] = 1,dfs1(1),top[1] = 1,dfs2(1);
	build(1,1,n);
	char op;
	int x,y;
	while(m--)
	{
		scanf(" %c%d%d",&op,&x,&y);
		if(op == 'Q')
			printf("%lld\n",(query(x,y) + mod) % mod);
		else
			modify(id[x],y,1,1,n);
	}
}
```

---

## 作者：SSerxhs (赞：4)

一道很传统的树上操作题。

这题由于区间之间的合并有不少细节，所以比赛的时候放弃了树剖写了LCT。本题要求后缀积之和，可以考虑在LCT上维护一个区间连乘、一个前缀积之和、一个后缀积之和，就可以很方便地在makeroot时实现交换孩子了。对于每个询问按照套路直接makeroot(x)并access(y)提取链，而对于修改则更容易，直接makeroot(x)并access(x)就不会对其他元素产生任何影响。初始时把树边都当成虚边可以少写一个link函数。

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N=1e5+2,p=20924,M=2e5+2;
int lj[M],nxt[M],fir[N],f[N],c[N][2],s1[N],s2[N],s3[N];
int a[N],lz[N],st[N];
int n,m,i,j,x,y,cc,bs,tp;
inline void read(int &x)
{
    cc=getchar();
    while ((cc<48)||(cc>57)) cc=getchar();
    x=cc^48;cc=getchar();
    while ((cc>=48)&&(cc<=57))
    {
        x=x*10+(cc^48);
        cc=getchar();
    }
}
inline void add()
{
    lj[++bs]=y;
    nxt[bs]=fir[x];
    fir[x]=bs;
    lj[++bs]=x;
    nxt[bs]=fir[y];
    fir[y]=bs;
}
inline bool nroot(int x)
{
    return ((c[f[x]][0]==x)||(c[f[x]][1]==x));
}
inline void pushup(int x)
{
    s1[x]=s1[c[x][0]]*s1[c[x][1]]%p*a[x]%p;
    s2[x]=(s2[c[x][0]]+a[x]*s1[c[x][0]]+a[x]*s1[c[x][0]]%p*s2[c[x][1]])%p;
    s3[x]=(s3[c[x][1]]+a[x]*s1[c[x][1]]+a[x]*s1[c[x][1]]%p*s3[c[x][0]])%p;
}
inline void pushdown(int x)
{
    if (lz[x])
    {
        swap(c[c[x][0]][0],c[c[x][0]][1]);
        swap(c[c[x][1]][0],c[c[x][1]][1]);
        swap(s2[c[x][0]],s3[c[x][0]]);
        swap(s2[c[x][1]],s3[c[x][1]]);
        lz[c[x][0]]^=1;lz[c[x][1]]^=1;
        lz[x]=0;
    }
}
inline void zigzag(int x)
{
    int y=f[x],z=f[y],typ=(c[y][1]==x);
    if (nroot(y)) c[z][c[z][1]==y]=x;
    f[f[y]=x]=z;
    if (c[x][typ^1]) f[c[x][typ^1]]=y;
    c[y][typ]=c[x][typ^1];
    c[x][typ^1]=y;
    pushup(y);
}
inline void splay(int x)
{
    int y=st[tp=1]=x;
    while (nroot(y)) st[++tp]=y=f[y];
    while (tp) pushdown(st[tp--]);
    while (nroot(x))
    {
        if (nroot(y=f[x]))
        {
            if (c[f[y]][0]==y^c[y][0]==x) zigzag(x); else zigzag(y);
        }
        zigzag(x);
    }
    pushup(x);
}
inline void access(int x)
{
    for (int y=0;x;x=f[y=x])
    {
        splay(x);
        c[x][1]=y;
        pushup(x);
    }
}
inline void makeroot(int x)
{
    access(x);splay(x);
    swap(c[x][0],c[x][1]);
    swap(s2[x],s3[x]);
    lz[x]^=1;pushup(x);
}
inline void split(int x,int y)
{
    makeroot(x);access(y);splay(y);
}
void dfs(int x)
{
    s1[x]=s2[x]=s3[x]=a[x];
    int i;
    for (i=fir[x];i;i=nxt[i]) if (lj[i]!=f[x])
    {
        f[lj[i]]=x;
        dfs(lj[i]);
    }
}
int main()
{
    s1[0]=1;
    read(n);read(m);
    for (i=1;i<=n;i++) read(a[i]);
    i=n;
    while (--i)
    {
        read(x);read(y);
        add();
    }
    dfs(1);
    while (m--)
    {
        cc=getchar();
        while ((cc!='C')&&(cc!='Q')) cc=getchar();
        if (cc=='C')
        {
            read(x);read(y);
            split(x,x);
            a[x]=(a[x]+y)%p;
            s1[x]=s2[x]=s3[x]=a[x];
        }
        else
        {
            read(x);read(y);
            split(x,y);pushdown(y);
            printf("%d\n",s3[y]);
        }
    }
}
```

---

## 作者：water_tomato (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P5220)   [个人博客版本](https://code.watertomato.com/p5220-%e7%89%b9%e5%b7%a5%e7%9a%84%e4%bf%a1%e6%81%af%e6%b5%81-%e9%a2%98%e8%a7%a3/)

> @GuidingStar 让我来做这道题目然后我就做了一下，结果因为一个愚蠢的错误调了一个小时代码……

## 题意

给定一棵树，维护区间后缀积之和，支持单点修改。

## 解析

个人觉得没那么难想（~~嗯，搞死我的是细节~~）。

我们先考虑线段树上如何维护这个东西。我们可以在维护区间后缀积之和的同时维护一下区间积，然后合并的时候只需要将左区间后缀积之和乘上右区间积，再加上右区间后缀积之和就好了。

然后我们考虑怎么将这个东西搬到树上。考虑树链剖分（~~LCT我不会啊~~）。

我们如果要查询点 $x,y$ 之间那段路径，就是将两边分别往上跳，然后在交汇处合并一下就行了。这时候容易想到，$x$ 往上跳时，跳的方向和 dfs 序的方向是相反的，也就是说此时的答案并非是后缀积之和而是前缀积之和，线段树再维护一下这玩意儿就好了。

单点修改非常容易，不多赘述。这些信息的查询也可以全部丢到一个函数里一起查询。

详见代码，都注释了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls u<<1
#define rs u<<1|1
using namespace std;
const int mod = 20924;
const int N = 4e5 + 5;
struct Segment_Tree {
	int prod, ans, fans;
} tree[N << 3];
struct edge {
	int to, nxt;
} e[N << 1];
int cnt, head[N], n, m;
int a[N], w[N];
char ch[20];
inline void add(int u, int v) {
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
int dep[N], son[N], siz[N], fa[N];
inline void dfs1(int u, int f) {
	dep[u] = dep[f] + 1;
	fa[u] = f; siz[u] = 1;
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (v == f) continue;
		dfs1(v, u);
		siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v;
	}
}
int top[N], id[N], tot;
inline void dfs2(int u, int Top) {
	id[u] = ++tot;
	a[tot] = w[u];
	top[u] = Top;
	if (!son[u]) return;
	dfs2(son[u], Top);
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (v == fa[u] || v == son[u]) continue;
		dfs2(v, v);
	}
}
inline void pushup(int u) {
	tree[u].prod = tree[ls].prod * tree[rs].prod % mod;//合并
	tree[u].ans = (tree[rs].ans + tree[ls].ans * tree[rs].prod % mod) % mod;
	tree[u].fans = (tree[ls].fans + tree[rs].fans * tree[ls].prod % mod) % mod;
}
inline void build(int u, int l, int r) {
	if (l == r) {
		tree[u].ans = tree[u].prod = tree[u].fans = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid); build(rs, mid + 1, r);
	pushup(u);
}
inline void update(int u, int l, int r, int x, int k) {//单点修改
	if (l == r) {
		tree[u].prod = (tree[u].prod + k) % mod;
		tree[u].ans = (tree[u].ans + k) % mod;
		tree[u].fans = (tree[u].fans + k) % mod;
		return;
	}
	int mid = (l + r) >> 1;
	if (mid >= x) update(ls, l, mid, x, k);
	else update(rs, mid + 1, r, x, k);
	pushup(u);
}
int prod, ans, fans;
inline void query(int u, int l, int r, int L, int R) {//三个东西一起查询
	if (l >= L && r <= R) {
		prod = tree[u].prod;//区间积
		ans = tree[u].ans;//区间后缀积之和
		fans = tree[u].fans;//区间前缀积之和
		return;
	}
	int mid = (l + r) >> 1;
	int tp = 0, ta = 0, tf = 0;
	if (mid >= L && mid < R) {//两边都有，需要合并
		query(rs, mid + 1, r, L, R);
		tp = prod, ta = ans, tf = fans;//记录右边的返回值
		query(ls, l, mid, L, R);
		ta = (ta + ans * tp) % mod;//合并
		tf = (fans + tf * prod) % mod;
		tp = prod * tp % mod;
		prod = tp; ans = ta; fans = tf;
	}
	else if (mid < R) {
		query(rs, mid + 1, r, L, R);
	}
	else if (mid >= L) {
		query(ls, l, mid, L, R);
	}
	return;
}
inline void queryTree(int x, int y) {
	int sa = 0, ta = 0, tp = 1;
	while (top[x] != top[y]) {
		if (dep[top[x]] >= dep[top[y]]) {
			query(1, 1, n, id[top[x]], id[x]);
			sa = (fans + sa * prod) % mod;//x 向上跳方向时和 dfs 序是反的，用 fans，合并同样注意方向
			x = fa[top[x]];
		}
		else {
			query(1, 1, n, id[top[y]], id[y]);//y 向上跳方向时没问题，直接用 ans
			ta = (ta + ans * tp) % mod;
			tp = tp * prod % mod;
			y = fa[top[y]];
		}
	}
	if (dep[x] < dep[y]) {//判断最后一段的方向
		query(1, 1, n, id[x], id[y]);
		ta = (ans * tp + ta) % mod;//先和中间这段合并
		tp = tp * prod % mod;
		sa = (sa * tp + ta) % mod;//再把两段合并起来
	}
	else {
		query(1, 1, n, id[y], id[x]);
		ta = (fans * tp + ta) % mod;
		tp = tp * prod % mod;
		sa = (sa * tp + ta) % mod;
	}
	printf("%lld\n", sa);
}
signed main() {
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%lld", &w[i]);
	for (int i = 1, u, v; i < n; i++) {
		scanf("%lld%lld", &u, &v);
		add(u, v); add(v, u);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	build(1, 1, n);
	for (int i = 1, a, b; i <= m; i++) {
		scanf("%s", ch);
		scanf("%lld%lld", &a, &b);
		if (ch[0] == 'Q') queryTree(a, b);
		else update(1, 1, n, id[a], b);
	}
	return 0;
}
```

至于我调了好久的原因：查询函数写得太垃圾了导致个别情况下 $prod,ans,fans$ 没有正确返回，然后把这玩意儿搞工整一点靠谱一点就过了（~~自闭~~）。

---

## 作者：cirnovsky (赞：0)

# Description

$\text{TYM}$ 所在的国家有 $n$ 个城市，编号为 $1,\dots,n$，由 $n - 1$ 条双向道路连接。保证任意两个城市间都有唯一的简单路径。  
以及，每个城市都有一个信息流的流量 $a_i$。

$\text{TYM}$ 一共要执行 $m_0$ 个任务，每个任务给定两个城市 $s,t$，其执行过程如下：  
第一个时刻，他从城市 $s$ 出发，以每个时刻移动到下一个城市的速度，走 $s,t$ 之间的简单路径到 $t$。  
每到达一个城市，他都会把这个城市的信息流 $a_i$ 发送到经过的每个城市。  
我们约定，他到达一个城市的同一时刻也会把这个城市的信息流发送给这个城市。我们定义一个城市的价值为这个城市所接受到的信息流的乘积。

请你求出每个任务中，$s$ 到 $t$ 的简单路径上经过的城市的价值的总和对 $20924$ 取模的结果。

此外，不幸地，由于侵略者同时也在行动，所以在他执行多个任务之间，可能会有某个 $a_i$ 发生改变。

他的任务总数与改变某个 $a_i$ 的次数之和为 $m$。

-------

# Solution

这道题的题意是真的绕，我前前后后读了不下五遍才大概意会。。。

做数据结构的题一般都要先浓缩题意。这道题是让我们求后缀积之和，再加上修改操作就基本上确定用LCT了

需要维护的信息有前缀积之和,后缀积之和，区间乘法三个信息。

对于修改操作，直接上LCT的套路makeroot和access。

对于询问操作，我们直接按照LCT的套路用makeroot和access把链给搞出来。

其实这就相当于一道LCT的板题吧。。。全部都是基础操作。。。

完整代码在这里[Link](https://paste.ubuntu.com/p/tsQ43Pvvg6/)

如果链接失效了就这个[Link](https://www.luogu.com.cn/paste/gtishzfw)

###### [悄悄的打个广告(blog)](http://boringhacker.github.io/)

```cpp
const int SIZE = 1e5 + 5;
const int M_SIZE = 2e5 + 5;
const int MOD = 20924;
int head[M_SIZE], nxt[M_SIZE];
int to[M_SIZE], ints[SIZE];
int waste[SIZE], n, m, top, tot;
struct SPLAY {
	int fa;
	int ch[2];
	int prod;
	int preprod;
	int sufprod;
	int lztg;
} data[SIZE];

void AddEdge(int x, int y) {
	to[++tot] = y;
	nxt[tot] = head[x];
	head[x] = tot;
}

bool IsRoot(int x) {
	return ((data[data[x].fa].ch[1] ^ x) && (data[data[x].fa].ch[0] ^ x));
}

bool WhichSon(int x) {
	return (data[data[x].fa].ch[1] == x);
}

void UpdateMessages(int x) {
	data[x].prod = data[data[x].ch[0]].prod * data[data[x].ch[1]].prod % MOD * ints[x] % MOD;
	data[x].preprod = (data[data[x].ch[0]].preprod + data[data[x].ch[0]].prod * ints[x] + data[data[x].ch[0]].prod * ints[x] % MOD * data[data[x].ch[1]].preprod) % MOD;
	data[x].sufprod = (data[data[x].ch[1]].sufprod + data[data[x].ch[1]].prod * ints[x] + data[data[x].ch[1]].prod * ints[x] % MOD * data[data[x].ch[0]].sufprod) % MOD;
}

void UpdateSons(int x) {
	if (data[x].lztg) {
		swap(data[data[x].ch[0]].ch[0], data[data[x].ch[0]].ch[1]);
		swap(data[data[x].ch[1]].ch[0], data[data[x].ch[1]].ch[1]);
		swap(data[data[x].ch[0]].preprod, data[data[x].ch[0]].sufprod);
		swap(data[data[x].ch[1]].preprod, data[data[x].ch[1]].sufprod);
		data[data[x].ch[0]].lztg ^= 1;
		data[data[x].ch[1]].lztg ^= 1;
		data[x].lztg = 0;
	}
}

void RotateNode(int x) {
	int y = data[x].fa;
	int z = data[y].fa;
	int k = WhichSon(x);
	if (!IsRoot(y)) data[z].ch[WhichSon(y)] = x;
	data[y].fa = x;
	data[data[y].fa].fa = z;
	if (data[x].ch[k ^ 1]) data[data[x].ch[k ^ 1]].fa = y;
	data[y].ch[k] = data[x].ch[k ^ 1];
	data[x].ch[k ^ 1] = y;
	UpdateMessages(y);
}

void SplayToRoot(int x) {
	int y = waste[top = 1] = x;
	while (!IsRoot(y)) waste[++top] = y = data[y].fa;
	while (top) UpdateSons(waste[top--]);
	for (; !IsRoot(x); RotateNode(x))
		if (!IsRoot((y = data[x].fa)))
			RotateNode((data[data[y].fa].ch[1] ^ y ^ data[y].ch[1] ^ x) ? x : y);
	UpdateMessages(x);
}

void AccessEdge(int x) {
	for (int y = 0; x; x = data[y = x].fa) {
		SplayToRoot(x);
		data[x].ch[1] = y;
		UpdateMessages(x);
	}
}

void MakeRoot(int x) {
	AccessEdge(x);
	SplayToRoot(x);
	swap(data[x].ch[0], data[x].ch[1]);
	swap(data[x].preprod, data[x].sufprod);
	data[x].lztg ^= 1;
	UpdateMessages(x);
}

void SplitTree(int x, int y) {
	MakeRoot(x);
	AccessEdge(y);
	SplayToRoot(y);
}

void Prepare(int x) {
	data[x].prod = ints[x];
	data[x].preprod = ints[x];
	data[x].sufprod = ints[x];
	for (int i = head[x]; i; i = nxt[i])
		if (to[i] ^ data[x].fa)
			data[to[i]].fa = x, Prepare(to[i]);
}

int GetAnswers(int x, int y) {
	SplitTree(x, y);
	UpdateSons(y);
	return data[y].sufprod;
}

void Behavior(int x, int y) {
	SplitTree(x, x);
	ints[x] += y;
	ints[x] %= MOD;
	data[x].prod = ints[x];
	data[x].preprod = ints[x];
	data[x].sufprod = ints[x];
}

signed main() {
	read(n, m);
	for (int i = 1; i <= n; ++i) read(ints[i]);
	for (int i = 1, x, y; i < n; ++i) read(x, y), AddEdge(x, y), AddEdge(y, x);
	(*data).prod = 1;
	Prepare(1);
	for (int i = 0, x, y; i < m; ++i) {
		char opt[5];
		read(opt);
		read(x, y);
		if (*opt ^ 'C') write(io_l, GetAnswers(x, y));
		else Behavior(x, y);
	}
	return 0;
}
```

---


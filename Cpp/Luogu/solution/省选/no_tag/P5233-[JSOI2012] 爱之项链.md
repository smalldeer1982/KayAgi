# [JSOI2012] 爱之项链

## 题目描述

在进香河，流传着这样一段美丽的故事。zyg 与 kzn 是两个生活在进香河的孩子，一天，他们两人闹矛盾了，于是 zyg 送给了 kzn 一条精美的爱之项链。从此他们幸福生活在一起。

这则故事的真实性到今天已经没有意义了，然而我们关注的是那一条精美的爱之项链。这是一条由 $N$ 个精致的戒指与一块特殊纪念品相连而成的环形，如下图中的爱心符号正是一种特殊纪念品（据说是 2012 年情人节时 zyg 特意托人订制的）。上面的每一枚戒指又是由 $M$ 个带磁性的特殊彩色球状物组成的环形。也许你会认为，这所谓的戒指，更像是一条条小项链。

下图给出了一种可行的方案，其中左边描述的是单一的一枚戒指，右图描述的是项链。

![](https://cdn.luogu.com.cn/upload/pic/52648.png) 

这里，所有带磁性的特殊彩色球状物的颜色只有 $R$ 种，这里我们用 $1$ 到 $R$ 来表示。如果一枚戒指可以通过顺时针或逆时针的旋转后与另外一枚戒指相同，则认为这是两枚相同的戒指。 

对于一条爱之项链，要求满足任何相邻两枚戒指必须是不相同的。同时，特殊纪念品左右两枚戒指也必须是不同的。 

现在给定 $N$，$M$ 和 $R$，问究竟有多少种不同的爱之项链。 

注意： 

1. 特殊纪念品的插入位置不同，也许会得到不同的爱之项链。
 2. 这里我们只考虑旋转后是否相同，不考虑翻转操作，这一点不论是对于每一枚戒指，还是对于整条项链，都是这样的。

## 说明/提示

对于 $30\%$ 的数据，$N \leq 10^3$，$M \leq 3 \times 10^2$，$R \leq 10^2$。

对于 $60\%$ 的数据，$N \leq 3 \times 10^4$，$M \leq 2 \times 10^3$，$R \leq 10^5$。

对于 $80\%$ 的数据，$N \leq 10^7$，$M \leq 10^6$，$R \leq 10^6$。

对于 $100\%$ 的数据，$N \leq 10^{15}$，$M \leq 10^9$，$R \leq 10^6$。

## 样例 #1

### 输入

```
10 5 4```

### 输出

```
1398595```

# 题解

## 作者：rui_er (赞：5)

理解本题解需要的前置知识：Pólya 定理、容斥原理。

可以发现本题分为两部分：

1. 求本质不同戒指数量。
2. 求本质不同项链数量。

先来看第一部分，求本质不同戒指数量：

戒指可以看做长度为 $m$ 的环，用 $r$ 种颜色进行染色，只存在旋转同构。这个东西其实就是 [P4980 【模板】Pólya 定理](https://www.luogu.com.cn/problem/P4980)，下面我们来推一下式子。

置换群 $G$ 为顺时针旋转 $0\sim m-1$ 个位置这些置换，答案即为在 $G$ 作用下等价类的数量。同时，定义集合 $M$ 为 $1\sim m$ 所有可能排列，就是初始的排列情况。

我们设 $c(g)$ 为置换 $g\in G$ 拆成的循环置换个数，那么旋转 $k$ 个位置的置换 $g$ 的循环置换个数为多少呢？$|g|=\frac{\textrm{lcm}(m,k)}{k}=\frac{m}{\gcd(m,k)}$，因此 $c(g)=\gcd(m,k)$。

根据 Pólya 定理，套路推式子得：

$$
\begin{aligned}
ans&=\frac{1}{|G|}\sum\limits_{g\in G}r^{c(g)}\\
&=\frac{1}{m}\sum\limits_{i=1}^mr^{\gcd(m,k)}\\
&=\frac{1}{m}\sum\limits_{i=1}^m\sum\limits_{d}r^d[\gcd(m,i)==d]\\
&=\frac{1}{m}\sum\limits_{d=1}^mr^d\sum\limits_{i=1}^{\frac{m}{d}}[\gcd(\frac{m}{d},i)==1]\\
&=\frac{1}{m}\sum\limits_{d\mid m}r^d\varphi(\frac{m}{d})
\end{aligned}
$$

于是第一部分就做完了，假设上面这个答案为 $k$，再看第二部分，求本质不同项链数量：

如果不考虑特殊纪念品两侧不能相同，只考虑把戒指串成一条链时相邻不能相同，此时不难得到数量为 $k\cdot(k-1)^{n-1}$。但是特殊纪念品两侧还不能相同，怎么办呢？使用容斥，规定特殊纪念品两侧相同的方案数为 $n\gets n-1$ 的情况。

递归下去计算时间显然爆炸，我们可以手玩一下递归的过程，利用容斥的性质加减相消，不难找到规律，答案为 $(k-1)^n+(k-1)(-1)^n$，当然也可以使用特征方程等方式进行推导。

结合一下上面两部分，我们就可以得到最终的答案了。

放一份代码（仅供参考）：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(ll x=y;x<=z;x++)
#define per(x,y,z) for(ll x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const ll mod = 3214567;

ll n, m, r;
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
ll qpow(ll x, ll y) {
	ll ans = 1;
	for(;y;y>>=1,x=x*x%mod) if(y & 1) ans = ans * x % mod;
	return ans;
}
ll inv(ll x) {return qpow(x, mod-2);}
ll phi(ll x) {
	ll ans = x;
	for(ll i=2;i*i<=x;i++) {
		if(!(x % i)) {
			ans = ans / i * (i - 1);
			while(!(x % i)) x /= i;
		}
	}
	if(x > 1) ans = ans / x * (x - 1);
	return ans;
}

int main() {
	scanf("%lld%lld%lld", &n, &m, &r);
	ll k = 0, lim = sqrt(m);
	rep(d, 1, lim) {
		if(!(m % d)) {
			k = (k + qpow(r, d) * phi(m/d) % mod) % mod;
			if(d != m / d) k = (k + qpow(r, m/d) * phi(d) % mod) % mod;
		}
	}
	k = k * inv(m) % mod;
	ll ans = (qpow(k-1, n) + ((n & 1) ? -1 : 1) * (k - 1) + mod) % mod;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：tzc_wk (赞：4)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P5233)

首先很明显题目暗示我们先求出符合条件的戒指数量，再计算出由这些戒指能够构成的项链的个数，因此考虑分别计算它们。首先是计算符合条件的戒指数量，题目中“可以通过旋转重合的戒指视作相同”可以让我们联想到 Polya 定理，具体来说根据 Polya 那套理论，符合条件的戒指个数就是 $C=\dfrac{1}{m}\sum\limits_{d\mid n}R^d\varphi(\dfrac{n}{d})$，$\mathcal O(\sqrt{n})$ 地枚举因子并计算 $\varphi$ 即可。注意这里 $m$ 有可能是 $3214567$ 的倍数，对于这种情况，我们考虑将模数变成 $3214567^2$，这样计算完之后除以 $m$ 这一步可以先令乘上 $\dfrac{m}{3214567}$ 在模 $3214567^2$ 意义下的逆元，然后答案除以 $3214567$（虽然似乎数据没有这样的情况？）

接下来考虑此题的第二部分，如何通过符合条件的戒指数量 $C$ 计算项链个数，一个很 naive 的想法是 $C·(C-1)^{n-1}$，不过由于“纪念品两侧戒指不同”这一条件的存在，这个想法是错误的。正确的方法是，设 $f_i$ 表示长度为 $i$ 的满足条件的项链个数，我们考虑从纪念品一侧的戒指开始，给 $i$ 枚戒指分别标号 $1,2,3,\cdots,i$，那么我们考虑分 $1$ 和 $i-1$ 戒指相同 与 $1$ 和 $i-1$ 戒指不同这两类进行处理，对于 $1,i-1$ 戒指不同的情况，如果我们把戒指 $i$ 拿掉，其余戒指组成了长度为 $i-1$ 的符合条件的项链，而由于 $1,i-1$ 戒指不同，第 $i$ 个戒指的方案数就是 $C-2$，总方案数 $f_{i-1}·(C-2)$，对于 $1,i-1$ 戒指相同的情况，由于 $i-2,i-1$ 相邻，$i-2,i-1$ 戒指必定不同，故 $1,i-2$ 对应的戒指也不同，因此如果我们把 $i-1,i$ 戒指拿掉，那剩余 $i-2$ 个戒指还是可以组成长度为 $i-2$ 的符合条件的项链，这部分的贡献也就是 $f_{i-2}·(C-1)$。因此我们可以得到递推式 $f_i=f_{i-1}·(C-2)+f_{i-2}·(C-1)$，边界条件 $f_1=0,f_2=C(C-1)$，直接暴力推是 $\mathcal O(n)$ 的，无法通过，不过很明显对于这样 $f_i=af_{i-1}+bf_{i-2}$ 的递推式，我们可以通过特征根方程优化，具体来说我们求出 $x^2=ax+b$ 的两根 $\alpha,\beta$，那么 $f_i$ 统统可以表示为 $A\alpha^i+B\beta^i$ 的形式。此题也不例外，代入 $a=C-2,b=C-1$ 可得特征根方程两根 $\alpha=-1,\beta=C-1$，再代入 $f_1=0,f_2=C(C-1)$ 可得 $A=(C-1),B=1$，因此 $f_i=(C-1)(-1)^n+(C-1)^n$。

u1s1 感觉此题和[这题](https://www.luogu.com.cn/problem/P3307)出奇地相似，题解写得也出奇地相似（

```cpp
ll n,MMOD=MOD;int m,r;
ll getmul(ll x,ll y){return (__int128_t)(1)*x*y%MMOD;}
int qpow(int x,ll e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
ll _qpow(int x,int e){
	ll ret=1;
	for(;e;e>>=1,x=getmul(x,x)) if(e&1) ret=getmul(ret,x);
	return ret;
}
void exgcd(ll x,ll y,ll &a,ll &b){
	if(!y) return a=1,b=0,void();exgcd(y,x%y,a,b);
	ll tmp=a;a=b;b=tmp-(x/y)*b;
}
ll getinv(ll a,ll mod){
	ll x,y;exgcd(a,mod,x,y);
	return (x+mod)%mod;
}
int getphi(int x){
	int res=x,tmp=x;
	for(int i=2;i*i<=x;i++) if(tmp%i==0){
		res=res/i*(i-1);
		while(tmp%i==0) tmp/=i;
	} if(tmp>1) res=res/tmp*(tmp-1);
	return res;
}
int main(){
	scanf("%lld%d%d",&n,&m,&r);ll ret=0;
	bool flg=0;if(m%MOD==0) flg=1,MMOD=1ll*MOD*MOD;
	for(int i=1;i*i<=m;i++) if(m%i==0){
		ret=(ret+getmul(_qpow(r,i),getphi(m/i)))%MMOD;
		if(m/i!=i) ret=(ret+getmul(_qpow(r,m/i),getphi(i)))%MMOD;
	} ret=1ll*ret*getinv((flg)?(m/MOD):m,MMOD)%MMOD;
	if(flg) ret/=MOD,ret%=MOD;
	printf("%d\n",(1ll*(ret-1)*qpow((MOD-1),n)%MOD+qpow(ret-1,n))%MOD);
	return 0;
}
```



---

## 作者：ccsc (赞：1)

对于本题，题意就不讲解了吧；

我们看题：
求解的是方案总数

那么我们想：我们是不是可以首先求出一共有多少种不同的戒指，又由于有那个特殊的东西，相当于这串项链即使旋转后相同，但特殊的东西插入的位置也肯定是不同的，因此即不考虑旋转，只考虑相邻位置不同的爱之项链的方案数。

然后这个问题经过大家努力求解之后，，

就解决了很多，接下来上重点（敲黑板！）

>接下来就是运用容斥原理。对于第i个戒指和第i+1个戒指相同，可以看成第i个限制，然后第n个限制即第n个戒指和第1个限制不同，那么即要求满足所有限制的方案数。令Si为满足第i个限制的方案数的集合，那么即求S1~Sn的交，也就是其补集的并，那么就是总方案数减去所有不满足任意一个限制数加上所有不满足任意二个限制数......

然后一大堆子莫名其妙的东东，，

就可以了……

但是后来要注意一点：
			
            首先总方案数显然就是ans^n，
            然后不满足任意一个限制数即有两个相邻的相同，
            可以看成一条边连接的两个点相同，就是C(n,1)*ans^(n-1)，
            以此类推，然后可以得到：sigma(0<=i<=n,(-1)^i*C(n,i)*ans^(n-i))，
            然后发现这就是二项式定理，就可以得到(ans-1)^n，
            但真的就是这样吗？当i=n时，就会有一个Bug，
            用公式算得的答案是(-1)^n，
            然而n个限制均不满足时的情况即所有颜色都一样，
            有ans种，因此还要加上(n&1?1-m:m-1)才行。
            
      
嗯，这里就直接把我看的题解code放上去啦，
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define p 3214567
#define maxn 200020
 
int m,r,tot;
int prime[maxn],phi[maxn];
bool isprime[maxn];
long long n;
 
int power(int a,long long k){
    if (k==0) return 1;
    if (k==1) return a%p;
    int x=power(a,k/2),ans=1ll*x*x%p;
    if (k&1) ans=1ll*a*ans%p;
    return ans;
}
 
int fphi(int x){
    int ans=x;
    for (int i=2;i*i<=x;i++)
        if (x%i==0){
            ans=ans-ans/i;
            while (x%i==0) x/=i;
        }
    if (x!=1) ans=ans-ans/x;
    return ans;
}
 
int main(){
    scanf("%lld%d%d",&n,&m,&r);tot=0,memset(isprime,1,sizeof(isprime)),phi[1]=1;
    for (int i=2;i<maxn;i++){
        if (isprime[i]) prime[++tot]=i,phi[i]=i-1;
        for (int j=1;j<=tot && i*prime[j]<maxn;j++){
            isprime[i*prime[j]]=0;
            if (i%prime[j]==0){
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
    int ans=0;
    for (int i=1;i*i<=m;i++)
        if (m%i==0){
            ans=(ans+1ll*power(r,i)*fphi(m/i)%p)%p;
            if (i*i!=m) ans=(ans+1ll*power(r,m/i)*phi[i]%p)%p;
        }
    ans=1LL*ans*power(m,p-2)%p;
    int t=(1ll*power(ans-1,n)+(n&1?1-ans:ans-1))%p;
    printf("%d\n",(t+p)%p);
    return 0;
}
```
[题解来源](https://www.cnblogs.com/DUXT/p/5951747.html)

---

## 作者：Purslane (赞：0)

# Solution

本题又是二合一题。注意到项链有一个特殊装饰品——一个 $\large \heartsuit$，所以项链是不可能旋转的。

首先求出所有的戒指的数量。这就是 [Polya](https://www.luogu.com.cn/problem/P4980) 计数的板子，设答案为 $c$。

只需要求出：用 $c$ 种染色染一个长度为 $n$ 的环，要求任意相邻两种颜色互不相同，**不能旋转**，有多少种情况。

设答案为 $S_n$。首先钦定最上面那个点为起点，然后不断顺时针染，不能出现相同的颜色，方案数为 $c \times (c-1)^{n-1}$。不过这包含了 $S_n+S_{n-1}$，分别表示第一个和最后一个的颜色相同 / 不相同。

递推数列 $S_n = c \times (c-1)^{n-1} - S_{n-1}$。得到 $(-1)^n S_n = - c \times (1-c)^{n-1}+(-1)^{n-1} S_{n-1}$。初始项为 $S_2 = c(c-1)$，有

$$(-1)^n S_n = -c [(1-c)+(1-c)^2+\dots+(1-c)^{n-1}]= -c \times \dfrac{(1-c)^n-(1-c)}{-c} = (1-c)^n-(1-c)$$

带回去得到 $S_n=(c-1)^n + (-1)^n (c-1)$。

~~第二部分是一个高考问题，完全不需要特征根解决。~~

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
__int128 _1=1;
int n,m,r;
int qpow(int base,int p,int mod) {
	int ans=1;
	while(p) {
		if(p&1) ans=_1*ans*base%mod;
		base=_1*base*base%mod,p>>=1;
	}
	return ans;
}
int phi(int x) {
	int ans=x,tmp=x;
	ffor(i,2,tmp/i) if(tmp%i==0) {
		ans=ans/i*(i-1);
		while(tmp%i==0) tmp/=i;
	}
	if(tmp>1) ans=ans/tmp*(tmp-1);
	return ans;
}
int c,ans=0,mmod=3214567;
int solve(int len) {
	int cnt=phi(m/len);
	return _1*cnt*qpow(r,len,mmod*mmod)%(mmod*mmod);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>r;
	ffor(i,1,m/i) if(m%i==0) {
		ans=(ans+solve(i))%(mmod*mmod);
		if(m/i!=i) ans=(ans+solve(m/i))%(mmod*mmod);
	}
	if(m%mmod==0) ans/=mmod,m/=mmod;	
	else ans%=mmod;
	ans=ans*qpow(m,mmod-2,mmod)%mmod;
	int fin=qpow(ans-1,n,mmod);
	if(n%2==0) fin+=ans-1;
	else fin-=(ans-1);
	cout<<(fin%mmod+mmod)%mmod;
	return 0;
}
```


---

## 作者：littlez_meow (赞：0)

是久违的群论题呢！

## step 1：戒指计数

问题可以分为戒指的种类和把戒指拼成项链两部分，先来解决第一部分。

翻译一下这部分的题意：给定一个有 $M$ 个点的环，每个点可以染色成 $R$ 种不同颜色，求本质不同染色方案数，其中本质不同定义为不能通过旋转与别的染色方案相同。

不就是[这道题](https://www.luogu.com.cn/problem/P4980)吗？下面给出一种不用莫反的推法。

由 Burnside 引理，我们有戒指个数 $|X/G|=\dfrac 1{|G|}\sum\limits_{g\in G}|X^g|$。

其中 $G$ 为旋转 $1\sim M$ 位的置换，$|X^g|$ 为置换 $g$ 下的不动点数量。

对于旋转 $t$ 位的置换，其不动点一定有长为 $k$ 的循环节，其中 $k|t$。又因为 $k$ 为循环节，肯定满足 $k|M$，因此 $k|\gcd(M,t)$。为了保证计数不重不漏，不如就令 $k=\gcd(M,t)$。这 $k$ 个位置随意染色共 $R^k$ 种。故最终答案为：

$$\dfrac 1 M \sum\limits_{t=0}^{M-1}R^{\gcd(t,M)}$$

枚举 $\gcd$ 得：

$$\dfrac 1 M \sum\limits_{d|M}\sum\limits_{t=1}^M R^d[\gcd(t,M)=d]$$

提出 $R^d$，$\gcd$ 化为 $1$，得：

$$\dfrac 1 M \sum\limits_{d|M}R^d\sum\limits_{t=1}^{\frac M d}[\gcd(t,\dfrac M d)=1]$$

右边 $\sum\limits_{t=1}^{\frac M d}[\gcd(t,\dfrac M d)=1]$ 是 $\varphi(\dfrac M d)$ 的定义。因此答案为：

$$\dfrac 1 M \sum\limits_{d|M}R^d\varphi(\dfrac M d)$$

枚举因数强行计算欧拉函数即可，时间复杂度 $O(\sum\limits_{i=1}^{\sqrt M}\sqrt i)=O(M^{\frac 3 4})$。

下面为了方便，记上面答案为 $S$。

## step 2：项链计数

由于特殊纪念品的存在，我们只要固定特殊纪念品的位置，就不存在环相同的情况。

感觉围成环很麻烦，先考虑链。链第一个点有 $S$ 种选法，后面每个点都有 $S-1$ 种选法。根据乘法原理，一共是 $S(S-1)^{N-1}$。

然后再容斥掉不合法的情况。强行钦定两端选一样的，捆绑在一起，环的长度变成了 $N-1$。

记 $n$ 个点的环答案为 $T_n$（注意这里的 $n$ 只是下标，不是题目里的 $N$），则有：

$$T_n=S(S-1)^{n-1}-T_{n-1}$$

打个表猜测 $T_n=(S-1)^n+(-1)^n(S-1)$，下面证明（就喜欢用数学归纳法而不喜欢直接拆开推式子）。

当 $n=1$ 时显然成立，假设当 $n=x$ 时成立，下证当 $n=x+1$ 时也成立。

$$T_{x+1}=S(S-1)^x-T_x$$

代入 $T_x=(S-1)^x+(-1)^x(S-1)$，把前面的负号乘进 $-1$ 的幂里，得：

$$T_{x+1}=S(S-1)^x-(S-1)^x+(-1)^{x+1}(S-1)$$

提取 $(S-1)^x$ 的公因式，得到：

$$T_{x+1}=(S-1)^{x+1}+(-1)^{x+1}(S-1)$$

原命题得证。故答案为：

$$(S-1)^N+(-1)^N(S-1)$$

计算复杂度 $O(\log N)$，用欧拉定理可以进一步优化至 $O(1)$（或 $O(\log P)$，其中 $P=3214567$ 为模数，如果你认为其属于输入规模）。

## step 3：附上代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
using namespace std;
const int MOD=3214567;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD;
		expo>>=1;
	}
	return res;
}
inline int phi(int x){
	int res(x);
	for(int i(2);(ll)i*i<=x;++i){
		if(x%i) continue;
		res=res/i*(i-1);
		while(!(x%i)) x/=i;
	}
	if(x^1) res=res/x*(x-1);
	return res;
}
ll n;
int m,r,s;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>r;
	for(int i(1);1ll*i*i<=m;++i){
		if(m%i) continue;
		int j=m/i;
		s+=qpow(r,i)*phi(j)%MOD;
		s>=MOD&&(s-=MOD);
		i!=j&&(s+=qpow(r,j)*phi(i)%MOD,s>=MOD&&(s-=MOD));
	}
	s=s*qpow(m,MOD-2)%MOD;
	n%=(MOD-1);
	cout<<(qpow(s-1,n)+((n&1)?MOD-s+1:s-1))%MOD;
	return 0;
}
```

完结撒花 qaq~

---

## 作者：D2T1 (赞：0)

首先你会了 Polya 板子你就会求出本质不同戒指个数，这一步可以直接去看板子或者看别的题解。算出本质不同戒指数 $k=\sum\limits_{d|m}r^d\varphi(\dfrac md)$。

接下来问题转化为 $n$ 个位置填 $[1,k]$ 的数满足相邻两个数不同且首尾两个数不同的方案数。

如果没有首尾不同的条件，答案很显然是 $k(k-1)^{n-1}$。

设 $g_i$ 表示 $i$ 个位置填 $[1,k]$ 的数满足相邻两个数不同，不一定满足首尾两个数不同的方案数；$f_i$ 表示 $i$ 个位置填 $[1,k]$ 的数满足相邻两个数不同且首尾两个数不同的方案数

有 $g_i=k(k-1)^{i-1}$。

$f_i$，考虑 $g_i$ 减去首尾两个数相同的方案数。当首尾相同时， $[1,i-1]$ 的位置要求首尾不同。所以 $f_i=g_i-g_{i-1}$。

代入可得：

$$
\begin{aligned}
f_n&=k(k-1)^{n-1}-k(k-1)^{n-2}+k(k-1)^{n-3}-...\\
&=(-1)^{n-1}k[(1-k)^{n-1}+(1-k)^{n-2}+...]\\
&=(-1)^{n-1}k\dfrac{(1-k)^n-(1-k)}{(1-k)-1}\\
&=(-1)^n[(1-k)^n-(1-k)]\\
&=(k-1)^n+(-1)^n(k-1)
\end{aligned}
$$

---


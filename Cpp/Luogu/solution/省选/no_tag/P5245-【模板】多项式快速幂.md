# 【模板】多项式快速幂

## 题目背景

[加强版传送门](https://www.luogu.com.cn/problem/P5273)

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 $\bmod\ x^n$ 意义下的多项式 $B(x)$，使得 $B(x) \equiv (A(x))^k \ (\bmod\ x^n)$。

多项式的系数在 $\bmod\ 998244353$ 的意义下进行运算。

## 说明/提示

对于 $100\%$ 的数据，$1 < n \leq 10^5$，$0 < k \leq 10^{10^5}$，$a_i \in [0,998244352]$，$a_0=1$。

## 样例 #1

### 输入

```
9 18948465
1 2 3 4 5 6 7 8 9```

### 输出

```
1 37896930 597086012 720637306 161940419 360472177 560327751 446560856 524295016```

## 样例 #2

### 输入

```
4 1
1 1 0 0
```

### 输出

```
1 1 0 0```

## 样例 #3

### 输入

```
4 2
1 1 0 0
```

### 输出

```
1 2 1 0
```

## 样例 #4

### 输入

```
4 3
1 1 0 0```

### 输出

```
1 3 3 1```

# 题解

## 作者：Light_Poet (赞：37)

我们可以直接做多项式 $\ln$ 并乘以 $k$ 然后进行多项式 $\exp$

为此会导出一个问题：我们将 $k$ 对 $p$（模数）进行了取模，似乎无论 $k$ 多大这都是正确的。

-----

以下内容节选自 EI 鸽鸽的集训队论文：

下面说明一个更一般的情况：

设 $f(x)$ 为一个 $n$ 次多项式，$p$ 为质数。

$$f(x)^p\equiv f(x^p)\pmod p$$

当我们计算 $f(x)^p\bmod x^n$ 时，由于一般情况下 $n<p$，所以 $f(x)^p\equiv a_0=1(\text{本题})$，故我们可以直接将 $k$ 对 $p$ 取模。

证明的话可以考虑到 $(a+b)^p\equiv a^p+b^p\pmod p$

使用归纳证明：

设 $f(x)$ 为 $k$ 阶多项式，$a_k$ 为其第 $k$ 项系数，设 $f(x)=g(x)+a_kx^k$，且上述结论对于 $k-1$ 阶多项式成立。

考虑到：$f(x)^p=g(x)^p+a_k^px^{pk}=g(x^p)+a_kx^{pk}=f(x^p)$

---

## 作者：Karry5307 (赞：28)

### 题意
给定$n-1$次多项式$F(x)$与整数$k$，求$\bmod\ x^n$意义下的$(F(x))^k$。

$\texttt{Data Range:}n\leq 10^5,2\leq k\leq 10^{10^5}$

### 前置知识

多项式基本操作，不会请右转模板区qwq。

### 题解

upd：修改了几处错误的公式。

而且这是早年题解，多项式板子写得不知道比现在慢多少倍，板子快的可以忽略后面的对板子进行卡常内容。

首先大力推一波式子

$$G(x)\equiv(F(x))^k\pmod{x^n}$$

取下对数

$$\ln G(x)\equiv k\ln F(x)\pmod{x^n}$$

再取一下指数

$$G(x)\equiv e^{k\ln F(x)}\pmod {x^n}$$

很明显，时间复杂度是$O(n\log n)$，但是如果像我一样写代码会$\color{#2e468c}\texttt{TLE 8-20}$，于是来~~践行OI界的优良传统~~卡常数。

**前方大图警告**

![](https://cdn.luogu.com.cn/upload/pic/54414.png)
![](https://cdn.luogu.com.cn/upload/pic/54412.png)
![](https://cdn.luogu.com.cn/upload/pic/54411.png)
![](https://cdn.luogu.com.cn/upload/pic/54410.png)
![](https://cdn.luogu.com.cn/upload/pic/54409.png)

中间有$\texttt{selftest}$的是我的自测，数据比这一题强。

首先看一份比较$\texttt{naive}$的代码（只有$\color{#e67e22}\texttt{35 pts}$，吸氧后在$\texttt{selftest}$上跑还只有$\texttt{45070ms}$）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=3e5+51,MOD=998244353,G=3,INVG=332748118;
ll fd,exponent;
ll f[MAXN],res[MAXN],tmp[MAXN],pinv[MAXN],der[MAXN],texp[MAXN],texp2[MAXN];
ll g[MAXN],rev[MAXN],root[MAXN],invl[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll readm(ll mod)
{
    register li num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(((num<<3)+(num<<1))%MOD+(ch-'0'))%MOD;
        ch=getchar();
    }
    return num*neg;
}                                   
inline ll qadd(ll x,ll y,ll mod)
{
    return x+y>mod?x+y-mod:x+y;
}
inline ll qmin(ll x,ll y,ll mod)
{
    return x-y<0?x-y+mod:x-y;
}
inline ll qpow(ll base,ll exponent,ll mod)
{
    li res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%mod;
        }
        base=(li)base*base%mod,exponent>>=1;
    }
    return res;
}
inline void NTT(ll *cp,ll cnt,ll inv,ll mod)
{
    ll cur=0,res=0,omg=0;
    for(register int i=0;i<cnt;++i)
    {
        if(i<rev[i])
        {
            swap(cp[i],cp[rev[i]]);
        }
    }
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1,res=qpow(inv==1?G:INVG,(mod-1)/i,mod);
        for(register ll *p=cp;p!=cp+cnt;p+=i)
        {
            omg=1;
            for(register int j=0;j<cur;++j)
            {
                ll t=(li)omg*p[j+cur]%mod;
                p[j+cur]=qmin(p[j],t,mod),p[j]=qadd(p[j],t,mod);
                omg=(li)omg*res%mod;
            }
        }
    }
    if(inv==-1)
    {
        ll invl=qpow(cnt,mod-2,mod);
        for(register int i=0;i<=cnt;++i)
        {
            cp[i]=(li)cp[i]*invl%mod;
        }
    }
}
inline void deriv(ll fd,ll *f,ll *res,ll mod)
{
    for(register int i=1;i<fd;++i)
    {
        res[i-1]=(li)f[i]*i%mod;
    }
    res[fd-1]=0;
}
inline void integ(ll fd,ll *f,ll *res,ll mod)
{
    for(register int i=1;i<fd;++i)
    {
        res[i]=(li)f[i-1]*qpow(i,mod-2,mod)%mod;
    }
    res[0]=0;
}
inline void inv(ll fd,ll *f,ll *res,ll mod)
{
    if(fd==1)
    {
        res[0]=qpow(f[0],mod-2,mod);
        return;
    }
    inv((fd+1)>>1,f,res,mod);
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;++i)
    {
        tmp[i]=i<fd?f[i]:0;
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmp,cnt,1,mod),NTT(res,cnt,1,mod);
    for(register int i=0;i<cnt;++i)
    {
        res[i]=(li)qmin(2,(li)tmp[i]*res[i]%mod,mod)*res[i]%mod;
    }
    NTT(res,cnt,-1,mod);
    for(register int i=fd;i<cnt;++i)
    {
        res[i]=0;
    }
}
inline void ln(ll fd,ll *f,ll *res,ll mod)
{
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    inv(fd,f,pinv,mod),deriv(fd,f,der,mod);
    for(register int i=0;i<cnt;++i)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(pinv,cnt,1,mod),NTT(der,cnt,1,mod);
    for(register int i=0;i<cnt;++i)
    {
        der[i]=(li)der[i]*pinv[i]%mod;
    }
    NTT(der,cnt,-1,mod),integ(fd,der,res,mod);
    for(register int i=0;i<cnt;++i)
    {
        der[i]=pinv[i]=0;
    }
}
inline void exp(ll fd,ll *f,ll *res,ll mod)
{
    if(fd==1)
    {
        res[0]=1;
        return;
    }
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    exp((fd+1)>>1,f,res,mod),ln(fd,res,texp,mod);
    for(register int i=0;i<cnt;++i)
    {
 		rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    texp[0]=qmin(f[0]+1,texp[0],mod);
    for(register int i=1;i<fd;++i)
    {
        texp[i]=qmin(f[i],texp[i],mod);
    }
    NTT(texp,cnt,1,mod),NTT(res,cnt,1,mod);
    for(register int i=0;i<cnt;++i)
    {
        res[i]=(li)res[i]*texp[i]%mod;
    }
    NTT(res,cnt,-1,mod);
    for(register int i=0;i<cnt;++i)
    {
        texp[i]=0,res[i]=i<fd?res[i]:0;
    }
}
int main()
{
    fd=read(),exponent=readm(MOD);
    for(register int i=0;i<fd;++i)
    {
        f[i]=read();
    }
    ln(fd,f,g,MOD);
    for(register int i=0;i<fd;++i)
    {
        g[i]=(li)g[i]*exponent%MOD;
    }
    exp(fd,g,res,MOD);
    for(register int i=0;i<fd;++i)
    {
        printf("%d ",res[i]);
    }
}
```
首先考虑把一些调用次数多而短的函数给搞掉。


一眼看过去，调用次数最多的是$\texttt{qadd}$和$\texttt{qmin}$，于是考虑吧这两个函数搞掉，把一些副本放到函数里面开$\texttt{static}$，于是就优化到了$\texttt{31078ms}$。

接下来，就可以考虑压缩$\texttt{deriv}$和$\texttt{integ}$了，尽管代码里只有调用一次，但是$\texttt{exp}$中会调用$\log n$次，所以果断搞掉，现在时间是$\texttt{28972ms}$。

接着考虑删掉一些不必要的参数，因为传$\texttt{int}$是$O(32)$的。于是可以考虑删掉$\texttt{mod}$，因为这题只有一个模数，用不着加这样一个参。

经过毒瘤卡常后，一个$\texttt{45000+ms}$的代码被优化成了$\texttt{12000-ms}$，可以见得卡常是个好东西。

附赠[$\texttt{selftest}$](https://www.luogu.org/problemnew/show/U65286)

### 代码
```
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=3e5+51,MOD=998244353,G=3,INVG=332748118;
ll fd,exponent;
ll f[MAXN],res[MAXN],g[MAXN],rev[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll readm()
{
    register li num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=((num<<3)+(num<<1)+(ch-'0'))%MOD;
        ch=getchar();
    }
    return num*neg;
}                                   
inline ll qpow(ll base,ll exponent)
{
    li res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    ll cur=0,res=0,omg=0;
    for(register int i=0;i<cnt;++i)
    {
        if(i<rev[i])
        {
            swap(cp[i],cp[rev[i]]);
        }
    }
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1,res=qpow(inv==1?G:INVG,(MOD-1)/i);
        for(register ll *p=cp;p!=cp+cnt;p+=i)
        {
            omg=1;
            for(register int j=0;j<cur;++j)
            {
                ll t=(li)omg*p[j+cur]%MOD,t2=p[j];
                p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD;
                omg=(li)omg*res%MOD;
            }
        }
    }
    if(inv==-1)
    {
        ll invl=qpow(cnt,MOD-2);
        for(register int i=0;i<=cnt;++i)
        {
            cp[i]=(li)cp[i]*invl%MOD;
        }
    }
}
inline void inv(ll fd,ll *f,ll *res)
{
    static ll tmp[MAXN];
    if(fd==1)
    {
        res[0]=qpow(f[0],MOD-2);
        return;
    }
    inv((fd+1)>>1,f,res);
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;++i)
    {
        tmp[i]=i<fd?f[i]:0;
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmp,cnt,1),NTT(res,cnt,1);
    for(register int i=0;i<cnt;++i)
    {
        res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD;
    }
    NTT(res,cnt,-1);
    for(register int i=fd;i<cnt;++i)
    {
        res[i]=0;
    }
}
inline void ln(ll fd,ll *f,ll *res)
{
    static ll pinv[MAXN],der[MAXN];
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    inv(fd,f,pinv);
    for(register int i=1;i<fd;++i)
    {
        der[i-1]=(li)f[i]*i%MOD;
    }
    der[fd-1]=0;
    for(register int i=0;i<cnt;++i)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(pinv,cnt,1),NTT(der,cnt,1);
    for(register int i=0;i<cnt;++i)
    {
        der[i]=(li)der[i]*pinv[i]%MOD;
    }
    NTT(der,cnt,-1);
    for(register int i=1;i<fd;++i)
    {
        res[i]=(li)der[i-1]*qpow(i,MOD-2)%MOD;
    }
    res[0]=0;
    for(register int i=0;i<cnt;++i)
    {
        der[i]=pinv[i]=0;
    }
}
inline void exp(ll fd,ll *f,ll *res)
{
    static ll texp[MAXN];
    if(fd==1)
    {
        res[0]=1;
        return;
    }
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    exp((fd+1)>>1,f,res),ln(fd,res,texp);
    for(register int i=0;i<cnt;++i)
    {
 		rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    texp[0]=(f[0]+1-texp[0]+MOD)%MOD;
    for(register int i=1;i<fd;++i)
    {
        texp[i]=(f[i]-texp[i]+MOD)%MOD;
    }
    NTT(texp,cnt,1),NTT(res,cnt,1);
    for(register int i=0;i<cnt;++i)
    {
        res[i]=(li)res[i]*texp[i]%MOD;
    }
    NTT(res,cnt,-1);
    for(register int i=0;i<cnt;++i)
    {
        texp[i]=0,res[i]=i<fd?res[i]:0;
    }
}
int main()
{
    fd=read(),exponent=readm();
    for(register int i=0;i<fd;++i)
    {
        f[i]=read();
    }
    ln(fd,f,g);
    for(register int i=0;i<fd;++i)
    {
        g[i]=(li)g[i]*exponent%MOD;
    }
    exp(fd,g,res);
    for(register int i=0;i<fd;++i)
    {
        printf("%d ",res[i]);
    }
}
```



---

## 作者：mrsrz (赞：14)

### 算法一：

由于$a^b=e^{b\ln a}$，所以可以先求$k\ln A(x)$，然后再$\exp$回来。这样就可以取模了。

多项式求逆+多项式指数函数+多项式对数函数，时间复杂度$O(n\log n)$。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
const int md=998244353,N=262145,g3=(md+1)/3;
typedef long long LL;
int n,k,a[N],A[N],G[N];
inline void upd(int&a){a+=a>>31&md;}
inline int pow(int a,int b){
	int r=1;
	for(;b;b>>=1,a=(LL)a*a%md)if(b&1)r=(LL)r*a%md;return r;
}
namespace poly{
	int lim,rev[N],inv[N];
	inline int poly_start(){
		inv[1]=1;
		for(int i=2;i<N;++i)inv[i]=(md-md/i)*(LL)inv[md%i]%md;
		return 1;
	}
	int __START__=poly_start();
	inline void init(int n){
		int l=-1;
		for(lim=1;lim<n;lim<<=1)++l;
		for(int i=1;i<lim;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
	}
	void NTT(int*a,int f){
		for(int i=1;i<lim;++i)if(i<rev[i])std::swap(a[i],a[rev[i]]);
		for(int i=1;i<lim;i<<=1){
			const int gi=pow(f?3:g3,(md-1)/(i<<1));
			for(int j=0;j<lim;j+=i<<1)
			for(int k=0,g=1;k<i;++k,g=(LL)g*gi%md){
				const int x=a[j+k],y=a[j+k+i]*(LL)g%md;
				upd(a[j+k]+=y-md),upd(a[j+k+i]=x-y);
			}
		}
		if(!f){
			const LL iv=inv[lim];
			for(int i=0;i<lim;++i)a[i]=a[i]*iv%md;
		}
	}
	void INV(const int*a,int*B,int n){
		if(n==1)*B=pow(*a,md-2);else{
			INV(a,B,n+1>>1);
			init(n<<1);
			static int A[N];
			for(int i=0;i<n;++i)A[i]=a[i];
			for(int i=n;i<lim;++i)A[i]=0;
			NTT(A,1),NTT(B,1);
			for(int i=0;i<lim;++i)B[i]=B[i]*((2-(LL)A[i]*B[i]%md+md)%md)%md;
			NTT(B,0);
			for(int i=n;i<lim;++i)B[i]=0;
		}
	}
	void dao(const int*a,int*G,int n){
		G[n-1]=0;
		for(int i=1;i<n;++i)
		G[i-1]=(LL)i*a[i]%md;
	}
	void INT(const int*a,int*G,int n){
		*G=0;
		for(int i=n-1;~i;--i)G[i+1]=a[i]*(LL)inv[i+1]%md;
	}
	void LN(const int*a,int*B,int n){
		static int F[N];
		dao(a,F,n),INV(a,B,n);
		init(n<<1);
		for(int i=n;i<lim;++i)B[i]=F[i]=0;
		NTT(F,1),NTT(B,1);
		for(int i=0;i<lim;++i)F[i]=(LL)B[i]*F[i]%md;
		NTT(F,0);
		INT(F,B,n);
		for(int i=n;i<lim;++i)B[i]=0;
	}
	void EXP(const int*a,int*F,int n){
		if(n==1)*F=1;else{
			EXP(a,F,n+1>>1);
			static int F0[N],A[N];
			for(int i=0;i<=n<<1;++i)F0[i]=0,A[i]=a[i];
			LN(F,F0,n);
			init(n<<1);
			for(int i=n;i<lim;++i)A[i]=0;
			NTT(A,1),NTT(F0,1),NTT(F,1);
			for(int i=0;i<lim;++i)F[i]=F[i]*(A[i]+1LL-F0[i]+md)%md;
			NTT(F,0);
			for(int i=n;i<lim;++i)F[i]=0;
		}
	}
}
int main(){
	scanf("%d",&n);
	int c=getchar();while(isspace(c))c=getchar();
	for(;isdigit(c);c=getchar())k=(k*10LL+(c^'0'))%md;
	for(int i=0;i<n;++i)scanf("%d",a+i);
	poly::LN(a,A,n);
	for(int i=0;i<n;++i)A[i]=A[i]*(LL)k%md;
	for(int i=0;i<n;++i)a[i]=0;
	poly::EXP(A,a,n);
	for(int i=0;i<n;++i)printf("%d ",a[i]);
	return 0;
}
```

### 算法二：

发现$e^{k\ln A(x)}\equiv e^{(k\bmod{998244353})\ln A(x)}\equiv A(x)^{k\bmod{998244353}}\pmod{x^n}$，所以先对$k$取模，然后直接多项式快速幂即可。

时间复杂度$O(n\log n\log(k\bmod{998244353}))$。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
const int md=998244353,N=262145,g3=(md+1)/3;
typedef long long LL;
int n,k,a[N],A[N];
inline void upd(int&a){a+=a>>31&md;}
inline int pow(int a,int b){
	int r=1;
	for(;b;b>>=1,a=(LL)a*a%md)if(b&1)r=(LL)r*a%md;return r;
}
int lim,rev[N];
inline void init(int n){
	int l=-1;
	for(lim=1;lim<n;lim<<=1)++l;
	for(int i=1;i<lim;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
}
void NTT(int*a,int f){
	for(int i=1;i<lim;++i)if(i<rev[i])std::swap(a[i],a[rev[i]]);
	for(int i=1;i<lim;i<<=1){
		const int gi=pow(f?3:g3,(md-1)/(i<<1));
		for(int j=0;j<lim;j+=i<<1)
		for(int k=0,g=1;k<i;++k,g=(LL)g*gi%md){
			const int x=a[j+k],y=a[j+k+i]*(LL)g%md;
			upd(a[j+k]+=y-md),upd(a[j+k+i]=x-y);
		}
	}
	if(!f){
		const LL iv=pow(lim,md-2);
		for(int i=0;i<lim;++i)a[i]=a[i]*iv%md;
	}
}
int main(){
	scanf("%d",&n);
	int c=getchar();while(isspace(c))c=getchar();
	for(;isdigit(c);c=getchar())k=(k*10LL+(c^'0'))%md;
	for(int i=0;i<n;++i)scanf("%d",a+i);
	*A=1;
	init(n<<1);
	NTT(A,1),NTT(a,1);
	for(;k;k>>=1){
		if(k&1){
			for(int i=0;i<lim;++i)A[i]=(LL)A[i]*a[i]%md;
			NTT(A,0);
			for(int i=n;i<lim;++i)A[i]=0;
			NTT(A,1);
		}
		for(int i=0;i<lim;++i)a[i]=(LL)a[i]*a[i]%md;
		NTT(a,0);
		for(int i=n;i<lim;++i)a[i]=0;
		NTT(a,1);
	}
	NTT(A,0);
	for(int i=0;i<n;++i)printf("%d ",A[i]);
	return 0;
}
```

---

## 作者：Constant (赞：12)

## 前言:

我要强烈谴责一些没有讲清楚为什么最后化简出来的系数 $k$ 可以取模的题解，

这是十分不负责任的行为，这些多项式题目不仅仅是背个板子，走马观花地看一

些，了解模板的推导过程才是学习多项式的目的，题目意思就不讲了，已经很清楚

了，下面讲解法。

## 前置知识：

多项式 $ln$ ，多项式 $exp$ ，多项式乘法逆。

## Solution:

首先知道: $B(x)≡A^k(x)$  $(mod$ $x^n)$  

考虑怎么消去次数 $k$ ，想到对数公式。

于是有: $ln$ $B(x)≡ $ $ln$ $A^k(x)$  $(mod$ $x^n)$ 

也即: $ln$ $B(x)≡ $ $k×ln$ $A(x)$  $(mod$ $x^n)$

于是，先对多项式 $A(x)$ 求出它的 $ln$ ，乘以 $k$ ，就求出了 $ln$ $B(x)$ 

值，对 $ln$ $B(x)$ 做一遍多项式 $exp$ 就是 $B(x)$ 了。

但是次数 $k$ 真的很大，需要一边读入一边取模，下证取模仍然使得答案正确。

由泰勒展开可得， $e^x=\sum{\frac{x^i}{i!}}$ 。

把上式的 $x$ 用 ${k×lnB(x)}$ 替换。

于是求和式子的分母处就是 $k^i×ln^iB(x)$ 。

显然取模后不变。

下面是代码，有点长。

```cpp
#include<bits/stdc++.h>
#define N 400050
#define p 998244353
#define ll long long
using namespace std;
char ch[N];
ll n,k;
ll a[N],b[N];
ll bit,pre[N],len;
ll g1=3,g2=332748118,c[N],tmp[N],lx[N],inv_num[N],Z[N],ans[N];
ll ksm(ll a,ll b)
{
	ll s=1;
	while(b)
	{
		if(b&1) s=(s*a)%p;
		a=(a*a)%p;
		b=b>>1;
	}
	return s;
} 
void NTT(ll* a,ll len,ll pd)
{
    for(register ll i=0;i<len;i++) 
	{
        if(i<pre[i]) swap(a[i],a[pre[i]]);
    }
    for (register ll mid=1;mid<=len-1;mid=(mid<<1)) 
	{
        ll gn;
		if(pd==1) gn=ksm(g1,(p-1)/(mid<<1));
        if(pd==-1) gn=ksm(g2,(p-1)/(mid<<1));	
        for(register ll i=0;i<=len-1;i+=(mid<<1)) 
		{
            ll g=1,x,y;
            for(register ll j=0;j<=mid-1;j++,g=(g*gn)%p) 
			{    
				x=a[i+j];
				y=g*a[i+j+mid]%p; 
                a[i+j]=(x+y)%p;
                a[i+j+mid]=(x-y+p)%p; 
            }
        }
    }	 
    if(pd==-1)
    {
        ll inv=ksm(len,p-2);
        for(ll i=0;i<len;i++)
        {
        	a[i]=(a[i]*inv)%p;
		}
	}
}
void inv(ll L,ll* a,ll* b)
{
	if(L==1)
	{
		b[0]=ksm(a[0],p-2);
		return;
	}
	inv((L+1)>>1,a,b);
    bit=0;	
	while((1<<bit)<(L<<1)) 
	{
        bit++;
    }
    len=(1<<bit);
	for(register ll i=0;i<len;i++) 
	{
        pre[i]=((pre[i>>1]>>1)|((i&1)<<(bit-1)));
    }
    for(register ll i=0;i<=L-1;i++) c[i]=a[i];
	for(register ll i=L;i<len;i++) c[i]=0;
	NTT(b,len,1);
	NTT(c,len,1);
	for(register ll i=0;i<len;i++)
	{
		b[i]=(2-c[i]*b[i]%p+p)*b[i]%p;	
	}
	NTT(b,len,-1);
	for(register ll i=L;i<len;i++) b[i]=0;
}
void Add(ll L,ll *a,ll *b)
{
	bit=0;
	while((1<<bit)<(L<<1)) 
	{
        bit++;
    }
    len=(1<<bit);
	for(register ll i=0;i<len;i++) 
	{
        pre[i]=((pre[i>>1]>>1)|((i&1)<<(bit-1)));
    }
	NTT(a,len,1);
	NTT(b,len,1);
	for(register ll i=0;i<len;i++) 
	{
	    b[i]=(a[i]*b[i])%p;	
	}
	NTT(b,len,-1);
}
void D(ll *a,ll *b,ll L)
{
	for(register ll i=1;i<=L-1;i++)
	{
		b[i-1]=i*a[i]%p;
	}	
	b[L-1]=0;
}
void I(ll* a,ll* b,ll L)
{
	for(register ll i=1;i<=L-1;i++)
	{
	    b[i]=a[i-1]*inv_num[i]%p;	
	}	
	b[0]=0;
}
void ln(ll L,ll* a,ll* b)
{
	for(ll i=0;i<(L<<2);i++)
	{
		b[i]=0;
	}
	inv(L,a,b);
	len=1; 
	bit=0;
	while(len<(L<<1))
	{
	    bit++;
	    len=(len<<1);
	}
	for(ll i=0;i<=len-1;i++)
	{
		pre[i]=(pre[i>>1]>>1)|((i&1)<<(bit-1));
	}
	for(ll i=0;i<L-1;i++) 
	{
		Z[i]=a[i+1]*(i+1)%p;
	}
	for(ll i=L-1;i<=len-1;i++) 
	{
		Z[i]=0;
	}
	NTT(Z,len,1);
	NTT(b,len,1);
	for(ll i=0;i<=len-1;i++)
	{
		b[i]=b[i]*Z[i]%p;
	}	  
	NTT(b,len,-1);
	for(ll i=L-1;i>0;i--)
	{
		b[i]=b[i-1]*inv_num[i]%p;
	}  
	for(ll i=L;i<len;i++) 
	{
		b[i]=0;
	}
	b[0]=0;
}
void exp(ll* a,ll* b,ll L)
{
	if(L==1)
	{
		b[0]=1;
		return;
	}
	exp(a,b,(L+1)>>1);
	ln(L,b,lx);
	bit=0;
	while((1<<bit)<(L<<1)) 
	{
        bit++;
    }
    len=(1<<bit);
	for(register ll i=0;i<len;i++) 
	{
        pre[i]=((pre[i>>1]>>1)|((i&1)<<(bit-1)));
    }
    for(register ll i=0;i<=L-1;i++)
	{
	    lx[i]=a[i]>=lx[i]?a[i]-lx[i]:a[i]-lx[i]+p;
	} 
	lx[0]++;
	for(register ll i=L;i<len;i++)
	{
		lx[i]=0;
		b[i]=0;
	}	
	NTT(lx,len,1);
	NTT(b,len,1);
	for(register ll i=0;i<len;i++)
	{
	    b[i]=(b[i]*lx[i])%p; 
	}
	NTT(b,len,-1);
	for(register ll i=L;i<len;i++)
	{
		b[i]=0;
	}
}
inline ll read()
{
    ll x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x*10+ch-48)%p;ch=getchar();}
    return x*f;
}
int main()
{
    scanf("%lld",&n);
    k=read();
    inv_num[1]=1;
    for(register ll i=0;i<=n-1;i++)
    {
       	scanf("%lld",&a[i]);
       	inv_num[i+2]=p-(p/(i+2))*inv_num[p%(i+2)]%p;
	} 
	ln(n,a,b);
	for(register ll i=0;i<=n-1;i++)
    {
        b[i]=b[i]*k%p;
    }
    exp(b,ans,n);
	for(register ll i=0;i<=n-1;i++) printf("%lld ",ans[i]);
    return 0;
}
```











---

## 作者：teylnol_evteyl (赞：5)

# 前置知识 FFT

## 复数与单位根

定义 $i^2=-1$，复数是形如 $a+bi$（$a,b\in R$）的数，其中 $a$ 是实部（$Re(a+bi)=a$），$b$ 是虚部（$Im(a+bi)=b$）。

运算：

- $(a+bi) \pm (c+di)=(a\pm c)+(b\pm d)i$。
- $(a+bi)(c+di)=(ac-bd)+(ad+bc)i$。
- $\dfrac{a+bi}{c+di}=\dfrac{(ac-bd)+(ad+bc)i}{c^2-d^2}$。

一个复数对应一个复平面上的点，所以也可以用幅角 $\theta$ 和模长 $r$ 确定一个复数。

欧拉公式 $e^{i\theta}=\cos\theta+i\sin\theta$。所以也可以用 $re^{i\theta}$ 表示一个复数。

此时复数加减可以看作向量加减，复数乘法可以看作模长相乘、幅角相加。

当 $r=1$ 构成复平面上单位圆，$\omega_n=\cos\left(\dfrac{2\pi}{n}\right)+i\sin\left(\dfrac{2\pi}{n}\right)$ 是单位根，表示单位圆上第一个 $n$ 等分点。

单位根性质：

- $\omega_{2n}^{2k}=\omega_n^k$。
- $\omega_{2n}^k=-\omega_{2n}^{n+k}$。

## 思想

基于乘法分配律的算法优化是比较困难的，但是如果用点值表示多项式，乘法运算只需要对应横坐标的点值相乘即可，所以可以考虑使用一组特殊的横坐标，快速进行求值和插值。FFT 中，我们选择 $n=2^m$ 的单位根 $\omega_n^{k}$。

## 求值

把多项式奇偶分组，则 $A(x)=A_0(x)+xA_1(x)$，根据单位根的性质，对 $0\le k<n$：

- $A(\omega_{2n}^k)=A_0(\omega_n^k)+\omega_{2n}^kA_1(\omega_n^k)$。
- $A(\omega_{2n}^{k+n})=A_0(\omega_n^k)-\omega_{2n}^kA_1(\omega_n^k)$。

可以分治进行，时间复杂度 $O(n\log n)$。

## 插值

$$b_i=\sum_{j=0}^{n-1}a_j\omega_n^{ij}\Longleftrightarrow a_i=\dfrac 1 n\sum_{j=0}^{n-1}b_j\omega_n^{-ij}$$

证明：

$$
\begin{aligned}
\dfrac 1 n\sum_{j=0}^{n-1}b_j\omega_n^{-ij} &= \dfrac 1 n\sum_{j=0}^{n-1}\sum_{k=0}^{n-1}a_k\omega_n^{jk-ij} \\
&= \dfrac 1 n\sum_{k=0}^{n-1}a_k\sum_{j=0}^{n-1}\omega_n^{j(i-k)}
\end{aligned}
$$

当 $i=k$，$\omega_n^0=1$，则贡献为 $a_k$。

当 $i\ne k$，相当于若干个单位圆上点求和，可以抵消。

另一方面同理。

所以只需要把求值的 $\omega_n$ 换成 $\omega_n^{-1}$ 即可。

## 优化

- 递归：相当于是将 $a_i$ 填到 $a_{f(i)}$，且 $f(i)$ 其实是将 $i$ 的二进制位反过来。
- 回溯：从小到大，蝶形变换。
- 储存单位根：把单位根预处理出来，并且类似快速幂的过程。
- 循环性质。单位根是循环的。

## 模板

```cpp
inline void FFT(Complex a[], int n, int m, int ty)
{
    for(int i = 0, j = 0; i < n; i ++ )
    {
        if(i < j) swap(a[i], a[j]);
        for(int k = 1 << (m - 1); (j ^= k) < k; k >>= 1) ;
    }
    static Complex w[N];
    w[0] = {1, 0};
    for(int i = 1; i < n; i <<= 1)
    {
        Complex wi = {cos(PI / i), sin(PI / i) * ty};
        for(int j = i - 2; j >= 0; j -= 2)
        {
            w[j] = w[j >> 1];
            w[j + 1] = w[j] * wi;
        }
        for(int j = 0; j < n; j += i << 1)
            for(int k = j; k < j + i; k ++ )
            {
                Complex t1 = a[k], t2 = a[k + i] * w[k - j];
                a[k] = t1 + t2, a[k + i] = t1 - t2;
            }
    }
    if(ty == -1)
    {
        double t = 1.0 / n;
        for(int i = 0; i < n; i ++ ) a[i].a *= t;
    }
}
```

# 前置知识 NTT

当模数 $P=t2^k+1$，当 $k$ 比较大时，设其中一个原根为 $g$，则 $w_n=g^{\frac{P - 1} n}$，可以进行 FFT。

一般，如果可以 NTT 也可以 FFT，FFT 会比较快（取模很慢）。

```cpp
inline LL ksm(LL a, LL n)
{
    LL res = 1;
    while(n)
    {
        if(n & 1) res = res * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return res;
}
inline void NTT(LL a[], int n, int ty)
{
    for(int i = 0, j = 0; i < n; i ++ )
    {
        if(i < j) a[i] ^= a[j] ^= a[i] ^= a[j];
        for(int k = (n >> 1); (j ^= k) < k; k >>= 1) ;
    }
    static LL w[N];
    w[0] = 1;
    for(int i = 1; i < n; i <<= 1)
    {
        LL wi = ksm(G, P - 1 + ty * (P - 1) / (i << 1));
        for(int j = i - 2; j >= 0; j -= 2)
        {
            w[j] = w[j >> 1];
            w[j | 1] = w[j] * wi % P;
        }
        for(int j = 0; j < n; j += (i << 1))
        {
            for(int k = j; k < j + i; k ++ )
            {
                LL t0 = a[k], t1 = a[k + i] * w[k - j] % P;
                (a[k] = t0 + t1) >= P && (a[k] -= P), (a[k + i] = t0 - t1 + P) >= P && (a[k + i] -= P);
            }
        }
    }
    if(ty == -1)
    {
        LL inv = ksm(n, P - 2);
        for(int i = 0; i < n; i ++ ) a[i] = a[i] * inv % P;
    }
}
```

# 前置知识 半在线卷积

给定序列 $g$，求 $h_n=\sum\limits_{i=1}^n g_if_{n-i}$，且 $f_i$ 需要在计算出 $h_i$ 之后才能知道。

比较常用的方法是分治 FFT，类似于 CDQ 分治优化 DP 的思路：

- 如果 $l=r$，则根据 $h_l$ 计算 $f_l$。
- 分治 $[l,mid]$。
- 用 $f_{[l,mid]}$ 与 $g_{[1,r-l+1]}$ 做乘法，贡献到 $h_{[mid+1,r]}$。
- 由于只需用到后半部分，所以不需要保证前半部分结果正确，于是 FFT 的长度只需要开到 $r-l+1$。
- 分治 $[mid+1,r]$。

时间复杂度 $O(n\log^2n)$，NTT 的规模是 $3\log n\times n$（表示进行 $3\log n$ 次长度为 $n$ 的 NTT，后同）。

```cpp
inline void Mul(LL f[], LL g[], int n, int m)
{
    int k = 0;
    while((1 << k) < m) k ++ ;
    for(int i = 0; i < 1 << k; i ++ ) a[i] = b[i] = 0;
    for(int i = 0; i < n; i ++ ) a[i] = f[i];
    for(int i = 0; i < m; i ++ ) b[i] = g[i];
    NTT(a, 1 << k, 1), NTT(b, 1 << k, 1);
    for(int i = 0; i < (1 << k); i ++ ) a[i] = a[i] * b[i] % P;
    NTT(a, 1 << k, -1);
}
inline void Solve(int l, int r)
{
    if(l == r)
    {
        f[l] += !l;
        return ;
    }
    int mid = l + r >> 1;
    Solve(l, mid);
    Mul(f + l, g, mid - l + 1, r - l + 1);
    for(int i = mid + 1; i <= r; i ++ ) f[i] = (f[i] + a[i - l]) % P;
    Solve(mid + 1, r);
}
```

# 前置知识 多项式求逆

对多项式 $F(x)$ 求 $G(x)$，使得 $(F\cdot G)(x)=1$。

由定义易得存在逆当且仅当常数项不为 $0$，且有递推式：

$$
g_n=
\begin{cases}
f_0^{-1} & n=0 \\
-f_0^{-1}\sum\limits_{i=1}^nf_ig_{n-i} & n>0
\end{cases}
$$

时间复杂度 $O(n^2)$，可以用半在线卷积优化为 $O(n\log^2n)$。

考虑倍增，已知 $(F\cdot G_m)(x)\equiv 1\pmod {x^m}$，求 $(F\cdot G_{2m})(x)\equiv 1\pmod {x^{2m}}$：

$$
\begin{aligned}
G_{2m}-G_{m} &\equiv 0 &\pmod{x^m} \\
G_{2m}^2-2G_{m}G_{2m}+G_{m}^2 &\equiv 0 &\pmod{x^{2m}} \\
G_{2m}-2G_m+G_m^2F&\equiv 0&\pmod {x^{2m}} \\
G_{2m}&\equiv 2G_m-G_m^2F&\pmod {x^{2m}}
\end{aligned}
$$

对 $G_m,F_m$ 分别进行 NTT，计算点值之后逆 NTT 即可。

时间复杂度 $O(n\log n)$，NTT 规模 $6\times 2n$。

```cpp
inline void Inv(LL f[], LL g[], int m)
{
    static LL a[N], b[N];
    int k = 1;
    g[0] = ksm(f[0], P - 2), g[1] = 0;
    while(k < m)
    {
        k <<= 1;
        for(int i = 0; i < k; i ++ ) a[i] = f[i], b[i] = g[i];
        for(int i = k; i < k << 1; i ++ ) a[i] = b[i] = g[i] = 0;
        NTT(a, k << 1, 1), NTT(b, k << 1, 1);
        for(int i = 0; i < k << 1; i ++ ) g[i] = (2 - b[i] * a[i] % P + P) * b[i] % P;
        NTT(g, k << 1, -1);
        for(int i = k; i < k << 1; i ++ ) g[i] = 0;
    }
}
```

# 前置知识 多项式求对数

若 $f_0=1$，求 $\ln F$，对其进行求导，有

$$(\ln F)'=\dfrac{F'}{F}$$

多项式求导有 $F'=\sum\limits_{i=1}if_ix^{i-1}$。

求导，求逆，相乘，积分（求导逆运算）。

时间复杂度 $O(n\log n)$，NTT 规模 $9\times 2n$。

```cpp
inline void Ln(LL f[], LL g[], int m)
{
    static LL a[N];
    Inv(f, a, m);
    for(int i = 0; i < m; i ++ ) g[i] = f[i + 1] * (i + 1) % P;
    int k = 1;
    while(k < (m << 1)) k <<= 1;
    NTT(g, k, 1), NTT(a, k, 1);
    for(int i = 0; i < k; i ++ ) g[i] = g[i] * a[i] % P;
    NTT(g, k, -1);
    for(int i = m - 1; i > 0; i -- ) g[i] = g[i - 1] * inv[i] % P;
    g[0] = 0;
}
```

# 前置知识 多项式求指数函数

对 $f_0=0$，设 $G=e^F$ 或 $G=\exp(F)$，则

$$
\begin{aligned}
F&=\ln G \\
(F)'&= \dfrac{G'}G \\
xGF'&=xG'
\end{aligned}
$$

这里有 $f'_i=if_i$，所以有

$$
g_n=
\begin{cases}
1 & n=1 \\
\dfrac 1 n\sum\limits_{i=1}^n if_ig_{n-i} & n>1
\end{cases}
$$

可以用半在线卷积优化到 $O(n\log^2n)$。

引入牛顿迭代和多项式牛顿迭代。

关于实数 $x$ 的函数 $f(x)$ 若在 $[a,b]$ 中连续且单调，求其中方程 $f(x)=0$ 的根。

设当前的值为 $x$，找到一个更接近根的实数 $x'$，有 $x'=x-\dfrac{f(x)}{f'(x)}$。

扩展到多项式，每进行一次迭代，有效项数翻倍。

可以用牛顿迭代求解逆元和开根。

设 $f(X)=\ln X-F$，则 $f'(X)=\dfrac 1 X$，所以 $G_{2m}=G_m(1-\ln G_m+F)$。

时间复杂度 $O(n\log n)$，NTT 规模 $24\times 2n$。

洛谷模板题中，牛顿迭代法以 $30ms$ 的优势险胜半在线卷积。

```cpp
inline void Exp(LL f[], LL g[], int m)
{
    static LL a[N];
    g[0] = 1;
    int k = 1;
    while(k < m)
    {
        k <<= 1;
        Ln(g, a, k);
        for(int i = 0; i < k; i ++ )(a[i] = f[i] - a[i] + P) >= P && (a[i] -= P);
        a[0] ++ ;
        for(int i = k; i < k << 1; i ++ ) a[i] = 0;
        NTT(a, k << 1, 1), NTT(g, k << 1, 1);
        for(int i = 0; i < k << 1; i ++ ) g[i] = g[i] * a[i] % P;
        NTT(g, k << 1, -1);
        for(int i = k; i < k << 1; i ++ ) g[i] = 0;
    }
}
```

# 进入正题 快速幂

这题 $f_0=1$，直接求对数、乘、求指数即可，其中乘之后仍然对 $P$ 取模，因为与欧拉定理无关。

对于一般情况，把 $F$ 拆成 $x^st(F')$ 的形式使得 $f'_0=1$，此时有 $F^k=x^{sk}t^kF'^k$，具体需要判断 $sk$ 与 $m$ 大小并且 $t^k$ 的指数对 $P-1$ 取模。

时间复杂度 $O(n\log n+\log k)$，NTT 规模 $33\times 2n$。

```cpp
inline void Read()
{
    scanf("%s", s);
    for(; s[l]; l ++ ) s[l] ^= 48;
}
inline LL Mod(LL P)
{
    LL res = 0;
    for(int i = 0; i < l; i ++ ) res = (res * 10 + s[i]) % P;
    return res;
}
inline LL Cmp(LL k)
{
    LL res = 0;
    for(int i = 0; i < l; i ++ )
    {
        res = res * 10 + s[i];
        if(res > k) return -1;
    }
    return res;
}

inline void Power1(LL f[], int m)
{
    static LL a[N];
    while(m != (m & -m)) m ++ ;
    Ln(f, a, m);
    LL t = Mod(P);
    for(int i = 0; i < m; i ++ ) a[i] = a[i] * t % P;
    for(int i = 0; i < m; i ++ ) f[i] = 0;
    Exp(a, f, m);
}
inline void Power(LL f[], int m)
{
    int s = 0;
    while(!f[s]) s ++ ;
    LL t = f[s], invt = ksm(t, P - 2);
    for(int i = s; i < m; i ++ ) f[i] = f[i] * invt % P;
    Power1(f + s, m - s);
    t = ksm(t, Mod(P - 1));
    for(int i = s; i < m; i ++ ) f[i] = f[i] * t % P;
    if(s)
    {
        LL d = Cmp(m / s);
        if(d == -1)
        {
            for(int i = 0; i < m; i ++ ) f[i] = 0;
        }
        else
        {
            d = (d - 1) * s;
            for(int i = m - 1; i >= d; i -- ) f[i] = f[i - d];
            for(int i = 0; i < d; i ++ ) f[i] = 0;
        }
    }
}
```

---

## 作者：Prean (赞：4)

A了这题之后，来发篇题解来警示后人。。。

先推一波式子：
$$ F^k(x) \equiv G(x) \pmod {x^n} $$
两边同时取Ln：
$$ k \times Ln(f(x)) \equiv Ln(G(x)) \pmod {x^n} $$
同时Exp：
$$ e^{k \times Ln(f(x))} \equiv G(x) \pmod {x^n} $$
然后就没什么可说的了。。。

我很好奇为什么很多人都在卡常，我写的代码不吸氧跑了7.5s左右。

Code：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define clr(f,len) memset(f,0,(len)<<3)
#define cpy(f,g,len) memcpy(f,g,(len)<<3)
typedef long long ll;
const ll M=5e5+5,G=3,invG=332748118ll,mod=998244353ll;
ll n,f[M],t[M],inv[M];
void swap(ll&a,ll&b){
    a^=b^=a^=b;
}
ll pow(ll a,ll b=mod-2){
    ll ans=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ans=ans*a%mod;
    return ans;
}
void px(ll*f,ll*g,int len){
    for(int i=0;i<len;++i)f[i]=f[i]*g[i]%mod;
}
void dao(ll*f,int n){
    for(int i=1;i<n;++i)f[i-1]=f[i]*i%mod;
    f[n-1]=0;
}
void jifen(ll*f,int n){
    for(int i=n;i;--i)f[i]=f[i-1]*inv[i]%mod;
    f[0]=0;
}
void NTT(ll*f,bool flag,int n){
	static int fl,t[M];
	int i,k,p,len;ll w,w1;
	if(n!=fl){
		for(i=0;i<n;++i)t[i]=t[i>>1]>>1|(i&1?n>>1:0);
		fl=n;
	}
    for(i=0;i<n;++i)if(i<t[i])swap(f[i],f[t[i]]);
    for(p=2;p<=n;p<<=1){
        len=p>>1;w1=pow(flag?G:invG,(mod-1)/p);
        for(k=0;k<n;k+=p){
            w=1;
            for(i=k;i<k+len;++i){
                ll t=f[i+len]*w%mod;
                if((f[i+len]=f[i]-t)<0)f[i+len]+=mod;
                if((f[i]=f[i]+t)>mod)f[i]-=mod;
                w=w*w1%mod;
            }
        }
    }
    if(flag)return;
    ll invn=pow(n);
    for(i=0;i<n;++i)f[i]=f[i]*invn%mod;
}
void times(ll* f, ll* g, int l1, int l2) {
    static ll sav[M];
    int n;
    for(n=1;n<=(l1+l2);n<<=1);
    cpy(sav,g,l2);clr(f+l1,n-l1);clr(sav+l2,n-l2);
    NTT(f,1,n);NTT(sav,1,n);
    px(f,sav,n);NTT(f,0,n);
    clr(sav,n);
}
void invp(ll*f,int m){
    static ll b1[M],b2[M],b3[M];
    int i,n,len;
    for(n=1;n<m;n<<=1);b1[0]=pow(f[0]);
    for(len=2;len<=n;len<<=1){
        for(i=0;i<(len>>1);++i)b3[i]=(b1[i]<<1)%mod;
        cpy(b2,f,len);
        NTT(b1,1,len<<1);px(b1,b1,len<<1);
        NTT(b2,1,len<<1);px(b1,b2,len<<1);
        NTT(b1,0,len<<1);clr(b1+len,len);
        for(i=0;i<len;++i)b1[i]=(b3[i]-b1[i]+mod)%mod;
    }
    cpy(f,b1,m);clr(b1,n+n);clr(b2,n+n);clr(b3,n+n);
}
void lnp(ll*f,int m){
    static ll g[M];int n;
    for(n=1;n<m;n<<=1);
    cpy(g,f,m);
    invp(g,m);dao(f,m);
    NTT(f,1,n<<1);NTT(g,1,n<<1);
    px(f,g,n<<1);NTT(f,0,n<<1);
    jifen(f,m-1);
    clr(g,n+n);
}
void exp(ll*f,int m){
    static ll b1[M],b2[M];int n,i,len;
    for(n=1;n<m;n<<=1);b1[0]=1;
    for(len=2;len<=n;len<<=1){
        cpy(b2,b1,len>>1);clr(b2+len/2,len/2);lnp(b2,len);
        for(i=0;i<len;++i)b2[i]=(f[i]-b2[i]+mod)%mod;
        b2[0]=(b2[0]+1)%mod;
        times(b1,b2,len/2,len);
    }
    cpy(f,b1,m);clr(b1,n+n);clr(b2,n+n);
}
void powp(ll*f,ll n,ll k){
    lnp(f,n);
    for(int i=0;i<n;++i)f[i]=f[i]*k%mod;
    exp(f,n);
}
signed main(void){
    char s;ll i,k=0;
    scanf("%lld%s",&n,s);//这里改成%c就会WA，很神奇吧。。。
    inv[1]=1;
    while(isdigit(s=getchar()))k=(k*10+(s^48))%mod;
    for(int i=2;i<M;++i)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    for(i=0;i<n;++i)scanf("%lld",f+i);
    powp(f,n,k);
    for(i=0;i<n;++i)printf("%lld ",f[i]);
}
```

---

## 作者：Convergent_Series (赞：3)

考虑把 $k$ 变成系数方便处理。

$$\begin{aligned}
B(x)&\equiv A(x)^k\\
\ln B(x)&\equiv k\ln A(x)\\
B(x)&\equiv e^{\normalsize k\ln A(x)}
\end{aligned}$$

$\because e^{\normalsize k\ln A(x)}=\displaystyle\sum_{i=0}^{\infty}\dfrac{k^i\ln^i A(x)}{i!}$

$\therefore k$ 可以对 $998244353$ 取模。

代码:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
#define bceil(n) (1<<(__lg(n-1)+1))
using namespace std;
int read(){
	int a=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') a=(a<<3)+(a<<1)+(ch^'0'),ch=getchar();
	return a;
} 
void write(int a){
	if(a>9) write(a/10); 
	putchar(a%10+'0');
}
const int MAXN=1e6+10,P=998244353,G=3,Gi=332748118;
int l,r[MAXN],inv[MAXN],sav[MAXN<<1];
ll qpow(ll a,ll b=P-2){
	if(a==1) return 1;
	ll ans=1;
	while(b){if(b&1) ans=ans*a%P;a=a*a%P;b>>=1;}
	return ans;
}
void tpre(int lim){
    if(l==lim) return;l=lim;
    for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?lim>>1:0);
}
void px(int *A,int *B,int n){for(int i=0;i<n;i++) A[i]=1ll*A[i]*B[i]%P;} 
void NTT(int *A,int lim,int type){
	tpre(lim);
	static ull f[MAXN<<1],w[MAXN];w[0]=1;
	for(int i=0;i<lim;i++) f[i]=(((ll)P<<5)+A[r[i]])%P;
	for(int mid=1;mid<lim;mid<<=1){
		ull Wn=qpow(type+1?G:Gi,(P-1)/(mid+mid));
		for(int i=1;i<mid;i++)w[i]=w[i-1]*Wn%P;
		for(int j=0;j<lim;j+=mid+mid){
			for(int k=0;k<mid;k++){
				int x=w[k]*f[j|mid|k]%P;
				f[j|mid|k]=f[j|k]+P-x;
				f[j|k]+=x;
			}   
		}if(mid==(1<<10)){for(int i=0;i<lim;i++) f[i]%=P;}
	}if(type-1){
		ull inv=qpow(lim);
		for(int i=0;i<lim;i++) A[i]=f[i]%P*inv%P;
	}else for(int i=0;i<lim;i++) A[i]=f[i]%P;
}
void mul(int *A,int *B,int la,int lb){//乘法 
	int lim=bceil(la+la);
	cpy(sav,B,lim);clr(sav+la,lim-la);
    NTT(A,lim,1);NTT(sav,lim,1);
    px(A,sav,lim);NTT(A,lim,-1);
    clr(A+lb,lim-lb);clr(sav,lim);
} 
void invp(int *A,int lim){//逆元 
	int n=bceil(lim);
	static int w[MAXN<<1],r[MAXN<<1];
	w[0]=qpow(A[0]);
	for (int ln=2;ln<=n;ln<<=1){
		for(int i=0;i<(ln>>1);i++) r[i]=w[i];
		cpy(sav,A,ln);NTT(sav,ln,1);NTT(r,ln,1);px(r,sav,ln);
		NTT(r,ln,-1);clr(r,ln>>1);cpy(sav,w,ln);NTT(sav,ln,1);
	    NTT(r,ln,1);px(r,sav,ln);NTT(r,ln,-1);
	    for(int i=ln>>1;i<ln;i++) w[i]=(w[i]*2ll-r[i]+P)%P;
	}cpy(A,w,lim);clr(sav,n);clr(w,n);clr(r,n);
}
void dao(int *A,int lim){//导数 
	for(int i=1;i<lim;i++) A[i-1]=1ll*A[i]*i%P;
	A[lim-1]=0;
}
void inv_init(int lim){
	inv[1]=1;
	for(int i=2;i<=lim;i++) inv[i]=1ll*inv[P%i]*(P-P/i)%P;
}
void jifen(int *A,int lim){//积分 
	for(int i=lim;i;i--) A[i]=1ll*A[i-1]*inv[i]%P;
	A[0]=0;
}
void lnp(int *A,int lim){//ln 
	static int w[MAXN<<1];
	cpy(w,A,lim);
	invp(w,lim);dao(A,lim);
	mul(A,w,lim,lim);
	jifen(A,lim-1);
	clr(w,lim);
}
void exp(int *A,int lim){//exp
	static int s[MAXN<<1],s2[MAXN<<1];
	int n=bceil(lim);
	s2[0]=1;
	for(int ln=2;ln<=n;ln<<=1){
		cpy(s,s2,ln>>1);lnp(s,ln);
		for(int i=0;i<ln;i++) s[i]=(A[i]-s[i]+P)%P;
		s[0]=(s[0]+1)%P;
		mul(s2,s,ln,ln);
	}cpy(A,s2,lim);clr(s,n);clr(s2,n);
}
void power(int *A,int lim,int k){
	lnp(A,lim);
	for(int i=0;i<lim;i++) A[i]=1ll*A[i]*k%P;
	exp(A,lim);
}
int n,k,a[MAXN],b[MAXN];
string str;
signed main(){
    n=read();cin>>str;int len=str.length();
    inv_init(n);
    for(int i=0;i<len;i++) k=((1ll*k*10%P)+str[i]-'0')%P;
    for(int i=0;i<n;i++) a[i]=read();
	power(a,n,k);
    for(int i=0;i<n;i++){write(a[i]);putchar(' ');} 
    return 0;
}
```

---

## 作者：WorldMachine (赞：2)

简单推导。
$$
\begin{aligned}
B(x)&\equiv[A(x)]^k&\pmod{x^n}\\
\ln B(x)&\equiv k\ln A(x)&\pmod{x^n}\\
B(x)&\equiv e^{k\ln A(x)}&\pmod{x^n}
\end{aligned}
$$
最重要的一点在于指数 $k$ 在 $a_0=1$ 时为何能直接对模数取模。

由于：
$$
e^{kF(x)}=\sum_{i=0}\dfrac{k^i[F(x)]^i}{i!}
$$
可以展开成一个多项式的形式，取模之后不变。
```cpp
poly pow(const poly &a, int n, int k) {
	poly b = ln(a, n);
	for (int i = 0; i < n; i++) b[i] = (ll)b[i] * k % mod;
	b = exp(b, n);
	return b;
}
```

---

## 作者：VenusM1nT (赞：2)

本文收录于：[多项式算法学习笔记](https://venusnero.github.io/2019/03/19/poly_algorithm_note/)。

这个好“简单”的……

前置芝士为 多项式 $\exp$ 和 多项式 $\ln$……

考虑对数函数的性质，即：$log_ab^k=klog_ab$，这个对多项式也适用。

那么我们知道，$\exp$ 其实就是 $e^x$，$\ln$ 其实就是 $log_ex$，那么……

要求 $G(x)$ 使得 $G(x)=F^k(x)$，两边取自然对数，得：

$$\ln G(x)=k\ln F(x)$$

所以我们把 $F(x)$ 求 $\ln$，把系数乘上 $k$，然后做一遍 $\exp$ 就得到了 $G(x)$。

~~（简不简单吖~）~~

```cpp
signed main()
{
    scanf("%lld %s",&n,s+1);
    int l=strlen(s+1);
    for(int i=1;i<=l;i++) k=((k<<3)+(k<<1)+(s[i]-48))%Mod;
    for(int i=0;i<n;i++) scanf("%lld",&F[i]);
    GetLn(F,G,n);
    for(int i=0;i<n;i++) G[i]=G[i]*k%Mod;
    memset(b,0,sizeof(b));
    GetExp(G,T,n);
    for(int i=0;i<n;i++) printf("%lld ",T[i]);
    return 0;
}
```

---

## 作者：Great_Influence (赞：2)

直接 [$Ln$](https://www.luogu.org/problemnew/show/P4725) 后系数乘 $k$ 再 [$Exp$](https://www.luogu.org/problemnew/show/P4726) 即可。 $k$ 可以直接膜 $mod$ 。

复杂度 $O(n\log n)$ 。

你也可以写一个快速幂，练习一下卡常。这里的 $k$ 需要膜 $mod-1$ 。

复杂度 $O(n\log n\log mod)$ 。

---

## 作者：Spasmodic (赞：1)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/happydef-blog/duo-xiang-shi-quan-jia-tong-xue-xi-bi-ji)

首先吐槽一波。。。多项式$\exp$都是黑的这题怎么紫的。。。

~~当然不排除分治NTT艹过去的可能，不过这种做法我们不讲~~

前置芝士：多项式$\ln$，多项式$\exp$

$$G\equiv F^k\pmod {x^n}$$
$$\ln G\equiv k\ln F\pmod {x^n}$$
$$G\equiv e^{k\ln F}\pmod {x^n}$$
over

复杂度$O(n\log n)$

代码：
```cpp
void getpow(ll*f,ll*g,ll len,ll k){
   getln(f,h,len);
   for(ll i=0;i<len;i++)h[i]=h[i]*k%P;
   getexp(h,g,len);
   clear(h);
}
```
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll; 
const ll N=100005*3;
ll n,k,f[N],g[N];
char s[100000]; 
namespace Poly{
	const ll P=998244353,G=3;
	ll lmt,rev[N],a[N],b[N],c[N],d[N],e[N],h[N];
	inline ll qpow(ll a,ll k){
		ll ret=1;
		while(k){
			if(k&1)ret=ret*a%P;
			a=(a*a)%P;
			k>>=1;
		}
		return ret%P;
	}
	inline void init(ll n){
		lmt=1;ll t=0;
		while(lmt<n)lmt<<=1,t++;
		for(ll i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(t-1);
	}
	inline void NTT(ll *A,ll lmt,ll tp){
		for(ll i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
		for(ll m=1;m<lmt;m<<=1)
			for(ll j=0,Wn=qpow(G,(P-1)/(m<<1));j<lmt;j+=m<<1)
				for(ll k=0,w=1,x,y;k<m;k++,w=w*Wn%P)
					x=A[j+k],y=w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
		if(tp==1)return;
		reverse(A+1,A+lmt);
		for(ll i=0,inv=qpow(lmt,P-2);i<=lmt;i++)A[i]=A[i]*inv%P;
	} 
	inline void mul(ll *f,ll *g,ll len){
		init(len);
		NTT(f,lmt,1);NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)f[i]=(f[i]*g[i])%P;
		NTT(f,lmt,-1);
	} 
	void getinv(ll*f,ll*g,ll len){
		if(len==1){g[0]=qpow(f[0],P-2);return;}
		getinv(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<len;i++)c[i]=f[i];
		for(ll i=len;i<lmt;i++)c[i]=0;
		NTT(c,lmt,1),NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)g[i]=(2LL-g[i]*c[i]%P+P)%P*g[i]%P;
		NTT(g,lmt,-1);
		for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	void getdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i-1]=i*f[i]%P;
		g[len-1]=0;
	}
	void getinvdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i]=f[i-1]*qpow(i,P-2)%P;
		g[0]=0;
	}
	void getln(ll*f,ll*g,ll len){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		getdev(f,a,len);
		getinv(f,b,len);
		mul(a,b,len<<1);
		getinvdev(a,g,len);
	}
	void getexp(ll*f,ll*g,ll len){
		if(len==1){g[0]=1;return;}
		getexp(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<(len<<1);i++)d[i]=e[i]=0;
		getln(g,d,len);
		for(ll i=0;i<len;i++)e[i]=f[i];
	    NTT(g,lmt,1),NTT(d,lmt,1),NTT(e,lmt,1);
    	for(ll i=0;i<lmt;i++)g[i]=(1-d[i]+e[i]+P)*g[i]%P;
    	NTT(g,lmt,-1);
    	for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	void getpow(ll*f,ll*g,ll len,ll k){
		getln(f,h,n);
		for(ll i=0;i<len;i++)h[i]=h[i]*k%P;
		getexp(h,g,n);
	}
}
using Poly::P;
using Poly::getpow;
int main(){
	scanf("%lld%s",&n,s+1);
	for(ll i=1,l=strlen(s+1);i<=l;i++)k=(k*10+s[i]-'0')%P;
	for(ll i=0;i<n;i++)scanf("%lld",&f[i]);
	getpow(f,g,n,k);
	for(ll i=0;i<n;i++)printf("%lld ",g[i]);
	return 0;
}
```
（这个常数似乎不是很大？在[Karry的selftest](https://www.luogu.com.cn/problem/U65286)里无需改动就可以跑到第二页。（雾

---

## 作者：Gauss0320 (赞：1)

一开始本来想封装多项式乘法，按照普通快速幂的思路去做的
$$A^k=\left(A^{\left\lfloor\frac{k}{2}\right\rfloor}\right)^2A^{\left[(2,n)=1\right]}$$
但$\log k$还是太大，只好考虑将$k$转化为多项式的系数了。

首先
$$B(x)=A^k(x)$$
两边同时取对数
$$\ln B(x)=\ln A^k(x)$$
由对数函数的性质，我们有
$$\ln B(x)=k\ln A(x)$$
转化一下，就成板子题了
$$B(x)=e^{k\ln A(x)}=\exp\left(k\ln A(x)\right)$$
由于$k$为系数，边输入边取模
```cpp
#include <cstdio>
#include <iostream>
#include <csstring>
#include <algorithm>
typedef long long ll;
const int P = 998244353, N = 262145, g3 = (P + 1) / 3;
using namespace std;
int n, k, a[N], A[N], G[N];

int pow(int a,int b)
{
	int r = 1;
	while(b)
	{
		if(b & 1) r = (ll)r * a % P;
		a = (ll)a * a % P;
		b >>= 1;
	}
	return r;
}
namespace poly
{
    int rev[N];
	void NTT(int *A, int n, int inv) 
	{
		for(int i = 0; i < n; ++i)
			if(i < rev[i]) swap(A[i], A[rev[i]]);
		for(int mid = 1; mid < n; mid <<= 1) 
		{
			int tmp = pow(inv == 1 ? 3 : g3, (P - 1) / (mid << 1));
			for(int j = 0; j < n; j += (mid << 1)) 
			{
				int omega = 1;
				for(int k = 0; k < mid; ++k, omega = (ll)omega * tmp % P) 
				{
					int x = A[j + k], y = (ll)omega * A[j + k + mid] % P;
					A[j + k] = (x + y) % P;
					A[j + k + mid] = (ll)(x - y + P) % P;
				}
			}
		}
		if(inv == 1) return;
		int invn = pow(n, P - 2);
		for(int i = 0; i < n; ++i)
			A[i] = (ll)A[i] * invn % P;
	}
    void Inv(int *a, int *b, int n) 
	{
		static int B[N], A[N];
		b[0] = pow(a[0], P - 2);
		int len, lim;
		for(len = 1; len < (n << 1); len <<= 1)
		{
			lim = len << 1;
			for(int i = 0; i < len; i++)
				A[i] = a[i], B[i] = b[i];
			for(int i = 0; i < lim; i++)
				rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? len : 0);
			NTT(A, lim, 1), NTT(B, lim, 1);
			for(int i = 0; i < lim; i++)
				b[i] = ((2LL - 1LL * A[i] * B[i] % P) * B[i] % P + P) % P;
			NTT(b, lim, -1);
			for(int i = len; i < lim; i++)
				b[i] = 0;
		}
		for(int i = 0; i < len; i++) 
			A[i] = B[i] = 0;
		for(int i = n; i < len; i++)
			b[i] = 0;
	}
    void derivative(int *a, int *b, int n)
	{
        b[n - 1] = 0;
        for(int i = 1; i < n; ++i)
        	b[i - 1] = (ll)a[i] * i % P;
    }
    void inter(int *a, int *b, int n)
	{
        *b = 0;
        for(int i = n - 1; i >= 0; --i)
			b[i + 1] = a[i] * (ll)pow(i + 1, P - 2) % P;
    }
    void ln(int *a, int *b, int n)
	{
        static int F[N];
        derivative(a, F, n);
		Inv(a, b, n);
        int lim = 1;
        while(lim < (n << 1)) lim <<= 1;
        for(int i = 1; i < lim; i++)
        	rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0);
        for(int i = n; i < lim; ++i)
			b[i] = F[i] = 0;
        NTT(F, lim, 1), NTT(b, lim, 1);
        for(int i = 0; i < lim; ++i)
			F[i] = (ll)b[i] * F[i] % P;
        NTT(F, lim, 0);
        inter(F, b, n);
        for(int i = n; i < lim; ++i)
			b[i] = 0;
    }
    void exp(int*a, int*F, int n)
	{
        if(n == 1)
			*F = 1;
		else
		{
            exp(a, F, n + 1 >> 1);
            static int F0[N], A[N];
            for(int i = 0; i <= (n << 1); ++i)
				F0[i] = 0, A[i] = a[i];
            ln(F, F0, n);
            int lim = 1;
            while(lim < (n << 1)) lim <<= 1;
            for(int i = 1; i < lim; i++)
            	rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0);
            for(int i = n; i < lim; ++i)
				A[i] = 0;
            NTT(A, lim, 1), NTT(F0, lim, 1), NTT(F, lim, 1);
            for(int i = 0; i < lim; ++i)
				F[i] = F[i] * (A[i] + 1LL - F0[i] + P) % P;
            NTT(F, lim, 0);
            for(int i = n; i < lim; ++i)
				F[i] = 0;
        }
    }
}
using namespace poly;
int main()
{
    scanf("%d", &n);
    int c=getchar();while(isspace(c))c=getchar();
    for(;isdigit(c);c=getchar())k=(k*10LL+(c^'0'))%P;
    for(int i = 0; i < n; ++i)	
		scanf("%d", a + i);
    ln(a, A, n);
    for(int i = 0; i < n; ++i)
		A[i] = A[i] * (ll)k % P;
    for(int i = 0; i < n; ++i)
		a[i] = 0;
    exp(A, a, n);
    for(int i = 0; i < n; ++i)
		printf("%d ", a[i]);
    return 0;
}
```


---

## 作者：SSerxhs (赞：1)

前置芝士：多项式exp、多项式ln

推式子
$$B(x)\equiv A^m(x)(\mathrm{mod\:}x^n)$$
同时取对数
$$lnB(x)\equiv mlnA(x)(\mathrm{mod\:}x^n)$$
所以对A(x)取ln，系数乘上m，再exp就可以了。由于这题保证a0==1，所以不需要考虑取ln时的特殊情况。特殊情况可以参考https://www.luogu.org/problemnew/show/U63679

upd:已经为P5273

详见代码，特殊处理的是ksm1，暴力是ksm2，这题只需要ksm3
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <stdlib.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pa;
const int N=2.7e5,p=998244353;
int r[N],ig[N],yg[N],invf[N],sqrtf[N],sqrtg[N],cdqf[N],cdqg[N],lnf[N],expf[N],expg[N];
int ksmf[N],inv[N],f[N],g[N],y[N];
int n,m,i,j,l,limit,biglimit,c,w;
pa ys,yys;
inline int sj()
{
    return rand()<<15|rand();
}
pa operator *(pa x,pa y)
{
    ys.first=((ll)x.first*y.first+(ll)x.second*y.second%p*w)%p;
    ys.second=((ll)x.first*y.second+(ll)x.second*y.first)%p;
    return ys;
}
inline void dbug(int *a,int n)
{
    for (int i=0;i<n;i++) printf("%d ",a[i]);puts("");
}
inline void read(int &x)
{
    c=getchar();
    while ((c<48)||(c>57)) c=getchar();
    x=c^48;c=getchar();
    while ((c>=48)&&(c<=57))
    {
        x=x*10+(c^48);
        c=getchar();
    }
}
inline void readd(int &x)
{
    c=getchar();
    while ((c<48)||(c>57)) c=getchar();
    x=c^48;c=getchar();
    while ((c>=48)&&(c<=57))
    {
        x=((ll)x*10+(c^48))%p;
        c=getchar();
    }
}
inline int ksm(int x,int y)
{
    int r=1;
    while (y)
    {
        if (y&1) r=(ll)r*x%p;
        x=(ll)x*x%p;
        y>>=1;
    }
    return r;
}
inline pa ksm(pa x,int y)
{
    yys.first=1;yys.second=0;
    while (y)
    {
        if (y&1) yys=yys*x;
        x=x*x;
        y>>=1;
    }
    return yys;
}
inline int mosqrt(int x)
{
    pa a;
    int y=rand()%p;
    while (ksm(w=((ll)y*y%p-x+p)%p,p-1>>1)<=1) y=rand()%p;
    if (w<0) w+=p;
    a.first=y;a.second=1;
    a=ksm(a,p+1>>1);
    return min(a.first,p-a.first);
}
inline void ycl(int l,int limit)
{
    for (int i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;
}
inline void gg(int limit)
{
    int i;
    ig[limit]=ksm(yg[limit]=ksm(3,(p-1)/limit),p-2);
    for (i=limit>>1;i;i>>=1)
    {
        yg[i]=(ll)yg[i<<1]*yg[i<<1]%p;
        ig[i]=(ll)ig[i<<1]*ig[i<<1]%p;
    }
    inv[1]=1;
    for (i=2;i<limit;i++) inv[i]=p-(ll)p/i*inv[p%i]%p;
}
inline void reverse(int limit,int *f)
{
    int lim=limit>>1;
    for (i=0;i<lim;i++) swap(f[i],f[limit-i-1]);
}
inline void dao(int *a,int n)
{
    for (i=1;i<n;i++) a[i-1]=(ll)a[i]*i%p;a[n-1]=0;
}
inline void ji(int *a,int n)
{
    for (i=n-1;~i;i--) a[i+1]=(ll)a[i]*inv[i+1]%p;
    a[0]=0;
}
void dft(int *a,int xs,int limit)
{
    int i,j,k,l,w,wn,b,c;
    for (i=1;i<limit;i++) if (i<r[i]) swap(a[i],a[r[i]]);
    for (i=1;i<limit;i=l)
    {
        l=i<<1;
        if (xs) wn=ig[l]; else wn=yg[l];
        for (j=0;j<limit;j+=l)
        {
            w=1;
            for (k=0;k<i;k++,w=(ll)w*wn%p)
            {
                b=a[j|k];c=(ll)w*a[j|k|i]%p;
                a[j|k]=(b+c)%p;
                a[j|k|i]=(b-c+p)%p;
            }
        }
    }
    if (xs)
    {
        limit=ksm(limit,p-2);
        for (i=0;i<xs;i++) a[i]=(ll)a[i]*limit%p;
    }
}
void polymultiply(int *f,int *g,int limit)
{
    int i;
    dft(f,0,limit<<1);dft(g,0,limit<<1); 
    for (i=0;i<limit<<1;i++) f[i]=(ll)f[i]*g[i]%p;
    dft(f,limit,limit<<1);
}
void polyinv(int *f,int *g,int biglim)
{
    int i,j,l=1,limit;
    memset(g,0,biglim<<3);
    memset(invf,0,biglim<<3);
    g[0]=ksm(f[0],p-2);
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        memcpy(invf,f,limit<<1);
        for (j=1;j<limit;j++) r[j]=r[j>>1]>>1|(j&1)<<l;
        dft(invf,0,limit);dft(g,0,limit);
        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(p+2-(ll)g[j]*invf[j]%p)%p;
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
void polysqrt(int *f,int *g,int biglim)//不动f
{
    memset(sqrtf,0,biglim<<3);
    memset(sqrtg,0,biglim<<3);
    memset(g,0,biglim<<3);
    int i,j,l=1,limit;
    g[0]=mosqrt(f[0]);
    if ((ll)g[0]*g[0]%p!=f[0]) while (1);
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        polyinv(g,sqrtg,i);
        memcpy(sqrtf,f,limit<<1);
        dft(sqrtf,0,limit);dft(sqrtg,0,limit);dft(g,0,limit);
        for (j=0;j<limit;j++)
        {
            g[j]=(ll)sqrtg[j]*((ll)g[j]*g[j]%p+sqrtf[j])%p;
            if (g[j]&1) g[j]=g[j]+p>>1; else g[j]>>=1;
        }
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
/*void polycdq(int l,int r,int *f,int *g)
{
    if (l==r) return;
    int mid=l+r>>1;
    polycdq(l,mid,f,g);
    int i,limit,li,siz=r-l;
    limit=1;li=-1;
    while (limit<=siz)
    {
        limit<<=1;++li;
    }
    for (i=l;i<=mid;i++) cdqf[i-l]=f[i];
    for (i=mid-l+1;i<lim;i++) cdqf[i]=0;
    for (i=1;i<=r-l;i++) cdqg[i]=g[i];G[0]=0;
    for (i=r-l+1;i<lim;i++) cdqg[i]=0;
    polymultiply(cdqf,cdqg,li,limit);
    for (i=mid+1;i<=r;i++)
    {
        f[i]+=cdqf[i-l];
        if (f[i]>=p) f[i]-=p;
    }
    polycdq(mid+1,r,f,g);
}*/
void polydivide(int *f,int *g,int *q,int *r,int limit)
{

}
void polyln(int *f,int *g,int biglim)
{
    int i,limit=biglim<<1;
    memcpy(lnf,f,biglim<<2);
    memset(lnf+biglim,0,biglim<<2);
    polyinv(f,g,biglim);
    dao(lnf,biglim);
    dft(lnf,0,limit);dft(g,0,limit);
    for (i=0;i<limit;i++) g[i]=(ll)g[i]*lnf[i]%p;
    dft(g,biglim,limit);
    memset(g+biglim,0,biglim<<2);
    ji(g,biglim);
}
void polyexp(int *f,int *g,int biglim)
{
    memset(g,0,biglim<<3);
    memset(expf,0,biglim<<3);
    memset(expg,0,biglim<<3);
    g[0]=1;
    int i,j,l=1,limit;
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        memcpy(expf,f,limit<<1);
        polyln(g,expg,i);
        dft(expf,0,limit);dft(g,0,limit);dft(expg,0,limit);
        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(1+expf[j]-expg[j]+p)%p;
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
void polyksm1(int *f,int *g,int biglim,int cs)
{
    if (cs==0)
    {
        g[0]=1;
        return;
    }
    int i,j,k=1,wy=0;
    if (f[0]==0)
    {
        for (i=1;i<biglim;i++) if (f[i]) break;
        for (j=0;j<biglim-i;j++) f[j]=f[j+i];
        memset(f+biglim-i,0,i<<2);
        if ((ll)i*cs>=biglim) return;
        wy=i*cs;
    }
    if (f[0]>1)
    {
        k=ksm(f[0],p-2);
        for (i=1;i<biglim;i++) f[i]=(ll)f[i]*k%p;
        k=ksm(f[0],cs);f[0]=1;
    }
    polyln(f,ksmf,biglim);
    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;
    polyexp(ksmf,g,biglim);
    if (k!=1)
    {
        for (i=0;i<biglim;i++) g[i]=(ll)g[i]*k%p;
    }
    if (wy)
    {
        for (i=biglim-1;i>=wy;i--) g[i]=g[i-wy];
        memset(g,0,wy<<2);  
    }
}
void polyksm2(int *f,int *g,int biglim,int cs)
{
    int limit=1,i,l=-1;
    while (limit<=biglim)
    {
        limit<<=1;++l;
    }
    for (i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;g[0]=1;
    while (cs)
    {
        if (cs&1)
        {
            memcpy(ksmf,f,biglim<<2);
            memset(ksmf+biglim,0,biglim<<2);
            polymultiply(g,ksmf,biglim);
            memset(g+biglim,0,biglim<<2);
        }
        dft(f,0,limit);
        for (i=0;i<limit;i++) f[i]=(ll)f[i]*f[i]%p;
        dft(f,biglim,limit);
        memset(f+biglim,0,biglim<<2);
        cs>>=1;
    }
}
void polyksm3(int *f,int *g,int biglim,int cs)
{
    int i;
    memset(ksmf,0,biglim<<3);
    memset(g,0,biglim<<3);
    polyln(f,ksmf,biglim);
    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;
    polyexp(ksmf,g,biglim);
}
int main()
{
    read(n);readd(m);
    limit=1;
    while (limit<n) limit<<=1;
    for (i=0;i<n;i++) read(f[i]);gg(limit<<1);
    polyksm1(f,g,limit,m);
    for (i=0;i<n;i++) printf("%d ",g[i]);
}
```


---

## 作者：Booksnow (赞：0)

# 多项式快速幂

## 题目大意

给定一个 $n-1$ 次的多项式 $A(x)$ ，求一个在 $mod x^n$ 意义下的多项式 $B(x)$ ，使得 $B(x) \equiv A^k(x) (mod x^n)$ 。

多项式的系数在 $mod$ $998244353$ 的意义下进行运算。

## 分析

### 思路一：倍增

这题既然叫快速幂，那么和我们正常的快速幂肯定是有某种关联的，事实上他们就是完全一样的。

我们平时的快速幂是怎么做的？

```cpp
inline int power(int x,int k){
    int res=1;
    while(k){
        if(k&1) res=res*x%MOD;
        k>>=1,x=x*x%MOD;
    }
    return res;
}
```
其实多项式快速幂就是在这个的基础上把乘法换成多项式的 $NTT$ 就行了，这里就不加赘述。

这种做法比较简单，也很容易理解，唯一需要注意的地方就是答案数组的**零次项数**需要初始化为 $1$ 。

然后就是这么做好像有点**慢**，单次卷积的时间复杂度为 $O(nlog_2n)$ ，那显然一个快速幂多一个 $log$ 时间复杂度就是 $O(nlog^2_2n)$ 。

到此这种做法就结束了，但是我不想把代码贴出来~~我没有打这种做法的代码~~，那就贴上 $NTT$ 的吧，只需要套一下就行了。


```cpp
inline void NTT(int *P,int flag)
{
    for(register int i=0;i<l;i++) if(i<r[i]) swap(P[i],P[r[i]]);
    for(register int i=1;i<l;i<<=1){
        int W=power(3,(MOD-1)/(i<<1));
        if(flag<0) W=power(W,MOD-2);
        for(register int j=0,p=i<<1;j<l;j+=p)
            for(register int k=0,w=1;k<i;k++,w=1ll*w*W%MOD){
                int x=P[j+k],y=1ll*P[j+k+i]*w%MOD;
                P[j+k]=(x+y)%MOD;P[j+k+i]=((x-y)%MOD+MOD)%MOD;
            }
    }
    if(flag<0) for(register int i=0,t=power(l,MOD-2);i<l;i++) P[i]=1ll*P[i]*t%MOD;
}
```

### 思路二：

上面也说到了，倍增是一种比较慢的做法，接下来我们可以尝试进行一些简单的**数学推导**。

对原式两边同时取**对数**，有：

$$ ln f(x)\equiv k \times ln g(x) $$

这个式子似曾相识？

没错，我们完全可以用 [多项式$exp$](https://www.luogu.com.cn/problem/P4726) 来求解。

也就是(注：下面 $exp()$ 的意思就是把括号内多项式按照上面链接的那个题目做一遍即可，不会的同学可以先去看看):

$$ f(x)\equiv exp(k\times ln g(x)) $$

那道这里这道题其实也就做完了，时间复杂度会比上一个优秀一点，为 $O(log_2n)$ 。

## 思路二CODE

```cpp
#include <bits/stdc++.h>
#define int long long
#define mul(x,y) (1ll*x*y%MOD)
#define add(x,y) (x+y>=MOD?x+y-MOD:x+y)
#define dec(x,y) (x-y<0?x-y+MOD:x-y)
using namespace std;
const int N=1e6+10,MOD=998244353;
int n,m,k;
int l,Time;
int r[N],A[N],B[N],C[N],D[N],F[N],G[N],O[N],f[N],g[N],inv[N];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w*=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s*10%MOD+ch-'0'+MOD)%MOD,ch=getchar();
	return s*w;
}
int a[N];
inline int power(int x,int k){
    int res=1;
    while(k){
        if(k&1) res=mul(res,x);
        k>>=1,x=mul(x,x);
    }
    return res;
}
inline void Deri(int *A,int *B,int len) { for(register int i=1;i<len;i++) B[i-1]=1ll*i*A[i]%MOD;B[len-1]=0; }
inline void Inte(int *A,int *B,int len) { for(register int i=1;i<len;i++) B[i]=1ll*A[i-1]*power(i,MOD-2)%MOD;B[0]=0; }
inline void NTT(int *A,int flag,int len){
    int limit=1,l=0;
    while(limit<len) limit<<=1,++l;
    for(register int i=0;i<limit;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    for(register int i=0;i<limit;i++) if(i<r[i]) swap(A[i],A[r[i]]);
    for(register int mid=1;mid<limit;mid<<=1){
        int R=mid<<1,Wn=power(3,(MOD-1)/R);O[0]=1;
        for(register int j=1;j<mid;++j) O[j]=mul(O[j-1],Wn);
        for(register int j=0;j<limit;j+=R){
            for(register int k=0;k<mid;++k){
                int x=A[j+k],y=mul(O[k],A[j+k+mid]);
                A[j+k]=add(x,y),A[j+k+mid]=dec(x,y);
            }
        }
    }
    if(flag==-1) { reverse(A+1,A+limit); for(register int i=0,invl=inv[limit];i<limit;i++) A[i]=mul(A[i],invl); }
}
inline void Inv(int *a,int *b,int len){
    if(len==1) return (void)(b[0]=inv[a[0]]);
    Inv(a,b,len>>1);
    for(register int i=0;i<len;i++) C[i]=a[i],D[i]=b[i];
    NTT(C,1,len<<1),NTT(D,1,len<<1);
    for(register int i=0,l=(len<<1);i<l;i++) C[i]=mul(mul(C[i],D[i]),D[i]);
    NTT(C,-1,len<<1);
    for(register int i=0;i<len;i++) b[i]=dec(add(b[i],b[i]),C[i]);
    for(register int i=0,l=(len<<1);i<l;i++) C[i]=D[i]=0;
}
inline void Ln(int *a,int *b,int len){
    Deri(a,A,len),Inv(a,B,len);
    NTT(A,1,len<<1),NTT(B,1,len<<1);
    for(register int i=0,l=len<<1;i<l;i++) A[i]=mul(A[i],B[i]);
    NTT(A,-1,len<<1),Inte(A,b,len<<1);
    for(register int i=0,l=len<<1;i<l;i++) A[i]=B[i]=0;
}
inline void Exp(int *a,int *b,int len){
    if(len==1) return (void)(b[0]=1);
    Exp(a,b,len>>1),Ln(b,F,len);
    F[0]=dec(a[0]+1,F[0]);
    for(register int i=1;i<len;i++) F[i]=dec(a[i],F[i]);
    NTT(F,1,len<<1),NTT(b,1,len<<1);
    for(register int i=0,l=len<<1;i<l;i++) b[i]=mul(b[i],F[i]);
    NTT(b,-1,len<<1);
    for(register int i=len,l=(len<<1);i<l;i++) b[i]=F[i]=0;
}
inline void Deri1(int *A,int *B,int len) { for(register int i=1;i<len;i++) B[i-1]=1ll*i*A[i]%MOD;B[len-1]=0; }
inline void Inte1(int *A,int *B,int len) { for(register int i=1;i<len;i++) B[i]=1ll*A[i-1]*power(i,MOD-2)%MOD;B[0]=0; }
inline void ntt(int *P,int flag)
{
    for(register int i=0;i<l;i++) if(i<r[i]) swap(P[i],P[r[i]]);
    for(register int i=1;i<l;i<<=1){
        int W=power(3,(MOD-1)/(i<<1));
        if(flag<0) W=power(W,MOD-2);
        for(register int j=0,p=i<<1;j<l;j+=p)
            for(register int k=0,w=1;k<i;k++,w=1ll*w*W%MOD){
                int x=P[j+k],y=1ll*P[j+k+i]*w%MOD;
                P[j+k]=(x+y)%MOD;P[j+k+i]=((x-y)%MOD+MOD)%MOD;
            }
    }
    if(flag<0) for(register int i=0,t=power(l,MOD-2);i<l;i++) P[i]=1ll*P[i]*t%MOD;
}
inline void Reverse(int *f,int *g,int n)
{
    if(n==1) { g[0]=power(f[0],MOD-2); return; }
    Reverse(f,g,n>>1);
    for(l=1,Time=0;l<=n;l<<=1) Time++;Time--;
    for(register int i=0;i<l;i++) r[i]=(r[i>>1]>>1)|((i&1)<<Time);
    for(register int i=0;i<n;i++) C[i]=f[i],D[i]=g[i];
    for(register int i=n;i<l;i++) C[i]=D[i]=0; ntt(C,1);ntt(D,1);
    for(register int i=0;i<l;i++) C[i]=1ll*C[i]*D[i]%MOD*D[i]%MOD; ntt(C,-1);
    for(register int i=0;i<n;i++) g[i]=((2ll*g[i]%MOD-C[i])%MOD+MOD)%MOD;
}
inline void Solve(int *f,int *g,int n)
{
    Deri1(f,A,n); Reverse(f,B,n);
    for(l=1,Time=0;l<=n;l<<=1) Time++;
    Time--;
    for(register int i=0;i<l;i++) r[i]=(r[i>>1]>>1)|((i&1)<<Time);
    ntt(A,1),ntt(B,1);
    for(register int i=0;i<l;i++) A[i]=1ll*A[i]*B[i]%MOD;
    ntt(A,-1);
    Inte1(A,g,n);
}
inline void clear()
{
	memset(A,0,sizeof(A));
	memset(B,0,sizeof(B));
	memset(C,0,sizeof(A));
	memset(D,0,sizeof(B));
	memset(F,0,sizeof(A));
	memset(G,0,sizeof(B));
	memset(r,0,sizeof(A));
}
signed main()
{
	n=read(),k=read();
	for(register int i=0;i<n;i++) F[i]=read();
	for(m=1;m<=n;m<<=1);
	Solve(F,G,m);
	for(register int i=0;i<n;i++) 
		f[i]=G[i]*k%MOD;
	clear();
	for(register int i=0,l=m<<1;i<=l;i++) inv[i]=power(i,MOD-2);
	Exp(f,g,m);
	for(register int i=0;i<n;i++) printf("%lld ",g[i]);
	return 0;
}
```


---

## 作者：Vocalise (赞：0)

考虑多项式 $\ln$ 和 $\exp$ 运算奇妙的复杂度，于是显然可以运用以上两者解决这道题。

***`cmath` 库中的 `pow` 函数就是使用了这种方法实现的。***

于是有十分简单的式子：

$$G(x)\equiv F^k(x)\pmod{x^n}$$

$$\ln G(x)\equiv k\ln F(x)\pmod{x^n}$$

同时取 $\exp$ 得

$$G(x)\equiv e^{k\ln F(x)}\pmod{x^n}$$

于是考虑搬来 $\ln$ 和 $\exp$ 的板子，取完 $\ln$ 后乘 $k$ 再 $\exp$ 于是就做完了。

注意清零。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

typedef long long ll;
const int p = 998244353;
const int MAXN = 400001;

inline ll read() {
    ll x = 0,f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = (x * 10 + ch - 48) % p, ch = getchar(); while(ch >= '0' && ch <= '9');
    return (x * f % p + p) % p;
}

int n,k,r[MAXN];
ll f[MAXN],g[MAXN],inv[MAXN];

ll fastpow(ll a,int b) {
    ll res = 1; a %= p;
    while(b) {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

void NTT(ll *a,int N) {
    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);
    for(int n = 2,m = 1;n <= N;m = n, n <<= 1) {
        ll g1 = fastpow(3,(p - 1) / n);
        for(int l = 0;l < N;l += n) {
            ll g = 1,t1,t2;
            for(int i = l;i < l + m;i++) {
                t1 = a[i], t2 = g * a[i + m] % p;
                a[i] = (t1 + t2) % p;
                a[i + m] = (t1 - t2 + p) % p;
                g = g * g1 % p;
            }
        }
    }
    return;
}

void INTT(ll *a,int N) {
    NTT(a,N);
    std::reverse(a + 1,a + N);
    int invN = fastpow(N,p - 2);
    for(int i = 0;i < N;i++) a[i] = a[i] * invN % p;
}

void Dervt(ll *a,ll *b,int n) {
    for(int i = 1;i < n;i++) b[i - 1] = a[i] * i % p;
    b[n - 1] = 0;
    return;
}

void Integ(ll *a,ll *b,int n) {
    for(int i = 1;i < n;i++) b[i] = a[i - 1] * inv[i] % p;
    b[0] =  0;
    return;
}

ll a1[MAXN];

void Inv(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = fastpow(a[0],p - 2));
    Inv(a,b,(n + 1) >> 1);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) a1[i] = a[i];
    for(int i = n;i < N;i++) a1[i] = 0;
    NTT(a1,N); NTT(b,N);
    for(int i = 0;i < N;i++) b[i] = ((b[i] << 1) % p + p - a1[i] * b[i] % p * b[i] % p) % p;
    INTT(b,N);
    for(int i = n;i < N;i++) b[i] = 0;
    return;
}

ll f1[MAXN],f2[MAXN];

void Ln(ll *f,ll *g,int n) {
    memset(f1,0,sizeof(f1)); memset(f2,0,sizeof(f2));
    Dervt(f,f1,n); Inv(f,f2,n);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    NTT(f1,N); NTT(f2,N);
    for(int i = 0;i < N;i++) f1[i] = f1[i] * f2[i] % p;
    INTT(f1,N); Integ(f1,g,n);
    return;
}

ll g1[MAXN];

void Exp(ll *f,ll *g,int n) {
    if(n == 1) return void(g[0] = 1);
    Exp(f,g,(n + 1) >> 1);
    Ln(g,g1,n);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) f1[i] = f[i];
    for(int i = n;i < N;i++) g1[i] = f1[i] = 0;
    for(int i = 0;i < N;i++) f1[i] = ((f1[i] - g1[i]) % p + p) % p;
    f1[0] = (f1[0] + 1) % p;
    NTT(f1,N); NTT(g,N);
    for(int i = 0;i < N;i++) g[i] = f1[i] * g[i] % p;
    INTT(g,N);
    for(int i = n;i < N;i++) g[i] = 0;
    return;
}

ll lnf[MAXN];

void Pow(ll *f,ll *g,int n,int k) {
    Ln(f,lnf,n);
    for(int i = 0;i < n;i++) lnf[i] = lnf[i] * k % p;
    Exp(lnf,g,n);
    return;
}

int main() {
    n = read(), k = read();
    for(int i = 0;i < n;i++) f[i] = read();
    inv[1] = 1;
    for(int i = 2;i < MAXN;i++) inv[i] = inv[p % i] * (p - p / i) % p;
    Pow(f,g,n,k);
    for(int i = 0;i < n;i++) std::printf("%lld ",g[i]);
    return 0;
}

```

---

## 作者：Illusory_dimes (赞：0)

### 题目大意
给定 $n-1$ 次多项式 $g(x)$ ，求多项式 $f(x)$ 满足：

$f(x)\equiv g^k(x)$ $(mod$ $x^n)$

系数对 $998244353$ 取模。

数据范围 $1\leq n\leq 10^5$ ， $1\leq k\leq 10^{10^5}$ 。

### 前置芝士：
多项式 $\ln$ ，多项式 $\exp$ ，~~非常入门的~~求导，积分和恶俗的牛顿迭代。

第一个不会出门左拐，最后两个的话，这里只要：

求导公式 $\mathrm{d}$ $x^{a}=ax^{a-1}$ 。

求导法则 $\mathrm{d}$ $f[g(x)]=f^{'}[g(x)]\cdot g^{'}(x)$ 。

积分公式 $\int x^a=\frac{1}{a+1}x^{a+1}$ 。

牛顿迭代的话，珂以看看[我的文章](https://www.luogu.com.cn/blog/ngzzgzz/yi-ge-niu-dun-die-dai-hao-xiang-bi-jiao-neng-dong-di-li-xie)（虽然不咋地。。），大概了解一下原理就好

### solution
对于多项式刚刚杠到这题的我们来说， $k$ 次幂实在有点陌生，但。。。

算了看式子吧，

$f(x)\equiv g^k(x)$ $(mod$ $x^n)$

众所周知“甩脑壳公式”：

$\ln{g^n(x)}=n\cdot\ln{g(x)}$

再看到原式，有那么一部分相同，于是珂以类比，我们将原式两边同时取 $\ln$ ，得到：

$\ln{f(x)}\equiv k\cdot\ln{g(x)}$ $(mod$ $x^n)$

注意上式 $k$ 是作为一个系数存在的，所以根据题意，在计算的时候 $k$ 是可以直接对模数取模。~~所以只要数组存的下，再大都不慌~~

因此，用求 $\ln$ 的做法就可以得到左边的 $\ln{f(x)}$ ,再对其计算 $\exp$ 即可。

（注：由于 $k$ 过大，需要边读入边取模）

~~（当然你要取完膜后直接倍增我也没办法）~~

时间复杂度 $O(n\log_{2}{n})$ 。

人傻常熟大 wtcl 。。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10;
typedef ll arr[N];
const int mod=998244353;
const int inv3=332748118;
int n,k,inv,lim=1,fre,id[N];
arr f,g,h,ans,tmp,ln;
inline ll inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline ll dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline ll mul(ll x,ll y){return 1ll*x*y%mod;}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=(1ll*tmp*a)%mod;
		b>>=1,a=(1ll*a*a)%mod;
	}
	return tmp;
}
inline void Never_Tell_TLE(ll* NTT,int sign)
{
	for(int i=0;i<=lim;++i)if(i<id[i])
	{
		ll NTt=NTT[i];
		NTT[i]=NTT[id[i]];
		NTT[id[i]]=NTt;
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		int Unit_root;
		if(sign==1)Unit_root=ksm(3,(mod-1)/(mid<<1));
		else Unit_root=ksm(inv3,(mod-1)/(mid<<1));
		for(int R=mid<<1,r=0;r<lim;r+=R)
		{
			int pw=1;
			for(int l=0;l<mid;++l,pw=(1ll*pw*Unit_root)%mod)
			{
				int butt=NTT[l+r],rfly=(1ll*pw*NTT[l+r+mid])%mod;
				NTT[l+r]=inc(butt,rfly);
				NTT[l+r+mid]=dec(butt,rfly);
			}
		}
	}
	if(sign==-1)
	{
		int inv_lim=ksm(lim,mod-2);
		for(int i=0;i<=lim;++i)NTT[i]=(1ll*NTT[i]*inv_lim)%mod;
	}
}
inline void Derivation(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i-1]=mul(1ll*i,F[i]);
	G[nm-1]=0;
}
inline void Inv(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=ksm(F[0],mod-2);
		return;
	}
	Inv(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<nm;++i)ans[i]=F[i];
	for(int i=nm;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(2ll,-mul(ans[i],G[i])+mod),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
inline void Mul(ll* F,ll* G,int nm)
{
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	int inv_lim=ksm(lim,mod-2);
	Never_Tell_TLE(G,1),Never_Tell_TLE(F,1);
	for(int i=0;i<=lim;++i)G[i]=mul(F[i],G[i]);
	Never_Tell_TLE(G,-1);
}
inline void Integral(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i]=mul(F[i-1],ksm(i,mod-2));
	G[0]=0;
}
inline void Ln(ll* F,ll* G,int nm)
{
	Inv(F,tmp,nm);
	for(int i=0;i<=lim;++i)ans[i]=0;
	Derivation(F,ans,nm);
	Mul(tmp,ans,nm);
	Integral(ans,G,nm);
	for(int i=0;i<=lim;++i)ans[i]=tmp[i]=0;
}
inline void solve(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=1;
		return;
	}
	solve(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<=lim;++i)ln[i]=0;
	Ln(G,ln,nm);
	for(int i=0;i<nm;++i)ans[i]=F[i];
	for(int i=nm;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1),Never_Tell_TLE(ln,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(1ll,inc(ans[i],-ln[i]+mod)),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
int main()
{
	n=read();
	int c=getchar();while(isspace(c))c=getchar();
	for(;isdigit(c);c=getchar())k=(k*10LL+(c^'0'))%mod;
	for(int i=0;i<n;++i)f[i]=read();
	Ln(f,g,n);
	for(int i=0;i<=lim;++i)g[i]=mul(g[i],k);
	solve(g,h,n);
	for(int i=0;i<n;++i)printf("%d ",h[i]);
	getchar();
	return 0;
}
```
只求能帮助到几个人罢。。

---


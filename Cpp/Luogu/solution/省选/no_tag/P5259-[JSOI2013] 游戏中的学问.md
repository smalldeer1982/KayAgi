# [JSOI2013] 游戏中的学问

## 题目描述

大家应该都见过很多人手拉手围着篝火跳舞的场景吧？一般情况下，大家手拉手跳舞总是会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另
一侧朋友的左手。

不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情
就变得有趣多了——此时大家依旧会形成圈，不过却可能会形成多个独立的圈。
当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。

班里一共有 $N$ 个同学，由 $1$ 到 $N$ 编号。Will想知道，究竟有多少种本质不
同的拉手方案，使得最终大家散开后恰好形成 $k$ 个圈呢？

给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这
只手的人的编号不同，则这两种方案本质不同。

## 说明/提示

$3~\leq~3k~\leq~N~\leq~3000$

$10^4~\leq~p~\leq~2~\times~10^9$

## 样例 #1

### 输入

```
3 1 1000000009 ```

### 输出

```
2```

# 题解

## 作者：xiaoxiaoyyds (赞：15)


[传送门](https://www.luogu.com.cn/problem/P5259)

# 分析

可以发现，这 $n$ 个人本质是相同的，因此可以设 $dp_{i,j}$ 为：已有 $i$ 个人拉手，恰好围成 $j$ 个圈的方案数。   
第 $i$ 个人就一定会被插进一个圆或组成一个圆。

- 当他插入进一个圆时，由于每种方法的圆本质相同，并且每个方法的每个圆中的可以插入的空位的和为总人数乘上方案数，即为 $(i-1) \times dp_{i-1,j}$

- 当他组成一个圆时，必须要以前的两个人和他一起组成，由于每个人的本质相同，因此有 $(i-1) \times (i-2) $ 种选人的方案，而且当人数为 $i-3$ 时，方案数为 $dp_{i-3,j}$ ，因此总方案数为 $(i-1) \times (i-2) \times dp_{i-3,j}$。    

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k,p,f[3001][3001];
int main(){
	cin>>n>>k>>p;
	f[0][0]=1;
	f[1][0]=f[2][0]=0;
	for(int i=3;i<=n;i++){
		for(int j=k;j>=1;j--){
			f[i][j]=((f[i-1][j]*(i-1)%p)+((f[i-3][j-1]*(i-1)%p*(i-2)%p)%p))%p;
		}
	} 
	cout<<f[n][k];
}
```

---

## 作者：mqxmm (赞：14)

# 小兔的话
欢迎大家在评论区留言哦~
- - -
# 思路
因为 **每一个人都随机地拉住两个不同人的手**，我们可以知道 **至少要 $3$ 个人才能围成一个新的圈**  
不妨设 $dp[i][j]$：有 $i$ 个人，围成 $j$ 个圈的方案数  
- - -
# 分析
对于一个 $i, j$，有 $2$ 种情况：  
- 第 $i$ 个人加入之前的人围成的 $j$ 个的圈中，第 $i$ 个人可以插入之前的 $i - 1$ 个位置（ 大家可以自己推一下, $n$ 个人就有 $n$ 个空位 ），故有 $i - 1$ 种情况，即 $dp[i - 1][j] * (i - 1)$  
- 第 $i$ 个人分离出来，和之前的 $2$ 个人围成 $1$ 个新的圈 ( 如果是和之前的 $3$ 个人，就相当于是加入那 $3$ 个人之前围成的圈中了 ），这时只需要选出之前的人中的 $2$ 个人，故有 $(i - 1) * (i - 2)$ 种情况，即 $dp[i - 3][j - 1] * (i - 1) * (i - 2)$  

综上所述：$dp[i][j] = dp[i - 1][j] * (i - 1) + dp[i - 3][j - 1] * (i - 1) * (i - 2)$  
- - -
# 代码
```cpp
#include <cstdio>

// 以下定义只是为了好看
#define i32 int
#define i64 long long
#define u32 unsigned int
#define u64 unsigned long long

const int MAXN = 3e3, MAXK = MAXN / 3;
int N, K, P;
i64 dp[MAXN + 5][MAXK + 5];

int main()
{
	scanf("%d %d %d", &N, &K, &P);
	dp[0][0] = 1 % P;
	for (int i = 1; i <= N; i++)
	{
		for (int j = K; j >= 1; j--)
		{
			dp[i][j] = dp[i - 1][j] * (i - 1) % P;
			if (i >= 3) dp[i][j] += dp[i - 3][j - 1] * (i - 1) % P * (i - 2) % P;
			dp[i][j] %= P;
		}
	}
	printf("%lld\n", dp[N][K]);
	return 0;
}

```


---

## 作者：Sooke (赞：7)

### 解题思路

标准 DP 题，统一把**左手**看成**单向边**，就转换成多环计数了（环大小 $\geqslant 3$），有点错排问题的味道。

直接用 $f_{i,\,j}$ 表示已选 $i$ 个点，构成 $j$ 个环的方案数。

怎么构成一个新环呢？要先有个小目标——构造三个点的。转移来的状态是 $f_{i-3,\,j-1}$，新加进去了 $i$ ，$i-1$ 和 $i-2$ 号点，钦定 $i$ 号点是这个环中的“头儿”，也就是说 $i-1$ 和 $i-2$ 号点可以跟之前使用的点交换，所以转移贡献是 $f_{i-3,\,j-1}\times(i-1)\times(i-2)$ 。

但大小为 $3$ 远远不够，我们也可以钦点 $i$ 号点是用来扩充的。转移来的状态是 $f_{i-1,j}$，因为其可以接在前 $i-1$ 个点的任何一个点的后面，所以转移贡献是 $f_{i-1,j}\times(i-1)$ 。

综上，$f_{i,\,j} = f_{i-3,\,j-1}\times(i-1)\times(i-2)+f_{i-1,j}\times(i-1)$ ，设定边界 $f_{0,\,0} = 1$ ，答案状态 $f_{n,\,m}$ 。

---

### 代码实现

真的很短呢 qaq

```cpp
#include <cstdio>

const int maxN = 3005;

int n, m, p, f[maxN][maxN];

int main() {
    scanf("%d%d%d", &n, &m, &p); f[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) { f[i][j] = ((i >= 3 ? f[i - 3][j - 1] * (i - 1ll) % p * (i - 2) % p : 0) + f[i - 1][j] * (i - 1ll)) % p; }
    }
    printf("%d\n", f[n][m]);
    return 0;
}
```

---

## 作者：da32s1da (赞：6)

设$f[i][j]$为$i$个人围成$j$个圈的方案数。

$$f[i][j]=f[i-1][j]\times(i-1)+f[i-3][j-1]\times(i-1)\times(i-2)$$

转移首先是$i-1$个人围成$j$个圈，第$i$个人可以跟$i-1$个人拉手

还有$i-3$个人围成$j-1$个圈，再选出$2$个人跟第$i$个人围成$1$个圈。

```cpp
#include<cstdio>
const int N=1005;
int n,k,p;
int f[N*3][N];
inline int min(int u,int v){return u<v?u:v;}
int main(){
	scanf("%d%d%d",&n,&k,&p);
	f[0][0]=1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=min(i/3,k);j++)
	f[i][j]=(1ll*f[i-1][j]*(i-1)%p+1ll*f[i-3][j-1]*(i-1)*(i-2)%p)%p;
	printf("%d\n",f[n][k]);
}
```

---

## 作者：mzyc_jx (赞：4)

[游戏中的学问](https://www.luogu.com.cn/problem/P5259)

一道不算难的动规题。

### 思路：
我们可以知道：至少要 $3$ 个人才能围成一个圈。

于是我们可以分类讨论：

1. 第 $i$ 个人加入 $j$ 个人的圈中，有 $i-1$ 种方案。
2. 第 $i$ 个人离开他所在的圈，找 $2$ 个人合成一个新圈，有 $(i-1)\times (i-2)$ 种方案。

### 动规方程：

可以设 $f[i][j]$ 为：有 $i$ 个人，围成 $j$ 个圈的方案数。

则方程为： $f[i][j]=f[i-1][j]\times(i-1)+f[i-3][j-1]\times(i-1)\times(i-2)$

### 注意：
动规数组记得开 $long long$ ！！！

### CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[3001][1001];
int main()
{
	int n,k;
	long long p;
	cin>>n>>k>>p;
	f[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=k;j>=1;j--)
		{
			f[i][j]=f[i-1][j]*(i-1)%p;
			if(i>=3)
			f[i][j]+=f[i-3][j-1]*(i-1)%p*(i-2)%p;
			f[i][j]%=p;
		}
	}
	cout<<f[n][k];
	return 0;
}
```

---

## 作者：Digital_Sunrise (赞：3)

[link](https://www.luogu.com.cn/problem/P5259)

小清新 $\text{dp}$ 题 。

## 思路

注意到圈的人数至少为 $3$ 。

最容易想到的状态： $dp_{i,j}$ 表示有 $i$ 个人，**恰好**围了 $j$ 个圈的方法数。

当有一个新的 $dp_{i,j}$ 处理时，可以分成两个情况考虑：

1. 合并。第 $i$ 个人与之前的 $j-1$ 个圈中的某个圈合并，即将 $i$ 插入到前 $i-1$ 个人围成的圈的 $i-1$ 个空隙中，得到 $dp_{i-1,j-1}\times (i-1)$ 。
2. 独立。与前面已经出现过的两人直接组建新的最小圈（超三人则称合并），得到 $dp_{i-3,j-1} \times(i-1)\times(i-2)$ ，注意此时 $3\le i$ 。

综上，得到 $dp_{i,j}=dp_{i-1,j-1}\times (i-1)+dp_{i-3,j-1} \times(i-1)\times(i-2)$ 。

答案即为 $dp_{n,k}$ 。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k, p;
int dp[3005][3005];

signed main()
{
	cin >> n >> k >> p;
	dp[0][0] = 1;
	for (int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= k;j++)
		{
			dp[i][j] = dp[i - 1][j] * (i - 1) % p;
			if(i >= 3)
				dp[i][j] += dp[i - 3][j - 1] * (i - 1) * (i - 2) % p;
			dp[i][j] %= p;
		}
	}
	cout << dp[n][k];
	return 0;
}
```

---

## 作者：Weng_Weijie (赞：2)

这里给出一个基于指数型生成函数的 $O(n^2)$ 或 $O(n\log^2n)$ 或 $O(n\log n)$ 的做法。

容易发现，如果确定了 $a$ 个人作为一个环，那么环的方案数即圆排列 $(a-1)!$

考虑每个环的指数型生成函数为

$$f(x)=\sum_{a\geq 3}\frac{1}{a}x^a$$

那么答案就是 $\dfrac{n!}{k!}[x^n]f^k(x)$

使用 FFT 和倍增快速幂，即可 $O(n\log^2n)$

也可以用 $\ln \exp$ 达到 $O(n\log n)$ 的复杂度，这里为了方便，使用了 $O(n^2)$ 的算法

```cpp
#include <iostream>

const int N = 3001;
using LL = long long;
int mod, n, k, A[N], lnA[N], B[N], lnB[N];
void reduce(int &x) { x += x >> 31 & mod; }
int pow(int x, int y, int ans = 1) {
	for (; y; y >>= 1, x = (LL) x * x % mod)
		if (y & 1) ans = (LL) ans * x % mod;
	return ans;
}
void poly_ln(int *A, int *B) {
	B[0] = 0;
	for (int i = 1; i <= n; ++i) {
		B[i] = 0;
		for (int j = 1; j < i; ++j)
			reduce(B[i] -= (LL) A[i - j] * j % mod * B[j] % mod);
		B[i] = pow(i, mod - 2, B[i]);
		reduce(B[i] += A[i] - mod);
	}
}
void poly_exp(int *A, int *B) {
	B[0] = 1;
	for (int i = 1; i <= n; ++i) {
		B[i] = 0;
		for (int j = 0; j < i; ++j)
			reduce(B[i] += (LL) A[i - j] * (i - j) % mod * B[j] % mod - mod);
		B[i] = pow(i, mod - 2, B[i]);
	}
}
int main() {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> n >> k >> mod;
	for (int i = 0; i <= n; ++i)
		A[i] = pow(i + 3, mod - 2);
	int c = A[0], d = pow(c, mod - 2);
	for (int i = 0; i <= n; ++i)
		A[i] = (LL) A[i] * d % mod;
	poly_ln(A, lnA);
	for (int i = 0; i <= n; ++i)
		lnB[i] = (LL) lnA[i] * k % mod;
	poly_exp(lnB, B);
	int ans = pow(c, k, B[n - 3 * k]);
	for (int i = 1; i <= n; ++i) ans = (LL) ans * i % mod;
	for (int i = 1; i <= k; ++i) ans = (LL) ans * pow(i, mod - 2) % mod;
	std::cout << ans << '\n';
	return 0;
}
```

---

## 作者：mzyc_pzx (赞：2)

一道典型的动规~~水~~题。
### 分析：
任何一个人都可以任意牵住两个人，所以至少 3 人围成一圈。
### 分类讨论：
1. 第 $i$ 个人加入 $j$ 个人的圈中，有 $ i - 1$ 种方案。
2. 第 $i$ 个人离开他所在的圈，找 2 个人合成一个新圈，有     $(i-1)\times (i-2)$ 种方案。
### 动归方程：
 $f_{i,j} = f_{i - 1,j}\times (i - 1) + f_{i - 3,j - 1}\times (i - 1)\times (i - 2)$
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,p;
long long a[3001][10001];
int main()
{
	cin>>n>>k>>p;
	a[0][0]=1%p;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			a[i][j]=a[i-1][j]*(i-1)%p;
			if(i>=3)
			a[i][j]=a[i][j]+a[i-3][j-1]*(i-1)%p*(i-2)%p;
			a[i][j]=a[i][j]%p;
		}
	}
	cout<<a[n][k];
	return 0;
}
```
### 注意:
动归数组一定要开够，否则会 RE 。

十年 OI 一场空，不开 long long 见祖宗。

---

## 作者：MafuyuQWQ (赞：1)

## Preface

感觉这道题和[$\color{black}{光之大陆}$](https://www.acwing.com/solution/content/153401/)那道题中间的 DP 有点像。

## Problem

> 求 $n$ 个人拉 $k$ 个圈的方案数，人互不相同。

## Solution

不难发现至少要 $3$ 个人才能组成一个圈。  
显然做法：设 $f_{i,j}$ 表示 $i$ 个人，拉 $j$ 个圈的方案数。  
考虑转移。  

* $i$ 插入前面一个环，即 $f_{i,j}\leftarrow f_{i-1,j}\times(i-1)$；
* $i$ 新建一个环，即 $f_{i,j}\leftarrow f_{i-3,j-1}\times (i-1)\times(i-2)$。

解释一下，为啥这里不是 $f_{i,j}\leftarrow \sum\limits_{l=3}^{i} f_{i-l,j-1}$。  
因为这个式子里除了第一项，都是被其他 $f$ 包含的，这样统计会被算重。比如，$f_{i-4,j-1}$ 就被包含在 $f_{i-1,j}$ 里了。~~恐怕只有我会推出这个转移式子了~~。  
初始化 $f_{0,0}=1$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 3010;

int n, k, p;
int f[N][N];

signed main()
{
    f[0][0] = 1;
    cin >> n >> k >> p;
    for (int i = 3; i <= n; i ++ )
        for (int j = 1; j <= k; j ++ )
            f[i][j] = (f[i - 1][j] * (i - 1) % p + f[i - 3][j - 1] * (i - 1) % p * (i - 2) % p) % p;

    cout << f[n][k] << '\n';

    return 0;
}
```

---

## 作者：lcfollower (赞：0)

我们设 $f_{i,j}$ 为前 $i$ 个人围成 $j$ 个圈的方案数。

那么转移：

$$f_{i ,j} = (i-1)\times f_{i - 1 ,j} + (i-1)(i-2)\times f_{i - 3 ,j - 1}$$

- 前面的表示 $i$ 加入已经有的圈中，可以有 $i - 1$ 个位置插，因为空位数量就是圆圈人数总和，根据乘法原理就是 $(i - 1) \times f_{i - 1 ,j}$。

- 后面的表示 $i$ 自己围成一个圈，但是题目要求**两个不同人的手**，所以可以随机选取两个幸运儿作为自己的左手和右手，方案数为 $(i - 1)(i - 2)$，根据乘法原理就是 $(i - 1)(i - 2) \times f_{i - 3 ,j - 1}$。

- 根据加法原理把它们相加就行了。

:::info[代码]
```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i, x, y) for (int i = x; i <= y; i++)
# define dn(i, x, y) for (int i = x; i >= y; i--)
# define inf 1e18

using namespace std;
 
inline int read(){int x = 0, f = 0;char ch = getchar();while (!isdigit(ch)) {f |= (ch == '-');ch = getchar();}while (isdigit(ch))x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();return f ? -x : x;}
inline void write(int x){if (x < 0)putchar('-'), x = -x;if (x > 9)write(x / 10);putchar(x % 10 | 48);}
inline void writeln(int x){write(x), putchar('\n');}
inline void writesp(int x){write(x), putchar(' ');}

const int N = 3005;
int n ,k ,p ,f[N][N];

namespace lolcrying {
    signed main () {
		n = read () ,k = read () ,p = read ();
        f[0][0] = 1;
        up (i ,1 ,n)
            up (j ,1 ,k) {
                f[i][j] = f[i - 1][j] * (i - 1) % p;
                if (i >= 3) f[i][j] += f[i - 3][j - 1] * (i - 1) % p * (i - 2) % p ,f[i][j] %= p;
            }
        writeln (f[n][k]);
        return 0;
	}
}
signed main () {
	int T = 1;
	while (T --) lolcrying :: main ();
	return 0;
}
```
:::

---

## 作者：TemplateClass (赞：0)

$\gdef \dp {\mathrm{dp}}$

由于每一个人都随机地拉住两个不同人的手，所以可以发现每个环的长度都至少为 $3$。

设 $\dp _ {i, j}$ 表示 $i$ 个人恰好围成 $j$ 个圈的方案数。然后考虑如何转移：

- 这个人可以选择加入到之前已经围成的 $j$ 个圈中的一个圈，也就是插入到 $(i - 1)$ 个人中的两个人之间，由于围成的是环，所以有 $(i - 1)$ 个地方可以插入，因而这部分的贡献是 $(i - 1) \times \dp _ {i - 1, j}$；
- 这个人还可以选择组成一个新的圈，也就是说从 $(i - 1)$ 个人中挑出两个人，显然一共有 $(i - 1)(i - 2)$ 种方案，所以这部分的贡献就是 $(i - 1)(i - 2) \times \dp _ {i - 3, j - 1}$。

然后这两部分的贡献加起来直接转移就可以了，注意初始时 $\dp _ {0, 0} = 1$，时间复杂度 $O(nk)$。

```cpp
#include<iostream>

constexpr int N = 3000 + 1, K = N / 3;

int n, k, p, dp[N][K];

int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	
	std::cin >> n >> k >> p;
	
	dp[0][0] = 1;
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= k; ++j) {
			dp[i][j] = 1ull * (i - 1) * dp[i - 1][j] % p;
			if(i >= 3) dp[i][j] = (1ull * dp[i][j] + 1ull * (i - 1) * (i - 2) * dp[i - 3][j - 1]) % p;
		}
	}
	
	std::cout << dp[n][k] << "\n";
	
	return 0;
}
```

---

## 作者：creation_hy (赞：0)

这不就是第二类斯特林数吗。。就加了个条件集合大小至少为三。。。

第二类斯特林数是设 $S_{i,j}$ 表示 $i$ 个数放进 $j$ 个圆排列的方案数，那么每步可以放在之前某个数右边，或者新建一个圆排列，即 $S_{i,j}=S_{i-1,j-1}+S_{i-1,j}(i-1)$。

这题稍微改一下，新建集合的时候在前面的数字里选两个数出来组成一个大小为三的圆排列即可。注意要乘上三个数的圆排列的方案数（$2$）。

即 $f_{i,j}=2f_{i-3,j-1}C_{i-1}^2+f_{i-1,j}(i-1)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3005;
int n, m, mod;
ll f[N][N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> mod;
    f[0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            f[i][j] = f[i - 1][j] * (i - 1);
            if (i >= 3)
                (f[i][j] += (i - 1ll) * (i - 2) % mod * f[i - 3][j - 1]) %= mod;
        }
    cout << f[n][m] << '\n';
    return 0;
}
```

---

## 作者：dAniel_lele (赞：0)

考虑 $dp_{i,j}$ 表示目前已经考虑了 $i$ 个人，组成了 $j$ 个圈。

转移枚举下一个圈大小 $p$，则：

$$dp_{i+p,j+1}\leftarrow dp_{i,j}\times\binom{i+p-1}{p-1}\times(p-1)!$$

这样做是 $n^3$ 的。

考虑转换一下转移式子：

$$\frac{dp_{i+p,j+1}}{(i+p-1)!}\leftarrow dp_{i,j}\times i!$$

于是前缀和优化即可。复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
int qp(int a,int b,int mod){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int fac[3005],inv[3005],dp[3005][3005],f[3005][62],C[3005][3005];
signed main(){
	int n,k,p; cin>>n>>k>>p; const int mod=p;
	fac[0]=1; for(int i=1;i<=3000;i++) fac[i]=fac[i-1]*i%mod;
	inv[3000]=qp(fac[3000],mod-2,mod); for(int i=2999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	for(int i=0;i<=3000;i++) C[i][0]=1;
	for(int i=1;i<=3000;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	dp[0][0]=1,dp[1][0]=mod-1;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=k;j++){
			if(i!=0) (dp[i][j]+=dp[i-1][j])%=mod;
			if(i!=0) (dp[i+3][j+1]+=dp[i][j]*fac[i-1]%mod*inv[i])%=mod;
			else (dp[i+3][j+1]+=dp[i][j]*inv[i])%=mod;
		}
	}
	cout<<dp[n][k]*fac[n-1]%mod;
	return 0;
}

```

---


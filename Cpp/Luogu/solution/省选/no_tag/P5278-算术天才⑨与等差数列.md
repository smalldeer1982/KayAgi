# 算术天才⑨与等差数列

## 题目描述

算术天才⑨非常喜欢和等差数列玩耍。   
有一天，他给了你一个长度为 $n$ 的序列，其中第 $i$ 个数为 $a_i$。  
他想考考你，每次他会给出询问 $l,r,k$，问区间 $[l,r]$ 内的数从小到大排序后能否形成公差为 $k$ 的等差数列。  
当然，他还会不断修改其中的某一项。  
为了不被他鄙视，你必须要快速并正确地回答完所有问题。  
注意：只有一个数的数列也是等差数列。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据， $1\le n,m \le 3\times 10^5$，$0\le a_i,y,k \le 10^9$。

## 样例 #1

### 输入

```
5 3
1 3 2 5 6
2 1 5 1
1 5 4
2 1 5 1```

### 输出

```
No
Yes```

# 题解

## 作者：da32s1da (赞：43)

维护x次方求和好像都能卡。。

考虑什么时候能组成等差数列。

1. 首先$\mathrm{max-min=(r-l)k}$
2. 其次**相邻两数差的绝对值**的$\gcd$是$k$
3. 区间$[l,r]$内的数不重复

满足性质1。我们把$[l,r]$内的数从小到大排序，减去最小值，得到$\{0,a,b,c,\cdots,(r-l)k\}$

满足性质2。说明$a,b,c,\cdots$都是$k$的倍数。都除以$k$，得到$\{0,a',b',c',\cdots,r-l\}$

满足性质3。数不重复，那么$a',b',c',\cdots$只能是$1,2,3,\cdots$

所以能组成公差是$k$的等差数列。

现在来看需要维护什么。

最大值，最小值，前驱的最大值，区间左端点数值，区间右端点数值，差的$\mathrm{gcd}$

这里前驱指前面出现这个数的最后一个位置。

线段树,map,set维护即可，注意强制在线

```cpp
#include<cstdio>
#include<set>
#include<map>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=6e5+50;
inline void rad(int &_){
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9');_=ch-48;
    while(ch=getchar(),ch<='9'&&ch>='0')_=_*10+ch-48;
}
int gcd(int u,int v){return v?gcd(v,u%v):u;}
int n,m,x,y,z,cnt,opt,las;
int a[N],pre[N],net[N];
map<int,int>mp;
set<int>s[N];
typedef set<int>::iterator IT;
struct node{
    int lval,rval,mx,mn,mnp,gc;
    node(){}
    node(int A,int B,int C,int D,int E,int F):lval(A),rval(B),mx(C),mn(D),mnp(E),gc(F){}
}r;
struct tree{
    node tre[N<<3];
    node update(node u,node v){
        return node(u.lval,v.rval,max(u.mx,v.mx),min(u.mn,v.mn),max(u.mnp,v.mnp),gcd(gcd(u.gc,v.gc),abs(u.rval-v.lval)));
    }
    void mktree(int now,int ls,int rs){
        if(ls==rs){
            tre[now]=(node){a[ls],a[ls],a[ls],a[ls],pre[ls],0};
            return;
        }
        int noww=now<<1,nrs=ls+rs>>1;
        mktree(noww,ls,nrs);
        mktree(noww|1,nrs+1,rs);
        tre[now]=update(tre[noww],tre[noww|1]);
    }
    void change(int now,int ls,int rs,int mb,node val){
        if(ls>mb||rs<mb)return;
        if(ls==rs){tre[now]=val;return;}
        int noww=now<<1,nrs=ls+rs>>1;
        change(noww,ls,nrs,mb,val);
        change(noww|1,nrs+1,rs,mb,val);
        tre[now]=update(tre[noww],tre[noww|1]);
    }
    node query(int now,int ls,int rs,int zuo,int you){
        if(ls>=zuo&&rs<=you)return tre[now];
        int noww=now<<1,nrs=ls+rs>>1;
        if(you<=nrs)return query(noww,ls,nrs,zuo,you);
        if(zuo>nrs)return query(noww|1,nrs+1,rs,zuo,you);
        return update(query(noww,ls,nrs,zuo,you),query(noww|1,nrs+1,rs,zuo,you));
    }
}t;
int main(){
    rad(n);rad(m);
    for(int i=1;i<=n;i++){
        rad(x);a[i]=x;
        if(mp.find(x)==mp.end())mp[x]=++cnt,s[cnt].insert(i);
        else{
            y=mp[x];
            z=*--s[y].end();
            pre[i]=z;
            net[z]=i;//记录每个数的前驱后继
            s[y].insert(i);//丢到set里
        }
    }
    t.mktree(1,1,n);
    for(int i=1;i<=m;i++){
        rad(opt);
        if(opt==1){
            rad(x);rad(y);
            x^=las;y^=las;
            net[pre[x]]=net[x];
            pre[net[x]]=pre[x];//修改前驱后继
            z=a[net[x]];
            t.change(1,1,n,net[x],node(z,z,z,z,pre[x],0));//修改后继在线段树内的信息
            s[mp[a[x]]].erase(x);//set中删除
            if(mp.find(y)==mp.end()){
                mp[y]=++cnt,s[cnt].insert(i);
                pre[x]=net[x]=0;
            }else{
                z=mp[y];
                IT it=s[z].lower_bound(x);//set的lower_bound找前驱后继
                if(it==s[z].begin()){//有后继无前驱
                    pre[x]=0;net[x]=*it;
                    pre[*it]=x;
                    t.change(1,1,n,*it,node(a[*it],a[*it],a[*it],a[*it],x,0));//修改后继在线段树内的信息
                }else if(it==s[z].end()){//有前驱无后继
                    --it;
                    pre[x]=*it;net[x]=0;
                    net[*it]=x;
                }else{//有前驱有后继
                    IT It=--it;++it;
                    pre[x]=*It;net[x]=*it;
                    net[*It]=x;pre[*it]=x;
                    t.change(1,1,n,*it,node(a[*it],a[*it],a[*it],a[*it],x,0));//修改后继在线段树内的信息
                }
            }
            a[x]=y;
            t.change(1,1,n,x,node(y,y,y,y,pre[x],0));//修改自身信息
        }else{
            rad(x);rad(y);rad(z);
            x^=las;y^=las;z^=las;
            r=t.query(1,1,n,x,y);
            if((r.mx-r.mn==z*(y-x))&&(r.gc==z||!r.gc)&&(r.mnp<x||!z))las++,puts("Yes");//这里注意一下
            else puts("No");
        }
    }
}
```

---

## 作者：Singercoder (赞：17)

**非正解，好像没有一样的做法，不是直接维护平方和，而是那种不容易构造数据卡掉的进制Hash。**

还是借鉴了[P6688](https://www.luogu.com.cn/problem/P6688)为可重集设计特征函数的思想，那道题[我的暴力做法](https://www.luogu.com.cn/blog/SingerCoder/solution-p6688)在这里，然后[正解](https://www.luogu.com.cn/blog/skydogli/solution-p6688)在这里。

这里先说一下进制Hash思想，我们知道本题维护区间本质上就是维护可重集，因为不考虑顺序；

那么考虑$a_i$对Hash值的贡献为$2^{a_i}$，这样就有了可重集的特征函数：

$$Hash(S) = \sum_{a_i \in S} 2^{a_i}$$

对整个集合整体加减就对特征函数进行乘除即可。

那么现在唯一的问题就在于，如何快速求出一个长度为n、首项为a_1、公差为k的等差数列的特征函数？

显然我们可以令首项为0，再对整个集合整体加减，令$f(n,k)$表示长度为n、首项为0，公差为k的等差数列的特征函数，则有：

![](https://cdn.luogu.com.cn/upload/image_hosting/8x10x6q3.png)

像快速幂那样写个递归即可，实测单哈希即可AC

```cpp
#include<bits/stdc++.h>

#define ll long long 

#define inf 0x3f3f3f3f

using namespace std;

inline int read()
{
	int a=0,f=1,c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		a=a*10+c-'0';
		c=getchar();
	}
	return a*f;
}

const int N=3e5+10;
const int P=1e9+7;
ll pm(ll a,ll x)
{
	if(x==0)return 1;
	if(x&1)return pm(a,x-1)*a%P;
	ll ret=pm(a,x/2);
	return ret*ret%P;
}
ll f(ll n,ll k)
{
	if(n==1)return 1;
	if(n&1)return (f(n-1,k)*pm(2,k)+1)%P;
	ll ret=f(n/2,k);
	return (ret+ret*pm(2,k*(n/2)))%P;
}

struct SGT
{
	struct node
	{
		int mn;
		ll sum;
	}a[N*4];
	inline int ls(int u){return u<<1;}
	inline int rs(int u){return u<<1|1;}
	inline void upd_one(int u,int val)
	{
		a[u].mn=val;
		a[u].sum=pm(2,val);
	}
	inline void push_up(int u)
	{
		a[u].mn=min(a[ls(u)].mn,a[rs(u)].mn);
		a[u].sum=(a[ls(u)].sum+a[rs(u)].sum)%P;
	}
	void build(int u,int l,int r,int* val)
	{
		if(l==r)upd_one(u,val[l]);
		else
		{
			int mid=(l+r)/2;
			build(ls(u),l,mid,val);
			build(rs(u),mid+1,r,val);
			push_up(u);
		}
	}
	void upd(int u,int l,int r,int p,int val)
	{
		if(l==r)upd_one(u,val);
		else
		{
			int mid=(l+r)/2;
			if(p<=mid)upd(ls(u),l,mid,p,val);
			else upd(rs(u),mid+1,r,p,val);
			push_up(u);
		}
	}
	int ask_mn(int u,int l,int r,int ql,int qr)
	{
		if(ql<=l && r<=qr)return a[u].mn;
		else
		{
			int mid=(l+r)/2,ret=inf;
			if(ql<=mid)ret=min(ret,ask_mn(ls(u),l,mid,ql,qr));
			if(mid+1<=qr)ret=min(ret,ask_mn(rs(u),mid+1,r,ql,qr));
			return ret;
		}
	}
	ll ask_sum(int u,int l,int r,int ql,int qr)
	{
		if(ql<=l && r<=qr)return a[u].sum;
		else
		{
			int mid=(l+r)/2;
			ll ret=0;
			if(ql<=mid)ret=(ret+ask_sum(ls(u),l,mid,ql,qr))%P;
			if(mid+1<=qr)ret=(ret+ask_sum(rs(u),mid+1,r,ql,qr))%P;
			return ret;
		}
	}
}T;

int n,m;
int a[N];

int main()
{
//	freopen("1.in","r",stdin);
	
	n=read();
	m=read();
	for(int i=1;i<=n;++i)a[i]=read();
	T.build(1,1,n,a);
	
	int cnt=0;
	for(int i=1;i<=m;++i)
	{
		int op=read();
		if(op==1)
		{
			int x=read()^cnt;
			int y=read()^cnt;
			T.upd(1,1,n,x,y);
		}
		else
		{
			int l=read()^cnt;
			int r=read()^cnt;
			int k=read()^cnt;
			int mn=T.ask_mn(1,1,n,l,r);
			ll sum=T.ask_sum(1,1,n,l,r);
			if(sum==f(r-l+1,k)*pm(2,mn)%P)
			{
				++cnt;
				puts("Yes");
			}
			else
			{
				puts("No");
			}
		}
	}
	
	return 0;
}
```

# 后记

说一下为啥选2为base不会产生冲突吧，首先很显然这样我们形成的Hash值相当于一个二进制数，例如：

$$Hash({1,3,5})=(10101)_2$$

那么如果要在集合不同的情况下令Hash值相同，我们就必须使得二进数的某一位不是直接得来，而是由上一位进位得来，这样整个二进数中1的个数就会减少，也就无法使得Hash值相同。

然而上述分析成立的前提是$k \ne 0$，对于$k=0$的情况，在最小值确定的情况下发现S与Hash(S)为互为唯一映射。

另外，依据可重集那道题的经验，用sin cos来设计特征函数貌似也是可行的，不过毕竟浮点数存在误差所以就没有尝试，有兴趣的小朋友可以试一试哈。

---

## 作者：TheShadow (赞：15)

# 闲扯

这道题 $JKLover$ 讲过，然后补课的时候老师也提到了，想了想还是做了吧，顺便写篇题解纪念一下。

# 题面

[P5278 算术天才⑨与等差数列](https://www.luogu.org/problem/P5278)

# Solution

对于一个序列，如果它排序后能构成一个公差为 $d$ 等差数列，一定满足一下几点：

1. $max-min=d\cdot(len-1)$ 。
2. $gcd_{k=i}^{j-1}(val_{k+1}-val_k)=d$ 。
3. 序列中没有重复元素。

前两个条件很好维护，直接上线段树即可，所以我们需要着重解决的是第 $3$ 个条件。

有一个很巧妙的方法，我们可以求出每一个元素，它在序列中上一次出现的位置，如果这一个区间中所有元素上一次出现位置的最大值小于 $l$ ，那么一定没有重复元素。

因为数据范围很大，而且是强制在线，所以我们用 $map$ 套 $set$ 存一下，单点修改时注意下边界条件即可。

需要注意的是**一个数的数列也算是等差数列**，还有在 $d=0$ 时我们直接判断最大值是否等于最小值即可。

# Code

```c++
#include<bits/stdc++.h>
#include<unordered_map>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il _print(T x){
	if(x/10) _print(x/10);
	putchar(x%10+'0');
}
template<class T>il print(T x){
	if(x<0) putchar('-'),x=-x;
	_print(x);
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 3e5+5;
int n,m,val[MAXN],opt,x,y,k,cnt,pre[MAXN];
unordered_map<int,set<int> > mp;
set<int>::iterator ite;
it gcd(int x,int y){return y==0?x:gcd(y,x%y);}
it max(int x,int y){return x>y?x:y;}
it min(int x,int y){return x<y?x:y;}
#define lc (cur<<1)
#define rc (cur<<1|1)
struct Seg_Tree{
	int mx,mn,mx_pre;
}T[MAXN<<2];
il pushup(int cur){
	T[cur].mn=min(T[lc].mn,T[rc].mn);
	T[cur].mx=max(T[lc].mx,T[rc].mx);
	T[cur].mx_pre=max(T[lc].mx_pre,T[rc].mx_pre);
}
il build_tree(int cur,int l,int r){
	if(l==r) return T[cur].mn=T[cur].mx=val[l],T[cur].mx_pre=pre[l],void();
	build_tree(lc,l,mid),build_tree(rc,mid+1,r);
	pushup(cur);
}
il updata(int cur,int l,int r,int pos,int k){
	if(l==r) return T[cur].mn=T[cur].mx=k,T[cur].mx_pre=pre[l],void();
	if(mid>=pos) updata(lc,l,mid,pos,k);
	else updata(rc,mid+1,r,pos,k);
	pushup(cur);
}
it query_mx(int cur,int l,int r,int L,int R){
	if(l>=L&&r<=R) return T[cur].mx;
	ri res=0;
	if(mid>=L) res=max(res,query_mx(lc,l,mid,L,R));
	if(R>mid) res=max(res,query_mx(rc,mid+1,r,L,R));
	return res;
}
it query_mn(int cur,int l,int r,int L,int R){
	if(l>=L&&r<=R) return T[cur].mn;
	ri res=INT_MAX;
	if(mid>=L) res=min(res,query_mn(lc,l,mid,L,R));
	if(R>mid) res=min(res,query_mn(rc,mid+1,r,L,R));
	return res;
}
it query_pre(int cur,int l,int r,int L,int R){
	if(l>=L&&r<=R) return T[cur].mx_pre;
	ri res=-1;
	if(mid>=L) res=max(res,query_pre(lc,l,mid,L,R));
	if(R>mid) res=max(res,query_pre(rc,mid+1,r,L,R));
	return res;
}
struct Tree{
	int d;
}T1[MAXN<<2];
int c[MAXN];
il build(int cur,int l,int r){
	if(l==r) return T1[cur].d=c[l],void();
	build(lc,l,mid),build(rc,mid+1,r);
	T1[cur].d=gcd(T1[lc].d,T1[rc].d);
}
il updata_d(int cur,int l,int r,int pos){
	if(l==r) return T1[cur].d=c[pos],void();
	if(mid>=pos) updata_d(lc,l,mid,pos);
	else updata_d(rc,mid+1,r,pos);
	T1[cur].d=gcd(T1[lc].d,T1[rc].d);
}
it query_d(int cur,int l,int r,int L,int R){
	if(l>=L&&r<=R) return T1[cur].d;
	ri res=0;
	if(mid>=L) res=gcd(res,query_d(lc,l,mid,L,R));
	if(R>mid) res=gcd(res,query_d(rc,mid+1,r,L,R));
	return res;
}
it solve(int l,int r,int k){
	if(l==r) return 1;
	ri mx=query_mx(1,1,n,l,r),mn=query_mn(1,1,n,l,r),d=query_d(1,1,n-1,l,r-1),mx_pre=query_pre(1,1,n,l,r);
	if(mx-mn!=1ll*(r-l)*k) return 0;
	if(k&&mx_pre>=l) return 0;
	if(d!=k) return 0;
	return 1;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	for(ri i=1;i<=n;++i) read(val[i]);
	for(ri i=1;i<n;++i) c[i]=abs(val[i+1]-val[i]);
	for(ri i=1;i<=n;++i){
		if(!mp[val[i]].size()) pre[i]=-1;
		else{
			ite=mp[val[i]].end();--ite;
			pre[i]=*ite;
		}
		mp[val[i]].insert(i);
	}
	build_tree(1,1,n),build(1,1,n-1);
	for(ri i=1;i<=m;++i){
		read(opt),read(x),read(y);
		x^=cnt,y^=cnt;
		if(opt==1){
			ite=mp[val[x]].find(x);
			if(ite!=mp[val[x]].end()) ++ite,pre[*ite]=pre[x],updata(1,1,n,*ite,val[*ite]);
			mp[val[x]].erase(x),val[x]=y;
			ite=mp[val[x]].lower_bound(x);
			if(ite!=mp[val[x]].end()) pre[*ite]=x,updata(1,1,n,*ite,val[*ite]);
			if(ite==mp[val[x]].begin()) pre[x]=-1;
			else --ite,pre[x]=*ite,mp[val[x]].insert(x);
			c[x]=abs(val[x+1]-val[x]),c[x-1]=abs(val[x]-val[x-1]);
			updata(1,1,n,x,y),updata_d(1,1,n-1,x);
			if(x-1) updata_d(1,1,n-1,x-1);
		}
		if(opt==2){
			read(k),k^=cnt;
			if(solve(x,y,k)) puts("Yes"),++cnt;
			else puts("No");
		}
	}
	return 0;
}
```

# 总结

这道题需要考虑到能构成等差数列的多种条件，而且边界需要特别注意，但是好像能用 $hash$ 乱搞过去。

就直接存一下区间最大，最小，区间和，元素的平方和，立方和，然后对于 $d$ ，我们根据最大值和最小值，算出以上的 $3$ 个值的 $hash$ 值，然后判断相等即可。

---

## 作者：SSerxhs (赞：6)

一段区间$[l,r]$排序后是等差数列，等价于$(max-min)=k*(r-l)$且相邻两数差的$gcd$是k的倍数且这段区间没有重复数字。

所以用线段树维护差分数组区间gcd、原数组最大最小值，用hash+set维护每个数字出现的位置，并在线段树上维护每个点的前驱(最靠右的值相等的点)，就可以判断区间内是否有重复数字了。

```cpp
#include <stdio.h>
#include <string.h>
#include <map>
#include <set>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=3e5+2,M=1.2e6+2,inf=1e9;
int l[M],r[M],s[M],zd[M],zx[M],a[N],dy[N],pre[M],st[M];
int n,m,i,j,x,y,z,c,ans,xz,dz,gc,ss,cc,tp;
map<int,int> ls;
set<int> b[N<<1];
set<int>::iterator it,jt;
inline int ab(register int x)
{
	if (x>0) return x;
	return -x;
}
inline int gcd(register int x,register int y)
{
	if (x>y) swap(x,y);
	while (x)
	{
		y%=x;swap(x,y);
	}
	return y;
}
inline void read(int &x)
{
	c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
inline void pushup(register int x)
{
	c=x<<1;
	s[x]=gcd(s[c],s[c|1]);
	zd[x]=max(zd[c],zd[c|1]);
	zx[x]=min(zx[c],zx[c|1]);
	pre[x]=max(pre[c],pre[c|1]);
}
void build(int x)
{
	if (l[x]==r[x])
	{
		read(a[l[x]]);s[x]=ab(a[l[x]]-a[l[x]-1]);
		zx[x]=zd[x]=a[l[x]];dy[l[x]]=x;
		if ((c=ls[zx[x]])==0) b[ls[zx[x]]=c=++ss].insert(0);
		b[c].insert(l[x]);
		return;
	}
	st[++tp]=x;
	l[c=x<<1]=l[x];r[c]=l[x]+r[x]>>1;
	l[c|1]=r[c]+1;r[c|1]=r[x];
	build(c);build(x<<1|1);
}
inline void allpush(register int x)
{
	while (x=x>>1) pushup(x);
}
inline void mdf()
{
	it=b[c=ls[a[z]]].find(z);
	jt=it++;if (it!=b[c].end()) pre[dy[*it]]=*(--jt);
	b[c].erase(z);
	zx[dy[z]]=zd[dy[z]]=a[z]=y;
	if ((c=ls[y])==0) b[ls[y]=c=++ss].insert(0);
	jt=it=b[c].insert(z).first;pre[dy[z]]=*(--jt);
	++it;if (it!=b[c].end()) pre[dy[*it]]=z;
	s[dy[z]]=ab(a[z]-a[z-1]);
	if (z<=n) s[dy[z+1]]=ab(a[z+1]-a[z]);
	allpush(dy[z]);if (z<=n) allpush(dy[z+1]);
}
void find1(int x)
{
	if ((z<=l[x])&&(r[x]<=y))
	{
		cc=max(cc,pre[x]);xz=min(xz,zx[x]);
		dz=max(dz,zd[x]);return;
	}
	if (z<=r[x<<1]) find1(x<<1);
	if (y>r[x<<1]) find1(x<<1|1);
}
void find2(int x)
{
	if ((z<=l[x])&&(r[x]<=y))
	{
		if (~gc) gc=gcd(gc,s[x]); else gc=s[x];
		return;
	}
	if (z<=r[x<<1]) find2(x<<1);
	if (y>r[x<<1]) find2(x<<1|1);
}
int main()
{
	read(n);read(m);
	r[l[1]=1]=n;build(1);
	for (i=1;i<=ss;i++) for (it=b[i].begin(),jt=it++;it!=b[i].end();jt=it++) pre[dy[*it]]=*jt;
	while (tp) pushup(st[tp--]);
	while (m--)
	{
		read(x);read(z);read(y);z^=ans;y^=ans;
		if (x==1) mdf(); else
		{
			read(x);x^=ans;xz=inf;dz=0;gc=-1;cc=0;
			if (z==y) {puts("Yes");++ans;continue;}
			find1(1);
			if (x==0)
			{
				if (xz==dz) puts("Yes"),++ans; else puts("No");continue;
			}
			if ((cc>=z)||((ll)(y-z)*x!=dz-xz)) {puts("No");continue;}++z;
			find2(1);
			if (gc%x) puts("No"); else {puts("Yes");++ans;}
		}
	}
}
```


---

## 作者：flower1 (赞：5)

## Solution

看了其他人的做法，感觉维护相邻差分的 $\gcd$ 还是有点难想到的，于是就有了这篇暴力随机化做法。

对于一个长度为 $n$ 的序列 $a$，设其最小值为 $a_1$，最大值为 $a_n$，如果它排序后能构成公差为 $d$ 的等差数列，要满足以下几点：

1. $a_n-a_1 = d \cdot (n-1) $。
2. 序列中不存在重复元素。
3. $\forall a_i,(a_i - a_1) \mid d$。

对于第一点，可以用线段树维护区间最大值与最小值。

对于第二点，可以求出每个元素，和它相同元素上一次出现的位置，如果区间所有元素上一次出现的位置小于左端点，那么区间中就没有重复元素。

可以采用线段树维护区间最值，用 $map$ 离散化后套 $set$ 动态维护。

对于第三点，一个很经典的做法就是随机化。

首先，若每个 $a_i-a_1$ 都能整除 $d$ ，则它们的和也一定能整除 $d$。

我们开 10  个树状数组维护区间和，对于序列的每个位置，树状数组都随机以 $\frac{1}{2}$ 的概率维护这个值，如果有任意一个树状数组的区间和不能整除 $d$ ，那么就不合法，这样做程序错误的概率很低。

时间复杂度 $O(n \log^2 n)$，空间复杂度 $O(n \log n)$，理论上难以通过，但由于数据极水可以 AC。

```
#include <bits/stdc++.h>
#define lowbit(x) x&(-x)
#define ls k<<1
#define rs k<<1|1
using namespace std;
typedef long long ll;
const int N=3e5+5,M=10;
int n,m,idx,a[N],pr[N],sf[N],ans;
map<int,int>mp;
set<int>st[N<<1];
struct node{
	int mi,mx,p,gd;
};
struct tree1{
	node tr[N<<2];
	node pushup(node x,node y,int mid){
		node k;
		k.mi=min(x.mi,y.mi);
		k.mx=max(x.mx,y.mx); 
		k.p=max(x.p,y.p);
		k.gd=__gcd(__gcd(x.gd,y.gd),abs(a[mid]-a[mid+1]));
		return k;
	}
	void build(int k,int l,int r){
		if(l==r){
			tr[k]=(node){a[l],a[l],pr[l],0};
			return;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid),build(rs,mid+1,r);
		tr[k]=pushup(tr[ls],tr[rs],mid);
	}
	void modify(int k,int l,int r,int x){
		if(l==r){
			tr[k]=(node){a[l],a[l],pr[l],0};
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid) modify(ls,l,mid,x);
		if(mid+1<=x) modify(rs,mid+1,r,x);
		tr[k]=pushup(tr[ls],tr[rs],mid);
	}
	node query(int k,int l,int r,int x,int y){
		if(x<=l&&r<=y)
			return tr[k];
		int mid=(l+r)>>1;
		if(x<=mid&&mid+1<=y) return pushup(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y),mid);
		else if(x<=mid) return query(ls,l,mid,x,y);
		else return query(rs,mid+1,r,x,y);
	}
}stk;
struct tree2{
	ll c[N];
	int d[N];
	bool vis[N];
	void build(){
		for(int i=1;i<=n;i++){
			if(rand()%2==0)
				vis[i]=true;
			add(i,a[i]);
		}
	}
	void add(int x,int v){
		if(vis[x]) return;
		for(int i=x;i<=n;i+=lowbit(i)){
			c[i]+=v;
			if(v>0) d[i]++;
			else d[i]--; 
		}
	}
	ll sum(int x){
		ll res=0;
		for(int i=x;i>=1;i-=lowbit(i))
			res+=c[i];
		return res;	
	}
	ll query(int x,int y){
		return sum(y)-sum(x-1);
	}
	int sum2(int x){
		ll res=0;
		for(int i=x;i>=1;i-=lowbit(i))
			res+=d[i];
		return res;	
	}
	int query2(int x,int y){
		return sum2(y)-sum2(x-1);
	}
}str[12];
int read(){
	int k=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9')
		k=k*10+ch-'0',ch=getchar();
	return k; 
}
int main(){
    srand(time(NULL));
	int opt,l,r,x,y;
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(!mp.count(a[i]))
			mp[a[i]]=++idx;
		auto it=st[mp[a[i]]].end(); 
		if(it!=st[mp[a[i]]].begin()){
			it--;
			pr[i]=*it,sf[*it]=i;
		}
		st[mp[a[i]]].insert(i);
	}
	stk.build(1,1,n);
	for(int i=1;i<=M;i++)
		str[i].build();
	for(int i=1;i<=m;i++){
		opt=read();
		if(opt==1){
			x=read()^ans,y=read()^ans;
			if(a[x]==y)
				continue;
			if(pr[x]) sf[pr[x]]=sf[x];
			if(sf[x]) pr[sf[x]]=pr[x],stk.modify(1,1,n,sf[x]);
			st[mp[a[x]]].erase(x);
			if(!mp.count(y))
				mp[y]=++idx;
			if(st[mp[y]].size()>0){
				auto it=st[mp[y]].lower_bound(x);
				if(it==st[mp[y]].end()){
					sf[x]=0;
					if(it!=st[mp[y]].begin()){
						it--;
						sf[*it]=x;
						pr[x]=*it;
					}
					else
						pr[x]=0;
				}
				else{
					sf[pr[*it]]=x,pr[x]=pr[*it];
					sf[x]=*it,pr[*it]=x;
					stk.modify(1,1,n,sf[x]);
				}
			}
			else
				pr[x]=0,sf[x]=0;
			for(int j=1;j<=M;j++)
				str[j].add(x,-a[x]),str[j].add(x,y);
			a[x]=y;
			stk.modify(1,1,n,x);
			st[mp[y]].insert(x);
		}
		else{
			l=read()^ans,r=read()^ans,x=read()^ans;
			node t=stk.query(1,1,n,l,r);
			if((r-l!=0)&&((x>0&&t.p>=l)||t.mx-t.mi!=(r-l)*x))
				printf("No\n");
			else if(x==0)
				printf("Yes\n"),ans++;
			else{
				int vl=0;
				for(int j=1;j<=M;j++){
					if((str[j].query(l,r)-1ll*t.mi*str[j].query2(l,r))%x!=0){
						vl=1;
						break;
					}
				}
				if(vl)
					printf("No\n");
				else
					printf("Yes\n"),ans++; 
			}
		}
	}
	return 0;
}
```

---

## 作者：Sktic (赞：5)

update:

2020-10-07 添加程序代码，修改 $latex$ 公式，优化题解讲解

前置芝士：[Luogu3792](https://www.luogu.com.cn/problem/P3792)
### Solution
首先,我们设这个等差数列的首项为 $t$,项数为 $n$,公差为 $k$

这道题就是一个维护区间 $hash$ 的思想，
我们要维护区间的 $\min$ 和 $\max$，这样能够知道首项和末项。

然后我们可以发现这个等差数列的性质：

1.$(\max-\min)=k(r-l)$

2.公差为 $k$ 的等差数列中任意选出两个元素，他们的差一定是k的倍数。

3.区间[l,r]的数不重复

这其中有一个坑：$l==r$是也算一个等差数列，但是公差 $k$ 为 $0$。

于是考虑用线段树维护差分区间数组 $\gcd$，$\min$&$\max$ 值，各点前驱，hash套set维护数字出现位置，然后维护区间 $\gcd$，但就可以保证上面三条性质达成。

时间复杂度 $O( mlog^2n )$。

### Code

完整代码过长，此处就不贴了，这里附上关键代码
```C++
while(t--)
{
	cin>>opt>>z>>y;
	z^=ans,y^=ans;//异或 
	if(opt==1)
	{
   		add(z,y);
   } 
	else
	{
		cin>>k;
		k^=ans;
		mn=INF;
		mx=0;
		g=-1;
		c=0;
		if(z==y) //l==r 特判 
		{
			puts("Yes");
			ans++;
			continue;
		}
		find_minmax(mn,mx,1);//找min,max值 
		if(k==0)//公差为0 
		{
			if(mx==mn)//若最大最小值相等 
			{
				cout<<"Yes\n";
				ans++;
			}
			else
			{
				cout<<"No\n";
			}
			continue;
		}
		if((c>=z)||((long long)(y-z)*k!=mx-mn))//不符合等差数列性质 
		{
			cout<<"No\n";
			continue;
		}
		z++;
		find_gcd(g,1);//找区间gcd 
		if(g%k!=0)//区间不能整除k 
		{
			cout<<"No\n";
			continue;
		}
		else
		{
			cout<<"Yes\n";
			ans++;
			continue; 
		}
	}
}
```

---

## 作者：BlackPanda (赞：3)

首先考虑等差数列性质。一段区间 $[l,r]$ 排序后记为 $a$，当且仅当 $a$ 满足如下条件时，称 $a$ 为公差为 $d$ 的等差数列。

- $\max{a_i}=\min{a_i} + d\times (r-l+1)$
- $\gcd\limits_{i=l+1}^{r}{a_i-a_{i-1}} = d$
- $a$ 中无重复元素

对于前两个条件，我们可以用两棵线段树分别维护序列 $a$ 的区间最值和 $a$ 的差分序列的区间 $\gcd$。

对于第三个条件，可以在线段树上维护序列每个元素的前驱（上次出现的位置）， 操作 $2$ 查询一下前驱的区间最大值，如果最大值不小于 $l$，则 $[l,r]$ 区间内某个值有重复。反之无重复。

操作 $1$ 单点修改时，二分查询一下 $a_x$ 在 $x$ 后下一次出现的位置 $nxt$，将 $nxt$ 的前驱更新成 $x$ 的前驱。最后把新值 $y$ 更新到序列中，并同步更新 $y$ 对应相邻位置的前驱即可。

需要注意本题空间限制以及公差为 $0$ 的情况。

```cpp
int n, m;
int a[N];
int lst[N];
map<int, set<int> > pos;
/*====================*/
struct Ans {
    int maxv, minv;
    LL sum;
};
struct Tree {
    int l, r;
    int val, maxv, minv;
    LL maxl;
} tree[N << 2];
int ls(int p) { return p << 1; }
int rs(int p) { return p << 1 | 1; }
void PushUp(int p) {
    tree[p].val = tree[ls(p)].val + tree[rs(p)].val;
    tree[p].maxv = max(tree[ls(p)].maxv, tree[rs(p)].maxv);
    tree[p].maxl = max(tree[ls(p)].maxl, tree[rs(p)].maxl);
    tree[p].minv = min(tree[ls(p)].minv, tree[rs(p)].minv);
}
void Build(int p, int l, int r) {
    tree[p].l = l, tree[p].r = r;
    if (l == r) {
        tree[p].maxv = tree[p].minv = tree[p].val = a[l];
        tree[p].maxl = lst[l];
    } else {
        int mid = (l + r) >> 1;
        Build(ls(p), l + 0, mid);
        Build(rs(p), mid + 1, r);
        PushUp(p);
    }
}
void Change(int p, int x, int d) {
    if (tree[p].l == tree[p].r) {
        tree[p].maxv = tree[p].minv = tree[p].val = d;
    } else {
        int mid = (tree[p].l + tree[p].r) >> 1;
        if (x <= mid)Change(ls(p), x, d);
        if (mid < x) Change(rs(p), x, d);
        PushUp(p);
    }
}
void pChange(int p, int x) {
    if (tree[p].l == tree[p].r) {
        tree[p].maxl = lst[x];
    } else {
        int mid = (tree[p].l + tree[p].r) >> 1;
        if (x <= mid)pChange(ls(p), x);
        if (mid < x) pChange(rs(p), x);
        PushUp(p);
    }
}
Ans Ask(int p, int l, int r) {
    if (l <= tree[p].l && tree[p].r <= r) {
        return (Ans) { tree[p].maxv, tree[p].minv, tree[p].val };
    } else {
        int resmx = -1, resmi = inf;
        LL res = 0;
        int mid = (tree[p].l + tree[p].r) >> 1;
        if (l <= mid) {
            Ans ans = Ask(ls(p), l, r);
            resmx = max(resmx, ans.maxv);
            resmi = min(resmi, ans.minv);
            res += ans.sum;
        }
        if (mid < r) {
            Ans ans = Ask(rs(p), l, r);
            resmx = max(resmx, ans.maxv);
            resmi = min(resmi, ans.minv);
            res += ans.sum;
        }
        return { resmx, resmi, res };
    }
}
int pAsk(int p, int l, int r) {
    if (l <= tree[p].l && tree[p].r <= r) {
        return tree[p].maxl;
    } else {
        int res = -inf;
        int mid = (tree[p].l + tree[p].r) >> 1;
        if (l <= mid) {
            res = max(res, pAsk(ls(p), l, r));
        }
        if (mid < r) {
            res = max(res, pAsk(rs(p), l, r));

        }
        return res;
    }
}
/*====================*/
int c[N];
struct gcdTree {
    int l, r;
    int gd;
} ct[N << 2];
void cPushUp(int p) {
    ct[p].gd = __gcd(ct[ls(p)].gd, ct[rs(p)].gd);
}
void cBuild(int p, int l, int r) {
    ct[p].l = l, ct[p].r = r;
    if (l == r) {
        ct[p].gd = c[l];
    } else {
        int mid = (l + r) >> 1;
        cBuild(ls(p), l + 0, mid);
        cBuild(rs(p), mid + 1, r);
        cPushUp(p);
    }
}
void cChange(int p, int x) {
    if (ct[p].l == ct[p].r) {
        ct[p].gd = c[x];
    } else {
        int mid = (ct[p].l + ct[p].r) >> 1;
        if (x <= mid)cChange(ls(p), x);
        if (mid < x) cChange(rs(p), x);
        cPushUp(p);
    }
}
int cAsk(int p, int l, int r) {
    if (l <= ct[p].l && ct[p].r <= r) {
        return ct[p].gd;
    } else {
        int res = 0;
        int mid = (ct[p].l + ct[p].r) >> 1;
        if (l <= mid)res = __gcd(res, cAsk(ls(p), l, r));
        if (mid < r) res = __gcd(res, cAsk(rs(p), l, r));
        return res;
    }
}
/*====================*/
void Solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        c[i] = abs(a[i] - a[i - 1]);
    }
    memset(lst, -1, sizeof lst);
    for (int i = 1; i <= n; i++) {
        if (pos[a[i]].size()) lst[i] = *(--pos[a[i]].end());
        pos[a[i]].insert(i);
    }
    // for (int i = 1; i <= n; i++) {
    //     cout << lst[i] << " ";
    // }
    Build(1, 1, n);
    cBuild(1, 1, n - 1);
    int cntyes = 0;
    // a[i]-a[i-1];
    // y-a[i-1];
    while (m--) {
        int op; cin >> op;
        if (op == 1) {
            int x, y; cin >> x >> y;
            x ^= cntyes, y ^= cntyes;
            // cout << x << " " << y << "";
            // assert(x >= 1 && x <= n);
            auto it = pos[a[x]].find(x);
            if (it != pos[a[x]].end()) {
                ++it;
                lst[*it] = lst[x];
                pChange(1, *it);
            }
            if (pos[a[x]].size())
                pos[a[x]].erase(x);
            a[x] = y;
            it = pos[y].lower_bound(x);
            if (it != pos[y].end()) {
                lst[*it] = x;
                pChange(1, *it);
            }
            if (it == pos[y].begin()) {
                lst[x] = -1;
                pChange(1, x);
            } else {
                it--;
                lst[x] = *it;
                pChange(1, x);
                // pos[y].insert(x);
            }
            Change(1, x, y);
            c[x] = abs(y - a[x - 1]);
            pos[y].insert(x);
            cChange(1, x);
            if (x + 1 <= n) {
                c[x + 1] = abs(a[x + 1] - y);
                cChange(1, x + 1);
            }
        } else {
            int l, r, k; cin >> l >> r >> k;
            l ^= cntyes, r ^= cntyes, k ^= cntyes;
            // cout << l << " " << r << " " << k << "@";
            // assert(l >= 1 && l <= n); assert(r >= 1 && r <= n); assert(l <= r);
            if (r - l + 1 == 1) {
                cout << "Yes" << endl;
                cntyes++;
                continue;
            }
            auto [maxx, minn, sum] = Ask(1, l, r);
            if (k == 0) {
                cout << (maxx == minn ? "Yes" : "No") << endl;
                if (maxx == minn) cntyes++;
                continue;
            }
            if (maxx - minn != k * (r - l)) {
                cout << "No" << endl;
                continue;
            }
            if (cAsk(1, l + 1, r) != k) {
                cout << "No" << endl;
                continue;
            }
            if (pAsk(1, l, r) >= l) {
                cout << "No" << endl;
                continue;
            }
            cout << "Yes" << endl;
            cntyes++;
        }
    }
    return;
}
```

---

## 作者：114514xxx (赞：2)

考虑对于数列 $\{a_n\}$ 如何判别为等差数列。暴力排序单次时间复杂度就来到了 $O(n \log n)$，太慢了，我们需要更快的方法。

先考虑 $k=0$ 的情况。仅需 $\displaystyle\max^{n}_{i=1}a_i=\min^{n}_{i=1}a_i$ 即可。

接下来考虑 $k > 0$ 的情况。首先 $\displaystyle\max^{n}_{i=1}a_i-\min^{n}_{i=1}a_i =(n-1)k$。我们发现这仅仅是一个充分不必要条件，因此我们还要更多的条件。注意到任意的 $a_i$ 都可以表示为 $a_i=\min^{n}_{i=1}a_i + mk$，其中 $0\le m \le n-1$，且 $m$ 为整数。进一步讲就是所有的 $a_i$ 对 $k$ 是同余的。并且所有 $a_i$ 也都是互异的。

于是我们尝试维护，但发现所有的 $a_i$ 对 $k$ 是同余的是不好维护的，因此我们转用数列 $\{a_n\}$  的差分数列 $\{d_n\}$ 进行维护，根据上面结论我们知道了所有 $d_i$ 都是 $k$ 的倍数。因此只要 $\gcd(d_1,d_2,\ldots,d_n)=k$ 就代表有的 $a_i$ 对 $k$ 是同余的了。

如何维护所有数互异呢，`set` 套 `map` 后放到线段树上即可。

总结得到以下条件：

1. $\displaystyle\max^{n}_{i=1}a_i-\min^{n}_{i=1}a_i =(n-1)k$
2. 设 $d_i=a_i-a_{i-1}$，且 $\gcd(d_1,d_2,\ldots,d_n)=k$
3. 所有数互异

上面这些条件线段树维护就可以了，时间复杂度 $O(n \log^2 n)$。两个 $\log$ 分别来自线段树和 $\gcd$。

放下代码。

```cpp
#include<bits/stdc++.h>
#define ls p*2
#define rs p*2+1
using namespace std;
const int N=3e5+25;
const int inf=2e9;
char *p1,*p2,buf[1<<21];
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
#define readin(fn) FILE *fin = freopen(#fn ".in", "r", stdin)
#define output(fn) FILE *fout = freopen(#fn ".out", "w", stdout)
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<48|ch>57){
        ch=getchar();
        if(ch=='-')f*=-1;
    }
    while(ch>=48&&ch<=57)
        x=(x*10)+(ch^48),ch=getchar();
    return x*f;
}
int gcd(int a, int b) {
    if(!a||!b)return a+b;
    int az=__builtin_ctz(a);
    int bz=__builtin_ctz(b);
    int z=min(az,bz);
    b>>=bz;
    int diff=0;
    while (a){
        a>>=az;
        diff=a-b;
        az=__builtin_ctz(diff);
        b=min(a,b),a=abs(diff);
    }
    return b<<z;
}//Binary GCD，比一般 GCD 更快一些
struct SegmentTree1{
    struct node{
        int l,r,maxn,minn;
    }t[N<<2];
    inline void update(int p){
        t[p].maxn=max(t[ls].maxn,t[rs].maxn);
        t[p].minn=min(t[ls].minn,t[rs].minn);
    }
    inline void build(int p,int l,int r,int *a){
        t[p].l=l,t[p].r=r;
        if(l==r){
            t[p].maxn=a[l];t[p].minn=a[l];
            return;
        }
		int mid=(l+r)>>1;
		build(ls,l,mid,a);
		build(rs,mid+1,r,a);
        update(p);
    }
    inline void modify(int p,int x,int k){
        if(t[p].l==t[p].r&&t[p].l==x){
            t[p].maxn=t[p].minn=k;
            return;
        }
        int mid=(t[p].l+t[p].r)>>1;
        if(x<=mid)modify(ls,x,k);
        if(x>mid)modify(rs,x,k);
        update(p);
    }
    inline int query_max(int p,int l,int r){
        if(t[p].l>=l&&t[p].r<=r)return t[p].maxn;
        int ans=0;
        int mid=(t[p].l+t[p].r)>>1;
        if(l<=mid)ans=max(ans,query_max(ls,l,r));
        if(r>mid)ans=max(ans,query_max(rs,l,r));
        return ans;
    }
    inline int query_min(int p,int l,int r){
        if(t[p].l>=l&&t[p].r<=r)return t[p].minn;
        int ans=inf;
        int mid=(t[p].l+t[p].r)>>1;
        if(l<=mid)ans=min(ans,query_min(ls,l,r));
        if(r>mid)ans=min(ans,query_min(rs,l,r));
        return ans;
    }   
}t1,t2;
struct GcdTree{
    struct node{
        int l,r,val;
    }t[N<<2];
    inline void update(int p){t[p].val=gcd(t[ls].val,t[rs].val);}
    inline void build(int p,int l,int r,int *a){
        t[p].l=l,t[p].r=r;
        if(l==r){t[p].val=a[l];return;}
        int mid=(l+r)>>1;
        build(ls,l,mid,a);
        build(rs,mid+1,r,a);
        update(p);
    }
    inline void modify(int p,int x,int k){
        if(t[p].l==t[p].r&&t[p].l==x){
            t[p].val=k;
            return;
        }
        int mid=(t[p].l+t[p].r)>>1;
        if(x<=mid)modify(ls,x,k);
        if(x>mid)modify(rs,x,k);
        update(p);
    }
    inline int query(int p,int l,int r){
        if(t[p].l>=l&&t[p].r<=r)return t[p].val;
        int mid=(t[p].l+t[p].r)>>1,ans=0;
        if(l<=mid)ans=gcd(ans,query(ls,l,r));
        if(r>mid)ans=gcd(ans,query(rs,l,r));
        return ans;
    }
}gcdt;
set<int>s[N<<1];
unordered_map<int,int>mp;
int n,m,a[N],d[N];
int pre[N],suf[N];
signed main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)d[i]=abs(a[i]-a[i-1]);
    t1.build(1,1,n,a);
    gcdt.build(1,1,n,d);
    int idx=0;
    for(int i=1;i<=n;i++){
        if(!mp.count(a[i]))mp[a[i]]=++idx;
        auto it=s[mp[a[i]]].end();
        if(it!=s[mp[a[i]]].begin())--it,pre[i]=*it,suf[*it]=i;
        s[mp[a[i]]].insert(i);
    }
    t2.build(1,1,n,pre);
    int op,x,y,l,r,k;
    int lastans=0;
    while(m--){
         op=read();
        if(op==1){
            x=read(),y=read();
            x^=lastans,y^=lastans;
            if(a[x]==y)continue;
            s[mp[a[x]]].erase(x);
            a[x]=y;
            d[x]=a[x]-a[x-1];
            d[x+1]=a[x+1]-a[x];
            d[x]=abs(d[x]),d[x+1]=abs(d[x+1]);
            int tmp1=suf[x];
            if(pre[x])suf[pre[x]]=suf[x];
            if(suf[x])pre[suf[x]]=pre[x];
            t2.modify(1,tmp1,pre[suf[x]]);
            t1.modify(1,x,a[x]);
            gcdt.modify(1,x,d[x]);
            if(x<n)gcdt.modify(1,x+1,d[x+1]);
            if(!mp.count(y))mp[y]=++idx;
            if(s[mp[y]].size()>0){
                auto it=s[mp[y]].lower_bound(x);
                if(it==s[mp[y]].end()){
                    suf[x]=0;
                    if(it!=s[mp[y]].begin()){
                        --it;
                        pre[x]=*it;
                        suf[*it]=x;
                    }else pre[x]=0;
                }else{
                    suf[pre[*it]]=x,pre[x]=pre[*it];
                    suf[x]=*it,pre[*it]=x;
                    t2.modify(1,*it,pre[*it]);
                    t2.modify(1,suf[x],x);
                }
            }else pre[x]=suf[x]=0;
            s[mp[y]].insert(x);
            t2.modify(1,x,pre[x]);
        }else{
            l=read(),r=read(),k=read();
            l^=lastans,r^=lastans,k^=lastans;
            if(l>r)continue;
            int maxf=t1.query_max(1,l,r);
            int minf=t1.query_min(1,l,r);
            if(k==0&&maxf==minf){cout<<"Yes\n",++lastans;continue;}
            if(l==r){cout<<"Yes\n",++lastans;continue;}
            int val=gcdt.query(1,l+1,r);
            if(val!=k){cout<<"No\n";continue;}
            if((long long)(maxf-minf)!=(long long)((r-l)*k)){cout<<"No\n";continue;}
            int pref=t2.query_max(1,l,r);
            //cout<<maxf<<' '<<minf<<' '<<val<<' '<<pref<<'\n';
            if(pref>=l){cout<<"No\n";continue;}
            if((long long)(maxf-minf)==(long long)((r-l)*k)&&pref<l)
                cout<<"Yes\n",++lastans;
            else cout<<"No\n";
        }
    }
}
```

---

## 作者：lflby (赞：2)

# 思路

首先，我们考虑等差数列，要确定首项和末项，不难想到要维护区间最大最小值。

然后考虑一个等差数列的性质：

公差为 $k$ 的等差数列中任意选出两个元素，他们做差一定是 $k$ 的倍数。

把一个等差数列重排一下，然后做一个差分，这个差分数组的最大公约数等于题目给定值时，才可成立。

考虑还需要什么？还需要区间中不能出现重复的数。

这个我们对每个数维护前驱，然后变成一个数点的问题了。

所以，总结一下要满足的条件：

1. $maxn-minn = k \times (r-l+1)$；
2. 所有区间内的值的差的最大公约数为 $k$；
3. 区间内所有值各不相同。

## 条件一二

线段树板子，不再赘述。

## 条件三

记录每个数的前驱，要求区间所有数的前驱小于 $l$，或 $k=0$ 时，要求 $maxn=minn$。

### 预处理

```cpp
map<int,set<int> > ma;
for (int i = 1; i <= n; i++)
{
	a[i]=read();
	c[i]=abs(a[i]-a[i-1]);//差分
	if (ma[a[i]].size()==0) pre[i]=-1;
	else pre[i]=*ma[a[i]].rbegin();
	ma[a[i]].insert(i);
}
```

### 添加时代码

**注意：原位的后继也要修改。**

```cpp
auto lzx = ma[a[x]].find(x);//先找到原来的位置
lzx++;
if (lzx!=ma[a[x]].end())
{
	auto cpn = lzx;
	cpn--;
	if (cpn!=ma[a[x]].begin()) cpn--,pre[*lzx]=*cpn;
	else pre[*lzx]=-1;
	mod1(1,*lzx);
}//修改原来后继的前驱
lzx--;
ma[a[x]].erase(lzx);//删除原位置
ma[y].insert(x);//加入新位置
auto ljk = ma[y].lower_bound(x);
if (ljk==ma[y].begin()) pre[x]=-1;
else ljk--,pre[x]=*ljk;//找到新位置的前驱
```

其他代码可自行理解，不再赘述。

# 代码


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
	int res = 0,f = 1;
	char ch = getchar();
	while (ch<'0'||ch>'9') f = (ch=='-'?-1:1),ch = getchar();
	while (ch>='0'&&ch<='9') res = (res<<3)+(res<<1)+(ch^48),ch = getchar();
	return res*f;
}
void write(int x)
{
	if (x<0) putchar('-'),x=-x;
	if (x>9) write(x/10);
	putchar(x%10+'0');
}
void writech(int x,char ch){write(x),putchar(ch);}
const int N = 3e5+5;
int n,m;
int a[N],c[N],pre[N];
struct tree
{
	int l,r;
	int maxn,minn,pre;
	int gcd;
}tr[4*N];
void pushup(int x)
{
	tr[x].maxn=max(tr[2*x].maxn,tr[2*x+1].maxn);
	tr[x].minn=min(tr[2*x].minn,tr[2*x+1].minn);
	tr[x].pre=max(tr[2*x].pre,tr[2*x+1].pre);
	tr[x].gcd=__gcd(tr[2*x].gcd,tr[2*x+1].gcd);
}
void bt(int x,int l,int r)
{
	tr[x].l=l,tr[x].r=r;
	if (l==r)
	{
		tr[x].maxn=tr[x].minn=a[l];
		tr[x].gcd=c[l];
		tr[x].pre=pre[l];
		return ;
	}
	int mid = (l+r)/2;
	bt(2*x,l,mid);
	bt(2*x+1,mid+1,r);
	pushup(x);
}
void mod1(int x,int q)
{
	int l = tr[x].l,r = tr[x].r;
	if (l==q&&r==q)
	{
		tr[x].maxn=tr[x].minn=a[l];
		tr[x].pre=pre[l];
		return ;
	}
	int mid = (l+r)/2;
	if (q<=mid) mod1(2*x,q);
	else mod1(2*x+1,q);
	pushup(x);
}
void mod2(int x,int q)
{
	int l = tr[x].l,r = tr[x].r;
	if (l==q&&r==q)
	{
		tr[x].gcd=c[l];
		return ;
	}
	int mid = (l+r)/2;
	if (q<=mid) mod2(2*x,q);
	else mod2(2*x+1,q);
	pushup(x);
}
tree query(int x,int ql,int qr)
{
	int l = tr[x].l,r = tr[x].r;
	if (ql<=l&&r<=qr) return tr[x];
	int mid = (l+r)/2;
	tree ll,rr;
	bool hl=false,hr=false;
	if (ql<=mid) ll = query(2*x,ql,qr),hl=true;
	if (qr>mid) rr = query(2*x+1,ql,qr),hr=true;
	if (hl&&hr)
	{
		tree res;
		res.l=ll.l,res.r=rr.r;
		res.maxn=max(ll.maxn,rr.maxn);
		res.minn=min(ll.minn,rr.minn);
		res.pre=max(ll.pre,rr.pre);
		return res;
	}
	if (hl) return ll;
	else return rr;
}
int query2(int x,int ql,int qr)
{
	int l = tr[x].l,r = tr[x].r;
	if (ql<=l&&r<=qr) return tr[x].gcd;
	int mid = (l+r)/2;
	int res = -1;
	if (ql<=mid) res = query2(2*x,ql,qr);
	if (qr>mid) res = (res==-1?query2(2*x+1,ql,qr):__gcd(res,query2(2*x+1,ql,qr)));
	return res;
}
map<int,set<int> > ma;
signed main()
{
	n=read(),m=read();
	for (int i = 1; i <= n; i++)
	{
		a[i]=read();
		c[i]=abs(a[i]-a[i-1]);
		if (ma[a[i]].size()==0) pre[i]=-1;
		else pre[i]=*ma[a[i]].rbegin();
		ma[a[i]].insert(i);
	}
	bt(1,1,n);
	int cnt = 0;
	while (m--)
	{
		int op=read();
		if (op==1)
		{
			int x=read()^cnt,y=read()^cnt;
			auto lzx = ma[a[x]].find(x);
			lzx++;
			if (lzx!=ma[a[x]].end())
			{
				auto cpn = lzx;
				cpn--;
				if (cpn!=ma[a[x]].begin()) cpn--,pre[*lzx]=*cpn;
				else pre[*lzx]=-1;
				mod1(1,*lzx);
			}
			lzx--;
			ma[a[x]].erase(lzx);
			ma[y].insert(x);
			auto ljk = ma[y].lower_bound(x);
			if (ljk==ma[y].begin()) pre[x]=-1;
			else ljk--,pre[x]=*ljk;
			a[x]=y;
			c[x]=abs(a[x]-a[x-1]);
			c[x+1]=abs(a[x+1]-a[x]);
			mod1(1,x);
			mod2(1,x);
			if (x+1<=n) mod2(1,x+1);
		}
		else
		{
			int l=read()^cnt,r=read()^cnt,k=read()^cnt;
			if (l==r){puts("Yes");cnt++;continue;}
			tree dlf = query(1,l,r);
			int maxn = dlf.maxn,minn = dlf.minn,mpre = dlf.pre;
			int d = query2(1,l+1,r);
			if (maxn-minn!=k*(r-l)){puts("No");continue;}
			if (k&&mpre>=l){puts("No");continue;}
			if (d!=k){puts("No");continue;}
			puts("Yes");cnt++;
		}
	}
	return 0;
}

```

代码稍长，谨慎使用。

---


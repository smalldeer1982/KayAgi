# [SNOI2019] 数论

## 题目描述

给出正整数 $P,Q,T$ ，大小为 $n$ 的整数集 $A$ 和大小为 $m$ 的整数集 $B$ ，请你求出：

$$
\sum_{i=0}^{T-1}[(i\bmod P) \in A \land (i\bmod Q) \in B]
$$


换言之，就是问有多少个小于 $T$ 的非负整数 $x$ 满足：$x$ 除以 $P$ 的余数属于 $A$ 且 $x$ 除以 $Q$ 的余数属于 $B$。

## 说明/提示

对于所有数据，$1 \leq n,m \leq 10^6 , 1 \leq P,Q \leq 10^6 , 1 \leq T \leq 10^{18}$。

对于10%的数据，$T \leq 10^6$。

对于另外20%的数据，$P,Q \leq 1000$。

对于另外10%的数据，$T$是$P,Q$的公倍数。

对于另外10%的数据，$P,Q$互质，且$P,Q \leq 10^5$。

对于另外10%的数据，$P,Q$互质。

对于另外10%的数据，$P,Q \leq 10^5$。

对于余下30%的数据，无特殊限制。

- 2023.11.17 添加三组 hack 数据。

## 样例 #1

### 输入

```
4 6 3 3 14
0 1 3
2 4 5```

### 输出

```
4```

# 题解

## 作者：Vocalise (赞：11)

## 题意

求 $T$ 以内模 $P$ 值属于集合 $A$ 且 模 $B$ 值属于集合 $B$ 的数的数量。

$T\le 10^{18},P,Q,|A|,|B|\le 10^6$

---

首先对一个模型作介绍。

对于 $[0,Q)$ 中的数都建立一个点，若点 $i$ 连一条边至 $(i+P)\mod Q$，那么整个图会分为 $\gcd(P,Q)$ 个独立的环，每个环的点数是 $\dfrac{\operatorname{lcm(P,Q)}}{P}$。

说明：

每一个点走若干个 $P$ 步回到自己，同时经过了若干个 $Q$ 总长，因此经过的总长是 $\operatorname{lcm(P,Q)}$，点数 $\dfrac{\operatorname{lcm(P,Q)}}{P}$。而总点数 $Q$，所以环数 $Q/(\dfrac{\operatorname{lcm(P,Q)}}{P})=\gcd(P,Q)$。

假设 $P \le Q$。因为 $[0,P)$ 中的数要不变地唯一对应到 $[0,Q)$ 中的一个数。

在这个图上考虑问题，我们可以枚举 $a_i$，在图上直接找到它，考虑它沿边走 $k$ 步得到的数是 $(a_i + kP)\mod Q$，我们需要计算包括自己，在 $T-1$ 以内，一共经过多少 $b_i$。

要解决的问题直观了起来。我们可以在图上标记所有 $b_i$ 权值为 $1$ 其余为 $0$，预处理环上总和与 $1$ 圈以内的前缀和。

对于 $a_i$，包括自己一共要统计 $\lfloor\dfrac{T-1-a_i}{P}\rfloor+1$ 个点。首先直接计算整圈，然后对于留下的不满一圈的路径，分类讨论一下计算即可。

要注意的是：前缀和中选定的起点值是 $0$ 还是总和；$t-1-a_i<0$ 要直接舍弃。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

typedef long long ll;
const int N = 1000001;

inline ll read() {
	ll x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int gcd(int x,int y) { return !y ? x : gcd(y,x % y); }

int P,Q,n,m,a[N],b[N]; ll t;
int vis[N],at[N]; ll dist[N],ring[N],sum[N],len;

ll Prefix(ll a,ll x) {
	if(!x) return 0;
	ll b = (a + (x - 1) * P) % Q;
	if(x + dist[a] > len) return sum[a] - (ring[a] - ring[b] - at[a]);
	else return ring[b] - ring[a] + at[a];
}

ll Calc(ll T) {
	ll ans = 0;
	for(int i = 1;i <= n;i++) {
		if(T < a[i]) continue;
		ll st = (T - a[i]) / P + 1;
		ans += st / len * sum[a[i]] + Prefix(a[i],st % len);
	}
	return ans;
}

int main() {
	P = read(), Q = read(), n = read(), m = read(), t = read();
	if(P > Q) {
		std::swap(P,Q), std::swap(n,m);
		for(int i = 1;i <= m;i++) b[i] = read();
		for(int i = 1;i <= n;i++) a[i] = read();
	} else {
		for(int i = 1;i <= n;i++) a[i] = read();
		for(int i = 1;i <= m;i++) b[i] = read();
	}
	for(int i = 1;i <= m;i++) at[b[i]] = true;
	for(int i = 0;i < Q;i++) if(!vis[i]) {
		int p = i, k = (i + P) % Q;
		while(!vis[p]) {
			vis[p] = true, dist[k] = dist[p] + 1;
			ring[k] = ring[p] + at[k];
			p = k, k = (k + P) % Q;
		}
		k = (i + P) % Q, sum[i] = ring[i], ring[i] = dist[i] = 0;
		while(k != i) sum[k] = sum[i], k = (k + P) % Q;
	}
	len = Q / gcd(P,Q);
	std::printf("%lld\n",Calc(t - 1));
	return 0;
}

```

---

## 作者：LCuter (赞：9)

## $\text{Description}$

给定 $T,P,Q$ 和大小为 $n$ 的集合 $A$ 与大小为 $m$ 的集合 $B$，求：
$$
\sum_{i=0}^{T-1}[(i\bmod{P})\in A]\times[(i\bmod{Q})\in B]
$$
$T\le 10^{18},P,Q,n,m\le 10^6$

## $\text{Solution}$

不妨设 $P<Q$。

记 $L=\operatorname{lcm}(P,Q)$，则两个余数有最小正周期 $L$。

对于本题，可以将 $T$ 缩到 $L$ 级别，即我们可以分解为 $[0,L-1]$ 和 $[0,T\bmod{L}]$ 两个子问题。

我们需要一个线性解，可以考虑枚举 $A$ 中的数，然后求出其可以对应的 $B$ 中的数的个数。

观察 $[0,L-1]$ 中的整数可以对应的 $B$ 的个数，首先可以考虑将 $[0,L-1]$ 按其对 $P$ 取模的值分成 $P$ 个递增的序列，然后考虑第 $i$ 个序列的第 $j$ 个数，其对应的原值是 $jP+i$，则其对应的对 $Q$ 取模的值为 $(i+Pj)\bmod{Q}$，容易发现这个东西是循环的，我们将这样的一个循环节称作轨道（自己 yy 的）。

那么每个序列都会属于一个轨道，特别地，若 $P,Q$ 互质，则只存在一个轨道。

注意到无论是 $[0,L-1]$ 还是 $[0,T\bmod{L}]$，我们要求的都是轨道内的一个区间内属于 $B$ 的数的个数，对于一个数 $x$，其权值设为 $[x\in B]$，则我们只需预处理一个轨道的权值和与其权值前缀和，就可以迅速求出环上任意区间的权值和了。

由于所有轨道的数的个数和为 $Q$，故时间复杂度为 $O(P+Q)$。

细节较多，建议参考以下代码。

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
using namespace std;
typedef long long ll;
const int N=1000005;
inline void read(int& x){
	static char c;
	while(!isdigit(c=getchar()));x=c^48;
	while(isdigit(c=getchar()))x=(x*10)+(c^48);
}
inline void read(ll& x){
	static char c;
	while(!isdigit(c=getchar()));x=c^48;
	while(isdigit(c=getchar()))x=(x*10)+(c^48);
}

int n,m;
ll P,Q,T,L;

int A[N],tmp,IB[N],IA[N],Rk[N];

ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
ll lcm(ll a,ll b){return a*b/gcd(a,b);}

vector<ll> PWS[N];

ll Ask(int p,int l,int r){return l<=r?PWS[p][r]-PWS[p][l-1]:PWS[p][r]+PWS[p][PWS[p].size()-1]-PWS[p][l-1];}

inline void Init(){
	read(P),read(Q),read(n),read(m),read(T);L=lcm(P,Q);
	if(P>Q){
    	swap(n,m),swap(P,Q);
    	for(REG int i=1;i<=m;++i) read(tmp),IB[tmp]=1;
    	for(REG int i=1;i<=n;++i) read(A[i]);
        
    }
	else{
    	for(REG int i=1;i<=n;++i) read(A[i]);
    	for(REG int i=1;i<=m;++i) read(tmp),IB[tmp]=1;
    }
	for(REG int i=0;i<P;++i){
	if(Rk[i]) continue;
    	PWS[i].push_back(0);
    	int Now=i;
    	while(!Rk[Now]) PWS[i].push_back(PWS[i][PWS[i].size()-1]+IB[Now]),IA[Now]=i,Rk[Now]=PWS[i].size()-1,Now=(Now+P)%Q;
    }
}

inline void Work(){
	Init();
	ll Per=T/L,Sur=T%L-1;
	ll Ans1=0,Ans2=0;
	for(REG int i=1;i<=n;++i) Ans1+=PWS[IA[A[i]]][PWS[IA[A[i]]].size()-1];
	for(REG int i=1;i<=n;++i) Ans2+=A[i]<=Sur?Ask(IA[A[i]],Rk[A[i]%Q],Rk[(A[i]%Q+(Sur-A[i])/P*P%Q)%Q]):0ll;
	printf("%lld\n",Per*Ans1+Ans2);
}

int main(){Work();}
```



---

## 作者：81179332_ (赞：8)

设我们要找有多少个数 $x$ 满足条件

对于每个 $a_i$，有 $x\equiv a_i \pmod P$，则 $x=a_i+kP$，对于这些 $x$，我们找有多少 $x$ 满足 $x\in B \pmod Q$

如果 $P > Q$，可能会有多个 $a_i$ 在 $\bmod Q$ 意义下相等，所以我们对于这种情况，可以交换一下 $P,Q$，注意同时交换其他变量

由于 $a_i+kP<T$,则 $k\le \lfloor \dfrac{T - 1 - a_i}{P} \rfloor$

在模 $Q$ 意义下，当 $kP\equiv 0$ 时就会出现循环节，则最小循环节为 $\dfrac{\text{lcm}(P,Q)}{P}=\dfrac Q{\gcd(P,Q)}$

我们对于每一个 $i(0\le i<Q)$，`dfs` 找环、染色、求每个环的权值和以及前缀和

最后对于每个 $a_i$ 计算贡献即可。

注意前缀和的地方不是正常的前缀和，因为使用了 `vector` 下标从 $0$ 开始，如果减一会出现负下标

另外，如果 $T-1<a_i$，算出来的 $\lfloor \dfrac{T - 1 - a_i}{P} \rfloor$ 会是负数，并且是向 $0$ 取整的，会出现问题，由于 $a_i<P\le 10^6$，我们对于 $T \le 10^6$ 暴力求解就好啦

hack 数据：
```
20 20 1 1 1
19
19
```


```cpp
ll gcd(ll a,ll b) { return b ? gcd(b,a % b) : a; }
const int N = 1000010;
ll p,q,n,m,T,a[N],b[N],num[N];
ll len,col[N],t[N],val[N],cnt;
vector<int> v[N],s[N];int pos[N];
ll ans;
void other_solve()
{
	static int booka[N],bookb[N];
	int ans = 0;
	for(int i = 1;i <= n;i++) booka[a[i]] = 1;
	for(int i = 1;i <= m;i++) bookb[b[i]] = 1;
	for(int i = 0;i < T;i++) ans = ans + (booka[i % p] & bookb[i % q]);
	fprint(ans);
}
void dfs(int x,int c)
{
	if(col[x]) return;
	col[x] = c,val[c] += t[x],v[c].push_back(x);
	dfs((x + p) % q,c);
}
int Sum(int len,int x) { return s[col[x]][pos[x] + len] - s[col[x]][pos[x]]; }
int main()
{
	freopen("random.in","r",stdin);
	freopen("sol.out","w",stdout);
	p = read(),q = read(),n = read(),m = read(),T = read();
	for(int i = 1;i <= n;i++) a[i] = read();
	for(int i = 1;i <= m;i++) b[i] = read();
	if(T <= 2000000) { other_solve();return 0; }

	if(p > q) swap(p,q),swap(n,m),swap(a,b);
	
	int len = q / gcd(p,q);
	for(int i = 1;i <= m;i++) t[b[i]] = 1;
	for(int i = 1;i <= n;i++) num[i] = (T - 1 - a[i]) / p;
	for(int i = 0;i < q;i++) if(!col[i]) cnt++,dfs(i,cnt);
	for(int i = 1;i <= cnt;i++)
	{
		for(int j = 0;j < v[i].size();j++) pos[v[i][j]] = j;
		int l = v[i].size();
		for(int j = 0;j < l;j++) v[i].push_back(v[i][j]);
		s[i].push_back(t[v[i][0]]);
		for(int j = 1;j < v[i].size();j++) s[i].push_back(s[i][j - 1] + t[v[i][j]]);
	}
	for(int i = 1;i <= n;i++)
		ans += num[i] / len *val[col[a[i]]] + Sum(num[i] % len,a[i]) + t[a[i]];
	fprint(ans);
}

```

---

## 作者：OIforJoy (赞：8)

## 建议添加标签:
# FFT，NTT.
是的你没有看错...这道题可以用FFT做.

先推一下式子:
$$Ans=\sum_{i=1}^n\sum_{k=0}^{[\frac{T-a_i-1}{p}]}\sum_{j=1}^m[pk\equiv b_j-a_i(mod\ q)]$$
这是先枚举 $x\bmod p$ 再枚举 $[\frac{x}{p}]$ 可以得到的式子.
由于 $0\leq a_i<p$,$[\frac{T-a_i-1}{p}]$ 最多只有2种取值,如果有2个则它们相邻.将$a$和$b$数组从小到大排序,则这1个或2个数中较小者为 $X=[\frac{T-a_n-1}{p}]$,所以我们有:
$$Ans=\sum_{i=1}^n\sum_{k=0}^X\sum_{j=1}^m[pk\equiv b_j-a_i(mod\ q)]+\sum_{i=1}^n[[\frac{T-a_i-1}{p}]>X][p[\frac{T-a_i-1}{p}]+a_i\in B(mod\ q)]$$
前后2项分别计算:

后面一项暴力枚举即可;

前面一项的求值也不难.调换求和符号:
$$\sum_{k=0}^{[\frac{T-a_i-1}{p}]}\sum_{i=1}^n\sum_{j=1}^m[pk\equiv b_j-a_i(mod\ q)]$$
那么如果我们构造2个多项式:$F[i]=[(q-i)\bmod q\in A],G[i]=[i\in B]$(这里 F , G 的次数小于 q),则这2个多项式模 q 循环卷积之后的系数就是上面式子去掉最左边求和符号并且将 $pk$ 替换成对应项的次数后的值,枚举k模q的余数就做完了.

复杂度:$O(p+q\log(q)+m\log(m))$.

代码:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
const int mod=998244353,g=3;
const int MAXN=2097152,expo=21,MAXM=1000010;
int change[MAXN]={0};
inline int square(int x)
{
	return 1ll*x*x%mod;
}
int qpow(int x,int y)
{
	if(y==0)return 1;
	if(y==1)return x;
	if(y&1)return 1ll*qpow(x,y-1)*x%mod;
	return square(qpow(x,y>>1));
}
inline int inv(int x)
{
	return qpow(x,mod-2);
}
void _init()
{
	for(int x=1;x<MAXN-1;x++)
	{
		int y=0,x0=x;
		for(int i=0;i<expo;i++)
		{
			if(x0&1)y+=(1<<(expo-1-i));
			x0>>=1;
		}
		change[x]=y;
	}
}
struct poly
{
	vector<int> data;
	poly(vector<int> d)
	{
		data=d;
		data.resize(MAXN);
	}
	int& operator [] (int ind)
	{
		return data[ind];
	}
	void print(int lim)
	{
		for(int i=0;i<lim;i++)cout<<data[i]<<' ';
	}
	void rev()
	{
		for(int x=1;x<MAXN-1;x++)if(x<change[x])swap(data[x],data[change[x]]);
	}
	void NTT(int type)//1=DFT -1=IDFT
	{
		rev();
		for(int i=2;i<=MAXN;i<<=1)
		{
			int len=i>>1;
			int mul=qpow(g,(mod-1)/i);
			if(type==-1)mul=inv(mul);
			for(int j=0;j<MAXN;j+=i)
			{
				int tmp1=1;
				for(int k=j;k<j+len;k++)
				{
					int tmp2=1ll*tmp1*data[k+len]%mod;
					data[k+len]=((data[k]-tmp2>=0)?(data[k]-tmp2):(data[k]-tmp2+mod));
					data[k]=((data[k]+tmp2<mod)?(data[k]+tmp2):(data[k]+tmp2-mod));
					tmp1=1ll*tmp1*mul%mod;
				}
			}
		}
		int qwerty=inv(MAXN);
		if(type==-1)for(int i=0;i<MAXN;i++)data[i]=1ll*data[i]*qwerty%mod;
	}
};
poly operator * (poly x,poly y)
{
	for(int i=0;i<MAXN;i++)x[i]=1ll*x[i]*y[i]%mod;
	return x;
}
int p,q,n,m,a[MAXM],b[MAXM];
bool inb[MAXM]={0};
long long T;
long long tmp[MAXN]={0};
long long ans=0;
int main()
{
	_init();
	ios::sync_with_stdio(false);
	cin>>p>>q>>n>>m>>T;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		cin>>b[i];
		inb[b[i]]=1;
	}
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	vector<int> v1,v2;
	v1.resize(MAXM);
	v2.resize(MAXM);
	for(int i=1;i<=n;i++)
	{
		v1[(q-a[i]%q)%q]++;
	}
	for(int i=1;i<=m;i++)
	{
		v2[b[i]]++;
	}
	poly F(v1),G(v2);
	F.NTT(1);
	G.NTT(1);
	F=F*G;
	F.NTT(-1);
	for(int i=MAXN-1;i>=0;i--)
	{
		tmp[i]=F[i];
	}
	for(int i=MAXN-1;i>=q;i--)
	{
		tmp[i-q]+=tmp[i];
		tmp[i]=0;
	}
	long long X=(T-a[n]-1)/p;
	for(int i=0;i<q;i++)
	{
		if(X<i)break;
		long long times=1+(X-i)/q;
		ans+=1ll*tmp[1ll*p*i%q]*times;
	}
	for(int i=1;i<=n;i++)if((T-a[i]-1)/p>X)
	{
		ans+=inb[(1ll*p*((T-a[i]-1)/p)+a[i])%q];
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：s_r_f (赞：4)

考虑枚举$a_i$,对给出的$b_i$维护一些信息，以支持快速查询答案。

发现$x + kP$在$k$不断$++$的过程中，在$mod$ $Q$意义下有循环节。

具体来说，考虑建出一张$Q$个点$0,1,2,...Q-1$的图。

对于每个$i(0<=i<Q)$,连边$(i,(i+P)$ $mod$ $Q)$ 

这张图一定由若干个环组成。

维护这个环上有多少个可行的$b_i$是$O(n)$的,

枚举$a_i$,首先算出$a_i$在环上要跳多少个循环，以及剩下长度$<$一整个循环节的链的头/尾。

接下来只要对环上的信息做一个前缀和，稍加分类讨论即可。

实现的时候,不用实际建出图,只要记录环的信息即可。

代码:

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline LL read(){
    LL x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(LL x){
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
inline void writeln(LL x){ write(x),putchar('\n'); }
const int N = 1000050,M = 1000050;
inline int gcd(int x,int y){ return y ? gcd(y,x%y) : x;}
inline LL lcm(int x,int y){ return (LL)x / gcd(x,y) * y; }
int P,Q,n,m; LL T,cyc,ans;
int A[N],B[N];
int vis[N],id[N],rk[N],sum[N],pre[N],len[N],cnt;
int main(){
	int i,j,k;
	P = read(),Q = read(),n = read(),m = read(),T = read() - 1;
	for (i = 1; i <= n; ++i) A[i] = read();
	for (i = 1; i <= m; ++i) B[read()] = 1;
	for (i = 0; i < Q; ++i) if (!vis[i]){
		vis[i] = 1,id[i] = ++cnt,len[cnt] = 1,rk[i] = 1;
		if (B[i]) sum[cnt] = pre[i] = 1;
		for (j = (i+P)%Q,k = 2; !vis[j]; j = (j+P)%Q,++k){
			vis[j] = 1,id[j] = cnt,++len[cnt],rk[j] = k;
			sum[cnt] += B[j];
			pre[j] = sum[cnt];
		}
	}
	LL cnt1,cnt2,cnt3,v,L,R,iid,llen;
	for (i = 1; i <= n; ++i) if (A[i] <= T){
		v = A[i] % Q,iid = id[v],llen = len[iid];
		cnt1 = (T-A[i]) / P,cnt2 = cnt1 / llen,cnt3 = cnt1 - cnt2 * llen;
		ans += cnt2 * sum[iid];
		L = v,R = (v + cnt3 * P) % Q;
		if (rk[L] <= rk[R]) ans += pre[R] - pre[L] + B[L];
		else ans += sum[iid] - pre[L] + B[L] + pre[R];
	}
	writeln(ans);
    return 0;
}
```

---

## 作者：shentao1 (赞：4)

关于这道题吧，~~其实本人认为应该改为提高~~

首先，算法一，暴力O(t)：
```cpp
//代码片段
	for (int i=1;i<=n;i++) h[a[i]]=1;
	for (int i=1;i<=m;i++) h1[b[i]]=1;
	for (int i=0;i<t;i++) if (h[i%p]&&h1[i%q]) 		ans++; 
	cout<<ans<<endl;
```
期望得分10分


------------


其次，很显然看出，区间以P*Q是有周期的

所以，我们轻易的得到了算法二O(PQ)：
```cpp
//代码片段
	for (int i=1;i<=n;i++) h[a[i]]=1;
	for (int i=1;i<=m;i++) h1[b[i]]=1;
	LCM=lcm(p,q); 
	for (int i=0;i<LCM;i++) if (h[i%p]&&h1[i%q]) 	ans1[i]=ans1[i-1]+1;else ans1[i]=ans1[i-1]; 
	cout<<t/LCM*ans1[LCM-1]+ans1[t%LCM]<<endl;
```
期望得分30-40分

最后，我们尝试对算法二进行优化：

我们将A[i]排序并设它是一个环

将2*Q/d分成前后两段

则设sm[i] (1<=i<=2*CD) 

=(B[P*i%Q] 是否出现）

则计算出sm[i]的前缀和

然后上公式：
```cpp
ans = SUM{(T-A[now])/lcm*sm[CD] + sm[dy[A[now]]+le] - sm[dy[A[now]]-1];}
//其中le=(T-A[now])%lcm/P;now<=n
```
last but not least 代码闪亮登场：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long P,Q,n,m,T,is[1000005],ans,A[1000005],B[1000005],sm[2000005],dy[2000005];
ll lcm,D;
bool cmp(int x,int y) {return x%D<y%D;}//模gcd(P,Q)意义下的排序
main() {
    cin>>P>>Q>>n>>m>>T;
    T--;//因为是小于T，这样写方便一点
    for(int i=1;i<=n;i++) cin>>A[i];
    for(int i=1;i<=m;i++) cin>>B[i];
    if(P>Q) {
        for(int i=1;i<=max(n,m);i++) swap(A[i],B[i]);
        swap(n,m); swap(P,Q);
    }//使P<=Q
    for(int i=1;i<=m;i++) is[B[i]] = 1;//打标记
    D=__gcd(P,Q);
    lcm = P/D*Q;
    int CD=Q/D;
    sort(A+1,A+1+n,cmp);//升序排序
    int now=0;
    for(int d=0;d<D;d++) {
        if(now==n) break;//如果查完了，退出
        if(A[now+1]%D!=d) continue;
        int o=d;
        for(int i=1;i<=CD;i++) {
            o=(o+P)%Q;//在线处理
            sm[i]=sm[i+CD]=is[o];//分段处理
            dy[o]=i;//类似约瑟夫的处理方法
        }
        for(int i=1;i<=2*CD;i++) sm[i] = sm[i-1]+sm[i];//预处理前缀和
        while(now<n&&A[now+1]%D==d) {
            now++; long long le = (T-A[now])%lcm/P;
            ans += 1ll*(T-A[now])/lcm*sm[CD] + sm[dy[A[now]]+le] - sm[dy[A[now]]-1];//公式，不再赘述
        }
    }
    cout<<ans<<endl;//输出
    return 0;
}

```

这样我们就A了SNOI2019 D1T2了鸭，开心开心

---

## 作者：Wuyanru (赞：3)

[更好的阅读体验](https://www.cnblogs.com/Wuyanru/p/SNOI-Number_Theory.html)

前几天我们NOIP模拟赛的最后一题，然后一不小心挂了 $ 10 $ 分，痛失ak。

题目链接：[luoguP5330](https://www.luogu.com.cn/problem/P5330) 。

题目大意：给定两个数 $ P,Q $ 和两个集合 $ A,B $ 求 $ \sum\limits_{i=0}^{T-1}[(i\bmod P\in A)\wedge(i\bmod Q\in B)] $ 。

首先我们来看一个显而易见的规律：

假如说 $ P=4,Q=6 $。

$ 0\bmod P=0,0\bmod Q=0 $

$ 1\bmod P=1,1\bmod Q=1 $

$ \dots $

$ 11\bmod P=3,11\bmod Q=5 $

$ 12\bmod P=0,12\bmod Q=0 $

$ 13\bmod P=1,13\bmod Q=1 $

我们会发现，数字对于 $ P,Q $ 取模的值构成了“循环”，并且所有这些循环，对答案的贡献是相同的。

这些循环的答案非常容易计算，并且我们还可以知道一个循环的大小为 $ \dfrac{PQ}{\gcd(P,Q)} $ 。

这就是当 $ T $ 为 $ P,Q $ 公倍数时的解法。

配合暴力，我们可以拿到 $ 40 $ 分。

现在我们可以快速处理一个完整的循环，但是如果最后数字的个数不足以构成循环，我们就只能暴力。

显然，这样时间复杂度是 $ O(PQ) $ 的。

我们再来找规律，把数字 $ \bmod P,Q $ 的值做成表格。

$ P=4,Q=6: $

[![vik4Mj.png](https://s1.ax1x.com/2022/07/30/vik4Mj.png)](https://imgtu.com/i/vik4Mj)

$ P=5,Q=7: $

[![vik5ss.png](https://s1.ax1x.com/2022/07/30/vik5ss.png)](https://imgtu.com/i/vik5ss)


发现什么了吗？

对于第一个表格，$ \bmod P=0 $ 的数字分别是 $ 0,4,8,12,16,20 $ ，这些数字 $ \bmod Q $ 的值分别是 $ 0,4,2,0,4,2 $ 。

$ \bmod P=1 $ 的数字分别是 $ 1,5,9,13,17,21 $ ，这些数字 $ \bmod Q $ 的值分别是 $ 1,5,3,1,5,3 $ 。

有没有发现什么？

再看一眼第二个表格。

$ \bmod P=0 $ 的数字分别是 $ 0,5,10,15,20,25,30,35,40,45,50,55,60,65 $ ，$ \bmod Q $ 的值分别是 $ 0,5,3,1,6,4,2,0,5,3,1,6,4,2 $ 。

$ \bmod P=1 $ 的数字分别是 $ 1,6,11,16,21,26,31,36,41,46,51,56,61,66 $ ，$ \bmod Q $ 的值分别是 $ 1,6,4,2,0,5,3,1,6,4,2,0,5,3 $ 。

发现了什么呢？

假如说上一个出现的数字 $ \bmod Q $ 的值是 $ x $ ，那么下一个值就是 $ (x+P)\bmod Q $ 。

好，现在让我们把这个序列写出来，但是这个序列中可能不包含 $ 0\sim Q-1 $ 中的所有数，所以我们把若干个这样的序列“拼”在一起。

举个例子，对于第二个表格，对应的序列就是 $ 0,5,3,1,6,4,2 $ ，对于第一个表格，对应的序列就是 $ 0,4,2,1,5,3 $ 。

然后呢？不难发现，对于某一个 $ \bmod P $ 的值，他对答案的贡献在这个序列中是完整的一段。

然后前缀和就可以了。

前缀和维护的是 $ 0~Q-1 $ 的这个排列中，前 $ i $ 个数字里面，有多少个属于集合 $ B $。

所以可以直接枚举 $ A $ 中的元素，计算它的贡献。

我考场上傻了，写了个线段树。

时间复杂度 $ O(P+Q) $ 。

我写的是 $ O(Q+P\log Q) $ 。

代码：

```c++
// DABC ABCD ABCA DBAA
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#include<map>
using namespace std;
using pi=pair<int,int>;
using ll=long long;
using pl=pair<ll,ll>;
using pli=pair<ll,int>;
template<typename A>
using vc=vector<A>;
using vi=vector<int>;
inline int read()
{
	int s=0,w=1;char ch;
	while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline ll lread()
{
	ll s=0,w=1;char ch;
	while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int gcd(int a,int b)
{
	int r=a%b;
	while(r)
	{
		a=b;
		b=r;
		r=a%b;
	}
	return b;
}
bool pp[1000001];
bool qq[1000001];
int t1[4000001];
int val[1000001];
int wh[1000001];
int visa[1000001];
int visb[1000001];
int a[1000001];
int b[1000001];
int n,m,p,q;
int tot;
ll ans;
ll t;
void add(int p,int pl,int pr,int x)
{
	t1[p]++;
	if(pl==pr) return ;
	int mid=(pl+pr)>>1;
	if(x<=mid) add(p*2,pl,mid,x);
	else add(p*2|1,mid+1,pr,x);
}
int get(int p,int pl,int pr,int l,int r)
{
	if(l<=pl&&pr<=r) return t1[p];
	int mid=(pl+pr)>>1,ans=0;
	if(l<=mid) ans+=get(p*2,pl,mid,l,r);
	if(mid<r) ans+=get(p*2|1,mid+1,pr,l,r);
	return ans;
}
int main()
{
	p=read(),q=read(),n=read(),m=read(),t=lread();
	int num=gcd(p,q);ll round=(ll)p*q/num;
	for(int i=1;i<=n;i++) a[i]=read(),visa[a[i]%num]++,pp[a[i]]=1;
	for(int i=1;i<=m;i++) b[i]=read(),visb[b[i]%num]++,qq[b[i]]=1;
	for(int i=0;i<num;i++) ans+=(ll)visa[i]*visb[i]*(t/round);
	ll rest=t-(t/round)*round;
	for(int i=0;i<num;i++)
	{
		for(int j=i;;)
		{
			val[++tot]=j;
			wh[j]=tot;
			j=(j+p)%q;
			if(j==i) break;
		}
	}
	// for(int i=1;i<=q;i++) printf("%d ",val[i]);
	// printf("\n");
	for(int i=1;i<=m;i++) add(1,1,q,wh[b[i]]);
	for(int i=1;i<=n;i++)
	{
		int v=a[i];//第v行
		if(rest<i) continue;
		int step=rest/p;
		if(v<rest%p) step++;
		if(!step) continue;
		int l=wh[v%q],r=wh[v%q]+step-1;
		// printf("%d : %d %d ",a[i],l,r);
		l--,r--;
		// ll mem=ans;
		if(l/(q/num)==r/(q/num)) ans+=get(1,1,q,l+1,r+1);
		else
		{
			int l2=l/(q/num)*(q/num);
			int r2=l2+q/num-1;
			ans+=get(1,1,q,l2+1,r-(q/num)+1);
			ans+=get(1,1,q,l+1,r2+1);
			// printf("%d %d %d %d ",l2+1,r-(q/num)+1,l,r2);
		}
		// printf("%lld\n",ans-mem);
	}
	printf("%lld\n",ans);
	return 0;
}
```

感谢观看！

---

## 作者：asuldb (赞：3)

[题目](https://www.luogu.org/problemnew/show/P5330)

考虑对于每一个$a_i$计算有多少个$0<x\leq T-1$满足$x\equiv a_i(mod\ P)$且$x\ mod\ Q \in B$

显然$x=a_i+k\times P$，先考虑一下这个$k$最大能取到多少，显然有$a_i+k\times P\leq T-1$，所以$k$最大取到$\left \lfloor \frac{T-1-a_i}{P} \right \rfloor$

我们这样加下去，肯定会使得$x$在$mod\ Q$意义下循环，我们尝试利用一下这个循环的性质

一旦$k\times P\equiv 0(mod\ Q)$就会循环，显然$k=\frac{lcm(P,Q)}{P}=\frac{Q}{gcd(P,Q)}$就是最小循环节

再考虑把这个问题转化成一个图论问题，我们对于每一个$0<x<Q$，都建一条向$(x+P)\% Q$的边，属于$B$集合中的点的点权是$1$，我们要做的是求出每一个$a_i$走$\left \lfloor \frac{T-1-a_i}{P} \right \rfloor$步到达的点的点权和

由于每一个点只有一条出边，那么就说明这个图里只会存在一些简单环，而且每一个环的大小都是$\frac{Q}{gcd(P,Q)}$

于是现在我们就可以把每一个环都找出来，维护一下每一个环的点权和，再维护一下环的前缀和，这样我们就能快速计算每一个点走一定步数到达的点的点权和了

边界情况需要好好判断一下

代码

```cpp
#include <bits/stdc++.h>
#define LL long long
#define re register
const int maxn = 1e6 + 5;
LL T, ans, p[maxn];
std::vector<int> s[maxn], v[maxn];
int len, P, Q, n, m, a[maxn], b[maxn], tax[maxn], w[maxn], col[maxn], pos[maxn], num;
inline int read() {
    char c = getchar();int x = 0;
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - 48, c = getchar();
    return x;
}
int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }
int dfs(int x, int c) {
    if (col[x]) return 0;
    col[x] = c;
    v[col[x]].push_back(x);
    return tax[x] + dfs((x + P) % Q, c);
}
inline int find(int l, int x) { return s[col[x]][pos[x] + l] - s[col[x]][pos[x]]; }
int main() {
    P = read(), Q = read(), n = read(), m = read(), scanf("%lld", &T);
    for (re int i = 1; i <= n; i++) a[i] = read();
    for (re int i = 1; i <= m; i++) b[i] = read();
    if (P > Q)
        std::swap(P, Q), std::swap(n, m), std::swap(a, b);
    len = Q / gcd(P, Q);
    for (re int i = 1; i <= m; i++) tax[b[i]] = 1;
    for (re int i = 1; i <= n; i++) p[i] = (T - 1 - a[i]) / P;
    for (re int i = 0; i < Q; i++)
        if (!col[i])
            ++num, w[num] = dfs(i, num);
    for (re int i = 1; i <= num; i++) {
        for (re int j = 0; j < v[i].size(); j++) pos[v[i][j]] = j;
        int t = v[i].size() - 1;
        for (re int j = 0; j < t; j++) v[i].push_back(v[i][j]);
        s[i].push_back(tax[v[i][0]]);
        for (re int j = 1; j < v[i].size(); j++) s[i].push_back(s[i][j - 1] + tax[v[i][j]]);
    }
    for (re int i = 1; i <= n; i++) {
        ans += 1ll * (p[i] / len) * (w[col[a[i]]]);
        ans += find(p[i] % len, a[i]) + tax[a[i]];
    }
    printf("%lld\n", ans);
    return 0;
}
```


---

## 作者：封禁用户 (赞：1)

[在我的博客查看](https://www.cnblogs.com/123asdf123/p/18736701https://www.cnblogs.com/123asdf123/p/18736701)

一种神奇的做法（？）。

模拟赛 exCRT 打错了导致只有 80……

前置：[exCRT](https://www.luogu.com.cn/problem/P4777)。以下有些没解释的就是 exCRT 的内容。

首先，因为是 $0$ 到 $T-1$，所以以下的 $T$ 代表的是 $T-1$。

看到 $\begin{cases}i\equiv x(\bmod\ P)\\i\equiv y(\bmod\ Q)\end{cases}(0 \le i \le T,x \in A,y \in B)$ 的形式，自然想到 exCRT。

首先，$0$ 到 $T$ 能被按照对 $\operatorname{lcm}(P,Q)$ 取模的结果划分开，取模得到 $k$ 的数的个数为$\lfloor\frac{T}{\operatorname{lcm}(P,Q)}\rfloor+[T\mod \operatorname{lcm}(P,Q)\ge k]$。

发现如果 $k$ 为已知余数分别为 $x,y$ 得到的最小解，那么对 $\operatorname{lcm}(P,Q)$ 取模等于 $k$ 的解都是可以的。

但是可能的 $x,y$ 对有 $nm$ 对，需要快速求解。

首先先把无解的区分开，根据 exCRT 可知，$(a-b)\mod \gcd(p,q)(a\in A,b\in B)$ 要等于 $0$ 才有解，因此需要 $a\equiv b (\bmod \gcd(p,q))(a\in A,b\in B)$。可以考虑把 $A$ 和 $B$ 集合内的每一个数都分别划分开，然后后面枚举 $i$ 从 $0\sim\gcd(p,q)$，每次只看 $\mod\gcd(p,q)=i$ 的 $A$ 和 $B$（分别设为集合 $A_i$ 和 $B_i$）。因为 $\sum_{i=0}^{\gcd(p,q)-1}|A_i|=|A|$，$B$ 同理，因此时间复杂度仍为线性的。

接着，求数量的 $\lfloor\frac{T}{\operatorname{lcm}(P,Q)}\rfloor+[T\mod \operatorname{lcm}(P,Q)\ge k]$ 可以被拆成 $\lfloor\frac{T}{\operatorname{lcm}(P,Q)}\rfloor$ 和 $[T\mod \operatorname{lcm}(P,Q)\ge k]$。前半段直接等于 $\lfloor\frac{T}{\operatorname{lcm}(P,Q)}\rfloor \times |A_i| \times |B_i|\ (0 \le i \le \gcd(p,q)-1)$，后边半段才是关键的。

$k$ 因为大家的 exCRT 不同，展开也不同，但无论如何都可以化为 $\text{一坨系数}\times a_{ij}+\text{一坨系数}\times b_{ij} \ (0 \le i \le \gcd(p,q)-1,a_{ij} \in A_i)$，设 $ta_{ij}$ 为 $\text{一坨系数}\times a_{ij}$，$tb_{ij}$ 同理。可以考虑直接定一求一，确定一个 $b_{ij}$，快速计算有多少个 $a_{ij}$ 使得 $0 \le ta_{ij}+tb_{ij} \le T\mod \operatorname{lcm}(P,Q)$，即计算在 $[-tb_{ij} , T\mod \operatorname{lcm}(P,Q)-tb_{ij}]$ 范围内的 $ta_{ij}$ 个数。（**注意因为它是在模 $\operatorname{lcm}(P,Q)$ 意义下的，所以上面的一切都要对 $\operatorname{lcm}(P,Q)$ 取模**）

可以考虑把 $A_i$ 和 $B_i$ 排序，直接双指针。总时间复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace estidi{
	vector<long long>a,b,va[1000003],vb[1000003],vva;
	long long xx,yy;
	long long exgcd(long long a,long long b){
		if(!b){
			xx=1;
			yy=0;
			return a;
		}
		long long d=exgcd(b,a%b);
		swap(xx,yy);
		yy-=a/b*xx;
		return d;
	}
	long long inv(long long x,long long p){
		exgcd(x,p);
		return (xx%p+p)%p;
	}
	int main(){
		int p,q,n,m;
		long long x,gc,lc,ck,iv,tt,ans=0;
		scanf("%d%d%d%d%lld",&p,&q,&n,&m,&tt);
		tt--;
		for(int i=1;i<=n;i++){
			scanf("%lld",&x);
			a.push_back(x);
		}
		for(int i=1;i<=m;i++){
			scanf("%lld",&x);
			b.push_back(x);
		}
		gc=__gcd(p,q);
		lc=p/gc*q;
		ck=tt%lc;
		iv=inv(p/gc,q/gc)*p/gc;
		for(int i=0;i<n;i++)
			va[a[i]%gc].push_back(((a[i]-iv*a[i])%lc+lc)%lc);
		for(int i=0;i<m;i++)
			vb[b[i]%gc].push_back(((-iv*b[i])%lc+lc)%lc);
		for(int i=0;i<gc;i++){
			ans+=tt/lc*va[i].size()*vb[i].size();
			sort(va[i].begin(),va[i].end());
			sort(vb[i].begin(),vb[i].end());
			vva=va[i];
//			cerr<<"a:\n";
//			for(long long x:va[i])
//				cerr<<x<<" ";
//			cerr<<"\nb:\n";
//			for(long long x:vb[i])
//				cerr<<x<<" ";
//			cerr<<endl<<ck<<" "<<lc<<" "<<iv<<endl;
			for(long long x:va[i])
				vva.push_back(x+lc);
			int l=-1,r=-1;
			for(long long x:vb[i]){
				long long nl=x,nr=ck+x;
				while(l<(int)vva.size()-1&&vva[l+1]<nl)
					l++;
				while(r<(int)vva.size()-1&&vva[r+1]<=nr)
					r++;
//				cerr<<x<<" "<<l<<" "<<r<<" "<<nl<<" "<<nr<<" "<<endl;
				ans+=r-l;
			}
		}
		printf("%lld",ans);
		return 0;
	}
}
int main(){
	estidi::main();
	return 0;
}
```

---

## 作者：Leasier (赞：1)

如何拥有脑子？如何拥有脑子？如何拥有脑子？如何拥有脑子？如何拥有脑子？如何拥有脑子？如何拥有脑子？如何拥有脑子？如何拥有脑子？如何拥有脑子？

------------

首先说一下我模拟赛时的无脑抽象做法：

- 不妨钦定 $p \leq q$。
- 不难发现关于 $i$ 有循环节 $L = \operatorname{lcm}(p, q)$，则答案可以被拆分成 $f(t) = \lfloor \frac{t}{L} \rfloor f(L) + f(t \bmod L)$。现在我们只需要考虑 $\forall n \in [1, L]$，$f(n)$ 如何计算。
- 考虑 exCRT 合并方程的过程，设 $x$ 满足 $x \equiv a \pmod p, x \equiv b \pmod q$。
- 令 $x = k_1 p + a = k_2 q + b$，则可以解出 $k_1 = \operatorname{inv}(\frac{p}{d}, \frac{q}{d}) \times \frac{a - b}{d} \bmod \frac{q}{d}$。这里 $a, b$ 需要满足 $a \equiv b \pmod d$，其中 $d = \gcd(p, q)$。
- 考虑枚举 $k_1$，则答案可以被拆分为 $k_1(p + 1) \leq n$ 的若干取任意 $a$ 皆可的整段和至多一个散段。散段可以直接暴力枚举 $a$，于是我们只关心整段如何计算。
- 由 $k_1$ 可以解出 $\frac{a - b}{d} \equiv k_1 \times \frac{p}{d} \pmod{\frac{q}{d}}$。考虑 $\forall r \in [0, d)$，对所有 $a \equiv b \equiv r \pmod d$ 分开统计。
- 不难发现此时 $\frac{a - b}{d} = \lfloor \frac{a}{d} \rfloor - \lfloor \frac{b}{d} \rfloor$，于是我们以此为下标用 NTT 做差卷积即可。
- 时间复杂度为 $O(q \log q)$。

但事实上本题存在一个更加高妙的做法。

下文钦定 $p \geq q$，令 $t \leftarrow t - 1$。

其实我们并没有必要真的去模拟 exCRT。考虑模拟暴力：从一个 $x = b \in B$ 出发，每次令 $x \leftarrow x + q$，看一下是否 $\exists a \in A, x \equiv a \pmod p$ 即可。

注意到对于每个 $b$ 而言，$x \bmod p$ 有长为 $L = \frac{p}{\gcd(p, q)}$ 的循环节。

考虑枚举 $b \in B$，则当 $t \geq b$，我们会从 $b$ 开始先经过若干整循环，再走至多一个不完整的段。

预处理所有循环节的前缀信息即可。时间复杂度为 $O(p)$。

- 事实上这里的“循环节”也可以通过图论模型表出：有一张点编号在 $[0, p)$ 中的图，每个点 $x$ 向 $(x + q) \bmod p$ 连边，则该图由若干互不相交的环构成。上文所述“循环节”即为这张图上的一个环。

代码：
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

typedef long long ll;

int a[1000007], b[1000007], belong[1000007], dis[1000007], sum[1000007];
bool vis1[1000007], vis2[1000007];

inline int read_int(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

inline ll read_ll(){
	ll ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline ll calc(int x, ll y, int p, int q, int len){
	if (y == 0) return 0;
	if (y + dis[x] - 1 <= len) return sum[(x + q * (y - 1) % p) % p] - (sum[x] - (vis1[x] ? 1 : 0));
	return sum[belong[x]] - ((sum[x] - (vis1[x] ? 1 : 0)) - sum[(x + q * (y - 1) % p) % p]);
}

int main(){
	int p = read_int(), q = read_int(), n = read_int(), m = read_int(), len;
	ll t = read_ll(), ans = 0;
	for (int i = 1; i <= n; i++){
		a[i] = read_int();
	}
	for (int i = 1; i <= m; i++){
		b[i] = read_int();
	}
	if (p < q){
		swap(p, q);
		swap(n, m);
		swap(a, b);
	}
	len = p / gcd(p, q);
	for (int i = 1; i <= n; i++){
		vis1[a[i]] = true;
	}
	for (int i = 0; i < p; i++){
		if (!vis2[i]){
			int pre = p;
			for (int j = i; ; j = (j + q) % p){
				if (vis2[j]){
					for (int k = i; ; k = (k + q) % p){
						belong[k] = pre;
						if (k == pre) break;
					}
					break;
				}
				vis2[j] = true;
				dis[j] = dis[pre] + 1;
				if (vis1[j]){
					sum[j] = sum[pre] + 1;
				} else {
					sum[j] = sum[pre];
				}
				pre = j;
			}
		}
	}
	t--;
	for (int i = 1; i <= m; i++){
		if (t >= b[i]){
			ll cnt = (t - b[i]) / q + 1;
			ans += sum[belong[b[i]]] * (cnt / len) + calc(b[i], cnt % len, p, q, len);
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：meizhuhe (赞：1)

发一篇跟我一样的苟弱也能看懂得题解

## 题目分析
根据题意，我们需要计算出小于 $T$ 条件的
$$
\begin{cases}
s \equiv  A_i \pmod P\\
s \equiv  B_j \pmod Q
\end{cases}
$$
中 $s$ 的数量。
显然的扩展中国剩余定理，那么化一下简，就是
$$
s\equiv\frac{ A_iP\operatorname{inv}(P)+B_jQ\operatorname{inv}(Q) }{\gcd(P,Q)} \pmod M \hspace{0.8cm} (1)
$$
其中 $M=\operatorname{lcm}(P, Q)$，$\operatorname{inv}(P),\operatorname{inv}(Q)$ 是适合等式
$$
P\operatorname{inv} (P)+Q\operatorname{inv} (Q)=
\gcd(P,Q)
$$
的整数，并且必须满足条件
$$
\gcd(P,Q)\mid A_i-B_j  \hspace{1cm} (2)
$$

**（注：这本质上是将中国剩余定理的形式进行扩展，需要推导一下，不能完全算 exCRT）** 


我们发现 $s$ 的表达式可以拆成两个分别关于 $A_i$，$B_j$ 的正比例函数，即设
$$
\begin{cases}
 Av_i=\frac{A_iP\operatorname{inv} (P)}{\gcd(P,Q)} \\
Bv_j=\frac{B_jP\operatorname{inv} (P)}{\gcd(P,Q)}
\end{cases}
$$
则会有 
$$s\equiv Av_i+Bv_j\pmod M\hspace{0.6cm} (3)$$

除此之外，我们应该先想一想怎么统计答案。设 $T=rM+t (0 \leq t <M)$，并假设我们已经求出在 $M$ 的范围内有 $amt_1$ 可行解（即满足 $(2)$ 式的数对 $(A_i,B_j)$），那么对于 $T$ 在 $M$ 的整数倍范围内，一定会有 $ r \times amt_1$ 个解。另外在 $[rM,rm+t)$ 的范围内的解的数量一定等于在 $[0,t)$ 内可行解的数量，设为 $amt_2$ 。因此，我们只需要统计出符合 $(2)$ 式的 $(i,j)$ 数量和同时满足 $(2)(4)$ 的 $(i,j)$ 数量 
$$
(Av_i+Bv_j) \mod M <t\quad (4)
$$


好了，我们可以干事情了。对于 $(2)$ 式，我们只需找出所有模 $\gcd(P,Q)$ 相等的 $A_i$ 与 $B_j$ 即可。方法是将 $A$ 和 $B$ 按照模 $\gcd(P,Q)$ 的值作为第一关键字进行排序，然后维护一个双指针指针即可。对于 $(4)$ 式，我们注意到  
$$0\leq Av_i+Bv_j<2M\qquad(5)$$
因此，和值要么取模和不变，要么减去一个 $M$，这样的话在第一关键字的基础上以 $Av,Bv$ 为第二关键字排序，按 $(5)$ 分两类讨论移项后二分查找即可。

时间复杂度 ：$\Theta (n\log_{}{} n)$
## 代码实现
```cpp
#include <bits/stdc++.h>
#define MAXN 1000009
#define MAXM 1000009
using namespace std;
typedef long long ull;
ull P,Q,n,m,T;
ull invP,invQ,kA,kB,M,t,g;
ull amt1,amt2;
struct Node{
	ull val;
	ull mdg;
	ull mtk;
	Node() : val(0),mdg(-1),mtk(0) { }
	Node(ull _val,ull _mdg,ull _mtk) : val(_val),mdg(_mdg),mtk(_mtk) { }
} A[MAXN],B[MAXN];
bool cmp(const Node& _1,const Node& _2) { return _1.mdg==_2.mdg?_1.mtk<_2.mtk:_1.mdg<_2.mdg; }
ull exgcd(ull a,ull b,ull& x,ull& y){
	if(!b){
		x=1;
		y=0;
		return a;
	}
	ull res=exgcd(b,a%b,x,y);
	ull t=x;x=y;y=t-y*(a/b);
	return res;
}
void init(){
	g=exgcd(P,Q,invP,invQ);
	M=P/g*Q;
	kB=__int128(P)/g*invP%M;
	kA=__int128(Q)/g*invQ%M;
	kA=(kA+M)%M,kB=(kB+M)%M;
	t=T%M;
	for(int i=1;i<=n;i++){
		A[i].mdg=A[i].val%g;
		A[i].mtk=__int128(A[i].val)*kA%M;
	}
	for(int i=1;i<=m;i++){
		B[i].mdg=B[i].val%g;
		B[i].mtk=__int128(B[i].val)*kB%M;
	}
}
void getans(){
	sort(A+1,A+n+1,cmp);
	sort(B+1,B+m+1,cmp);
	Node tmp;
	int j=0,lastans=0,pl,pr,pm,p1,p2;
	for(int i=1;i<=n;i++){
		if(A[i].mdg==B[j].mdg){
			amt1+=lastans;
			goto label;
		}
		lastans=0;
		pl=m+1,pr=0;
		while(j<m&&A[i].mdg>B[j+1].mdg)
			++j;
		while(j<m&&A[i].mdg==B[j+1].mdg){
			++j;
			if(pl==m+1)
				pl=j;
			pr=j;
		}
		if(pl>pr)
			continue;
		lastans=pr-pl+1;
		amt1+=lastans;
label:
		// B[pl,pr]
		tmp=Node(0,A[i].mdg,M-A[i].mtk);
		pm=lower_bound(B+pl,B+pr+1,tmp,cmp)-B;
		tmp.mtk=t-A[i].mtk;
		p1=lower_bound(B+pl,B+pm,tmp,cmp)-B;
		tmp.mtk=t-A[i].mtk+M;
		p2=lower_bound(B+pm,B+pr+1,tmp,cmp)-B;
		amt2+=(p1-pl)+(p2-pm);
	}
}
int main(){
	//freopen("input.in","r",stdin);
	//freopen("output.out","w",stdout);
	ios::sync_with_stdio(0);
	cin>>P>>Q>>n>>m>>T;
	for(int i=1;i<=n;i++)
		cin>>A[i].val;
	for(int i=1;i<=m;i++)
		cin>>B[i].val;
	init();
	getans();
	ull ans=(T/M)*amt1+amt2;
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：WeLikeStudying (赞：1)

**题意**
- 给定模 $p$ 域的子集和模 $q$ 域的子集，求它们的交集中小于 $T$ 的元素个数。
- $p,q\le 10^6$，$T\le 10^{18}$。

**分析**
- 这样的题目咱们先水分，使用位图优化，时间复杂度 $O(pq/w)$，[代码实现](https://www.luogu.com.cn/paste/3k0j4bm3)。
- 这份代码当然只能水 $80$ 分，咱们不必执着，考虑正解。
- 首先发现 $\text{lcm}(p,q)$ 的循环节，考虑枚举模 $p$ 的域，计算对应模 $q$ 的域，即 $(pi+j)\bmod q$，先枚举 $j$ 再计算对应的 $i$，我们发现有很多可以重复利用的东西。
- 对 $q$ 模域下的点 $i$，向 $(i+p)\bmod q$ 连一条有向边，而其实就是要求每个节点的长度为 $q/\gcd(p,q)$ 的路径上存在关键点的数量，这可以直接把环拆出来然后差分求解。
- 时间复杂度 $O(p+q)$，[代码](https://www.luogu.com.cn/paste/oz3yxm2s)，比乱搞短多了。

---

## 作者：happybob (赞：0)

假设 $p \leq q$。

建立一个有向图，顶点编号为 $[0,q)$，对于每个点 $i$，连唯一有向边 $i \rightarrow (i+p) \bmod q$。

这个图有若干性质：

1. 图由若干环构成。

   证明：每个点 $i$ 有唯一出边 $(i+p) \bmod q$ 和唯一入边 $(i-p) \bmod q$。所以图必然由若干环构成。
   
2. 每个环长度均相等，为 $\dfrac{\operatorname{lcm}(p,q)}{p}$。

   证明：考察 $i$ 经过多少步会重新变为 $i$。显然是方程 $i+kp \equiv i \pmod q$ 的最小正整数数解，进一步 $q \mid kp$，容易发现 $k_{min} = \dfrac{\operatorname{lcm}(p,q)}{p}$。

考虑原题怎么在图上做。对于每个 $a_i$，我们找到图上所对应的点 $a_i$。那么从这个点开始走若干步，会到达所有 $a_i+kp$ 对 $q$ 取模的结果，即 $\bmod p=a_i$ 的所有点。我们要求出这些点中不超过 $T$ 且在 $b$ 中出现过的点数量。显然这里的 $k$ 可以根据 $a_i+kp < T$ 解出范围，进一步等价与在环上走若干整数圈之后走若干步。维护每个环的总和与前缀和即可快速计算答案。特别地，$a_i \geq T$ 时直接跳过，否则可能会在第二个包获得 WA。

时间复杂度 $O(p+q)$。

代码：


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <numeric>
using namespace std;

using ll = long long;

const int N = 2e6 + 5;

int p, q, n, m, a[N], b[N];
ll t;
bool v[N], vis[N], v2[N];
ll sum[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> p >> q >> n >> m >> t;
	if (p > q)
	{
		swap(p, q), swap(n, m);
		for (int i = 1; i <= m; i++) cin >> b[i];
		for (int i = 1; i <= n; i++) cin >> a[i];
	}
	else
	{
		for (int i = 1; i <= n; i++) cin >> a[i];
		for (int i = 1; i <= m; i++) cin >> b[i];
	}
	for (int i = 1; i <= n; i++) v[a[i]] = 1;
	for (int i = 1; i <= m; i++) v2[b[i]] = 1;
	ll ans = 0ll;
	for (int i = 0; i < q; i++)
	{
		if (vis[i]) continue;
		if (i > t) continue;
		if ((i + p) % q == i)
		{
			vis[i] = 1;
			if (v2[i] && v[i])
			{
				ll l = 0, r = (t - i) / p;
				if ((t - i) % p == 0) r--;
				ans += max(0ll, r - l + 1);
			}
			continue;
		}
		vector<int> cir;
		int len = 0, j = i, s = 0;
		do
		{
			vis[j] = 1;
			cir.emplace_back(j);
			len++, j = (j + p) % q;
		} while (j != i);
		for (int x = 0; x < cir.size(); x++)
		{
			sum[x] = ((x == 0 ? 0 : sum[x - 1]) + v2[cir[x]]);
			s += v2[cir[x]];
		}
		for (int x = cir.size(); x < 2 * cir.size(); x++)
		{
			sum[x] = sum[x - 1] + v2[cir[x - cir.size()]];
		}
		for (int x = 0; x < cir.size(); x++)
		{
			int j = cir[x];
			if (!v[j] || j > t) continue;
			ll l = 0, r = (t - j) / p;
			if ((t - j) % p == 0) r--;
			if (r < l) continue;
			ll k = r / len + 1;
			if (k) ans += 1ll * (k - 1) * s;
			ll lft = r - (k ? (k - 1) * len : 0);
			ans += sum[x + lft] - (x != 0 ? sum[x - 1] : 0ll);
		}
	}
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：wosile (赞：0)

P5330 【模板】**瞪眼**

前几天模拟赛做到了这题的加强版，$P,Q \le 3000$ 的暴力分给到了 90pts，我场切很开心但是没什么用。

很明显，对于 $x \equiv x'\pmod{\text{lcm}(P,Q)}$，$x $ 和 $x'$ 的余数情况是一样的。所以以 $\text{lcm}(P,Q)$ 为一个周期，考虑周期内的情况即可。

既然有部分分就给点排面，先对着 $P,Q$ 互质的情况*瞪眼*。比如 $P=3,\,Q=5$。

|$x$| $0$| $1$| $2$| $3$| $4$| $5$| $6$| $7$| $8$| $9$|$10$|$11$|$12$|$13$|$14$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$x \bmod 3$|$0$|$1$|$2$|$0$|$1$|$2$|$0$|$1$|$2$|$0$|$1$|$2$|$0$|$1$|$2$|
|$x \bmod 5$|$0$|$1$|$2$|$3$|$4$|$0$|$1$|$2$|$3$|$4$|$0$|$1$|$2$|$3$|$4$|

很明显，每一种 $x \bmod P$ 的值（即 $[0,P)$ 中的数）都出现了 $Q$ 次，并且这 $Q$ 次出现对应每种 $x \bmod Q$ 的值各一次。

对于一个整周期，由于每一种 $(x \bmod P,x \bmod Q)$ 都恰好出现一次，答案就是 $nm$。

如果 $(P,Q)$ 不互质，情况没有这么简单，但也差不多，我们继续*瞪眼*。比如 $P=4,\,Q=6$。

|$x$|$0$|$1$|$2$|$3$|$4$|$5$|$6$|$7$|$8$|$9$|$10$|$11$|
|-|-|-|-|-|-|-|-|-|-|-|-|-|
|$x \bmod 4$|$0$|$1$|$2$|$3$|$0$|$1$|$2$|$3$|$0$|$1$|$2$|$3$|
|$x \bmod 6$|$0$|$1$|$2$|$3$|$4$|$5$|$0$|$1$|$2$|$3$|$4$|$5$|

观察 $x \bmod 4$ 的每个值对应的 $x \bmod 6$ 的值，发现有的是 $\{0,4,2,0,4,2,\dots\}$，有的是 $\{1,3,5,1,3,5,\dots\}$。进一步*瞪眼*或者推导可以发现，对应的 $x \bmod 6$ 的值到底是哪一种，与 $x \bmod \gcd(P,Q)$ 有关。

具体来讲，$x \bmod \gcd(P,Q)=r$ 时，该 $x \bmod P$ 类对应的 $x \bmod Q$ 的值构成的集合就是 $\{0 \le x <Q \;|\;x \bmod \gcd(P,Q)=r\}$，因为考虑 $Pk+c$ 和 $P(k+1)+c$ 两个数，从一个到下一个 $x \bmod P$ 相等的数需要增加 $P$，从而 $x \bmod Q$ 就可以且只能取遍 $x  \bmod \gcd(P,Q)$ 相等的值了。

在一个整周期内，$x \bmod P=r$ 的数出现了 $\dfrac{\text{lcm}(P,Q)}{P}=\dfrac{Q}{\gcd(P,Q)}$ 次，刚好遍历 $\{0 \le x <Q \;|\;x \bmod \gcd(P,Q)=r\}$。计算整周期的答案时，我们只需要先预处理每一种 $\{0 \le x <Q \;|\;x \bmod \gcd(P,Q)=r\}$ 有多少个 $x \bmod Q \in B$，再对于每一个 $x \bmod P \in A$，加上对应集合的答案即可。

整周期我们只要知道 $\{0 \le x <Q \;|\;x \bmod \gcd(P,Q)=r\}$ 被整个遍历了一遍，但是余下的部分就不能这么考虑了，我们需要知道这个集合中的数的访问顺序。

在上面的例子中，$x \bmod P=0$ 的访问顺序是 $\{0,4,2\}$，而 $x \bmod P=2$ 的访问顺序是 $\{2,4,0\}$。*瞪眼*可得，对于一类 $x \bmod P=r$ 而言，访问顺序 $o$ 满足 $o_1=r \bmod Q,\,o_i=(o_{i-1}+P)\bmod Q$，而 $\{0 \le x <Q \;|\;x \bmod \gcd(P,Q)=r\}$ 实际上是一个 $o$ 构成的环。对于一个整周期而言，只需要整个环的答案，对于非整周期，就需要求环其中一段的和，把所有环求出来用前缀和处理即可。最后仍然是枚举 $x \bmod P \in A$，加上对应集合的答案。

时间复杂度是 $O(P+Q)$。

其实这题思维量没有看起来那么大，正常的思考过程完全没有一点式子，*瞪眼*就行，只是我的题解写的比较抽象。

写起来稍微有一点细节。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,p,q;
ll T;
int a[1000005],b[1000005];
int pre[1000005],pos[1000005];
vector<int>v[1000005];
int main(){
	scanf("%d%d%d%d",&n,&m,&p,&q);
	scanf("%lld",&T);
	ll g=__gcd(n,m);
	ll l=1LL*n*m/g;
	for(int i=1;i<=p;i++){
		int x;
		scanf("%d",&x);
		a[x]=1;
	}
	for(int i=1;i<=q;i++){
		int x;
		scanf("%d",&x);
		b[x]=1;
	}
	ll z=T/l;
	for(int i=0;i<g;i++){
		for(int tmp=i,cnt=0,lst=m;cnt<m/g;lst=tmp,tmp=(tmp+n)%m,cnt++){
			//求环
			pre[tmp]=pre[lst]+b[tmp];
			v[i].push_back(tmp);
			pos[tmp]=cnt;
		}
	}
	ll ans=0;
	for(int i=0;i<n;i++)if(a[i]==1)ans+=pre[v[i%g][m/g-1]];
	ans*=z;
	T-=z*l;
	for(int i=0;i<n;i++)if(a[i]==1){
		int len=T/n+(i<T%n?1:0);
		if(!len)continue;
		int qwq=i%g;//对应集合
		int pl=(pos[i%m]+m/g-1)%(m/g);
		int pr=(pl+len)%(m/g);
		if(pl<pr)ans+=pre[v[qwq][pr]]-pre[v[qwq][pl]];
		else ans+=pre[v[qwq][pr]]+pre[v[qwq][m/g-1]]-pre[v[qwq][pl]];
	}
	printf("%lld",ans);
	return 0;
}

```

---


# [TJOI2019] 甲苯先生的滚榜

## 题目描述

甲苯先生在制作一个 Online Judge，他发现做比赛的人们很关心自己的排名（显而易见）。

在 ACM 赛制的比赛中，如果通过题目数量不相等，则通过题目数量多的人排名更靠前；  
如果通过题目数量相等，则罚时更少的人排名更高。

甲苯先生想让大家帮忙设计一个程序，每次有人通过之后，就告诉他排名在他的前面有多少人。  
（不包括和他罚时题数都相同的同学）

## 说明/提示

| 测试点# | 1, 2 | 3, 4 | 5 |6, 7, 8 | 9, 10 |
| :-: | :-: | :-: | :-: | :-: |:-:|
| $T$ | $\le10$ | $\le5$ | $\le15$ | $\le5$ | $\le5$ |
| $m$ | $\le1000$ | $\le10000$ | $\le10^5$ | $\le10^4$ |$\le10^5$|
| $n$ | $\le1000$ | $\le10000$ | $\le10^5$ | $\le10^6$ |$\le10^6$|


## 样例 #1

### 输入

```
1
7 3 1
```

### 输出

```
0
1
0
```

# 题解

## 作者：clamee (赞：13)

其实这个题 fhqtreap 也是可做的，这题的时间瓶颈实际上在输出而不在平衡树。

这题只有两个操作：

- 求某个值的排名-1

- 修改某个值

第一个操作应该人人都会，第二个操作先删了再加进去就好了。

至于题数和罚时，就重新写个类就行了。
```
#include<bits/stdc++.h>
using namespace std;
int n,m,root;
inline int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}
int tot,ans,s[100005],ls;
struct st{//写个新的val类
	int ria,rib;
	bool operator <(const st b)const{
		if(ria==b.ria)return rib<b.rib;
		else return ria>b.ria;
	}
	bool operator <=(const st b)const{
		if(ria==b.ria)return rib<=b.rib;
		else return ria>=b.ria;
	}
}a[100005];
struct ss{
	int lson,rson,rnd,sz,cnt;st val;
}e[200005];
----------平衡树分割线----------
void push_up(int x)
{
	e[x].sz=e[e[x].lson].sz+e[e[x].rson].sz+e[x].cnt;
}
int merge(int x,int y)
{
	if(!x||!y)return x|y;
	if(e[x].rnd<e[y].rnd)
	{
		e[x].rson=merge(e[x].rson,y);
		push_up(x);return x;
	}
	else
	{
		e[y].lson=merge(x,e[y].lson);
		push_up(y);return y;
	}
}
void split(st k,int now,int &x,int &y)
{
	if(!now)
	{
		x=y=0;
	}
	else
	{
		if(e[now].val<=k)
		{
			x=now;
			split(k,e[now].rson,e[now].rson,y);
		}
		else
		{
			y=now;
			split(k,e[now].lson,x,e[now].lson);
		}
	}
	push_up(now);
}
int new_node(st k)
{
	int now;
	if(ls)now=s[ls--];//写上垃圾回收节省空间
	else now=++tot;
	e[now].sz=e[now].cnt=1;
	e[now].val=k;
	e[now].rnd=rand();
	e[now].lson=e[now].rson=0;
	return now;
}
void insert(st x)
{
	int l,r;
	split(x,root,l,r);
	l=merge(l,new_node(x));
	root=merge(l,r);
}
void del(st x)
{
	int l,a,r;st y=x;
	y.rib--;
	split(x,root,l,r);
	split(y,l,l,a);
	s[++ls]=a;
	a=merge(e[a].lson,e[a].rson);
	root=merge(merge(l,a),r);
}
int ask_val(st x)
{
	int l,r;
	x.rib--;
	split(x,root,l,r);
	int re=e[l].sz+1;
	root=merge(l,r);
	return re-1;
}
-----------分割线结束-----------
typedef unsigned int ui;
    ui randNum(ui& seed, ui last, const ui m) {
    seed = seed * 17 + last;
    return seed % m + 1;
}
ui seed,last=7;
inline void write(int x)//这个必须要，不然会t得很惨
{
	if(x<10)
	{
		putchar(x+48);
		return;
	}
	write(x/10),write(x%10);
}
int main()
{
	int t=read();
	while(t--)
	{
	srand(19260817);
	m=read();n=read();seed=read();
	root=ls=tot=0;
	for(int i=1;i<=m;i++)
		a[i].ria=a[i].rib=0,insert(a[i]);
	int u,v;
	for(int i=1;i<=n;i++)
	{
		u=randNum(seed,last,m);
		v=randNum(seed,last,m);
		del(a[u]);
		a[u].ria++;a[u].rib+=v;
		insert(a[u]);
		last=ask_val(a[u]);
		write(last);
		putchar('\n');	
	}
	}
}
```

---

## 作者：行吟啸九州 (赞：12)

首先```diss```一下```TJOI2019D1T2```出题人，居然出了一道平衡树模板题，属实有点过分了。

题解里的办法大多是维护一个pair，不过这题可以更简单地维护一个```1500000```进制的两位数，第一位是```AC```数，第二位是```1500000 - ``` 罚时数的结果。因为AC数一定```≤```$10^6$,所以这个数在十进制下只有1e12那么大，在```long long```范围内，我们可以采用平衡树维护。

维护办法，就是对于一个点增加了```AC```数和罚时数，将其第一位+1，第二位减去罚时数，然后平衡树查询，再平衡树删去一个点，平衡树加入一个。整个过程需要对每个人维护这个```1500000```进制的数即可。

过程中请注意变量类型的不同，既有```unsigned int```， 又有```long long```，细心一些别弄错了就行。

---

## 作者：do_it_tomorrow (赞：10)

注意到数据随机，所以考虑乱搞。

因为 `vector` 的常数非常的小，所以一个很显然的思路就是直接在 `vector` 里面去 `erase`、`insert` 和 `lower_bound`。

发现过不了，考虑优化。

因为在 `vector` 中进行前两个操作的时间与 `vector` 的长度有很大关系，所以容易想到减小 `vector` 的长度。

考虑开 $n$ 个 `vector`，第 $i$ 个记录 AC 数量为 $i$ 是的罚时数量。

对于查询，先在 `vector` 中二分，然后再查询的 AC 数比自己大的就行了。

对于这个后缀和操作，容易想到用树状数组维护，在发布题解时是最优解。

考虑对于一次操作，最劣的情况肯定是将所有的数全部添加到 `vector` 中之后在把这些元素全部删除。

这样的操作显然只能填满 $10$ 次 `vector`，而因为 `vector` 有 $\dfrac{1}{8}$ 的常数，所以实际上把 $10^5$ 个数实际操作次数的大概只有 $\dfrac{10^{10}}{16}$ 也就是 $6\times 10^8$ 左右。

所以最终的时间复杂度我为 $O(T\times m^2)$，但是有一个 $\dfrac{10}{16}$ 的常数。

所以最终的计算次数大概只有 $3\times 10^{10}$ 左右，考虑到时限有 $10$ 秒所以可以通过。

然而数据是随机的，所以实际上的复杂度还会除以 $2$。

在最后由衷的感谢 [DengDuck](https://www.luogu.com.cn/user/501947)，ta 的帮助让我的题解蓬荜生辉，请关注 [DengDuck](https://www.luogu.com.cn/user/501947) 谢谢。

参考资料： <https://www.luogu.com.cn/article/9yp9o90m>

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
unsigned int n,last=7,seed;
int m,a[N],b[N];
unsigned int get(){ seed=seed*17+last;return seed%n+1; }
vector<int> v[N];
struct BIT{
	int s[N];
	int lowbit(int x){return x&-x;}
	void updata(int x,int v){for(int i=x;i>=1;i-=lowbit(i)) s[i]+=v;}
	int ask(int x){int ans=0;for(int i=x;i<N;i+=lowbit(i)) ans+=s[i];return ans;}
	void clear(){memset(s,0,n*4+5);}
}tr;
void solve(){
	cin>>n>>m>>seed,tr.clear();
	for(int i=0;i<=m;i++) v[i].clear();
	memset(a,0,n*4+5),memset(b,0,n*4+5);
	for(int i=1;i<=m;i++){
		int x=get(),y=get();
		if(a[x]) v[a[x]].erase(lower_bound(v[a[x]].begin(),v[a[x]].end(),b[x])),tr.updata(a[x],-1);
		b[x]+=y,a[x]++;
		auto it=lower_bound(v[a[x]].begin(),v[a[x]].end(),b[x]);
		cout<<(last=it-v[a[x]].begin()+tr.ask(a[x]+1))<<'\n';
		tr.updata(a[x],1),v[a[x]].insert(it,b[x]);
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：sleepyNick (赞：7)

直接大力splay鸭，来个不写指针的

每次操作根据$randNum ()$函数生成Ria和Rib

用$ac[i]$表示i位选手的ac数，$fs[i]$相应地表示罚时

那么每次操作$ac[Ria]++,fs[Ria]+=Rib$

有两个关键字，怎么办？上pair

然后套splay模板（记得一定要插哨兵，我就在这挂了），每个节点的值就是一个pair

pair的first是ac数，那么正常比较，second是罚时，越小的才排在前面，因此插入的时候取负就行了。

splay比较好想~~废话~~常数还是挺大的，不开o2T两个点。。。（但主要也是一种方法嘛对吧）

这道题输出量还是比较大的，换上手写结构体和快写能过

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <algorithm>
#define MAXN 1200100
#define INF 1 << 29
using namespace std;
typedef unsigned int ui;
typedef pair <int, int> pii;

int size[MAXN], son[MAXN][3], father[MAXN], cnt[MAXN], ac[MAXN], fs[MAXN], sz, root, n;
pii val[MAXN];
ui m, seed, last = 7;

//生成数据函数
ui randNum (ui &seed, ui last, ui m) {
    seed = seed * 17 + last;
    return seed % m + 1;
}

//splay模板
struct spaly {
    
    inline void maintain (int x) {
        size[x] = size[son[x][0]] + size[son[x][1]] + cnt[x];
    }
    
    inline void rotate (int x) {
        int y = father[x], z = father[y];
        int k = son[y][1] == x, kk = son[z][1] == y;
        son[z][kk] = x,
        father[x] = z,
        son[y][k] = son[x][k ^ 1],
        father[son[x][k ^ 1]] = y,
        son[x][k ^ 1] = y,
        father[y] = x,
        maintain (y), maintain (x);
    }
    
    inline void splay (int x, int goal) {
        while (father[x] != goal) {
            int y = father[x], z = father[y];
            if (z != goal)
                (son[y][1] == x) ^ (son[z][1] == y)
                    ? rotate (x) : rotate (y);
            rotate (x);
        }
        if (! goal) root = x;
    }
    
    inline int prev (pii x) {
        int now = root, pre;
        while (now) {
            (val[now] < x)
                ? pre = now, now = son[now][1]
                : now = son[now][0];
        }
        return pre;
    }
    
    inline int succ (pii x) {
        int now = root, nxt;
        while (now) {
            (val[now] > x)
                ? nxt = now, now = son[now][0]
                : now = son[now][1];
        }
        return nxt;
    }
    
    inline void del (pii x) {
        int pre = prev (x), nxt = succ (x);
        splay (pre, 0), splay (nxt, pre);
        int pos = son[nxt][0];
        if (cnt[pos] > 1) cnt[pos]--, splay (pos, 0);
        else son[nxt][0] = 0;
    }
    
    inline void insert (pii x) {
        int now = root, fa = 0;
        while (now && x != val[now]) fa = now, now = son[now][x > val[now]];
        if (now) cnt[now]++;
        else {
            now = ++sz;
            if (fa) son[fa][x > val[fa]] = now;
            son[now][0] = son[now][1] = 0;
            size[now] = cnt[now] = 1;
            val[now] = x, father[now] = fa;
        }
        splay (now, 0);
    }
    
}tree;

int main () {
    int T; scanf ("%d", &T);
    for (register int i = 1; i <= T; i++) {
    	scanf ("%d%d%d", &m, &n, &seed), root = 0, sz = 0;
        //一定要插两个哨兵
    	tree.insert (pii (INF, -INF)), tree.insert (pii (-INF, INF));  
        //清空数据
    	memset (ac, 0, sizeof ac), memset (fs, 0, sizeof fs);
    	for (register int j = 1; j <= n; j++) {
    		ui o = randNum (seed, last, m), u = randNum (seed, last, m);
            if (ac[o]) tree.del (pii (ac[o], -fs[o]));
            //如果有这个人，那么删除，注意罚时要取负插入，迎合pair的比较
            ++ac[o], fs[o] += u; tree.insert (pii (ac[o], -fs[o]));
            //处理数据，插入新节点
            last = size[son[root][1]] - 1, printf ("%d\n", last);
            //insert的时候新节点已经旋到根了，直接输出右子树（比它排名高的）即可
        }
    }
    return 0;
}
```


---

## 作者：star_magic_young (赞：4)

首先,排名系统,一看就知道是~~原题~~,可以上平衡树来维护

然后考虑一种比较朴素的想法,因为我们要知道排名在一个人前面的人数,也就是AC数比他多的人数+AC数一样并且罚时少的人数,所以考虑维护那两个东西.AC数更多的人数显然可以直接上树状数组.后者的话可以对每一种AC数开值域线段树,存每个罚时有多少人,注意到罚时之和不会超过$1.5*10^6$,所以动态开点线段树可以轻松解决.然后每次有个人AC数和罚时改变就先在原来的位置-1,然后在新位置+1.每次询问就是树状数组上AC数$>$当前AC数的对应区间之和$+$对应线段树上罚时$<$当前罚时的区间之和

```cpp
// luogu-judger-enable-o2
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<vector>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#include<set>
#define LL long long
#define ui unsigned int

using namespace std;
const int N=1e5+10,M=1e6+10,MX=1500000;
LL rd()
{
    LL x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
ui randNum(ui& seed ,ui last,const ui m)
{ 
    seed=seed*17+last;
    return seed%m+1; 
}
ui sd;
int m,n,a[N],b[N],c[M];
void ad(int x,int y){while(x<=n) c[x]+=y,x+=x&(-x);}
int gsm(int x){int an=0;while(x) an+=c[x],x-=x&(-x);return an;}
int s[M*25],ch[M*25][2],rt[M],tt;
void add(int o1,int o2,int x)
{
    int l=1,r=MX;
    s[o1]=s[o2]+1;
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(x<=mid)
        {
            ch[o1][0]=++tt,ch[o1][1]=ch[o2][1];
            o1=ch[o1][0],o2=ch[o2][0];
            r=mid;
        }
        else
        {
            ch[o1][0]=ch[o2][0],ch[o1][1]=++tt;
            o1=ch[o1][1],o2=ch[o2][1];
            l=mid+1;
        }
        s[o1]=s[o2]+1;
    }
}
void dec(int o,int x)
{
    int l=1,r=MX;
    --s[o];
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(x<=mid) o=ch[o][0],r=mid;
        else o=ch[o][1],l=mid+1;
        --s[o];
    }
}
int quer(int o,int l,int r,int ll,int rr)
{
    if(ll>rr||!o) return 0;
    if(ll<=l&&r<=rr) return s[o];
    int an=0,mid=(l+r)>>1;
    if(ll<=mid) an+=quer(ch[o][0],l,mid,ll,rr);
    if(rr>mid) an+=quer(ch[o][1],mid+1,r,ll,rr);
    return an;
}
    

int main()
{
    int T=rd(),ans=7;
    while(T--)
    {
        m=rd(),n=rd(),sd=rd();
        for(int i=1;i<=n;++i) c[i]=rt[i]=0;
        for(int i=1;i<=m;++i) a[i]=b[i]=0;
        tt=0;
        for(int i=1;i<=n;++i)
        {
            int x=randNum(sd,ans,m),y=randNum(sd,ans,m);
            if(a[x]) dec(rt[a[x]],b[x]),ad(a[x],-1);
            ++a[x],b[x]+=y;
            int las=rt[a[x]];
            add(rt[a[x]]=++tt,las,b[x]),ad(a[x],1);
            ans=gsm(n)-gsm(a[x])+quer(rt[a[x]],1,MX,1,b[x]-1);
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：yzhang (赞：2)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10954797.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P5338)

#### ~~这题明显可以平衡树直接大力整，所以我要说一下线段树+树状数组的做法~~

#### ~~实际线段树+树状数组的做法也很暴力~~

#### 我们先用树状数组维护每个ac数量有多少个队伍。这样就能快速求出有多少队伍ac数比现在这个队伍ac数多

#### 我们再用$n$棵动态开点的线段树，第$i$棵线段树维护的是ac数为$i$的队伍的罚时情况。当一个队伍ac数为$x$罚时为$t$时，就在第$x$棵线段树$t$上加一。这样就能快速求出有多少队伍ac数与现在这个队伍ac数相同且罚时更少

#### 当一个队伍过了一题后就在线段树和树状数组中正常修改即可

```cpp
#include <bits/stdc++.h>
#define M 1000005
#define N 150005
#define ML 1500005
#define uint unsigned int
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
uint randNum(uint& seed,uint last,const uint mod)
{
	seed=17*seed+last;
	return seed%mod+1;
}
struct bit{
	int tr[N];
	inline void init()
	{
		memset(tr,0,sizeof(tr));
	}
	inline void update(register int pos,register int val)
	{
		for(register int i=pos;i<N;i+=i&(-i))
			tr[i]+=val;
	}
	inline int query(register int pos)
	{
		int res=0;
		for(register int i=pos;i;i-=i&(-i))
			res+=tr[i];
		return res;
	}
}tr1;
struct segt{
	struct node{
		int ls,rs,sum;
	}tr[M*40];
	int tot,root[N];
	inline void init()
	{
		memset(root,0,sizeof(root));
		tot=0;
	}
	inline void update(register int &rt,register int l,register int r,register int pos,register int val)
	{
		if(!rt)
		{ 
			rt=++tot;
			tr[rt].ls=tr[rt].rs=tr[rt].sum=0;
		} 
		if(l==r)
		{
			tr[rt].sum+=val;
			return;
		}
		int mid=l+r>>1;
		if(pos<=mid)
			update(tr[rt].ls,l,mid,pos,val);
		else	
			update(tr[rt].rs,mid+1,r,pos,val);
		tr[rt].sum=tr[tr[rt].ls].sum+tr[tr[rt].rs].sum;
	}
	inline int query(register int &rt,register int l,register int r,register int L,register int R)
	{
		if(!rt)
			return 0;
		if(L<=l&&r<=R)
			return tr[rt].sum;
		int mid=l+r>>1,res=0;
		if(L<=mid)
			res+=query(tr[rt].ls,l,mid,L,R);
		if(R>mid)
			res+=query(tr[rt].rs,mid+1,r,L,R);
		return res;
	}
}tr2;
uint seed,last;
int T,n,m,tim[N],num[N];
int main()
{
	T=read();
	last=7;
	while(T--)
	{
		m=read(),n=read(),seed=read();
		memset(num,0,sizeof(num));
		memset(tim,0,sizeof(tim));
		tr1.init(),tr2.init();
		for(register int i=1;i<=m;++i)
			num[i]=1,tim[i]=1;
		tr1.update(1,m),tr2.update(tr2.root[1],1,ML,1,m);
		for(register int i=1;i<=n;++i)
		{
			int p=randNum(seed,last,m),v=randNum(seed,last,m);
			tr1.update(num[p],-1);
			tr2.update(tr2.root[num[p]],1,ML,tim[p],-1);
			++num[p],tim[p]+=v;
			tr1.update(num[p],1);
			tr2.update(tr2.root[num[p]],1,ML,tim[p],1);
			int res=m-tr1.query(num[p]);
			res+=tr2.query(tr2.root[num[p]],1,ML,1,tim[p]-1);
			last=res;
			write(res),puts("");
		}
	}
	return 0;
}

```

---

## 作者：ThomasX (赞：2)

**搬运官方题解。**

------------

简单来说类似于桶排序。在题面中说罚时不超过$1500000$其实已经给了提示这个题可以按照罚时来建立线段树进行排序。

对于每个user来说，比他排名高的人来源于两个地方：第一是题目数更多，第二是罚时更少。所以我们可以根据题目数量建立树状数组，去维护ac题目数量的前缀和。对于题数相同的同学，我们就可以用线段树去维护罚时。但是我们发现 $1500000\times$平均ac数量$\times4$ 是会MLE的，所以我们这时需要动态建立线段树（类似于主席树的方法）

所以对于每一次询问，时间复杂度为约 $log(1500000)+log(n/m)$ 。空间复杂度为 $log(1500000)+(n/m)$ 。

注: $n/m$代表近似于ac题目数量，直接开一个比较大的数组也可以做。

常数比较小的splay也可以过这道题的绝大部分样例点。

------------

std
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <ctime>

#define mid (l + r >> 1)

const int MQ = 1000005;
const int MAX = 150000;
const int MLEN = 1500010;

typedef unsigned int ui;

ui randNum(ui& seed, ui last, const ui mod){
	seed = 17 * seed + last;
	return seed % mod + 1;
}

struct bi_tree{
	int m_arr[MAX];
	int lowbit(int num){
		return num & (-num);
	}

	void init(){
		memset(m_arr, 0, sizeof(m_arr));
	}
	void update(int p, int v){
		while(p < MAX) {
			m_arr[p] += v;
			p += lowbit(p);
		}
	}
	int get(int p){
		int res = 0;
		while(p > 0){
			res += m_arr[p];
			p -= lowbit(p);
		}
		return res;
	}
};

struct sgm_tree{
	struct node{
		int lc, rc;
		int num;
	};
	node sgm[MQ * 40];
	int head[MAX];
	int top;
	void init(){
		memset(head, 0, sizeof(head));
		top = 1;
	}
	void update(int& nd, int l, int r, int p, int num){
		if(nd == 0){
			nd = top++;
			sgm[nd].lc = sgm[nd].rc = sgm[nd].num = 0;
		}
		if(p == l && p == r){
			sgm[nd].num += num;
			return;
		}
		if(p <= mid){
			update(sgm[nd].lc, l, mid, p, num);
		}
		else{
			update(sgm[nd].rc, mid + 1, r, p, num);
		}
		sgm[nd].num = sgm[sgm[nd].lc].num + sgm[sgm[nd].rc].num;
	}
	int get(int& nd, int l, int r, int L, int R){
		if(nd == 0) return 0;
		if(l == L && r == R){
			return sgm[nd].num;
		}
		if(R <= mid){
			return get(sgm[nd].lc, l, mid, L, R);
		}
		else if(L > mid){
			return get(sgm[nd].rc, mid + 1, r, L, R);
		}
		else{
			return get(sgm[nd].lc, l, mid, L, mid) + get(sgm[nd].rc, mid + 1, r, mid + 1, R);
		}
	}

};

int p_num[MAX];
int p_tim[MAX];
bi_tree bt;
sgm_tree st;

int main()
{

	freopen("roll.in", "r", stdin);
	freopen("roll.out", "w", stdout);
	ui seed, last;
	int m, n, casen, i, p, v, res;
	scanf("%d", &casen);
	last = 7;
	while(casen--){
		scanf("%d%d%d", &m, &n, &seed);
		memset(p_tim, 0, sizeof(p_tim));
		memset(p_num, 0, sizeof(p_num));
		bt.init();
		st.init();

		for(i = 1; i <= m; i++){
			p_num[i] = 1;
			p_tim[i] = 1;
		}
		bt.update(1, m);
		st.update(st.head[1], 1, MLEN, 1, m);
		for(i = 0; i < n; i++){
			p = randNum(seed, last, m);
			v = randNum(seed, last, m);
			bt.update(p_num[p], -1);
			st.update(st.head[p_num[p]], 1, MLEN, p_tim[p], -1);

			p_num[p]++;
			p_tim[p] += v;

			bt.update(p_num[p], 1);
			st.update(st.head[p_num[p]], 1, MLEN, p_tim[p], 1);

			res = m - bt.get(p_num[p]);
			res += st.get(st.head[p_num[p]], 1, MLEN, 1, p_tim[p] - 1);
			last = res;
			printf("%d\n", res);
		}
	}
	return 0;
}

```


---

## 作者：Vozeo (赞：2)

平衡树裸题。

害怕用`pair`过不去，开了一个结构体记录$AC$次数和罚时，重载几个运算符。开一个数组记录每个人的$AC$次数和罚时，每次修改时删除旧节点，插入新节点，再输出第$k$大就好啦。

`last`只需要在第一次设置为7，以后都不需要重置。

放一下代码。用`splay`实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i_, s_, t_) for (int i_ = (s_); i_ <= (t_); ++i_)

const int N = 2e6 + 5;

struct Sta {
    int ac, ti;
    Sta() {}
    Sta(int x, int y) : ac(x), ti(y) {}
    bool operator < (const Sta &rhs) const {
        return ac == rhs.ac ? ti < rhs.ti : ac > rhs.ac;
    }
    bool operator == (const Sta &rhs) const {
        return ac == rhs.ac && ti == rhs.ti;
    }
    bool operator != (const Sta &rhs) const {
        return ac != rhs.ac || ti != rhs.ti;
    }
} g[N << 1];

struct Node *root;
struct Node {
    Node *fa, *ch[2];
    Sta v;
    int cnt, siz;
    Node() {}
    Node(Node *f, Sta x) : fa(f), v(x), cnt(1), siz(1) {}
    void upd() {
        siz = cnt + (ch[0] ? ch[0]->siz : 0) + (ch[1] ? ch[1]->siz : 0);
    }
    int rel() {
        return fa ? fa->ch[1] == this : 0;
    }
    void link(Node *o, Node *f, int r) {
        if (o) o->fa = f;
        if (f) f->ch[r] = o;
    }
    void rot() {
       Node *f = fa;
       int r = rel();
       link(this, f->fa, f->rel());
       link(ch[r ^ 1], f, r);
       link(f, this, r ^ 1);
       f->upd(), upd();
       if (!fa) root = this;
    }
    void splay(Node *tar = NULL) {
        while (fa != tar) {
            if (fa->fa == tar) rot();
            else if (rel() == fa->rel())
                fa->rot(), rot();
            else rot(), rot();
        }
    }
    int rnk() {
        return ch[0] ? ch[0]->siz : 0;
    }
    Node *pre() {
        Node *o = ch[0];
        while (o->ch[1])
            o = o->ch[1];
        return o;
    }
    Node *suc() {
        Node *o = ch[1];
        while (o->ch[0])
            o = o->ch[0];
        return o;
    }
} tpool[N], *tcur = tpool;

Node *find(Sta x) {
    Node *o = root;
    while (o && o->v != x)
        o = o->ch[o->v < x];
    if (o) o->splay(); // ***
    return o;
}

Node *ins(Node *&o, Node *f, Sta x) {
    if (!o)
        return o = new (tcur++) Node(f, x);
    if (o->v == x)
        return ++o->cnt, o;
    return ins(o->ch[o->v < x], o, x);
}

Node *ins(Sta x) {
    Node *o = ins(root, NULL, x);
    o->splay();
    return o;
}

void del(Node *o) {
    Node *p = o->pre(), *s = o->suc();
    p->splay(), s->splay(p); // ***
    if (o->cnt > 1)
        --o->cnt, --o->siz;
    else s->ch[0] = NULL;
    s->upd(), p->upd();
}

void del(Sta x) {
    Node *o = find(x);
    if (o) del(o);
}

int rnk(Sta x) {
    Node *o = find(x);
    if (o) return o->rnk();
    o = ins(x);
    int ans = o->rnk();
    del(o);
    return ans;
}

void init() {
    memset(tpool, 0, sizeof tpool);
    tcur = tpool;
    root = NULL;
    ins(Sta(INT_MAX, INT_MIN));
    ins(Sta(INT_MIN, INT_MAX));
}

template<typename T>
void read(T &x) {
    char ch;
    while (!isdigit(ch = getchar()));
    for (x = ch - '0'; isdigit(ch = getchar()); x = x * 10 + ch - '0');
}

unsigned int seed, last = 7, n, m, Ra, Rb;

unsigned int randNum() {
    seed = seed * 17 + last;
    return seed % m + 1;
}

void work() {
    init();
    read(m), read(n), read(seed);
    while (n--) {
        Ra = randNum(), Rb = randNum();
        del(g[Ra]);
        ++g[Ra].ac, g[Ra].ti += Rb;
        ins(g[Ra]);
        printf("%d\n", last = rnk(g[Ra]) - 1);
    }
    memset(g, 0, sizeof g);
}

int main() {
    //freopen("roll.in", "r", stdin);
    //freopen("roll.out", "w", stdout);
    int T;
    read(T);
    while (T--)
        work();
}
```

---

## 作者：Anita_Hailey (赞：1)

# 甲苯先生的滚榜解题报告

这题一看，别人都说是平衡树的板子，还都用 **fhq_treap** 打过了，我这么菜，第一眼没看出来时平衡树，第二眼看出来了，之后冒出各种 sb 错误

~~话说 甲苯先生 和 大中锋 是什么梗呀（雾）~~

~~话说去年 **lyz** 是怎么 **T1** 爆零的？~~

~~话说这题这么水我怎么RE这么多次~~

我们这里操作一下，维护一棵平衡树就好了，结点的 *data* 用个结构体封装，然后重载运算符即可。

~~话说我的avl不能开 O2 是什么鬼~~ 

我怕是oier中极少数会avl的人吧。avl树的优点是极为稳定！但是稳定的同时也保证了他肯定是 $O(n \log n)$ 的时间复杂度。

于是很多题可以过。而且他就是最本质的 **BST** 功能极为强大（雾）。

但是像这道题只能得到90pts,因为有太多的删除操作。。

话说开了O2就RE是什么鬼

但是我的替罪羊能过呀！

## avl代码

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long ll;

const int Maxn = 1e5 + 11;

ll t, n, m;

typedef unsigned int ui;

ui seed, ria, rib, last;

ui randNum(ui& seed, ui last, const ui m) {
	seed = seed * 17 + last;
	return seed % m + 1;
}

struct Plr {
	int ac, tim;
	bool operator < (const Plr b) const { return(b.ac == ac) ? tim > b.tim :ac < b.ac; }
	void operator = (const Plr x) { ac = x.ac; tim = x.tim; }
	bool operator ==(const Plr b) const { return  ac == b.ac && tim == b.tim; }
}plr[Maxn];

struct avlNode;

typedef avlNode *avl;

struct avlNode {
	Plr data;
	int size, high, num;
	avl ls, rs;
	int get_size() { return this == NULL ? 0 : this->size; }
	int get_high() { return this == NULL ? 0 : this->high; }
	void update() {
		this->size = this->ls->get_size() + this->rs->get_size() + this->num;
		this->high = max(this->ls->get_high(), this->rs->get_high()) + 1;
	}
	avlNode(Plr x) {
		size = 1;
		high = 1;
		num = 1;
		data = x;
		ls = NULL;
		rs = NULL;
	}
};

avl Single_left(avl k2) {
	avl k1 = k2->ls;
	k2->ls = k1->rs;
	k1->rs = k2;
	k2->update();
	k1->update();
	return k1;
}

avl Single_right(avl k1) {
	avl k2 = k1->rs;
	k1->rs = k2->ls;
	k2->ls = k1;
	k1->update();
	k2->update();
	return k2;
}

avl double_left_right(avl T) {
	T->ls = Single_right(T->ls);
	return Single_left(T);
}

avl double_right_left(avl T) {
	T->rs = Single_left(T->rs);
	return Single_right(T);
}

avl Make_empty(avl T) {
	if(T != NULL) {
		Make_empty(T->ls);
		Make_empty(T->rs);
		delete T;
	}
	return NULL;
}

avl insert(Plr x, avl T) {
	if(T == NULL) { return new avlNode(x); }
	if(x == T->data) {
		++(T->num);
		T->update();
		return T;
	}
	else if(x < T->data) {
		T->ls = insert(x, T->ls);
		T->update();
		if(T->ls->get_high() - T->rs->get_high() == 2) {
			if(x < T->ls->data) { T = Single_left(T); }
			else { T = double_left_right(T); }
		}
	}
	else {
		T->rs = insert(x, T->rs);
		T->update();
		if(T->rs->get_high() - T->ls->get_high() == 2) {
			if(T->rs->data < x) { T = Single_right(T); }
			else { T = double_right_left(T); }
		}
	}
	T->update();
	return T;
}

avl erase(Plr x, avl T) {
	if(T == NULL) return NULL;
	if(T->data == x) {
		if(T->num > 1) {
			--(T->num);
			T->update();
			return T;
		}
		else if(T->ls && T->rs) {
			avl tmp = T->rs;
			while(tmp->ls) { tmp = tmp->ls; }
			T->num = tmp->num;
			T->data = tmp->data;
			tmp->num = 1;
			T->rs = erase(tmp->data, T->rs);
			T->update();
			if(T->ls->get_high() - T->rs->get_high() == 2) {
				if(T->ls->ls->get_high() >= T->ls->rs->get_high()) { T = Single_left(T); }
				else { T = double_left_right(T); }
			}
		}
		else {
			avl tmp = T;
			if(T->ls) T = T->ls;
			else if(T->rs) T = T->rs;
			else T = NULL;
			delete tmp;
		}
	}
	else if(x < T->data) {
		T->ls = erase(x, T->ls);
		T->update();
		if(T->rs->get_high() - T->ls->get_high() == 2) {
			if(T->rs->rs->get_high() >= T->rs->ls->get_high()) { T = Single_right(T); }
			else { T = double_right_left(T); }
		}
	}
	else {
		T->rs = erase(x, T->rs);
		T->update();
		if(T->ls->get_high() - T->rs->get_high() == 2) {
			if(T->ls->ls->get_high() >= T->ls->rs->get_high()) { T = Single_left(T); }
			else { T = double_left_right(T); }
		}
	}
	if(T == NULL) return NULL;
	T->update();
	return T;
}

int get_rank(Plr x, avl T) {
	if(T->data == x) return T->rs->get_size();
	if(x < T->data) return get_rank(x, T->ls) + T->rs->get_size() + T->num;
	return get_rank(x, T->rs);
}

avl T = NULL;

int read() {
	int x = 0;
	char ch = getchar();
	while(ch <'0' || ch >'9') ch = getchar();
	while(ch <= '9' && ch >= '0') {
		x = (x << 1) + (x << 3) + (ch - '0');
		ch = getchar();
	}
	return x;
}

void write(int x){
	if(x < 10) {
		putchar(x + 48);
		return;
	}
	write(x / 10), write(x % 10);
}
int main() {
	//freopen("test.in", "r", stdin);
	t = read();
	last = 7;
	while(t--) {
		m = read(); n = read(); seed = read();
		for(int i = 1; i <= m; ++i) {
			plr[i].ac = plr[i].tim = 0;
			T = insert(plr[i], T);
		}
		for(int i = 1; i <= n; ++i) {
			ria = randNum(seed, last, m);
			rib = randNum(seed, last, m);
			T = erase(plr[ria], T);
			plr[ria].ac++; plr[ria].tim += rib;
			T = insert(plr[ria], T);
			last = get_rank(plr[ria], T);
			write(last);
			putchar('\n');
		}
		T = Make_empty(T);
	}
	return 0;
}
```

在保证不RE的时候码量+调试难度堪比猪国杀。

## 替罪羊

~~这道题用替罪羊就比较合适了（虽然开了O2才能过）~~

因为结点实在是太多了！！！这就是替罪羊的弊端。

```c++
#define _CRT_SECURE_NO_WARNINGS
#pragma GCC optimize(2)

#include <iostream>
#include <cstdio>
#include <vector>

template<typename T> inline T abs(const T &a) { return a < 0 ? -a : a; }

const int Maxn = 1e5 + 11;

struct Plr {
	int ac, tim;
	void operator = (const Plr &x) { ac = x.ac; tim = x.tim; return; }
	bool operator < (const Plr &x) const { return ac == x.ac ? tim > x.tim:ac < x.ac; }
	bool operator == (const Plr &x) { return ac == x.ac && tim == x.tim; }
	bool operator <= (const Plr &x) const { return ac == x.ac ? tim >= x.tim : ac <= x.ac; }
}plr[Maxn];

#define get getchar
#define put putchar

int read() { int x = 0; bool f = 0; char ch = get(); while(ch < '0' || ch >'9') { f = (ch == '-'); ch = get(); }while(ch <= '9' && ch >= '0') { x = (x << 1) + (x << 3) + (ch - '0'); ch = get(); }return f ? -x : x; }
void write(int x) { if(x < 0) { put('-'); x = abs(x); }if(x < 10) { put(x + 48); return; }write(x / 10); put(x % 10 + 48); }
void write(Plr x) { write(x.ac); put(' '); write(x.tim); put('\n'); }

#undef put
#undef get

using namespace std;

typedef double db;

const double alpha = 0.7125;

#define al alpha

struct sgtNode;

typedef sgtNode *sgt;

struct sgtNode {
	Plr data;
	int size, valid;
	bool del;
	sgt ls, rs;
	bool bad() { return (double)this->ls->size > al *(double) this->size || (double)this->rs->size > al *(double) this->size; }
	void update() { this->size = this->ls->size + this->rs->size + 1; this->valid = this->ls->valid + this->rs->valid + !this->del; }
};

sgt NullNode = NULL;

sgt Makety(sgt T) {
	if(T != NullNode) {
		T->ls = Makety(T->ls);
		T->rs = Makety(T->rs);
		delete T;
		T = NULL;
	}
	return NULL;
}

void output(sgt T) {
	if(T != NullNode) {
		output(T->ls);
		putchar(' ');
		write(T->data);
		putchar(' ');
		output(T->rs);
	}
	return;
}


sgt build(vector <sgt> &ve, int l, int r) {
	if(l > r) return NullNode;
	int mid = (l + r) >> 1;
	sgt T = ve[mid];
	T->ls = build(ve, l, mid - 1);
	T->rs = build(ve, mid + 1, r);
	T->update();
	return T;
}

void dfs(sgt T, vector <sgt> &ve) {
	if(T == NullNode) return;
	dfs(T->ls, ve);
	if(!T->del) ve.push_back(T);
	dfs(T->rs, ve);
	if(T->del) { delete T; }
}

sgt rebuild(sgt T) {
	vector <sgt> ve;
	dfs(T, ve);
	return build(ve, 0, ve.size() - 1);
}

sgt insert(sgt T, Plr x) {
	if(T == NullNode) {
		T = new sgtNode();
		T->ls = T->rs = NullNode;
		T->data = x;
		T->del = 0;
		T->size = T->valid = 1;
		return T;
	}
	++(T->size); ++(T->valid);
	if(T->data <= x) { T->rs = insert(T->rs, x); }
	else { T->ls = insert(T->ls, x); }
	if(T->bad()) { T = rebuild(T); }
	return T;
}

sgt erase(int rnk, sgt T) {
	if(!T->del && rnk == T->ls->valid + 1) {
		T->del = 1;
		--(T->valid);
		return T;
	}
	--(T->valid);
	if(rnk <= T->ls->valid + !T->del) { T->ls = erase(rnk, T->ls); }
	else { T->rs = erase(rnk - T->ls->valid - !T->del, T->rs); }
	return T;
}

int get_rank(sgt T, Plr x) {
	int ans = 1;
	while(T != NullNode) {
		if(x <= T->data) { T = T->ls; }
		else { ans += T->ls->valid + !T->del; T = T->rs; }
	}
	return ans;
}

int get_rank1(sgt T, Plr x) {
	int ans = 0;
	while(T != NullNode) {
		if(x < T->data) { ans += T->rs->valid + !T->del; T = T->ls; }
		else { T = T->rs;}
	}
	return ans;
}

typedef unsigned int ui;

ui seed, last, m, n, t;

ui randNum(ui& seed, ui last, const ui m) {
	seed = seed * 17 + last;
	return seed % m + 1;
}

int main() {
	//freopen("in.txt", "r", stdin);
	t = read();
	last = 7;
	NullNode = new sgtNode();
	while(t--) {
		sgt rot = NullNode;
		m = read(); n = read(); seed = read();
		for(int i = 1; i <= (int)m; ++i) {
			plr[i].ac = plr[i].tim = 0;
			rot = insert(rot, plr[i]);
		}
		int ria, rib;
		while(n--) {
			ria = randNum(seed, last, m);
			rib = randNum(seed, last, m);
			rot = erase(get_rank(rot, plr[ria]), rot);
			plr[ria].ac++;
			plr[ria].tim += rib;
			rot = insert(rot, plr[ria]);
			last = get_rank1(rot, plr[ria]);
			write(last);
			putchar('\n');
		}
		rot = Makety(rot);
	}
	return 0;
}
```

但是较好调试，代码短

---

## 作者：Rainy_chen (赞：1)

不得不说这道题绝对是入门splay的绝世好题 卡了我一天的常 

很显然我们可以看出我们只需要支持两个操作
- 删除某一权值的人
- 加入某一权值的人  

那么很显然我们可以拿平衡树维护 我们平衡树只需要支持删除和插入就好了 

我相信各位都会写一些高效平衡树 但是我不会 我只会fhq-treap  

我认为以我的常数fhq-treap根本不可能通过这道题 事实上 我的fhq-treap只拿到了五十分的优秀成绩  

所以我去学了一下splay 并尝试使用splay解决它 然后经历了四次重构以后成功的卡进了10秒

简单说一下splay需要卡常的点以及坑点
- 某位大佬说过的 把两个属性压缩成一个属性
- 删除的时候你当然可以按照权值再去用$logn$的时间找到这个点 然后处理它 但是这样做很慢 你可以记录下来每一个人对应的splay上的点 然后直接操作这个点
- 清空树的时候把记录节点数的cnt设置成0就好了 再去遍历一遍整棵树也会导致常数变大
- 不需要写读入优化 但是一定要写输出优化 这题输出量达到了恐怖的七位数
  - 我不知道为什么 但是我自己跑的时候fwrite比putchar跑得慢
- 跑完一组数据之后不需要清空last 我第一次因为这个wa了
- 能不splay就不要splay 比如你在插入一个节点过后是一定要将它splay到根的 但是紧接着查询排名的时候 可以直接把他的左子树大小搞出来 也就是说能直接通过人脑yy得出的东西就不要去麻烦计算机计算
 
然后顺便给出最后两个点的数据(仅输入)  
![QAQ](https://i.loli.net/2019/05/13/5cd9218918b3391251.jpg)  

最后丢一个贼丑的代码
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize(3)
#pragma GCC optimize("inline")

#include<bits/stdc++.h>

using namespace std;

typedef unsigned int ui;
typedef long long int_t;
typedef int int_T;

const int_t maxn = 1200100;
const int_t base = 23;
const int_t tmpb = 1<<23;
#define il inline 

il ui randNum(ui& seed, ui last, const ui m) {
    seed = seed * 17 + last;
    return seed % m + 1;
}


il int_t getAC(int_t rt){return rt>>24;}
il int_t getTim(int_t rt){return (rt>>1)&(tmpb-1);}
il bool cmp(int_t a,int_t b){return getAC(a)==getAC(b)?getTim(a)<getTim(b):getAC(a)>getAC(b);}
il int_t getW(int_t AC,int_t tim){return (AC << 24) | (tim<<1);}

int_T son[maxn][2],fa[maxn],size[maxn],ac[maxn],ys[maxn];
int_T root,last=7,cnt=0;
int_t w[maxn],tw[maxn];

il bool check(int_T rt){
    return son[fa[rt]][1] == rt;
}

il void pushup(int_T rt){
    size[rt] = size[son[rt][0]] + size[son[rt][1]] + ac[rt];
}

il void rotate(int_T rt){
    int_T tfa = fa[rt],gfa = fa[tfa];
    bool ck = check(rt);
    fa[rt] = gfa;
    if(gfa)son[gfa][check(tfa)] = rt;
    son[tfa][ck] = son[rt][!ck];
    if(son[rt][!ck])fa[son[rt][!ck]] = tfa;
    son[rt][!ck] = tfa;
    fa[tfa] = rt;
    size[rt] = size[tfa];
    pushup(tfa);
}

il void splay(int_T rt,int_T goal){
    while(fa[rt] != goal){
        if(fa[fa[rt]] != goal){
            if(check(rt) == check(fa[rt]))rotate(fa[rt]);
            else rotate(rt);
        }
        rotate(rt);
    }
    if(goal == 0)root = rt;
}

il void insert(int_t W){
    int_T rt = root,tfa = 0;
    while(w[rt] != W && rt)tfa = rt,rt = son[rt][cmp(w[rt],W)];
    if(rt)++ac[rt];
    else {
        w[++cnt] = W;
        ac[cnt] = size[cnt] = 1;
        son[cnt][0] = son[cnt][1] = fa[cnt] = 0;  
        if(tfa) {
            fa[cnt] = tfa;
            son[tfa][cmp(w[tfa],W)] = cnt;
        } 
        rt = cnt;
    }
    splay(rt,0);
}

il int_T pre(int_T rt){rt=son[rt][0];while(son[rt][1])rt=son[rt][1];return rt;}
il int_T nxt(int_T rt){rt=son[rt][1];while(son[rt][0])rt=son[rt][0];return rt;}

il void del(int_t rt){
    splay(rt,0);
    int_T p = pre(rt),n = nxt(rt);
    splay(p,0);splay(n,p);
    if(ac[rt] > 1)--ac[rt],--size[rt],--size[p],--size[n];
    else {son[n][0] = fa[rt] = size[rt] = ac[rt] = w[rt] = 0;--size[n],--size[p];}
}

void write(int_T x){
    if(x > 9)write(x/10);
    putchar(x%10 + '0');
}

void work(){
    ui seed,m,n;
    scanf("%d%d%d",&m,&n,&seed);
    root = son[0][0] = son[0][1] = w[0] = fa[0] = 0;
    cnt = 0;
    for(int_T i=1;i<=m;i++)
        insert(1),tw[i] = 1,ys[i]=1;
    insert(getW(n+23,0));
    insert(getW(0,233));
    while(n--){
        ui Ria = randNum(seed,last,m),Rib = randNum(seed,last,m);
        del(ys[Ria]);
        tw[Ria] += (tmpb + Rib) << 1;
        insert(tw[Ria]);
        ys[Ria] = root;
        last = size[son[root][0]]-1;
        write(last);putchar('\n');
    }
}

int main(){
    int_t T;scanf("%d",&T);
    while(T--)
        work();
}
```

---

## 作者：zl_just (赞：1)

平衡树板子题  
不用担心 暴力删点 加点 开$O2$能过  
反正省选能开 ~~为什么$NOIP$没有~~
### First
用一个结构体保存节点
```cpp
struct kkk {
    int ac,rib;
    bool operator == (const kkk& res) const {
        return ac==res.ac&&rib==res.rib;
    }
    bool operator < (const kkk& res) const {
        return ac>res.ac||(ac==res.ac&&rib<res.rib);
    }
    bool operator <= (const kkk& res) const {
        return *this<res||*this==res; 
    }
};
```
~~我也不知道为什么要用这个名字~~

### Second
平衡树板子  
```cpp
略
```
见以下代码
## Third 加点 删点
用$AC[a]$表示$a$的题数,$RIB[b]$表示罚时  
当$a$ $AC$了一题,罚时为$b$时  
那我们删点{$AC[a]$,$RIB[a]$}  
然后加点{$++AC[a]$,$RIB[a]+=b$} 并求排名就可以了   

完整$CODE$
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<cstring>

struct kkk {
    int ac,rib;
    bool operator == (const kkk& res) const {
        return ac==res.ac&&rib==res.rib;
    }
    bool operator < (const kkk& res) const {
        return ac>res.ac||(ac==res.ac&&rib<res.rib);
    }
    bool operator <= (const kkk& res) const {
        return *this<res||*this==res; 
    }
};

namespace zl_just {
    template<typename T>
    class Treap {
        public:
        static const int maxn = 1000000 + 5;
        struct Node {
            T v;
            int c,s,r;
            Node *ch[2];
            inline int cmp(T x) {
                if(x==v) return -1;
                return v<x;
            }
            inline int ch_size(int d) { return ch[d]==NULL?0:ch[d]->s; }
            inline void maintain() { s=c+ch_size(0)+ch_size(1); }
        }node[maxn];
        Node* root;
        int size;
        Treap() { root=NULL; size=0; }
        inline void clear() { root=NULL; size=0; }
        
        inline void rotate(Node* &o,int d) {
            Node *k=o->ch[d^1]; o->ch[d^1]=k->ch[d]; k->ch[d]=o; 
            o->maintain(); k->maintain(); o=k;
        }
        
        void insert(Node* &o,T x) {
            if(o==NULL) {
                o=&node[size++]; o->r=rand();
                o->v=x; o->s=o->c=1;
                o->ch[0]=o->ch[1]=NULL;
            }
            else {
                int d=o->cmp(x);
                if(d==-1) { o->c++; o->s++; return ; }
                insert(o->ch[d],x); o->maintain();
                if(o->ch[d]->r > o->r) rotate(o,d^1);
            }
        }
        
        void remove(Node* &o,T x) {
            if(o==NULL) return ;
            int d=o->cmp(x);
            if(d==-1) {
                if(o->c > 1) { o->c--; o->s--; return ; }
                else if(o->ch[0]==NULL) o=o->ch[1];
                else if(o->ch[1]==NULL) o=o->ch[0];
                else {
                    int d2 = (o->ch[0]->r > o->ch[1]->r);
                    rotate(o,d2); remove(o->ch[d2],x);
                }
            }
            else remove(o->ch[d],x);
            if(o!=NULL) o->maintain();
        }
        
        int rank(Node *o,T x) {
            int rk=0;
            while(o!=NULL) {
                int d=o->cmp(x);
                if(d==-1) return rk+o->ch_size(0);
                if(d) rk+=o->ch_size(0)+o->c;
                o=o->ch[d];
            }  
            return rk;
        }
    };
}
//模板

using namespace zl_just;
int AC[1000005],RIB[1000005];
Treap<kkk>treap;

typedef unsigned int ui;
    ui randNum(ui& seed, ui last, const ui m) {
    seed = seed * 17 + last;
    return seed % m + 1;
}

int main() {
    srand(time(NULL));
    int T,last=7;
    //注意了,是开始为7,不是每组数据都重置为7
    scanf("%d",&T);
    while(T--) {
        ui n,m,seed;
        treap.clear();
        memset(AC,0,sizeof AC);
        memset(RIB,0,sizeof RIB);
        //数组一定要清干净!!!
        scanf("%d%d%d",&m,&n,&seed);
        for(register ui i=0;i<n;i++) {
            ui a=randNum(seed,last,m),b=randNum(seed,last,m);
            treap.remove(treap.root,(kkk){AC[a],RIB[a]});
            AC[a]++; RIB[a]+=b;
            treap.insert(treap.root,(kkk){AC[a],RIB[a]});
            //其实可以便插便查排名
            last=treap.rank(treap.root,(kkk){AC[a],RIB[a]});
            printf("%d\n",last);
        }
    }	
    return 0;
}
```


---

## 作者：Parabola (赞：1)

### Part0.题外话

省选也敢出平衡树板子题了？

我还一遍过了OrzOrz

### Part1.思路

事实上会有平衡树被卡死，你应该用什么平衡树？

首先我最不喜欢的平衡树就是fhq-Treap，这个东西的常数非常大。

为了您的前途，请不要在考场上写fhq-Treap，不要认为它常数小，即使是序列维护题，如果你时间够，请选择splay。

那splay呢？不错的平衡树，但是有点麻烦。

普通Treap就行了。

只要写代码的时候注意自己的常数。

例如不要每一次都memset，要想好自己一定要memset哪些

如果对自己的常数没有把握就不要用stl（反正我用了）

还想说的一点就是这个随机怎么随机，我推荐你们用mt19937，不过是c++11的，它产出的随机数比rand靠谱

### Part2.Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i , a , b) for(int i = (a) ; i <= (b) ; ++i)
#define irep(i , a , b) for(int i = (b) ; i >= (a) ; --i)
#define IO ios::sync_with_stdio(false)
#define ms(A) memset(A , 0 , sizeof A)
#define msinf(A) memset(A , 0x3f , sizeof A)
typedef long long ll;
typedef pair <int , int> pii;

const int inf = 0x3f3f3f3f;
const ll infLL = 0x3f3f3f3f3f3f3f3fLL;

const int N = 1000000 + 5;

mt19937 rnd(time(0));

int n , m , tmp;

typedef unsigned int ui;
ui sd , lst = 7;
ui randNum(ui& seed, ui last, const ui n) {seed = seed * 17 + last;return seed % n + 1;}

int ac[N] , fs[N];

int cnt , sz[N << 1] , rp[N << 1] , ch[N << 1][2];
pii val[N << 1];

#define lc(o) ch[o][0]
#define rc(o) ch[o][1]
int rt;
int cmp(int o , pii x) {return val[o] < x;}
void up(int o) {sz[o] = sz[lc(o)] + sz[rc(o)] + 1;}
void rotate(int& o , int d) {
	int k = ch[o][d];
	ch[o][d] = ch[k][d ^ 1];
	ch[k][d ^ 1] = o; up(o); up(k); o = k;
}

void insert(int& o , pii x) {
	if(!o) {
		val[o = ++cnt] = x; lc(o) = rc(o) = 0;
		rp[o] = rnd(); sz[o] = 1;
	}
	else {
		int d = cmp(o , x);
		insert(ch[o][d] , x); if(rp[ch[o][d]] < rp[o]) rotate(o , d);
		up(o);
	}
}
void erase(int& o , pii x) {
	if(val[o] == x) {
		if(lc(o) * rc(o)) {
			int d = rp[lc(o)] < rp[rc(o)];
			rotate(o , d ^ 1);
			erase(ch[o][d] , x);
		}
		else o = lc(o) + rc(o); 
	}
	else erase(ch[o][cmp(o , x)] , x);
	if(o) up(o);
}
int rnk(int o , pii x) {
	if(!o) return 0;
	if(val[o] <= x) return rnk(rc(o) , x);
	return sz[rc(o)] + 1 + rnk(lc(o) , x);
}

void solve() {
	ms(fs); ms(ac); rt = 0; cnt = 0;
	scanf("%d %d %d" , &n , &m , &tmp); sd = (ui)tmp;
	rep(i , 1 , m) {
		int id = randNum(sd , lst , n);
		if(ac[id] != 0) erase(rt , pii(ac[id] , -fs[id]));
		++ac[id]; fs[id] += randNum(sd , lst , n);
		printf("%d\n" , tmp = rnk(rt , pii(ac[id] , -fs[id])));
		insert(rt , pii(ac[id] , -fs[id]));
		lst = (ui)tmp;
	}
}

int main() {
	int T;
	scanf("%d" , &T);
	while(T--) solve();
	return 0;
} 
```

---

## 作者：Great_Influence (赞：1)

第一眼就看出是平衡树裸题。

那么就直接用 pbds 按题意模拟即可。(这个库可是直接就可以用的)

代码:
```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<iostream>
#include<climits>
#include<vector>
#include<bitset>
#include<queue>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
		if(nowps-Out>=1<<23)flush();
	}

	inline void getstr(char*q)
	{
		register char ch;
		for(ch=getc();!isgraph(ch);ch=getc());
		for(;isgraph(ch);ch=getc())*q++=ch;
		*q='\0';
	}

	inline void getwd(char&x){for(x=getc();!isupper(x);x=getc());}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void Chkmax(double&u,double v){u<v?u=v:0;}

inline void Chkmax(ll&u,ll v){u<v?u=v:0;}

inline void Chkmin(ll&u,ll v){u>v?u=v:0;}

const int MAXN=1e5+7;

static int n,m;

uint32 seed;

uint32 randnm(uint32&seed,uint32 lst,const uint32 m)
{
	seed=seed*17+lst;return seed%m+1;
}

inline void init(){read(m),read(n),read(seed);}

#include<bits/extc++.h>
using namespace __gnu_pbds;
typedef pair<int,ll>Pr;

tree<Pr,null_type,greater<Pr>,rb_tree_tag,tree_order_statistics_node_update>G;

static int AC[MAXN];

static ll tim[MAXN];

static int last;

const int bl=1e7;

inline void solve()
{
	G.clear();
	Rep(i,1,m)AC[i]=0,tim[i]=1.5e14+i,G.insert(mp(0,tim[i]));
	Rep(i,1,n)
	{
		int ria=randnm(seed,last,m),rib=randnm(seed,last,m);
		G.erase(mp(AC[ria],tim[ria]));
		++AC[ria],tim[ria]-=(ll)rib*bl;
		G.insert(mp(AC[ria],tim[ria]));
		write(last=G.order_of_key(mp(AC[ria],tim[ria]/bl*bl+bl-1000)));
	}
}

int main()
{
	file();
	static int _;
	read(_),last=7;
	while(_--)init(),solve();
	flush();
	return 0;
}
```

---

## 作者：览遍千秋 (赞：0)

## [My blog](https://www.cnblogs.com/liubainian/)

---

## 问题描述

[LG5338](https://www.luogu.org/problem/P5338)

[LOJ3105](https://loj.ac/problem/3105)

[BZOJ5509](https://www.lydsy.com/JudgeOnline/problem.php?id=5509)

---

## 题解

建立一棵$\mathrm{Treap}$，把原来的$val$换成两个值$ac,tim$

原来的比较$val_a<val_b$改成（设两个结点分别为$node_a,node_b$）：

1.若$ac_a>ac_b$，则$node_a<node_b$

2.若$1$不成立，若$ac_a=ac_b,tim_a<tim_b$，则$node_a<node_b$

3.若$1,2$均不成立，则$node_a>node_b$

~~10s时限简直要卡爆评测机~~

---

## $\mathrm{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

template<typename Tp>
void read(Tp &x){
    x=0;char ch=1;int fh;
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') fh=-1,ch=getchar();
    else fh=1;
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    x*=fh;
}

const int INF=0x3f3f3f3f;
const int maxm=1000000+7;

int n,T,root;

unsigned seed,las=7,m;

typedef unsigned int ui;
    ui randNum(ui& seed, ui last, ui m) {
    seed = seed * 17 + last;
    return seed % m + 1;
}

int dat[maxm],size[maxm],cnt[maxm],ac[maxm],tim[maxm];
int ch[maxm][2],tot;

int nowac[maxm*10],nowtim[maxm*10];

void pushup(int x){
    size[x]=size[ch[x][0]]+size[ch[x][1]]+cnt[x];
}

int New(int a,int b){
    dat[++tot]=rand(),size[tot]=cnt[tot]=1,ac[tot]=a,tim[tot]=b;
    return tot;
}

void build(){
    tot=0;
    root=New(INF,-INF);ch[root][1]=New(-INF,INF);
    pushup(root);
}

void rotate(int &id,int dir){
    int tmp=ch[id][dir xor 1];
    ch[id][dir xor 1]=ch[tmp][dir];
    ch[tmp][dir]=id;id=tmp;
    pushup(ch[id][dir]);pushup(id);
}

void insert(int &id,int a,int b){
    if(!id){
        id=New(a,b);return;
    }
    if(a==ac[id]&&b==tim[id]) cnt[id]++;
    else{
        int d;
        if(a>ac[id]) d=0;
        else if(a==ac[id]){
            if(b<tim[id]) d=0;
            else d=1;
        }
        else d=1;
        insert(ch[id][d],a,b);
        if(dat[id]<dat[ch[id][d]]) rotate(id,d xor 1);
    }
    pushup(id);
}

void remove(int &id,int a,int b){
    if(!id) return;
    if(ac[id]==a&&tim[id]==b){
        if(cnt[id]>1){
            cnt[id]--;pushup(id);return;
        }
        if(ch[id][0]||ch[id][1]){
            if(!ch[id][1]||dat[ch[id][0]]>dat[ch[id][1]]){
                rotate(id,1);remove(ch[id][1],a,b);
            }
            else{
                rotate(id,0);remove(ch[id][0],a,b);
            }
            pushup(id);
        }
        else id=0;
        return;
    }
    if(a>ac[id]){
        remove(ch[id][0],a,b);
    }
    else if(a==ac[id]){
        if(b<tim[id]) remove(ch[id][0],a,b);
        else remove(ch[id][1],a,b);
    }
    else remove(ch[id][1],a,b);
    pushup(id);
}

int get_rank(int id,int a,int b){
    if(!id) return 0;
    if(a==ac[id]&&b==tim[id]) return size[ch[id][0]]+1;
    if(a>ac[id]) return get_rank(ch[id][0],a,b);
    else if(a==ac[id]&&b<tim[id]) return get_rank(ch[id][0],a,b);
    return size[ch[id][0]]+cnt[id]+get_rank(ch[id][1],a,b);
}

int TTTT;

int main(){
    srand(28910);read(TTTT);
    while(TTTT--){
        build();memset(ch,0,sizeof(ch));
        memset(nowac,0,sizeof(nowac));memset(nowtim,0,sizeof(nowtim));
        read(m);read(n);read(seed);
        for(int i=1;i<=n;i++){
            int x,y;
            x=randNum(seed,las,m),y=randNum(seed,las,m);
            remove(root,nowac[x],nowtim[x]);
            nowac[x]++,nowtim[x]+=y;
//            insert(root,nowac[x],nowtim[y]);
            insert(root,nowac[x],nowtim[x]);//错误笔记：弄错x,y 
//            las=get_rank(root,nowac[x],nowtim[y])-2;
            las=get_rank(root,nowac[x],nowtim[x])-2;//错误笔记：弄错x,y 
            printf("%d\n",las);
        }
    }
    return 0;
}
```

---


# 密码解锁

## 题目背景

在开锁公司劳动

## 题目描述

这天，WD发现了一个很奇怪的密码锁，他记得CX让他解开这个密码锁之前告诉过他一些数字，可惜由于WD菜的真实，早就忘了那些数字是啥，只记得把他们从1到$n$编号后，对于任意的正整数$d(1\le d\le n)$，编号为$d$的倍数的数字之和恰好等于$\mu(d)$（即$d$的莫比乌斯函数值）。

现在，由于要打开这个密码锁，他必须知道第$m$个位置上的数字。由于他什么都不会，当然要请你来帮忙啦……

## 说明/提示

$subtask1(21pts):~n\le 10^6,~T\le 5$

$subtask2(34pts):~n\le 10^7,~T\le 10$

$subtask3(45pts):~n\le 10^{18},~m\le 10^9,~\frac{n}{m}\le 10^9,~T\le 20$

对于所有数据，$m\le n$。

对于样例1，满足要求的数列为4 -1 -1 0 -1.

## 样例 #1

### 输入

```
2
5 1
5 2```

### 输出

```
4
-1```

# 题解

## 作者：ywwywwyww (赞：8)

题目大意：给你 $n',m$，有 $\sum_{i\mid j}a_j=\mu(i)[i\leq n']$，求 $a_m$。$m\leq {10}^9,\frac{n'}{m}\leq {10}^9$。

先莫比乌斯反演一下，令 $n=\frac{n'}{m}$。那么 $a_m=\sum_{i=1}^n\mu(i)\mu(im)=\mu(m)\sum_{i=1}^n[\gcd(i,m)=1]\mu^2(i)$。

考虑无平方因子数是怎么算的，就是枚举每个完全平方数 $i^2$，然后计算 $i^2$ 的倍数，容斥一下。

对于一个完全平方数 $i^2$，如果 $\gcd(i,m)=1$，那么 $\gcd(i^2j,m)=\gcd(j,m)$，就只用求 $\sum_{j=1}^\frac{n}{i^2}[\gcd(m,j)=1]$，再莫比乌斯反演一下就能算了；

如果 $\gcd(i,m)\neq 1$，那么 $\gcd(i^2j,m)\neq 1$，贡献就是 $0$ 了。

复杂度不会算。上限是 $O(\sqrt n\sigma_0(m))$。

---

## 作者：Fading (赞：7)

数论毒瘤题

后面根本不会做了，什么求和套路都用光了。

所以还是自己容斥学的太差了。。。

不过这题简直就是多合一啊

### 讲讲我的心路历程：

做这道题之前请做一做[$P2257$](https://www.luogu.org/problemnew/show/P2257)和[$P1587$](https://www.luogu.org/problemnew/show/P1587)和[$SP4168$](https://www.luogu.org/problemnew/show/SP4168)

~~顺便安利一下我的题解~~

前面都是自己瞎推的，后面思路参考了楼上的大佬。

## 题意：

设一个函数$f(i)$，满足

$$\sum_{i|j}f(j)=\mu(i)$$

求$f(m)$

然后很显然的用莫比乌斯反演定理的第$2$种形式

复习一下~~前几天还说莫比乌斯反演定理没用~~

若

$$g(i)=\sum_{i|j}f(j)$$

则

$$f(i)=\sum_{i|j}g(j)\mu(\frac ji)$$

证明：

$$\sum_{i|j}g(j)\mu(\frac ji)=\sum_{i|j}\sum_{j|k}f(k)\mu(\frac ji)$$

$$=\sum_{i|k}\sum_{\frac ji|\frac ki}f(k)\mu(\frac ji)$$

设$d=\frac ji$

$$=\sum_{i|k}f(k)\sum_{d|\frac ki}\mu(d)\ =\ \sum_{i|k}f(k)[\frac ki==1]$$

$$=\sum_{i|k}f(k)[k==i]\ =f(k)$$

证完了。


------------


所以我们用一用莫比乌斯反演定理就有


$$f(m)=\sum_{m|j}\mu(\frac jm)\mu(j)$$

套路去设$k=\frac jm$

$$=\sum_{k=1}^{\lfloor \frac nm\rfloor}\mu(k)\mu(km)$$

这就又用到了循环之美的套路了，不会的可以看一看[我的小结](https://www.luogu.org/blog/wohaocaia/mu-bi-wu-si-fan-yan-di-ge-zhong-tao-lu-zong-jie)中的第$3$条

$\mu(ij)=\mu(i)\mu(j)[gcd(i,j)==1]$

所以就可以拆掉了

$$f(m)=\sum_{k=1}^{\lfloor \frac nm\rfloor}\mu^2(k)\mu(m)[gcd(m,k)==1]$$

$$f(m)=\mu(m)\sum_{k=1}^{\lfloor \frac nm\rfloor}\mu^2(k)[gcd(m,k)==1]$$

这前面都是自己推的，然后后面我就懵逼了

怎么求这个式子

$$\sum_{k=1}^{\lfloor \frac nm\rfloor}\mu^2(k)[gcd(m,k)==1]?$$

我想到了$SPOJ$那道题！

考虑没有$gcd$的情况

$$\sum_{i=1}^{n}\mu^2(i)=\sum_{i=1}^{\sqrt{n}}\mu(i)\lfloor\frac n{i^2}\rfloor$$

我们要求的就是$1$~$n$中不是完全平方数$(1$除外$)$倍数的数的个数。

然后根据枚举平方因子的倍数个数，然后容斥，且容斥系数为$\mu$，就得到了我们要的式子

不懂的可以看我的题解或者$Sooke$的题解。

其实现在就多了一个条件，这个数和$m$互质，于是我就去推式子了。

容斥容斥，搞不出来，样例没过。。。

然后就参考了$ywwywwyww$巨佬的题解！

我们容斥的不是$\lfloor\frac n{i^2}\rfloor$的个数吗？

它的意义是什么？不就是平方数的倍数个数吗？

只要这个平方数的倍数和$m$互质不就好了吗？？？

设$p=i^2j$就是这个平方数的个数

必须要有$gcd(p,m)=1$。

即$gcd(i^2j,m)=1$。

设$h(i)$表示$i^2$的倍数中与$m$互质的数的个数

所以我们现在要求的不就是

设$\lfloor \frac nm\rfloor=N$

$$\sum_{i=1}^{\sqrt{N}}\mu(i)h(i)\ \ ?$$

然后怎么求$h$?

我的思路和巨佬居然是类似的！惊喜！！！

我们分类讨论$i$和$m$的关系。

如果$gcd(i,m)!=1$，那么无论如何$gcd(p,m)$都不会等于$1$了，因为$p=i^2j$

所以$h(i)$直接等于$0$就可以了。

否则，
$$h(i)=\sum_{j=1}^{\lfloor\frac N{i^2}\rfloor}[gcd(i^2j,m)==1]$$

$$\because gcd(i,m)==1$$

$$h(i)=\sum_{j=1}^{\lfloor\frac N{i^2}\rfloor}[gcd(j,m)==1]$$

这个继续用套路

$$=\sum_{j=1}^{\lfloor\frac N{i^2}\rfloor}\sum_{d|j,d|m}\mu(d)\ =\ \sum_{d|m}\sum_{j=1}^{\lfloor\frac {\lfloor\frac N{i^2}\rfloor}d\rfloor}\mu(d)$$

$$=\ \sum_{d|m}\mu(d)\lfloor\frac {\lfloor\frac N{i^2}\rfloor}d\rfloor$$

枚举$m$的约数就可以快速计算了。

然后这道题就做完了，设$m$有$\alpha $个约数，时间复杂度就是$O(T\alpha\sqrt N)$

对了不要忘记外层还有一个$\mu(m)!!!$

看不懂的还可以私信问我。

具体实现非常恶心？

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,T,p[100001],d[100001],arfa,tot,vis[100001],mu[100001],MU[100001];
inline void init(ll nx){
    mu[1]=1;
    for (register int i=2;i<=nx;i++){
        if (!vis[i]) p[++tot]=i,mu[i]=-1;
        for (register int j=1;j<=tot&&(ll)i*p[j]<=nx;j++){
        	if (1LL*i*p[j]>nx) continue;
            vis[1LL*i*p[j]]=1;
            if((i%p[j])==0){
                mu[1LL*i*p[j]]=0;
                break;
            }
            mu[1LL*i*p[j]]=-mu[i];
        }
    }
}
ll Mu(ll a){//求单个数的莫比乌斯函数
    if (a<=35001) return mu[a];
    ll x=a,cnt=0;
    for (ll j=2;j*j<=a;j++){
        if (x%j==0){
        	ll now=0;
            while (x%j==0) now++,x/=j;
            if (now>1) return 0;
            cnt++;
        }
    }
    if (x!=1) cnt++;
    return (cnt&1)?-1:1;
}
inline ll h(ll I){
    if (__gcd(I,m)!=1) return 0;
    ll ans=0;
    for (int i=1;i<=arfa;i++){
        ans+=MU[i]*(n/m/(I*I)/d[i]);
    }
    return ans;
}
int main(){
    init(35005);
    cin>>T;
    while (T--){
        cin>>n>>m;
        arfa=0;
        for (int i=1;i*i<=m;i++){
            if (m%i==0) d[++arfa]=m/i,d[++arfa]=i;//枚举因数
        }
        if (d[arfa]==d[arfa-1]) d[arfa--]=0;
        for (int i=1;i<=arfa;i++){
            MU[i]=Mu(d[i]);//预处理每一个因数的莫比乌斯函数
        } 
        ll ans=0;
        for (register int i=1;i*i<=n/m;i++){
            ans+=mu[i]*h(i);
        }
        printf("%lld\n",Mu(m)*ans);
    }
}
```

---

## 作者：xgzc (赞：6)

如果需要更好的阅读体验请到我的[$\texttt{blog}$](https://www.cnblogs.com/cj-xxz/p/10812358.html)

记$N =  \dfrac nm$

这道题目就是要求$a_m = \sum_{i=1}^N \mu(i)\mu(im)$

因为$\mu(ij) = \mu(i)\mu(j)[\gcd(i, j) = 1]$

所以$a_m = \mu(m)\sum_{i=1}^N \mu^2(i) [\gcd(i, m) = 1]$

设$\mathbf S(n, m) = \sum_{i=1}^n \mu^2(i)[\gcd(i, m) = 1]$

则有：

$$\begin{aligned}\mathbf S(n, m) &= \sum_{i=1}^n\mu^2(i)\sum_{d|i, d|m}\mu(d) \\&= \sum_{d|m} \mu(d) \sum_{d|i}^n \mu^2(i) \\&= \sum_{d|m} \mu(d) \sum_{i=1}^{n/d} \mu^2(id) \\&= \sum_{d|m} \mu(d) \sum_{i=1}^{n/d} \mu^2(i)\mu^2(d)[\gcd(i, d) = 1] \\&= \sum_{d|m} \mu^3(d) \sum_{i=1}^{n/d} \mu^2(i)[\gcd(i, d) = 1] \\&= \sum_{d|m} \mu(d) \mathbf S\left(\left\lfloor\frac nd \right\rfloor, d\right)\end{aligned}$$

于是就可以递归处理了。

不过数据太水，$\mathrm{O}(\sqrt n)$求$\mu$都可以过，上面那个东西不记忆化都可以过，也是毒瘤了。

---

## 作者：flukehn (赞：2)

令 $F(n,m)=\sum_{i=1}^n\mu(i)\mu(i*m)=\mu(m)\sum_{d|m}\mu(d)\sum_{i=1}^{\frac{n}{d}}\mu^2(id)=\mu(m)\sum_{d|m}F(\frac{n}{d},d)$

答案就是$F(\frac{n}{m},m)$



---

## 作者：command_block (赞：1)

目前最优解,欢迎吊打。

**题意:**

有$(d\leq n)\ \mu(d)=\sum\limits_{d|i}^nf(i)$,注意这并不是狄利克雷卷积。

求$f(m)$。

先倍数反演一下得到:

$f(m)=\sum\limits_{k=1}^∞\mu(k)\mu(mk)[mk\leq n]$

**设** $N=\left\lfloor\dfrac{n}{m}\right\rfloor$

$=\sum\limits_{k=1}^N\mu(k)\mu(mk)$

$=\mu(m)\sum\limits_{k=1}^N\mu^2(k)[m\perp k]$

设$G(n,m)=\sum\limits_{k=1}^n\mu^2(k)[m\perp k]$

反演一下$=\sum\limits_{k=1}^n\mu^2(k)\sum\limits_{d|m,d|k}\mu(d)$

$=\sum\limits_{d|m}\mu(d)\sum\limits_{d|k}^n\mu^2(k)$

$=\sum\limits_{d|m}\mu(d)\sum\limits_{k=1}^{n/d}\mu^2(kd)$

$=\sum\limits_{d|m}\mu^3(d)\sum\limits_{k=1}^{n/d}\mu^2(k)[d\perp k]$

$=\sum\limits_{d|m}\mu(d)G\left(\left\lfloor\dfrac{n}{d}\right\rfloor,d\right)$

边界就是$G(0,m)=0;G(n,1)=\sum\limits_{k=1}^n\mu^2(k)$

设$S(n)=\sum\limits_{k=1}^n\mu^2(k)$,求法见[SP4168 SQFREE](https://www.luogu.org/problem/SP4168),似乎可以做到$O(n^{0.33})$

按照这个递推求$G$就好了,我们来优化一下:

**优化** : 注意到$G(n,m)$中的$n$都是$N$除以某些数的来的,所以取值只有$O(\sqrt{n})$种。

我们把$S(n)$记忆化一下,再预处理一部分,复杂度积分出来大约是$O(N^\frac{5}{9})$。

**优化** : 我们每次只枚举$\mu(d)≠0$的$d$。

那么$10^9$以内只能有$9$个不同质因子。

只能产生$2^9$种不同的$d$。

**优化** : 事先把$m$分解,然后压位存储素因子,枚举因数就变成了枚举子集。

求$\mu$可以数二进制下1的个数。

记$\alpha(m)$为$m$的不同素因子个数($\leq 9$)。

这样子总复杂度大约是$O(T(3^{\alpha(m)}logN+N^\frac{5}{9}))$,干脆可以理解成玄学。

**Code:**

这题数据过水,$S$**不**预处理,**不**记忆化反而更快。

```cpp
// luogu-judger-enable-o2
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<map>
#define ll long long
#define MaxLim 505000
#define MaxS 666
using namespace std;
int tn,p[MaxLim/10],mu[MaxLim],S[MaxLim];
bool e[MaxLim];
ll dmu[MaxS];int dc[MaxS];
void getsth()
{
  mu[1]=1;e[1]=1;
  for (int i=2;i<=500000;i++){
  	if (!e[i]){
  	  p[++tn]=i;
  	  mu[i]=-1;
    }
  	for (int j=1;j<=tn&&i*p[j]<=500000;j++){
  	  e[i*p[j]]=1;
  	  if (i%p[j]==0)break;
  	  mu[i*p[j]]=-mu[i];
  	}
  }for (int i=1;i<=500000;i++){
    S[i]=S[i-1]+(mu[i]!=0);
    mu[i]+=mu[i-1];
  }
  dc[0]=dmu[0]=1;
  for (int i=1;i<(1<<9);i++)
     dmu[i]=(i&1) ? -dmu[i>>1] : dmu[i>>1];
}
map<int,int> sav;
int getS(int n)
{
  if (n<=500000)return S[n];
  if (sav.count(n))return sav[n];
  int sum=0;
  for (int l=1,r;l<=n;l=r+1) {
    if (n/(l*l)==0)break;
    r=sqrt(n/(n/(l*l)));
    sum+=n/(l*l)*(mu[r]-mu[l - 1]);
  }return sav[n]=sum;
}
ll getG(int n,int ds)
{
  if (!n)return 0;
  ll ans=0;
  for (int i=ds;i;i=(i-1)&ds)
    ans+=dmu[i]*getG(n/dc[i],i);
  ans+=getS(n);
  return ans;
}
ll n;int m,tot;
bool preD()
{
  int sav=m,cnt=0; tot=0;
  for (int i=2;i*i<=sav;i++)
    if (sav%i==0){
      for (int s=0;s<(1<<tot);s++)
        dc[s|(1<<tot)]=dc[s]*i;
      tot++;cnt=0;
      while(sav%i==0)
        {sav/=i;cnt++;}
      if (cnt>1)return 0;
    }
  if (sav>1){
    for (int s=0;s<(1<<tot);s++)
      dc[s|(1<<tot)]=dc[s]*sav;
    tot++;
  }return 1;
}
void solve()
{
  scanf("%lld%d",&n,&m);
  n/=m;
  if (!preD())puts("0");
  else printf("%lld\n",
    dmu[(1<<tot)-1]*getG(n,(1<<tot)-1)
  );
}
int main()
{
  getsth();
  int T;scanf("%d",&T);
  while(T--)solve();
  return 0;
}
```


---

## 作者：Polaris_Dane (赞：0)

首先,声明一下,我的方法由于需要使用$map$进行记忆化MLE

但是本着~~口胡~~求知的精神,我决定将自己手推了半天的式子搬上来,也算提供一种新思路,反正题解也只是提供一下思路

当然,如果谁发现我错了一定要提醒我补锅

首先我们考虑我们设$f(x)$为序列中的第$x$项

$F(x)=\mu(x)=\sum\limits_{x|d}f(d)$

反演有$f(x)=\sum\limits_{x|d}\mu(d)F(\dfrac {d} {x})=\sum\limits_{x|d}\mu(d)\mu(\dfrac {d} {x})$

那么我们要求的第$m$项

$f(m)=\sum\limits_{m|d}\mu(d)\mu(\dfrac {d} {m})$

我们改为求和形式

$f(m)=\sum_{i=1}^{\left\lfloor\frac {n} {m}\right\rfloor}\mu(im)\mu(i)$

$=\sum_{i=1}^{\left\lfloor\frac {n} {m}\right\rfloor}\mu(m)\mu(i)^2[i\bot m]$

$=\mu(m)\sum_{i=1}^{\left\lfloor\frac {n} {m}\right\rfloor}\mu(i)^2[i\bot m]$

记$T(x,y)=\sum_{i=1}^x\mu(i)^2[i\bot y]$

那么所求就是$\mu(m)T(\left\lfloor\dfrac {n} {m}\right\rfloor,m)$

首先$m$中是否有平方质因子对是否互质无影响,提前消除

考虑$m$的质因子$p$

我们有$T(\left\lfloor\dfrac {n} {m}\right\rfloor,m)=\sum_{i=1}^{\left\lfloor\frac {n} {m}\right\rfloor}\mu(i)^2[i\bot m]$

$=\sum_{i=1}^{\left\lfloor\frac {n} {m}\right\rfloor}\mu(i)^2[i\bot \dfrac{m} {p}]-\sum_{i=1}^{\left\lfloor\frac {n} {m}\right\rfloor}\mu(i)^2[i\bot \dfrac{m} {p}][p|i]$

$=T(\left\lfloor\dfrac {n} {m}\right\rfloor,\dfrac {m} {p})-\sum_{i=1}^{\left\lfloor\frac {n} {mp}\right\rfloor}\mu(ip)^2[ip\bot \dfrac {m} {p}]$

对平方因子不予考虑

$=T(\left\lfloor\dfrac {n} {m}\right\rfloor,\dfrac {m} {p})-\sum_{i=1}^{\left\lfloor\frac {n} {mp}\right\rfloor}\mu(i)^2\mu(p)^2[i\bot p][i\bot \dfrac {m} {p}]$

$=T(\left\lfloor\dfrac {n} {m}\right\rfloor,\dfrac {m} {p})-\mu(p)^2\sum_{i=1}^{\left\lfloor\frac {n} {mp}\right\rfloor}\mu(i)^2[i\bot m]$

$=T(\left\lfloor\dfrac {n} {m}\right\rfloor,\dfrac {m} {p})-\mu(p)^2T({\left\lfloor\dfrac {n} {mp}\right\rfloor},m)$

$=T(\left\lfloor\dfrac {n} {m}\right\rfloor,\dfrac {m} {p})-T({\left\lfloor\dfrac {n} {mp}\right\rfloor},m)$

边界是$T(...,1)$或者$T(1,...)$

前者相当于没有平方因子数的个数,有式子$\sum_{i=1}^n\mu(i)^2=\sum_{d=1}^{\sqrt{n}}\mu(d)\left\lfloor\dfrac {n} {d^2}\right\rfloor$

可以$O(\sqrt{n})$算

后者不就只有$1$吗?

于是我们顺利的解决了这道题目,除了空间开不下,这个算法复杂度还是可以过的

---

## 作者：VegTea (赞：0)

想要更好的阅读体验请到我的[blog](https://www.cnblogs.com/cnyali-Tea/p/11519578.html)

# Description

给一个长度为 $n$ 的数组 $a[1\dots n]$ ，满足 $\sum_{m|x}a[x] = \mu(m)$，求 $a[m]$。

$n\le 10^{18}, m\le 10^9, \frac{n}{m}\le10^9,n\geq m$

# Solution

由另一种形式的莫比乌斯反演：

$$\begin{aligned}a[m] &= \sum_{m|x}\mu(\frac{x}{m})\mu(x)\\&=\sum_{i=1}^{\frac{n}{m}}\mu(i)\mu(im)\\&=\mu(m)\sum_{i=1}^{\lfloor\frac{n}{m}\rfloor}\mu(i)^2[\gcd(i, m) = 1]\\ \end{aligned}$$

**后面那个 $\sum$ 就是在求 $1\dots \frac{n}{m}$ 中与 $m$ 互质且不能写成完全平方数的倍数的个数。**

类似于 [[中山市选2011]完全平方数](https://endsah.cf/blog/BZOJ2440-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/#more)，可以容斥求：

令 $N = \lfloor\frac{n}{m}\rfloor$，

$$\begin{aligned} a[m] &=\mu(m)\sum_{i=1}^{\frac{n}{m}}\mu(i)^2[\gcd(i, m) = 1]\\&=\mu(m)\sum_{i=1}^{\sqrt{N}}\mu(i)\sum_{j=1}^{\lfloor\frac{N}{i^2}\rfloor}[\gcd(i^2j,m)=1]\\&=\mu(m)\sum_{i=1}^{\sqrt{N}}\mu(i)[\gcd(i,m)=1]\sum_{j=1}^{\lfloor\frac{N}{i^2}\rfloor}[\gcd(j,m)=1]\\&=\mu(m)\sum_{i=1}^{\sqrt{N}}\mu(i)[\gcd(i,m)=1]\sum_{j=1}^{\lfloor\frac{N}{i^2}\rfloor}\sum_{d|\gcd(j,m)}\mu(d)\\&=\mu(m)\sum_{i=1}^{\sqrt{N}}\mu(i)[\gcd(i,m)=1]\sum_{d|m}\mu(d)\lfloor\frac{\lfloor\frac{N}{i^2}\rfloor}{d}\rfloor\end{aligned}$$

然后就可以把 $m$ 的所有约数处理出来，暴力算（复杂度上界为 $O(T\sqrt \frac{n}{m} \sqrt m)$，实际后面的 $\sqrt m$ 跑不满）。

注意$\mu$要筛到$\sqrt N$复杂度才是对的（不然多一个根号）。

### code

```cpp
#include <bits/stdc++.h>

typedef long long LL;
typedef unsigned long long uLL;

#define SZ(x) ((int)x.size())
#define ALL(x) (x).begin(), (x).end()
#define MP(x, y) std::make_pair(x, y)
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#define GO cerr << "GO" << endl;

using namespace std;

inline void proc_status()
{
	ifstream t("/proc/self/status");
	cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;
}

template<class T> inline T read() 
{
	register T x(0);
	register char c;
	register int f(1);
	while (!isdigit(c = getchar())) if (c == '-') f = -1;
	while (x = (x << 1) + (x << 3) + (c xor 48), isdigit(c = getchar()));
	return x * f;
}

template<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }

const int maxN = 1e5;

bool vis[maxN + 1];
vector<int> prime;
int mu[maxN + 1];
LL n, m;

void Init()
{
	mu[1] = 1;
	for (int i = 2; i <= maxN; ++i)
	{
		if (!vis[i])
		{
			prime.push_back(i);
			mu[i] = -1;
		}
		for (int j = 0; j < SZ(prime) and prime[j] * i <= maxN; ++j)
		{
			vis[prime[j] * i] = 1;
			if (i % prime[j] == 0)
				break;
			else 
				mu[i * prime[j]] = -mu[i];
		}
	}
}

int Mu(LL M)
{
	if (M <= maxN) return mu[M];
	//GO;
	int cnt = 0;
	for (LL i = 2; i * i <= M; ++i)
		if (M % i == 0)
		{
			M /= i;
			cnt++;
			if (M % i == 0)
				return 0;
		}
	if (M != 1) cnt++;
	return (cnt & 1) ? -1 : 1;
}

vector<pair<LL, int> > p;

LL calc(LL i)
{
	LL ans(0);
	for (int l = 0; l < SZ(p); ++l)
		ans += (LL)p[l].second * (((n / m) / (i * i)) / p[l].first);
	return ans;
}

void GetP(LL m)
{
	p.clear();
	for (LL d = 1; d * d <= m; ++d)
		if (m % d == 0)
		{
			p.push_back(MP(d, Mu(d)));
			if (m / d == d) continue;
			p.push_back(MP(m / d, Mu(m / d)));
		}
}

void Solve()
{
	int T = read<int>();
	while (T--)
	{
		n = read<LL>(), m = read<LL>();

		GetP(m);

		LL ans(0);
		for (LL i = 1; i * i <= (n / m); ++i)
			if (__gcd((LL)i, m) == 1)
				ans += Mu(i) * calc(i);
		ans *= Mu(m);

		printf("%lld\n", ans);
	}
}

int main() 
{
#ifndef ONLINE_JUDGE
	freopen("xhc.in", "r", stdin);
	freopen("xhc.out", "w", stdout);
#endif
	Init();
	Solve();
	return 0;
}
```

---


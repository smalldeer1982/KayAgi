# 幂

## 题目背景

来到数学院劳动


## 题目描述

$$\text{求}\ \sum_{n=0}^{\infty}f(n)\ r^n\ ,\ f(n)\text{为一个多项式},\ r\text{是一个}(0,1)\text{内的有理数}$$

若答案的最简分数为$\frac{p}{q}$，你只需要输出$p\times q^{-1}\  \mathrm{mod} \ 998244353\ $的值即可。

## 说明/提示

对于$10\%$的数据，$m\le 5$。

对于$40\%$的数据，$m\le 2000$。

对于$100\%$的数据，$m\le 10^5\ ,\ a_i\in [0,998244353)$，保证$\ a_{m}\neq 0$

**捆绑测试**

----

**样例1解释：**

$499122177\equiv \frac{1}{2}\ (\mathrm{mod}\ 998244353)$

$\sum_{n=0}^{\infty}n\ (\frac{1}{2})^n=2$

-----

**样例2解释：**

$748683265\equiv \frac{1}{4}\ (\mathrm{mod}\ 998244353)$

$\sum_{n=0}^{\infty}n^2\ (\frac{1}{4})^n=\frac{20}{27}$

-----

**样例3解释：**

$713031681\equiv \frac{2}{7}\ (\mathrm{mod}\ 998244353)$

$\sum_{n=0}^{\infty}(2n^3+23n^2+5n+7)\ (\frac{2}{7})^n=\frac{25417}{625}$



## 样例 #1

### 输入

```
1 499122177
0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
2 748683265
0 0 1```

### 输出

```
628524223```

## 样例 #3

### 输入

```
3 713031681
7 5 23 2```

### 输出

```
257147786```

# 题解

## 作者：da32s1da (赞：14)

## 算法1：

设$\{a_n\}$是等差数列，首项为$a_1$，公差为$d$。

设$\{b_n\}$是等比数列，首项为$b_1$，公比为$q(\,\left|\,q\,\right|\lt1) $。

设$S(x)=\sum_{i=1}^{\infty}a_ib_i$，则

$S(x)=a_1b_1+(a_1+d)b_1q+(a_1+2d)b_1q^2+\cdots$

$\ \ \ \ \ \ \ \,\,=b_1\big[a_1(1+q+q^2+\cdots)+dq(1+2q+3q^2+\cdots)\big]$

$\ \ \ \ \ \ \ \,\,=b_1\big[a_1\frac{1}{1-q}+dq(\frac{1}{1-q})^2\big]$

$\ \ \ \ \ \ \ \,\,=\frac{b_1}{1-q}\big(a_1+d\cdot \frac{q}{1-q}\big)$

若$\{a_n\}$为$m$阶等差数列。

设$d_0,d_1,d_2,\dots d_m$为数列$\{a_n\}$的$0,1,2,\dots m$阶差数列的首项。

则$S(x)=\sum\limits_{i=1}^{\infty}a_ib_i=\frac{b_1}{1-q}\sum\limits_{i=0}^m d_i(\frac{q}{1-q})^i$

证明：$m=1$时，显然$d_0=a_1$，$d_1=d$，原式成立。

现在假设$m=r$时成立，下面证明$m=r+1$时也成立。

设$\{\Delta_n\}=\{a_{n+1}-a_n\}$，那么$\{\Delta_n\}$是$r$阶等差数列

则$\sum\limits_{i=1}^{\infty}\Delta_ib_i=\frac{b_1}{1-q}\sum\limits_{k=0}^r d_{k+1}(\frac{q}{1-q})^k$

设$\sum\limits_{i=1}^{\infty}\Delta_ib_i$的前$n$项和为$D_n$，$\sum\limits_{i=1}^{\infty}a_ib_i$的前$n$项和为$S_n$。

则$\lim\limits_{n\to \infty}D_n=\frac{b_1}{1-q}\sum\limits_{k=0}^r d_{k+1}(\frac{q}{1-q})^k$

考虑$S_n=a_1b_1+a_2b_2+a_3b_3+\cdots+a_nb_n$

$qS_n=a_1b_2+a_2b_3+a_3b_4+\cdots+a_nb_{n+1}$

$\big(1-q\big)S_n=a_1b_1-a_nb_{n+1}+(a_2-a_1)b_2+(a_3-a_2)b_3+\cdots+(a_n-a_{n-1})b_n$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,=a_1b_1-a_nb_{n+1}+\Delta_1b_2+\Delta_2b_3+\cdots+\Delta_{n-1}b_n$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,=a_1b_1-a_nb_{n+1}+q\big(\Delta_1b_1+\Delta_2b_2+\cdots+\Delta_{n-1}b_{n-1}\big)$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \,\,=a_1b_1-a_nb_{n+1}+qD_{n-1}$

$S(x)=\lim\limits_{n\to \infty}S_n=\frac{1}{1-q}\big(a_1b_1-\lim_{n\to \infty}a_nb_{n+1}+q\lim_{n\to \infty}D_{n-1}\big)$

分开考虑，由于$\{a_n\}$是$r+1$阶的等差数列，那么必然可以表达成$r+1$次多项式。

那么$\lim\limits_{n\to \infty}a_nb_{n+1}=\lim\limits_{n\to \infty}\sum\limits_{k=0}^{r+1}c_kn^k\cdot b_1q^n=b_1\sum\limits_{k=0}^{r+1}c_k\lim\limits_{n\to \infty}n^kq^n$

单独考虑每一个$k$，那么有

$\lim\limits_{n\to \infty}\frac{|(n+1)^kq^{n+1}|}{|n^kq^n|}=\lim\limits_{n\to \infty}\big|q(1+\frac{1}{n})^k\big|=\big|q\big|\lt 1$

那么$\lim\limits_{n\to \infty}n^kq^n=0\ \ (k=0,1,2,\dots,r+1)$

则$\lim\limits_{n\to \infty}a_nb_{n+1}=0$

又显然$\lim\limits_{n\to \infty}D_{n-1}=\lim\limits_{n\to \infty}D_{n}=\frac{b_1}{1-q}\sum\limits_{k=0}^r d_{k+1}(\frac{q}{1-q})^k$，所以

$S(x)=\frac{1}{1-q}\big(a_1b_1+q\frac{b_1}{1-q}\sum\limits_{k=0}^r d_{k+1}(\frac{q}{1-q})^k\big)$

$\ \ \ \ \ \ \ \,\,=\frac{b_1}{1-q}\big(a_1+\frac{q}{1-q}\sum\limits_{k=0}^r d_{k+1}(\frac{q}{1-q})^k\big)$

$\ \ \ \ \ \ \ \,\,=\frac{b_1}{1-q}\big(a_1+\sum\limits_{k=1}^{r+1} d_k(\frac{q}{1-q})^k\big)$

$\ \ \ \ \ \ \ \,\,=\frac{b_1}{1-q}\sum\limits_{k=0}^{r+1} d_k(\frac{q}{1-q})^k$

故$m=r+1$时成立。

归纳得$S(x)=\frac{b_1}{1-q}\sum\limits_{k=0}^m d_k(\frac{q}{1-q})^k$

----

下面考虑怎么计算$d_k$。

$d_k=\sum\limits_{i=0}^k(-1)^i\binom{k}{i}a_{k+1-i}$

首先$d_0=a_0$，符合上面式子。

假设$k=r$时上式成立，下面证明$k=r+1$时成立。

令$p_r$表示$a_2,a_3,\dots a_{r+2}$作差分时$r$阶差数列的首项，那么$p_r=\sum\limits_{i=0}^r(-1)^i\binom{r}{i}a_{r+2-i}$。

则$d_{r+1}=p_r-d_r=\sum\limits_{i=0}^r(-1)^i\binom{r}{i}a_{r+2-i}-\sum\limits_{i=0}^r(-1)^i\binom{r}{i}a_{r+1-i}$

$=\sum\limits_{i=1}^r(-1)^i\binom{r}{i}a_{r+2-i}-\sum\limits_{i=0}^{r-1}(-1)^i\binom{r}{i}a_{r+1-i}+a_{r+2}-(-1)^ra_1$

$=\sum\limits_{i=1}^r(-1)^i\binom{r}{i}a_{r+2-i}+\sum\limits_{i=1}^r(-1)^i\binom{r}{i-1}a_{r+2-i}+a_{r+2}-(-1)^ra_1$

$=\sum\limits_{i=1}^r(-1)^i\big(\binom{r}{i}+\binom{r}{i-1}\big)a_{r+2-i}+a_{r+2}-(-1)^ra_1$

$=\sum\limits_{i=1}^r(-1)^i\binom{r+1}{i}a_{r+2-i}+a_{r+2}+(-1)^{r+1}a_1$

$=\sum\limits_{i=0}^{r+1}(-1)^i\binom{r+1}{i}a_{r+2-i}$

故$k=r+1$时成立。

归纳得$d_k=\sum\limits_{i=0}^k(-1)^i\binom{k}{i}a_{k+1-i}$

----

将$d_k$的式子拆开。

$d_k=\sum\limits_{i=0}^k(-1)^i\binom{k}{i}a_{k+1-i}=k!\sum\limits_{i=0}^k\frac{(-1)^i}{i!}\cdot\frac{a_{k+1-i}}{(k-i)!}$

多项式多点求值$+\mathrm{NTT}$即可。

带入答案式子，$Ans=S(x)+a_0b_0=\frac{b_1}{1-q}\sum\limits_{k=0}^m d_k(\frac{q}{1-q})^k+a_0$

---

## 算法2：

令$f_k=\sum\limits_{n=0}^{\infty}n^kr^n$

那么 $r\cdot f_k=\sum\limits_{n=0}^{\infty}n^kr^{n+1}=\sum\limits_{n=1}^{\infty}(n-1)^kr^n$

$(1-r)f_k=\sum\limits_{n=1}^{\infty}\big(n^k-(n-1)^k\big)r^n$

$~~~~~~~~~~~~~\,=r\sum\limits_{n=0}^{\infty}\big((n+1)^k-n^k\big)r^n$

$~~~~~~~~~~~~~\,=r\sum\limits_{n=0}^{\infty}\sum\limits_{i=0}^{k-1}\binom{k}{i}n^ir^n$

$~~~~~~~~~~~~~\,=r\sum\limits_{i=0}^{k-1}\binom{k}{i}\sum\limits_{n=0}^{\infty}n^ir^n$

$~~~~~~~~~~~~~\,=r\sum\limits_{i=0}^{k-1}\binom{k}{i}f_i$

故有$f_k=\frac{r}{1-r}\sum\limits_{i=0}^{k-1}\binom{k}{i}f_i$

化一下式子，$\frac{f_k}{k!}=\sum\limits_{i=0}^{k-1}\frac{f_i}{i!}\big(\frac{r}{1-r}\cdot \frac{1}{(k-i)!}\big)$，很明显**分治fft**可以解决这个问题。

最后很明显$Ans=\sum\limits_{i=0}^ma_if_i$

-----

##  代码：

### 算法1：

```cpp
#pragma GCC optimize ("Ofast")
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=998244353;
const int N=1048580;
inline void rad(int &_){
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9');_=ch-48;
    while(ch=getchar(),ch<='9'&&ch>='0')_=_*10+ch-48;
}
inline void swap(int &u,int &v){int o=u;u=v;v=o;}
inline int __(int u){return u<mod?u:u-mod;}
inline int ___(int u){return u<0?u+mod:u;}
int ksm(int u,int v){
    int res=1;
    for(;v;v>>=1,u=1ll*u*u%mod)
    if(v&1)res=1ll*res*u%mod;
    return res;
}
int f[N],g[N],rnk[N],c[N],d[N],e[N];
int C[N],D[N],cr[N],dr[N],siz[N];
int h[N],fac[N],inv[N],cnt,n,m,r,s,Ans;
vector<int>vp[N];
void Ntt(int *t,int opt,int len){
    int g=3,g_=ksm(g,mod-2);
    for(int i=0;i<len;i++)if(i<rnk[i])swap(t[i],t[rnk[i]]);
    for(int i=1;i<len;i<<=1){
        int wn=ksm(~opt?g:g_,(mod-1)/(i<<1));
        for(int j=0,J=i<<1;j<len;j+=J){
            int w=1;
            for(int k=j;k<i+j;k++,w=1ll*w*wn%mod){
                int r=1ll*w*t[i+k]%mod;
                t[i+k]=___(t[k]-r);
                t[k]=__(t[k]+r);
            }
        }
    }
    if(~opt)return;
    int ny=ksm(len,mod-2);
    for(int i=0;i<len;i++)t[i]=1ll*t[i]*ny%mod;
}
void Inv(int *a,int Len,int *b){
    if(Len==1){b[0]=ksm(a[0],mod-2);return;}
    Inv(a,(Len+1)>>1,b);
    int len=1,_2=-1;
    while(len<Len+Len)len<<=1,_2++;
    for(int i=0;i<len;i++)rnk[i]=(rnk[i>>1]>>1)|((i&1)<<_2);
    memcpy(e,a,Len<<2);
    memset(e+Len,0,(len-Len)<<2);
    Ntt(e,1,len);Ntt(b,1,len);
    for(int i=0;i<len;i++)b[i]=1ll*(2-1ll*e[i]*b[i]%mod+mod)*b[i]%mod;
    Ntt(b,-1,len);
    memset(b+Len,0,(len-Len)<<2);
}
void ntt(int *a,int *b,int len1,int len2,int *t){
    int len=1,_2=-1;
    while(len<len1+len2)len<<=1,_2++;
    for(int i=0;i<len;i++)rnk[i]=(rnk[i>>1]>>1)|((i&1)<<_2);
    memcpy(C,a,len1<<2);
    memset(C+len1,0,(len-len1)<<2);
    memcpy(D,b,len2<<2);
    memset(D+len2,0,(len-len2)<<2);	
    Ntt(C,1,len);Ntt(D,1,len);
    for(int i=0;i<len;i++)t[i]=1ll*C[i]*D[i]%mod;
    Ntt(t,-1,len);
    if(&b[0]==&dr[0])memset(dr,0,len<<2);
}
void Mod(const int *a,const vector<int>&b,int *t,int lena,int lenb){
    for(int i=0;i<=lena;i++)c[i]=a[lena-i];
    for(int i=0;i<=lenb;i++)d[i]=b[lenb-i];	
    int len=1;while(len<=lena+lenb)len<<=1;
    memset(c+lena-lenb+1,0,(len-lena+lenb-1)<<2);
    memset(d+lena-lenb+1,0,(len-lena+lenb-1)<<2);
    Inv(d,lena-lenb+1,dr);
    ntt(c,dr,lena-lenb+1,lena-lenb+1,cr);
    reverse(cr,cr+(lena-lenb+1));
    for(int i=0;i<=lenb;i++)d[i]=b[i];
    memset(d+lenb+1,0,(len-lenb-1)<<2);
    ntt(d,cr,lenb+1,lena-lenb+1,c);
    for(int i=0;i<lenb;i++)t[i]=___(a[i]-c[i]);
}
void Solve(int now,int ls,int rs,int *a){
    if(ls==rs){h[++cnt]=a[0];return;}
    int noww=now<<1,nrs=ls+rs>>1,b[siz[now]+1];
    Mod(a,vp[noww],b,siz[now]-1,siz[noww]);
    Solve(noww,ls,nrs,b);
    Mod(a,vp[noww|1],b,siz[now]-1,siz[noww|1]);
    Solve(noww|1,nrs+1,rs,b);
}
void Solve(int now,int ls,int rs){
    siz[now]=rs-ls+1;
    if(ls==rs){
        vp[now].resize(2);
        vp[now][0]=mod-g[ls];
        vp[now][1]=1;
        return;
    }
    int noww=now<<1,nrs=ls+rs>>1;
    Solve(noww,ls,nrs);Solve(noww|1,nrs+1,rs);
    int len=1,_2=-1;
    while(len<=siz[now])len<<=1,_2++;
    for(int i=0;i<len;i++)rnk[i]=(rnk[i>>1]>>1)|((i&1)<<_2);
    for(int i=0;i<=siz[noww];i++)c[i]=vp[noww][i];
    for(int i=0;i<=siz[noww|1];i++)d[i]=vp[noww|1][i];
    memset(c+siz[noww]+1,0,(len-siz[noww]-1)<<2);
    memset(d+siz[noww|1]+1,0,(len-siz[noww|1]-1)<<2);
    Ntt(c,1,len);Ntt(d,1,len);
    for(int i=0;i<len;i++)c[i]=1ll*c[i]*d[i]%mod;
    Ntt(c,-1,len);
    vp[now].resize(siz[now]+1);
    for(int i=0;i<=siz[now];i++)vp[now][i]=c[i];
}
int main(){
    rad(n);m=n+1;rad(r);
    for(int i=0;i<=n;i++)rad(f[i]);
    for(int i=1;i<=m;i++)g[i]=i;
    s=f[0];
    Solve(1,1,m);
    Solve(1,1,m,f);
    fac[0]=fac[1]=inv[0]=inv[1]=1;
    for(int i=2;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;
    inv[n]=ksm(fac[n],mod-2);
    for(int i=n-1;i>=2;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    for(int i=0;i<=n;i++)f[i]=___((i&1?-1:1)*inv[i]);
    for(int i=0;i<=n;i++)g[i]=1ll*h[i+1]*inv[i]%mod;
    ntt(f,g,n+1,n+1,h);
    r=1ll*r*ksm(1-r+mod,mod-2)%mod;
    for(int i=0,j=1;i<=n;i++,j=1ll*j*r%mod)
    h[i]=1ll*h[i]*fac[i]%mod*j%mod;
    for(int i=0;i<=n;i++)Ans=__(Ans+h[i]);
    Ans=__(1ll*Ans*r%mod+s);
    printf("%d\n",Ans);
}
```

### 算法2：

```cpp
#include<cstdio>
const int N=262150;
const int mod=998244353;
int n,Ans,r,r_,A[N],fac[N],inv[N];
int f[N],g[N],c[N],rnk[N];
int ksm(int u,int v){
    int res=1;
    for(;v;v>>=1,u=1ll*u*u%mod)
    if(v&1)res=1ll*res*u%mod;
    return res;
}
inline void swap(int &u,int &v){int o=u;u=v;v=o;}
inline int _(int u){return u<mod?u:u-mod;}
inline int __(int u){return u<0?u+mod:u;}
void ntt(int *t,int opt,int len){
    int g=3,g_=ksm(g,mod-2);
    for(int i=0;i<len;i++)if(i<rnk[i])swap(t[i],t[rnk[i]]);
    for(int i=1;i<len;i<<=1){
        int wn=ksm(~opt?g:g_,(mod-1)/(i<<1));
        for(int j=0,J=i<<1;j<len;j+=J){
            int w=1;
            for(int k=j;k<i+j;k++,w=1ll*w*wn%mod){
                int r=1ll*w*t[i+k]%mod;
                t[i+k]=__(t[k]-r);
                t[k]=_(t[k]+r);
            }
        }
    }
    if(~opt)return;
    int ny=ksm(len,mod-2);
    for(int i=0;i<len;i++)t[i]=1ll*t[i]*ny%mod;
}
void Inv(int Len,int *a,int *b){
    if(Len==1){b[0]=ksm(a[0],mod-2);return;}
    Inv((Len+1)>>1,a,b);
    int len=1,_2=-1;
    while(len<Len+Len)len<<=1,_2++;
    for(int i=0;i<len;i++)rnk[i]=(rnk[i>>1]>>1)|((i&1)<<_2);
    for(int i=0;i<Len;i++)c[i]=a[i];
    for(int i=Len;i<len;i++)c[i]=0;
    ntt(c,1,len);ntt(b,1,len);
    for(int i=0;i<len;i++)
    b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)*b[i]%mod;
    ntt(b,-1,len);
    for(int i=Len;i<len;i++)b[i]=0;
}
int main(){
    scanf("%d%d",&n,&r);r_=1ll*r*ksm(1-r+mod,mod-2)%mod;
    for(int i=0;i<=n;i++)scanf("%d",&A[i]);
    fac[0]=inv[0]=1;
    for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;
    inv[n]=ksm(fac[n],mod-2)%mod;
    for(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    for(int i=1;i<=n;i++)g[i]=mod-1ll*inv[i]*r_%mod;
    g[0]=1;
    Inv(n+1,g,f);
    for(int i=0;i<=n;i++)f[i]=1ll*f[i]*fac[i]%mod*ksm(1-r+mod,mod-2)%mod;
    for(int i=0;i<=n;i++)Ans=_(Ans+1ll*f[i]*A[i]%mod);
    printf("%d\n",Ans);
}
```

---

## 作者：ywwywwyww (赞：10)

令 $f_k=\sum_{i=0}^\infty i^kq^i$，那么

$qf_k=\sum_{i=0}^\infty i^kq^{i+1}$

$(1-q)f_k=q\sum_{i=0}^\infty((i+1)^k-i^k)q^i$

$=q \sum_{i=0}^{\infty} \sum_{j=0}^{k-1}\binom{k}{j} i^j q^i$

$=q\sum_{j=0}^{k-1}\binom{k}{j}\sum_{i=0}^\infty i^jq^i$

$=q\sum_{j=0}^{k-1}\binom{k}{j}f_j$

$f_k=\frac{q}{1-q}\sum_{i=0}^{k-1}\binom{k}{i}f_i$

$\frac{f_k}{k!}=\frac{q}{1-q}\sum_{i=0}^{k-1}\frac{f_i}{i!}\frac{1}{(k-i)!}$

$\frac{1}{1-q}F(x)=\frac{q}{1-q}F(x)e^x+\frac{1}{1-q}$

$F(x)=qF(x)e^x+1$

$F(x)=\frac{1}{1-qe^x}$

直接多项式求逆即可，时间复杂度 $O(m\log m)$

---

## 作者：Brodal_Queue (赞：9)

为啥出题人的题解搞的那么迷惑，，   
萌新写题解，求资瓷qwq
***
考虑一个弱化问题：
$$f_k=\sum_{i=0}^\infty i^kr^i$$
那么只需要对于 $k\in[0,m]$ 求出 $f_k$，就能线性得到答案了。
$$rf_k=\sum_{i=1}^\infty (i-1)^kr^i$$
$$(1-r)f_k=\sum_{i=1}^\infty(i^k-(i-1)^k)r^i$$
把 $i$ 改为从 $0$ 开始，同时把 $r$ 提出来：
$$(1-r)f_k=r\sum_{i=0}^\infty((i+1)^k-i^k)r^i$$
$$(1-r)f_k=r\sum_{i=0}^\infty\sum_{j=0}^{k-1}\binom{k}{j}i^jr^j$$
交换一下求和顺序：
$$(1-r)f_k=r\sum_{j=0}^{k-1}\binom{k}{j}\sum_{i=0}^\infty i^jr^j$$
然后你发现最右边的那个就是 $f_j$，，
$$\frac{1-r}{r}f_k=\sum_{j=0}^{k-1}\binom kj f_j$$
这个形式非常像指数型生成函数的卷积，于是我们给两边加一项
$$\frac 1rf_k=\sum_{j=0}^k\binom kj f_j$$
现在设 $\{ f_k \}_{k=0}^\infty $ 的指数型生成函数为 $F(x)$，就可以得到一个函数方程。  
但别忘了 $k=0$ 时上式都不成立，右边需要多加一个 $r^{-1}$。
$$\frac{F(x)}{r}=\text e^x F(x)+\frac 1r$$
$$F(x)=r\text e^xF(x)+1$$
$$F(x)=\frac{1}{1-r\text e^x}$$
多项式求逆即可，时间复杂度 $\Theta(m\log m)$。  
别的神仙都不屑于给代码，这里给一个吧：
```cpp
#pragma GCC optimize (2)
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define N 262147
#define reg register
#define p 998244353
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int rev[N],rt[N],fac[N],ifac[N];
int siz;

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=0;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    w = power(3,(p-1)>>siz);
    rt[lim>>1] = 1;
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
}

inline void NTT(int *f,int type,int lim){
    if(type==-1) reverse(f+1,f+lim);
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]-x+p;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
    if(type==1) return;
    x = p-(p-1)/lim;
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline void inverse(const int *f,int n,int *g){
    static int h[N],s[30];
    int lim = 1,top = 0;
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = power(f[0],p-2);
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        NTT(g,-1,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
}

int n,r,ans;
int a[N],F[N],G[N];

int main(){
    read(n),read(r);
    init(n<<1);
    for(reg int i=0;i<=n;++i) read(a[i]);
    fac[0] = fac[1] = ifac[0] = ifac[1] = 1;
    for(reg int i=2;i<=n;++i) ifac[i] = fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = power(fac[n],p-2);
    for(reg int i=n-1;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
    for(reg int i=1;i<=n;++i) F[i] = (ll)(p-ifac[i])*r%p;
    F[0] = p+1-r;
    inverse(F,n,G);
    for(reg int i=0;i<=n;++i) ans = (ans+(ll)G[i]*fac[i]%p*a[i])%p;
    printf("%d",ans);
	return 0;	
}
```
顺手抢了个最优解（前面两个都是 500 分

---

## 作者：xgzc (赞：5)

首先考虑对于一个单项式怎么做，多项式就是单项式的答案的和。

就求一下$\mathbf f(n) = n^k$吧。（下面设$t = \dfrac 1r$）

设$\mathbf S_k = \sum_{n=0}^\infty n^k \left(\dfrac 1t\right)^n$

$t\mathbf S_k = \sum_{n=1}^\infty n^k \left(\dfrac 1t\right)^{n-1} = \sum_{n=0}^\infty (n+1)^k \left(\dfrac 1t\right)^n$

所以$(t - 1) \mathbf S_k = \sum_{n=0}^\infty [(n+1)^k - n^k]\left(\dfrac 1t\right)^n$

将$(n+1)^k$用二项式定理展开可以发现：

$\mathbf S_k = \dfrac 1{t-1} \sum_{i=0}^{k-1} \binom ki \mathbf S(i), \mathbf S_0 = \dfrac t{t-1}$

于是$\mathbf S_{k} = \dfrac {k!}{t-1}\sum_{i=0}^{k-1} \dfrac 1{(k - i)!} \dfrac {\mathbf S(i)}{i!}$

显然卷积的形式，分治$\mathrm{FFT}$即可。

代码见我的[$\texttt{blog}$](https://www.cnblogs.com/cj-xxz/p/10812424.html)

---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

提供一下全洛谷时间复杂度最劣解

首先，解决一下 $f(n)=n^k$ 的时候的问题。

考虑 $n^k$ 的第二类斯特林数展开：

$$n^k=\sum_{i=0}^k\begin{Bmatrix}k\\i\end{Bmatrix}n^{\underline i}=\sum_{i=0}^k\begin{Bmatrix}k\\i\end{Bmatrix}\frac{n!}{(n-i)!}$$

$$\sum_{n=0}^\infty n^kz^n=\sum_{n=0}^\infty \sum_{i=0}^k\begin{Bmatrix}k\\i\end{Bmatrix}\frac{n!}{(n-i)!}z^n=\sum_{i=0}^k\begin{Bmatrix}k\\i\end{Bmatrix}\sum_{n=0}^\infty \frac{n!}{(n-i)!}z^n$$
$$=\sum_{i=0}^k\begin{Bmatrix}k\\i\end{Bmatrix}i!\sum_{n=0}^\infty\binom niz^n=\sum_{i=0}^k\begin{Bmatrix}k\\i\end{Bmatrix}\frac{i!z^i}{(1-z)^{i+1}}$$

直接插入即可。

显然从 $n^k$ 变成一个多项式之后可以考虑贡献，唯一区别是 $\begin{Bmatrix}k\\i\end{Bmatrix}$ 变成 $f(i)=\sum a_k\begin{Bmatrix}k\\i\end{Bmatrix}$ 了，其中 $a_k$ 是多项式系数。

$$\sum_{n=0}^\infty p(n)z^n=\sum_{i=0}^kf(i)\frac{i!z^i}{(1-z)^{i+1}}$$

考虑 $f(i)$ 如何处理。

$$f(i)=\sum_{k=0}^m a_k\begin{Bmatrix}k\\i\end{Bmatrix}$$

展开第二类斯特林：

$$f(i)=\sum_{k=0}^m a_k\sum_{t=0}^i\frac{t^k}{t!}\frac{(-1)^{i-t}}{(i-t)!}=\sum_{t=0}^i\frac{\sum_{k=0}^m a_kt^k}{t!}\frac{(-1)^{i-t}}{(i-t)!}$$

注意到里面的和就是输入多项式 p!

$$f(i)=\sum_{t=0}^i\frac{p(t)}{t!}\frac{(-1)^{i-t}}{(i-t)!}$$

多点求值处理出来 $p(0),p(1),\dots,p(m)$ 这个就变成一个标准卷积了。

代码：

```cpp
#pragma GCC optimize("-Ofast","-funroll-all-loops","-ffast-math")
#pragma GCC optimize("-fno-math-errno")
#pragma GCC optimize("-funsafe-math-optimizations")
#pragma GCC optimize("-freciprocal-math")
#pragma GCC optimize("-fno-trapping-math")
#pragma GCC optimize("-ffinite-math-only")
#pragma GCC optimize("-fno-stack-protector")
#pragma GCC target ("avx2","sse4.2","fma")
#include <immintrin.h>
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// https://judge.yosupo.jp/submission/5253

struct IO {
  static constexpr size_t buf_size = 1 << 18;
  char buf_in[buf_size], buf_out[buf_size];
  size_t pt_in = 0, pt_out = 0, tail_in = 0;
  char strs[10000 * 4];
  inline size_t num_digits(long long x) {
    if (x >= (long long)1e9) {
      if (x >= (long long)1e18) return 19;
      if (x >= (long long)1e17) return 18;
      if (x >= (long long)1e16) return 17;
      if (x >= (long long)1e15) return 16;
      if (x >= (long long)1e14) return 15;
      if (x >= (long long)1e13) return 14;
      if (x >= (long long)1e12) return 13;
      if (x >= (long long)1e11) return 12;
      if (x >= (long long)1e10) return 11;
      return 10;
    } else {
      if (x >= (long long)1e8) return 9;
      if (x >= (long long)1e7) return 8;
      if (x >= (long long)1e6) return 7;
      if (x >= (long long)1e5) return 6;
      if (x >= (long long)1e4) return 5;
      if (x >= (long long)1e3) return 4;
      if (x >= (long long)1e2) return 3;
      if (x >= (long long)1e1) return 2;
      return 1;
    }
  }
  IO() {
    load();
    for (int i = 0; i < 10000; ++i) {
      int j = i;
      for (int t = 3; t >= 0; --t) {
        strs[i * 4 + t] = j % 10 + '0';
        j /= 10;
      }
    }
  }
  ~IO() { flush(); }
  inline void load() {
    memcpy(buf_in, buf_in + pt_in, tail_in - pt_in);
    size_t width = tail_in - pt_in;
    tail_in = width + fread(buf_in + width, 1, buf_size - width, stdin);
    pt_in = 0;
  }
  inline void flush() {
    fwrite(buf_out, 1, pt_out, stdout);
    pt_out = 0;
  }
  inline void read(char& c) { c = buf_in[pt_in++]; }
  template <class T>
  inline void read(T& x) {
    if (pt_in + 32 > tail_in) load();
    char c;
    do {
      read(c);
    } while (c < '0');
    bool minus = 0;
    if (c == '-') {
      minus = 1;
      read(c);
    }
    x = 0;
    while (c >= '0') {
      x = x * 10 + (c & 15);
      read(c);
    }
    if (minus) x = -x;
  }
  inline void write(char c) { buf_out[pt_out++] = c; }
  template <class T>
  inline void write(T x) {
    if (pt_out > buf_size - 32) flush();
    if (x < 0) {
      write('-');
      x = -x;
    }
    size_t digits = num_digits(x);
    int i;
    for (i = pt_out + digits - 4; i > (int)pt_out; i -= 4) {
      memcpy(buf_out + i, strs + (x % 10000) * 4, 4);
      x /= 10000;
    }
    memcpy(buf_out + pt_out, strs + x * 4 + (pt_out - i), 4 + i - pt_out);
    pt_out += digits;
  }
  inline void write(const char* s) {
    if (pt_out > buf_size - 32) flush();
    for (int i = 0; s[i] != 0; ++i) write(s[i]);
  }
  template <class T>
  inline void writeln(T x) {
    write(x);
    write('\n');
  }
} io;

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, (int)(a))
#define rep1(i, a) iter(i, 1, (int)(a)+1)
#define fi first
#define se second
#define pb push_back
#define intsize (sizeof(int))
 
#define ll long long
#define pii pair<int, int>
//#define int ll
const int MOD = 998244353;

typedef unsigned us;
typedef unsigned long long ull;

static char buf[450 << 20];
void* operator new(size_t s) {
	static size_t i = sizeof buf;
	assert(s < i);
	return (void*)&buf[i -= s];
}
void operator delete(void*) {}

template<class T> struct ptr {
	unsigned ind;
	ptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {
		assert(ind < sizeof buf);
	}
	T& operator*() const { return *(T*)(buf + ind); }
	T* get() const { return &**this; }
	T& operator[](int a) const { return (&**this)[a]; }
	explicit operator bool() const { return ind; }
};

namespace poly {
	const int MOD = 998244353;
	const int IMAG = 86583718;
	const int NTTG = 3;
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
// https://www.luogu.com.cn/record/32153077
// zzq orz
#define SZ 524320
ll qp(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%MOD;
		a=a*a%MOD; b>>=1;
	}
	return ans;
}
int getK(int n)
{int s=1; while(s<n) s<<=1; return s;}
us pool[SZ*4] __attribute__ ((aligned(64))),*ptr=pool;
us *p0[SZ],*p1[SZ],*q0[SZ],*q1[SZ];
__attribute__((always_inline)) void bit_flip(us*p,int t)
{
	for(int i=0,j=0;i<t;++i)
	{
		if(i>j) swap(p[i],p[j]);
		for(int l=t>>1;(j^=l)<l;l>>=1);
	}
}
void prep(int n)
{
	static int t=1;
	for(;t<n;t<<=1)
	{
		int g=qp(3,(MOD-1)/(t*2));
		us*p,*q;
		p=p0[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q0[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
		g=qp(g,MOD-2);
		p=p1[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q1[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
	}
}
typedef unsigned long long ull;
__attribute__((always_inline)) us my_mul(us a,us b,us c)
{
	return b*(ull)a-((ull(a)*c)>>32)*ull(998244353);
}
__attribute__((always_inline)) __m128i my_mullo_epu32(const __m128i&a, const __m128i& b)
{
	return _mm_mullo_epi32(a,b);
	/*
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (-,a2*b2,-,a0*b0)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (-,a3*b3,-,a1*b1)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (-,-,a1*b1,a0*b0) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (-,-,a3*b3,a2*b2) 
	__m128i prod   = _mm_unpacklo_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
	*/
}
__attribute__((always_inline)) __m128i my_mulhi_epu32(const __m128i&a, const __m128i& b)
{
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (a2*b2,-,a0*b0,-)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (a3*b3,-,a1*b1,-)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (a1*b1,a0*b0,-,-) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (a3*b3,a2*b2,-,-) 
	__m128i prod   = _mm_unpackhi_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
}
void ntt(us* __restrict__ x,int n)
{
	int t=n;
	for(int m=1;m<n;m<<=1)
	{
		t>>=1;
		us* __restrict__ p=p0[m];
		us* __restrict__ q=q0[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					u=_mm_sub_epi32(u,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u,mm),
					_mm_cmpgt_epi32(m0,u)),mm));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					v=_mm_sub_epi32(my_mullo_epu32(v,p4),
					my_mullo_epu32(my_mulhi_epu32(v,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u,v));
					_mm_storeu_si128((__m128i*)(xb+j),_mm_add_epi32(_mm_sub_epi32(u,v),mm));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					u0=_mm_sub_epi32(u0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u0,mm),
					_mm_cmpgt_epi32(m0,u0)),mm));
					u1=_mm_sub_epi32(u1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u1,mm),
					_mm_cmpgt_epi32(m0,u1)),mm));
					v0=_mm_sub_epi32(my_mullo_epu32(v0,p4),
					my_mullo_epu32(my_mulhi_epu32(v0,q4),m1));
					v1=_mm_sub_epi32(my_mullo_epu32(v1,p4),
					my_mullo_epu32(my_mulhi_epu32(v1,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u0,v0));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_add_epi32(u1,v1));
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_add_epi32(_mm_sub_epi32(u0,v0),mm));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_add_epi32(_mm_sub_epi32(u1,v1),mm));
				}
			}
		}
	}
	for(int i=0;i<n;++i)
		x[i]-=(x[i]>=us(MOD+MOD))*us(MOD+MOD),
		x[i]-=(x[i]>=us(MOD))*us(MOD);
}
void intt(us* __restrict__ x,int n)
{
	int t=1;
	for(int m=(n>>1);m;m>>=1)
	{
		us* __restrict__ p=p1[m];
		us* __restrict__ q=q1[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i uv=_mm_add_epi32(u,v);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv,mm),
					_mm_cmpgt_epi32(m0,uv)),mm)));
					uv=_mm_add_epi32(_mm_sub_epi32(u,v),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv,p4),
					my_mullo_epu32(my_mulhi_epu32(uv,q4),m1)));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					__m128i uv0=_mm_add_epi32(u0,v0);
					__m128i uv1=_mm_add_epi32(u1,v1);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv0,mm),
					_mm_cmpgt_epi32(m0,uv0)),mm)));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_sub_epi32(uv1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv1,mm),
					_mm_cmpgt_epi32(m0,uv1)),mm)));
					uv0=_mm_add_epi32(_mm_sub_epi32(u0,v0),mm);
					uv1=_mm_add_epi32(_mm_sub_epi32(u1,v1),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv0,p4),
					my_mullo_epu32(my_mulhi_epu32(uv0,q4),m1)));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_sub_epi32(my_mullo_epu32(uv1,p4),
					my_mullo_epu32(my_mulhi_epu32(uv1,q4),m1)));
				}
			}
		}
		t<<=1;
	}
	us rn=qp(n,MOD-2);
	for(int i=0;i<n;++i)
		x[i]=x[i]*(ull)rn%MOD;
}
	
	void mult(us *a, us as, us *b, us bs, us *o, bool construct, bool clean = 0, us th = 100000000) {
		us n = as+bs-1;
		if(n >= 40) {
    		while(n - (n & (-n))) n += (n & (-n));
    		assert(!construct);
    		//constructrev(n);
    		ntt(a, n); ntt(b, n);
    		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
    		intt(o, n);
		} else {
		    static ll tmp[41];
		    rep(i, as) rep(j, bs) tmp[i+j] += 1ll * a[i] * b[j];
		    rep(i, n) {
		        o[i] = tmp[i] % MOD;
		        tmp[i] = 0;
		    }
		}
		iter(i, th, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(us* a, us as, us *o) {
		static us tmp[524320];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); us le = 0;
		while((1 << le) < (as << 1)) le++;
		//constructrev(1 << le);
		memcpy(tmp, a, as*intsize);
		memset(tmp+as, 0, ((1<<le)-as)*intsize);
		ntt(tmp, 1<<le); ntt(o, 1<<le);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		intt(o, 1<<le);
		memset(o+as, 0, ((1<<le)-as)*intsize);
	}

	void init(us n) { prep(n); }
	
	void divide(us *a, us as, us *b, us bs, us *q, us *r) {
		static us ar[524320], br[524320], bin[524320];
		us th = as, re = as-bs+1;
		//th = re+1;
		rep(i, as) ar[i] = a[as-1-i];
		rep(i, bs) br[i] = b[bs-1-i];
		cfn(br, th, bin);
		mult(ar, th, bin, th, q, 0, 1, re);
		reverse(q, q+re);
		mult(q, re, b, bs, r, 0, 1, bs - 1);
		rep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;
	}
	
}

#define array MY_FUCKING_ARRAY

struct array {
    ptr<us> head; us sz;
    array() : sz(0) { head = nullptr; }
    array(us size) : sz(size) { head = new us[size]; }
    us& operator[](const us idx) { return head[idx]; }
    us* get() { return head.get(); }
    const us size() { return sz; }
};

array pol[524320];


namespace Eval {
    us points[524320];
    us answer[524320];
    
    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }

    void solve(us idx, us l, us r, array& polynomial) {
        static us tmp[524320], tmp2[524320], tmp3[524320], BULLSHIT[524320];
        //assert(polynomial.size() == r-l);
        if(r - l == 0) return;
        if(r - l == 1) {
            answer[l] = polynomial[0];
            return;
        }
        us m = (l+r)/2;
        if(m - l) {
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2].get(), (m-l+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, m-l+1, BULLSHIT, tmp3);
            array p2(m-l); memcpy(p2.get(), tmp3, (m-l)*intsize);
            solve(idx*2, l, m, p2);
        }
        if(r - m) { 
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2+1].get(), (r-m+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, r-m+1, BULLSHIT, tmp3);
            array p2(r-m); memcpy(p2.get(), tmp3, (r-m)*intsize);
            solve(idx*2+1, m, r, p2);
        }
    }
us p[524320];
us dv[524320];
us rp[524320];
us BULLsHIT[524320];
    array eval(array& po, array& v) {
        us n = po.size(), m = v.size();
        rep(i, m) {
            points[i] = v[i];
            if(!v[i]) v[i] = MOD;
        }
        init(1, 0, m);
        static us tmp[524320];
        array pp(m);
        if(n >= m+1) {
            rep(i, m+1) dv[i] = pol[1][i];
            rep(i, n) p[i] = po[i];
            poly::divide(p, n, dv, m+1, BULLsHIT, tmp);
            memcpy(pp.get(), tmp, m*intsize);
        } else pp = po;
        solve(1, 0, m, pp);
        array res(m); memcpy(res.get(), answer, m*intsize);
        return res;
    }
}

/*
namespace Inter {
    us points[524320], values[524320];
    
    array drv, coeff;

    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }
    
    array solve(us idx, us l, us r) {
        if(r - l == 0) {
            array ans(1); ans[0] = 1;
            return ans;
        }
        if(r - l == 1) {
            array ans(1); ans[0] = 1ll * values[l] * poly::qpow(coeff[l], MOD-2) % MOD;
            return ans;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320], tmp4[524320];
        array tmp = solve(idx*2, l, (l+r)/2);
        array tmpp = solve(idx*2+1, (l+r)/2, r);
        memcpy(tmp1, tmp.get(), tmp.size() * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), pol[idx*2+1].size() * intsize);
        us s1 = tmp.size() + pol[idx*2+1].size() - 1;
        poly::mult(tmp1, tmp.size(), tmp2, pol[idx*2+1].size(), tmp3, 0, 1); 
        rep(i, tmpp.size()) tmp1[i] = tmpp[i];
        memcpy(tmp1, tmpp.get(), tmpp.size() * intsize);
        memcpy(tmp2, pol[idx*2].get(), pol[idx*2].size() * intsize);
        us s2 = tmpp.size() + pol[idx*2].size() - 1;
        poly::mult(tmp1, tmpp.size(), tmp2, pol[idx*2].size(), tmp4, 0, 1); 
        s2 = max(s2, s1); tmp = array(s2);
        rep(i, s2) {
            us p = tmp3[i] + tmp4[i]; p -= (p >= MOD ? MOD : 0);
            tmp[i] = p;
            //tmp3[i] = tmp4[i] = 0;
        }
        return tmp;
    }

    array inter(array& pt, array& vl) {
        assert(pt.size() == vl.size());
        us n = pt.size();
        memcpy(points, pt.get(), n * intsize);
        memcpy(values, vl.get(), n * intsize);
        init(1, 0, n);
        drv = array(n);
        rep1(i, n) { drv[i-1] = 1ll * i * pol[1][i] % MOD; }
        coeff = Eval::eval(drv, pt);
        return solve(1, 0, n);
    }
}
*/

#define pol MY_FUCKING_pol

array pts;
array pol;
array tmp;

us fac[524300], ifac[524300], inv[524300];
us ar1[524320], ar2[524320], f[524320];

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n, p; io.read(n); io.read(p);
    n++;
    fac[0] = ifac[0] = fac[1] = ifac[1] = inv[0] = inv[1] = 1;
    iter(i, 2, n+2) {
    	inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;
    	fac[i] = 1ll * fac[i-1] * i % MOD;
    	ifac[i] = 1ll * ifac[i-1] * inv[i] % MOD;
    }
    pts = array(n+1);
    rep(i, n+1) pts[i] = i;
    pol = array(n);
    rep(i, n) io.read(pol[i]);
    int k = 1; while(k < ((n+2) << 1)) k <<= 1;
    poly::init(k);
    tmp = Eval::eval(pol, pts);
    rep(i, n+1) ar1[i] = 1ll * tmp[i] * ifac[i] % MOD;
    rep(i, n+1) ar2[i] = 1ll * ((i % 2) ? (MOD - 1) : 1) * ifac[i] % MOD;
    poly::mult(ar1, n+1, ar2, n+1, f, 0);
    int ans = 0;
    int t1 = p, t2 = poly::qpow((MOD + 1 - p) % MOD, MOD - 2);
    int v1 = 1, v2 = t2;
    rep(i, n+1) {
        ans = (ans + 1ll * f[i] * fac[i] % MOD * v1 % MOD * v2) % MOD;
        v1 = 1ll * v1 * t1 % MOD;
        v2 = 1ll * v2 * t2 % MOD;
    }
    cout << ans << endl;
}
```

---

## 作者：Y_B_X (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P5349)

>题意：  
给定多项式 $f$，以及有理数 $r\in(0,1)$  
求 $\displaystyle \sum_{n\geq 0}f(n)r^n$

设 $\displaystyle F(k)=\sum_{n\geq 0}n^kr^n$，那答案就只需依次乘上 $f$ 的各项系数即可。

而 $F(k)$ 也容易求得：

$$F(k)=\left[\dfrac{x^k}{k!}\right]\sum_{k\geq 0}\dfrac{x^k}{k!}\sum_{n\geq 0}n^kr^n=\left[\dfrac{x^k}{k!}\right]\sum_{n\geq 0}r^n\sum_{k\geq 0}\dfrac{(nx)^k}{k!}$$
$$=\left[\dfrac{x^k}{k!}\right]\sum_{n\geq 0}r^ne^{nx}=\left[\dfrac{x^k}{k!}\right]\dfrac{1}{1-re^x}$$

然后一次多项式求逆就没了，时间复杂度 $O(n\log n)$。

很不能理解其他人的鬼畜。

$\texttt{Code:}$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10;
const int mod=998244353;
char ch;int T,ans;
int n,k,m,nn,n_,x,y,res,wn,v;
int n1,len;int invn,w;
int a[N],b[N],nt[N];
int rev[N],inv[N],fac[N],ifac[N];
int invt[N];
inline void read(int &x){
	x=0;ch=getchar();while(ch<47)ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
void write(int x){if(x>9)write(x/10);putchar(48|x%10);}
inline void swap(int &x,int &y){x^=y^=x^=y;}
void qpow(int x,int k){
	res=1;
	while(k){
		if(k&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;k>>=1;
	}
}
void getinv(int n){
	register int i;
	for(inv[1]=1,i=2;i^n;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
}
void getfac(int n){
	register int i;
	for(ifac[0]=1,i=1;i^n;++i)ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	for(fac[0]=1,i=1;i^n;++i)fac[i]=1ll*fac[i-1]*i%mod;
}
void getrev(int n){
	static int i;
	n1=1;len=-1;while(n1<(n<<1))n1<<=1,++len;
	for(i=0;i^n1;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<len);
}
void ntt_init(int n){
	register int i,mid,j;n<<=1;
	for(mid=1;mid<n;mid<<=1){
		qpow(3,(mod-1)/(mid<<1));
		wn=res;nt[mid]=1;j=(mid<<1);
		for(i=mid+1;i<j;++i)nt[i]=1ll*nt[i-1]*wn%mod;
	}
}
inline int add(int x,int y){return x+y>mod?x+y-mod:x+y;}
inline int sub(int x,int y){return x>y?x-y:x-y+mod;}
inline void ntt(int n,int *a,bool t){
	register int i,mid,j,k;
	for(i=0;i^n;++i)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(mid=1;mid<n;mid<<=1){
		for(j=0;j<n;j+=(mid<<1)){
			for(k=0;k<mid;++k){
				x=a[j+k],y=1ll*nt[mid+k]*a[j+k+mid]%mod;
				a[j+k]=add(x,y);
				a[j+k+mid]=sub(x,y);
			}
		}
	}
	if(t){
		invn=n+1>>1;for(i=1;i^invn;++i)swap(a[i],a[n-i]);
		for(invn=inv[n],i=0;i^n;++i)a[i]=1ll*a[i]*invn%mod;
	}
}
void polyinv(int n,int *f,int *g){
	static int i;
	if(n==1)qpow(f[0],mod-2),g[0]=res;
	else {
		polyinv(n+1>>1,f,g);
		getrev(n);
		for(i=0;i^n;++i)invt[i]=f[i];
		for(i=n;i^n1;++i)invt[i]=0;
		ntt(n1,invt,0);ntt(n1,g,0);
		for(i=0;i^n1;++i)g[i]=1ll*sub(2,1ll*invt[i]*g[i]%mod)*g[i]%mod;
		ntt(n1,g,1);for(i=n;i^n1;++i)g[i]=0;
	}
}
main(){
	read(n),read(m);++n;register int i;
	getinv(n<<2),ntt_init(n<<1);getfac(n);
	for(i=0;i^n;++i)a[i]=mod-1ll*m*ifac[i]%mod;
	a[0]=add(1,a[0]);
	polyinv(n,a,b);
	for(i=0;i^n;++i)b[i]=1ll*b[i]*fac[i]%mod;
	for(i=0;i^n;++i)read(x),ans=add(ans,1ll*b[i]*x%mod);
	write(ans);
}
```


---

## 作者：warzone (赞：2)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/wangrx/solution-p5349)
## 题目大意

已知 $f(x)=\displaystyle\sum_{k=0}^ma_kx^k,r\in(0,1)$，  

求 $\left(\displaystyle\sum_{n=0}^\infty f(n)r^n\right)\bmod 998244353$ 。

$r$ 以$\mod{998244353}$ 意义给出。

$\texttt{Data Range: }0\le m\le10^5,a_k\in[0,998244353),a_m\not=0,$  
$\qquad\qquad\qquad r\not\equiv0,1\pmod{99844353}$

## 题解

前置芝士：[有限微积分](https://www.luogu.com.cn/blog/wangrx/finite-calculus)

$f(x)$ 是普通幂不好处理，转为下降幂多项式

$$f(x)=\sum_{k=0}^ma_kx^k=\sum_{k=0}^mf_kx^{\underline{k}}$$

使用分部求和公式求解不定和式 $\displaystyle\sum x^{\underline{k}}r^x\delta x$（此处省略求解过程）：



$$\sum x^{\underline{k}}r^x\delta x=\dfrac{r^x}{r-1}\sum_{i=0}^k{\left(\dfrac{-r}{r-1}\right)}^ik^{\underline{i}}x^{\underline{k-i}}$$


因此设 $g(x)=\displaystyle\sum f(x)r^x\delta x+C$，

则 $g(x)=r^xh(x)+C,h(x)$ 为一 $m$ 次下降幂多项式。  

$\lim\limits_{n\rightarrow\infty}r^nh(n)=0$，于是 


$$\sum_{n=0}^\infty f(n)r^n={\sum}_0^\infty f(x)r^x\delta x=\lim_{n\rightarrow\infty}{\sum}_0^nf(x)r^x\delta x$$

$$=\lim_{n\rightarrow\infty} g(n)-g(0)=\lim_{n\rightarrow\infty} r^nh(n)-h(0)=-h(0)$$

因此答案即为

$$-h(0)=-\sum_{k=0}^m\dfrac{f_k}{r-1}\sum_{i=0}^k\left(\dfrac{-r}{r-1}\right)^ik^{\underline{i}}0^{\underline{k-i}}$$
$$=-\sum_{k=0}^m\dfrac{f_k}{r-1}\left(\dfrac{-r}{r-1}\right)^kk!$$

$\Theta(m)$ 代入即可。

复杂度 $\Theta(m\log^2m)$，瓶颈为转下降幂多项式。

---

## 作者：huangzirui (赞：0)

题意：

求

$$\sum_{i=0}f(i)w^i$$

其中 $f$ 是次数为 $n$ 的多项式 $\sum_{i=0}^na_ix^i$，$w$ 是常数。

保证 $n \le 10^5$

---

生成函数入门题。

显然把要把它拆成单项式做。

构造生成函数 $F$ ，那么假设拆出了一项 $x^s$ ，就设：

$$F_s(x)=\sum\limits_{i=0}i^sw^i$$

套路地凑系数：

$$F_s(x)-wF_s(x)=\sum_{i=0}(i^s-(i-1)^s)w^i$$

拆一拆：

$$F_s(x)(1-w)=\sum_{i=1}w^i(\sum_{j=0}^{s-1} i^j{s\choose j})$$

试一试感觉走不下去了，考虑交换求和符号：

$$F_s(x)(1-w)=\sum_{j=0}^{s-1}{s\choose j}\sum_{i=1}w^ii^j$$

$$F_s(x)\dfrac{1-w}{w}=\sum_{j=0}^{s-1}{s\choose j}F_j(x)$$

这时再凑成卷积形式：

$$\dfrac{F_s(x)}{ws!}=\sum_{j=0}^{s}\dfrac{w^{s-j}}{(s-j)!}\dfrac{F_j(x)}{j!}$$
这样就很好了。

于是：

$$F(x)=we^xF(x)+1=\dfrac{1}{1-we^x}$$


---


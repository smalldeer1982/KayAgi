# [SDOI2019] 热闹的聚会与尴尬的聚会

## 题目背景

小 Q 的生日快到了，他决定周末邀请一些朋友到他的新房子一起聚会！

## 题目描述

他的联系薄上有 $n$ 位好友，他们两两之间或者互相认识，或者互相不认识。小 Q 希望在周六办一个热闹的聚会，再在周日办一个尴尬的聚会。

- 一场热闹度为 $p$ 的聚会请来了任意多位好友，对于每一位到场的好友来说都有至少 $p$ 位他认识的好友也参加了聚会，且至少对于一位到场的好友来说现场恰好有 $p$ 位他认识的好友；
- 一场尴尬度为 $q$ 的聚会请来了恰好 $q$ 位好友，且他们两两互不认识。

两场聚会可能有重复的参与者，联系薄上也有可能有某些好友同时缺席了两场聚会。

小 Q 喜欢周六聚会的热闹度 $p$ 与周日聚会的尴尬度 $q$ 之间满足：$\left\lfloor \frac{n}{p+1} \right\rfloor\! \le q$ 且 $\left\lfloor \frac{n}{q+1} \right\rfloor\! \le p$。

请帮助小 Q 找出一个可行的邀请方案。

## 说明/提示

#### 数据规模与约定

- 子任务 $1$（$10$ 分）：$1\le n\le 500$；  
- 子任务 $2$（$10$ 分）：$1\le n\le 700$；  
- 子任务 $3$（$10$ 分）：$1\le n\le 900$；  
- 子任务 $4$（$10$ 分）：$1\le n\le 1.1 \times {10}^3$；  
- 子任务 $5$（$10$ 分）：$1\le n\le 2 \times {10}^3$；  
- 子任务 $6$（$10$ 分）：$1\le n\le 3 \times {10}^3$；  
- 子任务 $7$（$10$ 分）：$1\le n\le 4.5 \times {10}^3$；  
- 子任务 $8$（$10$ 分）：$1\le n\le 6 \times {10}^3$；  
- 子任务 $9$（$10$ 分）：$1\le n\le 8 \times {10}^3$；  
- 子任务 $10$（$10$ 分）：$1\le n\le {10}^4$。

对于全部的测试点，满足 $1\le T\le 32$ 且 $1\le m\le 10^5$。

---

#### 提示

本题读入量很大，请注意自己代码在读入上的所需时间。

---
#### 说明

感谢 @[81179332\_](/user/53994) 提供 spj！

## 样例 #1

### 输入

```
2
6 15
1 2
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6
4 5
4 6
5 6
8 11
1 2
2 3
1 4
3 7
4 5
5 2
2 6
6 7
5 6
5 8
6 8```

### 输出

```
6 1 2 3 4 5 6
1 4
8 1 2 3 4 5 6 7 8
4 8 4 7 2```

# 题解

## 作者：liuzhangfeiabc (赞：28)

题目大意：给定无向简单图，你需要构造如下两个点集：

1、使得其点导出子图中度数最小的点尽量大。设这个度数为p。

2、求一个尽可能大的的独立集。设独立集大小为q。

则需要满足：n/(p+1)<=q，n/(q+1)<=p。这里的除法是下取整。

~~哈？最大独立集？！神仙sdoi居然出npc问题。~~

看起来是一道二合一，而且一时半会想不出为什么要这么合对吧。

那我们开始冷静分析一波。

首先你会发现，第一问求出一个最大的p是很简单的：只需要从全集出发，每次删掉一个度数最小的点，更新答案，并更新其余点的度数即可。我们能很容易地用堆维护这个过程。

证明也很简单：你对当前点集求了个答案，但是你有梦想觉得说不定还能更大些，那怎么办？当然是先无脑把度数最小的点删掉了，因为如果能通过删点使得答案变大，这个点显然一定不会在点集中。

而第二问呢？求最大独立集是不可能求的，这辈子不可能求的。我们只能想办法去求一些近似解。

最大独立集其实有多种近似算法，比如：

1、随机一个排列，按照排列的顺序往集合里加点，能加就加。

2、对1算法进行爬山/退火。

3、每次选一个度数最小的点扔进独立集中，把它相连的点全删掉。

你随便写了一个近似算法，本不抱有希望能a~~甚至像我一样做好了a不掉就退役的打算~~，然后你惊奇地发现你a了。

这一是因为题目中给出的界其实很松，二是因为这些近似算法其实都能得出蛮不错的解，~~三是因为数据是随的~~。

算法1和2是随机算法这里就不多说了。

这里主要说明一下：算法3是100%保证正确性的！

原因如下：

你每次加入一个度数最小的点时，它的度数一定不超过p，否则当前剩余的点就是第1问的一个更优的解，说明你第一问求错了。

因此，每加入一个点，最多删掉p个点。

这样构造出来的q>=n/(p+1)，恰好是题目中给出的式子，而且注意这里是上取整因此不存在差1之类的细节问题。

这个过程也可以很容易地用堆维护。

（其实据说不需要堆，实现得好可以做到线性。）

哦对了，**别忘了io优化**。

```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[100000],*buff = buf + 100000;
#define gc (buff == buf + 100000 ? (fread(buf,1,100000,stdin),buff = buf) : 0,*buff++)
char bb[10000010],*bbb = bb;
#define pc(x) (*(bbb++) = (x))
inline int read(){
	int x = 0,c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return x;
}
inline void print(int q){
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
int t,n,m;
struct edge{
	int to,nxt;
}e[200010];
int cnt,fir[10010],ds[10010],nwd[10010];
inline void ins(int u,int v){
	e[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;
	e[++cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;
	++ds[u];++ds[v];
}
int p1,p2,dlj[10010],shan[10010],wz,ft;
bool d1[10010],d2[10010];
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
priority_queue<pii > q;
int main(){
	int i,j;
	t = read();
	while(t--){
		memset(fir,0,sizeof(fir));memset(dlj,0,sizeof(dlj));memset(d1,0,sizeof(d1));memset(d2,0,sizeof(d2));memset(ds,0,sizeof(ds));memset(nwd,0,sizeof(nwd));memset(shan,0,sizeof(shan));cnt = p1 = p2 = wz = ft = 0;
		n = read();m = read();
		for(i = 1;i <= m;++i) ins(read(),read());
		while(!q.empty()) q.pop();
		for(i = 1;i <= n;++i) nwd[i] = ds[i],q.push(mp(-nwd[i],i));
		while(!q.empty()){
			pii p = q.top();q.pop();
			if(-p.fi != nwd[p.se]) continue;
			if(-p.fi >= p1){
				p1 = -p.fi;
				wz = ft;
			}
			shan[++ft] = p.se;d1[p.se] = 1;
			for(i = fir[p.se];i;i = e[i].nxt) if(!d1[e[i].to]){
				--nwd[e[i].to];
				q.push(mp(-nwd[e[i].to],e[i].to));
			}
		}
		while(!q.empty()) q.pop();
		for(i = 1;i <= n;++i) nwd[i] = ds[i],q.push(mp(-nwd[i],i));
		while(!q.empty()){
			pii p = q.top();q.pop();
			if(-p.fi != nwd[p.se]) continue;
			if(d2[p.se]) continue;
			dlj[++p2] = p.se;d2[p.se] = 1;
			for(i = fir[p.se];i;i = e[i].nxt) if(!d2[e[i].to]){
				d2[e[i].to] = 1;
				for(j = fir[e[i].to];j;j = e[j].nxt) if(!d2[e[j].to]){
					--nwd[e[j].to];
					q.push(mp(-nwd[e[j].to],e[j].to));
				}
			}
		}
		memset(d1,0,sizeof(d1));
		for(i = 1;i <= wz;++i) d1[shan[i]] = 1;
		print(n - wz);pc(' ');for(i = 1;i <= n;++i) if(!d1[i]) print(i),pc(' ');pc('\n');
		print(p2);pc(' ');for(i = 1;i <= p2;++i) print(dlj[i]),pc(' ');pc('\n');
	}
	fwrite(bb,1,bbb - bb,stdout);
	return 0;
}
```

---

## 作者：StudyingFather (赞：16)

两个问题能放在一道题里，说明这两个问题间应该存在点内在联系。

我们先看第一问。

第一问比较简单，我们每次从图上删除度数最小的点，并更新答案，即可确保 $p$ 尽可能大。

而对于求最大独立集，有诸如模拟退火等近似算法。如果有充裕的时间调参，理论上可以得到不错的解。当然这样的做法就和第一问无关了。

针对本题，我们有一种和解第一问差不多的方法：我们仍然每次挑出度数最小的点，把这个点加入独立集，并将与这个点直接相连的点从图中删掉。

可以证明，按照这个方法构造，一定可以满足题目所述限制。

证明如下：

我们每将一个点加入独立集，除去这个点本身外，最多会从图中删掉 $p$ 个点（第一问的结论）。

于是有 $q \geq \left \lceil \dfrac{n}{p+1} \right \rceil$。

```cpp
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
struct node
{
 int x,y;
 bool operator<(const node&a)const
 {
  return y>a.y;
 }
};
vector<int> e[10005];
int t[10005],t1[10005],t2[10005],vis[10005];
int ord[10005],res[10005],cnt;
priority_queue<node> q;
int main()
{
 ios::sync_with_stdio(false);
 int T;
 cin>>T;
 while(T--)
 {
  int n,m;
  int ansp=0,ansq=0,pos=0;
  cnt=0;
  cin>>n>>m;
  memset(t,0,sizeof(t));
  for(int i=1;i<=n;i++)
   vector<int>().swap(e[i]);
  for(int i=1;i<=m;i++)
  {
   int u,v;
   cin>>u>>v;
   e[u].push_back(v);
   e[v].push_back(u);
   t[u]++,t[v]++;
  }
  memcpy(t1,t,sizeof(t));
  memcpy(t2,t,sizeof(t));
  memset(vis,0,sizeof(vis));
  for(int i=1;i<=n;i++)
   q.push({i,t[i]});
  ansp=q.top().y;
  while(!q.empty())
  {
   int u=q.top().x;
   q.pop();
   if(vis[u])continue;
   ord[++cnt]=u,vis[u]=1;
   int rp=q.top().y;
   if(rp>ansp)
    ansp=rp,pos=cnt;
   for(auto v:e[u])
   {
    t1[v]--;
    q.push({v,t1[v]});
   }
  }
  memset(vis,0,sizeof(vis));
  for(int i=1;i<=n;i++)
   q.push({i,t[i]});
  while(!q.empty())
  {
   int u=q.top().x;
   q.pop();
   if(vis[u])continue;
   res[++ansq]=u,vis[u]=1;
   for(auto v:e[u])
    vis[v]=1;
  }
  memset(vis,0,sizeof(vis));
  for(int i=1;i<=pos;i++)
   vis[ord[i]]=1;
  cout<<n-pos<<' ';
  for(int i=1;i<=n;i++)
   if(!vis[i])cout<<i<<' ';
  cout<<endl;
  cout<<ansq<<' ';
  for(int i=1;i<=ansq;i++)
   cout<<res[i]<<' ';
  cout<<endl;
 }
 return 0;
}
```

---

## 作者：i207M (赞：16)

哇塞，智商不够了不够了。

首先原题可以转化为$(p+1)(q+1)\ge n+1$

构造方法：

独立集：

每次找出当前图G中度数最小的点，在q中加入它，然后删掉它和它相邻的所有点得到新图G'

度数限制图：

维护在这个过程中，度数最小的点最大的时候，将此时G中所有点加入集合中

证明：

如果独立集的算法运行了q次，第i次删掉的点的度数为$d_i$，于是有$\sum_{i=1}^q d_i+1=n$

要求的是$(\max(d_i)+1)(q+1)$，显然$\ge n$

```cpp
void solve()
{
	int mn=n,cntq=0,mxp=0,mxpk=0;
	for(ri i=1; i<=n; ++i) q[du[i]=Size(E[i])].push(i),ckmin(mn,du[i]);
	while(mn<n)
	{
		while(!q[mn].empty()&&del[q[mn].front()]) q[mn].pop();
		if(q[mn].empty()) {++mn; continue;}
		if(ckmax(mxp,mn)) mxpk=cntq;
		int x=q[mn].front(); q[mn].pop();
		del[x]=++cntq;
		B.pb(x);
		for(solid v:E[x])
		{
			if(del[v]) continue;
			del[v]=cntq;
			for(solid w:E[v])
				q[--du[w]].push(w),ckmin(mn,du[w]);
		}
	}
	for(ri i=1; i<=n; ++i) if(del[i]>=mxpk) A.pb(i);
	out(Size(A),' ');
	prt(&A[0],Size(A));
	out(Size(B),' ');
	prt(&B[0],Size(B));
}
```


---

## 作者：s_r_f (赞：7)

这道题太神仙了。。。

这个题$T = 32$,一看出题人就知道多测防乱搞~~于是我就写了随机化~~

## 第一问：求解最大的p和方案

第一问显然可以二分答案。

当我们二分$mid$时，我们可以考虑一直把$deg[x] < mid$的点直接删除，然后更新和$x$有连边的点$y$的$deg[y](deg[y]--)$,类似$bfs$的形式把所有$deg < mid$的点都删掉。

二分$check$的复杂度是$O(n+m)$的，所以第一问求得最优解的复杂度是
$O(Tmlogn)$

## 第二问：求出满足条件的可行的q的方案

第二问，~~好像没有多项式做法啊！~~

我们知道如果求最优解，那就是**一般图最大独立集**,是$NP$完全问题。

但是我们已经求出了第一问的$ans = p$

那么我们可以~~暴力枚举~~$q$的取值，找到最小的可行的$q$.

然后，就是

### 乱搞时间！

考虑一个很蠢的贪心：

我们把点$1$放进答案集合,然后枚举$1$的相邻点，把它们打上$tag$，即这些点不能选。

然后看点$2$有没有被打标记，如果有，就不管它，否则就把$2$放进答案集合，把$2$的相邻点打上$tag$.

然后枚举$3,4,5,6,...,n$,如果某个时刻答案集合中有$>=q$个数，就找到了方案。

~~如果找不到就~~ $WA$ ~~了~~，所以这样只做一遍是不行的。

考虑把点随机打乱，如果第一遍不行，就打乱之后再来一遍，直到找到一个可行解。

然后，加几个小特判，卡卡常，你就可以过掉了。

我的代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    static int x; static char c;
    x = 0,c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
    return x;
}
inline void write(int x){
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
inline void writeln(int x){ write(x),putchar('\n'); }
void File(){
    freopen("party.in","r",stdin);
    freopen("party.out","w",stdout);
}
const int N = 10050,M = 100050;
int To[M<<1],Ne[M<<1],He[N],k = 0;
int T,n,m,deg[N],cnt[N],ansp,ansq;
bool ans1[N],ans2[N],ans3[N];
inline void add(int x,int y){
    ++deg[x],++deg[y];
    ++k; To[k] = y,Ne[k] = He[x],He[x] = k;
    ++k; To[k] = x,Ne[k] = He[y],He[y] = k;
}
int Q[N],ql,qr;
inline bool check(int v){
    int size = n,i,x,y,p;
    ql = 1,qr = 0;
    for (i = 1; i <= n; ++i)
        if (deg[i] < v) ans3[i] = 0,Q[++qr] = i,--size; else ans3[i] = 1;
    while (ql <= qr && size > v){
        x = Q[ql],++ql;
        for (p = He[x]; p; p = Ne[p]) if (ans3[y=To[p]]){
            --deg[y];
            if (deg[y] < v) ans3[y] = 0,Q[++qr] = y,--size;
        }
    }
    memcpy(deg,cnt,(n+2)<<2);
    if (size > v) {memcpy(ans1,ans3,n+2); return 1;}
    return 0;
}
int id[N]; bool vis[N];
int main(){
    srand(time(NULL));
    int i,j,x,y,tot,p;
    T = read();
    while (T--){
        n = read(),m = read();
        k = 0,memset(He,0,(n+2)<<2),memset(deg,0,(n+2)<<2);
        while (m--) x = read(),y = read(),add(x,y);
        memcpy(cnt,deg,(n+2)<<2);
        int l = 1,r = n-1,mid;
        ansp = 0;
        while (l <= r){
            mid = l + r >> 1;
            if (check(mid)) ansp = mid,l = mid + 1; else r = mid - 1;
        }
        tot = 0;
        for (i = 1; i <= n; ++i) if (ans1[i]) ++tot;
        write(tot),putchar(' ');
        for (i = 1; i <= n; ++i) if (ans1[i]) write(i),putchar(' ');
        putchar('\n');
        for (i = 1; i <= n; ++i)
            if (n/(ansp+1) <= i && n/(i+1) <= ansp) {ansq = i; break;}
        if (ansq == 1){ printf("1 1\n"); continue; }
        if (ansq == n){ write(n),putchar(' '); for (i = 1; i < n; ++i) write(i),putchar(' '); writeln(n); }
        else{
            for (i = 1; i <= n; ++i) id[i] = i;
            while (1){
                tot = 0;
                random_shuffle(id+1,id+n+1);
                memset(vis,0,n+2);
                memset(ans2,0,n+2);
                for (i = 1; i <= n && tot < ansq; ++i)
                    if (!vis[x = id[i]]){
                        ans2[x] = 1,++tot;
                        for (p = He[x]; p; p = Ne[p]) vis[To[p]] = 1;
                    }
                if (tot == ansq){
                    write(tot),putchar(' ');
                    for (i = 1; i <= n; ++i) if (ans2[i]) write(i),putchar(' ');
                    putchar('\n');
                    break;
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：Hope2075 (赞：3)

考试时写了一个乱搞做法，然后另外两道题一点思路都没有

本来已经作好Day2爆零的心理准备了

结果：100+0+0

~~然后完美退役~~

首先，把两个限制分别搞一下：

$\lfloor \frac{n}{p+1} \rfloor\le q$

左边是向下取整，不太好放缩，改成向上取整

$\lceil \frac{n-p}{p+1} \rceil\le q$

实际上就是被取整的数减1，然后分子加1，这样得到的数上取整和原数相同

然后可以把取整符号去掉

$\frac{n-p}{p+1}\le q$

乘过去

$n-p \le q(p+1)$

$n-p \le pq+q$

$n \le pq+p+q$

利用整数的离散性，在右边加1，符号变为小于

$n < pq+p+q+1=(p+1)(q+1)$

注意这里的条件只是要求成立的必要条件

然后证明充分性：

$n < (p+1)(q+1)$

$\frac{n}{p+1} < q+1$

$\lfloor \frac{n}{p+1} \rfloor < q+1$

还是利用整数的离散性：

$\lfloor \frac{n}{p+1} \rfloor \le q$

所以这个条件是满足要求的充要条件

接下来就是乱搞时间了

还是介绍一下我的乱搞做法吧

对于$p$：

从初始图开始，每一步删除一个度数最小的点，然后记录中间出现的最大值

这样似乎可以感性证明是对的，大概就是因为保留这个点不会使答案更优

我维护的时候用的线段树

对于$q$：

完全没有思路

然后就考虑乱搞了

从每个节点开始，尝试对图进行黑白染色，如遇冲突，则把这个点删掉，不再扩展范围

每次染一些点，就取这部分点中所有黑色点或所有白色点

这样做正确性是有保证的，但很容易举出反例证明不是最优策略

然而，数据似乎是随机的，而且发现给出的条件很宽松

于是，就这样过了

最后是代码：

```cpp
#include<cstdio>
long long read(){
	long long n=0;bool f=0;char c=getchar();
	while(c!='-'&&(c<'0'||c>'9'))c=getchar();
	if(c=='-'){f=1;c=getchar();}
	while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
	if(f)return -n;
	else return n;
}
char res[25];
void write(long long n){
	if(n==0){putchar('0');return;}
	if(n<0){putchar('-');n=-n;}
	int t=0;
	while(n){
		res[t++]=n%10+'0';
		n/=10;
	}
	while(t--)putchar(res[t]);
}
const int N=10086,M=100007;

int t,n,m;
namespace p1{
	int head[N],next[M*2],ver[M*2],tot;
	int deg[N];
	int delt[N];
	int minn[N*4];
	int col[N];
	int cur;
	int he,ta,que[N];
	bool sel[N];
	int pa[N];
	void reset(){
		for(int i=1;i<=n;i++){
			head[i]=0;
			deg[i]=0;
			delt[i]=0;
			col[i]=0;
			sel[i]=0;
			pa[i]=0;
		}
		tot=0;
		he=ta=0;
	}
	void add(int a,int b){
		deg[a]++;deg[b]++;
		tot++;
		ver[tot]=b;
		next[tot]=head[a];
		head[a]=tot;
		tot++;
		ver[tot]=a;
		next[tot]=head[b];
		head[b]=tot;
	}
	inline int min(int a,int b){
		if(a>b)return b;
		else return a;
	}
	void upd(int p,int n,int ll,int rr,int id){
		if(ll==rr){
			minn[id]=n;
			return;
		}
		int mid=((ll+rr)>>1);
		if(p<=mid)upd(p,n,ll,mid,id<<1);
		else upd(p,n,mid+1,rr,(id<<1)|1);
		minn[id]=min(minn[id<<1],minn[(id<<1)|1]);
	}
	int gid(int ll,int rr,int id){
		if(ll==rr){
			minn[id]=0x7fffffff;
			return ll;
		}
		int mid=((ll+rr)>>1);
		int ans;
		if(minn[id<<1]>minn[(id<<1)|1]){
			ans=gid(mid+1,rr,(id<<1)|1);
		}else{
			ans=gid(ll,mid,(id<<1));
		}
		minn[id]=min(minn[id<<1],minn[(id<<1)|1]);
		return ans;
	}
	int maxn,maxt;
	void build(int ll,int rr,int id){
		if(ll==rr){
			minn[id]=deg[ll];
			return;
		}
		int mid=((ll+rr)>>1);
		build(ll,mid,id<<1);
		build(mid+1,rr,(id<<1)|1);
		minn[id]=min(minn[id<<1],minn[(id<<1)|1]);
	}
	int solve(){
		build(1,n,1);
		maxn=0;
		for(int t=1;t<=n;t++){
			if(minn[1]>maxn){
				maxn=minn[1];
				maxt=t;
			}
			int cur=gid(1,n,1);
			delt[cur]=t;
			for(int i=head[cur];i;i=next[i]){
				if(delt[ver[i]])continue;
				deg[ver[i]]--;
				upd(ver[i],deg[ver[i]],1,n,1);
			}
		}
		write(n-maxt+1);putchar(' ');
		for(int i=1;i<=n;i++){
			if(delt[i]>=maxt){write(i);putchar(' ');}
		}
		putchar('\n');
		return maxn;
	}
	
	int solve2(){
		int sum=0;
		for(int i=1;i<=n;i++){
			if(!col[i]){
				he=ta=0;
				que[he++]=i;
				col[i]=1;
				int bcnt=0,wcnt=0;
				while(he!=ta){
					int cur=que[ta++];
					
					if(col[cur]==3)continue;
					if(col[cur]==1)bcnt++;
					else wcnt++;
					for(int k=head[cur];k;k=next[k]){
						if(pa[ver[i]]!=0&&pa[ver[i]]!=i)continue;
						pa[ver[i]]=i;
						if(!col[ver[k]]){
							col[ver[k]]=3-col[cur];
							que[he++]=ver[k];
						}else if(col[cur]==col[ver[k]]){
							col[ver[k]]=3;
						}
					}
				}
				if(bcnt>wcnt){
					sum+=bcnt;
					for(int k=0;k<he;k++){
						if(col[que[k]]==1)sel[que[k]]=1;
					}
				}else{
					sum+=wcnt;
					for(int k=0;k<he;k++){
						if(col[que[k]]==2)sel[que[k]]=1;
					}
				}
			}
		}
		write(sum);putchar(' ');
		for(int i=1;i<=n;i++){
			if(sel[i]){
				write(i);putchar(' ');
			}
		}
		putchar('\n');
		return sum;
	}
}
int a,b;
bool f;
int main(){
	freopen("party.in","r",stdin);
	freopen("party.out","w",stdout);
	t=read();
	while(t--){
		n=read();
		m=read();
		p1::reset();
		while(m--){
			a=read();
			b=read();
			p1::add(a,b);
		}
		a=p1::solve()+1;
		b=p1::solve2()+1;
	}
}
```


---

## 作者：Purslane (赞：2)

# Solution

首先分析一下这个诡异的限制：$\lfloor \frac{n}{p+1} \rfloor \le q$ 且 $\lfloor \frac{n}{q+1} \rfloor \le p$。

首先，如果 $p+1 \nmid n$，那么 $\frac{n}{p+1}$ 就不是整数，因此 $\frac{n}{p+1} < q+1$。因此 $\frac{n}{q+1} < p+1$。必定有 $\lfloor \frac{n}{q+1} \rfloor \le p$。如果 $p+1 \mid n$，也就是 $\frac{n}{p+1} \le q$。于是  $\frac{n}{p+1} < q+1$ 得到 $\frac{n}{q+1} < p+1$，也就是 $\lfloor \frac{n}{q+1} \rfloor \le p$。于是我们只需要满足第一个条件。

然后你发现，你让 $p$ 和 $q$ 分别取到最大值，那么肯定满足！

首先考虑怎么求 $p$ 的最大值。考虑我们从 $G$ 出发逐步调整。注意，为了让答案更大，当前度数最小节点**必须删去**，而删去其他节点是没有意义的。然后在这个过程中枚举最小度数的最大值即可。

第二问是一般图的最大独立集问题。据说它是 NPC 问题。

但是考虑到你并不一定要把最大独立集求出来。下面再给出一个算法：每次把度数最小的节点和它所有相邻节点取出来，并且把这个度数最小的节点放进独立集里面去。由于每个时刻度数最小点的度数必然小于等于 $p$，因此这一步最多删掉 $p+1$ 个点。所以你一共最少可以进行 $\lceil \frac{n}{p+1} \rceil \ge \lfloor \frac{n}{p+1} \rfloor$ 步。

这个过程有点像 Dijkstra。于是你可以借鉴一下。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e4+10,MAXM=1e5+10;
int T,n,m,Deg[MAXN],deg[MAXN],in[MAXN];
pair<int,int> E[MAXM]; 
vector<int> G[MAXN];
int read(void) {
	int s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return s;	
}
struct Node {int u,dis;};
bool operator <(Node A,Node B) {return A.dis>B.dis;}
int vis[MAXN],res;
vector<int> ot,ans;
void solve(int mn=-1) {
	priority_queue<Node> q;
	ffor(i,1,n) vis[i]=0,deg[i]=Deg[i];
	ffor(i,1,n)	q.push({i,deg[i]});
	int flg=0;
	while(!q.empty()) {
		int u=q.top().u;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		if(mn==-1) res=max(res,deg[u]);
		else {
			if(deg[u]>=mn) flg=1;
			if(flg) ot.push_back(u);	
		}
		for(auto v:G[u]) if(vis[v]==0) deg[v]--,q.push({v,deg[v]});
	}
	return ;
}
void Solve(void) {
	ffor(i,1,n) vis[i]=0,deg[i]=Deg[i];
	priority_queue<Node> q;
	ffor(i,1,n) q.push({i,deg[i]});
	while(!q.empty()) {
		int u=q.top().u; q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		ans.push_back(u);
		for(auto v:G[u]) {
			if(vis[v]==0) {
				vis[v]=1;
				for(auto t:G[v]) if(vis[t]==0) deg[t]--,q.push({t,deg[t]});
			}
		}
	}
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	T=read();
	while(T--) {
		n=read(),m=read(),ot.clear();
		ffor(i,1,n) deg[i]=0,G[i].clear();
		ffor(i,1,m) {int u=read(),v=read();E[i]={min(u,v),max(u,v)};}
		sort(E+1,E+m+1),m=unique(E+1,E+m+1)-E-1;
		ffor(i,1,m) {
			deg[E[i].first]++,deg[E[i].second]++;
			G[E[i].first].push_back(E[i].second),G[E[i].second].push_back(E[i].first);	
		}
		ffor(i,1,n) Deg[i]=deg[i];
		res=*min_element(deg+1,deg+n+1),solve(),solve(res);
		printf("%d ",(int)ot.size());for(auto id:ot) printf("%d ",id); puts("");
		ans.clear(); Solve();
		printf("%d ",(int)ans.size());for(auto pr:ans) printf("%d ",pr); puts("");
	}
	return 0;
}
```

---

## 作者：FZzzz (赞：2)

不明白为什么大佬们的思路都那么神奇且复杂……下面是我的乱搞做法。

首先我们发现这个要求就是要让两问答案都尽量大，所以这是个二合一题。

第一问显然可以二分，按度数 dfs 删点即可。

第二问是个最大独立集……npc 啊。当然如果你对你的剪枝技巧有信心认为你可以 $2^n$ 过 $10^4$ 你可以去写状压或者你认为你可以现场拿到图灵奖你就去想多项式解法。我反正决定随机化乱搞。

最大独立集的随机化做法还是很经典的。我们随机一个排列，从前往后贪心选点即可。当然你也可以对这个序列进行退火，这题没必要。

然后由于这题的界是很松的，所以稳过。

下面是代码，由于搬题人@—扶苏— 的锅有时会莫名 UKE。
```cpp
#include<algorithm>
#include<vector>
#include<ctime>
#include<cstring>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
    int x=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c)&&c!='-') c=getchar();
    if(c=='-'){
        f=1;
        c=getchar();
    }
	while(isdigit(c)){
        x=x*10+c-'0';
        c=getchar();
    }
    return f?-x:x;
}
const int maxn=1e4+5;
int n,m;
vector<int> g[maxn];
int deg[maxn];
bool vis[maxn];
void dfs(int u,int p){
	vis[u]=1;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(vis[v]) continue;
		deg[v]--;
		if(deg[v]<p) dfs(v,p);
	}
}
void check(int p){
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++) deg[i]=g[i].size();
	for(int i=1;i<=n;i++)
		if(!vis[i]&&deg[i]<p) dfs(i,p);
}
int ord[maxn];
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    srand(time(0)*20060122);
    int t=readint();
    while(t--){
    	n=readint();
    	m=readint();
    	for(int i=1;i<=n;i++) g[i].clear();
    	for(int i=0;i<m;i++){
    		int u,v;
    		u=readint();
    		v=readint();
    		g[u].push_back(v);
    		g[v].push_back(u);
		}
		int l=0,r=n-1;
		while(l<r){
			int mid=l+(r-l+1)/2;
			check(mid);
			bool ok=0;
			for(int i=1;i<=n;i++) if(!vis[i]){
				ok=1;
				break;
			}
			if(ok) l=mid;
			else r=mid-1;
		}
		check(r);
		int cnt=0;
		for(int i=1;i<=n;i++) if(!vis[i]) cnt++;
		printf("%d ",cnt);
		for(int i=1;i<=n;i++) if(!vis[i]) printf("%d ",i);
		printf("\n");
		for(int i=1;i<=n;i++) ord[i]=i;
		random_shuffle(ord+1,ord+n+1);
		memset(vis,0,sizeof(vis));
		for(int i=1;i<=n;i++){
			int ok=1;
			for(int j=0;j<g[ord[i]].size();j++)
				if(vis[g[ord[i]][j]]){
					ok=0;
					break;
				}
			if(ok) vis[ord[i]]=1;
		}
		cnt=0;
		for(int i=1;i<=n;i++) if(vis[i]) cnt++;
		printf("%d ",cnt);
		for(int i=1;i<=n;i++) if(vis[i]) printf("%d ",i);
		printf("\n");
	}
    return 0;
}
```


---

## 作者：ModestCoder_ (赞：2)

构造题

首先对于条件进行转化-->$(p+1)(q+1)>n$

然后就是构造一个$p,q$出来

考虑一种做法：

 - 在图中选出度数最小的点，这个度数记为$d_i$
 - 将该点以及与该点直接相连的点删去
 - 重复上述过程直到无点为止
 - 取出$d_i$最大的时刻的图作为第一个点集，此时热闹度$p=d_i$，取所有操作1选择的点作为第二个点集就行了

考虑证明正确性：

设操作1共进行了$q$次，$dmax=max(d_i)$

得到$\sum_{i=1}^{q}(d_i+1)=n$,$p=dmax$

那么$(p+1)q>=\sum_{i=1}^{q}(d_i+1)=n$

即$(p+1)(q+1)>n$

得证

至于怎么维护这个删点并且修改点集中度数，每次还要找最小，用$std::set$

然后我这个$set$是新学的，不明白为什么$operator$写结构体里要把大小关系反一下？难道是$set$的特点？

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 1];
int num, head[maxn], n, m, cnt, len, q[maxn], print[maxn], d[maxn];
struct node{
	int u, d;
}a[maxn];
bool operator < (node a, node b){ return a.d == b.d ? a.u < b.u : a.d < b.d; }
typedef set<node> :: iterator iter;
set<node> S;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }

int main(){
	int Q = read();
	while (Q--){
		n = read(), m = read(), cnt = len = num = 0;
		memset(head, 0, sizeof(head));
		for (int i = 1; i <= n; ++i) d[i] = 0, a[i] = (node){i, 0};
		for (int i = 1; i <= m; ++i){
			int x = read(), y = read();
			addedge(x, y), addedge(y, x);
			++a[x].d, ++a[y].d, ++d[x], ++d[y];
		}
		for (int i = 1; i <= n; ++i) S.insert(a[i]);
		int maxd = -1, pos = 0;
		while (!S.empty()){
			int u = (*S.begin()).u; 
			if (d[u] > maxd) maxd = d[u], pos = len;
			S.erase(S.begin());
			q[++len] = u, print[++cnt] = u;
			for (int i = head[u]; i; i = edge[i].next){
				int v = edge[i].to;
				iter it = S.find((node){v, d[v]});
				if (it == S.end()) continue;
				S.erase(it), q[++len] = v;
				for (int j = head[v]; j; j = edge[j].next){
					int k = edge[j].to;
					it = S.find((node){k, d[k]});
					if (it == S.end()) continue;
					S.erase(it), S.insert((node){k, --d[k]});
				}
			}
		}
		printf("%d ", len - pos);
		for (int i = pos + 1; i <= len; ++i) printf("%d ", q[i]);
		puts("");
		printf("%d ", cnt);
		for (int i = 1; i <= cnt; ++i) printf("%d ", print[i]);
		puts("");
	}
	return 0;
}
```


---

## 作者：_Ch1F4N_ (赞：0)

比较牛的构造题。

首先我们的目标大致是最大化 $p,q$，由于一般图最大独立集不太可做所以我们先来最大化 $p$。

可以尝试二分一个答案 $mid$，不断地将所有度数小于等于 $mid$ 的点以及他们所连的边删去，最后如果图没被删空就代表 $p \geq mid$。

由于构造的 $q$ 的限制与 $p$ 强相关，所以我们考虑在构造最大 $p$ 的过程中顺便构造出满足要求的 $q$，首先我们需要简化最大 $p$ 的构造过程。

考虑从 $\text{check}(x)$ 的过程扩展到 $\text{check(x+1)}$ 的过程，你发现我们只需要再把度数为 $x+1$ 的点也列入删除的范畴即可，于是可以考虑这样一个过程：每次取出度数最小的点删除，并在这个过程中维护一个集合 $S$，如果取出的点度数大于 $S$ 中所有点在被取出时的度数就清空 $S$，否则什么都不做，然后加入这个点本身。那么最后 $S$ 就是构造到最大 $p$ 的一种方案。

然后考虑在这个过程中构造一个合法的 $q$，首先我们可以想到和构造 $p$ 的过程类似的一个贪心求解出一个尽可能大的（显然可能不是最大的）独立集的算法，每次取出度数最小点，如果没有被标记就将其加入独立集并标记其邻域，然后无论其有没有被标记都将其自己与自己所连出的边删去，显然可以在构造 $p$ 的过程中同时进行这个算法，并且注意到每次标记的邻域大小一定不超过 $p$，由于我们的算法会一直进行到图被删空，所以显然至少会有 $\left\lfloor \frac{n}{p+1} \right\rfloor$ 个点被我们加入独立集，故得到了一个合法构造。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e4+114;
vector<int> E[maxn];
int d[maxn];
int vis[maxn],del[maxn];
int n,m;
vector<int> S,T;
set< pair<int,int> > q;
void work(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        E[u].push_back(v);
        E[v].push_back(u);
    }   
    for(int i=1;i<=n;i++){
        d[i]=E[i].size();
        q.insert(make_pair(d[i],i));
    }
    int maxd=0;
    while(q.size()>0){
        int u=(*q.begin()).second;
        if(d[u]>maxd) S.clear(),maxd=max(maxd,d[u]);
        S.push_back(u);
        del[u]=1;
        q.erase(make_pair(d[u],u));
        if(vis[u]==0){
            T.push_back(u);
            vis[u]=1;
            for(int v:E[u]) vis[v]=1;
        }
        for(int v:E[u]){
            if(del[v]==1) continue;
            q.erase(make_pair(d[v],v));
            d[v]--;
            q.insert(make_pair(d[v],v));
        }
        E[u].clear();
    }
    cout<<S.size()<<" ";
    for(int x:S) cout<<x<<" ";
    cout<<"\n";
    cout<<T.size()<<" ";
    for(int x:T) cout<<x<<" ";
    cout<<"\n";
    for(int i=1;i<=n;i++) vis[i]=del[i]=0;
    S.clear(),T.clear();
    return ;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--) work();
    return 0;
}
```

---

## 作者：龙之吻—水货 (赞：0)

# [SDOI2019]热闹又尴尬的聚会

## 题目大意

给你一个无向图，求这个图的一个子图，其最小度数为 $p$，再求这个图的一个点独立集，其大小为 $q$，使得 $\lfloor \frac{n}{q+1} \rfloor\le p$ 且 $\lfloor \frac{n}{p+1} \rfloor\le q$。

## 解题报告

看这题的第一眼，就感觉要考虑 $p$ 和 $q$ 的关系，于是打了一个表，发现当 $n = 100$ 的时候，$p, q$ 中任意一个达到 $10$ 左右的时候，另一个就可以取任意值了，所以这题似乎只需要求一个较优解就可以了。

在打同步赛的时候，感觉 $q$ 的最大值似曾相识，于是考虑先求出 $q$ 的最大值，然后找出相应的最小的 $q$，统计答案即可。

但是，众所周知，求一般图的点的最大独立集及其难写，而且时间复杂度也并不对劲。所以在考场上我想了一个比较 naive 的贪心求法，就是把点按度数排序，之后能选则选。

虽然这么求独立集并不清真，但似乎效率还并不差，于是就这么求出了 $q$。

然后，就十分简单了，根据 $q$ 求出最小的 $p$，然后进行一个类似拓扑排序的东西，大体就是如果一个点的度数小于 $p$，就把这个点删去，并计算一下影响。

整个算法的复杂度应该是 $O(T(n\log{n} + m))$ 的，时间复杂度的瓶颈就是边数和 sort，完全可过。

本来以为这个算法能骗 $50$ ~ $60$ 分的，结果交上去，一遍 $AC$ ？！！！

最后，附上想要骗分却直接 AC 的 Code :

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>

std::vector<int> e[10007];

class Solution{
private :
    static const int maxn = 1e4 + 7;
    
    int t, n, m, id[maxn], res[maxn], cnt, need, degree[maxn];
    int tot, ans[maxn];
    bool vis[maxn], out[maxn];
    std::queue<int> q;

    void clear() {
        for (register int i = 1; i <= n; i++) {
            std::vector<int>().swap(e[i]);
        }
    }

    static bool cmp(int x, int y) {
        return e[x].size() < e[y].size();
    }

    void topoSort() {
        for (register int i = 1; i <= n; i++) {
            if (degree[i] < need) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int now = q.front();
            q.pop();
            out[now] = 1;
            for (auto v : e[now]) {
                if (degree[v] == need) {
                    q.push(v);
                    continue;
                }
                degree[v]--;
            }
        }
    }
    
public :
    Solution() {
        scanf("%d", &t);
        while (t--) {
            get();
            solve();
            clear();
        }
    }

    void get() {
        scanf("%d %d", &n, &m);
        for (register int i = 1, u, v; i <= m; i++) {
            scanf("%d %d", &u, &v);
            e[u].push_back(v);
            e[v].push_back(u);
        }
    }

    void solve() {
        for (register int i = 1; i <= n; i++) {
            id[i] = i;
            degree[i] = e[i].size();
        }
        memset(vis, 0, sizeof(vis));
        std::sort(id + 1, id + 1 + n, cmp);
        cnt = tot = 0;
        for (register int i = 1; i <= n; i++) {
            int now = id[i];
            if (!vis[now]) {
                vis[now] = 1;
                res[++cnt] = now;
                for (auto v : e[now]) {
                    vis[v] = 1;
                }
            }
        }
        need = n;
        for (register int i = 1; i <= n; i++) {
            if (n / (i + 1) <= cnt && n / (cnt + 1) <= i) {
                need = i;
                break;
            }
        }
        topoSort();
        for (register int i = 1; i <= n; i++) {
            if (!out[i]) {
                ans[++tot] = i;
            }
        }
        printf("%d", tot);
        for (register int i = 1; i <= tot; i++) {
            printf(" %d", ans[i]);
        }
        putchar('\n');
        //printf("%d\n", need);
        printf("%d", cnt);
        for (register int i = 1; i <= cnt; i++) {
            printf(" %d", res[i]);
        }
        putchar('\n');
    }
};
Solution sol;

int main() {}

```

---

## 作者：MLEAutoMaton (赞：0)

首先不难发现第二问可以直接输出最大独立集，因为我们要求的是$(p+1)(q+1) > n$，所以最大化$q$一定没有问题。

然后现在要求这个$p$，可以二分然后类似$bfs$一样判断。

最大独立集直接$random\_shuffle$即可。

```cpp
/*====================
author: fexuile
mail: fexuile@qq.com
QQ: 2165008534
====================*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<iostream>
#include<set>
#include<map>
using namespace std;
#define mp make_pair
#define ll long long
#define re register
typedef pair<int,int> pii;
#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
inline int gi(){
	int f=1,sum=0;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
const int N=200010;
int front[N],cnt,a[N],tot1,n,m,vis[N],p[N],b[N],tot2,d[N],D[N],B[N],TOT;
struct node{int to,nxt;}e[400010];
void Add(int u,int v){e[++cnt]=(node){v,front[u]};front[u]=cnt;D[u]++;}
queue<int>Q;
bool check(int mid){
	for(int i=1;i<=n;i++){
		d[i]=D[i];
		if(d[i]<mid)Q.push(i),vis[i]=1;
		else vis[i]=0;
	}
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=front[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(!vis[v]){
				d[v]--;
				if(d[v]<mid)Q.push(v),vis[v]=1;
			}
		}
	}
	tot1=0;
	for(int i=1;i<=n;i++)if(!vis[i])a[++tot1]=i;
	return tot1;
}
bool cmp(int a,int b){return D[a]>D[b];}
void solve(){
	n=gi();m=gi();
	for(int i=1;i<=n;i++)vis[i]=D[i]=front[i]=0;cnt=tot1=tot2=0;
	for(int i=1;i<=m;i++){
		int u=gi(),v=gi();
		Add(u,v);Add(v,u);
	}
	int l=0,r=n-1,ret=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid)){ret=mid;l=mid+1;}
		else r=mid-1;
	}
	check(ret);
	printf("%d ",tot1);for(int i=1;i<=tot1;i++)printf("%d%c",a[i]," \n"[i==tot1]);
	for(int i=1;i<=n;i++)p[i]=i,vis[i]=1;
	random_shuffle(p+1,p+n+1);
	for(int i=1;i<=n;i++){
		int u=p[i];
		
		if(vis[u])for(int j=front[u];j;j=e[j].nxt)vis[e[j].to]=0;
	}
	tot2=0;
	for(int i=1;i<=n;i++)if(vis[i])b[++tot2]=i;
	printf("%d ",tot2);
	for(int i=1;i<=tot2;i++)printf("%d%c",b[i]," \n"[i==tot2]);
}
int main(){
	srand(time(NULL));
#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif
	int T=gi();while(T--)solve();
	return 0;
}
```

---


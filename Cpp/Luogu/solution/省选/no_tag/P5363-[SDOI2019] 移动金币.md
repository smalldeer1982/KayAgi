# [SDOI2019] 移动金币

## 题目描述

Alice和Bob将要进行如下的一场游戏。二人轮流操作，且Alice先行。
当轮到一个玩家的时候，他可以选择一枚金币，并将其向左移动任意多格，且至少移动一格。
金币不能被移出棋盘，也不能越过其它金币。

一个 $1\times n$ 的棋盘上最初摆放有 $m$ 枚金币。其中每一枚金币占据了一个独立的格子，任意一个格子内最多只有一枚金币。

如果轮到一个玩家的时候他已经无法做出任何有效操作了（显然这个时候$m$枚金币恰好落在最左侧的$m$个格子中），则被判定为输家。已经知道Alice和Bob都是极致聪明的人，他们在任何局面下总能做出最优的操作。那么有多少初始状态能保证Alice必胜呢？

## 说明/提示

子任务$1$：（$50$分）$1\le n\le 250$且$1\le m\le 50$。

子任务$2$：（$50$分）$1\le n\le 150000$且$1\le m\le 50$。

## 样例 #1

### 输入

```
10 3```

### 输出

```
100```

## 样例 #2

### 输入

```
199 43```

### 输出

```
981535230```

## 样例 #3

### 输入

```
99999 47```

### 输出

```
39178973```

# 题解

## 作者：ywy_c_asm (赞：24)

首先我们会发现最后一枚棋子的移动是与别的棋子有所不同的，移动别的棋子的时候，并没有改变走向最终结束状态的步数，相当于是把它后面一段空格内的一些格子“移动”到了上一段空格内。而如果走最后一个，就相当于把后面一段空格里的格子扔掉了。

咦，这不阶梯博弈吗？

那么我们现在的问题就转化为了，我们要用$m$个棋子把$n$个格子**划分**为可空的$m+1$段，或者换句话说，把$n-m$个格子装入$m+1$个盒子，使得从左开始数第偶数个（因为最右边还有一段空的）盒子的异或和为0（拿总数减去就是答案了）。

这个看起来十分的不可做，但是我们想，异或为0即对于每一位，这一位是1的个数有偶数个。所以，我们可以考虑每个盒子的棋子个数二进制拆分成若干个不同的$2^k$之和，那么我们就按位考虑每一位，对于每一位$k$我们会往偶数个偶盒子里每一个都放$2^k$个格子。

那么就可以dp了，$dp[i][j]$表示放完前i位，还剩$j$个格子没放，那么就有$dp[i][j]=\sum_{k\%2=0}dp[i+1][j-2^ik]C_{q}^k$，其中$q=\lfloor\frac{m+1}2\rfloor$即偶盒子的个数。

那么我们最终把剩下的格子用插板法放到奇盒子里即可。$O(nm\log n)$。~~跑得比我想象的快多了~~

上代码~

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
#define p 1000000009
#define md(_o) (((_o) >= p) ? ((_o)-p) : (_o))
using namespace std;
namespace ywy {
	inline ll mi(int a, int b) {
	    ll ans = 1, tmp = a;
	    while (b) {
	        if (b & 1)
	            ans = (ans * tmp) % p;
	        tmp = (tmp * tmp) % p;
	        b >>= 1;
	    }
	    return (ans);
	}
	ll jc[200001], jcny[200001];
	inline ll cnm(int n, int m) {
	    if (n < m || m < 0)
	        return (0);
	    ll cjr = jc[n];
	    cjr *= jcny[m];
	    cjr %= p;
	    cjr *= jcny[n - m];
	    return (cjr % p);
	}
	inline ll chaban(int n, int m) { 
	    if (n == 0 && m == 0)
	        return (1);
	    return (cnm(n + m - 1, m - 1));
	}
	ll dp[21][150001];
	inline void pre(int n) {
	    jc[0] = 1;
	    for (register int i = 1; i <= n; i++) jc[i] = (jc[i - 1] * i) % p;
	    jcny[n] = mi(jc[n], p - 2);
	    for (register int i = n - 1; i >= 0; i--) jcny[i] = (jcny[i + 1] * (i + 1)) % p;
	}
	void ywymain() {
	    int n, m;
	    cin >> n >> m;
	    if (n < m) {
	        cout << 0 << endl;
	        return;
	    }
	    pre(n + m);
	    int k = 1;
	    while ((1 << k) <= n) k++;
	    dp[k][n - m] = 1;
	    for (register int i = k - 1; i >= 0; i--) {
	        for (register int j = 0; j <= n - m; j++) {
	            if (!dp[i + 1][j])
	                continue;
	            for (register int k = 0; k <= (m + 1) / 2 && k * (1 << i) <= j; k += 2) {
	                dp[i][j - k * (1 << i)] = (dp[i][j - k * (1 << i)] + dp[i + 1][j] * cnm((m + 1) / 2, k)) % p;
	            }
	        }
	    }
	    ll ans = 0;
	    for (register int i = 0; i <= n - m; i++) ans = (ans + dp[0][i] * chaban(i, (m + 2) / 2)) % p;
	    cout << (cnm(n, m) + p - ans) % p << endl;
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：Ebola (赞：20)

我的做法似乎和楼上几位大佬的完全不同，大佬们的做法都可以NTT优化，我的做法就只能过这个题的数据范围了qwq

这题转化成阶梯nim问题是很显然的，移动一枚金币，就是把下一堆石子拿若干个放到前一堆。先手必胜当且仅当编号为奇数的堆石子数异或和非零

### 阶梯nim结论的证明

假设两人都移动奇数堆的石子

对于一个先手必胜局面，先手肯定优先移动奇数堆的若干个石子使得奇数堆石子异或和为$0$从而进入P状态，然后后手萎蛋

如果后手试图打破规则，移动了偶数堆的若干个石子，那先手就把他移了的那些石子再往左移一堆，那么局面不改变，后手仍处于P状态

先手必败局面也是类似的证法

### 普通nim游戏先手必胜方案计数的一种方法（本题解法的前置芝士）

考虑统计先手必败（P状态）的方案数。实际上就是把$n$个石子放入$m$个容器，使得所有容器的石子数异或和为$0$

首先$n$为奇数的情况显然不可能异或和为$0$，所以设$D_k(n)$表示$k$堆石子一共$2n$个的P状态方案数

$2n$个石子且每堆石子都是偶数（以下简称“偶堆”，相应的有“奇堆”）的一个P状态，可以被认为是将$n$堆石子的某个P状态中每堆石子的数量翻倍，这意味着所有P状态与所有仅包含偶堆的P状态存在双射关系

现在考虑石子总数为$4n+2$。设奇堆的数量为$4i+2(\leq k)$，则选择奇堆的方案有$\binom{k}{4i+2}$种。我们可以在所有的奇堆中拿走一个石子，然后把所有堆的石子数减半，利用上述双射关系，对于枚举的一个$i$，就有$\binom{k}{4i+2}D_k(n-i)$种方案

所以，有：

$$D_k(2n+1)=\sum_{i=0}^{\min(n,\left\lfloor\frac{k}{4}\right\rfloor)}\binom{k}{4i+2}D_k(n-i)$$

类似地，有：

$$D_k(2n+2)=D_k(n+1)-\sum_{i=0}^{\min(n,\left\lfloor\frac{k}{4}\right\rfloor)}\binom{k}{4(i+1)}D_k(n-i)$$

利用上述式子，可以$O(nm)$求得答案，最后用总的方案数$\binom{n+m-1}{m-1}$去减一下就得到了N状态方案数

### 本题解法

还是考虑统计P状态数量

首先设$k=\left\lceil\frac{m}{2}\right\rceil$，即编号为奇数的堆数量

考虑有多少石子放入奇数堆（一定要放偶数个），多少石子放入偶数堆。放入偶数堆的可以任意，只要做个插板就行。奇数堆的就用nim游戏计数里的$D_k(n)$。于是得到：

$$cnt(P)=\sum_{i=0}^{\left\lfloor\frac{n}{2}\right\rfloor}D_k(i)\binom{n-2i+(m-k)-1}{(m-k)-1}$$

N状态的数量只要用总的数量$\binom{n+m-1}{m-1}$去减一下就好了

```cpp
#include<bits/stdc++.h>
using namespace std;

const int ha=1000000009;
const int N=150060;
int fac[N],ifac[N],d[N];
int n,m,k;

inline void add(int &x,const int &y){x=(x+y>=ha)?(x+y-ha):(x+y);}

int Pow(int a,int b)
{
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%ha)
        if(b&1) ans=1ll*ans*a%ha;
    return ans;
}

void init(int n)
{
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=1ll*fac[i-1]*i%ha;
    ifac[n]=Pow(fac[n],ha-2);
    for(int i=n-1;i>=0;i--)
        ifac[i]=1ll*ifac[i+1]*(i+1)%ha;
}

int C(int n,int m){return 1ll*fac[n]*ifac[m]%ha*ifac[n-m]%ha;}

int main()
{
    cin>>n>>m;
    init(n);
    n-=m;k=(m+1)/2;
    d[0]=1;
    for(int i=0;i<=n/4;i++)
    {
        for(int j=0;j<=i&&4*j+2<=k;j++)
            d[2*i+1]=(d[2*i+1]+1ll*C(k,4*j+2)*d[i-j])%ha;
        d[2*i+2]=d[i+1];
        for(int j=1;j<=i+1&&4*j<=k;j++)
            d[2*i+2]=(d[2*i+2]+1ll*C(k,4*j)*d[i+1-j])%ha;
    }
    int ans=0,kk=m-k;
    for(int i=0;i<=n;i++)
        if(~i&1) ans=(ans+1ll*d[i/2]*C(n-i+kk,kk))%ha;
    ans=(C(n+m,m)-ans+ha)%ha;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：command_block (赞：15)

**题意** ： 有一条长度为 $n$ 的纸带，上面有 $m$ 个棋子。

每次操作可以将一枚棋子向右移动若干格，但不能跨过其他棋子，棋子不能重叠。

现在有两人轮流操作，不能操作者负。

求在所有的 $\binom{n}{m}$ 种初始状态中，有多少种先手必胜。

答案对 $10^9+9$ 取模。

$n\leq 1.5\times 10^5,m\leq 50$ ，时限$\texttt{1s}$。

------------

首先分析这个游戏先手必胜的充要条件。

将每个棋子后面的空位看作一堆石子，移动棋子时，相当于把自己的石子给了上一个棋子。

不难发现这等价于阶梯 $\rm Nim$ 问题，结论是 ： 若奇数阶梯上石子数的异或和非 $0$ ，则先手必胜。

问题转化成 ： 将 $n-m$ 个石子分成 $m+1$ 堆（最左侧有一堆不属于任何棋子），问有多少种情况使得偶数堆石子异或和非 $0$。

非 $0$ 不太好统计，取个补集变成 $=0$。

考虑 $\rm DP$，设 $f[i][j][k]$ 表示已经分出 $i$ 堆，使用了 $j$ 个棋子，目前偶数堆异或和为 $k$ 的方案数。

转移时枚举下一堆放多少，复杂度为 $O(mn^3)$，无法通过。

我们最终只关心 $k=0$ 的情况，上述方法记录了大量无用状态。

根据位运算的性质，逐位考虑，设 $f[t][i][j][0/1]$ 表示考虑到第 $t$ 位，保证此时偶数堆已确定的前 $t-1$ 位异或和为 $0$ ，正在安排第 $i$ 堆石子的第 $t$ 位，目前该位异或值为 $0/1$，且用了 $j$ 个棋子。

转移显然是 $O(1)$ 的，复杂度为 $O(nm\log n)$。已经可以通过。

然而注意到最终只关心 $j=n-m$ 的情况，于是可以进一步化简 ：

记 $N=n-m$ ，考虑 $N$ 的某一位，有两种来源，一是在某一轮种放置了这样的一位，二是进位而得。

设 $g[t][i][s][0/1]$ 表示已经**从高到低**考虑到了第 $t$ 位，保证此时偶数堆已确定的高位异或和为 $0$ ，正在安排第 $i$ 堆石子的第 $t$ 位，目前该位异或值为 $0/1$，欠下的进位和为 $s$。

看起来似乎和原来的 $f$ 没什么区别，但是能够发现，显然有 $2^t|s$ ，而且，若 $s/2^t>m+1$ 则不可能补完进位。

所以，第三位改为记录 $s/2^t\leq m+1$ ，复杂度改进为 $O(m^2\log n)$。

还可以进一步优化，注意到每一堆的地位是相同的，没必要将堆数写进状态中。于是记 $g[t][s]$ 表示处理完 $t$ 及以上的所有位，欠下的进位和为 $2^ts$ 的方案数。

转移时枚举第 $t$ 位填写的 $1$ 的个数 $k$ ，有

$g[t][2s-k]\leftarrow g[t+1][s]*p(k,m+1)$

其中 $p(k,m)$ 指将 $k$ 个 $1$ 分给 $m$ 堆，满足偶数堆有偶数个 $1$ 的方案数。容易预处理。

不难发现这是个加法卷积，使用 FFT 即可做到 $O(m\log m\log n)$。

代码 ：上述做法暴力卷积， $O(m^2\log n)$

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
using namespace std;
const int mod=1000000009;
ll powM(ll a,int t=mod-2){
  ll ret=1;
  while(t){
    if (t&1)ret=ret*a%mod;
    a=a*a%mod;t>>=1;
  }return ret;
}
ll fac[55],ifac[55],p[55];
ll C(int n,int m)
{return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}
void Init(int n)
{
  fac[0]=1;
  for (int i=1;i<=n;i++)
    fac[i]=fac[i-1]*i%mod;
  ifac[n]=powM(fac[n]);
  for (int i=n;i;i--)
    ifac[i-1]=ifac[i]*i%mod;
  int a=n/2,b=(n+1)/2;
  for (int k=0;k<=n;k++)
    for (int i=0;i<=a;i+=2)
      if (0<=k-i&&k-i<=b)
        p[k]=(p[k]+C(a,i)*C(b,k-i))%mod;
}
ll g[20][55];
int n,m;
int main()
{
  scanf("%d%d",&n,&m);
  Init(m+1);
  g[18][0]=1;
  for (int t=17;t>=0;t--){
    int fl=(((n-m)>>t)&1);
    for (int s=0;s<=m+1;s++)
      for (int k=0;k<=m+1;k++){
        int u=2*s-k+fl;
        if (0<=u&&u<=m+1)
          g[t][u]=(g[t][u]+g[t+1][s]*p[k])%mod;
      }
  }
  ll buf=ifac[m];
  for (int i=1;i<=m;i++)buf=buf*(n-i+1)%mod;
  printf("%lld",(buf+mod-g[0][0])%mod);
  return 0;
}
```

---

## 作者：liuzhangfeiabc (赞：9)

题目大意：1×n的棋盘上有m个棋子，两个人轮流操作，每次可以将一枚棋子向左移动，不能跨过前面的棋子，也不能与其他棋子重叠，不能操作者输。给定n,m，求有多少种局面先手必胜。

说实话看到这个题的我是懵逼的，喵喵喵？这不是原题吗？我团队里还有这个题的说。再仔细一看，喵喵喵？数据范围这么小？原题n<=1e18，m<=8000啊。

印象中sd二轮放原题的画风应该是数据范围+9个0才对啊（比如反回文串），然而这波是什么操作？难道是我的打开方式有问题？难道有什么不为人知的坑？不管了，先写一发再说……然后20分钟就a了……

闲话少说进入正题。

有一个经典的阶梯nim模型：

有n堆石子排成一排，两人轮流操作，每次可以从某一堆石子中取出一些，放进前一堆石子中，不能操作者输，问谁必胜。

结论非常简单：只需忽略掉所有下标为偶数的石子堆(假设下标从0开始)，把所有奇数位置的石子拿出来，当成普通的nim游戏即可。

证明非常简单：如果先手去操作偶数堆的石子，后手可以完全模仿先手的动作，即将先手刚移动的那些石子再往前移动一步。凡是这种“对方可以完全模仿”的操作，在博弈论中我们通常都可以直接忽略掉。

而操作奇数堆的石子，就是将一些石子变成“可以忽略掉”的状态，这与直接拿走等价。

而nim游戏的结论是众所周知的：只需将所有石子的数量xor起来，为0则先手必败，否则先手必胜。

而这个题呢？只需要将两个棋子之间的空格当成石子，每次移动就相当于把一些石子移动到右侧的一堆中。这就是一个从右往左的阶梯nim游戏！

换句话说，我们只需要从右往左把所有奇数位置的空格数量xor起来判断是否为0可。

由此一来我们就能想到一些方法去计数。不妨统计所有先手必败的状态，再用总状态数c(n,m)减去即可。

一个暴力dp的思路是设f(i,j,k)表示从右往左考虑了前i个格子，已经放了j个棋子且最后一个格子一定放棋子，已经形成的空隙的xor是k的方案数。

转移时直接枚举下一个棋子放在哪里即可。

由于常数小，这样就可以获得50分的好成绩了。

如何更进一步？

注意到xor有一个优秀的性质：每一位是独立的。因此我们不妨从高到低逐位考虑每个数该填什么。

我们有m+1个数，要让它们的总和为n-m。

记g(i,j)表示从高到低考虑到了前i位，当前所有数的和是j的方案数。

枚举这一位填多少个1，要求所有奇数位置的空格必须填偶数个1，偶数位置的空格任意。可以预处理出hi表示某一位填i个1的方案数。

这样复杂度是mnlogn，对于这道题来说已经足够了。

当然这题其实还有复杂度更优秀的算法：

其实记录所有数的和这一维也是没必要的，dp时也会发现其中有大量状态是无用的。

我们从进位的角度考虑。

比如考虑n的最高位，这一位显然是1，此时我们考虑所有的数是否有在这一位填1的？如果有，就正常地做下去；否则，这一位的1该从何而来？当然是从下一位进位而来！

于是我们记f(i,j)表示从高到低考虑到第i位，当前还需要向更高位进位j位（也就是所有数后i位的和应该是n的后i位+j×(1<<i)）的方案数。

注意到这个j最大是m，否则后面的位即使填到最大也进不动位了。

转移时枚举下一位填多少个1，同样可以预处理转移系数。

这样复杂度就变成了m^2logn，最后一步用ntt优化(好吧，mtt，毕竟原题和这道题模数都不是ntt模数)即可做到mlogmlogn。

上代码（这里的代码是mnlogn的）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline li read(){
	li x = 0,y = 0,c = gc;
	while(!isdigit(c)) y = c,c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return y == '-' ? -x : x;
}
inline void print(li q){
	if(q < 0) pc('-'),q = -q;
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
int n,m;
const int mo = 1000000009;
inline li ksm(li q,li w){
	li as = 1;
	while(w){
		if(w & 1) as = as * q % mo;
		q = q * q % mo;
		w >>= 1;
	}
	return as;
}
li jc[160010],nj[160010],f[20][160010],tp[100];
inline li c(int q,int w){
	return w < 0 || w > q ? 0 : jc[q] * nj[w] % mo * nj[q - w] % mo;
}
inline li wk(int n,int m){
	register int i,j,k;
	int p1 = m >> 1,p0 = m - p1;
	for(i = 0;i <= m;++i){
		for(j = 0;j <= i;j += 2) (tp[i] += c(p1,j) * c(p0,i - j)) %= mo;
	}
	f[18][0] = 1;
	for(i = 18;i;--i){
		for(j = 0;j <= n;++j) if(f[i][j]){
			for(k = 0;k <= m && (j + k * (1 << i - 1) <= n);++k) (f[i - 1][j + k * (1 << i - 1)] += f[i][j] * tp[k]) %= mo;
		}
	}
	return f[0][n];
}
int main(){
	int i;
	n = read();m = read();
	if(n <= m){
		pc('0');pc('\n');return 0;
	}
	jc[0] = 1;for(i = 1;i <= n + m;++i) jc[i] = jc[i - 1] * i % mo;
	nj[n + m] = ksm(jc[n + m],mo - 2);
	for(i = n + m - 1;i >= 0;--i) nj[i] = nj[i + 1] * (i + 1) % mo;
	print((c(n,m) - wk(n - m,m + 1) + mo) % mo);
	return 0;
}
```

---

## 作者：zhylj (赞：7)

[广告](http://zhylj.cc/2020/08/20/64/#more)

---

### Solution

注意到金币的相对位置（顺序）不变，考虑进行差分，然后全部减 $1$，得到数组 $b_i$（不妨令 $b_{m+1}$ 为 $n$ 与最后一个金币位置的差分），相当于在进行这样的操作：找到一个 $i\le m$，选择一个数 $k$，令 $b_i\leftarrow b_i - k$，$b_{i+1}\leftarrow b_{i+1}+k$。

这就变成了阶梯博弈，结论是该博弈等价于奇数位置（从右往左数，最右边的位置记为 $0$）上的 Nim 游戏，证明如下：

- 只有偶数位置存在数字时，先手必败。先手只能把偶数位置移到奇数位置，后手只要把奇数位置再移到偶数位置即可。而显然终态属于这种状态，故先手必败。
- 容易发现，奇数位置上的情况相当于允许一些添加石子的 Nim 游戏，显然和普通 Nim 游戏无异。

可行局面相当于求有多少种 $b$ 数组，使得 $b$ 数组奇数位置上的异或和不为 $0$，且 $\sum (b_i + 1) = n$（原本应该是小于等于，但是我们加了个 $b_{m+1}$，就是恰等于了）即 $\sum b_i = n - m$.

当然，异或和不为 $0$ 并不好做，于是容斥（显然，局面的总数是 $n+m\choose m$ 的）后 dp，由于奇数位置和偶数位置互不影响，所以只需做普通 Nim 游戏的局面计数然后合并答案即可，设 $f(i,j)$ 表示考虑了前 $i-1$ 位，$b$ 的和为 $j$ 的异或和为 $0$ 的情况数。

枚举新一位 $1$ 的个数 $k$ 转移，则 $f(i,j)$（再乘上一个选择那些数加上这个 $1$ 的组合数）可以转移到 $f(i+1,j+2^k)$ ，条件是 $2|k$ 且 $j+2^k\le n$.

时间复杂度 $\mathcal O(nm\log n)$，由于自带一些 $0.5$ 的常数，所以跑的飞快。

### Code

```cpp
const int kN = 2e5 + 5, kB = 20;
const ll kMod = 1e9 + 9;

ll QPow(ll a, ll b) {
	ll ans = 1, bas = a;
	for(; b; b >>= 1, bas = bas * bas % kMod) if(b & 1) ans = ans * bas % kMod;
	return ans;
}

ll fac[kN], fac_inv[kN];
ll C(int x, int y) { return fac[x] * fac_inv[y] % kMod * fac_inv[x - y] % kMod; }

void Incr(ll &x, ll y) { x = (x + y) % kMod; }

int n, m; ll f[kB][kN], ans;

int main() { 
	rd(n, m);
	fac[0] = 1;
	for(int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % kMod;
	fac_inv[n] = QPow(fac[n], kMod - 2);
	for(int i = n - 1; ~i; --i) fac_inv[i] = fac_inv[i + 1] * (i + 1) % kMod;
	n -= m;
	int b;
	f[0][0] = 1;
	for(b = 0; n >> b; ++b) {
		for(int j = 0; j <= n; j += 2)
			for(int k = 0; k <= (m + 1) / 2; k += 2)
				if(j + (k << b) <= n) {
					Incr(f[b + 1][j + (k << b)], f[b][j] * C((m + 1) / 2, k) % kMod);
				}
	}
	for(int i = 0; i <= n; i += 2)
		Incr(ans, f[b][i] * C(n - i + m / 2, m / 2) % kMod);
	ans = (C(n + m, m) - ans + kMod) % kMod;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：5)

首先这显然是个阶梯 Nim 博弈的变种，阶梯上的硬币数以直接看成两个金币之间的空位。

于是考虑定义 $dp_{i,j,k}$ 为在第 $i$ 个格子放下第 $j$ 个棋子，构成的间隙 $ \operatorname{xor} $ 和为 $k$ 的方案数。转移显然。时间复杂度 $O(n^3m)$，好难受。

考虑 $\operatorname{xor}$ 和的性质，发现如果 $\operatorname{xor}$ 和为 $0$，那么分成的格子的二进制拆分下，每一位出现的次数都为偶数次。证明显然。

于是不在 $n$ 个格子上面 dp，跑到 $\operatorname{xor}$ 和上去 dp。那么定义 $dp_{i,j}$ 为现在已经进行完了二进制上的第 $i$ 位，空余的格子还有 $j$ 个（指没有被指定为空格子或者棋子）。

那么转移方程：
$$
\large dp_{i,j} = \sum_{2|k} dp_{i+1,j-k \times 2^i} \normalsize \dbinom{\lfloor \dfrac{m+1}{2} \rfloor}{k}
$$
剩下的格子可以直接插板法插到奇阶梯的空隙里面，可以组合数随便算算。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=1e9+9;
LL dp[21][150005],fac[300005],inv[300005];
LL QuickPow(LL x,LL p)
{
	LL base=x,ans=1;
	while(p)
	{
		if(p&1)	ans*=base,ans%=MOD;
		p>>=1;
		base*=base;
		base%=MOD;
	}
	return ans;
}
LL C(LL n,LL m){return fac[n]*inv[m]%MOD*inv[n-m]%MOD;}
LL n,m;
int main(){
	scanf("%lld %lld",&n,&m);
	n-=m;
	if(n<=0)	return puts("0")&0;
	fac[0]=fac[1]=1;
	for(LL i=2;i<=300000;++i)	fac[i]=fac[i-1]*i%MOD;
	inv[300000]=QuickPow(fac[300000],MOD-2);
	for(LL i=300000-1;~i;--i)	inv[i]=inv[i+1]*(i+1)%MOD;
	LL upper=1;
	while((1<<upper)<=n)	++upper;
	dp[upper][n]=1;
	for(LL i=upper-1;~i;--i)
	{
		for(LL j=0;j<=n;++j)
		{
			if(!dp[i+1][j])	continue;
			for(LL k=0;k<=(m+1)>>1 && k*(1<<i)<=j;k+=2)
			{
				dp[i][j-k*(1<<i)]+=dp[i+1][j]*C((m+1)>>1,k)%MOD;
				dp[i][j-k*(1<<i)]%=MOD;
			}
		}
	}
	LL ans=0;
	for(LL i=0;i<=n;++i)	ans+=dp[0][i]*(C(i+(m+1-(m+1)/2)-1,(m+1-(m+1)/2)-1))%MOD,ans%=MOD;
	printf("%lld",(C(n+m,m)-ans+MOD)%MOD);
	return 0;
}
```

---

## 作者：creed_ (赞：5)

本来可能还能买D的，结果这道题数组开小退役了qwq

这道题可能是SDOI2019二轮除了D1T1外最简单的题。

首先可以发现题面给的那个游戏，

如果把每一对相邻的金币之间的间距看做一堆石子，间距大小看做石子的个数。


那么题意就转化成了一个经典的阶梯nim游戏。

阶梯nim有一个结论：

先手必胜当且仅当所有奇数堆的石子异或起来不为0。

证明：

大概就是考虑如果当前先手选择了一堆偶数石子进行操作，

那么后手可以立刻把这堆石子移动到下一个偶数堆，使得对

奇数堆不产生影响。因此只需考虑奇数堆的SG值即可。



有了这个结论以后，我们可以立刻得到一个暴力的做法。

dp[i][j][k]表示当前放了i堆石子，总共用了j个石子，当前所有奇数堆石子异或和为k的方案数。

转移的时候枚举下一堆放多少个，复杂度O(m*n^3)

这样就可以得到50分的好成绩。

考虑满分怎么做。

首先容斥一下，考虑计算异或和为0的方案数。

异或和为0的话有一个很好的性质，即要求每一个二进制位单独考虑的话都是异或起来等于0。

也就是说，如果把所有奇数堆的石子个数都二进制分解掉。

那么对于每一位来说，相应的个数要求是偶数，

这样才能满足异或起来等于0。

考虑把每一位的生成函数写出来。

设奇数盘子个数为s，当前枚举到的二进制位为p=2^k。

$F(x)=\sum_{2|i}C(s,i)\times x^{i\times p}$

我们要做的就是把这logn个生成函数乘起来。



考虑完奇数堆后，还需要考虑偶数堆以及最后一个的金币右边留多少空。

我们再把偶数堆的生成函数写出来

$G(x)=\sum_{i}P(i,m-s)\times x^{i}$

其中P（n,m）指的是插板法计数，

也就是n个无标号石子放到m个有标号盘子的方案数。

最后先把奇数堆的生成函数和偶数堆的生成函数乘起来。

再去枚举一下给最后一个金币右边留多少空就做完了。


但是，你发现题目所给的模数十分的不适合跑多项式。

~~然后我试图三模数NTT爆过去~~

考虑怎么避免写NTT。

我们注意到奇数堆部分每一位的生成函数的项数都不超过25！（因为奇数盘子最多只有25个。）

我们可以暴力卷积！

注意，这里卷积的数组要开到n✖25级别！

每次的复杂度都是n✖25，做logn次，而且这个复杂度上界非常非常的松。

然后再考虑奇数堆和偶数堆做卷积的部分。

我们发现我们并不关心它们卷积后的每一项是多少，而是只关心

它们做卷积后所有次数<=n-m的项的和！

（因为只有石子个数<=n-m才能腾出金币占用的位置，再把多出来的的扔到最后面去！）

这个显然可以直接前缀和掉，然后就做完了。

~~然而数组开小让这一切都没有意义了~~

下面是数组开小的考场代码

```cpp
#include<bits/stdc++.h>
#define N 550000
#define L 400000
#define eps 1e-7
#define inf 1e9+7
#define db double
#define ll long long
#define ldb long double
using namespace std;
inline int read()
{
    char ch=0;
    int x=0,flag=1;
    while(!isdigit(ch)){ch=getchar();if(ch=='-')flag=-1;}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*flag;
}
const int mo=1e9+9;
int ksm(int x,int k)
{
    int ans=1;
    while(k){if(k&1)ans=1ll*ans*x%mo;k>>=1;x=1ll*x*x%mo;}
    return ans;
}
int inv(int x){x=(x%mo+mo)%mo;return ksm(x,mo-2);}
int fac[N],vac[N];
int C(int n,int m)
{
    if(n<m)return 0;
    return 1ll*fac[n]*vac[m]%mo*vac[n-m]%mo;
}
int P(int n,int m){return C(n+m-1,m-1);}
int n,m,t,dp[N];
bool check()
{
    if(n<m){printf("0");return true;}
    if(m==1){printf("%d",n-1);return true;}
    return false;
}
struct node{int x,k;}a[N],b[N],c[N];
node operator*(node a,node b){return (node){1ll*a.x*b.x%mo,a.k+b.k};}
bool cmp(node a,node b){return a.k<b.k;}
int mul(int len1,int len2)
{
    int cnt=0,tot=0;
    for(int i=1;i<=len1;i++)for(int j=1;j<=len2;j++)
    if(a[i].k+b[j].k<=n)c[++cnt]=a[i]*b[j];

    sort(c+1,c+cnt+1,cmp);
    for(int i=1;i<=cnt;i++)
    {
        if(i!=cnt&&c[i].k==c[i+1].k){c[i+1].x=(c[i+1].x+c[i].x)%mo;continue;}           
        else a[++tot]=c[i];
    }
    return tot;
}
int main()
{
    n=read();m=read();t=(m+1)/2;if(check())return 0;
    fac[0]=1;for(int i=1;i<=L;i++)fac[i]=1ll*fac[i-1]*i%mo;
    vac[L]=inv(fac[L]);for(int i=L;i>=1;i--)vac[i-1]=1ll*vac[i]*i%mo;
    int len=1;a[1]=(node){1,0};
    for(int k=1;k<=n;k<<=1)
    {
        int cnt=0;
        for(int i=0;i<=t;i+=2)if(i*k<=n)b[++cnt]=(node){C(t,i),i*k};
        len=mul(len,cnt);
    }
    int ans=0;
    for(int i=0;i<=n;i++)dp[i]=P(i,m-t);
    for(int i=1;i<=n;i++)dp[i]=(dp[i-1]+dp[i])%mo;

    for(int i=0;i<=len;i++)if(a[i].k<=n-m)
    ans=(ans+(1ll*a[i].x*dp[n-m-a[i].k]%mo))%mo;
    ans=(C(n,m)-ans)%mo;
    printf("%d",(ans%mo+mo)%mo);
    return 0;
}
```


---

## 作者：cirnovsky (赞：1)

对 @command_block 没有 implementation 做法的细化。理论来说可以通过，但因为我实现得较劣无法通过。：(

把金币中的空隙看作石子，就是一个阶梯 Nim 的模型（有总共 $n-m$ 个石子，$m+1$ 个石堆，其中最左边有一个独立的石堆）。于是问题转化为满足偶数编号的石堆石子数异或和非零的初始方案数。

取补集后可以给出这样一个 DP：令 $f(k,i,j,v\in\{0,1\})$ 表示考虑第 $k$ 个二进制位，决策好了 $i$ 个石堆，恰好 $j$ 个石子被分配，当前填 $0$ / $1$ 的方案数。

转移，考虑根据 $k$ 来分层，然后每个层独立地转移，最后来合并。具体来说，$f(k,i,j,v)\rightarrow f(k,i+1,j,v)$，并且 $f(k,i,j,v)\rightarrow f(k,i+1,j+2^k,v\oplus[i+1\equiv0\pmod2])$，即考虑填 $0$ 还是 $1$。令第 $k$ 层合并后的结果为 $s(k,i,j,v)$，最后的答案即 $\binom{n}{m}-s(\lfloor\log_2a_i\rfloor,m+1,n-m,0)$。合并的过程是 $s(k,m+1,j,0)=\sum\limits_i f(k,m+1,i,0)\times s(k-1,m+1,j,0)$。

边界即 $f(k,0,0,0)=1,s(0,m+1,j,0)=f(0,m+1,j,0)$。

时间复杂度 $\Theta(nm\log_2n)$。[这是一份比较朴素的实现方法，可以帮助理解，并不能通过此题。](https://paste.ubuntu.com/p/W5fWTvqh7Q/)

然后你会发现可能由于内存访问不连续等原因，朴素的实现并不能通过此题较大的数据。

考虑交换数组顺序，利用分奇偶讨论转移的特殊性来乘一个 $\frac{1}{2}$ 的常数等方法卡常，有效，但不完全有效。

但是确实过不去，希望哪天来个卡常大师给卡进去。（

---

## 作者：MeowScore (赞：0)

[link](https://www.luogu.com.cn/problem/P5363)

感觉是一道好题，综合了博弈和计数的技巧，值得一做。

首先不难发现这是一个阶梯博弈的模型，把一枚金币向左移动，相当于把这枚金币和它左边的金币的距离减小，同时它和右边的金币增加等量的距离（这就是阶梯博弈把一个台阶上的一部分石子拿到低一级台阶的过程）。特殊地，最右边一枚金币向左移动相当于把它左侧的一段距离放到右边，拿走的这一些距离也再也无法转移（阶梯博弈中把最低一级台阶的部分石子拿到 $0$ 位置的过程）。

问题转化成把 $n-m$ 个石子放到 $m+1$ 个台阶（$0$ 开始编号）上，求有多少种初始局面使得奇数台阶的石子异或和非 $0$。

这个 $n-m$ 是因为 $n$ 个位置放入 $m$ 枚金币后还剩下 $n-m$ 个位置是我们可以分配的“石子”。$m+1$ 是因为 $m$ 枚金币把棋盘切割成了 $m+1$ 段，每一段都是一个台阶。

求解异或非 $0$ 的方案不好做，我们考虑容斥，求出异或为 $0$ 的方案数，再拿总数去减即可，总方案数为 $C_{n}^m$。容斥的好处是什么？异或和为 $0$，则对于每个二进制位，异或和都是 $0$，也就是有偶数个台阶在这一二进制位上是 $1$。

设计一个计数 dp，$f_{i,j}$ 表示考虑完前 $i$ 个二进制位，用掉了 $j$ 颗石子，合法的方案数量。我们枚举 $i$，$j$，$k$。$k$ 代表这些台阶中有 $k$ 个台阶的第 $i$ 个二进制位为 $1$，得到转移：

$$
f_{i,j}=\sum_{k\bmod 2=0}^{k\leq a,k\times 2^i\leq j} f_{i-1,(j-k\times 2^i)\times C_a^k}
$$

注：这个式子中二进制位是从 $0$ 开始编号，但是实现的时候防止越界就从 $1$ 开始编。

其中 $a$ 代表奇数编号阶梯的个数，这个直接根据 $n$ 和 $m$ 算出来。

接下来统计所有异或和为 $0$ 的方案，枚举做完所有二进制位用掉的石子个数，剩下的随便丢到偶数编号台阶上，插板就好了（注意这个插板是可以选出空集合的）。

然后容斥一下就做完了。

代码：

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=200010,mod=1000000009;
int f[20][N],n,m;
int a,b;
int ksm(int x,int y){
	int res=1;
	while(y){
		if(y&1)
			res=res*x%mod;
		x=x*x%mod;
		y/=2;
	}
	return res;
}
int jc[N],inv[N];
int C(int n,int m){
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
signed main(){
	cin>>n>>m;
	if(n<m){
		cout<<0;
		return 0;
	}
	jc[0]=inv[0]=1;
	for(int i=1;i<=n;i++){
		jc[i]=(jc[i-1]*i)%mod;
		inv[i]=ksm(jc[i],mod-2);
	}
	n-=m;
	a=(m+1)/2;
	b=m+1-a;
	f[0][0]=1;//未处理任何二进制位，也没有用掉任何石子，方案数为 1
	int bit=log(n)/log(2)+2;
	for(int i=1;i<=bit;i++)
		for(int j=0;j<=n;j++)
			for(int k=0;k<=a&&k*(1<<(i-1))<=j;k+=2)
				f[i][j]=(f[i][j]+f[i-1][j-k*(1<<(i-1))]*C(a,k))%mod;
	int ans=0;
	for(int i=0;i<=n;i++)
		ans=(ans+f[bit][i]*C(n-i+b-1,b-1))%mod;//插板
	cout<<(C(n+m,m)-ans+mod)%mod;
	return 0;
}
```

---

## 作者：tylon2006 (赞：0)

定义两个相邻棋子（或棋子与边界）之间的空格子连续段（可能为空）为空格段。

考虑一下左移棋子改变了什么，实际上是将该棋子左边的空格段的空格转移给了与右边的空格段。这个转移只能在相邻的空格段之间发生，于是这就是一个阶梯博弈。

将空格段从右往左标号为 0,1,2,...,m。即求有多少种初始情况满足标号为奇数的空格段长度异或和不为 0。

考虑反面，求异或和为 0 的初始情况数。

一个无脑的想法是直接对于每个奇数标号做背包，由于还需要一维记录异或和，这样是 $O(n^2m)$ 的。

考虑对于长度拆二进制位。异或和要为 0，必然对于每一位，该位为 1 的长度的个数为偶数。

那么我们可以枚举每一位的个数做背包，使用组合数转移。最后对于每个背包状态将剩下的格子分给偶数位，求和即可。

这样就是 $O(nm\log n)$ 的。实际上带一个 $0.5$ 的常数于是跑得很快。

当然这玩意是背包，可以直接卷积，$O(n \log(n+m)\log n)$。因为 FFT 有巨大常数，说不定会更慢。

---

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=150010;
const int mod=1e9+9;
int ifac[maxn];
int fac[maxn];
int f[maxn];
int g[maxn];
int n,m,ans;
int fpow(int x,int y){
	int sum=1,bas=x;
	while(y){
		if(y&1) sum=sum*1ll*bas%mod;
		bas=bas*1ll*bas%mod;
		y>>=1;
	}
	return sum;
}
void init(){
	fac[0]=1;
	for(int i=1;i<=maxn;++i)
	fac[i]=fac[i-1]*1ll*i%mod;
	ifac[maxn]=fpow(fac[maxn],mod-2);
	for(int i=maxn;i;--i)
	ifac[i-1]=ifac[i]*1ll*i%mod;
}
int C(int x,int y){
	if(x<y) return 0;
	return fac[x]*1ll*ifac[y]%mod*ifac[x-y]%mod;
}
int add(int x,int y){
	return x+y>=mod?x+y-mod:x+y;
}
int main(){
	init(),g[0]=1;
	scanf("%d%d",&n,&m);
	int cnt=(m+1)>>1;
	for(int i=0;i<=17;++i){
		int s=1<<i;
		if(s>n-m) break;
		for(int j=0;j<=cnt&&j*s<=n-m;j+=2)
		for(int k=0;k+j*s<=n-m;++k)
		f[k+j*s]=add(f[k+j*s],g[k]*1ll*C(cnt,j)%mod);
		memcpy(g,f,sizeof(g));
		memset(f,0,sizeof(f));
	}
	for(int i=0;i<=n-m;++i)
	ans=add(ans,g[i]*1ll*C(n-i-cnt,m-cnt)%mod);
	printf("%d",add(C(n,m),mod-ans)); 
}
```

---

## 作者：NusGhy (赞：0)

第一步转化为阶梯 nim 其他题解讲得很清楚了，这边提供一个新的 dp 方式。  
  
设 $f_i$ 表示 $i$ 拆分为 $k$ 个数（$k$ 为奇数格子个数）且异或和不为零有几种方法。  
  
当 $i$ 为奇数时，它的拆分里二进制最低位必定有奇数个一，所以可以保证异或和至少为一，所以直接插板法即可。  
  
当 $i$ 为偶数时，考虑枚举它的拆分中最低位有几个一，由于最低位异或和必为零，所以只需要看去掉最低位之后的数异或和是否为零。  
  
  这个可以通过之前求得的数转移来，再乘上向最低位加一的方案数即可。  
  
具体方程看代码：  
  
```cpp 
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 200005;
const int maxk = 102;
const int p = 1000000009;

int n, k, k1, k2, ans;
int c[maxn][maxk];
int dp[maxn];

int main()
{
	cin>>n>>k;
	c[0][0] = 1;
	for(int i = 1; i <= n + k; i ++)
	{
		c[i][0] = 1;
		for(int j = 1; j <= k; j ++)
			c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % p;
	}
	dp[0] = 0;
	k1 = floor(1.0 * (k + 1) / 2), k2 = ceil(1.0 * (k + 1) / 2);
	n -= k;
	for(int i = 1; i <= n; i ++)
	{
		if(i % 2 == 1)
			dp[i] = c[i + k1 - 1][k1 - 1];
		else
			for(int j = 0; j <= min(k1, i); j += 2)
				dp[i] = (dp[i] + 1ll * dp[(i - j) / 2] * c[k1][j] % p) % p;
		ans = (ans + 1ll * dp[i] * c[n - i + k2 - 1][k2 - 1] % p) % p;
	}
	cout<<ans<<endl;
}
```


---


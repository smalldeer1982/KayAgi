# [PKUSC2018] 最大前缀和

## 题目描述

小 C 是一个算法竞赛爱好者，有一天小 C 遇到了一个非常难的问题：求一个序列的最大子段和。

但是小 C 并不会做这个题，于是小 C 决定把序列随机打乱，然后取序列的最大前缀和作为答案。

小 C 是一个非常有自知之明的人，他知道自己的算法完全不对，所以并不关心正确率，他只关心求出的解的期望值，现在请你帮他解决这个问题，由于答案可能非常复杂，所以你只需要输出答案乘上 $n!$ 后对 $998244353$ 取模的值，显然这是个整数。

注：最大前缀和的定义：$\forall i \in [1,n]$，$\sum_{j=1}^{i}a_j$的最大值。


## 说明/提示

对于$10\%$的数据，有$1\leq n\leq 9$。

对于$40\%$的数据，有$1\leq n\leq 15$。

另有$10\%$的数据，满足$a$中最多只有一个负数。

另有$10\%$的数据，满足$|a[i]|\leq 2$。

对于$100\%$的数据，满足$1\leq n\leq 20$，$\sum_{i=1}^{n}|a[i]|\leq 10^9$。


## 样例 #1

### 输入

```
2
-1 2```

### 输出

```
3```

# 题解

## 作者：w4p3r (赞：120)

## 一丶前言
为了方便，定义/说明一些东西：

若存在多个$p$使得$\sum_{i=1}^{p}{a_i}$最大，默认最**大**的一个$p$是它的最大前缀和。

$U$表示全集

真后缀的含义即为除了整体以外的后缀
## 二丶思路
题目大意很清楚了吧，就是求$n$个数所有排列的最大前缀和之和，答案对$998244353$取模。

既然要求最大前缀和，我们先看看最大前缀和有些什么性质，假设$\sum_{i=1}^{p}a_i$是最大前缀和，那么：

1. 不存在$x(1<x<=p)$，使得$\sum_{i=x}^{p}a_i<0$，即没有任何一段**真**后缀和$<0$（不然我们把这一段舍去答案就更大了）

2. 不存在$x(p<x<=n)$，使得$\sum_{i=p+1}^{x}a_i>=0$，即没有任何一段前缀和$>=0$（否则我们把这一段加上之后更优）

显然条件$1$只跟前$p$个数有关，条件2只跟后$n-p$个数有关，因此我们考虑分开$DP$：

假设$f[S]$是集合$S$为最大前缀和时，集合$S$的排列满足条件$1$的方案。

$g[U$^$S]$是集合$S$为最大前缀和时，集合$U-S$的排列满足条件$2$的方案数。

并假设$sum[S]=\sum_{i\in S}a_i$

所以$ans=\sum_{S\subset U}sum[S]*f[S]*g[U-S]$，问题就在于如何求$f$和$g$了

我们假设$f$是从后面往前面加数，$g$是从前面往后面加数（注意理解这句话），那么$g$的$DP$方程就很简单了：

$g[S|u]+=g[S](sum[S|u]<0)$ （因为我们是从前往后加数，加完一个数之后我们只用判断当前前缀的和是否$<0$就行了）

以此类推，$f$的$DP$方程貌似也很类似，就是：

$f[S|u]+=f[S](sum[S|u]>=0)$

但是这样只能拿到$55$分，为什么呢？因为我们说的是没有任何一段**真后缀**和 $<0$，而不是后缀，所以这样会漏掉一部分。

那我们稍稍改一改就行了，我的方法是假设一个$f[S][0/1]$：

$f[S][0]$表示$sum[S]<0$，但它的任何真后缀的和都$>=0$的方案数。

$f[S][1]$则是$sum[S]>=0$的情况，且它的任何真后缀都$>=0$的方案数。

$DP$方程也稍稍改改就好了：

$f[S|u][0]+=f[S][1](sum[S|u]<0)$

$f[S|u][1]+=f[S][1](sum[S|u]>=0)$

则$ans=\sum_{S \subset U}(f[S][0]+f[S][1])* sum[S]*g[U$^$S]$

## 三丶代码
```cpp
#include<bits/stdc++.h>
#define inf 1e9
#define eps 1e-6
#define N 21
#define mod 998244353
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
inline ll Z(ll x){return x>=mod?x-mod:x;}
ll sum[1<<N];ll f[1<<N][2],g[1<<N];
ll n,a[N];
int main()
{
	n=read();
	for(register ll i=1;i<=n;i++)a[i]=read();
	for(register ll i=0;i<(1<<n);i++)
	{
		for(register ll j=1;j<=n;j++)
		{
			if(i&(1<<(j-1)))sum[i]=sum[i]+a[j];
		}
	}
	for(register ll i=1;i<=n;i++)if(a[i]<0)f[1<<(i-1)][0]=1;else f[1<<(i-1)][1]=1;//初始化
	for(register ll i=1;i<(1<<n);i++)
	{
		ll S=i;
		for(register ll j=1;j<=n;j++)
		{
			if(S&(1<<(j-1)))continue;
			ll T=S|(1<<(j-1));
			if(sum[T]>=0)f[T][1]=Z(f[T][1]+f[S][1]);
			else f[T][0]=Z(f[T][0]+f[S][1]);
		}
	}
	g[0]=1;
	for(register ll i=0;i<(1<<n);i++)
	{
		ll S=i;if(!g[S])continue;
		for(register ll j=1;j<=n;j++)
		{
			if(S&(1<<(j-1)))continue;
			ll T=S|(1<<(j-1));
			if(sum[T]<0)g[T]=Z(g[T]+g[S]);
		}
	}
	
	ll U=(1<<n)-1,ans=0;
	for(register ll i=1;i<=U;i++)
	{
		ans=Z(ans+Z(sum[i]%mod+mod)*Z(f[i][0]+f[i][1])%mod*g[U^i]%mod);
	}
	printf("%lld\n",ans);
	return 0;
}
/*
3
0 1 -2
*/

```

**如果认为我这篇题解对你有帮助的可以给我点一下赞qwq。如果有任何疑问，或者认为我的题解有什么问题的话，请务必私信我，感激不尽！我会努力把我的题解写得最好的!**

---

## 作者：s_r_f (赞：49)

状压$DP$.

令$sum[i] = $ 集合 $i$ 内所有数的和。

令$f[i] = $ 集合 $i$ 内的数组成的排列，最大前缀和 $ = sum[i]$ 的方案数。

令$g[i] = $ 集合 $i$ 内的数组成的排列，所有的最大前缀和都 $ < 0$ 的方案数。

显然$ans = \Sigma sum[i] * f[i] * g[ALL-i]$,其中$ALL$表示全集。

实际上这个统计答案的方法可以这样理解：

**枚举最大前缀和的集合$S$组成的排列作为前半部分，**

**让其它数组成排列的后半部分，**

**前后拼接之后的序列的最大前缀和$ = $前半部分的最大前缀和， 也就是要让序列的后半部分所有的最大前缀和 $ < 0$**

##

那么，怎么$DP$ $f[i]$ 和 $g[i]$呢？

$g[i]$比较好考虑：

当$sum[i] >= 0$时,$g[i] = 0.$

当$sum[i] < 0$时,$g[i] =\Sigma g[i-j](j ∈ i)$

$f[i]$不太好直接$DP$.

考虑刷表，在集合$i$的排列**前**加入一个数$j(j∉i)$,

如果$sum[i] > 0$,那么$f[i+j] += f[i].$

否则,$f[i]$不能对$f[i+j]$产生任何贡献。

##

$DPf[i],g[i]$时枚举$i,j$都是$O(2^n)$的。

空间复杂度$O(2^n)$,时间复杂度$O(n2^n).$

代码:

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline LL read(){
    LL x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(LL x){
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
inline void writeln(LL x){ write(x),putchar('\n'); }
const int P = 998244353,N = 20 + 5,L = 1<<20;
inline int add(int x,int y){ return (x+=y)>=P?x-P:x; }
inline int mul(LL x,int y){ return x*y-x*y/P*P; }
int n,l,f[L],g[L],ans; LL sum[L];
int main(){
	int i,j;
	n = read(),l = 1<<n;
	for (i = 0; i < n; ++i) sum[1<<i] = read(),f[1<<i] = 1;
	for (i = 1; i < l; ++i) sum[i] = sum[i^(i&-i)] + sum[i&-i];
	for (g[0] = i = 1; i < l; ++i) if (sum[i] >= 0)
		{ for (j = 0; j < n; ++j) if (!(i>>j&1)) f[i|(1<<j)] = add(f[i|(1<<j)],f[i]); }
		else{ for (j = 0; j < n; ++j) if (i>>j&1) g[i] = add(g[i],g[i^(1<<j)]); }
	for (i = 1; i < l; ++i) ans = add(ans,mul(mul(sum[i]%P,f[i]),g[(l-1)^i])),ans = (ans % P + P) % P;
	writeln(ans);
	return 0;
}
```

---

## 作者：mrsrz (赞：16)

这里给出一种推得比较菜的方法，需要用到FWT来子集卷积。

首先定义$\oplus$为异或运算，$|S|$表示```__builtin_popcount(S)```。

状压DP。设$f_S$表示集合$S$有多少种排列方案，满足其最大前缀和恰好用到所有数（之前不能有和它相等的前缀和），$g _S$表示集合$S$有多少种排列方案，满足其所有前缀均小于等于$0$，$sum_S$表示集合$S$的元素和。

$g$非常容易求，$g_S=[sum_S\leqslant 0]\times \sum_{(2^i)\& S=2^i}g_{S-2^i}$。这部分复杂度为$O(2^nn)$。边界$g_0=1,g_{2^i}=[a_i\leqslant 0]$。

如何求$f$？考虑总数减去最大前缀和没用到所有数的方案数。

那么有$f_S=|S|!-\sum_{T\&S=T}f_T\times g_{S\oplus T}$。

这部分需要枚举子集，时间复杂度$O(3^n)$。

发现后面的求和是一个子集卷积的形式，于是可以用FWT将其优化到$O(2^nn^2)$。

最后的答案为$\sum_{i=1}^{2^n-1}f_ig_{2^n-i-1}$。

~~最慢无疑了~~

## Code：
```cpp
#include<cstdio>
#include<vector>
const int N=1<<20|1,md=998244353;
typedef long long LL;
inline void upd(int&a){a+=a>>31&md;}
int a[21],n,sum[N],ff[N],f[21][N],fc[N],lim,gg[21][N];
std::vector<int>vc[21];
inline void fwt(int*a){
	for(int i=1;i<lim;i<<=1)
	for(int j=0;j<lim;j+=i<<1)
	for(int k=0;k<i;++k)
	upd(a[j+k+i]+=a[j+k]-md);
}
inline void ifwt(int*a){
	for(int i=1;i<lim;i<<=1)
	for(int j=0;j<lim;j+=i<<1)
	for(int k=0;k<i;++k)
	upd(a[j+k+i]-=a[j+k]);
}
int main(){
	scanf("%d",&n);
	for(int i=*fc=1;i<=n;++i)fc[i]=(LL)fc[i-1]*i%md;
	for(int i=0;i<n;++i)scanf("%d",a+i);
	 lim=1<<n;
	for(int i=1;i<lim;++i){
		vc[__builtin_popcount(i)].push_back(i);
		for(int j=0;j<n;++j)sum[i]+=(i>>j&1)*a[j];
	}
	ff[0]=1;
	for(int i=0;i<n;++i)ff[1<<i]=a[i]<=0;
	for(int ct=1;ct<n;++ct)
	for(int S:vc[ct])
	if(sum[S]<=0)
	for(int i=0;i<n;++i)
	if(!(S>>i&1)&&sum[S|(1<<i)]<=0)upd(ff[S|(1<<i)]+=ff[S]-md);
	for(int i=0;i<lim;++i)gg[__builtin_popcount(i)][i]=ff[i];
	for(int i=0;i<=n;++i)fwt(gg[i]);
	for(int i=0;i<n;++i)f[1][1<<i]=1;fwt(f[1]);
	for(int ct=2;ct<=n;++ct){
		for(int i=1;i<ct;++i)
		for(int S=0;S<lim;++S)f[ct][S]=(f[ct][S]+(LL)f[i][S]*gg[ct-i][S])%md;
		ifwt(f[ct]);
		for(int S:vc[ct])upd(f[ct][S]=fc[ct]-f[ct][S]);
		fwt(f[ct]);
	}
	for(int i=1;i<=n;++i)ifwt(f[i]);
	int ans=0;
	--lim;
	for(int i=1;i<=lim;++i)
	ans=(ans+(LL)sum[i]*f[__builtin_popcount(i)][i]%md*ff[lim^i]%md+md)%md;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：lory1608 (赞：13)

一道比较简单的状压DP。

首先我们考虑什么情况下一个排列的前缀 $[1,i]$ 会成为答案，当且仅当：

1. 对于所有以 $i$ 结尾的后缀 $[j,i](j\not=1,j\leq i)$ 都满足 $S[j,i]\ge0$ 。

2. 并且对于以 $i$ 为开始的所有前缀 $S[i,j](j>i)$ 都满足 $S[i,j]<0$（注意这里如果有相同的权值，我们选最后一个）。

那么可以设计DP，设 $f[S]$ 表示选了集合S内所有元素，满足条件 $2$ 的方案数， $g[S]$ 表示选了集合S内所有元素，满足条件 $1$ 的方案数。

显然有如下转移：

$f[i|(1\ll j)]=(f[i|(1\ll j)]+f[i])(S[i]<0 $ 且 $j\notin i)$

$g[i|(1\ll j)]=(g[i|(1\ll j)]+g[i])(S[i]\ge0$ 且 $j\notin i)$


最后统计答案就枚举第一个数选什么，然后枚举所有满足条件的前缀后缀，计算答案即可。

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define sz(x) (int)(x.size())
#define ll long long
#define pb push_back
#define gc getchar()
using namespace std;
char buf[100000],*p1=buf,*p2=buf;
inline int gi()
{
	int x=0,f=1;char ch=gc;
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48),ch=gc;}
	return (f==1)?x:-x;
}
const int maxn=25,mod=998244353;
int f[(1<<20)+1],g[(1<<20)+1],n,a[maxn],S[(1<<20)+1];
inline void input()
{
	n=gi();
	FOR(i,0,n-1)a[i]=gi();
	f[0]=1;g[0]=1;
}
inline void solve()
{
	FOR(i,0,(1<<n)-1)
	{
		FOR(j,0,n-1)if(i>>j&1)S[i]+=a[j];
	}
	FOR(i,0,(1<<n)-1)
	{
		FOR(j,0,n-1)
		{
			if(i>>j&1)continue;
			int sum=S[i];
			if(sum+a[j]<0)f[i|(1<<j)]=(f[i|(1<<j)]+f[i])%mod;
			if(sum+a[j]>=0)g[i|(1<<j)]=(g[i|(1<<j)]+g[i])%mod;
		}
	}
	int ans=0;
	FOR(i,0,n-1)
	{
		FOR(j,0,(1<<n)-1)
		{
			if(j>>i&1)continue;
			int k=((1<<n)-1)^(j|(1<<i));
			int nowval=1ll*f[k]*g[j]%mod;
			ans=(ans+1ll*nowval*S[j|(1<<i)]%mod)%mod;
		}
	}
	ans=(ans+mod)%mod;
	printf("%d\n",ans);
}
int main()
{
	input();
	solve();
	return 0;
}
```



---

## 作者：MikukuOvO (赞：8)

$sum[S]$表示状态为$S$的集合，$a_i$的权值和。

$f[S]$表示状态为$S$的集合，满足最大前缀和等于$sum[S]$的排列的方案数。

$g[S]$表示状态为$S$的集合，满足最大前缀和$\leq0$的排列的方案数。

$$Ans=\sum_{S}sum[S] \times f[S] \times g[U-S]$$

$$g[S]+=g[S-i] (i \in S,sum[S] \leq 0)$$

$$f[S|i]+=f[S](sum[S]>0)$$

---

## 作者：EricWan (赞：5)

火箭连接大脑，暴力代替思考！

题目问的是一个序列的所有 $n!$ 种排列的最大非空前坠和之和，看到~~题解区~~ $n\le20$ 我们可以想到状压。

后面这一段和其他题解相同。

定义 $sum_S=\sum_{i\in S}a_i$，$f_S$ 为 $[a_{i\in S}]$ 的 $|S|!$ 种排列中满足任意后缀和 $\ge0$ 的排列方案数，$g_S$ 为 $[a_{i\in S}]$ 的 $|S|!$ 种排列中满足任意前缀和 $<0$ 的排列方案数。

可以得出转移方程

$$f_S=[sum_S\ge0]\times\sum_{i\in S}f_{\complement_Si}$$

$$g_S=[sum_S<0]\times\sum_{i\in S}g_{\complement_Si}$$

其中初始化为 $f_0=g_0=1$。

随后我们假设一个序列的贡献只产生再最长的最大前缀上。

我们的答案就是 $\sum_{S\subseteq\{1\dots n\}}sum_S\times f_S\times g_{\complement_{\{1\dots n\}}S}$，这个是好理解的。

我们开心的码完代码发现只有 55 分，为什么，重新观察刚才的思考过程，我们发现我们会将『所有非空前缀和都小于 $0$』的排列的答案以 $0$ 计入，但是这是错误的。

为了处理这个，其他题解开始各显神通，但是其中一种神通似乎都没有说，这里我要说一下这种方法（这也是我写这篇题解的目的）。

题目要求找『最大**非空**前缀和之和』而我们求的是『最大前缀和之和』，我们简单思考就可以发现『最大**非空**前缀和之和』可以转化为『第一个元素加后面长为 $n-1$ 的序列的最大前缀和之和』，我们就显然可以枚举第一个元素是什么，然后做上面的 dp 就好了。

时间复杂度是抽象的 $O(n^22^n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define MAXN 1200005
#define mod 998244353
using namespace std;
int n, A[MAXN], sum[MAXN], ans, f[MAXN], g[MAXN], cur_fir, a[1005][1005];
void solve(int *a) { // 直接调用获得 55pts 高分
	memset(sum, 0, sizeof(sum));
	memset(f, 0, sizeof(f));
	memset(g, 0, sizeof(g));
	for (int i = 1; i <= n; i++) { // 枚举，算出 sum
		for (int j = 0; j < (1 << n); j++) {
			if (j & (1 << i - 1)) {
				sum[j] += a[i];
			}
		}
	}
	f[0] = g[0] = 1;
	for (int i = 1; i < (1 << n); i++) { // 按照上面的递推公式算出 f 和 g
		for (int j = 1; j <= n; j++) {
			if (i & (1 << j - 1)) {
				if (sum[i] >= 0) {
					f[i] += f[i ^ (1 << j - 1)];
					f[i] %= mod;
				}
				if (sum[i] < 0) {
					g[i] += g[i ^ (1 << j - 1)];
					g[i] %= mod;
				}
			}
		}
	}
	for (int i = 0; i < (1 << n); i++) { // 按照上面的计算答案公式算出答案，记得 sum 要加一个当前的第一个元素
		ans += (sum[i] + cur_fir) % mod * f[i] % mod * g[(1 << n) - 1 ^ i] % mod;
		ans %= mod;
	}
}
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> A[i]; // 这个是原始的序列
	}
	n--; // 方便操作
	for (int i = 1; i <= n + 1; i++) {
		cur_fir = A[i];
		int *b = a[i]; // 拷贝一下原始序列，A 删掉 A[i] 然后存进 b
		for (int j = 1; j < i; j++) {
			b[j] = A[j];
		}
		for (int j = i + 1; j <= n + 1; j++) {
			b[j - 1] = A[j];
		}
		solve(b);
	}
	cout << (ans % mod + mod) % mod;
	return 0;
}
```

---

## 作者：_louhc (赞：4)

# 思路

数据范围这么小肯定是状压没错了.

做这种题一个基本的套路就是枚举所有可能产生贡献的状态,并把所有状态加起来.
从这方面考虑,我们枚举该序列中一些元素构成的集合 $S$ ,计算最大前缀和为这些元素之和的方案数.
要满足最大前缀和为 $sum(S)$ ,需要满足哪些条件呢?首先, $S$ 的最大前缀和为 $sum(S)$,其次, $all-S$ 所有的前缀和都得小于 $0$ ($all$ 表示整个序列,即全集) .
我们记 $S$ 构成的序列中有 $f(S)$ 个序列满足最大前缀和为 $sum(S)$, 有 $g(S)$ 个序列满足所有前缀和小于 $0$,那么答案就是 $\sum_{S}f(S)g(all-S)sum(S)$.

接下来难点就在于转移了.

先考虑 $f(S)$, 枚举序列的第一个元素 $x\in S$.如果 $sum(S-x)<0$,肯定不合题意.因为这样会导致 $x > x + sum(S-x)$.如果序列的最大前缀和不为 $sum(S-x)$, 很明显也不行,因为这样会导致加上 $x$ 后序列的最大前缀和不为 $x+sum(S-x)=sum(S)$.因此,可以写出方程 $f(S)=\sum_{x\in S,sum(S-x)\ge0} f(S-x)$.

然后考虑 $g(S)$,枚举序列的最后一个元素 $x \in S$. 如果 $sum(S)\ge0$, 易得 $g(S)=0$.只需要满足 $x$ 之前的序列满足条件即可,即 $g(S)=\sum_{x \in S} g(S-x)$.

然后就可以愉快地求出答案了.

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define i64 long long
#define f80 long double
#define rgt register
#define fp( i, b, e ) for ( int i(b), I(e); i <= I; ++i )
#define fd( i, b, e ) for ( int i(b), I(e); i >= I; --i )
#define go( i, b ) for ( int i(b), v(to[i]); i; v = to[i = nxt[i]] )
template<typename T> inline bool cmax( T &x, T y ){ return x < y ? x = y, 1 : 0; }
template<typename T> inline bool cmin( T &x, T y ){ return y < x ? x = y, 1 : 0; }

const int _ = 1 << 20, mod = 998244353;
int N, n, f[_], g[_];
i64 s[_];

inline int dec( int x ){ return x >= mod ? x - mod : x; }

signed main(){
	cin >> N, n = (1 << N) - 1, g[0] = 1;
	fp( i, 0, N - 1 ) cin >> s[1 << i], f[1 << i] = 1;
	fp( i, 0, n ) s[i] = s[i & -i] + s[i ^ (i & -i)];
	fp( i, 1, n ){
		if ( s[i] < 0 ){ fp( j, 0, N - 1 ) if ( (i >> j) & 1 ) g[i] = dec(g[i] + g[i ^ (1 << j)]); }
		else{ fp( j, 0, N - 1 ) if ( ~(i >> j) & 1 ) f[i | (1 << j)] = dec(f[i | (1 << j)] + f[i]); }
	} int ans(0); fp( i, 1, n ) ans = (ans + s[i] % mod * f[i] % mod * g[n ^ i] ) % mod;
	printf( "%d\n", (ans + mod) % mod );
	return 0;
}
```



---

## 作者：loverintime (赞：4)

首先， 我们要明白， 题目让我们求的是序列的任意排列的最大前缀和的和对 $998244353$ 取模。

看到 $n$ 最大只有 $20$, 想到状压 $dp$。

首先容易想到的， 令 $f(S)$ 表示让 $S$ 集合中的元素作为最大前缀和的方案数, $sum(S)$表示集合 $S$ 中所有数的和， 全集为 $I$。 那么，有两个条件需要满足：

1. $f(S)$ 的任意一个后缀和都是负数， 否则去掉更优。

这里我们可以得到转移方程。 考虑排在第一个的元素 $i$， 当且仅当 $sum(S-\{i\})\geqslant 0$ 可以给 $f(S)$ 有贡献。

即：
$$\large f(S)=\sum_{i\in S\wedge sum(S-\{i\})\geqslant 0}f(S-\{i\})$$

2. 剩下的数构成的排列没有任何一个前缀是非负数， 否则加上更优。

这个我们设 $g(S)$ 表示让 $S$ 集合中的元素任意前缀都 $<0$ 的排列个数。

首先， 我们得到答案： $\sum_{S\in I}sum(S)\times f(S)\times g(I-S)$

接下来想 $g$ 如何转移

首先， 当且仅当 $sum(S)<0$ 的情况下了， $g(S)$才有可能成立。

考虑最后一个数 $i$, 如果 $sum(S-\{i\})<0$， 那么 $g(S-\{i\})$ 对 $g(S)$ 有贡献。

即：
$$\large g(S)=\sum_{i\in S\wedge sum(S-\{i\})<0}g(S-\{i\})$$

那么这道题就做完了。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int f[(1<<20)+1],g[(1<<20)+1],sum[(1<<20)+1];
void add(int &a,int b){
	a+=b;a%=mod;
}
int n;
int ans=0;
signed main()
{
	scanf("%lld",&n);
	for(int i=0; i<n; i++) scanf("%lld",&sum[(1<<i)]);
	for(int s=1; s<(1<<n); s++){
		sum[s]=sum[s&(~(s&(-s)))]+sum[s&(-s)];
	}
	for(int i=0; i<n; i++){
		f[(1<<i)]=1;
	}g[0]=1;
	for(int s=0; s<(1<<n); s++){
		for(int i=0; i<n; i++){
			if(s&(1<<i)) continue;
			if(sum[s|(1<<i)]<0){
				add(g[s|(1<<i)],g[s]);
			}
			if(sum[s]>=0){
				add(f[s|(1<<i)],f[s]);
			}
		}
	}
	for(int s=0; s<(1<<n); s++){
		add(ans,sum[s]%mod*f[s]%mod*g[((1<<n)-1)&(~s)]%mod);ans=(ans%mod+mod)%mod;
	}
	printf("%lld",ans);
	return 0;
}


---

## 作者：Purslane (赞：3)

# Solution

怎么是一道唐题。

假设某个数列 $\{a\}$ 的最大前缀和在 $u$ 处取到（如果有多处，取 $u$ 最大的那一个），那么只需要满足如下的限制：

- $\forall u < v \le n$，$\sum_{i=u+1}^v a_i < 0$。这样保证 $u$ 之后没有最大值点。

- $\forall 1 < v \le u$，$\sum_{i=v}^u a_i \ge 0$。这是保证 $u$ 之前没有严格大于他的最大值点。

考虑用 $O(2^n)$ 复杂度枚举最大前缀和里面排了哪些数，计算要满足以上两种条件的总情况数是多少。

其实可以化归成两个问题：给你集合 $S$，求有多少种它的排列，使得：

- 这个排列所有非空前缀和都是负的。

- 这个排列所有非空前缀和以及不是自身的前缀和都是非负的。（你可以认为是真前缀和）。

这两个问题都可以利用状压 DP 枚举最后一个数解决。

复杂度 $O(n \times 2^n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=21,MOD=998244353;
int n,a[MAXN],sum[1<<MAXN],dp1[1<<MAXN],dp2[1<<MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n; ffor(i,1,n) cin>>a[i];
	ffor(i,1,(1<<n)-1) ffor(j,1,n) if(i&(1<<j-1)) sum[i]+=a[j];
	dp1[0]=dp2[0]=1;
	ffor(i,1,(1<<n)-1) ffor(j,1,n) if((i&(1<<j-1))&&sum[i-(1<<j-1)]>=0) dp1[i]=(dp1[i]+dp1[i-(1<<j-1)])%MOD;
	ffor(i,1,(1<<n)-1) if(sum[i]<0) ffor(j,1,n) if(i&(1<<j-1)) dp2[i]=(dp2[i]+dp2[i-(1<<j-1)])%MOD;
	int ans=0;
	ffor(i,1,(1<<n)-1) ans=(ans+dp1[i]*dp2[(1<<n)-1-i]%MOD*(sum[i]%MOD)%MOD)%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：3)

规定（都是正常的规定，可以跳过）：

用二进制数 $k$ 来表示一个集合，某一位为一表示有，零表示没有，$|k|$ 表示集合 $k$ 的大小，即二进制表示下 $1$ 的个数，$x|y$ 表示集合 $x$ 和 $y$ 的并集，即按位或，$x\&y$ 表示集合 $x$ 和 $y$ 的交集，即按位与，$x\otimes y$ 为集合 $x$ 和 $y$ 的对称差，即按位异或。

---
不妨设序列的最大前缀和在相等时取其一次出现的，当序列 $a_i$ 的最大前缀和是 $\sum\limits_{i=1}^ka_i$ 当且仅当 $\forall p\in[1,k),\sum\limits_{i=1}^pa_i<\sum\limits_{i=1}^ka_i$,$\forall p\in(k,n],\sum\limits_{i=k+1}^pa_i\le0$，这样将序列分成了前后两个子集。

设 $f_x$ 表示集合 $x$ 最大前缀和用到了所有数字的排列数，$g_x$ 表示集合 $x$ 满足任意前缀和非正的排列数，则答案为 $\sum\limits_{x=1}^{2^n-1}f_xg_{x\otimes(2^n-1)}$。

考虑如何求 $f$ 和 $g$，$g$ 可以通过简单的状压递推求：
```cpp
for(p=0;p<k;++p)
for(int x:G[p])
for(i=0;i<k;++i)
if((q=x|(1<<i))^x)
if((sm[q]=sm[x]+a[i])<=0)
if((dp[q]+=dp[x])>=M)dp[q]-=M;
```
以上 `sm` 表示集合元素和，`dp` 即需要求的 $g$ 数组，`p` 枚举的是集合元素个数（大小），`G[p]` 表示大小为 `p` 的集合。

于是 $g$ 求出来了，求 $f$ 可以使用基础容斥，考虑 $x$ 的前缀和不会用到所有数的情况有 $\sum\limits_{y\&x=x}f_yg_{y\otimes x}$ 种，用总排列数 $|x|!$ 减去即可。发现这是一个子集卷积形式，而且只有位数小的会推到位数大的，满足无后效性，参考[小清新子集卷积](/blog/502410/subset-sconvolution-fresh)，运用快速沃尔什变换可以做到 $O(n^22^n)$ 时间，$O(n2^n)$ 空间。

[LOJ 上的 AC 记录](https://loj.ac/s/1539004)

---

## 作者：TulipeNoire (赞：2)

### 题意

将长度为 $n$ 的正数序列 $a$ 任意重排后对每一种方案的最大前缀和求和。

$1\le n\le 20$。

### 分析

感觉此题的难点在于想到状态定义。还是我太菜了？

我们钦定产生最大前缀和的位置为第一次出现的位置，令其为 $p$，并把序列分为 $1$ 到 $p$ 与 $p+1$ 到 $n$ 两段。那么第一段中所有其他前缀和必定小于序列和，称其为条件一；第二段中所有前缀和不大于 $0$，称其为条件二。所以我们的思路可以是枚举这两段，将其拼接起来。

具体地，令 $f_S$ 为用 $S$ 中元素组成的序列中满足第一个条件的数量，$g_S$ 为第二个条件。可以发现 $g$ 是易于 $O(n)$ 转移的，难点在于 $f$ 的转移。稍加观察发现 $f_S$ 也可表示用 $S$ 中元素组成的序列，使得除了序列和，其他的前缀和都必须大于 $0$，这种序列的个数（考虑满足条件一序列的后缀都大于 $0$，翻转即可）。这样就可以与 $g_S$  类似地定义出 $h_S$，代表所有前缀大于 $0$ 的个数。然后 $f$ 也可以由 $h$ 的值 $O(n)$ 转移了。最后再枚举产生贡献的集合即可。时间复杂度 $O(n2^n)$，空间复杂度 $O(2^n)$。

### 代码

```cpp
//代码写得很清楚，注意代码中 f 和 h 的意义颠倒过来了。
#include<bits/stdc++.h>
using namespace std;
using LL=long long;
const int N=21,mod=998244353;
int n,a[N],f[1<<N],g[1<<N],h[1<<N];
LL sum[1<<N];
int main() {
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&a[i]);
	for (int S=0;S<(1<<n);S++) {
		for (int i=0;i<n;i++) if ((S>>i)&1) sum[S]+=a[i];
	}
	g[0]=1;
	for (int S=1;S<(1<<n);S++) {
		if (__builtin_popcount(S)==1) {
			f[S]=(sum[S]>0),g[S]=(sum[S]<=0),h[S]=1;
			continue;
		}
		for (int i=0;i<n;i++) {
			if ((S>>i)&1) {
				f[S]=(f[S]+1ll*(sum[S]>0)*f[S^(1<<i)])%mod;
				g[S]=(g[S]+1ll*(sum[S]<=0)*g[S^(1<<i)])%mod;
				h[S]=(h[S]+f[S^(1<<i)])%mod;
			}
		}
	}
	int ans=0;
	for (int S=1;S<(1<<n);S++) {
		ans=(ans+1ll*sum[S]%mod*h[S]%mod*g[((1<<n)-1)^S])%mod;
	}
	printf("%d",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：山田リョウ (赞：1)

## [「PKUSC2018」最大前缀和](https://www.luogu.com.cn/problem/P5369)

### 题意：

求一个序列 $a$ 任意排列的最大前缀和之和。

$1\leq |a|\leq 20$。

### 题解：

首先为了防止计重，当有多个前缀和同时为最大时，我们钦定选择最靠前的。

设 $b$ 为 $a$ 的某个排列，$s$ 是 $b$ 的前缀和。那 $s_i$ 最大当且仅当 $(\forall x\in [2,i]\cap\mathbb{Z})(s_i-s_{x-1}>0)\land(\forall x\in(i,n]\cap\mathbb{Z})(s_x-s_i\leq0)$，即 $b_{\{2,i\}}$ 后缀和全正，$b_{\{i+1,n\}}$ 前缀和全非正。

因此维护 $f_s$ 为点集为 $s$ 且前缀和全非正的排列数，$g_s$ 为点集为 $s$ 且后缀和全正的排列数，$f$ 枚举排列最后一位、$g$ 枚举排列第一位，递推维护即可。最后枚举 $b_1$ 再枚举 $b_{\{2,i\}}$ 更新答案即可，时间复杂度 $O(n2^n)$。 

[code.](https://paste.ubuntu.com/p/CRBm26prXv/)

---

## 作者：SamHJD (赞：1)

## [P5369 [PKUSC2018] 最大前缀和](https://www.luogu.com.cn/problem/P5369)

### 题意

求一个序列的所有排列的最大前缀和的和。

### 解法

看到 $n$ 的范围仅有 $20$，考虑状态压缩动态规划。为了方便，后面的数组中 $i$ 均为一个二进制下的数，表示全集序列的一个子集，某一位为 $1$ 意味着取。

首先思考最大前缀的性质：最大前缀一定没有一个负后缀，否则不为最优。同样的，最大前缀后面的部分一定没有一个正前缀。

我们设 $f_i$ 表示子集 $i$ 所有排列中，最大前缀和为 $sum_i$ 的情况，设 $sum_i$ 为子集 $i$ 所有元素的和。并设 $g_i$ 表示子集 $i$ 的所有排列中，没有正前缀和的情况。

这样，对于一个子集 $i$，他对答案的贡献为 $f_i\times g_{n-i}\times sum_i$。接下来考虑如何更新 $f,g$。

$$g_i=\begin{cases}0\ (sum_i>0)\\\sum\limits_{j\in i} g_{i-j}\end{cases}$$

如果 $i$ 的和大于 $0$，则其所有元素可以加入最大前缀和中，因此为 $0$，否则删掉任意一个 $1$ 来更新。

$$f_{i+j}=\begin{cases}\sum\limits_{j\not\in i}f_i\ (sum_i>0)\end{cases}$$

对于 $f$ 的转移，由于比 $g$ 的限制多些，我们不能直接枚举 $1$ 转移，考虑用 $f_i$ 更新其他 $f$。

我们枚举一个不属于 $i$ 集合中的一个元素 $j$，$j$ 将放在排列的最前面。这样，如果 $sum_i>0$，那么这个排列的最大前缀和一定是 $j+i$ 这些元素。否则不可能最大前缀和为 $sum_{i_j}$，而因该是 $j$ 加 $i$ 当前排列的最大前缀和的元素构成 $i+j$ 当前排列的最大前缀和。

所以，如果 $sum_i>0$，那么可以用 $f_i$ 更新 $f_{i+j}$，否则不行。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MOD=998244353,N=1<<20;
int n,f[N],g[N],ans,sum[N];
int lowbit(int x){
	return x&-x;
}
signed main(){
	scanf("%lld",&n);
	for(int i=0;i<n;++i){
		scanf("%lld",&sum[1<<i]);
		f[1<<i]=1;
	}
	for(int i=1;i<(1<<n);++i) sum[i]=sum[i^lowbit(i)]+sum[lowbit(i)];
	//每次获取i的最低位1，将其删去后的那个sum更新这个sum，当然你也可以dfs
	g[0]=1;
	for(int i=1;i<(1<<n);++i){
		if(sum[i]>=0){//更新f
			for(int j=0;j<n;++j){//枚举不属于i的一个元素j
				if(!(i&(1<<j))) f[i|(1<<j)]=(f[i|(1<<j)]+f[i])%MOD;
			}
		}
		else{//更新g
			for(int j=0;j<n;++j){//枚举属于i的一个元素j
				if(i&(1<<j)) g[i]=(g[i]+g[i^(1<<j)])%MOD;
			}
		}
	}
	for(int i=1;i<(1<<n);++i) ans=(ans+((sum[i]*f[i])%MOD*g[(1<<n)-1^i]%MOD)+MOD)%MOD;
	//计算答案
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

不妨考虑在第一个最大前缀和处计数。

假若这个点是 $k$ 并且这个前缀和的数集为 $v$ 那么这个时候考虑前缀和里面和后面怎么填的方案数乘起来再乘一个前缀和。

现在求需要求出这两个 dp 数组：

$f_{v}$ 前缀和数集合为 $v$ 且最大前缀和为 $\sum_{v} a_i$ 的方案数。

$g_{v}$ 待填的数（后缀）的前缀和恒小于 $0$ 的方案数。

后一个很好转移，这里略去。

只考虑 $f$ 怎么转移。

考虑使用填表法。

对于一个集合 $i$ 我们把数 $j$ 加到最开头，那么假若 $i$ 的和大于 $0$ 那么 $f_{i+2^j}$ 就会增加 $f_i$ 否则就没有贡献。

那么我们最后就在 $O(n \times 2^n)$ 的时间复杂度内解决了这个问题：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxv = 1048600;
const int maxn = 22;
const int mod = 998244353;
int sum[maxv],val[maxv],f[maxv],g[maxv];//前缀为 sum[i] 后缀小于 0 的方案数 
int a[maxn],n,ans;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=0;i<(1ll<<n);i++){
		for(int j=1;j<=n;j++){
			if(i&(1ll<<(j-1))){
				sum[i]+=a[j];
				val[i]=(val[i]+a[j]+mod)%mod;
			}
		}
	}
	g[0]=1;
	for(int i=0;i<(1ll<<n);i++){
		for(int j=1;j<=n;j++){
			if(i&(1ll<<(j-1))){
				g[i]=(g[i]+g[i-(1ll<<(j-1))])%mod;
			}
		}
		if(sum[i]>0) g[i]=0; 
	}
	f[0]=1;
	for(int i=0;i<(1ll<<n);i++){
		for(int j=1;j<=n;j++){
			if(!(i&(1ll<<(j-1)))){
				if(sum[i]>0||i==0) f[i+(1ll<<(j-1))]=(f[i+(1ll<<(j-1))]+f[i])%mod;
			}
		}
	}
	for(int i=0;i<(1ll<<n);i++){
		ans=(ans+val[i]*(f[i]*g[(1<<n)-1-i]%mod))%mod;
	}
	cout<<ans%mod<<'\n';
	return 0;
} 


					               
```


---

## 作者：chengch (赞：0)

其他题解似乎都在花功夫算最大前缀和用到所有数的方案数，实际上根本不需要算这个。  

考虑一个位置 $p$ 是**第一个**最大前缀和的条件是，以 $p$ 结尾的所有后缀和（不包括 $[1,p]$）都 $>0$，以 $p+1$ 开头的所有前缀和都 $\le 0$。  

设 $f_S$ 表示集合 $S$ 有多少种排列满足前缀和（显然这与后缀和的方案数是一样的）都 $>0$，设 $g_S$ 表示集合 $S$ 有多少种排列满足前缀和都 $\le 0$，记 $sum_S$ 表示 $S$ 的和。

转移是容易的，对于 $f_S$，如果 $sum_S \le 0$ 则 $f_S=0$，否则枚举最后一位放了什么，即 $f_S=\sum_{i\in S}f_{S\setminus \{i\}}$。$g$ 的转移同理。  

求出 $f,g$ 后，我们枚举答案中**第一位填了 $i$**，$[2,p]$ 填了集合 $S$，那么对答案的贡献就是 $sum_{S\cup \{i\}}f_{S}g_{\overline{S\cup \{i\}}}$。时间复杂度 $O(n2^n)$。  

代码很好写。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 25, M = (1 << 20) + 5, mod = 998244353;
int n, a[N], f[M], g[M], sum[M];
int main() {
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> a[i];
	for (int S = 0; S < (1 << n); S++) {
		for (int i = 0; i < n; i++)
			if (S >> i & 1)
				sum[S] += a[i];
	}	
	f[0] = 1;	
	for (int S = 1; S < (1 << n); S++) {
		if (sum[S] <= 0) continue;
		for (int i = 0; i < n; i++)
			if (S >> i & 1)
				(f[S] += f[S ^ (1 << i)]) %= mod;
	}
	g[0] = 1;
	for (int S = 1; S < (1 << n); S++) {
		if (sum[S] > 0) continue;
		for (int i = 0; i < n; i++)
			if (S >> i & 1)
				(g[S] += g[S ^ (1 << i)]) %= mod;
	}
	int ans = 0;
	for (int S = 0; S < (1 << n); S++) {
		for (int i = 0; i < n; i++) {
			if (S >> i & 1) continue;
			(ans += (ll) (a[i] + sum[S]) % mod * f[S] % mod * g[((1 << n) - 1) ^ S ^ (1 << i)] % mod) %= mod;
			if (ans < 0) ans += mod;
		}
	}
	cout << (ans % mod + mod) % mod << '\n';
	return 0;
}
```

---

## 作者：StarPatrick (赞：0)

主要讲状态定义的思路。

首先有一个显然的思路就是枚举最大值是由哪一个子集贡献的，然后再套个状压 dp 计算这种情况的方案，转移可以做到 $O(1)$，这一步复杂度是 $O(n3^n)$ 的。

考虑优化，我们的基本思路还是 **最大值** 乘以这种情况的 **方案数**，之前我们枚举了最大值，这一步不好优化，考虑是否能够优化内层的状压 dp。

我们发现这个最大值天然地把序列分成了两段，假设这个最大值的集合为 $u$，最大值为 $T$，那么前一半我们要保证 **从空集开始的前缀和** 最大值为 $T$，后一部分我们要保证 **从 $u$ 集合开始的前缀和** 最大值为 $T$，发现后面一个定义包含了 $u$，这也是我们需要优化的地方，转化一下变为 **从空集开始的前缀和** 最大值小于 $0$，这样两个定义就相互独立了。

接下来直接分别状压 dp，枚举最大值集合统计答案即可，这一部分其他大佬讲得很清楚，便不再赘述。

---


# [PKUSC2018] 主斗地

## 题目描述

如果你参加过 NOIP 2015 和 PKUWC 2018，那么你一定对一道叫做斗地主的题印象深刻。为了致敬经典，我们又出了一道有关打牌的题。在本题中，牌型和斗地主**类似但不完全相同**，我们称本题中的扑克游戏为主斗地。

主斗地是一种使用黑桃、红心、梅花、方片的A到K加上大小王的共54张牌来进行的扑克牌游戏，其中大小王各一张，其他数码牌各四张。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10(T)<J<Q<K<A<2< $小王 $(w)$ $<$ 大王 $(W)$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。为了简化题目，本题不考虑花色的影响，即**所有的相同的数码的牌都是被视为一样的**。

在这道题中，允许的出牌牌型有（**这一部分与传统的斗地主有所出入，请注意**）：

|   名称    |           解释           |      举例       |     注     |
| :-----: | :--------------------: | :-----------: | :-------: |
|   单牌    |         单独的一张牌         |       6       | 单张的王也是单牌  |
|   对子    |        相同数码的两张牌        |      66       |  大小王不是对子  |
|   三张牌   |        相同数码的三张牌        |      666      |           |
|   三带一   |     相同数码的三张牌带上一张单牌     |     666w      |           |
|   三带二   |  相同数码的三张牌带上一个另外数码的对子   |     66699     |           |
|   顺子    |    大小连续的 $5$ 张及以上单牌    |    3456789    | 不能含有大小王和2 |
|   连对    |   大小连续的 $3$ 对及以上的对子    |   33445566    | 不能含有大小王和2 |
|   三顺    |     大小连续的两组及以上的三张牌     |   333444555   | 不能含有大小王和2 |
|   四带二   |     四张相同数码的牌带上两张单牌     | 444456 444455 | 注意不能带两个对子 |
| 飞机（单翅膀） | 三顺带上相同数量的**数码两两不同的**单牌 | 33344455569J  |           |
| 飞机（双翅膀） | 三顺带上相同数量的**数码两两不同的**对子 |  3334446699   |           |

**注意**：

1. 在牌型中没有连炸这种牌型，但是形如 444455556666 的牌仍然是能出的，它将被视为 444555666 带 456 的飞机（单翅膀）牌型。
2. 大王和小王数码不同，即飞机带大小王是合法的，例如 333444wW
3. 容易验证，上述牌型的规则是合法的，即对于任意合法的牌，它都有唯一的牌型。
4. 在牌型中，没有炸弹。**炸弹将被视为三带一，且没有炸弹的效果**，即它不能压任何牌型。
5. 在牌型中，没有火箭。这意味着 wW 不再是一个合法的牌型。

两手牌是属于相同牌型的当且仅当他们的名称相同且包含牌的数量相同。相同牌型的牌之间存在着大小关系：

1. 三带一三带二的大小取决于那三张相同牌的数码
2. 飞机的大小取决于三顺的大小
3. 四带二的大小取决于四张相同牌的大小
4. 其他牌型的大小取决于牌中的最大的一张牌

下面是对主斗地的游戏过程的描述：

1. 在主斗地中，有两个玩家，他们是同一个阵营的，两个玩家要一同达成游戏目标。为了方便，我们假设第一个玩家是九条可怜，第二个玩家是××网友。
2. 游戏只会使用一副完整的扑克牌。在游戏开始的时候，**会先把所有的 $3$ 扔掉**。之后双方各从这一副牌中随机抽取 $17$ 张，余下的 $16$张被丢弃。你可以认为是随机洗牌后，九条可怜取前 $17$ 张，××网友后 $17$ 张，剩下的 $16$ 张被掉了。
3. 游戏分成若干轮，每一轮分为两步：
   1. 第一步，九条可怜从当前手牌中选择一个任意牌型任意大小的牌 $C$ 并打出。
   2. 第二步，××网友从当前手牌中选择一个和 $C$ 牌型相同且大小 **严格更大** 的牌 $C'$ 打出。如果不存在这样的牌则游戏失败。
4. 在某一轮结束后，如果九条可怜和××网友中有至少一个人没有手牌，则游戏结束。如果两个人都没有手牌，则游戏胜利，否则游戏失败。

下面是一个例子：

假设九条可怜的牌是 44445556789TJQKwW，××网友的牌是 666789TJQKAAAA222。那么一个可以获胜的方案是：

1. 第一轮九条可怜出 4444wW，××网友出 AAAA22。
2. 第二轮九条可怜出 6789TJQ，××网友出 789TJQK。
3. 第三轮九条可怜出 555K，××网友出 6662。

这个游戏很考验两个玩家之间的默契。但是因为九条可怜和××网友无法相互理解，于是他们打算以明牌的方式进行游戏，即双方都知道对方的牌。因为两个人都会按照最优策略行动，所以在牌下发的时候，游戏的胜负就已经确定了。

现在给出××网友的牌，你需要计算九条可怜有多少种不同的可能的手牌可以获得胜利。

注意：××网友和九条可怜的牌都来自于同一副扑克，且分牌的时候没有 $3$。

## 说明/提示


因为种种原因，本题采用捆绑测试，一共有 $3$ 个 subtask:

| 子问题编号 |  分值  |       约定       |
| :---: | :--: | :------------: |
|   1   | $30$ | 每一种牌最多出现 $2$ 次 |
|   2   | $30$ | 每一种牌最多出现 $3$ 次 |
|   3   | $40$ | 每一种牌最多出现 $4$ 次 |

时间限制：2s 

空间限制：512M

## 样例 #1

### 输入

```
556789TJJQKKAA22w
456789TJJQKKAA22w
456789TJQKKKAAA22```

### 输出

```
193483
0
613897```

# 题解

## 作者：feecle6418 (赞：7)

这是一道大力出奇迹的题。

首先题目的 $\mathrm{mod}\ 998244353$ 是来吓人的。其实在去掉 $3$ 之后， 九条可怜的牌至多只有几百万种，因此完全可以枚举九条可怜的牌，然后暴力判断是否可行。

如何判断是否可行呢？明确一个事实：顺子是无用的，可以拆成单牌。于是不需搜顺子，首先搜索三个和四个的数量（因为他们可以带牌）；然后枚举有几个三带对，剩下的全部三带一或者四带二（因为如果不带，则可以拆成单牌来打），九条可怜带大牌，网友带小牌，剩下的牌从小到大扫一遍，看是否可行即可。

但是这样写在~~评测机极慢~~的本校 oj 上过不去。

因此加入以下优化：

1. 假如说要带的牌已经超过了 $17$ 张，直接返回；
2. 用 `memset` 和 `memcpy` 让常数乘上 $\frac{1}{8}$；
3. 本来“剩下的牌从小到大扫一遍，看是否可行即可。”这一部分我是用的两个数组，一个存九条可怜的，一个存网友的，但是这样极慢。我们可以差分，只用一个数组 $c$，假如九条可怜有 $x$ 张 $y$，则 $c_{y+1}\leftarrow c_{y+1}-x$；假如网友有 $z$ 张 $w$，则 $c_{w}\leftarrow c_{w}+z$。最后做一遍前缀和，假如有 $>0$ 的，则说明九条可怜牌太多了，不可行；否则可行。常数又乘上 $\frac{1}{2}$；
4. 假如对子数已经超过了 $\min(j,w)$（$j$ 为九条可怜的对子数，$w$ 为网友对子数），则直接返回。
5. 三张和四张只用搜到 `2` 就好，不用搜 `w` 和 `W`。

加入以下优化后，在本校 oj、洛谷、loj 上均跑到了 Rank 1。（洛谷上显示为 Rank 2，但是其实我的总用时比 Rank 1 少，是总用时计算机制的问题）

代码直接去看 loj Rank 1 就好。提交者叫做 `2`。

---

## 作者：251Sec (赞：3)

我们先来分析一下，事实上这么多牌型有很多是没用的。

- 对子，三张牌，顺子，连对，三顺，这些牌型拆成单牌出一定不劣。
- 飞机拆成三带一或三带二一定不劣。

所以有用的牌型只有单牌，三带一，三带二，四带二。

考虑我们已知双方的牌，如果已经钦定了后三种牌型，那么剩下的就都是单牌。我们把双方的牌从小到大排序，然后一一对应着出，是不劣的。

我们事实上可以爆搜后三种牌型中三和四的部分（直觉上可以发现这些牌型不会很多），然后剩下被带的部分我们采取贪心：

- xx 网友优先带小牌。
- 九条可怜优先带大牌。

然后再按照对应着出的方法，就可以知道双方能不能出完这副牌了。

我们搞定了 Check 的部分，那么我们难道要对每种方案分别检测是否有解吗？

——还真是。我们发现，由于良心出题人去掉了 3，所以可行的手牌方案只有百万级别的种数，所以我们可以爆搜九条可怜的手牌。

于是这题就做完了。

感觉我的码风还挺好懂的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int cardXX[15], cardRemain[15], cardKel[15];
int ans;
int GetID(char cd) {
    if (cd >= '4' && cd <= '9') return cd - '3';
    if (cd == 'T') return 7;
    if (cd == 'J') return 8;
    if (cd == 'Q') return 9;
    if (cd == 'K') return 10;
    if (cd == 'A') return 11;
    if (cd == '2') return 12;
    if (cd == 'w') return 13;
    if (cd == 'W') return 14;
    return -1;
}
char s[18];
int cardXXCpy[15], cardKelCpy[15];
bool CheckSingle(int three, int four) {
    for (int i = 0; i <= three; i++) {
        int singleC = i + four * 2, doubleC = three - i;
        memcpy(cardXXCpy, cardXX, sizeof(int) * 15);
        memcpy(cardKelCpy, cardKel, sizeof(int) * 15);
        for (int j = 14; j >= 1; j--) {
            while (doubleC && cardKelCpy[j] >= 2) cardKelCpy[j] -= 2, doubleC--;
            while (singleC && cardKelCpy[j]) cardKelCpy[j]--, singleC--;
        }
        if (singleC || doubleC) continue;
        singleC = i + four * 2, doubleC = three - i;
        for (int j = 1; j <= 14; j++) {
            while (doubleC && cardXXCpy[j] >= 2) cardXXCpy[j] -= 2, doubleC--;
            while (singleC && cardXXCpy[j]) cardXXCpy[j]--, singleC--;
        }
        if (singleC || doubleC) continue;
        int counter = 0, j = 1;
        for (; j <= 14; j++) {
            if (counter < cardXXCpy[j]) break;
            counter += cardKelCpy[j] - cardXXCpy[j];
        }
        if (j == 15) return true;
    }
    return false;
}
bool Check(int pos = 1, int three = 0, int four = 0, int threeUnmatched = 0, int fourUnmatched = 0) {
    if (pos == 15) {
        if (!threeUnmatched && !fourUnmatched) {
            return CheckSingle(three, four);
        }
        return false;
    }
    if (cardKel[pos] >= 4) {
        cardKel[pos] -= 4; 
        bool foundAns = Check(pos + 1, three, four + 1, threeUnmatched, fourUnmatched + 1);
        cardKel[pos] += 4;
        if (foundAns) return true;
    }
    if (cardKel[pos] >= 3) {
        cardKel[pos] -= 3; 
        bool foundAns = Check(pos + 1, three + 1, four, threeUnmatched + 1, fourUnmatched);
        cardKel[pos] += 3;
        if (foundAns) return true;
    }
    if (cardXX[pos] >= 4 && fourUnmatched) {
        cardXX[pos] -= 4; 
        bool foundAns = Check(pos + 1, three, four, threeUnmatched, fourUnmatched - 1);
        cardXX[pos] += 4;
        if (foundAns) return true;
    }
    if (cardXX[pos] >= 3 && threeUnmatched) {
        cardXX[pos] -= 3;
        bool foundAns = Check(pos + 1, three, four, threeUnmatched - 1, fourUnmatched);
        cardXX[pos] += 3;
        if (foundAns) return true;
    }
    return Check(pos + 1, three, four, threeUnmatched, fourUnmatched);
}
void DFS(int pos, int siz) {
    if (pos == 15) {
        if (siz == 17) {
            if (Check()) ans++;
        }
        return;
    }
    for (int i = 0; i <= cardRemain[pos] && siz + i <= 17; i++) {
        cardKel[pos] = i;
        DFS(pos + 1, siz + i);
    }
}
int main() {
    while (~scanf("%s", s + 1)) {
        ans = 0;
        for (int i = 1; i <= 17; i++) cardXX[i] = 0;
        for (int i = 1; i <= 17; i++) {
            cardXX[GetID(s[i])]++;
        }
        for (int i = 1; i <= 12; i++) {
            cardRemain[i] = 4 - cardXX[i];
        }
        cardRemain[13] = 1 - cardXX[13]; cardRemain[14] = 1 - cardXX[14];
        DFS(1, 0);
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：zhenglier (赞：3)

$\color{white}\text{严厉谴责任何的盗窃题解行为}$

## 暴搜

非常暴力的搜索，以至于我都不相信我能过。

方法是：暴力枚举所有牌型，然后暴力判断是否可行。

## 暴力枚举部分:

非常暴力：
```cpp
void dfs(int x,int l){
    if(l==0){
        flag=0;
        check(1,0,0,0,0);
        if(flag)ans++;
        return;
    }
    if(x>14)return;
    for(res i=0;i<=limit[x]&&i<=l;++i){
        jiry[x]=i;
        dfs(x+1,l-i);
    }
}
```
搜下来发现牌型数量不大于$3000000$，因为出题人良心的把3都去掉了，所以总牌型大量缩减。

## 判断部分：

这里需要用到一个性质，如果一幅飞机或顺子可以大于另外一幅同类型的牌，那么把他拆开来也可以大于另外一幅牌拆开来。

判断部分分两部分，先暴力搜索搜出哪些牌要被拆出来变成三张牌或四张牌。

因为双方的总牌数都不会很大，所以直接搜只会带一个常数。

这里要注意，只有当九条可怜出了三张牌或四张牌以后，xx网友才能出三张牌或四张牌，不然九条可怜将无法出小于xx网友的牌型。

最后两者出的三张牌和四张牌数量必须相等，不然会有一副牌无法有对应的牌。

```cpp
void check(int x,int one,int oneortwo,int three,int four){
    if(x>14){
        if(three||four)return;
        check(one,oneortwo);
        return;
    }
    if(jiry[x]>=4){
        jiry[x]-=4;
        check(x+1,one+1,oneortwo,three,four+1);
        jiry[x]+=4;
        if(flag)return;
    }
    if(jiry[x]>=3){
        jiry[x]-=3;
        check(x+1,one,oneortwo+1,three+1,four);
        jiry[x]+=3;
        if(flag)return;
    }
    if(xx[x]>=4&&four){
        xx[x]-=4;
        check(x+1,one,oneortwo,three,four-1);
        xx[x]+=4;
        if(flag)return;
    }
    if(xx[x]>=3&&three){
        xx[x]-=3;
        check(x+1,one,oneortwo,three-1,four);
        xx[x]+=3;
        if(flag)return;
    }
    check(x+1,one,oneortwo,three,four);
}
```

然后再用贪心的方式判断最后的散牌是否可以。

枚举有多少的三张牌要带一个，然后得到有多少的一张牌和多少的两张牌可以被带掉。

对于九条可怜的牌，去掉最大的牌。对于xx网友的牌，去掉最小的牌。要先用两张牌来贪心，再用一张牌来贪心。

剩下的牌直接扫一遍，如果在前$i$种牌中xx网友的牌比九条可怜的要多，则当前牌错误。

```cpp
void check(int one,int oneortwo){
    for(res i=0;i<=oneortwo;i++){
        memcpy(jirycpy,jiry,sizeof jiry);
        memcpy(xxcpy,xx,sizeof xx);
        res o=i+one*2,t=oneortwo-i;
        for(res j=1;j<=14;++j){
            while(xxcpy[j]>=2&&t)xxcpy[j]-=2,t--;
            while(xxcpy[j]>=1&&o)xxcpy[j]-=1,o--;
        }
        if(o||t)continue;
        o=i+one,t=oneortwo-i;
        for(res j=14;j;--j){
            while(jirycpy[j]>=2&&t)jirycpy[j]-=2,t--;
            while(jirycpy[j]>=1&&o)jirycpy[j]-=1,o--;
        }
        if(o||t)continue;
        flag=1;
        for(res j=1,now=0;j<=14;++j){
            now-=xxcpy[j];
            if(now<0){
                flag=0;
                break;
            }
            now+=jirycpy[j];
        }
        if(flag)return;
    }
}
```

然后是完整代码

```cpp
#include<bits/stdc++.h>
#define res register int
using namespace std;
char str[15];
int jiry[15],xx[15],limit[15];
int jirycpy[15],xxcpy[15];
int cl(char c){
    if(c=='T')return 7;
    else if(c=='J')return 8;
    else if(c=='Q')return 9;
    else if(c=='K')return 10;
    else if(c=='A')return 11;
    else if(c=='2')return 12;
    else if(c=='w')return 13;
    else if(c=='W')return 14;
    else return c-'3';  
}
bool flag;
int ans;
void check(int one,int oneortwo){
    for(res i=0;i<=oneortwo;i++){
        memcpy(jirycpy,jiry,sizeof jiry);
        memcpy(xxcpy,xx,sizeof xx);
        res o=i+one*2,t=oneortwo-i;
        for(res j=1;j<=14;++j){
            while(xxcpy[j]>=2&&t)xxcpy[j]-=2,t--;
            while(xxcpy[j]>=1&&o)xxcpy[j]-=1,o--;
        }
        if(o||t)continue;
        o=i+one,t=oneortwo-i;
        for(res j=14;j;--j){
            while(jirycpy[j]>=2&&t)jirycpy[j]-=2,t--;
            while(jirycpy[j]>=1&&o)jirycpy[j]-=1,o--;
        }
        if(o||t)continue;
        flag=1;
        for(res j=1,now=0;j<=14;++j){
            now-=xxcpy[j];
            if(now<0){
                flag=0;
                break;
            }
            now+=jirycpy[j];
        }
        if(flag)return;
    }
}
void check(int x,int one,int oneortwo,int three,int four){
    if(x>14){
        if(three||four)return;
        check(one,oneortwo);
        return;
    }
    if(jiry[x]>=4){
        jiry[x]-=4;
        check(x+1,one+1,oneortwo,three,four+1);
        jiry[x]+=4;
        if(flag)return;
    }
    if(jiry[x]>=3){
        jiry[x]-=3;
        check(x+1,one,oneortwo+1,three+1,four);
        jiry[x]+=3;
        if(flag)return;
    }
    if(xx[x]>=4&&four){
        xx[x]-=4;
        check(x+1,one,oneortwo,three,four-1);
        xx[x]+=4;
        if(flag)return;
    }
    if(xx[x]>=3&&three){
        xx[x]-=3;
        check(x+1,one,oneortwo,three-1,four);
        xx[x]+=3;
        if(flag)return;
    }
    check(x+1,one,oneortwo,three,four);
};
void dfs(int x,int l){
    if(l==0){
        flag=0;
        check(1,0,0,0,0);
        if(flag)ans++;
        return;
    }
    if(x>14)return;
    for(res i=0;i<=limit[x]&&i<=l;++i){
        jiry[x]=i;
        dfs(x+1,l-i);
    }
}
int main(){
    scanf("%s",str+1);
    int len=strlen(str+1);
    for(int i=1;i<=12;++i){
    	limit[i]=4;
    }
    limit[13]=limit[14]=1;
    memset(xx,0,sizeof xx);
    for(int i=1;i<=len;++i){
        limit[cl(str[i])]--;
        xx[cl(str[i])]++;
    }
    ans=0;
    dfs(1,17); 
    printf("%d\n",ans);
}
```

---

## 作者：Time_tears (赞：3)

题解 P5370 【[PKUSC2018]主斗地】

**备战PKUWC的过程中，做到了这道题，在经过重重的毒瘤之后，我终于AC了这道题目！**

正解：暴搜

这道题没有那么多的部分分，直接上正解。


我们可以先暴力搜索九条可怜手上的牌，总数不会太大，大约在10^7级别，

对于搜出来的牌我们就考虑如何判断它是否合法就行了

（题目给的模数就是个坑！根本用不到）


**如何判断？**

注意到顺子和三顺是不优的，因为可以拆开来打

然后我们就可以先枚举有多少个三带X和多少个四带二

再然后我们就可以枚举所有的三带中有多少个三带二

再然后，就是带剩下的牌，这边有一个小贪心，就是九条可怜的牌尽量带大的走，网友的牌尽量带小的走。

再然后……慢慢打散牌

最后，附上我2.78K的代码，很多小错误改了我两个小时！！！


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define N 20
using namespace std;
int wy[N],jtkl[N],cnt[N];
int n,thr[N],fou[N],orz[N];
int a[N],W[N],J[N],p[N],ans;
char s[N];
int Num(char ch) {
	if(ch=='T')return 7;
	if(ch=='J')return 8;
	if(ch=='Q')return 9;
	if(ch=='K')return 10;
	if(ch=='A')return 11;
	if(ch=='2')return 12;
	if(ch=='w')return 13;
	if(ch=='W')return 14;
	return ch-'3';
}
bool Check(int f,int t) {
	for(int i=0; i<=t; ++i) {
		memcpy(W,wy,sizeof(wy)),memcpy(J,jtkl,sizeof(jtkl));
		int cnt=0;
		for(int j=1; j<=12; ++j) {
			if(W[j]>=2&&cnt<i)W[j]-=2,++cnt;
			if(W[j]>=2&&cnt<i)W[j]-=2,++cnt;
			if(cnt==i)break;
		}
		if(cnt<i)break;
		cnt=0;
		for(int j=12; j; --j) {
			if(J[j]>=2&&cnt<i)J[j]-=2,++cnt;
			if(J[j]>=2&&cnt<i)J[j]-=2,++cnt;
			if(cnt==i)break;
		}
		if(cnt<i)break;
		cnt=2*f+t-i,memset(p,0,sizeof(p));
		for(int j=1; j<=14; ++j) {
			int t=min(W[j],cnt);
			W[j]-=t,cnt-=t;
			if(!cnt)break;
		}
		cnt=2*f+t-i;
		for(int j=14; j; --j) {
			int t=min(J[j],cnt);
			J[j]-=t,cnt-=t;
			if(!cnt)break;
		}
		if(J[14])continue;
		for(int j=1; j<=14; ++j)p[j]+=W[j],p[j+1]-=J[j];
		cnt=0;
		for(int j=1; j<=14; ++j) {
			cnt+=p[j];
			if(cnt>0)break;
		}
		if(!cnt)return true;
	}
	return false;
}
bool Check_Jtkl(int now,int F,int T,int f,int t,int q1,int q2) {
	if(F==f&&T==t)return Check(f,t);
	if(now>=12)return false;
	q1+=thr[now],q2+=fou[now];
	if(q1>0||q2>0)return false;//九条可怜没有比网友小的牌
	if(jtkl[now]>=3) {
		jtkl[now]-=3;
		if(Check_Jtkl(now,F,T,f,t+1,q1,q2-1))return true;
		jtkl[now]+=3;
	}
	if(jtkl[now]>=4) {
		jtkl[now]-=4;
		if(Check_Jtkl(now,F,T,f+1,t,q1-1,q2))return true;
		jtkl[now]+=4;
	}
	return Check_Jtkl(now+1,F,T,f,t,q1,q2);
}
bool Check_Wy(int now,int f,int t) {//判断从2开始，搜素从1开始，因为一可以被带出去
	if(f*6+t*4>17)return false;
	if(now>12)return Check_Jtkl(1,f,t,0,0,0,0);
	if(wy[now]>=3) {
		wy[now]-=3,++thr[now];
		if(Check_Wy(now+1,f,t+1))return true;
		wy[now]+=3,--thr[now];
	}
	if(wy[now]>=4) {
		wy[now]-=4,++fou[now];
		if(Check_Wy(now+1,f+1,t))return true;
		wy[now]+=4,--fou[now];
	}
	return Check_Wy(now+1,f,t);
}
void Dfs(int x,int rest) {
	if(!rest) {
		memset(thr,0,sizeof(thr));
		memset(fou,0,sizeof(fou));
		memcpy(wy,a,sizeof(a));
		memcpy(jtkl,orz,sizeof(orz));
		if(Check_Wy(2,0,0))++ans;
		return;
	}
	if(x>14)return;
	for(int i=0; i<=cnt[x]; ++i) {
		if(i>rest)break;
		orz[x]=i,Dfs(x+1,rest-i),orz[x]=0;
	}
}
int main() {
	while(scanf("%s",s+1)!=EOF) {
		memset(a,0,sizeof(a));
		for(int j=1; j<=12; ++j)cnt[j]=4;
		cnt[13]=cnt[14]=1;
		for(int j=1; j<=17; ++j)++a[Num(s[j])],--cnt[Num(s[j])];
		ans=0,Dfs(1,17),printf("%d\n",ans);
	}
	return 0;
}
```



---

## 作者：MSqwq (赞：2)

### 喜欢暴力qwq（其实我是一个斗地主天才）
显然的想法是爆搜可怜的牌，然后接着找是否有合法出牌方案。因为总的方案数只有几百万种，所以可以直接枚举每种方案。   
然后是优化每一个 $check$ 过程.首先可以发现对子三张牌顺子连对三顺可以拆成若干单牌，飞机可以拆成若干三带一或三带二，所以只有我们只用考虑单牌，三带一，三带二，四带二。  
如果只考虑单牌,那么一定是两者的牌分别排好序后，可怜某张牌要严格小于网友的对应位置的牌才合法，所以这个可以从大到小枚举牌大小，然后看可怜的每种牌是否都有网友的更大的牌可以配上对，复杂度为 $O(14)$ ，也就是牌的种类数。   
然后考虑剩下的三种 $x$ 带 $y$ 。我们把所有 $x$ 带 $y$ 看成先选好 $x$ ，然后选 $y$ 。以就可以让两个人先只打三张或四张一样的牌，并且记录下三张牌或四张牌的个数，然后对应带的一些散牌后面处理。  
为这些散牌没有限制大小关系，所以实际上 $x$ 带 $y$ 的作用是把一些点数大导致配不上对的牌先消掉。一组三张牌可以带单牌或对子，一组四张牌可以带两张单牌，所以我们可以枚举打几次对子，注意到对子不用枚举各种打法，因为我们要尽量消掉可怜的大的牌，所以最优的方法是每次选择可怜最大的对子消掉；同样贪心的考虑,我们用网友最小的对子与其配对，显然也是最优的。  
最后还剩下一些三张牌或四张牌没有带上东西(设有 $a$ 组三张牌,b租四张牌)，因为前面枚举了对子，那么剩下的三张牌我们强制其带单牌，所以就是还可以选出至多 $a+2b$ 单牌配对，剩下的牌就只能用单牌一一对应去 $check$ 。  
具体来讲，如果在单牌 $check$ 过程中有 $c$ 张牌没被配对，那么如果满足 $c  \le a+2b$ ,那么这个就是合法方案，这是因为两个人都会有 $c$ 张牌没被配对好，那么这 $c$ 张牌被三张牌或四张牌带上就行了。   
代码：
```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<map>
#define ll long long
using namespace std;
char s[20];
map<char,int>mp;
void chu()
{
	mp['4']=0;
	mp['5']=1;
	mp['6']=2;
	mp['7']=3;
	mp['8']=4;
	mp['9']=5;
	mp['T']=6;
	mp['J']=7;
	mp['Q']=8;
	mp['K']=9;
	mp['A']=10;
	mp['2']=11;
	mp['w']=12;
	mp['W']=13;
}
int l[20]={4,4,4,4,4,4,4,4,4,4,4,4,1,1};
int ans,cnt[20],v[20];
bool check(int num,int sum,int x,int y)
{
	int sm=0;
	for(int i=13;i>=0;i--)sm-=v[i],sm=max(sm,0)+cnt[i];
	
	if(sm<=x+y*2)return true;
	int m,mm;
	bool flag=false;
	for(;num>=3;num--)
	{
		m=sum;
		while(m<=13&&v[m]<num)m++;
		while(m<=13)
		{
			mm=m+1;
			while(mm<=13&&cnt[mm]<num)mm++;
			if(mm>13)break;
			
			while(mm<=13)
			{
				v[m]-=num,cnt[mm]-=num;
				
				if(num==3)flag=check(num,m+1,x+1,y);
				else 
				{
					if(num==4)flag=check(num,m+1,x,y+1);
					else flag=check(num,m+1,x,y);
				}
				
				v[m]+=num,cnt[mm]+=num;
				mm++;
				if(flag)return true;
				while(mm<=13&&cnt[mm]<num)mm++;
			}
			m++;
			while(m<=13&&v[m]<num)m++;
		}
		
		sum=0;
	}
	
	if(x==0)return false;
	
	m=13,mm=0;
	while(m>=0&&v[m]<num)m--;
	
	while(mm<=13&&cnt[mm]<num)mm++;
	if(m<0||mm>13)return false;
	
	v[m]-=num,cnt[mm]-=num;
	flag=check(num,sum,x-1,y);
	v[m]+=num,cnt[mm]+=num;
	
	return flag;
}
void dfs(int x,int sum)
{
	if(sum==17)
	{
		if(check(4,0,0,0))ans++;
		return;
	}
	if(x>13)return;
	for(int i=0;i<=l[x]&&sum+i<=17;++i)
	{
		v[x]=i;
		dfs(x+1,sum+i);
		v[x]=0;
	}
}

int main()
{
	chu();
	
	scanf("%s",s+1);
	for(int i=1;i<=17;i++)cnt[mp[s[i]]]++,l[mp[s[i]]]--;
	dfs(0,0);
	printf("%d",ans);
}
```


---


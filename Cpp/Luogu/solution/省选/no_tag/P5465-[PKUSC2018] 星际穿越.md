# [PKUSC2018] 星际穿越

## 题目描述

有 $n$ 个星球，它们的编号是 1 到 $n$，它们坐落在同一个星系内，这个星系可以抽象为一条数轴，每个星球都是数轴上的一个点，特别地，编号为 $i$ 的星球的坐标是 $i$。

一开始，由于科技上的原因，这 $n$ 个星球的居民之间无法进行交流，因此他们也不知道彼此的存在。现在，这些星球独立发展出了星际穿越与星际交流的工具。对于第 $i$ 个星球，他通过发射强力信号，成功地与编号在 $[l_i,i-1]$ 的所有星球取得了联系(编号为 1 的星球没有发出任何信号)，取得联系的两个星球会建立 **双向** 的传送门，对于建立了传送门的两个星球 $u,v$，$u$ 上的居民可以花费 1 单位时间传送到 $v$，$v$ 上的居民也可以花费 1 单位时间传送到 $u$ ，我们用 $dist(x,y)$ 表示从编号为 $x$ 的星球出发，通过一系列星球间的传送门，传送到编号为 $y$ 的星球最少需要花费的时间。

现在有 $q$ 个星际商人，第 $i$ 个商人初始所在的位置是 $x_i$, 他的目的地是 $[l_i,r_i]$ 中的其中一个星球，保证 $l_i<r_i<x_i$ 。他会在这些星球中等概率挑选一个星球 $y$ (每个星球都有一样的概率被选中作为目的地)，然后通过一系列星球的传送门，**花费最少的时间**到达星球 $y$ 。商人想知道他花费的期望时间是多少？也就是计算 $\frac{1}{r_i-l_i+1}{\sum_{y=l_i}^{r_i}{dist(x_i,y)}}$ 。


## 说明/提示

样例对应的无向图如下：![ex](https://cdn.luogu.com.cn/upload/pic/63831.png)

对于 $20\%$ 的数据，满足 $n \leq 100$。

对于另 $25\%$ 的数据，满足 $n\leq 2000$

对于另 $25\%$ 的数据，满足 $n\leq 5000$

对于 $100\%$ 的数据，满足 $n,q\leq 3\times 10^5$

## 样例 #1

### 输入

```
7
1 1 2 1 4 6
5
3 4 6
1 5 7
1 2 4
1 2 6
1 3 5```

### 输出

```
3/2
13/5
3/2
2/1
1/1```

# 题解

## 作者：Fading (赞：37)

这是一道非常有趣的题。

可以先做$\texttt{[SCOI2015]国旗计划}$。

网络上很多题解都不清楚自己的写法为什么是对的，甚至连自己定义的数组是什么都不知道，非常误人子弟。他们都没想清楚。

所以我来发布一篇好了。

------------


设$\text{sum}_{i,j}$表示从$i$到$j\sim i$的所有点的最小步数之和。

首先，我们发现如果求出$\text{sum}_{i,j}$，

那么答案就是$\frac 1{r-l+1}(\text{sum}_{x,l}-\text{sum}_{x,r+1})$

怎么求呢？我们考虑一些显然的性质：

### 性质$1$

从$x$出发，可以一步到达最远的点为$l_x$，而且可以到达$[l_x,x-1]$的所有点。

废话！

### 性质$2$

如果$x$可以$k$步到达点$y$，那么一定可以到达$[y,x-1]$。

好像也很废话吧...



------------

我们考虑快速求$\text{sum}_{l,x}$

我们第一步从$x$开始跳，可以跳到哪里呢？

显然可以跳到最小的点为$l_x$。最大的呢？是$x$？naive!

注意到题目里的边是双向的！

所以，最大的点，应该是所以满足$l_k\leq x(k>x)$的$k$的最大值！

可能有点绕，不过多看几次就明白了。

感谢 @Fee_cle6418 的指正

然后我们第二次跳跃，可以到达最小的点是什么呢？

这里给出结论，是

$$\min_{i=l_x}^nl_i$$

你可能想问，为什么是$n$而不是$k_{\max}???$

事实上两者均可，但是前者表述起来方便。

因为，对于$(k_{\max}+1)\sim n$之间的所有点，其$l_i$对答案不可能造成贡献。因为它们的$l$值比$x$还大。

以此类推，设第$a(a>1)$次的可以到达最小的点为$b$，第$a+1$次跳跃可以到达最小的点就是

$$\min_{i=b}^nl_i$$

这样我们就可以用倍增优化了。

设$f_{i,0}$表示$\min\limits_{k=i}^nl_k,f_{i,j}=\min\limits_{k=f_{i,j-1}}^nl_k,g_{i,j}$表示$i$到$f_{i,j}\sim (i-1)$所有点的最小步数之和。

#### 具体转移

$$f_{i,j}=f_{f_{i,j-1},j-1}$$

$$g_{i,j}=g_{i,j-1}+g_{f_{i,j-1},j-1}+2^{j-1}(f_{i,j-1}-f_{i,j})$$

这个转移画画图就理解了。

具体求法实现看看代码吧，这里不方便叙述。


```
inline ll get(ll x,ll to){//表示x->(to~x-1)内所有点的答案。
    if (L[x]<=to) return x-to;//特判
    ll ans=x-L[x],tot=1;x=L[x];//第一跳跃比较特殊，上文有写到。
    //tot表示已经跳了多少步
    for (int i=20;i>=0;i--){
        if (f[x][i]>=to){//如果跳2^i次还无法到达
            ans+=tot*(x-f[x][i])+g[x][i];//先算上答案，而且这些点跳到起始点依旧需要跳tot步。
            tot+=(1<<i);x=f[x][i];
        }
    }
    if (x>to) ans+=tot*(x-to)+x-to;//最后没有跳满，算上残余答案。
    return ans;
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int f[302001][21],g[302001][21],L[302001],n,Q;
inline ll get(ll x,ll to){
    if (L[x]<=to) return x-to;
    ll ans=x-L[x],tot=1;x=L[x];
    for (int i=20;i>=0;i--){
        if (f[x][i]>=to){
            ans+=tot*(x-f[x][i])+g[x][i];
            tot+=(1<<i);x=f[x][i];
        }
    }
    if (x>to) ans+=tot*(x-to)+x-to;
    return ans;
}
signed main(){
    n=read();
    for (int i=2;i<=n;i++){
        L[i]=read();
    }
    f[n][0]=L[n];g[n][0]=n-L[n];
    for (int i=n-1;i>=2;i--){
        f[i][0]=min(f[i+1][0],L[i]);
        g[i][0]=i-f[i][0];
    }
    for (int j=1;j<=20;j++){
        for (int i=(1<<j);i<=n;i++){
            f[i][j]=f[f[i][j-1]][j-1];
            g[i][j]=g[i][j-1]+g[f[i][j-1]][j-1]+(1<<j-1)*(f[i][j-1]-f[i][j]);
        }
    }
    Q=read();
    while (Q--){
    	int l=read(),r=read(),X=read();
    	ll fz=get(X,l)-get(X,r+1),fm=(r-l+1),G=__gcd(fz,fm);
    	fz/=G;fm/=G;
    	printf("%lld/%lld\n",fz,fm);
    }
    return 0;
}

```



---

## 作者：_ZSR_ (赞：16)

## [[PKUSC2018]星际穿越](https://www.luogu.com.cn/problem/P5465)
可以想到，暴力做法就是把整张图建出来，然后求全源最短路，每次询问直接相加。显然，这样的做法是无法通过的，那么我们怎么优化它？
如果用图论的做法，我们似乎是无法做什么优化的，那么考虑图论以外的做法。

因为 $R$ 不一定与 $x$ 相邻，那么考虑是否转换成相邻好求一点。可以发现，该问题是满足前缀和的性质的，即我们可以用 $x$ 到 $[L,x-1]$ 的距离和减去到 $[R+1,x-1]$ 的距离和。

我们貌似还是无法想到怎么做，那么就模拟一下样例。我们发现，对于 $7$ 号节点，它到 $1$ 到 $6$ 号节点的距离依次是 $3,3,3,2,2,1$。这就启发我们是不是可以分段来做，因为答案序列是呈现出一段一段相等的样子。这就需要一个通过预处理之后，每次可以跳过一个区间，并且将这个区间的答案加上的高效的方法，那么这是不是倍增呢？

根据倍增的惯例，我们要定义若干个长度为 $N \times 20$ （本题 $n \leq 3 \times 10^5$ ，$2^{20}$ 够用了）的数组来记录从节点 $i$ 开始做 $2^j$ 次操作之后得到的我们需要的值。因为我们每次跳过一个区间，并且要把区间的贡献加到答案中，那我们是不是需要知道每次跳到哪里，跳过的区间的贡献是多少？

定义 $pre_{i,j}$ 表示从节点 $i$ 开始，跳 $2^j$ 步可以到达的最左边的节点是哪一个， $sum_{i,j}$ 表示从节点 $i$ 到区间 $[pre_{i,j},i-1]$ 的距离和。那么怎么更新呢？

对于节点 $x$ ，从它开始跳一步可以到达的最远距离显然是 $l_x$。我们记从 $x$ 跳一步可以到达的最右边的节点为 $rmax$。那么从 $x$ 跳两步可以到达的最左边的点应该是 $min_{k=l_x}^n l_k$。这里为什么不是到 $rmax$ 呢？其实这两种都可以，因为对于在 $rmax$ 右边的节点，它的 $l$ 值一定不会对答案产生影响，不然 $rmax$ 为什么不是它呢？

对于 $pre$ 数组的预处理很容易想到，类比倍增法求最近公共祖先，就是 $pre_{i,j}=pre_{pre_{i,j-1},j-1}$。但是对比我们上面所讲到的，我们会发现，我们两步都往左跳，可能没有先往右跳一步，再往左跳更优。仔细看后可以发现，其实区别就在于 $pre_{i,0}$ 的值。我们如果要保证 $pre_{i,0}$ 的结果正确，就不一定能保证后面的结果正确。反之，我们就无法保证 $pre_{i,0}$ 的结果是正确的。那这怎么办呢？其实我们只要保证后面的都是对的，对于一步就能到的节点求值时特判一下就可以了。因此， $pre_{i,0}$ 的公式为 $pre_{i,0}=min(pre_{i+1,0},l_i)$ （后面还会解释）。但是， $pre_{n,0}$ 就是 $l_n$，因为它右边没有其他节点了。

对于 $sum$ 的更新就要稍微想一下了，这里先给出递推公式：

$$sum_{i,0}=i-pre_{i,0}$$
$$sum_{i,j}=sum_{i,j-1}+sum_{pre_{i,j-1},j-1}+2^{j-1} \times (pre_{i,j-1}-pre_{i,j})$$ 

那么这是怎么来的呢？一步可以跳到的节点，距离肯定都是 $1$ 。对于跳 $2^{j}$ 步到的节点，我们将前 $2^{j-1}$ 步和后 $2^{j-1}$ 步拆开来计算，最后再加上 $i$ 到区间 $[pre_{i,j},pre_{i,j-1}]$ 的距离和。

模拟一下样例可以发现，对于 $6$ 号节点，从 $5$ 号节点跳到 $1$ 号节点更优，但是实际代码实现会跳到 $4$。但是 `pre[4][0]` 是 $1$，这样也保证了答案的正确性。那么为什么可以保证答案的正确性呢？因为对于任意一个直接连接 $i$ 的节点，它必然在 $i$ 的右边。那么它跳到 $i$ 和跳到 $i+1$ 所经过的距离是相等的（这里不考虑它是 $i+1$ 的情况，因为这样不会出现上述问题）。又因为我们初始化 $pre_{i,0}$ 的时候，我们是将 $l_i$ 和 $pre_{i+1,0}$ 取最小值的，那么我们跳到 $5$ 号节点再跳到 $1$，跟跳到 $4$ 号节点再跳到 $1$ 计算的距离是一样的，这样就保证了答案的正确性。

```
#include <bits/stdc++.h>
using namespace std;
const int N=300010;
int n,m;
int l[N];
int pre[N][20],sum[N][20];
inline void pre_work()
{
    pre[n][0]=l[n],sum[n][0]=n-l[n];
    for (int i=n-1;i>=2;--i)
    {
        pre[i][0]=min(pre[i+1][0],l[i]);
        sum[i][0]=i-pre[i][0];
    }
    for (int i=1;i<20;++i)
    {
        for (int j=(1<<i);j<=n;++j)
        {
            pre[j][i]=pre[pre[j][i-1]][i-1];
            sum[j][i]=sum[j][i-1]+sum[pre[j][i-1]][i-1]+(1<<(i-1))*(pre[j][i-1]-pre[j][i]);
        }
    }
}
inline int calc(int aim,int x)
{
    if (aim>=l[x]) return x-aim;//特判一步之内就能到的
    //特殊处理第一步
    int step=1,ans=x-l[x];
    x=l[x];
    for (int i=19;i>=0;--i)
    {
        if (pre[x][i]>=aim)
        {
            ans+=step*(x-pre[x][i])+sum[x][i];
            //对于区间[x,pre[x][i]]内的任一节点y，它对答案的贡献就是dist(x,y)+dist(start,x)(等于step)，start表示初始的x。那么每一个加起来就是上面的式子
            step+=(1<<i);
            x=pre[x][i];
        }
    }
    if (x>aim) ans+=step*(x-aim)+x-aim;
    return ans;
}
int gcd(int a,int b)
{
    return b>0?gcd(b,a%b):a;
}
int main()
{
    scanf("%d",&n);
    for (int i=2;i<=n;++i) scanf("%d",&l[i]);
    pre_work();
    scanf("%d",&m);
    while (m--)
    {
       int L,R,x;
       scanf("%d%d%d",&L,&R,&x);
       int dist=calc(L,x)-calc(R+1,x);
       int g=gcd(dist,R-L+1);
       printf("%d/%d\n",dist/g,(R-L+1)/g);
    }
    return 0;
}
```

---

## 作者：lhm_ (赞：12)

首先考虑题目的性质，发现点向区间连的边为双向边，所以也就可以从一个点向右跳到区间包含该点的点，如图所示：

![](https://s1.ax1x.com/2020/07/17/U6DHds.png)

但事实上向后跳其实是不优的，可以有更好的方法来节省花费：

![](https://s1.ax1x.com/2020/07/17/U6DoLQ.png)

因此我们发现一个点跳到其前一个区间的花费为 $1$，且在跳跃过程中不会向右跳，同时我们还证明了一个点向左的花费单调递增。

但是从起点进行第一步跳跃时，有可能会向后跳：

![](https://s1.ax1x.com/2020/07/17/U6rO7d.png)

其通过向后跳来到达一个更大的包含该点的区间，然后使下一步跳跃到达一个更向前的位置，第一步采取向后跳方案的花费为 $2$。

发现只有第一步是特殊的，所以单独来考虑第一步的情况。

设 $pos_i=\min\limits_{j=i}^n l_j$，即 $l_i$ 的后缀最小值，$pos_i$ 即为位置 $i$ 第一步采取向后跳方案来到达的最向前的位置。

对每个位置建可持久化线段树，线段树中对应的值为该位置不考虑第一步的花费，位置 $i$ 的线段树从位置 $pos_i$ 转移过来，然后在区间 $[1,i-1]$ 通过标记永久化来实现区间加一，表示不是第一步跳的花费。

查询时只需在 $l_x$ 所对应的线段树上查询区间 $[l,min(r,l_x-1)]$ 的和，其为位置 $x$  除去第一步的总花费，然后再加上第一步花费的贡献即可。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 300010
#define maxm 10000010
#define mid ((l+r)>>1)
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,q,tot;
int a[maxn],pos[maxn],rt[maxn],ls[maxm],rs[maxm];
ll sum[maxm],add[maxm];
ll gcd(ll a,ll b)
{
    return b?gcd(b,a%b):a;
}
void modify(int L,int R,int l,int r,int &cur)
{
    int x=++tot;
    ls[x]=ls[cur],rs[x]=rs[cur],add[x]=add[cur];
    sum[x]=sum[cur]+(min(R,r)-max(L,l)+1),cur=x;
    if(L<=l&&R>=r)
    {
        add[cur]++;
        return;
    }
    if(L<=mid) modify(L,R,l,mid,ls[cur]);
    if(R>mid) modify(L,R,mid+1,r,rs[cur]);
}
ll query(int L,int R,int l,int r,int cur)
{
    if(L>R) return 0;
    if(L<=l&&R>=r) return sum[cur];
    ll v=add[cur]*(min(R,r)-max(L,l)+1);
    if(L<=mid) v+=query(L,R,l,mid,ls[cur]);
    if(R>mid) v+=query(L,R,mid+1,r,rs[cur]);
    return v;
}
int main()
{
    read(n);
    for(int i=2;i<=n;++i) read(a[i]),pos[i]=a[i];
    for(int i=n-1;i>=2;--i) pos[i]=min(pos[i],pos[i+1]);
    for(int i=2;i<=n;++i) rt[i]=rt[pos[i]],modify(1,i-1,1,n,rt[i]);
    read(q);
    while(q--)
    {
        int l,r,x;
        ll g,v;
        read(l),read(r),read(x),v=r-l+1;
        v+=query(l,min(r,a[x]-1),1,n,rt[a[x]]);
        g=gcd(v,r-l+1),printf("%lld/%lld\n",v/g,(r-l+1)/g);
    }
    return 0;
}
```

---

## 作者：你的洛 (赞：7)

# [P5465[PKUSC2018]星际穿越](https://www.luogu.com.cn/problem/P5465)

一道倍增好题。

建议先把 [P4155 [SCOI2015]国旗计划](https://www.luogu.com.cn/problem/P4155) 做掉，并理解 LCA 的倍增方法和 ST 表的倍增方法，此题是二者的结合 ~~不然为什么是紫的~~。

先读题，首先给出一个数组 $L_x , x \in [2, n]$，对每一个 $ver_i \in [L_x, x]$，都会和 $ver_x$ 连一条双向边。给出 $m$ 次询问，求 $\sum_{y = l_i}^{r_i}dist(x,y)/(r_i - l_i + 1)$。

接着读样例
![](https://cdn.luogu.com.cn/upload/pic/63831.png)
实质上是在求 $ver_x$ 到 $ver_{l_i} \sim ver_{r_i}$ 的最短距离和

最后看一眼数据范围 $n,q \le 3\cdot 10^5$
可以猜出复杂度大致为 $O(q \log n)$。

## ~~我会暴力~~

对每次询问都进行计算 $\sum_{y = l_i}^{r_i}dist(x,y)$。

## 我会观察性质

手动模拟一下走法，可以发现 $dist(x,i)$ 随着 $i$ 的增大而不降。

## 我会优化

在文章的开头已经提到了这是一道倍增题，接下来就是如何使用倍增优化上述的算法。

首先我们观察到题目问的是 $l_i \sim r_i$ 的距离之和，很自然就会想到前缀和优化来快速计算，然而如果要存下这个 $sum$ 无论是在空间还是时间上都是无法接受的。

但是我们还有性质，观察如下的一列数
$$dist_x = \{4,4,4,4,4,3,3,3,3,2,2,2,2,2,2,1,1,1,0 \}$$
我们有两个问题，第一，这列数如何生成，第二，这列数有什么用。

### 如何计算 $dist$

设 $y_{x,i}$ 表示以 $ver_x$ 为起点，$dist_y$ 为 $i$ 的最小的 $y$。

$$\begin{cases}
  y_{x,0} = L_x \\
  y_{x,1} = \min \{ L_{y_{x,0}}, \cdots L_n \}\\
  \vdots
\end{cases}$$

关于为何 $\min$ 右边界为 $L_n$，其他题解已经解释得比较明白了，就不再赘述。

### $dist$ 有什么用
实际上这个算法的复杂度为 $O(n^2)$ 不足以通过此题，考虑优化。
~~都说了这是倍增题~~可以尝试优化为倍增。

设 $pre_{x,i}$ 为 $ver_x$ 左边 $dist_y$ 为 $2^i$ 的最左侧节点。

所以有
$$pre_{n,0} = L_n$$

$$pre_{i,0} = \min_i^n \{L_y\}$$

$$pre_{i,j} = pre_{pre_{i,j - 1},j - 1}$$

这样我们就可以使用倍增法来快速计算 $sum$ 了。

令 $sum_{i,j}$ 为以 $ver_i$ 为起点，左端点值为 $2^j$ 的前缀和

则有

$$sum_{i,0} = i - pre_{i,0}$$

$$sum_{i,j} = sum_{i,j - 1} + sum_{pre_{i,j - 1},j - 1} + 2 ^ {i - 1}\cdot(pre_{i,j - 1} - pre_{i,j})$$

那么最终倍增求解的前缀和便是：

$$S = S + sum_{p,i} + cnt \cdot (p - pre_{p,i})$$

最终复杂度为 $O((n+q)\log n)$。

## 一些细节

此题在计算时由于第一步在走出时不一定会向左边走，故需单独计算。

**不要忘记本题需要约分**。

## code

```cpp
// coding by cxz_0
#include <bits/stdc++.h>
#define awa cerr << "xlx is my superman!!!!!!!!!!!\n";
#define FOR(x,l,r) for(int (x) = (l); (x) <= (r); (x)++)
#define _FOR(x,l,r) for(int (x) = (r); (x) >= (l); (x)--)
#define gc getchar()
#define pb emplace_back
#define mp make_pair
#define pii pair<int, int >
#define PII pair<ll, ll >
#define fi first
#define se second
#define p_q priority_queue
// #define int ll
#define il inline
using namespace std;
typedef long long ll;

const int N = 3e5 + 5,MOD = 1e9 + 7;
int n, m, a[N], pre[N][20];
ll sum[N][20];

namespace cxz_0
{
    il int read(int x=0,bool f=0,char c=gc){while(!isdigit(c))f=c=='-',c=gc;while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=gc;return f?-x:x;}
    il void write(int x){if(x<0)x=-x,putchar('-');if(x>9)write(x/10);putchar(x%10+'0');}
    il ll readl(ll x=0,bool f=0,char c=gc){while(!isdigit(c))f=c=='-',c=gc;while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=gc;return f?-x:x;}
    il void writel(ll x){if(x<0)x=-x,putchar('-');if(x>9)writel(x/10);putchar(x%10+'0');}
    il int qpow(int a, int n, int p){int b=1;while(n){if(n&1)b=1ll*b*a%p;a=1ll*a*a%p;n>>=1;}return b;}
    il int max(int&a,int&b){return a>b?a:b;}
    il int min(int&a,int&b){return a<b?a:b;}
    il void swap(int&a,int&b){a^=b^=a^=b;}
    il int Mod(int x){return x>MOD?Mod(x-MOD):x;}
} using namespace cxz_0;

il ll cal (int fr, int to)
{
    if (a[fr] <= to) return fr - to;
    ll S = fr - a[fr];
    int cnt = 1;
    fr = a[fr];
    _FOR (i, 0, 19) if (pre[fr][i] >= to)
    {
        S += cnt * (fr - pre[fr][i]) + sum[fr][i];
        cnt += (1 << i);
        fr = pre[fr][i];
    }
    if (fr > to) S += cnt * (fr - to) + fr - to;
    return S;
}

signed main()
{
#ifndef ONLINE_JUDGE
    double start = clock();
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    n = read ();
    FOR (i, 2, n) a[i] = read ();
    int mi = a[n];
    pre[n][0] = a[n], sum[n][0] = n - a[n];
    _FOR (i, 1, n - 1) mi = min (mi, a[i]), pre[i][0] = mi, sum[i][0] = i - mi;
    FOR (j, 1, 19) FOR (i, 1, n) pre[i][j] = pre[pre[i][j - 1]][j - 1];
    FOR (j, 1, 19) FOR (i, 1, n) sum[i][j] = sum[i][j - 1] + sum[pre[i][j - 1]][j - 1] + (1 << (j - 1)) * (pre[i][j - 1] - pre[i][j]);
    m = read ();
    while (m--)
    {
        int l = read (), r = read (), x = read ();
        ll c = cal (x, l) - cal (x, r + 1), d = r - l + 1, g = __gcd (c, d);
        writel (c / g);
        putchar (47);
        writel (d / g);
        putchar (10);
    }
#ifndef ONLINE_JUDGE
    cerr << "Time: " << 1e3 * (clock() - start) / CLOCKS_PER_SEC << " ms" << endl;
    awa
#endif
    return 0;
}
```

---

## 作者：user100566 (赞：5)

> 很多题解仅仅把这道题的倍增优化 DP 当成类似树上倍增 LCA 的简单倍增。
>
> 但实际上直观定义出来的 DP 状态在某些方面上没有**最优子结构**性质（下文会展开叙述），并不适合倍增，而是需要进行一些特殊转化才能用倍增优化，本题解用**等效法**来构造合适的 DP 状态。

## 题目分析

### 形式化题意

形式化的，给定一个数轴上的 $n(n\le3\times10^5)$ 个点，编号 $1, 2, 3, \dots, n$，对每个点 $i$，给定 $l_i(l_i<i)$ ，将其与 $[l_i, i-1]$ 内的所有点连一条长度为 $1$ 的无向边，规定 $dist(x, y)$ 表示从 $x$ 到 $y$ 的最短路径长度。  
接下来给出 $q(q\le3\times10^5)$ 次询问，每次给出 $l<r<x$，求 $\frac{1}{r-l+1}\times\sum\limits_{i=l}^rdist(x, i)$，以最简分数形式输出。

*注：下文为了区分与联系相关的 $l_i$ 和与询问相关的 $l_x$，所有与联系相关的 $l_i$ 均含有下标（例如 $l_*$），与询问相关的全部用单独的 $l$*。

### 编码要求
显然，我们的主要任务对每次询问求出 $\sum\limits_{i=l}^rdist(x, i)$，然后使用 `std::__gcd` 约分即可。

考虑到 $n,q\le3\times10^5$，程序的复杂度应该是亚平方级的，例如 $O(n\log n), O(n\sqrt n)$（似乎这题单次分块的复杂度是 $O(n\sqrt n)$，但这题分块编码并不比倍增编码简单）。

---

## 暴力算法

容易想到 Floyd 多源最短路算法，复杂度 $O(n^3)$，显然不能通过。

但这个算法的真正意义是写对拍，因为 Floyd 编码很简单且不易写错，而且这题构造数据，将输入转为邻接矩阵也很简单，这里不再赘述。

## 正解 DP

首先容易想到 DP，因为传送过程存在明显的**无后效性**，前面如何到达 $i$ 与 $i$ 之后的传送路径无关。

但是，如果我们直观定义 $dp[i][j]$ 表示从 $i$ 出发走 $j$ 步能到达的最左端位置，会发现它并不符合最优子结构：$dp[i][j+1]$ 并不一定是最后通过 $dp[i][j]$ 到达的。
> 例如样例中以 $6$ 为起点，走 $1$ 步能到达的最左端位置为 $4$，走 $2$ 步能到达的最左端位置为 $1$，然而这个位置 $1$ 是从位置 $5$ 而非位置 $4$ 走过来的。

这限制了我们用倍增法优化这个 DP 状态，我们需要找到其它有用的 DP 状态。

### 引理 1

$\text{Lemma 1}$：**将第 $i$ 个星球的联系区间由 $[l_i, i-1]$ 改为 $[l_i, n]$，询问的答案不变**。  
换句话说，我们可以认为从 $i$ 出发可以一步到达的点为 $[l_i, n]$ 内的所有点，而不改变答案。

#### 证明

*注：下面各子引理的证明比较废话，读者可自行画图理解*。

显然 $\text{Lemma 1}$ 只是增加了边而没有删除边，那么答案不会增大。

##### 引理 1.1

$\text{Lemma 1.1}$：**如果最短路径存在向右的传送，那么所有向右的传送不在任何向左的传送之后**。

证明：假设在某一步向右传送($b\rightarrow c$)，在向左传送($b\leftarrow a$)之后，有以下情况：

1. $c=a$：无需多言。
1. $c<a$：可得 $l_a\le b<c<a$，那么可以直接 $c\leftarrow a$，那么原路径就不是最短路径了。
3. $c>a$：可得 $l_c\le b<a<c$，同样可以 $a\rightarrow c$，原路径不是最短路径。

根据 $\text{Lemma 1.1}$ 我们可以知道，最短路径要么一直向左传送，要么先向右传送再一直向左传送。

---

##### 引理 1.2

$\text{Lemma 1.2}$：**最短路径不存在连续多次向右的传送**。

证明：假设引理不成立，根据 $\text{Lemma 1.1}$，必然在开始就向右传送到起始点 $x$ 的右侧，由于终点在 $x$ 的左侧，必然存在唯一的一步 $a\xleftarrow{x}b$，满足 $a<x\le b$。
1. 若 $x=b$，无需多言。
2. 若 $x<b$，则 $l_b\le a<x<b$，那么可以直接 $x\rightarrow b$，再 $a\leftarrow b$ 两步到达 $a$，而那些连续多次向右的路径，至少花了 $3$ 步才到达 $a$。

根据 $\text{Lemma 1.1}, \text{Lemma 1.2}$，最短路径要么是一直向左传送，要么是先向右传送**一次**再一直向左传送。

---

##### 引理 1.3

$\text{Lemma 1.3}$：**如果最短路径以向右的传送开始，那么存在一个第一步相同的最短路径，其下一步向左传送的终点 $a<l_x$**。

证明：假设 $a\ge l_x$，有以下情况：

1. $a=x$，无需多言。
2. $a<x$，有 $l_x\le a<x$，那么可以从 $x$ 出发传送到 $a$，无需向右传送。
3. $a>x$，对于存在的唯一一步 $b\xleftarrow{x}c$，满足 $b<x\le c$，有以下情况：
   1. $x=c$，无需多言。
   2. $x<c$，有 $l_c\le b<x<c$，那么可以直接 $x\rightarrow c$, $b\leftarrow c$ 两步到达 $b$，而原路径至少花了两步才到达 $b$。

---

首先，在 $\text{Lemma 1}$ 的条件下，$\text{Lemma 1.1}, \text{Lemma 1.2}, \text{Lemma 1.3}$ 依然成立。

由于新条件只扩大了向右传送的区间，而没有改变向左传送的区间，因此新规则下的严格更短路径一定存在向右的移动 $x\rightarrow a$，并且 $x\rightarrow a$ 原本不合法。

根据 $\text{Lemma 1.3}$，存在一个至少同样长的严格更短路径，$x\rightarrow a$ 的下一步 $b\leftarrow a$ 满足 $b<l_x$，有 $l_a\le b<l_x\le x<a$，那么 $x\rightarrow a$ 是合法的，矛盾，因此不存在新规则下的严格更短路径，即答案不会减小，得证。

### 回归题目

接下来的讨论都在 $\text{Lemma 1}$ 的状态下。

$\text{Lemma 1.1}, \text{Lemma 1.2}$ 提到，仅有第一步可能是向右的，其它步都是向左的，为此我们可以特殊处理第一步：
> 显然一步能到达 $[l_x, n]$ 的所有节点，将其与询问区间 $[l, r]$ 取交集，得到从 $x$ 出发能一步到达的所有点，然后从询问 $[l, r]$ 中去掉这个交集，并将答案（这里的答案指 $\sum\limits_{i=l}^rdist(x, i)$，下同）加上区间长。
>
> 注意，可能有 $[l, r]\subset[l_x, n]$，那么询问区间内的所有点都可一步到达，正确更新答案后直接退出计算即可。

尽管我们只知道终点在 $l_x$ 左侧，但是容易贪心地找到第一步的固定终点：那就是使 $l_y$ 最小的 $y\in[l_x, n]$，显然其它第一步终点可直达的点，对于 $y$ 也是可直达的。注意这个 $y$ 可能在 $x$ 的左侧也可能在 $x$ 的右侧，但一定不是 $x$，因为 $l_{l_x}<l_x$ 恒成立，因此不用担心出现"原地跳跃"的情况。

定义 $s_i=\min\{l_y, i\le y\le n\}$，那么第一步的固定终点的 $l_*$ 值等于 $s_{l_x}$，贡献最小值的 $y$ 并不重要。

将等效起点转移到 $y$ 上，剩余的 $[l, r]$ 上的点都要走一步 $x\rightarrow y$，答案增加 $r-l+1$，然后将起点转移到 $y$ 上即可。

---

考虑第 $j+1$ 步的起点，即第 $j$ 步的终点，我们发现选择 $j$ 步可达的所有点中 $l_i$ 最小的点一定不劣，和上面选择第一步的终点是同一个道理。

但是这样还是太麻烦了，为什么不把那个最优点计入到 $j$ 步可达的左端点上呢？换言之，尽管最左端点不是下一步的好"跳板"，但它可以"借用"右边的点做"跳板"。

### 引理 2

$\text{Lemma 2}$：**如果起点 $x$ 满足 $\nexists x'>x, l_x'<l_x$，那么将第 $i$ 个星球的联系区间由 $[l_i, n]$ 改为 $[s_i, n]$，询问的答案不变**。

#### 证明

*注：证明还是比较废话，同样容易画图理解。*

用归纳法证明，显然新条件的答案不会增大。  
因此我们只需要证明新条件下 $j$ 步可达的点，在原条件下可以至多 $j$ 步到达即可。

- 当 $j=1$ 时，因为 $s_x=l_x$，否则与引理前提矛盾，引理显然成立。
- 当 $j>1$ 时，$j-1\ge1$，设 $j-1$ 步可达的最左端点为 $a$（由归纳法两种条件下都是一样的），列出两种条件下计算得到的 $j$ 步可达最左端点：
  - 原条件：$\min\{l_i, a\le i\le n\}$
  - 新条件：$\min\{s_i, a\le i\le n\}$  
    考虑 $s$ 的递推定义： $s_i=\min\{s_{i+1}, l_i\}, 1\le i<n$，上式等价于 $s_a=\min\{l_i, a\le i\le n\}$
    
  形式上都一模一样，引理成立。

---

我们第一步完成后的等效起点其实就符合 $\text{Lemma 2}$ 的前提。

### DP 状态定义

在 $\text{Lemma 2}$ 的状态下，定义 $dp[i][j]$ 表示从 $i$ 出发 $j$ 步可达的最左端点。

由于允许使用右侧的节点代替做"跳板"，新的 DP 状态具有明显的最优子结构特性：$dp[i][j+1]$ 可以从 $dp[i][j]$ 转移过来，转移方程如下：

$$dp[i][1] = s_i$$
$$dp[i][j+j']=dp[dp[i][j]][j'], j, j'>1$$

有了新的最优子结构特性，容易得到倍增优化的转移方程：

$$dp[i][2^0] = s_i$$
$$dp[i][2^{j+1}]=dp[dp[i][2^j]][2^j]$$

### 求解答案

首先按照前面的方法特殊处理第一步，然后跳到新的等效起点，这个等效起点符合 $\text{Lemma 2}$ 的前提，可以使用 $dp$ 加速跳跃。

接下来用倍增跳跃用最少步数 $j$ 到达 $r$，方法和树上倍增求 LCA 的第二阶段类似，如果从当前点 $i$ 出发走 $2^j$ 不能到达目标，则走 $2^j$ 步，并移动到 $dp[i][2^j]$ 上。  
这里仍然使用等效起点的思路，将起点转移到 $dp[i][2^j]$ 上，然后答案增加 $2^j\times(r-l+1)$。

做完上面的跳跃后，一定可以只花一步就能到达 $r$：
> 如果 $dp[x][0]\le l$，即从当前等效起点出发可以一步到达 $[l, r]$ 的所有点，那么答案增加 $r-l+1$，然后直接退出计算即可。
>
> 如果 $dp[x][0]>l$，答案增加 $r-dp[x][0]+1$，将等效起点转移到 $dp[x][0]$ 上，答案再增加 $dp[x][0]-l$，合起来还是增加 $r-l+1$。

---

但是接下来的部分怎么处理呢？由于接下来的连续的点全部都要到达恰好一次，我们可以定义 $sum[i][j]$ 表示从 $i$ 出发到达所有 $j$ 步可达的点的总最短距离（包不包括 $i$ 都没事，因为到自己的最短距离为 $0$），同样是在 $\text{Lemma 2}$ 的状态下。

转移方程如下：

$$sum[i][1] = i-dp[i][1]$$
$$sum[i][j+j'] = sum[i][j]+j'\times (dp[i][j]-dp[i][j+j'])+sum[dp[i][j]][j'], j, j'>1$$

中间的 $j'\times (dp[i][j]-dp[i][j+j'])$ 是根据等效起点法得到的，请自行思考。

倍增优化后的转移方程如下；

$$sum[i][2^0] = i-dp[i][2^0]$$
$$sum[i][2^{j+1}]=sum[i][2^j]+2^j\times(dp[i][2^j]-dp[i][2^{j+1}])+sum[dp[i][2^j]][2^j], j>1$$

这样，我们可以继续套用同样的倍增方式：如果走 $2^j$ 步仍未到达 $i$，则走下这 $2^j$ 步，然后答案增加 $sum[x][2^j]$，等效移动起点到 $dp[x][2^j]$，答案再增加 $2^j\times(dp[x][2^j]-l)$。

---

最后还剩下一片散块，散块内的点全部可以一步从当前等效起点 $x$ 到达，答案增加 $x-l$，终于结束了！

## 代码

警示：$\sum\limits_{i=l}^rdist(x, i)$ 可能超出 $\text{int32}$ 的范围，不仅仅是 $sum$ 的定义，相关计算过程的每一项可能超出 $\text{int32}$ 的表达式都要注意类型正确。

[云剪贴板存档](https://www.luogu.com.cn/paste/nzvz6h78)

[AC 记录](https://www.luogu.com.cn/record/196451462)

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long int64;

int n, L[300001], q;   // 用大 L 区分询问小 l 

int s[300001];         // s[i] : L[i~n] 的最小值
int dp[300001][19];    // dp[i][j] : 从 i 出发走 j 步可达的最左端点 
int64 sum[300001][19]; // sum[i][j] : 从 i 出发到 j 步可达的所有点的最短距离和

void init(){
	s[n] = L[n];
	dp[n][0] = L[n];
	sum[n][0] = n-L[n];
	for(int i=n-1; i; --i){
		s[i] = min(s[i+1], L[i]); // 递推求 s 
		dp[i][0] = s[i];          // dp 的初始状态 
		sum[i][0] = i-dp[i][0];   // sum 的初始状态 
	}
	for(int j=1; j<=18; ++j){
		for(int i=1; i<=n; ++i){
			// dp 的倍增递推转移方程 
			dp[i][j] = dp[dp[i][j-1]][j-1];
			// sum 的倍增递推转移方程 
			sum[i][j] = sum[i][j-1]+sum[dp[i][j-1]][j-1]+(1ll<<(j-1))*(dp[i][j-1]-dp[i][j]);
		}
	}
}
int64 solve(int l, int r, int x){
	int64 ans = 0;
	// 处理第一步可达的点 
	if(L[x]<=r){ 
		if(L[x]<=l){    // 一步可以到达所有点 
			return r-l+1;
		}else{
			ans += r-L[x]+1;
			r = L[x]-1; // 从询问区间中删除交集 
		}
	}
	// 转移等效起点 
	ans += r-l+1;
	x = L[x];
	// 第一部分：r 所在的散块 
	for(int j=18; ~j; --j){
		if(dp[x][j]>r){
			ans += (r-l+1)*(1ll<<j);
			x = dp[x][j];
		}
	}
	ans += r-l+1;
	if(dp[x][0]<=l) return ans;
	// 第二部分：[l, r] 中间的完整块 
	x = dp[x][0];
	for(int j=18; ~j; --j){
		if(dp[x][j]>l){
			ans += sum[x][j]+(1ll<<j)*(dp[x][j]-l);
			x = dp[x][j];
		}
	}
	// 第三部分：l 所在的散块 
	ans += x-l;
	return ans;
}

int main(){
	scanf("%d", &n);
	L[1] = 1; // 注意 L[1] 要手动赋值 
	for(int i=2; i<=n; ++i) scanf("%d", L+i);
	init();
	scanf("%d", &q);
	while(q--){
		int l, r, x;
		scanf("%d%d%d", &l, &r, &x);
		int64 sum = solve(l, r, x), len=r-l+1;
		int64 gcd = __gcd(sum, len);
		printf("%lld/%lld\n", sum/gcd, len/gcd);
	}
	return 0;
}

```

---

## 作者：JeffZhao (赞：4)

考虑如果从 $x$ 出发只跳一步，最远能跳到哪里。最远能跳到 $l_x$。

考虑如果从 $x$ 跳两步，最远能跳到哪里。这时候 $x$ 有可能先往后跳，然后再往前跳，也有可能两次都往前跳。因此，最远能跳到 $\min_{i = l_x}^{n} l_i$ 。

我们设第二次最远能跳到的位置是 $d$ ，那么第三次能够跳到的最远的位置是 $\min_{i = d}^{n} l_i$。

我们发现我们只需要倍增类似第二步的操作即可。

设 $f_{i , j}$ 表示从 $[i , n]$ 选出 $l_k$ 最小的 $k$，从 $k$ 开始跳到 $l_k$，然后从 $l_k$ 开始重复这个操作 $2^j - 1$ 次跳到的位置。

$g_{i , j}$ 表示从 $[i , n]$ 选出 $l_k$ 最小的 $k$，从 $k$ 开始跳到 $l_k$，然后从 $l_k$ 开始重复这个操作 $2^j - 1$ 次整个过程的代价。 

设 $calc(x , t)$ 表示从 $x$ 跳到 $[t , x - 1]$ 的代价之和，最终答案为 $calc(x , l) - calc(x , r + 1)$ 

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>

using namespace std;

const int N = 3e5 + 10;

int n , l[N] , q , p[22][N];
long long g[22][N];

long long gcd(int a , int b) {
    if(b == 0) return a;
    return gcd(b , a % b);
}

long long calc(int x , int t) {
    if(l[x] <= t) return x - t;
    long long ans = x - l[x];
    int tot = 1; x = l[x];
    for(int i = 20 ; i >= 0 ; -- i) {
        if(p[i][x] > t) {
            ans += 1ll * tot * (x - p[i][x]) + g[i][x];
            x = p[i][x] , tot += (1 << i);
        }
    }
    ans += 1ll * (tot + 1) * (x - t);
    return ans;
}

int main(void) {

    scanf("%d" , &n);

    for(int i = 2 ; i <= n ; ++ i) {
        scanf("%d" , &l[i]);
    }

    memset(p , -1 , sizeof(p));

    p[0][n] = l[n] , g[0][n] = n - l[n];

    for(int i = n - 1 ; i >= 2 ; -- i) {
        p[0][i] = min(p[0][i + 1] , l[i]);
        g[0][i] = i - p[0][i];
    }

    for(int j = 1 ; j <= 20 ; ++ j) {
        for(int i = 1 ; i <= n ; ++ i) {
            if(p[j - 1][i] != -1) {
                p[j][i] = p[j - 1][p[j - 1][i]];
                g[j][i] = g[j - 1][i] + g[j - 1][p[j - 1][i]] + 1ll * (1 << (j - 1)) * (p[j - 1][i] - p[j][i]);
            }
        }
    }

    scanf("%d" , &q);

    while(q -- ) {
        int st , ed , x;
        scanf("%d%d%d" , &st , &ed , &x);
        long long ans = calc(x , st) - calc(x , ed + 1) , base = ed - st + 1 , d = gcd(ans , base);
        ans /= d , base /= d;
        printf("%lld/%lld\n" , ans , base);
    }

    return 0;

}


```

---

## 作者：ModestCoder_ (赞：4)

重要性质：对于某个点$x$，必定是$x$到$[y,x)$中所有点的距离为1，$x$到$[z,y)$中所有点距离为2……
(满足$z<y<x$)

首先想70分暴力做法（性质的不完全利用）

处理出$dist_{i,j}$表示$i$到$j$的最短路

策略是最多向右走一次，尽可能向左走

复杂度$O(n^2)$

发现答案可以套用前缀和形式求得

想一想是否可以换一种思路：对于某个点$x$，先处理出跳一次能跳到的最左的点，在处理出跳两次能跳到最左的点，根据重要性质，每次肯定是向左边一块一块区间的更新

那么在进一步思考，是否可以用倍增进行优化操作？

如果可以，每个点只需要$O(logn)$的复杂度，就过了

可以记录$pre_{i,j}$表示从点$i$跳$2^j$步最左的点

$sum_{i,j}$表示$i$到从$(i-1)$到点$i$跳$2^j$步最左的点距离和

倍增预处理
询问$O(logn)$求得

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 300010
#define LL long long
using namespace std;
int n, pre[maxn][21], power[21], L[maxn];
LL sum[maxn][21];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

LL gcd(LL n, LL m){ return !m ? n : gcd(m, n % m); }

LL calc(int x, int l){
	if (L[x] < l) return x - l;
	LL ans = x - l, d = 0;
	x = L[x];
	for (int i = 20; i >= 0; --i)
		if (pre[x][i] >= l) ans += sum[x][i] + (x - pre[x][i]) * d, x = pre[x][i], d |= power[i];
	return ans + (x - l) * (d + 1);
}

int main(){
	n = read();
	for (int i = 2; i <= n; ++i) L[i] = read();
	L[1] = 1, pre[n + 1][0] = n;
	for (int i = n; i; --i) sum[i][0] = i - (pre[i][0] = min(pre[i + 1][0], L[i]));
	power[0] = 1;
	for (int i = 1; i <= 20; ++i) power[i] = power[i - 1] << 1;
	for (int j = 0; power[j + 1] <= n; ++j)
		for (int i = 1; i <= n; ++i)
			pre[i][j + 1] = pre[pre[i][j]][j], sum[i][j + 1] = sum[i][j] + sum[pre[i][j]][j] + power[j] * (pre[i][j] - pre[i][j + 1]);
	int Q = read();
	while (Q--){
		int l = read(), r = read(), x = read();
		LL p = calc(x, l) - calc(x, r + 1), q = r - l + 1, g = gcd(p, q);
		printf("%lld/%lld\n", p / g, q / g);
	}
	return 0;
}
```


---

## 作者：toolazy (赞：3)

~~感谢 Side 推题，这里属于是重投一遍蹭社贡来了（~~

---

我们来考虑一个东西：

$$\sum_{v=l}^rdist(u,v)=\sum_{v=l}^udist(u,v)-\sum_{v=r+1}^udist(u,v)$$

记：

$$\text{sum}(u,l)=\sum_{v=l}^udist(u,v)
\\\Rightarrow\sum_{v=l}^rdist(u,v)=\text{sum}(u,l)-\text{sum}(u,r+1)$$

我们的目标就是快速求解 $\text{sum}$。

---

进入下一步之前，我们需要发掘一些最短路更深的性质。

思考一下，两点之间的最短路，究竟能长什么样子，又究竟应该怎么走呢？（终点在起点左边）

首先，我们可以发掘出一个重要的性质：

- 不可能连续往右走两步（或者更多步）；不可能从 $i$ 开始走了两步之后走不到 $i$ 的左边。

	证明是简单的——假如走到了 $i$ 后往右走了，然后又走了若干步才到 $j$，然后才从 $j$ 跨过了 $i$ 到了左边...
    
    既然 $j$ 能到 $i$ 左边，那为什么 $i$ 不直接到 $j$ 呢？
    
    所以，任何走两步、三步甚至更多步的走法，都可以规约成只往右走一次。
    
接下来，可以得到另一个性质：

- $\textbf{Lemma 1.}$（路径方向的单调性）路径里至多在开头往右走一步；只要开始往左，势必就是一个劲往左，不可能中途往右。

	假设掉头后，往右走到的点是 $w$，那么我们势必能够找到路径中另外两个直接相连的点 $j\larr i$，且 $j<w<i$，这样的话 $w$ 就是 $i$ 可一步达的，明显更优。
    
但是这些还不够，我们需要一个最重要的性质：

- $\textbf{Lemma 2.}$（贪心的正确性）除了最后一步以外，每一步都贪心地往 $l_i$ 最小的 $i$ 走，这样势必最优。

	$l_i$ 越小，意味着走过去之后的可选项越多，就可以更快地扩张可达点的区间；相反，如果路径中有一个点不是这样走的，那么它的 $l_i$ 不够大，被最优解给包含了，那么势必劣。
    
通过这个思路，我们还可以知道一个事：

- $\textbf{Lemma 3.}$（距离的单调性）对于任意的 $w<v<u$，势必有 $dist(v,u)\le dist(w,u)$。

	根据我们贪心的思想，每一次的移动、每一次的扩张，产生的可达区间都是一段连续的，$[1,u]$ 的后缀，所以势必正确。
    
---

接下来，我们该考虑着手解决下一个问题：求 $u$ 在 $k$ 步之内可达的点集（考虑 $\text{sum}$ 的求解，故不考虑 $>u$ 的点）。

根据 $\textbf{Lemma 3.}$，我们会知道，这个集合势必是连续的，是 $[1,u]$ 的一段后缀，并且长度随 $k$ 单调递增。

那么，我们设 $f(u,k)$ 表示从 $u$ 开始，根据 $\textbf{Lemma 2.}$ 的理论，走 $k$ 步到达的点（$l_i$ 最小的 $i$）是什么。

为了方便我们的递推，我们钦定，$f$ 的路径链，不可以往右走，包括开头。

这个东西非常简单，明显会有：

$$f(u,a+b)=f\big(f(u,a),b\big)$$

因为，相同位置的下一步一定相同，没有后效性，这是根据 $\textbf{Lemma 2.}$ 和 $\textbf{Lemma 3.}$ 得到的。

所以，这个东西可以轻松地使用倍增做，只要再提前套一个 ST 表，把 $f(\cdot,2^0)$ 做一下就可以了，可以参考笔者最下面的实现。

---

由于 $f$ 的定义是只能往左走，所以根据 $\textbf{Lemma 1.}$，我们还需要分讨来解决开头往左还是往右的问题。

实际上并不难，我们可以通过 $\textbf{Lemma 2.}$ 对贪心的阐述，来得知第一步的方向：

如果 $u$ 的右边存在 $v$ 使得 $l_v\le u$，那么它可以参与竞争；而其中 $l_v$ 最小的 $v$ 的 $l_v$ 如果可以超过 $w\in[l_u,u]$ 中最小的 $l_w$，那我们的第一步就走 $v$，否则往左走。

说白了还是比谁的 $l$ 更小，这里也是套用上面的 ST 表就可以。

---

可能还不够，我们还需要倍增一些其它的东西：

$g(u,a+b)=g\big(f(u,a),b\big)$，表示从 $u$ 开始 $k$ 步及之内，可以到达的编号最小的点，初始状态是 $g(u,2^0)=l_u$，就这样。

$h(u,k)=\displaystyle\sum_{i=g(u,k)}^udist(u,i)$，或者说，$h(u,k)=\text{sum}\big(u,g(u,k)\big)$。

准备好了吗孩子们？接下来就是 $h$ 的递推公式辣（$v=f(u,k)$）：

$$h(u,a+b)=h(u,a)+h(v,b)+a\cdot\big(v-g(v,b)\big)-(a+1)\cdot\big(v-g(u,a)\big)$$

~~仔细看应该能看懂（陶艺~~

剩下的就是一些很恶心的分讨和倍增板子了，于是做完了。

---

最后放一个笔者调了两天的实现，感觉用了结构体看着可爱很多：

```c++
int st[MAXN][MAXP];

inline int __minl(int u, int v) { return l[u] < l[v] ? u : v; }

inline int minl(int l, int r) {
	int p = __builtin_log2(r - l + 1), len = 1 << p;
	return __minl(st[r][p], st[l + len - 1][p]);
}

struct QwQ { int f, g, h, from, step; } qwq[MAXN][MAXP];

QwQ merge(QwQ b, QwQ a) {
	QwQ res(b);
	res.from = a.from, res.step += a.step;
	res.h = a.h + b.h + a.step * (b.from - b.g)
		- (a.step + 1) * (b.from - a.g);
	return res;
}

void initializaiton() {
	for (int i = 1; i <= n; i ++) {
		st[i][0] = i;
		for (int p = 1, l = 1; i - l - l >= 0; p ++, l <<= 1)
			st[i][p] = __minl(st[i][p - 1], st[i - l][p - 1]);
	}
	for (int p = 0; p < MAXP; p ++) qwq[1][p] = {-1, 1, 0, 1, 0};
	for (int u = 2; u <= n; u ++) {
		qwq[u][0] = {minl(l[u], u), l[u], u - l[u], u, 1};
		for (int p = 1; ; p ++) {
			qwq[u][p] = merge(qwq[qwq[u][p - 1].f][p - 1], qwq[u][p - 1]);
			if (qwq[u][p].f == -1) {
				for (int q = p + 1; q < MAXP; q ++) qwq[u][q] = qwq[u][p];
				break;
			}
		}
	}
}

inline int sum(int ll, int u) {
	int __goleft = qwq[u][0].f, __goright = minl(u, n);
	if (l[__goleft] <= l[__goright]) {
		QwQ res = {u, u, 0, u, 0};
		for (int p = MAXP - 1; p >= 0; p --) {
			if (res.f == -1 || qwq[res.f][p].g < ll) continue;
			res = merge(qwq[res.f][p], res);
		}
		return res.h + (res.g - ll) * (res.step + 1);
	}
	if (ll >= l[u]) return u - ll;
	QwQ res = {__goright, __goright, 0, __goright, 0};
	for (int p = MAXP - 1; p >= 0; p --) {
		if (res.f == -1 || qwq[res.f][p].g < ll) continue;
		res = merge(qwq[res.f][p], res);
	}
	res.h += (res.g - ll) * (res.step + 1);
	res.h += u - ll;
	return res.h - (__goright - l[u]);
}
```

最后感谢 [@Dovish](https://www.luogu.com.cn/article/2baaj4vb)，其实这篇题解大部分都是贺 TA 的理论（

---

## 作者：Falling_Sakura (赞：3)

> [Blog 传送门](https://white.fallingsakura.love/)

> [题目传送门](https://www.luogu.com.cn/problem/P5465)


# 思路

由题意得，每次从 $i$ 可以跳一步到最小的点就是 $l_{i}$。

由于是双向的，因此只要满足 $l_{j}\le{i}(j>i)$ 那么便可以从 $j$ 一步跳到 $i$，记满足条件的最大的 $j$ 为 $rmax$。

那么定义：

$f_{i,0}$ 代表从 $i$ 开始走 $2^{0}$ 次可以到达的最小的点。

那么 $f_{i,j}$ 代表从 $i$ 开始走第 $2^{j}$ 次可以到达的最小的点。

$f_{i,0}=l_{i}$，也就是从 $i$ 走 $1$（$2^{0}$）次所能到达的最小的点。

再走一步呢？

那就是 $f_{i,1}=\min_{k=l_{i}}^{n}l_{k}$。

为什么是从 $i$ 跳一步所能到的最左端的点到 $n$ 这个区间内寻找更小的左端点呢？

为什么不是到 $rmax$ 呢？

其实就是 $rmax$，但是 $rmax$ 的左端点已经是满足条件最大的了，再往右，也就是从 $rmax+1$ 到 $n$ 都不会满足条件，也就是说这些点连 $i$ 都一步跳不到，怎么可能一步跳到比 $l_{i}$ 还小的点呢？

为了方便，所以写到 $n$，这样就不用特意计算 $rmax$ 了。

所以递推我们得到：

$$f_{i,j}=f_{f_{i,j-1},j-1}$$

也就是说，从 $i$ 开始走第 $j$ 次可以到达的最小的点就是从 $i$ 开始走 $2^{j-1}$ 次可以到达的最小的点到所有点之间的这些点，从这些点再跳 $2^{j-1}$ 步所能到达的最小的点。

这就有**倍增**的意思了。

**但是，但是：**

连续向左跳可不一定比先向右再向左跳更优。

所以 $f_{i,0}=\min(l_{i},f_{i+1,0})$，其中 $f_{n,0}$ 一定为 $l_{n}$。

这个需要倒着往前推，这样就可以都保证是最优解。

对于从 $n$ 开始的第一步，它所能到达的最小的点只能是它的 $l$ 值，因为它没法向右了。

这样的话从 $i$ 右边的 $j$ 号点先跳到 $i$ 还是先跳到 $i+1$，下一步都是一样的，因为贪心的缘故，假如 $i+1$ 往后跳更优，也就是 $f_{i+1,0}$ 更小，那么 $i$ 的下一步将和 $i+1$ 的下一步一致（因为 $f_{i,0}$ 的时候有个取 $\min$ 操作）。

根据答案形式为求区间期望，考虑前缀和优化。

用 $sum_{i,j}$ 代表从 $i$ 到 $f_{i,j}\sim{(i-1)}$ 这些点的最小步数之和，也就是从 $i$ 转移 $2^{j}$ 步后所到达的最小的点到 $i-1$ 这段区间内到 $i$ 的最小步数之和（**步数=转移次数**）。

**转移：**

$$sum_{i,0}=i-f_{i,0}$$

因为只用跳一次，区间内点的个数即转移代价。

$$sum_{i,j}=sum_{i,j-1}+sum_{f_{i,j-1},j-1}+2^{j-1}\times({f_{i,j-1}-f_{f_{i,j}}})$$

因为分了两次来跳，其实就是点的个数再把需要跳两遍的点再加一遍。

在跳的过程中记录一下需要累加的次数即可。

![](https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307021750966.png)

![](https://falling-sakura1-1316699389.cos.ap-nanjing.myqcloud.com/image/202307021753506.png)

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+7;
int l[N];
int f[N][22],sum[N][22];
int n,m;
void init()
{
    f[n][0]=l[n],sum[n][0]=n-l[n];//画下图即理解,
    for(int i=n-1;i>=2;i--)//从n-1开始处理
    {
        f[i][0]=min(f[i+1][0],l[i]);//跳一步
        sum[i][0]=i-f[i][0];
    }
    for(int i=1;i<22;i++)
        for(int j=(1<<i);j<=n;j++)
        {
            f[j][i]=f[f[j][i-1]][i-1];//递推式
            sum[j][i]=sum[j][i-1]+sum[f[j][i-1]][i-1]+(1<<(i-1))*(f[j][i-1]-f[j][i]);
        }
    return;
}
int dist(int x,int y)//目标点，当前位置
{
    if(x>=l[y]) return y-x;//特判一步就能走到的
    int sp=1,ans=y-l[y];//先跳一步
    y=l[y];
    for(int i=20;i>=0;i--)
    {
        if(f[y][i]>=x)//还没跳到
        {
            ans+=sp*(y-f[y][i])+sum[y][i];//前缀和，有些数会被加 sp 遍，sum 存的仅为走一步之和
            sp+=(1<<i);//走的这些都得加上
            y=f[y][i];//跳过来
        }
    }
    //下一次跳跳过了就停止转移，那么可能是刚好这一步跳到了，也可能还差一点
    if(y>x)//差一点，补上（类似倍增求 LCA ）
    {
        ans+=(sp+1)*(y-x);
    }
    return ans;
}
int gcd(int a,int b)
{
    return b>0?gcd(b,a%b):a;//辗转相除求 gcd
}

int main()
{
    cin>>n;
    for(int i=2;i<=n;i++)
    {
        scanf("%d",&l[i]);
    }
    init();
    cin>>m;
    while(m--)
    {
        int L,R,X;
        scanf("%d%d%d",&L,&R,&X);
        int d=dist(L,X)-dist(R+1,X); // X 为起点，从起点到左端点-起点到右端点 +1（其实就是前缀和）
        int g=gcd(d,R-L+1);
        printf("%d/%d\n",d/g,(R-L+1)/g);
    }
    return 0;
}
```

---

## 作者：云浅知处 (赞：3)

简单题。

考虑一个 $\text{dist}(x,y)$ 咋算，不妨设 $x>y$，发现如果一步走不到 $y$，那么肯定是从 $x$ 开始，找到他能走到的所有 $j$ 中 $l_j$ 最小的 $j$，然后跳到 $j$；直到当前的 $l_x\le y$。对每个 $x$ 算出这个 $j$，记为 $p_x=j$；对所有 $(x,p_x)$ 连边可以得到一棵树，$\text{dist}(x,y)$ 就是 $x$ 的最近的使得 $l_u\le y$ 的祖先 $u$ 与 $x$ 的距离 $+1$。

现在考虑怎么算 $\sum_{i=1}^k\text{dist}(i,x)$，发现只需要定位出 $k$ 的位置即最近一个 $l_u\le k$ 的祖先 $u$，剩下的就是一个 $\sum \text{dep}_x-\text{dep}_v+1$ 的形式，拆成 $k\times (\text{dep}_x+1)$ 与 $\sum -\text{dep}_v$ 即可。后面那一项可以预处理。

只需要树上倍增定位 $k$ 即可；找 $x$ 对应的 $j$ 只需要实现 RMQ，这是因为 $x$ 往左能到 $j\in[l_x,x-1]$ 的所有 $j$，往右能到 $l_j\le x$ 的所有 $j$，二者都形成一段区间。

> 实际上，只需要实现原序列上 $l$ 的 RMQ，然后在 $[l_x,n]$ 中取最小值即可。这是因为如果取到了左边显然合法，如果取到了右边，由于左边的最小值已经有 $l_x-1$ 了，所以如果取到右边那肯定不会超过这个数，说明取到的点仍然能到达 $x$。

时间复杂度 $O((n+q)\log n)$。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int mod=1e9+7;
int ksm(int x,int y,int p=mod){
	int ans=1;
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
int randint(int l,int r){return rand()*rand()%(r-l+1)+l;}
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}
void Mod(int &x){if(x>=mod)x-=mod;}

const int N=3e5+5;
const int K=20;
vector<int>G[N];
int ed[N],ST[K][N],fa[N][K],Lg[N],n,q;

void ST_build(){
	for(int i=2;i<=n;i++)Lg[i]=Lg[i>>1]+1;
	for(int i=1;i<=n;i++)ST[0][i]=i;
	for(int i=1;i<K;i++){
		for(int j=1;j+(1<<i)-1<=n;j++){
			if(ed[ST[i-1][j]]<ed[ST[i-1][j+(1<<(i-1))]])ST[i][j]=ST[i-1][j];
			else ST[i][j]=ST[i-1][j+(1<<(i-1))];
		}
	}
}
int qmin(int l,int r){
	int k=Lg[r-l+1];
	if(ed[ST[k][l]]<ed[ST[k][r-(1<<k)+1]])return ST[k][l];
	return ST[k][r-(1<<k)+1];
}

int val[N],dep[N];
void dfs(int u){
	for(int i=1;i<K;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int v:G[u]){
		fa[v][0]=u,dep[v]=dep[u]+1;
		assert(ed[u]<ed[v]);
		val[v]=val[u]+(ed[v]-ed[u])*dep[u];
		dfs(v);
	}
}
int get(int u,int k){
	for(int i=K-1;i>=0;i--)if(ed[fa[u][i]]>k)u=fa[u][i];
	if(ed[u]<=k)return u;
	else return fa[u][0];
}
int ans(int u,int k){
	int v=get(u,k);
	assert(ed[v]<=k);
	return k*(dep[u]+1)-(val[v]+(k-ed[v]+1)*dep[v]);
}

int gcd(int x,int y){return y?gcd(y,x%y):x;}

signed main(void){

#ifdef YUNQIAN
	freopen("in.in","r",stdin);
#endif

	n=read();ed[1]=0;
	for(int i=2;i<=n;i++)ed[i]=read();
	ST_build();
	for(int i=2;i<=n;i++){
		int p=qmin(ed[i],n);
		G[p].emplace_back(i);
	}
	dfs(1);
	q=read();
	while(q--){
		int l=read(),r=read(),x=read();
		int w=ans(x,r)-ans(x,l-1),len=r-l+1;
		int g=gcd(w,len);w/=g,len/=g;
		cout<<w<<'/'<<len<<'\n';
	}

	return 0;
}
```

---

## 作者：Dovish (赞：2)

首先观察到题目中每次询问都要求点到区间的最短路径之和，并且边权都为 1，还要点向区间连边。这其实提示我们这道题和图论的关系不大。

由于连边是紧贴着一个点向其前缀的一段后缀连边（我们不妨称 $i$ 和 $[L_i,i)$ 相连），我们可以挖掘出以下性质：

1. 若开始向左边走，是不可能再向右边走。

证明：不妨设路径为 $u\to v\to w$。那么如果 $u>v$ 且 $w>v$，$u$ 都可以一步到达 $w$。

2. 一开始最多向右边走一步。

证明：设 $u$ 右边所有点中，连边的区间的 $L$ 最小的点为 $v$。显然 $u$ 可以一步到 $v$。我们如果从 $v$ 再向后走一定是更劣的。


然后观察询问，这个形式一看就不好求，不妨换成 $\sum_{l\le y<x_i}dis(y,x_i)-\sum_{r<y<x_i}dis(y,x_i)$。

所以我们可以将边定向，只从右连向左。然后讨论一下第一步要不要跳到右边某个点就好了。

观察定向之后的最短路，一定是从右向左单调不减的。对于最短距离为 $s$ 的一段区间，我们可以根据其中 $L$ 最小的点找到最短距离为 $s+1$ 的区间。

这个每次向左拓展一个区间的做法让我们想到了倍增。但是直接做是没法的，因为每次拓展的区间都和上一次有关。显然这个信息是不独立的。

怎么办呢？我们考虑记录下一段区间 $L$ 最小的那个点而不是左端点。这样区间虽然重复了，但是这样维护倍增的转移就是对的了。而对于重复部分，我们也是可以简单地容斥掉的。

具体而言，我们设 $f_{u,i}$ 表示距离 $u$ 为 $2^i$ 的区间中 $L$ 最小的点，$v$ 表示 $f_{u,i-1}$。显然有：

$$f_{u,i}=f_{v,i-1}$$

类似地，我们记录 $g_{u,i}$ 表示距离其 $2^i$ 的区间中的左端点,记录 $h_{u,i}$ 为 $\sum_{g_{u,i}\le j<u}dis(j,u)$。

则有：

$$
g_{u,i}=g_{v,i-1}\\
h_{u,i}=h_{v,i-1}+h_{u,i-1}+(v-g_{v,i-1})2^{i-1}-(v-g_{u,i-1})(2^{i-1}+1)
$$

于是就做完了。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(register int i=a;i<=b;++i)
#define low(i,a,b) for(register int i=a;i>=b;--i)
#define edge(i,u) for(int i=head[u];i;i=e[i].next)
#define lc(u) tre[u].ls
#define rc(u) tre[u].rs
#define pii pair<int,int>
#define pdd pair<double,double>
#define mp(a,b) make_pair(a,b)
using namespace std;
const int N=3e5+10,inf=1e9;
struct vl
{
	int l,pos,val;//分别对应上文中的 g,f,h
}f[N][20];
int st[20][N];
int lg[N];
int max_right_l[N];
int L[N],n,q;
vector<int>input[N];
vector<int>back[N];
struct cmp{bool operator()(int x,int y){return (L[x]!=L[y])?(L[x]<L[y]):x<y;}};
int get(int x,int y)
{
	if(L[x]!=L[y])
	return L[x]<L[y]?x:y;
	return min(x,y);
}
void build_st()
{
	rep(i,2,n+1)
    lg[i]=lg[i>>1]+1;
    rep(i,1,n)st[0][i]=i;
	rep(w,1,19) 
	rep(i,1,n)
	st[w][i]=get(st[w-1][i],st[w-1][min(n,i+(1<<(w-1)))]);
}
int query(int l,int r)
{
    int g=lg[r-l+1];
    return get(st[g][l],st[g][r-(1<<g)+1]);
}
int getans(int to,int u)
{
	int res=0;
	int base=0;
	low(i,19,0)
	{
		if((i==0||f[u][i].l!=f[u][i-1].l)&&f[u][i].l>to)
		{
			res+=f[u][i].val+(u-f[u][i].l)*base;
			base+=(1<<i);
			res-=(f[u][i].pos-f[u][i].l)*(base+1);
			u=f[u][i].pos;
		}
	}
	res+=(u-to)*(base+1);
	return res;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	L[1]=1;
	rep(i,2,n)
	cin>>L[i];
	build_st();
	rep(i,1,n)
	{
		int to=query(L[i],i-1);
		if(i==1)to=1;
		f[i][0]={L[i],to,i-L[i]};
		rep(w,1,19)
		{
			int v=f[i][w-1].pos;
			f[i][w].pos=f[v][w-1].pos;
			f[i][w].l=f[v][w-1].l;
			f[i][w].val=f[v][w-1].val+(v-f[v][w-1].l)*(1<<w-1)+f[i][w-1].val-(v-f[i][w-1].l)*((1<<w-1)+1);
		}
		input[L[i]].push_back(i);
		back[i].push_back(i);
	}
	set<int,cmp>right;
	rep(i,1,n)
	{
		for(auto u:input[i])right.insert(u);
		for(auto u:back[i])right.erase(u);
		max_right_l[i]=*right.begin();
	}
	cin>>q;
	rep(i,1,q)
	{
		int l,r,x;
		cin>>l>>r>>x;
		int val=0,dis2=f[x][1].l,dis1=f[x][0].l;
		if(max_right_l[x]&&L[max_right_l[x]]<dis2)
		{
			int v=max_right_l[x];
			if(l>=dis2)val+=getans(l,x);
			else val+=getans(l,v)-(v-x)+dis1-l;
			if(r+1>=dis2)val-=getans(r+1,x);
			else val-=getans(r+1,v)-(v-x)+dis1-(r+1);
		}
		else val=getans(l,x)-getans(r+1,x);
		int GCD=__gcd(val,r-l+1);
		cout<<val/GCD<<"/"<<(r-l+1)/GCD<<'\n';
	}
	return 0;
}
```

---

## 作者：Fracture_Dream (赞：2)

# 题目传送门

[[PKUSC2018] 星际穿越](https://www.luogu.com.cn/problem/P5465)

# 简述题意
给定一张 $n$ 个点的无向图和 $q$ 次询问，每一个点 $i$ 与 $\forall j  \in [l_i , i -1]$ 都存在一条长度为 $1$ 的无向边，每次询问给定 $l_i,r_i,x_i$，求 $\frac{1}{r_i-l_i+1}{\sum_{y=l_i}^{r_i}{\operatorname{dist(x_i,y)}}}$  的最简分数形式。

- $n,q\leq 3\times 10^5，1\le l_i < r_i < x_i \le n$
# 思路
### Subtask1 & 2
直接把图建出来，对每一个点暴力跑一遍 $\operatorname{dijkstra}$，每次询问累和即可。
时间复杂度 $O(n^2\log n)$，可以得到 $45pts$。

### Subtask3
与正解**强相关**！

先把图降维成序列问题，把 $n$ 个点抽象成 $n$ 个元素的序列 $a$。


考虑贪心，由于 $l_i < r_i < x_i$，因此一定尽可能往右跳，才能最小化步数。
不妨令 $nxt_{i,j}$ 表示从 $i$ 开始跳 $j$ 步，能到达的最小点。

显然 $nxt_{i,0} = l_i$，然而 $nxt_{i,1}$ 一定等于 $l_{l_{x_i}}$ 嘛？

不是。如果有一个点 $j \in [l_{x_i},i-1]$ 满足 $l_j \le l_{l_{x_i}}$，那么跳到 $j$ 一定比跳到 $l_{x_i}$ 更优，因此有：

$$nxt_{i,j}=\min\{l_{nxt_{i,j-1}},...,l_{i-1},l_i,l_{i+1},...,l_n\}$$

为什么要考虑 $[i+1,n]$ 这一部分呢？因为有可能往右跳比往左跳更优，举个例子可能更形象：

![](https://cdn.luogu.com.cn/upload/image_hosting/9zylmmw1.png)

假如 $5$ 是起点，$1$ 是终点，那么很显然 $5 \rightarrow 6$ 比 $5 \rightarrow 4$ 更优。

因此枚举每个点作为起点，进行一次上述过程即可。
最坏时间复杂度 $O(n^2)$，可以得到 $75pts$。
### Subtask4
上述做法中，发现我们的时间复杂度瓶颈在于 $j$ 这一维，而且正解时间复杂度应该是 $O(n\log n)$，这都启发我们倍增。

不妨令 $dp_{i,j}$ 表示从 $i$ 开始跳 $2^j$ 步能够到达的最小点。

那么有经典倍增式 $dp_{i,j} = dp_{dp_{i,j-1},j-1}$。

然后显然有 $dp_{i,0}=l_i$ ？大多数人的第一想法可能都是这样初始化，然而这显然是错的！
再举个例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/avdn3dgz.png)

如上图，如果这样初始化就有 $dp_{5,1}=dp_{dp_{5,0},0}=dp_{3,0}=2$，然而显然可以 $5 \rightarrow 4 \rightarrow 1$，为什么会出错呢？  

由 $\operatorname{subtask3}$ 的做法可得，我们没有考虑往右跳的情况。

然而每个点都会出现往右跳的情况吗？
显然不是。具体地，有如下引理：

> 引理：
> 在任意最优情形下，只有起点可能往右跳，其他点一定只会向左跳。
证明也是显然的，如果当前点往右跳到 $x$ 更优，那为何不直接从上一个点（一定会有前驱点）跳到 $x$ 呢？

因此，我们只需要考虑起点往右跳的情况，就可以保证递推的重要性，因此 $dp_{i,0}=\min\{l_i,l_{i+1},...,l_n\}$（至于那些 $i$ 往右跳无法到达的点一定有 $l_{j} > i$，所以考虑了也无所谓），发现这样初始化代入上述例子也是对的。

考虑如何回答询问。不妨令 $sum_{i,j}$ 表示 $i$ 到 $[dp_{i,j},i-1]$ 的距离和，注意 $sum$ 并**未包含向右跳的贡献**，这一部分要在后面单独讨论！！！
                        
那么有 $sum_{i,0}=i-dp_{i,0}$。
- 先考虑 $[dp_{i,j-1},i-1]$ 这一部分的贡献，即 $sum_{i,j-1}$。
- 再考虑 $[dp_{i,j},dp_{i,j-1}-1]$ 这一部分的贡献，我们已知从 $dp_{i,j-1}$ 这个点走到这些点的距离，即为 $sum_{dp_{i,j-1},j-1}$，所以只需要从 $i$ 走 $2^{j-1}$ 到 $dp_{i,j-1}$，一共要走 $dp_{i,j-1}-dp_{i,j}$ 次。

总结一下有：
$$sum_{i,j}=sum_{i,j-1}+sum_{dp_{i,j-1},j-1}+2^{j-1}\times(dp_{i,j-1}-dp_{i,j})$$

注意，在上述推导过程中，我们并未考虑从起点往右跳的贡献，这一部分会在后文详细阐述。

求得 $dp,sum$ 以后，即可处理询问：

![](https://cdn.luogu.com.cn/upload/image_hosting/wbi7j2s3.png)

该函数旨在求出求出 $x$ 走到 $[lpos, x-1]$ 的距离和。

有注释的部分应该很好理解，瓶颈在于框出的两行代码，网上大多数题解这一部分都没有写明白。

为什么要强制走到 $l_x$ 呢？注意到，我们之前 $sum$ 的推导并没有考虑 $x$ 最开始往右跳的贡献，所以我们要强制选择一个点，那么为什么选择了 $l_i$ 呢？
- 如果 $x$ 最开始向右跳到 $y$ 更优，那么从 $l_x$ 出发可以且一定会跳到 $y$，就等价于 $x$ 跳到 $y$，区别在于 $l_x$ 出发可以顺便处理这一部分的贡献。 
- 如果 $x$ 最开始向左跳到 $x$ 更优，同理，从 $l_x$ 出发也一定会跳到 $y$。

通俗的讲，先强制选择 $l_x$ 其作用就在于等着被替代成其他点。表面上从 $x$ 跳到了 $l_x$，实际是从 $x$ 跳到了 $y$。
即 $x \rightarrow l_x \rightarrow y$ 等价于 $x \rightarrow y$，但前者可以处理向右跳的贡献。

结合样例可以更好理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/x5tapw5k.png)

如果 $6$ 为起点，那么我们会强制跳到 $4$，表面上错过了可以直达 $1$ 的 $5$，但是 $4$ 是可以且一定会向右跳到 $5$ 的，因为我们的倍增是最优的。

# 代码
一道非常好的倍增题！！！

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 3e5 + 5;
int n , q , dp[MAXN][20] , sum[MAXN][20] , l[MAXN];
int solve(int x , int lpos) { // 求出 x 走到 [lpos , x-1] 的距离和
	if (l[x] <= lpos) return x - lpos; // 特判一步走到的情况
	int ans = x - l[x] , step = 1;
	x = l[x];
	for (int i = 19 ; i >= 0 ; i --) { 
		if (dp[x][i] >= lpos) {// 只要还未到达终点，就不断往前倍增跳
			ans += (x - dp[x][i]) * step + sum[x][i]; // 和 sum 的推导类似
			x = dp[x][i] , step += (1 << i); // step 表示当前走过的步数
		}
	}
	step ++;
	if (x > lpos) ans += (x - lpos) * step; // 处理不能恰好到达 x 的情况
	return ans;	
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr) , cout.tie(nullptr);
	cin >> n;
	for (int i = 2 ; i <= n ; i ++) cin >> l[i] , dp[i][0] = l[i];
	for (int i = n - 1 ; i >= 2 ; i --) dp[i][0] = min(dp[i + 1][0] , dp[i][0]);
	for (int i = 1 ; i <= n ; i ++) sum[i][0] = i - dp[i][0];
	for (int j = 1 ; j <= 19 ; j ++) {
		for (int i = 2 ; i <= n ; i ++) {
			dp[i][j] = dp[dp[i][j - 1]][j - 1];
			sum[i][j] = sum[i][j - 1] + sum[dp[i][j - 1]][j - 1] + (dp[i][j - 1] - dp[i][j]) * (1 << j - 1);
		}
	}
	cin >> q;
	while(q --) {
		int ql , qr , x;
		cin >> ql >> qr >> x;
		int div = (qr - ql + 1) , w = solve(x , ql) - solve(x , qr + 1);
		int g = __gcd(div , w);
		w /= g , div /= g; // 约分
		cout << w << '/' << div << '\n';
	}
    return 0;
}
```

---

## 作者：liyancen (赞：1)

# 题解

## 由前缀和引发的思考

看到这道题的求和公式的瞬间，前缀和的思想就上来了。如果说我们知道了 $l_i\rightarrow x$ 这个区间和 $r_i+1 \rightarrow x$ 的所有点到 $x$ 点的距离的和（我们先暂时记为 $w_1$，$w_2$），那么 $w_1-w_2$ 的答案在除以 $r_i-l_i+1$ 所得到的结果不就是我想要的答案吗？

那么现在的问题就变成了如何快速求解这个值。

因为根据题目所说，我们知道：对于一个点 $i$ 而言的话，$l_i\rightarrow(i-1)$ 这个区间内的所有点都是可以一步就到 $i$ 的，同理 $i$ 也可以一步到达这些点。又因为题目中再次给出了这样的提示：保证 $l_i<r_i<x_i$，所以说，我们完全可以用倍增的思想维护出一个点跳某一个步数可以到达的最右边的点，然后这样不断的逼近 $l_i$ 和 $r_i$。

因此，我们可以设出这样的一个状态：$f_{i,j}$ 表示从 $i$ 出发，跳 $2^j$ 步所能到达的最左边的点。同时这个状态的初始化也很好写：对于 $f_{i,n}$ 而言，不可能有其他的点可以帮助它，所以说它的答案就是 $f_{i,0}=l_n$（请注意：这里的 $l_n$ 指的是第一次输入时的 $l$，并不是第二次的）。其余的点正常初始化就可以了：$f_{i,0}=\min(f_{i+1},l_i)$。

同时 $f$ 数组的更新也会采用倍增的思想，这也是非常简单的 $f_{i,j}=f_{f_{i-1,j},j}$。下面给出部分的代码：

```cpp
f[n][0]=l[n];
for (int i=n-1;i>=1;i--){
	f[i][0]=min(f[i+1][0],l[i]);
}
for (int j=1;j<=20;j++){
	for (int i=(1<<j);i<=n;i++){
		f[i][j]=f[f[i][j-1]][j-1];
	}
}
```

但是不难发现，即使这样写，时间复杂度也会爆炸，因为每次我们都要对每个区间内的答案单独求一遍，这样的时间复杂度和裸跑最短路算法其实是没有区别的。所以说我们还要优化。

## 由前缀和引发的探索

既然我们最初的想法是通过前缀和来求解，那为什么我们不能再有一个前缀和的倍增数组呢？然后通过这个倍增数组来得到最终的答案？说做就做！

尝试一下，我们设 $sum_{i,j}$ 表示从 $f_{i,j}$ 到 $(x-1)$ 的这个区间内所有点的最短路的和。不难发现这样的一个初始化的式子：$sum_{n,0}=n-l_n$，这是必然的，原因和上面一样。那么其余的点怎么初始话呢？

不难发现，我们在求解 $sum_{i,j}$ 的时候，$sum_{i,j-1}$ 和 $sum_{f_{i,j-1},j-1}$ 的答案肯定是得到了的，所以说我们答案就是会分成两段，一段是右侧的 $sum_{i,j-1}$ 一段是左侧的，但是左侧的答案是不完整的，所以说得增加。不难发现左侧总共有 $f_{i,j-1}-f_{i,j}$ 个点，而这些点是必须要经过右侧的 $2^{j-1}$ 次方的路径然后才能到达 $i$ 的，所以说我们就会有这样的状态转移方程：$sum_{i,j}=sum_{i,j-1}+sum_{f_{i,j-1},j-1}+(f_{i,j-1}-f_{i,j})\times 2^{j-1}$。

这里其实有点绕，可以画个图理解理解。下面给出示范代码：

```cpp
f[n][0]=l[n],sum[n][0]=n-l[n];
for (int i=n-1;i>=1;i--){
    f[i][0]=min(f[i+1][0],l[i]);
	sum[i][0]=i-f[i][0];
}
for (int j=1;j<=20;j++){
	for (int i=(1<<j);i<=n;i++){
		f[i][j]=f[f[i][j-1]][j-1];
		sum[i][j]=sum[i][j-1]+sum[f[i][j-1]][j-1]+(1<<(j-1))*(f[i][j-1]-f[i][j]); 
	}
}
```

## 由前缀和引发的结果

现在这些都维护出来了，那么我们只需要用前缀和倍增数组求得两段的答案就可以了。而求得答案的过程也是非常的简单的，也是非常的模板，其思路和上面前缀和倍增数组预处理的理解是差不多的，只不过要注意一下特判的问题，因为可能距离非常的近，导致就算是最小的前缀和数组也覆盖不了。

具体的细节就看代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=3e5+10;
int l[INF],sum[INF][30],f[INF][30];

int get(int to,int x){
	if (l[x]<=to)return x-to;
	int step=1,ans=x-l[x];
	x=l[x];
	for (int i=20;i>=0;i--){
		if (f[x][i]>=to){
			ans+=step*(x-f[x][i])+sum[x][i];
			step+=(1<<i);
			x=f[x][i];
		}
	}
	if (x>to)ans+=step*(x-to)+x-to;
	return ans;
}
int main(){
	int n;
	cin>>n;
	for (int i=2;i<=n;i++){
		cin>>l[i];
	}
	f[n][0]=l[n],sum[n][0]=n-l[n];
	for (int i=n-1;i>=1;i--){
		f[i][0]=min(f[i+1][0],l[i]);
		sum[i][0]=i-f[i][0];
	}
	for (int j=1;j<=20;j++){
		for (int i=(1<<j);i<=n;i++){
			f[i][j]=f[f[i][j-1]][j-1];
			sum[i][j]=sum[i][j-1]+sum[f[i][j-1]][j-1]+(1<<(j-1))*(f[i][j-1]-f[i][j]); 
		}
	}
	int q;
	cin>>q;
	for (int i=1;i<=q;i++){
		int l1,r1,x;
		cin>>l1>>r1>>x;
		int up=get(l1,x)-get(r1+1,x),down=r1-l1+1;
		int GCD=__gcd(up,down);
		cout<<up/GCD<<"/"<<down/GCD<<endl;
	}
	return 0;
}
```

## 题外话

@[Monkey_Dog](https://www.luogu.com.cn/user/772808)
这波没有写橙题的题解了吧。

---

## 作者：Sternenlicht (赞：1)

题目大意：

$n$ 个星球，可视为数轴上的 $1 \sim n$，第 $i$ 个星球可以到达 $[l_i,i-1]$ 中的任意一个星球，且与这个区间内的所有星球有双向边。

从 $u$ 到 $v$ 或从 $v$ 到 $u$ 需要花费 $1$ 个单位时间，$dist(x,y)$ 表示从 $x$ 到 $y$ 所花费的最少时间。

有 $q$ 个商人，第 $i$ 个商人在星球 $x_i$，他的目的地为 $[l_i,r_i]$ 区间内的一个星球，且 $l_i<r_i<x_i$。

等概率选取星球 $y$，通过传送门抵达 $y$ 且用时最短，求期望时间。

思路：

1. 更新： 点 $u$ 跳到前一个区间的花费为 $1$，且跳跃过程中不会向右跳，且一个点向左跳的花费单调递增（第一步是特殊的）。 设 $mi_i$ 表示 $l_i$ 的后缀最小值，即对位置 $i$ 第一步采取向后跳的方式到达最向前的位置。可对每个位置维护一个可持久化线段树，线段树的值为当前位置不考虑第一步的花费。$i$ 的线段树从 $mi_i$ 转移，在区间 $[1,i-1]$ 进行标记永久化，实现区间加一， 即不是第一步跳的花费。
 
2. 查询：在 $l_x$ 对应的线段树上，查询区间 $[l,min(r,l_x-1)]$ 的和，值为 $x$ 除去第一步的总花费，再加上第一步花费即可。

```cpp
#include <bits/stdc++.h>
namespace IO{
	#define LL long long
	inline LL read(){
		LL x=0,f=1;char c=getchar();
		for (;!isdigit(c);c=getchar())if (c=='-')f=-1;
		for (;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
		return x*f;
	}
	inline void write(LL x,char c='\n'){
		if (x){
			if (x<0)x=-x,putchar('-');
			char a[30];short l;
			for (l=0;x;x/=10)a[l++]=x%10^48;
			for (l--;l>=0;l--)putchar(a[l]);
		}else putchar('0');putchar(c);
	}
}using namespace IO;
using namespace std;

#define int long long
const int N = 3e5+10;
struct Segmt{int l,r,sum,val;}tree[N<<5];
int n,q,cnt,a[N],mi[N],root[N];
int gcd(int m,int n){return m%n==0?n:gcd(n,m%n);}
void update(int &now,int l,int r,int x,int y){
	tree[++cnt]=tree[now];
	tree[cnt].sum=tree[cnt].sum+min(r,y)-max(l,x)+1;
	now=cnt;int mid=(l+r)>>1;
	if (x<=l&&r<=y)return tree[now].val++,void();
	if (x<=mid)update(tree[now].l,l,mid,x,y);
	if (mid<y) update(tree[now].r,mid+1,r,x,y);
}
int query(int now,int l,int r,int x,int y){
	if (x>y)return 0;
	if (x<=l&&r<=y)return tree[now].sum;
	int mid=(l+r)>>1,res=tree[now].val*(min(r,y)-max(l,x)+1);
	if (x<=mid)res+=query(tree[now].l,l,mid,x,y);
	if (mid<y) res+=query(tree[now].r,mid+1,r,x,y);
	return res;
}
signed main(){
	n=read();
	for (int i=2;i<=n;i++)a[i]=mi[i]=read();
	for (int i=n-1;i>=2;i--)mi[i]=min(mi[i],mi[i+1]);
	for (int i=2;i<=n;i++)update((root[i]=root[mi[i]]),1,n,1,i-1);
	q=read();
	for (int i=1;i<=q;i++){
		int l=read(),r=read(),x=read(),len=r-l+1;
		len+=query(root[a[x]],1,n,l,min(r,a[x]-1));
		int d=gcd(len,r-l+1);
		write(len/d,'/'),write((r-l+1)/d);
	}
	return 0;
}
```

再附上 ST 表的代码，其中 $pre_{i,j}$ 表示从点 $i$ 跳 $2^j$ 步后最左的点，$sum_{i,j}$ 表示 $i$ 到“从 $i-1$ 到 $i$ 跳 $2^j$ 步后最左的点”的距离和。

```cpp
#include <bits/stdc++.h>
namespace IO{
	#define LL long long
	inline LL read(){
		LL x=0,f=1;char c=getchar();
		for (;!isdigit(c);c=getchar())if (c=='-')f=-1;
		for (;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
		return x*f;
	}
	inline void write(LL x,char c='\n'){
		if (x){
			if (x<0)x=-x,putchar('-');
			char a[30];short l;
			for (l=0;x;x/=10)a[l++]=x%10^48;
			for (l--;l>=0;l--)putchar(a[l]);
		}else putchar('0');putchar(c);
	}
}using namespace IO;
using namespace std;

#define int long long
const int N = 3e5+10;
int pre[N][30],sum[N][30],a[N],lg[N],n,q;
int gcd(int m,int n){return m%n==0?n:gcd(n,m%n);}
int query(int x,int l){
	if (a[x]<l)return x-l;
	int res=x-l,fl=0;x=a[x];
	for (int i=20;i>=0;i--)
		if (pre[x][i]>=l)
			res+=sum[x][i]+(x-pre[x][i])*fl,x=pre[x][i],fl|=lg[i];
	return res+(x-l)*(fl+1);
}
signed main(){
	n=read(),lg[0]=1,a[1]=1,pre[n+1][0]=n;
	for (int i=2;i<=n;i++)a[i]=read();
	for (int i=n;i>=1;i--)
		sum[i][0]=i-(pre[i][0]=min(pre[i+1][0],a[i]));
	for (int i=1;i<=20;i++)lg[i]=lg[i-1]<<1;
	for (int j=0;lg[j+1]<=n;j++)
		for (int i=1;i<=n;i++)
			pre[i][j+1]=pre[pre[i][j]][j],
			sum[i][j+1]=sum[i][j]+sum[pre[i][j]][j]+lg[j]*(pre[i][j]-pre[i][j+1]);
	q=read();
	for (int i=1;i<=q;i++){
		int l=read(),r=read(),x=read(),len=r-l+1;
		int val=query(x,l)-query(x,r+1),d=gcd(val,len);
		write(val/d,'/'),write(len/d);
	}
	return 0;
}
```

---

## 作者：LCat90 (赞：0)

这篇题解主要解释一些自己做题时的疑惑点，希望能帮到各位。

> 性质：如果当前走到了 $y<x$，那么一定可以使用同样的步数走到 $x$。

所以我们完全可以在从 $y$ 走到 $y'$ 的时候发现中间有一个点 $x$ 更优，直接从 $y$ 退到 $x$ 即可。

根据这个可撤销性，我们就得到了一个贪心思路：每次可以走到的最远点，就是 $\min _{i=l_y}^n l_i$。

但是考虑起点的特殊情况。由于刚开始只有一个点无法进行撤销操作。所以我们可以考虑花费一步向右走，走到一个最远的点 $P$。

可知：一定 $l_p \le x$，且 $\forall p'>p,l_p>x$。

那么走到这里之后，接下来就像上面一样走即可，注意由于第一步可以直接向左，所以至少是 $l_x$，然后如果需要撤回一种情况是撤回点 $t$ 在 $[l_x,x]$ 中，那么可以到达不影响。但是如果 $t>x$ 就要像上面说的那样先花一步向右走，但是由于这种情况的前提是有 $l_t<l_y,y\in [l_x,x]$。所以肯定是比直接左走更优的。

综上所述，我们一定可以在第二步的时候就达到“全可撤销态”。

然后就像其它题解说的一样，倍增即可。

---

## 作者：TTpandaS (赞：0)

先考虑从 $r$ 走到 $l(l<r)$ 的最小步数应该怎么计算。

发现问题形式与 [国旗计划](https://www.luogu.com.cn/problem/P4155) 基本相同，问题都可以抽象为：

对于每个点 $i$，能到达的区间为 $[l_i,r_i]$，问从 $l$ 走到 $r$ 的最小步数。

对于这种题，只需要倍增算出第 $i$ 个点走 $2^j$ 步能到达的最远的点即可。

在倍增前，需要找出走不同步数所能到达的最远的点的关系。

对于国旗计划这道题，如果从第 $i$ 个点开始走 $j$ 步所能到达的点为 $k$，那么走 $j+1$ 步所能到达的点为为 $\max_{p=i}^{k}r_p$。

但是此题与国旗计划不同的是，每个点 $i$ 与可达区间建立的是双向边，因此可以通过往回跳使得可达的点更远，所以我们需要找到一个点 $i$ 能向后跳一步所能走到的最远的点 $I$，其中 $I$ 为满足 $l_I \leq i$ 的最大值。

因此，如果从第 $i$ 个点开始走 $j$ 步所能到达的点为 $k$，那么走 $j+1$ 步所能到达的点为为 $\min_{p=k}^{I}l_p$。

接着考虑如何处理区间最小步数之和。

定义 $ans_{i,j}$ 表示第 $i$ 个点走到点集 ${k|f_{i,j} \leq k \leq i}$ 的最小步数之和，其中 $f_{i,j}$ 表示第 $i$ 个点走 $2^j$ 步所能到达的最远位置。

那么在倍增求 $f_{i,j}$ 时就可以一并求出 $ans_{i,j}$，其中 $f_{i,j}=f_{f_{i,j-1},j-1},ans_{i,j}=ans_{i,j-1}+ans_{f_{i,j-1},j-1}+2^{j-1}\times (f_{i,j-1}-f_{i,j})$。$2^{j-1}\times (f_{i,j-1}-f_{i,j})$ 表示的是 $f_{i,j-1}$ 到 $f_{i,j}$ 这些点都需要多走 $2^{j-1}$ 步。

那么计算一个点 $x$ 到一个区间 $l,r$ 的最小步数和，只需要求出 $x$ 到 $l$ 的步数之和减去 $x$ 到 $r+1$ 的步数之和。

考虑得到 $f$ 和 $ans$ 后如何计算以 $x$ 为起点，到区间  $[x,y]$ 的步数之和。

首先，第一步比较特殊，需要特殊处理。第一步能到达的最远位置只能为 $l_x$，对于区间 $[l_x,x]$，贡献就为 $x-l_x$。

再记录当前已经走的步数 $step$，如果倍增跳 $2^j$ 步，总步数就会增加 $step \times (s-f_{s,j}) +ans_{s,j}$。

代码：

```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int N=3e5+5,M=25;
  int n,m,l[N];
  int f[N][M],ans[N][M];
  int solve(int s,int t){
      if(l[s]<=t){
          return s-t;
      }
      int res=s-l[s],now=1;
      s=l[s];
      for(int j=20;j>=0;j--){
          if(f[s][j]>t){
              res+=now*(s-f[s][j])+ans[s][j];
              now+=(1<<j);
              s=f[s][j];
          }
      }
      return res+(s-t+now*(s-t));
  }
  signed main(){
      scanf("%d",&n);
      l[1]=1;
      for(int i=2;i<=n;i++){
          scanf("%d",&l[i]);
      }
      f[n+1][0]=n+1;
      for(int i=n;i>=1;i--){
          f[i][0]=min(f[i+1][0],l[i]);
          ans[i][0]=i-f[i][0];
      }
      for(int j=1;(1<<j)<=n;j++){
          for(int i=(1<<j);i<=n;i++){
              f[i][j]=f[f[i][j-1]][j-1];	
              ans[i][j]=ans[i][j-1]+ans[f[i][j-1]][j-1]+(1<<j-1)*(f[i][j-1]-f[i][j]);
          }
      }
      scanf("%d",&m);
      for(int i=1,l,r,x;i<=m;i++){
          scanf("%d %d %d",&l,&r,&x);
          int len=r-l+1;
          int res=solve(x,l)-solve(x,r+1);
          int g=__gcd(len,res);
          printf("%d/%d\n",res/g,len/g);		
      }
      return 0;
  }
```

---


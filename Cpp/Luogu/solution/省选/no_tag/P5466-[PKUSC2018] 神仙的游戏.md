# [PKUSC2018] 神仙的游戏

## 题目描述

小 D 和小 H 是两位神仙。他们经常在一起玩神仙才会玩的一些游戏，比如 “口算一个 4 位数是不是完全平方数” 。

今天他们发现了一种新的游戏：首先称 $s$ 长度为 $len$ 的前缀成为 border 当且仅当 $s[1\dots len ] = s[|s|-len + 1\dots |s|]$ 。给出一个由 $\texttt{01?}$ 组成的字符串 $s$，将 $s$ 中的问号用 $\texttt{01}$ 替换，对每个 $len$ 口算是否存在替换问号的方案使得 $s$ 长度为 $len$ 的前缀成为 border，把这个结果记做 $f(len)\in \{0,1\}$。如果 $s$ 长度为 $len$ 的前缀能够成为 border 那么 $f(len) = 1$，否则 $f(len) = 0$。

由于小 D 和小 H 是神仙，所以他们计算的 $s$ 的长度很长，因此把计算的结果一一比对会花费很长的时间。为了方便比对，他们规定了一个校验值：$(f(1)\times 1^2)~\operatorname{xor}~(f(2)\times 2^2)~\operatorname{xor}~(f(3)\times 3^2)~\operatorname{xor}~\dots~\operatorname{xor}~(f(n)\times n^2)$ 来校验他们的答案是否相同。$\operatorname{xor}$ 表示按位异或。但是不巧，在某一次游戏中，他们口算出的校验值并不一样，他们希望你帮助他们来计算一个正确的校验值。当然，他们不强迫你口算，可以编程解决。


## 说明/提示

### 样例解释

将问号填充为 1001，则这个串有长度为 1 的 border, 故 $f(1) = 1$。

将问号填充为 1101，则这个串有长度为 4 的 border, 故 $f(4) = 1$。

对于 $f(2)$ 和 $f(3)$，可以枚举填充的字符是什么来证明他们的值是 0。

故答案是 $1^2~\operatorname{xor}~4^2=17$。

### 数据范围

| 子任务编号 |        $\lvert s \rvert$         |         附加说明         | 分数 |
| :--------: | :------------------: | :----------------------: | :--: |
|     1      |     $\leq 1000$      |            无            |  8   |
|     2      | $\leq 5 \times 10^5$ |     输入的串没有问号     |  10  |
|     3      | $\leq 5\times 10^5$  |         数据随机         |  22  |
|     4      | $\leq 5\times 10^5$  | 问号个数至少是 $\lvert s \rvert -5000$ |  27  |
|     5      | $\leq 5\times 10^5$  |            无            |  33  |


## 样例 #1

### 输入

```
1?0?```

### 输出

```
17```

# 题解

## 作者：asuldb (赞：8)

[题目](https://www.luogu.org/problem/P5466)

画一画就会发现一些奇诡的性质

首先如果$len$为一个$\operatorname{border}$，那么必然对于$\forall i\in [1,len]$，都会有$s_i=s_{n-len+i}$

我们大力扩展一下这个性质，发现当$len$为一个$\operatorname{border}$时，我们把这个整个字符串按照$n-len$来分段，每一段都是完全相等的，最后的不完整的一段也肯定是之前的某一个前缀

换句话说，任取$i,j$在$\operatorname{mod}\ (n-len)$意义下相等，那么$s_i$和$s_j$也必须相等

于是我们发现通配符变得没有意义了，我们把$0,1$分别位于那些位置求出来，如果有一个$1$位于$i$位置，有一个$0$位于$j$位置，那么如果存在$i\equiv j(mod\ x)$，那么$n-x$不可能成为一个$\operatorname{border}$

显然如果$x|\operatorname{abs}(i-j)$，那么$i\equiv j(mod\ x)$

也就是说我们处理出$0,1$位置两两之差的绝对值，之后调和级数一下就能判断出那些不是$\operatorname{border}$了

显然现在问题被转化成了一道$\operatorname{FFT}$板子题

代码

```cpp
#include<bits/stdc++.h>
#define re register
#define LL long long
const int mod=998244353;
const int maxn=1<<20;
int n,len,Inv;char S[500005];
int rev[maxn],a[maxn],b[maxn],c[maxn];
inline int ksm(int a,int b) {
	int S=1;
	for(;b;b>>=1,a=1ll*a*a%mod) if(b&1) S=1ll*S*a%mod;
	return S;
}
inline void NTT(int *f,int *g) {
	for(re int i=0;i<len;i++) 
		if(i<rev[i]) std::swap(g[i],g[rev[i]]),std::swap(f[i],f[rev[i]]);
	for(re int i=2;i<=len;i<<=1) {
		int ln=i>>1,og1=ksm(3,(mod-1)/i);
		for(re int t,og=1,l=0;l<len;l+=i,og=1)
			for(re int x=l;x<l+ln;++x,og=1ll*og*og1%mod) 
				t=1ll*f[x+ln]*og%mod,f[x+ln]=(f[x]-t+mod)%mod,f[x]=(f[x]+t)%mod,
				t=1ll*g[x+ln]*og%mod,g[x+ln]=(g[x]-t+mod)%mod,g[x]=(g[x]+t)%mod;
	}
	for(re int i=0;i<len;i++) f[i]=1ll*f[i]*g[i]%mod;
	for(re int i=0;i<len;i++) if(i<rev[i]) std::swap(f[i],f[rev[i]]);
	for(re int i=2;i<=len;i<<=1) {
		int ln=i>>1,og1=ksm((mod+1)/3,(mod-1)/i);
		for(re int t,og=1,l=0;l<len;l+=i,og=1)
			for(re int x=l;x<l+ln;++x,og=1ll*og*og1%mod) 
				t=1ll*f[x+ln]*og%mod,f[x+ln]=(f[x]-t+mod)%mod,f[x]=(f[x]+t)%mod;
	}
	for(re int i=0;i<len;i++) f[i]=1ll*f[i]*Inv%mod;
}
inline int abs(int x) {return x>=0?x:-x;}
int main() {
	scanf("%s",S);n=strlen(S);
	for(re int i=0;i<n;i++) {
		if(S[i]=='0') a[n-i]++;
		if(S[i]=='1') b[i]++;
	}
	len=1;while(len<n+n+1) len<<=1;Inv=ksm(len,mod-2);
	for(re int i=0;i<len;i++) rev[i]=rev[i>>1]>>1|((i&1)?len>>1:0);
	NTT(a,b);
	for(re int i=1;i<n+n;i++) c[abs(i-n)]+=a[i];
	LL ans=0;
	for(re int i=1;i<n;i++) {
		int flag=0;
		for(re int j=i;j<=n;j+=i) flag|=(c[j]>0);
		if(!flag)  ans^=1ll*(n-i)*(n-i);
	}
	ans^=1ll*n*n;std::cout<<ans;
	return 0;
}
```


---

## 作者：wrpwrp (赞：4)

显然要是没有限制那就全都是$1$对吧，

所以考虑这些$0, 1$到底限制了啥。

首先看到$border$, 容易想到当年写$kmp$求最短回文子串的那题。因为$kmp$的$next$数组实际上就是最长$border$。我们也在那题积累一个结论， 就是对于原来的串一个长度为$k$的$border$, 原串一定是由长度为$n -k$的子串循环而成的，但是最后一部分并不一定是一个完整的循环节。（实际上你也可以看成第一个不一定是一个完整的循环节， 这一部分画图很容易看出来）。那么如果有一组$0,1$的位置距离恰好是$n-k$，那显然就是不行的， 因为按照要求， 它们应该相等。显然， 如果这个距离是$n-k$的因数也是不行的。

然后一个简单的暴力就出来了， 暴力枚举所有$0, 1$, 求出它们的距离， 然后取并集， 对于这个集合里的长度暴力枚举倍数来判断是否合法， 复杂度$O(n^2+n\ln n)$。

然后我们考虑优化这个做法， 优化这个我只知道有数据结构和多项式两条路，感觉数据结构不太行那就搞多项式。我们要求的是距离， 就设$F(x) = \sum_{i=0}^{n-1}x^if_i$, 其中$f_i$表示距离为$i$的$0,1$点对有多少对。 然后设$A(x)=\sum_{i=0}^{n-1}[s[i] =='0']x^i, B(x)=\sum_{i=0}^{n-1}[s[i]=='1']x^{-i}$,考虑怎么解决这个负数幂次， 让$B(x)=x^{n}B(\frac{1}{x})$,最后求答案的时候直接位置加上$n$就好了。

```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;

#define R register
#define LL long long
const int N = 2e6 + 10;
const int P = 998244353;
const int G = 3;
const int Gi = 332748118;

inline int read() {
	int x = 0, f = 1; char a = getchar();
	for(; a > '9' || a < '0'; a = getchar()) if(a == '-') f = -1;
	for(; a >= '0' && a <= '9'; a = getchar()) x = x * 10 + a - '0';
	return x * f;
}

inline int qpow(int x, int k) { 
	int res = 1;
	while(k) {
		if(k & 1) res = 1LL * res * x % P;
		x = 1LL * x * x % P; k >>= 1;
	} return res;
}

int bit, rev[N], lim = 1;
inline void NTT(int *A, int type = 1) {
	for(R int i = 0; i < lim; i ++) if(i > rev[i]) swap(A[i], A[rev[i]]);
	for(R int dep = 1; dep < lim; dep <<= 1) {
		int Wn = qpow(type == 1 ? G : Gi, (P - 1) / (dep << 1));
		for(R int j = 0, len = dep << 1; j < lim; j += len) {
			int w = 1;
			for(R int k = 0; k < dep; k ++, w = 1LL * w * Wn % P) {
				int x = A[j + k], y = 1LL * A[j + k + dep] * w % P;
				A[j + k] = (x + y) % P;
				A[j + k + dep] = (x - y + P) % P;
			}
		}
	}
	if(type == -1) {
		int inv = qpow(lim, P - 2);
		for(R int i = 0; i < lim; i ++) A[i] = 1LL * A[i] * inv % P;
	}
}

int n; 
char s[N];
int a[N], b[N];
int main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	scanf("%s", s); n = strlen(s);
	while(lim < (n << 1)) lim <<= 1, bit ++;
	for(R int i = 0; i < lim; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));
	for(R int i = 0; i < n; i ++) a[i] = (s[i] == '0');
	for(R int i = 0; i < n; i ++) b[i] = (s[n - i - 1] == '1');
	NTT(a); NTT(b);
	for(R int i = 0; i < lim; i ++) a[i] = 1LL * a[i] * b[i] % P;
	NTT(a, -1);
	LL ans = 1LL * n * n;
	for(R int i = 1; i < n; i ++) {
		int f = 1;
		for(R int j = i; j < n; j += i) if(a[n - 1 - j] | a[n - 1 + j]) {f = 0; break; }
		if(f) ans ^= 1LL * (n - i) * (n - i);
	}
	printf("%lld\n", ans);
	return 0;
}
```



---

## 作者：向日葵小班 (赞：2)

&emsp;&emsp;给出一个字符串 $s$，其中有若干位置为通配符，问 $s$ 可能拥有的 $\operatorname{Broder}$ 长度集合。
$|s|≤5×10^5$，字符集为 $\left\{0,1\right\}$。

将 $\operatorname{Bd}$ 转化称周期，问题变为求 $s$ 可能拥有的周期集合。

对于周期 $p$，要判定是否存在一对 $0,1$ 模 $p$ 之后在相同的位置上。若不存在，则该周期可行。

用卷积求出 $0,1$ 之间的距离集合。对每个 $p$ 查看 $p$ 的倍数即可，复杂度为 $O(n\log n)$。




---

## 作者：A1443356159 (赞：1)

首先注意到border一个性质，如果一个字符串有一个长度为 $len$ 的border，那么他就有一个长度为 $n-len $的循环节。

于是我们有了一个暴力的思路，枚举border的长度 $len$，判断 $S$ 是否有长度为 $n-len$ 的循环节即可。

对于字符串 $S$，有一个长度为 $x$ 的循环节，意味着若 $i\equiv j\mod x$ ，则 $S_i=S_j$。反过来说若对于任意  $i\equiv j\mod x$，满足 $S_i= S_j$，那么 $S$ 有一个长度为 $x$ 的循环节，同时，若存在  $i\equiv j\mod x$，$S_i \ne S_j$，那么x不是循环节。

显然 $i\equiv j \mod x$ ，等价于 $abs(i-j)|x$。所以若存在 $S_i=0,S_j=1$，那么不可能存在循环节长度 $abs(i-j)|len$，这个可以 $n^2$ 暴力。

考虑用NTT优化，若 $S_i=1$，$A_i=1$，若 $S_j=0$，$B_{n-j}=1$，卷积一下发现就是 $i-j+n$，减掉 $n$，求个绝对值即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+5,P=998244353,g=3,gi=(P+1)/g;
char S[N];
int A[N],B[N],rev[N],n,f[N];
int qpow(int a,int b) {
	int res=1;
	while(b) {
		if(b&1)res=res*a%P;
		a=a*a%P;
		b>>=1;
	}
	return res;
}
void NTT(int *F,int k,int flag) {
	int n=1<<k;
	for(int i=0;i<n;++i) {
		rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
		if(rev[i]<i)swap(F[i],F[rev[i]]);
	}
	int tmp,omega,t;
	for(int p=2,len=1;p<=n;p<<=1,len<<=1) {
		if(flag==1)tmp=qpow(g,(P-1)/p);
		else tmp=qpow(gi,(P-1)/p);
		for(int i=0;i<n;i+=p) {
			omega=1;
			for(int l=i;l<i+len;++l,omega=omega*tmp%P) {
				t=F[l+len]*omega%P;
				F[l+len]=(F[l]-t+P)%P;
				F[l]=(F[l]+t)%P;
			}
		}
	}
	if(flag==-1) {
		int inv=qpow(n,P-2);
		for(int i=0;i<n;++i)(F[i]*=inv)%=P;
	}
}
main() {
	scanf("%s",S+1);
	n=strlen(S+1);
	for(int i=1;i<=n;++i) {
		if(S[i]=='1')A[i-1]=1;
		if(S[i]=='0')B[n-i+1]=1;
	}
	int k=0,len;
	while((1<<k)<(n+n))++k;
	len=1<<k;
	NTT(A,k,1);NTT(B,k,1);
	for(int i=0;i<len;++i)(A[i]*=B[i])%=P;
	NTT(A,k,-1);
	for(int i=1;i<=2*n;++i) {
		if(!A[i])continue;
		f[abs(i-n)]=1;
	}
	int ans=0,flag=0;
	for(int i=1;i<n;++i) {
		int nw=n-i;
		flag=0;
		for(int j=nw;j<=n;j+=nw)flag|=f[j];
		if(!flag)ans^=(i*i);
	}
	ans^=(n*n);
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：1saunoya (赞：0)

对于一个 $f_i = 0$。

仅当有一个 $1$ 匹配到了 $0$。

所以如果这一位是 '1'，那么 $F_i = 1$。

这一位是 '0'，那么 $G_{n-i-1}=1$。

令 $H = F * G$。

关于 $border$ 有一个结论，令 $k = |s| - border[1..|s|]$，那么 $s$ 的循环节是 $k$，且最后一段是 $|s|\%k$。

也就是如果 $H_{i}\geq 1,i = n-1-k \times j, j \in Z,$那么 $f_{n-k} = 0$。

```cpp
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x,I=y+1;i<I;++i)
#define per(i,x,y) for(int i=x,I=y-1;i>I;--i)
using namespace std;
using ll=long long;
void cmax(int&x,const int&y){x=x>y?x:y;}
void cmin(int&x,const int&y){x=x<y?x:y;}
template<class T>istream&operator>>(istream&in,vector<T>&V){for(auto&x:V)in>>x;return in;}
template<class T>ostream&operator<<(ostream&out,const vector<T>&V){for(auto x:V)out<<x<<' ';return out;}
template<class T>void sort(vector<T>&V){sort(V.begin(),V.end());}
template<class T>void reverse(vector<T>&V){reverse(V.begin(),V.end());}
template<class T>int SZ(const vector<T>&V){return (int)V.size();}
void debug(){cerr<<"whxorz"<<'\n';}
template<class T>void debug(T x){debug();cout<<x<<'\n';}
const int mod=998244353;
void _(int&x,const int&y){x=1ll*x*y%mod;}
void upd(int&x,const int&y){x+=y;if(x>=mod)x-=mod;}
int qpow(int x,int t){int res=1;while(t){if(t&1)_(res,x);_(x,x),t>>=1;}return res;}
const int N=1048576;int rev[N];
void dft(int*f,int inv){
	rep(i,0,N-1)if(i<rev[i])swap(f[i],f[rev[i]]);
	for(int len=1;len<N;len<<=1)for(int i=0,wn=qpow(3,(mod-1)+inv*(mod-1)/(len<<1));i<N;i+=len<<1){
		int w=1;rep(j,0,len-1){int x=f[i+j],y=f[i+j+len];_(y,w);upd(f[i+j]=x,y),upd(f[i+j+len]=x,mod-y);_(w,wn);}
	}if(inv==-1){int iv=qpow(N,mod-2);rep(i,0,N-1)_(f[i],iv);}
}
char s[N];
int f[N],g[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	rep(i,0,N-1)rev[i]=rev[i>>1]>>1|(i&1)<<19;
	cin>>s;
	int n=strlen(s);
	rep(i,0,n-1){if(s[i]=='0')f[i]=1;if(s[i]=='1')g[n-i-1]=1;}
	dft(f,1),dft(g,1);
	rep(i,0,N-1)_(f[i],g[i]);
	dft(f,-1);
	ll ans=1ll*n*n;
	rep(i,1,n-1){
		bool flag=1;
		for(int j=i;j<n;j+=i){if(f[n-1+j]||f[n-1-j]){flag=0;break;}}
		if(flag)ans^=1ll*(n-i)*(n-i);
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Kinandra (赞：0)

1. 标签:FFT?
2. 称 $x$ 是 $s$ 的一个 $period$ 当且仅当 $\forall 1\leqslant i\leqslant |s| - x, s_i=s_{i+x}$.  
   定理1: $pre(s,r)$ 是 $s$ 的 $boder\Leftrightarrow|s|-r$ 是 $s$ 的 $period$ ,证明略.
3. 根据定理1, 本题等价于求对于每个 $0\leqslant i\leqslant |s|-1$ , $i$是否可能是 $s$ 的一个 $period$ . 易知 $i$ 不可能是 $s$ 的 $period$ 当且仅当$\exists 1\leqslant j\leqslant |s|, s_j\neq s_{j+k\times i}$且$s_j,s_{j+k\times i}$都不是 '?' , 即若存在某对 '0' 和 '1' 距离为 $d$，则 $period \nmid d$.
4. 至此, 我们只需要找到所有 '0' 和 '1' 之间的距离就可以解决本题了, 这个可以转化成卷积的形式, 通过FFT来解决. 不赘述, 若存在疑问, 建议先去完成[**万径人踪灭**](https://www.luogu.org/problem/P4199)或者结合代码来理解.

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const double pi = acos(-1);
int read();
char s[500005];
int vis[500005];
int n, len, w;

struct C {
    double x, y;
    C operator+(C a) { return (C){x + a.x, y + a.y}; }
    C operator-(C a) { return (C){x - a.x, y - a.y}; }
    C operator*(C a) { return (C){x * a.x - y * a.y, x * a.y + y * a.x}; }
    C operator*(double a) { return (C){x * a, y * a}; }
    C conj() { return (C){x, -y}; }
} O[1100005];

struct Poly {
    C x[1100005];
    C &operator[](int p) { return x[p]; };
} f, g, P;

int rtt[1100005];
void dft(Poly &x, int w, int len) {
    for (int i = 1; i < len; ++i)
        if ((rtt[i] = (rtt[i >> 1] >> 1 | ((i & 1) << (w - 1)))) > i)
            swap(x[i], x[rtt[i]]);

    for (int l = 2; l <= len; l <<= 1) {
        int m = l >> 1, aO = len / l;
        for (int i = 0; i < len; i += l) {
            for (int j = i, tO = 0; j < i + m; ++j) {
                C t = O[tO] * x[j + m];
                x[j + m] = x[j] - t, x[j] = x[j] + t;
                tO += aO, tO = tO >= len ? tO - len : tO;
            }
        }
    }
    return;
}

void ddft(Poly &f, Poly &g, int w, int len) {
    for (int i = 0; i < len; ++i) P[i] = (C){f[i].x, g[i].x};
    dft(P, w, len);
    f[0] = (C){P[0].x, 0}, g[0] = (C){P[0].y, 0};
    for (int i = 1; i < len; ++i) {
        f[i] = (P[i] + P[len - i].conj()) * 0.5;
        g[i] = (P[i] - P[len - i].conj()) * 0.5 * (C){0, -1};
    }
}

void idft(Poly &x, int w, int len) {
    dft(x, w, len), reverse(x.x + 1, x.x + len);
}

int main() {
    scanf("%s", s), n = strlen(s);
    for (int i = 0; i < n; ++i) {
        if (s[i] == '0') f[i] = (C){1, 0};
        if (s[i] == '1') g[n - i - 1] = (C){1, 0};
    }

    len = 1;
    while (len < 2 * n) ++w, len <<= 1;
    for (int i = 0; i < len; ++i)
        O[i] = (C){cos(pi * 2 * i / len), sin(pi * 2 * i / len)};

    ddft(f, g, w, len);

    for (int i = 0; i < len; ++i) f[i] = f[i] * g[i];
    idft(f, w, len);
    long long res = 0;
    for (int i = n - 1; i; --i) {
        if (f[n - 1 + i].x + f[n - 1 - i].x > 1e-3)
            vis[i] = 1;
        else
            for (int j = i; j < n; j += i)
                if (vis[j]) {
                    vis[i] = 1;
                    break;
                }
        if (!vis[i]) res ^= 1ll * (n - i) * (n - i);
    }
    printf("%lld\n", res ^ 1ll * n * n);
    return 0;
}
int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = getchar();
    while (isdigit(c)) x = x * 10 + c - '0', c = getchar();
    return x * f;
}
```


---


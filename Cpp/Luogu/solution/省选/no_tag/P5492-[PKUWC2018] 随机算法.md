# [PKUWC2018] 随机算法

## 题目描述

我们知道，求任意图的最大独立集是一类NP完全问题，目前还没有准确的多项式算法，但是有许多多项式复杂度的近似算法。

例如，小 C 常用的一种算法是：

1. 对于一个 $n$ 个点的无向图，先等概率随机一个 $1\ldots n$ 的排列 $p[1\ldots n]$。

2. 维护答案集合 $S$ ，一开始 $S$ 为空集，之后按照 $i=1\ldots n$ 的顺序，检查 $\{p[i]\}\cup S$ 是否是一个独立集，如果是的话就令 $S=\{p[i]\}\cup S$。

3. 最后得到一个独立集 $S$ 作为答案。

小 C 现在想知道，对于给定的一张图，这个算法的正确率，输出答案对 $998244353$ 取模。

## 说明/提示

#### 样例解释
这张图的最大独立集显然为 $2$，可以发现只有 $p[1]=2$ 时会得出 $S=\{2\}$，否则都是 $S=\{1,3\}$，所以答案是 $\frac{2}{3}$。


#### 数据范围
对于 $10\%$ 的数据，有$1\leq n\leq 9$。

对于 $30\%$ 的数据，有$1\leq n\leq 13$。

对于 $50\%$ 的数据，有$1\leq n\leq 17$。

另有 $10\%$ 的数据，满足给定的图是一条链。

另有 $10\%$ 的数据，满足给定的图是一棵树。

对于 $100\%$ 的数据，有$1\leq n\leq 20$，$0\leq m\leq \frac{n\times (n-1)}{2}$，保证给定的图没有重边和自环。

## 样例 #1

### 输入

```
3 2
1 2
2 3```

### 输出

```
665496236```

# 题解

## 作者：xyz32768 (赞：29)

- 写一发 $O(2^n\times n)$ 的做法

- 定义独立集 $S$ 的**生成点集**为一个最大的点集 $T$ ，满足 $S\subseteq T$ 且不存在 $T$ 的一个独立子集 $U$ 满足 $S\subsetneq U$

- 显然我们有：**$S$ 是最大独立集的必要条件是其生成点集为全集**

- 现在考虑如果已经知道了用随机算法生成的独立集，并且知道了这些点加入独立集的顺序，如何生成一个合法的随机序列

- 首先，独立集的第一个点 $u_1$ 必须在随机序列的第一位

- 可以发现这时候对于一个不在独立集内的点 $u$ ，如果存在边 $(u,u_1)$ ，那么 $u$ 在随机序列中的位置可以任意

- 为这些 $u$ 的位置安排好了之后，我们又能发现，独立集的第二个点 $u_2$ 必须在剩下的位置中的第一位

- 然后如果对于满足存在边 $(v,u_2)$ 而不存在边 $(v,u_1)$ 的点 $v$ ，也可以安排在剩下的任意位置

- 于是我们得出：一个随机序列合法的条件是对于所有的 $1\le i\le|S|$ ，都满足序列中删掉前 $i-1$ 个点的生成点集之后，$u_i$ 位于剩下的位置中的第一位

- 易得这个随机序列合法的概率是：

- $$\prod_{i=1}^{|S|}\frac1{n-size(S_{i-1})}$$

- $size$ 为生成点集大小，$S_i$ 表示 $S$ 前 $u_1$ 到 $u_i$ 构成的点集

- 推出这个式子之后，我们就有了一个 DP：

- $f[S]$ 表示插入独立集的前 $|S|$ 个点构成集合 $S$（顺序未定），对于所有 $|S|!$ 种顺序，上式的值之和

- $$f[\emptyset]=1$$

- $$f[S]=\sum_{i\in S}\frac{f[S-\{i\}]}{n-size(S-\{i\})}$$

- 最后的答案就是原图所有最大独立集 $S$ 的 $f[S]$ 之和

## 代码
```cpp
#include <bits/stdc++.h>

template <class T>
inline void read(T &res)
{
	res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	if (bo) res = ~res + 1;
}

template <class T>
inline T Max(const T &a, const T &b) {return a > b ? a : b;}

const int N = 23, M = (1 << 20) + 5, rqy = 998244353;

int n, m, Cm, ix[M], pset[N], cnt[M], sze[M], maxs, f[M], inv[N], ans;
bool is[M];

int main()
{
	int x, y;
	read(n); read(m);
	while (m--) read(x), read(y), pset[x] |= 1 << y - 1, pset[y] |= 1 << x - 1;
	is[0] = 1; Cm = 1 << n;
	for (int i = 1; i <= n; i++) ix[1 << i - 1] = i;
	for (int S = 1; S < Cm; S++)
	{
		int T = S ^ (S & -S), i = ix[S & -S];
		if (is[T]) is[S] = !(T & pset[i]);
		cnt[S] = sze[S] = sze[T] + 1;
		if (is[S]) maxs = Max(maxs, sze[S]);
		for (int i = 1; i <= n; i++)
			if (S & pset[i]) cnt[S]++;
	}
	f[0] = inv[1] = 1;
	for (int i = 2; i <= n; i++)
		inv[i] = 1ll * (rqy - rqy / i) * inv[rqy % i] % rqy;
	for (int S = 1; S < Cm; S++)
	{
		if (!is[S]) continue;
		for (int i = 1; i <= n; i++)
		{
			if (!((S >> i - 1) & 1)) continue;
			int T = S ^ (1 << i - 1);
			f[S] = (1ll * f[T] * inv[n - cnt[T]] + f[S]) % rqy;
		}
		if (sze[S] == maxs) ans = (ans + f[S]) % rqy;
	}
	return std::cout << ans << std::endl, 0;
}
```

---

## 作者：徐致远 (赞：11)


[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/12/19/%E3%80%8CPKUWC2018%E3%80%8D%E9%A2%98%E8%A7%A3-Solution/)

### 题解

排列的总数很好求，考虑有多少种排列能求出正确的答案。

数据范围很小，考虑一个状压DP：

$F[S][i]$表示当前的排列中已经包含了集合$S$中的所有元素，且最大独立的大小为$i$的方案数。

枚举下一个不在$S$中的节点$j$，使节点$j$加入到最大独立集中来。设$j$以及与$j$距离为$1$的点构成的集合为$T$，那么节点$j$需要放在排列中最靠前的一个空位，剩下的节点可以随意放排列中剩余的空位上。所以就有转移：
$$
F[S|T][i+1]+=F[S][i]*A_{n-|S|-1}^{|T-(S\bigcap T)|-1}
$$
初始有$F[0][0]=1$，最后的答案为$\frac{F[U][mx]}{n!}$，其中$U$为全集，$mx$为最大独立集的大小。

### 代码

```cpp
#include<cstdio>
using namespace std;
typedef long long LL;
const int maxn=25,TT=998244353;
int n,m,lnk[maxn],A[maxn][maxn],cnt[(1<<20)+5],F[(1<<20)+5][21],mx,ifn,ans;bool vis[(1<<20)+5][21];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline int QP(int a,int b)
{
	int ret=1,w=a;
	while(b)
	{
		if(b&1) ret=(LL)ret*w%TT;
		w=(LL)w*w%TT;b>>=1;
	}
	return ret;
}
inline void Inc(int& x,int y){x=(x+y>=TT?x+y-TT:x+y);}
int main()
{
	n=read();m=read();ifn=1;
	for(int i=1;i<=n;i++) ifn=(LL)ifn*i%TT;
	ifn=QP(ifn,TT-2);
	for(int i=1;i<=n;i++) lnk[i]|=1<<(i-1);
	for(int i=1;i<=m;i++)
	{
		int a=read(),b=read();
		lnk[a]|=(1<<(b-1));
		lnk[b]|=(1<<(a-1));
	}
	for(int i=0;i<=20;i++)
	{
		for(int j=0;j<=i;j++)
		{
			if(j==0) A[i][j]=1;
			else A[i][j]=(A[i-1][j]+(LL)A[i-1][j-1]*j)%TT;
		}
	}
	for(int i=1;i<(1<<n);i++) cnt[i]=cnt[i>>1]+(i&1);
	F[0][0]=vis[0][0]=1;
	for(int i=0;i<n;i++)
	{
		for(int S=0;S<(1<<n);S++)
		{
			for(int j=1;j<=n;j++)
			{
				if(vis[S][i]&&!(S&(1<<(j-1))))
				{
					Inc(F[S|lnk[j]][i+1],(LL)F[S][i]*A[n-cnt[S]-1][cnt[lnk[j]-(lnk[j]&S)]-1]%TT);
					vis[S|lnk[j]][i+1]=true;
					if(i+1>mx) mx=i+1;
				}
			}
		}
	}
	ans=(LL)F[(1<<n)-1][mx]*ifn%TT;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：TheLostWeak (赞：9)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5492.html)

**大致题意：** 用随机算法求一张图的最大独立集：每次随机一个排列，从前到后枚举排列中的点，如果当前点加入点集中依然是独立集，就将当前点加入点集中，最终得到的点集就是最大独立集。求这个随机算法的正确率。

### 前言

$PKUWC$的题目就是妙啊。

题目很神仙，但看完题解后就很简单了，可这种东西像我这般蒟蒻根本想不到啊......

### 状压$DP$

设$f_{i,j}$表示当前已考虑过点集$i$，最大独立集为$j$的方案数。

每次我们枚举一个不在点集中的点$k$，设与其相邻的点的集合为$a_k$。

则，如果我们要选择点$k$作为独立集中的点，那么与其相邻的点就不能再选择，方便起见，我们直接把$a_k$算作考虑过的点。

即，对于$f_{i,j}$和$k$，我们可以转移到$f_{i|2^{k-1}|a_k,j+1}$。

注，这里之所以是$2^{k-1}$，因为我习惯用二进制下第$x-1$位来表示第$x$个数是否被选择。

不难发现，根据我们的转移方式，由于$k$不在点集中，所以点集中被选作独立集中的点的点一定不与$k$相邻，否则在那个点被选作独立集中的点时就已经把$k$加入点集了，因此必然$j$可以加$1$。

然后我们考虑，在这一步转移下，$k$肯定是要直接加入点集中的，即必然在剩下的点中名列第一，它的位置是固定的。

而对于那些与$k$相邻、又不在点集$i$中的点（即：$a_k-(i\&a_k)$），它们可以在$k$之后的任意一个位置（共有$n-g_i-1$个位置，其中$g_i$代表点集$i$中的点，$1$代表点$k$）加入点集，因此方案数为$A_{n-g_i-1}^{g_{a_k-(i\& a_k)}}$。

其中，$A$表示排列数，$A_n^m=\frac{n!}{(n-m)!}$；$g_i$表示点集$i$中点的个数。

所以：$f_{i|2^{k-1}|a_k,j+1}+=f_{i,j}\cdot A_{n-g_i-1}^{g_{a_k-(i\&a_k)}}$。

由于求概率，而我们求的是方案数，所以最后的答案就是：$\frac{f_{2^n-1,w}}{n!}$，其中$w$表示最大独立集的大小。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 20
#define X 998244353
#define A(x,y) (1LL*Fac[x]*IFac[(x)-(y)]%X)
using namespace std;
int n,m,a[N+5],f[1<<N][N+5],g[1<<N],Fac[N+5],IFac[N+5];
I int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}
int main()
{
	RI i,x,y;for(scanf("%d%d",&n,&m),i=1;i<=m;++i) scanf("%d%d",&x,&y),a[x]|=1<<y-1,a[y]|=1<<x-1;//读入，记录相邻点
	for(Fac[0]=i=1;i<=N;++i) Fac[i]=1LL*Fac[i-1]*i%X;//预处理阶乘
	for(IFac[N]=Qpow(Fac[N],X-2),i=N-1;~i;--i) IFac[i]=1LL*IFac[i+1]*(i+1)%X;//预处理阶乘逆元
	RI j,k,t=1<<n;for(i=0;i^t;++i) g[i]=g[i>>1]+(i&1);for(f[0][0]=1,i=0;i^t;++i)//枚举点集
	{
		for(j=0;j<=g[i];++j) for(k=1;k<=n;++k) !((i>>k-1)&1)&&//一定要选择不在点集中的点
			(f[i|(1<<k-1)|a[k]][j+1]=(1LL*f[i][j]*A(n-g[i]-1,g[a[k]-(i&a[k])])+f[i|(1<<k-1)|a[k]][j+1])%X);//转移
	}
	for(i=n;!f[t-1][i];--i);return printf("%d",1LL*f[t-1][i]*IFac[n]%X),0;//求最大独立集点数，然后输出答案
}
```



---

## 作者：IceKylin (赞：5)

来点 [最优解](https://www.luogu.com.cn/record/210096600) 做法。

记 $N(v)$ 表示点 $v$ 的邻域。固定排列 $p$，将所有点按是否选入独立集分成 $S,T$ 两类，前者表选入。容易想到 $\mathcal{O(3^nn)}$ 的朴素做法，即直接状压两个点集转移。

考虑如下问题：给出点集 $U$，表示候选点集合，初始为全集。给出点集 $S$，表示最终的独立集，初始为空。每次操作为在 $U$ 中等概率随机一个点 $v$，将其加入 $S$，并在 $U$ 中删除 $N(v)$ 和 $v$。重复操作直至 $U$ 为空。求 $S$ 为最大独立集的概率。

令人惊讶的是，这与原题是等价的！

我们试图说明这一点：在朴素转移的过程中，每次随机一个点，要么加入 $S$，要么加入 $T$。然而 $T$ 中具体内容是无关紧要的，因为只有 $S$ 中的点会更新答案，并且具有后效性。所以直接将 $T$ 当作垃圾堆，删除其中的点即可。

显然新的题意存在一个 $\mathcal{O}(2^nn)$ 的小常数简单写法。

---

## 作者：Soulist (赞：5)

一个比较奇怪的做法？（u1s1 感觉相对而言这道题偏简单？）

先考虑一个自动机来识别原算法构成独立集是谁。

我们建 $dp[S]$ 数组表示状态 $S$ 是否为独立集。

我们先不关注是否是排列的问题，仅考虑依次加入一些元素然后判定上述算法构成的独立集是啥。

考虑加入一个字符之后的转移状态 $Go(S,p)$，显然只有两种情况：

- $S\to S',S\to S$

对于前者意味着自动机上进行了转移，表示加入了一个合法的元素，我们只关注后者，显然后者有两种：一类是加入了原来在 S 中存在的元素，一类是加入了原来不存在的元素。

如果是第一类，那么显然此时在计数时会记重，所以我们忽略它，只考虑第二类。

我们注意到非法的字符读入数量是单调的：假设对于状态 $S$ 有字符 $p$ 非法，同时 $S'$ 由 $S$ 转移得到，那么显然 $p$ 对于 $S'$ 同样非法，对于每个状态预处理有多少个接受字符是非法的，预处理可以走到终点的状态，问题变成给定一张 DAG，每条边有边权（每条边表示从状态 S 走到状态 S' 会增加多少个非法的元素），记 $k$ 为当前**经过的边权和**，每次走过一条边之后累加 $k$ （实质表示有 $k$ 个元素），然后每次走过一条边之后可以以任意顺序删除若干个元素，求经过 $\max\{S\}$ 条边同时用光边权的方案数。

设 $f_{S,j}$ 表示当前到达状态 $S$，剩余边权/元素数为 $j$ 的方案数即可，转移可以直接 copy dp 数组然后再对内部进行转移，可以简单的做到 $\mathcal O(2^n\cdot n^2)$，预期十分跑不满，所以感觉挺能过的，试了一下发现确实可以过。

然后我们可以优化到 $\mathcal O(2^n\cdot n)$

我们考虑将那个无用的维度 $(\text{指}j)$ 压掉，显然在转移某条边的时候，我们只需要保证先放入了 S 中的第一个元素，然后剩余的位置可以直接通过组合计数处理。

具体来说是设这条边上有 $k$ 个元素，前面的元素我们都直接填入位置中，那么当前会剩余 $n-|S|-f_S-1$，其中 $f_S$ 表示非法的字符数量（我们考虑从 S 转移到其他状态），那么方案数就是 $\binom{n-|S|-f_S-1}{k}$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int P = 998244353 ; 
const int N = ( 1 << 20 ) + 5 ; 
const int M = 23 ; 
int n, m, maxn, ans, z[M], bit[N], vis[N], dp[N], a[M][M] ; 
int Go[N][M], f[N], fac[M], c[M][M], Ans ;  
int low( int x ) {
	return ( x & (-x) ) ;
}
int fpow( int x, int k ) {
	int ans = 1, base = x ; 
	while( k ) {
		if( k & 1 ) ans = ans * base % P ;  
		base = base * base % P, k >>= 1 ; 
	} return ans ; 
}
signed main()
{
	n = gi(), m = gi() ; int x, y ; 
	rep( i, 1, m ) 
		x = gi(), y = gi(), a[x][y] = a[y][x] = 1 ; 
	vis[0] = 1 ; 
	rep( i, 1, n ) z[i] = ( 1 << (i - 1) ) ;
	maxn = ( 1 << n ) - 1 ; fac[0] = 1 ; c[0][0] = 1 ; 
	rep( i, 1, n ) rep( j, 0, n ) c[i][j] = ( j == 0 ) ? 1 : ( c[i - 1][j - 1] + c[i - 1][j] ) % P ; 
	rep( i, 1, n ) fac[i] = fac[i - 1] * i % P ; 
	rep( i, 1, maxn ) {
		int S = i, p = 0 ; bit[i] = bit[i ^ low(i)] + 1 ; 
		rep( k, 1, n ) if( z[k] & i ) p = k ;
		S ^= z[p], vis[i] = vis[S] ; 
		rep( k, 1, n ) if( (z[k] & S) && a[k][p] ) vis[i] = 0 ;
		if( vis[i] ) ans = max( ans, bit[i] ) ;
	}
	f[maxn] = 0 ; 
	for( re int i = maxn - 1; i >= 0; -- i ) {
		if( !vis[i] ) continue ; 
		int o = 0 ; 
		rep( j, 1, n ) if( !vis[i | z[j]] ) ++ o ; 
		f[i] = o ;
		rep( j, 1, n ) 
			if( ( z[j] & i ) || (!vis[i | z[j]]) ) Go[i][j] = -1 ; 
			else Go[i][j] = f[i | z[j]] - f[i] ; 
	}
	dp[0] = 1 ; 
	for( re int i = 0; i < maxn; ++ i ) {
		if( !vis[i] ) continue ; 
		rep( j, 1, n ) if( Go[i][j] >= 0 ) {
			int S = ( i ^ z[j] ) ;
			dp[S] = ( dp[S] + dp[i] * c[n - bit[i] - f[i] - 1][Go[i][j]] * fac[Go[i][j]] ) % P ; 
		}
		if( bit[i] == ans ) Ans = ( Ans + dp[i] ) % P ; 
	}
	printf("%lld\n", (Ans * fpow( fac[n], P - 2 ) % P) ) ;
	return 0 ;
}
```

---

## 作者：Super_Cube (赞：3)

# Solution

观察到 $n$ 的范围很小，又是一个方案统计，考虑状压 dp。

设 $dp_i$ 为已被选入独立集的点集为 $i$ 时的正确率，$v_i$ 表示点 $i$ 在图中距离不超过一的点集。

顺推方便一点。假设找到了一个点 $j$ 想要把它加入到当前的独立集 $i$ 中，需要满足的条件是 $\forall k \in i,j\not\in v_k$，因为如果 $j$ 与独立集中的点相邻或者本身就在这个独立集里面肯定不能加入进去。

记录一下这样能加入的点，假设一共有 $c$ 个。对于所有的能加入的点 $j$，都有 $dp_{i\cup\{j\}}\leftarrow dp_{i\cup\{j\}}+\dfrac{dp_i}{c}$。原因：因为是随机加入，每个点都是 $\dfrac{1}{c}$ 的等概率。

最后设最大独立集的大小为 $s$，那么总正确概率即为 $\displaystyle\sum_{|i|=s}dp_i$。

时间复杂度：$O(2^n\cdot n)$。

# Code

```cpp
#include <bits/stdc++.h>
const int mod = 998244353;
inline int qpow(int x, int y) {
	static int res;
	res = 1;
	while (y) {
		if (y & 1)
			res = 1ll * res * x % mod;
		y >>= 1;
		x = 1ll * x * x % mod;
	}
	return res;
}
int dp[1048576];
int v[20];
int n, m, res, ans;
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; ++i) v[i] |= 1 << i;
	for (int x, y; m--;) scanf("%d%d", &x, &y), --x, --y, v[x] |= 1 << y, v[y] |= 1 << x;
	dp[0] = 1;
	for (int i = 0, cnt; i < (1 << n); ++i) {
		if (!dp[i])
			continue;
		res = std::max(res, __builtin_popcount(i));//最大独立集的大小
		cnt = 0;
		for (int j = 0; j < n; ++j)
			if (!(i & v[j]))
				++cnt;
		cnt = qpow(cnt, mod - 2);//逆元
		for (int j = 0; j < n; ++j)
			if (!(i & v[j]))
				dp[i | (1 << j)] = (dp[i | (1 << j)] + 1ll * dp[i] * cnt % mod) % mod;
	}
	for (int i = 0; i < (1 << n); ++i)
		if (__builtin_popcount(i) == res)
			ans = (ans + dp[i]) % mod;
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Ameiyo (赞：3)

# PKUSC 2018 随机算法

$$ made \ by \ Ameiyo $$ 

---

[题目连接](https://www.luogu.com.cn/problem/P5492) 

用 $ f[i][s] $ 表示已经有 $ i $ 个点在排列里面，最大独立集的集合为 $ s $，这样的方案数。

对于当前不能加入最大独立集的点，在之后仍然不能加入，所以这些点可以被视为相同点，当做消耗品一样使用即可。

而可以加入的点，即加入后会使最大独立集变大的点，就直接放进 $ s $ 就行了。

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

#define ll long long
#define reg register
#define rep(i, a, b) for (reg int i = (a), i##end = (b); i <= i##end; ++i)
#define dep(i, a, b) for (reg int i = (a), i##end = (b); i >= i##end; --i)

template <typename _typer> inline _typer read() {
    _typer init = 0;
    char ch = getchar(), k = 0;
    for ( ; !isdigit(ch); ch = getchar()) k = (ch == '-');
    for ( ; isdigit(ch); ch = getchar())
        init = (init << 3) + (init << 1) + (ch ^ 48);
    return k ? -init : init;
}
const ll N = 25, INF = 1e9;
const ll M = (1 << 20), Mod = 998244353;

int n, m, G[N][N];
int tp[M], mk[N][M];
int f[N][M];

int Pow(int x, int k) {
    int ans = 1;
    for ( ; k > 0; x = 1ll * x * x % Mod, k >>= 1)
        ((k & 1) && (ans = 1ll * ans * x % Mod));
    return ans;
}

void Add(int &x, int y) { ((x += y) >= Mod && (x -= Mod)); }

int main() {
    n = read<int>(), m = read<int>();
    rep (i, 0, m - 1) {
        int x = read<int>() - 1, y = read<int>() - 1;
        G[x][y] = G[y][x] = true;
    }

    rep (i, 0, n - 1) tp[1 << i] = i, mk[i][0] = true;
    rep (i, 0, n - 1) rep (s, 1, (1 << n) - 1) if (!(s & (1 << i)))
        mk[i][s] = (mk[i][s & (s - 1)] && !G[i][tp[s & -s]]);

    f[0][0] = 1;
    // 不能放的点一直都不能放，所以可以算是一类点，就是把这部分处理掉就行了
    rep (i, 0, n - 1) rep (s, 0, (1 << n) - 1) if (f[i][s]) {
        reg int tmp = f[i][s], res = 0;
        rep (j, 0, n - 1) if (mk[j][s])
            ++res, Add(f[i + 1][s | (1 << j)], tmp);
        Add(f[i + 1][s], 1ll * tmp * (n - i - res) % Mod);
    }

    int Ans = 0, tot = 1, mx = 0;
    rep (i, 1, n) tot = 1ll * tot * i % Mod;
    rep (s, 0, (1 << n) - 1) if (f[n][s]) {
        int cnt = 0;
        for (int x = s; x > 0; x &= (x - 1)) ++cnt;
        if (cnt > mx) Ans = f[n][s], mx = cnt;
        else if (cnt == mx) Add(Ans, f[n][s]);
    }

//     cerr << Ans << endl;

    printf("%lld\n", 1ll * Ans * Pow(tot, Mod - 2) % Mod);
    return 0;
}
```

注意洛谷上卡内存，$ mk $ 数组开不了，但是 $ O(2 ^ n * n ^ 3) $ 可以过。。。

---

$$ in \ 2019.12.8 $$ 



---

## 作者：Unnamed114514 (赞：2)

为什么大家都写的是 dp 啊。

考虑记忆化搜索，我们显然必须得知道最大独立集的大小，问题问的是求正确率，因为要同时知道两个，所以开个 `pair` 记忆化。

然后的话这里我陷入了一个误区，我最先用的状态 $state$ 表示的是加入排列的状态，然后发现我不知道那些是在独立集里面的，导致复杂度退化到了 $O(n^23^n)$。

其实本质上不加入独立集的点是无用的，我们只需要知道加入独立集中的点，所以 $state$ 表示的是加入独立集中的点。

然后暴力枚举每个点就行了，注意只需要统计可以加入独立集的点，注意直接计数的时候，如果独立集加入不了，变成 $\dfrac{0}{0}$，此时其实概率应该是 $1$，特判一下即可。

另外，由于我太菜了，我只会写 $O(n^22^n)$ 的时间复杂度的代码，不过空间复杂度是 $O(2^n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
inline int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1) s=s*a%mod;
		a=a*a%mod,b>>=1;
	}
	return s;
}
pair<int,int> dp[1<<20];
int n,m;
bool f[25][25],vis[1<<20];
pair<int,int> dfs(int state){
	if(vis[state]) return dp[state];
	int cnt1=0,cnt2=0,mx=0;
	vis[state]=1;
	for(int i=1;i<=n;++i) if(!(state&(1<<i-1))){
		bool flg=1;
		for(int j=1;j<=n;++j) if((state&(1<<j-1))&&f[i][j]){
			flg=0;
			break;
		}
		if(flg){
			++cnt1;
			pair<int,int> p=dfs(state|(1<<i-1));
			++p.second;
			if(p.second>mx) cnt2=0,mx=p.second;
			if(p.second==mx) cnt2=(cnt2+p.first)%mod;
		}
	}
	if(!cnt1) return dp[state]=make_pair(1,0);
	return dp[state]=make_pair(cnt2*qpow(cnt1,mod-2)%mod,mx);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	while(m--){
		int u,v;
		cin>>u>>v;
		f[u][v]=f[v][u]=1;
	}
	cout<<dfs(0).first<<endl;
	return 0;
}
```

---

## 作者：mayike (赞：2)

[P5492 [PKUWC2018] 随机算法](https://www.luogu.com.cn/problem/P5492)

考场降智了。

这里说明以下：选 $x$ 是指进行了检查 $x\cup S$ 操作，淘汰是指其检查结果不属于独立集。

## 30pts

即对于 $n\le13$，可以直接 $O(n3^n)$ 状压，状态为 $0$ 表示当前点没选，$1$ 表示当前点选了且在独立集，$2$ 表示当前点选了但被淘汰，具体 $O(n)$ 转移，没了。

## 100pts

考虑优化，发现在转移的时候只有状态 $0,1$ 是有实际作用的，状态 $2$ 只不过是为了区分，就算把 $2$ 设成 $0$ 再去选独立集也会被淘汰。这启发我们直接舍去 $2$ 这个状态，新增一维 $j$ 表示有 $j$ 个数被淘汰，发现是可以转移的，且十分好转移。

直接**正推**转移，设状态 $f_{i,j}$ 表示选出独立集为 $i$ 且淘汰了 $j$ 个的方案数。设 $a_i$ 是与 $i$ 相邻点的集合。

如果有 `!(i>>k&1)&&!(a[k]&i)`，则

$$f_{i\cup2^k,j}\gets f_{i\cup2^k,j}+f_{i,j}$$

而枚举到一个独立集 $i$ 时，要转移一下淘汰的方案，即

```cpp
for(int k=y;k;k--)//y是(a[j]&i)!=0的个数
    for(int j=0;j<k;j++)f[i][k]=(f[i][k]+1ll*f[i][j]*A(y-j,k-j)%mod)%mod;
```

注意是从大到小循环，原因类似 01 背包。

最后是完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=21,mod=998244353;
int n,m,a[N],f[1<<N][N],sum[N],pr[N],mx,ans;
int pow_(int x,int y){
    int s=1;
    while(y){
        if(y&1)s=1ll*s*x%mod;
        x=1ll*x*x%mod;
        y>>=1;
    }
    return s;
}
int A(int x,int y){
    return x<y?0:1ll*sum[x]*pr[x-y]%mod;
}
int main(){
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        x--;
        y--;
        a[x]|=(1<<y);
        a[y]|=(1<<x);
    }
    sum[0]=1;
    for(int i=1;i<=n;i++)sum[i]=1ll*sum[i-1]*i%mod;
    pr[n]=pow_(sum[n],mod-2);
    for(int i=n;i;i--)pr[i-1]=1ll*pr[i]*i%mod;
    f[0][0]=1;
    for(int i=0;i<(1<<n);i++){
        int y=0;
        bool fg=1;
        for(int j=0;j<n;j++)
            if(i>>j&1)fg&=((a[j]&i)==0);
            else y+=((a[j]&i)!=0);
        if(!fg)continue;
        mx=max(mx,__builtin_popcount(i));
        for(int k=y;k;k--)
            for(int j=0;j<k;j++)f[i][k]=(f[i][k]+1ll*f[i][j]*A(y-j,k-j)%mod)%mod;
        for(int j=0;j<=y;j++)
            for(int k=0;k<n;k++)
                if(!(i>>k&1)&&!(a[k]&i))(f[i|(1<<k)][j]+=f[i][j])%=mod;
    }
    for(int i=0;i<(1<<n);i++)
        if(__builtin_popcount(i)==mx)ans=(ans+f[i][n-mx])%mod;
    cout<<1ll*ans*pr[n]%mod;
    return 0;
}
```

---

## 作者：LCat90 (赞：1)

非常暴力的做法。

设当前的点集为 $S$，考虑新加入一个点 $u$，判断是否可行。

设对于 $S$ 可以新加入的点个数为 $m$，则新加入一点 $u$ 的转移式就是：

$$dp_{S\cup \{u\}}\leftarrow dp_{S\cup \{u\}}+\dfrac{dp_S}{m}$$

最后看合法的最大 popcount 值就是最大独立集，加起来即可。时间为 $O(2^nn^2)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define pb push_back
using namespace std;
const int N = 21, M = (1 << 20) + 5, Mod = 998244353;
int qkpow(int a, int b) {
	if(b == 0) return 1;
	if(b & 1) return a * qkpow(a, b - 1) % Mod;
	int t = qkpow(a, b >> 1); return t * t % Mod; 
} 
int n, m, dp[M], sum, ans, maxn, num, phi[N];
bool vis[N][N], Vis[M]; bool can[N], f;  vector <int> G[N];
signed main() {
	cin >> n >> m; for(int i = 0;i <= n; ++i) phi[i] = qkpow(i, Mod - 2);
	for(int i = 1, x, y;i <= m; ++i) { 
		cin >> x >> y; vis[x][y] = vis[y][x] = 1; G[x].pb(y), G[y].pb(x); }
	dp[0] = 1; vector <int> g;
	for(int i = 0;i < (1 << n); ++i) { f = num = 0; g.clear();
		for(int i = 1;i <= n; ++i) can[i] = 0;
		for(int j = 1;j <= n; ++j) // 新加入
			if(!(i & (1 << (j - 1)))) { bool flag = 1;
				for(int k = 0;k < G[j].size(); ++k) 
					if(i & (1 << (G[j][k] - 1))) { flag = 0; break ; } 
				if(flag) f = 1, g.pb(j), num ++;
			}
		for(int j = 0;j < g.size(); ++j)
			dp[i | (1 << (g[j] - 1))] = (dp[i | (1 << (g[j] - 1))] + dp[i] * phi[num] % Mod);
		if(!f and dp[i]) 
		Vis[i] = 1, maxn = max(maxn, 1ll * __builtin_popcount(i));
	} 
	for(int i = 0;i < (1 << n); ++i)
		if(Vis[i] and maxn == 1ll * __builtin_popcount(i)) ans = (ans + dp[i]) % Mod;
	cout << ans;
	return 0;
}
/*
诈骗的，显然我们只需要算最终到达的状态数量就行了 
*/
```

---

## 作者：RockyYue (赞：1)

看到数据范围想到状态压缩，用一个二进制数表示一个点集 $S$。

独立集的所有子集均为独立集，可以在 $T\in S$ 且 $|T|=|S|-1$ 的基础上尝试加入一个点进行转移。

而题目又要求最大，即那么：
1. $T$ 中取的也要是最大独立集；
2. $T$ 在尝试加入一个点后大小为 $S$ 中最大独立集大小。

对应有两个想法：
1. 记 $f_S$ 为只在 $S$ 中进行题目的过程，可以取到 $S$ 中最大独立集的概率；
2. 还要记录每个点集的最大独立集大小来判断是否可以从某个子集转移，记为 $sz_S$。

接下来考虑转移，对于 $S$，枚举一个点 $u\in S$，把 $u$ 及与其连边的所有点从 $S$ 中删除，设这个集合为 $T$，至此 $S$ 中最大独立集便可从 $T$ 中最大独立集加上点 $u$ 转移来，于是对于所有这样得出的 $T$：
1. $sz_u=\max_{T}\{sz_T+1\}$；
2. $f_u=\frac{\sum_{T}{\left([sz_T=sz_S-1]\cdot f_T\right)}}{|S|}$。

最终答案为 $f_{\{1,2,\dots n\}}$，复杂度为 $O(2^nn)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 21, P = 998244353;
vector<int> g[N];
ll f[1 << N]; int sz[1 << N];
ll qpow(ll x, int y) {
	ll res = 1;
	while (y) {
		if (y & 1) res *= x, res %= P;
		x *= x, x %= P, y >>= 1;
	}
	return res;
}
inline int inv(int x) { return qpow(x, P - 2); }
ll Inv[N];
signed main() {
	ios :: sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int n, m; cin >> n >> m;
	for (int i = 1; i <= n; ++i) g[i].push_back(i);
	while (m--) {
		int u, v; cin >> u >> v;
		g[u].push_back(v), g[v].push_back(u);
	}
	f[0] = 1, sz[0] = 0;
	for (int i = 1; i <= n; ++i) Inv[i] = inv(i);
	for (int S = 1; S < (1 << n); ++S) {
		vector<int> V;
		int popcnt = 0;
		for (int i = 0; i < n; ++i) {
			if ((S >> i) & 1) V.push_back(i + 1), ++popcnt;
		}
		int invS = Inv[popcnt];
		for (int u : V) {
			int T = S;
			for (int v : g[u]) T &= (((1 << n) - 1) ^ (1 << v - 1));
			sz[S] = max(sz[S], sz[T] + 1);
		}
		for (int u : V) {
			int T = S;
			for (int v : g[u]) T &= (((1 << n) - 1) ^ (1 << v - 1));
			f[S] += (sz[T] == sz[S] - 1) * f[T] % P; f[S] %= P;
		}
		f[S] *= invS; f[S] %= P;
	}
	cout << f[(1 << n) - 1] << '\n';
	return 0;
}
```

---

## 作者：Gold_Dino (赞：1)

# 题解

写了一发 $ \Omicron(2^n n) $，发现过了，但是跟题解都不一样，来写题解。

## 正文

### 题意

给你一张 $n$ 个点，$m$ 条边的图，让你数有多少个排列（或者直接数概率），满足按照排列的顺序能贪心地生成出一个最大独立集。

### step 1

先考虑找最大独立集。

注意到一般图最大独立集是 NP 完全问题，但 $ n \le 20 $，可以直接 $ \Omicron(2^n) $ 的时间暴力找每个独立集。

因此有这样一个可行思路：先找出所有最大独立集，再分别算每个独立集的方案数。

### step 2

发现这样一个事实：我们只关心最大独立集里面点的标号，而对于不在最大独立集里的点，我们只关心他们的出现位置。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/nscsgk82.png)

对于上面这张图，圆点表示在最大独立集里的点。

对于 $l1$、$l2$、$l3$，这几段里的点一定在 $1$、$2$、$3$ 点的领域里，否则，该点会被加入最大独立集，矛盾。

那么我们只关心 $l1$、$l2$、$l3$ 这 $3$ 段中每个位置可选的点的个数。

### step 3

有了上面的思考，可以定义如下 dp 式子：

$ f_{i, S} $ 表示已经考虑了排列的前 $i$ 个位置，当前独立集为 $S$。

令 $ \mathrm{Ng}(u) $ 表示 $u$ 点的邻域（即与它相邻的点），$ N(S) $ 表示 $ \lor_{x \in S}\mathrm{Ng}(x) $。

那么发现，上面提到的 “可以选择的点的个数” 已经被包含在状态里了。

具体的：还有 $ |N(S)| - i + |S| $ 个点可以选进排列，但是不能被加进最大独立集。

有转移式：

![](https://cdn.luogu.com.cn/upload/image_hosting/gayhhm79.png)

## code


```cpp
#include <bits/stdc++.h>

using namespace std;

#ifdef local_ctz
#define info(...) fprintf(stderr, __VA_ARGS__)
#else
#define info(...) (__VA_ARGS__)
#endif

using ll_t = long long;

#define popcount(s) __builtin_popcount(s)

const int N = 21, S = 1048587;
const int mod = 998244353;

int n, m;
int ng[N];
ll_t dp[N][S];

ll_t Pow(ll_t a, int n = mod - 2)
{
    ll_t r = 1;
    for (; n; (a *= a) %= mod, n >>= 1)
        if (n & 1)
            (r *= a) %= mod;
    return r;
}

int main()
{
    ios::sync_with_stdio(false), cin.tie(NULL);
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        ng[u] |= (1 << (v - 1));
        ng[v] |= (1 << (u - 1));
    }
    int U = (1 << n);
    dp[0][0] = 1;
    for (int i = 0; i < n; ++i)
        for (int s = 0; s < U; ++s)
        {
            if (!dp[i][s])
                continue;
            int ns = 0;
            for (int u = 1; u <= n; ++u)
                if (s & (1 << (u - 1)))
                    ns |= ng[u];
            (dp[i + 1][s] += dp[i][s] * (popcount(ns) - (i - popcount(s))) % mod) %= mod;
            for (int u = 1; u <= n; ++u)
                if (!(ns & (1 << (u - 1))) && !(s & (1 << (u - 1))))
                    (dp[i + 1][s | (1 << (u - 1))] += dp[i][s]) %= mod;
        }
    int maxc = 0;
    for (int s = 0; s < U; ++s)
        if (dp[n][s])
            maxc = max(maxc, popcount(s));
    ll_t ans = 0;
    for (int s = 0; s < U; ++s)
        if (popcount(s) == maxc)
            (ans += dp[n][s]) %= mod;
    ll_t t = 1;
    for (int i = 1; i <= n; ++i)
        (t *= i) %= mod;
    printf("%lld\n", ans * Pow(t) % mod);
    return 0;
}
```


###### ~~希望能过审！！！~~

---

## 作者：zero4338 (赞：1)

## Solution
我们可以先求出所有的最大独立集 , 这个直接枚举所有子集之后进行判定即可 .  
一个图的最大独立集个数为一般不会太大 , 且本题中 $n\leq 20$ , 所以个数很小 , 本题数据中最多的个数只达到了 76 个 , 那么我们考虑枚举所有最大独立集 .  
设 $f_j$表示集合 $j$ 中所有的元素进行排列 , 按照题目的算法得出的集合是当前枚举的最大独立集的子集的方案数 .  
设当前枚举的最大独立集为 $i$ ,  
那么有转移 $f_{j\cup k}+=f_j$ , 当  
1. $k\in i$ , 即 $k$ 属于当前枚举的最大独立集
2. $k\cup(j\cap i)$ 不是独立集 , 即新加入的 $k$ 不会被加入集合

求出的 $f_{all}$ 即为求出集合为当前枚举的最大独立集的序列数 , 其中 $all$ 为全集 ,  
答案即为所有 $f_{all}$ 的和   
对于每一个最大独立集枚举全部状态和转移为 $O(n*2^n)$ , 
总时间复杂度为 $O(n2^n*$玄学$)$ , 不过也跑不满 .  
卡最大独立集数量的 hack 数据
```latex
20 10
1 2
3 4
5 6
7 8
9 10
11 12
13 14
15 16
17 18
19 20
```

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define il inline
#define reg register
using namespace std;
il int read()
{
    reg int ret=0;reg char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
    return ret;
}
const int maxn=20;
const int maxm=200;
const int mod=998244353;
int n,m;
il int qpow(reg int a,reg int b)
{
    reg int ret=1;
    for(;b;b>>=1)
    {
        if(b&1)ret=(ll)ret*a%mod;
        a=(ll)a*a%mod;
    }
    return ret;
}
il int qmod(reg int a){return a>=mod?a-mod:a;}
int ord[1<<maxn];
int to[maxn];
il void link(reg int x,reg int y){to[x]|=(1<<y);to[y]|=(1<<x);}//记录一个点的可达点集合
il bool judge(reg int x)//判断是否为独立集
{
    while(x)
    {
        reg int now=x&(-x);
        x-=now;
        now=ord[now];
        if(x&to[now])return false;
    }
    return true;
}
il bool judge(reg int x,reg int p)//判断点x和集合p的并集是否为独立集
{
    if(to[x]&p)return false;
    return true;
}
int all;
bool ind[1<<maxn];int cnt[1<<maxn];int mx;
int f[1<<maxn],ans;
int main()
{
    n=read();m=read();all=(1<<n)-1;
    for(int i=0;i<n;i++)ord[1<<i]=i;
    for(reg int i=1;i<=m;i++)link(read()-1,read()-1);
    for(reg int i=0;i<=all;i++)cnt[i]=cnt[i>>1]+(i&1);
    for(reg int i=all;i>=0;i--)//求出所有最大独立集
    {
        if(cnt[i]<mx)continue;
        if(judge(i))mx=cnt[i],ind[i]=1;
    }
    for(reg int i=0;i<=all;i++)
    {
        if(cnt[i]<mx||!ind[i])continue;
        for(reg int j=0;j<=all;j++)f[j]=0;
        f[0]=1;
        for(reg int j=0;j<=all;j++)
        {
            if(!f[j])continue;
            reg int np=j&i;
            for(reg int k=0;k<n;k++)
            {
                if((j>>k)&1)continue;
                if(((i>>k)&1)||!judge(k,np))f[j|(1<<k)]=qmod(f[j|(1<<k)]+f[j]);
            }
        }
        ans=qmod(ans+f[all]);
    }
    for(reg int i=2;i<=n;i++)ans=(ll)ans*qpow(i,mod-2)%mod;
    printf("%d",ans);
    return 0;
}
```


---

## 作者：Flan (赞：1)

> 给你一张无向图。使用如下算法生成一个独立集：
>
> - 随机生成一个排列 $p$。令 $S=\varnothing$。
> - 按 $i=1...n$ 的顺序，若 $\{p_i\}\cup S$ 是一个独立集，则使 $S=\{p_i\}\cup S$。
> 
> 求最终 $S$ 为图的最大独立集的概率。

分享一个普及水平的做法。

先使用状压 DP 求出图的所有最大独立集。对于每个最大独立集，暴力 DP 求可行排列数。

事实上，根据 [这篇论文](https://projecteuclid.org/download/pdf_1/euclid.twjm/1500407302)，阶为 $20$ 的图的最大独立集个数至多有 $1020$ 个，所以这种做法的时间频度是可以被卡成数十亿的。不过一般的图远远无法卡到上限，比如该题的最大测试点仅有 $18$ 个最大独立集。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

typedef long long ll;
const int MOD = 998244353;

int qpow(int a, int b){
	int res = 1;
	while(b){
		if(b & 1) res = (ll)res * a % MOD;
		a = (ll)a * a % MOD, b >>= 1;
	}
	return res;
}

int n, m, vist, G[20], pop[1 << 20], tot, ans, fact = 1, f[1 << 20] = {1}, lg[1 << 20] = {-1};
std::vector<bool> dp;

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; ++i){
		int u, v;
		scanf("%d%d", &u, &v), --u, --v;
		G[u] |= 1 << v, G[v] |= 1 << u;
	}
	dp.resize(1 << n), dp[0] = 1;
	for(int i = 1; i < (1 << n); ++i){
		pop[i] = pop[i >> 1] + (i & 1), lg[i] = lg[i >> 1] + 1;
		for(int j = 0; j < n; ++j)
			if(!(G[j] & i) && (i & (1 << j) && dp[i ^ (1 << j)])){
				dp[i] = 1, tot = std::max(tot, pop[i]);
				break;
			}
	}
	for(int S = 0; S < (1 << n); ++S)
		if(pop[S] == tot && dp[S]){
			for(int i = 1; i < (1 << n); ++i){
				f[i] = 0;
				for(int x = i; x; x -= x & -x){
					static int j; j = lg[x & -x];
					if(!(S & (1 << j)) && !(i & G[j] & S))
						continue;
					f[i] = (f[i] + f[i ^ (1 << j)]) % MOD;
				}
			}
			ans = (ans + f[(1 << n) - 1]) % MOD;
		}
	for(int i = 1; i <= n; ++i) fact = (ll)fact * i % MOD;
	ans = (ll)ans * qpow(fact, MOD - 2) % MOD;
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：charm1 (赞：1)

## 思路

首先我们发现在这道题中，所有没有进最终独立集的点，都可以不用去考虑，因为它们的顺序对答案没有影响，所以，题意就可以转化为：

**对于 $n$ 个点不停随机选未与当前点集连边的点等概率加入点集，求最终点集大小取得最大值的概率。**

## 实现

然后dp枚举下一个与当前子集不交的数， $O(n^2)$ 转移。
最后计算最大子集总概率之和即可。

有一个小优化，就是预处理出每一个点可到达的点集，这样可将判断一个是否与集合相交优化至 $O(1)$ 。 

所以总复杂度为 $ O(2^n*n)$ 。

## 代码

丑陋的代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=21;
const int maxm=1048605;
const int dd=998244353;
int n,m,siz;
int a[maxm],con[maxm],dp[maxm],Inv[maxm],cnt[maxm];
signed lg[maxm];
inline int read(){
	int ret=0,f=1;	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline int qpow(int x,int p){
	int ans=1;
	if(x==0)    return 0;
	while(p){
		if(p&1) ans=ans*x%dd;
		x=x*x%dd;   p>>=1;
	}
	return ans%dd;
}
inline int inv(int x){return qpow(x,dd-2)%dd;}
inline signed mod1(int x){return x>=dd?x-dd:x;}
signed main(){
	n=read(); m=read();
	for(int k=1;k<=(n<<1);k++) Inv[k]=inv(k);//预处理逆元
	for(int k=1;k<=m;k++){
		int x,y;
		x=read(); y=read();
		con[x]|=(1<<y-1);
		con[y]|=(1<<x-1);
		//处理出每一个点可到达的点集
	}
	for(int k=1;k<=n;k++) con[k]|=(1<<k-1);
	dp[0]=1; int siz=0; cnt[0]=0;
	for(register signed k=0;k<(1<<n);k++)
	if(dp[k]){
		int x=dp[k];
		if(k) cnt[k]=cnt[k^(k&(-k))]+1;
		//cnt为当前点所选元素个数
		siz=max(siz,cnt[k]);
		//siz为最大独立集大小
		signed s=0;
		for(register signed j=1;j<=n;j++)
		if(!(con[j]&k)) s++;//枚举一个点的转移数
		for(register signed j=1;j<=n;j++)
		if(!(con[j]&k)){
			signed p=(k|(1<<j-1));
			dp[p]=mod1(dp[p]+x*Inv[s]%dd);
			//转移每个点随机，直接除以转移数即可
		}
	}
	signed ans=0;
	for(register signed k=1;k<(1<<n);k++)
	if(cnt[k]==siz) ans=mod1(ans+dp[k]);
	printf("%lld\n",ans);
	return 0;
}

```



PS:最优解卡不动/kk,我菜啊

---

## 作者：suzhikz (赞：0)

范围告诉我们大概率是状压。

先考虑朴素的做法，因为枚举过的点和包括在独立集内的点会对答案产生影响，所以在 dp 的时候这两个都要记录，然后在转移的时候还要 $n^2$ 枚举距离，所以复杂度是 $O(2^{2n}n^2)$ ，显然是过不去的。

考虑如何优化，发现一个点被选上之后会使得周围的点都不能选上，所以我们可以把能加入独立集的点和它周围所有点打包加入状压，这样就不用考虑独立集的点是啥了，因为这些点直接打包加入就对别的点没有影响了。

贡献怎么算呢？就是把加入独立集的点放在第一个，他周围的点随便在后面插入就好了。

还有就是对于每种选点我们只需要保留独立集个数最多的部分。

主要代码长这样。

```cpp
for(int i=0;i<(1<<n);i++){
		for(int j=0;j<n;j++){
			if(((1<<j)&i)==0){
				int fl=(1<<j);
				for(int k=0;k<n;k++){
					if(k==j)continue;
					if(g[j][k]==1){
						fl|=(1<<k);
					}
				}
//				cout<<i<<' '<<j<<' '<<fl<<endl;
				if(maxx[i|fl]==maxx[i]+1){
					dp[i|fl]+=dp[i]*A[n-popcount(i)-1][popcount(fl)-popcount(fl&i)-1]%mod;
					dp[i|fl]%=mod;
				}else if(maxx[i|fl]<=maxx[i]){
					maxx[i|fl]=maxx[i]+1;
					dp[i|fl]=dp[i]*A[n-popcount(i)-1][popcount(fl)-popcount(fl&i)-1]%mod;
				}
			}
		}
	}
```

---

## 作者：biyi_mouse (赞：0)

诡异做法。

首先最大独立集大小可以高维前缀和 $\Theta(n2^n)$ 求。 

然后考虑三进制状压，$0$ 为没考虑，$1$ 为选进独立集，$2$ 为被独立集中的点排斥，设 $F_S$ 表示取到 $S$ 的概率。那么答案就是 $1$ 的个数与最大独立集大小相等的 $S$ 的概率相加。

直接做是 $\Theta(3^n)$ 的烂完了，但注意到合法的状态很少，于是全部搜出来后再 DP 即可。

代码比较困难。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i, a, b) for (int i = (a); i <= (b); i ++)
#define fro(i, a, b) for (int i = (a); i >= b; i --)
#define INF 0x3f3f3f3f
#define eps 1e-6
#define lowbit(x) (x & (-x))
#define reg register
#define IL inline
typedef long long LL;
typedef std::pair<int, int> PII;
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    return x * f;
}

const int N = 21, Mod = 998244353;
int n, m, k;
int a[N][N], pw3[N], g[1 << N];
unordered_set<int> h;
vector<int> states, f, p, cnt;

IL int qmi(int a, int b = Mod - 2, int p = Mod) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        b >>= 1; a = a * a % p;
    }
    return res;
}

void dfs(int S) {
    if (h.count(S)) return;
    h.insert(S); states.push_back(S);
    for (int i = 1; i <= n; i ++) {
        int T = S; 
        if (S / pw3[i - 1] % 3) continue;
        S += pw3[i - 1]; bool f = true;
        for (int j = 1; j <= n; j ++)
            if (a[i][j]) {
                if (S / pw3[j - 1] % 3 == 1) { f = false; break; }
                if (S / pw3[j - 1] % 3 != 2) S += pw3[j - 1] * 2;
            }
        if (f) dfs(S); 
        S = T;   
    }
}   

void calc(int S) {
    for (int i = 1; i <= n; i ++) {
        int T = S; 
        if (S / pw3[i - 1] % 3) continue;
        S += pw3[i - 1]; bool f = true;
        for (int j = 1; j <= n; j ++)
            if (a[i][j]) {
                if (S / pw3[j - 1] % 3 == 1) { f = false; break; }
                if (S / pw3[j - 1] % 3 != 2) S += pw3[j - 1] * 2;
            }
        if (f && h.count(S)) p.push_back(S);
        S = T;   
    }
}

signed main() {
    n = read(), m = read();
    while (m --) {
        int x = read(), y = read();
        a[x][y] = a[y][x] = 1; 
    } 
    pw3[0] = 1;
    for (int i = 1; i <= 20; i ++) pw3[i] = pw3[i - 1] * 3; 

    dfs(0); sort(states.begin(), states.end());
    k = states.size(); f.resize(k + 5), cnt.resize(k + 5);
    for (int i = 0; i < states.size(); i ++)
        for (int j = 0; j < n; j ++) 
            if (!(states[i] / pw3[j] % 3)) cnt[i] ++;
    f[0] = 1;
    for (int i = 0; i < states.size(); i ++) {
        int S = states[i]; p.clear(); calc(S);
        for (auto T : p) {
            int j = lower_bound(states.begin(), states.end(), T) - states.begin();
            f[j] += f[i] * qmi(cnt[i]) % Mod, f[j] %= Mod; 
        } 
    }

    for (int i = 1; i <= n; i ++)
        for (int j = i + 1; j <= n; j ++)
            if (a[i][j]) g[(1 << (i - 1)) | (1 << (j - 1))] = 1;
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j < (1 << n); j ++) 
            if (!(j >> (i - 1) & 1)) g[j | (1 << (i - 1))] |= g[j];
    int res = 0;
    for (int i = 0; i < (1 << n); i ++)
        if (!g[i]) res = max(res, (LL)__builtin_popcount(i));

    // for (int i = 0; i < states.size(); i ++)
    //     cout << states[i] << ' ' << f[i] << endl;
    int ans = 0;
    for (int i = 0; i < states.size(); i ++) {
        int s = 0;
        for (int j = 0; j < n; j ++)
            if (states[i] / pw3[j] % 3 == 1) s ++;
        if (s == res) ans = (ans + f[i]) % Mod;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：六楼溜刘 (赞：0)

# P5492 [PKUWC2018] 随机算法

[传送门](https://www.luogu.com.cn/problem/P5492)

## 题意

- 对于一张 $n$ 个点 $m$ 条边的简单无向图，考虑以下的最大独立集算法：
    - 将 $n$ 个点均匀随机排列（认为所有 $n!$ 种排列的出现概率是相等的）得到一个排列 $p_i$。
    - 维护一个集合 $S$，最初为空集，从 $p_1$ 开始遍历排列，假如 $p_i$ 和 $S$ 中所有点都没有连边则加入 $S$。
- 对于给定的图，求这个算法的正确率。我们认为这个算法正确当且仅当求出的 $|S|$ 等于最大独立集大小。
- $1\le n\le 20,0\le m\le \binom{n}{2}$。

## 题解

容易想到对能求出正解的排列计数来算概率。一眼能看出 $O(3^nn)$ 的状压 DP，就是设 $f_{msk}$ 表示得到状态 $msk$ 的方案数，其中 $msk$ 是一个三进制数，每一位表示每个点的三种状态，转移枚举下一个点即可。最终统计答案只需遍历所有状态找到独立集最大的全部加起来。

仔细想想为什么要 $3^n$，因为每个点有三个状态：已经被遍历过了并且在 $S$ 中，已经被遍历过并且不在 $S$ 中，还没被遍历过。这个非常不好优化，因为转移时需要确定每个点的状态才能知道新点是否加入 $S$ 集合。

考虑能不能将一些东西捆绑在一起转移，因为我们统计答案时只关注独立集的大小，不难想到对**没被遍历过的点**做文章，将点分为三种：已经被遍历过（第一类），和 $S$ 有边并且没被遍历过（第二类），和 $S$ 没有边并且没被遍历过（第三类）。

这样有什么用呢？容易发现此时我们加入一个第二类的点时并不关心这个点具体是什么，因为它不会加入集合 $S$，在序列中可以任意排列不产生影响，所以我们只需要记录它的数量就可以转移了！这就做到了我们期望的“捆绑在一起转移”。

于是设 $f_{msk,i}$ 表示一二类点的并集为 $msk$，其中有 $i$ 个二类点的最大独立集大小，$g_{msk,i}$ 表示能得到这个状态的排列数，转移要么消耗一个三类点，要么消耗一个二类点，具体见代码。

初始状态是 $f_{0,0}=0,g_{0,0}=1$，最后合法的排列数就是 $g_{n,0}$。

复杂度 $O(n^22^n)$。

## code

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=25,mod=998244353;
int ksm(int a,int b){
    int c=1;
    while(b){
        if(b&1) c=1ll*a*c%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return c;
}
int n,m;
int grp[N],f[1<<20][N],g[1<<20][N];
signed main(){
    n=read();m=read();
    forup(i,0,n-1) grp[i]|=1<<i;
    forup(i,1,m){
        int u=read()-1,v=read()-1;//下标从 0 开始方便状态压缩。
        grp[u]|=(1<<v);
        grp[v]|=(1<<u);
    }
    f[0][0]=0;g[0][0]=1;
    forup(msk,0,(1<<n)-1){
        fordown(i,__builtin_popcount(msk),0){
            if(!g[msk][i]) continue;
            if(i){//消耗一个二类点，只影响 i。
                if(f[msk][i]>f[msk][i-1]){
                    f[msk][i-1]=f[msk][i];
                    g[msk][i-1]=1ll*g[msk][i]*i%mod;//注意有 i 种选法。
                }else if(f[msk][i]==f[msk][i-1]){
                    (g[msk][i-1]+=1ll*g[msk][i]*i%mod)%=mod;
                }
            }
            forup(j,0,n-1){//消耗一个三类点，更新 msk 和 i。
                if(msk&(1<<j)) continue;
                int nxt=msk|grp[j],ni=i+__builtin_popcount(nxt^msk)-1;
                if(f[msk][i]+1>f[nxt][ni]){
                    f[nxt][ni]=f[msk][i]+1;
                    g[nxt][ni]=g[msk][i];
                }else if(f[msk][i]+1==f[nxt][ni]){
                    (g[nxt][ni]+=g[msk][i])%=mod;
                }
            }
        }
    }
    int ff=1;
    forup(i,1,n) ff=1ll*ff*i%mod;//计算排列总数，即阶乘，答案记得除以阶乘。
    printf("%lld\n",1ll*g[(1<<n)-1][0]*ksm(ff,mod-2)%mod);
}
```

---

## 作者：ZhongYuLin (赞：0)

设：$f_S$ 表示选取独立集为 $S$ 的概率（乱序）。

我们先将不是独立集的集合判断出来，并顺便求出每个独立集还可以选多少点，因为不能加进来的总是不影响概率。

考虑在集合 $S$ 中加入一个点 $x$ 得到 $T$，$T=S\cup{x}$。记 $S$ 还可以加入 $n$ 个点。显然，$x$ 恰好在此刻被加入的概率为 $\frac{1}{n}$。

```cpp
#include<bits/stdc++.h>
#define bcp(x) __builtin_popcount(x)
using namespace std;
using ll=long long;
const int N=20,P=998244353;
inline int add(int x,int y){return x+y>=P?x+y-P:x+y;}
inline int dlt(int x,int y){return x-y<0?x-y+P:x-y;}
ll fp(ll a,ll b=P-2){ll ans=1;for(;b;b>>=1,a=a*a%P)if(b&1)ans=ans*a%P;return ans;}
int g[N],lim[1<<N],cnt[1<<N];
ll f[1<<N];
int n,m,mx;
int main(){
    int u,v,w,x,y,z;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;++i)cin>>u>>v,--u,--v,g[u]|=1<<v,g[v]|=1<<u;
    for(int s=0;s<1<<n;++s)
        for(int i=0;i<n;++i)
            if(s&(1<<i))
                if(g[i]&s)lim[s]=-1;
                else if(g[i]!=-1)lim[s]|=g[i];
    for(int s=0;s<1<<n;++s)
        if(lim[s]!=-1){
            mx=max(mx,bcp(s));
            for(int i=0;i<n;++i)
                if(!(s&(1<<i))&&!(s&g[i]))++cnt[s];
            cnt[s]=fp(cnt[s]);
        }
    f[0]=1;
    for(int s=1;s<1<<n;++s)if(lim[s]!=-1)
        for(int i=0;i<n;++i)if(s&(1<<i)){
            int t=s^(1<<i);
            f[s]=add(f[s],f[t]*cnt[t]%P);
        }
    int ans=0;
    for(int s=0;s<1<<n;++s)
        if(bcp(s)==mx&&lim[s]!=-1)
            ans=add(ans,f[s]);
    printf("%d\n",ans);
    return 0;
}
```

---


# [JSOI2011] 柠檬

## 题目描述

$\text{Flute}$ 很喜欢柠檬。它准备了一串用树枝串起来的贝壳，打算用一种魔法把贝壳变成柠檬。贝壳一共有 $n$ $(1≤n≤100000)$ 只，按顺序串在树枝上。为了方便，我们从左到右给贝壳编号 $1..n$ 。每只贝壳的大小不一定相同，贝壳 $i$ 的大小为 $s_i(1≤s_i≤10000)$ 。

变柠檬的魔法要求$:\ \text{Flute}$ 每次从树枝一端取下一小段连续的贝壳，并选择一种贝壳的大小 $s_0$。如果这一小段贝壳中大小为 $s_0$ 的贝壳有 $t$ 只，那么魔法可以把这一小段贝壳变成 $s_0t^2$ 只柠檬。$\text{Flute}$ 可以取任意多次贝壳，直到树枝上的贝壳被全部取完。各个小段中，$\text{Flute}$ 选择的贝壳大小 $s_0$ 可以不同。而最终 $\text{Flute}$ 得到的柠檬数，就是所有小段柠檬数的总和。

$\text{Flute}$ 想知道，它最多能用这一串贝壳
变出多少柠檬。请你帮忙解决这个问题。

## 说明/提示

$\text{Flute}$ 先从左端取下 $4$ 只贝壳，它们的大小为 $2, 2, 5, 2$。选择 $s_0=2$，那么这一段里有 $3$ 只大小为 $s_0$ 的贝壳，通过魔法可以得到 $2×3^2 = 18$ 只柠檬。再从右端取下最后一只贝壳，通过魔法可以得到 $3×1^2 = 3$ 只柠檬。总共可以得到 $18+3=21$ 只柠檬。没有比这更优的方案了。

## 样例 #1

### 输入

```
5
2
2
5
2
3```

### 输出

```
21```

# 题解

## 作者：皎月半洒花 (赞：59)

这里说一种决策单调性+单调栈+二分的做法。

首先考虑是否有决策单调性。对于一个$i$，设其最优决策点为$o_i$，那么一定有$color[i]=color[o_i]$。

那么转移方程就很容易列出来：

$$f_i=\max_{color_i=color_j}\{ f_{j-1}+color_i\cdot (sum_i-sum_j+1)^2\} \quad (j<i)$$

观察这个式子，会发现一个性质，因为转移只在相同颜色间转移，所以对于后面的$color_i\cdot (sum_i-sum_j+1)$是随着$i$的变化而单增的，也就是说对于一个$j_1<j_2$，一开始时满足$j_1$更优，那么随着$i$增大$j_2$就永远不会比$j_1$更优，因为二次函数的增长对于更优的$j_1$只会增长得更快（类似于输在起跑线上233）。

所以发现是具有决策单调性的，即同一段区间的、同一种颜色的决策点会出现不增的局面。

那么一个自然的想法使用单调栈维护，发现第二个元素比第一个元素优的时候$pop$掉即可。但是问题在于当前点的最终决策点可能会更靠前，比如$j_1<j_2<j_3$但$val(j_1)>val(j_3)>val(j_2)$，就应该从$j_1$转移。


但事实上，根据大趋势而言，出现上述那种情况当且仅当一段时间内$j_2$比$j_1$更优（否则当时就不会入栈），之后$j_1$开始比$j_2$优（导致出现了现在的$val(j_1)>val(j_2)$）。所以我们可以**二分出**一个确定的时间（此处时间的流淌用新的$color_i$个数的增多刻画）优劣关系发生变化，而如果这个时间在$\leq sum_i$
之前，那么就要$pop$掉$j_2$，因为没用了。

所以，每次加入元素的时候都要判断当前栈中$top-1$超过$top$
的元素的时间是否小于等于$top$超过要添加进来的$x$的时间，如果是就要把$top$给$pop$掉，因为在$top$超过$x$之前$top$就死了。

…… 这么一比较似乎斜率优化简直是`pj`算法，比决策单调性的思维难度不知道低到哪里去了（雾）。然而事实上这是比较`hard`的决策单调性，比较普通的满足全局的决策点单调，但是这道题要分颜色考虑才能发现决策点单调233

```cpp
#define o(a, b) stk[a][b]
#define sz(k) stk[k].size()
#define sp(k) stk[k].size() - 1
#define sq(k) stk[k].size() - 2
il LL calc(int p, int t){
    return dp[p - 1] + 1ll * base[p] * t * t ;
}
il int chk(int x, int y){
	rg int ret = N + 1 ;
	rg int l = 1, r = N, mid ; 
	while (l <= r){
		mid = (l + r) >> 1 ; 
		if (calc(x, mid - s[x] + 1) >= calc(y, mid - s[y] + 1))
			ret = mid, r = mid - 1 ; else l = mid + 1 ; 
	}
	return ret ;
}
int main(){
	cin >> N ; int i ; 
	for (i = 1 ; i <= N ; ++ i) 
		scanf("%d", &base[i]), s[i] = ++ buc[base[i]] ; 
	for (i = 1 ; i <= N ; ++ i){
		rg int t = base[i] ; 
		while (sz(t) >= 2 && chk(o(t, sq(t)), o(t, sp(t))) <= chk(o(t, sp(t)), i)) 
			stk[t].pop_back() ; stk[t].push_back(i) ; 
		while (sz(t) >= 2 && chk(o(t, sq(t)), o(t, sp(t))) <= s[i]) stk[t].pop_back() ;
		dp[i] = calc(o(t, sp(t)), s[i] - s[o(t, sp(t))] + 1) ;  
	}
	cout << dp[N] << endl ; return 0 ;
}
```

$\rm By~the~way$，一般情况下决策单调性只要写好分治就可以了，分治可以用的前提是当前维度的$\{f_i\}$彼此之间线性无关。

---

## 作者：kkkstra (赞：42)

[蒟蒻的博客QwQ](https://oi.kkkstra.cn/)

### Description

将一个数列分成若干段，从每一段中选定一个数$s_0$，假设这个数有$t$个，这一段价值为$s_0 t^2$，数列的总价值为每一段的价值和，要使最终的总价值最大，求这个总价值。

### Solution

首先要知道一个显然的性质，就是每一段的左右端点的贝壳大小一定是相等的，且这一段选定的$s_0$一定是左右端点的贝壳大小。

因为如果左右端点贝壳大小不相等的话，必然有一个端点对答案没有贡献，那么可以让一个端点端点和其它贝壳再构成新的一段，会使得答案更优。

设$f_i$表示前$i$个位置分成若干段的答案最大是多少，$c_i$表示$i$是相同大小的贝壳中的第几个，那么转移方程很容易可以写出来：

$$f_i = \max \limits_{0<j\le i,s_i=s_j} \left \{ f_{j-1 + s_i(c_i-c_j+1)^2} \right \}$$

~~显然~~这个式子有同时与$i$和$j$相关的项，可以斜率优化

先将式子展开，把$\max$去掉，$s_i$和$s_j$可以相互替换

$$f_i = f_j-1 + s_i c_i^2 - 2s_i c_i c_j + s_j c_j^2 + 2s_i c_i - 2 s_j c_j + s_i$$

把只和$i$有关的部分拿出来：$f_i-s_i c_i^2 - 2s_i c_i + s_i$

把只和$j$有关的部分拿出来：$f_{j-1}+s_j c_j^2 - 2s_j c_j$

把和$i,j$都有关的部分拿出来：$2s_i c_i c_j$

把$j$有关的部分放在左边，其余的放在右边，式子就变成了

$$f_{j-1}+s_j c_j^2 - 2s_j c_j = 2s_i c_i c_j + f_i-s_i c_i^2 - 2s_i c_i + s_i$$

令

$$
\begin{cases}
y = f_{j-1}+s_j c_j^2 - 2s_j c_j \\
k=2s_i c_i \\
x=c_j \\
b=f_i-s_i c_i^2 - 2s_i c_i + s_i
\end{cases}
$$

那么我们就可以将每一个决策看做一个点$(x_j,y_j)$，将每个状态看做一条斜率$2s_i c_i$的直线，每次转移就相当于让斜率为$k_i$的直线经过某个点使得截距最大。

显然这里需要维护一个上凸壳，因为$x_i$是单调递增的，所以每次决策的最优点在凸壳的最后一个点取到，于是维护一个单调栈，每次转移去栈顶即可。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int _ = 100000 + 10;
const int __ = 10000 + 10;
int n, tot[__];
ll s[_], c[_], f[_];
vector<int> stk[__];

inline ll X(int i) { return c[i]; }
inline ll Y(int i) { return f[i - 1] + s[i] * c[i] * c[i] - 2 * s[i] * c[i]; }
inline double slope(int i, int j) { return 1.0 * (Y(i) - Y(j)) / (X(i) - X(j)); }
inline ll calc(int i, int j) { return f[j - 1] + s[i] * (c[i] - c[j] + 1) * (c[i] - c[j] + 1); }

#define t1 stk[t][stk[t].size() - 1]
#define t2 stk[t][stk[t].size() - 2]

int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> s[i];
		c[i] = ++tot[s[i]];
	}
	for (int i = 1; i <= n; ++i) {
		int t = s[i];
		while (stk[t].size() >= 2 && slope(t2, i) >= slope(t2, t1)) stk[t].pop_back();
		stk[t].push_back(i);
		while (stk[t].size() >= 2 && calc(i, t1) <= calc(i, t2)) stk[t].pop_back();
		f[i] = calc(i, stk[t][stk[t].size() - 1]);
	}
	cout << f[n] << endl;
	return 0;
}
```

---

## 作者：LittleFall (赞：16)

给定长为$n$(1e5)的数列$s$(1e4)，将其分成若干连续段。

可以从一段中任选一个数$s_0$，这一段的贡献就是$cnt[s_0]^2*s_0$，其中$cnt[s_0]$表示这一段中$s_0$出现的次数。

求所有段的贡献之和的最大值。

---
一个基础的dp：

设$d_i$表示把前$i$个数分好的最大贡献，$d_0=0$.

$d_i = max\{d_{j-1}+cal(j,i)\}$，其中$0<j<=i$，$cal(a,b)$表示把$a$到$b$分成一段的最大贡献。

一个明显的问题是$cal(j,i)$难以计算，直接枚举的复杂度可能达到$O(n^3)$

---

结论：最优情况下，每一段的首尾数字必定相同，而且作为$s_0$。

证明：如果存在一个段的首部数字不是这个段的$s_0$，那么可以将其独立成段，贡献显然增加。尾部同理。

把$n$个位置按值分组，记$p_{i,j}$表示数值$i$在原数列中第$j$次（从第0次开始算）出现的位置，那么有：$s[p_{i,j}]=i$。

此时对于位置$p_{i,j}$，只应该从$p_{i,j}-1,p_{i,j-1}-1,p_{i,j-2}-1,...,p_{i,0}-1$去转移，且数值$i$出现的次数很容易算出，即：

$d[p_{i,j}] = max\{d[p_{i,k}-1]+i*(j-k+1)^2\}$，$0<=k<=j$

保存每个位置对应的$i,j$值，按$p_{i,j}$递增的顺序转移即可。

此时复杂度并不能完全满足需求，如果所有数值都相同还是会卡到$O(n^2)$，还需要进一步优化。

```cpp
int xi[M], xj[M]; 
vector<int> pos[10016];
ll dp[M];
int main()
{
	int n = read();
	for(int p=1; p<=n; ++p)
	{
		xi[p] = read();
		xj[p] = pos[xi[p]].size();
		pos[xi[p]].push_back(p);
	}
	for(int p=1; p<=n; ++p)
	{	
		int i = xi[p], j = xj[p]; 
		for(int k=0; k<=j; ++k)
			dp[p] = max(dp[p], dp[pos[i][k]-1] + 1ll*i*(j-k+1)*(j-k+1));
	}
	cout << dp[n] << "\n";
}
```
~~开O2直接AC了你敢信~~ 

---
以下内容需要**斜率优化**作为前置知识，可以自行了解或者察看[我的博客](https://blog.csdn.net/m0_37809890/article/details/102389121)qwq.

对于转移式：$d[p_{i,j}] = max\{d[p_{i,k}-1]+i*(j-k+1)^2\}$

整理得到：$d[p_{i,j}] = i(j+1)^2 +max\{d[p_{i,k}-1]+ik^2-2i(j+1)k\}$

设$a<b<j$，那么从$d[p_{i,b}-1]$转移比从$d[p_{i,a}-1]$转移更优等价于

$d[p_{i,b}-1]+ib^2-2i(j+1)b>d[p_{i,a}-1]+ia^2-2i(j+1)a$

整理得到：

$\frac{(d[p_{i,b}-1]+ib^2) - (d[p_{i,a}-1]+ia^2)}{b-a}>2i(j+1)$

由斜率优化原理：
1. $y_a=d[p_{i,a}-1]+ia^2,x_a=a,k=2i(j+1)$。
2. 符号是大于号，维护上凸包。
3. 上凸包斜率递减，目标斜率递增，所以在队尾操作。
4. 本质上是一个单调栈。

注意，需要给每一个$i$值都维护一个独立的凸包。

---

实现细节：
1. 单调栈中可以存放实际位置，$i$和$j$可以由推导得到。
2. 此题中求$dp[p]$时需要把$p$放入凸包中，所以操作顺序应该是：
	1. 准备放入p，把构成下凸点的栈顶弹出
	2. 放入p
	3. 更新目标斜率，把不满足目标斜率的栈顶弹出
	4. 求dp[p]

---
AC代码如下：
```cpp
ll xi[M], xj[M]; 
vector<int> pos[10016];
ll dp[M];

vector<int> ms[10016]; //单调栈
inline int t1(const vector<int> &vc){return vc[vc.size()-1];} //栈顶的第一个元素
inline int t2(const vector<int> &vc){return vc[vc.size()-2];} //栈顶的第二个元素
inline ll subx(int p1, int p2){return xj[p2]-xj[p1];}
inline ll suby(int p1, int p2){
	return (dp[p2-1] + xi[p2]*xj[p2]*xj[p2]) - (dp[p1-1] + xi[p1]*xj[p1]*xj[p1]);
}
inline ll cal(int p, int lp){
	return dp[lp-1] + xi[p]*(xj[p]-xj[lp]+1)*(xj[p]-xj[lp]+1);
}
int main(void)
{
	int n = read();
	for(int p=1; p<=n; ++p)
	{
		xi[p] = read();
		xj[p] = pos[xi[p]].size();
		pos[xi[p]].push_back(p);
	}

	for(int p=1; p<=n; ++p)
	{	
		int i = xi[p], j = xj[p]; 
		while(ms[i].size()>=2 &&
			suby(t2(ms[i]),t1(ms[i]))*subx(t1(ms[i]),p) <= subx(t2(ms[i]),t1(ms[i]))*suby(t1(ms[i]),p)
		) ms[i].pop_back(); 

		ms[i].push_back(p);

		while(ms[i].size()>=2 && suby(t2(ms[i]),t1(ms[i])) <= 2ll*i*(j+1)*subx(t2(ms[i]),t1(ms[i])))
			ms[i].pop_back();

		dp[p] = cal(p, t1(ms[i]));
	}
	cout << dp[n] << "\n";

    return 0;
}
```

---

## 作者：Karry5307 (赞：16)

### 题意

给定一段长度为$n$的序列$a$，要把它划分成许多段。对于每一段，选出一个数$p$，若$p$在这段序列中出现$k$次，则这段序列的贡献为$pk^2$。求出最大贡献和。

### 题解

斜率优化好题。~~但这无法掩盖我第一次写斜率优化的事实~~

首先有个显然的性质：**每一段的两端的数相同**。

如果不同的话，那些不同的数也不会给这一段有贡献，反而把它们分到另外的段去期望对其他段产生贡献，才能使贡献最大化。

于是可以设$dp_i$表示前面$i$个数产生的最大贡献，$c_i$表示这个数是第几次出现，则有

$$dp_i=\max\{dp_{j-1}+a_i\times(c_i-c_j+1)^2\}(i>j,a_i=a_j)$$

可这是$O(n^2)$的，跑不过,考虑斜率优化。

观察一下原来的式子，把与$j$有关的放到$y,x$项，与$j$无关的放到$k,b$项，则有

$$dp_i=dp_{j-1}+a_i\times(c_i^2+(c_j-1)^2-2c_i(c_j-1))$$

移项之后，有

$$dp_{j-1}+a_i(c_j-1)^2=2a_ic_i(c_j-1)+dp_i-a_ic_i^2$$

于是，有

$$\begin{cases}y=dp_{j-1}+a_i(c_j-1)^2\\k=2c_i\\x=a_i(c_j-1)\\b=dp_i-a_ic_i^2\end{cases}$$

于是考虑用一个单调栈维护$k$就行啦qwq

首先，如果栈顶的斜率比新加进来的斜率小，就一直弹栈。

把新加进来的斜率入栈。

如果栈顶斜率小于$2c_i$，就一直弹栈。

最后取栈顶就可以啦qwq

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=1e5+51;
vector<ll>q[MAXN>>3];
ll cnt,cur,top,tmp;
li num[MAXN],occ[MAXN],st[MAXN],x[MAXN],y[MAXN],dp[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline double slope(ll xx,ll yy)
{
	return (double)(y[yy]-y[xx])/(double)(x[yy]-x[xx]);
}
int main()
{
	cnt=read();
	for(register int i=1;i<=cnt;i++)
	{
		num[i]=read(),st[i]=++occ[num[i]];
	}
	for(register int i=1;i<=cnt;i++)
	{
		cur=num[i],top=q[cur].size()-1;
		x[i]=(st[i]-1)*cur,y[i]=x[i]*(st[i]-1)+dp[i-1];
		while(top>0&&slope(q[cur][top-1],q[cur][top])<slope(q[cur][top],i))
		{
			q[cur].pop_back(),top--;
		}
		q[cur].push_back(i),top++;
		while(top>0&&slope(q[cur][top-1],q[cur][top])<2*st[i])
		{
			q[cur].pop_back(),top--;
		}
		tmp=q[cur][top];
		dp[i]=dp[tmp-1]+cur*(st[i]-st[tmp]+1)*(st[i]-st[tmp]+1);
	}
	printf("%lld",dp[cnt]);
}
```

---

## 作者：ZhuMingYang (赞：13)

（毕竟是第一次做到用单调栈的斜率优化，就写篇题解吧）

首先，显然分成的每段两端点值应该相等  
因为若不相等则其中必有一点对当前段无贡献，则放到别的段中显然更优

设$dp_i$表示前$i$个数分成若干段所取得的最大值  
则有状态转移方程

$$dp_i=\max_{1\le j\le i,\ a_i=a_j}\{dp_{j-1}+a_i\times(sum_i-sum_j+1)^2\},sum_n=\sum_{i=1}^n[a_i=a_n]$$

拆开+整理 得：

$$dp_{j-1}+a_jsum_j^2=2a_jsum_j(sum_i+1)+dp_i-a_i(sum_i+1)^2$$

则令决策点$y=dp_{j-1}+a_jsum_j^2,x=2a_jsum_j$

发现求的是最大值，且截距越大$dp_i$越大，如图，无论斜率，下面的点永远不能优于上面的，**此时维护上凸包**

![](https://cdn.luogu.com.cn/upload/image_hosting/k9dj4gsx.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

又因为$sum_i+1$是单调递增的，如图，最后一段斜率大于$sum_i+1$时，取最后一个点，否则应该退到前面状态，并及时排除最后一段（斜率单调递增，最后一个点不可能再次比前一个点优），此时维护一个**单调栈**

![](https://cdn.luogu.com.cn/upload/image_hosting/6dtrds6g.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

*10.10 修改打错的符号*

**AC代码：**

~~~c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
#include<map>
#include<bitset>
#include<set>
#include<queue>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define dwn(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
typedef long long ll;
int n,a[100010],sum[100010],l[10010];
vector<int> st[10010];//vector模拟单调栈，开数组内存不够
ll dp[100010];
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
double slope(int x,int y)//求两决策点的斜率
{
    return (double)(dp[y-1]-dp[x-1]+(ll)a[y]*sum[y]*sum[y]-(ll)a[x]*sum[x]*sum[x])/(2*(a[y]*sum[y]-a[x]*sum[x]));
}
int main()
{
    n=read();
    rep(i,1,n)
    {
        a[i]=read();
        sum[i]=sum[l[a[i]]]+1;
        l[a[i]]=i;
    }
    rep(i,1,n)
    {
        while(st[a[i]].size()>1&&slope(st[a[i]][st[a[i]].size()-1],st[a[i]][st[a[i]].size()-2])<=slope(st[a[i]][st[a[i]].size()-1],i)) st[a[i]].pop_back();
        //确保单调栈维护的是上凸包
        st[a[i]].push_back(i);
        while(st[a[i]].size()>1&&slope(st[a[i]][st[a[i]].size()-1],st[a[i]][st[a[i]].size()-2])<=sum[i]+1) st[a[i]].pop_back();
        //把最后几段斜率小于sum[i]+1的决策排除
        dp[i]=dp[st[a[i]].back()-1]+(ll)a[i]*(sum[i]-sum[st[a[i]].back()]+1)*(sum[i]-sum[st[a[i]].back()]+1);
    }
    printf("%lld\n",dp[n]);
    return 0;
}
~~~

---

## 作者：MCAdam (赞：11)

[题目](https://www.luogu.com.cn/problem/P5504)

题意：有$n$个贝壳，每个贝壳有大小$v_i$。每次可以从左边取一段，也可以从右边取一段。取出来的一段中，选择其中的一种贝壳的大小$v_0$，那么这一段的贡献为$v_0*k^2$，$k$是这一段中大小为$v_0$的个数。

$n\leq 10^5,v_i\leq 10^4$

简化一下题目：

首先，题目说可以从左边取，也可以从右边取，但是取的顺序并不会影响答案。所以统一从左边取就可以了。

然后，我们在当前点$i$，选取的贝壳一定是$s_i$。假设从点$i$选的贝壳$v_0\neq v_i$，那么$k_i=k_{i-1}$，那我们在$i$处选择$v_0$这种贝壳和在$i-1$处选择这种贝壳贡献是一样的。完全可以在$i-1$处选择$v_0$这种贝壳，然后在$i$处独立为一个，这样贡献会更大。

既然这一段的最后是$v_i$，那我们也能同样推理出，这一段的开头也应该是$v_i$。假设开头不是$v_i$，那我们完全可以把开头往后移一位，然后原开头独立为一个。这样贡献也会更大。

所以我们一开始用一个桶统计出，$[1,i]$中为$v_i$的有多少个，记为$s_i$

设$f_i$表示到第$i$个贝壳取得的最大贡献，则

$\displaystyle f_i=\max\limits_{1\leq j\leq i,s_j=s_i}\{f_{j-1}+v_i(s_i-s_j+1)^2\}$

这也就说明了，不同颜色之间的转移是相互独立的。

为了方便叙述（代码也是那么写的），我们把同一种颜色的的怼到一个$vector$里。记$g_j=f_{j-1}$，$col$为这一堆的颜色。那么转移改写为

$f_i=\max\limits_{1\leq j\leq i}\{g_j+col(i-j+1)^2\}$

这时就可以写出暴力的代码了（~~O2可过~~）

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#define ll long long
using namespace std;
const int N=1e5+10,M=1e4+10;
struct node
{
	int p;
	int l,r;
}que[N];
int v;
ll f[N];
vector<int>col[M];
inline ll cal(int c,int j,int i)
{
	return f[col[c][j]-1]+(ll)c*(i-j+1)*(i-j+1);
}
int main()
{
	int v,n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&v);
		int len=col[v].size();
		if(len) 
		{
			for(int j=0;j<len;j++)
				f[i]=max(f[i],cal(v,j,len));
		}
		f[i]=max(f[i],f[i-1]+v);
		col[v].push_back(i);
	}
	printf("%lld\n",f[n]);
	return 0;	
} 

```
看到$(i-j+1)^2$考虑斜率优化

设决策$j,k$，$k$比$j$更优

那么有$g_k+col(i-k+1)^2\geq g_j+col(i-j+1)^2$

展开得：$g_k-2col\times i\times k+col\times k^2-2col\times k\geq g_j-2col\times i\times j+col\times j^2-2col\times j$

设$Y(j)=g_j+col\times j^2-2col\times j,X(j)=j$

得到：$\displaystyle \frac{Y(k)-Y(j)}{X(k)-X(j)}\geq 2col\times i$

这个转化为线性规划来理解就是：

一条斜率为$2col\times i$的目标直线，从上往下切到的第一个点就是最优决策点。我们要维护一个上凸壳，也就是斜率递减的决策点。

因为$i$是单调递增的，所以目标直线斜率是递增的

![](https://cdn.luogu.com.cn/upload/image_hosting/5d8iavoi.png)

设当前目标直线对应的是红线，它在点$3$取得最优决策，那么对于$i'>i$对应的目标直线斜率更大，对应橙线。那么决策点$4$永远不可能成为最优决策，直接扔掉就好了。注意到进队和出队都是在队尾进行的，本质上就是一个栈（实现时可以用$vector$）。

具体来说就是：

1、对于当前目标函数，如果栈顶保存的斜率小于$2col\times i$就出栈

2、栈顶保存的就是最优决策，计算出$f_i$

3、如果这条新的直线的斜率大于栈顶的斜率，栈顶出栈。

4、插入新的直线。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#define top sta[v].size()-1
#define ll long long
using namespace std;
const int N=1e5+10,M=1e4+10;
int v;
ll f[N];
vector<int>col[M],sta[M];
inline ll X(int c,int j){ return j; }
inline ll Y(int c,int j){ return f[col[c][j]-1]+(ll)c*j*j-2*c*j; }
inline ll cal(int c,int j,int i){ return f[col[c][j]-1]+(ll)c*(i-j+1)*(i-j+1); }
inline double slope(int c,int j,int k){ return (double)(Y(c,k)-Y(c,j))/(double)(X(c,k)-X(c,j)); }
int main()
{
	int v,n;
	scanf("%d",&n);
	for(int i=1;i<=10000;i++)
		col[i].push_back(0);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&v);
		int len=col[v].size();
		col[v].push_back(i);
		if(len==1) sta[v].push_back(len);
		else
		{
			while(sta[v].size()>1&&slope(v,sta[v][top-1],sta[v][top])<=2*v*len) sta[v].pop_back();
			f[i]=cal(v,sta[v][top],len);
			while(sta[v].size()>1&&slope(v,sta[v][top-1],sta[v][top])<=slope(v,sta[v][top],len)) sta[v].pop_back();
			sta[v].push_back(len);
		}
		f[i]=max(f[i],f[i-1]+v);
	}
	printf("%lld\n",f[n]);
	return 0;	
} 
```



---

## 作者：智子·起源 (赞：8)

## 贴一发李超线段树的做法awa

看李超直接跳到第三板块awa。

### 1、题意

通过睿智的大脑思考可以发现，此题是较为典型的 “分段决策” 类型动态规划，每一段产生的价值为任选一个大小种类，其大小与此种类在该段个数的平方之积。

### 2、推式子

我们设 $dp[i]$ 表示前i个贝壳所能做出的最大贡献。

那么 $dp[i]$ 可以由前面的 $dp[j]+v(j+1,i)$ 转移而来,

其中 $v(j+1,i)$ 表示 $[j+1,i]$ 这贝壳可产生的最大价值。(即上面 $max$ 那坨东西)

为了接下来的操作方便,我们将上面一步的操作改为"由前面的 $dp[j-1]+v(j+1,i)$ "转移而来。

此时,通过贪心的思想发现只有当 $i$ 和前面某个贝壳 $j$ 颜色一致时才需要转移,不然贝壳 $i$ 一点用都没有,还不如单独一个,这样还能算他一份价值。

于是可以推出式子:

( $s[a[i]][j]$ 表示 $a[i]$ 大小的贝壳到了第 $j$ 个位置前缀个数)

$dp[i]=max\{ dp[j-1]+a[i]\times (s[a[i]][i]-s[a[i]][j-1])^2 \} $


其中 $j∈[1,i]$ 且 $a[j]=a[i]$。

处理上式中 $max$ 里面的东西可以变成这个样子——

太烦了，用 $x$ 代替 $a[i]$ ：

$dp[j-1]+x\times s[x][i]^2-2x\times s[x][i]\times s[x][j-1]+x\times s[x][j-1]^2$

因为事实上贝壳大小（ $x$ ）可以直接当成常数（可转移的决策的位置上贝壳大小相同），且 $x\times s[x][i]^2$ 也可以当成常数，

而剩下的 $2x\times s[x][i]\times s[x][j-1]$ 和 $x\times s[x][j-1]^2$ 分别是和当前位置与之前决策都有关、只和之前决策有关的项。

于是就转化成了李超线段树可以解决的经典问题。

### 3、李超线段树

这篇题解默认大家都学过李超线段树qwq。

[不会戳这里（李超模板题）](https://www.luogu.com.cn/problem/P4254)

[还有这里，非常经典的李超优化dp](https://www.luogu.com.cn/problem/P4655)

接着思考如何用李超线段树实现这个过程。

首先上面的 $s$ 数组肯定不能用二维，但是由于题目的特殊性，其实无需记录所有位置的前缀和，开个 $10000$ 就行了。（看一眼我的程序可以很好理解）

然后就是对于每个大小的种类都得建一棵李超线段树，由于总共只有 $n$ 个贝壳，所以不会爆空间。

接着是要提前把需要查询的x坐标（上面的 $2x\times s[x][i]$ ）离散化一下就行了。

**简单来说，这道题的李超线段树需要动态开点和离散化。**

### 4、CODE

也不是很麻烦，但是很麻烦。（是我太粪了qwq）

```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 100005
#define MAXS 10005
using namespace std;
int n,a[MAXN];
int h[MAXS];
vector<int>A[MAXS];
int dp[MAXN];

int rt[MAXS],tot;
struct Line{
	int b,k;
	bool flg;
}tr[MAXN<<3];
int calc(Line L,int x){
	return L.k*x+L.b;
}
int ls[MAXN<<3],rs[MAXN<<3];
int build(int l,int r,int opt){
	int now=++tot,mid=l+r>>1;
	tr[now]={0,0,0};
	if(l==r){
		return now;
	}
	ls[now]=build(l,mid,opt);
	rs[now]=build(mid+1,r,opt);
	return now;
}
#define pos_l A[opt][l-1]
#define pos_r A[opt][r-1]
#define pos_m A[opt][mid-1]
//离散化的错误查了一个晚上qwq 
void modify(int now,int l,int r,Line x,int opt){
	if(!tr[now].flg){
		tr[now]=x;
		return;
	}
	if(calc(x,pos_l)>calc(tr[now],pos_l)&&calc(x,pos_r)>calc(tr[now],pos_r)){
		tr[now]=x;
		return;
	}
	if((calc(x,pos_l)>calc(tr[now],pos_l)) ^ (calc(x,pos_r)>calc(tr[now],pos_r))){
		int mid=l+r>>1;
		if(calc(x,pos_m)>calc(tr[now],pos_m)){
			swap(x,tr[now]);
		}
		if(calc(x,pos_l)>calc(tr[now],pos_l))
			modify(ls[now],l,mid,x,opt);
		else
			modify(rs[now],mid+1,r,x,opt);
	}
}
int query(int now,int l,int r,int x,int opt){
	if(l==r){
		return tr[now].flg?calc(tr[now],x):0;
	}
	int mid=l+r>>1,res=tr[now].flg?calc(tr[now],x):0;
	if(x<=pos_m)res=max(res,query(ls[now],l,mid,x,opt));
	else res=max(res,query(rs[now],mid+1,r,x,opt));
	return res;
}//除了离散化之外就是李超线段树板子，这里不多赘述 
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
		++h[a[i]];
		A[a[i]].push_back((a[i]<<1)*h[a[i]]);
		//离散化要查询的位置 
	}
	for(int i=1;i<=10000;++i){
		if(A[i].size()){
			sort(A[i].begin(),A[i].end());
			rt[i]=build(1,A[i].size(),i);
			//每个大小种类建一棵树 
		}
	}
	memset(h,0,sizeof h);
   //非常失败的写法qwq
	for(int i=1;i<=n;++i){
		++h[a[i]];
		Line t1={dp[i-1]+a[i]*(h[a[i]]-1)*(h[a[i]]-1),1-h[a[i]],1};
		modify(rt[a[i]],1,A[a[i]].size(),t1,a[i]);
		dp[i]=query(rt[a[i]],1,A[a[i]].size(),(a[i]<<1)*h[a[i]],a[i]);
		dp[i]+=a[i]*h[a[i]]*h[a[i]];
	}
	printf("%lld",dp[n]);
	return 0;
}
/*
6
1 1 4 5 1 4

20
*/
```

感谢大家看到最后！(* *╹▽╹* *)


---

## 作者：disangan233 (赞：6)

## 题意简述

给你一个长度为 $n(n\leq 10^5)$ 的序列，将其分成若干段，每段选择一个数，获得这个数的价值 $\times$ 它在这段出现次数的平方，求最大总价值。

## 做法

引理：对于任意一个 $i$，所选的最后一段所指定的 $s_0$ 定为 $s_i$。

证明：$i$ 这个点会在 $s_0 \not =s_i$ 没有贡献，不如最后一段只选 $i$。

所以考虑动态规划，令 $f_i$ 为以 $i$ 结尾的最大值，$c_i$ 为出现次数的前缀和，可以得到如下转移方程：

$$f_i=\max_{j\leq i \wedge s_i=s_j} \{f_{j-1}+s_i(c_i-c_{j}+1)^2\}$$

暴力求解是 $O\left(n^2\right)$ 的，发现 dp 方程中存在积的形式，考虑斜率优化可得：

$$f_i-s_i{c_i}^2=\max_{j\leq i \wedge s_i=s_j} \{f_{j-1}+s_i(c_{j}+1)^2-s_ic_i\times 2(c_j-1)\}$$

令 $y=f_i-s_i{c_i}^2$，$k=-s_ic_i$，$x=2(c_j-1)$，$b=f_{j-1}+s_i(c_{j}+1)^2$，可得：

$$y=\max_{j\leq i \wedge s_i=s_j} \{kx+b\}$$

此处 $k$，$x$ 单调递增，维护上凸壳二分查询即可。时间复杂度 $O(n\log n)$。


## Code

之前二分写成了 `r=mid-1` 调了半个多小时，我酸了....

```cpp
#pragma GCC optimize(2,3,"Ofast","unroll-loops")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0,ny;
    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
    in ll read()
    {
        ll x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;Bi=1;if(nc<0)return nc;
        x=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*ny;
    }
    in db gf() {re a=read(),y=ny,b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi)*y:a);}
    in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
    in void flush() {if(C>1<<22) ot();}
    template <typename T>
    in void write(T x,char t)
    {
        re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
    }
    in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=1e5+5,M=1e4+5;
#define q v[a[i]]
#define push push_back
#define pop pop_back
int n,a[N],cnt[M],c[N];
ll f[N];
vector<int>v[N];
in ll sqr(ll x) {return x*x;}
in ll slp(re i,re j,re k) 
{
	ll xi=2*c[i],bi=f[i-1]+a[i]*sqr(c[i]);
	ll xj=2*c[j],bj=f[j-1]+a[j]*sqr(c[j]),xk=2*c[k],bk=f[k-1]+a[k]*sqr(c[k]);
	return ((xi-xj)*(bk-bj)-(bi-bj)*(xk-xj))>0;
}
in ll calc(re i,re x) {return f[x-1]+a[i]*sqr(c[i]-c[x]+1);}
int main()
{
	n=read();
	for(re i=1,l,r,mid,t;i<=n;i++)
	{
		a[i]=read(),c[i]=(++cnt[a[i]])-1;
		while((t=q.size()-1)>0&&slp(i,q[t],q[t-1])) q.pop();q.push(i);
		for(l=0,r=q.size();mid=(l+r)>>1,l+1<r;) (calc(i,q[mid])>calc(i,q[mid-1]))?l=mid:r=mid;
		f[i]=calc(i,q[l]);
	}
	write(f[n],'\n');
	return ot(),0;
}
//Author: disangan233
//In my dream's scene,I can see the everything that in Cyaegha.
```

---

## 作者：LastKismet (赞：1)

# Sol
决策单调性写法。

题意很简单，就是要把序列分成若干块，使每块价值和最大。

考虑一个块的价值，我们容易发现一个性质：一个块可能当且仅当左右两端点同色且块内答案为左右两端点的颜色更新而来，否则这一块一定不优。

于是我们就可以写出转移方程了：
$$
f_i=\max_{col_i=col_j} f_{j-1}+\mathrm{calc}(j,i)
$$

这个方程有一定的简化，但应该不影响阅读。

我们会发现这个 DP 具有决策单调性，对于同一区间，因为同色，易得其决策点单调不增。也就是说，越往后的决策点，只会在前几个点被选择，此后就不优了。

因此我们可以单调栈实现。

值得注意的是，由于存在一个区间只有一个点的情况，我们应当先入栈，再更新 DP 值。

入栈时，对于栈顶二分其最后一个劣于新决策点的位置，倘若完全劣于新决策点即可出栈，否则将新决策点入栈即可。

```cpp
int n;
int a[N];
int cnt[M];
ll sum[N];
ll f[N];
vec<pii> stk[M];int top[M];

inline ll calc(int i,ll t){return (i?f[i-1]:0)+a[i]*t*t;}
inline int find(int c,int x){
    int l=sum[x]-1,r=stk[c][top[c]].sec;
    while(l<r){
        int m=l+r+1>>1;
        if(calc(stk[c][top[c]].fir,m-sum[stk[c][top[c]].fir]+1)>calc(x,m-sum[x]+1))r=m-1;
        else l=m;
    }
    return l;
}
inline void Main(){
    read(n);
    rep(i,1,n)read(a[i]),sum[i]=++cnt[a[i]];
    rep(i,1,1e4)stk[i].resize(cnt[i]+2),stk[i][top[i]=1]={0,n};
    sum[0]=1;
    rep(i,1,n){
        int c=a[i],rt;
        while(stk[c][top[c]].sec<sum[i])--top[c];
        while(top[c]){
            rt=find(c,i);
            if(rt==stk[c][top[c]].sec)--top[c];
            else break;
        }
        if(rt>=sum[i])stk[c][++top[c]]={i,rt};
        f[i]=calc(stk[c][top[c]].fir,sum[i]-sum[stk[c][top[c]].fir]+1);
    }
    put(f[n]);
}
```

---

## 作者：Union_Find (赞：1)

首先我们可以发现这是一个 dp，我们定义 $f_i$ 表示前 $i$ 个数权值之和最大值。我们可以枚举 $j$，就有

$$f_i = \max\{f_{j-1} + val(j,i)\}$$

其中 $val(j,i)$ 表示区间 $[j,i]$ 的权值。我们似乎没有什么好的去表示 $val(j, i)$ 的方法，所以这个式子是 $O(n^3)$ 的，可以倒着枚举 $j$ 做到 $O(n^2)$，这都不是关键，因为我们无法进一步优化。

但是我们可以注意到，我们划分的区间 $[l,r]$ 要满足 $a_l = a_r$，否则我们可以把 $r$ 单独分成一段，权值和会变大。于是我们仍然用上面的转移，但是枚举的 $j$ 必须满足 $a_j=a_i$。

我们对于每个颜色开 `vector` 存位置，同时记录 $num_i$ 表示第 $i$ 个数是第几个出现的 $a_i$。

那么我们就有

$$f_i = \max_{a_j=a_i}\{f_{j-1}+a_i(num_i-num_j+1)^2\}$$

这个式子暴力做是 $O(n^2)$ 的，但是在原数据下可以通过，现在不行了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 100005
il int rd(){
	int s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
int n, a[N], num[N];
ll f[N];
vector <int> pos[N];
signed main(){
	n = rd();
	for (int i = 1; i <= n; i++) a[i] = rd(), num[i] = pos[a[i]].size(), pos[a[i]].push_back(i);
	for (int i = 1; i <= n; i++){
		for (int j = 0; j <= num[i]; j++) f[i] = max(f[i], f[pos[a[i]][j] - 1] + 1ll * a[i] * (num[i] - j + 1) * (num[i] - j + 1));
	}
	printf ("%lld\n", f[n]);
	return 0;
}
```

现在我们考虑优化。先拆开平方的式子，然后分离出与 $j$ 无关的项。

$$f_i = a_i(num_i+1)^2 + \max_{a_j=a_i}\{f_{j-1}+a_inum_j^2-2a_i(num_i+1)num_j\}$$

我们后文为了方便表示，用 $p$ 代表枚举的 $i$，用 $i$ 表示 $a_p$，$j$ 表示 $num_p$，转移的 $j$ 用 $k$ 表示，用 $c_i$ 表示 $num_i$。式子可以写成下面的样子。

$$f_p = i(j+1)^2 + \max_{a_k=i}\{f_{k-1}+ic_k^2-2i(j+1)c_k\}$$

注意到这是一个斜率优化的式子，我们可以套一下公式。

设 $t_1 < t_2 < i$ 且 $a_{t_1} = a_{t_2} = i$，考虑从 $t_2$ 转移优于从 $t_1$ 转移的条件。

$$\begin{equation}\begin{matrix}\begin{aligned}
f_{t_2-1}+ic_{t_2}^2-2i(j+1)c_{t_2} &> f_{t_1-1}+ic_{t_1}^2-2i(j+1)c_{t_1}\\
\frac{(f_{t_2-1}+ic_{t_2}^2)-(f_{t_1-1}+ic_{t_1}^2)}{c_{t_2}-c_{t_1}} &> 2i(j+1)
\end{aligned}\end{matrix}\end{equation}$$

于是我们就有 $X_k = c_k,Y_k = f_{k-1}+ic_k^2,k = 2i(j+1)$。

这题是求最大值，所以维护上凸包。因为斜率递增，所以我们要用单调栈而非单调队列。

注意细节即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define il inline
#define N 100005
il int rd(){
	int s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
int n, a[N], num[N], c[N], f[N];
il int subX(int i, int j){return num[i] - num[j];}
il int subY(int i, int j){return f[i - 1] + a[i] * num[i] * num[i] - f[j - 1] - a[j] * num[j] * num[j];}
il void calc(int i, int j){f[i] = f[j - 1] + a[i] * (num[i] - num[j] + 1) * (num[i] - num[j] + 1);}
struct Stack{
	vector <int> stk;
	il int size(){return stk.size();}
	il void pop(){stk.pop_back();}
	il void push(int x){stk.push_back(x);}
	auto& operator [](const int &x){return stk[size() - x - 1];}
}stk[N];
signed main(){
	n = rd();
	for (int i = 1; i <= n; i++) a[i] = rd(), num[i] = (c[a[i]]++);
	for (int p = 1; p <= n; p++){
		int i = a[p], j = num[p];
		while (stk[i].size() >= 2 && subY(p, stk[i][0]) * subX(stk[i][0], stk[i][1]) >= subY(stk[i][0], stk[i][1]) * subX(p, stk[i][0])) stk[i].pop();
		stk[i].push(p);
		while (stk[i].size() >= 2 && subY(stk[i][0], stk[i][1]) <= 2 * i * (j + 1) * subX(stk[i][0], stk[i][1])) stk[i].pop();
		calc(p, stk[i][0]);
	}
	printf ("%lld\n", f[n]);
	return 0;
}

```

---

## 作者：_xguagua_Firefly_ (赞：0)

观察到没有多少李超树的题解，斜率优化的轮椅为什么不摇呢。

以下大小称为颜色。

### 分析

注意到，我们取颜色，一定是取端点上的颜色，并且两端点的颜色相同。因为如果不取端点上的颜色，那我们就可以缩短区间使得端点变为最后一个那种颜色的位置，而贡献非负，所以不取端点上的颜色一定不优。

同样的，如果两端点颜色不同，那一样可以缩短区间得到更多贡献，所以两端点颜色一定相同。

预处理一个 $sum _ i = \sum \limits _ {j = 1} ^ i [s _ {j} = s _ {i}]$，那么我们就有一个朴素的方程：$dp _ {i} = \max \limits _ {j \le i \wedge s _ {j} = s _ {i}} \{ dp _ {j - 1} + s _ {j}(sum _ {i} - sum _ {j} + 1) ^ {2} \}$

把后面那个式子展开，得到 $dp _ {i} = \max \limits _ {j \le i \wedge s _ {j} = s _ {i}} \{ dp _ {j - 1} + s _ {i} (sum _ {i} ^ {2} + 2 sum _ {i} - 2 sum _ {j} - 2 sum _ {i} sum _ {j} + sum _ {j} ^ {2} + 1)\}$。

这个时候，我们发现，把前面那个 $s _ {i}$ 乘进去之后，会出现同时存在 $-2 s _ {i}sum _ {j}$ 与 $-2 s _ {i} sum _ {i} sum _ {j}$，这样不好处理。但是有个限制条件是 $s _ {i} = s _ {j}$，那我们就可以给不同的项分配不同的值。最后方程就会变为 $dp _ {i} = \max \limits _ {j \le i \wedge s _ {i} = s _ {j}} \{ dp _ {j - 1} + s _ {i} sum _ {i} ^ {2} + 2 s _ {i} sum _ {i} - 2 s _ {j} sum _ {j} - 2 s _ {j} sum _ {i} sum _ {j} + s _ {j} sum _ {j} ^ 2 + s _ {i} \}$，将仅含与 $i$ 有关的项放到外面，这样 $\max$ 里面的内容就是 $kx + b$ 的形式了，其中 $k = -2 s _ {j} sum _ {j},x = sum _ {i},b = -2 s _ {j} sum _ {j} + s _ {j} sum _ {j} ^ {2} + dp _ {j - 1}$。

用李超树来维护这些直线的极值。对于颜色相同的限制，对每一个颜色都开一棵李超树，在计算的时候到对应颜色的树上去查询就行了。因为 $j$ 的范围是 $j \le i$，所以你得先把直线加进李超树再算 DP 值。

### Code

```cpp
#include <bits/extc++.h>
using namespace std;
#define int long long 

constexpr int MAXN = 1e5 + 5,V = 1e5,inf = 0x3f3f3f3f3f3f3f3f;
struct Rukkhadevata
{
    int ls,rs,id;
}tree[MAXN];
#define lson(rt) tree[rt].ls
#define rson(rt) tree[rt].rs
int cnt,root[10005],k[MAXN],b[MAXN];
inline int F(int id,int x)
{return k[id] * x + b[id];}
inline int newNode()
{
    ++cnt;
    lson(cnt) = rson(cnt) = tree[cnt].id = 0;
    return cnt;
}
inline void modify(int &rt,int l,int r,int id)
{
    if(!rt)
    {
        rt = newNode();
        tree[rt].id = id;
        return ;
    }
    if(l == r)
    {
        if(F(id,l) > F(tree[rt].id,l))
            tree[rt].id = id;
        return ;
    }
    int mid = (l + r) >> 1;
    if(F(id,mid) > F(tree[rt].id,mid))
        swap(id,tree[rt].id);
    if(F(id,l) > F(tree[rt].id,l))
        modify(lson(rt),l,mid,id);
    if(F(id,r) > F(tree[rt].id,r))
        modify(rson(rt),mid + 1,r,id);
}
inline int query(int rt,int l,int r,int p)
{
    if(!rt)
        return -inf;
    if(l == r)
        return F(tree[rt].id,p);
    int mid = (l + r) >> 1;
    return max(F(tree[rt].id,p),(p <= mid) ? query(lson(rt),l,mid,p) : query(rson(rt),mid + 1,r,p));
}
int n,s[MAXN],sum[MAXN],dp[MAXN],last[10005];
signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n;
    for(int i = 1;i <= n;i++)
    {
        cin >> s[i];
        sum[i] = sum[last[s[i]]] + 1;
        last[s[i]] = i;
    }
    b[0] = -inf;
    for(int i = 1;i <= n;i++)
    {
        k[i] = -2 * s[i] * sum[i],b[i] = -2 * s[i] * sum[i] + s[i] * sum[i] * sum[i] + dp[i - 1];
        modify(root[s[i]],1,V,i);
        dp[i] = query(root[s[i]],1,V,sum[i]) + s[i] * sum[i] * sum[i] + 2 * s[i] * sum[i] + s[i];
    }
    cout << dp[n];
}
```

---

## 作者：CommandSR (赞：0)

## 题意

[link](https://www.luogu.com.cn/problem/P5504)

## 题解

对于每一个 $i$ 预处理 $sum_i = \sum_{j=1}^{i} [a_i = a_j]$，即前面和它大小相同的柠檬个数。

朴素 dp 方程 $f_i = \max_{j=1}^{i-1} f_{j-1} + a_i \cdot (sum_i-sum_j+1)^2$，且满足 $a_i = a_j$。
$$
f_i = f_{j-1} + a_i \cdot (sum_i+1-sum_j)^2
$$

$$
f_i = f_{j-1} + a_i \cdot ((sum_i+1)^2 + sum_j^2 - 2sum_j(sum_i+1))
$$

$$
f_i = f_{j-1} + a_i \cdot (sum_i+1)^2 + a_j \cdot sum_j^2 - a_i \cdot 2sum_j(sum_i+1)
$$

$$
f_{j-1} + a_jsum_j^2 = f_i -  a_i \cdot (sum_i+1)^2 + 2a_isum_j(sum_i+1)
$$

令 $Y_j = f_{j-1} + a_jsum_j^2$， $X_j = 2a_jsum_j$，$K = sum_i + 1$ 维护上凸壳。

发现要求截距最大值，但是斜率是单调递增的，因此本题要使用单调栈进行斜率优化。

因为要满足 $a_i = a_j$ 的限制，因此要对每一个大小都开一个单调栈分别进行斜率优化。


## Code

```cpp
// Problem: P5504
#include <bits/stdc++.h>  
#define ll long long
#define sz(x) (int)x.size()
#define F(i, a, b) for (int i = (a); i <= (b); ++i)
#define D(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
inline ll rd() {
	ll x = 0; bool f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = 0; ch = getchar(); }
	while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return (f ? x : (-x));
}
const int N = 1e5 + 5;
int n, a[N], sum[N], pre[N];
vector<int> st[N];
ll f[N];
ll dy(int i, int j) { return (f[j-1] + 1ll*a[j]*sum[j]*sum[j]) - (f[i-1] + 1ll*a[i]*sum[i]*sum[i]); }
ll dx(int i, int j) { return 2 * (a[j]*sum[j] - a[i]*sum[i]); }
double slope(int i, int j) { return 1.0 * dy(i,j) / dx(i,j); }

int main() {
	n = rd();
	F(i, 1, n) a[i] = rd(), sum[i] = sum[pre[a[i]]] + 1, pre[a[i]] = i;
	F(i, 1, n) {
		int cur = a[i];
		while (sz(st[cur])>1 && slope(st[cur][sz(st[cur])-2], st[cur][sz(st[cur])-1]) <= slope(st[cur][sz(st[cur])-1], i)) st[cur].pop_back();
		st[cur].push_back(i);
		while (sz(st[cur])>1 && slope(st[cur][sz(st[cur])-2], st[cur][sz(st[cur])-1]) <= sum[i] + 1) st[cur].pop_back(); 
		int j = st[cur].back();
		f[i] = f[j-1] + 1ll*a[i]*(sum[i]-sum[j]+1)*(sum[i]-sum[j]+1);
	}
	cout << f[n];
	return 0;
}
```

---

## 作者：under_the_time (赞：0)

## 题意

> 给定一个长度为 $n$ 的序列 $a$，你需要将其划分成若干个连续的区间。对于区间 $[l,r]$，你先选择一个 $i\in[l,r]$，设 $a_i$ 在 $a[l:r]$ 中的出现次数为 $t$，则区间 $[l,r]$ 的价值就是 $a_it^2$，求最大价值。
>
> $n,a_i\le 10^5$。

## 解法

对于一个区间 $[l,r]$，假设选定了 $i\in[l,r]$ 的 $a_it^2$ 作为价值，那么对于 $j\in[l,r]$ 且 $a_j\ne a_i$ 的 $j$ 在不在这个区间里对这个区间无影响，所以每个区间可以一直缩小，直到出现 $a_l=a_r$ 然后选择 $i=l$ 作为价值。

考虑令 $f(i)$ 表示对 $[1,i]$ 进行划分的最大价值，转移就是
$$
f(i)=\max_{j<i,a_i=a_{j+1}}f(j)+\left(\sum_{k=j+1}^i[a_k=a_i]\right)^2a_i
$$
令 $s_i=\sum_{j=1}^i[a_j=a_i]$，$t_i=\sum_{j=1}^i[a_j=a_{i+1}]$；那么就有
$$
f(i)=\max_{j<i,a_i=a_{j+1}}f(j)+a_i(s_i-t_j)^2=a_is_i^2+\max_{j<i,a_i=a_{j+1}}f(j) + a_{j+1}t_j^2-2a_is_it_j
$$
令 $k_j=-2t_j^2a_{j+1},b_j=f(j)+a_{j+1}t_j^2$，可以发现这相当于查询前面所有满足 $a_{j+1}=a_i$ 的直线 $k_jx+b_j$ 中 $x=s_i$ 处的最大值；并且满足 $a_{j+1}=a_i$ 的所有直线斜率单调下降、询问的 $x$ 单调上升（对于同一个 $a_i$），也就是说我们可以对所有 $a_{j+1}$ 相等的决策点 $j$ 放在一起做斜率优化。时间复杂度 $O(n)$。

:::info[**斜率优化的推导：**]
对于两个决策点 $j_0<j_1$ 和被决策点 $i$，$j_0$ 优于 $j_1$ 当且仅当
$$
\begin{aligned}k_{j_0}s_i+b_{j_0}&>k_{j_1}s_i+b_{j_1}\\ s_i&>\frac{b_{j_1}-b_{j_0}}{k_{j_0}-k_{j_1}}\end{aligned}
$$
当决策点 $i$ 满足 $s_i\ge \frac{b_{j_1}-b_{j_0}}{k_{j_0}-k_{j_1}}$ 时 $j_1$ 劣于 $j_0$。考虑三个决策点 $j_0<j_1<j_2$，如果
$$
\frac{b_{j_2}-b_{j_1}}{k_{j_1}-k_{j_2}}\ge\frac{b_{j_1}-b_{j_0}}{k_{j_0}-k_{j_1}}
$$
即
$$
(b_{j_2}-b_{j_1})(k_{j_0}-k_{j_1})\ge (b_{j_1}-b_{j_0})(k_{j_1}-k_{j_2})
$$
那就说明 $j_1$ 永远不会成为转移点。
:::
## 代码

```cpp
#include <bits/stdc++.h>
bool MemoryST; using namespace std;
#define ll long long
#define mk make_pair
#define open(x) freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout)
#define lowbit(x) ((x) & (-(x)))
#define lson l, mid, rt << 1
#define rson mid + 1, r, rt << 1 | 1
#define BCNT __builtin_popcount
#define cost_time (1e3 * clock() / CLOCKS_PER_SEC) << "ms"
#define cost_space (abs(&MemoryST - &MemoryED) / 1024.0 / 1024.0) << "MB"
const int inf = 0x3f3f3f3f; 
const ll linf = 1e18; 
mt19937 rnd(random_device{}());
template<typename T> void chkmax(T& x, T y) { x = max(x, y); }
template<typename T> void chkmin(T& x, T y) { x = min(x, y); }
template<typename T> T abs(T x) { return (x < 0) ? -x : x; }
const int maxn = 1e5 + 5, maxm = 1e4 + 5;
int n, a[maxn], s[maxn], t[maxn], cnt[maxn];
vector<int> st[maxm]; ll f[maxn], K[maxn], B[maxn];
bool check(int j0, int j1, int j2) {
    return (B[j2] - B[j1]) * (K[j0] - K[j1]) >= (B[j1] - B[j0]) * (K[j1] - K[j2]);
}
bool MemoryED; int main() {
    scanf("%d", &n); ll ans = -linf;
    for (int i = 1; i <= n; i ++) {
        scanf("%d", &a[i]);
        s[i] = cnt[a[i]] + 1, t[i - 1] = cnt[a[i]];
        cnt[a[i]] ++;
    } 
    // for (int i = 0; i <= n; i ++)
    //     cout << i << ' ' << s[i] << ' ' << t[i] << '\n';
    for (int i = 1; i <= n; i ++) {
        int pos = a[i]; K[i - 1] = -(2ll * t[i - 1] * a[i]), B[i - 1] = f[i - 1] + 1ll * t[i - 1] * t[i - 1] * a[i];
        while ((int)st[pos].size() > 1) {
            int j0 = st[pos][(int)st[pos].size() - 2], j1 = st[pos][(int)st[pos].size() - 1];
            if (check(j0, j1, i - 1)) st[pos].pop_back();
            else break;
        } st[pos].push_back(i - 1);
        while ((int)st[pos].size() > 1) {
            int j0 = st[pos][(int)st[pos].size() - 2], j1 = st[pos][(int)st[pos].size() - 1];
            if (K[j0] * s[i] + B[j0] >= K[j1] * s[i] + B[j1]) st[pos].pop_back();
            else break;
        } chkmax(ans, f[i] = 1ll * s[i] * s[i] * a[i] + K[st[pos].back()] * s[i] + B[st[pos].back()]);
        // cout << i << ' ' << st[pos].back() << '\n';
    } printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Iris_Aurora (赞：0)

我们令 $dp_i$ 表示前 $i$ 个贝壳可以变出柠檬数量的最大值。

然后我们可以列出转移方程：

$$dp_i=\max\{dp_{j-1}+val(i,j)\}$$。

$val(i,j)$ 表示 $[i,j]$ 段变出柠檬数量的最大值。

然后我们发现 $dp_i$ 是单调不减的，那么一个转移是有意义的当且仅当 $a_i=a_j$，于是进一步简化转移方程：

$$dp_i=\max_{\begin{subarray}{l}
   a_i=a_j=k\\
   1\le j\le i
\end{subarray}}\{dp_{j-1}+k\times [s_{i,k}-(s_{j,k}-1)]^2\}$$。

然后我们开始推式子：

$$
dp_i=dp_{j-1}+k\times (s_{i,k})^2+k\times (s_{j,k}-1)^2-2\times k\times s_{i,k}\times (s_{j,k}-1)\\
dp_i-k\times (s_{i,k})^2=-2\times k\times (s_{j,k}-1) \times s_{i,k}+(dp_{j-1}+k\times (s_{j,k}-1)^2)
$$

然后这个式子就变成了一个经典斜率优化形式 $b_i=y_j-k_ix_j$：

$$
\begin{cases}
   b_i = dp_i-k\times (s_{i,k})^2\\
   y_j = dp_{j-1}+k\times (s_{j,k}-1)^2\\
   k_i =  2s_{i,k}\\
   x_j = k\times (s_{j,k}-1)\\
\end{cases}
$$
~~完结撒花。~~

----
呃呃偏题了，因为今天学了李超线段树，所以我们尝试用李超线段树维护。

这个式子的右边可以变成 $k_jx_i+b_j$ 的形式：

$$
\begin{cases}
   b_j = dp_{j-1}+k\times (s_{j,k}-1)^2\\
   k_j = -2\times k\times (s_{j,k}-1)\\
   x_i = s_{i,k}\\
\end{cases}
$$

然后就可以维护了，即求 $dp_i=\max\{k_jx_i+b_j\}+k\times (s_{i,k})^2$。

附上代码：

```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const int MAXN = 1e5 + 10;
const int MAXM = 1e4 + 10;
const ll inf = 0x3f3f3f3f3f3f3f3f;
int n;
int a[MAXN],cnt[MAXM];
int rt[MAXM];
ll f[MAXN];
struct Line{
	ll k,b;
	ll Get(int x){
		return (ll)(k*x+b); 
	}
}e[MAXN];
struct Lichao_Segment_Tree{
	#define ls t[x].Ls
	#define rs t[x].Rs
	int tot=0;
	struct node{
		int l,r;
		int id;
		int Ls,Rs;
	}t[MAXN<<4];
	void build(int &x,int l,int r){
		x=++tot;
		t[x].l=l,t[x].r=r,t[x].id=t[x].Ls=t[x].Rs=0;
		if(l==r) return ;
		int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
	}
	void update(int x,int k){
		if(!t[x].id){
			t[x].id=k;
			return ;
		}
		int mid=(t[x].l+t[x].r)>>1;
		if(e[k].Get(mid)>e[t[x].id].Get(mid)) swap(t[x].id,k);
		if(e[k].Get(t[x].l)>e[t[x].id].Get(t[x].l)) update(ls,k);
		if(e[k].Get(t[x].r)>e[t[x].id].Get(t[x].r)) update(rs,k);
	}
	ll query(int x,int p){
		if(!t[x].id) return 0;
		ll res=e[t[x].id].Get(p);
		if(t[x].l==t[x].r) return res;
		int mid=(t[x].l+t[x].r)>>1;
		if(p<=mid) res=max(res,query(ls,p));
		else res=max(res,query(rs,p));
		return res;
	}
}T;
int main(){
	scanf("%d",&n);
	FL(i,1,n) scanf("%d",&a[i]),cnt[a[i]]++;
	FL(i,1,10000)
		if(cnt[i]) T.build(rt[i],1,cnt[i]);
	memset(cnt,0,sizeof(cnt));
	FL(i,1,n){
		cnt[a[i]]++;
		e[i].k=-2ll*a[i]*(cnt[a[i]]-1);
		e[i].b=f[i-1]+1ll*a[i]*(cnt[a[i]]-1)*(cnt[a[i]]-1);
		T.update(rt[a[i]],i);
		f[i]=T.query(rt[a[i]],cnt[a[i]])+1ll*a[i]*cnt[a[i]]*cnt[a[i]];
	}
	printf("%lld\n",f[n]);
}
```

---

## 作者：lzdll (赞：0)

首先我们注意到一个性质，就是的每一段选择的颜色一定会在段的首和尾都出现。

其实很好证明，如果我们选择的颜色 $s_0$ 没有出现在这一段的首或尾，那么我们可以把这一段的开头没出现 $s_0$ 的部分割下来给前面的段，结尾没出现 $s_0$ 的部分割下来给后面的段，这样这一段的答案不会减少。前后段的答案还有可能增大。

所以我们维护一个 $sum_i$，表示从 $1$ 到 $i$ 中 $s_i$ 这种颜色的出现次数。然后我们可以得到下面的公式。

$$dp_i=\max_{1\le j\le i,s_j=s_i} \{f_{j-1}+(sum_i-sum_j+1)^2\}$$

接下来我们就可以写出暴力代码了。

```cpp
R(n);
for(int i=1;i<=n;++i){
	R(s[i]);
	sum[i]=sum[lst[s[i]]]+1;
	lst[s[i]]=i;
}
for(int i=1;i<=n;++i){
	for(int j=1;j<=i;++j){
		if(s[i]==s[j]){
			dp[i]=max(dp[i],dp[j-1]+s[i]*(sum[i]-sum[j]+1)*(sum[i]-sum[j]+1));
		}
	}
}
cout<<dp[n];
```
这样做复杂度为 $\Theta(n^2)$，我们考虑使用斜率优化。不会斜率优化的也可以看[我的博客](https://www.luogu.me/article/keovo605)。

首先我们把式子拆开，假设 $i$ 要从 $j$ 转移。

这里注意 $s_i$ 和 $s_j$ 是相等的。

$$dp_i-s_i(sum_i+1)^2+2s_isum_isum_j=dp_{j-1}+s_jsum_j(sum_j-2)$$

然后这就可以看做是一条直线，其中 $y=dp_{j-1}+s_jsum_j(sum_j-2)$，$x=sum_j$，$k=2s_isum_i$，$b=dp_i-s_i(sum_i+1)^2$。

每一个 $j$ 都可以变成一个点 $(sum_j,dp_{j-1}+s_jsum_j(sum_j-2))$，然后尝试让这条直线过每一个点，截距最大时，$dp_i$ 取最大值。

这道题让我们求最大值，我们需要维护一个上凸壳，简单画一下图就可以知道上凸壳下面的点永远不会用到。

![](https://cdn.luogu.com.cn/upload/image_hosting/dj8qedui.png)

黄、绿、紫三种颜色的线分别代表以图中两条浅蓝色线的斜率为分界，不同范围内的斜率。

可以发现下面的红色点都不会成为最优决策点。

我们通常斜率优化是使用单调队列，因为要去除前面不优的点。但这道题使用上凸壳，所以我们需要找到从后往前第一个斜率比询问斜率大的，然后因为斜率单增，后面的线就用不到了。所以使用单调栈即可。

代码如下。

```cpp
#define R(x) x=read()
#define int long long
const int N=100005,M=10005;
int n,s,sum[N],lst[M],dp[N];
vector<int>st[M];
int Y(int i){
	return dp[i-1]-2*s*sum[i]+s*sum[i]*sum[i];
}
double slope(int i,int j){
	return 1.0*(Y(i)-Y(j))/(sum[i]-sum[j]);
}
#define top st[s].size()-1
signed main() {
	R(n);
	for(int i=1;i<=n;++i){
		R(s);
		sum[i]=sum[lst[s]]+1;
		lst[s]=i;
		dp[i]=dp[i-1]+s;
		if(sum[i]==1){
			st[s].push_back(i);
			continue;
		}
		while(st[s].size()>=2&&slope(st[s][top],st[s][top-1])<=2*s*sum[i])st[s].pop_back();
		dp[i]=max(dp[i],dp[st[s][top]-1]+s*(sum[i]-sum[st[s][top]]+1)*(sum[i]-sum[st[s][top]]+1));
		while(st[s].size()>=2&&slope(st[s][top],st[s][top-1])<=slope(st[s][top],i))st[s].pop_back();
		st[s].push_back(i);
	}
	cout<<dp[n]<<"\n";
	return 0;
}
```

---

## 作者：zifanwang (赞：0)

首先容易想到记 $f_i$ 表示前 $i$ 个位置能得到的最大价值，枚举以 $i$ 结尾的段直接 dp。

发现最后一个段选的颜色必定为 $s_i$，不然可以令 $[i,i]$ 为单独一段。且以 $i$ 结尾的段开头颜色也一定是 $s_i$。记 $c_i$ 表示 $[1,i]$ 中与 $i$ 颜色相同的位置个数，有：

$$
f_i=\max_{1\le j\le i\land s_j=s_i} f_{j-1}+s_i(c_i-c_j+1)^2
$$

然后就是斜率优化板子题，时间复杂度 $\mathcal O(n)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 100003
#define pb push_back
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;
int n,a[mxn],p[mxn],c[10003];
ll f[mxn],g[mxn];
vector<int>q[10003];
inline ll get(int x,int y){
	return g[x]+((ll)p[y]*p[y]-2ll*(p[x]-1)*p[y])*a[x];
}
signed main(){
	scanf("%d",&n);
	rep(i,1,n)scanf("%d",&a[i]),p[i]=++c[a[i]];
	rep(i,1,n){
		g[i]=f[i-1]+(p[i]-1)*(p[i]-1ll)*a[i];
		while(q[a[i]].size()>1&&(g[q[a[i]][q[a[i]].size()-1]]-g[q[a[i]][q[a[i]].size()-2]])*(p[i]-p[q[a[i]][q[a[i]].size()-1]])<=
								(g[i]-g[q[a[i]][q[a[i]].size()-1]])*(p[q[a[i]][q[a[i]].size()-1]]-p[q[a[i]][q[a[i]].size()-2]]))q[a[i]].pop_back();
		q[a[i]].pb(i);
		while(q[a[i]].size()>1&&get(q[a[i]][q[a[i]].size()-1],i)<=get(q[a[i]][q[a[i]].size()-2],i))q[a[i]].pop_back();
		f[i]=get(q[a[i]].back(),i);
	}
	cout<<f[n];
	return 0;
}
```

---


# 篮球统计

## 题目背景

小L喜欢唱、跳、Rap和篮球。

在同一时刻，篮球场上可能会有很多个在空中的篮球，小L想统计这些篮球的信息。

## 题目描述

当一个篮球被抛到空中时，小L会记下一个时刻 $l$ ，此时这个篮球开始被小L统计；当一个篮球被接住时，小L会记下一个时刻 $r$ ，在这之后这个篮球的状态不再被小L统计。对于每个篮球，小L会计算出在时刻 $l$ 这个篮球的高度和向上的初速度。

对于一个时刻 $x$ ，小L想知道，对于所有此时还在空中的篮球，高度最高的篮球的高度是多少。

**注意** ：被发现的篮球的出现时间 $l,r$ 和小L统计信息的时刻 $x$ 均没有任何单调性。

## 说明/提示

对于 $30\%$ 的数据， $m\le 5000$

对于另外 $30\%$ 的数据， $-100< l,r,x< 100$

对于 $100\%$ 的数据， $1\le m\le 100000,-1000< a,v < 1000,-10^6< l,r,x < 10^6,l\le r$ ，保证输入中所有的小数均为 $3$ 位小数。

篮球高度可能是负数。

### 小K教你学物理

本题中所有的单位均采用国际单位制。即时间单位是秒（ $s$ ），长度单位是米（ $m$ ）。

本题中取重力加速度 $g=9.8 ~ m \cdot s^{-2}$ 。

省略掉篮球横向的位移，可以将篮球的运动看做是 **竖直上抛运动** 。根据题目中给出的信息，已知篮球初始的高度 $a$ ，初速度 $v$ ，重力加速度 $g$ ， **在空中的时间**  $t$ ，则篮球在这一时刻的高度是 $-\dfrac 1 2 g t^2 + vt+a$ 。

## 样例 #1

### 输入

```
5
query 1.000
add 1.000 5.000 1.000 2.000
query 1.000
query 2.000
query 1.500```

### 输出

```
Undefined
1.000000
1.100000
2.275000```

# 题解

## 作者：hsfzLZH1 (赞：5)

出题人： [hsfzLZH1](https://www.luogu.org/space/show?uid=43486)

本题主要考察模型转化和线段树。

## 题目大意

$m$ 次操作，每次操作为以下两种之一：

1.  `add a v l r` ，告诉你有一个篮球，在时间段 $[l,r]$ 时在空中，时刻 $l$ 时的高度为 $a$ ，初始向上速度为 $v$ 。篮球的高度 $h$ 随在空中的时长 $t$ 的变化为 $h=-\dfrac 1 2 gt^2+vt+a$ 。

2. `query x` ，询问在时刻 $x$ ，所有已知的在空中的篮球中，最高的一个的高度是多少。 如果此时不存在在空中的篮球，输出 `Undefined` 。

## 30pts

记录已知的所有篮球的 $a,v,l,r$ ，对一个时刻进行查询时，判断每个球是否在空中，如果是，计算这个球此时的高度，并取最大值即可。时间复杂度 $O(m^2)$ 。

## 60pts

将时间轴当做横坐标，篮球的高度当做纵坐标。

篮球的高度 $h$ 与时刻 $x$ 的关系式： $h=-\dfrac 1 2 g(x-l)^2+v(x-l)+a$

$h=-\dfrac 1 2 gx^2+(v+gl)x-\dfrac 1 2 gl^2-vl+a$

每次询问，给定 $x$ ，而 $a,v,l,r$ 的取值会随着线段的不同而不同，此时 $-\dfrac 1 2 gx^2$ 为定值。对每个篮球，令 $k=v+gl,b=-\dfrac 1 2 gl^2-vl+a$ ，你需要求出满足 $l\le x\le r$ 时最大的 $kx+b$ 。

由此，问题转化为两种操作：

1. 在平面上插入一条线段。

2. 求所有与 $x=c$ 相交的线段中交点 $y$ 坐标最大的一个。

这就是 [**李超线段树**](https://blog.csdn.net/flere825/article/details/76283734) 的模板题了。由于题目中有小数，可以将所有时间乘以 $1000$ 后转化为整数。令 $n=1000\times x$ ，时间复杂度 $O(n\log_2^2 n)$ ，空间复杂度 $O(n)$ 。

## 100pts

注意到 $n$ 的值可能很大，此时可以用 **询问离线+离散化** 或 **动态开点** 的方法减小 $n$ 的值。

## 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#define double long double
using namespace std;
const int maxn=100010;
const int inf=1e9+1;
const int ddd=20000010;
const double g=9.8;
int m,cur;
char op[10];
double a,v,x,l,r;
struct seg
{
	double a,b;
	double f(double x){return x*a+b;}
}s[maxn];
int rt,cnt,lc[ddd],rc[ddd],id[ddd];
void update(int&o,int l,int r,int ql,int qr,int v)
{
	if(r<ql||l>qr)return;
	if(!o)o=++cnt;
	if(ql<=l&&r<=qr)
	{
		if(!id[o])id[o]=v;
		else
		{
			if(s[v].f(l/1000.0)>=s[id[o]].f(l/1000.0)&&s[v].f(r/1000.0)>=s[id[o]].f(r/1000.0)){id[o]=v;return;}
			if(s[v].f(l/1000.0)<=s[id[o]].f(l/1000.0)&&s[v].f(r/1000.0)<=s[id[o]].f(r/1000.0))return;
			if(l==r)return; 
			int mid=(l+r)>>1;
			if(s[v].f(l/1000.0)>=s[id[o]].f(l/1000.0))
			{
				if(s[v].f(mid/1000.0)>=s[id[o]].f(mid/1000.0))update(rc[o],mid+1,r,ql,qr,id[o]),id[o]=v;
				else update(lc[o],l,mid,ql,qr,v);
			}
			else
			{
				if(s[v].f(mid/1000.0)<=s[id[o]].f(mid/1000.0))update(rc[o],mid+1,r,ql,qr,v);
				else update(lc[o],l,mid,ql,qr,id[o]),id[o]=v;
			}
		}
		return;
	}
	int mid=(l+r)>>1;
	update(lc[o],l,mid,ql,qr,v);
	update(rc[o],mid+1,r,ql,qr,v);
}
int query(int o,int l,int r,int x)
{
	if(!o)return 0;
	if(l==r)return id[o];
	int mid=(l+r)>>1,ans;
	if(x<=mid)ans=query(lc[o],l,mid,x);
	else ans=query(rc[o],mid+1,r,x);
	if(!id[o])return ans;
	if(!ans)return id[o];
	if(s[id[o]].f(x/1000.0)>=s[ans].f(x/1000.0))return id[o];
	return ans;
}
main()
{
	scanf("%d",&m);
	while(m--)
	{
		scanf("%s",op);
		if(op[0]=='a')
		{
			cur++;
			scanf("%Lf%Lf%Lf%Lf",&a,&v,&l,&r);
			s[cur].a=v+g*l;s[cur].b=a-g/2*l*l-v*l;
			update(rt,-inf,inf,(int)(l*1000.0),(int)(r*1000.0),cur);
		}
		else
		{
			scanf("%Lf",&x);
			int t=query(rt,-inf,inf,(int)(x*1000.0));
			if(!t)printf("Undefined\n");
			else printf("%Lf\n",-g/2*x*x+s[t].a*x+s[t].b);
		}
	}
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

卡精度差评。

对于一个篮球 $(l,r,v,a)$，他在 $t$ 时刻的高度为：

$$
\begin{aligned}
& -\dfrac{1}{2}g(t-l)^2 + v(t-l)+a \\
=& \color{red}{-\dfrac{1}{2}gt^2} + \color{blue}{(v + gl)t}+\color{orange}{a-vl-\dfrac{1}{2}gl^2}
\end{aligned}
$$

红色只和 $t$ 有关，蓝色和黄色看成一个一次函数 $f(x)=(v+gl)x + a-vl-\dfrac{1}{2}gl^2$。

使用动态开点李超树维护即可。

我想把 $1000t$ 当做坐标，这样就全是整数非常容易处理。

但是貌似会有误差。得手动修正。

```cpp
#include<bits/stdc++.h>
#define ld long double
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100000+10,C=100+5;
const ld INF=1e18;
int m,rt,vis[MAXN*C],tot;
struct Segment {ld k,b;ld f(ld x) {return k*(1.0*x/1000)+b;}};
struct Node {int lson,rson;Segment s;}t[MAXN*C];
#define mid (l+(r-l)/2)
void update(int& u,int l,int r,int x,int y,Segment s) {
	if(!u) u=++tot;
	if(x<=l&&r<=y) {
		if(vis[u]==0) return vis[u]=1,t[u].s=s,void();
		if(t[u].s.f(mid)<s.f(mid)) swap(s,t[u].s);
		if(l!=r) {
			if(t[u].s.k<=s.k) update(t[u].rson,mid+1,r,x,y,s);
			else update(t[u].lson,l,mid,x,y,s);	
		}
		return ;
	}
	if(x<=mid) update(t[u].lson,l,mid,x,y,s);
	if(y>mid) update(t[u].rson,mid+1,r,x,y,s);
	return ;
}
ld query(int u,int l,int r,int x) {
	if(!u) return -INF;
	ld ans=-INF;
	if(vis[u]) ans=t[u].s.f(x);
	if(x<=mid) ans=max(ans,query(t[u].lson,l,mid,x));
	else ans=max(ans,query(t[u].rson,mid+1,r,x));
	return ans;
}
int trans(long double x) {
	x*=1000;
	int v=floor(x),vv=ceil(x);
	if(x-v<vv-x) return v;
	return vv;	
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>m;
	ffor(i,1,m) {
		string S;
		cin>>S;
		if(S=="query") {
			ld x;
			cin>>x;
			ld ans=query(rt,-1000000000,1000000000,trans(x));
			if(ans<=-INF+1e-10) cout<<"Undefined\n";
			else cout<<fixed<<setprecision(10)<<ans-4.9*x*x<<'\n';
		}
		else {
			ld l,r,v,a;
			cin>>a>>v>>l>>r;
			update(rt,-1000000000,1000000000,trans(l),trans(r),{v+9.8*l,-4.9*l*l-v*l+a});
		}
	}
	return 0;
}
/*
-1/2g(x-l)^2+v(x-l)+a
-0.5g(x^2-2lx+l^2)+vx-vl+a
-4.9(x^2-2lx+l^2)+vx-vl+a
-4.9x^2+(v+9.8l)x-4.9l^2-vl+a
*/
```

---

## 作者：Little_Cancel_Sunny (赞：2)

# 题解：P5554 篮球统计

## 题意

$m$ 次操作：

1. 插入一个函数 `add a v l r` 即记录了 $l$ 到 $r$ 时间段的球的高度，且初始高度为 $a$，速度为 $v$，由公式得其在 $t$ 秒时高度 $h$ 为 $h = -\dfrac 1 2 g (t-l)^2 + (t-l)v + a$ 其中 $g=9.8$。

2. 询问 `query x` 即当 $t=x$ 时 $h$ 最大的是多少，若没有则输出 `Undefined`。

## 考点

1. 将二次函数转化为一次函数维护。

2. 李超线段树。

~~既然都用李超树了卡精度少不了。~~

## 思路

1. 对于 $h = -\dfrac 1 2 g (t-l)^2 + (t-l)v + a$ 我们显然无法直接维护，因为它是一个二次函数，所以我们考虑化简，首先拆开二次项 $h = -\dfrac 1 2 g t^2 + glt -\dfrac 1 2 gl^2 + vt - vl + a$，然后合并同类项 $h = -\dfrac 1 2 g t^2 + (v+gl)t -(\dfrac 1 2 gl+v)l + a$。

2. 可以发现 $h=-\dfrac 1 2 g t^2 + (v+gl)t -(\dfrac 1 2 gl+v)l + a$ 中，$-\dfrac 1 2 gt^2$ 是一个定值，所以我们最后处理，而对于 $(v+gl)t - (\dfrac 1 2 gl+v)l + a$，就变成了一个一次函数，符合 $y=kx + b$ 的形式，考虑使用李超线段树维护。

## 注意事项与技巧

1. 注意使用动态开点，本题会卡。

2. 注意每次比较写成 $x - y > eps$ 保证精度，long double 也别忘了。

3. 小技巧：每次插入与查询时将 $l$ 和 $r$ 乘上 $10^3$ (~~记得开 long long~~) 可以保证查询时都是整数坐标，但是最后求 $h$ 不要忘了除 $10^3$。

## Code

~~有一定注释提示。~~


```cpp
#include<bits/stdc++.h>
#define double long double
#define int long long
using namespace std;

const int N=1e6+15;
const int inf=1e9+15; 
const double g=9.8;
const double eps=1e-9,O=1000.0;

struct lc_segment_tree
{
	int lc,rc;
	int id;
}tr[4*N];
int cnt=0;

struct node 
{
	double k,b;
	double get_y(double x)
	{
		return 1.0*k*x+1.0*b;
	}
}line[N];
int sum=0;

int n,rt;

void update(int &k,int l,int r,int ln,int rn,int loc)
//记得rt要寻址不然就改不到值
{
	if(!k)//动态开点
	{
		k=++cnt;
	}
	int mid=(l+r)>>1;
	//李超线段树常规操作
	if(l>=ln&&r<=rn)
	{
		if(!tr[k].id)
		{
			tr[k].id=loc;
			return;
		}
		if(line[loc].get_y(mid/O)-line[tr[k].id].get_y(mid/O)>eps)
		{
			swap(tr[k].id,loc);
		}
		if(line[loc].get_y(l/O)-line[tr[k].id].get_y(l/O)>eps)
		{
			update(tr[k].lc,l,mid,ln,rn,loc);
		}
		if(line[loc].get_y(r/O)-line[tr[k].id].get_y(r/O)>eps)
		{
			update(tr[k].rc,mid+1,r,ln,rn,loc);
		}
	}
	else
	{
		if(rn<=mid)
		{
			update(tr[k].lc,l,mid,ln,rn,loc);
		}
		else
		{
			if(ln>mid)
			{
				update(tr[k].rc,mid+1,r,ln,rn,loc);
			}
			else
			{
				update(tr[k].lc,l,mid,ln,rn,loc);
				update(tr[k].rc,mid+1,r,ln,rn,loc);
			}
		}
	}
}

int query(int k,int l,int r,int point)
{
	if(!k)//动态开点
	{
		return 0;
	}
	if(l==r)
	{
		return tr[k].id;
	}
	double res=line[tr[k].id].get_y(point/O);
	int ans=tr[k].id;
	int mid=(l+r)>>1;
	int ans1;
	if(point<=mid)
	{
		ans1=query(tr[k].lc,l,mid,point);
	}
	else
	{
		ans1=query(tr[k].rc,mid+1,r,point);
	}
	//注意万一出现负数，有可能当y=0时会比当前答案大，所以注意判断一下
	if(!ans1)
	{
		return ans;
	}
	if(!ans)
	{
		return ans1;
	}
	if(line[ans1].get_y(point/O)-res>eps)
	{
		ans=ans1;
	}
	return ans;
}

signed main()
{
	cin>>n;
	while(n--)
	{
		string opt;
		cin>>opt;
		if(opt=="add")
		{
			double a,v,l,r;
			
			cin>>a>>v>>l>>r;
			line[++sum]=(node){1.0*(v+g*l),1.0*a-(1.0*g/2*l+v)*l};
			update(rt,-inf,inf,(int)(l*O),(int)(r*O),sum);
			//坐标*1000 不然会不断向下查询
		}
		else
		{
			double tim;
			cin>>tim;
			int loc=query(rt,-inf,inf,(int)(tim*O));
			//其实返回线段编号与y值都可以，看个人喜好
			if(!loc)
			{
				cout<<"Undefined"<<endl;
			}
			else
			{
				double tmp1=-g/2*tim*tim*(double)1.0;
				double tmp2=(double)1.0*line[loc].k*tim;
				double tmp3=(double)1.0*line[loc].b;
				printf("%.10Lf\n",((double)(tmp1+tmp2+tmp3)));
//				cout<<(-g/2*tim*tim+line[loc].k*tim+line[loc].b)<<endl;
			}
		}
	}
	return 0;
}
```

---


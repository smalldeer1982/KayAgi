# 数码排序【加强版】

## 题目背景

**本题是[P5626](https://www.luogu.org/problem/P5626)的加强版**

小L从虚拟世界里出来啦！

## 题目描述

逃出来的同时，也有一部分数码逃了出来，吵着闹着让小L帮他们排序。

虚拟世界的数码都是不可见的。

小L目前只会选择排序，插入排序，冒泡排序，归并排序。

所以小L想问他在最坏情况下最少需要几次比较，才能使序列有序。

------

[排序的模板代码](https://www.luogu.org/paste/fdtepscp)

## 说明/提示

- **样例$1$解释**

长度为$4$的序列归并调用，分成$2$组，一组$2$个元素。$2$个元素分别比较一次， 合并时最坏比较$3$次，所以是$3+1+1=5。$

- **数据范围**

对于 $10\%$ 的数据，$n\leq10^{18}$；

对于 $20\%$ 的数据，$n\leq10^{100}$；

对于 $50\%$ 的数据，$n\leq10^{1000}$；

对于 $80\%$ 的数据，$n\leq10^{10000}$；

对于 $100\%$ 的数据，$n\leq10^{100000}$。

**请注意时限**

## 样例 #1

### 输入

```
4```

### 输出

```
5```

## 样例 #2

### 输入

```
5```

### 输出

```
8```

# 题解

## 作者：Pisces (赞：19)

[题面在此](https://www.luogu.org/problem/P5634)

$\Large\text{大波公式警告}$

为了方便，以下我用$\lg$来代替$\log_2$

我们容易得出$ans=F(n)=F(\lfloor n/2\rfloor )+F(\lceil n/2\rceil )+n-1(n>1)$，我们令$g(n)=g(\lfloor n/2\rfloor )+g(\lceil n/2\rceil )+a(n)(n>1)$，则有$\Delta g(n)=\Delta a(n)+\Delta g(\lfloor n/2\rfloor)$

我们有恒等式$\lceil \lg2j\rceil=\lceil \lg j\rceil+1$和$\lceil \lg(2j-1)\rceil=\lceil \lg j\rceil+[j>1](j\geq1)$，所以当$a(n)=n-1$时，$\lceil \lg(n+1)\rceil$满足$\Delta f(n)=1+\Delta f(\lfloor n/2\rfloor)$

所以有结论若$F(1)=0,F(n)=F(\lfloor n/2\rfloor )+F(\lceil n/2\rceil )+n-1(n>1)$，$F(n)=\sum\limits_{k=1}^{n}\lceil \lg k\rceil$，我们就可以暴力求$F(n)$，但此时暴力仍然是$O(n)$的，因为其中有一些连续相等的数，可以考虑数论分块，复杂度大概是$O(\lg n)$的，预计得分$10\sim20pts$

令$m=\lceil \lg n\rceil$，我们考虑增加$2^m-n$项以简化运算：

$F(n)+(2^m-n)m=\sum\limits_{k=1}^{2^m}\lceil \lg k\rceil=\sum\limits_{j,k}j[j=\lceil \lg k\rceil][1\leq k\leq 2^m]=\sum\limits_{j,k}j[2^{j-1}\lt k\leq 2^j][1\leq j\leq m]=\sum\limits_{j=1}^{m}j2^{j-1}=2^m(m-1)+1$

所以我们得到$F(n)=nm-2^m+1$

但是还有一个问题：如何求$\lceil \lg n\rceil$，由于$n$太大，只能使用高精度，考虑暴力求$2^k$，暴力找到$m$，暴力取模，复杂度仍为$O(\lg n)$，预计得分仍然为$10\sim20pts$

我们有换底公式$\lg n=\log_{10}n/\log_{10}2=\log_{10}n*(1/\log_{10}2),\log_{10}n$可以用数位个数估算（偏小），$1/\log_{10}2$取估算值$3.32192809488736218170856773213$，此时就可以求得估算值$l$，考虑预处理出$2^{2^l}$，再把$l$用二进制法表示即可快速求出$2^l$，再用暴力即可（此时暴力最多算$4$次，因为$2^4\gt10$），复杂度$O(\lg \lg n)$，预计得分$100pts$，但是此题数据范围达到$10^{100000}$，必须用$FFT$优化，否则得分只能是$50\sim80pts$

（当然高精度快速幂是一样的）

但其实这道题还有个比较巧妙的理解方法：

先求式子:$f(n)=f(\lfloor n/2\rfloor )+f(\lceil n/2\rceil )+n(n>1)$，$\lfloor n/2\rfloor,\lceil n/2\rceil$取遍了$n$，如果每次加$n$，就相当于**每层**递归都是加$n$，一共递归了$\lceil \lg n\rceil$**层**，且一共递归了$n-1$**次**，答案就是$f(n)-(n-1)$，所以我们还是得到$F(n)=nm-2^m+1$

$Code:(part)$
```cpp
int main()
{
    scanf("%s",ch);n=ch;
    int l=db*(strlen(ch)-1),ll=l;//db=3.32192809488736218170856773213
    for(register int i=1;i<=l;i<<=1,++tot)
        b[tot+1]=b[tot]*b[tot];//预处理
    while(l){
        if(l&1) s=s*b[t];//二进制分解算
        ++t,l>>=1;
    }
    while(1){//暴力算
        s+=s,++ll;
        if(s>=n) break;
    }
    T=(n%mod*ll+mod-qpow(2,ll)+1)%mod;
    T.print();
    return 0;
}
```

---

## 作者：Kreado (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5634)。

首先你需要知道递推式，详见这一篇题解 [this](https://www.luogu.com.cn/blog/zqh158233/solution-p5626)。

由此得知

$$S_n=np-2^p+1$$

$p=\log_2n$。

因为要对 `100000007` 取模，所以我们可以只算 $p$，有换底公式，从而算到它的估值 $p=\log_{10}(n)\times \log_2(10)$，继续暴力算误差部分即可。

接下来按式子取模即可。

当然，如果没有取模呢，数字可能很大，需要 FFT 优化到 $O(n\log n)$，[如果您不知道什么是 FFT](https://www.luogu.com.cn/problem/P1919)。

下面给出不取模的代码。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const double PI=acos(-1),dbos=3.32192809488736218170856773213;
string S;
const ll Maxn=2e5+7,Mod=100000007;
ll len,Lim=1,Alen,Blen,rev[Maxn],ans[Maxn];
struct Complex{
	double r,i;
	Complex(){r=0,i=0;}
	Complex(double real,double imag):r(real),i(imag){}
}A[Maxn],B[Maxn];
inline Complex operator +(Complex A,Complex B){return Complex(A.r+B.r,A.i+B.i);}
inline Complex operator -(Complex A,Complex B){return Complex(A.r-B.r,A.i-B.i);}
inline Complex operator *(Complex A,Complex B){return Complex(A.r*B.r-A.i*B.i,A.r*B.i+A.i*B.r);}
inline void FFT(Complex *a,double flag){
	for(ll i=0;i<Lim;++i) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(ll dep=1;dep<=log2(Lim);++dep){
		ll m=1<<dep;
		Complex wn=Complex(cos(2.0*PI/m),flag*sin(2.0*PI/m));
		for(ll i=0;i<Lim;i+=m){
			Complex w=Complex(1,0);
			for(ll j=0;j<m/2;j++){
				Complex t=w*a[i+j+m/2];
				Complex u=a[i+j];
				a[i+j]=u+t;
				a[i+j+m/2]=u-t;
				w=w*wn;
			}
		}
	}
	if(flag==-1) for(ll i=0;i<Lim;++i) a[i].r/=Lim;
}
inline void write(string S){
	ll Len=S.size();
	for(ll i=0;i<=Len;i++) putchar(S[i]);
	putchar('\n');
}
inline string toString(ll p){
	string P;
	while(p){P+=(p%10+'0'),p/=10;}
	reverse(P.begin(),P.end());
	return P;
}
inline string times(string S1,string S2){
	Alen=0,Blen=0,Lim=1,len=0;
	memset(rev,0,sizeof rev);
	memset(A,0,sizeof A);memset(B,0,sizeof B);memset(ans,0,sizeof ans);
	for(ll i=S1.size()-1;i>=0;i--) A[Alen++].r=S1[i]^48;
	for(ll i=S2.size()-1;i>=0;i--) B[Blen++].r=S2[i]^48;
	while(Lim<=Alen+Blen) Lim<<=1,++len;
	for(ll i=0;i<Lim;++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<(len-1));
	FFT(A,1),FFT(B,1);
	for(ll i=0;i<Lim;++i) A[i]=A[i]*B[i];
	FFT(A,-1);
	for(ll i=0;i<Lim;++i){
		ans[i]+=(ll)(A[i].r+0.5);
		if(ans[i]>9) ans[i+1]+=ans[i]/10,ans[i]%=10,Lim+=(i==Lim);
	}
	while(!ans[Lim]&&Lim>=1) --Lim;++Lim;
	string P;
	while(--Lim>=0) P+=('0'+ans[Lim]);
	return P;
}
inline string ksm(string S1,ll p){
	string S2="1";
	while(p){
		if(p&1) S2=times(S2,S1);
		S1=times(S1,S1);
		p>>=1;
	}
	return S2;
}
ll na[Maxn],nb[Maxn];
inline string sub(string a, string b){
    memset(na,0,sizeof na);
    memset(nb,0,sizeof nb);
    memset(ans,0,sizeof ans);
    string P;
    if((a<b&&a.size()<=b.size())||b.size()>a.size()) return "-"+sub(b,a);
    for(ll i=a.size();i>0;i--)na[i]=a[a.size()-i]-'0';
    for(ll i=b.size();i>0;i--)nb[i]=b[b.size()-i]-'0';
    ll len2=max(a.size(),b.size());
    for(ll i=1;i<=len2;i++){
        if(na[i]<nb[i]) na[i+1]--,na[i]+=10;
        ans[i]=na[i]-nb[i];
    }
    while(ans[len2]==0) len2--;
    if(len2<1)return "0";
    for(ll i=len2;i>0;i--) P+=ans[i]+'0';
    return P;
}
inline string add(string a, string b){
    memset(na,0,sizeof na);
    memset(nb,0,sizeof nb);
    memset(ans,0,sizeof ans);
    string P;
    for(ll i=a.size();i>0;i--)na[i]=a[a.size()-i]-'0';
    for(ll i=b.size();i>0;i--)nb[i]=b[b.size()-i]-'0';
    ll len2=max(a.size(),b.size());
    for(ll i=1;i<=len2;i++){
        ans[i]+=na[i]+nb[i];
        if(ans[i]>9) ans[i+1]+=ans[i]/10,ans[i]%=10;
    }
    while(ans[len2]==0) len2--;
    if(len2<1)return "0";
    for(ll i=len2;i>0;i--) P+=ans[i]+'0';
    return P;
}
inline bool check(string a,string b){
	ll sizea=a.size(),bsize=b.size();
	if(sizea!=bsize) return sizea<bsize;
	for(ll i=0;i<sizea;i++){
		if(a[i]==b[i]) continue;
		return a[i]<b[i];
	}
	return 0;
}
inline ll Log2(string S){
	ll lens=S.size()-1;lens=lens*log2(10);ll k=0;
	string g=ksm("2",lens);
	while(check(g,S)) g=times(g,"2"),++lens,++k;
	return lens;
}
int main(){
	cin>>S;
	ll len=Log2(S);
	string P=add(sub(times(S,toString(len)),ksm("2",len)),"1");ll an=0;
	write(P);
	return 0;
}
```


---


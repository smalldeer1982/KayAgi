# ckw的树

## 题目描述

ckw有一棵无根树，ckw会随意挑一个点然后开始随机游走，每一个单位时间会等概率跳到与当前点距离不超过$2$的任意一个点。树上有一些点被标记了，求ckw第一次到达被标记的点的期望时间。


## 说明/提示

$2 \le n\le 10^5,1\le m \le n$

$subtask1(20pts):n\le 300$

$subtask2(16pts):$第$i$条边连接$i$和$i+1$

$subtask3(8pts):$第$i$条边链接$1$和$i+1$

$subtask4(20pts):n\le 3000$，且最大点的度数不超过$4$

$subtask5(36pts):$无限制

## 样例 #1

### 输入

```
2 1
1 2
1```

### 输出

```
0
2```

## 样例 #2

### 输入

```
10 2
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
2
5```

### 输出

```
3
0
3
4
0
8
10
13
14
15```

## 样例 #3

### 输入

```
10 2
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9  
1 10
3
6```

### 输出

```
5
5
0
5
5
0
5
5
5
5```

# 题解

## 作者：ケロシ (赞：13)

模拟赛时想到一个的绝妙做法。

下文中的 $v$ 是指与 $u$ 相邻的节点，$s$ 指 $u$ 的儿子，$ru_u$ 为点 $u$ 的度数，$su_u=\sum ru_v$。

设 $f_u$ 为从点 $u$ 开始走的期望步数，则可以列出方程：

$$f_u=\frac{\sum_{dis(u,k)\le 2} f_k}{su_u+1}+1$$

若为点 $u$ 为终点，则 $f_u=0$。

但是方程 $u$ 与较远的 $k$ 有关系，不好算。能不能只和相邻的点有关系？答案是可以的，设 $g_u$：

$$g_u=\sum f_v$$

那么算 $f_u$ 只需要容斥一下：

$$
f_u=\frac{\sum f_v + \sum g_v - ru_u f_u + f_u}{su_u + 1}+1
$$

把 $f_u$ 都移到一边：

$$
f_u=\frac{\sum f_v + \sum g_v + su_u + 1}{su_u + ru_u}
$$

这样所有的式子就只和相邻项有关系了。

考虑如何解这些方程，直接做就是高斯消元了，但是我们需要更优的做法。

考虑小学二年级是如何解方程的，没错就是代入消元，不难发现这里可以先从叶子开始代入消元，譬如叶子 $u$，有 $g_u=f_{fa}$，考虑用 $f_{fa}$ 与 $g_{fa}$ 表示 $f_u$ 与 $g_u$，形如：

$$
[f_u,g_u]=[f_{fa},g_{fa},1]
\begin{bmatrix}
\dots & \dots \\
\dots & \dots \\
\dots & \dots \\
\end{bmatrix}
$$

$$
f_u=[f_{fa},g_{fa},1]F_u
\\
g_u=[f_{fa},g_{fa},1]G_u
$$

其中 $F_u$ 与 $G_u$ 都表示大小一乘三的矩阵。

这样点 $u$ 的值就能用父亲来表示，而点 $u$ 方程中含有有关儿子 $s$ 的项，都可以用 $s$ 的父亲 $u$ 表示，这样方程就只和父亲有关了。

因为叶子节点没有儿子，所以 dfs，从叶子开始，一步一步向上代入消元即可。

这样的话，点 $u$ 的方程消掉儿子，就变成：

$$
g_u=f_{fa}+[f_u,g_u,1]\sum F_s
$$

$$
f_u=\frac{[f_u,g_u,1](\sum F_s+\sum G_s)+f_{fa} + g_{fa} + su_u + 1}{su_u + ru_u}
$$

这里用任何方法解出方程即可，比如暴力推式子或者搞大小二乘五矩阵的高斯消元。

然后对于终点的 $g_u$ 特判一下即可。

然后求出根节点 $F_{rt}$ 和 $G_{rt}$ 后，不难想到因为根节点没有父亲，所以没有 $f_{fa}$ 和 $g_{fa}$，所以 $f_{rt}$ 的值即为 $F_{rt}$ 的常数项 ${F_{rt}}_{3,1}$，同理 $g_{rt}={G_{rt}}_{3,1}$。

求出根节点的两个值后，再做一次 dfs 把所有点的 $f_u$ 与 $g_u$ 全部反推出来即可。

忽略逆元复杂度，时间复杂度为 $O(n)$。

```cpp
const int N = 1e5 + 5;
const int P = 998244353;
int add(int x, int y) { return (x + y < P ? x + y : x + y - P); }
void Add(int & x, int y) { x = (x + y < P ? x + y : x + y - P); }
int sub(int x, int y) { return (x < y ? x - y + P : x - y); }
void Sub(int & x, int y) { x = (x < y ? x - y + P : x - y); }
int mul(int x, int y) { return (1ll * x * y) % P; }
void Mul(int & x, int y) { x = (1ll * x * y) % P; }
int fp(int x, int y) {
	int res = 1;
	for(; y; y >>= 1) {
		if(y & 1) Mul(res, x);
		Mul(x, x);
	}
	return res;
}
int n, m, a[N];
int fi[N], ne[N << 1], to[N << 1], ecnt;
int ru[N], su[N];
struct Node { // 1x3 矩阵
	int f, g, c;
	friend Node operator + (Node A, Node B) {
		Node res;
		res.f = add(A.f, B.f);
		res.g = add(A.g, B.g);
		res.c = add(A.c, B.c);
		return res;
	}
	friend Node operator - (Node A, Node B) {
		Node res;
		res.f = sub(A.f, B.f);
		res.g = sub(A.g, B.g);
		res.c = sub(A.c, B.c);
		return res;
	}
	friend Node operator * (Node A, int B) {
		Node res;
		res.f = mul(A.f, B);
		res.g = mul(A.g, B);
		res.c = mul(A.c, B);
		return res;
	}
	Node & operator += (const Node &A) {
		return *this = *this + A;
	}
	Node & operator -= (const Node &A) {
		return *this = *this - A;
	}
	Node & operator *= (const int &A) {
		return *this = *this * A;
	}
} f[N], g[N];
int A[2][5]; // 用于高斯消元解小方程的 2x5 矩阵
int ans[N][2];
void add_edge(int u, int v) {
	ne[++ ecnt] = fi[u];
	to[ecnt] = v;
	fi[u] = ecnt;
}
void guass() { // 高斯消元解小方程
	if(! A[0][0]) swap(A[0], A[1]);
	int val = fp(A[0][0], P - 2);
	REP(i, 5) Mul(A[0][i], val);
	val = A[1][0];
	REP(i, 5) Sub(A[1][i], mul(A[0][i], val));
	val = fp(A[1][1], P - 2);
	REP(i, 5) Mul(A[1][i], val);
	val = A[0][1];
	REP(i, 5) Sub(A[0][i], mul(A[1][i], val));
	REP(i, 5) A[0][i] = sub(0, A[0][i]);
	REP(i, 5) A[1][i] = sub(0, A[1][i]);
}
void dfs1(int u, int fa) {
	Node F = {0, 0, 0}, G = {0, 0, 0};
	for(int i = fi[u]; i; i = ne[i]) {
		int v = to[i];
		if(v == fa) continue;
		dfs1(v, u);
		F += f[v], F += g[v];
		G += f[v];
	}
	if(! a[u]) {
		A[0][0] = G.f;
		A[0][1] = sub(G.g, 1);
		A[0][2] = 1;
		A[0][3] = 0;
		A[0][4] = G.c;
		A[1][0] = F.f;
		A[1][1] = F.g;
		A[1][2] = 1;
		A[1][3] = 1;
		A[1][4] = add(F.c, su[u] + 1);
		int val = fp(su[u] + ru[u], P - 2);
		REP(i, 5) Mul(A[1][i], val);
		Sub(A[1][0], 1);
		guass();
		f[u] = {A[0][2], A[0][3], A[0][4]};
		g[u] = {A[1][2], A[1][3], A[1][4]};
	}
	else { // 是终点要特判一下
		int val = sub(1, G.g);
		g[u].f = 1, g[u].c = G.c;
		g[u] *= fp(val, P - 2);
	}
} 
void dfs2(int u, int fa) {
	for(int i = fi[u]; i; i = ne[i]) {
		int v = to[i];
		if(v == fa) continue;
		Add(ans[v][0], mul(ans[u][0], f[v].f));
		Add(ans[v][0], mul(ans[u][1], f[v].g));
		Add(ans[v][0], f[v].c);
		Add(ans[v][1], mul(ans[u][0], g[v].f));
		Add(ans[v][1], mul(ans[u][1], g[v].g));
		Add(ans[v][1], g[v].c);
		dfs2(v, u);
	}
}
void solve() {
	cin >> n >> m;
	REP(_, n - 1) {
		int u, v;
		cin >> u >> v;
		add_edge(u, v);
		add_edge(v, u);
		ru[u] ++, ru[v] ++;
	}
	FOR(u, 1, n) for(int i = fi[u]; i; i = ne[i]) {
		int v = to[i];
		Add(su[u], ru[v]);
	}
	REP(_, m) {
		int x; cin >> x;
		a[x] = 1;
	}
	dfs1(1, 0);
	ans[1][0] = f[1].c;
	ans[1][1] = g[1].c;
	dfs2(1, 0);
	FOR(i, 1, n) cout << ans[i][0] << endl;
}
```

---

## 作者：zJx_Lm (赞：4)

#### 题意
给定一棵树，从一个点可以走到距离不超过2的其他点（包括自己），有若干个终点，问以某个点当起点的期望步数。
#### 思路
我们设 $E(u)$ 为从 $u$ 点开始走的期望步数，容易得到
$
E(u)=\frac{E(gfa(u))+E(fa_{u})+\sum_{v\epsilon bro_{u}}E(v)+\sum_{v\epsilon son_{u}}E(v)+\sum_{v\epsilon gson_{u}}E(v)}{du_{u}}+1
$

(记得加上原地不动的情况)

高斯应该很好解吧，但我们可以考虑能不能消掉几项。
首先我们注意到叶子节点和根节点是少了几项的，考虑是否能根据他们消掉几项。

叶节点：
$
E(u)=\frac{E(gfa_{u})+E(fa_{u})+\sum_{v\epsilon bro_{u}}E(v)}{du_{u}}+1
$

将他的所有兄弟节点加起来，则：

$
\sum E(u)=\sum a E(gfa_{u})+\sum b E(fa_{u})+\sum c \sum_{v \epsilon bro_{u}}E(v)+f
$

（$a,b,c,f$ 为系数）

因为 $\sum E(u)=\sum_{v\epsilon bro_{u}}E(v)$, 我们设 $sum(u)=\sum E(u),A=\sum a,B=\sum b,C=\sum c$

可以得到：

$
sum(u)=AE(gfa_{u})+BE(fa_{u})+Csum(u)+f
$

$
sum(u)=\frac{AE(gfa_{u})+BE(fa_{u})}{1-C}+f
$

我们把他带入到叶节点的式子，从而消去了 $c$ 项，现在叶节点仅剩下 $a,b,f$
 项。
 然后再带入总式子，就可以消去 $son$ 和 $gson$ 项，注意 $son$ 和 $gson$ 的各项与原式各项的对应关系。然后原式就剩下 $a,b,c,f$ 项，仿照叶节点的方式就可以再消去 $c$ 项。
 
 最后每个方程仅剩下 $a,b,f$ 项，从根节点向下扫一边即可求出答案。

*Code:*

```cpp
#include <bits/stdc++.h>
#define pir make_pair
#define db double
#define int long long
#define re register
using namespace std;
const int maxn=1e5+10;
const int mol=998244353;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') f=(ch=='-')?-1:1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}

inline int qpow(int a,int b) { int ans=1; while(b){ if(b&1) (ans*=a)%=mol; (a*=a)%=mol; b>>=1; } return ans; }
int n,m,w[maxn],du[maxn],son[maxn];
struct EDGE { int var,nxt; } edge[maxn<<1];
int head[maxn],cnt=1,ansl[maxn];
inline void add(int a,int b) { edge[++cnt]=(EDGE){b,head[a]}; head[a]=cnt; }
struct DATE { int a,b,c,d; } f[maxn],g[maxn];
inline void dfs1(int now,int fa,int ff,int e) {
	du[now]=son[fa]+(fa>0)+(ff>0);
	son[now]=0ll;
	int A=0ll,B=0ll,C=1ll,D=0ll;
	for(re int i=head[now],to;i;i=edge[i].nxt) if(i!=e) son[now]++;
	for(re int i=head[now],to;i;i=edge[i].nxt) if(i!=e) { 
		to=edge[i].var;
		dfs1(to,now,fa,i^1);
		(du[now]+=(son[to]+1)%mol)%=mol;
		(A+=f[to].a)%=mol; (B+=f[to].b)%=mol; (C+=mol-f[to].c)%=mol; (D+=f[to].d)%=mol; 
	}
	int sd=qpow(du[now],mol-2);
	f[now].a=f[now].b=f[now].c=sd; f[now].d=1ll;
	int sc=(C!=0)? qpow(C,mol-2):0ll;
	int l=1ll;
	(A*=sc)%=mol; (B*=sc)%=mol; (D*=sc)%=mol; 
	for(re int i=head[now],to;i;i=edge[i].nxt) if(i!=e) {
		to=edge[i].var;
		(f[to].a+=A*f[to].c%mol)%=mol;
		(f[to].b+=B*f[to].c%mol)%=mol;
		(f[to].d+=D*f[to].c%mol)%=mol;
		f[to].c=0ll;
		
		(f[now].b+=f[to].a*(g[to].b+1ll)%mol*sd%mol)%=mol;
		(f[now].d+=f[to].d*(g[to].b+1ll)%mol*sd%mol)%=mol;
		(l+=mol-f[to].b*(g[to].b+1ll)%mol*sd%mol)%=mol;
		
		(f[now].d+=g[to].d*sd%mol)%=mol;
		(l+=mol-g[to].a*sd%mol)%=mol;
		
		(g[now].a+=f[to].a)%=mol; (g[now].b+=f[to].b)%=mol; (g[now].d+=f[to].d)%=mol;
	}
	if(!w[now]) {
		int sl=qpow(l,mol-2);
		(f[now].a*=sl)%=mol; (f[now].b*=sl)%=mol; (f[now].c*=sl)%=mol; (f[now].d*=sl)%=mol;
	} else { f[now].a=f[now].b=f[now].c=f[now].d=0ll; }
}
inline void dfs2(int now,int l1,int l2,int e) {
	ansl[now]=((f[now].b*l1%mol+f[now].a*l2%mol)%mol+f[now].d)%mol;
	for(re int i=head[now];i;i=edge[i].nxt) if(i!=e) {
		dfs2(edge[i].var,ansl[now],l1,i^1);
	}
}
signed main(void) {
    n=read(),m=read(); 
    for(re int i=1,x,y;i<n;i++) { x=read(); y=read(); add(x,y); add(y,x); }
    for(re int i=1,x;i<=m;i++) { x=read(); w[x]=1; }
    son[0]=1ll; dfs1(1,0,0,0); 
   	int sc=qpow((1ll-f[1].c+mol)%mol,mol-2); f[1].c=0ll;
   	(f[1].a*=sc)%=mol; (f[1].b*=sc)%=mol; (f[1].d*=sc)%=mol;
   	dfs2(1,0,0,0);
   	for(re int i=1;i<=n;i++) printf("%lld\n",ansl[i]);
}

```







---

## 作者：final_trump (赞：4)

## P5637 ckw的树

此题不同于普通的树上随机游走，它扩充了条件: $dis \leq 2$  。暴力高斯消元肯定行不通$(n \leq 10^5)$ ，这启发我们用更优秀的解法。

我们优先考虑 $dis \leq 1$ 的解法。这是一类经典的树上高消问题([比较板的例题](https://www.luogu.com.cn/problem/CF802L))，通常解法就是将动归函数 $f_u$ 表示为关于其父亲节点的一次函数，即 $f_u=\alpha_u f_{fa}+\beta_u$ ，通过代入朴素方程解出对应的 $\alpha$ 、$\beta$，从下往上递推即可。

本题由于可以到达所有 $dis \leq 2$ 的节点，我们可以类比之前的解法，设 $f_u=a_uf_{fa}+b_uf_{pa}+c_u$，然后再想办法解出对应系数。对于当前节点 $u$ 它可以到达的节点包括 孙子节点(gs) 、儿子节点(s) 、兄弟节点(bro) 、父亲节点(fa) 、祖父节点(pa)。

![relations](https://cdn.luogu.com.cn/upload/image_hosting/2i8rvekz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（如图所示，红色节点为u，橙色为gs，黄色为s，蓝色为bro，绿色为fa，紫色为pa）

然后我们就可以开心的推式子了！
$$
f_u=\frac{\sum f_{gs} + \sum f_s + \sum f_{bro} + f_u + f_{fa} + f_{pa}}{S_u}+1\\
$$
我们可以展开 $f_s$ 项和 $f_{gs}$ 项，把展开的 $f_{gs}$ 项继续展开(还存在 $f_s$ 项)，就可以得到下面的式子:

(大写字母表示同一关系中的某一系数和，$suma_u$ 表示节点 $u$ 的儿子的 $a$ 之和)

$$
(S_u-\sum_{s \in son_u} (suma_s \ a_s)-B_{gs}-A_s-1)f_u=(\sum_{s \in son_u}(suma_s b_s) + B_s + 1)f_{fa} + f_{pa} + (\sum_{s \in son_u}(suma_sc_s) + C_{gs} + C_s + S_u) + \sum f_{bro}
$$

(这里之所以未展开和式，是因为作者太菜不知道如何更清晰的表达这种关系，不过这在代码中很好实现)

把 $f_u$ 的常数移过去，我们似乎就能得到对应的系数了。。

等一下，兄弟节点好像还未处理！

我们发现在从叶节点向上推的过程中，由于同一兄弟关系相互影响，形成了环状的递推方程。

难道我们就只有再回到高斯消元吗？一棵菊花图就能卡死这种做法。

这里提供一种非常巧妙的解法。首先上面的那个式子实在是太长了，我们用字母去替换一部分。
$$
f_u=a_uf_{fa}+b_uf_{pa}+c_u+d_u\sum f_{bro}
$$
(这里的系数并不是最终答案的系数)

然后两边同时加上 $d_uf_u$，并设在同一兄弟关系中，$\sum f_{cousin}=S$
$$
(1+d_u)f_u=a_uf_{fa}+b_uf_{pa}+c_u+d_uS
$$
再把左边的系数除过去
$$
f_u=\frac{a_u}{1+d_u}f_{fa}+\frac{b_u}{1+d_u}f_{pa}+\frac{c_u}{1+d_u}+\frac{d_u}{1+d_u}S
$$
然后我们发现，对于同一兄弟关系中的每一个 $u$ 我们都能表示为类似于上面的式子。于是我们把它加起来
$$
S=sumaf_{fa}+sumbf_{pa}+sumc+sumdS
$$
我门就可以找到 $S$ 对应的系数了。最后把 $S$ 带回，我们就可以找到每个 $u$ 对应的系数。

最后合并一下答案就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5,MOD=998244353;

int n,m,root;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch))(ch=='-')&&(f=-f),ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline int expow(int n,int k){
	int ans=1;
	for(;k;k>>=1,n=1ll*n*n%MOD) (k&1)&&(ans=1ll*ans*n%MOD);
	return ans;
}
inline int inv(int k){
	return expow(k,MOD-2); 
}
inline int explus(int x,int y){
	return x+y>MOD?x+y-MOD:x+y;
}
inline int exminus(int x,int y){
	return x-y<0?x-y+MOD:x-y;
}

int head[MAXN],trump;
struct Edge{
	int to,next;
	Edge(int u=0,int v=0):to(v),next(head[u]){};
}e[MAXN<<1];
inline void addedge(int u,int v){
	e[++trump]=Edge(u,v);head[u]=trump;
	e[++trump]=Edge(v,u);head[v]=trump;
}

#define v e[i].to
bool vis[MAXN];
int w[MAXN][4];
int r[MAXN][4];
int ds[MAXN],d[MAXN];
int f[MAXN],father[MAXN];
void pre_dfs(int u,int fa){
	d[u]=u==root?1:ds[fa]+1+(father[fa]!=0);father[u]=fa;
	register int i,j;
	for(i=head[u];i;i=e[i].next)
		if(v!=fa) ++ds[u];
	d[u]+=ds[u];
	for(i=head[u];i;i=e[i].next)
		if(v!=fa) pre_dfs(v,u),d[u]+=ds[v];
}

void dfs(int u,int fa){
	int i,j;
	int iv;
	for(i=head[u];i;i=e[i].next) if(v!=fa) dfs(v,u);
	int s[4]={};
	for(i=head[u];i;i=e[i].next){
		if(v==fa) continue;
		iv=inv(explus(r[v][3],1));
		for(j=0;j<4;++j) s[j]=explus(s[j],1ll*r[v][j]*iv%MOD);
	}
	iv=inv(exminus(1,s[3]));
	for(j=0;j<3;++j) s[j]=1ll*s[j]*iv%MOD;
	for(i=head[u];i;i=e[i].next){
		if(v==fa) continue;
		iv=inv(explus(r[v][3],1));
		if(!vis[v])
			for(j=0;j<3;++j)
				w[v][j]=1ll*explus(r[v][j],1ll*s[j]*r[v][3]%MOD)*iv%MOD;
	}
	if(vis[u]) return;
	int sumas,As=0,Bs=0,Bgs=0,Cs=0,Cgs=0,Sa=0,Sb=0,Sc=0;
	for(i=head[u];i;i=e[i].next){
		if(v==fa) continue;
		sumas=0;
		As=explus(As,w[v][0]);
		Bs=explus(Bs,w[v][1]);
		Cs=explus(Cs,w[v][2]);
		for(j=head[v];j;j=e[j].next)
			if(e[j].to!=u){
				sumas=explus(sumas,w[e[j].to][0]);
				Bgs=explus(Bgs,w[e[j].to][1]);
				Cgs=explus(Cgs,w[e[j].to][2]);
			}
		Sa=explus(Sa,1ll*w[v][0]*sumas%MOD);
		Sb=explus(Sb,1ll*w[v][1]*sumas%MOD);
		Sc=explus(Sc,1ll*w[v][2]*sumas%MOD);
	}
	r[u][3]=inv(exminus(d[u],explus(Sa,explus(Bgs,explus(As,1)))));
	r[u][0]=1ll*explus(Sb,explus(Bs,1))*r[u][3]%MOD;
	r[u][1]=r[u][3];
	r[u][2]=1ll*explus(Sc,explus(Cgs,explus(Cs,d[u])))*r[u][3]%MOD;
	if(u==root){
		w[u][0]=r[u][0];
		w[u][1]=r[u][1];
		w[u][2]=r[u][2];
	}
}

void calc(int u,int fa){
	f[u]=explus(1ll*f[fa]*w[u][0]%MOD,explus(1ll*f[father[fa]]*w[u][1]%MOD,w[u][2]));
	for(register int i=head[u];i;i=e[i].next){
		if(v==fa) continue;
		calc(v,u);
	}
}
#undef v

int main(){
	register int i;
	n=read();m=read();root=1;
	for(i=1;i<n;++i) addedge(read(),read());
	for(i=1;i<=m;++i) vis[read()]=1;
	pre_dfs(root,0);
	dfs(root,0);
	calc(root,0);
	for(i=1;i<=n;++i) printf("%d\n",f[i]);
	return 0;
}
```



---

## 作者：min_inf (赞：2)

让我们说中文。

首先距离为 $2$ 看起来就很错，设 $f_u$ 为答案，$g_u=\sum\limits_{(u,v)\in T}f_v$，可以列出线性方程组 $f_u=1+\frac{\sum\limits_{(u,v)\in T}(f_v+g_v)-(\operatorname{deg}_u-1)f_u}{1+\sum\limits_{(u,v)\in T}\operatorname{deg}_v}$，这样就只和相邻的点有关。

直接消元显然会倒闭，考虑按照一定顺序确定答案，比如从下往上递推。这样我们没法知道 $f_{fa}$ 和 $g_{fa}$，不过很明显 $f_u$ 和 $g_u$ 可以表示为 $af_{fa}+bg_{fa}+c$，将这个作为 DP 状态，把子树的答案表示为只和 $u$ 有关然后带入 $u$ 的柿子，得到两个形如 $af_u+bg_u+cf_{fa}+dg_{fa}+e$ 的柿子，高斯消元解一下即可得到 $u$ 的 DP 值。

DP 到根的时候显然常数项就是答案，再根据每个点的 DP 值逆推回去就行了。

能跳的距离更大的时候可以设 $f_{u,i}$ 为距离 $u$ 为 $i$ 的点答案之和，可以做到 $O(nk^3)$。

```cpp
void dfs1(int u,int fa){
    Z M[2][5]{};
    // fu = (sum gv + sum fv - degu*fu + fu) / cnt
    // gu = sum fv
    M[0][0]+=deg(u),--M[0][2],--M[0][3],--M[1][2];
    for(auto v:G[u])if(v!=fa){
        dfs1(v,u);
        rep(x,0,1)rep(y,0,2)rep(z,0,x^1)M[x][y<2?y:4]-=dp[v][z][y];
    }
    int cnt=0;
    for(auto v:G[u])cnt+=deg(v);
    Z inv=Z(1)/cnt;
    rep(i,0,4)M[0][i]*=inv;
    ++M[0][0],++M[1][1],--M[0][4];
    if(mk[u])rep(k,0,4)M[0][k]=!k;
    rep(i,0,1){
        int row=-1;
        rep(j,i,1)if(M[j][i].val())row=j;
        assert(~row);
        rep(j,0,4)swap(M[i][j],M[row][j]);
        Z inv=1/M[i][i];
        rep(j,0,4)M[i][j]*=inv;
        row=i^1;
        Z k=M[row][i];
        rep(j,0,4)M[row][j]-=M[i][j]*k;
    }
    rep(x,0,1)rep(y,0,2)dp[u][x][y]=-M[x][y+2];
}
Z f[N],g[N];
void dfs2(int u,int fa){
    for(auto v:G[u])if(v!=fa){
        f[v]=dp[v][0][0]*f[u]+dp[v][0][1]*g[u]+dp[v][0][2];
        g[v]=dp[v][1][0]*f[u]+dp[v][1][1]*g[u]+dp[v][1][2];
        dfs2(v,u);
    }
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin>>n>>m;
    rep(i,2,n){
        int u,v;cin>>u>>v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    while(m--){
        int x;cin>>x;
        mk[x]=1;
    }
    dfs1(1,0);
    f[1]=dp[1][0][2],g[1]=dp[1][1][2];
    dfs2(1,0);
    rep(i,1,n)cout<<f[i].val()<<'\n';
}
```

---

## 作者：ningago (赞：1)

树上随机游走模型的扩展。

令 $E_k$ 为 $k$ 节点还需要走的期望步数，若 $k$ **没有被标记**，则有定义式（其中 $k\in bro(k)$）：

$$E_k=\dfrac{1}{cnt_k}(E_{fa_k}+E_{gfa_k}+\sum_{t\in bro(k)}E_t+\sum_{nx\in son(k)}E_{nx}+\sum_{nx\in gson(k)}E_{nx})+1$$

不难发现，叶子节点的后两项是不存在的。所以后两项可以从儿子递推，可以考虑把 $E_k$ 写成如下形式：

$$E_k=a_kE_{fa_k}+b_kE_{gfa_k}+c_k+\dfrac{1}{cnt_k}\sum_{t\in bro(k)}E_t$$

难点在于兄弟的贡献如何展开。假定已经算出了 $E_k$ 的 $a,b,c$ 系数，对 $k$ 的兄弟节点一起考虑。此时 $bro$ 集合，$fa_k,gfa_k$ 都固定，令 $\sum_{t\in bro(k)}E_t=S$：

$$S=\sum_k(a_kE_{fa_k}+b_kE_{gfa_k}+c_k+\dfrac{1}{cnt_k}S)$$

$$S=\dfrac{E_{fa_k}(\sum_k a_k)+E_{gfa_k}(\sum_k b_k)+(\sum_k c_k)}{1-\sum_k \dfrac{1}{cnt_k}}$$

所以可以把 $S$ 化进 $a,b,c$ 中。

接下来就只用考虑从儿子递推了，这是容易的，展开后的结果：

$$\begin{aligned}
cnt_k\cdot E_k
&=E_k(\sum_{nx\in son(k)}a_{nx}+\sum_{s\in son(k)}\sum_{nx\in son(s)}b_{nx}+\sum_{s\in son(k)}a_s\sum_{nx\in son(s)}a_{nx})\\
&+E_{fa_k}(1+\sum_{nx\in son(k)}b_{nx}+\sum_{s\in son(k)}b_s\sum_{nx\in son(s)}a_{nx})\\
&+E_{gfa_k}\\
&+S\\
&+(cnt_k+\sum_{nx\in son(k)}c_{nx}+\sum_{s\in son(k)}\sum_{nx\in son(s)}c_{nx}+\sum_{s\in son(k)}c_s\sum_{nx\in son(s)}a_{nx})
\end{aligned}$$

容易化简出系数。

由于根节点的 $E_{fa}=E_{gfa}=0$，可以直接推出 $E_{root}=c_{root}$。最后 dfs 一遍还原出每个节点的 $E$ 即可。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <ctype.h>
#include <cmath>
#include <vector>

char ST;

#define ll long long
#define inf 0x3f3f3f3f
//#define int long long
//#define inf 0x3f3f3f3f3f3f3f3f
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define gline debug("now is #%d\n", __LINE__)
#define pii std::pair <int, int>
#define mkp std::make_pair
#define fi first
#define se second

int read()
{
	int x = 0, f = 1;
	char c = getchar();
	for(; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for(;  isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

void ckmax(int &x, int y) { x = x > y ? x : y; }
void ckmin(int &x, int y) { x = x < y ? x : y; }

#define mod 998244353
//#define mod 1000000007
void plus_(int &x, int y) { x = x + y >= mod ? x + y - mod : x + y; }
void mul_(int &x, int y) { x = 1ll * x * y % mod; }
int ksm(int a, int b)
{
	int res = 1;
	for(; b; b >>= 1, mul_(a, a)) if(b & 1) mul_(res, a);
	return res;
}

#define N 100010
int n, m;
bool flag[N];
int h[N], e[N << 1], ne[N << 1], idx = -1;
void add_edge(int x, int y) { ne[++idx] = h[x], h[x] = idx, e[idx] = y; }
void add(int x, int y) { add_edge(x, y), add_edge(y, x); }

int a[N], b[N], c[N], d[N];
int suma[N], sumb[N], sumc[N];

int du[N], son[N];

void dfs1(int k, int fa, int ff)
{
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(nx == fa) continue;
		dfs1(nx, k, fa);
		son[k]++;
		du[k] += son[nx] + 1;
	}
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(nx == fa) continue;
		du[nx] += son[k];
	}
	du[k] += (!!fa) + (!!ff);
}

void dfs2(int k, int fa)
{
	int A, B, C, D;
	A = B = C = D = 0; 
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(nx == fa) continue;
		dfs2(nx, k);
		plus_(A, a[nx]), plus_(B, b[nx]);
		plus_(C, c[nx]), plus_(D, d[nx]);
	}
	D = (mod + 1 - D) % mod;
	D = ksm(D, mod - 2);
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(nx == fa) continue;
		plus_(a[nx], 1ll * A * D % mod * d[nx] % mod);
		plus_(b[nx], 1ll * B * D % mod * d[nx] % mod);
		plus_(c[nx], 1ll * C * D % mod * d[nx] % mod);
		d[nx] = 0;
		plus_(suma[k], a[nx]);
		plus_(sumb[k], b[nx]);
		plus_(sumc[k], c[nx]);
	}
	if(flag[k])
	{
		a[k] = b[k] = c[k] = d[k] = 0;
		return;
	}
	int S;
	a[k] = b[k] = d[k] = 1;
	S = c[k] = du[k];
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(nx == fa) continue;
		plus_(a[k], b[nx]);
		plus_(a[k], 1ll * b[nx] * suma[nx] % mod);
		plus_(S, mod - a[nx]);
		plus_(S, mod - sumb[nx]);
		plus_(S, mod - 1ll * a[nx] * suma[nx] % mod);
		plus_(c[k], c[nx]);
		plus_(c[k], sumc[nx]);
		plus_(c[k], 1ll * c[nx] * suma[nx] % mod);
	}
	S = ksm(S, mod - 2);
	mul_(a[k], S), mul_(b[k], S), mul_(c[k], S), mul_(d[k], S);
}

int E[N];

void dfs3(int k, int fa, int gfa)
{
	E[k] = c[k];
	plus_(E[k], 1ll * a[k] * E[fa] % mod);
	plus_(E[k], 1ll * b[k] * E[gfa] % mod);
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(nx == fa) continue;
		dfs3(nx, k, fa);
	}
}

char ED;
int main()
{
	debug("1/2 = %d, 1/3 = %d\n", ksm(2, mod - 2), ksm(3, mod - 2));
	debug("%.3f MB\n", abs(&ST - &ED) / 1024.0 / 1024);
	memset(h, idx = -1, sizeof(h));
	n = read(), m = read();
	for(int i = 1, x, y; i < n; i++) x = read(), y = read(), add(x, y);
	for(int i = 1; i <= m; i++) flag[read()] = 1;
	dfs1(1, 0, 0);
	du[1]++;
	dfs2(1, 0);
	int D = (mod + 1 - d[1]) % mod;
	D = ksm(D, mod - 2);
	plus_(a[1], 1ll * a[1] * D % mod * d[1] % mod);
	plus_(b[1], 1ll * b[1] * D % mod * d[1] % mod);
	plus_(c[1], 1ll * c[1] * D % mod * d[1] % mod);
	d[1] = 0;
	dfs3(1, 0, 0);
	for(int i = 1; i <= n; i++) printf("%d\n", E[i]);
	return 0;
}
```

---


# 基础函数练习题

## 题目背景

YSGH is our red sun.


## 题目描述

YSGH 有一个 $1 \sim n$ 的排列 $p$ 和一个长度为 $n$ 的整数序列 $w$。

定义：

$$ F(l, r) = \begin{cases} \max(F(l, m - 1), F(m + 1, r)) + w_m & , l \le r \\ 0 & , l > r \end{cases} $$

其中 $m$ 为 $p$ 的区间 $[l, r]$ 的最大值的下标。

$q$ 次询问 $F(l, r)$ 的值。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（10 points）：$n, q \le 5 \times {10}^3$。
- Subtask 2（10 points）：保证 $p$ 是随机的。
- Subtask 3（20 points）：$n ,q \le 5 \times {10}^4$。
- Subtask 4（20 points）：$n, q \le {10}^5$。
- Subtask 5（20 points）：$w_i \ge 0$。
- Subtask 6（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n, q \le 5 \times {10}^5$，$|w_i| \le 10^9$，$1 \le p_i \le n$，保证 $p$ 是一个 $1 \sim n$ 的排列。

## 样例 #1

### 输入

```
5 2
2 1 5 3 4
2 5 1 2 4
3 5
1 1```

### 输出

```
7
2```

# 题解

## 作者：小粉兔 (赞：15)

### 题意简述：

题目说得很清楚了。

### 题解：

观察这个函数，$\displaystyle F(l, r) = \max(F(l, m-1), F(m+1, r)) + w_m$。

很显然，当询问 $F(1, n)$ 时，转移就是一个笛卡尔树的结构。笛卡尔树的构建可以使用单调栈。

考虑询问 $l, r$ 时，区间 $[l, r]$ 形成的笛卡尔树：

![](https://cdn.luogu.com.cn/upload/image_hosting/wsdj3nru.png)

上图为序列 $p = \{3, 4, 1, 12, 7, 2, 8, 5, 15, 10, 13, 6, 9, 14, 11\}$ 的笛卡尔树。

当询问 $\left< l, r \right> = \left< 6, 12 \right>$ 时，即有 $p_6 = 2$，$p_{12} = 6$，两条红色链两侧的点和边全部删除，并添加红色边，得到的即是这个区间中的笛卡尔树。

首先有区间的笛卡尔树的根节点应该是这两个点在原笛卡尔树上的 LCA，只不过在这个例子中恰好是根。

可以发现点 $8$ 即是点 $2$ 祖先中第一个往“右”走的点，而点 $15$ 也是点 $8$ 的祖先中第一个往“右”走的点。右边的 $6 \to 13 \to 15$ 同理，只不过左右交换了。

也就是说，区间 $[l, r]$ 的笛卡尔树的“左链”和“右链”由这种方式确定，而中间的子树没有改动。

令 $z = \mathrm{lca}(l, r)$，则答案为 $\max(F(l, z-1), F(z+1, r)) + w_z$。也就是将式子展开一层，左右两边分开考虑，最后再合起来。

以左侧的 $F(l, z-1)$ 为例，它也就是 $z$ 的左子树（但是其“左链”由 $l$ 用刚刚的方式确定）。

考虑使用倍增，从 $l$ 通过红色边不断尝试向上跳 $2^j$ 步到达 $z$，并统计这之间产生的贡献。

**注意：这里说的祖先都是不断通过红色边上升到达的点，而不是原笛卡尔树的祖先。**  
**红色边：$\boldsymbol u$ 通过红色边的父亲即是 $\boldsymbol u$ 在原笛卡尔树的祖先链中，最深的往“右”走（即上一个点是它的左孩子）的点，如果不存在这样的点则没有通过红色边的父亲（在原笛卡尔树的“右链”上才可能没有父亲）。**

首先预处理 $f(u, j)$ 表示 $u$ 的最近 $2^j$ 个祖先（包含 $u$）的 $w$ 之和，以及 $g(u, j)$ 表示 $u$ 的 $2^j - 1$ 次祖先的子树（**删去 $\boldsymbol u$ 之前的点**）内的答案（但强制不能往 $u$ 的左子树走，即使 $u$ 的左子树确实是空的，这是因为合并答案时需要接在上面，而答案有可能是负的，会影响计算）。

上述预处理不难合并，具体可以看代码。

查询的时候也是同理，从 $l$ 往上，令 $j$ 从大到小不断尝试能否跳到 $z$ 或比 $z$ 深的节点，能跳就跳并更新答案。

对 $F(z+1, r)$，即 $z$ 的右子树也是同理，只不过要把方向反一下，这里不再赘述。

~~总结：不需要用到任何数据结构，仅需掌握笛卡尔树和倍增的知识点，实乃小清新树上问题（大雾）~~

总结：注意卡空间，因为倍增的空间消耗很大，而且很多数组要开 `long long` 类型，不得不合并一些预处理数组，而且还需左右两边分开处理，不占用重复空间才卡过去。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

#define _L_ 0
#define _R_ 1
int lr;

typedef long long LL;
const int MN = 500005, MQ = 500005;

int N, Q, root, A[MN], V[MN];

int dep[MN], lc[MN], rc[MN], faz[MN][19];
LL S[MN], _chain[MN][19], _subt[MN][19];
void DFS0(int u) {
	for (int j = 0; j < 18 && faz[u][j]; ++j) faz[u][j + 1] = faz[faz[u][j]][j];
	if (lc[u]) dep[lc[u]] = dep[u] + 1, DFS0(lc[u]);
	if (rc[u]) dep[rc[u]] = dep[u] + 1, DFS0(rc[u]);
	S[u] = std::max(S[lc[u]], S[rc[u]]) + V[u];
}
void Init() {
	static int stk[MN]; int tp = 0, x;
	for (int i = 1; i <= N; ++i) {
		x = 0;
		while (tp && A[stk[tp]] < A[i]) {
			if (x) rc[stk[tp]] = x, faz[x][0] = stk[tp];
			x = stk[tp], --tp;
		}
		if (x) lc[i] = x, faz[x][0] = i;
		stk[++tp] = i;
	}
	x = 0;
	while (tp) {
		if (x) rc[stk[tp]] = x, faz[x][0] = stk[tp];
		x = stk[tp], --tp;
	}
	dep[x] = 1, DFS0(x);
	root = x;
}

inline int lca(int u, int v) {
	if (dep[u] < dep[v]) std::swap(u, v);
	for (int d = dep[u] - dep[v], j = 0; d; d >>= 1, ++j)
		if (d & 1) u = faz[u][j];
	if (u == v) return u;
	for (int j = 18; j >= 0; --j)
		if (faz[u][j] != faz[v][j])
			u = faz[u][j],
			v = faz[v][j];
	return faz[u][0];
}

void DFS1(int u) {
	_chain[u][0] = V[u];
	if (lr == _L_) _subt[u][0] = S[lc[u]] + V[u];
	if (lr == _R_) _subt[u][0] = S[rc[u]] + V[u];
	for (int j = 0; j < 18; ++j) {
		faz[u][j + 1] = faz[faz[u][j]][j];
		if (!faz[u][j + 1]) break;
		_chain[u][j + 1] = _chain[u][j] + _chain[faz[u][j]][j];
		_subt[u][j + 1] = std::max(_chain[faz[u][j]][j] + _subt[u][j], _subt[faz[u][j]][j]);
	}
	if (lc[u]) {
		if (lr == _L_) faz[lc[u]][0] = faz[u][0];
		if (lr == _R_) faz[lc[u]][0] = u;
		DFS1(lc[u]);
	}
	if (rc[u]) {
		if (lr == _L_) faz[rc[u]][0] = u;
		if (lr == _R_) faz[rc[u]][0] = faz[u][0];
		DFS1(rc[u]);
	}
}

inline LL calc(int u, int z) {
	LL val = 0;
	for (int j = 18; j >= 0; --j)
		if (dep[faz[u][j]] >= dep[z]) {
			val = std::max(val + _chain[u][j], _subt[u][j]);
			u = faz[u][j];
		}
	return val;
}

int ql[MQ], qr[MQ], qz[MQ];
LL Ans[MQ];

int main() {
	scanf("%d%d", &N, &Q);
	for (int i = 1; i <= N; ++i) scanf("%d", &A[i]);
	for (int i = 1; i <= N; ++i) scanf("%d", &V[i]);
	Init();
	for (int i = 1; i <= Q; ++i) {
		scanf("%d%d", &ql[i], &qr[i]), qz[i] = lca(ql[i], qr[i]);
		Ans[i] = -0x3f3f3f3f3f3f3f3f;
	}
	memset(faz, 0, sizeof faz), lr = _R_, DFS1(root);
	for (int i = 1; i <= Q; ++i) Ans[i] = std::max(Ans[i], calc(ql[i], qz[i]) + V[qz[i]]);
	memset(faz, 0, sizeof faz), lr = _L_, DFS1(root);
	for (int i = 1; i <= Q; ++i) Ans[i] = std::max(Ans[i], calc(qr[i], qz[i]) + V[qz[i]]);
	for (int i = 1; i <= Q; ++i) printf("%lld\n", ql[i] <= qr[i] ? Ans[i] : 0ll);
	return 0;
}
```

---

## 作者：feecle6418 (赞：9)

~~我觉得这题是搬的 IOI2018 Meetings，但当时审核的洛谷管理员并没有看出来。~~

考虑沿用那题的做法，拆开一层 $f$，只需要求 $f(l,m-1)$，右边是对称的。

建出大根笛卡尔树，形如 $[l,m-1]$ 总满足：右端点是某个点的子树中最右边的点。

考虑对于每个子树 $[L,R]$ 的最右边的点 $R$，维护它到所有子树内的点的 $f$ 值 $f(i,R)\ (i\in [L,R])$。

在从下一层 $f$ 上推至这一层 $f$ 的过程中，

- 右儿子的 $f$ 可以直接继承。
- 左儿子的 $f$ 的变化，相当于先对 $f(L,m-1)$ 取 max，再加上 $w_m$。

显然可以线段树维护，$O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,a[500005],w[500005],st[500005],top,c[500005][2],p[500005][20];
int d[500005],P[500005],L[500005],R[500005];
ll ans[500005];
struct Tg{
	ll x,y;
}tag[2000005];//w->max(w+x,y)
vector<int> q[500005];
//w->max(w+x.x,x.y)->max(max(w+x.x,x.y)+y.x,y.y)
Tg operator +(Tg x,Tg y){
	return {x.x+y.x,max(x.y+y.x,y.y)};
}
void Tag(int p,Tg z){
	tag[p]=tag[p]+z;
}
void Pushdown(int p){
	Tag(p*2,tag[p]),Tag(p*2+1,tag[p]),tag[p]={0,-(1ll<<60)};
}
void Apply(int p,int l,int r,int x,int y,Tg z){
	if(x<=l&&r<=y)return Tag(p,z),void();
	Pushdown(p);
	int mid=(l+r)/2;
	if(x<=mid)Apply(p*2,l,mid,x,y,z);
	if(mid<y)Apply(p*2+1,mid+1,r,x,y,z);
}
ll Get(int p,int l,int r,int x){
	if(l==r)return max(tag[p].x,tag[p].y);
	Pushdown(p);
	int mid=(l+r)/2;
	if(x>mid)return Get(p*2+1,mid+1,r,x);
	else return Get(p*2,l,mid,x);
}
void dfs(int x,int f){
	p[x][0]=f,d[x]=d[f]+1;
	for(int i=1;i<=18;i++)p[x][i]=p[p[x][i-1]][i-1];
	if(c[x][0])dfs(c[x][0],x);
	if(c[x][1])dfs(c[x][1],x);
}
int LCA(int x,int y){
	if(d[x]<d[y])swap(x,y);
	for(int i=18;i>=0;i--)if(d[p[x][i]]>=d[y])x=p[x][i];
	if(x==y)return x;
	for(int i=18;i>=0;i--)if(p[x][i]^p[y][i])x=p[x][i],y=p[y][i];
	return p[x][0];
}
void dfs2(int x,int l,int r){
	if(c[x][0])dfs2(c[x][0],l,x-1);
	ll T=0;
	if(c[x][0])T=Get(1,1,n,x-1);
	if(c[x][1]){
		dfs2(c[x][1],x+1,r);
		Apply(1,1,n,x+1,r,{w[x],T+w[x]});
	}
	Apply(1,1,n,x,x,{max(0ll,T)+w[x],-(1ll<<60)});
	for(int i:q[x])ans[i]=max(ans[i],Get(1,1,n,R[i])+w[P[i]]);
}
int main() {
	cin>>n>>m;
	for(int i=1;i<=4*n;i++)tag[i]={0,-(1ll<<60)};
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		while(top&&a[st[top]]<a[i])top--;
		int p=st[top];
		c[i][0]=c[p][1],c[p][1]=i,st[++top]=i;
	}
	dfs(st[1],0);
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&L[i],&R[i]),P[i]=LCA(L[i],R[i]),ans[i]=-1e18;
		if(P[i]!=R[i])q[c[P[i]][1]].push_back(i);
		else ans[i]=max(ans[i],(ll)w[R[i]]);
	}
	dfs2(st[1],1,n),top=0;
	for(int i=0;i<=n;i++)q[i].clear(),c[i][0]=c[i][1]=0,memset(p[i],0,sizeof(p[i])),d[i]=0;
	for(int i=1;i<=4*n;i++)tag[i]={0,-(1ll<<60)};
	reverse(a+1,a+n+1),reverse(w+1,w+n+1);
	for(int i=1;i<=n;i++){
		while(top&&a[st[top]]<a[i])top--;
		int p=st[top];
		c[i][0]=c[p][1],c[p][1]=i,st[++top]=i;
	}
	for(int i=1;i<=m;i++){
		L[i]=n-L[i]+1,R[i]=n-R[i]+1,swap(L[i],R[i]),P[i]=n-P[i]+1;
		if(P[i]!=R[i])q[c[P[i]][1]].push_back(i);
		else ans[i]=max(ans[i],(ll)w[R[i]]);
	}
	dfs2(st[1],1,n);
	for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';
}
```

---

## 作者：加藤惠 (赞：7)

考虑对原序列建出笛卡尔树，每次询问相当于把从 $l$ 爬到 lca 的路径上是从左儿子爬到父亲的节点和那个节点的右子树以及从 $r$ 爬到 lca 的路径上是从右儿子爬到父亲的节点和那个节点的左子树抠出来，然后按题面给的转移 dp 一下。

先处理出以每个点 $i$ 为根的子树的 dp 值，再考虑离线处理，把 $l$ 爬到 lca 和 $r$ 爬到 lca 的两部分分开算，最后再合并。

dfs 笛卡尔树，开两个栈分别记录从父亲到左儿子，从父亲到右儿子，每次询问就相当于询问栈一个后缀的简单的 dp，dp 的转移长这样 $dp_i=max(dp_{i+1},b_i)+w_i$，$b_i$ 为右子树或者左子树一开始预处理的$dp$值。

这是一个可以 ddp 的形式，所以我们只要用线段树维护一下就行了。

复杂度 $O(n \log n)$，常数较大，可以通过本题。

但其实上述做法其实非常的愚蠢。

依然考虑对原序列建出笛卡尔树，上面做法可以看成是从下往上做，现在我们考虑从上往下做，设 $g_i$ 为笛卡尔树上 $i$ 到 root 的路径上的点权和，求 $F(l,r)$ 的值转化为求 $\max\limits_{i=l}^{r}$ $g_i$减去 $i$ 到根中不在 $[l,r]$ 内的点的点权，$l$ 和 $r$ 的 lca 左子树和右子树依旧分开算，接下来以处理左子树为例，右子树同理。

dfs 笛卡尔树，设当前点为 $u$，先把 $u$ 的右子树里的点减去 $u$ 的点权（右子树内的询问的区间显然是不包含 $u$ 的），然后先 dfs 到右子树，dfs 左子树之前再把 $u$ 的右子树里的点加上 $u$ 的点权（左子树内的询问区间是肯定是包含 $u$ 和 $u$ 的右子树内的所有点的），再 dfs 左子树，询问则是相当于询问 $[l,lca-1]$ 区间的 $\max$，线段树维护即可，复杂度 $O(n \log n)$，常数较小。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define uint unsigned
#define ull unsigned ll
#define pii pair<int,int>
#define pll pair<ll,ll>
#define PB push_back
#define fi first
#define se second
#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)
#define CLR(a,v) memset(a,v,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(a))
#define y1 fdhjksa
using namespace std;
const int N=500005;
int n,Q,a[N],v[N];
int ls[N],rs[N],q[N];
int st[N],ed[N],dep[N];
ll g[N],G[N];
void dfs(int x,int fa){
	st[x]=ed[x]=x,g[x]=g[fa]+v[x],dep[x]=dep[fa]+1;
	if (ls[x]) dfs(ls[x],x),st[x]=st[ls[x]];
	if (rs[x]) dfs(rs[x],x),ed[x]=ed[rs[x]];
}
void build_tree(){
	int top=0;
	For(i,1,n){
		for (;top&&a[q[top]]<a[i];--top){
			rs[q[top]]=ls[i];
			ls[i]=q[top];
		}
		if (top)
			rs[q[top]]=i;
		q[++top]=i;
	}
	dfs(q[1],0);
	For(i,1,n){
		G[i]=g[i];
		if (ls[i]&&rs[i]) g[i]=-1e15;
	}
}
struct TREE1{
	int t[N*4],nn;
	int Mx(int x,int y){
		return a[x]>a[y]?x:y;
	}
	void build(int n){
		for (nn=1;nn<n+1;nn<<=1);
		For(i,1,n) t[i+nn]=i;
		Rep(i,nn-1,1) t[i]=Mx(t[i*2],t[i*2+1]);
	}
	int ask(int l,int r){
		l+=nn-1; r+=nn+1;
		int ans=0;
		for (;l^r^1;l>>=1,r>>=1){
			if (!(l&1)) ans=Mx(ans,t[l^1]);
			if (r&1) ans=Mx(ans,t[r^1]);
		}
		return ans;
	}
}T1;
struct TREE2{
	ll mx[N*4],tg[N*4];
	void build(int k,int l,int r){
		tg[k]=0;
		if (l==r) return mx[k]=g[l],void(0);
		int mid=(l+r)/2;
		build(k*2,l,mid);
		build(k*2+1,mid+1,r);
		mx[k]=max(mx[k*2],mx[k*2+1]);
	}
	void change(int k,int l,int r,int x,int y,ll v){ 
		if (l==x&&r==y){
			tg[k]+=v;
			mx[k]+=v;
			return;
		}
		int mid=(l+r)/2;
		if (y<=mid) change(k*2,l,mid,x,y,v);
		else if (x>mid) change(k*2+1,mid+1,r,x,y,v);
		else{
			change(k*2,l,mid,x,mid,v);
			change(k*2+1,mid+1,r,mid+1,y,v);
		}
		mx[k]=max(mx[k*2],mx[k*2+1])+tg[k];
	}
	ll ask(int k,int l,int r,int x,int y){
		if (l==x&&r==y) return mx[k];
		int mid=(l+r)/2;
		if (y<=mid) return ask(k*2,l,mid,x,y)+tg[k];
		if (x>mid) return ask(k*2+1,mid+1,r,x,y)+tg[k];
		return max(ask(k*2,l,mid,x,mid),ask(k*2+1,mid+1,r,mid+1,y))+tg[k];
	}
}T2;
vector<pii> vec1[N];
vector<pii> vec2[N];
ll ans[N],ansl[N],ansr[N],pre[N];
inline void dfs2(int u){
	if (ls[u]&&rs[u]) T2.change(1,1,n,u,u,1e15+G[u]);
	for (auto tmp:vec2[u]) ansr[tmp.se]=T2.ask(1,1,n,tmp.fi+1,u)-pre[dep[tmp.fi]];
	if (ls[u]&&rs[u]) T2.change(1,1,n,u,u,-1e15-G[u]);
	if (ls[u]) T2.change(1,1,n,st[ls[u]],ed[ls[u]],-v[u]);
	if (ls[u]) pre[dep[u]]=pre[dep[u]-1],dfs2(ls[u]);
	if (ls[u]) T2.change(1,1,n,st[ls[u]],ed[ls[u]],v[u]);
	if (rs[u]) pre[dep[u]]=pre[dep[u]-1]+v[u],dfs2(rs[u]);
}
inline void dfs1(int u){
	if (rs[u]&&ls[u]) T2.change(1,1,n,u,u,1e15+G[u]);
	for (auto tmp:vec1[u]) ansl[tmp.se]=T2.ask(1,1,n,u,tmp.fi-1)-pre[dep[tmp.fi]];
	if (rs[u]&&ls[u]) T2.change(1,1,n,u,u,-1e15-G[u]);
	if (rs[u]) T2.change(1,1,n,st[rs[u]],ed[rs[u]],-v[u]);
	if (rs[u]) pre[dep[u]]=pre[dep[u]-1],dfs1(rs[u]);
	if (rs[u]) T2.change(1,1,n,st[rs[u]],ed[rs[u]],v[u]); 
	if (ls[u]) pre[dep[u]]=pre[dep[u]-1]+v[u],dfs1(ls[u]);
}
int main(){
	scanf("%d%d",&n,&Q);
	For(i,1,n) scanf("%d",&a[i]);
	For(i,1,n) scanf("%d",&v[i]);
	build_tree();
	T1.build(n);
	For(i,1,Q){
		int l,r;
		scanf("%d%d",&l,&r);
		int m=T1.ask(l,r);
		if (m!=l) vec1[l].PB(pii(m,i));
		if (m!=r) vec2[r].PB(pii(m,i));
		ans[i]=v[m];
	}
	T2.build(1,1,n),dfs1(q[1]);
	T2.build(1,1,n),dfs2(q[1]);
	For(i,1,Q) printf("%lld\n",ans[i]+max(ansl[i],ansr[i]));
}
```

---

## 作者：皎月半洒花 (赞：4)

sto 兔，尝试解释的更详细一点。

大概是比较神的题？首先如果考虑是 $F(1,n)$，那么转移就是一个笛卡尔树的形式。然后如果放到区间里来，可以发现可能会存在从 $l$、$r$ 到根的链被修改，中间的链不会被改变。

而这个被修改成的模样大概是要稍微找一下性质。可以发现对于 $l$ 而言，首先他的左子树会被砍掉，其次考虑对笛卡尔树的父子关系分类，称 ${\rm Lson}(x)=y$ 的父子关系 $(y,x)$ ，其中 $x$ 是 $y$ 的右行父亲，${\rm Rson}(x)=y$ 的则为左行父亲。那么不难看出，对于 $l\to root$ 这条链上，任何一个键值(下标)比 $l$ 小的都需要被删掉，也就是所有右行父亲都要被删掉；同理对于 $r\to root$ 这条脸上，所有左行父亲需要被删掉。

发现询问可以离线，于是考虑拆成两半做。这个地方需要一个神奇的 Observation。观察 $F$ 在笛卡尔树上的展开式：

$$
\begin{aligned}
F(l, r)& = \max\{F(l, m - 1), F(m + 1, r)\} + w_m \\
&= \max\{\max \{~F(l, m_1), F(m_1+1,m - 1)~\} + w_{m_1}, \max \{~F(m+1, m_2), F(m_2+1,r)~\} +w_{m_2} \} + w_m\\
& \cdots
\end{aligned}
$$

不难发现 $m_k$ 只会与对应节点有关，同时 $\max$ 有结合律，整个式子都被 $\max$ 包住了，于是就可以直接倍增。

具体的，考虑设 $g_{x,k}$ 表示 $x$ 的 $2^{k-1}$ 祖先的**内向子树**的贡献和，$f_{x,k}$ 表示从 $x$ 到 $x$ 的 $2^{k-1}$ 祖先的点权和，$fa_{x,k}$ 表示对一个固定的方向，即不考虑「左行」或者「右行」父亲时的父亲。那么预处理时 $f_{x,k}$ 较容易维护，考虑 $g_{x,k}$ ，发现倍增是需要考虑分成两个 $2^{k-1}$ 规模的子问题去计算，也就是此时需要分别计算 $2^{k-1}$ 级祖先上面的和下面的贡献，拼一下的话比较直观。

然后就可以考虑如何计算答案。发现由于上文提到过的结合律，可以发现只需要比较链上的答案和子树内的答案的 $\max$ 就好了。

---

## 作者：zyn0309 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5654)

没看懂另外几篇题解，写个比较暴力的做法。

看到 $F(l,r)$ 的定义中有 $\max$，考虑建出排列 $p$ 的大根笛卡尔树，查询 $F(l,r)$ 需要知道 $F(l,m-1)$ 和 $F(m+1,r)$，容易发现这个就是笛卡尔树上一个结点左子树的后缀 $F$ 值和右子树前缀 $F$ 值，因此可以考虑在笛卡尔树上的每个结点维护前缀和后缀的 $F$ 值。

观察一下 $F$ 的式子。

$$ F(l, r) = \begin{cases} \max(F(l, m - 1), F(m + 1, r)) + w_m & , l \le r \\ 0 & , l > r \end{cases} $$

以维护后缀为例，发现把 $F(i,m-1)$ 变为 $F(i,r)$ 就是把它变成 $\max(F(i,m-1)+w_m,F(m+1,r)+w_m)$，维护前缀同理。

发现需要支持区间加，区间对一个数取 $\max$，单点查值，上两个线段树合并，一个维护前缀，一个维护后缀即可。

### Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace fast_IO{
	#define IOSIZE 100000
		char ibuf[IOSIZE], obuf[IOSIZE], *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
	#define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
	#define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
	#define isdigit(ch) (ch>47&&ch<58)
	#define isspace(ch) (ch<33)
		template<typename T> inline T read() { T s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s * w;}
		template<typename T> inline bool read(T &s) { s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s *= w, true;}
		template<typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; if (x > 9) print(x / 10); putchar(x % 10 + 48);}
		inline bool read(char &s) { while (s = getchar(), isspace(s)); return true; }
		inline bool read(char *s) { char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) *s++ = ch, ch = getchar(); *s = '\000'; return true;}
		inline void print(char x) { putchar(x); }
		inline void print(char *x) { while (*x) putchar(*x++); }
		inline void print(const char *x) { for (int i = 0; x[i]; i++) putchar(x[i]); }
		inline bool read(std::string& s) { s = ""; char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) s += ch, ch = getchar(); return true;}
		inline void print(std::string x) { for (int i = 0, n = x.size(); i < n; i++) putchar(x[i]);}
		inline bool read(bool &b) { char ch; while(ch=getchar(), isspace(ch)); b=ch^48; return true;}
		inline void print(bool b) { putchar(b+48);}
		template<typename T, typename... T1> inline int read(T& a, T1&... other) { return read(a) + read(other...);}
		template<typename T, typename... T1> inline void print(T a, T1... other) { print(a), print(other...);}
		struct Fast_IO { ~Fast_IO() { fwrite(obuf, p3 - obuf, 1, stdout);}} io;
		template<typename T> Fast_IO& operator >> (Fast_IO &io, T &b) { return read(b), io;}
		template<typename T> Fast_IO& operator << (Fast_IO &io, T b) { return print(b), io;}
	#define cout io
	#define cin io
}using namespace fast_IO;
const int N=5e5+10,inf=2e9;
int n,m,w[N],p[N],tot,rt,cnt;
ll ans[N];
struct sgt{
	int lson,rson,ma;
}t2[2*N];
inline void build(int &u,int l,int r){
	u=++cnt;
	if(l==r){
	  t2[u].ma=l;
	  return;
	}
	int mid=(l+r)>>1;
	build(t2[u].lson,l,mid);
	build(t2[u].rson,mid+1,r);
	if(p[t2[t2[u].lson].ma]>p[t2[t2[u].rson].ma])t2[u].ma=t2[t2[u].lson].ma;
	else t2[u].ma=t2[t2[u].rson].ma;
}
inline int query(int u,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr)return t2[u].ma;
	int mid=(l+r)>>1;
	if(qr<=mid)return query(t2[u].lson,l,mid,ql,qr);
	else if(ql>mid)return query(t2[u].rson,mid+1,r,ql,qr);
	else{
	  int v1=query(t2[u].lson,l,mid,ql,qr),v2=query(t2[u].rson,mid+1,r,ql,qr);
	  return (p[v1]>p[v2])?v1:v2;
	}
}
vector<int>rub;
struct tree{
	int lson,rson;
	ll ma,lazy,lazy2;
}t[38*N];
inline int New(){
	if(!rub.size())return ++tot;
	else{
	  int x=rub[rub.size()-1];
	  rub.pop_back();
	  return x;
	}
}
inline void work(int u,ll val){
	t[u].ma+=val;
	t[u].lazy+=val;
	if(t[u].lazy2!=inf)t[u].lazy2+=val;
}
inline void work2(int u,ll val){
	if(t[u].lazy2!=inf)t[u].lazy2=max(t[u].lazy2,val);
	else t[u].lazy2=val;
	t[u].ma=max(t[u].ma,val);
}
inline void push_down(int u){
	if(t[u].lson)work(t[u].lson,t[u].lazy);
	if(t[u].rson)work(t[u].rson,t[u].lazy);
	t[u].lazy=0;
	if(t[u].lson&&t[u].lazy2!=inf)work2(t[u].lson,t[u].lazy2);
	if(t[u].rson&&t[u].lazy2!=inf)work2(t[u].rson,t[u].lazy2);
	t[u].lazy2=inf;
}
inline void push_up(int u){
	t[u].ma=max(t[t[u].lson].ma,t[t[u].rson].ma);
}
inline void update2(int &u,int l,int r,int ql,int qr,ll val){
	if(ql>qr||ql<1||qr>n)return;
	if(!u){
	  u=New();
	  t[u].lazy2=inf;
	}
	if(ql<=l&&r<=qr){
	  work2(u,val);
	  return;
	}
	push_down(u);
	int mid=(l+r)>>1;
	if(ql<=mid)update2(t[u].lson,l,mid,ql,qr,val);
	if(qr>mid)update2(t[u].rson,mid+1,r,ql,qr,val);
	push_up(u);
}
inline void update(int &u,int l,int r,int ql,int qr,ll val){
	if(ql>qr||ql<1||qr>n)return;
	if(!u){
	  u=New();
	  t[u].lazy2=inf;
	}
	if(ql<=l&&r<=qr){
	  work(u,val);
	  return;
	}
	push_down(u);
	int mid=(l+r)>>1;
	if(ql<=mid)update(t[u].lson,l,mid,ql,qr,val);
	if(qr>mid)update(t[u].rson,mid+1,r,ql,qr,val);
	push_up(u);
}
inline ll query_tree(int u,int l,int r,int x){
	if(x<1||x>n)return -1e18;
	if(l==r)return t[u].ma;
	push_down(u);
	int mid=(l+r)>>1;
	if(x<=mid)return query_tree(t[u].lson,l,mid,x);
	else return query_tree(t[u].rson,mid+1,r,x);
}
#define pb push_back
#define pii  pair<int,int> 
#define mk make_pair
inline int merge(int a,int b){
	if(!a||!b)return a|b;
	push_down(a),push_down(b);
	t[a].ma=max(t[a].ma,t[b].ma);
	t[a].lson=merge(t[a].lson,t[b].lson);
	t[a].rson=merge(t[a].rson,t[b].rson);
	rub.pb(b);
	t[b].lson=t[b].rson=t[b].lazy=t[b].lazy2=t[b].ma=0;
	return a;
}
struct node{
	int l,r,id;
};
vector<node>v[N];
inline pii solve(int l,int r){
	if(l>r)return mk(0,0);
	int pos=query(rt,1,n,l,r);
	pii lson=solve(l,pos-1),rson=solve(pos+1,r);
	int root1=0,root2=0;
	for(node p:v[pos])ans[p.id]=max(query_tree(lson.second,1,n,p.l),query_tree(rson.first,1,n,p.r))+w[pos];

	if(l==1&&r==n)return mk(0,0);

	update(root2,1,n,pos,pos,w[pos]+max(0ll,query_tree(rson.second,1,n,pos+1)));
	if(lson.second)update2(lson.second,1,n,l,pos-1,query_tree(rson.second,1,n,pos+1));
	if(lson.second)update(lson.second,1,n,l,pos-1,w[pos]);
	root2=merge(merge(lson.second,rson.second),root2);

	update(root1,1,n,pos,pos,w[pos]+max(0ll,query_tree(lson.first,1,n,pos-1)));
	if(rson.first)update2(rson.first,1,n,pos+1,r,query_tree(lson.first,1,n,pos-1));
	if(rson.first)update(rson.first,1,n,pos+1,r,w[pos]);
	root1=merge(merge(lson.first,rson.first),root1);

	return mk(root1,root2);
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>p[i];
	for(int i=1;i<=n;++i)cin>>w[i];
	build(rt,1,n);
	int l,r;
	for(int i=1;i<=m;++i){
	  cin>>l>>r;
	  v[query(rt,1,n,l,r)].pb({l,r,i});
	}
	solve(1,n);
	for(int i=1;i<=m;++i)cout<<ans[i]<<"\n";
	return 0;
}
```

---


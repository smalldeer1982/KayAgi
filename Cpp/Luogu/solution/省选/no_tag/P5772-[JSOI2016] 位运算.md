# [JSOI2016] 位运算

## 题目描述

JYY 最近在研究位运算。他发现位运算中最有趣的就是异或 (xor) 运算。对于两个数的异或运算，JYY 发现了一个结论：两个数的异或值为 $0$ 当且仅当他们相等。于是 JYY 又开始思考，对于 $N$ 个数的异或值会有什么性质呢？

JYY 想知道，如果在 $0$ 到 $R-1$ 的范围内，选出 $N$ 个不同的整数，并使得这 $N$ 个整数的异或值为 $0$，那么一共有多少种选择的方法呢？（选择的不同次序并不作重复统计，请参见样例）

JYY 是一个计算机科学家，所以他脑海里的 $R$ 非常非常大。为了能够方便的表达，如果我们将 $R$ 写成一个 $01$ 串，那么 $R$ 是由一个较短的 $01$ 串 $S$ 重复 $K$ 次得到的。比如，若 $S=101$，$K=2$，那么 $R$ 的二进制表示则为 $101101$。由于计算的结果会非常大，JYY 只需要你告诉他选择的总数对 $10^9+7$ 取模的结果即可。

## 说明/提示

**样例说明**

唯一的一种选择方法是选择 $\{1,2,3\}$。

------

**数据范围**

对于 $100\%$ 的数据，$3 \le N \le 7$，$1 \le k \le 10^5$，$1 \le |S| \le 50$。

## 样例 #1

### 输入

```
3 1
100```

### 输出

```
1```

# 题解

## 作者：duyi (赞：13)

# 强烈推荐，戳此↓，看看我的博客

[更好的阅读体验](https://www.cnblogs.com/dysyn1314/p/13227188.html)

## 题目大意

[题目链接](https://loj.ac/problem/2075)

给定两个整数$n$, $k$和一个01串$S$。我们设$R$是一个二进制数，它的二进制表示，就是$S$重复$k$次。请你选出$n$个不同的、小于$R$的非负整数（也就是值在$[0,R-1]$之间），使得它们的异或和为$0$。

数据范围：$3\leq n\leq 7,1\leq k\leq 10^5,1\leq |S|\leq 50$。

## 本题题解

假设我们已经知道了$R$（也就是把$S$重复$k$次大力展开），该怎么做？设选出的这$n$个数为$x_1,x_2,\dots,x_n$。为了保证这$n$个数互不相同且都小于$R$，不妨设$R>x_1>x_2>\dots >x_n$。不妨设$x_0=R$。

因为$n$很小，考虑状压DP。设$dp[i][\text{mask}]$表示考虑了$R$的前$i$位（从高到低）；$\text{mask}$是一个长度为$n$的二进制数，对于第$j$个位置 ($1\leq j\leq n$)，如果当前（只考虑数的前$i$位）$x_j=x_{j-1}$，则$\text{mask}$第$j$位为$1$，否则$\text{mask}$第$j$位为$0$。转移时，枚举$x_1\dots x_n$的第$i$位分别填什么，这样可以计算出新的$\text{mask}'$。令$dp[i][\text{mask}']\texttt{+=}dp[i-1][\text{mask}]$即可。

这个DP的时间复杂度是$O(|R|\cdot (2^n)^2\cdot n)=O(k\cdot |S|\cdot 2^{2n}\cdot n)$的，无法通过本题。

发现上面的这个DP，没有用到“$R$是由一个非常短的串$S$，重复$k$次得来的”，这一特殊条件。我们发现，在$S$的$k$次重复中，每一次的转移其实都是一样的。那么就容易想到做**矩阵快速幂**。

那么关键就是要求出转移矩阵：$\text{trans}[\text{mask}_1][\text{mask}_2]$表示从$dp[x\cdot|S|][\text{mask}_1]$转移到$dp[(x+1)\cdot|S|][\text{mask}_2]$的系数 ($0\leq x<k$)。可以枚举$\text{mask}_1$，令$dp[0][\text{mask}_1]=1$，然后对$S$做一遍上面的那个DP，就可以对所有$\text{mask}_2$求出$\text{trans}[\text{mask}_1][\text{mask}_2]$了。这部分时间复杂度$O(|S|\cdot 2^{3n}\cdot n)$。可以承受。

然后就对这个大小为$2^n\times 2^n$的矩阵做矩阵快速幂即可。这部分时间复杂度$O(2^{3n}\log k)$。

总时间复杂度$O(|S|\cdot 2^{3n}\cdot n+2^{3n}\log k)$。

参考代码：

```cpp
//problem:LOJ2075
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

const int MOD=1e9+7;
inline int mod1(int x){return x<MOD?x:x-MOD;}
inline int mod2(int x){return x<0?x+MOD:x;}
inline void add(int& x,int y){x=mod1(x+y);}
inline void sub(int& x,int y){x=mod2(x-y);}
inline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}

const int MAXN=7,MAXK=1e5,MAXS=50;
const int SIZE2=1<<MAXN;
int n,K,len,bitcnt[SIZE2],dp[MAXS+5][SIZE2];
char s[MAXS+5];
struct Matrix{
	int a[SIZE2][SIZE2],sz;
	Matrix(){
		memset(a,0,sizeof(a));
		sz=0;
	}
};
Matrix operator*(const Matrix& X,const Matrix& Y){
	Matrix Z;
	assert(X.sz==Y.sz);
	Z.sz=X.sz;
	for(int i=0;i<=X.sz;++i){
		for(int j=0;j<=X.sz;++j){
			for(int k=0;k<=X.sz;++k){
				add(Z.a[i][j],(ll)X.a[i][k]*Y.a[k][j]%MOD);
			}
		}
	}
	return Z;
}
Matrix mat_pow(Matrix X,int i){
	Matrix Y;
	Y.sz=X.sz;
	for(int j=0;j<=X.sz;++j)Y.a[j][j]=1;
	while(i){
		if(i&1)Y=Y*X;
		X=X*X;
		i>>=1;
	}
	return Y;
}

int main() {
	cin>>n>>K;
	cin>>(s+1);len=strlen(s+1);
	int sz=(1<<n)-1;
	for(int i=1;i<=sz;++i)bitcnt[i]=bitcnt[i>>1]+(i&1);
	Matrix trans;
	trans.sz=sz;
	for(int st=0;st<=sz;++st){
		memset(dp,0,sizeof(dp));
		dp[0][st]=1;
		for(int i=1;i<=len;++i){
			for(int j=0;j<=sz;++j)if(dp[i-1][j]){
				for(int k=0;k<=sz;++k)if(bitcnt[k]%2==0){
					static int curs[MAXN+5];
					curs[0]=s[i]-'0';
					for(int l=1;l<=n;++l)curs[l]=((k>>(l-1))&1);
					bool fail=false;
					int newj=0;
					for(int l=1;l<=n;++l){
						if((j>>(l-1))&1){
							//之前是等于的
							if(curs[l]>curs[l-1]){fail=1;break;}
							if(curs[l]==curs[l-1])newj|=(1<<(l-1));
						}
					}
					if(fail)continue;
					add(dp[i][newj],dp[i-1][j]);
				}
			}
		}
		for(int ed=0;ed<=sz;++ed){
			trans.a[st][ed]=dp[len][ed];
		}
	}
	trans=mat_pow(trans,K);
	Matrix res;
	res.a[0][sz]=1;
	res.sz=sz;
	res=res*trans;
	cout<<res.a[0][0]<<endl;
	return 0;
}
```


---

## 作者：nodgd (赞：10)

我看其他几篇题解，复杂度关于 $ n $ 都不是多项式的，所以写了这篇题解。有的题解第一步和我相同但第二步复杂度是贝尔数不是多项式的。这个算法，实测 $ n\leq 200 $ 其他范围不变的情况下还是能过。

### 第一步，先去掉“ $ n $ 个数互不相同”的限制

从高位到低位暴力数位DP，设状态 $ dp_i(0\leq i\leq n) $ 是已经有 $ i $ 个数严格小于 $ R $ 时，高位的方案数。

- $ R $ 的下一位是 $ 0 $ 时，转移 $ dp_i'\leftarrow dp_i $ 的系数只考虑已经严格小于 $ R $ 的这 $ i $ 个数的方案，也就是 $ \begin{cases}1&i=0\\ 2^{i-1}& i>0\end{cases} $ 
- $ R $ 的下一位是 $ 1 $ 时，转移 $ dp_j'\leftarrow dp_i(j\geq i) $ 的系数还得再乘个组合数，也就是 $ C_{n-i}^{n-j} \times \begin{cases} 0 & (n-j)\%2=1\\1&(n-j)\%2=0\\ 2^{i-1}&i>0 \end{cases} $ 

这个转移可以写成矩阵的形式，矩阵规模 $ (n+1)\times (n+1) $ 。 $ R $ 的下一位是 $ 0 $ 时的转移矩阵是 $ B_0 $ ，是 $ 1 $ 时的转移矩阵是 $ B_1 $ 。

于是 $ [1,0,\cdots,0 ]\cdot \left(\displaystyle\prod B_{S_i}\right)^K $ 就是最终的 $ [dp_0,\cdots,dp_n] $ ，答案就是 $ dp_n $ 。

### 第二步，强制互不相同

假设把第一步的算法跑 $ n+1 $ 遍，算出了 $ F_0,F_1,\cdots,F_n $ 。这一步时间复杂度 $ O(n^4\cdot(|S|+\log K)) $ 。

其中 $ F_k $ 表示：长度为 $ k $ 的序列 $ a_1\sim a_k $ ，值域在 $ [0,R-1] $ 范围内，异或和为 $ 0 $ 的方案数。

再设 $ f_k $ 表示：长度为 $ k $ 的序列 $ a_1\sim a_k $ ，值域在 $ [0,R-1] $ 范围内，**每个数互不相同**，异或和为 $ 0 $ 的方案数。

对于 $ F_k $ ，考虑 $ a_1\sim a_k $ 这 $ k $ 个数的相等分组情况。设 $ g_{k,i,j} $ 表示 $ k $ 个数分成 $ i+j $ 组，每组内都相等，任意两组都不相等，有 $ i $ 组包含奇数个数，剩下 $ j $ 包含偶数个数，这样分组的方案数。

显然 $ g_{k,i,j} $ 可以DP计算。考虑 $ a_k $ 所在组的三种情况：单独一组、组的大小为偶数、组的大小为不小于 $ 3 $ 的奇数。于是 $ g_{k,i,j}=g_{k-1,i,j}+g_{k-1,i+1,j-1}\times (i+1)+g_{k-1,i-1,j+1}\times (j+1) $ 。这个DP时间复杂度 $ O(n^3) $ 。

于是 $ F_k=\displaystyle\sum_{i}\sum_j g_{k,i,j}\times f_i\times (R-i)^{\underline{j}} $ 。这个式子很好理解， $ g_{k,i,j} $ 是分组方案数， $ f_i $ 是 $ i $ 个包含奇数个数的组的数值方案数， $ (R-i)^{\underline{j}} $ 是剩下 $ j $ 个包含偶数个数的组的数值方案数。

现在已知 $ F_0\sim F_n $ ，可以直接高斯消元计算 $ f_0\sim f_n $ 。反正高斯消元复杂度 $ O(n^3) $ ，比前面的步骤小所以可以忽略。而且这个公式貌似不方便使用反演之类的方法，如果一定要反演，大概得先把 $ g_{k,i,j} $ 写成通项公式，大概是包含斯特林数和组合数的一坨，然后也不知道该斯特林反演还是二项式反演，说不定可以让这一步的时间复杂度更低一点。

最后，本题的答案就是高斯消元算出来的 $ f_n $ 。

总时间复杂度 $ O(n^4\cdot (|S|+\log K)) $ ，关于 $ n $ 是的《多项式复杂度》的。

因为这个 $ n^4 $ 其实是 $ 1^3+2^3+\cdots+n^3 $ 得到的自带 $ \frac14 $ 常数，涉及的矩阵只有上三角非零所以矩阵乘法再自带 $ \frac 16 $ 的常数，再搭配循环展开之类的方式卡一卡就跑得巨快无比。所以本题大概把 $ n $ 的范围开到 $ 200 $ 其他范围不变，亲测也还能过。




---

## 作者：_Sein (赞：6)

众所周知，异或是按位进行的。

那么不妨这道题也是按位处理。

显然，不能直接处理。

观察到$R$是由多个$S$拼成的，即它的状态可以由多个$S$首尾拼接而成。

考虑矩阵快速幂。

于是仅用处理$S$状态即可。

不妨假设选出来的数满足

$S>x_n>x_{n-1}>x_{n-2}>\ldots>x_1$

因为这样不重不漏。

最后统计答案时，即为这个的方案数。

状压$\text{DP}$状态$f_{i,j}$表示二进制从左往右前$i$位，

$j$从左往右第$k$位表示$x_k,x_{k+1}$的大小，若$x_{k+1}=x_{k}$，则为$1$，否则$x_{k+1}>x_k$为$0$。特别地，$x_{n+1}=S$

转移时枚举前$i-1$位的状态，然后根据这个选出合法的第$i$位状态，然后再进行转移。

特别地，初始状态$f_{0,s}$是为了进行矩阵快速幂而设计的。

矩阵快速幂记录一个头和尾的状态，这个部分可以参照代码。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<vector> 
#define gc getchar()
#define ll long long
#define ull unsigned long long
#define file(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
#define I inline 
#define eps 1e-8
using namespace std;
const int N=(1<<7)+5,mod=1e9+7;
const ull p0=31,p1=37;
template<class o>I void qr(o &x)
{
	char c=gc;int f=1;x=0;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>I void qw(o x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int dp[55][N],n,a[55],c[N];char s1[55];
I int pls(int x,int y){x+=y;return x>=mod?x-mod:x;}
I int get(int l,int r,int i)
{
	int v=0;
	for(int j=1;j<n;j++)if(l>>j&1)
	{
		int y=r>>j&1,z=r>>(j-1)&1;
		if(y>z)return -1;
		if(y==z)v|=1<<j;
	}
	if(l&1)
	{
		int y=r&1;
		if(y>a[i])return -1;
		if(y==a[i])v|=1;
	}
	return v;
}
int h[N][N],limit;
I void mul(int f[N][N],int g[N][N])
{
	for(int i=0;i<limit;i++)
		for(int j=0;j<limit;j++)
			h[i][j]=0;
	for(int i=0;i<limit;i++)
		for(int j=0;j<limit;j++)if(f[i][j])
			for(int k=0;k<limit;k++)
				h[i][k]=pls(h[i][k],(int)(1ll*f[i][j]*g[j][k]%mod));
	for(int i=0;i<limit;i++)
		for(int j=0;j<limit;j++)
			f[i][j]=h[i][j];
}
int f[N][N],g[N][N];
int main()
{
	qr(n);int k;qr(k);scanf("%s",s1+1);int m=strlen(s1+1);
	for(int i=1;i<=m;i++)a[i]=s1[i]^48;limit=1<<n;c[0]=1;
	for(int i=1;i<limit;i++)c[i]=c[i-(i&-i)]^1;
	for(int s=0;s<limit;s++)
	{
		for(int i=0;i<=m;i++)
			for(int j=0;j<limit;j++)
				dp[i][j]=0;
		dp[0][s]=1;
		for(int i=1;i<=m;i++)
			for(int l=0;l<limit;l++)if(dp[i-1][l])
				for(int r=0,j;r<limit;r++)if(c[r]&&(~(j=get(l,r,i))))
					dp[i][j]=pls(dp[i][j],dp[i-1][l]);
		for(int i=0;i<limit;i++)
			f[i][s]=pls(f[i][s],dp[m][i]);
	}
	for(int i=0;i<limit;i++)g[i][i]=1; 
	for(;k;k>>=1,mul(f,f))if(k&1)mul(g,f);
	int ans=0;
	qw(g[0][limit-1]);puts("");
	return 0;
}
```

---

## 作者：Itst (赞：5)

先考虑把限制删掉。假设需要求的是可重、有序方案数，此时可以得到一个数位 DP：设 $f_{i,j}$ 表示考虑了前 $i$ 个二进制位，其中已经有 $j$ 个数满足确定它比 $S$ 小，且前 $i$ 位异或和为 $0$ 的方案数。转移根据第 $i+1$ 位是 $0$ 还是 $1$ 转移。注意到给出的串是一个串重复 $K$ 遍，可以把转移写成矩阵形式轻松使用矩阵快速幂优化至 $O(N^3(|S| + \log K))$。

然后容斥掉不满足条件的解。枚举这 $N$ 个数字的集合划分，其中一个集合内的下标对应数字相等，不同集合中数字不等，那么有 $Bell_N$ 种划分方案。对于任意一种划分方案，因为两个相同的数对异或和的贡献是 $0$，故考虑统计出现了偶数次的数的数量 $c_0$ 和出现奇数次的数的数量 $c_1$，那么最后的异或和就是这 $c_1$ 个数的异或和。

那么满足这种集合划分的方案数就是：选择 $c_1$ 个互不相同的 $<R$ 的数使得异或和为 $0$ 的方案数乘上在 $R - c_1$ 个数中选择 $c_0$ 个数进行排列的方案数。前者是子问题，后者的计算是简单的。

所以只需要把 $0 \sim N$ 的答案从小到大依次求出即可。复杂度 $O(N^4(|S| + \log K) + \sum\limits_{i=0}^N iBell_i)$。

可以在集合划分枚举上更精细实现做到 $O(N^4(|S| + \log K) + \sum\limits_{i=0}^N iD_i)$，其中 $D_i$ 是有限集划分数。但是 $N$ 实在太小了，运行上几乎没有差别。

```
#include<bits/stdc++.h>
using namespace std;

#define sz(x) (int)x.size()
const int P = 1e9 + 7; int N , K , C[8][8] , sval , R; string S;
int inv(int x){int sum = P + 1; while(sum % x) sum += P; return sum / x;}

struct matrix{
	int arr[8][8]; matrix(){memset(arr , 0 , sizeof(arr));} int* operator [](int x){return arr[x];}
	friend matrix operator *(matrix p , matrix q){
		matrix r; for(int i = 0 ; i < 8 ; ++i) for(int j = 0 ; j < 8 ; ++j) for(int k = 0 ; k < 8 ; ++k) r[i][k] = (r[i][k] + 1ll * p[i][j] * q[j][k]) % P;
		return r;
	}
}trs0 , trs1;
int num[8] , val[8];

vector < int > pot;
int choosenum(int x , int y){int tms = 1; for(int i = 1 ; i <= y ; ++i) tms = tms * (x - i + 1ll + P) % P; return tms;}

int st[8];
int dfs(int x , int cnt){
	if(!x){int c[2] = {}; for(int i = 1 ; i <= cnt ; ++i){++c[st[i]];} return 1ll * val[c[1]] * choosenum(R - c[1] , c[0]) % P;}
	int sum = 0; for(int i = 1 ; i <= cnt + 1 ; ++i){st[i] ^= 1; sum = (sum + dfs(x - 1 , max(i , cnt))) % P; st[i] ^= 1;} return sum;
}

int main(){
	cin >> N >> K >> S; val[0] = 1; for(int i = 0 ; i <= N ; ++i){C[i][0] = 1; for(int j = 1 ; j <= i ; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];}
	for(int i = 0 ; i < sz(S) ; ++i) sval = ((sval << 1) + S[i] - '0') % P;
	for(int i = 0 ; i < K ; ++i) R = (R * ((1ll << sz(S)) % P) + sval) % P;
	
	for(int i = 1 ; i <= N ; ++i){
		trs0 = trs1 = matrix(); for(int x = 0 ; x <= i ; ++x) trs0[x][x] = 1 << max(x - 1 , 0);
		for(int x = 0 ; x <= i ; ++x)
			for(int y = x ; y <= i ; ++y)
				trs1[x][y] = C[i - x][y - x] * (x ? 1 << (x - 1) : !((i - y) & 1));
		matrix now , tms; for(int i = 0 ; i <= N ; ++i) now[i][i] = tms[i][i] = 1;
		for(int i = 0 ; i < sz(S) ; ++i) now = now * (S[i] == '1' ? trs1 : trs0);
		int tmp = K; while(tmp){if(tmp & 1) tms = tms * now; now = now * now; tmp >>= 1;}
		val[i] = (tms[0][i] - dfs(i , 0) + P) % P;
	}
	int t = val[N]; for(int i = 1 ; i <= N ; ++i) t = 1ll * t * inv(i) % P;
	cout << t; return 0;
}
```

---

## 作者：cancan123456 (赞：0)

提供一种不需要高消的反演做法。

考虑容斥干掉 $n$ 个整数不同的限制，即，先求出 $f_m$ 为选出 $[0,R-1]$ 中 $m$ 个异或和为 $0$ 的整数的方案数。

不难考虑到数位 DP，因为每个数之间没有区别，所以只需要记录有几个数与上界 $R-1$ 的前缀，即，设 $dp_{j,k}$ 为考虑了高 $j$ 位，目前有 $k$ 个数与 $R-1$ 的高 $j$ 位相同，这些数的异或和的高 $j$ 位等于 $0$ 的方案数，可以使用矩阵快速幂优化到 $O(|S|m^3\log k)$。

求出 $f_m(0\le m\le n)$ 后，设 $g_m$ 为从 $[0,R-1]$ 中选出 $m$ 个**不同**的异或和为 $0$ 的整数的方案数，显然 $g_0=f_0=1$，考虑转移，先令 $g_m\gets f_m$，然后从 $g_m$ 里减掉不合法的情况。

不合法的情况，一定是选出的 $m$ 个数有一些相同的，设这 $m$ 个数去重后有 $j+k$ 个数，其中 $j$ 个数出现了奇数次，$k$ 个数出现了偶数次，这样的方案数为 $h_{m,j,k}g_j\prod_{i=0}^{k-1}(R-j-i)$，其中 $h_{m,j,k}$ 是将 $m$ 个元素分成 $j+k$ 组使得 $j$ 组大小为奇数 $k$ 组大小为偶数的方案数，$h_{m,j,k}$ 的转移方程可以参考第二类斯特林数的转移方式，不再赘述。

预处理 $\prod_{i=0}^{k-1}(R-j-i)$ 可以做到 $O(n^3)$ 的时间复杂度，但是我懒了，于是下面是时间复杂度 $O(k+|S|m^3\log k+n^4)$ 的代码。

```cpp
#include <cstdio>
using namespace std;
typedef long long ll;
const ll mod = 1000000007;
int size;
struct Matrix {
	ll a[8][8];
	Matrix() {
		for (int i = 0; i <= size; i++) {
			for (int j = 0; j <= size; j++) {
				a[i][j] = 0;
			}
		}
	}
	ll * operator [] (int i) {
		return a[i];
	}
	const ll * operator [] (int i) const {
		return a[i];
	}
	void E() {
		for (int i = 0; i <= size; i++) {
			for (int j = 0; j <= size; j++) {
				if (i == j) {
					a[i][j] = 1;
				} else {
					a[i][j] = 0;
				}
			}
		}
	}
};
void add(ll & x, ll y) {
	x = (x + y) % mod;
}
Matrix operator * (const Matrix & a, const Matrix & b) {
	Matrix c;
	for (int i = 0; i <= size; i++) {
		for (int j = 0; j <= size; j++) {
			for (int k = 0; k <= size; k++) {
				add(c[i][k], a[i][j] * b[j][k]);
			}
		}
	}
	return c;
}
Matrix pow(Matrix a, ll b) {
	Matrix ans;
	ans.E();
	while (b != 0) {
		if (b % 2 == 1) {
			ans = ans * a;
		}
		a = a * a;
		b = b / 2;
	}
	return ans;
}
int k, C[8][8];
char str[51];
void sub(ll & x, ll y) {
	x = (x - y + mod) % mod;
}
ll dp(int n) {
	size = n;
	Matrix trans0, trans1;
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= n - i; j++) {
			if (j % 2 == 0) {
				add(trans0[i][i], C[n - i][j]);
			}
		}
	}
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= n - i; j++) {
			for (int k = 0; k <= i; k++) {
				if ((j + k) % 2 == 0) {
					add(trans1[k][i], C[n - i][j] * C[i][k]);
				}
			}
		}
	}
	Matrix M;
	M.E();
	for (int i = 0; str[i] != '\0'; i++) {
		if (str[i] == '0') {
			M = trans0 * M;
		} else {
			M = trans1 * M;
		}
	}
	M = pow(M, k);
	return M[0][n];
}
int odd(int x) {
	return x % 2;
}
int even(int x) {
	return 1 - x % 2;
}
ll calc(ll a, int b) {
	ll ans = 1;
	for (int i = 0; i < b; i++) {
		ans = ans * a % mod;
		a = (a + mod - 1) % mod;
	}
	return ans;
}
ll pow(ll a, ll b) {
	ll ans = 1;
	while (b != 0) {
		if (b % 2 == 1) {
			ans = ans * a % mod;
		}
		a = a * a % mod;
		b = b / 2;
	}
	return ans;
}
ll f[8], h[8][8][8], g[8], fac[8];
int main() {
	int n;
	scanf("%d %d", &n, &k);
	scanf("%s", str);
	ll pow2k = 1;
	for (int i = 0; str[i] != '\0'; i++) {
		pow2k = pow2k * 2 % mod;
	}
	ll int_str = 0;
	for (int i = 0; str[i] != '\0'; i++) {
		int_str = (int_str * 2 + str[i] - '0') % mod;
	}
	ll R = 0;
	for (int i = 0; i < k; i++) {
		R = (R * pow2k + int_str) % mod;
	}
	for (int i = 0; i <= n; i++) {
		C[i][0] = 1;
		for (int j = 1; j <= i; j++) {
			C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
		}
	}
	fac[0] = 1;
	for (int i = 1; i <= n; i++) {
		fac[i] = fac[i - 1] * i % mod;
	}
	for (int i = 0; i <= n; i++) {
		f[i] = dp(i);
	}
	h[0][0][0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= i; j++) {
			for (int k = 0; j + k <= i; k++) {
				add(h[i][j][k], h[i - 1][j - 1][k]);
				add(h[i][j][k], h[i - 1][j + 1][k - 1] * (j + 1));
				add(h[i][j][k], h[i - 1][j - 1][k + 1] * (k + 1));
			}
		}
	}
	for (int i = 0; i <= n; i++) {
		g[i] = f[i];
		for (int j = 0; j < i; j++) {
			for (int k = 0; j + k <= i; k++) {
				sub(g[i], h[i][j][k] * g[j] % mod * calc(R - j, k) % mod);
			}
		}
	}
	printf("%lld", g[n] * pow(fac[n], mod - 2) % mod);
	return 0;
}
```

---


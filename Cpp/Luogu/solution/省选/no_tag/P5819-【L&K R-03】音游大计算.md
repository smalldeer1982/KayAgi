# 【L&K R-03】音游大计算

## 题目描述

小 K 喜欢玩音游，特别是一款叫做 dimou 的音游。dimou 的判定机制是这样的：dimou 是单面（不像某 dy 开头的东西）下落式音游。具体来说，在屏幕底端有一条判定线。一首曲子有若干打击点（即 key，可以看做一条与判定线平行的只有左右宽度的线段），每个 key 会在某个时刻从顶端匀速下落，而玩家需要尽量精准地在每个 key 与判定线重合时点击它。

当然，玩家有可能在 key 接触判定线之前就点击了，也可能在 key 已经落到判定线之下时才点击。这时候，就需要考虑游戏的判定系统，以统计玩家完成一首曲子的情况。dimou 有三种判定：perfect，good 和 miss。总共有六种情况——

情况 $1$：玩家点击的时间在某个 key 下落至其与判定线重合的时间的前 $1s$ 或更多（记为 $\triangle t\ge1$，下同），则不会产生任何判定效果（等于无意义点击）；

情况 $2$：$0.6\le\triangle t<1$，则此 key 产生一次 miss 判定并消失；

情况 $3$：$0.2\le\triangle t<0.6$，则此 key 产生一次 good 判定并消失；

情况 $4$：$-0.2<\triangle t<0.2$（负数代表在 key 到达判定线之后点击），则此 key 产生一次 perfect 判定并消失；

情况 $5$：$-0.6<\triangle t\le-0.2$，则此 key 产生一次 good 判定并消失；

情况 $6$：$\triangle t\le-0.6$，则此 key 在点击之前就会落出屏幕，记一次 miss 判定并消失（即在此 key 落于判定线之下 $0.6s$ 后自己产生一次 miss 判定），点击对此 key 不会产生任何判定效果。

除此之外，dimou 还有最大连击判定（max combo）。一段连击（combo）是指从某一个非 miss 的判定开始，到某一个非 miss 的判定结束（在这段区间内 **（按时间顺序）** 没有任何 miss 判定），判定的总数量。而 max combo 则指的是所有 combo 的最大值。

除此之外，dimou 还有一些判定规则。一次点击的位置可以看做判定线上的一个点，则过此点作判定线的垂线，只有与此垂线有交点（交点可在端点）的 key 才**可能**因此次点击产生判定效果。并且， **每次点击只会对可能产生判定效果的 key 中位置（纵向高度）最低（离屏幕顶端最远）的一个产生判定效果。** 形象地说，你只有点击某个 key 下方的位置才可能将其消除，并且若两个 key 有上下相对距离地一起下落，那么如果点击可以使下面的 key 消除，则一定不会使上面的 key 消除。特殊地，如果一次点击对两个或以上位置（高度）相同的 key 都可能产生判定效果，且没有更低的可能产生判定效果的 key，则这些 key 都会被消除。

为了把一首曲子打好，小 K 决定背谱，即记住所有 key 的位置和它们下落到判定线的时间。当然，小 K 也会事先决定好自己的打法，即决定在什么时间在什么位置点击。可是小 K 并不会计算自己的打法可以得到的最终成绩。请你帮小 K 算算，他的打法会得到多少 perfect 判定，多少 good 判定，多少 miss 判定，以及 max combo。

注意：小 K 不会在同一时间点击两次或以上。如果同一时间有多个判定，按 miss，good，perfect 的顺序依次处理。

## 说明/提示

样例 $3$：[输入](https://www.luogu.com.cn/paste/qrbt8fnq)，[输出](https://www.luogu.com.cn/paste/evke45h8)。

样例 $4$：[输入](https://www.luogu.com.cn/paste/a71namso)，[输出](https://www.luogu.com.cn/paste/jgpcani2)。

【样例解释】

对于样例 $1$：$5$ 个 key 产生的判定按时间顺序分别为 
 miss，good，perfect，good，miss。第一次和最后一次点击不产生判定效果。

对于样例 $2$：按时间顺序，第一次点击（$T=0.0$），可能产生判定效果的有（按输入顺序）第 $1,2,4$ 个 key。第 $1,2$ 个 key 同时到达判定线，第 $4$ 个 key 比第 $1,2$ 个 key 高。因此第一次点击只让第 $1,2$ 个 key 产生 perfect 判定。第二次点击（$T=0.6$），与其垂线有交点的有第 $3,4$ 个 key，但第 $3$ 个 key 此时已经产生 miss 判定并消失，因此这次点击让第 $4$ 个 key 产生一次 perfect 判定，此时在同一时间出现了两个判定 perfect，miss，按照规则先处理 miss 再处理 perfect。所以，所有判定按时间顺序分别是 perfect，perfect，miss，perfect。容易发现 miss 把判定序列分成了两段，第一段的 combo 为 $2$，第二段的 combo 为 $1$，所以 max combo 为 $2$。

【数据范围】

对于 $30\%$ 数据，$n,m\le5000$。

对于另外 $20\%$ 数据，$n\le5000$，$m\le114514$。

对于另外 $10\%$ 数据，所有 $a_i$ 相等，所有 $b_i$ 相等。

对于另外 $10\%$ 数据，$t_i,T_i,a_i,b_i,x_i$ 在 $[0,10^4]$ 中随机生成。

对于 $100\%$ 数据，$1\le n,m\le114514$，$0\le t_i,T_i,a_i,b_i,x_i\le 10^4$，$a_i\le b_i$。

## 样例 #1

### 输入

```
5 6
1 0.0 10.0
1.5 0.0 10.0
2.0 0.0 10.0
2.5 0.0 10.0
3.0 0.0 10.0
0.0 5.0
0.4 5.0
1.3 5.0
2.0 5.0
2.7 5.0
3.6 5.0```

### 输出

```
1 2 2 3```

## 样例 #2

### 输入

```
4 2
0.1 0.0 3.0
0.1 2.0 4.0
0.0 3.0 8.0
0.6 1.0 6.0
0.6 6.0
0.0 2.5```

### 输出

```
3 0 1 2```

# 题解

## 作者：Alex_Wei (赞：19)

$$\mathsf{Preface}$$

> [题面传送门](https://www.luogu.com.cn/problem/P5819)

> 题意简述：题面太长，细节太多，没法简述。。。

看起来现在的 $\sf{AC}$ 记录里面除了我和出题人，别的都是抄题解的。。（截至 $2020.2.21\ 23:08$）

锻炼码力 + $\rm{debug}$ 能力的题目。我对拍了无数次才把自己的错误一一找出来。

吐槽一下：**这！题！的！细！节！是！真！T！M！多！** 

为了我花在这道题目上的 $\rm{3.5h}$，我一定得写篇题解。

---

$$\sf{Solution}$$

$$\sf{Step\ One:Prework}$$


敢做这道题目的应该都能一眼看出是线段树。。。

我们先把所有位置离散化，然后将 $\rm{key}$ 按下落时间排序，将 $\rm{click}$ 按点击时间排序，方便统计答案。

该部分的注意点：

- 和出题人给出的题解一样，尽量用整数存储答案，即将读入的数乘上 $10^5$。

- 化成整数的时候有精度误差，可以加上像四舍五入一样加上 $0.5$。

$\rm{key}$ 的读入及离散化：

```cpp
const int N=1.2e5+5,inf=2e9+7;
struct key{
	int t,a,b,sta,ju;//sta是这个key的状态，ju是这个key被判定的时间
	bool operator < (const key &v) const {return t<v.t;}//按时间排序
}c[N];
struct click{
	int t,pos;
	bool operator < (const click &v) const {return t<v.t;}
}q[N];
int n,m,cnt,pos[N<<2];
......main函数内
	read(n),read(m);
	for(int i=1;i<=n;i++){
		double x,y,z; read(x),read(y),read(z);
		c[i]={x*1e5+0.5,y*1e5+0.5,z*1e5+0.5,0};
		pos[++cnt]=c[i].a,pos[++cnt]=c[i].b;
	}
	for(int i=1;i<=m;i++){
		double x,y; read(x),read(y);
		q[i]={x*1e5+0.5,y*1e5+0.5};
		pos[++cnt]=q[i].pos; 
	}
	sort(c+1,c+n+1),sort(q+1,q+m+1),c[0].t=inf;//c[0].t赋为inf，更方便
	sort(pos+1,pos+cnt+1);
	cnt=unique(pos+1,pos+cnt+1)-pos-1;
```

$$\sf{Step\ Two:Build\ SegmentTree}$$

将相应的 $\rm{key}$ 添加到线段树相应的位置上，因为线段树的一个区间可能会被多个 $\rm{key}$ 覆盖，所以每个区间可以存一个链表，链表里面存 $\rm{key}$ 的编号。

- 因为位置离散化后会达到 $2n+m$，所以空间要开大一些。（反正不会 $\sf{MLE}$ 就行）

线段树的建造：

```cpp
int get(int x){return lower_bound(pos+1,pos+cnt+1,x)-pos;}//返回离散化后的值
int node,hd[N<<4],tl[N<<4],nxt[N<<7],val[N<<7];
void push(int x,int id){//链表添加
	if(!hd[x])hd[x]=tl[x]=++node;
	else nxt[tl[x]]=++node,tl[x]=node;
	val[node]=id;
}
void add(int l,int r,int ql,int qr,int x,int id){//添加key
	if(ql<=l&&r<=qr){
		push(x,id);
		return;
	}
	int m=l+r>>1;
	if(ql<=m)add(l,m,ql,qr,x<<1,id);
	if(m<qr)add(m+1,r,ql,qr,x<<1|1,id);
}
......main函数内
	for(int i=1;i<=n;i++){
		int p1=get(c[i].a),p2=get(c[i].b);
		add(1,cnt,p1,p2,1,i);
	}
```

$$\sf{Step\ Three:Query}$$

对每一个点击，先求出它产生判定效果的 $\rm{key}$ 是在什么时候下落的，如果此次点击时间为 $T$，位置为 $P$，也就是求出 $\min_{a_i\leq P\leq b_i,\ T-0.6s<t_i<T+1s}t_i$，记为 $t$。（区分 $t$ 和 $T$）

另外，在求 $t$ 的时候要将前面已经 “过期” 或者 “已被判定” 的 $\rm{key}$ 弹出。

给出此部分的代码：

```cpp
#define d val[hd[x]]//宏定义方便
void update(int x,int t){//将过期或已被判定的key弹出
	while(hd[x]){
		if(c[d].t+60000<=t){//过期
			if(!c[d].sta)c[d].ju=c[d].t+60000,c[d].sta=1;
			hd[x]=nxt[hd[x]];
		}
		else if(c[d].sta)hd[x]=nxt[hd[x]];//已被判定
		else break;//否则break 
	}
}
int tim(int x,int t){//求一下会判定的key的下落时间
	if(c[d].t-t>=100000)return inf;//如果还没到判定范围就返回inf（如果链表为空，因为前面c[0].t赋为inf了，所以也会返回inf） 
	else return c[d].t;
}
int query(int l,int r,int pos,int x,int t){
	update(x,t);
	if(l==r)return tim(x,t);//如果到底了就返回
	int m=l+r>>1;
	if(pos<=m)return min(tim(x,t),query(l,m,pos,x<<1,t));
	else return min(tim(x,t),query(m+1,r,pos,x<<1|1,t));//因为判定的是最低的key，所以取min
}
```
接下来判定所有下落时间为 $t$ 的 $\rm{key}$。

注意点：如果没有可以判定的 $\rm{key}$（即代码中 $t=\rm{inf}$），跳过此部分，否则可能会导致死循环。

```cpp
void modify(int l,int r,int pos,int x,int t,int T){
	while(c[d].t==t){//如果下落时间为本次key的判定下落时间t
		if(!c[d].sta){//如果没有被判定
			c[d].ju=T;//记录被判定的时间T（再次说明，请区分t和T）
			if(abs(c[d].t-T)<20000)c[d].sta=3;//根据题目所给的条件进行判定，下同 
			else if(abs(c[d].t-T)<60000)c[d].sta=2;
			else c[d].sta=1;
		}
		hd[x]=nxt[hd[x]];
	}
	if(l==r)return;
	int m=l+r>>1;
	if(pos<=m)modify(l,m,pos,x<<1,t,T);
	else modify(m+1,r,pos,x<<1|1,t,T);
}
......main函数内
	for(int i=1;i<=m;i++){
		int p=get(q[i].pos),t=query(1,cnt,p,1,q[i].t);
		if(t!=inf)modify(1,cnt,p,1,t,q[i].t);//如果有判定的key就判定
	}
```

$$\sf{Step\ Four:Calculate\ Answer}$$

有了每个 $\rm{key}$ 的判定时间和判定状态，答案就很好计算了，将每个 $\rm{key}$ 按照判定时间排序，判定时间相同按 $\sf{miss,good,perfect}$ 排序即可。

此部分代码：

```cpp
bool cmp(key a,key b){return a.ju<b.ju||a.ju==b.ju&&a.sta<b.sta;}
int mis,goo,per,com,tmp;
......main函数内
	for(int i=1;i<=n;i++)if(!c[i].sta)c[i].sta=1,c[i].ju=c[i].t+60000;//如果未被判定，那就是miss，判定时间为下落时间+0.6s 
	sort(c+1,c+n+1,cmp);//根据判定时间排序
	for(int i=1;i<=n;i++){
		if(c[i].sta==1)com=max(com,tmp),mis++,tmp=0;
		else tmp++,c[i].sta==2?goo++:per++;//计算答案
	}
	cout<<per<<" "<<goo<<" "<<mis<<" "<<max(tmp,com)<<endl;
```

至此，本题被我们完美解决！

---

$$\sf{Code}$$

给出完整的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void read(int &x){
	bool sign=0; char s=getchar(); x=0;
	while(!isdigit(s))sign|=s=='-',s=getchar();
	while(isdigit(s))x=(x<<1)+(x<<3)+s-'0',s=getchar();
	x=sign?-x:x;
}
inline void read(double &x){
	bool sign=0; char s=getchar(); int a=0; x=0;
	while(!isdigit(s))sign|=s=='-',s=getchar();
	while(isdigit(s))a=(a<<1)+(a<<3)+s-'0',s=getchar();
	if(s=='.'){
		double tmp=1; s=getchar();
		while(isdigit(s))tmp/=10,x+=tmp*(s-'0'),s=getchar();
	}
	x+=a,x=sign?-x:x;
}
#define d val[hd[x]]//宏定义方便
const int N=1.2e5+5,inf=2e9+7;
struct key{
	int t,a,b,sta,ju;//sta是这个key的状态，ju是这个key被判定的时间
	bool operator < (const key &v) const {return t<v.t;}//按时间排序
}c[N];
struct click{
	int t,pos;
	bool operator < (const click &v) const {return t<v.t;}
}q[N];
bool cmp(key a,key b){return a.ju<b.ju||a.ju==b.ju&&a.sta<b.sta;}
int n,m,cnt,pos[N<<2];
int get(int x){return lower_bound(pos+1,pos+cnt+1,x)-pos;}//返回离散化后的值
int node,hd[N<<4],tl[N<<4],nxt[N<<7],val[N<<7];
void push(int x,int id){//链表添加
	if(!hd[x])hd[x]=tl[x]=++node;
	else nxt[tl[x]]=++node,tl[x]=node;
	val[node]=id;
}
void add(int l,int r,int ql,int qr,int x,int id){//添加key 
	if(ql<=l&&r<=qr){
		push(x,id);
		return;
	}
	int m=l+r>>1;
	if(ql<=m)add(l,m,ql,qr,x<<1,id);
	if(m<qr)add(m+1,r,ql,qr,x<<1|1,id);
}
void update(int x,int t){//将过期或已被判定的key弹出
	while(hd[x]){
		if(c[d].t+60000<=t){//过期
			if(!c[d].sta)c[d].ju=c[d].t+60000,c[d].sta=1;
			hd[x]=nxt[hd[x]];
		}
		else if(c[d].sta)hd[x]=nxt[hd[x]];//已被判定
		else break;//否则break 
	}
}
int tim(int x,int t){//求一下会判定的key的下落时间
	if(c[d].t-t>=100000)return inf;//如果还没到判定范围就返回inf（如果链表为空，因为前面c[0].t赋为inf了，所以也会返回inf） 
	else return c[d].t;
}
int query(int l,int r,int pos,int x,int t){
	update(x,t);
	if(l==r)return tim(x,t);//如果到底了就返回
	int m=l+r>>1;
	if(pos<=m)return min(tim(x,t),query(l,m,pos,x<<1,t));
	else return min(tim(x,t),query(m+1,r,pos,x<<1|1,t));//因为判定的是最低的key，所以取min
}
void modify(int l,int r,int pos,int x,int t,int T){
	while(c[d].t==t){//如果下落时间为本次key的判定下落时间t
		if(!c[d].sta){//如果没有被判定
			c[d].ju=T;//记录被判定的时间T（再次说明，请区分t和T）
			c[d].sta=abs(c[d].t-T)<20000?3:abs(c[d].t-T)<60000?2:1;//根据题目所给的条件进行判定
		}
		hd[x]=nxt[hd[x]];
	}
	if(l==r)return;
	int m=l+r>>1;
	if(pos<=m)modify(l,m,pos,x<<1,t,T);
	else modify(m+1,r,pos,x<<1|1,t,T);
}
int mis,goo,per,com,tmp;
int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++){
		double x,y,z; read(x),read(y),read(z);
		c[i]={x*1e5+0.5,y*1e5+0.5,z*1e5+0.5,0};
		pos[++cnt]=c[i].a,pos[++cnt]=c[i].b;
	}
	for(int i=1;i<=m;i++){
		double x,y; read(x),read(y);
		q[i]={x*1e5+0.5,y*1e5+0.5};
		pos[++cnt]=q[i].pos; 
	}
	sort(c+1,c+n+1),sort(q+1,q+m+1),c[0].t=inf;//c[0].t赋为inf，更方便
	sort(pos+1,pos+cnt+1),cnt=unique(pos+1,pos+cnt+1)-pos-1;//离散化
	for(int i=1;i<=n;i++)add(1,cnt,get(c[i].a),get(c[i].b),1,i);
	for(int i=1;i<=m;i++){
		int p=get(q[i].pos),t=query(1,cnt,p,1,q[i].t);
		if(t!=inf)modify(1,cnt,p,1,t,q[i].t);//如果有判定的key就判定
	}
	for(int i=1;i<=n;i++)if(!c[i].sta)c[i].sta=1,c[i].ju=c[i].t+60000;//如果未被判定，那就是miss，判定时间为下落时间+0.6s 
	sort(c+1,c+n+1,cmp);//根据判定时间排序
	for(int i=1;i<=n;i++){
		if(c[i].sta==1)com=max(com,tmp),mis++,tmp=0;
		else tmp++,c[i].sta==2?goo++:per++;//计算答案
	}
	cout<<per<<" "<<goo<<" "<<mis<<" "<<max(tmp,com)<<endl;
	return 0;
}
```

开了 $\sf{O2}$ 跑得飞快，不开 $\sf{O2}$ 可能会因为评测机波动 $\sf{TLE}$（只是可能，因为还没背卡过，最长的测试点在 $\sf{900ms}$ 左右）

---

$$\sf{Ending}$$

如果你只对 $\rm{key}$ 的位置离散化，其实会快不少，但细节更多，有一些边界情况需要考虑。如果你想追求更快的解法，可以参考我的这份评测记录：[$\sf{link}$](https://www.luogu.com.cn/record/30906960)（快了大概 $25\%$ 左右）

其实当时打这场比赛的时候就想写正解，但是细节太多写自闭了。。。

今天无意间翻到这道题，仍然用了很长时间才将其 $\sf{AC}$，可见我是多么的菜。

码字不易，既然你都看到这儿了，就顺手点个赞呗 =w=

当然，如果你发现了本题解的笔误/学术上的错误，欢迎在评论区指出或者直接私信通知我，万分感谢！

再次感谢你认真地翻到了这里，拜拜 ~~

---

## 作者：Jadonyzx (赞：6)

### Description

你需要实现一个音游判定，但是玩家是只会单指的奥托普雷先生。

~~话说什么粪谱物量 114514 啊？~~

### Solution

~~敢开这道题的应该都能看出是线段树吧~~

首先把所有出现过的横坐标离散化，最终化为一个只有横坐标的判定线，有点像中二节奏的判定，有的键大，有的小，对于每个线段树的结点开一条链表，表示该区间点击时一定会被判定的按键编号。 

链表代码：


```cpp
int head[maxn<<6],tail[maxn<<6],chaintot;
int nxt[maxn<<7],uid[maxn<<7],pre[maxn<<7];
void push(int st,int u){
	if(!head[st])head[st]=tail[st]=++chaintot;
	else nxt[tail[st]]=++chaintot,pre[chaintot]=tail[st],tail[st]=chaintot;
	uid[chaintot]=u;return;
}
```

> 每次点击只会对可能产生判定效果的 key 中位置（纵向高度）最低（离屏幕顶端最远）的一个产生判定效果。

可是连 rks=12.22 的 yyw 都知道在 phigros 的 stasis 谱面中存在大量纵连，显然我们要先判定先落下的按键。

因此我们先对所有按键进行排序，按顺序插入即可。

开一个结构体排序，由于会爆精度，我们把每个时间映射成一个整数。

代码：


```cpp
struct Key{int t;double aa,bb;int a,b;}key[maxn<<1];

for(int i=1;i<=n;++i){
		cin>>dub>>key[i].aa>>key[i].bb;
		key[i].t=dub*1e5+0.5;//映射 
	}

inline bool cmp(Key drag,Key flick){return drag.t<flick.t;}

sort(key+1,key+1+n,cmp);
```

如果我先加入了所有按键再直接处理的话，会遇到一个问题，我们联想到 phigros 中山茶花的某张 AT 铺面，存在双押三押交替的情况，而这里的玩家是不会双押多押的，如图。

![+++](https://cdn.luogu.com.cn/upload/image_hosting/lcph70mn.png)

那么根据先判 miss 的规则，太麻烦了。

不妨定义**事件**有三种类型。

1.音符进入判定区域。定义为 insert 。

2.音符推出判定区域，即为自动 miss。定义为 miss。

3.玩家点击。定义为 tap。

对于 insert 事件，我们直接将音符压入线段树中。

对于 miss 事件，我们开一个布尔数组表示按键是否被判定过，直接修改布尔数组对应位置即可。

对于 tap 事件，我们根据点击位置遍历线段树对应位置，将有可能被判定的按键压入一个栈中，再利用先前定义下标越小，时间越小的性质，根据下标排序，处理栈中时间相同的前几项即可。

下面给出关于事件的处理代码。

音符进入判定区域。

```cpp
void insert(int id,int nowl,int nowr,int tol,int tor,int UID){
	if(tol<=nowl&&nowr<=tor){push(id,UID);return;}
	if(tol>nowr||tor<nowl)return;
	int mid=(nowl+nowr)>>1;
	insert(id<<1  ,nowl , mid,tol,tor,UID);
	insert(id<<1|1,mid+1,nowr,tol,tor,UID);
	return;
}

if(now.op==1){
    if(js[now.keyid])continue;
    insert(1,1,tot,key[now.keyid].a,key[now.keyid].b,now.keyid);
    cerr<<"insert\n";
}
```

音符自动判定为 miss。

```cpp
else if(now.op==2){
  if(js[now.keyid])continue;
  maxcombo=max(maxcombo,combo);
  combo=0;js[now.keyid]=1;
  miss++;
  cerr<<"miss\n";
}
```

将可能结算的音符压入栈中。


```cpp
void update(int id,int nowl,int nowr,int place,int t){
	if(nowr<place||nowl>place)return;
	bool Vis=false;int first_t=0;
	for(int i=head[id];i;i=nxt[i]){
		if(!i)break;
		if(js[uid[i]]){
			nxt[pre[i]]=nxt[i];
			pre[nxt[i]]=pre[i];
			if(i==head[id])head[id]=nxt[i];
			if(i==tail[id])tail[id]=pre[i];
			continue;
		}
		if(Vis&&first_t!=key[uid[i]].t)break;
		stk[++top]=uid[i];
		first_t=key[uid[i]].t;
		Vis=1;
		if(i==tail[id])break;
	}
	if(nowl==nowr)return;
	int mid=(nowl+nowr)/2;
	update(id<<1  ,nowl , mid,place,t);
	update(id<<1|1,mid+1,nowr,place,t);
	return;
}
```

按照 miss，good，perfect 的顺序结算。


```cpp
else{
    top=0;
    update(1,1,tot,now.place,now.tl);
    sort(stk+1,stk+1+top);
    int stk2[maxn],top2=0;
    for(int i=1;i<=top;++i){
      if(key[stk[i]].t!=key[stk[1]].t)break;
      stk2[++top2]=stk[i];
    }
    for(int i=1;i<=top2;++i){
      if(js[stk2[i]])continue;
      int delta=key[stk2[i]].t-now.tl;
      if(delta>=60000||delta<=-60000){
        maxcombo=max(maxcombo,combo);
        combo=0;js[stk2[i]]=1;
        miss++;
        cerr<<"miss\n";
      }
    }
    for(int i=1;i<=top2;++i){
      if(js[stk2[i]])continue;
      int delta=key[stk2[i]].t-now.tl;
      if((delta>=20000&&delta<60000)||(delta<=-20000&&delta>-60000)){
        cerr<<"good\n";
        js[stk2[i]]=1;
        combo++;
        good++; 
      }
    }
    for(int i=1;i<=top2;++i){
      if(js[stk2[i]])continue;
      int delta=key[stk2[i]].t-now.tl;
      if(-20000<delta&&delta<20000){
        cerr<<"perfect\n";
        combo++;
        js[stk2[i]]=1;
        perfect++;
      }
    }
  }
```

那么就只剩事件排序的问题了，如图。

![Perfect](https://cdn.luogu.com.cn/upload/image_hosting/7jhbkuzg.png)

考虑到按键进入判定区间与按键自动miss是开区间，我们在排序时若两个事件同时发生应遵循以下规则：

1.事件 miss 优先于事件 tap。

2.事件 tap 优先于事件 insert。

体现在排序中是这样的：


```cpp
struct event{int op,keyid,place;int tl;};//op=1音符进入判定区间 op=2音符推出判定区间 op=3点击 
queue<event>q;
event events[maxn<<3];int evecnt;
bool Cmp(event drag,event flick){
	if(drag.tl==flick.tl){
		if(drag.op<=2&&flick.op<=2)return 1;
		if(drag.op==3&&flick.op==3)return 1;
		if(drag.op==1&&flick.op==3)return 0;
		if(drag.op==2&&flick.op==3)return 1;
		if(drag.op==3&&flick.op==1)return 1;
		if(drag.op==3&&flick.op==2)return 0; 
	}
	return drag.tl<flick.tl;
}
```

总代码如下：


```cpp
#include<bits/stdc++.h>
#define maxn 114514+10
using namespace std;
int n,m,tot;double tong[maxn<<4];
bool js[maxn];double dub;
int combo,maxcombo,perfect,good,miss;
struct Key{int t;double aa,bb;int a,b;}key[maxn<<1];
struct Tap{int t;double xx;int x;}tap[maxn<<1];
inline bool cmp(Key drag,Key flick){return drag.t<flick.t;}
inline bool CMP(Tap drag,Tap flick){return drag.t<flick.t;}
int stk[maxn<<6],top;

int head[maxn<<6],tail[maxn<<6],chaintot;
int nxt[maxn<<7],uid[maxn<<7],pre[maxn<<7];
void push(int st,int u){
	if(!head[st])head[st]=tail[st]=++chaintot;
	else nxt[tail[st]]=++chaintot,pre[chaintot]=tail[st],tail[st]=chaintot;
	uid[chaintot]=u;return;
}

void insert(int id,int nowl,int nowr,int tol,int tor,int UID){
	if(tol<=nowl&&nowr<=tor){push(id,UID);return;}
	if(tol>nowr||tor<nowl)return;
	int mid=(nowl+nowr)>>1;
	insert(id<<1  ,nowl , mid,tol,tor,UID);
	insert(id<<1|1,mid+1,nowr,tol,tor,UID);
	return;
}

void update(int id,int nowl,int nowr,int place,int t){
	if(nowr<place||nowl>place)return;
	bool Vis=false;int first_t=0;
	for(int i=head[id];i;i=nxt[i]){
		if(!i)break;
		if(js[uid[i]]){
			nxt[pre[i]]=nxt[i];
			pre[nxt[i]]=pre[i];
			if(i==head[id])head[id]=nxt[i];
			if(i==tail[id])tail[id]=pre[i];
			continue;
		}
		if(Vis&&first_t!=key[uid[i]].t)break;
		stk[++top]=uid[i];
		first_t=key[uid[i]].t;
		Vis=1;
		if(i==tail[id])break;
	}
	if(nowl==nowr)return;
	int mid=(nowl+nowr)/2;
	update(id<<1  ,nowl , mid,place,t);
	update(id<<1|1,mid+1,nowr,place,t);
	return;
}
struct event{int op,keyid,place;int tl;};//op=1音符进入判定区间 op=2音符推出判定区间 op=3点击 
queue<event>q;
event events[maxn<<3];int evecnt;
bool Cmp(event drag,event flick){
	if(drag.tl==flick.tl){
		if(drag.op<=2&&flick.op<=2)return 1;
		if(drag.op==3&&flick.op==3)return 1;
		if(drag.op==1&&flick.op==3)return 0;
		if(drag.op==2&&flick.op==3)return 1;
		if(drag.op==3&&flick.op==1)return 1;
		if(drag.op==3&&flick.op==2)return 0; 
	}
	return drag.tl<flick.tl;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>dub>>key[i].aa>>key[i].bb;
		key[i].t=dub*1e5+0.5;//映射 
	}
	for(int i=1;i<=n;++i){
		tong[++tot]=key[i].aa;
		tong[++tot]=key[i].bb;
	}
	for(int i=1;i<=m;++i){
		cin>>dub>>tap[i].xx;
		tap[i].t=dub*1e5+0.5;
		tong[++tot]=tap[i].xx;
	}
	sort(tong+1,tong+1+tot);tot=unique(tong+1,tong+1+tot)-(tong+1);
	for(int i=1;i<=n;++i){
		key[i].a=lower_bound(tong+1,tong+1+tot,key[i].aa)-(tong);
		key[i].b=lower_bound(tong+1,tong+1+tot,key[i].bb)-(tong);
	}
	for(int i=1;i<=m;++i)tap[i].x=lower_bound(tong+1,tong+1+tot,tap[i].xx)-(tong);
	//离散化
	sort(key+1,key+1+n,cmp);
	sort(tap+1,tap+1+m,CMP);
	//排序 
	for(int i=1;i<=n;++i){
		events[++evecnt]={1,i,114514,key[i].t-100000};
		events[++evecnt]={2,i,114514,key[i].t+60000};
	}
	cerr<<"track completed\n";
	//导入音符进入事件 
	for(int i=1;i<=m;++i)events[++evecnt]={3,114514,tap[i].x,tap[i].t};
	cerr<<"player completed\n";
	//导入点击时间 
	sort(events+1,events+1+evecnt,Cmp);
	for(int i=1;i<=evecnt;++i)q.push(events[i]);
	//排序事件并压入队列 
	//计算
	while(q.size()){
		event now=q.front();q.pop();
		if(now.op==1){
			if(js[now.keyid])continue;
			insert(1,1,tot,key[now.keyid].a,key[now.keyid].b,now.keyid);
			cerr<<"insert\n";
		}
		else if(now.op==2){
			if(js[now.keyid])continue;
			maxcombo=max(maxcombo,combo);
			combo=0;js[now.keyid]=1;
			miss++;
			cerr<<"miss\n";
		}
		else{
			top=0;
			update(1,1,tot,now.place,now.tl);
			sort(stk+1,stk+1+top);
			int stk2[maxn],top2=0;
			for(int i=1;i<=top;++i){
				if(key[stk[i]].t!=key[stk[1]].t)break;
				stk2[++top2]=stk[i];
			}
			for(int i=1;i<=top2;++i){
				if(js[stk2[i]])continue;
				int delta=key[stk2[i]].t-now.tl;
				if(delta>=60000||delta<=-60000){
					maxcombo=max(maxcombo,combo);
					combo=0;js[stk2[i]]=1;
					miss++;
					cerr<<"miss\n";
				}
			}
			for(int i=1;i<=top2;++i){
				if(js[stk2[i]])continue;
				int delta=key[stk2[i]].t-now.tl;
				if((delta>=20000&&delta<60000)||(delta<=-20000&&delta>-60000)){
					cerr<<"good\n";
					js[stk2[i]]=1;
					combo++;
					good++;
				}
			}
			for(int i=1;i<=top2;++i){
				if(js[stk2[i]])continue;
				int delta=key[stk2[i]].t-now.tl;
				if(-20000<delta&&delta<20000){
					cerr<<"perfect\n";
					combo++;
					js[stk2[i]]=1;
					perfect++;
				}
			}
		}
	}
	maxcombo=max(maxcombo,combo);
	combo=0;
	cout<<perfect<<" "<<good<<" "<<miss<<" "<<maxcombo;
	if(perfect==maxcombo&&(good==0&&miss==0))cerr<<"All Perfect\n";
	else if(maxcombo==n)cerr<<"Full Combo\n"; 
	return 0;
}
```

---

## 作者：potatoler (赞：5)

所以啊，为什么刚读完题就感到手疼了呢？QwQ

### [题目](https://www.luogu.com.cn/problem/P5819)简述

题目比较复杂——没有玩过音游的小伙伴们建议从上面的链接前往原题

下落式音游。给出判定的时间规则，每个 Key 的位置范围和到达判定线的时间，每次 Click 的位置和时间，统计 miss，good，perfect 和 maxcombo。

### 思路：

#### 数据结构的使用

Key 的位置是一个范围，在判定线上投影为一段区间，Click 的位置是一个点，在判定线上投影为一个点——处理每一次的 Click，对 Key 进行判定，其实就是在一条线段上以一个单点为入口对区间进行判定——于是我们可以用线段数来维护 Click 和 Key 的信息。

一般来讲线段树可以看作是一种二维数据结构，两个维度分别是「位置」和「层级」：在访问某一个位置的时候我们从「位置」出发，在「层级」上推进，最终找到我们要访问的数据在线段树中的具体位置。![2D-SegmentTree](https://i.loli.net/2020/05/31/pxiobkyMrNTjKLO.jpg)

但是在本题中，判定线上的同一位置可能会出现多个 Key，这些 Key 在「位置」和「层级」维度记录的数据都是相同的，但是它们出现的时间是不同的——换句话说，二维的线段树已经满足不了我们统计数据的需要，我们应该在二位线段树的基础上增加一个「时间」维度。![3D-SegmentTree](https://i.loli.net/2020/05/31/a3YVHPgt9eNjKqx.jpg)

从上面的线段树分析中我们可以看出：线段树的几个维度并不是平行关系，其从主到次的顺序分别是：「位置」「层级」「时间」

#### 数据处理

位置和时间都是最多五位的小数，为了计算方便，我们将所有数据乘 $10^5$，用整数表示位置和时间，为了防止产生精度误差可以用「四舍五入」的方式加上 0.5。将数据离散化并且将 Key 和 Click 按照时间排序方便线段树时间维度的构造以及答案的统计。

#### 将 Key 放入线段树

方法与二维线段树几乎相同。

在原来的线段树中当查找到线段树最底层时，也就意味着第二个维度也走完了，我们只需要将数据直接存入线段树的数组，而现在我们要在每一个位置都再扩展出一维：可以使用链表储存 Key 的编号，挂在线段树数组的每一个元素中。由于刚才已经将 Key 按照时间排过序，每一条链上的编号所指向的 Key 也是时间从前往后的——这样就成功构建出了我们所希望的三维线段树。

值得注意的一点是：原本的二维线段树对数组大小要求就已经很高了，再扩展一维会有更大的空间开销——再加上我们对位置进行了离散化处理，所以要把数组开大些。

#### 对于 Click 和 Key 的判定

对于每一次 Click，我们需要求出它在那个具体的时间。事实上我们需要求出再有效打击时间范围内最前面的一个 Key，即对于时间为 $clickTime$，位置为 $pos$ 的 Click，我们要求 $judgeTime_{min}$ 满足 $a_i ≤ pos ≤ b_i$ 且 $clickTime-0.6s < judgeTime < clickTime + 1s$。然后对于我们求出的每一个 $judgeTime$ 判对可以判定的 Key 按照规则进行处理。

值得注意的一点是，判定过的 Key 我们要从线段树中删除——操作很简单但这是一个很重要的步骤。

#### 答案的统计

最后按照判定时间对 Key 进行排序（以便计算maxCombo），扫一遍 Key 顺便就可以统计判定结果了

### Code

```CPP
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<climits>
#define thisKey ky[nodeSerial[headNode[x]]]
using namespace std;
const int MaxN = 120000, Inf = INT_MAX;
int n, m, elemCount;
int missKey, goodTap, perfectClick, maxCombo, curCombo;
struct Key{int t, a, b, judgeTime, ifJudged;} ky[MaxN];
struct Click{int t, pos;} click[MaxN];
int nodeCount, headNode[MaxN << 4], lastNode[MaxN << 4], nextNode[MaxN << 10], nodeSerial[MaxN << 10];
bool cmpKey(Key x, Key y){return x.t < y.t;}
bool cmpClick(Click x, Click y){return x.t < y.t;}
bool cmpJudge(Key x, Key y){return x.judgeTime < y.judgeTime || (x.judgeTime == y.judgeTime && x.ifJudged < y.ifJudged);}
int posData[MaxN << 3];
inline int getPos(int x){return lower_bound(posData+1, posData+elemCount+1, x) - posData;}
inline void AddNode(int x,  int ser){
	//the x-th position on the segment tree with ser-th key
	//it's worth noticed that for position x there may be more than one key with different serial
	nodeCount++;
	if(!headNode[x]) headNode[x] = lastNode[x] = nodeCount;
	else nextNode[lastNode[x]] = nodeCount, lastNode[x] = nodeCount;
	nodeSerial[nodeCount] = ser;
}
inline void Build(int l, int r, int reqL, int reqR, int x, int ser){
	//in the traditional segment tree we can simply give a[i]'s value to the tree but here we need to used the AddNote function
	if(l >= reqL && r <= reqR){AddNode(x, ser); return;}
	int mid = (l + r) / 2;
	if(reqL <= mid) Build(l, mid, reqL, reqR, x*2, ser);
	if(reqR > mid) Build(mid+1, r, reqL, reqR, x*2+1, ser);
}
//obviously the big number in the functions below comes from the 0.6 and 1 in game rule: after dispersing these numbers also get bigger
inline void Refresh(int x, int t){
	//keys that have been clicked should be deleted
	while(headNode[x]){
		if(thisKey.t + 60000 <= t){
			if(!thisKey.ifJudged){
				thisKey.judgeTime = thisKey.t + 60000;
				thisKey.ifJudged = 1;
			}
			headNode[x] = nextNode[headNode[x]];
		}
		else if(thisKey.ifJudged) headNode[x] = nextNode[headNode[x]];
		else break;
	}
}
inline int JudgeTimeCal(int x, int t){
	if(thisKey.t - t >= 100000) return Inf;
	else return thisKey.t;
}
inline int GetJudgeTime(int l, int r, int pos, int x, int t){
	//delete judged keys before EVERY SINGLE TIME of JUDGE!
	Refresh(x, t);
	if(l == r) return JudgeTimeCal(x, t);
	int mid = (l + r) / 2;
	if(pos <= mid) return min(JudgeTimeCal(x, t), GetJudgeTime(l, mid, pos, x*2, t));
	else return min(JudgeTimeCal(x, t), GetJudgeTime(mid+1, r, pos, x*2+1, t));
}
inline void Judge(int l, int r, int pos, int x, int t, int jt){
	while(thisKey.t == t){
		if(!thisKey.ifJudged){
			thisKey.judgeTime = jt;
			if(abs(thisKey.t - jt) < 20000) thisKey.ifJudged = 3;
			else if(abs(thisKey.t - jt) < 60000) thisKey.ifJudged = 2;
			else thisKey.ifJudged = 1;
		}
		headNode[x] = nextNode[headNode[x]];
	}
	if(l == r) return;
	int mid = (l + r) / 2;
	if(pos <= mid) Judge(l, mid, pos, x*2, t, jt);
	else Judge(mid+1, r, pos, x*2+1, t, jt);
}
int main(){
	//intput and have keys dispersed
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		double t, a, b;
		scanf("%lf%lf%lf",&t,&a,&b);
		ky[i].t = t*1e5+0.5, ky[i].a = a*1e5+0.5, ky[i].b = b*1e5+0.5;
		posData[++elemCount] = ky[i].a, posData[++elemCount] = ky[i].b;
	}
	for(int i=1;i<=m;i++){
		double t, p;
		scanf("%lf%lf",&t,&p);
		click[i].t = t*1e5+0.5, click[i].pos = p*1e5+0.5;
		posData[++elemCount] = click[i].pos;
	}
	ky[0].t = Inf;
	sort(ky+1, ky+1+n, cmpKey);
	sort(click+1, click+1+m, cmpClick);
	sort(posData+1, posData+1+elemCount);
	elemCount = unique(posData+1, posData+elemCount+1) - posData - 1;
	//add keys to the segment tree
	for(int i=1;i<=n;i++)
		Build(1, elemCount, getPos(ky[i].a), getPos(ky[i].b), 1, i);
	//judge
	for(int i=1;i<=m;i++){
		int clickPos = getPos(click[i].pos);
		int t = GetJudgeTime(1, elemCount, clickPos, 1, click[i].t);
		if(t != Inf) Judge(1, elemCount, clickPos, 1, t, click[i].t);
	}
	for(int i=1;i<=n;i++)
		if(!ky[i].ifJudged){
			ky[i].ifJudged = 1;
			ky[i].judgeTime = ky[i].t + 60000;
		}
	sort(ky+1, ky+1+n, cmpJudge);
	for(int i=1;i<=n;i++){
		if(ky[i].ifJudged == 1) missKey++, maxCombo = max(maxCombo, curCombo), curCombo = 0;
		else if(ky[i].ifJudged == 2) curCombo++, goodTap++;
		else if(ky[i].ifJudged == 3) curCombo++, perfectClick++;
	}
	maxCombo = max(maxCombo, curCombo);
	printf("%d %d %d %d", perfectClick, goodTap, missKey, maxCombo);
	return 0;
}
```





---

## 作者：KesdiaelKen (赞：4)

本题只需使用简单数据结构维护即可（似乎叫线段树分治？），当然还有一些细节需要注意。下面分部分分进行解答。

$30\%$

暴力模拟即可。

$50\%$

考虑到$key$的数量比较少，最多产生$5000$次判定，所以先维护$key$出现的位置与时间，然后对于每次点击，判断其位置和时间是否可能击中$key$，不可能则直接$continue$，如果可能则暴力枚举被击中的$key$并将其标记，$key$全部被标记则结束程序。复杂度$O(m+n^2)$，可能维护信息会增加复杂度，但是因为数据水肯定可以过。

$60\%$

类似上面的方法判断点击是否可能击中$key$，但是可以先把$key$按时间排序，用单调队列维护，则被击中的$key$肯定是队头。

$70\%$

用单调队列优化暴力，因为数据十分离散所以枚举次数少，可过。

前$70$分用$n\le5000,m\le114514$的写法即可过。

$100\%$

考虑用线段树优化。我们发现上面的算法时间主要花在判断点击击中的$key$是哪一个。因为$key$是一个线段，我们可以用线段树，将每个$key$的信息分散存在线段树中，每次点击则查询包含这个位置的$key$中最低的那个（用单调队列实现）。这样我们就可以做到用$O(m\log(2n+m))$（$2n+m$为离散化最多会产生的位置数）的复杂度解决此题。

当然，还有一些细节（可能很容易注意到）：浮点数精度很容易炸，要用快读把浮点数转为整数（乘$100000$）再离散化；~~可能是出题人常数比较大~~，用排序离散化比用$map$快了将近$1s$……所以还是要注意一下常数。

总的来说，此题其实是个很基本的线段树优化题，注意细节即可。

代码如下：

```
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<iostream>
using namespace std;
int n,m;
int per=0,goo=0,mis=0,combo=0,maxcom=0;
bool vis[300000]={0};
struct KEY
{
	int t,a,b;
}key[300000];
struct TAP
{
	int t,x;
}tap[300000];
struct LB
{
	int bh,nexty;
}lb[5000000];
int tail[4000000]={0},head[4000000]={0},cnt=0;
int yd=1;int zhi;
inline int min(int&a,int&b){return a<b?a:b;}
struct LS
{
	int num,bh;
}ls[1000000];
bool cmpkey(const KEY&a,const KEY&b){return a.t<b.t;}
bool cmptap(const TAP&a,const TAP&b){return a.t<b.t;}
bool cmpls1(const LS&a,const LS&b){return a.num<b.num;}
bool cmpls2(const LS&a,const LS&b){return a.bh<b.bh;}
void jia(int zuo,int you,int node,int bh)
{
	if(zuo>key[bh].b||you<key[bh].a)return;
	if(key[bh].a<=zuo&&you<=key[bh].b)
	{
		cnt++;
		lb[cnt].bh=bh;lb[cnt].nexty=0;
		lb[tail[node]].nexty=cnt;tail[node]=cnt;
		return;
	}
	int mid=(zuo+you)>>1;
	jia(zuo,mid,node<<1,bh);jia(mid+1,you,node<<1|1,bh);
}
int query(int zuo,int you,int node,int bh)
{
	if(zuo>tap[bh].x||you<tap[bh].x)return 2e9;
	while(head[node]&&vis[lb[head[node]].bh])head[node]=lb[head[node]].nexty;
	if(zuo==you)return key[lb[head[node]].bh].t;
	int mid=(zuo+you)>>1;
	return min(key[lb[head[node]].bh].t,min(query(zuo,mid,node<<1,bh),query(mid+1,you,node<<1|1,bh)));
}
void del(int zuo,int you,int node,int bh)
{
	if(zuo>tap[bh].x||you<tap[bh].x)return;
	while(head[node]&&key[lb[head[node]].bh].t==zhi)
	{
		if(!vis[lb[head[node]].bh])
		{
			vis[lb[head[node]].bh]=true;
			if(60000<=zhi-tap[bh].t)mis++,combo=0;
			if(20000<=zhi-tap[bh].t&&zhi-tap[bh].t<60000)goo++,combo++;
			if(-20000<zhi-tap[bh].t&&zhi-tap[bh].t<20000)per++,combo++;
			if(zhi-tap[bh].t<=-20000)goo++,combo++;
			maxcom=max(maxcom,combo);
		}
		head[node]=lb[head[node]].nexty;
	}
	if(zuo==you)return;
	int mid=(zuo+you)>>1;
	del(zuo,mid,node<<1,bh);del(mid+1,you,node<<1|1,bh);
}
int ch;
inline void dr(int&a)
{
	a=ch=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){a=a*10+ch-'0';ch=getchar();}
	if(ch!='.'){a*=100000;return;}
	ch=getchar();a=a*10+ch-'0';//1
	ch=getchar();if(ch<'0'||ch>'9'){a*=10000;return;}
	a=a*10+ch-'0';//2
	ch=getchar();if(ch<'0'||ch>'9'){a*=1000;return;}
	a=a*10+ch-'0';//3
	ch=getchar();if(ch<'0'||ch>'9'){a*=100;return;}
	a=a*10+ch-'0';//4
	ch=getchar();if(ch<'0'||ch>'9'){a*=10;return;}
	a=a*10+ch-'0';//5
}
int main()
{ 
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		dr(key[i].t);dr(key[i].a);dr(key[i].b);
		ls[i].num=key[i].a;ls[i].bh=i;
		ls[i+n].num=key[i].b;ls[i+n].bh=i+n;
	}
	for(int i=1;i<=m;i++)
	{
		dr(tap[i].t);dr(tap[i].x);
		ls[2*n+i].num=tap[i].x;ls[2*n+i].bh=2*n+i;
	}
	sort(ls+1,ls+2*n+m+1,cmpls1);
	int a=-1,js=0;
	for(int i=1;i<=2*n+m;i++)
	{
		if(a!=ls[i].num)js++;
		a=ls[i].num;ls[i].num=js;
	}
	sort(ls+1,ls+2*n+m+1,cmpls2);
	for(int i=1;i<=n;i++)key[i].a=ls[i].num,key[i].b=ls[i+n].num;
	for(int i=1;i<=m;i++)tap[i].x=ls[2*n+i].num;
	sort(key+1,key+n+1,cmpkey);sort(tap+1,tap+m+1,cmptap);
	key[0].t=2e9;
	for(int i=1;i<=js*4;i++)
	{
		cnt++;lb[cnt].bh=lb[cnt].nexty=0;
		head[i]=tail[i]=cnt;
	}
	for(int i=1;i<=n;i++)jia(1,js,1,i);
	vis[0]=true;
	for(int i=1;i<=m;i++)
	{
		while(yd<=n&&key[yd].t<=tap[i].t-60000)
		{
			if(!vis[yd])vis[yd]=true,mis++,combo=0;
			yd++;
		}
		zhi=query(1,js,1,i);
		if(zhi>=tap[i].t+100000)continue;
		del(1,js,1,i);
	}
	while(yd<=n){if(!vis[yd])vis[yd]=true,mis++,combo=0;yd++;}
	printf("%d %d %d %d\n",per,goo,mis,maxcom);
	return 0;
}
```


---

## 作者：KobeBeanBryantCox (赞：1)

# P5819 【L&K R-03】音游大计算 题解

------------------

[题目传送门](https://www.luogu.com.cn/problem/P5819)。

大常数选手前来报到，实测不开 O2 TLE $4$ 个点并且我卡不过去了，开了能 AC。

代码不算长，4k 以内，用了很多很长的变量名和函数名，改短了的话估计能 3k 以内。

为调试方便，我封装了很多东西。

-----------------

## 题意

你要实现一个类似 phigros 的评判机制。

但是按键大小不统一、判定线不会移动、只有 note 键、且玩家不会读谱只会背谱。

~~鉴定为音游玩多了导致的。~~

具体看题目描述。

---------------

## 思路

不难看出线段树。

### 第一步：辅助内容

```cpp
constexpr int none=0,miss=1,good=2,perfect=3;
```

表示 key 的评判状态。

```cpp
struct Key
{
	int t,l,r,judgetime,state; // 到达判定线的时间，左右端点，被评判的时间，评判状态
	bool operator<(const Key &a)const{return t<a.t;} // 排序用的
}key[N];
```

封装 key。

```cpp
struct Click
{
	int t,pos; // 点击的时间和位置
	bool operator<(const Click &a)const{return t<a.t;} // 排序用的
}click[N];
```

封装每一次点击。

```cpp
struct Discretizing
{
	vector<int>a;
	inline void put(int v){a.push_back(v);} // 插入 v
	inline void init() // 离散化
	{
		sort(a.begin(),a.end());
		a.erase(unique(a.begin(),a.end()),a.end());
	}
	inline int get(int v){return lower_bound(a.begin(),a.end(),v)-a.begin()+1;} // 得到离散化后的值
}pos;
```

封装离散化（通常不会封装离散化，但是这个题太恶心了，我不想把代码写得很乱）。

--------------

### 第二步：读入及初始化

```cpp
inline void init(int n,int m)
{
	for(int i=1;i<=n;i++)
	{
		double t,l,r;cin>>t>>l>>r;
		t=t*1e5+0.5,l=l*1e5+0.5,r=r*1e5+0.5; // 转成整数避免精度误差
		key[i]={t,l,r};
		pos.put(l),pos.put(r); // 放入离散化数组中
	}
	for(int i=1;i<=m;i++)
	{
		double t,p;cin>>t>>p;
		t=t*1e5+0.5,p=p*1e5+0.5; // 转成整数避免精度误差
		click[i]={t,p};
		pos.put(p); // 放入离散化数组中
	}
}
--------------
主函数内：
	int n,m;cin>>n>>m;
	init(n,m);
	sort(key+1,key+n+1),sort(click+1,click+m+1); // 按时间排序
	pos.init(),T.build(1,1,pos.a.size()); // 离散化和构建线段树
	for(int i=1;i<=n;i++)key[i].l=pos.get(key[i].l),key[i].r=pos.get(key[i].r);
	for(int i=1;i<=m;i++)click[i].pos=pos.get(click[i].pos); // 取出离散化后的值
```

-------------

### 第三步：构建线段树及插入所有 key

```cpp
judge 函数内：
	for(int i=1;i<=n;i++)
	{
		int l=key[i].l,r=key[i].r;
		T.addkey(1,l,r,i);
	}
```

以上是插入所有 key。

接下来是线段树的构建。

因为一个区间可能有多个 key，所以每个区间维护一个队列（其他题解说的都是链表，但我觉得队列会合适一点）。

注意到这样并不会消耗很多空间，因为一个区间最多覆盖线段树上 $\log$ 个节点，每个节点的队列长度总和是 $n\log$ 的。

```cpp
struct Seg 内：
	struct node
	{
		int l,r;
		list<int>keyid; // 开 queue 或者手写 queue 都会 MLE，原因放本文最后
		#define push push_back
		#define pop pop_front // 刚开始我写的是 queue MLE 了，后面改成 list 其他的不想改了就 define 一下
		inline void push(int id){keyid.push(id);}
	}tr[(3*N)<<2]; // 3*N 是因为离散化后最多有 2n+m 个点
	#define lc (x<<1)
	#define rc (x<<1|1)
	void build(int x,int l,int r) // 其实没什么用，主要就是求出 tr[x].l 和 tr[x].r，如果写法不一样，可以把 build 删了
	{
		tr[x].l=l,tr[x].r=r;
		if(l==r)return;
		int mid=(l+r)>>1;
		build(lc,l,mid),build(rc,mid+1,r);
	}
	void addkey(int x,const int l,const int r,const int id)
	{
		if(tr[x].l>=l&&tr[x].r<=r)return tr[x].push(id),void(); // 在区间插入编号为 id 的 key
		int mid=(tr[x].l+tr[x].r)>>1;
		if(l<=mid)addkey(lc,l,r,id);
		if(r>mid)addkey(rc,l,r,id);
	}
```

------------------

### 第四步：判定

```cpp
judge 函数内：
	for(int i=1;i<=m;i++)
	{
		int p=click[i].pos,t=T.querytime(1,p,click[i].t); // 查询下一个将在当前点击产生判定的 key 的接触判定线的时间
		if(t!=inf)T.change(1,p,t,click[i].t); // 对接触判定线的时间为 t 的 key 进行评判，如果 t=inf，说明这次点击是一次无效点击
	}
```

以上是对每一个点击所对应的 key 进行判定。

为什么不找到了直接判定，而是要写两个函数呢？

因为题目说了相同时间接触判定线的 key 同时产生判定，这样做刚刚好可以实现。

线段树内的函数是这样的（有点长，慢慢看）：

```cpp
struct Seg 内：
	struct node
	{
		已省去上文讲过的
		inline void pop(int t) // 这个用处是把超过评判时间的和已经评判过的弹出队列
		{
			while(!keyid.empty())
			{
				int id=keyid.front();
				if(key[id].state!=none){keyid.pop();continue;} // 代表评判过了
				// 上一行要写的原因是：当前 id 可能在其他线段树上的节点被评判过了
				if(key[id].t+60000>t)break;
				key[id].judgetime=key[id].t+60000;
				key[id].state=miss; // 产生 miss 判定并且修改判定时间为接触判定线时间+60000
				keyid.pop();
			}
		}
		inline int gettime(int t) // 找到队列中下一个将评判的 key 的时间
		{
			if(keyid.empty())return inf; // 队列为空
			int id=keyid.front();
			if(key[id].t-t>=100000)return inf; // 如果没到可以产生评判的时间，返回 inf
			return key[id].t;
		}
		inline void judge(int t,int judgetime) // 对队列中接触判定线时间为 t 的 key，进行评判，修改判定时间为 judgetime
		{
			for(;!keyid.empty();keyid.pop())
			{
				int id=keyid.front();
				if(key[id].t!=t)break; // 如果接触判定线时间不是 t 了，退出即可
				if(key[id].state!=none)continue; // 评判过的
				key[id].judgetime=judgetime;
				if(abs(key[id].t-judgetime)<20000)key[id].state=perfect; // 根据题目要求判断即可
				else if(abs(key[id].t-judgetime)<60000)key[id].state=good;
				else key[id].state=miss;
			}
		}
	}tr[(3*N)<<2];
	已省去上文讲过的
	int querytime(int x,const int pos,const int t) // 查询下一个将在时间为 t 时产生判定的 key 的接触判定线的时间
	{
		tr[x].pop(t); // 弹出超过时间的和评判过的
		int tim=tr[x].gettime(t); // 找到当前最低的 key 的时间
		// 思路类似于标记永久化，在经过的路径的节点上都要贡献并取 min，因为我们并没有 pushdown 且 pushdown 的时空复杂度过高（需要复制队列）
		if(tr[x].l==tr[x].r)return tim;
		int mid=(tr[x].l+tr[x].r)>>1;
		if(pos<=mid)return min(tim,querytime(lc,pos,t)); // 取 min 是题目要求：只能对离屏幕顶端最远的产生判定
		else return min(tim,querytime(rc,pos,t));
	}
	void change(int x,const int pos,const int t,const int judgetime) // 对接触判定线时间为 t 的 key 评判且修改为 judgetime 的评判时间
	{
		tr[x].judge(t,judgetime); // 直接调用上面的函数即可
		if(tr[x].l==tr[x].r)return;
		int mid=(tr[x].l+tr[x].r)>>1;
		if(pos<=mid)change(lc,pos,t,judgetime);
		else change(rc,pos,t,judgetime);
	}
```

---------------

### 第五步：求出答案

现在已经对所有能评判的 key 都进行了评判，只剩求答案了。

简单，不解释，看代码：

```cpp
inline void getans(int n)
{
	for(int i=1;i<=n;i++)
		if(key[i].state==none) // 可能还有一些没判到，这些一定都是 miss
		{
			key[i].state=miss;
			key[i].judgetime=key[i].t+60000;
		}
	sort(key+1,key+n+1,[](const Key &a,const Key &b)
	{
		if(a.judgetime==b.judgetime)return a.state<b.state;
		return a.judgetime<b.judgetime;
	}); // 要根据判定时间来处理
	int perfect=0,good=0,miss=0,maxcombo=0,sum=0;
	for(int i=1;i<=n;i++)
	{
		if(key[i].state==::miss)miss++,maxcombo=max(maxcombo,sum),sum=0; // 不会有人不知道 :: 的含义吧，这就是取全局变量的意思，一般用在有重名的时候
		if(key[i].state==::good)good++,sum++;
		if(key[i].state==::perfect)perfect++,sum++;
	}
	cout<<perfect<<" "<<good<<" "<<miss<<" "<<max(maxcombo,sum);
	if(perfect==maxcombo&&good==0&&miss==0)cerr<<"AP!"; // All Perfect
	else if(maxcombo==n)cerr<<"FC!"; // Full Combo
}
```

然后捏？没有然后啦，已经做完了喵。

--------------

## AC 代码

不知道为什么我的代码常数那么大，估计是因为封装太多东西导致的。

```cpp
// 好吧，怎么卡都卡不进 3 秒内，常数大选手是这样的，实测不开 O2 TLE
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
constexpr int N=1.2e5+10,inf=1e9;
constexpr int none=0,miss=1,good=2,perfect=3;
struct Key
{
	int t,l,r,judgetime,state;
	bool operator<(const Key &a)const{return t<a.t;}
}key[N];
struct Click
{
	int t,pos;
	bool operator<(const Click &a)const{return t<a.t;}
}click[N];
struct Discretizing
{
	vector<int>a;
	inline void put(int v){a.push_back(v);}
	inline void init()
	{
		sort(a.begin(),a.end());
		a.erase(unique(a.begin(),a.end()),a.end());
	}
	inline int get(int v){return lower_bound(a.begin(),a.end(),v)-a.begin()+1;}
}pos;
struct Seg
{
	struct node
	{
		int l,r;
		list<int>keyid; // 开 queue 或者手写 queue 都会 MLE
		#define push push_back
		#define pop pop_front
		inline void push(int id){keyid.push(id);}
		inline void pop(int t)
		{
			while(!keyid.empty())
			{
				int id=keyid.front();
				if(key[id].state!=none){keyid.pop();continue;}
				if(key[id].t+60000>t)break;
				key[id].judgetime=key[id].t+60000;
				key[id].state=miss;
				keyid.pop();
			}
		}
		inline int gettime(int t)
		{
			if(keyid.empty())return inf;
			int id=keyid.front();
			if(key[id].t-t>=100000)return inf;
			return key[id].t;
		}
		inline void judge(int t,int judgetime)
		{
			for(;!keyid.empty();keyid.pop())
			{
				int id=keyid.front();
				if(key[id].t!=t)break;
				if(key[id].state!=none)continue;
				key[id].judgetime=judgetime;
				if(abs(key[id].t-judgetime)<20000)key[id].state=perfect;
				else if(abs(key[id].t-judgetime)<60000)key[id].state=good;
				else key[id].state=miss;
			}
		}
	}tr[(3*N)<<2];
	#define lc (x<<1)
	#define rc (x<<1|1)
	void build(int x,int l,int r)
	{
		tr[x].l=l,tr[x].r=r;
		if(l==r)return;
		int mid=(l+r)>>1;
		build(lc,l,mid),build(rc,mid+1,r);
	}
	void addkey(int x,const int l,const int r,const int id)
	{
		if(tr[x].l>=l&&tr[x].r<=r)return tr[x].push(id),void();
		int mid=(tr[x].l+tr[x].r)>>1;
		if(l<=mid)addkey(lc,l,r,id);
		if(r>mid)addkey(rc,l,r,id);
	}
	int querytime(int x,const int pos,const int t)
	{
		tr[x].pop(t);
		int tim=tr[x].gettime(t);
		if(tr[x].l==tr[x].r)return tim;
		int mid=(tr[x].l+tr[x].r)>>1;
		if(pos<=mid)return min(tim,querytime(lc,pos,t));
		else return min(tim,querytime(rc,pos,t));
	}
	void change(int x,const int pos,const int t,const int judgetime)
	{
		tr[x].judge(t,judgetime);
		if(tr[x].l==tr[x].r)return;
		int mid=(tr[x].l+tr[x].r)>>1;
		if(pos<=mid)change(lc,pos,t,judgetime);
		else change(rc,pos,t,judgetime);
	}
}T;
inline void init(int n,int m)
{
	for(int i=1;i<=n;i++)
	{
		double t,l,r;cin>>t>>l>>r;
		t=t*1e5+0.5,l=l*1e5+0.5,r=r*1e5+0.5;
		key[i]={t,l,r};
		pos.put(l),pos.put(r);
	}
	for(int i=1;i<=m;i++)
	{
		double t,p;cin>>t>>p;
		t=t*1e5+0.5,p=p*1e5+0.5;
		click[i]={t,p};
		pos.put(p);
	}
}
inline void judge(int n,int m)
{
	for(int i=1;i<=n;i++)
	{
		int l=key[i].l,r=key[i].r;
		T.addkey(1,l,r,i);
	}
	for(int i=1;i<=m;i++)
	{
		int p=click[i].pos,t=T.querytime(1,p,click[i].t);
		if(t!=inf)T.change(1,p,t,click[i].t);
	}
}
inline void getans(int n)
{
	for(int i=1;i<=n;i++)
		if(key[i].state==none)
		{
			key[i].state=miss;
			key[i].judgetime=key[i].t+60000;
		}
	sort(key+1,key+n+1,[](const Key &a,const Key &b)
	{
		if(a.judgetime==b.judgetime)return a.state<b.state;
		return a.judgetime<b.judgetime;
	});
	int perfect=0,good=0,miss=0,maxcombo=0,sum=0;
	for(int i=1;i<=n;i++)
	{
		if(key[i].state==::miss)miss++,maxcombo=max(maxcombo,sum),sum=0;
		if(key[i].state==::good)good++,sum++;
		if(key[i].state==::perfect)perfect++,sum++;
	}
	cout<<perfect<<" "<<good<<" "<<miss<<" "<<max(maxcombo,sum);
	if(perfect==maxcombo&&good==0&&miss==0)cerr<<"AP!";
	else if(maxcombo==n)cerr<<"FC!";
}
int main()
{
	ios::sync_with_stdio(false);cout.tie(0),cin.tie(0);
	int n,m;cin>>n>>m;
	init(n,m);
	sort(key+1,key+n+1),sort(click+1,click+m+1);
	pos.init(),T.build(1,1,pos.a.size());
	for(int i=1;i<=n;i++)key[i].l=pos.get(key[i].l),key[i].r=pos.get(key[i].r);
	for(int i=1;i<=m;i++)click[i].pos=pos.get(click[i].pos);
	judge(n,m),getans(n);
	return 0;
}
```

-------------

## 补充：

STL 的 queue MLE（$10$ 个点）的原因：queue 只有在销毁的时候才会释放内存，而 list 是弹出元素就释放内存。

关于手写 queue（指针版）也 MLE（$5$ 个点），我不知道，有大佬知道原理的可以评论一下。

~~另外，有没有 phigros 大佬带带我这个萌新。~~

---

## 作者：HenghengMoi (赞：0)

[P5819 【L&K R-03】音游大计算](https://www.luogu.com.cn/problem/P5819)

## 题意简述

非常长题目，使人简述不了，爱来自大模拟。

## 题目分析

浮点数小数位数不超过 $5$ 位，大小不超过 $10^4$，乘 $10^5$ 便于后续处理。

首先肯定要将 key 和小 K 的点击按时间排序。对于小 K 的每次点击，寻找满足 $a_i \le x \le b_i$ 的 $t_i$ 最小的若干个 key，判定后删除。key 的实际判定时间与 $t_i$ 可能不同，一边判定一边计算分数会特别麻烦，可以到最后再将 key 按实际判定时间排序后计算。

但是暴力会超时，因为寻找 key 的时间复杂度最坏为 $O(nm)$。

考虑优化。

由于只查询 $m$ 个位置上的 key，对 $x$ 离散化，只维护这 $m$ 个位置的信息即可。

对于每个 key，在 $[a_i, b_i]$ 上修改；对于每次点击，查询 $x_i$ 的信息。

区间修改，单点查询。

使用线段树优化。树上每个节点维护一个链表，每次从链表一端插入 $t_i$ 大的 key，从另一端删除已判定的 $t_i$ 小的 key。

可是在极限数据下，一开始根节点有一条长度为 $n$ 的链（即 $n$ 个 key 都可能被小 K 的任意一次点击判定到），再在 $m$ 个点都分别进行一次询问，那么一条长度为 $n$ 的链就会被下传成 $m$ 条长度为 $n$ 的链，空间复杂度会达到 $O(nm)$。

那干脆就不下传了，只保证单条链内的 $t_i$ 单调。

对于每次插入操作，一旦确定了修改的节点位置，后续就不再上传或下传，一次操作的空间复杂度为 $O(\log{m})$，总空间复杂度 $O(n\log{m})$。

对于每次查询操作，查询从该叶子节点到根节点的路径上链表维护的 $t_{min}$，一次操作的时间复杂度为 $O(\log{m})$，由于 $t_{min}$ 可能相同，最多可能需要 $n + m$ 次查询，总时间复杂度 $O((n + m)\log{m})$。

还可以使用动态开点线段树，这样就最多有 $2m - 1$ 个节点。

大体思路确定了，接下来开始扣细节。

## 代码

首先把 key 和点击的信息塞进结构体里。

```cpp
const int N = 114514;

struct NOTE {
	int t, l, r;
	int judge, judge_t; //判定等级 & 判定时间 
	bool operator < (const NOTE &nt) const {
		return t < nt.t || t == nt.t && l < nt.l || t == nt.t && l == nt.l && r < nt.r;
	}
}note[N + 5];

struct TAP {
	int t, x;
	bool operator < (const TAP &tp) const {
		return t < tp.t;
	}
}tap[N + 5];
``````

输入时 ```double``` 有误差，可以加上 $0.00005$ 之后再乘 $10^5$。

```cpp
double db; 
int n, m;
int a[N + 5], len; //离散化

int main() {
	/**/
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> db;
		db += 0.000005;
		note[i].t = db * 100000;
		cin >> db;
		db += 0.000005;
		note[i].l = db * 100000;
		cin >> db;
		db += 0.000005;
		note[i].r = db * 100000;
	}
	for (int i = 1; i <= m; i++) {
		cin >> db;
		db += 0.000005;
		tap[i].t = db * 100000;
		cin >> db;
		db += 0.000005;
		tap[i].x = db * 100000;
		a[++len] = tap[i].x;
	}
	
	//离散化
	sort(a + 1, a + len + 1);
	len = unique(a + 1, a + len + 1) - a - 1;
	for (int i = 1; i <= m; i++) tap[i].x = lower_bound(a + 1, a + len + 1, tap[i].x) - a;
	/**/
}
``````

分享一个小知识：手写 list 比用 ```std::list``` 快。写一个结构体封装 list，需要实现头插入，尾查询，尾删除，查询是否为空。（虽然用 STL 也慢不了多少）

```cpp
struct LIST {
	
	struct node{
		int val; //权值 
		node* l; //左节点 
		node* r; //右节点 
	}front[2 * N + 5], back[2 * N + 5]; //链表头尾 
	
	void init() { //初始化 
		for (int i = 1; i <= 2 * N; i++) {
			front[i].l = NULL;
			back[i].r = NULL;
			front[i].r = &back[i];
			back[i].l = &front[i];
		}
	}
	
	void push_front(int t, int k) {
		node *p = new node;
		p -> val = k;
		front[t].r -> l = p;
		p -> r = front[t].r;
		front[t].r = p;
		p -> l = &front[t];
	}
	
	void pop_back(int t) {
		node *p = back[t].l;
		p -> l -> r = &back[t];
		back[t].l = p -> l;
		p -> l = NULL;
		p -> r = NULL;
		delete p;
	}
	
	int get_back(int t) {
		return back[t].l -> val;
	}
	
	bool empty(int t) {
		return front[t].r == &back[t];
	}
	
}List;
``````

线段树上甚至不用维护多少信息，直接在链表上操作即可。由于先插入的 key 在删除时不一定在链表尾部，只能打上删除标记，查询时更新。

```cpp
bool vis[N + 5]; //删除标记

struct Segment{
	
	int tot, ls[2 * N + 5], rs[2 * N + 5];
	
	void pushdown(int t) { //很不pushdown的pushdown，删除链表尾部被标记了的key 
		while (!List.empty(t) && vis[List.get_back(t)]) List.pop_back(t);
	}
	
	void build(int l = 1, int r = len, int t = 1) { //动态开点建树 
		if (l == r) return;
		int mid = (l + r) >> 1;
		ls[t] = ++tot;
		build(l, mid, ls[t]);
		rs[t] = ++tot;
		build(mid + 1, r, rs[t]);
	}
	
	void insert(int L, int R, int k, int l = 1, int r = len, int t = 1) {
		if (!t) return;
		if (L <= l && r <= R) {
			List.push_front(t, k);
			return; 
		}
		int mid = (l + r) >> 1;
		if (R <= mid) insert(L, R, k, l, mid, ls[t]);
		else if (L > mid) insert(L, R, k, mid + 1, r, rs[t]);
		else {
			insert(L, R, k, l, mid, ls[t]);
			insert(L, R, k, mid + 1, r, rs[t]);
		}
	}
	
	int query(int p, int l = 1, int r = len, int t = 1) {
		if (!t) return 0;
		pushdown(t);
		int ret = 0;
		if (!List.empty(t)) ret = List.get_back(t);
		if (l == r) return ret;
		int mid = (l + r) >> 1;
		if (p <= mid) {
			int L = query(p, l, mid, ls[t]);
			if (L == 0) return ret;
			else if (ret == 0) return L;
			else if (note[L].t < note[ret].t) return L;
			else return ret;
		}
		else {
			int R = query(p, mid + 1, r, rs[t]);
			if (R == 0) return ret;
			else if (ret == 0) return R;
			else if (note[R].t < note[ret].t) return R;
			else return ret;
		}
	}
	
}tree;
``````

每次点击要判定完重合的 key，记得给已判定的 key 打上删除标记，判定区间的符号不要写错，特判到最后都没有判定到的 key。

```cpp
int L, R; //双指针 
bool vis[N + 5]; //删除标记 
vector<int> ret_notes; //一次判定到的key

int main() {
	/**/
	for (int i = 1; i <= m; i++) {
		while (L <= n && note[L].t < tap[i].t + 100000) { //更新上界
			int l = lower_bound(a + 1, a + len + 1, note[L].l) - a;
			int r = upper_bound(a + 1, a + len + 1, note[L].r) - a - 1;
			tree.insert(l, r, L);
			L++;
		}
		while (R <= L && note[R].t <= tap[i].t - 60000) { //更新下界
			if (!vis[R]) { //落出屏幕前仍未判定
				note[R].judge = 0;
				note[R].judge_t = note[R].t + 60000;
				vis[R] = 1;
			}
			R++;
		}
		int ret = tree.query(tap[i].x);
		if (ret == 0) continue;
		ret_notes.clear();
		int T = note[ret].t;
		while (ret != 0 && note[ret].t == T) { //判定重合的key
			ret_notes.push_back(ret);
			vis[ret] = 1;
			ret = tree.query(tap[i].x);
		}
		T -= tap[i].t;
		int judgement = 0;
		if (T >= 60000) judgement = 0;
		else if (T >= 20000) judgement = 1;
		else if (T > -20000) judgement = 2;
		else judgement = 1;
		for (int j = 0; j < ret_notes.size(); j++) {
			ret = ret_notes[j];
			note[ret].judge = judgement;
			note[ret].judge_t = tap[i].t;
		}
	}
	for (int i = R; i <= n; i++) {
		if (!vis[i]) { //所有点击操作结束后仍未判定
			note[i].judge = 0;
			note[i].judge_t = note[i].t + 60000;
		}
	}
	/**/
}
``````

统计答案前以实际判定时间为第一关键字，判定等级为第二关键字排序。

```cpp
int cnt_judge[3], combo, max_combo; //计算答案

bool cmp(NOTE i, NOTE j) {
	return i.judge_t < j.judge_t || i.judge_t == j.judge_t && i.judge < j.judge;
}

int main() {
	/**/
	//计算答案
	sort(note + 1, note + n + 1, cmp);
	for (int i = 1; i <= n; i++) {
		cnt_judge[note[i].judge]++;
		if (note[i].judge == 0) combo = 0;
		else combo++;
		max_combo = max(max_combo, combo);
	}
	cout << cnt_judge[2] << ' ' << cnt_judge[1] << ' ' << cnt_judge[0] << ' ' << max_combo;
	/**/
}
``````

[完整代码](https://www.luogu.com.cn/paste/m1j27837)

## 后记

~~看到数据这么水天都塌了。~~

一开始链表判空写成 ```return front[t].l == &back[t];```，还是 AC。

欢迎大家用各种神奇妙妙做法 AC。

---


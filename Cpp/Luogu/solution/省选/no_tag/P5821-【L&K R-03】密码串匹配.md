# 【L&K R-03】密码串匹配

## 题目背景

众所周知，小 L 很喜欢用 $123321$ 做密码。每次登陆 Codeforces，都会看见显眼的一行提示：

```text
Your password is extremely weak or has been leaked . Please, change it ASAP. 
(see https://haveibeenpwned.com/)
```

## 题目描述

在被机惨之后，小 L 痛定思痛，决定使用更安全的密码。小 L 设计出了一个可能长达 $200,000$ 位的仅由小写字母构成的密码，并保证没有人能记住，猜出或试出（包括小 L 自己）。

为了防止自己忘记整串密码（不用防止了，已经忘记了），小 L 编写了一个程序，可以存储小 L 的密码串 $T$，但是不能直接输出（因为这个程序可能会被他人使用），小 L 第一次会根据记忆还原出长度为 $l$ 的一个字符串 $P$，后面会根据程序的输出修改 $P$ 的某一位，这个程序可以求出当前猜测串 $P$ 与密码串 $T$ 的相同长度的字串的 **失配度** 。

定义字符 `a` 的值为 $1$，字符 `b` 的值为 $2$，以此类推，字符 `z` 的值为 $26$。定义两个字符串 $s,t$ 的失配度为对应位置上的值相减后的平方。

现在，小 L 想知道他的程序是否正确，请你也编写一个类似的程序。

## 说明/提示

**请注意本题特殊的时间限制。**

**本题数据规模大，请注意常数优化。**

为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。

本题中所有编号从 $1$ 开始。

- Subtask \#1：$30$ 分，保证 $n,m\le 5\times 10^3$；
- Subtask \#2：$30$ 分，保证没有 $2$ 操作；
- Subtask \#3：$40$ 分，保证 $n,m\le 2\times 10^5$。

对于 $100\%$ 的数据，保证 $1\le l\le n,1\le x$。

对于所有 $1$ 操作，保证 $x-1+l\le n$。

对于所有 $2$ 操作，保证 $x\le l$。

### 样例解释

$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$。

$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。

## 样例 #1

### 输入

```
8 5 3
iamangry
anger
1 4
2 2 m
1 2```

### 输出

```
218
238```

# 题解

## 作者：Binary_Search_Tree (赞：6)

题意：给出两个序列$T,P$ 动态修改、询问$\sum\limits_{i=0}^{l-1}(A[i+x]-B[i])^2$的值

$\sum\limits_{i=0}^{l-1}(A[i+x]-B[i])^2=\sum\limits_{i=0}^{l-1}A[i+x]^2+B[i]^2-2A[i+x][Bi]$

如果没有修改操作，翻转A数组或B数组后就是裸的FFT了

- 如果每次操作都暴力修改+FFT时间复杂度显然爆炸

- 如果每次操作都不修改，记下修改序列，询问时加上修改序列的贡献，复杂度仍然爆炸

于是考虑把两种方法结合起来，对操作序列分块

设块的大小为$B$，则做一个块的时间复杂度为$O(S^2+n\log n)$ 总复杂度为$O(mS+\frac{nm\log n}{S})$

$mS=\frac{nm\log n}{S}$即$S=\sqrt{n\log n}$时，复杂度取最小值$O(m\sqrt{nlogn})$

虽然看上去复杂度很大，但是有4s的时限，出题人也友善地提供了各种优化开关。

所以应该是可以过哒~

附代码（有少量卡常):

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#define M 1000005
#define mod 998244353
#define g 3
using namespace std;
int n,ll,m,len=1,L,power3[M],power_inv3[M],rev[M],H,cnt;
int X[M],Y[M],E[M];
long long A[M],B[M],C[M],tmp_A[M],tmp_B[M],len_inv,sum;
long long add(long long u,long long v){return (u+=v)>=mod?u-mod:u;}
long long inv(long long x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}
long long power(long long x,long long y){
	long long ans=1,now=x;
	for (register long long i=y;i;i>>=1,now=now*now%mod)
		if (i&1) ans=ans*now%mod;
	return ans;
}
char get_char(){//快读（字母）
	char c=getchar();
	while (c<'a'||c>'z') c=getchar();
	return c-'a';
}
int read(){//快读（整数)
	char c=getchar();int ans=0;
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') ans=ans*10+c-'0',c=getchar();
	return ans;
}
void Write(long long x){//快速输出
	if (x<10) putchar(x^48);
	else Write(x/10),putchar((x%10)^48);
	return;
}
void NTT(long long *A,int flag){//NTT板子
	for (register int i=0;i<len;i++)
		if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (register int l=1;l<len;l<<=1){
		long long T=(flag==1?power3[l]:power_inv3[l]);
		for (register int i=0;i<len;i+=(l<<1)){
			long long t=1;
			for (register int j=0;j<l;j++,t=t*T%mod){
				long long u=A[i+j],v=A[i+j+l]*t%mod;
				A[i+j]=add(u,v),A[i+j+l]=add(u,mod-v);
			}
		}
	}
	return;
}
void mul(){//多项式乘法
	for (register int i=0;i<len;i++) tmp_B[i]=B[i];NTT(tmp_B,1);
	for (register int i=0;i<len;i++) C[i]=tmp_A[i]*tmp_B[i]%mod;NTT(C,-1);
	for (register int i=0;i<len;i++) C[i]=C[i]*len_inv%mod;
	return;
}
long long query(int x){//处理询问操作
	long long now=C[x+ll-1];x+=ll-1;
	for (register int i=1;i<=X[0];i++) now+=Y[i]*A[x-X[i]];//暴力加上修改块内修改操作贡献
	return sum+E[x]-(x>=ll?E[x-ll]:0)-now*2;
}
int main(){
	n=read(),ll=read(),m=read();H=(int)(pow(n*log2(n),0.5))*3;
	while (len<=n+ll) len<<=1,++L;
	for (register int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<L-1);
	for (register int i=0;i<n;i++) tmp_A[i]=A[i]=get_char(),E[i]=E[i-1]+A[i]*A[i];
	for (register int i=0;i<ll;i++) B[i]=get_char(),sum+=B[i]*B[i];
	for (register int i=0,j=ll-1;i<j;i++,j--) swap(B[i],B[j]);
	for (register int l=1;l<len;l<<=1) 
		power3[l]=power(g,(mod-1)/(l<<1)),power_inv3[l]=power(inv(g),(mod-1)/(l<<1));
	len_inv=inv(len);NTT(tmp_A,1);mul();//对密码串T只需要做一次FFT
	for (register int i=1,opt;i<=m;i++){
		opt=read();
		if (opt==1) Write(query(read()-1)),putchar('\n');
		else {
			X[++X[0]]=ll-read(),Y[++Y[0]]=get_char();
			sum-=B[X[X[0]]]*B[X[X[0]]];
			int tmp=B[X[X[0]]];B[X[X[0]]]=Y[Y[0]],Y[Y[0]]-=tmp;
			sum+=B[X[X[0]]]*B[X[X[0]]];
		}
		if (X[0]==H) mul(),X[0]=Y[0]=0;//块的末尾暴力做NTT
	}
	return 0;
}
```
看完求赞~

---

## 作者：hsfzLZH1 (赞：2)

### 题目大意

令 $a,b,\ldots ,z$ 分别等于 $1,2,\ldots , 26$。给定字符串 $T,P$， $m$ 次操作，每次操作为以下两种之一：

1. 给定 $x$，询问 $\sum_{i=1}^{|P|} (T_{x+i-1}-P_i)^2$ 的值。

2. 给定 $x,c$ ，将 $P_x$ 修改为 $c$ 。

$n,m\le 2\times 10^5$

### Subtask#1

单次操作 $O(|P|)$ 处理，时间复杂度 $O(nm)$ 。

### Subtask#2

没有修改操作。

将所求式子变形得

$\sum_{i=1}^{|P|} (T_{x+i-1}-P_i)^2 =\sum_{i=1}^{|P|} T_{x+i-1}^2-2T_{x+i-1}P_i+P_i^2$

$= \sum_{i=1}^{|P|} T_{x+i-1}^2-2 \sum_{i=1}^{|P|}T_{x+i-1}P_i+\sum_{i=1}^{|P|}P_i^2$

第一项和第三项都很容易通过前缀和求，麻烦的是中间那一项，因为每次询问的 $x$ 都互不相同。

我们将 $P$ 串翻转，记为 $Q$ ，所求即为 $\sum_{i=1}^{|P|} T_{x+i-1}Q_{|P|-i+1}$ 。观察到不论 $i$ 取何值，下标的和总是相同的。这样我们就把所求化成了卷积形式。只需做一次卷积，时间复杂度为 $O(n\log_2 n)$ 。

### Subtask#3

加上修改操作。

对于每次修改操作，如果重新做一次卷积，时间复杂度无法接受。注意到如果我们记下每次的修改操作，对于每次查询操作计算其影响，那么每次查询我们都要遍历之前的所有修改，时间复杂度仍然无法接受，怎么办呢？能不能找到一个同时使用卷积和记录修改操作的方法，同时限制这两种操作的次数呢？

此时就可以 **分块** 了。如果修改操作的数量到达了一个值 $S$ ，则进行一次卷积，并清除之前的修改操作。进行复杂度分析，当 $S=O(\sqrt{n\log_2 n})$ 时，时间复杂度最优，为 $O(n\sqrt{n\log_2 n})$ 。

### 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
//#define int long long
typedef long long ll; 
const int maxn=5000010;
int n,m,s,l,k,t[maxn],p[maxn],P[maxn],op,x,c[maxn],tot,sum[maxn],siz,lg[maxn],cur;
int st[maxn],ss[maxn],pre[maxn],pp[maxn],ppp[maxn],tt[maxn];
char str[maxn],sp[maxn],ch;
const int mod=998244353;
const int r=3;
int ksm(int a,int k)
{
	int ret=1,x=a;
	while(k)
	{
		if(k&1)ret=(ll)ret*(ll)x%mod;
		x=(ll)x*(ll)x%mod;k>>=1;
	}
	return ret;
}
void dft(int a[],int n)
{
	for(int i=0;i<n;i++)if(i<P[i])swap(a[i],a[P[i]]);
	for(int i=1;i<n;i<<=1)
	{
		int wn=ksm(r,(mod-1)/(i<<1));
		for(int j=0;j<n;j+=(i<<1))
		{
			int w=1;
			for(int k=0;k<i;k++)
			{
				int tmp=(ll)w*(ll)a[i+j+k]%mod;
				a[i+j+k]=(a[j+k]-tmp+mod)%mod;
				a[j+k]=(a[j+k]+tmp)%mod;
				w=(ll)w*(ll)wn%mod;
			}
		}
	}
}
void idft(int a[],int n)
{
	for(int i=0;i<n;i++)if(i<P[i])swap(a[i],a[P[i]]);
	for(int i=1;i<n;i<<=1)
	{
		int wn=ksm(ksm(r,(mod-1)/(i<<1)),mod-2);
		for(int j=0;j<n;j+=(i<<1))
		{
			int w=1;
			for(int k=0;k<i;k++)
			{
				int tmp=(ll)w*(ll)a[i+j+k]%mod;
				a[i+j+k]=(a[j+k]-tmp+mod)%mod;
				a[j+k]=(a[j+k]+tmp)%mod;
				w=(ll)w*(ll)wn%mod;
			}
		}
	}
	int inv=ksm(n,mod-2);
	for(int i=0;i<n;i++)a[i]=((ll)a[i]*(ll)inv)%mod;
}
main()
{
	scanf("%d%d%d",&n,&l,&m);
	for(int i=2;i<=n;i++)lg[i]=lg[i/2]+1; 
	siz=(int)sqrt((ll)n*(ll)lg[n]*16ll)+1;
	scanf("%s%s",str,sp);
	for(int i=0;i<n;i++){t[i]=tt[i]=str[i]-'a';sum[i+1]=sum[i]+t[i]*t[i];}
	for(int i=0;i<l;i++)p[i]=pp[i]=ppp[l-i]=sp[l-i-1]-'a',tot+=p[i]*p[i];
	for(s=1,k=0;s<=n+l;s<<=1,k++);
	for(int i=0;i<s;i++)P[i]=(P[i>>1]>>1)|((i&1)<<(k-1));
	dft(t,s);dft(p,s);for(int i=0;i<s;i++)c[i]=(ll)t[i]*(ll)p[i]%mod;idft(p,s);idft(c,s);
	while(m--)
	{
		scanf("%d%d",&op,&x);
		if(op==1)
		{
			int nww=c[x+l-2];
			for(int i=1;i<=cur;i++)
			{
				nww-=(ppp[st[i]]*tt[x+st[i]-2]);
				ppp[st[i]]=ss[i];
				nww+=(ppp[st[i]]*tt[x+st[i]-2]); 
			}
			for(int i=cur;i>=1;i--)ppp[st[i]]=pre[i];
			printf("%d\n",tot-2*nww+(sum[x+l-1]-sum[x-1]));
		}
		else
		{
			scanf(" %c",&ch);
			pre[++cur]=pp[l-x];
			tot-=pp[l-x]*pp[l-x];pp[l-x]=ch-'a';tot+=pp[l-x]*pp[l-x];
			st[cur]=x;ss[cur]=pp[l-x];
			if(cur==siz)
			{
				for(int i=1;i<=cur;i++)p[l-st[i]]=ss[i],ppp[st[i]]=ss[i];
				dft(p,s);for(int i=0;i<s;i++)c[i]=(ll)t[i]*(ll)p[i]%mod;idft(p,s);idft(c,s);
				cur=0;
			}
		}
	}
	return 0;
}
```

---


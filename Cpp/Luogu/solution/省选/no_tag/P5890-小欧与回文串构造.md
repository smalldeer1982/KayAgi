# 小欧与回文串构造

## 题目描述

小欧很喜欢字符串，尤其是只有 `0` 和 `1` 两种字符的回文串。

小欧也喜欢回文串，尤其是有那么一些回文子串但不是很多的串。

小欧更喜欢构造，所以他思考如下问题：

给定正整数 $n$ 和 $k$，保证 $k\le n$，能否构造一个长为 $n$ 的，只含有字符 `0` 和 `1` 的字符串 $S$，使得 $S$ 的本质不同非空回文子串个数恰好为 $k$ 呢？

小欧是构造小鬼，打不过已经爆切十万甚至九万道构造的先辈们，因此他找你帮忙解决这个问题，并希望你在有解时给出任意一个构造。

下面给出一些关于字符串的基本定义，字符串大手子可以跳过不读。

- 对于长为 $n$ 的字符串 $S$，定义 $S_i$ 为字符串 $S$ 的从左至右第 $i$ 个字符，
- 对于长为 $n$ 的字符串 $S$，定义其子串 $S[l;r]\; (1\le l\le r\le n)$ 为将字符 $S_l,S_{l+1},\ldots,S_{r}$ 自左至右拼接形成的字符串。特别地，空串也是 $S$ 的子串。
- 称 $S$ 的两个子串 $S[l_1;r_1]$ 和 $S[l_2;r_2]$ 本质不同，当且仅当 $S[l_1;r_1] \ne S[l_2;r_2]$。
- 对于长为 $n$ 的字符串 $S$，定义它的反串 $S^{T}$ 为将字符 $S_n,S_{n-1},\ldots,S_1$ 自左至右拼接形成的字符串。
- 字符串 $S$ 为回文串，当且仅当 $S=S^{T}$。

## 说明/提示

对于第一组数据，本质不同的回文子串有：`1`，`0`，`101`，`010` 共四个。

### 数据范围与约定

对于 $20\%$ 的数据，$n\le 15$。  
另有 $10\%$ 的数据，$k=n$。  
另有 $20\%$ 的数据，$1000\le n\le 2000$，$k\ge \left\lfloor\dfrac{n}{2}\right\rfloor+100$。  
对于 $100\%$ 的数据，$1 \le T \le 10$，$1\le k\le  n\le 2\times 10^5$。

## 样例 #1

### 输入

```
4
4 4
8 6
15 14
114514 1```

### 输出

```
Yes
0101
No
Yes
010100000111101
No```

# 题解

## 作者：namespace_std (赞：4)

构造的思路是爆搜出来的...

经过推导（或者搜索），我们发现：

**令 $s = 00101100101100101 ... $ （ $001011$ 无限循环），当 $|s|>8$ 时一定存在且仅存在 $8$ 个本质不同的回文串。**

同时，又由于当串为 $000...0$ 时显然本质不同的回文子串个数为 $n$。

我们发现，当字符串长度 $\geq 8$ 时 $n < m$ 的情况才存在解，
而且如果 $n \neq m$，并且 $m < 8$，一定无解。

又由于每在$s$的开头插入一个 $0$ ，就会多出一个回文串 $00...00$，所以我们可以：

$1)$ 对于 $n < 8$ ，我们只需要判断是否满足 $n = m$ 。

$2)$ 对于 $n = 8$ ，特判 $m = 7$ 。这个可以搜一下或者直接手玩。

$3)$ 对于 $n > 8$ ，我们特判掉 $n = m$ 和 $m \leq 8$，然后记 $len = n-m+8$，显然此时有 $8 < len \leq n$。

于是拼接一个长度为 $n - len$ 的全 $0$ 串和一个长度为 $len$ 的形如 $0010110010110 ... $ 的串即可。

AC代码：
```
#include<cstdio>
#include<cstdlib>
int n,m;
char v[1111111];
void constr(int n,int m)
{
	register int i;
    if(m==n)
	{
		puts("Yes");
		for(i=1;i<=n;i++)putchar('0');
		puts("");
		return;
	}if(n==8&&m==7)return(void)puts("Yes\n00101100");
	if(m<8)return(void)puts("No");
	int d=n-m+8;
	puts("Yes");
	for(i=1;i<=d;i+=6)v[i]='0';
	for(i=2;i<=d;i+=6)v[i]='0';
	for(i=4;i<=d;i+=6)v[i]='0';
	for(i=3;i<=d;i+=6)v[i]='1';
	for(i=5;i<=d;i+=6)v[i]='1';
	for(i=6;i<=d;i+=6)v[i]='1';
	for(i=d+1;i<=n;i++)putchar('0');
	v[d+1]=0;
	puts(v+1);
}
void exec()
{
	scanf("%d%d",&n,&m);
	constr(n,m);
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)exec();
}
```

---

## 作者：Rose_Melody (赞：1)

## Solution-P5890 小欧与回文串构造

[题目链接](https://www.luogu.com.cn/problem/P5890)
## 题目分析
这是一道~~很水~~的 **构造** 紫题

经过不断地探索我们发现：

**构造一个字符串子串 $ S=\texttt{‘001011’}$，将其不断循环，当 $|s|>8$ 时，形如 $v=\texttt{‘001011001011.......’}$ 的字符串有且仅有8个回文子串。**

还有，对于长度为 $n$ 的字符串 $\texttt{‘00000...’}$ 显然有 $n$ 个回文子串。

#### 分类讨论
1. 对于 $n<8$ 时，只需判断是否 $n=k$；

2. 当 $n=8$ 时，仅当 $k=7$ 时成立，特判一下即可；

3. 当 $n>8$ 时，当 $k\le8$ 时无解，$n=k$ 时特判掉即可。令 $cnt=n-k+8,8 \le cnt \le n,$ 前缀一段长度为 $n-len$ 的字符串 $\texttt{‘00000...’}$，后接长度为 $len$ 的字符串 $\texttt{‘001011001011.......’}$。在这里可以用 $\bmod $ 处理下标循环。

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=7;
int n,k;
char v[N]={'0','0','1','0','1','1'};
void solve(int len,int sum)//len表示字符串长度，sum表示回文子串个数 
{
    if(len==sum)
	{
		printf("Yes\n");
		for(int i=1;i<=n;i++)printf("0");
		printf("\n");
		return;
	}
	if(len==8&&sum==7){
		puts("Yes\n");
		printf("00101100\n");
		return ;
	}
	if(sum<8){
		printf("No\n");
		return ;
	}//以上皆是特判
	int cnt=len-sum+8;//8<=cnt<=n
	printf("Yes\n");
	for(int i=cnt+1;i<=n;i++){
		printf("0");
	}
	for(int i=0;i<cnt;i++){
		printf("%c",v[i%6]);//用取模来找循环下标
	}
	printf("\n");
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);
		solve(n,k);
	}
	return 0;
}
```

---


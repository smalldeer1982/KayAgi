# [POI 2004] KAG

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/8x4n4ya8.png)

## 说明/提示

对于 $100\%$ 的数据，$1\le k\le10$，$1\le n\le10^4$，$0\le m\le10^5$。

## 样例 #1

### 输入

```
3
3 2
1 2
2 3
4 3
1 2
2 3
3 4
3 3
1 2
2 3
3 1```

### 输出

```
TAK
NIE
TAK
```

# 题解

## 作者：honglan0301 (赞：9)

## 题目分析

一个渐进更优但是在这题数据范围下跟 $O({knm\over \omega})$ 暴力差不多的做法。

首先我们观察 $\text{C-Algae}$ 的性质，发现这两种操作是对称的，所以有：**若 $G$ 为 $\text{C-Algae}$，则 $G$ 的补图也为 $\text{C-Algae}$（反之同理）**，原因是补图可以每次用与原图相反的合并方式造出来。于是我们会了一个暴力做法，即考虑倒推操作，交替进行以下两个拆分步骤，若最终能把图全都拆成单点则说明该图为 $\text{C-Algae}$。

1. 把原图分成多个不连通的子图（求连通块），然后分别检查各个子图。

2. 要么把反图分成多个不连通的子图（求反图连通块），然后分别检查各个子图的反图。

分析时间复杂度。单次操作 $1,2$ 分别是 $O(m)$ 和 $O(n^2-m)$ 的，而操作 $2$ 若能有效会消耗掉至少 $O(n)$ 条边，故至多进行 $O({m\over n})$ 轮，时间复杂度 $O(knm)$。

接下来考虑优化拆分的步骤。发现我们应该不同情况差别对待地对操作 $1,2$ 采取不一样的方式求连通块。操作 $1$ 在稀疏图上可以直接枚举边，单次时间复杂度 $O(n+m)$。而操作 $2$ 的图过于稠密，可以枚举点然后检查不存在的边，因为至多会查到 $m$ 条不存在的边，故单次时间复杂度同样为 $O(n+m)$。由于 $m\leq n^2$，故总时间复杂度 $O(k(n+m)\times{\min(m,n^2)\over n})=O(k(n+m)\sqrt m)$，常数不大，可以通过本题。

## 代码

实现可见下面代码，感觉还算简洁。

```cpp
/*
  author: PEKKA_l  
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <unordered_map>
#include <vector>
using namespace std;
#define pb push_back

int T,n,m,u,v;
vector <int> e[10005];
unordered_map <int,int> s;
bool isb(int x,int y) {if(x>y) swap(x,y); return s.count(x*20000+y);}

int zta[10005],ztb[10005],ztc[10005],cntb,cntc,sza[10005],szc[10005];
int nowb[10005],nxt[20005],frm[20005];

queue <int> Q;
void ins(int k,int x) {nxt[nowb[k]]=x; frm[x]=nowb[k]; nowb[k]=x;}
void del(int x) {nxt[frm[x]]=nxt[x]; frm[nxt[x]]=frm[x]; }
void bfs(int x,int k)
{
	Q.push(x); ztb[x]=cntb; ins(ztb[x],x);
	while(!Q.empty())
	{
		int nr=Q.front(); Q.pop();
		for(auto i:e[nr]) {if(!ztb[i]&&zta[i]==k) {ztb[i]=cntb; Q.push(i); ins(ztb[i],i);}}
	}
}
void bfs2(int x,int k)
{
	Q.push(x); ztc[x]=cntc; szc[cntc]++; del(x);
	while(!Q.empty())
	{
		int nr=Q.front(); Q.pop();
		for(int i=nxt[k+10000];i;i=nxt[i])
		{
			if(!isb(nr,i)) {ztc[i]=cntc; szc[cntc]++; del(i); Q.push(i);}
		}
	}
}
void czc(int k) {while(nxt[k+10000]) {int nr=nxt[k+10000]; cntc++; bfs2(nr,k);}}

signed main()
{
	cin>>T;
	while(T--)
	{
		cin>>n>>m; s.clear(); for(int i=1;i<=n;i++) e[i].clear();
		for(int i=1;i<=m;i++) {cin>>u>>v; if(u>v) swap(u,v); e[u].pb(v); e[v].pb(u); s[u*20000+v]=1;}
		for(int i=1;i<=n;i++) zta[i]=1; sza[1]=n;
		while(1)
		{
			memset(ztb,0,sizeof(ztb)); cntb=0; for(int i=1;i<=n;i++) nowb[i]=i+10000;
			memset(nxt,0,sizeof(nxt)); memset(frm,0,sizeof(frm));
			for(int i=1;i<=n;i++) if(!ztb[i]) {cntb++; bfs(i,zta[i]);}
			memset(ztc,0,sizeof(ztc)); cntc=0; memset(szc,0,sizeof(szc));
			for(int i=1;i<=cntb;i++) czc(i);
			bool yes=1,no=0;
			for(int i=1;i<=n;i++)
			{
				if(sza[zta[i]]==szc[ztc[i]]) no=1;
				if(szc[ztc[i]]>2) yes=0;
			}
			if(no) {cout<<"NIE"<<endl; break;}
			if(yes) {cout<<"TAK"<<endl; break;}
			memcpy(zta,ztc,sizeof(ztc)); memcpy(sza,szc,sizeof(szc));
		}
	}
}
```


---

## 作者：COsm0s (赞：6)

提供一个 $\Theta(n + m)$ 的做法。

我们先来看将原图中的两个点合在一起的条件。

不妨设这两个点为 $A,B$。那么 **$A,B$ 除了连向对方以外的边集相等**。这个结论很好证明。当我们将 $A,B$ 合并之后，下面所有的连边都是两者所共有的，所以边集相等。

对于两个集合相等，不难想到用 hash 求解。我们将每个点的所相连的点集合 hash 一下，不妨设为 $h_i$，那么上面的条件可以被简化为：

+ 当 $A,B$ 之间没有边时，有 $h_A=h_B$。
+ 否则，有 $h_A-w_B=h_B-w_A$ 即 $h_A+w_A=h_B+w_B$，其中 $w$ 为当前点 hash 用的随机权值。

接下来我们将其扩展到集合上，现在有 $A,B$ 两个点集需要合并它们，只需要将前面的 $h$ 和 $w$ 做一遍集合内求和即可。

那么最后只需要所有能合并的点集合并完之后点集大小为 $n$ 即为有解。

具体的，我们维护一个队列，存储点集。

不妨设队头为 $u$，我们只需要判断其 $h_u$ 以及 $h_u+w_u$ 在哈希表中是否出现过，然后进行合并，并放到队尾。如果没有出现过，就将其加入哈希表。

容易发现进入队列的点集最多只有 $O(n)$ 级别。所以复杂度为 $\Theta(n+m)$。


```cpp
int n, m;
ull val[N], sum[N], sum2[N];
queue<int> q;
unordered_map<ull, int> Out, In;
void Solve() {
	cin >> n >> m;
	REP(i, 1, n) val[i] = rnd();
	REP(i, 1, m) {
		int u, v;
		cin >> u >> v;
		sum[u] += val[v], sum[v] += val[u];
	}
	Out.clear(), In.clear();
	REP(i, 1, n) q.emplace(i);
	int cur = n;
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		ull nowOut = sum[u], nowIn = sum[u] + val[u];
		if(Out.count(nowOut)) {
			int p = Out[nowOut];
			cur ++;
			sum[cur] = sum[u];
			val[cur] = val[u] + val[p];
			Out.erase(nowOut), In.erase(val[p] + sum[p]);
			q.push(cur);
		}
		else if(In.count(nowIn)) {
			int p = In[nowIn];
			cur ++;
			sum[cur] = sum[u] - val[p];
			val[cur] = val[u] + val[p];
			Out.erase(sum[p]), In.erase(nowIn);
			q.push(cur);
		}
		else Out[nowOut] = u, In[nowIn] = u;
	}
	if(cur == n * 2 - 1) cout << "TAK\n";
	else cout << "NIE\n";
	REP(i, 1, cur) sum[i] = 0;
}
```
感谢 @cjZYZtcl 的讲解思路。

---

## 作者：Purslane (赞：0)

# Solution

考虑对两种操作进行逆操作。

对于第一种操作，直接把图按连通块分成若干个联通子图。

对于第二种操作，考虑把图按照补图分成若干个联通子图。

如果两种操作都无法实施，那么失败。

如何模拟呢？对于第一种，暴力扫描是 $O(n+m)$ 的；对于第二种，考虑增量：增加节点时，计算该节点和之前已有的所有连通块相连的边数，如果和连通块大小不相等就合并。根据势能分析，这样做也是 $O(n+m)$ 的。

单次复杂度弄明白了，总体复杂度怎么样？

显然操作 $1$ 和 $2$ 是交替进行的，因此可以不考虑操作 $1$ 的复杂度（因为必定伴随一次复杂度几乎相同的操作 $2$）。每完成一次操作 $2$，$m$ 至少减去 $n-1$。考虑 $n$ 是递减的，因此操作最多进行 $O(\sqrt m)$ 层，复杂度为 $O((n+m)\sqrt m)$。

跑得飞快。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e4+10;
int T,n,m,fa[MAXN],sze[MAXN],cnt[MAXN],ans;
vector<int> G[MAXN];
int find(int k) {return (fa[k]==k)?k:(fa[k]=find(fa[k]));}
void merge(int u,int v) {
	u=find(u),v=find(v);
	if(u==v) return ;
	if(sze[u]<sze[v]) swap(u,v);
	fa[v]=u,sze[u]+=sze[v];
	return ;	
}
vector<int> psl[MAXN];
int flg[MAXN];
void solve(vector<int> id) {
	if(id.size()==1) return ;	
	for(auto u:id) flg[u]=1;
	for(auto u:id) fa[u]=u,sze[u]=1,cnt[u]=0;
	for(auto u:id) for(auto v:G[u]) if(flg[v]) merge(u,v);
	for(auto u:id) flg[u]=0;
	int al=0;
	for(auto u:id) al+=(find(u)==u);
	if(al!=1) {
		for(auto u:id) psl[u].clear();
		for(auto u:id) psl[find(u)].push_back(u);
		for(auto u:id) if(find(u)==u) solve(psl[u]);
		return ;
	}
	for(auto u:id) flg[u]=1;
	for(auto u:id) fa[u]=u,sze[u]=1,cnt[u]=0;
	vector<int> bl;
	for(auto u:id) {
		vector<int> nbl;
		for(auto b:bl) cnt[b]=0;
		for(auto v:G[u]) if(flg[v]) cnt[find(v)]++;
		for(auto b:bl) if(cnt[b]!=sze[b]) merge(u,b);
		else nbl.push_back(b);
		nbl.push_back(find(u)),bl=nbl;	
	}
	for(auto u:id) flg[u]=0;
	if(bl.size()!=1) {
		for(auto u:id) psl[u].clear();
		for(auto u:id) psl[find(u)].push_back(u);
		for(auto u:id) if(find(u)==u) solve(psl[u]);
		return ;	
	}
	ans=1;
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		vector<pair<int,int>> vc;
		cin>>n>>m,ans=0;
		ffor(i,1,m) {
			int u,v;
			cin>>u>>v;
			if(u>v) swap(u,v);
			G[v].push_back(u);
		}
		vector<int> al;
		ffor(i,1,n) al.push_back(i);
		solve(al);
		ffor(i,1,n) G[i].clear();
		if(!ans) cout<<"TAK\n";
		else cout<<"NIE\n";
	}
	return 0;
}
```

---


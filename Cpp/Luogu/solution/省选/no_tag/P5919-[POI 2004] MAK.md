# [POI 2004] MAK

## 题目描述

置换就是 $n$ 个元素 $1$ 对 $1$ 的函数映射$p:\{1,2,\ldots,n\}\to\{1,2,\ldots,n\}$，一个置换 $p$ 的 `order` 等于最小的 $k\ge1$，且对所有的 $i=1,2,...,n$ 都满足：
$$p(p(...(p(i))...))=i$$
（共 $k$ 次）


举个例子，对于 $3$ 个元素的 `order` $p(1)=3,p(2)=2,p(3)=1$ 为 $ 2$，因为$p(p(1))=1,p(p(2))=2,p(p(3))=3$。

对于给定的 $n$ 我们想要一个长度为 $n$ 的置换的 `order` 尽量大。比如说长度为 $5$ 的置换的 order 最大为 $6$。

一个例子就是 $p(1)=4,p(2)=5,p(3)=2,p(4)=1,p(5)=3$。

对于所有使得 `order` 最大的置换中，我们要找到字典序最小的那个。

更精确来说，我们说置换 $p$ 小于置换 $r$，即存在一个 $i$，使得对于所有 $j<i$ 都满足 $p(j)=r(j)$ 且 $p(i)<r(i)$。那么对于长度为 $5$ 的置换中最小的那个为 $p(1)=2,p(2)=1,p(3)=4,p(4)=5,p(5)=3$。

## 说明/提示

对于 $100\%$ 的数据，$1\le d\le10$，$1\le n_i\le10^4$。

## 样例 #1

### 输入

```
2
5
14```

### 输出

```
2 1 4 5 3
2 3 1 5 6 7 4 9 10 11 12 13 14 8```

# 题解

## 作者：a326820068122c (赞：5)

这题首先不难想到需要每个置换能形成环才能满足 $p(p(...(p(i))...))=i$ 成立。

然后 order 是所有环大小的 LCM。

令环的大小为 $x_1x_2...x_k$ （这里为了方便令$x_1 \le x_2 \le ... \le x_k$）其实就是把寻找最大的 $lcm(x_1,x_2,...,x_k)$ 使得 $x_1+x_2+...+x_k=n$。

对于先考虑如何让一个固定的 $x_1,x_2,...,x_k$ 使得字典序最小。

由于是字典序，可以考虑贪心，首先对于一组数 $y_1y_2...y_t$ 满足 $y_1 \le y_2 \le ... \le y_t$）形成的环最小是 $y_2,y_3,...,y_t,y_1$,那么对于多个环，每次应该可以会到$y_1$时就回到$y_1$（可以理解成拿最小的一个环进行贪心）。

很显然，一定存在一个最优解使所有 $x$ 互质（假设$\gcd(x_a,x_b)>1$,则必然存在质因数 $p$ 使$p|x_a$且$p|x_b$,不妨令 $x_b$质因数分解中 $p$的指数更大, 则$x_a,x_b$ 可以改成 $x_a/p,x_b,1,1,1...(x_a-x_a/p$ 个 $1$) 使和、LCM 不变，字典序会更优。

然后发现如果一个数 $x$ 含有超过 $2$ 个质因子它一定不优秀,设他的其中两个质因子为 $p,q$ 其必然能写成 $x=p^a*q^b*c$ 其中能保证 $p^a,q^b*c$ 两部分都 $\ge2$ 所以 $p^a*q^b*c\ge p^a+q^b*c$ （若 $a,b\ge2$ 则 $(a-1)(b-1)\ge1$，则$ab\ge a+b$），则 $x$ 可以改成 $p^a,q^b*c$ 使和不变，LCM 不变差，字典序会更优。

综上，$x_1,x_2,...,x_k$ 为 $1$ 或不同质数次方。

于是可以先筛出 $[2,10000]$ 所有的质数，

然后进行带路径记录的分组背包（可以理解成对于每个质数 $p$ 在 $0,1$、$p,p$、$p^2,p^2...$ 中选一个(当然贡献是相乘的，不是平常背包里的相加）。

这里有两个小细节 :

一，可以采用 `long double` 来代替高精度，由于只需比较大小，不需输出，所以不需要那么高的精度（实测可以过）。

二，不难发现比较大的质数并不会被选中，我们可以先让程序用 $[2,10000]$ 所有的质数进行 dp，然后再循环出 $[1,10000]$ 所有数中最大可能用到的最大质数 $p_{\max}$，然后再用 $[2,p_{\max}]$ 所有的质数进行 dp 。

最后放一下代码：

```cpp
#include <bits/stdc++.h>
#define for1(i,n) for(i=1;i<=(n);i++)
#define forlr(i,l,r) for(i=(l);i<=(r);i++)
using namespace std;
typedef long double ld;
const int N=10005,D=10000;
int z[N],cz,n,pre[75][N],T,c[N],cc;
bool b[N];
ld dp[75][N];
int main(){
	int i,j,k;
	forlr(i,2,D){
		if(!b[i]) z[++cz]=i;
		if(cz==72) break;
		for(j=1;z[j]*i<=D;j++){
			b[z[j]*i]=1;
			if(!(i%z[j])) break;
		}
	}
	forlr(i,0,D) dp[0][i]=1;
	for1(j,cz){
		forlr(i,0,D) pre[j][i]=0,dp[j][i]=dp[j-1][i];
		forlr(i,0,D) for(k=z[j];i+k<=D;k*=z[j]) if(dp[j][i+k]<dp[j-1][i]*k)
			pre[j][i+k]=k,dp[j][i+k]=dp[j-1][i]*k;
	}
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);cc=0;
		for(i=cz;i;i--) if(pre[i][n]) n-=(c[++cc]=pre[i][n]);
		sort(c+1,c+cc+1);
		for1(i,n) printf("%d ",i);
		for1(j,cc){
			forlr(k,i,i+c[j]-2) printf("%d ",k+1); 
			printf("%d ",i);i+=c[j];
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：hyman00 (赞：4)

## P5919 题解

首先注意到一个排列 $p$ 的 `order` 等于它的所有环长的 $\operatorname{lcm}$，因为每进行一次置换相当于每个环 `rotate` 一个位置，于是问题转化为求出 $\sum c_i=n$ 使得 $\operatorname{lcm}(c_1,\dots,c_k)$ 最大。

然后考虑这样的问题：要求 `order` 恰好等于 $x$ ，排列最小长度。

假设我们有一组解 $c_1,\dots,c_k$，可以使用调整法得到最优解：

- $c_i=1$，直接删去这个数，这说明不能有 $1$；
- $c_i=\prod_{i=1}^{m}p_i^{k_i},m>1$，可以将它分为所有的 $p_i^{k_i}$，这说明一个数不能有多个不同质因子；
- $c_i=p^{k_1},c_j=p^{k_2},i\ne j,k_1\le k_2$，删去 $c_i$，这说明同一个质因子的幂只会出现一次。

于是设 $x=\prod_{i=1}^{m}p_i^{k_i}$，则最优解为 $\sum p_i^{k_i}$。

由于互质，问题转化为求出 $\sum c_i=n,\gcd(c_1,\dots,c_k)=1$ 使得 $\prod c_i$ 最大。

然后就可以 `dp` 了，考虑 `dp[i][j]` 表示用了前 `i` 个素数，长度上限为 `j` ，最大的答案。

转移枚举当前素数不加入或者加入几次方的，乘起来就行，要记录路径。

这个答案可能很大，但是发现 `dp` 的操作只涉及乘法以及 `max` ，可以对所有数取 `log` 计算，由于本题限制特殊不容易卡精度，`double` 就够用了。

还原路径时还要注意总长度不够要补 1。

最后一个问题就是，知道了所有 $c_i$，怎么构造字典序最小。

考虑从前往后依次填数，最前面肯定贪心填 $2,3,\dots,x,1$ 作为第一个环，然后 $x+2,x+3,\dots,x+y,x+1$ 作为第二个环……

因此把 $c$ 数组从小到大排序然后填进去即可。

复杂度预处理 $O(n\pi(n))$，询问 $O(n)$。

代码

```c++
#define db double
const int N=10004,M=200;
int n;
int isp[N],pr[N],cp;
db cln[N];
vi prp[N];
pair<db,int>dp[M][N];
void pre(){
	rept(i,2,N){
		if(!isp[i]){
			pr[cp]=i;
			prp[cp]=vi(1,0);
			for(int j=i;j<N;j*=i)prp[cp].pb(j);
			cln[cp++]=log(i);
		}
		rep(j,cp){
			if(i*pr[j]>=N)break;
			isp[i*pr[j]]=1;
			if(i%pr[j]==0)break;
		}
	}
	rep(i,M)rep(j,N)dp[i][j]={.0,0};
	rep(i,M-1){
		db cc=cln[i];
		rep(j,N){
			rep(k,sz(prp[i])){
				if(j+prp[i][k]>=N)break;
				Mx(dp[i+1][j+prp[i][k]],{dp[i][j].F+cc*k,prp[i][k]});
			}
		}
	}
}
void run(){
	int n;
	cin>>n;
	int cx=M-1,cy=n;
	vi ans;
	while(cx){
		int k=dp[cx][cy].S;
		if(k)ans.pb(k);
		cx--;cy-=k;
	}
	rep(_,cy)ans.pb(1);
	sort(all(ans));
	int cc=1;
	for(int i:ans){
		rept(j,cc+1,cc+i)cout<<j<<" ";
		cout<<cc<<" ";
		cc+=i;
	}
	cout<<"\n";
}
```

---

## 作者：forgotmyhandle (赞：3)

## 分析

观察题目，发现实际上这个置换构成一堆环，要求所有环长度和为 $n$，然后求这些环长的 $\operatorname{lcm}$ 的最大值。我们先考虑如何最小化一个环的字典序。设环长为 $k$，环上最小的点为 $a$，则最小的字典序一定分别是 $a + 1, a + 2, \cdots, a + k - 1, a$。然后来观察性质。

1. 在合法且 $\operatorname{lcm}$ 相同的方案中，自环个数越多的方案一定更好。设某方案中自环的个数为 $cnt$。首先肯定把所有自环往前扔，不然一定不优。这样两个方案最终排出来一定是 $1, 2, \cdots, cnt_1, \cdots$ 和 $1, 2, \cdots, cnt_2, \cdots$，然后 $cnt$ 的后一项和 $cnt$ 的差就不再是 $1$ 了。根据字典序，可以发现 $cnt$ 更大的更优。

2. 设某最优方案中所有环长为 $x_1, x_2, \cdots, x_n$，则每两个 $x$ 都是互质的。如果有两个 $x$ 不互质，就可以把其中一个除掉它们的 $\gcd$，使得整个方案的 $\operatorname{lcm}$ 不变，而多出来的这些可以全填上自环，这样根据上一个性质，新方案更优。所以最优方案中所有环长两两互质。

3. 最优方案中所有环长一定都只有 $1$ 种质因子。假设某个环长 $x$ 有两种或更多质因子，那我们一定可以把 $x$ 写成 $p^a \times q^b \times c$ 的形式，其中 $p, q$ 为质数，$a, b, c$ 为正整数。注意到此时我们有 $p^a \ge 2$，$q^b \times c \ge 2$。所以我们可以得出 $p^a \times q^b \times c > p^a + q^b \times c$（$a, b > 1 \implies (a - 1)(b - 1) > 0 \implies ab \ge a + b$）。这样我们就可以把一个长度为 $x$ 的环拆成两个长度分别为 $p^a$ 和 $q^b\times c$ 的环，而保证所有数的和变小。这样多出来的这些和我们就又可以拿来当自环，从而根据性质 $1$ 使得答案更优。

这样我们就发现所有答案中的环长一定是 $p^a$ 次方的形式，其中 $p$ 为质数，$a$ 为自然数。这样我们就可以进行一个 dp。先筛出 $10^4$ 以内的所有素数，然后设 $dp[i][j]$ 表示使用了前 $i$ 个素数，所有环长和为 $j$ 时的最大 $lcm$。转移时枚举所有素数，再枚举所有和，然后枚举所有这个素数的次方进行转移，方程为 $dp[i][j] = \max\limits_{k}^{p_i^k \le j} \{ dp[i - 1][j - p_i^k] \times p_i^k \}$，其中 $p_i$ 表示从小往大第 $i$ 个素数。然后由于要输出方案，所以要记录转移路径。

输出方案就是把最优方案中的所有环长搞出来，排个序，从小往大依次往里填即可。

有几个地方要注意：
1. 一个质数可以不选，也可以选择其 $0$ 次方，这两者是不同的。具体见代码。

2. 由于 dp 值可能过于巨大，需要开 long double 存 dp 值。我开的是 long double，所以不知道开 double 能不能过。实际上也可以取对所有 dp 值对数。

3. 虽然 $10^4$ 以内有将近 $3000$ 个素数，但是我们 dp 时只取前 $200$ 个即可通过，否则数组不一定开的下。

## 代码
```cpp
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
const int N = 10000;
int p[100005], pcnt;
bool mark[100005];
void F(int n) {
    for (int i = 2; i <= n; i++) {
        if (!mark[i]) {
            p[++pcnt] = i;
        }
        for (int j = 1; j <= pcnt && i * p[j] <= n; j++) {
            mark[i * p[j]] = 1;
            if (i % p[j] == 0) 
                break;
        }
    }
}
long double f[205][10005];
int g[205][10005];
void ini() {
    F(N);
    f[0][0] = 1;
    pcnt = 200;
    for (int i = 1; i <= pcnt; i++) {
        for (int j = 0; j <= N; j++) { // 不选这个质数
            f[i][j] = f[i - 1][j];
            g[i][j] = 0;
        }
        for (int j = 1; j <= N; j *= p[i]) { // j = 1 即为选 0 次方
            for (int k = j; k <= N; k++) {
                if (f[i - 1][k - j] * j > f[i][k]) 
                    f[i][k] = f[i - 1][k - j] * j, g[i][k] = j;
            }
        }
    }
}
int c[10005], ccnt;
void Answer(int n) {
    int s = n;
    ccnt = 0;
    for (int i = pcnt; i; i--) {
        c[++ccnt] = g[i][s];
        s -= c[ccnt];
    }
    sort(c + 1, c + ccnt + 1);
    int cur = 1;
    for (int i = 1; i <= ccnt; i++) {
        if (c[i] == 0) 
            continue;
        for (int j = 1; j < c[i]; j++) cout << cur + j << " ";
        cout << cur << " ";
        cur += c[i];
    }
    cout << "\n";
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int tc;
    cin >> tc;
    ini();
    while (tc--) {
        int n;
        cin >> n;
        Answer(n);
    }
    return 0;
}
```

---

## 作者：qnqfff (赞：2)

### 思路

容易发现一个排列的 ```order``` 等于置换环大小的 $\operatorname{lcm}$，所以相当于把 $n$ 分成若干个正整数使得他们的的 $\operatorname{lcm}$ 最大，首先质数很优，所以考虑拆成很多 $p^k$ 一定最优，不足可以拆若干个 $1$，于是设 $dp_{i,j}$ 表示考虑到第 $i$ 个质数，和为 $j$ 的最大 $\operatorname{lcm}$，但是你发现无法比较大小，$\ln$ 一下就行了，因为要构造方案，于是还要记录一下最优决策中当前质数选了多少个，但是还有个问题，空间暴了，猜测用到的最大质数不大，打个表发现最多用到第 $70$ 个质数，然后就做完了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){char c=getchar();int p=0,flg=1;while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int T,n,flg[10010],pr[10010],cnt,pre[1310][10010];double dp[75][10010];
void P(){
	for(int i=2;i<=1e4;i++){if(!flg[i]) pr[++cnt]=i;for(int j=1;j<=cnt&&i*pr[j]<=1e4;j++){flg[i*pr[j]]=1;if(!(i%pr[j])) break;}}
	for(int i=1;i<=70;i++) for(int j=0;j<=1e4;j++){
		if(dp[i-1][j]>dp[i][j]) dp[i][j]=dp[i-1][j],pre[i][j]=0;
		for(int k=pr[i],l=1;j+k<=1e4;k*=pr[i],l++) if(dp[i-1][j]+1.*log(pr[i])*l>dp[i][j+k]) dp[i][j+k]=dp[i-1][j]+1.*log(pr[i])*l,pre[i][j+k]=l;
	}
}
void solve(){
	n=read();vector<int>use;for(int i=70;i;i--) if(pre[i][n]){int mul=1;for(int j=1;j<=pre[i][n];j++) mul*=pr[i];use.push_back(mul);n-=mul;}while(n) use.push_back(1),n--;
	sort(use.begin(),use.end());int now=0;for(auto i:use){for(int j=now+2;j<=now+i;j++) cout<<j<<' ';cout<<now+1<<' ';now+=i;}cout<<'\n';
}
signed main(){
	P();cout<<pr[70];T=read();while(T--) solve();
	return 0;
}
```

---


# [POI 1997] 跳

## 题目背景

在一个无限长的棋盘上玩一种跳棋游戏。

## 题目描述

其中棋盘被划分成许多区域，每一个区域中可以放置多个的棋子。

规定某一个区域的编号为 $0$，在它开始往左边连续的区域编号为 $-1,-2,-3,…,$在它的右边连续区域编号为 $1,2,3,…,$ ，若区域 $P$ 有棋子，那么棋子有两种跳法：

- 向左跳：则方格 $P-1$ 和 $ P-2 $ 中应增加一枚棋子，方格 $P$ 中应减少一枚棋子。 

- 向右跳：则方格 $P$ 和 $P+1$ 中应减少一枚棋子，方格 $P+2$ 中应增加一枚棋子。

对于给定的初始棋局，经过若干步跳棋后，总可以找到一种目标，就是任意两个相邻的区域棋子数目不超过 $1$ 。

你的任务是对给定的一种初始棋局，找到最终的目标棋局。

## 说明/提示

对于 $100\%$ 的数据，$1\le n \le 10000$。

## 样例 #1

### 输入

```
2
0 5
3 3```

### 输出

```
-4 -1 1 3 5```

# 题解

## 作者：_LPF_ (赞：5)

[[POI1997] Jump](https://www.luogu.com.cn/problem/P5940)

上古好题，从一个看似毫无关联的问题转化到**斐波那契数列分解**。

- 初始有一个长度无限的空序列，所有整数（无论正负）都可以作为下标。
- 给定 $n$ 个二元组 $(p_i,x_i)$ 表示在数列中 $p_i$ 放上 $x_i$ 个棋子，即 $a_{p_i}\gets a_{p_i}+x_i$。
- 可以无限制的进行两种操作：
  - 选定 $p$，满足 $a_p>0$，操作后 $a_p$ 减 $1$，$a_{p-1},a_{p-2}$ 均加 $1$。
  - 选定 $p$，满足 $a_p,a_{p+1}>0$，操作后 $a_p,a_{p+1}$ 减 $1$，$a_{p+2}$ 加 $1$。
- 求输出一个目标局面，使得 $\forall i,a_i+a_{i+1}\leq 1$。
- $n\leq 10^4,0\leq p_i\leq 10^4, 0\leq x_i\leq 10^8$，注意 $p_i$ 可以有重复。

观察到这题没有 SPJ，所以第一个令人好奇的点就是是否**一定存在唯一解**。

同时直觉上这种构造题需要手玩一些小情况，不妨从某个单个位置有 $2$ 开始：

```plain
number : 1 2 3 4 5
step 0 : 0 0 2 0 0
step 1 : 1 1 1 0 0
step 2 : 1 0 0 1 0
```

再看看对于单个 $3$：

```plain
number : 1 2 3 4 5 6 7
step 0 : 0 0 0 3 0 0 0
step 1 : 0 1 1 2 0 0 0
step 2 : 0 1 0 1 1 0 0
step 3 : 0 1 0 0 0 1 0
```

这样就得到了一个看起来不太靠谱的调整法：

- 对于连续 $>0$ 的两个位置，用基本操作二不断后移。

- 对于 $\geq 3$ 的位置，持续使用**对单个 $3$ 的处理方法**，直至全局都不存在 $\geq 3$。因为每次操作会使全局和 $-1$，所以必定会终止。

- 现在，所有有棋子的位置均不连续，且 $\leq 2$。那么对从右往左对每个 $2$ 使用**对单个 $2$ 的处理方法**。

  每次可能会新增 $2$，那么相当于最右侧的 $2$ 向左平移，传递到最左侧后总会停止。

  也可能会新增 $3$，此时仍然调用对 $3$ 的方法，同样因为全局和 $-1$ 到得出操作次数有限的结论。

当然，调整法的操作次数上限是多少，如何简洁清晰地实现，怎么证明解存在且唯一，等等。都存在一定问题。

此时，不妨换个角度，从**操作过程中的不变量**来观察。

第一种操作是 $p$ 的减少换来 $p-1,p-2$ 的增加，而第二中操作是逆运算。

我们能否给每个位置赋上合适的权值，以得到序列总权值始终不变的结论呢。

答案已经呼之欲出了，当然可以，令 $f_p=f_{p-1}+f_{p-2}$，这是经典的斐波那契数列，完全没有问题。

同时，算出初始序列的权值后，题目的目标也变成了：选出若干不相邻的斐波那契数，使它们的和等于初始序列的权值。

这是经典的斐波那契数列分解问题，可以证明有且仅有唯一解，并且解的构造相对容易，只要从大到小枚举斐波那契数，如果 $f_i\leq$ 当前权值和就直接选择。

> 简单证明：
>
> 这都是基于，对于最大的 $i$ 满足 $f_i\leq v$，$f_i$ 一定存在于 $v$ 的分解当中，这一事实。
>
> 而这又能够通过 $f_1+f_3+\cdots +f_n$ 或 $f_2+f_4+\cdots +f_n$ 均严格 $<f_i$ 这一简单事实来证明。

并且显然通过 单个斐波那契数的拆解（对应于操作 $1$）和 相邻斐波那契数的合并（对应于操作 $2$）能够得到任意目标序列，只要全局和不变。

所以所有问题全部迎刃而解，我们已经得到了一个足够理性，足够正确，有充分证明的完备算法。

最后一个问题，对于序列赋值，$f_0$ 应该从何开始呢？

因为存在负下标，所以在证明的时候选定 $-\infty$ 已经足够，但是在代码实现的时候显然不能这么模糊。

实际上，上面那个不靠谱的调整法或许在这里有了些用处，可以大致观察出平移最左的棋子位置：

- 对单个 $3$ 的处理，每次会使棋子向左平移两位，每次平移后权值和 $/3$，所以大致平移 $2\log_3 v$ 距离，其中 $v$ 是总棋子个数。
- 对单个 $2$ 的处理，同样是使棋子左移两格，但最终对最左侧的棋子的影响是 $O(1)$ 的。

所以从 $-(2\log _3 v+c)$ 开始或许就足够，在考场上的一个 trick 是可以二分这个偏移量。具体的，首先偏移量尽量调大得到准确解，之后尝试缩小并对拍，能过拍就继续调小 QwQ

于是这题就愉快的做完了/se。具体实现上需要实现一个高精度，这里偏移量选的是 $80$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define rep(i, a, b) for(int i = (a); i <= (b); i ++)
#define per(i, a, b) for(int i = (a); i >= (b); i --)
#define Ede(i, u) for(int i = head[u]; i; i = e[i].nxt)
using namespace std;

inline int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') f = (c == '-') ? - 1 : 1, c = getchar();
	while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
	return x * f;
}

const int N = 1e4 + 10;
const ll B = 10000000000ll;
const int D = 80;
int n, a[N], b[N];

struct bigint {
	ll a[500]; int len;
	bigint(int x = 0) {memset(a, 0, sizeof(a)); len = 0; while(x) a[++ len] = x % B, x /= B;}
	bigint operator + (const bigint &p) const {
		bigint q = * this;
		q.len = max(len, p.len);
		rep(i, 1, q.len) {
			q.a[i] += p.a[i];
			q.a[i + 1] += q.a[i] / B, q.a[i] %= B;
		}
		while(q.a[q.len + 1]) q.len ++, q.a[q.len + 1] += q.a[q.len] / B, q.a[q.len] %= B;
		return q;
	}
	bigint operator - (const bigint &p) const {
		bigint q = * this;
		rep(i, 1, q.len) {
			q.a[i] -= p.a[i];
			while(q.a[i] < 0) q.a[i] += B, q.a[i + 1] --;
		}
		while(q.len && ! q.a[q.len]) q.len --;
		return q;
	}
	bigint operator * (const ll &p) const {
		bigint q = * this;
		per(i, q.len, 1) {
			ll cur = q.a[i] * p;
			q.a[i + 1] += cur / B, q.a[i] = cur % B;
		}
		rep(i, 1, q.len) {
			q.a[i + 1] += q.a[i] / B, q.a[i] %= B;
			if(q.a[i + 1] && i == q.len) q.len ++;
		}
		return q;
	}
	bool operator < (const bigint &p) const {
		if(len ^ p.len) return len < p.len;
		per(i, len, 1) if(a[i] ^ p.a[i]) return a[i] < p.a[i];
		return false;
	}
} F1, F2, A;

ll sum[N + 100];

int main() {
	int n = read();
	rep(i, 1, n) a[i] = read() + D, sum[a[i]] += read();
	sort(a + 1, a + n + 1);
	n = unique(a + 1, a + n + 1) - (a + 1);
	
	F1 = bigint(1);
	F2 = bigint(1); int c = 1;
	rep(i, 1, a[n]) {
		if(a[c] == i) A = A + (F2 * sum[a[c]]), c ++;
		swap(F1, F2), F2 = F1 + F2;
	}
	c = a[n] + 1;
	while(F2 < A) swap(F1, F2), F2 = F1 + F2, c ++;

	vector<int> ans;
	while(A.len) {
		if(! (A < F2)) A = A - F2, ans.push_back(c);
		c --, swap(F1, F2), F1 = F1 - F2;
	}
	reverse(ans.begin(), ans.end());
	for(int o : ans) printf("%d ", o - D);
	putchar('\n');
	return 0;
}
```

---

## 作者：__JCY__ (赞：2)

题目传送门：[P5940 \[POI1997\] 跳](https://www.luogu.com.cn/problem/P5940)

# 分析题意

不难发现这道题是没有 SPJ 的，意思是这个有唯一解？对这两个操作重新理解：操作一的意思是将一个 $1$ 拆成 $2$ 个 $1$，操作二的意思是将两个 $1$ 合成 $1$ 个 $2$。也就是说可以把前两个相邻的数合成为一个。这个合并是不是有点斐波那契的意思了。

不妨假设，第 $i$ 个位置是第 $i$ 个斐波那契数。此时就有性质，斐波那契数的和是不变的。因为 $f_{i-2}$ 和 $f_{i-1}$“消失”可以换为一个 $f_i$，所以每次操作后的和是不变的。（消失的对象是将每个位置对印的斐波那契数）。

## 举个例子：

```
位置：    1 2 3 4 5
斐波那契：1 1 2 3 5
棋子个数：5 9 2 4 0 对应位置和：5 * 1 + 9 * 1 + 2 * 2 + 3 * 4 + 5 * 0 = 30
```

### 经过一次操作（$i = 3$ 操作二）

```
位置：    1 2 3 4 5
斐波那契：1 1 2 3 5
棋子个数：5 9 1 3 1 对应位置和：5 * 1 + 9 * 1 + 1 * 2 + 3 * 3 + 1 * 5 = 30
```

### 再经过一次操作（$i = 3$ 操作一）

```
位置：    1 2  3 4 5
斐波那契：1 1  2 3 5
棋子个数：6 10 2 3 1 对应位置和：6 * 1 + 10 * 1 + 2 * 2 + 3 * 3 + 1 * 5 = 30
```

这里只是给出例子证明，没有严格证明，但是因该很好想。

最后，我们只需要构造一个不相邻的数列满足对应的斐波那契额数和跟原数列相等即可。Zeckendor 定理说明分解唯一，即大到小，能放就放。

# 代码实现

斐波那契增长速度非常快，所以需要高精度；因为位置有负数，所以需要偏移一个数，因为斐波那契增长速度非常快，所以这个偏移量不用很大。

```cpp
// __JCY__ | 20241210

#include <bits/stdc++.h>

using namespace std;
using LL = long long;

const int kMaxN = 2e6 + 520, D = 1314; // D 是偏移量

//高精度
class Bigint{public:Bigint(long long=0);Bigint(const string&);Bigint(const char*str){*this=string(str);}Bigint&operator=(long long num){return*this=Bigint(num);}Bigint&operator=(const string&str){return*this=Bigint(str);}Bigint&operator=(const char*str){return*this=Bigint(str);}bool operator<(const Bigint&obj)const{return cmp(obj)<0;}bool operator>(const Bigint&obj)const{return cmp(obj)>0;}bool operator<=(const Bigint&obj)const{return cmp(obj)<=0;}bool operator>=(const Bigint&obj)const{return cmp(obj)>=0;}bool operator==(const Bigint&obj)const{return cmp(obj)==0;}bool operator!=(const Bigint&obj)const{return cmp(obj)!=0;}Bigint operator+()const{return*this;}Bigint operator-()const{return Bigint(-sign_,val_);}Bigint operator+(const Bigint&)const;Bigint operator-(const Bigint&)const;Bigint operator*(const Bigint&)const;Bigint operator/(const Bigint&)const;Bigint operator%(const Bigint&)const;Bigint&operator+=(const Bigint&obj){return*this=*this+obj;}Bigint&operator-=(const Bigint&obj){return*this=*this-obj;}Bigint&operator*=(const Bigint&obj){return*this=*this*obj;}Bigint&operator/=(const Bigint&obj){return*this=*this/obj;}Bigint&operator%=(const Bigint&obj){return*this=*this%obj;}Bigint&operator++(){return*this+=1;}Bigint&operator--(){return*this-=1;}Bigint operator++(int);Bigint operator--(int);friend istream&operator>>(istream&,Bigint&);friend ostream&operator<<(ostream&,const Bigint&);protected:enum div_type{division,remainder};enum cmp_type{with_sign,without_sign};static const int base_=(int)1e4;static const int width_=4;Bigint(int s,const vector<int>&v):sign_(s),val_(v){}int cmp(const Bigint&,cmp_type=with_sign)const;Bigint&delZero();Bigint&add(const Bigint&);Bigint&sub(const Bigint&);Bigint&mul(const Bigint&,const Bigint&);Bigint&div(Bigint&,Bigint,div_type=division);private:int sign_;vector<int>val_;};Bigint::Bigint(long long num):sign_(0){if(num<0)sign_=-1,num=-num;else if(num>0)sign_=1;do{val_.push_back(num%base_);num/=base_;}while(num);}Bigint::Bigint(const string&str){sign_=str[0]=='-'?-1:1;int be=str[0]=='-'?1:0,en=str.size();while((en-=width_)>=be){stringstream ss(str.substr(en,width_));int temp;ss>>temp;val_.push_back(temp);}if((en+=width_)>be){stringstream ss(str.substr(be,en-be));int temp;ss>>temp;val_.push_back(temp);}delZero();}Bigint Bigint::operator+(const Bigint&obj)const{if(sign_*obj.sign_==1){Bigint temp;return cmp(obj,without_sign)>=0?(temp=*this).add(obj):(temp=obj).add(*this);}else if(sign_*obj.sign_==-1)return*this- -obj;else return sign_==0?obj:*this;}Bigint Bigint::operator-(const Bigint&obj)const{if(sign_*obj.sign_==1){Bigint temp;return cmp(obj,without_sign)>=0?(temp=*this).sub(obj):(temp=-obj).sub(*this);}else if(sign_*obj.sign_==-1)return*this+-obj;else return sign_==0?-obj:*this;}inline Bigint Bigint::operator*(const Bigint&obj)const{Bigint temp;return(temp.sign_=sign_*obj.sign_)==0?temp:temp.mul(*this,obj);}inline Bigint Bigint::operator/(const Bigint&obj)const{Bigint temp,mod=*this;return cmp(obj,without_sign)<0||(temp.sign_=sign_*obj.sign_)==0?temp:temp.div(mod,obj);}inline Bigint Bigint::operator%(const Bigint&obj)const{Bigint temp,mod=*this;return cmp(obj,without_sign)<0||(temp.sign_=sign_)==0?mod:temp.div(mod,obj,remainder);}inline Bigint Bigint::operator++(int){Bigint temp=*this;++*this;return temp;}inline Bigint Bigint::operator--(int){Bigint temp=*this;--*this;return temp;}inline istream&operator>>(istream&in,Bigint&obj){string str;if(in>>str)obj=str;return in;}ostream&operator<<(ostream&out,const Bigint&obj){if(obj.sign_==-1)cout<<'-';out<<obj.val_.back();for(int i=obj.val_.size()-2;i>=0;i--)out<<setw(Bigint::width_)<<setfill('0')<<obj.val_[i];return out;}int Bigint::cmp(const Bigint&obj,cmp_type typ)const{if(typ==with_sign&&sign_!=obj.sign_)return sign_-obj.sign_;int sign=typ==with_sign?sign_:1;if(val_.size()!=obj.val_.size())return sign*(val_.size()-obj.val_.size());for(int i=val_.size()-1;i>=0;i--)if(val_[i]!=obj.val_[i])return sign*(val_[i]-obj.val_[i]);return 0;}inline Bigint&Bigint::delZero(){while(val_.back()==0&&val_.size()>1)val_.pop_back();if(val_.back()==0)sign_=0;return*this;}Bigint&Bigint::add(const Bigint&obj){int ts=val_.size(),os=obj.val_.size();for(int i=0;i<os;i++)val_[i]+=obj.val_[i];val_.push_back(0);for(int i=0;i<ts;i++)if(val_[i]>=base_)val_[i]-=base_,++val_[i+1];return delZero();}Bigint&Bigint::sub(const Bigint&obj){int pos=obj.val_.size();for(int i=0;i<pos;i++)if((val_[i]-=obj.val_[i])<0)val_[i]+=base_,--val_[i+1];while(val_[pos]<0)val_[pos]+=base_,--val_[++pos];return delZero();}Bigint&Bigint::mul(const Bigint&a,const Bigint&b){int as=a.val_.size(),bs=b.val_.size();val_.resize(as+bs);for(int i=0;i<as;i++)for(int j=0;j<bs;j++){int x=i+j;val_[x]+=a.val_[i]*b.val_[j];val_[x+1]+=val_[x]/base_;val_[x]%=base_;}return delZero();}Bigint&Bigint::div(Bigint&a,Bigint b,div_type typ){int move=a.val_.size()-b.val_.size();val_.resize(move+1);b.val_.insert(b.val_.begin(),move,0);for(int i=move;i>=0;i--){int left=0,right=base_;while(left+1<right){int mid=(left+right)>>1;if(a.cmp(b*Bigint(mid),without_sign)>=0)left=mid;else right=mid;}val_[i]=left;a.sub(b*Bigint(left));b.val_.erase(b.val_.begin());}return typ==division?delZero():a;}

int a[kMaxN], sum[kMaxN], n, cnt = 1;
Bigint f1 = 1, f2 = 1, ret;
vector<int> ans;

int main() {
    cin >> n;
    for (int i = 1, x; i <= n; i++) {
        cin >> a[i] >> x, a[i] += D, sum[a[i]] += x, cnt = max(cnt, a[i]);
    }
    sort(a + 1, a + n + 1), n = unique(a + 1, a + n + 1) - (a + 1); //排序
    for (int i = 0; i <= a[n]; i++) {
        if (sum[i]) { //计算当前位置的斐波那契额和
            ret += (f2 * sum[i]);
        }
        swap(f1, f2), f2 = f1 + f2;
    }
    for (; f1 < ret; swap(f1, f2), f2 = f1 + f2, cnt++);
    for (; ~cnt; cnt--) { //贪心放
        if (ret >= f2) {
            ret = ret - f2, ans.push_back(cnt);
        }
        swap(f1, f2), f1 = f1 - f2;
    }
    sort(ans.begin(), ans.end());
    for (auto v : ans) {
        cout << v - D + 1 << ' ';
    }
    return 0;
}
```

---

## 作者：Z1qqurat (赞：1)

tag: 模拟，Zeckendorf 表示。

solve time: 4h.

一开始没有注意到输入的位置可能有重复的，拍了好久才拍出来，被坑飞了/ll。

发现这题没有 SPJ 的时候就觉得很奇怪，这真的保证是唯一解吗？手玩感觉一直把 $\ge 2$ 的数往右边推会操作次数比较少。不过题目操作次数没有要求，试着直接观察目标局面的形式以及操作的特点。

设格子 $i$ 内的棋子数为 $w_i$，那么要么可以 $w_i\gets w_i-1,w_{i-1}\gets w_{i-1}+1,w_{i-2}\gets w_{i-2}+1$，要么可以 $w_i\gets w_i+1,w_{i-1}\gets w_{i-1}-1,w_{i-2}\gets w_{i-2}-1$，考虑每次操作后的不变量。如果能给每个位置赋一个权值 $f$，使得操作前后 $\sum f_i w_i$ 不变，那么就转化为一个类似于整数拆分的问题。容易想到令 $f$ 为 Fibonacci 数列，最终局面相当于求一个数 $s=\sum f_i w_i$ 的 Zeckendorf 表示。

> Zeckendorf's Theorem: 一个正整数 $x$ 一定可以被**唯一**表示为若干个**不相邻的** Fibonacci 数之和。
> 
> 证明是平凡的。考虑归纳构造，找出 $f_n\le s< f_{n+1}$，那么取出 $f_n$ 作为 $s$ 的 Zeckendorf 表示的一项，$s'=s-f_n<f_{n+1}-f_n<f_{n-1}$，而由归纳有 $s'$ 一定可以表示出来，并且 $s'<f_{n-1}$ 所以一定存在一组表示并且没有相邻项，同时也顺带证明了 Zeckendorf 表示的唯一性。

直接求 Zeckendorf 表示。但是位置 $i$ 可以是负数，所以需要把 Fibonacci 数列偏移若干位之后才是 $f$。$f$ 必须要用高精度存储（涉及高精度加法、减法、比大小以及高精度乘 int），位数达到了 $2100$ 左右，所以肯定不能把每个位置的 $f$ 都存在数组里面，具体就在循环的时候维护最近的两项 Fibonacci 数。注意一些剪枝优化。

```cpp
#include <bits/stdc++.h>

#define ALL(v) begin(v), end(v)
#define All(v, l, r) &v[l], &v[(r) + 1]
using i64 = int64_t;
using u64 = uint64_t;
using db = double;
using std::cin;
using std::cout;

constexpr int N = 2e4, D = 100;

int n;
std::array<i64, N> w;

struct Bigint {
   int len;
   std::array<i64, 2500> a;
   Bigint() {}
   Bigint(int l, i64 x) {
      len = l, std::fill(ALL(a), 0);
      for (int i = 0; i <= l; ++i) a[i] = x % 10, x /= 10;
   }
   void init(int l, i64 x) {
      len = l;
      for (int i = 0; i <= l; ++i) a[i] = x % 10, x /= 10;
   }

   bool operator<= (const Bigint y) {
      if (len != y.len) return len < y.len;
      for (int i = len; ~i; --i) {
         if (a[i] < y.a[i]) return true;
         if (a[i] > y.a[i]) return false;
      }
      return true;
   }
   Bigint operator+ (const Bigint y) {
      Bigint z(std::max(len, y.len) + 5, 0);
      for (int i = 0; i <= z.len; ++i) {
         z.a[i] += a[i] + y.a[i];
         if (z.a[i] > 9) z.a[i] -= 10, z.a[i + 1]++;
      }
      while (z.a[z.len] == 0) --z.len;
      return z;
   }
   friend void operator+= (Bigint &x, const Bigint y) {
      x = x + y;
   }
   Bigint operator- (const Bigint y) {
      Bigint z(std::max(len, y.len), 0);
      for (int i = 0; i <= z.len; ++i) {
         z.a[i] += a[i] - y.a[i];
         if (z.a[i] < 0) {
         	i64 k = (-z.a[i] - 1) / 10 + 1;
         	z.a[i] += 10 * k, z.a[i + 1] -= k;
			}
      }
      while (z.a[z.len] == 0) --z.len;
      return z;
   }
   friend void operator-= (Bigint &x, const Bigint y) {
      x = x - y;
   }
   Bigint operator* (const i64 y) {
      Bigint z(len + 20, 0);
      for (int i = 0; i <= z.len; ++i) {
         z.a[i] += a[i] * y;
         i64 k = z.a[i] / 10;
         z.a[i] -= k * 10, z.a[i + 1] += k;
      }
      while (z.a[z.len] == 0) --z.len;
      return z;
   }
   friend void operator*= (Bigint &x, const i64 y) {
      x = x * y;
   }
   
   void print() { 
   	for (int i = len; ~i; --i) cout << a[i];
	}
} s, f0, f1;

std::array<i64, N> val;

int main() {
   std::ios::sync_with_stdio(false);
   cin.tie(nullptr), cout.tie(nullptr);

   cin >> n, f0.init(0, 1), f1.init(0, 1);
   int mx = 0;
   for (int i = 1, x, y; i <= n; ++i)
      cin >> x >> y, val[x + D] += y, mx = std::max(mx, x + D);
   for (int i = 2; i <= mx; ++i) {
   	std::swap(f0, f1), f1 += f0;
   	if (val[i]) s += f1 * val[i];
	}
	while (f1 <= s) std::swap(f0, f1), f1 += f0, mx++;
   std::vector<int> ans;
   for (int i = mx; ~i; --i) {
   	if (!s.len && !s.a[0]) break;
      if (f1 <= s) s -= f1, ans.emplace_back(i - D);
		std::swap(f0, f1), f0 -= f1;
	}
	std::reverse(ALL(ans));
   for (int i : ans) cout << i << ' ';
   cout << "\n";
   return 0;
}

---

## 作者：Zi_Gao (赞：1)

## 前言

挺有意思的题，记录一下。

## 正文

### 分析题目

简化一下题意，有一个无限长的的数组，从负无穷到正无穷，然后初始这个数组上一些点有一些数，现在可以使用两种操作让这个数组任意两个相邻的数的和不超过一，首选选择一个下标 $p$：

1. 让 $a_p$ 加一，$a_{p-1},a_{p-2}$ 减一。

2. 让 $a_p$ 减一，$a_{p-1},a_{p-2}$ 加一。

首先这两个操作是互逆的。然后这个操作会给人一种感觉，就是 $p-1,p-2$ 位置上的数各取一，和一个 $p$ 位置取一是等价的。所以可以花费 $p-1,p-2$ 位置各减去一作为代价，让 $p$ 位置加上一，另一个操作同理。

那就给每个位置钦定一个权值 $w_p$ 可以满足这样的条件，肯定有 $w_p=w_{p-1}+w_{p-2}$，即斐波那契数列。这样每次操作后数组的带权和不变，我们令这个值是 $s$，那么结束状态就是把 $s$ 拆分成不同且不相邻的一些斐波那契数之和，所以把问题转化为求一个数的斐波那契拆解（我也不知道这个叫什么）。

求解方法很简单，每次减去小于等于这个数的最大斐波那契数即可。为什么这样是对的呢，用归纳法证明，首先 $s$ 是一或者二可以直接拆解，那么设当前已知分解方法的最大的数是 $n$，现在来分解 $n+1$，找到的小于等于 $n+1$ 的最大斐波那契数是 $f$，那么 $n+1-f\leq n$ 所以一定能拆解下去。那么可不可能分解出来有相邻的数呢？不可能，假设分解出 $fib_{i-1}$ 和 $fib_i$，再找最大的斐波那契数的时候就会找 $fib_{i+1}$ 了，而不是这两个。

### 代码实现

由于需要高精，建议使用 python 实现，并且钦定权值要从小一点的地方开始钦定，这里建议是 $-100$。

```python
B=100
n=int(input())

pos=[0]*100010
val=[0]*100010
fib=[0]*200010
fib[0]=fib[1]=1
res=[]

sumFib=0
cnt=0

minp=0x3f3f3f3f
maxp=0

for i in range(0,n):
    [pos[i],val[i]]=map(int,input().split())
    maxp=max(pos[i],maxp)
    minp=max(pos[i],minp)
    
cnt=maxp+B
for i in range(2,cnt+1):
    fib[i]=fib[i-1]+fib[i-2]

for i in range(0,n):
    sumFib+=fib[pos[i]+B]*val[i]

while fib[cnt]<sumFib:
    fib[cnt+1]=fib[cnt]+fib[cnt-1]
    cnt+=1

while sumFib>0:
    while fib[cnt]>sumFib:
        cnt-=1
    res.append(cnt-B)
    sumFib-=fib[cnt]

res.reverse()

print(*res)
```

---

## 作者：TH911 (赞：0)

> [题目传送门](https://www.luogu.com.cn/problem/P5940)

# 题意分析

观察棋子的跳法，不难想到斐波那契数列（本文中“斐波那契数列”均将下标视为无限延伸）。

设斐波那契数列第 $i$ 项为 $f_i$，满足 $f_i=f_{i-1}+f_{i-2}$。

因此可以想到每一个位置都对应斐波那契数列中的某一项。设位置 $i$ 的棋子数量为 $\textit{cnt}_i$。

则两种跳法对应：

* 向左跳：
  
  $$
  \textit{cnt}_{p-2}\leftarrow\textit{cnt}_{p-2}+1\\
  \textit{cnt}_{p-1}\leftarrow\textit{cnt}_{p-1}+1\\
  \textit{cnt}_p\leftarrow\textit{cnt}_p-1\\
  $$
  
  可以发现，这即将 $f_p$ 转化为 $f_{p-1},f_{p-2}$。
  
* 向右跳：同理，将 $f_{p-1},f_{p-2}$ 转化为 $f_p$。

那么，题目即要求我们**构造一组互不相邻的斐波那契数**。

容易发现，这些斐波那契数的**总和不变**，因此可以算出来记作 $g$。

想要构造互不相邻的斐波那契数，可以考虑**贪心**。**从大到小枚举**斐波那契数 $f_k$，若 $g\geq f_k$ 就分配一个 $k$，同时令 $g\leftarrow g-f_k$。

这样贪心一定能构造一组解。考虑反证。

假设 $g\geq f_{k},g-f_k\geq f_{k-1}$。那么就有 $g\geq f_k+f_{k-1}=f_{k+1}$，那么就不会分配 $k-1,k$ 而是分配 $k+1$。

又因为 $f_i$ 有无穷多个，因此这样一定可以分配完 $g$。

***

当然，在实际代码中，下标非负。因此需要一个偏移量。

同时，这题需要一个高精度。

# AC 代码

复制了一个完整的高精度模板，因此有些长。

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
struct BigIntTiny {
    int sign;
    std::vector<int> v;

    BigIntTiny() : sign(1) {}
    BigIntTiny(const std::string &s) { *this = s; }
    BigIntTiny(int v) {
        char buf[21];
        sprintf(buf, "%d", v);
        *this = buf;
    }
    void zip(int unzip) {
        if (unzip == 0) {
            for (int i = 0; i < (int)v.size(); i++)
                v[i] = get_pos(i * 4) + get_pos(i * 4 + 1) * 10 + get_pos(i * 4 + 2) * 100 + get_pos(i * 4 + 3) * 1000;
        } else
            for (int i = (v.resize(v.size() * 4), (int)v.size() - 1), a; i >= 0; i--)
                a = (i % 4 >= 2) ? v[i / 4] / 100 : v[i / 4] % 100, v[i] = (i & 1) ? a / 10 : a % 10;
        setsign(1, 1);
    }
    int get_pos(unsigned pos) const { return pos >= v.size() ? 0 : v[pos]; }
    BigIntTiny &setsign(int newsign, int rev) {
        for (int i = (int)v.size() - 1; i > 0 && v[i] == 0; i--)
            v.erase(v.begin() + i);
        sign = (v.size() == 0 || (v.size() == 1 && v[0] == 0)) ? 1 : (rev ? newsign * sign : newsign);
        return *this;
    }
    std::string to_str() const {
        BigIntTiny b = *this;
        std::string s;
        for (int i = (b.zip(1), 0); i < (int)b.v.size(); ++i)
            s += char(*(b.v.rbegin() + i) + '0');
        return (sign < 0 ? "-" : "") + (s.empty() ? std::string("0") : s);
    }
    bool absless(const BigIntTiny &b) const {
        if (v.size() != b.v.size()) return v.size() < b.v.size();
        for (int i = (int)v.size() - 1; i >= 0; i--)
            if (v[i] != b.v[i]) return v[i] < b.v[i];
        return false;
    }
    BigIntTiny operator-() const {
        BigIntTiny c = *this;
        c.sign = (v.size() > 1 || v[0]) ? -c.sign : 1;
        return c;
    }
    BigIntTiny &operator=(const std::string &s) {
        if (s[0] == '-')
            *this = s.substr(1);
        else {
            for (int i = (v.clear(), 0); i < (int)s.size(); ++i)
                v.push_back(*(s.rbegin() + i) - '0');
            zip(0);
        }
        return setsign(s[0] == '-' ? -1 : 1, sign = 1);
    }
    bool operator<(const BigIntTiny &b) const {
        return sign != b.sign ? sign < b.sign : (sign == 1 ? absless(b) : b.absless(*this));
    }
    bool operator==(const BigIntTiny &b) const { return v == b.v && sign == b.sign; }
    BigIntTiny &operator+=(const BigIntTiny &b) {
        if (sign != b.sign) return *this = (*this) - -b;
        v.resize(std::max(v.size(), b.v.size()) + 1);
        for (int i = 0, carry = 0; i < (int)b.v.size() || carry; i++) {
            carry += v[i] + b.get_pos(i);
            v[i] = carry % 10000, carry /= 10000;
        }
        return setsign(sign, 0);
    }
    BigIntTiny operator+(const BigIntTiny &b) const {
        BigIntTiny c = *this;
        return c += b;
    }
    void add_mul(const BigIntTiny &b, int mul) {
        v.resize(std::max(v.size(), b.v.size()) + 2);
        for (int i = 0, carry = 0; i < (int)b.v.size() || carry; i++) {
            carry += v[i] + b.get_pos(i) * mul;
            v[i] = carry % 10000, carry /= 10000;
        }
    }
    BigIntTiny operator-(const BigIntTiny &b) const {
        if (b.v.empty() || b.v.size() == 1 && b.v[0] == 0) return *this;
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) return -(b - *this);
        BigIntTiny c;
        for (int i = 0, borrow = 0; i < (int)v.size(); i++) {
            borrow += v[i] - b.get_pos(i);
            c.v.push_back(borrow);
            c.v.back() -= 10000 * (borrow >>= 31);
        }
        return c.setsign(sign, 0);
    }
    BigIntTiny operator*(const BigIntTiny &b) const {
        if (b < *this) return b * *this;
        BigIntTiny c, d = b;
        for (int i = 0; i < (int)v.size(); i++, d.v.insert(d.v.begin(), 0))
            c.add_mul(d, v[i]);
        return c.setsign(sign * b.sign, 0);
    }
    BigIntTiny operator/(const BigIntTiny &b) const {
        BigIntTiny c, d;
        BigIntTiny e=b;
        e.sign=1;

        d.v.resize(v.size());
        double db = 1.0 / (b.v.back() + (b.get_pos((unsigned)b.v.size() - 2) / 1e4) +
                           (b.get_pos((unsigned)b.v.size() - 3) + 1) / 1e8);
        for (int i = (int)v.size() - 1; i >= 0; i--) {
            c.v.insert(c.v.begin(), v[i]);
            int m = (int)((c.get_pos((int)e.v.size()) * 10000 + c.get_pos((int)e.v.size() - 1)) * db);
            c = c - e * m, c.setsign(c.sign, 0), d.v[i] += m;
            while (!(c < e))
                c = c - e, d.v[i] += 1;
        }
        return d.setsign(sign * b.sign, 0);
    }
    BigIntTiny operator%(const BigIntTiny &b) const { return *this - *this / b * b; }
    bool operator>(const BigIntTiny &b) const { return b < *this; }
    bool operator<=(const BigIntTiny &b) const { return !(b < *this); }
    bool operator>=(const BigIntTiny &b) const { return !(*this < b); }
    bool operator!=(const BigIntTiny &b) const { return !(*this == b); }
};
typedef long long ll;
constexpr const int N=10000,D=1000;
int n;
int a[N+1];
ll cnt[N+D+D+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]+=D;
		int pl;
		cin>>pl;
		cnt[a[i]]+=pl;
	}
	sort(a+1,a+n+1);
	n=unique(a+1,a+n+1)-a-1;
	BigIntTiny f1=1,f2=1,g=0;
	for(int i=0;i<=a[n];i++){
		if(cnt[i]){
			g+=f2*cnt[i];
		}
		BigIntTiny tmp=f2;
		f2+=f1;
		f1=tmp;
	}
	int p=a[n];
	while(f2<g){
		BigIntTiny tmp=f2;
		f2+=f1;
		f1=tmp;
		p++;
	}
	vector<int>ans;
	for(;p>0;p--){
		if(g>=f2){
			g=g-f2;
			ans.push_back(p);
		}
		BigIntTiny tmp=f1;
		f1=f2-f1;
		f2=tmp;
	}
	sort(ans.begin(),ans.end());
	for(int i:ans){
		cout<<i-D+1<<' ';
	}
	cout<<'\n';
	
	cout.flush(); 
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：cwfxlh (赞：0)

# [P5940](https://www.luogu.com.cn/problem/P5940)      

儿简送。     

发现这个棋子的转移与斐波那契序列的式子很像，令一个棋子摆放方案的权值为 $\sum{f_i\times num_i}$ 的形式，发现无论如何变换权值均不变，于是我们要找到这个权值的一种特殊表达方式。    

从大到小遍历斐波那契，如果当前 $f_i\le val$，就在当前位置放一个棋子，否则不放。这样显然不会出现两个棋子相邻的情况，由 $f_{i-2}+f_{i-1}=f_i$ 和 $f_{i-1}\times 2\ge f_i$ 可得。于是写个高精即可。因为棋子可能会放到负数位置，所以斐波那契需要带一个偏移量。     

代码：   

```cpp
#include<bits/stdc++.h>
using namespace std;
struct BigNum{
    int len;
    char v[4003];
}f[11003],val,bl1,bl2;
int ans[500003],tot,n,k1,k2,k3,k4,k5;
bool grt(BigNum X,BigNum Y){
    if(X.len>Y.len)return true;
    if(X.len<Y.len)return false;
    for(int i=X.len;i>0;i--){
        if(X.v[i]>Y.v[i])return true;
        if(X.v[i]<Y.v[i])return false;
    }
    return true;
}
int main(){
    ios::sync_with_stdio(false);
    f[0].len=1;
    f[0].v[1]=1;
    f[1].len=1;
    f[1].v[1]=1;
    for(int i=2;i<=11000;i++){
        f[i].len=f[i-1].len;
        for(int j=1;j<=f[i].len;j++)f[i].v[j]=f[i-1].v[j]+f[i-2].v[j];
        for(int j=1;j<=f[i].len;j++){
            f[i].v[j+1]+=(f[i].v[j]/10);
            f[i].v[j]%=10;
        }
        if(f[i].v[f[i].len+1]!=0)f[i].len++;
    }
    cin>>n;
    val.len=1;
    while(n--){
        cin>>k1>>k2;
        for(int i=1,j=0;i<=max(val.len,f[k1+800].len);i++){
            k3=(f[k1+800].v[i]*k2+j)+val.v[i];
            val.v[i]=k3%10;
            j=k3/10;
            if(i==val.len&&(j!=0||i<f[k1+800].len))val.len++;
        }
    }
    for(int i=11000;i>0;i--){
        if(!grt(val,f[i]))continue;
        ans[++tot]=i-800;
        for(int j=1;j<=val.len;j++){
            val.v[j]-=f[i].v[j];
            if(val.v[j]<0){
                val.v[j]+=10;
                val.v[j+1]--;
            }
        }
        while(val.len>1&&val.v[val.len]==0)val.len--;
    }
    for(int i=tot;i;i--)cout<<ans[i]<<" ";
    return 0;
}
```

---


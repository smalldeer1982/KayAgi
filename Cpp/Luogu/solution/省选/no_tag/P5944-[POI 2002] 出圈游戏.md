# [POI 2002] 出圈游戏

## 题目描述

有编号从 $1$ 到 $n$ 的 $n$ 个小朋友在玩一种出圈的游戏,编号为 $i+1 $ 的小朋友站在编号为 $i $ 小朋友左边。编号为 $1 $ 的小朋友站在编号为 $n$ 的小朋友左边。首先编号为 $1$ 的小朋友开始报数，接着站在左边的小朋友顺序报数，直到数到某个数字 $K$ 时就出圈。直到所有的小朋友都出圈，则游戏完毕。

现在给出出圈的顺序，求最小的 $K$。

## 说明/提示

对于 $100\%$ 的数据，$2\le n\le 20$。

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4
1 4 3 2```

### 输出

```
NIE```

## 样例 #2

### 输入

```
4
1 4 2 3```

### 输出

```
5```

# 题解

## 作者：2018ljw (赞：5)

Update：更正代码，修复几个锅。

知道每个人是第几个出圈的作用不大，不如转化为出圈序列。

不难发现，假如当前圈内剩余人数为 $L$，某个人第一次报的数为 $a$，这个人的所有报数均形如 $a+xL$。那么某个人出圈等价于 $a+xL=k$，即 $k\equiv a\pmod L$。

不难发现 $a$ 就是上一个出圈的人到他的距离，暴力找即可。

问题等价于解同余方程组 $\begin{cases}k\equiv a_1\pmod n\\k\equiv a_2\pmod {n-1}\\ \ldots\\k\equiv 0\pmod 1\end{cases}$。

直接 excrt 即可，无解即某次合并时无解。

需要注意的是最后可能会合并出 $k\equiv 0\pmod x$，但显然 $k\ge 1$，因此此时答案为模数 $x$。

```cpp
#include<cstdio>
int cq[31];
int n,ys[31],ms[31];
bool td[31];
long long gcd(long long x,long long y){
	return x%y==0?y:gcd(y,x%y);
}
void exgcd(long long a,long long b,long long &x,long long &y){
	if(!b){
		x=1;y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	long long z=x;
	x=y;
	y=z-a/b*y;
}
int main(){
	int i;
	scanf("%d",&n);
	int p=0,x;
	for(i=1;i<=n;i++){
		scanf("%d",&x);
		cq[x]=i;
	}//cq 存储出圈序列 
	for(i=1;i<=n;i++){
		int ds=0;
		x=cq[i];
		while(p!=x){
			p++;if(p>n)p=1;
			if(!td[p])ds++;
		}
		ms[i]=n-i+1;
		ys[i]=ds%ms[i];
		td[x]=1;
	}
	long long res=ys[1],mod=ms[1];//excrt 流程
	for(i=2;i<=n;i++){
		long long a=mod,b=ms[i],t=((ys[i]-res)%b+b)%b;
		long long x,y,r=gcd(a,b);
		if(t%r)return printf("NIE"),0;
		a/=r;b/=r;t/=r;
		exgcd(a,b,x,y);
		x=x%ms[i]*t%ms[i];
		res+=x*mod;
		mod*=b;
		res=(res+mod)%mod;
	}
	if(!res)res+=mod;
	printf("%lld",res);
}
```

---

## 作者：0x3F (赞：4)

手玩一下样例。

第一个出圈的是 $1$，数了 $4n+1$ 次，那么 $K \equiv 1 \pmod 4$，

第二个出圈的是 $4$，数了 $3m$ 次，那么 $K \equiv 0 \pmod 3$，

第三个出圈的是 $3$，数了 $2k$ 次，那么 $K \equiv 0 \pmod 2$，

第四个出圈的是 $2$，数了 $l$ 次，那么 $K \equiv 0 \pmod 1$，

无解，所以输出 `NIE`。

容易得到 $K$ 对 $1$ 到 $n$ 之间的所有数取模的值。

使用 $\texttt{excrt}$，但是由于模数比较小，可以使用暴力替代 $\texttt{exgcd}$ 的过程。

另外特判所有模数均为零的情况，此时 $K \neq 0$。

代码如下：

```cpp
#include <cstdio>
#define _ 22
int n, a, b[_], x;
bool vis[_];
int res[_];
int mod, val;
inline int gcd(int a, int b) {
	while (a ^= b ^= a ^= b %= a);
	return b;
}
int main() {
	scanf("%d", &n);
	x = n;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a);
		b[a] = i;
	}
	for (int i = 1; i <= n; i++) {
		a = b[i];
		while (x != a) {
			if (x == n) x = 1;
			else x++;
			if (!vis[x]) res[n-i+1]++;
		}
		vis[x] = true;
		res[n-i+1] %= (n-i+1);
	}
	mod = 1;
	val = 0;
	for (int i = 2, j, f; i <= n; i++) {
		j = i / gcd(i, mod);
		f = 1;
		for (int k = 0; k < j; k++) {
			if ((val + mod * k) % i == res[i]) {
				f = 0;
				val += mod * k;
				mod *= j;
				break;
			}
		}
		if (f) {
			printf("NIE\n");
			return 0;
		}
	}
	if (!val) val = mod;
	printf("%d\n", val);
	return 0;
}
```


---

## 作者：wimg6_ (赞：2)

注意到，一个人第 $i$ 轮的时候出圈等价于 $K\equiv f_i \pmod {n-j+1}$，其中 $f_i$ 表示第一轮该人所报的数。

为什么？首先，显而易见地，第 $i$ 轮时还会剩下 $n-i+1$ 个人。而一个人在第 $i$ 圈报到了 $K$，也就说明他在剩余 $n-i+1$ 个人的时候会报到 $K$，也就是 $K\equiv f_i \pmod {n-i+1}$。

其次，如何说明这个人不会在报到 $i$ 前出圈？我们不妨假设他会在第 $j(1\leq j<i)$ 轮出圈，那么就有 $K\equiv f_i \pmod {n-i+1}$ 并且 $K\equiv f_i \pmod {n-j+1}$。利用裴蜀定理，我们可以写出 $K=f_i+J(n-j+1)=f_i+I(n-i+1)$ 的形式，显然 $J=I\times \dfrac{n-i+1}{n-j+1}$。而 $j<i$，那么 $\dfrac{I\times (n-i+1)}{n-j+1}\notin \mathbb{Z}$ 也即 $J\notin \mathbb{Z}$，故假设不成立。

那么我们直接解 $K\equiv f_i \pmod {n-i+1}\ (1\leq i\leq n)$ 即可，之后用 `exCRT` 就可以轻松解决了！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,s=1,now=1,ans,a[30],r[30],w[30],t[30],vis[30];
void exgcd(long long a,long long b,long long &d,long long &x,long long &y){
    if(!b){
        d=a,x=1,y=0;
        return ;
    }
    exgcd(b,a%b,d,y,x);
    y-=x*(a/b);
}
long long excrt(){
    long long m=w[1],p=r[1],d,x,y,f;
    for(long long i=2;i<n;i++){
        exgcd(m,w[i],d,x,y);
        if((r[i]-p)%d) return -1;
        //if(i==3) printf("%lld %lld\n",r[i]-p,d);
        f=w[i]/d,x*=(r[i]-p)/d;
        x%=f,x+=f,x%=f;
        p+=m*x;m/=d,m*=w[i],p%=m;
    }
    p%=m,p+=m,p%=m;
    if(!p) return m;
    return p;
}
int main(){
    scanf("%lld",&n);
    for(long long i=1;i<=n;i++)
        scanf("%lld",&a[i]),t[a[i]]=i,w[i]=n-i+1;
    for(long long i=1;i<n;i++)
        while(1){
            if(vis[now]){
                now%=n,now++;
                continue;
            }
            if(now==t[i]){
                r[i]=s,vis[t[i]]=1,s=1;
                break;
            }
            s++,now%=n,now++;
        }
    //for(long long i=1;i<=n;i++)
    //    printf("%lld ",r[i]);
    ans=excrt();
    if(ans==-1) return !printf("NIE");
    return !printf("%lld",ans);
}
```

**更新日志**

更新了取模的格式。

---

## 作者：roger_yrj (赞：2)

这题一眼 CRT。

因为我们只知道每次谁会出圈。通过暴力模拟，我们可以知道出圈的人和最开始报数的人的距离。这个距离也就是 $k\ \bmod$ 圈内人数的值。

这样，我们可以得到 $k\bmod i\ (2\le i\le n)$ 的值。直接 CRT 即可。

注意特判 $0$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=30;
int n,vis[N],a[N];
ll M=1,B=0;
void merge(ll &m1,ll &b1,ll m2,ll b2){
	ll m3=m1/__gcd(m1,m2)*m2;
	for(ll i=0;i<m2;i++){
		ll x=i*m1+b1;
		if(x%m2==b2){
			b1=x%m3,m1=m3;
			return;
		}
	}
	cout<<"NIE";
	exit(0);
} 
int main(){
	cin>>n;
	for(int i=1,x;i<=n;i++)scanf("%d",&x),a[x]=i;
	for(int i=n,j=1;i>1;i--){
		int x=1,y=a[n-i+1];
		for(;j!=y;j=j%n+1)if(!vis[j])x++;
		vis[j]=1;x%=i;
		merge(M,B,i,x);
	}
	if(B)cout<<B;
	else cout<<M;
}
```

---

## 作者：__vector__ (赞：1)

做这题时没理解他是怎么报号的，猜了一种题意通过了，记录一下。  

#### 题意  

有 $n$ 个人，从左到右编号为 $1,2,3,\cdots,n$，且 $n$ 右边是 $1$。    

现在举行 $n$ 轮游戏。  

对于第 $i$ 轮，从第 $i-1$ 轮被踢出的人的右边的第一个存活的人开始报数，对于第一轮，则从 $1$ 号开始。  

从左到右报数，第一个人报 $1$，之后每个人报上一个人的数字加 $1$。  

当有人报出 $k$ 时，本轮结束，这个人被踢出。  

现在已知第 $i$ 个人是第 $a_i$ 轮出圈的，求最小的 $k$，或者报告 ```NIE```。  

### 做法  

考虑依次模拟每一轮，并在每一轮开始前，将开始报数的人编号设置为 $1$ 并对所有存活的人按照报号顺序重新编号。   

假设第 $i$ 轮重新编号后，编号为 $x$ 的人被踢出了，那么说明 $k \equiv x \pmod {(n-i+1)}$ 。  

显然，EXCRT 合并就可以解决本题。

---

## 作者：chentianmiao (赞：0)

## 思路解析
先算第二个样例。

$1$ 号第一个出圈，得到 $K \equiv 1 \pmod {n}$；

$3$ 号第二个出圈，得到 $K \equiv 2 \pmod {n-1}$；

$4$ 号第三个出圈，得到 $K \equiv 1 \pmod {n-2}$；

$2$ 号第四个出圈，得到 $K \equiv 0 \pmod {n-3}$。

于是得到 $K$ 的最小值 $5$。

在计算过程中，我们使用的是出圈序列而非每个人出圈的时刻，在输入时先转化为出圈序列 $id[]$。

假设已经进行到了第 $i$ 轮，本轮出圈的人是 $id[i]$。不难发现，这一轮中 $id[i]$ 号报的数必定可以表示为 $x_i+y_i \times (n-i+1)$。

于是问题转换为解下面这个方程组：
$\begin{cases} 
K \equiv a_1 \pmod {n} \\
K \equiv a_2 \pmod {n-1} \\
\vdots \\
K \equiv a_i \pmod {n-i+1} \\
\vdots \\
K \equiv a_{n-1} \pmod {2} \\
K \equiv 0 \pmod {1}
\end{cases}$。

套用 exCRT 即可解决问题。

__注意__：

- 无解的判定：一次合并中出现无法被整除的情况。
- 特殊情况的处理：若合并结束后，得到的 $R$ 为 $0$，又因为 $K>0$，因此最小的 $K$ 为合并后的模数 $M$。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=29;
ll n;
ll rk[N],id[N];
ll bit[N];
ll mod[N],r[N];
ll LSB(ll i){
	return i&(-i);
}
void add(ll x,ll d){
	while(x<=n){
		bit[x]+=d;
		x+=LSB(x);
	}
}
ll psq(ll x){
	ll ans=0;
	while(x>0){
		ans+=bit[x];
		x-=LSB(x);
	}
	return ans;
}
void exGCD(ll a,ll b,ll&x,ll&y,ll&gcd){
	if(!b){
		x=1;
		y=0;
		gcd=a;
		return;
	}
	exGCD(b,a%b,y,x,gcd);
	y-=(a/b)*x;
}
ll exCRT(){
	ll M=mod[1],R=r[1];
	ll gcd,lcm,x,y,z;
	for(ll i=2;i<=n-1;i++){
		exGCD(M,mod[i],x,y,gcd);
		if((r[i]-R)%gcd){
			return -1;
		}
		lcm=M/gcd*mod[i];
		x*=(r[i]-R)/gcd;
		z=M*x+R;
		R=(z%lcm+lcm)%lcm;
		M=lcm;
	}
	if(!R){
		R=M;
	}
	return R;
}
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>rk[i];
		id[rk[i]]=i;
	}
	mod[1]=n;
	r[1]=id[1];
	for(ll i=1;i<=n;i++){
		bit[i]=LSB(i);
	}
	add(id[1],-1);
	for(ll i=2;i<=n-1;i++){
		mod[i]=mod[i-1]-1;
		r[i]=(psq(id[i])-psq(id[i-1]))%mod[i];
		if(r[i]<0){
			r[i]+=mod[i];
		}
		add(id[i],-1);
	}
	ll ans=exCRT();
	if(ans==-1){
		cout<<"NIE";
	}else{
		cout<<ans;
	}
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

~~都让你构造了干脆叫出签游戏得了~~。

我们思考每一次淘汰一个人的要求。假设从淘汰第 $i$ 个人到淘汰第 $i+1$ 个人中间要经过 $t$ 个人，那么因为此时剩下 $n-i$ 个人，所以 $k\equiv t\pmod {n-i}$。

然后就变成扩展中国剩余定理的板子题了。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
signed n, a[25], lp; bool ext[25];
namespace excrt {
	int A, B, a, b, t1, t2, tmp, gc, md;
	long long t, a_, b_;
	vector<pair<signed, signed>>que;
	inline void exgcd(int a, int b, int& x, int& y) {
		if (!b) x = 1, y = 0, gc = a;
		else exgcd(b, a % b, y, x), y -= a / b * x;
	}
	inline void solve() {
		exgcd(A, a, t1, t2), tmp = b - B; a /= gc;
		if (tmp % gc) {
			cout << "NIE" << endl;
			exit(0);
		}
		t1 = (t1 * tmp / gc + a) % a;
		md = A * a;
		B = (A * t1 + B + md) % md, A = md;
	}
	void main() {
		ios::sync_with_stdio(0);
		A = que[0].first, B = que[0].second;
		for (int i = 1; i != que.size(); ++i)
			a_ = que[i].first, b_ = que[i].second,
			a = a_, b = b_, solve();
		if (!(B % A)) cout << (long long)A << endl;
		else cout << (long long)(B % A) << endl;
	}
}
inline void nxt(signed& p) {
	do p = p % n + 1; while (ext[p]);
}
signed main() {
	ios::sync_with_stdio(0); cin >> n;
	for (signed i = 1, p; i <= n; ++i) cin >> p, a[p] = i;
	for (signed i = 1; i <= n; ++i) {
		signed st = 0; while (lp != a[i]) nxt(lp), st++; ext[a[i]] = 1;
		excrt::que.emplace_back(make_pair(n - i + 1, st % (n - i + 1)));
	}
	excrt::main();
}
```

---


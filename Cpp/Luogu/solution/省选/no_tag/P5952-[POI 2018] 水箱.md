# [POI 2018] 水箱

## 题目描述

在地面上有一个水箱，它的俯视图被划分成了 $n$ 行 $m$ 列个方格，相邻两个方格之间有一堵厚度可以忽略不计的墙，水箱与外界之间有一堵高度无穷大的墙，因此水不可能漏到外面。已知水箱内每个格子的高度只能是 $[0,H]$ 之间的整数，请统计有多少可能的水位情况。

因为答案可能很大，请对 $10^9+7$ 取模输出。

我们说两种情况是不同的当且仅当存在至少一个方格的水位在两个情况中不同。

## 说明/提示

对于 $100\%$ 的数据，$n\times m\le500000$，$1\le H\le10^9$。

----

### 样例解释：

要么全部格子水位都是 $2$，要么全部格子水位都在 $[0,1]$ 之间，共 $1+2^6=65$ 种情况。

## 样例 #1

### 输入

```
3 2 2
1
1
1
1 2
1 1```

### 输出

```
65
```

# 题解

## 作者：jdsb (赞：12)

## 题意

给定一个高为$H$的水箱，水箱被划分为$n*m$个格子，每个相邻的格子之间都有一堵墙，高度为$h_i$，每个格子高度都是$[0,H]$之间的整数，求有多少种可能的水位情况。

## 分析
- 我们将每堵墙看作边，边的边权为墙的高度，再把墙两边的格子看作点，可以发现只有这张图上的最小生成树上的边才是会对答案有影响的，我们来证明一下这个东西。

- 设已经有两个点 $x$，$y$，被我们所选中，这两个点所处的连通块的高度为 $h$，此时有一条边能使 $x$，$y$ 相连，这条边的边权为 $h'$，若 $h'>h$，则这个连通块的最高的能不相同的水位高度也只能为$h$，所以$h'$对答案没有贡献。

- 当我们知道了这个结论，我们就可以来做这道题了。我们先把边按照边权从小到大排序，然后对于这条边的两个结点 $u$，$v$，若这两个点不在一个连通块中，我们就考虑合并它们的答案，设 $f_u$ 和 $f_v$ 分别为两个联通块的答案，$h_u$ 和 $h_v$ 为两个连通块的最高高度，$v$ 为这条边的边权，则新的联通块的答案就为 $(f_u+v-h_u)*(f_v+v-h_v)$，因为左边连通块的最高高度本来为 $h_u$，现在最高高度变为 $v$，那么左边的方案就增加了 $v-h_u$，右边也是同理，根据乘法原理，即可得到上面的式子，那么这题就做完了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();};
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x*f;
}
#define ll long long
const int N=5e5+5,mod=1e9+7;
struct edge
{
	int x,y,v;
}e[N<<1];
int cnt;
bool mycmp(edge x,edge y)
{
	return x.v<y.v;
}
int f[N];
int get(int x)
{
	if(x^f[x]) f[x]=get(f[x]);
	return f[x];
}
int n,m,H,ans[N],h[N];
int ya(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
	n=read(),m=read(),H=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<m;j++)
		{
			int x=ya(i,j),y=ya(i,j+1),v=read();
			e[++cnt]={x,y,v}; 
		}
	for(int i=1;i<n;i++)
		for(int j=1;j<=m;j++)
		{
			int x=ya(i,j),y=ya(i+1,j),v=read();
			e[++cnt]={x,y,v};
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			int x=ya(i,j);
			f[x]=x;
			ans[x]=1;
		}
	sort(e+1,e+cnt+1,mycmp);
	for(int i=1;i<=cnt;i++)
	{
		int x=get(e[i].x),y=get(e[i].y),v=e[i].v;
		if(x^y)
		{
			f[y]=x;
			ans[x]=1ll*(ans[x]-h[x]+v)*(ans[y]-h[y]+v)%mod;
			h[x]=v;
		}
	}
	int x=get(1);
	printf("%d\n",(ans[x]-h[x]+H)%mod);
	return 0;
}
```


---

## 作者：LCuter (赞：5)

## POI2018 水箱 题解

##### $\text{Description}$

已知有一个 $n\times m\times H$ 的长方体，对于水平面上的相邻两格间，会有一堵厚度忽略不计的墙，从最低一层开始，到第 $h_{i,j}\ge 1$ 层。

定义一种装水方式是合法的，当且仅当：

1. 某一个格子装了水，则它是最低一层的格子或者其竖直向下的格子装了水。
2. 某一个格子装了水，则它在水平面上的相邻四个格子要么是水，要么中间有堵墙。

求有多少种合法的装水方式，对 $10^9+7$ 取模。

$n\times m\le 5\times 10^5,H\le 10^9$

##### $\text{Solution}$

考虑某一个位置有墙，则它的正下方必然有墙（或者是最底一层），那么从下向上计算的过程实际上可以看成不断去掉一堵墙，其实就是让两个格子连通的操作，由于墙的高度至少为 $1$，故一开始所有格子都不连通。对于某一层 $h$，我们发现高度大于等于 $h$ 的墙会将该平面分成若干个连通块，对于某个连通块，若某一个装的水高度大于等于 $h$，则该连通块内的所有格子装的水都相等。

换言之，我们设某个连通块装水的方案数为 $f_i$，该连通块内的最高的墙高度 $h_i$，则某次去掉一堵高度为 $h$ 的墙时，不妨设它让 $x,y$ 两个连通块连通了（若两者已连通则无需考虑），那么新连通块 $t$ 的方案数正是 $f_t=f_xf_y+f_x(h-h_y)+f_y(h-h_x)=(f_x+h-h_x)\times(f_y+h-h_y)$，即两者装的水高度都不超过各自内部最高的墙，某一个超过了，两者都超过了的方案数之和。

注意到我们只需让两个连通块连通，故采用并查集，并在代表元处维护 $f$ 即可。

最后需将所有连通块的答案加上 $H-h_x$ 后再相乘，具体实现细节见代码。

时间复杂度 $\mathcal O(nm\log(nm))$。

##### $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
using namespace std;
const int Mod=1000000007,N=500005;
inline void read(int& x){
    static char c;
    while(!isdigit(c=getchar()));x=c^48;
    while(isdigit(c=getchar()))x=(x*10)+(c^48);
}
inline void Add(int& a,int b){(a+=b)>=Mod?a-=Mod:a;}

int n,m,H,tot,w;
struct Wal{int P1,P2,Hi;}W[N<<1];
inline bool cmp(Wal x,Wal y){return x.Hi<y.Hi;}

int Val[N],Fat[N],L1[N];
inline void Init(){for(REG int i=1;i<=n*m;++i)Fat[i]=i,Val[i]=1,L1[i]=0;}
int GetF(int now){return now==Fat[now]?now:Fat[now]=GetF(Fat[now]);}

inline void Work(){
    read(n),read(m),read(H),Init();
    for(REG int i=1;i<=n;++i)
        for(REG int j=1;j<m;++j)
            read(w),W[++tot]=(Wal){(i-1)*m+j,(i-1)*m+j+1,w};
    for(REG int i=1;i<n;++i)
        for(REG int j=1;j<=m;++j)
            read(w),W[++tot]=(Wal){(i-1)*m+j,i*m+j,w};
    sort(W+1,W+tot+1,cmp);
    for(REG int i=1;i<=tot;++i){
        int x=W[i].P1,y=W[i].P2,h=W[i].Hi;
        int Fx=GetF(x),Fy=GetF(y);
        if(Fx==Fy) continue;
        Add(Val[Fx],h-L1[Fx]),Add(Val[Fy],h-L1[Fy]);
        Fat[Fx]=Fy,Val[Fy]=1ll*Val[Fy]*Val[Fx]%Mod,L1[Fy]=h;
    }
    int Ans=1;
    for(REG int i=1;i<=n*m;++i)
        if(Fat[i]==i) Add(Val[i],H-L1[i]),Ans=1ll*Ans*Val[i]%Mod;
    printf("%d\n",Ans);
}

int main(){Work();}
```



---

## 作者：xiezheyuan (赞：3)

一道比较高级的图论建模题。

首先考虑隔板的意义，如果 $(a,b)$ 和 $(c,d)$ 间有一个高位 $h$ 的隔板，则满足 $(a,b)$ 和 $(c,d)$ 的水量都小于等于 $h$。当然不是小于等于 $h$ 都可以取到。

考虑将 $(a,b)$ 和 $(c,d)$ 之间的隔板建成 $((a,b),(c,d))$ 无向边。边权为高度。

然后就变成了两个点之间的高度最大值，等同于之间所有路径的最大边最小值。

考虑这个定义非常像瓶颈路的定义。所以可以想到最小生成树。

当然也可以严格证明只有最小生成树才对答案有影响。

两个点，如果有一条高度大于树边高度的边，则还是无法达到这个高度，因为在树边会溢出来。

然后考虑计算答案。设 $f(x)$ 为 $x$ 所在连通块的答案。$h(x)$ 为其最高高度。

然后合并 $u,v$ 时若边权为 $w$，两边水位可以上涨 $w-h(u),w-h(v)$，方案也就增加这么多。

所以有 $f(u)=(f(u)+w-h(u))(f(v)+w-h(v))$。

最后记得 $H$ 的存在还可以涨一点。

做完了。时间复杂度 $O(nm\log nm)$。难度建议评蓝。

```cpp
#define t(i,j) (((i)-1)*m+(j))

struct edge{
	int u,v,w;
	bool operator<(const edge &x) const {
		return w<x.w;
	}
} g[N<<1];
int tot;

int fa[N],ans[N],h[N];

int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}

int n,m,hh;

void merge(int x,int y,int z){
	fa[y]=x;
	ans[x]=(ans[x]-h[x]+z)*(ans[y]-h[y]+z)%MOD;
	h[x]=z;
}

signed main(){
	cin>>n>>m>>hh;
	for(int i=1;i<=n;i++){
		for(int j=1;j<m;j++){
			int v;cin>>v;
			g[++tot]={t(i,j),t(i,j+1),v};
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			int v;cin>>v;
			g[++tot]={t(i,j),t(i+1,j),v};
		}
	}
	sort(g+1,g+tot+1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			fa[t(i,j)]=t(i,j);
			ans[t(i,j)]=1;
		}
	}
	int cnt=0;
	for(int i=1;i<=tot;i++){
		int u=g[i].u,v=g[i].v,w=g[i].w;
		int fu=find(u),fv=find(v);
		if(fu==fv) continue;
		cnt++;
		merge(fu,fv,w);
		if(cnt == t(n,m)-1) break;
	}
	int rt=find(t(1,1));
	cout<<((ans[rt]-h[rt]+hh)%MOD)<<'\n';
	return 0;
}
```

---

## 作者：jiangly (赞：3)

#### 题意

有一个大小 $n\times m$ ($1\le n\cdot m\le 5\cdot 10^5$)，高 $H$ 的水箱，每相邻两格之间有一堵墙，求所有格子水位情况的方案数。

#### 题解

Kruskal 求最小生成树，同时维护方案数即可。

时间复杂度：$O(nm\log nm)$。

#### 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
const int P = 1000000007;
int n, m, h;
std::vector<int> fa, height, count;
struct Edge {
    int u, v, w;
    Edge(int u, int v, int w) : u(u), v(v), w(w) {}
};
bool operator<(const Edge &lhs, const Edge &rhs) {
    return lhs.w < rhs.w;
}
std::vector<Edge> edges;
int find(int u) {
    while (fa[u] >= 0 && fa[fa[u]] >= 0)
        u = fa[u] = fa[fa[u]];
    return fa[u] >= 0 ? fa[u] : u;
}
void merge(int u, int v, int ht) {
    u = find(u);
    v = find(v);
    if (u == v)
        return;
    if (fa[u] > fa[v])
        std::swap(u, v);
    count[u] = 1ll * (count[u] + ht - height[u]) * (count[v] + ht - height[v]) % P;
    fa[u] += fa[v];
    fa[v] = u;
    height[u] = ht;
}
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cin >> n >> m >> h;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m - 1; ++j) {
            int x;
            std::cin >> x;
            edges.push_back(Edge(i * m + j, i * m + j + 1, x));
        }
    }
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < m; ++j) {
            int x;
            std::cin >> x;
            edges.push_back(Edge(i * m + j, (i + 1) * m + j, x));
        }
    }
    std::sort(edges.begin(), edges.end());
    fa.assign(n * m, -1);
    count.assign(n * m, 1);
    height.resize(n * m);
    for (int i = 0; i < int(edges.size()); ++i)
        merge(edges[i].u, edges[i].v, edges[i].w);
    int u = find(0);
    std::cout << (count[u] + h - height[u]) % P << "\n";
    return 0;
}

```



---

## 作者：shiroi (赞：2)



### Description

地面上有一高为H的水箱，俯视图被划分成了n行m列个方格。已知水箱内每个格子的高度都是 $[0,H]$ 之间的整数，求有多少可能的水位情况。




### Solution

观察题目可以发现可以将每个格子看作图上的点，格子间的隔板看作边，隔板高度设为边权，则题目中的模型是一个网格图。

对于图上的任意一点，只要其水位高度超过相连边权的最小值就会和周围节点一致。因此考虑用并查集维护连通块，用类似kruskal的方法按边权从小到大的顺序依次进行合并，同时维护连通块内的边权最大值和方案数。

在对两个连通块进行合并时，设两连通块方案数分别为 $g_x,g_y$ ，最大边权为 $mx_x,mx_y$， 进行合并的边权为 $val$ ，则新连通块方案为 $(g_x+val-mx_x) \cdot (g_y+val-mx_y)$ 。可以由此求解。

```cpp
#include <bits/stdc++.h>
using namespace std;

char buf[10000001],*ptr=buf-1;

inline int read()
{
	int x=0,c=getchar();
	while(c<48) c=*++ptr;
	while(c>47) x=x*10+c-'0',c=*++ptr;
	return x;
}

typedef long long ll;
const int MOD = 1e9+7;
const int MAXN = 500005;
struct Edge {int u,v,w;} e[MAXN*2];
ll fa[MAXN],g[MAXN],mx[MAXN];
int n,m,h,cnt;

bool operator < (Edge a,Edge b)
{return a.w<b.w;}

inline ll calc(int x,int y)
{return g[x]-mx[x]+y;}

inline int find(int x)
{return fa[x]^x ? fa[x]=find(fa[x]) : x;}

int main(int argc, char const *argv[])
{
	fread(buf,1,sizeof(buf),stdin)[buf]=0;
	n=read(); m=read(); h=read();
	for(int i=1; i<=n; ++i)
		for(int j=1,x=(i-1)*m; j<m; ++j)
			e[++cnt]=Edge{x+j,x+j+1,read()};
	for(int i=1; i<n; ++i)
		for(int j=1,x=(i-1)*m; j<=m; ++j)
			e[++cnt]=Edge{x+j,x+j+m,read()};
	sort(e+1,e+cnt+1);
	for(int i=1; i<=n; ++i)
		for(int j=1,x=(i-1)*m; j<=m; ++j)
			fa[x+j]=x+j,g[x+j]=1;
	for(int i=1; i<=cnt; ++i)
	{
		int fx=find(e[i].u),fy=find(e[i].v),val=e[i].w;
		if(fx^fy)
		{
			g[fx]=1ll*calc(fx,val)*calc(fy,val)%MOD;
			fa[fy]=fx; mx[fx]=val;
		}
	}
	printf("%lld\n",calc(find(1),h)%MOD);
	return 0;
}
```



---

## 作者：Bpds1110 (赞：1)

cy4 讲题的时候还看到了某位出题人。

我们考虑水箱隔板的用途。设当前隔板的高度为 $h1$，两边格子中的水高度位 $h2$。$h1 < h2$ 时代表水位在隔板高度下，此时的两格中的水是完全分开的。当 $h1 \ge h2$ 时，两格水位高度在隔板之上，并且是完全合并的，即高度完全相同。

当两个格子的高度**不小于**隔板高度时，它们的高度都相同，我们可以认为它们合并为了一个格子，且高度**不小于**隔板高度。

我们再来看这题，题目让我们求总方案数。这里我们采用**类似于** Kruskal 的方法求解。

题目给出了一些隔板的高度，我们先考虑将这些按高度从小到大排序。然后对于前几条边，合并与这条边相邻的两格，并计算做出的贡献。对从小到大合并的做出解释。因为总共有 $n \times m$ 格，只能合并 $n \times m - 1$ 次，前 $n \times m - 1$ 次合并，会将总高度合并到至少第 $n \times m - 1$ 个隔板的高度，若合并得太高，是没有意义的，它们在之前已经合并为了一个格子。

对于每次合并，一开始两格的高度一定小于隔板的高度，因为我们每次合并，都是将两格的高度合并成当前隔板的高度，而隔板高度又是单调递增的。

我们计算对于每次合并做出的贡献。考虑用并查集维护一格中最高的水位，两个格子分别用 $h1$ 和 $h2$ 表示。再考虑用并查集维护一个区块（一格）的方案总数，用 $ans1$ 和 $ans2$ 表示。然后可以看图片解决了。

![](https://cdn.luogu.com.cn/upload/image_hosting/80n1pm86.png)

根据乘法原理，不难得出以上结论，只需要左边总方案数与右边总方案数相乘，就是两个水箱的总贡献。

计算完贡献，就合并目前的两格水箱。并查集更新一格中最高的水位，和当前这格做出的贡献即可。

最后别忘记计算最大高度为 $H$ 产生的贡献。

---

## 作者：_Cheems (赞：0)

将墙视为边，那么就是求给网格图赋值 $a$ 的方案数，满足 $a\le H$ 且对于一条边 $(u,v,w)$，假如 $\max(a_u,a_v)>w$ 则 $a_u=a_v$。

试了下 dp、容斥等等，不好做，太生搬硬套了。考虑边权最大的一条边 $(u,v,w)$，对 $a_u,a_v$ 进行分讨：

1. $a_u=a_v=x>w$：因为连最大的边都会溢出，那么值会一直传递到整个图，故方案数为 $\max(0,H-w)$。
2. $a_u,a_v\le w$：则全图的点的值应 $\le w$ 否则一定非法。考虑断掉这条边，假如图仍连通，那么将 $H\gets w$，然后递归计算即可；否则，图将被分为两部分，显然互相独立，对两边分别计算乘起来即可。

删边不好做，不妨倒着做变成合并，用并查集维护即可。复杂度 $O(n\log n)$。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define id(x, y) ((x - 1) * m + y)
const int N = 1e6 + 5, mod = 1e9 + 7;
int n, m, h, a[N], tot, x, fa[N], ans[N], lst[N];
struct edge{int u, v, w;} e[N];

inline int find(int u) {return fa[u] == u ? u : fa[u] = find(fa[u]);}
signed main(){
	cin >> n >> m >> h;
	for(int i = 1; i <= n * m; ++i) fa[i] = i, lst[i] = -1;
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j < m; ++j) scanf("%lld", &x), e[++tot] = {id(i, j), id(i, j + 1), x};
	for(int i = 1; i < n; ++i)
		for(int j = 1; j <= m; ++j) scanf("%lld", &x), e[++tot] = {id(i, j), id(i + 1, j), x};
	sort(e + 1, e + 1 + tot, [](edge A, edge B){return A.w < B.w;});
	for(int i = 1; i <= tot; ++i){
		int u = e[i].u, v = e[i].v, w = e[i].w;
		int fu = find(u), fv = find(v);
		if(fu ^ fv){
			ans[fu] = (ans[fu] + w - lst[fu]) % mod; 
			ans[fv] = (ans[fv] + w - lst[fv]) % mod;
			ans[fv] = ans[fv] * ans[fu] % mod;
			lst[fv] = w, fa[fu] = fv;
		}
		else{
			ans[fu] = (ans[fu] + w - lst[fu]) % mod;
			lst[fu] = w; 
		}
	}
	cout << (ans[find(1)] + h - e[tot].w) % mod;
	return 0;
}
```

---

## 作者：Helloworldwuyuze (赞：0)

# P5952 [POI2018] 水箱

## Description

给定一个 $n\times m$ 的网格，每两个网格之间有一堵墙分隔。墙的高度为 $h_i$，四周的墙无穷高。求最高水位为 $H$ 时整个网格可能的状态数，对 $10^9+7$ 取模。

## Solution

首先注意到 $1\le H\le 10^9$，这很不好，但是 $n\times m\le 5\times 10^5$，因此可以离散化。考虑我们从低到高一层层填水，中间断层的就一下子填完，那么一定是一堆小的联通块不断合并的过程。因此，很容易联想到并查集。我们考虑使用并查集维护联通块，并且开两个数组 $\text{ans,comdep}$ 分别表示该联通块在 $\text{comdep}$ 的高度时刚好合并，并且这个高度的答案为 $\text{ans}$。值得注意的是，相同的联通块在不同高度的答案是不一样的。因为可能整个水位同时提高，这样的答案就会 $+1$（例如一个格子，它在 $H=1$ 时 $\text{ans}=2$，但是在 $H=21$ 时 $\text{ans}=22$）。记录这个 $\text{comdep}$ 就是方便下次再合并它的时候统计它的答案。

现在考虑如何合并两个联通块。对于联通块 $x$ 和 $y$，显然在高度小于合并高度的时候，它们互不影响，根据乘法原理，很容易得知在高度小于合并高度时它们的答案是 $(\text{ans}_x+dep-\text{comdep}_x)$ $\times$ $(\text{ans}_y+dep-\text{comdep}_y)$。然后再把 $\text{comdep}$ 设成当前高度，我们就合并完了。

注意，这里的记录方式有很多种。我用的是不记录在刚好合并的高度上的那一个答案，而是只记录它们的乘机。这样可以最大地减小代码复杂度。大家注意一下这里的统计细节。

## Code

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<stack>
#include<algorithm>
#include<map>

#include<bitset>
#include<set>

#include<deque>
#include<cassert>
#include<cstdlib>
#include<cmath>
#include<ctime>
#include<vector>

#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define DBG cerr << __LINE__ << ' ' << __FUNCTION__ << endl

#define DRE default_random_engine
#define UID uniform_int_distribution
#define y0 Y0
#define y1 Y1

#define pi acos(-1)
#define eps (1e-8)

using namespace std;

#define int long long
const int INF = 0x3f3f3f3f;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
const int N = 1e6 + 10;
const int M = 5e5 + 10;
const int MOD = 1e9 + 7;

struct edge{
    PII u,v;
    int h;
}e[N];
int fa[N], a[N], n, m, idx, ans[N], comdep[N], H;

int Hash(int x,int y){ return (x-1)*m+y;}
int find(int x){ return fa[x]==x?fa[x]:fa[x]=find(fa[x]);}

bool cmp(edge x,edge y){
	return x.h<y.h;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
    cin>>n>>m>>H;
    for(int i=1;i<=n;++i)
        for(int j=1;j<m;++j)    ++idx, cin>>e[idx].h, e[idx].u=mk(i,j), e[idx].v=mk(i,j+1), a[idx]=e[idx].h+1;
    for(int i=1;i<n;++i)
        for(int j=1;j<=m;++j)   ++idx, cin>>e[idx].h, e[idx].u=mk(i,j), e[idx].v=mk(i+1,j), a[idx]=e[idx].h+1;
    sort(a+1,a+1+idx);
    int tot=unique(a+1,a+1+idx)-a-1;
    sort(e+1,e+1+idx,cmp);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j){
            int x=Hash(i,j);
            fa[x]=x, ans[x]=1; comdep[x]=1;
        }
    int j=1;
    for(int i=1;i<=tot;++i){
        if(a[i]>H)  break;
        while(e[j].h<a[i]&&j<=idx){
            int x=Hash(e[j].u.fi,e[j].u.se), y=Hash(e[j].v.fi, e[j].v.se);
            int fx=find(x), fy=find(y);
            if(fx==fy){ ++j; continue;}
            fa[fy]=fx;
            ans[fx]=((ans[fx]+(a[i]-comdep[fx]))%MOD*(ans[fy]+(a[i]-comdep[fy]))%MOD)%MOD;
            comdep[fx]=a[i];
            ++j;
        }
    }
    int sum=1;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j){
            int x=Hash(i,j);
            if(find(x)==x)  sum=(sum*(ans[x]+H+1-comdep[x])%MOD)%MOD;
        }
    cout<<sum<<endl;
	return 0;
}
```

---

## 作者：Linge_Zzzz (赞：0)

链接：[P5952](https://www.luogu.com.cn/problem/P5952)。题意不再赘述。

先把这个网格抽象成一个图，$(i,j)$ 位置的格子对应的图中点的编号是 $m(i-1)+j$，这样对于每个格子都有唯一的点。

对于每一层，墙会把这一层分成几个连通块，我们从下往上一层一层处理，设 $f_i$ 为当前高度下，点 $i$ 所属连通块内的方案数。

我们遍历到一层，当这一层的水会把下面的几个连通块合起来的时候，我们可以用并查集来维护，考虑合并他们两个的答案。

设当前要合并 $u$ 的连通块和 $v$ 的连通块。$w$ 是他们两个之间墙的高度。$h_i$ 是点 $i$ 所属连通块的最高高度（可以理解为这个连通块连通的墙最高的一个的高度）。我们把 $u$ 合并到 $v$，则有：

$$ f_v=(f_u+w-h_u)(f_v+w-h_v) $$

怎么理解呢？因为 $h_i$ 存储的是这个连通块刚好连通的最高高度，也就是说在这个高度下，只要再增加高度，这个连通块里的所有格子就必须一块增加高度。$u$ 能增加的高度是 $w-h_u$，$v$ 同理，最后用乘法原理乘起来就行了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+10,mod=1e9+7;
typedef long long ll;
typedef pair<int,int> pii;
int n,m,h;
struct edge{
	int u,v,w;
	edge(){}
	edge(int _u,int _v,int _w){u=_u,v=_v,w=_w;}
}e[N*2];
int tot;
bool operator<(edge x,edge y){return x.w<y.w;}
int fa[N],hi[N];
ll f[N];
void init(){for(int i=1;i<N;i++)fa[i]=i,f[i]=1;}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int c(int x,int y){return (x-1)*m+y;}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>h;
	for(int i=1;i<=n;i++){
		for(int j=1;j<m;j++){
			int t;cin>>t;
			e[++tot]=edge(c(i,j),c(i,j+1),t);
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			int t;cin>>t;
			e[++tot]=edge(c(i,j),c(i+1,j),t);
		}
	}
	sort(e+1,e+1+tot);
	init();// 此处初始化了 fa 和 f 
	for(int i=1;i<=tot;i++){
		int fu=find(e[i].u),fv=find(e[i].v);
		if(fu==fv)continue;
		fa[fu]=fv;
		f[fv]=(f[fu]+e[i].w-hi[fu])*(f[fv]+e[i].w-hi[fv])%mod;
		hi[fv]=e[i].w;
	}
	int x=find(1);
	cout<<(f[x]+h-hi[x])%mod;
	return 0;
}
```

---

## 作者：lyhqwq (赞：0)

# Solution

首先从 $N=1$ 开始考虑

对于两个相邻的格子，在两个格子水位都不超过中间墙的高度时，两个格子是独立的。一旦超过中间墙的高度时，两个格子的水位一定相同，所以可以合并成一个格子，我们的目的就是去将所有的格子合并。

假设我们当前的两个还没有合并的格子，这两个格子的最高水位分别为 $Max_u$ 和 $Max_v$，两个格子之间的墙的高度为 $w$，那么一定有 $Max_u,Max_v\leq w$。所以我们要从低到高考虑每一个墙

根据以上性质，我们可以将墙是为边，格子视为点，做一遍最小生成树即可。

我们记录每个连通块的答案 $ans_i$，假设我们当时考虑到一条边 $u \to v$，边权为 $w$ ，那么新的连通块的答案就是 $(ans_u+w-Max_u)\times(ans_v+w_Max_v)$。

最后还要加上 $[Max_1,H]$ 这部分的答案。

# code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1000005;
const int Mod=1e9+7;
struct edge{
    int u,v,w;
}e[N];
int cnt;
int n,m,h;
int fa[N];
int Max[N],ans[N];
int find(int x){
    return (x==fa[x]?x:fa[x]=find(fa[x]));
}
bool cmp(edge a,edge b){
    return a.w<b.w;
}
int f(int i,int j){
    return (i-1)*m+j;
}
void kruscal(){
    int tot=0;
    for(int i=1;i<=cnt;i++){
        int u=e[i].u,v=e[i].v,w=e[i].w;
        int fu=find(u),fv=find(v);
        if(fu==fv) continue;
        fa[fv]=fu;
        ans[fu]=((ans[fu]+w-Max[fu])%Mod)*((ans[fv]+w-Max[fv])%Mod)%Mod;
        Max[fu]=w;
        tot++;
        if(tot==n*m-1) return;
    }
}
signed main(){
    //freopen("tank3.in","r",stdin);
    //freopen("tank.out","w",stdout);
    scanf("%lld%lld%lld",&n,&m,&h);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m-1;j++){
            int w;
            scanf("%lld",&w);
            e[++cnt]=(edge){f(i,j),f(i,j+1),w};
        }
    }
    for(int i=1;i<=n-1;i++){
        for(int j=1;j<=m;j++){
            int w;
            scanf("%lld",&w);
            e[++cnt]=(edge){f(i,j),f(i+1,j),w};
        }
    }
    for(int i=1;i<=n*m;i++) fa[i]=i,ans[i]=1;
    sort(e+1,e+1+cnt,cmp);
    kruscal();
    printf("%lld\n",(ans[find(1)]+h-Max[find(1)])%Mod);
    return 0;
}

```


---


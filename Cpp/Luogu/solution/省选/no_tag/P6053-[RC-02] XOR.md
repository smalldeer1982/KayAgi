# [RC-02] XOR

## 题目背景

FangZeLi 喜欢异或，所以就有了这道题（然而这并不是他出这种题的理由）。

## 题目描述

**注意，本题中一切 $\sum$ 均表示求异或和！**

一棵 $n$ 个节点，$n-1$ 条边的有根树，初始时以 $1$ 节点为根。

这棵树上的每个节点 $i$ 都有其点权 $V_{i}$。

令函数 $\operatorname{Xor}(x)=\sum_{y\in  \operatorname{Subtree}(x)}{V_{y}}$，其中 $\operatorname{Subtree}(x)$ 表示 $x$ 的子树。

现需支持以下五种操作：

1. `1 x`，表示将 $x$ 换为根，且查询 $\sum_{i=1}^{n}{\operatorname{Xor}(i)}$。
2. `2 x y`，表示令 $V_{x}=y$。
3. `3 x y` ，表示查询 $\operatorname{LCA}(x,y)$。
4. `4 x y`，表示查询 $x$ 到 $y$ 路径上的点的点权异或和。
5. `5 x`，表示查询 $\operatorname{Xor}(x)$。

## 说明/提示

对于所有数据，保证 $100\le n,m,q\le 10^6$，$0\le V_i\le 2^{31}-1$。详细数据范围如下表。

| 测试点编号 | 时间限制/秒 | $n$                | $m$                | $q$                 |
| :-----: | :--------: | :------------------: | :------------------: | :-------------------: |
| $1$   |  $1$     | $ 100 $            | $ 100 $            | $ 4 \times 10 ^ 5 $ |
| $2,3$   |$1$     | $ 100 $            | $10^ { 6 }$ | $ 4 \times 10 ^ 5 $ |
| $4,5$   | $1$     | $ 10 ^ 4$ | $100$              | $ 4 \times 10 ^ 5 $ |
| $6,7,8$ |  $ 1 $   | $ 10 ^ 4$ | $10 ^ 6$    | $ 4 \times 10 ^ 5 $ |
| $9$    | $ 1.8 $ | $ 10 ^ 6$ | $100$              | $ 10^6$      |
| $10$   | $ 2.3 $ | $ 10 ^ 6$ | $ 10^6$     | $ 10 ^ 6$    |

## 样例 #1

### 输入

```
5 4 4
0 0 2 2 1
1 2
1 3
2 4
2 5
1 1
1 1
1 1
2 3 0
4 3 3
5 1
1 2
3 1 2
```

### 输出

```
3
3
3
0
3
0
2
```

## 样例 #2

### 输入

```
10 8 8
5 6 2 1 0 4 0 0 0 3
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
5 10
3 10 9
2 1 6
1 5
1 4
1 7
1 7
5 1
1 1
3 1 5
1 7
1 9
2 5 0
4 9 6
1 10
4 10 7
5 1
```

### 输出

```
2
3
3
3
3
2
3
1
3
7
7
7
1
0
```

# 题解

## 作者：FangZeLi (赞：4)

废话不多说，直接看题。

### Subtask1:

直接暴力模拟，不多说了，送分的。

### Subtask2:

在这一档部分分里，我们发现$m$的值急剧增大，达到了$10^6$级别。显然，我们需要一种$O(1)$的做法。

不妨设询问的点为$x$，我们先看以$1$为根的情况。在以1为根时，我们单独拉出来以条从$1$到$x$的路径。我们发现，在这条路径上的所有点，它们的子树都包含$x$。并且，$x$也只被这些点的子树所包含。

因为$x\operatorname{xor} x=0$，所以，我们只需要知道$x$被包含的次数即可。

那么这个次数是什么呢？

深度！！！

那么，在以$1$为根时，所有深度为奇数的点就全都被包含，深度为偶数的就不包含。

再来考虑换根。我们直接考虑换根后的深度的奇偶性。不妨设将$y$换为了根。这样，对深度的影响无非就是全被减去$y$的深度。不用担心深度出现负数，因为负数并不会影响之前的讨论。

其实也可以换一种角度理解。根无论是哪个点，对最终答案有贡献的点一定是一个隔着一个的。这样一来，答案就只有两种情况。恰好，同样答案的点可以用深度来分类。那么就可以用深度做了。

具体的，开一个数组```ans[2]```记录答案，```depth```数组表示深度。查询时输出```ans[depth[y]&1]```，修改时也修改一下即可。

### Subtask3:

这一档部分分是留给会树剖的同学的暴力分的。

（~~厚颜无耻~~的宣传一波自己的树剖博客：[重链剖分](https://www.luogu.com.cn/blog/FangZeLi/zhong-lian-pou-fen)）

考虑到1操作较少，每次重新剖分即可。

### Subtask4：

对于操作$3$，是经典的换根意义下的树剖例题，设根为$z$，查询的点为$x$和$y$，只需输出$\operatorname{LCA}(x,y)$，$\operatorname{LCA}(x,z)$，$\operatorname{LCA}(z,y)$中深度最大的哪个点。

对于操作$4$，由于路径与根无关，直接正常写。

对于操作$5$，只需讨论一下查询点与根的方向关系即可，比较简单，画图就可以发现查询的是整棵树挖去该查询点的一棵子树的异或值，不展开。

对于操作$1$，按调用Subtask2的方法进行处理。

那么，对于操作$2$，只需要维护一下操作$4$中的线段树即可。

结合Subtask2起来，即可拿到此档部分分。

### Subtask5&6:

这两档部分分放在一起讲。

回顾一下单纯的树剖，在处理操作4时，我们跳链的过程带着两个$\log$，再看一下数据范围，在被构造数据卡的情况下，是不可能过的。我们需要优化。

怎么优化呢？

我们考虑前缀和的思想，假如我们把点$i$到$1$号点的路径存下来，令其为$G_i$，那么，$4$操作就可以看成是$G_x \operatorname{xor} G_y \operatorname{xor} V_{\operatorname{LCA}(x,y)}$。

我们再来看一看怎么维护这个信息。

在单点修改时，我们发现，有影响的只是该点的子树。具体来说，所有位于该点子树中的点的$G$值都要先异或上原来的值，再异或上现在的值。

那么问题就变成了一个单点查询，区间修改。

至此，$4$操作被我们成功的优化至了一个$\log$。

另外，假如你会树剖，想到了这个优化方法，但没有想到Subtask2的结论，努力卡一卡常，依然能拿到Subtask5的分。

最后要注意，由于洛谷的数据点大小限制（~~也可能是我造数据能力太差~~），在Subtask4和正解之间拉不开时间上的差距，因此，本题卡常。所以，树剖中的所有维护区间信息的工具，均要使用树状数组，不然不保证能够通过。

附上AC代码（比较丑，见谅）：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<ctime>
using namespace std;

#define _N 1000001

#define lowbit(p) (p&-p)

struct Side
{
	int to;
	int next;
	Side()
	{
		to = next = 0;
	}
	Side(int a, int b)
	{
		to = a;
		next = b;
	}
};

int n, m, q;

int v[_N];
int res[2];

int root = 1;
int ncnt = 0;
int fa[_N];
int heavyson[_N];
int siz[_N];
int depth[_N];
int top[_N];
int id[_N];
int dfn[_N];

int treeval[_N];
int treesum[_N];

int sidecnt = 0;
int head[_N];
Side sides[2 * _N];

void inline Swap(int& a, int& b)
{
	int t = a;
	a = b;
	b = t;
}

void inline adde(int x, int y)
{
	sides[++sidecnt] = Side(y, head[x]);
	head[x] = sidecnt;
}

void xor_val(int p, int k)
{
	while (p <= n)
	{
		treeval[p] ^= k;
		p += lowbit(p);
	}
}
int query_val(int p)
{
	int ans = 0;
	while (p != 0)
	{
		ans ^= treeval[p];
		p -= lowbit(p);
	}
	return ans;
}
void xor_sum(int p, int k)
{
	while (p <= n)
	{
		treesum[p] ^= k;
		p += lowbit(p);
	}
}
int query_sum(int p)
{
	int ans = 0;
	while (p != 0)
	{
		ans ^= treesum[p];
		p -= lowbit(p);
	}
	return ans;
}

void update_treesum(int l, int r, int k)
{
	xor_sum(l, k);
	xor_sum(r + 1, k);
}
void update_treeval(int p, int k)
{
	xor_val(p, k);
}
int query_treesum(int p)
{
	return query_sum(p);
}
int query_treeval(int l, int r)
{
	return query_val(r) ^ query_val(l - 1);
}

void cut(int x, int father, int deep)
{
	siz[x] = 1;
	fa[x] = father;
	depth[x] = deep;
	res[depth[x] & 1] ^= v[x];
	int next = head[x];
	while (next != 0)
	{
		int y = sides[next].to;
		if (y != father)
		{
			cut(y, x, deep + 1);
			siz[x] += siz[y];
			if (siz[y] > siz[heavyson[x]])
			{
				heavyson[x] = y;
			}
		}
		next = sides[next].next;
	}
}
void inf(int x, int topfather)
{
	top[x] = topfather;
	id[x] = ++ncnt;
	dfn[ncnt] = x;
	if (heavyson[x] == 0)
	{
		return;
	}
	inf(heavyson[x], topfather);
	int next = head[x];
	while (next != 0)
	{
		int y = sides[next].to;
		if (y != fa[x] && y != heavyson[x])
		{
			inf(y, y);
		}
		next = sides[next].next;
	}
}

int lca(int x, int y)
{
	while (top[x] != top[y])
	{
		if (depth[top[x]] < depth[top[y]])
		{
			Swap(x, y);
		}
		x = fa[top[x]];
	}
	if (depth[x] > depth[y])
	{
		Swap(x, y);
	}
	return x;
}
int selca(int x, int y)
{
	while (top[x] != top[y])
	{
		if (depth[top[x]] < depth[top[y]])
		{
			Swap(x, y);
		}
		if (fa[top[x]] == y)
		{
			return top[x];
		}
		x = fa[top[x]];
	}
	if (depth[x] > depth[y])
	{
		Swap(x, y);
	}
	return heavyson[x];
}

int makeroot(int x)
{
	root = x;
	return res[depth[x] & 1];
}
void update_val(int x, int y)
{
	res[depth[x] & 1] ^= v[x] ^ y;
	update_treesum(id[x], id[x] + siz[x] - 1, v[x] ^ y);
	update_treeval(id[x], v[x] ^ y);
	v[x] = y;
}
int lca(int x, int y, int k)
{
	int a = lca(x, y);
	int b = lca(x, root);
	int c = lca(y, root);
	if (depth[a] > depth[b])
	{
		if (depth[a] > depth[c])
		{
			return a;
		}
		else
		{
			return c;
		}
	}
	else
	{
		if (depth[b] > depth[c])
		{
			return b;
		}
		else
		{
			return c;
		}
	}
}
int query_path(int x, int y)
{
	return query_treesum(id[x]) ^ query_treesum(id[y]) ^ v[lca(x, y)];
}
int query_sub(int x)
{
	if (x == root)
	{
		return query_treeval(id[1], id[1] + siz[1] - 1);
	}
	int a = lca(x, root);
	if (a == x)
	{
		int b = selca(root, x);
		return query_treeval(id[1], id[1] + siz[1] - 1) ^ query_treeval(id[b], id[b] + siz[b] - 1);
	}
	else
	{
		return query_treeval(id[x], id[x] + siz[x] - 1);
	}
}


int main()
{
	scanf("%d%d%d", &n, &m, &q);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &v[i]);
	}
	for (int i = 1; i < n; i++)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		adde(x, y);
		adde(y, x);
	}
	cut(1, 0, 1);
	inf(1, 1);
	for (int i = 1; i <= n; i++)
	{
		update_treeval(id[i], v[i]);
		update_treesum(id[i], id[i] + siz[i] - 1, v[i]);
	}
	for (int i = 1; i <= m + q; i++)
	{
		int opt, x, y;
		scanf("%d", &opt);
		switch (opt)
		{
		case 1:
			scanf("%d", &x);
			printf("%d\n", makeroot(x));
			break;
		case 2:
			scanf("%d%d", &x, &y);
			update_val(x, y);
			break;
		case 3:
			scanf("%d%d", &x, &y);
			printf("%d\n", lca(x, y, root));
			break;
		case 4:
			scanf("%d%d", &x, &y);
			printf("%d\n", query_path(x, y));
			break;
		case 5:
			scanf("%d", &x);
			printf("%d\n", query_sub(x));
			break;
		}
	}
	return 0;
}
```





---

## 作者：zhengrunzhe (赞：3)

提供一个常数大的一个log解法

出题人把询问分为了一百万个换根和一百万个其余操作，其中前者要求$O(1)$

而我的这个全都是一个log，相当于两百万个问用log的方法解决，也许像树状数组常树小的能过，但我这个lct常数实在是大我最多就卡到90，但这不是问题，主要是提供一个思路。~~听说有两只log的树状数组开O2艹过去了~~

**由于我不喜欢叫lct，叫$S-T \ Trees$**

**虚子树叫$dashed$，实链叫$solid$**

#### 首先看操作4:路径点权$xorsum$

S-T trees记下点权，维护实链的$xorsum$，$expose$提取路径返回即可

由于是有根树，$expose$需要$evert$换根，记下原本的$root$，$expose$之后把答案存下来，然后$evert(root)$把根换回去再返回答案

#### 接着看操作3:$lca$

s-t trees上找lca有一种做法是先$access(x)$，然后执行$access(y)$，看最后切换虚实的点即$lca$

这种做法是没什么问题的，我这里用的是另一种做法

在$root \ path$上的$non-local \ searching for \ LCA$

一般的树上距离公式:$dis(x,y)=dep_x+dep_y-2dep_{lca}+1$

移项一下:$2dep_{lca}=dep_x+dep_y-dis(x,y)+1$

系数化为1:$dep_{lca}=\frac {dep_x+dep_y-dis(x,y)+1}{2}$

然后我们$access(x)$把x到根的路径提取出来，然后在上面找第$dep_{lca}$个点，即在$root \ path$找排名为$dep_{lca}$的点，类似平衡树上二分即可

#### 操作5:子树$xorsum$

由于$xorsum$是可差分的，切换虚实链是可以通过$xor$掉原实儿子后$xor$新实儿子的，~~所以我们没有必要去写个toptree~~，直接s-t trees维护子树信息即可

考虑维护虚子树$xorsum$:   $dashed\_sum$

s-t tree上的子树$xorsum$(树簇异或和)表示为$sum$

可以这么维护:$sum=son[0]\rightarrow sum \bigoplus  val \bigoplus son[1]\rightarrow sum \bigoplus dashed\_sum$

考虑在$access$的时候把一个点$q$的右儿子$q\rightarrow son[1]$切换为$p$

$q\rightarrow dashed\_sum \bigoplus =q\rightarrow son[1]\rightarrow sum\bigoplus p\rightarrow sum$

异或原右儿子表示把原本的消除，后异或p表示加入p

然后要查询的点$p$的子树异或和$subtree\_sum$就是先$access(p)$，然后输出$p \rightarrow dashed\_sum \bigoplus p \rightarrow val$

#### 操作1:换根+询问所有子树异或和的异或和

不妨先算出原本的所有子树的异或和的异或和，然后再考虑每个操作对答案的影响

3,4,5操作都是没有影响的，现在考虑换根带来的影响

![](https://cdn.luogu.com.cn/upload/image_hosting/xz78m7ca.png)

考虑原根为$v$，把根换成$u$的影响，把$v$除到u路径的子树记作$B$，$u$的子树记作$A$，$u,v$的路径记作$[u,v]$，排除端点u,v的记作$(u,v)$，其中$w$为最上面的那个点,$sum_x$表示x的子树异或和

原本的答案记为$sum_u \bigoplus ans(u,v) \bigoplus ans_C \bigoplus sum_v \bigoplus ans_B \bigoplus ans_A$

新答案:$sum_u' \bigoplus ans(u,v)' \bigoplus ans_C \bigoplus sum_v' \bigoplus ans_A \bigoplus ans_B$

$sum_u'=sum_v$(就是整棵树的异或和)

$sum_v'=sum_v \bigoplus sum_w$ (少了到u路径的部分)

考虑$ans(u,v)'$有什么变化

将(u,v)上的所有点按左图由下往上编号$1,2,3,\cdots,|(u,v)|$

特别地,$0=u,|(u,v)|+1=v,|(u,v)|=w$

考虑一个点$k$的子树异或和咋变

![](https://cdn.luogu.com.cn/upload/image_hosting/rqyso3ui.png)

首先$k-1$以下的部分倒过来变成$k$的祖先，所以$sum_k\bigoplus=sum_{k-1}$

其次在$k$上方的所有点倒过来在$k$的子树中，所以$sum_k\bigoplus=sum_v \bigoplus sum_k$

然后我们对于所有的$k$串在一起，发生的变化为:

$(sum_0\bigoplus sum_v \bigoplus sum_1) \bigoplus(sum_1 \bigoplus sum_v \bigoplus sum_2)\bigoplus \cdots \bigoplus (sum_{|(u,v)|-1}\bigoplus sum_v \bigoplus sum_{|(u,v)|})$

由于异或有结合律合交换律，所以发现能删去一堆东西

$=sum_0 \bigoplus sum_1 \bigoplus sum_1 \bigoplus sum_2 \bigoplus sum_2 \bigoplus \cdots \bigoplus sum_{|(u,v)|}(\bigoplus sum_v \bigoplus sum_v \bigoplus \cdots \bigoplus sum_v)(|(u,v)| \text {次})$

中间的都可以消掉,最后由于异或偶数个相同的可以消除，所以化为

$sum_u \bigoplus sum_w (\bigoplus sum_v(|(u,v)|\text{为奇数}))$

然后考虑最终答案变了什么

$ans=sum_u \bigoplus ans(u,v) \bigoplus ans_C \bigoplus sum_v \bigoplus ans_B \bigoplus ans_A$

$ans'=sum_u' \bigoplus ans(u,v)' \bigoplus ans_C \bigoplus sum_v' \bigoplus ans_A \bigoplus ans_B$
$ans'=sum_v \bigoplus ans(u,v) \bigoplus sum_u \bigoplus sum_w (\bigoplus sum_v(|(u,v)|\text{为奇数}))\bigoplus ans_C \bigoplus sum_v \bigoplus sum_w \bigoplus ans_A \bigoplus ans_B$
$ans'=sum_u\bigoplus ans(u,v)(\bigoplus sum_v(|(u,v)|\text{为奇数}))\bigoplus ans_A \bigoplus ans_B \bigoplus ans_C$

$ans'\bigoplus ans=sum_v(\bigoplus sum_v(|(u,v)|\text{为奇数}))$

由于$|(u,v)|=dep_u-2$，奇偶性与$dep_u$相同

$ans'=ans(\bigoplus sum_v (dep_u\text{为偶数}))$

s-t trees维护实链长度$solid_size$，$access(u)$一下获取$dep_u$(即rootpath长度即solid_size)，$sum_v$就是整棵树的异或和，在操作2的时候变化

#### 操作2:单点修改

这一个操作也是会影响操作1的答案的，考虑变化了什么

**u到根路径上的所有点的子树异或和都消去了原来的点权加上了新的点权**

所以直接$access$然后看$dep_u$的奇偶性，是奇数答案就异或上$u\rightarrow val \bigoplus w$

然后把$u\rightarrow val$赋成$w$即可

$O(n \log n+(m+q) \log n)$

```cpp
#include<cstdio>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
template<class type>inline const void swap(type &a,type &b){const type c(a);a=b;b=c;}
const int N(1e6+10);
namespace Sleator_Tarjan_Trees
{
	struct tree
	{
		bool rev;
		int solid_size,val,dashed_sum,solid_sum,sum;
		tree *son[2],*fa;
		static tree *null;
		void *operator new(size_t size);
		void *operator new[](size_t size);
		inline tree():rev(0),solid_size(0),val(0),dashed_sum(0),solid_sum(0)
		{
			static bool init(0);
			if (!init)
				init=1,
				null=new tree,
				null->son[0]=null->son[1]=null->fa=null;
			son[0]=son[1]=fa=null;
		}
		inline const void pushup()
		{
			solid_size=son[0]->solid_size+1+son[1]->solid_size;
			solid_sum=son[0]->solid_sum^val^son[1]->solid_sum;
			sum=son[0]->sum^val^son[1]->sum^dashed_sum;
		}
		inline const void reverse()
		{
			swap(son[0],son[1]);rev^=1;
		}
		inline const void pushdown()
		{
			if (rev)son[0]->reverse(),son[1]->reverse(),rev=0;
		}
		inline const bool isroot()
		{
			return fa->son[0]!=this&&fa->son[1]!=this;
		}
		inline const bool id()
		{
			return fa->son[1]==this;
		}
		inline const void set(tree *p,const bool &d)
		{
			(son[d]=p)->fa=this;
		}
		inline const void rotate()
		{
			fa->pushdown();pushdown();
			const bool f(id());
			tree *fa(this->fa),*gfa(fa->fa),*q(son[f^1]);
			if (!fa->isroot())gfa->son[fa->id()]=this;
			(son[f^1]=fa)->son[f]=q;
			((q->fa=fa)->fa=this)->fa=gfa;
			fa->pushup();pushup();
		}
		inline const void splay()
		{
			for (pushdown();!isroot();rotate())
				if (!fa->isroot())
					fa->fa->pushdown(),
					(fa->id()^id()?this:fa)->rotate();
		}
	}*root,*node0,*tree::null;
	#define null tree::null
	inline tree *node(const int &x){return node0+x;}
	char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof memory_pool);
	inline void *tree::operator new(size_t size){return tail-=size;}
	inline void *tree::operator new[](size_t size){return tail-=size;}
	inline const void access(tree *p)
	{
		p->splay();
		p->dashed_sum^=p->son[1]->sum;
		p->son[1]=null;
		p->pushup();
		for (tree *q(p->fa);q!=null;q=p->fa)
			q->splay(),
			q->dashed_sum^=q->son[1]->sum,
			q->dashed_sum^=(q->son[1]=p)->sum,
			q->pushup(),
			p->rotate();
	}
	inline const void evert(tree *p)
	{
		access(p);p->reverse();
	}
	inline const void expose(tree *p,tree *q)
	{
		evert(p);access(q);
	}
	inline const void link(tree *p,tree *q)
	{
		access(p);evert(q);p->set(q,1);p->pushup();
	}
	inline tree *lca(tree *p,tree *q)
	{
		expose(p,q);
		const int dispq(q->solid_size);
		evert(root);
		access(q);const int depq(q->solid_size);
		access(p);const int depp(p->solid_size);
		int deplca(depp+depq-dispq+1>>1);
		while (p->pushdown(),1)
			if (deplca<=p->son[0]->solid_size)p=p->son[0];
			else if (!(deplca-=p->son[0]->solid_size+1))return p;
				else p=p->son[1];
	}
	inline const int path_sum(tree *p,tree *q)
	{
		expose(p,q);
		const int sum(q->solid_sum);
		evert(root);
		return sum;
	}
	inline const int subtree_sum(tree *p)
	{
		access(p);return p->val^p->dashed_sum;
	}
}using namespace Sleator_Tarjan_Trees;
int n,m,q,ans,sum[N],all;
int head[N],edc,to[N<<1],next[N<<1];
inline const void connect(const int &u,const int &v)
{
	next[++edc]=head[u];to[head[u]=edc]=v;
	next[++edc]=head[v];to[head[v]=edc]=u;
}
inline const void dfs(const int &p,const int &fa)
{
	sum[p]=node(p)->val;
	for (int son,i(head[p]);i;i=next[i])
		if ((son=to[i])^fa)
			dfs(son,p),
			sum[p]^=sum[son],
			link(node(p),node(son));
	ans^=sum[p];
	node(p)->pushup();
}
inline const void modify(const int &x,const int &y)
{
	access(node(x));
	const int dep(node(x)->solid_size);
	if (dep&1)ans^=node(x)->val^y;
	all^=node(x)->val^y;
	node(x)->val=y;
	node(x)->pushup();
}
inline const void makeroot(const int &x)
{
	access(node(x));
	const int dep(node(x)->solid_size);
	if (!(dep&1))ans^=all;
	(root=node(x))->reverse();
}
int main()
{
	read(n);read(m);read(q);
	node0=new tree[n+1];
	for (int i(1);i<=n;i++)read(node(i)->val),all^=node(i)->val;
	for (int u,v,i(1);i<n;i++)read(u),read(v),connect(u,v);
	dfs(1,0);root=node(1);
	for (int opt,x,y,i(1);i<=m+q;i++)
		switch (read(opt),read(x),opt)
		{
			case 1:makeroot(x);printf("%d\n",ans);break;
			case 2:read(y);modify(x,y);break;
			case 3:read(y);printf("%d\n",lca(node(x),node(y))-node0);break;
			case 4:read(y);printf("%d\n",path_sum(node(x),node(y)));break;
			case 5:printf("%d\n",subtree_sum(node(x)));break;
		}
	return 0;
}
```

---


# [RC-02] GCD

## 题目背景

小 A：数论题真是无聊呢，一天到晚枚举二元组、三元组，太无聊了。

小 B：对呀对呀，都是套路。

小 A：要不我们试试枚举四元组？

小 B：......

于是就有了这道题。


## 题目描述

给出 $N$，求：

$$
\sum_{i=1}^N\sum_{j=1}^N\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(i,j)=1][\gcd(p,q)=1]
$$

答案模 $998244353$。

$[]$ 是条件表达式。当括号里面的式子成立时值为 $1$，否则为 $0$。

## 说明/提示

对于所有数据，保证 $1\le N\le 2\times10^9$，所有测试点的时限均为 $1\text{s}$，空间限制均为 $500\text{MB}$。

| 测试点编号 | $N$               |
| ---------- | ----------------- |
| $1$          | $\le 100$         |
| $2$          | $\le 400$         |
| $3,4,5,6$ | $\le10^6$ |
| $7,8$       | $\le 2\times10^7$ |
| $9$          | $\le 2\times10^8$ |
| $10$         | $\le 2\times10^9$ |

这题其实可以搞一个测试点多组数据，但良心的出题人为了多给你们一点部分分，就决定只来一组数据。

idea 源自 @Fee_cle6418，题目的题面，标算，数据源自 @FangZeLi。

## 样例 #1

### 输入

```
50
```

### 输出

```
104527
```

## 样例 #2

### 输入

```
200
```

### 输出

```
6664993
```

## 样例 #3

### 输入

```
500000
```

### 输出

```
835964450
```

## 样例 #4

### 输入

```
10000000
```

### 输出

```
503290049```

## 样例 #5

### 输入

```
100000000```

### 输出

```
712748411
```

## 样例 #6

### 输入

```
1000000000```

### 输出

```
845640070
```

# 题解

## 作者：FangZeLi (赞：22)

作为一道立志于打破套路的套路数论题，这题其实不是很难。

这道题有两种思路，一种很暴力，需要很扎实的基本功。一种很巧妙，需要很强的思维能力。

现在，我们以推出正解式子的过程，来讲解一下这道题目。

法一：暴力
$$
\sum_{i=1}^N\sum_{j=1}^N\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(i,j)==1][\gcd(p,q)==1]
$$
拿到这个式子，我们先进行最最基本的变形：
$$
=\sum_{i=1}^N\sum_{j=1}^N[\gcd(i,j)==1]\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(p,q)==1]
$$

假如在这时候停笔枚举，就可以过第一个测试点。10 pts get！（然而复杂度我不会算233）

将后面拎出来看：
$$
\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(p,q)==1]
$$
这不正是我们最最熟悉的吗？

接下来有两种做法：

1. 我会莫比乌斯反演！

   套路的化简后半部分：

   
$$
=\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{d\mid\gcd(j,k)}\mu(d)
$$
$$
=\sum_{d=1}^{\lfloor\frac{N}{j}\rfloor}\lfloor\frac{\lfloor\frac{N}{j}\rfloor}{d}\rfloor\lfloor\frac{\lfloor\frac{N}{j}\rfloor}{d}\rfloor\mu(d)
$$
   代回原式，得：
$$
=\sum_{i=1}^N\sum_{j=1}^N[\gcd(i,j)==1]\sum_{d=1}^{\lfloor\frac{N}{j}\rfloor}\lfloor\frac{\lfloor\frac{N}{j}\rfloor}{d}\rfloor\lfloor\frac{\lfloor\frac{N}{j}\rfloor}{d}\rfloor\mu(d)
$$
   直接数论分块后按公式计算，复杂度$O(n^2\sqrt{n})$，20 pts get！

3. 我精通数论函数！

   假如你做过[SDOI2008仪仗队](https://www.luogu.com.cn/problem/P2158)，就应该会这种做法，化简后半部分：
   
$$
=2\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^p[\gcd(p,q)==1]-1
$$
   我们看这一部分
$$
\sum_{q=1}^p[\gcd(p,q)==1]
$$
   这恰好是$\varphi$函数的定义式。

   因此：
$$
=2\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\varphi(p)-1
$$
   记$\varphi^s(n)=\sum_{i=1}^n\varphi(i)$，得：
$$
=2\varphi^s(\lfloor\frac{N}{j}\rfloor)-1
$$
   回代入原式：
$$
=\sum_{i=1}^N\sum_{j=1}^N[\gcd(i,j)==1](2\varphi^s(\lfloor\frac{N}{j}\rfloor)-1)
$$
   用线性筛预处理出$\varphi$及其前缀和，再按公式计算即可。

   复杂度$O(n^2)$。20 pts get！

显然，我们绝不能满足于这样的复杂度，所以继续前进。

注意到后边的部分已经做的很好了，很难有继续优化的可能，在这样的情况下，前面的$[\gcd(i,d)==1]$就成了我们的眼中钉，肉中刺。

但这一部分却不能像之前一样优化，因为后面的部分依赖于此处枚举的$j$。

那没办法，莫比乌斯反演总行吧，大不了把$d$留着呗。
$$
=\sum_{g=1}^N\sum_{i=1}^{\lfloor\frac{N}{g}\rfloor}\sum_{j=1}^{\lfloor\frac{N}{g}\rfloor}\mu(g)(2\varphi^s(\lfloor\frac{N}{jg}\rfloor)-1)
$$
$$
=\sum_{g=1}^N\lfloor\frac{N}{g}\rfloor\mu(g)\sum_{j=1}^{\lfloor\frac{N}{g}\rfloor}(2\varphi^s(\lfloor\frac{N}{jg}\rfloor)-1)
$$
接下来，又有两种方法了：

1. 我精通套路！

   发现原式关于$g$和$j$的枚举其实就是在枚举乘积不大于$n$的二元组，于是令$T=gj$，得：

   
$$
=\sum_{T=1}^N(2\varphi^s(\lfloor\frac{N}{T}\rfloor)-1)\sum_{g\mid T}\lfloor\frac{N}{g}\rfloor\mu(g)
$$
   假如我们令$f(T)=\sum_{d\mid T}\lfloor\frac{N}{d}\rfloor\mu(d)$，$h(T)=2\varphi^s(T)-1$，原式就化为：
$$
=\sum_{T=1}^Nh(\lfloor\frac{N}{T}\rfloor)f(T)
$$
   这是一个除法分块的形式，可以在预处理后$O(\sqrt{n})$的时间内求出。

   问题就在于如何预处理。

   $g$是很好求的，而$f$很棘手，$f$甚至不是一个积性函数。

   那，既然无法线性筛，我们就枚举每一个数$p$及其倍数，暴筛吧。

   复杂度是调和级数$O(n\log n)$，60 pts get！

3. 我精通数论分块！

   我们观察原式，将其直接分为两个部分：
   
$$
=\sum_{g=1}^N\mu(g)\times\lfloor\frac{N}{g}\rfloor\sum_{j=1}^{\lfloor\frac{N}{g}\rfloor}(2\varphi^s(\lfloor\frac{N}{jg}\rfloor)-1)
$$
   我们重新定义函数$f$：
$$
   f(T)=T\sum_{i=1}^T(2\varphi^s(\lfloor\frac{T}{i}\rfloor)-1)
$$
   显然，这个函数可以数论分块$O(\sqrt{n})$求。

   代回原式：
$$
\sum_{g=1}^N\mu(g)f(\lfloor\frac{N}{g}\rfloor)
$$
   这个式子也是可以数论分块$O(\sqrt{n})$求的。

   但我们再一次遇到了预处理的难题，这次如果再暴力，复杂度就是$O(n\sqrt{n})$的，还不如上一种方法。

   答案是：我们根本不需要预处理！

   再对第二个式子数论分块时，我们求出所需的$f$值即可。

   这样做，复杂度是$O(n^\frac{3}{4})$的，考虑到预处理的$O(n)$复杂度，总复杂度依然是$O(n)$的。80 pts get！

   如何改进复杂度呢？

   预处理使用杜教筛，即可使复杂度瓶颈变为计算的过程。新复杂度是$O(n^\frac{3}{4})$的。90 pts get！

   文末会有该档部分分的代码。

法二：思维

不进行任何变形：
$$
\sum_{i=1}^N\sum_{j=1}^N\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(i,j)==1][\gcd(p,q)==1]
$$
仔细观察这个式子，你会发现，关于$j$的枚举，很像是在枚举$p$，$q$的$\gcd$。

我们来试一试。
$$
=\sum_{i=1}^N\sum_{p=1}^N\sum_{q=1}^N[\gcd(i,\gcd(p,q))==1]
$$

$$
=\sum_{i=1}^N\sum_{p=1}^N\sum_{q=1}^N[\gcd(i,p,q)==1]
$$

写到这里，你可以停笔$O(n^3)$的去枚举（~~10 pts get~~），但其实你离另一种正解只有两步之遥。
$$
=\sum_{d=1}^N\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{p=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{d}\rfloor}\mu(d)
$$

$$
=\sum_{d=1}^N\mu(d)\lfloor\frac{N}{d}\rfloor\lfloor\frac{N}{d}\rfloor\lfloor\frac{N}{d}\rfloor
$$

这个式子可以在$O(n)$的预处理后，$O(\sqrt{n})$的求得，总复杂度$O(n)$。80 pts get！

和上一种方法一样，我们使用杜教筛优化。瓶颈依旧是预处理，但复杂度降至$O(n^\frac{2}{3})$，100 pts get！

文末会有该标程的代码。

接下来是代码时间：

90 pts的代码：

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>

using namespace std;

#define _N 1000001
#define _P 998244353
#define _INV 499122177

int n;

int pricnt = 0;
bool visited[_N];
int prime[_N];
int mu[_N];
int phi[_N];

map<int, int> ansmu, ansphi;

long long ans = 0;

void sieve()
{
	int range = n + 1 < _N ? n + 1 : _N;
	visited[1] = true;
	mu[1] = phi[1] = 1;
	for (int i = 1; i < range; i++)
	{
		if (!visited[i])
		{
			prime[++pricnt] = i;
			mu[i] = _P - 1;
			phi[i] = i - 1;
		}
		for (int j = 1; j <= pricnt; j++)
		{
			if (i * prime[j] >= range)
			{
				break;
			}
			visited[i * prime[j]] = true;
			if (i % prime[j])
			{
				mu[i * prime[j]] = (_P - mu[i]) % _P;
				phi[i * prime[j]] = phi[i] * phi[prime[j]] % _P;
			}
			else
			{
				phi[i * prime[j]] = phi[i] * prime[j] % _P;
				break;
			}
		}
	}
	for (int i = 1; i < range; i++)
	{
		mu[i] = (mu[i - 1] + mu[i]) % _P;
		phi[i] = (phi[i - 1] + phi[i]) % _P;
	}
}

int getmu(int x)
{
	if (x < _N)
	{
		return mu[x];
	}
	if (ansmu[x])
	{
		return ansmu[x];
	}
	long long res = 1;
	for (int l = 2, r; l <= x; l = r + 1)
	{
		r = x / (x / l);
		res = (res - ((long long)r - l + 1) * getmu(x / l) % _P + _P) % _P;
	}
	return ansmu[x] = res;
}

int getphi(int x)
{
	if (x < _N)
	{
		return phi[x];
	}
	if (ansphi[x])
	{
		return ansphi[x];
	}
	long long res = (long long)x * ((long long)x + 1) % _P * _INV % _P;
	for (int l = 2, r; l <= x; l = r + 1)
	{
		r = x / (x / l);
		res = (res - ((long long)r - l + 1) * getphi(x / l) % _P + _P) % _P;
	}
	return ansphi[x] = res;
}

long long f(int n)
{
	long long res = 0;
	for (int l = 1, r = 0; l <= n; l = r + 1)
	{
		r = n / (n / l);
		res = (res + (r - l + 1) * (2 * getphi(n / l) % _P - 1) % _P) % _P;
	}
	res = res * n % _P;
	return res;
}

int main()
{
	scanf("%d", &n);
	sieve();
	for (int l = 1, r = 0; l <= n; l = r + 1)
	{
		r = n / (n / l);
		ans = (ans + ((long long)getmu(r) - getmu(l - 1) + _P) % _P * f(n / l) % _P) % _P;
	}
	printf("%lld\n", ans);
	return 0;
}
```

100 pts的代码：

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>

using namespace std;

#define _N 1000001
#define _P 998244353

int n;

int pricnt = 0;
bool visited[_N];
int prime[_N];
int mu[_N];

map<int, int> ansmu;

long long ans = 0;

void sieve()
{
	int range = n + 1 < _N ? n + 1 : _N;
	visited[1] = true;
	mu[1] = 1;
	for (int i = 1; i < range; i++)
	{
		if (!visited[i])
		{
			prime[++pricnt] = i;
			mu[i] = _P - 1;
		}
		for (int j = 1; j <= pricnt; j++)
		{
			if (i * prime[j] >= range)
			{
				break;
			}
			visited[i * prime[j]] = true;
			if (i % prime[j])
			{
				mu[i * prime[j]] = (_P - mu[i]) % _P;
			}
			else
			{
				break;
			}
		}
	}
	for (int i = 1; i < range; i++)
	{
		mu[i] = (mu[i - 1] + mu[i]) % _P;
	}
}

int getmu(int x)
{
	if (x < _N)
	{
		return mu[x];
	}
	if (ansmu[x])
	{
		return ansmu[x];
	}
	long long res = 1;
	for (int l = 2, r; l <= x; l = r + 1)
	{
		r = x / (x / l);
		res = (res - ((long long)r - l + 1) * getmu(x / l) % _P + _P) % _P;
	}
	return ansmu[x] = res;
}

int main()
{
	scanf("%d", &n);
	sieve();
	for (int l = 1, r = 0; l <= n; l = r + 1)
	{
		r = n / (n / l);
		ans = (ans + ((long long)getmu(r) - getmu(l - 1) + _P) % _P * ((long long)n / l) % _P * ((long long)n / l) % _P * ((long long)n / l) % _P) % _P;
	}
	printf("%lld\n", ans);
	return 0;
}
```

Update At 2024/11/19: 修复了文中的 $\LaTeX$ 公式显示。

---

## 作者：1saunoya (赞：11)

没啥好说的，杜教筛板子题。


$$\sum_{i=1}^{N} \sum_{j=1}^{N}\sum_{p=1}^{\lfloor \frac{N}{j} \rfloor}\sum_{q=1}^{\lfloor \frac{N}{j} \rfloor} [\gcd(i,j)==1][\gcd(p,q)==1]$$


容易发现，我们枚举 $j$ 其实是相当于枚举 $\gcd$
~~才不是枚举题目~~

然后式子可以变成

$$\sum_{i=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N} [\gcd(i,p,q)==1]$$

然后套路式的枚举 $gcd$ ~~依旧不是枚举题目~~

$$\sum_{d=1}^{N}\sum_{i=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i,p,q)==d]$$

熟悉的形式，其实就等于

$$\sum_{d=1}^{N}\sum_{i=1}^{\lfloor \frac{N}{d} \rfloor} \sum_{p=1}^{\lfloor \frac{N}{d} \rfloor} \sum_{q=1}^{\lfloor \frac{N}{d} \rfloor} \mu(d)$$

$$\sum_{d=1}^{N} \mu(d) \lfloor \frac{N}{d}\rfloor^3$$

然后整除分块就完了，由于 $N$ 比较大，大力杜教筛就完事了，~~话说我好像是这题除掉出题人的最优解~~

```cpp
// powered by c++11
// by Isaunoya
#include<bits/stdc++.h>
#define rep(i , x , y) for(register int i = (x) ; i <= (y) ; ++ i)
#define Rep(i , x , y) for(register int i = (x) ; i >= (y) ; -- i)
using namespace std ;
using db = double ;
using ll = long long ;
using uint = unsigned int ;
#define int long long
using pii = pair < int , int > ;
#define ve vector
#define Tp template
#define all(v) v.begin() , v.end()
#define sz(v) ((int)v.size())
#define pb emplace_back
#define fir first
#define sec second
// the cmin && cmax
Tp < class T > void cmax(T & x , const T & y) { if(x < y) x = y ; }
Tp < class T > void cmin(T & x , const T & y) { if(x > y) x = y ; }
// sort , unique , reverse
Tp < class T > void sort(ve < T > & v) { sort(all(v)) ; }
Tp < class T > void unique(ve < T > & v) { sort(all(v)) ; v.erase(unique(all(v)) , v.end()) ; }
Tp < class T > void reverse(ve < T > & v) { reverse(all(v)) ; }
const int SZ = 0x191981 ;
struct FILEIN {
	~ FILEIN () {} char qwq[SZ] , * S = qwq , * T = qwq , ch ;
	char GETC() { return (S == T) && (T = (S = qwq) + fread(qwq , 1 , SZ , stdin) , S == T) ? EOF : * S ++ ; }
	FILEIN & operator >> (char & c) { while(isspace(c = GETC())) ; return * this ; }
	FILEIN & operator >> (string & s) {
		while(isspace(ch = GETC())) ; s = ch ;
		while(! isspace(ch = GETC())) s += ch ; return * this ;
	}
	Tp < class T > void read(T & x) {
		bool sign = 1 ; while((ch = GETC()) < 0x30) if(ch == 0x2d) sign = 0 ;
		x = (ch ^ 0x30) ; while((ch = GETC()) > 0x2f) x = x * 0xa + (ch ^ 0x30) ;
		x = sign ? x : -x ;
	}
	FILEIN & operator >> (int & x) { return read(x) , * this ; }
	FILEIN & operator >> (signed & x) { return read(x) , * this ; }
	FILEIN & operator >> (unsigned & x) { return read(x) , * this ; }
} in ;
struct FILEOUT { const static int LIMIT = 0x114514 ;
	char quq[SZ] , ST[0x114] ; signed sz , O ;
	~ FILEOUT () { sz = O = 0 ; }
	void flush() { fwrite(quq , 1 , O , stdout) ; fflush(stdout) ; O = 0 ; }
	FILEOUT & operator << (char c) { return quq[O ++] = c , * this ; }
	FILEOUT & operator << (string str) {
		if(O > LIMIT) flush() ; for(char c : str) quq[O ++] = c ; return * this ;
	}
	Tp < class T > void write(T x) {
		if(O > LIMIT) flush() ; if(x < 0) { quq[O ++] = 0x2d ; x = -x ; }
		do { ST[++ sz] = x % 0xa ^ 0x30 ; x /= 0xa ; } while(x) ;
		while(sz) quq[O ++] = ST[sz --] ; return ;
	}
	FILEOUT & operator << (int x) { return write(x) , * this ; }
	FILEOUT & operator << (signed x) { return write(x) , * this ; }
	FILEOUT & operator << (unsigned x) { return write(x) , * this ; }
} out ;

const int maxn = 5e5 ;
int mu[maxn + 10] ;
const int mod = 998244353 ;
map < int , int > _mu ;
int getmu(int x) {
	if(x <= maxn) return mu[x] ;
	if(_mu[x]) return _mu[x] ;
	int ans = 1 ;
	int l = 2 , r = 0 ;
	for( ; l <= x ; l = r + 1) {
		r = x / (x / l) ;
		ans -= getmu(x / l) * (r - l + 1) ;
		ans = (ans + mod) % mod ;
	}
	return _mu[x] = ans ;
}
signed main() {
#ifdef _WIN64
	freopen("testdata.in" , "r" , stdin) ;
#else
	ios_base :: sync_with_stdio(false) ;
	cin.tie(nullptr) , cout.tie(nullptr) ;
#endif
// code begin.
	mu[1] = 1 ;
	for(int i = 1 ; i <= maxn ; i ++)
		for(int j = i + i ; j <= maxn ; j += i) 
			mu[j] -= mu[i] ;
	for(int i = 2 ; i <= maxn ; i ++)
		mu[i] = (mu[i] + mu[i - 1]) % mod ;
	int n ;
	in >> n ;
	int l = 1 , r = 0 ;
	int ans = 0 ;
	for( ; l <= n ; l = r + 1) {
		r = n / (n / l) ;
		int qwq = (n / l) * (n / l) % mod * (n / l) % mod ;
		ans = (ans + (getmu(r) - getmu(l - 1) + mod) % mod * qwq % mod) % mod ;
	}
	out << ans << '\n' ;
	return out.flush() , 0 ;
// code end.
}
```

---

## 作者：一扶苏一 (赞：6)

## 【莫比乌斯反演】P6055 [RC-02] GCD

### Analysis

这里有一个又弱智又麻烦的推式子的过程。

求

$$A(n) = \sum_{i=1}^N\sum_{j=1}^N\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(i,j)=1][\gcd(p,q)=1]$$

发现第一个方括号和 $p,q$ 无关，提到前面来

$$\begin{aligned}
A(N) &=  \sum_{i=1}^N\sum_{j=1}^N[\gcd(i,j)=1]\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(p,q)=1]\\
 &= \sum_{i=1}^N\sum_{j=1}^N \epsilon(\gcd(i, j))\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}\epsilon(\gcd(p,q))
\end{aligned}$$

其中 $\epsilon(x) = [x = 1]$ 为幺元函数。

然后把前半部分按照套路反演一下，众所周知 $\mu \circ 1 = \epsilon$，因此

$$\begin{aligned}
A(N) &= \sum_{i=1}^N\sum_{j=1}^N \sum_{d \mid i \land d \mid j} \mu(d)\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}\epsilon(\gcd(p,q)) \\
&= \sum_{d = 1}^N \mu(d) \lfloor\frac{N}{d}\rfloor \sum_{k = 1}^{\lfloor\frac{N}{d}\rfloor}\sum_{p=1}^{\lfloor\frac{N}{kd}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{kd}\rfloor}\epsilon(\gcd(p,q)) 
\end{aligned}$$

设 

$$\begin{aligned}
F(x) 
&= \sum_{k = 1}^{x}\sum_{i = 1}^{\lfloor\frac{x}{k}\rfloor} \sum_{j = 1}^{\lfloor\frac{x}{k}\rfloor} \epsilon(\gcd(i, j))
\end{aligned}$$

则

$$\begin{aligned}
A(N) 
&=\sum_{d = 1}^N \mu(d) \lfloor\frac{N}{d}\rfloor \times F(\lfloor\frac{N}{d}\rfloor)
\end{aligned}$$

式子长得很好看，看起来只要解决了 $F$ 就万事大吉了。

设 

$$G(x) = \sum_{i = 1}^{x} \sum_{j = 1}^{x}\epsilon(\gcd(i, j))$$

同样反演一下，套路的得到

$$G(x) = \sum_{d = 1}^x \mu(d) \lfloor\frac{x}{d}\rfloor^2$$

则 

$$\begin{aligned}
F(x) 
&= \sum_{k = 1}^{x} G(\lfloor\frac{x}{k}\rfloor) \\
&= \sum_{k = 1}^{x} \sum_{d = 1}^{\lfloor\frac{x}{k}\rfloor} \mu(d) \lfloor\frac{x}{kd}\rfloor^2
\end{aligned}$$

设 $T = kd$，把 $T$ 提出来枚举，那么 $d$ 应该作为 $T$ 的因数进行枚举。

$$\begin{aligned}
F(x) 
&= \sum_{T = 1}^{x} \sum_{t \mid T} \mu(t) \times \lfloor\frac{x}{T}\rfloor^2\\
&= \sum_{T = 1}^{x}\lfloor\frac{x}{T}\rfloor^2 \times \sum_{t \mid T} \mu(t) \\
\end{aligned}$$

我们发现 $\sum_{t \mid T} \mu(t)$ 就是 $\mu \circ 1$ 的第 $T$ 项。而众所周知 $\mu \circ 1 = \epsilon$，因此当且仅当 $T = 1$ 时，$\lfloor\frac{x}{T}\rfloor^2$ 对答案有贡献，为 $x^2$。因此

$$F(x) = x^2$$

（也算是为楼下某个打表找规律题解补了个证明吧 233）

带回 $A(N)$，得到

$$\begin{aligned}
A(N) 
&=\sum_{d = 1}^N \mu(d) \lfloor\frac{N}{d}\rfloor \times F(\lfloor\frac{N}{d}\rfloor)  \\
&=\sum_{d = 1}^N \mu(d) \lfloor\frac{N}{d}\rfloor \times \lfloor\frac{N}{d}\rfloor^2 \\
&=\sum_{d = 1}^N \mu(d) \lfloor\frac{N}{d}\rfloor^3\end{aligned}$$

整除分块+杜教筛即可。时间复杂度 $O(n^{\frac{2}{3}})$。

### Code

```cpp
#include <iostream>
#include <unordered_map>

const int maxn = 10000007;
const int p = 998244353;

int n, pcnt;
int prm[maxn], mu[maxn];
bool np[maxn];

void Sieve();
long long S(const int x);
long long p3(const int x);

int main() {
  std::cin >> n;
  Sieve();
  long long ans = 0;
  for (int i = 1, x, y; i <= n; i = y + 1) {
    x = n / i; y = n / x;
    (ans += (S(y) - S(i - 1)) * p3(x)) %= p;
  }
  std::cout << (ans + p) % p<< std::endl;
}

long long p3(const int x) {
  return 1ll * x * x % p * x % p;
}

long long S(const int x) {
  static std::unordered_map<int, int> rec;
  if (x < maxn) return mu[x];
  if (rec.count(x) != false) return rec[x];
  long long ans = 1;
  for (int i = 2, a, b; i <= x; i = b + 1) {
    a = x / i; b = x / a;
    ans -= (b - i + 1) * S(a);
  }
  return rec[x] = ans % p;
}

void Sieve() {
  mu[1] = 1;
  for (int i = 2; i < maxn; ++i) {
    if (np[i] == false) {
      mu[i] = -1;
      prm[++pcnt] = i;
    }
    for (int j = 1, u = prm[j], v = i * u; j <= pcnt; v = i * (u = prm[++j])) if (v < maxn) {
      np[v] = true;
      if ((i % u) == 0) break;
      mu[v] = -mu[i];
    } else {
      break;
    }
    mu[i] += mu[i - 1];
  }
}
```



---

## 作者：ix35 (赞：4)

没啥好说的，就是非常套路的根据莫比乌斯反演推式子：

![](https://cdn.luogu.com.cn/upload/image_hosting/837s7veq.png)

最后这个是个套路的整除分块+杜教筛维护 $\mu$ 的前缀和，然后结束了。

整个题就很套路，据说还有 OEIS 做法，没了解过。

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const int MAXN=5000010,DSQRT=50010,P=998244353;
int n,tot,ans,mu[MAXN],q[MAXN],smu[MAXN],p[MAXN];
map <int,int> u;
void init () {
    mu[1]=smu[1]=1;
    for (int i=2;i<=MAXN-10;i++) {
        if (!q[i]) {p[++tot]=i,mu[i]=-1;}
        for (int j=1;j<=tot&&i*p[j]<=MAXN-10;j++) {
            if (i%p[j]==0) {
                q[i*p[j]]=1,mu[i*p[j]]=0;
                break;
            }
            q[i*p[j]]=1,mu[i*p[j]]=-mu[i];
        }
        smu[i]=smu[i-1]+mu[i];
    }
    return;
}
int sm (int x) {
    if (x<=MAXN-10) {return smu[x];}
    if (u[x]) {return u[x];}
    int ans=1;
    for (int l=2,r;l<=x;l=r+1) {
        r=x/(x/l);
        ans-=sm(x/l)*(r-l+1);
    }
    return u[x]=ans;
}
int main () {
    init();
    scanf("%d",&n);
    for (int l=1,r;l<=n;l=r+1) {
    	r=n/(n/l);
    	int tmp=(1ll*(n/l)*((1ll*(n/l)*(n/l))%P))%P;
    	ans=(ans+(1ll*tmp*(sm(r)-sm(l-1)+P))%P)%P;
	}
	printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Rusalka (赞：3)

 
~~式子是在数学课上推的，幸好没被老师发现。~~

### 题意

- 求 $ \sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\sum\limits_{p=1}^{\lfloor \frac{N}{j} \rfloor} \sum\limits_{q=1}^{\lfloor \frac{N}{j} \rfloor} [\gcd(i,j)=1][\gcd(p,q)=1]$

- 答案对 $998\ 244\ 353$ 取模

-  $1 \le N \le 2 \times10^9$


### ~~愉快地~~推式子环节

首先观察原式的这一部分：
$$\sum\limits_{j=1}^{N}\sum\limits_{p=1}^{\lfloor \frac{N}{j} \rfloor} \sum\limits_{q=1}^{\lfloor \frac{N}{j} \rfloor} [\gcd(p,q)=1]$$

不难发现上式等价于：
$$\sum\limits_{j=1}^{N}\sum\limits_{p=1}^{N} \sum\limits_{q=1}^{N} [\gcd(p,q)=j]$$

也就是说，只有当 $\gcd(p,q)=j$ 时，才对答案有贡献。

所以可以省去枚举 $j$ ，并且把 $j$ 用 $ \gcd(p,q) $ 替换掉，得到：
$$\sum\limits_{i=1}^{N}\sum\limits_{p=1}^{N} \sum\limits_{q=1}^{N} [\gcd(i,\gcd(p,q))=1]$$

根据 $\gcd$ 的性质，可以得到：
$$\sum\limits_{i=1}^{N}\sum\limits_{p=1}^{N} \sum\limits_{q=1}^{N} [\gcd(i,p,q)=1]$$

接下来就都是套路了。根据 $\mu$ 的基本性质，可以将原式化为：

$$ \sum\limits_{i=1}^{N}\sum\limits_{p=1}^{N} \sum\limits_{q=1}^{N} \sum\limits_{d|gcd(i,p,q)} \mu(d)$$

枚举 $d$ ，则有：

$$ \sum\limits_{d=1}^{N}\sum\limits_{i=1}^{\lfloor \frac{N}{d} \rfloor}\sum\limits_{p=1}^{\lfloor \frac{N}{d} \rfloor} \sum\limits_{q=1}^{\lfloor \frac{N}{d} \rfloor}  \mu(d)$$

即：

$$ \sum\limits_{d=1}^{N}\mu(d) \lfloor {\dfrac{N}{d}  \rfloor}^{3}$$

然后发现数据范围不允许线筛，根据 $\mu*I=\epsilon$ （ $*$ 是狄利克雷卷积），杜教筛求 $\mu$ 的前缀和就好了。

注意取模。


### Code

``` cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <tr1/unordered_map>

using namespace std;

typedef long long ll;
const int MAXN = 6000010;
const int MOD = 998244353;

inline int add(int x, int y){return (x+=y)>=MOD?x-MOD:x;}
inline int sub(int x, int y){return (x-=y)<0?x+MOD:x;}
inline int mul(int x, int y){return 1ll*x*y%MOD;}

int pr[MAXN], mu[MAXN], cnt = 0;
bool vis[MAXN];

inline void muda(int n)
{
	mu[1] = 1;
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])
		{
			pr[++cnt] = i;
			mu[i] = -1;
		}
		for(int j=1;j<=cnt&&i*pr[j]<=n;j++)
		{
			vis[i*pr[j]] = 1;
			if(i%pr[j] == 0) 
			{
				mu[i*pr[j]] = 0;
				break;
			}
			mu[i*pr[j]] = -mu[i];
		}
	}
	for(int i=1;i<=n;i++)
		mu[i] = add(mu[i], mu[i-1]);
}

tr1::unordered_map<int,int> summu;

inline int sumMu(int n)
{
	if(n <= 6000000) return mu[n];
	if(summu[n]) return summu[n];
	int res = 1;
	for(int l=2,r;l<=n;l=r+1)
	{
		r = n/(n/l);
		res = sub(res, mul(sub(r%MOD, l%MOD)+1, sumMu(n/l)));
	}
	return summu[n] = res;
}

inline int calc(int n)
{
	int res = 0;
	for(int l=1,r;l<=n;l=r+1)
	{
		r = n/(n/l);
		res = add(res, mul(mul(n/l, n/l), mul(n/l, sub(sumMu(r), sumMu(l-1)))));
	}
	return res;
}

int main()
{
	muda(6000000); 
	int n;
	scanf("%d",&n);
	printf("%d\n",calc(n));
	return 0;
}
```


---

## 作者：fanfansann (赞：2)

**Weblink**

[https://www.luogu.com.cn/problem/P6055](https://www.luogu.com.cn/problem/P6055)



**Problem**



给出 $N$，求：

$$
\sum_{i=1}^{N} \sum_{j=1}^{N} \sum_{p=1}^{\left\lfloor\frac{N}{\jmath}\right\rfloor} \sum_{q=1}^{\left\lfloor\frac{N}{j}\right\rfloor}[\operatorname{gcd}(i, j)=1][\operatorname{gcd}(p, q)=1]
$$

答案模 $998244353$。


**Solution**



这题真是乐死我了，真就图一乐呗

上来怎么看这个 $j$ 怎么不顺眼，这不先把 $j$ 直接丢回去 ？？？

然后这题就没了...

随便反演一下，杜教筛随便搞搞就完事了

$$
\begin{aligned}
&\ \ \ \ \ \sum_{i=1}^N\sum_{j=1}^N\sum_{p=1}^{\left\lfloor\frac N j\right\rfloor}\sum_{q=1}^{\left\lfloor\frac N j\right\rfloor}[\gcd(i, j)=1][\gcd(p, q)=1]&\\&
=\sum_{i=1}^N\sum_{j=1}^N\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i, j)=1][\gcd(p, q)=j]&\\&
=\sum_{i=1}^N\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i, p,q)=1]&\\&
=\sum_{i=1}^N\sum_{p=1}^{N}\sum_{q=1}^{N}\sum_{d\mid \gcd(i,p,q)}\mu(d)&\\&
=\sum_{d=1}^N\sum_{i=1}^N\sum_{p=1}^{N}\sum_{q=1}^{N}[d\mid i][d\mid p][d\mid q]\mu(d)&\\&
=\sum_{d=1}^N\sum_{i=1}^{\left\lfloor\frac N d\right\rfloor }\sum_{p=1}^{\left\lfloor\frac N d\right\rfloor }\sum_{q=1}^{\left\lfloor\frac N d\right\rfloor}\mu(d)&\\&
=\sum_{d=1}^N\mu(d)\left\lfloor\frac N d\right\rfloor^3
\end{aligned}
$$



时间复杂度 $O(n^{\frac 2 3})$。

20分钟水一道紫题 \^q\^ 



**Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int maxn = 2e6 + 7, mod = 998244353;

ll n, m, s, t;
ll ans;
int primes[maxn], cnt;
bool vis[maxn];
ll mu[maxn];
unordered_map <ll, ll> sum_mu;

void prework(int n)
{
	mu[1] = 1;
	for (int i = 2; i <= n; ++ i) {
		if(vis[i] == 0) {
			primes[ ++ cnt] = i;
			mu[i] = -1;
		}
		for (int j = 1; j <= cnt && i * primes[j] <= n; ++ j) {
			vis[i * primes[j]] = 1;
			if(i % primes[j] == 0) 
				break;
			mu[i * primes[j]] -= mu[i];
		}
	}
	for (int i = 1; i <= n; ++ i) {
		mu[i] += mu[i - 1];
	}
}

int g_sum(int x)
{
	return x;
}

inline int get_sum_mu(int x)
{
	if(x <= maxn - 10) return mu[x];
	if(sum_mu.find(x) != sum_mu.end()) return sum_mu[x];
	ll ans = 1;
	for (ll l = 2, r; l <= x; l = r + 1) {
		r = x / (x / l);
		ans -= (g_sum(r) - g_sum(l - 1)) * get_sum_mu(x / l);
	}
	return sum_mu[x] = ans / g_sum(1);
}

int main()
{
//	int ^q^; 
	prework(maxn - 7);
	t = 1;
	while(t -- ) {
		ans = 0;
		scanf("%lld", &n);
		for (ll l = 1, r = 0; l <= n; l = r + 1) {
			r = n / (n / l);
			ll _ = (n / l) * (n / l) % mod * (n / l) % mod; 
			ans = (ans + (get_sum_mu(r) - get_sum_mu(l - 1) + mod) % mod * _ % mod) % mod;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```


 

---

## 作者：chihik (赞：1)

这道题的反推还是挺有意思的。

$$\sum_{i=1}^n\sum_{j=1}^n\sum_{p=1}^{\lfloor \frac{n}{j} \rfloor}\sum_{q=1}^{\lfloor \frac{n}{j} \rfloor}[(i,j)=1][(p,q)=1]$$

$$\sum_{i=1}^n\sum_{j=1}^n\sum_{p=1}^{n}\sum_{q=1}^{n}[(i,j)=1][(p,q)=j]$$


$$\sum_{i=1}^n\sum_{p=1}^{n}\sum_{q=1}^{n}[(i,p,q)=1]$$

然后就可以正常化简了。

$$\sum_{i=1}^n\sum_{p=1}^{n}\sum_{q=1}^{n}[(i,p,q)=1]$$

$$\sum_{d=1}^n \mu(d) \lfloor \frac{n}{d} \rfloor ^3$$

整除分块+杜教筛即可。

```cpp
#include <map>
#include <cstdio>
using namespace std;

const int MAXN = 2e6 , Mod = 998244353;

int prn , prime[ MAXN + 5 ] , mu[ MAXN + 5 ] , f[ MAXN + 5 ]; 
bool vis[ MAXN + 5 ];
void sieve( ) {
	mu[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) prime[ ++ prn ] = i , mu[ i ] = -1;
		for( int j = 1 ; j <= prn && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) break;
			mu[ i * prime[ j ] ] = -mu[ i ];
		}
	}
	for( int i = 1 ; i <= MAXN ; i ++ ) f[ i ] = f[ i - 1 ] + mu[ i ];
}

map< int , int > Smu;
int Summu( int n ) {
    if( n <= MAXN ) return f[ n ];
    if( Smu[ n ] ) return Smu[ n ];

    int Ans = 1;
    for( int l = 2 , r ; l <= n ; l = r + 1 ) {
        r = n / ( n / l );
        Ans -= ( r - l + 1 ) * Summu( n / l );
    }
    return Smu[ n ] = Ans;
}

int Solve( int n ) {
    int Ans = 0;
    for( int l = 1 , r ; l <= n ; l = r + 1 ) {
        r = n / ( n / l );
        Ans = ( Ans + 1ll * ( ( Summu( r ) - Summu( l - 1 ) ) % Mod + Mod ) % Mod * ( n / l ) % Mod * ( n / l ) % Mod * ( n / l ) % Mod ) % Mod;
    }
    return Ans;
}

int n;
int main( ) {
	sieve( );
    scanf("%d",&n);
    printf("%d\n", Solve( n ) );
	return 0;
}
```


---

## 作者：hehelego (赞：1)

首先考虑$p,q$的那部分$\sum_p\sum_q[(p,q)=1]$

$$F(n)=\sum_{i=1}^n\sum_{j=1}^n[(i,j)=1]$$
$$\sum_{d=1}^n\mu(d)(\lfloor\frac{n}{d}\rfloor)^2$$
$$-1+2\sum_{i=1}^n \varphi(i)$$


第二个的话,考虑$(i,j)=(j,i)$,其中$(i,i)$只有$i=1$时有贡献,多算了一次$-1$去掉它,btw,这个东西曾经出现在SDOI的一个经典数论题里面.

-------

然后我们发现$i,j$是对等的,个人习惯把$F(\lfloor\frac{n}{j}\rfloor)$换成$i$.然后带着它做莫比乌斯反演(就是用$\sum_{d\mid n}\mu(d)=[n=1]$直接带入,然后换求和顺序qwq).

$$\sum_{i=1}^n\sum_{j=1}^n[(i,j)=1]F(\lfloor\frac{n}{i}\rfloor)$$
$$\sum_{d=1}^n\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}F(\lfloor\frac{n}{id}\rfloor)\lfloor\frac{n}{d}\rfloor$$
$$\sum_{d=1}^n\mu(d)\lfloor\frac{n}{d}\rfloor\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}F(\lfloor\frac{n}{id}\rfloor)$$

我们发现一个可以分块套分块的美好结构,考虑一下用那种方式来算$F$.  
用$\varphi$前缀和的话,显然用到的值都是$\lfloor\frac{n}{d}\rfloor$的形式,用卷积构造递推式,记忆化搜索可以$O(n^\frac34)$把它们都求出来(这个技巧也叫杜教筛).具体而言是$\varphi *1=id$这样做分开考虑复杂度贡献,是$O(n^\frac34)$的,记忆化的话有小技巧$sum(x)$放在$\begin{cases}A(x)&(x\lt \sqrt n)\\B(n/x)&(x\geq \sqrt n)\end{cases}$不会产生冲突,或者使用std::unordered_map这个hash表不开c++11的话它在header:tr1/unordered_map中,std::tr1 namespace之下.  

用更加通用的反演求$F$的话,需要再套一层分块.复杂度可以这么估计$\int_1^{\sqrt n}(x^{\frac34}+(\frac{n}{x})^\frac34)dx$显然是比前一种做法更慢的...如果怕常数问题的话,两种都写出来本机测速一下也可以.  


-----


$n\leq 2e9$的话$O(n^\frac34)$应该是离正解不远了,只差最后一步优化了qwq.  当然也可能是出题人良心给了传统套路90pts而std和这个做法没关系23333.  

重新审视分块套分块的式子
$$\sum_{d=1}^n\mu(d)\lfloor\frac{n}{d}\rfloor\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}F(\lfloor\frac{n}{id}\rfloor)$$

就是后面那个$\sum F(n/id)$,这东西应该是唯一能优化的了吧?展开它?不存在的.  


我们此时应该求助于OI常见技巧:打表找规律!.这里把取模删掉,裸跑$n\leq 100$的情况,打出$g(n)=\sum F(n/i)$.然后惊奇的发现,$g(n)=n^2$.  

$$\sum_{d=1}^n\mu(d)(\lfloor\frac{n}{d}\rfloor)^3$$  

然后发现它仍然$O(n^\frac34)$我们1pts都躲不了.

----

这样复杂度瓶颈在于求$\mu$的前缀和了,给杜教筛也加上打表~~找规律~~,预处理前$S$项(线性筛法)显然$S\gt \sqrt n$才会有用,杜教筛的复杂度是

$$
\int_1^{\sqrt n} (\sqrt x+\sqrt{\frac{n}{x}})dx
$$
这里后一部分是大于前一部分的,如果$S\lt \sqrt n$的话,后一部分是不变的,复杂度没法优化.  

$$
S+\int_1^{n/S} (\sqrt{\frac{n}{x}})dx
$$
把后面的积分出来,均值不等式一下,发现$S=n^\frac23$是最优的$O(n^\frac23)$,当然实际上由于线性筛和递归记忆化搜索的常数不一样大,我们需要本机实地测试一下$S$多大最优秀.  


-----

现在求$\sum \mu$在$n/1,n/2,n/3\dots n/n$处取值变成$O(n^\frac23)$了,分块部分每次是$O(1)$的,总复杂度是$O(n^\frac23)$就可以过了qwq.  






-----

upd一下,没放代码qwq...对于求$F$的两种实现都没有删掉,分别是Int F1(int n)和Int F2(int n);
```cpp
#include <bits/stdc++.h>
typedef long long Int;
typedef std::unordered_map<int,Int> Map;
const Int mod=998244353LL;
const int N=2000000+10;
inline Int fix(Int x){ return (x%mod+mod)%mod; }
int vis[N],prime[N],cnt,phi[N],mu[N];
void init(){
	vis[1]=1; mu[1]=phi[1]=1;
	for(int i=2;i<N;i++){
		if(!vis[i]){
			prime[cnt++]=i;
			phi[i]=i-1; mu[i]=-1;
		}
		for(int j=0;j<cnt&&i*prime[j]<N;j++){
			int v=i*prime[j]; vis[v]=1;
			if(i%prime[j]==0){
				phi[v]=phi[i]*prime[j];
				mu[v]=0;
				break;
			}
			phi[v]=phi[i]*(prime[j]-1);
			mu[v]=mu[i]*(-1);
		}
	}
	for(int i=2;i<N;i++){
		phi[i]=(phi[i-1]+phi[i])%mod;
		mu[i]=(mu[i-1]+mu[i]+mod)%mod;
	}
}

Map tmu;
Int smu(int n){
	if(n<N) return mu[n];
	if(tmu.count(n)) return tmu[n];
	Int s=1; int l=2,r,q;
	while(l<=n){
		q=n/l; r=n/q;
		s=fix(s-(r-l+1)*smu(q)%mod);
		l=r+1;
	}
	return tmu[n]=s;
}
Map tphi;
Int sphi(int n){
	if(n<N) return phi[n];
	if(tphi.count(n)) return tphi[n];
	Int s=(1LL*n*(n+1)/2)%mod; int l=2,r,q;
	while(l<=n){
		q=n/l; r=n/q;
		s=fix(s-(r-l+1)*sphi(q)%mod);
		l=r+1;
	}
	return tphi[n]=s;
}

Map tf1;
Int F1(int n){
	if(tf1.count(n)) return tf1[n];
	return tf1[n]=(2*sphi(n)-1+mod)%mod;
}
Map tf2;
Int F2(int n){
	if(tf2.count(n)) return tf2[n];
	Int s=0; int l=1,r,q;
	while(l<=n){
		q=n/l; r=n/q;
		s=(s+1LL*q*q%mod*fix(smu(r)-smu(l-1))%mod)%mod;
		l=r+1;
	}
	return tf2[n]=s;
}
Int sf(int n){
	return 1LL*n*n%mod;
	Int s=0; int l=1,r,q;
	while(l<=n){
		q=n/l; r=n/q;
		s=(s+1LL*(r-l+1)*F1(q)%mod)%mod;
		l=r+1;
	}
	return s;
}

int main(){
	init();
	int n;std::cin>>n;
	Int s=0; int l=1,r,q;
	while(l<=n){
		q=n/l; r=n/q;
		s=(s+fix(smu(r)-smu(l-1))*q%mod*sf(q)%mod)%mod;
		l=r+1;
	}
	std::cout<<s<<std::endl;
	return 0;
}
```


---

## 作者：derta (赞：0)

将后两个 $\sum$ 乘 $j$，得
$$\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i,j)=1][\gcd(p,q)=j]$$

发现 $j$ 相当于在枚举 $\gcd(p,q)$，那我们就可以把它搞掉
$$\sum_{i=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i,\gcd(p,q))=1]$$

（其实这两步相当于把莫反套路反过来了）

之后就很简单了，都是套路，简单写了

$$\sum_{i=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i,p,q)=1]$$
$$\sum_{i=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}\sum_{d|i,d|p,d|q}\mu(d)$$
$$\sum_{d=1}^{N}\mu(d)\lfloor\frac{N}{d}\rfloor^{3}$$

直接整除分块+杜教筛即可

$\rm{Code}:$

```cpp
#include <iostream>
#include <tr1/unordered_map>
typedef std::tr1::unordered_map<int, int>::iterator Iter;
const int MAXN = 1587401, lnMAXN = 10, MOD = 998244353;
//MAXN为线筛的范围，也就是n^{2/3}，考虑线筛与杜教筛的常数差异也可以稍稍加大 
int Prime[MAXN/lnMAXN], size; 
int mu[MAXN + 5];
bool not_prime[MAXN + 5];
std::tr1::unordered_map<int, int> ans_mu; // 杜教筛的mu 

void sieve(int n) {
	not_prime[1] = true;
	mu[1] = 1;
	// 边界 
	for(int i = 2; i <= n; ++i) {
		if(not_prime[i] == false) {
			Prime[size++] = i; // 加入质数表 
			mu[i] = MOD - 1; //-1在mod MOD意义下为MOD-1 
		}
		for(int j = 0; j < size && i*Prime[j] <= n; ++j) {
			not_prime[i*Prime[j]] = true;
			if(i%Prime[j] == 0)
				break;
			mu[i*Prime[j]] = MOD - mu[i];
		}
	}
	for(int i = 2; i <= n; ++i)
		mu[i] = (mu[i] + mu[i - 1])%MOD; //搞前缀和 
}

int get_mu(int n) {
	if(n <= MAXN) // 线性筛筛过 
		return mu[n];
	Iter it = ans_mu.find(n);
	if(it != ans_mu.end()) // 杜教筛筛过 
		return it->second;
	int res = 1;
	for(int i = 2, ni; i <= n; i = ni + 1) {
		ni = n/(n/i);
		res = (res - 1LL*(ni - i + 1)*get_mu(n/i)%MOD)%MOD;
		//注意何时乘1LL 
	}
	return ans_mu[n] = (res < 0 ? res + MOD : res); // 判断是否为负数 
}

inline int cube(int x)
{ return 1LL*x*x%MOD*x%MOD; } // 计算x^3 

int solve(int n) {
	int res = 0;
	for(int i = 1, ni; i <= n; i = ni + 1) {
		ni = n/(n/i);
		res = (1LL*res + 1LL*(get_mu(ni) - get_mu(i - 1))%MOD*cube(n/i%MOD)%MOD)%MOD;
		//注意何时乘1LL 
	}
	return res < 0 ? res + MOD : res; // 判断是否为负数 
}

int main() {
	sieve(MAXN);
	int n;
	std::cin >> n;
	std::cout << solve(n);
	return 0;
}
```

---


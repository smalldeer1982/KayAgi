# 最小路径

## 题目描述

一棵 $n$ 个点的树，每个点两个点权 $a_i$ 和 $b_i$，找一条长度为 $m$ 的简单路径，使 $\frac{\sum a_i}{\sum b_i}$ 最小。无解输出 $-1$。

## 说明/提示

subtask 1 $20$：$n\le 100$，$m\le n$，$1\le a_i,b_i\le 2000$。

subtask 2 $40$：$n\le 10^4$，$m\le n$，$1\le a_i,b_i\le 2000$。

subtask 3 $40$：$n\le 2\times 10^5$，$m\le n$，$1\le a_i,b_i\le 2000$。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，$1\le m\le n$，$1\le a_i,b_i\le 2000$。

## 样例 #1

### 输入

```
3 1
2 3 3
6 6 6
1 2
2 3```

### 输出

```
0.42```

## 样例 #2

### 输入

```
9 2
9 4 4 1 6 5 1 9 5
8 3 3 1 5 4 1 8 4
1 2
2 3
3 4
3 5
1 6
6 7
7 8
6 9```

### 输出

```
1.15```

# 题解

## 作者：yuzhechuan (赞：9)

很好的一道01分数规划套长链剖分优化树形dp题（不愧是zjk大佬出的题）

---

### 题解：

首先是01分数规划的套路，二分答案$k$，然后每个点的点权转为$val_i=a_i-k\times b_i$，当前二分答案合法的条件是存在一条长度为$m$的树上路径的点权和小于等于0

于是当前问题转化为：给你一棵树，问你长度为$m$的树上路径的最小点权和

考虑树形dp，设$f[x][i]$表示$x$向下长度为$i$的链中的最小点权和

考虑转移，$f[x][i]=val_i+\min\{f[y][i-1]\| y\in son_x\}$,$f[x][0]=val_i$

考虑答案，有两种：

* 一种是自上而下的链，直接$f[x][m]$

* 另一种是要折一次的链，可以在$x$的子节点里挑两个搞

---

考虑优化，发现转移方程里的$val_i$很难去掉

考虑转变dp状态，改设$f[x][i]$表示**根到$x$的$i$级儿子**的链的最小点权和

考虑转移，$f[x][i]=\min\{f[y][i-1]\| y\in son_x\}$,$f[x][0]=pre_x$

（其中$pre_x$表示根到$x$路径上的$val$的和）

考虑答案，类似原先的，只不过要注意减去祖先的冗余贡献

考虑优化，发现现在的转移方程就好看多了，是个经典的可以用长剖优化的方程

于是套用长链剖分，重链利用指针直接转移，轻链暴力转移

注意此时第二种情况的答案可以在暴力转移时同时处理

---

时间复杂度均摊一只log，空间复杂度线性

---

### 代码：

```cpp
#pragma GCC optimize(3,"Ofast","inline")
#pragma GCC target("avx,avx2")
#include <bits/stdc++.h>
using namespace std;
template<class t> inline t read(t &x){
    char c=getchar();bool f=0;x=0;
    while(!isdigit(c)) f|=c=='-',c=getchar();
    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
    if(f) x=-x;return x;
}
template<class t> inline void write(t x){
    if(x<0) putchar('-'),write(-x);
    else{if(x>9) write(x/10);putchar('0'+x%10);}
}

const double eps=1e-4;
const int N=2e5+5;
double memory[N],ans=-1,res,*f[N],*cur,val[N];
int n,s[N],dep[N],a[N],b[N],m;
vector<int> g[N];

void dfs1(int x,int fa){ //长剖
	for(int y:g[x]) if(y^fa){
		dfs1(y,x);
		if(dep[y]>dep[s[x]]) s[x]=y;
	}
	dep[x]=dep[s[x]]+1;
}

void dfs2(int x,int fa){
	val[x]+=val[fa]; //处理val前缀和
	if(s[x]) f[s[x]]=f[x]+1,dfs2(s[x],x); //重链直接复制
	f[x][0]=val[x];
	for(int y:g[x]) if(y!=fa&&y!=s[x]){
		f[y]=cur;
		cur+=dep[y];
		dfs2(y,x);
		for(int i=0;i<dep[y];i++) if(m-i-1>=0&&dep[x]>m-i-1) res=min(res,f[x][m-i-1]+f[y][i]-val[x]-val[fa]); //处理第二种答案
		for(int i=0;i<dep[y];i++) f[x][i+1]=min(f[x][i+1],f[y][i]); //暴力转移
	}
	if(dep[x]>m) res=min(res,f[x][m]-val[fa]); //第一种答案
}

bool check(double k){
	res=1e18;
	for(int i=1;i<=n;i++) val[i]=a[i]-k*b[i];
	for(int i=1;i<=n;i++) memory[i]=1e18; //还原内存数组
	f[1]=cur=memory;
	cur+=dep[1];
	dfs2(1,0);
	return res<=0;
}

signed main(){
	read(n);read(m);
	for(int i=1;i<=n;i++) read(a[i]);
	for(int i=1;i<=n;i++) read(b[i]);
	for(int i=1,x,y;i<n;i++){
		read(x);read(y);
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs1(1,0);
	double l=0,r=2000; //冷静分析，最大值只有2000
	while(l<=r-eps){
		double mid=(l+r)/2.0;
		if(check(mid)) ans=mid,r=mid-eps;
		else l=mid+eps;
	}
	if(ans<0) write(-1); //注意无解
	else printf("%.2lf",ans);
}
```

---

## 作者：mahaihang1 (赞：2)

### 前情提要
没有学过长链剖分优化 dp 的可以先做 [Dominant Indices](https://www.luogu.com.cn/problem/CF1009F) 和 [[湖南集训] 更为厉害](https://www.luogu.com.cn/problem/P3899)。
## 思路
考虑分数规划，将点权 $val_i$ 变为 $a_i-mid \times b_i$，考虑如何求所有长为 $m$ 的简单路径上的点权之和最小值。

对于一条树上的路径，发现一定可以变成以一个点开头的至多两条链拼在一起，则通过这个点的所有链可以通过两个不相同的子节点开头的链与自己拼起来。

因此不如设 $dp_{i,j}$ 表示以 $i$ 开头的深度为 $j$ 的所有链的最小值，转移方程为 

$$dp_{i,j}= \begin{cases} val_i +  \displaystyle\min_{u \in \text{son}(i)} dp_{u,j-1} & j \ge 1 \\ val_i & j=0 \end{cases}$$

发现这个转移第二维与深度有关，考虑长链剖分优化 dp，发现对于从重子节点直接继承过来的链的节点都要加上 $val_i$，考虑对于每个节点 $i$ 打一个懒标记 $s_i$ 表示对于所有的 $dp_{i,j}$ 都加上 $s_i$。

- 对于 $u$ 为重子节点，$s_i$ 直接加上 $s_u$，因为 $dp_{i,0}=val_i$，要将 $dp_{i,0}$ 减去 $s_u$。
- 对于 $u$ 为轻子节点，暴力合并即可，有 $dp_{i,j}=\displaystyle\min(dp_{u,j-1}+s_u-s_i,dp_{i,j})$，这样才能保证 $dp_{i,j}+s_i$ 为真实值。

最后 $s_i$ 要加上 $val_i$。

我们完成了如何求出 $dp_{i,j}$，考虑如何求解。

- 对于所有在 $i$ 字树内且过 $i$ 的长为 $m$ 的链来说，对于每一次合并的轻子节点 $u$，因为之前的 $dp_{i,j}$ 已经处理好了，可以在合并过程中求解。
- 当以 $i$ 开头的最深的链的长度 $\ge m$ 时，还要考虑以 $i$ 开头的长为 $m$ 的链对答案的贡献。

自此，我们就能做到 $O(n\log n)$ 解决该问题。
## 代码


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=500010,inf=0x3f3f3f3f3f3f3f3f;
const double eps=1e-4;
int n,m,idx,cnt,a[N],b[N],ver[2*N],nxt[2*N],hd[N],f[N],hs[N],d[N];
double val[N],dp[N],s[N],ans;
void add(int _u,int _v){
	ver[++idx]=_v;
	nxt[idx]=hd[_u];
	hd[_u]=idx;
}
void solve(int p,int fa){
	if(hs[p]){
		f[hs[p]]=f[p]+1;
		solve(hs[p],p);
	}
	s[p]=s[hs[p]];
	for(int i=hd[p];i;i=nxt[i]){
		if(ver[i]==fa||ver[i]==hs[p]) continue;
		f[ver[i]]=cnt,cnt+=d[ver[i]];
		solve(ver[i],p);
		for(int j=max(m-d[p],0ll);j<min(d[ver[i]],m);j++) ans=min(ans,dp[f[ver[i]]+j]+s[ver[i]]+s[p]+dp[f[p]+m-j-1]+val[p]);
		for(int j=0;j<d[ver[i]];j++) dp[f[p]+j+1]=min(dp[f[p]+j+1],dp[f[ver[i]]+j]+s[ver[i]]-s[p]);
	}
	s[p]+=val[p],dp[f[p]]=-s[hs[p]];
	if(d[p]>m) ans=min(ans,dp[f[p]+m]+s[p]);
}
bool check(double x){
	for(int i=1;i<=n;i++) val[i]=1.0*a[i]-b[i]*x,dp[i]=inf,s[i]=0;
	ans=inf,f[1]=1,cnt=d[1]+1;
	solve(1,0);
	return ans<=0;
} 
void dfs(int p,int fa){
	for(int i=hd[p];i;i=nxt[i]){
		if(ver[i]==fa) continue;
		dfs(ver[i],p);
		if(d[hs[p]]<d[ver[i]]) hs[p]=ver[i];
	}
	d[p]=d[hs[p]]+1;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v),add(v,u);
	} 
	dfs(1,0);
	double l=0,r=2000;
	while(l+eps<=r){
		double mid=(l+r)/2.0;
		if(check(mid)) r=mid;
		else l=mid;
	}
	if(check(r)) cout<<fixed<<setprecision(2)<<r;
	else cout<<"-1";
	return 0;
}
```

---

## 作者：hzjnsy (赞：1)

**[题目传送门](https://www.luogu.com.cn/problem/P6074)**

> - 给出一棵 $n$ 个点的树，点 $i$ 有点权 $a_i,b_i$，求一条边数为 $m$ 的路径 $P$，使得 $\frac{\sum_{u\in P}a_u}{\sum_{u\in P}b_u}$ 最小。
>
> - $n\le 2\times 10^5$。

看到这个形式考虑分数规划，二分检查分式的值能否 $\le mid$，不等式变形一下变成 $\sum_{u\in P}(a_u-b_u\cdot mid) \le 0$。记点权 $val_u=a_u-b_u\cdot mid$。只需要检查点权和最小的路径的点权和是否 $\le 0$ 即可。

求边数为 $m$ 且点权和最小的路径，套点分治模板即可。需要卡常，可以参考[代码](https://www.luogu.com.cn/paste/aubob6uf)。

时间复杂度为 $\mathcal{O}(n\log n\cdot \log |V|)$，空间复杂度为 $\mathcal{O}(n)$。

---

## 作者：DJRzjl (赞：1)

无脑写了个 01 分数规划 + 点分治的双 log 做法，结果卡了半天常...

首先二分答案 $mid$，答案可以更小仅当存在长 $m$ 的路径满足 $\frac{\sum a_i}{\sum b_i}< mid$，即 $\sum a_i - \sum mid\cdot b_i <0$，设 $w_i=a_i-mid\cdot b_i$，那么我们只需要判断是否存在长 $m$ 的路径，路径上所有点 $w$ 的和小于 $0$。

然后就变成了点分治模板题，不再赘述。

做法是没问题，但如果实现的不够精细会被卡 T（没卡常之前我的代码要跑 7s 左右）。

如果你想写这个做法，这里给出要注意的一些实现细节：

- 快读（不知道有没有用），开 **O2**。
- 点分治过程中剪枝：
	- 若发现当前更新到的长 m 的路径和的最小值小于 0，退出整个分治过程。
   - **若当前分治子连通块大小小于等于 $m$ 直接退出该层分治**。（这点最重要）。
   - 遍历当前分治子连通块时不遍历深度大于 $m$ 的点。
- 不需要每次二分都重新找重心，**用一次点分治预处理出访问点的顺序**即可（差不多就是隐式点分树）。

- 还有一些标记，清空等小细节写法上的差异。

这些不一定都需要加上，我的代码全加上后最大点跑进了 1s。


~~很屎的~~Code：

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
using namespace std;
typedef double db;
const int N=2e5+10;
const db inf=5e8;
const int MAXL=1<<22;
char i_str[MAXL],o_str[MAXL],*i_s,*i_t;
int o_t;
inline char gc(){
	if(i_s==i_t){
		i_s=i_str;
		i_t=i_s+fread(i_str,1,MAXL,stdin);
		return i_s==i_t?EOF:*i_s++;
	}else return *i_s++;
}
inline int read(){
	int x=0;
	char ch=gc();
	for(;ch<'0'||ch>'9';ch=gc());
	for(;ch>='0'&&ch<='9';ch=gc()) x=(x<<1)+(x<<3)+(ch^48);
	return x;
}//祖传快读

int n,m,a[N],b[N],seq[N],idn;
vector<int>e[N];
db w[N],ret;

int siz[N],rt,foc[N];
void dfs1(int u,int fa){
	siz[u]=1;
	for(auto v:e[u]) if(v!=fa&&!foc[v]) dfs1(v,u),siz[u]+=siz[v];
}
void dfs2(int u,int fa,int tot){
	int mx=tot-siz[u];
	for(auto v:e[u]) if(v!=fa&&!foc[v]) dfs2(v,u,tot),mx=max(mx,siz[v]);
	if(mx*2<=tot) rt=u;
}

db t[N];
vector<pair<int,db> >tmp;

void dfs(int u,int fa,int d,db s){
	if(ret<0||d>m) return;//剪枝
	s+=w[u];
	if(d<=m) ret=min(ret,s+t[m-d]+w[rt]);//这里的rt记得更新
	tmp.pb(d,s);
	for(auto v:e[u]) if(v!=fa&&!foc[v]) dfs(v,u,d+1,s);
}

void init(int u){
	dfs1(u,0);
	if(siz[u]<=m) return ;//比较重要的剪枝，能把访问到的点的数量减下一个量级。
	dfs2(u,0,siz[u]);
	foc[u=rt]=1;
	seq[++idn]=u;
	for(auto v:e[u]){
		if(foc[v]) continue;
		dfs(v,u,1,0);
		for(auto[d,s]:tmp) t[d]=min(t[d],s);
		tmp.clear();
	}
	for(int i=1;t[i]<inf;i++) t[i]=inf;
	for(auto v:e[u]) if(!foc[v]) init(v);
}

void solve(int u){
	if(ret<0) return ;//剪枝
	foc[rt=u]=1;
	for(auto v:e[u]){
		if(foc[v]) continue;
		dfs(v,u,1,0);
		for(auto[d,s]:tmp) t[d]=min(t[d],s);
		tmp.clear();//注意清空
		if(ret<0) return ;
	}
	for(int i=1;t[i]<inf;i++) t[i]=inf;
}

bool chk(db x,int op){
	for(int i=1;i<=n;i++) w[i]=a[i]-x*b[i],t[i]=inf,foc[i]=0;
	ret=inf;
	if(!op) init(1);//op=0,第一遍点分治，预处理出点的访问顺序seq，顺便判掉无解。
	else for(int i=1;i<=idn;i++) solve(seq[i]);//op=1,无需递归，根据seq按顺序做就行。
	return ret<=0;
}

int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) b[i]=read();
	for(int i=1,x,y;i<n;i++){
		x=read(),y=read();
		e[x].pb(y),e[y].pb(x);
	}
	if(!chk(2000,0)) return puts("-1"),0;
	db l=0,r=2000,mid; int cnt=25;
	while(cnt--){//实数二分答案
		mid=(l+r)/2;
		if(chk(mid,1)) r=mid;
		else l=mid;
	}
	printf("%.2lf\n",l);
	return 0;
}
```


---

## 作者：caidzh (赞：1)

看到这个题：诶这不是裸分数规划题吗？唉呀妈呀这个 check 我怎么只会平方做法啊

想了一下怎么优雅地 check，于是就有了一个比 $\text{\color{black}{Z}\color{red}{houJK}}$ 大爷不知道垃圾到哪里去的点分治做法

然而我的代码相当依赖数据的随机性，因为我的卡常方式都是针对数据的一些特殊性的qwq

首先分数规划的一般解法就是二分答案，考虑二分答案 $x$ ，如果答案 $x$ 可行，则满足：

$$\sum a_i-x\sum b_i \le0$$

于是我们令一个点的点权为 $a-xb$ ，则我们需要寻找一条长度为  $m$ 的权值和小于等于 $0$ 的路径

树上路径？立马想到点分治

点分治时记录分治中心到一个点长度为 $len$ 的路径权值和的最小值然后再一个个匹配就可以了

但是点分治并不能非常舒服地跑过这个题，我们需要一定的卡常数，这里列举几个比较通用的在这个题的卡常方式：

$1.$ 因为点分治时我们要不停地寻找分治中心，我们可以在第一次分治时找一次，然后之后的点分治利用第一次记录下来的分治顺序数组直接做

$2.$ 找到一组可行的路径时就立马退出

$3.$ 依赖数据随机性，缩小二分上界

$4.$ 如果一个点到分治中心的距离就大于了 $m$ ，立刻退出

加上这些卡常就可以通过这个题了qwq，于是代码就长得非常丑陋

```cpp
#include<bits/stdc++.h>
#define INF 2147483647
#define LLINF 9223372036854775807
#define LL long long
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=200010;
const float eps=1e-3;
int n,m,f[maxn],ans,head[maxn],cnt;
float a[maxn],b[maxn],val[maxn],ANS;
struct Edge{
	int nxt,to;
}edge[maxn<<1];
void add_edge(int x,int y){
	edge[++cnt].nxt=head[x];edge[cnt].to=y;head[x]=cnt;	
}
float Min(float x,float y){
	return x<y?x:y;
}
void dfs(int x,int fa){
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa)continue;
		double val=(a[x]+a[v])/(b[x]+b[v]);
		if(val<ANS)ANS=val;dfs(v,x);
	}
}
void chk(int x,int fa){
	f[x]=1;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa)continue;chk(v,x);
		ans=max(ans,f[x]+f[v]);f[x]=max(f[x],f[v]+1);
	}
}
int rt,size[maxn],used[maxn],vis[maxn],flg,line[maxn],top,dfn[maxn],tot,com;float s[maxn];
void getrt(int x,int fa,int sum){
	f[x]=0;size[x]=1;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa||used[v])continue;
		getrt(v,x,sum);size[x]+=size[v];f[x]=max(f[x],size[v]);
	}f[x]=max(f[x],sum-size[x]);if(f[x]<f[rt])rt=x;
}
void getsize(int x,int fa){
	size[x]=1;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa||used[v])continue;
		getsize(v,x);size[x]+=size[v];
	}
}float test;
void getans(int x,int fa,int dep,float sum){
	if(dep>m)return; 
	if(m-dep>=1&&vis[m-dep])
		if(s[m-dep]+sum<=0)flg=1;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa||used[v])continue;
		getans(v,x,dep+1,sum+val[v]);
	}
}
void add(int x,int fa,int dep,float sum){
	if(dep>m)return;
	if(!vis[dep])vis[dep]=1,line[++top]=dep,s[dep]=sum;
	else s[dep]=Min(s[dep],sum);
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa||used[v])continue;
		add(v,x,dep+1,sum+val[v]);
	}
}
void solve(int x){
	used[x]=1;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(used[v])continue;
		getans(v,x,2,val[v]+val[x]);add(v,x,1,val[v]);
	}for(int i=1;i<=top;i++)vis[line[i]]=0;top=0;
	if(!com){
		for(int i=head[x];i;i=edge[i].nxt){
			int v=edge[i].to;if(used[v])continue;
			rt=0;getsize(v,x);getrt(v,x,size[v]);dfn[++tot]=rt;solve(rt);
		}
	}
}
bool check(float x){
	memset(used,0,sizeof(used));flg=0;
	for(int i=1;i<=n;i++)val[i]=a[i]-b[i]*x;
	if(!dfn[tot]){f[0]=INF;getrt(1,0,n);dfn[++tot]=rt;solve(rt);}
	else{for(int i=1;i<=tot;i++){if(flg)break;solve(dfn[i]);}}com=1;return flg;
}
float tmpa[maxn],tmpb[maxn];
void work(){
	memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++)tmpa[i]=a[i],tmpb[i]=b[i];
	sort(tmpa+1,tmpa+n+1);sort(tmpb+1,tmpb+n+1);
	double suma=0,sumb=0;
	for(int i=n;i>=n-m;i--)suma+=tmpa[i];
	for(int i=1;i<=m;i++)sumb+=tmpb[i];
	float l=0,r=suma/sumb;s[0]=-INF;
	while(r-l>=eps){
		float mid=(l+r)/2.0;test=mid;
		if(check(mid))r=mid;else l=mid;
	}printf("%.2lf",l);
}
int main()
{
	n=read();m=read();m++;
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read();
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		add_edge(x,y);add_edge(y,x);
	}if(m==2){ANS=INF;dfs(1,0);printf("%.2lf",ANS);return 0;}
	chk(1,0);if(ans<m)printf("-1");else work();return 0;
}
```


---

## 作者：_zuoqingyuan (赞：0)

很明显是分数规划。

二分 $mid$，然后判断是否存在一条路径满足 $\frac{\sum a_i}{\sum b_i}\le mid$，整理一下可以转化为是否存在一条路径，满足 $\sum (a_i-mid\times b_i)\le 0$。

我们给每个点附上权值 $v_i=(a_i-mid\times b_i)$，问题就是求出一条路径，在满足路径上的边数为 $m$ 的同时最小化路径上点权和，然后直接判断这个和是否小于等于 $0$ 即可。

这里使用点分治即可，我们在计算时维护一个额外的辅助数组，计算完后再重置即可，总时间复杂度为 $O(n\log n\log V)$。

这样是无法通过的，我们可以加上一个小剪枝：如果当前分治的子树大小小于 $m$，则直接返回。加上快读后就可以通过本题了。


```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#define mp make_pair
using namespace std;
const int N=2e5+10;
const double inf=1e15;
const int MAXSIZE=(1<<20);
char buf[1<<20],*p1,*p2;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXSIZE,stdin),p1==p2)?EOF:*p1++)
inline void read(int &a){
	int x=0,f=1;char ch=gc();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
	while(isdigit(ch))x=(x<<3)+(x<<1)+ch-48,ch=gc();
	return a=x*f,void();
}
int n,m,a[N],b[N],siz[N],mx[N],rt,vis[N],tot;
int idx,ver[N],to[N<<1],nxt[N<<1];
double L,R,M,val[N],ans,dis[N];
struct node{
    int len,from;
    double val;
    void init(int a,int b,double c){len=a,from=b,val=c;}
}q[N];
void add(int x,int y){
    to[++idx]=y,nxt[idx]=ver[x],ver[x]=idx;
}
void dfs_root(int x,int fa,int sum){
    siz[x]=1,mx[x]=0;
    for(int i=ver[x];i;i=nxt[i]){
        int y=to[i];if(y==fa||vis[y])continue;
        dfs_root(y,x,sum),siz[x]+=siz[y];
        mx[x]=max(mx[x],siz[y]);
    }
    mx[x]=max(mx[x],sum-siz[x]);
    if(mx[rt]>mx[x])rt=x;return;
}
void dfs_dis(int x,int fa,int sum,double res,int tp){
    q[++tot].init(sum,tp,res);
    for(int i=ver[x];i;i=nxt[i]){
        int y=to[i];if(y==fa||vis[y])continue;
        dfs_dis(y,x,sum+1,res+val[y],tp);
    }
    return;
}
void calc(int u){
    q[tot=1].init(0,-1,0);
    for(int i=ver[u];i;i=nxt[i]){
        int v=to[i];if(vis[v])continue;
        dfs_dis(v,u,1,val[v],v);
    }
    for(int i=1,j=1;i<=tot;i++){
        while(q[j].from!=q[i].from)dis[q[j].len]=min(dis[q[j].len],q[j].val+val[u]),j++;
        if(q[i].len<=m)ans=min(ans,q[i].val+dis[m-q[i].len]);
    }
    for(int i=1;i<=tot;i++)dis[q[i].len]=inf;
    return;
}
void solve(int u){
    vis[u]=1,calc(u);
    for(int i=ver[u];i;i=nxt[i]){
        int v=to[i];if(vis[v])continue;
        if(siz[v]<m)continue;
        rt=0,dfs_root(v,u,siz[v]);solve(rt);
    }
    return;
}
bool check(double mid){
    memset(vis,0,sizeof(vis));
    for(int i=0;i<=n;i++)dis[i]=inf;
    for(int i=1;i<=n;i++)val[i]=(double)(a[i]-mid*b[i]);
    ans=inf,rt=0,dfs_root(1,1,n),solve(rt);
    if(ans<=0)return 1;
    else return 0;
}
int main(){
    read(n),read(m);
    for(int i=1;i<=n;i++)read(a[i]),R=max(R,a[i]*1.0);
    for(int i=1;i<=n;i++)read(b[i]);
    for(int i=1,u,v;i<n;i++){
        read(u),read(v);
        add(u,v),add(v,u);
    }
    mx[0]=0x3f3f3f3f;
    memset(dis,0x3f,sizeof(dis));
    for(int T=1;T<=23;T++){
        M=(L+R)/2;
        if(check(M))R=M;
        else L=M;
    }
    if(!check(R))printf("-1\n");
    else printf("%.2lf",R);
    return 0;
}
```

复建淀粉质。

如有错误，请指出。

---

## 作者：Scinerely (赞：0)

### 题目描述

一棵 $n$ 个点的树，每个点两个点权 $a_i$ 和 $b_i$，找一条长度为 $m$ 的简单路径，使 $\frac{\sum a_i}{\sum b_i}$ 最小。无解输出 $-1$。

### 思路点拨

考虑对于 $\frac{\sum a_i}{\sum b_i}$ 这种形式的式子去二分一个答案，那么问题转化为了check答案是否合法，假设目前check的答案是 $mid$ ，那么需要满足

$$\frac{\sum a_i}{\sum b_i} \leqslant m$$

$$\sum a_i-mid\times b_i \leqslant 0$$

我们令 $c_i=a_i-mid\times b_i$ 作为新的点权，判断是否存在一条长度为 $m$ 的路径权值小于等于 $0$ ，我们不妨直接求出权值最小的路径。考虑一个动态规划：

令 $f_{i,j}$ 表示目前在节点 $i$ ，以 $i$ 结尾长度为 $j$ 的链（竖直的那种链，链上节点两两之间都是祖先关系）的最小权值是多少，转移是简单的：

$$f_{i,0}=c_i$$

$$f_{i,j}=\min\{f_{son,j-1}+c_i\}$$

答案的话在 $\text{LCA}$ 处合并一下即可。时间复杂度为 $O(n^2 \log V)$，不可以通过。

注意到状态和深度相关，我们不妨使用长链剖分直接优化到 $O(n \log V)$。

---


# [CEOI 2019] 立方填词

## 题目描述

立方填词是一种特殊的填词游戏。填词之前，你需要选择立方体的边长 $a$ ，然后你就可以建立一个有 $a^3$ 个单位立方体的立方体了。这个大立方体有 $12$ 条边。然后，你去掉所有没有接触大立方体边的单位立方体。下图展示了当 $a=6$ 时建立的最终立方体。

![](https://cdn.luogu.com.cn/upload/image_hosting/zzs7dshw.png)

最后，你需要给剩下的每个单位立方体填上一个字母。对于这个立方体，填词之后，每条边上的单词都应该是有意义的。每条边都可以双向阅读，只要从一个方向读起来有意义即可。

下图展示了当 $a=6$ 时的一个立方体。一些单位立方体已经填上了字母。你已经可以沿这个大立方体的三条边读到 **SUBMIT**，**ACCEPT** 和 **TURING** 三个单词了。

![](https://cdn.luogu.com.cn/upload/image_hosting/jzpyzoeu.png)

给定一系列有意义的单词，每个单词可以在合法的立方体的任意一条边上出现。求可以构造多少种不同的立方体对 $998244353$ 取模。

即使一个立方体可以通过旋转和镜像操作变成另一个立方体，也认为这两个立方体**是不同的**。

## 说明/提示

#### 样例解释#1

第一个样例中，唯一一种可能是立方体的所有边上的单词均为 **radar**。

#### 样例解释#2

第二个样例中，有两种立方体，其中一个旋转后可以得到另一个立方体。立方体所有边上的单词都是 **robot**，两个立方体的不同之处在于左下角的字母是 **r** 还是 **t**。

#### 样例解释#3

第三个样例与第二个类似，注意阅读方向不会影响答案。

#### 样例解释#4

第四个样例中，如果把 **bob** 填在立方体的每条边上，有一种立方体。还有 $2^
{12} = 4096$ 种立方体，每条边都填 **baobab**（对于 $12$ 条边中的一条，我们有两种可能的阅读顺序）。

#### 数据范围

对于全部数据， $1 \le n \le 10^5$  。      

详细子任务限制及分值如下表：

| 子任务编号 | 限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | 单词中只包含小写的 `a` 到 `f` | $21$ |
| 2 | 单词中只包含小写的 `a` 到 `p` | $29$ |
| 3 | 单词中包含小写的 `a` 到 `p` 和大写的 `A` 到 `P` | $34$ |
| 4 | 单词中包含小写的 `a` 到 `z`，大写的 `A` 到 `Z` 和数字 `0` 到 `9`  | $16$ |

## 样例 #1

### 输入

```
1
radar```

### 输出

```
1```

## 样例 #2

### 输入

```
1
robot```

### 输出

```
2```

## 样例 #3

### 输入

```
2
FLOW
WOLF```

### 输出

```
2```

## 样例 #4

### 输入

```
2
baobab
bob```

### 输出

```
4097```

## 样例 #5

### 输入

```
3
TURING
SUBMIT
ACCEPT```

### 输出

```
162```

## 样例 #6

### 输入

```
3
MAN1LA
MAN6OS
AN4NAS```

### 输出

```
114```

# 题解

## 作者：Iang_ (赞：7)

神仙题

注意到一个正方体的种类只跟其八个角上的字符相关，所以考虑枚举每个角上填的字符，把八个角分成两层，每层4个，记 $G[len][j][k]$ 为长度为 $len$ 第一个字符为$j$，最后一个字符为 $k$ 的单词数。因为一个角相邻有三个角，记 $f[x][y][z]$ 为这个角任意填k周围三个角上填的字符分别是 $x,y,z$ 的方案数，$f[x][y][z]=\sum_{k\in [0,127]} G[len][k][x]*G[len][k][y]*G[len][k][z]$。

答案即为：
$\sum f[i][x][y]*f[i][x][z]*f[i][y][z]*f[x][y][z]$（一层有四个点，f数组限定了另一层的填法）。

![](https://cdn.luogu.com.cn/upload/image_hosting/05v3pruq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

ps：将每个单词翻转加入字符串去重可解决。

```cpp
#include<bits/stdc++.h>
#define mod 998244353
using namespace std;
int n,m,G[11][128][128],pos[128],f[128][128][128];
string s[200010];
char g[128];
bool vis[128];
long long ans;
int main()
{
	freopen("cubeword.in","r",stdin);
	freopen("cubeword.out","w",stdout);
	scanf("%d",&n);
	int x,y,z,i,j;
	for(i=1;i<=n;i++) {
		cin>>s[i];s[i+n]=s[i];
		reverse(s[i+n].begin(),s[i+n].end());
		for(j=0;j<s[i].size();j++) vis[s[i][j]]=1;
	}
	n*=2;
	sort(s+1,s+n+1);
	n=unique(s+1,s+n+1)-s-1;
	for(int i=0;i<128;i++) if(vis[i]) g[++m]=i,pos[i]=m;
	for(int i=1;i<=n;i++) G[s[i].size()][pos[s[i][0]]][pos[s[i][s[i].size()-1]]]++;
	for(int len=3;len<=10;len++) {
//		memset(f,0,sizeof(f));
			for(x=1;x<=m;x++) 
				for(y=1;y<=m;y++) 
					for(z=1;z<=m;z++) {
						f[x][y][z]=0;
						for(i=1;i<=m;i++) 
							f[x][y][z]=(f[x][y][z]+1ll*G[len][i][x]*G[len][i][y]%mod*G[len][i][z]%mod)%mod;
					}
		for(i=1;i<=m;i++) 
			for(x=1;x<=m;x++) 
				for(y=1;y<=m;y++) 
					for(z=1;z<=m;z++) 
						ans=(ans+1ll*f[i][x][y]*f[i][x][z]%mod*f[i][y][z]%mod*f[x][y][z]%mod)%mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Badnuker (赞：3)

[传送门](https://www.luogu.com.cn/problem/P6090)

神仙题

## 先考虑 $O(|\Sigma| ^8)$ 做法：

$\Sigma$：字符总数，本题为 大写字母 $26$ 个+小写字母 $26$ 个+数字 $10$ 个。

预处理两个字母一首一尾可以组成多少种**长度相同**的字符串，枚举正方体 $8$ 个顶点，计算每两个点之间贡献的积。

~~~cpp
for (int a1 = 1; a1 <= 62; a1++)
    for (int a2 = 1; a2 <= 62; a2++) 
        ...
            for (int a8 = 1; a8 <= 62; a8++) 
                ans += v[a1][a2] * v[a1][a3] * ... * v[a7][a8];
~~~

## 再考虑 $O(|\Sigma| ^7)$ 做法：

![](https://cdn.luogu.com.cn/upload/image_hosting/jzpyzoeu.png)

图中点 $G$，$A$，$T$，$S$ 之间三条边的贡献可以提前用 $O(\sum ^4)$ 的复杂度预处理出来，

~~~cpp
for (int l = 1; l <= 62; l++) 
	for (int i = 1; i <= 62; i++) 
		for (int j = 1; j <= 62; j++) 
			for (int k = 1; k <= 62; k++) 
				f[i][j][k] += v[l][i] * v[l][j] * v[l][k];
~~~

就只用枚举 $7$ 个点了。

## 再推广一下，

我们可以把正方体分成 $4$ 部分，每一部分都能用上面的预处理直接得出答案，就只用枚举体对角线的 $4$ 个点了，复杂度 $O(|\Sigma| ^4)$。

**注意：不同长度要分开处理**

## ~~卡常~~优化小技巧

不影响答案时，多层循环时最后一层循环最好和循环内多维数组的最后一个下标对应，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zs6vo456.png)

这样读取数组时是从 CPU 缓存直接读取的，速度更快。

~~经过折磨的测试~~，不这么写会喜提 TLE。

## 代码

~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5, mod = 998244353;

int n, ans;
int cnt[11];
int v[11][63][63];
int f[11][63][63][63];

int tran(char c) {
	if (c >= 'a' && c <= 'z') return c - 96;
	else if (c >= 'A' && c <= 'Z') return c - 38;
	else if (c >= '0' && c <= '9') return c + 5;
	else return 0;
}

string s[maxn];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> s[i];
		s[i + n] = s[i];
		reverse(s[i + n].begin(), s[i + n].end());
	}
	n *= 2;
	sort(s + 1, s + 1 + n);
	n = unique(s + 1, s + n + 1) - s - 1;//去重
	for (int i = 1; i <= n; i++) {
		cnt[s[i].size()]++;
		v[s[i].size()][tran(s[i][0])][tran(s[i][s[i].size() - 1])]++;
	}
	for (int len = 3; len <= 10; len++) {
		if (!cnt[len]) continue;
		for (int l = 1; l <= 62; l++) {
			for (int i = 1; i <= 62; i++) {
				if (!v[len][l][i]) continue;
				for (int j = 1; j <= 62; j++) {
					if (!v[len][l][j]) continue;
					for (int k = 1; k <= 62; k++) {
						if (!v[len][l][k]) continue;
						(f[len][i][j][k] += 1ll * v[len][l][i] * v[len][l][j] % mod * v[len][l][k] % mod) %= mod;
					}
				}
			}
		}
		for (int l = 1; l <= 62; l++) {
			for (int i = 1; i <= 62; i++) {
				for (int j = 1; j <= 62; j++) {
					for (int k = 1; k <= 62; k++) {
						(ans += 1ll * f[len][i][j][k] * f[len][i][j][l] % mod * f[len][i][k][l] % mod * f[len][j][k][l] % mod) %= mod;
					}
				}
			}
		}
	}
	cout << ans;
	return 0;
}

~~~

---

## 作者：irris (赞：2)

> 枚举，暴力 / 优化

## Solution

这是一道 **bot 题**，看你一开始是不是能找到正确的思路罢了。

显然单词除了去重以外，我们只关心它的长度 $l$（对于相同 $l$ 统一处理即可）、开头结尾字符 $\sigma_0, \sigma_1$。

有一个大力 $\mathcal O(l\cdot \lvert\Sigma\rvert^5)$ 做法，就是从一些点开始扩展，每次记录当前的一个连通块的边缘的字符，转移就枚举新的字符预处理贡献即可。

这个东西不光要转移很多次，而且 $5$ 次方也到了这种做法的极限了。因此考虑优化。

所以我们考察，三维立方体事实上是一张 **二分图**，每部各有 $4$ 个端点。

因此枚举其中一部点的四个字符，另一部的每个点只和其中三种有关，贡献可以预处理。时间复杂度 $\mathcal O(l\cdot \lvert\Sigma\rvert^4)$。

这是一道 bot 题。想出来的人都是 bot！

## Code

```cpp
inline int id(char ch) {
	return 'a' <= ch && ch <= 'z' ? ch - 'a' : 'A' <= ch && ch <= 'Z' ? ch - 'A' + 26 : ch - '0' + 52;
}
const int L = 10;
std::set<std::string> v[L + 1];

const int alpha = 62;
int con[alpha][alpha][alpha], cnt[alpha][alpha];

constexpr int MOD = 998244353;
inline void add(int &x, int y) { (x += y) >= MOD && (x -= MOD); }
int main() {
	int N = read<int>(), ans = 0;
	for (int i = 1; i <= N; ++i) {
		std::string S, T; std::cin >> S, T = S;
		std::reverse(T.begin(), T.end());
		v[S.size()].insert(S), v[T.size()].insert(T);
	}
	for (int i = 3; i <= L; ++i) {
		for (int i = 0; i < alpha; ++i) for (int j = 0; j < alpha; ++j) cnt[i][j] = 0;
		for (std::string S : v[i]) ++cnt[id(S.front())][id(S.back())];
		for (int i = 0; i < alpha; ++i) for (int j = 0; j < alpha; ++j) for (int k = 0; k < alpha; ++k) {
				con[i][j][k] = 0;
				for (int w = 0; w < alpha; ++w) add(con[i][j][k], 1ll * cnt[w][i] * cnt[w][j] % MOD * cnt[w][k] % MOD);
		}
		for (int a = 0; a < alpha; ++a) for (int b = 0; b < alpha; ++b) for (int p = 0; p < alpha; ++p) if (con[a][b][p]) {
			for (int q = 0; q < alpha; ++q) add(ans, 1ll * con[a][b][p] * con[a][b][q] % MOD * con[a][p][q] % MOD * con[b][p][q] % MOD);
		}
	}
	return print<int>(ans), 0;
}
```

---

## 作者：AC_love (赞：0)

首先枚举正方形的边长，然后考虑对于某个边长该怎么做。

首先注意到只有角上的字母会重复使用，因此我们可以直接枚举八个角上的字母，然后两两计算贡献即可。

令字符集大小为 $|\sum|$，复杂度 $O(l|\sum|^8)$。

考虑怎么优化这个玩意。

注意到对于一个顶点，它会且仅会与三个顶点共用一条边。如果我们确定了另外三个与它共用一条边的顶点填什么并计算出了贡献，那么这个顶点填什么都无所谓了。

这样就可以减掉一个顶点的枚举，降低一维的复杂度。

那么最多可以减掉几个顶点的枚举呢？

注意到，只需要枚举正方体底部正方形对角线上的两个点和顶部正方形另一条对角线上两个点即可，剩下四个点都与刚才枚举过的某三个点共用一条边。

于是复杂度被降低到了 $O(l|\sum|^4)$。

略微卡常。

---

## 作者：Xqbk (赞：0)

神仙题。

（后面一部分没有独立思考出来的参照了一些CF上给的解答）

首先很容易注意到每种长度要分开统计。

其次注意到正序和倒序、回文和非回文词会对统计产生影响。由于每个词都可以正反两种方法读，我们直接将原字符串和倒序字符串一同加入我们的字符串集合，顺便去重。这时对于每个剩下的串对应了“从首字符到尾字符连边的一种方式”，显然中间部分对答案没有影响了。就用 $a[s][t]$ 记录端点为 $s$ 和 $t$ 的方案数吧，于是每个字符串 $[s\dots t]$ 都会对 $a[s][t]$ 产生 $1$ 的贡献。同时有 $a[s][t]=a[t][s]$。

这时最容易想到的是枚举 $8$ 个顶点的 ${|\Sigma|}^8$ 种填字方式，每种方式对答案的贡献为 $\prod a[u][v]$，其中 $u,v$ 是某条边的两端点。复杂度（除了预处理的 $O(n)$ 以外）是 $O({|\Sigma|}^8)$。

考虑优化。发现 $8$ 个顶点可以染色成各自独立的两组，即 $3-$正则二分图的形式，每组之内独立考虑。设 $d[a][b][c]$ 为以任意相同字母开头，分别以 $a,b,c$ 结尾的字符串三元组的个数。一组顶点为 $a,b,c,d$ 的话，答案即为 $d[a][b][c]\cdot d[a][b][d]\cdot d[a][c][d]\cdot d[b][c][d]$。这部分复杂度 $O({|\Sigma|}^4)$。至于 $d$ 的计算，可以看出 $d[j][k][l]=\sum\limits_{i\in\Sigma}a[i][j]\cdot a[i][k]\cdot a[i][l]$。同样是 $O({|\Sigma|}^4)$。

还能优化。注意到很多方案之间是互相对称的，于是想到群论方法。发现对于正方体的 $48$ 种摆放方式，其中只有一半会改变两个顶点组的位置。至于怎么发现的就不（会）解释了。（或者也可以当正四面体来想。）如果一组中的 $a,b,c,d$ 各不相同，只算 $a<b<c<d$ 的答案再乘上置换数 $24$ 就好。要是有相同的就用 $(a,b,c,d)$ 的排列数去乘。总之就是数一个顶点组（正四面体）的放置方式，详情参考群论方面资料。另外处理 $d$ 的时候显然 $d[a][b][c]=d[a][c][b]=\dots=d[c][b][a]$，于是可以只算 $a\le b\le c$ 的。最后优化下来加上预处理能达到 $O(n+{|\Sigma|}^4/6)$。


---


# 【模板】后缀平衡树

## 题目背景

"后缀平衡树"这个名字正确性存疑，由于 clj 给的"重量平衡树"定义有歧义。

字符串我也不会，所以也没去查证。

## 题目描述

给你一个字符串 `init`，要求你支持三个操作：

1. 在当前字符串的后面插入若干个字符。

2. 在当前字符串的后面删除若干个字符。

3. 询问字符串 $s$ 在当前字符串中出现了几次（作为连续子串）？

你必须在线支持这些操作。



## 说明/提示

数据字符串变化长度以及初始长度和 $ \le 8 \times 10^5$，询问次数 $\le 10^5$，询问总长度 $\le 3 \times 10^6$。

字符集为大写字母，注意 `ADD` 和 `QUERY` 操作的字符串都需要解压。

## 样例 #1

### 输入

```
3
A
QUERY B
ADD BBABBBBAAB
DEL 1```

### 输出

```
0```

# 题解

## 作者：KiDDOwithTopTree (赞：63)

## 目录

+ 前置芝士

+ 序

+ 离线构造

+ 在线构造

+ 代码实现

+ 与其他后缀数据结构的比较

+ 例题

+ 参考资料

------------


## 前置芝士

重量平衡树。

此重量平衡树的定义为：

> 在插入或删除操作之后，为了保持树的平衡而重构的子树大小为均摊或期望 $O(\log n)$。

~~[要不要来看看重量平衡树的经典题目？](https://www.luogu.com.cn/problem/P6272)~~

只要是重量平衡树就可以了。主要有替罪羊树、$\texttt {Treap}$、$\texttt {Leafy Tree}$ 等。

本文将以 $\texttt {Treap}$ 为例，介绍后缀平衡树。

![](https://cdn.luogu.com.cn/upload/image_hosting/nkqr1z9k.png)

(图源：<https://www.luogu.com.cn/blog/85514/fhq-treap-xue-xi-bi-ji>)

------------

## 0. 序

这一段并没有什么用，直接学算法的可以跳过。

众所周知，后缀数据结构博大精深。包括有：后缀树、后缀数组、后缀自动姬与后缀平衡树。同时背诵 $4$ 种数据结构的模板也忒累了。于是我就开始想偷工减料。

首先，反串的后缀自动姬的 $\texttt {parent tree}$ 就是后缀树。这么一来，一个算法就可以同时构造两种数据结构。完美！

然后就剩下后缀数组了。但是这东西不讲武德。看着很简单，但是很遗憾，我看了半天也没懂基数排序，其他两种 $O(n)$ 办法也看不懂…于是我只能想其他办法…

欸，不是还有后缀平衡树吗？可不可以用后缀平衡树来解决后缀数组呢？

那就试试看咯。

------------

## 1. 概念

后缀平衡树。由字面意思可得，它是一种维护后缀的数据结构。它可以维护一个字符串的所有后缀。~~那如果用来维护前缀是不是就是前缀平衡树了？~~

很显然，平衡树是可以用来排序的。那么后缀平衡树就是用来把这些后缀进行排序的。

怎么排序呢？

那当然是字典序啦。

所以这就是后缀平衡树的定义：

> 考虑一个长度为 $n$ 的字符串 $s$，定义 $s^i$ 为其由 $s_i,s_{i+1},...,s_n$ 组成的后缀。

> 后缀之间的大小由字典序定义，后缀平衡树就是一个平衡树并维护这些后缀的顺序。

------------

## 2. 离线构造

那么我们试着来建立一棵后缀平衡树：

我们先写出字符串 $\texttt {abababc}$ 的所有后缀：$\texttt{abababc bababc ababc babc abc bc c}$。

把这一些后缀按照字典序进行从小到大的排序：$\texttt {abababc ababc abc bababc babc bc c}$。

把它们像替罪羊树一样二分拎起来，不就是一棵后缀平衡树了吗？

![](https://cdn.luogu.com.cn/upload/image_hosting/3bj7s0h4.png)（上图是字符串 $\texttt {abababc}$ 的所有后缀的排序结果与所建立的后缀平衡树）

很简单对不。

好家伙，这不还需要先求出后缀数组来吗？

时复为 $O(n)$ 或 $O(n \log n)$，取决于所用后缀数组的算法。

上面的方法为构造后缀平衡树的离线算法。

虽然这可以建出后缀数组来，但是并不能在线解决问题。~~也不能解决我不会求后缀数组的问题。~~

------------

## 3. 在线构造

那么我们如何在线构造呢？

那我们可以把这个字符串的后缀一个一个地把插入进去平衡树。

怎么插入呢？

我们遍历到每一个节点，用即将插入的后缀 $x$ 和此节点代表的后缀 $y$ 按照字典序比较。如果 $x<y$，那么就向左儿子插入；如果 $x>y$，那么就向右儿子插入。因为每一个后缀的长度都不一样，所以没有相同的情况。

我们以字符串 $\texttt {abababc}$ 为例，把 $\texttt {abababc}$ 的所有后缀插入一棵平衡树：（平衡树以 $\texttt {Treap}$ 为例，黑字为节点代表的字符串，蓝字为节点的 $key$ 值（随机权值））

### 1. 插入后缀 $\texttt {c}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/3yrjpiis.png)

### 2. 插入后缀 $\texttt {bc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/b07ce25d.png)

### 3. 插入后缀 $\texttt {abc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/rllf752d.png)

不满足堆性质，进行旋转调整：

![](https://cdn.luogu.com.cn/upload/image_hosting/j8h16oaf.png)

### 4. 插入后缀 $\texttt {babc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/zgtbuiz0.png)

### 5. 插入后缀 $\texttt {ababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/dhbmehi7.png)

### 6. 插入后缀 $\texttt {bababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/c7swlfja.png)

不满足堆性质，进行旋转调整：

![](https://cdn.luogu.com.cn/upload/image_hosting/96op3km1.png)

### 7. 插入后缀 $\texttt {abababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/6nob4gbs.png)

不满足堆性质，进行旋转调整：

![](https://cdn.luogu.com.cn/upload/image_hosting/izco5hjj.png)

至此，关于字符串 $\texttt {abababc}$ 所有后缀的后缀平衡树已经建立完成了。

我们发现，建立一棵后缀平衡树，其实是把后缀一个一个地插入进平衡树中。

------------

既然有插入一个后缀的操作，那么也应该有删除一个后缀的操作。

我们对于刚才建立的这一棵平衡树，我们把这些后缀一个一个删除。

### 0. 原图：

![](https://cdn.luogu.com.cn/upload/image_hosting/izco5hjj.png)

### 1. 删除后缀 $\texttt {abababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/vt4oc6i2.png)

### 2. 删除后缀 $\texttt {bababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/9qjyidk6.png)

### 3. 删除后缀 $\texttt {ababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/3fpnfahb.png)

### 4. 删除后缀 $\texttt {babc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/tedry4v7.png)

### 5. 删除后缀 $\texttt {abc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/ibnjh0uj.png)

### 6. 删除后缀 $\texttt {bc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/hob36du6.png)

### 7. 删除后缀 $\texttt {c}$：

删空了，就不放图片了。

------------

这个例子貌似不太好…那就再来一个例子吧。

~~其实是来凑字数的。~~

### 0. 原图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9xmpor8j.png)

### 1. 删除后缀 $\texttt {abababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/lz9l583x.png)

### 2. 删除后缀 $\texttt {bababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/yuh19boa.png)

**如图，左右子树分成了两部分，为了避免分类讨论，我把它用 $\texttt {FHQ Treap}$ 的 $\texttt {merge}$ 操作进行合并（当然也可以直接写 $\texttt {Treap}$ 的分类讨论）：**

![](https://cdn.luogu.com.cn/upload/image_hosting/31am5kps.png)

### 3. 删除后缀 $\texttt {ababc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/p09clvv8.png)

### 4. 删除后缀 $\texttt {babc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/xz4oowna.png)

### 5. 删除后缀 $\texttt {abc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/oa9qncx8.png)

### 6. 删除后缀 $\texttt {bc}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/qso67xzd.png)

### 7. 删除后缀 $\texttt {c}$：
删空了，就不放图片了。

------------

我们可以发现，后缀平衡树可以资瓷动态插入一个后缀和删除一个后缀。

毕竟是插入和删除一个后缀，所以后缀平衡树是资瓷在一个字符串**前**插入或删除一个字符。

这一点与后缀自动姬不同。后缀自动姬是在后面插入一个字符，而后缀平衡树是在前面插入一个字符。两者要注意区分。

为什么是在前面呢？

因为如果是在后面插入一个字符的话，那么原有的那些后缀的关系就全部打乱了。设原来字符串的长度为 $n$，那么我们就要把原来的 $n$ 个后缀全部删除，再插入新的 $n+1$ 个后缀。删除一个字符同理。如果在前面插入一个字符的话，假设原有字符串为 $S$，新插入的字符为 $x$，那么原有的后缀其实并没有改变，其实只是新插入了一个后缀 $xS$。删除也是同理。

可以发现，其实后缀平衡树并不难，容易理解。在比赛上是个不错的选择。

------------

## 4. 代码实现

思路都很好理解，那代码呢？

其实也不难。

我们先把普通平衡树的插入给放上来：

```cpp
void ins(int &now,int val){
	if(!now){
		now=++tot;
		tr[now].size=tr[now].cnt=1;
		tr[now].val=val;
		tr[now].key=rand();
		return ;
	}
	if(tr[now].val==val){
		tr[now].cnt++;
		pushup(now);
	}
	else if(tr[now].val>val){
		ins(tr[now].lson,val);
		pushup(now);
		if(tr[now].key<tr[tr[now].lson].key)
			zig(now);
	}
	else{
		ins(tr[now].rson,val);
		pushup(now);
		if(tr[now].key<tr[tr[now].rson].key)
			zag(now);
	}
}
```

我们把它魔改成后缀平衡树…

欸，$val$ 是什么，后缀没有赋权值啊。

那又怎么样？我们可以直接把要插入的后缀与节点所代表的后缀进行比较不就行啦？

那不可能一个节点上就放一个字符串啊。这还不会爆空间？

那么我们就应该想其他的方法。

我们可以把一个节点的编号设为后缀开始的的位置。例如节点 $1$ 就代表从 $1$ 开始的后缀。那么我们就可以这样写：

```cpp
void ins(int &now,int pos){//now为现在访问到的编号，pos为插入后缀的开始节点
	if(!now){//新建节点
		trp[pos].key=rand();
		trp[pos].size=1;
		trp[pos].cnt=1;
		now=pos;//节点编号为后缀开始的位置
		return ;
	}
	if(comp(now,pos)>0){//比较，如果大于0则now代表的后缀的字典序大于pos代表的后缀的字典序
		ins(trp[now].lson,pos);
		pushup(now);
		if(trp[now].key>trp[trp[now].lson].key)
			zig(now);
	}
	else if(comp(now,pos)<0){//小于0则now代表的后缀的字典序小于pos代表的后缀的字典序
		ins(trp[now].rson,pos);
		pushup(now);
		if(trp[now].key>trp[trp[now].rson].key)
			zag(now);
	}
	else{//等于0，字典序相等，后缀相同（其实不可能出现这种情况）
		trp[now].cnt++;
		pushup(now);
	}
}
```

------------

~~不错。那么后缀平衡树的插入操作就解决啦。~~

还有一个问题呢：$\texttt {comp}$ 函数怎么写？

### 1. 暴力比较：

最简单的一种方法：直接暴力遍历两个字符串，对其进行比较：

```cpp
inline int comp(int x,int y){
	for(int i=x,j=y;s[i]||s[j];i++,j++)
		if(s[i]>s[j])
			return 1;
		else if(s[i]<s[j])
			return -1;
	return 0;
}
```

一次比较就需要 $O(n)$ 的时复。一次插入就要 $O(n \log n)$ 的时复。直接原地升天。

### 2. $\texttt {Hash}$ + 二分：

这个方法需要二分找出两个后缀的最长公共前缀（$\texttt {LCP}$）。因为公共前缀的部分一定一样，那么我们比较后一位就可以比较出来啦。

更细致的思路与代码可以看这篇：[洛谷日报#315](https://www.luogu.com.cn/blog/Flying2018/qian-tan-zi-fu-chuan-hash)。

我就不放代码啦。

一次比较需要 $O(\log n)$ 的时复。一次插入要 $O(n \log^2n)$ 的时复。但还是不够优秀。

### 3. 正解：

我们想要的是单次比较 $O(1)$ 的时间复杂度。我们要对插入的后缀进行思考：

我们在字符串 $S$ 前面插入一个字符 $x$，就相等于插入了一个新的后缀 $xS$。其中后缀 $S$ 已经在平衡树中出现过，那么就是说后缀 $S$ 在平衡树中的位置其实已经知道了，大小关系也已经确定了。那么我们是否可以利用这一点呢？

我们把每一个点设置一个虚拟权值 $val$，用来确定它们之间的大小关系。我们怎么判断两个后缀的大小关系呢？我们可以先判断第一个字符。如果不同就已经知道大小关系了；如果相同，那么去掉首字符之后的后缀已经在平衡树中出现过了。我们判断它们 $val$ 的关系就可以知道了。因此，我们插入一个字符串的所有后缀是**有顺序的**。我们应该从后往前插入字符，就相当于每次插入一个新字符在字符串前。

~~妙啊！妙极了！~~

边看代码边理解一下。代码如下：

```cpp
inline int comp(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&trp[x+1].val>trp[y+1].val)//先看首字母，首字母相同再看去掉首字母后的权值大小
		return 1;
	else if(s[x]==s[y]&&trp[x+1].val==trp[y+1].val)
		return 0;
	else return -1;
}
```

------------

那么问题就成了怎么设置 $val$ 了。

### 1. 前驱后继取中值：

这个应该好理解。就是找到要插入的值的前驱和后继，把它们的值相加后除以 $2$ 得到值。

因为是在外面找前驱后继（就是在 $\texttt {main}$ 函数里），所以单次插入时复仍为 $O(\log n)$，但是会爆精度。（就是如果插入的每一个后缀都比之前的后缀大，那么就会呈现“一边偏”的趋势）

### 2. 懒标记：

可以用 $\texttt {FHQ Treap}$ 或者 $\texttt {Splay}$ 等可以支持区间操作的平衡树来维护。

以 $\texttt {FHQ Treap}$ 为例，我们把 $S$ 插入平衡树后，对其进行 $\texttt {Split}$，把字典序小于等于 $S$ 的节点分裂到 $x$ 上，大于 $S$ 的分裂到 $y$ 上。我们把 $y$ 上的节点打一个懒标记，表示 $y$ 上的节点的 $val$ 值全部 $+1$。而 $S$ 的 $val$ 就是 $x$ 中最大的值 $+1$。

不过这种方法因为在 $\texttt {comp}$ 函数中会跳跃访问（在函数中会访问 $x-1$ 号节点和 $y-1$ 号节点），而这些节点上方的标记可能并没有下放完全，所以要把从根到 $x-1$ 和 $y-1$ 的路径上的懒标记全部下放。一次下放需要 $O(\log n)$ 的时间，每一次 $\texttt {comp}$ 都需要下放，单次插入的时复为 $O(\log^2n)$。

这种方法虽然避免了爆精度，但是时复又回到了 $\texttt {Hash}$ + 二分时的 $O(\log^2n)$，并不够优秀。

### 3. 正解：

我们康康解法 $1$，把这些权值拿出来看，我们可以发现：这一些东西构成了一棵**极不平衡**的平衡树。

~~我们是要再写一棵平衡树吗？~~

当然不是。我们现在不是已经有了一棵平衡树了吗？我们只要把这棵平衡树**好好利用**。

怎么利用呢？

我们像线段树一样传两个参数 $l$ 和 $r$，一个点的权值就是 $(l+r) / 2$。走向左儿子时就是 $l$ 和 $(l+r) / 2-1$，走向右儿子就是 $(l+r) / 2 + 1$ 和 $r$。

那么每一次旋转不就会把一部分点的权值给改变了吗？

所以前置芝士就是重量平衡树啊。

我们康康重量平衡树的定义：

> 在插入或删除操作之后，为了保持树的平衡而重构的子树大小为均摊或期望 $O(\log n)$。

哦豁？！

就是每一次插入，需要 $O(\log n)$ 时间来找到插入位置，再用 $O(\log n)$ 时间来重构子树。时复为 $O(2 \log n)$，省去常数为 $O(\log n)$。目的达到！

注意 $l$ 和 $r$ 不开 ```long long``` 见祖宗。

#### Upd：根据[Ireliaღ](https://www.luogu.com.cn/user/126376)大佬所说，有可能 rp 不好会导致 ```long long``` 爆精度，所以保险起见最好使用 ```double``` 类型。

我们康康代码：

```cpp
void get_val(int pos,long long l,long long r){//重构
	if(!pos)//判空
		return ;
	trp[pos].val=l+r>>1;
	get_val(trp[pos].lson,l,trp[pos].val-1);
	get_val(trp[pos].rson,trp[pos].val+1,r);
}
void zig(int &p,long long l,long long r){
	int q=trp[p].lson;
	trp[p].lson=trp[q].rson;
	trp[q].rson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void zag(int &p,long long l,long long r){
	int q=trp[p].rson;
	trp[p].rson=trp[q].lson;
	trp[q].lson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
//左右旋。不想传l和r的可以在外面get_val
void ins(int &now,int pos,long long l,long long r){
	if(!now){
		trp[pos].key=rand();
		trp[pos].val=l+r>>1;
		trp[pos].size=1;
		trp[pos].cnt=1;
		now=pos;
		return ;
	}
	if(comp(now,pos)>0){
		ins(trp[now].lson,pos,l,trp[now].val-1);
		pushup(now);
		if(trp[now].key>trp[trp[now].lson].key)
			zig(now,l,r);
	}
	else if(comp(now,pos)<0){
		ins(trp[now].rson,pos,trp[now].val+1,r);
		pushup(now);
		if(trp[now].key>trp[trp[now].rson].key)
			zag(now,l,r);
	}
	else{
		trp[now].cnt++;
		pushup(now);
	}
}
```

------------

删除操作也是同理。只不过我不想写那么多的分类讨论，所以就换成了 $\texttt {FHQ Treap}$ 的合并左右子树。因为 $\texttt {FHQ Treap}$ 合并后期望树高仍为 $O(\log n)$，所以合并后树高不变。合并左右子树后再重构即可。

代码如下：

```cpp
int merge(int x,int y){//合并
	if(!x||!y)
		return x+y;
	if(trp[x].key<trp[y].key){
		trp[x].rson=merge(trp[x].rson,y);
		pushup(x);
		return x;
	}
	else{
		trp[y].lson=merge(x,trp[y].lson);
		pushup(y);
		return y;
	}
}
void del(int &now,int pos,long long l,long long r){
	if(!now)
		return ;
	if(comp(now,pos)==0){
		if(trp[now].cnt>1)
			trp[now].cnt--;
		else{
			now=merge(trp[now].lson,trp[now].rson);//合并左右子树，相当于删除节点
			get_val(now,l,r);//重构
		}
		pushup(now);
		return ;
	}
	if(comp(now,pos)>0)
		del(trp[now].lson,pos,l,trp[now].val-1);
	else
		del(trp[now].rson,pos,trp[now].val+1,r);
	pushup(now);
}
```

至此，后缀平衡树的插入删除操作就已经全部结束了。

------------

怎么求出后缀数组的那些东西呢？

后缀数组有三个数组：$sa$、$rk$ 和 $height$。$sa_i$ 表示排名为 $i$ 的后缀起点，$rk_i$ 表示后缀起点为 $i$ 的排名，$height_i$ 表示排名为 $i-1$ 的后缀与排名为 $i$ 的后缀的 $\texttt {LCP}$ 长度。

一般后缀数组都是静态问题。我们把后缀平衡树建立之后，一遍 $dfs$ 就可以求出 $sa$ 和 $rk$ 数组啦。然后 $height$ 数组就随你是用 $O(n \log n)$ 的 $\texttt {Hash}$ 还是 $O(n)$ 的遍历了。

求 $sa$ 和 $rk$ 的 $dfs$ 代码：

```cpp
int cnt;
inline void dfs(int now){
	if(!now)
		return ;
	dfs(trp[now].lson);
	sa[++cnt]=now;
	rk[now]=cnt;
	dfs(trp[now].rson);
}
```

------------

我们可以发现，后缀平衡树单次插入需要 $O(\log n)$ 的时间，有 $n$ 个后缀，总共需要 $O(n \log n)$ 的时间。

而后缀平衡树最多有 $n$ 个后缀，那么其实 $\texttt {Treap}$ 就只有 $n$ 个节点。空间复杂度为 $O(n)$。

------------

## 5. 与其他后缀数据结构的比较

众所周知，后缀数据结构有两大毒瘤：一是后缀数组（$\texttt {SA}$），另一个是后缀自动姬（$\texttt{SAM}$）。后缀树我不会，但是个人感觉应该和后缀自动姬差不多（毕竟都可以用一个算法解决）。

后缀平衡树在概念上就是 $\texttt {SA}$ + 平衡树。所以拥有添加字符的操作。这是 $\texttt {SA}$ 所没有的。因为这种概念，所以它比 $\texttt {SAM}$ 更好理解。

后缀平衡树的代码长，但是思路清晰，因此不容易写错。

后缀自动姬可以资瓷加入一个字符，而后缀平衡树不仅可以资瓷加入一个字符，还可以资瓷删除一个字符。这是后缀自动姬所没有的。

我们写 $\texttt {SAM}$ 都需要一个 $ch$ 数组来表示一种转移边。这个 $ch$ 数组是依赖于字符集大小的。而后缀平衡树则不需要考虑这一点。

------------


## 6. 例题

[P3809](https://www.luogu.com.cn/problem/P3809)。

后缀数组模板题。

就直接建出后缀平衡树后 $dfs$ 即可。

时复 $O(n \log n)$。

记得吸吸氧。如果不行就晚上再交。

```cpp
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<cstring>
#include<cstdlib>
#include<cstdio>
using namespace std;
const long long INF=1e18;
const int N=1e6+10;
struct treap{
	long long val;
	int lson,rson;
	int size;
	int key;
	int cnt;
};
treap trp[N];
char s[N];
int root;
inline int comp(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&trp[x+1].val>trp[y+1].val)
		return 1;
	else if(s[x]==s[y]&&trp[x+1].val==trp[y+1].val)
		return 0;
	else
		return -1;
}
inline void pushup(int pos){
	int lson=trp[pos].lson,rson=trp[pos].rson;
	trp[pos].size=trp[lson].size+trp[rson].size+trp[pos].cnt;
}
inline void get_val(int now,long long l,long long r){
	if(!now)
		return ;
	trp[now].val=l+r>>1;
	get_val(trp[now].lson,l,trp[now].val-1);
	get_val(trp[now].rson,trp[now].val+1,r);
}
inline void zig(int &p,long long l,long long r){
	int q=trp[p].lson;
	trp[p].lson=trp[q].rson;
	trp[q].rson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
inline void zag(int &p,long long l,long long r){
	int q=trp[p].rson;
	trp[p].rson=trp[q].lson;
	trp[q].lson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void ins(int &now,int pos,long long l,long long r){
	if(!now){
		trp[pos].val=l+r>>1;
		trp[pos].key=rand();
		trp[pos].size=1;
		trp[pos].cnt=1;
		now=pos;
		return ;
	}
	if(comp(now,pos)>0){
		ins(trp[now].lson,pos,l,trp[now].val-1);
		pushup(now);
		if(trp[trp[now].lson].key<trp[now].key)
			zig(now,l,r);
	}
	else if(comp(now,pos)<0){
		ins(trp[now].rson,pos,trp[now].val+1,r);
		pushup(now);
		if(trp[trp[now].rson].key<trp[now].key)
			zag(now,l,r);
	}
	else{
		trp[now].cnt++;
		pushup(now);
	}
}
inline void dfs(int now){
	if(!now)
		return ;
	dfs(trp[now].lson);
	printf("%d ",now);
	dfs(trp[now].rson);
}
int main(){
	scanf("%s",s+1);
	int l=strlen(s+1);
	for(register int i=l;i>=1;i--)
		ins(root,i,1,INF);//从后向前
	dfs(root);
}
```

然后你就可以爆切各种后缀数组题目了。

------------

[P5353](https://www.luogu.com.cn/problem/P5353)。

树上后缀排序。听说后缀数组很难搞这种东西，但是后缀平衡树可以轻易解决。

其他的没有什么区别，区别在于 $\texttt {comp}$ 函数上：

```cpp
inline int comp(int x,int y){
    if(s[x]>s[y]||s[x]==s[y]&&trp[x+1].val>trp[y+1].val)
        return 1;
    else if(s[x]==s[y]&&trp[x+1].val==trp[y+1].val)
        return 0;
    else return -1;
}
```

我们可以发现，如果字符相同，我们并不是比 $x+1$ 与 $y+1$ 的权值，而是应该比 $fa_x$ 和 $fa_y$ 的权值，而如果 $fa_x$ 与 $fa_y$ 权值相同，我们再比 $x$ 和 $y$ 的**数字大小**。

```cpp
inline int comp(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&trp[fa[x]].val>trp[fa[y]].val)
		return 1;
	else if(s[x]==s[y]&&trp[fa[x]].val==trp[fa[y]].val&&x>y)
		return 1;
	else if(s[x]==s[y]&&trp[fa[x]].val==trp[fa[y]].val&&x==y)
		return 0;
	else
		return -1;
}
```

剩下的就是套模板了。

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
using namespace std;
const long long INF=1e18;
const int N=1e6+10;
struct treap{
	long long val;
	int lson,rson;
	int size;
	int key;
	int cnt;
};
treap trp[N];
char s[N];
int fa[N];
int root;
inline int comp(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&trp[fa[x]].val>trp[fa[y]].val)
		return 1;
	else if(s[x]==s[y]&&trp[fa[x]].val==trp[fa[y]].val&&x>y)
		return 1;
	else if(s[x]==s[y]&&trp[fa[x]].val==trp[fa[y]].val&&x==y)
		return 0;
	else
		return -1;
}
inline void pushup(int pos){
	int lson=trp[pos].lson,rson=trp[pos].rson;
	trp[pos].size=trp[lson].size+trp[rson].size+trp[pos].cnt;
}
inline void get_val(int now,long long l,long long r){
	if(!now)
		return ;
	trp[now].val=l+r>>1;
	get_val(trp[now].lson,l,trp[now].val-1);
	get_val(trp[now].rson,trp[now].val+1,r);
}
void zig(int &p,long long l,long long r){
	int q=trp[p].lson;
	trp[p].lson=trp[q].rson;
	trp[q].rson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void zag(int &p,long long l,long long r){
	int q=trp[p].rson;
	trp[p].rson=trp[q].lson;
	trp[q].lson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void ins(int &now,int pos,long long l,long long r){
	if(!now){
		trp[pos].val=l+r>>1;
		trp[pos].key=rand();
		trp[pos].size=1;
		trp[pos].cnt=1;
		now=pos;
		return ;
	}
	if(comp(now,pos)>0){
		ins(trp[now].lson,pos,l,trp[now].val-1);
		pushup(now);
		if(trp[now].key>trp[trp[now].lson].key)
			zig(now,l,r);
	}
	else if(comp(now,pos)<0){
		ins(trp[now].rson,pos,trp[now].val+1,r);
		pushup(now);
		if(trp[now].key>trp[trp[now].rson].key)
			zag(now,l,r);
	}
	else{
		trp[now].cnt++;
		pushup(now);
	}
}
void dfs(int now){
	if(!now)
		return ;
	dfs(trp[now].lson);
	cout<<now<<' ';
	dfs(trp[now].rson);
}
int main(){
	int n;
	cin>>n;
	for(int i=2;i<=n;i++)
		cin>>fa[i];
	cin>>s+1;
	for(int i=1;i<=n;i++)
		ins(root,i,1,INF);
	dfs(root);
}
```

------------

[P5346](https://www.luogu.com.cn/problem/P5346)。

~~我不会忘记 $\sout {\texttt {AC}}$ 这题时的快乐，这是我放了好久的任务列表上的题目啊。（因为柯南）~~

其实会了 [P5353](https://www.luogu.com.cn/problem/P5353) 后我才发现这个小菜一碟。

先把后缀排序结果算出来，操作 $1$ 可以预处理，$O(1)$ 解决，剩下两个操作均为区间第 $k$ 小的问题，套用主席树即可。具体来讲使用两棵主席树，一棵维护原树上的链，另一棵维护原树的 $dfs$ 序。因为在一棵子树上的 $dfs$ 序必定是连续的，所第二棵其实也是区间第 $k$ 大。

```cpp
#include<cstdlib>
#include<cstdio>
const long long INF=1e18;
const int N=1e6+10;
struct segment_tree{
	struct hjt_node{
		int lson,rson;
		int size;
	};
	hjt_node hjt[40*N];
	int root[N];
	int tot;
	segment_tree(){
		tot=1;
	}
	inline int copynode(int pos){
		hjt[++tot]=hjt[pos];
		return tot;
	}
	void init(int now,int l,int r){
		if(l==r)
			return ;
		hjt[now].lson=++tot;
		hjt[now].rson=++tot;
		int mid=l+r>>1;
		init(hjt[now].lson,l,mid);
		init(hjt[now].rson,mid+1,r);
	}
	int ins(int last,int pos,int l,int r){
		int now=copynode(last);
		hjt[now].size++;
		if(l==r)
			return now;
		int mid=l+r>>1;
		if(pos<=mid)
			hjt[now].lson=ins(hjt[now].lson,pos,l,mid);
		else
			hjt[now].rson=ins(hjt[now].rson,pos,mid+1,r);
		return now;
	}
	int query(int last,int now,int key,int l,int r){
		if(l==r)
			return l;
		int size=hjt[hjt[now].lson].size-hjt[hjt[last].lson].size;
		int mid=l+r>>1;
		if(key<=size)
			return query(hjt[last].lson,hjt[now].lson,key,l,mid);
		else
			return query(hjt[last].rson,hjt[now].rson,key-size,mid+1,r);
	}
};
struct treap{
	long long val;
	int lson,rson;
	int size;
	int key;
	int cnt;
};
struct edge{
	int from,to;
	int nxt;
};
segment_tree hjt1,hjt2;
treap trp[N];
edge e[N];
int fa[N],a[N],last[N],sa[N],rk[N],rev[N],dfn[N],size[N];
int root,tot,cnt,num;
inline void add(int from,int to){
	tot++;
	e[tot].from=from;
	e[tot].to=to;
	e[tot].nxt=last[from];
	last[from]=tot;
}
inline bool comp(int x,int y){
	if(a[x]!=a[y])
		return a[x]>a[y];
	else if(fa[x]&&fa[y]&&fa[x]!=fa[y])
		return trp[fa[x]].val<trp[fa[y]].val;
	else
		return x>y;
}
inline void pushup(int pos){
	int lson=trp[pos].lson,rson=trp[pos].rson;
	trp[pos].size=trp[lson].size+trp[rson].size+trp[pos].cnt;
}
void get_val(int now,long long l,long long r){
	if(!now)
		return ;
	trp[now].val=l+r>>1;
	get_val(trp[now].lson,l,trp[now].val-1);
	get_val(trp[now].rson,trp[now].val+1,r);
}
void zig(int &p,long long l,long long r){
	int q=trp[p].lson;
	trp[p].lson=trp[q].rson;
	trp[q].rson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void zag(int &p,long long l,long long r){
	int q=trp[p].rson;
	trp[p].rson=trp[q].lson;
	trp[q].lson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void ins(int &now,int pos,long long l,long long r){
	if(!now){
		trp[pos].key=rand();
		trp[pos].val=l+r>>1;
		trp[pos].size=1;
		trp[pos].cnt=1;
		now=pos;
		return ;
	}
	if(!comp(now,pos)){
		ins(trp[now].lson,pos,l,trp[now].val-1);
		pushup(now);
		if(trp[now].key>trp[trp[now].lson].key)
			zig(now,l,r);
	}
	else{
		ins(trp[now].rson,pos,trp[now].val+1,r);
		pushup(now);
		if(trp[now].key>trp[trp[now].rson].key)
			zag(now,l,r);
	}
}
void get_sa(int now){
	if(!now)
		return ;
	get_sa(trp[now].lson);
	sa[++cnt]=now;
	rk[now]=cnt;
	get_sa(trp[now].rson);
}
void dfs(int u){
	rev[++num]=u;
	dfn[u]=num;
	size[u]=1;
	for(int i=last[u];i;i=e[i].nxt){
		int v=e[i].to;
		dfs(v);
		size[u]+=size[v];
	}
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=2;i<=n;i++){
		scanf("%d",&fa[i]);
		add(fa[i],i);
	}
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		ins(root,i,1,INF);
	get_sa(root);
	hjt1.init(hjt1.root[0]=1,1,n);
	for(int i=1;i<=n;i++)
		hjt1.root[i]=hjt1.ins(hjt1.root[fa[i]],rk[i],1,n);
	dfs(1);
	hjt2.init(hjt2.root[0]=1,1,n);
	for(int i=1;i<=n;i++)
		hjt2.root[i]=hjt2.ins(hjt2.root[i-1],rk[rev[i]],1,n);
	int opt,x,y;
	while(m--){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d",&x);
			printf("%d\n",rk[x]);
		}
		else if(opt==2){
			scanf("%d%d",&x,&y);
			printf("%d\n",sa[hjt1.query(hjt1.root[0],hjt1.root[x],y,1,n)]);
		}
		else{
			scanf("%d%d",&x,&y);
			printf("%d\n",sa[hjt2.query(hjt2.root[dfn[x]-1],hjt2.root[dfn[x]+size[x]-1],y,1,n)]);
		}
	}
}
```

------------

[P5212](https://www.luogu.com.cn/problem/P5212)。

~~这题我脑抽在 $\sout {\texttt {if}}$ 后加了分号结果一直没调出来…~~

这一题是在字符串**后面**加入一个字符，我们要把它**转换**成在字符串前面加入一个字符。

怎么转换？

就是把整个字符串颠倒。

其实就是 $\texttt {comp}$ 函数变成这样：

```cpp
inline int comp(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&trp[x-1].val>trp[y-1].val)
		return 1;
	else if(s[x]==s[y]&&trp[x-1].val==trp[y-1].val)
		return 0;
	else return -1;
}
```

因为转换之后，我们可以认为它维护的是原字符串的前缀，只不过是从最后一位开始比较。我们比较最后一位之后，我们就要比较倒数第二位。即为 $x-1$ 和 $y-1$。

假设原串为 $S$，查询的串为 $str$，那么查询我们可以转换为有多少个 $S$ 的后缀以 $str$ 作为前缀。即有多少 $S^\prime$ 的后缀以 $str^\prime$ 作为前缀。其中 $S^\prime$ 为 $S$ 的反串，$str^\prime$ 为 $str$ 的反串。

我们可以在 $str^\prime$ 后加入极大值，在后缀平衡树中查询排名为 $ans1$，再把上一个字符 $-1$ 后查询排名设为 $ans2$。答案就是 $ans1-(ans2+1)+1=ans1-ans2$。

因为查询的字符串并没有在平衡树中出现过，所以不能使用原来的那种方法比较。我们只能暴力比较。时复为  $O(\sum |str| \log n)$。数据范围告诉我们 $O(\sum|str|)$ 为 $3 \times 10^6$，所以查询时复为 $O(3 \times 10^6 \log n)$

放上代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
const long long INF=1e18;
const int N=1e6+10;
struct treap{
	long long val;
	int lson,rson;
	int size;
	int key;
	int cnt;
};
treap trp[N];
char s[N],str[N],opt[10];
int root;
void decode(char *ch,int mask){
	int l=strlen(ch);
	for(int i=0;i<l;i++){
		mask=(mask*131+i)%l;
		char t=ch[i];
		ch[i]=ch[mask];
		ch[mask]=t;
	}
}
inline int comp(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&trp[x-1].val>trp[y-1].val)
		return 1;
	else if(s[x]==s[y]&&trp[x-1].val==trp[y-1].val)
		return 0;
	else
		return -1;
}
bool check(int pos){
	for(int i=1,j=pos;str[i];i++,j--)//因为是逆序，所以j要倒着遍历
		if(str[i]>s[j])
			return false;
		else if(s[j]>str[i])
			return true;
}
inline void pushup(int pos){
	int lson=trp[pos].lson,rson=trp[pos].rson;
	trp[pos].size=trp[lson].size+trp[rson].size+trp[pos].cnt;
}
inline void get_val(int now,long long l,long long r){
	trp[now].val=l+r>>1;
	if(trp[now].lson)
		get_val(trp[now].lson,l,trp[now].val-1);
	if(trp[now].rson)
		get_val(trp[now].rson,trp[now].val+1,r);
}
void zig(int &p,long long l,long long r){
	int q=trp[p].lson;
	trp[p].lson=trp[q].rson;
	trp[q].rson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void zag(int &p,long long l,long long r){
	int q=trp[p].rson;
	trp[p].rson=trp[q].lson;
	trp[q].lson=p;
	pushup(p);
	pushup(q);
	get_val(q,l,r);
	p=q;
}
void ins(int &now,int pos,long long l,long long r){
	if(!now){
		trp[pos].val=l+r>>1;
		trp[pos].key=rand();
		trp[pos].size=1;
		trp[pos].cnt=1;
		now=pos;
		return ;
	}
	if(comp(now,pos)>0){
		ins(trp[now].lson,pos,l,trp[now].val-1);
		pushup(now);
		if(trp[trp[now].lson].key<trp[now].key)
			zig(now,l,r);
	}
	else if(comp(now,pos)<0){
		ins(trp[now].rson,pos,trp[now].val+1,r);
		pushup(now);
		if(trp[trp[now].rson].key<trp[now].key)
			zag(now,l,r);
	}
	else{
		trp[now].cnt++;
		pushup(now);
	}
}
int rnk(int now){
	if(!now)
		return 1;
	else if(check(now))
		return rnk(trp[now].lson);
	else
		return rnk(trp[now].rson)+trp[trp[now].lson].size+trp[now].cnt;
}
int main(){
	int n;
	cin>>n;
	cin>>s+1;
	int len=strlen(s+1),l;
	for(int i=1;i<=len;i++)
		ins(root,i,1,INF);
	int mask=0,ans;
	while(n--){
		cin>>opt+1>>str+1;
		decode(str+1,mask);
		l=strlen(str+1);
		if(opt[1]=='A'){
			for(int i=len+1;i<=len+l;i++){
				s[i]=str[i-len];
				ins(root,i,1,INF);
			}
			len+=l;
		}
		else{
			reverse(str+1,str+l+1);
			str[l+1]='C';
			str[l+2]='\0';
			ans=rnk(root);
			str[l]--;
			ans-=rnk(root);
			mask^=ans;
			cout<<ans<<'\n';
		}
	}
}
```

------------

[P6164](https://www.luogu.com.cn/problem/P6164)。

~~终于到了模板题。~~

其实就比上一道题多了一个删除操作而已…

加上删除操作就可以了。

放上代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
using namespace std;
const long long INF=1e18;
const int N=8e5+10;
struct treap{
	long long val;
	int lson,rson;
	int size;
	int cnt;
	int key;
};
treap trp[N];
char s[N],ty[11],str[N];
int root;
void decode(char *ch,int mask){
	int l=strlen(ch);
	for(int i=0;i<l;i++){
		mask=(mask*131+i)%l;
		char t=ch[i];
		ch[i]=ch[mask];
		ch[mask]=t;
	}
}
inline int comp(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&trp[x-1].val>trp[y-1].val)
		return 1;
	else if(s[x]==s[y]&&trp[x-1].val==trp[y-1].val)
		return 0;
	else return -1;
}
inline bool check(int pos){
	for(int i=1,j=pos;str[i];i++,j--)
		if(str[i]<s[j])
			return true;
		else if(str[i]>s[j])
			return false;
}
inline void pushup(int pos){
	int lson=trp[pos].lson,rson=trp[pos].rson;
	trp[pos].size=trp[lson].size+trp[rson].size+trp[pos].cnt;
}
void dfs(int pos,long long l,long long r){
	int lson=trp[pos].lson,rson=trp[pos].rson;
	trp[pos].val=l+r>>1;
	if(lson)
		dfs(lson,l,trp[pos].val-1);
	if(rson)
		dfs(rson,trp[pos].val+1,r);
}
void zig(int &p,long long l,long long r){
	int q=trp[p].lson;
	trp[p].lson=trp[q].rson;
	trp[q].rson=p;
	pushup(p);
	pushup(q);
	dfs(q,l,r);
	p=q;
}
void zag(int &p,long long l,long long r){
	int q=trp[p].rson;
	trp[p].rson=trp[q].lson;
	trp[q].lson=p;
	pushup(p);
	pushup(q);
	dfs(q,l,r);
	p=q;
}
int merge(int x,int y){
	if(!x||!y)
		return x+y;
	if(trp[x].key<trp[y].key){
		trp[x].rson=merge(trp[x].rson,y);
		pushup(x);
		return x;
	}
	else{
		trp[y].lson=merge(x,trp[y].lson);
		pushup(y);
		return y;
	}
}
void ins(int &now,int pos,long long l,long long r){
	if(!now){
		trp[pos].lson=trp[pos].rson=0;
		trp[pos].key=rand();
		trp[pos].val=(l+r)/2;
		trp[pos].size=1;
		trp[pos].cnt=1;
		now=pos;
		return ;
	}
	if(comp(now,pos)>0){
		ins(trp[now].lson,pos,l,trp[now].val-1);
		pushup(now);
		if(trp[now].key>trp[trp[now].lson].key)
			zig(now,l,r);
	}
	else if(comp(now,pos)<0){
		ins(trp[now].rson,pos,trp[now].val+1,r);
		pushup(now);
		if(trp[now].key>trp[trp[now].rson].key)
			zag(now,l,r);
	}
	else{
		trp[now].cnt++;
		pushup(now);
	}
}
void del(int &now,int pos,long long l,long long r){
	if(!now)
		return ;
	if(comp(now,pos)==0){
		if(trp[now].cnt>1)
			trp[now].cnt--;
		else{
			now=merge(trp[now].lson,trp[now].rson);
			if(now)
				dfs(now,l,r);
		}
		return ;
	}
	if(comp(now,pos)>0)
		del(trp[now].lson,pos,l,trp[now].val-1);
	else
		del(trp[now].rson,pos,trp[now].val+1,r);
	pushup(now);
}
int rnk(int now){
	if(!now)
		return 1;
	else if(check(now))
		return rnk(trp[now].lson);
	else
		return rnk(trp[now].rson)+trp[trp[now].lson].size+trp[now].cnt;
}
int main(){
	int n;
	cin>>n;
	cin>>s+1;
	int len=strlen(s+1);
	for(int i=1;i<=len;i++)
		ins(root,i,1,INF);
	int l,x;
	int ans;
	int mask=0;
	while(n--){
		cin>>ty+1;
		switch(ty[1]){
			case 'A':
				cin>>str+1;
				decode(str+1,mask);
				l=strlen(str+1);
				for(int i=len+1;i<=len+l;i++){
					s[i]=str[i-len];
					ins(root,i,1,INF);
				}
				len+=l;
				break;
			case 'D':
				cin>>x;
				for(int i=len;i>len-x;i--)
					del(root,i,1,INF);
				len-=x;
				break;
			case 'Q':
				cin>>str+1;
				decode(str+1,mask);
				int l=strlen(str+1);
				reverse(str+1,str+l+1);
				str[l+1]='Z'+1;
				str[l+2]='\0';
				ans=rnk(root);
				str[l]--;
				ans-=rnk(root);
				mask^=ans;
				cout<<ans<<'\n';
				break;
		}
	}
}
```

------------

### 插入：可持久化后缀平衡树

貌似可以，又貌似不行…

~~反正我是不会啦。有谁可以教一下我？~~

------------

## 7. 参考资料

### 陈立杰的论文：[重量平衡树和后缀平衡树在信息学奥赛中的应用](https://www.docin.com/p-1387378205.html?docfrom=rrela)。

### YoungNeal的总结：[[总结] 后缀平衡树学习笔记](https://www.cnblogs.com/YoungNeal/p/10270377.html)。

### Ireliaღ的题解：[题解 P6164 【【模板】后缀平衡树】](https://www.luogu.com.cn/blog/126376/solution-p6164)。

---

## 作者：Ireliaღ (赞：29)

终于抢到第一篇题解了，真不容易

## 后缀平衡树

### 前置知识

替罪羊树

### 原理

后缀平衡树是一个以字典序为关键字的有序字符串集$X$，它可以资瓷两种复杂度为$O(\log n)$的操作：

- 向字符串集中加入一个长度为$1$的字符串$S$

- 向字符串集中加入字符串$xS$，其中$S \in X$

所以，如果对一个字符串逆序执行插入操作，它就是严格的“后缀平衡树”，它的中序遍历也就是后缀数组。但其实上，观察这两个操作，它完全可以维护一个有根树森林。

### 实现

两种插入操作完全可以视为一种。我们考虑要加入一个字符串$xS$，我们要做的就是从根开始与当前节点进行比较，然后进入左/右儿子，直到找到一个空位为止。现在的问题就是，如何比较要插入的字符串和节点上的字符串。

显然我们不能$O(n)$暴力比较。考虑到要插入的字符串$xS$，除去第一个字母之后的$S$已经在树中，并且树是有序的。那么当第一个字符相同时，我们完全可以利用这棵树进行$O(\log n)$比较后面的部分，这样的话，插入操作时$O(\log ^ 2 n)$的。

考虑如何进行$O(1)$比较，来做到单次操作是$O(\log n)$。我们对于每个节点维护一个$key$值代表在树中的相对位置。具体方法是：选取一个很大的值域，每次进入下一层时根据左右儿子将值域折半，最终节点的值就是当前值域的$mid$值。当需要比较两个已经在树中的字符串时，直接比较$key$值即可，复杂度$O(1)$。

对于如何维护平衡，最简单的方法就是使用替罪羊树，注意在重构时要重新赋key值。

## 本题做法

由于后缀平衡树维护串头操作比较容易，所以对于这种串尾操作，我们可以直接维护反串的后缀平衡树，添加和删除操作正常维护，注意删除时彻底删除节点而不是使用懒标记，这样更不容易犯错，方便后面的查询。

查询时，假设当前串为$S$，查询以$T$在$S$中的出现次数，就可以转化为查询有多少个$S$的后缀是以$T$为前缀的。我们把$T$翻转，在后面添加一个字典序极大的字符`'Z'+1`，查询它的排名为$r$。然后我们保留后添加的字符，把上一个字符$-1$，再次查询它的排名为$l$。这样，得到的$r-l$就是$T$在$S$中的出现次数。

代码如下

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
const double LIM = 1e16;
const int MAXN = 2e6;

int n, m;
char str[MAXN], S[MAXN];
double key[MAXN];
int ch[MAXN][2], siz[MAXN];
int tr[MAXN], rt, tcnt;
char op[10];

void Decode(char *s, int mask) {
	int len = strlen(s);
	for (int i = 0; i < len; i++) {
		mask = (mask * 131 + i) % len;
		char t = s[i];
		s[i] = s[mask];
		s[mask] = t;
	}
}

void Update(int now) {
	siz[now] = 1 + siz[ch[now][0]] + siz[ch[now][1]];
}

int Bad(int now) {
	return 1.0 * siz[ch[now][0]] > 0.7 * siz[now] || 1.0 * siz[ch[now][1]] > 0.7 * siz[now];
}

void DFS(int now) {
	if (!now) return;
	DFS(ch[now][0]);
	tr[++tcnt] = now;
	DFS(ch[now][1]);
	ch[now][0] = ch[now][1] = 0;
}

void Rebuild(int &now, int l, int r, double lv, double rv) {
	if (l > r) return;
	int mid = (l + r) >> 1;
	double midv = (lv + rv) / 2;
	now = tr[mid];
	key[now] = midv;
	Rebuild(ch[now][0], l, mid - 1, lv, midv);
	Rebuild(ch[now][1], mid + 1, r, midv, rv);
	Update(now);
}

void Maintain(int &now, double lv, double rv) {
	if (Bad(now)) {
		tcnt = 0;
		DFS(now);
		Rebuild(now, 1, tcnt, lv, rv);
	}
}

int Comp(int x, int y) {
	return S[x] < S[y] || (S[x] == S[y] && key[x - 1] < key[y - 1]);
}

void Insert(int &now, int idx, double lv, double rv) {
	if (!now) {
		now = idx;
		siz[now] = 1;
		key[now] = (lv + rv) / 2;
		ch[now][0] = ch[now][1] = 0;
		return;
	}
	if (Comp(idx, now)) Insert(ch[now][0], idx, lv, key[now]);
	else Insert(ch[now][1], idx, key[now], rv);
	Update(now);
	Maintain(now, lv, rv);
}

void Remove(int &now, int idx) {
	if (now == idx) {
		if (!ch[now][0] || !ch[now][1]) {
			now = (ch[now][0] | ch[now][1]);
		} else {
			int cur = ch[now][0], las = now;
			while (ch[cur][1]) {
				las = cur;
				siz[las]--;
				cur = ch[cur][1];
			}
			if (las == now) {
				ch[cur][1] = ch[now][1];
				now = cur;
				Update(now);
			} else {
				ch[cur][0] = ch[now][0];
				ch[cur][1] = ch[now][1];
				ch[las][1] = 0;
				now = cur;
				Update(now);
			}
		}
		return;
	}
	if (Comp(idx, now)) Remove(ch[now][0], idx);
	else Remove(ch[now][1], idx);
	Update(now);
}

int Com(int now) {
	for (int p = 1; str[p]; p++, now = (now ? now - 1 : 0)) {
		if (str[p] < S[now]) return 1;
		else if (str[p] > S[now]) return 0;
	}
}

int Query(int now) {
	if (!now) return 0;
	int ls = siz[ch[now][0]];
	if (Com(now)) return Query(ch[now][0]);
	else return Query(ch[now][1]) + ls + 1;
}

int main() {
	scanf("%d", &m);
	scanf("%s", S + 1);
	int mask = 0, ans = 0;
	n = strlen(S + 1);
	for (int i = 1; i <= n; i++) Insert(rt, i, 0, LIM);
	for (int i = 1; i <= m; i++) {
		scanf("%s", op);
		if (op[0] == 'A') {
			scanf("%s", str + 1);
			Decode(str + 1, mask);
			int len = strlen(str + 1);
			for (int j = 1; j <= len; j++) {
				S[n + j] = str[j];
				Insert(rt, n + j, 0, LIM);
			}
			n += len;
		} else if (op[0] == 'Q') {
			scanf("%s", str + 1);
			Decode(str + 1, mask);
			int len = strlen(str + 1);
			reverse(str + 1, str + len + 1);
			str[len + 1] = 'Z' + 1;
			str[len + 2] = '\0';
			ans = Query(rt);
			str[len]--;
			ans -= Query(rt);
			printf("%d\n", ans);
			mask ^= ans;
		} else {
			int k;
			scanf("%d", &k);
			for (int j = n; j > n - k; j--) Remove(rt, j);
			n -= k;
		}
	}
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：6)

将字符串的后缀按照字典序排序，可以支持很多操作，后缀平衡树就是将后缀以字典序为比较方式构成的平衡树，支持动态插入、删除、可持久化。

容易知道，在插入的过程中，需要将后缀进行比较，假设插入 $y$，要和 $x$ 进行比较，可以先比较 $S_x$ 和 $S_y$，如果相等，就要将后缀 $x-1,y-1$，进行比较，可以求它们在后缀树上的名次，这样可以用任意平衡树维护，插入复杂度为$O(\log^2n)$，在数据范围较小时，为了减少码量可以这么做。

如果能做到给每一个树上的节点实现 $O(1)$ 比较，就可以 $O(\log n)$ 插入了，方法是给每个节点赋予一个权值，这样每次旋转都需要将整棵树重构权值，使用替罪羊树最为合适，即插入时对每棵访问到的子树有 $\frac{1}{size}$ 的概率将其重构，这样也可以实现可持久化（但常数较大）。

查询就等价于上界减下界，暴力比较即可。复杂度为 $O(\sum L\log n)$ 可以通过此题。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=8e5+5,M=3e6+6;
char buf[M+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2)?EOF:*p1++)
inline void read(int &x){
	for(c=gc;c<'0'||c>'9';c=gc);
	for(x=0;c>='0'&&c<='9';x=x*10+c-'0',c=gc);
}
char s[N],st[M];
int t[N][2],Q,n,tot,mask,ans,rt,*nrb,sz[N],val,rb[N],bt;
typedef long double ld;
ld d[N][3],lv,rv;
inline void read(char *s){
	while(!isalpha(c=gc));n=0;
	do s[++n]=c;while(isalpha(c=gc));
}
inline void decode(char *st,int mask){
	for(int i=0;i<n;i++)
		mask=(mask*131+i)%n,swap(st[i],st[mask]);
}
void Rem(int x){if(t[x][0])Rem(t[x][0]);rb[++bt]=x;if(t[x][1])Rem(t[x][1]);}
int Mak(int l,int r,ld L,ld R){
	if(l>r)return 0;int md=l+r>>1,x=rb[md];ld Md=(L+R)/2;
	t[x][0]=Mak(l,md-1,L,Md),t[x][1]=Mak(md+1,r,Md,R);
	d[x][0]=L,d[x][1]=Md,d[x][2]=R,sz[x]=sz[t[x][0]]+sz[t[x][1]]+1;
	return x;
}
void Reb(int &x){bt=0,Rem(x),x=Mak(1,bt,d[x][0],d[x][2]);}
void Ins(int &x,ld L,ld R){
	if(!x){
		x=val,t[x][0]=t[x][1]=0,sz[x]=1;
		d[x][0]=L,d[x][1]=(L+R)/2,d[x][2]=R;
	}else{
		int k=s[x]==s[val]?d[x-1][1]<d[val-1][1]:s[x]<s[val];
		Ins(t[x][k],d[x][k],d[x][k+1]),++sz[x];
		if((rand()+rand())%sz[x]==0)nrb=&x;
	}
}
void Del(int &x){
	int k=d[val][1]>=d[x][1],&y=t[x][k],&z=t[x][!k];
	if(y){
		Del(y);if(k&&val){
			t[val][0]=t[x][0],t[val][1]=t[x][1];
			d[val][0]=d[x][0],d[val][1]=d[x][1];
			d[val][2]=d[x][2],x=val,val=0;
		}sz[x]=sz[y]+sz[z]+1;
	}else {val=(x==val)?0:x;x=z;}
	return;
}
void Ins(int x){val=x,nrb=NULL,Ins(rt,1,1e18);if(nrb)Reb(*nrb);}
int lwb(int x){
	if(!x)return 0;int i,k=0;
	for(i=0;i<n;++i)
		if(i==x){k=1;break;}
		else if(s[x-i]!=st[n-i]){k=s[x-i]<st[n-i];break;}
	return k?sz[t[x][0]]+1+lwb(t[x][1]):lwb(t[x][0]);
}
int main(){
    srand(1919810u^time(0));
	read(Q),read(s);int i,j,k;
	for(i=1;i<=n;++i)Ins(i);tot=n;
	while(Q--){
		read(st);
		if(st[1]=='A'){
			read(st),decode(st+1,mask);
			for(i=1;i<=n;++i)s[++tot]=st[i],Ins(tot);
		}else if(st[1]=='Q'){
			read(st),decode(st+1,mask),ans=lwb(rt),++st[1];
			ans=lwb(rt)-ans;printf("%d\n",ans),mask^=ans;
		}else for(i=1,read(n);i<=n;++i)val=tot--,Del(rt);
	}
	return 0;
}
```

---

## 作者：Tachanka233 (赞：5)

来一发 FHQTreap 的题解。


---

## 前置知识

重量平衡树。

重量平衡树的定义为每次插入新节点对应的子树大小为期望或均摊 $O(\log n)$ 的平衡树。

主要的重量平衡树有：Treap、WBLT、替罪羊树等。

本文将使用 FHQTreap 进行讲解。

## 算法简介

### 定义

后缀平衡树维护一个包含字符串所有后缀的有序集合，并支持动态加入后缀（在字符串前添加字符）。通常采用重量平衡树实现。后缀平衡树的中序遍历即为后缀数组。

后缀平衡树可以实现动态在开头加字符，删字符，查询后缀排名，查询字符串排名等。

### 过程

先考虑暴力构造。每次向平衡树里插入一个后缀，然后暴力比较新字符串和当前遍历到的节点。一次比较复杂度 $O(n)$，一次插入复杂度 $O(n\log n)$，总复杂度 $O(n^2\log n)$。显然，这个复杂度是不可接受的。

既然后缀平衡树的中序遍历是后缀数组，那么我们可以考虑像后缀数组一样用已经求出的后缀的排名关系优化字符串比较的过程。

每次比较新后缀和一个已有的后缀，先比较对应位置上字符的大小，若相等，则比较上一个后缀的大小。比较已有后缀可以直接查排名，也可以用 Hash + 二分，复杂度 $O(\log n)$，总复杂度 $O(n\log^2 n)$。

这样的复杂度仍然不够优秀，考虑进一步优化。观察到比较两个位置的字符是 $O(1)$ 的，但比较两个后缀是 $O(\log n)$ 的，这很不优。所以我们考虑加速两个后缀的比较。

我们令平衡树上每个点对应一个区间 $[l,r]$，定义这个点的权值 $val$ 为 $\frac{l+r}{2}$，并且令每个节点左儿子对应的区间为 $[l,\frac{l+r}{2}]$，右儿子为 $[\frac{l+r}{2},r]$，则所有节点的权值一定满足平衡树左儿子 $<$ 自身 $<$ 右儿子的特性。

那么，比较两个在平衡树上的节点就只需要比较它们的 $val$ 就可以了。这就完成了 $O(1)$ 的两个后缀比较。然后在插入新节点或删除节点后将子树内的 $val$ 值重新计算即可。一次插入复杂度 $O(\log n)$，总复杂度 $O(n\log n)$。删除同理。

查询后缀排名就是查询平衡树内某个节点的排名，是平衡树的基本操作之一，复杂度 $O(\log n)$，不再赘述。查询字符串的排名因为字符串不一定在原串中出现，所以只能朴素地字符串比较。总复杂度 $O(\left\vert S\right\vert\log n)$，其中 $\left\vert S\right\vert$ 表示查询字符串的长度。

## 复杂度证明

Treap 期望树高 $O(\log n)$，所以一次插入或删除共进行 $O(\log n)$ 次比较，每次比较复杂度 $O(1)$，故插入或删除复杂度为 $O(\log n)$。

根据重量平衡树的性质：一次插入或删除找到的节点的子树大小期望或均摊 $O(\log n)$，可以知道插入或删除后暴力重构子树内 $val$ 值是 $O(\log n)$ 的。

查询后缀排名的复杂度与树高相同，是 $O(\log n)$ 的。

查询字符串排名的复杂度，一次比较为 $O(\left\vert S\right\vert)$，比较次数与树高相同，为 $O(\log n)$，因此总复杂度为 $O(\left\vert S\right\vert\log n)$。

所以算法总复杂度为 $O(n\log n+\left\vert S\right\vert\log n)$。

## 代码实现

本文使用 FHQTreap 实现。

在字符串后插入或删除字符字符可以将字符串翻转，然后改为在字符串前插入或删除字符。

对于插入操作，找到要插入的位置，然后将该位置分裂，两个根节点作为新节点的两个子节点。

对于删除操作，找到要删除的位置，将两个儿子对应的子树合并作为当前节点。

查询字符串 $s$ 出现次数，实际上就是问 $\operatorname{rank}(s+char(\infty))-\operatorname{rank}(s+char(0))$，其中 $\operatorname{rank}(s)$ 表示 $s$ 在当前集合中的排名，$s+c$ 表示在字符串 $s$ 后面加一个字符 $c$ 形成的字符串。

维护的权值 $val$ 最好使用浮点数类型，并给根节点赋一个较大的区间，不容易爆精度。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N=2e6+6,inf=1e9+7;
mt19937 f(chrono::steady_clock::now().time_since_epoch().count());
inline int rd(){return f()%inf;}//随机函数
struct FHQTreap{
    int ls[N],rs[N],size[N],pri[N],cnt,rt;
    char c[N];//当前节点字符
    double val[N];//当前节点权值
    inline int newnode(char v){//新建节点
        int p=++cnt;
        ls[p]=rs[p]=0;
        size[p]=1;
        c[p]=v;
        pri[p]=rd();
        return p;
    }
    inline bool cmp(int x,int y){//比较后缀大小
        return c[x]>c[y]||(c[x]==c[y]&&val[x-1]>val[y-1]);
    }
    inline void pushup(int p){//维护子树size
        size[p]=size[ls[p]]+size[rs[p]]+1;
    }
    void get_val(int p,double l,double r){//更新p子树内的权值
        if(!p)return;
        val[p]=(l+r)/2;
        get_val(ls[p],l,val[p]);
        get_val(rs[p],val[p],r);
    }
    void split_rank(int rt,int rank,int &rtl,int &rtr){//按排名分裂
        if(!rt){rtl=rtr=0;return;}
        if(size[ls[rt]]>=rank){
            rtr=rt;
            split_rank(ls[rtr],rank,rtl,ls[rtr]);
            pushup(rtr);
        }
        else{
            rtl=rt;
            split_rank(rs[rtl],rank-size[ls[rtl]]-1,rs[rtl],rtr);
            pushup(rtl);
        }
    }
    int merge(int rtl,int rtr){//合并
        if(!rtl)return rtr;
        if(!rtr)return rtl;
        if(pri[rtl]<pri[rtr]){
            rs[rtl]=merge(rs[rtl],rtr);
            pushup(rtl);
            return rtl;
        }
        else{
            ls[rtr]=merge(rtl,ls[rtr]);
            pushup(rtr);
            return rtr;
        }
    }
    int get_rank(int p,int node){//获得节点node在节点p为根的子树内的排名
        int rank=0;
        while(p){
            if(cmp(node,p))rank+=size[ls[p]]+1,p=rs[p];
            else p=ls[p];
        }
        return rank;
    }
    void insert(int &p,int node,double l,double r){//向以p为根的子树内插入节点node
        if(!p||pri[p]>pri[node]){
            split_rank(p,get_rank(p,node),ls[node],rs[node]);
            get_val(p=node,l,r);
            pushup(p);
            return;
        }
        if(cmp(node,p))insert(rs[p],node,val[p],r);
        else insert(ls[p],node,l,val[p]);
        pushup(p);
    }
    void del(int &p,int rank,double l,double r){//在以p为根的子树内删除排名为rank的节点
        if(size[ls[p]]==rank){
            cnt--;
            get_val(p=merge(ls[p],rs[p]),l,r);
            return;
        }
        if(size[ls[p]]>rank)del(ls[p],rank,l,val[p]);
        else del(rs[p],rank-size[ls[p]]-1,val[p],r);
        pushup(p);
    }
    inline bool scmp(string s,int p){//字符串比较
        for(char v:s){
            if(!p)return 1;
            if(v>c[p])return 1;
            if(v<c[p])return 0;
            p--;
        }
        return 0;
    }
    int get_rank(string s){//获取字符串s在整棵树内的排名
        int p=rt,rank=0;
        while(p){
            if(scmp(s,p))rank+=size[ls[p]]+1,p=rs[p];
            else p=ls[p];
        }
        return rank;
    }
}tr;
int mask;
void decodeWithMask(string &s,int mask){
	for(int j=0;j<s.size();j++){
		mask=(mask*131+j)%s.size();
		swap(s[j],s[mask]);
	}
}
int n;
string s;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    cin>>s;
    tr.insert(tr.rt,tr.newnode(1),0,1e18);//先加入一个极小值
    for(char c:s){
        tr.insert(tr.rt,tr.newnode(c),0,1e18);
    }
    for(int i=1;i<=n;i++){
        string type,x;
        int ans,y;
        cin>>type;
        if(type=="QUERY"){
            cin>>x;
            decodeWithMask(x,mask);
            reverse(x.begin(),x.end());//先翻转再查询
            ans=tr.get_rank(x+char(127))-tr.get_rank(x+char(0));
            cout<<ans<<'\n',mask^=ans;
        }
        else if(type=="ADD"){
            cin>>x;
            decodeWithMask(x,mask);
            for(char c:x){
                tr.insert(tr.rt,tr.newnode(c),0,1e18);
            }
        }
        else{
            cin>>y;
            for(int i=1;i<=y;i++){
                tr.del(tr.rt,tr.get_rank(tr.rt,tr.size[tr.rt]),0,1e18);
            }
        }
    }
    return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：3)

来补最后一个后缀数据结构板子了。

由于题目中要求的是在后面插入，所以我写的实际上是一个前缀数据结构，下文中认为比较两个字符串的字典序时是**从后往前**比。

考虑将给定串所有前缀按照字典序大小插入一棵平衡树中。

考虑将前缀从小往大增量地插入平衡树中，考虑在插入前缀 $[1,i]$ 时如何比较其与前面前缀的字典序关系以将其插入平衡树。

对于前缀 $[1,i]$ 与前缀 $[1,j]$，考虑先比较 $S_i$ 与 $S_j$ 的大小关系，假若不同则可以直接得出结果，否则我们发现就需要比较前缀 $[1,i-1]$ 与前缀 $[1,j-1]$ 的字典序，由于这两个前缀均已经插入平衡树，所以假若可以 $O(1)$ 直到这两个前缀在平衡树上的 dfs 序大小关系就可以 $O(\log n)$ 插入一个前缀。

该如何维护 dfs 序的大小关系呢？

考虑对于平衡树上每个节点维护一个区间 $[l,r]$，像线段树那样，令左儿子区间为 $[l,mid]$，右儿子区间为 $[mid,r]$（这里区间和线段树稍有不同但是没关系），然后比较两个节点时就比较其对应区间的中点之间的大小关系，不难发现这与 dfs 序大小关系一致。

那该如何删除呢？

对于要删除的节点 $u$，假若其没有右儿子，那么直接把左儿子提上来，虽然这会使得上面父亲区间与儿子区间的对应关系被破坏，但是儿子真是的区间一定是理论上的区间的一个子区间，因此中点的性质依然保存。假若存在右儿子，那么就在左儿子子树中一直向右走直到没有右儿子，也就是走到左儿子子树中最大点，将最大点仿照前面的处理删除再传回来，用其代替掉真正要删除的节点即可。

查询出现次数考虑询问串 $T$ 是多少个前缀的后缀，我们发现如果是一个前缀的后缀话，那么将询问串开头加上一个字典序等于极小字符减去 $1$ 的字符与将询问串开头加上一个字典序等于极大字符加上 $1$ 的字符后，字典序大小关系发生了改变，否则不会改变，因此考虑用这两种方式分别查询下，再差分即可。

为了使得区间不掉精度，我们需要保证平衡树的树高，并且一般平衡树难以在合并分裂或者是旋转时维护区间的变化，因此考虑使用替罪羊树即可。

为了实现方便，代码中对读入的串做了些处理，具体可以见代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6+114;
const long long inf = 2e18;
char S[maxn];
int len;
int q;
long long L[maxn],R[maxn];
int ls[maxn],rs[maxn],sz[maxn];
bool cmp(int x,int y){
    if(x==0) return true;
    if(y==0) return false;
    if(S[y]!=S[x]) return S[x]<S[y];
    else return (L[x-1]+R[x-1])>>1<=(L[y-1]+R[y-1])>>1;
}
int rt;
void pushup(int u){
	if(u==0) return ;
	sz[u]=sz[ls[u]]+sz[rs[u]]+1;
}
mt19937 rd(time(0));
vector<int> vec;
int delet;
void dfs(int u){
	if(u==0) return ;
	dfs(ls[u]);
	if(u!=delet) vec.push_back(u);
	dfs(rs[u]);
	ls[u]=rs[u]=sz[u]=L[u]=R[u]=0;
	return ;
}
int build(int l,int r,long long lt,long long rt){
	if(l>r) return 0;
	if(l==r){
		sz[vec[l]]=1;
		L[vec[l]]=lt,R[vec[l]]=rt;
		return vec[l];
	}
	int mid=(l+r)>>1;
	long long Mid=(lt+rt)>>1;
	ls[vec[mid]]=build(l,mid-1,lt,Mid);
	rs[vec[mid]]=build(mid+1,r,Mid,rt);
	pushup(vec[mid]);
	L[vec[mid]]=lt,R[vec[mid]]=rt;
	return vec[mid];
}
int rebuild(int u,long long lt,long long rt){
	vec.clear();
	dfs(u);
	return build(0,vec.size()-1,lt,rt);
}
const int B = 10;
const double warma = 0.75;
void maintain(int &cur){
	if(sz[cur]<B) return ;
	if(max(sz[ls[cur]],sz[rs[cur]])*warma<=min(sz[ls[cur]],sz[rs[cur]])) return ;
	cur=rebuild(cur,L[cur],R[cur]);
}
void ins(int &cur,int u,long long lt,long long rt){
	if(cur==0){
		cur=u;
		L[cur]=lt,R[cur]=rt;
		sz[cur]=1;
		return ;
	}
	lt=L[cur],rt=R[cur];
	long long mid=(lt+rt)>>1;
	if(cmp(u,cur)==true){
		ins(ls[cur],u,lt,mid);
	}
	else{
		ins(rs[cur],u,mid,rt);
	}
	maintain(cur);
	pushup(cur);
	return ;
}
int move(int &cur,int u,long long lt,long long rt){
	lt=L[cur],rt=R[cur];
	if(rs[cur]==0){
		int res=cur;
		cur=ls[cur];
		return res;
	}
	long long mid=(lt+rt)>>1;
	int res=move(rs[cur],u,mid,rt);
	maintain(cur);
	pushup(cur);
	return res;
}
void del(int &cur,int u,long long lt,long long rt){	
	lt=L[cur],rt=R[cur];
    if(cur==u){
		if(ls[cur]==0){
			cur=rs[cur];
			L[u]=R[u]=sz[u]=ls[u]=rs[u]=0;			
		}else{
			long long mid=(lt+rt)>>1;
			int res=move(ls[cur],u,lt,mid);	
			swap(L[res],L[cur]);
			swap(R[res],R[cur]);
			swap(sz[res],sz[cur]);
			swap(ls[res],ls[cur]);
			swap(rs[res],rs[cur]);
			int cle=cur;
			cur=res;
			L[cle]=R[cle]=sz[cle]=ls[cle]=rs[cle]=0;
		}
		pushup(cur);
        return ;
    }
	long long mid=(lt+rt)>>1;
	if(cmp(u,cur)==true){
		del(ls[cur],u,lt,mid);
	}
	else{
		del(rs[cur],u,mid,rt);
	}
	maintain(cur);
	pushup(cur);
	return ;
}
int ask(int cur,string L){
	if(cur==0) return 0;
	bool flag=false;
	for(int j=cur,i=L.size()-1;;i--,j--){
		if(S[j]<L[i]){
			flag=true;
			break;
		}
		if(S[j]>L[i]){
			flag=false;
			break;
		}
	}
	if(flag==true){
		return 1+sz[ls[cur]]+ask(rs[cur],L);
	}else{
		return ask(ls[cur],L);
	}
}
int lst;
void f(string &s,int mask){
	for(int i=0;i<(int)s.size();i++)
		mask=(mask*131+i)%(int)s.size(),swap(s[i],s[mask]);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>q;
	string init;
	cin>>init;
	len=init.size();
	len++;
	S[1]='A'-1;
	for(int i=2;i<=len;i++) S[i]=init[i-2];
	for(int i=1;i<=len;i++) ins(rt,i,0,inf);
	while(q--){
		string opt,str;
		int ct;
		cin>>opt;
		if(opt=="ADD"||opt=="QUERY") cin>>str,f(str,lst);
		else cin>>ct;
		if(opt=="ADD"){
			for(char x:str){
				S[++len]=x;
				ins(rt,len,0,inf);
			}
		}else if(opt=="DEL"){
			for(int i=1;i<=ct;i++){
				del(rt,len,0,inf);
				len--;
			}
		}else{
			int ans=0;
			cout<<(ans=(ask(rt,(char)('Z'+1)+str)-ask(rt,(char)('A'-2)+str)))<<'\n';
			lst^=ans;
		}
	}
	return 0;
}
```

---

## 作者：L_zaa_L (赞：0)

我们模板题当然要使用后缀平衡树了。

## 原理
我们用平衡树上每个节点代表一个后缀，这个树肯定是一个二叉搜索树，然后对于每个节点都有一个权值，每个节点的左子树里面的所有权值小于这个节点的权值，右边的大于这个节点的权值。由此可以知道，我们的后缀平衡树每个节点的权值应该是这个节点所代表的后缀的字典序大小。然后我们往前面依次插入一个字符（相当于插入一个后缀），我们走到一个节点比较它和左右儿子字典序大小，看是在左右儿子哪一边，然后递归下去。

问题就来了，我们如何比较两个后缀的字典序大小呢，显然可以用二分哈希，但是加上平衡树的一个  不就有两只 $\log$ 了吗，所以我们考虑优化。我们仔细一想，发现后缀平衡树相当于给每个后缀进行排序，所以我们直接用后缀数组就行了，然后就可以比较大小了！！！

这，当然不对，我如果使用后缀数组，我要构建平衡树干什么，好看吗？转念一想，既然后缀数组和后缀平衡树的用法大致相同，那么我们也就可以模仿后缀数组的比较方式。然后回去看SA后缀数组学习笔记，发现后缀数组的比较方式是知道 $s[i,i+k-1]$ 和 $s[i+k,i+2\times k-1]$ 的排名，去得到 $s[i,i+2\times k-1]$ 的排名，也就是说我们是通过已知的排名可以得到新的排名，那么我们后缀平衡树似乎也可以用已知的排名得到新的排名，比如，我现在有两个以 $x,y$ 开头的后缀，我们首先比较 $S_x$ 和 $S_y$，然后如果相同，就比较 $x+1$ 和 $y+1$ 这两个后缀的值，因为我们是知道这两个值的大小关系的（是往前面加入的），所以直接可以比较出来了。如果想要往后面插就比较前缀就可以了（但这个就好像不能代替后缀数组了），不管你怎么插，只要比较的前一个东西是之前插过的且和它相连，你就可以比较了（树上的就是它的父亲）。

然后代码如下：
```cpp
inline int chk(int x,int y){
	if(s[x]>s[y]||s[x]==s[y]&&tr[x+1].v>tr[y+1].v)
		return 1;
	else if(s[x]==s[y]&&tr[x+1].v==tr[y+1].v)
		return 0;
	else return -1;
}
```

做题的时候要注意需要修改这个，然后这个每个点的大小关系，我们可以像线段树一样，将中间的设为 $\frac{(l+r)}{2}$，然后左儿子的值的范围为 $[l,\frac{(l+r)}{2})$，右儿子则为 $(\frac{(l+r)}{2},r]$，然后每次在插入的时候可以计算，有时候用 double 似乎更保险一些。

但同时我们为了保证树高为 $\log$，我们还需要进行旋转，然后权值在旋转过后遍历一遍重新分配就可以了（不会证明，但期望是 $O(\log n)$ 的）。

所以插入操作如下：
```cpp
inline void pushup(int x){
	tr[x].s=tr[ls(x)].s+tr[rs(x)].s+1;
}
void dfs(int x,ll l,ll r){
	tr[x].v=l+r>>1;
	if(ls(x))dfs(ls(x),l,tr[x].v-1);
	if(rs(x))dfs(rs(x),tr[x].v+1,r);
}
inline void zig(int &x,ll l,ll r){
	int q=ls(x);
	ls(x)=rs(q);
	rs(q)=x;
	pushup(x),pushup(q);
	dfs(q,l,r);x=q;
}
inline void zag(int &x,ll l,ll r){
	int q=rs(x);
	rs(x)=ls(q);
	ls(q)=x;
	pushup(x),pushup(q);
	dfs(q,l,r);x=q;
}
void ins(int &x,int p,ll l,ll r){
	if(!x){
		tr[p].l=tr[p].r=0;
		tr[p].key=rand();
		tr[p].v=(l+r)/2;
		tr[p].s=1;
		x=p;
		return ;
	}
	if(chk(x,p)>0){
		ins(ls(x),p,l,tr[x].v-1);
		pushup(x);
		if(tr[x].key>tr[ls(x)].key)
			zig(x,l,r);
	}
	else{
		ins(rs(x),p,tr[x].v+1,r);
		pushup(x);
		if(tr[x].key>tr[rs(x)].key)
			zag(x,l,r);
	}
}
```

删除就是找到那个位置，然后删掉，把两个子树合并到一起，然后再重构一边值。由于是平衡树，所以合并可以用  fhq Treap 的方式来写。

```cpp
int merge(int x,int y){
	if(!x||!y)return x|y;
	if(tr[x].key<tr[y].key){
		rs(x)=merge(rs(x),y);
		pushup(x);
		return x;
	}
	else{
		ls(y)=merge(x,ls(y));
		pushup(y);
		return y;
	}
}
void del(int &x,int p,ll l,ll r){
	if(!x)return;
	if(chk(x,p)==0){
		x=merge(ls(x),rs(x));
		if(x) dfs(x,l,r);
		return;
	}
	if(chk(x,p)>0)
		del(ls(x),p,l,tr[x].v-1);
	else del(rs(x),p,tr[x].v+1,r);
	pushup(x);
}
```

## 本题的做法

首先这个是往后面加入字符，所以我们的比较函数应该要进行更改。

然后现在我们每个节点代表一个字符串翻转之后的每个后缀，也就是翻转过的原字符串前缀。那么我们现在只需要比较需要查找的是具有询问串后缀的前缀，由于满足条件的字符串前缀都是一样的，所以我们可以知道它们在后缀平衡树上的大小应该是连续的，那么我们就可以找到最大的那个的排名，再找到最小的那个的排名，就可以计算出这个询问串出现的次数了，我们可以查找 $s$ 后面拼接一个字典序极小的字符，或和字典序极大的字符，算出两个串的排名，这个在平衡树上是很好求导的，然后相减即可。

```cpp
#include<bits/stdc++.h>
#define ll long long  
#define ls(x) (tr[x].l)
#define rs(x) (tr[x].r)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=8e5+5,base=999983,Mod=998244353;
const ll inf=1e16;
//char buf[(1<<21)+5],*p1,*p2;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
inline void Add(int &x,int y){(x=x+y+Mod)%=Mod;}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
void print(int n){
    if(n<0){
        putchar('-');
        n*=-1;
    }
    if(n>9) print(n/10);
    putchar(n%10+'0');
}
int n,m;
char s[N],op[11],t[N];
struct _Tree{
	ll v;
	int l,r,s,key;
};
struct SAT{
	_Tree tr[N];int rt;
	inline int chk(int x,int y){
		if(s[x]>s[y]||s[x]==s[y]&&tr[x-1].v>tr[y-1].v)
			return 1;
		else if(s[x]==s[y]&&tr[x-1].v==tr[y-1].v)
			return 0;
		else return -1;
	}
	inline void pushup(int x){
		tr[x].s=tr[ls(x)].s+tr[rs(x)].s+1;
	}
	void dfs(int x,ll l,ll r){
		tr[x].v=l+r>>1;
		if(ls(x))dfs(ls(x),l,tr[x].v-1);
		if(rs(x))dfs(rs(x),tr[x].v+1,r);
	}
	inline void zig(int &x,ll l,ll r){
		int q=ls(x);
		ls(x)=rs(q);
		rs(q)=x;
		pushup(x),pushup(q);
		dfs(q,l,r);x=q;
	}
	inline void zag(int &x,ll l,ll r){
		int q=rs(x);
		rs(x)=ls(q);
		ls(q)=x;
		pushup(x),pushup(q);
		dfs(q,l,r);x=q;
	}
int merge(int x,int y){
	if(!x||!y)return x|y;
	if(tr[x].key<tr[y].key){
		rs(x)=merge(rs(x),y);
		pushup(x);
		return x;
	}
	else{
		ls(y)=merge(x,ls(y));
		pushup(y);
		return y;
	}
}
	void ins(int &x,int p,ll l,ll r){
		if(!x){
			tr[p].l=tr[p].r=0;
			tr[p].key=rand();
			tr[p].v=(l+r)/2;
			tr[p].s=1;
			x=p;
			return ;
		}
		if(chk(x,p)>0){
			ins(ls(x),p,l,tr[x].v-1);
			pushup(x);
			if(tr[x].key>tr[ls(x)].key)
				zig(x,l,r);
		}
		else{
			ins(rs(x),p,tr[x].v+1,r);
			pushup(x);
			if(tr[x].key>tr[rs(x)].key)
				zag(x,l,r);
		}
	}
	void del(int &x,int p,ll l,ll r){
		if(!x)return;
		if(chk(x,p)==0){
			x=merge(ls(x),rs(x));
			if(x) dfs(x,l,r);
			return;
		}
		if(chk(x,p)>0)
			del(ls(x),p,l,tr[x].v-1);
		else del(rs(x),p,tr[x].v+1,r);
		pushup(x);
	}
	inline bool check(int x){
		for(int i=1,j=x;t[i];i++,j=j?j-1:0){
			if(t[i]<s[j]) return 1;
			if(t[i]>s[j]) return 0;
		}
	}
	int qry(int x){
		if(!x) return 0;
		if(check(x))
			return qry(ls(x));
		return qry(rs(x))+tr[ls(x)].s+1;
	}
}sat;
inline void gstr(char s[],int p){
    int len=strlen(s);
    For(i,0,len-1){
        p=(p*131+i)%len;
        swap(s[i],s[p]);
    }
}
signed main(){
//	freopen("P6164_1.in","r",stdin);
//	freopen(".out","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	srand(time(0));
	int Q=read();scanf("%s",s+1);
	int n=strlen(s+1);
	For(i,1,n)sat.ins(sat.rt,i,1,inf);
	int mask=0;
	while(Q--){
		scanf("%s",op);
        if(op[0]=='A'){
        	scanf("%s",t+1);
			gstr(t+1,mask);
			int len=strlen(t+1);
			For(i,1,len){
				s[++n]=t[i];
				sat.ins(sat.rt,n,1,inf);
			}
		}
        else if(op[0]=='D'){
        	int x=read();
        	Rof(i,n,n-x+1)
				sat.del(sat.rt,i,1,inf);
			n-=x;
		}
        else{
        	scanf("%s",t+1);
			gstr(t+1,mask);
			int len=strlen(t+1);
			reverse(t+1,t+len+1);
			t[len+1]='Z'+1;t[len+2]=0;
			int ans=sat.qry(sat.rt);
			t[len]--;
			ans-=sat.qry(sat.rt);
			mask^=ans;
			printf("%d\n",ans);
		}
	}
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：yangdezuo (赞：0)

## 题意：
给定初始字符串 s 和 q 个操作：

在当前字符串的后面插入若干个字符。
在当前字符串的后面删除若干个字符。
询问字符串 t 作为连续子串在当前字符串中出现了几次？
题目 强制在线，字符串变化长度以及初始长度 $\le 8 \times 10^5$，$q \le 10^5$，询问的总长度 $\le 3 \times 10^6$。

对于操作 1 和操作 2，由于后缀平衡树维护头插和头删操作比较方便，所以想到把尾插和尾删操作搞成头插和头删。这里如果维护 s 的反串的后缀平衡树，而非 s 的后缀平衡树，就可以完成上述转换。平衡树的添加和删除都是 $O(\log n)$ 的，所以添加或者删除一个字符的时间复杂度为 $O(\log n)$。记添加和删除的总字符数为 N，那么这一部分总的时间复杂度为 $O(N \log n)$。

对于操作 3，t 的出现次数等于以 t 为前缀的后缀数量，而以 t 为前缀的后缀数量等于其后继的排名减去其前驱的排名。在 t 后面加入一个极大的字符，就可以构造出 t 的一个后继。将 t 的最后一个字符减小 1，就可以构造出 t 的一个前驱。

现在要查询某一个串 t 在后缀平衡树中排名，由于不能保证 t 在后缀平衡树中出现过，所以每次只能暴力比较字符串大小。单次比较的时间复杂度为 $O(|t|)$，每次查询至多比较 $O(\log n)$ 次，所以单次查询的复杂度为 $O(|t|\log n)$。记所有询问串的长度和为 L，那么这一部分总的时间复杂度为 $O(L \log n)$。

## 接下来贴上 SGT 版本的参考代码


```cpp
#include <bits/stdc++.h>//万能头
using namespace std;

const int N = 8e5 + 5;
const double INF = 1e18;

void decode(char* s, int len, int mask) {
  for (int i = 0; i < len; ++i) {
    mask = (mask * 131 + i) % len;
    swap(s[i], s[mask]);
  }
}

int q, n, na;
char a[N], t[N];

// SuffixBST(SGT Ver)

// 顺序加入，查询时将询问串翻转
// 以i结束的前缀，对应节点的编号为i
// 注意：不能写懒惰删除，否则可能会破坏树的结构
const double alpha = 0.75;
int root;
int sz[N], L[N], R[N];
double tag[N];
int buffer_size, buffer[N];

bool cmp(int x, int y) {
  if (t[x] != t[y]) return t[x] < t[y];
  return tag[x - 1] < tag[y - 1];
}

void init() { root = 0; }

void new_node(int& rt, int p, double lv, double rv) {
  rt = p;
  sz[rt] = 1;
  tag[rt] = (lv + rv) / 2;
  L[rt] = R[rt] = 0;
}

void push_up(int x) {
  if (!x) return;
  sz[x] = sz[L[x]] + 1 + sz[R[x]];
}

bool balance(int rt) { return alpha * sz[rt] > max(sz[L[rt]], sz[R[rt]]); }

void flatten(int rt) {
  if (!rt) return;
  flatten(L[rt]);
  buffer[++buffer_size] = rt;
  flatten(R[rt]);
}

void build(int& rt, int l, int r, double lv, double rv) {
  if (l > r) {
    rt = 0;
    return;
  }
  int mid = (l + r) >> 1;
  double mv = (lv + rv) / 2;

  rt = buffer[mid];
  tag[rt] = mv;
  build(L[rt], l, mid - 1, lv, mv);
  build(R[rt], mid + 1, r, mv, rv);
  push_up(rt);
}

void rebuild(int& rt, double lv, double rv) {
  buffer_size = 0;
  flatten(rt);
  build(rt, 1, buffer_size, lv, rv);
}

void insert(int& rt, int p, double lv, double rv) {
  if (!rt) {
    new_node(rt, p, lv, rv);
    return;
  }

  if (cmp(p, rt))
    insert(L[rt], p, lv, tag[rt]);
  else
    insert(R[rt], p, tag[rt], rv);

  push_up(rt);
  if (!balance(rt)) rebuild(rt, lv, rv);
}

void remove(int& rt, int p, double lv, double rv) {
  if (!rt) return;

  if (rt == p) {
    if (!L[rt] || !R[rt]) {
      rt = (L[rt] | R[rt]);
    } else {
      // 找到rt的前驱来替换rt
      int nrt = L[rt], fa = rt;
      while (R[nrt]) {
        fa = nrt;
        sz[fa]--;
        nrt = R[nrt];
      }
      if (fa == rt) {
        R[nrt] = R[rt];
      } else {
        L[nrt] = L[rt];
        R[nrt] = R[rt];
        R[fa] = 0;
      }
      rt = nrt;
      tag[rt] = (lv + rv) / 2;
    }
  } else {
    double mv = (lv + rv) / 2;
    if (cmp(p, rt))
      remove(L[rt], p, lv, mv);
    else
      remove(R[rt], p, mv, rv);
  }

  push_up(rt);
  if (!balance(rt)) rebuild(rt, lv, rv);
}

bool cmp1(char* s, int len, int p) {
  for (int i = 1; i <= len; ++i, --p) {
    if (s[i] < t[p]) return true;
    if (s[i] > t[p]) return false;
  }
  return false;
}

int query(int rt, char* s, int len) {
  if (!rt) return 0;
  if (cmp1(s, len, rt))
    return query(L[rt], s, len);
  else
    return sz[L[rt]] + 1 + query(R[rt], s, len);
}

void solve() {
  n = 0;
  scanf("%d", &q);
  init();

  scanf("%s", a + 1);
  na = strlen(a + 1);
  for (int i = 1; i <= na; ++i) {
    t[++n] = a[i];
    insert(root, n, 0, INF);
  }

  int mask = 0;
  char op[10];
  for (int i = 1; i <= q; ++i) {
    scanf("%s", op);

    // 三种情况分别处理

    if (op[0] == 'A') {  // ADD
      scanf("%s", a + 1);
      na = strlen(a + 1);
      decode(a + 1, na, mask);

      for (int i = 1; i <= na; ++i) {
        t[++n] = a[i];
        insert(root, n, 0, INF);
      }
    } else if (op[0] == 'D') {  // DEL
      int x;
      scanf("%d", &x);
      while (x) {
        remove(root, n, 0, INF);
        --n;
        --x;
      }
    } else if (op[0] == 'Q') {  // QUERY
      scanf("%s", a + 1);
      na = strlen(a + 1);
      decode(a + 1, na, mask);

      reverse(a + 1, a + 1 + na);

      a[na + 1] = 'Z' + 1;
      a[na + 2] = 0;
      int ans = query(root, a, na + 1);

      --a[na];
      ans -= query(root, a, na + 1);

      printf("%d\n", ans);
      mask ^= ans;
    }
  }
}

int main() {
  solve();
  return 0;//结束
}
```


---


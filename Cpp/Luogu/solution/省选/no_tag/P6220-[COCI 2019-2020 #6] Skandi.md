# [COCI 2019/2020 #6] Skandi

## 题目背景

题目翻译来自 [LOJ3269](https://loj.ac/problem/3269) 。


**由于洛谷评测机原因，数据有删改。**

## 题目描述

**译自 [COCI 2019/2020 Contest #6](https://hsin.hr/coci/archive/2019_2020/) T4.** ***[Skandi](https://hsin.hr/coci/archive/2019_2020/contest6_tasks.pdf)***

Dragica 不仅是当地的一个半专业保龄球队的队长，还是一位充满激情的厨师。除此之外，他还是克罗地亚数一数二的填字游戏（crossword）玩家。填字游戏是一个在 $N\times M$ 的网格上游玩的游戏。在游戏开始前，部分格子已经填上了字母，作为至多两题的起点，而玩家需要根据给出的提示以水平向右或竖直向下的方向在剩下的格子填上答案。在这里，一题的答案定义为从该题起点沿提示指定方向直至网格边界或另一题起点之前的部分。如果一题的起点右边一格是空的，则该题在水平方向上存在一题；类似的，如果一题的下面一格是空的，则该题在竖直方向上存在一题。

Dragica 当然知道答案啦，但他有点鸽，想让你帮他找出完成某个填字游戏最少回答的题目数。

## 说明/提示

#### 样例 $3$ 解释：
下图展示了样例中的填词游戏，其中黑色的格子表示开始时已经填了字符的格子，在图下方所示的表中你可以看到给出的横着填和竖着填的提示。注意，已经填了字符的格子可以是零题、一题（例如第 $8$ 和 $13$ 题）或两题（例如第 $10$ 和 $12$）题的起点。要解出它，你至少需要知道 $14$ 题的答案，试试看看你会吗？~~（疑问语气）~~

*译者注：以下图片经过高清重制。中文的 crossword 没啥意义，就不翻译了。*

![](https://cdn.luogu.com.cn/upload/image_hosting/d7w61uk7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/4spl87ov.png)

-----


#### 数据范围：

对于 $100\%$ 的数据，有 $2\le N,~M\le 500$。

各子任务限制见下表：

|子任务|分值|特殊限制|
|:-:|:-:|:-:|
|1|16|至多 $9$ 个格子开始前填了字符|
|2|30|$N\le 500,~M\le 10$|
|3|54|无特殊限制|

## 样例 #1

### 输入

```
4 5
11111
10000
10000
10000```

### 输出

```
3
2 1 DESNO
3 1 DESNO
4 1 DESNO```

## 样例 #2

### 输入

```
6 4
1111
1011
1000
1011
1010
1000```

### 输出

```
4
1 2 DOLJE
4 4 DOLJE
5 3 DOLJE
3 1 DESNO```

## 样例 #3

### 输入

```
9 8
11111111
10000000
10001000
10010001
11100001
10100110
10001000
10100001
10010001```

### 输出

```
14
5 2 DOLJE
5 8 DOLJE
8 3 DOLJE
2 1 DESNO
3 1 DESNO
3 5 DESNO
4 1 DESNO
4 4 DESNO
5 3 DESNO
6 3 DESNO
7 1 DESNO
7 5 DESNO
8 3 DESNO
9 4 DESNO```

# 题解

## 作者：Night_Bringer (赞：4)

# 前言
~~博主很笨~~ ，如有纰漏，欢迎在评论区指出讨论。

二分图的最大匹配使用 $Dinic$ 算法进行实现，时间复杂度为 $O(n\sqrt{e})$，其中， $n$为二分图中左部点的数量， $e$ 为二分图中的边数。若是匈牙利算法，时间复杂度为 $O(nm)$ ， $m$ 为二分图中右部点的数量，不建议使用。

[博客园食用更佳](https://www.cnblogs.com/C202202chenkelin/p/14437260.html)
# König定理
定理内容：二分图最小点覆盖的点的数量**等于**二分图最大匹配的边的数量。

构造方法 $+$ 简单证明：

首先求出二分图中的最大匹配，建议使用 $Dinic$ 。

从每一个非匹配点出发，沿着非匹配边正向进行遍历，沿着匹配边反向进行遍历到的点进行标记。选取左部点中没有被标记过的点，右部点中被标记过的点，则这些点可以形成该二分图的最小点覆盖。

遍历代码实现如下：
```cpp
void dfs(int now) {
	vis[now] = true;
	int SIZ = v[now].size();
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i].to;
		if(vis[next] || !v[now][i].val)//正向边的容量为0说明是匹配边，反向边的容量为0说明是非匹配边
			continue;
		dfs(next);
	}
}
```
那么就有以下性质：

* 若该点为左边的非匹配点，则这个点必被访问，因为这个点是整个 $dfs$ 的起点
* 若该点为右边的非匹配点，则这个点必不会被访问，若是由左边的非匹配点才到达了这个点，那么可以将这条边变为匹配边，则匹配数 $+1$ ，与最大匹配相冲突。若是左边的匹配点才到达了这个点，那么这个点的路径为**左边非匹配点** → **右边匹配点** → **左边非匹配点** → **右边匹配点** →  **……** → **左边匹配点** → **右边非匹配点** ，很明显，上述路径为增广路，与最大匹配相冲突。所以，右边的非匹配点必不会被访问。
* 对于一组匹配点，要么两个都被标记，要么都不被标记。因为左部的匹配点是由右部的匹配点来遍历到的，出现必然成双成对。

有了上述的三条性质，可以发现：按照选取左部点中没有被标记过的点，右部点中被标记过的点的规则，选出来的点的点数必然为最大匹配的边数。左部的非匹配点必然被访问，则必不会被选，右部的非匹配点必不会被访问，则必不会被选。而第三条性质决定了，对于一组匹配点，会选择有且仅有一个点。故而选出的点的点数等于最大匹配的边数。

其次需要解决一个问题：保证这些点覆盖了所有的边。具体可以分为四类：
* 左部为非匹配点，右部为非匹配点。性质二已经讨论过，不可能出现这种情况，出现就不满足最大匹配的前提。
* 左部为匹配点，右部为非匹配点。同理性质二，路径类似，会出现增广路，那么这个左部的匹配点一定没有被访问过，必然被选。
* 左部为匹配点，右部为匹配点。一对匹配点中必选一个。
* 左部为非匹配点，右部为匹配点。这条边为非匹配边，而起点就是从左部的非匹配点点开始，那么右部的这个点必然被访问过，必然被选。

最后在确保这是最小的方案：反证法，少选一个点，那么至少有一条匹配边会被不选，不满足点覆盖的定义，矛盾。也就是说，至少每一条匹配边都需要选一个点。

如上，证毕。

题目来源：[COCI 2019/2020 Contest #6](https://hsin.hr/coci/archive/2019_2020/) T4.  [Skandi](https://hsin.hr/coci/archive/2019_2020/contest6_tasks.pdf)
# 题目大意
给定一个 $n\times m$ 的矩阵，其中的白色点为 $0$ ， 黑色点为 $1$ 。黑色点可以往下一直扩展到底部，把白色点变成蓝色点，直到遇到黑色点为止。同理，也可向右扩展。问整个矩阵经过最小多少次扩展才能扩展为整个矩阵到不存在白色，并打印出每次扩展是从哪个点开始的，并打印出扩展方向。题目满足第一行第一列一定为黑色点。
# 思路
一道建模题。

一个白色点变为蓝色点只有两种方法，从它上方或左方的黑色点扩展而来，且只需要一个点扩展即可。可以考虑到最小点覆盖问题。

由于对于一个黑色点来说，它可以往右或往下扩展。那么它就有两个身份，也就是说一个点拥有两个编号。一个编号为把整个矩阵拉成一条链的顺序，另一个编号为前一个编号 $+n\times m$ ，这样不会发生冲突。获得编号的函数：
```cpp
int GetHash(int i, int j) {
	return (i - 1) * m + j;
}
```
那么不难发现一个白色点，与其相关的是一个编号 $\leqslant n\times m$ 的点，和一个编号 $>n\times m$ 的点。把这两个点连接起来，就是一张二分图。

问题就转换为找这张图的最小点覆盖问题。使用 $Dinic$ ，在根据上述 $König$ 定理构造即可。

边数为白点的个数，左部点为黑点的个数，则时间复杂度为 $O(nm\sqrt{nm})$ ，即 $O(n^{\frac{3}{2}}m^{\frac{3}{2}})$  ，本题的 $n$ ， $m$ 均小于 $500$ ，大概能够在 $1s$ 内求出答案。
# C++代码
```cpp
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
using namespace std;
#define INF 0x3f3f3f3f
const int MAXN = 1e6 + 5;
const int MAXM = 5e2 + 5;
struct Node {
	int to, val, rev;//依次为：下一个点，边的容量，相反的边的编号
	Node() {}
	Node(int T, int V, int R) {
		to = T;
		val = V;
		rev = R;
	}
};
vector<Node> v[MAXN];//用vector存图的癖好...
int dn[MAXN], rt[MAXN];//预处理白色点可以右那两个点扩展而来
queue<int> q;
int de[MAXN], be[MAXN];
int twin[MAXN];
bool vis[MAXN];
int n, m, s, t;
int arr[MAXM][MAXM];
bool bfs() {//将残量网络分层
	bool flag = 0;
	memset(de, 0, sizeof(de));
	while(!q.empty())
		q.pop();
	q.push(s);
	de[s] = 1; be[s] = 0;
	while(!q.empty()) {
		int now = q.front();
		q.pop();
		int SIZ = v[now].size();
		for(int i = 0; i < SIZ; i++) {
			int next = v[now][i].to;
			if(v[now][i].val && !de[next]) {
				q.push(next);
				be[next] = 0;
				de[next] = de[now] + 1;
				if(next == t)
					flag = 1;
			}
		}
	}
	return flag;
}
int dfs(int now, int flow) {//沿着增广路增广
	if(now == t || !flow)
		return flow;
	int i, surp = flow;
	int SIZ = v[now].size();
	for(i = be[now]; i < SIZ && surp; i++) {
		be[now] = i;
		int next = v[now][i].to;
		if(v[now][i].val && de[next] == de[now] + 1) {
			int maxnow = dfs(next, min(surp, v[now][i].val));
			if(!maxnow)
				de[next] = 0;
			v[now][i].val -= maxnow;
			v[next][v[now][i].rev].val += maxnow;
			surp -= maxnow;
		}
	}
	return flow - surp;
}
int Dinic() {//网络最大流，亦可用于二分图匹配
	int res = 0;
	int flow = 0;
	while(bfs())
		while(flow = dfs(s, INF))
			res += flow;
	return res;
}
int GetHash(int i, int j) {//获取点的编号
	return (i - 1) * m + j;
}
void Down(int now, int i, int j) {//黑点向下扩展，每个白点最多遍历到一次
	if(i != now)
		dn[GetHash(now, j)] = GetHash(i, j);
	if(arr[now + 1][j] == 2)
		Down(now + 1, i, j);
} 
void Right(int now, int i, int j) { //黑点向右扩展，每个白点最多遍历到一次
	if(j != now)
		rt[GetHash(i, now)] = GetHash(i, j) + n * m;
	if(arr[i][now + 1] == 2)
		Right(now + 1, i, j);
}
void GetMin(int now) {//dfs求构造方式
	vis[now] = true;
	int SIZ = v[now].size();
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i].to;
		if(vis[next] || !v[now][i].val)
			continue;
		GetMin(next);
	}
}
int main() {
	scanf("%d %d", &n, &m);
	s = 0; t = 2 * n * m + 1;//源点和汇点初始化
	char ch;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			cin >> ch;
			if(ch == '1')
				arr[i][j] = 1;
			else
				arr[i][j] = 2;
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(i == 1 && j == 1)
				continue;
			if(arr[i][j] == 1) {//向右或向下扩展，一个白点会被访问2次
				Down(i, i, j);
				Right(j, i, j);
			}
		}
	}
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			if(arr[i][j] == 1) {//源点到左部点，汇点到右部点连边
				int now = GetHash(i, j);
				int idnow = v[now].size();
				int ids = v[s].size();
				v[s].push_back(Node(now, 1, idnow));
				v[now].push_back(Node(s, 0, ids));
				now = GetHash(i, j) + n * m;
				idnow = v[now].size();
				int idt = v[t].size();
				v[now].push_back(Node(t, 1, idt));
				v[t].push_back(Node(now, 0, idnow));
			}
		}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(i == 1 && j == 1)
				continue;
			if(arr[i][j] == 1)
				continue;
			int A = dn[GetHash(i, j)];//左部点到右部点连边
			int B = rt[GetHash(i, j)];
			int idA = v[A].size();
			int idB = v[B].size();
			v[A].push_back(Node(B, 1, idB));
			v[B].push_back(Node(A, 0, idA));
		}
	}
	printf("%d\n", Dinic());
	GetMin(s);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(arr[i][j] == 2)
				continue;
			if(!vis[GetHash(i, j)])//打印答案
				printf("%d %d DOLJE\n", i, j);
			if(vis[GetHash(i, j) + n * m])
				printf("%d %d DESNO\n", i, j);
		}
	}
	return 0;
}
```

---

## 作者：ClearluvXL (赞：1)

# Skandi

## 题目解读

这个题目的解释简直是依托答辩啊。

其实就是，现在给一张 $n\times m$ 的矩阵。其中是 1 的点可以向右扩张 1，也可以向下扩张 1，直到跑到边界或者遇到另一个原本是 1 的点，就停止。问最少需要多少次操作可以把整个图全部变成 1。给出数据保证一定有解。

## 思路

很明显，每一个是 0 的点最多只会被两种情况染色，从左和从上。那么我们假设这个点从左边会被第 $i$ 个点染色，向上会被第 $j$ 个点染色。那么我们将 $i,j$ 连一个边。左边的点放左边，上面的点放右边的话，那么这道题就变成了一个最小点覆盖的问题了。

为什么是一个最小点覆盖的问题呢？其实我们每一条边都代表了一个 0 格，那么要求使用最小的操作来使得全图变 1，不就是使得每一条边至少有一个端点被选上的最小选择方案吗？所以这题是一个最小点覆盖。

根据一个著名的定理，**二分图的最小点覆盖 = 二分图的最大匹配**。所以此时就能得出操作最少的次数了。

麻烦的是输出方案。也就是最小的点覆盖集合。

那么先求出二分图的最大匹配。

然后，按照求最小点覆盖的方式，将左侧没有匹配的点再求一次增广路，并标记路途中的点。左边没有被标记的点和右边标记了的点即为最小点覆盖中的点。

最小点覆盖集中左边的点，对应操作为 `DESNO`。右边的点，对应操作为 `DOLJE`。

所以建议先去预习或者打一遍最大匹配和求最小点覆盖的板子。

## 代码

```c++
#include<bits/stdc++.h>
#define endl '\n' 

using namespace std;

const int N=510;
const int INF=0x3f3f3f3f;

typedef long long ll;
typedef pair<int,int> pii;

int n,m;
int a[N][N];

int id(int x,int y){
	return (x-1)*m+y;
}//end

int l[N][N],up[N][N];

vector<int> e[N*N];

void add(int u,int v){
	e[u].push_back(v);
}//end

void build(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]==0) continue;
			int pos=j;
			while(j<m&&a[i][j+1]==0){
				++j;
				l[i][j]=id(i,pos);
			}
		}
	}
	for(int j=1;j<=m;j++){
		for(int i=1;i<=n;i++){
			if(a[i][j]==0) continue;
			int pos=i;
			while(i<n&&a[i+1][j]==0){
				++i;
				up[i][j]=id(pos,j);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]==1) continue;
			add(l[i][j],up[i][j]);
		}
	}
}//end

int visl[N*N],visr[N*N],nowidx;
int match[N*N];

bool mat[N*N];//左边匹配点 

bool dfs(int x){
	visl[x]=nowidx;
	for(int y:e[x]){
		if(visr[y]==nowidx) continue;
		visr[y]=nowidx;
		if(!match[y]||dfs(match[y])){
			match[y]=x;
			return true; 
		}
	}
	return false;
}//end

map<int,string> ys;

int main(){
	ios::sync_with_stdio(0);
	
	ys[0]="DESNO"; ys[1]="DOLJE";
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char x; cin>>x;
			a[i][j]=x-'0';	
		}
	} 
	
	build();
	
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			++nowidx;
			if(dfs(id(i,j))){
				ans++;
				mat[id(i,j)]=1;
			}
		}
	}
	
	cout<<ans<<endl;
	
	++nowidx;
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!mat[id(i,j)]){
				dfs(id(i,j));
			}
		}
	}
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int nowid=id(i,j);
			if(visl[nowid]!=nowidx){
				cout<<i<<" "<<j<<" "<<ys[0]<<endl;
			}
			if(visr[nowid]==nowidx){
				cout<<i<<" "<<j<<" "<<ys[1]<<endl;
			}
		}
	}
	
	
	return 0;
}//end
```

---

## 作者：Violet___Evergarden (赞：1)

建议评紫。

# 简述题意

有一个 $n$ 行 $m$ 列的矩阵，每个格子上有数字 $0$ 或 $1$，每一个 $1$ 可以选择右边和下面任意一个方向扩展把 $0$ 变成 $1$，直到碰到另一个 $1$。问把所有 $0$ 变成 $1$ 的方案数。

# 分析

考虑每一个 $1$ 怎么扩展很麻烦，可以考虑每一个 $0$ 被哪个 $1$ 从哪个方向扩展。

你会发现这个很容易求，并且每一个 $0$ 只有两种情况，可以联想到二分图。

以两个方向为界限建立二分图，设 $i$ 点向下，$j$ 点向右都可以扩展到某个 $0$，那么我们把 $i$ 放左边，$j$ 放右边，并且给这两个点连一条边。

这样，只要每条边的两个点任意选一个，所有的 $0$ 就都可以变成一。

那么就转化为求最小覆盖了。

# 细节

因为这是一个二维矩阵，每一个点用一个二维数对表示很麻烦，可以从左到右、从上到下给每个点编号，那么 $(i,j)$ 的号码就是 $ i \times (m-1) + j$。

这里我用的是匈牙利算法，其中的 $vis$ 数组在每次清零时很慢，可以每次匹配时设一个参数 $now$。如果遍历到一个点，那么 $vis\gets now$，判断有没有来过也就看 $vis$ 是否等于 $now$。

求最小覆盖的方案时，我们可以把左边没有配对的点选出来。左边有配对的点和右边链接了左边没有配对的点的点就是答案。左边的点就往下走，右边的点有往右走。
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
const int kMaxN=501;
bool mp[kMaxN][kMaxN];
vector<int>v[kMaxN*kMaxN];
int n,m,now,ans,vis[kMaxN*kMaxN],visr[kMaxN*kMaxN],match[kMaxN*kMaxN],num;
bool ma[kMaxN*kMaxN],choose[kMaxN*kMaxN];//分别表示左边的点是否配对上、二分图中是否有这个点
int Id(int x,int y)//得到数对的编号
{
  return (x-1)*m+y;
}
bool Dfs(int x)//匈牙利算法
{
  if(vis[x]==now)return false;
  vis[x]=now;
  for(int i=0;i<v[x].size();i++)
  {
    visr[v[x][i]]=now;
    if(!match[v[x][i]]||Dfs(match[v[x][i]]))
    {
      match[v[x][i]]=x;
      return true;
    }
  }
  return false;
}
void Match()
{
  for(int i=1;i<=Id(n,m);i++)
  {
    now=i;
    if(Dfs(i))
    {
      ans++;
      ma[i]=true;
    }
  }
}
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)
{
  for(int j=1;j<=m;j++)
  {
    char c;
    cin>>c;
    mp[i][j]=c-'0';
  }
}
for(int i=1;i<=n;i++)
{
  for(int j=1;j<=m;j++)
  {
    if(!mp[i][j])
    {
      int x,y;
      for(int k=i;k>=1;k--)//求每个 0 被哪个点扩展
      {
        if(mp[k][j])
        {
          x=Id(k,j);
          break;
        }
      }
      for(int k=j;j>=1;k--)
      {
        if(mp[i][k])
        {
          y=Id(i,k);
          break;
        }
      }
      v[x].push_back(y);//链接它们
      choose[x]=choose[y]=true;//标记这两个点在二分图里面
    }
  }
}
Match();
cout<<ans<<"\n";
++now;
for(int i=1;i<=Id(n,m);i++)
{
  if(!ma[i])
  {
    Dfs(i);
  }
}
for(int i=1;i<=n;i++)
{
  for(int j=1;j<=m;j++)
  {
    int id=Id(i,j);
    if(choose[id]&&vis[id]!=now)//左边有配对
    {
      cout<<i<<" "<<j<<" "<<"DOLJE\n";
    }
    if(choose[id]&&visr[id]==now)//右边被左边没有配对的点链接
    {
      cout<<i<<" "<<j<<" "<<"DESNO\n";
    }
  }
}
return 0;
}
```
# 关于时间复杂度

匈牙利算法的本身最劣时间复杂度为 $ O(n\times(n+m))$，$n$ 为点数，$m$ 为边数，在完全图中则为 $ O(n^3)$。但大多数情况下，每次配对的时候不会全部把点遍历一遍，所以复杂度跑不满。这也是为什么上面我们要这么处理 $vis$ 数组，~~不然时间复杂度卡满~~。

---

## 作者：Z1qqurat (赞：0)

可以说是最小点覆盖输出方案板题。

我们现在需要将所有没填字母的格子用单词覆盖。每个已有的字母最多为两个单词的起点，横着的或者竖着的。所以说每个格子有两种被覆盖的方案。枚举这两种方案，选取起点的位置为方案的编号。问题是每个有字母的点是两个单词的起点，所以我们将从点 $(x, y)$ 开始向右的单词编号命为 $(x - 1) \times m + y$，向下的单词为 $(x - 1) \times m + y + n \times m$。然后每个需要被覆盖的点我们将它的两种覆盖方案连边，跑最大匹配求最小点覆盖。

问题来了，怎么输出方案捏？对于已经求出的最大匹配，从一个未在匹配内的左部点出发，找长度为偶数的交错路径（即未匹配边和匹配边交替出现的路径），将路径上所有经过的点打上标记，那么方案就是未被标记的左部点和被标记的右部点。

纯野生代码，请放心食用。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <set>
#define ll long long
using namespace std;
const int N = 505, M = 5e5 + 5;
int n, m, px[M], py[M], vis[M], chs[M];
char c[N][N];
vector <int> G[M], pr[N][N];

int DESNO(int x, int y) {
    return (x - 1) * m + y;
}

int DOJLE(int x, int y) {
    return (x - 1) * m + y + n * m;
}

bool Hungary(int u, int tim) {
    for (int i = 0; i < G[u].size(); ++i) {
        int v = G[u][i];
        if(vis[v] == tim) continue;
        vis[v] = tim;
        if(!py[v] || Hungary(py[v], tim)) {
            py[v] = u, px[u] = v;
            return 1;
        }
    }
    return 0;
}

void dfs(int u, int col) {
    chs[u] = col;
    if(col == 1) { // 1 代表不需要
        for (int i = 0; i < G[u].size(); ++i) {
            int v = G[u][i];
            if(chs[v] == 0 && py[v] && py[v] != u) {
                dfs(v, 3 - col);
            }
        }
    }
    else {
        dfs(py[u], 3 - col);
        // else dfs(py[u], 3 - col);
    }
    return ;
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> c[i][j];
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if(c[i][j] == '0') continue;
            int lef = DESNO(i, j), dow = DOJLE(i, j);
            for (int k = j + 1; k <= m; ++k) {
                if(c[i][k] == '1') break;
                else pr[i][k].push_back(lef);
            }
            for (int k = i + 1; k <= n; ++k) {
                if(c[k][j] == '1') break;
                else pr[k][j].push_back(dow);
            }
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if(c[i][j] == '1') continue;
            if(pr[i][j].size() == 2) {

                G[pr[i][j][0]].push_back(pr[i][j][1]);
                G[pr[i][j][1]].push_back(pr[i][j][0]);
            }
            else {
                // puts("qwq");
                G[pr[i][j][0]].push_back(pr[i][j][0]);
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n * m; ++i) {
        ans += Hungary(i, i);
    }
    cout << ans << "\n";
    for (int i = 1; i <= n * m; ++i) {
        if(!px[i]) {
            dfs(i, 1);
        }
    }
    for (int i = n * m + 1; i <= 2 * n * m; ++i) {
        if(chs[i] == 2) {
            int ii = i - n * m, x, y;
            x = ii / m + 1;
            y = ii % m;
            if(y == 0) x--, y = m;
            cout << x << ' ' << y << " DOLJE\n";
        }
    }
    for (int i = 1; i <= n * m; ++i) {
        if(px[i] && chs[i] != 2 && chs[px[i]] != 2) {
            int x, y;
            x = i / m + 1;
            y = i % m;
            if(y == 0) x--, y = m;
            cout << x << ' ' << y << " DESNO\n"; 
        }
    }
    return 0;
}
```

---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16361957.html)

关键是输出方案。

# 题目大意

给定一个 $n\times m$ 的矩阵，其中的白色点为 $0$，黑色点为 $1$。黑色点可以往下一直扩展到底部，把白色点变成蓝色点，直到遇到黑色点为止。同理，也可向右扩展。

问整个矩阵经过最小多少次扩展才能扩展为整个矩阵到不存在白色，并打印出每次扩展是从哪个点开始的，并打印出扩展方向。题目满足第一行第一列一定为黑色点。

# 题目分析

对于每一个白色点，一定是由两个方向走过来的让它变成蓝色的，故不妨对以这两个方向建立二分图。把向下的放在左边，向右走的放在右边，找到最先开始的两个黑点进行连边。这两个黑点任选一个就可以使得这个白色点变成蓝色，所以题目转化为求最小点覆盖问题。

根据 $\rm König$ 定理可知（[link](https://www.matrix67.com/blog/archives/116/)）最小点覆盖数就等于最大匹配数。因此我们通过匈牙利算法求出最大匹配数即可。

而较麻烦的是输出方案。

----

先求出二分图的最大匹配，记录下左部点中在匹配中的点。随后，从每一个 **未** 在匹配中的左部点出发，按照未匹配边 $\to$ 匹配边 $\to$ 未匹配边 $\to\cdots\to$ 匹配边的顺序遍历。注意到最后一条边必为匹配边，否则这就是一条增广路了。那么记录途中经过的左部点和右部点。

最后答案就是未被标记的左部点和被标记的右部点。

# 代码

```cpp
// Problem: P6220 [COCI 2020.3]Skandi
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6220
// Memory Limit: 250 MB
// Time Limit: 5000 ms
// Date:2022-06-09 20:27
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	inline int read() {
		int ret = 0,f = 0;char ch = getchar();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getchar();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getchar();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getchar();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getchar();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 505,M = 505;
struct Graph {
	int v,nxt;
} gra[N * M];
int head[N * M],matr[N * M],visl[N * M],visr[N * M];
bool mat[N * M],maps[N][M];
int n,m,idx,nowidx;
inline int getid(int x,int y) {
	return (x - 1) * m + y;
}
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline bool dfs(int now) {
	visl[now] = nowidx;
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (visr[v] != nowidx) {
			visr[v] = nowidx;
			if (!matr[v] || dfs(matr[v])) {
				matr[v] = now;
				return true;
			}
		}
	}
	return false;
}
int main(void) {
	scanf("%d%d",&n,&m);
	for (register int i = 1;i <= n; ++ i) {
		char s[M];
		scanf("%s",s + 1);
		for (register int j = 1;j <= m; ++ j) {
			maps[i][j] = s[j] - '0';
		}
	}
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			if (!maps[i][j]) {
				int u,v;
				for (register int k = i;k; -- k) {
					if (maps[k][j]) {
						u = getid(k,j);
						break;
					}
				}
				for (register int k = j;k; -- k) {
					if (maps[i][k]) {
						v = getid(i,k);
						break;
					}
				}
				add(u,v);
			}
		}
	}
	int ans(0);
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			nowidx ++;
			if (dfs(getid(i,j))) {
				ans ++;
				mat[getid(i,j)] = true;
			}
		}
	}
	printf("%d\n",ans);
	nowidx ++;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			if (!mat[getid(i,j)]) {
				dfs(getid(i,j));
			}
		}
	}
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			if (visl[getid(i,j)] != nowidx) {
				printf("%d %d DOLJE\n",i,j);
			}
			if (visr[getid(i,j)] == nowidx) {
				printf("%d %d DESNO\n",i,j);
			}
		}
	}
	
	return 0;
}
```

---


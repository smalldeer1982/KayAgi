# [BJWC2014] 数据

## 题目描述

为了写论文，```Alex``` 经常要整理大量的数据。这一次，```Alex``` 面临一个严峻的考验：他需要实现一个数据结构来维护一个点集。

现在，二维平面上有 $N$ 个点。

```Alex``` 需要实现以下三种操作：

1. 在点集里添加一个点；

2. 给出一个点，查询它到点集里所有点的曼哈顿距离的最小值；

3. 给出一个点，查询它到点集里所有点的曼哈顿距离的最大值。

两个点的曼哈顿距离定义为它们的横坐标差的绝对值与纵坐标差的绝对值的和。

这么困难的问题，```Alex``` 当然不会做，只好再次请你帮忙了。

## 说明/提示

对于前 $20 \%$ 的数据：$1\le N , Q\le 10^3$

对于前 $100 \%$ 的数据： $1\le N , Q \le 10^5$；

点的坐标是不超过 $10^9$ 的非负整数。

## 样例 #1

### 输入

```
3
7 5
6 2
3 1
5
1 6 1
1 5 5
2 7 1
0 3 2
1 1 0```

### 输出

```
1
2
4
3```

# 题解

## 作者：wishapig (赞：6)

关于KDT最近邻查询方面，前几个星期被@[Tweetuski](https://www.luogu.com.cn/user/48843)和@[142857cs](https://www.luogu.com.cn/user/35760)两位巨佬给D得体无完肤（~~导致现在我看到最近邻就头疼~~）

具体可见

[https://www.luogu.com.cn/discuss/show/214220](https://www.luogu.com.cn/discuss/show/214220) 

[https://www.luogu.com.cn/discuss/show/214426](https://www.luogu.com.cn/discuss/show/214426)

基于对最近邻查询深深的恐惧感，这题我一开始没有用最近邻

首先有

$$\max_i\{|x_i-x|+|y_i-y|\}$$
$$=\max_i\{\max(x_i-x,x-x_i),\max(y_i-y,y-y_i)\}$$
$$=\max_i\{x_i-x+y_i-y,x_i-x+y-y_i,x-x_i+y_i-y,x-x_i+y-y_i\}$$

那维护$\max\{x_i+y_i\},\max\{x_i-y_i\},\max\{-x_i+y_i\},\max\{-x_i-y_i\},$就可以了

然后

$$\min_i\{|x_i-x|+|y_i-y|\}$$

这把$x$与$x_i$，$y$与$y_i$的大小关系分4部分分别查询即可

在类似替罪羊树的重构方面，我也被@[142857cs](https://www.luogu.com.cn/user/35760)给D了，所以我预先把所有点都记下来，提前建好树形，避免了重构的操作

所以这种方法没用最近邻查询，复杂度是标准的$O(n\sqrt{n})$，带$4$倍常数（~~但是出题人很善良的把根号卡掉了~~）

这是根号的代码，也许有大佬可以帮我卡卡？

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> Pair;
const int N=4e5+5;
const Pair Em=make_pair(-1e9,-1e9);
#define F first
#define S second
int L[N],R[N],U[N],D[N],ls[N],rs[N],loc[N],fa[N];
int n,q,treesize,rt,cnt,maxx,maxy,Dir,l,r,d,u,k;
Pair poi[N];
bool exi[N];
struct Point{ int x,y,loc; bool E; } p[N];
struct Ques{ int op,x,y,loc; } que[N];
struct Data{ int a[4]; } Da,dat[N];
Data operator + (const Data& a, const Data& b){
	Data c;
	c.a[0]=min(a.a[0],b.a[0]); c.a[1]=min(a.a[1],b.a[1]);
	c.a[2]=min(a.a[2],b.a[2]); c.a[3]=min(a.a[3],b.a[3]);
	return c;
}
bool operator < (const Point& a, const Point& b){ return Dir?a.y<b.y:a.x<b.x; }
inline void Mix(Data& D, Pair P){
	if (P.F==Em.F && P.S==Em.S) D.a[0]=D.a[1]=D.a[2]=D.a[3]=2e9;
	else {
		int x=P.F,y=P.S;
		D.a[0]=-x-y; D.a[1]=-x+y;
		D.a[2]= x-y; D.a[3]= x+y;
	}
}
inline void Newnode(int now){
	if (!exi[now]) L[now]=U[now]=1e9,R[now]=D[now]=0,Mix(dat[now],Em); else
	L[now]=R[now]=poi[now].F,U[now]=D[now]=poi[now].S,Mix(dat[now],poi[now]);
}
inline void pushup(int now){
	Newnode(now);
	L[now]=min(L[now],min(L[ls[now]],L[rs[now]]));
	U[now]=min(U[now],min(U[ls[now]],U[rs[now]]));
	R[now]=max(R[now],max(R[ls[now]],R[rs[now]]));
	D[now]=max(D[now],max(D[ls[now]],D[rs[now]]));
	dat[now]=dat[now]+dat[ls[now]]+dat[rs[now]];
}
void build(int& now, int l, int r, int tag){
	if (l>r) return;
	int mid=(l+r)>>1; now=++treesize; Dir=tag;
	nth_element(p+l,p+mid,p+r+1);
	poi[now]=make_pair(p[mid].x,p[mid].y); exi[now]=p[mid].E;
	Newnode(now);
	if (p[mid].loc) loc[p[mid].loc]=now;
	build(ls[now],l,mid-1,tag^1); build(rs[now],mid+1,r,tag^1);
	if (ls[now]) fa[ls[now]]=now;
	if (rs[now]) fa[rs[now]]=now;
	pushup(now);
}
int query(int now){
	if (!now) return 2e9;
	if (l<=L[now] && R[now]<=r && u<=U[now] && D[now]<=d) return dat[now].a[k];
	if (l>R[now] || r<L[now] || u>D[now] || d<U[now]) return 2e9;
	int x=poi[now].F,y=poi[now].S,c=2e9;
	if (l<=x && x<=r && u<=y && y<=d && exi[now]){
		if (k==0) c=-x-y;
		else if (k==1) c=-x+y;
		else if (k==2) c= x-y;
		else c=x+y;
	}
	return min(c,min(query(ls[now]),query(rs[now])));
}
inline int read(){
	int num=0,fu=1; char ch=getchar();
	while (ch<'0' || ch>'9') fu&=(ch!='-'),ch=getchar();
	while (ch>='0' && ch<='9') num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return fu?num:-num;
}
int main(){
	n=read(); Newnode(0); Da.a[0]=Da.a[1]=Da.a[2]=Da.a[3]=-2e9;
	for (int i=1; i<=n; i++){
		p[i].x=read(),p[i].y=read(),p[i].E=1;
		Da.a[0]=max(Da.a[0],-p[i].x-p[i].y); Da.a[1]=max(Da.a[1],-p[i].x+p[i].y);
		Da.a[2]=max(Da.a[2], p[i].x-p[i].y); Da.a[3]=max(Da.a[3], p[i].x+p[i].y);
		maxx=max(maxx,p[i].x); maxy=max(maxy,p[i].y);
	}
	q=read(); cnt=n;
	for (int i=1; i<=q; i++){
		que[i].op=read(); que[i].x=read(); que[i].y=read();
		if (!que[i].op){
			cnt++,p[cnt].x=que[i].x,p[cnt].y=que[i].y,p[cnt].loc=que[i].loc=cnt;
			maxx=max(maxx,p[cnt].x); maxy=max(maxy,p[cnt].y);
		}
	}
	build(rt,1,cnt,0);
	for (int i=1; i<=q; i++){
		int x=que[i].x,y=que[i].y;
		if (que[i].op==0){
			int u=loc[que[i].loc]; exi[u]=1; Newnode(u);
			Da.a[0]=max(Da.a[0],-x-y); Da.a[1]=max(Da.a[1],-x+y);
			Da.a[2]=max(Da.a[2], x-y); Da.a[3]=max(Da.a[3], x+y);
			for (; u; u=fa[u]) pushup(u);
		} else
		if (que[i].op==1){
			int ans=2e9,r1,r2,r3,r4;
			l=0,r=x,u=0,d=y,k=0; r1=query(rt);
			l=0,r=x,u=y,d=maxy,k=1; r2=query(rt);
			l=x,r=maxx,u=0,d=y,k=2; r3=query(rt);
			l=x,r=maxx,u=y,d=maxy,k=3; r4=query(rt);
			if (r1!=2e9) ans=min(ans,r1+x+y);
			if (r2!=2e9) ans=min(ans,r2+x-y);
			if (r3!=2e9) ans=min(ans,r3-x+y);
			if (r4!=2e9) ans=min(ans,r4-x-y);
			printf("%d\n",ans);
		} else printf("%d\n",max(max(x+y+Da.a[0],x-y+Da.a[1]),max(-x+y+Da.a[2],-x-y+Da.a[3])));
	}
	return 0;
}
```

无奈，上面这份代码卡不过去，所以我又写了一份最近邻查询的版本，下面是代码

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
#define F first
#define S second
int L[N],R[N],U[N],D[N],ls[N],rs[N],loc[N],fa[N],Px[N],Py[N];
int n,q,treesize,rt,cnt,maxx,maxy,Dir,l,r,d,u,k,x,y,ans;
bool exi[N];
struct Point{ int x,y,loc; bool E; } p[N];
struct Ques{ int op,x,y,loc; } que[N];
struct Data{ int a[4]; } Da;
bool operator < (const Point& a, const Point& b){ return Dir?a.y<b.y:a.x<b.x; }
inline void Newnode(int now){
	if (!exi[now]) L[now]=U[now]=1e9,R[now]=D[now]=0; else
	L[now]=R[now]=Px[now],U[now]=D[now]=Py[now];
}
inline void pushup(int now){
	Newnode(now);
	L[now]=min(L[now],min(L[ls[now]],L[rs[now]]));
	U[now]=min(U[now],min(U[ls[now]],U[rs[now]]));
	R[now]=max(R[now],max(R[ls[now]],R[rs[now]]));
	D[now]=max(D[now],max(D[ls[now]],D[rs[now]]));
}
void build(int& now, int l, int r, int tag){
	if (l>r) return;
	int mid=(l+r)>>1; now=++treesize; Dir=tag;
	nth_element(p+l,p+mid,p+r+1);
	Px[now]=p[mid].x; Py[now]=p[mid].y; exi[now]=p[mid].E;
	Newnode(now);
	if (p[mid].loc) loc[p[mid].loc]=now;
	build(ls[now],l,mid-1,tag^1); build(rs[now],mid+1,r,tag^1);
	if (ls[now]) fa[ls[now]]=now;
	if (rs[now]) fa[rs[now]]=now;
	pushup(now);
}
inline int read(){
	int num=0,fu=1; char ch=getchar();
	while (ch<'0' || ch>'9') fu&=(ch!='-'),ch=getchar();
	while (ch>='0' && ch<='9') num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return fu?num:-num;
}
inline int Get_dis(int now){
	if (!now) return 2e9;
	int ans=0;
	if (x<L[now]) ans+=L[now]-x;
	if (y<U[now]) ans+=U[now]-y;
	if (x>R[now]) ans+=x-R[now];
	if (y>D[now]) ans+=y-D[now];
	return ans;
}
void query(int now){
	if (!now) return;
	if (exi[now]) ans=min(ans,abs(Px[now]-x)+abs(Py[now]-y));
	int dl=Get_dis(ls[now]),dr=Get_dis(rs[now]);
	if (dl<dr){
		if (dl<ans) query(ls[now]);
		if (dr<ans) query(rs[now]);
	} else {
		if (dr<ans) query(rs[now]);
		if (dl<ans) query(ls[now]);
	}
}
int main(){
	n=read(); Newnode(0); Da.a[0]=Da.a[1]=Da.a[2]=Da.a[3]=-2e9;
	for (int i=1; i<=n; i++){
		p[i].x=read(),p[i].y=read(),p[i].E=1;
		Da.a[0]=max(Da.a[0],-p[i].x-p[i].y); Da.a[1]=max(Da.a[1],-p[i].x+p[i].y);
		Da.a[2]=max(Da.a[2], p[i].x-p[i].y); Da.a[3]=max(Da.a[3], p[i].x+p[i].y);
		maxx=max(maxx,p[i].x); maxy=max(maxy,p[i].y);
	}
	q=read(); cnt=n;
	for (int i=1; i<=q; i++){
		que[i].op=read(); que[i].x=read(); que[i].y=read();
		if (!que[i].op){
			cnt++,p[cnt].x=que[i].x,p[cnt].y=que[i].y,p[cnt].loc=que[i].loc=cnt;
			maxx=max(maxx,p[cnt].x); maxy=max(maxy,p[cnt].y);
		}
	}
	build(rt,1,cnt,0);
	for (int i=1; i<=q; i++){
		x=que[i].x,y=que[i].y;
		if (que[i].op==0){
			int u=loc[que[i].loc]; exi[u]=1; Newnode(u);
			Da.a[0]=max(Da.a[0],-x-y); Da.a[1]=max(Da.a[1],-x+y);
			Da.a[2]=max(Da.a[2], x-y); Da.a[3]=max(Da.a[3], x+y);
			for (; u; u=fa[u]) pushup(u);
		} else
		if (que[i].op==1){
			ans=2e9; query(rt);
			printf("%d\n",ans);
		} else printf("%d\n",max(max(x+y+Da.a[0],x-y+Da.a[1]),max(-x+y+Da.a[2],-x-y+Da.a[3])));
	}
	return 0;
}
```

最后，我还是要问：KDT最近邻查询最坏到底是多少的？有没有卡到极限的方法？各位巨佬可以私信我（我到现在都没弄明白）

---

## 作者：Su_Zipei (赞：4)

首先这题是可以使用cdq分治解决，类似天使玩偶那道题，不过翻转很麻烦，所以我使用了KD-Tree

个人认为KD-Tree的核心在于估价函数和重构，不然就和暴力没有什么关系了。

对于重构，其实和替罪羊的重构没什么区别，就不说了。

对于估价函数，要知道得到的估价并不是实际距离的最大值/最小值，所以两棵子树都要试着去搜一下，不过需要先搜索更容易更新答案的那个。
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e6+10;
int typ,rt;
struct Node{
	int x[2];
	bool operator < (const Node &A)const{
		return x[typ]<A.x[typ];
	}
}a[N];
struct Tree{
	int ls,rs,siz,Mx[2],Mi[2],x[2];
}T[N];
#define ls T[rt].ls
#define rs T[rt].rs
int stk[N],tp,cnt;
int New(){
	if(tp)return stk[tp--];
	return ++cnt;
}
void up(int rt){
	T[rt].siz=T[ls].siz+T[rs].siz+1;
	for(int i=0;i<2;i++){
		T[rt].Mx[i]=T[rt].Mi[i]=T[rt].x[i];
		if(ls){
			T[rt].Mx[i]=max(T[rt].Mx[i],T[ls].Mx[i]);
			T[rt].Mi[i]=min(T[rt].Mi[i],T[ls].Mi[i]);
		}
		if(rs){
			T[rt].Mx[i]=max(T[rt].Mx[i],T[rs].Mx[i]);
			T[rt].Mi[i]=min(T[rt].Mi[i],T[rs].Mi[i]);
		}
	}
}
void Build(int &rt,int l,int r,int d){
	rt=0;
	if(l>r)return;
	rt=New();
	int mid=l+r>>1;
	typ=d;
	nth_element(a+l,a+mid,a+r+1);
	T[rt].x[0]=a[mid].x[0];T[rt].x[1]=a[mid].x[1];
	Build(ls,l,mid-1,d^1);
	Build(rs,mid+1,r,d^1);
	up(rt);
}
int tt;
void get(int rt){
	a[++tt].x[0]=T[rt].x[0];
	a[tt].x[1]=T[rt].x[1];
	stk[++tp]=rt;
	if(ls)get(ls);
	if(rs)get(rs);
}
void ck(int &rt,int d){
	int Max=max(T[ls].siz,T[rs].siz);
	if(Max>T[rt].siz*0.75)tt=0,get(rt),Build(rt,1,tt,d);
}
void insert(int &rt,int x[2],int d){
	if(!rt){
		rt=New();
		ls=rs=0;
		T[rt].x[0]=x[0];T[rt].x[1]=x[1];
		up(rt);
		return;
	}
	if(x[d]<=T[rt].x[d])insert(ls,x,d^1);
	else insert(rs,x,d^1);
	up(rt);ck(rt,d);
}
int ans;
int getmi(int rt,int x[]){
	int res=0;
	for(int i=0;i<2;i++)
		res+=max(x[i]-T[rt].Mx[i],0)+max(T[rt].Mi[i]-x[i],0);
	return res;
}
int getmx(int rt,int x[]){
	int res=0;
	for(int i=0;i<2;i++)
		res+=max(T[rt].Mx[i]-x[i],0)+max(x[i]-T[rt].Mi[i],0);
	return res;
}
#define dis(x,y,xx,yy) (abs(x-xx)+abs(y-yy))
const int INF=0x7fffffff;
void qmx(int rt,int x[2]){
	ans=max(ans,dis(T[rt].x[0],T[rt].x[1],x[0],x[1]));	
	int l=-INF,r=-INF;
	if(ls)l=getmx(ls,x);
	if(rs)r=getmx(rs,x);
	if(l<r){
		if(r>ans)qmx(rs,x);
		if(l>ans)qmx(ls,x);
	}else{
		if(l>ans)qmx(ls,x);
		if(r>ans)qmx(rs,x);
	}
}
void qmi(int rt,int x[2]){
	ans=min(ans,dis(T[rt].x[0],T[rt].x[1],x[0],x[1]));	
	int l=INF,r=INF;
	if(ls)l=getmi(ls,x);
	if(rs)r=getmi(rs,x);
	if(l<r){
		if(l<ans)qmi(ls,x);
		if(r<ans)qmi(rs,x);
	}else{
		if(r<ans)qmi(rs,x);
		if(l<ans)qmi(ls,x);
	}
}
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=0;j<2;j++)
			scanf("%d",&a[i].x[j]);
	}
	Build(rt,1,n,0);
	int q;
	scanf("%d",&q);
	while(q--){
		int op,x[2];
		scanf("%d%d%d",&op,&x[0],&x[1]);
		if(op==0)insert(rt,x,0);
		else if(op==1)ans=INF,qmi(rt,x),printf("%d\n",ans);
		else ans=-INF,qmx(rt,x),printf("%d\n",ans);
	}
	return 0;
}

```

---

## 作者：zhengrunzhe (赞：3)

K-D Tree板子题 学习见[我的kd树教程](https://www.luogu.com.cn/blog/van/qian-tan-pian-xu-wen-ti-yu-k-d-tree)

设置估价函数，类似树上A*，判断答案是否有可能在子树中达到剪枝

考虑如何支持动态插入

kdtree不好旋转，每一层的排序方式不太一样

做法就是利用替罪羊思想 设置平衡因子$\alpha$ 如果左右子树有一个子树的大小>子树大小*$alpha$，就失衡了，拍扁重建
```cpp
#include<cstdio>
#include<algorithm>
using std::nth_element;
const int k(2),N(2.5e5+5),inf(2e9+5);
template<class type>inline const type max(const type &a,const type &b){return a>b?a:b;}
template<class type>inline const type min(const type &a,const type &b){return a<b?a:b;}
template<class type>inline const type abs(const type &a){return a<0?-a:a;}
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
bool f,flag;
struct point
{
	int d[k];
	inline point(){}
	inline point(const int &x,const int &y){d[0]=x;d[1]=y;}
	inline const bool operator<(const point &p)const
	{
		if (d[f]!=p.d[f])return d[f]<p.d[f];
		for (int i(0);i<k;i++)if (d[i]!=p.d[i])return d[i]<p.d[i];
		return 0;
	}
	inline const friend int distance(const point &x,const point &y) //曼哈顿距离
	{
		int dis(0);
		for (int i(0);i<k;i++)dis+=abs(x.d[i]-y.d[i]);
		return dis;
	}
	inline const void readin()
	{
		for (int i(0);i<k;i++)read(d[i]);
	}
}a[N<<1]; //注意点数O(n+m)
int ans,cnt,n,m;
const double alpha(0.75);
struct tree
{
	point range,mn,mx;
	tree *son[2];
	int size;
	static tree *null;
	void *operator new(size_t size);
	void operator delete(void *ptr);
	inline tree():size(0)
	{
		son[0]=son[1]=null;
	}
	inline tree(const point &p):range(p),mn(p),mx(p),size(1)
	{
		static bool init(0);
		if (!init)
			init=1,
			null=new tree,
			null->son[0]=null->son[1]=null,
			null->mn.d[0]=null->mn.d[1]=inf;
		son[0]=son[1]=null;
	}
	inline const bool unbalanced()
	{
		return son[0]->size>size*alpha||son[1]->size>size*alpha;
	}
	inline const void pushup()
	{
		size=son[0]->size+1+son[1]->size;
		for (int i(0);i<k;i++)
			mx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i])),
			mn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i]));
	}
	inline const int evalue_min(const point &p)
	{
		if (this==null)return inf;
		int f(0);
		for (int i(0);i<k;i++)f+=max(mn.d[i]-p.d[i],0)+max(p.d[i]-mx.d[i],0);
		return f;
	}
	inline const int evalue_max(const point &p)
	{
		if (this==null)return 0;
		int f(0);
		for (int i(0);i<k;i++)f+=max(abs(mn.d[i]-p.d[i]),abs(mx.d[i]-p.d[i]));
		return f;
	}
	inline const void query_min(const point &p)
	{
		if (this==null)return;
		ans=min(ans,distance(range,p));
		const int f[k]={son[0]->evalue_min(p),son[1]->evalue_min(p)};
		const bool t(f[0]>=f[1]);
		if (f[t]<ans)son[t]->query_min(p);
		if (f[!t]<ans)son[!t]->query_min(p);
	}
	inline const void query_max(const point &p)
	{
		if (this==null)return;
		ans=max(ans,distance(range,p));
		const int f[k]={son[0]->evalue_max(p),son[1]->evalue_max(p)};
		const bool t(f[0]<=f[1]);
		if (f[t]>ans)son[t]->query_max(p);
		if (f[!t]>ans)son[!t]->query_max(p);
	}
}*root,*tree::null;
#define null tree::null
char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof memory_pool);
void *recycle[N],**top(recycle);
inline void *tree::operator new(size_t size){return top!=recycle?*--top:tail-=size;}
inline void tree::operator delete(void *ptr){*top++=ptr;}
inline const void travel(tree *&p) //提取子树内所有的点
{
	if (p==null)return;
	travel(p->son[0]);
	a[++cnt]=p->range;delete p;
	travel(p->son[1]);
}
inline tree *build(const int &l,const int &r,const bool &d) //拍扁重建
{
	if (l>r)return null;
	const int mid(l+r>>1);f=d;
	nth_element(a+l,a+mid,a+r+1);
	tree *p(new tree(a[mid]));
	if (l==r)return p;
	p->son[0]=build(l,mid-1,!d);
	p->son[1]=build(mid+1,r,!d);
	p->pushup();
	return p;
}
inline const void rebuild(tree *&p,const bool &d)
{
	cnt=0;
	travel(p);
	p=build(1,cnt,d);
}
inline tree **insert(tree *&p,const point &x,const bool &d) //插入，返回失衡位置
{
	if (p==null)return p=new tree(x),&null;
	f=d;tree **bad(insert(p->son[p->range<x],x,!d));
	p->pushup();
	if (p->unbalanced())bad=&p,flag=d;
	return bad;
}
inline const void insert(const point &x)
{
	tree **bad(insert(root,x,flag=0));
	if (*bad==null)return;
	rebuild(*bad,flag);
}
int main()
{
	read(n);
	for (int i(1);i<=n;i++)a[i].readin();
	root=build(1,n,0);
	read(m);
	for (int opt,x,y;m--;)
		switch (read(opt),read(x),read(y),opt)
		{
			case 0:insert(point(x,y));break;
			case 1:ans=inf;root->query_min(point(x,y));printf("%d\n",ans);break;
			case 2:ans=0;root->query_max(point(x,y));printf("%d\n",ans);break;
		}
	return 0;
}
```

---

## 作者：critnos (赞：2)

一个 CDQ 做法。

考虑静态问题怎么做（给定 $n$ 个点，后 $m$ 次询问）。为了去掉绝对值，分关于 $x,y$ 大小分四类讨论，最后取 $\min  \max$。这里可以按 $x$ 排序，然后通过维护前缀 $\min \max$ 的树状数组维护即可。

那么通过 CDQ 这个动态转静态的工具即可。

一些注意点：

* 按 $x,y,op$ 的顺序排序（CDQ 基操），否组会导致查询没有被可以有贡献的操作贡献。

* 离散化，有一些细节，就是在树状数组里搞的时候要用原数。

* 我全部开了 `long long` 才过。。$\inf -\inf$ 也取了 $10^{18} -10^{18}$ 才过（应该是我写丑了）。

因为有些难写，所以我放个代码以供各位参考吧

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
#define int long long
using namespace std;
int read()
{
	int s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s;
}
struct node
{
	int opt,x,y,w,y2;
	friend bool operator<(const node &x,const node &y)
	{
		if(x.x==y.x) 
		{
			if(x.y==y.y)
				return x.opt<y.opt;
			return x.y<y.y;
		}
		return x.x<y.x;
	}
}a[200005],q[200005];
int h[200005];
int all,cnt;
int mx;
int ans[100005];
const int mxv=200005;
int t[200010],t2[200010];
void add_bit(int x,int y)
{
	for(;x<=mxv;x+=lowbit(x))
		t[x]=min(t[x],y),t2[x]=max(t2[x],y);
}
void clear(int x)
{
	for(;x<=mxv;x+=lowbit(x))
		t[x]=1e18,t2[x]=-1e18;
}
int ask_min(int x)
{
	int s=1e18;
	for(;x;x-=lowbit(x))
		s=min(s,t[x]);
	return s;
}
int ask_max(int x)
{
	int s=-1e18;
	for(;x;x-=lowbit(x))
		s=max(s,t2[x]);
	return s;
}
void solve(int cnt)
{
	int i,j;
	bool fl;
	sort(q,q+cnt);
	for(i=0;i<cnt;i++)
	{
		if(q[i].opt==1)
			add_bit(q[i].y2,-q[i].x-q[i].y);
		if(q[i].opt==2)	
			ans[q[i].w]=min(1ll*ans[q[i].w],1ll*q[i].x+q[i].y+ask_min(q[i].y2));
		if(q[i].opt==3)	
			ans[q[i].w]=max(1ll*ans[q[i].w],1ll*q[i].x+q[i].y+ask_max(q[i].y2));	
	}
	for(i=0;i<cnt;i++)
		if(q[i].opt==1)
			clear(q[i].y2);
	for(i=cnt-1;i>=0;i--)
	{
		if(q[i].opt==1)
			add_bit(q[i].y2,q[i].x-q[i].y);
		if(q[i].opt==2)
			ans[q[i].w]=min(1ll*ans[q[i].w],-1ll*q[i].x+q[i].y+ask_min(q[i].y2));
		if(q[i].opt==3)
			ans[q[i].w]=max(1ll*ans[q[i].w],-1ll*q[i].x+q[i].y+ask_max(q[i].y2));
	}
	for(i=0;i<cnt;i++)
		if(q[i].opt==1)
			clear(q[i].y2);		
	for(i=0;i<cnt;i++)
	{
		if(q[i].opt==1)
			add_bit(mxv-q[i].y2,-q[i].x+q[i].y);
		if(q[i].opt==2)
			ans[q[i].w]=min(1ll*ans[q[i].w],1ll*q[i].x-q[i].y+ask_min(mxv-q[i].y2));
		if(q[i].opt==3)
			ans[q[i].w]=max(1ll*ans[q[i].w],1ll*q[i].x-q[i].y+ask_max(mxv-q[i].y2));	
	}		
	for(i=0;i<cnt;i++)
		if(q[i].opt==1)
			clear(mxv-q[i].y2);	
	for(i=cnt-1;i>=0;i--)
	{
		if(q[i].opt==1)
			add_bit(mxv-q[i].y2,q[i].x+q[i].y);
		if(q[i].opt==2)
			ans[q[i].w]=min(1ll*ans[q[i].w],-1ll*q[i].x-q[i].y+ask_min(mxv-q[i].y2));
		if(q[i].opt==3)
			ans[q[i].w]=max(1ll*ans[q[i].w],-1ll*q[i].x-q[i].y+ask_max(mxv-q[i].y2));
	}
	for(i=0;i<cnt;i++)
		if(q[i].opt==1)
			clear(mxv-q[i].y2);
}
void CDQ(int l,int r)
{
	if(l==r) return;
	int mid=l+r>>1,i,w=0;
	CDQ(l,mid),CDQ(mid+1,r);
	for(i=l;i<=mid;i++)
		if(a[i].opt==1)
			q[w++]=a[i];
	for(;i<=r;i++)
		if(a[i].opt>1)
			q[w++]=a[i];
	solve(w);
}
signed main()
{
	int n,m,i,cnt=0,q=0,le;
	n=read();
	for(i=1;i<=n;i++)
		a[++cnt].opt=1,a[cnt].x=read(),a[cnt].y=read();
	m=read();
	while(m--)
	{
		a[++cnt].opt=read()+1,a[cnt].x=read(),a[cnt].y=read();
		if(a[cnt].opt>1) a[cnt].w=++q;
		if(a[cnt].opt==2) ans[q]=2e9;
	}
	for(i=1;i<=cnt;i++)
		h[i]=a[i].y;
	sort(h+1,h+1+cnt);
	le=unique(h+1,h+1+cnt)-h;
	for(i=1;i<=cnt;i++)
		a[i].y2=lower_bound(h+1,h+le,a[i].y)-h;
	for(i=1;i<=mxv;i++)
		t[i]=1e18,t2[i]=-1e18;
	CDQ(1,cnt);
	for(i=1;i<=q;i++)
		printf("%lld\n",ans[i]);
}
```

---

## 作者：__ycx2010__ (赞：1)

## 思路
cdq 分治，思路类似 P4169，对于每一个点维护坐标和时间，当有一个点得坐标和时间都小于等于它时，更新答案，一共有四个方向，将坐标轴旋转 $90$ 度四次，时间复杂度 $O(n\log^2 n)$。

```cpp
#include <bits/stdc++.h>
#define re register
#define ll long long
using namespace std;

const int N = 200010, INF = 2e9;
int n, m, tot;
long long ans[N][2];
vector<int> X, Y;

int Max(int fi, int se) {
	return fi < se ? se : fi;
} int Min(int fi, int se) {
	return fi < se ? fi : se;
} 

struct IOI {
	int x, y, t, id, v, xx, yy;
} a[N], b[N], c[N];

inline int read() {
	int f = 1, w = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {w = (w << 3) + (w << 1) + ch - '0'; ch = getchar();}
	return f * w;
}

struct Tree__ {
	int mx[N + 10], mx2[N + 10];
	inline void clearr() {
		for (re int i = 0; i < N + 10; i ++ ) mx[i] = -INF, mx2[i] = INF;
	} inline void clear(int x) {
	    for (re int i = x; i <= N - 10; i += i & -i) mx[i] = -INF, mx2[i] = INF;
	} inline void modify(int x, int y) {
	    for (re int i = x; i <= N - 10; i += i & -i) mx[i] = Max(mx[i], y), mx2[i] = Min(mx2[i], y);
	} inline int query(int x) {
	    int res = -INF;
	    for (re int i = x; i; i -= i & -i) res = Max(res, mx[i]);
	    return res;
	} inline int query2(int x) {
	    int res = INF;
	    for (re int i = x; i; i -= i & -i) res = Min(res, mx2[i]);
	    return res;
	}
} Tr;

inline void merge(int l, int r) {
	if (l == r) return;
	int mid = l + r >> 1;
	merge(l, mid), merge(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (i <= mid && j <= r) {
		if (a[i].x <= a[j].x) {
			if (a[i].id == 0) Tr.modify(a[i].y, a[i].v);
			b[k ++ ] = a[i ++ ];
		} else {
			if (a[j].id) {
				ans[a[j].id][0] = min(ans[a[j].id][0], (ll)a[j].v - Tr.query(a[j].y));
				ans[a[j].id][1] = max(ans[a[j].id][1], (ll)a[j].v - Tr.query2(a[j].y));
			}
			b[k ++ ] = a[j ++ ];
		}
	}
	while (i <= mid) {b[k ++ ] = a[i ++ ];}
	while (j <= r) {
		if (a[j].id) {
			ans[a[j].id][0] = min(ans[a[j].id][0], (ll)a[j].v - Tr.query(a[j].y));
			ans[a[j].id][1] = max(ans[a[j].id][1], (ll)a[j].v - Tr.query2(a[j].y));
		}
		b[k ++ ] = a[j ++ ];
	}
	for (i = l; i <= r; i ++ ) {
		Tr.clear(a[i].y);
		a[i] = b[i];
	}
}

inline void rotato() {
	for (register int i = 1; i <= tot; i ++ ) {
		int xx = a[i].x, yy = a[i].y;
		int xxx = a[i].xx, yyy = a[i].yy;
		a[i].x = yy, a[i].y = 200001 - xx;
		a[i].xx = yyy, a[i].yy = 1000000002 - xxx;
		a[i].v = a[i].xx + a[i].yy;
	}
}

int main() {
	for (re int i = 0; i < N; i ++ ) ans[i][0] = INF;
	Tr.clearr();
	n = read();
	tot = n;
	for (register int i = 1; i <= n; i ++ ) {
		a[i].x = read() + 1, a[i].y = read() + 1;
		a[i].t = 0;
		X.push_back(a[i].x);
		Y.push_back(a[i].y);
	}
	m = read();
	vector<pair<int, int> > Query;
	for (register int i = 1; i <= m; i ++ ) {
		int op = read();
		if (op == 0) {
			a[++ tot] = {read() + 1, read() + 1, i};
			X.push_back(a[tot].x);
			Y.push_back(a[tot].y);
		} else {
			a[++ tot] = {read() + 1, read() + 1, i, i};
			Query.push_back({i, op - 1});
			X.push_back(a[tot].x);
			Y.push_back(a[tot].y);
		}
	}
	sort(X.begin(), X.end());
	sort(Y.begin(), Y.end());
	int len1 = unique(X.begin(), X.end()) - X.begin();
	int len2 = unique(Y.begin(), Y.end()) - Y.begin();
	map<int, int> ma, ma2;
	for (re int i = 0; i < len1; i ++ ) ma[X[i]] = i + 1;
	for (re int i = 0; i < len2; i ++ ) ma2[Y[i]] = i + 1;
	for (re int i = 1; i <= tot; i ++ ) {
		a[i].v = a[i].x + a[i].y;
		a[i].xx = a[i].x, a[i].yy = a[i].y;
		a[i].x = ma[a[i].x];
		a[i].y = ma2[a[i].y];
	}
	for (register int i = 0; i < 4; i ++ ) {
		for (register int j = 1; j <= tot; j ++ ) c[j] = a[j];
		merge(1, tot);
		for (register int j = 1; j <= tot; j ++ ) a[j] = c[j];
		rotato();
	}
	for (register int i = 0; i < Query.size(); i ++ ) printf("%lld\n", ans[Query[i].first][Query[i].second]);
	return 0;
}
```

---

## 作者：JiaY19 (赞：1)

[$\text{可能更好的阅读体验}$](https://www.cnblogs.com/mfeitveer/p/16034987.html)

明明是一道 $\text{k-d tree}$ 模板题，为什么写的人这么少呢。

### 思路

看到平面上的操作，就必不可免的想到 $\text{k-d tree}$。

$\text{k-d tree}$ 板子大家应该都会写，这里讲一下最近最远的查询。

**1.最远**

我们可以发现，一个点到一个矩阵的最远距离一定是到其四个角的最大距离，$\text{k-d tree}$ 维护的矩阵虽然不是一个实际的矩阵，但算出这个答案与原来的答案进行比较，也能剪枝掉不少情况。

**2.最近**

一个点到一个矩阵的最近距离我们发现，如果点在矩阵内，那么就是零，不然就是直接到边或者到四个角。

为了简便，我们可以这么写：

```cpp
inline int ask(int x , int y , int id)
{
	int res = 0;
	res += max(0ll , y - t[id].u) + max(0ll , x - t[id].r);
	res += max(0ll , t[id].d - y) + max(0ll , t[id].l - x);
	return res;
}

```

本题实测是不需要方差建树和重构树的，直接交替建树就可以了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 200020;
const int inf = 1e10;

int n , m , rt , cnt , top , ans , stk[N];

struct Node
{
	int l , r , u , d , siz , a[2] , son[2];
}t[N];

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

inline void push_up(int p)
{
	t[p].l = t[p].r = t[p].a[0] , t[p].u = t[p].d = t[p].a[1] , t[p].siz = 1;
	for(int i = 0;i <= 1;i++) if(t[p].son[i])
		t[p].siz += t[t[p].son[i]].siz,
   		t[p].l = min(t[p].l , t[t[p].son[i]].l) , t[p].r = max(t[p].r , t[t[p].son[i]].r),
   		t[p].d = min(t[p].d , t[t[p].son[i]].d) , t[p].u = max(t[p].u , t[t[p].son[i]].u);
}

inline void insert(int &p , int id , int opt)
{
	if(!p) { p = id , push_up(p); return; }
	if(t[id].a[opt] < t[p].a[opt]) insert(t[p].son[0] , id , opt ^ 1);
	else insert(t[p].son[1] , id , opt ^ 1); push_up(p);
}

inline void ask1(int p , int x , int y)
{
	ans = max(ans , abs(x - t[p].a[0]) + abs(y - t[p].a[1]));
	for(int i = 0;i <= 1;i++)
		if(t[p].son[i])
		{
			int l = t[p].l , r = t[p].r , u = t[p].u , d = t[p].d;
			int res = max({abs(l - x) + abs(u - y) , abs(r - x) + abs(u - y) , abs(r - x) + abs(d - y) , abs(l - x) + abs(d - y)});
			if(res > ans) ask1(t[p].son[i] , x , y);
		}
}

inline int ask(int x , int y , int id)
{
	int res = 0;
	res += max(0ll , y - t[id].u) + max(0ll , x - t[id].r);
	res += max(0ll , t[id].d - y) + max(0ll , t[id].l - x);
	return res;
}

inline void ask2(int p , int x , int y)
{
	ans = min(ans , abs(x - t[p].a[0]) + abs(y - t[p].a[1]));
	for(int i = 0;i <= 1;i++)
		if(t[p].son[i])
		{
			int res = ask(x , y , t[p].son[i]);
			if(res < ans) ask2(t[p].son[i] , x , y);
		}
}

signed main()
{
    n = read();
	for(int i = 1;i <= n;i++)
	{
		int x = read() , y = read(); ++cnt;
		t[cnt].a[0] = x , t[cnt].a[1] = y;
		insert(rt , cnt , 1);
	}
	m = read();
	for(int i = 1;i <= m;i++)
	{
		int opt = read() , x = read() , y = read();
		if(opt == 0)
		{
			t[++cnt].a[0] = x , t[cnt].a[1] = y;
			insert(rt , cnt , 1);
		}
		if(opt == 1) ans =  inf , ask2(rt , x , y) , printf("%lld\n" , ans);
		if(opt == 2) ans = -inf , ask1(rt , x , y) , printf("%lld\n" , ans);
	}
    return 0;
}

```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可癌~~的~~毒瘤~~题目。

### 前置知识

- [cdq 分治](https://www.luogu.com.cn/article/nl6r7elc)
- [[Violet] 天使玩偶/SJY摆棋子](https://www.luogu.com.cn/problem/P4169)
- [离散化](https://oi-wiki.org/misc/discrete/)

### 思路

学完后你就会发现这道题和 P4196 简直一摸一样，只需要在树状数组上维护最大值和最小值，答案也维护最大和最小值，但是需要将 $y$ 离散化，所以在结构体里新建一个变量 $posy$ 用于存储离散化后的 $y$，不能使用 `unordered_map` 和 `map`，否则会 TLE。

时间复杂度 $O(n \log^{2} n)$。

> 十年 OI 一场空，不开 long long 见祖宗。

### Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5,inf = 1e18;
struct node{
    int ti,x,y,pos,pos_y;
    char opt;
} e1[N],e2[N],e3[N],e4[N],t[N];
int n,m,Q,cnt,qcnt,ti,tot,minn[N],maxx[N];
vector<int> num;
char opt[N];
namespace Bit{
    int minn[N],maxx[N];
    void build(){
        for(int i = 1;i <= m;i ++){
            minn[i] = inf;
            maxx[i] = -inf;
        }
    }
    void update(int x,int v){
        for(;x <= m;x += x & -x){
            minn[x] = min(minn[x],v);
            maxx[x] = max(maxx[x],v);
        }
    }
    void clear(int x){
        for(;x <= m;x += x & -x){
            minn[x] = inf;
            maxx[x] = -inf;
        }
    }
    int query_max(int x){
        int res = -inf;
        for(;x > 0;x -= x & -x){
            res = max(res,maxx[x]);
        }
        return res;
    }
    int query_min(int x){
        int res = inf;
        for(;x > 0;x -= x & -x){
            res = min(res,minn[x]);
        }
        return res;
    }
}
char get(){
    static char buf[1 << 20],*p1 = buf,*p2 = buf;
    if(p1 == p2){
        p2 = (p1 = buf) + fread(buf,1,1 << 20,stdin);
        if(p1 == p2){
            return EOF;
        }
    }
    return *p1 ++;
}
int read(){
    int res = 0;
    char c = get();
    while(c < '0' or c > '9'){
        c = get();
    }
    while(c >= '0' and c <= '9'){
        res = (res << 1) + (res << 3) + (c ^ '0');
        c = get();
    }
    return res;
}
char read_c(){
    char c = get();
    while(c < '0' or c > '9'){
        c = get();
    }
    return c;
}
void write(int x){
    if(x < 0){
        putchar('-');
        x = -x;
    }
    if(x > 9){
        write(x / 10);
    }
    putchar(x % 10 + '0');
}
void cdq(int l,int r){
    if(l == r){
        return;
    }
    int mid = (l + r) >> 1;
    cdq(l,mid);
    cdq(mid + 1,r);
    int p = l,q = mid + 1,tot = 0;
    while(p <= mid and q <= r){
        if(e1[p].x <= e1[q].x){
            if(e1[p].opt == '1'){
                Bit::update(e1[p].pos_y,e1[p].x + e1[p].y);
            }
            t[++tot] = e1[p ++];
        }else{
            if(e1[q].opt == '2'){
                minn[e1[q].pos] = min(minn[e1[q].pos],e1[q].y + e1[q].x - Bit::query_max(e1[q].pos_y));
            }
            if(e1[q].opt == '3'){
                maxx[e1[q].pos] = max(maxx[e1[q].pos],e1[q].y + e1[q].x - Bit::query_min(e1[q].pos_y));
            }
            t[++tot] = e1[q ++];
        }
    }
    while(p <= mid){
        if(e1[p].opt == '1'){
            Bit::update(e1[p].pos_y,e1[p].x + e1[p].y);
        }
        t[++tot] = e1[p ++];
    }
    while(q <= r){
        if(e1[q].opt == '2'){
            minn[e1[q].pos] = min(minn[e1[q].pos],e1[q].y + e1[q].x - Bit::query_max(e1[q].pos_y));
        }
        if(e1[q].opt == '3'){
            maxx[e1[q].pos] = max(maxx[e1[q].pos],e1[q].y + e1[q].x - Bit::query_min(e1[q].pos_y));
        }
        t[++tot] = e1[q ++];
    }
    for(int i = l;i <= mid;i ++){
        if(e1[i].opt == '1'){
            Bit::clear(e1[i].pos_y);
        }
    }
    for(int i = l;i <= r;i ++){
        e1[i] = t[i - l + 1];
    }
    p = l,q = mid + 1,tot = 0;
    while(p <= mid and q <= r){
        if(e2[p].x <= e2[q].x){
            if(e2[p].opt == '1'){
                Bit::update(m - e2[p].pos_y + 1,e2[p].x - e2[p].y);
            }
            t[++tot] = e2[p ++];
        }else{
            if(e2[q].opt == '2'){
                minn[e2[q].pos] = min(minn[e2[q].pos],e2[q].x - e2[q].y - Bit::query_max(m - e2[q].pos_y + 1));
            }
            if(e2[q].opt == '3'){
                maxx[e2[q].pos] = max(maxx[e2[q].pos],e2[q].x - e2[q].y - Bit::query_min(m - e2[q].pos_y + 1));
            }
            t[++tot] = e2[q ++];
        }
    }
    while(p <= mid){
        if(e2[p].opt == '1'){
            Bit::update(m - e2[p].pos_y + 1,e2[p].x - e2[p].y);
        }
        t[++tot] = e2[p ++];
    }
    while(q <= r){
        if(e2[q].opt == '2'){
            minn[e2[q].pos] = min(minn[e2[q].pos],e2[q].x - e2[q].y - Bit::query_max(m - e2[q].pos_y + 1));
        }
        if(e2[q].opt == '3'){
            maxx[e2[q].pos] = max(maxx[e2[q].pos],e2[q].x - e2[q].y - Bit::query_min(m - e2[q].pos_y + 1));
        }
        t[++tot] = e2[q ++];
    }
    for(int i = l;i <= mid;i ++){
        if(e2[i].opt == '1'){
            Bit::clear(m - e2[i].pos_y + 1);
        }
    }
    for(int i = l;i <= r;i ++){
        e2[i] = t[i - l + 1];
    }
    p = l,q = mid + 1,tot = 0;
    while(p <= mid and q <= r){
        if(e3[p].x >= e3[q].x){
            if(e3[p].opt == '1'){
                Bit::update(e3[p].pos_y,e3[p].y - e3[p].x);
            }
            t[++tot] = e3[p ++];
        }else{
            if(e3[q].opt == '2'){
                minn[e3[q].pos] = min(minn[e3[q].pos],e3[q].y - e3[q].x - Bit::query_max(e3[q].pos_y));
            }
            if(e3[q].opt == '3'){
                maxx[e3[q].pos] = max(maxx[e3[q].pos],e3[q].y - e3[q].x - Bit::query_min(e3[q].pos_y));
            }
            t[++tot] = e3[q ++];
        }
    }
    while(p <= mid){
        if(e3[p].opt == '1'){
            Bit::update(e3[p].pos_y,e3[p].y - e3[p].x);
        }
        t[++tot] = e3[p ++];
    }
    while(q <= r){
        if(e3[q].opt == '2'){
            minn[e3[q].pos] = min(minn[e3[q].pos],e3[q].y - e3[q].x - Bit::query_max(e3[q].pos_y));
        }
        if(e3[q].opt == '3'){
            maxx[e3[q].pos] = max(maxx[e3[q].pos],e3[q].y - e3[q].x - Bit::query_min(e3[q].pos_y));
        }
        t[++tot] = e3[q ++];
    }
    for(int i = l;i <= mid;i ++){
        if(e3[i].opt == '1'){
            Bit::clear(e3[i].pos_y);
        }
    }
    for(int i = l;i <= r;i ++){
        e3[i] = t[i - l + 1];
    }
    p = l,q = mid + 1,tot = 0;
    while(p <= mid and q <= r){
        if(e4[p].x >= e4[q].x){
            if(e4[p].opt == '1'){
                Bit::update(m - e4[p].pos_y + 1,-(e4[p].y + e4[p].x));
            }
            t[++tot] = e4[p ++];
        }else{
            if(e4[q].opt == '2'){
                minn[e4[q].pos] = min(minn[e4[q].pos],-(e4[q].y + e4[q].x) - Bit::query_max(m - e4[q].pos_y + 1));
            }
            if(e4[q].opt == '3'){
                maxx[e4[q].pos] = max(maxx[e4[q].pos],-(e4[q].y + e4[q].x) - Bit::query_min(m - e4[q].pos_y + 1));
            }
            t[++tot] = e4[q ++];
        }
    }
    while(p <= mid){
        if(e4[p].opt == '1'){
            Bit::update(m - e4[p].pos_y + 1,-(e4[p].y + e4[p].x));
        }
        t[++tot] = e4[p ++];
    }
    while(q <= r){
        if(e4[q].opt == '2'){
            minn[e4[q].pos] = min(minn[e4[q].pos],-(e4[q].y + e4[q].x) - Bit::query_max(m - e4[q].pos_y + 1));
        }
        if(e4[q].opt == '3'){
            maxx[e4[q].pos] = max(maxx[e4[q].pos],-(e4[q].y + e4[q].x) - Bit::query_min(m - e4[q].pos_y + 1));
        }
        t[++tot] = e4[q ++];
    }
    for(int i = l;i <= mid;i ++){
        if(e4[i].opt == '1'){
            Bit::clear(m - e4[i].pos_y + 1);
        }
    }
    for(int i = l;i <= r;i ++){
        e4[i] = t[i - l + 1];
    }
}
signed main(){
    n = read();
    for(int i = 1,x,y;i <= n;i ++){
        x = read(),y = read();
        x ++,y ++;
        x = N - x + 1;
        e1[++cnt] = {0,x,y,0,0,'1'};
        e2[cnt] = e1[cnt];
        e3[cnt] = e1[cnt];
        e4[cnt] = e1[cnt];
        num.push_back(y);
    }
    Q = read();
    while(Q --){
        char op;
        op = read_c();
        if(op == '0'){
            e1[++cnt] = {++ti,0,0,0,0,'1'};
            e1[cnt].x = read();
            e1[cnt].y = read();
            e1[cnt].x ++,e1[cnt].y ++;
            e1[cnt].x = N - e1[cnt].x + 1;
            e2[cnt] = e1[cnt];
            e3[cnt] = e1[cnt];
            e4[cnt] = e1[cnt];
            num.push_back(e1[cnt].y);
        }else if(op == '1'){
            e1[++cnt] = {++ti,0,0,++qcnt,0,'2'};
            e1[cnt].x = read();
            e1[cnt].y = read();
            e1[cnt].x ++,e1[cnt].y ++;
            e1[cnt].x = N - e1[cnt].x + 1;
            e2[cnt] = e1[cnt];
            e3[cnt] = e1[cnt];
            e4[cnt] = e1[cnt];
            num.push_back(e1[cnt].y);
            opt[qcnt] = '2';
        }else{
            e1[++cnt] = {++ti,0,0,++qcnt,0,'3'};
            e1[cnt].x = read();
            e1[cnt].y = read();
            e1[cnt].x ++,e1[cnt].y ++;
            e1[cnt].x = N - e1[cnt].x + 1;
            e2[cnt] = e1[cnt];
            e3[cnt] = e1[cnt];
            e4[cnt] = e1[cnt];
            num.push_back(e1[cnt].y);
            opt[qcnt] = '3';
        }
    }
    sort(num.begin(),num.end());
    num.erase(unique(num.begin(),num.end()),num.end());
    m = num.size();
    for(int i = 1;i <= cnt;i ++){
        e1[i].pos_y = lower_bound(num.begin(),num.end(),e1[i].y) - num.begin() + 1;
        e2[i].pos_y = e1[i].pos_y;
        e3[i].pos_y = e1[i].pos_y;
        e4[i].pos_y = e1[i].pos_y;
    }
    sort(e1 + 1,e1 + cnt + 1,[](node a,node b){
        if(a.ti != b.ti){
            return a.ti < b.ti;
        }
        if(a.x != b.x){
            return a.x < b.x;
        }
        return a.y < b.y;
    });
    sort(e2 + 1,e2 + cnt + 1,[](node a,node b){
        if(a.ti != b.ti){
            return a.ti < b.ti;
        }
        if(a.x != b.x){
            return a.x < b.x;
        }
        return a.y > b.y;
    });
    sort(e3 + 1,e3 + cnt + 1,[](node a,node b){
        if(a.ti != b.ti){
            return a.ti < b.ti;
        }
        if(a.x != b.x){
            return a.x > b.x;
        }
        return a.y < b.y;
    });
    sort(e4 + 1,e4 + cnt + 1,[](node a,node b){
        if(a.ti != b.ti){
            return a.ti < b.ti;
        }
        if(a.x != b.x){
            return a.x > b.x;
        }
        return a.y > b.y;
    });
    for(int i = 1;i <= qcnt;i ++){
        minn[i] = inf;
        maxx[i] = -inf;
    }
    Bit::build();
    cdq(1,cnt);
    for(int i = 1;i <= qcnt;i ++){
        if(opt[i] == '2'){
            write(minn[i]);
            putchar('\n');
        }else{
            write(maxx[i]);
            putchar('\n');
        }
    }
    return 0;
}
```

---


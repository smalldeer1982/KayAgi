# [USACO06OPEN] The Milk Queue G

## 题目背景

题目是经过简写保证不改变原有题意的题目。

## 题目描述

每早，FJ 的 $N$ 头奶牛都排成一列挤奶．一个个进到仓库，为提高速率，FJ 把整个挤奶过程划分成两道工序，FJ负责实行第一道，第二道由 Rob 完成。

如果某头牛先于另一头牛开始进行第一道工序，那么她同样先开始第二道工序。

FJ 发现，如果奶牛们按某种顺序排队进行挤奶，那么可能会在排队等待上多花很多的时间。比如，如果 FJ 要花很长时间才能完成某头奶牛的第一道工序，那么 Rob 就会浪费一段时间。反之如果 FJ 的工作完成得太快，Rob 面前会有很多奶牛排起长队。

请你计算按最优方式排队后最少需要多少时间才能挤完奶。对于每头奶牛，数据提供第一道工序的时间 $A_i$ 和第二道工序的时间 $B_i$。

## 说明/提示

#### 样例说明

把奶牛们按照 3，1，2  的顺序排队，这样挤奶总共花费 16 个单位时间．

$1\le N\le 25000$

$1\le A_i,B_i\le 2\times 10^4$

2025-06-03: 增加了一组 hack 数据

## 样例 #1

### 输入

```
3
2 2
7 4
3 5```

### 输出

```
16```

# 题解

## 作者：CloudDreamLake (赞：8)

先找出总时间的表达式：

$$\max_{i=1}^{n} \left( \sum_{j=1}^ia_j + \sum_{j=i}^n b_j \right)$$

> 解释：
> 
> 如果对其正确性怀疑，大概率是认为 $i$ 后面的 $b$ 时间无法密排，但此时无法密排的一段中 $a$ 时间一定是密排的（并且 $\max$ 会选到后一种方案）。

然后运用临项交换法的思路，可以推出 

$$\begin{align}\max(a_y, b_x)-a_y-b_x &< \max(b_y, a_x)-a_x-b_y\\-\min(a_y, b_x) &< -\min(b_y, a_x)\\\min(a_x, b_y) &< \min(b_x, a_y)\end{align}$$

你可能会认为：直接放入 `sort` 的 `cmp` 中即可。但这会**引发 `UB`**，因为它不满足传递性，因此也不是一个全序关系。

此时我们需要构造一种满足 $\min(a_x, b_y) < \min(b_x, a_y)$ 的全序比较关系，将数据分为两类：
+ $a_i < b_i$，按 $a_i$ 从小到大排序。
+ $a_i \geqslant b_i$，按 $b_i$ 从大到小排序。

---

## 作者：skyx (赞：5)

# P6243 [USACO06OPEN] The Milk Queue G-题解
## 简要题意

每头奶牛需要进行两道工序，FJ 完成第一道（耗时 $a_i$），Rob 完成第二道（耗时 $b_i$）。工序必须按顺序进行，且不能交叉执行。

决定奶牛的排队顺序，使得所有奶牛的工序完成的全程时间最短。

## 题目分析
### 考虑两头牛？
对于一类重点考虑选择顺序的问题，我们可以假设 A 在 B 前面比 B 在 A 前面更优，并分析关系。这种方法一般称作 exchange argument。

我们先考虑两个奶牛的情况：奶牛 1 为 $$(a_1, b_1)$$，奶牛 2 为 $$(a_2, b_2)$$。

- 若先安排奶牛 1，再安排奶牛 2，所需时间为：
  $$
  T_{1\rightarrow2} = a_1 + \max(b_1, a_2) + b_2
  $$
- 若顺序调换，先 2 后 1：
  $$
  T_{2\rightarrow1} = a_2 + \max(b_2, a_1) + b_1
  $$
我们希望选择更小的那个时间。

对两个表达式做展开比较：

> 这里有 $ \max(x,y)=x+y-\min(x, y) $，在两个数中减去较小的，剩下较大的。

$$
T_{1\rightarrow2} = a_1 + b_1 + a_2 + b_2 - \min(b_1, a_2)
$$
$$
T_{2\rightarrow1} = a_1 + b_1 + a_2 + b_2 - \min(b_2, a_1)
$$

若希望 $$T_{1\rightarrow2}<T_{2\rightarrow1}$$，则需：

$$
\min(b_1, a_2) > \min(b_2, a_1)
$$

**但是，这真的对吗？**

我们尝试这两组数据：
```
4
1 1
1 1
3 5
2 7
```

```
4
1 1
3 5
1 1
2 7
```
排列后的最终结果分别为：

```
1 1
1 1
2 7
3 5
```

```
1 1
3 5
1 1
2 7
```
排序方式不同，得到的答案也不同。

经过验证，我们发现这两种方式都符合 $\min(b_1, a_2) > \min(b_2, a_1)$，排序完成后任意交换相邻元素能使答案更优，那这个排序关系就是**错误的**。那为什么会这样呢？

先了解几个概念：

> 传递性是数学中描述二元关系的一个核心特性。它指的是：若在某集合 $X$ 上，元素 $a$ 与 $b$ 存在某种关系，且 $b$ 与 $c$ 也存在该关系，则 $a$ 与 $c$ 之间也必须存在这种关系。
> - 小于关系是传递的，因为如果 $a < b$ 且 $b < c$，那么 $a < c$。

> 有集合 $X$ 和一个二元关系 $R$，如果它们之间**没有确定的顺序或优劣关系**，我们就说 $a, b \in X$ 是不可比的。
> 
>在集合的子集包含关系 $\subseteq$ 中，$\{1\}$ 和 $\{2\}$ 是不可比的，因为：
>
> $\{1\} \nsubseteq \{2\},\quad \{2\}\nsubseteq \{1\}.$

我们可以通过上面的尝试发现，结果不同的主要原因是 `sort` 函数无法正确排序。我们知道，C++ 标准库要求用于排序的运算符必须满足严格弱序。
> 对于一个比较运算符，若满足以下四个条件，则称其是满足严格弱序的：
> - 非自反性
> - 非对称性
> - 传递性
> - 不可比性的传递性

在相关解答中已经证明，$\min(b_1, a_2) > \min(b_2, a_1)$ 是传递的，我们聚焦于于不可比性的传递性：

---
考虑这三个元素：
- $A = (5, 8) $ 
- $B = (2, 2)$ 
- $C = (4, 7)$


> 比较两个元素，看  
> $$
> \min(b_x, a_y) \quad \text{和} \quad \min(b_y, a_x)
> $$
> 谁大，谁小，是否相等。  
> 如果相等则**不可比**，否则**可比**，并以较小的那一方为“较小”的元素。

---

对 $A = (5, 8),B = (2, 2)$，有：

$$
\min(b_A, a_B) = \min(8, 2) = 2
$$
$$
\min(b_B, a_A) = \min(2, 5) = 2
$$

结果相等，**不可比**。

---

对 $B = (2, 2),C = (4, 7)$, 有：

$$
\min(b_B, a_C) = \min(2, 4) = 2
$$
$$
\min(b_C, a_B) = \min(7, 2) = 2
$$

结果相等，**不可比**。

---

对 $A = (5, 8),C = (4, 7)$，有：

$$
\min(b_A, a_C) = \min(8, 4) = 4
$$
$$
\min(b_C, a_A) = \min(7, 5) = 5
$$
$$
4 < 5 \Rightarrow A < C
$$

则 $A$ 和 $C$ **可比**。

---
这个例子清楚地说明：即使两个元素分别与第三个元素都不可比，它们之间也**可能是可比的**。因此，该关系的**不可比性不具备传递性**。

所以，通过 $\min(b_1, a_2) > \min(b_2, a_1)$ 这样的排序关系有失严谨。

### 考虑总时间？

考虑这三个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/q84a3zmg.png)

- 灰色是没有牛在当前工序的时间。

结合题意，我们能贪心地得出以下结论：

- 第一条工序不会停止，因为我们想让总时间最少的话，就应当让第一道工序源源不断加工产品，所以决定答案的是第二道工序的开始时间（也就是第一个任务在第一道工序的时间），以及停滞时间。

- 最坏的情况是什么呢？

  一个产品的 $b_i$ 很小，下一个产品的 $a_{i+1}$ 很大。  
所以，前一个产品完成时，**下一个产品的第一道工序还没完成**，就会导致第二道工序有停滞时间。

- 最好的情况是什么呢？

  一个产品的 $a_i$ 很小，但是 $b_i$ 很大。  
这样会有越来越多的产品在完成第一道工序后，等待第二道工序开始，**不会造成第二道工序停工等待**，从而提高效率。

综上，我们得到了排序的优先级：

1. 若 $a_i < b_i$，是**第一优先级**；
2. 若 $a_i = b_i$，是**第二优先级**；
3. 若 $a_i > b_i$，是**第三优先级**。

那对于每一个优先级内部，我们又要如何处理呢？

再回顾一下!

![](https://cdn.luogu.com.cn/upload/image_hosting/q84a3zmg.png)

考虑图中的第一、第二种方案，对第一优先级，我们要最小化第二道工序的开始时间，也就是最小化**第一个任务在第一道工序的时间**。

对于同优先级的其他任务，可以推广这个结论，让第一道工序尽快处理掉容易的任务，从而让第二道工序更早开始，避免等待。

对第二优先级，优先处理 $a_i$ 小的任务也能让流水线更快地“铺开”，避免前期积压。

而对于第三优先级，把 $b_i$ 小的任务排前面，会导致第二道工序很快就干完了，然后等前面的任务还没处理完，造成浪费，所以应推迟那些容易处理完的任务进入第二工序，避免在中间或最后浪费时间。

所以，我们完善了以下排序规则：
1. 若 $a_i < b_i$，是**第一优先级**，按照 $a_i$ 从小到大排序；
2. 若 $a_i = b_i$，是**第二优先级**，按照 $a_i$ 从小到大排序；
3. 若 $a_i > b_i$，是**第三优先级**，按照 $b_i$ 从大到小排序。

- 实际上，对于 $a_i = b_i$ 的情况，存在多种排序策略均是可以的。
## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
struct wu
{
	int a,b,id,lei;
} p[2000005];
bool cmp(wu q,wu w)
{

	if(q.lei!=w.lei)
	{
		return q.lei>w.lei;
	}
	else
	{
		if(q.lei>=0)
		{
			return q.a<w.a;
		}
		else return q.b>w.b;
	}
}
int main()
{
	int n;
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>p[i].a;
		cin>>p[i].b;
		p[i].id=i;
	}
	for(int i=1; i<=n; i++)
	{

		if(p[i].a<p[i].b) p[i].lei=1;
		if(p[i].a==p[i].b) p[i].lei=0;
		if(p[i].a>p[i].b) p[i].lei=-1;
	}
	sort(p+1,p+n+1,cmp);
	int ta=0;
	int tb=0;
	for(int i=1; i<=n; i++)
	{
		ta+=p[i].a;
		tb=max(ta,tb)+p[i].b;
	}
	cout<<tb<<endl;

	return 0;
}
```

---

## 作者：chenbs (赞：1)

来一个答案表达式的证明。

---

首先，总时间的表达式为 $\max \left( \sum_{k=1}^i a_k + \sum_{k=i}^{n} b_k \right)$，下面给出证明。

$n=1$ 时只有一只奶牛，显然成立。下面假设 $n=x-1$ 时成立，证明 $n=x$ 成立。

设 $\max \left( \sum_{k=1}^i a_k + \sum_{k=i}^{x-1} b_k \right) = \sum_{k=1}^p a_k + \sum_{k=p}^{x-1} b_k$，$\max \left( \sum_{k=1}^i a_k + \sum_{k=i}^{x} b_k \right) = \sum_{k=1}^q a_k + \sum_{k=q}^{x} b_k$。

![](https://cdn.luogu.com.cn/upload/image_hosting/87vkuv81.png)

见上图，红色表示新来的这只奶牛（第 $n$ 只）的安排：

+ 若 $\sum_{k=p}^{x} a_k < \sum_{k=p}^{x-1} b_k$，则新来的这只奶牛需要在两个工序之间等待一会，则 $q=n$，符合答案。

+ 若 $\sum_{k=p}^{x} a_k \ge \sum_{k=p}^{x-1} b_k$，则新来的这只奶牛不需要等待，则 $q=p$，符合答案。

由数学归纳法，可知答案的表达式对任意的 $n$ 都成立。

---

接下来就很套路了。对于 $i$ 和 $i+1$ 考虑临项交换，可得：

$$\max \left\{ a_i + b_i + b_{i+1}, a_i + a_{i+1} + b_{i+1} \right\} < \max \left\{ a_{i+1} + b_{i+1} + b_i, a_{i+1} + a_i + b_i \right\}$$

$$a_i + b_{i+1} + \max \left\{b_i, a_{i+1}\right\} < a_{i+1} + b_i + \max \left\{b_{i+1}, a_i\right\} $$

$$\min \left\{b_i, a_{i+1}\right\} < \min \left\{b_{i+1}, a_i\right\} $$

但是这个式子没有传递性，不能用于排序，所以需要另外构造一个式子满足它。

问题在于 $\min$ 不好处理，所以将奶牛分为两组，$a_i \le b_i$ 的组中，按照 $a_i$ 升序排序，$a_i > b_i$ 的组中，按照 $b_i$ 降序排序，就可以满足条件了。这个式子通过简单的代数不等式即可证明。

```cpp lines=7-10
#include<bits/stdc++.h>
using namespace std;
int n;
struct node {
	int a,b;
	bool operator < (const node &y) const {
		int g1=(a<=b), g2=(y.a<=y.b);
		if(g1!=g2) return g1>g2;
		else if(g1==1) return a<y.a;
		else return b>y.b;
	}
} a[100005];
long long ans,ap[25005],bs[25005];
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i].a>>a[i].b;
	sort(a+1,a+1+n);
	for(int i=1; i<=n; i++) ap[i]=ap[i-1]+a[i].a;
	for(int i=n; i>=1; i--) bs[i]=bs[i+1]+a[i].b;
	for(int i=1; i<=n; i++) ans=max(ans, ap[i]+bs[i]);
	cout<<ans<<'\n'; 
	return 0;
}
```

---


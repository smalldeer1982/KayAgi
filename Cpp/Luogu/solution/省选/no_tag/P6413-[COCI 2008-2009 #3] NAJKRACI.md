# [COCI 2008/2009 #3] NAJKRACI

## 题目描述

有一个含 $n$ 个点，$m$ 条边的**有向图**。

对于每一条边，求出它被任意两点的最短路径经过的次数对 $10^9+7$ 取模的值。

如果 $A, B$ 两点之间有多条最短路，每条最短路都要计算一遍。你可以参考样例 $4$ 中第 $3, 4$ 条边的输出来理解这句话。

## 说明/提示

#### 数据范围与约定
- 对于 $30\%$ 的数据，保证 $n\le 15$，$m\le 30$。
- 对于 $60\%$ 的数据，保证 $n\le 300$，$m\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 1.5\times 10^3$，$1\le m\le 5\times 10^3$，$a\neq b$，$1\le a,b\le n$，$1\le d\le 10^4$。
#### 说明
本题译自 [Croatian Open Competition in Informatics 2008/2009](https://hsin.hr/coci/archive/2008_2009) [Contest #3](https://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf) T6 NAJKRACI。

## 样例 #1

### 输入

```
4 3
1 2 5
2 3 5
3 4 5 
```

### 输出

```
3
4
3 ```

## 样例 #2

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8 
```

### 输出

```
2
3
2
1 ```

## 样例 #3

### 输入

```
5 8
1 2 20
1 3 2
2 3 2
4 2 3
4 2 3
3 4 5
4 3 5
5 4 20 
```

### 输出

```
0
4
6
6
6
7
2
6 ```

## 样例 #4

### 输入

```
4 4
1 2 1
2 3 1
1 3 2
3 4 1
```

### 输出

```
3
4
2
4```

# 题解

## 作者：hellhell (赞：7)

### 题目大意
题面已经很简洁了，这里不再赘述。
### 思路分析
定理1：对于一条最短路 $u$ -> $v$，它的任意一个子路径 $u_1$ -> $v_1$ 都是一条最短路。

证明：假设 $u_1$ -> $v_1$ 不是最短路，那么一定可以找到一条路径 $u_2$ -> $v_2$ 使得 $u$ -> $v$ 更短，与 $u$ -> $v$ 是最短路矛盾。

根据定理1，一张图 $G$，在固定源点 $S$ 时，可以得到一张子图 $G_1$ 使得 $G_1$ 上任意一条边都在 $S$ 到至少一个点的最短路径上，且不再 $G_1$ 上的边都不在 $S$ 到任意一个点的最短路上。我们称图 $G_1$ 为最短路图。

判断一条边是否在最短路图上，只需判断 $dis[u]+val[v] == dis[v]$ 是否成立。

求最短路图可以用 `SPFA` 来解决。

$dis[i]$ 表示距离，$vis[i]$ 表示是否入队，$book[i]$ 表示是否在最短路图中。

```cpp
void spfa(int s){
    memset(dis,0x3f,sizeof(dis));
    memset(vis,false,sizeof(vis));
    memset(book,false,sizeof(book));
    dis[s]=0;
    vis[s]=true;
    q.push(s);
    while(!q.empty()){
        int now=q.front();
        vis[now]=false;
        q.pop();
        for(int i=head[now];i;i=edge[i].next){
            int v=edge[i].to;
            if(dis[v]>dis[now]+edge[i].val){
                dis[v]=dis[now]+edge[i].val;
                if(!vis[v]){
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    for(int i=1;i<=m;i++){
        if(dis[edge[i].from]+edge[i].val==dis[edge[i].to])
            book[i]=true;
    }
}
```
定理2：任意的最短路图，一定不存在环。

证明：假设图中存在环 $u_1$ -> $u_2$ -> $u_3$ -> …… -> $u_n$ -> $u_1$，则有 $dis[u_1]+val[u_2] == dis[u_2]$，$dis[u_2]+val[u_3] == dis[u_3]$，

…… 

$dis[u_n]+val[u_1] == dis[u_1]$。

因为边权都为正数，则有 $dis[u_n]>dis[u_1]$，$dis[u_1]>dis[u_n]$。
矛盾。
 

求出最短路图后，考虑如何统计答案。

设 `cnt1[i]` 表示 $S$ 到 $i$ 点的最短路数量，`cnt2[i]` 表示 $i$ 点到终点的最短路数量。

那么对于一条边 $e(u,v)$，根据乘法原理，答案为 $cnt1[u]*cnt2[v]$。

但题目中源点和终点并没有给出，只枚举源点，并不能知道终点。根据定理2可以考虑对最短路图拓扑排序，然后按照拓扑序倒序求 $cnt2$。

具体来说，枚举顺序为拓扑序倒序，当前点为 $u$，$u$ 点指向 $v_1$，$v_2$，则有
$cnt2[u]=cnt2[v_1]+cnt2[v_2]$。

$topo$ 数组与 $tag$ 记录拓扑序。



```cpp
void TopoSort(int s){
    memset(ind,0,sizeof(ind));
    memset(cnt1,0,sizeof(cnt1));
    memset(cnt2,0,sizeof(cnt2));
    cnt1[s]=1;
    q.push(s);
    tag=0;
    for(int i=1;i<=m;i++){
        if(book[i])
            ind[edge[i].to]++;
        
    }
    while(!q.empty()){
        int now=q.front();
        q.pop();
        topo[++tag]=now;
        for(int i=head[now];i;i=edge[i].next){
            if(!book[i])
                continue;
            int v=edge[i].to;
            ind[v]--;
            if(ind[v]==0)
                q.push(v);
            cnt1[v]+=cnt1[now];
            cnt1[v]%=mod;
        }
    }
    for(int i=tag;i;i--){
        int now=topo[i];
        cnt2[now]++;
        for(int j=head[now];j;j=edge[j].next){
            if(!book[j])
                continue;
            int v=edge[j].to;
            cnt2[now]+=cnt2[v];
            cnt2[now]%=mod;
        }
    }
}
```



---

## 作者：神眷之樱花 (赞：2)

# 题面
[道路](https://www.luogu.com.cn/problem/P2505)

[My Blog](https://blog.csdn.net/init1064573673/article/details/116571091) 
# 题解
### 题意
对于每条道路，求出有多少条最短路经过它。
### 解析
先看看数据范围，不算大。

所以我们分别以每个点为起点，用SPFA求出每个点到源点的最短距离。

不难发现对于边 $(u,v,w)$，如果 $dis[u] + w = dis[v]$，那么这条边一定在源点到 $v$ 的最短路上。
而不满足这个条件的边，显然对答案毫无贡献，所以我们可以在跑完最短路后忽略不满足条件的这些边。

这样原图就变成了一副DAG图，因为不存在 $dis[u] + w = dis[v]$ ，且 $dis[v] + w = dis[u]$。

在DAG图上我们就可以跑拓扑排序了。对于每个点求出从源点到达它的方案数，再按照拓扑排序的逆序求出从后面的节点到达当前节点的方案数。

原因请看下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210509214202784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luaXQxMDY0NTczNjcz,size_16,color_FFFFFF,t_70#pic_center)
从源点到 $u$ 的方案数记为 $cnt1[u]$，从后面的节点到达 $v$ 的方案数记为 $cnt2[v]$ ，不难发现根据乘法原理，这条从 $u$ 到 $v$ 的边就有 $cnt1[u] \times cnt2[v]$ 条最短路经过了它。因为当前图只保留了在最短路上的边，这些方案数确实都是最短路，所以答案是正确的。
# 代码
不知道我按照正常的SPFA的写法为什么只能过40分，这份代码里面的SPFA的内容是参考了其它题解的写法的。

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define re register

using namespace std;

const int N = 1505,M = 5005;
const int mod = 1e9 + 7;

struct edge {
	int from,next,to,w;
}a[M];
int head[N],dis[N],ans[M],que[M << 1],n,m,a_size = 0;
bool vis[N],is[M];
inline void add(int u,int v,int w) {
	a[++a_size] = (edge){u,head[u],v,w};
	head[u] = a_size;
}
void SPFA(int s) {
    memset(dis,0x3f,sizeof(dis));
    memset(is,0,sizeof(is)); re int len;
    dis[que[len = 1] = s] = 0; vis[s] = true;
    for (re int i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (re int e = head[u],v; e; e = a[e].next)
            if (dis[u] + a[e].w < dis[v = a[e].to]) {
                dis[v] = dis[u] + a[e].w;
                if (!vis[v]) vis[que[++len] = v] = 1;
            }
    }
    for (re int i = 1; i <= m; i++)
        if (dis[a[i].from] + a[i].w == dis[a[i].to])
            is[i] = 1;
}
int deg[N],cnt1[N],cnt2[N],ord[N],len;
queue<int> q;
void tuopu(int s) {
	while(!q.empty()) q.pop();
	memset(deg,0,sizeof(deg));
	memset(cnt1,0,sizeof(cnt1));
	memset(cnt2,0,sizeof(cnt2)); len = 0;
	for(re int i = 1; i <= m; i++) if(is[i]) deg[a[i].to]++;
	q.push(s); cnt1[s] = 1;
	while(!q.empty()) {
		int x = q.front();
		q.pop(); ord[++len] = x;
		for(int i = head[x]; i; i = a[i].next) {
			if(!is[i]) continue;
			int y = a[i].to;
			cnt1[y] = (cnt1[y] + cnt1[x]) % mod;
			if(--deg[y] == 0) q.push(y);
		}
	}
	for(re int j = len; j >= 1; j--) {
		re int x = ord[j]; cnt2[x]++;
		for(re int i = head[x]; i; i = a[i].next) {
			if(!is[i]) continue;
			cnt2[x] = (cnt2[x] + cnt2[a[i].to]) % mod; 
		}
	}
}
inline int read() {
	re int x = 0,flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
	while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
	return x * flag;
}
int main() {
	n = read(),m = read();
	for(re int i = 1,u,v,w; i <= m; i++) {
		u = read(),v = read(),w = read();
		add(u,v,w);
	}
	for(re int i = 1; i <= n; i++) {
		SPFA(i); tuopu(i);
		for(re int j = 1; j <= m; j++)
			if(is[j]) ans[j] = (ans[j] + 1ll * cnt1[a[j].from] * cnt2[a[j].to] % mod) % mod;
	}
	for(re int i = 1; i <= m; i++) printf("%d\n",ans[i]);
	return 0;
}
```



---

## 作者：Mortidesperatslav (赞：1)

不错的题。

本题 dp 本身大约只有橙到黄题难度，不是那么难，所以就不讲了。

注意到 $n,m$ 比较小，我们考虑对于每一个 $i \in [1,n]$，以 $i$ 为起点跑一次 spfa 最短路。然后就能得到一个 DAG。

下面讲几个重点。

### 为什么一定能得到 DAG？

我们可以想一想，如果一个节点到其余节点的最短路上存在一个环，这说明什么？说明出现了负环，而这个图是正权图，所以一定不会存在最短路上有环的情况，于是就得到 DAG。

得到 DAG 后，跑一遍拓扑排序进行 dp 即可。

### 为什么要取模，感觉点数那么少，最短路数目不会很多啊？

我们考虑一下，一共有 $2n-2$ 条边，$i$ 号节点到 $i+1$ 号节点有两条边权相同的边，那么这个时候最短路径数目会指数“爆炸”，就是一个可怕的数目了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1000000007;
int n, m, dis[5141], in[5141];
long long f[5141], ff[5141], ans[5141];
int tpx[5141], js;
bool inq[5141], olw[5141];
struct node{
	int v, c, id;
};
struct edge{
	int u, v, c;
};
vector<node> G[5141];//图
vector<edge> E;//边集
queue<int> q;
queue<int> qq;
void spfa(int s){//对每个节点跑 spfa
    memset(dis, 0x3f, sizeof dis);
    memset(olw, 0, sizeof(olw));
    q.push(s);
    dis[s] = 0;
    while (!q.empty()){
    	int u = q.front();
    	q.pop();
    	inq[u] = 0;
        for (auto vv : G[u]){
			int v = vv.v, c = vv.c;
            if (dis[v] == -1 || dis[u] + c < dis[v]){
                dis[v] = dis[u] + c;
                if (!inq[v]){
                	inq[v] = 1;
                	q.push(v);
				}
            }
		}
    }
    for (int i = 0; i < m; i++)//记录最短路图
        if (dis[E[i].u] + E[i].c == dis[E[i].v])
            olw[i] = 1;
}
void topo_sort(int s) {//拓扑排序 dp
    memset(in, 0, sizeof in);
    memset(f, 0, sizeof f);
    memset(ff, 0, sizeof ff);
    qq.push(s);
    f[s] = 1;
    js = 0;
    for (int i = 0; i < m; i++) 
		if (olw[i])
			in[E[i].v]++;
    while (!qq.empty()) {//拓扑排序主体
    	int u = qq.front();
    	qq.pop();
    	tpx[++js] = u;
        for (auto vv : G[u]){
            if (!olw[vv.id])
				continue;
			int v = vv.v;
            in[v]--;
            if (!in[v])
            	qq.push(v);
            f[v] = (f[v] + f[u]) % mod;
        }
    }
  //  cerr <<"qwq\n"; 
    for (int i = js; i; i--) {
        int u = tpx[i];
		ff[u]++;
        for (auto vv : G[u]){
            if (!olw[vv.id])
				continue;
            ff[u] = (ff[u] + ff[vv.v]) % mod;
        }
    }
}
void solve(int s) {
    spfa(s);
    topo_sort(s);
    for (int i = 0; i < m; i++){
	//	cerr << i << "\n";
		if (olw[i])
			ans[i] = (ans[i] + (long long) 1 * f[E[i].u] * ff[E[i].v] % mod) % mod;//对于每条边进行计数
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    cin >> n >> m;
    for (int i = 0; i < m; i++){
    	int u, v, c;
    	cin >> u >> v >> c;
    	G[u].push_back({v, c, i});
    	E.push_back({u, v, c});
	}
    for (int i = 1; i <= n; i++)
		solve(i);
    for (int i = 0; i < m; i++)
    	cout << ans[i] << "\n";
}
```

---

## 作者：Maysoul (赞：1)

[原 P](https://www.luogu.com.cn/problem/P2505)

## 简化题意：

对于每一条边，求出它被任意两点的最短路经过的次数。

## 简述思路：

直观的，我们必须要求出任意两点之间的最短路，同时记录它经过的次数。

这个操作洛谷上有原题 [P1144](https://www.luogu.com.cn/problem/P1144)。

我们不难发现，有一些边在最短路中没有贡献，一条边只有在 $ dis_{u}+w=dis_{v} $ 的时候，在对答案做出贡献。

既然这些边没有贡献，我们不妨把它们删除掉。

举个例子，我们构建一个有向图如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/di9p9n02.png)

假设 $ 1 $ 号节点为起点，我们可以把那些没有用的边去掉，可以得到下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/9vojt7sq.png)

显然，只保留最短路径的图构成了一个 DAG。

这是必然的，因为最短路满足如下的两条性质：

1. 最短路中的每一条边都是一条最短路

证明：如果最短路 $ 1 $ 中有一条边不是最短路，那么就一定存在一条最短路$ 2 $，可以使最短路 $ 1 $ 更短，故每一条边都是一条最短路。

2. 最短路中不包含环路

证明：如果最短路中包含环路，因为题目已经指出边权都是正整数，所以不走环路一定比走环路更短，故最短路中不包含环路。

想到 DAG，这道题的思路就已经呼之欲出了。

我们在最短路中，已经正向跑出了每个点到起点的最短路径数量 $ cnt1 $。现在我们可以对着这个 DAG，再反向跑出每个点到终点的最短路径数量 $ cnt2 $，并更新答案即可。

## CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
long long ans[MAXN];
int n,m,s,t; 
struct node{
	int id;
	int dist;
	node(){	id=0;dist=0;}
	node(int c,int d){id=c;dist=d;}
	bool operator < (const node &x)const{return x.dist<dist;}
};
priority_queue<node> que;
struct linkstar{
	int to,from;
	int w,id;
	int next;
}edge[2*MAXN];
int head[MAXN];
long long cnt1[MAXN],cnt2[MAXN];
int dis[MAXN];
int vis[MAXN];
int escnt;
void add(int from,int to,int w,int id)
{
	edge[++escnt].from=from;
	edge[escnt].to=to;
	edge[escnt].w=w;
	edge[escnt].id=id;
	edge[escnt].next=head[from];
	head[from]=escnt;
}
vector<int> point;
void Dijkstra(int u)//正常的dijkstra+堆优化
{
	for (int i=1;i<=n;i++){
		dis[i]=INF;
		vis[i]=0;
	}
	dis[u]=0;
	cnt1[u]=1;
	que.push(node(u,0));
	while(que.size()){
		node cp=que.top();
		que.pop();
		if(vis[cp.id]) continue;
		vis[cp.id]=true;
		point.push_back(cp.id);
		for (int i=head[cp.id];i!=-1;i=edge[i].next){
			if(dis[edge[i].to]>dis[cp.id]+edge[i].w){
				dis[edge[i].to]=dis[cp.id]+edge[i].w;
				cnt1[edge[i].to]=cnt1[cp.id];
				que.push(node(edge[i].to,dis[edge[i].to]));
			}
			else if(dis[edge[i].to]==dis[cp.id]+edge[i].w){
				cnt1[edge[i].to]=(cnt1[edge[i].to]+cnt1[cp.id])%MOD;
			}
		}
	}
	
}
void toposort()//对DAG进行更新
{
	for (int i=point.size()-1;i>=0;i--){//反向跑图
		int u=point[i];
		cnt2[u]=1;
		for (int j=head[u];j!=-1;j=edge[j].next){
			int v=edge[j].to;
			int id=edge[j].id;
			if(dis[u]+edge[j].w==dis[v]){//寻找最短路径
				cnt2[u]=(cnt2[u]+cnt2[v])%MOD;
				ans[id]=(ans[id]+1ll*cnt1[u]*cnt2[v]%MOD)%MOD;//更新答案
			}
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	int x,y,w;
	cin>>n>>m;
	for (int i=1;i<=m;i++){
		cin>>x>>y>>w;
		add(x,y,w,i);
	}
	for (int i=1;i<=n;i++){
		Dijkstra(i);
		toposort();
		point.clear();
	}
	for (int i=1;i<=m;i++){
		cout<<ans[i]<<endl;
	}
	return 0;
}
```


---

## 作者：SalN (赞：1)

### 题目描述 

有一个含 $n$ 个点，$m$ 条边的有向图。

对于每一条边，求出它被任意两点的最短路径经过的次数对 $10^9+7$ 取模的值。

$n\leq1500,m\leq 5000$

### 题目解法

首先，我们枚举路径的起始 $s$，那么我们现在考虑固定源点的答案啦！

先跑一边最短路，求 $d[x]$ 表示 $s$ 到 $x$ 的最短路径长度，那么对于一条边  $(u,v,w)$ 如果 $d[u]+w=d[v]$，那么祂在 $s$ 当源的时候有用。我们整理出这些有用的边，这会是一个 DAG 图，有着可以拓扑的优秀性质！！！

我们考虑计算一条边 $(u,v)$ 在这里的方案数，那么就是 $f[u]*g[v]$。其中 $f[u]$ 是 $s$ 到 $u$ 的方案数，$g[v]$ 是 $v$ 到随便的方案数。这两个显然可以拓扑然后 dp 啦！具体而言，初始化 $f[s]=1$ 以及 $g[i]=1$，然后有 $(u,v)$ 的偏序就把 $u$ 的往 $v$ 里面加一遍 qwq

### lsy 的代码

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int> 
#define N 1510
#define M 5010
#define pb push_back
#define pi make_pair

using namespace std;

const int P=1e9+7;
int n, m, vis[N], d[N], u[M], v[M], w[M];
int inz[N], inf[N], ans[M], f[N], g[N];
vector<int> to[N], eg[N], ez[N], ef[N];
priority_queue<pii> q;
queue<int> qwq, awa;

void solve(int s) {
	for(int i=1; i<=n; ++i) {
		inz[i]=inf[i]=f[i]=g[i]=0;
		vis[i]=0, d[i]=1<<30;
        ez[i].clear(), ef[i].clear();
	}
    d[s]=0, q.push(pi(0,s));
    while(q.size()) {
        int x=q.top().second; q.pop();
        if(vis[x]) continue;
        vis[x]=1;
        for(int i=0; i<to[x].size(); ++i) {
            int y=to[x][i], v=eg[x][i];
            if(vis[y]) continue;
            if(d[x]+v<d[y]) {
                d[y]=d[x]+v;
                q.push(pi(-d[y],y));
            }
        }
    }
    for(int i=1; i<=m; ++i)
        if(d[u[i]]+w[i]==d[v[i]]) {
            ez[u[i]].pb(v[i]);
            ef[v[i]].pb(u[i]);
            inz[v[i]]++, inf[u[i]]++;
        }
    for(int i=1; i<=n; ++i) {
        if(inz[i]==0) qwq.push(i);
        if(inf[i]==0) awa.push(i); 
    }
    f[s]=1;
    while(qwq.size()) {
        int x=qwq.front(); qwq.pop();
        for(int i=0; i<ez[x].size(); ++i) {
            int y=ez[x][i];
            f[y]=(f[x]+f[y])%P;
            if(--inz[y]==0) qwq.push(y);
        }
    }
    for(int i=1; i<=n; ++i) g[i]=1;
    while(awa.size()) {
        int x=awa.front(); awa.pop();
        for(int i=0; i<ef[x].size(); ++i) {
            int y=ef[x][i];
            g[y]=(g[x]+g[y])%P;
            if(--inf[y]==0) awa.push(y);
        }
    }
    for(int i=1; i<=m; ++i)
        if(d[u[i]]+w[i]==d[v[i]]) {
            int lsy=f[u[i]]*g[v[i]]%P;
            ans[i]=(ans[i]+lsy)%P;
        }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    for(int i=1; i<=m; ++i) {
        cin >> u[i] >> v[i] >> w[i];
        to[u[i]].pb(v[i]);
        eg[u[i]].pb(w[i]);
    }
    for(int i=1; i<=n; ++i) solve(i);
    for(int i=1; i<=m; ++i)
        cout << ans[i] << endl;
    return 0;
}
```


---

## 作者：漠寒 (赞：1)

## 分析

计算出最短路后，一条边是最短路的一部分，当且仅当起点的 $f$ 值加上该边边权等于终点的 $f$ 值，所以跑最短路后，对 $m$ 条边进行判定，满足该条件的加入最短路图。

加入后进行拓扑排序，计算以该边作为终点的最短路个数 $cntz$，和该边作为起点的最短路 $cntq$，易证两子问题的计算互为倒序，拓扑排序只需跑起点到终点即可，跑的过程中记录顺序，在倒着顺序把 $cntz$ 加回来，最后将两值相乘，即为答案。

另外值得注意的是，因为是不断换起点跑最短路，dijkstra 的复杂度可能因 memset 过多而时间较长，spfa 会低一些，虽然本题时间上限很高，但当然越优越好。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
int n,m,head[1501],vis[1501],flag[5001],f[1501],cnt,ans[5001],sum[1501],cntm[1501],cntq[1501];
const int mod=1e9+7;
struct node{
	int to,w,fr,next;
}a[5001];
void read(int &res){
	char c;
	res=0;
	c=getchar();
	while(c<'0'||c>'9'){c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
}
priority_queue<pair<int,int> > q;
/*
inline void dijkstra(int qq){
	memset(vis,0,sizeof(vis));
	memset(flag,0,sizeof(flag));
	memset(f,127,sizeof(f));
	f[qq]=0;
	q.push(make_pair(0,qq));
	while(q.size()){
		int x=q.top().second;q.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(register int i=head[x];i;i=a[i].next){
			int v=a[i].to;
			if(f[v]>f[x]+a[i].w){
				f[v]=f[x]+a[i].w;
				q.push(make_pair(-f[v],a[i].to));
			}
		}
	}
	for(register int i=1;i<=m;++i){
		if(f[a[i].fr]+a[i].w==f[a[i].to])flag[i]=1;
	}
}
*/

int que[10001],len;

inline void spfa(int qq) {
    memset(f,127,sizeof(f));
    memset(flag,0,sizeof(flag));
    f[que[len=1]=qq]=0;
    for (register int i = 1; i <= len; i++) {
        int x=que[i];vis[x]=0;
        for (register int i=head[x];i;i=a[i].next){
        	int v=a[i].to;
            if(f[x]+a[i].w<f[v]){
            	f[v]=f[x]+a[i].w;
            	if(!vis[v])vis[que[++len]=v]=1;
			}
		}
    }
    for(register int i=1;i<=m;++i){
		if(f[a[i].fr]+a[i].w==f[a[i].to])flag[i]=1;//满足条件，进行标记 
	}
}

int qu[1501],tot;
inline void topu(int qq){
	memset(sum,0,sizeof(sum));
	memset(cntm,0,sizeof(cntm));
	memset(cntq,0,sizeof(cntq));
	for(register int i=1;i<=m;++i)if(flag[i])sum[a[i].to]++;
	cntm[qq]=1;
	qu[tot=1]=qq;
	for(register int i=1;i<=tot;++i){
		int x=qu[i];
		for(register int i=head[x];i;i=a[i].next){
			if(!flag[i])continue;
			int v=a[i].to;
			if(!--sum[v])qu[++tot]=v;
			cntm[v]=(cntm[v]+cntm[x])%mod;
		}
	}
	for(register int i=tot;i;i--){
		int x=qu[i];cntq[x]++;
		for(register int i=head[x];i;i=a[i].next){
			if(!flag[i])continue;
			cntq[x]=(cntq[x]+cntq[a[i].to])%mod;
		}
	}
}

inline void sol(int qq){
	spfa(qq);topu(qq);
	for(register int i=1;i<=m;++i){
		if(flag[i])ans[i]=(ans[i]+1ll*cntm[a[i].fr]*cntq[a[i].to]%mod)%mod;
	}
}

inline void add(int qq,int mm,int l){
	a[++cnt].fr=qq;
	a[cnt].next=head[qq];
	head[qq]=cnt;
	a[cnt].to=mm;
	a[cnt].w=l;
}
int main()
{
	read(n);read(m);
	for(int i=1;i<=m;i++){
		int x,y,j;
		read(x);read(y);read(j);
		add(x,y,j);
	}
	for(int i=1;i<=n;i++)sol(i);
	for(int i=1;i<=m;i++){
		printf("%d\n",ans[i]);
	}
	return 0;
}
```


---

## 作者：wangruibo20 (赞：0)

传送门：[[COCI2008-2009#3] NAJKRACI](https://www.luogu.com.cn/problem/P6413)

看到这个题，不由分说肯定要用 $n$ 遍 Dijkstra，求出每个点与点之间的最短路。

我们有一种暴力的做法计数：枚举两个点 $A$ 和 $B$ 和一条边 $e$，若 $e$ 在 $A$ 到 $B$ 的最短路上就加 $1$.

显然，这种做法时间复杂度为 $\mathcal O(n^3)$，根本承受不了。

考虑优化计数方法。计数时我们会枚举到很多不经过这条边的最短路，会白白浪费大量时间。

众所周知，Dijkstra 算法跑时所经过的边与点会组成一个 DAG，而 DAG 上的每一条边都是在某条最短路上的，用样例3举例：

首先我们原图为：

![](https://cdn.luogu.com.cn/upload/image_hosting/ojf1zlyw.png)

若从1开始跑 Dijkstra，得到的 DAG 就为：

![](https://cdn.luogu.com.cn/upload/image_hosting/erdge2by.png)

显然，此图中 $(1,3)$ 被经过数为 $1\times3=3$，$(3,4)$ 被经过数为 $2\times2=4$。

可以看出，此图中一条边被经过数等于这条边的起点以及之前所经过的点数乘上这条边的终点以及之后所经过的点数。

所以我们在每次做完 Dijkstra 后就来一遍拓扑排序，再进行计算（要把值加起来），时间复杂度就成功压到了 $\mathcal O(n^2\log_2m)$。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m,u[5005],head[1505],nxt[5005],qz[5005],to[5005],dis[1505],g[1505],f[1505],ans[5005],rd[1505];
const ll mod=1000000007;
bitset<5005>ff;
bitset<1505>vis;
struct node{
	ll dis,u;
	inline bool operator<(const node b)const{
		return dis>b.dis;
	}
};priority_queue<node>pq;
inline void tuopu(ll u){
	memset(g,0,sizeof g);
	memset(f,0,sizeof f);
	memset(rd,0,sizeof rd);
	for(ll i=1;i<=m;i++)if(ff[i])rd[to[i]]++;
	queue<ll>q;
	stack<ll>st;
	q.push(u);
	g[u]=1;
	while(!q.empty()){
		ll x=q.front();
		q.pop();
		st.push(x);
		for(ll i=head[x];i;i=nxt[i]){
			if(ff[i]){
				g[to[i]]=(g[x]+g[to[i]])%mod;
				--rd[to[i]];
				if(!rd[to[i]])q.push(to[i]);
			}
		}
	}while(!st.empty()){
		ll x=st.top();
		st.pop();
		f[x]=1;
		for(ll i=head[x];i;i=nxt[i])
			if(ff[i])f[x]=(f[x]+f[to[i]])%mod;
	}
}int main(){
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=m;i++){
		scanf("%lld%lld%lld",&u[i],&to[i],&qz[i]);
		nxt[i]=head[u[i]];
		head[u[i]]=i;
	}for(ll i=1;i<=n;i++){
		memset(dis,0x3f3f3f3f,sizeof dis);
		vis=0;
		ff=0;
		dis[i]=0;
		pq.push({0,i});
		while(!pq.empty()){
			ll u=pq.top().u;
			pq.pop();
			if(vis[u])continue;
			vis[u]=true;
			for(ll j=head[u];j;j=nxt[j]){
				if(dis[to[j]]>dis[u]+qz[j]){
					dis[to[j]]=dis[u]+qz[j];
					pq.push({dis[to[j]],to[j]});
				}
			}
		}for(ll j=1;j<=m;j++)
			if(dis[u[j]]+qz[j]==dis[to[j]])ff[j]=1;
		tuopu(i);
		for(ll j=1;j<=m;j++)
			if(ff[j])ans[j]=(ans[j]+f[to[j]]*g[u[j]]%mod)%mod;
	}for(ll i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```



---

## 作者：CQWDX (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2505)

不管怎么说，[双倍经验](https://www.luogu.com.cn/problem/P6413)。

---

题意很简洁了。

对于每个源点 $s$，先跑一遍 dijkstra。显然，若满足 $dis_v=dis_u+w_{u,v}$，则 $e(u,v)$ 一定在最短路上。

显然在 $w_{u,v}>0$ 时，不存在 $u,v$ 使得 $dis_u=dis_v+w_{u,v} \wedge dis_v=dis_u+w_{u,v}$。

因此，若将最短路径上的点从原图中取出，加入集合 $V$，其构成的图一定为 DAG $G(V,E)$。

可以考虑将其进行拓扑排序。

~~一般来说是可以在 dijkstra 中排序的。但是如果你硬要再写一遍也没人拦你~~

然后捏？

图上 dp。

设 $G(V,E)$ 的源点（集）为 $s'$，汇点（集）为 $t'$。

对于任意 $E_i:e(u,v)$，设 $out_i$ 为 $s'\to u$ 的方案数，$in_i$ 为 $v\to t'$ 的方案数。

根据乘法原理，得 $ans_i=in_i\times out_i$。

$out_i$ 好求。转移方程为 $out_u=out_u+out_v[dis_u+w_{u,v}=dis_v]\ \ e(u,v)\in E$。

事实上 $in_i$ 和 $out_i$ 的求法是一样的。

将 $v\to t'$ 这部分建个反图 $G'(V',E')$ 就可以达到同样的效果。

转移方程为 $in_u=in_u+in_v[dis_v+w_{u,v}=dis_u]\ \ e(u,v)\in E'$。

---

代码实现：

```cpp
#include <bits/stdc++.h>
typedef long long ll;
const int maxn = 15020, maxm = 50020;
const int inf = 998244853;
const int mod = 1e9 + 7;
class Solution {
	struct Graph {
		struct edge {
			int u, v, w, next;
		};
		int head[maxn], idx;
		edge e[maxm];
		void add(int x, int y, int z) {
			idx++; e[idx].u = x, e[idx].v = y, e[idx].w = z;
			e[idx].next = head[x], head[x] = idx;
		}
	} G, revG; 
	struct point {
		int u; ll dis;
		point(int a, ll b) {u = a, dis = b;}
		friend bool operator < (point a, point b) {
			return a.dis > b.dis;
		}
	};
	int n, m;
	std::vector <int> route;
	ll ans[maxn];
	ll dis[maxn];
	bool mk[maxn];
	ll in[maxn], out[maxn];
	void dijkstra(int st, Graph &G) {
		std::priority_queue <point> q;
		for(int i = 1; i <= n; i++) dis[i] = inf, mk[i] = 0;
		dis[st] = 0, q.push(point(st, 0));
		while(!q.empty()) {
			int u = q.top().u; q.pop();
			if(mk[u]) continue;
			mk[u] = 1; route.push_back(u);
			for(int j = G.head[u]; j; j = G.e[j].next) {
				int v = G.e[j].v, w = G.e[j].w;
				if(dis[v] > dis[u] + w) dis[v] = dis[u] + w, q.push(point(v, dis[v]));
			}
		}
	}
	void Count(int st) {
		dijkstra(st, G);
		for(int i = 1; i <= n; i++) in[i] = 0, out[i] = 0;
		in[st] = 1;
		for(auto v : route) {
			for(int i = revG.head[v]; i; i = revG.e[i].next) {
				int u = revG.e[i].v, w = revG.e[i].w;
				if(dis[v] == dis[u] + w) in[v] += in[u], in[v] %= mod;
			}
		}
		std::reverse(route.begin(), route.end());
		for(auto u : route) {
			out[u] = 1;
			for(int i = G.head[u]; i; i = G.e[i].next) {
				int v = G.e[i].v, w = G.e[i].w;
				if(dis[v] == dis[u] + w) out[u] += out[v], out[u] %= mod;
			}
		}
		route.clear();
		for(int i = 1; i <= m; i++) {
			int u = G.e[i].u, v = G.e[i].v, w = G.e[i].w;
			if(dis[v] == dis[u] + w) ans[i] += std::max(1ll, in[u]) * std::max(1ll, out[v]), ans[i] %= mod;
		}
	}
	public: void solve() {
		scanf("%d %d", &n, &m);
		for(int i = 1; i <= m; i++) {
			int u, v, w;
			scanf("%d %d %d", &u, &v, &w);
			G.add(u, v, w), revG.add(v, u, w);
		}
		for(int i = 1; i <= n; i++) Count(i);
		for(int i = 1; i <= m; i++) printf("%lld\n", ans[i]);
	}
} S;
int main() {
	S.solve();
	return 0;
}

```



---

## 作者：rq_kyz (赞：0)

# 【题解】 P6413 [COCI2008-2009#3] NAJKRACI

### 传送门

[P6413 [COCI2008-2009#3] NAJKRACI](https://www.luogu.com.cn/problem/P6413)

---

### 题意

有一个 $n$ 个点、$m$ 条边的有向图，对于每一条边，求出它被任意两点的最短路径经过的次数对 $10^9+7$ 取模的值。如果 $A,B$ 两点之间有多条最短路，每条最短路都要计算一遍。

---

### 分析

楼上很多大佬写的都是拓扑做法，今天来搞一个 DFS 做法。

本题的暴力做法为：从每个点出发跑 Dijkstra，时间复杂度 $O(n^2\log_2n)$。记节点 $x$ 到节点 $y$ 的最短路长度为 $dis_{x,y}$，方案数为 $cnt_{x,y}$。然后枚举一条边和两个点，设这条边为 $u\to v$，边权为 $len$，两个节点分别为 $st$ 和 $ed$，判断这两个节点的最短路有没有经过这条边，即 $dis_{st,u}+len+dis_{v,ed}$ 是否等于 $dis_{st,ed}$。如果相等，则 $ans_{u\to v}+=cnt_{st,u}\times cnt_{v,ed}$（因为最短路可能不止一条，所以需要记录 $cnt_{x,y}$，具体计算方法详见代码）；否则进行下一次循环。时间复杂度 $O(n^2m)$，总时间复杂度 $O(n^2m)$。

显然，本题 $O(n^2m)$ 的时间肯定会爆炸。但是我们注意到，跑 $n$ 遍 Dijkstra 的时间只有 $O(n^2\log_2n)\approx23739180$，所以预处理 $dis_{x,y}$ 和 $cnt_{x,y}$ 的过程可以不变，需要优化的只是记录答案。那么，到底哪些最短路才会经过我当前这条边呢？

如下图：

![](https://s11.ax1x.com/2023/12/25/piH6l1f.png)

这张图是从节点 $st$ 出发的 Dijkstra DAG 图。设 $v$ 后面的节点数量为 $son_{st,v}$，可以看到，从 $st$ 出发的最短路有 $cnt_{st,u}\times son_{st,v}$ 条是经过边 $u\to v$ 的。而怎么计算 $son_{st,x}$ 呢？我们可以先把这张 DAG 图记录下来，然后在上面跑 DFS，这样便可计算 $son_{st,x}$。当然，既然都跑 DFS 了，我们就不必再进行循环来更新每一条边，只需要在 DFS 的时候更新答案。

具体的，我们先循环 $st$。对于每一个 $st$，先跑一遍 Dijkstra，记录 $dis_{st,x}$ 和 $cnt_{st,x}$。接下来进行 DFS。当到达了点 $u$，我们首先判断是否已经遍历过。如果没有，则从这个点出发，循环它出度的每一条边（不需要再建一遍图，我们可以通过上面提到的判断条件来判断每一条边是否在 DAG 图中），然后更新每一条边被经过的次数，在循环时需要同时更新 $son_{st,u}$。

编码细节：因为从一个 $st$ 跑 Dijkstra 和 DFS 时与其他节点出发的 Dijkstra 和 DFS 没有关系，只是每条边的经过次数需要全局记录，所以 $dis_{st,x}$、$cnt_{st,x}$ 和 $son_{st,x}$ 全部只需要保留一维，即 $dis_x$、$cnt_x$ 和 $son_x$。

---

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll p=1e9+7;
ll a[5001];//全局记录每一条边的经过次数
ll last[1501];//链式前向星
struct s{
	ll t,to,l;
}nxet[5001];
ll cd=0;
void lj(ll x,ll y,ll l){
	nxet[++cd].t=last[x];
	nxet[cd].to=y;
	nxet[cd].l=l;
	last[x]=cd;
}
ll dis[1501];//Dijkstra
bool vis[1501];
ll cnt[1501];
struct s2{
	ll x,l;
}h[5001];
ll len=1;
bool f(s2 num1,s2 num2){
	return num1.l>num2.l;
}
void dijkstra(ll s){
	memset(dis,0x7f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(cnt,0,sizeof(cnt));
	dis[s]=0;
	cnt[s]=1;
	h[0]={s,0};
	len=1;
	while(len){
		ll x=h[0].x;
		pop_heap(h,h+len,f);
		len--;
		if(vis[x])
			continue;
		vis[x]=1;
		for(ll j=last[x];j;j=nxet[j].t){
			ll y=nxet[j].to;
			if(dis[y]>dis[x]+nxet[j].l){
				dis[y]=dis[x]+nxet[j].l;
				cnt[y]=cnt[x];
				h[len].x=y;
				h[len++].l=dis[y];
				push_heap(h,h+len,f);
			}
			else if(dis[y]==dis[x]+nxet[j].l)
				cnt[y]+=cnt[x];
		}
	}
}
bool t[1501];//DFS
ll son[1501];
void dfs(ll x){
	if(t[x])
		return;
	t[x]=1;
	son[x]=1;
	for(ll j=last[x];j;j=nxet[j].t){
		ll y=nxet[j].to,l=nxet[j].l;
		if(dis[y]==dis[x]+l){
			dfs(y);
			a[j]=(a[j]+cnt[x]*son[y]%p)%p;
			son[x]+=son[y];
		}
	}
}
int main(){
	ll n,m;
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=m;i++){
		ll x,y,l;
		scanf("%lld%lld%lld",&x,&y,&l);
		lj(x,y,l);
	}
	for(ll st=1;st<=n;st++){//循环以每一个节点为开始跑Dijkstra和DFS
		dijkstra(st);
		memset(t,0,sizeof(t));
		memset(son,0,sizeof(son));
		dfs(st);
	}
	for(ll i=1;i<=m;i++)
		printf("%lld\n",a[i]);
	return 0;
}
```

### 双倍经验

[P2505 [HAOI2012] 道路](https://www.luogu.com.cn/problem/P2505)。

---

## 作者：i_love_xqh (赞：0)

# 题目链接

[[COCI2008-2009#3] NAJKRACI ](https://www.luogu.com.cn/problem/P6413)。

# 分析

## 题目大意

给出 $n$ 个点，$m$ 条有向边的图，求出每条边被**任意**两点间**所有**最短路经过了多少次。

## 题目分析

### Part 1——常规思路

对于每一条边，两个端点分别为 $x,y$，权值为 $z$。枚举任意两个点 $u$ 与 $v$，如果 $dis_{u,v}=dis_{u,x}+z+dis_{y,v}$（其中 $dis_{i,j}$ 表示 $i\sim j$ 的最短距离），则代表这条边在 $x\sim y$ 的这条最短路上，然后统计次数即可。

### Part 2——分析

单从时间复杂度上来说，用 `dijkstra` 预处理任意两个点之间的最短距离有 $O(n\times(n+m)\log_n)$，然后枚举边与任意两点有 $O(m\times n^2)$，很容易发现，后面一个会超时。

再从算法正确性角度来说，虽可以判断这条边是否在最短路上，但对于两点间有多条最短路的情况来说，就会少算，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/250afp3f.png)

比如说 $1-2$ 的这条边，当点对枚举到 $1,5$ 时，发现 $1\sim5$ 的两条最短路都包含了它，但是却只算了一遍。

综上，这只是对本题的初步了解。

### Part 3——正解

对于一条边 $u-v$，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ani0vg9e.png)

我们可以从任意一点跑一遍 `dijkstra`，图中为从 $x$ 点出发的所有最短路（虚线及实线）。我们可以在跑 `dijkstra` 的过程中，算出 $x$ 到每个点有几条最短路。如图中 $x\sim u$ 的虚线部分，假如说 $x\sim u$ 有 $cnt_u$ 条最短路，那我们只需求出最短路上 $v$ 点以后（含 $v$ 点）有多少个点，假如说有 $sum_{v}$ 个，那么这条边在以 $x$ 点出发的所有最短路中，被经过了 $cnt_u\times sum_v$ 次。

可以通过一个例子更直观地理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/onzn155p.png)

如图，是以 $1$ 为起点的最短路的图，以 $4-5$ 的这条边为例，$1\sim 4$ 有两条最短路，$cnt_4=2$，$5$ 以后（含 $5$）共有 $3$ 个点，$sum_5=3$，所以 $4-5$ 这条边被经过了 $cnt_4\times sum_5=2\times 3=6$ 次，（$1-5:2;1-7:2;1-6:2$）。

### Part 4——分析及实现

首先时间复杂度，以每个点跑最短路 $O(n\times(n+m)\log_n)$，不会超时。

再看如何实现。

- 求 $cnt_u$。求以点 $x$ 为起点，到 $u$ 的最短路的数量可以参考 [P1144 最短路计数 ](https://www.luogu.com.cn/problem/P1144)。具体为，`dijkstra` 过程中，如发现 $dis_v>dis_u+z$，则将 $cnt_v$ 设为 $cnt_u$，如发现 $dis_v=dis_u+z$，则将 $cnt_v$ 加上 $cnt_u$。初始为 $cnt_x=1$。

- 求 $sum_v$ 及求和。因为已经通过 `dijkstra` 求出每个点到 $x$ 的最短距离，那我们就可以验证一条边是否在最短路中。可以通过 `dfs`，看一个点 $u$ 的所有临边 $u-v$，如果 $dis_u+z=dis_v$，则代表此边在最短路中，那么算最短路中 $v$ 及 $v$ 以后的点数，即可再次 `dfs(v)`，求出 $sum_v$，然后 $sum_u=sum_u+sum_v$。然后只需在枚举完临边后，给目前该点 $u$，$sum_u=sum_u+1$（自己）。至于求和，只需在 `dfs` 过程中，如果发现 $u-v$ 在最短路中，那么假如说这条边编号为 $i$，那么 $ans_i=ans_i+cnt_u\times sum_v$。

最后按照顺序，输出 $ans_i$ 即可，别忘了对 $10^9+7$ 取模。

## $AC\,CODE$
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
struct node{
   	ll y,z,next,id;
}e[5010];
ll cnt,elast[1510];//链式前向星
void add(ll x,ll y,ll z){
   	e[++cnt].y=y;
   	e[cnt].z=z;
   	e[cnt].next=elast[x];
   	e[cnt].id=cnt;
   	elast[x]=cnt;
}//建边
struct PQnode{
   	ll u,dis;
};
bool operator<(PQnode a,PQnode b){
   	return a.dis>b.dis;
}
priority_queue<PQnode>pq;
ll Ct[1510],Tc[1510],CT[5010];//Ct[i]即cnt[i]，Tc[i]即sum[i]，CT[i]即ans[i]
ll dis[1510],x[5010],y[5010],z[5010],mod=1e9+7;
bool vis[1510];
void dfs(ll u){
   	if(Tc[u])return;//判断这个点是否已经遍历过，否则可能会多算
   	for(ll i=elast[u];i;i=e[i].next){
    	ll v=e[i].y;
    	if(dis[v]==dis[u]+e[i].z){
    		dfs(v);
    		CT[e[i].id]+=Ct[u]*Tc[v]%mod;//实现2
    		CT[e[i].id]=CT[e[i].id]>=mod?CT[e[i].id]-mod:CT[e[i].id];//取模
    		Tc[u]+=Tc[v];//实现2
    	}
   	}
    Tc[u]++;//实现2
}
int main(){
   	ll n,m;
   	scanf("%lld%lld",&n,&m);
   	for(ll i=1;i<=m;i++){
   		scanf("%lld%lld%lld",&x[i],&y[i],&z[i]);
   		add(x[i],y[i],z[i]);
   	}
   	for(ll a=1;a<=n;a++){//对每个点跑 dijkstra
    	for(ll i=1;i<=n;i++)dis[i]=1e18,vis[i]=false,Ct[i]=0;//初始化
    	dis[a]=0;
    	Ct[a]=1;
    	pq.push({a,0});
    	while(!pq.empty()){
    		ll u=pq.top().u;
    		pq.pop();
    		if(vis[u])continue;
   			vis[u]=true;
    		for(ll i=elast[u];i;i=e[i].next){
    			ll v=e[i].y;
    			if(dis[v]>dis[u]+e[i].z){
    				Ct[v]=Ct[u];//实现1
    				dis[v]=dis[u]+e[i].z;
    				pq.push({v,dis[v]});
   				}
   				else if(dis[v]==dis[u]+e[i].z){
   					Ct[v]+=Ct[u];//实现1
   				}
   			}
   		}//标准 dijkstra
   		for(ll i=1;i<=n;i++)Tc[i]=0;//清零
   		dfs(a);
   	}
   	for(ll i=1;i<=m;i++){
   		printf("%lld\n",CT[i]);//输出答案
    }
    return 0;
}
```

---

## 作者：rechenz (赞：0)

之前没有接触过最短路图，退役前正好趁这道题学习一下。

其实最短路图没有多少东西，但是考到的时候就很有用 ~~废话~~。

首先对于一张图来说，以一个点来跑单源最短路的话，那么这个起点到所有点的最短路必定构成一张 $\texttt{DAG}$，那么这就是很优秀的，但是如果我们更极端一点，用奇怪的方式规定（当然也可能直接说）两点间的最短路有且只有一条，那么我们跑出来的就变成了一颗最短路树。

来看这道题，题面非常简介，发现这道题中的边如果不被任何最短路经过的话便是毫无作用的，所以我们跑出最短路图，然后便是用拓扑排序在 $\texttt{DAG}$ 上进行递推计数。

因为题中的数据范围很小，所以我们暴力地枚举起点，以枚举的起点跑单源最短路，然后对跑出来的 $\texttt{DAG}$ 进行答案累加就可以了。

但是要注意一点，我们的 $\texttt{DAG}$ 要进行反拓扑序，因为我们记录的是以某一点为起点的 $\texttt{DAG}$，不反过来跑的话记的数是错的。

然后求哪些边是最短路经过的边的时候其实用上了dp回溯（因为最短路算法本质就是动态规划嘛），我们只需要枚举边，然后判断是否 $dis[v]=dis[x]+e[i].wide$ 就可以了。

然后对于跑最短路因为没有负权边所以我用的是堆优化 $\rm Dijkstra$。

复杂度分析：$\rm O(n^2logn+n^2)$ 理论实测均可过。

（因为我也是才学所以代码有所借鉴其他题解）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1505;
const int mod=1e9+7;
int n,m,head[N],cnt;

struct Edge{
    int to;
    int next;
    int wide;
}e[5005];

void adding(int u,int v,int w){
    e[++cnt].to=v;
    e[cnt].wide=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}

int cnt1[N],cnt2[N],dis[N],vis[N],ans[5005];
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;
void dij(int s){
    memset(cnt1,0,sizeof cnt1);
    memset(dis,127,sizeof dis);
    memset(vis,0,sizeof vis);
    dis[s]=0;
    cnt1[s]=1;
    q.push(make_pair(dis[s],s));
    vector<int>dot;
    while(q.size()){
        int x=q.top().second;
        q.pop();
        if(vis[x]) continue;
        vis[x]=1;
        dot.push_back(x);
        for(int i=head[x];i;i=e[i].next){
            int v=e[i].to;
            if(dis[v]>dis[x]+e[i].wide){
                dis[v]=dis[x]+e[i].wide;
                cnt1[v]=cnt1[x];
                q.push(make_pair(dis[v],v));
            }else if(dis[x]+e[i].wide==dis[v]){
                cnt1[v]+=cnt1[x];
            }
        }
    }
    reverse(dot.begin(),dot.end());
    for(auto x:dot){
        cnt2[x]=1;
        for(int i=head[x];i;i=e[i].next){
            int v=e[i].to;
            if(dis[v]==dis[x]+e[i].wide){
                cnt2[x]=(cnt2[x]+cnt2[v])%mod;
                ans[i]+=1ll*cnt1[x]%mod*cnt2[v]%mod;
                ans[i]%=mod;
            }
        }
    }
}

signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=m;i++){
        int s1,s2,s3;
        scanf("%lld%lld%lld",&s1,&s2,&s3);
        adding(s1,s2,s3);
    }
    for(int i=1;i<=n;i++){
        dij(i);
    }
    for(int i=1;i<=m;i++){
        printf("%lld\n",ans[i]);
    }
    return 0;
}
```


---

## 作者：Coros_Trusds (赞：0)

# 题目大意

给定一个有向图，对于每条道路，求出有多少条最短路经过它。答案可能很大，对 $10^9+7$ 取模。

# 题目分析

观察到 $n$ 的数据范围足够跑 $n^2$ 了，所以我们来个暴力算法：

以每个点为原点 $st$ 跑一边 $\rm Spfa$，如果存在一条边 $dis[u]+w=dis[v]$ 那么边 $(u,v)$ 在最短路径上。

接下来我们可以排除掉那些不在最短路径上的边了。

但是怎么求经过某条道路的次数呢？令 $cnt1[u]$ 表示 $st$ 到 $u$ 的最短路径数，$cnt2[v]$ 表示从点 $v$ 出发的最短路径数，根据乘法原理，这条边 $(u,v)$ 的单次经过次数为 $cnt1[u]\times cnt2[v]$，总共的经过次数即为把所有点都当做一次原点跑出的结果之和。

可以发现可以轻易判断出每条边是否在最短路径上，因为 $dis$ 容易求。$cnt1,cnt2$ 则跑一次拓扑排序就求出来了。

存边可以用 `tuple` 存。

**注意多测要清空！！！（因为会把每个点都当做源点跑一次 $\rm Spfa$ 和拓扑排序）**

# 代码

```cpp
//2022/4/19
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <tuple>
#include <queue>
#define enter putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;
typedef tuple<int,int,int> TII;

const int N = 5005;
struct Gragh {
	int v,w,nxt;
} gra[N];
int head[N],dis[N],cnt1[N],cnt2[N],ans[N],in[N],que[N];
bool in_que[N],in_path[N];
TII edges[N];
int n,m,idx;
inline void add(int u,int v,int w) {
	gra[++ idx].v = v,gra[idx].w = w,gra[idx].nxt = head[u],head[u] = idx;
}
inline void spfa(int st) {
	mst(dis,0x3f),mst(in_que,false),mst(in_path,false);
	dis[st] = 0,in_que[st] = true;
	queue<int>q;
	q.push(st);
	while (!q.empty()) {
		int u = q.front();q.pop();
		in_que[u] = false;
		for (register int i = head[u];i;i = gra[i].nxt) {
			int v = gra[i].v,w = gra[i].w;
			if (dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
				if (!in_que[v]) {
					in_que[v] = true;
					q.push(v);
				}
			}
		}
	}
}
inline void topsort(int st) {
	mst(cnt1,0),mst(cnt2,0),mst(in,0),mst(que,0);
	int cnt = 0;
	for (register int i = 1;i <= m; ++ i) {
		if (in_path[i]) {
			in[get<1>(edges[i])] ++;
		}
	}
	cnt1[st] = 1;
	queue<int>q;
	q.push(st);
	while (!q.empty()) {
		int u = q.front();q.pop();
		que[++ cnt] = u;
		for (register int i = head[u];i;i = gra[i].nxt) {
			int v = gra[i].v;
			if (in_path[i]) {
				cnt1[v] = MOD(cnt1[v] + cnt1[u]);
				in[v] --;
				if (!in[v]) q.push(v);
			}
		}
	}
	for (register int i = cnt;i >= 1; -- i) {
		int u = que[i];
		cnt2[u] ++;
		for (register int j = head[u];j;j = gra[j].nxt) {
			if (in_path[j]) {
				cnt2[u] = MOD(cnt2[u] + cnt2[get<1>(edges[j])]);
			}
		}
	}
}
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	n = read(),m = read();
	for (register int i = 1;i <= m; ++ i) {
		int u = read(),v = read(),w = read();
		add(u,v,w);
		edges[i] = make_tuple(u,v,w);
	}
	for (register int i = 1;i <= n; ++ i) {
		spfa(i);
		for (register int j = 1;j <= m; ++ j) {
			if (dis[get<0>(edges[j])] + get<2>(edges[j]) == dis[get<1>(edges[j])]) {
				in_path[j] = true;
			}
		}
		topsort(i);
		for (register int j = 1;j <= m; ++ j) {
			if (in_path[j]) {
				ans[j] = MOD(ans[j] + cnt1[get<0>(edges[j])] * cnt2[get<1>(edges[j])]);
			}
		}
	}
	for (register int i = 1;i <= m; ++ i) printf("%d\n",ans[i]);

	return 0;
}
```

---

## 作者：Stinger (赞：0)

观察数据范围，发现这题完全可以跑 $n$ 遍dij。

那对于每一遍dij我们怎么统计答案呢？

设当前dij计算以 $source$ 为源点的单源最短路径。

考虑重新建图。对于一条边 $u\rightarrow v$，若边权为 $w$，如果它没有被任意一条最短路经过（我们令 $dis_i$ 表示 $source$ 到 $i$ 最短路长度，显然若 $dis_u+w>dis_v$，则它没有被任意一条最短路经过），则不把它加入新的图，否则加入。剩下的图一定是由被以 $source$ 作为源点的最短路**经过了至少一次的点。** 可以发现，剩下的图**一定是DAG**。这个结论很显然。

在剩下的DAG上，我们只需要统计一条边被从 $source$ 开始的所有路径经过了多少次。$In_i$ 表示以 $source$ 为起点，$i$ 作为终点的路径数，$Out_i$ 表示以 $i$ 作为起点的路径数。不难发现，对于所有满足存在一条从 $j$ 到 $i$ 的边的点 $j$，$In_i=\sum In_j$。同样的，对于所有满足存在一条从 $i$ 到 $j$ 的边的点 $j$，$Out_i=\sum Out_j$。

需要对这个DAG进行拓扑排序。幸运的是，Dijkstra的节点出队顺序本身就是该DAG的一个拓扑序列。比如 $source=1$，我节点出优先队列的顺序是 $1,4,2,5,3$，那么这个DAG拓扑序就是 $1,4,2,5,3$。计算 $In$ 按照拓扑序从小到大计算，由拓扑序小的推拓扑序大的，$Out$ 则按照拓扑序从大到小计算，由拓扑序大的推拓扑序小的。

# $Code$

```cpp
#include <cstdio>
#include <queue>
#include <cstring>

inline int max(const int x, const int y) {return x > y ? x : y;}
typedef std::pair<int, int> PII;
std::priority_queue<PII, std::vector<PII>, std::greater<PII> > q;
const int MOD = 1e9 + 7;
struct Edge {
	int from, to, w, nxt;
	bool mark;
} e[5001];
int head[1501], dis[1501], In[1501], Out[1501], top[1501], ans[5001], tot, toptot, n;
bool done[1501];
inline void AddEdge(const int u, const int v, const int w) {
	e[++ tot].to = v, e[tot].from = u, e[tot].w = w, e[tot].nxt = head[u], head[u] = tot;
}

inline void Dijkstra(const int source) {
	memset(dis, 0x3f, sizeof dis);
	memset(done, 0, sizeof done);
	memset(In, 0, sizeof In);
	memset(Out, 0, sizeof Out);
	toptot = 0;
	while (q.size()) q.pop();
	for (int i(1); i <= tot; ++ i) e[i].mark = false;
	q.push(std::make_pair(dis[source] = 0, source));
	while (q.size()) {
		int u(q.top().second);
		q.pop();
		if (done[u]) continue;
		done[u] = true;
		top[++ toptot] = u;
		for (int i(head[u]); i; i = e[i].nxt) {
			int v(e[i].to);
			if (dis[u] + e[i].w < dis[v])
				q.push(std::make_pair(dis[v] = dis[u] + e[i].w, v));
		}
	}
	for (int i(1); i <= tot; ++ i)
		if (dis[e[i].from] + e[i].w == dis[e[i].to]) e[i].mark = true;
	for (int i(toptot); i; -- i) {
		for (int j(head[top[i]]); j; j = e[j].nxt) if (e[j].mark)
			Out[top[i]] += Out[e[j].to];
		++ Out[top[i]];
	}
	In[source] = 1;
	for (int i(1); i <= toptot; ++ i) {
		for (int j(head[top[i]]); j; j = e[j].nxt) if (e[j].mark)
			In[e[j].to] += In[top[i]];
	}
	for (int i(1); i <= tot; ++ i)
		if (e[i].mark) ans[i] += 1LL * max(1, In[e[i].from]) * max(1, Out[e[i].to]) % MOD, ans[i] %= MOD;
}

int main() {
	int m;
	scanf("%d%d", &n, &m);
	for (int i(1); i <= m; ++ i) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		AddEdge(u, v, w);
	}
	for (int i(1); i <= n; ++ i) Dijkstra(i);
	for (int i(1); i <= tot; ++ i) printf("%d\n", ans[i]);
}
```

---


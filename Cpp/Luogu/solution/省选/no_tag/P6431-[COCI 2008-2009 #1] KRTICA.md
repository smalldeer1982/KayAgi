# [COCI 2008/2009 #1] KRTICA

## 题目描述

有一棵 $n$ 个点的树，边权都为 $1$。

现在想删去一条边，增加一条边，使得最远的两个点距离最短。

## 说明/提示

#### 数据规模与约定
- 对于 $40\%$ 的数据，保证 $n\le 30$。
- 对于 $70\%$ 的数据，保证 $n\le 3\times 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n \le 3\times 10^5$，$1\le a,b\le n$。

---

#### 计分标准

- 如果输出的第一行不正确，得 $0$ 分。
- 如果输出得第一行正确，但是剩下的数字不正确或数量不足四个，得对应测试点 $70\%$ 的分数。
- 如果输出第一行正确，且给出的方案是可行且正确的，得到对应测试点 $100\%$ 的分数。

---
#### 说明
本题译自 [Croatian Open Competition in Informatics 2008/2009](https://hsin.hr/coci/archive/2008_2009) [Contest #1](https://hsin.hr/coci/archive/2008_2009/contest1_tasks.pdf) T6 KRTICA。

SPJ provided by @Tweetuzki 

## 样例 #1

### 输入

```
4
1 2
2 3
3 4 ```

### 输出

```
2
3 4
4 2 
```

## 样例 #2

### 输入

```
7
1 3
2 3
2 7
4 3
7 5
3 6 
```

### 输出

```
3
2 3
7 3 ```

# 题解

## 作者：EityDawn (赞：1)

# 思路：

题意：给定一棵树，断开一条边，新加一条边使得新树的直径最小。

来个数据结构暴力求解的题解。

直径的性质：令 $F(x)$ 为点集 $x$ 的直径的两个端点，对于点集 $S$ 与点集 $T$，$F(S\cup T)\subseteq F(S)\cup F(T)$。

说直白点，就是给你两棵树，一棵树的直径端点是 $(x1,y1)$，另一棵是 $(x2,y2)$，加边合并这两棵新树，新直径的端点是四个点中的两个。

证明：若新树的直径不为两个原直径，那么新直径过连接边，两端点是距离连接点最远的两个端点，即两原树的直径端点之一。

所以求 $F(x)$ 是非常好做的，只需要写一个合并函数：

```cpp
inline Dia merge(Dia x,Dia y)
{
    int lx=x.l,rx=x.r,ly=y.l,ry=y.r;
    int dis[]={Dis(lx,rx),Dis(lx,ly),Dis(lx,ry),Dis(rx,ly),Dis(rx,ry),Dis(ly,ry)};
    int z=max_element(dis,dis+6)-dis;
    if(z==0) return {lx,rx};
    if(z==1) return {lx,ly};
    if(z==2) return {lx,ry};
    if(z==3) return {rx,ly};
    if(z==4) return {rx,ry};
    return {ly,ry};
}
```

注意到合并的复杂度是和你 LCA 算法有关的，所以建议写 $O(1)$ LCA。

然后就可以上线段树啥的来维护，这里不推荐倍增数组，虽然可以 $O(1)$ 询问，但是空间不够。

本人实现的是线段树和 $O(1)$ LCA，可以 $O(\log n)$ 来查询点集的直径两端点。

然后，我们再看怎样连边直径最小。断边后，原树被分成了两棵树，我们设第一棵树的直径为 $l$，第二棵树的直径为 $r$。

考虑连接两棵树，假设连接的边的在第一棵树上的端点到第一棵树上其他点的最大距离为 $x$，在第二棵树上的端点到第二棵树上其他点的最大距离为 $y$，那么新树直径为 $\max(l,r,x+y+1)$，而 $x,y$ 的上界分别为 $\lceil{l\over 2}\rceil,\lceil{r\over 2}\rceil$，也就是说连接两直径的中点是最优的，那么答案就是所有断边情况的 $\max(l,r,\lceil{l\over 2}\rceil+\lceil{r\over 2}\rceil+1)$ 的最小值。

剩下的，就是把树拍到区间上去来维护了。

时间复杂度为 $O(n\log n)$，常数极大，且较卡空间。

## code：

```cpp
#include<bits/stdc++.h>
#define all(x) x.begin(),x.end()
#define mset(x,y) memset((x),(y),sizeof((x)))
#define mcpy(x,y) memcpy((x),(y),sizeof((y)))
#define FileIn(x) freopen(""#x".in","r",stdin)
#define FileOut(x) freopen(""#x".out","w",stdout)
#define debug(x) cerr<<""#x" = "<<(x)<<'\n'
#define Assert(x) if(!(x)) cerr<<"Failed: "#x" at line "<<__LINE__,exit(1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 Int;
const int N=3e5+10;
bool StM;
int n,dep[N],dfn[N],From[N];
int siz[N],id[N],k=0;
int low[N<<1],t=0,rt=1;
int Lt[N];
pair<int,int>fa[N<<1][19];
vector<int>G[N];
int LCA(int l,int r)
{
    if(l>r) swap(l,r);
    int x=log2(r-l+1);
    return min(fa[l][x],fa[r-(1<<x)+1][x]).second;
}
struct Dia{int l,r;}g[N<<1];
inline int Dis(int x,int y)
{
    return dep[x]+dep[y]-2*dep[LCA(Lt[x],Lt[y])];
}
inline Dia merge(Dia x,Dia y)
{
    int lx=x.l,rx=x.r,ly=y.l,ry=y.r;
    int dis[]={Dis(lx,rx),Dis(lx,ly),Dis(lx,ry),Dis(rx,ly),Dis(rx,ry),Dis(ly,ry)};
    int z=max_element(dis,dis+6)-dis;
    if(z==0) return {lx,rx};
    if(z==1) return {lx,ly};
    if(z==2) return {lx,ry};
    if(z==3) return {rx,ly};
    if(z==4) return {rx,ry};
    return {ly,ry};
}
#define lc(x) (mid<<1)
#define rc(x) (mid<<1|1)
void build(int l,int r,int x)
{
	if(l==r)
		return void(g[x]={id[l],id[l]});
	int mid=(l+r)>>1;
	build(l,mid,lc(x)),build(mid+1,r,rc(x));
	g[x]=merge(g[lc(x)],g[rc(x)]);
}
Dia query(int p,int q,int l=1,int r=n,int x=1)
{
	if(p<=l&&q>=r)
		return g[x];
	int mid=(l+r)>>1;
	if(q<=mid) return query(p,q,l,mid,lc(x));
	if(p>mid) return query(p,q,mid+1,r,rc(x));
	return merge(query(p,q,l,mid,lc(x)),query(p,q,mid+1,r,rc(x)));
}
void dfs(int now,int from)
{
    id[dfn[now]=++k]=now;
    low[++t]=now;siz[now]=1;
    if(!Lt[now]) Lt[now]=t;
    for(int to:G[now])
    {
        if(to==from) continue;
        dep[to]=dep[now]+1;From[to]=now;
        dfs(to,now);
        low[++t]=now;siz[now]+=siz[to];
    }
    return;
}
int GetMid(int x,int y)
{
	int dis=Dis(x,y),z=LCA(x,y);
	if(dep[y]-dep[z]>dep[x]-dep[z]) swap(x,y);
	while(Dis(x,y)>dis/2) x=From[x];
	return x;
}
void Main()
{
    cin>>n;
    for(int i=1,x,y;i<n;i++)
    {
        cin>>x>>y;
        G[x].push_back(y);
        G[y].push_back(x);
    }
    dfs(rt,0);
    for(int i=1;i<=t;i++) 
        fa[i][0]={dep[low[i]],low[i]};
    for(int i=1;i<=18;i++)
		for(int j=1;j+(1<<i)-1<=t;j++)
            fa[j][i]=min(fa[j][i-1],fa[j+(1<<i-1)][i-1]);
    build(1,n,1);
    Dia x=query(1,n),L={0,0},R={0,0},Mid={0,0};
    int Ans=Dis(x.l,x.r),l,r;
    for(int i=2;i<=n;i++)
    {
        Dia l={1,1},r=query(dfn[i],dfn[i]+siz[i]-1);//第二棵树对应的就是子树的区间
        if(1<dfn[i]) l=merge(l,query(1,dfn[i]-1));
        if(dfn[i]+siz[i]-1<n) l=merge(l,query(dfn[i]+siz[i],n));
        //第一棵树对应的是除这棵子树外的最多两个区间
        int x=Dis(l.l,l.r),y=Dis(r.l,r.r);
        auto dia=max({(x+1)/2+(y+1)/2+1,x,y});
        if(dia<Ans) Ans=dia,L=l,R=r,Mid={i,From[i]};
    }
    cout<<Ans<<'\n';
    cout<<Mid.l<<' '<<Mid.r<<'\n';
    cout<<GetMid(L.l,L.r)<<' '<<GetMid(R.l,R.r)<<'\n';
}
bool EdM;
int main()
{
    cerr<<fabs(&StM-&EdM)/1024.0/1024.0<<" MB\n";
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int StT=clock();
    int T=1;
    while(T--) Main();
    int EdT=clock();
    cerr<<1e3*(EdT-StT)/CLOCKS_PER_SEC<<" ms\n";
    return 0;
}
```

---

## 作者：FQ04gty (赞：1)

##### [原题链接](https://www.luogu.com.cn/problem/P6431)

---

简化题意：在一棵树上删去一条边，加入一条边，使得树的直径尽可能小。

要使删去一条边后树的直径尽可能小，显然一定要删去直径上的边，这样才能使直径比当前直径小。

删去一条边后，树被分成两个联通块，显然，最后的直径至少为两个连通块中直径较大者的直径。

考虑新边的两端应该选在哪个位置。

设 $dis_i$ 为点 $i$ 距离自己连通块中，离自己最远的点的距离。

在两个连通块中，分别找到点 $a$、$b$，满足该点是自己所在的连通块中，$dis_a$、$dis_b$ 最小的点。 

设整棵树的直径为 $u$，$v$，考虑两棵树分别从 $u$、$v$ 开始加边，此时显然有 $u$、$v$ 分别为两个连通块直径上的一个点（反证法：若 $u$ 不是自己所在连通块直径的一端，那么一定可以找到一个点 $p$，使得 $dis(p,v)>dis(p,u)$，那么 $p$ 应当成为 $u$）。

另一个点的位置可以这样得出：

对于每个整棵树的直径上的点 $p$，预处理出 $maxdis_p$，表示存在一个不在整棵树的直径上的点  $k$，使得 $dis(p,k)$ 最大，且 $p$、$k$ 之间的路径不经过直径上的边。

两个连通块每次加入一个直径上的点，即可用 $maxdis$ 更新直径。直径的中点可以通过深度计算得出。

时间复杂度 $O(n)$。

### Code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mset(arr,val) memset(arr,val,sizeof(arr))
using namespace std;
const int SIZE=6e5+10,inf=0x3f3f3f3f;
inline int read()
{
    int x=0,opr=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')opr=-opr;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x*10)+(ch^48),ch=getchar();
    return x*opr;
}
int n,head[SIZE],sizee,mid,thisa;
struct edge{int u,v,nxt;}e[SIZE];
inline void add(int u,int v){e[sizee]={u,v,head[u]},head[u]=sizee++;}
inline void add_edge(int u,int v){add(u,v),add(v,u);}
int dpth[SIZE],fst[SIZE],scd[SIZE],hvy[SIZE],fa[SIZE],tmp,root,tail,maxn,ths,ct,pnt[SIZE],len;
int ans[SIZE],part[SIZE],maxlen[SIZE],ansplace,ansct,ANS=inf,til,ctmid;
inline void update(int thisp,int v,int t)
{
    if(v>fst[thisp])scd[thisp]=fst[thisp],fst[thisp]=v,hvy[thisp]=t;
    else if(v>scd[thisp])scd[thisp]=v;
}
void dfs(int thisp,int lst)
{
    dpth[thisp]=dpth[fa[thisp]=lst]+1;
    for(int i=head[thisp];~i;i=e[i].nxt)if(e[i].v!=lst)dfs(e[i].v,thisp),update(thisp,fst[e[i].v],e[i].v);
    if(fst[thisp]+scd[thisp]-2*dpth[thisp]+1>maxn)maxn=fst[thisp]+scd[thisp]-2*dpth[thisp]+1,tmp=thisp;
    update(thisp,dpth[thisp],thisp);
}
int main()
{
    mset(head,-1);
    n=read();
    for(int i=1;i<n;i++)add_edge(read(),read());
    dfs(1,0),root=tmp;
    while(hvy[root]!=root)root=hvy[root];
    mset(hvy,0),mset(fst,0),mset(scd,0),dfs(tail=root,0);
    while(hvy[tail]!=tail)pnt[dpth[tail]]=tail,tail=hvy[tail];
    pnt[dpth[tail]]=tail,len=dpth[tail];
    ths=ct=tail;
    for(int i=1;i<=n;i++)if(!scd[i])scd[i]=dpth[i];
    while(ths!=root)
    {
        
        mid=(scd[ths]+len-2*dpth[ths])/2+(scd[ths]+len-2*dpth[ths])%2;
        if(len-mid<dpth[ct])ct=pnt[len-mid],ctmid=mid;
        ans[ths]=ct,maxlen[ths]=ctmid,part[ths]=til=max(til,scd[ths]+len-2*dpth[ths]);
        ths=fa[ths];
    }
    ths=ct=root,til=ctmid=0;
    while(ths!=tail)
    {
        mid=(scd[ths]-1)/2+(scd[ths]-1)%2;
        if(1+mid>dpth[ct])ct=pnt[1+mid],ctmid=mid;
        thisa=max({ctmid+1+maxlen[hvy[ths]],part[hvy[ths]],til=max(til,scd[ths]-1)});
        if(thisa<ANS)ANS=thisa,ansplace=ths,ansct=ct;
        ths=hvy[ths];
    }
    printf("%d\n%d %d\n%d %d",ANS,ansplace,hvy[ansplace],ansct,ans[hvy[ansplace]]);
    return 0;
}
```

---


# [COCI 2008/2009 #4] TREZOR

## 题目描述

在平面直角坐标系中，有一个以 $(1,-A)$ 和 $(L,B)$ 为对角线上的两个端点的矩形。这个矩形内有 $L\times (A+1+B)$ 个点。

现在有两名警卫分别在 $(0,-A)$ 和 $(0,B)$ 两个点。他们都看向这个矩形。如果他的视线（为一条射线）与矩形内的一个点之间有其他点阻隔，那么他就看不到这个点。

对于每一个点：

- 如果它能被两个警卫都看到，那么就认为它是非常安全的；
- 如果z只能被其中一个警卫都看到，那么就认为它是安全的；
- 如果两个警卫都看不到它，那么就认为它是危险的。

给定 $A,B,L$，你需要找出非常安全的点、安全的点和危险的点分别的数量。


## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，$L\le 1000$；
- 对于另 $25\%$ 的数据，$A,B\le 100$；
- 对于 $100\%$ 的数据，$1\le A,B\le 2000$，$1\le L\le 10^9$。

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #4](https://hsin.hr/coci/archive/2008_2009/contest4_tasks.pdf) *T5 TREZOR***。

## 样例 #1

### 输入

```
1 1
3```

### 输出

```
2
2
5```

## 样例 #2

### 输入

```
2 3
4```

### 输出

```
0
16
8```

## 样例 #3

### 输入

```
7 11
1000000```

### 输出

```
6723409
2301730
9974861```

# 题解

## 作者：Limit (赞：4)

# 题目大意

给出一个 $(a+b)\times (l-1)$ 的矩形,端点为 $(0,0)$ 和 $(l-1,a+b)$,在 $(-1,0)$ 和 $(-1,a+b)$ 的位置有一个特殊点,问又多少点满足和其中一个特殊点之间的连线不经过其他点,和两个特殊点的连线不经过其他点,以及两个特殊点和它的连线都会经过其他点.

# 分析

对于两线之后不经过其他点的点对 $(x_1,y_1),(x_2,y_2)$ 必定满足 $\gcd(|x_1-x_2|,|y_1-y_2|)=1$(具体可以看看 [P2158]( https://www.luogu.com.cn/problem/P2158 ) 的题解区,这里不作多解释),可以发现 $a+b$ 的范围很小,所以考虑枚举所在的行,对于每一行计算答案.

设 $f(l,x)$ 表示 $\sum\limits_{i=1}^{l}[\gcd(i,x)=1]$.即计算 $1\sim l$ 中与 $x$ 互质的数的个数.

那么对于第 $i$ 行第一个特殊点可以看见的点的个数 $=f(l,i-1)$,第二个特殊点可以看见的点的个数 $=f(l,a+b+1-i)$.

考虑 $f$ 的本质,$f(l,x)$ 的计算可以把 $x$ 拆成 $p_1^{k_1}p_{2}^{k_2}p_{3}^{k_3}\dots$.那么 $f(l,x)=l-\lfloor\frac{l}{p_1}\rfloor-\lfloor\frac{l}{p_2}\rfloor\dots+\lfloor\frac{l}{p_1p_2}\rfloor+\lfloor\frac{l}{p_2p_3}\rfloor+\lfloor\frac{l}{p_1p_3}\rfloor\dots-\lfloor\frac{l}{p_1p_2p_3}\rfloor-\lfloor\frac{l}{p_1p_2p_4}\rfloor-\lfloor\frac{l}{p_1p_3p_4}\rfloor\dots\dots$ 变成了一个简单的容斥,$f(l,x)=$ 选 $0$ 个数的乘积在 $1\sim m$ 中的倍数个数 $-$ 选 $1$ 个数的乘积在 $1\sim m$ 中的倍数的个数 $+$ 选 $2$ 个数的乘积在 $1\sim m$ 中倍数的个数 $\dots$

同时被两个点看到的方案数 $=f(l,(i-1)(a+b+1-i))$(可以理解为需要得到将两个数分解之后所得的质数集合的并集,$(i-1)(a+b+1-i)$ 换成 $\operatorname{lcm}(i-1,a+b+1,i)$ 也是可以的)

恰好只会被第一个特殊点看到的方案数 $=f(l,i-1)-f(l,(i-1)(a+b+1-i))$.第二个特殊点同理.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int PRIME[303]={2,3,5,7,11,13,....};//2000 以内的质数表
int a,b,l;
long long answer1,answer2;
long long sum;
int cnt=0;
int num[100];
void DFS(int now=1,int use=0,long long add=1)
{
	if(now==cnt+1)
	{
		sum+=1ll*(use&1?-1:1)*(l/add);//选了偶数个是加上,选了奇数个是减
		return;
	}
	DFS(now+1,use,add);
	DFS(now+1,use+1,add*num[now]);
}
long long Calc(int a)
{
	if(!a)
	{
		return 1;
	}
	sum=0;
	cnt=0;
	REP(i,0,302)//将数分解为若干质数的幂次的乘积的形式
	{
		if(a%PRIME[i]==0)
		{
			num[++cnt]=PRIME[i];
			while(a%PRIME[i]==0)
			{
				a/=PRIME[i];
			}
		}
	}
	if(a^1)
	{
		num[++cnt]=a;
	}
	DFS();//暴力 DFS 容斥
	return sum;
}
int main()
{
	scanf("%d%d%d",&a,&b,&l);
	int len=a+b+1;
	REP(i,1,len)
	{
		a=i-1;
		b=len-i;
		long long ua=Calc(a);//第一个特殊点可以看见的点的数量
		long long ub=Calc(b);//第二个特殊点可以看见的点的数量
		long long uab=Calc(a*b);//第一个和第二个特殊点可以同时看见的点的数量
		answer2+=uab;//记录答案
		answer1+=ua-uab+ub-uab;
	}
	printf("%lld\n%lld\n%lld\n",1ll*len*l-answer1-answer2,answer1,answer2);
	return 0;
}
```

---

## 作者：IkunTeddy (赞：2)

# 题目分析

我们先考虑能被看到的条件，若 $(x_1,y_1)$ 能看到 $(x_2,y_2)$ 当且仅当 $\gcd(\left | x_1-x_2 \right |,\left | y_1-y_2  \right | )=1$。

但是要同时被两个人看到限制太强，考虑容斥减少限制。那么现在我们只需考虑至少的情况了。

设 $f(n,x)=\sum\limits_{i=1}^{n}[\gcd(i,x)=1]$，即 $1 \sim n$ 中与 $x$ 互质的个数。

$cnt_1=\sum\limits_{i=-A}^{B}f(L,A+i)$ 即**至少**第一个人能看到的个数。

$cnt_2=\sum\limits_{i=-A}^{B}f(L,B-i)$ 即**至少**第二个人能看到的个数。

$ans_3=\sum\limits_{i=-A}^{B}f(L,\text{lcm}(A+i,B-i))$ 即两个人能**同时**看到的个数。

则只能被一个人看到的个数 $ans_2=cnt_1+cnt_2-2\cdot ans_3$，不能被看到的个数 $ans_1=L(A+B+1)-ans_2-ans_3$。

现在就是用考虑 $f(n,x)$ 的求解。看到这种形式我们就不觉想到**莫比乌斯反演**。

这就是板子，直接上了。

$$f(n,x)=\sum_{d\mid x} \mu(d)\cdot[\frac{n}{d}]$$

这道题的 $A,B$ 太小了，随便怎么求 $\mu$ 都能过。就不放代码了。

---

## 作者：devout (赞：2)

**题意**

设 $n=A+B-1,m=L$，求

$$\sum_{i=1}^n\sum_{j=1}^m[\gcd(i-1,j)=1]\wedge[\gcd(n-i,j)=1]$$

发现 $n$ 非常的小，所以考虑枚举 $i$，问题转化成了求同时和 $i-1,n-i$ 互质的数，这个问题等价于和 $\operatorname{lcm}(i-1,n-i)$ 互质的数

所以接下来的问题是求

$$\sum_{i=1}^x[\gcd(i,m)=1]=\sum_{i=1}^x\sum_{d|\gcd(i,m)}\mu(d)$$

$$=\sum_{d=1}^m\mu(d)\lfloor\dfrac{x}{i}\rfloor$$

然后就搞完了，但是这题非常恶心的是空间限制为 31.25M，所以不能直接筛，每次暴力求 mu 即可

O(能过)

```cpp
#include <bits/stdc++.h>
int A,B,n,m;
ll ans1,ans2;

int gcd(int a,int b){
    if(!b)return a;
    return gcd(b,a%b);
}

int mu(int x){
    int res=1;
    for(int i=2;i*i<=x;i++){
        if(x%i!=0)continue;
        res=-res;
        x/=i;
        if(x%i==0)return 0;
    }
    if(x>1)res=-res;
    return res;
}

ll ask(int x){
    ll res=0;
    for(int i=1;i*i<=x;i++){
        if(x%i!=0)continue;
        res+=1ll*mu(i)*(m/i);
        if(x/i!=i)res+=1ll*mu(x/i)*(m/(x/i));
    }
    return res;
}

int main()
{
    # ifdef hibike
    freopen("testdata.in","r",stdin);
    freopen("test1.out","w",stdout);
    # endif
    read(A),read(B),n=B+A+1;
    read(m);
    ans1+=2*ask(n-1)-2,ans2+=2;
    Rep(i,2,n-1){
        int val=(i-1)*(n-i)/gcd(i-1,n-i);
        ll tmp=ask(val);
        ans2+=tmp;
        ans1+=ask(i-1)+ask(n-i)-2*tmp;
    }
    printf("%lld\n",1ll*n*m-ans1-ans2);
    printf("%lld\n",ans1);
    printf("%lld\n",ans2);
    return 0;
}
```

---


# [COCI 2010/2011 #4] DUGOVI

## 题目描述

在一个小镇上有 $n$ 位居民，每位居民都**恰好从其他一位**居民那里借了一些钱。

现在到了还债的时间。但问题是每个人都把自己的钱用完了；也就是说任何人都无力偿还债务。这样以来产生了很多冲突。

市长决定解决这个问题。他预想要给一部分居民一些钱，以便于他们用来还债。不过当一部分居民拿到了钱，一系列的连锁反应就开始了。

例如， $A$ 从市长那里得到了钱。$A$ 赶忙用这些钱偿还 $B$ 的债务。$B$ 也正好偿还 $C$ 的债务，以此类推。

其中，如果 $B$ 没有足够的钱来一次还清，那么他会把钱暂时留在自己手里等到钱够了；如果还完债后还有剩余， $B$ 也会自己留着。（$B$ 的行为对于任意一个人适用）

另一个例子：如果两个镇上的居民**互欠**对方 $100$ 美元，那么市长只需要给其中一个人 $100$ 美元，这两个债务就都解决了。

你需要通过程序来计算出：市长至少要支出多少元给一部分居民才能平息一切债务？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 2\times 10^5$，$1\le A_i\le n$ 且 $A_i\neq i$，$1\le B_i\le 10^4$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #4](https://hsin.hr/coci/archive/2010_2011/contest4_tasks.pdf) *T5 DUGOVI***。

## 样例 #1

### 输入

```
4
2 100
1 100
4 70
3 70```

### 输出

```
170```

## 样例 #2

### 输入

```
3
2 120
3 50
2 80```

### 输出

```
150```

## 样例 #3

### 输入

```
5
3 30
3 20
4 100
5 40
3 60```

### 输出

```
110```

# 题解

## 作者：阿丑 (赞：18)

非常明显的一题环套树，注意到本题条件：

>如果还完债后还有剩余， $B$ 也会自己留着。（$B$ 的行为对于任意一个人适用）

  即，每个人欠的钱，就是他还给债主的钱 ~~（废话）~~。请注意。

思路：

1. 首先去掉所有不被其他人欠钱的人，因为这种人必须由政府出钱。之后可以直接把他欠的钱给出去，再删除这个节点。

2. 步骤 $1$ 后环套树就只剩下了环，一一枚举计算即可。


***

#### 第一步

对于所有不被其他人欠钱的人，由于他所欠的钱一定由政府出，直接将他所欠的钱累加进答案 $ans$，再将他的钱还给债主，然后就可以删除他和他对应的边了。

而若此时的债主不被其他人欠钱了，也可以这么处理。代码如下：

```cpp
//ind 表示入度，val 表示所欠的钱，now 表示手里有的钱，fa 表示债主
for(int x=1; x<=n; ++x)
	if(ind[x]==0) {
		for(int u=x; ind[u]==0; u=fa[u]) {
			ans+=max(val[u]-now[u], 0);	//累加 
			--ind[fa[u]];	//删边 
			now[fa[u]]+=val[u];	//给钱
 
			ind[u]=-1;	//标记u，防止此后被重复计算 
		}
	}
```

***

#### 第二步

执行完第一步后，可以发现图只剩了下了入度 $\ge 1$ 的节点。由于原图是环套树森林，故此时只剩下了很多个环。

对于环上的任意一个节点 $su$，设他的债主为 $u$，则对于 $u$ 的还钱，有两种情况：

1. $su$ 先还给了 $u$ 共 $val[su]$ 的钱，政府再给 $u$ 剩下的钱（如果需要），凑够 $val[u]$ 后还钱。此时政府支出 $val[u]-(val[su]+now[u])$ 的钱（如果是负数，则不用支出，下文同理）。

2. $su$ 还没给钱，政府就给了 $u$ 所需的钱，支出 $val[u]-now[u]$ 的钱。

由于 $val[su]>0$，故第一种情况一定更赚，即政府至少要给出 $\sum val[u]-(val[su]+now[u])$。

但是，所有人都不会自动给钱，必须由政府给其中一个人钱才会触发某人的第一种情况，随后即可触发所有人的第一种情况，故只需给一人 $val[u]-now[u]$，可以想到记录两种情况差值的最小值。

（若有人在第一步中已经有了足够还债主的钱，则可以看做政府给了 $0$ 元钱。此时差值为 $0$，一定是最小值。）

代码如下：

```cpp
if(ind[x]>0) {
	int dans=INF;
	for(int u=fa[x], su=x; ind[u]>0; su=u, u=fa[u]) {
		int c1=max(val[u]-val[su]-now[u], 0), c2=max(val[u]-now[u], 0);
		ans+=c1;
		if(dans>c2-c1) dans=c2-c1;	//记录最小值
		ind[u]=0;	//标记
	}
	ans+=dans;
}
```
***
然后就结束了（甚至图都没存，码量挺小），完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=200000+30, INF=2000000000+10;
int n, fa[MAXN], val[MAXN], ind[MAXN], now[MAXN];
void init() {
	scanf("%d", &n);
	for(int x=1; x<=n; ++x)
		scanf("%d%d", &fa[x], &val[x]), ++ind[fa[x]];
	return;
}
void solve() {
	int ans=0;
	for(int x=1; x<=n; ++x)
		if(ind[x]==0) {
			for(int u=x; ind[u]==0; u=fa[u]) {
				ans+=max(val[u]-now[u], 0);
				--ind[fa[u]];
				now[fa[u]]+=val[u];
				ind[u]=-1;
			}
		}
	for(int x=1; x<=n; ++x)
		if(ind[x]>0) {
			int dans=INF;
			for(int u=fa[x], su=x; ind[u]>0; su=u, u=fa[u]) {
				int c1=max(val[u]-val[su]-now[u], 0), c2=max(val[u]-now[u], 0);
				ans+=c1;
				if(dans>c2-c1) dans=c2-c1;
				ind[u]=0;
			}
			ans+=dans;
		}
	printf("%d\n", ans);
	return;
}
int main() {
	init();
	solve();
	return 0;
}
```
***

本蒟蒻的第一篇题解，见谅 $QAQ$。

---

## 作者：Zjl37 (赞：4)

> 我希望能讲清楚思路，代码就不放了。
 
$n$ 个点每个点连出一条边，这显然是一棵（片）基环树（森林）。

### 处理树的部分

不断寻找入度为零的点：没有任何人还他钱，只能由市长给他钱。市长需要给 $u$ 这个人 $B_u$ 元. 如果 $u$ 已经有了 $C_u$ 元，市长只用给 $B_u - C_u$ 元。

一旦 $u$ 得到了足够的钱，即 $C_u \ge B_u$，就会触发还债动作，$C_{A_u} \gets C_{A_u} + B_u $. 

- 还债后 $A_u$ 的入度减一，因而这一部分可以用类似拓扑排序的方式做。

- 如果 $A_u$ 也得到了足够的钱，那就继续下去……因而称作连锁反应。注意这行为对每个人都适用，也就是每个人得到钱之后都要检查是否足够还债。

- 值得注意的是，在环上的人如果有能力还债了，环就“破了”。如

![](https://cdn.luogu.com.cn/upload/image_hosting/1a7une9x.png?x-oss-process=image/resize,m_lfit,h_353,w_441)

### 处理环的部分

这时图中只剩下一些环。只要政府给环中一个人足够还债的钱，环就“破了”，变成一条链，可以照上面方法处理。那么政府该给谁钱呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/ss3nhy19.png?x-oss-process=image/resize,m_lfit,h_416,w_514)

可以发现，每个人作为债主都会得到别人的钱。市长“希望”每个人都能先拿到别人的钱再拿政府的钱，这样政府付给他的钱就会尽可能少一些，即给 $A_u$ 这个人 $W_{A_u} = \max \lbrace B_{A_u} - C_{A_u} - B_u, 0 \rbrace$ 元

但是市长要先给一个人钱，如果选择 $u$，就要给他 $V_u = B_{A_u} - C_{A_u}$ 元而不是 $W_u$ 元。政府就共支出 $\sum W - W_u + V_u$.

只要选择 $- W_u + V_u$ 最小的那个人就可以了。

实际上实现并不需要先破成链再像第一部分处理，只需遍历一遍环，记录下 $\sum W$ 和 $\min{- W_u + V_u}$ 即可。

---

## 作者：hxylrorz (赞：4)

思路都在代码里，大家自己看吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[200001],l[200001],t[200001],d[200001],ans=0;
//数组：下一个点、要还的钱、自己有的钱、入度 
queue<int> q;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int a,b;
        scanf("%d %d",&a,&b);
        x[i]=a;//还钱给a 
        l[i]=b;//还b块钱 
        d[a]++;//增加入度 
    }
    for(int i=1;i<=n;i++)if(d[i]==0)q.push(i);//败类只借不还，只有问市长借 
    while(!q.empty())
    {
        int u=q.front(),v=x[u];
        if(t[u]<l[u])ans+=l[u]-t[u];//兜里没钱 
        t[v]+=l[u];//收到钱 
        d[v]--;//又有一个人还了钱~在小本本上划一笔 
        if(d[v]==0)q.push(v);//咦~所有人都还完了呀 
        q.pop();
    }//把钱集中在一个环上 
    for(int i=1;i<=n;i++)
        if(d[i])//找环 
        {
            int u=i,v,Min=1<<30,pu=-1/*前一个点*/;//取巧一下 
            while(1)
            {
                if(d[u]==0)break;//终于完工了 
                v=x[u];
                if(pu==-1)//第一个点 
                {
                    pu=u;
                    u=v;
                    continue;
                }
                if(l[pu]+t[u]<l[u])ans+=l[u]-(l[pu]+t[u]),t[u]+=l[u]-l[pu]-t[u];//借钱 
                if(l[u]-t[u]<Min)Min=l[u]-t[u];//找启动代价最小的点 
                d[u]=0;
                pu=u;
                u=v;
            }
            if(Min>0)ans+=Min;//需要借钱的借钱 
        }
    printf("%d\n",ans);
    return 0;
}
```

这是本蒟蒻的首篇题解，请大家多多支持！

---

## 作者：joe_zxq (赞：3)

# 思路

1. 有些人没有被人欠钱，却欠别人钱。这种人显然需要市长帮助。

2. 可以发现，剩下的人形成一个环。我们需要枚举市长给环里的谁钱，因为第一个人需要额外的钱资助，取一个最小值，然后其他人遍历一遍算答案即可。

# 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans = 0, v[214514], fa[214514], cnt[214514], now[214514];
// v 我欠人家多少钱
// fa 我欠谁钱
// cnt 有多少人欠我钱
// now 我有多少钱
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x, y;
        cin >> x >> y;
        // 建图：债主就是我父亲
        v[i] = y, fa[i] = x;
        // 又有一个人欠债主钱了
        cnt[fa[i]]++;
    }
    for (int i = 1; i <= n; i++) {
        // 如果没人欠我钱，就要市长帮我还钱
        if (!cnt[i]) {
            // 往上一直找债主的债主
            for (int u = i; !cnt[u]; u = fa[u]) {
                // 若我还不起钱，那就让市长帮我还剩下的钱！
                ans += max(v[u] - now[u], 0);
                // 我不欠债主钱了，债主少一个人欠他钱啦
                cnt[fa[u]]--;
                // 债主拿到钱了
                now[fa[u]] += v[u];
                // 给u标记一下，下一次不用再来了
                cnt[u] = -1;
            }
        }
    }
    //中间的人就是一个环了，枚举市长要把钱先给谁，然后转圈圈
    for (int i = 1; i <= n; i++) {
        if (cnt[i] > 0) {
            // 记录市长把钱给谁后的消耗最小值
            int minn = 2e9 + 7;
            // 一直往上找父亲，遍历这个环
            for (int u = fa[i], su = i; cnt[u] > 0; su = u, u = fa[u]) {
                // 市长想要尽可能地少花点钱，所以要贪心，这是人之常情
                int c1 = max(v[u] - v[su] - now[u], 0), c2 = max(v[u] - now[u], 0);
                ans += c1;
                minn = min(minn, c2 - c1);
                // 好了，没人欠钱了
                cnt[u] = 0;
            }
            ans += minn;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Awatesolo (赞：2)

# 题解：P6486 [COCI 2010/2011 #4] DUGOVI
* 本题解与其它大部分题解解法相同，此题解给出算法时间复杂度的证明。
## 思路
* 若 $A$ 欠 $B$ 钱，则从 $A$ 向 $B$ 连一条**有向边**。统计每一点的**入度**。
* 若节点 $x$ 的入度为 $0$，则 $x$ 必须得到市长的帮助，答案直接加上 $x$ 的出边。
* 拿到钱的 $x$ 会将钱分给他欠钱的人，于是我们暴力将钱沿着路线往下分。
* 剩下的没环完的人一定在环上。
* 遍历环，考虑给环上的一个人 $i$ 补钱。设他现在有的钱为 $w_i$，他欠的钱为 $a_i$，欠他的钱为 $b_i$。则
* 给 $i$ 补的钱为：$\max(0,a_i-w_i)$。
* 给其它点补的钱为：$\sum\max(0,a_i-w_i-b_i)$。
* 总共补的钱为：$\sum\max(0,a_i-w_i-b_i)+\max(0,a_i-w_i)$。

## 时间复杂度证明
* 总时间复杂度：$O(n)$。
* 操作 $1$：若节点 $x$ 的入度为 $0$，则得到市长的帮助并暴力将钱沿着路线往下分。
* 由于每人**要么被市长给钱，要么被给钱**，最多跑 $n$ 次，所以操作 $1$的复杂度为 $O(n)$。
* 操作 $2$：遍历环，考虑给环上的一个人 $i$ 补钱。
* 环最大长度为 $n$，而我们以 $O(1)$ 的时间计算贡献。因此时间复杂度为 $O(n)$。
* 综上，时间复杂度为 $O(n)$。

## 代码
码风粗鄙。可参考其它题解的代码。
```c++
#include<bits/stdc++.h>
using namespace std;
int n;
int g[200005],c[200005];
int rd[200005];
int now[200005];
signed main(){
	cin>>n;
	int v;
	for(int i=1;i<=n;i++){
		cin>>g[i]>>c[i];
		rd[g[i]]++;
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(rd[i]==0){
			for(int u=i;rd[u]==0;u=g[u]){
				ans+=max(c[u]-now[u],0);
				rd[g[u]]--;
				now[g[u]]+=c[u];
				rd[u]=-1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(rd[i]>0){
			int maxn=2e9+10;
			int fa=i; 
			for(int u=g[i];rd[u];u=g[u]){
				ans+=max(c[u]-c[fa]-now[u],0);
				int z=max(c[u]-now[u],0)-max(c[u]-c[fa]-now[u],0);
				maxn=min(maxn,z);
				rd[u]--;
				fa=u;
			}
			ans+=maxn;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：TMLY114514 (赞：2)

## 题解：P6486 [COCI2010-2011#4] DUGOVI

先把题目中还钱的关系抽象成一张有向图，设点 $x$ 的出点为 $fa_x$，其出边边权为 $b_x$，当前拥有的钱数为 $a_x$。

首先，每个人只有一条出边，显然这张图是内向基环树森林。

我们很容易想到对于非环上的点的处理方法。对于入度为 $0$ 的点 $u$，没有任何点给其还钱，所以只能贪心地补给他 $\max(b_u-a_u,0)$ 的钱。然后他会给 $fa_u$ 还 $b_u$ 的钱，此时 $fa_u$ 的钱的唯一来源已经处理，也可以视为入度为 $0$ 的点。通过拓扑排序可以处理这部分的答案。

然后这张图剩下的就是一堆环了，此时需要给一个人启动资金，然后顺着环和上面一样贪心即可。设 $u$ 为起点，$v$ 为这个环上的任意一个人，考虑写出此时整个环的总花费：
$$\max(b_u-a_u,0)+\sum_{fa_v\ne u}\max(b_{fa_v}-(a_{fa_v}+b_v),0)$$
设 $pre_x$ 为这个环上给 $x$ 钱的人，则原式可化为：
$$\max(b_u-a_u,0)-\max(b_u-(a_u+b_{pre_u}),0)+\sum\max(b_{fa_v}-(a_{fa_v}+b_v),0)$$

不难发现，此时答案的大小只和 $\max(b_u-a_u,0)-\max(b_u-(a_u+b_{pre_u}),0)$ 有关。遍历环，找到使其最小化的人作为起点即可。

---

## 作者：Iris_Aurora (赞：1)

可以发现这是一片基环树内向森林，我们分链和环的情况讨论。

在一条链上，市长给每个人补的钱是固定的，是 $\max(a_i-b_i,0)$，$a_i$ 是他欠别人的钱，$b_i$ 是别人欠他的钱。这一部分可以用拓扑排序解决。

再考虑环上，现在每个点有一个初始点权 $w_i$，是子树给他还的钱，我们考虑先给所有 $b_i+w_i < a_i$ 的点补钱，即补 $\max(a_i-w_i-b_i,0)$，但这个时候这个环还不一定可以运转起来，要运行起来必须给一个点补至少 $\max(a_i-w_i,0)$ 才可以，那我们在遍历环的时候记录这两个值的最小差值累加上答案就行了。

附上代码：

```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const int MAXN = 2e5 + 10;
int n,ans=0;
int a[MAXN],b[MAXN],c[MAXN],d[MAXN];
queue<int>q;
void solve(int x){
	int u=x,v,mn=2e9,now;
	while(u){
		d[u]--;
		v=a[u];
		now=max(c[v]-b[u],0);
		ans+=now;
		mn=min(mn,c[v]-now);//记录最小差值 
		if(v==x) break;
		u=v;
	}
	ans+=mn;
} 
int main(){
	scanf("%d",&n);
	FL(i,1,n){
		scanf("%d%d",&a[i],&b[i]);
		c[i]=b[i];
		d[a[i]]++;
	}
	FL(i,1,n){
		if(!d[i]) q.push(i),ans+=b[i];
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
//		printf("%d %d\n",u,a[u]);
		c[a[u]]=max(0,c[a[u]]-b[u]);//还需要补的钱 
//		printf("%d\n",c[a[u]]);
		d[a[u]]--;
		if(!d[a[u]]){
			ans+=c[a[u]];
			q.push(a[u]);
		}
	}
	FL(i,1,n){
		if(d[i]) solve(i);
	}
	printf("%d\n",ans);
}
```

---

## 作者：Hua_Tian (赞：0)

### 基础思路

第一步：找出所有没有人要给他钱的人，让市长掏腰包。

第二步：观察剩下的人，可以发现所有人必定会成为一个环，然后枚举市长要给谁钱即可。

基础思路已给出，具体做法可以参考其他题解。

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int nxt[200001], val[200001], zd[200001], t[200001], cnt = 0, n, d[200001], qq[200001];
long long ans = 0;
queue < int > q;
void solve()
{
	while (!q.empty())
	{
		int u = q.front(); 
		int v = nxt[u];
		if (t[u] < val[u])
			ans += val[u] - t[u];
		t[v] += val[u];
		d[v]--;
		if (d[v] == 0) q.push(v);
		q.pop();
	}
}
int main()
{
//	freopen("dugovi.in","r",stdin);
//	freopen("dugovi.out","w",stdout);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		int x, y;
		scanf("%d %d", &x, &y);
		nxt[i] = x;
		val[i] = y;
		d[x]++;
	}
	for (int i = 1; i <= n; i++)
		if (d[i] == 0) q.push(i);
	solve();
	for (int i = 1; i <= n; i++)
		if (d[i])
		{
			int u = i, min = 1<<30, v, pu = -1;
			while(1)
			{
				if (d[u] == 0) break;
				v = nxt[u]; 
				if (pu == -1)
				{
					pu = u;
					u = v;
					continue;
				}
				if (val[pu] + t[u] < val[u])
					ans += val[u] - (val[pu] + t[u]), t[u] += val[u] - (val[pu] + t[u]);
				if (val[u] - t[u] < min) min = val[u] - t[u];
				d[u] = 0;
				pu = u;
				u = v;
			}
			if (min > 0)
				ans += min;
		}
	cout << ans <<endl; 
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

每个人只欠一个人钱，所以让每个人向他的债主连一条边，我们就得到了一片基环内向树森林。

对于不在环上的人，贪心可得让所有欠他钱的人都还了钱的时候，再让他还钱，这时在他身上花的钱最小。所以我们就可以直接拓扑将不在环上的点去掉。现在问题就在如何解决环的问题。

现在只考虑一个环上的人，关于环上的某个人，设他现在有的钱为 $w_i$，他欠的钱为 $a_i$，欠他的钱为 $b_i$，如果把环断开一个点，我们就可以把它当成一条链来写，那么就可以枚举断开的点，然后求解，取最小值。但是直接这么写是 $O(n^2)$，考虑优化。

对于我们断开的点，它的贡献是 $\max(0,a_i-w_i)$，其它点的贡献都是 $\max(0,a_i-w_i-b_i)$，设 $sum=\sum \max(0,a_i-w_i-b_i)$，那么断开第 $i$ 个的答案就是 $sum-\max(0,a_i-w_i-b_i)+\max(0,a_i-w_i)$，可以 $O(1)$ 求得，总复杂度 $O(n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,s[N],to[N],w[N],ans,q[N],ql,nw[N],v[N];
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; ++i) {
		scanf("%d %d",&to[i],&w[i]);
		s[to[i]]++;
	}
	for(int i=1; i<=n; ++i)if(!s[i]) {
		q[++ql]=i;
		v[i]=1;
	}
	for(int i=1; i<=ql; ++i) {
		int x=q[i];
		ans+=max(w[x]-nw[x],0);
		nw[to[x]]+=w[x];
		s[to[x]]--;
		if(!v[to[x]]&&(!s[to[x]]||nw[to[x]]>=w[to[x]])) {
			q[++ql]=to[x];
			v[to[x]]=1;
		}
	}
	int m=n-ql,p=1;
	while(m) {
		for(; p<=n; ++p)if(s[p]) {
				q[ql=1]=p;
				break;
			}
		do {
			q[ql+1]=to[q[ql]];
			ql++;
			s[q[ql]]=0;
		} while(q[ql]!=q[1]);
		m-=ql-1;
		int s=0;
		for(int i=2; i<=ql; ++i) {
			s+=max(w[q[i]]-nw[q[i]]-w[q[i-1]],0);
		}
		int mi=2e9;
		for(int i=2; i<=ql; ++i) {
			mi=min(mi, s-max(w[q[i]]-nw[q[i]]-w[q[i-1]],0) + max(w[q[i]]-nw[q[i]],0));
		}
		ans+=mi;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：sgl654321 (赞：0)

## 题目大意
- 城市里有 $n$ 个人，第 $i$ 个人对第 $a_i$ 个人欠了 $b_i$ 元，一开始，他们全部都是穷光蛋，一元钱也没有。

- 来了一个好心人，决定给其中某些人一些钱，如果第 $i$ 个人得到了 $\ge b_i$ 元钱，那么他会立刻向 $a_i$ 还 $b_i$ 元，多余的钱用来买绿鸟牌鸡柳。之后，$a_i$ 会考虑用他得到的这 $b_i$ 元钱，继续给他的债主还钱。

- 这个好心人也非常吝啬，他想要自己给出的钱最少。因此请你输出好心人最少给的钱。

## 解题思路
### 建立图论模型
我们考虑将每个 $i$ 向 $a_i$ 分别连一条边权为 $b_i$ 的边。由于每个点的出边是唯一的，我们将会得到一个**内向基环树森林**。

- 什么是内向基环树呢？

这个有向连通图，有且仅有**一个**简单环，我们将这个环缩成一个点之后，就会发现形成了一个**树**结构，同时所有的**儿子指向父亲**。

- 什么是内向基环树森林呢？

这个有向图，每个连通块都是一个基环树。

言归正传，这个题显然各个连通块之间互不影响，因此，我们处理每个基环树再把答案加起来就行了。

我们发现，基环树这个结构之所以特殊，因为它由两部分构成：一个是树，一个是环。
### 处理树部分
这个是内向树，意味着所有的叶子节点，都不存在入边，也就是说，它不是任何人的债主，但他们又是一群穷光蛋，因此他们还钱的钱，只能来自于好心人。

我们可以记录下，每个点 $i$ 当前有多少钱，记作 $now[i]$。

- 如果 $now[i]\ge b_i$ 那么好心人就不用出钱了，我们把 $now[a_i]$ 加上 $b_i$ 即可。

- 如果 $now[i] < b_i$ 那么好心人必须继续出钱，出 $b_i - now[i]$ 元钱，然后把 $now[a_i]$ 加上 $b_i$。

我们考虑从叶子节点（入度为 $0$ 的节点）开始拓扑排序，模拟上述过程即可。

拓扑排序中始终没有入队的节点，显然就是环上的节点。
### 处理环部分
我们最终剩下了很多简单环。环上的问题，我们通常考虑**破环成链**的做法。

即，钦定环上第一个点，好心人给他足够的钱让他还钱，然后他就离开了环。剩下就是一条链了，用刚才树的情况处理。

但我们显然不能枚举钦定每个点，不然复杂度就变成 $O(n^2)$ 了。我们将从数学的角度考虑优化。

对于下文，我们设点 $i$ 将从它的还债人那边收到 $c_i$ 元钱。即，若 $i$ 向 $a_i$ 还 $b_i$ 元钱，那么 $c_{b_i} = a_i$。

1. 如果点 $i$ 是钦定点，那么好心人应当给他 $\max\{0,b_i-now[i]\}$ 元钱。

2. 如果点 $i$ 不是钦定点，那么好心人应给他 $\max\{0,b_i-c_i-now[i]\}$ 元钱。

那么，好心人至少给 $i$ 这个点 $\max\{0,b_i-c_i-now[i]\}$ 元钱，如果 $i$ 是钦定点，好心人还要给他 $\max\{0,b_i-now[i]\}-\max\{0,b_i-c_i-now[i]\}$ 这么多钱。

我们考虑求出最小的 $\max\{0,b_i-now[i]\}-\max\{0,b_i-c_i-now[i]\}$，在  $\sum_i\max\{0,b_i-c_i-now[i]\}$ 的基础上，加上这个最小值，就是这个环的给钱需求量。

## 参考代码

```cpp
#include<bits/stdc++.h> 
#define maxn 200010
using namespace std;
typedef long long ll;
ll n, to[maxn], lend[maxn], in[maxn], x;
ll cur[maxn], ans, now, tot, a[maxn];
ll c[maxn],mi;

queue<ll> q;
int main(){
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> to[i] >> lend[i], in[to[i]] ++;
	for(int i = 1; i <= n; i++)
		if(!in[i]) q.push(i);
	while(!q.empty()){
		x = q.front(); q.pop();
		
		ans += max(0ll, lend[x] - cur[x]);
		cur[to[x]] += lend[x];
		
		in[to[x]]--;
		if(in[to[x]] == 0) q.push(to[x]);
	}
	for(int i = 1; i <= n; i++)
		if(in[i] == 1){
			tot = 1; a[tot] = i;
			now = to[i];
			while(now != i){
				a[++tot] = now;
				now = to[now];
			}
			c[1] = max(0ll, lend[a[1]] - lend[a[tot]] - cur[a[1]]);
			for(int j = 2; j <= tot; j++)
				c[j] = max(0ll, lend[a[j]] - lend[a[j-1]] - cur[a[j]]);
			mi = 1e16;
			for(int j = 1; j <= tot; j++){
				ans += c[j];
				now = max(0ll, lend[a[j]] - cur[a[j]]);
				mi = min(mi, now - c[j]);
			}
			ans += mi; 
			for(int j = 1; j <= tot; j++)
				in[a[j]]--;
		}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Tx_Lcy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6486)

简单题，提供一种比较暴力的做法。

## 思路

首先考虑连边 $i \rightarrow A_i$，肯定会连出基环树森林。

对于每个连通块，找出这个连通块中的环，对于非环上的点，显然可以直接算出每个点对答案的贡献。

对于环上的点，我们先统计出非环上点会环上每个点的贡献，然后我们显然要断环成链，枚举每个点，套用非环的做法，然后取 $\min$ 即可，可以轻松做到 $\mathcal O(n^2)$。

观察点 $i$ 对点 $A_i$ 的贡献，不难发现贡献是确定的，为 $B_i$。那么当我们断环成链时，除了断开的那个点，别的点收到的钱是一样的，我们可以记录前缀后缀和，然后特殊计算一下当前断开的那个点即可。

不需要任何结论即可做到 $\mathcal O(n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mid ((l+r)>>1)
#define all(x) (x).begin(),(x).end()
int const N=2e5+10;
int p[N],q[N],pre[N],sb[N],suf[N],sp[N],dp[N],co[N],vis[N];
vector<int>vec[N];
void solve(){
	int n;cin>>n;
	for (int i=1;i<=n;++i){
		int x,y;cin>>x>>y;
		p[i]=x,q[i]=y;
	}
	int tot=0;
	for (int i=1;i<=n;++i){
		if (vis[i]) continue;
		vector<int>v,b;int j;
		for (j=i;!vis[j];j=p[j]) vis[j]=1,v.push_back(j);
		int fl=0;
		for (auto i:v){
			if (i==j) fl=1;
			if (fl) b.push_back(i),co[i]=1;
		}
		if (b.size()){
			++tot;
			for (auto i:b) vec[tot].push_back(i);
		}
	}
	int ans=0;
	for (int i=1;i<=n;++i)
		if (!co[i]) dp[p[i]]+=q[i];
	for (int i=1;i<=n;++i)
		if (!co[i]) ans+=max(0ll,q[i]-dp[i]);
	for (int i=1;i<=tot;++i){
		for (auto j:vec[i]) sb[p[j]]=dp[p[j]]+q[j];
		for (int j=0;j<vec[i].size();++j)
			if (j) pre[j]=pre[j-1]+max(0ll,q[vec[i][j]]-sb[vec[i][j]]);
			else pre[j]=max(0ll,q[vec[i][j]]-sb[vec[i][j]]);
		for (int j=vec[i].size()-1;~j;--j)
			if (j!=vec[i].size()-1) suf[j]=suf[j+1]+max(0ll,q[vec[i][j]]-sb[vec[i][j]]);
			else suf[j]=max(0ll,q[vec[i][j]]-sb[vec[i][j]]);
		int pl=1e18;
		for (int j=0;j<vec[i].size();++j){
			int r=max(0ll,q[vec[i][j]]-dp[vec[i][j]]);
			if (j) r+=pre[j-1];
			if (j!=vec[i].size()-1) r+=suf[j+1];
			pl=min(pl,r);
		}
		ans+=pl;
	}
	cout<<ans<<'\n';
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
	int t=1;
//	cin>>t;
	while (t--) solve();
	return 0;
}
```

---

## 作者：FReQuenter (赞：0)

不难发现，人分两类：只欠债的和欠债与收债都有的。

那就把这两类人分开考虑。对于只欠债的，就只能出所有的钱了。这些人处理完之后对答案就没有影响了，可以忽略。接下来看两者都有的。

一个性质：剩下来的人会组成若干个环。因为这些人都有且仅有 $1$ 条入边和 $1$ 条出边，刚好符合环的定义。

那么就遍历每一个环，需要的钱就是在该环内流通的最大值。

关于代码处理：可以记录每个人处理完第一种人时的钱数，这样在环内的判断会方便很多。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,a[200005],b[200005],m[200005],ind[200005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i],ind[a[i]]++;
	queue<int> q;
	for(int i=1;i<=n;i++) if(!ind[i]) q.push(i);
	while(!q.empty()){
		int fr=q.front();
		q.pop();
		if(m[fr]<b[fr]){
			ans+=b[fr]-m[fr];
		}
		m[a[fr]]+=b[fr];
		ind[a[fr]]--;
		if(!ind[a[fr]]) q.push(a[fr]);
	}
	for(int i=1;i<=n;i++){
		if(!ind[i]) continue;
		int now=a[i],minn=0x3f3f3f3f3f3f3f3fll,lst=i;
		while(ind[now]){
			if(b[lst]+m[now]<b[now]){
				ans+=b[now]-(b[lst]+m[now]);
				m[now]+=b[now]-(b[lst]+m[now]);
			}
			minn=min(minn,b[now]-m[now]);
            ind[now]=0,lst=now,now=a[now];
		}
		if(minn>0) ans+=minn;
	}
	cout<<ans;
}
```

---


# [COCI 2016/2017 #2] Zamjene

## 题目背景

**警告：滥用本题评测将被封号。**

## 题目描述

Dominik 构造了一个含有 $n$ 个元素的数组 $p_1,p_2,\dots,p_n$，和对其排序得到的数组 $q_1,q_2,\dots,q_n$。

此外，他还定义了「可交换集」。若无序数对 $(a,b)$ 属于「可交换集」，则他可以交换 $p_a,p_b$ 的位置。『通过「可交换集」』，即为**通过若干次这样的交换**。

现有四种操作：

- 操作 $1$：

	格式：`1 a b`。
    
    交换 $p_a,p_b$ 的位置（不受「可交换集」限制）。
    
- 操作 $2$：

	格式：`2 a b`。
    
    将无序数对 $(a,b)$ 加入「可交换集」。
    
- 操作 $3$：
	
    格式：`3`。
    
    判断能否通过「可交换集」完成对数组 $p$ 的排序。
    
- 操作 $4$：

	格式：`4`。
    
    若数组 $p$ 中的第 $x$ 个元素能通过「可交换集」移至第 $y$ 位，则称 $x,y$ 是相连的。其中 $x$ 可能等于 $y$。
    
    将所有与 $x$ 相连的 $y$ 构成的集合称作 $x$ 的「云」。若一朵「云」能通过「可交换集」使得「云」中任意的 $i$ 满足 $p_i=q_i$，则称这朵「云」是「祥云」。
    
    计算有多少组无序数对 $(a,b)$ 满足：
    
    - $1\le a,b\le n$ 且 $a\not=b$。
	- $a,b$ 不是相连的。
	- $a$ 的「云」与 $b$ 的「云」均不是「祥云」。
    - 将无序数对 $(a,b)$ 加入「可交换集」后，$a$ 的「云」变为「祥云」。
    
请你帮助 Dominik 完成这些操作。

## 说明/提示

#### 样例 1 解释

- 第一次操作：仅有无序数对 $(2,3)$ 满足要求。
- 第二次操作：不能通过「可交换集」完成对数组 $p$ 的排序。
- 第三次操作：将无序数对 $(2,3)$ 加入「可交换集」。
- 第四次操作：不存在满足要求的无序数对。
- 第五次操作：交换 $p_2,p_3$，即可通过「可交换集」完成对数组 $p$ 的排序。

------------

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n,q\le 10^6$，$1\le p_i\le 10^6$，$1\le t\le 4$，$1\le a,b\le n$ 且 $a\not=b$。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T5 Zamjene_**。

## 样例 #1

### 输入

```
3 5
1 3 2
4
3
2 2 3
4
3 ```

### 输出

```
1
NE
0
DA ```

## 样例 #2

### 输入

```
5 5
4 2 1 4 4
3
4
1 1 3
3
4 ```

### 输出

```
NE
1
DA
0 ```

## 样例 #3

### 输入

```
4 10
2 1 4 3
3
4
1 1 2
3
4
2 2 3
2 1 2
4
2 3 4
3 ```

### 输出

```
NE
2
NE
1
3
DA ```

# 题解

## 作者：cqbzlzm (赞：4)

### *Description*

先简单转换一下题意：

|    操作      |         事件    |
| :-----------   |    :----------- |
| 1 | 交换两个位置上的数的值 |
| 2 | 合并两朵云 |
| 3 |是否所有云都是祥云  |
| 4 | 计算有多少**非祥云**合并后成为了**祥云** |


### *Solution*


注意到要合并两朵云，所以想到要使用并查集。每朵云就是一个集合，用并查集维护。

我们考虑如何判断一朵云是**祥云**：

假设一朵云中对应位置的集合上的数$i$的出现次数记为$cnt_i$。比如一朵云上位置上的数为 $1,2,2$，那么 $cnt_1 = 1, cnt_2 = 2$。

对于 $cnt_1,cnt_2 \cdots cnt_n$，我们考虑使用**哈希**来记录整个数组。

即对于每个并查集维护一个 $H = P^ncnt_n + P^{n - 1}cnt_{n - 1}+...+Pcnt_1+cnt_0$，当然，同样对排完序后云包含的位置上的数值维护一个哈希值，记作 $Hq$。

在合并两个并查集时，我们只需要将两个并查集的原有哈希值相加即可。


完成上述操作后，我们就可以在合并并查集的时候记录**祥云**数量，这样操作3也解决了。

最后考虑操作4，设有两朵**云**，哈希值为 $H_1,Hq_1, H_2, Hq_2$。 

首先要满足条件——这两朵云都是**非祥云**，即 $H_1 \neq Hq_1 $ 且 $H_2 \neq Hq_2$。

再考虑操作后变成祥云，即 $H_1 + H_2 = Hq_1 + Hq_2$。

移项得：$Hq_1-H_1=-(Hq_2-H_2)$ 且 $Hq_1-H1\neq 0$。

所以我们维护一个 `map`，下表为 $Hq_1-H_1$，值为满足这个条件的祥云的元素个数和。

这道题到这里就结束了，注意所有操作都是再并查集里面边修改边维护，所以操作很多，现成一个函数会简洁很多。


# *Code*


```cpp
#include <bits/stdc++.h>
using namespace std;
#define PP 1234577
//#define mod 1000000000000007
#define MAXN 1000000
#define int long long
int Pow[MAXN + 5];
int n, q, gcloud, cloud, ans;
int p[MAXN + 5], qq[MAXN + 5];
int father[MAXN + 5], H[MAXN + 5], Hq[MAXN + 5], Size[MAXN + 5];
map<int, int>mp;
void add(int K, int S) {
	if (K != 0)
		ans = ans + mp[-K] * S;
	mp[K] += S;
	return;
}
void sub(int K, int S) {
	if (K != 0)
		ans = ans - mp[-K] * S;
	mp[K] -= S;
	return;
}
int find(int x) {
	if (father[x] == x)
		return x;
	return father[x] = find(father[x]);
}
void merge(int x, int y) {
	int fx = find(x), fy = find(y);
	if (fx == fy)
		return;
	if (H[fx] == Hq[fx]) 
		gcloud --;
	if (H[fy] == Hq[fy]) 
		gcloud --;
	cloud --;
	father[fx] = fy;
	sub(Hq[fx] - H[fx], Size[fx]);
	sub(Hq[fy] - H[fy], Size[fy]);
	H[fy] = (H[fy] + H[fx]) ;
	Hq[fy] = (Hq[fy] + Hq[fx]) ;
	Size[fy] = Size[fx] + Size[fy];
	add(Hq[fy] - H[fy], Size[fy]);
	if (H[fy] == Hq[fy])
		gcloud ++;
	return;
}

signed main() {
	Pow[0] = 1ll;
	for (int i = 1; i <= MAXN; i ++)
		Pow[i] = Pow[i - 1] * PP ;
	scanf("%lld%lld", &n, &q);
	for (int i = 1; i <= n; i ++)
		father[i] = i, Size[i] = 1;
	for (int i = 1; i <= n; i ++)
		scanf("%lld", &p[i]), qq[i] = p[i];
	sort(qq + 1, qq + 1 + n);
	for (int i = 1; i <= n; i ++) {
		H[i] = Pow[p[i]];
		Hq[i] = Pow[qq[i]];
		if (H[i] == Hq[i])
			gcloud++;
		add(Hq[i] - H[i], 1);
		cloud++;
	}
	while (q --) {
		int op, a, b;
		scanf("%lld", &op);
		if (op == 1) {
			scanf("%lld%lld", &a, &b);
			int fx = find(a), fy = find(b);
			if (fx == fy) {
				swap(p[a], p[b]);
				continue;
			}
			if (H[fx] == Hq[fx])
				gcloud --;
			if (H[fy] == Hq[fy])
				gcloud --;
			sub(Hq[fx] - H[fx], Size[fx]);
			sub(Hq[fy] - H[fy], Size[fy]);
			H[fx] = ((H[fx] - Pow[p[a]] + Pow[p[b]])  )  ;
			H[fy] = ((H[fy] - Pow[p[b]] + Pow[p[a]])  )  ;
			swap(p[a], p[b]);
			add(Hq[fx] - H[fx], Size[fx]);
			add(Hq[fy] - H[fy], Size[fy]);
			if (H[fx] == Hq[fx])
				gcloud ++;
			if (H[fy] == Hq[fy])
				gcloud ++;
		}
		if (op == 2) {
			scanf("%lld%lld", &a, &b);
			merge(a, b);
		}
		if (op == 3) {
			if (cloud == gcloud)
				printf("DA\n");
			else
				printf("NE\n");
		}
		if (op == 4) {
			printf("%lld\n", ans);
		}
	}
	return 0;
}

```

---

## 作者：zsq147258369 (赞：4)

对于可交换集中的元素，可以用类似于冒泡的方法将他们排序，则如果一个交换集中的所有元素与其对应位置的 q 完全重合，则这个交换集可以对 p 的排序做出贡献。反之，若有一个交换集无法满足对应关系，则无法对 p 排序。

想要快速判断交换集中元素是否与 q 中对应位置元素相等，可以用哈希。数 $x$ 对应的哈希值为 $x^{p_1}$，模数为 $p_2$，然后一个集合内的元素哈希值加进来即为集合的哈希值。

对于每一个交换集，记录 $val_i$ 表示集合中元素哈希值，$pre_i$ 表示其在 q 中对应位置的哈希值。

对于操作 3，记录一个 $num$ 表示 $pre_i=val_i$ 的个数，每合并一个集合就把 $num$ 加 1，$num=n$ 则表示可以完成对 p 的排序。

对于操作 4，记录 $ans$ 表示答案，并把无序数对转为有序~~因为好处理~~。我们要求的是 $pre_i+pre_j=val_i+val_j$ 且 $val_i\neq pre_i,val_j\neq pre_j$ 的个数。移项，可得 $pre_i-val_i=val_j-pre_j$，可以把每个 $pre_i-val_i$ 丢进 map 里面查询。

每次操作前把 $a,b$ 所在交换集对 $num$ 和 $ans$ 的影响减掉，注意还要乘 2。若 $a,b$ 已在一个集合内，则直接跳过。当 $pre_a+pre_b=val_a+val_b$ 时，还要减掉重复算的。注意 map 加入或减掉的是集合的大小而不是 1。

把上面的操作搞完后，我得到了 [68 分](https://www.luogu.com.cn/record/81354947)的~~好成绩~~。应该是我运气太好了，模数取烂了。我搞了个双哈希就过了。

# $code$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+50,ba=10000019,baa=10000079,mod=1000000513;

struct node
{
	int a,b;
	
	friend node operator+(node a,node b)
	{
		return (node){(a.a+b.a)%mod,(a.b+b.b)%mod};
	}
	
	friend node operator-(node a,node b)
	{
		return (node){(a.a-b.a+mod)%mod,(a.b-b.b+mod)%mod};
	}
	
	friend bool operator==(node a,node b)
	{
		return (a.a==b.a)&(a.b==b.b);
	}
	
	friend bool operator!=(node a,node b)
	{
		return (a.a!=b.a)|(a.b!=b.b);
	}
	
	friend bool operator<(node a,node b)
	{
		return a.a==b.a?a.b<b.b:a.a<b.a;
	}
}val[N],pre[N];

int n,Q,p[N],q[N],ro[N],num,len[N],ans;
map<node,int>mp;

int ksm(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

int find(int x)
{
	return x==ro[x]?x:(ro[x]=find(ro[x]));
}

main()
{
	cin>>n>>Q;
	for(int i=1;i<=n;i++)cin>>p[i],q[i]=p[i],ro[i]=i,val[i]=(node){ksm(p[i],ba),ksm(p[i],baa)},len[i]=1;
	sort(q+1,q+1+n);
	for(int i=1;i<=n;i++)pre[i]=(node){ksm(q[i],ba),ksm(q[i],baa)},num+=(pre[i]==val[i]),mp[pre[i]-val[i]]++;
	for(int i=1;i<=n;i++)if(pre[i]!=val[i])ans+=mp[val[i]-pre[i]];
	int opt,a,b;
	while(Q--)
	{
		cin>>opt;
		if(opt==1)
		{
			cin>>a>>b;
			int ra=find(a),rb=find(b);
			if(ra==rb){swap(p[a],p[b]);continue;}
			num-=(pre[ra]==val[ra])+(pre[rb]==val[rb]);
			if(pre[ra]!=val[ra])ans-=2*len[ra]*mp[val[ra]-pre[ra]];
			if(pre[rb]!=val[rb])ans-=2*len[rb]*mp[val[rb]-pre[rb]];
			if(pre[ra]+pre[rb]==val[ra]+val[rb]&&pre[ra]!=val[ra])ans+=2*len[ra]*len[rb];
			mp[pre[ra]-val[ra]]-=len[ra];mp[pre[rb]-val[rb]]-=len[rb];
			val[ra]=val[ra]-(node){ksm(p[a],ba),ksm(p[a],baa)};
			val[rb]=val[rb]+(node){ksm(p[a],ba),ksm(p[a],baa)};
			val[ra]=val[ra]+(node){ksm(p[b],ba),ksm(p[b],baa)};
			val[rb]=val[rb]-(node){ksm(p[b],ba),ksm(p[b],baa)};
			swap(p[a],p[b]);
			num+=(pre[ra]==val[ra])+(pre[rb]==val[rb]);
			mp[pre[ra]-val[ra]]+=len[ra];mp[pre[rb]-val[rb]]+=len[rb];
			if(pre[ra]!=val[ra])ans+=2*len[ra]*mp[val[ra]-pre[ra]];
			if(pre[rb]!=val[rb])ans+=2*len[rb]*mp[val[rb]-pre[rb]];
			if(pre[ra]+pre[rb]==val[ra]+val[rb]&&pre[ra]!=val[ra])ans-=2*len[ra]*len[rb];
			continue;
		}
		if(opt==2)
		{
			cin>>a>>b;
			a=find(a),b=find(b);
			if(a==b)continue;
			num-=(pre[a]==val[a])+(pre[b]==val[b]);num++;
			if(pre[a]!=val[a])ans-=2*len[a]*mp[val[a]-pre[a]];
			if(pre[b]!=val[b])ans-=2*len[b]*mp[val[b]-pre[b]];
			if(pre[a]+pre[b]==val[a]+val[b]&&pre[a]!=val[a])ans+=2*len[a]*len[b];
			mp[pre[a]-val[a]]-=len[a];mp[pre[b]-val[b]]-=len[b];
			val[a]=val[a]+val[b];
			pre[a]=pre[a]+pre[b];
			ro[a]=ro[b]=a;len[a]+=len[b];
			num+=(pre[a]==val[a]);
			mp[pre[a]-val[a]]+=len[a];
			if(pre[a]!=val[a])ans+=2*len[a]*mp[val[a]-pre[a]];
			continue;
		}
		if(opt==3)
		{
			if(num==n)puts("DA");
			else puts("NE");
			continue;
		}
		cout<<ans/2<<'\n';
	}
}
```

---

## 作者：封禁用户 (赞：3)

# 1.前言
[AC记录](https://www.luogu.com.cn/record/56774129)

原 blog：[CSDN](https://blog.csdn.net/qq_37656398/article/details/93631728)

对于操作 3，相当于将一堆有关联的东西连在一起并互相替换。

如何证明排序？我们可以尝试 $O(N^2)$ 的暴力查询，但显然是 T 的。

# 2.分析
我们只需要记录能交换的位置上的数，与排好的对应位置上的数比较，只要有相同数量的数，我们就可以认为这个“云”是好的，即这几个位置可以排好序。

所以我们可以考虑哈希。如此对于两个云我们就可以 $O(1)$ 比较了。

对于操作1，我们应先将对应位置上的数从哈希表中删掉，并交换，最后再加回去。

对于操作2，我们在合并时把对应的哈希值加上即可。

对于操作3，我们只需利用查找两组对应哈希值相减是否都为0即可。

![](https://img-blog.csdnimg.cn/20190625195728229.png)

对应操作4，我们需要找到一个如下所示的云：
这四个云必须满足 $h_1+h_3=h_2+h_4$，移项：$h_1-h_2=-(h_3-h_4)$，这样我们就可以将对应的云的哈希值相减存在 map 里，最后数一遍就行了。

# 3.code

参考代码
```cpp
#include<map>
#include<cstdio>
#include<algorithm>
using namespace std;

typedef long long ll;
const int Maxn=1e6;
const int Hash=1e7+7;
const int Mod=1e9+7;

int N,P;
int A[Maxn+5];
int Q[Maxn+5];

ll powt[Maxn+5];
ll p[Maxn+5],q[Maxn+4];
map<ll,int> diff;
int num[Maxn+5];
ll totpair;

void adddiff(int dir,ll dif,int n) {
	if(dif!=0) {
		totpair+=dir*n*diff[-dif];
	}
	diff[dif]+=dir*n;
}
void add(int dir,int u,int pos,int val) {
	p[u]+=dir*powt[pos];
	q[u]+=dir*powt[val];
	num[u]+=dir;
}

int fa[Maxn+5];
int find(int u) {
	if(fa[u]==u)return fa[u];
	return fa[u]=find(fa[u]);
}
void merge(int a,int b) {
	int u=find(a),v=find(b);
	if(u==v)return;
	adddiff(-1,p[u]-q[u],num[u]);
	adddiff(-1,p[v]-q[v],num[v]);
	fa[v]=u;
	p[u]+=p[v];
	q[u]+=q[v];
	num[u]+=num[v];
	adddiff(1,p[u]-q[u],num[u]);
}

int main() {
	freopen("zamjene.in","r",stdin);
	freopen("zamjene.out","w",stdout);
	scanf("%d %d",&N,&P);
	for(int i=1;i<=N;i++) {
		scanf("%d",&A[i]);
		fa[i]=i;
		Q[i]=A[i];
		num[i]=1;
	}
	sort(Q+1,Q+N+1);
	powt[0]=1;
	for(int i=1;i<=Maxn;i++)
		powt[i]=powt[i-1]*Hash;
	for(int i=1;i<=N;i++) {
		q[i]=powt[A[i]];
		p[i]=powt[Q[i]];
		adddiff(1,p[i]-q[i],num[i]);
	}
	while(P--) {
		int op;
		scanf("%d",&op);
		if(op==1) {
			int a,b;
			scanf("%d %d",&a,&b);
			int u=find(a),v=find(b);
			if(u==v)
				swap(A[a],A[b]);
			else {
				adddiff(-1,p[u]-q[u],num[u]);
				adddiff(-1,p[v]-q[v],num[v]);
				add(-1,find(a),a,A[a]);
				add(-1,find(b),b,A[b]);
				swap(A[a],A[b]);
				add(1,find(a),a,A[a]);
				add(1,find(b),b,A[b]);
				adddiff(1,p[u]-q[u],num[u]);
				adddiff(1,p[v]-q[v],num[v]);
			}
		} else if(op==2) {
			int a,b;
			scanf("%d %d",&a,&b);
			merge(a,b);
		} else if(op==3) {
			puts(diff[0]==N?"DA":"NE");
		} else if(op==4) {
			printf("%lld\n",totpair);
		}
	}
	return 0;
}
```


---

## 作者：lyt_awa (赞：1)

## 题目
[**<传送门>**](https://www.luogu.com.cn/problem/P6498)
## 解法（并查集 + 哈希）
### 并查集
并查集的每一个集合记录的是**下标的集合**。

用并查集的视角来看看这几个操作：
+ 操作 $1$：  
交换下标为 $a,b$ 的两个数。
+ 操作 $2$：  
合并下标 $a$ 和下标 $b$ 所在的集合（再次强调：每一个集合记录的是**下标的集合**）。
+ 操作 $3$：  
查询是否每一个集合都满足要求（要求会在下面哈希部分讲）。
+ 操作 $4$：  
在操作时维护（如何维护会在下面哈希部分讲）。

### 哈希
先来看怎样的集合满足要求：  
对于一个序列 `4 6 2 3 5 6`，排序后为 `2 3 4 5 6 6`。  
假设当前的下标集合为 $\{\{1,3\},\{2\},\{4,5,6\}\}$。  
那么对于第一个下标集合 $\{1,3\}$，排序前的序列在这些下标上的数字为 $4,2$ 排序后的序列在这些下标上的数字为 $2,4$，两集合相同，则下标集合 $\{1,3\}$ 满足要求（是「祥云」）。  
对于第三个下标集合 $\{4,5,6\}$，排序前的序列在这些下标上的数字为 $3,5,6$ 排序后的序列在这些下标上的数字为 $5,6,6$，两集合相同，则下标集合 $\{4,5,6\}$ 不满足要求（不是「祥云」）。

如何判断一个集合是否满足要求呢？  
利用计数排序的思想对于每一个下标集合构造两个哈希值：
$$\begin{array}{c}
H(S)=\sum_{i\in S} P^{p_i}\\
Hs(S)=\sum_{i\in S} P^{ps_i}
\end{array}$$
$S$ 是一个下标集合，$P$ 是常数，$p$ 是排序前的序列，$ps$ 是排序后的序列。

这样当 $H(S)=Hs(S)$ 时，就说明下标集合 $S$ 满足要求（是「祥云」）。

于是就可以愉快地完成操作 $3$ 了。
+ 操作 $3$：  
记录一个 $cl$ 表示当前下标集合的数量，再记录一个 $gcl$ 表示满足要求（是「祥云」）的下标集合的数量，若询问时 $cl = gcl$ 则说明每一个集合都满足要求，即能通过下标集合完成对数组 $p$ 的排序，输出一行 `DA`，否则输出一行 `NE`。

对于操作 $4$，先看两个下标 $a,b$ 设它们所在的下标集合分别为 $S,T$， 要满足：
1. $S\ne T$ 即，$a,b$ 不是相连的。
1. $H(S)\ne Hs(S)\wedge H(T)\ne Hs(T)$ 即，$a$ 的「云」与 $b$ 的「云」均不是「祥云」。
1. $H(S)+H(T)=Hs(S)+Hs(T)$ 即，将无序数对 $(a,b)$ 加入「可交换集」后，$a$ 的「云」变为「祥云」。

将 $3$ 中的式子移项变为 $H(S)-Hs(S)=-(H(T)-Hs(T))$ 很容易发现可以用 STLmap 来记录值为 $H(S)-Hs(S)$ 的下标集合个数，然后再其他操作的过程中维护操作 $4$ 的答案。
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ULL unsigned long long
const int N = 1000005, P = 131;

int n, m, p[N], ps[N], fa[N], siz[N], cl, gcl;
ULL H[N], Hs[N], _p[N], ans;
unordered_map<ULL, int> mp;

inline void add(int x, int op) {//加入下标集合 x和 y 对操作 4的 ans的贡献 
	ULL c = H[x] - Hs[x];
	if (c) ans += op * mp[-c] * siz[x];
	mp[c] += op * siz[x];
}
inline void del(int x, int y) {//删除下标集合 x和 y 对操作 4的 ans的贡献 
	if (H[x] == Hs[x]) --gcl;
	if (H[y] == Hs[y]) --gcl;
	add(x, -1), add(y, -1);
}

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

int main() {
	scanf("%d%d", &n, &m);
	_p[0] = 1;
	for (int i = 1; i <= n; ++i) scanf("%d", &p[i]), ps[i] = p[i], _p[i] = _p[i - 1] * P;
	sort(ps + 1, ps + n + 1);
	for (int i = 1; i <= n; ++i) {
		fa[i] = i, siz[i] = 1, H[i] = _p[p[i]], Hs[i] = _p[ps[i]];
		if (H[i] == Hs[i]) ++gcl;//初始化操作 3的 gcl
		++cl;//初始化操作 3的 cl 
		add(i, 1);//初始化操作 4的 ans 
	}
	while (m--) {
		int op, x, y, fx, fy;
		scanf("%d", &op);
		if (op == 1) {
			scanf("%d%d", &x, &y), fx = find(x), fy = find(y);
			if (fx == fy) { swap(p[x], p[y]); continue; }
			del(fx, fy);
			H[fx] += _p[p[y]] - _p[p[x]], H[fy] += _p[p[x]] - _p[p[y]];//更新哈希值 
			swap(p[x], p[y]);
			add(fx, 1), add(fy, 1);
			if (H[fx] == Hs[fx]) ++gcl; 
			if (H[fy] == Hs[fy]) ++gcl;
		} else if (op == 2) {
			scanf("%d%d", &x, &y), fx = find(x), fy = find(y);
			if (fx == fy) continue;
			del(fx, fy), --cl;
			fa[fx] = fy, H[fy] += H[fx], Hs[fy] += Hs[fx], siz[fy] += siz[fx];
			add(fy, 1);
			if (H[fy] == Hs[fy]) ++gcl;
		} else if (op == 3) puts(cl == gcl ? "DA" : "NE");
		else printf("%llu\n", ans);
	}
	return 0;
}
```
时间复杂度 $O(N\log N)$。

---

## 作者：Inzaghi_Luo (赞：0)

### 分析
我们先看操作四中对于云的定义。由于它是有可交换集连接的，这就启发我们要用并查集去维护。

我们再看祥云的定义。当云是祥云是，这个云包含元素所组成的集合要等于其对应位置在有序数组上的集合。而判断两个集合相等，这就启发我们要用哈希。考虑设计哈希函数为 $\sum cnt_xbase^x$ 的形式，好处在于当两个集合合并时，哈希值可以直接相加。

现在再看如何处理每一个操作。

对于操作一，直接修改两个位置对应集合的哈希值即可。

对于操作二，并查集直接合并。

对于操作三，等价于判断所有云是否都是祥云。

对于操作四，两个云要对应哈希值相加后相等，移项后用 map 存一下就好。

具体实现看代码。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int MAXN = 1000005;
int fa[MAXN], sz[MAXN];
int belong(int x){
	if(x == fa[x]) return x;
	return fa[x] = belong(fa[x]);
} 
int p[MAXN], o[MAXN];
ull base[MAXN], hp[MAXN], ho[MAXN];
map<ull, int> t; 
long long ans;
void change(ull wz, int num, int op){
	if(wz) ans += 1ll * num * t[-wz] * op;
	t[wz] += num * op;
}
int main(){
	int n, q;
	scanf("%d%d", &n, &q);
	base[0] = 1;
	base[1] = 0x66ccff;
	for(int i = 2;i <= 1000000;i++) base[i] = base[i - 1] * base[1];
	for(int i = 1;i <= n;i++){
		fa[i] = i;
		sz[i] = 1;
		scanf("%d", &p[i]);
		o[i] = p[i];
	}
	sort(o + 1, o + n + 1);
	int num = n, lucky = 0;
	for(int i = 1;i <= n;i++){
		hp[i] = base[p[i]];
		ho[i] = base[o[i]];
		if(hp[i] == ho[i]) lucky++;
		change(hp[i] - ho[i], 1, 1);
	}
	for(int i = 1, op, a, b;i <= q;i++){
		scanf("%d", &op);
		if(op == 1){
			scanf("%d%d", &a, &b);
			int ba = belong(a), bb = belong(b);
			if(ba == bb){
				swap(p[a], p[b]);
				continue;
			}
			change(hp[ba] - ho[ba], sz[ba], -1);
			change(hp[bb] - ho[bb], sz[bb], -1);
			if(hp[ba] == ho[ba]) lucky--;
			if(hp[bb] == ho[bb]) lucky--;
			hp[ba] = hp[ba] - base[p[a]] + base[p[b]];
			hp[bb] = hp[bb] + base[p[a]] - base[p[b]];
			swap(p[a], p[b]);
			if(hp[ba] == ho[ba]) lucky++;
			if(hp[bb] == ho[bb]) lucky++;
			change(hp[ba] - ho[ba], sz[ba], 1);
			change(hp[bb] - ho[bb], sz[bb], 1);
		}
		else if(op == 2){
			scanf("%d%d", &a, &b);
			int ba = belong(a), bb = belong(b);
			if(ba == bb) continue;
			num--;
			change(hp[ba] - ho[ba], sz[ba], -1);
			change(hp[bb] - ho[bb], sz[bb], -1);
			if(hp[ba] == ho[ba]) lucky--;
			if(hp[bb] == ho[bb]) lucky--;
			fa[bb] = ba;
			sz[ba] += sz[bb];
			hp[ba] += hp[bb];
			ho[ba] += ho[bb];
			change(hp[ba] - ho[ba], sz[ba], 1);
			if(hp[ba] == ho[ba]) lucky++;
		}
		else if(op == 3){
			if(num == lucky) puts("DA");
			else puts("NE");
		}
		else{
			printf("%lld\n", ans);
		}
	}
	return 0;
}

```

---


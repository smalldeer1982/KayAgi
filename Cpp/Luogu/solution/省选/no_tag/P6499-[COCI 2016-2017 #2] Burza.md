# [COCI 2016/2017 #2] Burza

## 题目描述

Daniel 和 Stjepan 在一棵含有 $n$ 个节点的树上做游戏，树上各节点的编号为 $1,2,\dots,n$。游戏开始时，$1$ 号节点上有一枚硬币。

游戏规则如下：

1. Daniel 选择一个节点，将其标记。
2. Stjepan 标记当前硬币所在的节点。
3. Stjepan 将硬币移至一个**尚未标记**且**与当前所在的节点相邻**的节点。

重复以上操作。当 Stjepan 无法移动硬币时，游戏结束。

Daniel 想知道是否存在某种**既定**的操作策略，使得**无论 Stjepan 如何操作**，都能在 $k$ 轮操作内结束游戏。即 Stjepan 能移动硬币的次数**小于** $k$。

## 说明/提示

#### 【样例解释】

**样例 2 解释**

- 若 Daniel 标记结点 $1$，Stjepan 可以将硬币移至结点 $2$ 或结点 $3$。
- 若 Daniel 标记结点 $2$，Stjepan 可以将硬币移至结点 $3$。
- 若 Daniel 标记结点 $3$，Stjepan 可以将硬币移至结点 $2$。

均不能在 $1$ 轮操作内结束游戏。

即不存在满足条件的操作策略。

**样例 3 解释**

- 第一轮操作，Daniel 标记结点 $2$。
- 第二轮操作，Daniel 标记结点 $6$。

无论 Stjepan 如何操作，都无法第二次移动硬币。

即存在满足条件的操作策略。

------------

#### 【数据规模与约定】

对于 $100\%$ 的数据，$1\le k\le n\le 400$，$1\le a,b\le n$。

------------

#### 【说明】

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T6 Burza_**。

## 样例 #1

### 输入

```
6 2
1 2
2 3
3 4
1 5
5 6 ```

### 输出

```
DA ```

## 样例 #2

### 输入

```
3 1
1 2
1 3 ```

### 输出

```
NE ```

## 样例 #3

### 输入

```
8 2
1 2
2 3
2 4
5 6
6 8
1 5
7 1 ```

### 输出

```
DA ```

# 题解

## 作者：panyf (赞：17)

偏思维的状压 dp 。

不要被数据范围吓到，当 $k>19$ 时直接输出 DA 就行，以下是简要证明：

首先，删掉所有深度大于 $k$ 的点（假设根节点深度为 $0$ ）。删掉所有子树内不存在深度等于 $k$ 的点的点，因为如果 Stjepan 走到这些点就不可能取胜了。

注意到 Daniel 第 $i$ 次标记的点深度必须大于等于 $i$ ，否则这次标记就是无效的。一个显然的贪心策略就是第 $i$ 次标记一个深度等于 $i$ 的点，这样能够堵住尽可能多的点。

考虑最坏的情况，就是根节点下面连了 $k$ 条长度为 $k$ 的链，此时只需每次堵住一条链， $k$ 次恰好能堵住所有的链，而此时 $n=k\times k+1$ 。所以只有 $n>k\times k+1$ 时 Stjepan 才可能获胜。此时如果 $k>19$ ，那么 $n>k\times k+1>400$ ，不符合题意。

对于其他的情况，每次堵住当前最大的子树，如果这棵子树已经变成一条链，那么转换为之前的情况，否则堵住的点数肯定多于之前的情况。所以只要 $k>19$ 那么 Daniel 必胜。

现在数据范围已经被大幅缩小，只需要 $O(n2^k)$ 的复杂度即可通过本题（常数很小，最慢点也就 100 多 ms ）。很容易想到状压 dp 。

根据 dfs 序的性质， 每一棵子树可以用 dfs 序上一段区间表示。那么我们预处理出 dfs 序。设 $f[i][j]$ 表示标记了深度状压后为 $j$ 的点，是否可以堵住 dfs 序在 $i$ 以后的点。

设 $sz[i]$ 为 $i$ 的子树大小， $g[i]=f[i]+sz[i]$ ，那么 $i$ 的子树即为 $i$ 到 $g[i]-1$ 中的所有点， $f[i]$ 就可以用 $f[g[i]]$ 来转移，因为只要堵住了 $g[i]$ 以后的点和点 $i$ ，那么 $i$ 子树中的点也被堵住了， $i$ 以后的点就都被堵住了。

当 $i$ 的深度小于 $k$ 时， $f[i]$ 还可以直接继承 $f[i+1]$ ，因为如果堵住了 $i+1$ 以后的点，就堵住了 $i$ 子树中除自身外所有点，点 $i$ 也没用了。

具体转移方程和细节见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=403;
bool b[N],f[N][525003];
int he[N],to[N*2],ne[N*2],fa[N],g[N],d[N],p[N],id;
void dfs1(int x,int y){//预处理父亲和深度
	fa[x]=y,d[x]=d[y]+1;
	for(int i=he[x],j;i;i=ne[i])if((j=to[i])!=y)dfs1(j,x);
}
void dfs2(int x,int y,int z){//预处理dfs序
	for(int i=he[x],j;i;i=ne[i])if((j=to[i])!=y&&b[j])dfs2(j,x,++id);
	g[z]=id,p[z]=d[x];
}
int main(){
	int n,k,u,i,j,l,v,t=0;
	scanf("%d%d",&n,&k),u=1<<k,d[0]=-1;
	if(k>19)return puts("DA"),0;
	for(i=1;i<n;++i){
		scanf("%d%d",&j,&l);
		ne[++t]=he[j],to[t]=l,he[j]=t;
		ne[++t]=he[l],to[t]=j,he[l]=t;
	}
	dfs1(1,0);
	for(i=1;i<=n;++i)if(d[j=i]==k)do b[j]=1;while(j=fa[j]);//标记有用点
	dfs2(1,0,0),memset(f[id+1],1,u);
	for(i=id;i;--i){
		if(g[i]>i)memcpy(f[i],f[i+1],u);
		for(j=0,l=g[i]+1,v=1<<p[i]-1;j<u;++j)if(!(j&v))f[i][j|v]|=f[l][j];
	}
	puts(f[1][u-1]?"DA":"NE");
	return 0;
}
```

---

## 作者：寻逍遥2006 (赞：11)

为什么没有人写 $O(k2^k)$ 的做法？

首先证明一个结论：当 $k\ge \sqrt{n}$ 的时候，一定是 Daniel 赢。

证明如下。钦定根的深度为 $0$，显然我们不需要考虑所有深度 $\ge k$ 的节点以及没有深度 $\ge k$ 的子孙的节点。我们现在要标记上 $k$ 个节点使得从根到任何一个叶子的路径上都有点被标记。

根据贪心，我们可以知道，第 $i$ 次一定会标记第 $i$ 层的某个节点，同时每一次至少会额外使得一个叶子到根的路径上有节点被标记（否则就说明所有的叶子到根的路径都被标记过了）。

考虑最劣的情况，每次只能堵住一个节点，这样的构造是 $k$ 条一段以 $1$ 为端点的长为 $k$ 的链。这样的树的节点数是 $k^2+1$ 个。

也就意味着所有节点数 $\le k^2+1$ 的树一定是 Daniel 赢，也就是 $n\le k^2+1$，即 $k\ge \sqrt{n}$ 的时候，Daniel 一定赢。

也就是可以认为 $k\ge 20$ 的时候，一定是 Daniel 赢。

现在我们的 $k\le 19$ 了，考虑这是如何判断 Daniel 是否能赢。

我们还是可以按照上面给出的方式将树上所有深度 $\ge k$ 的节点以及没有深度 $\ge k$ 的子孙的节点删去。将新树 dfs 一遍，将所有的叶子按照 dfs 序重标号，则每一个节点的所有叶子子孙将会对应一段区间 $[L_i,R_i]$。

假设一共有 $cnt$ 个叶子。

我们现在需要在每一个深度中选择一个节点，使得他们的交是 $[1,cnt]$。

考虑状压 + 贪心，记 $f_S$ 表示从 $S$ 这些深度中每层选择一个节点，最大的可能的 $t$，使得这些节点对应区间的交包含 $[1,t]$。

如果有一个 $f_S=cnt$ 则说明 Daniel 赢。

考虑转移，找到 $i\notin S$，找到深度为 $i$ 且包含编号为 $f_S+1$ 的叶子的节点 $u$，它对应的叶子区间为 $[L_u,R_u]$，则 $f_{S\cup \{i\}}\gets \max\{f_{S\cup \{i\}},R_u\}$。

考虑这个贪心为什么是对的，对于 $i\ge j$，任何一层中，$i$ 对应的 $R_u$ 一定比 $j$ 对于的 $R_u'$ 大。所以这个贪心很对。

现在这个做法是本题最快解，是次快的非完隐选手的一半。

```cpp
#include <bits/stdc++.h>
using namespace std;
int Qread()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
    return x;
}
int n,k,st;
vector<int> ed[410];
void add_edge(int u,int v)
{
    ed[u].push_back(v);
    ed[v].push_back(u);
}
int get_max(int &a,int b){if(a<b) a=b;}
int ls[410];
int f[1<<20|5];
int dep[410],L[410],R[410];
int Tr[20][410],ind;
void dfs(int a,int fa)
{
    dep[a]=dep[fa]+1;
    L[a]=ind+1;
    for(int v:ed[a])
        if(v!=fa)
            dfs(v,a);
    if(fa&&ed[a].size()==1&&dep[a]>=k) ++ind;
    R[a]=ind;
    if(dep[a]<=k)
        for(int i=L[a];i<=R[a];i++)
            Tr[dep[a]][i]=R[a];
}
int main()
{
    n=Qread(),k=Qread();
    for(int i=1;i<n;i++)
        add_edge(Qread(),Qread());
    if(k>=20)
    {
        printf("DA");
        return 0;
    }
    dep[0]=-1;
    dfs(1,0);

    st=1<<k;
    for(int S=0;S<st;S++)
    {
        if(f[S]==ind)
        {
            printf("DA");
            return 0;
        }
        for(int i=1;i<=k;i++)
            if(!(S&(1<<i-1)))
                get_max(f[S|(1<<i-1)],Tr[i][f[S]+1]);
    }
    printf("NE");
    return 0;
}
```

---

## 作者：_determination_ (赞：9)

致敬传奇乱搞搜索大师！！！

[你](https://www.luogu.com.cn/user/530468)是一名参与联考的学生，现在[你](https://www.luogu.com.cn/user/530468)打开了 T3，一道奇妙博弈题。

看到这道题[你](https://www.luogu.com.cn/user/530468)立刻发现[你](https://www.luogu.com.cn/user/530468)会了一个 $2^n$ 的暴力枚举。[你](https://www.luogu.com.cn/user/530468)开始测试大样例。[你](https://www.luogu.com.cn/user/530468)发现大样例水的一批，竟然全过了。

[你](https://www.luogu.com.cn/user/530468)同时看到了题面里有这样一句话：

> 请选手相信自己的常数。

于是[你](https://www.luogu.com.cn/user/530468)认为爆搜是有希望的，于是[你](https://www.luogu.com.cn/user/530468)开始剪枝。

1. 减去所有深度 $>k$ 的点和子树内没有深度 $>k$ 的点的点。
2. 显然分析性质，可以知道肯定是每个深度的点各选一个。
3. 如果祖先已经被封锁，那么就不用继续搜索。
4. 如果所有深度 $>k$ 的点全部被封锁，则直接输出有解。

由于这是考场，[你](https://www.luogu.com.cn/user/530468)还要打暴力，于是[你](https://www.luogu.com.cn/user/530468)稍微分析一下复杂度并尝试卡了一下之后就扔掉了，[你](https://www.luogu.com.cn/user/530468)认为这可以通过 70 分（$n\leq 50$）。

[你](https://www.luogu.com.cn/user/530468)看到了旁边的人的屏幕，他也在剪枝。但是[你](https://www.luogu.com.cn/user/530468)看到他的 report 上写着“很轻易被卡”。决定考完之后找他要一组 hack。

考试结束之后[你](https://www.luogu.com.cn/user/530468)轻易的通过了 hack 但是在榜上还是 70 分。[你](https://www.luogu.com.cn/user/530468)被卡了。但是[你](https://www.luogu.com.cn/user/530468)发现 50 个点的 sub 你过了26 个点，[你](https://www.luogu.com.cn/user/530468)仍然认为爆搜大有希望。但是放学了，[你](https://www.luogu.com.cn/user/530468)决定在第二天周六继续剪枝。

[你](https://www.luogu.com.cn/user/530468)发现 hack 形式是性质 A（除了 1 的每个节点的度数均小于等于 2，即在 1 上挂一堆链）并在叶子处添加点成为一堆蒲公英。

但是[你](https://www.luogu.com.cn/user/530468)仍然无法对着数据点性质分析出做法，但是[你](https://www.luogu.com.cn/user/530468)发现有一些蒲公英的菊花大小比较小，于是[你](https://www.luogu.com.cn/user/530468)决定将每一层的搜索顺序按照下面的目标点数排序。

[你](https://www.luogu.com.cn/user/530468)仍然无法通过所有测试点，于是[你](https://www.luogu.com.cn/user/530468)决定卡时，然后[你](https://www.luogu.com.cn/user/530468)获得了[通过](https://www.luogu.com.cn/record/183161994)。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int mod=998244353,inf=0x3f3f3f3f3f3f3f3f;
const int N=410,M=2e5+10;
int n,k;
vector<int>e[N];
vector<pair<int,int>>E;
int checkA()
{
	for ( int i = 2 ; i <= n ; i++ )if(e[i].size()>2)return 0;
	return 1;
}
int dep[N],cnt[N],fa[N];
void dfs(int x,int f)
{
    cnt[x]=0;
	if(dep[x]==k)cnt[x]=1;
	fa[x]=f;
	for ( auto v:e[x] )
	{
		if(v==f)continue;
		dep[v]=dep[x]+1;
		dfs(v,x);
        if(cnt[v])E.push_back({x,v});
		cnt[x]+=cnt[v];
	}
}
void A()
{
	if(cnt[1]<=k)cout << "DA";
	else cout << "NE";
}
int tag[N];
int dfs2(int x,int f)
{
	if(dep[x]==k)return 1;
	for ( auto v:e[x] )
	{
		if(v==f||tag[v])continue;
		if(dfs2(v,x))return 1;
	}
	return 0;
}
vector<int>vec[N];
int find(int x)
{
	while(x!=1)
	{
		if(tag[x])return 1;
		x=fa[x];
	}
	return 0;
}
int t;
void dfs3(int x)
{
	if(cnt[1]==0)
	{
		cout << "DA";
		exit(0);
	}
	if(x==k+1)return;
    if(clock()-t>900000)
    {
        cout << "NE";
        exit(0);
    }
	assert(tag[1]==0);
	for ( auto i:vec[x] )
	{
		if(find(i))continue;
		tag[i]=1;
		cnt[1]-=cnt[i];
		dfs3(x+1);
		tag[i]=0;
		cnt[1]+=cnt[i];
	}
}
mt19937 rnd(time(0));
int cmp(int p,int q){return cnt[p]>cnt[q];}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    t=clock();
	cin >> n >> k;
	if(k>19)return cout << "DA",0;
	for ( int i = 1 ; i < n ; i++ )
	{
		int u,v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u); 
	}
	dfs(1,1);
    for ( int i = 1 ; i <= n ; i++ )e[i].clear();
    for ( auto v:E )e[v.first].push_back(v.second),e[v.second].push_back(v.first);
    // for ( auto v:E )cout << v.first << " " << v.second << endl;
    dfs(1,1);
	if(checkA())return A(),0;
	if(cnt[1]==0)return cout << "DA",0;
	for ( int i = 1 ; i <= n ; i++ )if(cnt[i])vec[dep[i]].push_back(i);
	for ( int i = 1 ; i <= n ; i++ )sort(vec[i].begin(),vec[i].end(),cmp);
	dfs3(1);
	cout << "NE";
	return 0;
}//70
//别有用心的大样例。
//用脚卡都能卡掉的小肠2^n暴力。
//分析了一下复杂度，最劣似乎是sqrt(n)^(logn)?
//继续卡常+奇技淫巧显然没有意义，不如写一下T4暴力
//感觉现在这样很难卡吧！期望70~100
//大样例个个0.00s，鉴定为别有用心。
//搓了组hack，跑得飞快。且看实际表现如何！ 
```

更新：由于[你](https://www.luogu.com.cn/user/530468)还是学生，[你](https://www.luogu.com.cn/user/530468)需要改题。由于七中将时限设为了 0.5s，于是[你](https://www.luogu.com.cn/user/530468)改完了卡时时限之后交上去 WA 了，而且只有 50 分。但是[你](https://www.luogu.com.cn/user/530468)听机房同学说卡时只需要 0.2s 就行，于是[你](https://www.luogu.com.cn/user/530468)拿出了交到联考那里的代码并添加了卡时，然后过了。

---

## 作者：hater (赞：7)


设根节点深度为一 

根据题意 可以得知

第 $i$ 轮游戏结束后 棋子一定在深度为 $i+1$ 的节点

那么我们的目标就是不让它移到深度为 $k+1$ 的节点 

同时 深度大于 $k+1$ 的节点根本不用去管 

把 深度为 $k+1$ 的节点 我们称之为 **叶子节点** 

那么 如果我们标记一个 包含叶子节点数越多的节点 

这个选择就会越优 

那么什么情况最劣 

也就是除根节点外 ， 其他节点 所包含的叶子节点数都为一 

（树长成这样：一堆深度为$k+1$的链，根节点连着所有的链端 ） 

此时如果 有 $n/k <= k$  那么答案一定是 $DA$ 

那么对于跟一般的情况 

若 $n<=k*k$ 则答案一定是 $DA$ 

那我们来考虑 $ n > k*k $ 的情况 

此时$k$的规模只在20大小左右 

（ 后文请对照代码理解 ， 很多地方将不会非常严谨 ） 

我们先来理解这个 ： 每一个深度都最多只会有一个节点被标记

当棋子在第 $i$ 层时 ， 我们会标记 $i+1$ 层的节点

为什么 ？ 如果要标记深度更深的节点 

我们完全可以把这个点移上去 ，

既可以保证原来被剪断的叶子节点 ， 现在还是被剪断的

同时还可能会有更多的叶子节点被剪断 

那么棋子在每一个深度都只会出现一次 , 相对的 , 

我们标记的点也在每一个深度有且仅有1个 。 

接下来继续讲思路 

先将以叶子节点做dfs序 （ 说的好别扭 ， 代码一眼就看明白了 ） 

如果标记了 节点 $i$ 

那么 从 $L_{i}$ 到 $R_{i}$ 的叶子节点将会被剪断 

此时这个树上问题可以形象地看成一个序列问题 

你有若干个可自行的操作（就是树上的节点） 

每一个操作可以将 区间 $L_{i}$ 至 $R_{i}$ 标记 

（ 剪断叶子节点$L_{i}$至$R_{i}$ ）

这些选择带有属性$c$ （也就是节点深度 ） 

你需要按属性严格从小到大（从$2$到$k$ ） ，执行给出的操作

问你是否能在$k$个操作内将这个序列完全标记 

有人此时会觉得用贪心 但是这是有后效性的 

稍加分析 ， 那个按属性从小到大操作是假的 

我们只要保证选择的操作 ， $c$ 互不相同就可以了 

再加上 $k$ 的规模如此之小 思路已经呼之欲出 ： 状压动规

设 $f[i][j]$ 表示属性使用情况为$j$时，序列前$i$项是否能被全部标记

易得转移方程 ： 

$f[R_{x}][j|(1<<c_{x}-1)] |= f[i][j]$ （$L_{x}=i$）

最后枚举$j$ 看 $f[len][j]$ 有没有为1的就OK了 

代码中 把$L_{x}=i$的$x$存到下标为$i$的vector中 

  同时注意代码中根节点深度为一 那么第二层深度为二
  
  转移的时候注意要把$dep$减$2$省下点空间

```cpp
#include<bits/stdc++.h> 
#define rg register
#define fp( i , x , y ) for( rg int i=(x); i<=(y); ++i ) 
#define fq( i , x , y ) for( rg int i=(y); i>=(x); --i ) 
#define il inline 
using namespace std ; 
const int N = 405 , K = 20 ; 
vector <int> v[N] , Sta[N] ; 
int n , k , L[N] , R[N] , dep[N] , cnt , f[N][1<<K] ;   
il void add( rg int x , rg int y ) { 
 v[x].push_back(y) ; v[y].push_back(x) ; }  
void dfs( int x , int fa ) { 
   int y ; dep[x] = dep[fa] + 1 ; 
   if( dep[x] == k+1 ) { L[x] = cnt ++ , R[x] = cnt ; return ;  } 
   L[x] = cnt ; 
   fp( i , 0 , (int)(v[x].size()-1) ) { 
      if( fa == ( y = v[x][i] ) ) continue ; 
      dfs( y , x ) ; } R[x] = cnt ; return ;  } 
signed main( ) { 
   ios::sync_with_stdio(false) ; 
   cin.tie(0) ; cout.tie(0) ; 
   cin >> n >> k ;  rg int x , y ; 
   if( k * k >= n ) { cout << "DA" << endl ; return 0 ; } 
   fp( i , 2 , n ) cin >> x >> y , add( x , y ) ;  
   dfs( 1 , 0 ) ; f[0][0] = 1 ; 
   fp( i , 1 , n ) if( dep[i] > 1 ) Sta[L[i]].push_back(i) ;   
   fp( i , 0 , cnt-1 ) { 
     fp( j , 0 , ( 1 << k ) - 1 ) { 
	    if( ! f[i][j] ) continue ; 
		fp( p , 0 , (Sta[i].size()-1) ) { int r = Sta[i][p] ; 
		  if( j & ( 1 << dep[r]-2 ) ) continue ; 
		  f[R[r]][j|(1 << dep[r]-2 )] = 1 ; } } } 
	fp( i , 0 , ( 1 << k ) - 1 )  if( f[cnt][i] ) 
	{ cout << "DA" << endl ; return 0 ; } 
	cout << "NE" << endl ; return 0 ; } 
```

题目还未评分 ，难度给个蓝是至少的 ， 最好紫吧 


---

## 作者：CYZZ (赞：6)

## [P6499](https://www.luogu.com.cn/problem/P6499)

简单解释一下题意：

称 Daniel 为 Alice，Stjepan 为 Bob。

`既定的操作策略` 意思是 Alice 在游戏开始前就选定一个操作序列 $p_i$，在开始后不能改变。

`使得无论 Stjepan 如何操作` 意思是默认 Bob 采取的是最优策略，**即假定 Bob 已经知道 $p_i$**。

---

设 $1$ 号点深度为 $0$。称深度为 $i$ 的点为 `i-point`。

现在Alice 想要堵住一些点，使得 Bob 走不到任何一个 `k-point`。

如果 $k$ 过大，以至于 `k-point` 的个数 $\le k$，那么 Alice 一个一个标就行了。

具体的，当 $k\ge \sqrt{n}$ 时，直接输出 `DA`。

---

不难发现 Bob 在第 $i$ 步移动后会一定走到某个 `i-point`。

**重要结论**： Alice 最优策略下 $p_i$ 为 `i-point`。

证明：如果 $p_i$ 深度小于 $i$，对 Bob 没有任何影响。如果 $p_i$ 深度大于 $i$，一定没有选 $p_i$ 的第一个 `i-point` 祖先优。

---

由于我们假定 Bob 已经知道了 $p_i$，而 $p_i$ 又是确定的。

所以 Bob 实际上**不需要做任何决策**，只要 Alice 没有把所有的 `k-point` 堵住，Bob 就能赢。

所以 Alice 的目标是把所有的 `k-point` 堵住。

---

把所有 `k-point` 按 dfs 序排序为 $K[1\dots c]$。dfs 时预处理 $[L_u,R_u]$ 表示 $u$ 子树内 `k-point` 的下标区间。

那么标记一个点 $u$，相当于覆盖了一个区间 $[L_u,R_u]$，问存不存在一种选法能够覆盖 $[1,c]$。

---

问题转化为：有 $k$ 类区间，区间总数为 $n$，**每类区间恰好选一个**，能否覆盖 $[1,c]$。

由于我们刚才把 $k\ge \sqrt{n}$ 的情况判掉了，所以现在 $k<20$，可以状压。

设 $f_{i,j}=0/1$ 表示已经覆盖了 $[1,i]$，$k$ 类区间的使用情况为 $j$ 是否可能。

转移时枚举选了哪个区间，时间复杂度 $O(2^kn^2)$。

优化状态：设 $f_i$ 表示区间的使用情况为 $i$，最多覆盖到 $[1,f_i]$。

转移时枚举选了哪类区间，设选了 $[l,r]$，需要满足 $l\le f_i$，且 $r$ 尽可能大。

直接类内按左端点排序，转移时二分出最右的能选的区间，然后用前缀 $r$ 的最大值更新。

复杂度降为 $O(2^kk\log n)$。

---

## 作者：tzc_wk (赞：5)

[题面传送门](https://www.luogu.com.cn/problem/P6499)

一道挺有意思的思维题（？）

首先我们假设根节点深度为 $0$，那么 Daniel 的目标显然就是堵住一些节点使得 Stjepan 不能移动到深度为 $k$ 的节点，Stjepan 的目标就是将棋子移到深度为 $k$ 的节点。我们还可以发现一个显然的性质，就是 Daniel 在第 $i$ 步肯定会堵住深度为 $i$ 的节点（如果还存在深度为 $i$ 的节点没有堵住），因为如果堵住一个深度 $<i$ 的节点那显然是无效的，而如果堵住深度 $>i$ 的节点，我们完全可以将其移到它深度为 $i$ 的祖先上，这样肯定比堵住原来的节点来得更优。

于是现在问题就转化为，你需要选择一个集合 $S\subseteq T=\{1,2,3,\cdots,k\}$ 并堵住深度为 $x$ 的点各一个（$x\in S$），使得不存在深度为 $k$ 的点满足从根节点到该点的路径都被堵住了。

这样看上去还是很不好做，不过注意到当 $k$ 比较大的时候答案都是 `DA`，事实上，对于 $k\ge\sqrt{n}$ 答案必定是 `DA`，感性理解（因为我也不会严谨证明，想了半天没想通/wul）可知最劣情况大概是根节点下面接了 $k$ 条长度为 $k$ 的链，那么此时你只需在第 $i$ 条链上堵住长度为 $i$ 的边即可，这样我们就将 $k$ 的规模降到了 $19$。

注意到这道题的状态与集合有关，因此考虑状压 $dp$，由于每次堵住一个点会使得一个子树内的点到根节点的路径受阻，因此考虑 DFS 序，将所有深度为 $k$ 的点按照 DFS 序从小到大排成一列，那么堵住每个点后会使一段区间 $[L_x,R_x]$ 内的深度为 $k$ 的点不可到达，因此可以设 $dp_{i,S}$ 表示 $1\sim i$ 的点已经被堵住了，堵住的点的深度组成的集合为 $S$ 是否合法，转移就枚举 $x$ 满足 $L_x=i+1$ 且 $dep_x\notin S$，然后用 $dp_{i,S}$ 更新 $dp_{R_x,S\cup\{dep_x\}}$ 即可。

时间复杂度 $n2^k$。

```cpp
const int MAXN=400; 
int n,k,hd[MAXN+5],to[(MAXN<<1)+5],nxt[(MAXN<<1)+5],ec=0;
void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
int dep[MAXN+5],L[MAXN+5],R[MAXN+5],lcnt=0;bool on[MAXN+5];
void dfs(int x,int f){
	on[x]=1;
	if(dep[x]>=k) return L[x]=lcnt,R[x]=++lcnt,void();
	L[x]=lcnt;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f) continue;
		dep[y]=dep[x]+1;dfs(y,x);
	} R[x]=lcnt;
}
vector<pii> idl[MAXN+5];
bool dp[MAXN+5][1048577];
int main(){
	scanf("%d%d",&n,&k);if(k*k>=n) return printf("DA\n"),0;
	for(int i=1,u,v;i<n;adde(u,v),adde(v,u),i++) scanf("%d%d",&u,&v);
	dfs(1,0);dp[0][0]=1;
	for(int i=1;i<=n;i++) if(on[i]&&(i^1)) idl[L[i]].pb(mp(R[i],dep[i]));
	for(int i=0;i<lcnt;i++) for(int j=0;j<(1<<k);j++)
		for(pii p:idl[i]) if(~j>>(p.se-1)&1) dp[p.fi][j|(1<<p.se-1)]|=dp[i][j];
	bool ret=0;for(int i=0;i<(1<<k);i++) ret|=dp[lcnt][i];
	printf("%s\n",ret?"DA":"NE");
	return 0;
}
```



---

## 作者：DeepSeaSpray (赞：4)

# LGP6499 [COCI2016-2017#2] Burza

首先解释题意，对于既定策略，我们要求方案不随对方的移动而改变。

仔细思考，能取胜的最多点数的情况就是根节点下面有 $k$ 条长度为 $k$ 的链。因为对于长度小于 $k$ 的路径不需要考虑，而我们最多只能堵住 $k$ 条路径。

而这样恰好需要 $k$ 次才能全部堵住。

故得到推论 $n \leq k^2$ 时必胜。又 $n \leq 400$ 所以 $k \geq 20$ 时必胜。

这样我们只需要做 $k < 20$ 的部分。

同时我们只需要研究所有长度为 $k$ 的路径，其他的点我们可以全部舍弃。

通过上面的例子，我们容易发现第 $i$ 次标记的点深度为 $i$，即每一次按深度递增堵上一个子树。

我们考虑在 Dfn 序上做状压 DP。

$f(i,s)$ 表示堵住了 Dfn 序大于 $i$ 的所有点，标记状态为 $s$ 的可行性。

对于深度不为 $k$ 的点，$f(i,s) = f(i+1,s)$，因为堵住了 Dfn 序大于 $i+1$ 的点，那么就堵住了 $i$ 的所有子树，那么这个点也没用了。

接着还有转移，堵上 $i$ 这个点，这会堵上 $i$ 的子树，从 $i + sz(i)$ 转移。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=400;
const int maxm=1<<19;
struct Edge{int u,v,nxt;};
int n,K;
int hd[maxn+5],et;
Edge e[(maxn<<1)+5];
int de[maxn+5];
int sz[maxn+5];
bool flg[maxn+5];
int dfn[maxn+5],dfnt;
int to[maxn+5],rde[maxn+5];
bool f[maxn+5][maxm+5];
inline void Adde(int u,int v){
	e[et].u=u,e[et].v=v,e[et].nxt=hd[u],hd[u]=et++;
}
void Dfs1(int u,int fa){
	int v;
	sz[u]=1;
	if(de[u]==K) flg[u]=1;
	for(int i=hd[u];~i;i=e[i].nxt){
		v=e[i].v;
		if(v==fa) continue;
		de[v]=de[u]+1;
		Dfs1(v,u);
		sz[u]+=sz[v];
		flg[u]|=flg[v];
	}
}

void Dfs2(int u,int fa){
	int v;
	if(!flg[u]) return;
	dfn[u]=dfnt++;
	for(int i=hd[u];~i;i=e[i].nxt){
		v=e[i].v;
		if(v==fa) continue;
		Dfs2(v,u);
	}
	to[dfn[u]]=dfnt;
	rde[dfn[u]]=de[u]-1;
}
signed main(){
	int u,v;
	memset(hd,-1,sizeof(hd));
	scanf("%d%d",&n,&K);
	if(K>=20){puts("DA");return 0;}
	for(int i=1;i<n;i++){
		scanf("%d%d",&u,&v);
		Adde(u,v),Adde(v,u);
	}
	Dfs1(1,0);
	Dfs2(1,0);
	int tp=(1<<K)-1;
	memset(f[dfnt],1,sizeof(f[dfnt]));
	for(int i=dfnt-1;i>=1;i--){
		if(rde[i]<K-1)
			for(int j=0;j<=tp;j++)
				f[i][j]=f[i+1][j];
		for(int j=0;j<=tp;j++)
			if(j&(1<<rde[i]))
				f[i][j]|=f[to[i]][j^(1<<rde[i])];
	}
	puts(f[1][tp]?"DA":"NE");
	return 0; 
}
```

---

## 作者：EternalHeart1314 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P6499)

听说赛前发题解能 rp++！

致敬传奇乱搞王！

# Problem

每次 Daniel 堵住一个点，然后 Stjepan 走一步（走到相邻的点），不能往回走，问存不存在一种**堵**的**既定**策略，可以使 Stjepan 无论怎么走都走不了 $k$ 步。

# Solution

注意这里是**既定**策略，就是 Daniel 不知道 Stjepan 会怎么走，不能走一步看一步，而是开始前就要计划好怎么堵。Stjepan 无论怎么走，都只能用这一种方法堵。

我们称一种既定策略可以使 Daniel 赢，则这是一个胜利策略。

那么题目就转化为有没有必胜策略。

首先可以发现，如果 Stjepan 从某条路径一直走下去都到走不了 $k$ 次，那他显然不会走，可以删掉这条路径。

如果已经走了 $k$ 步，则 Stjepan 已经赢了，Daniel 输了，则这不是胜利策略。所以深度大于 $k$ 的也可以删掉。

举个例子，树长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/t50f5zfu.png)

长的很抽象~~像个人~~。

整理一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/4o9qbyjz.png)

~~更像人了。~~

然后如果 $k=2$。

按上面的删法，删掉节点 $4$，$7$，$10$，$11$。

![](https://cdn.luogu.com.cn/upload/image_hosting/75985m1u.png)

这种方法可以删掉很多点。

然后你会发现必胜策略很多！

必胜策略很多，那么随机到必胜策略的概率就很大！

然后就用随机化过掉了！

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k;
vector<int> e[514], g[514];
mt19937 rnd(time(0));

inline static int build(int u, int fa, int d) {
	if (d == k) return 1;
	for (auto v : e[u]) if (v ^ fa) {
		if (build(v, u, d + 1)) g[u].push_back(v);
	}
	return g[u].size();
}

inline void lyht() {
	vector<int> v, c;
	for (int u : g[1]) v.push_back(u);
	if (v.empty()) {
		puts("DA");
		exit(0);
	}
	for (int i = 1; i <= k; ++i) {
		v.erase(v.begin() + rnd() % v.size());
		if (v.empty()) {
			puts("DA");
			exit(0);
		}
		c = {};
		for (int u : v) for (int v : g[u]) c.push_back(v);
		v = c;
	}
}

int main()  {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> k;
	for (int i = 1, u, v; i < n; ++i) {
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	build(1, -1, 0);
	while (1. * clock() / CLOCKS_PER_SEC < 0.99) lyht();
	return puts("NE"), 0;
}
```

最后用了卡时，但改成 `for (int i = 1; i <= 400; ++i) lyht();` 也可以过。

主要是必胜策略特别多，随到的概率也特别大。

最优解第一页。

---

## 作者：Kingna (赞：1)

可以观察到 $k>\sqrt n$ 直接有解。设根节点深度为 $0$，也就是深度大于 $k$ 的部分全部斩了。再观察到第 $i$ 次标记一定在深度 $i$，一定互不相同。再观察将标记放在节点 $x$，那么节点 $x$ 内的所有深度为 $k$ 的节点不再可达。我们的目标就是在深度 $1
\sim k$ 各选定一个节点，放标记，使得所有深度为 $k$ 的节点不再可达。

用状压 dp 完成。复杂度是 $O(n2^k)$ 的！

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)

const int N = 405;

int n, k, L[N], R[N], son[N], dep[N], idx, vis[N], f[N][1000000], fat[N];
vector<PII> has[N];
vector<int> G[N]; 

void dfs(int u, int fa, int depth) {
  vis[u] = 1; fat[u] = fa; dep[u] = depth;
  if (dep[u] >= k) {
    L[u] = idx + 1; idx++; R[u] = idx; 
    return; 
  }
  L[u] = idx + 1;
  for (auto v : G[u]) {
    if (v == fa) continue;
    son[u]++;
    dfs(v, u, depth + 1);
  }
  R[u] = idx;
}

signed main() {
  cin >> n >> k;
  if (k >= 20) puts("DA"), exit(0);
  _for(i, 1, n - 1) {
    int u, v;
    cin >> u >> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  dfs(1, 0, 0);
  _for(i, 1, n) if (vis[i] && i != 1) has[L[i]].push_back({R[i], dep[i]});
  f[0][0] = 1;
  _for(i, 1, idx) {
    _for(j, 0, (1 << k) - 1) {
      for (auto v : has[i]) {
        if ((j & (1 << (v.second - 1))) == 0) f[v.first][j | (1 << (v.second - 1))] |= f[i - 1][j];
      }
    } 
  }
  int res = 0;
  _for(i, 0, (1 << k) - 1) res |= f[idx][i];
  if (res) puts("DA");
  else puts("NE");
}
```

---

## 作者：Carey_chen (赞：1)

### Solution

这是一道不容易独立思考出来的状态压缩动态规划题。

考虑转化题意为：

> 有一棵树，求能不能在 $1 \sim k$（根节点为第 $0$ 层）上的每一层标记一个点和它的**整颗子树**，使得第 $k$ 层中的每个节点都被标记过。

显然这种可行的情况 $(k^2 +1 = n)$ 需要标记的节点最多：

![](https://cdn.luogu.com.cn/upload/image_hosting/n2kvaolr.png)

因此，当 $k > \sqrt{n}$ 时一定可行。只需要考虑 $k \leq \sqrt{n}$ 的情况。

定义 $dp_{i, S}$ 为是否存在覆盖了第 $k$ 层中的前 $i$ 个节点，并且集合 $S$ 中的每一层都标记过的情况。

最后判断覆盖第 $k$ 层中的每个结点的情况是否存在即可。

### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

const int M = (1 << 20) + 5;
vector<int> G[410];
int cnt = 0, n, k;
int l[410], r[410];
bool dp[410][M];

int p[410];

vector<int> T;
void dfs(int u = 1, int pre = -1, int dep = 0)
{
	p[u] = dep;
	if(dep == k)
	{
		cnt++;
		l[u] = r[u] = cnt;
		T.push_back(u);
		return;
	}
	
	l[u] = 1e9;
	r[u] = -1e9;
	
	for(auto v : G[u])
	{
		if(v != pre)
		{
			dfs(v, u, dep + 1);
			l[u] = min(l[u], l[v]);
			r[u] = max(r[u], r[v]);
		}
	}
	
	if(u != 1 && l[u] != 1e9 && r[u] != -1e9)
	{
		T.push_back(u);
	}
}

int main()
{
	scanf("%d %d", &n, &k);
	
	if(k > sqrt(n))
	{
		printf("DA\n");
		return 0;
	}
    
    for(int i = 1; i < n; i++)
    {
    	int u, v;
    	scanf("%d %d", &u, &v);
    	G[u].push_back(v);
    	G[v].push_back(u);
	}
	
	dfs(1);
//	printf("%d \n", cnt);
//    for(auto i : T)
//    {
//		printf("%d %d %d\n", i, l[i], r[i]);
//    }
    
	int N = (1 << k) - 1;
	dp[0][0] = true;
	for(int i = 0; i <= cnt; i++)
	{
		for(int S = 0; S <= N; S++)
		{
			if(dp[i][S] == true)
			{
				//printf("  %d %d\n", i, S);
				for(auto j : T)
				{
					if(!((S >> (p[j]-1)) & 1) && i + 1 == l[j])
					{
						//printf("    %d %d\n", l[j], r[j]);
						dp[r[j]][S | (1 << (p[j]-1))] |= dp[i][S];
					}
				}
			}
		}
	}
	//printf("%d %d", cnt,N);
	bool ans = false;
	for(int i = 0; i <= N; i++)
	{
		ans |= dp[cnt][i];
	}
	printf(ans ? "DA\n" : "NE\n");
	
    return 0;
}
```

---

## 作者：dengjunhaodejia09 (赞：1)

模拟赛考到了这道题，当时只有 50 分，昨天晚上证明了很久，终于在学长的帮助下明白了。

这道题，对于 $k^2+1>n$ 的情况是必胜的，我们考虑证明一下。

考虑剥掉根，此时点数变为 $N=n-1$，即证 $k^2>N$ 时必胜，此时变成了一个森林，每个原来根的儿子都是一个新的根。

定义新根的深度为 1，那么我们剥掉所有所有深度大于k的节点，一定没有影响。

定义分叉，指的是至少有两个儿子。那么我们找到深度最小的分叉，定义其的深度为 $d$，那么我们依次进行 $d$ 次操作，若进行不了便结束了，那么便是胜利，得证。若进行的了 $d$ 次删的操作，那么一定是在所有删的点一定是新根往下的链（定义为新根往下一直走仅有的唯一儿子能组成的链），此时我们删过的子树不可能还有贡献，即使单词操作之上去掉了 $2k-d$ 个节点，共 $d$ 次，共去掉了 $d\times(2k-d)$ 个节点。此时，去掉所有可能有贡献的子树去掉深度 $<=d$ 的节点。此时 $k$ 变为 $k-d$， $n$ 变为 $n-d\times(2k-d)$ ，依旧满足 $(k-d)^2>n-d\times(2k-d) $。我们重复第一次的操作，直到没有分叉。此时至少 $k^2$ 个节点才能必败，又 $k^2>n$，没有那么多的节点，即得证。

状压的部分令 $dp_{S,j}$ 为当前深度状态为 $S$，覆盖了第 0 到 $j-1$ 个叶子，考虑深度为 $i$ 的点最多能从第 $j$ 个叶子，转移到哪，再枚举转移深度与状态转移即可。

---

## 作者：喵仔牛奶 (赞：1)

## $\mathcal{P}reface$

样例调了 10min，调完居然一发 A 了，非常震撼……

## $\mathcal{S}olution$

首先，对于 Daniel 来说最坏情况是根节点下面 $k$ 条长为 $k$ 的链，那样他需要 $k$ 次才能全部堵住。但是这样 $n=k^2+1$，所以如果 $n\leq k^2$，Daniel 必胜。这样，$k\leq\lfloor\sqrt n-1\rfloor$，也就是 $k\leq19$。

然后，我们可以证明每个深度的点只会有一个被标记：  
- 因为 Stjepan 会依次走过深度 $1\sim k$ 的节点，而当 Stjepan 走到深度为 $i$ 的节点时，标记深度 $\leq i$ 的节点无效，而标记深度 $\geq i+1$ 的节点不如标记深度为 $i+1$ 的节点，因为标记深度为 $i+1$ 的节点可以包含深度 $\geq i+1$ 的节点，肯定更优。    
- 如果有必胜策略，Daniel 只要第 $i$ 次标记深度为 $i+1$ 的节点即可。

因为如果 Stjepan 可以胜利，他最后会走到深度为 $k$ 的节点上，所以 Daniel 只需阻止 Stjepan 到达深度为 $k$ 的节点即可。

观察发现，所有深度 $>k$ 的节点是无用的，而标记 $i$ 相当于标记所有 $i$ 子树里深度为 $k$ 的节点，所以我们把树用 dfs 序重新编号，并且只记录深度为 $k$ 的节点，设 $L_{i},R_{i}$ 为 dfs 序中 $i$ 的子树里新编号最小和最大的深度为 $k$ 的节点，$d_i$ 是 $i$ 的深度。转化问题：
- 问题变成了给定 $L_i,R_i,d_i$，第 $i$ 个节点可以覆盖 $[L_i,R_i]$，求是否可以选出一些节点，使得它们覆盖整个区间，且没有深度重复的节点。

这样可以状压 dp，设 $f_{i,S}$ 是是否可以用 $S$ 中节点覆盖新编号前 $i$ 个节点（是为 $1$，否为 $0$），显然有转移方程：

$$f_{i,S}=\max_{j\in S\land R_{j}=i}\{f_{L_{j}-1,S-j}\}$$

这样转移是 $\mathcal{O}(n^22^k)$ 的，显然会 TLE，需要使用刷表法并且剪枝（对于为 $0$ 的状态不刷表）。

## $\mathcal{C}ode$

状压 dp，[2.50s](https://www.luogu.com.cn/record/98198215)。

注意，我写的 $L_{i}$ 实际上是上文中的 $L_{i}-1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 405, K = 20;
int n, k, u, v, cnt, ans, L[N], R[N], fa, depth[N], f[N][1 << K];
vector<int> G[N], qwq[N];
void dfs(int u, int fa, int dep) {
	L[u] = cnt, depth[u] = dep;
	if (dep == k - 1) { L[u] = cnt ++, R[u] = cnt; return; }
	for (int v : G[u])
		if (v != fa) dfs(v, u, dep + 1);
	R[u] = cnt;
}
int main() {
	cin >> n >> k;
	if (n <= k * k) puts("DA"), exit(0);
	for (int i = 1; i < n; i ++)
		cin >> u >> v, G[u].push_back(v), G[v].push_back(u);
	dfs(1, 0, -1), f[0][0] = 1;
	for (int i = 2; i <= n; i ++) qwq[L[i]].push_back(i);
	for (int i = 0; i <= cnt; i ++)
		for (int j = 0; j < 1 << k; j ++) {
			if (!f[i][j]) continue;
			for (int v : qwq[i])
				if (!(j & 1 << depth[v])) f[R[v]][j | 1 << depth[v]] |= f[i][j];
		}
	for (int i = 0; i < 1 << k; i ++)
		if (f[cnt][i]) ans = 1;
	puts(ans ? "DA" : "NE");
	return 0;
}

```

---

## 作者：Thomas0218 (赞：0)

# 分析
定义根结点为 $1$，深度为 $0$。

很明显深度大于 $k$ 的结点于我们无用。本题就是询问我们能不能通过某种策略堵住所有深度为 $k$ 的结点（后面我们称其为叶子结点）。我们考虑什么情况对于小 D 最劣，很明显是$\frac{n-1}{k}$ 条深度 $k$ 为的链。而若此时 $\frac{n-1}{k}\leq k$ 即 $k^2+1\geq n$，那么小 D 必胜（因为他一定可以在规定时间内把所有链全都堵死）。类似的，对于所有情况若 $k\geq \sqrt n$，都是小 D 必胜。

剩下的情况 $k$ 都不大于 $20$，考虑状压 dp。我们首先可以发现一个关键性质：每层结点最多有一个会被小 D 标记。证明：由于小 S 所在结点的深度单调递增，小 D 只会在小 S 到达当前深度 $i$ 之前标记该深度。而如果小 D 在小 S 到达深度 $i-1$ 之前标记深度 $i$，把此时小 D 标记的结点上移一层肯定不劣。简而言之，小 D 标记的深度只会是这样：$1,2,\cdots k$。

有了这个性质，我们就将问题转化为了每层选一个点并覆盖其子树内所有叶子结点，问能不能覆盖所有叶子结点。我们先对叶子结点按 dfs 序重新编号为 $[1,tot]$。设 $f_S$ 表示已经选了深度集合为 $S$，能覆盖 $[1,f_S]$ 的叶子结点。我们预处理 $tr_{i,j}$ 表示深度为 $i$ 的结点的子树内叶子结点 $j$ 的最大与其在同一深度为 $i$ 的结点的子树内的叶子结点编号。什么意思呢，就是如果某一个结点 $u$ 能覆盖 $[l_u,r_u]$ 的叶子结点，那么 $tr_{dep_u,[l_u,r_u]}$ 都是 $r_u$。

那么 $f_{S\cup\{x\}}=\max(f_S,tr_{x,f_S+1})$。最后判断是否 $\exist S,f_S=tot$。时间复杂度 $O(k2^k)$。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 405, M = 21;
int n, k, dep[N], tr[M][N]; vector <int> e[N];
int f[(1<<M)], l[N], r[N], cnt;
void dfs(int u, int fa) {
	if(dep[u] == k) { cnt++, l[u] = cnt, r[u] = cnt, tr[k][cnt] = cnt; return ; }
	l[u] = cnt + 1;
	for(auto v : e[u]) if(v != fa) { dep[v] = dep[u] + 1; dfs(v, u); }
	r[u] = cnt;
	for(int i = l[u]; i <= r[u]; i++) tr[dep[u]][i] = r[u];
}
int main() {
	scanf("%d%d", &n, &k);
	if(k > 19) { printf("DA\n"); return 0; }
	for(int i = 1; i < n; i++) { int u, v; scanf("%d%d", &u, &v); e[u].push_back(v); e[v].push_back(u); }
	dfs(1, 0);
	for(int mask = 0; mask < (1 << k); mask++) {
		if(f[mask] == cnt) { printf("DA\n"); return 0; }
		for(int i = 1; i <= k; i++)
			if(!(mask & (1 << (i - 1)))) f[mask|(1<<(i-1))] = max(f[mask|(1<<(i-1))], tr[i][f[mask]+1]);
	}
	printf("NE\n");
	return 0;
}
```

---

## 作者：Iris_Aurora (赞：0)

首先我们可以发现当 $k^2\ge n$ 时 Daniel 必胜，构造一种最坏的情况是根节点下面挂 $k$ 条长度为 $k$ 的链，此时你只需在第 $i$ 条链上标记第 $i$ 个节点即可，此时 $k$ 的范围变成了 $k \le 19$。

看到这个范围我们考虑状压，

我们称一个点被覆盖了当且仅当它有至少一个祖先被标记了，

问题转化为选 $\le k$ 个点可不可以覆盖所有深度为  $k$ 的叶子节点。

首先可以证明同一个深度的点选多于一个肯定不优，当棋子在第 $i$ 层时 ， 我们标记第 $i+1$ 层的节点一定最优，因为可以覆盖更多深度为 $k$ 的叶子节点。

我们定义 $f_{i,j}$ 表示覆盖了前 $i$ 个深度为 $k$ 的叶子节点，选择深度的状态为 $j$ 是否可行。

用 dfs 求出一个点覆盖的叶子节点区间 $[L_i,R_i)$（注意是左闭右开），可以列出转移，复杂度  $\mathcal{O(n2^k)}$。

tips：用 bitset 可以优化到 $\mathcal{O(n2^{k-5})}$ 的复杂度。


```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
//每一层选择一个节点，覆盖所有的叶子（第k层的节点）
//dp[i][j]表示覆盖了i个叶子，选了点的层状态是j
const int MAXN = 8e2 + 10; 
const int MR = (1<<20) + 10;
int n,m,k;
int dep[MAXN],L[MAXN],R[MAXN],tot=0;
vector<int>G[MAXN],E[MAXN];
bool f[MAXN][MR];
void dfs(int u,int fth){
	dep[u]=dep[fth]+1;
	if(dep[u]==k-1){
		L[u]=tot++,R[u]=++tot;
		return ;
	}
	L[u]=tot;
	for(int v:G[u]){
		if(v==fth) continue;
		dfs(v,u);
	}
	R[u]=tot;
}

int main(){
	scanf("%d%d",&n,&k);
	if(k*k>=n) puts("DA"),exit(0);
	m=(1<<k)-1;
	FL(i,1,n-1){
		int u,v;
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dep[0]=-2;
	dfs(1,0);
	f[0][0]=1;
	FL(i,2,n) E[L[i]].push_back(i);
	FL(i,0,tot){
		FL(j,0,m){
			if(!f[i][j]) continue;
			for(int l:E[i]) if(!(j&1<<dep[l])) f[R[l]][j|1<<dep[l]]|=f[i][j];
		}
	}
	bool t=0;
	FL(i,0,m) t|=f[tot][i];
	puts(t?"DA":"NE");
	return 0;
}
```

---

## 作者：gghack_Nythix (赞：0)

## 前言：

不知道说什么了，赛时我的假做法 60pts，别人暴力加个卡时就过了？

赛后看了题解貌似懂了，所以写一下来总结。

## 分析：

首先可以先扣掉 $k$ 步之内一定无法到达的子树。

然后考虑一个状压的做法：设 $dp_{S}$ 表示选择的点是 $S$ 这个集合里面的，最终能覆盖的叶子是 $[1,dp_S]$ 这个范围的。

至于这个覆盖的范围你可以理解成：把叶子从左往右标号，其实也就是按照搜索顺序给叶子节点标号。

接下来想一下，发现你肯定是没法标记同一层的点的，毕竟玩家不能往上走，我再堵一遍他走过的层有何用？

那么我的 $S$ 代表的含义就可以变成：每个深度是否选择堵死。

转移的话，先找到一个新的深度 $dep$，满足 $dep\notin S$。转移是把这个 $dep$ 算上取并集。
现在假设某一个点 $u$ 所控制的叶子节点的范围右端点是 $dp_S+1$，则转移方程就是：

$$
dp_{S\cup dep}=\max\{dp_{S\cup dep},F_u\}
$$

其中 $F_u$ 表示 $u$ 能控制的最远右端点距离。

我的代码实现略有麻烦：

```cpp
# include<bits/stdc++.h>
# define pb push_back
using namespace std;
vector <int> g[505] ;
int n , k;
int dp[1 << 20] , dep[505] , L[505] , R[505] , fgR[505][505];//fgR表示最远的能表示的那个点 
int leaf ;
void dfs (int now , int fa) {
	dep[now] = dep[fa] + 1;
	L[now] = leaf + 1;
	for (auto x : g[now]) if (x != fa) dfs (x , now) ; 
	if (g[now].size() == 1 && fa != 0 && (dep[now] == k + 1 || dep[now] == k + 2)) ++ leaf;
	R[now] = leaf;
	if (dep[now] <= k + 1 && dep[now] != 1) for (int i = L[now] ; i <= R[now] ; ++i) fgR[dep[now]][i] = R[now];
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	if (k > 19) return cout << "DA\n",0;//下文证明这里为什么是对的。
	for (int i = 1;i < n;++i){
		int u , v ;
		cin >> u >> v , g[u].pb(v) , g[v].pb(u);
	}
	dfs (1 , 0);
	int lim = (1 << (k + 1)) - 1;
	for (int S = 0 ; S <= lim;++S) for (int dep = 1;dep <= k + 1;++dep) 
	if (!(S & (1ll << dep))) dp[S | (1ll << dep)] = max(dp[S | (1ll << dep)] , fgR[dep + 1][dp[S] + 1ll]) ;
	for (int S = 0 ; S <= lim; ++S) if (dp[S] == leaf) return cout << "DA\n",0;
	cout << "NE\n";
	return 0;
}
/*
*/
```

然后 $k$ 一大你就做不了，猜测一定有一个策略使得能在 $k$ 轮内结束游戏，然后发现这是对的，考虑怎么证明。

首先最差的情况肯定是我只能堵死一条链，那么可以构造出来一棵树，形如菊花图和链的结合体：

![](https://cdn.luogu.com.cn/upload/image_hosting/lsczlvhb.png)

那么这种情况无论怎么跑，他都能在最后给你堵死，见下面的方法：

![](https://cdn.luogu.com.cn/upload/image_hosting/gc7193us.png)


这种情况有 $k(k+1)$ 个非根的点，注意根我们不考虑。

则当 $k(k+1)\geq n$ 的时候一定可以堵死，因为没有比这种更差的情况了。

所以这题就圆满解决了。

---


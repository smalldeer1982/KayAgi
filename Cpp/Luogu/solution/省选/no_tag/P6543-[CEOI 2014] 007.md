# [CEOI 2014] 007

## 题目背景

CEOI2014 Day2 T1，译者：小粉兔

## 题目描述

007 特工发现了她最大的敌人 De Referenced Nullpointer 博士（简称 Dr. Null）的一个阴谋：Dr. Null 将要摧毁洛谷的两台服务器中的某一台！Dr. Null 正准备去实施他的方案，并且他也正在去服务器的路上。很遗憾，这意味着 007 必须告别她正在泡着帅哥吃早餐的生活。

007 和 Dr. Null 都入侵了一个卫星系统，所以他们总是知道对方的位置。卫星系统把地图表示为一个**连通**的无向图，007 和 Dr. Null 以及两台服务器都位于节点上。**特别地，保证两台服务器位于相邻的两个节点上**。007 和 Dr. Null 都可以在一个单位时间内移动一条边，不过也可以不移动。Dr. Null 摧毁服务器也需要一个单位时间。Dr. Null 和 007 轮流行动，Dr. Null 先手。

如果 007 抓住了 Dr. Null（他们位于同一个节点上）或者可以保证 Dr. Null 在无限长的时间内无法摧毁服务器，就算 007 获胜。

007 想要知道她现在能吃着早餐泡帅哥最迟到什么时候，以确保无论 Dr. Null 采取什么策略依然可以取得胜利。

请你帮助 007 编写一个程序，计算她为了确保胜利，最迟停下吃早餐的时间。注意：当 007 还在吃早餐的时候她是没有办法抓住 Dr. Null 的，即使他们位于同一个节点上也不行。

## 说明/提示

对于所有数据，保证 $4 \le n \le 2 \times {10}^5$，$3 \le m \le 6 \times {10}^5$，$1 \le s, d, a, b \le n$ 且互不相同，保证图连通。

| 子任务编号 | 分值 | 特殊限制 |
| :-: | :-: | :-: |
| $1$ | $30$ | $n \le 800$，$m \le 1600$ |
| $2$ | $70$ | 无特殊限制 |

**部分分设置**：对于每个子任务，如果你的程序的输出在其中至少一组测试点中比非负的正确答案少 $1$ 并且在其它测试点中完全正确，则你将获得该子任务的 $30 \%$ 的分数。注意如果正确答案是 $0$ 时你的程序输出 $-1$ 也算作这种情况。

## 样例 #1

### 输入

```
6 6
1 2 3 4
1 5
5 6
6 3
6 4
1 2
3 4```

### 输出

```
1```

## 样例 #2

### 输入

```
6 7
5 6 1 2
6 3
1 2
1 3
2 3
1 5
2 4
5 4```

### 输出

```
0```

# 题解

## 作者：Mr_罗 (赞：2)

[洛谷 P6543 [CEOI2014] 007](https://www.luogu.com.cn/problem/P6543) & [LOJ #3289. 「CEOI2014」007](https://loj.ac/p/3289)。

upd on 2024/10/15 13:12:40：修改一处笔误。
upd on 2024/10/15 14:39:45：修改亿处笔误。

## 题意

在无向无权图上有警、匪和相邻的两处机密，每回合匪先走，警后走，可以不走，匪目标为走到某处机密并花一回合获得，警目标是在匪获得机密前某一回合走到匪当时所在的点，求警最多可以摆烂几回合（摆烂时无法抓匪）。

数据范围：点数 $n\le 2\times 10^5$，边数 $m\le 6\times 10^5$。

## 题解

先后走无关紧要，看作同时走，即警最晚需要在匪到机密时走到匪的位置。

首先容易发现警可以在机密处「守株待~~小粉~~兔」，因此警一定走最短路，所以匪也一定走最短路。那么容易判掉 $-1$ 的情况：对于某一个机密，警一定比匪晚到。

设 $ds_i$ 表示以警为起点的最短路，$dt_i$ 表示以匪为起点的最短路，则警摆烂的上限显然是 $\min\{dt_a-ds_a,dt_b-ds_b\}$。

那么这是不是最终答案呢？稍加思考便可以举出反例：有可能匪「虚晃」了一下警，把警骗到歧路中后抄近道，这时答案需要减一。例如下面这张图：

![](https://pic.imgdb.cn/item/670d0e08d29ded1a8c281047.png)

*P.S. 略微不对称，强迫症体谅一下 :)*

*P.P.S 如果 $\it{d=8}$ 那么也无解，相当于 $\it{0-1=-1}$。*

在这个例子里，$s=1,d=9,a=4,b=5$。本来上限是 $\min\{3-2,3-2\}=1$，但我们可以模拟一下这样的策略会产生的问题：

- 第一回合：匪走到 $8$；警摆烂。
- 第二回合：匪走到 $6$；警走到 $2$。
- 第三回合：匪走到 $5$；警走到 $4$。
- 第四回合：匪获胜。

这样警就必须提前一回合出发，答案需要减一。

那么何时答案需要减一呢？仔细思考，可以发现问题一定出在 **从 $\boldsymbol{s,d}$ 到 $\boldsymbol{a,b}$ 的最短路的分叉点** 上：倘若 **警在匪还可以走两条最短路重合部分时，自己便必须抉择需要先照顾 $\boldsymbol{a}$ 还是 $\boldsymbol{b}$**，那么匪就可以把警「晃飞」，这样答案就必须减一。即设 $s'$ 为 $s$ 到 $a,b$ 的最短路最长能重合的位置，$d'$ 为 $d$ 的最长位置，那么当且仅当 $ds_{s'}+\min\{dt_a-ds_a,dt_b-ds_b\}<dt_{d'}$ 时答案需要减一。

当然这样做有前提条件，就是 $dt_a-ds_a=dt_b-ds_b$，否则警就直接走等待时间更短的那条路就好了，不用管匪。

剩下的代码就很好写了，判掉无解，找到上限，找到最长重合位置（$ds/dt$ 最大的位置且在 $s/t\to a,b$ 最短路上），判断即可。

```cpp
constexpr int N = 200005;
constexpr ll mod = 998244353;
int n, m, s, t, x, y, k;
vector<int> G[N];
int ds[4][N];
int qu[N], lh, rt;

#define d ds[t]
void bfs(int s, int t) {
    qu[lh = rt = 1] = s, d[s] = 0; while (lh <= rt) {
        int u = qu[lh++];
        for (auto v : G[u]) if (d[v] < 0) d[v] = d[u] + 1, qu[++rt] = v;
    }
}

void solve() {
    scanf("%d%d%d%d%d%d", &n, &m, &s, &t, &x, &y); rep(i, 1, m) {
        int u, v; scanf("%d%d", &u, &v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    } mem(ds, -1), bfs(s, 0), bfs(t, 1);
    if (int d1 = ds[1][x] - ds[0][x], d2 = ds[1][y] - ds[0][y]; (k = min(d1, d2)) < 0) { puts("-1"); return; }
    else if (d1 != d2) printf("%d\n", k);
    else {
        int p = 0, q = 0; bfs(x, 2), bfs(y, 3);
        rep(i, 1, n) if (ds[2][i] == ds[3][i]) {
            if (ds[0][i] + ds[2][i] == ds[0][x]) chkmx(p, ds[0][i]);
            if (ds[1][i] + ds[3][i] == ds[1][y]) chkmx(q, ds[1][i]);
        }
        printf("%d\n", k - (p + k < q));
    }
}
```

---

## 作者：Unnamed114514 (赞：0)

注意到有两种情况：

- 007 到达了和 Dr.Null 相同的服务器，007 抓住了 Dr.Null。

- 007 在 Dr.Null 到两个服务器中间的路径上的割点堵住了 Dr.Null。

第二种情况很好处理，直接在圆方树上暴力跳祖先即可。

对于第一种情况，我们考虑分类讨论，求出 $s,d$ 到其它节点的最短路，分别记作 $dis_1,dis_2$

题目中有一个非常关键的性质：$a,b$ 之间一定有边。

这个性质告诉我们：当 $dis_{1,a}<dis_{1,b}$ 时，$a$ 可以在 $s\to b$ 的最短路上，$d\to a/b$ 以及 $dis_{1,a}>dis_{1,b}$ 的情况同理。

不妨令 $dis_{2,a}<dis_{2,b}$ 否则交换 $a,b$ 即可。

- $dis_{2,a}\ne dis_{2,b}$

此时走到 $a$ 一定更优，因为如果要到 $b$，经过 $a$ 到 $b$ 一定不会使最短路变长。

那么 007 至少要跟 Dr.Null 同时到达 $a$，所以当 $dis_{1,a}\le dis_{2,a}$ 的时候有解，答案是 $dis_{2,a}-dis_{1,a}$。

- $dis_{2,a}=dis_{2,b}$

此时的情况就复杂了：

首先一定是一直沿着到 $a/b$ 的最短路都不会减小的点走。

判断一个点是否在最短路上，所以我们需要算出 $a,b$ 到它们的最短路 $dis_3,dis_4$。

考虑这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rijt3tku.png)

Dr.Null 在 $1$，007 在 $7$，服务器在 $3,4$。

Dr.Null 第一步只能走到 $2$，此时若 007 走到 $5$ 的话，Dr.Null 就走 $4$，否则走 $3$，答案是 $-1$。

但是如果按照刚才的策略的话，两个 dis 直接相减，答案就变成 $0$ 了。

这个情况告诉我们：

我们需要知道离 $a,b$ 最近的同时在 $s/d\to a,b$ 的最短路上的点，因为我们只关心距离，我们得到这些点到 $s/d$ 距离的最小值记作 $x,y$。

如果 $x\ge y$ 的话，007 会后选择走到哪个服务器，此时当 $dis_{2,c}\ge dis_{1,c}$ 时有解，答案为 $dis_{2,c}-dis_{1,c}$。

否则 007 就会先选择方向，那么 Dr.Null 就会走和她相反的方向，那么 007 就要多走一步，所以只有当 $dis_{2,c}\ge dis_{1,c}+1$ 时才有解，答案为 $dis_{2,c}-(dis_{1,c}+1)$。

### 题外话

在 $dis_{2,a}\ne dis_{2,b}$ 时，贪心策略固定，跟割点无关。

在 $dis_{2,a}=dis_{2,b}$ 时，这个割点显然同时在 $d\to a/b$ 的最短路上，所以不用判割点。

综上所述，上述第二个条件是无用的。

求解答案的过程中其实不用判大小关系，和 $-1$ 取 $\max$ 即可。

---

## 作者：Arson1st (赞：0)

## [[CEOI2014] 007](https://www.luogu.com.cn/problem/P6543) 题解

### 最短路+分讨

题面说的基本清楚了，给出警家 $s$、匪家 $d$、AB 包点位置 $a,b$，一旦有包点被爆破了就算失败。

首先分别从 $s,d$ 开始跑一遍最短路，因为边权为 $1$，可以直接考虑 BFS。记从 $s$ 起始到 $a,b$ 的最短距离为 $dis1[a],dis1[b]$，从 $d$ 起始到 $a,b$ 的最短距离为 $dis2[a],dis2[b]$。计算 $\Delta_a=dis2[a]-dis1[a],\Delta_b=dis2[b]-dis1[b]$，$\Delta$ 的意义就是 007（警） 比 Dr.Null（匪） 先到包点的时间。根据题意两人起码要能同时到达 **同一** 包点，否则无论警怎么走， 匪都至少有一个单位时间下包。所以如果 $\Delta=\min(\Delta_a,\Delta_b)<0$，输出 $-1$ 即可。

现在考虑 **可能** 合法的情况：

注意到两个包点紧邻，所以一定有 $|dis1[a]-dis1[b]|\le 1,|dis2[a]-dis2[b]|\le 1$。如果我们记 $x=\min(dis1[a],dis1[b]),y=\min(dis2[a],dis2[b])$，不区分 $a,b$，那么无非出现这几种组合：（包点加粗，警家和匪家分别位于 $1,5$，守点用其到 $s,d$ 的距离组成的二元组描述）

|     与警家距离     |     与匪家距离     |                             图示                             |   守点    |
| :-------: | :-------: | :----------------------------------------------------------: | :-------: |
|  $(x,x)$  |  $(y,y)$  | ![](https://cdn.luogu.com.cn/upload/image_hosting/y7ekidq3.png) |           |
|  $(x,x)$  | $(y,y+1)$ | ![](https://cdn.luogu.com.cn/upload/image_hosting/po461m71.png) |  $(x,y)$  |
| $(x,x+1)$ |  $(y,y)$  | ![](https://cdn.luogu.com.cn/upload/image_hosting/gcex7xf2.png) |  $(x,y)$  |
| $(x,x+1)$ | $(y,y+1)$ | ![](https://cdn.luogu.com.cn/upload/image_hosting/ew7pbxqf.png) |  $(x,y)$  |
| $(x,x+1)$ | $(y+1,y)$ | ![](https://cdn.luogu.com.cn/upload/image_hosting/5tzslwt6.png)| $(x+1,y)$ |

有一个明显的性质：如果要出现 $(x,x),(y,y)$ 这样的组合，**到两个包点的最短路一定存在一个岔路口（称两个包点的连接），且一旦在连接分开后，我们就可以预见是在往哪个点转移**。

1. 如果 $\Delta_a\not=\Delta_b$，或属于图四的情况，那么我们最大只能取到 $\min(\Delta_a,\Delta_b)$。正确性显然，构造的方案（警去守的包点）已给出，可对照上表一一验证。

2. 此时 $\Delta_a=\Delta_b$，且属于图一的情况，那么我们就不能直接输出 $\Delta$ 了，因为题目有一句话：

	> 007 和 Dr. Null 都入侵了一个卫星系统，所以他们总是知道对方的位置

	两人都是有智慧的，在晚出发 $\Delta$ 的时间后，两人都可以同时走到任一点。再直接指定警的去向，可能导致警跑到了 $a$ 守包，但匪通过透视认出了行踪于是转 $b$ 的情况。总之，此时匪可以最终胜利的充要条件就是警先暴露行踪，跑去了错误的包点。反之亦然。所以有时我们需要预留单位时间的提前量，以保证警去了 $a$ 点才发现匪转的 $b$ 点时，能再抢先一步到 $b$ 点。

	既然双方都要晚暴露行踪，又要一直走最短路……到了这里可能你就反应过来了：两人行进路线一定是先走两条最短路径的公共部分，一直到连接处才转点。记警家到警连接的距离为 $c_1$，匪家到匪连接的距离为 $c_2$（也是 BFS 得到）。那么我们比较的就是警到警连接的时间 $c_1+\Delta$ 与匪到匪连接的时间 $c_2$ 哪个更长。明显 $c_1+\Delta<c_2$ 时，警先“误入歧途”，就得准备提前量，输出 $\Delta-1$。否则输出 $\Delta$。（顺便也满足 $\Delta=0$ 的不合法情况输出 $-1$ 的条件，省的特判）

```cpp
#include<bits/stdc++.h>
#define Counter return
#define Strike2 0
using namespace std;
const int N = 2e5+10;

queue<int> Q;
vector<int> E[N];
int n, m, s, t, a, b;
int dis[N], dit[N], sid[N], tid[N];

void bfs(int d[]) {
	while (!Q.empty()) {
		int u = Q.front(); Q.pop();
		for (int v : E[u]) {
			if (~d[v]) continue;
			d[v] = d[u] + 1; Q.push(v);
		}
	}
}

int main() {
	scanf("%d%d %d%d%d%d", &n, &m, &s, &t, &a, &b);
	for (int i = 1; i <= m; i ++) {
		int u, v; scanf("%d%d", &u, &v);
		E[u].push_back(v); E[v].push_back(u);
	}
	memset(dis, -1, sizeof dis); Q.push(s); dis[s] = 0; bfs(dis);
	memset(dit, -1, sizeof dit); Q.push(t); dit[t] = 0; bfs(dit);
	//两次bfs处理dis1、dis2 
	int der1 = dit[a] - dis[a], der2 = dit[b] - dis[b];
	//处理delta 
	if (min(der1, der2) < 0) printf("-1");
	else if (der1 == der2) {
		memset(sid, -1, sizeof sid);
		sid[a] = 0;	Q.push(a); bfs(sid);
		memset(tid, -1, sizeof tid);
		tid[b] = 0;	Q.push(b); bfs(tid);
		int c1 = 0, c2 = 0;
		for (int i = 1; i <= n; i ++) {
			if (sid[i] != tid[i]) continue;
			if (sid[i] + dis[i] == dis[a])
				c1 = max(c1, dis[i]);
			if (tid[i] + dit[i] == dit[a])
				c2 = max(c2, dit[i]);
		}
		//bfs处理c1、c2 
		if (c1 + der1 >= c2) printf("%d", der1);
		else printf("%d", der1-1);
	}
	else printf("%d", min(der1, der2));
	Counter Strike2;
}
```


---


# [COCI 2010/2011 #2] CRNI

## 题目描述

尽管 Mirko 找到了所有最有趣的游乐设施，但他的热情仍然没有消失。 他打开方格纸笔记本，开始给方块上色，一个新的甚至更难的问题浮现在他身上。

您将得到一个 $n \times n$ 的表格。 每个单元格的颜色是黑色或白色。

如果表格内的某一个矩形图形的所有单元格均为黑色并且此矩形由至少两个单元格组成，则此矩形称为黑色矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/h7lgmovq.png)

上左图举了两个不是黑色矩形的例子。 标为 $1$ 的矩形不是黑色矩形，因为它包含一个白色单元格；标为 $2$ 的矩形不是黑色矩形，因为它仅包含一个单元格。 上右图则举了三个黑色矩形的例子。

计算选择两个没有公共单元格的黑色矩形的方法数。 由于所求的结果可能非常大，因此您应该输出该数除以 $10^4 + 7$ 后的余数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2 \leq n \leq 1 \times 10^3$，输入字符串的每一位只可能是 `C` 或 `B`，令 $|s|$ 为每个字符串长度，则 $|s| = n$。

#### 说明

- 本题满分 $130$ 分。
- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) CRNI，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
2
CC
CC```

### 输出

```
2```

## 样例 #2

### 输入

```
3
CCB
CCB
CBB```

### 输出

```
5```

## 样例 #3

### 输入

```
5
BCCBB
BBCBB
BCCBB
BBBBB
CCBBB```

### 输出

```
8```

# 题解

## 作者：辰星凌 (赞：13)

# **【题解】Crni [P6551] [SP7884]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/11637590.html)
 
**传送门：[$\text{Crni [P6551]}$](https://www.luogu.com.cn/problem/P6551) [$\text{[SP7884]}$](https://www.spoj.com/problems/C2CRNI/)** 

-------

## **【分析】**

这是一道套路题，用到了很多关于矩阵的处理技巧，但找到解决方法后会发现它的思维难度其实并不高，主要是代码实现较困难，所以也可以视其为膜你题。

### **【前缀和的套路】**

找子矩阵基本都会用到前缀和，常见的查询子矩阵可以直接容斥，例如维护**二维树状数组**时用到的方法：

设 $S[x][y]=\sum_{i=1}^{x} \sum_{j=1}^{y} a[i][j]$，那么递推式为 $S[i][j]=$ $S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]$

如果要查询以 $(x1,y1)$ 为左下角，以 $(x2,y2)$ 为右下角的矩阵和，$\sum_{i={x_1}}^{y_1} \sum_{j={x_2}}^{y_2} a[i][j]=$ $S[x2][y2]-S[x1-1][y2]-S[x2][y1-1]+S[x1-1][y1-1]$

在预处理式子时需要从左上角一直递推到右下角，而稍复杂一点的需要统计多个方向（没错，就是此题了），即从最多 $4$ 个角落（左上，左下，右上，右下）开始向其对角处递推，得到多个助于统计答案的前缀和数组。

### **【预处理】**

回到此题。

为方便处理，将矩阵中的黑点设为 $1$，白点设为 $0$ 。

对于所有的黑点，先预处理出 $4$ 个数组：

$(1).$ $RD[i][j]$： 以 $(i,j)$ 为**右下角**的**黑矩阵**个数。

$(2).$ $LU[i][j]$： 以 $(i,j)$ 为**左上角**的**黑矩阵**个数。

$(3).$ $LD[i][j]$： 以 $(i,j)$ 为**左下角**的**黑矩阵**个数。

$(4).$ $RU[i][j]$： 以 $(i,j)$ 为**右上角**的**黑矩阵**个数。

但如果暴力枚举的话 $O(n^4)$ 复杂度过高，需要考虑合理**继承**前面求出的信息。

以 $RD$ 为例，为便于推导，我们先在矩阵中枚举一条辅助线，假设已经求出了第 $i$ 行前 $j-1$ 列的 $RD$ 信息，如图为 $i=4,j=4$ 的情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/24n4h1nl.png)

定义 $H[i][j]$ 为点 $(i,j)$ 向上最多可以延伸的距离（或者说高度），如果 $a(i,j)$ 为白块，$H[i][j]=0$ 。

处理方法如下：

对于点 $(i,j)$ 找到同一列前面第一个 $H$ 小于它的位置 $(i,k)$。

由于 $[k+1,j]$ 的高度都大于 $j$，那么将会有 $H[i][j]*(j-k)$ 个点可以作为**黑矩形**的**左上角**（**右下角**为 $(i,j)$），但是将 $(i,j)$ 自己作为**左上角**时**黑矩阵**大小只有 $1$，所以要减去 $1$ 。

另外以 $(i,k)$ 为**右下角**的**黑矩阵**都可以将长度扩大 $j-k$，即变成以 $(i,j)$ 为**右下角**，但以 $(i,k)$ 为**右下角**的情况没有计算在 $RD[i][k]$ 以内，所以要加上 $1$ 。

得到递推式为：$RD[i][j]=H[i][j]*(j-k)-1+RD[i][k]+1$ 。

于是时间复杂度就被优化到了 $O(n^3)$，但还不够优秀。

现在的问题是如何快速找 $k$，方法同 [$\text{Largest}$ $\text{Rectangle}$ $\text{in}$ $\text{a}$ $\text{Histogram}$](https://www.luogu.org/problem/SP1805) [（题解）](https://www.cnblogs.com/Xing-Ling/p/10935693.html)，直接单调栈维护即可。

在上面那张图中 $H[4][1]=1,H[4][2]=2,H[4][3]=4,H[4][4]=3$，所以 $j=4$ 时的决策点 $k=2$，因此 $RD[3][4]=3*2-1+RD[3][2]+1$ 。

同理可得 $LU,LD,RU$ 。

### **【统计答案】**

依旧是枚举辅助线：  
![](https://cdn.luogu.com.cn/upload/image_hosting/89a72vbb.png)

先求出**下边界在红线上面**的**黑矩形**个数，即 $\sum_{i=1}^{x} \sum_{j=1}^{n} RD[i][j]$（或者 $LD[i][j]$），

再求出**上边界紧贴在红线下面**的**黑矩阵**个数，即 $\sum_{j=1}^{n}LU[x+1][j]$（或者 $RU[x+1][j]$），

将二者相乘，再对于每一条辅助线算出的结果求和，得到**相对位置为上下**的**黑矩形**总对数。（其实也可以固定红线上面，红线下面求总个数）

同理枚举**竖线**，可得**相对位置为左右**的**黑矩形**总对数。

但这样会有算重复的情况，如下图绿色部分和蓝色部分：  
![](https://cdn.luogu.com.cn/upload/image_hosting/gz6se8m3.png)

因此还要减去**相对位置既有上下又有左右**的**黑矩形**对数，也就是在十字线对角象限的**黑矩形**对数，求法和前面大致相同。为方便处理，要任选两个方向计算矩阵前缀和（递推式和二维树状数组的一样）：

$(1).$ $S_{RD}[x][y]=\sum_{i=1}^{x} \sum_{j=1}^{y} RD[i][j]$  
前缀和递推方向：**左上** → **右下** 。  
矩阵前缀和意义：**右下角**在 $(i,j)$ **左上面**的黑矩阵个数。

$(2).$ $S_{LU}[x][y]=\sum_{i=n}^{x} \sum_{j=n}^{y} RD[i][j]$  
前缀和递推方向：**右下** → **左上** 。  
矩阵前缀和意义：**左上角**在 $(i,j)$ **右下面**的黑矩阵个数。

$(3).$ $S_{LD}[x][y]=\sum_{i=1}^{x} \sum_{j=n}^{y} RD[i][j]$  
前缀和递推方向：**右上** → **左下** 。  
矩阵前缀和意义：**左下角**在 $(i,j)$ **右上面**的黑矩阵个数。

$(4).$ $S_{RU}[x][y]=\sum_{i=n}^{x} \sum_{j=1}^{y} RD[i][j]$  
前缀和递推方向：**左下** → **右上** 。  
矩阵前缀和意义：**右上角**在 $(i,j)$ **左下面**的黑矩阵个数。

最后，此题细节较多，变量名没设好的话很容易搞混。

时间复杂度为：$O(n^2)$ 。

-------

## **【Code】**

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#define Re register int
#define For(i,a,b) for(Re i=a;i<=b;++i)
#define Por(i,a,b) for(Re i=a;i>=b;--i)
#define print() for(Re i=1;i<=n;puts(""),++i)for(Re j=1;j<=n;++j)
using namespace std;
const int N=1003,P=10007;
int n,Q[N],A[N][N],H[N][N],SS[N][N];char ch[N];
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
int RD[N][N];
inline void get_RD(){//RD[i][j]: 以i,j为右下角的黑矩形个数(1,1)→(n,n) 
    memset(H,0,sizeof(H));
    For(i,1,n)For(j,1,n)if(A[i][j])H[i][j]=H[i-1][j]+1;
//  print()printf("%d ",H[i][j]);puts("");
    For(i,1,n){
    	Re h=1,t=0;
    	For(j,1,n)if(!A[i][j])RD[i][j]=-1;
    	RD[i][Q[++t]=0]=-1;
    	For(j,1,n){
            while(h<=t&&H[i][Q[t]]>=H[i][j])--t;
            if(h<=t&&A[i][j])RD[i][j]=RD[i][Q[t]]+1+H[i][j]*(j-Q[t])-1;
            Q[++t]=j;
    	}
    	For(j,1,n)if(RD[i][j]<0)RD[i][j]=0;
    }
//  print()printf("%d ",RD[i][j]);puts("");
}
int LU[N][N];
inline void get_LU(){//LU[i][j]: 以i,j为左上角的黑矩形个数(n,n)→(1,1) 
    memset(H,0,sizeof(H));
    Por(i,n,1)Por(j,n,1)if(A[i][j])H[i][j]=H[i+1][j]+1;
//  print()printf("%d ",H[i][j]);puts("");
    Por(i,n,1){
    	Re h=1,t=0;
    	Por(j,n,1)if(!A[i][j])LU[i][j]=-1;
    	LU[i][Q[++t]=n+1]=-1;
    	Por(j,n,1){
            while(h<=t&&H[i][Q[t]]>=H[i][j])--t;
            if(h<=t&&A[i][j])LU[i][j]=LU[i][Q[t]]+1+H[i][j]*(Q[t]-j)-1;
            Q[++t]=j;
    	}
    	Por(j,n,1)if(LU[i][j]<0)LU[i][j]=0;
    }
//  print()printf("%d ",LU[i][j]);puts("");
}
int LD[N][N];
inline void get_LD(){//LD[i][j]: 以i,j为左下角的黑矩形个数(1,n)→(n,1)
    memset(H,0,sizeof(H));
    For(i,1,n)Por(j,n,1)if(A[i][j])H[i][j]=H[i-1][j]+1;
//  print()printf("%d ",H[i][j]);puts("");
    For(i,1,n){
    	Re h=1,t=0;
    	Por(j,n,1)if(!A[i][j])LD[i][j]=-1;
    	LD[i][Q[++t]=n+1]=-1;
    	Por(j,n,1){
            while(h<=t&&H[i][Q[t]]>=H[i][j])--t;
            if(h<=t&&A[i][j])LD[i][j]=LD[i][Q[t]]+1+H[i][j]*(Q[t]-j)-1;
            Q[++t]=j;
    	}
    	Por(j,n,1)if(LD[i][j]<0)LD[i][j]=0;
    }
//  print()printf("%d ",LD[i][j]);puts("");
}
int RU[N][N];
inline void get_RU(){//RU[i][j]: 以i,j为右上角的黑矩形个数(n,1)→(1,n)
    memset(H,0,sizeof(H));
    Por(i,n,1)Por(j,n,1)if(A[i][j])H[i][j]=H[i+1][j]+1;
//  print()printf("%d ",H[i][j]);puts("");
    Por(i,n,1){
    	Re h=1,t=0;
    	For(j,1,n)if(!A[i][j])RU[i][j]=-1;
    	RU[i][Q[++t]=0]=-1;
    	For(j,1,n){
            while(h<=t&&H[i][Q[t]]>=H[i][j])--t;
            if(h<=t&&A[i][j])RU[i][j]=RU[i][Q[t]]+1+H[i][j]*(j-Q[t])-1;
            Q[++t]=j;
    	}
    	For(j,1,n)if(RU[i][j]<0)RU[i][j]=0;
    }
//  print()printf("%d ",RU[i][j]);puts("");
}
inline int U_D(){//加上-下 
    Re ans=0,S=0;
    For(i,1,n){
    	For(j,1,n)(ans+=S*LU[i][j]%P)%=P;//用【左上角为(i,j)的矩阵LU】固定在辅助线下面
    	For(j,1,n)(S+=RD[i][j])%=P;//用【右下角为(i,j)的矩阵RD】求辅助线上边的总个数
    }
    return ans%P;
}
inline int L_R(){//加左-右 
    Re ans=0,S=0;
    For(j,1,n){
    	For(i,1,n)(ans+=S*LU[i][j]%P)%=P;//用【左上角为(i,j)的矩阵LU】固定在辅助线右边
    	For(i,1,n)(S+=RD[i][j])%=P;//用【右下角为(i,j)的矩阵RD】求辅助线左边的总个数
    }
    return ans%P;
}
inline int LU_RD(){//减左上-右下 
    Re ans=0;memset(SS,0,sizeof(SS));
    For(i,1,n-1)For(j,1,n-1){
    	SS[i][j]=((RD[i][j]+SS[i-1][j]+SS[i][j-1])%P-SS[i-1][j-1]+P)%P;
    	//十字线左上角的用【右下角为(i,j)的矩阵RD】求总和
    	(ans+=SS[i][j]*LU[i+1][j+1]%P)%=P;//用【左上角为(i,j)的矩阵LU】固定十字线的右下角
    }
    return ans;
}
inline int RU_LD(){//减右上-左下 
    Re ans=0;memset(SS,0,sizeof(SS));
    For(i,1,n-1)Por(j,n,2){
    	SS[i][j]=((LD[i][j]+SS[i-1][j]+SS[i][j+1])%P-SS[i-1][j+1]+P)%P;
    	//十字线右上角的用【左下角为(i,j)的矩阵LD】求总和
    	(ans+=SS[i][j]*RU[i+1][j-1]%P)%=P;//用【右上角为(i,j)的矩阵RU】固定十字线的左下角
    }
    return ans;
}
int main(){
//  freopen("crni.in","r",stdin);
//  freopen("crni.out","w",stdout);
    in(n);
    For(i,1,n){
    	scanf("%s",ch+1);
    	For(j,1,n)A[i][j]=(ch[j]=='C');
    }
    get_RD(),get_LU(),get_LD(),get_RU();
    printf("%d\n",((U_D()+L_R())%P-(LU_RD()+RU_LD())%P+P)%P);
//  fclose(stdin);
//  fclose(stdout);
    return 0;
}
```


---

## 作者：_Never45_ (赞：2)

其实还好的计数。

首先对题目转化。求两个不交的黑色矩形，可以看做先选一个黑色矩形，在剩下的图形中选一个黑色矩形的方案数。这一步的时间复杂度是 $O(n^4)$ 。

先不纠结于暴力的时间复杂度，来看这个做法的可行性。求去除了一个矩形的图形中还剩多少矩形，可以用容斥求解。如下图：

![dp](https://cdn.luogu.com.cn/upload/image_hosting/j8oaj7yl.png)

在黑色的大矩形中去除了一个黑色矩形，标记为红色。则剩下的个数可以记为上下左右四个矩形中所包含的黑色矩形和，同时减去重复计算的四个角的矩形。这一步为 $O(1)$ 。所以问题转化为求解一个矩形内包含的黑色矩形和。

同样运用二位差分，问题可以转化为求矩形 $(1, 1)$ 到 $(i, j)$ 的黑色矩形个数。同理，问题又可以转化为求解以 $(i, j)$ 为右上角的黑色矩形数。这个可以用单调栈维护，时间复杂度为预处理的 $O(n^2)$ 。

至此，时间复杂度瓶颈仅为枚举矩形的 $O(n^4)$ 。考虑优化。

可以发现，位置类似的矩形所造成的贡献类似。可以将容斥中所涉及到的 $8$ 个矩形单独提出考虑。可以分为两类：边矩形和角矩形。

边矩形的贡献源于枚举黑色矩形的边，枚举边，同时求出以这个边为上/下/左/右边的黑色矩形数量，时间复杂度 $O(n^2)$ 。

角矩形的贡献源于枚举黑色矩形的角，枚举角即可，时间复杂度 $O(n^2)$ 。

所以，总时间 $O(n^2)$ 完成。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1000 + 5, Mod = 10000 + 7;

long long n, g[5][N][N], a[5][N][N], h[5][N];
char s[N][N], b[N][N];
stack<long long> op, ed;

long long ksm(long long x, long long y)
{
	long long temp = 1;
	while(y)
	{
		if(y & 1) temp = 1ll * temp * x % Mod;
		x = 1ll * x * x % Mod;
		y >>= 1;
	}
	return temp;
}

int main()
{
//	freopen("table.in", "r", stdin);
//	freopen("table.out", "w", stdout);

	scanf("%lld", &n);

	for(long long i = 1; i <= n; ++i) scanf("%s", s[i] + 1);
	
	long long ans = 0;
	for(long long T = 0; T < 4; ++T)
	{
		long long sum = 0;
		
		for(long long i = 1; i <= n; ++i)
		{
			sum = 0;
			for(long long j = 1; j <= n; ++j)
			{
				if(s[i][j] == 'B') h[T][j] = 0;
				else h[T][j]++;
				
				while(op.size() && h[T][op.top()] > h[T][j])
				{
					sum -= h[T][op.top()] * (op.top() - ed.top() + 1) % Mod, op.pop(), ed.pop();
					if(sum < 0) sum += Mod;	
				}
				if(op.size()) sum += h[T][j] * (j - op.top()) % Mod, ed.push(op.top() + 1), op.push(j);
				else sum += h[T][j] * j % Mod, ed.push(1), op.push(j);
				
				if(sum >= Mod) sum -= Mod;
				
				g[T][i][j] = sum;
				if(s[i][j] == 'C') g[T][i][j]--;
			}
			while(op.size()) op.pop(), ed.pop();
		}
	
		for(long long i = 1; i <= n; ++i)
		{
			for(long long j = 1; j <= n; ++j)
			{
				a[T][i][j] = (a[T][i - 1][j] + a[T][i][j - 1] - a[T][i - 1][j - 1] + g[T][i][j] + Mod) % Mod;
			}
		}
		
		for(long long i = 1; i <= n; ++i)
		{
			for(long long j = 1; j <= n; ++j) b[n - j + 1][i] = s[i][j];
		}
		for(long long i = 1; i <= n; ++i)
		{
			for(long long j = 1; j <= n; ++j) s[i][j] = b[i][j];
		}
	}
	
	for(long long T = 0; T < 4; ++T)
	{
		for(long long i = 1; i <= n; ++i)
		{
			long long temp = 0;
			for(long long j = 1; j <= n; ++j)
			{
				ans -= g[T][i][j] * a[(T + 2) % 4][n - i][n - j] % Mod;
				if(ans < 0) ans += Mod;
				temp += g[T][i][j];
                if(temp >= Mod) temp -= Mod;
			}
			ans += a[(T + 2) % 4][n - i][n] * temp % Mod;
			if(ans >= Mod) ans -= Mod;
		}
	}

	long long z = ans * ksm(2, Mod - 2) % Mod;
	printf("%lld\n", z);

	return 0;
}
```


---

## 作者：yxy666 (赞：1)

我们接下来看一个 $2X3$ 的矩阵方案数的统计原理,再进行拓展,其中 $a,b,c,d,e,f$ 均为黑色单元格 .

| $a$ | $b$ | $c$ |
| :----------: | :----------: | :----------: |
| $d$ | $e$ | $f$ |

对于此时答案为$a(b+c+d+e+f)+b(c+d+e+f)+c(d+e+f)+d(e+f)+ef。$

我们对式子变形处理为： $(a+b+c)(d+e+f)+(a+d)(b+c+e+f) - a(e+f) - d(b+c) + (b+e)(c+f) - bf - ec$ 

理解即为把每一行的所有方案数 $*$ 下面一块区域的所有方案数+每一列 $*$ 右边区域的所有方案数 $-$  当前左下角（下看） $*$ 右上所有 $-$  当前左上角（上看） $*$ 右下角所有。

$code$ :
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX=1005,TT=10007;
int n,MP[MAX][MAX],h[MAX],ans[MAX][MAX],ul[MAX][MAX],dl[MAX][MAX],UL[MAX][MAX],UR[MAX][MAX],DL[MAX][MAX],DR[MAX][MAX];
char S[MAX];
void flip_LR(int mat[MAX][MAX]){
	for (int i=1;i<=n;i++)
    for (int a=1,b=n;a<b;a++,b--) swap(mat[i][a],mat[i][b]);
}
void flip_UD(int mat[MAX][MAX]){
	for (int a=1,b=n;a<b;a++,b--)
    for (int j=1;j<=n;j++) swap(mat[a][j],mat[b][j]);
}

void Copy(int a[MAX][MAX],int b[MAX][MAX]){
	for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++)
      b[i][j]=a[i][j];
}
void RC(int mat[MAX][MAX]){
	for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++)
      mat[i][j]=((mat[i][j]+mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1])%TT+TT)%TT;
}

void solve(){
	memset(h,0,sizeof h);
    for (int i=1;i<=n;i++){
    	for (int j=1;j<=n;j++)
          if (MP[i][j]) h[j]++;else h[j]=0;
        stack<int> stk;
        stk.push(0);
        int area=0;
        for (int j=1;j<=n;j++){
        	while (stk.top()&&h[stk.top()]>=h[j]){
        		int a=stk.top();stk.pop();
                int b=stk.top();
                area-=(j-b-1)*(h[a]-max(h[j],h[b]));
            }
            stk.push(j);
            area+=h[j];
            ans[i][j]=max(area-1,0)%TT;
        }
    }
}
int main(){
	freopen("crni.in","r",stdin);
	freopen("crni.out","w",stdout);
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
    	scanf("%s",S+1);
        for (int j=1;j<=n;j++) MP[i][j]=S[j]=='C';
    }
    solve(),Copy(ans,ul),Copy(ans,UL),RC(UL);
    flip_LR(MP),solve(),Copy(ans,UR),RC(UR),flip_LR(UR),flip_LR(MP);
    flip_UD(MP),solve(),Copy(ans,dl),Copy(ans,DL),RC(DL),flip_UD(dl),flip_UD(DL);
    flip_LR(MP),solve(),Copy(ans,DR),RC(DR),flip_LR(DR),flip_UD(DR);
    int Ans=0;
    for (int i=1;i<=n;i++){
    	Ans+=(DL[1][i]-DL[1][i-1]+TT)*DR[1][i+1];//当前第i列*右下一整块区域 
        Ans+=(UL[i][n]-UL[i-1][n]+TT)*DL[i+1][n];//当前第i行*左下一整块区域 
        Ans%=TT;
        for (int j=1;j<=n;j++){
        	Ans-=ul[i][j]*DR[i+1][j+1];//左上单点*右下一整块区域 
            Ans-=dl[i][j]*UR[i-1][j+1];//左下单点*右上一整块区域 
            Ans=(Ans%TT+TT)%TT;
        }
    }
    printf("%d\n",Ans);
    return 0;
}
```


---


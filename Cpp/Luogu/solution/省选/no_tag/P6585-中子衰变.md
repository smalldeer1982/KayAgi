# 中子衰变

## 题目背景

这是一道**交互题**。

可能会用到的前置知识：

质子带一个单位的正电荷。

电子带一个单位的负电荷。

中子不带电。

## 题目描述

Youyou 和小 Z 面前有 $n$ 个中子，从左往右排成一行，这些中子被强作用力固定在编号为 $1 \sim n$ 的位置上。

小 Z 拥有一台弱作用衰变机 Wadm（Weak Action Decay Machine）。Wadm 每次可以使一个中子发生弱作用衰变，放出一个电子和一个质子（本题中不考虑中微子），然后 Wadm 会根据 Youyou 或小 Z 的指令，留下其中一个粒子，然后将另一个粒子移出体系。

简而言之，Wadm 可以将一个中子变为一个电子或一个质子。

现在小 Z 想和 Youyou 玩一个游戏：两个人轮流使用 Wadm 操作一个中子，将其变为一个电子或一个质子。然而，如果一个电子和质子相邻，那么由于强大的库仑引力的作用，它们会脱离强作用力的束缚，所以这种情况是不被允许的。如果轮到某人操作时，所有位置都不能操作了，那么他就输了。

Youyou 快乐地答应了小 Z 的游戏请求，但是面对聪明的小 Z，Youyou 只好来求助你了。

特别地，**如果全部中子最后变成了同种粒子，那么后手获胜**。

如果你帮助 Youyou 打败了小 Z，那么 Youyou 就会送你一台 Wadm 作为奖励！

## 交互方式

你的程序应从标准输入中读入，向标准输出中输出。

输入中将包含两个整数 `n task_id` ，分别代表题目中的 $n$ 和子任务编号。

然后你需要输出一个整数 `order`，$\text{order}$ 只能是 $0$ 或 $1$。$0$ 代表你选择先手，$1$ 代表你选择后手。

接下来，你应该根据你选择的先后手情况通过标准输入输出与交互库进行交互。

- 若轮到你操作，那么你应该接着输出两个整数 `place type`，代表你将位置在 $\text{place}$ 的中子变为了电子（$\text{type}=-1$）或质子（$\text{type}=1$）。其中，你需要保证：
  - $\text{place} \in [1,n]$ 且该位置可以操作；
  - $\text{type} \in \{-1,1\}$；
  - **你已经清空缓冲区**。在 C 或 C++ 中，可使用 `fflush(stdout)` 函数。在 C++ 中，还可使用 `cout << flush`，`cout.flush()`，或使用 `endl` 而不是 `'\n'` 来输出一个换行。

- 若轮到小 Z 操作，那么你应该接着读入两个整数 `place type`，代表小 Z 将位置在 $\text{place}$ 的中子变为了电子（$\text{type}=-1$）或质子（$\text{type}=1$）。其中，保证：
  - $\text{place} \in [1,n]$ 且该位置可以操作；
  - $\text{type} \in \{-1,1\}$。

例如，如果你选择先手，那么你应该按照「输出，输入，输出，输入……」的顺序进行交互。如果你选择后手，那么你应该按照「输入，输出，输入，输出……」的顺序进行交互。

请注意，如果游戏结束，你应当立即终止程序。游戏结束后多余的输出可能会导致 RE 。

## 说明/提示

* Subtask 1（5 分）：$n \leq 4$；
* Subtask 2（8 分）：$n \leq 8$；
* Subtask 3（12 分）：$n$ 为偶数，交互库特殊策略*；
* Subtask 4（15 分）：交互库特殊策略*；
* Subtask 5（20 分）：$n$ 为偶数；
* Subtask 6（40 分）：无特殊限制。

*交互库特殊策略：每次轮到交互库操作时，交互库会找到最左侧的能操作的位置，然后如果该位置能操作为质子，则操作为质子，否则操作为电子。

对于全部的数据，保证 $1 \leq n \leq 2^{10}$ 。

## 样例 #1

### 输入

```
4 1


2 1
```

### 输出

```

0
1 1

4 -1```

# 题解

## 作者：鏡音リン (赞：13)

我们对$n$的奇偶进行分类讨论：

若$n$是偶数，我们选择后手。对于对手每次操作，我们操作其对称的位置，将其转变为与对手操作相同的粒子。容易证得这样的操作一定合法。

若$n$是奇数，我们可以尝试先操作最中间的位置，然后使用和上面类似的对称策略。但是由于```如果全部中子最后变成了同种粒子，那么后手获胜。```这条规则，这个策略并不成立。

换一个思路，我们选择后手。我们的操作策略要保证，每次我方操作后，局面状态满足一个循环不变式：

存在一个$m\le\frac{n-1}{2}$使得，前$m$个粒子和后$m$个粒子相反对称，且中间剩余的一段除某一个端点没被操作外，其他部分都被操作成了相同的粒子。其中，**相反对称**的定义是：对于任意$i\le m$，左起第$i$个粒子和右起第$i$个粒子要么都没被操作过，要么电性相反。

例如，以下情况都是满足条件的：

| 1 | 1 | 0 | 0 | 0 | 0 | 0 | -1 | -1 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |

| 0 | -1 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |

| 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |

（三个例子中$m$分别可以取$4,3,0$）

注意初始状态也是满足这个条件的，$m$取$\frac{n-1}{2}$即可。

我们可以采取以下策略维护这个循环不变式：

选择后手，对于对手每次操作，我们都操作其对称的位置，将其转变为与对手操作相反的粒子。但是有两种例外情况，可能导致我们的操作不合法：

- 对手操作了中间一段剩下的那个端点。（例如在上面的第二行例子中，对手将第六格变成$1$）。由于我们保证左右两侧是相反对称的，那么与中间一段相邻的两个粒子中，必然有一个是可操作的。我们把这个格子操作成和中间一段相同的粒子（接上面的例子，把第七格变成$1$），易发现这样操作后循环不变式仍然满足，且$m$的值减少了$1$。特殊地，如果$m$已经是$0$，对手这样操作后必然导致所有粒子相同，根据规则后手胜。

- 对手操作了中间一段剩下的那个端点相邻的一个点，且与中段的电性相同（例如在上面的第二行例子中，对手将第七格变成$1$）。此时我们只需要把那个端点操作成相同的粒子即可（接上面的例子，把第六格变成$1$）。循环不变式仍然成立，且$m$的值减少了$1$。

如果我们一直维护了这个循环不变式，对于对手的每一个合法操作我们都有一个对应的合法操作，显然后手必胜。

---

## 作者：xuanxuan001 (赞：5)

第 $3^2$ 篇题解了

一道月赛题为什么这么冷门啊，~~博弈论这么不受欢迎吗~~

正文
-
$n$ 为偶数时直接对称就可以了，另一篇题解讲了。这里讲一讲 $n$ 为奇数的时候。

稍加分析可以发现这题最后的局面一定是连续的一些质子\电子，空一个，一些电子\质子，空一个，……，一些质子\电子。所以说要控制的就是空的位置的数量，而与此直接关联的就是端点上的（就是第一个和第 $n$ 个，下同）粒子（显然不会是中子）的类型是否相同。同时，与端点相邻的两个粒子（即第二个和第 $n - 1$ 个）也与胜负有关。因为选择了它们就等于决定了与它们相邻的端点粒子的种类。所以如果一个人更改了两边的 4 个粒子，那么另一个人就会立即更改另一端的粒子来让自己赢。所以说除非迫不得已，没有人会更改两边的 4 个粒子。

所以问题就变成了中间的 $n - 4$ 个粒子，你只要做到你操作了这 $n - 4$ 个粒子中的最后一个可操作的即可，那么就与前面的 $n$ 个粒子的情况一样了。

因此可以不断减小规模直到 $n \le 4$。

这时我们把最边上的 4 个粒子分为一组，较靠里的 4 个分一组，再往里的 4 个再分一组，直到最中间的那 4 个不到分为一组。

>特别地，**如果全部中子最后变成了同种粒子，那么后手获胜。**

通过手玩可以发现 $n$ 为奇数时也要选择后手，这时我们要把端点的粒子变成不同种，否则就让他整个都是同种。

首先，如果交互库没有操作正中间的粒子，那么我们可以直接操作那一组的另一边的粒子为另一类，此时交互库操作的这一组以及更靠里的若干组构成的这个区间你就必胜了（即如果只有这个区间里的粒子你就可以保证获胜了，将这个区间命名为“必胜区间”）。就可以直接跳过下面的两段了。

如果他选了正中间，那么我们就记住它把那个粒子变成了什么，设它变成了 $c$。然后从里到外将每组粒子中左边的两个中的一个变为 $c$。如果下面

1. 交互库没有操作这一组右边的那两个粒子，就直接将这一组靠右的那两个粒子变为 $a$ 的另一种粒子。然后这一组以及更靠里的若干组构成的这个区间就是“必胜区间”了。
1. 否则，如果交互库将粒子变为 $a$ 的另一种粒子，那么情形也与第一种情况一样了，然后你只要找到一个在这个区间里的另一个可操作的粒子进行操作即可。
1. 否则继续操作。

如果从始至终一直都是第一个情况的话，那么此时每组的左右两部分都各有一个粒子被变成了 $c$。所以任意一个粒子都要么被变成了 $c$，要么与一个 $c$ 相邻。所以最后就一定会是全部为 $c$，你胜。

否则接下来如果交互库选择了

1. 如果它选择了在你的“必胜区间”里的粒子，那么你也一定可以在你的区间里再选一个。
1. 否则，你只要把相应组的另一端的粒子改成相反的粒子并更新“必胜区间”即可。

好吧，然后你就胜了。

应该也没啥好说的了。

代码
-
```
#include<cstdio>
#define Ty int
#define MAXN 1026
#define FOR(i,a,b) for(Ty i=a;i<=b;i++)
#define fOR(i,a,b) for(Ty i=a;i<b;i++)
#define ROF(i,a,b) for(Ty i=a;i>=b;i--)
#define rOF(i,a,b) for(Ty i=a;i>b;i--)
using namespace std;
const Ty INF=2e6;
typedef long long ll;
typedef unsigned long long ull;
Ty abs(Ty a){return a<0?-a:a;}
Ty maxn(Ty a,Ty b){return a>b?a:b;}
Ty minn(Ty a,Ty b){return a<b?a:b;}
Ty qr(){
	char ch=getchar();Ty x=1,s=0;
	while(ch<'0'||ch>'9'){if(ch=='-')x=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return x*s;
}Ty n,c,x,y,in,tmp,a[MAXN];
Ty ara(Ty a){if(a%2==0)a--;return a;}//求所在的组（返回所在组的最左边的粒子编号） 
void chang(Ty x,Ty y){printf("%d %d\n",x,y);fflush(stdout);a[x]=y;}
void js(Ty x){//寻找可操作位置并直接修改（从 x 开始找） 
	FOR(i,x,n){
		if(a[i])continue;
		if(a[i-1]!=-1&&a[i+1]!=-1){chang(i,1);break;}
		if(a[i-1]!=1&&a[i+1]!=1){chang(i,-1);break;}
	}
}bool can(){//判断游戏是否结束（即有没有可操作粒子） 
	FOR(i,1,n){
		if(a[i])continue;
		if(a[i-1]==a[i+1])return true;
		if((a[i-1]&a[i+1])==0)return true;
	}return false;
}
int main(){
	n=qr();qr();tmp=ara(n+1>>1);
	printf("1\n");fflush(stdout);
	if(n&1){
		x=qr();a[x]=c=qr();//讨论交互库的第一次操作 
	    if(x==n+1>>1){
	        for(tmp-=2;tmp>0;tmp-=2){//从里到外操作每一组 
	            chang(tmp,c);
	            x=qr();y=a[x]=qr();
	            in=minn(x,n-x+1);
	            if(in<tmp){
	            	tmp=ara(in);
					if(x==tmp||x==tmp+1)chang(n-tmp+1,-y);
					if(x==n-tmp+1||x==n-tmp)chang(tmp,-y);
					break;
				}if(in>tmp+1){js(tmp);break;}if(c^y){//第二种 
	                if(y==n-tmp+1)chang(n-tmp,c);
	                else chang(n-tmp+1,c);
	                break;
	            }
	        }if(tmp<0)js(tmp=1);
	    }else{
	        tmp=ara(in=minn(x,n-x+1));
	        if(x==tmp||x==tmp+1)chang(n-tmp+1,-c);
	        if(x==n-tmp+1||x==n-tmp)chang(tmp,-c);
	    } 
	    while(can()){
	        x=qr();y=a[x]=qr();
	        in=minn(x,n-x+1);
	        if(tmp<=in)js(tmp);//第一种 
	        else{//第二种 
	            tmp=ara(in);
	            if(x==tmp||x==tmp+1)chang(n-tmp+1,-y);
	            if(x==n-tmp+1||x==n-tmp)chang(tmp,-y);
	        }
	    }
	}else{
		while(can()){
			x=qr();y=a[x]=qr();
			chang(n-x+1,y);
		}
	}return 0;
}
```

这个交互库只考察了主要的策略，结果我第一次 A 的代码都有小漏洞，现在这个代码还是审核前改的，也不知道还有没有错，所以要是有人发现还有问题就在评论区发一下吧，谢谢。

---

## 作者：p878567 (赞：3)

 这个题当场想到了做法，但~~要考化学没时间写，懒得补~~，因此~~口胡~~描述一下做法。  
## Subtask1: $n$ 为偶数

这档部分分应当比较简单。  
拿后手，对方摆什么你都和他对称着操作，这样总是合法的。  
这样由于你是后手，且你每一步都能操作，因此你必胜。

## Subtask2: $n$ 为奇数

这个比较困难。

手玩 $n$ 较小的情况发现仍然后手必胜，考虑构造证明。  

一般情况下进行反对称操作（即在对称位置上进行相反操作）。  

除非对方在正中间操作，否则你总是可以操作。  

以下处理对方在正中间操作后的情况，并假定你所考虑的位置总是存在的。  

> 若对方在正中间操作，那么你在距其为 $1$ 的位置进行相同的操作（由反对称性，可以证明这样的位置总是存在，以下不再重复）  
>> 若对方在距正中间 $\geq3$ 的位置操作，那么仍然反对称操作，这总是合法的（以下不再重复）。

>> 若对方在与你对称的位置操作，那么把这 $3$ 个位置当成一个整体，这相当于对方在正中间进行的一次操作，再次调用该方法。

>> 若对方在和你相邻的位置操作，那么仍然反对称操作。此时发现距中心为 $1$ 的另一个位置再也无法操作，以后就都能反对称了。

>> 若对方在另一个距中心为 $2$ 的位置操作，且和第一次操作相反，则与上一种情况相同。

>> 若对方在另一个距中心为 $2$ 的位置操作，且和第一次操作相同，

~~这一种应该是最麻烦的了，实在懒得写代码~~  

>>> 若距中心为 $3$ 的位置已被占据，那么我们发现另一个（指不同于对方操作位置的）距中心为 $2$ 的位置再也无法操作，那么你操作留下来距中心为 $1$ 的位置，以后就都能反对称了。  

>>> 若距中心为 $3$ 的位置未被占据：
>>>> 1. `..00+0[+]+000..` 或 `..-0+0[+]+00+..` (`+` `-` 指已确定部分， `0` 指未确定部分，`[]` 表示中心，下同)  
>>>> 将 `+0[+]+0` 当成整体，并操作为 `0[+0++0]+`，中间的空位不主动进入，对方占据某一格时你立刻占据另一个，回到初始情况。 
>>>> 2. `..+0+0[+]+00-..`，那么操作为 `+++0[+]+00-`，那么中间的 $3$ 个 `0` 无论如何都恰有两个可以被操作，对方操作某一个时你立刻选一个操作，以后就都能反对称了。  

如果在你应该操作的位置并不存在（指超出 $n$ 的范围限制），那么可以发现此时的局面无论如何操作都将得到全 `+` 或全 `-`，根据规则，此时你仍然获胜。

upd: 在 `若对方在另一个距中心为 $2$ 的位置操作，且和第一次操作相同，` 情况中，可以直接操作余下的距中心为 $1$ 的位置，并当作 `+[+++]0` 处理

---

## 作者：vectorwyx (赞：2)

如果 $n$ 为偶数可以选后手下模仿棋。以下默认 $n$ 为奇数。

不妨假定先手第一个放的数是 $1$。如果进行了奇数次回合且最终局面非全 $1$ 那么先手赢，否则后手赢。回合数相当于非 $0$ 位置数，由于 $n$ 为奇数，所以如果最终有偶数个 $0$ 那么先手胜，否则后手胜。$0$ 的个数又和什么有关呢？注意到每个 $0$ 旁边一定是一个 $+1$ 一个 $-1$，所以一个 $0$ 标记着 $\pm 1$ **连续段**的转换。同时 $a_1,a_n$ 一定非零，所以如果 $a_1=a_n$，连续段的转换一定进行了偶数次，否则进行了奇数次。这也就表明决定胜负的其实是 $a_1,a_n$ 是否相同，先手希望 $a_1=a_n$，后手希望 $a_1\not= a_n$。当然，即使 $a_1=a_n$ 也不意味着先手就一定能赢，因为还有全 $1$ 的特殊情况，但是如果 $a_1\not= a_n$ 先手就真的完蛋了。

所以如果先手有选择，他一定不会去碰 $a_1,a_2,a_{n-1},a_n$ 这四个位置，对后手也是如此。因为一旦有一方率先动了这四个位置中的一个，假设他动了 $a_1$，那么对方只需要把 $a_n$ 设置成对他有利的值，比如先手动 $a_1$ 后手就可以接着把 $a_n$ 变成 $-a_1$ 来杀死比赛。而如果先手动了 $a_2$，$a_1$ 其实也就相应的固定下来了，后手把 $a_{n-1}$ 变为 $-a_2$ 也能杀死比赛。这意味着双方如果想赢只能先尽量把操作落在 $[3,n-2]$ 里，如果轮到某一方没法使操作落在 $[3,n-2]$ 这个区间里那他就寄了。同时有个特例，如果 $[3,n-2]$ 全都是 $1$（注意这表明此时轮到了后手），后手只需要把 $a_{n-1}$ 设成 $1$，如果先手想赢，他就只能相应地把 $a_1$ 设为 $1$，于是剩下的两个位置也只能是 $1$，此时 $[1,n]$ 全都是 $1$，后手胜。那 $[3,n-2]$ 这个问题是不是和原问题一模一样，只是规模缩减了？递归！直到 $n=1,3$，而这两种情况后手都可以保证填出来的区间全 $1$，大获全胜。

具体实现就是执后手，如果对面不走中点就仍然在对称位置下相反棋。如果他走了中点，此时中点旁边的两个位置肯定是空着的，随便选一个位置 $i$ 贴着走。接下来如果对面的某一步走到了 $i$ 的对称位置，则一定有 $a_{\frac{n+1}{2}-1}=a_{\frac{n+1}{2}}=a_{\frac{n+1}{2}+1}$，那么旁边的两个位置 $a_{\frac{n+1}{2}-2}$ 和 $a_{\frac{n+1}{2}+2}$ 一定全空，继续随便选一个位置落子。但是这样的话有个小问题就是如果对面下在了空出来的那个位置（比如 $i$ 的对称位置）的旁边，有可能无法在对称位置下相反棋，此时需要在空出来的位置落子。这样递归地做下去，在对方落子后总能找到一个相应的可行位置落子，时间复杂度 $O(n)$。

代码如下：

```cpp
#include<bits/stdc++.h>
namespace vectorwyx{
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){signed ch=getchar();int x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=1<<10|1;
int a[N],cnt,n,ok[N];

void set(int x,int o){
	assert(x>0&&x<=n);
	assert(!ok[x]);
	a[x]=o;cnt--;ok[x]=1;
	if(x>2&&a[x-1]==0&&a[x-2]==-o&&!ok[x-1]) cnt--,ok[x-1]=1;
	if(x<n-1&&a[x+1]==0&&a[x+2]==-o&&!ok[x+1]) cnt--,ok[x+1]=1;
	if(cnt==0) exit(0);
}

void play_(int x,int o){
	assert(x>0&&x<=n);
	assert(!ok[x]);
	printf("%d %d\n",x,o);cout.flush();
	set(x,o);
}

signed main(){
	n=read();read();
	cnt=n;
	puts("1");cout.flush();
	if(n%2==0){
		while(1){
			int x=read(),o=read();
			set(x,o);
			play_(n-x+1,o);
		}
	}
	int aim=(n+1)/2,nxt=aim+1;
	while(1){
		int x=read(),o=read();
		set(x,o);
		if(x==aim){
			int x_=nxt;
			if(ok[x_]) x_=n-x_+1;
			assert(!ok[x_]);
			play_(x_,o);
			aim=n-x_+1;nxt=aim>n/2?aim+1:aim-1;
		}else if(x==nxt){
			play_(aim,o);
			aim=n-x+1;nxt=aim>n/2?aim+1:aim-1;
		} 
		else play_(n-x+1,-o);
	}
	return 0;
}
}
/*
-------------------------------------------------
*/










signed main(){re vectorwyx::main();}
```



---

## 作者：P_Bisector (赞：0)

奇偶分析入门题。

先给出结论：后手必胜。

$n$ 为偶数的时候直接走与对方相对称的位置即可。以下只分析 $n$ 为奇数的情况。

# 正文

 考虑所有可以填放的位置全部被填满的情况。
  - 如果有偶数个位置被填放，后手获胜。
  - 如果有奇数个位置被填放，那么除非所有位置电荷相同，否则先手获胜。

我们考虑所有无法放置的位置，显然这个位置两侧的电荷不等，也就是说，如果我们从左往右看，那么每个无法放置的位置意味着电荷的反转。

由于我们希望有偶数个位置被填放，即奇数个位置无法放置，那么电荷一定被反转奇数次，因此首尾两个位置的电荷必不相同，否则所有电荷均相同。相反地，对手一定希望首尾两个位置的电荷相同。

于是我们发现两人都不希望走到边缘的四个位置，一旦走到这四个位置，除非当后手走的时候其他位置已经做到所有电荷均相等，否则必败。

那么为了逼迫对手走到这四个位置，我们需要构造使得第三个和倒数第三个位置的电荷相反，易证此时中间一定恰好填了偶数个位置，此时对手行棋，其必败。

归纳分析可以发现，假设所有电荷都位于 $[l,n+1-l]$ 这个区间中，那么只要构造两端电荷不同或者所有电荷相同即可胜利。

以下给出具体策略：

游戏开始时，设 $l=\frac{n+1}{2}$，设 $r$ 恒等于 $n+1-l$。

- 如果先手行棋在 $[l,r]$ 内：

  - 如果 $[l,r]$ 区间未满（可以行棋），任选区间内的一个点进行行棋；
  - 如果 $[l,r]$ 区间已满（无法行棋），由于此时为后手行棋，必然是 $l,r$ 两处电荷相同。由于我们前面保证此状态下区间内电荷都相同，于是我们选择在 $r+1$ 处行棋。此时，由于 $[l-1,r+1]$ 范围内只有一个位置没有电荷并且其右侧有电荷，因此对方无法破坏区间内电荷相同的条件。
- 如果先手行棋在 $[l,r]$ 外，设其行棋位置为 $x$：

  - 如果可以在 $n+1-x$ 处填与之相反的电荷，则填入；
  - 如果不可以在 $n+1-x$ 处填与之相反的电荷，易证 $x=l-1$ 或 $x=r+1$。分析 $x=l-1$ 的情况。此时显然不满足 $l$ 和 $r$ 两处相反，因此一定是区间内所有电荷均相等。为了保持阵型，在 $[l,r]$ 中任选一个点行棋。

::::info[代码如下]
```cpp
#include<bits/stdc++.h>
#define B7 __int128
#define pb push_back
#define PLL pair<int,int>
#define U6 unsigned long long
#define f first
#define s second
#define Qin ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;void solve();void init();
void file(string s){freopen((s+".in").c_str(),"r",stdin);freopen((s+".out").c_str(),"w",stdout);}
int main(){Qin;init();int t,M=0;M?(cin>>t,0):t=1;while(t--)solve();return 0;}
#define int long long
const int inf=1e18,N_=100050,mod=998244353,P=1e9+7,N=1e6+50,N2=5050;
void init(){}
int a[N],n;
int check(){
    for(int i=1;i<=n;i++){
        // assert(a[i]==0||a[i]!=-a[i+1]);
        if(a[i]==0&&(a[i-1]==0||a[i+1]==0||a[i-1]==a[i+1]))return 1;
    }
    return 0;
}
void evensolve(){
    cout<<1<<endl;
    while(check()){
        int x,y;
        cin>>x>>y;
        a[x]=y;
        cout<<n+1-x<<" "<<y<<endl;
        a[n+1-x]=y;
    }
}
void random_put(int x){
    if(a[x-1]==0)cout<<x<<" "<<1<<endl,a[x]=1;
    else cout<<x<<" "<<a[x-1]<<endl,a[x]=a[x-1];
}
int checkput(int x,int y){
    if(a[x-1]!=-y&&a[x+1]!=-y&&a[x]==0){
        cout<<x<<" "<<y<<endl;
        a[x]=y;
        return 1;
    }
    return 0;
}
int random_put(int l,int r){
    for(int i=l;i<=r;i++){
        if(checkput(i,1))return 1;
        if(checkput(i,-1))return 1;
    }
    return 0;
}
void midsolve(){
    int l=(n+1)/2,r=(n+1)/2,mid=(n+1)/2;
    while(check()){
        int x,y;
        cin>>x>>y;
        a[x]=y;
        if(!check())return;
        if(x<l||x>r){//不在范围内
            l=min(l,min(x,n+1-x));
            r=n+1-l;
            if(!checkput(n+1-x,-y)){
                random_put(l,r);
            }
        }else{
            if(!random_put(l,r)){
                r++,l--;
                checkput(r,1);
                checkput(r,-1);
            }
        }
    }
}
void solve(){
    cin>>n>>a[n+2];
    if(n%2==0)return evensolve();
    cout<<1<<endl;
    midsolve();
    return;
}
```
::::

---


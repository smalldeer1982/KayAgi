# [HNOI2016] 序列 加强版

## 题目背景

本题是 [P3246](https://www.luogu.com.cn/problem/P3246) 的数据加强版，扩大了询问次数的范围，增加了强制在线，并加入了一组构造数据。

本题的输入输出格式与原题略有不同。

## 题目描述

给定长度为 $ n $ 的序列：$ a_1, a_2, \cdots , a_n $，记为 $ a[1 \colon n] $。类似地，$ a[l \colon r] $（$ 1 \leq l \leq r \leq N$）是指序列：$ a_{l}, a_{l+1}, \cdots ,a_{r-1}, a_r $。若 $1\leq l \leq s \leq t \leq r \leq n$，则称 $ a[s \colon t] $是 $ a[l \colon r] $ 的子序列。

现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \leq l \leq r \leq n $，求 $ a[l \colon r] $ 的不同子序列的最小值之和。例如，给定序列
 $ 5, 2, 4, 1, 3 $，询问给定的两个数为 $ 1 $ 和 $ 3 $，那么 $ a[1 \colon 3] $ 有 $ 6 $ 个子序列 $a[1 \colon 1], a[2 \colon 2], a[3 \colon 3], a[1 \colon 2],a[2 \colon 3], a[1 \colon 3] $，这 $6 $ 个子序列的最小值之和为 $5+2+4+2+2+2=17$。

## 说明/提示

- 对于 $30\%$ 的数据，$1\le q\le10^5$，$type=0$。
- 对于另外 $70\%$ 的数据，$1\le q\le10^7$，$type=1$。

对于 $100\%$ 的数据，$1\le n\le10^5$，$-10^9\le a_i\le10^9$。

## 样例 #1

### 输入

```
5 5 0
5 2 4 1 3
1 5
1 3
2 4
3 5
2 5
```

### 输出

```
28
```

## 样例 #2

### 输入

```
6 5 1
1 1 4 5 1 4
19 19 8 10
```

### 输出

```
6
```

# 题解

## 作者：yijan (赞：17)

考虑一次查询，比如查询 $[l,r]$ 区间。

首先找出区间内最小值的位置，设为 $pos$。

考虑把询问的区间的子区间分成三种：

1. 跨过了 $pos$
2. 左右端点都在 $[l,pos-1]$
3. 左右端点都在 $[pos+1,r]$

考虑分别处理。对于第一种，明显贡献是 $(pos-l+1)(r-pos+1)$ 。

下面设 $[l,r][L,R]$ 表示左端点在 $[l,r]$ 内，右端点在 $[L,R]$ 内的所有区间的最小值的和。

我们考虑怎么求 $[l,r][l,r]$ 的值。我们把这个拆成：
$$
[l,n][l,n] - [r + 1,n][r + 1,n] - [l,r][r + 1,n]
$$
也就是左右端点都在 $[l,n]$ 减去左右都在 $[r+1,n]$ 再减去左端点在 $[l,r]$ 右端点在 $[r+1,n]$ 的贡献。

怎么求 $[l,n][l,n]$ 呢，考虑预处理出来。为了方便设 $f(i) = [i,n][i,n]$ ，于是可以发现
$$
f(i) = f(i + 1) + [i,i][i,n]
$$
再设 $F(i) = [i,i][i,n]$ 。考虑怎么递推出 $F$ 。对于每个位置 $i$ ，设 $r_i$ 为满足 $a_{r_i} < a_i$ 的最小值，也就是说 $a_i$ 小于 $[i,r_i-1]$ 的所有值。于是
$$
F_i = F_{r_i} + a_i(r_i-i)
$$
于是递推求出了 $F$ 也就求出了 $f$ 。

回到原来的问题，我们还需要求 $[l,r][r+1,n]$。这个东西看起来求不了。但是，对于第二种询问，我们要求的是 
$$
[l,pos-1][pos,n]
$$
由于 $a_{pos}$ 是 $[l,r]$ 的最小值，这个东西直接等于 $(pos-l)F_{pos}$。因为左端点的选择是 $[l,pos-1]$ 中任意选择，且每个区间都一定是 $pos$ 后面更小，所以就是 $F_{pos}$ 的 $pos-l$ 倍了。

$[pos+1,r]$ 呢？倒过来（后缀变前缀）一样整一遍即可。

实现上，求 $l_i,r_i$ 直接单调栈即可。复杂度瓶颈在 ST 表的 $O(n\log n) -O(1)$ ，用转01 RMQ 后整 线性的 ST 表也可以做到 $O(n)-O(1)$。

代码很好写+好调。。代码后面留了个 gen。

```cpp
#include "iostream"
#include "algorithm"
#include "cstring"
#include "cstdio"
#include "cmath"
#include "vector"
#include "map"
#include "set"
#include "queue"
using namespace std;
#define MAXN 1000006
//#define int long long
#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)
#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector<int>
#define all(x) (x).begin() , (x).end()
#define mem( a ) memset( a , 0 , sizeof a )
typedef long long ll;
int n , q;
int A[MAXN] , p[19][MAXN] , L[MAXN] , R[MAXN] , lg[MAXN];
ll f[MAXN] , F[MAXN] , g[MAXN] , G[MAXN];
int stk[MAXN] , top;

namespace gen{
	typedef unsigned long long ull;
	ull s,a,b,c,lastans=0;
	void in( ) { cin >> s >> a >> b >> c; }
	ull rand(){
		return s^=(a+b*lastans)%c;
	}
};

void solve() {
	int typ; cin >> n >> q >> typ;
	lg[0] = -1;
	rep( i , 1 , n ) scanf("%d",&A[i]) , p[0][i] = i , lg[i] = lg[i >> 1] + 1;
	rep( i , 1 , 18 ) for( int j = 1 ; j + ( 1 << i ) - 1 <= n ; ++ j ) 
		p[i][j] = ( A[p[i - 1][j]] < A[p[i - 1][j + ( 1 << i - 1 )]] ? p[i - 1][j] : p[i - 1][j + ( 1 << i - 1 )] );
	rep( i , 1 , n ) {
		while( top && A[stk[top]] > A[i] ) R[stk[top]] = i , -- top;
		stk[++ top] = i;
	}
	while( top ) R[stk[top]] = n + 1 , -- top;
	per( i , n , 1 ) {
		while( top && A[stk[top]] > A[i] ) L[stk[top]] = i , -- top;
		stk[++ top] = i;
	}
	while( top ) L[stk[top]] = 0 , -- top;
	per( i , n , 1 ) F[i] = F[R[i]] + A[i] * 1ll * ( R[i] - i ) , f[i] = f[i + 1] + F[i];
	rep( i , 1 , n ) G[i] = G[L[i]] + A[i] * 1ll * ( i - L[i] ) , g[i] = g[i - 1] + G[i];
	int l , r , pos , len;
	unsigned long long re = 0 , res = 0;
	if( !typ ) {
		while( q-- ) {
			scanf("%d%d",&l,&r);
			len = lg[r - l + 1];
			pos = ( A[p[len][l]] < A[p[len][r - ( 1 << len ) + 1]] ? p[len][l] : p[len][r - ( 1 << len ) + 1] );
			res = f[l] - f[pos] - ( pos - l ) * F[pos] + g[r] - g[pos] - ( r - pos ) * G[pos] + ( pos - l + 1 ) * 1ll * ( r - pos + 1 ) * A[pos];
			re ^= res;
		}
	} else {
		gen::in();
		while( q-- ) {
			l = gen::rand() % n + 1 , r = gen::rand() % n + 1;
			if( l > r ) swap( l , r );
			len = lg[r - l + 1];
			pos = ( A[p[len][l]] < A[p[len][r - ( 1 << len ) + 1]] ? p[len][l] : p[len][r - ( 1 << len ) + 1] );
			res = f[l] - f[pos] - ( pos - l ) * F[pos] + g[r] - g[pos] - ( r - pos ) * G[pos] + ( pos - l + 1 ) * 1ll * ( r - pos + 1 ) * A[pos];
			gen::lastans = res;
			re ^= res;
		}
	}
	cout << re << endl;
}

signed main() {
//    int T;cin >> T;while( T-- ) solve();
    solve();
}

/*
void solve() {
	srand( (long long) new char );
	n = 10 , m = 10;
	cout << n << ' ' << m << endl;
	rep( i , 1 , n ) printf("%d ",rand() % 2000000000 - 1000000000 + 1);
	puts("");
	rep( i , 1 , m ) {
		int l = rand() % n + 1 , r = rand() % n + 1;
		if( l > r ) swap( l , r );
		printf("%d %d\n",l,r);
	}
}
*/
```



---

## 作者：Nephren_Sakura (赞：10)

1. 首先不考虑区间询问，对每个位置算贡献。

2. 对于位置 $i$，单调栈维护左边与右边第一个小于 $a_i$ 的位置 $L_i$ 和 $R_i$。

3. 位置 $i$ 作为最小值的贡献：
- 左端点选择：$i-L_i$。
- 右端点选择：$R_i - i$。
- 总贡献：$(i-L_i) \times (R_i-i) \times a_i$。

4. 设状态 $dp_i$ 表示整个序列以第 $i$ 个数为结尾的最小值之和。
- $dp_i=dp_{L_i}+a_i \times (i-L_i)$。

5. 对于询问 $[l,r]$，利用 RMQ 维护区间最小值 $mini$ 及下标 $pos$。

- 包含 $pos$：$a_{pos}\times(pos-l+1)\times(r-pos+1)$。

- 子段在 $pos$ 左侧：$(\sum\limits_{i=l}^{pos}DP_i)-DP_{pos}\times(pos-l)$

- 子段在 $pos$ 右侧：$(\sum\limits_{i=pos}^{r}dp_i)-dp_{pos}\times(r-pos)$。

6. 前缀和预处理即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
namespace gen{
	typedef unsigned long long ull;
	ull s,a,b,c,lastans=0;
	ull rand(){
		return s^=(a+b*lastans)%c;
	}
};
int n,m,type;
int a[1000005];
int L[1000005],R[1000005];
int lg[1000005],mini[1000005][21],pos[1000005][21];
int dp[1000005],DP[1000005];
int sum[1000005],SUM[1000005];
stack<int> stk;
int qr(int lt,int rt){
	int len=lg[rt-lt+1];
	if(mini[lt][len]<mini[rt-(1<<len)+1][len])
		return pos[lt][len];
	return pos[rt-(1<<len)+1][len];
}
unsigned int help(int l,int r){
	if(l>r)
		return 0ll;
	if(l==r)
		return a[l];
	int pos=qr(l,r);
	unsigned int ans=a[pos]*(pos-l+1)*(r-pos+1);
	ans+=SUM[l]-SUM[pos];
	ans-=DP[pos]*(pos-l);
	ans+=sum[r]-sum[pos];
	ans-=dp[pos]*(r-pos);
	return ans;
}
unsigned int s=0;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	lg[0]=-1;
	for(int i=1; i<=1000000; i++)
		lg[i]=lg[i>>1]+1;
	cin>>n>>m>>type;
	for(int i=1; i<=n; i++)
		cin>>a[i],mini[i][0]=a[i],pos[i][0]=i;
	for(int j=1; j<=20; j++)
		for(int i=1; i+(1<<j)-1<=n; i++){
			if(mini[i][j-1]<mini[i+(1<<j-1)][j-1]){
				mini[i][j]=mini[i][j-1];
				pos[i][j]=pos[i][j-1];
			}
			else{
				mini[i][j]=mini[i+(1<<j-1)][j-1];
				pos[i][j]=pos[i+(1<<j-1)][j-1];
			}
		}
	for(int i=1; i<=n; i++){
		while(stk.empty()==false&&a[i]<a[stk.top()])
			stk.pop();
		if(stk.empty()==false)
			L[i]=stk.top();
		stk.push(i);
	}
	while(stk.empty()==false)
		stk.pop();
	for(int i=n; i>=1; i--){
		while(stk.empty()==false&&a[i]<a[stk.top()])
			stk.pop();
		if(stk.empty()==false)
			R[i]=stk.top();
		stk.push(i);
	}
	while(stk.empty()==false)
		stk.pop();
	for(int i=1; i<=n; i++)
		dp[i]=dp[L[i]]+a[i]*(i-L[i]);
	for(int i=n; i>=1; i--)
		DP[i]=DP[R[i]]+a[i]*(R[i]-i);
	for(int i=1; i<=n; i++)
		sum[i]=sum[i-1]+dp[i];
	for(int i=n; i>=1; i--)
		SUM[i]=SUM[i+1]+DP[i];
	if(type)
		cin>>gen::s>>gen::a>>gen::b>>gen::c;
	while(m--){
		int l,r;
		if(!type){
			cin>>l>>r;
			s^=help(l,r);
		}
		else{
			l=gen::rand()%n+1;
			r=gen::rand()%n+1;
			if(l>r) std::swap(l,r);
			gen::lastans=help(l,r);
			s^=gen::lastans;
		}
//		cout<<help(l,r)<<'\n';
	}
	cout<<s;
	return 0;
} 
```

---

## 作者：Alex_Wei (赞：6)

> #### *I. [P6604 [HNOI2016]序列 加强版](https://www.luogu.com.cn/problem/P6604)

> 摘自学习笔记 [简单树论](https://www.cnblogs.com/alex-wei/p/Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree.html) 笛卡尔树部分例题 I.

和 [P6503](https://www.luogu.com.cn/problem/P6503) 比较类似。我们设 $f_i$ 表示全局以 $i$ 结尾的子区间的最小值之和，令 $p_i$ 为下标在 $i$ 之前第一个比 $a_i$ 小的位置，显然有 $f_i=f_{p_i}+(i-p_i)a_i$：因为 $a_i$ 对 $p_i$ 以及 $p_i$ 以前的最小值没有影响（即 $[1,p_i]$ 与 $[1,i]$，$[2,p_i]$ 与 $[2,i]\cdots$ $[p_i,p_i]$ 与 $[p_i,i]$ 的最小值相同），所以可以直接由 $f_{p_i}$ 转移得来。而根据 $p_i$ 的定义，后面 $i-p_i$ 个子序列（即 $[p_i+1,i],[p_i+2,i]\cdots,[i,i]$）的最小值为 $a_i$。

注意到 $p_i$ 实际相当于 $i$ 在笛卡尔树上第一个向左走的父亲，求 $p_i$ 的过程十分类似构建笛卡尔树：**笛卡尔树上每个节点的祖先由左右两个单调栈构成**。

考虑对一个区间求答案：求出区间最小值的位置 $p$，那么左端在 $p$ 左边，右端在 $p$ 右边的子区间最小值为 $a_p$，故答案加上 $a_p\times (p-l+1)\times (r-p+1)$。此外，我们还需求出 $[l,p)$ 与 $(p,r]$ 的答案：考虑 $(p,r]$ 每个位置对答案的贡献都是 $f_r-f_p$，因为 $[i,p]$ 与 $[i,r]\ (1\leq i\leq p)$ 的最小值相同。前缀和优化可以做到 $\mathcal{O}(1)$ 回答每个询问。对于 $[l,p)$ 同理，我们只需预处理出 $g_i$ 表示全局以 $i$ 开头的子区间的最小值之和并类似处理即可。

复杂度瓶颈在于区间 RMQ，时间复杂度 $\mathcal{O}(n\log n+q)$。

```cpp
const int N = 1e5 + 5;
const int K = 17;

namespace gen {
	ull s, a, b, c, las = 0;
	ull rand() {return s ^= (a + b * las) % c;}
}

int n, q, type, stc[N], *top = stc, a[N], lg[N], pre[N], suf[N];
ll mi[K][N], fp[N], gp[N], fs[N], gs[N]; ull res;
int cmp(int x, int y) {return a[x] < a[y] ? x : y;}
int RMQ(int l, int r) {int d = lg[r - l + 1]; return cmp(mi[d][l], mi[d][r - (1 << d) + 1]);}

int main(){
	cin >> n >> q >> type;
	for(int i = 1; i <= n; i++) a[i] = read(), mi[0][i] = i;
	for(int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for(int i = 1; i <= lg[n]; i++)
		for(int j = 1; j + (1 << i) - 1 <= n; j++)
			mi[i][j] = cmp(mi[i - 1][j], mi[i - 1][j + (1 << i - 1)]);
	for(int i = 1; i <= n; i++) { 
		while(*top && a[*top] >= a[i]) suf[*top--] = i; // 可以类比求笛卡尔树的过程: ls[i] = *top, 因此 suf[*top] = i;
		pre[i] = *top, *++top = i; // 同理, rs[*top] = i, 所以 pre[i] = *top: 笛卡尔树上每个节点的祖先是由两个单调栈构成的!
	}
	for(int i = 1; i <= n; i++)
		fp[i] = fp[pre[i]] + 1ll * a[i] * (i - pre[i]), gp[i] = gp[i - 1] + fp[i];
	for(int i = n; i; i--)
		fs[i] = fs[suf[i]] + 1ll * a[i] * (suf[i] - i), gs[i] = gs[i + 1] + fs[i];
	if(type) gen :: s = read(), gen :: a = read(), gen :: b = read(), gen :: c = read();
	for(int i = 1, l, r; i <= q; i++) {
		if(type == 0) l = read(), r = read();
		else {
			l = gen :: rand() % n + 1;
			r = gen :: rand() % n + 1;
			if(l > r) swap(l, r);
		}
		ll p = RMQ(l, r), ans;
		ans = a[p] * (r - p + 1) * (p - l + 1);
		ans += gp[r] - gp[p] - fp[p] * (r - p);
		ans += gs[l] - gs[p] - fs[p] * (p - l);
		res ^= gen :: las = ans;
	}
	cout << res << endl;
    return flush(), 0;
}
```

---

## 作者：FZzzz (赞：3)

水篇双倍经验题解。

这是一个 $O(n\log n)+O(1)+O(n\log n)$ 的在线做法。

猫树，对于某个节点，先预处理出一个点到中点的答案。这可以使用单调栈求出。那么我们需要计算跨中点的贡献。

预处理出每个点到中点的最小值，并处理出这个最小值能延伸到右边哪里。这可以对左右两个区间进行一次归并得到。

贡献分为两种：最小值在左边的，我们在左端点处计算贡献；最小值在右边的，我们在右端点处计算贡献。

若查询左端点到中点的最小值不能延伸到右端点，则左边所有点都有到其延伸的右端点的完整的贡献。对于右半部分，左端点延伸的最远点左边的所有点都有完整的贡献，而右边到右端点的所有点都只有到左端点的贡献。这些东西都是可以拆开然后预处理出来的。

另一种情况的话同理可得。

代码实现上，这个到中点的前缀和很烦人，所以我分别保存的左边的答案和右边的答案。

另外这个做法其实是和那个 rmq 的做法本质相同，那个做法基本上相当于把这个做法搬到笛卡尔树上，然后就少了一堆特判……

放一下 std：
```cpp
#include<algorithm>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5;
int n,q,a[maxn*2];
bool type;
typedef long long ll;
int pos[maxn*2];
ll s1[25][maxn*2],s2l[25][maxn*2],s2r[25][maxn*2];
int mn[25][maxn*2],pp[25][maxn*2];
ll s3l[25][maxn*2],s3r[25][maxn*2];
ll s4l[25][maxn*2],s4r[25][maxn*2];
int st[maxn],top;
void build(int o,int l,int r,int d){
	if(l==r){
		pos[r]=o;
		return;
	}
	int mid=l+(r-l)/2;
	build(o*2,l,mid,d+1);
	build(o*2+1,mid+1,r,d+1);
	ll res=0;
	st[top=0]=mid+1;
	for(int i=mid;i>=l;i--){
		while(top&&a[i]<a[st[top]]){
			res-=1ll*a[st[top]]*(st[top-1]-st[top]);
			top--;
		}
		st[++top]=i;
		res+=1ll*a[i]*(st[top-1]-i);
		s1[d][i]=i==mid?res:s1[d][i+1]+res;
		mn[d][i]=a[st[1]];
	}
	res=0;
	st[top=0]=mid;
	for(int i=mid+1;i<=r;i++){
		while(top&&a[i]<a[st[top]]){
			res-=1ll*a[st[top]]*(st[top]-st[top-1]);
			top--;
		}
		st[++top]=i;
		res+=1ll*a[i]*(i-st[top-1]);
		s1[d][i]=i==mid+1?res:s1[d][i-1]+res;
		mn[d][i]=a[st[1]];
	}
	int cur=r;
	for(int i=l;i<=mid;i++){
		while(cur>mid&&mn[d][cur]<mn[d][i]) pp[d][cur--]=i;
		pp[d][i]=cur;
	}
	for(int i=mid+1;i<=cur;i++) pp[d][i]=mid+1;
	for(int i=mid;i>=l;i--){
		s2l[d][i]=s2l[d][i+1]+1ll*mn[d][i]*(pp[d][i]-mid);
		s3l[d][i]=s3l[d][i+1]+1ll*mn[d][i]*mid;
		s4l[d][i]=s4l[d][i+1]+mn[d][i];
	}
	for(int i=mid+1;i<=r;i++){
		s2r[d][i]=s2r[d][i-1]+1ll*mn[d][i]*(mid+1-pp[d][i]);
		s3r[d][i]=s3r[d][i-1]+1ll*mn[d][i]*(mid+1);
		s4r[d][i]=s4r[d][i-1]+mn[d][i];
	}
}
int lg[maxn*4];
namespace gen{
	typedef unsigned long long ull;
	ull s,a,b,c,lastans=0;
	ull rand(){
		return s^=(a+b*lastans)%c;
	}
};
using gen::ull;
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	q=readint();
	type=readint();
	for(int i=1;i<=n;i++) a[i]=readint();
	int len=1;
	while(len<n) len*=2;
	build(1,1,len,1);
	for(int i=2;i<=n*4;i++) lg[i]=lg[i/2]+1;
	if(type){
		gen::s=readint();
		gen::a=readint();
		gen::b=readint();
		gen::c=readint();
	}
	ull out=0;
	while(q--){
		int l,r;
		if(type){
			l=gen::rand()%n+1;
			r=gen::rand()%n+1;
			if(l>r) std::swap(l,r);
		}
		else{
			l=readint();
			r=readint();
		}
		if(l==r){
			out^=gen::lastans=a[r];
			continue;
		}
		int k=lg[pos[r]]-lg[pos[l]^pos[r]];
		ll ans=s1[k][l]+s1[k][r];
		if(pp[k][l]<r){
			ans+=s2l[k][l]+s2r[k][pp[k][l]];
			ans+=s3r[k][r]-s3r[k][pp[k][l]];
			ans-=(s4r[k][r]-s4r[k][pp[k][l]])*l;
		}
		else{
			ans+=s2r[k][r]+s2l[k][pp[k][r]];
			ans-=s3l[k][l]-s3l[k][pp[k][r]];
			ans+=(s4l[k][l]-s4l[k][pp[k][r]])*r;
		}
		out^=gen::lastans=ans;
	}
	printf("%llu\n",out);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：2)

算是一个思维上的漏洞了。~~而且不想打 `\operator` 就算了吧~~

令 $st(l,r,L,R)$ 为左端点在区间 $[l,r]$，右端点在区间 $[L,R]$ 的答案。那么原问题的形式是多次询问 $st(l,r,l,r)$。

考虑将原问题用另一种形式表示。期望的做法是将其勾结到一个可以预处理的，和边界凑边的形式。

有一个比较好想到的构造方法是，$st(l,r,l,r) = st(1,r,1,r) - st(1,l-1,l,r) - st(1,l-1,1,l-1)$。理解方式是去掉含有左端点在 $[1,l-1]$ 内，右端点在 $[l,r]$ 内的与两端点均在 $[1,l-1]$ 内的贡献就是两端点均在 $[l,r]$ 的贡献。

有几个特殊的形式比较让人在意，也就是，出现了两次 $st(1,x,1,x)$ 的形式（$x$ 分别是 $l-1$ 和 $r$）。

那么令 $F(x) = st(1,x,1,x)$。

发现这个东西仍然是一个不好计算的形式，将 $F(x)$ 中的 $x$ 拆出来，可得：

$$
\begin{aligned}
F(x) &= F(x-1) + st(x,x,x,x) + st(1,x-1,x,x) \\
&=F(x-1) + st(1,x,x,x)
\end{aligned}
$$

发现这是一个类似于前缀和的形式，需要考虑 $st(1,x,x,x)$ 这个看起来就很好看的东西怎么计算。记其为 $f(x)$，那么 $F(x) = \sum_{i=1}^x f(x)$。

注意到这是一个前缀和的形式，不难想到 $f(x)$ 应由之前的某一个状态转移。那么直接考虑 $a_x$ 的贡献。定义 $lst_x$ 为，在 $x$ 前的第一个比 $a_x$ 小的数的位置（不存在则为 $0$）。做这个事情的是考虑了 $a_x$ 的作用范围的结果。那么 $f(x) = f(lst_x) + a_x(x-lst_x)$。

于是处理出 $f,F$。用同样的方法处理出 $G(x) = st(x,n,x,n),g(x) = st(x,x,x,n)$。需要求出另一个辅助数组 $nxt_x$ 表示在 $x$ 后的第一个小于 $a_x$ 的数的位置。

于是要求 $lst_x$ 和 $nxt_x$。这是一个经典问题，直接用单调栈解决问题。（单调栈模板）


遗漏了一个东西 $st(1,l-1,l,r)$。这个东西比较一般没有好的方法解决，放在下面考虑。

反正让我想不到的是，询问 $[l,r]$ 的答案，令 $pos = \arg \min_{i=l}^r$，考虑算三个东西：

1. 两个端点都在 $[l,pos-1]$ 内的答案；   
2. 两个端点都在 $[pos+1,r]$ 内的答案；   
3. 包含 $pos$ 的区间的答案。

毕竟一般来说这样做的话都会递归下去通过数据结构优化快速处理嘛 |=.=)

从简单的入手，第 3 部分的答案显然是 $(pos-l+1)(r-pos+1)pos$。

然后考虑前两个的答案，注意到两部分来源和形式大致相同，故只考虑第一个。回到上面的内容，这个一般形式中剩下一个 $st(1,l-1,l,r)$。需要去除掉无用的信息。因为 $a_{pos}$ 是 $[l,r]$ 内的最小值，故最小值一定与 $[l,pos-1]$ 无关（要取也至少取到 $a_{pos}$），所以得到 $(pos-l)st(pos,pos)(pos,n) = st(l,pos-1)(pos,n)$。

最后要处理的是 $[l,r]$ 内最小值的位置。可以用 $st$ 表解决问题，也可以用 $O(n) - O(1)$ rmq 来踩众仙。总之下面的代码时间复杂度是 $O(n \log n + q)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
struct Generator{
	ull s,a,b,c,lastans;
	Generator(){lastans=0;}
	void getVal(){s=read(),a=read(),b=read(),c=read();}
	ull rand(){return s^=(a+b*lastans)%c;}
}gen;
int Arg(int x,int y,int a,int b){return x<y?a:b;}
int n,q,type,a[100005],stk[100005],top,lst[100005],nxt[100005],args[17][100005],lgs[100005];
ull f[100005],g[100005],sumf[100005],sumg[100005];
int query(int l,int r)
{
	int d=lgs[r-l+1];
	return Arg(a[args[d][l]],a[args[d][r-(1<<d)+1]],args[d][l],args[d][r-(1<<d)+1]);
}
int main(){
	n=read(),q=read(),type=read();
	for(int i=1;i<=n;++i)	a[i]=read(),nxt[i]=n+1;
	for(int i=1;i<=n;++i)
	{
		while(top && a[stk[top]]>a[i])	nxt[stk[top--]]=i;
		stk[++top]=i;
	}
	top=0;
	for(int i=n;i;--i)
	{
		while(top && a[stk[top]]>a[i])	lst[stk[top--]]=i;
		stk[++top]=i;
	}
	for(int i=1;i<=n;++i)	f[i]=f[lst[i]]+ull(a[i])*ull(i-lst[i]);
	for(int i=n;i;--i)	g[i]=g[nxt[i]]+ull(a[i])*ull(nxt[i]-i);
	for(int i=1;i<=n;++i)	sumf[i]=sumf[i-1]+f[i];
	for(int i=n;i;--i)	sumg[i]=sumg[i+1]+g[i];
	for(int i=2;i<=n;++i)	lgs[i]=lgs[i>>1]+1;
	for(int i=1;i<=n;++i)	args[0][i]=i;
	for(int j=1;j<=16;++j)	for(int i=1;i+(1<<j)-1<=n;++i)	args[j][i]=Arg(a[args[j-1][i]],a[args[j-1][i+(1<<(j-1))]],args[j-1][i],args[j-1][i+(1<<(j-1))]);
	ull ans=0;
	if(!type)
	{
		while(q-->0)
		{
			int l=read(),r=read(),pos=query(l,r);
//			printf("%d %d %d\n",l,r,pos);
			ans^=(sumg[l]-sumg[pos]-ull(pos-l)*g[pos]+sumf[r]-sumf[pos]-ull(r-pos)*f[pos]+ull(pos-l+1)*ull(r-pos+1)*ull(a[pos]));
		}
	}
	else
	{
		gen.getVal();
		while(q-->0)
		{
			int l,r,pos;
			l=gen.rand()%n+1;
			r=gen.rand()%n+1;
			if(l>r)	swap(l,r);
			pos=query(l,r);
			ans^=(gen.lastans=sumg[l]-sumg[pos]-ull(pos-l)*g[pos]+sumf[r]-sumf[pos]-ull(r-pos)*f[pos]+ull(pos-l+1)*ull(r-pos+1)*ull(a[pos]));
		}
	}
	printf("%llu",ans);
	return 0;
}
```

---

## 作者：xfrvq (赞：1)

原题题解满了，[重投](https://www.luogu.com.cn/article/v16uda12) 至加强版。

这是一个线性做法，并附赠了一个易实现的 $O(n)-O(1)$ RMQ。

---

首先看到静态区间询问可以先考虑莫队。

考虑如何从 $[l,r]$ 推到 $[l,r + 1]$。

要增加的贡献其实就是以 $l,\cdots,r+1$ 为左端点，$r+1$ 为右端点的区间的答案之和。

我们记 $[l,r+1]$ 最小值为 $a_p$。然后对每个位置 $i$ 求出在它左边第一个小于它的位置 $pre_i$。

根据 $pre_i$ 的定义：

+ 设 $p_0=pre_i$，$(p_0,i]$ 的最小值是 $a_i$
+ 设 $p_1=pre_{p_0}$，$(p_1,p_0]$ 最小值是 $a_{p_0}$。
+ 以此类推 $\cdots$

如果把这个迭代的开始位置从 $i$ 改为 $r+1$，那么最后会迭代到 $p$ 而停止。原因是 $p$ 是 $[l,r+1]$ 最小值，$[l,p)$ 中没有比 $a_p$ 更小的。

我们把答案分成两部分，一部分是 $[l,p]$，这部分的答案都是 $a_p$，一部分是 $(p,r]$，这部分可以在刚刚的迭代中计算。

我们定义 $f_i$ 为从 $i$ 开始迭代到 $1$ 的答案。所以 $r+1$ 迭代到 $p$ 的答案，就会是 $f_{r+1}-f_p$（变成了一个 $\mathcal O(1)$ 的式子）。

然后思考 $f_i$ 怎么预处理。

+ 设 $p_0=pre_i$，$(p_0,i]$ 的最小值是 $a_i$（这段的答案是 $a_i\times(i-p_0)$）
+ 设 $p_1=pre_{p_0}$，$(p_1,p_0]$ 最小值是 $a_{p_0}$（这段的答案是 $a_{p_0}\times(p_0-p_1)$）
+ 以此类推 $\cdots$

推往左是相反的，比较类似。

---

但是这个题这样做是不够的，我们考虑做的更快。

对于一个询问 $[l,r]$，我们记录下其最小值 $a_p$。这时有

+ $\forall i\in[l,p)$，$pre_i\notin[l,r]$
+ $\forall i\in(p,r]$，$suf_i\notin[l,r]$

我们考虑 $(p,r]$ 部分计算。

+ $\displaystyle\sum_{i=p+1}^r\min(a_i,\cdots,a_r)=f_r-f_p$
+ $\displaystyle\sum_{i=p+1}^{r-1}\min(a_i,\cdots,a_{r-1})=f_{r-1}-f_p$
+ $\cdots$

答案就会等于 $\displaystyle\left(\sum_{i=p+1}^r f_i\right)-f_p\times(r-p)$

这个可以维护 $f_i$ 的前缀和然后 $O(1)$ 算。

$[l,p)$ 部分是相反的，也是类似。

---

现在整个问题的复杂度瓶颈就在于找出 $p$ 了。

这是一个 $\tt RMQ$ 问题，使用 [这个算法](https://www.luogu.com.cn/blog/368107/another-On-O1-RMQ-algorithm) 做到 $O(n)-O(1)$ 。

于是我们在线性时间内完成了这个问题。

```cpp
#include<bits/stdc++.h>
using namespace std;

#ifdef ONLINE_JUDGE
static char buf[1000000],*p1=buf,*p2=buf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#endif

inline int read(){
    register int x = 0,f = 1;
    register char c = getchar();
    for(;c < '0' || c > '9';c = getchar())
    	if(c == '-') f = -1;
    for(;c >= '0' && c <= '9';c = getchar())
        x = x * 10 + (c ^ '0');
    return x * f;
}

typedef long long ll;

const int N = 1e5 + 5;

int n,m,k,prv[N],nxt[N],stk[N],tp;
ll a[N],fl[N],fr[N],sl[N],sr[N];

namespace RMQ{
	const int Blk = 28,SIZ = N;
	
	int bl[N],bg[SIZ],ed[SIZ];
	int pre[N],suf[N];
	int st[17][SIZ];
	unsigned val[N];
	
	int cmp(int x,int y){ return a[x] < a[y] ? x : y; }
	
	void init(){
		for(int i = 1;i <= n;++i) pre[i] = suf[i] = i;
		int C = (n - 1) / Blk + 1;
		for(int i = 1;i <= C;++i){
			bg[i] = ed[i - 1] + 1;
			ed[i] = i != C ? bg[i] + Blk - 1 : n;
			for(int j = bg[i];j <= ed[i];++j)
				st[0][bl[j] = i] = cmp(st[0][i],j);
			for(int j = bg[i] + 1;j <= ed[i];++j)
				pre[j] = cmp(pre[j],pre[j - 1]);
			for(int j = ed[i] - 1;j >= bg[i];--j)
				suf[j] = cmp(suf[j],suf[j + 1]);
		}
		for(int j = 1;(1 << j) <= C;++j)
			for(int i = 1;i + (1 << j) - 1 <= C;++i)
				st[j][i] = cmp(st[j - 1][i],st[j - 1][i + (1 << (j - 1))]);
		for(int i = 1;i <= C;++i){
			for(int j = bg[i],tp = 0;j <= ed[i];++j){
				if(j != bg[i]) val[j] = val[j - 1];
				while(tp && a[j] <= a[stk[tp] + bg[i] - 1]) val[j] ^= 1u << stk[tp--];
				val[j] ^= 1u << (stk[++tp] = j - bg[i] + 1); 
			}
		}
	}
	
	int qry(int l,int r){
		if(bl[l] == bl[r]) return l + __builtin_ctz(val[r] >> (l - bg[bl[l]] + 1));
		if(bl[l] + 1 == bl[r]) return cmp(suf[l],pre[r]);
		int i = __lg(bl[r] - bl[l] - 1);
		return cmp(cmp(suf[l],pre[r]),cmp(st[i][bl[l] + 1],st[i][bl[r] - (1 << i)]));
	}
}

typedef unsigned long long ull;
ull s,A,B,C,lastans,ans;
ull rnd(){ return s ^= (A + B * lastans) % C;}

int main(){
	n = read(),m = read(),k = read();
	for(int i = 1;i <= n;++i) a[i] = read();
	if(k) s = read(),A = read(),B = read(),C = read();
	a[0] = a[n + 1] = 2e9;
	RMQ::init();
	for(int i = 1;i <= n + 1;++i){
		while(tp && a[stk[tp]] > a[i]) nxt[stk[tp--]] = i;
		prv[i] = stk[tp]; stk[++tp] = i;
	}
	for(int i = 1;i <= n;++i)
		sr[i] = sr[i - 1] + (fr[i] = a[i] * (i - prv[i]) + fr[prv[i]]);
	for(int i = n;i >= 1;--i)
		sl[i] = sl[i + 1] + (fl[i] = a[i] * (nxt[i] - i) + fl[nxt[i]]);
	for(int l,r,p;m--;){
		if(!k) l = read(),r = read();
		else {
			l = rnd() % n + 1,r = rnd() % n + 1;
			if(l > r) swap(l,r);
		}
		p = RMQ::qry(l,r);
		ll Vr = sr[r] - sr[p] - fr[p] * (r - p);
		ll Vl = sl[l] - sl[p] - fl[p] * (p - l);
		lastans = ((a[p] * (p - l + 1) * (r - p + 1) + Vr + Vl));
		ans ^= lastans;
	}
	return printf("%llu\n",ans),0;
}
```

---

## 作者：hegm (赞：1)

### [P6604 [HNOI2016] 序列 加强版](https://www.luogu.com.cn/problem/P6604)

求出区间最小值，位置为 $m$ 那么把询问的合法子区间分为三种：

1. 左端点在 $[l,m]$，右端点在 $[m,r]$。
2. 左端点在 $[l,m)$，右端点在 $[l,m)$。
2. 左端点在 $(m,r]$，右端点在 $(m,r]$。

一共三种情况，容易发现，第一种情况最好算，因为一定会经过最小值 $a_m$ 所以这些区间的总贡献是 $(m-l+1)\times(r-m+1)\times a_m$。

类比的考虑 $2,3$ 部分。

设 $f_i$ 表示右端点是 $i$，左端点是 $[1,i]$ 范围的子区间权值和。

那么考虑 $\sum\limits_{i=m+1}^{i\le r}f_i$ 这玩意包含了左端点在 $[1,r]$ 右端点在 $(m,r]$。但是这样的话会存在左端点在 $[1,m)$ 右端点在 $(m,r]$ 的不合法区间，然后你会惊讶的发现，这些区间的权值恰好为 $f_m$，因为对于任何一个左端点在 $(m,r]$ 右端点在 $[1,m)$ 的子区间，一定会经过 $a_m$ 又因为 $a_m$ 是 $[l,r]$ 的最小值，所以任何一个 $[i,m]$ 区间和 $[i,j](j\in (m,r])$ 区间来说，最小值一定是相同的。

然后对于每个 $i$ 会恰好剩下左右端点都在 $(m,r]$ 的子区间。

对于 $[l,m)$ 来说，操作和 $(m,r]$ 效果是一样的，只不过是反过来罢了。

### CODE
```cpp
#include<bits/stdc++.h>
#define N 1000005
#define int long long
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,q,a[N],st[25][N],f[N],g[N],tp,awa;
int get(int l,int r)
{
	int len=__lg(r-l+1);
	int x=st[len][l],y=st[len][r-(1<<len)+1];
	if(a[x]<a[y])return x;
	return y;
}
stack<int> t;
namespace gen{
	typedef unsigned long long ull;
	ull s,a,b,c,lastans=0;
	ull rand(){
		return s^=(a+b*lastans)%c;
	}
};
signed main()
{
	n=read();q=read();tp=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		st[0][i]=i;
	}
	if(tp)
	{
		gen::s=read();
		gen::a=read();
		gen::b=read();
		gen::c=read();
	}
	for(int i=1;i<=19;i++)
	{
		for(int j=1,x,y;j<=n;j++)
		{
			x=st[i-1][j];
			y=st[i-1][j+(1<<(i-1))];
			if(a[x]<a[y])st[i][j]=x;
			else st[i][j]=y;
		}
	}
	a[0]=-1000000001;
	a[n+1]=-1000000001;
	t.push(0);
	for(int i=1;i<=n;i++)
	{
		while(a[t.top()]>a[i])t.pop();
		f[i]=f[t.top()]+(i-t.top())*a[i];
		t.push(i);
	}
	while(t.size())t.pop();
	t.push(n+1);
	for(int i=n;i>=1;i--)
	{
		while(a[t.top()]>a[i])t.pop();
		g[i]=g[t.top()]+(t.top()-i)*a[i];
		t.push(i);
	}
	for(int i=1;i<=n;i++)f[i]=f[i-1]+f[i];
	for(int i=n;i>=1;i--)g[i]=g[i+1]+g[i];
	int l,r;
	while(q--)
	{
		if(tp)
		{
			l=gen::rand()%n+1;
			r=gen::rand()%n+1;
			if(l>r)swap(l,r);
		}
		else l=read(),r=read();
		int s=get(l,r),ans=0;
		ans=(s-l+1)*(r-s+1)*a[s];
		ans+=f[r]-f[s]-(f[s]-f[s-1])*(r-s);
		ans+=g[l]-g[s]-(g[s]-g[s+1])*(s-l);
		awa^=ans;
		gen::lastans=ans;
	}
	cout<<awa<<"\n";
	return 0;
}
```

---

## 作者：panyf (赞：1)

[猫树学习笔记](https://www.luogu.com.cn/blog/221955/mao-shu)

不需要单调栈，用双指针就行。

存储结点信息的结构体：

```cpp
struct T{ll la,ra,s,g;int m,l,r;}s[19][N];
```
其中 $l,r$ 分别表示所在区间左右端点；

$la,ra$ 分别表示 $[l,x]$ 和 $[x,r]$ 的答案；

$m$ 表示 $x$ 到中点（这里对于左区间的 $x$，中点表示 $mid$，否则表示 $mid+1$）的 $a$ 的最小值；

$s$ 表示 $x$ 到中点的所有点的 $m$ 之和。

$g$ 表示一个端点为 $x$ 到中点的所有点，另一个端点为区间另一侧的所有点，所有这样的子段的最小值之和。

$l,r,m,s$ 可以直接求出。

左区间的 $la$ 和右区间的 $ra$ 直接继承下一层。

$g$ 可以双指针求出，具体做法：假设当前在求左区间的点 $x$ 的 $g$，将右区间分为两段，一段大于 $m_x$，另一段小于等于 $m_x$。两段分别求答案。两段的分界点用双指针维护。

左区间的 $ra$ 和右区间的 $la$ 用 $g$ 和下一层的 $la,ra$ 求出。

有了这些信息就可以 $O(1)$ 回答询问。

具体实现见代码。

定位询问区间的部分和 immortalCO 的博客略有不同（没有补全 $2^k$，但需要额外记录叶子结点编号），具体见[猫树学习笔记](https://www.luogu.com.cn/blog/221955/mao-shu)
。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=1e5+3;
int a[N],p[N],lg[N*4];
struct T{ll la,ra,s,g;int m,l,r;}s[19][N];
void wk(int d,int k,int l,int r){//d是当前深度，k是区间编号
	T*f=s[d],*g=s[d+1];
	int m=l+r>>1,i,t;
	for(i=l;i<=r;++i)f[i].l=l,f[i].r=r;
	if(l==r)return f[l].la=f[l].ra=a[l],void(p[l]=k);//记录叶子结点区间编号
	ll w=0,u=0;
	wk(d+1,k*2,l,m),wk(d+1,k*2+1,m+1,r);
	for(g[m].m=g[m].s=a[m],i=m-1;f[i+1].la=g[i+1].la,i>=l;--i)g[i].s=g[i+1].s+(g[i].m=min(g[i+1].m,a[i]));
	for(g[m+1].m=g[m+1].s=a[m+1],i=m+2;f[i-1].ra=g[i-1].ra,i<=r;++i)g[i].s=g[i-1].s+(g[i].m=min(g[i-1].m,a[i]));
	for(i=r,t=m+1;i>m;--i)w+=g[i].m;
	for(;i>=l;--i){//双指针部分
		while(t<=r&&a[i]<a[t])w-=g[t++].m;
		u=g[i].g=u+w+g[i].m*1ll*(t-m-1),f[i].ra=g[i].ra+g[r].la+u;
	}
	for(i=l,t=m,u=w=0;i<=m;++i)w+=g[i].m;
	for(;i<=r;++i){
		while(t>=l&&a[i]<a[t])w-=g[t--].m;
		u=g[i].g=u+w+g[i].m*1ll*(m-t),f[i].la=g[i].la+g[l].ra+u;
	}
}
using ull=unsigned long long;
ull S,A,B,C,l;
ull rd(){return S^=(A+B*l)%C;}
int main(){
	int n,q,o,i,j,x,y;
	ull w=0;
	T*g;
	for(i=1;i<N*4;++i)lg[i]=lg[i>>1]+1;//预处理lg表示log2(x)+1下取整
	for(i=1,scanf("%d%d%d",&n,&q,&o);i<=n;++i)scanf("%d",a+i);
	if(o)cin>>S>>A>>B>>C;
	for(wk(0,1,1,n);q--;){
		if(o){
			x=rd()%n+1,y=rd()%n+1;
			if(x>y)swap(x,y);
		}else scanf("%d%d",&x,&y);
		if(x==y)w^=(l=(ull)a[x]);else{
			if(i=p[x],j=p[y],i<j)swap(i,j);
			i>>=lg[i]-lg[j],i=lg[i>>lg[i^j]],g=s[i];
			w^=(l=g[x].ra+g[y].la+(g[x].m<g[y].m?g[y].g-(y-g[x].r)*(g[g[x].l].s-g[x].s):g[x].g-(g[y].l-x)*(g[g[y].r].s-g[y].s)));
		}
	}
	cout<<w;
	return 0;
}
```


---

## 作者：Phartial (赞：0)

被思维惯式打爆了。

记 $\displaystyle f([l_1,r_1],[l_2,r_2])=\sum_{i=l_1}^{r_1}\sum_{j=l_2}^{r_2}\min a[i:j]$，我们要求的就是 $f([l,r],[l,r])$。

将 $f([l,r],[l,r])$ 拆成 $f([1,r],[1,r])-f([1,l-1],[1,l-1])-f([1,l-1],[l,r])$。简记 $g(i)=f([1,i],[1,i])$，有 $g(i)=g(i-1)+f([1,i],[i,i])$。而 $h(i)=f([1,i],[i,i])$ 是好求的，记 $p_i$ 表示 $i$ 之前最大的 $j$ 满足 $a_j<a_i$，则 $h(i)=f([1,p_i],[i,i])+f([p_i+1,i],[i,i])=h(p_i)+(i-p_i)a_i$。

而 $f([1,l-1],[l,r])$ 实际上是难求的，而这里有一个很妙的思路：我们尝试通过转化原先的询问，将欲求的 $f([1,l-1],[l,r])$ 中的 $l$ 与 $r$ 之间建立联系，并尝试从中得到一些优良性质。

对于询问 $[l,r]$，考虑其区间最小值 $a_k$，则 $f([l,r],[l,r])=f([l,k],[k,r])+f([l,k-1],[l,k-1])+f([k+1,r],[k+1,r])$。显然 $f([l,k],[k,r])=(k-l+1)(r-k+1)a_k$，而对于 $f([k+1,r],[k+1,r])$，我们欲求的就变成了 $f([1,k],[k+1,r])$，这就有很好的性质了！因为 $a_k=\min a[k:r]$，所以 $a[k+1:r]$ 中的数不会产生贡献，于是有 $f([1,k],[k+1,r])=(r-k)h(k)$。对于 $f([l,k-1],[l,k-1])$，将序列反过来算一遍即可。

$p_i$ 可以使用单调栈简单求出。时间复杂度 $\Theta(n\log n)$，瓶颈在朴素 ST 表求区间最小值。

代码：https://www.luogu.com.cn/paste/qm4vljpy.

---

## 作者：StayAlone (赞：0)

好厉害的题。

用 $[l, r][x, y]$ 表示左端点在 $[l, r]$，右端点在 $[x, y]$ 的答案和。

考虑先找到区间最小值的位置 $p$，答案分为三类：

- 跨越位置 $p$
- $[l, p-1][l, p-1]$
- $[p+1,r][p+1,r]$

第一类很容易。第二类和第三类是对称的。

考虑第二类，使用差分。

$[l, p-1][l, p-1] = [l, n][l, n]-[p, n][p, n]-[l,p-1][p, n]$。

于是想要预处理 $f_i=[i,n][i, n]$。

显然 $f_i=f_{i+1}+[i, i][i, n]$。

设 $F_i=[i, i][i, n]$，考虑 $i$ 右边第一个小于 $a_i$ 的位置 $nxt$，则对于 $j\geq nxt$，区间 $[i, j]$ 的最小值显然等于区间 $[nxt, j]$ 的最小值；而对于 $j<nxt$，区间 $[i, j]$ 的最小值就是 $a_i$。故有 $F_i=F_{nxt}+a_i(nxt-i)$。

再考虑 $[l, p-1][p, n]$ 的答案。由于 $p$ 是区间最小值，对于 $j\in[l, p)$，$[j, j][p, n]=[p, p][p, n]=F_p$，所以答案就是 $F_p\times (p-l)$。

瓶颈在于区间最值的预处理，ST 表即可做到 $\mathcal O(n\log n+q)$。

[AC record](https://www.luogu.com.cn/record/214742718)

```cpp
int n, q, a[MAXN], mi[20][MAXN], typ; vector <int> st;
ull f[MAXN], F[MAXN], g[MAXN], G[MAXN], sum;

il int comb(int x, int y) {
    return a[x] < a[y] ? x : y;
}

il int query(int l, int r) {
    int k = __lg(r - l + 1);
    return comb(mi[k][l], mi[k][r - (1 << k) + 1]);
}

ull s, _a, b, c, lstans;
ull get() {
    return s ^= (_a + b * lstans) % c;
}

int main() {
    read(n, q, typ); rer(i, 1, n, a), mi[0][i] = i;
    rep1(i, 1, 16) rep1(j, 1, n - (1 << i - 1)) mi[i][j] = comb(mi[i - 1][j], mi[i - 1][j + (1 << i - 1)]);
    st.eb(n + 1);
    rep2(i, n, 1) {
        while (st.size() && a[st.back()] > a[i]) st.pop_back();
        int nxt = st.back(); st.eb(i);
        f[i] = f[i + 1] + (F[i] = F[nxt] + ull(nxt - i) * a[i]);
    } st.clear(); st.eb(0);
    rep1(i, 1, n) {
        while (st.size() && a[st.back()] > a[i]) st.pop_back();
        int lst = st.back(); st.eb(i);
        g[i] = g[i - 1] + (G[i] = G[lst] + ull(i - lst) * a[i]);
    }
    if (typ == 0) {
        int l, r; while (q--) {
            read(l, r); int p = query(l, r);
            ll ans = a[p] * ull(p - l + 1) * (r - p + 1);
            ans += f[l] - f[p] - F[p] * (p - l);
            ans += g[r] - g[p] - G[p] * (r - p);
            sum ^= ans;
        }
    } else {
        read(s, _a, b, c); int l, r;
        while (q--) {
            l = get() % n + 1, r = get() % n + 1;
            if (l > r) swap(l, r);
            int p = query(l, r);
            lstans = a[p] * ull(p - l + 1) * (r - p + 1);
            lstans += f[l] - f[p] - F[p] * (p - l);
            lstans += g[r] - g[p] - G[p] * (r - p);
            sum ^= lstans;
        }
    } cout << sum << endl;
    return 0;
}
```

---

## 作者：Missa (赞：0)

找到区间最小值的位置 $p$，跨越 $p$ 的贡献一定是 $a_p$，则需考虑 $[l, p)$ 与 $(p, r]$ 的内部贡献。

不妨看后者，假设我们把 $[p, r]$ 依次放进递增单调栈并求其所有子区间最小值和，有 $a_p$ 永远不会被弹出，于是将 $[1, p)$ 预先放入单调栈并不影响，以 $p$ 为分界点，前面为 $[1, p]$ 的子问题，全栈为 $[1, r]$ 的子问题。于是设 $f_i$ 表示以 $i$ 结尾的所有区间的最小值和，则 $f_i-f_p$ 即为所有 $l \in (p, i], r=i$ 的区间的最小值和，对 $f$ 做一个前缀和就行了。$[l, p)$ 是对称的。

想起了 P8251，那题的结论是去掉单调栈下面的部分元素，弹出每个元素的元素不变，其中元素关系没有传递性。

```cpp
#include <bits/stdc++.h>

namespace gen {
typedef unsigned long long ull;
ull s, a, b, c, lastans = 0;
ull rand() { return s ^= (a + b * lastans) % c; }
};  // namespace gen

using LL = long long;
using uLL = unsigned long long;

int main() {
  int n, q, type; scanf("%d %d %d", &n, &q, &type);
  std::vector<int> a(n);
  for (int &x : a) scanf("%d", &x);
  if (type == 1) scanf("%d %d %d %d", &gen::s, &gen::a, &gen::b, &gen::c);

  std::vector<LL> f(n), g(n), sf(n), sg(n);
  int m = std::log2(n);
  std::vector<std::vector<int>> mn(m + 1, std::vector<int>(n));

  auto cmp = [&](int x, int y) {
    return a[x] < a[y] ? x : y;
  };
  for (int i = 0; i < n; i++) mn[0][i] = i;
  for (int i = 1; i <= m; i++) 
    for (int j = 0; j + (1 << i) - 1 < n; j++) 
      mn[i][j] = cmp(mn[i-1][j], mn[i-1][j + (1 << i-1)]);
  auto qry = [&](int l, int r) {
    int t = std::log2(r - l + 1);
    return cmp(mn[t][l], mn[t][r - (1 << t) + 1]);
  };
  
  std::vector<int> s, pre(n, -1), suf(n, n);
  for (int i = 0; i < n; i++) {
    while (s.size() && a[s.back()] >= a[i]) suf[s.back()] = i, s.pop_back();
    if (s.size()) pre[i] = s.back();
    s.push_back(i);
  }
  for (int i = 0; i < n; i++) {
    f[i] = 1ll * a[i] * (i - pre[i]);
    if (pre[i] != -1) f[i] += f[pre[i]];
    sf[i] = f[i];
    if (i) sf[i] += sf[i - 1];
  }
  for (int i = n - 1; i >= 0; i--) {
    g[i] = 1ll * a[i] * (suf[i] - i);
    if (suf[i] != n) g[i] += g[suf[i]];
    sg[i] = g[i];
    if (i + 1 < n) sg[i] += sg[i + 1];
  }

  uLL res(0);
  while (q--) {
    int l(0), r(0); 
    if (type == 0) scanf("%d %d", &l, &r), --l, --r;
    else {
      l = gen::rand() % n;
      r = gen::rand() % n;
      if (l > r) std::swap(l, r);
    }
    int p = qry(l, r);
    LL ans = 1ll * (p - l + 1) * (r - p + 1) * a[p];
    ans += sf[r] - sf[p] - f[p] * (r - p);
    ans += sg[l] - sg[p] - g[p] * (p - l);
    res ^= gen::lastans = ans;
    // printf("%lld\n", ans);
  }
  printf("%llu\n", res);
}
```

---

## 作者：TernaryTree (赞：0)

好题哦。

考虑维护每个前缀的所有后缀子串 $\min$ 之和以及每个后缀的所有前缀子串 $\min$ 之和，记为 $f_i$ 和 $g_i$。可以直接单调栈求出来。我们希望这些信息可以进行二元运算来增加信息数，覆盖所有区间集合。然而这个信息不可减。我们考虑什么情况下是可减的。取出区间中的最小值，设位置为 $p$。我们发现此时要对所有 $p\lt j\le r$ 计算 $\sum_{i=p+1}^j\min a_{i\dots j}$。有趣的事实是，这个值恰好是 $f_j-f_p$。因为 $p$ 同时是 $[p,r]$ 的最小值，所以增加了一些判定范围并不影响值，此时信息可减。于是我们要求 $\sum_{j=p+1}^r f_j-f_p$，前缀和。另一半对称处理即可。瓶颈在于 rmq。

---

## 作者：dAniel_lele (赞：0)

考虑先预处理出所有前缀/后缀中，$1\leq l\leq r\leq i$ 的 $[l,r]$ 区间最小值之和与 $i\leq l\leq r\leq n$ 的$[l,r]$ 区间最小值之和。这是容易使用笛卡尔树+前缀和求出的。

考虑如何查询。取出查询区间 $[l,r]$ 中的最小值位置记为 $v$。将所有子区间分为三部分：

* $l\leq l'\leq r'<v$；
* $v<l'\leq r'\leq r$；
* $l'\in [l,v]$，$r'\in[v,r]$。

最后一类是好求的，显然答案是 $(v-l+1)(r-v+1)a_v$，因为 $a_v$ 是区间最小值。

考虑前两类怎么求，以第一类为例。我们预处理出了后缀区间最小值之和，于是我们可以使用 $[l,n]$ 后缀区间最小值之和减去 $[v,n]$ 后缀区间最小值之和再减去跨越 $v$ 的区间最小值之和。显然难点在于第三部分。

由于 $a_v\geq\max(a_l,a_{l+1},\dots,a_{v-1})$，容易发现所有区间一定不大于 $a_v$，同时左边 $a_{l'}\sim a_{v-1}$ 不会对最小值有任何影响。也就是说，对于所有 $l'\in[l,v-1]$，对应的所有 $r'\in[v,n]$ 的所有区间最小值之和都是一样的，且均为 $l'=v$ 对应的所有 $r'\in[v,n]$ 的所有区间最小值之和。于是第一类的答案其实就是 $(v-l)(suf_v-suf_{v+1})$。

同理可以计算出第二类。时间复杂度根据不同实现在 $O(n+q)$（需要 $O(n)$ 建笛卡尔树，$O(n)-O(1)$ 最近公共祖先）和 $O(n\log n+q)$ 之间。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
using namespace std;
namespace gen{
	typedef unsigned long long ull;
	ull s,a,b,c,lastans=0;
	ull rand(){
		return s^=(a+b*lastans)%c;
	}
};
struct node{
	int minv,pos;
};
node merge(node x,node y){
	if(x.minv<y.minv) return x;
	return y;
}
node st[100005][18];
int lg[100005];
int qry(int l,int r){
	int k=lg[r-l+1];
	return merge(st[l][k],st[r-(1<<k)+1][k]).pos;
}
int fl[100005],fr[100005],a[100005];
int prec[100005],sufc[100005];
vector<pair<int,int>> vc;
int findl(int i){return fl[i]==i?fl[i]:fl[i]=findl(fl[i]);};
int findr(int i){return fr[i]==i?fr[i]:fr[i]=findr(fr[i]);}; 
signed main(){
	for(int i=2;i<=100000;i++) lg[i]=lg[i/2]+1;
	int n,q,tp=0; cin>>n>>q;
	cin>>tp;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		vc.push_back(make_pair(a[i],i));
	}
	if(tp) cin>>gen::s>>gen::a>>gen::b>>gen::c;
	sort(vc.begin(),vc.end()); reverse(vc.begin(),vc.end());
	for(auto v:vc){
		int i=v.second;
		fl[i]=i,fr[i]=i;
		int L1=i,L2=i,R1=i,R2=i;
		if(fl[i-1]){
			fl[findl(i)]=findl(i-1);
			fr[findr(i-1)]=findr(i);
			L1=findl(i-1);
		}
		if(fr[i+1]){
			fr[findr(i)]=findr(i+1);
			fl[findl(i+1)]=findl(i);
			R2=findr(i+1);
		}
		int l=L2-L1+1,r=R2-R1+1;
		prec[i]+=l*a[i];
		if(R2+1<=n) prec[R2+1]-=l*a[i];
		sufc[i]+=r*a[i];
		if(L1-1>=1) sufc[L1-1]-=r*a[i];
	}
	for(int i=1;i<=n;i++) prec[i]+=prec[i-1];
	for(int i=1;i<=n;i++) prec[i]+=prec[i-1];
	for(int i=n;i>=1;i--) sufc[i]+=sufc[i+1];
	for(int i=n;i>=1;i--) sufc[i]+=sufc[i+1];
//	for(int i=1;i<=n;i++) cout<<prec[i]<<" "<<sufc[i]<<"\n";
	for(int i=1;i<=n;i++) st[i][0].minv=a[i],st[i][0].pos=i;
	for(int j=1;j<=17;j++) for(int i=1;i+(1<<j)-1<=n;i++) st[i][j]=merge(st[i][j-1],st[i+(1<<(j-1))][j-1]);
	unsigned long long res=0;
	while(q--){
		int l,r;
		if(tp==0) cin>>l>>r;
		else{
			l=gen::rand()%n+1;
			r=gen::rand()%n+1;
			if(l>r) std::swap(l,r);
		}
//		cout<<l<<" "<<r<<"\n"; 
		int v=qry(l,r);
		int ans=(v-l+1)*(r-v+1)*a[v];
		int ptl=sufc[l]-sufc[v]-(sufc[v]-sufc[v+1])*(v-l);
		int ptr=prec[r]-prec[v]-(prec[v]-prec[v-1])*(r-v);
		int ret=(unsigned long long)(ans+ptl+ptr);
//		cout<<ret<<" "<<ans<<" "<<ptl<<" "<<ptr<<"\n";
		res^=ret;
		gen::lastans=ret;
	}
	cout<<res;
	return 0;
}
```

---

## 作者：happybob (赞：0)

与最小值相关，考虑求出每个点左右两边第一个小于这个数的点。可以用笛卡尔树或者单调栈维护。

设 $f_i$ 表示以 $i$ 为右端点的所有区间的最小值之和。考虑如何转移 $f_i$。

设 $i$ 左边第一个小于 $a_i$ 的位置为 $pre_i$，则 $f_i = f_{pre_i} + (i-pre_i)\times a_i$。左端点在 $pre_i$ 之前的可以直接继承，在这之后的每一区间贡献都是 $a_i$。

同理设 $g_i$ 表示以 $i$ 为左端点的所有区间最小值之和，求法类似。

考虑求答案时，求出区间最小值位置 $i \in [l,r]$，跨过 $i$ 的贡献为 $a_i \times (i-l+1) \times (r-i+1)$。

考虑求 $[l,i)$ 与 $(i,r]$ 的贡献。比如求 $[l,i)$，设 $j \in [l,i)$，考虑以 $j$ 为左端点，且右端点 $\in [j,i)$ 的贡献。可以发现贡献为 $g_j - g_i$。因为每一个以 $i$ 为左端点的区间，将左端点拓展到 $j$，最小值不变，而相减后剩余的就是 $g_j-g_i$ 了。

同理，$(i,r]$ 可以用 $f_j - f_i$ 算。维护 $f$ 和 $g$ 的前缀和，即可做到 $O(n \log n + q)$ 的复杂度了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <stack>
using namespace std;

const int N = 1e5 + 5;

int n, q, type;
long long a[N];

namespace gen
{
	typedef unsigned long long ull;
	ull s, a, b, c, lastans = 0;
	ull rand()
	{
		return s ^= (a + b * lastans) % c;
	}
};

int pre[N], suf[N];
long long f[N], revf[N];
long long s_f[N], s_revf[N];

int lson[N], rson[N];

int LG2[N];
int ff[N][21], p[N][21];

void Init()
{
	memset(ff, 0x7f, sizeof ff);
	for (int i = 2; i < N; i++) LG2[i] = LG2[i >> 1] + 1;
	for (int i = 1; i <= n; i++) ff[i][0] = a[i], p[i][0] = i;
	for (int j = 1; j <= LG2[n]; j++)
	{
		for (int i = 1; i + (1 << j) - 1 <= n; i++)
		{
			if (ff[i][j - 1] < ff[i + (1 << (j - 1))][j - 1])
			{
				ff[i][j] = ff[i][j - 1];
				p[i][j] = p[i][j - 1];
			}
			else
			{
				ff[i][j] = ff[i + (1 << (j - 1))][j - 1];
				p[i][j] = p[i + (1 << (j - 1))][j - 1];
			}
		}
	}
}

int query(int l, int r)
{
	int x = LG2[r - l + 1];
	return (ff[l][x] < ff[r - (1 << x) + 1][x] ? p[l][x] : p[r - (1 << x) + 1][x]);
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> q >> type;
	for (int i = 1; i <= n; i++) cin >> a[i], pre[i] = 0, suf[i] = n + 1;
	if (type == 1) cin >> gen::s >> gen::a >> gen::b >> gen::c;
	stack<int> st;
	for (int i = 1; i <= n; i++)
	{
		while (st.size() && a[st.top()] > a[i])
		{
			lson[i] = st.top();
			suf[st.top()] = i;
			st.pop();
		}
		int p = (st.size() ? st.top() : 0);
		pre[i] = p;
		rson[p] = i;
		st.push(i);
	}
	for (int i = 1; i <= n; i++)
	{
		f[i] = f[pre[i]] + (1LL * i - pre[i]) * a[i];
		s_f[i] = s_f[i - 1] + f[i];
	}
	for (int i = n; i >= 1; i--)
	{
		revf[i] = revf[suf[i]] + (1LL * suf[i] - i) * a[i];
		s_revf[i] = s_revf[i + 1] + revf[i];
	}
	Init();
	unsigned long long res = 0;
	while (q--)
	{
		int l, r;
		if (type == 0) cin >> l >> r;
		else
		{
			l = gen::rand() % n + 1, r = gen::rand() % n + 1;
		}
		if (l > r) swap(l, r);
		int place = query(l, r);
		long long ans = 0;
		ans += 1ll * a[place] * (1ll * r - place + 1) * (1ll * place - l + 1);
		ans += 1ll * (1ll * s_f[r] - s_f[place] - f[place] * 1ll * (1ll * r - place));
		ans += 1ll * (1ll * s_revf[l] - s_revf[place] - revf[place] * (1ll * place - l));
		gen::lastans = (unsigned long long)ans;
		res ^= (unsigned long long)ans;
	}
	cout << res << "\n";
	return 0;
}
```


---

## 作者：Leap_Frog (赞：0)

### Description.
多次询问 $l$ 和 $r$，求 $\sum_{x=l}^r\sum_{y=x}^r\min_{i=x}^ya_i$
### Solution
我们设 $[l,r][x,y]$ 代表左端点在 $[l,r]$ 右端点在 $[x,y]$ 的答案。  
$$\therefore[l,r][l,r]=[1,r][1,r]-[1,l-1][1,l-1]-[1,l-1][l,r]$$
我们设 $F(x)=[1,x][1,x]$，$f(x)=[1,x][x,x]$，$ls(x)$ 表示上一个比 $x$ 小的数。  
$$\therefore F(x)=[1,x-1][1,x-1]+[1,x][x,x]=F(x-1)+f(x)$$
$$\therefore f(x)=f(ls(x))+(x-ls(x))\times a_x$$
所以我们可以 $O(n)$ 预处理出 $f(x)$ 和 $F(x)$。  
但是对于那个 $[1,l-1][l,r]$ 很难处理。  
我们不妨考虑特殊情况，假设 $[l,r]$ 满足 $a_l\le a_x(x\in[l,r])$  
那么 $[1,l-1][l,r]=(r-l+1)\times F(l-1)$  
我们考虑如何把原题转化到这个上面。  
对于询问，我们先进行一步转化。（设 $p=wh[l,r]$  
$$[l,r][l,r]=[l,p][l,p]+[p,r][p,r]+[l,p-1][p+1,r]-[p,p][p,p]$$  
$$\because [l,p-1][p+1,r]=(p-l)\times(r-p)\times a_p$$  
$$\because [p,p][p,p]=a_p$$
我们就可以把它用双倍常数的代价转化成 $a_l\le a_x(x\in[l,r])$。  
然后再预处理一下，单调栈求一下 $ls(x)$，st 表维护一下 $wh$ 就好了。  
注意有些时候左端点是最小值，有些时候右端点是最小值，所以需要做两次。  
然后再推下去就和@yijan 的做法殊途同归了 ![](//xn--9zr.tk/cy)
### Coding.
~~暂无，不贴。因为还没写，写完可能会贴~~  
~~upd：代码来了！~~  
```cpp
//愿你有一天能和你重要的人重逢。
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	if(f) x=-x;
}
//这里 f 和 F 和上面定义的一样，g 和 G 是反过来之后的定义
//ls 相当于这里的 L，rs 相当于这里的 R。
typedef unsigned long long ull;const int N=100005;ull S,A,B,C,las=0,res=0;
int n,q,a[N],L[N],R[N],st[N][20],lg[N],sa[N],tp;ll f[N],F[N],g[N],G[N];char tag;
inline ull rnd() {return S^=(A+B*las)%C;}
inline int gtmn(int x,int y) {return a[x]<a[y]?x:y;}
inline int qry(int l,int r) {int g=lg[r-l+1];return gtmn(st[l][g],st[r-(1<<g)+1][g]);}
int main()
{
	read(n),read(q),read(tag),lg[0]=-1;for(int i=1;i<=n;i++) read(a[i]),st[i][0]=i,lg[i]=lg[i>>1]+1;
	for(int i=1;i<20;i++) for(int j=1;j+(1<<(i-1))<=n;j++) st[j][i]=gtmn(st[j][i-1],st[j+(1<<(i-1))][i-1]);
	for(int i=1;i<=n;i++) {while(tp&&a[sa[tp]]>a[i]) R[sa[tp--]]=i;sa[++tp]=i;}
	while(tp) R[sa[tp--]]=n+1;
	for(int i=n;i>=1;i--) {while(tp&&a[sa[tp]]>a[i]) L[sa[tp--]]=i;sa[++tp]=i;}
	while(tp) L[sa[tp--]]=0;
	for(int i=1;i<=n;i++) g[i]=g[L[i]]+1ll*a[i]*(i-L[i]),G[i]=G[i-1]+g[i];
	for(int i=n;i>=1;i--) f[i]=f[R[i]]+1ll*a[i]*(R[i]-i),F[i]=F[i+1]+f[i];
	tag?read(S),read(A),read(B),read(C):void();for(int l,r,p;q--;)
	{
		if(tag) l=rnd()%n+1,r=rnd()%n+1,l>r?swap(l,r):void(),p=qry(l,r);else read(l),read(r),p=qry(l,r);
		res^=(las=F[l]-F[p]-(p-l)*f[p]+G[r]-G[p]-(r-p)*g[p]+1ll*(p-l+1)*(r-p+1)*a[p]);
	}
	return printf("%llu\n",res),0;
}
```

---


# 环 Rings

## 题目背景

> 一九二九不出手，三九四九冰上走，五九六九隔河看杨柳；
>
> 七九河开，八九雁来，九九加一九，耕牛遍地走。

「九」自古以来就是一个奇妙的数字，而你今天要解决的问题，也与「九」有关。

## 题目描述

你有一个 $n$ 连环，和你熟知的九连环有着相同的结构。

![这是一个九连环](https://cdn.luogu.com.cn/upload/image_hosting/x68krf0v.png)

> 上图是一个九连环。

顾名思义，$n$ 连环有一个长长的横梁，上面挂着 $n$ 个 **彼此影响** 的环。

我们给这 $n$ 个环编号，其中最靠横梁头部的环为第 $1$ 个环，其次为第 $2$ 个环，以此类推……最靠横梁尾部的环为第 $n$ 个环；

定义 $f_i$ 表示第 $i$ 个环的状态，其中 $f_i = 1$ 表示这个环在横梁上，$f_i = 0$ 表示这个环不在横梁上；

定义 **拆装一个环** 为使环的状态 **取反**，即状态从 $1$ 变成 $0$ 或从 $0$ 变成 $1$。

这些环的合法拆装规则如下：

1. 第 $1$ 个环随时可以单独拆装；
2. 第 $k+1$ 个环可以单独拆装，当且仅当 $f_k=1$ 且 $\forall i < k$，都有 $f_i = 0$；
3. 若 $f_1 = f_2$，则第 $1,2$ 两个环可以一起拆装。

现在你需要解决的问题是：已知一个 $n$ 连环的初始状态，请你求出拆除这个 $n$ 连环的最少拆装步数。

## 说明/提示

本题采用 **捆绑测试**，开启 **O2优化**。

$\text{Subtask 1 (10 pts)}:$ 保证 $1 \le n \le 20$；

$\text{Subtask 2 (15 pts)}:$ 保证 $1 \le n\le 1000$；

$\text{Subtask 3 (15 pts)}:$ 保证初始状态中 **只有** $1$ 个 $1$；

$\text{Subtask 4 (30 pts)}:$ 保证 $1 \le n \le 10^7$；

$\text{Subtask 5 (30 pts)}:$ 没有特殊限制。

对于所有数据，满足 $1 \le n \le 10^{18}$，$1 \le m \le 10^5$，$st_{i} \in \{0, 1\}$，$len_{i} \ge 1$

数据保证 $\sum\limits_{i=1}^m len_{i} = n$。

---

#### 样例 #1 解释

样例描述的是 $4$ 连环，初始状态为 `1101`。

用最少合法拆装次数完成的方法如下：

```plain
1. 1101 -> 1100
2. 1100 -> 0100
3. 0100 -> 0111
4. 0111 -> 0110
5. 0110 -> 0010
6. 0010 -> 0011
7. 0011 -> 0000
```

共 $7$ 步。

---

#### 题外话

本题中 $n$ 连环的第 $3$ 条拆装规则，在大部分的九连环玩法说明中都没有提到，但它确实是一个真实可行的操作呢！

## 样例 #1

### 输入

```
4
3
1 1
1 0
2 1
```

### 输出

```
7```

## 样例 #2

### 输入

```
15
4
5 1
2 1
4 0
4 1
```

### 输出

```
15424```

## 样例 #3

### 输入

```
3
3
1 1
1 0
1 1```

### 输出

```
5```

# 题解

## 作者：WYXkk (赞：11)

由于被这题卡了好久，最后过了还拿到了最优解，于是来写波题解（

首先，我们不应该考虑如何把所示状态 **拆下来**，而应该考虑如何将它 **装上去**。

容易知道，这两者是完全等价的。

然后，我们先考虑一种极其特殊的情况：只有一个环在上面（即 $\text{Subtask 3}$）。

设这个环在 $n$ 位置，其答案为 $f_n$。

易知：$f_1=1,f_2=2$，且对于 $n\ge 3$，$f_n=2f_{n-1}+1$。

（先 $f_{n-1}$ 步单独上 $n-1$ 环，然后一步上 $n$ 环，然后 $f_{n-1}$ 步下 ${n-1}$ 环）

然后随便找个规律可得 $f_n=\begin{cases}1,&n=1\\3\times2^{n-2}-1,&n\ge 2\end{cases}$。

现在考虑一般的情况，例如 `111011011`。

既然要上第 $9$ 环，那么必须得有只有第 $8$ 环的时刻，于是 `000000000` -> `010000000` -> `110000000`，共用了 $f_8+1=3\times2^6$ 步；

接下来，我们可以不管前两个环了，只需要让 `0000000` -> `1011011` 即可。

同上可知，既然要上 $7$ 环，那么必须得有单独上 $6$ 环，即 `0000000` -> `0100000` -> `1100000`，共用了 $f_6+1=3\times2^4$ 步；

接下来 $7$ 环就可以不管了，只需要让 `100000` -> `011011` 即可。

然后，因为要下 $6$ 环，因此单独上 $5$ 环，然后把 $6$ 环下下来，即 `100000` -> `110000` -> `010000`，共用了 $f_5+1=3\times2^3$ 步；

接下来 $5,6$ 两环就可以不管了，只需要让 `0000` -> `1011` 即可。

我们应该先单上 $3$ 环，然后上 $4$ 环，然后单上 $2$ 环，然后下 $3$ 环，然后上 $1$ 环。其中的逻辑和上面类似，不再赘述。

因此，我们可以得到如下策略：

从最高位开始，忽略所有已完成位，然后上次高位，完成最高位，以此类推。

回到原题，如何求出最优解的步数呢？

首先倒序输入，然后合并段。

```cpp
UF(i,m,1) {rd(l[i]);rd(st[i]);}
int tot=0,st2=0;
F(i,1,m) {if(st[i]!=st2) ++tot,st2=st[i];l2[tot]+=l[i];}
n-=l2[0];
```

扫描所有 $1$ 段，分别计算他们的贡献。每扫描完一段，忽略之（即将 $n$ 减去已匹配的部分）

接下来就是大分类讨论了——（为了防止 Markdown 爆炸我加上了层数以便区分）

- (1)如果这是最后一段（即后面没有 $0$ 了）：

  - (2)如果其长度为奇数 $l$：$3\times2^{l-3}+3\times2^{l-5}+\cdots+3\times2^0+1=2^{l-1}$
  - (2)如果其长度为偶数 $l$：$3\times2^{l-3}+3\times2^{l-5}+\cdots+3\times2^1+1=2^{l-1}-1$

- (1)如果这段后面还有长度 $l^\prime$ 的 $0$ 段：

  - (2)如果这段长度为奇数 $l$：$3\times2^{n-3}+3\times2^{n-5}+\cdots+3\times2^{n-l}=2^{n-1}-2^{n-l}$

    - (3)如果再后面没有了/只有一个 $1$ 就到末尾：$3\times2^{n-l-1}-1$
    - (3)否则：$3\times2^{n-l-2}+3\times2^{n-l-3}+...+3\times2^{n-l-l^\prime-2}=3\times(2^{n-l-1}-2^{n-l-l^\prime-2})$

    (2)最后删去下一段 $1$ 的开头一个 $1$。

  - (2)如果这段长度为偶数 $l$：$3\times2^{n-3}+3\times2^{n-5}+...+3\times2^{n-l-1}=2^{n-1}-2^{n-l-1}$

更新 $n$。（我一开始就漏了这一步调了 $114514$ 年）

最后输出结果即可。复杂度 $O(m)$。

$\texttt{code:}$

```cpp
#define int ll
const int M=100005;
ll l[M],st[M];
ll l2[M],tot=0;
const ll p=1201201201;
ll qp(ll a,ll b){if(!b) return 1;ll w=qp(a,b>>1);w=w*w%p;return b&1?w*a%p:w;}
signed main()
{
	ll n=rd();
	int m=rd();
	F(i,1,m) {rd(l[i]);rd(st[i]);}
	int st2=0;
	UF(i,m,1) if(st[i]==st2) l2[tot]+=l[i];else {++tot;l2[tot]=l[i],st2=st[i];}
	int lst=0;
	ll ans=0;n-=l2[0];
	F(i,1,tot)
	{
		l2[i]-=lst;n-=lst;
		if(i==tot)
		{
			if(l2[i]&1)
			{
				ans+=qp(2,l2[i]-1);
				ans=(ans%p+p)%p;
			}
			else
			{
				if(l2[i]) ans+=qp(2,l2[i]-1)-1;
				ans=(ans%p+p)%p;
			}
			lst=0;
		}
		else
		{
			if(l2[i]&1)
			{
				ans+=qp(2,n-1)-qp(2,n-l2[i]);
				if(n-l2[i]-l2[i+1]-2>=0) ans+=3*(qp(2,n-l2[i]-1)-qp(2,n-l2[i]-l2[i+1]-2));
				else ans+=3*qp(2,n-l2[i]-1)-1;
				ans=(ans%p+p)%p;lst=1;
			}
			else
			{
				ans+=qp(2,n-1)-qp(2,n-l2[i]-1);
				ans=(ans%p+p)%p;lst=0;
			}
			n-=l2[i]+l2[i+1];++i;
		}
	}
	cout<<ans%p<<endl;
	return 0;
}
```



---


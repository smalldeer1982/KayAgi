# [BalticOI 2020] 染色 (Day1)

## 题目描述

Linda 喜欢时不时改变她头发的颜色，如果她的男友 Archie 注意到她头发颜色发生了改变，Linda 会十分高兴。当且仅当 Archie 发现 Linda 的头发颜色发生改变时，Archie 才会去评论 Linda 头发的新颜色。这意味着 Linda 始终可以知道 Archie 是否发现她的头发颜色有改变。

现在市场上有一个新染发剂系列，该染发剂系列有 $N$ 种颜色，从 $1$ 到 $N$ 编号。两个颜色的相近程度与它们编号的差值有关——差值越小，则越相近。

Linda 发现，对于该系列的染发剂，存在一个色差阈值 $C$（$1 \leq C \leq N$）。具体来说，假如 Linda 之前使用的染发剂颜色编号为 $color_{prew}$，Linda 接下来打算使用的染发剂颜色编号为 $color_{new}$，则 Archie 会注意到 Linda 的颜色头发差异，当且仅当 $\left | color_{new}-color_{prew}\right | \geq C$。

现在 Linda 买下了一套该系列的染发剂，准备做一个实验。她会不断地更换头发的颜色，并观察 Archie 是否注意到了头发颜色发生改变。因为染发剂有限，每种颜色的染发剂最多只能使用一次。

在实验开始之前，Linda 使用的是另外一个系列的染发剂，因此讨论第一次染发后 Archie 的反应是没有意义的。

现在 Linda 想要通过有限的时间找到阈值 $C$，请写一个程序帮助她完成这个任务。

### 交互方式

本题是一道交互题。

**与原题不同的是，为了压缩数据组数，本题单个测试点中将包含多组数据。**

输入第一行包含一个整数 $T$，表示该测试点的数据组数。

对于每组数据，你首先将读入一个整数 $N$，代表该系列染发剂的颜色数量。

接下来，你可以按如下形式输出来进行询问：`? P`。其中 $P$ 代表 Linda 下一次要使用的染发剂的颜色编号。你输出的 $P$ 需要满足 $1 \leq P \leq N$，且任意两次询问的 $P$ 均不相同。

在询问过后，你的程序将读入一个整数，若这个整数为 $1$，代表 Archie 注意到了 Linda 头发颜色的变化；若为 $0$，则表示他没有注意到颜色的变化。

当你确认了阙值 $C$ 后，按如下格式输出答案：`= C`。

如果答案正确，将会直接进入下一组数据的交互。

如果答案错误，交互器将直接终止你的程序。

对于每组测试数据，你的程序可以最多进行 $64$ 次询问（最后输出答案不算作询问）。

请注意，一般情况下程序的输出会存放在缓冲区中，为了确保你的输出能被交互库接收，请在输出一行之后刷新缓冲区。

- 对于 C++ 语言，可以使用 `std::cout<<std::endl` 来在输出换行的同时刷新缓冲区；
- 对于 Java 语言，可以使用 `System.out.flush();` 来刷新缓冲区；
- 对于 Python 语言，可以使用 `sys.stdout.flush()` 来刷新缓冲区。

## 说明/提示

### 样例解释

为了方便各位理解交互过程，部分行之间人为添加了空行。

下面依次解释每次询问过程：

1. 这一次询问的结果无意义。
2. 此次询问后有 $C \leq 5$；
3. 此次询问后有 $3 \lt C \leq 5$，这时候可以考虑检测差值为 $4$ 时的情况。但因为 $4+4=8$ 和 $4-4=0$ 都不合法，因此不再考虑这么做。
4. 此次询问后有 $3 \lt C \leq 5$。
5. 此次询问后有 $3 \lt C \leq 4$，即 $C=4$。

### 子任务

所有数据均满足：$1 \leq T \leq 1200$，$1 < N \leq 10^{18}$。

- 子任务 1（9 分）：$N \leq 64$；
- 子任务 2（13 分）：$N \leq 125$；
- 子任务 3（21 分）：$N \leq 10^3$；
- 子任务 4（24 分）：$N \leq 10^9$；
- 子任务 5（33 分）：无特殊限制。

## 样例 #1

### 输入

```
1
7

1

1

0

0

1
```

### 输出

```


? 2

? 7

? 4

? 1

? 5

= 4```

# 题解

## 作者：7KByte (赞：4)

非常有意思的交互题。

隐藏一个常数 $C$，每次可以查询一个在范围 $[1,n]$ 中的位置，取这个位置和上次查询的位置的差，如果差 $\ge C$ 返回 $1$，否则返回 $0$。每个位置只能查询一次。要在 $64$ 次询问内求出答案，$1\le C\le N\le 10^{18}$。

根据数据范围我们可以知道需要一个严格 $\log N$ 的做法。（多一两次应该没问题

那么只有倍增和二分两个选择。

倍增每次往一个方向走，如果来回走显然会重复位置，看上去就非常不可做。

考虑二分。由于 $C$ 可能很大，那么我们也只有依次向右向左这样来回跳。

到这里我们也没有想到什么好的方法能避免重复询问。

倒着想，最坏的情况我们一定要判断 $N-1$ 是否满足条件，而要判断 $N-1$ 必定是从 $1$ 跳到 $N$，没有别的选择。

这样我们就知道了最后两次的询问，并且如果卡到最坏情况，显然 $C = N$，这也就意味着每次二分的返回值都是 0，进一步，每次的 $mid$ 都是固定的。

所以我们可以反推出第一次询问的位置，并且这个位置是唯一的。

从初始位置出发，每次交替向左或向右跳 $mid$ 格即可二分出最终答案。

但是这样做为什么不会有重复的，因为我们倒着推出这个方案是唯一的，其余方案显然会被 $C = N$ 的情况卡掉，所以不会有重复（

感性理解一下，如果一直返回 $0$ ，就是正的走一遍，一定不会重复。如果某次返回了 $1$ ，那么范围上界缩小到 $mid - 1$，在距离当前位置 $[l,mid-1]$ 范围内的格子显然没有走过，归纳一下也没有问题。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define int long long
using namespace std;
vector<int>c;
int ask(int x){
	cout<<"? "<<x<<endl;
	int op;cin>>op;
	return op;
}
signed main(){
	int T;scanf("%lld",&T);
	while(T--){
		int n;scanf("%lld",&n);
		c.clear();
		int l = 1, r = n - 1;
		while(l <= r){
			int mid = (l + r) >> 1;
			c.push_back(mid);
			l = mid + 1;
		}
		reverse(c.begin(), c.end());
		int st = 1, j = 1;
		for(int x : c)st += j * x, j *= -1;
		l = 1, r = n - 1;int ed = n;
		ask(st);
		while(l <= r){
			int mid = (l + r) >> 1;
			st += j * mid, j *= -1;
			if(ask(st))ed = mid, r = mid - 1;
			else l = mid + 1;
		}
		cout<<"= "<<ed<<endl;
	}
	return 0;
}
```



---

## 作者：Inui_Sana (赞：2)

挺简单的交互题。不知道为什么这题在 [cf 上的版本](https://codeforces.com/problemset/problem/1386/A) 评了 *2700。并且有双倍经验。

首先显然是要二分答案然后用交互 check 的。我们先尝试从 $P=1$ 开始是否可行。容易发现，如果得到 $ans>mid$，$P$ 此时原本在 $\dfrac{n}{2}$ 左右，而第二次我们要找到一个 $P'$ 使得 $|P'-P|\approx \dfrac{3n}{4}$。这显然是无解的。

不过这也启示我们应该从每次跳的距离都最大的情况去考虑，如何找到一个合法的起点。

因为极端情况下 $mid$ 不断变大，于是倒序考虑，先确定终点在 $1$，处理出每次的 $mid$，在数轴上考虑，每次先往右再往左跳。跳完所有的 $mid$ 时在的位置就是我们要的起点。

此时就会有一个问题：会不会向左/右的空间不够导致奇怪的 $P$ 的重复呢？其实是不会的，因为容易发现每次就相当于把一个区间不断缩小，直到区间长度 $=\dfrac{n}{2}$。

于是我们就可以想出这么一种构造：从这个起点开始，二分同时依次向左向右跳（根据上面处理起点时的相反顺序来）。

然后又有一个问题了：这样会不会重复？感性理解一下是不会的，有具体证明可以敲敲我。

code：

```cpp
ll n,m,a[107];
il ll ask(ll x,int op){
	if(op){
		printf("= %lld\n",x);
		fflush(stdout);
		return 0;
	}
	printf("? %lld\n",x);
	fflush(stdout);
	ll y;scanf("%lld",&y);
	return y;
}
void Yorushika(){
	scanf("%lld",&n),m=0;
	ll l=1,r=n-1;
	while(l<=r){
		ll mid=(l+r)>>1;
		a[++m]=mid,l=mid+1;
	}
	reverse(a+1,a+m+1);
	ll p=1;
	rep(i,1,m){
		if(i&1){
			p+=a[i];
		}else{
			p-=a[i];
		}
	}
	ll x=ask(p,0);
	l=1,r=n-1;
	ll ans=n,cnt=0;
	while(l<=r){
		ll mid=(l+r)>>1;
		cnt++;
		if(abs(m-cnt)&1){
			x=ask(p+=mid,0);
		}else{
			x=ask(p-=mid,0);
		}
		if(x){
			ans=mid;
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	ask(ans,1);
}
signed main(){
	int t=1;
		scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

---


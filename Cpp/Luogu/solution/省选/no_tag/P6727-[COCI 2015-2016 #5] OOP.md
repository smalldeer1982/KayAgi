# [COCI 2015/2016 #5] OOP

## 题目描述

给定 $N$ 个单词和 $Q$ 个模板，一个模板由一个 `*` 和一些小写字母组成。一个模板覆盖了一个单词当且仅当将 `*` 替换为某个字符串（**可以为空**）后，模板和单词能够完全重合。对于每个模板，求出它能够覆盖多少个单词。

## 说明/提示

#### 数据规模与约定
对于 $40\%$ 的数据，$1\le N,Q\le 10^3$；  
对于 $100\%$ 的数据，$1\le N,Q\le 10^5$。

#### 说明

**题目译自 [COCI2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #5](https://hsin.hr/coci/archive/2015_2016/contest5_tasks.pdf) *T5 OOP***。

## 样例 #1

### 输入

```
3 3
aaa
abc
aba
a*a
aaa*
*aaa```

### 输出

```
2
1
1```

## 样例 #2

### 输入

```
5 3
eedecc
ebdecb
eaba
ebcddc
eb
e*
*dca
e*c```

### 输出

```
5
0
2```

# 题解

## 作者：Miko35 (赞：9)

提供一个线性的屑，跑的比 $\operatorname{log}$ 慢一万倍！！!!11！1

---

一个询问串 `A*B` （长为 $len$）的限制有如下三条：(其中 `A` 表示 `*` 前面的子串，`B` 表示后面的）

1. 前缀有 `A`
2. 后缀有 `B`
3. 长度 $\ge len-1$

只有满足这三点的串才会对这个询问产生 $1$ 的贡献。如何维护？

先考虑前缀的限制，可以将所有模式串按照字典序排序，这样子的话，前缀为 `A` 的所有串都会在一个区间内。（具体实现为，加入到 trie 中然后 dfs 一遍 trie）

有了这个性质，一个询问就变成了：查询 $[l,r]$ 中后缀有 `B` 且长度 $\ge len$ 的串有多少个。

显然可以差分喵。也就是令 $f(i,str,len)$ 表示 $[1,i]$ 中后缀有 $str$ 且长度 $\ge len$ 的串的个数，答案即为 $f(r,str,len)-f(l-1,str,len)$。

然后离线，在排序后的模式串中，从 $1$ 到 $n$ 依次在 trie 加入每个串的反串，然后查询 $f(i,str,len)$ 就是找到 $str$ 的反串所对应 trie 上节点的子树内，有多少长度 $\ge len$ 的串。

维护一个哈希表 $h_{x,i}$ 表示 trie 树上的 $x$ 节点的子树内，长度为 $i$ 的串的个数。查询时，用子树内总串数减去长度 $<len$ 的串数，得到合法数量。前者容易维护，后者就暴力扫一遍 $h_{x,1}$ 到 $h_{x,len-1}$ 求和。因为 $len$ 和询问串长度同级，所以复杂度是 $O(\text{总串长})$。

这样就做到，线性解决询问了喵。

空间可能会有点点卡 QwQ

```cpp
#include<bits/stdc++.h>
#define rgi register int
#define pbk push_back
#define pii pair<int,int>
#define fi first
#define se second 
#define fin(x) freopen(x,"r",stdin)
#define cl(x) memset(x,0,sizeof x)
using namespace std;
typedef long long ll;
const int N=100010,S=3000010,mod=4127021;
int n,m,l[S],r[S],T=1,ch[S][26],p[N],C,id[N],ans[N],d;
string s[N],t,g;
vector<int>b[S];
struct Hash{
	int h[mod+10],vx[S],vy[S],p[S],nxt[S],sz;
	inline void ins(int x,int y){
		for(rgi k=h[((ll)(x-1)*S+y-1)%mod];k;k=nxt[k])if(vx[k]==x&&vy[k]==y)return void(++p[k]);
		int pos=((ll)(x-1)*S+y-1)%mod;
		vx[++sz]=x,vy[sz]=y,p[sz]=1,nxt[sz]=h[pos],h[pos]=sz;
	}
	inline int ask(int x,int y){
		for(rgi k=h[((ll)(x-1)*S+y-1)%mod];k;k=nxt[k])if(vx[k]==x&&vy[k]==y)return p[k];
		return 0;
	}
}mp;
int F(int& x){return x?x:x=++T;}
int find(string s,int id=0,int h=0){
	int rt=1;
	for(char k:s){
		rt=F(ch[rt][k-'a']);
		if(h)mp.ins(rt,h),++l[rt];
	}
	if(id)b[rt].pbk(id);
	if(h)mp.ins(1,h),++l[1];
	return rt;
}
void dfs(int x){
	l[x]=C;
	for(rgi k:b[x])id[k]=++C;
	for(rgi to:ch[x])if(to)dfs(to);
	r[x]=C;
}
struct qry{
	int id,v,len;string s;
	void sol(){
		int G=l[d=find(s)];
		for(rgi i=1;i<len;++i)G-=mp.ask(d,i);
		ans[id]+=G*v;
	}
};
vector<qry>q[N];
signed main(){
	cin>>n>>m;
	for(rgi i=1;i<=n;++i)cin>>s[i],find(s[i],i);
	dfs(1);
	for(rgi i=1;i<=n;++i)p[id[i]]=i;
	for(rgi i=1,pos,k,L;i<=m;++i){
		cin>>t,L=t.size()-1,k=find(t.substr(0,pos=t.find('*')));
		g=t.substr(pos+1),reverse(g.begin(),g.end());
		q[r[k]].pbk(qry{i,1,L,g}),q[l[k]].pbk(qry{i,-1,L,g});
	}
	cl(ch),cl(l);
	for(rgi i=T=1;i<=n;++i){
		g=s[p[i]],reverse(g.begin(),g.end()),find(g,0,g.size());
		for(qry k:q[i])k.sol();
	}
	for(rgi i=1;i<=m;++i)cout<<ans[i]<<'\n';
	return 0;
}
```




---

## 作者：Provicy (赞：4)

$\text{Problem}$：[题目链接](https://www.luogu.com.cn/problem/P6727)

$\text{Solution}$：

考虑到模式串中只有一个 `*` 号，对于一个询问串 $t_{i}$，可以把它根据 `*` 的位置分成一个前缀串和后缀串，并分别记它们为 $a_{i}$ 和 $b_{i}$。对于单词串 $s_{i}$，可以考虑把它插入字典树。发现每次查询时可以把 $a_{i}$ 放到字典树上查询到节点 $x$，那么在 $x$ 的子树内查询有多少和 $t_{i}$ 相等的后缀即可。

对于后缀串判断是否相同，考虑使用 $\text{Hash}$。在字典树上的每个节点开一个 $vector$ 记录这个节点所有后缀串的 $\text{Hash}$ 值。对于查询串的 $b_{i}$ 串，可以用 $set$ 或 $map$ 保存它们。那么我们 $DFS$ 一遍这个字典树，对于一个节点 $x$，如果这个节点存储的后缀串 $\text{Hash}$ 值 $v$，和某个 $b_{i}$ 串的 $\text{Hash}$ 值相同，则我们对于 $v$ 开一个用 $map$ 实现的 $vector$ $G$ ，在 $G_{v}$ 中插入 $x$ 这个位置的 $id$。

考虑如何求出这个 $id$，由于我们在查询时要求出第一个在子树内和第一个在子树外的 $id$ 在 $G_{v}$ 中的位置，则我们可以用欧拉序维护这个信息。记 $ql_{x}$ 表示第一次遍历 $x$ 这个节点，$qr_{x}$ 表示第二次遍历 $x$ 这个节点，$DFS$ 字典树时，满足条件就在 $G_{v}$ 中插入 $ql_{x}$，那么查询答案时直接在 $G_{b_{i}}$ 上二分即可找到答案。

$\text{Code}$：

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <queue>
#include <set>
#include <vector>
#include <stack>
#include <map>
#include <bitset>
#define ri register
#define inf 0x7fffffff
#define E (1)
#define mk make_pair
//#define int long long
//#define double long double
using namespace std; const int N=3000010, M=100010;
const int Base=193, Mod=998244353, Base1=131, Mod1=19260817;
inline int read()
{
    int s=0, w=1; ri char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch-'0'), ch=getchar();
    return s*w;
}
void print(int x) { if(x<0) x=-x, putchar('-'); if(x>9) print(x/10); putchar(x%10+'0'); }
int n,q,ch[N][26],tot=1,ql[N],qr[N],nowid; char s[N];
struct Node{ int hsh1,hsh2; }hsh[N];
inline bool operator < (const Node& a, const Node &b ) { return a.hsh1==b.hsh1?a.hsh2<b.hsh2:a.hsh1<b.hsh1; }
vector<Node> P[N];
string a[M],b[M],ss;
set<Node> suf; map<Node,vector<int> > G;
inline void Insert(char *s,int len)
{
    int x=1; P[x].push_back(hsh[0]);
    for(ri int i=0;i<len;i++)
    {
        int p=s[i]-'a';
        if(!ch[x][p]) ch[x][p]=++tot;
        x=ch[x][p];
        P[x].push_back(hsh[i+1]);
    }
}
void DFS(int x)
{
    ql[x]=++nowid;
    for(ri int i=0;i<(int)P[x].size();i++) if(suf.count(P[x][i])) G[P[x][i]].push_back(ql[x]);
    for(int i=0;i<26;i++) if(ch[x][i]) DFS(ch[x][i]);
    qr[x]=++nowid;
}
int Ask(const char *s,int len,Node w)
{
    int x=1;
    for(ri int i=0;i<len;i++)
    {
        int p=s[i]-'a';
        x=ch[x][p];
    }
    return upper_bound(G[w].begin(),G[w].end(),qr[x])-lower_bound(G[w].begin(),G[w].end(),ql[x]);
}
signed main()
{
    n=read(), q=read();
    for(ri int i=1;i<=n;i++)
    {
        scanf("%s",s); int len=strlen(s);
        hsh[len].hsh1=hsh[len].hsh2=0;
        for(ri int j=len-1;~j;j--)
        {
            hsh[j].hsh1=(1ll*hsh[j+1].hsh1*Base%Mod+s[j]-'a'+1)%Mod;
            hsh[j].hsh2=(1ll*hsh[j+1].hsh2*Base1%Mod1+s[j]-'a'+1)%Mod1;
        }
        Insert(s,strlen(s));
    }
    for(ri int i=1;i<=q;i++)
    {
        cin>>ss;
        a[i]=ss.substr(0,ss.find('*'));
        b[i]=ss.substr(ss.find('*')+1);
        int len=b[i].length();
        int sufhash, sufhash1; sufhash=sufhash1=0;
        for(ri int j=len-1;~j;j--)
        {
            sufhash=(1ll*sufhash*Base%Mod+b[i][j]-'a'+1)%Mod;
            sufhash1=(1ll*sufhash1*Base1%Mod1+b[i][j]-'a'+1)%Mod1;
        }
        Node sufh=(Node){sufhash,sufhash1};
        suf.insert(sufh);
    }
    DFS(1);
    for(ri int i=1;i<=q;i++)
    {
        int len=b[i].length();
        int sufhash, sufhash1; sufhash=sufhash1=0;
        for(ri int j=len-1;~j;j--)
        {
            sufhash=(1ll*sufhash*Base%Mod+b[i][j]-'a'+1)%Mod;
            sufhash1=(1ll*sufhash1*Base1%Mod1+b[i][j]-'a'+1)%Mod1;
        }
        Node sufh=(Node){sufhash,sufhash1};
        printf("%d\n",Ask(a[i].c_str(),(int)a[i].size(),sufh));
    }
    return 0;
}
```


---

## 作者：Mirasycle (赞：2)

> 给出一个由 $n$ 个只有小写字母的字符串 $S_i$ 构成的序列。
$m$ 次询问，每次给出一个恰好带通配符的询问串 $T$，求这个串能与多少串 $S_i$ 匹配。通配符可以替换为空串或者某个串。$\sum len \le 3\times10^6,n\le 10^5$。

令 $T=A*B$，其中 $*$ 为通配符。

我们就是要找到有多少 $S_i$ 的前缀为 $A$，后缀为 $B$，长度 $\ge \lvert T\rvert-1$。

需要前后缀都出现，于是对于正反串建立 Trie，前后缀要求就转化为子树 dfs 序范围，然后又要求长度，于是就是三维偏序了。时间复杂度 $O(n\log^2n)$。

还有一个解法，我们对于前缀走 Trie，假设走到了节点 $u$，对于 $u$ 的子节点寻找有无后缀哈希值在子节点中出现。这个直接离线 dfn 序扫描线，由于满足可减性可以不用线段树，直接 $[l,r]=[1,r]-[1,l-1]$ 就行了。用 `std::map` 保存一下哈希值就可以做到 $O(n\log n)$ 了。这个算法能省去一个 $\log$ 的原因是第一个算法只在尾节点处产生贡献，而这个是在串的每个位置都产生一个后缀信息的贡献，这样子就省去对于长度的约束了。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn=3e6+10;
const int maxm=3e6+10;
void chkmax(int &x,int y){ x=x>y?x:y; }
void chkmin(int &x,int y){ x=x<y?x:y; }
struct Que{
	int id,v; ull hh;
}; vector<Que> Q[maxm];
vector<ull> vec[maxn];
int ans[maxn]; map<int,int> S;
struct Hash{
	ull h[maxn],p[maxn];
	void init(char *s,int n){
		p[0]=1; for(int i=1;i<=n;i++) p[i]=p[i-1]*1337;
		for(int i=1;i<=n;i++) 
			if(s[i]!='*') h[i]=h[i-1]*1337+(s[i]-'a'+1);
			else h[i]=h[i-1]*1337;
	}
	ull get(int l,int r){ if(l>r) return 0; return h[r]-h[l-1]*p[r-l+1]; }
}h;
int id(char c){ return c-'a'+1; }
struct Trie{
	int dfn[maxn],ch[maxn][27],sz[maxn],Id[maxn],tot,cnt;
	void init(){ tot=1; cnt=0; }
	void ins(char *s){
		int u=1,m=strlen(s+1);
		for(int i=1;i<=m;i++){
			int x=id(s[i]); vec[u].pb(h.get(i,m));
			if(!ch[u][x]) ch[u][x]=++tot;
			u=ch[u][x];
		}
		vec[u].pb(0);
	}
	int dfs(int u){
		dfn[u]=++cnt; Id[cnt]=u; sz[u]=1;
		for(int i=1;i<=26;i++)
			if(ch[u][i]) sz[u]+=dfs(ch[u][i]);
		return sz[u];
	}
	void find(char *s,int m,ull M,int Id){
		int u=1;
		for(int i=1;i<=m;i++) u=ch[u][id(s[i])];
		if(!u) return ;
		Q[dfn[u]-1].pb((Que){Id,-1,M});
		Q[dfn[u]+sz[u]-1].pb((Que){Id,1,M});
	}
}t; char s[maxn]; int n,q;
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>q; t.init();
	for(int i=1;i<=n;i++){
		cin>>(s+1); h.init(s,strlen(s+1));
		t.ins(s);
	}
	t.dfs(1);
	for(int i=1;i<=q;i++){
		cin>>(s+1); int m=strlen(s+1);
		h.init(s,m); int pos;
		for(int j=1;j<=m;j++)
			if(s[j]=='*') pos=j;
		t.find(s,pos-1,h.get(pos+1,m),i);
	}
	for(int i=1;i<=t.tot;i++){
		for(auto z:vec[t.Id[i]]) S[z]++;
		for(auto z:Q[i]) 
			if(S.find(z.hh)!=S.end()) ans[z.id]+=z.v*S[z.hh];
	}
	for(int i=1;i<=q;i++) cout<<ans[i]<<"\n";
	return 0;
}
```

---

## 作者：小木虫 (赞：2)

### Preface  
提供一个没有在题解区中被提到的小清新做法。  
### Problem  

给定 $N$ 个单词和 $Q$ 个模板，一个模板由一个 `*` 和一些小写字母组成。一个模板覆盖了一个单词当且仅当将 `*` 替换为任意字母后，模板和单词能够完全重合。对于每个模板，求出它能够覆盖多少个单词。

对于 $40\%$ 的数据，$1\le N,Q\le 10^3$；  
对于 $100\%$ 的数据，$1\le N,Q\le 10^5$。

### Solution  
容易发现一个模版 $t$ 能覆盖一个单词 $s$ 当且仅当 $t$ 的前半部分（被星号隔开的）为 $s$ 的前缀，而后半部分为 $s$ 的后缀。  

将单词们按字典序排序后，对于一个字符串 $p$，所有满足有前缀为 $p$ 的字符串形成一个区间，证明可以放到字典树上证明。  

回到原问题，我们先对单词们正向排序再反向排序，可以获得两个值 $(x,y)$，分别为在两次排序当中的排名，我们再把模版正反掰开，对于有前后缀为模版的单词们分别可以二分出两个范围：$[l1,r1],[l2,r2]$，表示在两次排名中的合法排名范围。  

那么这个问题现在被转化成了二维数点问题，但是由于我们还有一个长度的限制，所以实际上是三维数点，点数和矩形数量都是 $O(n)$ 的。  

最终时间复杂度为 $O(n\log^2n+(\sum |s|)\log n)$。

实现用了哈希表实现二维树状数组，常数稍大。  

超美丽代码：  
```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define fir first
#define sec second
#define mp make_pair
#define ull unsigned long long
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+10;
const int M=3e6+10;
int n,q,ans[N],x[N],y[N];
struct str{string s;int id;}a[N],b[N];
struct Qry{int l1,r1,l2,r2,id;}Q[N];
bool cmp1(str a,str b){
	string x=a.s;string y=b.s;
	for(int i=0;i<min(x.size(),y.size());i++)
		if(x[i]!=y[i])return x[i]<y[i];
	if(x.size()!=y.size())return x.size()<y.size();
	else return false;
}
bool cmp2(str a,str b){
	string x=a.s;string y=b.s;
	reverse(x.begin(),x.end());reverse(y.begin(),y.end());
	for(int i=0;i<min(x.size(),y.size());i++)
		if(x[i]!=y[i])return x[i]<y[i];
	if(x.size()!=y.size())return x.size()<y.size();
	else return false;
}
bool cmp3(str a,str b){return a.s.size()>b.s.size();};
int lcp(string s,string t,int op){
	if(op){reverse(s.begin(),s.end());reverse(t.begin(),t.end());}
	for(int i=0;i<min(s.size(),t.size());i++)if(s[i]!=t[i]){return i;}
	return min(s.size(),t.size());
}
gp_hash_table <int,int> t[N];
int lowbit(int x){return x&-x;}
void update(gp_hash_table <int,int> &t,int x,int y){while(x<=n){t[x]+=y;x+=lowbit(x);}}
int query(gp_hash_table <int,int> &t,int x){int res=0;while(x){res+=t[x];x-=lowbit(x);}return res;}
void add(int x,int y,int z){while(x<=n){update(t[x],y,z);x+=lowbit(x);}}
int ask(int x,int l,int r){
	if(l>r)return 0;
	int res=0;while(x){
		res+=query(t[x],r)-query(t[x],l-1);
		x-=lowbit(x);
	}return res;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i].s,a[i].id=i;
	for(int i=1;i<=q;i++)cin>>b[i].s,Q[i].id=b[i].id=i;
	sort(a+1,a+1+n,cmp1);
	for(int i=1;i<=n;i++)x[a[i].id]=i;
	for(int i=1;i<=q;i++){
		str tmp=b[i];
		for(int j=0;j<tmp.s.size();j++){
			if(tmp.s[j]=='*'){
				tmp.s=tmp.s.substr(0,j);
				break;
			}
		}
		int l=lower_bound(a+1,a+1+n,tmp,cmp1)-a;
		int L=l,R=n+1;
		while(L<R){
			int mid=(L+R)>>1;
			if(lcp(tmp.s,a[mid].s,0)!=tmp.s.size())R=mid;
			else L=mid+1;
		}
		int r=L-1;
		Q[i].l1=l,Q[i].r1=r;
	}
	sort(a+1,a+1+n,cmp2);
	for(int i=1;i<=n;i++)y[a[i].id]=i;
	for(int i=1;i<=q;i++){
		str tmp=b[i];
		for(int j=0;j<tmp.s.size();j++){
			if(tmp.s[j]=='*'){
				if(j==tmp.s.size()-1)tmp.s="";
				else tmp.s=tmp.s.substr(j+1,tmp.s.size()-j-1);
			break;}
		}
		int l=lower_bound(a+1,a+1+n,tmp,cmp2)-a;
		int L=l,R=n+1;
		while(L<R){
			int mid=(L+R)>>1;
			if(lcp(tmp.s,a[mid].s,1)!=tmp.s.size())R=mid;
			else L=mid+1;
		}
		int r=L-1;
		Q[i].l2=l,Q[i].r2=r;
	}
	sort(a+1,a+1+n,cmp3);sort(b+1,b+1+q,cmp3);
	for(int i=1,j=1;i<=q;i++){
		while(j<=n&&a[j].s.size()+1>=b[i].s.size())
			add(x[a[j].id],y[a[j].id],1),j++;
		if(Q[b[i].id].l1>Q[b[i].id].r1)continue;
		ans[b[i].id]=ask(Q[b[i].id].r1,Q[b[i].id].l2,Q[b[i].id].r2)-
		ask(Q[b[i].id].l1-1,Q[b[i].id].l2,Q[b[i].id].r2);
	}
	for(int i=1;i<=q;i++)cout<<ans[i]<<"\n";
	return 0;
}
```

---

## 作者：一只绝帆 (赞：2)

尝试用 AC 自动机。

AC 自动机肯定是要把原问题变成简单的匹配问题。

我们发现询问形如 `前缀*后缀`，那我们把他前后换一下，变成 `后缀*前缀`，再把原串变成 `原串*原串`，对询问建立 ACAM，即可用普通字符串匹配来做。

但是发现 `a*a` 会把 `a` 匹配上，所以需要对匹配串长度进行限制。

需要对 $\text{Fail}$ 树上那些长度小于原串（$len\leq \frac{|s|-1}{2}$）的进行权值 +1。

所以我们不断跳 $\text{Fail}$，直到长度符合要求，然后对这些符合要求的点到根的链的并 +1 即可。

求到根的链的并可以按 $\text{Fail}$ 上的 dfs 序排序然后树上前缀和。

有没有更简单一点的做法？

其实不需要到根的链的并，直接加就好，因为本题每个串里都有一个只出现一次的特殊字符，从而不会有一个串包含多次另一个串的情况，也就不需要并起来。

所以不断跳 $\text{Fail}$ 直到符合要求，然后直接对这个点权值 `+1`，最后做树上前缀和即可。

Code：
```cpp
#include<bits/stdc++.h>
#define gc getchar
#define UF(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define F(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define G(i,x) for(int i=start[x];i;i=Next[i])
#define id(c) (c=='*'?26:(c-'a'))
using namespace std;
int read() {
	int s=0,w=0;char c=gc();
	while(c<'0'||c>'9') w|=c=='-',c=gc();
	while(c>='0'&&c<='9') s=s*10+(c^48),c=gc();
	return w?-s:s;
}
bool is(char c) {return c=='*'||c>='a'&&c<='z';} 
void instr(string &s) {
	s.clear();char c=gc();while(!is(c)) c=gc();
	while(is(c)) s+=c,c=gc();
} const int N=3e6+5,M=1e5+5;string s[N],t,t1,t2;int ans[M],n,Q,nxt[N][27],cnt,bfn[N],bfx[N],tot,fa[N],sum[N],len[N],snt,id[M];
vector<int> qu[N];
void buildf() {
	queue<int,list<int>> q;
	F(i,0,26) if(nxt[0][i]) q.push(nxt[0][i]);
	while(!q.empty()) {
		int x=q.front();q.pop();bfx[++tot]=x;
		F(i,0,26) {
			int &id=nxt[x][i],&idf=nxt[fa[x]][i];
			if(id) fa[id]=idf,q.push(id);
			else id=idf;
		}
	}
}
void q(string &s) {
	int now=0,l=s.size();for(char c:s) {
		now=nxt[now][id(c)];
		while(len[now]-1>l/2) now=fa[now];
		sum[now]++; 
	}
}
int main() {
	n=read();Q=read();
	F(i,1,n) instr(s[i]),s[i]=s[i]+'*'+s[i];
	F(i,1,Q) {
		instr(t);t1.clear();t2.clear();
		int now=0,fl=0;for(char c:t) {
			if(c=='*') {fl=1;continue;}
			fl?t1+=c:t2+=c; 
		} t=t1+'*'+t2;for(char c:t) {
			if(!nxt[now][id(c)]) nxt[now][id(c)]=++snt,len[nxt[now][id(c)]]=len[now]+1;
			now=nxt[now][id(c)];
		} id[i]=now;
	} buildf();F(i,1,n) q(s[i]);
	UF(i,tot,1) sum[fa[bfx[i]]]+=sum[bfx[i]];
	F(i,1,Q) printf("%d\n",sum[id[i]]);
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

这个题的意思是说，给定字符集 $S$。每次询问 $S$ 中有多少个串 $T$，满足其前缀为 $A$，后缀为 $B$，且 $|T| \ge |A|+|B|$。

将所有询问写成 $B*A$ 并且插入 AC 自动机中。对于 $S$ 中每个字符串 $T$，将 $T*T$ 在 AC 自动机上遍历，标记所有遍历的点。

如果一个询问在 fail 树上包含了 $T*T$ 经过的节点，那么它就能被 $T$ 覆盖到。所以求出 $T$ 遍历过的所有点的虚树即可。

然后转化为子树内信息查询，可以转 DFS 序之后使用扫描线。

复杂度 $O(n \log n)$。

Warning：本人习惯使用 vector 实现扫描线，空间常数太大难以通过（其实把 vector 换成前向星或者进行归并很容易通过，但是我——懒！）。赌一波 AC 自动机上节点不会太多，事实确实如此。正式比赛当然不能像我这样干。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1.5e6+10;
int n,q,fail[MAXN],lim[MAXN],sze[MAXN],s[MAXN],dep[MAXN],id[MAXN],dfn[MAXN],tot,ans[MAXN],tr[MAXN][27],fa[MAXN][24];
string T[MAXN];
vector<pair<int,int>> upd[MAXN];
vector<pair<int,int>> qr[MAXN];
int lca(int u,int v) {
	if(dep[u]<dep[v]) swap(u,v);
	int dt=dep[u]-dep[v];
	ffor(i,0,22) if(dt&(1<<i)) u=fa[u][i];
	if(u==v) return u;
	roff(i,22,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
int insert(string S) {
	int u=0;
	for(auto ch:S) {
		if(!tr[u][ch-'a']) tr[u][ch-'a']=++tot;
		u=tr[u][ch-'a'];
	}
	return u;
}
vector<int> G[MAXN];
void build(void) {
	queue<int> q;
	ffor(i,0,26) if(tr[0][i]) q.push(tr[0][i]);
	while(!q.empty()) {
		int u=q.front();q.pop();
		dep[u]=dep[fail[u]]+1,fa[u][0]=fail[u],G[fail[u]].push_back(u);
		ffor(i,1,22) fa[u][i]=fa[fa[u][i-1]][i-1];
		ffor(i,0,26) if(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);
		else tr[u][i]=tr[fail[u]][i];
	}
	return ;
}
void dfs(int u) {sze[u]=1,dfn[u]=++tot;for(auto v:G[u]) dfs(v),sze[u]+=sze[v];return ;}
void add(string T,int len) {
	vector<int> p;
	int u=0;
	p.push_back(0);
	for(auto ch:T) u=tr[u][ch-'a'],p.push_back(u);
	sort(p.begin(),p.end()),p.erase(unique(p.begin(),p.end()),p.end());
	sort(p.begin(),p.end(),[&](int A,int B) {return dfn[A]<dfn[B];});
	int lst=-1;
	for(auto id:p) {
		upd[dfn[id]].push_back({len,1});
		if(lst!=-1) upd[dfn[lca(lst,id)]].push_back({len,-1});
		lst=id;
	}
	return ;
}
void update(int pos,int v) {pos=tot-pos+1;while(pos<=tot+1) s[pos]+=v,pos+=pos&-pos;return ;}
int query(int pos) {pos=tot-pos+1;int ans=0;while(pos) ans+=s[pos],pos-=pos&-pos;return ans;}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	ffor(i,1,n) cin>>T[i];
	ffor(i,1,q) {
		string qr;
		cin>>qr;
		string A,B;
		int op=0;
		for(auto ch:qr) {
			if(ch=='*') op=1;
			else if(!op) A+=ch;
			else B+=ch;	
		}
		id[i]=insert(B+"{"+A),lim[i]=qr.size()-1;
	}
	build(),tot=0,dfs(0);
	ffor(i,1,n) add(T[i]+"{"+T[i],T[i].size());
	ffor(i,1,q) qr[dfn[id[i]]-1].push_back({lim[i],-i}),qr[dfn[id[i]]+sze[id[i]]-1].push_back({lim[i],i});
	ffor(i,1,tot) {
		for(auto pr:upd[i]) update(pr.first,pr.second);
		for(auto pr:qr[i]) {
			int lim=pr.first,id=pr.second;
			if(id>0) ans[id]+=query(lim);
			else ans[-id]-=query(lim);	
		}
	}
	ffor(i,1,q) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：ZHONGZIJIE0608 (赞：1)

给你 $n$ 个字符串和 $q$ 个模板，一个模板由若干小写字母和一个通配符 `∗` 组成，对于通配符，你可以把它替换成任意字符串（可以是空串），你需要对于每个模板，问与多少个字符串相同（每个字符串通配符代表的字符串可以不同）。

发现通配符是很不牛的。我们考虑把字符串转化掉，使得用普通的字符串匹配就可以解决问题。

考虑从插入通配符，翻转等变换方法入手。

对于每个文本串 $s_i$，全部转化为 $s_i + \text{*}+s_i$。

对于每个模板 $t_i$，我们将其以通配符为边界分成左右两个部分并将两个部分交换。

这样，我们注意到，如果某个模板可以和某个文本串相同，则更新后这个模板是新的文本串的一个子串，且只会是一个子串（只有一个通配符）。

于是我们把所有模板放进 AC 自动机匹配。

结果挂掉了。为什么会挂掉呢？

考虑到对于一个模板，它匹配的文本串是有长度限制的。文本串必须不能比它去掉通配符的长度还要短。

举个例子，显然模板 `p*p` 是不能匹配文本串 `p` 的。但是进行修改之后，两个串都变成 `p*p`，居然可以匹配上。

所以我们要在查询的时候体现长度限制。怎么体现呢？

考虑先在字典树上把每个点对应的串的长度（就是点的深度）维护好。

然后在查询时一直向上跳 fail 直到长度合法。再打上标记。

势能分析发现复杂度是对的。于是就做到线性了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+10;
int ch[N][30],vis[N],val[N],fail[N],idx[N],dep[N],n,q,tot;
string s,t[N];vector<int>e[N];
void insert(string s,int id){
    int len=s.size(),p=0;
    for(int i=0;i<len;++i){
        int c=s[i]-'a';
        if(s[i]=='*')c=26;
        if(!ch[p][c])ch[p][c]=++tot,dep[ch[p][c]]=dep[p]+1;
        p=ch[p][c];
    }idx[id]=p;
}
void build(){
    queue<int>q;
    for(int i=0;i<27;++i)if(ch[0][i])q.push(ch[0][i]);
    while(!q.empty()){
        int p=q.front();q.pop();
        for(int c=0;c<27;++c){
            if(ch[p][c])fail[ch[p][c]]=ch[fail[p]][c],q.push(ch[p][c]);
            else ch[p][c]=ch[fail[p]][c];
        }
    }
    for(int i=1;i<=tot;++i)e[fail[i]].push_back(i);
}
void qry(string s){
    int len=s.size(),p=0;
    for(int i=0;i<len;++i){
        int c=s[i]-'a';
        if(s[i]=='*')c=26;
        p=ch[p][c];
        while(dep[p]>len/2+1)p=fail[p];
        //模式串长度不会比文本串长度长。
        ++val[p];
    }
}
void dfs(int u){
    vis[u]=val[u];
    for(auto v:e[u]){
        dfs(v);
        vis[u]+=vis[v];
    }
}
signed main(){
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;++i){
        cin>>t[i];t[i]=t[i]+"*"+t[i];
    }
    for(int i=1;i<=q;++i){
        cin>>s;
        string S="",T="";
        bool f=0;
        for(auto c:s){
            if(c=='*'){
                f=1;continue;
            }
            if(!f)S+=c;
            else T+=c;
        }
        s=T+"*"+S;
        insert(s,i);
    }
    build();
    for(int i=1;i<=n;++i)qry(t[i]);
    dfs(0);
    for(int i=1;i<=q;++i)cout<<vis[idx[i]]<<'\n';
    return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：1)

提供一个线段树合并的做法。比较卡空间但是自认为比较无脑，只要套板子就好了。

题意的覆盖就是说如果模板串是 `A*B`  那么所有形如 `A...B` 的单词都是合法的。其中 `A`，`B` 都可以是空串。

显然建 trie 然后根据前缀把 `A` 的匹配匹完，剩下的问题就变为求这个子树中有多少后缀为 `B`。

把后缀用哈希表示，后缀对应的哈希值挂在后缀对应的 trie 节点上。询问变成问一棵子树中一个数的出现次数。

发现每插入一个长度为 $m$ 的串就会增加 $m+1$ 个后缀，所以后缀个数和总字符数阶级是相同的。那么考虑对 trie 存的哈希值离线之后线段树合并统计答案。

因为哈希后值域太大空间会爆炸，我们考虑提前统计只有哪些后缀是我们关注的，这个个数不超过 $10^5$，然后只把这些后缀对应的哈希编号，插入到线段树里面。

复杂度大概是 $O(\sum |s|\log n)$？反正是这个级别大差不差。

代码挺丑。因为换了许多次模数和 base 总是被卡所以一怒之下换成了双哈希，所以代码可读性不是很高？慎读。

```cpp
#include <bits/stdc++.h>
//#define lint __int128
//#define int long long
#define fi first
#define se second
#define pb push_back
#define vec vector
#define Il inline
#define Rg register
#define Ri Rg int
#define IT ::iterator
#define p_que priority_queue

using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
const int N=1e5,M=3e6,ba=41,mod1=1e9+7,mod2=1e9+9;
const db eps=1e-9,pi=acos(-1.0);

int n,Q,iq=0,ans[N+5],qv[M+5],iv=0;
pll ha[N+5],hs[M+5],pw[M+5];
int tr[M+5][26],ti=0;
int si=0,rt[M+5],sm[M*18+5],ls[M*18+5],rs[M*18+5];
string as[N+5],bs[N+5];
map<pll,int>mp;
vec<pii>v[N+5];

Il void add(int ps,int l,int r,int &p){
	if(!p)p=++si;sm[p]++;if(l==r)return;
	int mid=(l+r)>>1;
	if(ps<=mid)add(ps,l,mid,ls[p]);
	else add(ps,mid+1,r,rs[p]);
	return;
}

Il int merge(int x,int y){
	if(!x||!y)return x|y;
	if(!ls[x]&&!rs[x]&&!ls[y]&&!rs[y]){sm[x]+=sm[y];return x;}
	ls[x]=merge(ls[x],ls[y]);rs[x]=merge(rs[x],rs[y]);
	sm[x]=sm[ls[x]]+sm[rs[x]];
	return x;
}

Il int qps(int ps,int l,int r,int p){
	if(!p)return 0;
	if(l==r)return sm[p];
	int mid=(l+r)>>1;
	if(ps<=mid)return qps(ps,l,mid,ls[p]);
	return qps(ps,mid+1,r,rs[p]);
}

Il void ins(string s){
	int m=s.size(),p=0;
	for(Ri i=0;i<m;i++)hs[i+1]={(hs[i].fi*ba%mod1+s[i]-'a'+1)%mod1,(hs[i].se*ba%mod2+s[i]-'a'+1)%mod2};
	for(Ri i=0;i<m;i++){
		int c=s[i]-'a';if(!tr[p][c])tr[p][c]=++ti;
		p=tr[p][c];pll ah={(hs[m].fi-hs[i].fi*pw[m-i].fi%mod1+mod1)%mod1,(hs[m].se-hs[i].se*pw[m-i].se%mod2+mod2)%mod2};
		if(mp.count(ah))add(mp[ah],1,iq,rt[p]);
	}
	add(mp[{0,0}],1,iq,rt[p]);
	return;
}

Il void qur(string s,int is){
	int p=0,m=s.size();
	for(Ri i=0;i<m;i++){
		if(s[i]=='*'){
			if(!qv[p])qv[p]=++iv;
			v[qv[p]].pb({mp[ha[is]],is});
			break;
		}
		int c=s[i]-'a';if(!tr[p][c])return;p=tr[p][c];
	}
	return;
}

Il void uni(int p){//从下往上合并子树
	int trt=0;
	for(Ri i=0;i<26;i++)if(tr[p][i])uni(tr[p][i]),trt=merge(trt,rt[tr[p][i]]);
	for(Rg pii i:v[qv[p]])if(i.fi^1)ans[i.se]=qps(i.fi,1,iq,trt);//统计子树时根算作前缀所以除了空后缀都不能统计到根
	rt[p]=merge(rt[p],trt);
	for(Rg pii i:v[qv[p]])if(i.fi==1)ans[i.se]=qps(i.fi,1,iq,rt[p]);
	return;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	mp[{0,0}]=++iq;pw[0]={1,1};for(Ri i=1;i<=M;i++)pw[i].fi=pw[i-1].fi*ba%mod1,pw[i].se=pw[i-1].se*ba%mod2;
	cin>>n>>Q;for(Ri i=1;i<=n;i++)cin>>as[i];
	for(Ri i=1;i<=Q;i++){
		cin>>bs[i];bool os=0;
		for(Ri j=0;j<bs[i].size();j++){
			if(bs[i][j]=='*')os=1;
			else if(os)ha[i]={(ha[i].fi*ba%mod1+bs[i][j]-'a'+1)%mod1,(ha[i].se*ba%mod2+bs[i][j]-'a'+1)%mod2};
		}
		if(!mp.count(ha[i]))mp[ha[i]]=++iq;
	}
	for(Ri i=1;i<=n;i++)ins(as[i]);
	for(Ri i=1;i<=Q;i++)qur(bs[i],i);
	uni(0);for(Ri i=1;i<=Q;i++)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Reunite (赞：1)

### 一
---

这个匹配等价于 $*$ 之前和之后的部分恰好为模式串的前后缀。

显然有一个建正反 Trie，然后把询问转化成前缀加后缀，然后三维数点做法，复杂度 $\log^2$，显然过不了。

但其实根本不用那么麻烦，我们把所有模式串插入 Trie，同时记录它之后的后缀，然后把询问串 $*$ 之前的部分跑一下 Trie，设最终停在点 $u$，那么 $u$ 子树内所有点都满足询问串前部是其前缀，接下来只需满足后缀。一个性质是一个固定长度的后缀对于每个串只会被统计一次，那直接存一下每个点对应后缀的哈希，就变成了子树内等于某个数的个数。

然后就很简单了，最好写的是询问离线对 $dfn$ 扫描线，显然这个查询具有可差分性，所以我们把子树内的限制转化成了前缀，只需要 map 或者是哈希表就可以做到单 $\log$ 或线性。因为字符集大小 $>\log$，所以没有啥区别。

### 二

时空复杂度均为 $O(n|\sum|)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#define mod 10000000000037
#define ll long long
using namespace std;

int n,m,tot=1,tm;
ll hs[3000005];
ll bin[3000005];
int ans[100005];
char ch[3000005];
int it[3000005];
int dfn[3000005];
int out[3000005];
int son[3000005][26];
vector <ll> h[3000005];
vector <pair <ll,int>> g[3000005];
map <ll,int> mp;

inline ll get(int l,int r){return (hs[r]-((__int128)hs[l-1])*bin[r-l+1]%mod+mod)%mod;}

inline void ins(int len){
	int u=1;
	h[1].emplace_back(get(1,len));
	for(int i=1;i<=len;i++){
		int c=ch[i]-'a';
		if(!son[u][c]) son[u][c]=++tot;
		u=son[u][c];
		h[u].emplace_back((i==len)?0:get(i+1,len));
	}
	return ;
}

inline void init(int u){
	it[dfn[u]=++tm]=u;
	for(int i=0;i<26;i++)
		if(son[u][i]) init(son[u][i]);
	out[u]=tm;
	return ;
}

int main(){
	// freopen("qwq.in","r",stdin);
	n=3000000;
	bin[0]=1;
	for(int i=1;i<=n;i++) bin[i]=bin[i-1]*137%mod;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",ch+1);
		int len=strlen(ch+1);
		for(int j=1;j<=len;j++) hs[j]=(hs[j-1]*137+ch[j])%mod;
		ins(len);
	}
	init(1);
	for(int i=1;i<=m;i++){
		scanf("%s",ch+1);
		int len=strlen(ch+1),u=1,J=0;
		for(int j=1;j<=len&&ch[j]!='*';j++){
			int c=ch[j]-'a';
			if(!son[u][c]){ans[i]=-1;break;}
			J=j;
			u=son[u][c];
		}
		if(ans[i]==-1) continue;
		ll hhs=0;
		for(int j=J+2;j<=len;j++) hhs=(hhs*137+ch[j])%mod;
		g[dfn[u]-1].push_back({hhs,-i});
		g[out[u]].push_back({hhs,i});
	}
	for(int i=1;i<=tm;i++){
		for(ll v:h[it[i]]) mp[v]++;
		for(auto tmp:g[i]) ans[abs(tmp.second)]+=tmp.second/abs(tmp.second)*mp[tmp.first];
	}
	for(int i=1;i<=m;i++) printf("%d\n",max(0,ans[i]));

	return 0;
}
```

---


# [NOI2020] 美食家

## 题目描述

坐落在 Bzeroth 大陆上的精灵王国击退地灾军团的入侵后，经过十余年的休养生息，重新成为了一片欣欣向荣的乐土，吸引着八方游客。小 W 是一位游历过世界各地的著名美食家，现在也慕名来到了精灵王国。

精灵王国共有 $n$ 座城市，城市从 $1$ 到 $n$ 编号，其中城市 $i$ 的美食能为小 W 提供 $c_i$ 的愉悦值。精灵王国的城市通过 $m$ 条**单向道路**连接，道路从 $1$ 到 $m$ 编号，其中道路 $i$ 的起点为城市 $u_i$ ，终点为城市 $v_i$，沿它通行需要花费 $w_i$ 天。也就是说，若小 W 在第 $d$ 天从城市 $u_i$ 沿道路 $i$ 通行，那么他会在第 $d + w_i$ 天到达城市 $v_i$。

小 W 计划在精灵王国进行一场为期 $T$ 天的旅行，更具体地：他会在第 $0$ 天从城市 $1$ 出发，经过 $T$ 天的旅行，最终在**恰好第 $T$ 天**回到城市 $1$ 结束旅行。由于小 W 是一位美食家，每当他到达一座城市时（包括第 $0$ 天和第 $T$ 天的城市 $1$），他都会品尝该城市的美食并获得其所提供的愉悦值，若小 W 多次到达同一座城市，他将**获得多次愉悦值**。注意旅行途中小 W **不能在任何城市停留**，即当他到达一座城市且还未结束旅行时，他当天必须立即从该城市出发前往其他城市。

![](https://cdn.luogu.com.cn/upload/image_hosting/2svum9ge.png)

对于上图，小 W 一种为期 $11$ 天的可行旅游方案为 $1 \to 2 \to 1 \to 2 \to 3 \to 1$：
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $1$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $1$ 出发。
- 第 $4$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $5$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $3$ 出发。
- 第 $7$ 天，小 W 到达城市 $3$，获得愉悦值 $4$ 并向城市 $1$ 出发。
- 第 $11$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并结束旅行。
- 小 W 在该旅行中获得的愉悦值之和为 $13$。

此外，精灵王国会在**不同**的时间举办 $k$ 次美食节。具体来说，第 $i$ 次美食节将于第 $t_i$ 天在城市 $x_i$ 举办，若小 W 第 $t_i$ 天时恰好在城市 $x_i$，那么他在品尝城市 $x_i$ 的美食时会**额外得到** $y_i$ 的愉悦值。现在小 W 想请作为精灵王国接待使者的你帮他算出，他在旅行中能获得的愉悦值之和的**最大值**。

## 说明/提示

#### 样例 1 解释

该样例为题目描述中的例子，最优旅行方案见题目描述。

#### 样例 2 解释

最优方案为 $1 \to 3 \to 4 \to 2 \to 3 \to 4 \to 1$。
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $3$ 并沿道路 $3$ 通行。
- 第 $2$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $5$ 天，小 W 到达城市 $4$，由于美食节获得愉悦值 $20 + 4$ 并沿道路 $7$ 通行。
- 第 $6$ 天，小 W 到达城市 $2$，获得愉悦值 $1$ 并沿道路 $5$ 通行。
- 第 $8$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $11$ 天，小 W 到达城市 $4$，获得愉悦值 $4$ 并沿道路 $8$ 通行。
- 第 $16$ 天，小 W 到达城市 $1$，获得愉悦值 $3$ 并结束旅行。
- 小 W 获得的愉悦值之和为 $39$。

#### 样例 3

见选手目录下的 delicacy/delicacy3.in 与 delicacy/delicacy3.ans。

该样例满足 $k=0$

---

### 测试点约束

对于所有测试点：

$1 \leq n \leq 50$，$n \leq m \leq 501$，$0 \leq k \leq 200$，$1 \leq t_i \leq T \leq 10^9$。

$1 \leq w_i \leq 5$，$1 \leq c_i \leq 52501$，$1 \leq u_i, v_i, x_i \leq n$，$1 \leq y_i \leq 10^9$。

每个测试点的具体限制见下表：

| 测试点编号 |  $n$ |  $m$ |  $T$ | 特殊限制 |
| :-: | :-:| :-: |:-:| :-:|
|  $1\sim 4$ |  $\le 5$ |  $\le 50$ |  $\le 5$ | 无 |
|  $5\sim 8$ |  $\le 50$ |  $\le 50$ |  $\le 52501$ | 无 |
|  $9\sim 10$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | A | 
|  $11\sim 13$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k=0$ |
|  $14\sim 15$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k\le 10$ |
|  $16\sim 17$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | 无 |
|  $18\sim 20$ |  $\le 50$ |  $\le 501$ |  $\le 10^9$ | 无 |

特殊限制 A：$n = m$ 且 $u_i = i,v_i = (i \bmod n) + 1$。

## 样例 #1

### 输入

```
3 4 11 0
1 3 4
1 2 1
2 1 3
2 3 2
3 1 4```

### 输出

```
13```

## 样例 #2

### 输入

```
4 8 16 3
3 1 2 4
1 2 1
1 3 1
1 3 2
3 4 3
2 3 2
3 2 1
4 2 1
4 1 5
3 3 5
1 2 5
5 4 20```

### 输出

```
39```

# 题解

## 作者：duyi (赞：79)

# LOJ3339 「NOI2020」美食家

[题目链接](https://loj.ac/problem/3339)

> 博主有幸参加了NOI2020，考场上的经历和心得请见[这篇文章](https://www.cnblogs.com/dysyn1314/p/13525855.html)。这里就不唠叨了。

## 本题题解

### 朴素DP

考虑前两档部分分，也就是$T$没那么大的时候。我们可以做一个简单的DP。设$dp[i][u]$表示在第$i$天，走到了图上的节点$u$，一路上总共能获得的最大愉悦值。转移时，可以枚举点$u$的一条出边$(u,v,w)$，然后用$dp[i][u]+c[v]$去更新$dp[i+w][v]$，当然，如果第$i+w$天点$v$恰好在举办美食节，还要加上额外产生的愉悦值。

因为保证了$w>0$，所以这个DP满足无后效性，状态非常合理。时间复杂度$O(T(n+m))$，期望得分$40$分。加上环的部分分（简单特判），可以得到$50$分。

### 矩阵优化

因为$T$很大而$n,m,w$都较小，容易想到用矩阵快速幂优化。

对于传统的矩阵乘法，我们是这样定义的：

$$
C=A\times B \Leftrightarrow C[i][j] = \sum_{k=1}^{n}A[i][k]\times B[k][j]

$$


但在本题中，DP的转移不是相加而是取$\max$。我们根据本题中的需要，定义一种新的矩阵乘法，不妨记为$\otimes$：
$$
C=A\otimes B \Leftrightarrow C[i][j] = \max_{k=1}^{n}\{A[i][k]+B[k][j]\}
$$
也就是把原来外层的$+$换成$\max$，把原来内层的$\times$换成$+$。可以证明，这个矩阵乘法仍然是成立的，并且满足原来的种种性质（比如结合律，其实矩阵快速幂优化DP的本质就是用到结合律）。证明略。

值得一提的是，这种重新定义的矩阵乘法，在一类动态DP问题中经常用到。例如[NOIP2018 保卫王国](https://www.luogu.com.cn/problem/P5024)。

---

回到我们的DP。先只考虑$k=0$，也就是没有美食节的情况。

发现从$dp[i][\dots]$转移到$dp[i+w][\dots]$不太好处理（一般的矩阵快速幂优化DP，只会从$i$转移到$i+1$）。但是我们发现$w$很小，$\leq 5$，所以可以考虑把原来的一条边，拆成$w$条边。也就是原本的$(u,v,w)$，拆成：$(u,e_1,w),(e_1,e_2,0),\dots,(e_{w-2},e_{w-1},0),(e_{w-1},v,0)$。这样虽然点数变多了（变成了$n+4m$），但是只会从$i$转移到$i+1$了，可以用矩阵快速幂优化DP。

具体来说，我们根据两个点之间相连的边权（没有边就是$-\inf$，有边边权就是$0$或$w$，前面已经标出），构造一个转移矩阵$G$。则$dp[i]=dp[i-1]\otimes G$。答案就是$dp[T][1] = (dp[1]\otimes G^T)[1]$。

时间复杂度$O((n+4m)^3\log T)$。

注意到$m$可能比$n$大不少，所以可以把**拆边**改成**拆点**。具体来说，把一个点$u$，变成$u_1\to u_2\to \dots \to u_5$的这样一个结构，边权都是$0$。出发点设为$1_1$。对于一条边$(u,v,w)$，我们从$u_w$向$v_1$连一条边权为$c[v]$的边。这样相当于要先从$u_1$走到$u_w$，再从$u_w$走到$v$，刚好经过了$w$条边，也就是起到了从$dp[i]$转移到$dp[i+w]$的效果。

时间复杂度优化为$O((5n)^3\log T)$。可以通过$k=0$的部分分。结合前面的暴力，期望得分$65$分。

### k个美食节怎么处理？

以上的矩阵快速幂，目前还只能处理$k=0$，也就是没有美食节的情况。考虑$k>0$时怎么做。

注意到题目保证了任意两个美食节不在同一天举办。所以可以先将美食节按举办时间从小到大排序。然后在任意两个美食节之间，做一遍普通的DP转移。例如，第$j$个美食节的举办日期为$t_j$，第$j-1$个美食节举办日前为$t_{j-1}$，则这段的转移就是：$dp[t_{j}] = dp[t_{j-1}]\otimes G^{t_{j}-t_{j-1}}$。转移完成后，再令$dp[t_j][x_j]\texttt{+=}y_j$。也就是加上了美食节的贡献。

最后，如果$t_k\neq T$，再从$dp[t_k]$转移到$dp[T]$就行。

直接按此做法实现的话，时间复杂度$O(k\cdot (5n)^3\cdot \log T)$。可以通过$k\leq 10$的部分分，结合前面的暴力，期望得分$75$分。

### 进一步优化

我们发现所做的$k$次转移，每次都是乘以同一个转移矩阵的若干次幂。

我们考虑把【$G$的【$2$的次幂】次幂】（也就是$G^1,G^2,G^4,G^8,G^{16},\dots ,G^{2^{29}}$）预处理出来。预处理的时间复杂度为$O((5n)^3\log T)$。

然后，在做每个美食节的转移时，对$(t_j-t_{j-1})$这个数做二进制分解，设$t_j-t_{j-1}=2^{p_1}+2^{p_2}+\dots +2^{p_l}$，也就是$p_1\dots p_l$这些二进制位上为$1$。那么我们只需要用$dp[t_{j-1}]$，依次乘以预处理好的$G^{2^{p_1}},G^{2^{p_2}},\dots,G^{2^{p_l}}$，即可得到$dp[t_j]$。而因为$dp[i]$是一个$1\times 5n$的“长条”（又叫向量）而不是一个真正的矩阵，所以每次乘法的时间复杂度只有$O((5n)^2)$。所有转移的总复杂度$O(k\cdot (5n)^2\cdot \log T)$。

总时间复杂度$O((5n)^3\log T+ k\cdot (5n)^2\log T)$。

这个优化方法和[NOI Online 3 魔法值](https://www.luogu.com.cn/problem/P6569)这题很类似。

### 参考代码

[在LOJ查看](https://loj.ac/submission/914048)

友情提醒，在LOJ提交时，记得开``freopen``，也就是和考场上要求一样。

```cpp
//problem:LOJ3339
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN = 50, MAXM = 501, MAXW = 5, MAXK = 200;
const int LOGT = 29;
const int MT_SIZE = MAXN*5;
const ll LL_INF = 1e18;

struct Matrix{
	ll a[MT_SIZE+5][MT_SIZE+5];
	int size;
	void identity() {
		for(int i=1;i<=size;++i) {
			for(int j=1;j<=size;++j){
				a[i][j] = (i==j ? 0 : -LL_INF);
			}
		}
	}
	Matrix(){
		for(int i=1;i<=MT_SIZE;++i)
			for(int j=1;j<=MT_SIZE;++j)
				a[i][j] = -LL_INF;
		size=0;
	}
};
Matrix operator * (const Matrix& A, const Matrix& B) {
	Matrix C;
	assert(A.size==B.size);
	C.size = A.size;
	for(int i=1;i<=A.size;++i){
		for(int j=1;j<=A.size;++j){
			for(int k=1;k<=A.size;++k){
				if(A.a[i][k] == -LL_INF || B.a[k][j] == -LL_INF)
					continue;
				ckmax(C.a[i][j], A.a[i][k]+B.a[k][j]);
			}
		}
	}
	return C;
}
Matrix mat_pow(Matrix X,int i) {
	Matrix Y;
	Y.size = X.size;
	Y.identity();
	while(i){
		if(i&1)
			Y=Y*X;
		X=X*X;
		i>>=1;
	}
	return Y;
}

int n,m,T,K,c[MAXN+5];
int id[MAXN+5][MAXW+5],cnt_id;

struct Event{
	int t,u,w;
	bool operator < (const Event& rhs) const {
		return t < rhs.t;
	}
}ev[MAXK+5];

Matrix trans,pow_of_trans[LOGT+1];
void init_pow_of_trans() {
	pow_of_trans[0] = trans;
	for(int i=1; i<=LOGT; ++i) {
		pow_of_trans[i] = pow_of_trans[i-1] * pow_of_trans[i-1];
	}
}
void mul_pow_of_trans(Matrix& A, int mi) {
	// O(size^2 * log k)
	for(int bit=0; bit<=LOGT; ++bit) {
		if((mi>>bit) & 1) {
			//向量乘矩阵
			Matrix res;
			res.size=A.size;
			for(int j=1; j<=A.size; ++j) {
				for(int k=1; k<=A.size; ++k) {
					if(A.a[1][k] == -LL_INF || pow_of_trans[bit].a[k][j] == -LL_INF)
						continue;
					ckmax(res.a[1][j], A.a[1][k] + pow_of_trans[bit].a[k][j]);
				}
			}
			A = res;
		}
	}
}

int main() {
//	freopen("delicacy.in", "r", stdin);
//	freopen("delicacy.out", "w", stdout);
	cin >> n >> m >> T >> K;
	for(int i=1;i<=n;++i) {
		cin >> c[i];
	}
	trans.size = n*5;
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=5;++j) {
			id[i][j] = ++cnt_id;
		}
		for(int j=1;j<5;++j) {
			trans.a[id[i][j]][id[i][j+1]] = 0;
		}
	}
	for(int i=1;i<=m;++i) {
		int u,v,w;
		cin >> u >> v >> w;
		trans.a[id[u][w]][id[v][1]]=c[v];
	}
	for(int i=1; i<=K; ++i) {
		cin >> ev[i].t >> ev[i].u >> ev[i].w;
	}
	sort(ev+1, ev+K+1);
	
	Matrix A;
	A.size = n*5;
	A.a[1][id[1][1]] = c[1];
	init_pow_of_trans();
	
	int last_time = 0;
	for(int i=1; i<=K; ++i) {
		mul_pow_of_trans(A, ev[i].t - last_time);
		// 相当于: A = A * mat_pow(trans, ev[i].t - last_time);
		if(A.a[1][id[ev[i].u][1]] != -LL_INF) {
			A.a[1][id[ev[i].u][1]] += ev[i].w;
		}
		last_time = ev[i].t;
	}
	if(last_time != T) {
		mul_pow_of_trans(A, T - last_time);
	}
	if(A.a[1][id[1][1]] == -LL_INF)
		cout << -1 << endl;
	else
		cout << A.a[1][id[1][1]] << endl;
	return 0;
}
```



---

## 作者：Lice (赞：17)

### Description

给定一张有向图，$n$ 个顶点，$m$ 条边。第 $i$ 条边从 $u_i$ 到 $v_i$，走完该边的用时为 $w_i$。每一个点有一个价值 $c$，走到点 $i$ 可以得到 $c_i$ 的价值。

初始时间为 $0$，你需要从起点 $1$ 开始，走出一个回到 $1$ 的有向环，耗时恰好为 $T$。最终得到的价值为所有经过的点的价值和。注意这里的环可以经过同个顶点多次，价值和也会被计算多次。

现在有 $k$ 个附加元素，第 $i$ 个附加元素有三个参数：$(t_i, x_i, y_i)$。表示当恰好在 $t_i$ 时间点到达顶点 $x_i$ 时，可以得到 $y_i$ 的额外的价值。

求最大的最终价值和。

### Hint

- $1\le n\le 50$
- $n\le m\le 501$
- $0\le k\le 200$
- $1\le t_i\le T\le 10^9$
- $1\le w_i\le 5$
- $1\le c_i\le 52501$
- $1\le y_i\le 10^9$

### Solution

首先有一个简单朴素的动态规划：$f(t, x)$ 表示在 $t$ 时间点，走到顶点 $x$ 时，可以得到的最大价值和。显然有：
$$
f(t, x) = \max\limits_{(y, x, w) \in \text E} \{f(t-w, y)\} + c_x + g(t, x)
$$
其中 $g(t, x)$ 表示 $t$ 时间顶点 $x$ 的附加值（美食节），如果没有就是 $0$。

这个做法是 $O(m\times T)$ 的，期望 $40\ \text{pts}$。

--------------------------

考虑优化。为了方便，$k$ 个额外的我们会在最后讨论，以下都假设 $k=0$。

我们发现，如果 $w_i = 1$，那么所有边的转移都是“**一步到位**”的，不存在走了一天还在路上这种东西。那么这样显然可以 **矩阵乘法** 优化。

具体的，就是假设矩阵 $B_t = \begin{bmatrix}f(t, 1)\\f(t, 2)\\ \vdots \\ f(t, n) \end{bmatrix}$，即时间点 $t$ 下的所有状态。我们需要构造一个转移矩阵 $A$，使得 $B_{t+1} = A\circ B_t$。其中 $\circ$ 为自定义的一种“广义矩阵乘法”，计算公式即为上述状态转移方程：$c_{i, j} = \max_{1\le k\le n} \{a_{i, k} + b_{k, j}\}$。可以证明这样定义一定满足结合律。（$A^x = A\circ A\circ \cdots \circ A$，$x$ 个 $A$）

不难发现转移的条件是边存在，于是 $A$ 就是 **反图** （带上价值）的邻接矩阵。为什么是反图？因为这里 $A_{u, v}$ 的含义是 $u$ 从 $v$ 转移而来得到的价值 $c_u$，并不是 $u\to v$ 转移过去。

那么直接矩阵快速幂即可，$B_t = A^t \circ B_0$，答案即为 $(B_t)_{1, 1}$ 的值，复杂度 $O(n^3\log T)$。

--------------------------

然而边长 $w$ 并不是一，~~为了不让我们前面的努力白费，~~ 我们尝试着将原图的边权“变成”$1$。本题中有一个突破口：$w\le 5$，那么我们的机会来了。

拆边？我们发现点数的规模会达到 $O(mw+n)$，不可承受。所以选择拆点。

我们把点 $u$ 拆成五个：$u_1, u_2, u_3, u_4, u_5$，然后连边 $u_1\to u_2\to u_3\to u_4\to u_5$，边权都为 $0$，边长为 $1$，表示这些拆出来的边不会对答案有贡献。更新转移矩阵 $A_{u_w, u_{w-1}} = 0$。

如果原图中有一条边 $(u, v, w)$，那么我们实际的连边为 $u_w \to v_1$。不难发现，长度为 $w$ 的边正好被分为了 $w$ 段长度为 $1$ 的边。然后更新转移矩阵 $A_{v, u_{w}} = c_u$。

最后得到了一个 $(nw)^2$ 大小的矩阵。

那么现在有了一个应付 $k=0$ 的数据的做法。

--------------------------------

考虑如何加入附加元素（美食节）的影响。发现整个时间段 $[0, T]$ 被时间点 $t_1, t_2, \cdots , t_k$ 分为了一些段，那我们不如 **一段段** 地做。

具体的，当 $t_{i-1}$ 刚做好时，我们直接跳到 $t_i$，然后在点 $x_i$ 的对应值加上 $y_i$。于是问题被完美地解决了……

显然还没有。这里有两个问题：

- $x_i$ 加到那个点上？
- 复杂度好像有点炸……

下面给出解决方案：

- 由于我们进行了拆点操作，点 $x_i$ 应对于 $5$ 个点中的哪一个呢？假设有一条 $u_1 \to u_4 \to v_1$ 的路径，其对应的原图的边其实是 $(u, v, 4)$。对于点 $u_4$ 而言，**它的实际含义其实是“在路上”**。对于 $u_2, u_3, u_5$ 同理。可见只有点 $u_1$ 才是真正原图上的顶点。于是一个把 $y_i$ 加在 $(x_i)_1$ 的位置上。
- 算一下复杂度？我们最多有 $k$ 次，每次 $\log (t_i - t_{i-1})$ 次矩阵（方阵×方阵）乘法，总复杂度为 $O((nw)^3\sum \log (t_i - t_{i-1}))$。也就是说 **我们可能会做** $200$ **多次矩阵快速幂！** 这里会用到一个神奇优化，详情见下：

-----------------------------

我们预处理出 $A$ 之后，再计算一个 $P$。其中 $P_i = A^{2^i}$。显然 $P_i = P_{i-1}^2$，可以在 $O((nw)^3\log T)$ 的时间内求出。

然后尝试着用 $P$ 替代矩阵快速幂。我们考虑一下，我们需要求 $B \circ A^x$ 的时候，快速幂是先计算 $A^x$ 的，其中原理是 $A^x = A^{e_1} \circ A^{e_2} \circ \cdots \circ A^{e_q}$，其中 $e$ 是 $x$ 二进制下的所有为 $1$ 的位分别独立取出的值。而我们现在已经预处理好了这些 $P$，如果我们直接用 $B$ 每次对 $P$ 做乘法，结果是一样的。

但这两者又有什么区别呢？当然有！我们发现 $B$ 是一个 **列向量**，这个东西乘上 $A$ 一次是 **平方级别** 的！

现在我们可以做到一次跳时间点 $O((nw)^2\log(t_i - t_{i-1}))$，已经可以通过了。

总复杂度 $O((nw)^3\log T + (nw)^2\sum\log(t_i - t_{i-1}))$。

### Code

```cpp
/*
 * Author : _Wallace_
 * Source : https://www.cnblogs.com/-Wallace-/
 * Problem : NOI2020 LOJ #3339 Luogu P6772 美食家
 */
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;
typedef long long LL;

const int N = 50 + 5;
const int W = 5;
const int logT = 31;
const int K = 200 + 5;
const LL inf = 5e16;

int n, m, T, k;
int c[N];
struct activity {
    int t, x, y;
} act[K << 1];

struct matrix {
    LL e[N * W][N * W];
    int R, C;
    inline LL* operator [] (int p) { return e[p]; }
    inline void set(LL v) {
        for (int i = 1; i <= R; i++)
            for (int j = 1; j <= C; j++)
                e[i][j] = v;
    }
} A, B, P[logT];
// P[k] : A^{2^k}

inline matrix operator * (matrix a, matrix b) {
    matrix c; c.R = a.R, c.C = b.C;
    c.set(-inf);
    for (int k = 1; k <= a.C; k++)
        for (int i = 1; i <= a.R; i++)
            for (int j = 1; j <= b.C; j++)
                c[i][j] = max(c[i][j], a[i][k] + b[k][j]);
    return c;
}

void trans(matrix& B, int t) {
    if (!t) return;
    for (int i = 0; i < logT; i++) 
        if ((t >> i) & 1)
            B = P[i] * B;
}

signed main() {
    freopen("delicacy3.in", "r", stdin);
  //  freopen("delicacy.out", "w", stdout);

    ios::sync_with_stdio(false);
    cin >> n >> m >> T >> k;

    A.R = A.C = n * 5;
    A.set(-inf);

    for (int i = 1; i <= n; i++)
        for (int w = 1; w < W; w++)
            A[i + n * w][i + n * (w - 1)] = 0;
    for (int i = 1; i <= n; i++)
        cin >> c[i];
    for (int i = 1; i <= m; i++) {
        int u, v, w; cin >> u >> v >> w;
        A[v][u + n * (w - 1)] = c[u];
    }
    for (int i = 1; i <= k; i++)
        cin >> act[i].t >> act[i].x >> act[i].y;

    P[0] = A;
    for (int i = 1; i < logT; i++)
        P[i] = P[i - 1] * P[i - 1];
    B.R = n * 5, B.C = 1;
    B.set(-inf);
    B[1][1] = 0;

    sort(act + 1, act + 1 + k, [](activity& a, activity& b) {
        return a.t < b.t;
    });
    int curT = 0;
    for (int i = 1; i <= k; i++) {
        int gap = act[i].t - curT;
        trans(B, gap);
        B[act[i].x][1] += act[i].y;
        curT = act[i].t;
    }
    trans(B, T - curT);

    LL ans = B[1][1] + c[1];
    cout << (ans < 0 ? -1 : ans) <<endl;
    return 0;
}
```


---

## 作者：Time_tears (赞：14)

~~一道比较模板的矩阵套矩阵吧~~

- 题外话

这道题坑就坑在复杂度算起来有点毒瘤（可能是本人太菜了），一开始把复杂度算成 $O(n^3\times \log T\times200)$ ，导致花费大量时间在无用的优化快速幂上，其实就是自己傻*了。

- 引言

其实和这道题很像的是 [[BJOI2017]魔法咒语](https://www.luogu.com.cn/problem/P3715) ，也是矩阵套矩阵，只不过是一个 $ACAM$ 上的 $Dp$ ，本人就是靠这道题获得了解题灵感

- 算法 $1$： $O(m \times T)$ 算法

这个算法就是一个普通的 $Dp$ ，设 $f_{i,j}$ 表示第 $i$ 天，在第 $j$ 号点的最大愉悦值，转移方程很简单 $f_{i+val[x][y],y}=\max( f_{i,x} )+c[y]$ 只需要在有美食节的那一天把 $c[y]$ 加上一个定值就可以了，这样可以获得 $40$ 的~~高分~~。

- 算法 $2$：$9 - 10$ 号测试点

这个测试点直接暴力走环就可以了，结合算法 $1$ 可以得到 $50$ 分

- 算法 $3$：$11 - 13$ 号测试点

这个测试点就要开始使用矩阵乘法了，我们不妨考虑把 $f$ 写成矩阵的形式，令 $ans_{1-n}$ 表示 $f$ 数组某天的取值，但是这样就会出现转移丢失的问题，要是有边权不为 $1$ 的边，普通的矩阵快速幂就无法工作了，这个时候就需要拆点的矩阵快速幂了，如何拆点呢？

我们不妨考虑这样一个数组

$f_{0,1},f_{0,2},...,f_{0,n},f_{1,1},...,f_{1,n},...,f_{4,n}$ ，我们强行把五天的 $f$ 值记录在一起，然后就可以进行转移了，为什么呢，因为边权最大是 $5$ ！！！

转移矩阵如下：（本人美术功力有限）

![](https://cdn.luogu.com.cn/upload/image_hosting/mm1w8e2w.png?x-oss-process=image/resize,m_lfit,h_600,w_600)

红色的 $1,2,3,4,5$ 就表示边权为（注意！！！！！！此处本人图画错了）$5,4,3,2,1$ 的转移矩阵，然后这个地方的矩阵快速幂不是普通的，他的矩阵是比较大小（做过动态 $Dp$ 的应该比较好理解），这个待会可以结合 $code$ 来理解，结合算法 $1,2$ 可以拿到 $65$ 分。

- 算法 $4$：正解

因为有美食节的存在，导致我们不能直接快速幂了，但是美食节仅仅只有 $200$ 个，我们为什么不能对于每一段都分别快速幂，再按照美食节一个一个合起来呢？这样的话时间复杂度就是美妙的 $O((5n)^2 \times \log T \times k)$ 了！但是要预处理 $2$ 的幂次，这部分的复杂度是 $O((5n)^3 \times \log T )$，所以总复杂度就是 $O((5n)^2 \times \log T \times k + (5n)^3 \times \log T)$，可以通过 ，本人代码是把第 $0$ 天乘到了第 $i$ 天，但是在判有无美食节时需要加四，这个大家想想为什么吧，应该很好理解。

* 后记

本人考场浪费了大量时间在 $T1$ 上，结果最后只有 $95$ 分，$-1$ 真是害死人啊，希望明年能好好考 $NOI$ 同步赛 甚至是 $NOI$。

* $code$

```cpp
#include<bits/stdc++.h>
#define N 255
#define pr pair<int,int>
#define mp make_pair
using namespace std;
const long long inf=(1ll<<60);
int np[6][N][N];
int n,m,T,kk,c[N],t[N];
long long f[6][N];
struct node {
	int t,x,y;
	bool operator <(node a) const {
		return t<a.t;
	}
} p[N],a[N];
struct Array {
	int n,m;
	long long a[255][255];
	Array operator *(Array A) const {
		Array c;
		c.n=n,c.m=A.m;
		for(int i=1; i<=c.n; ++i)
			for(int j=1; j<=c.m; ++j)c.a[i][j]=-inf;
		for(int i=1; i<=c.n; ++i)
			for(int k=1; k<=m; ++k)
				if(a[i][k]>=0)for(int j=1; j<=c.m; ++j)c.a[i][j]=max(c.a[i][j],a[i][k]+A.a[k][j]);
		return c;
	}
} arr[31],ans,bn;
inline int read() {
	int s=0,f=0;
	char ch=getchar();
	while(ch<48||ch>57)f=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
void MMul(int x) {
	for(int i=0; (1<<i)<=x; ++i)if(x>>i&1)ans=ans*arr[i];
}
int main() {
	n=read(),m=read(),T=read(),kk=read();
	for(int i=1; i<=n; ++i)c[i]=read();
	for(int i=1; i<=m; ++i)a[i].x=read(),a[i].y=read(),a[i].t=read(),np[a[i].t][a[i].x][a[i].y]=1;
	for(int i=1; i<=kk; ++i)p[i].t=read(),p[i].x=read(),p[i].y=read();
	sort(p+1,p+kk+1);
	memset(f,-0x3f,sizeof(f)),f[0][1]=c[1];
	for(int i=1,j=1; i<=4; ++i) {
		if(i==p[j].t)c[p[j].x]+=p[j].y;
		for(int k=1; k<=m; ++k)
			if(a[k].t<=i)f[i][a[k].y]=max(f[i][a[k].y],f[i-a[k].t][a[k].x]+c[a[k].y]);
		if(i==p[j].t)c[p[j].x]-=p[j].y,++j;
	}
	ans.n=1,ans.m=n*5;
	for(int i=0; i<=4; ++i)
		for(int j=1; j<=n; ++j)ans.a[1][i*n+j]=f[i][j];
	arr[0].n=arr[0].m=n*5;
	memset(arr[0].a,-0x3f,sizeof(arr[0].a));
	for(int i=n+1; i<=ans.m; ++i)arr[0].a[i][i-n]=0;
	for(int i=1; i<=5; ++i)
		for(int j=1; j<=n; ++j)
			for(int k=1; k<=n; ++k)if(np[i][j][k])arr[0].a[j+(5-i)*n][k+4*n]=c[k];
	for(int i=1; i<=30; ++i)arr[i]=arr[i-1]*arr[i-1];
	int num=1,tt=4;
	while(num<=kk&&p[num].t<=4)++num;
	while(num<=kk) {
		if(tt<p[num].t-1)MMul(p[num].t-tt-1),tt=p[num].t-1;
		bn=arr[0];
		for(int K=1; K<=5*n; ++K)bn.a[K][p[num].x+4*n]+=p[num].y;
		ans=ans*bn,++num,++tt;
	}
	if(tt<=T+4)MMul(T+4-tt);
	printf("%lld",max(ans.a[1][1],-1ll));
	return 0;
}
```


---

## 作者：zhoukangyang (赞：9)

## 蒟蒻语
wtcl, 只会最简单的题目

这道题目与 [P6569 [NOI Online #3 提高组]魔法值（民间数据）](https://www.luogu.com.cn/problem/P6569) 类似, 都是倍增优化矩阵乘法。
## 蒟蒻解
首先观察数据, 看到 $w_i \le 5$, 可以想到储存下前 $5$ 天的状态, 从而推出现在的状态。

显然着这样是 $O(nwT)$ 的, 不可通过次题。

但是考虑到 $n$ 很小, 可以使用矩阵乘法优化。然后按照图建立矩阵 $a$。大概是这样子的：

原来的数组（$now$表示转移结束后的状态）：

| $now-5$ | $now-4$ | $now-3$ | $now-2$ | $now-1$ |
| -----------: | -----------: | -----------: | -----------: | -----------: |

要变成：

| $now-4$ | $now-3$ | $now-2$ | $now-1$ | $now$ |
| -----------: | -----------: | -----------: | -----------: | -----------: |

转移矩阵 $a$ :

| $0$ | $0$ | $0$ | $0$ | $w = 5$ 的转移 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| $S$ | $0$ | $0$ | $0$ | $w = 4$ 的转移 |
| $0$ | $S$ | $0$ | $0$ | $w = 3$ 的转移 |
| $0$ | $0$ | $S$ | $0$ | $w = 2$ 的转移 |
| $0$ | $0$ | $0$ | $S$ | $w = 1$ 的转移 |

$S$ 表示单位矩阵

形如这样子的：

| $1$ | $0$ | $0$ |
| -----------: | -----------: | -----------: |
| $0$ | $1$ | $0$ |
| $0$ | $0$ | $1$ |


矩阵快速幂即可。时间复杂度为 $O((nw)^3\log T)$

但是这只是没有美食节的情况, $k = 0$。对于每次美食节, 可以先把答案算到美食节的时间 $-1$。然后对原来建立的矩阵进行矩阵快速幂, 时间复杂度 $O(k(nw)^3logT)$, 不可通过本题。

考虑继续优化。矩阵快速幂多次计算了一个矩阵的 $2^t$ 次方, 考虑优化调这个时间。倍增预处理出原矩阵的 $2^t$ 次方。这部分的代码：
```cpp
void build() {
    btd[0] = a; // btd 是倍增矩阵。
    for(int i = 1; i <= 30; i++) btd[i] = btd[i - 1] * btd[i - 1]; 
    // 利用2^{t-1}矩阵的信息处理出2^t的矩阵。
}
```
求值时拿原来的序列乘以需要乘的矩阵。那么这部分的代码是：
```cpp
void get(ll *f, int b) {
    for(int i = 0; i <= 30; i++) if(b & (1 << i)) cf(f, btd[i]);
    // cf : 乘法， 代表数组(1*(nw)的矩阵)乘以矩阵
}
```
预处理时间复杂度是 $(nw^3)\log T$, 而单次求值是 $(nw^2)logT$, 求 $m$ 次就是 $m(nw)^2 \log T$, 总时间复杂度是 $(nw^3)\log T + m(nw)^2 \log T$, 可以通过本题。

## 蒟蒻码
```cpp
int mn;
struct M {
    ll a[255][255];
} a;
M clear() {
    M res;
    for(int i = 1; i <= mn; i++) for(int j = 1; j <= mn; j++) res.a[i][j] = -inf;
    return res;
}
M operator * (M aa, M bb) {
    M res = clear();
    for(int i = 1; i <= mn; i++) 
        for(int j = 1; j <= mn; j++) 
            for(int k = 1; k <= mn; k++)
                res.a[i][j] = max(res.a[i][j], aa.a[i][k] + bb.a[k][j]);
    return res;
}
M btd[33];
void cf(ll *f, M b) {
    ll fz[255];
    for(int i = 1; i <= mn; i++) fz[i] = f[i], f[i] = -inf;
    for(int i = 1; i <= mn; i++) 
        for(int j = 1; j <= mn; j++) 
            f[i] = max(f[i], fz[j] + b.a[j][i]);
}
void get(ll *f, int b) {
    for(int i = 0; i <= 30; i++) if(b & (1 << i)) cf(f, btd[i]);
}
void build() {
    btd[0] = a;
    for(int i = 1; i <= 30; i++) btd[i] = btd[i - 1] * btd[i - 1];
}
struct node {
    int t, x, y;
} msj[2333];
bool cmp(node aa, node bb) {
    return aa.t < bb.t;
}
int T, n, m, k, c[55];
ll ans[255];
int main() {
    scanf("%d%d%d%d", &n, &m, &T, &k), mn = n * 5;
    for(int i = 1; i <= n; i++) scanf("%d", &c[i]);
    a = clear();
    for(int i = 1; i <= 4 * n; i++) a.a[i + n][i] = 0;
    for(int i = 1; i <= m; i++) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        a.a[u + n * (5 - w)][v + n * 4] = c[v];
    }
    build();
    for(int i = 1; i <= k; i++) 
        scanf("%d%d%d", &msj[i].t, &msj[i].x, &msj[i].y);
    sort(msj + 1, msj + k + 1, cmp);
    for(int i = 1; i <= mn; i++) ans[i] = -inf;
    ans[n * 4 + 1] = c[1];
    for(int i = 1; i <= k; i++) {
        get(ans, msj[i].t - msj[i - 1].t - 1);
        M master = a;
        for(int j = 1; j <= mn; j++) master.a[j][4 * n + msj[i].x] += msj[i].y;
        cf(ans, master);
    }
    get(ans, T - msj[k].t);
    if(ans[n * 4 + 1] < 0ll) puts("-1");
    else printf("%lld\n", ans[n * 4 + 1]);
    return 0;
}
```

---

## 作者：s_r_f (赞：8)

考虑拆点$,$把每个点拆成$5$个点$,$ $p_{i,t}(0\leq t \leq 4)$表示$t$秒之后到达点$i.$

对于每个正整数$t,$把所有的$p_{i,t}$连向$p_{i,t-1}.$

然后每一条边$(x,y,t)$就可以变成$(p_{x,0},p_{y,t-1}),$就可以矩阵乘法来维护这个东西了$.$

不难据此得到转移矩阵$A.$

然后我们相当于要向量乘矩阵$,$一共需要乘$k$次$A$的若干次方$,$那么我们预处理一下$A^2,A^4,A^8,...A^{2^{30}}$即可$.$

复杂度$O((nw)^3 \log T+k(nw)^2 \log T).$

代码$:$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 50,M = 505,K = 205,V = 250;
const LL INF = 1ll << 60;

int L;
struct Mat{
	LL a[V][V];
	inline void init(){
		for (int i = 0; i < L; ++i) for (int j = 0; j < L; ++j) a[i][j] = -INF;
	}
};
struct Vec{
	LL a[V];
	inline void init(){
		for (int i = 0; i < L; ++i) a[i] = -INF;	
	}
};
Mat operator * (const Mat A,const Mat B){
	static Mat T; T.init();
	for (int k = 0; k < L; ++k) for (int i = 0; i < L; ++i) for (int j = 0; j < L; ++j)
		if (A.a[i][k] + B.a[k][j] > T.a[i][j]) T.a[i][j] = A.a[i][k] + B.a[k][j];
	return T;
}
Vec operator * (const Mat A,const Vec B){
	static Vec T; T.init();
	for (int i = 0; i < L; ++i) for (int j = 0; j < L; ++j)
		if (A.a[j][i] + B.a[j] > T.a[i]) T.a[i] = A.a[j][i] + B.a[j];
	return T;
}

int n,m,T,k,c[N];
int ex[M],ey[M],ez[M];
Mat I,Tr,A[30];
Vec st; int nowt;
int id[N][5];
struct Festival{
	int t,x,y;
}ev[K];
int main(){
//	freopen("delicacy.in","r",stdin);
//	freopen("delicacy.out","w",stdout);
	int i,j;	
	cin >> n >> m >> T >> k;
	I.init(); L = n * 5;
	for (i = 0; i < n; ++i) cin >> c[i];
	for (i = 0; i < n; ++i) I.a[i][i] = 0;
	for (i = 0; i < n; ++i) for (j = 0; j < 5; ++j) id[i][j] = j * n + i;
	for (i = 1; i <= m; ++i) cin >> ex[i] >> ey[i] >> ez[i],--ex[i],--ey[i];
	Tr.init();
	for (i = 0; i < n; ++i)
	for (j = 1; j < 5; ++j) Tr.a[id[i][j]][id[i][j-1]] = (j==1) ? (c[i]) : (0);
	for (i = 1; i <= m; ++i) Tr.a[id[ex[i]][0]][id[ey[i]][ez[i]-1]] = (ez[i]==1) ? (c[ey[i]]) : (0);
	A[0] = Tr;
	for (i = 1; i < 30; ++i) A[i] = A[i-1] * A[i-1];
	
	for (i = 1; i <= k; ++i) cin >> ev[i].t >> ev[i].x >> ev[i].y,--ev[i].x;
	for (i = 1; i <= k; ++i) for (j = i+1; j <= k; ++j) if (ev[j].t < ev[i].t) swap(ev[i],ev[j]);
	if (ev[k].t != T){ ++k; ev[k].t = T,ev[k].x = ev[k].y = 0; }	
	st.init(); st.a[id[0][0]] = c[0]; nowt = 0;
	for (i = 1; i <= k; ++i){
		int dt = ev[i].t - nowt;
		for (j = 0; j < 30; ++j) if (dt>>j&1) st = A[j] * st;
		if (st.a[ev[i].x] >= 0) st.a[ev[i].x] += ev[i].y; 
		nowt = ev[i].t;
	}
	if (st.a[0] < 0) st.a[0] = -1;
	cout << st.a[0] << '\n';
}
```

---

## 作者：万弘 (赞：8)

### Day1 T1 delicacy

给一个 $ n $ 个点的有向图,点有价值.有 $ m $ 条边,经过它要消耗 $ w_i $ 的时间.每次经过一个点时可以获得其价值(可重复获得).特别的,有 $ k $ 条形如  $  (t,x,y)  $  的活动,当 $ t $ 时刻在点 $ x $ 处时可额外获得 $ y $ 的价值.求在0时刻从点1出发,并在 $ T $ 时刻到点1能获得的最大价值.

 $ n\le 50,T\le 10^9,k\le 200,1\le w_i\le 5 $ 

有启发性的两个subtask: $ T\le 52501; $  $ k=0 $ 

解:    

对于 $ T\le 52501 $ ,直接dp即可.记 $ f(i,j)  $  表示 $ j $ 时刻在点 $ i $ 的最大价值.复杂度  $  \mathcal O(Tm)  $  

考虑用矩阵快速幂优化这一过程.记 $ R^T(i)  $  表示 $ T $ 时刻后在点 $ i $ 的最大价值,显然当 $ k=0 $ , $ R^T $ 是由 $ R^0 $ 乘上 $ T $ 个相同的转移矩阵得到的(这里的"乘"是广义矩阵乘法,即 $ C(i,j)=\max_kA(i,k)+B(k,j)  $   ).考虑如何构造这个转移矩阵.

首先  $  1\le w_i\le 5 $ ,我们可以将每个点 $ u $ 拆成5个,即  $  \{u+i\times n|0\le i\le 4\}  $  , $ u+i\times n $ 表示相对于当前时刻, $ i $ 个时刻后的那个点.对于原图中的边  $  (u,v,w)  $  ,让 $ u $ 向 $ v+(w-1)\times n $ 连边,边权为 $ v $ 的价值,即让转移矩阵 $ A(v+(w-1)\times n,u)  $  的值为 $ val(v)  $  .另外每次转移后要将矩阵向上移动一个单位(这是我的理解),即要让 $ u+n\times (i-1)  $  向 $ u+n\times i $ 连边.矩阵加速即可,对于 $ k=0 $ ,复杂度为  $  \mathcal O(n^3\log T)  $  .

对于一般情况,将活动按 $ t $ 排序,则相邻的两个活动构成 $ k=0 $ 的子问题.矩阵加速后令 $ R^t(x)+y $ 即可.复杂度  $  \mathcal O((wn)^3\log T\times k)  $  .

这样是过不去的,但xyx神仙有高论:

>  你考虑矩阵相乘复杂度是立方没有办法,但是矩阵乘列向量复杂度是平方.你先暴力预处理那个转移矩阵的二次幂,然后拿列向量去乘他们就好了.

简单来说就是,先预处理 $ A^{2^i}  $  ,复杂度  $  \mathcal O(n^3\log T)  $  .之后再做矩阵加速时,不再用矩阵相乘,直接用列向量 $ R $ 去乘 $ A^{2^i}  $  ,那么对于每对相邻的 $ t $ ,就只要  $  \mathcal O(n^2\log T)  $  了.总复杂度  $  \mathcal O(n^3\log T+n^2\log T\times k)  $  .

```cpp
#define MAXN 255
ll res[MAXN][MAXN],a[31][MAXN][MAXN],t[MAXN][MAXN], n,m,T,k;
ll val[MAXN];
void mul(ll a[MAXN][MAXN],ll b[MAXN][MAXN],ll res[MAXN][MAXN],int n,int m,int p)
{
    for(int i=1;i<=n;++i)
        for(int j=1;j<=p;++j)
        {
            t[i][j]=a[i][1]+b[1][j];
            for(int k=2;k<=m;++k)umax(t[i][j],a[i][k]+b[k][j]);
        }
    for(int i=1;i<=n;++i)
        for(int j=1;j<=p;++j)res[i][j]=t[i][j];
}
struct tuple
{
    int pos,t,ww;
    bool operator <(const tuple& you)const{return t<you.t;}
}party[MAXN];
void pr()
{
    puts("debug:");
    for(int i=1;i<=5*n;++i)printf("%lld\n",res[i][1]);
}
void Qpow(int p)
{
    // while(p--)mul(a[0],res,res,5*n,5*n,1),pr();
    for(int i=30;i>=0;--i)
        if(p&(1<<i))mul(a[i],res,res,5*n,5*n,1);
}
int main()
{
    n=read(),m=read(),T=read(),k=read();
    for(int i=1;i<=n;++i)val[i]=read();
    for(int i=1;i<=5*n;++i)
        for(int j=1;j<=5*n;++j)a[0][i][j]=res[i][j]=-1e17;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=4;++j)a[0][i+n*(j-1)][i+n*j]=0;
    res[1][1]=val[1];
    for(int i=1;i<=m;++i)
    {
        int u=read(),v=read(),w=read()-1;
        a[0][v+n*w][u]=val[v];
    }
    for(int i=1;i<=k;++i)party[i].t=read(),party[i].pos=read(),party[i].ww=read();
    std::sort(party+1,party+k+1);
    for(int i=1;i<=30;++i)mul(a[i-1],a[i-1],a[i],5*n,5*n,5*n);//n^3 log T
    for(int i=1;i<=k;++i)
    {
        Qpow(party[i].t-party[i-1].t);
        if(res[party[i].pos][1]>=0)res[party[i].pos][1]+=party[i].ww;
    }
    Qpow(T-party[k].t);
    printf("%lld",max(-1ll,res[1][1]));
    return 0;
}
```



---

## 作者：zzqDeco (赞：8)

这道题算是在矩阵快速幂方面应用比较全面的题目

首先我们一般的矩阵快速幂考虑到的都是当一个状态向下一个转移一步的结果

但是这道题首先一点在于我们状态的转移需要走的步数不一定为一

在这里我们考虑用拆点的思想，也就是定义更加适用于这道题的状态来更方便的转移

我们考虑 $w_i$ 的特点，发现范围很小，就可以这样考虑：我们每次从 $a$ 到 $b$ 走 $t$ 天实际可以看作在 $a$ 停留 $t-1$ 天，再一天走到 $b$

基于上面我们的讨论，就可以发现这道题我们拆点的方法就是将点 $a$ 拆成 $a_1,a_2,a_3,a_4,a_5$  ,分别表示到 $a$ 点的第几天，显然的我们从 $a_i$ 到 $a_{i+1}$ 的转移贡献是 $0$ ，其他的通过给出的边得到的转移的贡献是到达点的权值（可以看作是点权转边权）

这样第一个棘手的问题就解决了

第二个在于他存在中间有 $k$ 次的美食节，这个很容易发现 $k$ 很小，完全可以把时间分为 $k+1$ 段，分别计算这些段上的，然后考虑这 $k$ 次美食节的贡献

第三个在于我们通过拆点，形成了 $250$ 个点，并且要进行多次的快速幂，普通的复杂度难以保证，这里我们考虑用列向量和预处理来解决这个问题

我们想想快速幂的过程，实际上就是求出关于这个矩阵的 $x$ 次幂，然后合并这些次幂

那么就可以预处理这些次幂

同时我们考虑到一般的方阵的乘法是 $O(n^3)$

于是就可以考虑到我们用一个列向量表示开始状态，然后不断地乘上方阵，单次复杂度就为$O(n^2)$

同时为了起点为 $1$ ，我们将其他点的初始值都设为 $-\inf$，这样就可以消除其他点的开始的贡献

总复杂度$O(n^2(k + log{T})+nk)$，分析常数的话，存在 $5\times5$的大常数，但是考虑 $log$ 里面的 $T$ 的常数的话，大概是 $1/7$，所以实际上不存在超时的现象的

下面是代码

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int n,m,k;

long long T;

int num,head[310];

long long v[310];

struct query
{
  long long now,v;
  int p;
}q[100010];

struct M
{
  long long s[310][310],r,c;
  void clear()
  {
    for(int i=1;i<=300;i++) for(int j=1;j<=300;j++) s[i][j]=-0x3f3f3f3f3f3f3f3f;
  }
}ans,Ye[40];

M operator * (const M &x,const M &y)
{
  M now;
  now.clear();
  now.r=x.r;
  now.c=y.c;
  for(int k=1;k<=x.c;k++)
  {
    for(int i=1;i<=x.r;i++)
    {
      for(int j=1;j<=y.c;j++)
      {
        now.s[i][j]=max(now.s[i][j],x.s[i][k]+y.s[k][j]);
      }
    }
  }
  return now;
}

bool cmp(query a,query b)
{
  return a.now<b.now;
}

int main()
{
  scanf("%d%d%lld%d",&n,&m,&T,&k);
  ans.clear();
  ans.r=1;
  ans.c=n*5;
  ans.s[1][1]=0;
  Ye[0].clear();
  Ye[0].r=n*5;
  Ye[0].c=n*5;
  for(int i=1;i<=n*5;i++) if(i%5) Ye[0].s[i][i+1]=0;
  for(int i=1;i<=n;i++) scanf("%lld",&v[i]);
  for(int i=1;i<=m;i++)
  {
    int a,b,c;
    scanf("%d%d%d",&a,&b,&c);
    Ye[0].s[(a-1)*5+c][(b-1)*5+1]=v[b];
  }
  for(int i=1;i<=31;i++) Ye[i]=Ye[i-1]*Ye[i-1];
  for(int i=1;i<=k;i++) scanf("%lld%d%lld",&q[i].now,&q[i].p,&q[i].v);
  sort(q+1,q+k+1,cmp);
  q[0].now=0;
  for(int i=1;i<=k;i++)
  {
    for(int j=0;j<=31;j++) if((q[i].now-q[i-1].now-1)&(1ll<<j)) ans=ans*Ye[j];
    M wee=Ye[0];
    for(int j=1;j<=n*5;j++) if(wee.s[j][(q[i].p-1)*5+1]>=0) wee.s[j][(q[i].p-1)*5+1]+=q[i].v;
    ans=ans*wee;
  }
  for(int j=0;j<=31;j++) if((T-q[k].now)&(1ll<<j)) ans=ans*Ye[j];
  if(ans.s[1][1]>0) printf("%lld",ans.s[1][1]+v[1]);
  else puts("-1");
}

```

update:修改了部分不严谨的地方

---

## 作者：seajupiter (赞：8)

HB倒数rk1最菜打铁选手来写篇题解纪念这题害我退役……

# Task 1

这题题意非常简单，任何一个选手在开题后都可以想出一个简单的dp：

设 $f_{i,u}$ 表示在第 $i$ 时刻到达 $u$ 节点所能获得美味值的最大值，然后转移直接就是：

$f_{i,v}= \max\limits_{(u,v) \in E} f_{i-w(u,v),u}+c_v$

如果恰好这时有个美食节那么就加上美食节的额外美味值即可，时间复杂度 $O((n+m)T)$ ，可以过掉前 40 分。

# Task 2

接下来我们看A性质的数据，满足构成一个环，那么怎么走已经是确定的，直接按照题意模拟即可，先算出这个环会被走几遍，然后再扫一遍美食节判断会不会刚好碰上就可以了，时间复杂度 $O(n+k)$，配合 Task1 可获得 50 分。 ~~（也就是我考场得分）~~

# Solution

我们观察到有个很有意思的地方，题目保证了每条边的边权不超过 5，而且 $n$ 也小得惊人，那么但凡有一些经验的选手都可以想到用矩阵快速幂优化。具体怎么办呢？我们发现转移方程只会用到时间差在 5 以内的状态，那么我们可以把转移搞成一个 $5n * 5n$ 的矩阵，并且把状态表示成一个 $5n$ 的向量，然后根据转移方程可以轻松推出转移矩阵（构造矩阵的时候要足够细致）。众所周知，这里的广义矩阵乘法 (+和max形式）是符合结合律的，可以矩阵快速幂。

首先看到 $k=0$ 的部分分，那么直接一个矩阵快速幂就可以了，时间复杂度 $O(125n^3 \log T)$ ，计算量很有点大，比较极限，但似乎也只能这样了。

然后看到 $k \leq 200$ ，那么这就很套路，把美食节排序，把转移划分为 k 段，每段快速幂就行了。

可是这个时候复杂度就变成了 $O(125n^3 k\log T)$ ，这是怎么卡都过不去了（实际上有75），怎么办呢？

我们发现，我们实际上手上时时刻刻都拿着我们的状态向量，矩阵乘矩阵是 $O(n^3)$ ，而矩阵乘向量是 $O(n^2)$ ，那么我们可以预处理出转移矩阵的 $1,2,2^2 ... 2^{\log T}$ 次幂，然后每段快速幂就用矩阵左乘向量就可以了，复杂度 $O(125n^3 \log T+25n^2 k \log T)$ ，虽然计算量还是很大，但比小多了。而且出题人非常良心，一点都不卡常，时限非常宽松，可以通过。

（提一下我为什么只有50：我把单位矩阵全部设成了 -inf （应该要留对角线的0），而且由于一些策略问题很晚才开始写 t1 正解，最后调试十分紧张，又万万想不到会是这种错误，最后只剩1min时放弃了。人生就是这么富有戏剧性，只能说是我水平还不够吧……）

代码：（大部分是考场上写的，之后偷懒直接在其基础上小改了一下，所以比较乱 ~~（但是有部分分的写法）~~ ，请原谅）

```cpp
#include <bits/stdc++.h>
#define FOR(i, l, r) for(int i=l; i<=r; ++i)
#define ROF(i, r, l) for(int i=r; i>=l; --i)
#define FOF(i, l, r) for(int i=l; i<r; ++i)
#define REP(i, u) for(int i=hd[u],v;v=to[i],i;i=nxt[i])
#define cmax(x, y) (x=max(x, y))
using namespace std;

typedef long long ll;

char _b[100000], *p1, *p2;
#define gc ((p1==p2)&&(p2=(p1=_b)+fread(_b,1,100000,stdin)),p1==p2)?EOF:*(p1++)
template<class T> inline void read(T& x){
	char c=gc;x=0; while(!isdigit(c))c=gc;
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=gc;
}

const int N=55, M=505, K=205;
const ll infll=0x3f3f3f3f3f3f3f3fll;

int n, m, T, k, c[N];
int e, hd[N], to[M<<1], nxt[M<<1], val[M<<1];
struct Fst{int t, x, y;}p[K];

inline bool cmp(const Fst& a, const Fst& b){
	return a.t<b.t;
}

inline void add(int u, int v, int w){
	to[++e]=v, val[e]=w;
	nxt[e]=hd[u], hd[u]=e;
}

namespace Task1{
	const int MX=53005;

	ll f[MX][N];
	int g[MX][N];

	int main(){
		FOR(i, 1, k) g[p[i].t][p[i].x]=p[i].y;

		FOR(i, 0, T) FOR(u, 1, n) f[i][u]=-infll;
		f[0][1]=0;
		FOR(i, 0, T)
			FOR(u, 1, n) if(f[i][u]>-infll){
				f[i][u]+=1ll*g[i][u]+1ll*c[u];
				REP(j, u) if(i+val[j]<=T)
					cmax(f[i+val[j]][v], f[i][u]);
			}
		
		if(f[T][1]>-infll) printf("%lld\n", f[T][1]);
		else puts("-1");

		return 0;
	}
}

inline bool spj2(){
	if(m!=n) return false;
	FOR(i, 1, n) if(to[hd[i]]!=i%n+1)
		return false;
	return true;
}
namespace Task2{

	int w[N], s[N], tot;
	ll ans, res;

	int main(){
		FOR(i, 1, n) tot+=(w[i]=val[hd[i]]);
		if(T%tot) return 0*puts("-1");
		FOR(i, 1, n) s[i]=s[i-1]+w[i-1];
		
		FOR(i, 1, n) res+=c[i];
		ans=res*(T/tot)+c[1];
		FOR(i, 1, k) if(p[i].t%tot==s[p[i].x])
			ans+=p[i].y;

		printf("%lld\n", ans);

		return 0;
	}
}

namespace Task3{
	const int D=255;
	int d, mx, lg;
	ll f[D];
	struct Matrix{
		ll a[D][D];
		inline ll* operator[](int x){
			return a[x];
		}
		inline void init(int flag=0){
			FOR(i, 1, d) FOR(j, 1, d)
				a[i][j]=-infll;
			if(flag) FOR(i, 1, d) a[i][i]=0;
		}
	}E, Ep[30];
	inline void mul(Matrix& a, Matrix& b, Matrix& c){
		static Matrix A, B;
		A=a, B=b;
		c.init();
		FOR(i, 1, d) FOR(j, 1, d) FOR(k, 1, d)
			cmax(c[i][k], A[i][j]+B[j][k]);
	}
	inline void mul(Matrix& a, ll *b, ll *c){
		static ll B[D];
		FOR(i, 1, d) B[i]=b[i];
		FOR(i, 1, d) c[i]=-infll;
		FOR(i, 1, d) FOR(j, 1, d)
			cmax(c[i], a[i][j]+B[j]);
	}
	inline void init(){
		FOR(i, 1, e) mx=max(mx, val[i]);
		d=n*mx;
		E.init();
		FOR(u, 1, n) FOF(j, 1, mx)
			E[(u-1)*mx+j][(u-1)*mx+j+1]=0;
		FOR(u, 1, n) FOR(i, 1, mx){
			int p=(u-1)*mx+i;
			REP(j, u) if(i+val[j]-1<=mx){
				int q=(v-1)*mx+i+val[j]-1;
				E[q][p]=c[v];
			}
		}
		Ep[0]=E;
		while((1<<(lg+1))<=T) ++lg;
		FOR(i, 1, lg) mul(Ep[i-1], Ep[i-1], Ep[i]);
		FOR(i, 1, d) f[i]=-infll;
		f[mx]=c[1];
	}
	inline void qpow(int x){
		for(int i=0; x; x>>=1, ++i) if(x&1)
			mul(Ep[i], f, f);
	}
	inline void work(){
		sort(p+1, p+k+1, cmp);
		int cur=0;
		FOR(i, 1, k){
			int t=p[i].t, x=p[i].x, y=p[i].y;
			qpow(t-cur);
			f[x*mx]+=y;
			cur=p[i].t;
		}
		if(cur<T) qpow(T-cur);
	}
	int main(){
		init();
		work();
		printf("%lld\n", f[mx]>=0?f[mx]:-1);
		return 0;
	}
}

int main(){
	freopen("delicacy.in", "r", stdin);
	freopen("delicacy.out", "w", stdout);

	read(n);read(m);read(T);read(k);
	FOR(i, 1, n) read(c[i]);
	for(int i=1, u, v, w; i<=m; ++i){
		read(u);read(v);read(w);
		add(u, v, w);
	}
	FOR(i, 1, k) read(p[i].t), read(p[i].x), read(p[i].y);

	if(T<=52501) return Task1::main();
	if(spj2()) return Task2::main();
	return Task3::main();

	return 0;
}
```

这也许是我最后一片题解了。

机不我予，时若奔驷，有来无返，难得易失。






---

## 作者：Rubyonly (赞：6)

## 基本思路

从 $n \leq 50$ 和 $w \leq 5$ 中不难看出，这是一个矩阵快速幂，利用一个拆点的思想，可以先做一下 [P4159迷路](https://www.luogu.com.cn/problem/P4159)，然后再用一个二进制拆分，不错，就是 [P6190魔法](https://www.luogu.com.cn/problem/P6190)。

将上俩个题的思路综合起来，这个题就好处理多了。

### 拆点

何为拆点，如何拆点？

首先，我们拿一个图为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/7qfflkap.png)

当前这个图的01邻接矩阵为：

$\begin{bmatrix}
 0&1&1&0 \\ 
 0&0&1&0 \\
 0&0&0&0 \\
 1&0&1&0
\end{bmatrix}$

可以理解为 $a[i][j]$ 从 $i$ 走一步能否到 $j$ 。

将这个矩阵相乘：

$
\begin{bmatrix}
 0&1&1&0 \\ 
 0&0&1&0 \\
 0&0&0&0 \\
 1&0&1&0 \\
\end{bmatrix} \times
\begin{bmatrix}
 0&1&1&0 \\ 
 0&0&1&0 \\
 0&0&0&0 \\
 1&0&1&0
\end{bmatrix} =
\begin{bmatrix}
 0&0&1&0 \\ 
 0&0&0&0 \\
 0&0&0&0 \\
 0&1&1&0
\end{bmatrix} 
$

易证，得出的矩阵 $a[i][j]$ 表示从 $i$ 走 $2$ 步能否到达 $j$ 。

不妨设一开始的矩阵为 $base$ ，则可以得出：$base^k$ 为从 $i$ 走 $k$ 步能否到达 $j$ 。

---

但是这道题还有一个点权，该怎么统计呢？

我们可以将矩阵中的元素更改，并将矩阵乘法的运算重新定义。

不妨设 $a[i][j]$ 为从 $i$ 到 $j$ 的最长路，那么矩阵中的运算就改为了：

```c++
c.a[i][j] = max (c.a[i][j], a.a[i][k] + b.a[k][j]);
```

注意将不能到达的点，权值设为 $-INF$，这样无论怎样相加都不会影响到答案了。

---

emmmm，好像跑的有点远。

由于我们的矩阵只支持边权为1时的图，所以我们要拆点。

拆点，顾名思义，就是将一个点拆成多个点，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/s6c6zeud.png)

图中1、6 ,就是我们原来的1和2 。

如果我们要从2到1建一条边权为3的边，我们就将新图中从6到3建一条边，这样就达到了我们的目的，也可以跑矩阵快速幂了。

![](https://cdn.luogu.com.cn/upload/image_hosting/9fld1pz2.png)

### 分块快速幂

如果 $k=0$，那么答案很简单就是 $base^T.a[1][1]$ 。

若 $k\neq0$，我们可以将整段 $T$ 时间分成 $k+1$ 块进行矩阵快速幂。

这样在每次美食节结束的时候，在统计答案的矩阵里，在相应的位置加上额外的贡献即可。

到现在我们就可以粗略的码一个效率为 $\Theta(kn^3log_T)$ 的小暴力，显然会T到飞起。

### 二进制拆分

从上面我们会发现，在每次分块快速幂的时候，我们都将统计答案的 $ans$ 矩阵乘上了一个 $base^t$。

我们可以现将 $base$ 矩阵的 $2^x$ 次方预处理出来。

在统计答案时，将这段时间二进制拆分，乘上相应的 $base^{2^x}$。

好像差不多可以优化一个 $log$ 的效率，但还是会T到飞起。

### 搞掉一个n

怎么能搞掉一个n呢？

我们会发现，我们统计答案的矩阵 $ans$，只用到了 $i = 1$ 的地方，所以我们直接只计算 $i = 1$ 的那一行的答案即可。

~~搞掉一个n不轻轻松松？~~

当前复杂度 $\Theta(kn^2logT)$，直接碾掉！！！

## 代码（自带大常数）

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

#define ll long long
#define DEBUG puts ("emmmm")

using namespace std;

const int maxn = 5e2 + 50;

inline int read () {
	int x = 0, w = 1;
	char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';
	return x * w;
}

int n, m, T, K;
int c[maxn];

struct Festival{
	int t, pos, val;
	inline bool operator < (const Festival &a) const {
		return t < a.t;
	};
}Fes[maxn];

struct Matrix{
	ll a[260][260];
	Matrix () {
		memset (a, -0x3f, sizeof a); //初始为-INF，对答案不会造成影响
	};
}base, ans, basem[50];

inline Matrix Matx (Matrix a, Matrix b) {
	Matrix ans;
	register int i = 1, j = 1, k = 1;
	for (; i <= n * 5; i ++) {
		for (j = 1; j <= n * 5; j ++) {
			for (k = 1; k <= n * 5; k ++) {
				ans.a[i][j] = max (ans.a[i][j], a.a[i][k] + b.a[k][j]);
			}
		}
	}
	return ans;
}

inline Matrix Matx0 (Matrix a, Matrix b) {
	Matrix ans;
	register int j = 1, k = 1;
	for (; j <= n * 5; j ++) {
		for (k = 1; k <= n * 5; k ++) {
			if (a.a[1][k] != -1 && b.a[k][j] != -1) ans.a[1][j] = max (ans.a[1][j], a.a[1][k] + b.a[k][j]);
		}
	}
	return ans;
}

inline Matrix Matqpow (Matrix a, register int b) {
	Matrix ans;
	register int i = 1;
	for (; i <= n * 5; i ++) ans.a[i][i] = 1;
	while (b) {
		if (b & 1) ans = Matx (ans, a);
		a = Matx (a, a);
		b >>= 1;
	}
	return ans;
}

int main () {
	freopen ("delicacy.in", "r", stdin);
	freopen ("delicacy.out", "w", stdout);
	n = read(), m = read(), T = read(), K = read();
	for (register int i = 1; i <= n; i ++) c[i] = read();
	for (register int i = 1; i <= n; i ++) {
		for (register int j = 1; j <= 4; j ++) {
			register int u = (i - 1) * 5 + j + 1, v = (i - 1) * 5 + j; // 负责的建边，建议自己模拟
			if (j != 1) base.a[u][v] = 0;
			else base.a[u][v] = c[i];
		}
	}
	for (register int i = 1; i <= m; i ++) {
		register int u = read(), v = read(), w = read();
		if (w != 1) base.a[(u - 1) * 5 + 1][(v - 1) * 5 + w] = 0; // 负责的建边，建议自己模拟
		else base.a[(u - 1) * 5 + 1][(v - 1) * 5 + w] = c[v];
	}
	for (register int i = 1; i <= K; i ++) Fes[i].t = read(), Fes[i].pos = read(), Fes[i].val = read();
	sort (Fes + 1, Fes + K + 1);
	Fes[++ K].t = T;
	basem[1] = base;
	for (register int i = 2; (1 << i - 1) <= T; i ++) {
		basem[i] = Matx (basem[i - 1], basem[i - 1]);
	}
	register int last = 0;
	register bool flag = 0;
	ans.a[1][1] = 0;
	for (register int i = 1; i <= K; i ++) {
		register int x = Fes[i].t - last;
		for (register int j = 1; j <= 30; j ++) {
			if (1 << j - 1 & x) {
				ans = Matx0 (ans, basem[j]);
			}
		}
		last = Fes[i].t;
		for (register int j = 1; j <= n * 5; j ++) {
			if (ans.a[j][(Fes[i].pos - 1) * 5 + 1] >= 0) {
				ans.a[j][(Fes[i].pos - 1) * 5 + 1] += Fes[i].val;	
			}
		}
	}
	if (ans.a[1][1] < 0) {
		puts ("-1");
	}else {
		printf ("%lld\n", ans.a[1][1] + c[1]); // 别忘了最后加上刚开始获得的愉悦值
	}
	return 0;
}
```

---

## 作者：UltiMadow (赞：5)

从我的[做题笔记](https://www.luogu.com.cn/blog/sflsrick/note-problems-in-august)上弄下来的一段

同步赛 long long $\to$ int，$100\to 20$ /dk/dk

第一眼是个费用流，后来发现就是个 DAG 最长路

然后显然这个图可以分层（反正就莫名其妙想到了，鬼知道为啥），边是有向无权边，点上有点权

按照时间分层，$u\to v$ 的权值为 $w$ 的边就在分层图上连 $(i,u)\to (i+w,v)$，二元组 $(i,u)$ 表示第 $i$ 层的点 $u$

点权即为到达一个点的收益，美食节直接在对应的点上改即可

然后跑 $(0,1)\to (T,1)$ 的最长路即可

利用拓扑排序即可做到 $\mathcal O(Tn+Tm)$

然后直接爆炸

然后我又无端联想到了「超级跳马」这个题，于是想到了用矩阵加速

于是便有了一个 $(5\times n)\times (5\times n)$ 的一个矩阵，资瓷 $\max$ 运算和 $+$ 运算

矩阵很好构造，把求最长路看成线性递推即可

每次美食节直接暴力修改即可做到 $\mathcal O(125kn^3\log \frac T k)$

然后直接爆炸

然后我又无端联想到了「魔法值」这个题，于是想到了预处理矩阵的 $2^i$ 次幂，$k$ 次矩阵乘法中每次矩阵乘法就由 $\mathcal O((5n)^3)$ 变成了 $\mathcal O((5n)^2)$

总复杂度 $\mathcal O(125n^3\log T+25kn^2\log \frac T k)$

即可通过此题

考场上写的奇丑无比的 code:
```cpp
#include<bits/stdc++.h>
#define MAXM 60
#define MAXK 210
#define int long long
using namespace std;
int n,m,T,K,val[MAXM];
int t[MAXK],x[MAXK],y[MAXK];
vector<int>e[MAXM],re[MAXM];
vector<int>we[MAXM],wre[MAXM];
const int minf=0xcfcfcfcfcfcfcfcf;
const int inf=0x3f3f3f3f3f3f3f3f;
namespace solveAC{
	struct Node{
		int a[MAXM*4+20][MAXM*4+20],c,r;
		Node(int rr=0,int cc=0){c=cc,r=rr;memset(a,0xcf,sizeof(a));}
		void clear(){memset(a,0,sizeof(a));}
	}base[40];
	Node operator ~ (Node x){
		for(int i=1;i<=x.c;i++)x.a[i][i]=1;
		return x;
	}
	Node operator * (Node a,Node b){
		int r=a.r,c=b.c;
		Node ret(r,c);
		for(int k=1;k<=a.c;k++)
			for(int i=1;i<=r;i++)
				for(int j=1;j<=c;j++){
					if(a.a[i][k]==minf||b.a[k][j]==minf)continue;
					ret.a[i][j]=max(ret.a[i][j],a.a[i][k]+b.a[k][j]);
				}
		return ret;
	}
	void init(){
		base[0]=Node(5*n,5*n);
		for(int i=1;i<=n;i++){
			for(int j=1;j<=4;j++){
				int now=(i-1)*5+j;
				base[0].a[now][now+1]=0;
			}
			for(unsigned int j=0;j<re[i].size();j++){
				int v=re[i][j],w=wre[i][j];
				int now=i*5;
				base[0].a[now][v*5-w+1]=val[i];
			}
		}
		for(int i=1;i<=30;i++)base[i]=base[i-1]*base[i-1];
	}
	int pos[MAXK];
	bool cmp(int a,int b){return t[a]<t[b];}
	void mul(Node &a,int cnt){
		for(int i=30;i>=0;i--)
			if(cnt>=(1<<i)){
				a=base[i]*a;
				cnt-=(1<<i);
			}
	}
	void solve(){
		init();
		Node ans(5*n,1);
		for(int i=1;i<=n;i++){
			for(int j=1;j<=4;j++)
				ans.a[(i-1)*5+j][1]=minf;
			if(i==1)ans.a[i*5][1]=val[1];
		}
		for(int i=1;i<=K+1;i++)pos[i]=i;t[K+1]=T;
		sort(pos+1,pos+K+1,cmp);
		mul(ans,t[pos[1]]);
		for(int i=1;i<=K;i++){
			if(ans.a[5*x[pos[i]]][1]!=minf)
				ans.a[5*x[pos[i]]][1]+=y[pos[i]];
			mul(ans,t[pos[i+1]]-t[pos[i]]);
		}
		if(ans.a[5][1]==minf)printf("-1\n");
		else printf("%lld",ans.a[5][1]);
	}
}
signed main(){
	scanf("%lld%lld%lld%lld",&n,&m,&T,&K);
	for(int i=1;i<=n;i++)scanf("%lld",&val[i]);
	for(int i=1;i<=m;i++){
		int u,v,w;scanf("%lld%lld%lld",&u,&v,&w);
		e[u].push_back(v);re[v].push_back(u);
		we[u].push_back(w);wre[v].push_back(w);
	}
	for(int i=1;i<=K;i++)
		scanf("%lld%lld%lld",&t[i],&x[i],&y[i]);
	solveAC::solve();
	return 0;
}
```

---

## 作者：Yukikaze_ (赞：5)

首先看到数据范围里 $ n\le50,T\le10^{9} $ ，猜到估计是矩阵快速幂，然后观察到边权小于 $ 5 $ ，猜测要根据边权设计状态，于是我们可以设计如下的算法：

令 $ f_{i,j} $ 表示在第 $j$ 天到达 $i$ 号点可以获得的最大愉悦值，那么所有状态的转移中 $j$ 的变化不会超过 $5$，于是我们让 $j=0,1,2,3,4$ ，表示在令初始时间为 $t$ 的情况下，实际时间为 $t,t+1,t+2,t+3,t+4$ 的情况，然后每次转移时，我们只从这些情况转移到时间为 $t+5$ 的情况，并把数组整体后移一位，就可以保证正确性了，初始情况为 $f_{1,4}=c_{1}$ 。

在做了上面这些操作之后，我们发现状态数只剩下了 $5n\le250$ 个，用 [NOI online 3 魔法值](https://www.luogu.com.cn/problem/P6569)或[能量采集](https://www.luogu.com.cn/problem/P5107)中矩阵加速转移的技巧，就可以解决该问题了。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=255,inf=1e9;
int n,m,t,k,c[N];
struct bb
{
	ll a[N][N];
	bb operator *(const bb &b)const
	{
		bb res; memset(res.a,-63,sizeof(res.a));
		for(int i=1;i<=n*5;i++)
			for(int j=1;j<=n*5;j++)
				for(int li=1;li<=n*5;li++) res.a[i][j]=max(res.a[i][j],a[i][li]+b.a[li][j]);
		return res;
	}
}A[31];
struct cc
{
	ll a[N];
	cc operator *(const bb &b)const
	{
		cc res; memset(res.a,-63,sizeof(res.a));
		for(int i=1;i<=n*5;i++)
			for(int j=1;j<=n*5;j++) res.a[i]=max(res.a[i],a[j]+b.a[j][i]);
		return res;
	}
}B;
struct dd
{
	int t,x,y;
	bool operator <(const dd &b)const{return t<b.t;}
}st[N];
int read()
{
	int res=0,fl=0; char a=getchar();
	while(a<'0'||a>'9') {if(a=='-') fl=1;a=getchar();}
	while(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();
	return fl? -res:res;
}
int d(int a,int b) {return a+b*n;}
int main()
{
// 	freopen("delicacy.in","r",stdin);
// 	freopen("delicacy.out","w",stdout);
	int i,j;
	n=read(),m=read(),t=read(),k=read();
	for(i=1;i<=n;i++) c[i]=read();
	memset(A,-63,sizeof(A)),memset(B.a,-63,sizeof(B.a));
	for(i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read(),la=d(u,5-w),lb=d(v,4);
		A[0].a[la][lb]=max(A[0].a[la][lb],c[v]*1ll);
	}
	for(i=1;i<=n;i++)
		for(j=1;j<=4;j++) A[0].a[d(i,j)][d(i,j-1)]=max(A[0].a[d(i,j)][d(i,j-1)],0ll);
	for(i=1;i<=30;i++) A[i]=A[i-1]*A[i-1];
	for(i=1;i<=k;i++) st[i].t=read(),st[i].x=read(),st[i].y=read();
	sort(st+1,st+k+1),B.a[d(1,4)]=c[1];
	for(i=1;i<=k;i++)
	{
		int lk=st[i].t-st[i-1].t;
		for(j=30;~j;j--) if((1<<j)<=lk) lk-=(1<<j),B=B*A[j];
		B.a[d(st[i].x,4)]+=st[i].y;
	}
	int lk=t-st[k].t;
	for(j=30;~j;j--) if((1<<j)<=lk) lk-=(1<<j),B=B*A[j];
	if(B.a[d(1,4)]<0) cout<<-1;
	else cout<<B.a[d(1,4)];
	return 0;
}
```


---

## 作者：1saunoya (赞：4)

随便写写吧…

显然方程式 $f_{t,u}$ 表示 $t$ 时间在 $u$ 的最大贡献。

$f_{t,u} = \max\{f_{t-w,v} + c_u\}$。

看到这范围绝对是矩阵快速幂了…

等等边权不为$1$？

那就构造一个长度为 $5 \times n$ 的向量嘛，然后每过一个时间就会移动。

我们令 $id(i,j)$ 为 $position$ 为 $i$ 的时候，当前时间为 $6-j$ 的状态。

然后转移矩阵是考虑 $id(i,j+1) \to id(i,j)$ 的，然后连上边，注意有重边，如果没有注意的话会有奇奇怪怪的问题。

如果有一条 $\{u, v, w\}$ 的边，我们考虑 

```cpp
base[0][id(u, 6 - w)][id(v, 5)] = c[v];
```

实际意义是满足方程式。（

然后就可以转移了。

预处理 $\log_2 10^9 = 30$ 个矩阵，向量乘矩阵的复杂度是 $(5n)^2$ 的。

所以复杂度是 $((5n)^3 + (5n)^2k)\times \log_2 t$。


```cpp
#include <bits/stdc++.h>

#define FOR(i, x, y) for (int i = x; i <= y; i++)
#define ROF(i, x, y) for (int i = x; i >= y; i--)

int n, m, T, k;
int c[51];
struct buf { int t, x, y; } q[201];

struct Matrix {
	long long a[251][251]; 
	Matrix() { memset(a, 0xc0, sizeof(a)); }
	long long* operator[](int x) { return a[x]; }
} base[31];

struct Vector {
	long long a[251]; 
	Vector() { memset(a, 0xc0, sizeof(a)); }
	long long& operator[](int x) { return a[x]; }
} answer;

int lim;
Matrix mul(Matrix a, Matrix b) {
	Matrix c;
	FOR(i, 1, lim)
		FOR(j, 1, lim)
			FOR(k, 1, lim)
				c[i][j] = std::max(c[i][j], a[i][k] + b[k][j]);
	return c;
}

Vector mul(Vector a, Matrix b) {
	Vector c;
	FOR(i, 1, lim)
		FOR(j, 1, lim)
			c[i] = std::max(c[i], a[j] + b[j][i]);
	return c;
}

int id(int x, int y) { return x + (y - 1) * n; }
int main() {
#ifdef LOCAL
	freopen("testdata.txt", "r", stdin);
#endif
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);
	std::cin >> n >> m >> T >> k;
	lim = n * 5;
	FOR(i, 1, n) std::cin >> c[i];
	FOR(i, 1, m) {
		int u, v, w;
		std::cin >> u >> v >> w;
		base[0][id(u, 6 - w)][id(v, 5)] = c[v];
	}
	FOR(i, 1, k) {
		int t, x, y;
		std::cin >> t >> x >> y;
		q[i] = {t, x, y};
	}
	std::sort(q + 1, q + k + 1, [](buf x, buf y) { return x.t < y.t; });
	FOR(i, 1, n) FOR(j, 1, 4) base[0][id(i, j + 1)][id(i, j)] = 0;
	FOR(i, 1, 30) base[i] = mul(base[i - 1], base[i - 1]);
	answer[id(1, 5)] = c[1];
	FOR(i, 1, k) {
		int t = q[i].t - q[i - 1].t;
		FOR(j, 0, 30) if (t >> j & 1) answer = mul(answer, base[j]);
		answer[id(q[i].x, 5)] += q[i].y;
	}
	int t = T - q[k].t;
	FOR(j, 0, 30) if (t >> j & 1) answer = mul(answer, base[j]);
	std::cout << std::max(answer[id(1, 5)], -1ll) << '\n';
	return 0;
}
```

---

## 作者：AzusaCat (赞：4)

我们很容易写出朴素的 dp 方程，设 $f(i,u)$ 为第 $i$ 天在城市 $u$ 能得到的最大愉悦值之和，那么有转移：
$$
f(i,u)=\max_{(v,u)\in E}f(i-w_{(v,u)},v)+c_u
$$
如果某一个某一次美食节被举办，那么就往对应的 $f$ 加上 $y_i$

我们注意到 $w$ 很小，并且 $\max$ 对 $+$ 有分配律，所以我们可以矩阵快速幂加速计算，我们考虑向量：
$$
\begin{bmatrix}
f(t,1)\\
f(t,2)\\
\vdots\\
f(t,n)\\
f(t-1,1)\\
\vdots\\
f(t-4,n)
\end{bmatrix}
$$
这个东西可以通过
$$
\begin{bmatrix}
f(t-1,1)\\
f(t-1,2)\\
\vdots\\
f(t-1,n)\\
f(t-2,1)\\
\vdots\\
f(t-5,n)
\end{bmatrix}
$$
左乘转移矩阵得到。转移矩阵比较显然，大概是每有一条边 $(u,v,w)$ 就把 $(v,u+(w-1)n)$ 改为 $c_v$，然后其余地方是 $-inf$。这样总复杂度是 $O(n^3w^3k\log T)$ 无法通过，只需要预处理转移矩阵的次幂，然后每一次只需要向量乘矩阵，总复杂度为 $O((n^3w^3+kn^2w^2)\log T)$，可以通过。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int c[55],lim;
struct mat
{
    ll s[255][255];
    mat(){memset(s,0xcf,sizeof(s));}
    friend mat operator *(const mat &x,const mat &y)
    {
        mat res;
        for(int i=1;i<=lim;i++)
            for(int j=1;j<=lim;j++)
                for(int k=1;k<=lim;k++)
                    res.s[i][j]=max(res.s[i][j],x.s[i][k]+y.s[k][j]);
        return res;
    }
}r[35];
ll ans[255],ans2[255];
struct event
{
    int x,y,z;
}d[205];
bool cmp(event a,event b){return a.x<b.x;}
int main()
{
    int n,m,t,q,x,y,z;
    scanf("%d%d%d%d",&n,&m,&t,&q);
    lim=5*n;
    for(int i=1;i<=n;i++)scanf("%d",&c[i]);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        r[1].s[y][x+(z-1)*n]=c[y];
    }
    for(int i=n+1;i<=5*n;i++)
        r[1].s[i][i-n]=0;
    for(int i=2;i<=30;i++)r[i]=r[i-1]*r[i-1];
    memset(ans,0xcf,sizeof(ans));
    ans[1]=c[1];
    for(int i=1;i<=q;i++)scanf("%d%d%d",&d[i].x,&d[i].y,&d[i].z);
    q++;d[q].x=t;
    sort(d+1,d+q+1,cmp);
    int now=0;
    for(int i=1;i<=q;i++)
    {
        int tmp=d[i].x-now;
        now=d[i].x;
        for(int j=30;j>=1;j--)
            if(tmp&(1<<(j-1)))
            {
                for(int k=1;k<=lim;k++)ans2[k]=ans[k];
                memset(ans,0xcf,sizeof(ans));
                for(int k=1;k<=lim;k++)
                    for(int l=1;l<=lim;l++)
                        ans[k]=max(ans[k],ans2[l]+r[j].s[k][l]);
            }
        ans[d[i].y]+=d[i].z;
    }
    if(ans[1]<0)puts("-1");
    else printf("%lld",ans[1]);
    return 0;
}
```

---

## 作者：Jayun (赞：3)

# 链接：

[题目](https://www.luogu.com.cn/problem/P6772)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/13541730.html)

# 题目大意：

给定一个有 $n$ 个节点的有向图，每一个点有点权，在某些时候达到某些点能获得额外值，从点 1 出发，问 $t$ 天后回到点 1 的最大价值。

# 正文：

## 方法一：

直接无脑DP，设 $f_{i,j}$ 表示第 $i$ 天时正好到点 $j$ 的最大价值，转移 $f_{i,j}=\max\{f_{i-w,k}\}+c_j$

枚举时再加上附加值，时间复杂度 $O(Tm)$。

代码：

```cpp
f[0][1] = c[1];
for (int i = 1; i <= m; i++) 
	scanf ("%lld%lld%lld", &e[i].from, &e[i].to, &e[i].w);
for (ll i = 1, tim, u, v; i <= k; i++)
	scanf ("%lld%lld%lld", &tim, &u, &v),TouShui[tim][u] = v; 
for (int i = 1; i <= T; i++)
{
	for (int j = 1; j <= m; j++)
		if(f[i - e[j].w][e[j].from])
		{
			f[i][e[j].to] = max(f[i][e[j].to], f[i - e[j].w][e[j].from]) + c[e[j].to] + TouShui[i][e[j].to];   
		}
} 
printf("%lld", f[T][1]);
```

## 方法二：

若附加值和边权先不管，这题就是矩阵乘法优化的神（S）怖（B）题，理由是不可能存在第某天在路上的情况。定义一个矩阵 $F_i$ 表示到第 $i$ 天的各个 $f_i$ 的状态。那我们定义一个广义矩阵乘法 $C_{i,j}=\max\{B_{i,k}+C{k,j}\}$，那么构造一个邻接矩阵 $A$，$F_{i}=F_{i-1}\times A$，答案就是 $F_{t}=F_0\times A^t$ 了。只可惜这道题还有附加值和边权的问题。

### 边权问题：

注意看数据范围，发现边长小于等于五，直接拆点，建议不要拆边因为拆边数据过大会爆，如果你的程序过不了可能是因为拆的是边而不是点。

### 附加值问题：

可以给时间分段：

![](https://s1.ax1x.com/2020/08/21/dNyD9e.png)

吃完一个美食节就直接跳到下一个美食节。最后再利用快速幂的思想给程序进行小优化就能过了。

# 代码：

最后提醒，检查数组范围，只要经过矩阵乘法运算的数组都要记得乘五（即拆点的范围）。

```cpp
const int N = 60, M = 510, logT = 30, K = 210;
const ll inf = 4e17;

ll n, m, T, k, a[N * 5];
ll c[N * 5];

struct matrix
{
	ll mat[N * 5][N * 5];
	int n, m;
	inline ll* operator [] (int b) { return mat[b];}
	matrix() { memset(mat, 0xcf, sizeof mat);}
}F[logT + 5];

inline matrix operator * (matrix &a, matrix &b)
{
	matrix c; c.n = a.n, c.m = b.m;
	for (int k = 1; k <= a.m; k++)
		for (int i = 1; i <= a.n; i++)
			for (int j = 1; j <= b.m; j++)
				c[i][j] = max(c[i][j], a[i][k] + b[k][j]);
	return c;
}

struct FoodFestival 
{
	ll t, x, y;
}fft[K];

bool cmp (FoodFestival x, FoodFestival y)
{
	return x.t < y.t;
}

void mul(matrix &b)
{
	memcpy(c, a, sizeof(c));
	memset(a, 0xcf, sizeof(a));
	for (int i = 1; i <= b.n; i++)
		for (int j = 1; j <= b.m; j++)
			a[j] = max(a[j], b[i][j] + c[i]);
	return ;
}

void qpow(ll b)
{
	for (ll i = 0; i <= logT; i++)
		if(b & (1 << i)) mul(F[i]);
	return; 
}

signed main()
{
//	freopen("delicacy.in", "r", stdin);
//	freopen("delicacy.out", "w", stdout); 
	scanf ("%lld%lld%lld%lld", &n, &m, &T, &k);
	
	F[0].n = F[0].m = n * 5;
	
	for (int i = 1; i <= n; i++)
	{ 
		scanf("%lld", &c[i]);
		for (int j = 1; j < 5; j++)
			F[0][i + n * j][i + n * (j - 1)] = 0;
	} 
	for (int i = 1; i <= m; i++)
	{
		ll u, v, tim;
		scanf ("%lld%lld%lld", &u, &v, &tim);
		F[0][u][v + n * (tim - 1)] = c[v];
	} 
	for (int i = 1; i <= logT; i++)
		F[i] = F[i - 1] * F[i - 1];
	
	for (int i = 1; i <= k; i++)
		scanf ("%lld%lld%lld", &fft[i].t, &fft[i].x, &fft[i].y);
	sort (fft + 1, fft + 1 + k, cmp);
	fft[++k] = (FoodFestival) {T, 0, 0};
	
	memset (a, 0xcf, sizeof a);a[1] = c[1];
	ll now = 0;
	for (int i = 1; i <= k; i++)
	{
		qpow(fft[i].t - now);
		a[fft[i].x] += fft[i].y;
		now = fft[i].t;
	}
	if(a[1] < 0) puts("-1");
	else printf("%lld\n", a[1]);
	
	return 0;
}

```

---

## 作者：zjjws (赞：3)

在不考虑美食节的情况下，题目就是：从某个点出发，经过 $T$ 时间后回到原点所能的取到的最大价值。

注意到边权 $w_i\le 5$，那么这道题就跟 [P4159](https://www.luogu.com.cn/problem/P4159) 是一样的，对于每个城市拆分成五个以内的点，使得边的长度都变成 $1$，这样就可以用矩阵进行优化，每次矩阵乘类似 Floyd 跑一个最长路。

那如果考虑美食节呢？我们又发现这个美食节个数 $k\le 200$，也就是说可以分段跑，然后对于每一段结束之后加上这个美食节的贡献。这个时候你就可以拿到 $55$ 分，后面 $\operatorname{TLE}$。

分析复杂度：

$n\le 50,T\le 10^9$

分段运算就几乎是乘上了个 $200$ 的大常数，而矩阵乘法跑最长路每次运算又是 $\operatorname O((5n)^3)$，最大可以达到 $\operatorname O(250^3)$。每段也不止跑一次，常数可以简单算成乘一个 $\log T$，大概是 $\operatorname O(10^{11})$，直接爆炸。~~除非把时限开到100s~~

考虑优化：

$\operatorname A:$ 转移矩阵实际上是可以按二进制预处理好的，这样就省去了分段造成的重复运算。（我甚至先算出最高会有几位然后再做，因为当时同学在 luogu 上被卡到十几秒，交了好几次才过，~~luogu 评测机浮动，~~ 我以为这是个需要疯狂卡常的题）

$\operatorname B:$ 最重要的一个优化，能直接把 $n$ 的幂次减 $1$。

我们现在有两种矩阵，一种是存贮跑了当前时间以后的答案，即从某个点出发跑了当前时间后到达一个点能拿到的最大愉悦值（不可能则为 $-1$），记这个矩阵为 $ans$；一个是我们需要用到的转移矩阵的集合，记为 $sum[]$。

是可以将 $ans$ 这个矩阵压为一维的，只存从点 $1$ 出发跑了若干时间到达点 $i$ 的最大愉悦值。为什么可以这样呢？首先我们最后需要的答案是 $ans_{1,1}$（表示从 $1$ 出发花了 $T$ 时间回到 $1$ 能拿到的最大愉悦值），跟 $1$ 无关的处理出来也用不上。

然后考虑维护过程中这些东西是否是无用的。

如果我要维护 $ans_{1,1}$ ，它可以由 $ans_{1,j}+sum[]_{j,1}$ 得来

$\operatorname {Question}:$ 那我维护这个 $ans_{1,j}$ 不是有可能要用到 $ans_{i,j},i!=1$ 的吗？

$\operatorname {Answer}:$ 对于运算 

$$ans=ans \times sum[x_1] \times sum[x_2] \dots \times sum[x_k]$$

你需要用到的 $ans_{i,j},i!=1$ 是往前两步的 $ans$ 的，是可以由状态转移矩阵来更新的，并不会缺失状态。

这么说感觉有点抽象，用式子表达就是：

$$ans_{1,1}=ans_{1,1}+sum[x_p]_{1,j}+sum[x_{p+1}]_{j,1}$$

对于 $ans_{1,i}$ 也是一样的

$$ans_{1,i}=ans_{1,i}+sum[x_p]_{i,j}+sum[x_{p+1}]_{j,i}$$


结论：对于任意的 $ans_{i,j},i!=1$ 都是无用的状态

我是把 $ans$ 矩阵只考虑第一行的状态，这样前面预处理的乘法和跑答案的乘法是不一样的，你反正 $ans$ 都压成一维了干脆另外写个结构体，然后重载两次乘法

那么到这里就已经能过了。

然后还有个没啥屁用的优化。

$\operatorname C:$ 拆点的时候需要一个开一个，不要直接开 $n\times 5$ 个（只要数据好，完全可以变成无用的优化，但反正这个本身也不加复杂度，我平时也都是这么写的）

当时交上去发现跑得很快，挤到了第一页，然后在其他地方优化了下常数，加了个火车头，就成功跑到了最优解。

接下来附上巨丑代码：

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int MAN=250;
const int MAM=502;
struct milk
{
    LL a[MAN+2][MAN+2];
    inline void build(){memset(a,-0x3f,sizeof(a));}
};
struct stan
{
    LL a[MAN+2];
};
struct cow
{
    int t,x,y;
}b[MAM];
int n,m,t,k;
int nam;
int c[53];
int to[MAN];
milk sum[40];
milk st;
inline bool myru(cow x,cow y){return x.t<y.t;}//美 食 节 不 一 定 按 时 间 顺 序 给 ! ! !
inline stan operator *(stan x,milk y)//ans × sum[]
{
    stan z;
    memset(z.a,-0x3f,sizeof(z.a));
    for(int i=1;i<=nam;i++)
    for(int j=1;j<=nam;j++)
    if(x.a[i]>=0&&y.a[i][j]>=0)
    z.a[j]=max(z.a[j],x.a[i]+y.a[i][j]);
    return z;
}
inline milk cheng(milk s)//因为只会用到自己乘自己，干脆写函数不重载了
{
    milk z;
    z.build();
    for(int k=1;k<=nam;k++)
    for(int x=1;x<=nam;x++)
    for(int y=1;y<=nam;y++)
    if(s.a[x][k]>=0&&s.a[k][y]>=0)z.a[x][y]=max(z.a[x][y],s.a[x][k]+s.a[k][y]);
    return z;
}
LL rin()
{
    LL s=0;
    char c=getchar();
    bool bj=0;
    for(;(c>'9'||c<'0')&&c!='-';c=getchar());
    if(c=='-')c=getchar(),bj=true;
    for(;c>='0'&&c<='9';c=getchar())s=(s<<1)+(s<<3)+(c^'0');
    if(bj)return -s;
    return s;
}
int main()
{
    // freopen("delicacy.in","r",stdin);
    // freopen("delicacy.out","w",stdout);
    n=rin();m=rin();t=rin();k=rin();
    st.build();
    nam=n;
    for(int i=1;i<=n;i++)c[i]=rin();
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        x=rin();y=rin();z=rin();
        for(;z>1;z--,x=to[x])if(to[x]==0)to[x]=++nam,st.a[x][nam]=0;
        st.a[x][y]=c[y];
    }
    for(int i=1;i<=k;i++)b[i].t=rin(),b[i].x=rin(),b[i].y=rin();
    sort(b+1,b+k+1,myru);

    int max_t=t-b[n].t;
    for(int i=1;i<=k;i++)max_t=max(max_t,b[i].t-b[i-1].t);
    int max_s=0;
    for(;max_t>0;max_t>>=1)max_s++;

    milk s=st;
    sum[1]=st;
    for(int i=2;i<=max_s;i++)s=sum[i]=cheng(s);
    stan ans;
    for(int i=2;i<=nam;i++)ans.a[i]=-0x3f3f3f3f3f3f3f3f;
    ans.a[1]=c[1];//一开始出发有一次城市1的愉悦值
    for(int i=1;i<=k;i++)//跑到每个美食节的举办时间
    {
        int t_s=b[i].t-b[i-1].t;
        for(int i=1;t_s>0;i++,t_s>>=1)if(t_s&1)ans=ans*sum[i];
        if(ans.a[b[i].x]>=0)ans.a[b[i].x]+=b[i].y;
    }
    int t_s=t-b[k].t;//所有美食节都结束了，跑到给定的结束时间T
    for(int i=1;t_s>0;i++,t_s>>=1)if(t_s&1)ans=ans*sum[i];
    LL ans_s=-1;
    ans_s=max(ans_s,ans.a[1]);
    printf("%lld",ans_s);
    return 0;
}
```


---

## 作者：feecle6418 (赞：3)

唯一 A 掉的 NOI Day 1 题。

这题其实是把很多老题拼起来出的题啊，，，

第一部分是对边权的处理，若不会出门右转 [SCOI2009]迷路。这题处理方法一模一样，把每个点拆成 5 个点 $(i,0)\sim(i,4)$，$(i,j)\to (i,j+1)$ 连权为 $1$ 的边，若要连边 $(i\to j,k)$ 相当于 $(i,k-1)\to (j,0)$。

第二部分是矩阵快速幂，dp 和矩阵构造是显然的（$f_{v_i,t+w_i}\leftarrow f_{u_i,t}+c_{v_i}$，$i\to j$ 就让 $A_{i,j}=c_j$），比较难想的地方又是原题（NOI Online 魔法值），预处理转移矩阵 $1,2,4,\dots,2^{30}$ 次幂，按照 $k$ 个美食节分段转移，因为行向量乘矩阵的复杂度是 $O(n^2)$ 的，因此总复杂度就是 $O((5n)^3\log T+(5n)^2k\log T)$，是完全能过的。

哦对了这个矩阵乘法和普通的不太一样，这里的定义是 $A\times B=C$ 相当于 $C_{i,j}=\max\limits_{k}(A_{i,k}+B_{k,j})$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct Matrix {
	ll a[255][255];
	int n,m;
	Matrix(){memset(a,0xc0,sizeof(a)),n=m=0;}
	Matrix operator *(Matrix b){
		Matrix ans;
		ans.n=n,ans.m=b.m;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=b.m;j++){
				for(int k=1;k<=m;k++)ans.a[i][j]=max(ans.a[i][j],a[i][k]+b.a[k][j]);
			}
		}
		return ans;
	}
}vec2[35],fir,B;
struct E{
	int pos,t,val;
	bool operator <(const E e) const {
		return t<e.t;
	}
}a[205];
int n,m,T,K,val[55];
void Add(int x,int y,int z){
	fir.a[(x-1)*5+z][(y-1)*5+1]=val[y];
}
void Prework(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<5;j++)fir.a[(i-1)*5+j][(i-1)*5+j+1]=0;
	}
	fir.n=fir.m=n*5,vec2[0]=fir;
	for(int i=1;i<=30;i++)vec2[i]=vec2[i-1]*vec2[i-1];
}
int main(){
	scanf("%d%d%d%d",&n,&m,&T,&K);
	for(int i=1;i<=n;i++)scanf("%d",&val[i]);
	for(int i=1,x,y,z;i<=m;i++)scanf("%d%d%d",&x,&y,&z),Add(x,y,z);
	Prework();
	for(int i=1;i<=K;i++)scanf("%d%d%d",&a[i].t,&a[i].pos,&a[i].val);
	sort(a+1,a+K+1);
	B.n=1,B.m=n*5,B.a[1][1]=val[1];
	for(int i=1;i<=K;i++){
		for(int j=0;j<=30;j++)if((1<<j)&(a[i].t-a[i-1].t))B=B*vec2[j];
		B.a[1][(a[i].pos-1)*5+1]+=a[i].val;
	}
	for(int j=0;j<=30;j++)if((1<<j)&(T-a[K].t))B=B*vec2[j];
	if(B.a[1][1]<0)puts("-1");
	else printf("%lld\n",B.a[1][1]);
}
```

---

## 作者：zhylj (赞：2)

**Solution**

[广告](http://zhylj.cc/2020/08/18/63/#more)

先考虑 $k=0$ 的情况：

这是一个带边权的定长最短路，一般的定长最短路固定的是边数而非权值和，所以考虑将边权转化为边数：

- 将点 $u$ 拆成五个点 $u_1,u_2,\cdots,u_5$，连接 $u_i\to u_{i+1}$，边权为 $0$。
- 对于一条原图中连接 $u\to v$，边权为 $w$ 的边，建边 $u_{w}\to v_1$，权值为 $c_v$

这样，问题就被转化为了一般的定长最短路问题，作出新图的邻接矩阵 $G$，定义矩阵运算 $*$，$A*B=C$，则：

$$C_{ij} = \max_p \{A_{ip}+B_{pj}\}$$

容易发现该运算具有结合律，可以进行快速幂。（下面的次幂均指该运算）

再考虑 $k\neq 0$ 的情况，考虑一种 $\mathcal O(mT)$ 的 dp：设 $f_{t,i}$ 表示在第 $t$ 时刻恰好由 $1$ 到达 $i$ 的最小代价（注意这里 $i$ 是新图上的点）。可以发现 $f_t$ 是一个列向量，我们可以通过 $f_{t}*G^{a}$ 在平方时间内将 $f_t$ 转移到 $f_{t+a}$。

考虑将给出的 $t_i$ 排序，预处理出所有 $G^{2^i}$ 的值，不断计算这一个列向量在每个 $t_i$ 时候的取值，每次只需要令 $f_{x_i}$ 增加 $y_i$ 就可以计算。

可以发现，这样做的时间复杂度是 $\mathcal O((w\cdot n)^2(w\cdot n+k)\log T)$。~~（算起来感觉好大，但是可以过）~~

**Code**

```cpp
struct Fs {
	int t, x; ll y;
}; std::vector <Fs> fs;
int n, m, T, k; ll f[kN], t[kN], g[kB][kN][kN], c[kN];
void Update(ll &x, ll y) { x = std::max(x, y); }

void Init() {
	for(int b = 1; b < kB; ++b) {
		for(int i = 1; i <= n; ++i)
			for(int p = 1; p <= n; ++p) if(g[b - 1][i][p] >= 0)
				for(int j = 1; j <= n; ++j) if(g[b - 1][p][j] >= 0)
					Update(g[b][i][j], g[b - 1][i][p] + g[b - 1][p][j]);
	}
}

int main() {
	memset(f, ~0x3f, sizeof(f)); memset(g, ~0x3f, sizeof(g));
	scanf("%d%d%d%d", &n, &m, &T, &k);
	for(int i = 1; i <= n; ++i) scanf("%lld", c + i);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= 4; ++j) g[0][i + n * (j - 1)][i + n * j] = 0;
	for(int i = 1; i <= m; ++i) {
		int u, v, w; scanf("%d%d%d", &u, &v, &w);
		g[0][u + n * (w - 1)][v] = c[v];
	}
	for(int i = 1; i <= k; ++i) {
		int t, x; ll y; scanf("%d%d%lld", &t, &x, &y);
		fs.push_back((Fs) { t, x, y });
	}
	fs.push_back((Fs) { 0, 1, 0 });
	fs.push_back((Fs) { T, 1, 0 });
	std::sort(fs.begin(), fs.end(), [](const Fs &x, const Fs &y) { return x.t < y.t; });
	n *= 5; Init(); f[1] = c[1];
	for(int i = 1; i <= k + 1; ++i) {
		int dis = fs[i].t - fs[i - 1].t;
		for(int j = 0; j < kB; ++j)
			if((dis >> j) & 1) {
				memset(t, ~0x3f, sizeof(t));
				for(int p = 1; p <= n; ++p) if(f[p] >= 0)
					for(int q = 1; q <= n; ++q) if(g[j][p][q] >= 0)
						Update(t[q], f[p] + g[j][p][q]);
				memcpy(f, t, sizeof(f));
			}
		if(f[fs[i].x] >= 0) f[fs[i].x] += fs[i].y;
	}
	if(f[1] >= 0)
		printf("%lld\n", f[1]);
	else printf("-1\n");
	return 0;
}
```

---

## 作者：zzw4257 (赞：2)

# [NOI2020]美食家

NOI居然过了道模板拼凑，我要抢前排

> 给定一张有向图$G$，有经过一条边的时间和每次到达一个点的收益，求从$1$出发经过恰好$T$时间回到$1$的最大点权和,有特殊事件形如$(x,y,v)$表示在出发$x$时间后到达$y$点会获得$v$的收益，注意不能停留
>
> 一些特殊性质:$T$极大$(\leqslant 10^9)$，经过每条边的时间极小($\leqslant 5$)，

首先注意到$T$的范围，问题又形如关于总路程的最值

考虑边权为$1$的特殊情况，实际上是神似$Flyod$的关于路程起止位置的$dp$

$f_{i,j,t}=\max\{f_{i,k,t-1}+f_{k,j,t-1}\}+v_y$

$t$表示轮数，阶段，路程...

根据对$t$的认识不同我们可以轻易使用倍增$Floyd$或者矩阵乘法来优化

这里专门考量矩阵快速幂的本质，其实是类$\max$卷积的结合率

直接扩展边权到$\{1,2,3,4,5\}$，实际上是扩大了递推的阶数，因此直接用[[BJOI2017]魔法咒语](https://www.luogu.com.cn/problem/P3715)的技巧我们带着边权数维度，带着$d*d$倍的转移矩阵就可以维护一个时刻内最值的变化了

最后我们再考虑特殊事件，考虑按照时间来分层，我们尝试从上一个结点去满足下一个结点，其实答案只与其中时间的差值相关，因此我们不急着快速幂，而是维护$2^k$时间的$dp$的转移矩阵，这样我们对于每一层都倍增拼接，更新一段的重点即可

注意判$-1$完了

---

## 作者：TEoS (赞：1)

本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/13578834.html)

**题意分析**

给出一个带权有向图，要求从节点 $1$ 出发，经过恰好 $T$ 的边权和，回到节点 $1$ ，求可经过的最大点权和。特别地，经过的边权和达到部分特殊数时，会有某个点的点权发生改变。

**思路分析**

##### 朴素算法

- 时间复杂度： $O(mT)$
- 理论得分： $40pts$

设 $f_{i,j}$ 表示在节点 $j$ ，经过的边权和为 $i$ 时可经过的最大点权和。很容易可以得出 DP 方程：
$$
f_{i,j}=\max_{(x,j,w)\in E}(f_{i-w,x})+c_j
$$
暴力转移，点权改变的情况特判修改即可。

##### 优化1

- 时间复杂度： $O(125n^3k\log T)$
- 理论得分：$75pts$

可以发现 $w$ 的数据范围很小，想到用矩阵快速幂优化。

首先拆点，令所有边边权都为 $1$ ，然后将所求的点权转化为边权：设有 $(u,v,w)\in E$ ，则可以将 $u$ 拆成 $u_0,u_1,...,u_{w-1}$ ，从 $u_{i-1}$ 向 $u_i$ 间连一条边，边权为 $0$ ，然后从 $u_{w-1}$  向 $v$ 连一条边，边权为 $c_v$ 。

这样，问题就转化为，从节点 $1$ 出发，经过 $T$ 条边，回到节点 $1$ ，求可经过的最大边权和，即最长路。

定义一个广义矩阵乘法 $ans_{i,j}=max(a_{i,k}+b_{k,j})$ 。可以证明这个广义矩阵乘法同样满足矩阵乘法的基本运算律，如结合律。

设邻接矩阵为 $a$ ，可以很容易得出 DP 方程：
$$
dp_i=dp_j*a^{i-j}
$$
点权改变的情况怎么处理？只要先将时间从小到大排序，然后在相邻的时间之间转移，转移后在改变点权在邻接矩阵中的对应位置修改即可。

##### 优化2

- 时间复杂度： $O(125n^3\log T+25n^2k\log T)$
- 理论得分： $100pts$ 

分析过后可以发现，因为要求的只是 $dp_{T_{1,1}}$ ，因此只要保留 $dp$ 矩阵的第一行即可；另外，发现在转移的时候要多次乘上邻接矩阵 $a$ 的相同次幂，因此可以先预处理出 $a$ 的 $2$ 的整数次幂。这样处理之后可以降低一维的复杂度。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int N=300;
const ll INF=0xcfcfcfcfcfcfcfcf;
struct Node
{
	ll p[N][N];
}a[31];
struct Fes
{
	int t,x,y;
	#define t(i) b[i].t
	#define x(i) b[i].x
	#define y(i) b[i].y
}b[N];
int n,m,T,K;
int c[N],id[N][5];
ll dp[N];
Node Max(Node x)
{
	Node now;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			now.p[i][j]=INF;
			for(int k=1;k<=n;k++)
				now.p[i][j]=max(now.p[i][j],x.p[i][k]+x.p[k][j]);
		}
	return now;
}//广义矩阵乘法
void Maxx(Node x)
{
	ll now[N];
	for(int i=1;i<=n;i++)
	{
		now[i]=INF;
		for(int j=1;j<=n;j++)
			now[i]=max(now[i],dp[j]+x.p[j][i]);
	}
	for(int i=1;i<=n;i++)
		dp[i]=now[i];
}//一维乘二维
void pre()
{
	for(int i=1;i<=30;i++)
		a[i]=Max(a[i-1]);
}//预处理次幂
void fastpow(int x)
{
	for(int i=30;i>=0;i--)
		if(x&(1<<i))
			Maxx(a[i]);
}//快速幂
bool cmp(Fes x,Fes y)
{
	return x.t<y.t;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&T,&K);
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]),id[i][0]=i;
	memset(a,0xcfcf,sizeof(a));
	for(int i=1,u,v,w;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		for(int j=1;j<w;j++)
		{
			if(!id[u][j])
				id[u][j]=++n;
			a[0].p[id[u][j-1]][id[u][j]]=0;
		}
		a[0].p[id[u][w-1]][v]=c[v];//拆点
	}
	pre();
	for(int i=1;i<=K;i++)
		scanf("%d%d%d",&t(i),&x(i),&y(i));
	sort(b+1,b+K+1,cmp);t(K+1)=T;
	memset(dp,0xcfcf,sizeof(dp));dp[1]=c[1];//初状态
	for(int i=1,d;i<=K+1;i++)
	{
		d=t(i)-t(i-1);
		fastpow(d);
		dp[x(i)]+=y(i);//点权改变
	}//在相邻的时间之间转移
	printf(dp[1]<0?"-1":"%lld",dp[1]);
	return 0;
}
```

---

## 作者：xukuan (赞：1)

**注意：本篇题解中的代码只能在64-bit的电脑上运行，具体原因未知。以Windows Dev_C++为例，编译选项请选择TDM-GCC 一串数字 64-bit Release,而不是TDM-GCC 一串数字 32-bit Release**

**另外，由于不同网站评测机常数性能差异，部分常数较大的代码不能在洛谷上通过，本题建议有条件的同学使用XJOI开发版等其他较快的OJ测试**

看完这题没什么思路，再看数据范围

$0 \leq k \leq 200,1 \leq T \leq 10^9,1 \leq w_i \leq 5$

k和T的数据范围告诉我们这题要对转移用压缩处理，而$w_i$出奇的小：如果大家对[这题](https://www.luogu.com.cn/problem/P2886)有印象的话，就会发现：如果对于任意的$i$满足$w_i=1$，那么这两题是一样的。但是这题要记得边权转点权，最后答案加上$c_1$

很快我们会想到拆边，即对任意一条边$(x_i,y_i,z_i)$，把他拆成$(x_i,e_{i,1},0),(e_{i,1},e_{i,2},0),...,(e_{z_{i-1}},y_i,c_{x,i})$

这样的时间复杂度是$O(k(n+\sum_{i=1}^mw_i)^3log_2T) \leq O(k(n+4m)^3log_2T)$，只有45分

我们会发现，不论在何时，当$x_i$相同时，$e_{i,j}$的值都是相同的。所以我们可以把拆边变成拆点，即先预处理出$(i,e_{i,1},0),(e_{i,1},e_{i,2},0),(e_{i,2},e_{i,3},0),(e_{i,3},e_{i,4},0)$，然后连边时直接$(e_{x_i,z_i-1},y_i,c_{x_i})$，其中$e_{i,0}=x_i$

时间复杂度降到$O(k(5n)^3log_2T)$，35分，还是不够

对于矩阵快速幂：类似多重背包或完全背包的那个优化，考虑预处理出所有2的幂次，在询问的时候直接乘上去。

时间复杂度降到$O(k(5n)^3)$，55分，继续优化

**最重要的优化：我们发现我们对于矩阵快速幂的结果，真正有用的其实只有第一行，所以转移的时候后面的直接不选，时间复杂度降到$O(k(5n)^2log_2T)$，写的漂亮能过**

代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=260,INF=1ll<<60;
ll n,m,T,K,cnt,a[N],id[N][10];
struct matrix{
    ll mat[N][N];
    matrix(){memset(mat,-0x3f,sizeof(mat));}
}G[30];
struct node{
	ll QAQ[N];
	node(){memset(QAQ,-0x3f,sizeof(QAQ));}
}f[N];
struct GG{
	ll t,x,val;
}b[N];

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

inline matrix floyd(matrix a,matrix b){
	matrix c;
    for(ll k=1; k<=cnt; k++){
        for(ll i=1; i<=cnt; i++){
            for(ll j=1; j<=cnt; j++) c.mat[i][j]=max(c.mat[i][j],a.mat[i][k]+b.mat[k][j]);
        }
    }
    return c;
}

inline node mul(node a,matrix b){
	node c;
	for(ll k=1; k<=cnt; k++){
		for(ll j=1; j<=cnt; j++) c.QAQ[j]=max(c.QAQ[j],a.QAQ[k]+b.mat[k][j]);
	}
	return c;
}

inline node ksm(node x,ll y){
    for(ll i=0; (1<<i)<=y; i++){
    	if(y&(1<<i)) x=mul(x,G[i]);
	}
	return x;
}

inline bool cmp(GG a,GG b){
	return a.t<b.t;
}

int main(){
    cnt=n=read(); m=read(); T=read(); K=read();
    for(ll i=1; i<=n; i++) a[i]=read();
    for(ll i=1; i<=n; i++){
    	id[i][0]=i;
    	for(ll j=1; j<=4; j++){
    		id[i][j]=++cnt;
    		G[0].mat[id[i][j-1]][id[i][j]]=0;
		}
	}
    while(m--){
        ll x=read(),y=read(),z=read();
        G[0].mat[id[x][z-1]][y]=max(G[0].mat[id[x][z-1]][y],a[x]);
    }
    for(ll i=1; (1<<i)<=T; i++) G[i]=floyd(G[i-1],G[i-1]);
    for(ll i=1; i<=K; i++){
    	b[i].t=read();
    	b[i].x=read();
    	b[i].val=read();
	}
	b[++K].t=T;
	sort(b+1,b+1+K,cmp);
	f[0].QAQ[1]=0;
	for(ll i=1; i<=K; i++){
		f[i]=ksm(f[i-1],b[i].t-b[i-1].t);
		if(b[i].x) f[i].QAQ[b[i].x]+=b[i].val;
	}
	if(f[K].QAQ[1]<0) cout<<"-1"; 
	else cout<<f[K].QAQ[1]+a[1]<<endl;
    return 0;
}
```

---

## 作者：chenxia25 (赞：1)

NOI 签到题我都不会哦~

> ### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6772)

>题意见洛谷。（以下用 $K$ 表示 $k$ 以避免与迭代变量冲突）

首先有个很显然的 DP：$dp_{i,j}$ 表示第 $i$ 天小 W 在城市 $j$ 的情况下获得的最大愉悦值之和。边界：$dp_{0,i}=\begin{cases}c_1&i=1\\-\infty&i\neq1\end{cases}$；目标：$dp_{T,1}$；状态转移方程：

$$dp_{i,j}=\max_{(k,j,len)\in E}\{dp_{i-len,k}+c_j+ext(i,j)\}$$

其中 $ext(i,j)$ 表示第 $i$ 天城市 $j$ 通过美食节额外获得的愉悦值。

暴力 DP 肯定是不行的。这个 $T$ 这么大，一脸矩阵快速幂的样子。

考虑用矩阵的形式将状态转移方程写出来。我们重定义矩阵乘法，将 $\times$ 改为 $+$，将 $+$ 改为 $\max$，学过 DDP 的都知道这样满足原矩阵乘法的一切性质~~（我没学过 DDP 都知道）~~。需要注意的是，这种乘法意义下的单位元是

$$I=\begin{bmatrix}0&-\infty&-\infty &\cdots&-\infty\\-\infty&0&-\infty&\cdots&-\infty\\-\infty&-\infty&0&\cdots&-\infty\\\vdots&\vdots&\vdots&\ddots&-\infty\\-\infty&-\infty&-\infty&-\infty&0\end{bmatrix}$$

具体广义乘法这套理论等到我学 DDP 再研究吧。于是：

$$\begin{bmatrix}dp_{i,1}&dp_{i,2}&\cdots&dp_{i,n}&\cdots&dp_{i-4,n}\end{bmatrix}\Delta_i=\begin{bmatrix}dp_{i+1,1}&dp_{i+1,2}&\cdots&dp_{i+1,n}&\cdots&dp_{i-3,n}\end{bmatrix}$$

其中 $\Delta$ 是啥就不详细说了，大概就是前 $n$ 列是转移方程里的 $c_j+ext(i,j)$（如果转移不到就是 $-\infty$），后 $4n$ 列是一些 $0$ 和 $-\infty$ 表示移位。

注意到大多数时候 $ext(i,j)=0$，只存在 $\mathrm O(K)$ 个 $i$ 使得不等于零。而所有 $ext$ 为零的时候的 $\Delta$ 是相等的，于是考虑按有美食节的时间分段，每段快速幂，有美食节的时间暴力修改矩阵单独转移。

这样复杂度为 $\mathrm O\!\left(KN^3\log T\right)$，其中 $N=5n$。显然过不去，瓶颈在于快速幂。

如何优化呢？注意到这里是同底数幂，想到进制光速幂，即设一个 $x$ 进制，预处理出 $\Delta^0,\Delta^{x^y},\cdots,\Delta^{x^y(x-1)}$，其中 $y\in[0,\lceil\log_xT\rceil]$，然后每次算幂的时候将指数 $x$ 进制拆分乘即可。时间复杂度 $\mathrm O\!\left(N^3x\log_xT+KN^3\log_xT\right)$。本来就卡的很紧，似乎并没啥卵用。

但是！这样一来，算幂的时候每次乘法（共 $\mathrm O(\log_xT)$ 次）可以利用矩阵乘法的结合律，将矩阵乘到向量上去，时间复杂度 $\mathrm O(N^2)$！然鹅直接使用快速幂的话，一次快速幂是一个整体，无法在其过程中乘以向量；光速幂的优点是，它将乘的过程拆开了。

总时间复杂度 $\mathrm O\!\left(N^3x\log_xT+KN^2\log_xT\right)$。xjb 取个 $x=2$ 即可得到 $\mathrm O\!\left(N^3\log T+KN^2\log T\right)$ 的复杂度。由于矩阵乘法常数非常小，可以通过。

这里「xjb 取个 $x=2$」，换句话说就是光速幂的优化的地方不在「光速」，而在用矩阵乘法的结合律降低单次乘法的复杂度，这大概是个矩阵乘法比较惯用的套路吧。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define mp make_pair
#define X first
#define Y second
const int inf=0x3f3f3f3f3f3f3f3f;
const int N=50,T=200,LOG_T=32; 
int n,m,s,t;
int c[N+1];
vector<pair<int,int> > rnei[N+1];
pair<int,pair<int,int> > spc[T+2];
struct matrix{
	int a[5*N][5*N];
	int *operator[](int x){return a[x];}
	matrix(){
		for(int i=0;i<5*N;i++)for(int j=0;j<5*N;j++)a[i][j]=i==j?0:-inf;
	}
	friend matrix operator*(matrix x,matrix y){
		matrix res;
		for(int i=0;i<5*n;i++)for(int j=0;j<5*n;j++)res[i][j]=-inf;
		for(int i=0;i<5*n;i++)for(int j=0;j<5*n;j++)for(int k=0;k<5*n;k++)
			res[i][j]=max(res[i][j],x[i][k]+y[k][j]);
		return res;
	}
	friend vector<int> operator*(vector<int> x,matrix y){
		vector<int> res(5*n,-inf);
		for(int j=0;j<5*n;j++)for(int k=0;k<5*n;k++)
			res[j]=max(res[j],x[k]+y[k][j]);
		return res;
	}
};
matrix pw[LOG_T];
vector<int> dp;
signed main(){
	cin>>n>>m>>s>>t;
	for(int i=1;i<=n;i++)cin>>c[i];
	while(m--){
		int x,y,z;
		cin>>x>>y>>z;
		rnei[y].pb(mp(x,z));
	}
	for(int i=1;i<=t;i++)cin>>spc[i].X>>spc[i].Y.X>>spc[i].Y.Y;
	for(int i=0;i<5*n;i++)for(int j=0;j<5*n;j++)pw[0][i][j]=-inf;
	for(int i=1;i<=n;i++)for(int j=0;j<rnei[i].size();j++)
		pw[0][(rnei[i][j].Y-1)*n+rnei[i][j].X-1][i-1]=c[i];
	for(int i=n;i<5*n;i++)pw[0][i-n][i]=0;
	for(int i=1;i<LOG_T;i++)pw[i]=pw[i-1]*pw[i-1];
	sort(spc+1,spc+t+1);
	spc[++t]=mp(inf,mp(0,0));
	dp.resize(5*n,-inf);dp[0]=c[1];
	for(int i=1;i<=t;i++){
		if(spc[i].X>s){
			int e=s-spc[i-1].X;
			for(int j=0;j<LOG_T;j++)if(e&1<<j)dp=dp*pw[j];
			break;
		}
		int e=spc[i].X-1-spc[i-1].X;
		for(int j=0;j<LOG_T;j++)if(e&1<<j)dp=dp*pw[j];
		matrix delta=pw[0];
		for(int j=0;j<5*n;j++)delta[j][spc[i].Y.X-1]+=spc[i].Y.Y;
		dp=dp*delta;
	}
	if(dp[0]<0)puts("-1");
	else cout<<dp[0];
	return 0;
}
```

---


# [CEOI 2020] 道路

## 题目背景

0.3s，32MB

## 题目描述

Treeland 政府准备建立一个全新的道路网。Treeland 共有 $2N$ 个城市，目前已经修建了 $N$ 条道路，每条道路都是一条连接两个城市的线段。这 $N$ 条道路两两没有交点（包括端点处）。你现在需要再修建 $N-1$ 条道路，要求：

1. 每条道路都是一条连接两个城市的线段。
2. 道路只能在端点处相交。
3. 对于任意两个城市，均能通过该路网相互抵达。

## 说明/提示

### 样例解释

下图中，实线表示已经修建的道路，虚线代表新修道路。

![](https://cdn.luogu.com.cn/upload/image_hosting/qxnetdvo.png)

### 子任务

所有数据均满足：$2 \leq N \leq 10^5$，$-10^7 \leq x_1,y_1,x_2,y_2 \leq 10^7$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                 |
| ---------- | ---- | ------------------------------------ |
| $1$        | $0$  | 样例                                 |
| $2$        | $15$ | 输入的所有线段均为竖直线段           |
| $3$        | $15$ | 任意两条输入线段互相平行             |
| $4$        | $15$ | 输入的所有线段均为水平线段或竖直线段 |
| $5$        | $15$ | $N \leq 10^4$                        |
| $6$        | $40$ | 无特殊约束                           |

注意实际评测分值分配与上述约定不同。

## 样例 #1

### 输入

```
5
1 3 3 6
5 1 5 3
3 3 6 5
2 1 4 1
2 3 4 2```

### 输出

```
2 1 1 3
2 3 2 1
3 3 2 3
5 1 4 2```

# 题解

## 作者：s_r_f (赞：9)

[我的CEOI作战记录&题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ceoi2020-zuo-zhan-ji-lu-ti-xie-shi-gong-zhong-post)

[我的CEOI作战记录&题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13581895.html)

---

计算几何扫描线题.

首先为了防止出现一些边界情况，(比如有一条无斜率的线段)，可以把点转一个角度。

用set维护当前的所有线段，并记录每条线段上方，最晚被插入/删除的**后继**的线段。

然后从左到右扫描线，

在每次加入线段的时候，考虑把加入的线段的左端点和set里的一个点连接起来。

考虑这个线段在set上的前驱，如果前驱上记录了点，那我就把这个点和记录的点连起来，否则我就和前驱这条线段的左端点连起来。  同时用当前这条线段的左端点来更新前驱记录的点。

在每次删除点的时候，更新一下set上的前驱记录的点即可。

复杂度$O(n \log n).$

代码 :
```cpp
#define db long double
const int N = 100050;
db Pi = acos(-1.0),theta = Pi * (1.0 * 139 / 180),cost = cos(theta),sint = sin(theta);
struct point{
	db x,y; int realx,realy;
	inline void calc(){ x = cost * realx - sint * realy,y = cost * realy + sint * realx; }
}p[N<<1]; int n;
inline void print(point a,point b){
	cout << a.realx << ' ' << a.realy << ' ' << b.realx << ' ' << b.realy << '\n';
}
struct Event{
	int id,tp; db x;
	bool operator < (Event w) const{ return x < w.x; }
}ev[N<<1];
db T;
struct line{
	int s,t; mutable int lst; db k,b;
	inline void calc(){ k = (p[s].y - p[t].y) / (p[s].x - p[t].x),b = p[s].y - k * p[s].x; }
	bool operator < (const line w) const{ return k*T+b < w.k*T+w.b; }
}tmp;
set<line>S; set<line>::iterator it;
int main(){
	int i;
	ios::sync_with_stdio(0);
	cin >> n;
	for (i = 1; i <= n*2; i += 2){
		cin >> p[i].realx >> p[i].realy,p[i].calc();
		cin >> p[i+1].realx >> p[i+1].realy,p[i+1].calc();
		if (p[i].x > p[i+1].x) swap(p[i],p[i+1]);
		ev[i].id = i,ev[i].tp = 1,ev[i].x = p[i].x;
		ev[i+1].id = i+1,ev[i+1].tp = 0,ev[i+1].x = p[i+1].x;
	}
	sort(ev+1,ev+(n<<1|1));
	tmp.s = -2,tmp.t = tmp.lst = 0,tmp.k = 0,tmp.b = -1e10; S.insert(tmp);
	tmp.s = -1,tmp.t = tmp.lst = 0,tmp.k = 0,tmp.b = 1e10; S.insert(tmp);
	for (i = 1; i <= n*2; ++i){
		T = ev[i].x;
		if (ev[i].tp){
			tmp.lst = tmp.s = ev[i].id,tmp.t = ev[i].id+1,tmp.calc();
			it = S.insert(tmp).first,--it;
			if (it->lst) print(p[it->lst],p[tmp.s]); it->lst = tmp.s;
		}
		else{
			tmp.s = ev[i].id-1,tmp.t = ev[i].id,tmp.calc(),it = S.find(tmp),--it;
			it->lst = tmp.t,S.erase(tmp);
		}
	}
	return 0;
}
```

---

## 作者：Thunder_S (赞：4)

## Solution

首先为了避免斜率正无穷这种极端情况的出现，可以将点进行一个旋转。$(x,y)$ 逆时针转 $\alpha$ 角后的坐标是 $(x\cos\alpha-y\sin\alpha,x\sin\alpha+y\cos\alpha)$。

计算几何题中出现线段需要统计一些结果的，一般使用扫描线来完成。

假设扫描线从左往右扫。扫描过程中，扫描线会不断被给出的线段分割成若干个区域。当扫描线碰到某条线段的左端点时，说明此时又新增了一个区域。那么我们找出此前该区域内 $x$ 坐标最大的点，与当前点连边即可。注意更新各区域的 $x$ 坐标最大的点。

当扫到线段的右端点时，就将两个区域合并，同时更新一下最大的 $x$ 坐标。

具体过程可以用 $\text{set}$ 来实现。

## Code

```cpp
#include<set>
#include<cmath>
#include<cstdio>
#include<algorithm>
#define N 100050
#define inf 10000000000
#define ldb long double
using namespace std;
int n;
ldb nowx;
ldb Pi=acos(-1.0),alpha=Pi*(1.0*139/180),cosal=cos(alpha),sinal=sin(alpha);
struct po
{
    int rlx,rly;
    ldb x,y;
    void calc()
    {
        x=cosal*rlx-sinal*rly;
        y=cosal*rly+sinal*rlx;
    }
}a[N<<1];
struct px
{
    int id,tp;
    ldb x;
}c[N<<1];
struct line
{
    int st,ed;mutable int pre;
    ldb k,b;
    void calc()
    {
        k=(a[st].y-a[ed].y)/(a[st].x-a[ed].x);
        b=a[st].y-k*a[st].x;
    }
    bool operator <(const line x) const {return k*nowx+b<x.k*nowx+x.b;};
}now;
set<line> S;
set<line>::iterator it;
bool cmp(px x,px y) {return x.x<y.x;}
int main()
{
    freopen("network.in","r",stdin);
    freopen("network.out","w",stdout);
    scanf("%d",&n);
    for (int i=1;i<=2*n;i+=2)
    {
        scanf("%d%d",&a[i].rlx,&a[i].rly);a[i].calc();
        scanf("%d%d",&a[i+1].rlx,&a[i+1].rly);a[i+1].calc();
        if (a[i].x>a[i+1].x) swap(a[i],a[i+1]);
        c[i].x=a[i].x;c[i].id=i;c[i].tp=1;
        c[i+1].x=a[i+1].x;c[i+1].id=i+1;c[i+1].tp=0;        
    }
    sort(c+1,c+2*n+1,cmp);
    now.st=-2;now.ed=0;now.pre=0;now.k=0;now.b=-inf;S.insert(now);
    now.st=-1;now.ed=0;now.pre=0;now.k=0;now.b=inf;S.insert(now);
    for (int i=1;i<=2*n;++i)
    {
        nowx=c[i].x;
        if (c[i].tp)
        {
            now.pre=now.st=c[i].id;now.ed=c[i].id+1;
            now.calc();
            it=S.insert(now).first;--it;
            if (it->pre) printf("%d %d %d %d\n",a[it->pre].rlx,a[it->pre].rly,a[now.st].rlx,a[now.st].rly);
            it->pre=now.st;
        }
        else
        {
            now.st=c[i].id-1;now.ed=c[i].id;
            now.calc();
            it=S.find(now);--it;
            it->pre=now.ed;
            S.erase(now);
        }
    }
    return 0;
}

```
代码可能有亿点相似，请见谅。

感谢 s_r_f 大佬的题解->[传送门](https://www.luogu.com.cn/blog/s-r-f/solution-p6802)

---


# [CEOI 2020] 权力药水

## 题目背景

3s，256MB

## 题目描述

很久以前，在萨满之岛上，所有人都住在一个如天一样高的豆茎上。每位萨满都有一个独一无二的编号，编号的范围在 $0$ 和 $N-1$ 之间。第 $i$ 位萨满居住的高度用 $H_i$ 表示。定义两位萨满间的距离为其高度差的绝对值。

所有的萨满之间本来和谐共处，直到一天权力药水的配方被盗。为了掩盖他的行径，那位小偷给整座岛施加了诅咒，大多数居民不再彼此信任了。

虽然情况非常复杂，但是经过调查，某组织还是获得了如下信息：

- 诅咒刚生效时，所有的萨满停止彼此信任。
- 诅咒本身是不稳定的，在每天将要结束时（准确来说是午夜），某一对萨满将会建立信任或是停止信任。
- 不幸地是，一位萨满在任意时刻最多信任 $D$ 位萨满。

该组织还重建了萨满间的信任变化日志，该日志记录了在每个半夜，哪对萨满的信任关系发生了变化（从不信任到信任，或是从信任到不信任）。

该组织的成员相信，小偷还向一位邪恶的萨满通过隔空传话的方式泄露了配方。为了避免被发现，他们俩都各自拜访了一位信任的萨满的家，在拜访的过程中，小偷透过窗户向邪恶的萨满泄露配方。需要注意的是，那位信任的朋友当时不必在家中，事实上，两位萨满可能互相前往对方的家。毕竟萨满都很奇怪。

幸运的是，因为萨满们的听力有限，声音并不能传出太远，这意味着两位朋友（小偷的朋友和邪恶的萨满的朋友）之间的距离必须尽可能近。

现在该组织决定让你来协助调查。他们想要验证自己的猜想：当小偷为 $x$，邪恶的萨满为 $y$，泄露配方的日子为 $v$ 时，隔空传话的声音需要行进的最小值是多少？也即，你需要在第 $v$ 天时，在 $x$ 信任的所有萨满中找到一位萨满 $x'$，在 $y$ 信任的所有萨满中找到一位萨满 $y'$，使 $x'$ 和 $y'$ 间的距离最小。

你已经获得了求出答案所需的所有信息，但你需要**实时**回答每一组询问。

## 说明/提示

### 样例解释

下面是询问的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/gdrha1bp.png)

下面是每一天时信任关系的变化情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/uulqejgp.png)

### 子任务

所有数据均满足：$2 \leq N \leq 10^5$，$1 \leq D \leq 500$，$0 \leq U \leq 2 \times 10^5$，$1 \leq Q \leq 5 \times 10^4$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                    |
| ---------- | ---- | --------------------------------------- |
| $1$        | $0$  | 样例                                    |
| $2$        | $17$ | $Q,U \leq 10^3$                         |
| $3$        | $14$ | 所有询问均满足 $v=U$                  |
| $4$        | $18$ | $\forall i \in [0,N)$，$H_i\in \{0,1\}$ |
| $5$        | $21$ | $U,N \leq 10^4$                         |
| $6$        | $30$ | 无特殊约束                              |

## 样例 #1

### 输入

```
6 5 11 4
2 42 1000 54 68 234
0 1
2 0
3 4
3 5
3 5
1 3
5 3
0 5
3 0
1 3
3 5
0 3 4
3 0 8
0 5 5
3 0 11```

### 输出

```
26
0
1000000000
14```

# 题解

## 作者：s_r_f (赞：4)

[我的CEOI作战记录&题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ceoi2020-zuo-zhan-ji-lu-ti-xie-shi-gong-zhong-post)

[我的CEOI作战记录&题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13581895.html)

观察数据范围,不难得出每组询问应当用 $O(D)$ 的时间复杂度解决,并且需要注意常数.

一开始的想法是直接暴力存每个点相邻的权值集合,然后每次修改更新一次权值,这样就可以有序地取出在时间 $t$ 时节点 $x$ 和 $y$ 相邻点的权值集合了.

时空复杂度都是 $O(UD),$ 会爆空间.

那么我们其实就是要在**可持久化**的情况下支持 $O(D)$ 取出每个点在某个时刻的 $O(D)$ 个相邻点的权值,并且需要保证有序.

一种写法是直接使用可持久化 $fhqTreap$ 直接对每个点相邻的权值进行可持久化,空间常数和时间常数都比较大,我当场使用了这个做法,花了 $3$ 个小时卡常.

另一种写法是 $uoj$ 群友口胡的: 对每个点按时间建线段树,然后在线段树上insert,用set记录集合.我没写过,不知道这个做法时间效率怎么样,不过这个做法空间相对较小.

$fhqTreap$ 做法代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100005,U = 200005;
int n,d,m,h[N];
const int V = U*60;
struct Treap{
	struct Node{ int lc,rc,pos,val,siz; }t[V]; int _cnt;
	inline int New_node(int v){ ++_cnt,t[_cnt].val = v,t[_cnt].pos = rand(),t[_cnt].siz = 1; return _cnt; }
	inline int Copy_node(int p){ return memcpy(t+(++_cnt),t+p,20),_cnt; }
	inline void up(int o){ t[o].siz = t[t[o].lc].siz + t[t[o].rc].siz + 1; }
	inline int getrnk(int p,int v){
		static int ans; ans = 0;
		while (p) if (t[p].val > v) p = t[p].lc; else ans += 1 + t[t[p].lc].siz,p = t[p].rc;
		return ans;
	}
	inline void spilt(int p,int k,int &x,int &y){
		if (!p){ x = y = 0; return;	}
		if (t[t[p].lc].siz >= k) y = Copy_node(p),spilt(t[y].lc,k,x,t[y].lc),up(y);
		else x = Copy_node(p),spilt(t[x].rc,k-t[t[x].lc].siz-1,t[x].rc,y),up(x);
	}
	inline int merge(int x,int y){
		if (!x || !y) return x|y;
		if (t[x].pos < t[y].pos){ x = Copy_node(x),t[x].rc = merge(t[x].rc,y),up(x); return x;}
		y = Copy_node(y),t[y].lc = merge(x,t[y].lc),up(y); return y;
	}
	inline int add(int p,int v){
		static int k,x,y; k = getrnk(p,v); spilt(p,k,x,y);
		return merge(merge(x,New_node(v)),y);
	}
	inline int del(int p,int v){
		static int k,x,y,z; k = getrnk(p,v); spilt(p,k,x,y); spilt(x,k-1,x,z);
		return merge(x,y);
	}
 	int aa[505],llen;
	inline void Get(int rt){ if (t[rt].lc) Get(t[rt].lc); aa[++llen] = t[rt].val; if (t[rt].rc) Get(t[rt].rc); }
	inline void getall(int rt,int *a,int &len){
		if (!rt) len = 0; else llen = 0,Get(rt),len = llen,memcpy(a,aa,len+1<<2);
	}
}Tr;
vector<int>G[N],Gt[N];
inline int query(int x,int t){
	int L = 1,R = Gt[x].size()-1,Mid,Ans = 0;
	while (L <= R){
		Mid = L+R>>1;
		if (Gt[x][Mid] <= t) Ans = G[x][Mid],L = Mid + 1; else R = Mid - 1;
	}
	return Ans;
}
int ans,lena,lenb,a[505],b[505];
inline void upd(int x){ x < ans ? ans = x : 0; }
inline void QUery(){
	static int x,y,t,i,j;
	cin >> x >> y >> t,++x,++y,ans = 1000000000;
	Tr.getall(query(x,t),a,lena); Tr.getall(query(y,t),b,lenb);
	i = j = 1;
	while (i < lena && j < lenb) if (a[i] < b[j]) upd(b[j]-a[i]),++i; else upd(a[i]-b[j]),++j;
	if (i == lena){ while (j <= lenb) upd((a[i] > b[j]) ? (a[i] - b[j]) : (b[j] - a[i])),++j; }
	else if (j == lenb){ while (i <= lena) upd((a[i] > b[j]) ? (a[i] - b[j]) : (b[j] - a[i])),++i; }
	cout << ans << '\n'; fflush(stdout);
}
set<int>S[N];
int main(){
	int i,q,x,y,vx,vy,t;
	srand(time(NULL));
	cin >> n >> d >> m >> q;
	for (i = 1; i <= n; ++i) cin >> h[i];
	for (i = 1; i <= n; ++i) G[i].push_back(0),Gt[i].push_back(0);
	for (i = 1; i <= m; ++i){
		cin >> x >> y,++x,++y; if (x > y) swap(x,y); vx = h[x],vy = h[y];
		Gt[x].push_back(i),Gt[y].push_back(i);
		if (S[x].count(y)){//have -> none
			S[x].erase(y);
			G[x].push_back(Tr.del(G[x].back(),vy));
			G[y].push_back(Tr.del(G[y].back(),vx));
		}
		else{//none -> have
			S[x].insert(y);
			G[x].push_back(Tr.add(G[x].back(),vy));
			G[y].push_back(Tr.add(G[y].back(),vx));
		}
	}
	while (q--) QUery();
	return 0;
}
```

---

## 作者：yyandy (赞：2)

提供一个思路简单，代码好写的~~乱搞~~做法。   

给定的高度是乱序的，所以我们首先应当排序并且对于人重新标号。  

考虑对于每次询问，如果我们已经知道了那两个人的朋友是谁，该怎么做。        

这个应该还是很 Easy 的，只需要枚举一个人的朋友，在另一个人的朋友集合里去找前驱和后继然后取 $\min$ 即可。    

可以直接二分，也可以搞一个指针，单次 $O(D\log D)$ 或 $O(D)$。  

现在要解决的就是快速找出一个人的朋友了。

如果离线，那就非常简单了，只需要将询问挂到对应的时间上去就可以了。

但此题要求强制在线，所以得另寻出路。

有一个非常暴力的想法就是取一个阈值 $B$。      

每隔 $B$ 的时间保存下当前每个人的朋友状况。         

然后我们就可以利用已知的信息，再进行较少的修改得知当前的朋友状况了。        

不过虽然是较少的修改，如果用 `set` 或者 `vector` 存朋友都会寄掉。  

我这里用了 bitset 来存询问的两个人的朋友，最后只用使用 `bitset` 的 `_Find_next` 操作就可以知道朋友集合了。           

时间复杂度 $O(\frac{NQ}{w}+\frac{QU}{B}+\frac{U^2}{B}+QD)$。     

由于前面一部分保存朋友状况常数巨大，后一部分 `bitset` 常数很小，$B=9000$ 左右反而跑得很快。

#### Code:

```cpp
#include<bits/stdc++.h>
#define fi first 
#define se second
#define mp make_pair 
using namespace std;
const int Lim=9000;
set<pair<int,int> > S,R[85];
vector<int> v[2100002];
bitset<100020> B[2];
int n,m,u,q,x[200020],y[200020],Fr[100020],k,L;
pair<int,int> c[100020];
int main(){
	ios::sync_with_stdio(0),cin>>n>>m>>u>>q;
	for(int i=0;i<n;++i)cin>>c[i].fi,c[i].se=i;sort(c,c+n);
	for(int i=0;i<n;++i)Fr[c[i].se]=i;
	for(int i=1;i<=u;++i){
		cin>>x[i]>>y[i];
		x[i]=Fr[x[i]],y[i]=Fr[y[i]];
		if(x[i]>y[i])swap(x[i],y[i]);
		if(S.find(mp(x[i],y[i]))!=S.end())S.erase(mp(x[i],y[i]));
		else S.insert(mp(x[i],y[i]));
		if(i%Lim==0){++k,L+=n;
			for(auto i:S)v[L+i.first].push_back(i.second),v[L+i.second].push_back(i.first);
		}
	}
	while(q--){
		int xx,yy,w;
		cin>>xx>>yy>>w,B[0].reset(),B[1].reset(),xx=Fr[xx],yy=Fr[yy];
		if(xx>yy)swap(xx,yy);int cc=w/Lim,p=w%Lim;
		for(int i:v[cc*n+xx])B[0].set(i);for(int i:v[cc*n+yy])B[1].set(i);
		for(int j=cc*Lim+1;j<=w;++j){
			if(x[j]==xx)B[0].flip(y[j]);if(y[j]==xx)B[0].flip(x[j]);
			if(x[j]==yy)B[1].flip(y[j]);if(y[j]==yy)B[1].flip(x[j]);
		}
		int r=B[1]._Find_first(),lst=-1,Mn=1e9;
		for(int j=B[0]._Find_first();j<n;j=B[0]._Find_next(j)){
			while(r<=j&&r<n)lst=r,r=B[1]._Find_next(r);if(!Mn)break;
			if(lst>=0&&r<n)Mn=min(Mn,c[r].fi-c[j].fi),Mn=min(Mn,c[j].fi-c[lst].fi);
			else if(r<n)Mn=min(Mn,c[r].fi-c[j].fi);
			else if(lst>=0)Mn=min(Mn,c[j].fi-c[lst].fi);
		}
		cout<<Mn<<'\n',cout.flush();
	}
}
```

---

## 作者：luanmenglei (赞：0)

如果这道题可以离线，那么直接模拟就做完了。

考虑怎么转到在线，发现我们可以只记录 $m$ 天的修改的人的信任的人的集合，时间复杂度 $\mathcal{O}(UD+QD)$ 空间复杂度 $\mathcal{O}(UD)$。空间复杂度过大，无法通过。

发现其实有很多位置的数是没必要记录的，因为有效的信任对只有 $\mathcal{O}(M)$ 个，所以我们可以转为对每个萨满开一个数据结构来维护每一个时间点的信任的萨满集合，不难发现一颗动态开点线段树可以满足我们的需求。

现在的时间复杂度为 $\mathcal{O}(M \log M + QD \log M)$，空间复杂度为 $\mathcal{O}(M \log M)$，但由于常数过大仍然无法通过。

注意到存在很多在一段后缀存在的信任对，可以将这些信任对单独拎出来，直接二分统计，就可以通过了，线段树点数要开到 $6 \times 10^6$ 左右。

```cpp
#include <bits/stdc++.h>
using namespace std;

bool stB;

void debug(const char *msg, ...) {
#ifdef CLESIP
    va_list arg;
    static char pbString[512];
    va_start(arg,msg);
    vsprintf(pbString,msg,arg);
    cerr << "[DEBUG] " << pbString << "\n";
    va_end(arg);
#endif    
}

const int N = 1e5 + 10;
const int SEG_SIZE = 5.9e6;
int n, m, k, q, a[N], v[N], s1[510], s2[510];
vector<pair<int, int>> evt[N]; 
vector<pair<int, int>> suf[N];

int cnt, lc[SEG_SIZE], rc[SEG_SIZE], rt[N];
vector<int> cargo[SEG_SIZE];

void insert(int &x, int l, int r, int ql, int qr, int k) {
	if (!x) x = ++ cnt, assert(cnt < SEG_SIZE);
	if (ql <= l && r <= qr) {
		cargo[x].push_back(k);
		return;
	}
	int mid = (l + r) >> 1;
	if (ql <= mid) insert(lc[x], l, mid, ql, qr, k);
	if (mid < qr) insert(rc[x], mid + 1, r, ql, qr, k);
}

void query(int x, int l, int r, int pos, int *arr, int &tot) {
	if (!x) return;
	for (int val : cargo[x]) arr[++ tot] = val;
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (pos <= mid) query(lc[x], l, mid, pos, arr, tot);
	else query(rc[x], mid + 1, r, pos, arr, tot);
}

void solve(int x, int y, int t) {
	int len1 = 0, len2 = 0;
	query(rt[x], 1, m, t, s1, len1);
	query(rt[y], 1, m, t, s2, len2);

	int pos_x = lower_bound(suf[x].begin(), suf[x].end(), make_pair(t + 1, 0)) - suf[x].begin() - 1;
	for (int i = 0; i <= pos_x; i ++) s1[++ len1] = suf[x][i].second;
	int pos_y = lower_bound(suf[y].begin(), suf[y].end(), make_pair(t + 1, 0)) - suf[y].begin() - 1;
	for (int i = 0; i <= pos_y; i ++) s2[++ len2] = suf[y][i].second;


	sort(s1 + 1, s1 + 1 + len1);

	int ans = 1e9;
	for (int i = 1; i <= len2; i ++) {
		int pos = lower_bound(s1 + 1, s1 + 1 + len1, s2[i]) - s1;
		if (pos <= len1) ans = min(ans, s1[pos] - s2[i]);
		if (pos >= 2) ans = min(ans, s2[i] - s1[pos - 1]);
	}
	cout << ans << "\n";
	cout.flush();
}

bool edB;

int main() {
	cerr << "Memory: " << (&stB - &edB) / 1024.0 / 1024.0 << "MB\n"; 
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> k >> m >> q;
	for (int i = 1; i <= n; i ++) cin >> a[i];
	for (int i = 1, x, y; i <= m; i ++) {
		cin >> x >> y; ++ x, ++ y;
		evt[x].emplace_back(y, i);
		evt[y].emplace_back(x, i);
	}
	for (int x = 1; x <= n; x ++) {
		// cerr << x << "\n";
		for (auto [y, t] : evt[x]) {
			if (v[y]) {
				insert(rt[x], 1, m, v[y], t - 1, a[y]);
				v[y] = 0;
			} else {
				v[y] = t;
			}
		}
		for (auto [y, t] : evt[x]) if (v[y]) suf[x].emplace_back(v[y], a[y]), v[y] = 0;
		sort(suf[x].begin(), suf[x].end());
	}
	debug("cnt: %d", cnt);
	while (q --) {
		int x, y, t; cin >> x >> y >> t;
		solve(x + 1, y + 1, t);
	}
	cerr << "Time: " << clock() / 1000.0 << "S\n";
	return 0;
}
```

---

## 作者：Rosaya (赞：0)

### 题意

[P6804 [CEOI2020] 权力药水](https://www.luogu.com.cn/problem/P6804)

### 思路

首先如果可以离线的话问题是极简单的。

就是把大小不超过 $D$ 的集合拿出来用就行了，每次用两个当前最小值更新答案，然后将较小的数往后推。

这样的话每个数只会与另一个序列中最小的比它大的数贡献一次答案，复杂度 $O(D)$。

现在要求在线，导致空间开不下。

我们考虑少维护一些信息，用时间换空间。

具体地，我们考虑分块，设块长为 $B$，则空间为 $O(\dfrac{N}{B} \cdot U)$。

然后我们考虑将剩下的 $O(B)$ 的贡献打到其相关的点上排序，并且先排序，之后我们可以 $O(B)$ 统计每个数出现次数并与已经记录的信息归并，这部分空间为 $O(U)$。

最后用 set 维护动态图，总时间复杂度 $O(U \log U + \dfrac{N}{B} \cdot U +Q \cdot (B+D))$。

因为 $O(B)$ 统计根本跑不满，所以 $B=20000$ 的时候效率很高，足以通过。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int B=20000;

struct Node
{
    int t,v;
    Node(int t,int v):t(t),v(v){}
    bool operator<(const Node &tp)const{return v<tp.v;}
};

int n,d,_,q,cnt;
int num[100005],id[100005],h[100005];
vector<Node> adj[15][100005];
vector<int> ed[15][100005],nm[2];
set<int> s[100005]; 

inline bool cmp(int x,int y){return h[x]<h[y];}

inline void add(int u,int v,int t)
{
    adj[(t-1)/B][u].push_back(Node(t,v));
    auto it=s[u].lower_bound(v);

    if(it==s[u].end()||(*it)!=v)
        s[u].insert(v);
    else
        s[u].erase(v);
}

inline void sol(int u,int t)
{
    for(auto x:s[u])
        ed[t][u].push_back(x);

    sort(adj[t-1][u].begin(),adj[t-1][u].end());
}

inline void getnum(int u,int t,int d)
{
    int p=t/B,x;
    int cnt0=0,cnt1=0,siz0=adj[p][u].size(),siz1=ed[p][u].size();

    while(cnt0!=siz0||cnt1!=siz1)
    {
        int k=0;

        if(cnt0==siz0)
        {
            nm[d].push_back(ed[p][u][cnt1]);
            cnt1++;
        }
        else if(cnt1==siz1)
        {
            x=cnt0;
            while(x!=siz0&&adj[p][u][cnt0].v==adj[p][u][x].v)
            {
                if(adj[p][u][x].t<=t)
                    k^=1;
                x++;
            }
            if(k)
                nm[d].push_back(adj[p][u][cnt0].v);
            cnt0=x;
        }
        else if(adj[p][u][cnt0].v<ed[p][u][cnt1])
        {
            x=cnt0;
            while(x!=siz0&&adj[p][u][cnt0].v==adj[p][u][x].v)
            {
                if(adj[p][u][x].t<=t)
                    k^=1;
                x++;
            }
            if(k)
                nm[d].push_back(adj[p][u][cnt0].v);
            cnt0=x;
        }
        else if(adj[p][u][cnt0].v>ed[p][u][cnt1])
        {
            nm[d].push_back(ed[p][u][cnt1]);
            cnt1++;
        }
        else
        {
            x=cnt0;
            while(x!=siz0&&ed[p][u][cnt1]==adj[p][u][x].v)
            {
                if(adj[p][u][x].t<=t)
                    k^=1;
                x++;
            }
            if(!k)
                nm[d].push_back(ed[p][u][cnt1]);
            cnt0=x;
            cnt1++;
        }
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    cin>>n>>d>>_>>q;

    for(int i=0;i<n;i++)
        cin>>h[i],num[i+1]=i;

    sort(num+1,num+n+1,cmp);

    for(int i=1;i<=n;i++)
        id[num[i]]=i;

    for(int i=1;i<=_;i++)
    {
        int x,y;
        cin>>x>>y;
        x=id[x],y=id[y];

        add(x,y,i);
        add(y,x,i);

        if(i%B==0||i==_)
        {
            for(int j=1;j<=n;j++)
                sol(j,(i-1)/B+1);
        }
    }

    while(q--)
    {
        int x,y,z,mn=1000000000;

        cin>>x>>y>>z;
        x=id[x],y=id[y];

        nm[0].clear(),nm[1].clear();
        nm[0].shrink_to_fit(),nm[1].shrink_to_fit();

        getnum(x,z,0);
        getnum(y,z,1);

        int cnt0=0,cnt1=0,siz0=nm[0].size(),siz1=nm[1].size();

        while(cnt0!=siz0&&cnt1!=siz1)
        {
            if(nm[0][cnt0]<nm[1][cnt1])
            {
                mn=min(mn,h[num[nm[1][cnt1]]]-h[num[nm[0][cnt0]]]);
                cnt0++;
            }
            else
            {
                mn=min(mn,h[num[nm[0][cnt0]]]-h[num[nm[1][cnt1]]]);
                cnt1++;
            }
        }

        cout<<mn<<endl;
    }

    return 0;
}
```

---

## 作者：7KByte (赞：0)

题意不是很复杂，只不过出题人强行把题面写的很长。

首先 $D$ 很小，所以对于每个询问，我们可以直接找出两个人信任的人的集合，然后双指针扫一遍即可。

对询问离线，然后维护每个人的集合即可，这道题就做完了（

但是本题强制在线，把小清新模拟题强行变成毒瘤题。

我们需要记录，每个人，在每一时刻，信任的人的集合，这复杂度是 $\mathcal{O}(NMD)$ 的，显然不行。

考虑对每个人动态开点，那么剩下的状态数是 $\mathcal{O}(MD)$ 还是吃不消。

$M$ 比较大，将时间作为动态开点的下标，那么对于一个关系 $(x,y)$，可以计算出它在图中存活的时间段，然后在线段树中区间加。

因为是动态开点线段树，所以我们需要标记永久化。最后在线段树上单点查询即可得到集合，排序后跑双指针得到答案。

时间复杂度 $\mathcal{O}(M\log M+QD\log D)$。另外本题卡空间，观察一下发现不少关系 $(x,y)$ 的存活时间都是从某个时间开始，一直持续到结束。对于这类关系，我们直接对每个点开一个变长数组维护即可。因为这类关系对每个点的贡献也不会超过 $D$。

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 100005
#define ef 1000000000
using namespace std;
struct node {
    int l, r;
    vector<int>u;
} a[N * 55];
#define ls a[x].l
#define rs a[x].r
#define S a[x].u
int n, D, m, q, u[N], rt[N], idx;
void ins(int &x, int l, int r, int L, int R, int val) {
    if (!x)
        x = ++idx;

    if (L >= l && R <= r) {
        a[x].u.push_back(val);
        return ;
    }

    int mid = (L + R) >> 1;

    if (mid >= l)
        ins(ls, l, r, L, mid, val);

    if (mid < r)
        ins(rs, l, r, mid + 1, R, val);
}
vector<int>c[2];
void ask(int x, int L, int R, int pos, int op) {
    if (!x)
        return;

    for (int i = 0; i < (int)a[x].u.size(); i++)
        c[op].push_back(a[x].u[i]);

    if (L == R)
        return;

    int mid = (L + R) >> 1;

    if (mid >= pos)
        ask(ls, L, mid, pos, op);
    else
        ask(rs, mid + 1, R, pos, op);
}
vector<pair<int, int>>ad[N];
map<pair<int, int>, int>h;
inline void calc() {
    int p = c[0].size(), q = c[1].size();

    if (!p || !q) {
        cout << ef << endl;
        return;
    }

    sort(c[0].begin(), c[0].end());
    sort(c[1].begin(), c[1].end());
    int j = 0, mn = 0x7fffffff;
    rep(i, 0, q - 1) {
        while (j < p - 1 && c[0][j] <= c[1][i])
            j++;

        mn = min(mn, abs(c[0][j] - c[1][i]));

        if (j)
            mn = min(mn, abs(c[0][j - 1] - c[1][i]));
    }
    cout << mn << endl;
}
int main() {
    scanf("%d%d%d%d", &n, &D, &m, &q);
    rep(i, 1, n)scanf("%d", &u[i]);
    rep(i, 1, m) {
        int x, y;
        scanf("%d%d", &x, &y);
        x++, y++;

        if (x > y)
            swap(x, y);

        pair<int, int> cur = make_pair(x, y);

        if (h.count(cur)) {
            ins(rt[x], h[cur], i - 1, 1, m, u[y]);
            ins(rt[y], h[cur], i - 1, 1, m, u[x]);
            h.erase(h.find(cur));
        } else
            h.insert(make_pair(cur, i));
    }

    for (map<pair<int, int>, int>::iterator it = h.begin(); it != h.end(); it++) {
        int x = (*it).first.first, y = (*it).first.second;
        ad[x].push_back(make_pair(u[y], (*it).second));
        ad[y].push_back(make_pair(u[x], (*it).second));
    }

    while (q--) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        x++, y++;
        c[0].clear();
        c[1].clear();

        if (z) {
            ask(rt[x], 1, m, z, 0), ask(rt[y], 1, m, z, 1);

            for (int i = 0; i < (int)ad[x].size(); i++)
                if (ad[x][i].second <= z)
                    c[0].push_back(ad[x][i].first);

            for (int i = 0; i < (int)ad[y].size(); i++)
                if (ad[y][i].second <= z)
                    c[1].push_back(ad[y][i].first);

            calc();
        } else
            cout << ef << endl;
    }

    return 0;
}
```



---


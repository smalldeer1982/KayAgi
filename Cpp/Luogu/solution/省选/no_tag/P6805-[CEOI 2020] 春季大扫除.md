# [CEOI 2020] 春季大扫除

## 题目背景

0.3s，128MB

## 题目描述

春季大扫除也许是我们一生中最无聊的事情之一。当然，对于 Flóra 和她的母亲而言，今年的春季大扫除要有意思得多。因为她们在地毯下发现了一张已被灰尘覆盖的树形地图。

这棵树有 $N$ 个节点，节点从 $1$ 到 $N$ 进行编号，这 $N$ 个点通过 $N-1$ 条边相连。这些边上都积累了过多的灰尘，因此 Flóra 的母亲准备对这棵树进行清理。

清理这棵树的过程是这样的：Flóra 的母亲每次在这棵树上选择两个叶子节点（定义一棵树的叶子节点为只与恰好一个点直接相连的点），并对这两个叶子点路径上的所有边进行清理。如果这条路径上有 $d$ 条边，则清理的费用为 $d$。当这棵树上的所有边都被清理后，这棵树的清理过程就完成了。清理这棵树的总费用即为各次清理的费用之和。

因为她想保护这棵树的叶子节点，因此对于每个叶子节点，她最多只会选择一次。

Flóra 认为原来的树过于简单，她决定对原始的树进行一些改造。在第 $i$ 次改造中，她在原始的树的基础上添加了 $D_i$ 个叶子节点。具体来说，她会在原始的树上选择一个节点，并在该点与新的叶子节点之间连接一条边。需要注意的是，在添加新的叶子节点的过程中，原来的一些节点将不再是叶子节点。

现在你需要帮助 Flóra 求出清理改造后的树的最小费用。

## 说明/提示

### 样例解释

下面展示的是第二次改造后的树：

![](https://cdn.luogu.com.cn/upload/image_hosting/9rj8iovq.png)

一种最优的清理方案是清理 $1-6$，$A-7$，$B-3$ 这三条路径上的所有边。

### 子任务

所有测试点均满足：$3 \leq N \leq 10^5$，$1 \leq Q \leq 10^5$，$\sum D_i \leq 10^5$，$1 \leq u,v \leq N$，$1 \leq a_j \leq N$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                                         |
| ---------- | ---- | ------------------------------------------------------------ |
| $1$        | $0$  | 样例                                                         |
| $2$        | $9$  | $Q=1$，$\forall i \in [2,N]$，都存在一条连接 $1$ 和 $i$ 的边，且 Flóra 不会在 $1$ 号点上添加叶子节点 |
| $3$        | $9$  | $Q=1$，$\forall i \in [1,N)$，$i$ 和 $i+1$ 之间有边相连，且 Flóra 不会在 $1$ 号点或 $N$ 号点上添加叶子节点 |
| $4$        | $16$ | $N \leq 2 \times 10^4$，$Q \leq 300$                         |
| $5$        | $19$ | 原始的树是一棵以 $1$ 号点为根的满二叉树，即每个非叶子节点均有恰好两个子节点，且各叶子节点到根节点间的距离相等 |
| $6$        | $17$ | $\forall i \in [1,Q]$，$D_i=1$                               |
| $7$        | $30$ | 无特殊约束                                                   |

## 样例 #1

### 输入

```
7 3
1 2
2 4
4 5
5 6
5 7
3 4
1 4
2 2 4
1 1```

### 输出

```
-1
10
8```

# 题解

## 作者：s_r_f (赞：8)

[我的CEOI作战记录&题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ceoi2020-zuo-zhan-ji-lu-ti-xie-shi-gong-zhong-post)

[我的CEOI作战记录&题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13581895.html)

---

考虑一个 $O(nq)$ 的暴力/结论:

首先,如果叶子节点数目为奇数,则必然无解,返回 $-1$. 

随便选取一个度数 $>1$ 的点 $rt$ 为根进行dfs,然后考虑每个子树 $x(x\neq rt).$ 

记 $siz_x$ 为 $x$ 子树内的叶子节点个数,这个可以在dfs的过程中统计出.

如果 $siz_x$ 为奇数,那么 $x$ 到父亲的边至少要被清扫 $1$ 次.

如果 $siz_x$ 为偶数,那么 $x$ 到父亲的边至少要被清扫 $2$ 次.

---

证明:

可以发现这个问题是一个把所有叶子节点两两匹配并保证所有树上的边都被覆盖到的问题.

那么,每个子树 $x$ (除了根之外)必须要有至少一个叶子 $z$ ,它和子数外的另一个叶子进行匹配.

那么如果子树内的叶子数目是奇数,那么我就两两匹配然后留下 $1$ 个,否则我就两两匹配然后留下 $2$ 个.

因为所有非叶子节点度数 $>1$ ,并且每个子树往外匹配的叶子数目只有 $1$ 或 $2$ 个,所以一定可以成功匹配.

---

现在我们考虑优化.

答案为 总点数 $-$ $2$ $+$ $\sum\limits_{x∈T}[siz_x$ 是偶数 $]$

这个东西可以直接树剖维护, $O((\sum\limits_{i=1}^q D_i)\log^2 n).$ 

也可以用虚树做到 $O((n+ \sum\limits_{i=1}^q D_i)\log n).$ 

树剖做法代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100050;
int n,rt,deg[N],size[N],fa[N],dpt[N],son[N],dval[N],suml; bool isl[N];
vector<int>G[N];
inline void dfs1(int x){
	size[x] = 1,dval[x] = 0; isl[x] = 1;
	for (int y,i = 0; i < G[x].size(); ++i) if ((y=G[x][i])^fa[x]){
		fa[y] = x,dfs1(y),size[x] += size[y],isl[x] = 0,dval[x] ^= dval[y];
		if (size[y] > size[son[x]]) son[x] = y; 
	}
	if (isl[x]) dval[x] = 1,++suml;
}
int top[N],id[N],pos[N],Time;
inline void dfs2(int x){
	id[x] = ++Time; pos[Time] = x;
	if (son[x]){
		top[son[x]] = top[x],dfs2(son[x]);
		for (int y,i = 0; i < G[x].size(); ++i) if (!top[y=G[x][i]]) top[y] = y,dfs2(y);
	}
}
int f0[N<<2],f1[N<<2]; bool rev[N<<2];
inline void up(int o){ f0[o] = f0[o<<1] + f0[o<<1|1],f1[o] = f1[o<<1] + f1[o<<1|1]; }
inline void Build(int o,int l,int r){
	rev[o] = f0[o] = f1[o] = 0;
	if (l == r){ if (dval[pos[l]]) f1[o] = 1; else f0[o] = 1; return; }
	int mid = l+r>>1; Build(o<<1,l,mid); Build(o<<1|1,mid+1,r); up(o); 
}
inline void Tag(int o){ rev[o] ^= 1,swap(f0[o],f1[o]); }
inline void down(int o){ if (rev[o]) Tag(o<<1),Tag(o<<1|1),rev[o] = 0; }
int ll,rr;
inline void Rev(int o,int l,int r){
	if (ll <= l && rr >= r){ Tag(o); return; }
	down(o); int mid = l+r>>1; if (ll <= mid) Rev(o<<1,l,mid); if (rr > mid) Rev(o<<1|1,mid+1,r); up(o);
}
inline void change(int l,int r){ if (l <= r) ll = l,rr = r,Rev(1,1,n); }
inline void work(int x){
	while (top[x] ^ rt) change(id[top[x]],id[x]),x = fa[top[x]]; change(id[rt],id[x]);
}
int opv[N],_,p[N],len;
int main(){
	int i,x,y,q; suml = 0;
	cin >> n >> q;
	for (i = 1; i < n; ++i)	cin >> x >> y,G[x].push_back(y),G[y].push_back(x),++deg[x],++deg[y];
	for (i = 1; i <= n; ++i) if (deg[i] > 1) rt = i;
	dfs1(rt),top[rt] = rt,dfs2(rt); Build(1,1,n);
	while (q--){
		cin >> len;
		for (i = 1; i <= len; ++i) cin >> p[i];
		sort(p+1,p+len+1);
		int cl = suml + len;
		for (_ = 0,i = 1; i <= len; ++i){
			if (opv[_] == p[i]) --_; else opv[++_] = p[i];
			if (p[i] != p[i-1] && isl[p[i]]){
				if (opv[_] == p[i]) --_; else opv[++_] = p[i]; --cl;
			}
		}
		for (i = 1; i <= _; ++i) work(opv[i]);
		cout << ((cl&1) ? -1 : len + n - 2 + f0[1]) << '\n';
		for (i = 1; i <= _; ++i) work(opv[i]);
	}
	return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：3)

似乎没人用 LCT？没卡常的代码就 rk1 了。

随便以一个非叶节点为根从下往上考虑，设每个节点子树内的叶子个数为 $tt_x$。

每条边(设边中的儿子为 $x$)向上传一个叶子，如果 $tt_x$ 为偶数会有一个没配对，得多往上传一个，贡献就为 $1+[tt_x\%2=0]$。

总贡献为 $(\sum_x 1+[tt_x\%2=0])-1-[tt_{rt}\%2=0]$ ，因为根没有到父亲的边贡献所以要减掉。

设 $\sum_x1$，也就是树上的点数为 $n$，把式子化简一下：

原式 $=(n+\sum_x[tt_x\%2=0])-1-[tt_{rt}\%2=0]$

注意到总叶子个数为偶数才能两两配对，故有解时一定有 $[tt_{rt}\%2=0]=1$。

故原式 $=n-2+\sum_x[tt_x\%2=0]$

再看询问，就是到根 $tt$ 加一，全局查询。

树剖+线段树 = 两个数据结构 + 两只 log，LCT = 一个数据结构 + 一只 log，码量和复杂度上看都是 LCT 血赚。

具体实现上更简单，选定根后根不变，Make_root 都不用写，每次 Access 就行了。

注意一下加点后 $n$ 也要加就行了。

[跑得快但不会有人看的代码](https://www.luogu.com.cn/paste/s4lcl28j)

---

## 作者：Hoks (赞：2)

## 前言
duel $2300$ problem 的时候跳到的题，发现洛谷居然在主站里就搬了。

貌似不是很难，经典结论后随便套个树剖/虚树/全局平衡二叉树/LCT 貌似就做完了。

摘自 [杂题选做](https://www.luogu.com.cn/training/518105)。
## 思路分析
整体不好考虑，考虑对于每个点分开考虑。

不难发现，对于点 $x$，设其子树内叶子数为 $y$，则：
1. $y$ 是奇数，此时 $x$ 连向 $fa_x$ 的边至少经过一次。
2. $y$ 是偶数，此时 $x$ 连向 $fa_x$ 的边至少经过一次。

原因很简单，这条边首先要至少经过一次。

1. 如果是奇数，那么剩下的叶子就是偶数个，两两配对即可。
2. 如果是偶数，那么剩下的叶子就是奇数个，两两配对了还剩下一个，那必然要拿到子树外去匹配，所以至少经过两次。

接着考虑怎么修改，还是先分类讨论：
1. 如果加在叶子下，那么就相当于没有修改，不用管即可。
2. 如果加在非叶子下，那么就相当到路径上的奇偶性翻转，考虑用树剖/虚树/全局平衡二叉树/LCT 来维护，这里用的树剖做法。

    考虑线段树怎么维护这个东西，区间 $0,1$ 翻转，数 $1$ 数量，可以考虑先把 $0$ 和 $1$ 的数量都数出来，然后直接交换两个值即可。

接着是对于无解，如果总共有奇数个叶子包是不可能的，因为没法配对。

最后的就是实现细节问题：
1. 根节点不能是叶子，所以根节点的度数不能为 $1$。
2. 因为可能在一个点上挂很多叶子，所以要记得动态修改这个点的度数然后撤销。
3. 根节点往上是没有边的，所以记得答案 $-1$。
## 代码
套了个树剖的板子，可能看起来有点丑。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
int n,rt,q,a[N],b[N];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
namespace tree_decomposition_SGT_Point
{
	struct SGT
	{
		#define ls (p<<1)
		#define rs (p<<1|1)
		#define mid ((l+r)>>1)
		#define pushup(p) (t[p]=t[ls]+t[rs],tt[p]=tt[ls]+tt[rs])
		int L,R;vector<int> t,tt,lz,len;//t for tree and lz for lazy tag
		void init(int l,int r){t=lz=len=tt=vector<int>((r-l+10)<<2);L=l,R=r;}
		void build(int p,int l,int r,int a[],int id[])
		{
			if(p==1) l=L,r=R;len[p]=r-l+1;
			if(l==r) return t[p]=!a[id[l]],tt[p]=a[id[l]],void();
			build(ls,l,mid,a,id),build(rs,mid+1,r,a,id);pushup(p);
		}
		void pushson(int p){lz[p]^=1,swap(t[p],tt[p]);}
		void pushdown(int p){if(lz[p]) pushson(ls),pushson(rs);lz[p]=0;}
		void modify(int p,int l,int r,int s,int e)
		{
			if(p==1) l=L,r=R;if(l>=s&&r<=e) return pushson(p),void();pushdown(p);
			if(mid>=s) modify(ls,l,mid,s,e);
			if(mid<e) modify(rs,mid+1,r,s,e);pushup(p);
		}
		int query(int p,int l,int r,int s,int e)
		{
			if(p==1) l=L,r=R;if(l>=s&&r<=e) return t[p];
			pushdown(p);int res=0;
			if(mid>=s) res=query(ls,l,mid,s,e);
			if(mid<e) res+=query(rs,mid+1,r,s,e);
			return res;
		}
		#undef ls
		#undef rs
		#undef mid
		#undef pushup
	} sgt;
	int cnt;vector<int> e[N];
	int fa[N],son[N],si[N],dep[N];
	int top[N],id[N],dfn[N];
	inline void init(int l,int r,int a[])
	{
		sgt.init(l,r);
		sgt.build(1,0,0,a,id);
	}
	inline void add(int u,int v) { e[u].emplace_back(v),e[v].emplace_back(u); }
	inline void dfs1(int u,int ff)
	{
		fa[u]=ff,si[u]=1,dep[u]=dep[ff]+1;if(e[u].size()==1) a[u]=1;
		for(auto v:e[u])
		{
			if(v==ff) continue;
			dfs1(v,u);si[u]+=si[v];a[u]^=a[v];
			if(si[son[u]]<si[v]) son[u]=v;
		}
	}
	inline void dfs2(int u,int topf)
	{
		top[u]=topf,dfn[u]=++cnt,id[cnt]=u;
		if(son[u]) dfs2(son[u],topf);
		for(auto v:e[u])
		{
			if(v==fa[u]||v==son[u]) continue;
			dfs2(v,v);
		}
	}
	inline void modify(int x)
	{
		while(top[x]!=rt) sgt.modify(1,0,0,dfn[top[x]],dfn[x]),x=fa[top[x]];
		sgt.modify(1,0,0,1,dfn[x]);
	}
}
using namespace tree_decomposition_SGT_Point;
inline void solve()
{
	n=read(),q=read();for(int i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v);
	for(int i=1;i<=n;i++) if(e[i].size()>1){rt=i;break;}
	dfs1(rt,0);dfs2(rt,rt);init(1,n,a);
	for(int i=1,k,f;i<=q;i++)
	{
		k=read();f=a[rt];
		for(int j=1;j<=k;j++) b[j]=read();
		for(int j=1;j<=k;j++){if(e[b[j]].size()>1)  modify(b[j]),f^=1;e[b[j]].emplace_back(INF);}
		print(f?-1:n-2+k+sgt.t[1]);put('\n');
		for(int j=1;j<=k;j++){e[b[j]].pop_back();if(e[b[j]].size()>1) modify(b[j]);}
	}
}
signed main()
{
    int T=1;while(T--) solve();
    genshin:;flush();return 0;
}
```

---

## 作者：JK_LOVER (赞：2)

# 题意
叶子节点两两匹配，要求覆盖所有边，求最小覆盖边长。[$QAQ$](https://www.luogu.com.cn/blog/xzc/solution-p6805)
# 分析
先单独对每个节点考虑。

- 叶子节点。因为自己不能和自己匹配，直接向父亲上传。

- 非叶节点。如果子树中叶子个数为奇数，那么这个可以完美匹配的，剩下一条传给父亲，如果为偶数，就只能找两条都传给父亲，此时向父亲的边就多走了一次。

- 根节点。因为没有父亲，必须总叶子数为偶数才有解。

那么就考虑一个叶子节点的贡献，发现叶子节点只会影响这个节点到根节点的路径上的所有节点。那么总覆盖边长为 $n-2 + \sum[si_i\%2=0]$ 。最后答案只和 $si_i$ 的奇偶有关，直接树链剖分维护时间复杂度为 $O(n\log^2n)$ 。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 4e5+100;
struct Edge{int to,nxt;}e[N<<1];
int top[N],fa[N],si[N],Id,id[N],son[N],head[N],du[N],dep[N];
int t[N][2],tag[N],ecnt = 0,n;
void add(int x,int y){e[++ecnt].to = y;e[ecnt].nxt = head[x];head[x] = ecnt;}
int read() {
	int x = 0,f = 0;char ch = getchar();
	while(!isdigit(ch)) {if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
void dfs1(int x,int f,int Dep){
	dep[x] = Dep;fa[x] = f;si[x] = 1;
	for(int i = head[x];i;i = e[i].nxt){
		int y = e[i].to;
		if(y == f) continue;
		dfs1(y,x,Dep+1);
		si[x] += si[y];
		if(si[y] > si[son[x]]) son[x] = y; 
	} 
}
void dfs2(int x,int f,int Top){
	top[x] = Top;id[x] = ++Id;
	if(son[x]) dfs2(son[x],x,Top);
	for(int i = head[x];i;i = e[i].nxt){
		int y = e[i].to;
		if(y == f || y == son[x])  continue;
		dfs2(y,x,y);
	}
}
void pushdown(int u){
	if(tag[u]){
		swap(t[u<<1][1],t[u<<1][0]);
		swap(t[u<<1|1][1],t[u<<1|1][0]);
		tag[u<<1] ^= tag[u];
		tag[u<<1|1] ^= tag[u];
		tag[u] = 0;
	}
}
void update(int u,int l,int r,int L,int R) {
	if(l > R || r < L) return;
	if(L <= l && r <= R){
		swap(t[u][0],t[u][1]);
		tag[u] ^= 1;return;
	}
	pushdown(u);
	int mid = l + r >> 1;
	update(u<<1,l,mid,L,R);update(u<<1|1,mid+1,r,L,R);
	t[u][1] = t[u<<1][1] + t[u<<1|1][1];
	t[u][0] = t[u<<1][0] + t[u<<1|1][0];
}
int ask(int u,int l,int r,int pos){
	if(l==r) {return t[u][1]?1:0;}
	int mid=l+r>>1;pushdown(u);if(pos <= mid) return ask(u<<1,l,mid,pos);else return ask(u<<1|1,mid+1,r,pos);
}
void update2(int a,int b){
	while(top[a] != top[b]) {
		if(dep[top[a]] < dep[top[b]]) swap(a,b);
		update(1,1,n,id[top[a]],id[a]);
		a = fa[top[a]];
	}
	if(dep[a] > dep[b]) swap(a,b);
	update(1,1,n,id[a],id[b]);
}
void build(int u,int l,int r){
	if(l == r) {t[u][0] = 1;return;}
	int mid = l + r >> 1;
	build(u<<1,l,mid);build(u<<1|1,mid+1,r);
	t[u][0] = t[u<<1][0] + t[u<<1|1][0];
}
vector<int> leaf;
int main()
{
	int rt = 0,vis = 0;
	n = read();int Q = read();
	for(int i = 1;i < n;i++) {
		int a = read(),b = read();
		add(a,b);add(b,a);du[a]++;du[b]++;
	}
	for(int i = 1;i <= n;i++) {if(du[i] > 1) rt = i;}
	dfs1(rt,0,1);dfs2(rt,0,rt);build(1,1,n);
	for(int i = 1;i <= n;i++) {
		if(du[i] == 1) update2(rt,i),vis++;
	}
	while(Q--) {
		int sum = read();
		leaf.clear();
		for(int i = 1;i <= sum;i++) {
			int a = read();
			if(du[a] != 1) update2(a,rt),vis++; 
			du[a]++;leaf.push_back(a);
		}
		(vis&1)?printf("-1\n"):printf("%d\n",n+sum-2+t[1][0]);
		for(int i = 0;i < leaf.size();i++) {
			int a = leaf[i];
			du[a]--;
			if(du[a] != 1) update2(a,rt),vis--;
		}
	}
} 
```


---

## 作者：Seauy (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P6805)

## 题目大意

- $n$ 个结点的树，要求所有叶子两两匹配，叶子间的路径覆盖了树上所有边。

- 每次独立添加 $D$ 个叶子，求路径长度和的最小值，并判断无解。

- $n,q,\sum D\leq 10^5$。

# Solution

首先奇数个叶子显然无解，然后发现偶数个叶子必有解，比如随便找个非叶结点当根（$n \geq 3$），让所有路径都经过根即可。

先考虑静态问题，尝试用 dp 解决。设 $f_i$ 以 $i$ 为根的子树内的答案，$g_i$ 为有多少叶子的路径经过 $i$ 但并为匹配。那么对于一个 $i$，他肯定要让所有儿子 $x$ 的 $g$ 一部分匹配，一部分向上继承。为了让代价最小且能够覆盖所有边，$g_i$ 不能为 $0$ 且要最小化，而一次匹配只能取出两个未匹配的叶子，所以 $g_i$ 的奇偶性得跟 $\sum_{x} g_x$ 保持一直，最后的取值就只能有 $\{1,2\}$，具体来说：

设 $S=\sum_{x} g_x$，则

$$ f_i=S+\sum_{x} f_x $$

$$ g_i=2- (S\bmod 2) $$

当 $S$ 为偶时 $g_i=2$，当 $S$ 为奇时，$g_i=1$。对于叶子，$f_i=0,g_i=1$。

这样对于每个询问，我们就可以使用动态 dp 了。再此之前我们思考一下这个转移怎么矩阵递推。

我们先去掉重儿子的贡献，就变成一个链上的问题。假如我们把状态矩阵设为

$$ \begin{bmatrix} f_i & g_i  \end{bmatrix} $$

转移时增加重儿子的贡献，发现转移矩阵的左上角必为 $1$，因为 $f_i$ 需要保留再与 $f_x,g_x$ 相加，但是发现 $g_i$ 的位置就非常尴尬，因为式子里并没有 $g_i$ 跟某个变量的乘积项，所以状态向量长度肯定大于 $2$。

那干脆把 $g_i$ 拆掉，当 $g_i=1$ 时

$$ \begin{bmatrix} f_i & 1 & 0  \end{bmatrix} $$

当 $g_i=2$ 时

$$ \begin{bmatrix} f_i & 0 & 1  \end{bmatrix} $$

这样转移矩阵找起来就舒服多了，当 $g_x=1$ 时

$$ \begin{bmatrix} 1 & 0 & 0 \\ f_i+1 & 0 & 1 \\  f_i+2 & 1 &0 \end{bmatrix} $$

当 $g_x=2$ 时

$$ \begin{bmatrix} 1 & 0 & 0 \\ f_i+1 & 1 & 0 \\  f_i+2 & 0 & 1 \end{bmatrix} $$

然后想一下初始状态长啥样，他乘以链低的叶子就要完全获取她的信息，$f_i$ 的来源有 $f_i+1$ 或 $f_i+2$，如果是 $f_i+1$，初始向量为

$$ \begin{bmatrix} -1 & 1 & 0 \end{bmatrix} $$

但是这样 $g_i$ 的状态就反了（一开始以为这样是对的所以查错了很久qwq），所以正确的初始向量为

$$ \begin{bmatrix} -2 & 0 & 1 \end{bmatrix} $$

查询时一个结点下挂了许多叶子，$f_{a_i}$ 对应增加 $g_{a_i}$ 对应翻转即可，注意由于叶子 $g$ 本来就是 $1$，修改她时要多翻转一次。

最后套路地用各种数据结构维护即可，300ms 卡得有点紧，推荐使用[全局平衡二叉树](https://blog.csdn.net/ez_lcw/article/details/123574885)。

时间：$O(27(n+\sum D)\log n)$；空间：$O(9n)$。

~~好差劲啊~~

# Code

代码非常长！

```cpp
#include<bits/stdc++.h>
#define Lson(x) node[x].Son[0]
#define Rson(x) node[x].Son[1]
#define fa(x) node[x].father
using namespace std;

typedef long long ll;
typedef pair<int,int> pr;

const int MAXN=1e5;

struct Matrix
{
	int data[3][3];
	inline void Clean() {memset(data,0,sizeof data);}
	inline void operator = (const Matrix &a)
	{
		for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
				data[i][j]=a.data[i][j];
	}
	inline Matrix operator * (const Matrix &a)
	{
		Matrix res;
		for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
			{
				res.data[i][j]=0;
				for(int k=0;k<3;k++) res.data[i][j]+=data[i][k]*a.data[k][j]; 
			}
		return res;
	}
	inline int Fval() {return data[2][0]-2;}
	inline int Gval() {return data[2][1]==1 ? 1 : 2;}
	inline void rev()
	{
		data[1][1]^=1,data[1][2]^=1;
		data[2][1]^=1,data[2][2]^=1;
	}
	inline void Print()
	{
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++) printf("%d ",data[i][j]);
			printf("\n");
		}
	}
};

struct OVBST
{
	int Son[2],father;
	Matrix dp,T;
}node[MAXN+5];

int n,q,root;
vector<int> nxt[MAXN+5];
int Mson[MAXN+5],Size[MAXN+5],f[MAXN+5],ovroot;
int F[MAXN+5],G[MAXN+5],A[MAXN+5];

inline void Link(int a,int b)
{
	if(!b) return;
	F[a]+=F[b]+G[b];
	if(G[b]==1) G[a]=3-G[a];
}

inline void Cut(int a,int b)
{
	if(!b) return;
	F[a]-=F[b]+G[b];
	if(G[b]==1) G[a]=3-G[a];
}

void CalMsg(int now)
{	
	int S=0;
	Size[now]=1;
	for(int i=0,rear;i<nxt[now].size();i++)
	{
		rear=nxt[now][i];
		if(rear==f[now]) continue;
		f[rear]=now;
		CalMsg(rear);
		Size[now]+=Size[rear];
		if(Size[rear]>Size[Mson[now]]) Mson[now]=rear;
	
		S+=G[rear];
		F[now]+=F[rear];
	}
	if(nxt[now].size()==1) F[now]=0,G[now]=1;
	else
	{
		F[now]+=S;
		if(S&1) G[now]=1;
		else G[now]=2;
	}
	
	Cut(now,Mson[now]);
	node[now].T.data[0][0]=1;
	node[now].T.data[1][0]=F[now]+1;
	node[now].T.data[2][0]=F[now]+2;
	if(G[now]==1) node[now].T.data[2][1]=node[now].T.data[1][2]=1;
	else node[now].T.data[1][1]=node[now].T.data[2][2]=1;
	Link(now,Mson[now]);
}

inline void PushUp(int x)
{
	node[x].dp=node[x].T;
	if(Lson(x)) node[x].dp=node[x].dp*node[Lson(x)].dp;
	if(Rson(x)) node[x].dp=node[Rson(x)].dp*node[x].dp;
}
inline bool isRoot(int x) {return Lson(fa(x))!=x && Rson(fa(x))!=x;}

int Build(int L,int R)
{
	if(L==R) {PushUp(L);return L;}
	ll sum=0;int now;
	for(int i=L;1;i=Mson[i]) {sum+=Size[i]-Size[Mson[i]];if(i==R) break;}
	sum>>=1;
	for(int i=L;1;i=Mson[i]) {sum-=Size[i]-Size[Mson[i]];if(sum<=0) {now=i;break;}}
	if(L!=now) Lson(now)=Build(L,f[now]),fa(Lson(now))=now;
	if(R!=now) Rson(now)=Build(Mson[now],R),fa(Rson(now))=now;
	PushUp(now);
	return now;
}

void TCP(int now,int Top)
{
	if(Mson[now]) TCP(Mson[now],Top);
	for(int i=0,rear;i<nxt[now].size();i++)
	{
		rear=nxt[now][i];
		if(rear==f[now] || rear==Mson[now]) continue;
		TCP(rear,rear);
	}
	if(now==Top)
	{
		int R=now;while(Mson[R]) R=Mson[R];
		fa(Build(now,R))=f[now];
	}
}

inline void Modify(int x,int v,bool c)
{
	node[x].T.data[1][0]+=v;
	node[x].T.data[2][0]+=v;
	if(c) node[x].T.rev();
	
	for(;x!=ovroot;x=fa(x))
	{
		if(isRoot(x))
		{
			int delta=node[x].dp.Fval()+node[x].dp.Gval();
			node[fa(x)].T.data[1][0]-=delta;
			node[fa(x)].T.data[2][0]-=delta;
			if(node[x].dp.Gval()==1) node[fa(x)].T.rev();
		}
		PushUp(x);
		if(isRoot(x))
		{
			int delta=node[x].dp.Fval()+node[x].dp.Gval();
			node[fa(x)].T.data[1][0]+=delta;
			node[fa(x)].T.data[2][0]+=delta;
			if(node[x].dp.Gval()==1) node[fa(x)].T.rev();
		}
	}
	PushUp(ovroot);
}

int main()
{
	scanf("%d %d",&n,&q);
	for(int i=1,a,b;i<n;i++)
	{
		scanf("%d %d",&a,&b);
		nxt[a].push_back(b);
		nxt[b].push_back(a);
	}
	for(int i=1;i<=n;i++)
		if(nxt[i].size()>1) {root=i;break;}
	CalMsg(root),TCP(root,root);
	for(int i=1;i<=n;i++) if(!fa(i)) {ovroot=i;break;}
	for(int d;q--;)
	{
		scanf("%d",&d);
		for(int i=1;i<=d;i++) scanf("%d",&A[i]);
		sort(A+1,A+d+1),A[d+1]=0;
		for(int i=1,cnt=0;i<=d;i++)
		{
			++cnt;
			if(A[i]!=A[i+1])
			{
				if(nxt[A[i]].size()>1) Modify(A[i],cnt,cnt&1);
				else Modify(A[i],cnt,(cnt^1)&1);
				cnt=0;
			}
		}
		
		if(node[ovroot].dp.Gval()==1) printf("-1\n");
		else printf("%d\n",node[ovroot].dp.Fval());
		
		for(int i=1,cnt=0;i<=d;i++)
		{
			++cnt;
			if(A[i]!=A[i+1])
			{
				if(nxt[A[i]].size()>1) Modify(A[i],-cnt,cnt&1);
				else Modify(A[i],-cnt,(cnt^1)&1);
				cnt=0;
			}
		}
	}
	return 0;
}
```


---

## 作者：Genius_Star (赞：0)

#### 思路：

[或许更好的阅读体验。](https://www.cnblogs.com/rgw2010/p/18362340)

首先随意钦定一个不是叶子节点的节点为根节点。

然后考虑对于一个不是根节点的点 $u$，肯定需要至少一个叶子去与 $u$ 子树之外的叶子节点配对。

考虑 $u$ 到 $fa_u$ 的这条边，首先至少有一个叶子节点穿过，然后设 $p_u$ 表示 $u$ 中的叶子节点个数：

- 若 $p_u$ 为偶，在一个叶子节点往外传后还剩奇数个，两两配对后还剩一个叶子节点，也需要往外传经过 $u \to fa_u$ 的这条边。

- 否则 $p_u$ 为奇时，在一个叶子节点往外传后还剩偶数个，可以完美两两配对。

那么对于 $u \to fa_u$ 的这条边，经过这条边的叶子节点个数为 $1 + [p_u \bmod 2=0]$。

则总答案为：

$$\sum_{u \ne rt} 1 + [p_u \bmod 2 = 0] = (n-1) + \sum_{u \ne rt} [p_u \bmod 2 = 0]$$

考虑将 $u \ne rt$ 给去掉，可以方便一些计算。

因为若 $p_{rt}$ 不为偶数，就无法使得所有叶子节点配对，即无解，所以在有解的情况下 $[p_{rt} \bmod 2 = 0] = 1$，则需要将前面 $-1$。

则原式化为：

$$n -2 + \Big(\sum_u[p_u \bmod 2 = 0]\Big)$$

则每次在 $u$ 处添加一个叶子节点，就相当于将 $u$ 到根节点的 $p_u \bmod 2$ 的值取反。

那么直接树剖维护即可，时间复杂度为 $O(\Big(\sum D_i\Big) \log^2 n)$。

**要注意一下细节：在叶子节点下添加新节点，是没有贡献的（即不需要翻转），于是我们可以动态维护每个点的度数。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=1e5+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,s,q,x,h,rt;
ll du[N];
bool f[N];
vector<ll> E[N];
stack<ll> T;
void add(ll u,ll v){
    E[u].push_back(v);
    E[v].push_back(u);
    du[u]++,du[v]++;
}
namespace Seg{
    struct Node{
        ll len;
        ll l,r;
        ll data;
        bool tag;
    }X[N<<2];
    void pushup(ll k){
        X[k].data=X[k<<1].data+X[k<<1|1].data;
    }
    void rev(ll k){
        X[k].data=X[k].len-X[k].data;
        X[k].tag^=1ll;
    }
    void push_down(ll k){
        if(X[k].tag){
            rev(k<<1);
            rev(k<<1|1);
            X[k].tag=0;
        }
    }
    void build(ll k,ll l,ll r){
        X[k].len=r-l+1;
        X[k].l=l,X[k].r=r;
        if(l==r)
          return ;
        ll mid=(l+r)>>1;
        build(k<<1,l,mid);
        build(k<<1|1,mid+1,r);
    }
    void update(ll k,ll i){
        if(X[k].l==i&&i==X[k].r){
            X[k].data=1;
            return ;
        }
        push_down(k);
        ll mid=(X[k].l+X[k].r)>>1;
        if(i<=mid)
          update(k<<1,i);
        else
          update(k<<1|1,i);
        pushup(k);
    }
    void rev(ll k,ll l,ll r){
        if(X[k].l==l&&r==X[k].r){
            rev(k);
            return ;
        }
        push_down(k);
        ll mid=(X[k].l+X[k].r)>>1;
        if(r<=mid)
          rev(k<<1,l,r);
        else if(l>mid)
          rev(k<<1|1,l,r);
        else{
            rev(k<<1,l,mid);
            rev(k<<1|1,mid+1,r);
        }
        pushup(k);
    }
    ll sum(){
        return X[1].data;
    }
};
namespace Tree{
    ll cnt=0;
    ll siz[N],w[N],z[N],fa[N],d[N],t[N],dfn[N];
    void dfs1(ll u,ll f){
        siz[u]=1;
        for(auto v:E[u]){
            if(v==f)
              continue;
            fa[v]=u;
            d[v]=d[u]+1;
            dfs1(v,u);
            siz[u]+=siz[v];
            if(siz[v]>siz[z[u]])
              z[u]=v;
        }
    }
    void dfs2(ll u,ll k){
        t[u]=k;
        dfn[u]=++cnt;
        if(!z[u])
          return ;
        dfs2(z[u],k);
        for(auto v:E[u]){
            if(v==fa[u]||v==z[u])
              continue;
            dfs2(v,v);
        }
    }
    void dfs3(ll u){
        if(du[u]==1){
            s++;
            w[u]=1;
            return ;
        }
        for(auto v:E[u]){
            if(v==fa[u])
              continue;
            dfs3(v);
            w[u]+=w[v];
        }
    }
    void init(){
        Seg::build(1,1,n);
        dfs1(rt,rt);
        dfs2(rt,rt);
        dfs3(rt);
        For(i,1,n)
          if((w[i]&1ll)^1ll)
            Seg::update(1,dfn[i]);
    }
    void rev(ll u,ll v){
        while(t[u]!=t[v]){
            if(d[t[u]]<d[t[v]])
              swap(u,v);
            Seg::rev(1,dfn[t[u]],dfn[u]);
            u=fa[t[u]];
        }
        if(d[u]>d[v])
          swap(u,v);
        Seg::rev(1,dfn[u],dfn[v]);
    }
};
bool End;
int main(){
    n=read(),q=read();
    for(int u,v,i=1;i<n;i++){
        u=read(),v=read();
        add(u,v);
    }
    For(i,1,n){
        if(du[i]!=1){
            rt=i;
            break;
        }
    }
    Tree::init();
    while(q--){
        h=0;
        m=read();
        For(i,1,m){
            x=read();
            if(du[x]==1)
              s--;
            else{
                Tree::rev(x,rt);
                f[x]^=1ll;
            }
            s++;
            du[x]++;
            T.push(x);
        }
        if(s&1ll)
          puts("-1");
        else{
            write(h+n+m-2+Seg::sum());
            putchar('\n');
        }
        while(!T.empty()){
            x=T.top();
            s--;
            du[x]--;
            if(du[x]==1)
              s++;
            if(f[x]){
                Tree::rev(rt,x);
                f[x]=0;
            }
            T.pop();
        }
    }
	//cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：0)

## 题目大意

定义一颗有 $2m$ 颗叶子的树的权值如下：

- 叶子间两两匹配，匹配叶子之间的路径需覆盖所有边，匹配叶子之间距离和的最小值。

现在给你一棵初始的树。有若干次独立的询问，每次给出几个新点，与原树上的点连边，并询问新树的权值，如果叶子数不是偶数，输出 $-1$。

## 题目分析

以下都把树当成有根树。

首先考虑如果快速求一棵树的权值，这里可以将路径长度之和做一个简单的转换：

- 初始时每个叶子上都有个标记，你可以花费 $1$ 的代价使一个标记跳到父亲上，或者不花费代价使得两个标记在对应叶子的 $lca$ 处销毁，要求每条边都被跳过，且所有标记都被销毁，最终花费的代价。

然后，我们从简单的情况入手：对于儿子节点都是叶子的非根节点 $x$，如何决策？首先那些标记肯定得先跳到 $x$。

1. 如果只有 $1$ 个儿子，则肯定需要跳一步。

2. 如果有 $2$ 个儿子，由于 $x$ 连向父亲的边需要被跳，所以它们的标记不能在 $x$ 处销毁，之后准备跳到父亲上和其它子树的标记一起销毁。

3. 如果有 $3$ 个以上的儿子，我们可以尽量在 $x$ 处多销毁标记，但暂时还不知道如果保留标记过少会不会影响之后的决策，只知道如果保留 $1/2$ 个标记一定是局部最优的。

然后这时候会发现，对于一般的非根节点，它的儿子上保留的标记是能控制在 $1/2$ 个的，这时候就很容易得出一个结论：剔除需要留着跳父亲的 $1/2$ 个节点后，剩下的每个儿子上保留的标记数量不超过总数的一半，这使得它们之间可以两两匹配，且这样做是局部最优的。对根节点进行简单的讨论后发现最终所有的标记都会在根节点处完全销毁。然后就可以归纳证明，这样做是全局最优的。

这时候代价就很好计算，考虑每个点上会有多少标记会跳父亲，这只和子树内的叶子数的奇偶性有关，询问相当于给一些点接了叶子，使得到根的路径上的点子树内叶子数的奇偶性翻转，直接树剖线段树维护即可，复杂度 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define OK Ll<=l&&r<=Rr
#define Root 1,1,n
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=1e5+5;
const ll llf=1e18;
int n,m,deg[N],ct,a[N],pct,h[N],nxt[N<<1],to[N<<1],cnt;
inline void add_(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt,deg[a]++;
}
int siz[N],son[N],f[N],top[N],sz[N];
inline void dfs(int x,int fa){
	f[x]=fa,siz[x]=1,sz[x]=deg[x]==1;
	e(x)if(y^fa)dfs(y,x),siz[x]+=siz[y],sz[x]+=sz[y],son[x]=siz[y]>siz[son[x]]?y:son[x];
}
int dfn[N],Time,Id[N];
bool v[N];
inline void Dfs(int x,int low){
	top[x]=low,dfn[x]=++Time,Id[Time]=x;
	if(son[x])Dfs(son[x],low);
	e(x)if(y^f[x]&&y^son[x])Dfs(y,y);
}
struct seg{
	int c1,c2;
	bool laz;
}xd[N<<2];
inline void getup(int x){
	xd[x]={xd[L].c1+xd[R].c1,xd[L].c2+xd[R].c2,xd[x].laz};
}
inline void rev(int x){
	swap(xd[x].c1,xd[x].c2),xd[x].laz^=1;
}
inline void pushdown(int x){
	if(xd[x].laz)rev(L),rev(R),xd[x].laz=0;
}
inline void build(int x,int l,int r){
	if(l==r){
		if(l^1)sz[Id[l]]%2==1?xd[x].c1=1:xd[x].c2=1;
		return;
	}
	build(lc),build(rc),getup(x);
}
inline void modify(int x,int l,int r,int Ll,int Rr){
	if(OK)return rev(x),void();
	pushdown(x);
	if(Ll<=mid)modify(lc,Ll,Rr);
	if(Rr>mid)modify(rc,Ll,Rr);
	getup(x);
}
inline void solve(int x){
	while(x)modify(Root,dfn[top[x]],dfn[x]),x=f[top[x]];
}
inline void Main(){
	n=read(),m=read();
	rep(i,2,n){
		int x=read(),y=read();
		add_(x,y),add_(y,x);
	}
	repn(i)ct+=deg[i]==1;
	dfs(1,0),Dfs(1,1),build(Root);
	pct=ct;
	while(m--){
		int d=read();
		rep(i,1,d){
			a[i]=read(),ct++;
			if(deg[a[i]]==1)ct--;
			v[i]=deg[a[i]]==1;
			deg[a[i]]++;
			if(!v[i])solve(a[i]);
		}
		if(ct&1)puts("-1");
		else cout <<xd[1].c1+xd[1].c2*2+d<<'\n';
		rep(i,1,d){
			deg[a[i]]--;
			if(!v[i])solve(a[i]);
		}
		ct=pct;
	}
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}	


```

---


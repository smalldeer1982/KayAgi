# [RC-03] 记忆

## 题目背景

小 W 想写一个关于记忆的题目背景，但是他忘记了。

## 题目描述

有一个括号串 $S$，一开始 $S$ 中只包含一对括号（即初始的 $S$ 为 `()`），接下来有 $n$ 个操作，操作分为三种：

1. 在当前 $S$ 的末尾加一对括号（即 $S$ 变为 `S()`）；

2. 在当前 $S$ 的最外面加一对括号（即 $S$ 变为 `(S)`）；

3. 取消第 $x$ 个操作，即去除第 $x$ 个操作造成过的**一切影响**（例如，如果第 $x$ 个操作也是取消操作，且取消了第 $y$ 个操作，那么当前操作的实质就是恢复了第 $y$ 个操作的作用效果）。

每次操作后，你需要输出 $S$ 的能够括号匹配的非空子串（子串要求连续）个数。

一个括号串能够括号匹配，当且仅当其左右括号数量相等，且任意一个前缀中左括号数量不少于右括号数量。

## 说明/提示

【样例 $1$ 解释】

用 $S[i,j]$ 表示从 $S_i$ 到 $S_j$ 的子串（下标从 $1$ 开始）。

一开始 $S$ 为 `()`，每次操作后：

第 $1$ 次操作后：$S$ 为 `()()`，匹配的子串有 $S[1,2]$，$S[1,4]$ 和 $S[3,4]$，共 $3$ 个。

第 $2$ 次操作后：$S$ 为 `(()())`，匹配的子串有 $S[1,6]$，$S[2,3]$，$S[2,5]$ 和 $S[4,5]$，共 $4$ 个。

第 $3$ 次操作后：$S$ 为 `(())`，匹配的子串有 $S[1,4]$ 和 $S[2,3]$，共 $2$ 个。

第 $4$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。

第 $5$ 次操作后：$S$ 为 `(()())()`，匹配的子串有 $S[1,6]$，$S[1,8]$，$S[2,3]$，$S[2,5]$，$S[4,5]$ 和 $S[7,8]$，共 $6$ 个。

第 $6$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。

---

【数据范围】

**本题采用捆绑测试。**

对于全部数据：$1\leq n\leq 2\times 10^5$，$op\in \{1,2,3\}$，$1\leq x\leq n$，一个操作在形式上最多只会被取消一次（即所有 $x$ 互不相同）。

| 子任务编号 |    $n\leq$     |   $op\in$   | 分值 |
| :--------: | :------------: | :---------: | :--: |
| Subtask 1  |     $100$      | $\{1,2,3\}$ | $10$ |
| Subtask 2  |     $10^3$     | $\{1,2,3\}$ | $10$ |
| Subtask 3  |     $10^5$     | $\{1,2,3\}$ | $30$ |
| Subtask 4  | $2\times 10^5$ |  $\{1,2\}$  | $20$ |
| Subtask 5  | $2\times 10^5$ | $\{1,2,3\}$ | $30$ |



## 样例 #1

### 输入

```
6
1
2
3 1
1
3 3
3 5
```

### 输出

```
3
4
2
4
6
4
```

## 样例 #2

### 输入

```
10
1
2
2
3 2
1
3 3
3 6
1
2
1
```

### 输出

```
3
4
5
4
6
6
6
9
10
12
```

# 题解

## 作者：oyoham (赞：20)

### Problem
[P6864](https://www.luogu.com.cn/problem/P6864)  
维护一个字符串 `S`，支持变成 `(S)`、变成 `S()` 以及撤销一次操作（保证该操作在被撤销前生效，可撤销**撤销操作**），求每次操作后的合法括号字串数量。
### Solution
题解中大部分讲的都是矩阵 $\Theta(n\log n)$ 的做法。但是我在模拟赛中乱搞得到一种更快的做法。  
我们考虑将原字串每一对括号视为一个节点，每个节点的父亲是在原串上最小的**能够包含节点代表的括号**的括号对应的节点（即 $u$ 是 $v$ 的父亲节点，当前仅当 $u$ 对应的括号包含 $v$ 对应的括号，且不存在任何括号被 $u$ 包含且包含 $v$），形成一棵树。  
这样，我们可以考虑树上 dp，我们记 $f_u$ 为以 $u$ 为根的树的答案，$son_u$ 代表 $u$ 的儿子的集合，则有：
$$
f_u=\left(\sum_{v\in son_u}f_v\right)+\frac{\lvert son_u\rvert\cdot\left(\lvert son_u\rvert+1\right)}{2}
$$
其中前面的求和是子树内答案，后面的统计在这个括号内一层的括号的答案。
可以建一个虚拟根节点方便统计答案。  
考虑操作 `S()`，相当于自己建一个新的节点，向虚拟根节点连边。  
考虑操作 `(S)`，可以将虚拟根节点当作这个节点，并新建一个新的虚拟根节点由该点连边。  
考虑撤销操作，若该撤销使字符串少一对括号，相当于删除对应节点并将该节点所有子节点连到被删除节点处。若该撤销使字符串多一对括号（或者说恢复操作），相当于将从该店连到其父亲的子节点从其父亲中删去并连到该点上，再有该店连向其父亲。  
为处理撤销操作，我们定义 $g_i$ 代表该节点为他父节点贡献的子节点个数，则当该节点未删去时，有：
$$
f_u=\left(\sum_{v\in son_u}f_v\right)+\frac{\sum_{v\in son_u}g_v\cdot\left(\left(\sum_{v\in son_u}g_v+1\right)\right)}{2}\\
g_u=1
$$
当该节点删去时，有：
$$
f_u=\sum_{v\in son_u}f_v\\
g_u=\sum_{v\in son_u}g_v
$$
我们可以在每次修改后进行整条到根节点路径的更新。时间平均复杂度 $\Theta(n\log^2n)$。
### Optimization
首先，所有节点可以先将 $s_u=\sum_{v\in son_u}g_v$ 给维护起来，这样就可以方便的删除一个节点。  
其次，对于一次删除或恢复，可以先用栈维护该节点到根节点的路径，取消该路径上的贡献，更改后在恢复贡献，这样这个算法的时间平均复杂度就降到 $\Theta(n\log n)$ 了。  
此外，我们发现，没有必要对每个节点维护 $f$，可以发现答案等于 $\sum_{u\in T}\frac{s_u\cdot(s_u+1)}{2}$，我们可以单独维护一个答案变量。  
有了上面的优化后，转移就只有
$$
s_u=\sum_{v\in son_u}g_v\\
g_u=\begin{cases}1&\text{u isn't deleted}\\s_u&\text{u is deleted}\end{cases}
$$
这时我们发现，当一个节点未被删除时，它子树内的删数并不会影响到这个结点的祖先（因为这个的 $g$ 值始终为 $1$）这时，我们可以将之前维护的到根节点的链改为到最近的未被删除的点即可，可以发现，这条链的期望值不会很大（大概只有 $3$ 左右），所以在随机数据下这个做法是 $\Theta(n)$ 的。
### Code
贴上我丑陋的代码（勿喷 qwq
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read(){
	ll x=0;
	short f=1;
	char c=getchar();
	while(c>57||c<48){
		if(c==45) f=-1;
		else f=1;
		c=getchar();
	}
	while(c<58&&c>47){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void write(ll x){
	if(x<0ll) putchar(45),x=~x+1;
	if(x>9ll) write(x/10);
	putchar(x%10|48);
}
int Node[200005],Id=2;
int RT=1;
int alive[200005],g[200005],sg[200005],fa[200005];
ll ans=0;
int st[200005],tp;
signed main(){
	alive[1]=alive[2]=ans=g[1]=sg[1]=fa[2]=g[2]=1;
	int n=read();
	for(int i=1;i<=n;i++){
		int op=read();
		if(op==1){
			Node[i]=++Id;
			fa[Id]=RT;
			alive[Id]=1;
			g[Id]=1;
			sg[RT]++;
			ans+=sg[RT];
		}
		if(op==2){
			Node[i]=RT;
			RT=++Id;
			alive[RT]=1;
			sg[RT]=1;
			g[RT]=1;
			ans++;
			fa[Node[i]]=RT;
		}
		if(op==3){
			int x=Node[i]=-Node[read()];
			if(x<0){
				x=-x;
				//delete node x away
				st[++tp]=x;
				while(!alive[x=fa[x]])st[++tp]=x;
				for(int i=tp;i;i--){
					int o=st[i];
					sg[fa[o]]-=g[o];
					if(alive[fa[o]]){
						ans-=1ll*sg[fa[o]]*g[o]+(1ll*g[o]*(g[o]+1)>>1);
					}
					else{
						g[fa[o]]-=g[o];
					}
				}
				x=-Node[i];
				g[x]=sg[x];
				ans-=sg[x]*(sg[x]+1)>>1;
				alive[x]=0;
				for(int i=1;i<=tp;i++){
					int o=st[i];
					if(alive[fa[o]]){
						ans+=1ll*sg[fa[o]]*g[o]+(1ll*g[o]*(g[o]+1)>>1);
					}
					else{
						g[fa[o]]+=g[o];
					}
					sg[fa[o]]+=g[o];
				}
				tp=0;
			}
			else{
				//insert node x back
				st[++tp]=x;
				while(!alive[x=fa[x]])st[++tp]=x;
				for(int i=tp;i;i--){
					int o=st[i];
					sg[fa[o]]-=g[o];
					if(alive[fa[o]]){
						ans-=1ll*sg[fa[o]]*g[o]+(1ll*g[o]*(g[o]+1)>>1);
					}
					else{
						g[fa[o]]-=g[o];
					}
				}
				x=Node[i];
				alive[x]=1;
				g[x]=1;
				ans+=1ll*sg[x]*(sg[x]+1)>>1;
				for(int i=1;i<=tp;i++){
					int o=st[i];
					if(alive[fa[o]]){
						ans+=1ll*sg[fa[o]]*g[o]+(1ll*g[o]*(g[o]+1)>>1);
					}
					else{
						g[fa[o]]+=g[o];
					}
					sg[fa[o]]+=g[o];
				}
				tp=0;
			}
		}
		write(ans);putchar(10);
	}
}
```
### Extra
我在模拟赛赛时打完了如上优化，但还是能找到 Hack 数据，可按如下方法构造：
```
	cout<<"200000\n";
	for(int i=1;i<=66667;i++)cout<<"2\n";
	for(int i=1;i<=66667;i++)cout<<"3 "<<66668-i<<"\n";
	for(int i=133335;i<=200000;i++)cout<<"3 "<<i-1<<"\n";
```
但是，这个算法在随机情况下是 $\Theta(n)$ 的，足以高速的通过此题。

---

## 作者：irris (赞：10)

## Solution

撤销操作乍一看比较难以处理。考虑没有撤销操作的情形。

> + Hint $1$：任意时刻该括号串是匹配的。

证明：操作一和操作二是显然的。对操作三，可以看做时间倒流到之前某个匹配的状态，跳过一次操作，接着完成剩下的操作，所以也是匹配的。

---

假设当前括号串最多可以分割为 $cnt$ 个匹配的括号串（把 `(` 看成 $1$，`)` 看成 $-1$，这可以看做共有 $cnt$ 个前缀和 $=0$）。例如，对于括号串 $\texttt{\color{red}(())\color{green}()\color{blue}(()())}$，$cnt = 3$，我用不同颜色标注了这 $3$ 个不同的匹配的括号串。

我们考虑操作一：括号串变成 $\texttt{\color{red}(())\color{green}()\color{blue}(()())\color{orange}()}$，这里匹配的括号串增加了：

+ $\texttt{\color{orange}()}$
+ $\texttt{\color{blue}(()())\color{orange}()}$
+ $\texttt{\color{green}()\color{blue}(()())\color{orange}()}$
+ $\texttt{\color{red}(())\color{green}()\color{blue}(()())\color{orange}()}$

共 $cnt + 1 = 3 + 1 = 4$ 个匹配的括号串，同时 $cnt$ 也增加了 $1$。

形式化的，这带来的影响是：$ans \leftarrow ans + cnt + 1, cnt \leftarrow cnt + 1$，我们可以用对 $[ans, cnt, 1]$ 乘下列矩阵来描述这个变化：

$$ \begin{bmatrix}
 1 & 0 & 0 \\
 1 & 1 & 0 \\
 1 & 1 & 1 \\
\end{bmatrix} $$

同理，操作二带来的矩阵是：

$$ \begin{bmatrix}
 1 & 0 & 0 \\
 0 & 0 & 0 \\
 1 & 1 & 1 \\
\end{bmatrix} $$

那么操作三也就简单了，只需要找到究竟撤销了什么操作，然后把它翻转成正常的矩阵或者单位矩阵即可。

每次修改可以用线段树维护，时间复杂度 $\mathcal O(M^3n \log n)$，其中 $M = 3$。

### Code

```cpp
#include <bits/stdc++.h>

struct Matrix {
#define MAXM 4
	long long a[MAXM][MAXM]; int n, m;
	Matrix () { memset(a, 0, sizeof(a)); }
	Matrix (int N, int M) : n(N), m(M) { 
		memset(a, 0, sizeof(a));
	}
	inline void printMat() {
		for (int i = 1; i <= n; ++i) 
			for (int j = 1; j <= m; ++j) 
				std::cout << a[i][j] << " \n"[j == m];
	}
};
const Matrix unit(int N) {
	Matrix ans = Matrix(N, N);
	for (int i = 1; i <= N; ++i) ans.a[i][i] = 1;
	return ans;
}
Matrix operator * (const Matrix& a, const Matrix& b) {
	assert(a.m == b.n);
	Matrix c(a.n, b.m);
	for (int k = 1; k <= a.m; ++k) 
		for (int i = 1; i <= a.n; ++i) 
			for (int j = 1; j <= b.m; ++j) 
				c.a[i][j] += a.a[i][k] * b.a[k][j];
	return c;
}

Matrix IN(1, 3), AD(3, 3), CU(3, 3), UN = unit(3);
inline void inisM() {
	IN.a[1][1] = IN.a[1][2] = IN.a[1][3] = AD.a[1][1] = AD.a[2][1] = AD.a[2][2] = AD.a[3][1] = AD.a[3][2] = AD.a[3][3] = CU.a[1][1] = CU.a[3][1] = CU.a[3][2] = CU.a[3][3] = 1;
}

#define MAXN 200001
int tp[MAXN], don[MAXN];
Matrix a[MAXN << 2];
void build(int l, int r, int pos = 1) {
	if (l == r) return (void)(a[pos] = UN);
	int mid = l + r >> 1, lc = pos << 1, rc = pos << 1 | 1;
	build(l, mid, lc), build(mid + 1, r, rc);
	a[pos] = a[lc] * a[rc];
}
void upd(int l, int r, int x, int pos = 1) {
	if (r < x || x < l) return;
	if (l == r) {
		if (tp[x] > 0) a[pos] = UN;
		else a[pos] = (tp[x] == -1 ? AD : CU);
		tp[x] *= -1;
		return;
	}
	int mid = l + r >> 1, lc = pos << 1, rc = pos << 1 | 1;
	upd(l, mid, x, lc), upd(mid + 1, r, x, rc);
	a[pos] = a[lc] * a[rc];
}
int main() {
	inisM();
//	IN.printMat(), AD.printMat(), CU.printMat();
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	int M; std::cin >> M; build(1, M);
	for (int i = 1, op; i <= M; ++i) {
		std::cin >> op;
		if (op == 3) 
			std::cin >> op, upd(1, M, don[i] = don[op]);
		else tp[i] = -op, upd(1, M, don[i] = i);
		std::cout << (IN * a[1]).a[1][1] << '\n';
	}
	return 0;
}
```

---

## 作者：TruchyR (赞：8)

### 更新
修掉了某个 hack，挂掉的原因是层数可以到 $n+1$。

## Part 1 思路
观前提醒：本片题解是神秘树状数组+二分做法！  
这道题配得上紫。  
### Subtask 4
先考虑 $op\in\{1,2\}$ 的 Subtask 4：  
- 容易发现 $op=2$ 时对答案的贡献有且只有 $1$（全选的方案）。  
- $op=1$ 时，对答案的贡献是在上一个 $op=2$ **及以后**的操作数和。  

这部分有些题解讲的很清楚，可以去参考一下。  
### Subtask 4 更改
加入 $op=3$ 的操作后，我么需要先修改一下之前的方案：  
对于 $op=2$ 的操作，一定会有一层括号将之前的括号全部括住！  
将操作作为节点及编号，连接成树后会发现：  
- **一个节点的儿子中，只有编号最小的儿子可能不是叶子结点**。  
**且，编号最小的儿子是** $op=2$ **的操作，其余的为** $op=1$ **的操作**。    
建议自己造几组样例观察一下。


所以我们可以定义第 $i$ 次操作加入的括号的深度为 $deep_i$ （$deep_0=1$，为初始字符串）。  
至于得出这个数组，定义一个变量，遇到 $op=2$ 的操作将这个变量 $+1$ 即可。  
为了更新答案时统计方便，我们使用两个数组（单点改区间查）：  
- $c_i$ 代表 $op=2$ 且 $deep=i$ 的操作是否被撤销，**未被撤销为** $1$。  
- $d_i$ 代表 $dep=i$ 的操作有几个未被撤销。

### 更改后的 $op\in\{1,2\}$ 的操作
对于 $op=2$ 的操作，计算方式不变。  
对于 $op=1$ 的操作（设操作编号为 $p$）：  
- 找到一个最小的 $l$，满足 $\sum_{i=l}^{M}c_i=0$。 
- 所有满足 $l\leq deep_i\leq deep_p$ 且未被撤销的操作 $i$ 的总数为**增加**的答案。  
这么做的原因是中途部分 $op=2$ 的操作可能被撤销。

### 撤销/还原 $op=1$ 的操作  
以下设撤销/还原的操作编号为 $N$，$deep=M$。  
发现，撤销 $op=1$ 的操作的时候，根据前文的做法，我们可以这么计算答案：  
- 找到一个最小的 $l$，满足 $\sum_{i=l}^{M}c_i=0$。  
- 找到一个最大的 $r$，满足 $\sum_{i=M+1}^{r}c_i=0$。  
**这里 $M+1$ 是因为往深处跳不需要满足 $c_M=0$**。
- 所有满足 $l\leq deep_i\leq r$ 且未被撤销的操作 $i$ 的总数为**减少**的答案。  
以上过程正确的原因是这些操作得到的括号在合并后，如果重新计算它们的 $deep$，它们的结果将会相同，并还原至前文的做法。   

还原操作的时候同理，只是把减少改为增加。  
### 撤销/还原 $op=2$ 的操作
以下设撤销/还原的操作编号为 $N$，$deep=M$。  
先看撤销的时候：  
- 二分部分与前文的撤销相同，不再赘述。  
- 下文令 $f_{l,r}$ 为所有满足 $l\leq deep_i\leq r$ 且未被撤销的操作 $i$。  
1. 考虑**增加**的答案：
- $f_{l,m-1}$，可以与 $f_{m,r}$ 共同贡献答案。  
2. 考虑**减少**的答案：
- 撤销的操作与 $f_{m.r}$ 原本对答案做出贡献，需要删去。 
- 撤销的操作作为最外层括号的方案原本对答案做出贡献，需要删去。 

还原操作的时候： 
1. 考虑**减少**的答案：
- $f_{l,m-1}$，可以与 $f_{m,r}-1$ 原本对答案做出贡献，需要删去。   
这里扣去的 $1$ 是还原的那一个方案。  
2. 考虑**增加**的答案：
- $f_{m,r}-1$ 与还原的操作共同贡献答案。  
- 撤销的操作作为最外层括号的方案贡献答案。 

然后这道题就被纯树状数组做完了，时间复杂度 $O(n\log^2{n})$。  
## Part 2 代码
代码中，$inv_i$ 代表编号为 $i$ 的操作是否被撤销，**被撤销为** $1$。  
```cpp
#include<bits/stdc++.h>
#define int long long
#define MX 300005
using namespace std;
int n,q,qq,l,r,res=1,ans=1,re=1,dep[MX],inv[MX],tp[MX],s[MX],Tp[MX];

int c[MX],d[MX];int lbt(int w){return w&-w;}//树状数组
void gt(int w,int ww){for(;w<=n+5;w+=lbt(w)) c[w]+=ww;}
int sm(int w){int cnt=0;for(;w;w-=lbt(w)){cnt+=c[w];}return cnt;}
void addD(int w,int ww){for(;w<=n+5;w+=lbt(w)) d[w]+=ww;}
int smD(int w){int cnt=0;for(;w;w-=lbt(w)){cnt+=d[w];}return cnt;}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;dep[0]=1;addD(1,1);Tp[1]=0;c[0]=1;
	for(int i=1;i<=n;i++) gt(i,1);
	for(int i=1;i<=n;i++){
		cin>>q;
		if(q==1){//操作1
		    dep[i]=re;addD(re,1);tp[i]=i;
			l=1,r=re;
			while(l<r){
				int mid=(l+r)>>1;
				if(sm(re)-sm(mid-1)) l=mid+1;
				else r=mid;
			}r=r-inv[Tp[re]];
			ans+=(smD(re)-smD(r-1));
		}else if(q==2){//操作2
		    dep[i]=++re;addD(re,1);tp[i]=i;Tp[re]=i;
			ans+=(smD(re)-smD(re-1));s[i]=1;
		}else{//操作3
			cin>>qq; tp[i]=tp[qq];
			int N=tp[i]; int M=dep[N];
			if(!inv[N]){addD(M,-1);}
			    else{addD(M,1);}
			if(!inv[N] && s[N]) gt(M,-1);
			l=1,r=M;
			while(l<r){
				int mid=(l+r)>>1;
				if(sm(M)-sm(mid-1)) l=mid+1;
				else r=mid;
			}
			int L=r-1;
			l=M,r=re;
			while(l<r){
				int mid=(l+r+1)>>1;
				if(sm(mid)-sm(M)) r=mid-1;
				else l=mid;
			}
			int R=l;
			if(s[N]){
				if(!inv[N]){
					ans+=(
						(smD(M-1)-smD(L-1))*(smD(R)-smD(M-1))
						-(smD(R)-smD(M-1)+1)
					);
				}else{
					ans-=(
						(smD(M-1)-smD(L-1))*(smD(R)-smD(M-1)-1)
						-(smD(R)-smD(M-1))//这里将题解提到的贡献合并了
					);
				}
			}else{
			    //前面 L->L-1，这里视情况还原
			    L=L+1-inv[Tp[L+1]];
				if(inv[N])
					ans+=(smD(R)-smD(L-1));
				else
					ans-=(smD(R)-smD(L-1)+1);
			}
			if(inv[N] && s[N]) gt(M,1);
			inv[N]^=1;//撤销/还原方案
		}cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：int08 (赞：5)

## 前言
这下又不是官解了吧？

模拟赛题，在一个月后又出现在了数据结构讲稿上，令人忍俊不禁。

# Solution
官方解法是用线段树加矩阵，不过赛时的我显然没这么聪明，是想不到的。

赛时我就只知道先发掘一些答案的性质。
### 一、一些性质

首先，发现这个撤销操作比较棘手，考虑没有撤销操作的情况下，每一个新的操作对答案的贡献。

发现：对于每次操作二，对答案的贡献绝对只有 $1$！

只是在开头结尾各自加上一个括号，从左括号 $+1$、右括号 $-1$ 来看，前缀数组是时刻 $\ge0$ 的，如果在开头结尾加上一个括号，那前缀数组就只有最后一位为 $0$，也就是以第一个括号开头只能匹配结尾括号，反之亦然。

类似的，考虑操作一在结尾加上一组括号，增加的贡献一定是以最后括号结尾的，此时

```
(......)(......)(......)  +  ()
```
前面有几组括号贡献就是组数 $+1$，例如上图中尾部加入括号，贡献为 $4$。

换句话说，操作二贡献恒为 $1$，操作一贡献取决于前面连续操作一的次数，贡献为连续次数 $+1$。

~~有一种 OSU! 的美。~~

### 二、如何维护

你以为这道题就做完了？撤销操作才是本题的重点！

考虑撤销操作可能会对连续操作一的长度有影响。

比如说：

```
2 1 1 1 1 2 1 1 1 
```

撤销掉第二个操作二，会导致其左右两边操作一连起来。

就像打音游，本来某个位置一直断，有一次这里全连了，最后连击数就会变高。

而且还可以撤销撤销操作，就导致已经被撤销的操作二可能会打赢复活赛。

换句话说我们得维护一个关于操作二的链表，能支持随时在某个位置插入，删除和查询前面或者后面的第一个操作二。

但是直接写链表，操作一怎么办？

因为我们还需要能够快速得出两个位置之间的操作一次数，这是一个**区间查询**，链表上显然行不通。

但是偶然间想到一个复杂度稍逊但是也可以维护链表的东西：**平衡树！**

这道题的解法就显然了：

**用 set 维护操作二的插入和删除，记录下每次操作二的位置之后，便可以用树状数组来查询其间操作一数量。**

### 三、具体影响

末尾加操作二，简单，$+1$ 即可。

末尾加操作一，用 set 找到上一个还活着的操作二，树状数组求出其间的操作一数量为 $x$ 贡献为 $x+1$。

中间插入或删除操作一：找到左右的操作二，剩下同上。

中间插入或删除操作二，看看这个操作二左右两端各有多长的操作一，简单计算即可。

复杂度显然为 $O(n\log n)$。

这显然不是官方解法，而且显然比官方做法简单。

## AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t[1234657],n,cnt;
void change(int x,int v)
{
	for(;x<=n+10;x+=x&-x) t[x]+=v;
}
int ask(int x)
{
	int ans=0;
	for(;x>0;x-=x&-x) ans+=t[x];
	return ans;
}
set<int> s,fs;
int i,j,op,x;
int ot[666666],ch[666666],lo[666666];
signed main()
{
	cin>>n;
	for(i=1;i<=n;i++)
	ch[i]=i;
	int ans=1,p=1;
	s.insert(0);fs.insert(0);
	s.insert(n+1);fs.insert(-n-1);
	for(i=1;i<=n;i++)
	{
		cin>>op;
		ot[i]=op;
		if(op==1)
		{	
			cnt++;
			lo[i]=cnt;
			change(cnt,1);
			int q=-(*fs.upper_bound(-cnt));
			ans+=ask(cnt)-ask(q)+1;
		}
		if(op==2)
		{
			ans++;
			cnt++;
			lo[i]=cnt;
			s.insert(cnt);fs.insert(-cnt);
		}
		if(op==3)
		{
			cin>>x;
			ch[i]=-ch[x];
			if(ch[i]>0)
			{
				int ty=ot[ch[i]],loc=lo[ch[i]];
				int fr=-(*fs.upper_bound(-loc)),bk=*s.upper_bound(loc);
				if(ty==1)
				{
					change(loc,1);
					ans+=ask(bk-1)-ask(fr)+1;
				}
				if(ty==2)
				{
					s.insert(loc);fs.insert(-loc);
					ans++;
					int c=ask(bk-1)-ask(fr);
					ans-=c*(c+3)/2;
					c=ask(loc-1)-ask(fr);
					ans+=c*(c+3)/2;
					c=ask(bk-1)-ask(loc);
					ans+=c*(c+3)/2;
				}
			}
			else
			{
				int ty=ot[-ch[i]],loc=lo[-ch[i]];
				int fr=-*fs.upper_bound(-loc),bk=*s.upper_bound(loc);
				if(ty==1)
				{
					change(loc,-1);
					ans-=ask(bk-1)-ask(fr)+2;
				}
				if(ty==2)
				{
		//			cout<<"?"<<ans<<"? ";
					ans--;
					s.erase(loc);fs.erase(-loc);
					int c=ask(bk-1)-ask(fr);
					ans+=c*(c+3)/2;
			//		cout<<"?"<<ans<<"? ";
					c=ask(loc-1)-ask(fr);
					ans-=c*(c+3)/2;
				//	cout<<"?"<<ans<<"? ";
					c=ask(bk-1)-ask(loc);
					ans-=c*(c+3)/2;
					//cout<<"?"<<ans<<"? ";
				}
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
## 后记

~~这题解有一种为了一碗醋包了一盘饺子的美。~~

什么叫数据结构只会树状数组啊。

# The End.

---

## 作者：Schi2oid (赞：4)

# P6864 [RC-03] 记忆 题解

考虑按照题目描述构造出来的括号串具有的性质。

首先，我们将所有的括号转换成一段折线图，$\texttt{(}$ 记录为 $+1$，$\texttt{)}$ 记录为 $-1$，那么容易发现依照题目描述构造出来的所有串应该形如下图：

![](https://s1.ax1x.com/2023/02/25/ppSDjk4.png)

我们一定可以将整张折线图划分成若干层，每一层都是不断的 $+1$ 和 $-1$ 的震荡，然后进入下一层。一操作等价于在当前层末尾新加入一次震荡，二操作相当于进入下一层，而三操作相当于将某一层去掉/恢复一次震荡或是将某两层分裂/合并。容易注意到每次一操作或二操作都会唯一地对应上图中的一个点。

考虑原题所求的合法括号串数量，等价于选择两个在折线图上等高的点，且它们之间所有的点都不低于它们的高度。由于此题括号串的特性，这等价于选择一对位于同一层的点。所以，我们设落在某一层上的点数量为 $c_i$（忽略最左侧连续上升的段），那么 $Ans=\sum \frac{c_i(c_i+1)}{2}$。因此，先不考虑撤销操作，我们使用一个 $set$，维护每一层的起始位置，最开始向 $set$ 中加入 $1$，询问下标改为 $2\sim q+1$，就可以简单地维护答案。对于一操作，我们直接将答案加上当前层的 $c_i$；对于二操作，我们向 $set$ 中加入当前询问下标，然后将答案加上 $1$。

接下来考虑撤销操作。本质上来说，我们可以维护每个点是否有效。使用树状数组维护每个点的有效状态，对于一次撤销，我们可以处理出它实际上是对哪一次一操作或二操作进行的，然后将这一次操作的有效状态取反，在更新答案时忽略掉区间内无效的操作，由于二操作的撤销最多涉及两层，此时的复杂度依然正确。对于三操作而言，我们直接将它设置成无效操作即可，因为这一操作本身并不会对括号串产生任何改变。

时间复杂度 $O(n\log n)$。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
set<int>s;
int q;
int opt[200005],pos[200005];
int t[200005];
int lowbit(int x){return x&(-x);}
void add(int x,int k){
	while(x<=q){
		t[x]+=k;
		x+=lowbit(x);
	}
}
int sum(int x){
	int ret=0;
	while(x){
		ret+=t[x];
		x-=lowbit(x);
	}
	return ret;
}
signed main(){
	int p;
	cin>>q;
	q++;
	s.insert(1);
	int ans=1;
	for(int i=2;i<=q;i++){
		scanf("%lld",&opt[i]);
		if(opt[i]==1){
			pos[i]=i;
			int tmp=*(--s.end());
			int del=sum(i)-sum(tmp-1);
			int len=i-tmp+1;
			ans+=len-del;
		}
		else if(opt[i]==2){
			pos[i]=i;
			s.insert(i);
			ans++;
		}
		else{
			add(i,1);
			scanf("%lld",&p);
			p++;
			opt[i]=opt[p],pos[i]=pos[p];
			p=pos[p];
			int chk=sum(p)-sum(p-1);
			if(!chk) chk=-1;
			int bg=*(--s.upper_bound(p));
			set<int>::iterator it=s.upper_bound(p);
			int ed;
			if(it==s.end()) ed=i;
			else ed=(*it)-1;
			if(opt[p]==1){
				int len=ed-bg+1;
				int del=sum(ed)-sum(bg-1);
				ans-=(len-del)*(len-del+1)/2;
				add(p,-chk);
				del=sum(ed)-sum(bg-1);
				ans+=(len-del)*(len-del+1)/2;
			}
			else{
				if(chk==1){
					int del=sum(ed)-sum(bg-1);
					int len=ed-bg+1;
					ans-=(len-del)*(len-del+1)/2;
					add(p,-chk);
					int l1=p-bg,l2=ed-p+1,d1=sum(p-1)-sum(bg-1),d2=sum(ed)-sum(p-1);
					ans+=(l1-d1)*(l1-d1+1)/2+(l2-d2)*(l2-d2+1)/2;
					s.insert(p);
				}
				else{
					int bef=*(--s.lower_bound(p));
					int l1=bg-bef,l2=ed-bg+1,d1=sum(bg-1)-sum(bef-1),d2=sum(ed)-sum(bg-1);
					ans-=(l1-d1)*(l1-d1+1)/2+(l2-d2)*(l2-d2+1)/2;
					add(p,-chk);
					int len=ed-bef+1,del=sum(ed)-sum(bef-1);
					ans+=(len-del)*(len-del+1)/2;
					s.erase(p);
				}
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：ダ月 (赞：3)

### 题目分析：

前置知识：线段树，矩阵。

一个直观的感受，整个字符串在任何时候都是匹配的。我们每次加入的时候只用考虑当前加入的括号对当前字符串的影响。

我们记 $p$ 为当前字符串最多可以分割成括号匹配的子串的数量。

- 对于操作 $1$：

我们可以发现无论这对括号加到哪个地方，前半部分贡献和后半部分贡献和总是 $p+1$（加上自身的贡献）。此时，整个序列可以多分割出一个括号匹配了的子串，即 $p$ 更新成 $p+1$。考虑将转移写成矩阵的形式，即：$\begin{bmatrix}1&0&0\\1&1&0\\1&1&1\\\end{bmatrix}$。

其中，$(1,1)$ 代表常量 $1$，$(2,1)$ 代表当前连续操作 $1$ 的个数，$(2,2)$ 代表是否加上自身贡献（在当前仅有操作 $1$ 中是有的），$(3,1)$ 代表当前的答案，$(3,2)$ 代表 $p$，$(3,3)$ 代表这个自增量 $1$。

- 对于操作 $2$：

我们可以同理得出以下矩阵：$\begin{bmatrix}1&0&0\\0&0&0\\1&1&1\\\end{bmatrix}$。

因为在操作 $2$ 时，本身就是连续 $0$ 个操作 $1$，不需要加上自身贡献。

- 对于操作 $3$:

我们只需要翻转这个时间的操作，改成单位矩阵或恢复其形态就行。

最后答案左乘上一个 $\begin{bmatrix}1,1,1\end{bmatrix}$。

代表初始状态。

自行理解一下矩阵乘法的转移过程。

由于矩阵乘法满足结合律，所以我们可以用线段树来维护矩阵乘法。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+10;
//===
缺省源
//===
struct Matrix{
	ll a[4][4];
	int n,m;
	void init1(){a[1][1]=a[2][1]=a[2][2]=a[3][1]=a[3][2]=a[3][3]=1;n=m=3;}
	void init2(){a[1][1]=a[3][1]=a[3][2]=a[3][3]=1;n=m=3;}
	void init3(){a[1][1]=a[2][2]=a[3][3]=1;n=m=3;}
	void init4(){a[1][1]=a[1][2]=a[1][3]=1;n=1,m=3;}
	void init5(){memset(a,0,sizeof(a));}
	Matrix operator *(Matrix B){
		Matrix ans;ans.init5();ans.n=this->n;ans.m=B.m;
		assert(this->m==B.n);
		for(int i=1;i<=ans.n;i++)
			for(int j=1;j<=ans.m;j++)
				for(int k=1;k<=this->m;k++)
					ans.a[i][j]+=this->a[i][k]*B.a[k][j];
		return ans;
	}
};
int n;
int p[N],rot[N],did[N];
struct node{Matrix x;}tr[N<<2];
void pushup(int rt){tr[rt].x=tr[rt<<1].x*tr[rt<<1|1].x;}
void build(int rt,int l,int r){
	if(l==r){tr[rt].x.init5();tr[rt].x.init3();return void();}
	int mid=l+r>>1;
	build(rt<<1,l,mid);build(rt<<1|1,mid+1,r);
	pushup(rt);
	return;
}void change(int rt,int l,int r,int x,int opt){
	if(l==r){
		tr[rt].x.init5();
		if(opt<0)tr[rt].x.init3();
		else if(opt==1)tr[rt].x.init1();
		else tr[rt].x.init2();
		return void();
	}int mid=l+r>>1;
	if(x<=mid)change(rt<<1,l,mid,x,opt);
	else change(rt<<1|1,mid+1,r,x,opt);
	pushup(rt);
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=IO::readInt();Matrix Base;Base.init4();
	build(1,1,n);
	for(int i=1;i<=n;i++){
		int opt=IO::readInt();
		if(opt==1)p[i]=rot[i]=i,did[i]=1,change(1,1,n,p[i],1);
		else if(opt==2)p[i]=rot[i]=i,did[i]=2,change(1,1,n,p[i],2);
		else rot[i]=IO::readInt(),p[i]=p[rot[i]],did[i]=-did[rot[i]],change(1,1,n,p[i],did[i]);
		printf("%lld\n",(Base*tr[1].x).a[1][1]);
	}return 0;
}
```


---

## 作者：chenxinyang2006 (赞：3)

官方题解貌似挺麻烦的，给一个不太用动脑子的方法（

首先我们可以知道，任何时刻这个括号串都是匹配的，这点显而易见

考虑进行一二操作产生的影响
   
记后缀匹配括号数为 $cnt$
   
那么一操作会增加 $cnt + 1$ 个匹配括号串，$cnt$ 也会增加 $1$
   
二操作后，显然整个串会是匹配的，那么会增加多少个前缀匹配串呢（默认不是整个串）？
   
答案是没有，原因是加上一个左括号后匹配的前缀括号串，原来的权值和（也就是左括号作为 $1$，右括号作为 $-1$ 的和）是 $-1$，而进行操作前的括号序列是匹配的，也就不存在这样的前缀
   
同样的，也不会增加后缀匹配串，如果有匹配后缀串的话，删去最后加上的右括号，形成的原来的后缀括号串的权值就是 $1$，因为原来的串整个的权值和为 $0$，意味着有一个前缀括号串的权值和为负数
   
于是进行二操作 $ans$ 会增加 $1$，$cnt$ 变为 $1$
   
注意到两种操作转移的影响可以写成一个 $3 \times 3$ 的矩阵，于是我们就是要维护矩阵连续乘积
   
撤销操作相当于单点修改一个矩阵，单点修改，全局矩阵连乘积，可以使用线段树简单维护

同样也在 $O(n \log n)$ 的时间内解决了问题，但是常数巨大

```cpp
#include <cstdio>
#define ll long long
int n;
int tag[200005],op[200005],p[200005];

struct M{
	ll v[5][5];
}A,B,C;

M operator * (M a,M b){
	M c;
	for(int i = 1;i <= 3;i++){
		for(int j = 1;j <= 3;j++){
			c.v[i][j] = 0;
			for(int k = 1;k <= 3;k++){
				c.v[i][j] += a.v[i][k] * b.v[k][j];
			}
		}
	}
	return c;
}

M tree[800005];
#define ls (rt * 2)
#define rs (rt * 2 + 1)

void upload(int rt,int l,int r,int id,int tp){
	if(l == r){
		if(tp == 1) tree[rt] = A;
		else if(tp == 2) tree[rt] = B;
		else tree[rt] = C;
		return;
 	}
 	int mid = l + r >> 1;
 	if(id <= mid){
 		upload(ls,l,mid,id,tp);
	}else{
	 	upload(rs,mid+1,r,id,tp);
	}
	tree[rt] = tree[ls] * tree[rs];
}

int main(){
	A.v[1][1] = A.v[2][1] = A.v[2][2] = A.v[3][1] = A.v[3][2] = A.v[3][3] = 1;
	A.v[1][2] = A.v[1][3] = A.v[2][3] = 0;
	B.v[1][1] = B.v[3][1] = B.v[3][2] = B.v[3][3] = 1;
	B.v[1][2] = B.v[1][3] = B.v[2][1] = B.v[2][2] = B.v[2][3] = 0;
	C.v[1][1] = C.v[2][2] = C.v[3][3] = 1;
	C.v[1][2] = C.v[1][3] = C.v[2][1] = C.v[2][3] = C.v[3][1] = C.v[3][2] = 0;
	scanf("%d",&n);
	for(int i = 1;i <= 4 * n;i++) tree[i] = C;
	for(int i = 1;i <= n;i++){
	    scanf("%d",&op[i]);
	    if(op[i] == 1){
	    	p[i] = i;
	    	upload(1,1,n,i,1);
		}else if(op[i] == 2){
			p[i] = i;
			upload(1,1,n,i,2);
		}else{
			scanf("%d",&p[i]);
			p[i] = p[p[i]];
			if(tag[p[i]]){
				tag[p[i]] = 0;
				upload(1,1,n,p[i],op[p[i]]);
			}else{
				tag[p[i]] = 1;
				upload(1,1,n,p[i],3);
			}
		}
		M tmp;
		tmp.v[1][1] = tmp.v[1][2] = tmp.v[1][3] = 1;
		tmp.v[2][1] = tmp.v[2][2] = tmp.v[2][3] = tmp.v[3][1] = tmp.v[3][2] = tmp.v[3][3] = 0;
		tmp = tmp * tree[1];
		printf("%lld\n",tmp.v[1][1]);
 	}
	return 0;
}
```


---

## 作者：Louis_lxy (赞：2)

模拟赛 T4，算是有史以来最简单的 T4 了。

先考虑 40pts 怎么做，也就是 $\mathcal O(1)$ 处理 1 和 2 操作，$\mathcal O(n)$ 处理 3 操作。我们考虑操作 1 会造成什么影响，首先会增加左边有多少个可以和它连在一起的合法括号序列数量，然后还会增加它自己这个括号。操作 2 则是会增加它自己本身，并将能够贡献给操作 1 的合法括号序列数量变为 $1$。

注意到这是线性变化，于是用矩阵维护它即可。

注意我们要维护每次撤销具体是撤销那个，于是容易想到递推得到，但是赛时降智写了并查集。

现在是矩阵乘法中的最优解，另外，全部的最优解是我同学（至少是现在），oyoham 的代码是 $\mathcal O(n^2)$ 的。。。。

code:

```cpp
#include <bits/stdc++.h>
#define lson (x << 1)
#define rson ((x << 1) | 1)
#define mid ((l + r) >> 1)
#define int long long
using namespace std;

const int N = 2e5 + 10;
int n, op[N], x[N], vis[N], res, cnt, fa[N];

class fastio
{
	static const int MAX = 1 << 15; char ibuf[MAX], *p1 = ibuf, *p2 = ibuf, obuf[MAX], *p3 = obuf, sta[50]; bool file_end = false;
	inline char get() { return p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, MAX, stdin), p1 == p2) ? (file_end = true), char(EOF) : *p1++; }
	inline void put(const char x) { p3 - obuf < MAX ? *p3++ = x : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3++ = x); }
	inline explicit operator bool() { return !file_end; }
	size_t flush() { size_t f = fwrite(obuf, p3 - obuf, 1, stdout); p3 = obuf; *p3 = 0; return f; }
public :
	inline fastio &operator >> (char &t) { for (t = get(); !isgraph(t); t = get()); return *this; }
	inline fastio &operator >> (char *t) { char c; for (c = get(); !isgraph(c); c = get()); for (; isgraph(c); c = get()) * t = c, t++; *t = 0; return *this; }
	inline fastio &operator >> (string &t) { t.clear(); char c; for (c = get(); !isgraph(c); c = get()); for (; isgraph(c); c = get()) t += c; return *this; }
	inline fastio &operator << (const char t) { put(t); return *this; }
	inline fastio &operator << (const char *t) { for (; *t; ++t) put(*t); return *this; }
	inline fastio &operator << (const string &t) { for (const char it : t) put(it); return *this; }
	inline fastio &read(char *t) { char c; for (c = get(); !isgraph(c); c = get()); for (; isgraph(c); c = get()) * t = c, t++; *t = 0; return *this; }
	template <typename any1, typename any2> inline pair<any1, any2> tpval() { return pair<any1, any2>(tpval<any1>(), tpval<any2>()); }
	template <typename any> inline typename enable_if <is_same<any, char>::value, any>::type tpval() { char t; for (t = get(); !isgraph(t); t = get()); return t; }
	template <typename any> inline typename enable_if <is_same<any, string>::value, any>::type tpval() { string t; char c; for (c = get(); !isgraph(c); c = get()); for (; isgraph(c); c = get()) t += c; return t; }
	template <typename any> inline typename enable_if <(is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) || is_same<any, __int128_t>::value, any >::type tpval() { any t = 0; bool y = 0; char c = get(); for (; !isdigit(c); c = get()) if (c == 45) y = true; for (; isdigit(c); c = get()) t = t * 10 + (c ^ 48); if (y == 1) t = -t; return t; }
	template <typename any> inline typename enable_if <(is_signed<any>::value && std::is_integral<any>::value && !is_same<any, char>::value) || is_same<any, __int128_t>::value, fastio >::type &operator >> (any &t) { t = 0; bool y = 0; char c = get(); for (; !isdigit(c); c = get()) if (c == 45) y = true; for (; isdigit(c); c = get()) t = t * 10 + (c ^ 48); if (y == 1) t = -t; return *this; }
	template <typename any> inline typename enable_if <(is_unsigned<any>::value && std::is_integral<any>::value && !is_same<any, char>::value) || is_same<any, __uint128_t>::value, any >::type tpval() { any t = 0; char c = get(); for (; !isdigit(c); c = get()); for (; isdigit(c); c = get()) t = t * 10 + (c ^ 48); return t; }
	template <typename any> inline typename enable_if <(is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) || is_same<any, __uint128_t>::value, fastio >::type &operator >> (any &t) { t = 0; char c = get(); for (; !isdigit(c); c = get()); for (; isdigit(c); c = get()) t = t * 10 + (c ^ 48); return *this; }
	template <typename any1, typename any2> inline fastio &operator >> (pair<any1, any2> &t) { return *this >> t.first >> t.second; }
	template <typename any> inline typename enable_if <(is_signed<any>::value && is_integral<any>::value && !is_same<any, char>::value) || is_same<any, __int128_t>::value, fastio >::type &operator << (any t) { if (!t) { put(48); return *this; } int len = 0; if (t < 0) t = -t, put(45); while (t) sta[len++] = char((t % 10) ^ 48), t /= 10; while (len--) put(sta[len]); return *this; }
	template <typename any> inline typename enable_if <(is_unsigned<any>::value && is_integral<any>::value && !is_same<any, char>::value) || is_same<any, __uint128_t>::value, fastio >::type &operator << (any t) { if (!t) { put(48); return *this; } int len = 0; while (t) sta[len++] = char((t % 10) ^ 48), t /= 10; while (len--) put(sta[len]); return *this; }
	template <typename any1, typename any2> inline fastio &operator << (const pair<any1, any2> &t) { return *this << t.first << ' ' << t.second; } template <typename any> fastio &write(const any &t) { return *this << t; } template <typename any, typename...args> fastio &write(const any &t1, const args &...t2) { return (*this << t1).write(t2...); }
	template <typename any> inline fastio &read(any &t) { return *this >> t; }
	template <typename any, typename...args> inline fastio & read(any &t1, args &...t2) { return (*this >> t1).read(t2...); }
	~fastio() { fwrite(obuf, p3 - obuf, 1, stdout); }
} fio;

struct matrix {
	int a[3][3];
	inline int* operator [] (int x) { return a[x]; }
	inline matrix (bool flag = 0) {
		memset(a, 0, sizeof a);
		if (flag) a[0][0] = a[1][1] = a[2][2] = 1;
	}
	inline friend matrix operator * (matrix a, matrix b) {
		matrix c;
		c[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0];
		c[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1];
		c[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2];
		c[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0];
		c[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1];
		c[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2];
		c[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0];
		c[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1];
		c[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2];
		return c;
	}
} tr[N << 2], I(1), A, B, C;

void build(int x, int l, int r) {
	tr[x] = I;
	if (l == r) return;
	build(lson, l, mid), build(rson, mid + 1, r);
}

void modify(int x, int l, int r, int d, matrix k) {
	if (l == r) { tr[x] = k; return; }
	if (d <= mid) modify(lson, l, mid, d, k);
	else modify(rson, mid + 1, r, d, k);
	tr[x] = tr[lson] * tr[rson];
}

signed main() {
	fio >> n;
	A[0][0] = 1, A[0][1] = 0, A[0][2] = 0;
	A[1][0] = 1, A[1][1] = 1, A[1][2] = 0;
	A[2][0] = 1, A[2][1] = 1, A[2][2] = 1;
	B[0][0] = 1, B[0][1] = 0, B[0][2] = 0;
	B[1][0] = 0, B[1][1] = 0, B[1][2] = 0;
	B[2][0] = 1, B[2][1] = 1, B[2][2] = 1;
	C[0][0] = 1, C[0][1] = 1, C[0][2] = 1;
	C[1][0] = 0, C[1][1] = 0, C[1][2] = 0;
	C[2][0] = 0, C[2][1] = 0, C[2][2] = 0;
	build(1, 1, n);
	for (int i = 1; i <= n; ++i) {
		fio >> op[i], fa[i] = i;
		if (op[i] == 1) modify(1, 1, n, i, A);
		else if (op[i] == 2) modify(1, 1, n, i, B);
		else {
			fio >> x[i];
			fa[i] = fa[x[i]];
			int p = fa[i];
			vis[p] ^= 1;
			if (!vis[p]) {
				if (op[p] == 1) modify(1, 1, n, p, A);
				else if (op[p] == 2) modify(1, 1, n, p, B);
			} else modify(1, 1, n, p, I);
		}
		matrix p = C * tr[1];
		fio << p[0][0] << '\n';
	}
	return 0;
}
```

---

## 作者：Lyrella (赞：2)

# 思路

我们可以先考虑模拟整个过程，或者更简单一点，我们去计算一个已经确定的串。

比如现在有一个串：$(((()()())))()()$，我们观察这个串的最外层是三个并列的括号，我们可以得到一共 ${3\times4\over2}=6$ 种选择方法。

然后再看到最前面的那个 $(((()()())))$，对于最外层的括号我们可选可不选，所以最外层每多一对括号就会多一种方法。

于是考虑对每次操作维护一个括号串的后缀存在多少个连续的括号，记做 $\operatorname{suf}$，然后答案 $\operatorname{ans}_i=\operatorname{ans}_{i-1}+\operatorname{suf}_i$，如果是第二种操作就直接答案加一。

现在考虑第三种操作。我们会回溯到之前的某次操作中，但是操作三可能会嵌套，所以我们需要进行路径压缩。然后根据**嵌套的奇偶性**我们需要处理一些撤销与撤销之前的撤销的神秘操作。

具体怎么撤销，就是把刚刚做的操作倒着做回去，比如操作一就把答案和后缀都减去之前的后缀长加一；操作二就直接答案减一。

但是这些操作都有后效性，也就是前面的操作会对后面的答案与后缀产生影响（废话），直接暴力做复杂度是 $O(n^2)$。

考虑优化。注意到我们做一二操作的时候的转移与之前的数值无关，这启发我们用数据结构去**维护操作**，注意不是操作后的值。

对于两种不同的操作我们可以用矩阵表示。发现之前的式子 $\operatorname{ans}_i=\operatorname{ans}_{i-1}+\operatorname{suf}_i$ 等式右边不同阶，考虑把 $\operatorname{suf}_i$ 写成 $\operatorname{suf}_{i-1}+1$ 然后就可以做了。
因为有三操作的存在，也就是需要修改，所以上线段树维护转移矩阵即可，复杂度 $O(n\log n\omega^3)$，其中 $\omega$ 的大小由个人习惯决定。

（比如我写的时候脑抽多加了一层无用的信息）

代码如下：

```cpp
struct Matrix{
	int n, m; ll a[4][4];
	void clr(){n = m = 0; for(int i = 0; i < 4; ++i)for(int j = 0; j < 4; ++j)a[i][j] = 0;}
    friend Matrix operator * (Matrix x, Matrix y){
        Matrix res; res.clr(); res.n = x.n; res.m = y.m;
        for(int i = 0; i < 4; ++i)for(int j = 0; j < res.m; ++j)
            for(int k = 0; k < 4; ++k)res.a[i][j] += x.a[i][k] * y.a[k][j];
        return res;
    }
	void init(){n = m = 4; for(int i = 0; i < 4; ++i)a[i][i] = 1;}
	void output(){for(int i = 0; i < n; ++i, puts(""))for(int j = 0; j < m; ++j)printf("%d ", a[i][j]);}
}f1 = {4, 4, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1},
f2 = {4, 4, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1},
I = {4, 4, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}, t[N << 2],
s = {4, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1}, ans;
int n, opt[N], id[N];

int ls[N << 2], rs[N << 2], nd, rt;

void upd(int x){
    if(rs[x])t[x] = t[rs[x]] * t[ls[x]];
    else t[x] = t[ls[x]];
}
void mdf(int &x, int l, int r, int pos, short o){
    if(! x)x = ++nd;
    if(l == r){
        if(o == 1)t[x] = f1;
        if(o == 2)t[x] = f2;
        if(o == 3)t[x] = I;
        return;
    }
    int mid = l + r >> 1;
    if(pos <= mid)mdf(ls[x], l, mid, pos, o);
    else mdf(rs[x], mid + 1, r, pos, o);
    upd(x);
}

signed main(){
    n = rd();
    for(int i = 1; i <= n; ++i){
        opt[i] = rd();
        if(opt[i] == 3){
            id[i] = rd(); if(opt[id[i]] == 3)id[i] = - id[id[i]];
            if(id[i] > 0)mdf(rt, 1, n, id[i], 3);
            else mdf(rt, 1, n, - id[i], opt[- id[i]]);
            mdf(rt, 1, n, i, 3);
        }
        else if(opt[i] ^ 2)mdf(rt, 1, n, i, 1);
        else mdf(rt, 1, n, i, 2);
        ans = t[1] * s;
        printf("%lld\n", ans.a[2][0]);
    }
    return 0;
}
```

---

## 作者：rizynvu (赞：2)

[我的博客](https://www.cnblogs.com/rizynvu/p/18278861)。

2024.07.01：修改了博客网址。  
2024.07.02：修改了括号格式。

先考虑没有 $3$ 操作该怎么做。  
对于当前字符串把其分成多组互不包含的括号的形式，即 $\texttt{(}\cdots\texttt{)()()}$ 这样，考虑经过 $1 / 2$ 操作后对互不包含的括号组数 $b$ 和答案 $v$ 会产生什么影响。  
- $1$ 操作，加上过后便会多上一组互不包含的括号，$b\leftarrow b' + 1$，同时这个括号能和前面的所有互不包含的括号连起来对答案产生贡献，$v\leftarrow v' + b' + 1$。
- $2$ 操作，此时所有括号都被新的括号包含了，$b = 1$，答案会多上整个串，$v\leftarrow v' + 1$。

再来考虑有 $3$ 操作该怎么做，这个操作即可以改变一个操作对答案是否产生贡献，每次进行此操作都需要重头再推，考虑降低修改的时间复杂度。  
单点修改全局查询，考虑到使用线段树，再结合 $v, b$ 能发现其变化都是 $\times +$ 操作，考虑把其写成矩阵的形式 $\begin{bmatrix}v & b & 1\end{bmatrix}$，再来考虑构造每个操作对应的矩阵。
- $1$ 操作：$\begin{bmatrix}v & b & 1\end{bmatrix} \times\begin{bmatrix}1 & 0 & 0 \\ 1 & 1 & 0 \\ 1 & 1 & 1 \end{bmatrix}= \begin{bmatrix}v + b + 1 & b + 1 & 1\end{bmatrix}$。
- $2$ 操作：$\begin{bmatrix}v & b & 1\end{bmatrix} \times\begin{bmatrix}1 & 0 & 0 \\ 0 & 0 & 0 \\ 1 & 1 & 1 \end{bmatrix}= \begin{bmatrix}v + 1 & 1 & 1\end{bmatrix}$。
- $3$ 操作：如果是被删除的操作还原按照 $1 / 2$ 操作构造即可，若是删除则为单位矩阵，即 $\begin{bmatrix}v & b & 1\end{bmatrix} \times\begin{bmatrix}1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}= \begin{bmatrix}v & b & 1\end{bmatrix}$。

对于每个操作，直接单点修改对应位置的矩阵即可，最后用初始矩阵 $\begin{bmatrix}1 & 1 & 1\end{bmatrix}$ 乘上全部的操作矩阵的乘积即可。

时间复杂度 $\mathcal{O}(w^3\times n\log n)$，$w$ 为矩阵大小。

```cpp
#include<bits/stdc++.h>
using ll = long long;
const int N = 2e5 + 10;
int n;
struct Matrix {
	ll a[3][3];
	Matrix() {
		memset(a, 0, sizeof(a));
	}
	const ll* operator [] (int x) const {
		return a[x];
	}
	ll* operator [] (int x) {
		return a[x];
	}
	Matrix operator * (const Matrix &b) const {
		Matrix c;
		for (int i = 0; i < 3; i++) {
			for (int k = 0; k < 3; k++) {
				for (int j = 0; j < 3; j++) {
					c[i][j] += a[i][k] * b[k][j];
				}
			}
		}
		return c;
	}
	Matrix operator *= (const Matrix &b) {
		return *this = *this * b;
	}
};
Matrix t[N * 4];
void pushup(int k) {
	t[k] = t[k << 1] * t[k << 1 | 1];
}
void build(int k = 1, int l = 1, int r = n) {
	if (l == r) {
		t[k][0][0] = t[k][1][1] = t[k][2][2] = 1;
		return ;
	}
	int mid = (l + r) >> 1;
	build(k << 1, l, mid), build(k << 1 | 1, mid + 1, r);
	pushup(k);
}
void update(int x, const Matrix &y, int k = 1, int l = 1, int r = n) {
	if (l == r) {
		t[k] = y;
		return ;
	}
	int mid = (l + r) >> 1;
	if (x <= mid) {
		update(x, y, k << 1, l, mid);
	} else {
		update(x, y, k << 1 | 1, mid + 1, r);
	}
	pushup(k);
}
int opt[N], x[N], vis[N];
void make_matrix(int opt, Matrix &z) {
	if (opt == 0) {
		z[0][0] = z[1][1] = z[2][2] = 1;
	} else if (opt == 1) {
		z[0][0] = z[1][0] = z[1][1] = z[2][0] = z[2][1] = z[2][2] = 1;
	} else if (opt == 2) {
		z[0][0] = z[2][0] = z[2][1] = z[2][2] = 1;
	}
}
int main() {
	scanf("%d", &n);
	build();
	for (int i = 1; i <= n; i++) {
		scanf("%d", &opt[i]);
		if (opt[i] != 3) {
			Matrix z;
			make_matrix(opt[i], z);
			update(i, z);
		} else if (opt[i] == 2) {
			Matrix z;
			z[0][0] = z[2][0] = z[2][1] = z[2][2] = 1;
			update(i, z);
		} else {
			scanf("%d", &x[i]);
			if (opt[x[i]] == 3) {
				x[i] = x[x[i]];
			}
			vis[x[i]] ^= 1;
			Matrix z;
			make_matrix(vis[x[i]] ? 0 : opt[x[i]], z);
			update(x[i], z);
		}
		Matrix x;
		x[0][0] = x[0][1] = x[0][2] = 1;
		x *= t[1];
		printf("%lld\n", x[0][0]);
	}
	return 0;
}
```

---

## 作者：LinkCatTree (赞：2)

本篇博客介绍了题解区较主流的矩阵 + 线段树的做法，希望能够给你帮助。

一些更好的观感：[View in 3ZincBlog](https://3zinc.github.io/2023/58502/)。

## 1. 操作一

对于操作一，很明显，它会增加到上一个操作二为止的所有操作数（包括它本身）。

举个例子：对于字符串 $\texttt{(()())()}$，如果执行操作一，会多出 $3$ 的合法的括号序列。这三个合法的括号序列分别是：$\texttt{(()())()()}$，$\texttt{()()}$ 和 $\texttt{()}$。

由此，我们可以得出操作一时，矩阵的转移。

$t_1=\begin{bmatrix}1&0&0\\1&1&0\\1&1&1\end{bmatrix}$

在这里，我们用 $a_{1,1}$ 存储常量 $1$（在加一时需要用到），$a_{2,1}$ 表示从上一个操作二到目前为止的所有操作一的数量（**包括当前操作**），而 $a_{3,1}$ 表示目前所有合法括号序列的数量。

（由于在转移时，要加上最近一个操作二，所以 $t_{1,3,1}$ 是 $1$ 而不是 $0$）

## 2. 操作二

由于每个操作二会让答案加 $1$，并使 $a_{2,1}$ 变为 $0$。可得矩阵 $t_2$。

$t_2=\begin{bmatrix}1&0&0\\0&0&0\\1&1&1\end{bmatrix}$

## 3. 操作三

考虑操作三，相当于把矩阵更改之前某个状态的矩阵，也就是把这个操作对应的矩阵翻转并相乘，因为矩阵乘法有结合律，可以使用线段树维护。

## 4. 实现

在最后输出答案的时候，需要再乘上一个 $\begin{bmatrix}1&1&1\end{bmatrix}$，表示初始状态。

代码丑陋，仅供参考：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=200005;
int n,op[MAXN],x[MAXN];
bool cancel[MAXN];
struct Matrix {
    ll a[3][3];
    Matrix() {
        memset(a,0,sizeof(a));
        return ;
    }
    friend Matrix operator*(const Matrix tmp1,const Matrix tmp2) {
        Matrix res;
        for(int i=0;i<3;i++) for(int j=0;j<3;j++) for(int k=0;k<3;k++)
            res.a[i][k]+=tmp1.a[i][j]*tmp2.a[j][k];
        return res;
    }
};
Matrix tree[MAXN<<2],mat[4],tmp;
void change(int l,int r,int p,int x,int i) {
    if(l==r) {
        tree[p]=mat[i];
        return ;
    }
    int mid=l+r>>1;
    if(x<=mid) change(l,mid,p<<1,x,i);
    if(x>mid) change(mid+1,r,p<<1|1,x,i);
    tree[p]=tree[p<<1]*tree[p<<1|1];
    return ;
}
int main() {
    scanf("%d",&n);
    mat[1].a[0][0]=mat[1].a[1][0]=mat[1].a[1][1]=mat[1].a[2][0]=mat[1].a[2][1]=mat[1].a[2][2]=1LL;
    mat[2].a[0][0]=mat[2].a[2][0]=mat[2].a[2][1]=mat[2].a[2][2]=1LL;
    mat[3].a[0][0]=mat[3].a[1][1]=mat[3].a[2][2]=1LL;
    tmp.a[0][0]=tmp.a[0][1]=tmp.a[0][2]=1;
    for(int i=1;i<=(n<<2);i++) tree[i]=mat[3];
    for(int i=1;i<=n;i++) {
        scanf("%d",&op[i]);
        if(op[i]<=2) change(1,n,1,i,op[i]);
        else {
            scanf("%d",&x[i]);
            if(op[x[i]]==3) x[i]=x[x[i]];
            if(cancel[x[i]]) change(1,n,1,x[i],op[x[i]]);
            else change(1,n,1,x[i],3);
            cancel[x[i]]=!cancel[x[i]];
        }
        printf("%lld\n",(tmp*tree[1]).a[0][0]);
    }
    system("pause");
    return 0;
}
```

---

## 作者：gan_ge (赞：1)

一个抽象的做法。

一些性质：  
1. 我们任意时刻得到的括号序列必然形如 $((\dots)\dots)\dots$，且 $\dots$ 必为 $()()()\dots$；即不会出现形如 $(\dots)(\dots)(\dots)$ 的括号序列；
2. 对于一段形如 $(({\color{orange} \dots}) {\color{red} \dots})\dots$ 的序列，对于红色这段的括号，它不会对黄色或黑色两段产生贡献，若红色这段有 $n$ 个 $()$，则其贡献为 $(n+1)\times(n+2)\div2$。

由这两个性质可知，我们只需要维护每两个后括号之间有多少个 $()$，直接给每个上述区间标号开桶。

此时我们就有了数个带权的点。

但由于有撤销，会让我们出现合并和分离操作，使得之前的点形成数个不交的区间，发现与珂朵莉树的维护极为相似，所以我们用 `set` 维护每个区间，朴素地进行修改即可。

这时由于区间已被合并，我们要用区间的总和统计贡献，可以采用树状数组或线段树。

对于每个操作就如下处理：  
+ 操作一：给当前最后一个桶 $+1$；
+ 操作二：建一个新桶；
+ 撤销操作一：给相应的桶 $-1$；
+ 撤销操作二：合并两桶;
+ 撤销对操作一的撤销：给相应的桶 $+1$；
+ 撤销对操作二的撤销：分裂两桶。

修改时把原贡献减去，再加上新贡献即可得到答案。

复杂度 $O(n\log(n))$，可以通过本题。

注意：慎重使用 `set<pair<int,int> >` 极容易找错区间。

附代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

const int N=2e5+10;

namespace tools{
    class BIT{
        private: int tr[N],len;
        public:
            inline int lowbit(const int &x){return x&-x;}
            inline void init(const int &x){ len=x;}
            inline void add(int x,int val){
                for(;x<=len;x+=lowbit(x)) tr[x]+=val;
            }
            inline int query(int x){
                int res=0;
                for(;x;x-=lowbit(x)) res+=tr[x];
                return res;
            }
    };
}

tools::BIT bit;

struct change{
    int opt,x,y;    //opt=1:x处+-,opt=2:分裂x,y,opt=3:合并x,y
}p[N];

struct node{
    int l,r;
    bool operator < (const node &t) const{
        return r<t.r;
    }
};


int n,now=1;

ll ans=1;

set<node> st;

int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n; bit.init(n);
    st.insert({now,now});
    for(int i=1,opt,x;i<=n;i++){
        cin>>opt;
        if(opt==1){
            auto it=st.rbegin();
            int l=(*it).l,r=(*it).r;
            int sum=bit.query(r)-bit.query(l-1);
            ans-=1ll*(sum+1)*(sum+2)/2;
            sum++;
            bit.add(now,1);
            p[i]={1,now,1};
            ans+=1ll*(sum+1)*(sum+2)/2;
        }
        else if(opt==2){
            now++,ans++;
            st.insert({now,now});
            p[i]={2,now-1,now};
        }
        else{
            cin>>x;
            change nd=p[x];
            if(nd.opt==1){
                auto it=st.lower_bound({nd.x,nd.x});
                int l=(*it).l,r=(*it).r;
                int sum=bit.query(r)-bit.query(l-1);
                ans-=1ll*(sum+1)*(sum+2)/2;
                sum-=nd.y;
                bit.add(nd.x,-nd.y);
                p[i]={1,nd.x,-nd.y};
                ans+=1ll*(sum+1)*(sum+2)/2;
            }
            else if(nd.opt==2){
                auto itl=st.lower_bound({nd.x,nd.x}),itr=st.lower_bound({nd.y,nd.y});
                int ll=(*itl).l,lr=(*itl).r;
                int rl=(*itr).l,rr=(*itr).r;
                int suml=bit.query(lr)-bit.query(ll-1),sumr=bit.query(rr)-bit.query(rl-1);
                ans-=1ll*(suml+1)*(suml+2)/2,ans-=1ll*(sumr+1)*(sumr+2)/2;
                st.erase(itl),st.erase(itr);
                st.insert({ll,rr});
                ans+=1ll*(suml+sumr+1)*(suml+sumr+2)/2;
                p[i]={3,nd.x,nd.y};
            }
            else{
                auto it=st.lower_bound({nd.x,nd.x});
                int l=(*it).l,r=(*it).r;
                int sum=bit.query(r)-bit.query(l-1);
                ans-=1ll*(sum+1)*(sum+2)/2;
                st.erase(it);
                st.insert({l,nd.x}),st.insert({nd.y,r});
                int suml=bit.query(nd.x)-bit.query(l-1),sumr=bit.query(r)-bit.query(nd.y-1);
                ans+=1ll*(suml+1)*(suml+2)/2,ans+=1ll*(sumr+1)*(sumr+2)/2;
                p[i]={2,nd.x,nd.y};
            }
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：dami826 (赞：1)

无矩阵做法，仅需线段树即可。

注意到题目中的括号序列能够等价为树，操作 1 就是给当前根节点加一个儿子，操作 2 就是给当前根节点加一个父亲并使其成为新根节点。不难注意到这样操作得到的树一定是形如一条链上挂着许多叶子的“鱼骨形”的东西。

那么在这个树形态下答案是什么呢？不难发现匹配的子段一定是树上相邻的几个兄弟。这个数量是好求的，设 $i$ 号点有 $s_i$ 个儿子，答案就是 $\sum s_i \cdot (s_i+1)= \sum s_i^2+s_i$。

考虑直接用线段树维护每个非叶子节点的儿子数量之和（代码中的 `sum`）以及儿子数量的平方和（代码中的 `sum2`），操作 1 是单点修改，操作 2 则是在线段树末尾新建一个值为 $1$ 的节点。

此时已经可以通过 Subtask 4，考虑操作 3。

不难注意到操作 3 其实只会撤销或恢复一个操作 1 和操作 2。操作 1 是简单的单点修改，此处不再赘述。考虑撤销一个操作 2，其实就是将这个点删除，同时将这个点上的所有连边都连向它的非叶子儿子，即线段树上它的前驱。（也可以理解为合并两个节点）我们维护每个节点在**不考虑合并的情况下**的儿子数量（代码中的 `val`）、此时被合并到的节点编号（代码中的 `fa`）、最远合并进每个点来的点编号（代码中的 `maxn`），此时每一次 3 操作都可以转化为若干次区修，具体请见代码。

特别提醒：父亲的儿子数量是包括非叶子儿子的，在向非叶子儿子合并以及分离时记得 $+1$ 或 $-1$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define OK puts("OK");
using namespace std;
int n,cnt,fa[200010];
struct opt{
	int op,x,pre;
	bool type;
}s[200010];
struct node{
	int sum,sum2,fa,lazyfa,val,maxn,lazymx;
};
struct segment_tree{
	node tree[800010];
	void pushup(int index){
		tree[index].sum=tree[index<<1].sum+tree[index<<1|1].sum;
		tree[index].sum2=tree[index<<1].sum2+tree[index<<1|1].sum2;
		tree[index].val=tree[index<<1].val+tree[index<<1|1].val;
	}
	void pushdown(int index){
		if(tree[index].lazyfa){
			tree[index<<1].fa=tree[index<<1].lazyfa=tree[index<<1|1].fa=tree[index<<1|1].lazyfa=tree[index].lazyfa;
			tree[index].lazyfa=0;
		}
		if(tree[index].lazymx){
			tree[index<<1].maxn=tree[index<<1].lazymx=tree[index<<1|1].maxn=tree[index<<1|1].lazymx=tree[index].lazymx;
			tree[index].lazymx=0;
		}
	}
	void update(int g,int x,int left,int right,int index){
		if(g<left||right<g){
			return;
		}
		if(left==right){
			tree[index].sum+=x;
			tree[index].sum2=tree[index].sum*tree[index].sum;
			return;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		update(g,x,left,mid,index<<1);
		update(g,x,mid+1,right,index<<1|1);
		pushup(index);
	}
	void updatefa(int gleft,int gright,int x,int left,int right,int index){
		if(gright<left||right<gleft){
			return;
		}
		if(gleft<=left&&right<=gright){
			tree[index].fa=x;
			tree[index].lazyfa=x;
			return;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		updatefa(gleft,gright,x,left,mid,index<<1);
		updatefa(gleft,gright,x,mid+1,right,index<<1|1);
		pushup(index);
	}
	void updatemx(int gleft,int gright,int x,int left,int right,int index){
		if(gright<left||right<gleft){
			return;
		}
		if(gleft<=left&&right<=gright){
			tree[index].maxn=x;
			tree[index].lazymx=x;
			return;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		updatemx(gleft,gright,x,left,mid,index<<1);
		updatemx(gleft,gright,x,mid+1,right,index<<1|1);
		pushup(index);
	}
	void updatev(int g,int x,int left,int right,int index){
		if(g<left||right<g){
			return;
		}
		if(left==right){
			tree[index].val+=x;
			return;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		updatev(g,x,left,mid,index<<1);
		updatev(g,x,mid+1,right,index<<1|1);
		pushup(index);
	}
	int search(int g,int left,int right,int index){
		if(g<left||right<g){
			return 0;
		}
		if(left==right){
			return tree[index].sum;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		return search(g,left,mid,index<<1)+search(g,mid+1,right,index<<1|1);
	}
	int searchfa(int g,int left,int right,int index){
		if(g<left||right<g){
			return 0;
		}
		if(left==right){
			return tree[index].fa;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		return searchfa(g,left,mid,index<<1)+searchfa(g,mid+1,right,index<<1|1);
	}
	int searchmx(int g,int left,int right,int index){
		if(g<left||right<g){
			return 0;
		}
		if(left==right){
			return tree[index].maxn;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		return searchmx(g,left,mid,index<<1)+searchmx(g,mid+1,right,index<<1|1);
	}
	int searchv(int gleft,int gright,int left,int right,int index){
		if(gright<left||right<gleft){
			return 0;
		}
		if(gleft<=left&&right<=gright){
			return tree[index].val;
		}
		int mid=(left+right)>>1;
		pushdown(index);
		return searchv(gleft,gright,left,mid,index<<1)+searchv(gleft,gright,mid+1,right,index<<1|1);
	}
}tr;
int find(int x){
	fa[x]=tr.searchfa(x,1,n+1,1);
	if(fa[x]==x){
		return x;
	}
	fa[x]=find(fa[x]);
	return fa[x];
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n*4;i++){
		tr.tree[i]={0,0,0,0,0};
	}
	tr.update(1,1,1,n+1,1);
	cnt++;
	fa[1]=1;
	tr.updatefa(1,1,1,1,n+1,1);
	tr.updatev(1,1,1,n+1,1);
	tr.updatemx(1,1,1,1,n+1,1);
	for(int i=1;i<=n;i++){
		scanf("%lld",&s[i].op);
		if(s[i].op==1){
			int fx=find(cnt);
			tr.update(fx,1,1,n+1,1);
			tr.updatev(cnt,1,1,n+1,1);
			s[i].x=cnt;
		}
		else{
			if(s[i].op==2){
				cnt++;
				tr.update(cnt,1,1,n+1,1);
				fa[cnt]=cnt;
				tr.updatemx(cnt,cnt,cnt,1,n+1,1);
				tr.updatefa(cnt,cnt,cnt,1,n+1,1);
				tr.updatev(cnt,1,1,n+1,1);
				s[i].x=cnt;
			}
			else{
				int u;
				scanf("%lld",&u);
				if(s[u].op==3){
					s[i].type=!s[u].type;
					u=s[u].pre;
				}
				else{
					s[i].type=0;
				}
				s[i].pre=u;
				s[i].x=s[u].x;
				if(s[u].op==1){
					if(s[i].type==0){
						tr.updatev(s[i].x,-1,1,n+1,1);
						int fx=find(s[i].x);
						tr.update(fx,-1,1,n+1,1);
					}
					else{
						tr.updatev(s[i].x,1,1,n+1,1);
						int fx=find(s[i].x);
						tr.update(fx,1,1,n+1,1);
					}
				}
				else{
					if(s[i].type==0){
						fa[s[i].x]=find(s[i].x-1);
						tr.updatefa(s[i].x,s[i].x,fa[s[i].x],1,n+1,1);
						int mxt=tr.searchmx(s[i].x,1,n+1,1);
						tr.updatemx(fa[s[i].x],s[i].x-1,mxt,1,n+1,1);
						int tmp=tr.search(s[i].x,1,n+1,1);
						tr.update(fa[s[i].x],tmp-1,1,n+1,1);
						tr.update(s[i].x,-tmp,1,n+1,1);
					}
					else{
						int fx=find(s[i].x);
						fa[s[i].x]=s[i].x;
						int mxt=tr.searchmx(fx,1,n+1,1);
						tr.updatefa(s[i].x,mxt,s[i].x,1,n+1,1);
						tr.updatemx(fx,s[i].x-1,s[i].x-1,1,n+1,1);
						int tmp=tr.searchv(fx,s[i].x-1,1,n+1,1)-tr.search(fx,1,n+1,1)-(s[i].x-fx-1);
						tr.update(fx,tmp,1,n+1,1);
						tr.update(s[i].x,-tmp+1,1,n+1,1);
					}
				}
			}
		}
		printf("%lld\n",(tr.tree[1].sum+tr.tree[1].sum2)/2);
	}
	return 0;
}
```

---

## 作者：toolong114514 (赞：1)

## 解题思路
首先考虑无修改的情况。

记答案为 $ans$。

不难看出，对于某次 $2$ 操作，只会让答案 $+1$，即 $ans\to ans+1$。对于此后紧跟的若干次 $2$ 操作，其造成的贡献与这个 $1$ 操作之前的部分无关。
::::info[证明]
对于一个括号序列 $(S)$，如果尝试取出一段包含左端点或右端点的子串，且不是它本身，一定会有 “$($” 或 “$)$”剩余（来自最外层的那对括号）。
::::
也就是说，我们可以根据操作 $2$ 对整个操作序列进行分层，每层的最左端为操作 $2$ 生成的括号序列 $(S)$。

不妨定义 $cnt$ 为当前层（也是最外层）中的“$()$”个数（忽略左端 $(S)$ 内的 $S$，理由同上）。

对于一次操作 $2$ 显然有 $cnt\to 1$。

对于一个操作 $1$，以其增加的“$()$”为美丽子串右部，显然只有前面的 $cnt$ 个端点可以搭配，再加上它本身。同时，当前层中的“$()$”个数也增加了 $1$。

形式化的表示为：$ans\to ans+cnt+1,cnt\to cnt+1$。

据此编写代码，可以通过 subtask 4。

接下来考虑有修改的情况。

对于一次操作 $3$，其本质为撤销或恢复序列中某个操作 $1$ 或 $2$。下一次是撤销还是恢复可以在每次操作 $3$ 后改标记。
### Solution 1
注意到两种操作均可用矩阵表达。

我们在更新中需要用到 $ans$ 和 $cnt$ 互相转化，所以矩阵一定含这两个元素，且在同一行。

但是只有这两项没法构造出 $+1$，可以在同一行补上一个元素 $1$ 解决这个问题。

那么初始矩阵为 $\begin{bmatrix}ans&cnt&1\end{bmatrix}$。

我们记操作 $1$ 的变化矩阵为 $X_1$，那么有：
$$\begin{bmatrix}ans&cnt&1\end{bmatrix}\times X_1=\begin{bmatrix}ans+cnt+1&cnt+1&1\end{bmatrix}$$

解得 $X_1=\begin{bmatrix}1&0&0\\1&1&0\\1&1&1\end{bmatrix}$，恰好是一个下三角矩阵。

我们记操作 $2$ 的变化矩阵为 $X_2$，那么有：
$$\begin{bmatrix}ans&cnt&1\end{bmatrix}\times X_2=\begin{bmatrix}ans+1&1&1\end{bmatrix}$$

解得 $X_2=\begin{bmatrix}1&0&0\\0&0&0\\1&1&1\end{bmatrix}$。

对于当前操作序列中（默认长为 $n$）暂无变化的地方，可以用 $3\times3$ 的[单位矩阵](https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5/8540268)填满。

那么对于操作 $3$，就是把操作序列中对应位置的变化矩阵修改成 $X_1$、$X_2$ 或 $3\times3$ 的单位矩阵。

每次操作完，将初始矩阵与整个操作序列的矩阵表示的乘积相乘，就可以得出当前美丽子串数目。

用线段树维护矩阵乘积，支持单点修改和全局查询是容易的。

时间复杂度 $O(3^3\cdot n\log{n})$，$3^3$ 为矩阵乘法的常数。
### Solution 2
对于（恢复）进行或撤销操作 $1$，不会改变操作序列的分层，只会在同一层产生对美丽子串数的影响。

对于（恢复）进行或撤销操作 $2$，相当于分解一层或合并两层，只会对跨越操作 $2$ 所在位置的美丽子串产生影响。

可以用线段树维护分层的相关信息。

时间复杂度应该是 $O(n\log{n})$。

~~但是我比赛时用这个思路没有调出来~~。
## 参考代码
是 Solution 1 的代码。

Solution 2 的代码以后再补。
```cpp
#include<iostream>
using namespace std;
const int N=3e5+10;
#define ll long long
struct ccf{
	int r,c;
	ll cont[4][4];
	friend ccf operator*(ccf a,ccf b){
		ccf res;
		res.r=a.r,res.c=b.c;
		for(int i=1;i<=res.r;i++){
			for(int j=1;j<=res.c;j++){
				res.cont[i][j]=0;
				for(int k=1;k<=a.c;k++){
					res.cont[i][j]+=a.cont[i][k]*b.cont[k][j];
				}
			}
		}
		return res;
	}
}mrx_const,op1,op2,sta;
struct node{
	int l,r;
	ccf fac;
}tree[4*N];
void push_up(int pos){
	tree[pos].fac=tree[pos*2].fac*tree[pos*2+1].fac;
}
void build(int pos,int lft,int rgt){
	tree[pos].l=lft;
	tree[pos].r=rgt;
	tree[pos].fac=mrx_const;
	if(lft==rgt) return;
	int mid=(lft+rgt)/2;
	build(pos*2,lft,mid);
	build(pos*2+1,mid+1,rgt);
}
void upd(int pos,int dot,ccf x){
	if(tree[pos].r<dot||dot<tree[pos].l) return;
	if(tree[pos].l==tree[pos].r){
		tree[pos].fac=x;
		return;
	}
	upd(pos*2,dot,x);
	upd(pos*2+1,dot,x);
	push_up(pos);
}
int n;
struct zyh{
	int op,xx;
}lqr[N];
bool vst[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	mrx_const.r=mrx_const.c=op1.r=op1.c=op2.r=op2.c=sta.c=3;
	sta.r=1;
	mrx_const.cont[1][1]=mrx_const.cont[2][2]=mrx_const.cont[3][3]=1;
	op1.cont[1][1]=op1.cont[2][1]=op1.cont[3][1]=op1.cont[2][2]=op1.cont[3][2]=op1.cont[3][3]=1;
	op2.cont[1][1]=op2.cont[3][1]=op2.cont[3][2]=op2.cont[3][3]=1;
	sta.cont[1][1]=sta.cont[1][2]=sta.cont[1][3]=1;
	cin>>n;
	build(1,1,n);
	for(int i=1;i<=n;i++){
		cin>>lqr[i].op;
		if(lqr[i].op==3){
			cin>>lqr[i].xx;
			if(lqr[lqr[i].xx].op==3) lqr[i].xx=lqr[lqr[i].xx].xx;
		}
	}
	for(int i=1;i<=n;i++){
		if(lqr[i].op==1) upd(1,i,op1);
		else if(lqr[i].op==2) upd(1,i,op2);
		else{
			if(lqr[lqr[i].xx].op==1){
				if(!vst[lqr[i].xx]) upd(1,lqr[i].xx,mrx_const);
				else upd(1,lqr[i].xx,op1);
			}else{
				if(!vst[lqr[i].xx]) upd(1,lqr[i].xx,mrx_const);
				else upd(1,lqr[i].xx,op2);
			}
			vst[lqr[i].xx]=!vst[lqr[i].xx];
		}
		cout<<(sta*tree[1].fac).cont[1][1]<<'\n'; 
	}
	return 0;
}
```
[本代码可以通过洛谷评测](https://www.luogu.com.cn/record/228977041)

Written by [toolong114514](/user/477821) on 2025/8/5.

---

## 作者：P2441M (赞：1)

## 题意

有一个括号串 $S$，初始时 $S=\texttt{()}$。有 $n$ 个操作：

1. 在 $S$ 的末尾添加一对括号。
2. 在 $S$ 的最外面添加一对括号。
3. 撤销第 $x$ 个操作。

每次操作后求 $S$ 中能括号匹配非空子串个数。$1\leq n\leq 2\times 10^5$。

## 题解

简单题。模拟赛考了，可惜没调出来。

先考察执行操作 $1$ 后答案的变化，设括号串中的极长合法括号串的段数为 $cnt$，则此时会令 $ans\leftarrow ans+cnt+1$，$cnt\leftarrow cnt+1$。再来考察操作 $2$，不难发现此时 $ans\leftarrow ans+1$，$cnt\leftarrow 1$。于是这样我们就能 $\mathcal{O}(n)$ 地完成没有操作 $3$ 的 $\text{Subtask}$ 了。

考虑操作 $3$ 的影响。设编号为 $x$ 的操作 $3$ 所撤销的操作编号为 $p_x$，我们不断令 $x\leftarrow p_x$ 直到 $x$ 号操作不是撤销操作，把这个 $x$ 记作 $pre_x$。那么原操作的实际影响就是改变 $pre_x$ 号操作的状态，也即从不执行变成执行，从执行变成不执行。这样我们就有了 $\mathcal{O}(n^2)$ 的做法：从左到右扫，对每个非撤销操作记录其状态，每次扫到一个撤销操作 $x$ 后更改 $pre_x$ 的状态，然后暴力从头开始重新计算即可。$pre_x$ 可以简单递推得出。

考虑优化。我们发现我们需要维护好二元组 $(ans,cnt)$，不难发现操作 $1,2$ 都是对这个二元组进行的线性变换。由于有 $+1$，我们将状态扩充为三元组 $(ans,cnt,1)$，容易得到操作 $1,2$ 对应的转移矩阵：

$$
\begin{align*}
\begin{bmatrix}
ans & cnt & 1
\end{bmatrix}\times
\begin{bmatrix}
1 & 0 & 0\\
1 & 1 & 0\\
1 & 1 & 1
\end{bmatrix}&=
\begin{bmatrix}
ans+cnt+1 & cnt+1 & 1
\end{bmatrix}\\
\begin{bmatrix}
ans & cnt & 1
\end{bmatrix}\times
\begin{bmatrix}
1 & 0 & 0\\
0 & 0 & 0\\
1 & 1 & 1
\end{bmatrix}&=
\begin{bmatrix}
ans+1 & 1 & 1
\end{bmatrix}
\end{align*}
$$

于是不难想到用线段树维护矩阵乘积，每次变换状态时从转移矩阵变为单位矩阵，或从单位矩阵变为转移矩阵即可。时间复杂度 $\mathcal{O}(C^3n\log{n})$，其中 $C=3$。

---

## 作者：sinestrea (赞：1)

### 前言

提供一种思维和写法都很暴力的分块做法。

### 题目分析

显然我们可以得出两个结论：

- 操作 $2$ 对于答案的贡献为 $1$。
- 操作 $1$ 对于答案的贡献为上一个操作 $2$ 到当前位置的操作个数。

### 转换

因为刚开始我们有一对括号，我们可以理解成首位为一个 $2$ 操作。

我们定义从操作 $2$ 到下一个操作 $2$ 的**前一个位置**，这样一段区间，称之为“连续区间”，对于一个连续区间的答案，就是 $1 + 2 + 3 + \dots + len$。

例（连续的相同颜色的一段表示一段“连续区间”）：

第一段的价值为 $15$，第二段为 $6$，第三段为 $1$，那么这个区间的价值就是 $15 + 6 + 1 = 22$。

![](https://z1.ax1x.com/2023/11/08/pi1bzW9.png)

我们可以维护一个数组 $\operatorname{save}$，$\operatorname{save}(i) = \operatorname{save}(i - 1) + i$，方便求一段连续区间的答案。

对于操作 $3$，我们可以新建一个数组，来标记当前操作是否存在，前两个操作可以直接将当前位置存在信息修改为 $1$，操作 $3$ 则是找到目标位置，更新目标位置是否存在的信息，可以参考并查集路径压缩。

注意：操作 $3$ 的存在信息始终为 $0$，因为操作 $3$ 和我们统计答案无关。

### 题解

有了前面的思路，我们可以很容易求出一个区间的值。

对于操作 $1$ 和操作 $2$ 我们可以直接修改整块。

对于操作 $3$ 我们可以查询之后修改整块。

对于每次操作之后输出所有块合并的贡献。

我们将操作区间分块，每块存的信息如下：操作 $1$ 数量的前缀（$\operatorname{pre}$），操作 $1$ 数量的后缀（$\operatorname{suc}$），区间存在的操作数量（$\operatorname{size}$），区间去掉首半段和尾段的贡献（$\operatorname{val}$）。

黄色部分表示前缀，绿色部分表示后缀，红色部分表示区间去掉首半段和尾段的贡献。
![](https://z1.ax1x.com/2023/11/08/pi1qWOx.png)

我们该如何求两块合并呢？

- 注意我们每一块所拥有的信息：$\operatorname{pre}$，$\operatorname{suf}$，$\operatorname{size}$，$\operatorname{val}$，我们可以开一个变量 $\operatorname{cnt}$ 来维护距离上一个操作 $2$ 有多少个操作 $1$，开一个变量 $\operatorname{ans}$ 来记录答案；

- 若 $\operatorname{pre} = \operatorname{size}$，说明这一块全是操作 $1$，将 $\operatorname{cnt} = \operatorname{cnt} + \operatorname{size}$；

- 否则说明这个区间存在操作 $2$，那么将 $\operatorname{cnt}$ 增加 $\operatorname{pre}$，那么 $\operatorname{ans} = \operatorname{ans} + \operatorname{save}(cnt) + \operatorname{val}$，将 $\operatorname{cnt}$ 设为 $\operatorname{suf}$；

- 在最后 $\operatorname{ans} = \operatorname{ans} + \operatorname{save}(cnt)$。

对于每次操作，每个块长度是 $\sqrt{n}$，单次修改时间复杂度是 $\sqrt{n}$，一共有 $\sqrt{n}$ 块，查询时间复杂度也是 $\sqrt{n}$，总的时间复杂度就是 $n \sqrt{n}$。

因为修改的常数大于查询的常数，所以可以将块长调小。

那么对于前三个操作：
```cpp
if (opt[i] == 1) exist[i] = 1, update(i); 
if (opt[i] == 2) exist[i] = 1, update(i);
//若操作为1或2，将当前点设为存在，更新当前点所在块
if (opt[i] == 3) {
    cin >> change[i];
    change[i] = find(change[i]);
    exist[change[i]] ^= 1;
    update(change[i]);
}
若操作为3，将指向的点（祖先）更改存在信息，更新指向的点（祖先）所在的块
```
操作 $3$ 的查找代码：

```cpp
int find(int loc) {
    if (change[loc] == 0) return loc; 
    //若当前点没有往前找的点了，就返回当前下标
    else return change[loc] = find(change[loc]); 
    //否则往前找，参考并查集（路径压缩）
}
```

每次修改一个点更改整块的代码：

```cpp
void update(int loc) {
    node *item = &lazy[belong[loc]];
    //设置一个元素指向当前块
    int l = item -> l, r = item -> r;
    int cnt{}, first{}, end{};
    //first维护记录第一个2出现的位置，end记录最后一个2出现的位置

    item -> pre = item -> suf = item -> val = item -> size = 0;
    //初始化

    for (int i = l; i <= r; i++) {
        if (!exist[i]) continue;
        //若当前点不存在则跳过

        if (first == 0 && opt[i] == 2) first = i;
        //若没出现过2，当前点为2，则当前点为第一个2出现的位置
        if (opt[i] == 2) end = i, item -> suf = 0;
			//更新end，将suf重设为0
        if (first == 0 && opt[i] == 1) item -> pre++;
        //记录前缀1
        if (opt[i] == 1) item -> suf++;
        //记录后缀1
        item -> size++;
    }
    if (first == 0) item -> pre = item -> suf = item -> size;//特判未出现2的情况
    else {
        for (int i = first; i <= end; i++) {
            if (!exist[i]) continue;
            if (opt[i] == 1) cnt++;
            else item -> val += save[cnt], cnt = 1;
        }
        //记录删掉前半段和最后一段的答案
    }
}
```
查询所有块的贡献的代码：

```cpp
long long calc() {
    int cnt = 1;//初始为1，则开始有一个2操作
    long long ret{};
    for (int i = 1; i <= blockNum; i++) {
        cnt += lazy[i].pre;//加上前缀
        if (lazy[i].pre == lazy[i].size) continue;//若不存在2，跳过
        //下面为存在2操作：
        ret += save[cnt] + lazy[i].val;
        //计入答案
        cnt = lazy[i].suf + 1;
        //将cnt设成后缀 + 1，即211111...
    }
    ret += save[cnt];//最后更新
    return ret;
}
```

### 代码

```cpp
#include <bits/stdc++.h>

class cin {
public:
    cin operator>>(int &num) {
        num = 0;
        char c = getchar();
        long long f = 1;
        while (c < '0' || c > '9') {
            if (c == '-') f = -1;
            c = getchar();
        }
        while (c >= '0' && c <= '9') {
            num = num * 10 + (c ^ '0');
            c = getchar();
        }
        num *= f;
        return *this;
    }
} cin{};

class cout {
public:
    cout operator<<(long long num) {
        if (num < 0) {
            putchar('-');
            num = -num;
        }
        if (num >= 10) (*this) << (num / 10);
        putchar(num % 10 ^ '0');
        return *this;
    }

    cout operator<<(char c) {
        putchar(c);
        return *this;
    }
} cout{};

const int MAX = 2e5 + 5, MAX_BLOCK_LEN = 1000;

class node {
public:
    long long pre{}, suf{}, val{};
    int size{}, l{}, r{};
} lazy[MAX_BLOCK_LEN]{};

int n{}, x{};
long long save[MAX]{};
int opt[MAX]{}, change[MAX]{}, belong[MAX]{}, blockLen{}, blockNum{};
bool exist[MAX]{};

void init() {
    blockLen = 300;
    blockNum = n / blockLen;
    if (n % blockLen) blockNum++;
    for (int i = 1; i <= n; i++) save[i] += save[i - 1] + i, belong[i] = (i - 1) / blockLen + 1;
    for (int i = 1; i <= blockNum; i++) lazy[i].l = (i - 1) * blockLen + 1, lazy[i].r = i * blockLen;
    lazy[blockNum].r = n;
}

int find(int loc) {
    if (change[loc] == 0) return loc;
    else return change[loc] = find(change[loc]);
}

void update(int loc) {
    node *item = &lazy[belong[loc]];
    int l = item -> l, r = item -> r;
    int cnt{}, first{}, end{};

    item -> pre = item -> suf = item -> val = item -> size = 0;

    for (int i = l; i <= r; i++) {
        if (!exist[i]) continue;

        if (first == 0 && opt[i] == 2) first = i;
        if (opt[i] == 2) end = i, item -> suf = 0;

        if (first == 0 && opt[i] == 1) item -> pre++;
        if (opt[i] == 1) item -> suf++;
		item -> size++;
    }
    if (first == 0) item -> pre = item -> suf = item -> size;
    else {
        for (int i = first; i <= end; i++) {
            if (!exist[i]) continue;
            if (opt[i] == 1) cnt++;
            else item -> val += save[cnt], cnt = 1;
        }
    }
}

long long calc() {
    int cnt = 1;
    long long ret{};
    for (int i = 1; i <= blockNum; i++) {
        cnt += lazy[i].pre;
        if (lazy[i].pre == lazy[i].size) continue;
        ret += save[cnt] + lazy[i].val;
        cnt = lazy[i].suf + 1;
    }
    ret += save[cnt];
    return ret;
}

signed main() {
    cin >> n;
    init();
    for (int i = 1; i <= n; i++) {
        cin >> opt[i];
        if (opt[i] == 1) exist[i] = 1, update(i);
        if (opt[i] == 2) exist[i] = 1, update(i);
        if (opt[i] == 3) {
            cin >> change[i];
            change[i] = find(change[i]);
            exist[change[i]] ^= 1;
            update(change[i]);
        }
        cout << calc() << '\n';
    }
}
```

---

## 作者：Lamb_Carp (赞：1)

## advertisement

这位靓仔，你都来看我题解了，为什么不来[我的博客]( https://www.cnblogs.com/carp-oier/p/P6864.html)看看呢。

## prologue

今天模拟赛 T3，一道很好的题目。

## analysis

对于这个题目我们可以通过对操作的手玩，得出一个结论。

记 $ans$ 为当前所有的合法子串数量，记 $tmp$ 为当前以最后以一个括号结尾的子串个数。可以推出来前两个操作分别的转移式子：

$$ans \gets ans + tmp + 1,p \gets p + 1$$
$$ans \gets ans + 1, p \gets 1$$

感觉这个证明起来其实很显然，~~读者自证不难~~简单证明一下：

1. 如果是操作 1，我们在最后面加上一个合法的匹配括号，就相当于是在继承了父亲（上一个状态）的条件下，又多了一对括号。所以得出来第一个式子。

2. 如果是操作2，我们在当前的串加上一个最外层的括号。这相当于是自断一臂，因为我们此时再去统计以最后一个括号为结尾的子串，就只有前面这一坨了（傻鱼的量词是跟初中历史老师学的），我们最后的 $ans$ 也就仅仅只是加上了前面这一整串这个答案，所以推出来第二个式子。（其实你可以看成二号操作是对前面的串进行了整个的封装。）

然后我们开始考虑怎么去维护上面两个操作。

我们上面的式子是非常具有矩阵转移的性质的，即我们可以构造这样一个 $\begin{bmatrix}ans, tmp, 1\end{bmatrix}$ 的答案矩阵，那么我们上面两个操作的矩阵也就可以构造出来了：

1. 操作一的转移矩阵：$\begin{bmatrix}1 & 0 & 0 \\ 1 & 1 & 0 \\ 1 & 1 & 1\end{bmatrix}$

2. 操作二的转移矩阵：$\begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 0 \\ 1 & 1 & 1\end{bmatrix}$

但是我们不可能对于每一次操作都 $O(n)$ 扫一遍，而且还有单点修改，还要滚回去撤销操作，所以我们再考虑：

我们知道矩阵乘法是具有结合律的，即 $A_1 A_2 A_3 = A_1(A_2 A_3)$ 所以我们的答案矩阵只需要左乘一次后面整体矩阵的乘积就好了。

我们就可以用线段树来进行这个单点修改，区间查询（查询后面所有操作的乘积）的操作。（单位矩阵对于矩阵乘法没有贡献所以我们就可以那这个当作我们的初始值了。）

我们上面两个操作的思路就呼之欲出了，再考虑我们的撤销操作。

我们通过分析样例可以知道，我们的撤销操作是可以撤销之前的撤销操作的。所以我们对于一个地方的修改不可能是真的就给撤销没了，我们就可以考虑每个操作节点维护两个矩阵，一个单位矩阵 $B$ 一个贡献矩阵 $A$ 每次撤销操作就是 $swap(A, B)$ 的过程。

而对于这个撤销**撤销操作**不就是找到自己的爹的爹么，可以用并查集来维护。（这里加粗是为了方便断句）

分析至此，接下来就是我们的代码实现了。

## code time

火车头自跳。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rl register ll
#define fom(i, a) for(rl i=a; i; -- i)
#define foa(i, a, b) for(rl i=a; i < b; ++ i)
#define fos(i, a, b) for(rl i=a; i <= b; ++ i)
#define fop(i, a, b) for(rl i=a; i >= b; -- i)
namespace IO
{
    int pp1=-1; const int pp2=(1<<21)-1; char buf[1<<21],*p1=buf,*p2=buf,buffer[1<<21];
    inline void flush() {fwrite(buffer,1,pp1+1,stdout); pp1=-1;}
    inline void pc(const char ch) {if(pp1==pp2) flush(); buffer[++pp1]=ch;}
    inline char gc(){ return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    template <class T> inline void read(T &res){char ch=gc();bool f=0;res=0; for(;!isdigit(ch);ch=gc()) f|=ch=='-'; for(;isdigit(ch);ch=gc()) res=(res<<1)+(res<<3)+(ch^48); res=f?~res+1:res;}
    template <class T> inline void ww(T x) { if(!x) pc('0'); else { static int stk[21]; int top = 0; if(x<0) pc('-'),x=~x+1; while(x) stk[top++]=x%10, x/=10; while(top--) pc(stk[top]^48);}}
}

#define wp IO::pc(' ')
#define wl IO::pc('\n')
#define ww(x) IO::ww(x)
#define read(x) IO::read(x)
#define flush() IO::flush()

constexpr ll N  = 2e5 + 10;

ll n, p[N];

struct Matrix
{
    ll a[4][4];

    Matrix () { memset(a, 0, sizeof a);} 

    inline void make_I() { fos(i, 1, 3) a[i][i] = 1; }

    inline void init() { fos(i, 1, 3) a[1][i] = 1; }

    Matrix operator *(const Matrix &x) const
    {
        Matrix res;

        fos(i, 1, 3) fos(k, 1, 3) fos(j, 1, 3)  
            res.a[i][j] += a[i][k] * x.a[k][j];

        return res; 
    }

    inline void print()
    {
        fos(i, 1, 3)
        {
            fos(j, 1, 3) ww(a[i][j]), wp;

            wl;
        }
    }
} I, Op1, Op2, ans;

struct tree
{
    ll l, r;
    Matrix A, B;
} tr[N << 2];

inline ll find(ll x) { return p[x] == x ? x : p[x] = find(p[x]); }

inline void pushup(ll u) { tr[u].A = tr[u << 1].A * tr[u << 1 | 1].A; }

inline void build(ll u, ll l, ll r)
{
    tr[u] = {l, r, I, I}; 

    if(l == r) return ;
    
    ll mid = l + r >> 1;

    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

inline void update(ll u, ll x, ll op)
{
    if(tr[u].l == tr[u].r && tr[u].l == x)
    {
        if(op == 1) tr[u].A = Op1;
        if(op == 2) tr[u].A = Op2;
        return ;
    }

    ll mid = tr[u].l + tr[u].r >> 1;

    if(x <= mid) update(u << 1, x, op);
    if(x > mid) update(u << 1 | 1, x, op);

    pushup(u);
}

inline void remove(ll u, ll x)
{
    if(tr[u].l == x && tr[u].r == x)
    {
        swap(tr[u].A, tr[u].B);
        return;
    }

    ll mid = tr[u].l + tr[u].r >> 1;

    if(x <= mid) remove(u << 1, x);
    if(x > mid) remove(u << 1 | 1, x);
    pushup(u);
}

int main()
{
    // freopen("dydy.in", "r", stdin), freopen("dydy.out", "w", stdout);
    read(n); I.make_I(), Op1.make_I(), Op2.make_I();

    fos(i, 1, n) p[i] = i;

    Op2.a[2][2] = 0;
    Op1.a[2][1] = Op1.a[3][1] = Op1.a[3][2] = Op2.a[3][2] = Op2.a[3][1] = 1;

    build(1, 1, n);

    fos(i, 1, n)
    {
        ans.init();
        ll op, x; read(op);
        if(op == 1 || op == 2) update(1, i, op);
        else { read(x); remove(1, find(x)); p[i] = x; }
        ans = ans * tr[1].A;
        ww(ans.a[1][1]), wl;
    }
    flush(); return 0;
}
```

---

## 作者：2019yyy (赞：0)

我们把在最外层的括号叫做一级括号，我们发现，每次操作一对答案的贡献可以通过一级括号的数量算出来，假设一级括号的数量为 $k$，对于每一次操作一则有：$ans=ans+k+1$，$k=k+1$。

接下来考虑操作二，对于每一次操作二也有：$ans=ans+1$，$k=1$。

乍一看操作三好像很难，但是我们想撤销一次操作等同于让该操作对于 $ans$ 与 $k$ 的影响消失，所以考虑用矩阵维护操作，最后用全局的矩阵乘法计算答案。

操作三等同于将前面的操作变为单位矩阵，但是当撤销一个操作三的时候，我们需要把原来被这个操作三撤销的矩阵还回来，于是考虑用并查集维护每一个操作三的的根本目标，然后用标记计算每一个操作是开启还是关闭状态。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
struct Martix{
    int a[3][3];
    Martix operator*(Martix another){
        Martix res;memset(res.a,0,sizeof(res.a));
        for(int i=0;i<=2;i++)
            for(int j=0;j<=2;j++)
                for(int k=0;k<=2;k++)
                    res.a[i][j]+=a[i][k]*another.a[k][j];
        return res;
    }
};
struct SegmentTree{
    struct Node{
        int l,r;
        Martix val;
    } tr[1100000];
    void NewNode(int x,int l,int r){
        tr[x].val.a[0][0]=tr[x].val.a[1][1]=tr[x].val.a[2][2]=1;
        tr[x].l=l,tr[x].r=r;
    }
    void pushUp(int x){
        tr[x].val=tr[ls(x)].val*tr[rs(x)].val;
    }
    void buildUp(int x,int l,int r){
        NewNode(x,l,r);
        if(l==r) return ;
        int mid=((l+r)>>1);
        buildUp(ls(x),l,mid);
        buildUp(rs(x),mid+1,r);
        pushUp(x);
    }
    void modify(int x,int pos,Martix val){
        if(tr[x].l==tr[x].r) return (void)(tr[x].val=val);
        int mid=(tr[x].l+tr[x].r)>>1;
        if(mid>=pos) modify(ls(x),pos,val);
        else modify(rs(x),pos,val);
        pushUp(x);
    }
} Tr;

Martix m1,m2,base,init;
int op[210000],fl[210000],fa[210000];
int getfa(int x){
    if(x==fa[x]) return x;
    return fa[x]=getfa(fa[x]);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    // freopen("bracket4.in","r",stdin);
    // freopen("bracket4.out","w",stdout);
    int n;cin>>n;Tr.buildUp(1,1,n);
    for(int i=1;i<=n;i++) fa[i]=i;
    m1.a[0][0]=m1.a[1][0]=m1.a[1][1]=m1.a[2][0]=m1.a[2][1]=m1.a[2][2]=1;
    m2.a[0][0]=m2.a[2][0]=m2.a[2][1]=m2.a[2][2]=1;
    base.a[0][0]=base.a[1][1]=base.a[2][2]=1;
    init.a[0][0]=init.a[0][1]=init.a[0][2]=1;
    for(int i=1;i<=n;i++){
        int opt;cin>>opt;op[i]=opt;
        if(opt==1) Tr.modify(1,i,m1);
        if(opt==2) Tr.modify(1,i,m2);
        if(opt==3){
            int x;cin>>x;
            if(op[x]==1 or op[x]==2) Tr.modify(1,x,base),fl[x]=true,fa[i]=x;
            else{
                fa[i]=getfa(x);
                if(fl[fa[i]]){
                    if(op[fa[i]]==1) Tr.modify(1,fa[i],m1);
                    if(op[fa[i]]==2) Tr.modify(1,fa[i],m2);
                    fl[fa[i]]=false;
                }else{
                    Tr.modify(1,fa[i],base),fl[fa[i]]=true;
                }
            }
        }
        // cout<<Tr.tr[1].l<<" "<<Tr.tr[1].r<<"\n";
        // for(int i=0;i<=2;i++){
        //     for(int j=0;j<=2;j++){
        //         cout<<Tr.tr[1].val.a[i][j]<<" ";
        //     }
        //     cout<<'\n';
        // }
        cout<<(init*Tr.tr[1].val).a[0][0]<<'\n';
    }
    return 0;
}

```

---

## 作者：XZhuRen (赞：0)

模拟赛遇到的小题目，建议降难度。

首先我们添加的括号必然合法，所以假设有一个形如 `()()()()` 的长度为 $n$ 的括号序列，在任意非括号间位置添加一个 `()` 都让答案增加 $1$，所以把这种括号视为单点。

称 $2$ 操作添加的括号为一次**收缩**，一次收缩内部形如 `()()()()` 的括号序列没有影响，对于序列外，则有把整个收缩设为一个括号，参与外面的计算。

收缩之间有嵌套，且嵌套总是一层接一层，左端点连续，右端点单调，离线下来，给每个操作赋一个合理的 $L_i,R_i$ 作为端点，记录端点所对应的值。用 $\text{set}$ 维护每一层收缩的右端点。答案与每一层收缩内的 `()` 数量相关，用 $\text{bit}$ 单点加区间查就好。

``` cpp

#include<bits/stdc++.h>
using namespace std;
const int N=6e5+5;
const int M=6e5;
const int St=300000;
typedef long long ll1;
namespace BIT{//散点区间和
	#define lowbit(x) (x&-x)
	int bit[N];
	void Add(int x,int y){for(;x>0&&x<=M;x+=lowbit(x))bit[x]+=y;}
	int qy(int x){int res=0;for(;x>0;x-=lowbit(x))res+=bit[x];return res;}
	int Qry(int l,int r){return qy(r)-qy(l-1);}
}
int n;
bool ison[N];
int Op[N],nxt[N];
int nl,nr;
int L[N],R[N];
int bel[N];
set<int>Rt;//收缩的右端点集合
set<int>::iterator it1,it2;
int cnt[N];//每层收缩的点数
void init(){
	scanf("%d",&n);
	nl=300001,nr=300000;
	L[0]=R[0]=++nr;
	nxt[0]=0,Op[0]=1;
	for(int i=1;i<=n;i++){
		nxt[i]=i;
		scanf("%d",&Op[i]);
		if(Op[i]==3){
			scanf("%d",&nxt[i]);
			nxt[i]=nxt[nxt[i]];
		}else{
			if(Op[i]==1)L[i]=R[i]=++nr;
			else L[i]=--nl,R[i]=++nr,bel[L[i]]=bel[R[i]]=i;
		}
	}
	L[n+1]=--nl,R[n+1]=++nr;
	ison[n+1]=1;
	Rt.insert(nr);
}
int lives=0;
ll1 Ans=0;
void ins1(int id){//插入单点
	ison[id]=1;
	int bl=bel[*Rt.upper_bound(L[id])];
	Ans+=(++cnt[bl]);
	BIT::Add(L[id],1);
	lives++;
}
void del1(int id){//删除单点
	ison[id]=0;
	int bl=bel[*Rt.upper_bound(L[id])];
	Ans-=(cnt[bl]--);
	BIT::Add(L[id],-1);
	lives--;
}
void ins2(int id){//插入收缩
	int l=L[id],r=R[id],Out=0;
	ison[id]=1;
	it1=it2=Rt.upper_bound(R[id]);
	Out=bel[*it2];
	cnt[id]=0;
	if(it1!=Rt.begin()){//内部是否有区间
		int In=bel[*(--it1)];
		l=R[In]+1;
		cnt[id]=1;//包含它的区间端点
	}
	cnt[id]+=BIT::Qry(l,r);//区间内有多少散点
	cnt[Out]-=cnt[id];
	cnt[Out]+=1;
	Ans-=(cnt[Out]-1)*cnt[id];
	Ans+=cnt[Out];
	Rt.insert(R[id]);
	lives++;
}
void del2(int id){//删除收缩
	int l=L[id],r=R[id],Out=0;
	ison[id]=0;
	it1=it2=Rt.lower_bound(R[id]);
	Out=bel[*(++it2)];
	cnt[id]=0;
	if(it1!=Rt.begin()){//内部是否有区间
		int In=bel[*(--it1)];
		l=R[In]+1;
		cnt[id]=1;//包含它的区间端点
	}
	cnt[id]+=BIT::Qry(l,r);//区间内有多少散点
	Ans+=cnt[id]*(cnt[Out]-1);
	Ans-=cnt[Out];
	cnt[Out]+=cnt[id]-1;
	Rt.erase(R[id]);
	cnt[id]=0;
	lives--;
}
void out(){
	if(!lives)printf("1\n");
	else printf("%lld\n",Ans);
}
void work(){
	ins1(0);
	for(int nw=1;nw<=n;nw++){
		if(Op[nw]==1){
			ins1(nw);
		}else if(Op[nw]==2){
			ins2(nw);
		}else{
			int tar=nxt[nw];
			if(!ison[tar]){//插入
				if(Op[tar]==1)ins1(tar);
				else ins2(tar);
			}else{//删除
				if(Op[tar]==1)del1(tar);
				else del2(tar);
			}
		}
		out();
	}
}
int main(){
	init();
	work();
	return 0;
}
/*
考虑去每一个新加括号方案的影响：

1.()
增加等同于(同一个收缩内数目+1) 的对数

2.收缩包含的一段，
其中的端点变成非法，
其本身的左端点变成合法。

答案增加 1，
减少它同收缩连续段的（长度-它的长度）*它的长度

其撤销同理，释放一个连续段，
答案减少 1，
增加它同收缩连续段的（长度-它的长度）*它的长度


由于一层嵌套必然发生奇偶变化，直接维护奇偶变化就可以了。
具体的就是对于一个找嵌套的
*/
/*
性质：
所有收缩的左端点都连续。
所以：每一层收缩必包含它的下一层收缩（或不存在）
为统计方便，在外层增加一个最大的收缩。
*/

```

---

## 作者：dAniel_lele (赞：0)

考虑只有 $1$ 操作，不难发现操作 $x$ 次会变成连续 $x$ 个 `()` 拼接而成，其能够括号匹配的非空子串个数为 $\frac{x(x+1)}{2}$。

对于 $2$ 操作，我们不难发现会把整个序列分成两层，也就是说，里面的无法到外面使得其能匹配。于是要么被这个括号包含，要么区间包含这个括号，相当于下一层的区间。

也就是说，如果只有 $1,2$ 操作，我们可以简单维护目前本层有几个括号，记为 $cnt$。新加入一个 $1$ 操作就把 $cnt$ 加一然后把 $cnt$ 加入 $ans$，$2$ 操作就把 $cnt$ 变为 $1$，然后加入 $ans$。

考虑取消操作，首先这个操作将没有任何贡献，如果他是 $2$ 操作那么会合并两层。

考虑用线段树维护，每个点记录这个区间里面的答案，向左边/右边延伸的同层数量与区间长度。合并的时候只需要合并答案，加上中间的贡献，类似最大子段和地合并向左边/右边延伸的同层数量与区间长度即可。

对于最底层，有三类：$1,2$ 和被删除操作。$1$ 的话左右延伸均为 $1$，答案为 $1$，区间长度为 $1$，$2$ 的话左延伸为 $0$，右延伸为 $1$，答案为 $1$，区间长度为 $1$，被删除的话左右延伸，答案，区间长度均为 $0$。

总复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
#define int long long
using namespace std;
int op[200005],pos[200005],sta[200005];
struct node{
	int tol,tor,tot,tag;
};
node merge(node x,node y){
	node ans;
	ans.tol=(x.tag?x.tol:x.tol+y.tol);
	ans.tor=(y.tag?y.tor:y.tor+x.tor);
	ans.tot=x.tot+y.tot+x.tor*y.tol;
	ans.tag=x.tag|y.tag;
	return ans;
}
struct sgt{
	node f[1000005];
	void change(int i,int l,int r,int pos){
		if(l==r){
			if(sta[l]) f[i].tol=f[i].tor=f[i].tot=f[i].tag=0;
			else{
				if(op[l]==1) f[i].tol=f[i].tor=f[i].tot=1,f[i].tag=0;
				if(op[l]==2) f[i].tor=f[i].tot=f[i].tag=1,f[i].tol=0;
			}
			return ;
		}
		if(pos<=mid) change(i*2,l,mid,pos);
		else change(i*2+1,mid+1,r,pos);
		f[i]=merge(f[i*2],f[i*2+1]);
	}
}tree;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
	int n; cin>>n;
	for(int i=1;i<=n;i++){
		cin>>op[i];
		if(op[i]==3){
			cin>>pos[i];
			if(op[pos[i]]==3) pos[i]=pos[pos[i]];
		}
		else{
			pos[i]=i;
		}
	}
	op[0]=1;
	tree.change(1,0,n,0);
	for(int i=1;i<=n;i++){
		tree.change(1,0,n,pos[i]);
		sta[pos[i]]^=1;
		cout<<tree.f[1].tot<<"\n";
	}
	return 0;
}
```

---

## 作者：北文 (赞：0)

 [题面传送门](https://www.luogu.com.cn/problem/P6864)  
今天模拟赛出了此题，感觉和大家做法不太一样（不是矩阵玩家），写个题解说一下。    
## 题目分析：  
首先考虑没有撤销怎么做。 
每次新加入一对括号只要考虑这对括号与原串的影响。  
记当前串为 $S$，当前答案为 $now$。  
对于当前字符串把其分成多组互不包含的括号的形式  
形如这样：  
`(.....)(...)(...)`   
设有 $p$ 段。  

操作 1 ：在 $S$ 后加一对括号，那么新加的这个串贡献为 $p+1$，因为它可以和前面的每一个括号匹配，再加上它本身。然后令 $p\leftarrow p+1$。  
操作 2 ：把 $S$ 用一个括号包起来，那么贡献为 $1$，再令 $p=1$。  

我们发现对于任意两个操作 2 之间的操作 1 ，他们的贡献总和是 $\frac{p\times (p+1)}{2}$ （其实是等差数列求和），而一个 2 操作相当于一个分隔符。   
假设操作序列为：1 1 1 2 1 1 2。  
$S=$ `( ( ( ) ( ) ( ) ( ) ) ( ) ( ) )`  
$$now=\frac{4\times (4+1)}{2}+\frac{3\times (3+1)}{2}+\frac{1\times (1+1)}{2}=17$$   
这样我们只要知道每段的 $p$ 就能求出 $now$ 了。  
考虑撤销操作。  
如果撤销了 1 操作，相当于令某一个 $p\leftarrow p-1$。  
如果撤销了 2 操作，相当于合并两个 $p1, p2$，令新 $p\leftarrow p1+p2-1$。  
撤销（撤销 1 操作），相当于令某一个 $p\leftarrow p+1$。  
撤销（撤销 2 操作），相等于使一个 $p$ 分裂成 $p1,p2$，我们只需要记下之前合并时的分界点即可。  
剩下合并的事情，蒟蒻用了线段树维护，真是太难看了  
## Sol:  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
using ll=long long;
struct Seg{
	int t[N<<2], tag[N<<2];
	void build(int u, int l, int r) {
		if(l==r) return t[u]=l, void();
		int mid=l+r>>1;
		build(u<<1, l, mid);
		build(u<<1|1, mid+1, r);
	}
	void pushdown(int u) {
		if(tag[u]) {
			t[u<<1]=tag[u];
			t[u<<1|1]=tag[u];
			tag[u<<1]=tag[u];
			tag[u<<1|1]=tag[u];
			tag[u]=0;
			return ;
		}
	}
	void update(int u, int l, int r, int L, int R, int v) {
		if(L<=l&&r<=R) {
			t[u]=v;
			tag[u]=v;
			return ;
		}
		int mid=l+r>>1;
		pushdown(u);
		if(L<=mid) update(u<<1, l, mid, L, R, v);
		if(R>mid) update(u<<1|1, mid+1, r, L, R, v);		
	}
	int query(int u, int l, int r, int x) {
		if(l==r) return t[u];
		int mid=l+r>>1;
		pushdown(u);
		if(x<=mid) return query(u<<1, l, mid, x);
		else return query(u<<1|1, mid+1, r, x);
	}
}L, R;
int n, top[N], tx[N], val[N];
int t[N];
void update(int x, int v) {
	for(; x<=n; x+=x&-x)
		t[x]+=v;
}
int query(int x) {
	int ret=0;
	for(; x; x-=x&-x)
		ret+=t[x];
	return ret;
}
ll calc(int x) {
	return 1ll*(x+1)*x/2;
}
int pos[N], hmid[N];
int main() {
//	freopen("dydy.in", "r", stdin);
//	freopen("dydy.out","w",stdout);
	scanf("%d", &n);
	L.build(1, 1, n); R.build(1, 1, n);
	int now=1; ll ans=1; update(1, 1);
	for(int i=1, op, x; i<=n; i++) {
		scanf("%d", &op); if(op==3) scanf("%d", &x);
		if(op==1) {
			int l=L.query(1, 1, n, now), r=R.query(1, 1, n, now);
			ans-=calc(query(r)-query(l-1));
			update(now, 1);
			ans+=calc(query(r)-query(l-1));
			
			top[i]=1; tx[i]=i; val[i]=-1;
		} else if(op==2) {
			ans++; now++; update(now, 1);
			top[i]=2; tx[i]=i; val[i]=-1; 
		} else if(op==3) {
			
			if(top[x]==1) {
				int l=L.query(1, 1, n, pos[tx[x]]), r=R.query(1, 1, n, pos[tx[x]]);
				ans-=calc(query(r)-query(l-1));
				update(pos[tx[x]], val[x]);
				ans+=calc(query(r)-query(l-1));
				top[i]=1; tx[i]=tx[x]; val[i]=-val[x];
				
			} else if(top[x]==2) {
					
				if(val[x]==-1) {
					int l1=L.query(1, 1, n, pos[tx[x]]-1), r1=R.query(1, 1, n, pos[tx[x]]-1);
					int l2=L.query(1, 1, n, pos[tx[x]]), r2=R.query(1, 1, n, pos[tx[x]]);
					ans-=calc(query(r1)-query(l1-1));
					ans-=calc(query(r2)-query(l2-1));
					update(pos[tx[x]], -1);
			
					R.update(1, 1, n, l1, r1, r2);
					L.update(1, 1, n, l2, r2, l1);
					ans+=calc(query(r2)-query(l1-1));
					
					top[i]=2; tx[i]=tx[x]; val[i]=1; hmid[tx[x]]=r1;
				} else {
					int l1=L.query(1, 1, n, pos[tx[x]]-1), r1=R.query(1, 1, n, pos[tx[x]]-1);
					ans-=calc(query(r1)-query(l1-1));
					R.update(1, 1, n, l1, hmid[tx[x]], hmid[tx[x]]);
					L.update(1, 1, n, hmid[tx[x]]+1, r1, hmid[tx[x]]+1);
					update(pos[tx[x]], 1);
					ans+=calc(query(hmid[tx[x]])-query(l1-1));
					ans+=calc(query(r1)-query(hmid[tx[x]]));
					top[i]=2; tx[i]=tx[x]; val[i]=-1;
				}
			} 
		}
		pos[i]=now; printf("%lld\n", ans);
	}
	return 0;
}
```


---

## 作者：dbxxx (赞：0)

[欢迎到我的博客阅读本文，谢谢](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p6864.html)。

设当前括号串 $S$ 中：

- 合法括号非空 **子串** 数量为 $\mathrm{ans}$。
- 合法括号非空 **后缀子串** 数量为 $\mathrm{cnt}$。

>  例： $S = \mathtt{()()}$，则 $\mathrm{ans} = 3$，$\mathrm{cnt} = 2$。

设 $S$ 进行一步操作一后，变为括号串 $S_1 = \overline{S\mathtt{()}}$，相应参数变为 $\mathrm{ans}_1$ 和 $\mathrm{cnt}_1$。

现试图找到 $\mathrm{ans_1}$ 和 $\mathrm{ans}$、$\mathrm{cnt_1}$ 和 $\mathrm{cnt}$ 的关系。

不难发现 $\mathrm{cnt_1 = cnt + 1}$，$\mathrm{ans_1 = ans + cnt + 1}$。

再设 $S$ 进行一步操作二后，变为括号串 $S_2 = \overline{\mathtt ( S\mathtt)}$，相应参数 $\mathrm{ans_2}$ 和 $\mathrm{cnt_2}$。

我们试图证明，**新增的合法括号非空子串只有 $\boldsymbol{S_2}$ 本身一个。**

反证法，我们考虑有没有可能，新加的这对括号中的左括号，和 $S$ 的一段前缀组成一段合法括号子串？

很明显，这要求 $S$ 的这段前缀中，右括号比左括号多一个。

但在操作的变换中，字符串始终是合法括号串。因此，$S$ 不可能存在一段右括号比左括号多的前缀。

那有无可能，新加的这对括号中的右括号，和 $S$ 的一段后缀组成一段合法括号子串？

这要求 $S$ 的这段后缀里，左括号比右括号多一个。

可以发现，这就意味着 $S$ 除去这段后缀的剩余那部分前缀，右括号比左括号多一个（因为整个括号串左右括号数相等），所以同样不可能。

那么新增的合法括号子串只有 $S_2$ 本身一个咯。

所以 $\mathrm{cnt_2} = 1$，$\mathrm{ans_2} = \mathrm{ans} + 1$。

现在考虑撤销操作。发现撤销操作对 $\mathrm{cnt}$ 和 $\mathrm{ans}$ 的变化并不平凡。

然后这里有一个比较不朴素的想法……那就是用矩阵刻画上面两种操作的变换。

刻画还是较为容易的：
$$
\begin{bmatrix}
\mathrm{ans} & \mathrm{cnt} & \mathrm{1}
\end{bmatrix} \times
\begin{bmatrix}
1 & 0 & 0\\
1 & 1 & 0\\
1 & 1 & 1
\end{bmatrix} = 
\begin{bmatrix}
\mathrm{ans_1} & \mathrm{cnt_1} & \mathrm{1}
\end{bmatrix}
$$

$$
\begin{bmatrix}
\mathrm{ans} & \mathrm{cnt} & \mathrm{1}
\end{bmatrix} \times
\begin{bmatrix}
1 & 0 & 0\\
0 & 0 & 0\\
1 & 1 & 1
\end{bmatrix} = 
\begin{bmatrix}
\mathrm{ans_2} & \mathrm{cnt_2} & \mathrm{1}
\end{bmatrix}
$$

那么答案可以看做初始矩阵 $\begin{bmatrix}1 & 1 & 1\end{bmatrix}$ 经过一系列矩阵乘法得到的结果。

那撤销是什么？题目的撤销还可以撤销一个撤销操作，看起来很高级，但它的影响最后无非都是：

- 将某个非撤销操作（即操作一或操作二）从进行改为不进行。
- 将某个非撤销操作（即操作一或操作二）从不进行改为进行。

不进行操作也是可以刻画出矩阵的，即单位矩阵 $\begin{bmatrix}1 & 0 & 0 \\0 & 1 & 0 \\ 0 & 0  & 1\end{bmatrix}$。

所以任何一个撤销操作都是将一个非撤销操作对应的矩阵单点修改，要么是从操作矩阵修改成单位矩阵，要么是从单位矩阵修改成操作矩阵。

因此现在变成一个对矩阵单点修改，求矩阵全局乘法的问题。因为矩阵乘法有结合律，可以用线段树维护。

因为矩阵乘法没法差分，所以不能用单 $\log$ 的树状数组。

时间复杂度 $\Theta(K^3 n \log n)$，其中 $K = 3$。

```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2023-05-15 16:06:19 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2023-05-15 19:15:26
 */
#include <bits/stdc++.h>
#define int long long
inline int read() {
    int x = 0;
    bool f = true;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = false;
    for (; isdigit(ch); ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    return f ? x : (~(x - 1));
}
inline int ls(int p) {
    return p << 1;
}
inline int rs(int p) {
    return p << 1 | 1;
}

struct phalanx {
    int a[4][4];

    phalanx () {
        for (int i = 1; i <= 3; ++i)
            for (int j = 1; j <= 3; ++j)
                a[i][j] = 0;
    }
    phalanx (std :: vector <int> v) {
        for (int i = 1; i <= 3; ++i)
            for (int j = 1; j <= 3; ++j)
                a[i][j] = v[(i - 1) * 3 + j - 1];
    }

    const phalanx operator * (const phalanx b) const {
        phalanx ans;
        for (int i = 1; i <= 3; ++i)
            for (int j = 1; j <= 3; ++j)
                for (int k = 1; k <= 3; ++k)
                    ans.a[i][j] += a[i][k] * b.a[k][j];
        return ans;
    }
};

const phalanx UNIT({1, 0, 0, 0, 1, 0, 0, 0, 1}), 
                OP1({1, 0, 0, 1, 1, 0, 1, 1, 1}),
                OP2({1, 0, 0, 0, 0, 0, 1, 1, 1});

const int N = (int)2e5 + 5;

struct node {
    int l, r;
    phalanx ans;
} t[N << 2];

inline node con(node lef, node rgt) {
    return (node){
        l: lef.l,
        r: rgt.r,
        ans: lef.ans * rgt.ans
    };
}

inline void up(int p) {
    t[p] = con(t[ls(p)], t[rs(p)]);
}

void build(int p, int l, int r) {
    if (l == r) {
        t[p].l = t[p].r = l;
        t[p].ans = UNIT;
        return ;
    }
    int mid = (l + r) >> 1;
    build(ls(p), l, mid);
    build(rs(p), mid + 1, r);
    up(p);
}

void modify(int p, int x, int op) {
    int l = t[p].l, r = t[p].r;
    if (l == r) {
        if (op == 1)
            t[p].ans = OP1;
        else if (op == 2)
            t[p].ans = OP2;
        else
            t[p].ans = UNIT;
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid)
        modify(ls(p), x, op);
    else
        modify(rs(p), x, op);
    up(p);
}

int ops[N];
int pos[N];

signed main() {
    int n = read();
    build(1, 1, n);

    for (int i = 1; i <= n; ++i) {
        int op = ops[i] = read();
        pos[i] = i;
        if (op <= 2)
            modify(1, i, op);
        else {
            int p = read();
            p = pos[i] = pos[p];
            ops[p] = -ops[p];
            modify(1, p, ops[p]);
        }
        phalanx ans = t[1].ans;
        printf("%lld\n", ans.a[1][1] + ans.a[2][1] + ans.a[3][1]);
    }
    return 0;
}
```

---


# [JOISC 2020] ビルの飾り付け 4

## 题目背景

JOISC2020 Day 1 T1

由于数据点较多，本题只评测其中的部分数据。

## 题目描述

给定两个长度为 $2n$ 的序列 $A,B$，构造一个长度为 $2n$ 的序列 $C$ 满足以下条件：

- 对于 $1\leq i\leq 2n$，$C_i$ 只能从 $A_i$ 和 $B_i$ 中选取

- $C_i$ 从 $A_i$ 中选取的次数和从 $B_i$ 中选取的次数都恰好为 $n$。

- $C$ 为单调不降的序列。

如果满足条件的 $C$ 有多个，只需要输出一个。

## 说明/提示

#### 样例 1 解释

构造的 $C=[2,5,6,9,12,14]$，可以自行这是满足条件的方案。

#### 样例 2 解释

另外有 $\texttt{AABB},\texttt{ABAB},\texttt{BABA},\texttt{BAAB},\texttt{ABBA}$ 这 $5$ 组解，输出任何一组均可。

#### 样例 3 解释

没有满足条件的方案。

#### 子任务

| 子任务 | 特殊性质 | 分数 |
| :----------: | :----------: | :----------: |
| $1$ | $1\leq n\leq 2\times 10^3$ | $11$ |
| $2$ | 无 | $89$ |

对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^5,1\leq A_i,B_i\leq 10^9$。

## 样例 #1

### 输入

```
3
2 5 4 9 15 11
6 7 6 8 12 14```

### 输出

```
AABABB```

## 样例 #2

### 输入

```
2
1 4 10 20
3 5 8 13```

### 输出

```
BBAA```

## 样例 #3

### 输入

```
2
3 4 5 6
10 9 8 7```

### 输出

```
-1```

## 样例 #4

### 输入

```
6
25 18 40 37 29 95 41 53 39 69 61 90
14 18 22 28 18 30 32 32 63 58 71 78```

### 输出

```
BABBABAABABA```

# 题解

## 作者：peppaking8 (赞：22)

**我写此题解的两个原因**：

1. 题解里都没有给出连续性的证明，这里给出简证，并说一下我自己的想法；

2. 关于加强问题的一些想法。

### 题意

给定长度为 $2n$ 的序列 $a,b$，你需要构造一个序列，使得每一位从 $a_i,b_i$ 中选取，满足 $a,b$ 中都恰选 $n$ 个，满足其单调不降。

$n\le 5\times 10^5$。

### 标准解法

这道题事实上 dp 是第一想法：$f(i,j,0/1)$ 表示到了第 $i$ 位，$a$（$b$ 也行）序列已经选了 $j$ 个，且这一位选了 $a_i/b_i$ 是否可行。那么，根据单调不降的性质就可以从 $f(i-1)$ 转移过来。时间复杂度 $O(n^2)$。

同时，若 $n=10^5$，这道题就做完了：毕竟 dp 数组是 bool 类型的，所以用 bitset 优化转移，时间复杂度 $O(\dfrac{n^2}{\omega})$。

因为这是正式赛题，所以在考场上，这里可以先写一个这样的暴力，再列出 dp 数组找规律。如果真的这么做的话，比较容易能发现，如果固定 $i$，那么 $f=1$ 的 $j$ 全部落在一个区间 $[l,r]$ 内。

所以就不用 $j$ 这一维了——我们直接定义 $g(i,0/1)$ 为两个数 $l,r$，表示 $j$ 满足 $l\le j\le r$ 时 $f(i,j,0/1)=1$。状态数降下来了，转移又是 $O(1)$ 的，这道题就这样做完了。

### 解法 2

~~如果在家里口胡，不能打表怎么办？~~

抽象成一个图论问题来看看。若 $a_{i-1}/b_{i-1}\le a_i/b_i$，则在两点之间连一条边。如果让 $a_i,b_i$ 在同一列（$a_i$ 在上 $b_i$ 在下），那么原题就是找到从最左边到达最右边的一条路，经过了上面恰 $n$ 次，下面也如此。

有一些情况时，可以直接确定 $a_i,b_i$ 究竟选哪个。比如，若 $a_i$ 比 $a_{i-1},b_{i-1}$ 都小，那么一定要选 $b_i$ 否则连不出去；同理，若 $a_i$ 比 $a_{i+1},b_{i+1}$ 都大，那么一定要选 $b_i$。在确定了一些位之后，有可能和它相邻的位也确定了：若 $a_i$ 必须选，且 $a_{i-1}>a_i$，那么只能选 $b_{i-1}$ 了。

这其实是手算的时候的步骤。这也可以用代码来实现：先看能不能在这一位就直接确定选择，若可以就向外拓展，遇到不能拓展或已经拓展完的就停止。这样每个位置最多被扩展一次，复杂度 $O(n)$ 有保证。

好了，那现在没有被确定下来的位基本上是 $a_i,b_i$ 都行了。而且我们会发现，若 $i-1,i$ 位都没确定，不妨 $a_{i-1}\le b_{i-1}$，则一定 $a_{i-1}\le a_i,b_i$，且 $b_{i-1}$ 至少 $\le $ 其中一个。分两种情况：

- $b_{i-1}\le a_i,b_i$，此时 $i-1,i$ 位任意选择都可行；
- $b_{i-1}\le a_i$ 但 $>b_i$。此时不能同时选择 $b_{i-1},b_i$，其余均可。

所以我们发现，原题变成了若干条如下的限制：

- 有若干位已经被确定；
- 对相邻不确定的位，不能同时选择两个元素。

这就证明了连续性的结论。不妨考虑 $a$ 能选多少个。我们将第二种限制分成若干段，每段 $a_l,\cdots,a_r$ 相邻两项都不能全选。这样在这个段里面可以选 $[0,(r-l+1)/2]$ 个，是连续的；若干段叠加起来，自然也是连续的。

所以我们分别判断 $a,b$ 至多选择多少个，若全都 $\ge n$ 则可行，否则不行。判断方式也更加简单了：若这一段是区间 $[l,r]$，则答案加上 $(r-l+1)/2$ 下取整。

### 加强

本题的加强版是：求满足条件的方案数。

变成了求方案数的问题，前面的 dp 做法就无法很简单地优化了。我们考虑解法 2。对已经确定的位，当然就固定了；剩下的就是若干限制。

我们仍考虑段。对长度为 $x$ 的段，要选择 $y$ 个，满足两两不相邻，方案数是
$$C_{x-y+1}^y = \dfrac{(x-y+1)!}{y!\times (x-2y+1)!}$$
这可以通过递推式或者插板法推出。

回到原题，除去已经确定的位，设 $a$ 一共要选 $m$ 个。若 $a$ 的段长分别为 $x_1,\cdots,x_k$，则方案数等于
$$\sum\limits_{y_1+\cdots+y_k=m} \prod\limits_{i=1}^k C_{x_i-y_i+1}^{y_i}$$
其中 $y_1,\cdots,y_k$ 是每段选多少个。

显然就拿多项式来干这个东西。$F_{l,r}$ 表示 $x_l,\cdots,x_r$ 区间内的以 $m$ 为变量的多项式，则
$$F_{l,r}=F_{l,mid}\times F_{mid+1,r}$$
就可以用分治和多项式乘法来解决。时间复杂度 $O(n\log^2n)$。

---

## 作者：pref_ctrl27 (赞：7)

## [JOISC2020] ビルの飾り付け 4

### Description

给定长度为 $2n$ 的序列 $A,B$，要求构造序列 $C$ 使得：

+ $C_i$ 从 $A_i,B_i$ 中选取。
+ 恰好有 $n$ 个位置是从 $A$ 中选取的。

### Analysis

为啥题解都说打表，没什么人证这个结论……感觉挺自然的啊。

显然的 DP 是 $f_{i,j,0/1}$ 表示前 $i$ 个中选出 $j$ 个 A，最后一位为 A/B 是否合法。复杂度 $\mathcal O(n^2)$。

考虑 DP 优化常用技巧：调换定义域和值域，用 $f_{i,0/1,0/1}$ 表示 $\{j\mid f_{i,j,0/1}=0/1\}$。由于互为补集，所以只需考虑 $f_{i,0/1,1}$ 即可。

转移可以表示成 $f_{i,*}\gets f_{i-1, 0} \cup f_{i-1, 1}$ 的形式，可能会整体加上 $1$。
考察 $f_{i, 0}$ 和 $f_{i, 1}$ 的关系，可以发现，$f_{i,0}$ 和 $\{j\mid j+1\in f_{i,1}\}$ 是包含关系。这是因为 $A_i, B_i$ 中较大数能转移的状态一定包含了较小的数能转移到的状态。

注意到此时如果 $f_{i-1,0/1}$ 都为连续区间，那么由于上述结论，显然它们的并也是连续区间，而初始区间为 $\{0\}$ 和 $\{1\}$，因此归纳可证 $f_{i,0/1}$ 是一段连续区间，所以可以做到 $\mathcal O(n)$。

---

## 作者：xht (赞：5)

先考虑 $n \le 2 \times 10^3$ 怎么做。

设 $f_{i,j,0/1}$ 表示考虑前 $i$ 个数，在 $a$ 中选了 $j$ 个数，第 $i$ 个数选的是 $a/b$ 是否可行。

那么 $\mathcal O(n^2)$ dp 即可，如果有方案，从后往前构造。

注意到对于 $f_{i,j,0/1}$，如果 $i,0/1$ 固定，$j$ 可行的方案为一个区间。

因此只用 $\mathcal O(n)$ dp 出对于每个 $i,0/1$，$f_{i,j,0/1}$ 中 $j$ 的可行区间。

```cpp
const int N = 5e5 + 7, inf = 1e9;
int n, a[N<<1], b[N<<1];
pi f[N<<1][2];

inline void upd(pi &a, pi b, bool c) {
	a.fi = min(a.fi, b.fi + c), a.se = max(a.se, b.se + c);
}

inline bool pd(pi a, int x) {
	return a.fi <= x && a.se >= x;
}

int main() {
	rd(n), rda(a, n << 1), rda(b, n << 1);
	f[1][0] = mp(1, 1), f[1][1] = mp(0, 0);
	for (int i = 2; i <= (n << 1); i++)
		for (int j = 0; j < 2; j++)
			f[i][j] = mp(inf, -inf);
	for (int i = 1; i < (n << 1); i++)
		for (int j = 0; j < 2; j++)
			if (f[i][j] != mp(inf, -inf)) {
				if (j == 0 && a[i+1] >= a[i])
					upd(f[i+1][0], f[i][j], 1);
				if (j == 1 && a[i+1] >= b[i])
					upd(f[i+1][0], f[i][j], 1);
				if (j == 0 && b[i+1] >= a[i])
					upd(f[i+1][1], f[i][j], 0);
				if (j == 1 && b[i+1] >= b[i])
					upd(f[i+1][1], f[i][j], 0);
			}
	if (!pd(f[n<<1][0], n) && !pd(f[n<<1][1], n)) return print(-1), 0;
	int p = n, q = 0;
	string s;
	a[n<<1|1] = b[n<<1|1] = inf;
	for (int i = n << 1; i; i--)
		if (pd(f[i][0], p) && a[i] <= (q ? b[i+1] : a[i+1]))
			s += 'A', --p, q = 0;
		else s += 'B', q = 1;
	reverse(s.begin(), s.end());
	prints(s);
	return 0;
}
```

---

## 作者：syksykCCC (赞：5)

后文请自动将状态中的 $A$ 视作 $0$，$B$ 视作 $1$。 

$\mathcal O(n^2)$ 的思路还是很好想的，用 $f_{i, j, A/B}$ 表示前 $i$ 个数，选了 $j$ 个 $\text A$ 中的，最后一个数字选的是 $\text A$ 中的还是 $\text B$ 中的，当前末尾的最小值是多少。转移显然。

改变策略，用 $f_{i, A/B, A/B}$ 表示前 $i$ 个数，最后一个选了 $\text A$ 中的还是 $\text B$ 中的，最大化选 $\text A$ 的个数还是选 $\text B$ 的个数，最多能选多少个 $\text A / \text B$。

我们枚举 $i$ 和 $i - 1$ 的状态，分类讨论。下文的 $\to$ 可以视作「去更新」，也就是一个取 $\max$ 的操作。

* 如果 $A_{i-1} \le A_i$，那么我们试图选择 $A_{i - 1}$ 和 $A_i$，这时可以用 $f_{i - 1, A, A} + 1 \to f_{i, A, A}$（又选了一个 $\text A$），用 $f_{i - 1, A, B} \to f_{i, A, B}$（没有选 $\text B$）；

* 如果 $B_{i-1} \le A_i$，那么我们试图选择 $B_{i - 1}$ 和 $A_i$，这时可以用 $f_{i - 1, B, A} + 1 \to f_{i, A, A}$（又选了一个 $\text A$），用 $f_{i - 1, B, B} \to f_{i, A, B}$（没有选 $\text B$）；

* 如果 $A_{i-1} \le B_i$，那么我们试图选择 $A_{i - 1}$ 和 $B_i$，这时可以用 $f_{i - 1, A, A} \to f_{i, B, A}$（没有选 $\text A$），用 $f_{i - 1, A, B} + 1 \to f_{i, B, B}$（又选了一个 $\text B$）；

* 如果 $B_{i-1} \le B_i$，那么我们试图选择 $B_{i - 1}$ 和 $B_i$，这时可以用 $f_{i - 1, B, A} \to f_{i, B, A}$（没有选 $\text A$），用 $f_{i - 1, B, B} + 1 \to f_{i, B, B}$（又选了一个 $\text B$）。

求出这个有什么作用呢？当 $f_{2n, A, A} \ge n$ 且 $f_{2n, A, B} \ge n$；或者当 $f_{2n, B, A} \ge n$ 且 $f_{2n, B, B} \ge n$ 时必然有解。这很显然，因为只要两者都能选 $\ge n$ 个，我们就让两者都选 $n$ 个好了。

然后逆序构造答案，时刻保证选 $\text A$ 的个数和选 $\text B$ 的个数都 $\ge n$ 就好了。

时间复杂度 $\mathcal O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5, A = 0, B = 1; 
int n, a[N], b[N], f[N][2][2];
char ans[N];
inline void upd(int &x, int y) { if(y > x) x = y; }
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n << 1; i++) scanf("%d", &a[i]);
	for(int i = 1; i <= n << 1; i++) scanf("%d", &b[i]);
	memset(f, -0x3f, sizeof f);
	f[1][A][A] = 1; f[1][A][B] = 0; f[1][B][A] = 0; f[1][B][B] = 1; 
	for(int i = 2; i <= n << 1; i++)
	{
		if(a[i - 1] <= a[i])
			upd(f[i][A][A], f[i - 1][A][A] + 1), upd(f[i][A][B], f[i - 1][A][B]);
		if(b[i - 1] <= a[i])
			upd(f[i][A][A], f[i - 1][B][A] + 1), upd(f[i][A][B], f[i - 1][B][B]);
		if(a[i - 1] <= b[i])
			upd(f[i][B][A], f[i - 1][A][A]), upd(f[i][B][B], f[i - 1][A][B] + 1);
		if(b[i - 1] <= b[i])
			upd(f[i][B][A], f[i - 1][B][A]), upd(f[i][B][B], f[i - 1][B][B] + 1);
	}
	int cntA = 0, cntB = 0, lst = INT_MAX;
	for(int i = n << 1; i; i--)
	{
		if(cntA + f[i][A][A] >= n && cntB + f[i][A][B] >= n && a[i] <= lst)
			cntA++, ans[i] = 'A', lst = a[i];
		else if(cntA + f[i][B][A] >= n && cntB + f[i][B][B] >= n && b[i] <= lst)
			cntB++, ans[i] = 'B', lst = b[i];
		else return puts("-1") && 0;
	}
	for(int i = 1; i <= n << 1; i++) putchar(ans[i]);
	return 0;
}
```

---

## 作者：EternalEpic (赞：5)

如果要看能统计方案数的加强版，可以转至[划分](https://ac.nowcoder.com/acm/contest/8996/B)。

这题如果每次暴力从上一个状态枚举转移可以得到一个时间复杂度为 $O(n^2)$ 的朴素动态规划，期望得分 $19$ 分。

观察朴素动态规划方程，并经过打表可以发现，对于每一个阶段，在一个序列中选取点的个数是连续的一段区间。

那么我们可以考虑少枚举一层状态（选取个数），把控制区间记录在数组里，这样就可以 $O(1)$ 转移啦。

输出答案方案，只需要逆序判断就可。

至于我上文提到的加强版，需要读者掌握一定的多项式技术，笔者也在自己研究中，可以参考牛客网出题人的题解。

code:

```cpp
// Program written by Liu Zhaozhou ~~~
#include <bits/stdc++.h>

using namespace std;

inline char gc(void) {
	static char buf[100000], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
}

template <class T> inline void read(T &x) {
	T f = 1; x = 0; static char c = gc();
	for (; !isdigit(c); c = gc()) if (c == '-') f = -f;
	for (; isdigit(c); c = gc()) x = (x << 1) + (x << 3) + (c & 15);
	x *= f;
}

inline void readstr(string&x) {
	x = ""; static char ch;
	while (isspace(ch = gc()));
	while (x += ch, !isspace(ch = gc()));
}

inline void readstr(char *s) {
	do *s = gc(); while ((*s == ' ') || (*s == '\n') || (*s == '\r'));
	do *(++s) = gc(); while ((~*s) && (*s != ' ') && (*s != '\n') && (*s != '\r'));
	*s = 0; return;
}

inline void readch(char&x) { while (isspace(x = gc())); }

char pf[100000], *o1 = pf, *o2 = pf + 100000;
#define ot(x) (o1 == o2 ? fwrite(pf, 1, 100000, stdout), *(o1 = pf) ++= x : *o1 ++= x)
template <class T>
inline void println(T x, char c = '\n') {
	if (x < 0) ot(45), x = -x;
	static char s[15], *b; b = s;
	if (!x) *b ++= 48;
	for (; x; * b ++= x % 10 + 48, x /= 10);
	for (; b-- != s; ot(*b)); ot(c);
}

template <class T> inline void write(T x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x / 10);
	putchar(x % 10 + 48);
}

template <class T> inline void writeln(T x, char c = '\n') { write(x); putchar(c); }
template <class T> inline void chkmax(T &x, const T y) { x > y ? x = x : x = y; }
template <class T> inline void chkmin(T &x, const T y) { x < y ? x = x : x = y; }

inline void file(string str) {
	freopen((str + ".in").c_str(), "r", stdin);
	freopen((str + ".out").c_str(), "w", stdout);
}

#define Ms(arr, opt) memset(arr, opt, sizeof(arr))
#define Mp(x, y) make_pair(x, y)

typedef long long ll;
typedef pair <int, int> pii;

const int INF = 0x3f3f3f3f;

const int Maxn = 5e5 + 5;
int n, a[Maxn * 2], b[Maxn * 2];
pii f[Maxn * 2][2]; char ans[Maxn * 2];
inline void update(pii &x, pii y) {
	chkmin(x.first, y.first);
	chkmax(x.second, y.second);
}

signed main(void) {
	read(n); int m = n * 2;
	for (int i = 1; i <= m; i++) read(a[i]);
	for (int i = 1; i <= m; i++) read(b[i]);
	
	f[0][0] = f[0][1] = Mp(0, 0);
	for (int i = 1; i <= m; i++) {
		f[i][0] = f[i][1] = Mp(INF, -INF);
		if (a[i - 1] <= a[i]) update(f[i][0], f[i - 1][0]);
		if (a[i - 1] <= b[i]) update(f[i][1], f[i - 1][0]);
		if (b[i - 1] <= a[i]) update(f[i][0], f[i - 1][1]);
		if (b[i - 1] <= b[i]) update(f[i][1], f[i - 1][1]);
		++f[i][1].first; ++f[i][1].second;
	}
	
	int cur = -1, rem = n;
	for (int i = 0; i < 2; i++)
		if (f[m][i].first <= n && f[m][i].second >= n) cur = i;
	if (cur == -1) { puts("-1"); return 0; }
	for (int i = m; i >= 1; i--) {
		ans[i] = (cur ? 'B' : 'A'); rem -= cur;
		int opt = (cur ? b[i] : a[i]);
		if (a[i - 1] <= opt && f[i - 1][0].first <= rem && f[i - 1][0].second >= rem) cur = 0;
		else cur = 1;
	} puts(ans + 1);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}

/**/

```


---

## 作者：serene_analysis (赞：1)

update on 2022.11.18：刚刚发现当时写题解的时候过于匆忙，没有附上代码，现将其补充以帮助读者理解，同时补充时间复杂度。

---

先忽略字母的数量限制，从前往后找到一个每个位置的值最小的不降序列（也就是说，每个位置在满足选择的数不小于前一个数的基础上尽量小），判无解后尝试从这个状态调整。也就是说，我们尝试让序列中是数量较多字母的位置反转选择。

对于当前位置 $i$，设其选择的字母是 $p_i$，值是 $c_i$，没有选择的值是 $ic_i$。

- 如果 $p_i$ 是我们需要的，直接跳过。
- 如果 $ic_i \lt c_{i-1}$ 则当前位置不能反转选择，直接跳过。
- 否则，尝试反转当前选择。这可能会导致后面的选择需要跟着反转，于是我们往后搜，直到某个位置 $x$ 在前一个位置反转时**可以不反转**或者**不能反转**时停下。那么我们得到了一个序列，且这个序列中任何一个数反转都会导致后面的所有数反转。如果 $x$ 不能反转，直接跳过；如果 $x$ 可以不反转，则把序列中选择了你需要的字母的位置的权值设为 $-1$，选择了你不需要的位置的权值设为 $1$，取你需要的权值和最大的后缀反转即可。（注意这里不能取区间，因为反转一次后被反转的部分的联系就消失了，也即某个位置再次反转回来不一定需要后面的位置跟着反转）

最后判断一下较少的字母数量能否达到序列长度一半即可。

正确性证明相当复杂，我也没有完全证明出来，~~于是我决定留给后人~~，建议没有听懂的读者直接私信找我问，用回答的方式您应该会比较容易理解。当然问我之前可以先思考一下，利用一下初始解值最小这个性质尝试自己证明。如果您完整证明出来了，欢迎您随时私信我指点迷津。

时间复杂度 $\mathcal{O}(n)$。

```cpp
#include<algorithm>
#include<cstdlib>
#include<cstdio>
#include<vector>
int read(){
	int x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-48;
		ch=getchar();
	}
	return x;
}
const int maxn=1e6+5;
int n;
int val[maxn][3],uid[maxn];
void no_sol(){
	printf("-1");
	exit(0);
}
void yes(){
	for(int i=1;i<=n;i++)printf("%c",uid[i]==1?'A':'B');
	exit(0);
}
signed main(){
//	freopen("build.in","r",stdin);
//	freopen("build.out","w",stdout);
	n=read()*2;
	for(int i=1;i<=n;i++)val[i][1]=read();
	for(int i=1;i<=n;i++)val[i][2]=read();
	int last=std::min(val[1][1],val[1][2]);
	uid[1]=(last==val[1][1]?1:2);
	for(int i=2;i<=n;i++){
		if(val[i][1]<val[i][2]){
			if(val[i][1]>=last)uid[i]=1,last=val[i][1];
			else if(val[i][2]>=last)uid[i]=2,last=val[i][2];
			else no_sol();
		}
		else{
			if(val[i][2]>=last)uid[i]=2,last=val[i][2];
			else if(val[i][1]>=last)uid[i]=1,last=val[i][1];
			else no_sol();
		}
	}
	int one=0;
	for(int i=1;i<=n;i++)one+=(int)(uid[i]==1);
	if(one==n/2)yes();
	int need=(one>n/2?2:1),ncnt=(one>n/2?one-n/2:n/2-one);
//	printf("one=%d,need=%d,ncnt=%d\n",one,need,ncnt);
	for(int i=1;i<=n;i++){
//		printf("i=%d,uid[i]=%d,val[i][need]=%d\n",i,uid[i],val[i][need]);
		if(ncnt==0)break;
		if(uid[i]==need)continue;
		if(val[i][need]<val[i-1][uid[i-1]])continue;
		int nval=val[i][need],to=i+1;
		bool can=true;
		while(to<=n){
			if(std::max(val[to][uid[to]],val[to][3-uid[to]])<nval){
//				printf("can=false\n");
				can=false;
				break;
			}
			if(val[to][uid[to]]>=nval)break;
			else nval=val[to][3-uid[to]],to++;
		}
		if(can){
			int mx=0,mid=-1,got=0;
			for(int j=to-1;j>=i;j--){
//				printf("uid[%d]=%d\n",j,uid[j]);
				got+=(uid[j]==3-need?1:-1);
				if(got>mx){
					mx=got,mid=j;
					if(got==ncnt)break;
				}
			}
			if(mx>0){
				for(int j=mid;j<=to-1;j++)uid[j]=3-uid[j];
				ncnt-=mx;
			}
		}
//		printf("i=%d,to=%d\n",i,to);
		i=to-1;
	}
	if(ncnt==0)yes();
	else no_sol();
	return 0;
}
/*
3
2 5 4 9 15 11
6 7 6 8 12 14
*/
```

感谢您的阅读。

---

## 作者：qian_shang (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P6891)


------------


## 子任务一

- 先思考朴素$O(n^2)DP$，$f[i][j][0/1]$指选到第$i$位，$A$数组选了$j$个，这一位是$A/B$.

- 转移是判断当前位置与上一个位置的大小关系,暴力转移。

- 期望得分$11$

## 子任务二

- 可以打表或者推结论发现（然而我不会），转移一定是从一段连续的地方转移的。

- 于是我们可以记录一个最大值和最小值，$f[i][0/1]$指选到第$i$位当前为$A/B$的合法情况选A的个数的最大值，$g[i][0/1]$指选到第$i$位当前为$A/B$的合法情况选A的个数的最小值。

- 转移方程为：

```
if (A[i]>=A[i-1]) f[i][0]=max(f[i][0],f[i-1][0]+1),g[i][0]=min(g[i][0],g[i-1][0]+1);
if (A[i]>=B[i-1]) f[i][0]=max(f[i][0],f[i-1][1]+1),g[i][0]=min(g[i][0],g[i-1][1]+1);
if (B[i]>=A[i-1]) f[i][1]=max(f[i][1],f[i-1][0]),g[i][1]=min(g[i][1],g[i-1][0]);
if (B[i]>=B[i-1]) f[i][1]=max(f[i][1],f[i-1][1]),g[i][1]=min(g[i][1],g[i-1][1]);
```

- 考虑如何输出答案，按照最长上升子序列的套路，考虑倒序输出，递归函数$solve(x,y,z)$为，当前选到$x$位，还可以选$y$个$A$,上一个数选的是$z$。

- 最后再特判无解就可以了

```
#include<bits/stdc++.h>
#define N 500005
#define M 1000005
#define R register
#define inf 0x7f7f7f7f
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
inline int minn(int A,int B){return A<B?A:B;}
inline int maxx(int A,int B){return A>B?A:B;}
int n,A[M],B[M],f[M][2],g[M][2];
char ans[M];
bool ok=1;
inline void solve(int x,int y,int z){
	if (!ok) return ;
	if (x){
		if (A[x]<=z&&f[x][0]>=y&&g[x][0]<=y) solve(x-1,y-1,A[x]),ans[x]='A';
		else if (B[x]<=z&&f[x][1]>=y&&g[x][1]<=y) solve(x-1,y,B[x]),ans[x]='B';
		else ok=0;
	}
	return ;
}
int main(){
	memset(g,inf,sizeof(g)); g[0][0]=g[0][1]=0;
	n=read();
	for (R int i=1;i<=(n<<1);++i) A[i]=read();
	for (R int i=1;i<=(n<<1);++i) B[i]=read();
	for (R int i=1;i<=(n<<1);++i){
		if (A[i]>=A[i-1]) f[i][0]=maxx(f[i][0],f[i-1][0]+1),g[i][0]=minn(g[i][0],g[i-1][0]+1);
		if (A[i]>=B[i-1]) f[i][0]=maxx(f[i][0],f[i-1][1]+1),g[i][0]=minn(g[i][0],g[i-1][1]+1);
		if (B[i]>=A[i-1]) f[i][1]=maxx(f[i][1],f[i-1][0]),g[i][1]=minn(g[i][1],g[i-1][0]);
		if (B[i]>=B[i-1]) f[i][1]=maxx(f[i][1],f[i-1][1]),g[i][1]=minn(g[i][1],g[i-1][1]);
	}
	solve(n<<1,n,inf);
	if (ok) printf("%s",ans+1);
		else puts("-1");
	return 0;
}
```

---

## 作者：dead_X (赞：1)

## 前言
JOISC 唯一的水题。
## 思路
显然这道题是 dp 。

考虑 $O(n^2)$ dp。我们记录第 $i$ 格选 $\texttt{A}$ 和 $\texttt{B}$ 时能否构成 $j$ 个 $\texttt{A}$，然后朴素转移。

转移即取某个字母时，前一个字母对应的位置对应的 $j$ 或 $j-1$ 已经能取到，并且那个字母对应的数小于等于你的数。

然后你可以打表找规律。相信你一下就会发现，在格子 $i$ 指定时，$\texttt{A}$ 的个数 $j$ 能取到的一定是**一段连续的区间**，并且 $i$ 相同时，$\texttt{A,B}$ 对应的区间**中间一定不会隔开**，也就是 $r_A+1\geq l_B$。

于是我们就可以 $O(n)$ dp 了。我们可以直接把两个区间取并，然后寻找方案倒推即可。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int a[1000003],b[1000003];
int al[1000003],ar[1000003];
int bl[1000003],br[1000003];
stack<char> ch;
void print(int x,int t,int k)
{ 
    while(1)
    {
        if(t) ch.push('B'); else ch.push('A');
        if(x==1) 
        {
            while(!ch.empty()) putchar(ch.top()),ch.pop(); 
            return ;
        }
        if(t==0)
        {
            
            if(b[x-1]>a[x]) t=0,--k;
            else if(a[x-1]>a[x]) t=1;
            else if(bl[x-1]<=k && k<=br[x-1]) t=1;
            else t=0,--k;
        }
        else
        {
            if(b[x-1]>b[x]) t=0,--k;
            else if(a[x-1]>b[x]) t=1;
            else if(bl[x-1]<=k && k<=br[x-1]) t=1;
            else t=0,--k;
        }
        --x;
    }
}
signed main()
{
    int n=read()*2;
    for(int i=1; i<=n; i++) a[i]=read();
    for(int i=1; i<=n; i++) b[i]=read();
    al[1]=ar[1]=1,bl[1]=br[1]=0;
    for(int i=2; i<=n; i++)
    {
        al[i]=bl[i]=10000003;
        ar[i]=br[i]=-10000003;
        if(a[i-1]<=a[i])
        {
            al[i]=min(al[i],al[i-1]+1);
            ar[i]=max(ar[i],ar[i-1]+1);
        }
        if(b[i-1]<=a[i])
        {
            al[i]=min(al[i],bl[i-1]+1);
            ar[i]=max(ar[i],br[i-1]+1);
        }
        if(a[i-1]<=b[i])
        {
            bl[i]=min(bl[i],al[i-1]);
            br[i]=max(br[i],ar[i-1]);
        }
        if(b[i-1]<=b[i])
        {
            bl[i]=min(bl[i],bl[i-1]);
            br[i]=max(br[i],br[i-1]);
        }
    }
    //for(int i=1; i<=n; i++) printf("[%d,%d] ",al[i],ar[i]); puts("");
    //for(int i=1; i<=n; i++) printf("[%d,%d] ",bl[i],br[i]);
    if(al[n]<=n/2 && n/2<=ar[n]) print(n,0,n/2-1);
    else if(bl[n]<=n/2 && n/2<=br[n]) print(n,1,n/2);
    else puts("-1");
    return 0;
}
```

---


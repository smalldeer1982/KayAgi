# [ICPC 2016 WF] What Really Happened on Mars?

## 题目描述

你有 $t$ 个进程和 $r$ 个资源，每个进程包含其起始时间与**基础优先级**（保证两两不同），以及若干条指令。指令有以下三种：

- `compute`：进行计算，消耗 $1$ 微秒。
- `lock k`：锁定编号为 $k$ 的资源，不耗时。
- `unlock k`：解锁编号为 $k$ 的资源，不耗时。

在进程锁定资源后，这个进程就拥有了这个资源直到这个进程将它解锁。保证任意进程只会解锁最近锁定的资源，不会锁定自身拥有的资源，且在进程结束时不会拥有任何资源。

每个资源有一个固定的属性**最高优先级**，即包含锁定该资源指令的所有进程的最高**基础优先级**。

有一个处理器处理这些进程。处理器有一个时钟初始为 $0$，然后重复执行下列步骤：

1. 找出所有正在运行的进程。如果进程开始的时间不大于处理器的时钟且该进程的指令未运行完毕，那么称这个进程正在运行。

2. 决定当前所有正在运行的进程的优先级，以及哪些正在运行的进程会被阻塞。进程 $T$ 会被阻塞当且仅当：

   - 进程 $T$ 的下一条指令是锁定资源 $k$。
   - 资源 $k$ 已经被其他进程拥有，或存在另一个进程拥有某个资源 $\ell$，$\ell$ 的**最高优先级**大于等于 $T$ 的**当前优先级**。

   此时我们称进程 $T$ 被所有拥有资源 $k$ 或满足条件的资源 $\ell$ 的进程阻塞。定义 $T$ 的**当前优先级**为所有它阻塞的进程的**当前优先级**与它本身的**基础优先级**的最大值。

3. 执行**当前优先级**最高且没有被阻塞的进程的下一条指令。如果不存在这样的进程或者执行的指令是 `compute`，则将时钟加 $1$ 微秒。

你需要求所有进程的结束时间。可以证明所有进程一定会结束。

## 样例 #1

### 输入

```
3 1
50 2 5 C1 L1 C1 U1 C1
1 1 5 C1 L1 C100 U1 C1
70 3 1 C1
```

### 输出

```
106
107
71
```

## 样例 #2

### 输入

```
3 3
5 3 5 C1 L1 C1 U1 C1
3 2 9 C1 L2 C1 L3 C1 U3 C1 U2 C1
1 1 9 C1 L3 C3 L2 C1 U2 C1 U3 C1
```

### 输出

```
8
15
16
```

# 题解

## 作者：pokefunc (赞：0)

[P6928 [ICPC2016 WF] What Really Happened on Mars?](https://www.luogu.com.cn/problem/P6928)

题面太长了就不放了。

题目的最大难点在于如何处理阻塞关系，因为看起来阻塞由当前优先级定义，但当前优先级又由阻塞定义。

考虑阻塞的条件，也就是访问一个已经被锁定的资源或者访问一个被拥有且**最高优先级**大于这个进程的**当前优先级**。那么我们从正在执行的**基础优先级**最高的进程开始考虑，如果它的下一条指令是锁定某个资源，且满足上述的阻塞条件，那么我们就可以找出阻塞当前进程的进程，根据题目要求更新**当前优先级**，然后将当前进程标记为被阻塞。

剩下的就没什么特别大的难度了，~~实现难度严格低于今年 CSP-S T3~~，注意细节。建议对于这种大模拟题分模块写，这样各个模块之间相互独立调试更有条理。

[code](https://www.luogu.com.cn/paste/2frtqldk)，非常丑但是应该可读。

此题建议评蓝/紫。

---


# [NEERC 2014] Epic Win!

## 题目描述

在游戏「石头、剪子、布」中，两名玩家分别同时出示自己的行动：*石头*、*剪子*、或*布*。如果两人的行动一致，则平局。否则*石头*打败*剪子*、*布*打败*石头*、*剪子*打败*布*。

上述过程可以重复多次。在本题中，两台有限状态自动机（Finite State Machines，FSM）将游玩多轮「石头、剪子、布」（准确地说，本题中的 FSM 特指 Moore 状态机）。

一台被设计用来游玩「石头、剪子、布」的 FSM 有着有限的状态。每个状态由以下信息描述：下一轮中本台自动机将会出示怎样的行动，以及当下一轮中对手出示了*石头*、*剪子*、或*布*时应该转移到的新状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/j121iya3.png)

幸运的是，你知道对手的 FSM：你知道它所有的结构，但唯独不知道它的初始状态。

你的任务是设计一台你自己的 FSM 去和对手的进行对战。你的 FSM 必须在前十亿（${10}^9$）轮中打败对手至少 $99 \%$ 轮。这就是所谓的史诗般的胜利（epic win）！


对手的 FSM 持续出示*石头*或*布*（取决于初始状态）直到它接收到*剪子*：接收到*剪子*将导致它的行为改变。

一种打败这样的 FSM 的方法是出示*布*。如果对手持续出示*石头*，只需继续出示*布*即可胜利。如果对手出示了*布*，通过出示一次*剪子*让它的行为改变，接下来它就会持续出示*石头*，然后你就可以用*布*打败它了。

## 说明/提示

对于全部数据，$1 \le n \le 100$，$c_i \in \{\texttt{R}, \texttt{P}, \texttt{S}\}$，$1 \le r_i, p_i, s_i \le n$。

**翻译来源**：IOI 2021 集训队第一部分作业，PinkRabbit。

## 样例 #1

### 输入

```
2
R 1 1 2
P 2 2 1
```

### 输出

```
2
P 1 2 1
S 1 1 1
```

# 题解

## 作者：JoshAlMan (赞：11)

现考虑如果我们知道了对方当前状态，我们就可以建立一个 $n$ 的节点，称之为一个系统，第 $i$ 个节点设定为打败对方 $i$ 号节点的状态，并且随之转移到下一个点，对着让他失败着卡就行了（

但是我们不知道，咋办呢？

一种想法是通过有限次弄到一个确定的位置，但显然他的构造（也许有循环性等等）不能让我们的统一化成立。

考虑利用模拟退火类似的方式，我们可以做 $500$ 个系统，每次随机一个猜当前状态的位置，一旦失败，就转移到下一个系统，这样失败的概率在 $n = 100$ 时是 $(\frac{99}{100})^{500} \approx 0.6 \%$，这个东西感觉非常的小，基本不可能发生。

复杂度大概就是 $O(500n)$

---

## 作者：DPair (赞：6)

先膜hehezhou

## 【题意】
**这是一道传统题**

给你一个玩石头剪刀布的有限状态自动机，其初始状态不确定，让你写一个相同形式且初始状态为 $1$ 的有限状态自动机，并在 $1e9$ 场比赛中获得 $99\%$ 的胜率，平局算你输。
## 【思路】
首先我们考虑初始状态确定的情况，比如说初始为 $1$。

那么我们显然对于每一个结点都可以对应的去吊打电脑，并且由于我们选择的策略是确定的，电脑的后继状态也是确定的。

所以我们显然可以造一个自动机对电脑进行全面吊打，称之为一个 “吊打自动机”。

但是这道题的难点在于初始状态不确定。

考虑我们先假设电脑初始状态为 $1$ ，若出现问题了后面再进行调整。

由于我们现有的自动机对电脑全面吊打，每一个点只用了一条出边，那么剩下的两条出边就可以被我们用来调整我们自己的决策。

显然如果我们要吊打电脑的决策，无论电脑的起始点是哪一个，我们的自动机的基础结构都应该是一样的，所以我们直接考虑对自动机进行分层，每一层对应一个不同的起点所对应的 “吊打自动机” ，然后加一些用来调整的出边。

接下来考虑怎么加入这一些用来调整的出边。

考虑枚举每一个电脑的起点，然后跑我们现有的自动机，不断遍历直到我们自动机的当前结点无法处理电脑的返回值，或遍历点数超过了现有点数。后者说明出现了循环，电脑已经被我们全面吊打了，接下来考虑前者。

显然这一局我们是输的，因为赢的边一定在 “吊打自动机” 中被建立出来了，故我们要建一条 “调整边” 。

首先显然当前起点的情况我们无法处理，所以我们新建一层 “吊打自动机” 应对这个起点的情况，然后后面电脑的所有操作就一定会被我们全面吊打了。

我们不妨采用 “自欺欺人” 的策略，即假装我们一直在新的那一层里面，考虑我们下一步该怎么做。

显然我们应该分析电脑下一步会走到哪一个结点，然后我们直接连一条边到新建层的对应结点即可，后面就必然是全面吊打了。

这样子复杂度应该是 $O(n^3)$ 的，总点数是 $O(n^2)$ 的，显然可以通过本题。

## 【代码】
只保留关键部分
```cpp
int tot, layer;
int n;
int c[105][15], t[105];//电脑的自动机
//0, 2, 5 非常符合石头剪刀布的手势
inline int change(char x){//字符转数字
    if(x == 'R') return 0;
    if(x == 'S') return 2;
    if(x == 'P') return 5;
}
inline char Change(int x){//数字转字符
    if(x == 0) return 'R';
    if(x == 2) return 'S';
    if(x == 5) return 'P';
}
inline int dunkon(int x){//什么可以进行吊打
    if(x == 5) return 2;
    if(x == 2) return 0;
    if(x == 0) return 5;
}
int m[50005][15], mt[50005];//我们的自动机
int id[105][105];//每一层结点的编号
inline void newlayer(){//新建一层吊打自动机
    ++ layer;
    for (register int i = 1;i <= n;i ++){
        id[layer][i] = ++ tot;
        mt[tot] = dunkon(t[i]);
    }
    for (register int i = 1;i <= n;i ++) m[id[layer][i]][t[i]] = id[layer][c[i][mt[id[layer][i]]]];
}
void duel(int x){//以 x 为起点，决斗！
    int u = 1, cnt = 0;
    while(m[u][t[x]] && cnt <= tot){//一直处理直到到达边界
    	//注意这里并不需要考虑我们当前是否能赢，因为并不需要保证，只要我们进入循环就一定是全面吊打的状态
        //可以理解为不同起点可能会有相同的过程
        int my = mt[u];
        int cp = t[x];
        u = m[u][cp];
        x = c[x][my];
        ++ cnt;
    }
    if(cnt > tot) return ;//后者直接退出（事实上这里我 tot 错写成 n 也过了）
    newlayer();//新建一层
    m[u][t[x]] = id[layer][c[x][mt[u]]];//连到新建层的对应结点，这是关键步骤，需要仔细理解。
}

int main(){
    read(n);
    for (register int i = 1;i <= n;i ++){
        char ch;readc(ch);t[i] = change(ch);
        read(c[i][0]);read(c[i][5]);read(c[i][2]);
    }
    newlayer();//以 1 为起点吊打
    for (register int st = 2;st <= n;st ++) duel(st);//枚举起点
    fprint(tot, 10);
    for (register int i = 1;i <= tot;i ++){
        char ch = Change(mt[i]);int res;
        putcha(ch);putcha(32);
        res = m[i][0];
        if(!res) res = 1;
        fprint(res, 32);
        res = m[i][5];
        if(!res) res = 1;
        fprint(res, 32);
        res = m[i][2];
        if(!res) res = 1;
        fprint(res, 10);
    }
}

```

---

## 作者：dyc2022 (赞：5)

确定性做法。（感谢 @[whiteqwq](https://www.luogu.com.cn/user/35754) 老师的讲解 /bx）

容易发现，当我们知道 bot 的起点，我们是很好构造一张图使得拥有 $100 \%$ 的胜率的。具体操作就是把 bot 的图贺过来，然后把点权全部变成能克 bot 的手势，然后再把边权换成 bot 出的手势。这样就稳赢了。

但问题在于我们不知道起点。

考虑在知道起点的情况只保留获胜的边。那么我们在构造出这张图后，如果在和 bot 大战的过程中发现，我们根本停不下来，那么就说明我们的这张图所认定的 bot 起点就是 bot 真正的起点，那么我们就赢了。

考虑到这一特性，我们充分发扬人类智慧，对于每一个 bot 可能的起点构造一个只保留获胜边的图，**平局或失败的边连向下一层的该点**。这样为什么是对的？因为总有一层能做到完胜 bot，而我们走到完胜 bot 的层后就会在这一层无限游走。而又因为切换一层等同于一次失败，我们最多在切换 $n-1$ 次后可以到达完胜 bot 的层，因此在 $10^9$ 次游戏中我们最多只会输 $99$ 次。胜率远高于 $99 \%$。

代码好写，就不放了。

---

## 作者：EricWan (赞：2)

题解好少，第一篇说的不清楚，第二篇退火（需要火，小孩子不能玩火，玩火尿床），第三个太长了不想看。

其实这题想明白并不多难，这篇题解清晰通俗的讲一个非常好实现的效率很高解法（我这种大常数选手都一发最优解）。从某神秘训练哪里学到的解法微调的，代码极短！

为了更方便描述下标，本题解大部分使用行内代码块而非 $\LaTeX$。

我们想办法实现一个函数，`int solve(vector<int> nodes)` 代表构造一个从返回值开始的，若电脑的位置为任何 `nodes` 的元素都可以被自己完虐的自动机。

这个函数我们要干什么呢？首先，我们创建一个节点，作为这个自动机的初始节点，我们这个节点出一个手势（后文称为 `c`），然后根据对方出的手势，这时将 `nodes` 划分为三类。这样我们的问题规模就能缩小。我们根据电脑的自动机，可以知道这三类点看到我们的手势之后转移到的位置 `go[0], go[1], go[2]`（`go[x]={computer_move[i if computer_choice[i]==x && i in nodes][c]}`），并让当前自己的三个转移分别指向 `solve(go[0]), solve(go[1]), solve(go[2])` 即可。

上面就是我们的大体思路了，具体来说一下实现：找出能胜出当前 `nodes` 中任意一个元素的手势（这里我为了更智能，找出了能胜最多的一个手势），我们出这个手势，根据这个手势和电脑的自动机，求出上文说的三个 `go`，依次`solve` 一下就是答案，最终的自己造的自动机节点数不超过 $215$，这是什么优化都没有加的。

至于怎么让建自动机的递归停下来，考虑记忆化一下就可以，搜到了自己的祖先就造一个环立马跳转回去。

为什么这个看起来是 $O(2^n)$ 的 DFS 复杂度是对的，考虑到如果 `nodes` 中的节点不等价（等价定义为我们 `solve` 的过程中永远无法分清其中的某一些节点，等价就相当于所用 `computer_choice[i in nodes]` 全部一样我们一直保证获胜，不需要考虑），我们一定可以在 $n-1$ 次对 `solve` 的调用内将 `nodes` 划分为至少两个更小的子集，于是可以在最多 $(n-1)\times(n-1)$ 次对 `solve` 的调用内将 `nodes` 分开为若干等价的子集。每一个等价的子集可以用最多 $n-1$ 次对 `solve` 的调用内建立一个吊打电脑的环，于是总点数最多 $(n-1)\times(2\times n-1)$。实际上这题数据上我的方法建立出来的点数最多 215 个。

代码非常短，码风优美，常数小，带注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
using vi = vector<int>;
int n, cnt;
int botc[105]; // 同题解中 computer_choice
int bot[105][3]; // 同题解中 computer_move
int my_botc[50005];
int my_bot[50005][3];
map<vi, int> mem;
int solve(vi &nodes) { // 为了更更智能地找到能胜最多的手势，这里的 nodes 可重（相当于带权），去重的我没试。
	if (mem.count(nodes))
		return mem[nodes];
	int vote[3]{0, 0, 0};
	for (int i : nodes)
		vote[(botc[i] + 1) % 3]++; // 找到能胜最多的手势
	int now_node = ++cnt; // 自己的节点
	mem[nodes] = now_node; // 记忆化
	if (vote[0] >= vote[1] && vote[0] >= vote[2]) my_botc[now_node] = 0;
	if (vote[1] >= vote[0] && vote[1] >= vote[2]) my_botc[now_node] = 1;
	if (vote[2] >= vote[0] && vote[2] >= vote[1]) my_botc[now_node] = 2;
	vi go[3]; // 拆分 nodes 为三堆
	for (int i : nodes)
		go[botc[i]].push_back(bot[i][my_botc[now_node]]);
	for (int i = 0; i < 3; i++) {
		sort(go[i].begin(), go[i].end()); // 排序，记忆化的时候可以少几个节点，比如 [1,2,2] 和 [2,1,2] 就可以返回同一个自动机初始节点（实测没大用）
		if (go[i].size())
			my_bot[now_node][i] = solve(go[i]); // 如果 go 不为空，就 solve
		else
			my_bot[now_node][i] = now_node; // 否则，这个转移没大用，随便指一个倒霉蛋，就他自己比较优雅
	}
	return now_node;
}
signed main() {
	vi tot;
	map<char, int> c2i{{'R', 0}, {'P', 1}, {'S', 2}};
	cin >> n;
	char ch;
	for (int i = 1; i <= n; i++) {
		tot.push_back(i);
		cin >> ch >> bot[i][0] >> bot[i][1] >> bot[i][2];
		botc[i] = c2i[ch];
	}
	solve(tot);
	cout << cnt << endl;
	for (int i = 1; i <= cnt; i++) {
		cout << "RPS"[my_botc[i]] << " " << my_bot[i][0] << " " << my_bot[i][1] << " " << my_bot[i][2] << endl;
	}
	return cnt / 216; // 展示 cnt <= 215，嘻嘻
}
```

---


# [CERC2013] History course

## 题目描述

你需要按某种顺序为一系列重要历史事件安排讲座，每个讲座对应一个事件。每个事件持续一段时间区间 $[a_i, b_i]$。如果两个事件的时间区间有公共点，则称这两个事件是相关的。为了方便起见，安排相关事件的讲座时应尽量靠近。此外，对于不相关的事件，讲座应按照事件发生的顺序进行（如果事件 A 先于不相关事件 $B$ 发生，那么 A 的讲座应先于 B 的讲座）。找到最小的整数 $k \ge 0$ 和一个讲座顺序，使得任何两个相关事件的讲座之间的间隔最多为 $k$（讲座编号 $i$ 和 $j$ 之间的间隔被认为是 $|i−j|$）。

## 说明/提示

时间限制：10 秒，内存限制：128 MB。感谢 [hht2006](/user/175829) 提供的 Special Judge。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
1
3
1 6
2 3
4 5
```

### 输出

```
1
2 3
1 6
4 5
```

# 题解

## 作者：Sampson_YW (赞：4)

首先按 $l$ 从小到大排序。

最小化最大值，考虑二分答案。那么就要对当前二分的答案 $mid$ 构造一组方案。

我们从小到大依次枚举每个位置，并确定这个位置应该选哪个区间。

假设当前枚举到位置 $i$， 如果选择一个区间，那么其他与它有交的区间能填的位置不能超过 $i+mid$。

记 $f_x$ 表示区间 $x$ 最远能填哪里，记 $s_k = \sum_{x=1}^n[f_x=k]$。

我们找到最小的 $j$ 使得 $\sum_{k=i}^j s_k = j - i + 1$，显然所有 $f$ 值在 $[i, j]$ 之间的区间都必须填到 $[i,j]$ 中。

那么无解的条件就是存在一个 $p$ 使得 $\sum_{k=i}^p s_k > p - i + 1$。

我们贪心地选择区间，从 $f$ 值在 $[i,j]$ 之间的区间中选择 $r$ 最小的区间填到位置 $i$ 上，因为这样会使与位置 $i$ 相交的区间越少，受限制的区间数量就越少。

这样即可在 $O(n^2)$ 的时间内完成一次答案的构造。使用两棵线段树分别查找最小的 $j$ 和右端点最小的区间可优化至 $O(n\log n)$。

具体地，对于查找最小的 $j$，先将每个 $s_i$ 减一，那么对于一个 $i$，要找的 $j$ 就满足 $\sum_{k = i}^j s_k = 0$，线段树维护区间和与区间前缀和的最小值，线段树上二分即可做到 $O(n \log n)$。

对于找 $r$ 最小的区间，要满足 $f$ 值不超过 $j$。

由于序列按照 $l$ 排序，所以每次填一个区间 $[L_x, R_x]$，都会对 $l\leq R_x$ 的前缀产生限制。所以排序后序列的 $f$ 值是单调不降的。我们直接对这个前缀 chkmin 即可。那么会不会出现与 $[L_x, R_x]$ 无交的区间被 $\text{chkmin}$ 使得答案变劣呢？答案是不会的。

因为我们贪心地让 $r$ 小的尽量往前填，所以 $l \leq R_x$ 的区间，要么与 $[L_x, R_x]$ 有交，要么在之前就填过了。否则就会出现一个与 $[L_x, R_x]$ 无交且没有填的区间 $[L_y, R_y]$，满足 $L_y\leq L_x$，那么显然 $R_y\leq R_x$。由于 $[L_x,R_x]$ 能填且序列的 $f$ 值单调不降，所以 $f_y \leq f_x \leq j$，即 $[L_y, R_y]$ 也能填且更优，这与我们的贪心策略矛盾，所以不会出现无交且没填的区间。

第二棵线段树维护序列中没有被填过且 $r$ 最小的区间。

由于我们从小到大填，所以每个 $f$ 每个只会被 $\text{chkmin}$ 一次，用一个指针 $t$ 维护第一个还没被 $\text{chkmin}$ 的位置，设 $g_i$ 表示最后一个 $f=i$ 的位置。

对于要填的位置 $i$，我们用第一棵线段树找到 $j$，然后在第二棵线段树上查前缀 $g_j$ 中 $r$ 最小的区间 $[L_x, R_x]$，然后将 $x$ 删除，向后移动指针，更新 $f_t$ 并修改第一棵线段树，直到 $L_t>R_x$，此时更新 $g_{i + mid} = t - 1$。

总复杂度 $O(n\log^2 n)$。[Code](https://www.luogu.com.cn/paste/wc5l8ia2)

此题弱化版：[CF309E Sheep](https://www.luogu.com.cn/problem/CF309E)，$n\leq 2000$。

---

## 作者：_fairytale_ (赞：2)

>如今再回首那个夏天你我多么明耀
>
>把一切记忆吞下就能填补当时心跳
>
>即使未来迷惘无可奉告
>
>停滞不前的呼号
>
>即使最后对你仍无以为报

这也太难了吧！！！！！！

首先二分答案 $mid$，问题变为判断答案是否 $\le mid$。

设排在第 $i$ 个位置的线段编号为 $q_i$，显然有 $q_{p_i}=p_{q_i}=i$。考虑依次决策 $q_1\dots q_n$。

我们每选择一条线段，就会对与它相交的线段产生约束。对于每条线段 $i$，维护 $lim_i$ 表示它最晚放在 $q_{lim_i}$，初始 $lim_i=n$。这样如果我们决策 $q_i=s$，那么对于所有与 $s$ 相交的线段 $t$，$lim_t\gets\min(lim_t,s+mid)$。

下文的“$[i,j]$ 间的线段”表示“$lim$ 落在 $[i,j]$ 间的线段”。

设 $cnt_i$ 表示满足 $lim_s=i$ 的线段 $s$ 有几个。当我们决策 $q_i$ 的时候，记 $F(j)=(\sum_{k=i}^jcnt_k)-(j-i+1)$，即 $lim$ 落在 $[i,j]$ 间的线段数减去空位数。显然如果存在 $j$ 满足 $F(j)\ge 1$ 就无解。否则我们会找到一个最小的 $j$ 满足 $F(j)=0$，之后不需考虑 $lim$ 落在 $j$ 之后的线段，因为 $[i,j]$ 之间的空位必须由 $[i,j]$ 之间的线段一一填满。

若 $j=i$ 则决策只有一种，接下来讨论 $j>i$ 的情况。

我们有结论：选取右端点最小的线段即可。

猜猜题目中为啥有“**两个区间如果没有交点，则左端点更小的区间需要排在前面**”？我们将在证明的最后解答这个问题。

证明：若 $j=n$，显然选取右端点最小的影响的线段数量最少，是最优的。否则 $j<n$，这说明，$[i,j]$ 间的所有线段都有已经做出过决策的线段与之相交。而 $lim$ 有这样的性质：一旦一条线段的 $lim<n$，接下来这条线段的 $lim$ 就不会改变。**因此这些线段无论如何排序，它们的 $lim$ 都不会改变。**

假设我们没有选择右端点最小的线段，设右端点最小的线段是 $k$，设 $t=p_k$，则 $t>i$。

必然存在一个线段 $s$ 满足 $p_s<p_k$，且 $lim_s\ge t$。这是因为，如果 $lim_{q_i\dots q_{t-1}}$ 都 $<t$，首先剩下的线段中只有这些线段的 $lim<t$，因为如果有线段放在它们之后，它就不能满足它的 $lim$。又因为 $[i,t-1]$ 的空位和线段数相等，所以 $F(t-1)=0$，而 $t-1< t\le j$，与 $j$ 的最小性矛盾。

接下来证明把 $s$ 和 $k$ 交换依然合法。

由于 $[i,j]$ 之间的线段的 $lim$ 不会改变，我们只需考察交换导致 $k$ 提前，进而导致某个 $lim_l>j$ 的线段 $l$ 由合法变为不合法，即交换后 $lim'_l<p_l$ 的情况。若存在这样的线段 $l$，首先说明 $k$ 与 $l$ 有交，且 $lim'_l=p_s+mid<p_l$（因为 $k$ 换到了 $s$ 的位置），所以 $s$ 与 $l$ 无交，因为如果有交，那么 $lim_l=p_s+mid$，则本来 $lim_l$ 就 $<p_l$。

接下来我们开始解答最开始的问题。题面中写道：**“两个区间如果没有交点，则左端点更小的区间需要排在前面”**。因为 $s,l$ 无交，而 $p_s<p_l$，所以 $L_s\le R_s<L_l\le R_l$。因为 $k$ 是右端点最小的线段，所以 $R_k< R_s <L_l$，推出 $k,l$ 无交，矛盾！

接下来就是怎么维护贪心决策了。我们把所有线段按 $l$ 排序，这样对 $lim$ 的修改变为了对一段前缀中的某些线段 ckmin。考察前缀中不应该被 ckmin 的某条线段必然与当前线段无交，而由于题目无交区间 $l$ 更小的需要排在前面的限制，这条线段已经被选过，也就是对它 ckmin 不会有影响，所以可以直接对一段前缀 ckmin，这是经典的 Segment Tree Beats 问题。由于每条线段只会被 ckmin 一次，它使我们把对 $lim$ 的修改拆成了 $n$ 次对 $cnt$ 数组的单点修改！

有了 $cnt$ 数组之后，我们只需要维护 $cnt'_i=cnt_i-i$，接下来是区间查询 $\max$ 判断无解，若有解，则可以通过在线段树上二分找到第一个前缀最大值的位置找到 $j$，剩下的工作都是简单的。

时间复杂度 $\mathcal O(n\log^2 n)$。

---


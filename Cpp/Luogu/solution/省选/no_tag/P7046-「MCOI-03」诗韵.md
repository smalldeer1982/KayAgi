# 「MCOI-03」诗韵

## 题目背景

$\texttt{And the game was over and the player woke up from the dream. }$

游戏结束了，玩家从梦中醒来。

$\texttt{And the player began a new dream. }$

并开始了新的梦境。

$\texttt{And the player dreamed again, dreamed better.}$

并再次沉入梦境中，沉入更好的梦。

$\texttt{And the player was the universe. And the player was love.}$

而玩家就是宇宙。而玩家就是爱。

$\texttt{You are the player.}$

你就是那个玩家。


$\texttt{Wake up.}$


该醒了。

## 题目描述

小 C 想要写首诗文，但是写诗需要押韵。

一首诗文是由需多句子组成，这些句子需要押韵。

但押韵也有优劣。小 C 对押韵有一个评分。评分定义为这些句子的最长公共后缀长度，而韵脚被定义为这些句子的公共后缀。韵脚可以为空串，一个集合的韵脚可以有多个。

最开始，小 C 一个句子也没有写出来。即最开始的记忆集合为空。

小 C 会思考 $M$ 个时刻。每个时刻，他会想出一个句子。即向记忆集合中加入一个新的句子。

小 C 可能会加入多个相同的句子，请只保留一个。因为他的记忆力很好，所以他想到的句子不会被遗忘。

但是他不想花太多心思去造句，所以他认为，只要有 **大于** $K$ 个句子，就能写成一首诗。所以每想出一个句子后，他会向你询问集合所有的元素个数 $>K$ 的子集的评分的最大值，和集合所有元素个数 $>K$ 的子集的韵脚的种类。注意：如果有多个不同的满足条件的集合韵脚相同，则这个韵脚只能计算一次。

由于小 C 很强，所以他造的所有句子的总长度可能非常大。为了方便告诉你这些句子，他造的每一个句子都是长度为 $N$ 的母串 $T$ 的子串。

**注意**：集合是满足特异性的，即集合中的元素应该互不相同，如果有相同元素仅保留一个。

## 说明/提示

#### 样例解释

第一个时刻后，记忆集合为 $\{\texttt{"ab"}\}$。没有子集满足条件，输出 $0\ 0$。

第二个时刻后，记忆集合为 $\{\texttt{"ab","ba"}\}$。能得到的韵脚只有空串。

第三个时刻后，记忆集合为 $\{\texttt{"ab","ba","aba"}\}$。能得到的韵脚有空串，$\texttt{"a"}$，$\texttt{"ba"}$。

第四个时刻后，记忆集合为 $\{\texttt{"ab","ba","aba","abab"}\}$。能得到的韵脚有空串，$\texttt{"a"}$，$\texttt{"ba"}$，$\texttt{"b"}$，$\texttt{"ab"}$。

第五个时刻后，记忆集合为 $\{\texttt{"ab","ba","aba","abab","baba"}\}$。能得到的韵脚有空串，$\texttt{"a"}$，$\texttt{"ba"}$，$\texttt{"b"}$，$\texttt{"ab"}$，$\texttt{"aba"}$。

#### 数据规模和约定

**本题采用捆绑测试。**

| 子任务编号 | $N\le$ | $M\le$ |  时限 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $10$ | $\rm1s$ | $15$ |
| $2$ | $ 10^3$ | $10^3$  | $\rm 1s$ | $20$ |
| $3$ | $10^5$ | $10^5$  | $\rm 1s$ | $25$ |
| $4$ | $ 5\times 10^5$ | $5\times 10^5$ | $\rm 2.33s$ | $40$ |

对于 $100\%$ 的数据，$1 \le N\le 5\times 10^5$，$1 \le M\le   5 \times 10^5，0\le K \le M$。仅包含小写字母。


## 样例 #1

### 输入

```
5 5 1
ababa
1 2
2 3
1 3
1 4
2 5```

### 输出

```
0 0
1 0
3 2
5 2
6 3```

# 题解

## 作者：Flying2018 (赞：10)

## 题目大意
给定一个长度为 $n$ 的字符串。维护一个由其子串构成的集合。支持插入操作。

定义一个字符串（包括空串）是好的，当且仅当其是集合中 $>k$ 个元素的后缀。

每次插入操作后回答：有几个字符串是好的，最长的好字符串长度是多少。
## 题解
首先建出后缀自动机。对于这道题，其中有用的部分是后缀自动机的 parent 树。

通过 parent 树的性质，我们知道任何一条**点到根**的路径代表一个**子串**。同样，一个子串 $s$ 是另一个子串 $s'$ 的后缀当前仅当 $s$ 在后缀树上的位置是 $s'$ 到根路径上的某个节点/边。

我们试图让所有子串定位到点上。但是定位并不总是成功的，因为有一些点由于只有一个儿子，所以被直接缩去了。这时候我们定位到的是一条边。

所以一个子串要么定位到一个固定的点，要么对应到一条固定边上的一个被“压缩”掉的节点。

具体的定位方式有很多，树上倍增是其中一种。即预处理出后缀树上每个节点往上跳 $i$ 个父亲的结果，然后用类似于倍增 $\text{LCA}$ 的方法实现。

找到每个子串的对应位置后，由于这道题没有强制在线，我们不妨离线读入所有子串，全部插入进后缀树中，被“压缩”掉的节点复原出来，形成一颗新的树。

比如样例建出的树就长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/htxrlcwi.png)

其中 $\varnothing$ 表示的是空串（也就是这两个点应该是在一起的，只是为了方便拆成两个点），点 $1$ 至 $6$ 对应是 parent 树上的点，$7$ 至 $11$ 对应是因询问而插入的点。这里为了方便，对于每一次询问都新建了一个点。这样并不会导致复杂度变劣。

我们定义新树的点权为其表示字符串长度与在后缀树上父亲的长度之差。即 $w_u=len_u-len_{fa_u}$。

可以发现，如果 $u$ 代表的字符串是好的，那么 $u$ 到 $fa_u$ 边上的所有被缩掉点表示的字符串都是好的，总个数就是 $w_u$ 个。

这样原问题就转化为：给定一颗树，每次将一个点染色，定义子树大小是子树中染色点的数量，要求每次操作后输出满足子树大小 $>k$ 的所有点的点权和 与 $len_u$ 的最大值。

随着新点的插入，每个点的子树大小一定是单调不降的。同样，任取树上的一条链，从底向上其子树大小也是单调不降的。

而根据 parent 树的性质，从底向上的 $len_u$ 始终是单调递减的。

所以，对于任何一条链，当我们确定了这条链的最深的点，使得其满足子树大小 $>k$ 后，这条链上所有深度比它小的点都是符合条件的。

同时它的 $len_u$ 也是最长的。所以这样最深的满足条件的点的深度随新点的插入也是单调不降的。

于是我们对新树使用轻重链剖分。即对于一条链我们维护其深度最深的点的位置。一次修改操作对应前缀 $[1,l]\ +1$，每次修改后暴力判断最深的点会不会往下移动。如果会那么暴力更新最深的点的位置，同时修改答案。

为了保证复杂度，修改操作我们要 $O(1)$ 进行。

我们发现最深的点是一步一步向下跳的，考虑差分，先给总权值 $+1$，再给 $l+1$ 位置 $-1$，意思是这次 $+1$ 到 $l+1$ 位置就失效了。每次更新最深的点时加上这个位置的代价即可。

特别的，假如更新位置已经高于最深点位置，这种情况下这次更新不会造成任何影响，直接跳过即可。

由于总链长是 $O(n)$，每次将一个点染色需要跳 $\log n$ 条链，加上预处理时倍增的 $O(\log n)$，总时间复杂度 $O((n+m)\log n)$，空间 $O(n\log n)$。

注意这题有一个坑点，就是如果插入本质相同的子串应当只算一次。这个在插入时特判一下就好了。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<set>
#define ll long long
#define N 1000010
#define D 25
using namespace std;
int nxt[N<<2],to[N<<2],head[N<<1],rcnt;
void add(int u,int v){nxt[++rcnt]=head[u];to[rcnt]=v;head[u]=rcnt;}
int las=1,scnt=1,fa[N<<1],f[N][D],ch[N][26],len[N<<1],acnt,k;
int insert(int c)
{
    int p=las,q=las=++scnt;
    len[q]=len[p]+1;
    for(;p && !ch[p][c];p=fa[p]) ch[p][c]=q;
    if(!p) fa[q]=1;
    else
    {
        int np=ch[p][c];
        if(len[np]==len[p]+1) fa[q]=np;
        else
        {
            int nq=++scnt;
            memcpy(ch[nq],ch[np],sizeof(ch[nq]));
            len[nq]=len[p]+1;
            fa[nq]=fa[np];
            fa[np]=fa[q]=nq;
            for(;p && ch[p][c]==np;p=fa[p]) ch[p][c]=nq;
        }
    }
    return q;
}
int pos[N],nd[N];
vector<int>ad[N];
set<int>s[N];
bool cmp(int a,int b){return len[a]<len[b];}
int work()
{
    int l,r;
    scanf("%d%d",&l,&r);
    int u=pos[r];
    ++acnt;
    len[acnt]=r-l+1;
    for(int i=D-1;i>=0;i--)
        if(f[u][i] && len[f[u][i]]>=len[acnt]) u=f[u][i];
    if(s[u].count(r-l+1)) return 0;//特判重复的插入
    s[u].insert(r-l+1);
    ad[u].push_back(acnt);
    return acnt;
}
void build()
{
    for(int i=2;i<=scnt;i++)
    {
        int p=fa[i];sort(ad[i].begin(),ad[i].end(),cmp);//按长度排序后依次连边即可
        for(int v:ad[i]) add(p,v),p=v;
        add(p,i);
    }
}
int son[N<<1],siz[N<<1],dep[N<<1],ldep[N<<1];
void dfs1(int u)
{
    siz[u]=1;
    ldep[u]=1;
    for(int i=head[u];i;i=nxt[i])
    {
        int v=to[i];dep[v]=dep[u]+1;
        fa[v]=u;
        dfs1(v);
        if(siz[v]>siz[son[u]]) son[u]=v;
        siz[u]+=siz[v];
    }
    ldep[u]=ldep[son[u]]+1;
}
int ar[N*20],par;
int* _new(int k){par+=k;return ar+(par-k);}//动态分配内存，减小常数
int* b[N<<1];int g[N<<1],d[N<<1];
int top[N<<1],pp[N<<1];
void dfs2(int u,int topp)
{
    top[u]=topp;
    if(son[u]) dfs2(son[u],topp);
    for(int i=head[u];i;i=nxt[i])
    {
        int v=to[i];
        if(v!=son[u]) dfs2(v,v);
    }
    if(u==topp) b[u]=_new(ldep[u]+1),pp[u]=u;
}
ll ans;int res;
void upd(int u)
{
    if(dep[u]<dep[pp[top[u]]]) return;
    b[top[u]][dep[u]-dep[top[u]]+1]--;g[top[u]]++;
    u=top[u];
    while(pp[u])
    {
        if(g[u]+b[u][dep[pp[u]]-dep[u]]>k)
        {
            ans+=len[pp[u]]-len[fa[pp[u]]];
            res=max(res,len[pp[u]]);
            g[u]+=b[u][dep[pp[u]]-dep[u]];
            pp[u]=son[pp[u]];
        }
        else break;
    }
}
void ins(int u){for(;u;u=fa[top[u]]) upd(u);}
char str[N];
int main()
{
    int n,m;
    scanf("%d%d%d%s",&n,&m,&k,str+1);
    for(int i=1;i<=n;i++) pos[i]=insert(str[i]-'a');
    for(int i=1;i<=scnt;i++) f[i][0]=fa[i];
    for(int j=1;j<D;j++)
        for(int i=1;i<=scnt;i++) f[i][j]=f[f[i][j-1]][j-1];
    acnt=scnt;
    for(int i=1;i<=m;i++) nd[i]=work();
    for(int i=1;i<=scnt;i++) s[i].clear();
    build();
    len[0]=-1;
    dfs1(1);dfs2(1,1);
    for(int i=1;i<=m;i++)
    {
        if(nd[i]) ins(nd[i]);
        printf("%lld %d\n",ans,res);
    }
    return 0;
}
```

---

## 作者：Owen_codeisking (赞：9)

$\text{SAM}$ 好题！前排膜拜出题人。

#### 前置芝士：SAM、树上倍增、线段树上二分

看到题目中韵脚的定义是最长公共后缀长度，而且 $N\le 5\times 10^5$ 只需 $\text{2.33s}$，可以猜测是一道正宗的 $\text{SAM}$ 题。

对字符串建出 $\text{SAM}$，用树上倍增将串挂在 $\text{SAM}$ 的对应位置。若直接在线做，要支持维护链并的数据结构，~~总之我不会~~，所以考虑反着做，算每个节点的贡献。因为只有插入操作没有删除操作，所以一个节点的贡献最多只有 $|P|+1$ 种，$|P|$ 为挂在这个结点串的个数。算出这些贡献对应的时间轴区间，就可以在答案序列差分一下，最后统一算。

那么问题就转化成算一个节点不同贡献的时间轴区间。

由于赛中没打，赛后想了两天，想到了一种比较好写的方法。

$\text{SAM}$ 上一个节点对应的长度区间是 $(len_{fa_p},len_p]$。设挂在这个节点的长度序列为 $l_0=len_{fa_p},l_1,l_1,...,l_{|P|},l_{|P|+1}=len_p$，我们算 $l_{i}-l_{i-1}(1\le i\le |P|+1)$ 的贡献。

使这段有贡献的最小的 $T$ 要满足从这个时刻开始，这个节点上 $\ge l_i$ 的串的个数+这个节点在 $\text{parent}$ 树上子树（不包括此节点）的串的个数 $>K$。前者可以在这个节点从大到小枚举，线段树上单点修改；后者可以线段树合并或者 $\text{dfs}$ 序上主席树。直接二分+验证显然会 $\text{TLE}$，那么可以在线段树上二分。时间 $\mathcal{O}((n+m)\log n)$。

~~自己感觉写的还是挺简洁的~~

注意，空串要特判。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fi first
#define se second
const int maxn=1000005;
const int inf=0x3f3f3f3f;
int n,m,k,ch[maxn][26],fa[maxn],len[maxn],pos[maxn],f[maxn][21],last=1,cnt=1;
char s[maxn]; ll ans[maxn][2];
vector<int> g[maxn];
vector<pii> p[maxn];
inline void insert(int c,int id)
{
	int p=last,q=++cnt; len[q]=len[p]+1,last=pos[id]=q;
	for(;p && !ch[p][c];p=fa[p]) ch[p][c]=q;
	if(!p) fa[q]=1;
	else
	{
		int r=ch[p][c];
		if(len[r]==len[p]+1) fa[q]=r;
		else
		{
			int s=++cnt; len[s]=len[p]+1;
			memcpy(ch[s],ch[r],sizeof(ch[r]));
			fa[s]=fa[r],fa[r]=fa[q]=s;
			for(;p && ch[p][c]==r;p=fa[p]) ch[p][c]=s;
		}
	}
}
inline void jump(int l,int r,int id)
{
	int L=r-l+1,x=pos[r];
	for(int i=20;i>=0;i--)
		if(f[x][i] && len[f[x][i]]>=L) x=f[x][i];
	p[x].push_back(pii(L,id));
}
int rt[maxn],ls[maxn*24],rs[maxn*24],sum[maxn*24],S[maxn<<2],sz;
void modify(int rt,int l,int r,int u,int v)
{
	S[rt]+=v;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(u<=mid) modify(rt<<1,l,mid,u,v);
	else modify(rt<<1|1,mid+1,r,u,v);
}
void update(int &rt,int l,int r,int u,int v)
{
	if(!rt) rt=++sz,ls[rt]=rs[rt]=sum[rt]=0;
	sum[rt]+=v;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(u<=mid) update(ls[rt],l,mid,u,v);
	else update(rs[rt],mid+1,r,u,v);
}
int merge(int x,int y)
{
	if(!x || !y) return x|y;
	ls[x]=merge(ls[x],ls[y]);
	rs[x]=merge(rs[x],rs[y]);
	sum[x]=sum[ls[x]]+sum[rs[x]];
	return x;	
}
int query(int u,int v,int l,int r,int k)
{
	if(l==r) return sum[u]+S[v]<=k?l:0;
	int mid=(l+r)>>1,siz=sum[ls[u]]+S[v<<1];
	if(k<siz) return query(ls[u],v<<1,l,mid,k);
	else return max(mid,query(rs[u],v<<1|1,mid+1,r,k-siz));
}
void dfs(int x)
{
	for(auto y:g[x])
		dfs(y),rt[x]=merge(rt[x],rt[y]);
	sort(p[x].begin(),p[x].end());
	int sz=(int)p[x].size();
	for(int i=sz-1;i>0;i--)
		if(p[x][i].fi!=p[x][i-1].fi)
		{
			if(p[x][i].se>0 && p[x][i].se<=m)
				modify(1,1,m,p[x][i].se,1);
			if(sum[rt[x]]+S[1]>k)
			{
				int T=query(rt[x],1,1,m,k)+1;
				if(T<=m)
					ans[T][0]=max(ans[T][0],(ll)p[x][i].fi),ans[T][1]+=p[x][i].fi-p[x][i-1].fi; 
			}	
		}
	for(int i=sz-1;i>0;i--)
		if(p[x][i].fi!=p[x][i-1].fi && p[x][i].se>0 && p[x][i].se<=m)
			modify(1,1,m,p[x][i].se,-1),update(rt[x],1,m,p[x][i].se,1);
}
int main()
{
	scanf("%d%d%d%s",&n,&m,&k,s+1);
	for(int i=1;i<=n;i++) insert(s[i]-'a',i);
	for(int i=2;i<=cnt;i++) g[fa[i]].push_back(i);
	for(int i=1;i<=cnt;i++) f[i][0]=fa[i];
	for(int j=1;j<=20;j++)
		for(int i=1;i<=cnt;i++)
			f[i][j]=f[f[i][j-1]][j-1];
	for(int i=2;i<=cnt;i++) p[i].push_back(pii(len[fa[i]],0));
	int l,r;
	for(int i=1;i<=m;i++)
		scanf("%d%d",&l,&r),jump(l,r,i);
	for(int i=2;i<=cnt;i++) p[i].push_back(pii(len[i],inf));
	dfs(1),ans[k+1][1]++;
	for(int i=1;i<=m;i++)
		ans[i][0]=max(ans[i][0],ans[i-1][0]),ans[i][1]+=ans[i-1][1],printf("%lld %lld\n",ans[i][1],ans[i][0]);
	return 0;
}
```

---

## 作者：万弘 (赞：5)

在[我的博客](https://oierwanhong.cc/2020/11/03/Luogu%20P7046%20%E3%80%8CMCOI-03%E3%80%8D%E8%AF%97%E9%9F%B5/)中查看


给一个串 $ T $ ，和一个大小为 $ m $ 的子串集合 $ \{T[l_i,r_i]|1\le i\le m\} $ ,记为 $ S $ .和一个定值 $ K $ .

定义 $ \text{CS}(A) $ 表示 $ A $ 中所有串的 CS（公共后缀）的集合。

求 $ |{\bigcup_{A\subset S,|A|>K}}\ \text{CS(A)}| $ 和 $ \max_{A\subset S,|A|>K}\max(\text{CS(A)}) $ .

 $ |T|\le 5\times 10^5,m\le 5\times 10^5,0\le K\le m. $   可能形式化之后反而不太清楚了，可以去看看原题面。

这里介绍一种重工业做法。


先建 T 的 SAM。对于每个 $ T[l_i,r_i] $ 我们找到其在SAM上的对应节点（最浅的满足 $ maxlen\ge r_i-l_i+1 $ 的点）。如果这个串的长度恰好等于该点的 $ maxlen $ ，那么其贡献就是该点到根的路径上所有点出现次数+1；否则对这个点来说，长度 $ \le r_i-l_i+1 $ 的串出现次数+1，然后祖先的出现次数+1.一个点表示的不同串的出现次数不同很难搞，干脆直接给这个子串新建一个点，放在原本的点和原本的父亲中间，就能保证每个点表示的所有串出现次数都相同（这样加点后我们仍然保留了parent 树最重要的性质，即祖先表示的串都是当前串的后缀）

那么现在我们就要支持三种操作：

0. 在一条链上找到一个最浅的点满足 $ maxlen\ge r-l+1 $ .同时可能要在这个点和其父亲中加入一个点
1. 链上所有点出现次数+1
2. 询问整棵树上所有满足出现次数 $ >k $ 的子串的数量和最大长度。

~~什么毒瘤~~

对于操作0，由于要动态加点，倍增没法维护，那就用 LCT 维护，并令 splay 上每个点维护一下子树中最大len值，找一个最浅的满足 $ maxlen\ge r-l+1 $ 的点就先`access`然后在 splay 上二分找。

此外可以发现我们先做完所有0操作再去做1和2不会对答案产生任何影响，即对于操作1,2，树是静态的。

但还是不太可做，强行做可能会出现树剖然后树套树的诡异东西。转而考虑离线，对加点后的 SAM 上每个点求其出现次数 $ >k $ 的最早时间。这东西我们可以整体二分，然后链加变成单点修改询问子树和，就可以在dfs序上建树状数组维护了。

令加点后的 parent 树点数为 $ n $ ,则复杂度分析如下：

0操作的总复杂度是 $ \mathcal O(m\log n) $ ,log 是 LCT 的 log。LCT 只要用有根树 LCT，所以常数也不太大。

1和2操作的总复杂度 $ \mathcal O((n+m)\log^ 2n) $ .由于树状数组常数爆小，所以能过。

```cpp
/**********/
#define MAXN 2000011
int n,m,k,dfn[MAXN],edn[MAXN],cur;
namespace BIT
{
	int t[MAXN];
#define lowb (i&-i)
	void modify(int i,int k)
	{
		while(i<=cur)t[i]+=k,i+=lowb;
	}
	int Qsum(int i)
	{
		int res=0;
		while(i)res+=t[i],i-=lowb;
		return res;
	}
	int Qsum(int l,int r){ return Qsum(r)-Qsum(l-1);}
}

namespace SAM
{
	int t[MAXN/2][26],pre[MAXN],len[MAXN];
	int last=1,tot=1;
	void extend(int w)
	{
		int pos=last,cur=++tot;
		len[cur]=len[pos]+1,last=cur;
		while(pos&&!t[pos][w])t[pos][w]=cur,pos=pre[pos];
		if(!pos){pre[cur]=1;return;}
		int nxt=t[pos][w];
		if(len[nxt]==len[pos]+1)pre[cur]=nxt;
		else
		{
			int tmp=++tot;
			len[tmp]=len[pos]+1,memcpy(t[tmp],t[nxt],sizeof t[nxt]);
			pre[tmp]=pre[nxt],pre[cur]=pre[nxt]=tmp;
			while(pos&&t[pos][w]==nxt)t[pos][w]=tmp,pos=pre[pos];
		}
	}
}
struct LCT
{
    int fa[MAXN],son[MAXN][2],mx[MAXN];
    void init(){for(int i=2;i<=SAM::tot;++i)fa[i]=SAM::pre[i];}
    bool not_root(int x){return son[fa[x]][0]==x||son[fa[x]][1]==x;}
    void pushup(int x){mx[x]=max(SAM::len[x],max(mx[son[x][0]],mx[son[x][1]]));}
	void rotate(int x)
    {
        int y=fa[x],z=fa[y],k=(son[y][1]==x);
        if(not_root(y))son[z][son[z][1]==y]=x;
        fa[x]=z;
        son[y][k]=son[x][!k],fa[son[x][!k]]=y;
        son[x][!k]=y,fa[y]=x;
		pushup(y);
    }
	void splay(int x)
	{
		while(not_root(x))
		{
			int y=fa[x];
			if(not_root(y))rotate((son[y][1]==x)==(son[fa[y]][1]==y)?y:x);
			rotate(x);
		}
		pushup(x);
	}
	void access(int x)
	{
		for(int y=0;x;y=x,x=fa[x])
			splay(x),son[x][1]=y;
	}
	void link(int x,int y){access(x),splay(x),fa[x]=y;}
	void cutfa(int x){access(x),splay(x), fa[son[x][0]]=0,son[x][0]=0,pushup(x);}
	int find(int x,int len)
	{
		access(x),splay(x);
		while(1)
		{
			if(mx[son[x][0]]>=len)x=son[x][0];
			if(SAM::len[x]>=len)break;
			x=son[x][1];
		}
		return splay(x),x;
	}
}lct;
struct edge{int v,nxt;}e[MAXN<<1|1];
int cnt=0,last[MAXN];
void adde(int u,int v){e[++cnt].v=v,e[cnt].nxt=last[u],last[u]=cnt;}
void dfs(int u)
{
	dfn[u]=++cur;
	for(int i=last[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v!=SAM::pre[u])dfs(v);
	}
	edn[u]=cur;
}
int ed[MAXN];
char ss[MAXN];
struct one{int u,r;}a[MAXN],la[MAXN],ra[MAXN];
int res[MAXN],node[MAXN];
ll c[MAXN],mx[MAXN];
void solve(int begin,int end,int dep,int l,int r)
{
	if(begin>end)return;
	if(l==r)
	{
		for(int i=begin;i<=end;++i)res[a[i].u]=l;
		return;
	}
	int mid=(l+r)>>1,itl=0,itr=0;
	for(int i=l;i<=mid;++i)
		if(node[i])BIT::modify(dfn[node[i]],1);
	for(int i=begin;i<=end;++i)
	{
		int c=BIT::Qsum(dfn[a[i].u],edn[a[i].u]);
		if(a[i].r<=c)la[++itl]=a[i];
		else a[i].r-=c,ra[++itr]=a[i];
	}
	for(int i=l;i<=mid;++i)
		if(node[i])BIT::modify(dfn[node[i]],-1);
	for(int i=1;i<=itl;++i)a[begin+i-1]=la[i];
	for(int i=1;i<=itr;++i)a[begin+itl+i-1]=ra[i];
	solve(begin,begin+itl-1,dep+1,l,mid),solve(begin+itl,end,dep+1,mid+1,r);
}
bool vis[MAXN];
int main()
{
	n=read(),m=read(),k=read();
	scanf("%s",ss+1);
	for(int i=1;i<=n;++i)SAM::extend(ss[i]-'a'),ed[i]=SAM::last;
	lct.init();	
	for(int i=1;i<=m;++i)
	{
		int l=read(),r=read();
		int p=lct.find(ed[r],r-l+1);
		if(SAM::len[p]==r-l+1)node[i]=vis[p]?0:p;
		else{SAM::len[++SAM::tot]=r-l+1,SAM::pre[SAM::tot]=SAM::pre[p],SAM::pre[p]=SAM::tot,lct.cutfa(p),lct.link(SAM::tot,SAM::pre[SAM::tot]),lct.link(p,SAM::tot);node[i]=SAM::tot;}
		vis[node[i]]=1;
	}
	for(int i=1;i<=SAM::tot;++i)a[i]=one{i,k+1},adde(SAM::pre[i],i);
	dfs(1);
	SAM::len[0]=-1;
	solve(1,SAM::tot,0,1,m+1);
	for(int i=1;i<=SAM::tot;++i)c[res[i]]+=SAM::len[i]-SAM::len[SAM::pre[i]],umax(mx[res[i]],SAM::len[i]);
	for(int i=1;i<=m;++i)c[i]+=c[i-1],umax(mx[i],mx[i-1]),printf("%lld %lld\n",c[i],mx[i]);
	return 0;
}

```



---

## 作者：Elma_ (赞：4)

前半部分做法和其他题解相同，先用 SAM 建出 $T$ 的后缀树，然后用树上倍增把询问挂到对应的点上，建一棵新树复原出被压缩的询问节点。这里不再赘述，详细做法可以参考其他题解。

对后半部分的处理这里给一个比较简单的做法：由于子串 $s'$ 为子串 $s$ 的后缀当且仅当在后缀树中 $s$ 对应的节点在 $s'$ 对应节点的子树中，因此假设当前树上有若干询问点打了标记，我们想知道某个子串 $s$ 是否是一个合法的韵脚，只需找到 $s$ 对应的节点，查询子树中的标记数量是否大于 $K$ 即可。这可以使用树状数组维护。

注意到，每次往树上的某个节点打标记时，只有该点到根的路径上的点的状态可能会被更新（即从不为韵脚变为一个合法的韵脚），并且子树中的标记数量具有单调性，这意味着合法的韵脚所对应的点一定会形成一个包含根节点的连通块。显然，每个节点只会被更新一次，因此每次给某个节点打标记时只需倍增往上找第一个没有被更新的点进行更新，直到找到了一个不为韵脚的点或者这个点到根的路径上所有点都被更新为止。时间复杂度 $O((n+m) \log n)$，稍微有点卡空间。

```cpp
const int MN = 1.5e6 + 5;

int N, M, K, Ans2; long long Ans1; char Str[MN];

int lst, cnt, len[MN], nxt[MN], ch[MN][26];
inline void Insert(int c) {
    int p = lst, o = ++cnt;
    len[o] = len[p] + 1;
    while (p && !ch[p][c]) ch[p][c] = o, p = nxt[p];
    if (!p) nxt[o] = 1;
    else {
        int q = ch[p][c];
        if (len[q] == len[p] + 1) nxt[o] = q;
        else {
            int cl = ++cnt;
            for (int i = 0; i < 26; i++) ch[cl][i] = ch[q][i];
            len[cl] = len[p] + 1, nxt[cl] = nxt[q], nxt[q] = nxt[o] = cl;
            while (ch[p][c] == q) ch[p][c] = cl, p = nxt[p]; 
        }
    }
    lst = o;
}

struct Node {
    int nxt, to;
} e[MN];
int fr[MN], tot;
inline void add(int u, int v) {
    e[++tot] = (Node){ fr[u], v }, fr[u] = tot;
}

int pos[MN], L[MN], R[MN], fa[MN][20], st[MN], ed[MN], dfc, p[MN], pN, pr[MN], id[MN], vis[MN];
set <int> s[MN]; vector <int> Buc[MN];
set <int> :: iterator it;
inline void DFS(int u) {
    st[u] = ++dfc;
    for (int p = fr[u], v; p; p = e[p].nxt) {
        v = e[p].to, fa[v][0] = u, DFS(v);
    }
    ed[u] = dfc;
}
inline void Work(int o, int l, int r) {
    int p = pos[r], x = r - l + 1;
    for (int i = 19; i >= 0; i--) {
        if (len[fa[p][i]] >= x) p = fa[p][i];
    }
    if (!s[p].count(x)) s[p].insert(x), Buc[p].pb(o); 
}

struct BIT {
    int tr[MN];
    inline int lowbit(int x) {
        return x & (-x);
    }
    inline void Modify(int x, int k) {
        for (int i = x; i <= cnt; i += lowbit(i)) tr[i] += k;
    }
    inline int Query(int x) {
        int ret = 0;
        for (int i = x; i; i -= lowbit(i)) ret += tr[i];
        return ret;
    }
} T;

const int Diana_is_God = 1;

signed main(void) {
    N = read(), M = read(), K = read();
    scanf("%s", Str + 1), lst = cnt = 1;
    for (int i = 1; i <= N; i++) Insert(Str[i] - 'a'), pos[i] = lst;
    for (int i = 1; i <= cnt; i++) fa[i][0] = nxt[i];
    for (int j = 1; j <= 19; j++) {
        for (int i = 1; i <= cnt; i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];
    }
    for (int i = 1; i <= M; i++) L[i] = read(), R[i] = read(), Work(i, L[i], R[i]);
    for (int i = 1; i <= cnt; i++) p[i] = i, s[i].insert(len[i]);
    sort(p + 1, p + cnt + 1, [&](int i, int j){ return len[i] < len[j]; });
    pN = cnt, pr[cnt = 1] = 1;
    for (int i = 2; i <= pN; i++) {
        int x = p[i];
        sort(Buc[x].begin(), Buc[x].end(), [&](int i, int j) { return R[i] - L[i] < R[j] - L[j]; });
        pr[x] = pr[nxt[x]], it = s[x].begin();
        int j = 0; 
        while (Diana_is_God) {
            cnt++, add(pr[x], cnt), pr[x] = cnt;
            int w = *it;
            len[cnt] = w;
            while (j < (int)Buc[x].size() && R[Buc[x][j]] - L[Buc[x][j]] + 1 <= w) id[Buc[x][j]] = cnt, j++;
            it++;
            if (it == s[x].end()) break;
        }
        vector <int> (Buc[x]).swap(Buc[x]);
    }
    DFS(1), vis[0] = 1, len[0] = -1;
    for (int j = 1; j <= 19; j++) {
        for (int i = 1; i <= cnt; i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];
    }
    // for (int i = 1; i <= cnt; i++) printf("%lld %lld\n", st[i], ed[i]);
    for (int i = 1; i <= M; i++) {
        int p = id[i];
        if (!p) {
            printf("%lld %d\n", Ans1, Ans2);
            continue;
        }    
        // printf("Modify Node %lld on %lld\n", p, st[p]);
        T.Modify(st[p], 1);
        if (vis[p]) {
            printf("%lld %d\n", Ans1, Ans2);
            continue;
        }
        while (!vis[p]) {
            int x = p;
            for (int j = 19; j >= 0; j--) {
                if (!vis[fa[x][j]]) x = fa[x][j]; 
            }
            int w = T.Query(ed[x]) - T.Query(st[x] - 1);
            // printf("Query Node %lld : [%lld, %lld] = %lld\n", x, st[x], ed[x], w);
            if (w > K) vis[x] = 1, Ans1 += len[x] - len[fa[x][0]], Ans2 = max(Ans2, len[x]);
            else break;
        } 
        printf("%lld %d\n", Ans1, Ans2);
    }
    return 0; 
}
```


---

## 作者：FZzzz (赞：4)

看到 @Cadence 神仙场切了这题，于是在学校的时候无聊花两天想了个做法，先记录一下等会补代码。

就是你会发现我不会做这题，所以我们计算每个本质不同串的贡献。

离线把所有串先丢到 SAM 上去挂起来，然后计算贡献的时候把这些串弄下来和 SAM 本来就有的节点一起拆点建一个新树（代码里大概不需要显式建出），然后每个节点的贡献就可以一起算了。

每个节点当子树内已经有 $k+1$ 个子串被加到集合里了以后才会对答案有贡献，我们计算这个节点是啥时候开始有贡献的。拿一个线段树合并，然后线段树二分一下就可以了。

~~谜 语 人 题 解~~

我猜和 @Owen_codeisking 神仙的题解差不多？但是我不太看得懂他的题解（

------------
upd：代码
```cpp
#include<algorithm>
#include<vector>
#include<cstring>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=5e5+5;
int n,m,k;
char t[maxn];
int sz,last,len[maxn*2],link[maxn*2],nxt[maxn*2][26];
vector<int> ch[maxn*2];
void init(){
	sz=1;
	last=0;
	len[0]=0;
	link[0]=-1;
}
int extend(int c){
	int cur=sz++;
	len[cur]=len[last]+1;
	int p=last;
	while(p>=0&&!nxt[p][c]){
		nxt[p][c]=cur;
		p=link[p];
	}
	if(p<0) link[cur]=0;
	else{
		int q=nxt[p][c];
		if(len[p]+1==len[q]) link[cur]=q;
		else{
			int clone=sz++;
			len[clone]=len[p]+1;
			link[clone]=link[q];
			memcpy(nxt[clone],nxt[q],sizeof(nxt[q]));
			while(p>=0&&nxt[p][c]==q){
				nxt[p][c]=clone;
				p=link[p];
			}
			link[q]=link[cur]=clone;
		}
	}
	return last=cur;
}
int cur[maxn];
int size[maxn*2],hson[maxn*2];
void dfs1(int u){
	size[u]=1;
	hson[u]=-1;
	for(int i=0;i<(int)ch[u].size();i++){
		int v=ch[u][i];
		dfs1(v);
		size[u]+=size[v];
		if(hson[u]<0||size[v]>size[hson[u]]) hson[u]=v;
	}
}
vector<int> f;
int pos[maxn*2],top[maxn*2];
void dfs2(int u){
	pos[u]=f.size();
	f.push_back(u);
	if(hson[u]<0) return;
	top[hson[u]]=top[u];
	dfs2(hson[u]);
	for(int i=0;i<(int)ch[u].size();i++){
		int v=ch[u][i];
		if(v==hson[u]) continue;
		top[v]=v;
		dfs2(v);
	}
}
int find(int l,int r){
	int u=cur[r];
	while(top[u]&&len[link[top[u]]]>=r-l+1) u=link[top[u]];
	int lb=pos[top[u]],rb=pos[u];
	while(lb<rb){
		int mid=lb+(rb-lb)/2;
		if(len[f[mid]]>=r-l+1) rb=mid;
		else lb=mid+1;
	}
	return f[rb];
}
struct node{
	int l,r;
	node* ch[2];
	int s;
	node(int l,int r):l(l),r(r),s(0){
		ch[0]=ch[1]=0;
	}
	void modify(int x){
		s++;
		if(l==r) return;
		int mid=l+(r-l)/2;
		if(x<=mid){
			if(!ch[0]) ch[0]=new node(l,mid);
			ch[0]->modify(x);
		}
		else{
			if(!ch[1]) ch[1]=new node(mid+1,r);
			ch[1]->modify(x);
		}
	}
	int query(int k){
		if(l==r) return r;
		if(ch[0]&&k<=ch[0]->s) return ch[0]->query(k);
		else return ch[1]->query(ch[0]?k-ch[0]->s:k);
	}
};
node* merge(node* a,node* b){
	if(!a) return b;
	if(!b) return a;
	a->s+=b->s;
	a->ch[0]=merge(a->ch[0],b->ch[0]);
	a->ch[1]=merge(a->ch[1],b->ch[1]);
	delete b;
	return a;
}
node* rt[maxn*2];
typedef pair<int,int> pii;
vector<pii> q[maxn*2];
long long ans1[maxn];
int ans2[maxn];
void dfs(int u){
	rt[u]=new node(0,m-1);
	for(int i=0;i<(int)ch[u].size();i++){
		int v=ch[u][i];
		dfs(v);
		rt[u]=merge(rt[u],rt[v]);
	}
	sort(q[u].begin(),q[u].end());
	for(int i=(int)q[u].size()-1;i>=0;i--){
		if(i&&q[u][i].first==q[u][i-1].first) continue;
		if(q[u][i].second<m) rt[u]->modify(q[u][i].second);
        //这个做法的常数瓶颈：如果不加这个判断，时空会多两倍常数！
		if(rt[u]->s>k){
			int x=rt[u]->query(k+1);
			if(i) ans1[x]+=q[u][i].first-q[u][i-1].first;
			else ans1[x]+=u?q[u][i].first-len[link[u]]:1;
			ans2[x]=max(ans2[x],q[u][i].first);
		}
	}
}
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	m=readint();
	k=readint();
	scanf("%s",t+1);
	init();
	for(int i=1;i<=n;i++) cur[i]=extend(t[i]-'a');
	for(int i=1;i<sz;i++) ch[link[i]].push_back(i);
	dfs1(0);
	dfs2(0);
	for(int i=0;i<m;i++){
		int l,r;
		l=readint();
		r=readint();
		int u=find(l,r);
		q[u].push_back(pii(r-l+1,i));
	}
	for(int i=0;i<sz;i++) q[i].push_back(pii(len[i],m));
	dfs(0);
	for(int i=1;i<m;i++){
		ans1[i]+=ans1[i-1];
		ans2[i]=max(ans2[i],ans2[i-1]);
	}
	for(int i=0;i<m;i++) printf("%lld %d\n",ans1[i],ans2[i]);
	return 0;
}
```

---

## 作者：鏡音リン (赞：1)

题意：维护一个字符串集合，支持加入给定母串的一个子串，查询至少为集合内 $K+1$ 个元素的后缀的字符串的个数，和它们的最长长度。

暴力思路：每次加入一个字符串时，就给它所有的后缀打一次标记。那么我们要维护的就是那些被打了至少 $K+1$ 次标记的串。字符串到标记次数的对应关系可以用哈希表维护，时间复杂度 $O(NM)$。

考虑如何对这个思路进行优化。注意到一个串的所有后缀对应了后缀自动机 fail 树上这个串对应节点的所有父节点。我们可以建出后缀自动机 fail 树，就可以把所有后缀标记转化为某点到根的链标记。这里有一个小问题，后缀自动机上的节点是一个等价类，可能会出现要打标记的串是这个节点的一部分这种情况。可以按照长度进行拆点，保证每次标记的都包含了整个节点。

拆完点我们得到了一棵树，现在要做的是：某点到根的链打标记，查询标记至少 $K+1$ 次的点的信息。有两种做法：

在线做法，用重链剖分或者全局平衡二叉树把链修改转化为区间修改，由于每个点只会在第 $K+1$ 次标记的时候更新一次，因此可以直接在线段树上暴力更新。复杂度 $O(M\log^2N+N\log N)$（朴素重链剖分）或者 $O((M+N)\log N)$（全局平衡二叉树）。

离线做法，我们只需要知道每个点第 $K+1$ 次标记是在什么时候。把每次链修改操作的时间插入到链底节点上，那么某个点第 $K+1$ 次标记的时间就是子树里第 $K+1$ 小的数字。通过 dfs 序把子树查询转化成区间查询，这是个静态区间 kth 问题，可以主席树解决。时间复杂度 $O((N+M)\log N)$。子树 kth 用线段树合并也是可以的，时间复杂度相同。

---

## 作者：_Wind_Leaves_ShaDow_ (赞：0)

[P7076](https://www.luogu.com.cn/problem/P7046)。

### 前言

前排提醒一下，题目中相同子串只保留一个指对于 $Q$ 个子串中若存在 $i<j$ 且 $s[l_i,r_i]=s[l_j,r_j]$，则第 $j$ 次插入作废。

所以 [这篇题解](https://www.luogu.com.cn/article/pokm5vru) 对于 SAM 的初始节点的处理其实是有误的，因为前 $k+1$ 次插入操作中可能有操作无效。

### 题解

注意到题目中涉及的都是后缀相关查询，很容易想到后缀数据结构。考虑把 SAM 建出来。

查询 $s[l,r]$ 是简单的，保存每个前缀 $s[1,i]$ 在 SAM 上的位置 $ep_i$，在 parent 树上倍增跳到最深的长度 $\le r-l+1$ 的节点即为 $s[l,r]$ 处于的节点。

插入一个字符串很直观的就是在树上该点到父亲的路径上的所有点出现次数加一，两种询问分别为查询出现次数 $>k$ 的子串个数和最大长度。

如果我们知道一个串在哪些时候被插入了就可以很好地维护以上两种查询，于是很经典地想到线段树二分寻找第 $k+1$ 次插入在哪里。所以每次插入时在插入的点上标记时刻，离线下来做线段树合并即可。若一个串在 $t$ 时刻第一次造成贡献，则其会在所有 $T\ge t$ 的时刻 $T$ 造成贡献，直接差分维护即可。

然而以上所有讨论均基于只有一个子串，而实际上 SAM 中一个节点 $p$ 包含了 $le_p-le_{lk_p}$ 个子串（$le$ 为 maxlen，$lk$ 为其 parent 树上的父亲）。

考虑在当前节点插入长度为 $d_1$ 的子串会对所有 $d_2\le d_1$ 的子串产生贡献，启发我们按照插入字串的长度从大到小排序，防止插入的小串对大串产生不必要贡献。

对于相同子串的判定，显然若两个子串在 SAM 上位于同一个节点且长度相同则两子串相同，也就是每一个长度只需记录一次也就是最早的一次插入。

[record](https://www.luogu.com.cn/record/226965356)，码风并不是很好看。

```cpp
#include <bits/stdc++.h>
#define lint __int128
// #define int long long
#define Il inline
#define fi first
#define se second
#define vec vector
#define pb push_back
#define IT ::iterator
#define p_q priority_queue

using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef double db;
const int N=1e6;
const db eps=1e-9,pi=acos(-1.0);

mt19937 rnd(time(0));
Il int rint(int l,int r){return rnd()%(r-l+1)+l;}

int n,kk,Q,lg[N+5],ep[N+5],a2[N+5];
ll a1[N+5];
int sz=1,las=0,sam[N+5][30],le[N+5],lk[N+5][25],rt[N+5],ls[N*30+5],rs[N*30+5],sm[N*30+5],id=0;
vec<int>v[N+5];
vec<pii>qu[N+5];//位于该点的插入操作
string s;

Il void ins(int c){
    int p=sz++,ps=las;las=p,le[p]=le[ps]+1;
    for(;(~ps)&&!sam[ps][c];ps=lk[ps][0])sam[ps][c]=p;
    if(ps<0)return;
    if(le[ps]+1==le[sam[ps][c]])lk[p][0]=sam[ps][c];
    else{
        int np=sz++,fp=sam[ps][c];le[np]=le[ps]+1,lk[np][0]=lk[fp][0],lk[fp][0]=lk[p][0]=np;
        for(int i=0;i<26;i++)sam[np][i]=sam[fp][i];
        for(;(~ps)&&sam[ps][c]==fp;ps=lk[ps][0])sam[ps][c]=np;
    }
    return;
}

Il int merge(int x,int y){
    if(!x||!y)return x|y;
    if(!ls[x]&&!rs[x]&&!ls[y]&&!rs[y]){sm[x]|=sm[y];return x;}
    ls[x]=merge(ls[x],ls[y]),rs[x]=merge(rs[x],rs[y]);
    sm[x]=sm[ls[x]]+sm[rs[x]];
    return x;
}

Il int qur(int l,int r,int p,int K){
    if(sm[p]<K)return 0;
    if(l==r)return l;
    int mid=(l+r)>>1;
    return sm[ls[p]]>=K?qur(l,mid,ls[p],K):qur(mid+1,r,rs[p],K-sm[ls[p]]);
}

Il void add(int ps,int l,int r,int &p){
    if(!p)p=++id;
    sm[p]++;if(l==r)return;
    int mid=(l+r)>>1;
    if(ps<=mid)add(ps,l,mid,ls[p]);
    else add(ps,mid+1,r,rs[p]);
    return;
}

Il void dfs(int p){
    for(int i:v[p])dfs(i),rt[p]=merge(rt[p],rt[i]);
    sort(qu[p].rbegin(),qu[p].rend());//从大到小排序
    int lal=le[p];//上一次插入的长度为 lal 这一次插入的长度为 le，显然总共包含 lal-le 个子串
    for(int i=0,j=0;i<(int)qu[p].size();lal=qu[p][i].fi,i=j+1){
        while(j+1<(int)qu[p].size()&&qu[p][j+1].fi==qu[p][i].fi)j++;
        int tk=qur(1,Q,rt[p],kk);if(tk)a1[tk]+=lal-qu[p][i].fi,a2[tk]=max(a2[tk],lal);
        add(qu[p][j].se,1,Q,rt[p]);//由于 pair 的双关键字排序长度相同时编号小的会排在后面。
    }
    int tk=qur(1,Q,rt[p],kk);if(tk)a1[tk]+=(p?lal-le[lk[p][0]]:1),a2[tk]=max(a2[tk],lal);
    return;
}

signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>Q>>kk>>s;kk++,s=" "+s;lk[0][0]=-1;for(int i=1;i<=n;i++)ins(s[i]-'a'),ep[i]=las;
    for(int i=1;i<sz;i++)v[lk[i][0]].pb(i);
    for(int i=2;i<=sz;i++)lg[i]=lg[i>>1]+1;
    for(int j=1;j<=lg[sz];j++)for(int i=1;i<sz;i++)lk[i][j]=lk[lk[i][j-1]][j-1];
    for(int _=1;_<=Q;_++){
        int lq,rq,pp;cin>>lq>>rq;if(mp[lq][rq])continue;
        pp=ep[rq],mp[lq][rq]=1;
        for(int k=lg[sz];~k;k--)if((~lk[pp][k])&&le[lk[pp][k]]>=rq-lq+1)pp=lk[pp][k];
        qu[pp].pb({rq-lq+1,_});
    }
    dfs(0);for(int i=1;i<=Q;i++)cout<<(a1[i]+=a1[i-1])<<' '<<(a2[i]=max(a2[i],a2[i-1]))<<'\n';
    return 0;
}
```

---

## 作者：yzy1 (赞：0)

### 声明

在本篇题解的复杂度表示时，记字符串字符集大小为 $|\Sigma|$，且认为 $N,M,K$ 同阶．

### 题目大意

维护一个字符串集合，支持插入固定母串的一个子串．每插入一个串后输出有多少个本质不同的字符串是集合中至少 $(K+1)$ 个字符串的后缀，以及满足上述要求的最长的字符串的长度．允许离线．

### 做法 $\bf 1$

考虑维护一个哈希表，每次插入一个串后，计算出其所有后缀的哈希值，将哈希表对应键值 $+1$，记录每个串出现第 $(K+1)$ 次出现的时间．最后前缀和即可．

时间复杂度 $O(N^2)$，空间复杂度 $O(N^2)$，期望得分 $35$ pt．

### 做法 $\bf 2$

显然所有符合条件的字符串都是母串的一个子串，考虑建立对于母串的后缀树．对于后缀树的每个结点维护一个权值．每次插入一个串后，将这个串的所有后缀对应后缀树的结点的权值 $+1$．并维护每个权值第一次大于等于 $(K+1)$ 的时刻．然后使用类似做法 1 的方法解决．

根据后缀树的性质，一个串的后缀对应的结点一定是这个串对应的结点或者该结点的祖先．因此，我们可以得到一个推论：

> 每次向集合插入字符串时相当于把这个字符串所对应结点到根路径上的点权 $+1$．

但你会发现上述推论是错误的，考虑当母串 $= \texttt{abc}$ 时，依次插入 $\texttt{bc}$ 和 $\texttt{c}$．由于这两个字符串的 endpos 集合相等，即对应后缀树上的结点相同，故上述做法会认为字符串 $\texttt{bc}$ 作为了集合中 $2$ 个串的后缀出现，得到错误的答案．

解决此问题的一种方式是对后缀树上的每个结点进行拆点．根据 endpos 等价类的性质，对于同一等价类，将类中的所有子串按长度非递增的顺序排序，每个子串都不会比它前一个子串长，与此同时每个子串也是它前一个子串的后缀．我们可以将后缀树上的每个结点拆成一条链，链中结点个数等于该结点对应字符串的个数．以此保证正确性．但我们发现，若按照上述方法拆点后得到的树中的结点个数等于母串的本质不同子串个数，其是 $O(N^2)$ 级别．观察发现，拆点后得到的树有些点是「不需要拆」的，考虑询问离线，只拆需要拆的点，得到一个类似类似虚树的东西，以此同时保证正确性和时间复杂度．

接下来要解决的是如何在后缀树上定位一个区间对应的结点．考虑构建 SAM 时记录母串的每个前缀对应的结点．预处理倍增父亲数组，查询时从前缀对应的结点开始向上倍增跳，跳到深度最小的满足 $\mathrm{len} \ge r-l+1$ 的结点即位符合要求的结点．

考虑采用重链剖分和线段树维护树上修改．线段树维护区间最大值，由于每个值只会由小于 $K$ 到大于等于 $K$ 变换一次．故可以做以下转化：每次修改后二分出第一个大于 $K$ 的位置，记录后将其修改为 $-\infty$．

时间复杂度 $O(N|\Sigma| + N \log^2 N)$，空间复杂度 $O(N|\Sigma| + N \log N)$，期望得分 $60$ pt．

### 做法 $\bf 3$

前面部分应该是无法再继续优化了，考虑优化后面的数据结构部分．

考虑一种离线方式，在每个结点上放一个时间维的线段树，第 $i$ 次链加就把链端点上的线段树 $i$ 位置 $+1$，最后 DFS 一遍把儿子的线段树合并到父亲上，线段树上二分出第一个前缀和大于 $K$ 的位置，就为第一次变化到权值大于 $K$ 的时间．

需要特别注意的是，倍增数组大小只需开到 SAM 的结点数即可，不要因为开了过大数组造成内存超限．

时间复杂度 $O(N|\Sigma| + N \log N)$，空间复杂度 $O(N|\Sigma| + N \log N)$，期望得分 $100$ pt．

---


# [NWRRC 2014] Fragmentation

## 题目描述

Felix 正在他的车库里进行一个创业项目。他已经为他的项目找到了一个很棒的名字：SuperFastZilla。目前他还不确定 SuperFastZilla 应该做什么，但他非常确定它应该做得很快，超级快。

有一次他注意到 SuperFastZilla 的运行速度太慢，尽管它使用了快速算法。Felix 认为问题可能是由存储碎片引起的。

SuperFastZilla 使用的存储由 $n$ 个内存块组成。SuperFastZilla 在这个存储上执行一些操作。每个块只在一个操作中使用，第 $i$ 个块在第 $a_{i}$ 个操作中使用。

Felix 想按它们使用的操作索引对这些块进行排序。为了加快速度，Felix 想将存储分成最少数量的连续块段，然后重新排列这些段以获得排序后的块数组。重新排列后，块的操作索引顺序必须是非递减的。

帮助 Felix 找到一种分割存储的方法，以最小化段的数量。

例如，如果 $a = [2 , 3 , 1 , 1 , 2 , 2 , 1]$，它可以分成三部分：$[2 , 3], [1 , 1 , 2 , 2]$ 和 $[1]$。这些部分可以重新排列以形成排序后的数组：$[1], [1 , 1 , 2 , 2], [2 , 3]$。

## 说明/提示

时间限制：2 秒，内存限制：256 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
7
2 3 1 1 2 2 1
```

### 输出

```
3
2 4 1
```

# 题解

## 作者：JoshAlMan (赞：10)

考虑降序的必须断开，离散化后不连续的必须断开，序列就变成大概是若干递增串（称之为块，给这样的每个块编个号qwq）的形式，然后可以连起来的段要满足的性质（充要）：

* 如果三个以上不同数值连起来，被包含在中间的数必须恰好所有同数值都在这个段里，否则就拼不进来了。
* 离散化后，连接 $(x, x+1)$ 这样的东西最多连一次。

如果假设最开始全断的化，要最大化连的次数。

这个东西似乎很难做，每段并不是独立的，看样子需要按数值顺序做安排。

想到（我就想不到呜呜呜）如果 $\le x$ 要如何连都安排好了，那么后续再连，前面对后面决策的可行性有影响的只有 $(x - 1, x)$ 有没有连，连的哪个块：

* 如果 $(x, x+1)$ 不准备连那么不影响
* 若 $(x, x +1)$ 连的块不是 $(x - 1,x )$ 的块，那么显然咋搞都行
* 如果是相同的块，那么就要检查是否 $x$ 全部出现在这个块作为可行的要求。

因此我们可以设一个 DP：

* $f_{i, j}$ 表示连接到数值 $i$，$(i - 1, i)$ 连的块编号是 $j$（没连搞成 $0$），最大化连的次数。

* 转移就枚举 $(i - 2, i - 1)$ 连的块是啥

  * $f_{i,0}=\max(f_{i-1,j})$

  * $f_{i, j} = \max_{k\not= j}(f_{i - 1, k} + 1)$
  * 同一块内的转移要满足 $i - 1$ 全部出现在这个块里，式子也是同上。 

别看是二维 DP，但实际的状态数应该是 $O(n)$ 的，因为每一个状态都一一对应着一个块内连续对。

然后考虑转移，暴力转移是 $O(n^2)$ 的。优化也挺显然，前后缀 $\max$ 再加自身转移特判，每次转移做到 $O(1)$。（具体实现来回扫一遍双指针）

总复杂度 $O(n)$。



---

## 作者：St_john (赞：5)

发现连续相同的数字是可以合并成一段的。  
对于相邻不同的数字，可以合并的充分条件之一是两个数字是升序。  
**这不是充要条件。**  
举个例子。  
```cpp
8
2 3 1 1 2 2 1 2
``` 
显然，如果贪心的对相邻的合并，发现最后重排失败。  


可以用DP来解决一下最优性合并问题。  
离散化后，标记每一段的结尾。  
进行DP。  
设 $f_i$ 表示在 $\leqslant a_i$ 的段以 $i$ 为结尾重排后有序，不同段最多合并的次数。  
枚举时要数值从小到大。  
最后要输出段数，所以保存路径。  
转移时，分类讨论。  
1. 下一个不是紧接着的下一个数值，根本不用考虑连接的事。
1. 当前数值的只有一个，那就直接连接，合并的次数 $+1$ 。
1. 当前数值不止一个，但上一位是上一个数值的 $f$ 最大值，如果直接连接，那就会重排后不能保持升序。此时就直接连接次大值即可，合并次数 $+1$ 。  
1. 当前数值不止一个，上一位不是上一个数值的 $f$ 最大值，可以直接连接，合并次数 $+1$ 。

往回倒序找路径时，就可以选择没有合并的地方，做标记，最后输出即可。 
```cpp
#include<cstdio>
#include<vector>
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
#define Re register int
#define il inline
#define pc putchar
using namespace std;
typedef long long ll;
const int N=5e5+10,M=1e6+10,inf=2147483647;
il int re(){
	int x=0;
	bool f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		f|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
void pr(int x){
	if(x<0) pc('-'),x=-x;
	if(x>9) pr(x/10);
	pc(x%10|48);
}

int a[N],pre[N],nxt[N],f[N],from[N];
vector<int> s[M];
bool have[N];

signed main(){
	int n=re();
	int x=0,num=0,mx=0;
	_for(i,1,n){
		a[i]=re();
		if(a[i]>mx) mx=a[i];
	}
	_for(i,1,n)
		if(a[i]!=a[i+1]){
			have[i]=1;//将每一段的末尾标记
			++num;
			s[a[i]].push_back(i);
			pre[i]=x;
			x=i;
		}
	x=0;
	_for(i,1,mx)
		if(!s[i].empty()){
			nxt[x]=i;
			x=i;
		}
	int m1=0,m2=0,m1f=0,m2f=0;
	for(Re i=nxt[0];i<mx;i=nxt[i])
		if(!s[i].empty()){
			int t1=0,t2=0,t1f=0,t2f=0;
			for(Re p:s[i]){
				if(a[p+1]!=nxt[a[p]]){//不是接下来的，不能连接
					f[p]=m1;
					from[p]=m1f;
				}
				else if(s[i].size()==1){//正好有一个，可以直接连接
					f[p]=m1+1;
					from[p]=m1f;
				}
				else if(pre[p]==m1f){
				//有许多个，且上一个是最大值，不能直接连接，会有其他的被排除在块外
					f[p]=m2+1;
					from[p]=m2f;
				}
				else{
					f[p]=m1+1;
					from[p]=m1f;
				}
				if(t1<f[p]){
					t2=t1;
					t2f=t1f;
					t1=f[p];
					t1f=p;
				}
				else if(t2<f[p]){
					t2=f[p];
					t2f=p;
				}
			}
			if(m1<t1){
				m2=m1;
				m2f=m1f;
				m1=t1;
				m1f=t1f;
			}
			else if(m2<t1){
				m2=t1;
				m2f=t1f;
			}
			if(m2<t2){
				m2=t2;
				m2f=t2f;
			}
		}
	pr(num-m1),pc('\n');
	x=m1f;
	while(x){
		if(f[x]!=f[from[x]]) have[x]=0;
  //合并过，那就直接赋值为0
		x=from[x];
	}
	x=0;
	_for(i,1,n)
		if(have[i]){
			pr(i-x),pc(' ');
			x=i;
		}
	return 0;
}
```


---


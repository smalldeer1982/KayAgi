# [NWRRC 2013] Intellectual Property

## 题目描述

Erast Kopi 是一位著名的数独谜题设计师。他的谜题合集取得了巨大成功，引发了许多模仿和抄袭。在提出诉讼之前，他决定收集更多证据。

数独谜题是一个 $9 \times 9$ 的表格，分为 $3 \times 3$ 的子表格，每个子表格包含 $3 \times 3$ 的单元格。每个单元格可以包含从 $1$ 到 $9$ 的一个数字。任务是用数字填充空单元格，使得每一行、每一列以及每个 $3 \times 3$ 的子表格都恰好包含从 $1$ 到 $9$ 的每个数字一次。

Kopi 有一个数独谜题数据库，他想检查其中是否包含相似的谜题。谜题 $P$ 与谜题 $Q$ 相似，如果可以通过以下操作序列将谜题 $P$ 转换为谜题 $Q$：

选择两个数字 $x$ 和 $y$，并将所有数字 $x$ 替换为 $y$，反之亦然；

交换两组行：$(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$；

在一组行中交换两行；

交换两组列：$(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$；

在一组列中交换两列；

沿左上到右下轴翻转。此操作后，列变为行，反之亦然。

帮助 Kopi 在他的数据库中找到相似的谜题。

## 说明/提示

时间限制：2 秒，内存限制：256 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
4
.....1...
1........
.2.....8.
.........
8....9...
.........
....7....
...2...1.
2...4....

....2....
...7.4...
8.......9
.8...2..1
..2......
.........
.........
..1.8....
.........

1........
.........
.........
.........
.........
.........
.........
.........
.........

.....1...
1........
.2.....8.
.........
8....9...
.........
....7....
...2...1.
2...4....
```

### 输出

```
Yes
7
C 1 2
D 5 3
F
r 7 9
c 6 5
C 2 3
D 1 8
No
Yes
0
No
Yes
8
R 1 2
C 2 3
c 4 5
F
r 5 6
c 7 9
D 1 8
D 3 5
No
```

# 题解

## 作者：Starlight237 (赞：1)

> 对于两个 $9\times9$ 数独谜题（不管是否有解）$A,B$，定义 $A$ 和 $B$ 等价当且仅当 $A$ 可以通过下列操作进行若干次变换后成为 $B$。
> - 选择两个数字 $x,y$，将所有 $x$ 变成 $y$，所有 $y$ 变成 $x$。
> - 在 $(1,2,3),(4,5,6),(7,8,9)$ 三个三元组中，选择两个，作为整体交换以它为下标的行。
> - 选择在同一个三元组中的两个数 $x,y$，交换谜题的第 $x$ 行和第 $y$ 行。
> - 在 $(1,2,3),(4,5,6),(7,8,9)$ 三个三元组中，选择两个，作为整体交换以它为下标的列。
> - 选择在同一个三元组中的两个数 $x,y$，交换谜题的第 $x$ 列和第 $y$ 列。
> - 把 $A$ 转置。

> 现在给定 $n(n\le20)$ 个数独谜题，判断它们两两是否等价。若等价，还需要输出一种变换的方法。`D x y` 表示将两个数字交换，`R a b` 表示整体交换三元组 $(3a-2,3a-1,3a),(3b-2,3b-1,3b)$ 对应的行，`r a b` 表示交换两个行，同理有 `C a b` 和 `c a b` 作为列操作。`F` 表示取转置。

下面考虑如何比较两个数独 $A,B$，首先不考虑具体的数字，交换行的操作一共有 1296 种，交换列的操作也一共有 1296 种。$A$ 同时做行变换和列变换等价于 $A$ 只做行变换，$B$ 只做列变换，因此可以把 $A$ 做行变换的结果用 Hash 表存起来即可，然后枚举对 $B$ 的列变换，看 $B'$ 是否在 Hash 表中出现过。类似 BSGS 算法的思想。

转置操作最多会进行一次，枚举是否转置即可。

由于任意两个数字可以交换，我们只需要设计一种对数值不敏感的 Hash，比如 $H(s_1,...,s_9)=H_0(s_1)+...+H_0(s_n)$，或者异或等，其中 $s_i$ 表示数字 $i$ 在数独上出现的位置集合，可以用一个 `unsigned int128` 压缩起来。若比较的时候发现两个 Hash 值不相等，那一定（在当前变换方法下）不等价，否则暴力比较两个 $\{s_i\}$ 集合。具体实现可以用 `std::map`，`std::unordered_map` 等 `STL` 结构。$H_0$ 是一个单值 Hash 函数，可以随自己的喜好实现。

---


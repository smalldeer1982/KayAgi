# 计数题

## 题目描述

您有一个无限大的集合，其中有所有小于等于 $n$ 的质数和其中它们的乘积。

如 $n=5$，集合中实际包含的数为 $2,3,5$（质数），$4,6,8,9,10,12.....$（质数之积），假设这个集合为 $T$。


求：

$\sum\limits_{S\subset T,S\neq\varnothing}\mu(\prod\limits_{i\in S}i)\varphi(\prod\limits_{i\in S}i)$

对 $998244353$ 取模。可以证明这个和是存在的。

为了您能更好的获得部分分，我们会给定一个 $k$，表示一些限制，**$k$ 的值可能影响答案！请认真阅读提示说明**。

$n\leq 10^6$

## 说明/提示

$k$ 的限制如下：

$k=0:$ 选出的集合 $S$ 中至少含有一个完全平方数。

$k=1:$ 选出的集合 $S$ 中只能含有质数。

$k=2:$ 无任何限制。

| 测试点编号 |$n$  |$k$  |
| :----------: | :----------: | :----------: |
| $1\sim 2$ |$\leq 5$  |$2$  |
| $3\sim 5$ |$\leq 20$  |$2$  |
| $6\sim 11$ |$\leq 5000$  |$2$  |
| $12$ |$\leq 10^6$  |$0$  |
| $13\sim 14$ |$\leq 10^6$  |$1$  |
| $15\sim 16$ |$\leq 10^5$  |$2$  |
| $17\sim 20$ |$\leq 10^6$  |$2$  |

样例 $1$ 解释：

答案为 $\mu(2)\varphi(2)=-1\times 1=-1$，对 $998244353$ 取模为 $998244352$。

## 样例 #1

### 输入

```
2 2```

### 输出

```
998244352```

## 样例 #2

### 输入

```
114514 2```

### 输出

```
662314206```

# 题解

## 作者：wlzhouzhuan (赞：17)

本题的第一篇题解（出题人好像没给题解？那我来发一波）。。


注意到 $\mu(\prod_{i\in S}i)$ 只有当每种质因数出现次数 $\le 1$ 的时候才 $\neq 0$ ，因此 $\prod_{i\in S}i$ 一定可以表示为 $\prod_{i=1}^{k}p_i$ 的形式。

对于同一种 $\prod_{i=1}^{k}p_i$ ，满足条件的 $S$ 集合个数显然是 $Bell_k$ （贝尔数）。可以这么考虑，相当于把 $k$ 个不同的小球放入任意多个**本质相同**的组内，也就是第二类斯特林数 $\sum\limits_{i=0}^{k} S(k,i)=Bell_k$ 。

其实只需要管到底取出了多少个质数，然后乘上贝尔数即为答案。这里可以通过**分治NTT**维护取了 $k$ 个质数的 $\varphi$ 之和。

特别地，

对于 $k=0$ ，$\mu$ 全为 $0$ ，故答案为 $0$ 。

对于 $k=1$ ，$S$ 内部全是质数，那么不需要乘上贝尔数。

**分治NTT**部分有 $\frac{n}{logn}$ 个质数，这里复杂度 $O(\frac{n}{logn}log^2(\frac{n}{logn}))=O(nlogn)$ ，

计算**贝尔数**这里可以利用贝尔数的 $EGF$ ，即 $\sum\limits_{i}Bell_i\frac{x^i}{i!}=e^{e^x-1}$ ，多项式exp即可，复杂度 $O(\frac{n}{logn}log(\frac{n}{logn}))=O(n)$ 。

总时间复杂度 $O(nlogn)$ ，实测 $n=10^6$ 跑的飞快。。

代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define poly vector<int>

const int N = 1000005;
const int mod = 998244353;
const int G = 3;
const int Gi = 332748118;

inline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }
inline int sub(int a, int b) { return a - b < 0 ? a - b + mod : a - b; }
inline int qpow(int a, int b = mod - 2) {
  int res = 1;
  while (b > 0) {
    if (b & 1) res = 1ll * res * a % mod;
    a = 1ll * a * a % mod, b >>= 1;
  }
  return res;
}

namespace Poly {
  poly r, W;
  int lim, L;
  void getR(int n) {
    lim = 1, L = 0;
    while (lim <= n) lim <<= 1, L++;
    r.resize(lim), W.resize(lim);
    for (int i = 0; i < lim; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << L - 1);
  }
  void reverse(poly &a) {
    for (int i = 0, j = a.size() - 1; i < j; i++, j--) swap(a[i], a[j]);
  }
  void wf(poly &a) {
    int n = a.size();
    for (int i = 0; i < n - 1; i++) a[i] = 1ll * (i + 1) * a[i + 1] % mod;
    a[n - 1] = 0;
  }
  void jf(poly &a) {
    int n = a.size() - 1;
    for (int i = n - 1; i >= 1; i--) a[i] = 1ll * a[i - 1] * qpow(i) % mod;
    a[0] = 0;
  }
  void NTT(poly &a, int opt) {
    for (int i = 0; i < lim; i++) if (i < r[i]) swap(a[i], a[r[i]]);
    for (int mid = 1; mid < lim; mid <<= 1) {
      int Wn = qpow(opt == 1 ? G : Gi, (mod - 1) / (mid << 1));
      W[0] = 1;
      for (int k = 1; k < mid; k++) W[k] = 1ll * W[k - 1] * Wn % mod;
      for (int j = 0; j < lim; j += mid << 1) {
        for (int k = 0; k < mid; k++) {
          int x = a[j + k], y = 1ll * a[j + k + mid] * W[k] % mod;
          a[j + k] = add(x, y);
          a[j + k + mid] = sub(x, y);
        }
      }
    } 
    if (opt == -1) {
      int linv = qpow(lim);
      for (int i = 0; i < lim; i++) a[i] = 1ll * a[i] * linv % mod;
    }
  }
  poly operator * (poly a, poly b) {
    int len = a.size() + b.size() - 1;
    getR(len), a.resize(lim), b.resize(lim);
    NTT(a, 1), NTT(b, 1);
    for (int i = 0; i < lim; i++) a[i] = 1ll * a[i] * b[i] % mod;
    NTT(a, -1), a.resize(len);
    return a;
  }
  poly Inv(poly a) {
    if (a.size() == 1) return {qpow(a[0])};
    int n = a.size();
    poly ha = a; ha.resize(n + 1 >> 1);
    poly b = Inv(ha);
    getR(2 * n), a.resize(lim), b.resize(lim);
    NTT(a, 1), NTT(b, 1);
    for (int i = 0; i < lim; i++) b[i] = 1ll * b[i] * (mod + 2 - 1ll * a[i] * b[i] % mod) % mod;
    NTT(b, -1), b.resize(n);
    return b;
  }
  poly Ln(poly a) {
    poly ta = a; wf(ta);
    int n = a.size();
    a = ta * Inv(a); jf(a);
    a.resize(n);
    return a;
  }
  poly Exp(poly a) {
    if (a.size() == 1) return {1};
    int n = a.size();
    poly ta = a; ta.resize(n + 1 >> 1);
    poly b = Exp(ta); b.resize(n);
    poly tb = Ln(b);
    for (int i = 0; i < n; i++) tb[i] = (mod + a[i] - tb[i]) % mod;
    tb[0]++;
    b = b * tb;
    b.resize(n);
    return b;
  }
}
using namespace Poly;

int vis[N], pr[N], len;
int fac[N], ifac[N];
void init(int n) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % mod;
  ifac[n] = qpow(fac[n]);
  for (int i = n - 1; i >= 1; i--) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
  for (int i = 2; i <= n; i++) {
    if (!vis[i]) pr[len++] = i;
    for (int j = 0; j < len && pr[j] * i <= n; j++) {
      vis[pr[j] * i] = 1;
      if (i % pr[j] == 0) break;
    } 
  }
}

poly solve(int l, int r) {
  if (l == r) return {1, pr[l] - 1};
  int mid = l + r >> 1;
  poly L = solve(l, mid), R = solve(mid + 1, r);
  return L * R;
}

int main() {
  int n, k;
  cin >> n >> k;
  if (n <= 1 || k == 0) {
    puts("0");
    return 0;
  }
  init(n);
  vector<int> Bell(len + 1);
  for (int i = 1; i <= len; i++) Bell[i] = ifac[i];
  Bell = Exp(Bell);
  for (int i = 0; i <= len; i++) Bell[i] = 1ll * Bell[i] * fac[i] % mod;
  poly res = solve(0, len - 1);
  assert(res.size() <= len + 1);
  int ans = 0;
  if (k == 1) {
    for (int i = 1; i <= len; i++) {
      if (i & 1) {
        ans = (ans + mod - res[i]) % mod;
      } else {
        ans = (ans + res[i]) % mod;
      }
    }
  } else {
    for (int i = 1; i <= len; i++) {
      if (i & 1) {
        ans = (ans + mod - 1ll * res[i] * Bell[i] % mod) % mod;
      } else {
        ans = (ans + 1ll * res[i] * Bell[i] % mod) % mod; 
      }
    }
  }
  cout << ans << '\n';
}
```


---

## 作者：wangyizhi (赞：8)

## 题目分析

看眼特殊性质。$k=0$ 时，存在 $x \in S$ 满足 $x$ 为完全平方数，那么 $\displaystyle \prod_{i\in S} i$ 存在一个质因子的次数大于 $2$，因此 $\displaystyle \mu \left( \prod_{i\in S} i \right) = 0$，答案为 $0$。

这启示我们只有 $\displaystyle \prod_{i\in S} i$ 每个质因子出现次数小于 $2$ 时才会对答案有贡献。记小于 $n$ 的质数个数为 $c$，只有 $2^c-1$ 种情况时会产生贡献的。考虑枚举 $s = \displaystyle \prod_{i\in S} i$，由于 $\mu$ 和 $\varphi$ 都是积性函数，那么贡献就是 $\displaystyle \mu(s) \varphi(s) C(s) = C(s) \prod_{i\in S} \mu(i) \varphi(i)$，其中 $C(s)$ 表示 $s$ 的出现次数。

考虑如何求出 $C(s)$。显然它只与 $s$ 的质因子个数 $w$ 有关。发现它正好等于将 $s$ 的质因子划分成几个集合且不考虑顺序的方案数。由基本的组合知识，可知 $C(s)=B(w)$，其中 $B(x)$ 表示 [贝尔数](https://oi-wiki.org/math/combinatorics/bell/)。可以利用多项式 $\operatorname{exp}$ 在 $O(n\log n)$ 下计算。

考虑计算 $\displaystyle \prod_{i\in S} \mu(i) \varphi(i)$，且我们需使其与 $w$ 有关。不难想到可以跑一个完全背包，若选 $p$ 那么个数加 $1$，权值乘 $-\varphi(p)$；若不选那么均不变。

从生成函数的角度考虑。设 $F_p(x)=1-(p-1)x$，那么背包完的结果就是 $\prod F_p(x)$。可以分治 NTT 解决。因此答案就是 $\sum B(n) [x^n] \prod F_p(x)$。

对于 $k=1$ 的情况，当 $n<2$ 时显然答案为 $0$，否则对于任意的不含质因子 $2$ 的 $s$，都有 $\mu(s)\varphi(s) + \mu(2s)\varphi(2s) = \mu(s)\varphi(s)(1+\mu(2)\varphi(2))=0$，因此只需考虑质因子 $2$ 的贡献，答案为 $-1$。

求贝尔数部分，时间复杂度 $O(n\log n)$。分治 NTT 部分，一次多项式个数为 $O(\frac{n}{\log n})$，时间复杂度也为 $O(n\log n)$。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
//#define int ll
const int N=(1<<20)+5,mod=998244353;
inline ll pr(ll x,ll M=mod){return x+(x<0)*M;}
inline ll rd(ll x,ll M=mod){return x-(x>=M)*M;}
inline ll qpow(ll a,ll b=mod-2,ll M=mod){ll res=1;for(;b;b>>=1,a=a*a%M)if(b&1)res=res*a%M;return res;}
const int B=3,iB=qpow(B);
int p[N],pcnt;
bitset<N> to;
void sieve(int n=1e6)
{
	for(int i=2;i<=n;i++)
	{
		if(!to[i]) p[++pcnt]=i;
		for(int j=1;j<=pcnt&&i*p[j]<=n;j++)
		{
			to[i*p[j]]=1;
			if(!(i%p[j])) break;
		}
	}
}
int rev[N];
void ntt(int *a,int n,int op)
{
	for(int i=1;i<n;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int mid=1,len=2;mid<n;mid<<=1,len<<=1)
		for(int i=0,g=qpow(op>0?B:iB,(mod-1)/len);i<n;i+=len)
			for(int j=0,o=1,x,y;j<mid;j++,o=1ll*o*g%mod)
				x=a[i|j],y=1ll*o*a[i|j|mid]%mod,a[i|j]=rd(x+y),a[i|j|mid]=pr(x-y);
	if(op<0)
	{
		int iv=qpow(n);
		for(int i=0;i<n;i++) a[i]=1ll*a[i]*iv%mod;
	}
}
void polydiff(int *a,int *b,int n)
{
	for(int i=1;i<n;i++) b[i-1]=1ll*i*a[i]%mod;
	b[n-1]=0;
}
void polyinte(int *a,int *b,int n)
{
	for(int i=1;i<n;i++) b[i]=1ll*a[i-1]*qpow(i)%mod;
	b[0]=0;
}
void polyinv(int *a,int *b,int n)
{
	static int c[N];
	if(n==1) return b[0]=qpow(a[0]),void();
	polyinv(a,b,(n+1)>>1);
	int sz=1,l=0;
	while(sz<(n<<1)) sz<<=1,l++;
	for(int i=1;i<sz;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<n;i++) c[i]=a[i];
	for(int i=n;i<sz;i++) c[i]=0;
	ntt(c,sz,1),ntt(b,sz,1);
	for(int i=0;i<sz;i++) b[i]=1ll*b[i]*(2-1ll*b[i]*c[i]%mod+mod)%mod;
	ntt(b,sz,-1);
	for(int i=n;i<sz;i++) b[i]=0;
	for(int i=0;i<sz;i++) c[i]=0;
}
void polyln(int *a,int *b,int n)
{
	static int c[N],d[N];
	polydiff(a,c,n),polyinv(a,d,n);
	int sz=1,l=0;
	while(sz<(n<<1)) sz<<=1,l++;
	for(int i=1;i<sz;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	ntt(c,sz,1),ntt(d,sz,1);
	for(int i=0;i<sz;i++) c[i]=1ll*c[i]*d[i]%mod;
	ntt(c,sz,-1);
	polyinte(c,b,n);
	for(int i=0;i<sz;i++) c[i]=d[i]=0;
}
void polyexp(int *a,int *b,int n)
{
	static int c[N],d[N];
	if(n==1) return b[0]=1,void();
	polyexp(a,b,(n+1)>>1);
	polyln(b,c,n);
	int sz=1,l=0;
	while(sz<(n<<1)) sz<<=1,l++;
	for(int i=1;i<sz;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<n;i++) d[i]=a[i];
	for(int i=n;i<sz;i++) d[i]=0;
	ntt(d,sz,1),ntt(b,sz,1),ntt(c,sz,1);
	for(int i=0;i<sz;i++) b[i]=1ll*b[i]*(1+d[i]-c[i]+mod)%mod;
	ntt(b,sz,-1);
	for(int i=0;i<sz;i++) c[i]=d[i]=0;
	for(int i=n;i<sz;i++) b[i]=0;
}
int A[N],F[N],fac[N],ifac[N],inv[N];
void init(int n=1e5)
{
	inv[0]=inv[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1;
	for(int i=2;i<=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod,fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	for(int i=1;i<=n;i++) A[i]=ifac[i];
	polyexp(A,F,n+1);
	for(int i=1;i<=n;i++) F[i]=1ll*F[i]*fac[i]%mod;
}
vector<int> f[N];
vector<int> solve(int nl,int nr,const int lim=32)
{
	if(nl==nr) return f[nl];
	int m=(nl+nr)>>1,n=nr-nl+2,sz=1,l=0;
	vector<int> le=solve(nl,m),ri=solve(m+1,nr),res(n);
	static int a[N],b[N],c[N];
	while(sz<n) sz<<=1,l++;
	for(int i=0;i<sz;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<=m-nl+1;i++) a[i]=le[i];
	for(int i=m-nl+2;i<sz;i++) a[i]=0;
	for(int i=0;i<=nr-m;i++) b[i]=ri[i];
	for(int i=nr-m+1;i<sz;i++) b[i]=0;
	if(nr-nl<=lim)
	{
		for(int i=0;i<sz;i++) c[i]=0;
		for(int i=0;i<=(m-nl+1);i++)
			for(int j=0;j<=(nr-m);j++)
				c[i+j]=(c[i+j]+1ll*a[i]*b[j])%mod;
		for(int i=0;i<n;i++) res[i]=c[i];
		return res;
	}
	ntt(a,sz,1),ntt(b,sz,1);
	for(int i=0;i<sz;i++) a[i]=1ll*a[i]*b[i]%mod;
	ntt(a,sz,-1);
	for(int i=0;i<n;i++) res[i]=a[i];
	return res;
}
int main()
{
	int n,k,ans=0;
	cin>>n>>k;
	if(k==0) return cout<<0<<"\n",0;
	else if(k==1)
	{
		if(n<2) return cout<<0<<"\n",0;
		return cout<<mod-1<<"\n",0;
	}
	init(),sieve(n);
	for(int i=1;i<=pcnt;i++) f[i].resize(2),f[i][0]=1,f[i][1]=pr(1-p[i]);
	vector<int> res=solve(1,pcnt);
	for(int i=1;i<=pcnt;i++) ans=(ans+1ll*res[i]*F[i])%mod;
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：masterhuang (赞：0)

推销[博客](https://www.cnblogs.com/HaHeHyt/p/17624345.html)！

前置题目：[P5748 集合划分计数](https://www.luogu.com.cn/problem/P5748)。我们令 $Bell_n$ 表示将 $n$ 个有标号的球划分为若干集合的方案数。且 $Bell_n=n![x^n]e^{e^x-1}$。

---
首先，当 $k=0$ 时，$\mu(S)=0$，答案为 $0$。

---
当 $k=1$ 时，$\mu(S)=(-1)^{|S|},\varphi(S)=\prod\limits_{x\in S}(x-1)$。记 $\pi(S)=\prod\limits_{x\in S}x$，推式子：

$$\sum\limits_{\substack{S\subset T\\S\neq \varnothing}}(-1)^{|S|}\prod\limits_{x\in S}(x-1)=\sum\limits_{\substack{S\subset T\\S\neq \varnothing}}(-1)^{|S|}\sum\limits_{S'\subset S}\pi(S')(-1)^{|S|-|S'
|}=\sum\limits_{\substack{S\subset T\\S\neq \varnothing}}\sum\limits_{S'\subset S}\pi(S')(-1)^{|S'
|}=\sum\limits_{S'\subset T}\pi(S')(-1)^{|S'
|}\sum\limits_{\substack{S\subset T\\S\neq \varnothing\\S'\subset S}} 1$$

当 $S'=\varnothing$ 时，$\sum\limits_{\substack{S\subset T\\S\neq \varnothing\\S'\subset S}} 1=2^{|T|}-1$。否则，我们就能除去 $S\neq \varnothing$ 的限制，$\sum\limits_{\substack{S\subset T\\S'\subset S}} 1=2^{|T|-|S'|}$。

所以式子为：$\sum\limits_{S'\subset T}\left(\pi(S')(-1)^{|S'
|}2^{|T|-|S'|}\right)-1=\prod\limits_{x\in T}(2-x)-1$。

注意到当 $n>1$ 时 $2\in T$，于是答案为 $-1$，否则答案为 $0$。

---

当 $k=2$ 时，注意到当 $S$ 中存在两个有相同质因子的数时答案为 $0$。令 $P=\{p_1,p_2,\dots,p_{\pi(n)}\}$，其中 $p_i$ 表示第 $i$ 个素数。

我们枚举 $S$ 中的质因子集合，式子为：

$\sum\limits_{\substack{S\subset P\\S\neq \varnothing}}(-1)^{|S|}\prod\limits_{p\in S}(p-1)Bell_{|S|}=\sum\limits_{i=1}^{|P|}(-1)^iBell_i\sum\limits_{\substack{S\subset P\\|S|=i}}\prod\limits_{p\in S}(p-1)$。

注意到 $\sum\limits_{\substack{S\subset P\\|S|=i}}\prod\limits_{p\in S}(p-1)=[x^i]\prod\limits_{p\in S} ((p-1)x+1)$，对于这个式子分治 **NTT** 计算即可。

复杂度 $O(\pi(n)\log^2 n)=O(\dfrac{n}{\ln n}\log^2n)=O(n\log n)$。

---

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int N=4e6+5,mod=998244353;
int n,k,pr[N],v[N],a[N],b[N],w[N],jc[N],*f[N],mmax;
#define md(x) ((x)>=mod?(x)-mod:(x))
inline int bger(int x){return x|=x>>1,x|=x>>2,x|=x>>4,x|=x>>8,x|=x>>16,x+1;}
inline int ksm(int x,int p){int s=1;for(;p;(p&1)&&(s=1ll*s*x%mod),x=1ll*x*x%mod,p>>=1);return s;}
inline void dao(int *a,int n){for(int i=1;i<n;i++) a[i-1]=1ll*i*a[i]%mod;a[n-1]=0;}
inline void ji(int *a,int n){for(int i=n-1;i>=1;i--) a[i]=1ll*ksm(i,mod-2)*a[i-1]%mod;a[0]=0;}
inline void init(int mmax)
{
	for(int i=1,j,k;i<mmax;i<<=1)
		for(w[j=i]=1,k=ksm(3,(mod-1)/(i<<1)),j++;j<(i<<1);j++)
			w[j]=1ll*w[j-1]*k%mod;
}
inline void DNT(int *a,int mmax)
{
	for(int i,j,k=mmax>>1,L,*W,*x,*y,z;k;k>>=1)
		for(L=k<<1,i=0;i<mmax;i+=L)
			for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				*y=1ll*(*x+mod-(z=*y))* *W%mod,*x=md(*x+z);
}
inline void IDNT(int *a,int mmax)
{
	for(int i,j,k=1,L,*W,*x,*y,z;k<mmax;k<<=1)
		for(L=k<<1,i=0;i<mmax;i+=L)
			for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				z=1ll* *W* *y%mod,*y=md(*x+mod-z),*x=md(*x+z);
	reverse(a+1,a+mmax);
	for(int inv=ksm(mmax,mod-2),i=0;i<mmax;i++) a[i]=1ll*a[i]*inv%mod;
}
inline void NTT(int *a,int *b,int n,int m)
{
	mmax=bger(n+m);init(mmax);
	DNT(a,mmax);DNT(b,mmax);
	for(int i=0;i<mmax;i++) a[i]=1ll*a[i]*b[i]%mod;
	IDNT(a,mmax);
}
void INV(int num,int *a,int *b)
{
	if(num==1) return b[0]=ksm(a[0],mod-2),void();
	INV((num+1)>>1,a,b);
	int mmax=bger(num<<1);init(mmax);
	static int c[N];
	for(int i=0;i<num;i++) c[i]=a[i];for(int i=num;i<mmax;i++) c[i]=0;
	DNT(c,mmax);DNT(b,mmax);
	for(int i=0;i<mmax;i++) b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)%mod*b[i]%mod;
	IDNT(b,mmax);
	for(int i=num;i<mmax;i++) b[i]=0;
}
inline void Ln(int *a,int n){static int b[N];for(int i=0;i<bger(n<<1);i++) b[i]=0;INV(n,a,b);dao(a,n);NTT(a,b,n,n);ji(a,n);for(int i=n;i<bger(n<<1);i++) a[i]=0;}
inline void Exp(int *a,int *b,int n)
{
	if(n==1) return b[0]=1,void();
	Exp(a,b,(n+1)>>1);static int c[N];for(int i=0;i<bger(n<<1);i++) c[i]=0;
	for(int i=0;i<n;i++) c[i]=b[i];Ln(c,n);
	for(int i=0;i<n;i++) c[i]=md(mod-c[i]+a[i]);c[0]=md(c[0]+1);
	NTT(b,c,n,n);for(int i=n;i<bger(n<<1);i++) b[i]=0;
}
void sol(int l,int r,int wz)
{
	f[wz]=new int[r-l+2];
	if(l==r) return f[wz][0]=1,f[wz][1]=pr[l]-1,void();
	int mid=(l+r)>>1;sol(l,mid,wz<<1);sol(mid+1,r,wz<<1|1);
	static int A[N],B[N];for(int i=0;i<=mid-l+1;i++) A[i]=f[wz<<1][i];
	for(int i=0;i<=r-mid;i++) B[i]=f[wz<<1|1][i];NTT(A,B,mid-l+1,r-mid);
	for(int i=0;i<=r-l+1;i++) f[wz][i]=A[i];for(int i=0;i<mmax;i++) A[i]=B[i]=0;
}
inline void Init(int M)
{
	for(int i=2;i<=M;i++)
	{
		if(!v[i]) pr[++pr[0]]=i;
		for(int j=1;j<=pr[0]&&i*pr[j]<=M;j++)
		{
			v[i*pr[j]]=1;
			if(i%pr[j]==0) break;
		}
	}
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>n>>k;
	if(!k||n<=1) return cout<<"0",0;
	if(k==1) return cout<<mod-1,0;Init(n);n=pr[0];
	for(int i=jc[0]=1;i<=n;i++) jc[i]=1ll*jc[i-1]*i%mod;
	a[n]=ksm(jc[n],mod-2);for(int i=n-1;~i;i--) a[i]=1ll*a[i+1]*(i+1)%mod;a[0]=0;
	Exp(a,b,n+1);for(int i=0;i<=n;i++) b[i]=1ll*b[i]*jc[i]%mod;sol(1,n,1);int ans=0;
	for(int i=1,t;i<=n;i++) t=1ll*b[i]*f[1][i]%mod,ans=md(ans+((i&1)?mod-t:t));
	return cout<<ans,0;
}
```

---


# [NOIP2020] 移球游戏

## 题目描述

小 C 正在玩一个移球游戏，他面前有 $n + 1$ 根柱子，柱子从 $1 \sim n + 1$ 编号，其中 $1$ 号柱子、$2$ 号柱子、……、$n$ 号柱子上各有 $m$ 个球，它们自底向上放置在柱子上，$n + 1$ 号柱子上初始时没有球。这 $n \times m$ 个球共有 $n$ 种颜色，每种颜色的球各 $m$ 个。

初始时一根柱子上的球可能是五颜六色的，而小 C 的任务是将所有同种颜色的球移到同一根柱子上，这是唯一的目标，而每种颜色的球最后放置在哪根柱子则没有限制。

小 C 可以通过若干次操作完成这个目标，一次操作能将一个球从一根柱子移到另一根柱子上。更具体地，将 $x$ 号柱子上的球移动到 $y$ 号柱子上的要求为：

1. $x$ 号柱子上至少有一个球；
2. $y$ 号柱子上至多有 $m - 1$ 个球；
3. 只能将 $x$ 号柱子最上方的球移到 $y$ 号柱子的最上方。

小 C 的目标并不难完成，因此他决定给自己加加难度：在完成目标的基础上，使用的操作次数不能超过 $820000$。换句话说，小 C 需要使用至多 $820000$ 次操作完成目标。

小 C 被难住了，但他相信难不倒你，请你给出一个操作方案完成小 C 的目标。合法的方案可能有多种，你只需要给出任意一种，题目保证一定存在一个合法方案。

## 说明/提示

**【样例 #1 解释】**

柱子中的内容为：按自底向上的顺序依次给出柱子上每个球的颜色。

| 操作 | $1$ 号柱子 | $2$ 号柱子 | $3$ 号柱子 |
|:-:|:-:|:-:|:-:|
| 初始 | $1\ 1\ 2$ | $2\ 1\ 2$ | |
| $1\ 3$ | $1\ 1$ | $2\ 1\ 2$ | $2$ |
| $2\ 3$ | $1\ 1$ | $2\ 1$ | $2\ 2$ |
| $2\ 3$ | $1\ 1$ | $2$ | $2\ 2\ 1$ |
| $3\ 1$ | $1\ 1\ 1$ | $2$ | $2\ 2$ |
| $3\ 2$ | $1\ 1\ 1$ | $2\ 2$ | $2$ |
| $3\ 2$ | $1\ 1\ 1$ | $2\ 2\ 2$ | |

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 2$ | $2$ | $20$ |
| $3 \sim 5$ | $10$ | $20$ |
| $6 \sim 8$ | $50$ | $85$ |
| $9 \sim 14$ | $50$ | $300$ |
| $15 \sim 20$ | $50$ | $400$ |

对于所有测试点，保证 $2 \le n \le 50$，$2 \le m \le 400$。

**【校验器】**

为了方便选手测试，在附件中的 `ball` 目录下我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。

编译命令为：`g++ checker.cpp −o checker -std=c++11`。

`checker` 的使用方式为：`checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。

若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：

1. `A x`，表示进行到第 $x$ 个操作时不合法。
2. `B x`，表示操作执行完毕后第 $x$ 个柱子上的球不合法。

若你的方案正确，校验器会给出 `OK`。

## 样例 #1

### 输入

```
2 3
1 1 2
2 1 2
```

### 输出

```
6
1 3
2 3
2 3
3 1
3 2
3 2
```

## 样例 #2

### 输入

```
见附件中的 ball/ball2.in```

### 输出

```
见附件中的 ball/ball2.ans```

## 样例 #3

### 输入

```
见附件中的 ball/ball3.in```

### 输出

```
见附件中的 ball/ball3.ans```

# 题解

## 作者：鏡音リン (赞：303)

题意：给定 $n+1$ 个栈，栈的高度限制为 $m$。初始时前 $n$ 个上每个有 $m$ 个球，最后一个为空。球分为 $n$ 种颜色，每种恰好 $m$ 个。一次操作可以把一个栈顶的元素弹出放到一个另一个栈顶，但是不可以使栈溢出或下溢。现要把同种颜色的球移动到同一个栈上，你需要构造一个在 $820000$ 次操作内的方案。

先来看通过这个操作都能干什么。例如，我们可以把一个满栈 $X$ 中所有颜色为 $y$ 的球挪到栈顶，这项操作需要借助另一个满栈 $H$ 和一个空栈 $N$：

1. 数一下 $X$ 中共有多少个颜色为 $y$ 的球，这个数字记为 $a$。
2. 把 $H$ 栈顶 $a$ 个元素依次放入 $N$。操作后 $H$ 有 $a$ 个空位，$N$ 有 $m-a$ 个空位。
3. 一直弹出 $X$ 的栈顶元素，如果颜色为 $y$ 则放入 $H$，否则放入 $N$，直到 $X$ 为空。这时 $H$ 和 $N$ 都恰好满了。
4. 把 $N$ 栈顶 $m-a$ 个元素依次放入 $X$，把 $H$ 栈顶 $a$ 个元素依次放入 $X$。这时 $X$ 中的元素还是原来的那些，不过顺序发生了变化，所有颜色为 $y$ 的都在栈顶。
5. 把 $N$ 全部 $a$ 个元素依次放入 $H$。操作后 $H$ 和 $N$ 恢复了操作前的原样。

这项操作的移动步数是 $2m+2a$。为了方便，我们把这个操作叫做“上提”。

有了这项操作，我们可以构造出一个算法：

1. 任选一个颜色 $y$，把所有 $n$ 个栈中颜色为 $y$ 的球都上提。
2. 把这些颜色是 $y$ 的球都移到那个空栈里。
3. 任选一个栈，把它的元素都移动到其他没满的栈里。
4. 去掉颜色是 $y$ 的球组成的栈，则问题规模 $n$ 减小了 $1$。回到第一步重新执行，直到 $n=1$ 结束。

这个算法的移动步数上界也容易分析。每次执行第一步的操作次数是 $(2n+2)m$，第二和第三步每一步是 $m$，合起来是 $(2n+4)m$。那么总体步数上界为 $\sum_{i=2}^n(2i+4)m=(n+6)(n-1)m$。

带入 $70$ 分部分分数据范围，算了一下这个数字是 $823200$，还差一点。于是……

潜在的常数优化方法：

- 上提操作的第三步，不需要把 $X$ 弹到空，只需要弹到里面没有颜色 $y$ 的球即可。
- 在上一条优化的基础上，算法的第一步，可以计算出上提每种颜色的球的代价，然后找一种最小的上提。
- 上提的第二步和第五步，如果 $m-a<a$，则只需要移动 $m-a$ 个元素，然后交换一下 $N$ 和 $H$ 的作用即可。

加上这些优化，$70$ 分到手。考虑正解。

考虑一个对两个栈的操作：给定栈 $X,Y$，重排两个栈的元素使得 $\operatorname{max}\{X\}\leq \operatorname{min}\{Y\}$。其中，$\operatorname{max}$ 和 $\operatorname{min}$ 都是针对颜色编号而言的。这个操作也需要借助另一个满栈 $H$ 和一个空栈 $N$。注意到同一种颜色可能有很多球，不便于操作，我们可以把所有元素分成“大的一半”和“小的一半”，分别应该装进 $Y$ 和 $X$ 里。以下我们用“元素为大”、“元素为小”称呼。

1. 数一下 $X$ 中共有多少个元素为大，这个数字记为 $a$。
2. 把 $H$ 栈顶 $a$ 个元素依次放入 $N$。操作后 $H$ 有 $a$ 个空位，$N$ 有 $m-a$ 个空位。
3. 一直弹出 $X$ 的栈顶元素，如果为大则放入 $H$，否则放入 $N$，直到 $X$ 为空。这时 $H$ 和 $N$ 都恰好满了。
4. 把 $N$ 栈顶 $m-a$ 个元素依次放入 $X$。
5. 一直弹出 $Y$ 的栈顶元素，如果为大则放入 $N$，否则放入 $X$，直到 $Y$ 为空。这时 $N$ 和 $X$ 都恰好满了。
6. 把 $N$ 栈顶 $m-a$ 个元素依次放入 $Y$，把 $H$ 栈顶 $a$ 个元素依次放入 $Y$。
7. 把 $N$ 全部 $a$ 个元素依次放入 $H$。操作后 $H$ 和 $N$ 恢复了操作前的原样。

为了方便下文管这个操作叫“切分”，意思当然是把小的一半切出来。操作结束时，$X$ 所有元素为小，$Y$ 所有元素为大。这就达成了我们的目的。这个操作的步数是 $4m+a\leq 5m$。可以使用类似上面第三条常数优化，如果 $m-a<a$，则第一步和第七步只需要移动 $m-a$ 个元素，然后交换 $H$ 和 $N$ 的作用即可。优化后移动次数不超过 $\frac{9}{2}m$。

注意到这个操作不适用于 $n=2$（因为压根就找不到可以用的 $H$），于是把 $n=2$ 特判出来，跑上面的算法。

有了这个操作，我们可以使用类似冒泡排序的方式把整个 $n$ 个栈按照颜色排序，排序之后很显然每个栈里球颜色一样。排序的正确性参照冒泡排序很容易证明（最大的元素一定会冒到最右边），可以算出移动步数 $\frac{9}{4}n(n-1)m$，渐进复杂度相同的情况下常数比上面那个算法大了一倍多，只能过 $40$ 分，看起来根本没用……

尝试换一种排序：归并排序。要解决的问题就是如何归并。类似普通归并的过程，维护两个指针 $x$ 和 $y$，初始值在要归并的两个区间最左侧。把两个指针指向的栈分别称为 $X,Y$。如果 $\operatorname{max}\{X\}<\operatorname{max}\{Y\}$，对 $X,Y$ 执行切分，小的一半放到 $X$，然后把指针 $x$ 递增，继续执行。否则把小的一半放在 $Y$，指针 $y$ 递增。这样做是正确的，因为未归并区间最小的 $m$ 个元素一定包含在了 $X$ 和 $Y$ 里。最后我们可以得到一系列从小到大的栈，不过它们并没有摆在它们应该在的位置上。于是归并的过程中记录一下每个栈应该在的位置，利用那个空栈进行整体移动，可以使用不超过 $2L$ 次整体移动把它们摆好（$L$ 是归并的区间长度）。于是，要归并一个长度为 $L$ 的区间，要执行不超过 $L$ 次切分和不超过 $2L$ 次整体移动，总操作次数不超过 $\frac{13}{2}Lm$。

由归并排序的复杂度证明得，所有归并的区间长度和是不会超过 $n\lceil\log_2n\rceil$ 的，于是这个算法的操作次数上界是 $\frac{13}{2}n\lceil\log_2n\rceil m$（很松，根本卡不满），算一下数字 $780000$，轻松过题。

还有一个优化，就是归并之后的“整体移动”其实是没必要的，可以用一个数组记录一下假装移动了，那么排序长度为 $L$ 的区间操作次数只有 $\frac{9}{2}Lm$，极限数据下总操作次数不会超过 $540000$。

---

## 作者：QwQcOrZ (赞：280)

_此题解纪念我在考场上通过了本题_

考虑先枚举颜色，然后将此颜色的所有球移动到同一个柱子上

### Step. 0 问题的转换

假设原来是这么一组数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/cwpdg8i2.png)

为了方便，我们将每个柱子看作一列，从左到右标号为 $1..n$

记 $now$ 表示当前枚举到的颜色，令所有 $a_{i,j}=now$ 的位置为 $1$，$a_{i,j}\not=now$ 的位置为 $0$

记 $t_i$ 表示第 $i$ 列 $1$ 的个数

当 $now=1$ 时，那么图就变成了这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/jibk41sr.png)

这时问题的目标就转化为了将所有的 $1$ 移到同一列上

### Step. 1 制造全 $0$ 列

考虑对于每个颜色先制造出一个全 $0$ 列，然后再制造全 $1$ 列

至于为什么要先制造全 $0$ 列我后面会讲，这里先讲构造方法：

0. 还是为了方便，我们强制第 $n+1$ 列是空的（没有任何球）

   具体操作时可以维护一个数组 $p$，其中 $p_i$ 表示当前第 $i$ 列的柱子在最开始时的编号为 $p_i$

   这样就可以通过 `swap` $p$ 中的两个数来使柱子的排列方便我们构造

1. 设 $tot=t_1$，将第 $n$ 列最上面的 $tot$ 个球移动到第 $n+1$ 列

   ![](https://cdn.luogu.com.cn/upload/image_hosting/wjhhyj9g.png)

   （这里用的还是 `Step. 0` 中的例子）

2. 将第 $1$ 列中的 $1$ 全部移动到第 $n$ 列，$0$ 全部移动到第 $n+1$ 列

   ![](https://cdn.luogu.com.cn/upload/image_hosting/myjlbseh.png)

   具体过程就是如果第一列的最上面为 $1$ 就移到第 $n$ 列，否则移到第 $n+1$ 列

   此时可以发现第一列中的 $0$ 和 $1$ 被我们分离了

3. 将第 $n+1$ 列中的 $m-tot$ 个 $0$ 全部移回第 $1$ 列（其中 $tot$ 为第一步中的 $t_1$）

   ![](https://cdn.luogu.com.cn/upload/image_hosting/1q1m0423.png)

4. 将第 $2$ 列中的 $0$ 分离到第 $1$ 列，$1$ 分离到第 $n+1$ 列（如果第一列塞不下 $0$ 了就往第 $n+1$ 列丢）

   ![](https://cdn.luogu.com.cn/upload/image_hosting/bjmjj427.png)

   此时我们就构造出了一个全 $0$ 列！

   至于第四步中为什么 $0$ 的数量一定够，是因为前两列中 $1$ 的个数一定不大于 $m$，所以 $0$ 的个数一定 $\geq 2m-1的数量$ ，即 $\geq m$。而这四步的本质也就是将前两列中的 $0$ 全部分离到第一列中，所以一定能构造出一个全 $0$ 列

`Step. 1` 实际上就是用第 $1,2,n,n+1$ 列构造了一个全 $0$ 列

#### Step. 2 构造全 $1$ 列

我们在 `Step. 1` 中构造全 $0$ 列的目的自然是为了方便将所有的 $1$ 移到同一列

依然是为了方便，我们强制在构造全 $1$ 列时第 $n$ 列要为全 $0$，第 $n+1$ 列要为空

所以在构造了全 $0$ 列的之后需要 $swap(p_1,p_n),swap(p_2,p_{n+1})$ （因为这时第一列为全 $0$，第二列为空）

然后自然是通过全 $0$ 列和全空列构造全 $1$ 列了（不然上一步构造全 $0$ 列干啥）

0. 开始的时候图长这样

   ![](https://cdn.luogu.com.cn/upload/image_hosting/rclsxwrb.png)

1. 像 `Step. 1` 中的 1.2. 那样将第 $1$ 列分解到第 $n,n+1$ 列

   ![](https://cdn.luogu.com.cn/upload/image_hosting/fras5a3j.png)

然后你就会发现第 $1$ 列中的 $1$ 全部被移到了第 $n$ 列的最上方，然后第 $n+1$ 列构成了一个新的全 $0$ 列

所以我们第一步中构造全 $0$ 列的目的就是保证在这步中，第 $n$ 列除了最上面的第一列中的 $1$，其它都为 $0$（否则第 $n$ 列的下方可能出现其它的 $1$，第 $n+1$ 列也不一定是全 $0$）

然后你又能发现你可以用第 $n+1$ 列新产生的全 $0$ 列和第 $2$ 列继续操作，再用新的全 $0$ 列和第 $3,4,...,n-1$ 列操作

所有操作完成后，所有的 $1$ 都被移到了柱子的最上方，这时就可以将所有 $1$ 都移到空行，然后再用全 $0$ 列去填充产生的空当

然后我们发现当前枚举的颜色已经合法，剩下的相当于要将 $n-1$ 根柱子的颜色分离，用同样的方法求解即可

### Step. 3 $n=2$

也许你以为本题的做法到这里就结束了？其实并没有

你会发现这个做法根本过不了样例

因为当 $n=2$ 时，第 $2$ 列和第 $n$ 列是同一列，也就是说不能用上面的方法制造全 $0$ 列

所以要特判 $n=2$ 的情况

这个应该挺好做的，这里简单介绍一下我的做法：

0. 假设开始的图是这样的：

   ![](https://cdn.luogu.com.cn/upload/image_hosting/kf54txnp.png)

1. 还是像 `Step. 1` 中的 1.2. 那样将第 $1$ 列分解到第 $2,3$ 列

   ![](https://cdn.luogu.com.cn/upload/image_hosting/5y49k8ws.png)

2. 然后再将分离后的丢回第 $1$ 列（先 $1$ 后 $2$）

   ![](https://cdn.luogu.com.cn/upload/image_hosting/qdncepqk.png)

   这两步操作相当于将第一列排了个序

3. 将第三列移回第二列，然后将第一列上面的 $2$ 移到第三列

   ![](https://cdn.luogu.com.cn/upload/image_hosting/rupoz1bv.png)

4. 然后类似 `Step. 1` 中的 1.2. 那样将第 $2$ 列分解到第 $1,3$ 列，就能得到全 $1$ 列和全 $2$ 列了

### Step. 4 操作次数分析

最外层枚举颜色一个 $n$ ，每次构造全 $1$ 列时需要 $nm+m$（因为 $1$ 的总个数为 $m$，所以分解时的第一步均摊的总次数为 $m$）

因为列数随着颜色一个一个处理完会减小，所以 $nm+m$ 中的 $n$ 其实是个等差数列，也就是 $\sum\limits_{i=1}^n im+m$。所以有个 $1/2$ 的常数

构造全 $0$ 列时上限需要 $4m$ 次，所以操作次数上限为 $\sum\limits_{i=1}^n im+5m$，极限数据满打满算要操作 $600,000$ 次，可以轻松通过本题

复杂度 $=$ 操作次数，所以不需要管它

### Step. 5 一些小细节

1. 所有对第 $i$ 列的操作实际上都是对 $p_i$ 进行的，因为上面说第 $i$ 列只是方便思考，实际上时对 $p_i$ 进行的操作
2. 每次移完球需要动态更新 $p$ 数组，否则会惨烈爆蛋
3. 祝大家省选 rp++！

$Code\ Below$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55;
const int M=405;
const int OPT=820005;

int read()
{
	int s=0;
	char c=getchar(),lc='+';
	while (c<'0'||'9'<c) lc=c,c=getchar();
	while ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();
	return lc=='-'?-s:s;
}
void write(int x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x<10) putchar(x+'0');
	else
	{
		write(x/10);
		putchar(x%10+'0');
	}
}
void print(int x=-1,char c='\n')
{
	write(x);
	putchar(c);
}
int L[OPT],R[OPT],CNT=0,n,m;
int a[N][M],cnt[N],tot[N],p[N];
void move(int x,int y)
{
	++CNT;
	L[CNT]=x;
	R[CNT]=y;
	a[y][++cnt[y]]=a[x][cnt[x]--];
}
int count(int x,int y)
{
	int ret=0;
	for (int i=1;i<=m;i++) ret+=a[x][i]==y;
	return ret;
}
inline int top(int x)
{
	return a[x][cnt[x]];
}

int main()
{
	freopen("ball.in","r",stdin);
	freopen("ball.out","w",stdout);

	n=read();
	m=read();
	for (int i=1;i<=n;i++)
	{
		cnt[i]=m;
		for (int j=1;j<=m;j++) a[i][j]=read();
	}
	cnt[n+1]=0;
	for (int i=1;i<=n+1;i++) p[i]=i;
	//empty:n+1
	//full :n
	for (int now=n;now>=3;now--)
	{
		int tmp=count(p[1],now);
		for (int i=1;i<=tmp;i++) move(p[now],p[now+1]);
		for (int i=1;i<=m;i++)
		if (top(p[1])==now) move(p[1],p[now]);
					   else move(p[1],p[now+1]);
		for (int i=1;i<=m-tmp;i++) move(p[now+1],p[1]);
		for (int i=1;i<=m;i++)
		if (top(p[2])==now||cnt[p[1]]==m) move(p[2],p[now+1]);
									 else move(p[2],p[1]);
        //构造全 0 列
		swap(p[1],p[now]);
		swap(p[2],p[now+1]);
		for (int k=1;k<now;k++)
		{
			tmp=count(p[k],now);
			for (int i=1;i<=tmp;i++) move(p[now],p[now+1]);
			for (int i=1;i<=m;i++)
			if (top(p[k])==now) move(p[k],p[now]);
						   else move(p[k],p[now+1]);
			swap(p[k],p[now+1]);
			swap(p[k],p[now]);
		}
		for (int i=1;i<now;i++) while (top(p[i])==now) move(p[i],p[now+1]);
		for (int i=1;i<now;i++) while (cnt[p[i]]<m) move(p[now],p[i]);
        //构造全 1 列
	}
	int tmp=count(p[1],1);
	for (int i=1;i<=tmp;i++) move(p[2],p[3]);
	for (int i=1;i<=m;i++)
	if (top(p[1])==1) move(p[1],p[2]);
				 else move(p[1],p[3]);
	for (int i=1;i<=tmp;i++) move(p[2],p[1]);
	for (int i=1;i<=m-tmp;i++) move(p[3],p[1]);
	while (cnt[p[3]]) move(p[3],p[2]);
	for (int i=1;i<=m-tmp;i++) move(p[1],p[3]);
	for (int i=1;i<=m;i++)
	if (top(p[2])==1) move(p[2],p[1]);
				 else move(p[2],p[3]);
    //特判 n=2
	print(CNT);
	for (int i=1;i<=CNT;i++)
	{
		print(L[i],' ');
		print(R[i]);
	}

	return 0;
}
```



---

## 作者：Dzhao (赞：164)

2020.12.19 upd：更新了时间复杂度与操作次数。

思路：分治 + 构造

个人认为这是 NOIP 历年以来最有思维含量的题目之一。

题解：

我们先考虑 $n=2$ 的情况，个人认为用优秀的算法解决这一档部分分是通往正解的唯一途径。

由于 CCF 十分的良心，用他自己辛辛苦苦写的正解跑了第二个样例，然后考场上我就瞪着这个样例瞪出了优秀的做法。

我们考虑要把第一根柱子上的颜色 $1$ 和颜色 $0$ 分离开来，于是我们就要是状态最后变成第一根柱子上为原来第一根柱子上所有的 $1$，第二根柱子上为原来第二根柱子上所有的 $0$。我们设原来第 $1$ 根柱子上有 $s$ 个 $1$ 于是我们就可以进行以下操作：


![](https://cdn.luogu.com.cn/upload/image_hosting/659tn0ux.png)

## $\texttt{Step\ 1}$

![](https://cdn.luogu.com.cn/upload/image_hosting/9y7nzibx.png)

## $\texttt{Step\ 2}$

![](https://cdn.luogu.com.cn/upload/image_hosting/75coreu2.png)

## $\texttt{Step\ 3}$

![](https://cdn.luogu.com.cn/upload/image_hosting/188akelr.png)

## $\texttt{Step\ 4}$

![](https://cdn.luogu.com.cn/upload/image_hosting/0p7utzmx.png)

## $\texttt{Step\ 5}$

![](https://cdn.luogu.com.cn/upload/image_hosting/s6jn6z39.png)

于是，我们就解决了 $n=2$ 的情况的优秀算法，操作次数为:

$s+m+m+(m-s)+(m-s)+m=5m-s$

这指引我们走向了正解。

对于只有两种颜色的情况我们很好解决，但是对于多种颜色，我们就很那解决，所以我们就要尽可能将多种颜色转化为两种颜色去求解，我们可以想到设一个阀值 $x$，使 $\le x$ 的数全部变为 $1$，$>x$ 的数全部变为 $0$，然后将 $[1,x]$ 和 $[x+1,n]$ 分治求解。很显然对于每个区间 $[l,r]$ ，将 $x$ 设为 $\lfloor\frac{l+r}{2}\rfloor$ 时操作次数是最优的。

每次 $solve(l,r)$ ，我们将 $[l,mid]$ 和 $[mid+1,r]$ 中没有复原的柱子两两匹配，我们令两根柱子分别为 $i$ 和 $j$，这样，$i$ 和 $j$ 中如果 $\le mid$ 的个数大于 $>mid$ 的个数，那么将 $i$ 还原，否则将 $j$ 还原，然后继续递归下去 $solve(l,mid)$ 和 $solve(mid+1,r)$ 就行了。

操作次数：
$$T(n)=2T(n/2)+5mn$$
$$T(n)=5mn\log n$$

时间复杂度$\mathcal{O}(5mn^2\log n)$

$\mathcal{View\ Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55,M=405,K=820005;
int a[N][M],top[N],n,m,ans[K][2],tot;bool flag[N];
inline void pour(int x,int y) 
{
	ans[++tot][0]=x,ans[tot][1]=y;
	a[y][++top[y]]=a[x][top[x]--];
}
void solve(int l,int r)
{
	if(l==r) return;
	int mid=l+r>>1;
	memset(flag,0,sizeof(flag));
	for(int i=l;i<=mid;i++)
		for(int j=mid+1;j<=r;j++)
		{
			if(flag[i] || flag[j]) continue;
			int s=0;for(int k=1;k<=m;k++) s+=(a[i][k]<=mid);
			for(int k=1;k<=m;k++) s+=(a[j][k]<=mid);
			if(s>=m) //<=mid 
			{
				s=0;for(int k=1;k<=m;k++) s+=(a[i][k]<=mid);
				for(int k=1;k<=s;k++) pour(j,n+1); //1
				while(top[i]) a[i][top[i]]<=mid?pour(i,j):pour(i,n+1); //2
				for(int k=1;k<=s;k++) pour(j,i);
				for(int k=1;k<=m-s;k++) pour(n+1,i);
				for(int k=1;k<=m-s;k++) pour(j,n+1); //3
				for(int k=1;k<=m-s;k++) pour(i,j); //4
				while(top[n+1]) 
				{
					if(top[i]==m || a[n+1][top[n+1]]>mid) pour(n+1,j);
					else pour(n+1,i); 
				}
				flag[i]=1;
			}
			else //>mid
			{
				s=0;for(int k=1;k<=m;k++) s+=(a[j][k]>mid);
				for(int k=1;k<=s;k++) pour(i,n+1); //1
				while(top[j]) a[j][top[j]]>mid?pour(j,i):pour(j,n+1); //2
				for(int k=1;k<=s;k++) pour(i,j);
				for(int k=1;k<=m-s;k++) pour(n+1,j);
				for(int k=1;k<=m-s;k++) pour(i,n+1); //3
				for(int k=1;k<=m-s;k++) pour(j,i); //4
				while(top[n+1]) 
				{
					if(top[j]==m || a[n+1][top[n+1]]<=mid) pour(n+1,i);
					else pour(n+1,j); 
				}
				flag[j]=1;
			}
		}
	solve(l,mid);solve(mid+1,r);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) 
		for(int j=1,x;j<=m;j++)
			scanf("%d",&x),a[i][++top[i]]=x;
	solve(1,n);printf("%d\n",tot);
	for(int i=1;i<=tot;i++) printf("%d %d\n",ans[i][0],ans[i][1]);
	return 0;
}
```

---

## 作者：yyh_1102 (赞：112)

具体的解决方案大佬们都已经给出了，我主要想给大家来捋一捋如何去思考这个问题，建立一个思考问题的流程，毕竟我不会“不难注意到”，“易得”，“显然”之类的高端操作。

## Step1
首先看一看数据范围，十分是$n<=2$，其实也就是$n=2$

那么对于 $n=2$ 的特殊情况改如何思考呢，我们先从简单的来想，如果 $m=1$ 的话就不需要做了，直接就是满足情况，那么当 $m=2$ 的时候，会有四种情况，不过两两对称，其中两种也是直接满足要求的，所以我们干脆就只讨论唯一需要做的一种。如下图
![](https://cdn.luogu.com.cn/upload/image_hosting/epjsrve5.png)
对于这种情况，我们很容易能想到做法，直接把$A$柱上面的第一个球（~~其实是木块~~）移到$C$，再把$B$上的第一个球移动到$A$，最后把$C$上的球移动到$B$，过程就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ee7hpay.png)

那么对于$m=2$的情况就讨论完了，可以轻松解决，接下来就是$m=3$的情况，这里我举一个比较有代表性的例子
![](https://cdn.luogu.com.cn/upload/image_hosting/rf95m1pc.png)

现在我们的问题就是如何把颜色尽可能的集中到一根柱子上去，其实我们对比一下上图$m=2$的情况，可以看出来如果把 $A_3$ 和 $B_3$ 移动到 $C$ 柱上面，就可以把 $A$ , $B$ 柱处理成 $m=2$ 的情况，然后就可以把 $A$ , $B$ 柱的颜色变成纯色，剩下 $C$ 柱上还有两个异色的分别放到相同颜色的柱子上就行。

想到这里我们欣喜若狂，仿佛找到了正解，于是想继续往下推，看看是否能继续推广，试探 $m=4$ 可以！，再试探一下 $m=5$ ，突然发现如果要把 $A$ , $B$ 都变成只有两个球，那么 $C$ 柱上就会有六个球，超出了 $m=5$ 的限制，这条路到这里就死了。

于是我们只能另寻他路，再想一想 $m>2$ 和 $m=2$ 有什么相同与不同之处，想啊想，想啊想，相同之处就是只有两种颜色，至于不同之处嘛，哪哪都不同。既然不同之处下不了手，那就从相同之处开始下手。
## Step2
相同之处是只有两种颜色，我们应该如何去利用这样的条件呢？开始往往是最难的地方，而一个百试不厌的方法就是去试，多种情况去试试，那么对于 $m=3$ ，有以下几种情况(其中可以通过颜色互换对称相同的视为同一种)
![](https://cdn.luogu.com.cn/upload/image_hosting/2p7noffq.png)

通过手动模拟可以发现，如果对于两根柱子上同种颜色的球都是连续的情况就可以通过类似 $m=2$ 的方法解决，如图中的①，②，⑦，⑨种情况。我们不妨把这种柱子称作**伪纯色柱**，那么在 $n=2$ 的情况下，如果两根柱子都是伪纯色柱，解法就很明了了，我们可以把连续一段相同颜色的球看作一个大球，那么就自然而然的转化成 $m=2$ 的情况了。

所以，我们的又一个思路就是把所有杂色柱转变为伪纯色柱，这看起来是不是比直接变成纯色柱要简单一点。我们又对自己有了信心，开始思考有什么办法可以把杂色变成伪纯色。两根柱子一起处理可以吗，思考一下会发现想不到什么好的办法，于是只能想从一根柱子开始处理的办法。

这里我们可以联想到**魔方**，没错，就是魔方。我们在复原魔方的时候会借助公式一层一层向上拼，同时又能在变化上层色块的时候保持下层色块在转动后回到原位。想到了这个，我们就可以去想一想这道题的结构是不是跟魔方十分相似，都是打乱色块，最后要把色块复原；都是有多种方法,但最后殊途同归。（~~所以我们可以把这道题目改名为CCF家的新魔方~~）

好，发现与魔方的相似之处后再来思考一根柱子上的球如何能把相同颜色的放在一起，假设没有任何限制，就是给你一根柱子，让你把上面混乱的两种颜色球使颜色相同的变成连续的。如果是我的话肯定就是把上面的球无脑全部拿下来，同种颜色的放到一块，然后再无脑拼回去。好，此时再回归题目，我们能不能无脑把 $A$ 柱上面的球全部拿下来分类呢？

如果 $B$ 柱不去动他，我们就只能把$A$柱上的球挨个放到$C$柱上面，最后 $C$ 柱(~~**活成了 $A$ 柱的模样**~~)就变成了倒过来的 $A$ 柱，对与解题~~貌似~~没有任何帮助。

所以，我们不得不去借助 $B$ 柱了，我们要注意在借助 $B$ 柱的时候不能打乱 $B$ 柱原始的顺序，否则到调整 $B$ 柱的时候需要借助 $A$ 柱，如果需要打乱原始顺序的话 $A$ 柱就白整了。

我们先想个法调整，最后再验证是否打乱顺序（这是一类常用的方法，先去满足必要性，再从必要性中一步步去剥充分性）。

联系到上面无限制条件的方法，我们需要借助 $B$ 柱给 $A$ 柱中的某一个颜色腾出空间，让 $A$ 柱上的某一种颜色能全部集中到一根柱子上去。

我们就假设 $A$ 柱上有黑球和白球两种颜色吧，我们不妨记录其中白球的数量为 $cnt$ 个，则黑球的数量就是 $m-cnt$ 个，所以 $B$ , $C$ 柱上一个要留 $cnt$ 个位置，一个要留 $m-cnt$ 个位置，我们不妨把所有白球放到 $B$ 柱上面去，所有黑球放到 $C$ 柱上面去（反正都是对称的），所以我们需要把 $B$ 柱上的前 $cnt$ 个球移动到 $C$ 柱上面，于是乎 $B$ 柱留下了 $cnt$ 个位置， $C$ 柱留下了 $m-cnt$ 个位置。如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/knagkufx.png)

接着我们从 $A$ 柱上一个一个向外拿球，如果是白球就放到 $B$ 柱，反之放到 $C$ 柱，当 $A$ 柱刚好拿完的时候， $B$ , $C$ 柱也刚好放满。此时 $A$ 柱的白球和黑球被完美分开了，接下来我们只需要先把 $B$ 柱上前 $cnt$ 个来自 $A$ 柱的白球放回 $A$ 柱，接着把 $C$ 柱上前 $m-cnt$ 个黑球放回 $A$ 柱，最后再把 $C$ 柱上来自 $B$ 柱的 $cnt$ 个不知道什么颜色的球放回 $B$ 柱，就完成了一次对 $A$ 柱的完美调整。

由于放球有先进后出的属性，可以轻松验证最后 $C$ 柱上 $cnt$ 个来自 $B$ 柱的球放回到 $B$ 柱的时候排列顺序与从 $B$ 柱拿走的时候不发生任何变化。由此便满足了我们所需要的一种调整方法。

接着对 $B$ 柱用相同的方法进行调整，便可以让 $A$ , $B$ 变成伪纯色柱，再用上文对于伪纯色柱的方法操作就可以了。

到此为止， $n=2$ 的十分就拿到手了，有的选手想到了这一步却没有继续往下做真的很可惜，因为这 $10$ 分的策略其实就是 $100$ 分的策略。
## Step3
解决完了两个柱子之间的策略之后其实与最终解法之间就只剩下一层薄薄的膜了（~~绝不是什么可悲的厚障壁~~），下面就要去讨论 $n$ 更大的情况，由于我很笨，所以我还是一个个试。

 $n=3$ 和 $n=2$ 的不同点在于多了一种颜色，不能对一根柱子进行暴力分类了，所以我们要想一种方法去让它可以被暴力分类。有什么办法呢？笨拙的我在纸上画来画去，原本用红蓝黑三种颜色来区别不同颜色的球，后来觉得换三支笔太累了，干脆用蓝黑来区别，空心蓝和实心蓝代表两种颜色的球，黑代表另一种颜色。

当这样偷懒之后，居然可以分类了！

我们可以把蓝笔画的分为一类，黑笔画的分为一类，对这两类分析，先选两个柱子，把蓝笔画的颜色看作 $1$ ，黑笔画的颜色看作 $2$ ，把选中的两个柱子整理为关于 $1$ , $2$ 的伪纯色柱，接着可以把 $1$ , $2$ 彻底分开，变成两个 $1$ 的纯色柱和一个 $2$ 的纯色柱，由于 $2$ 只代表一种颜色，所以 $2$ 的那一个纯色柱其实就已经完成了它的使命，接下来再去看 $1$ 的那两根纯色柱，问题就非常明了了，又变回了 $n=2$ 的情况。

到这里，所有迷雾都已经消散，我相信你们都已经看出来了，这已经可以通过分治解决了。

具体策略就很好想了，对于 $n$ 个柱子，把 $1$~$[\frac {n}{2}]$ 视为同一种颜色， $([\frac{n}{2}]+1)$~$n$ 视为同一种颜色，对其进行二分递归，具体操作其他大佬都已经讲过了，这里不再赘述。

# Summary
打完这篇题解，我一直在想，为什么考场上面我上面都没有想出来，如果静下心来好好分析的话至少10分还是可以拿到的，但是一开始就奔着满分去打，导致没有基础思路，无从下手，就像一个平面没有基底向量，什么也构成不了，平时喜欢玩魔方也没有看出这道题其实有魔方的思路在内，更没有发现这道题的思想早在初一上学期的《走一步再走一步》中就已经告诉过我。

一个复杂的问题可以被拆分成若干个简单的小问题。这句耳朵都听吐了的话到了真用上的时候却忘却。

所以，对于一个看起来很复杂的问题，还是要踏踏实实的从最简单的情况开始分析，然后一层一层的往上走，盖高楼大厦从来都是先打好地基，总不能直接从楼顶开始盖吧。

这篇题解更多的是想去把这道题想出来的过程呈现给大家，建立一个思维方式，懂得先走一步，再走一步。

**谨以此题解，祭奠我逝去的2020NOIP**


------------
**update 2020.12.14**

之前有个可以考场上猜出大致思考方向的方法忘记说了，其实ccf已经给过我们提示了，就在大数据答案中：
```
11 51
11 51
50 51
50 51
50 51
50 51
50 51
50 51
50 51
50 51
50 51
50 51
```
我们可以清楚的到有很长一串都是同一根柱子进行相同的操作，事实上这个从 $50$ 转移到 $51$ 的操作一共有 $31$ 次，再往下看就是从 $51$ 移动回 $50$ ， $11$ 移动到 $51$ ，下面的答案也是类似操作，考场上看样例答案也许会有意想不到的启发哟。

---------

---

## 作者：KaisuoShutong (赞：46)

首先我们明确大体思路：分治。

怎么分治？

每次我们假定只有两个颜色，达到的目的是每种颜色都在一边。  
例如：
```
[1]  [1]  [2]
[3]  [1]  [3]
[2]  [2]  [3]
```
我们假定颜色 $1,2$ 为 A 颜色，$3$ 为 B 颜色。
那么变为：
```
[A]  [A]  [A]
[B]  [A]  [B]
[A]  [A]  [B]
```
我们想要使其变成这种状态：
```
[A]  [A]  [B]
[A]  [A]  [B]
[A]  [A]  [B]
```
接下来分两边递归处理。  
至于 A 颜色和 B 颜色内部的顺序，我们并不关心，因为在接下来的递归中，它们都会被处理到。

具体实现的时候，我们用一个 `STL::vector` 带着这次处理的列走就行了。

这个框架的时间和操作复杂度为 $O(n \log_2 n)$，也就意味着剩下的处理复杂度大概是 $O(m)$ 的。

考虑怎么进行一次操作。

第一步，我们使用**整理**操作。  
即，将每一列整理成上面 B 颜色，下面 A 颜色的状态。  
举个例子。
原本某一列长这样：
```
[A]
[B]
[B]
[A]
[B]
```
我们要使其变为这样：
```
[B]
[B]
[B]
[A]
[A]
```
怎么做呢？  
1. 统计第一根柱子的 `[A]` 的个数，设为 $T$ 。
2. 将第二根柱子的上面 $T$ 个移到空列上。
3. 移动所有第一根柱子上的球。如果为 `[A]`，移到第二根柱子上，否则移到空列上。
4. 将第二根柱子上边 $T$ 个（一定全为 `[A]`）移回第一根柱子。
5. 将空列上面 $m-T$ 个（一定全为 `[B]`）移回第二根柱子。
6. 将空列上剩的 $T$ 个移回第二根柱子。

举个例子。

1.
```
[A] [X] [_]
[B] [X] [_]
[B] [X] [_]
[A] [X] [_]
[B] [X] [_]
```

2.
```
[A] [_] [_]
[B] [_] [_]
[B] [X] [_]
[A] [X] [X]
[B] [X] [X]
```

3.
```
[_] [A] [B]
[_] [A] [B]
[_] [X] [B]
[_] [X] [X]
[_] [X] [X]
```

4.
```
[_] [_] [B]
[_] [_] [B]
[_] [X] [B]
[A] [X] [X]
[A] [X] [X]
```

5.
```
[B] [_] [_]
[B] [_] [_]
[B] [X] [_]
[A] [X] [X]
[A] [X] [X]
```
6.
```
[B] [X] [_]
[B] [X] [_]
[B] [X] [_]
[A] [X] [_]
[A] [X] [_]
```

这样**不会改变空列的位置，不会改变第二根柱子的顺序**，完成了对第一根柱子的整理。

第二步，我们使用**合并**操作。

首先我们定义**翻转**操作。  
非常简单，将一列的数全部插入空列。
即：
```
[B]    [A]
[B]    [B]
[B] -> [B]
[B]    [B]
[A]    [B]
```

对于最上面的颜色不一样的两列，我们翻其中一列，使两列最上面的东西都相同。  
接着我们计算两列处于上面的颜色的个数加起来是否小于等于 $m$。如果大于，那就翻转两列，使得两列处于上面的个数加起来小于等于 $m$。

接着我们做：
1. 把两列的上面分别放进空集。
2. 把第二列的剩下的东西填满第一列。
3. 把空集里的东西丢回第二列。

举个例子。
```
[A] [A] [_]
[A] [B] [_]
[B] [B] [_]
[B] [B] [_]
[B] [B] [_]
```

1.
```
[_] [_] [_]
[_] [B] [_]
[B] [B] [A]
[B] [B] [A]
[B] [B] [A]
```

2.
```
[B] [_] [_]
[B] [_] [_]
[B] [_] [A]
[B] [B] [A]
[B] [B] [A]
```

3.
```
[B] [A] [_]
[B] [A] [_]
[B] [A] [_]
[B] [B] [_]
[B] [B] [_]
```

这样，我们每次都可以“生成”一个纯色列。  

结合这两大步，可以做完一次操作。

---

## 作者：Calculatelove (赞：14)

题目链接：[Link](https://www.luogu.com.cn/problem/P7115)。

感谢 [xyz32768](https://www.luogu.com.cn/user/29936) 的指导，以及[他的题解](https://www.cnblogs.com/xyz32768/p/14159770.html)。

## 算法一

特殊性质：$n = 2$。

- 现在有三个柱子 $x, y, z$。  
  其中 $x$ 号柱与 $y$ 号柱是满的，$z$ 号柱是空的。  
  这 $2m$ 个球中有 $m$ 个关键球，现在要将所有关键球移动到同一根柱子上。

- 设 $x$ 柱上有 $c$ 个关键球，操作如下：

  - （1）：将 $y$ 号柱上的 $c$ 个球移动到 $z$ 号柱上。

  - （2）：依次考虑 $x$ 号柱里的每一个球。

    > 若该球为关键球，则将其移动到 $y$ 号柱。  
    > 若该球不为关键球，则将其移动到 $z$ 号柱。

  - （3）：将 $z$ 号柱上方的 $m - c$ 个球移回 $x$ 号柱。

  - （4）：将 $y$ 号柱上方的 $c$ 个球移动到 $x$ 号柱。

  - （5）：将 $z$ 号柱里的 $c$ 个球移动到 $y$ 号柱。

  - （6）：将 $x$ 号柱上方的 $c$ 个球移动到 $z$ 号柱。

  - （7）：依次考虑 $y$ 号柱里的每一个球。

    > 若该球为关键球，则将其移动到 $z$ 号柱。  
    > 若该球不为关键球，则将其移动到 $x$ 号柱。

- 此时 $n = 2$ 就做完了，复杂度是 $\mathcal{O(m)}$ 的。

- 「算法一」是本题中**最基本的操作**。

## 算法二

特殊性质：$n \leq 50$，$m \leq 300$。

- 可以一个颜色一个颜色来考虑。  
  假设考虑到第 $n$ 个颜色，现在要将所有颜色为 $n$ 的球移动到同一根柱子上：

1. 枚举 $i = 1 \to (n - 1)$。  
   该步骤的意义为：将 $i$ 号柱里所有颜色为 $n$ 的球都移动到 $i$ 号柱子的最顶端。  
   记 $i$ 号柱共有 $c_i$ 个颜色为 $n$ 的球，操作如下：

   - （1）：将 $n$ 号柱移出 $c_i$ 个空位。

   - （2）：依次考虑 $i$ 号柱里的每一个球。 

     > 若该球的颜色为 $n$，则将其移动到 $n$ 号柱。  
     > 若该球的颜色不为 $n$，则将其移动到 $n  + 1$ 号柱。

   - （3）：将 $n + 1$ 号柱上方的 $m - c_i$ 个球移回 $i$ 号柱。

   - （4）：将 $n$ 号柱上方的 $c_i$ 个球移回 $i$ 号柱。

   - （5）：将 $n + 1$ 号柱上方的 $c_i$ 个球移回 $n$ 号柱。

2. 枚举 $i = 1 \to (n - 1)$。  
   将 $i$ 号柱子最顶端所有颜色为 $n$ 的球都移动到 $n + 1$ 号柱上。

3. 依次考虑 $n$ 号柱子里的每一个球。

   > 若该球的颜色为 $n$，则将其移动到 $n + 1$ 号柱。  
   > 若该球的颜色不为 $n$，则将其补到 $1$ 至 $n - 1$ 号柱里的一个空位上。

- 这样的话就得到了一个规模为 $n - 1$ 的子问题，直接递归调用到 $1$ 即可。
- 复杂度是 $\mathcal{O}(n^2m)$ 的。  
  来计算一下该算法的严格操作数。
- 记 $g(n)$ 表示解决一个规模为 $n$ 的问题，且不向下递归调用时需要的操作数，则：

$$
\begin{aligned}g(n)& = \sum\limits_{i = 1}^{n - 1} (2m + 2c_i) + \sum\limits_{i = 1}^{n - 1} c_i + m\\& = 2m(n - 1) + 3\sum\limits_{i = 1}^{n - 1} c_i + m\\& = 2nm - m + 3\sum\limits_{i = 1}^{n - 1} c_i\end{aligned}
$$

- 在最坏情况下，$\sum\limits_{i = 1}^{n - 1} c_i = m$，则：

$$
\begin{aligned}

g(n) & = 2nm - m + 3m

\\

& = 2nm + 2m

\\

& = 2m(n + 1)

\end{aligned}
$$

- 此时：

$$
\begin{aligned}\text{answer}& = \sum\limits_{i = 2}^n g(i)\\& = \sum\limits_{i = 2}^n 2m(i + 1) \\& = 2m \sum\limits_{i = 2}^n (i + 1)\\& = 2m [\frac{(n + 1)(n + 2)}{2} - 3]\\& = m(n - 1)(n + 4)\end{aligned}
$$

- 发现刚好可以过掉 $70$ 分。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

inline int read() {
	int x = 0, f = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') f = -f; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * f; 
}

const int N = 60, M = 450;

int n, m;

int top[N], a[N][M];
int cnt[N][M];

int t;
pair<int, int> ans[820001];

void move(int x, int y) {
	ans[++ t] = make_pair(x, y);

	int u = a[x][top[x]];

	cnt[x][u] --;
	cnt[y][u] ++;

	a[y][++ top[y]] = a[x][top[x] --];
}

void solve(int u) {
	if (u == 1)
		return;

	for (int i = 1; i < u; i ++) {
		int c = cnt[i][u];

		for (int j = c; j; j --)
			move(u, u + 1);

		for (int j = m; j; j --)
			if (a[i][j] == u) move(i, u);
			else move(i, u + 1);

		for (int j = m - c; j; j --)
			move(u + 1, i);

		for (int j = c; j; j --)
			move(u, i);

		for (int j = c; j; j --)
			move(u + 1, u);
	}

	for (int i = 1; i < u; i ++)
		while (a[i][top[i]] == u)
			move(i, u + 1);

	int p = 1;
	for (int j = top[u]; j; j --) {
		if (a[u][j] == u) move(u, u + 1);
		else {
			while (top[p] >= m) p ++;
			move(u, p);
		}
	}

	solve(u - 1);
}

int main() {
	n = read(), m = read();

	for (int i = 1; i <= n; i ++) {
		top[i] = m;
		for (int j = 1; j <= m; j ++)
			a[i][j] = read(), cnt[i][a[i][j]] ++;
	}

	solve(n);

	printf("%d\n", t);
	for (int i = 1; i <= t; i ++)
		printf("%d %d\n", ans[i].first, ans[i].second);

	return 0;
}

// I hope changle_cyx can pray for me.
```

## 算法三

特殊性质：$n \leq 50$，$m \leq 400$。

- 注意到「算法二」中，" 一个颜色一个颜色来考虑 " 有点浪费。  
  可不可以多个颜色一起考虑呢。

- 这启发我们分治。

- 定义分治函数 `solve(l, r)`，取中点 $\text{mid} = \left\lfloor \frac{l + r}{2} \right\rfloor $。  
  在每一轮中我们的目的是：将所有 " 颜色 $\leq \text{mid}$ 的球 " 与 " 颜色 $> \text{mid}$ 的球 " 区分开来。  
  即：经过一系列操作过后，不存在一根柱子上同时有 " 颜色 $\leq \text{mid}$ 的球 " 和 " 颜色 $> \text{mid}$ 的球 "。  
  随后调用 `solve(l, mid)` 与 `solve(mid + 1, r)`。

- 问题的关键在于如何区分。

- 在每一轮中，我们将这 $r - l + 1$ 根柱子取出来。  
  每次我们可以挑出两根柱子：

  - （1）：如果 " 颜色 $\leq \text{mid}$ 的球 " 超过了 $m$ 个，则选取任意 $m$ 个 " 颜色 $\leq \text{mid}$ 的球 " 作为关键球，进行「算法一」中的基本操作。
  - （2）：如果 " 颜色 $> \text{mid}$ 的球 " 超过了 $m$ 个，则选取任意 $m$ 个 " 颜色 $> \text{mid}$ 的球 " 作为关键球，进行「算法一」中的基本操作。

  这样进行 $r - l$ 次，这 $r - l + 1$ 根柱子也就达到了每一轮的目的，递归下去解决即可。

- 考虑分治树的结构，共有 $\mathcal{O(\log n)}$ 层。  
  对于每层的所有节点，进行上述的基本操作的复杂度是 $\mathcal{O(nm)}$ 的。  
  故复杂度为 $\mathcal{O(nm \log n)}$，肯定是可以过的。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

inline int read() {
	int x = 0, f = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') f = -f; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * f; 
}

const int N = 60, M = 410;

int n, m;

int top[N], a[N][M];
int em;

int t;
pair<int, int> ans[820001];

void move(int x, int y) {
	ans[++ t] = make_pair(x, y);

	a[y][++ top[y]] = a[x][top[x] --];
}

bool impx[M], impy[M];

int merge(int x, int y, int mid) {
	int cx = 0, cy = 0;

	for (int i = 1; i <= m; i ++)
		impx[i] = a[x][i] <= mid,
		impy[i] = a[y][i] <= mid;

	for (int i = 1; i <= m; i ++)
		cx += impx[i], cy += impy[i];

	if (cx + cy > m) {
		cx = m - cx, cy = m - cy;

		for (int i = 1; i <= m; i ++)
			impx[i] ^= 1, impy[i] ^= 1;
	}

	for (int i = 1; i <= m; i ++)
		if (!impx[i] && cx + cy < m)
			impx[i] = 1, cx ++;

	for (int i = cx; i; i --)
		move(y, em);

	for (int i = m; i; i --)
		if (impx[i]) move(x, y);
		else move(x, em);

	for (int i = m - cx; i; i --)
		move(em, x);

	for (int i = cx; i; i --)
		move(y, x);

	for (int i = cx; i; i --)
		move(em, y);

	for (int i = cx; i; i --)
		move(x, em);

	for (int i = m; i; i --)
		if (impy[i]) move(y, em);
		else move(y, x);

	int p = em; em = y;
	return p;
}

void solve(int l, int r) {
	if (l == r) return;
	int mid = (l + r) >> 1;

	vector<int> now;
	for (int i = 1; i <= n + 1; i ++) {
		if (i == em) continue;
		if (l <= a[i][1] && a[i][1] <= r) now.push_back(i);
	}

	for (int i = 0; i + 1 < (int)now.size(); i ++)
		now[i + 1] = merge(now[i], now[i + 1], mid);

	solve(l, mid), solve(mid + 1, r);
}

int main() {
	n = read(), m = read();

	em = n + 1;

	for (int i = 1; i <= n; i ++) {
		top[i] = m;
		for (int j = 1; j <= m; j ++)
			a[i][j] = read();
	}

	solve(1, n);

	printf("%d\n", t);
	for (int i = 1; i <= t; i ++)
		printf("%d %d\n", ans[i].first, ans[i].second);

	return 0;
} 

// I hope changle_cyx can pray for me. 
```

# 

---

## 作者：Warriors_Cat (赞：7)

Life is continuing……

---

[题面传送门](https://www.luogu.com.cn/problem/P7115)，题意可以从这里看。

这里仅仅讲正解，如果需要知道暴力怎么打可以去其他题解看。

---

### $Solution:$

以下把柱子看作栈，球看作数字，颜色看作权值。

先考虑一个小问题：

给 $A$，$B$ 两个满栈和一个空栈 $C$，数字权值均为 $0$ 或 $1$，**$A$，$B$ 的数字合并起来可以有一种权值的个数 $> m$**。现假设权值 $0$ 的个数 $\ge m$，如何利用这三个栈使得 $A$，$B$ 栈为满栈且 $A$ 栈数字权值均为 $0$。

这个问题是可以解决的，具体操作如下：

1. 记 $A$ 栈中 $0$ 的个数为 $x$，将 $B$ 栈前 $x$ 个数字放至 $C$ 栈。
2. 依次枚举 $A$ 栈的数字，如果权值为 $0$ 则放入 $B$ 栈，否则放入 $C$ 栈，显然 $A$ 栈空后 $B$，$C$ 栈均满。
3. 将 $B$ 栈前 $x$ 个元素放至 $A$ 栈，再将 $C$ 栈中前 $m - x$ 个元素放入 $A$ 栈，最后将 $C$ 栈中剩下 $x$ 个元素放入 $B$ 栈。
4. 记 $B$ 栈中 $0$ 的个数为 $y$，将 $A$ 栈前 $y$ 个数字放至 $C$ 栈。由小问题题面可知 $x + y \ge m$。
5. 依次枚举 $B$ 栈的数字，如果权值为 $0$ 则放入 $A$ 栈，否则放入 $C$ 栈。$B$ 栈空后，因为 $x + y \ge m$，所以此时 $A$ 栈数字权值均为 $0$。
6. 将 $C$ 栈中所有的数字放至 $B$ 栈，以保证 $C$ 还是空栈。

显然这里的操作次数是 $4m + 2x + y$ 次，最坏为 $7m$ 次。

当然在实际代码可能是权值为 $1$ 的个数 $> m$，原理相同，这里不再多讲。 

我们记这个操作叫做 “利用 $B$ 填充 $A$ 的 $0$” 或 “利用 $B$ 填充 $A$ 的 $1$”。

考虑分治。假设我们现在要操作的区间为 $(L, R)$，$mid = \dfrac{L + R}{2}$。

我们将 $L$ 到 $R$ 上所有的数字中颜色 $> mid$ 的权值记为 $1$，否则记为 $0$。

分治的目标是：**将 $L$ 到 $mid$ 上所有的数字的权值都变为 $0$，将 $mid + 1$ 到 $R$ 上所有的数字的权值都变为 $1$**。

跟普通的快排一样，我们运用双指针 $l$ 和 $r$，一开始分别指向 $L$ 和 $R$。然后统计其中权值为 $1$ 的个数。如果这个个数 $> m$ 就利用 $l$ 填充 $r$ 的 $1$，同时 $r$ 左移；否则利用 $r$ 填充 $l$ 的 $0$，同时 $l$ 右移。

然后就可以变成 $(L, mid)$ 和 $(mid + 1, R)$ 两个区间的子问题了。如此归并下去，到 $L = R$ 的时候自然排好了。

另外，这里的快排是不会退化到 $O(n^2)$ 的。普通的快排退化到 $O(n^2)$ 是因为 $mid$ 处的权值可能是最大的，或者是最小的，这样就使得操作数大大增加。而在这里权值为 $0$ 的个数与权值为 $1$ 的个数是绝对的，而且相差为 $m$，所以很平均，不会被卡。

根据快排的时间复杂度，可得总操作次数为 $7nm\left\lceil\log_2n\right\rceil$，算一下大约是 $840000$，还差一点。

这里膜拜一下铃酱（[鏡音リン](https://www.luogu.com.cn/user/90893)），学了 TA 的优化这题就做完了。

我们发现在“利用 $B$ 填充 $A$ 的 $0$ / $1$” 的常数特别大，能不能有办法减小常数呢？

答案是有的。在这个操作中，如果 $x > \dfrac{m}{2}$，那么我们可以只把 $B$ 栈前 $m - x$ 个数字放到 $C$，然后在 $2.$ 中交换一下 $B$、$C$ 的性质，最后再把 $C$ 中剩下的 $m - x$ 个元素还回去即可。

于是操作次数降为 $4m + 2\min\{x, m - x\}+y$，最坏为 $6m$。

总操作次数就变为了 $6nm\left\lceil\log_2n\right\rceil$，大约是 $700000$，时间复杂度也是此级别，对于这道题来说算是绰绰有余了。

---

### $Code:$

代码不长，2KB 都不到，而且很好写。

以下代码仅供参考。

```cpp
#include <cstdio>
using namespace std;
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 60, M = 410, K = 820010;
int n, m, a[N][M], len[N], ans, q[K], b[N][M];
inline void Move(int x, int y){ a[x][++len[x]] = a[y][len[y]]; b[x][len[x]] = b[y][len[y]]; --len[y]; q[++ans] = y * 65 + x; }//单次移动 y -> x
inline void movenum(int x, int y, int z){ while(z--) Move(x, y); }//多次移动 y -> x
inline void movecol(int x, int y, int z){// 利用 y 填充 x 为 z 
	int num = 0; for(int i = 1; i <= m; ++i) num += (b[x][i] == z);
	if(num == m) return; if(num > m / 2){
		movenum(n + 1, y, m - num);
		for(int i = m; i; --i){ if(b[x][i] == z) Move(n + 1, x); else Move(y, x); }
		movenum(x, n + 1, num); movenum(x, y, m - num); movenum(y, n + 1, m - num);
	}else{
		movenum(n + 1, y, num);
		for(int i = m; i; --i){ if(b[x][i] == z) Move(y, x); else Move(n + 1, x); }
		movenum(x, y, num); movenum(x, n + 1, m - num); movenum(y, n + 1, num);
	}
	num = 0; for(int i = 1; i <= m; ++i) num += (b[y][i] == z); movenum(n + 1, x, num); 
	for(int i = m; i; --i){ if(b[y][i] == z) Move(x, y); else Move(n + 1, y); } movenum(y, n + 1, m);
}
inline void Qsort(int l, int r){//分治 
	if(l == r) return; int mid = l + r >> 1, x = l, y = r;
	for(int i = l; i <= r; ++i) for(int j = 1; j <= m; ++j) b[i][j] = (a[i][j] > mid);
	while(x <= mid && y > mid){
		int num = 0;
		for(int i = 1; i <= m; ++i) num += b[x][i] + b[y][i];
		if(num > m) movecol(y--, x, 1); else movecol(x++, y, 0);
	}
	Qsort(l, mid); Qsort(mid + 1, r);
}
inline void print(){ printf("%d\n", ans); for(int i = 1; i <= ans; ++i) printf("%d %d\n", q[i] / 65, q[i] % 65); }
int main(){
	n = read(); m = read();
	for(int i = 1; i <= n; ++i){
		len[i] = m;
		for(int j = 1; j <= m; ++j){
			a[i][j] = read();
		}
	}
	Qsort(1, n); print(); return 0;
}
```
---
总的来说这题思维难度还是很高的，特别是得先想到一个小问题再转换为大问题，同时还要运用分治思想。尽管在 NOIp 中出构造题可能会有些不妥，但不可否认这题质量之高。

---

## 作者：Loser_Syx (赞：4)

比较有思维含量的题。

这题主要是发现一个性质，就是一个颜色一个颜色地归纳，最后的局面也一定是可完成的。

这就启示我们对于每个颜色分开来做，于是我们枚举颜色 $c\in [1,n-1]$，表示这是我们的第 $c$ 个要归纳的颜色，那么和 $c$ 颜色不同的就没用了，不妨改为 $0$，和 $c$ 相同的就改为 $1$。

我们的任务现在就是如何把这 $m$ 个 $1$ 改到同一个位置，需要合理运用这个空列。

这个时候就需要很聪明的想到，在这 $m$ 个 $1$ 摆放好之前，先使得 $n$ 列最顶端都放置上 $1$，然后直接移是简单的。

换句话说呢，就是使每列下面的都填上 $0$，这个本来看上去也是困难的，那如果说我们本来就有一个全都是 $0$ 的列呢？

那么事情就变得简单许多了，我们随意挑一列未“排序”的列出来，记 $1$ 的个数为 $cnt$，先把全 $0$ 列的 $cnt$ 个数移走，然后再对这一列进行拆分，把 $1$ 的放到全是 $0$ 的列上，把 $0$ 放分出来的 $cnt$ 个上。

这样我们就发现，原本全是 $0$ 的上面变成了我们所想要的样子，而我们分成的另外一列就变成了全是 $0$ 的一列。

于是我们只需构造全是 $0$ 的一列了，我们先“故技重施”把其中一列的 $0$ 提到最上面，然后由于 $1$ 的个数只有 $m$ 个，也就是我只要找两列，就一定会凑出来至少一整列的 $0$。所以我们直接把已经筛选出来的 $n-cnt$ 个 $0$ 摆到空位上，再找另外的一列（不能找一开始分出 $cnt$ 个的那一列是因为 $cnt$ 个里面 $0$ 或 $1$ 不确定可能不够），里面分出 $cnt$ 个 $0$ 就构造出了全 $0$ 列。

然后我们就**基本**做完了。但是我们发现剩 $2$ 个的时候，全 $0$ 列构造不了啊！怎么办呢。

还是可以先把 $0$ 提到上面，然后把 $0$ 全都放到空位上，最后把满的那一列分成 $0$ 和 $1$。

操作次数是好算的，第 $i$ 次有 $n-i+1$ 种颜色，所以是 $\sum_i (i+5)m$ 次，完全足够通过。

```cpp
int n, m, e, tmp;
int a[500][500], d[500], v[500];
int p[500], siz;
vector<pii> sol;
void rem(int x,int y) {
	a[y][++d[y]]=a[x][d[x]--];
	sol.eb(x,y);
}
signed main() {
	read(n, m); e=n+1;
	for (int i=1;i<=n;++i) for (int j=1;j<=m;++j) read(a[i][j]);
	for (int i=1;i<=n;++i) d[i]=m;
	for (int c=n;c>2;--c) {
		siz=0;
		for (int i=1;i<=n+1;++i) {
			if (v[i]) continue;
			if (d[i]) p[++siz]=i;
		} int cnt=0;
		for (int i=m;i;--i) cnt+=a[p[1]][i]==c;
		for (int i=1;i<=cnt;++i) rem(p[siz],e);
		for (int i=m;i;--i) if (a[p[1]][i]!=c) rem(p[1],e); else rem(p[1],p[siz]);
		for (int i=1;i<=m-cnt;++i) rem(e,p[1]);
		for (int i=m;i;--i) if (a[p[2]][i]!=c&&d[p[1]]<m) rem(p[2],p[1]); else rem(p[2],e);
		swap(p[2],e);
		for (int i=2;i<=siz;++i) {
			int q=0;
			for (int j=m;j;--j) q+=a[p[i]][j]==c;
			for (int j=1;j<=q;++j) rem(p[1],e);
			for (int j=m;j;--j) if (a[p[i]][j]!=c) rem(p[i],e); else rem(p[i],p[1]);
			swap(p[1],p[i]); swap(p[1],e);
		}
		for (int i=1;i<=siz;++i) {
			int q=0;
			for (int j=m;j;--j) if (a[p[i]][j]==c) ++q;
			for (int j=1;j<=q;++j) rem(p[i],e);
			for (int j=1;j<=q;++j) rem(p[1],p[i]);
		}
		v[e]=1; e=p[1];
	}
	siz=0;
	for (int i=1;i<=n+1;++i) {
		if (v[i]) continue;
		if (d[i]) p[++siz]=i;
	} int cnt=0;
	for (int i=1;i<=m;++i) cnt+=a[p[1]][i]==2;
	for (int i=1;i<=cnt;++i) rem(p[2],e);
	for (int i=m;i;--i) if (a[p[1]][i]!=2) rem(p[1],e); else rem(p[1],p[2]);
	for (int i=1;i<=m-cnt;++i) rem(e,p[1]);
	for (int i=1;i<=cnt;++i) rem(p[2],p[1]);
	for (int i=1;i<=cnt;++i) rem(e,p[2]);
	for (int i=1;i<=cnt;++i) rem(p[1],e);
	for (int i=m;i;--i) if (a[p[2]][i]!=2) rem(p[2],p[1]); else rem(p[2],e);
	write(sol.size());
	for (pii x:sol) {
		write(x.F,' '); write(x.S,'\n');
	}
	return 0;
}
```

---

## 作者：ZnPdCo (赞：3)

构造题。

首先可以非常容易想到 $n=2$ 的解法，把 $1$ 看作黑球，$2$ 看作白球，$x$ 作为第一列，$y$ 作为第二列，$n+1$ 作为多出的一列：

0. 初始状态。

   ```plain
   121121
   122212

   ```

1. 将 $x$ 中的黑球个数 $cx$ 统计下来，把 $y$ 中 $cx$ 个球移动到 $n+1$。

   ```plain
   121121
   12
   2122
   ```

2. 将 $x$ 中的黑球放到 $y$，白球放到 $n+1$。

   ```plain

   121111
   212222
   ```

3. 把 $n+1$ 中的 $m-cx$ 个原属于 $x$ 的白球移动回 $x$。

   ```plain
   22
   121111
   2122
   ```

4. 把 $y$ 中的 $cx$ 个原属于 $x$ 的黑球移动回 $x$。（$x$ 现在前面是白球，后面是黑球）

   ```plain
   221111
   12
   2122
   ```

5. 把 $n+1$ 中的 $cx$ 个原属于 $y$ 的球移动回 $y$。

   ```plain
   221111
   122212

   ```

6. 把 $x$ 中的 $cx$ 个黑球放到 $n+1$（$x$ 现在只有白球）

   ```plain
   22
   122212
   1111
   ```

7. 把 $y$ 中的黑球放到 $n+1$，白球放到 $x$。

   ```plain
   222222

   111111
   ```

8. 把 $n+1$ 中的黑球放回 $y$。

   ```plain
   222222
   111111

   ```

---

上面其实就是将第二列作为黑球的储存地，第三列作为白球的储存地。

其实和正解很接近。

不妨利用分治思想，分治一个 $mid$，将小于等于 $mid$ 的看作黑球，大于 $mid$ 的看作白球。然后把颜色在 $[l,r]$ 内的两两相邻的做 $n=2$ 的操作。

但是我们会发现，黑球的个数 $w$ 可能会大于或小于 $m$，这会导致在进行如上相同操作时，$y$ 列不够多放到 $n+1$ 列。

所以当 $w<m$ 时，我们**随机**选择一些白球染成黑球；当所以当 $w>m$ 时，我们**随机**选择一些黑球染成白球。

因为我们会在下一次分治时进一步分类，所以不用担忧黑球和白球会混在一起。

最坏情况是 $7nm\log n\le800000$，可以过。

```c++
#include <cstdio>
#include <vector>
using namespace std;
#define ll long long
#define N 60
#define M 410
#define debug false
ll n, m;
ll top[N];
ll num[N][M];	// 某一行某种颜色的个数
ll a[N][M];		// 给定的颜色分布
bool b[N][M];	// 黑白球规定


struct node {
	ll x, y;
} ans[820010];
ll cnt;


void show() {
	for(ll i = 1; i <= n+1; i++) {
		for(ll j = 1; j <= top[i]; j++) {
			printf("%lld ", a[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void mov(ll x, ll y) {
	ans[++cnt].x = x;
	ans[cnt].y = y;
	
	a[y][++top[y]] = a[x][top[x]--];
	
	if(debug) show();
}

void fun(ll x, ll y, ll mid) {
	ll numx = 0, numy = 0;
	for(ll i = 1; i <= m; i++) {
		if(a[x][i] <= mid) numx++, b[x][i] = 1;
		else b[x][i] = 0;
		if(a[y][i] <= mid) numy++, b[y][i] = 1;
		else b[y][i] = 0;
	}
	
	// 1.如果太多黑球则取反
	if(numx + numy > m) {
		numx = m - numx, numy = m - numy;
		for(ll i = 1; i <= m; i++) b[x][i] ^= 1, b[y][i] ^= 1;
	}
	
	// 2.如果太少则添加虚拟黑球（把黑球放到y）
	for(ll i = 1; i <= m; i++) {
		if(!b[x][i] && numx + numy < m) {
			numx++;
			b[x][i] = 1;
		}
	}
	
	// 3.把y中的numx个取到n+1中
	if(debug) printf("把y中的numx个取到n+1中\n");
	for(ll i = 1; i <= numx; i++) {
		mov(y, n+1);
	}
	// 4.把x中的黑球放到y，白球放到n+1
	if(debug) printf("把x中的黑球放到y，白球放到n+1\n");
	for(ll i = 1; i <= m; i++) {
		if(b[x][top[x]]) {
			mov(x, y);
		} else {
			mov(x, n+1);
		}
	}
	// 5.把n+1中的m-numx个白球放回到x
	if(debug) printf("把n+1中的m-numx个白球放回到x\n");
	for(ll i = 1; i <= m-numx; i++) mov(n+1, x);
	
	// 6.把y中的numx个黑球放回到x（x现在前面是白球，后面是黑球）
	if(debug) printf("把y中的numx个黑球放回到x（x现在前面是白球，后面是黑球）\n");
	for(ll i = 1; i <= numx; i++) mov(y, x);
	
	// 7.把n+1中的numx放回到y（y现在不变）
	if(debug) printf("把n+1中的numx放回到y（y现在不变）\n");
	for(ll i = 1; i <= numx; i++) mov(n+1, y);
	
	// 8.把x中的numx个黑球放到n+1（x现在只有白球）
	if(debug) printf("把x中的numx个黑球放到n+1（x现在只有白球）\n");
	for(ll i = 1; i <= numx; i++) mov(x, n+1);
	
	// 9.把y中的黑球放到n+1，白球放到x
	if(debug) printf("把y中的黑球放到n+1，白球放到x\n");
	for(ll i = 1; i <= m; i++) {
		if(b[y][top[y]]) {
			mov(y, n+1);
		} else {
			mov(y, x);
		}
	}
	
	// 10.把n+1中的黑球放回y
	if(debug) printf("把n+1中的黑球放回y\n");
	for(ll i = 1; i <= m; i++) {
		mov(n+1, y);
	}
}

void solve(ll l, ll r) {
	if(debug) printf("===%lld %lld===\n", l, r);
	
	if(l == r) return;
	
	ll mid = (l + r) >> 1;
	vector<ll> now;
	for(ll i = 1; i <= n; i++) {
		if(l <= a[i][1] && a[i][1] <= r) {
			now.push_back(i);
		}
	}
	for(ll i = 0; i < now.size() - 1; i++) {
		fun(now[i], now[i+1], mid);
	}
	
	solve(l, mid);
	solve(mid+1, r);
}

int main() {
	freopen("ball.in", "r", stdin);
	freopen("ball.out", "w", stdout);
	
	scanf("%lld %lld", &n, &m);
	
	for(ll i = 1; i <= n; i++) {
		for(ll j = 1; j <= m; j++) {
			scanf("%lld", &a[i][j]);
			num[i][a[i][j]]++;
		}
		top[i] = m;
	}
	
	solve(1, n);
	
	printf("%lld\n", cnt);
	for(ll i = 1; i <= cnt; i++) {
		printf("%lld %lld\n", ans[i].x, ans[i].y);
	}
	
//	show();
}
```

---

## 作者：Mirasycle (赞：1)

暑假 vp 的时候连 $n=2$ 的常规解法都没想到，于是一波爆搜强行构造 $n=2$ 方案喜提 $10$ 分。

当时还不会按照值域 $0/1$ 分治的 trick，不过后来见到了无数次这种 trick。

我印象中这个题也是分治构造的。[ P9731 [CEOI2023] Balance ](https://www.luogu.com.cn/problem/P9731)

下文中将柱子称为栈 $s$，毕竟两者的用法是一样的。


先思考 $n=2$ 时候的解法，记录两个栈为 $s_1$ 和 $s_2$，分别目标为 $1$ 球和 $2$ 球。我们现在想要其中一个栈变成全 $1$。我们发现 $s_1$ 和 $s_2$ 都往空栈里面放一点东西进去似乎只有暴搜放进去的顺序然后 $2$ 和 $3$ 栈互相搞一下的很暴力的做法，没有可扩展性。

有没有什么好办法去分离 $1$ 和 $2$ 两种小球呢，只有两个空栈能办到。我们现在只有一个空栈，转念一想，**其实我们可以再创造两个半空栈**，设 $s_1$ 中有 $a$ 个 $1$，那么我们只需要从 $s_1$ 中挪 $\min(a,m-a)$ 个球给 $s_3$。不妨设 $a<m-a$，然后将 $s_1$ 中球依次弹出，如果是 $1$ 则放入 $s_2$ 中，如果是 $0$ 则放入 $s_3$ 中，这次操作把部分 $0$ 和 $1$ 聚集在了一起。

接着，把 $s_2$ 和 $s_3$ 栈顶的 $0/1$ 段全部再放回 $s_1$ 中，这一步我们实现了对于 $s_1$ 的排序。

将 $s_2$ 中的所有数移动到 $s_3$ 中，再把 $s_1$ 中顶端的 $1$ 段放入 $s_2$ 中。这一步我们实现了将 $0$ 和 $1$ 段分别独立地放在 $s_1$ 和 $s_2$ 中。

然后就是处理 $s_3$ 了，我们只需要根据是 $0$ 还是 $1$ 分别放入 $s_1$ 或者 $s_2$ 即可。

这样子我们就完美解决了 $n=2$ 的情况。


那么对于 $n>2$ 的时候呢？把问题转化到 $n=2$！

我们设 $\operatorname{solve}(l,r)$ 表示正在处理颜色为 $[l,r]$ 范围内的球。我们将 $x\le mid$ 的球全部看成一种颜色，将 $x>mid$ 的球看成另一种颜色，然后执行 $n=2$ 的算法就可以将 $x\le mid$ 的球放在一起，$x>mid$ 的球放在一起，然后再分别进行操作 $\operatorname{solve}(l,mid)$ 和 $\operatorname{solve}(mid+1,r)$ 就可以继续分治下去解决问题了。

---


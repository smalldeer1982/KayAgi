# 小 H 的序列

## 题目背景

小 H 有一个序列。

## 题目描述

**提交时自动开启 O2 优化。**

小 H 想让你维护一个长为 $n$ 序列 $a_1,a_2,\ldots,a_n$，要求支持

- 修改操作：将所有满足$i\in[l,r]$且$u\le a_i\le v$的$a_i$的值修改为$w$；
- 查询操作：求出$\sum_{i=l}^ra_i^t\bmod k$。

## 说明/提示

输入的所有数字均为正整数。  
设存在数据范围 $\mathrm{randmax}$，满足 $n,m,a_i,w\le\mathrm{randmax},1\le l\le r\le n,1\le u\le v\le \mathrm{randmax},1\le t,k\le10^9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wt8vfeho.png)

保证数据除 $n,m$ 以及测试点 $4,5$ 的 $t$ 外随机，各变量意义如【题目描述】中所述。

由于本题输入量较大及为了省下不必要的评测耗时，请注意输入优化。在此给出以下模板（`c++`语言）：

```cpp
/* ---- read() & rlong() - begin ---- */
#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048576,stdin),p0==p1)?EOF:*p0++)
char buf[1048576],*p0,*p1;
inline int read() {
	int r=0; char c=gc(); while (c<48||c>57) c=gc();
	while (c>47&&c<58) {r=(r<<3)+(r<<1)+(c^48); c=gc();} return r;
}
#undef gc
/* ---- read() & rlong() -- end ----- */
```

调用`read()`函数会从输入中读入一个`int`型整数，注意该模板不能处理负数，调试时请使用文件输入。

## 样例 #1

### 输入

```
10 9
4 3 2 1 9 6 8 8 1 3 
0 4 8 3 10 9
1 1 3 2 973874498
0 10 10 5 9 6
1 7 9 3 738164087
1 1 10 1 694888198
0 2 2 4 7 7
0 1 6 1 3 3
1 1 10 3 868703567
1 4 9 3 545789338
```

### 输出

```
525```

# 题解

## 作者：konjacq (赞：4)

作为出题人过来发个题解.

首先很抱歉比赛时被暴力艹过去了,现在数据已经加强(时限也对应开大),欢迎大家用更奇怪的暴力来艹过.

---

分块.

对于整块的修改,直接用珂朵莉树维护每个值的出现次数;对于散块的修改,遍历从上次作为散块以来的所有修改,记录每个出现过的数最后变成了哪个数即可.注意散块修改细节实现的时候不能用并查集:比如依次进行$1\gets2$,$3\gets1$两个操作,并查集会记录为$1~\text{and}~3\gets2$.所以只能保存每一个数最后被修改成了什么,而不能记录中间过程.清空也请注意复杂度保持在$\sqrt n$以内.

每一块最多从第一次修改到第$m$次,参考珂朵莉树的证明可以发现每次修改时每块内的值的种类数期望是$\log n$的,所以散块总复杂度的期望大致是$m\sqrt n\log n$的.

对于询问,散块暴力整块珂朵莉树.

总复杂度大概是$n\sqrt n\log n$乘巨大的常数.不是很会分析,如果哪位大佬能仔细证一下的话就多谢了.

```cpp
#include <algorithm>
#include <cstdio>
#include <queue>
#include <set>
using namespace std;

typedef long long ll;

/* ---- read() & rlong() - begin ---- */
#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048576,stdin),p0==p1)?EOF:*p0++)
char buf[1048576],*p0,*p1;
inline int read() {
	int r=0; char c=gc(); while (c<48||c>57) c=gc();
	while (c>47&&c<58) {r=(r<<3)+(r<<1)+(c^48); c=gc();} return r;
}
#undef gc
/* ---- read() & rlong() -- end ----- */

const int q=188; int p[35505],tim,val[35505],fat[35505],cnt[35505];
int upl[35505],upr[35505],upu[35505],upv[35505],upw[35505];
struct txb {
	int w; mutable int t;
	inline txb (int _w):w(_w),t(0) {}
	inline txb (int _w,int _t):w(_w),t(_t) {}
	bool operator <(const txb &op) const {return w<op.w;}
};
typedef set<txb>::iterator sit;
struct bxt {
	int l,r; vector<int> g; set<txb> s;

	inline void clear() {
		vector<int> e; int f;
		for (int i=l;i<=r;++i) {
			if (!fat[val[i]]) {
				f=val[i];
				for (auto j:g) if (f>=upu[j]&&f<=upv[j])
					f=upw[j]; fat[val[i]]=f;
			}
			e.push_back(val[i]); val[i]=fat[val[i]];
		}
		for (auto i:e) fat[i]=0; g.clear();
	}

	inline void flatten(int u,int v,int w) {
		int t=0; g.push_back(tim);
		sit spl=s.lower_bound(txb(u)),spr=s.upper_bound(txb(v));
		if (spl==spr) return;
		for (sit i=spl;i!=spr;++i) t+=i->t;
		s.erase(spl,spr); spl=s.lower_bound(txb(w));
		if (spl->w==w) spl->t+=t; else s.insert(txb(w,t));
	}

	inline void update(int a,int b,int u,int v,int w) {
		clear(); s.clear();
		for (int i=l;i<=r;++i) {
			if (i>=a&&i<=b&&val[i]>=u&&val[i]<=v) val[i]=w;
			++cnt[val[i]];
		}
		for (int i=l;i<=r;++i) if (cnt[val[i]]) {
			s.insert(txb(val[i],cnt[val[i]])); cnt[val[i]]=0;
		}
	}
} b[405];

inline int mjly(int u,int v) {return u<v?u:u-v;}

inline int ksm(int u,int v,int w) {
	int r=1; while (v) {
		if (v&1) r=(ll)u*r%w;
		u=(ll)u*u%w; v>>=1;
	}
	return r;
}

inline void update(int l,int r,int u,int v,int w) {
	if (p[l]==p[r]) b[p[l]].update(l,r,u,v,w);
	else {
		b[p[l]].update(l,r,u,v,w); b[p[r]].update(l,r,u,v,w);
		for (int i=p[l]+1;i<p[r];++i) b[i].flatten(u,v,w);
	}
}

inline int powmk(int l,int r,int t,int k) {
	int w=0;
	if (p[l]==p[r]) {
		b[p[l]].clear();
		for (int i=l;i<=r;++i) w=mjly(w+ksm(val[i],t,k),k);
		return w;
	}
	b[p[l]].clear(); b[p[r]].clear();
	for (int i=l;p[i]==p[l];++i) w=mjly(w+ksm(val[i],t,k),k);
	for (int i=r;p[i]==p[r];--i) w=mjly(w+ksm(val[i],t,k),k);
	for (int i=p[l]+1;i<p[r];++i)
		for (auto j:b[i].s) w=(w+(ll)j.t*ksm(j.w,t,k))%k;
	return w;
}

int main() {
	int n,m,l,r,t,k,a=0; n=read(); m=read(); p[0]=p[n+1]=-1;
	for (int i=1;i<=n;i+=q) {
		for (int j=0;j<q&&i+j<=n;++j) {
			p[i+j]=i/q; ++cnt[val[i+j]=read()];
		}
		b[p[i]].l=i; b[p[i]].r=min(i+q-1,n);
		for (int j=b[p[i]].l;j<=b[p[i]].r;++j) if (cnt[val[j]]) {
			b[p[i]].s.insert(txb(val[j],cnt[val[j]])); cnt[val[j]]=0;
		}
	}
	for (;tim<m;++tim) {
		if (read()) {
			l=read(); r=read(); t=read(); k=read();
			a^=powmk(l,r,t,k);
		}
		else {
			upl[tim]=read(); upr[tim]=read();
			upu[tim]=read(); upv[tim]=read(); upw[tim]=read();
			update(upl[tim],upr[tim],upu[tim],upv[tim],upw[tim]);
		}
	}
	printf("%d",a);
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## solution

这个查询操作看起来十分像珂朵莉树的起源题对吧，所以自然想到珂朵莉树解决。

操作一似乎不能直接推平，考虑把每个区间转存到数组里面，再把操作区间删掉，然后把相邻且值相同的区间合并之后再加到珂朵莉树中。

询问操作就是很典的珂树了，把每个树里的的区间一起计算 $v ^ {p}$，再乘上区间长度，累加到答案。

~~（怎么感觉能珂树的题都比较容易实现）~~

## 一些小细节

1.查询操作的累加应该写作 ```cnt = (cnt + (qpow(itl -> v, p, mod) % mod) * len(itl)) % mod;```，不要模错地方，不要把 $cnt$ 放到乘长度的括号里（因为这句盯了好久）。

2.正如大佬所说，就这样子写的话会因为每个查询里面有很多一样的数被重复计算而 T 一个点，所以要给快速幂加上记忆化。

## code

```
#include<bits/stdc++.h>

#define int unsigned long long

namespace IO {
	inline int read() {
		int ret = 0, f = 1;char ch = getchar();
		while (ch < '0' || ch > '9') {
			if (ch == '-') f = -f;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9') {
			ret = (ret << 1) + (ret << 3) + (ch ^ 48);
			ch = getchar();
		}
		return ret * f;
	}
	void write(int x) {
		if (x < 0) putchar('-'), x = -x;
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}

using namespace IO;
using namespace std;

constexpr int maxn = 1e5 + 5;

int n, m;

struct Node {
	int l, r;
	mutable int v;
	
//	Node(int x, int y, int z) {
//		l = x, r = y, v = z;
//	}
	
	bool operator < (const Node & x) const {
		return l < x.l;
	} 
};

set<Node> odt;

auto split(int x) {
	auto it = odt.lower_bound({x, 0, 0});
	if (it != odt.end() && it -> l == x) return it;
	it--;
	int l = it -> l, r = it -> r, v = it -> v;
	if (r < x) return odt.end();	
	odt.erase(it);
	odt.insert({l, x - 1, v});
	return odt.insert({x, r, v}).first;
}

void assign(int l, int r, int v) {
	auto itr = split(r + 1), itl = split(l);
	odt.erase(itl, itr);
	odt.insert({l, r, v});
}


int MOD[maxn], Val[maxn];
int qpow(int a, int p, int mod) {
	int ans = 1LL, A = a;
	
	if (MOD[A] == mod) return Val[A];

	while (p) {
		if (p & 1) ans *= a, ans %= mod;
		a *= a, a %= mod;
		p >>= 1;
	}
	
	Val[A] = ans, MOD[A] = mod;
	
//	cout << ans << '\n'; 
	return ans % mod;
}

void update(int l, int r, int x, int y, int d) {
//	cout << l << ' ' << r << ' ' << x << ' ' << y << ' ' << d << '\n';
	auto itr = split(r + 1), itl = split(l);Node its[maxn];
	int tot = 1, nowx = 0;
	for (auto i = itl;i != itr;i++) {
		int v = i -> v;
		its[++tot] = *i;
		if (v <= y && v >= x) its[tot].v = d;
	}
	
	odt.erase(itl, itr);
	
	for (int i = 1;i <= tot;i++) {
		if (i == 1 || its[i].v != its[i - 1].v) {
			if (nowx) odt.insert({nowx, its[i - 1].r, its[i - 1].v});
			nowx = its[i].l;
		}
	}
	odt.insert({nowx, r, its[tot].v});
}

int len(auto it) {
	return it -> r - it -> l + 1;
}

int query(int l, int r, int p, int mod) {
//	cout << l << ' ' << r << ' ' << p << ' ' << mod << '\n';
	auto itr = split(r + 1), itl = split(l);
//	cout << itl -> l << ' ' << itr -> r;
	int cnt = 0;
	for (;itl != itr;itl++) {
//		cout << itl -> l << ' ' << itl -> r << ' ' << itl -> v << ' ' << len(itl) << '\n';
//		(((cnt += qpow(itl -> v, p, mod)) %= mod) *= len(itl)) %= mod;
		cnt = (cnt + (qpow(itl -> v, p, mod) % mod) * len(itl)) % mod;
//		cout << qpow(itl -> v, p, mod) << "nailong " << cnt << '\n';
	}
//	cout << cnt << '\n';
	return cnt;
}

signed main() {
	n = read(), m = read();
	
	for (int i = 1;i <= n;i++) odt.insert({i, i, read()});
	
	int Ans = 0;
	
	while (m--) {
		int op = read(), l = read(), r = read(), u = read(), v = read(), t;
		if (op == 0) t = read(), update(l, r, u, v, t);
		else Ans ^= query(l, r, u, v);
		
//		for (auto i : odt) cout << i.l << ' ' << i.r << ' ' << i.v << '\n';
	}
	
	write(Ans), putchar(10);
	
	return 0;
}
```

---

## 作者：Eaoci (赞：1)

区间 $k$ 次方和这个东西上次见到还是珂朵莉树模板，自然考虑直接用珂朵莉树维护，可是这个操作不能保证区间全部被推平，但是感性的想一想，$u,v$ 都是随机的那应该每次能推平 $\frac{1}{3}$ 的区间，大概能做，写出来后发现第 10 个点不到 2s 过了，但是第 8 个点过不去。把珂朵莉树形态输出观察发现，区间数量一般不超过 $500$，但是把他们全快速幂的复杂度很大，发现这些区间相同的数很多，于是把一次询问相同值的快速幂记忆化一下，能够通过本题。

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#define sint set<node>::iterator 
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=100010;
int n,m,a[N],b[N];
struct node{
	int l,r;
	mutable int v;
	node(int l=0,int r=0,int v=0):l(l),r(r),v(v){}
	bool operator < (const node &a)const{
		return l<a.l;
	}
}st[N];int tt;
set<node>s;
sint spl(int p){
	sint it=prev(s.upper_bound(node(p)));
	if(it->l==p)return it;
	int L=it->l,R=it->r,V=it->v;
	s.erase(it);
	s.insert(node(L,p-1,V));
	return s.insert(node(p,R,V)).first;
}
void asn(int l,int r,int u,int v,int w){
	sint ir=spl(r+1),il=spl(l);tt=0;
	for(sint it=il;it!=ir;it++){
		st[++tt]=*it;
		if(u<=st[tt].v&&st[tt].v<=v)st[tt].v=w;
	}
	s.erase(il,ir);
	int x=0;
	for(int i=1;i<=tt;i++){
		if(i==1||st[i].v!=st[i-1].v){
			if(x)s.insert(node(x,st[i-1].r,st[i-1].v));
			x=st[i].l;
		}
	}
	s.insert(node(x,r,st[tt].v));
}
int ksm(int p,int k,int mod){
	int q=p;
	if(b[q]==mod)return a[q];
	int x=1;
	while(k){
		if(k&1)x=1ll*x*p%mod;
		p=1ll*p*p%mod;
		k>>=1;
	}
	a[q]=x,b[q]=mod;
	return x;
}
int qry(int l,int r,int x,int y){
	sint ir=spl(r+1),il=spl(l);int cnt=0;
	for(sint it=il;it!=ir;it++){
		cnt=(cnt+1ll*ksm(it->v,x,y)*(it->r-it->l+1))%y;
	}
	return cnt;
}
int main(){
//	freopen("P7134.in","r",stdin);
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		s.insert(node(i,i,read()));
	}
	int ans=0;
	while(m--){
		int op=read(),l=read(),r=read(),u=read(),v=read();
		if(op==0)asn(l,r,u,v,read());
		else ans^=qry(l,r,u,v);
	}
	cout<<ans<<"\n";
//	int res=0,lt=0,rr=0;
//	for(sint it=s.begin();it!=s.end();it++){
//		cout<<it->l<<" "<<it->r<<" "<<it->v<<"\n";
//		res++;rr+=(lt==it->v);lt=it->v;
//	}
//	cout<<res<<" "<<rr<<"\n";
	return 0;
}
```


---

## 作者：yizhiming (赞：0)

偶然看到一年前某个提交的做法，发扬光大一下。

### 题目大意

给你一个长度为 $n$ 序列 $a$，$m$ 次操作，修改操作是将 $[l,r]$ 中值域为 $[u,v]$ 的值修改为 $w$，查询每次给定 $l,r,t,k$，求 $\sum_{i=l}^{r}a^t$，对 $k$ 取模。

除 $n,m$ 和特殊性质外数据随机。

$1\leq n,m,V \leq 10^5,1\leq t,k\leq 10^9$，其中 $V$ 是值域。

### 题目分析

数据随机考虑乱搞，我们用线段树维护当前区间内的最小值和最大值。

每次修改若当前区间内存在节点在修改范围内，则暴力向下递归。

查询若当前区间全为一个值则统计答案，否则向下递归。

数据随机的情况下某个区间很容易被完全覆盖，或者拆分成若干个值域相同的区间，所以直接维护就能过，毕竟时限很大，较优的乱搞不好卡。

### Code

直接这么用线段树维护，每次查询直接用快速幂可能会超时，瞄了眼提交记录，有个老哥是把快速幂优化了一下，不难发现在同一个修改，因为一个区间在线段树上会拆成若干个区间，但是其算的值一样，所以可以记下来当前修改有哪些已经算过了，记忆化一下。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 1e5+5;
int a[N];
int sum[N],id[N],lst;
int ksm(int x,int y,int p){
	if(id[x]==lst){
		return sum[x];
	}
	id[x] = lst;
	int res = 1;
	int xx = x;
	while(y){
		if(y&1){
			res = res*x%p;
		}
		y>>=1;
		x = x*x%p;
	}
	return sum[xx] = res;
}
struct seg{
	struct aa{
		int lc,rc,mx,mi,tag;
	}node[N*2];
	void pushup(int u){
		node[u].mi = min(node[node[u].lc].mi,node[node[u].rc].mi);
		node[u].mx = max(node[node[u].lc].mx,node[node[u].rc].mx);
	}
	void lazy_tag(int u,int x){
		node[u].mx = node[u].mi = x;
		node[u].tag = x;
	}
	void pushdown(int u){
		if(!node[u].tag){
			return;
		}
		lazy_tag(node[u].lc,node[u].tag);
		lazy_tag(node[u].rc,node[u].tag);
		node[u].tag = 0;
	}
	int tot;
	void build(int &u,int l,int r){
		u = ++tot;
		if(l==r){
			node[u].mi = node[u].mx = a[l];
			return;
		} 
		int mid = (l+r)/2;
		build(node[u].lc,l,mid);
		build(node[u].rc,mid+1,r);
		pushup(u);
	} 
	
	void upd(int u,int l,int r,int ll,int rr,int x,int y,int z){
		if(node[u].mx<x||node[u].mi>y){
			return;
		}
		int mid = (l+r)/2;
		pushdown(u);
		if(l==ll&&r==rr){
			if(node[u].mi>=x&&node[u].mx<=y){
				lazy_tag(u,z);
				return;
			}
		}
		if(rr<=mid){
			upd(node[u].lc,l,mid,ll,rr,x,y,z);
		}else if(ll>mid){
			upd(node[u].rc,mid+1,r,ll,rr,x,y,z);
		}else{
			upd(node[u].lc,l,mid,ll,mid,x,y,z);
			upd(node[u].rc,mid+1,r,mid+1,rr,x,y,z);
		}
		pushup(u);
	}
	int ask(int u,int l,int r,int ll,int rr,int t,int k){
		int mid = (l+r)/2;
		if(node[u].mx==node[u].mi){
//			cout<<"U:"<<u<<" "<<node[u].mx<<" "<<l<<" "<<r<<" "<<ll<<" "<<rr<<"\n";
			return (rr-ll+1)%k*ksm(node[u].mx,t,k)%k;
		}
		pushdown(u);
		if(l==ll&&r==rr){
			return (ask(node[u].lc,l,mid,ll,mid,t,k)+ask(node[u].rc,mid+1,r,mid+1,rr,t,k))%k;
		}
		if(rr<=mid){
			return ask(node[u].lc,l,mid,ll,rr,t,k);
		}else if(ll>mid){
			return ask(node[u].rc,mid+1,r,ll,rr,t,k);
		}else{
			return (ask(node[u].lc,l,mid,ll,mid,t,k)+ask(node[u].rc,mid+1,r,mid+1,rr,t,k))%k;
		}
	}
}T; 
int n,m,rt;
void Upd(int l,int r,int u,int v,int w){
	for(int i=l;i<=r;i++){
		if(a[i]>=u&&a[i]<=v){
			a[i] = w;
		}
	}
}
void print(int l,int r,int u,int v){
	cout<<"--------------------\n";
	int res = 0;
	for(int i=l;i<=r;i++){
		cout<<a[i]<<" ";
		res = (res+ksm(a[i],u,v))%v;
	}
	cout<<"\n"<<res<<"\n";
	cout<<"--------------------\n";
}
signed main(){
//	freopen("data.txt","r",stdin);
//	freopen("me.txt","w",stdout);
	n = read();m = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
	}
	T.node[0].mx = -1e18;
	T.node[0].mi =  1e18;
	T.build(rt,1,n);
	int ans = 0;
	for(int i=1;i<=m;i++){
		int op,l,r,u,v,w;
		op = read();l = read();r = read();
		u = read();v = read();
		if(op==0){
			w = read();
			T.upd(rt,1,n,l,r,u,v,w);
//			Upd(l,r,u,v,w);
		}else{
			lst = i;
			int res = T.ask(rt,1,n,l,r,u,v);
			ans^=res;
//			cout<<res<<"\n";
//			print(l,r,u,v);
		}
	}
	cout<<ans<<"\n";
	return 0;
}


```


---


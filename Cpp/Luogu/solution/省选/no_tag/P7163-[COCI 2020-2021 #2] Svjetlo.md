# [COCI 2020/2021 #2] Svjetlo

## 题目描述

有一个呈树状结构的吊灯，由 $n$ 个灯泡组成，这些灯泡之间有 $n-1$ 根电线连接。每个灯泡有一个按钮，能使灯泡的状态发生改变，即把打开的灯泡关闭，关闭的灯泡打开。你需要把所有的灯泡打开。

你可以选择一个序列，序列中两两相邻位置的灯泡相邻，灯泡可以在序列中出现多次。你可以依次改变序列中的灯泡的状态。

你需要计算出最短的符合题目要求的灯泡序列。保证至少有一个灯泡在开始时处于关闭状态。

## 说明/提示

**【样例解释 #1】**

序列可以为 $1, 2, 3, 2$。

**【数据范围】**

对于 $100\%$ 的数据，$2 \leq n \leq 500,000$。

Subtask #1（$19$ pts）：$n \leq 100$。  
Subtask #2（$27$ pts）：每个灯泡最多与两个灯泡相连。  
Subtask #3（$27$ pts）：一开始所有灯泡均处于关闭状态。  
Subtask #4（$27$ pts）：无附加限制。

#### 说明

译自 [Croatian Open Competition in Informatics 2020 ~ 2021 Round 2 E Svjetlo](https://hsin.hr/coci/contest2_tasks.pdf)。

## 样例 #1

### 输入

```
3
010
1 2
2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
5
00000
1 2
2 3
2 4
3 5```

### 输出

```
7```

## 样例 #3

### 输入

```
5
00100
1 2
2 3
2 4
3 5```

### 输出

```
8```

# 题解

## 作者：遮云壑 (赞：32)

# Description
- 一颗树，每个点有一个灯，初始开或关
- 从一个点开始，在树上走来走去，到一个点改变这个点的状态，使最终树上的灯全部打开
- 问最少走过多少个点，保证有解

还不清楚？[出门左转](https://www.luogu.com.cn/problem/P7163)。

# Solution

### 大体思路：树形dp

真的是一道树形dp神题，不论是状态设计还是转移都使我叹服QAQ。

### 1. 状态设计

我们最终相当于在树上找一条路，可以反复走，那么这条路一定会有两个端点吧。

- $f_{x,0/1}$ 表示在 $x$ 为根的子树内，**两个端点都不在**该子树内，且在该子树内走完后 $x$ 是开还是关（0为关，1为开），把该子树内的点全点亮所要的步数。
- $g_{x,0/1}$ 表示在 $x$ 为根的子树内，**两个端点仅有一个在**该子树内，且在该子树内走完后 $x$ 是开还是关（0为关，1为开），把该子树内的点全点亮所要的步数。
- $h_{x,0/1}$ 表示在 $x$ 为根的子树内，**两个端点**都在该子树内（可以到子树外面逛一圈再回来），且在该子树内走完后 $x$ 是开还是关（0为关，1为开），把该子树内的点全点亮所要的步数。

看不懂图解一下，红色是我们走的路

![](https://cdn.luogu.com.cn/upload/image_hosting/9ikfd3lt.png)

然后讲一下状态设计的细节，从图中很容易发现， $f$ 会伸出两个头， $g$ 会伸出一个头， $h$ 会伸出两个头。

然后在 $f$ 伸出的两个头里，我们是算一个在 $f$ 里，为的是后面好转移，不妨算出去的一个，后面会好理解一点。

当然这么讲你不可能懂，所以上图。

![](https://cdn.luogu.com.cn/upload/image_hosting/v033f2w1.png)

我们走的路径是 1 2 3 2 4 2 1 5 1 ，这时给 $f_{1,1}$ 或者是 $f_{1,0}$ 的值就是8，即我们只考虑 2 3 2 4 2 1 5 1。

然后 $g$ 伸出的一个头算在里面， $h$ 伸出的两个头只算一个，为了好理解，你也可以算是出去的那一个（其实你算哪一个效果是一样的）。

### 2.状态转移
树形dp肯定是深搜嘛，我们总的思路是把新的子树向已经算好的子树上合并，或者说把子树一棵一棵向x上接。

先讲一个小技巧，这将贯穿整个转移过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/a7sf4rlg.png)

我们接子树的时候，一去一回，会把两个关着的灯打开，那如果是两个本来就开着的灯怎么办，再走一次不就又开了？这里建议自己画图模拟理解一下。

下文中，$f0,f1,g0,g1,h0,h1$分别代表在 $y$ 子树还没有来的时候 $f_{x}$ $g_{x}$ $h_{x}$ 的答案，即上一次的结果。

建议结合下面的图一起看。

#### i. 对于 $f$ 的转移

$f_{x,1}=\min(f0+f_{y,0}+2,f1+f_{y,1}+4)$

$f_{x,0}=\min(f1+f_{y,0}+2,f0+f_{y,1}+4)$

当求 $f_{x,1}$，走完x前面的子树，如果x和y的灯都关了 ，我们从x到y，再从y回到x，打开两个灯，如上图。如果x和y都开了，走四步，依然如上图，这样就把两棵子树接起来了。

$f_{x,0}$ 同理。

#### ii. 对于 $g$ 的转移

$g_{x,1}=\min(g0+f_{y,0}+2,g1+f_{y,1}+4,f0+g_{y,1}+1,f1+g_{y,0}+3)$

$g_{x,0}=\min(g1+f_{y,0}+2,g0+f_{y,1}+4,f1+g_{y,1}+1,f0+g_{y,0}+3)$

由定义， $g$ 维护的是仅有一个端点在该子树内的情况，这个端点可能在x里，也可能是在y里，所以要么是 $g_x+f_y$ 要么是 $f_x+g_y$ 。至于后面是+1+2+3还是+4，详见上面那张图，都是一个道理。
#### iii. 对于 $h$ 的转移

$h_{x,1}=\min(f0+h_{y,0}+2,f1+h_{y,1}+4,g0+g_{y,0}+2,g1+g_{y,1},h0+f_{y,0}+2,h1+f_{y,1}+4)$

$h_{x,0}=\min(f1+h_{y,0}+2,f0+h_{y,1}+4,g1+g_{y,0}+2,g0+g_{y,1},h1+f_{y,0}+2,h0+f_{y,1}+4)$

 $h$ 比较烦，$h_x$是两个端点都在x为根的子树中，那么这两个端点可能都在x的子树中，可能都在y的子树中，也可能两边各一个。所以$h_x$就是$h_x+f_y$
或$f_x+h_y$或$g_x+g_y$。后面加的那个1234还是看上面那张图。

图解一下

![](https://cdn.luogu.com.cn/upload/image_hosting/c51y8umh.png)

左上是 $f_x$ 的转移，右上是 $g_x$ 的转移，下面是 $h_x$ 的转移（下中图子树里两个端点少了红点，右上好像也忘记画了，应该能懂（逃））。

#### iv.特例，关于 $g_x,h_x$ 端点就在x的转移

以上的分析都是端点在子树之内，如果x就是端点呢？

$g_{x,0}=\min(g_{x,0},f_{x,1}+1)$

$g_{x,1}=\min(g_{x,1},f_{x,0}+1)$

$h_{x,0}=\min(h_{x,0},g_{x,0})$

$h_{x,1}=\min(h_{x,1},g_{x,1})$

什么意思呢， $g$ 是有一个端点， $f$ 是没有端点，我们把进来的那个x算成端点，它就是 $g$ 了， $g$ 要算一个出去的头，$f$正好有，但是 $f$ 是不算进来的那一个点的，即你现在定的端点，所以要加1。

$h$ 同理，就是把 $g$ 出去的点算成端点。（注意，$g$ 可能更新 $f$ ，所以 $g$ 要先算）

### 3.关于初值

设点x初始的开关状态为 $l_x$ ，那么 $f_{x,l_x}=0$，本来就是这样，不需要操作。其他的由于可能要取min，所以设为正无穷。

注意，这里如果不是叶节点设为0不会有影响，因为你在转移 $f_x$ 的时候不会和自己取min ~~（不信你翻上面式子）~~。

### 4.dfs从哪里开始

从开始关着的灯开始。若从开着的灯（1）开始**有可能**会不是最优，因为你从下面走上来，如果接下来的子树本来就都是1，那么你的这么多步，包括上来到1的这一步，都是无效的，而你会用刚才上面那张图走4步的方法让1在变成1，这就不满足题目要的最少步数了。

而你从关着的灯（0）开始，上来到根这一步是肯定必要的，所以一定是最优。

### 5.亿点小优化（bushi）

#### 说是优化，你不优化就是WA

如果当前子树本来初始状态就全是开着的（1），根本没必要遍历这个子树，道理和上面以0为根的有点相似，都开了你再走干嘛，如果你跑这个dp，它会用4步把1变成1 。

这个东西可以先dfs预处理一下。

### 6.得到答案

到这儿基本上就没了，答案就是 $h_{rt,1}$ rt是你之前找到的一个初始状态为0的点。

由于一开始我们定义，h伸出的两个头我们只算一个，所以根节点不会被算两遍。


# Analysis

我们只需要把整棵树遍历两边，整体复杂度 $O(n)$ 。

# Code
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
inline void read(int& x)
{
	x=0;int y=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	x=x*y;
}
const int N=500010;
int n,l[N],chk[N],f[N][2],g[N][2],h[N][2];
struct node{
	int to,nxt;
}e[N<<1];
int cnt,head[N];
inline void add(int u,int v){e[++cnt].nxt=head[u];e[cnt].to=v;head[u]=cnt;} 
char s[N];
void dfs(int x,int fa)//dfs预处理出全是1的子树 
{
	if(l[x])chk[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		dfs(y,x);
		if(!chk[y])chk[x]=0;
	}
}
inline int Min(int A,int B,int C,int D,int E,int F)
{
	return min(A,min(B,min(C,min(D,min(E,F)))));
}
void dfs1(int x,int fa)//树形dp 
{
	f[x][l[x]]=0;//初值 
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa||chk[y])continue;
		dfs1(y,x);
		int f0=f[x][0],f1=f[x][1],g1=g[x][1],g0=g[x][0],h1=h[x][1],h0=h[x][0];
		f[x][1]=min(f0+f[y][0]+2,f1+f[y][1]+4);//正常转移 
		f[x][0]=min(f1+f[y][0]+2,f0+f[y][1]+4);
		g[x][1]=min(min(g0+f[y][0]+2,g1+f[y][1]+4),min(f0+g[y][1]+1,f1+g[y][0]+3));
		g[x][0]=min(min(g1+f[y][0]+2,g0+f[y][1]+4),min(f1+g[y][1]+1,f0+g[y][0]+3));
		h[x][1]=Min(f0+h[y][0]+2,f1+h[y][1]+4,
					g0+g[y][0]+2,g1+g[y][1],
					h0+f[y][0]+2,h1+f[y][1]+4);
		h[x][0]=Min(f1+h[y][0]+2,f0+h[y][1]+4,
					g1+g[y][0]+2,g0+g[y][1],
					h1+f[y][0]+2,h0+f[y][1]+4);
	}
	g[x][0]=min(g[x][0],f[x][1]+1);//以x为根转移 
	g[x][1]=min(g[x][1],f[x][0]+1);
	h[x][0]=min(h[x][0],g[x][0]);
	h[x][1]=min(h[x][1],g[x][1]);
}
signed main(){
	freopen("lihtg.in","r",stdin);//教练让我们练习打乱七八糟的文件名emm 
	freopen("lihtg.out","w",stdout);
	read(n);
	scanf("%s",s+1);
	for(int i=1;i<=n;i++)l[i]=s[i]-'0';
	for(int i=1,x,y;i<=n-1;i++){read(x),read(y);add(x,y),add(y,x);}
	int rt=1;for(int i=1;i<=n;i++)if(l[i]==0)rt=i;//找一个初始为0的点 
	dfs(rt,0);
	memset(f,0x3f,sizeof(f));//初值 
	memset(g,0x3f,sizeof(g));
	memset(h,0x3f,sizeof(h));
	dfs1(rt,0);
	printf("%lld\n",h[rt][1]);
	return 0;//完结撒花 
} 
```
# Conclusion

这题状态设计有三个，在设计dp状态的时候要打开思路，仔细分类，既要不重不漏，也要没有冗余。这样以路径端点是否在子树内的分类也是为我们提供了一种新的思考方向。

想看更多好题？[欢迎光临我的博客qwq](https://www.luogu.com.cn/blog/HZOIHuEnqi/#)

---

## 作者：tzc_wk (赞：11)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7163)

神仙级别的树形 dp。

~~u1s1 这种代码很短但巨难理解的题简直是我的梦魇~~

首先这种题目一看就非常可以 DP 的样子，但直接一维状态的 DP 显然无法表示所有情况。注意到对于这类统计一个路径上权值之和的最值这样的问题，我们可以考虑借鉴 [P4383 林克卡特树](https://www.luogu.com.cn/problem/P4383) 的套路，即在 DP 状态中多记录一维 $j$ 存储当前路径的延伸情况。但是这道题与 林克卡特树 的不同之处在于路径并非是简单路径，即一条路径可以先向上走一段，再向下走一段，接着再向上走一段。因此考虑这样设计 DP 状态：我们考察路径的起点和终点 $x,y$，并设 $dp_{u,j,k}$ 表示目前 $u$ 考虑到 $u$ 的子树，$x,y$ 中恰好有 $j$ 个在 $u$ 的子树中 $(j\in[0,2])$，目前除了 $u$ 的状态为 $k$ 之外，$u$ 子树内其剩余所有点的状态都变为 $1$ 的最短序列长度。

初始三种情况都只有一条单一的 $u\to u$ 的路径，即 $dp_{u,0,a_u\oplus 1}=dp_{u,1,a_u\oplus 1}=dp_{u,2,a_u\oplus 1}=1$。考虑怎样合并两棵子树的路径，即从 $dp_{u,j,k}$ 与 $dp_{v,p,q}$ 推出新的 $dp_{u,j,k}$，其中 $u$ 的 $v$ 的父亲，$p+j\le 2$。这一部分的转移略有亿点点恶心，下面将分条叙述：

- 若 $p=1$，那么 $v$ 子树内的路径应当是一条不能再向下延伸，但可以再继续向上延伸的路径 $x\to v$，同理由于 $p+q\le 2$，$u$ 子树内对应的路径必然有一个端点会向上延伸，即一条 $u\to y$ 的路径，其中 $y$ 可以等于 $u$，即 $j=0$ 的情况，也可以不等于 $u$，即 $j=1$ 的情况，那么：
  - 如果 $k=1$，那么此时直接将两部分拼在一起即可，即 $x\to v\to u\to y$，$dp_{u,j,k}+dp_{v,p,q}\to newdp_{u,j+p,q}$
  - 如果 $k=0$，那么在合并时候还要花费 $2$ 的代价将 $y$ 的状态变为 $1$，即 $x\to v\to u\to v\to u\to y$，此时 $y$ 的状态也会改变，$dp_{u,j,k}+dp_{v,p,q}+2\to newdp_{u,j+p,q\oplus 1}$
- 若 $p=2$，那么 $v$ 子树内的路径本来应是一段 $x\to y$，而 $u$ 子树内的路径应为一段 $u\to u$ 的回路，那么合并两段路径时，由于本来经过 $v$ 的是一段完整的路径 $x\to y$，而现在我们要将 $u\to u$ 的路径嵌进去，因此我们要将 $x\to y$ 的路径拆成 $x\to v$ 和 $v\to y$，然后将两段按 $x\to v\to u\to u\to v\to x$ 的顺序合并，至于额外代价……首先将两个 $v$ 拆开来需要有 $1$ 的代价。其次如果 $k=1$，那么合并时将 $v$ 拆成了两段会将 $v$ 的状态改变一次，变成 $0$，此时我们还需要在 $u,v$ 反复横跳一次之后才能将 $v$ 的状态变为 $1$。而如果 $k=0$，则不需要，因此：
  - 如果 $k=1$，那么 $dp_{u,j,k}+dp_{v,p,q}\to newdp_{u,j+p,q\oplus 1}+3$
  - 如果 $k=0$，那么 $dp_{u,j,k}+dp_{v,p,q}\to newdp_{u,j+p,q}+1$
- 若 $p=0$，那么 $v$ 子树内的路径就是一段回路 $v\to v$，我们合并两条路径时，由于两个 $v$ 都要向上延伸，因此我们要将 $u$ 子树内一段路径拆成两段 $x\to u$ 和 $y\to u$，然后将 $v\to v$ 嵌进去，即 $x\to u\to v\to v\to u\to y$，这样 $u$ 的状态首先会改变一次，产生 $1$ 的基本代价，而：
  - 如果 $k=1$，那不用额外代价，但 $u$ 的状态会改变 $1$，$dp_{u,j,k}+dp_{v,p,q}\to newdp_{u,j+p,q\oplus 1}+1$
  - 如果 $k=0$，那还要在 $(u,v)$ 上反复横跳一次将 $v$ 的状态改为 $1$，同时 $u$ 的状态又改变了一次，这样一来一回贡献抵消了，因此 $dp_{u,j,k}+dp_{v,p,q}\to newdp_{u,j+p,q}+3$

状态转移情况就这么多。注意一些细节的情况，比方说一个子树如果所有点的状态都是 $1$，那我们大可不必进入这个子树，直接 `continue` 即可，还有就是要以一个 $s_i='0'$ 的点为根 DFS。

总复杂度 $\mathcal O(n)$

```cpp
const int MAXN=5e5;
int n,a[MAXN+5],rt=-1;char s[MAXN+5];
int hd[MAXN+5],to[MAXN*2+5],nxt[MAXN*2+5],ec=0;
void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
int sum[MAXN+5],dp[MAXN+5][3][2];
void dfs(int x,int f){
	sum[x]=(!a[x]);
	dp[x][0][a[x]^1]=dp[x][1][a[x]^1]=dp[x][2][a[x]^1]=1;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f) continue;dfs(y,x);
		sum[x]|=sum[y];if(!sum[y]) continue;
		static int tmp[3][2];memset(tmp,63,sizeof(tmp));
		for(int i=0;i<2;i++) for(int j=0;j<2;j++)
			for(int p=0;p<3;p++) for(int q=0;p+q<3;q++){
				if(q==0) chkmin(tmp[p+q][i^j],dp[x][p][i]+dp[y][q][j]+3-j*2);
				if(q==1) chkmin(tmp[p+q][i^j^1],dp[x][p][i]+dp[y][q][j]+2-j*2);
				if(q==2) chkmin(tmp[p+q][i^j],dp[x][p][i]+dp[y][q][j]+3-(j^1)*2);
			}
		memcpy(dp[x],tmp,sizeof(dp[x]));
	}
}
int main(){
	scanf("%d%s",&n,s+1);
	for(int i=1,u,v;i<n;i++) scanf("%d%d",&u,&v),adde(u,v),adde(v,u);
	for(int i=1;i<=n;i++) a[i]=s[i]-'0';
	for(int i=1;i<=n;i++) if(!a[i]) rt=i;
	memset(dp,63,sizeof(dp));
	dfs(rt,0);printf("%d\n",dp[rt][2][1]);
	return 0;
}
```



---

## 作者：Alex_Wei (赞：3)

*[P7163 [COCI2020-2021#2] Svjetlo](https://www.luogu.com.cn/problem/P7163)

挺不错的题目。

考虑在树形 DP 的过程中，对于 $x$ 的子树，我们只关心哪些信息。无论路径怎么绕，我们抓住它 **只有两个端点** 的关键性质，考虑记录有多少个端点在 $x$ 处，且 **即将上传**，意思是要延伸到它的父亲处。

此外，因为 $x$ 与其父亲 $u$ 连接时，可通过形如 $u - x - u$ 的片段改变 $x$ 的状态，所以用封闭在 $x$ 子树内的路径将 $x$ 变成打开未必有在将其和 $u$ 连接时处理更优。但和 $u$ 连接时我们只会改变 $x$ 的状态，而不会改变 $x$ 子树内其它节点的状态，因为后者在和它们的父亲相连时已经被处理掉，若 $u$ 跨过 $x$ 改变它们的状态，则我们多花了 $u$ 的两次操作起到了同样效果，不优。

综合上述分析，我们得到状态设计 $f_{i, j, k}$ 表示在 $i$ 的子树内，有 $j$ 个路径端点需要上传至它的父亲，点 $i$ 当前状态为 $k$ 的最小代价。

答案：我们从一个必然被经过的点 $r$ 开始树形 DP，则 $f_{r, 0, 1}$ 即为所求。$r$ 可以是任意 $s_r = \texttt {0}$ 的点。

初始值：假设 $i$ 必然被经过，那么初始路径为 $i$ 单点。我们可以任意钦定初始有多少个路径端点需要上传，所以 $f_{i, 0 / 1 / 2, [s_i = \texttt {0}]} = 1$。我们需要跳过那些不需要被操作的子树，以保证这样赋初始值的正确性。

转移：考虑合并 $u$ 及其儿子 $x$。$u$ 的状态对转移没有关系，我们只想让 $x$ 的状态变成 $1$，因此直接枚举 $u$ 的状态 $k_u$。若当前 $u$ 有 $j_u$ 个端点上传，$x$ 有 $j_x$ 个端点上传，则合并后它们只有 $j_u + j_x - 2$ 个端点上传，因此 $j_u + j_x \geq 2$。

- 若 $j_u = j_x = 2$，$k_x = 1$，则将 $u$ 的某个端点和 $x$ 的某个端点直接相连，另一个端点上升至 $u$，因此 $f_{u, 2, k_u} + f_{x, 2, 1} + 1\to f_{u, 2, k_u \oplus 1}$。
- 若 $j_u = j_x = 2$，$k_x = 0$，则进行上述处理后，还需要在路径末尾 $x - u$ 以保证 $x$ 的状态为 $1$，因此 $f_{u, 2, k_u} + f_{x, 2, 0} + 3\to f_{u, 2, k_u}$。
- 还有另外十种情况，均可类似上述分析根据实际意义通过手动模拟得出转移式，此处不再赘述。
- 特殊说明一点，当 $j_u = 0$ 且 $j_x = 2$ 时，我们的处理方法是链在 $u$ 处断成两半，即 $v_1 - u - v_2$ 断成 $v_1 - u$ 和 $u - v_2$，然后和 $x$ 上传的链拼起来。注意这增加了一次 $u$ 的出现次数。对于 $j_u = 2$，$j_x = 0$ 同理。

为什么必然有解：一开始钦定 $j_u = 0 / 1 / 2$ 保证了 $u$ 和 $x$ 的连接方式的多样性，从而保证了 $u$ 的状态的多样性。

时间复杂度 $\mathcal{O}(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 5e5 + 5;
void cmin(int &x, int y) {x = x < y ? x : y;}
int n, f[N][3][2], sz[N];
char s[N];
vector<int> e[N];
void dfs(int id, int ff) {
  for(int d : {0, 1, 2}) f[id][d][sz[id]] = 1;
  for(int it : e[id]) {
    if(it == ff) continue;
    dfs(it, id);
    if(!sz[it]) continue;
    sz[id] += sz[it];
    static int g[3][2];
    memset(g, 0x3f, 24);
    for(int j : {0, 1}) {
      // 2 + 2
      cmin(g[2][j ^ 1], f[id][2][j] + f[it][2][1] + 1);
      cmin(g[2][j], f[id][2][j] + f[it][2][0] + 3);
      // 2 + 1
      cmin(g[1][j], f[id][2][j] + f[it][1][1]);
      cmin(g[1][j ^ 1], f[id][2][j] + f[it][1][0] + 2);
      // 2 + 0
      cmin(g[0][j ^ 1], f[id][2][j] + f[it][0][1] + 3);
      cmin(g[0][j], f[id][2][j] + f[it][0][0] + 1);
      // 1 + 2
      cmin(g[1][j ^ 1], f[id][1][j] + f[it][2][1] + 1);
      cmin(g[1][j], f[id][1][j] + f[it][2][0] + 3);
      // 1 + 1
      cmin(g[0][j], f[id][1][j] + f[it][1][1]);
      cmin(g[0][j ^ 1], f[id][1][j] + f[it][1][0] + 2);
      // 0 + 2
      cmin(g[0][j ^ 1], f[id][0][j] + f[it][2][1] + 1);
      cmin(g[0][j], f[id][0][j] + f[it][2][0] + 3);
    }
    memcpy(f[id], g, 24);
  }
  if(!ff) cout << f[id][0][1] << "\n", exit(0);
}
int main() {
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> s + 1;
  for(int i = 1, x, y; i < n; i++) cin >> x >> y, e[x].push_back(y), e[y].push_back(x);
  for(int i = 1; i <= n; i++) sz[i] = s[i] == '0';
  memset(f, 0x3f, sizeof(f));
  for(int i = 1; i <= n; i++) if(sz[i]) dfs(i, 0);
  return cerr << "Time: " << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n", 0;
}
```

---

## 作者：APJifengc (赞：2)

> # 题目大意
> 给定一棵树，每个点有点亮与未点亮两种状态。现在从选中的一个点开始，每次走到相邻的节点，每经过一个节点都会使节点的状态翻转。   
> 求将所有点都点亮的最短路径长度。  
> $n \le 5\times 10^5$

这里提供一种 **换根 DP** 的做法。

# 思路

首先可以想到 **树形 DP**。从任意一个起点开始感觉不太好 DP，那么我们就先钦定以根节点为起始点，求出这样的最短路径长度。

我们考虑一个路径大概长什么样子：

![image1](https://cdn.luogu.com.cn/upload/image_hosting/zmppfnme.png)

发现会有两种情况：一种是从一个子树的根节点出发，将子树中所有节点点亮后回到根节点；另一种是将所有子树点亮后，往一个子树内走。

我们可以根据这样的过程定义状态：

（注：以下根节点指当前节点 $u$）

设 $f_{u,0}$ 为将一个子树内的所有节点全部点亮（不考虑根节点），所需要的最短路径长度。

如果一个根节点是亮的那就不用管了，但是如果走完所有子树后根节点没亮呢？

![image2](https://cdn.luogu.com.cn/upload/image_hosting/r4glzjis.png)

我们可以考虑在它的父亲节点时，只需要走完所有子树后，再往这个没亮的节点走一次，走回来就可以使这个儿子节点点亮。

具体的，对于一个转移，我们先跳到子树里，从子树里走，然后跳一步跳回根节点，最后看如果那个节点没有亮，就往下走一步再走回来把它点亮。

同时我们发现，这样做完操作之后，根节点的颜色一定是固定的（因为只有一种决策方式），那么我们可以记录下来这个颜色，设它为 $f_{u,1}$。

那么大致转移就是：

$$f_{u,0}=1+\sum_{v\in son_u}f_{v,0} + 2 \times [f_{v,1}=1]$$

$$f_{u,1}=1 \oplus s_u \oplus \bigoplus_{v\in son_u} f_{v,1}$$

（$s_u$ 为 $u$ 节点的初始状态，两个转移式子都有 $1$ 的原因是要考虑刚进入根节点时造成的那一次贡献）

第二种情况就是我们从一个根节点走完其它子树后直接往下走，那么我们肯定是先把一些子树全部走完，然后选择一颗子树往下递归下去。那么发现根据选择的子树不同，走完后根节点的颜色也是不同的。所以我们设 $f_{u,2}$ 为根节点不亮的情况，$f_{u,3}$ 为根节点亮的情况。

若根节点未点亮，和上面的处理方法是相同的，考虑在它的父节点处走下去再走上来将它点亮。所以若转移到 $f_{u,2}$，那么根节点的颜色会翻转。

所以转移大概是：

$$f_{u,2+[f_{u,1} \oplus f_{v,1} \oplus 1]} = \min_{v\in son_u} \{f_{u,0} - (f_{v,0} + 2 \times [f_{v,1}=1]) + f_{v,2} + 2\}$$

$$f_{u,2+[f_{u,1} \oplus f_{v,1}]} = \min_{v\in son_u} \{f_{u,0} - (f_{v,0} + 2 \times [f_{v,1}=1]) + f_{v,3}\}$$

（即将 $v$ 回到根节点的贡献去掉之后改为直接向下走的贡献）

注意我们也可指直接走完整颗子树然后回到根节点，不再往下走，所以我们要设初值：

$$f_{u, 2 + f_{u, 1}}=f_{u, 0}$$

需要注意的是，如果整个子树都是点亮状态，我们分两种情况：根节点也点亮了和根节点未点亮。直接特殊处理出来这两种情况的 DP 值就可以了。

单次 DP 代码：

```cpp
void update(int u, int pre) {
    f[u][0] = -1;
    int sum = 0, col = s[u];
    for (int v : e[u]) if (v != pre) { 
        if (f[v][0] != -1) f[u][0] = 1;
        sum += f[v][0] + 2 * (f[v][1] == 0) + 1;
        col ^= f[v][1] ^ (f[v][0] == -1);
    }
    if (col == 1 && f[u][0] == -1) {
        f[u][0] = -1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 0;
    } else if (col == 0 && f[u][0] == -1) {
        f[u][0] = 1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 1;
    } else {
        col ^= 1;
        f[u][0] = 1 + sum;
        f[u][1] = col;
        f[u][2] = f[u][3] = 0x3f3f3f3f;
        f[u][2 + col] = min(f[u][2 + col], f[u][0]);
        for (int v : e[u]) if (v != pre) {
            f[u][2 + (col ^ f[v][1] ^ 1)] = min(f[u][2 + (col ^ f[v][1] ^ 1)], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][2] + 2);
            f[u][2 + (col ^ f[v][1])] = min(f[u][2 + (col ^ f[v][1])], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][3]);
        }
    }
}
```

接下来考虑换根。

$f_{u,0}$ 和 $f_{u,1}$ 是容易的，因为他们都是和的形式和异或和的形式，不过需要注意都点亮的情况，因为换根后原来都点亮的子树可能不再都点亮。

所以我们可以维护三个数组 $psum_u,pcol_u,pcnt_u$，分别表示 $u$ 节点**在没有全部点亮的情况下得到的 $f_{u,0},f_{u,1}$ 值和有多少个子树没有被点亮**。

这样我们在转移的时候就可以轻松处理子树全部点亮的情况了。具体的，当 $pcnt_u=0$ 时，就说明子树全部被点亮了。

对于 $f_{u,2},f_{u,3}$，它们的转移是 $O(size_u)$ 的，直接换根显然可以被卡到 $O(n^2)$（构造菊花图）。但是观察 DP 的形式：$f_{u,0}$ 是只跟当前节点的 DP 值有关系的，而剩下的加起来只跟 $v$ 有关系。所以我们发现，对于每一个 $u$，**只有 $2$ 个 $v$ 是可能造成贡献的**。因为如果最小值的那个子树在换根的时候删除了，那么就肯定会轮到第二小的子树造成贡献，更大的值是肯定不会造成贡献的。同时考虑当前节点的根节点可能已经被更改过，所以要把当前节点的父亲节点加进去。

于是我们跑第一遍 DP 的时候可以处理出每个节点可能的 $5$ 个决策点（两个 DP 式子各 $2$ 个，再加上一个父亲节点共 $5$ 个），然后再换根的时候只遍历这几个子树就可以了。

于是我们就做到了复杂度 $O(n)$ 解决该问题。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500005;
vector<int> e[MAXN], e2[MAXN]; // e2: 可能的决策点
int n;
char s[MAXN];
int f[MAXN][4];
int psum[MAXN], pcol[MAXN], pcnt[MAXN];
void remove(int u, int pre) { // 从当前子树中删除 pre 节点
    int &sum = psum[u], &col = pcol[u];
    if (f[pre][0] != -1) pcnt[u]--;
    sum -= f[pre][0] + 2 * (f[pre][1] == 0) + 1;
    col ^= f[pre][1] ^ (f[pre][0] == -1);
    if (pcnt[u] == 0) {
        f[u][0] = -1;
    } else {
        f[u][0] = 1;
    }
    if (col == 1 && f[u][0] == -1) {
        f[u][0] = -1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 0;
    } else if (col == 0 && f[u][0] == -1) {
        f[u][0] = 1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 1;
    } else {
        f[u][0] = 1 + sum;
        f[u][1] = (col ^ 1);
        f[u][2] = f[u][3] = 0x3f3f3f3f;
        f[u][2 + (col ^ 1)] = min(f[u][2 + (col ^ 1)], f[u][0]);
        for (int v : e2[u]) if (v != pre) { // 注意排除要删掉的节点
            f[u][2 + ((col ^ 1) ^ f[v][1] ^ 1)] = min(f[u][2 + ((col ^ 1) ^ f[v][1] ^ 1)], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][2] + 2);
            f[u][2 + ((col ^ 1) ^ f[v][1])] = min(f[u][2 + ((col ^ 1) ^ f[v][1])], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][3]);
        }
    }
}
void add(int u, int pre) { // 从当前子树添加 pre 节点
    int &sum = psum[u], &col = pcol[u];
    if (f[pre][0] != -1) pcnt[u]++;
    sum += f[pre][0] + 2 * (f[pre][1] == 0) + 1;
    col ^= f[pre][1] ^ (f[pre][0] == -1);
    if (pcnt[u] == 0) {
        f[u][0] = -1;
    } else {
        f[u][0] = 1;
    }
    if (col == 1 && f[u][0] == -1) {
        f[u][0] = -1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 0;
    } else if (col == 0 && f[u][0] == -1) {
        f[u][0] = 1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 1;
    } else {
        f[u][0] = 1 + sum;
        f[u][1] = (col ^ 1);
        f[u][2] = f[u][3] = 0x3f3f3f3f;
        f[u][2 + (col ^ 1)] = min(f[u][2 + (col ^ 1)], f[u][0]);
        for (int v : e2[u]) {
            f[u][2 + ((col ^ 1) ^ f[v][1] ^ 1)] = min(f[u][2 + ((col ^ 1) ^ f[v][1] ^ 1)], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][2] + 2);
            f[u][2 + ((col ^ 1) ^ f[v][1])] = min(f[u][2 + ((col ^ 1) ^ f[v][1])], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][3]);
        }
    }
}
void dfs(int u, int pre) {
    for (int v : e[u]) if (v != pre) {
        dfs(v, u);
    }
    f[u][0] = -1;
    int sum = 0, col = s[u];
    for (int v : e[u]) if (v != pre) { 
        if (f[v][0] != -1) f[u][0] = 1;
        sum += f[v][0] + 2 * (f[v][1] == 0) + 1;
        col ^= f[v][1] ^ (f[v][0] == -1);
    }
    if (col == 1 && f[u][0] == -1) {
        f[u][0] = -1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 0;
        e2[u].push_back(pre);
    } else if (col == 0 && f[u][0] == -1) {
        f[u][0] = 1;
        f[u][1] = 1;
        f[u][2] = 0x3f3f3f3f;
        f[u][3] = 1;
        e2[u].push_back(pre);
    } else {
        col ^= 1;
        f[u][0] = 1 + sum;
        f[u][1] = col;
        f[u][2] = f[u][3] = 0x3f3f3f3f;
        f[u][2 + col] = min(f[u][2 + col], f[u][0]);
        queue<int> q[2];
        for (int v : e[u]) if (v != pre) {
            if (f[u][2 + (col ^ f[v][1] ^ 1)] >= 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][2] + 2) {
                    q[(col ^ f[v][1] ^ 1)].push(v);
                    if (q[(col ^ f[v][1] ^ 1)].size() > 2) q[(col ^ f[v][1] ^ 1)].pop();
                }
            if (f[u][2 + (col ^ f[v][1])] >=
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][3]) {
                    q[(col ^ f[v][1])].push(v);
                    if (q[(col ^ f[v][1])].size() > 2) q[(col ^ f[v][1])].pop();
                }
            f[u][2 + (col ^ f[v][1] ^ 1)] = min(f[u][2 + (col ^ f[v][1] ^ 1)], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][2] + 2);
            f[u][2 + (col ^ f[v][1])] = min(f[u][2 + (col ^ f[v][1])], 
                f[u][0] - (f[v][0] + 2 * (f[v][1] == 0) + 1) + f[v][3]);
        }
        while (!q[0].empty()) e2[u].push_back(q[0].front()), q[0].pop();
        while (!q[1].empty()) e2[u].push_back(q[1].front()), q[1].pop();
        if (pre) e2[u].push_back(pre);
    }
    pcol[u] = s[u];
    for (int v : e[u]) if (v != pre) { 
        if (f[v][0] != -1) pcnt[u]++;
        psum[u] += f[v][0] + 2 * (f[v][1] == 0) + 1;
        pcol[u] ^= f[v][1] ^ (f[v][0] == -1);
    }
}
void changeRoot(int u, int v) {
    remove(u, v);
    add(v, u);
}
int ans = INT_MAX;
void dfs2(int u, int pre) { // 换根 DP
    ans = min(ans, f[u][3]);
    for (int v : e[u]) if (v != pre) {
        changeRoot(u, v);
        dfs2(v, u);
        changeRoot(v, u);
    }
}
int main() {
    scanf("%d%s", &n, s + 1);
    for (int i = 1; i <= n; i++) s[i] ^= '0';
    for (int i = 1; i < n; i++) {
        int x, y; scanf("%d%d", &x, &y);
        e[x].push_back(y);
        e[y].push_back(x);
    }
    memset(f, 0x3f, sizeof f);
    dfs(1, 0);
    dfs2(1, 0);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：听取MLE声一片 (赞：2)

神仙树形 dp 题。注：本题解中“变”指灯的状态改变一次。不难看出开头结尾互换是没有影响的，然后我们尝试构造一下路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/i6gb0ejt.png)

端点标为红色，路径可以划分成两部分：端点之间的链和链上点的子树。我们抽出来这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/j8fep5gt.png)

我们首先观察链上的点。我们是要从一个端点走到另外一个端点，所以是有方向的。我们规定当前节点为红色，下一个节点为蓝色。我们可以直接从红走到蓝，红不变，蓝变；也可以红到蓝，蓝到红，红到蓝，红变，蓝不变。显然更多步数不优。

总结：链上的点，花费 $1$ 次使得红不变，蓝变；或花费 $3$ 次使得红变，蓝不变。

然后我们看链上点的子树。我们需要从红色点出发然后回到红色点。还是规定当前点为红色，下一个节点为蓝色。我们可以从红走到蓝，再从蓝走到红，红变，蓝不变；也可以从红到蓝，蓝到红，红到蓝，蓝到红，红不变，蓝不变。显然更多步数不优。

总结：链上点的子树，花费 $2$ 次使得红变，蓝变；或花费 $4$ 次使得红不变，蓝不变。

然后我们设定状态 $f_{i,j,k}$。第一维是枚举到的点；第二维的取值为 $0,1,2$，表示以这个点的子树内的端点个数；第三维的取值为 $0,1$ 表示灯的状态（分别为关闭和打开）。

最后我们来说一下状态转移方程。显然是要枚举开关灯状态，遍历到编号为 $u$ 的点则 $f_{u,0,b_u}=0,f_{u,1,b_u \mathbin{\mathrm{xor}} 1}=1$，其中 $b$ 数组为记录灯的初始状态数组。

我们规定 $u$ 是当前节点，$v$ 是 $u$ 的一个儿子节点。

然后我们根据上面的思想来写出状态转移方程（因为过于复杂就用代码表示了）：

$\mathbf{loop.\ } j \leftarrow 0 \mathbf{\ to\ } 2$

$\quad\mathbf{loop.\ } k \leftarrow 0 \mathbf{\ to\ } 1$

$\qquad g_{j,k} \leftarrow f_{u,j,k}$

$\mathbf{loop.\ } j \leftarrow 0 \mathbf{\ to\ } 1$

$\quad f_{u,0,j} \leftarrow \min\{f_{v,0,0} + g_{0,j\oplus1} + 2, f_{v,0,1} + g_{0,j} + 4\}$

$\quad f_{u,1,j} \leftarrow \min\{f_{v,0,0} + g_{1,j\oplus1} + 2, f_{v,0,1} + g_{1,j} + 4, f_{v,1,1} + g_{0,j\oplus1} + 1, f_{v,1,0} + g_{0,j} + 3\}$

$\quad f_{u,2,j} \leftarrow \min\{f_{v,0,0} + g_{2,j\oplus1} + 2, f_{v,0,1} + g_{2,j} + 4, f_{v,1,1} + g_{1,j}, f_{v,1,0} + g_{1,j\oplus1} + 2, f_{v,2,0} + g_{0,j\oplus1} + 2, f_{v,2,1} + g_{0,j} + 4\}$

然后对于 $u$ 节点可以原本不是端点取上一个端点，也可以原本是一个端点再取一遍作为端点，代码：

```
for(int i=0;i<3;i++)
	for(int j=0;j<2;j++)
		g[i][j]=f[u][i][j];
for(int i=0;i<2;i++){
	f[u][1][i]=min(f[u][1][i],g[0][i^1]+1);
	f[u][2][i]=min(f[u][2][i],g[1][i]);
}
```
最后这种策略的 dp 只适用于根节点初始为关闭的状态，原因是你一开始需要改变根节点，如果一开始是开的会额外浪费次数。所以我们需要找到一个初始为关闭的点作为根即可。

代码：

```
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
#include<set>
#include<ctime>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=5e5+10;
const int inf=1e18;
int n,b[N],f[N][3][2],g[3][2],siz[N],root,ans;
char s[N];
vector<int>a[N];
void dfs1(int u,int fa){
	if(!b[u])
		siz[u]=1;
	for(int i=0;i<a[u].size();i++){
		int v=a[u][i];
		if(v==fa)
			continue;
		dfs1(v,u);
		siz[u]+=siz[v]; 
	}
}
void dfs2(int u,int fa){
	f[u][0][b[u]]=0,f[u][1][b[u]^1]=1;
	for(int i=0;i<a[u].size();i++){
		int v=a[u][i];
		if(v==fa||siz[v]==0)
			continue;
		dfs2(v,u);
		for(int j=0;j<3;j++)
			for(int k=0;k<2;k++)
				g[j][k]=f[u][j][k];
		for(int j=0;j<2;j++){
			f[u][0][j]=min(f[v][0][0]+g[0][j^1]+2,f[v][0][1]+g[0][j]+4);
			f[u][1][j]=min(min(f[v][0][0]+g[1][j^1]+2,f[v][0][1]+g[1][j]+4),min(f[v][1][1]+g[0][j^1]+1,f[v][1][0]+g[0][j]+3));
			f[u][2][j]=min(min(f[v][0][0]+g[2][j^1]+2,f[v][0][1]+g[2][j]+4),min(min(f[v][1][1]+g[1][j],f[v][1][0]+g[1][j^1]+2),min(f[v][2][0]+g[0][j^1]+2,f[v][2][1]+g[0][j]+4)));
		}
	}
	for(int i=0;i<3;i++)
		for(int j=0;j<2;j++)
			g[i][j]=f[u][i][j];
	for(int i=0;i<2;i++){
		f[u][1][i]=min(f[u][1][i],g[0][i^1]+1);
		f[u][2][i]=min(f[u][2][i],g[1][i]);
	}
}
signed main()
{
	//freopen("light.in","r",stdin);
	//freopen("light.out","w",stdout);
	n=read();
	scanf("%s",s+1);
	for(int i=1;i<=n;i++)	
		b[i]=s[i]-'0';
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		a[u].push_back(v);
		a[v].push_back(u);
	}
	for(int i=1;i<=n;i++)
		if(b[i]==0){
			root=i;
			break;
		}
	dfs1(root,-1);
	for(int i=0;i<=n;i++)
		f[i][0][0]=f[i][0][1]=f[i][1][0]=f[i][1][1]=f[i][2][0]=f[i][2][1]=inf;
	dfs2(root,-1);
	ans=f[root][2][1];	
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：wjyppm1403 (赞：1)

[可能更好的阅读体验](https://worldcpu.github.io/posts/e46562f0/#p7163-coci-20202021-2-svjetlo)

这是困难的，但也是好的。

原命题叽里咕噜可以转化为树上路径问题。有起点和终点不固定，每经过一个点就可以置反当前状态，问最短路径使得所有状态为 $1$。

显然考虑 DP，首先考虑枚举法确定我们路径的起始点，令我们枚举的点为 $rt$。那么将这个枚举的点 $rt$ 作为有根树提起来。然后考虑如何在这个有根树上进行 DP。考虑一条路径会有如下两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/hptvjq65.png)

一个直下，一个绕一圈在回来（~~南下和北上~~）。考虑 DP 状态中我们需要融入这个状态，设 $f(u,0/1,0/1)$ 表示 $u$ 子树内都为 $1$，是否返回 $u$ 点，当前最终状态是 $0/1$ 的最短路径答案。

转移不太好直接转移，考虑合并子树答案，以下令 $tmp$ 为转移临时存储更新后答案的数组，$\oplus$ 运算代表异或，转移考虑枚举最终状态 $d$，以下转移按顺序进行：

$$tmp(0,d)\leftarrow
\begin{cases}
2+\min\{f(u,0,d\oplus 1)+f(v,1,0),f(u,0,d)+f(v,1,1)+2\} \\ \\
1+\min\{f(u,1,d)+f(v,0,0),f(u,1,d\oplus 1)+f(v,0,1)+2\}
\end{cases}
$$
$$tmp(1,d)\leftarrow 2+\min\{ f(u,1,d\oplus1)+f(v,1,0),f(u,1,d)+f(v,1,1)+2  \}$$
$$f(u,0/1,d)\leftarrow tmp(0/1,d)$$
以下解释转移方程。根据上面的图，我们有两种路径模式：直下和绕圈返回。贡献我们可以分摊到边的贡献，对于 $tmp(0,d)$ 的第一部分就是在绕圈进行分讨：

- 常数 $2$ 代表回路一条边经过两次，固定贡献。
- $f(u,0,d\oplus 1)+f(v,1,0)$：我们把 $v$ 子树当成一个完整的回路，然后我们将两端连接，由于绕了一圈 $d$ 一开始就是被置反过的，所以为 $d\oplus 1$。
- $f(u,0,d)+f(v,1,1)+2$：依旧是回路，但是 $v$ 这里最终状态变了，因为经过路径会使得 $v$ 被取反两次，为了使得贡献能够匹配上，我们要把内部在做一次回路改奇偶的操作，这个返回使得 $v$ 子树内边经过 $2$ 次。

第二部分是直下：

- 常数 $1$ 代表边经过一次。
- $f(u,1,d)+f(v,0,0)$ 代表 $u$ 需要返回而 $v$ 必须要，我们两部分用路径穿起来即可。
- $f(u,1,d\oplus 1)+f(v,0,1)+2$：同样是穿越，但是我们也要和上面一样来通过做一次改变奇偶性的操作来使得贡献能够匹配上。

对于 $tmp(1,d)$ 的同理，这里不再细说，但是只用分讨回路的情况即可，因为要回到 $u$ 肯定就没有直下啦。

对于合并当子树已经保证全为 $1$ 的时候可以不用合并，对答案无影响。直接做，时间复杂度 $O(n^2)$。但是注意到转移只有和式，可以通过换根 DP 来进行代替枚举法的决策。具体的，我们需要维护一个 $pre,suf$ 表示前缀儿子 $f$ 合并后的数组和后缀 $f$ 合并后的数组，转移利用 $pre$ 和 $suf$ 即可，具体见代码，时间复杂度 $O(n)$ 但有巨大常数难泵，于是荣获本题最差解，比倒数第二还慢 $300$ 毫秒。

总结：枚举法可以帮助我们确定决策，虽然我们可以在后面优化掉，但这是一个优秀的决策确定方式。同时对于树上路径 DP 问题（不要和点分治搞混了）可以考虑枚举起始点，然后通过换根 DP 确定。

注意我们 $pre$ 和 $suf$ 是开在函数内部的，不要瞎开大数组，可以用指针分配内存或 `vector` 方便一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int MN=5e5+15,INF=0x3f3f3f3f;
int n,ans=INF,a[MN];
vector<int> adj[MN];

namespace Tree{
    int f[MN][2][2];
    bool vis[MN];

    void init(int u){
        vis[u]=a[u];
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                f[u][i][j]=(j!=a[u])?INF:0;
            }
        }
    }

    void merge(int u,int v){
        vis[u]&=vis[v];
        if(vis[v]) return;
        int tmp[2][2]{};
        for(int i=0;i<2;i++){
            tmp[0][i]=min(
                min(f[u][0][i^1]+f[v][1][0],f[u][0][i]+f[v][1][1]+2)+2,
                min(f[u][1][i]+f[v][0][0],f[u][1][i^1]+f[v][0][1]+2)+1
            );
            tmp[1][i]=min(f[u][1][i^1]+f[v][1][0],f[u][1][i]+f[v][1][1]+2)+2;
        }
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                f[u][i][j]=tmp[i][j];
            }
        }
    }

    void dfs1(int u,int pre){
        init(u);
        for(auto v:adj[u]){
            if(v==pre) continue;
            dfs1(v,u);
            merge(u,v);
        }
    }

    void dfs2(int u,int pree){
        int len=adj[u].size();
        vector<array<array<int,2>,2>> pre(len+1),suf(len+1);
        vector<bool> prev(len+1),sufv(len+1);
        init(u);
        for(int i=0;i<len;i++){
            for(int x=0;x<2;x++) for(int y=0;y<2;y++) pre[i][x][y]=f[u][x][y];
            prev[i]=vis[u];
            merge(u,adj[u][i]);
        }
        init(u);
        for(int i=len-1;i>=0;i--){
            for(int x=0;x<2;x++) for(int y=0;y<2;y++) suf[i][x][y]=f[u][x][y];
            sufv[i]=vis[u];
            merge(u,adj[u][i]);
        }
        ans=min(ans,f[u][0][1]);
        for(int i=0;i<len;i++){
            int v=adj[u][i];
            if(v==pree) continue;
            for(int x=0;x<2;x++) for(int y=0;y<2;y++) f[u][x][y]=INF;
            for(int i1=0;i1<2;i1++){
                for(int j1=0;j1<2;j1++){
                    for(int i2=i1^1;i2<2;i2++){
                        for(int j2=0;j2<2;j2++){
                            f[u][i1&i2][j1^j2^a[u]]=min(f[u][i1&i2][j1^j2^a[u]],pre[i][i1][j1]+suf[i][i2][j2]);
                        }
                    }
                }
            }
            vis[u]=prev[i]&sufv[i];
            dfs2(v,u);
        }
    }

}using namespace Tree;

signed main(){
    string st;
    cin>>n>>st;
    st=" "+st;
    for(int i=1;i<=n;i++) a[i]=(st[i]=='1');
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs1(1,0);
    dfs2(1,0);
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：novax (赞：1)

[题面](https://www.luogu.com.cn/problem/P7163)。

#### 思路

很强的树形dp。

要求选择一个最短行走序列打开所有灯。

既然是序列，那就得有起点和终点。

考虑对序列的起点和终点分类讨论。

设dp中的当前点为 $p$，那么可以设三个状态：$f_{p},g_{p},h_{p}$。分别对应所选路径的起点终点都在 $p$ 的子树之外/选路径的端点有一个在 $p$ 的子树之外另一个在子树内/所选路径的起点终点都在 $p$ 的子树内，打开 $p$ 子树内所有灯的最小步数。

每个状态还要有额外的 $0/1$ 一维，记录这个状态下当前点上灯的状态。

为了方便转移，$f,h$ 状态本都有一进一出两步，但我们的状态中只记录一步，另一步在转移时再加上。

dp之前先记录一下哪些子树内的灯初始时已经全被打开了，这样的子树不需要被走过。

然后说状态转移。将某个子树的状态与当前信息合并，更新当前状态。

设当前要将状态合并到当前点的子树为``to``。

$$\begin{cases}
f[p][0]=\min({f[p][1]+f[to][0]+2,f[p][0]+f[to][1]+4})\\
f[p][1]=\min({f[p][0]+f[to][0]+2,f[p][1]+f[to][1]+4})\\
\end{cases}$$ 

↑↑↑ 先说 $f$ 的转移。

$+2$ 的转移：当前点走下去，再走回来，此时在 $p$ 与 $to$ 间的边上走了两步，这两步会使 $p$ 和 $to$ 点上的灯状态反转，为使子树内的灯全部被打开，需要此转移的 $to$ 点状态灯处于关闭状态，而当前点状态反转。

$+4$ 的转移：走一次 $+2$ 的转移后，再走两步：$p \rightarrow to \rightarrow p$。这样起到了在 $+2$ 转移基础上使 $p$ 和 $to$ 的灯泡状态都反转的效果。

$$\begin{cases}
g[p][0]=\min({g[p][1]+f[to][0]+2,g[p][0]+f[to][1]+4,f[p][1]+g[to][1]+1,f[p][0]+g[to][0]+3})\\
g[p][1]=\min({g[p][0]+f[to][0]+2,g[p][1]+f[to][1]+4,f[p][0]+g[to][1]+1,f[p][1]+g[to][0]+3})\\
\end{cases}$$ 

↑↑↑ 然后是 $g$ 的转移。

因为 $g$ 有一个端点在子树内而另一个端点在子树外，所以分端点在原有子树与端点在 $to$ 子树内分开讨论。状态也即 $f$ 与 $g$ 的合并。

$+2$ 的转移：原理与 $f$ 的对应转移类似。将子树 $to$ 的 $f$ 状态接在当前点的 $g$ 状态上。

$+1$ 的转移：将子树 $to$ 的 $g$ 状态接在当前点的 $f$ 状态上。此时该路径的起点在子树 $to$ 内，只有从 $to$ 点向上走到 $p$ 的额外一步，所以是加一。因为此转移只走过 $p$ 点一次而没有走过 $to$，所以 $to$ 的状态需要为 $1$ 而 $p$ 的状态正常取反。

$+4,+3$ 的转移：与 $f$ 的 $+4$ 的转移类似，在 $+2,+1$ 的基础上走到 $to$ 点再走回来一次。

$$\begin{cases}
h[p][0]=\min({h[p][1]+f[to][0]+2,h[p][0]+f[to][1]+4,f[p][1]+h[to][0]+2,f[p][0]+h[to][1]+4,g[p][0]+g[to][1],g[p][1]+g[to][0]+2})\\
h[p][1]=\min({h[p][0]+f[to][0]+2,h[p][1]+f[to][1]+4,f[p][0]+h[to][0]+2,f[p][1]+h[to][1]+4,g[p][1]+g[to][1],g[p][0]+g[to][0]+2})\\
\end{cases}$$ 

↑↑↑ 最麻烦的 $h$ 的转移。

$h$ 的两个端点都在子树内。所以有三种情况到达合并后的结果：原有子树内有两个端点而 $to$ 内没有；原树与 $to$ 子树内各有一个；两个端点都在 $to$ 子树内。

第一个 $+2$ 转移：对应上述第二个转移。原理与 $f$ 的 $+2$ 转移类似。将子树 $to$ 的 $f$ 状态接在当前点的 $h$ 状态上。

第二个 $+2$ 转移：对应上述第三个转移。将子树 $to$ 的 $f$ 状态接在当前点的 $h$ 状态上。同样是需要多走两步。

$+0$ 的转移：对应上述第二个转移。合并当前点的 $g$ 与 $to$ 的 $g$ 状态。因为 $g$ 状态本来就记录了离开当前点的一步，所以两个状态可以直接合并，并不需要额外走任何步数。

两个 $+4$ 的转移及第三个 $+2$ 的转移：与 $f$ 的 $+4$ 的转移类似，在上面三个转移的基础上走到 $to$ 点再走回来一次以实现 $p$ 点和 $to$ 点上状态都反转的效果。

$g$ 和 $h$ 的状态考虑了路径端点，所以不一定要从子树里转移而来，也有可能是以当前点为状态中路径的端点。

$$\begin{cases}
g[p][0]=min(g[p][0],f[p][1]+1)\\
g[p][1]=min(g[p][1],f[p][0]+1)\\
h[p][0]=min(h[p][0],f[p][0])\\
h[p][1]=min(h[p][1],f[p][1])\\
\end{cases}$$ 

↑↑↑ 四个以当前点为路径端点的转移。

对于 $g$ 的两个转移：设置当前点为起点。因为我们定义的 $f$ 状态中没有记录进入当前点的那一步，而以 $p$ 为起点后状态里少了起点那一步，所以要 $+1$，$f$ 的状态也对应反转。

对于 $h$ 的两个转移：设置当前点为一个端点。$g$ 与 $h$ 同样都只记录了离开当前点的一步，所以直接与 $f$ 状态取 $\min$ 即可。

初始选定的根需要其上的灯是关闭的，否则会通过一些不必要的步数将打开的灯关上再打开。最后的 $h_{root,1}$ 即为最终的答案。

#### 代码

```cpp
#include <cstdio>
#include <algorithm>
using std::min;
const int Nx=500010;
int N;
char A[Nx];
struct edge{int to,nex;};
edge a[2*Nx];
int head[Nx],cnt;
void add(int u,int v)
{
	a[++cnt].to=v;
	a[cnt].nex=head[u];
	head[u]=cnt;
}
int siz[Nx],saz[Nx],used[Nx];
void dfs_X(int p,int fa)
{
	int i;
	siz[p]=1;
	saz[p]=A[p];
	for(i=head[p];i;i=a[i].nex)
	{
		if(a[i].to==fa)
			continue;
		dfs_X(a[i].to,p);
		siz[p]+=siz[a[i].to];
		saz[p]+=saz[a[i].to];
	}
	if(siz[p]==saz[p])
		used[p]=1;
}
int F[Nx][3],G[Nx][3],H[Nx][3];//i的子树内灯泡全部被点亮的最短路径长度 F该路径两端点都不在i子树内 G有一个端点在i子树里 H两个端点都在i子树里
void dfs_DP(int p,int fa)
{
	//printf("DP : %d %d\n",p,fa);
	int i,to,f[3],g[3],h[3];
	F[p][A[p]]=0;
	for(i=head[p];i;i=a[i].nex)
	{
		if(a[i].to==fa||used[a[i].to])
			continue;
		dfs_DP(a[i].to,p);
		to=a[i].to;
		f[0]=F[p][0],g[0]=G[p][0],h[0]=H[p][0];
		f[1]=F[p][1],g[1]=G[p][1],h[1]=H[p][1];
		F[p][0]=min({f[1]+F[to][0]+2,f[0]+F[to][1]+4});
		F[p][1]=min({f[0]+F[to][0]+2,f[1]+F[to][1]+4});
		G[p][0]=min({g[1]+F[to][0]+2,g[0]+F[to][1]+4,f[1]+G[to][1]+1,f[0]+G[to][0]+3});
		G[p][1]=min({g[0]+F[to][0]+2,g[1]+F[to][1]+4,f[0]+G[to][1]+1,f[1]+G[to][0]+3});
		H[p][0]=min({h[1]+F[to][0]+2,h[0]+F[to][1]+4,f[1]+H[to][0]+2,f[0]+H[to][1]+4,g[0]+G[to][1],g[1]+G[to][0]+2});
		H[p][1]=min({h[0]+F[to][0]+2,h[1]+F[to][1]+4,f[0]+H[to][0]+2,f[1]+H[to][1]+4,g[1]+G[to][1],g[0]+G[to][0]+2});
	}
	G[p][0]=min(G[p][0],F[p][1]+1);
	G[p][1]=min(G[p][1],F[p][0]+1);
	H[p][0]=min(H[p][0],G[p][0]);
	H[p][1]=min(H[p][1],G[p][1]);
}
int main()
{
	scanf("%d%s",&N,A+1);
	int i,j,k;
	for(i=1;i<=N;i++)
		A[i]-='0';
	for(i=1;i<N;i++)
	{
		scanf("%d%d",&j,&k);
		add(j,k),add(k,j);
	}
	k=0;
	for(i=1;i<=N;i++)
	{
		F[i][0]=G[i][0]=H[i][0]=1e8;
		F[i][1]=G[i][1]=H[i][1]=1e8;
		if(k==0&&A[i]==0)
			k=i;
	}
	if(k==0)
	{
		printf("0\n");
		return 0;
	}
	dfs_X(k,0);
	dfs_DP(k,0);
	printf("%d\n",H[k][1]);
}
```


---

## 作者：vectorwyx (赞：1)

钦定 $1$ 为根，以 $i$ 为根的子树有四种情况：进去了之后又出来（即子树内没有起点也没有终点），进去了就再也没出来（子树内有终点无起点），一开始从那里走出来后就没进去（子树内有起点无终点），从那里出来又走回来（子树内起点终点均有）。 

这个状态看上去合并的难度并不大，但是细节一堆。由于走完子树后 $i$ 结点本身可能不为 $1$，所以还要多记一维 $0/1$。记 $f_{i,0/1,0/1,0/1}$ 表示处理完 $i$ 子树，$i$ 的所有子结点均为 $1$，且子树内无/有起点、无/有终点、$i$ 为 $0/1$ 的最小代价。合并子树时类似，记一个辅助数组 $g_{0/1,0/1,0/1}$ 表示合并完目前的这些子树，是否已经选定了起点，是否已经选定了终点，以及 $i$ 被经过了偶数次/奇数次的最小代价。

先来考虑以怎样的方式计算代价。假设 $i$ 子树内没有起点或终点，那么 $i$ 子树对应的路径一定形如：$i\to p_1\to i\to p_2\to \cdots\to i$。先不管末尾的 $\to i$，在每次合并 $f(p,0,0,k)$ 时把新产生的 $i\to p$ 的贡献考虑进去，最后结束时再把"尾款" $\to i$ 的贡献算到 $g(0,0,k)$ 里。  这样同样能处理其他情况，在合并 $f(p,1,0,k)$ 时实际上是在路径的最前面插入了一个 $p\to$，$i,p$ 并没有被多经过一次，只是把两条路径衔接起来；合并 $f(p,0,1,k)$ 同理，是在路径的末尾插入了一个 $\to p$；合并 $f(p,1,1,k)$ 则是在前面插入了 $p\to$，后面插入了 $\to p$，$i$ 经过次数无影响但是 $p$ 被多经过了一次。

四种情况都是简明的，注意如果处理完 $p$ 对应子树后 $p$ 结点的值为 $0$ ，需要在 $p,i$ 之间多折返一次把 $p$ 的值调整为 $1$，这会额外产生 $2$ 的代价。但是答案路径可能不会经过 $p,i$ 啊？所以需要**在初始时不断剥去值为 $1$ 的叶子**来保证每条边都会被经过至少一次，这样就可以肆意调整了。在合并完子树后我们还可以把 $i$ 本身钦定为起点或终点，处理这个只需要把 $g$ 的每个状态向它的超集贡献一次，比如 $g(0,0,k)$ 贡献到 $g(0,1,k),g(1,0,k),g(1,1,k)$。

代码如下（核心代码很短，但鬼知道我调了多久）：
```cpp
//author:望远星
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned int
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
#define ptc putchar
#define emp emplace
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){int ch=getchar(),x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=5e5+5;
int n,a[N],f[N][2][2][2],g[2][2][2],g_[2][2][2],ok[N],rt;
vector<int> e[N];

inline int F(int i,int j,int k){
	//if(i==1&&j==0) return (k^1)<<1;
	if(i&j) k^=1;
	return (k^1)<<1|1;
}

void dfs(int x,int fa){
//	printf("dfs(%d,%d)\n",x,fa);
	ok[x]=a[x];
	vector<int> son;
	for(int i:e[x]) if(i!=fa){
		dfs(i,x);
		ok[x]&=ok[i];
		if(!ok[i]) son.pb(i);
	}
	if(ok[x]) return;
	memset(g,0x3f,sizeof g);//g[0][0][0]=g[1][0][0]=0;g[0][1][1]=g[1][1][1]=1;
	g[0][0][0]=0;
	//(0,0) (0,1) (1,0) (1,1) 都各有一项尾款（最后一步）未处理，
	//合并子树结束后，即确认该状态不会再转移到新状态后把这一步处理掉 
	for(int p:son){
		memset(g_,0x3f,sizeof g_);
		fo(i,0,1) fo(j,0,1) fo(ii,0,!i) fo(jj,0,!j) fo(k,0,1) fo(kk,0,1){
			int c=(kk^1)<<1;
			if(ii&jj) sml(g_[i|ii][j|jj][k^kk],g[i][j][k]+f[p][ii][jj][kk]+2-c+1);
			else if(ii|jj) sml(g_[i|ii][j|jj][k^kk^1],g[i][j][k]+f[p][ii][jj][kk]+c);
			else sml(g_[i|ii][j|jj][k^kk],g[i][j][k]+f[p][ii][jj][kk]+c+1);
		}
		memcpy(g,g_,sizeof g); 
	}
	//g[1][0][0]++,g[1][0][1]++;swap(g[1][0][0],g[1][0][1]);
	//g[0][0][0]++,g[0][0][1]++;swap(g[0][0][0],g[0][0][1]);
	fo(i,0,1) fo(j,0,1) g[i][j][0]++,g[i][j][1]++,swap(g[i][j][0],g[i][j][1]);
	//cout<<x<<":\n";
	//fo(i,0,1) fo(j,0,1) fo(k,0,1) printf("g(%d,%d,%d)=%d\n",i,j,k,g[i][j][k]);	
	fo(i,0,1) fo(j,0,1) fo(ii,i,1) fo(jj,j,1) fo(k,0,1) sml(g[ii][jj][k],g[i][j][k]);
	fo(i,0,1) fo(j,0,1) fo(k,0,1) f[x][i][j][k]=g[i][j][k^a[x]];
	
//	fo(i,0,1) fo(j,0,1) fo(k,0,1) printf("f(%d,%d,%d)=%d\n",i,j,k,f[x][i][j][k]);
}

signed main(){
	cin>>n;
	string s;cin>>s;
	for(ull i=0;s[i]!='\0';++i) a[i+1]=s[i]=='1';
	fo(i,2,n){
		int x=read(),y=read();
		e[x].pb(y),e[y].pb(x);
	}
	fo(i,1,n) if(!a[i]){rt=i;break;}
	dfs(rt,0);
	cout<<f[rt][1][1][1];
	return 0;
}
/*
-------------------------------------------------
*/

```


---


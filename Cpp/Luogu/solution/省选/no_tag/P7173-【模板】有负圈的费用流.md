# 【模板】有负圈的费用流

## 题目描述

给定一张 $n$ 个点 $m$ 条边的费用网络，源为 $s$ 且汇为 $t$ ，求其最小费用最大流。

注意存在费用为负的边和总费用为负的环。

注意，本题中允许一个不经过 $s,t$ 的环整体加上一个流量。事实上，若不允许这种情况的出现，则哈密顿路可以归约为这个问题。

## 说明/提示

对于 $100\%$ 的数据：$1\leq n\leq 200$，$1\leq m\leq {10}^{4}$，$0\leq f_i,|v_i|\leq 100$。

注：不知道消圈算法能不能过，由于数据分档，即使不能过应该也能拿到一定的分数。

## 样例 #1

### 输入

```
4 5 4 3
4 2 30 2
4 3 20 3
2 3 20 1
2 1 30 9
1 3 40 5
```

### 输出

```
50 280
```

## 样例 #2

### 输入

```
5 7 1 5
1 3 2 4
1 2 2 3
3 5 2 2
3 2 1 -1
2 4 2 -2
4 3 1 -1
4 5 1 3
```

### 输出

```
3 12
```

# 题解

## 作者：hezlik (赞：33)

增广路算法由于实现中存在最短路算法，无法处理存在费用负圈的最小费用流问题。

消圈算法本身就有消除负圈的过程，但由于效率低下，在 OI 中并不实用。

我们考虑利用上下界网络流的技术来解决负圈的问题。

对于网络中的负费用边 $x\rightarrow y$，我们先让其直接满流。然后加入一条边 $y\rightarrow x$，费用为原来费用的相反数，用于退流。

满流直接用上下界费用流的技术解决，跑一个有源汇上下界最小费用最大流即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N=200,M=10000,INF=(1<<30)-1;

int n,m,st0,td0,df[N+9];
int ans[2];
struct side{
  int y,next,f,v;
}e[M*2+N*2+9];
int lin[N+9],cs;

void Ins(int x,int y,int f,int v){e[++cs].y=y;e[cs].f=f;e[cs].v=v;e[cs].next=lin[x];lin[x]=cs;}
void Ins_flow(int x,int y,int f,int v){Ins(x,y,f,v);Ins(y,x,0,-v);}

void into(){
  scanf("%d%d%d%d",&n,&m,&st0,&td0);
  cs=1;
  for (int i=1;i<=m;++i){
    int x,y,f,v;
    scanf("%d%d%d%d",&x,&y,&f,&v);
    if (v>=0) Ins_flow(x,y,f,v);
    else{
      df[x]-=f;df[y]+=f;ans[1]+=f*v;
      Ins_flow(y,x,f,-v);
    }
  }
}

int st,td,cn;

void Get_graph(){
  st=n+1;td=cn=n+2;
  for (int i=1;i<=cn-2;++i){
    if (!df[i]) continue;
    df[i]>0?Ins_flow(st,i,df[i],0):Ins_flow(i,td,-df[i],0);
  }
  Ins_flow(td0,st0,INF,0);
}

int flow,value;
int dis[N+9],vis[N+9],pre[N+9],f[N+9];
queue<int>q;

bool Spfa(int st,int td){
  for (int i=1;i<=cn;++i) dis[i]=INF,vis[i]=0;
  dis[st]=0;vis[st]=1;f[st]=INF;q.push(st);
  for (;!q.empty();){
    int t=q.front();q.pop();
    vis[t]=0;
    for (int i=lin[t];i;i=e[i].next)
      if (e[i].f&&dis[t]+e[i].v<dis[e[i].y]){
        dis[e[i].y]=dis[t]+e[i].v;
        pre[e[i].y]=i;
        f[e[i].y]=min(f[t],e[i].f);
        if (!vis[e[i].y]) vis[e[i].y]=1,q.push(e[i].y);
      }
  }
  return dis[td]^INF;
}

void Max_flow(int st,int td){
  flow=0;value=0;
  for (;Spfa(st,td);flow+=f[td],value+=f[td]*dis[td])
    for (int k=td;k^st;k=e[pre[k]^1].y) e[pre[k]].f-=f[td],e[pre[k]^1].f+=f[td];
}

void Get_ans(){
  Max_flow(st,td);
  ans[1]+=value;
  Max_flow(st0,td0);
  ans[0]=flow;ans[1]+=value;
}

void work(){
  Get_graph();
  Get_ans();
}

void outo(){
  printf("%d %d\n",ans[0],ans[1]);
}

int main(){
  into();
  work();
  outo();
  return 0;
}
```

---

## 作者：Ckger (赞：19)

对于有负环的费用流，就得使用另外一种处理方式了，那就是强制满流。对于一条边，我们可以这样来让他的费用变为正。

首先，如图，假设 $u$ 到 $v$ 有一条权值为 $-w$ 的边 $(w > 0)$ ，容量为 $cap$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/d6932tj7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么我们可以在图上进行一些操作，如图，我们先建一个虚拟源点 $(ss)$ 和虚拟汇点 $(tt)$ ，由 $ss$ 指向 $u$ ， $tt$ 指向 $v$ ，容量暂时不管，费用均为0。

![](https://cdn.luogu.com.cn/upload/image_hosting/uw1by4bj.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么很显然，从 $ss$ 到 $tt$ 有一条容量为 $cap$ 的增广路，那么正好流满
这一条路，残余网络变成了这个样子，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/n4qv56sw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这样如果不看 $ss$ 和 $tt$ 连向 $u,v$ 的边的容量的话，实际就是将连接 $u,v$ 的边反向了，或者说，是**提前将这条边流满了**，没错，因为网络流的“反悔”性质，提前流满一条边是不会对答案产生影响的。但是在原网络图中，即使你这条边流满了，这在当前的网络中是不合法的。这时怎么办呢？ $ss$ 和 $tt$ 的作用就在于这里，虚拟源汇能保障你当前网络的合法性，从而保障强制满流的合法性。跑费用流时，先跑一遍虚拟源汇，再跑一遍真实的源汇即可。对于满流对费用的影响，一开始把边的费用算一下即可，还是不难的。

至于 $ss$ 连向 $u$ 和 $v$ 连向 $tt$ 的边的容量，选为 $cap$ 即可，因为反悔的容量不会超过 $cap$ 。

最后值得注意的是实际运用当中，因为 $ss$ 连出的边和 $tt$ 连入的边费用都为 0 ，所以对于一个点既有由 $ss$ 连入的边，又有连向 $tt$ 的边，就可以把边抵消一部分，从而减少常数。

处理负权的部分：

```cpp
inline void init()
{
	foir(i,1,m)
	{
		int u=read(),v=read(),c=read(),w=read();
		if (w>=0)
			link(u,v,c,w),link(v,u,0,-w);
		else
		{
			link(v,u,c,-w),link(u,v,0,w);
			tot[u]-=c,tot[v]+=c;
			minc+=c*w;  
		}
	}
	st=n+1,tt=st+1;
	foir(i,1,n)
	{
		if(!tot[i])
			continue;
		if(tot[i]>0)
			link(st,i,tot[i],0),link(i,st,0,0);
		else link(i,tt,-tot[i],0),link(tt,i,0,0);
	}
}
```

---

## 作者：Flanksy (赞：16)

#### 有源汇上下界最小费用可行流

------------

为了消除负环，强制所有负权边 $(x,y)$ 满流并统计这些负权边的费用。加入边 $(y,x)$ 用于退流，其权值为边 $(x,y)$ 权值的相反数，流量下界为 $0$，流量上界为 $(x,y)$ 的容量，然后使用上下界网络流求解。不会上下界费用流的建议先去做 [P4043](https://www.luogu.com.cn/problem/P4043)。

强制满流可以解释为加入流量上界为 $f$，下界为 $f$，费用为 $v$ 的边 $(x,y)$。注意到这时 $(x,y)$ 只需要统计一下，不需要实际添加。而反向边实际上是用来退流反悔的。

更详细的解释可以看其他题解，现有题解都没有给出一个比较格式化的求解流程，这里补一个。

以下流程中部分是给没学过上下界网络流的读者看的，可能有些繁琐。

------------

注意下文中提及的边的“容量”代表该边的流量下界为 $0$，流量上界为容量。

- 读入边的信息 $x,y,f,v$ 并根据边权分类讨论：
	- $v \geq 0$：加入容量为 $f$，费用为 $v$ 的边 $(x,y)$。
   - $v < 0$：加入容量为 $f$，费用为 $-v$ 的边 $(y,x)$。**如前文所述，实际上还加入了一条流量上下界同为 $f$ 的边 $(x,y)$，按照上下界网络流套路统计每个点入流量和出流量的差（设为 $w$）。** 将满流边的费用 $f \times v$ 计入答案费用。

- 建立附加源汇点 $SS,TT$ 并连边，具体地，对于点 $i$：
	- $w_i>0$：加入容量为 $w_i$ 的边 $(SS,i)$。
   - $w_i<0$：加入容量为 $-w_i$ 的边 $(i,TT)$。
	- $w_i=0$：什么都不干。

- 加入容量为 $inf$ 的边 $(T,S)$，在图上跑以 $SS$ 为源点，$TT$ 为汇点的最小费用最大流（求解有源汇最小费用可行流）。将可行流流量（最后加入的边 $(T,S)$ 的流量）计入答案流量，将此次最小费用最大流的费用计入答案费用。

- 撤去所有与附加源汇点 $SS,TT$ 相连的边和最后加入的边 $(T,S)$。跑一次以 $S$ 为源点，$T$ 为汇点的最小费用最大流。将此次最小费用最大流的流量和费用计入答案流量和答案费用。

**刚开始的强制满流可以保证任意时刻网络无负环。**

答案流量为可行流流量与最小费用最大流流量之和，答案费用为强制满流的费用、可行流的费用与最小费用最大流的费用之和。

------------

总体时间复杂度 $O(nmf)$，其中 $f$ 为求解过程中网络的最大流量。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int inf=1000000000;
namespace net{
	int cnt,lim,h[205],hc[205],dis[205],f[100005],w[100005],to[100005],nxt[100005];
	bool on[205];
	queue<int> q;
	void lockstar(int x){lim=x;}//封锁下标大于 x 的边 
	void reset(){cnt=1,lim=inf;}
	inline void addstar(int x,int y,int _f,int _w){
		f[++cnt]=_f,w[cnt]=_w,to[cnt]=y,nxt[cnt]=h[x],h[x]=cnt;
		f[++cnt]=0,w[cnt]=-_w,to[cnt]=x,nxt[cnt]=h[y],h[y]=cnt;
	}
	bool SPFA(int x,int y){
		memset(dis,63,sizeof(dis)),dis[x]=0;
		for(q.push(x);!q.empty();q.pop()){
			int now=q.front();
			on[now]=0;
			for(int i=h[now];i;i=nxt[i]) if(i<=lim&&f[i]&&dis[to[i]]>dis[now]+w[i]){
				dis[to[i]]=dis[now]+w[i];
				if(!on[to[i]]) on[to[i]]=1,q.push(to[i]);
			}
		}
		return dis[y]<inf;
	}
	int dfs(int x,int flow,int aim){
		if(x==aim||!flow) return flow;
		int ret=0;
		on[x]=1;
		for(int &i=hc[x];i;i=nxt[i]) if(i<=lim&&!on[to[i]]&&dis[to[i]]==dis[x]+w[i]){
			int now=dfs(to[i],min(flow,f[i]),aim);
			ret+=now,f[i]-=now,f[i^1]+=now,flow-=now;
			if(!flow) break;
		}
		on[x]=0;
		return ret;
	}
	pair<int,int> SSP(int S,int T){
		pair<int,int> ret;
		while(SPFA(S,T)){
			memcpy(hc,h,sizeof(hc));
			int flow=dfs(S,inf,T);
			ret.first+=flow;
			ret.second+=dis[T]*flow;
		}
		return ret;
	}
}
//强制满流负权边 连反向正权边退流 限制退流流量
//有源汇上下界最小费用可行流解决
int n,m,S,T,SS,TT,ans,mem,maxflow,w[205];
int main(){
	scanf("%d%d%d%d",&n,&m,&S,&T);
	net::reset(); 
	for(int i=1;i<=m;i++){
		static int x,y,f,_w;
		scanf("%d%d%d%d",&x,&y,&f,&_w);
		if(!f) continue;//要你何用
		if(_w>=0) net::addstar(x,y,f,_w);
		else{//下界0 上界f 费用取反
			w[x]-=f,w[y]+=f,ans+=_w*f;
			net::addstar(y,x,f,-_w);
		}
	}
	SS=n+1,TT=SS+1,mem=net::cnt;
	for(int i=1;i<=n;i++){
		if(w[i]>0) net::addstar(SS,i,w[i],0);
		if(w[i]<0) net::addstar(i,TT,-w[i],0);
	}
	net::addstar(T,S,inf,0);
	auto SSP=net::SSP(SS,TT);//可行流
	maxflow=net::f[net::cnt];//拿到可行流实际流量
	ans+=SSP.second;//拿到可行流费用
	net::lockstar(mem);//封边
	SSP=net::SSP(S,T);//在原图上跑
	maxflow+=SSP.first,ans+=SSP.second;
	printf("%d %d\n",maxflow,ans);
	return 0;
}
```

---

## 作者：Garrison (赞：9)

其实相较于普通的费用流模板只多了一个对于负边的处理（强制满流）。

对于负的来说，我们可以建立一个临时的原点和汇点，先手跑一边增广。

实际上就相当与原本从  $   a \rightarrow b   $   有一条 $ -1 $  的边，实际上就相当于，从   $b \rightarrow a$ 有一条  $1$  的边，只不过费用相反，然后将 $a$ 往临时汇点， $b$  往临时源点 连一条边。

最后跑最小费用最大流即可。
```
#include<cstdio>
#include<queue>
#include<string.h>
using std::queue;
#define min(a,b) a<b?a:b
#define N 100005
const int INF = (1<<29);
int tot=1,head[N<<1],cost[N<<1],to[N<<1],cap[N<<1],nex[N<<1];
int incf[N],pre[N],vis[N],d[N];
int maxflow,ans;
void add(int x,int y,int c,int z){
    ++tot;
    to[tot]=y;
    cost[tot]=z;
    cap[tot]=c;
    nex[tot]=head[x];
    head[x]=tot;
}
inline bool spfa(int s,int t){
    memset(vis,0,sizeof vis);
    memset(d,127,sizeof d);
    queue<int> Q;
    Q.push(s),d[s]=0,vis[s]=1,incf[s]=INF;
    while(!Q.empty()){
        int x=Q.front();Q.pop();
        vis[x]=0;
        for(int i=head[x];i;i=nex[i]){
            int u=to[i];
            if(cap[i]&&d[u]>d[x]+cost[i]){
               d[u]=d[x]+cost[i];
               pre[u]=i;
               incf[u]=min(incf[x],cap[i]);
               if(!vis[u]) 
                   vis[u]=1,Q.push(u);
            }
        }
    }
    if(d[t]>=INF)
        return 0;
    return 1;
}
inline void update(int s,int t){
	int u=t,i;
	while(u!=s){
		i=pre[u];
		cap[i]-=incf[t];
		cap[i^1]+=incf[t];
		u=to[i^1];
	}
	maxflow+=incf[t]; 
    ans+=incf[t]*d[t];
}
int n,m,s,t,st,tt,total[N];
inline void EK(){
    while(spfa(st,tt))
        update(st,tt);
    maxflow=0;
    while(spfa(s,t))
        update(s,t);
}
signed main(){
    int u,v,c,w;
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(register int i=1;i<=m;++i){
        scanf("%d%d%d%d",&u,&v,&c,&w);
        if(w>=0)
            add(u,v,c,w),add(v,u,0,-w);
        else{
            add(v,u,c,-w),add(u,v,0,w);
            total[u]-=c,total[v]+=c;
            ans+=c*w;  
        }
    }
    st=n+1,tt=n+2;
    for(register int i=1;i<=n;++i){
        if(!total[i])
            continue;
        if(total[i]>0)
            add(st,i,total[i],0),add(i,st,0,0);
        else add(i,tt,-total[i],0),add(tt,i,0,0);
    }
    add(t,s,INF,0),add(s,t,0,0),
    EK();
    printf("%d %d\n",maxflow,ans);
    return 0;
}
```


---

## 作者：x383494 (赞：7)

[可能更好的食用体验](https://www.cnblogs.com/x383494/p/17497006.html)。

upd：修了英文与标点间多空格的锅。

upd：修了中文与符号间少空格的锅，补上一处句号并自查无锅。这次再格式不过我就不打扰管理了 orz。

网络单纯形是一种神奇的算法。它可以求解带负圈的费用流，可以过 HLPP 板子，但它的（最坏）复杂度好像是指数级，尽管我并不会证。

感性理解：它和线规算法 simplex 有许多相似之处，而 simplex（最坏）是指数级的。

虽然但是，据 CF（见本文末尾）上所讲，它的平均时间复杂度是 $O(VE)$，且常数较小（无 LCT 情况下）。~~SPFA被卡前：这我熟。~~

网络单纯形算法可用来求解无源汇有负圈上下界最小费用可行流。~~好像常见的网络流都可以转化为这个~~，但加入上下界后常数会略大，不知道是不是我写炸了，欢迎大佬修改。

将有源汇最小费用最大流转换为无源汇最小费用可行流的方法：从汇向源连一条费用为 $-\infty$，流量为 $+\infty$ 的边。实际可取 `inf` 为其余边费用/流量之和加一。

将上下界最小费用可行流转换为一般的最小费用可行流的方法：先所有边强制推下界的流，记录“溢出”的流，建虚拟点 $K$，$K$ 向所有“上溢”（流量有多余）的点连边，权为 $-\infty$；所有“下溢”的点向 $K$ 连边，权为 $0$。最后检查这些边是否跑满即可。

感性理解：若存在一条路径，从某个“上溢”的点 $A$ 到另一个“下溢”的点 $B$，则它与 $B \rightarrow K \rightarrow A$ 的路径构成负环，可推流（见下文），这相当于之前我们强制推的流从这条路径回去。

网络单纯形算法的大致思路：求解最小费用可行流时，给定图 $G=(V,E)$，在算法过程中，我们维护它的生成森林（原图可能不联通）边集 $T$，每次找一条不在 $T$ 内的边 $t \in E \setminus T$，若 $T \cup \{t\}$ 包含负环，则在 $T$ 中沿此负环推流，选出一条满流的边删去，将 $t$ 加入 $T$。重复此过程直到 $T$ 中不含负环，我们就得到了 $G$ 的最小费用可行流。这样的思想使得网络单纯型算法天生就支持带负环的费用流。

线规角度的解释：生成森林相当于初始可行解，向负环推流相当于转动变量。

# 判断一条边加入生成树后是否有负环

考虑函数 $h:V \rightarrow \mathbf{R}$，满足对 $\forall e \in T, h(e.\text{to}) - h(e.\text{from}) = e.\text{cost}$，那么对于两个点 $a,b$，$h(a)-h(b)$ 就是 $T$ 上 $a$ 到 $b$ 一条路的权值之和。对边 $e \in E$，若 $h(e.\text{to}) - h(e.\text{from}) + e.\text{cost} < 0$，则它所在的环路（沿着它的方向）为负环。这样可做到 $\Theta(1)$ 判断是否这条边加入后存在负环。

# 找到负环后推流

先从 $e.\text{from}$ 和 $e.\text{to}$ 向上跳到 LCA，再从两边分别找能推的最小流值，最后推流。

这里如果用 LCT 维护，则可从 $O(n)$ 优化到 $O(\log n)$，但常数大。

推流后，别忘了删边并反转被删的链的父子关系，保证生成树还是树。

# Code

跑得飞快.jpg

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#define sd std::
#define UP(i,s,e) for(auto i=s; i!=e; ++i)
#define IT(i,x) for(int i=flow::head[x]; i!=flow::EDGE_NIL; i=flow::es[i].nxt)
namespace flow{ // }{{{
typedef long long ll;
constexpr int V = 5e3+100, E = V+5e4+100;
constexpr int EDGE_NIL = 0;
struct Edge{
        int to;
        ll lf, cost;
        int nxt;
} es[E*2+4];
ll sumcost = 0, sumflow = 0;
int is, it, iv;
ll minc, maxf;
int head[V], cnt = (EDGE_NIL|1)+1;
ll pi[V]; // h 函数
int fe[V], mark[V], time = 2; // fe: father edge
int fa[V];
void init(int v, int s, int t){
        is = s, it = t, iv = v+1;
        sd fill(head, head+iv, EDGE_NIL);
        sd fill(mark, mark+iv, 0);
        sd fill(fe, fe+iv, EDGE_NIL);
        time = 2;
        cnt = (EDGE_NIL|1)+1;
        sumcost = sumflow = 0;
        minc = maxf = 0;
}
void addflow(int s, int t, ll f, ll c){
        es[cnt] = (Edge){t, f, c, head[s]}, head[s] = cnt++;
        es[cnt] = (Edge){s, 0, -c, head[t]}, head[t] = cnt++;
        sumflow += f, sumcost += sd abs(c);
}
void mktree(int x, int from_e){
        fe[x] = from_e;
        fa[x] = es[from_e^1].to;
        mark[x] = 1;
        for(int i=head[x]; i!=EDGE_NIL; i=es[i].nxt){
                if(mark[es[i].to] == 1 || es[i].lf == 0) continue;
                mktree(es[i].to, i);
        }
}
ll getpi(int x){ // 获取某个点的 h 值
        if(mark[x] == time) return pi[x];
        mark[x] = time;
        pi[x] = getpi(fa[x]) - es[fe[x]].cost;
        return pi[x];
}
ll pushflow(int e){ // 返回减少的费用
        int rt = es[e].to, lca = es[e^1].to;
        time++;
        while(rt){ // rt 用来标记点
                mark[rt] = time;
                rt = fa[rt];
        }
        while(mark[lca] != time){ // lca 用来找 LCA
                mark[lca] = time;
                lca = fa[lca];
        }
        ll df = es[e].lf; // df 为流量的改变量
        int todel = e, dir = -1; // dir: direction, dir 为 0 表示 es[e].to 方向
        for(int i=es[e^1].to; i!=lca; i=fa[i]){ // 两边向上找能推的最小流
                if(es[fe[i]].lf < df){
                        df = es[fe[i]].lf;
                        todel = fe[i];
                        dir = 1;
                }
        }
        for(int i=es[e].to; i!=lca; i=fa[i]){
                if(es[fe[i]^1].lf < df){
                        df = es[fe[i]^1].lf;
                        todel = fe[i];
                        dir = 0;
                }
        }
        ll dcst = 0; // delta cost
        if(df) { // 推流
                for(int i=es[e].to; i!=lca; i=fa[i]){
                        es[fe[i]].lf += df;
                        es[fe[i]^1].lf -= df;
                        dcst += es[fe[i]^1].cost * df;
                }
                for(int i=es[e^1].to; i!=lca; i=fa[i]){
                        es[fe[i]].lf -= df;
                        es[fe[i]^1].lf += df;
                        dcst += es[fe[i]].cost * df;
                }
                es[e].lf -= df;
                es[e^1].lf += df;
                dcst += es[e].cost * df;
        }
        if(todel == e) return dcst;
        int last = e^dir, lastu = es[e^dir^1].to;
        for(int i=es[e^dir].to; i!=es[todel^1].to; ){
                mark[i]=time-1;
                int i_ = fa[i];
                fa[i] = lastu;
                lastu = i;
                sd swap(fe[i], last);
                last ^= 1;
                i=i_;
        }
        return dcst;
}
void mcmf(){
        ll sfl_ = sumflow, scs_ = sumcost;
        addflow(iv-1, is, sfl_, 0);
        addflow(it, iv-1, sfl_, -scs_-1);
        sumflow = sfl_, sumcost = scs_;
        mktree(iv-1, EDGE_NIL);
        mark[iv-1] = ++time;
        fa[iv-1] = 0;
        bool run = true;
        while(run){
                run = false;
                UP(i, (EDGE_NIL|1)+1, cnt){
                        int s = es[i^1].to, t = es[i].to;
                        if(es[i].lf && es[i].cost + getpi(t) - getpi(s) < 0){
                                run = true;
                                minc += pushflow(i);
                        }
                } // 一圈下来没流可推时算法结束
        }
        maxf = es[cnt-1].lf;
        minc += maxf * (scs_+1);
}
} // {}}}
namespace m { // }{{{
int in, im, is, it;
void work() {
        scanf("%d%d%d%d", &in, &im, &is, &it);
        is--, it--;
        flow::init(in, is, it);
        UP(i, 0, im) {
                int u, v, w, c;
                scanf("%d%d%d%d", &u, &v, &w, &c);
                u--, v--;
                flow::addflow(u, v, w, c);
        }
        flow::mcmf();
        printf("%lld %lld\n", flow::maxf, flow::minc);
}
} // {}}}
int main() { m::work(); return 0; }
```

# 参考资料

- Codeforces（强烈推荐看原文）[[Tutorial] Network simplex](https://codeforces.com/blog/entry/94190)
- 冰中火大佬的 blog [感性理解网络单纯形](https://fireinicecode.github.io/2022/05/17/network_simplex/)


---

## 作者：strcmp (赞：6)

费用流因为是使用最短路来查找增广路的，所以当原图上存在负权圈的时候，会导致不能正常终止的情况，但是原图的最小费用最大流仍然存在，所以考虑消去负圈。

有一种可以消去负圈的消圈算法，但时间复杂度实在太高，所以考虑最简单粗暴的做法：对于一条边 $u \to v$，其中 $u,v \in V$，如果其费用 $w$ 为负，则暴力使这条边满流，即可达到消除负权边的目的。

如何才能使这条边强制满流？考虑增加超级源 $s'$ 和超级汇 $t'$，对于每条负权边 $u \to v$，设其容量为 $w$，费用为 $c$。将其满流后，可以将其转化为 $v \to u$ 的一条容量为 $w$，费用为 $-c$ 的边，并加上对费用的贡献。

设 $\operatorname{tot}(u)$ 为 $u$ 附近的所有负权边出边的容量减去所有负权入边的容量。对于所有 $u \in V,u \ne s',u \ne t'$，如果 $\operatorname{tot}(u) > 0$，则 从 $s'$ 向 $u$ 连一条容量为 $\operatorname{tot}(u)$，费用为 $0$ 的边；如果 $\operatorname{tot}(u) < 0$，则从 $u$ 向 $t'$ 连一条容量为 $-\operatorname{tot}(u)$，费用为 $0$ 的边。

跑一遍最小费用最大流，可知原图上已不存在负权圈。

再以 $s$ 为源点，$t$ 为汇点，跑一遍最小费用最大流。

答案即为原图的最小费用最大流。

ACcode

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000000000
#define V 100100
#define E 200100
typedef long long int ll;
struct edge {
	int to, next;
	ll capa, cost;
};
int cnt = 0, head[V], n, m; edge node[E];
inline void add(int fir, int nxt, ll w, ll c) {
	node[cnt].to = nxt,
		node[cnt].capa = w,
		node[cnt].cost = c,
		node[cnt].next = head[fir],
		head[fir] = cnt++;
}
int s, t, cur[V]; deque<int>que; ll dep[V], sum = 0, cost = 0;
bool vis[V];
inline bool spfa() {
	for (register int i = 0; i <= n; ++i)dep[i] = inf;
	dep[s] = 0; que.push_back(s); int u, v;
	while (!que.empty()) {
		v = que.front(); que.pop_front();
		for (register int i = head[v]; i != -1; i = node[i].next) {
			u = node[i].to;
			if (dep[v] + node[i].cost < dep[u] && node[i].capa) {
				dep[u] = dep[v] + node[i].cost;
				if (!que.empty() && dep[u] < dep[que.front()])que.push_front(u);
				else que.push_back(u);
			}
		}
	}
	return (dep[t] != inf);
}
ll dfs(register int v, register ll flow) {
	if (v == t || flow == 0)return flow; ll used = 0, wei = 0;
	vis[v] = true;
	for (register int i = cur[v]; i != -1; i = node[i].next) {
		cur[v] = i;
		if (!vis[node[i].to] && dep[node[i].to] == dep[v] + node[i].cost && node[i].capa) {
			wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei,
					node[i ^ 1].capa += wei,
					used += wei,
					cost += node[i].cost * wei;
			}
		}
		if (used == flow)break;
	}
	vis[v] = false;
	return used;
}
inline void Dinic() {
	while (spfa()) {
		memcpy(cur, head, (n + 1) * sizeof(int));
		sum += dfs(s, inf);
	}
}
inline void addE(int u, int v, ll w, ll c) {
	add(u, v, w, c);
	add(v, u, 0, -c);
}
int st, ed; ll tot[V];
int main() {
	ios::sync_with_stdio(0);
	cin.tie(); cout.tie();
	memset(head, -1, V * sizeof(int));
	cin >> n >> m >> st >> ed; 
	int f, l; ll w, c;
	for (register int i = 0; i < m; ++i) {
		cin >> f >> l >> w >> c;
		if (c >= 0)addE(f, l, w, c);
		else {
			addE(l, f, w, -c);
			tot[f] -= w; tot[l] += w;
			cost += w * c;
		}
		
	}
	s = n + 1, t = n + 2; n = t;
	for (int i = 1; i <= n; i++) {
		if (!tot[i])continue;
		if (tot[i] > 0)addE(s, i, tot[i], 0);
		else addE(i, t, -tot[i], 0);
	}
	Dinic();
	s = st, t = ed; sum = 0; n -= 2;//sum 一定要清空
	Dinic();
	cout << sum << " " << cost;
	return 0;
}
```


---

## 作者：王大神——A001 (赞：4)

## 最小费用最大流
[P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)

### Dinic(费用流)
和 [Dinic最大流](https://wdsa001.github.io/2021/12/04/dinic/) 的最大的区别在于多了“费用”这一概念（所以不能随心所欲的“流”了）。

既然不能随心所欲的“流”了，那分层（找增广路的）的意义也不大了。所以就不用写 `Bfs`，取而代之的 `Spfa`（或者 `Dij`），思路变为每回找到花费最小的一条路，一条一条的找，不断更新即可。

在记录路径时，我们新开两个数组，一个负责存储流过来的节点是谁（类似于存父节点），另一个存储是从那条路流过来的（方便更新反向弧）。在最后更新流量时，通过不断的“爬树”即可。

注意：

- 由于多了“费用”，所以连反向边的时候，要将费用取反。

- 虽然要找最小费用，但前提是能流出最大流。

### 代码思路
- 加边（注意反向弧）。

- 判断汇点源点联通（同时计算联通的最小价值）。

- 累计价值和流量。

- 更新经过路径的流量。

- 输出最大流，最小费用。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<cctype>
#include<queue>
#include<vector>
using namespace std;
long long r_r(){//快读 
	long long x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=1e5+10;
struct po{
	int n_t;
	int v;
	int l;//流量 
	int c;//费用 
}p_p[o_o];
int h_d[o_o],x_p=1;
int n=r_r(),m=r_r(),s=r_r(),t=r_r();
bool b_b[o_o];//标记是否重复访问节点（跑环） 
int l_v[o_o];//节点剩余流量 
int v_l[o_o];//到当前节点最小价值 
int f_f[o_o];//存流向当前点的点 
int l_t[o_o];//存流向当前点的边 
int m_l,m_v;//最大流，最小花费 
void a_d(int u,int v,int l,int c){//加边 
	p_p[++x_p].v=v;
	p_p[x_p].l=l;
	p_p[x_p].c=c;
	p_p[x_p].n_t=h_d[u];
	h_d[u]=x_p;
}
queue<int>q_q;
bool s_p(){
	//初始化所有数组 
	memset(b_b,0,sizeof b_b);
	memset(l_v,0x3f,sizeof l_v);
	memset(v_l,0x3,sizeof v_l);
	
	q_q.push(s);//源点入队 
	b_b[s]=1;//标记 
	v_l[s]=0;//价值初始化 
	f_f[t]=-1;
	while(!q_q.empty()){
		int k_k=q_q.front();
		q_q.pop();
		b_b[k_k]=0;//取消标记 
		for(int i=h_d[k_k];i;i=p_p[i].n_t){//枚举出边 
			int v=p_p[i].v;
			if(p_p[i].l&&v_l[v]>v_l[k_k]+p_p[i].c){//有流量并且价值可以减小 
				v_l[v]=v_l[k_k]+p_p[i].c;//更新价值 
				f_f[v]=k_k;//记录来的点 
				l_t[v]=i;//记录来的边的编号 
				l_v[v]=min(l_v[k_k],p_p[i].l);//最多能流多少 
				if(!b_b[v]){//没有被标记过（不会跑环） 
					b_b[v]=1;//标记 
					q_q.push(v);//入队 
				}
			}
		}
	}
	return f_f[t]!=-1;//源点汇点是否联通 
}
int main(){
	for(int i=1;i<=m;i++){
		int a=r_r(),b=r_r(),v=r_r(),c=r_r();//加边 
		a_d(a,b,v,c);
		a_d(b,a,0,-c);//反向弧，注意花费取反 
	}
	while(s_p()){//源点汇点联通，还有流量可流 
		int k_k=t;
		m_l+=l_v[k_k];//累计流量 
		m_v+=l_v[k_k]*v_l[k_k];//累计价值 
		while(k_k!=s){//没有返回源点 
			p_p[l_t[k_k]].l-=l_v[t];//更新边的流量 
			p_p[l_t[k_k]^1].l+=l_v[t];//更新反向弧的流量 
			k_k=f_f[k_k];//跳上一级 
		}
	}
	printf("%d %d",m_l,m_v);//输出最大流，最小费用 
	return 0;
} 
```
## 有负圈的费用流
[P7173 【模板】有负圈的费用流](https://www.luogu.com.cn/problem/P7173)

### 思路
和普通的最小费用最大流的区别在于出现了“负圈”的情况。

而在上面的 `Dinic` 算法中，我们用到了 `SPFA` 来判最小花费，所以如果出现“负圈”，那么就会陷入死循环。

为了避免这种情况，我们可以先将所有的负边先流满，这样，它就和没有流满的正边的反向弧性质相同了，注意此时我们记录每个点的流量情况。可以让一些节点先“透支”一些流量，注意代价要记录结果。

现在，对于一些节点剩余的“量”是正数，而另一些是负数。这些值，我们肯定要处理的，这时，我们可以建两个新节点，一个新源点和所有大于零的节点连边（这样才能满足它们的“需求”），一个新汇点和所有小于零的节点连边（让它们多余的“流走”）。

这时通过新源点和新汇点跑一遍最大费用最小流，尽量满足不同节点的不同“需求”（此时已经不存在负边了，负边是越跑越划算的所以也是跑最小费用最大流）。因为我们一开始假设的是所有负边“流满”，而这之中可定有多余的（达不到最大流量的边），所以通过这次最大费用最小流来将这些“冗余”的“流量”除去。

满足尽量多的节点后，就可以将源点和汇点正常再跑一遍最小费用最大流了，因为还有一些没有“需求”的节点（没有负边的节点）需要统计。

### 代码思路
- 加边（注意反向弧）。

- 将所有负边“流满”，并记录节点状态和费用。

- 建新源点和新汇点，并和有需要的节点连边。

- 用新源点和新汇点跑一遍最小费用最大流，去除“冗余”。

- 在跑一遍真正的源点和汇点的最小费用最大流，统计结果，输出即可。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<cctype>
#include<queue>
#include<vector>
using namespace std;
long long r_r(){//快读 
	long long x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=2e5+10;
const int m_a=1e9+10;
struct po{
	int n_t;
	int v;
	int l;//边的最大流量 
	int c;//“路费” 
}p_p[o_o];
int x_p=1,h_d[o_o];
int v_l[o_o];//到当前节点最小价值 
int l_t[o_o];//记录流到当前节点的路 
int l_v[o_o];//最多能流的量 
int s_m[o_o];//当前点剩余流量 
bool b_b[o_o];//标记是否重复访问节点（跑环）
int m_l,m_v;//最大流量，最小花费 
int s_i,t_i;//临时节点 
int n=r_r(),m=r_r(),s=r_r(),t=r_r();
void a_d(int u,int v,int l,int c){//加边 
	p_p[++x_p].v=v;
	p_p[x_p].l=l;
	p_p[x_p].c=c;
	p_p[x_p].n_t=h_d[u];
	h_d[u]=x_p;
}
queue<int>q_q;
bool s_p(int s,int t){
	memset(b_b,0,sizeof b_b);//标记是否重复访问节点（跑环）
	memset(v_l,0x3f,sizeof v_l);//初始化流到当前节点的最小费用 
	q_q.push(s);
	v_l[s]=0;//初始化费用 
	b_b[s]=1;//标记 
	l_v[s]=m_a;//初始化最多流的量 
	while(!q_q.empty()){
		int k_k=q_q.front();
		q_q.pop();
		b_b[k_k]=0;//标记 
		for(int i=h_d[k_k];i;i=p_p[i].n_t){
			int v=p_p[i].v;
			if(p_p[i].l&&v_l[v]>v_l[k_k]+p_p[i].c){//有流量并且更新最小费用 
				v_l[v]=v_l[k_k]+p_p[i].c;//更新最小费用 
				l_t[v]=i;//记录流过来的路 
				l_v[v]=min(l_v[k_k],p_p[i].l);//最多能流的量 
				if(!b_b[v]){//标记是否重复访问节点（跑环）
					b_b[v]=1;//标记 
					q_q.push(v);//入队 
				}
			}
		}
	}
	return v_l[t]!=v_l[0];//检查源点汇点是否联通 
} 
void u_p(int s,int t){
	int k_k=t;
	while(k_k!=s){//未回到原点 
		int i=l_t[k_k];//返回流过来的路 
		p_p[i].l-=l_v[t];//更新路径流量 
		p_p[i^1].l+=l_v[t];//更新流量 
		k_k=p_p[i^1].v;//回到流过来的点 
	}
	m_l+=l_v[t];//统计流量 
	m_v+=l_v[t]*v_l[t];//统计费用 
}
int main(){
	for(int i=1;i<=m;i++){
		int a=r_r(),b=r_r(),w=r_r(),c=r_r();//读入 
		
		//加边 
		if(c>=0){
			a_d(a,b,w,c);
			a_d(b,a,0,-c);//加反向弧 
		}else {//假设所有负边全部流完了 
			a_d(a,b,0,c);//流量清零 
			a_d(b,a,w,-c);//反向弧更新 
			s_m[a]-=w;//节点流量更新 
			s_m[b]+=w;//节点流量更新 
			m_v+=w*c;//统计费用流 
		}
	}
	s_i=n+1;//新源点 
	t_i=n+2;//新汇点 
	for(int i=1;i<=n;i++){
		if(!s_m[i])continue;//没有流量跳过 
		if(s_m[i]>0){//节点需要流量 
			a_d(s_i,i,s_m[i],0);//和新源点连边（可以让“量”流过来） 
			a_d(i,s_i,0,0);//反向弧 
		}else {//节点不需要这些流量 
			a_d(i,t_i,-s_m[i],0);//和新汇点连边（可以让“量”流走）
			a_d(t_i,i,0,0);//反向弧 
		}
	}
	
	//处理所有需求和多余有关的“流动” 
	while(s_p(s_i,t_i))u_p(s_i,t_i);//新节点流量 
	
	m_l=0;//初始化最大流量 
	
	//此时问题已经解决了，可以跑正常的最小费用最大流了 
	while(s_p(s,t))u_p(s,t);//真正流量计算 
	
	printf("%d %d\n",m_l,m_v);//输出最大流量，最小费用 
	return 0;
} 
```



---

## 作者：Louis_1346 (赞：3)

## 题解：P7173 【模板】有负圈的费用流

### 题目描述

板子，有负环的费用流

### 思路

我们考虑使用上下界的思想+最小费用最大流解决负环问题。

先定义一条边的五元组表示法，我们令从 $u$ 连到 $v$，下界为 $l_i$，上界为 $r_i$，代价为 $w_i$ 的边叫做 $(u,v,l_i,r_i,w_i)$。

首先，对于一个源汇流变成无源汇流，显然的，只需要连 $(t,s,-inf,inf,0)$ 即可。

考虑上下界的一种理解方式：每一个点流量不守恒，利用原图中可以增广的路径修复每一个点的流量守恒条件，这说明，只要不超过上下界，一开始的不满足流量守恒的图可以是任意流量的。

然后我们考虑先将所有 $(u,v,w,co)$ 的边看作 $(u,v,0,w,co)$，变成上下界无源汇网络流。

明显的，没有流就是一组可行流，但是这样修复图中是有负环的，无法跑费用流。

但是，我们的原图是可以在上下界内随意赋值的，于是对于负数权值的边，我们干脆让它在原图中流满，那么修复图中就只会出现边权为正的边，这样修复图中就不会出现负环了。

然后此时考虑修复，找到可行流，然后再把刚刚加的 $(s,t)$ 边删掉，那么这样我们就成功的消除了所有的负环，此时再根据题目条件跑所需要的流即可。此时也是在原来的修复图上跑，同时我们刚刚已经知晓修复图上没有负环，于是也可以跑费用流了。

### code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x3f3f3f3f3f3f3f3f
const int maxn=1e6+10;
const int maxv=1e4+10;
int head[maxn],to[maxn],w[maxn],c[maxn],nxt[maxn],cnt=1;
void add_edge(int u,int v,int da,int cost){
	to[++cnt]=v;
	w[cnt]=da;
	c[cnt]=cost;
	nxt[cnt]=head[u];
	head[u]=cnt;
} 
int dis[maxn],st[maxn],cur[maxn];
int n,m,s,t,s1,t1,qwq;
bool spfa(int begin,int end,int bnd){
	queue<int> q;
	memset(st,0,sizeof(st));
	memset(dis,0x3f,sizeof(dis));
	dis[begin]=0,st[begin]=true,cur[begin]=head[begin];
	q.push(begin);
	while(!q.empty()){
		int u=q.front();
		st[u]=false;
		q.pop();
		for(int i=head[u];i;i=nxt[i]){
			if(i>bnd) continue;
			int v=to[i];
			if(w[i]>0&&dis[v]>dis[u]+c[i]){
				dis[v]=dis[u]+c[i];
				cur[v]=head[v];
				if(!st[v]){
					st[v]=true;
					q.push(v);
				}
			}
		}
	}
	return dis[end]!=inf;
}
int co;
int find(int u,int lim,int end,int bnd){
	if(u==end) return lim;
	int sum=0;
	st[u]=true;
	for(int i=cur[u];i&&sum<lim;i=nxt[i]){
		if(i>bnd) continue;
		cur[u]=i;
		int v=to[i];
		if(w[i]>0&&dis[v]==dis[u]+c[i]&&!st[v]){
			int flow=find(v,min(w[i],lim-sum),end,bnd);
			if(!flow) dis[v]=-1;
			w[i]-=flow,w[i^1]+=flow;
			co+=flow*c[i];
			sum+=flow;
		}
	}
	st[u]=false;
	return sum;
}
int dinic(int begin,int end,int bnd){
	int ans=0,sum;
	while(spfa(begin,end,bnd)) 
	while(sum=find(begin,inf,end,bnd)) 
	ans+=sum;
	return ans;
}
int into[maxv];
signed main(){
	scanf("%lld%lld%lld%lld",&n,&m,&s,&t);
	int a,b,c,d;
	for(int i=1;i<=m;i++){
		scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
		if(d<0){
			add_edge(b,a,c,-d);
			add_edge(a,b,0,d);
			into[a]-=c,into[b]+=c;
			co+=c*d;
		}else{
			add_edge(a,b,c,d);
			add_edge(b,a,0,-d);
		}
	}
	add_edge(t,s,inf,0);
	add_edge(s,t,0,0);
	qwq=cnt;
	s1=n+1,t1=n+2; 
	for(int i=1;i<=n;i++){
		if(into[i]<0) add_edge(i,t1,-into[i],0),add_edge(t1,i,0,0);
		else if(into[i]>0) add_edge(s1,i,into[i],0),add_edge(i,s1,0,0);
	}
	dinic(s1,t1,inf);
	printf("%lld ",dinic(s,t,qwq));
	printf("%lld",co);
}
```

---

## 作者：123456xwd (赞：2)

## 前置知识： 

### 无源汇上下界可行流：

无源汇上下界可行流就是一张没有源点和汇点的图，问你是否有可行的每条边分配的流量。

我们考虑，对于一条边，他的下界为 $l(u,v)$，我们不妨直接先假定他的流量就为 $l(u,v)$，则它变为一个上界为 $r(u,v)-l(u,v)$ 的管道，而流出 $u$ 的流量 $out_u$ 和流入 $v$ 的流量 $in_v$ 都增加 $l(u,v)$，然后我们考虑在新图上调整。

考虑一下，若是一个可行流，则对于每个点 $u$，设其在满足下界后额外流入的流量之和为 $x$，额外流出的流量之和为 $y$，则很明显，有：$in_u+x=out_u+y$，则$in_u-out_u=y-x$。

分讨一下：

1. 若 $in_u-out_u>0$，**则表示满足下界后，额外流出的流量比因该额外流入的流量多一些**，但是我们在新图上调整的话，也要想办法满足流量守恒，不如建立一个虚拟源点 $s$，将其连向 $u$，容量为 $in_u-out_u$，表示有一股的流量是**肯定**要从 $u$ 流出的。

2. 若 $in_u-out_u=0$，不管他。

3. 若 $in_u-out_u<0$，**则表示满足下界后，额外流入的流量比额外流出的流量多一些**，同理，建立一个虚拟汇点 $t$，$u$ 连向其，容量为 $out_u-in_u$，表示有一股的流量是**肯定**要流入 $u$ 的。

其实可以理解为在满足了下界后，他产生的一些流量不守恒的地方需要调整，而虚拟源汇就帮助我们进行调整。

由于我们新连接的这些边的流量只有在满流的时候，才使得其合法，所以跑一个最大流（相当于帮我们找到一个合法的方案，分配那些坑定要流入流出的流量），判断其是否等于我们所有和 $s$ 相连的边的容量之和，然后每条边的实际容量加上其跑最大流时的流量。

### 有源汇上下界可行流：

他同无汇源上下界可行流的最大区别就在于 $s,t$ 不满足流量守恒，但是从 $s$ 出发的流量肯定是等于流入 $t$ 的流量。

那么我们直接在前新建一条从 $t$ 到 $s$ ，流量为正无穷的边，原图就转化为了无源汇上下界可行流。

这个可行流的流量就相当于这条边的反边的流量。（其实就是有多少流量从 $t$ 又回到了 $s$）。

### 有源汇上下界最大流：

我们求出可行流后，把新增的这条边删掉，然后在残量网络上跑从 $s$ 到 $t$ 的最大流，和之前的可行流加起来即可。

证明：

设 $in_u,out_u$ 是每条边都流其下界的情况下，点 $u$ 流入流出的流量，**$x,y$ 表示我们找到的可行流中 $s$ 额外流出的和 $t$ 额外流入**的流量，满足：$out_s+x=in_t+y$。

而我们求的最大流，肯定满足这样的形式：$in_s+x+z=out_t+y+z$。

想要最大化 $z$，很明显在残量网络上跑最大流时，求得 $z$ 的最大值。

### 有源汇上下界最小费用流：

其实求解十分的简单，就是在求解有汇源上下界可行流的基础上将最大流算法改为求最小费用的算法即可，注意，还要加上每条边初始的保底流量产生的费用。

## 关于本题：
 难点在于对负权边的处理。

设有一条边 $(u,v,f,w)(w<0)$，（$f,w$ 分别表示流量和花费），我们先假设其为满流，其实就相当于在有汇源上下界最小费用流中有一条上下流都为 $f$ 的边。

但是在实际操作中我们其实是没有加的（因为根据有汇源上下界最大流的模型，这条边的流量为 $0$，加上去无意义），只是在最小费用的统计中算上。

但是，我们这条边又不一定全部用完，由于网络流的退回操作，我们可以建立一条 $(v,u,-w)$ 的边，上下界为 $0$ 和 $f$，执行退回操作。

对于正权边，类似，建立一条 $(u,v,w)$，上下界为 $0$ 和 $f$ 的边。

然后直接跑有汇源上下界最小费用流即可。

答案费用不要忘记了强制满流的费用。

注意，在第一次 SSP-EK 后的实际增加的流量并不是在算法内统计的，而是从 $T$ 到 $S$ 的流量。（这里的是题目给定的 $T,S$），但费用可以是因为虚拟汇源同图上点的连边费用都为  $0$。

代码：
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int rd(){
	int x=0,f=1; char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if (ch=='-') f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	return x*f;
}
const int N=250,M=10005,INF=0x3f3f3f3f3f3f3f3f;

int n,m,s,t,s1,t1;
struct node{
	int to,nt,flow,cost;
}a[(N+N+M)<<1];
int head[N],at=1;
void add(int u,int v,int flow,int cost){
	a[++at].nt=head[u],head[u]=at,a[at].to=v,a[at].flow=flow,a[at].cost=cost;
}
void Add(int u,int v,int flow,int cost){
	add(u,v,flow,cost);
	add(v,u,0,-cost);
}
bool vis[N];
int dis[N],incf[N],pre[N];
int in[N],out[N];
int ans,flow;
bool spfa(){
	memset(dis,0x3f,sizeof(dis));memset(vis,0,sizeof(vis));
	dis[s]=0,vis[s]=1,incf[s]=INF;
	queue<int> q;q.push(s);
	int u,v,w,flow;
	while(!q.empty()){
		u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=a[i].nt){
			v=a[i].to,flow=a[i].flow,w=a[i].cost;
			if(flow&&dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				incf[v]=min(incf[u],flow);
				pre[v]=i;
				if(!vis[v]) q.push(v),vis[v]=1;
			}
		}
	}
	return (dis[t]==INF)?0:1;
}
void EK(){
	while(spfa()){
		flow+=incf[t],ans+=incf[t]*dis[t];
		int u=t,i;
		while(u!=s){
			i=pre[u];
			a[i].flow-=incf[t],a[i^1].flow+=incf[t];
			u=a[i^1].to;
		}
	}
}
signed main(){
	n=rd(),m=rd(),s1=rd(),t1=rd();
	s=n+1,t=n+2;
	int u,v,f,w;
	for(int i=1;i<=m;i++){
		u=rd(),v=rd(),f=rd(),w=rd();
		if(!f) continue;
		if(w>=0) Add(u,v,f,w);
		else{
			Add(v,u,f,-w);
			ans+=w*f;
			out[u]+=f,in[v]+=f;
		}
	}
	for(int i=1;i<=n;i++){
		if(in[i]>out[i]) Add(s,i,in[i]-out[i],0); 
		if(in[i]<out[i]) Add(i,t,out[i]-in[i],0);
	}
	Add(t1,s1,INF,0);
	EK();
	flow=a[at].flow;
	head[s1]=a[head[s1]].nt,head[t1]=a[head[t1]].nt;
	s=s1,t=t1;
	EK();
	printf("%lld %lld\n",flow,ans);
	return 0;
}
```

---

## 作者：acb437 (赞：1)

# 题解：[P7173 有负权的费用流](https://www.luogu.com.cn/problem/P7173)
## 题意
题意简明，但是在这里特别指出：对于在环中（完全不从源点出发，也不会到达汇点，只是在环里循环）的流，它们的流量由于并不是从源点到汇点，所以是 **不算在最大流里** 的，但是它们的费用是 **算进最小费用中** 的。

## 思路简析
个人的理解是，有负环导致的问题是 SPFA 会陷在负环中出不来导致无法进行后续网络流的求解。所以先使所有负权边流满，这样就不会进入负环中了（也许效果是第一遍求完可行流后，所有负环中都会有一个顶满上界的流在环里循环，使得从 $s$ 出发的流都无法进入循环）。但是提前设置某些边的流量可能会导致网络的流量不平衡，所以参照上下界网络流的处理方式，将流量不平衡的点通过虚拟源点和虚拟汇点进行调整。

设 $d_u$ 表示 $u$ 的 $\text{入流流量}-{出流流量}$，$S$ 和 $T$ 为虚拟源汇点，（与上下界网络流）同样地（下面的边的费用均为 $0$）：
  1. 从原图汇点 $s$ 向原图源点 $t$ 连一条流量上界为 $\inf$ 的边，转为无源汇的情况。
  2. 若 $d_u<0$，入流过少，通过连接 $u\rightarrow T$ 引导 $u$ 的入流增加。
  3. 若 $d_u>0$，出流过少，通过连接 $S\rightarrow u$ 引导 $u$ 的出流增加。

然后求出 $S$ 到 $T$ 的最小费用可行流，费用全部加上这一步的答案，最大流加上这一步中 $t\rightarrow s$ 的边的流量，去掉附加边再跑一遍 $s$ 到 $t$ 的最小费用最大流，答案全部加上即可。
### 一些思考
下文中“可行流”指上下界网络流流程中第一次求 $S\rightarrow T$ 的最大流，“最大流”指第二次求 $s\rightarrow t$ 的最大流，最终答案的最大流则以 *最大流* 表示。
#### 1
与 [有源汇上下界网络流（模板）](https://www.luogu.com.cn/problem/P5192) 不同的是，第一次跑 $S$ 到 $T$ 的可行流时，本题不能直接算上可行流的流量，而是要单独取出 $t\rightarrow s$ 的边的流量。

我的分析是：模板题的一般建模中没有环的存在，唯一的环就是连接附加边 $t\rightarrow s$ 后产生的，所以第一次跑可行流时，所有的流量一定都会参与到 $s\rightarrow t$ 的流中，所以可以直接加上第一次跑可行流的答案，它的值和 $s\rightarrow t$ 的流量是一样的。但一旦出现了其它的环，这样做就是错的，因为第一遍跑可行流时可能有流量在环中循环，没有参与到 $s\rightarrow t$ 的流中。模板题的相当一部分题解是直接加上可行流的，我的写法也是这样，所以我在做这一题时因为这个问题调了很久。

#### 2
在因为上面的问题调代码的时候，又发现另一个问题：如果不清理附加边，并且不计算第一次跑可行流的答案（*最大流* 不算，费用是要算上的），只计算第二次跑最大流的答案，求出来的 *最大流* 是对的。经过测试，这一结论同样适用于模板题（这里说的附加边只包含 $t\rightarrow s$ 的边，其它和 $S$，$T$ 相连的附加边由于都是死路，都不会对答案造成影响，本来就可以不删）。

我的分析是：在绝大多数最大流 / 费用流的写法中，$t\rightarrow s$ 的附加边的正向边（即网络流建图中一条边的正向边和反向边中的正向边）视写法不同，因为不同的原因，并不会对求解造成影响，而这条边的反向边（同上，一条 $s\rightarrow t$ 的边）却会。

在求解最大流时，这条反向边一定会被流满，而它的流量上界恰好就是第一次求可行流时 $t\rightarrow s$ 的流量（由于是无源汇的含义下，这个值其实就是求可行流时 $s$ 到 $t$ 的流量之和），所以尽管求完可行流后，并没有加上可行流中 $s$ 到 $t$ 的流量，但跑最大流时，这个流量仍然通过上述方式被算到了 *最大流* 中，因此答案是对的。

**所以，在跑上下界网络流的第二遍求最大流时可以大胆地不去除附加边，只要确保第一遍求可行流时的流量不被算进 *最大流* 中即可**（如果你的写法允许的话。具体说来，大多数求网络最大流的 dinic 写法中，BFS 和 DFS 在碰到 $t$ 之后就会 `return`，肯定不会有影响；在最小费用最大流的 EK 写法和我用的这种看起来像是 dinic 改的写法中，SPFA 求最短路时不会走这条边权为 $0$ 的边）。

#### 3
注意本题只是提前设置负权边满流，而不是强制负权边满流，求最大流的过程中是可以退流的。这是和上下界网络流的区别，即本题的反向边的初始流量上界是原边的流量上界 $f$ 而不是上下界网络流的 $0$。
### 实现细节
如何提前设置负权边流满呢？一条边 $(u,v,w,c)$ 在网络流中流满的表现是流量上界变为 $0$，反向边的流量上界变为 $w$，所以在正确（即实际意义，流满了负权边的情况下）计算每个点的 $d$ 值和消耗的费用之后，直接连接 $(v,u,w,-c)$ 即可。当然你正常加边然后手动改边权也是可以的。
## 代码
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int N = 2e2 + 5, M = 2e4 + 5, INF = 1e9;
int n, m, s, t, s1, t1, s2, t2, ans1, ans2, d[N];

int idx = 1, h[N];
struct edge{int to, nxt, val, cst;}e[M << 1];
void addEdge(int u, int v, int w, int c)
{
	e[++idx] = (edge){v, h[u], w, c};
	h[u] = idx;
}
void addEdgeG(int u, int v, int w, int c){addEdge(u, v, w, c), addEdge(v, u, 0, -c);}

queue <int> q;
int dis[N], now[N];
bool vis[N], inQue[N];
bool SPFA()
{
	memset(dis, 0x3f, sizeof(dis));
	memset(vis, false, sizeof(vis));
	q.push(s), dis[s] = 0, now[s] = h[s], inQue[s] = true;
	while(!q.empty())
	{
		int u = q.front();
		q.pop(), inQue[u] = false;
		for(int i = h[u];i;i = e[i].nxt)
		{
			int v = e[i].to;
			if(!e[i].val || dis[v] <= dis[u] + e[i].cst)continue;
			dis[v] = dis[u] + e[i].cst, now[v] = h[v];
			if(!inQue[v])q.push(v), inQue[v] = true;
		}
	}
	return dis[t] ^ 0x3f3f3f3f;
}
int DFS(int u, int sum)
{
	if(u == t)return sum;
	int res = 0;vis[u] = true;
	for(int i = now[u];i && sum;i = e[i].nxt)
	{
		int v = e[i].to;
		if(vis[v] || !e[i].val || dis[v] != dis[u] + e[i].cst)continue;
		now[u] = i;int k = DFS(v, min(sum, e[i].val));
		e[i].val -= k, e[i ^ 1].val += k;
		sum -= k, res += k;
	}
	return res;
}
void dinic()
{
	while(SPFA())
	{
		int f = DFS(s, INF);
		ans1 += f, ans2 += f * dis[t];
	}
}

int main()
{
	scanf("%d%d%d%d", &n, &m, &s2, &t2), s1 = 0, t1 = n + 1;
	for(int i = 1, u, v, w, c;i <= m;i++)
	{
		scanf("%d%d%d%d", &u, &v, &w, &c);
		if(c >= 0)addEdgeG(u, v, w, c);
		else addEdgeG(v, u, w, -c), d[u] -= w, d[v] += w, ans2 += w * c;
	}
	for(int i = 1;i <= n;i++)
		if(d[i] > 0)addEdgeG(s1, i, d[i], 0);
		else if(d[i] < 0)addEdgeG(i, t1, -d[i], 0);
	addEdgeG(t2, s2, INF, 0), s = s1, t = t1, dinic();
	ans1 = 0, s = s2, t = t2, dinic();
	printf("%d %d\n", ans1, ans2);
	return 0;
}
```

---

## 作者：sangshang (赞：1)

# Description

给出一张有向图，求最小费用最大流。**费用可能为负。**

# Solution

如果费用为负，SSP 类算法在求最短路的时候就会因为负环卡死。因此可以这么想。

对于一条边 $(u,v,f,c)\in E$，$f$ 是容量，$c$ 是费用。如果 $c<0$，等于说流从这条边流过，不仅不花费，反而还盈利，那肯定是从这条边流得越多越好。因此我们预先让这种费用为负的边满流。但因为还要保持流量平衡，我们还需要设置一种机制，让预先流出去的流量可以退回来。

具体的，可以使用上下界网络流。对于新添的的一条边 $(u,v,f,c)$。如果费用为负，就先建一条 $u\to v$ 的上下界均为 $f$ 费用为 $c$ 的边，（因为上下界相同，这条费用为负的边本质并不在残量网络中，建边只是代表预先满流），再连一条 $v\to u$ 的下界为 $0$ 上界为 $f$ 费用为 $-c$ 的边，这条边流过多少就表示退回来多少流量。如果边权非负，就像费用非负的普通费用流，直接连一条 $u\to v$，下界为 $0$ 上界为 $f$ 费用为 $c$ 的边即可。

## 上下界网络流

先让边的下界满流，虚拟超级源汇 $S',T'$，再遍历每个点 $i$，如果推进来的流量多 $W_i,W_i>0$，连边 $(S',i,W_i,0)$；如果流量少 $W_i,W_i<0$，连边 $(i,T',-W_i,0)$。连一条边 $(T,S,+\infty,0)$。跑一遍用最小费用最大流，用以平衡流量。删掉边 $(T,S,+\infty,0)$，再跑一遍最小费用最大流，得到答案。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Dinic {
	public:
		typedef int TYPE;
		static const int maxn = 1e4, inf = 0x7f7f7f7f, maxm = inf;
		class edge {
			public:
				int to, rev;
				TYPE flow, cost;
				edge(int to, TYPE flow, TYPE cost, int rev): to(to), flow(flow), cost(cost), rev(rev) {}
				edge() {}
		};
		std::vector<edge>vec[maxn];
		TYPE MinCost, MaxFlow, dist[maxn], W[maxn];
		int cur[maxn], n, m, s, t;
		bool vis[maxn];
		Dinic(int n, int m, int s, int t): n(n), m(m), s(s), t(t),
			MinCost(0), MaxFlow(0), cur({0}), dist({0}), vis({false}) {}
		Dinic() {}
		inline void _Add_Edge_(int from, int to, TYPE flow, TYPE cost) {
			vec[from].push_back(edge(to, flow, cost, vec[to].size()));
			vec[to].push_back(edge(from, 0, -cost, vec[from].size() - 1));
		}
		inline void Add_Edge(int from, int to, TYPE flowL, TYPE flowR, TYPE cost) {
			W[from] -= flowL, W[to] += flowL;
			MinCost += flowL * cost;
			_Add_Edge_(from, to, flowR - flowL, cost);
		}
		inline bool SPFA() {
			std::memset(dist, inf, sizeof(dist));
			dist[t] = 0;
			std::memset(cur, 0, sizeof(cur));
			std::queue<int>que;
			for (que.push(t), vis[t] = true; !((bool)  que.empty());) {
				int u = que.front();
				vis[u] = false;
				que.pop();
				for (edge &e : vec[u]) {
					int v = e.to;
					if (vec[v][e.rev].flow && dist[u] + vec[v][e.rev].cost < dist[v]) {
						dist[v] = dist[u] + vec[v][e.rev].cost;
						if (!vis[v]) {
							que.push(v);
							vis[v] = true;
						}
					}
				}
			}
			return dist[s] != inf;
		}
		inline TYPE dfs(int u, TYPE flow) {
			if (u == t || !flow) {
				return flow;
			}
			vis[u] = true;
			TYPE res = 0;
			int sz = vec[u].size();
			for (int &i = cur[u]; i < sz && flow; ++i) {
				edge &e = vec[u][i];
				int v = e.to;
				if (e.flow && dist[u] == dist[v] + e.cost && !vis[v]) {
					TYPE Preflow = dfs(v, std::min(flow, e.flow));
					res += Preflow, flow -= Preflow, MinCost += Preflow * (e.cost);
					e.flow -= Preflow, vec[v][e.rev].flow += Preflow;
				}
			}
			vis[u] = false;
			return res;
		}
		inline TYPE Get_MaxFlow_MinCost() {
			MaxFlow = 0;
			while (SPFA()) {
				std::memset(vis, false, sizeof(vis));
				TYPE Preflow = dfs(s, inf);
				MaxFlow += Preflow;
			}
			return MaxFlow;
		}
		inline TYPE clac(int S, int T) {
			Add_Edge(T, S, 0, inf, 0);
			int PreS = n + 1, PreT = n + 2;
			this->s = PreS, this->t = PreT;
			TYPE sum = 0;
			for (int i = 0; i <= n; ++i) {
				if (W[i] > 0) {
					Add_Edge(PreS, i, 0, W[i], 0);
					sum += W[i];
				} else if (W[i] < 0) {
					Add_Edge(i, PreT, 0, -W[i], 0);
				}
			}
			if (Get_MaxFlow_MinCost() < sum) {
				return -1;
			} else {
				TYPE res = vec[S].back().flow;
				vec[S].pop_back();
				vec[T].pop_back();
				this->s = S, this->t = T;
				res = Get_MaxFlow_MinCost();
				return (MaxFlow = res);
			}
		}
		inline void Solve() {
			int N, M, S, T;
			scanf("%d%d%d%d", &N, &M, &S, &T);
			this[0] = Dinic(N, M, S, T);
			for (int i = 1; i <= M; ++i) {
				int u, v;
				TYPE flow, cost;
				scanf("%d%d%d%d", &u, &v, &flow, &cost);
				if (cost < 0) {
					W[u] -= flow, W[v] += flow;
					MinCost += cost * flow;
					Add_Edge(v, u, 0, flow, -cost);
				} else {
					Add_Edge(u, v, 0, flow, cost);
				}
			}
			clac(S, T);
			printf("%d %d\n", MaxFlow, MinCost);
		}
};
Dinic Main;

int main() {
	Main.Solve();
	return 0;
}
```


---

## 作者：Gold_Dino (赞：1)

首先考虑如果没有负环，就是一个最小费用最大流的板子。

如果原图没有负环，易证按最短路增广后也不会有负环。

现在增加了负环，目的要没有负环，这样就可以解决了。

随意考虑吧所有负边消掉：

对于一条费用为正的边，不对其进行特殊处理。

对于一条费用为负的边，将其流满，并累加每个点的总出流量 $c_{i}$，这样的话，正边费用为负，富于容量为 $0$，反边费用为正，富于容量为原本的容量。

继而原图就没有负环。

在考虑有些边已经流了一些流量，不满足流量平衡。

那么我们统计的 $c_{i}$，就有用了，如果为正，则表示出流量比如流量多，向新汇点建边，容量为 $c_{i}$，否则从新源点向它建边。

所以如果新图能满流，则必定原图有可行流。

从新源点导新汇点跑最小费用最大流，在从原图源点导汇点跑最小费用最大流。

需要注意的是，因为原图源点和汇点不需要满足流量平衡，所以第一次需要将源点和汇点并为一个点，在第二次时分开。

具体参见代码。
```cpp
# include <cstdio>
# include <algorithm>
# include <limits.h>
# include <cstring>

using std :: min;

int n, m, s, t;
int ans1, ans2;
struct { int v, rest, p, nxt; } e[ 30005 ]; int sc, tg, e_tot = 1, first[ 205 ], dis[ 205 ], que[ 200005 ], head, tail, pre[ 205 ], vis[ 205 ], f[ 205 ];

inline void add( int u, int v, int c, int p ) {
    e[ ++e_tot ] = { v, c, p, first[ u ] }, first[ u ] = e_tot;
    return;
}

inline void add_e( int u, int v, int c, int p ) { return add( u, v, c, p ), add( v, u, 0, -p ); }

inline bool spfa( int s, int t ) {
    memset( dis, 0x3f, sizeof( int ) * ( n + 2 ) ), memset( pre, 0, sizeof( int ) * ( n + 2 ) ), memset( vis, 0, sizeof( int ) * ( n + 2 ) ), dis[ que[ ( tail = head = 0 )++ ] = s ] = 0, vis[ s ] = 1;
    while( head != tail ) {
        int u = que[ head ];
        for( int i = first[ u ]; i; i = e[ i ].nxt ) {
            auto &x = e[ i ];
            if( x.rest && i <= e_tot && dis[ u ] + e[ i ].p < dis[ x.v ] ) {
                dis[ x.v ] = dis[ u ] + e[ i ].p, pre[ x.v ] = i;
                if( !vis[ x.v ] ) vis[ que[ tail ] = x.v ] = 1, ( tail += 1 ) %= ( 2 * n );
            }
        }
        vis[ u ] = 0, ( head += 1 ) %= ( 2 * n );
    }
    return dis[ t ] < 0x3f3f3f;
}

inline void fllow( int s, int t ) {
    while( spfa( s, t ) ) {
        int ret = INT_MAX, now = t;
        while( now != s ) {
            int p = pre[ now ]; auto &x = e[ p ];
            ret = min( x.rest, ret ), now = e[ p ^ 1 ].v;
        }
        now = t;
        while( now != s ) {
            int p = pre[ now ]; auto &x = e[ p ];
            x.rest -= ret, e[ p ^ 1 ].rest += ret, ans2 += ret * x.p, now = e[ p ^ 1 ].v;
        }
    }
    return;
}

int main( ) {
    int i;
    for( i = 1, scanf( "%d%d%d%d", &n, &m, &s, &t ), tg = n + 1; i <= m; i++ ) {
        int u, v, c, p;
        scanf( "%d%d%d%d", &u, &v, &c, &p );
        if( p > 0 ) add_e( u, v, c, p );
        else add( u, v, 0, p ), add( v, u, c, -p ), ans2 += c * p, f[ u ] += c, f[ v ] -= c;
    }
    int tet = e_tot;
    for( i = 1; i <= n; i++ )
        if( f[ i ] > 0 ) add_e( i, tg, f[ i ], 0 );
        else add_e( sc, i, -f[ i ], 0 );
    add( s, t, INT_MAX >> 1, 0 ), add( t, s, INT_MAX >> 1, 0 ), fllow( sc, tg ), e_tot = tet, fllow( s, t );
    for( i = 2, ans1; i <= e_tot; i += 2 ) {
        if( e[ i ].v == s ) ans1 -= e[ i ^ 1 ].rest;
        if( e[ i ^ 1 ].v == s ) ans1 += e[ i ^ 1 ].rest;
    }
    printf( "%d %d", ans1, ans2 );
    return 0;
}
```


---

## 作者：GordonWood (赞：1)

##### 本题解使用的是 `vector` 存图的 SPFA_Dinic。部分思想参考自 @[wql_cai](https://www.luogu.com.cn/user/551861) 巨佬的[题解](https://www.luogu.com.cn/blog/wangqianlong463/solution-p7173)，但加上了一些自己的理解。

### 题目简介：

费用流（废话）

有负圈（嗯？）

### 简要思路：

因为

> 注意存在费用为负的边和总费用为负的环。

> 注意，本题中允许一个不经过 $s,t$ 的环整体加上一个流量。

简单思考一下，要跑最小费用最大流，这个负环显然是会跑满的，所以我们可以先行手动处理每一个负环，将其满流。

但是，要是拿到一张图还得先去判断哪里是负环太烦了 ~~（指本蒟蒻不会判 qwq）~~。

网络流中有这么一句名言：

> 正难则反。

~~（虽然好像和这个没什么关系就是了）~~

所以我们可以考虑先将所有负权边全部强制满流，然后通过一些手段再将非负环上的边返回来。

那第一步就非常简单了，注意过程中别忘了先记下满流边造成的贡献 $mincost_1$。

```cpp
for (rint i = 1; i <= m; i++)
	{
		x = readint();
		y = readint();
		f = readint();
		c = readint();
		if (c < 0)
		{
			edge[x].push_back({y, 0, c, (int)edge[y].size()});
			edge[y].push_back({x, f, -c, (int)edge[x].size() - 1});
			mincost1 += f * c;
		}
		else
		{
			edge[x].push_back({y, f, c, (int)edge[y].size()});
			edge[y].push_back({x, 0, -c, (int)edge[x].size() - 1});
		}
	}
```

接下来我们要干的就是退还所有不应该满流的边的流量。

这里我们先设虚拟源点 $s'$ 和汇点 $t'$，然后对于每个点，统计其所有负权出边容量之和减去负权入边容量之和，记为 $tot_x$，如 $tot_x>0$，则说明这个点存在负权出边不应该满流，我们将这个点连向 $t'$，权值为 $tot_x$；反之则存在负权入边不应该满流，将 $s'$ 连向这个点，权值为 $-tot_x$。这时候我们再从 $s'$ 到 $t'$ 跑一遍费用流，得到的
 $minconst_2$ 就是应返还的费用，同时跑费用流的过程中将流量返还了。
 
 ```cpp
for (rint i = 1; i <= n; i++)
		if (tot[i])
		{
			if (tot[i] > 0)
			{
				edge[i].push_back({t, tot[i], 0, (int)edge[t].size()});
				edge[t].push_back({i, 0, 0, (int)edge[i].size() - 1});
			}
			else
			{
				edge[s].push_back({i, -tot[i], 0, (int)edge[i].size()});
				edge[i].push_back({s, 0, 0, (int)edge[s].size() - 1});
			}
		}
	while (SPFA())
		while (flow = dinic(s, INF))
			maxflow += flow;
```

这样我们就得到了一张正常的费用流的图，再跑一遍最小费用即可。

最后答案 $mincost=mincost_1-mincost_2+mincost_3$，
就是强制满流的贡献减去退还的贡献加上最后处理过负边的贡献。

代码如下：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define rint register int
#define INF 0x7f7f7f7f
using namespace std;
namespace IO
{
	inline int readint()
	{
		int x = 0, f = 1;
		char ch = getchar();
		while (!isdigit(ch) && ch != '-')
			ch = getchar();
		if (ch == '-')
		{
			f = -1;
			ch = getchar();
		}
		while (isdigit(ch))
		{
			x = x * 10 + ch - '0';
			ch = getchar();
		}
		return x * f;
	}
	inline ll readlong()
	{
		ll x = 0;
		int f = 1;
		char ch = getchar();
		while (!isdigit(ch) && ch != '-')
			ch = getchar();
		if (ch == '-')
		{
			f = -1;
			ch = getchar();
		}
		while (isdigit(ch))
		{
			x = x * 10 + ch - '0';
			ch = getchar();
		}
		return x * f;
	}
	inline void write(ll x)
	{
		if (x < 0)
		{
			putchar('-');
			write(-x);
			return;
		}
		if (x < 10)
		{
			putchar('0' + x);
			return;
		}
		write(x / 10);
		putchar('0' + x % 10);
	}
	inline void write_(ll x)
	{
		write(x);
		putchar(' ');
	}
	inline void writeln(ll x)
	{
		write(x);
		putchar('\n');
	}
}
using namespace IO;

const int MAXN = 40005;
int n, m, snode, tnode;
int x, y, f, c;
int s, t;
int mincost1, mincost;
int maxflow, flow;
int tot[MAXN];
int dis[MAXN];
int inque[MAXN];
int cur[MAXN]; 
struct node
{
	int to, val, cost, inv;
};
vector < node > edge[MAXN];

inline bool SPFA()
{
	queue < int > q;
	memset(dis, INF, sizeof(dis));
	memset(inque, 0, sizeof(inque));
	dis[s] = 0;
	q.push(s);
	cur[s] = 0;
	inque[s] = 1;
	while (!q.empty())
	{
		int x = q.front();
		q.pop();
		inque[x] = 0;
		for (rint i = 0; i < edge[x].size(); i++)
		{
			node y = edge[x][i];
			if (y.val && dis[y.to] > dis[x] + y.cost)
			{
				cur[y.to] = 0;
				dis[y.to] = dis[x] + y.cost;
				if (!inque[y.to])
				{
					inque[y.to] = 1;
					q.push(y.to);
				}
			}
		}
	}
	return (dis[t] != INF);
}

inline int dinic(int x, int flow)
{
	if (x == t)
		return flow;
	int rest = flow, k = 0;
	inque[x] = 1;
	for (rint i = cur[x]; i < edge[x].size(); i++)
	{
		cur[x] = i;
		node y = edge[x][i];
		if (rest && !inque[y.to] && y.val && dis[y.to] == dis[x] + y.cost)
		{
			k = dinic(y.to, min(rest, y.val));
			rest -= k;
			edge[x][i].val -= k;
			edge[y.to][y.inv].val += k;
			mincost1 += k * y.cost;
		}
	}
	inque[x] = 0;
	return flow - rest;
}

int main()
{
	n = readint();
	m = readint();
	snode = readint();
	tnode = readint();
	for (rint i = 1; i <= m; i++)
	{
		x = readint();
		y = readint();
		f = readint();
		c = readint();
		if (c < 0)
		{
			tot[x] += f;
			tot[y] -= f;
			edge[x].push_back({y, 0, c, (int)edge[y].size()});
			edge[y].push_back({x, f, -c, (int)edge[x].size() - 1});
			mincost1 += f * c;
		}
		else
		{
			edge[x].push_back({y, f, c, (int)edge[y].size()});
			edge[y].push_back({x, 0, -c, (int)edge[x].size() - 1});
		}
	}
	s = n + 1;
	t = n + 2;
	for (rint i = 1; i <= n; i++)
		if (tot[i])
		{
			if (tot[i] > 0)
			{
				edge[i].push_back({t, tot[i], 0, (int)edge[t].size()});
				edge[t].push_back({i, 0, 0, (int)edge[i].size() - 1});
			}
			else
			{
				edge[s].push_back({i, -tot[i], 0, (int)edge[i].size()});
				edge[i].push_back({s, 0, 0, (int)edge[s].size() - 1});
			}
		}
	mincost += mincost1;
	mincost1 = 0;
	while (SPFA())
		while (flow = dinic(s, INF))
			maxflow += flow;
	s = snode;
	t = tnode;
	mincost += mincost1;
	mincost1 = 0;
	maxflow = 0;
	while (SPFA())
		while (flow = dinic(s, INF))
			maxflow += flow;
	write_(maxflow);
	writeln(mincost + mincost1);
	system("pause");
	return 0;
}

```

---


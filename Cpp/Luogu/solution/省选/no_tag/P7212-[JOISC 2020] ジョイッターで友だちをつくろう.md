# [JOISC 2020] ジョイッターで友だちをつくろう

## 题目背景

Joitter 是一款交友软件。

## 题目描述

在 Joitter 你可以关注他人，但你不可以关注自己和关注他人两次，即如果关注他人多次只会算作一次。

共有 $N$ 名新用户，$M$ 天。

在第 $i$ 天，用户 $A_i$ 会关注用户 $B_i$。

同时在关注之后，会举办一场交友活动，活动内容如下：

1. 选择一个用户 $x$。
2. 选择一个被用户 $x$ 关注的用户 $y$。
3. 选择一个用户 $z$，要求 $z\not=x$，$x$ 未关注 $z$ 且 $y$ 和 $z$ 互关。
4. 让 $x$ 关注 $z$。
5. 重复 $1,2,3,4$，直到选不出合适的三元组 $(x,y,z)$。

您需要求出，对于每一个 $i$，第 $i$ 天过后的所有关注总数。

## 说明/提示

#### 子任务
对于 $100\%$ 的数据，保证 $2\le N\le 10^5$，$1\le M\le 3\times 10^5$，$1\le A_i,B_i\le N$，$A_i\not=B_i$，$(A_i,B_i)\not=(A_j,B_j)$。

| 子任务编号 | $N\le $ | 分值 |
|:-:|:-:|:-:
| $1$ | $50$ | $1$ |
| $2$ | $2\times 10^3$ | $16$ |
| $3$ | 无 | $83$ |

#### 说明
本题译自 [第 19 回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) Day 2 [T2 ジョイッターで友だちをつくろう](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day2/joitter2-en.pdf)。

## 样例 #1

### 输入

```
4 6
1 2
2 3
3 2
1 3
3 4
4 3```

### 输出

```
1
2
4
4
5
9```

## 样例 #2

### 输入

```
6 10
1 2
2 3
3 4
4 5
5 6
6 5
5 4
4 3
3 2
2 1```

### 输出

```
1
2
3
4
5
7
11
17
25
30```

# 题解

## 作者：周子衡 (赞：3)

考虑维护最后图中**极大团**，也就是所有的点集 $S$，满足对于 $S$ 中的任意两点 $u,v$，在举办活动后既有 $u\rightarrow v$ 的边，也有 $v\rightarrow u$ 的边。我们先来分析一下一个大小为 $s$ 的极大团给答案带来的贡献：

- 极大团内部有 $s(s-1)$ 条边；
- 对于每个向该团中连了至少一条边的团外的点，该点最后会和团中所有人连单向边。因而如果该团被 $k$ 个点连向，将会给答案带来 $sk$ 的贡献。注意：这里的 $k$ 是连向该团的不同点数，不是连向该团的团数。

我们考虑在加边过程中，用并查集维护每个极大团，并对每个极大团 $S$，动态维护集合：

- $\mathrm{IN}(S)$：向 $S$ 有连边的团的集合；
- $\mathrm{IP}(S)$：向 $S$ 有连边的点的集合；
- $\mathrm{OUT}(S)$：$S$ 连向的团的集合。

当每次加入边 $x\rightarrow y$ 时，设 $x$ 在团 $X$ 中，$y$ 在团 $Y$ 中，如果 $Y$ 之前向 $X$ 连过边，那么我们需要把 $X,Y$ 合并。为了确保时间复杂度，采用启发式合并的技巧。注意一次合并可能会引起其他的合并，使用队列来维护所有的合并即可。如果 $Y$ 之前未向 $X$ 连过边，我们简单地更新即可。注意要去掉集合中的重复元素，可以采用 `std::set` 实现。总时间复杂度 $O(m\log^2 m)$。

```cpp
#include<cstdio>
#include<set>
#include<queue>

using namespace std;

struct BCJ
{
	int fa[200000];
	void init(int n){for(int i=1;i<=n;i++)fa[i]=i;}
	int fnd(int x){return x==fa[x]?x:fa[x]=fnd(fa[x]);}
}B;

set<int> IN[200000],OUT[200000],IP[200000],S[200000];
queue<pair<int,int> > Q;

long long calc(int x){return (long long)(S[x].size()-1)*S[x].size()+(long long)IP[x].size()*S[x].size();}
long long ans;

typedef set<int>::iterator IT;

void merge(int x,int y)
{
	x=B.fnd(x),y=B.fnd(y);if(x==y)return;
	if(S[x].size()<S[y].size())swap(x,y);
	B.fa[y]=x;
	ans-=calc(x),ans-=calc(y);
	if(IN[x].count(y))IN[x].erase(y);
	if(OUT[x].count(y))OUT[x].erase(y);
	for(IT it=S[y].begin();it!=S[y].end();it++)
	{
		int u=*it;S[x].insert(u);
		if(IP[x].count(u))IP[x].erase(u);
	}
	for(IT it=IP[y].begin();it!=IP[y].end();it++)
	{
		int u=*it;if(!IP[x].count(u)&&!S[x].count(u))IP[x].insert(u);
	}
	for(IT it=IN[y].begin();it!=IN[y].end();it++)
	{
		int u=*it;if(u==x)continue;
		OUT[u].erase(y),OUT[u].insert(x);IN[x].insert(u);
		if(OUT[x].count(u))Q.push(make_pair(x,u));
	}
	for(IT it=OUT[y].begin();it!=OUT[y].end();it++)
	{
		int u=*it;if(u==x)continue;
		IN[u].erase(y),IN[u].insert(x);OUT[x].insert(u);
		if(IN[x].count(u))Q.push(make_pair(x,u));
	}
	ans+=calc(x);
}
void work()
{
	while(!Q.empty())
	{
		int x=Q.front().first,y=Q.front().second;Q.pop();
		merge(x,y);
	}
}

int main()
{
	int n=0,m=0;scanf("%d%d",&n,&m);B.init(n);
	for(int i=1;i<=n;i++)S[i].insert(i);
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0;scanf("%d%d",&x,&y);
		int fx=B.fnd(x),fy=B.fnd(y);if(fx==fy){printf("%lld\n",ans);continue;}
		if(IN[fx].count(fy))
		{
			Q.push(make_pair(fx,fy));work();
		}
		else
		{
			ans-=calc(fx),ans-=calc(fy);
			IN[fy].insert(fx),IP[fy].insert(x),OUT[fx].insert(fy);
			ans+=calc(fx),ans+=calc(fy);
		}
		printf("%lld\n",ans);
	}
}
```

---

## 作者：xht (赞：3)

并查集维护每个极大团即可。

如果某一次加边后，存在两个团之间可以互相到达，则需要合并这两个团。

用 `set` 维护每个团内的节点，点团之间的边，和团团之间的边，合并时启发式合并。

时间复杂度 $\mathcal O(n \log^2 n)$。

```cpp
const int N = 1e5 + 7;
int n, m, f[N];
set<int> s[N], e[N], g[N], fe[N], fg[N];
deque<int> X, Y;
ll ans;

int get(int x) {
	return x == f[x] ? x : (f[x] = get(f[x]));
}

inline void work(int x, int y) {
	int fx = get(x), fy = get(y);
	if (fx == fy) return;
	if (fe[fy].find(fx) == fe[fy].end()) {
		if (g[fy].find(x) == g[fy].end())
			ans += s[fy].size(),
			e[x].insert(fy), g[fy].insert(x),
			fe[fx].insert(fy), fg[fy].insert(fx);
		return;
	}
	ans -= 1ll * s[fx].size() * (s[fx].size() - 1);
	ans -= 1ll * s[fy].size() * (s[fy].size() - 1);
	fe[fy].erase(fx), fg[fx].erase(fy);
	if (s[fx].size() < s[fy].size()) swap(fx, fy);
	for (int i : s[fy]) {
		for (int j : e[i])
			ans -= s[j].size(),
			g[j].erase(i),
			X.pb(i), Y.pb(j);
		e[i].clear();
	}
	for (int i : g[fy])
		ans -= s[fy].size(),
		e[i].erase(fy),
		X.pb(i), Y.pb(fx);
	g[fy].clear();
	for (int i : fe[fy]) fg[i].erase(fy);
	for (int i : fg[fy]) fe[i].erase(fy);
	for (int i : s[fy]) s[fx].insert(i);
	f[fy] = fx;
	ans += 1ll * s[fx].size() * (s[fx].size() - 1);
	ans += 1ll * g[fx].size() * s[fy].size();
	s[fy].clear();
}

int main() {
	rd(n), rd(m);
	for (int i = 1; i <= n; i++) f[i] = i, s[i].insert(i);
	for (int i = 1, x, y; i <= m; i++) {
		rd(x), rd(y), X.pb(x), Y.pb(y);
		while (X.size()) work(X[0], Y[0]), X.pop_front(), Y.pop_front();
		print(ans);
	}
	return 0;
}
```

---

## 作者：Purslane (赞：2)

#  Solution

NOIP 模拟赛第二题。当时以为是绿题自己都做不出来很沮丧，后来乱搞竟然是正解。（然后 T1 喜提 35 分。）

首先，这是计数题而不是最优化题，选择三元组的顺序与答案无关。

然后发掘题目性质。观察到，如果 $y$ 和 $z$ 是互相关注的，所有和 $y$ 有边与所有和 $z$ 有边的点都相当于和 $y$ 与 $z$ 都有边，因此可以把 $yz$ 当做一个联通块里面的点。而且如果 $x$ 和 $y$ 互相关注，$y$ 和 $z$ 互相关注，那么效果上等价于 $x$ 和 $z$ 互相关注。

那么你只需要维护所有的互相关注的点的集合。先考虑答案怎么计算。联通块内的点肯定两两互相关注，其他如果点 $u$ 向联通块 $S$ 有至少一条连边，那么对答案产生 $size_S$ 的贡献。（多条只能算一条。）以下小写字母表示节点,大写字母表示联通块。于是你注意到，产生贡献的边实际上是点指向联通块的，这意味着你合并两个联通块，它们中的点指向外部联通块的边不必更改。

然后考虑如果联通块 $S$ 已经存在指向 $T$ 的边，那么再有 $T$ 指向 $S$ 的边，那么可以将 $S$ 和 $T$ 合并。你需要更改的是所有 $S$ 中的点向 $T$ 的连边的贡献（将其删除），再加上 $S$ 中的点和 $T$ 中的点两两间的贡献。你还需要加上的是只连向 $S$ 的点对 $T$ 的贡献，以及只连向 $T$ 的点对 $S$ 的贡献。

然后你发现你需要维护点指向联通块的边，前者的反图；联通块指向联通块的边（不仅要记录是否存在还要记录数量），前者的反图；每个联通块的节点集合。这个使用启发式合并可以在 $O(\log^2 n)$ 的复杂度内快速解决。

细节巨多，但是需要自行思考。如果细节挂了可以在博客底下评论。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,m,fa[MAXN],sze[MAXN],ans; vector<int> idx[MAXN];
set<int> tv[MAXN],iv[MAXN];
map<int,int> tb[MAXN],ib[MAXN];
//Two kinds of Edges:original vertex -> blocks & blocks -> blocks
//Every time we add an edge,if the anti-order edge exists,we can merge the two blocks
//First we should consider changing the answer between the two blocks
//We are supposed to minus the answer from A to B and add szeA*szeB*2
//Then consider merging the blocks.Using qifashihebing,we add the smaller one into the bigger one
//Consider the outer edge. vertex->blocks don't change at all,but we should change the number of edge blocks->blocks
//Consider the iner edge. We should know how many appear in both blocks(0) and how many appear in exactly A or B,which will add the size of the other block
//Thus we should record v->b and b<-v (1) but it's easy to change,and don't have anything to do with the number of edges.

//Then consider the edge between blocks. Since we should minus the the current answer,the number of edges is important.
//Consider the outer edge,simply add them together. Consider the inner edge. Since a vertex may link to both blocks,but now it's useless.After add two blocks together we should minus the situation (0) above.
//use long long and set(first) and map(second,to distinguish the difference)
//Also,we should iterate other blocks so that we can deal with new mergings.
int find(int k) {return (fa[k]==k)?k:(fa[k]=find(fa[k]));}
int merge(int u,int v) {
	int U=find(u),V=find(v); if(U==V) return U;
	int uv=0,vu=0;
	if(tb[V].count(U)) ans-=sze[U]*tb[V][U],vu=tb[V][U],tb[V].erase(U),ib[U].erase(V);
	if(tb[U].count(V)) ans-=sze[V]*tb[U][V],uv=tb[U][V],tb[U].erase(V),ib[V].erase(U);
	ans+=2*sze[U]*sze[V]; //cout<<"DEBUG:"<<ans<<'\n';
	if(sze[U]<sze[V]) swap(U,V),swap(uv,vu);
	int cnt1=0,cnt2=0,cnt3=0; //cnt1:only U cnt2:both U&V cnt3:only V
	for(auto id:iv[V]) {
		if(tv[id].find(U)!=tv[id].end()) cnt2++; else cnt3++;
	}
	cnt1=iv[U].size()-cnt2-vu,cnt3-=uv;
	ans+=cnt1*sze[V]+cnt3*sze[U]; //cout<<"DEBUG"<<U<<' '<<V<<' '<<uv<<' '<<vu<<' '<<cnt1<<' '<<cnt2<<' '<<cnt3<<'\n';
	for(auto id:iv[V]) {
		if(tv[id].find(U)==tv[id].end()) {tv[id].erase(V);if(find(id)!=U) tv[id].insert(U),iv[U].insert(id);}
		else tb[find(id)][U]--,ib[U][find(id)]--,tv[id].erase(V);
	}
	for(auto v:idx[V]) if(tv[v].count(U)) tv[v].erase(U),iv[U].erase(v);
	for(auto v:idx[V]) idx[U].push_back(v); idx[V].clear();
	vector<int> nxt;
	iv[V].clear();
	for(auto pr:tb[V]) {
		int to=pr.first,cnt=pr.second;
		tb[U][to]+=cnt,ib[to][U]+=cnt,ib[to].erase(V);
		if(tb[to].count(U)) nxt.push_back(to);
	}
	for(auto pr:ib[V]) {
		int frm=pr.first,cnt=pr.second;
		tb[frm][U]+=cnt,ib[U][frm]+=cnt,tb[frm].erase(V);
		if(tb[U].count(frm)) nxt.push_back(frm);
	}
	tb[V].clear(),ib[V].clear(),iv[V].clear();
	fa[V]=U,sze[U]+=sze[V];
	for(auto id:nxt) U=merge(U,id);
	return U;
}
signed main() {
//	freopen("friends.in","r",stdin);
//	freopen("friends.out","w",stdout);
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) fa[i]=i,sze[i]=1,idx[i].push_back(i);
	ffor(i,1,m) {
		int u,v; cin>>u>>v;
		if(find(u)==find(v)) {cout<<ans<<'\n';continue;}
		if(tb[find(v)].count(find(u))) merge(u,v);
		else if(tv[u].find(find(v))==tv[u].end()) tv[u].insert(find(v)),iv[find(v)].insert(u),tb[find(u)][find(v)]++,ib[find(v)][find(u)]++,ans+=sze[find(v)];
		cout<<ans<<'\n';
	}
	return 0;
}
```


---

## 作者：LiQXing (赞：1)


比较显然的结论:

$a\Longleftrightarrow b,b\Longleftrightarrow c$，则 $a\Longleftrightarrow c$。

看一眼数据范围，肯定不能每条边都一一加上，肯定会超时。

观察，每个连通块的贡献都为 $size[x]\times(size[x]-1)$。

想到只维护连通块之间的边。

手动模拟加边情况：

加入边 $[u,v]$，如果这条边在同一个联通图，跳过。

如果 $u$ 有一条连向 $v$ 所在连通图的边，那么 $u$ 一定已经连向了 $v$ 本身，跳过。

再判断有无一条边可以从 $v$ 所在的连通图连向 $u$ 所在的连通图。

如果 $v$ 所在的连通图不能够连向 $u$ 所在的连通图，就直接记录这条边，然后答案加上 $v$ 连通块的大小。

如果能够连向，那么这两个连通块都可以合并成一个。

那么把答案中的两个连通块去掉，合并之后再加上。

把 $v$ 所在的连通图合并在 $u$ 所在的联通图上。

$v$ 连通图伸出和射入的边去掉，然后全连在 $u$ 的图上，bfs 循环加边，最后再统计答案。


```cpp

inline int clac(int u){
    return siz[u]*(siz[u]-1)+in[u].size()*siz[u];
}
inline void merge(int xx,int yy){
    queue<pii>q;
    q.push({xx,yy});
    while(q.size()){
        pii u=q.front();q.pop();
        int x=u.first,y=u.second;
        int fux=find(x),fuy=find(y);
        if(fux==fuy||in[fuy].count(x))continue;
        auto it=out[fuy].lower_bound({fux,0});
        if(it==out[fuy].end()||it->first!=fux){
            in[fuy].insert(x);
            out[fux].insert({fuy,x});
            ans+=siz[fuy];
            continue;
        }
        ans-=clac(fux)+clac(fuy);
        for(auto t:out[fuy]){
            int tx=t.first,ty=t.second;
            in[tx].erase(ty);
            if(tx==fux)continue;
            q.push({ty,tx});
            ans-=siz[tx];
        }
        for(auto t:in[fuy]){
            int ft=find(t);
            out[ft].erase({fuy,t});
            if(ft!=fux)q.push({t,fux});
        }
        fa[fuy]=fux;siz[fux]+=siz[fuy];
        ans+=clac(fux);
        in[fuy].clear();
        out[fuy].clear();
    }
}
```

然而，会超时。

考虑优化，想到启发式合并。

```cpp
	if(in[fux].size()+out[fux].size()<in[fuy].size()+out[fuy].size()){
            swap(fux,fuy);
            swap(x,y);
        }
```
时间复杂度变为 $O(n\log^2n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define ull unsigned long long
#define i128 __int128
#define ldo long double
#define dle double
#define up(a,b,c) for(int a=b;a<=c;a++)
#define dn(a,b,c) for(int a=b;a>=c;a--)
#define pii pair<int,int>
#define lc k<<1
#define rc k<<1|1

const int N=1e6+7;
const int mod=59027;

namespace IO{
    inline int read(){
        char c=getchar();int x=0,fh=0;
        while(c<'0'||c>'9'){fh|=c=='-';c=getchar();}
        while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
        return fh?-x:x;
    }
    inline void wt(int x){
        if(x<0){x=-x;putchar('-');}
        if(x>9)wt(x/10);
        putchar((x%10)^48);
    }
    inline void write(int x,bool op){
        wt(x);
        putchar(op?'\n':' ');
    }
}using namespace IO;
int fa[N];
inline int find(int x){
    if(x==fa[x])return x;
    return fa[x]=find(fa[x]);
}
set<int>in[N];
set<pii>out[N];
int n,m,siz[N];
int ans;
inline int clac(int u){
    return siz[u]*(siz[u]-1)+in[u].size()*siz[u];
}
inline void merge(int xx,int yy){
    queue<pii>q;
    q.push({xx,yy});
    while(q.size()){
        pii u=q.front();q.pop();
        int x=u.first,y=u.second;
        int fux=find(x),fuy=find(y);
        if(fux==fuy||in[fuy].count(x))continue;
        auto it=out[fuy].lower_bound({fux,0});
        if(it==out[fuy].end()||it->first!=fux){
            in[fuy].insert(x);
            out[fux].insert({fuy,x});
            ans+=siz[fuy];
            continue;
        }
        if(in[fux].size()+out[fux].size()<in[fuy].size()+out[fuy].size()){
            swap(fux,fuy);
            swap(x,y);
        }
        ans-=clac(fux)+clac(fuy);
        for(auto t:out[fuy]){
            int tx=t.first,ty=t.second;
            in[tx].erase(ty);
            if(tx==fux)continue;
            q.push({ty,tx});
            ans-=siz[tx];
        }
        for(auto t:in[fuy]){
            int ft=find(t);
            out[ft].erase({fuy,t});
            if(ft!=fux)q.push({t,fux});
        }
        fa[fuy]=fux;siz[fux]+=siz[fuy];
        ans+=clac(fux);
        in[fuy].clear();
        out[fuy].clear();
    }
}
signed main(){
    int u,v;
    n=read();m=read();
    up(i,1,n)fa[i]=i,siz[i]=1;
    up(i,1,m){
        u=read();v=read();
        merge(u,v);
        write(ans,1);
    }
    return 0;
}

```









---

## 作者：7KByte (赞：1)

关于我读错题调了一个小时这档事，这个关注操作不具有传递性，也就是说如果 $x$ 关注 $y$ ，$x$ 所在强连通分量的人不用关注 $y$ 。。。

题意比较简单，转化一下，给定 $N$ 个点，支持加边，维护强连通分量，每个分量的贡献为 $size^2-size$ ，对于缩点后每条边的贡献为终点所在强连通分量的 $size$ 。再次强调只计算终点的 $size$ ，笔者因为看成两端 $size$ 乘积调了一年。

转化完后你会发现，这这题怎么这么熟悉，[**[WC2021]括号路径**](https://www.luogu.com.cn/problem/P7323)是这道题的弱化版，只用维护 $size^2$ 即可。

所以我们开 ``set`` 维护分别维护每一个强连通分量中的点，连向当前分量的其他分量，当前分量出发到达的其他分量，和到达当前分量且不在当前分量中的点。

合并的时候可能会引起多个后续合并，所以我们再用队列维护一下需要合并的点对即可。

时间复杂度 $\mathcal{O}(M\log M\log N)$ 。这道题做的人还是少，做过这题参加 WC2021 可收获巨大 BUFF。

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 100005
using namespace std;
int n, m, col[N];
long long ans;
set<int>s[N], in[N], out[N], ed[N];
queue<pair<int, int>>q;
typedef set<int>::iterator ite;
long long g(int x) {
    return 1LL * s[x].size() * (s[x].size() - 1 + ed[x].size());
}
void merge(int u, int v) {
    q.push(make_pair(u, v));

    while (!q.empty()) {
        int x = col[q.front().first], y = col[q.front().second];
        q.pop();

        //cout<<"ss "<<x<<" "<<y<<endl;
        if (x == y)
            continue;

        if (s[x].size() > s[y].size())
            swap(x, y);

        ans -= g(x) + g(y);

        if (in[x].find(y) != in[x].end())
            in[x].erase(y), out[y].erase(x);

        if (in[y].find(x) != in[y].end())
            in[y].erase(x), out[x].erase(y);

        for (ite it = s[x].begin(); it != s[x].end(); it++) {
            col[*it] = y, s[y].insert(*it);
            ite cur = ed[y].find(*it);

            if (cur != ed[y].end())
                ed[y].erase(cur);
        }

        for (ite it = in[x].begin(); it != in[x].end(); it++) {
            out[*it].erase(x);
            out[*it].insert(y);

            if (out[y].find(*it) != out[y].end())
                q.push(make_pair(*it, y));
            else
                in[y].insert(*it);
        }

        for (ite it = out[x].begin(); it != out[x].end(); it++) {
            in[*it].erase(x);
            in[*it].insert(y);

            if (in[y].find(*it) != in[y].end())
                q.push(make_pair(*it, y));
            else
                out[y].insert(*it);
        }

        for (ite it = ed[x].begin(); it != ed[x].end(); it++)
            if (col[*it] != y)
                ed[y].insert(*it);

        ans += g(y);
    }
}
void ins(int x, int y) {
	int w = x;
    x = col[x];
    y = col[y];

    if (x == y)
        return;

    if (in[x].find(y) != in[x].end())
        merge(x, y);
    else in[y].insert(x), out[x].insert(y), ans -= g(y) , ed[y].insert(w), ans += g(y);
}
int main() {
    scanf("%d%d", &n, &m);
    rep(i, 1, n)col[i] = i, s[i].insert(i);
    rep(i, 1, m) {
        int x, y;
        scanf("%d%d", &x, &y);
        ins(x, y);
        printf("%lld\n", ans);
    }
    return 0;
}
```





---

## 作者：nullqtr_pwp (赞：1)

JOISC2020 D2T2 Solution

考虑建图，$u$ 关注 $v$ 写成有向图 $u\to v$。

**首先考虑操作的性质。** 显然一次操作不会改变二元环 $(y,z)$ 的任何信息，只会让 $x\to y$ 和 $y\to z$ 的边都存在。考虑对于 $x$ 操作能进行下去的条件，就是 $x\to y$ 或者 $y\to z$ 可以被继续拓展，那么就是存在一个 $l$ 使得 $(y,l)$ 是二元环或者 $(z,l)$ 是二元环，都会建立边 $y\to l$。再想进行下去，必须有点 $t$ 和 $y,z,l$ 中至少一者有二元环，然后建立边 $x\to t$。与此同时，$y,z,l$ 也可以被操作拓展成两两之间都有二元环。

**由此可以想到若干二元环联通的情况。** 考虑一条链，两两之间的点都被二元环连接，那么这个二元环内部所有点之间都可以被操作成有二元环连接，此时设这些点为 $a_1,a_2,\cdots ,a_k$，那么 $\forall 1\leq i\leq j\leq n$，边 $i\to j,j\to i$ 都会存在。此时**形成一个团。** 假设有一个点 $x$，不妨设与 $a_1$ 有连边，那么根据第一段的叙述，接下来会与 $a_2,a_3,\cdots ,a_k$ 都有连边。因此，对于同一个团，只要有一个点连了进来，就会拓展到所有点。所以可以对同一个团一起维护连进来的点。

边分为两种，连接同一个团中两个点的边，以及连接不同团两个点的边。第一种的维护是容易的。

此时考虑加边 $(u,v)$，除了更新一个团的答案外，还很可能会合并两个团，**合并两个团的过程，可以用并查集维护。** 二元环关系是无向并且不带撤销的。所以，直接维护所有极大团并查集即可。不仅需要维护 $S_u,\text{inpoints}_u$ 分别表示 $u$ 极大团的具体点以及此团连进来的**点**集，还需要维护额外两个集合表示，团 $u$ 连了哪些**团**，团 $u$ 被哪些**团**连了。这个是必须有方向的，因为一条边的对边存在时，就会形成二元环，此时会合并两个团。

实现细节较多，可以用 ```std::set``` 以及启发式合并维护。时间复杂度 $O(n\log n)$。

[提交记录](https://loj.ac/s/2000513)

---


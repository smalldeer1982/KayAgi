# [COCI 2019/2020 #4] Klasika

## 题目描述

开始时，你有一个编号为 $1$ 的节点，它代表着一棵树的根。你的任务是对树进行 $Q$ 次操作。

操作分为两类：

- $\texttt{Add x y}$，给树上编号为 $x$ 的节点加入一个儿子，该儿子的编号为加入该节点后树的大小，它与 $x$ 的边的边权为 $y$。
- $\texttt{Query a b}$，查找从 $a$ 出发，到 $b$ 节点子树内某个节点（包括 $B$ ）的路径中边权异或和最大的一条，并输出其异或和。

## 说明/提示

【数据规模与约定】

| 子任务编号 | 特殊限制                                   | 分值 |
| ---------- | ------------------------------------------ | ---- |
| $1$        | $Q\le 200$                                 | $10$ |
| $2$        | $Q\le 2\times 10^3$                        | $20$ |
| $3$        | 对于所有 $\texttt{Query}$ 操作，保证 $b=1$ | $30$ |
| $4$        | 无特殊限制                                 | $40$ |

对于 $100\%$ 的数据，$1\le Q\le 2\times 10^5$，$0\le y\le 2^{30}$，保证 $x,a,b$ 小于等于当前树的大小。

【提示与帮助】

**题目译自 [COCI 2019/2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #4](https://hsin.hr/coci/archive/2019_2020/contest4_tasks.pdf) T4 Klasika**

在 COCI 中，本题分值为 $110$ 分。

## 样例 #1

### 输入

```
4
Add 1 5
Query 1 1
Add 1 7
Query 1 1```

### 输出

```
5
7```

## 样例 #2

### 输入

```
6
Add 1 5
Add 2 7
Add 1 4
Add 4 3
Query 1 1
Query 2 4```

### 输出

```
7
2```

## 样例 #3

### 输入

```
10
Add 1 4
Add 1 9
Add 1 10
Add 2 2
Add 3 3
Add 4 4
Query 4 2
Query 1 3
Add 6 7
Query 1 3```

### 输出

```
14
10
13```

# 题解

## 作者：硫酸 (赞：11)

update on 11.6

添加了解法二，并修改了解法一的小部分内容。

------------

# 解法一

算是对 @[MuelsyseU](https://www.luogu.com.cn/user/62440) 的做法的补充吧。

先是一个比较套路的转化：记点 $u$ 到根的异或路径为 $dis_u$，则 $a,b$ 间的异或路径就是 $dis_a \oplus dis_b$，那么 `Query u v` 的答案就是 $\max\limits_{x \in subtree_v } \{ dis_u \oplus dis_x\}$。

如果对于一个点 $v$，将它子树内所有点的 $dis$ 放到一棵 01-trie 上。询问时在 01-trie 从根向叶子走，对于每一位尽可能往 $dis_u$ 相反的方向上走就行了。这一部分也可以参考 [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)。

问题在于怎么求出每个点的 01-trie 。

考虑树上启发式合并。对于点 $u$，先处理掉所有儿子的 01-trie ，再将重儿子的 01-trie 直接转移到点 $u$ 上，然后把所有轻儿子的 01-trie 合并到 $u$ 上面。

关于复杂度，只有当一个点是轻儿子才会合并。而一条链最多包含 $\log n$ 条重链，于是每个数最多只会添加（包括合并次数）到 01-trie 里 $\log n$ 次，$n$ 个点就是 $n\log n$ 次。每次查询只要在 01-trie 里从根到叶子走一次，也是 $\log n$。

总复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	template<typename T>inline void read(T &x)
	{
		x=0;int y=1;
		char c=getchar();
		while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}
		while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
		x*=y;
		return;
	}
	template<typename T>inline void write(T x)
	{
		if(x<0){putchar('-');x=-x;}
		if(x>9) write(x/10);
		putchar(x%10 + '0');
		return;
	}
}
using namespace IO;
#define writeln(x) write(x),putchar('\n')
#define writesp(x) write(x),putchar(' ')
#define debug printf("Now is on line %d\n",__LINE__)
const int N=2e5+5;
int n=1,Q,tot=0,ans,fa[N],a[N],rt[N],siz[N],hson[N];//rt为每个点上01-trie的根，hson为重儿子
struct Que{int u,v,tim,ans;}inp[N];//离线操作
struct dot{int tim,son[2];}f[N*30];//01-trie
vector<int> w[N],que[N];//w存图，que存每个节点上的询问
int New(int tim)
{
	++tot;f[tot].tim=tim;f[tot].son[0]=0;f[tot].son[1]=0;
	return tot;
}
void add(int id,int x,int dep,int tim)//向01-trie里加入一个数
{
	f[id].tim=min(f[id].tim,tim);
	if(dep<0) return;
	int op=((x>>dep)&1);
	if(!f[id].son[op]) f[id].son[op]=New(tim);
	add(f[id].son[op],x,dep-1,tim);
	return;
}
void merge(int id,int id2,int dep)//合并两个01-trie
{
	if(!id2) return;
	f[id].tim=min(f[id].tim,f[id2].tim);
	if(dep<0) return;
	if(!f[id].son[0]) f[id].son[0]=f[id2].son[0];
	else merge(f[id].son[0],f[id2].son[0],dep-1);
	if(!f[id].son[1]) f[id].son[1]=f[id2].son[1];
	else merge(f[id].son[1],f[id2].son[1],dep-1);
	return;
}
void query(int id,int x,int dep,int tim)//在01-trie里查询
{
	int op=(((x>>dep)&1)^1);//找到数字x第dep位，取反（尽可能往相反方向走）
	if(!f[id].son[op] || f[f[id].son[op]].tim>tim) op^=1;
	ans|=(op<<dep);
	if(dep) query(f[id].son[op],x,dep-1,tim);
	return;
}
void dfs(int id)
{
	siz[id]=1;hson[id]=0;
	for(int to : w[id])
	{
		dfs(to);
		siz[id]+=siz[to];
		if(siz[hson[id]]<siz[to]) hson[id]=to;
	}
	if(hson[id]) swap(rt[id],rt[hson[id]]);//将重儿子（如果有）的01-trie直接转移到当前点
	for(int to : w[id]) merge(rt[id],rt[to],30);//合并其他轻儿子
	for(int i : que[id])
	{
		ans=0;query(rt[id],a[inp[i].u],30,i);
		inp[i].ans=(ans^a[inp[i].u]);
	}
	return;
}
signed main()
{
	int u,v;
	char cc[10];
	rt[1]=New(0);add(rt[1],0,30,0);//细节：初始要在1节点插入一个0，实际意义为走到1节点
	read(Q);
	for(int i=1;i<=Q;++i)
	{
		scanf("%s",cc);read(u);read(v);
		if(cc[0]=='A')
		{
			++n;
			a[n]=(a[u]^v);
			fa[n]=u;
			w[u].emplace_back(n);
			rt[n]=New(i);
			add(rt[n],a[n],30,i);
		}
		else
		{
			inp[i]=Que{u,v,i,0};
			que[v].emplace_back(i);
		}
	}
	dfs(1);
	for(int i=1;i<=Q;++i) if(inp[i].tim) writeln(inp[i].ans);
	return 0;
}
```
# 解法二

来自 @[gty314159](https://www.luogu.com.cn/user/768612) ，已在线下得到其授权。

依然离线，求出 dfs 序，将子树上的查询转化为区间查询。

先开一个数组 $d$，$d_i$ 表示 $dfn_u=i$ 的节点 $u$ 的 $dis_u$。（$dis$ 定义同上）。初始 $d_i=0$，按照操作顺序加入、查询。这样当一个点未加入时，查询到它等价于查询到子树的根，不影响。

然后用树套树维护这个数组 $d$。树状数组套 01-trie，树状数组上第 $i$ 个 01-tire 上存储 $d_1\thicksim d_i$。其中 01-trie 每个节点还要记录这一位出现的次数 $siz$。

查询时，对于 $d_l\thicksim d_r$ ，记第 $r$ 棵 01-tire 和第 $l-1$ 棵“作差”。由于第 $r$ 棵一定是包含第 $l-1$ 棵的，于是将第 $r$ 棵每个节点的 $siz$ 与第 $l-1$ 棵作差，如果为零就是这个点在 $d_l\thicksim d_r$ 中不存在。

作差后得到 $d_l\thicksim d_r$ 的 01-trie ，按解法一中的查询，从根节点走一次就行了。

但是空间很紧，树状数组勉强能在 400MB 混过去，线段树会炸。

代码不是一个人写的，码风不同。
```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int i = (a); i <= (b); ++i)
#define dF(i, a, b) for(int i = (a); i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const int N = 2e5 + 5;
const int K = 30;

int n = 1, m, dis[N];
vector<int> e[N];
void Addedge(int u, int v) {
    e[u].push_back(v);
    return ;
}

int cnt, dfn[N], siz[N];
void Dfs(int u) {
    dfn[u] = ++cnt;
    siz[u] = 1;
    for (auto v : e[u])
        Dfs(v), siz[u] += siz[v];
    return ;
}

int tot, rt[N], s[K + 5];
struct Trie { int s[2], siz; } t[N * 200];
void Init(int k) {
    dF(i, K, 1) s[i] = k & 1, k >>= 1;
    return ;
}
void Update(int x, int &rt) {
    Init(x);
    if (!rt) rt = ++tot;
    int u = rt;
    F(i, 1, K) {
        ++t[u].siz;
        if (!t[u].s[s[i]])
            t[u].s[s[i]] = ++tot;
        u = t[u].s[s[i]];
    }
    ++t[u].siz;
    return ;
}

int lowbit(int x) { return x & -x; }
void Update(int x) {
    for (int i = dfn[x]; i <= n; i += lowbit(i))
        Update(dis[x], rt[i]);
    return ;
}
int numl, invl[K], numr, invr[K];
void Init(int l, int r) {
    numl = numr = 0;
    for (int i = r; i; i -= lowbit(i))
        invr[++numr] = rt[i];
    for (int i = l - 1; i; i -= lowbit(i))
        invl[++numl] = rt[i];
    return ;
}
int Query(int l, int r, int x) {
    Init(l, r);
    Init(x);
    int res = 0;
    F(i, 1, K) {
        res <<= 1;
        int sum = 0;//这里把01-trie作差与查询放在一个函数里了
        F(j, 1, numr) sum += t[t[invr[j]].s[s[i] ^ 1]].siz;
        F(j, 1, numl) sum -= t[t[invl[j]].s[s[i] ^ 1]].siz;
        if (sum) {
            res ^= 1;
            F(j, 1, numr) invr[j] = t[invr[j]].s[s[i] ^ 1];
            F(j, 1, numl) invl[j] = t[invl[j]].s[s[i] ^ 1];
        } else {
            F(j, 1, numr) invr[j] = t[invr[j]].s[s[i]];
            F(j, 1, numl) invl[j] = t[invl[j]].s[s[i]];
        }
    }
    return res;
}

string op[N];
int x[N], y[N];

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> m;
    F(i, 1, m) {
        cin >> op[i] >> x[i] >> y[i];
        if (op[i] == "Add")
            Addedge(x[i], ++n),
            dis[n] = dis[x[i]] ^ y[i];
    }
    Dfs(1);
    Update(1);
    int now = 1;
    F(i, 1, m)
        if (op[i] == "Add") Update(++now);
        else cout << Query(dfn[y[i]], dfn[y[i]] + siz[y[i]] - 1, dis[x[i]]) << "\n";
    return 0;
}
```

---

## 作者：F_Alnorie (赞：4)

## 题目分析
约定树节点数量为 $n$。

由于在线做法维护信息较为困难，因此使用离线做法，先将树建出来再依次处理操作。

考虑如何维护两点间的异或路径和。

比较套路的方法是维护每个点 $i$ 到根的异或路径和 $dis_i$，那么点 $a$ 到点 $b$ 的异或路径和即为 $dis_a \operatorname{xor} dis_b$。

这样，Query 操作就变为询问 $\max \{ dis[a] \operatorname{xor} dis[c] ,c\in \text{b子树} \}$。但是如果暴力遍历子树，单次的查询复杂度就为 $O(n)$，难以通过此题。

如果使用 dfs 序，询问就变成了区间查询异或最大值，这可以通过 01Trie 树解决，单次查询时间复杂度降为 $O(31)$，其中 $31$ 是数字二进制下的最长长度。

然而肯定不可以对于每个区间都建立一颗 01Trie 树，现在的问题即为如何维护 01Trie 树下标。

~~我会树套树！~~ 树套树虽然时间复杂度较小，但空间开不下，所以考虑用分块维护 01Trie 树。

对于每个块，建立一颗 01Trie 树。对于 Add 操作，更新当前块的 01Trie 树，复杂度为 $O(31)$。对于 Query 操作，散块直接暴力，整块则在 01Trie 树上进行查询。设块大小为 $S$，单次查询时间复杂度即为 $O(S+ \dfrac{31n}{S} )$，当 $S = \sqrt{31n}$ 时时间复杂度最优。

时间复杂度为 $O(Q\sqrt{31n})$。

```cpp
#include<bits/stdc++.h>
#define M 200005
typedef long long ll;
using namespace std;
bool f2;
char IO;
int rd(){
	int num=0;bool f=0;
	while(IO=getchar(),IO<48||IO>57)if(IO=='-')f=1;
	do num=(num<<1)+(num<<3)+(IO^48);
	while(IO=getchar(),IO>=48&&IO<=57);
	return f?-num:num;
}
int n,m,Q,S;
int opt[M],X[M],Y[M];
int to[M],hd[M],val[M],nxt[M],cnte;
void Adde(int u,int v,int w){
	to[++cnte]=v;val[cnte]=w;
	nxt[cnte]=hd[u];hd[u]=cnte;
}
int L[M],R[M],dis[M],idfn[M],ntot;
void dfs(int x){
	L[x]=++ntot;idfn[ntot]=x;
	for(int i=hd[x],y;i;i=nxt[i]){
		y=to[i];
		dis[y]=dis[x]^val[i];
		dfs(y);
	}R[x]=ntot;
}
// 01Trie树
int Rt[505],trie[M*32][2],cnt[M*32],tot;
void update(int &rt,int x,int dep=30){
	if(!rt)rt=++tot;
	++cnt[rt];
	if(dep==-1)return ;
	update(trie[rt][(x>>dep)&1],x,dep-1);
}
int query(int rt,int x,int dep=30){
	if(dep==-1||!cnt[rt])return 0;
	int bit=(x>>dep)&1;
	if(cnt[trie[rt][!bit]])
		return query(trie[rt][!bit],x,dep-1)|(1<<dep);
	else return query(trie[rt][bit],x,dep-1);
}
bool Upd[M];
void Update(int x){
	Upd[L[x]]=1;
	update(Rt[L[x]/S],dis[x]);
}
void Query(int L,int R,int x){
	int res=0,kl=L/S,kr=R/S;
	if(kl==kr){
		for(int i=L;i<=R;++i)
			if(Upd[i])res=max(res,dis[idfn[i]]^x);
	}else{
		for(int i=L;i<(kl+1)*S;++i)
			if(Upd[i])res=max(res,dis[idfn[i]]^x);
		for(int i=kl+1;i<kr;++i)
			res=max(res,query(Rt[i],x));
		for(int i=kr*S;i<=R;++i)
			if(Upd[i])res=max(res,dis[idfn[i]]^x);
	}printf("%d\n",res);
}
bool f1;
int main(){
//	cout<<(&f1-&f2)/1024.0/1024.0<<endl;
	Q=rd();n=1;
	char str[8];
	for(int i=1;i<=Q;++i){
		scanf("%s",str);
		opt[i]=(str[0]=='A');
		X[i]=rd(),Y[i]=rd();
		if(opt[i])Adde(X[i],++n,Y[i]);
	}
	dfs(1);S=sqrt(31*n);
	Update(m=1);
	for(int i=1,x;i<=Q;++i){
		if(!opt[i])Query(L[Y[i]],R[Y[i]],dis[X[i]]);
		else Update(++m);
	}
	return 0;
}

```

---

## 作者：SegmentTree_ (赞：2)

对于树上路径边权异或和，可以转化为 $dis_x \oplus dis_v$，其中 $dis_i$ 表示 $i$ 到根的路径上的边权异或和。  
于是，`Query` 操作就变成了 $b$ 的子树中的点的 $dis$ 异或上 $dis_a$ 的最大值。  
加上 `Add` 操作后，因为在序列上用树状数组套01-trie还是很好维护的，所以考虑把树拍到序列上。  
那要怎么做呢？可以离线建树搞一个 $dfn$ 序，初始时树套树只有一个 $dis_1$，也就是 $0$，`Add` 操作就是在 $x$ 插入一个 $dis_x$，`Query` 就是区间内异或最大值。  
时间复杂度 $O(n \log_2 n \log_2 V)$。  
code:  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned ll
#define ui unsigned int
#define i128 __int128
#define lid (id << 1)
#define rid (id << 1 | 1)
const int N = 2e5+5;
namespace tianyu{
	int n, q;
	struct Quee{
		string op;
		int x, y;
	}Q[N];
	int root[N];
	int trie[N * 200][2], siz[N * 200], tot;
	int now;
	vector<int> G[N];
	int dis[N];
	int dfn[N], end[N], tt;
	void dfs(int u){
		dfn[u] = ++tt;
		for (int v : G[u]){
			dfs(v);
		}
		end[u] = tt;
	}
	void insert(int p, int x){
		if (!root[p]) root[p] = ++tot;
		int u = root[p];
		for (int i = 30;i >= 0;i--){
			int a = (x >> i) & 1;
			if (!trie[u][a]) trie[u][a] = ++tot;
			u = trie[u][a];
			++siz[u];
		}
	}
	int ql[N], qr[N];
	int query(int x){
		int res = 0;
		for (int i = 30;i >= 0;i--){
			int a = (x >> i) & 1;
			int s = 0;
			for (int i = 1;i <= qr[0];i++) s += siz[trie[qr[i]][!a]];
			for (int i = 1;i <= ql[0];i++) s -= siz[trie[ql[i]][!a]];
			if (s){
				res |= (1 << i);
				a = !a;
			}
			for (int i = 1;i <= qr[0];i++) qr[i] = trie[qr[i]][a];
			for (int i = 1;i <= ql[0];i++) ql[i] = trie[ql[i]][a];
		}
		return res;
	}
	void update(int p){
		for (int i = dfn[p];i <= n;i += i & -i){
			insert(i, dis[p]);
		}
	}
	int query(int l, int r, int x){
		ql[0] = qr[0] = 0;
		--l;
		for (int i = r;i;i -= i & -i){
			qr[++qr[0]] = root[i];
		}
		for (int i = l;i;i -= i & -i){
			ql[++ql[0]] = root[i];	
		}
		return query(x);
	}
	void awa(){
		now = 1;
		n = 1;
		cin >> q;
		for (int i = 1;i <= q;i++){
			cin >> Q[i].op >> Q[i].x >> Q[i].y;
			if (Q[i].op == "Add"){
				++n;
				G[Q[i].x].emplace_back(n);
				dis[n] = dis[Q[i].x] ^ Q[i].y;
			}
		}
		dfs(1);
		update(1);
		for (int i = 1;i <= q;i++){
			if (Q[i].op == "Add"){
				update(++now);
			}
			else{
				int x = Q[i].x, y = Q[i].y;
				cout << query(dfn[y], end[y], dis[x]) << '\n';
				
			}
		}
	}
}
signed main(){
	int T = 1;
	while (T--) tianyu::awa();
	return 0;
}
```

---

## 作者：MuelsyseU (赞：2)

根据套路，设 $s_u$ 表示点 $u$ 到根路径的异或和。则我们的问题转化为求：

$$\max_{u\in\operatorname{subtree(b)}}\{s_a \operatorname{xor} s_u\}$$

由于 $s_a$ 为定值，所以我们可以考虑维护 $b$ 子树中所有 $s$ 的 01Trie，每次走相反边来取得最大异或和。

这样看起来不适合在线，考虑离线下来，发现可以采取线段树合并的 trick 来获得对应节点的 01Trie。为了处理修改，我们深入理解一般区间最大异或和的思路，是通过可持久化获取前 $r$ 个元素对应的 01Trie，再在走的过程中避免经过下标小于 $l$ 的节点。这里我们把下标对应改为这个点被插入的时间，就可以直接处理了。

时空复杂度 $O(q\log v)$，其中 $v$ 为值域大小。

实现时要注意这里的 Trie 合并时会出现重复元素，这时我们贪心地保留时间最小的。

```
#include <bits/stdc++.h>
#define maxn 1000005
using namespace std;

int ch[maxn * 30][2], p[maxn * 30], val[maxn * 30], s[maxn], t[maxn];
int a[maxn], ans[maxn];
int bk[maxn * 30], top;
int i, x, y, tot, n = 1, m;
char op[10];
inline void insert(int i, int k, int v) {
    if (k < 0) {
        p[v] = s[i], val[v] = t[i];
        return;
    }
    int c = s[i] >> k & 1;
    if (!ch[v][c]) ch[v][c] = top ? bk[top--] : ++tot;
    insert(i, k - 1, ch[v][c]), val[v] = min(val[ch[v][0]], val[ch[v][1]]);
}

inline int query(int u, int x, int k, int r) {
    if (k < 0) return p[u] ^ x;
    int c = x >> k & 1;
    if (val[ch[u][c ^ 1]] < r)
        return query(ch[u][c ^ 1], x, k - 1, r);
    else
        return query(ch[u][c], x, k - 1, r);
}
inline int merge(int u, int v) {
    if (!u || !v) return u ^ v;
    if (p[u] && p[v]) return val[u] < val[v] ? u : v;
    ch[u][0] = merge(ch[u][0], ch[v][0]), ch[u][1] = merge(ch[u][1], ch[v][1]);
    val[u] = min(val[ch[u][0]], val[ch[u][1]]);
    ch[v][0] = ch[v][1] = p[v] = 0, val[v] = 0x7f7f7f7f, bk[++top] = v;
    return u;
}
vector<int> e[maxn], q[maxn];
inline int dfs(int u) {
    int rt = top ? bk[top--] : ++tot;
    insert(u, 30, rt);
    for (auto v : e[u]) rt = merge(rt, dfs(v));
    for (auto i : q[u]) ans[i] = query(rt, a[i], 30, i);
    return rt;
}
int main() {
    scanf("%d", &m);
    memset(val, 0x7f, sizeof(ans));
    memset(ans, -1, sizeof(ans));
    for (int i = 1; i <= m; ++i) {
        scanf("%s", op), scanf("%d%d", &x, &y);
        if (op[0] == 'A')
            e[x].push_back(++n), s[n] = s[x] ^ y, t[n] = i;
        else
            q[y].push_back(i), a[i] = s[x];
    }
    dfs(1);
    for (int i = 1; i <= m; ++i)
        if (~ans[i]) printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：_Spectator_ (赞：0)

[可能更好的食用体验](/article/ltcrorsb) $|$ 
[题目传送门](/problem/P7242) $|$ 
[我的其他题解](/user/523641#article.2)

------------

### ${\color{#00CD00}\text{思路}}$

如果你做过 [P4551 最长异或路径](/problem/P4551)，那你一定知道一个经典的套路：设一个点 $u$ 到根节点的边权异或和为 $s_u$，则树上两点 $(u,v)$ 之间路径中边权异或和就是 $s_u\oplus s_v$。那么原题的询问就转化为了：求 $\max\limits_{u\in\operatorname{subtree}(b)} s_a\oplus s_u$。

和 P4551 类似，我们可以对每个点都开一个 $\tt 01\,Trie$，把这个点子树内所有点的 $s$ 都放到 $\tt 01\, Trie$ 上。这样我们在查询时只需要尽可能地走相反的边就能取到最大的异或值了。

离线，先将完整的树建出来，求出每个点对应的 $\tt 01\,Trie$，同时对 $\tt Trie$ 上的每个点 $u$ 记录一个时间 $t$，表示这个结点最早在 $t$ 时刻被创建。对于询问操作同样记录询问的时间，然后在查询时避开 $\tt Trie$ 中那些 $t$ 大于询问时间的点即可。

最后说下如何求出每个点对应的 $\tt 01\,Trie$，其实很简单，先求出所有子结点对应的 $\tt Trie$ 再合并即可。合并时从根结点递归到叶子，对所有结点的 $t$ 取较小值。实测不需要启发式合并也能通过。（而且跑得还比启发式合并快？）

实现细节详见代码。

------------

### ${\color{#00CD00}\text{代码}}$

字典树是非递归写法的，似乎更符合大多数人写字典树的习惯？

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;

namespace Trie{ // 01-Trie
	int idx, rt[N], f[N<<5][2], ti[N<<5]; // rt 存的是树上每个结点对应的 01-Trie 的根结点 
	int New(int t){return ti[++idx] = t, idx;} // 新建一个结点，创建时间为 t 
	void insert(int rt, int val, int t){ // 向以 rt 为根的 01-Trie 中插入 val 
		ti[rt] = min(ti[rt], t);
		for(int i=30; i>=0; i--){
			int x = val >> i & 1;
			if(!f[rt][x]) f[rt][x] = New(t);
			rt = f[rt][x], ti[rt] = min(ti[rt], t);
		}
	}
	int query(int rt, int val, int t){ // 在以 rt 为根的 01-Trie 中查询 val 的最大异或值 
		int res = 0;
		for(int i=30; i>=0; i--){
			int x = !(val >> i & 1);
			if(!f[rt][x] || ti[f[rt][x]] > t) rt = f[rt][x ^ 1];
			else res |= 1 << i, rt = f[rt][x];
		}
		return res;
	}
	void merge(int rt1, int rt2){ // 合并以 rt1, rt2 为根的两颗 01-Trie 
		if(!rt1 || !rt2) return;
		ti[rt1] = min(ti[rt1], ti[rt2]);
		if(!f[rt1][0]) f[rt1][0] = f[rt2][0];
		else merge(f[rt1][0], f[rt2][0]);
		if(!f[rt1][1]) f[rt1][1] = f[rt2][1];
		else merge(f[rt1][1], f[rt2][1]);
	}
} using namespace Trie;

int Q, n, m, s[N], ans[N];
struct qry{int x, t, id;};
vector<qry> q[N]; // 存储所有询问 
vector<int> G[N]; // 存储一棵树 
void solve(int u){ // 核心就两行（ 
	for(int v: G[u]) solve(v), merge(rt[u], rt[v]);
	for(qry i: q[u]) ans[i.id] = query(rt[u], s[i.x], i.t);
}

signed main(){
	ios::sync_with_stdio(false), cin.tie(nullptr);
	cin >> Q; insert(rt[1] = New(0), 0, 0), n = 1;
	for(int i=1; i<=Q; i++){
		string op; int x, y; cin >> op >> x >> y;
		if(op == "Query") q[y].push_back({x, i, ++m});
		if(op == "Add"){
			G[x].push_back(++n), s[n] = s[x] ^ y;
			insert(rt[n] = New(i), s[n], i);
		}
	}
	solve(1);
	for(int i=1; i<=m; i++) cout << ans[i] << "\n"; 
	return 0;
}
```

---

## 作者：TulipeNoire (赞：0)

这是一个复杂度为 $O(Q\log Q(\log Q+\log V))$ 的较劣做法，但是代码应该比较好写，而且思路比较直观。

我们考虑一个结论：令 $f_i$ 为 $1$ 到 $i$ 的路径上的边的边权异或和，那么 $f_x$ 异或上 $f_y$ 就是 $x$ 到 $y$ 路径上所有边的边权异或和。也就是说这个问题本质上还是点权的问题。

考虑离线，我们先把整棵树建出来，并标上 dfs 序。那么如果一个点 $x$ 对一个询问 $q$ 有贡献的话，显然要满足：

+ $x$ 出现时间在 $q$ 前。

+ $x$ 的 dfs 序在某一个区间（即 $q$ 询问中目标子树的 dfs 序区间，这显然连续）内。

这是一个三维偏序，我们可以考虑 cdq 分治。

具体地，我们对时间维分治。对一个区间分治时，我们先递归分治左右两半，然后考虑从这个区间左半对右半的贡献。我们把左半部分所有点（即第一类操作）按照 dfs 离散化，然后建立可持久化 trie，然后再右半部分查询时可以直接 `lower_bound` 找出这个询问的目标子树对应的离散化后的区间，然后直接在可持久化 trie 上查即可。

可持久化 trie 这部分就是经典问题了。

有一个细节要注意，就是一开始先要加上根节点。（即代码注释中特别标记的地方）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int n,val[N],ans[N],dfn[N],tot,ed[N];
vector<int>G[N];
struct opt {
    bool t;
    int x,y;
}q[N];
struct query {
    bool t;
    int val,x,y,id;
    inline bool operator<(query o) {return x<o.x;}
}a[N];
void dfs(int p) {
    dfn[p]=++tot;
    for (auto x:G[p]) dfs(x);
    ed[p]=tot;
    return;
}
int cnt,rt[N],b[N];
struct node {
    int dat,ch[2];
}tr[N<<5];
int upd(int cur,int x,int pos) {
    int p=++cnt;
    tr[p]=tr[cur],tr[p].dat++;
    if (pos<0) return p;
    int res=(x>>pos)&1;
    tr[p].ch[res]=upd(tr[cur].ch[res],x,pos-1);
    return p;
}
inline int get(int p,int q,int x) {
    int ans=0;
    for (int i=30;i>=0;i--) {
        int res=(x>>i)&1;
        if (tr[tr[p].ch[res^1]].dat-tr[tr[q].ch[res^1]].dat) {
            ans|=(1<<i),p=tr[p].ch[res^1],q=tr[q].ch[res^1];
        } else {
            p=tr[p].ch[res],q=tr[q].ch[res];
        }
    }
    return ans;
}
void cdq(int l,int r) {
    if (l==r) return;
    int mid=(l+r)>>1;
    cdq(l,mid);
    for (int i=1;i<=cnt;i++) tr[i]={};
    int tot=0;
    cnt=rt[0]=0;
    for (int i=l;i<=mid;i++) {
        if (!a[i].t) {
            tot++,b[tot]=a[i].x;
            rt[tot]=upd(rt[tot-1],a[i].val,30);
        }
    }
    for (int i=mid+1;i<=r;i++) {
        if (a[i].t) {
            int l=lower_bound(b+1,b+tot+1,a[i].x)-b;
            int r=upper_bound(b+1,b+tot+1,a[i].y)-b-1;
            ans[a[i].id]=max(ans[a[i].id],get(rt[r],rt[l-1],a[i].val));
        }
    }
    cdq(mid+1,r);
    sort(a+l,a+r+1);
    return;
}
char op[11];
int main() {
    scanf("%d",&n);
    int ncnt=1;
    for (int i=1;i<=n;i++) {
        scanf("%s",op);
        int x,y;
        if (op[0]=='A') {
            scanf("%d %d",&x,&y);
            val[++ncnt]=val[x]^y;
            G[x].push_back(ncnt);
            q[i].x=ncnt,q[i].y=val[ncnt];
        } else {
            scanf("%d %d",&x,&y);
            q[i].t=1,q[i].x=x,q[i].y=y;
        }
    }
    dfs(1);
    a[0]={0,0,dfn[1]};//！！！！！
    for (int i=1;i<=n;i++) {
        a[i].t=q[i].t,a[i].id=i;
        if (q[i].t) a[i].val=val[q[i].x],a[i].x=dfn[q[i].y],a[i].y=ed[q[i].y];
        else a[i].val=q[i].y,a[i].x=dfn[q[i].x];
    }
    cdq(0,n);
    for (int i=1;i<=n;i++) if (q[i].t) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：zhanghengrui (赞：0)

大致思路和楼上差不多，也是离线把树建出来，求出每个点和它的子树对应的 dfs 序区间，查询就直接查询区间内的最大值

不过不需要用楼上说的分块，直接一棵大 Trie 就行

Trie 上每个结点用一个 set 维护经过这个结点的所有数对应的 dfs 序，查询的时候就可以直接判断能不能走

设边权值域 $[0, 2^k)$，本题中 $k = 31$  
显然每个 set 的大小是 $O(Q)$ 的，每次插入和查询总共经过 $\Theta(k)$ 个结点，所以每次插入和查询是 $O(k \log Q)$ 的，总共 $\Theta(Q)$ 次插入和查询，因此总时间复杂度 $O(k Q \log Q)$，大概就是两个 log 的样子  
至于空间复杂度，Trie 本身 $O(k Q)$，所有 set 加起来 $\Theta(k Q)$，还有别的一些更小的东西，总共 $\Theta(k Q)$，大概一个 log

代码写的可能比较丑，空间几乎是卡着过的（400+ MB），时间的话有 O2 / Ofast 支持好像还行

```cpp
#include <iostream>
#include <memory>
#include <set>
#include <vector>

struct Operation {
  enum class Type { ADD, QUERY };

  Type type;
  unsigned long u;
  union {
    unsigned long val;
    unsigned long v;
  };
};

class Trie {
private:
  static constexpr unsigned short MAX_BITS = 31;

  struct Node {
    std::set<unsigned long> s;
    std::unique_ptr<Node> child[2];
  };

  std::unique_ptr<Node> root = std::make_unique<Node>();

public:
  void insert(unsigned long p, unsigned long v) {
    Node *node = root.get();
    for (unsigned short i = MAX_BITS; i--;) {
      const unsigned short t = (v >> i) & 1U;
      if (!node->child[t])
        node->child[t] = std::make_unique<Node>();
      node = node->child[t].get();
      node->s.insert(p);
    }
  }

  unsigned long get(unsigned long min, unsigned long max,
                    unsigned long v) const {
    Node *node = root.get();
    for (unsigned short i = MAX_BITS; i--;) {
      const unsigned short t = (v >> i) & 1U;
      if (node->child[t ^ 1]) {
        auto iter = node->child[t ^ 1]->s.lower_bound(min);
        if (iter != node->child[t ^ 1]->s.end() && *iter <= max) {
          node = node->child[t ^ 1].get();
          v |= (1UL << i);
          continue;
        }
      }
      node = node->child[t].get();
      v &= (v ^ (1UL << i));
    }
    return v;
  }
};

class Tree {
private:
  std::vector<unsigned long> sum{0};
  std::vector<std::vector<unsigned long>> children{{}};
  unsigned long cnt = 0;
  std::vector<unsigned long> dfn, siz;

  void dfs(unsigned long u) {
    dfn[u] = ++cnt;
    siz[u] = 1;
    for (const auto &v : children[u]) {
      dfs(v);
      siz[u] += siz[v];
    }
  }

public:
  std::vector<unsigned long> solve(const std::vector<Operation> &operations) {
    unsigned long addCnt = 0;
    std::vector<unsigned long> result;
    Trie trie;
    for (const auto &operation : operations) {
      if (operation.type == Operation::Type::ADD) {
        sum.push_back(sum[operation.u] ^ operation.val);
        children[operation.u].push_back(children.size());
        children.emplace_back();
      }
    }
    dfn.resize(sum.size());
    siz.resize(sum.size());
    dfs(0);
    trie.insert(dfn[0], sum[0]);
    for (const auto &operation : operations) {
      switch (operation.type) {
      case Operation::Type::ADD:
        ++addCnt;
        trie.insert(dfn[addCnt], sum[addCnt]);
        break;
      case Operation::Type::QUERY:
        result.push_back(trie.get(dfn[operation.v],
                                  dfn[operation.v] + siz[operation.v] - 1,
                                  sum[operation.u]));
        break;
      }
    }
    return result;
  }
};

int main() {
  unsigned long q;
  std::vector<Operation> operations;
  Tree tree;
  std::vector<unsigned long> answer;
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> q;
  while (q--) {
    unsigned long x, y;
    std::string s;
    std::cin >> s >> x >> y;
    if (s == "Add") {
      operations.push_back(
          Operation{.type = Operation::Type::ADD, .u = --x, .val = y});
      continue;
    }
    if (s == "Query") {
      operations.push_back(
          Operation{.type = Operation::Type::QUERY, .u = --x, .v = --y});
      continue;
    }
  }
  answer = tree.solve(operations);
  for (const auto &item : answer)
    std::cout << item << '\n';
  return 0;
}
```

---


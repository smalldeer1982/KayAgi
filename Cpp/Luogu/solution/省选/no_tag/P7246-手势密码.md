# 手势密码

## 题目背景

&emsp;&emsp;众目睽睽之下被要求解锁另一个人的手机是一件非常恐怖的事。

&emsp;&emsp;——特别是密码关于自己的时候。

---

&emsp;&emsp;被堆在讲台周围乌压压的同学围着，小灰毛表示自己真的很难。作为班长的阿绫被叫去开会，存着月考名次表的手机被交给天依保管。但消息不出意料地走漏，现在一班觊觎着分数数据的饿狼一致要求天依打开手机……

&emsp;&emsp;“真不知道密码啊！”拖延着，心里早就猜到手势密码的答案。

&emsp;&emsp;最后，试探而肯定地划出一个字母“Y”，解锁成功。什么意思呢？首先排除“依”的首字母。

&emsp;&emsp;这个时候肯定有起哄的啦！

&emsp;&emsp;“懂的都懂\~”“别问，问就是 [XX即是正义！](https://www.bilibili.com/video/BV1z741137vQ)”……

## 题目描述

乐正大小姐用的手机很高级，所以她的手势密码也很花哨。

具体地，现在有一棵 $n$ 个结点的树，对于两个结点 $u,v$，当且仅当 $(u,v)$ 是一条树边时，手势才能从其中一个点（$u$ 或 $v$）划向另一个点（$v$ 或 $u$）。更奇怪的是，这种手势密码不限制仅划一次，但每次划出的路径必须是树上的一条简单路径。

现在阿绫告诉了天依在她的密码中每个结点被手势划过的次数（作为手势的起点或终点也算划过一次），其中第 $i$ 个结点划过 $a_i$ 次。那么，天依至少要划多少次才能解开密码呢？

----

#### 简化题意

有一棵带点权的树。定义一次操作为选择树上的一条简单路径，并将这条简单路径上的所有点点权减去 $1$。问至少需要多少次操作，使树上所有点的点权**恰好**变为 $0$。

## 说明/提示

#### 样例解释 2
给出的树形态如下，括号中的数字表示该点的点权。

![样例2](https://cdn.luogu.com.cn/upload/image_hosting/djmtr8s9.png)

一种最优的操作方案为 $(3,4)\times2,(4,5),(4,4)\times4,(5,5)\times4,(4,7),(7,8),(6,7)\times6$。其中 $(u,v)$ 表示对从 $u$ 到 $v$ 的简单路径进行一次操作。

------------
#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$op\in\{1,2\}$，$1\le seed\le 10^9$，$1\le n\le 3\times 10^6$，$0\le a_i\le10^9$，$1\le u,v\le n$，保证 $u\ne v$。

| 子任务 | 分值 |    $op$    |           $n$            |      $a_i$      | 特殊性质 |
| :----: | :--: | :--------: | :----------------------: | :-------------: | :------: |
|   1    |  1   |    $1$     |           $2$            |        /        |    /     |
|   2    |  4   |    $1$     |           $3$            |        /        |    /     |
|   3    |  10  |    $1$     |      $\leq 6$       |  $\leq 3$  |    /     |
|   4    |  5   |    $1$     |     $\leq 10^6$     |        /        |    A     |
|   5    |  15  |    $1$     |      $\leq 50$      |        /        |    /     |
|   6    |  5   |    $1$     | $\leq 5\times 10^3$ | $\leq 100$ |    B     |
|   7    |  10  |    $1$     |     $\leq 10^5$     | $\leq 100$ |    B     |
|   8    |  10  |    $1$     |     $\leq 10^5$     |        /        |    C     |
|   9    |  10  |    $1$     |     $\leq 10^5$     | $\leq 100$ |    /     |
|   10   |  30  |    /     |            /             |        /        |    /     |


- 特殊限制 A：对于第 $i$ 条边 $(u,v)$，保证 $u=i,v=i+1$。
- 特殊限制 B：输入的边构成一棵满二叉树。
- 特殊限制 C：对于 $\forall 1\le i\le n$ 有 $a_i=1$。




------------
#### 提示
Subtask 10 时限 2S。

对于 $op=2$ 的数据，输入的模板只用于减小输入量，标程不依赖该数据生成方式。

【2024.7.2 补充】@[Edward1002001](https://www.luogu.com.cn/user/151415) 指出，Subtask 10 的数据生成器生成的树形并没有随机性。（因为在生成 $2$ 的父亲时，最终 `seed` 一定会变为 $1$，此后的随机序列就完全相同了。）这一点不影响数据的正确性，但导致数据强度下降，我们为此致歉。鉴于本题提交较多，不做题面和数据修改。

## 样例 #1

### 输入

```
1
4
1 2 1 2
1 2
2 3
2 4```

### 输出

```
2```

## 样例 #2

### 输入

```
1
8
1 4 2 8 5 7 8 1
1 2
2 3
2 4
2 5
1 6
6 7
6 8```

### 输出

```
19```

## 样例 #3

### 输入

```
2
10086001 100000```

### 输出

```
26892182890608```

# 题解

## 作者：Elegia (赞：36)

**懒得推贪心咋做啊？**

我们考虑将问题描述为**线性规划**，设集族 $\mathcal I$ 包含了所有的路径，那么我们无非要给每条路径 $S$ 赋予一个权值 $x_S$ 表示这条路径走了多少次，容易写出约束：

$$
\forall u, \sum_{S\ni u} x_S=a_u
$$

我们的目的就是最小化

$$
\sum_{S\in \mathcal I} x_S
$$

线性规划一般是用不等式表述的，所以我们先将前面的等式拆成两组不等式，就可以写成标准的形式：

$$
\begin{matrix}
& x_S \ge 0,\\
\mathrm{minimize} & \sum_{S\in \mathcal I} x_S, \\
\mathrm{s.t.} & \sum_{S\ni u} x_S  &\ge & a_u & (s_u)\\
              & \sum_{S\ni u} -x_S &\ge& -a_u & (t_u)\\
\end{matrix}
$$

我们改写为其**对偶线性规划**，即变成

$$
\begin{matrix}
& s_u,t_u \ge 0,\\
\mathrm{maximize} & \sum_u a_u(s_u-t_u), \\
\mathrm{s.t.} & \sum_{u\in S} (s_u-t_u)  &\le & 1 & (x_S)\\
\end{matrix}
$$

不难看出，我们可以令 $b_u=s_u-t_u$，那么就相当于 $b_u$ 可任取，然后目标是最大化 $\sum a_ub_u$，满足约束

$$
\forall S\in \mathcal I,\sum_{u\in S} b_u \le 1
$$

根据线性规划的对偶定理，这两个问题的解是相等的，我们只需求解后者。

由此，我们可以自然地设计一个 DP：$f_{u,d}$ 表示 $u$ 这颗子树里从 $u$ 出发，$b$ 值之和最大的路径为 $d$ 时最大的 $\sum a_ub_u$。显然 $d \in \{0,1\}$。而 $b_u$ 只有三种必要的取值：$\{-1,0,1\}$。我们枚举各情况进行转移，即是一个 $\Theta(n)$ DP。

（不过这里有一个小疑点，就是为什么最优解一定是整数。容易发现本题的约束矩阵**并不是**全幺模的，因此不能套用该充分条件来说明。）

---

## 作者：Reanap (赞：18)

很巧妙的一道贪心题。

很显然我们可以想到这道题的关键在于从什么时候开始，我当前所选择的链开始拐弯。

那么我们就可以想到遍历整棵树，在回溯的过程中依次处理那些链是就地拐弯，哪些链是继续往上传，在决定一条链的开始时计算贡献决定拐弯时减去多算的贡献即可。

现在我们的瓶颈在于如何决定拐点，由于数据范围很大，期望在 $O(n)$ 的时间复杂度内解决，同时问题情况也非常复杂，我们尝试着分类讨论贪心去解决它。

首先假设我们已经得到了对于当前点 $x$ ，我们已经得到了对于它的每个儿子往上传了多少条链，那么我们考虑最多可以将这些链可以匹配出多少个拐弯来。我们可以贪心地考虑每次将传递的链最多的儿子往其他任意一个儿子传递一个拐弯，可以发现这样一定是最优的。那么最后能够匹配出的拐点显然就是 $c = \min\left(sum-maxn , \left\lfloor \dfrac{sum}{2} \right\rfloor \right)$ 条，其中 $sum$ 是儿子的总上传链数，$maxn$ 是儿子上传的最大的链数。

很显然，我们肯定不能能拐弯就直接拐弯。不妨分类讨论一下：

1、当 $sum \le a_x$ 时：

对于这种情况，我们发现我们完全不拐弯一定属于最优策略。因为在这种情况下，无论如何，$a_x$ 的值都最多会刚好被儿子上传的链完全消耗。假设我们少取一个拐点，那么 $a_x$ 一定不会被完全消耗，因此还需要从 $x$ 上传一条链，所以贡献不变，上传的链增加 。很显然，我们希望上传的链越多越好，因为这样我们就可以在祖先节点帮助更多的点完成拐弯。

2、当 $a_x \le c$ 时：

对于这种情况，我们需要尽可能多地选择拐点。因为此时取到最后 $a_x$ 自身一定不会有剩余，那么取拐点的多少对当前贡献一定会有影响。假设我们少取一个拐点，我们会多一个上传链，当前贡献加 $1$，与其希望这个上传链在以后帮助祖先将贡献减少 $1$ 不如现在就不增加贡献。

3、对于剩余的情况：

由于随着我们对于拐点的选取， $sum$ 减少得比 $a_x$ 快，最终有可能变成情况 1 ，因此我们先考虑当前状态下的第一个拐点是否选择。假设我们取这个拐点，导致的结果就是贡献一定减少 $1$（因为加上这个拐点后，$a_x \le sum$，所以不可能产生从 $x$ 开始的链） ，同时上传链一定减少 $1$ ，相当于把这个上传链在祖先可能会产生的贡献在此时确定，一定能让答案不劣。最后由于 $sum$ 减速会比 $a_x$ 快，因此当当前情况变为情况 1 时则按照情况 1 计算。

整理可得一下简单的代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;

namespace IO{
	const int sz=1<<22;
	char a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];
	inline char gc(){
		return p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;
	}
	template<class T> void gi(T& x){
		x=0; char c=gc();
		for(;c<'0'||c>'9';c=gc());
		for(;c>='0'&&c<='9';c=gc())
			x=(x<<3)+(x<<1)+(c-'0');
	}
	inline void flush(){fwrite(b,1,t-b,stdout),t=b; }
	inline void pc(char x){*t++=x; if(t-b==sz) flush(); }
	template<class T> void pi(T x,char c='\n'){
		if(x<0) x=-x;
		if(x==0) pc('0'); int t=0;
		for(;x;x/=10) p[++t]=x%10+'0';
		for(;t;--t) pc(p[t]); pc(c);
	}
	struct F{~F(){flush();}}f; 
}
using IO::gi;
using IO::pi;



const int MAXN = 3e6 + 5;
LL ans , a[MAXN];
int n , head[MAXN] , to[MAXN << 1] , nxt[MAXN << 1] , cnt;
void add(int u , int v) {nxt[++cnt] = head[u];head[u] = cnt;to[cnt] = v;}

LL dfs(LL x , LL fa) {
	LL _sum = 0 , maxn = 0;
	for (int i = head[x]; i; i = nxt[i]) {
		if(to[i] == fa) continue;
		LL num = dfs(to[i] , x);
		_sum += num , maxn = max(maxn , num);
	}
	LL c = min(_sum - maxn , _sum / 2);
	if(a[x] <= c) {
		ans -= a[x];
		return 0;
	}
	else if(a[x] < _sum) {
		LL tmp = min(_sum - a[x] , c);
		ans -= tmp;
		return a[x] - tmp;
	}
	else {
		ans += a[x] - _sum;
		return a[x];
	}
}

namespace Generate{
	int n,seed;
	static const int mod=1e9;
	int Rand(int x){
		seed=(1ll*seed*0x66CCF+19260817ll)%x+1;
		seed=(1ll*seed*0x77CCF+20060428ll)%x+1;
		seed=(1ll*seed*0x88CCF+12345678ll)%x+1;
		seed=(1ll*seed*0x33CCCCFF+10086001ll)%x+1;
		return seed;
	}
	void RS(LL* a){ 
		for(int i = 1; i <= n; i++) a[i] = Rand(mod); 
		for(int i = 2; i <= n; i++){
			int fa = Rand(i - 1);
			add(fa , i);
			add(i , fa);
		}
	}
};

int main() {
	int ty;
	gi(ty);
	if(ty == 1) {
		gi(n);
		for (int i = 1; i <= n; ++i) gi(a[i]);
		for (int i = 1; i < n; ++i) {
			int u , v;
			gi(u),gi(v);
			add(u , v),add(v , u);
		}
	}
	else {
		gi(Generate::seed);
		gi(n);
		Generate::n=n;
		Generate::RS(a);
	}
	dfs(1 , 0);
	pi(ans);
	return 0;
}

```

---

## 作者：ForgotMe (赞：15)

## 题意

给出一棵树，点带权，每次操作可以将树上的一条简单路径上的点的点权减去 $1$，求使所有的点的点权变为 $0$ 最少操作次数。

## 题解

对于 subtask 1~2 直接手玩就好了，subtask 3 爆搜，subtask 4 是送给你们乱搞的，subtask 5 就是积木大赛直接递推就好了。

现在来讲正解。

先规定一下，$(u,v)$ 表示对 $u$ 到 $v$ 这条简单路径进行一次操作。

我们仍然应用积木大赛这题的‘帮忙’思想进行树上贪心。

我们在 dfs 时限保证子树处理完成，再在回溯时减去不必要的浪费。

假设当前结点为 $u$，考它的孩子能分别提供 $v_1,v_2,...,v_k$ 的‘帮助’（即对于孩子 $i$，它有 $v_i$ 条路径可以继续往上连）。

开始推结论。

### 结论1

在 $u$ 及其子树的操作次数不变的情况下，$u$ 向上提供的‘帮助’越多越好。

举个栗子：

![](https://cdn.luogu.com.cn/upload/image_hosting/xa6vpepb.png)

其中 $a_2=2,a_3=a_4=1$。不难发现，$(3,2)+(4,2)$ 其实是优于 $(3,4)+(2,2)$ 的，因为前者的两条路径都能继续向上帮助结点 $1$，但是后者仅有一条。

这个结论比较简单，大家应该都看的懂。

### 结论2

在保证结论一的前提下，尽量让路径跨子树的匹配。

举个栗子：

![](https://cdn.luogu.com.cn/upload/image_hosting/xwxq3j3i.png)

其中 $a_2=a_4=2,a_1=a_3=4$。

虽然在 dfs 时，结点 $2,3,4$ 总共需要 $8$ 次操作，但是回溯到根的时候，可以匹配 $2\times ((2,2)+(1,1)+(3,3))=2\times (2,3),2\times ((4,4)+(1,1)+(3,3))=2\times (4,3)$，这样子反而让答案减少了 $4$。

但是还有个问题，为什么说要保证结论一呢？

若原来 $\sum v_i\ge a_u$，假设所有的 $v_i$ 都不匹配，而向上帮助 $u$，$u$ 是一定不会额外加答案的，但是每次匹配会使 $\sum v_i$ 减少 $2$，$a_u$ 减少 $1$。但是匹配次数过多，在子树内是对答案没有帮助的，但是却会是根向上帮助的路径减少。这就违背结论一。

最后，考虑怎么实现，~~毕竟实现才是最难的~~。

- 最多匹配次数 $c=\min\{\lfloor\frac{\sum v_i}{2}\rfloor,\sum v_i-\max\{v_i\}\}$

- 保证贪心结论的最多匹配次数 $c^{'}=\max\{0,\min\{c,a_u,\sum v_i - a_u\}\}$

- 结点 $u$ 能向上帮助的次数 $help=a_u-c^{'}$

- 对答案的贡献 $\Delta ans=\max\{a_u-\sum v_i+c^{'},0\}-c^{'}$

总时间复杂度 $\mathcal{O(n)}$。

代码
```cpp
#include <map>
#include <set>
#include <stack>
#include <vector>
#include <cstdio>
#include <ctime>
#include <list>
#include <cmath>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

template <typename T>
inline void read(T& t) {
    t = 0;
    char c = getchar();
    int f = 1;
    while (c < '0' || c > '9') {
        if (c == '-')
            f = -f;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        t = (t << 3) + (t << 1) + c - '0';
        c = getchar();
    }
    t *= f;
}

template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t);
    read(args...);
}

template <typename T>
inline void write(T x) {
    if (x < 0) {
        x = -x;
        putchar('-');
    }
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

#define LL long long

LL Min(LL a, LL b) {
    if (a > b)
        return b;
    else
        return a;
}

LL Max(LL a, LL b) {
    if (a < b)
        return b;
    else
        return a;
}

namespace Generate {
	int n, seed;
	static const int mod = 1e9;
	int Rand(int x) {
    	seed = (1ll * seed * 0x66CCF + 19260817ll) % x + 1;
    	seed = (1ll * seed * 0x77CCF + 20060428ll) % x + 1;
    	seed = (1ll * seed * 0x88CCF + 12345678ll) % x + 1;
    	seed = (1ll * seed * 0x33CCCCFF + 10086001ll) % x + 1;
   	 	return seed;
	}
	void RS(LL* a, int* u, int* v) {  //你需要传入三个参数，分别表示点权，一条边的两个端点
    	int cnt = 0;
    	for (int i = 1; i <= n; i++) a[i] = Rand(mod);
    	for (int i = 2; i <= n; i++) {
       	 	int fa = Rand(i - 1);
        	cnt++;
        	u[cnt] = fa, v[cnt] = i;
    	}
	}
};  // namespace Generate

LL ans;
int opt, n;
LL a[3000005];
int U[3000005], V[3000005];
vector<int> G[3000005];

LL dfs(int u, int fa) {
    LL sum = 0, maxn = 0;
    for (int i = 0; i < G[u].size(); i++) {
        int v = G[u][i];
        if (v == fa)
            continue;
        LL num = dfs(v, u);
        sum += num, maxn = Max(maxn, num);
    }
    LL c = min(sum / 2, sum - maxn);
    LL newc = max(0ll, min(c, min(a[u], sum - a[u])));
    ans += max(0ll, a[u] - sum + newc) - newc;
    return a[u] - newc;
}

signed main() {
    read(opt);
    if (opt == 1) {
        read(n);
        for (int i = 1; i <= n; i++) read(a[i]);
        for (int i = 1; i < n; i++) {
            int u, v;
            read(u, v);
            G[u].push_back(v);
            G[v].push_back(u);
        }
    } else {
        read(Generate::seed), read(n);
        Generate::n = n;
        Generate::RS(a, U, V);
        for (int i = 1; i < n; i++) {
            G[U[i]].push_back(V[i]);
            G[V[i]].push_back(U[i]);
        }
    }
    dfs(1, 0);
    write(ans);
    return 0;
}
```


---

## 作者：Alex_Wei (赞：8)

> [P7246 手势密码](https://www.luogu.com.cn/problem/P7246)

除 EI 外的其它所有题解并没有严谨地证明贪心结论，本题解作为补充。

一道 DP 与贪心相结合的好题。

考虑树形 DP，设 $b_i$ 表示将 $i$ 子树所有节点权值清零的最小代价。

根据贪心思想，我们希望让尽量多的路径以 $i$ 为一端，这样它们可以选择继续向上延伸，或者封闭在子树内。根据决策包容性可证。问题在于如何平衡最小代价 $b_i$ 和以 $i$ 为一端的路径条数 $f_i$。

可以猜到这样一条结论：在 $b_i$ 最小的前提下使得 $f_i$ 最大，接下来 $f_i$ 每增大 $1$，$b_i$ 至少增加 $1$，我们将看到这是不优的。其证明在最后给出。

考虑 $u$ 及其所有子节点 $v$，如果它们分别独立，则总代价将为 $b_u = a_u + \sum b_v$，而我们可以执行以下两种操作减小 $b_u$：

- 选择 $v_1\neq v_2$，将 $a_u, f_{v_1}, f_{v_2}$ 同时减去 $1$，并将总代价 $b_u$ 减少 $2$，表示通过 $u$ 将两条分别以 $v_1$ 和 $v_2$ 为端点的链相连。
- 选择 $v$，将 $a_u, f_v$ 同时减去 $1$，并将总代价 $b_u$ 减少 $1$，表示将 $u$ 和一条以 $v$ 为端点的链相连。

不妨先执行所有操作 1，再执行所有操作 2。设 $S$ 为当前 $\sum f_v$，我们有以下几个容易证明的观察：

- $f_u$ 等于 $a_u$ 减去操作 1 执行次数。
- 操作 1 执行完毕后，操作 2 执行的最大次数为 $\min(a_u, S)$。
- 根据摩尔投票法和经典结论，操作 1 执行的最大次数为 $Q = \min(a_u, \lfloor \frac S 2 \rfloor, S - \max f_v)$。

结合观察 1 与观察 2，因为操作 1 使得 $a_u$ 减少 $1$，$S$ 减少 $2$，因此当 $S \leq a_u$ 时，一次操作 1 将减少两次操作 2，尽管总代价减小的值相同，但操作 1 执行次数增加，违背了最大化 $f_u$ 的目标。否则 $S > a_u$，一次操作 1 仅减少一次操作 2，总代价减小的值增加了，更优。

进一步地，可以计算得出操作 1 执行次数 $P = \min(Q, \max(0, S - a_u))$，继而得到 $f_u = a_u - P$，$b_u = a_u + \sum b_v - 2P - \min(f_u, S - 2P)$，注意这里 $S$ 为初始 $\sum f_v$。

对上述过程应用之前的结论，因为 $f_v$ 每增加 $1$，$b_v$ 都至少增加 $1$，但观察 $P$ 的计算式，其显然最多只能让 $P$ 增加 $1$，因此 $b_u$ 不会变小。也就是说，增加代价以增加以 $i$ 为一端的向上传递的链数不使得答案变优。

那么如何证明这一结论呢？也很容易：$f_u$ 加 1 说明操作 1 执行次数减少 1，只需对 **求解 $f_u$ 时** 操作 1 执行的最终态说明每撤销一次操作 1 均使得 $b_u$ 增大即可：

- 若 $a_u\leq S$，每撤销一次操作 1 使得 $\min(a_u, S)$ 即操作 2 次数增加 $1$，但 $b_u$ 增加 $2$，不优。
- 若 $a_u > S$，必然没有执行任何一次操作 1，否则撤销一次操作 1 使得 $b_u$ 不变，$f_u$ 增加 1，与 $f_u$ 的最大性矛盾。因此 $f_u$ 已经取到最大值 $a_u$，无法增大。

综上，时间复杂度 $\mathcal{O}(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
constexpr int mod = 1e9;
constexpr int N = 3e6 + 5;
int seed;
int Rand(int x) {
  seed = (1ll * seed * 0x66CCF + 19260817) % x + 1;
  seed = (1ll * seed * 0x77CCF + 20060428) % x + 1;
  seed = (1ll * seed * 0x88CCF + 12345678) % x + 1;
  seed = (1ll * seed * 0x33CCCCFF + 10086001) % x + 1;
  return seed;
}
int cnt, hd[N], nxt[N], to[N];
void add(int u, int v) {nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v;}
int op, n, dn, a[N], id[N], fa[N];
ll f[N];
void dfs(int x, int ff) {
  fa[x] = ff, id[++dn] = x;
  for(int i = hd[x]; i; i = nxt[i]) if(to[i] != ff) dfs(to[i], x);
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0);
  cin >> op;
  if(op == 1) {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i < n; i++) {
      int u, v;
      cin >> u >> v;
      add(u, v), add(v, u);
    }
    dfs(1, 0);
  }
  else {
    cin >> seed >> n;
    for(int i = 1; i <= n; i++) a[i] = Rand(mod), id[i] = i;
    for(int i = 2; i <= n; i++) add(fa[i] = Rand(i - 1), i);
  }
  ll ans = 0;
  for(int _ = n; _; _--) {
    int x = id[_];
    ll sumf = 0, mxf = 0;
    for(int i = hd[x]; i; i = nxt[i]) {
      int y = to[i];
      if(fa[x] == y) continue;
      sumf += f[y], mxf = max(mxf, f[y]);
    }
    ans += a[x];
    ll P = min((ll) a[x], min(sumf / 2, sumf - mxf));
    P = min(P, max(0ll, sumf - a[x]));
    f[x] = a[x] - P, ans -= 2 * P + min(f[x], sumf - 2 * P);
  }
  cout << ans << "\n";
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/8/9
Author: Alex_Wei
start coding at 10:45
finish debugging at 19:39
*/
```

---

## 作者：whiteqwq (赞：7)

[P7246 手势密码](https://www.luogu.com.cn/problem/P7246)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1769634)

## 题意

- 给定一颗$n$个点带点权的树，可以用若干条简单路径覆盖树，使得每个点被覆盖的次数为它的点权。
- 数据范围：$1\leqslant n\leqslant 3\times 10^6$。

## 分析

非常神仙的贪心题。

考虑使用一种“帮忙”思想：对于以$x$为根的子树，我们**将内部的点全部按要求覆盖**，并从$x$延伸出$v_x$条路径来帮忙覆盖祖宗结点（某些路径也可以在$x$结点止步）。

因此我们做一遍树形dp，对于每个结点$x$，我们计算**仅**当前位置对答案的贡献，也就是说如果这里向上延伸出$1$条路径，那么贡献就加$1$；如果有两条路径在这里交汇或者一条路径在这里结束，那么贡献就减$1$（本来要两条路径，现在用一条路径就可以覆盖了）。

设$x$所有儿子组成了$son(x)$集合，那么很容易发现：

- 对于每一个$y,z\in son(x)$，$y$的路径可以和$z$的路径在$x$上连接起来（下文称之为匹配），这样就可以让$y$和$z$的两个操作变成一个操作，并可以让$x$多一次覆盖。
- 对于所有的儿子，两两之间匹配最多匹配$\lfloor\frac{sum}{2}\rfloor$次。
- 对于某个儿子$y$，满足$v_y=maxx$，那么我们发现如果其他的儿子都与$y$匹配（不考虑$y$不够的情况），那么最少也需要$sum-maxx$次匹配。

因此，在$x$结点上**理论上**可以进行$l=\min\{\lfloor\frac{sum}{2}\rfloor,sum-maxx\}$次匹配。

我们发现，**在不增加$x$子树内对答案的贡献的情况下且不让$x$的覆盖次数超限的情况下，我们要减小匹配次数。**因为我们减小匹配次数就可以让可以延伸出去的路径数更多，根据贪心的思想这样一定是更优的。

这里有一个问题，为什么要保证不增加$x$子树内对答案的贡献呢？延伸出去不是可以减小祖先对答案的贡献吗？

我们发现对于某一条路径，且当前子树的根的覆盖次数还没有满，那么如果它在这里匹配，那么会减小$1$的贡献；而如果延伸出去，只是有可能减小$1$的贡献（有可能匹配不到路径）。因此我们发现在当前子树能减小贡献我们直接匹配一定是不劣的。

我们设当前根结点为$x$，在$x$处的匹配次数为$y$，那么有$y+(sum-2y)=a_x$（$y$条在$x$处匹配的路径，其余的路径都向上延伸，共$sum-2y$条），也就是$y=sum-a_x$。

那么，我们当前子树最优匹配次数为$match=\min\{l,a_x,sum-a_x\}$。

知道了子树最优匹配次数，那么其他的都好算了。

$v_x=a_x-match$（显然除去匹配的路径数对$x$的覆盖数量，其余$a_x$的每次覆盖都可以帮祖宗的忙）

而$x$结点对答案的贡献为$\max\{a_x-(sum-match),0\}-match$（所有路径能覆盖的次数为$(sum-2match)+match=sum-match$，因此$x$结点还需要$a_x-(sum-match)$次覆盖）。

时间复杂度：$O(n)$。

## 代码
```
#include<stdio.h>
#define int long long
const int mod=1000000000,maxn=3000005,maxm=maxn<<1;
int op,n,seed,e,ans;
int a[maxn],start[maxn],to[maxm],then[maxm],v[maxn];
inline int getseed(int x){
	seed=(1ll*seed*0x66CCF+19260817ll)%x+1;
	seed=(1ll*seed*0x77CCF+20060428ll)%x+1;
	seed=(1ll*seed*0x88CCF+12345678ll)%x+1;
	seed=(1ll*seed*0x33CCCCFF+10086001ll)%x+1;
	return seed;
}
inline int max(int a,int b){
	return a>b? a:b;
}
inline int min(int a,int b){
	return a<b? a:b;
}
inline void add(int x,int y){
	then[++e]=start[x],start[x]=e,to[e]=y;
}
void dfs(int x,int last){
	int sum=0,maxx=0,match;
	for(int i=start[x];i;i=then[i]){
		int y=to[i];
		if(y==last)
			continue;
		dfs(y,x),sum+=v[y],maxx=max(maxx,v[y]);
	}
	match=max(0,min(min(sum/2,sum-maxx),min(a[x],sum-a[x])));
	v[x]=a[x]-match;
	ans+=max(a[x]-(sum-match),0)-match;
}
signed main(){
	scanf("%lld",&op);
	if(op==1){
		scanf("%lld",&n);
		for(int i=1;i<=n;i++)
			scanf("%lld",&a[i]);
		for(int i=1;i<n;i++){
			int x,y;
			scanf("%lld%lld",&x,&y);
			add(x,y),add(y,x);
		}
	}
	if(op==2){
		scanf("%lld%lld",&seed,&n);
		for(int i=1;i<=n;i++)
			a[i]=getseed(mod);
		for(int i=2;i<=n;i++){
			int x=getseed(i-1);
			add(x,i),add(i,x);
		}
	}
	dfs(1,0);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：船酱魔王 (赞：1)

## 题意回顾

一个 $ n $ 个结点的无向树，点带非负权，请问至少多少次链减一操作可以让所有点点权归零？

$ 1 \le n \le 3 \times 10^6 $，点权上限 $ 10^9 $。

## 分析

考虑树上最小化一些东西的贪心强制定向，从低处往高处考虑，则一个点可能会开启一个“线头”，或合并两条“毛线”，或结束一条“毛线”，要求恰好填满每个结点的毛线“容量”。

可以发现开启线头会让答案加一，合并毛线会让答案减一，结束毛线答案不加不减。

* 考虑什么时候要开启线头？对于最底下的结点，这些点权数量的毛线要从这个结点开启，而一个结点可以上传一些毛线，如果下属结点上传的毛线不够也要新开线头。
* 考虑什么时候要合并毛线？假设我们把所有下属结点的毛线尽量多地直接接挂在这个结点上：
  * 如果数量还不足的话，合并两个毛线会导致需要额外开启一个线头，且上传的线头还少一个，这肯定是不优的（因为多上传一个线头可以就地斩断，但是少上传一个线头可能导致上面的结点还要多花一个开启线头的费用）。
  * 如果数量已经足够的话，每次合并一个没挂上去的毛线和已经挂上去的毛线可以节约一个花费，但是减少一个上传毛线，容易发现一个上传毛线带来的效果要么是节约一个新上传毛线要么是与一个毛线合并，对花费最多减一，因此在保证不需要添加毛线时尽量多地合并两个毛线一定是最优的。
  * 那么最多合并多少个线头？容易发现最多容纳点权个合并点，而最多有上传总数减去点权（即一开始没挂在上面的线头）个可以合并进来，但是这个上界并非是紧的。
    * 容易发现这个上界是在点权约束下的上界，考虑能不能真正找出这么多可以合并的毛线对。
    * 容易发现毛线对数合并的另一个上界为总数除以二下取整，即最多留一个孤毛线不合并。
    * 但是考虑如果其中某个结点上传毛线极多，达到了毛线总数的一半，则这个结点与其他结点对拼消耗是最优的。
    * 初始状态下，如果只有一条毛线，则合并总对数可以达到总数一半下取整。而边界条件是只能是其他结点没毛线，而如果一定能转移到有毛线的那个结点有一条及以下毛线的状态那就是能取到总毛线数除以二下取整的上界的情况，容易发现边界情况当且仅当能取到上界的情况满足“一个结点上传毛线总数不超过总上传毛线数的一半上取整”。
    * 如果考虑将上传毛线最多的一个子结点的毛线与上传毛线次多的子结点匹配。上传毛线新的最多子结点如果是被匹配的两个之一，那么总数减二（则最大值上界减一）最大值减一显然仍然满足要求；否则两个匹配的结点上传毛线数和新最大上传毛线数结点上传毛线数原来一定相等，则新的最大结点上传毛线数若大于等于 $ 2 $，则两个被匹配结点上传毛线数总和易证大于等于新的最大结点，否则所有结点都上传最多一条毛线也容易转移到能取到上界的边界情况。
    * 考虑非边界状态如果满足“最大值不多于一半上取整”的条件可以一直转移，转移次数有限，而每次转移后仍然满足要求，则所有子结点上传毛线最大值不超过总毛线数一半上取整的都可以取到上界（匹配数为总毛线数除以二下取整）；否则前文已经证明上界是总毛线数减去最大子结点上传毛线数。
  * 因此在不导致这个结点需要新开线头的情况下合并尽量多的毛线即可（总上传毛线数减去点权、点权、总上传毛线数减去最大值、总上传毛线数除以二下取整取最小值）。

## 参考实现

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <vector>
#define ll long long
using namespace std;
const int N = 3e6 + 5;
int n;
int a[N];
vector<int> g[N];
int up[N];
ll ans = 0;
namespace Generate {
	int n, seed;
	static const int mod = 1e9;
	int Rand(int x) {
		seed = (1ll * seed * 0x66CCF + 19260817ll) % x + 1;
		seed = (1ll * seed * 0x77CCF + 20060428ll) % x + 1;
		seed = (1ll * seed * 0x88CCF + 12345678ll) % x + 1;
		seed = (1ll * seed * 0x33CCCCFF + 10086001ll) % x + 1;
		return seed;
	}
	void RS(int *a) {
		for(int i = 1; i <= n; i++) a[i] = Rand(mod); 
		for(int i = 2; i <= n; i++) {
			int fa = Rand(i - 1);
			g[fa].push_back(i);
			g[i].push_back(fa);
		}
	}
};
void solve(int u, int fath) {
	ll sumd = 0;
	ll maxd = 0;
	for(int i = 0; i < g[u].size(); i++) {
		int v = g[u][i];
		if(v == fath) continue;
		solve(v, u);
		sumd += up[v];
		maxd = max(maxd, (ll)up[v]);
	}
	if(sumd <= a[u]) {
		up[u] = a[u];
		ans += a[u] - sumd;
	} else {
		int comb = min(min(sumd - a[u], (ll)a[u]), min(sumd / 2, sumd - maxd));
		up[u] = a[u] - comb;
		ans -= comb;
	}
}
int main() {
	int op;
	scanf("%d", &op);
	if(op == 1){
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
		int u, v;
		for(int i = 1; i < n; i++) scanf("%d%d", &u, &v), g[u].push_back(v), g[v].push_back(u);
	} else {
		int n;
		scanf("%d%d", &Generate::seed, &n);
		Generate::n = n;
		Generate::RS(a);
	}
	solve(1, 0);
	printf("%lld\n", ans);
	return 0;
}
```

---


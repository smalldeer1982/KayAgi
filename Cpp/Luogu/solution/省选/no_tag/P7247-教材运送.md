# 教材运送

## 题目背景

&emsp;&emsp;“如果天依来当志愿者的话，说不定会被累死哟。”

------------

&emsp;&emsp;“七年三班又在什么鬼地方啊……”，不信这个邪的小灰毛喘息着抱怨。发丝凝着汗珠，慵懒地趴在白皙的后颈，粘黏感若有若无地在心里描画着燥热。数十本教材抵在胸口，大腿前伸直的双手托着艰难的重量，贴着扶手一步一步挪上漫长的台阶。

&emsp;&emsp;背后，一撮可爱的棕色呆毛蹦蹦跳跳地跟了上来，“所以\~需要帮忙吗？”

## 题目描述

魔都中学的教学楼是一棵有 $n$ 个结点的树，结点 $i$ 对应编号为 $i$，人数为 $a_i$ 的教室。无向边 $i$ 描述为 $(u_i,v_i,b_i)$，对应连接教室 $u_i$ 和 $v_i$，垂直高差为 $b_i\ \text{m}$ 的台阶。

新学期开学，需要为同学们分发教材，不过传送系统的故障导致教材散落在各个教室。当天依在教室 $u$ 时，会随机抱起属于教室 $v~(v\in[1,n])$ 的 $a_v$ 本教材，并沿连接教室 $u,v$ 的唯一简单路径将这些教材送到教室 $v$。设天依走过的台阶高差为 $b_1,b_2,\cdots,b_m\ \text{m}$，每本教材重力为 $1\text{N}$，那么称此次运送中，天依的托举力做功的绝对值（上台阶取正功，下台阶取负功的绝对值）为 $W=a_v\left( \sum_{i=1}^{m} b_i \right)\text{J}$。换句话来说，一次运送的代价是**终点点权**与**走过路径边权之和**的乘积。

初始时，天依在 $1$ 号教室，但她不认识路，所以阿绫会带着天依运送教材，使得天依到达过每个教室至少一次。那么在达到这一目标之前，天依托举力做功的绝对值之和的期望为多少 $\text{J}$？

**由于答案可能是一个小数，为了避免损失精度，请输出答案在 $998244353$ 模意义下的值。**

------------

#### 简化题意

给定一棵包含 $n$ 个点，有点权和边权的无根树。设当前位置 $s$（初始时 $s=1$），每次在 $n$ 个结点内随机选择目标结点 $t$，付出「$s$ 到 $t$ 的简单路径上的边权之和」$\times$「$t$ 的点权」的代价，标记（可以重复标记）点 $t$ 并把 $s$ 置为 $t$。求每个点至少被标记一次时（其中 $1$ 号结点一开始就被标记）代价之和的期望。答案对 $998244353$ 取模。

## 说明/提示

------------
#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le a_i,b_i\lt 998244353$，$1\le u_i,v_i\le n$，保证 $u_i\ne v_i$。

| 子任务 | 分值 |         $n$          |               特殊限制                |
| :----: | :--: | :------------------: | :-----------------------------------: |
|   1    |  5  |      $ \le 3$       |                   /                   |
|   2    |  10  |      $ \le 13$       |                   /                   |
|   3    |  10  |      $ \le 20$       |                   /                   |
|   4    |  25  | $ \le 5\times 10^3 $ |                   /                   |
|   5    |  5   |          /           | 对于 $\forall 1\le i\le n$，$a_i=1$ |
|   6    |  10  |          /           | 对于每一条边，$v_i=u_i+1$，即树是一条链。 |
|   7    |  35  |          /           |                   /                   |


## 样例 #1

### 输入

```
3
1 2 3
1 2 1
2 3 1```

### 输出

```
332748127```

## 样例 #2

### 输入

```
5
2 3 4 2 5
1 2 3
2 4 2
2 5 5
1 3 3```

### 输出

```
615584181```

## 样例 #3

### 输入

```
2
1 2
1 2 2```

### 输出

```
4```

# 题解

## 作者：Elegia (赞：21)

我们不难确认如下事实：

任何时刻，将所在位置归类为**在根节点**或**不在根节点**，若不在根节点，那么**有等概率（即$\bf \frac 1{n-1}$）出现在任何一个非根节点**。

我们不妨设 $f_{i,j}$ 表示当前还剩 $i$ 个节点没有被占领，$j=0$ 表示现在在根节点，$j=1$ 表示**在 $\bf n-1-i$ 个已经被占领的非根节点中随机选取一个节点作为所在位置**，接下来的期望所需代价。

那么我们就不难设计转移了，首先预处理三个量：

- $x$：从根节点随机走到另外一个节点的期望代价。
- $y$：从随机一个非根节点走到根节点的期望代价。
- $z$：从一个随机非根节点走到另一个随机非根节点的期望代价。

这三者只要预处理出每个节点到其他所有节点的距离之和就可以 $\Theta(n)$ 算出，这只需要 dfs 两遍，不予赘述。

那么对于 $1\le i\le n-2$，我们根据组合意义直接列出的是一个关于 $f_{i,0},f_{i,1}$ 的方程：

$$
\begin{aligned}
f_{i,0} &= \frac i{n-1}f_{i-1,1}+\frac{n-1-i}{n-1}f_{i,1}&+x\\
f_{i,1} &= \frac i{n-1}f_{i-1,1}+\frac{1}{n-1}f_{i,0}+\frac{n-2-i}{n-1}f_{i,1} & + \frac 1{n-1}y + \frac{n-2}{n-1}z
\end{aligned}
$$

读者不难自行化简上式，会发现化简之后分母关于 $i$ 的部分只有一些形如 $i,i+1$ 等，因此不会发生除以 $0$ 的事情。

综上，我们通过一个简洁的 $\Theta(n)$ 解方程方法解决了本题。

---

## 作者：tuxuanming2024 (赞：6)

前言：这是一个不使用树形 dp 的，个人认为比较好想到的方法。

## 题意

一个树，从 $1$ 开始每次随机一个点走到那里，代价为那个点的点权乘上路径长度，问所有点至少访问一次的期望代价。

## 题解

考虑拆每条边的贡献。对于每条边，将整个树分成两个子树，设 $1$ 结点所在的子树的根为 $x$，另一个子树根为 $y$。现在考虑从 $x$ 子树走到 $y$ 子树。

那么，这一条边经过的期望次数为：$x$ 子树中的结点访问次数之和乘上走一次终点选到 $y$ 子树的概率。但同时注意到当一个点是最后一个被访问的点时是不能继续走的，于是要在前面那项减掉一个结束点在 $x$ 子树中的概率。形式化的，设点 $i$ 被访问的期望次数为 $e_i$，$i$ 为结束点的概率为 $p_i$，$sz_x$ 和 $sz_y$ 表示 $x$，$y$ 子树的大小，那么这条边被经过的期望次数为：

$$\left( \sum_{i \in \text{subtree(x)}} e_i - p_i \right)  \times \frac{sz_y}{n}$$

点权的话，由于每个点是等概率的，所以直接乘 $y$ 子树的 $a$ 之和除以 $sz_y$ 即可。

从 $y$ 走到 $x$ 同理。

接下来就是如何算出 $e$ 和 $p$。首先 $p$ 是很好求的，因为除了 $1$ 以外，剩下 $n-1$ 个点被作为结束点的概率是相等的，所以 $p_i = \frac{1}{n-1}$，$p_1 = 0$。

对于 $e$，我们知道如果起点也随机选择的话，那么每个点访问的期望次数是调和级数，即 $\sum_{i=1}^{n} \frac{1}{i}$。那么现在起点固定了怎么办呢，我们考虑这个结果是怎么得到的。实际上是个比较显然的线性期望 dp，设 $E_i$ 表示从访问过 $i$ 个点开始，一直到访问 $n$ 个点结束的期望次数，则：

$$E_i = E_{i+1} \times \frac{n-i}{n} + E_i \times \frac{i}{n} +1$$

移项得：

$$E_i = E_{i+1} + \frac{n}{n-i}$$

将 $E_0$ 除以 $n$ 就可以得到上面那个调和级数。这时起点固定了，那么实际上 $E_0 = E_1$，固 $e_i = \dfrac{E_1}{n} = \dfrac{1}{n}\sum_{i=1}^{n-1} \dfrac{1}{i}$，由于 $1$ 一开始就被访问了，所以还要将 $e_1$ 加一。

那么万事俱备，直接算就行了。复杂度如果线性预处理逆元的话就是 $O(n)$，否则是 $O(n \log V)$。

##

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1000005,mod=998244353;
int n,a[N],sz[N],sum;
ll res,s[N],ans,inv[N];
vector<pair<int,int>>e[N];
ll qpow(ll x,int y)
{
	ll s=1;
	for(;y;x=x*x%mod,y>>=1) if(y&1) s=s*x%mod;
	return s;
}
void dfs(int x,int prt)
{
	sz[x]=1,s[x]=a[x];
	for(auto it:e[x])
	{
		int y=it.first,w=it.second;
		if(y==prt) continue;
		dfs(y,x),sz[x]+=sz[y],s[x]=(s[x]+s[y])%mod;
		ll p=(res*(n-sz[y])%mod+1-(n-sz[y]-1)*inv[n-1]%mod)%mod;
		ans=(ans+p*s[y]%mod*inv[n]%mod*w%mod)%mod;
		p=(res*sz[y]%mod-sz[y]*inv[n-1]%mod)%mod;
		ans=(ans+p*(sum-s[y])%mod*inv[n]%mod*w%mod)%mod;
	}
}
signed main()
{
	scanf("%d",&n);
	inv[0]=1;
	for(int i=1;i<=n;i++) scanf("%d",a+i),sum=(sum+a[i])%mod,inv[i]=qpow(i,mod-2);
	for(int i=1,x,y,z;i<n;i++)
	{
		scanf("%d %d %d",&x,&y,&z);
		e[x].emplace_back(y,z);
		e[y].emplace_back(x,z);
	}
	if(n==1) {puts("0"); return 0;}
	for(int i=1;i<n;i++) res=(res+inv[i])%mod;
	dfs(1,0);
	printf("%lld",(ans+mod)%mod);
	return 0;
}
```


---

## 作者：FjswYuzu (赞：5)

首先给出 min-max 容斥的基本形式。
$$
E(\max(S)) = \sum_{\varnothing \neq T ⊆ S} (-1)^{|T|-1} E(\min(T))
$$
注意到原问题等价于标记最后一个点的期望代价，那么将一个集合里面的每一个元素看作标记该点的期望代价，那么 $E(\max(S))$ 可以表示答案。同时 $E(\min(T))$ 相当于从 $1$ 第一次走到 $T$ 中一个结点的期望代价。因为该题中 $1$ 一开始就被标记，那么 $S = \{2,3,\cdots n\}$。请注意 $S$ 不包括 $1$。

记 $f_T(u)$ 为从 $u$ 走到 $T$ 中任意一个结点的代价。不难得到：
$$
nf_T(u) = \begin{cases} 0 (u \in T) \\  \sum_{v=1}^n f_T(v) + d_{u,v} (u \not \in T) \end{cases}
$$
其中 $d_{u,v}$ 表示题目中 $u\to v$ 的代价。注意到等式左右两边已经同时乘 $n$。

下面记 $w(u) = \sum_{v=1}^n d_{u,v}$。

不妨记 $|T| = m$。那么所有 $f_T(i)$ 里共有 $n-m$ 个不为 $0$。这下可以列出 $n-m$ 个形似 $nf_T(u) -\sum_{v=1}^n f_T(v) = w(u)$ 的等式。

将 $\sum_{v=1}^n f_T(v)$ 记作 $s$。显然 $s = \sum_{v \not \in T} f_T(v)$。

那么将这 $n-m$ 个等式同时相加，可以得到：
$$
ns-(n-m)s = \sum_{u\not \in T} w(u)
$$

$$
\Rightarrow s = \dfrac{\sum_{u\not \in T} w(u)}{m}
$$

那么对于一个 $T$，可知：
$$
E(\min(T)) = f_T(1) = \dfrac{s+w(1)}{n}
$$
考虑到我们无法枚举 $T$，但是对于每一个 $E(\min (T))$，其贡献的形式类似，并且非根结点间没有本质区别（这也是 $O(n)$ DP 做法的重要 Motivation），考虑枚举 $T$ 的大小。
$$
\begin{aligned}E(\max(S)) 
&= \sum_{\varnothing \neq T ⊆ S} (-1)^{|T|-1} E(\min(T)) \\
&= \sum_{\varnothing \neq T ⊆ S} (-1)^{|T|-1} \left( \dfrac{w(1)}{n} + \dfrac{\sum_{u \not \in T} w(u)}{n|T|}\right) \\
&= \sum_{m=1}^{n-1} (-1)^{|T|-1} \left[ \dbinom{n-1}{m}\dfrac{w(1)}{n} + \dfrac{1}{nm} \sum_{T ⊆ S ∧ |T| = m} \sum_{u \in T} w(u) \right] \\
&= \dfrac{1}{n}\sum_{m=1}^{n-1} (-1)^{|T|-1} \left[ \dbinom{n-1}{m}w(1) + \dfrac{1}{m} \sum_{T ⊆ S ∧ |T| = m} \sum_{u \in T} w(u) \right]
\end{aligned}
$$
我们要把 $\sum_{T ⊆ S ∧ |T| = m} \sum_{u \in T} w(u)$ 这一大坨东西扯出来做。这个东西相当于对 $w(u)$ 带上一个系数，稍微想一下就可以知道这个东西就等于 $\displaystyle \binom{n-1}{m} w(1) + \binom{n-2}{m} \sum_{u=2}^{n} w(u)$。其中 $1 \not \in T$ 一定成立，相当于在 $n-1$ 元素个里面选 $m$ 个元素；对于其他的，要在 $S$ 中排除掉 $i$，相当于在 $n-2$ 元素个里面选 $m$ 个元素，可以得到上面的式子。

然后计算贡献方法很多，可以算换根每一个 $w(u)$，也可以算 $\sum_{u=1}^n w(u)$ 和 $w(1)$。介绍第二种方法。

$w(1)$ 可以根据定义直接来。算 $\sum_{u=1}^n w(u)$ 可以对每一条边考虑。现在有边 $\langle u,v,c \rangle$，记断掉这条边后，与 $u,v$ 连通的点个数为 $p_u,p_v$，点权之和为 $q_u,q_v$。可以知道：
$$
\sum_{u=1}^n w(u) = \sum_{\langle u,v,c \rangle \in E} c(p_uq_v + p_vq_u)
$$
于是这个题就做完了。时间复杂度 $O(n)$。

下面给出核心代码。

```cpp
int fac[1000005],ifac[1000005];
inline int C(int n,int m){return (m<0 || n<m)?0:Mul(fac[n],Mul(ifac[m],ifac[n-m]));}
inline int inv(int n){return Mul(fac[n-1],ifac[n]);}
struct Edge{
	int t,v;
	Edge(int T=0,int V=0){t=T,v=V;}
};
vector<Edge> G[1000005];
int n,w1,wsum,a[1000005],p[1000005],q[1000005],f[1000005];
void dfs1(int now,int pre)
{
	p[now]=1,q[now]=a[now];
	for(auto st:G[now])
	{
		int to=st.t;
		if(to==pre)	continue;
		dfs1(to,now);
		p[now]+=p[to];
		q[now]=Add(q[now],q[to]);
	}
}
void dfs2(int now,int pre,int dis)
{
	w1=Add(w1,Mul(dis,a[now]));
	for(auto st:G[now])
	{
		int to=st.t,w=st.v;
		if(to==pre)	continue;
		dfs2(to,now,Add(dis,w));
		wsum=Add(wsum,Mul(w,Add(Mul(p[to],Sub(q[1],q[to])),Mul(Sub(p[1],p[to]),q[to]))));
	}
}
int main(){
	n=read();
	fac[0]=1;
	for(int i=1;i<=n;++i)	fac[i]=Mul(fac[i-1],i);
	ifac[n]=QuickPow(fac[n],MOD-2);
	for(int i=n-1;~i;--i)	ifac[i]=Mul(ifac[i+1],i+1);
	for(int i=1;i<=n;++i)	a[i]=read();
	for(int i=1;i<n;++i)
	{
		int u=read(),v=read(),w=read();
		G[u].push_back(Edge(v,w));
		G[v].push_back(Edge(u,w));
	}
	dfs1(1,0);
	dfs2(1,0,0);
	wsum=Sub(wsum,w1);
	int ans=0;
	for(int m=1,i=1;m<n;++m,i=MOD-i)	ans=Add(ans,Mul(i,Add(Mul(C(n-1,m),w1),Mul(inv(m),Add(Mul(C(n-1,m),w1),Mul(C(n-2,m),wsum))))));
	write(Mul(ans,inv(n)));
	return 0;
}
```

---

## 作者：whiteqwq (赞：3)

[P7247 教材运送](https://www.luogu.com.cn/problem/P7247)

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1805462)

是我不会的天依题，让我把EI题解复读一遍！

## 题意

在一棵$n$个点，带点权、边权的树上，不断执行下列行动直到所有节点至少被标记过一次：

设当前起点为$s$（最开始为树根），随机选取一个非$s$节点$t$（不一定要标记过），消耗$a_t\times\sum_{edge\in path(s,t)}v_{edge}$的代价并标记$t$为新的$s$。

求期望代价对$998244353$取模的值。

$1\leqslant n\leqslant 10^6$。

## 分析

由于我们的行动一直是随机的，而起点固定是根节点，所以可以把树上的节点分为两部分：根节点与非根节点（每个非根节点都可以视为相同）。

不难想到期望dp，于是按套路倒推：设$f_{i,j}(j=0/1)$为还有$i$个节点没有标记，当前节点为根节点/非根节点，接下来所有操作的期望代价。

自然地想到预处理三个量：$x$表示从根节点到随机非根节点的期望代价，$y$表示从随机非根节点到根节点的期望代价，$z$表示从随机非根节点到随机非根节点的代价。

这三个量可以通过一遍dfs求出。

如果我们现在在根节点，还有$i$个没有标记的点，那么有$\frac{i}{n-1}$的概率到没有标记的点，$\frac{n-i-1}{n-1}$的概率到有标记的非根节点，即

$$f_{i,0}=\frac{i}{n-1}f_{i-1,1}+\frac{n-i-1}{n-1}f_{i,1}+x$$

如果我们现在在非根节点，还有$i$个没有标记的节点，那么有$\frac{i}{n-1}$的概率到没有标记的点，有$\frac{1}{n-1}$的概率到根节点，有$\frac{n-1}{n-i-2}$的概率到有标记的非根节点，即

$$f_{i,1}=\frac{i}{n-1}f_{i-1,1}+\frac{1}{n-1}f_{i,0}+\frac{n-i-2}{n-1}f_{i,1}+\frac{1}{n-1}y+\frac{n-2}{n-1}z$$

化简有

$$f_{i,1}=\frac{if_{i-1,1}+f_{i,0}+y+(n-2)z}{i+1}$$

两个式子联立有

$$f_{i,0}=\frac{nif_{i-1,1}+(n-1)(i+1)x+(n-i-1)(y+(n-2)z)}{ni}$$

$$f_{i,1}=\frac{nif_{i-1,1}+(n-1)(x+y+(n-2)z)}{ni}$$

于是$O(n)$递推就好了。（减小常数可以只递推$f_{i,1}$）

总结：遇到关于随机的题可以考虑将同类型的节点放在一起处理，减小状态。

## 代码

比第二短的代码短了1k左右，可见实现的简单。

想要代码可以私信我。

---

## 作者：gdf_yhm (赞：1)

[P7247](https://www.luogu.com.cn/problem/P7247)

参考 EI 题解。

### 思路

因为随机移动，所以可以不管当前在具体哪个点，发现本质不同的只有根节点和非根节点。设 $dp_{i,0/1}$ 表示还剩 $i$ 个未标记点，当前在或不在根节点。可以通过根到随机非根节点的期望 $x$，随机非根节点到根的期望 $y$，随机非根节点到另一个随机非根节点的期望 $z$ 来转移。

可以 dfs 预处理三个值。期望转为总和除以方案数。记 $dis_u$ 表示 $1$ 到 $u$ 的距离。

$$x=\frac{\sum dis_u\times a_u}{n-1}$$

$$y=\frac{\sum dis_u\times a_1}{n-1}$$

$$z=\frac{\sum_{u\neq 1}\sum_{v\neq 1}(dis_u+dis_v-2\times dis_{lca(u,v)})\times a_u}{(n-1)\times(n-2)}$$

对于 $z$ 当递归到 $u$ ，计算 $lca(uu,vv)=u$ 的有序对 $(uu,vv)$ 的答案。分别计算从每个子树出去和进入每个子树的贡献和。然后就可以 dp。

$$dp_{i,0}=\frac{i}{n-1}\times (dp_{i-1,1}+x)+\frac{n-i-1}{n-1}\times(dp_{i,1}+y)$$

$$dp_{i,1}=\frac{i}{n-1}\times (dp_{i-1,1}+z)+\frac{1}{n-1}\times(dp_{i,0}+y)+\frac{n-i-2}{n-1}\times(dp_{i,1}+z)$$

移项解得：

$$dp_{i,0}=dp_{i-1,1}+\frac{(n-1)(i-1)x+(n-i-1)y+(n-i-1)(n-2)z}{n\times i}$$

$$dp_{i,1}=dp_{i-1,1}+\frac{(n-1)x+(n-1)y+(n-1)(n-2)z}{n\times i}$$

递推即可，发现 $\frac{1}{n\times i}$ 可以预处理，复杂度 $O(n)$。

### code

```cpp
int n,a[maxn];
int head[maxn],tot;
struct nd{
	int nxt,to,w;
}e[maxn<<1];
void add(int u,int v,int w){e[++tot]={head[u],v,w};head[u]=tot;}
int x,y,z;
int dis[maxn],sum[maxn],siz[maxn],sa[maxn],mul[maxn];
int inc(int u,int v){
	((u+=v)>=mod)&&(u-=mod);
	return u;
}
void dfs(int u,int fa){
	if(u!=1)(x+=dis[u]*a[u])%=mod,(y+=dis[u]*a[1])%=mod;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==fa)continue;
		dis[v]=inc(dis[u],e[i].w);dfs(v,u);
		siz[u]+=siz[v],sum[u]=inc(sum[u],sum[v]),sa[u]=inc(sa[u],sa[v]),mul[u]=inc(mul[u],mul[v]);
	}
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==fa)continue;
		(z+=(siz[u]-siz[v])*(mul[v]-dis[u]*sa[v]%mod+mod))%=mod;
		(z+=(sa[u]-sa[v]+mod)*(sum[v]-siz[v]*dis[u]%mod+mod))%=mod;
	}
	if(u!=1){
		(z+=a[u]*(sum[u]-siz[u]*dis[u]%mod+mod))%=mod;
		(z+=mul[u]-dis[u]*sa[u]%mod+mod)%=mod;
	}
	siz[u]++,sum[u]=inc(sum[u],dis[u]),sa[u]=inc(sa[u],a[u]),(mul[u]+=a[u]*dis[u])%=mod;
}
int dp[maxn][2];
int inv[maxn];
void work(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read(),w=read();
		add(u,v,w),add(v,u,w);
	}
	dfs(1,0);
	inv[0]=inv[1]=1;for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	x=x*inv[n-1]%mod,y=y*inv[n-1]%mod,z=z*inv[n-1]%mod*inv[n-2]%mod;
	for(int i=1;i<n;i++){
		dp[i][0]=(dp[i-1][1]+((n-1)*(i+1)%mod*x+(n-i-1)*y+(n-i-1)*(n-2)%mod*z)%mod*inv[i]%mod*inv[n])%mod;
		dp[i][1]=(dp[i-1][1]+((n-1)*x+(n-1)*y+(n-1)*(n-2)%mod*z)%mod*inv[i]%mod*inv[n])%mod;
	}
	printf("%lld\n",dp[n-1][0]);
}
```

---


# 纯洁憧憬

## 题目背景

少年对他的憧憬，简直连续不断。  
少年的思绪，如同许多数字的排列一般凌乱。

## 题目描述

对于一个 $n$ 阶排列 $p_1,\dots,p_n$ 和一个区间 $[l,r]$，若 $\max\limits_{l\le i\le r} p_i - \min\limits_{l\le i\le r} p_i = r - l$，则称 $[l,r]$ 为一个**连续段**。

对于一个连续段 $[l,r]$，若其满足 $2 \le r - l + 1 < n$，则称 $[l,r]$ 为一个**非平凡连续段**。

**少年的思绪**可以抽象成一个**至少存在一个**长度大于 $k$ 的非平凡连续段的排列。

少年会给定 $n,k$，并询问你有多少 $n$ 阶排列可能是少年的思绪。答案对 $10^9 + 7$ 取模。

## 说明/提示

对于 $20\%$ 的数据，$n \le 10$；  
对于 $100\%$ 的数据，$1 \le k < n \le 400$。

#### 样例解释

对于第二个样例，不满足条件的排列有以下 $4$ 种：
1. $[2,1,4,3]$；
1. $[2,4,1,3]$；
1. $[3,4,1,2]$；
1. $[3,1,4,2]$。

另外 $4!-4=20$ 种方案都满足条件，可能是少年的思绪。

## 样例 #1

### 输入

```
3 2```

### 输出

```
0```

## 样例 #2

### 输入

```
4 2```

### 输出

```
20```

# 题解

## 作者：Aleph1022 (赞：3)

本文同步发表于我的博客：<https://www.alpha1022.me/articles/lg-7278.htm>。

首先正难则反，先算不存在的方案数再用 $n!$ 减去。  
考虑这个排列的析合树。

若根为合点，则儿子序列上的任何连续子序列都将是一个连续段。  
故此时条件等价于第一个儿子和最后一个儿子的大小都不小于 $n-k$。

考虑设 $g_i$ 表示长度为 $i$ 且满足任意前缀都不是包含 $1$ 的连续段的排列个数。  
这样的排列可以作为其中一个儿子。  
有递推式 $g_i = i! - \sum\limits_{j=1}^{i-1} g_j (i-j)!$。  
此部分复杂度为 $O(n^2)$。

枚举第一个和最后一个儿子的大小，从而这种情况的答案为
$$
2\sum\limits_{i=n-k}^k \sum\limits_{j=n-k}^{n-i} g_i g_j (n-i-j)!
$$

这可以直接 $O(n^2)$ 枚举计算。

若根为析点，则只需要保证每个儿子的大小不超过 $k$ 即可。

设 $f_i$ 表示长度为 $i$ 的不存在非平凡连续段的排列个数。  
这样的排列可以作为根的儿子序列，而儿子内部可以任意排列。

考虑递推 $f_i$。  
可以用所有方案减去根为合点的方案再减去根为析点但儿子个数不超过 $i-1$ 的方案。  
其中有初值 $f_1=1,f_2=2$。  
设 $G_{i,j}$ 表示将 $i$ 个数划分为 $j$ 个排列的方案数。这可以简单地 $O(n^3)$ 递推得到。  
则有递推式
$$
f_i = i! - 2\sum\limits_{j=1}^{i-1} g_j (i-j)! - \sum\limits_{j=4}^{i-1} f_j G_{i,j} \qquad (i\ge 3)
$$

求得 $f$ 后，考虑类似地设 $F_{i,j}$ 表示将 $i$ 个数划分为 $j$ 个大小不超过 $k$ 的排列的方案数，同样可以简单递推得到。  
于是这种情况的答案为
$$
\sum\limits_{i=4}^n f_i F_{n,i}
$$

综上，总答案为
$$
n! - 2\sum\limits_{i=n-k}^k \sum\limits_{j=n-k}^{n-i} g_i g_j (n-i-j)! - \sum\limits_{i=4}^n f_i F_{n,i}
$$

复杂度 $O(n^3)$，虽然这个瓶颈实际上看起来非常不优美，但是出题人并不想让一道看起来比较健康的签到题变成毒瘤题（或者说原题）。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 400;
const int mod = 1e9 + 7;
int n,k;
int fac[N + 5];
int f[N + 5],g[N + 5];
int F[N + 5][N + 5],G[N + 5][N + 5];
int ans;
int main()
{
    scanf("%d%d",&n,&k),fac[0] = 1;
    for(register int i = 1;i <= n;++i)
        fac[i] = (long long)fac[i - 1] * i % mod;
    for(register int i = 1;i <= n;++i)
    {
        g[i] = fac[i];
        for(register int j = 1;j < i;++j)
            g[i] = (g[i] - (long long)g[j] * fac[i - j] % mod + mod) % mod;
    }
    G[0][0] = 1;
    for(register int i = 1;i <= n;++i)
        for(register int j = 1;j <= i;++j)
            for(register int x = 1;x <= i;++x)
                G[i][j] = (G[i][j] + (long long)G[i - x][j - 1] * fac[x]) % mod;
    f[1] = 1,f[2] = 2;
    for(register int i = 3;i <= n;++i)
    {
        f[i] = fac[i];
        for(register int j = 1;j < i;++j)
            f[i] = (f[i] - 2LL * g[j] * fac[i - j] % mod + mod) % mod;
        for(register int j = 4;j < i;++j)
            f[i] = (f[i] - (long long)f[j] * G[i][j] % mod + mod) % mod;
    }
    F[0][0] = 1;
    for(register int i = 1;i <= n;++i)
        for(register int j = 1;j <= i;++j)
            for(register int x = 1;x <= min(i,k);++x)
                F[i][j] = (F[i][j] + (long long)F[i - x][j - 1] * fac[x]) % mod;
    for(register int i = n - k;i <= k;++i)
        for(register int j = n - k;j <= n - i;++j)
            ans = (ans + 2LL * g[i] * g[j] % mod * fac[n - i - j]) % mod;
    for(register int i = 4;i <= n;++i)
        ans = (ans + (long long)f[i] * F[n][i]) % mod;
    ans = (fac[n] - ans + mod) % mod;
    printf("%d\n",ans);
}
```

---

## 作者：NaCly_Fish (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P7278)

之前看 alpha 说有 $\Theta(n \log^2 n)$ 做法，不过我网上翻了一圈没找到有人写过。那我就来水一篇题解。

首先还是快进到答案的计算式：
$$n!-2\sum_{i=n-k}^kg_i\sum_{j=n-k}^{n-i}g_j(n-i-j)!-\sum_{i=4}^nf_iF_{n,i}$$

****
### Part 1

首先考虑快速地求出 $g_i$，这是很简单的。设其生成函数为 $\mathcal G(x)$，则 $\mathcal G(x)=1-(1+P(x))^{-1}$，其中

$$P(x)=\sum_{i\geq 1}i!x^i$$

可以 $\Theta(n \log n)$ 求出，对于答案算式中的这一段：
$$\sum_{i=n-k}^kg_i\sum_{j=n-k}^{n-i}g_j(n-i-j)!$$
我们发现若内层和式中的 $j$ 从 $0$ 开始，那就是标准的卷积式了。所以直接出将「$g_j$ 低于 $n-k$ 的项抹去得到的数列」与 $j!$ 卷积即可。


****
### Part 2

对于答案计算式的第二部分，我们先分析 $f$ 的结构：

$$f_i=i!-2\sum_{j=1}^{i-1}g_j(i-j)!-\sum_{j=4}^{i-1}f_jG_{i,j}$$
等式右边第二项可以直接用 $g_i$ 的递推式化简，而第三项需要用到
$$G_{i,j}=[x^i]P(x)^j$$
所以
$$[x^i]\sum_{j=4}^if_jP(x)^j=2g_i-i! \quad (i\geq 3)$$
我们发现等式左边很像一个多项式复合的形式，把多出来的项消掉，就可以写为
$$\begin{aligned}\mathcal F(P(x))-2P(x)^2+x &=2G(x) \\ \mathcal F(P(x))-2P(x)^2+x&=2\left( 1-\frac{1}{1+P(x)} \right) \\ \mathcal F(x)&=2\left( x^2+\frac{x}{1+x}\right)-P^{\langle -1 \rangle}(x)\end{aligned}$$

现在需要求出
$$\begin{aligned} \sum_{i=4}^nf_i F_{n,i} &= [x^n]\sum_{i=4}^nf_i \hat P(x)^i \\ &=[x^n]\left(\mathcal F\left( \hat P(x)\right)-\hat P(x)-2\hat P(x)^2 \right) \\ &= [x^n]\left(  \frac{\hat P(x)-\hat P(x)^2}{1+\hat P(x)}-P^{\langle -1 \rangle}\left(\hat P(x) \right)\right)\end{aligned}$$
前面一项很容易处理，重点在于后面那项：
$$[x^n]P^{\langle -1 \rangle}\left(\hat P(x) \right)=\frac 1n [x^{n-1}]\left(\frac{x}{\hat P^{\langle -1 \rangle}(P(x))}\right)^n$$
设 $\hat P(Q(x))=P(x)$，根据 $\hat P$ 的微分有限性，$Q(x)$ 可以快速求出：
$$\hat P(x)=x^2\hat P'(x)+x \hat P(x)+x-(k+1)!x^{k+1}$$
两边同时复合 $Q(x)$ 即得
$$\begin{aligned}P(x)&=Q(x)^2 \hat P'(Q(x))+Q(x)P(x)+Q(x)-(k+1)!Q(x)^{k+1}\\(1-Q(x))P(x)&=\frac{Q(x)}{Q'(x)}P'(x)+Q(x)-(k+1)!Q(x)^{k+1}\end{aligned}$$
~~使用 [一阶微分方程](https://www.luogu.com.cn/problem/P6613) 的牛顿迭代法求解即可，总时间复杂度 $\Theta(n \log n)$。~~

牛顿迭代的求解确实有一些问题，具体而言设 $Q'(x)=A(Q(x))$，在牛顿迭代中会用到求 $A'(Q(x))$，这会导致出现 **低于 -1 次** 的项。这本来也问题不大，但是还要求出 $\exp \left(\int A'(Q(x))\text dx\right)$，这样就出现了无限负次项，瞬间爆炸。

暂时还只能用分治 fft 或半在线卷积求解，若有新做法还会补充。

由于模数是 $10^9+7$，就不写代码了。

---

## 作者：DaiRuiChen007 (赞：0)

# P7278 题解

[Problem Link](https://www.luogu.com.cn/problem/P7278)

**题目大意**

> 给定 $n,m$，求多少 $n$ 阶排列有长度 $>m$ 的非平凡连续段。
>
> 数据范围：$n\le 400$。

**思路分析**

先考虑如何求 $n$ 阶无连续段排列的数量 $h_n$，反面考虑，减掉存在非平凡连续段的答案。

先考虑析合树的根为析点的情况，此时我们枚举第一个儿子，预处理 $f_i$ 表示 $i$ 阶排列无连续段前缀的方案数，容斥得到：
$$
f_i=i!-\sum_{j=1}^{i-1} (i-j)!f_j
$$
那么答案就要减掉 $2\sum_{j=1}^{n-1} f_j(i-j)!$，$\times 2$ 是处理析点的正序和倒序问题。

然后考虑析合树的根为合点的情况，首先枚举儿子数 $i$，那么儿子之间的排列数就是 $h_i$，还要乘以 $g_{n,i}$ 表示 $1\sim n$ 分成 $i$ 个连续段的方案数。

显然析点的儿子数 $\ge 4$，因此递推式为：
$$
g_{i,j}=\sum_{k=1}^i g_{i-k,j-1}k!\\
h_{i}=i!-\sum_{j=1}^{n-1} 2f_j(i-j)!-\sum_{j=4}^n g_{i,j}h_j
$$
类似刚才的想法，我们接着容斥求没有长度 $>m$ 的连续段数量。

若根为析点，那么我们要要求前后缀节点长度 $\ge n-m$，否则我们乘上 $g'_{n,i}$ 作为系数，表示 $1\sim n$ 分成 $i$ 个 $\le m$ 的连续段。

最终答案就是：
$$
g'_{i,j}=\sum_{k=1}^{\min(m,i)} g_{i-k,j-1}k!\\
\mathrm{Answer}=n!-2\sum_{i=1}^{n-m}\sum _{j=1}^{n-m} f_if_j(n-i-j)!-\sum_{i=4}^n h_ig'_{n,i}
$$
时间复杂度 $\mathcal O(n^3)$.

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=405,MOD=1e9+7;
ll fac[MAXN],f[MAXN],g[MAXN][MAXN],h[MAXN],tg[MAXN][MAXN];
signed main() {
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=fac[0]=1;i<=n;++i) fac[i]=fac[i-1]*i%MOD;
	f[1]=1;
	for(int i=2;i<=n;++i) {
		f[i]=fac[i];
		for(int j=1;j<i;++j) f[i]=(f[i]+MOD-f[j]*fac[i-j]%MOD)%MOD;
	}
	g[0][0]=1;
	for(int i=1;i<=n;++i) for(int j=1;j<=i;++j) {
		for(int k=1;k<=i;++k) g[i][j]=(g[i][j]+g[i-k][j-1]*fac[k])%MOD;
	}
	h[1]=1,h[2]=2,h[3]=0;
	for(int i=4;i<=n;++i) {
		h[i]=fac[i];
		for(int j=1;j<i;++j) h[i]=(h[i]+MOD-2*f[j]*fac[i-j]%MOD)%MOD;
		for(int j=4;j<i;++j) h[i]=(h[i]+MOD-h[j]*g[i][j]%MOD)%MOD;
	}
	tg[0][0]=1;
	for(int i=1;i<=n;++i) for(int j=1;j<=i;++j) {
		for(int k=1;k<=i&&k<=m;++k) tg[i][j]=(tg[i][j]+tg[i-k][j-1]*fac[k])%MOD;
	}
	ll ans=fac[n];
	for(int i=4;i<=n;++i) ans=(ans+MOD-h[i]*tg[n][i]%MOD)%MOD;
	for(int i=n-m;i<=n;++i) for(int j=n-m;j<=n-i;++j) {
		ans=(ans+MOD-2*f[i]*f[j]%MOD*fac[n-i-j]%MOD)%MOD;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


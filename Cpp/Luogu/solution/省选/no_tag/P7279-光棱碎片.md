# 光棱碎片

## 题目背景

碎片在少年的世界里四处飘散。  
最后被少年收集起，成为一列仿若无意义的字符。

## 题目描述

少年只剩一个字符串 $S$，它的长度为 $n$，下标以 $1 \dots n$ 编号；  
以及一个数组 $a_{1\dots n}$。

少年写出了两个数 $L,R$ 并尝试寻找那些被光芒照耀过的碎片：  
对于 $S$ 中两个出现位置不同而本质相同的子串 $(S_{l_1\dots r_1},S_{l_2\dots r_2})$，若 $L \le (a_{r_1} \oplus a_{r_2}) + (r_1 - l_1 + 1) \le R$，则这两个子串之间存在光芒。  
其中 $S_{l\dots r}$ 表示 $S$ 的下标在 $[l,r]$ 内的字符顺次连接构成的子串，$\oplus$ 表示按位异或运算。

少年试图寻找，有多少对子串之间存在光芒。  
子串对是无序的。具体地，$(S_{l_1\dots r_1},S_{l_2\dots r_2})$ 和 $(S_{l_2\dots r_2},S_{l_1\dots r_1})$ 视为一个子串对。  
而你只需要将答案对 $998244353$ 取模之后告诉他就行了。

## 说明/提示

对于 $20\%$ 的数据，$n \le 100$；    
对于 $50\%$ 的数据，$n \le 10^3$；  
对于 $100\%$ 的数据，$1 \le n \le 10^5$, $0 \le a_i,L,R \le 10^5$, $L \le R$, $S$ 只包含小写字母。

**「出题人的馈赠」**  
勇敢一点。相信某算法的常数。你想到的可能就是垃圾标算。

## 样例 #1

### 输入

```
5
abcbc
0 1 2 3 4
2 7```

### 输出

```
2```

# 题解

## 作者：Aleph1022 (赞：3)

本文同步发表于我的博客：<https://www.alpha1022.me/articles/lg-7279.htm>。

首先将限制转化为 $\le R$ 。  
建出反串的后缀树，执行静态链分治（即树上启发式合并）。  
设当前结点包含字符串的最长长度为 $\rm len$，则考虑子树内的后缀 $i,j$ 的贡献。  
显然是 $\min(R - (a_i \oplus a_j),{\rm len})$。

考虑分类讨论。  
若 $a_i \oplus a_j \le R - {\rm len}$，需要这部分的数对的个数。  
若 $R - {\rm len} < a_i \oplus a_j \le R$，需要这部分的数对的 $a_i \oplus a_j$ 之和以及个数。

则问题变为维护一个多重集 $S$，支持对于  $i \in S$，查询满足 $i \oplus v \le R$ 的 $i$ 的个数以及 $i \oplus v$ 的和。  
可以考虑使用 Trie 来维护，查询时在 Trie 上走 $v \oplus R$ 的路径，当某个时刻 $R$ 的当前位为 $1$，则意味着若走向另一个儿子，异或值的这一位会变为 $0$，故将答案加上另一个儿子子树内的贡献即可。  
当然，还要加上 $v \oplus R$ 本身的贡献。  
而同时要查询和，可以套路地维护每一位 $1$ 的个数来支持查询。

时间复杂度 $O(n \log n \log^2 a_i)$。  
因为这是一棵后缀树，可以相信良心出题人没有卡树剖，所以是可以过的。

当然，在 SA 的 height 数组上并查集启发式合并或所谓「启发式分裂」并使用可持久化 Trie 也是可以的。  
实际上这两种做法都相当于在 height 数组的笛卡尔树上做静态链分治，而 height 数组的笛卡尔树和后缀树某种意义上是等价的。

代码：
```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <utility>
#include <algorithm>
using namespace std;
const int N = 1e5;
const int LG = 16;
const int mod = 998244353;
int n,L,R,w[N + 5];
char s[N + 5];
int ans;
namespace TRIE
{
	struct node
	{
		int ch[2];
		int cnt,sum[LG + 5];
	} tr[(N << 5) + 5];
	int tot = 1;
	inline void insert(int v,int d)
	{
		int p = 1;
		tr[p].cnt += d;
		for(register int k = 0;k <= LG;++k)
			tr[p].sum[k] += ((v >> k) & 1) * d;
		for(register int i = LG;~i;--i)
		{
			!(tr[p].ch[(v >> i) & 1]) && (tr[p].ch[(v >> i) & 1] = ++tot),
			p = tr[p].ch[(v >> i) & 1];
			tr[p].cnt += d;
			for(register int k = 0;k <= LG;++k)
				tr[p].sum[k] += ((v >> k) & 1) * d;
		}
	}
	inline pair<int,int> query(int v,int r)
	{
		if(r < 0)
			return make_pair(0,0);
		int p = 1;
		int cnt = 0,sum = 0;
		for(register int i = LG;~i && p;--i)
		{
			if((r >> i) & 1)
			{
				cnt += tr[tr[p].ch[(((v ^ r) >> i) & 1) ^ 1]].cnt;
				for(register int k = 0;k <= LG;++k)
					if((v >> k) & 1)
						sum = (sum + (tr[tr[p].ch[(((v ^ r) >> i) & 1) ^ 1]].cnt - tr[tr[p].ch[(((v ^ r) >> i) & 1) ^ 1]].sum[k]) * (1LL << k)) % mod;
					else
						sum = (sum + tr[tr[p].ch[(((v ^ r) >> i) & 1) ^ 1]].sum[k] * (1LL << k)) % mod;
			}
			p = tr[p].ch[((v ^ r) >> i) & 1];
		}
		cnt += tr[p].cnt;
		for(register int k = 0;k <= LG;++k)
			if((v >> k) & 1)
				sum = (sum + (tr[p].cnt - tr[p].sum[k]) * (1LL << k)) % mod;
			else
				sum = (sum + tr[p].sum[k] * (1LL << k)) % mod;
		return make_pair(cnt,sum);
	}
}
namespace SAM
{
	struct node
	{
		int ch[26];
		int fa,len;
	} sam[(N << 1) + 5];
	int las = 1,tot = 1;
	int c[N + 5],a[(N << 1) + 5];
	int sz[(N << 1) + 5],son[(N << 1) + 5];
	vector<int> edp[(N << 1) + 5];
	inline void insert(int x,int pos)
	{
		int cur = las,p = ++tot;
		sam[p].len = sam[cur].len + 1;
		for(;cur && !sam[cur].ch[x];cur = sam[cur].fa)
			sam[cur].ch[x] = p;
		if(!cur)
			sam[p].fa = 1;
		else
		{
			int q = sam[cur].ch[x];
			if(sam[cur].len + 1 == sam[q].len)
				sam[p].fa = q;
			else
			{
				int nxt = ++tot;
				sam[nxt] = sam[q],sam[nxt].len = sam[cur].len + 1,sam[p].fa = sam[q].fa = nxt;
				for(;cur && sam[cur].ch[x] == q;cur = sam[cur].fa)
					sam[cur].ch[x] = nxt;
			}
		}
		++sz[las = p],edp[las].push_back(pos);
	}
	int to[(N << 1) + 5],pre[(N << 1) + 5],first[(N << 1) + 5];
	inline void add(int u,int v)
	{
		static int tot = 0;
		to[++tot] = v,pre[tot] = first[u],first[u] = tot;
	}
	inline void build()
	{
		for(register int i = 1;i <= tot;++i)
			++c[sam[i].len],i > 1 && (add(sam[i].fa,i),1);
		for(register int i = 1;i <= n;++i)
			c[i] += c[i - 1];
		for(register int i = tot;i > 1;--i)
			a[c[sam[i].len]--] = i;
		for(register int i = tot;i > 1;--i)
		{
			sz[sam[a[i]].fa] += sz[a[i]];
			if(!son[sam[a[i]].fa] || sz[a[i]] > sz[son[sam[a[i]].fa]])
				son[sam[a[i]].fa] = a[i];
		}
	}
	void dfs(int p)
	{
		int len = sam[p].len;
		pair<int,int> res1,res2;
		for(register int i = first[p];i;i = pre[i])
			if(to[i] ^ son[p])
			{
				dfs(to[i]);
				for(register vector<int>::iterator it = edp[to[i]].begin();it != edp[to[i]].end();++it)
					TRIE::insert(w[*it],-1);
			}
		if(son[p])
			dfs(son[p]);
		for(register vector<int>::iterator it = edp[p].begin();it != edp[p].end();++it)
			res1 = TRIE::query(w[*it],R - len),
			res2 = TRIE::query(w[*it],R),
			ans = (ans + (long long)res1.first * len) % mod,
			ans = (ans + (long long)(res2.first - res1.first) * R % mod - (res2.second - res1.second + mod) % mod + mod) % mod,
			res1 = TRIE::query(w[*it],L - 1 - len),
			res2 = TRIE::query(w[*it],L - 1),
			ans = (ans - (long long)res1.first * len % mod + mod) % mod,
			ans = (ans - (long long)(res2.first - res1.first) * (L - 1) % mod + (res2.second - res1.second + mod) % mod + mod) % mod;
		for(register vector<int>::iterator it = edp[p].begin();it != edp[p].end();++it)
			TRIE::insert(w[*it],1);
		if(son[p])
		{
			edp[p].swap(edp[son[p]]);
			for(register vector<int>::iterator it = edp[son[p]].begin();it != edp[son[p]].end();++it)
				edp[p].push_back(*it);
			vector<int>().swap(edp[son[p]]);
		}
		for(register int i = first[p];i;i = pre[i])
			if(to[i] ^ son[p])
			{
				for(register vector<int>::iterator it = edp[to[i]].begin();it != edp[to[i]].end();++it)
					res1 = TRIE::query(w[*it],R - len),
					res2 = TRIE::query(w[*it],R),
					ans = (ans + (long long)res1.first * len) % mod,
					ans = (ans + (long long)(res2.first - res1.first) * R % mod - (res2.second - res1.second + mod) % mod + mod) % mod,
					res1 = TRIE::query(w[*it],L - 1 - len),
					res2 = TRIE::query(w[*it],L - 1),
					ans = (ans - (long long)res1.first * len % mod + mod) % mod,
					ans = (ans - (long long)(res2.first - res1.first) * (L - 1) % mod + (res2.second - res1.second + mod) % mod + mod) % mod;
				for(register vector<int>::iterator it = edp[to[i]].begin();it != edp[to[i]].end();++it)
					edp[p].push_back(*it),TRIE::insert(w[*it],1);
				vector<int>().swap(edp[to[i]]);
			}
	}
}
int main()
{
	scanf("%d%s",&n,s + 1);
	for(register int i = 1;i <= n;++i)
		scanf("%d",w + i);
	scanf("%d%d",&L,&R);
	for(register int i = 1;i <= n;++i)
		SAM::insert(s[i] - 'a',i);
	SAM::build(),SAM::dfs(1);
	printf("%d\n",ans);
}
```

---

## 作者：Mivik (赞：1)

> 给定字符串 $S$，每一位额外有权值 $v_i$，求有多少对 **无序的** 本质相同但出现位置不同的子串（右端点分别为 $r_1,r_2$）满足 $L\le (v_{r_1}\oplus v_{r_2})+len\le R$，其中 $L$、$R$ 为给定参数。答案对 $998244353$ 取模。
>
> $1\le |S|,v_i,L,R\le 10^5$

[原题链接](https://www.luogu.com.cn/problem/P7279)

---

[欢迎到我的博客查看](https://mivik.gitee.io/2021/solution/alpha1022-fragment/)

~~所以为什么考场上我盯着甚至已经把 Trie 写好的暴力看了半天都没想到启发式合并（）~~

考虑枚举端点 $r_1,r_2$，然后记 $l$ 为 $|\operatorname{lcp}(S_{1,r_1},S_{1,r_2})|$，这个可以用 SAM 求。然后这对 $r_1,r_2$ 的贡献就是 $\sum_{i=1}^l \left[L-i\le \left(v_{r_1}\oplus v_{r_2}\right)\le R-i\right]$。把 $(v_{r_1}\oplus v_{r_2})$ 的值放到序列 $A$ 上，相当于求了 $A$ 序列的多个区间和，也就是 $A$ 二次前缀和后（记为 $B$）的单点查。具体地，原式即为 $(B_{R}-B_{R-l})-(B_{L-1}-B_{L-l-1})$。然后注意到 $A_i$ 对 $B_j$ 的贡献是 $\max\{j-i+1,0\}$，于是我们就得到了 $O(n^2)$ 做法。

然后考虑启发式合并 $endpos$。于是我们需要维护一个集合 $S$，支持查询对于给定的 $x$ 和 $lim$，$\sum_{v\in S}\max\{lim-v,0\}$ 的值，也就是要维护 $\sum_{v\in S}\left[(v\oplus x)\le lim\right]$ 和 $\sum_{v\in S}(v\oplus x)$ 的值。这个可以用 01 Trie 做到插入查询 $O(\log^2V)$。于是这道题就做完了，时间复杂度 $O(n\log^3n)$。

[mivik.h](https://mivik.gitee.io/mivik.h)

[代码](https://paste.ubuntu.com/p/nrbCDnZ8vd/)


---

## 作者：Y_B_X (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P7279)

>题意：  
对求出无序子串对 $(S[l1\dots r1],S[l2\dots r2])$ 的个数，  
满足 $S[l1\dots r1]=S[l2\dots r2]$ 且 $L\leq a_{r1} \operatorname{xor} a_{r2}+r1-l1+1\leq R$。  
其中 $L,R,a_{1\dots |S|}$ 是给定的。

首先，$L,R$ 的限制可以通过差分转为 $\geq lim$ 的贡献，算两次。

所以只需看 $a_{r_1} \operatorname{xor} a_{r_1}+r1-l1+1\geq lim$。

扔到 $\text{SAM}$ 的 $\text{parent}$ 树上后，对每个子串的 $\text{endpos}$ 考虑。设点 $i,j$ 分别对应原序列中 $r_1,r_2$ 的位置，$x=\operatorname{lca}(i,j)$ ，则上式为 $a_{r_1}\operatorname{xor} a_{r_2}+[1,len_x]\geq lim$ 。其中 $[1,len_x]$ 是因为任何比其 $\text{lcs}$ 短的子串都能相等。（$[1,len_x]$ 指这一段区间，写法可能不规范但应该容易理解）

注意此时每个 $a_{r_1}\operatorname{xor}a_{r_2}$ 只要满足以上条件都会算入一次，因为会对应不同位置的子串。

也就是说，如果 $a_{r_1}\operatorname{xor}a_{r_2}\geq lim-1$ ，则 $[1,len_x]$ 区间内都能满足条件，会被算入 $len_x$ 次，只需求出个数。但如果 $a_{r_1}\operatorname{xor}a_{r_2}\in[lim-len_x,lim-1)$ ，则会被算入 $a_{r_1}\operatorname{xor}a_{r_2}-lim+len_x+1$ 次，这就要求出个数，以及这部分的和。

分析到此结束，实现呼之欲出。

对每个 $x$，统计子树内路径 $\text{lca}$ 为 $x$ 的贡献。

通过 $\text{dsu on tree}$ 把之前子树内的 $a_{r_1}$ 插到 $\text{01trie}$ 中，遍历轻儿子子树时先算作为 $a_{r_2}$ 的贡献，然后再将其插入 $\text{01trie}$。

而算贡献时要用 $\text{01trie}$ 求出 $\operatorname{xor}v$ 后 $\geq k$ 的个数，以及和。

在 $\text{01trie}$ 上找出 $v\operatorname{xor} s=k$ 的一条链 $s$ ，如果这一位上 $k$ 为 $0$ ，则找到 $s$ 的另一个儿子，使这一位为 $1$。个数即为子树和，而求和可以在 $\text{01trie}$ 上拆位实现。由于是 $\geq k$，最终到的点同样要算入。

时间复杂度为 $O(n\log^3 n)$，$\text{dsu on tree，01trie}$ 以及拆位各带一个 $\log$ ，空间复杂度为 $O(n\log^2 n)$。

代码：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+10,K=20,mod=998244353;
int n,m,x,y,xx,last=1,tot=1,ts,rt,t_tot,ti,l,lx,ksb;
int lim_l,lim_r,zt1[2],zt2[2];ll tmp,tmps,tt,tts,res,ans;
int mxlen[N<<1],pos[N<<1],link[N<<1],trans[N<<1][26];
int to[N<<1],nextn[N<<1],h[N<<1],edg;bool b,bb,tb[K+1];
int size[N<<1],son[N<<1],w[N<<1],a[N];char ch,s[N];
inline void read(int &x){
	x=0;ch=getchar();while(ch<48)ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
void write(int x){if(x>9)write(x/10);putchar(48+x%10);}
inline void extend(char a){
	y=last;ts=++tot;mxlen[ts]=mxlen[y]+1;
	for(;y&&!trans[y][a];y=link[y])trans[y][a]=ts;
	if(!y)link[ts]=1;
	else {
		x=trans[y][a];
		if(mxlen[x]==mxlen[y]+1)link[ts]=x;
		else {
			xx=++tot;link[xx]=link[x];mxlen[xx]=mxlen[y]+1;
			memcpy(trans[xx],trans[x],sizeof(trans[xx]));
			for(;trans[y][a]==x;y=link[y])trans[y][a]=xx;
			link[ts]=link[x]=xx;
		}
	}
	last=ts;
}
inline void add(int x,int y){to[++edg]=y;nextn[edg]=h[x],h[x]=edg;}
void init(int x){
	int i,y;size[x]=1;
	for(i=h[x];y=to[i];i=nextn[i]){
		init(y);size[x]+=size[y];
		if(size[y]>size[son[x]])son[x]=y;
	}
}
struct trie{int son[2],sz,t[K+1];}t[N*(K+1)];
void update(int &k,int x,int i,int v){
	if(!k)k=++t_tot;t[k].sz+=v;
	for(ti=K;~ti;--ti)if(tb[ti])t[k].t[ti]+=v;
	if(~i)update(t[k].son[(x>>i)&1],x,i-1,v);
}
void inquiry(int k,int x,int i){
	if(~i){
		b=(l>>i)&1;bb=b^((x>>i)&1);
		if(!b)tmp+=t[t[k].son[!bb]].sz;
		inquiry(t[k].son[bb],x,i-1);
	}
	else tmp+=t[k].sz;
}//求个数
void inquirys(int k,int x,int i){
	if(~i){
		b=(l>>i)&1;bb=b^((x>>i)&1);
		if(!b&&(ksb=t[k].son[!bb])){
			for(ti=K;~ti;--ti){
				if(tb[ti])tmps=(tmps+(1ll<<ti)*(t[ksb].sz-t[ksb].t[ti]+mod)%mod)%mod;
				else tmps=(tmps+(1ll<<ti)*t[ksb].t[ti]%mod)%mod;
			}
		}
		inquirys(t[k].son[bb],x,i-1);
	}
	else if(k)tmps=(tmps+1ll*t[k].sz*l)%mod;
}//求和
inline void update(int x,int v){
	for(ti=K;~ti;--ti)tb[ti]=(x>>ti)&1;
	update(rt,x,K,v);
}
inline void inquiry(int x,int lim,bool b){
	tmp=0;l=zt1[b];inquiry(rt,x,K);
	res=(res+tmp*lx%mod)%mod;tt=tmp;//>=lim-1的个数
	tmp=0;l=zt2[b];inquiry(rt,x,K);tt=tmp-tt;
	for(ti=K;~ti;--ti)tb[ti]=(x>>ti)&1;
	tmps=0;l=zt2[b];inquirys(rt,x,K);tts=tmps;
	tmps=0;l=zt1[b];inquirys(rt,x,K);tts-=tmps;
	res=(res-tt*(lim-lx-1+mod)%mod+tts)%mod;
//求[lim-lx,lem-1)的个数以及和
}
inline void inquiry(int x){
	res=0;inquiry(x,lim_l,false);ans=(ans+res)%mod;
	res=0;inquiry(x,lim_r,true);ans=(ans-res)%mod;
}
void calc(int x){
	if(pos[x])inquiry(w[x]);register int i,y;
	for(i=h[x];y=to[i];i=nextn[i])calc(y);
}
void dfs(int x){
	if(pos[x])update(w[x],1);register int i,y;
	for(i=h[x];y=to[i];i=nextn[i])dfs(y);
}
void clear(int x){
	if(pos[x])update(w[x],-1);register int i,y;
	for(i=h[x];y=to[i];i=nextn[i])clear(y);
}
void solve(int x){
	register int i,y;
	for(i=h[x];y=to[i];i=nextn[i])if(y^son[x])solve(y),clear(y);
	if(son[x])solve(son[x]);
	if(lx=mxlen[x]){
		zt2[0]=max(lim_l-lx,0);zt2[1]=max(lim_r-lx,0);//注意要和0取max
		if(pos[x])inquiry(w[x]),update(w[x],1);
		for(i=h[x];y=to[i];i=nextn[i])if(y^son[x])calc(y),dfs(y);
	}
}
main(){
	while(ch<97)ch=getchar();register int i;
	while(ch>96)s[++n]=ch-'a',ch=getchar();
	for(i=1;i<=n;++i)extend(s[i]),pos[ts]=i;
	for(i=2;i<=tot;++i)add(link[i],i);init(1);
	for(i=1;i<=n;++i)read(a[i]);init(1);
	for(i=1;i<=tot;++i)if(pos[i])w[i]=a[pos[i]];
	read(lim_l);zt1[0]=max(lim_l-1,0);
	read(lim_r);zt1[1]=lim_r;++lim_r;
	solve(1);ans=(ans%mod+mod)%mod;write(ans);
}
```


---


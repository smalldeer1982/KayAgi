# [COCI 2018/2019 #3] Sajam

## 题目背景

原时限 5s，这里设为 1s，经测试正确算法可以正常通过。

Milo 组织了一场圣诞游园会。结束后，他想通过 LEET 来实现熄灯。

## 题目描述

每个区域都由 $N$ 行组成，其中每行有 $N$ 个摊位。现有 $3$ 种操作方式改变发光状态指将原来发光的灯改为熄灭，反之亦然）：

1. LEET 将选定一整行，并自动将这行所有的灯改变发光状态。
2. LEET 将选定一整列，并自动将这列所有的灯改变发光状态。
3. Milo 将选定一个摊位，并手动将该摊位的灯改变发光状态。

是否有方案使得 Milo 能在最多进行 $K$ 次操作 3 的情况下，将所有灯全部熄灭？

## 说明/提示

#### 样例 3 解释

一种符合题意的方案：

- 执行操作 $2$，选定第 $1$ 列。
- 执行操作 $3$，选定 $(2,2)$。
- 执行操作 $1$，选定第 $2$ 行。
- 执行操作 $2$，选定第 $4$ 列。
- 执行操作 $3$，选定 $(3,3)$。

#### 数据规模与规定

对于 $15$ 分的数据，$K=0$。

对于另外 $15$ 分的数据，$N \le 100$。

对于另外 $30$ 分的数据，$K \lt \dfrac{N}{2}$。

对于 $100\%$ 的数据，$1 \le N \le 1000$，$0 \le K \le N$。

#### 说明

**本题分值按 COCI 原题设置，满分 $90$。这里只选取其中具有梯度的 $18$ 个测试点进行评测。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T3 Sajam_。**

## 样例 #1

### 输入

```
2 0
ox
ox```

### 输出

```
DA```

## 样例 #2

### 输入

```
3 1
ooo
xoo
oox```

### 输出

```
NE```

## 样例 #3

### 输入

```
4 2
oxxo
xxox
oxoo
oxxo```

### 输出

```
DA```

# 题解

## 作者：Bronya18C (赞：13)

由于本题原唯一题解是错误的贪心，现提供一种有正确性证明的方法。

---

> 给一个 $n \times n$ 的 $01$ 矩阵，每次使一行或一列状态反转，问能否用若干次操作后使得最终矩阵的 $1$ 的个数 $\le k$。

---

本题关键条件为 $k \le n$，不运用此条件我们的贪心无从下手。

这里我们分成两类情况：

- $k<n$
           
  因为我们最多使用 $k$ 次操作 3 将原矩阵 $1$ 变为 $0$，所以经过操作 1 或 2 后的矩阵 $1$ 的个数 $g$ 满足 $g \le k \lt n$ 。

  运用鸽巢原理可知 $n$ 行里至少有一行全为 $0$。

  我们枚举全为 $0$ 的行，然后我们发现对于当前情况，每一列的操作情况是固定的。
  
  由于操作为一整行或列反转，因此每一列或行操作次数要么是 $0$ 要么是 $1$，否则可以等价于 $0$ 或 $1$。
  
  现在我们固定了一行 $i$，规定它最终一定要是 $0$，则对于每一列 $j$，$a_{i,j}=0$ 则这一列不操作，否则 $a_{i,j}=1$ 一定要操作。
  
  然后我们对其他行进行列的操作（其实相当于异或上 $a_i$ ），然后每一行最后可以进行贪心是否反转，因为列已经固定，且此行的操作不会对其他行有影响。
  
  即对于每个枚举的行 $i$ 统计 $ans_i=\sum\limits_{j\not=i} {\min \{\sum_{l=1}^{n}{a_{i,l} \oplus a_{j,l}} , n-\sum_{l=1}^{n}{a_{i,l} \oplus a_{j,l}}\}}$（其中 $\oplus$ 表示异或）。
  
  最后看是否存在一行 $i$，满足 $ans_i \le k$。
  
  暴力枚举 $i,j,l$ 是 $\mathcal O(n^3)$ 的。
  
  用 ```bitset``` 优化可做到 $\mathcal O(\dfrac{n^3}{w})$ 。
  
- $k=n$
 
  同理，我们首先判断是否能够存在至少有一行全为 $0$ 的解，同 $k<n$ 的情况。
  
  但 $k=n$ 可能会存在最终每一行恰好都有一个 $1$ 的解。
  
  我们枚举第一行的哪一位是 $1$，然后先将其异或上 $1$（相当于提前用一次操作 3），此时最终第一行就是全为 $0$ 了。
  
  此时用了一次操作 3，相当于 $k=n-1$，将第 1 行行当作 $k<n$ 情况中的全为 $0$ 的那行 $i$ 进行求解即可。
  
  枚举第一行的某一位复杂度为 $\mathcal O(n)$，再枚举剩下的每行每位复杂度为 $\mathcal O(n^2)$，再用 ```bitset``` 优化同样可以做到 $\mathcal O(\dfrac{n^3}{w})$。
  
总时间复杂度 $\mathcal O(\dfrac{n^3}{w})$。

---

```cpp
int n,k;
bitset<1005>st[1005];
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		char s[1005];
		scanf("%s",s+1);
		for(int j=1;j<=n;j++)
			if(s[j]=='o')st[i][j]=1;
	}
	if(k==n){
		for(int i=1;i<=n;i++){
			st[1].flip(i);
			bool chk=false;
			for(int j=2;j<=n;j++){
				st[j]=st[1]^st[j];
				if(min(st[j].count(),n-st[j].count())>1){
					chk=true;st[j]=st[1]^st[j];
					break;
				}
				st[j]=st[1]^st[j];
			}
			if(!chk){
				puts("DA");
				return 0;
			}
			st[1].flip(i);
		}
	}
	for(int i=1;i<=n;i++){
		int sum=0;
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			st[j]=st[j]^st[i];
			sum+=min(st[j].count(),n-st[j].count());
			st[j]=st[j]^st[i];
		}
		if(sum<=k){
			puts("DA");
			return 0;
		}
	}
	puts("NE");
	return 0;
}
```

---

## 作者：bai_tang (赞：3)

只要有信念，就一定能成功！

### [题意](https://www.luogu.com.cn/problem/P7315)
给定一个 $n\times n$ 的 $01$ 矩阵，可以翻转一行或一列，判定能否使得 $1$ 的个数不超过 $k$，$0\le k\le n\le 10^3$。

### 分析
此题一开始想要建立模型恐怕会没什么头绪，不妨沉下心来，考虑一些简单而基本的情况，还有题目中的特殊限制 $k\le n$，没有它问题可能更加困难。

因为 $1$ 的个数显然最小化有的时候也是 $O(n^2)$ 的，比如说只有左上角 $\lfloor n/2\rfloor\times \lfloor n/2\rfloor$ 的矩阵留黑其它留白。

考虑部分分的情况，$k=0$ 的情况应该如何判定，手玩几组样例即可发现此规律，即只考虑列，那么每列要么与第一行相等，要么相反，通过它可以给出一个线性的判定。

结合一个有趣的特殊性质：$k\le n$，我们醒悟，并且似乎可以寻找到一个可行的判定。

如果存在一种可行解使得任何一行没有被改变，那么我们就可以用这一行确定出这个可行解的较小花费具体是多少，暴力枚举可以 $O(n^3)$ 判定。

如果不存在，那么剩下的情况就是 $k=n$，并且存在一组解使得每行恰好有一个位置被改变了，枚举每一行哪个位置被改变，我们仍然可以在 $O(n^3)$ 的时间内判定解是否存在。

最后，这个过程可以利用 bitset 优化，所以最终的复杂度即为 $O(n^3/w)$，[代码](https://www.luogu.com.cn/paste/its5bttm)。

---

## 作者：Ecrade_ (赞：3)

首先可以观察到，灯泡由全灭状态经过若干次操作 1 和操作 2 后，任意两行的状态要么完全相同，要么完全相反。

注意到题目中给出了 $k \le n$ 的条件，而由鸽巢原理可知，要么存在一行没有被进行过操作 3，要么 $k=n$ 且每行均恰被进行了一次操作 3。

若第 $i$ 行没有被进行过操作 3，那么我们可以将其作为模板，并要求其它行的状态与之完全相同或完全相反。具体地，若第 $j$ 行与第 $i$ 行有 $x$ 位不相同，则我们最少需要 $\min(x,n-x)$ 次操作 3 才能使第 $j$ 行满足条件，当每行所需操作 3 的总数不超过 $k$ 时，则说明存在符合题意的方案。对 $i=1,2,\dots,n$ 进行判定即可。

若 $k=n$ 且每行均恰被进行了一次操作 3，那么我们枚举第一行被进行了操作 3 的位置，接着将其作为模板进行判定即可。

计算两行有几位不相同时，可以使用 bitset 优化。

时间复杂度 $O(\frac{n^3}{\omega})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,k,dif[1009];
bitset <1009> bt[1009];
char s[1009];
inline ll read(){
	ll s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
int main(){
	n = read(),k = read();
	for (ll i = 1;i <= n;i += 1){
		scanf("%s",s + 1);
		for (ll j = 1;j <= n;j += 1){
			bt[i][j] = s[j] == 'o';
		}
		for (ll j = 1;j < i;j += 1){
			ll qwq = (bt[i] ^ bt[j]).count();
			dif[i] += min(qwq,n - qwq);
			dif[j] += min(qwq,n - qwq);
		}
	}
	for (ll i = 1;i <= n;i += 1){
		if (dif[i] <= k){
			puts("DA");
			return 0;
		}
	}
	if (k == n){
		for (ll i = 1;i <= n;i += 1){
			bt[1][i].flip();
			ll res = 1;
			for (ll j = 2;j <= n;j += 1){
				ll qwq = (bt[1] ^ bt[j]).count();
				res += min(qwq,n - qwq);
			}
			if (res <= k){
				puts("DA");
				return 0;
			}
			bt[1][i].flip();
		}
	}
	puts("NE");
	return 0;
}
```


---

## 作者：Mr_Az (赞：1)

# [P7315 [COCI 2018/2019 #3] Sajam](https://www.luogu.com.cn/problem/P7315)

**双倍经验：** [**P10554 [ICPC 2024 Xi'an I] Turn Off The Lights**](https://www.luogu.com.cn/problem/P10554)。

两题差别为下表：

| 差别       | P7315 [COCI 2018/2019 #3] Sajam | P10554 [ICPC 2024 Xi'an I] Turn Off The Lights |
| ---------- | ------------------------------- | ---------------------------------------------- |
| 输出方案   | 不需要                          | 需要                                           |
| $k$ 的范围 | $k \le n$                       | $k < n$                                        |

快去偷圈！

### Algorithm:

神秘观察+构造。

### Solution:

令 $a_i$ 为第 $i$ 行的**亮灯**情况，$b_i$ 为第 $i$ 行**熄灯**情况，两者互为补集。

对于这道题目，上来是没有头绪的，我们考虑从特殊情况开始思考。

##### $k=0$ 的情况:

此时**不能**单独修改特定格子，容易发现存在**合法**操作方案的条件为**每一行亮灯状况与第一行相同或恰好相反**，$O(N)$ 判断即可。

##### $k < n$ 的情况:

此时**可以**修改一些格子，**但是由于鸽巢原理，总有一行是没有被修改的**。注意到这个之后，我们只需要枚举**每一行作为没有被修改的**。设当前枚举第 $i$ 行，仿照 $k=0$ 时候的方法进行判断，将每一行与 $a_i$ 或 $b_i$ 取异或，这样可以找出来他们与第 $i$ 行**不同的位置个数**，对 $b_i$ 取异或的目的是这一行可以通过题目中的 $1$ 操作进行取反。如果不同的位数 $\le k$ 那么存在合法解。

##### $k=n$ 的情况：

如果你能想出来 $k<n$ 的情况，那这个情况就非常显然了。

此时存在两种情况，对应的处理方式如下：

1. 同上面**有一行没有修改**，判断同上。

2. 所有行都只有一个位置被修改，枚举第 $1$ 行修改的位置后，判断同上。

时间复杂度：直接暴力 $O(N^3)$，但是我们有 `bitset`！所以可以优化为 $O(\frac{N^3}{\omega})$。

### Code:

```cpp
namespace Mr_Az{
	int T=1;
	const int N=1008;
	int n,k;
	char ch;
	bitset<N> a[N],t;
	inline void solve(){
		read(n,k);
		for(rint i=1;i<=n;i++){
			for(rint j=1;j<=n;j++){
				scanf(" %c",&ch);
				a[i][j]=ch=='o';
			}
		}
		for(rint i=1;i<=n;i++) t[i]=1;
		for(rint i=1;i<=n;i++){
			int cnt=0;
			for(rint j=1;j<=n;j++){
				cnt+=min((a[i]^a[j]).count(),(a[i]^t^a[j]).count());
			}// a[i]^t 即为 ~a[i]
			if(cnt<=k){
				puts("DA");
				return ;
			}
		}
		if(n==k){
			for(rint i=1;i<=n;i++){
				a[1].flip(i);
				for(rint j=2;j<=n;j++){
					if((a[1]^a[j]).count()!=n-1&&(a[1]^t^a[j]).count()!=n-1) goto end;
				}
				puts("DA");
				return ;
				end:;
				a[1].flip(i);
			}
		}
		puts("NE");
		return ;
	}
	inline void mian(){if(!T) read(T);while(T--) solve();}
}
```

---

## 作者：hegm (赞：1)

题目是让你对一个矩阵进行修改：

1. 列翻转

2. 行翻转

3. 单点翻转

由于我们的目的是使用最少次数的 $3$ 操作将矩阵变为全 `0`。

而且容易发现一个性质，操作的先后顺序不影响最终结果，所以我们容易想到，使用 $1,2$ 操作，将 `1` 的数量最小化，最后统计 `1` 的数量，就知道了最少的操作次数。

那么如何操作能够保证我们的 `1` 的数量最少。

如果你仔细观察数据范围，容易发现：

对于 $100\%$ 的数据，保证 $0\le k\le n$。

要知道，$k$ 是能容忍的 $1$ 的数量最多的情况，我们可以非常容易的构造出一个 $k>n$ 的矩阵。

$$\begin{bmatrix}0&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\\0&0&1&1&0\\0&0&1&0&1\end{bmatrix}$$

容易发现，上面的矩阵最少 `1` 的数量就是 $6$。

因此对于这种特殊的性质，我们需要仔细思考并且利用。

以下称最佳状态为只进行 $1,2$ 操作后 `1` 的数量最少的矩阵。

我们分讨

1. $k<n$，这个情况有什么优美的性质？根据鸽巢原理，一定有一行没有 `1`，所以我们考虑以此为关键下手，我们枚举全是 `0` 的行是哪一个，对于这一行，我们是不能进行 $3$ 操作的，所以我们只能使用列翻转，将这一行全部变为 `0`，那么我们只剩下了行操作和单点操作，容易发现，我们的每个操作只会影响某一行，行与行之间已经无关了，所以对于某一行，我们看他进行行翻转和不进行哪一个 `1` 的数量更少即可，最后的上限就是所有行的答案之和。
    
2. $k=n$，这个情况依然需要进行上面的操作，但是他多了一种情况，每一行都恰好有一个 `1`，那么我们枚举第一行的这个 `1` 的位置，显然其他位置只能通过列操作将它们变为 `0`，那么我们依然只有行操作和单点了，再沿用上面的方法即可。

容易发现两种情况的复杂度都是 $O(n^3)$，但是发现我们进行的操作只有单点/行/列翻转，统计 `1` 的个数，所以我们使用 $\text{bitset}$ 优化即可。

正解复杂度 $O\left(\dfrac{n^3}{w}\right)$

---

## 作者：fish_love_cat (赞：0)

想出来一半然后不会了 /kel

---

手玩发现不用操作三可以做到令每一行间要么完全不同，要么完全相同。

注意到 $k\le n$，所以合法局面一定可以转化为两种情况：

 1. 当 $k\le n$，存在一行没有亮着的灯。

 2. 当 $k=n$，除上面一种情况外，还可能每行都有一个亮着的灯。

局面 1 是好做的，我们只需要枚举每一行钦定其无灯，然后取使其合法的最小代价即可。

然后我不会做局面 2 了 /qd

但是想到这里你可以先去把 [P10554](https://www.luogu.com.cn/problem/P10554) 过了，那题保证 $k<n$。

```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<1005>a[1005];
int ans=1e9;
int main(){
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++){
        char c;
        cin>>c;
        // a[i][j]=c=='o';
        a[i][j]=c=='1';
    }
    for(int i=1,sum=0;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(i==j)continue;
            bitset<1005>flc(a[i]^a[j]);
            sum+=min(n-(int)flc.count(),(int)flc.count());
        }
        ans=min(ans,sum),sum=0;
        //下面输出方案
        if(ans<=k){
            vector<pair<int,int> >ans;
            for(int j=1;j<=n;j++){
                if(i==j)continue;
                bitset<1005>flc(a[i]^a[j]);
                if(n-(int)flc.count()<(int)flc.count()){
                    for(int g=1;g<=n;g++)
                    if(a[j][g]==a[i][g])ans.push_back(make_pair(j,g));
                    ans.push_back(make_pair(j,0));
                }else{
                    for(int g=1;g<=n;g++)
                    if(a[j][g]!=a[i][g])ans.push_back(make_pair(j,g));
                }
            }
            for(int j=1;j<=n;j++)
            if(a[i][j])
            ans.push_back(make_pair(0,j));
            cout<<ans.size()<<'\n';
            for(int i=0;i<ans.size();i++)
            cout<<ans[i].first<<' '<<ans[i].second<<'\n';
            return 0;
        }
    }
    // puts(ans<=k?"DA":"NE");
    puts("-1");
    return 0;
}
```

返回局面 2，我们可以钦定第一行的某一位亮着，然后对其操作 3 转变回局面 1，然后直接做就行了。

由于行的顺序无关，所以操作非第一行的相同位与直接对第一行做是等价的，于是不用考虑其他情况了。

```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<1005>a[1005];
int ans=1e9;
int main(){
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++){
        char c;
        cin>>c;
        a[i][j]=c=='o';
    }
    for(int i=1,sum=0;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(i==j)continue;
            bitset<1005>flc(a[i]^a[j]);
            sum+=min(n-(int)flc.count(),(int)flc.count());
        }
        ans=min(ans,sum),sum=0;
    }
    for(int i=1,sum=1;i<=n&&k==n;i++){
        bitset<1005>flc(a[1]);
        if(flc[i])flc[i]=0;
        else flc[i]=1;
        for(int j=2;j<=n;j++){
            bitset<1005>clf(flc^a[j]);
            sum+=min(n-(int)clf.count(),(int)clf.count());
        }
        ans=min(ans,sum),sum=1;
    }
    puts(ans<=k?"DA":"NE");
    return 0;
}
```

---


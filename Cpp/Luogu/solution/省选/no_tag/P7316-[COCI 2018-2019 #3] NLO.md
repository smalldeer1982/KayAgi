# [COCI 2018/2019 #3] NLO

## 题目描述

给定一个 $N \times M$ 的矩形麦田。麦田的每个区域都生长有一定量的草。所有区域的初始草量均为 $1$。

在 $K$ 天内，圆形的 UFO 将降落在麦田上并画圆。在第 $i$ 天早上，一个半径为 $R_i$ 的 UFO 将降落在区域 $(X_i,Y_i)$，并使得以该区域为圆心，$R_i$ 的半径内的所有区域将会受到影响。如果一个区域 $(x,y)$ 受到影响，且 $(X_i-x)^2+(Y_i-y)^2 \le R_i^2$，则该区域的草量将降为 $0$。在新的一天到来时，每个区域的草量都会增加 $1$。

求在第 $K$ 天晚上，所有区域的草量之和。

## 说明/提示

#### 样例 1 解释

第一天晚上的麦田：

|$1$|$1$|$1$|$1$|$1$|$1$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$1$|$1$|$1$|$\red 0$|$1$|$1$|
|$1$|$1$|$\red 0$|$\red 0$|$\red 0$|$1$|
|$1$|$\red 0$|$\red 0$|$\red 0$|$\red 0$|$\red 0$|
|$1$|$1$|$\red 0$|$\red 0$|$\red 0$|$1$|
|$1$|$1$|$1$|$\red 0$|$1$|$1$|

第二天晚上的麦田：

|$2$|$2$|$\red 0$|$2$|$2$|$2$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$2$|$\red 0$|$\red 0$|$\red 0$|$2$|$2$|
|$\red 0$|$\red 0$|$\red 0$|$\red 0$|$\red 0$|$2$|
|$2$|$\red 0$|$\red 0$|$\red 0$|$1$|$1$|
|$2$|$2$|$\red 0$|$1$|$1$|$2$|
|$2$|$2$|$2$|$1$|$2$|$2$|

第三天晚上的麦田：

|$3$|$3$|$1$|$\red 0$|$3$|$3$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$3$|$1$|$\red 0$|$\red 0$|$\red 0$|$3$|
|$1$|$1$|$1$|$\red 0$|$1$|$3$|
|$3$|$1$|$1$|$1$|$2$|$2$|
|$3$|$3$|$1$|$2$|$2$|$3$|
|$3$|$3$|$3$|$2$|$3$|$3$|

因此总草量为 $68$ 单位。

#### 数据规模与约定

对于 $20\%$ 的数据，$N,M \le 1000$。

对于 $100\%$ 的数据，$1 \le N,M \le 10^5$，$1 \le K \le 100$，$1 \lt X_i \lt N$，$1 \lt Y_i \lt M$，$1 \le R_i \le \min(X_i-1,Y_i-1,N-X_i,M-Y_i)$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T4 NLO_。**

## 样例 #1

### 输入

```
6 6
3
4 4 2
3 3 2
2 4 1```

### 输出

```
68```

## 样例 #2

### 输入

```
100 100
2
50 50 49
30 30 29```

### 输出

```
9534```

## 样例 #3

### 输入

```
33333 44444
1
11111 22222 9999```

### 输出

```
1167355751```

# 题解

## 作者：FQ04gty (赞：5)

##### [原题链接](https://www.luogu.com.cn/problem/P7316)

---

考虑最后的麦田图形，可以发现，如果一个格子最后一次被飞碟降落是在第 $i$ 天，那么最后的数字是 $k-i$。

可以知道每个圆对一行的影响是一段区间，因此对每一行分别处理。

对于每一行，从后面的圆开始考虑，一次次将该圆的区间覆盖，统计本次新覆盖了多少个点，使答案加上点数乘以本次的权值，即 $k-i$，再将区间覆盖。最后再统计没有被覆盖的点数量乘上 $k$。

显然可以将每行要操作的区间边界离散化从而加速考虑区间。

时间复杂度 $O(nk^2)$。但是由于不是每一次都会完整覆盖每一行，所以跑不满。

由于 $k$ 很小，这里采用 $\log$ 级别的数据结构优化可能不会快多少。

如果手写 bitset 来进行每一次的区间统计和修改操作，则可以将时间复杂度优化到 $O(\frac{nk^2}{w})$。

空间复杂度 $O(n)$。

### Code

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#define pow(x) ((x)*(x))
#define mset(arr,val) memset(arr,val,sizeof(arr))
using namespace std;
const int SIZE=2e2+10,EXTRA=1e5+10;
typedef long long ll;
inline int read()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x*10)+(ch^48),ch=getchar();
    return x;
}
int n,m,k,X[SIZE],Y[SIZE],R[SIZE],bin[SIZE],trans[EXTRA],s[SIZE],t[SIZE],top;
ll ans;
bool use[SIZE];
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=k;i++)X[i]=read(),Y[i]=read(),R[i]=read();
    for(int l=1,uniq;l<=n;l++)
    {
        mset(bin,0),top=0,mset(use,0),s[0]=0,t[0]=m,bin[++top]=s[0],bin[++top]=t[0];
        for(int i=1,len;i<=k;i++)
        {
            if(R[i]<abs(X[i]-l))continue;
            len=sqrt(pow(R[i])-pow(X[i]-l)),s[i]=Y[i]-len-1,t[i]=Y[i]+len,bin[++top]=s[i],bin[++top]=t[i];
        }
        sort(bin+1,bin+top+1),uniq=unique(bin+1,bin+top+1)-bin-1;
        for(int i=1;i<=uniq;i++)trans[bin[i]]=i;
        for(int i=0,ts,tt;i<=k;i++)ts=trans[s[i]],tt=trans[t[i]],s[i]=ts,t[i]=tt;
        int res;
        for(int i=k;i;i--)
        {
            if(R[i]<abs(X[i]-l))continue;
            res=0;
            for(int j=s[i]+1;j<=t[i];j++)if(!use[j])res+=bin[j]-bin[j-1],use[j]=true;
            ans+=(k-i)*res;
        }
        res=0;
        for(int j=2;j<=uniq;j++)if(!use[j])res+=bin[j]-bin[j-1];
        ans+=k*res;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Super_Cube (赞：3)

# Solution

注意到 $k\le 100$，可以离线对每一行单独算答案。假设现在枚举的是第 $i$ 行，那么第 $j$ 个 UFO 对其的影响为：若 $|i-x_j|>r_j$，无影响；否则设 $s=\left\lfloor\sqrt{{r_j}^2-(i-x_j)^2}\right\rfloor$，会对第 $i$ 行的 $[y_j-s,y_j+s]$ 产生影响。按照题目所说，每个 UFO 降临后除被影响区域外全部草量会加一，于是枚举 UFO 时对于会产生影响的 UFO 中第 $i$ 行的 $[y_j-s,y_j+s]$ 置为 $-1$，并对整行加一，最后查询整行的和就是该行最终贡献。

利用线段树做到区间赋值，全局加一，全局查询，时间复杂度：$O(nk\log m)$。

---

## 作者：Feyn (赞：3)

[link](https://www.luogu.com.cn/problem/P7316)

考完后发现就我一个带冤种苦哈哈地在写线段树，代码又长跑得又慢，果然还是太弱了。但这种方法也有其优点，即不需要脑子也能写。

圆是不好处理的，因为它的边缘是无规律的（反正我没发现）。一开始想着能不能有类似数论分块的方法把圆分割成一些矩形，但搞了几个大圆的数据发现分割出的矩形数目始终和半径同级，于是这条路就堵死了。其它大佬有方法，但我看不懂（呜呜呜）。

最后蒟蒻想到一种不是办法的办法，枚举每一列之后考虑每个圆对它的影响，显然每个圆会对一整段区间造成影响，假如按时间从前向后考虑，可以看成是后面的圆可以覆盖前面的圆，于是我们需要维护一个支持区间加和查询区间和的序列，线段树可以搞定。当然每次都重建线段树是肯定不行的，我们可以只对每次新访问的结点初始化即可，这也是惯常操作了。

复杂度 $O(MK\log N)$ ，按理说过不了。但由于跑不满上限，而且这道题时限放得比较宽，~~再加上 COCI 数据的配合~~就可以过掉这道题了。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define int long long
const int N=200010;
const int M=210;
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int m,n,num;
inline int p(int wh){
	return wh<0?-wh:wh;
}

#define lc (wh<<1)
#define rc (wh<<1|1)
#define mid (t[wh].l+t[wh].r>>1)
struct node{
	int l,r,data,lazy;
}t[N<<2];
inline void check(int wh){
	if(t[wh].lazy!=-1)return;
	t[wh].lazy=0,t[wh].data=(t[wh].r-t[wh].l+1)*num;
	t[lc].lazy=t[rc].lazy=-1;
}
inline void build(int wh,int l,int r){
	t[wh].l=l,t[wh].r=r;
	t[wh].lazy=0,t[wh].data=(r-l+1)*num;
	if(l==r)return;
	build(lc,l,mid);build(rc,mid+1,r);
}
inline void pushnow(int wh,int val){
	t[wh].lazy=val;t[wh].data=(t[wh].r-t[wh].l+1)*val;
}
inline void pushdown(int wh){
	check(wh);
	if(t[wh].lazy==0)return;
	pushnow(lc,t[wh].lazy);
	pushnow(rc,t[wh].lazy);
	t[wh].lazy=0;
}
inline void pushup(int wh){
	check(lc);check(rc);
	t[wh].data=t[lc].data+t[rc].data;
}
inline void change(int wh,int wl,int wr,int val){
	if(wl<=t[wh].l&&t[wh].r<=wr){
		pushnow(wh,val);return;
	}
	pushdown(wh);
	if(wl<=mid)change(lc,wl,wr,val);
	if(wr>mid)change(rc,wl,wr,val);
	pushup(wh);
}
#undef lc
#undef rc
#undef mid

int ans,x[M],y[M],r[M];

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(m);read(n);read(num);
	for(int i=1;i<=num;i++){
		read(y[i]);read(x[i]);read(r[i]);
	}
	build(1,1,m);
	for(int i=1;i<=n;i++){
		t[1].lazy=-1;check(1);
		for(int j=1;j<=num;j++){
			if(p(x[j]-i)>r[j])continue;
			int s=sqrt(r[j]*r[j]-(x[j]-i)*(x[j]-i));
			change(1,y[j]-s,y[j]+s,num-j);
		}
		ans+=t[1].data;
	}
	printf("%lld\n",ans);
	
	return 0;
}
```

---

## 作者：DengDuck (赞：2)

题解区好像没有提到珂朵莉树做法，我来补充一个。

~~当然，由于这里没有 Split 操作，所以与其说是珂朵莉树，不如说是 `set` 维护区间的 Trick。~~

注意到我们可以把外星人来的过程反过来做，这样每个点只有第一次染色的时候是需要计算贡献的，所以我们每次只需要统计每一行有多少个点第一次被染色。

对于一次外星人降临，每一行被染色的部分必然是一段连续的区间，所以我们现在咋维护这一过程呢？考虑到线段问题的利器是珂朵莉树，所以我们直接每次用珂朵莉树合并这些被染色的区间，同时统计出当前区间与被合并区间的交集之和即可。


目前来看，这份实现是洛谷和 LOJ 两边的最快解，理论上能优化的地方非常多。

而在 LOJ 我发现了一份[思路类似但是代码极短的实现](https://loj.ac/s/1446488)，大家可以参考一下这份。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
using namespace std;
const int N=1e5+5;
int n,m,k;
LL X[N],Y[N],R[N],Ans;
inline LL P(LL x){return x*x;}
struct Line
{
	int L,R;
	inline bool operator<(const Line &X)const
	{
		if(L!=X.L)return L<X.L;
		return R<X.R;
	}
};
int Hav(Line A,Line B){return max(0,min(A.R,B.R)-max(A.L,B.L)+1);}
struct ODT
{
	set<Line>S;
	inline int Upd(int L,int R)
	{
		if(S.empty())return  S.insert({L,R}),0;
		vector<Line>V;
		auto t=S.upper_bound({L,0});
		if(t!=S.begin())
		{
			t--;
			while(Hav(*t,{L,R})>0)
			{
				V.pb(*t);
				if(t==S.begin())break;
				t--;
			}
		}
		t=S.upper_bound({L,0});
		while(t!=S.end()&&Hav(*t,{L,R})>0)
		{
			V.pb(*t),t++;
		}
		int Ans=0,l=L,r=R;
		for(Line i:V)
		{
			S.erase(S.lower_bound(i));
			l=min(l,i.L),r=max(r,i.R),Ans+=Hav(i,{L,R});
		}
		S.insert({l,r});
		return Ans;
	}
}T[N];
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++)scanf("%lld%lld%lld",&X[i],&Y[i],&R[i]);
	X[0]=1,Y[0]=1,R[0]=1e6;
	for(int i=k;i>=0;i--)
	{
		LL x=X[i],y=Y[i],r=R[i]*R[i];
		for(LL A=1;A<=n;A++)
		{
			if(P(x-A)>r)continue;
			LL t=sqrt(r-P(x-A));
			LL BL=max(1ll,y-t),BR=min(m*1ll,y+t);
			LL Cnt=BR-BL+1-T[A].Upd(BL,BR);
			Ans+=Cnt*(k-i);
		}
	}
	printf("%lld\n",Ans);
}
```

---

## 作者：MuelsyseU (赞：1)

除离散化外 $O(nk)$ 做法。

---

一个点的贡献就是 $K$ 减去最后一次被清除的时间。

我们利用处理圆覆盖的 trick，考虑每个行至多有 $k$ 个区间被覆盖。

注意到可以离散化，那就是要支持区间推平和求和，这时候有一个朴素做法。

感觉有点危险，我们可以继续用一个 trick，反向变成维护区间尚未被覆盖的数的个数。

这时候离散化之外有一堆 $O(nk)$ 做法了，比如线段树标记永久化 / 并查集。

那瓶颈变成排序，不过小常数 $O(nk\log k)$ 非常稳，最大点不到 400ms。

```cpp
#include <bits/stdc++.h>
#define ls(p) (p << 1)
#define rs(p) (p << 1 | 1)
using namespace std;

const int maxk = 1205, maxn = 200005;
int n, m, k, al[maxk], ar[maxk], b[maxk], x[maxn], y[maxn], r[maxn];
int t[maxk];
long long ans;
long long sqr(long long x) { return x * x; }
int calc(int x) { return (x & 1) ? 1 : b[(x >> 1) + 1] - b[x >> 1] - 1; }
void build(int p, int l, int r) {
	int mid = (l + r) >> 1;
	if (l == r) t[p] = calc(l);
	else build(ls(p), l, mid), build(rs(p), mid + 1, r), t[p] = t[ls(p)] + t[rs(p)];
}
int insert(int p, int l, int r, int ql, int qr) {
	if (!t[p]) return 0;
	int tmp = t[p];
	if (ql <= l && r <= qr) return t[p] = 0, tmp;
	int mid = (l + r) >> 1, ans = 0;
	if (ql <= mid) ans += insert(ls(p), l, mid, ql, qr);
	if (qr > mid) ans += insert(rs(p), mid + 1, r, ql, qr);
	t[p] = t[ls(p)] + t[rs(p)];
//	cout << ((l + 1) / 2) << " " << ((r + 1) / 2) << " " << t[p] << endl;
	return ans;
}
signed main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= k; ++i)
		scanf("%d%d%d", x + i, y + i, r + i);
	for (int i = 1; i <= n; ++i) {
		long long ln;
		int top = 0;
		for (int j = 1; j <= k; ++j)
			if (r[j] >= abs(x[j] - i))
				ln = sqrt(sqr(r[j]) - sqr(x[j] - i)), al[j] = y[j] - ln, ar[j] = y[j] + ln, b[++top] = al[j], b[++top] = ar[j];
		b[++top] = 1, b[++top] = m, sort(b + 1, b + top + 1), top = unique(b + 1, b + top + 1) - b - 1;
		build(1, 1, top * 2 - 1), ans += m * 1ll * k;
		for (int j = k; j >= 1; --j) {
			if (r[j] < abs(x[j] - i)) continue;
			al[j] = lower_bound(b + 1, b + top + 1, al[j]) - b;
			ar[j] = lower_bound(b + 1, b + top + 1, ar[j]) - b;
			long long tmp = insert(1, 1, top * 2 - 1, al[j] * 2 - 1, ar[j] * 2 - 1);
			ans -= tmp * j;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：DevilsFlame (赞：0)

我来简单讲述一下方法思路。

#### STEP 1
正常我们使用的线段树是维护一维区间的，而本题是二维问题，所以你想到了什么？可以将二维变成若干一维问题。

#### STEP 2
数据范围往往可以给予人启发，$k$ 的范围很小，不难想到处理每一行或列时枚举 $k$ 个 UFO 对于本行或列的影响。成功的将二维问题转化成一维区间问题。

#### STEP 3
当然，处理每一维时，显然不可能用多个线段树，这就涉及到线段树初始化问题。显然不可能初始化直接初始化所有节点，要与 ```push_down``` 融合。所以我们可以取一个不可能达到的值，比如负值，在 ```push_down``` 特判，然后遗传到子节点。

#### STEP 4
细节。   
例如 STEP 3 中的 ```push_down```，在修改时，懒标记遗传到子代，不能清空，除了初始化，否则 ```push_up``` 会出问题。   
还有 $ans$ 范围不用多说了吧。

---

## 作者：_Vix_ (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P7316)

## 前言
建议评蓝，思路不是很难想，考场上两个小时线段树差点写挂（据说正解更加优秀？），因为代码常数较大，吸口氧[还是能过](https://www.luogu.com.cn/record/89588675)~~（果然还是太菜了~~

## 题意
给定一个 $N \times M$ 的矩阵，每个格子的初值均为 $0$，接下来 $K$ 天，第 $i$ 天先后发生两件事：

1. 所有格子的值加 $1$。
2. 将所有到 $(X_i,\ Y_i)$ 欧几里得距离小于等于 $R_i$ 的点值变为 $0$。

求 $K$ 天后所有格子值的总和。

范围：$1 \le N,M \le 10^5$，$1 \le K \le 100$，保证所有到 $(X_i,\ 
Y_i)$ 欧几里得距离小于 $R_i$ 的点在矩阵内。


## 分析
显然所有到定点欧几里得距离小于等于定值的点构成的集合是**圆**。

## 20 pts
直接根据题意乱搞，要么对于每个点考虑所有圆，要么对于每个圆考虑所有点，最后求和即可，时间复杂度 $O(NMK)$，空间复杂度 $O(NM)$。

## 100 pts
首先空间是可以优化的，我们可以重复使用一行，然后一行一行来做。

那么顺着思路，考虑顺序枚举每个圆对这一行的影响，易得是一个区间，并且区间端点到圆心的距离为 $R$，我们就可以将上述的两个操作变为**区间赋值和区间加**，直接用线段树维护就行了（好像可以优化枚举顺序使得只需要区间赋值，常数更优？），每次换一行时直接清空线段树就行，时间复杂度 $O(NK \log M)$，空间复杂度 $O(4M)$。

## 注意
1. 一定记得开 **long long**，答案上界是 $10^{12}$ 级别的。
2. 关于算区间端点：如果圆心为 $(x,\ y)$，半径为 $r$，当前枚举到第 $i$ 行，那么左端点就是 $x - \sqrt{(y - i)^2 - r^2}$，右端点就是 $x + \sqrt{(y - i)^2 - r^2}$。

## Code
由于本蒟蒻[代码](https://www.luogu.com.cn/paste/0nrbo48t)又臭又长，这里就不贴出来了。

---

## 作者：CQ_Bab (赞：0)

# 前言
卡空间的\*\*题。
# 思路
可以发现每一次是将一段区间赋值为 $0$ 可以想到珂朵莉树，首先我们可以想到一个 trick 就是答案为 $\sum k-lst_{i,j}$ 所以我们便可以省去整体加一的操作，每一只需要将 $l\sim r$ 区间赋值为当前的时间即可，我们考虑开 $n$ 棵珂朵莉树来维护每一行的值，可是我们发现这样会 MLE 一个点，所以考虑优化。我们可以将修改离线然后对于每一行去枚举每一次操作然后算出区间的大小再进行修改即可，这样我们只用开一棵珂朵莉树即可。
# 代码
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
const int bufsize = 230005;
char buf[bufsize], *f1, *f2;
#define getchar() (f1 == f2 && (f2 = buf + fread(f1 = buf, 1, bufsize, stdin)) == buf? EOF: *f1++)
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    int f = 1;
    while (ch < '0' || ch > '9') {if(ch=='-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
    x *= f;
}
int T=1;
const int N=1e5+10;
struct ccc{
	int x,l,r;
	friend bool operator<(const ccc&a,const ccc&b) {
		return a.x<b.x;
	}
};
int n,m,k;
struct node{
	int l,r;
	mutable int val;
	friend bool operator<(const node&a,const node&b) {
		return a.l<b.l;
	}
};
set<node>s;
auto split(int pos) {
	auto it=s.lower_bound({pos,0,0});
	if(it->l==pos) return it;
	it--;
	if(it->r<pos) return s.end();
	int L=it->l,R=it->r,v=it->val;
	s.erase(it);
	s.insert({L,pos-1,v});
	return s.insert({pos,R,v}).first;
}
void modify(int l,int r,int v) {
	auto itr=split(r+1);
	auto itl=split(l);
	s.erase(itl,itr);
	s.insert({l,r,v});
}
int x[N],y[N],z[N];
void solve() {
	in(n),in(m),in(k);
	int cc=0,lst=k;
	rep(i,1,k) in(x[i]),in(y[i]),in(z[i]);
	long long res=0;
	lst*=n;
	rep(i,1,m) {
		s.clear();
		s.insert({1,n,0});
		rep(j,1,k) {
			long long now=1ll*z[j]*z[j]-1ll*(y[j]-i)*(y[j]-i);
			if(now<0) continue;
			now=sqrt(now);
			int l=max(1ll,x[j]-now),r=min((long long)n,x[j]+now);
			modify(l,r,j);
		}
		res+=lst;
		auto itr=split(n+1),itl=split(1);
		for(;itl!=itr;itl++) res-=1ll*(itl->r-itl->l+1)*(itl->val);
	}
	printf("%lld\n",res);
}
fire main() {
	while(T--) {
		solve();
	}
	return 0;
}

```

---


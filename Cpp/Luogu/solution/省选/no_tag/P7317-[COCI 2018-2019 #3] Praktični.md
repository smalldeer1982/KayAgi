# [COCI 2018/2019 #3] Praktični

## 题目描述

给定一个包含 $N$ 个结点和 $M$ 条边的无向图。每条边有一个小于 $10^9$ 的权值。

当一个环上的所有边的权值的异或和为 $0$，该环被称作好环。

可以对无向图进行若干次操作。每次操作包含下列步骤：

- 选定一个整数 $x$。
- 选定一个包含若干条边的非空集合。
- 给该集合中每条边都异或上 $x$。

请在尽可能少的操作次数之下使得无向图中的所有简单回路都是好环。请求出最少操作次数，并输出对应的操作参数。

## 说明/提示

#### 样例 1 解释

图的初始和结束状态（在初始状态的基础上给前三条边的权值异或上 $12$）分别如下方左图和右图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zh4zuicc.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/lbmx5f8v.png)

#### 样例 2 解释

该无向图无环，因此题意已经满足，不需要进行修改，因此最少操作次数为 $0$。

#### 数据规模与约定

对于 $20\%$ 的数据，$K=1$。

对于另外 $40\%$ 的数据，输入的所有数均小于等于 $10^6$。

对于 $100\%$ 的数据，$1 \le N,M \le 10^5$，$1 \le a_i,b_i \le N$，$a_i \neq b_i$，$0 \le p_i \le 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $130$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T5 Praktični_。**

## 样例 #1

### 输入

```
4 4
1 2 10
2 3 9
3 4 8
4 1 7```

### 输出

```
1
12 3 1 2 3```

## 样例 #2

### 输入

```
2 1
1 2 3```

### 输出

```
0```

## 样例 #3

### 输入

```
6 8
1 2 6
2 3 1
3 5 6
3 1 5
4 5 0
3 6 0
4 2 8
4 1 1```

### 输出

```
2
2 2 4 6
15 1 7```

# 题解

## 作者：larsr (赞：2)

很好的一道题，~~但我没做出来~~。

先假设我们已经决定好边权值的最终值了，此时要用最少次数，很容易想到要用线性基。

那怎么决定最终值呢？首先选择在图上随便选一个生成树，如果一条非树边和它的两个端点路径的回路满足条件的话，那么这个图一定满足条件。

为什么呢？因为一边非树边和它的两个端点路径异或值相等，可以把非树边换成这条路径，那么任何一个回路，都会经过同一条边两次或不经过。

这是只改非树边是最优的，为什么呢？一个回路上更改的值的异或值是一定的，如果只更改非树边，变化量只有一个，线性基的结果也是最小的。那么求出每个非树边要更改的值即可。

时间复杂度 $O(n\log V)$。
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#define N 100010
using namespace std;
int n, m, vis[N], d[N];
struct edge
{
	int to, w, id;
};
vector<edge>e[N];
int vid[N];
int xe[N], xid[N], tot = 0;
int bit[100];
vector<int>ans[100];
void dfs(int now)
{
	vis[now] = 1;
	for(int i = 0; i < e[now].size(); i++)
		if(!vis[e[now][i].to])
		{
			d[e[now][i].to] = d[now] ^ e[now][i].w;
			dfs(e[now][i].to);
		}
}
void dfs1(int now, int fa)
{
	vis[now] = 1;
	for(int i = 0; i < e[now].size(); i++)
	{
		int to = e[now][i].to;
		if(!vis[to])
		{
			dfs1(to, now);
		}
		else if(to != fa && !vid[e[now][i].id])
		{
			tot++;
			vid[e[now][i].id] = 1;
			xe[tot] = d[now] ^ d[to] ^ e[now][i].w;
			xid[tot] = e[now][i].id;
		}
	}
}
int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++)
	{
		int a, b, p;
		scanf("%d%d%d", &a, &b, &p);
		e[a].push_back((edge){b, p, i});
		e[b].push_back((edge){a, p, i});
	}
	dfs(1);
	memset(vis, 0, sizeof vis);
	dfs1(1, 0);
	for(int i = 1; i <= tot; i++)
	{
		int now = xe[i];
		for(int j = 30; j >= 0; j--)
			if(now & (1 << j))
			{
				if(bit[j])now ^= bit[j];
				else
				{
					bit[j] = now;
					break;
				}
			}
	}
	for(int i = 1; i <= tot; i++)
	{
		int now = xe[i];
		for(int j = 30; j >= 0; j--)
			if(now & (1 << j))
			{
				ans[j].push_back(xid[i]);
				now ^= bit[j];
			}
	}
	int sum = 0;
	for(int i = 30; i >= 0; i--)
		if(bit[i])
			sum++;
	printf("%d\n", sum);
	for(int i = 30; i >= 0; i--)
	if(bit[i])
	{
		printf("%d %d ", bit[i], ans[i].size());
		for(int j = 0; j < ans[i].size(); j++)printf("%d ", ans[i][j]);
		printf("\n");
	}
	return 0;
}

```

---

## 作者：fsfdgdg (赞：1)

## 题解 P7317

### 题意简述

给定一个含 $N$ 个点，$M$ 条边的无向图，边有权值。现在你可以进行任意次操作，每次选定一个整数 $x$ 和一个边集 $S$，将 $S$ 中的所有边的权值异或上 $x$，使得最后图中每个环的边权异或和为 $0$。最小化操作次数并输出方案。

$N,M\leq 1e5$

### 前置知识

[线性基](https://www.luogu.com.cn/problem/P3812)

### 正文

首先套路地，我们可以求出原图的一棵生成树，此时所有非树边和其两个端点在树上的路径构成了一个环，原图中所有的环的权值都可以由若干个这样的环的权值异或得到（读者自证不难）。因此，现在问题转化为使所有这样的环权值为 $0$。

我们声称，**一定存在一种方案，使得只需修改非树边的权值即可**。

**证明**：首先对于每个环，都至多只需修改一次（将其对应非树边的权值异或上环的权值即可）。如果存在一种方案中修改了树边，则包含这条树边的所有环权值一定相同，此时如果不修改树边，修改它们的非树边，操作次数不变，假设得证。

现在我们可以求出若干条需要修改的边，此时直接将所有权值相同的边操作一次，可以得到 $26pts$ 的好成绩。

怎么回事呢？发现一个权值可以被拆分成若干个其他权值的异或和，此时即可减少操作次数。我们不难想到线性基，只有线性基的基底需要被操作，构造方案也是好构造的，可以详见代码。

时间复杂度 $O(n\log V)$。

（~~丑陋无比的~~）Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
struct node
{
	int id,to,w;
};
int n,m,dep[N],cnt,base[N];  //dep表示根节点到当前节点的路径异或和，base是线性基的基底 
bool vis[N],Vis[N];
map < int,vector<int> > H;  //需要修改的边 
vector <int> ans[N];  //答案 
vector <node> nex[N];  //vector存图 
void dfs(int x)
{
	vis[x]=true;
	for(node op:nex[x])
		if(!Vis[op.id])
		{
			Vis[op.id]=true;
			int y=op.to;
			if(vis[y]&&(op.w^dep[x]^dep[y]))  //只有异或和不为 0 时需要修改 
				H[op.w^dep[x]^dep[y]].push_back(op.id);
			if(!vis[y])
			{
				dep[y]=dep[x]^op.w;
				dfs(y);
			}
		}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		nex[x].push_back((node){i,y,w}); nex[y].push_back((node){i,x,w});
	}
	for(int i=1;i<=n;i++)
		if(!vis[i])
			dfs(i);
	for(pair < int,vector<int> > op:H)
		for(int i=30;i>=0;i--)
			if((op.first>>i)&1)
			{
				for(int j:op.second)
					ans[i].push_back(j);
				if(!base[i])
				{
					base[i]=op.first;
					++cnt;
					break;
				}
				op.first^=base[i];
			}
	printf("%d\n",cnt);
	for(int i=30;i>=0;i--)
		if(base[i])
		{
			printf("%d %d ",base[i],ans[i].size());
			for(int j:ans[i])
				printf("%d ",j);
			printf("\n");
		}
}
```



---


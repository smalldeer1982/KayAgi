# 「MCOI-04」纯水精灵

## 题目背景

轻策的净水之主——「纯水精灵」洛蒂娅是一个掉水元素角色突破材料的 BOSS。今天你想刷点材料，所以……

## 题目描述

洛蒂娅所在的水面上有 $n$ 块平台，初始时均未沉没。有 $m$ 对不同的平台彼此相连。洛蒂娅与敌人战斗了 $k$ 个回合。每一回合，她可以选择一些未沉没的平台，让这些平台沉没（可以不选，但不可以让全部平台沉没）。然后她会选择最多的平台，满足任意两块选择的平台之间都相连，在每块平台上召唤一种不同的水之幻形。$k$ 回合结束后，洛蒂娅对敌人的伤害就是每回合召唤的水之幻形数量之和。洛蒂娅想知道，对于她的所有不同选择方案，伤害的总和是多少。两种方案被视为不同当且仅当存在一回合，使得两种方案在这一回合沉没的平台不同，而与召唤水之幻形的平台无关。由于答案可能很大，你需要输出它对 $10^9+7$ 取模的结果。

简要题意：给定无自环无重边的无向图，$k$ 回合中每回合可以删去现有点集的任意真子集，求所有方案中每回合后剩下的图最大团大小之和模 $10^9+7$。

## 说明/提示

#### 样例解释

有五种不同的方案：

- 第一回合让 $0$ 号平台沉没，第二回合不选，伤害是 $1+1=2$。
- 第一回合让 $1$ 号平台沉没，第二回合不选，伤害是 $1+1=2$。
- 第一回合不选，第二回合让 $0$ 号平台沉没，伤害是 $2+1=3$。
- 第一回合不选，第二回合让 $1$ 号平台沉没，伤害是 $2+1=3$。
- 两回合都不选，伤害是 $2+2=4$。

五种方案的总伤害是 $2+2+3+3+4=14$。

#### 数据范围

本题采用捆绑测试，数据范围符合下表：

| 测试点编号 | $n\le$ | $k\le$ | 得分 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $1$ | $10$ |
| $2$ | $16$ | $100$ | $10$ |
| $3$ | $20$ | $100$ | $20$ |
| $4$ | $26$ | $1$ | $20$ |
| $5$ | $26$ | $10^9$ | $20$ |
| $6$ | $28$ | $10^9$ | $20$ |

对于全部数据，$2\le n\le 28$，$1\le m\le\frac{n(n-1)}{2}$，$1\le k\le 10^9$。

#### 提示

请注意时空限制。

#### 说明
 
[Minecraft OI Round 4](https://www.luogu.com.cn/contest/33344) A         
idea & solution：鏡音リン check：namespace_std	

## 样例 #1

### 输入

```
2 1 2
0 1```

### 输出

```
14```

## 样例 #2

### 输入

```
5 7 100
0 1
1 2
2 3
3 4
0 4
0 3
0 2```

### 输出

```
969766107```

# 题解

## 作者：yzy1 (赞：7)

> 一年前，我报名了 [MCOI Round 4](https://www.luogu.com.cn/contest/33344)，发现自己一道题也不会做，遗憾爆零。  
> 一天前，我从比赛列表里挑了一场比赛开始 VP，发现这场比赛一年前自己打过，但是基本没有印象。想了俩小时 A 发现做法假了，后来一直卡在 A 上，遗憾爆零。

## 简要题意

为表述方便和个人习惯原因，下面出现的所有大写字母 $K$ 均代表原题面中小写字母 $k$ 的含义。

给定无自环无重边的无向图，$K$ 回合中每回合可以删去现有点集的任意真子集，求所有方案中每回合后剩下的图最大团大小之和模 $10^9+7$。

观察题意，发现这题是个二合一，首先预处理出所有子集的最大团后对于每个集合进行贡献的计算，累加即可。

## 1. DP 部分

首先我们考虑枚举子集，对于每个子集求出最大团的大小，这是一个基础的状压 DP，题解中不做过多讲述。预处理出 $F(i)$ 表示点集的所有大小为 $i$ 的子集的最大团大小之和，以便下一部分使用。

## 2. 计算贡献

对于每一种情况计算贡献。即答案为：在第 $k$ 回合结束后，剩下 $s$ 个点没被删的方案数乘上 $F(s)$。所以我们先要求出这个「方案数」。

这个部分我一开始想到的是一种假做法。具体可以见 [这篇帖子](https://www.luogu.com.cn/discuss/397203)。这个东西并不是组合数，原因是同一个点在不同的时间被删也是不同的方案。换句话说，我在帖子中的做法问题转化为把长度为 $k$ 的单调不升序列计数，是忘了点与点之间有区别，即把有标号计数想成了成无标号计数。

正确的做法为：假设在第 $k$ 回合结束时剩下 $s$ 个点没被删，则有 $(n-s)$ 个点在前 $k$ 回合的某个时刻被删了，单独对每个点考虑，只要两种方案中某个点被删的时刻不一样，这两种方案就不一样，共 $s^{n-k}$ 种。在 $k$ 回合后同理，有 $s$ 个点在后面的 $K-k$ 回合被删了，或者没被删，一共是 $k-y+1$ 种，所以是 $(k-y+1)^x$。综上，第 $k$ 回合结束时剩下 $s$ 个点没被删的方案数为 $k^{n-s}((K-k+1)^s-(K-k)^s)$。

枚举 $k,s$，则我们要求的答案为：

$$
\sum_{k=0}^{K-1} \sum_{s=1}^n F(s) (K-k)^{n-s}((k+1)^s-k^s)
$$

把 $F(s)$ 提出来，得：

$$
\sum_{s=1}^n (F(s) \sum_{k=0}^{K-1} (K-k)^{n-s}((k+1)^s-k^s))
$$

发现要枚举一个 $k$，而 $K$ 的范围为 $10^9$，复杂度不能接受，考虑把式子中的 $(K-k)^{n-s}$ 和 $((k+1)^s-k^s)$ 拆开，根据二项式定理得：

$$
\sum_{s=1}^n (F(s) \sum_{k=0}^{K-1} ((\sum_{i=0}^{n-s}\binom{n-s}{i}K^i(-k)^{n-s-i})(\sum_{i=0}^{s-1} \binom{s}{i} k^i))
$$

这是两个关于 $k$ 的最高次为 $n$ 的多项式，由于 $n$ 范围很小，我们可以把它们 $O(n^2)$ 暴力乘起来，得到一个最高次为 $2n$ 的多项式，我们记这个多项式的 $i$ 次项系数为 $P_i$，则：

$$
\sum_{s=1}^n (F(s) \sum_{p=0}^{2n} (P_p\sum_{k=0}^{K-1} k^p))
$$

这就是一个经典的自然数幂和，直接伯努利数 $O(n^2)$ 预处理后 $O(n)$ 计算。

至此，我们以 $O(n^3)$ 的复杂度计算出了贡献。如果你在计算多项式乘法时使用了 $O(n\log n)$ 的算法，复杂度将优化至 $O(n^2 \log n)$，但是介于此题的数据范围，没有必要。

> 后来读 std 代码时发现其用了拉格朗日插值而不是暴力拆二项式化简，算是一题多解了。

## 3. 常数优化

如果你按照 $1\sim 2$ 中的步骤写完了代码，你会发现你的 $2^n$ 跑不过去 $n=28$，所以需要一些常数优化。

### 优化 A

首先，在写这篇题解时，本题的空间限制为 $160\text{ MB}$。你根本开不下 $2^{28}$ 个 `int` 甚至是 $2^{28}$ 个 `unsigned char`。所以可以采用一种特殊的方法来卡内存，由于图的最大团大小最大为点数，我们可以把一个 `int` 拆成六个来用，每个数字只用其中的 $5$ 个 bit 即 $2^5=32$，压缩空间来卡进本题的空间限制。

### 优化 B

我们可以把 $n$ 中的点拆成两部分，第一部分用普通的 $2^n$ DP。包含第二部分的点的点集的最大团在每次进行第一部分的 DP 转移时顺便转移。由于第二部分的点有三种状态：不选、选但不包括在最大团内，选且包括在最大团内，所以是 $O(3^n)$。这样的话设第一部分包含前 $n_0$ 个点，第二部分包括后 $n-n_0$ 个点，则时间复杂度为 $O(2^{n_0} 3^{n-n_0})$，空间复杂度为 $O(\max\{2^{n_0},3^{n-n_0}\})$，看似时间复杂度更劣但是在 $(n-n_0)$ 非常小的时候跑得比 $2^n$ 暴力 DP 要快接近 $400\text{ ms}$。

- 如果仅使用优化 A，可以做到 $840\text{ ms / }131\text{ MB}$，可以通过此题但是常数仍然不够优秀。
- 如果把优化 A 和 B 结合起来，$n_0$ 取 $n-1$，则可以做到 $620\text{ ms / }44\text{ MB}$，内存约为 std 的 $\dfrac 1 3$，但是用时较慢。
- 如果仅使用优化 B，$n_0$ 取 $n-2$，则可以做到 $330\text{ ms / }64\text{ MB}$，时间略优于 std 的同时内存只有 std 的 $\dfrac 1 2$。

## 代码参考

$O(n^2)$ 暴力计算多项式乘法，仅使用优化 B 且 $n_0=n-2$：

```cpp
const int mo = 1e9 + 7;
const int N = 139;
int n, m, K, cnt[30], jc[N], jcinv[N], e[30], B[N], Binv[N], pwk[N], P[N];
// unsigned sz[(1 << 28) / 2 / 6 + 9];
unsigned char sz[(1 << 28) / 4 + 9];

ll Pow(ll a, ll b, const ll &m) {
  ll res = 1;
  a %= m;
  while (b > 0) {
    if (b & 1) res = res * a % m;
    a = a * a % m, b >>= 1;
  }
  return res;
}
inline int C(int n, int m) {
  if (m > n) return 0;
  return 1ll * jc[n] * jcinv[m] % mo * jcinv[n - m] % mo;
}
int Calc(int n, int k) {
  if (k == 0) return n;
  int res = 0;
  re (i, k + 1)
    res = (res + 1ll * C(k + 1, i) * B[k + 1 - i] % mo * Pow(n + 1, i, mo)) % mo;
  int ans = 1ll * res * Pow(k + 1, mo - 2, mo) % mo;
  return ans;
}
// inline unsigned char Get(int pos) { return (sz[pos / 6] >> (pos % 6 * 5)) & 0b11111; }
// inline void Set(int pos, unsigned char x) { sz[pos / 6] |= x << (pos % 6 * 5); }
#define Get(x) sz[x]
#define Set(x, y) sz[x] = y

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> m >> K;
  pwk[0] = jc[0] = jcinv[0] = 1;
  re (i, N - 1)
    jc[i] = 1ll * jc[i - 1] * i % mo, jcinv[i] = Pow(jc[i], mo - 2, mo),
    pwk[i] = 1ll * pwk[i - 1] * K % mo;
  B[0] = 1;
  re (i, 100) {
    B[i] = 0;
    rep (j, 0, i - 1)
      B[i] += 1ll * C(i + 1, j) * B[j] % mo, umod(B[i]);
    B[i] = (1ll * B[i] * -Pow(i + 1, mo - 2, mo) % mo + mo) % mo;
  }
  rep (i, 0, n - 1)
    e[i] |= 1 << i;
  re (i, m) {
    int f, t;
    cin >> f >> t, e[f] |= 1 << t, e[t] |= 1 << f;
  }
  cnt[1] = 2;
  cnt[2] = 1 + (e[n - 2] >> (n - 1));
  re (S, (1 << (n - 2)) - 1) {
    unsigned char res = max<unsigned char>(Get(S ^ lb(S)),
                                           Get((S ^ lb(S)) & e[__builtin_ctz(lb(S))]) + 1),
                  popc = __builtin_popcount(S);
    Set(S, res), cnt[popc] += res;
    unsigned char res2;
    cnt[popc + 1] += (res2 = max<unsigned char>(res, Get(S & e[n - 1]) + 1));
    cnt[popc + 1] += max<unsigned char>(res, Get(S & e[n - 2]) + 1);
    up(res2, Get(S & e[n - 2]) + 1);
    cnt[popc + 2] +=
        max<unsigned char>(res2, Get(S & e[n - 1] & e[n - 2]) + (e[n - 2] >> (n - 1)) + 1);
  }
  // 共 K 回合，第 k 回合时剩下一个大小为 s 的点集的方案数
  // 方案数 = k^(n-s)*((K-k+1)^s-(K-k)^s)
  int ans = 0;
  re (s, n) {
    int res = 0;
    memset(P, 0, sizeof P);
    rep (i, 0, n - s)
      rep (j, 0, s - 1)
        P[n - s - i + j] +=
            (((n - s - i) & 1) ? mo - 1ll : 1ll) * C(n - s, i) % mo * pwk[i] % mo * C(s, j) % mo,
            umod(P[n - s - i + j]);
    rep (p, 0, 2 * n) {
      int x = p == 0;
      x += Calc(K - 1, p);
      res += 1ll * x * P[p] % mo, umod(res);
    }
    ans += 1ll * res * cnt[s] % mo, umod(ans);
  }
  cout << ans << '\n';
  return 0;
}
```

---

## 作者：鏡音リン (赞：6)

简要题解

### Part1 预处理子集最大团

定义：$f(S)$ 是集合 $S$ 的最大团大小，$r(x)$ 是点 $x$ 的邻居的集合

对于任意一个 $S\neq \varnothing$，取任意 $x\in S$，考虑 $x$ 是否在最大团中，可以得到转移：$f(S)=\max(1+f(S\cap r(x)),f(S-\{x\}))$

状压从小到大枚举 $S$，dp 计算即可

注意到我们只需要对每个子集大小分别求出子集最大团的和

所以数组可以开大小 $2^{n-1}$ 的```char```类型，因为后 $2^{n-1}$ 个值不会再次被用到了

### Part2 计算贡献

如果在第 $y$ 回合结束后剩下一个大小为 $x$ 的子集，包含这种状态的方案数应该是 $y^{n-x}((k-y+1)^x-(k-y)^x)$

也就是，考虑每个点是在哪一回合删除的

由于 $x$ 的范围只有 $[0,n]$ 所以可以枚举，所以要求的就是 $\sum_{y=1}^k y^{n-x}((k-y+1)^x-(k-y)^x)$

这是个关于 $k$ 的 $n+1$ 次多项式，暴力求 $n+2$ 个点值然后拉格朗日插值即可

### Part3 卡常

这个……看标程吧，最大点 356ms，还挺快的（初代标程最大点 700+ms，
被我优化了一半常数，我认为有必要区分一下）

标程长这样，~~欢迎抄题解~~

```cpp
#include <cstdio>
#include <algorithm>
#define N 28
#define P 1000000007
int n, m, k, G[N], s[N+1]; char a[1<<(N-1)];
int inv[N+2], pow[N+2][N+1];
int main() {
	scanf("%d%d%d", &n, &m, &k);
	while (m--) {
		int x, y;
		scanf("%d%d", &x, &y);
		G[x] |= 1 << y;
		G[y] |= 1 << x;
	}
	for (int x = 1, t = 1, d = 0; ; x++) {
		if (x & (t<<1)) {t <<= 1; if (++d == n-1) break; }
		a[x] = std::max(a[x^t], char(a[x&G[d]]+1));
		int c = __builtin_popcount(x); s[c] += a[x];
		s[c+1] += std::max(int(a[x]), a[x&G[n-1]]+1);
	}
	s[1]++;
	pow[0][0] = inv[1] = 1;
	for (int i = 1; i <= n+1; i++) {
		pow[i][0] = 1;
		for (int j = 1; j <= n; j++)
			pow[i][j] = 1ll * pow[i][j-1] * i % P;
	}
	for (int i = 2; i <= n+1; i++)
		inv[i] = 1ll * (P-P/i) * inv[P%i] % P;
	int ans = 0;
	for (int g = 1; g <= n; g++) {
		for (int i = 1; i <= n+1; i++) {
			int y = 0;
			for (int j = 1; j <= i; j++)
				y = (1ll * pow[j][n-g] * (pow[i-j+1][g] - pow[i-j][g] + P) + y) % P;
			for (int j = 0; j <= n+1; j++) if (i != j)
				y = 1ll * y * (k-j+P) % P * (i>j?inv[i-j]:P-inv[j-i]) % P;
			ans = (1ll * y * s[g] + ans) % P;
		}
	}
	printf("%d\n", ans);
}
```

---


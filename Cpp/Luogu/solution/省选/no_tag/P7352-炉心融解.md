# 炉心融解

## 题目背景

2020-2021 国家集训队自选题

## 题目描述

你叫了 $n$ 个人来玩游戏。$n$ 个人从 $0$ 到 $n-1$ 编号，按顺序坐成一圈，$0$ 号与 $n-1$ 号相邻。

你给这 $n$ 个人每人发了一张写着数字 $\texttt{0}$ 或 $\texttt{1}$ 的卡片。每个人都可以看到**除了相邻的两个人以外**所有人的卡片数字，也可以看到自己的。

游戏共进行 $m$ 回合。第 $i$ 回合你会向所有人公布 $k_i$ 条信息，信息的格式都是“某个集合里存在某种数字的卡片”。公布完之后：

- 如果某个人手里的卡片写着 $\texttt 0$，且他可以通过推断确定相邻的两个人卡片数字**逻辑或**的值，他就必须大喊“Meltdown！”。
- 如果某个人手里的卡片写着 $\texttt 1$，且他可以通过推断确定相邻的两个人卡片数字**逻辑异或**的值，他就必须大喊“Meltdown！”。

所有人都清楚游戏规则，且都有极强的推断能力，只要依据他已有的信息能够推断出来他就必须要喊。喊话是所有人同时喊，不可以听别人喊完了再继续推断。然后本回合结束，进入下一回合。

除此之外这 $n$ 个人没有任何信息交流。现在给出每个人的卡片数字和你公布的所有信息，求每个人第一次喊出“Meltdown！”是在第几回合。

## 说明/提示

对于 $100\%$ 的数据，$3\le n\le 16$，$\ 1\le m\le 100$，$0\le \sum k\le 2\times 10^3$。

## 样例 #1

### 输入

```
3 2
1 1 0
2
2 0 2 1
1 1 1
0```

### 输出

```
2 2 1```

## 样例 #2

### 输入

```
3 2
1 1 1
1
3 0 1 2 1
0```

### 输出

```
2 2 2```

# 题解

## 作者：Presentation_Emitter (赞：9)

你谷绿题恐怖如斯。建议评紫/黑。

有用的信息共有两种：公布的“某个集合里存在某种数字的卡片”的信息和每一回合喊出“Meltdown！”的人的集合。

由于 $n$ 很小，考虑状压，令 $f_{i,S}$ 表示第 $i$ 次公布信息后 $S$ 是否满足所有已知的信息，$g_{i,S}$ 表示若当前所有 $\texttt{1}$ 的集合为 $S$，则第 $i$ 次喊话后第一次喊的人组成的集合。

对于每个集合 $S$，出现以下两种情况时该集合即为非法：与公布的信息矛盾，或者 $g_{i,S} \neq g_{i,V}$，其中 $V$ 表示所有 $\texttt{1}$ 的集合。

对于 $g_{i,S}$，每次暴力枚举所有人，然后对于每个人判断在所有合法的集合中是否存在多个能推断出来的值即可。

时间复杂度 $\Theta(2^n(nm+\sum k))$。

Code:

```cpp
int n,q,m,S,ans[17],f[1<<16],g[1<<16],st[(1<<16)|1],vis[1<<16][2],t,tt,lt;
int main()
{
	n=rd();q=rd();for(int i=0;i<n;++i)S|=rd()<<i,ans[i]=-1;
	cst int lim=1<<n;for(int i=0;i<lim;++i)st[++t]=i,f[i]=1;
	for(int ti=1;ti<=q;++ti)
	{
		//cerr<<t<<endl;for(int i=1;i<=tt;++i)cerr<<st[i]<<" \n"[i==tt];
		m=rd();while(m --> 0)
		{
			int c=rd(),s=0;while(c --> 0)s|=1<<rd();
			int b=rd();if(vis[s][b])continue;
			vis[s][b]=1;tt=t;t=0;
			for(int i=1;i<=tt;++i)if((st[i]&s)==(b?0:s))f[st[i]]=0;else st[++t]=st[i];
		}
		if(t==lt)continue;
		//cerr<<t<<endl;for(int i=1;i<=tt;++i)cerr<<st[i]<<" \n"[i==tt];
		for(int j=1,s;j<=t;++j)
		{
			g[s=st[j]]=0;assert(f[s]);
			for(int i=0,posl=n-1,posr=1;i<n;++i,++posl,++posr)
			{
				if(~ans[i])continue;
				if(posl>=n)posl-=n;
				if(posr>=n)posr-=n;
				int s1=(s|(1<<posl))|(1<<posr),s2=(s|(1<<posl))&~(1<<posr),s3=(s&~(1<<posl))|(1<<posr),s4=(s&~(1<<posl))&~(1<<posr);
				//cerr<<ti<<' '<<s<<' '<<i<<' '<<((s>>i)&1)<<' '<<g[s]<<' '<<s1<<' '<<s2<<' '<<s3<<' '<<s4<<endl;
				if((s>>i)&1){if((((s>>posl)&1)^((s>>posr)&1))?!f[s1]&&!f[s4]:!f[s2]&&!f[s3])g[s]|=1<<i;}
				else{if((((s>>posl)&1)|((s>>posr)&1))?!f[s4]:!f[s1]&&!f[s2]&&!f[s3])g[s]|=1<<i;}
				//cerr<<ti<<' '<<s<<' '<<i<<' '<<((s>>i)&1)<<' '<<g[s]<<' '<<s1<<' '<<s2<<' '<<s3<<' '<<s4<<endl;
			}
			//cerr<<ti<<' '<<t<<' '<<j<<' '<<s<<' '<<g[s]<<endl;
		}
		lt=t;t=0;for(int j=1,s;j<=lt;++j){if(g[s=st[j]]^g[S])f[s]=0;else st[++t]=s;}
		for(int i=0;i<n;++i)if(((g[S]>>i)&1)&&!~ans[i])ans[i]=ti;
		//cerr<<t<<endl;for(int i=1;i<=tt;++i)cerr<<st[i]<<" \n"[i==tt];
	}
	for(int i=0;i<n;++i)prt(ans[i]," \n"[i==n-1]);
	ret 0;
}
```

---

## 作者：Flanksy (赞：5)

### 状态压缩动态规划

------------

#### 分析

卡牌只有 $0$ 和 $1$，$n$ 最大是 $16$，除了状压和爆搜以外想不到其他做法了。

虽然卡牌的状态是固定的，但由于每个人都不知道其左右邻居的状态，他会猜测 $4$ 种情况，直接搜索没什么思路，因此采用状态压缩动态规划。

------------

#### 实现

状态压缩每个人的卡牌（$0$ 或 $1$），称题目中给出的真实卡牌集合为 $X$。

定义 $dp_{i,S}$ 为状态 $S$ 在第 $i$ 轮信息公布后喊出 Meltdown 的人的集合，这样最后过一遍 $dp_{i,X}$ 就可以得到答案了。

怎么得到 $dp$？题目中已经说明了会喊出 Meltdown 的情况只有两种，分析一下就可以得到人们大喊大叫的原因了：

- 卡牌上数字为 $0$ 且猜测的所有情况中，**所有合法情况**中左右邻居卡牌上数字的逻辑或值相等。
- 卡牌上数字为 $1$ 且猜测的所有情况中，**所有合法情况**中左右邻居卡牌上数字的逻辑异或值相等。

为什么会有合法情况之说？因为有的情况和题目中给出的信息不符，这时候它就不再会被考虑了。

定义 $on_S$ 为集合 $S$ 的合法性，随着游戏轮数的增加，集合只会从合法变成不合法，所以不用加一维记录轮数。

每轮游戏都检查所有合法的集合，然后在**每一个合法集合**中枚举每一个人将要猜测的情况，符合上文中大喊大叫的条件就把对应的二进制位设为 $1$。**无论该集合对于那个人合不合法都需要枚举**，其他人会利用这一点排除他们猜测的集合。（样例二中，第一回合没人喊说明每个人手里都不是 $0$，在第二回合没有给出任何信息的情况下他们都喊了 Meltdown）

题目要每个人第一次喊出 Meltdown 的轮编号，没有喊过则输出 $-1$。因为和 $dp$ 的定义有差别，每一轮都需要统计答案。

然而照这个思路写出来的代码并不正确，为什么？因为如果 $dp_{i,S}$ 和 $dp_{i,X}$ 不相等，说明集合 $S$ 非法，会被排除。**因为真实卡牌集合确定，每轮给出的信息确定，游戏进程也是唯一确定的，这场游戏的一切已经在开始时就注定了。**

现在思路完全正确，接下来是代码实现，注意此题的空间限制为 16MB，需要滚动数组。笔者的实现并不精细，不开 O2 无法通过。可以使用链表或并查集维护所有合法集合以大幅减少遍历次数。

实现中 $dp$ 并没有滚动数组，由于对于每种合法状态会喊出 Meltdown 的人数不减，可以直接继承之前的值。

时间复杂度 $O(2^nnm+2^n\sum k)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,X,ans[16],dp[1<<16];
bool on[1<<16];
inline int ex(int x){return ~x ? (x==n ? 0:x):n-1;}
inline bool check(int x,int S){//检查第x个人在状态S中是否会喊出 Meltdown
    int ret=-1,ima=S;
    ima|=1<<ex(x-1),ima|=1<<ex(x+1);
    if(on[ima]) ret=S>>x&1 ? 0:1;//只有左右全1的or和xor结果不同
    ima^=1<<ex(x-1);
    if(on[ima]){//左0右1
        if(ret==0) return 0;
        ret=1;
    }
    ima|=1<<ex(x-1),ima^=1<<ex(x+1);
    if(on[ima]){//左1右0
        if(ret==0) return 0;
        ret=1;
    }
    ima^=1<<ex(x-1);
    if(on[ima]){//左右全0
        if(ret==1) return 0;
        ret=0;
    }
    return 1;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++){
        static int x;
        scanf("%d",&x);
        X|=x<<i;
    }
    const int lim=(1<<n)-1;
    for(int i=0;i<=lim;i++) on[i]=1;
    for(int R=1;R<=m;R++){
        static int T,k,c,aim;
        scanf("%d",&T);
        while(T--){//每轮 T 条信息 每条信息 k 个目标 存在卡牌 c
            scanf("%d",&k);
            aim=0;//指定集合内元素设为 1 用以检查合法性
            for(int i=0;i<k;i++){
                static int x;
                scanf("%d",&x);
                aim|=1<<x;
            }
            scanf("%d",&c);
            for(int i=0;i<=lim;i++) if(on[i]){
                if(c&&!(i&aim)) on[i]=0;//指定集合中存在1但是i没有
                if(!c&&(i&aim)==aim) on[i]=0;//集合存在0但是i没有
            }
        }
        for(int i=0;i<=lim;i++) if(on[i])
            for(int j=0;j<n;j++) if(!(dp[i]>>j&1)&&check(j,i)) dp[i]|=1<<j;
        for(int i=0;i<=lim;i++) if(on[i]&&dp[i]!=dp[X]) on[i]=0;
        for(int i=0;i<n;i++) if((dp[X]>>i&1)&&!ans[i]) ans[i]=R;
    }
    for(int i=0;i<n;i++) if(!ans[i]) ans[i]=-1;
    for(int i=0;i<n;i++) printf("%d ",ans[i]);
    return 0;
}
```

------------

#### [闲话](https://www.luogu.com.cn/paste/4iykeva8)

博弈游戏类似问题的过程大多是唯一确定的。绝顶聪明的玩家们按照最优策略博弈，即使过程不唯一，结果也全部都是唯一确定的。

有一种悲剧美感。

---

## 作者：Sky_Maths (赞：1)

以前没做过这种题。

## 思路
对于所有人共享的信息：当前由输入给出的限制，前几次 `Meltdown!` 的人。

可以通过这两种信息排除一些情况，设 $f_S, S = \sum\limits_{i = 0}^{n - 1}c_i\cdot 2^{i}$ 为仅考虑共享信息（即不知道任何序列信息）的情况下，序列为 $S$ 的情况是否可能。

同时设 $g_S$ 为当前情况下，若序列为 $S$，喊过 `Meltdown!` 的人的集合。

每次维护即可。

## 实现
类似于模拟，每回合：
1. 输入限制条件，更新 $f_S$。
2. 根据当前条件更新 $g_S$。
3. 根据 $g_S$ 更新 $ans_i$ 和 $f_S$（若 $g_S\not=g_{fact}$ 则会与事实不符）。

## 代码
```cpp
const int N = 16;
int n, m, fact;
int ans[N];
int c[N][4];
int f[1 << N], g[1 << N];
int main() {
	read(n, m);
	rep (s, 0, (1 << n) - 1) f[s] = 1;
	rep (i, 0, n - 1) {
		int t; read(t);
		fact |= t << i;
		ans[i] = -1;
		int x = (i - 1 + n) % n;
		int y = (i + 1) % n;
		rep (j, 0, 3) {
			c[i][j] = ((j & 1) << x) | (((j >> 1) & 1) << y);
		}
	}
	rep (t0, 1, m) {
		int k; read(k);
		rep (t1, 1, k) {
			int p; read(p);
			int x = 0;
			rep (i, 1, p) {
				int y; read(y);
				x |= 1 << y;
			}
			int c; read(c);
			rep (s, 0, (1 << n) - 1) {
				if (!f[s]) continue;
				if (c == 1) {
					if ((s & x) == 0) {
						f[s] = 0;
					}
				}
				if (c == 0) {
					if ((~s & x) == 0) {
						f[s] = 0;
					}
				}
			}
		}
		rep (s, 0, (1 << n) - 1) {
			if (!f[s]) continue;
			g[s] = 0;
			rep (i, 0, n - 1) {
				int now = -1;
				rep (j, 0, 3) {
					int t = s ^ c[i][j];
					if (f[t] == 0) continue;
					int u = t & c[i][3];
					if (s >> i & 1) {
						if (u > 0 && (u & (u - 1)) == 0) {
							u = 1;
						}
						else {
							u = 0;
						}
						if (now == -1) now = u;
						else {
							if (now != u) {
								now = 7;
								break;
							}
						}
					}
					else {
						u = u > 0;
						if (now == -1) now = u;
						else {
							if (now != u) {
								now = 7;
								break;
							}
						}
					}
				}
				if (now != 7) {
					g[s] |= 1 << i;
				}
			}
		}
		rep (i, 0, n - 1) {
			if (ans[i] == -1 && (g[fact] >> i) & 1) {
				ans[i] = t0;
			}
		}
		rep (s, 0, (1 << n) - 1) {
			if (f[s] && g[s] != g[fact]) {
				f[s] = 0;
			}
		}
	}
	rep (i, 0, n - 1) {
		printf("%d ", ans[i]);
	}
	return 0;
}
```

---


# [COCI 2020/2021 #5] Magenta

## 题目描述

给定一个包含 $n$ 个结点，$n-1$ 条边的连通图，其中结点编号分别为 $1,2,\cdots,n$。这 $n-1$ 条边被涂成了不同的颜色，其中包含蓝色、红色和洋红。

Paula 和 Marin 的棋子分别从结点 $a$ 和 $b$ 出发。两人轮流行走，Paula 先走。Paula 的棋子只能沿着蓝色或洋红的边行走，而 Marin 的棋子只能沿着红色或洋红的边行走。然而，任何时候都不能行走都对方棋子所在的位置。如果由一方的棋子无法行走，则另一方获胜。

如果 Paula 和 Marin 每次都使用最优的走法，求最终胜利的一方。如果游戏无法决出胜负，则为平局。

## 说明/提示

#### 样例 1 解释

Paula 的最优走法为前往结点 $2$，此时 Marin 无法行走。

#### 样例 2 解释

Paula 将前往结点 $1$，而 Marin 会前往结点 $2$。Paula 只能前往结点 $3$，此时 Marin 前往结点 $1$。这时 Paula 无法行走，Marin 获胜：

![](https://cdn.luogu.com.cn/upload/image_hosting/03flhrlq.png)

#### 数据规模与约定

**本题采用捆绑测试**。

|Subtask|分值|数据范围及约定|
| :----------: | :----------: | :----------: |
|$1$|$30$|$2 \le n \le 100$|
|$2$|$30$|连通图中所有边的颜色都为洋红|
|$3$|$50$|无|

对于 $100\%$ 的数据，$2 \le n \le 10^5$，$1 \le a,b \le n$，$a \neq b$，$1 \le x,y \le n$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #5](https://hsin.hr/coci/contest5_tasks.pdf)  _T3 Magenta_。**

## 样例 #1

### 输入

```
3
1 3
3 2 magenta
2 1 magenta```

### 输出

```
Paula```

## 样例 #2

### 输入

```
5
3 5
1 2 magenta
1 3 magenta
2 4 plava
2 5 crvena```

### 输出

```
Marin```

## 样例 #3

### 输入

```
5
1 4
2 1 plava
1 3 crvena
5 2 plava
4 1 magenta```

### 输出

```
Magenta```

# 题解

## 作者：Little_x_starTYJ (赞：11)

## 解题思路

下文中的距离指的是 $a,b$ 之间的边的数量。

### Sub 2
即所有边 Paula 与 Marin 都可以行走。

根据题意 Paula 先手。因此，如果一开始 Paula 动不了，那么 Marin 胜。如果 Paula 动一次后 Marin 动不了，那么 Paula 胜。

除去这两种情况后，每当 Paula、Marin 分别动了一次，他们之间的距离要么不变，要么缩短 $2$ 要么增长 $2$。

但是很明显，由于他们都会使用最优的走法，所以他们之间的距离不会增长（增长过后会变成平局，处于优势的人肯定不希望平局），所以他们之间的距离要么缩短 $2$ 要么不变。

所以当 Paula 与 Marin 之间的距离为奇数时，最后，他们的距离会变成 $1$。接下来轮到 Paula，但由于对面有 Marin，所以他只能往后退，Marin 趁机逼近，最后 Marin 胜。

当距离为偶数时同理，Paula 胜。

### Sub 3
在上面的基础上，我们不难发现 Sub 3 与 Sub 2 最大的不同就是可能存在安全区。

安全区就是只有 Paula 或者 Marin 能够到达的地方。

于是这个安全区至少由 $3$ 个节点构成，假设 $3$ 个节点的编号分别为 $1, 2, 3$ 并且是 Paula 的安全区。那么不难发现 $1 \to 2$ 这条边的颜色一定是蓝色。$2\to 3$ 这条边只要不是红色就行。

所以我们不光要判断 Marin 与 Paula 之间的距离的奇偶，还要找到必不胜家的安全区。

在查找安全区时需要注意找到安全区后，可以获胜的人可能可以先到达，所以这个安全区实际上是没有用的。

---

## 作者：hanjinghao (赞：8)

首先，我们考虑两种特殊情况。

第一种，先手一开始就动不了，那么后手直接赢。

第二种，先手动了一步之后，后手无路可走，那么先手直接赢。

接下来考虑普遍情况。

这是一个回合制游戏，两人分别动一步看作一个回合。

可以发现，经过一个回合，两人的距离要么缩短二，要么不变，要么扩大二，变化量一定为偶数。

而偶数乘任何数都为偶数，因此无论经过多少个回合，两人的距离的变化量一定是偶数（即距离的奇偶性不变）。

我们根据两人一开始距离的奇偶性分类讨论。

一开始是 Paula 走。如果一开始两人距离为奇数，那么由上述奇偶性分析可得，每次轮到 Magenta 走的时候，两人的距离都为偶数。而两人不能待在同一个格子，即距离大于零。以上两点可以得出，两人的距离大于等于二，也就是说，Magenta 的路不会被堵死，即 Magenta 不会输。此时，Magenta 需要想办法把 Paula 的路堵死，让自己赢，而不要让平局出现。

同理，如果一开始两人距离为偶数，那么 Paula 就不会输。此时，Paula 需要想办法把 Magenta 的路堵死，让自己赢，而不要让平局出现。

以下令一定不会输的一方为猎手，另一方为猎物。

如果有两个相邻的节点，都是猎手到不了的，并且猎物可以到达这两个节点（即半路上不会被猎手截胡），那么，猎物就要赶往这两个点，并且之后一直在这两个点之间反复横跳。这样，猎手就只能在这两个点外面干瞪眼，堵不死猎物。平局出现。

如果不存在上述情况，那么猎物就无法制造平局。最后猎手会赢。

具体细节请见代码及注释。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
int n, Length, Prey, a[5], dist[N][2];
char col[35];
bool Can[5];
string name[] = {"Paula", "Marin", "Magenta"};
vector < pair < int, int > > G[N];

inline void End(int x)
{
	puts(name[x].c_str());
	exit(0);
}

void dfs(int x, int id, int fa)
{
	int len = G[x].size();
	for (register int i = 0; i < len; ++i)
	{
		if (G[x][i].second == fa) continue;
		if (G[x][i].second == a[!id]) Length = dist[x][id] + 1; 
		if (G[x][i].first != (!id))
		{
			dist[G[x][i].second][id] = dist[x][id] + 1;
			dfs(G[x][i].second, id, x);
		}
	}
}

bool Escape(int x, int id, int fa)
{
	int len = G[x].size();
	for (register int i = 0; i < len; ++i)
	{
		if (G[x][i].second == fa) continue;
		if (G[x][i].first == (!id)) continue;
		if (dist[G[x][i].second][!id] != -1 && dist[G[x][i].second][id] >= dist[G[x][i].second][!id]) continue;//这条路被猎手截胡了
		if (dist[x][!id] == -1 && dist[G[x][i].second][!id] == -1) return 1;
		if (Escape(G[x][i].second, id, x)) return 1;
	}
	return 0;
}

int main()
{
	read(n);
	read(a[0]);
	read(a[1]);
	for (register int i = 1; i < n; ++i)
	{
		int x, y;
		read(x);
		read(y);
		scanf("%s", col);
		int num;
		if (col[0] == 'p') num = 0;
		else if (col[0] == 'c') num = 1;
		else num = 2;
		G[x].push_back(make_pair(num, y));
		G[y].push_back(make_pair(num, x));
		if (num != 1)
		{
			if ((x == a[0] && y != a[1]) || (y == a[0] && x != a[1])) Can[0] = 1;
		}
		if (num)
		{
			if (x == a[1] || y == a[1]) Can[1] = 1;
		}
	}
	if (!Can[0]) End(1);
	if (!Can[1]) End(0);
	memset(dist, -1, sizeof(dist));
	dist[a[0]][0] = 0;
	dfs(a[0], 0, 0);
	dist[a[1]][1] = 0;
	dfs(a[1], 1, 0);
	Prey = !(Length & 1);
	if (Escape(a[Prey], Prey, 0)) End(2);
	End(!Prey);
	return 0;
}
```

---

## 作者：yanwh1 (赞：2)

## 前话
史题。

## 思路分析：
这道题乍一看不好做，于是我们考虑从第二个点入手：如果所有的边双方都可以通过的话，那么必定可以分出胜负。显然，决定两人胜负的就是他们初始的距离的奇偶性。如果双方初始距离为奇数，则 Paula 胜，反之则 Marin 胜。

而这条性质同样适用于其它几个点，但是多了平局的可能。我们将上一个性质判断出来的胜方记作 A，败方记作 B，如果有一条边连接的两个点 B 可以到达但 A 不行，且 A 在 B 到达这两个点之前没有拦住 B 到这两个点的必经之路，那么就会平局。

看着这道题的思路其实并不难，难点在于它的细节是真的多！并且我们还要特判是否有一开始就走不了的情况（~~光是这个特判就改了一个下午~~）。

放代码！
## 代码详解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
inline int read(){
    int f=0,t=0;
    char c=getchar();
    while(!isdigit(c)) t|=(c=='-'),c=getchar();
    while(isdigit(c)) f=(f<<3)+(f<<1)+c-48,c=getchar();
    return t?-f:f;
}
inline void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar('0'+x%10);
}const int N=1e5+5;
int head[N],to[N<<1],nxt[N<<1],w[N<<1],dep[N][3],cnt,rs,n,a,b;//dep用于计算双方到某个点的距离 
inline void add(int u,int v,int e){nxt[++cnt]=head[u],to[cnt]=v,w[cnt]=e,head[u]=cnt;}
inline void dfs1(int u,int f,int x){
	dep[u][x]=dep[f][x]+1;
	if((x==1&&u==b)||(x==2&&u==a))rs=dep[u][x]; 
	for(rint i=head[u];i;i=nxt[i])
		if(to[i]!=f&&(w[i]&x))
			dfs1(to[i],u,x);
}//dfs1算出双方到每个点的距离
inline int dfs2(int u,int f,int x){
	for(rint i=head[u];i;i=nxt[i]){
		if(to[i]==f||(!(w[i]&x))||(dep[to[i]][x]>=dep[to[i]][((x-1)^1)+1]&&dep[to[i]][((x-1)^1)+1]!=-1))//如果胜方能在败方到达之前到达，则败方不能到达该点
			continue;
		if(dep[to[i]][((x-1)^1)+1]==-1&&dep[u][((x-1)^1)+1]==-1)return 1;//如果一条边的两个端点都符合条件，则判为平局
		if(dfs2(to[i],u,x))return 1;
	}return 0;
}//dfs2判断是否有平局情况
signed main(){
	n=read(),a=read(),b=read();int f1=0,f2=0;
	for(rint i=1;i<n;i++){
		int u=read(),v=read(),e;
		char c=getchar();
		while(c<'a'||c>'z')c=getchar();
		if(c=='p')e=1;
		if(c=='c')e=2;
		if(c=='m')e=3;
		add(u,v,e),add(v,u,e);
		if((a==u||a==v)&&(e!=2)&&b!=u&&b!=v)f1=1;
		if((b==u||b==v)&&(e!=1))f2=1;//特判是否第一步就不能走 
	}if(!f1){
		puts("Marin");
		return 0;
	}if(!f2){
		puts("Paula");
		return 0;
	}memset(dep,-1,sizeof(dep));
	dfs1(a,0,1);dfs1(b,0,2);
	if(dfs2(rs&1?a:b,0,rs&1?1:2)){
		puts("Magenta");
		return 0;
	}if(rs&1)puts("Marin");
	else puts("Paula");
	return 0;
}
```
## 后话
一道很好的细节题，使我的大脑旋转。思维难度不高，但是调起来十分困难（最关键是容易虚空调题）。

---

## 作者：Piggy343288 (赞：2)

P7400，一个有趣的博弈论。  
下面称 Paula 和 Marin 都执行一轮操作的“一整轮”为一个周期。  

### Sub 1：$n\le 100$  
我们采用 $O(n^2\times n)=O(n^3)$ 的 DP 即可。这里略去具体实现。  


### Sub 2：边的颜色均为洋红  
这意味着两人都可以走过任意一条边。考虑两方如何对对方进行“围追堵截”，我们不难发现：若起初两者之间连边为奇数，则先手胜，否则后手胜。这可以用简单的搜索得到结果，时间复杂度 $O(n)$。  


### Sub 3：无特殊限制  
Sub 3 与 Sub 2 的主要区别在于，既然有些边不能通过，那这意味着有可能存在这样一种情况，使得围追堵截的那个人（无论是 Paula 还是 Marin ）可能无法通过必经过的边，从而被迫陷入平局。   

因为路径长度的奇偶性已经确认了某个玩家绝不会赢，因此我们直接考虑平局的情况，即存在某一条边，使得此玩家可以到达这条边的顶点，而且对方到达不了。如果对方本来是必胜的，那么由于边的限制，这种局面一定平局。  

否则不存在这样的一条边，那么此玩家无论怎么走，都是一个对方能够到达的点，这样对方总能获胜。  

这也可以用朴素的搜索来解决。时间复杂度 $O(n)$。  

代码略了。

---


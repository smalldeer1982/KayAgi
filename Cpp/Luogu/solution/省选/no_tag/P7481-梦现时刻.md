# 梦现时刻

## 题目描述

给定 $n,m$ ，保证 $m\le n$，令 $F(a,b)=\sum_{i=0}^{b}\binom{b}{i}\binom{n-i}{a}$。

求 $\bigoplus_{a=1}^{m}\bigoplus_{b=1}^{m}(F(a,b) \bmod 998244353)$。

其中 $\oplus$ 表示异或运算。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

对于 $100 \%$ 的数据，$1 \le n \le {10}^9$，$1\le m\le 5000$，保证 $m\le n$

- Subtask 1（20 points）：$n \le 500$。
- Subtask 2（30 points）：$n \le 5000$。
- Subtask 3（50 points）：无特殊限制。

## 样例 #1

### 输入

```
3 3```

### 输出

```
7```

# 题解

## 作者：_l_l_ (赞：14)

给定 $n$，对所有 $1\leq a,b\leq m$，求：
$$f(a,b)=\sum\binom bi\binom{n-i}a$$

$n\leq10^9,m\leq5\times10^3$。

显然很难 $O(1)$ 在线求出每个 $f$ 的值，因此考虑递推。

首先看到上面有个常数项 $b$，考虑将其拆开：

$$
\begin{aligned}
f(a,b)=&\sum\binom bi\binom{n-i}a\\
=&\sum\binom{b-1}i\binom{n-i}a+\sum\binom{b-1}{i-1}\binom{n-i}a\\
=&f(a,b-1)+\sum\binom{b-1}{i}\binom{n-i-1}a\\
\end{aligned}
$$

可以看见我们莫名其妙的把 $n-i$ 变为了 $n-i-1$，考虑变回去：

$$
\begin{aligned}
&\sum\binom{b-1}{i}\binom{n-i-1}a\\
=&\sum\binom{b-1}{i}\binom{n-i}a-\sum\binom{b-1}{i}\binom{n-i-1}{a-1}\\
=&f(a,b-1)-\sum\binom{b-1}{i}\binom{n-i-1}{a-1}\\
\end{aligned}
$$

无论怎么变，都无法将 $n-i-1$ 变没，但是我们已经把右下角 $a$ 变为 $a-1$，这是个突破性的进展（确信），因此考虑将 $\sum\binom{b-1}{i}\binom{n-i-1}{a-1}$ 左下方的 $i$ 变为 $i+1$：

$$
\begin{aligned}
&\sum\binom{b-1}{i}\binom{n-i-1}{a-1}\\
=&\sum\binom b{i+1}\binom{n-i-1}{a-1}-\sum\binom {b-1}{i+1}\binom{n-i-1}{a-1}\\
=&\sum\binom bi\binom{n-i}{a-1}-\sum\binom {b-1}i\binom{n-i}{a-1}\\
=&f(a-1,b)-f(a-1,b-1)
\end{aligned}
$$

然后就推完了，总结下就是：

$$
\begin{aligned}
f(a,b)=&2f(a,b-1)-(f(a-1,b)-f(a-1,b-1))\\
=&2f(a,b-1)+f(a-1,b-1)-f(a-1,b)
\end{aligned}$$

边界就 $f(a,0)=\binom na$，$f(0,b)=\sum\binom bi=2^b$。

$\binom na$ 可以直接使用 $O(a+\log \text{mod})$ 的公式 $\frac{n\times(n-1)\times\cdots\times(n-a+1)}{a!}$ 计算。

```cpp
#include <cstdio>
using namespace std;
const int MAXN = 5005;
const int mod = 998244353;
int f[MAXN][MAXN];
int qkpow(int a, int b) {
    int ans = 1; for (; b; b >>= 1, a = 1ll * a * a % mod) if (b & 1) ans = 1ll * ans * a % mod; return ans;
}
int main() {
    int n, m; scanf("%d %d", &n, &m);
    for (int i = 0; i <= m; i++) {
        int ans1 = 1, ans2 = 1;
        for (int j = n - i + 1; j <= n; j++) ans1 = 1ll * ans1 * j % mod;
        for (int j = 1; j <= i; j++) ans2 = 1ll * ans2 * j % mod;
        f[i][0] = 1ll * ans1 * qkpow(ans2, mod - 2) % mod;
    }
    for (int i = 0; i <= m; i++) f[0][i] = qkpow(2, i);
    for (int i = 1; i <= m; i++) for (int j = 1; j <= m; j++) {
        f[i][j] = (2ll * f[i][j - 1] + f[i - 1][j - 1] + mod - f[i - 1][j]) % mod;
    }
    int ans = 0; for (int i = 1; i <= m; i++) for (int j = 1; j <= m; j++) {
        ans ^= f[i][j];
    }
    printf("%d\n", ans); return 0;
}
```

---

## 作者：加藤惠 (赞：13)

我们考虑 $F(a,b)$ 的组合意义，因为保证了 $n\ge m$，可以看做是一个有 $n$ 个不同的球，前 $b$ 个可以染成黑色，所有球都可以染成白色，一共要染 $a$ 个白球，任意个黑球，求方案数。

保证了 $m\le n$，这个时候可以染成黑色的球肯定也可以染成白色，我们可以改为枚举可以染成黑色的球有几个染了白色，于是可以得到：
$$ F(a,b)=\sum_{i}2^{b-i}\binom{b}{i}\binom{n-b}{a-i}$$

写成生成函数形式就是 $[x^a](1+x)^{n-b}(2+x)^b$。

我们可以通过手动求导来得到递推式，或者移动 $b$ 暴力维护整个多项式。

---

## 作者：冷月葬T魂 (赞：12)

题目大意：给定正整数 $n,m$，令 $F(a,b)=\sum\limits_{i=1}^m C_b^i \times C_{n-i}^a $， 求 $ \bigoplus_{a=1}^m \bigoplus_{b=1}^m F(a,b)$（其中 $\bigoplus$ 表示异或运算）。   

看似是一道数学题，但是我们可以将它“实际化”来做。  

我们可以将 $C_b^i \times C_{n-i}^a$ 视为从 $n$ 个球中按两步取球：第一步从前 $b$ 个球中取出 $i$ 个球，第二步从剩下的 $n-i$ 个球中取出 $a$ 个球。  
于是，$F(a,b)=\sum\limits_{i=1}^m C_b^i \times C_{n-i}^a $ 即代表着第一步从前 $b$ 个球中取出**若干**个球，第二步从剩下的球中取出 $a$ 个球的取法总数。 

我们现设 $f(i,j)$ 表示第一步从前 $i$ 个球中取出若干个球，第二步从剩下的球中取出 $j$ 个球的取法总数，则题意即对于 $1 \leq i \leq m,1 \leq j \leq m$ 求出 $f(i,j)$ 的值。**注意此处的 $i$ 和题目中的 $i$ 意义并不相同。**  

这样我们就把一道数学问题转化成了一道动态规划问题。

为了方便，我们再设 $g(i,j)$ 表示第一步从前 $i$ 个球中取出若干个球，第二步从剩下的球中取出 $j$ 个球**但不能取第 $i+1$ 个球**的取法总数。  

得出递推式：  
1. $ f(i,j)=f(i-1,j)+g(i-1,j) $  
其中 $f(i-1,j)$ 表示**第一步**不取第 $i$ 个球（第二步仍然可以取），$g(i-1,j)$ 表示**第一步**取第 $i$ 个球（第二步就不能取了）。  
2. $ g(i,j)=f(i,j)-g(i,j-1) $  
其中 $f(i,j)$ 代表第二步取不取第 $i+1$ 个球无所谓，$g(i,j-1)$ 代表第二步取第 $i+1$ 个球（于是只能从剩下的球中取出 $j-1$ 个，且不能取第 $i+1$ 个球）。  

边界条件： $ f(0,j)=C_n^j,f(i,0)=2^i,g(0,j)=C_{n-1}^{j},g(i,0)=2^i $。 

**原来的 $g(0,j)$ 边界条件写错了，现已修改。感谢 @panyf 提出错误。**

至于 $C_n^j$ 可以通过预处理 $j$ 的乘法逆元递推求出。  

算法时间复杂度为 $O(m^2)$。~~（究竟赛时没有做出来）~~  

附上代码：

```c++
#include <bits/stdc++.h>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Rev(i,a,b) for(int i=a;i>=b;i--)
#define clr(a,val) memset(a,val,sizeof(a))
#define int long long
using namespace std;

// f(i,j)=g(i-1,j)+f(i-1,j)
// g(i,j)=f(i,j)-g(i,j-1)
// f(0,i)=C(n,i)
// f(i,0)=2^n
// g(0,i)=C(n-1,i)
// g(i,0)=2^n

const int N=5e3+5,mod=998244353;

int n,m,f[N][N],g[N][N];
int inv[N];

int qpow(int x,int y)
{
	int res=1;
	while(y){
		if(y&1ll) res=res*x%mod;
		x=x*x%mod;
		y>>=1ll;
	}
	return res;
}

signed main()
{
	cin>>n>>m;
	
	inv[0]=1;
	For(i,1,m){
		inv[i]=qpow(i,mod-2);
	}
	
	f[0][0]=1;
	
	For(i,1,m){
		f[0][i]=f[0][i-1]*(n-i+1)%mod*inv[i]%mod;
		f[i][0]=f[i-1][0]*2%mod;
	}
	
	g[0][0]=1;
	
	For(i,1,m){
		g[0][i]=g[0][i-1]*(n-i)%mod*inv[i]%mod;
		g[i][0]=g[i-1][0]*2%mod;
	}
	
	int ans=0;
	
	For(i,1,m){
		For(j,1,m){
			f[i][j]=(g[i-1][j]+f[i-1][j])%mod;
			g[i][j]=((f[i][j]-g[i][j-1])%mod+mod)%mod;
			ans^=f[i][j];
		}
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```

另：这是本人的第一篇题解，若有不到之处望大家多多包涵：）

---

## 作者：rits_m (赞：8)

注意到先 $\bmod 998244353$ 再 $\oplus$ 一眼的没有高妙算法，所以看样子要求出所有 $F$ 了。也就是说：

**题意**：求所有 $1 \leq a, b \leq m$ 的：

$$F(a,b)=\sum_{i=0}^{b} \binom{b}{i}\binom{n - i}{a}$$

$1 \leq a \leq 10^9$，$1 \leq m \leq 5000$。

**题解**：看到乘积，第一眼不能范德蒙德。那我们考虑一下组合数递推，感觉和 [这个](https://www.luogu.com.cn/problem/solution/P9357) 有点像？

把第一个组合数用 **加法** 拆开：

$$F(a,b)=\sum_{i=0}^{b} \binom{b - 1}{i}\binom{n - i}{a} + \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - i}{a}$$

对照上式的前半部分和 $F$ 的定义：

$$F(a, b) = F(a, b - 1) + \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - i}{a}$$

后半部分是化不了的，因为我们搞出来一个 $i - 1$，如果你想要提到第二个组合数的上指标上，由于 $n$ 不是参量是常量，所以不能直接化成 $F$。

那么我们再次把组合数用 **减法** 拆开，为了让第一个组合数的下指标和第二个组合数的上指标形式相同。

但是这里拆开第一个组合数会很尴尬：

$$F(a, b) = F(a, b - 1) + \sum_{i=0}^{b} \binom{b}{i}\binom{n - i}{a} - \sum_{i=0}^{b} \binom{b - 1}{i}\binom{n - i}{a}$$

你得到了 $F(a, b) = F(a, b - 1) + F(a, b) - F(a, b - 1)$，等于废话。

$$F(a, b) = F(a, b - 1) + \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - i}{a}$$

所以拆开第二个组合数：

$$F(a, b) = F(a, b - 1) + \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - (i - 1)}{a} - \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - i}{a - 1}$$

也即：

$$F(a, b) = F(a, b - 1) + \sum_{i=0}^{b - 1} \binom{b - 1}{i}\binom{n - i}{a} - \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - i}{a - 1}$$

$$F(a, b) = 2F(a, b - 1) - \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - i}{a - 1}$$

虽然后面这个式子很尴尬，我们又回到了原来的起点，但是 **对照一下一开始的式子**：

$$F(a, b) - F(a, b - 1) = \sum_{i=0}^{b} \binom{b - 1}{i - 1}\binom{n - i}{a}$$

所以有：

$$F(a, b) = 2F(a, b - 1) - F(a - 1, b) + F(a - 1, b - 1)$$

我们要 $a, b$ 均从小到大递推，这只需要我们知道边界情况：$\forall 1 \leq b \leq m$ 的 $F(0, b)$ 和 $\forall 1 \leq a \leq m$ 的 $F(a, 0)$ 以及 $F(0, 0) = 1$。

虽然只有 $\mathcal O(m)$ 个点值，暴力带定义算一下处理的好是可以单次 $\mathcal O(m)$ 的，但是事实上直接带回去，可以得到

$$F(a, 0)= \binom{n}{a}$$

$$F(0, b)= 2^b$$

所以最后复杂度就严格 $\mathcal O(m^2)$ 了。

**代码**：随手写了个最优解 rk3。

```cpp
#include <cstdio>

const int MOD = 998244353;
inline void add(int& x, int y) { (x += y) >= MOD && (x -= MOD); }
inline void del(int& x, int y) { (x -= y) < 0 && (x += MOD); }
inline int sum(int x, int y) { return (x += y) < MOD ? x : x - MOD; }
inline int mun(int x, int y) { return (x -= y) >= 0 ? x : x + MOD; }

#define MAXM 5001
int inv[MAXM], F[MAXM][MAXM];
int main() {
	int N, M; scanf("%d%d", &N, &M);
	inv[1] = 1;
	for (int i = 2; i <= M; ++i) 
		inv[i] = MOD - (long long)(MOD / i) * inv[MOD % i] % MOD;
	F[0][0] = 1;
	for (int a = 1; a <= M; ++a) 
		F[a][0] = (long long)F[a - 1][0] * (N - a + 1) % MOD * inv[a] % MOD;
	for (int b = 1; b <= M; ++b) 
		F[0][b] = sum(F[0][b - 1], F[0][b - 1]);
	int ans = 0;
	for (int a = 1; a <= M; ++a) for (int b = 1; b <= M; ++b) 
		ans ^= (F[a][b] = sum(sum(F[a][b - 1], F[a][b - 1]), mun(F[a - 1][b - 1], F[a - 1][b])));
//	for (int a = 0; a <= M; ++a) for (int b = 0; b <= M; ++b) 
//		printf("%d%c", F[a][b], " \n"[b == M]);
	return printf("%d\n", ans), 0;
}
```

---

## 作者：_lbw_ (赞：7)

怒斥不给证明的题解！!1

首先看完题目，这个异或显然无法优化

也就是说需要求出所有 $F(a,b)$

考虑递推

$$F(a,b+1)=\sum_{i=0}^{b+1}\binom{b+1}{i}\binom{n-i}{a}$$

接下来需要大量用到基础组合数恒等式 $\dbinom{n}{m}=\dbinom{n-1}{m-1}+\dbinom{n-1}{m}$

$$=\sum_{i=0}^{b+1}\binom{b}{i}\binom{n-i}{a}+\sum_{i=0}^{b+1}\binom{b}{i-1}\binom{n-i}{a}$$

$$=F(a,b)+\sum_{i=0}^{b+1}\binom{b}{i-1}\binom{n-i}{a}$$

$$=\sum_{i=1}^{b+1}\binom{b}{i-1}\binom{n-i}{a}+F(a,b)$$

$$=\sum_{i=0}^{b}\binom{b}{i}\binom{n-i-1}{a}+F(a,b)$$

$$=\sum_{i=0}^{b}\binom{b}{i}\binom{n-i}{a}-\sum_{i=0}^{b}\binom{b}{i}\binom{n-i-1}{a-1}+F(a,b)$$

$$=2F(a,b)-\sum_{i=0}^{b}\binom{b}{i}\binom{n-i-1}{a-1}$$

对于后面的式子，发现与 $\sum_{i=0}^{b}\dbinom{b}{i}\dbinom{n-i-1}{a}$ 相似

考虑逆推回去

$$\sum_{i=0}^{b}\binom{b}{i}\binom{n-i-1}{a-1}$$

$$=\sum_{i=1}^{b+1}\binom{b}{i-1}\binom{n-i}{a-1}$$

$$=\sum_{i=1}^{b+1}\binom{b+1}{i}\binom{n-i}{a-1}-\sum_{i=1}^{b+1}\binom{b}{i}\binom{n-i}{a-1}$$

$$=F(a-1,b+1)-\sum_{i=1}^{b}\binom{b}{i}\binom{n-i}{a-1}$$

$$=F(a-1,b+1)-F(a-1,b)$$

带回刚才推出的式子得

$$F(a,b+1)=2F(a,b)-F(a-1,b+1)+F(a-1,b)$$

$$F(a,b)=2F(a,b-1)+F(a-1,b-1)-F(a-1,b)$$

现在可以递推了

但是需要求 $F(0,k)$ 和 $F(k,0)$

$F(k,0)=\binom{n}{k}$ 可以 $\mathcal{O(m)}$ 求

而 $F(0,k)$ 按照原等式展开，然后预处理阶乘也可 $\mathcal{O(m)}$ 求

总复杂度 $\mathcal{O}(m^2)$ 

[码](https://www.luogu.com.cn/paste/5fixa8kw)











---

## 作者：dengyaotriangle (赞：6)

题目要求

$$f(a,b)=\sum_i \binom{b}{i}\binom{n-i}{a}$$

考虑一个多项式


$$
\begin{aligned}
F_b(x)&=\sum_ax^a\sum_i \binom{b}{i}\binom{n-i}{a}\\

& = \sum_i \binom{b}{i}\sum_ax^a\binom{n-i}{a}\\
& = \sum_i \binom{b}{i}(1+x)^{n-i}\\
& = (1+x)^n\sum_i \binom{b}{i}(1+x)^{-i}\\
& = (1+x)^n(1+(1+x)^{-1})^b\\
& = (1+x)^{n-b}(2+x)^b\\
\end{aligned}$$

我们只需要对于 $F_1(x)\cdots F_m(x)$ 知道它的前 $m$ 项系数即可。
## sol 1
我们知道，$F_0(x)=(1+x)^n$，我们很容易可以求出 $F_0(x) \bmod x^{m+1}$

而 $F_b(x)\equiv F_{b-1}(x)\frac{2+x}{1+x}\pmod{x^{m+1}}$。

给一个多项式乘上 $2+x$ 这件事情是很容易。

给一个多项式除去 $1+x$ 就相当于乘上 $1-x+x^2-x^3+\cdots$，可以使用前缀和优化，或者你也可以理解为可撤销背包。

于是，我们可以 $O(m)$ 从 $F_b(x)$ 递推到 $F_{b+1}(x)$ ，总复杂度 $O(m^2)$
## sol 2
我们知道 

$$(1+x)(2+x)\frac{\mathrm{d}}{\mathrm{d}x}{F_b(x)}=(1+x)^{n-b}(2+x)^{b}(2n-b+nx)=F_b(x)(2n-b+nx)$$

提取第 $t$ 项系数，
$$
[x^t](1+x)(2+x)\frac{\mathrm{d}}{\mathrm{d}x}{F_b(x)}=[x^t]F_b(x)(2n-b+nx)
$$

若令 $f_t$ 代表 $F_b(x)$ 的第 $t$ 项系数，
$$
2(t+1)f_{t+1}+3tf_t+(t-1)f_{t-1}=nf_{t-1}+(2n-b)f_t
$$
$$
f_{t+1}=\frac{(n-t+1)f_{t-1}+(2n-b-3t)f_t}{2(t+1)}
$$

而 $f_0=2^b$ ，所以我们对于每一个 $b$ 递推得到所有 $a$ 处的值，若预处理逆元复杂度 $O(m^2)$。同时注意到这个做法可以线性求任意一行的前几项，而且对于其它问题也可以得以拓展。
## code 1
```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

const int mdn=998244353;
const int maxn=5005;

int n,m;
int inv[maxn];
int f[maxn];

int main(){
    cin>>n>>m;
    inv[1]=1;for(int i=2;i<=m;i++)inv[i]=inv[mdn%i]*(long long)(mdn-mdn/i)%mdn;
    int z=1,z1=1;
    for(int i=0;i<=m;i++){
        f[i]=z*(long long)z1%mdn;
        z=z*(long long)(n-i)%mdn;
        z1=z1*(long long)inv[i+1]%mdn;
    }
    int ans=0;
    for(int i=1;i<=m;i++){
        for(int j=m;j>=1;j--)f[j]=(f[j]*2u+f[j-1])%mdn;
        f[0]=f[0]*2u%mdn;
        for(int j=1;j<=m;j++){
            f[j]-=f[j-1];f[j]+=(f[j]<0?mdn:0);
            ans^=f[j];
        }
    }
    cout<<ans;
    return 0;
}
```
## code 2
```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

const int mdn=998244353;
const int maxn=5005;
const int inv2=(mdn+1)/2;
int f[maxn];
int inv[maxn];

int main(){
    int n,m;
    cin>>n>>m;
    inv[1]=1;for(int i=2;i<=m;i++)inv[i]=inv[mdn%i]*(long long)(mdn-mdn/i)%mdn;
    int ans=0;
    f[0]=1;
    for(int i=1;i<=m;i++){
        f[0]=f[0]*2%mdn;
        for(int j=1;j<=m;j++){
            if(j==1)f[j]=(2*n-i)*(long long)inv2%mdn*f[0]%mdn;
            else f[j]=((n-j+2)*(long long)f[j-2]+(2ll*n-i+(mdn-3ll)*(j-1))%mdn*f[j-1])%mdn*inv2%mdn*inv[j]%mdn;
            ans^=f[j];
        }
    }
    cout<<ans;
    return 0;
}
```



---

## 作者：_ANIG_ (赞：5)

$$f_{a,b}=\sum\limits_{i=0}^bC(b,i)C(n-i,a)$$

$$=\sum\limits_{i=0}^b(C(b-1,i)+C(b-1,i-1))C(n-i,a)$$

$$=\sum\limits_{i=0}^bC(b-1,i)C(n-i,a)+\sum\limits_{i=0}^bC(b-1,i-1)C(n-i,a)$$

$$=\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i,a)+\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i-1,a)$$

$$=f_{a,b-1}+\sum\limits_{i=0}^{b-1}C(b-1,i)(C(n-i,a)-C(n-i-1,a-1))$$

$$=f_{a,b-1}+\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i,a)-\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i-1,a-1)$$

$$=2f_{a,b-1}-\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i-1,a-1)$$

考虑求 $\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i-1,a-1)$。

$$\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i-1,a-1)$$

$$=\sum\limits_{i=0}^{b-1}(C(b,i+1)-C(b-1,i+1))C(n-i-1,a-1)$$

$$=\sum\limits_{i=0}^{b-1}C(b,i+1)C(n-i-1,a-1)-\sum\limits_{i=0}^{b-1}C(b-1,i+1)C(n-i-1,a-1)$$

$$=\sum\limits_{i=1}^bC(b,i)C(n-i,a-1)-\sum\limits_{i=1}^{b-1}C(b-1,i)C(n-i,a-1)$$

$$=(\sum\limits_{i=0}^bC(b,i)C(n-i,a-1)-C(n,a-1))-(\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i,a-1)-C(n,a-1))$$

$$=\sum\limits_{i=0}^bC(b,i)C(n-i,a-1)-\sum\limits_{i=0}^{b-1}C(b-1,i)C(n-i,a-1)$$

$$=f_{a-1,b}-f_{a-1,b-1}$$

综上

$$f_{a,b}=2f_{a,b-1}-f_{a-1,b}+f_{a-1,b-1}$$

$m^2$ 递推即可。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=5005,mods=998244353;
int n,m,f[N][N],C[N][N],ny[N],res;
int gets(int a,int b){
    int res=1;
    for(int i=a-b+1;i<=a;i++)res=res*i%mods;
    for(int i=1;i<=b;i++)res=res*ny[i]%mods;
    return res;
}
int pows(int a,int b){
    if(b==0)return 1;
    int res=pows(a,b>>1);
    res=res*res%mods;
    if(b&1)res=res*a%mods;
    return res;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++)ny[i]=pows(i,mods-2);
    for(int i=0;i<=m;i++)C[i][0]=1;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=m;j++)C[i][j]=C[i-1][j-1]+C[i-1][j],C[i][j]%=mods;
    for(int i=0;i<=m;i++){
        for(int j=0;j<=i;j++)f[0][i]+=C[i][j],f[0][i]%=mods;
        f[i][0]=gets(n,i);
    }
    for(int i=1;i<=m;i++){
        for(int j=1;j<=m;j++){
            f[i][j]=2*f[i][j-1]-f[i-1][j]+f[i-1][j-1];
            f[i][j]=(f[i][j]%mods+mods)%mods;
            res^=f[i][j];
        }
    }
    cout<<res;
}
```


---

## 作者：dAniel_lele (赞：4)

容易发现 $\oplus$ 是没有性质的，也就是要求所有 $F(a,b)$。

考虑递推。

$$F(a,b)=\sum_{i=0}^b\binom{b}{i}\binom{n-i}{a}$$

$$=\sum_{i=0}^b(\binom{b-1}{i-1}+\binom{b-1}{i})\binom{n-i}{a}$$

$$=\sum_{i=0}^b\binom{b-1}{i-1}\binom{n-i}{a}+F(a,b-1)$$

$$=\sum_{i=0}^{b-1}\binom{b-1}{i}\binom{n-(i+1)}{a}+F(a,b-1)$$

$$=\sum_{i=0}^{b-1}\binom{b-1}{i}(\binom{n-i}{a}+\binom{n-(i+1)}{a-1})+F(a,b-1)$$

$$=-\sum_{i=0}^{b-1}\binom{b-1}{i}\binom{n-(i+1)}{a-1}+F(a,b-1)+F(a,b-1)$$

$$=-\sum_{i=0}^{b-1}\binom{b-1}{i}(\binom{n-i}{a-1}-\binom{n-(i+1)}{a-2})+F(a,b-1)+F(a,b-1)$$

$$=\sum_{i=0}^{b-1}\binom{b-1}{i}\binom{n-(i+1)}{a-2}+F(a,b-1)+F(a,b-1)-F(a-1,b-1)$$

$$=\dots$$

$$=F(a,b-1)+F(a,b-1)-F(a-1,b-1)+F(a-2,b-1)-F(a-3,b-1)+\dots$$

容易 $O(m^2)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int mod=998244353;
//Combinatorics
int qp(int a,int b){
	if(b<0){
		return qp(qp(a,mod-2),-b);
	}
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int fac[3000005],inv[3000005];
void init(){
	fac[0]=1; for(int i=1;i<=3000000;i++) fac[i]=fac[i-1]*i%mod;
	inv[3000000]=qp(fac[3000000],mod-2); for(int i=2999999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return fac[i]*inv[j]%mod*inv[i-j]%mod;
}
//Fast input/output
int read(){
	char c; int ans=0; int z=1;
	while(!isdigit(c=getchar()))z-=2*(c=='-');
	do{ans=(ans*10+c-'0');}while(isdigit(c=getchar()));
	return ans*z;
}
void print(int x){
	if(x<0) putchar('-');
	if(llabs(x)>=10) print(llabs(x)/10);
	putchar((llabs(x)%10)+'0');
}
void endl(){
	putchar(10);
}
int f[5005][5005];
signed main(){
	init();
	int n,m,tmp=1,ans=0; cin>>n>>m;
	f[0][0]=1;
	for(int i=1;i<=m;i++) (tmp*=(n-i+1))%=mod,f[i][0]=tmp*inv[i]%mod;
	for(int i=1;i<=m;i++){
		f[0][i]=f[0][i-1]*2%mod;
		int tmp=f[0][i-1];
		for(int j=1;j<=m;j++){
			tmp=(f[j][i-1]+mod-tmp)%mod;
			f[j][i]=(tmp+f[j][i-1])%mod;
			ans^=f[j][i];
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Owen_codeisking (赞：4)

昨天某佬过来问我此题，想了一想，想出来了一个麻烦的做法。

定义三元函数 $f(n,a,b)=\sum {b\choose i}{n-i\choose a}$

现在来研究她的递推式：

$$f(n,a,b)=\sum {b\choose i}{n-i\choose a}$$

$$={n\choose a}+\sum_{i\ge 1} ({b-1\choose i}+{b-1\choose i-1}){n-i\choose a}$$

$$={n\choose a}+\sum_{i\ge 1} {b-1\choose i}{n-i\choose a}+\sum_{i\ge 1}{b-1\choose i-1}{n-i\choose a}$$

$$=f(n,a,b-1)+f(n-1,a,b-1)$$

接着我们发现对于 ${n-i\choose a}$ 也进行类似的变形，可以得到：

$$f(n,a,b)=f(n-1,a,b)+f(n-1,a-1,b)$$

将这个递推式代到上面，可以得到：

$$f(n,a,b)=f(n-1,a-1,b-1)+2\times f(n-1,a,b-1)$$

可以发现这个递推式 $n$ 和 $b$ 同时 $-1$，只有 $a$ 有时不变有时 $-1$。

根据某套路，将这个递推式视为一个三维平面的游走模型，以 $n,b,a$ 为 $x,y,z$ 轴。那么我们每次就是对角线走一步，或者对角线走完后走到上面的平面。而且，$f(n,a,b)$ 只和 $f(n-b,i,0)$ 有关。

$f(n-b,i,0)={n-b\choose i}$。而从 $(n-b,i,0)$ 走到 $(n,a,b)$ 时，共走了 $b$ 步，有 $a-i$ 次选择向上走，每次方案数为 $1$；有 $b-a+i$ 次选择不往上走，每次方案数为 $2$。

那么函数就可化为：

$$f(n,a,b)=\sum 2^{b-a+i}{n-b\choose i}{b\choose a-i}$$

将 $2^{b-a}$ 提出来：

$$f(n,a,b)=2^{b-a}\sum 2^i{n-b\choose i}{b\choose a-i}$$

$$=2^{b-a}(1+2x)^{n-b}(1+x)^b[x^a]$$

以上解决的是 $b\ge a$ 的问题，但实际上 $b<a$ 类似，可以推出相同的结论。

接着可以先预处理出 $(1+2x)^n$ 的前 $m$ 项多项式，每次乘上 $(1+x)$ 后除掉 $(1+2x)$。因为每次操作乘或除的都是一次式，所以单次 $\mathcal{O}(m)$，总时间 $\mathcal{O}(m^2)$。

突然想了一下，这个做法是不是可以拓展？比如给出 $n,b$ 求一行 $a$，$n,b\le 10^9,a\le 10^5$。

---

## 作者：zundamon (赞：3)

楼上各位大佬的博客思路都十分精妙！是我所达不到的程度。但个人认为，有许多地方讲的并不是很清楚。为了更加容易的理解，在此写下一篇 0 基础难度的详解。

## 前置知识：

相信有不少人做到这道题时，像我一样没有了解过**组合数恒等式**，无论是做题时还是看题解时都十分懵。

**组合数恒等式**：即关于组合数的等式，其中大部分为**递推式**。通常认为组合数恒等式有许多，赛时需要自己推，但较常用的几个是需要了解的。

我们比较熟悉的**杨辉三角式**就是最简单的组合数恒等式之一：

$$
\binom{n}{m} = \binom{n-1}{m} + \binom{n-1}{m-1}
$$

这也是我们待会需要用到的式子，记作**加法公式**。

--------

我们同样需要用到的**减法公式**由上式推来，移项得：

$$
\binom{n-1}{m} = \binom{n}{m} - \binom{n-1}{m-1}
$$

设 $n' = n + 1$，代入上式得：

$$
\binom{n+1-1}{m} = \binom{n+1}{m} - \binom{n+1-1}{m-1}
$$

即：

$$
\binom{n}{m} = \binom{n+1}{m} - \binom{n}{m-1}
$$

记作**减法公式**。

下面开始正式讲解。

## 思路

发现式子的运算量比较多，直接算显然不可行。但 $m$ 较小，若能将 $F(a,b)$ 转为递推式，是可以 $m^2$ 计算的。

$$
F(a,b) = \sum^{b}_{i=0} \binom{b}{i}\binom{n-i}{a}
$$

对于 $\binom{b}{i}$ 项使用**加法公式**，乘法分配律得到。

$$
\begin{aligned}
\sum^{b}_{i=0}\binom{b}{i}\binom{n-i}{a} &= \sum^{b}_{i=0} \binom{b}{i}\binom{n-i}{a}\\
&= \sum^{b}_{i=0}\binom{b-1}{i}\binom{n-i}{a} + \sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a}
\end{aligned}
$$

发现前面一项符合 $F(a,b-1)$ 的形式。
$$
\begin{aligned}
F(a,b) &= F(a,b-1) + \sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a} 
\end{aligned}
$$

**(特别标注此式子，下文会用到。）**

对于后面一项使用 **减法公式**，得到：
$$
\begin{aligned}
F(a,b) &= F(a,b-1) + \sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-(i-1)}{a} - \sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a-1}
\end{aligned}
$$


------

这里我们发现，对于 $\sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-(i-1)}{a}$ 一项，$i-1$ 会出现负数的情况。

我们如何理解组合数中出现的负数呢？可以简单地理解为，不存在任意一种方案，可以选取到负数个物品。

所以得到： $\forall \binom{n}{m} = 0 (n<0)$

-------

在 $\sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-(i-1)}{a}$ 一项中，由于是求和，所以 $i-1$ 为负数时的值为 $0$ ，对答案没有影响。

而 $i-1$ 最大会取到 $b-1$，所以此项可以化简为：

$$
\sum^{b-1}_{i=0}\binom{b-1}{i}\binom{n-i}{a}
$$
 
即： $F(a,b-1)$

带回原式：

$$
\begin{aligned}
F(a,b) &= F(a,b-1) + F(a,b-1) - \sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a-1}
\end{aligned}
$$

此处对于 $\sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a-1}$ 一项，我们可以使用上文标注的式子化简：

----
上文标注的式子：

$$
\begin{aligned}
F(a,b) &= F(a,b-1) + \sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a} 
\end{aligned}
$$

移项得：$
\begin{aligned}
F(a,b) - F(a,b-1) &= \sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a} 
\end{aligned}$

----

则：

$$
\sum^{b}_{i=0}\binom{b-1}{i-1}\binom{n-i}{a-1} = F(a-1,b) - F(a-1,b-1)
$$

带回原式：

$$
\begin{aligned}
F(a,b) &= F(a,b-1) + F(a,b-1) + F(a-1,b-1) - F(a-1,b)
\end{aligned}
$$

最终得到递推式：

$$
\begin{aligned}
F(a,b) &= 2F(a,b-1) + F(a-1,b-1) - F(a-1,b)
\end{aligned}
$$

此处使用 $m^2$ 递推求即可。注意边界值：

$$
F(a,0) = \binom{n}{a}
$$

$$
F(0,b) = 2^b
$$

------

附上代码：

```cpp
#define ll long long
#define loop(i,x,y) for(int i=x;i<=y;i++)
#define doop(i,x,y) for(int i=x;i>=y;i--)
using namespace std;
int read(){int x=0,y=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') y=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+(ch^48);	ch=getchar();}return x*y;}
const int Mod=998244353;
const long long N=5005;
ll n,m;
ll f[N][N];
ll ans=0;
ll res=1;
ll ksm(ll x,ll a){
	ll res=1;
	while(a){
		if(a&1) res=(res*x)%Mod;
		x=(x*x)%Mod;
		a>>=1;
	}
	return res;
}
signed main(){
	n=read(),m=read();
	loop(i,0,m){
		ll up=1,down=1;
		loop(j,n-i+1,n) up=(1LL*up*j)%Mod;
		loop(j,1,i) down=(1LL*down*j)%Mod;
		f[i][0]=up*ksm(down,Mod-2)%Mod;
		if(i!=0)
		f[0][i]=ksm(2,i);
	}
	loop(i,1,m){
		loop(j,1,m){
			f[i][j]=((2*f[i][j-1]+f[i-1][j-1]-f[i-1][j])%Mod+Mod)%Mod;
			ans^=f[i][j];
		}
	}
	cout<<ans;
	return 0;
}
```




---

## 作者：Warriors_Cat (赞：3)

[题面传送门](https://www.luogu.com.cn/problem/P7481)。

题意：

* 给定 $n, m$ 且 $m \le n$，定义 $F(a, b) = \sum\limits_{i=0}^b\dbinom{b}{i}\dbinom{n-i}{a}$。

* 求 $\bigoplus_{a=1}^{m}\bigoplus_{b=1}^{m}(F(a,b) \bmod 998244353)$，其中 $\bigoplus$ 表示异或和。

* $n \le 10^9, m \le 5\times 10^3$。

感觉还算一道有意思的数学题（？

---

### Solution：

看到数据范围后考虑 $O(m^2)$ 的算法，于是可以想到递推。我们看一下 $F(a, b + 1)$ 是什么。

先给一个引理：$\dbinom{n}{i}=\dbinom{n}{i-1}+\dbinom{n-1}{i-1}$，证明直接结合杨辉三角或者组合意义即可。

然后直接硬搞，想法子往 $F$ 的形式凑：

$$\begin{aligned}
F(a, b + 1)&=
\sum_{i=0}^{b+1}\binom{b+1}{i}\binom{n-i}{a}
\\&=\sum_{i=0}^{b+1}\binom{b}{i}\binom{n-i}{a}+\sum_{i=0}^{b+1}\binom{b}{i-1}\binom{n-i}{a}
\\&=F(a, b) + \sum_{i=1}^{b+1}\binom{b}{i-1}\binom{n-i}{a}
\\&=F(a, b) + \sum_{i=0}^b\binom{b}{i}\binom{n-i-1}{a}
\\&=F(a, b) + \sum_{i=0}^b\binom{b}{i}\binom{n-i}{a}-\sum_{i=0}^b\binom{b}{i}\binom{n-i-1}{a-1}
\\&=2F(a, b)-\sum_{i=1}^{b+1}\binom{b}{i-1}\binom{n-i}{a-1}
\\&=2F(a, b)-\sum_{i=1}^{b+1}\binom{b+1}{i}\binom{n-i}{a-1}+\sum_{i=1}^{b+1}\binom{b}{i}\binom{n-i}{a-1}
\\&=2F(a, b)-F(a-1, b+1)+\binom{b+1}{0}\binom{n}{a-1}+F(a-1, b)-\binom{b}{0}\binom{n}{a-1}
\\&=2F(a, b)-F(a-1, b+1)+F(a-1, b)
\end{aligned}$$

因此就有：

$$F(a, b)=2F(a, b-1)-F(a-1, b)+F(a-1, b-1)$$

于是我们成功地转化成了一个递推式！！！111

最后就是边界问题了。这里的边界就是要求 $F(a, 0)$ 和 $F(0, b)$。$F(a, 0)$ 很好办，直接就是 $\dbinom{n}{a}$，$F(0, b)$ 代回原式发现就是 $\sum\limits_{i=0}^b\binom{b}{i}=2^b$。

然后就做完了……时间复杂度为 $O(m^2)$。

---

### Code：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 5010, mod = 998244353;
int n, m, f[N][N], inv[N]; 
inline void mian(){
	n = read(); m = read(); int nw = 1; inv[0] = inv[1] = 1;
	rep(i, 2, m) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
	rep(i, 0, m) f[i][0] = nw, nw = 1ll * nw * ((n - i) % mod) % mod * inv[i + 1] % mod;
	nw = 1; rep(i, 0, m) f[0][i] = nw, nw = 2ll * nw % mod;
	rep(i, 1, m) rep(j, 1, m){
		f[i][j] = ((2ll * f[i][j - 1] % mod - f[i - 1][j] + mod) % mod + f[i - 1][j - 1]) % mod;
	}
	int ans = 0; rep(i, 1, m) rep(j, 1, m) ans ^= f[i][j];
	printf("%d\n", ans);
}
int main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```


---

## 作者：zhenjianuo2025 (赞：2)

[You can see it here.](https://www.luogu.com.cn/blog/534654/solution-binoms)

### Solve

首先，形象化地，$F(a,b)\ (a,b\le m)$ 可以看作是 $n$ 个球，前 $b$ 个球中选出任意个（可以不选），再从剩下的球中选出 $a$ 个的方案数。

设 $f_{i,j}=F(j,i)\ (i,j\le m)$，即 $n$ 个球，前 $i$ 个球中选出任意个（可以不选），再从剩下的球中选出 $j$ 个的方案数。

为了方便转移，设 $g_{i,j}$ 为 $f_{i,j}$ 在不选第 $i+1$ 个球时的方案数。

$$\large
f_{i,j}=f_{i-1,j}+g_{i-1,j}\\
g_{i,j}=f_{i,j}-g_{i,j-1}
$$

$f_{i.j}$ 若不选第 $i$ 个，答案为 $f_{i-1,j}$，后边还可以再选第 $i$ 个；若选，答案为 $g_{i-1,j}$，后边就不能再选了。

$g_{i,j}$ 就是总方案数减去选第 $i+1$ 个的方案数 $g_{i,j-1}$。

$$
\binom{n}{i}=\dfrac{n!}{(n-i)!\ i!}=\dfrac{n!}{(n-i+1)!\ (i-1)!}\cdot \dfrac{n-i+1}{i}
$$

---

## 作者：big_news (赞：2)

砷铋题淦了两个小时，不愧是我。

一开始想着对 $a$ 或者 $b$ 扰动，想了 114514 年都凑不出系数来。

然后发现大力拆一波组合数就好了/kk

设 $F(A,B)=\sum_{i=0}^A\binom A i\binom{n-i}{B}$，有 $F(A,B)=\sum_{i=0}^A \binom{A-1}{i}\binom{n-i}{B}+\sum_{i=0}^A\binom{A-1}{i-1}\binom{n-i}{B}=F(A-1,B)+[]$

把括号 $[]$ 里面设成 $G(A,B)=\sum_{i=0}^A\binom{A}{i}\binom{n-i-1}{B}$，再拆一次：$G(A,B)+G(A,B-1)=\sum_{i=0}^A \binom A i\left[\binom{n-i-1}{B}+\binom{n-i-1}{B-1} \right]=F(A,B)$。

然后有递推式 $F(A,B)=F(A-1,B)+G(A-1,B), G(A,B)=F(A,B)-G(A,B-1)$。由于后面那个组合数的边界问题，第一个递推式在 $A\le n$ 时成立，第二个递推式在 $A<n$ 时成立。

然后题目保证 $m\le n$，于是就做完了，复杂度 $O(m^2)$。

代码：

```cpp
#include<iostream>
using namespace std; typedef long long LL; const int P = 998244353, CN = 5050;
int add(int x, int y) {return x + y >= P ? x + y - P : x + y;}
int n, m, fn[CN], ifac[CN], f[CN][CN], g[CN][CN];
int main(){
    m = 5000, ifac[0] = ifac[1] = 1; for(int i = 2; i <= m; i++) ifac[i] = (LL)ifac[P % i] * (P - P / i) % P;
    for(int i = 2; i <= m; i++) ifac[i] = (LL)ifac[i - 1] * ifac[i] % P;
    cin >> n >> m, fn[0] = 1; for(int i = 1; i <= m; i++) fn[i] = (LL)fn[i - 1] * (n - i + 1) % P;
    for(int i = 0; i <= m; i++) f[0][i] = (LL)fn[i] * ifac[i] % P;
    n--; for(int i = 1; i <= m; i++) fn[i] = (LL)fn[i - 1] * (n - i + 1) % P;
    for(int i = 0; i <= m; i++) g[0][i] = (LL)fn[i] * ifac[i] % P;
    for(int i = 1; i <= m; i++){
        f[i][0] = g[i][0] = add(f[i - 1][0], f[i - 1][0]);
        for(int j = 1; j <= m; j++){
            f[i][j] = add(f[i - 1][j], g[i - 1][j]);
            g[i][j] = add(f[i][j], P - g[i][j - 1]);
        }
    }
    int ans = 0;
    for(int i = 1; i <= m; i++) for(int j = 1; j <= m; j++) ans ^= f[i][j];
    cout << ans << endl; return 0;
}
```

---


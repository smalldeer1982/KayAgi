# 不条理狂诗曲

## 题目背景

YSGHYYDS

## 题目描述

YSGH 有一个长度为 $n$ 的非负整数序列 $a$，定义 $f(l, r)$ 表示从 $a$ 序列的区间 $[l, r]$ 选择若干不相邻的数的和的最大值。 

YSGH 想知道 $\displaystyle \left[ \sum_{l = 1}^{n} \sum_{r = l}^{n} f(l, r) \right] \bmod ({10}^9 + 7)$ 。

## 说明/提示

**【样例解释】**

$f(1, 1)=1$，$f(1, 2)=2$，$f(1, 3)=5$，$f(2, 2)=2$，$f(2, 3)=4$，$f(3, 3)=4$。

答案为 $1 + 2 + 5 + 2 + 4 + 4 = 18$。

---

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$0 \le a_i \le {10}^9$。

- Subtask 1（10 points）：$n \le 500$。
- Subtask 2（20 points）：$n \le 5000$。
- Subtask 3（20 points）：$a_i \in \{ 0, 1 \}$。
- Subtask 4（20 points）：$a_i \in \{ 1, x \}$，$x$ 是大于 $1$ 的整数。
- Subtask 5（30 points）：无特殊限制。

## 样例 #1

### 输入

```
3
1 2 4```

### 输出

```
18```

# 题解

## 作者：BreakPlus (赞：21)

一个好写 $\mathcal{O}(n)$ 的做法。好像题解区都是分治？

----

考虑对于每个右端点计算答案。

众所周知，最大独立集问题是可以 DP 的。具体地，维护两个 DP 值 $f,g$，其中 $f$ 表示最后一个数**任意**的最大独立集的值，$g$ 表示最后一个数**必须不选**的最大独立集的值。

若在末尾加入一个值为 $a_i$ 的数，则转移如下：

$$f' = \max(f, g+a_i), g' = f$$

这类问题有一个经典转化（类似 PKUSC2024 D1T3）。把转移式子写成以下形式：

$$f' = f + \max(0, a_i - (f-g)), g' = f$$

发现每次新加入一个数， $f$ 的变化量与新的 $f'-g'$ **均为** $\max(0, a_i-(f-g))$。这个值只和 $f-g$ 有关。

也就是说，我们将答案进行拆贡献，每加入一个数，答案就增加 $\max(0, a_i-(f-g))$。这样，我们只需要时刻维护 $f-g$ 的值，每次转移就 $f'-g'=\max(0, a_i-(f-g))$。于是可以完成对答案的计算。

----

我们从左往右扫，假设扫到 $x$，对每个 $i$ 维护以 $i$ 为左端点，$x$ 为右端点的区间的 $f-g$ 的值。维护一个多重集 $S$，囊括所有的 $f-g$。

记录 $r_x$ 表示所有右端点为 $x$ 的区间的最大独立集之和。每次移动 $x$，都相当于对 $i \in [1,x-1]$ 的 $d_i$ 做了一次转移（右边新加一个 $a_x$）。

实时维护 $r_x$ 的变化量，即 $r_x - r_{x-1}$，记作 $\Delta_x$。其实这个值也就等于 $\sum \max(0, a_x - (f-g)) = \sum (f'-g')$。

如果不考虑要与 $0$ 取 $\max$，不难得到 $\Delta_x=-\Delta_{x-1}+xa_x$，也就是每一个 $(f-g)$ 都变成 $a_x-(f-g)$。

发现会有一些 $a_x - (f-g)$ 小于 $0$。我们直接从 $S$ 的最大值开始判断，暴力将所有这样的 $f-g$ 全部手动改成 $0$。而其它的 $f-g$ 在全局打 tag 完成修改（这个地方略有一点细节）。

手动改成 $0$ 是否复杂度寄了？发现 $f-g$ 值相同的可以捆绑在一起维护，所有手动修改的 $f-g$ 都变成了 $0$。

于是我们可以在 $S$ 中维护二元组，记录 $f-g$ 的值和这种值出现的次数。通过势能分析，我们只会往 $S$ 里加入 $n$ 个数，每次手动修改都会使 $|S|$ 减小 $1$。

具体实现的时候发现 $S$ 时刻保持着有序，只会在头尾修改，拿个 deque 搞一下就是 $\mathcal{O}(n)$ 的了。

```cpp
ll n,a[100005],tx=1,ty=0,sum=0,ans=0,Ans=0;
deque<P>S;
// tx, ty 是全局 tag，S 中的一个数 x 其实已经变成了 tx * x + ty
// tx 为 1 或 -1，所以序列有时候升序有时候降序，但时刻保持有序

ll decode(ll x){ return tx * x + ty; } // 还原真正的 x
ll encode(ll x){ return (x - ty) / tx; } // 加入的时候需要进行逆操作 
void solve(){
    n=read();
    for(ll i=1;i<=n;i++) a[i]=read();
    for(ll i=1;i<=n;i++){
        if(S.empty() || encode(0) <= S.front().fi) S.push_front(mkp(encode(0), 1));
        else S.push_back(mkp(encode(0), 1));
        tx=-tx; sum=mod-sum;
        ty=-ty+a[i]; sum=(sum+a[i]*i)%mod; // 全局修改

        ll cnt = 0;
        while(!S.empty() && decode(S.front().fi) < 0){
            sum=(sum+(-decode(S.front().fi))*(S.front().se))%mod;
            cnt+=S.front().se; S.pop_front();
        }

        while(S.size() && decode(S.back().fi) < 0){
            sum=(sum+(-decode(S.back().fi))*(S.back().se))%mod;
            cnt+=S.back().se; S.pop_back();
        } // 对首尾的特殊修改
      // sum 是 r[x] 的变化量

        if(S.empty() || encode(0) <= S.front().fi) S.push_front(mkp(encode(0), cnt));
        else S.push_back(mkp(encode(0), cnt));
        _Add(ans, sum); // ans 是 r[x]
        _Add(Ans, ans); // Ans 是总的答案
    }
    printf("%lld\n", Ans);
}
```

---

## 作者：meyi (赞：14)

2021/6/19 UPD: 修正了一些typo

考虑分治，对于一段区间 $[L,R]$，令 $mid=\lfloor\frac{L+R}{2}\rfloor$，我们可以将其子区间分为三类：

- 左端点和右端点都在 $[L,mid]$ 上。

- 左端点和右端点都在 $[mid+1,R]$ 上。

- 左端点在 $[L,mid]$ 上，右端点在 $[mid+1,R]$ 上。

对于第一、二种情况，我们直接递归到该子区间以同样的方法求解，于是只需要考虑第三种情况的贡献。

令 $fl_i$ 为选取 $a_{mid}$ 的 $[i,mid]$ 段最大值，$gl_i$ 为不选取 $a_{mid}$ 的 $[i,mid]$ 段最大值，
$fr_i$ 为选取 $a_{mid+1}$ 的 $[mid+1,i]$ 段最大值，
$gr_i$ 为不选取 $a_{mid+1}$ 的 $[mid+1,i]$ 段最大值，那么题目中的 $f(l,r)=\max(fl_l+gr_r,gl_l+fr_r,gl_l+gr_r)=\max(\max(fl_l,gl_l)+gr_r,gl_l+fr_r)$。

考虑选取 $gl_l+fr_r$ 的情况，显然 $\max(fl_l,gl_l)+gr_r<gl_l+fr_r$，移项，将相同下标的数移到同侧，可以得到 $\max(fl_l-gl_l,0)<fr_r-gr_r$。

于是我们对于每个左端点，即 $[L,mid]$ 中的所有点，将其 $\max(fl_l-gl_l,0)$ 记录在数组 $tl$ 中，并将 $tl$ 排序。对排序后的 $tl$ 数组，开两个前缀和数组 $sgl$ 和 $sml$，$sgl$ 为 $gl$ 的前缀和， $sml$ 为 $\max(fl-gl,0)$ 的前缀和。然后我们在 $[mid+1,R]$ 上枚举右端点 $i$，二分 $tl$ 中比 $fr_i-gr_i$ 小的元素个数，若有 $k$ 个，那么以 $i$ 为右端点，左端点在 $[L,mid]$ 中的所有区间对答案的贡献为 $sgl_{k-1}+(k-l)\times fr_i+sml_{mid}-sml_{k-1}+(mid-k+1)\times gr_i$。

最后提醒一下，上述过程中，不应将 $fl$ 和 $gl$ 数组取模，因为我们需要对 $tl$ 排序，若取模则可能会影响 $tl$ 中各元素的顺序。

时间复杂度： $O(n\log^2n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int
typedef long long ll;
const int maxn=1e5+10,mod=1e9+7;
struct node{
	ll val;
	int id;
	inline bool operator<(const node &k)const{
		return val<k.val;
	}
}tl[maxn];
int a[maxn],n;
ll ans,fl[maxn],fr[maxn],gl[maxn],gr[maxn],sml[maxn],sgl[maxn];
void solve(int l,int r){
	if(l==r){
		ans=(ans+a[l])%mod;
		return;
	}
	int mid=l+r>>1;
	solve(l,mid);
	solve(mid+1,r);
	for(ri i=mid;i>=l;--i){
		if(i==mid)fl[i]=a[i],fl[i+1]=gl[i]=0;
		else fl[i]=max(fl[i+1],fl[i+2]+a[i]);
		if(i==mid-1)gl[i]=a[i],gl[i+1]=0;
		else if(i!=mid)gl[i]=max(gl[i+1],gl[i+2]+a[i]);
		tl[i]={max(fl[i]-gl[i],0ll),i};
	}
	sort(tl+l,tl+mid+1);
	sml[l-1]=sgl[l-1]=0;
	for(ri i=l;i<=mid;++i){
		sml[i]=sml[i-1]+max(fl[tl[i].id],gl[tl[i].id]);
		sgl[i]=sgl[i-1]+gl[tl[i].id];
	}
	for(ri i=mid+1;i<=r;++i){
		if(i==mid+1)fr[i]=a[i],fr[i-1]=gr[i]=0;
		else fr[i]=max(fr[i-1],fr[i-2]+a[i]);
		if(i==mid+2)gr[i]=a[i];
		else if(i!=mid+1)gr[i]=max(gr[i-1],gr[i-2]+a[i]);
		ri k=lower_bound(tl+l,tl+mid+1,node{fr[i]-gr[i],0})-tl;
		ans=(ans+(sml[mid]-sml[k-1])%mod+(mid-k+1)*(gr[i]%mod)%mod)%mod;
		ans=(ans+(sgl[k-1]%mod)+(k-l)*(fr[i]%mod)%mod)%mod;
	}
}
int main(){
	scanf("%d",&n);
	for(ri i=1;i<=n;++i)scanf("%d",a+i);
	solve(1,n);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Leap_Frog (赞：14)

### Link.
[Luogu](https://www.luogu.com.cn/problem/P7482)  
[更紬的阅读体验](https://www.cnblogs.com/pealfrog/p/15171835.html)  

### Description.
给定一个序列 $\{a_i\}$，定义 $f(l,r)$ 表示 $[l,r]$ 中取出一些不相邻数的最大和。  
求 $\sum_{l=1}^n\sum_{r=l}^nf(l,r)$。  

### Solution.
楼上有一个步骤比较复杂其实的说。  

分治，拆贡献，然后接下来需要考虑跨过 $l\le md,r>md$ 的 $f(l,r)$ 贡献。  
左右两边除了选中点之外互不干扰，我们考虑直接 `dp` 的合并。  
先左边做一遍 `dp`，右边做一遍 `dp`，设 $f_l(i),g_l(i),f_r(i),g_r(i)$ 表示从 $md/md+1$ `dp` 到 $i$，$md/md+1$ 选或不选的最大和。  
答案 $f(a,b)$ 就是 $\max(f_l(a)+g_r(b),g_l(a)+f_r(b))$。  
考虑决策，若 $f_l(a)+g_r(b)<g_l(a)+f_r(b)$，则有 $f_r(b)-g_r(b)>f_l(a)-g_l(a)$  
然后直接左边按照 $f_l(a)-g_l(b)$ 排序，就能找到决策点。  
然后维护一下 $f_l(x)$ 的前缀和和 $g_l(x)$ 的后缀和即可。  

### Coding.
```cpp
//是啊，你就是那只鬼了，所以被你碰到以后，就轮到我变成鬼了{{{
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<48||c>57;c=getchar()) if(!(c^45)) f=1;
	for(;c>=48&&c<=57;c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	f?x=-x:x;
}
template<typename T,typename...L>inline void read(T &x,L&...l) {read(x),read(l...);}/*}}}*/
const int N=100005,P=1e9+7;int n,a[N],id[N],rs;
ll fl[N],gl[N],fr[N],gr[N],sf[N],sg[N];
struct ${ll f,g;char operator<($ b) const {return f-g<b.f-b.g;}}F[N];
inline void solve(int l,int r)
{
	int md=(l+r)>>1;if(l==r) return (rs+=a[l])%=P,void();else solve(l,md),solve(md+1,r);
	fl[md+1]=0,fl[md]=a[md];for(int i=md-1;i>=l;i--) fl[i]=max(fl[i+1],fl[i+2]+a[i]);
	gl[md]=0,gl[md-1]=a[md-1];for(int i=md-2;i>=l;i--) gl[i]=max(gl[i+1],gl[i+2]+a[i]);
	fr[md]=0,fr[md+1]=a[md+1];for(int i=md+2;i<=r;i++) fr[i]=max(fr[i-1],fr[i-2]+a[i]);
	gr[md+1]=0,gr[md+2]=a[md+2];for(int i=md+3;i<=r;i++) gr[i]=max(gr[i-1],gr[i-2]+a[i]);
	int tt=0;for(int i=l;i<=md;i++) F[++tt]=($){fl[i],gl[i]};
	sort(F+1,F+tt+1);for(int i=1;i<=tt;i++) sf[i]=sf[i-1]+F[i].f,sg[i]=sg[i-1]+F[i].g;
	//printf("%d %d %d : %d\n",l,md,r,rs);
	//if(l==1&&md==2&&r==3) for(int i=1;i<=tt;i++) printf("ll %lld %lld\n",F[i].f,F[i].g);
	for(int i=md+1;i<=r;i++)
	{
		int wh=lower_bound(F+1,F+tt+1,($){fr[i],gr[i]})-F-1;
		//if(l==1&&md==2&&r==3) printf("rr %lld %lld\n",fr[i],gr[i]);
		rs=(rs+(sf[tt]-sf[wh])+gr[i]%P*(tt-wh))%P;
		rs=(rs+sg[wh]+fr[i]%P*wh)%P;
	}
	//printf("%d %d %d : %d\n",l,md,r,rs);
}
int main()
{
	read(n);for(int i=1;i<=n;i++) read(a[i]);
	return solve(1,n),printf("%d\n",rs),0;
}
```

---

## 作者：KobeBeanBryantCox (赞：12)

# P7482 不条理狂诗曲 题解

------------

[题目传送门](https://www.luogu.com.cn/problem/P7482)。

### 声明：

本题解是对[这篇题解](https://www.luogu.com.cn/article/9qe8j83t)的补充，思路和做法完全一样，代码也差不多。

~~所以都不要来说我抄别人题解来发题解，只是补充说明而已。~~

当然，已经看懂那篇题解的大佬们可以跳过本题解了。

至少本蒟蒻刚开始是没怎么看懂的，所以这里解释有点长便于理解，请耐心阅读。

由于是补充，所以在本题解中会引用那篇题解的话，建议读者二者一起食用效果最佳。

------------

## 题意

此题题目描述简洁无废话，题意见题目描述。

------------

## 解法

### 1.

首先，因为是区间操作，而且区间可合并，考虑分治。

> 然后接下来需要考虑跨过 $l\leq md,r>md$ 的 $f(l,r)$ 贡献。

这句话意思是，对于区间 $[l,r]$，令 $md=\large\left\lfloor\frac{l+r}{2}\right\rfloor$，我们可以将其子区间分为三类：

1. 左端点和右端点都在 $[l,md]$ 上；
2. 左端点和右端点都在 $[md+1,r]$ 上；
3. 左端点在 $[l,md]$ 上，右端点在 $[md+1,r]$ 上。

对于前两种，直接递归到左区间和右区间计算即可，所以下面讨论第三种。

------------

### 2.

> 先左边做一遍 `dp`，右边做一遍 `dp`，设 $f_l(i),g_l(i),f_r(i),g_r(i)$ 表示从 $md/md+1$ `dp` 到 $i$，$md/md+1$ 选或不选的最大和。

这句话意思是，设 $f_l(i),g_l(i),f_r(i),g_r(i)$。

- $f_l(i)$ 表示从 $md$ 往左 `dp` 到 $i$ 的最大和，**其中 $md$ 可以选（非强制选）**。

- $g_l(i)$ 表示从 $md$ 往左 `dp` 到 $i$ 的最大和，**其中 $md$ 强制不能选**。

- $f_r(i)$ 表示从 $md+1$ 往右 `dp` 到 $i$ 的最大和，**其中 $md+1$ 可以选（非强制选）**。

- $g_r(i)$ 表示从 $md+1$ 往右 `dp` 到 $i$ 的最大和，**其中 $md+1$ 强制不能选**。

这四个应该都会求吧，不会求的看其他题解，这里不做展开。

------------

### 3.

易得：

> 答案 $f(a,b)$ 就是 $\max(f_l(a)+g_r(b),g_l(a)+f_r(b))$。

不做解释，不懂的画图理解。

> 考虑决策，若 $f_l(a)+g_r(b)<g_l(a)+f_r(b)$ 则有 $f_r(b)-g_r(b)>f_l(a)-g_l(a)$。

意思是，如果在 $\max$ 运算中取了后者，则满足上述移项后式子。

------------

### 4.

然后由于接下来不好操作，考虑拆开贡献。

> 然后直接左边按照 $f_l(a)-g_l(b)$ 排序，就能找到决策点。

这里应该是那篇题解作者笔误（？），应该是按照 $f_l(a)-g_l(a)$ 排序，不过无所谓，感性理解就行。

意思是，以 $f_l(a)-g_l(a)$ 为权值，从小到大排序。

然后对于每一个 $b$（也就是枚举 $b$），在排序后的数组中二分查找最后一个比 $f_r(b)-g_r(b)$ 小的 $f_l(a)-g_l(a)$ 的位置，假设记为 $k$。

接下来就找到一共有多少对 $a,b$ 满足 $f_r(b)-g_r(b)>f_l(a)-g_l(a)$（即 $k$ 对）。

那么就知道了原来的 $\max(f_l(a)+g_r(b),g_l(a)+f_r(b))$ 中取后者的个数（即 $k$）；

也就是知道了 $g_l(a)+f_r(b)$ 对于答案的贡献次数（即 $k$）。

由于是枚举的 $b$，则答案加上 $f_r(b)\times k+\sum_{i=1}^{k}g_l(i)$。

其中 $\sum$ 部分可以考虑使用前缀和与后缀和预处理出来，也就是原文的：

> 然后维护一下 $f_l(x)$ 的前缀和和 $g_l(x)$ 的后缀和即可。

最后别忘记取模。

------------

### 5.

对于 $\max(f_l(a)+g_r(b),g_l(a)+f_r(b))$ 中取前者的情况，同理可得，不做展开解释。

详见代码：

------------

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long
int in()
{
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=1e5+10,mod=1e9+7;
int ans=0;
int a[N],fl[N],fr[N],gl[N],gr[N],sf[N],sg[N];
struct nod
{
	int f,g;
	bool operator<(nod a)const
	{
		return f-g<a.f-a.g; // 以 fl[x]-gl[x] 为权值从小到大排序
	}
}F[N];
void solve(int l,int r)
{
	int mid=(l+r)>>1;
	if(l==r)
	{
		ans=(ans+a[l])%mod; // 就一个点，直接返回
		return;
	}
	else solve(l,mid),solve(mid+1,r); // 先递归
	fl[mid+1]=0,fl[mid]=a[mid];
	for(int i=mid-1;i>=l;i--)fl[i]=max(fl[i+1],fl[i+2]+a[i]); // 计算 fl
	gl[mid]=0,gl[mid-1]=a[mid-1];
	for(int i=mid-2;i>=l;i--)gl[i]=max(gl[i+1],gl[i+2]+a[i]);// 计算 gl
	fr[mid]=0,fr[mid+1]=a[mid+1];
	for(int i=mid+2;i<=r;i++)fr[i]=max(fr[i-1],fr[i-2]+a[i]);// 计算 fr
	gr[mid+1]=0,gr[mid+2]=a[mid+2];
	for(int i=mid+3;i<=r;i++)gr[i]=max(gr[i-1],gr[i-2]+a[i]); // 计算 gr
	int s=0;
	for(int i=l;i<=mid;i++)F[++s]=(nod){fl[i],gl[i]};
	sort(F+1,F+s+1); // 排序
	for(int i=1;i<=s;i++)sf[i]=sf[i-1]+F[i].f,sg[i]=sg[i-1]+F[i].g; // 前后缀和预处理
	for(int i=mid+1;i<=r;i++)
	{
		int k=lower_bound(F+1,F+s+1,(nod){fr[i],gr[i]})-F-1; // 二分查找位置 k
		ans=(ans+(sf[s]-sf[k])+gr[i]%mod*(s-k))%mod; // 计算 max 中取前者对答案的贡献
		ans=(ans+sg[k]+fr[i]%mod*k)%mod; // 计算 max 中取后者对答案的贡献
	}
}
signed main()
{
	int n=in();
	for(int i=1;i<=n;i++)a[i]=in();
	solve(1,n);
	out(ans),putchar('\n');
	return 0;
}
```

~~说句闲话：研究珂学的最好方法是：~~

~~看了我的题解，并且 A 了这道题。~~

~~祝你们成功（滑稽 (ಡωಡ)~~

------------

## 后记

1. 先膜拜 [Leap_Frog](https://www.luogu.com.cn/user/44805) 大佬 %%% sto orz，因为 ta 的题解使我受益匪浅。
2. 本题解如有解释错误，欢迎提出修改；如有解释不清，欢迎提问。
3. 注意：

> 十年 oi 一场空，不开 long long 见祖宗！
4. 给个关注呗，给个赞呗，帮忙顶到前排呗 QWQ

---

## 作者：TempestMiku (赞：7)

# [不条理狂诗曲](https://www.luogu.com.cn/problem/P7482)

## 题目大意

定义 $f(l, r)$ 表示从 $a$ 序列的区间 $[l, r]$ 选择若干不相邻的数的和的最大值。 

求 $\displaystyle \left[ \sum_{l = 1}^{n} \sum_{r = l}^{n} f(l, r) \right] \bmod ({10}^9 + 7)$。


## 思路


这道题需要用到序列分治。


对于一段区间 $l \sim r$，我们找出 $mid$，然后统计跨过 $mid$ 的区间答案，这样我们就能把 $n^2$ 的复杂度变成 $nlogn$。


定义 $f_{i,\left[0/1\right]}$，$f_{i,0}$ 代表不选择 $mid$ 左区间最大的和，$f_{i,1}$ 代表选择 $mid$ 左区间最大的和。


定义 $g_{i,\left[0/1\right]}$，$g_{i,0}$ 代表不选择 $mid+1$ 右区间最大的和，$g_{i,1}$ 代表选择 $mid+1$ 右区间最大的和。


我们先求出 $f$ 和 $g$。


然后面临一个问题。


假设 $i$ 表示左区间的指针，$j$ 表示右区间的指针。



- 如果没有选择 $mid$，那就可以选 $mid+1$ 也可以不选 $mid+1$。



$$f_{i,0}+\max{\{g_{j,0},g_{j,1}\}}$$



- 如果我们选择了 $mid$，那就不能选择 $mid+1$。



$$f_{i,1}+g_{j,0}$$



- 当 $f_{i,0}+\max{\{g_{j,0},g_{j,1}\}}>f_{i,1}+g_{j,0}$ 的时候我们选择前者，否则选择后者。



$$f_{i,0}+\max{\{g_{j,0},g_{j,1}\}}>f_{i,1}+g_{j,0}$$



$$f_{i,0}+\max{\{g_{j,0},g_{j,1}\}}-g_{j,0}>f_{i,1}$$



$$f_{i,0}+\max{\{0,g_{j,1}-g_{j,0}\}}>f_{i,1}$$



$$\max{\{0,g_{j,1}-g_{j,0}\}}>f_{i,1}-f_{i,0}$$



化简到如果 $\max{\{0,g_{j,1}-g_{j,0}\}}>f_{i,1}-f_{i,0}$ 的时候我们选择 $f_{i,0}+\max\{g_{j,0},g_{j,1}\}$，否则选择 $f_{i,1}+g_{j,0}$。



然后我们把左侧的 $f_{i,0}+\max\{g_{j,0},g_{j,1}\}$ 变成 $f_{i,0}+\max\{0,g_{j,1}-g_{j,0}\}+g_{j,0}$。



左侧和右侧都有 $g_{j,0}$ 的贡献，所以这个贡献一定会有，我们直接加上。



- 接下来我们记录一个 $cf_{i}$ 的值表示 $f_{i,1}-f_{i,0}$，一个 $cg_i$ 的值表示 $\max\{0,g_{i,1}-g_{i,0}\}$。


 
那么上面式子变成：


$$ans = \begin{cases}  
f_{i,0}+cg_j+g_{j,0} & cg_j> cf_i \\  
f_{i,1}+g_{j,0} & cg_j\le cf_i \\  
\end{cases}$$


$$ans = g_{j,0}+\begin{cases}  
f_{i,0}+cg_j & cg_j> cf_i \\  
f_{i,1} & cg_j\le cf_i \\  
\end{cases}$$


$$ans = g_{j,0}+f_{i,0}+\begin{cases}  
cg_j & cg_j> cf_i \\  
f_{i,1}-f_{i,0} & cg_j\le cf_i \\  
\end{cases}$$



$$ans = g_{j,0}+f_{i,0}+\begin{cases}  
cg_j & cg_j> cf_i \\  
cf_i & cg_j\le cf_i \\  
\end{cases}$$



那么问题就简单了，我们先统计出 $g_{j,0}+f_{i,0}$ 的贡献。



然后把 $cf$ 和 $cg$ 升序排序。



设 $ll$ 是左区间的指针，$rr$ 是右区间的指针。



对于每个 $cf_i$，从 $l$ 到 $mid$ 移动指针 $ll$ 的时候，我们不断将 $rr$ 指针向右移动，在 $rr$ 满足 $cg_j\le cf_i$ 的时候，我们就算 $cf_i$ 的贡献，否则就算 $cg_j$ 的贡献。



在代码中实现是：
```cpp
int rr=mid;
for(register int ll=l;ll<=mid;ll++){
    while(cg[rr+1]<=cf[ll]&&rr<r){
        rr++;
        Avantgarde=(Avantgarde+cg[rr]*(ll-l))%mod;
    }
    Avantgarde=(Avantgarde+cf[ll]*(rr-mid))%mod;
}
```
关于怎么计算 $cg_j$：上一个左指针即 $ll-1$ 的时候最大的右指针 $+1$ 的位置正好是 $cg_{rr}>cf_{ll-1}$ 的位置，那么在这个左指针即 $ll$ 的时候，需要统计区间 $(ll-1)-l+1=ll-l$ 次。所以是 $cg_{rr}\times (ll-l)$，在跳出之后 $rr$ 的位置正好是统计 $cf$ 的位置，再统计即可。


[单调指针练习题](https://www.luogu.com.cn/problem/AT_abc321_d)


### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace Testify{
    inline int read(){
        int f(1),x(0);
        char ch=getchar();
        for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
        for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
        return f*x;
    }
    inline void Write(int x){
        if(x>9) Write(x/10);
        putchar(x%10+48);
    }
    inline void write(int x){
        if(x<0) putchar('-'),x=-x;
        Write(x);
        putchar('\n');
    }
}
using namespace Testify;
int n,m;
const int N=1e5+5;
int a[N],maxn[N],minn[N],sum[N],sumcheng[N];
int Avantgarde=0;
const int mod=1e9+7;
int dp[N][2],f[N][2],g[N][2];
//f是左区间，g是右区间
//f_i,0代表不选择mid左区间最大的和，f_i,1代表选择mid左区间最大的和
//g_i,0代表不选择mid+1右区间最大的和，g_i,1代表选择mid+1右区间最大的和
int cf[N],cg[N];
//作差的数组
inline void fenzhi(int l,int r){
    if(l==r){
		Avantgarde=(Avantgarde+a[l])%mod;
        return ;
    }
    int mid=(l+r)>>1;
    fenzhi(l,mid);
    fenzhi(mid+1,r);
    /*   
        下面是找f[i][0]和g[i][0]の操作，
        即mid不选，那么我们需要初始化保证mid不选。
        dp初始化dp[mid][1]=INT_MIN这样的话mid肯定选不到
        因为这样的话dp[mid-1][0]只能从max(dp[mid][0],dp[mid][1])转移过来，即0。
                                                                            */
    for(register int i=l;i<=r;i++){
        dp[i][0]=dp[i][1]=0;//清空
    }    
    dp[mid][0]=0;
    dp[mid][1]=INT_MIN;
    f[mid][0]=0;
    for(register int i=mid-1;i>=l;i--){
        dp[i][0]=max(dp[i+1][0],dp[i+1][1]);//
        dp[i][1]=dp[i+1][0]+a[i];
        f[i][0]=max(dp[i][0],dp[i][1]);
    }
    dp[mid+1][0]=0;
    dp[mid+1][1]=INT_MIN;
    g[mid+1][0]=0;
    for(register int i=mid+2;i<=r;i++){
        dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
        dp[i][1]=dp[i-1][0]+a[i];
        g[i][0]=max(dp[i][0],dp[i][1]);
    }
    /*   
        下面是找f[i][1]和g[i][1]の操作，
        即mid不选，那么我们需要初始化保证mid选。
        dp初始化dp[mid][0]=INT_MIN,dp[mid][1]=s[mid]
        这样的话mid肯定选得到
                                                                            */
    for(register int i=l;i<=r;i++){
        dp[i][0]=dp[i][1]=0;
    }
    dp[mid][0]=INT_MIN;
    dp[mid][1]=a[mid];
    f[mid][1]=a[mid];
    for(register int i=mid-1;i>=l;i--){
        dp[i][0]=max(dp[i+1][0],dp[i+1][1]);//
        dp[i][1]=dp[i+1][0]+a[i];
        f[i][1]=max(dp[i][0],dp[i][1]);
    }
    dp[mid+1][0]=INT_MIN;
    dp[mid+1][1]=a[mid+1];
    g[mid+1][1]=a[mid+1];
    for(register int i=mid+2;i<=r;i++){
        dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
        dp[i][1]=dp[i-1][0]+a[i];
        g[i][1]=max(dp[i][0],dp[i][1]);
    }
    /*               分界线                    */
    for(register int i=l;i<=mid;i++){
        cf[i]=f[i][1]-f[i][0];
        Avantgarde=(Avantgarde+(f[i][0]*(r-mid))%mod)%mod;
    }
    for(register int i=mid+1;i<=r;i++){
        cg[i]=max(g[i][1]-g[i][0],0ll);
        Avantgarde=(Avantgarde+(g[i][0]*(mid-l+1)))%mod;
    }
    /*                                  */
    stable_sort(cf+l,cf+mid+1);
    stable_sort(cg+mid+1,cg+r+1);

    int rr=mid;
    for(register int ll=l;ll<=mid;ll++){
        while(cg[rr+1]<=cf[ll]&&rr<r){
            rr++;
            Avantgarde=(Avantgarde+cg[rr]*(ll-l))%mod;
        }
        Avantgarde=(Avantgarde+cf[ll]*(rr-mid))%mod;
    }
    for(register int i=rr+1;i<=r;i++){
        Avantgarde=(Avantgarde+cg[i]*(mid-l+1))%mod;
    }
    return ;
}
signed main(void){
    n=read();
    for(register int i=1;i<=n;i++){
        a[i]=read();
    }
    fenzhi(1,n);
    write(Avantgarde);
    return 0;
}
```


---

## 作者：chlchl (赞：4)

看上去好恐怖的题目，求所有区间的最大独立集之和。

考虑分治（~~别问我为什么，因为今天上的专题叫分治、分块与莫队~~）。

假设当前处理的是 $[l,r]$ 的答案。记 $mid=\dfrac{l+r}{2}$。我们的核心思路是每次处理所有包含 $mid$ 的区间，然后递归处理 $[l,mid]$ 和 $[mid+1,r]$ 的区间。

如何处理过 $mid$ 的区间？显然这个区间可以由 $[x,mid]$ 和 $[mid+1,y]$ 这种一个后缀和一个前缀拼接起来。

考虑求出 $\forall x\in[l,mid],f(x,mid)$ 和 $\forall x\in[mid+1,r],f(mid+1,x)$ 的值（记为 $a(x),b(x)$）。这个可以直接线性 DP。

但是两边拼接的时候，如果 $mid$ 位置选了，那么 $mid+1$ 就不能选，这是一个比较棘手的问题，因为我们不知道最大独立集包不包含这两个位置。

所以再求出 $\forall x\in[l,mid-1],f(x,mid-1)$ 和 $\forall x\in[mid+2,r],f(mid+2,x)$ 的值（记为 $c(x),d(x)$）。

那么过 $mid$ 的所有区间的答案显然就是 $\sum \max\{a_l+d_r,b_l+c_r\}$。

这个不好快速求，考虑将其拆开。

取 $b_l+c_r$ 时，一定满足 $a_l+d_r<b_l+c_r$，移项得到 $a_l-b_l<c_r-d_r$，是个二维数点问题。

我们按 $a_l-b_l$ 从小到大排序，这样的话取 $b_l+c_r$ 的区间一定是一个前缀。

所以对于每一个 $r$，显然可以二分出一个临界点，计算贡献的时候预处理 $b_l$ 的前缀和、$a_l$ 的后缀和即可。

感觉不是很难啊，重点在于想到要用分治？

时间复杂度 $O(n\log^2n)$。

小破题细节不少。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 1e5 + 10;
const ll P = 1e9 + 7;
int n;
ll ans, a[N], sf[N], sg[N];

struct xyr{
	ll fl, gl;
	bool operator < (const xyr &Chl){
		return fl - gl < Chl.fl - Chl.gl;
	}
} f[N];

struct chl{
	ll fr, gr;
} f1[N];


void solve(int l, int r){
	if(l == r)
		return (ans += a[l]) %= P, void();
	int mid = (l + r) >> 1;
	solve(l, mid);
	solve(mid + 1, r);
	
	f[mid + 1].fl = 0, f[mid].fl = a[mid];
	f[mid].gl = 0, f[mid - 1].gl = a[mid - 1];
	for(int i=mid-1;i>=l;i--){
		f[i].fl = max(f[i + 1].fl, f[i + 2].fl + a[i]);
		if(i != mid - 1)
			f[i].gl = max(f[i + 1].gl, f[i + 2].gl + a[i]);
	}
	
	f1[mid].fr = 0, f1[mid + 1].fr = a[mid + 1];
	f1[mid + 1].gr = 0, f1[mid + 2].gr = a[mid + 2];
	for(int i=mid+2;i<=r;i++){
		f1[i].fr = max(f1[i - 1].fr, f1[i - 2].fr + a[i]);
		if(i != mid + 2){
			f1[i].gr = max(f1[i - 1].gr, f1[i - 2].gr + a[i]);
			
		}
	}
	sort(f + l, f + mid + 1);
	sf[mid + 1] = sg[l - 1] = 0;
	for(int i=mid;i>=l;i--)
		sf[i] = (sf[i + 1] + f[i].fl);//a 后缀和 
	for(int i=l;i<=mid;i++)
		sg[i] = (sg[i - 1] + f[i].gl);//b 前缀和 
	for(int i=mid+1;i<=r;i++){
		int id = lower_bound(f + l, f + mid + 1, (xyr){f1[i].fr, f1[i].gr}) - f - 1;
		(ans += sf[id + 1] % P + 1ll * f1[i].gr * (mid - id) % P) %= P;
		(ans += sg[id] % P + 1ll * f1[i].fr * (id - l + 1) % P) %= P;
//		cout << sg[id] << ' ' << f1[i].fr << ' ' << id - l + 1 << endl;
	}
}

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%lld", &a[i]);
	solve(1, n);
	printf("%lld\n", ans);
	return 0; 
}
/*
5
2 5 3 2 5

82
*/
```

---

## 作者：Link_Cut_Y (赞：3)

名字很有感觉。题目也很好。我来嘴巴一下。

先来考虑部分分。枚举区间左端点 $l$，不妨设 $f_{i, j}$ 表示以 $l$ 为左端点，右端点为 $i$，选 / 不选第 $i$ 个的最大价值。转移平凡。复杂度 $O(n ^ 2)$。期望得分 $50$。

考虑分治。不妨设当前分治中点为 $mid$，考虑跨过分治中点的所有区间的贡献和。枚举左端点 $l \le mid$，只需要对其计算右端点 $r > mid$ 的贡献和即可。

对两侧分值区间分别 dp。设 $f_{l, 0/1}$ 表示左端点为 $l$，右端点为 $mid$，且 $mid$ 选 / 不选的最大价值。这个和第一档部分分相同，线性于区间长度即可完成。对于右侧同理做一下，设为 $g_{r, 0/1}$。

现在我们有了左半区间的最大权后缀和右半区间的最大权前缀。由于枚举左端点，可以看做左端点固定，设为 $l$。则对于某个右端点 $r$，其对于答案的贡献就是：

$$\max\{f_{l, 0} +g_{r, 0}, f_{l, 1} +g_{r, 0}, f_{l, 0} +g_{r, 1}\}$$

发现这个三项 $\max$ 不美观，考虑变成两项。修改状态，用 $f / g_{i, 1}$ 表示最大权后缀 / 前缀，其中 $mid$ **可选可不选**。这样贡献变成两项：

$$\max\{f_{l, 0} + g_{r, 1}, f_{l, 1} +g_{r, 0}\}$$

前面的处理都是平凡的。本题最具有思考价值的部分在下面。

由于是两项 $\max$，考虑答案取前项的条件，也就是 $f_{l, 0} + g_{r, 1} >  f_{l, 1} +g_{r, 0}$ 的条件。移项充要转化一下，可以得到，取前项的条件为：

$$f_{l, 0} - f_{l, 1} > g_{r, 0} - g_{r, 1}$$

由于 $l$ 为定值，左半部分为定值，设为 $k$。引入 $\Delta_r$ 表示 $g_{r, 0} - g_{r, 1}$。

将 $\Delta_{mid < r}$ 排序，对于每个 $k$，可以二分得到取前项的最靠右的点，剩下的全取后项。

对某个分治区间的处理，复杂度是区间长度的线性对数。故整体复杂度 $O(n \log ^ 2 n)$。

**Bonus：** 一种更简单的做法是将左右区间的 $\Delta$ 分别排序后尺取。

代码写完了会扔到讨论区里。

---

## 作者：rits_m (赞：3)

**题意**：对每个 $a$ 的子区间 $a_{l\dots r}$，求选择若干个不连续的数的和的最大值，求答案的和对 $10^9 + 7$ 取模。

$1 \leq n \leq 10^5$，$0 \leq a_i \leq 10^9$。

**题解**：注意到，给定 $a$，区间查询，我们是可以放到线段树上打 tag 维护的。也就是说，这个答案是可合并的。

所以直接上分治，定义 $\text{Solve}(L, R)$ 表示所有 $L \leq l \leq r \leq R$ 的答案，取一个中点 $mid$，那么 $\text{Solve}(L, R) = \text{Solve}(L, mid) + \text{Solve}(mid + 1, r)$ 再加上所有 $l \in [L, mid], r \in (mid, R]$ 的答案。

更具体地，对于后面的横跨中点的区间 $[l, r]$，我们事实上只需要 **合并 $\bm{[l, mid]}$ 和 $\bm{[mid + 1, r]}$ 一次**。考虑记 $f_l$ 表示强制不选 $mid$ 的 $a_{l\dots mid}$ 的答案，$g_l$ 表示 $a_{l\dots mid}$ 的答案（对 $r$ 同理），那我们要求的就是：

$$\sum_{l=L}^{mid} \sum_{r=mid+1}^R \max(f_l + g_r, f_r + g_l)$$

$\max$ 的两项都是既带 $l$ 又带 $r$，不好做。所以套路性地减一下，化为：

$$\sum_{l=L}^{mid} \sum_{r=mid+1}^R \max(f_l - g_l, f_r - g_r) + \sum_{l=L}^{mid} \sum_{r=mid+1}^R (g_l + g_r)$$

然后这个就可以随便维护。具体地，对左右两边的 $(f - g)$ 排序后，可以双指针找到左边每个数对于 $\max$ 取值为它的统辖范围（右边同理，当然你也可以维护一个后缀和），就可以 $\mathcal O((R - L) \log (R - L))$ 解决前一半；后一半直接线性地算贡献即可。

主定理求得时间复杂度 $\mathcal O(n\log^2 n)$。

**代码**：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

const int MOD = 1000000007;
#define MAXN 100001
int a[MAXN];
long long solve(int l, int r) {
	if (l == r) return a[l];
	int mid = l + r >> 1;
	long long ans = solve(l, mid) + solve(mid + 1, r);
	std::vector<long long> f0(mid - l + 1), g0(mid - l + 1), f1(r - mid), g1(r - mid);
	f0[0] = f1[0] = 0, g0[0] = a[mid], g1[0] = a[mid + 1];
	for (int k = mid - 1, id = 1; k >= l; --k, ++id) {
		f0[id] = std::max(f0[id - 1], a[k] + (id >= 2 ? f0[id - 2] : 0));
		g0[id] = std::max(g0[id - 1], a[k] + (id >= 2 ? g0[id - 2] : 0));
	}
	for (int k = mid + 2, id = 1; k <= r; ++k, ++id) {
		f1[id] = std::max(f1[id - 1], a[k] + (id >= 2 ? f1[id - 2] : 0));
		g1[id] = std::max(g1[id - 1], a[k] + (id >= 2 ? g1[id - 2] : 0));
	}
	std::vector<long long> w0(mid - l + 1), w1(r - mid);
	for (int k = l, id = mid - l; k <= mid; ++k, --id) 
		ans += g0[id] % MOD * (r - mid) % MOD, w0[id] = f0[id] - g0[id];
	for (int k = mid + 1, id = 0; k <= r; ++k, ++id) 
		ans += g1[id] % MOD * (mid - l + 1) % MOD, w1[id] = f1[id] - g1[id];
	ans %= MOD, std::sort(w0.begin(), w0.end()), std::sort(w1.begin(), w1.end());
	std::vector<long long> sum(r - mid + 1, 0);
	for (int i = r - mid - 1; ~i; --i) sum[i] = ((w1[i] + sum[i + 1]) % MOD + MOD) % MOD;
	for (int i = 0, s = -1; i <= mid - l; ++i) {
		while (s + 1 < r - mid && w1[s + 1] <= w0[i]) ++s;
		ans = ((w0[i] % MOD + MOD) % MOD * (s + 1) % MOD + sum[s + 1] + ans) % MOD;
	}
	return ans;
}
int main() {
	int N; scanf("%d", &N);
	for (int i = 1; i <= N; ++i) scanf("%d", a + i);
	return printf("%lld", solve(1, N)), 0;
}
```

---

## 作者：FFFFFAN (赞：3)

## 题意

给定长度为 $n$ 的非负整数序列 $a$，定义 $f(l,r)$ 表示从 $a$ 序列的区间 $[l,r]$ 选择若干不相邻的数的和的最大值。

求 $[\sum^n_{l=1}\limits\sum^n_{r=l}\limits f(l,r)]\mod (10^9+7)$。

## 思路

考虑对于单个区间 $[l,r]$ 如何求 $f(l,r)$，然后发现这是一道很经典的 dp，转移方程为 $dp_i=\max(dp_{i-1},dp_{i-2}+a_i)$，可以得到枚举左端点的 $O(n^2)$ 暴力做法。

题目要求所有子区间的 $f(l,r)$ 之和，这启示我们使用分治，将问题转化为求所有满足 $l\in[L,mid],r\in[mid+1,R]$ 的 $f(l,r)$ 之和。

由于分治，满足条件的所有的子区间 $[l,r]$ 都可以表示为 $[l,mid]\cup[mid+1,r]$，即 $[L,mid]$ 的一段后缀并上 $[mid+1,R]$ 的一段前缀，因此我们只需要 $O(n)$ 地分别从 $mid$ 向左和从 $mid+1$ 向右做 $dp$，就可以合并得到满足条件的任意子区间的 $f(l',r')$。

注意到 $mid$ 和 $mid+1$ 这两个位置最多只能选取其中一个，进行讨论：设 $fl_i$ 表示 $mid$ 可以选也可以不选时的 $f(i,mid)$，$gl_i$ 表示强制 $mid$ 不选时的 $f(i,mid)$；设 $fr_i$ 表示 $mid+1$ 可以选也可以不选时的 $f(mid+1,i)$，$gr_i$ 表示强制 $mid+1$ 不选时的 $f(mid+1,i)$，那么就可以得到 $f(l,r)=\max(fl_l+gr_r,gl_l+fr_r)$。

考虑拆 $\max$，解 $fl_l+gr_r\lt gl_l+fr_r$，移项得 $fl_l-gl_l\lt fr_r-gr_r$，记为 ① 式。因此我们知道，对于所有满足 ① 式的 $l,r$，其对答案做的贡献为 $gl_l+fr_r$；对于所有不满足 ① 式的 $l,r$，其对答案做的贡献为 $fl_l+gr_r$。

据此，我们可以将 $[L,mid]$ 按 $fl_l-gl_l$ 排序，然后对于每一个 $r\in[mid+1,R]$，我们二分找到最大的 $i$ 满足 $fl_i-gl_i\lt fr_r-gr_r$。因此对于所有的 $l\in[L,i]$，区间 $[l,r]$ 都会对答案做 $gl_l+fr_r$ 的贡献；对于所有的 $l\in[i+1,mid]$，区间 $[l,r]$ 都会对答案做 $fl_l+gr_r$ 的贡献。

我们设 $sf_i$ 表示排序后 $fl_i$ 的前缀和，$sg_i$ 表示排序后 $gl_i$ 的前缀和，那么以 $r$ 为右端点，以 $l\in[L,mid]$ 为左端点的所有区间对答案做的贡献的总和应该就是 $(sg[i]+fr_r\times i)+(sf[mid]-sf[i]+gr_r\times(mid-i))$。

时间复杂度 $O(n\log^2n)$，需要注意 $fl,gl,fr,gr$ 不可取模，否则会影响排序，部分变量需要开 `long long`。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#define N 100005
using namespace std;

const int p = 1e9+7;

int n, a[N], tot;
long long ans, fl[N], fr[N], gl[N], gr[N], sf[N], sg[N];

struct Node {
	long long f, g;
	inline bool operator <(const Node &o) const {
		return f-g < o.f-o.g;
	}
} ls[N];

void solve(int l, int r) {
	if(l == r) {
		ans = (ans+a[l])%p;
		return;
	}
	int mid = (l+r)>>1;
	solve(l, mid), solve(mid+1, r);
	fl[mid]=a[mid], fl[mid+1]=gl[mid]=gl[mid+1]=0;
	for(int i=mid-1; i>=l; --i)	fl[i]=max(fl[i+1], fl[i+2]+a[i]), gl[i]=max(gl[i+1], gl[i+2]+a[i]);
	fr[mid+1]=a[mid+1], fr[mid]=gr[mid+1]=gr[mid]=0;
	for(int i=mid+2; i<=r; ++i)	fr[i]=max(fr[i-1], fr[i-2]+a[i]), gr[i]=max(gr[i-1], gr[i-2]+a[i]);
	tot = 0;
	for(int i=l; i<=mid; ++i)	ls[++tot]={fl[i], gl[i]};
	sort(ls+1, ls+1+tot);
	for(int i=1; i<=tot; ++i)	sf[i]=sf[i-1]+ls[i].f, sg[i]=sg[i-1]+ls[i].g;
	for(int i=mid+1; i<=r; ++i) {
		int j = lower_bound(ls+1, ls+1+tot, (Node){fr[i], gr[i]})-ls-1;
		ans = (ans+sg[j]%p+fr[i]%p*j%p)%p;
		ans = (ans+(sf[tot]-sf[j])%p+gr[i]%p*(tot-j)%p)%p;
	}
}

int main() {
	scanf("%d", &n);
	for(int i=1; i<=n; ++i)	scanf("%d", &a[i]);
	solve(1, n);
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：blossom_j (赞：3)

首先 $n^2$ 暴力很好想到。这又是一个区间问题，考虑分治，计算跨过中点 $mid$ 的区间的 $f$ 之和。

可以从区间中点向左写一个 DP，向右写一个 DP。$f_{i,0/1,0/1}$ 表示 DP 到 $i$，第一个 $0/1$ 表示 $mid$ 或 $mid+1$ 是不是被选了，第二个 $0/1$ 表示是不是选择第 $i$ 个元素。

枚举左端点 $l$ 对于所有右端点 $r$ 求和：设 $g_{i,j}=\max\{f_{i,j,0},f_{i,j,1}\}$。
区间 $[l,r]$ 的答案就 $ \max\{g_{l,0}+g_{r,0},g_{l,0}+g_{r,1},g_{l,1}+g_{r,0}\}$  但是这个式子可以写成 $g_{l,0}+ \max\{g_{r,0},g_{r,1}\}$ 和 $g_{l,1}+g_{r,0}$ 找最大值。

如果 $g_{l,0}-g_{l,1} \le g_{r,0}-\max\{g_{r,0},g_{r,1}\}$ 这样就必须选后者。

所以将所有的 $g_{r,0}-\max\{g_{r,0},g_{r,1}\}$ 排序，二分找到分界点用前缀和计算.

这题还是强调一个分离变量的技巧，比较大小的时候把和 $l$ 相关的挪到一侧，和 $r$ 相关的挪到另一侧。

具体就是先扫右侧，排序，求右侧前缀，再扫左侧，扫的过程中二分查找点，然后计算贡献。


粘个代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
const int N=2*1e5+10;
int a[N];
int ans=0;
int f[N][2][2],g[N][2],cf[N],gf[N];
int sum1[N],sum2[N];
struct lhx{
	int data,id;
}d[N];
bool amp(lhx x,lhx y){
	return x.data<y.data;
}
int ask(int x,int ls,int rs){
	int l=ls,r=rs;
	while(l<r){
		int mid=(l+r+1)/2;
		if(d[mid].data<=x) l=mid;
		else r=mid-1;
	}
	return l;
}
void solve(int l,int r){
	if(l==r){
		ans=(ans+a[l])%mod;
		return;
	}
	int anss=ans;
	int mid=(l+r)/2;
	f[mid+1][0][0]=f[mid+1][0][1]=f[mid+1][1][0]=0,f[mid+1][1][1]=a[mid+1];
	g[mid+1][0]=f[mid+1][0][0];
	g[mid+1][1]=f[mid+1][1][1];
	d[mid+1].data=g[mid+1][0]-max(g[mid+1][0],g[mid+1][1]);
	d[mid+1].id=mid+1;
	for(int i=mid+2;i<=r;i++){
		f[i][0][0]=max(f[i-1][0][0],f[i-1][0][1]);
		f[i][1][0]=max(f[i-1][1][0],f[i-1][1][1]);
		f[i][0][1]=f[i-1][0][0]+a[i];
		f[i][1][1]=f[i-1][1][0]+a[i];
		g[i][0]=max(f[i][0][0],f[i][0][1]);
		g[i][1]=max(f[i][1][0],f[i][1][1]);
		d[i].data=g[i][0]-max(g[i][0],g[i][1]);
		d[i].id=i;
	}
	sort(d+mid+1,d+r+1,amp);
	sum1[mid]=sum2[mid]=sum1[r+1]=sum2[r+1]=0;
	for(int i=mid+1;i<=r+1;i++){
		sum1[i]=sum1[i-1]+g[d[i].id][0];
		sum2[i]=sum2[i-1]+max(g[d[i].id][0],g[d[i].id][1]);
	}
	f[mid][0][0]=f[mid][0][1]=f[mid][1][0]=0,f[mid][1][1]=a[mid];
	g[mid][0]=f[mid][0][0];
	g[mid][1]=f[mid][1][1];
	int j=ask(g[mid][0]-g[mid][1],mid,r);
	ans=(ans+g[mid][0]*(j-mid)%mod+sum2[j]+sum1[r]-sum1[j]+g[mid][1]*(r-j)%mod+mod)%mod;
	for(int i=mid-1;i>=l;i--){
		f[i][0][0]=max(f[i+1][0][0],f[i+1][0][1]);
		f[i][1][0]=max(f[i+1][1][0],f[i+1][1][1]);
		f[i][0][1]=f[i+1][0][0]+a[i];
		f[i][1][1]=f[i+1][1][0]+a[i];
		g[i][0]=max(f[i][0][0],f[i][0][1]);
		g[i][1]=max(f[i][1][0],f[i][1][1]);
		int j=ask(g[i][0]-g[i][1],mid,r);
		ans=(ans+g[i][0]*(j-mid)%mod+sum2[j]+sum1[r]-sum1[j]+g[i][1]*(r-j)%mod+mod)%mod;
	}
	solve(l,mid),solve(mid+1,r);
}
signed main(){
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	solve(1,n);
	cout<<ans<<endl;
}
/*
10
850534838 749655434 745817507 991867417 645519349 373697182 427765279 182404140 260664174 366393413

5
1 3 3 2 4
*/
```

---

## 作者：gdf_yhm (赞：2)

[P7482](https://www.luogu.com.cn/problem/P7482)

### 思路

cdq 分治拆成 $[l,mid]$ 到 $(mid,r]$ 的贡献。

对于一个区间计算答案可以用 dp 完成。以 $mid$ 为交界合并左右的 dp 值。设 $f_{i,0/1}$ 表示区间 $[i,mid]$ 或区间 $(mid,i]$，是否选 $mid$ 或 $mid+1$ 的答案。

$$f_{i,0}=\max (f_{i+1,0},f_{i+2,0}+a_i)$$

$$ans(i,j)=\max (f_{i,0}+f_{j,1},f_{i,1}+f_{j,0})$$

记跨过 $mid$ 的贡献为 $w$。

$$w=\sum_{i=l}^{mid}\sum_{j=mid+1}^{r} ans(i,j)$$

记 $g_i=f_{i,1}-f_{i,0}$。

$$w=\sum_{i=l}^{mid}\sum_{j=mid+1}^{r} \max(g_i+f_{i,0}+f_{j,0},g_j+f_{i,0}+f_{j,0})$$

$$w=\sum_{i=l}^{mid}\sum_{j=mid+1}^{r} \max(g_i,g_j)+\sum_{i=l}^{mid}f_{i,0}\times (r-mid)+\sum_{j=mid+1}^r f_{j,0}\times (mid-l+1)$$

后面两个直接做，前面的对于每个 $i$ 拆开 max 计算。

$$\sum_{j=mid+1}^{r} \max(g_i,g_j)=\sum_{j=mid+1}^{r}[g_i\geq g_j]\times g_i+[g_i<g_j]\times g_j$$


对 $(mid,r]$ 的 $g_j$ 排序，二分 $g_i$ 的位置，记录 $g_j$ 的后缀和即可。

其余的递归 $[l,mid]$ 和 $(mid,r]$ 解决。

然后发现一个 sub 都没过。原因是不一定一定要选 $mid$ 和 $mid+1$，将 $f_{i,1}$ 的定义改为区间不考虑任何限制的最大值，强行当作选 $mid$ 位置即可。

### code

```cpp
int n,a[maxn],ans;
int f[maxn][2],g[maxn];
int b[maxn],len,sum[maxn];
void sovle(int l,int r){
	if(l==r){
		(ans+=a[l])%=mod;
		return ;
	}
	int mid=l+r>>1;
	f[mid][0]=0,f[mid][1]=a[mid];
	if(mid-1>=l)f[mid-1][0]=a[mid-1],f[mid-1][1]=max(a[mid-1],a[mid]);
	for(int i=mid-2;i>=l;i--){
		f[i][0]=max(f[i+1][0],f[i+2][0]+a[i]);
		f[i][1]=max(f[i+1][1],f[i+2][1]+a[i]);
	}
	f[mid+1][0]=0,f[mid+1][1]=a[mid+1];
	if(mid+2<=r)f[mid+2][0]=a[mid+2],f[mid+2][1]=max(a[mid+2],a[mid+1]);
	for(int i=mid+3;i<=r;i++){
		f[i][0]=max(f[i-1][0],f[i-2][0]+a[i]);
		f[i][1]=max(f[i-1][1],f[i-2][1]+a[i]);
	}
	int sl=0,sr=0;
	for(int i=l;i<=mid;i++)(sl+=f[i][0])%=mod;
	for(int i=mid+1;i<=r;i++)(sr+=f[i][0])%=mod;
	(ans+=sl*(r-mid)+sr*(mid-l+1))%=mod;
//	cout<<l<<" "<<r<<" "<<ans<<"\n"; 
	for(int i=l;i<=r;i++)g[i]=f[i][1]-f[i][0];
	len=0; 
	for(int i=mid+1;i<=r;i++)b[++len]=g[i];
	sort(b+1,b+len+1);sum[len+1]=0;
	for(int i=len;i>=1;i--)sum[i]=(sum[i+1]+b[i]%mod+mod)%mod;
	for(int i=l;i<=mid;i++){
		int p=upper_bound(b+1,b+len+1,g[i])-b;
		(ans+=(g[i]%mod+mod)*(p-1)+sum[p])%=mod;
//		cout<<i<<" "<<g[i]<<" "<<p<<" "<<sum[p]<<"\n";
	}
	sovle(l,mid),sovle(mid+1,r);
}
```


---

## 作者：dAniel_lele (赞：1)

考虑分治，在每个 $[l,r]$ 区间计算 $L\in[l,mid],R\in(mid,r]$ 的答案。

首先 $[l,mid]$ 的每个后缀和 $(mid,r]$ 的每个前缀的答案是容易计算的。

考虑到 $mid$ 和 $mid+1$ 只能选其一，我们把每个位置选/不选 $mid$ 或 $mid+1$ 的差值排序，然后贪心考虑即可。

总复杂度 $O(n\log^2n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
const int mod=1e9+7;
int a[100005],f[100005][2][2],val[100005][2],ans;
void solve(int l,int r){
	if(l==r){
		(ans+=a[l])%=mod;
		return ;
	}
	vector<pair<int,int>> vc;
	int cntl=mid-l+1,cntr=r-mid;
	for(int i=l;i<=r;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++) f[i][j][k]=-1e18;
	f[mid][0][0]=f[mid][0][1]=f[mid][1][0]=0,f[mid][1][1]=a[mid];
	for(int i=mid-1;i>=l;i--){
		for(int j=0;j<2;j++){
			f[i][j][0]=max(f[i+1][j][0],f[i+1][j][1]);
			f[i][j][1]=f[i+1][j][0]+a[i];
		}
	}
	for(int i=mid;i>=l;i--)
		val[i][0]=max(f[i][0][0],f[i][0][1]),val[i][1]=max(f[i][1][0],f[i][1][1]),(ans+=val[i][0]%mod*cntr)%=mod,vc.push_back(make_pair(val[i][1]-val[i][0],0));
	f[mid+1][0][0]=f[mid+1][0][1]=f[mid+1][1][0]=0,f[mid+1][1][1]=a[mid+1];
	for(int i=mid+2;i<=r;i++){
		for(int j=0;j<2;j++){
			f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
			f[i][j][1]=f[i-1][j][0]+a[i];
		}
	}
	for(int i=mid+1;i<=r;i++)
		val[i][0]=max(f[i][0][0],f[i][0][1]),val[i][1]=max(f[i][1][0],f[i][1][1]),(ans+=val[i][0]%mod*cntl)%=mod,vc.push_back(make_pair(val[i][1]-val[i][0],1));
	sort(vc.begin(),vc.end());
	reverse(vc.begin(),vc.end());
	for(auto v:vc){
		if(v.second==0) (ans+=v.first%mod*cntr)%=mod,cntl--;
		else (ans+=v.first%mod*cntl)%=mod,cntr--;
	}
	solve(l,mid),solve(mid+1,r);
}
signed main(){
	int n; cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	solve(1,n);
	cout<<ans;
	return 0;
}

```

---

## 作者：封禁用户 (赞：1)

# 题解：P7482 不条理狂诗曲

本题解借鉴 blossom_j 大佬思路，~~但这位大佬的题解似乎没放正确代码~~。

## 题意

对于每一个 $a$ 的子区间 $a_{l\dots r}$，求选择若干个不连续的数的和的最大值，对答案取模 $10^{9}+7$。

## 思路

主要算法：分治。

计算跨过中点 $mid$ 的区间的 $f$ 之和。

首先我们可以写一个 DP。$f_{i,0/1,0/1}$ 表示 DP 已到达 $i$ 的位置。第一个 $0/1$ 表示 $mid$ 或 $mid+1$ 是否被选择。第二个 $0/1$ 表示是否选择了第 $i$ 个元素。

枚举 $l$ 对所有的 $r$ 求和：设 $g_{i,j}=\max\{f_{i,j,0},f_{i,j,1}\}$。区间 $\left [ l,r \right ] $ 的答案就是 $\max\{g_{l,0}+\max\{g_{r,0},g_{r,1}\},g_{l,1}+g_{r,0}\}$。

若 $g_{l,0}-g_{l,1}\le g_{r,0}-\max\{g_{r,0},g_{r,1}\}$，则必需选择后者。

将 $g_{r,0}-\max\{g_{r,0},g_{l,1}\}$ 排序，二分寻找分界点。

## 代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1000000007, Maxn = 2 * 1e5 + 10;
int n, a[Maxn], ans = 0, f[Maxn][2][2], g[Maxn][2],sa[Maxn], sb[Maxn];
struct Node {
	int date, ID;
} d[Maxn];

bool  cmp(Node x, Node y) {
	return x.date < y.date;
}

int ask(int x, int l, int r) {
	while (l < r) {
		int mid = (l + r + 1) >> 1;
		if (d[mid].date <= x)l = mid;
		else r = mid - 1;
	}
	return l;
}

void solve(int l, int r) {
	if (l == r) {
		ans = (ans + a[l]) % mod;
		return;
	}

	int mid = (l + r) >> 1;
	f[mid + 1][0][0] = f[mid + 1][0][1] = f[mid + 1][1][0] = 0, f[mid + 1][1][1] = a[mid + 1];

	g[mid + 1][0] = f[mid + 1][0][0];
	g[mid + 1][1] = f[mid + 1][1][1];

	d[mid + 1].ID = mid + 1;
	d[mid + 1].date = g[mid + 1][0] - max(g[mid + 1][0], g[mid + 1][1]);


	for (int i = mid + 2; i <= r; i++) {
		f[i][0][0] = max(f[i - 1][0][0], f[i - 1][0][1]);
		f[i][1][0] = max(f[i - 1][1][0], f[i - 1][1][1]);
		f[i][0][1] = f[i - 1][0][0] + a[i];
		f[i][1][1] = f[i - 1][1][0] + a[i];

		g[i][0] = max(f[i][0][0], f[i][0][1]);
		g[i][1] = max(f[i][1][0], f[i][1][1]);

		d[i].ID = i;
		d[i].date = g[i][0] - max(g[i][0], g[i][1]);
	}


	sort(d + mid + 1, d + r + 1, cmp);

	sa[mid] = sb[mid] = sa[r + 1] = sb[r + 1] = 0;
	for (int i = mid + 1; i <= r + 1; i++) {
		sa[i] = sa[i - 1] + g[d[i].ID][0];
		sb[i] = sb[i - 1] + max(g[d[i].ID][0], g[d[i].ID][1]);
	}

	f[mid][0][0] = f[mid][0][1] = f[mid][1][0] = 0, f[mid][1][1] = a[mid];

	g[mid][0] = f[mid][0][0];
	g[mid][1] = f[mid][1][1];

	int k = ask(g[mid][0] - g[mid][1], mid, r);
	ans = (ans + g[mid][0] * (k - mid) % mod + sb[k] + sa[r] - sa[k] + g[mid][1] * (r - k) % mod + mod) % mod;

	for (int i = mid - 1; i >= l; i--) {
		f[i][0][0] = max(f[i + 1][0][0], f[i + 1][0][1]);
		f[i][1][0] = max(f[i + 1][1][0], f[i + 1][1][1]);
		f[i][0][1] = f[i + 1][0][0] + a[i];
		f[i][1][1] = f[i + 1][1][0] + a[i];

		g[i][0] = max(f[i][0][0], f[i][0][1]);
		g[i][1] = max(f[i][1][0], f[i][1][1]);

		int k = ask(g[i][0] - g[i][1], mid, r);
		ans = (ans + g[i][0] * (k - mid) % mod + sb[k] + sa[r] - sa[k] + g[i][1] * (r - k) % mod + mod) % mod;
	}

	solve(l, mid), solve(mid + 1, r);
}
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++)cin >> a[i];
	solve(1, n);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：0)

分治，考虑在 $[l,r)$ 中，跨过分治中心 $mid$ 的区间求解。

不妨设 $f_{0/1,i}$ 表示 $[l,mid)$ 的 $i$ 后缀，不选/选 $mid-1$ 的最大价值。$g$ 同理定义为 $[mid,r)$ 的前缀不选/选 $mid$ 的最大价值。递推一下即可求得。

那么区间 $[l,r)$ 的最大价值就是 $\max\{f_{0,l}+\max(g_{0,r},g_{1,r}),f_{1,l}+g_{0,r}\}$。

把外层最大值化开，写成一维数点形式即可做到单层 $O(n\log n)$，总复杂度 $O(n\log^2 n)$。

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/159639984)

---

## 作者：happybob (赞：0)

题意：给定 $n$ 个数，定义 $f(l,r)$ 为在区间 $[l,r]$ 选若干个任意两个不相邻的数的和的最大值。求 $\sum \limits_{i=1}^n \sum \limits_{j=i}^n f(i,j)$ 对 $10^9+7$ 取模的结果。

范围：$n \leq 10^5, 0 \leq a_i \leq 10^9$。

考虑如果只需要求 $f(1,n)$，是很朴素的 DP。$f_{i,0/1}$ 表示到 $i$，$i$ 没选或选了的最大值，朴素转移即可。

现在考虑分治，要处理的是跨过中点的贡献。我们考虑区间 $[i,j]$ 对答案的贡献，其中 $i \in [mid,l], j \in (mid,r]$。

考虑到最终选的只有三种：

1. $mid$ 选了，$mid + 1$ 没选。
2. $mid$ 没选，$mid+1$ 选了。
3. $mid$ 没选，$mid+1$ 没选。

于是我们可以在每次分治时求出四个数组 $a_i,b_i,c_i,d_i$，分别表示从 $i \sim mid$，$mid$ 必须选以及必须不选的最大值。从 $mid + 1 \sim i$，$mid+1$ 必须选和不选的最大值。这时可以知道 $[i,j]$ 的贡献为 $\max\{a_i + d_j,b_i+c_j,b_i+d_j\}=\max\{\max\{a_i,b_i\}+d_j,b_i+c_j\}$。

分类讨论，当 $\max\{a_i,b_i\}+d_j \geq b_i+c_j$ 时，移项得 $\max\{a_i,b_i\}-b_i \geq c_j-d_j$。于是对 $c_j-d_j$ 排序之后维护前缀和，对于每个 $i$ 二分即可。复杂度 $O(n \log^2 n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <array>
#include <queue>
using namespace std;

using ll = long long;
constexpr int N = 1e5 + 5;
constexpr ll MOD = 1e9 + 7;

int n;
ll ans = 0LL;
array<int, N> s;

array<ll, N> a, b, c, d;
array<array<ll, 2>, N> dp;

void add(auto& x, auto y)
{
	y %= MOD;
	x += y;
	x %= MOD;
}

struct Node
{
	ll c, d, m, sumc, sumd;
	Node(ll c, ll d, ll m) :c(c), d(d), m(m), sumc(0), sumd(0) {}
	Node() = default;
};

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> s[i];
	auto solve = [&](auto self, int l, int r)
		{
			if (l == r)
			{
				add(ans, s[l]);
				return;
			}
			int mid = l + r >> 1;
			self(self, l, mid);
			self(self, mid + 1, r);
			for (int i = l - 1; i <= mid + 1; i++) a[i] = b[i] = c[i] = d[i] = dp[i][0] = dp[i][1] = 0;
			for (int i = mid; i <= r + 1; i++) a[i] = b[i] = c[i] = d[i] = dp[i][0] = dp[i][1] = 0;
			// solve a: mid 必选
			dp[mid][0] = (ll)-2e18;
			dp[mid][1] = s[mid];
			a[mid] = s[mid];
			for (int i = mid - 1; i >= l; i--)
			{
				dp[i][0] = max(dp[i + 1][0], dp[i + 1][1]);
				dp[i][1] = dp[i + 1][0] + s[i];
				a[i] = max(dp[i][0], dp[i][1]);
			}
 			// solve b: mid 不能选
			for (int i = l - 1; i <= mid + 1; i++) dp[i][0] = dp[i][1] = 0;
			dp[mid][1] = (ll)-2e18;
			b[mid] = 0;
			for (int i = mid - 1; i >= l; i--)
			{
				dp[i][0] = max(dp[i + 1][0], dp[i + 1][1]);
				dp[i][1] = dp[i + 1][0] + s[i];
				b[i] = max(dp[i][0], dp[i][1]);
			}
			// solve c: mid + 1 必选
			for (int i = mid; i <= r + 1; i++) dp[i][0] = dp[i][1] = 0;
			dp[mid + 1][0] = (ll)-2e18;
			c[mid + 1] = s[mid + 1];
			dp[mid + 1][1] = s[mid + 1];
			for (int i = mid + 2; i <= r; i++)
			{
				dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
				dp[i][1] = dp[i - 1][0] + s[i];
				c[i] = max(dp[i][0], dp[i][1]);
			}
			// solve d: mid + 1 不能选
			for (int i = mid; i <= r + 1; i++) dp[i][0] = dp[i][1] = 0;
			dp[mid + 1][1] = (ll)-2e18;
			for (int i = mid + 2; i <= r; i++)
			{
				dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
				dp[i][1] = dp[i - 1][0] + s[i];
				d[i] = max(dp[i][0], dp[i][1]);
			}
			vector<Node> v;
			for (int i = mid + 1; i <= r; i++) v.emplace_back(Node(c[i], d[i], c[i] - d[i]));
			sort(v.begin(), v.end(), [&](const auto& x, const auto& y) {return x.m < y.m; });
			v[0].sumc = v[0].c, v[0].sumd = v[0].d;
			for (int i = 1; i < v.size(); i++) v[i].sumc = v[i - 1].sumc + v[i].c, v[i].sumd = v[i - 1].sumd + v[i].d;
			for (int i = l; i <= mid; i++)
			{
				// sum of max(b_i + c_j, max(a_i, b_i) + d_j) (mid + 1 <= j <= r)
				// 1. max(a_i, b_i) + d_j >= b_i + c_j
				// max(a_i, b_i) - b_i >= c_j - d_j
				ll maxn = max(a[i], b[i]) - b[i];
				auto it = upper_bound(v.begin(), v.end(), Node(0, 0, maxn), [&](const auto& x, const auto& y) {return x.m < y.m; });
				if (it != v.begin())
				{
					--it;
					// a_i + d_j
					ll cnt = it - v.begin() + 1;
					add(ans, cnt * max(a[i], b[i]) % MOD + (*it).sumd);
					++it;
					
				}
				// a_i - b_i < c_j - d_j
				if (it != v.end())
				{
					ll cnt = v.end() - it;
					add(ans, cnt * b[i] % MOD + (v.back()).sumc - (*it).sumc + (*it).c);
				}
			}
		};
	solve(solve, 1, n);
	cout << ans % MOD << "\n";
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：0)

考虑分治，对于当前区间 $[L,R]$，计算 $l\in [L,mid],r\in [mid+1,R]$ 的情况。

这个需要考虑是否选 $mid$ 和 $mid+1$。显然 $mid,mid+1$ 中有且只有一个入选。我们只需要合并左后缀以及右前缀。

考虑令 $rg_i$ 表示选了 $mid+1$，当前位置为 $i$。$rf_i$ 是不选 $mid+1$。$lf_i$ 是选了 $mid$，$lg_i$ 是不选 $mid$ 的。那么一个区间的答案就是 $\max(lf_i+rf_j,lg_i+rg_j)$。但是有 $\max$ 不好处理。

通用的套路是把相同下标的东西整理到一边。考虑决策点 $lf_i+rf_j<lg_i+rg_j$，则有 $lf_i-lg_i<rg_j-rf_j$。原来的柿子是 $\sum_{i,j} \max(lf_i-lg_i,rg_j-rf_j)+lg_i+rf_j$。其中 $i\in [L,mid],j\in [mid+1,R]$。

钦定 $rg_j-rf_j$ 作为最大值。二分出管辖的 $i$ 的位置，用个前缀和就好了。

时间复杂度 $O(n\log^2n)$。

---

## 作者：under_the_time (赞：0)

## 题意

> 给定长度为 $n$ 的非负整数序列 $a$，求
> $$
> \sum^n_{l=1}\sum^n_{r=l}f(l,r)
> $$
> ，其中 $f(l,r)$ 表示从 $a$ 序列的区间 $[l,r]$ 选择若干不相邻的数的和的最大值。结果对 $10^9+7$ 取模。

## 思路

求所有区间的权值和提示我们使用分治。

考虑分治。设当前处理的区间为 $[l,r]$，令 $mid=\lfloor\dfrac{l+r}{2}\rfloor$，我们将子区间分为三种：

- 左右端点都在 $[l,mid]$ 上；
- 左右端点都在 $[mid + 1,r]$ 上；
- 左端点在 $[l,mid]$ 上，右端点在 $[mid + 1,r]$ 上。

前两种子区间可以分治递归求解。对于第三种子区间，我们令 $f0_L$ 表示以 $L$ 开始不取 $mid$ 时 $[L,mid]$ 的最大权值，$f1_L$ 表示以 $L$ 开始取 $mid$ 时 $[L,mid]$ 的最大权值。相对应的，令 $g0_R$ 表示以 $R$ 结束不取 $mid + 1$ 时 $[mid + 1,R]$ 的最大权值，$g1_R$ 表示以 $R$ 结束取 $mid + 1$ 时 $[mid + 1,R]$ 的最大权值。

对于所有 $L$ 和 $R$，我们可以用类似 dp 的方法预处理出 $f0_L,f1_L,g0_R,g1_R$，此时当前区间产生对答案的贡献即为
$$
\sum_{l\le L\le mid}\sum_{mid+1\le R\le r}\max(f0_L+g1_R,f1_L+g0_R)
$$
。考虑 $f0_L+g1_R\ge f1_L+g0_R$ 的情况，移项得 $f0_L-f1_L\ge g0_R-g1_R$。于是我们可以将 $L$ 按 $f0_L - f1_L$ 排序，$R$ 按 $g0_R-g1_R$ 排序，使用双指针计算对应贡献。

另一种情况是对称的，处理方法相似。

时间复杂度 $O(n\log^2n)$。

---

## 作者：Sonnety (赞：0)

在校内打比赛遇到这道题目，当时觉得是唯一可做题目，维护了一个线段树，然后伪了。

然后正解是分治。~~（线段树用到了分治思想，赢）~~

## 暴力

这道题其实暴力分很好拿，就是设计 $f_{i,[0/1]}$ 表示 $i$ 表示第几轮，$0/1$ 表示取或不取：

$$

\begin{aligned}

&f_{i,1}=f_{i-1,0}+a_i\\

&f_{i,0}=\max(f_{i-1,0},f_{i-1,1})

\end{aligned}

$$

然后这个是 $O(n)$ 的，套上枚举的长度和起点就是 $O(n^3)$。

然后稍微转换一下可以变成 $O(n^2)$ 的做法：

```
#include<iostream>
#include<cstdio>
using namespace std;
int n;
#define ll long long
ll a[200010],dp[5][5],ans;
const ll mod=998244353;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    for(int i=1;i<=n;i++){
        int now=0;
        dp[1][0]=dp[1][1]=dp[0][1]=dp[0][0]=0;
        for(int j=i;j<=n;j++){
            now^=1;
            dp[now][1]=dp[now^1][0]+a[j];
            dp[now][0]=max(dp[now^1][1],dp[now^1][0]);
            ans+=max(dp[now][1],dp[now][0]);
            ans%=mod;
        }
    }
    printf("%lld",ans);
    return 0;
}
```

## 正解

然后考虑正解分治，以中点 $mid$ 分界，设：

* $lf_{i,[0/1],[0/1]}$ 表示现在到第 $i$ 轮，第一个 $0/1$ 表示是否选 $mid$，第二个 $0/1$ 表示是否选择第 $i$ 个元素。

* $rf_{i,[0/1],[0/1]}$ 表示现在到第 $i$ 轮，第一个 $0/1$ 表示是否选 $mid+1$，第二个 $0/1$ 表示是否选择第 $i$ 个元素。

为了简单表示，我们这样写：

* $lg_{i,[0/1]}$ 是 $mid$ 向左，$1$ 表示选 $mid$，$0$ 表示不选 $mid$ 的最大值，即 $\max(lf_{i,[0/1],0},lf_{i,[0/1],1})$。

* $rg_{i,[0/1]}$ 是 $mid+1$ 向右，$1$ 表示选 $mid+1$，$0$ 表示不选 $mid+1$ 的最大值，即 $\max(rf_{i,[0/1],0},rf_{i,[0/1],1})$。

对于区间 $[l,r]$，因此就有：

**对于 $lg$ 和 $rg$，第二维的 $[0,1]$ 只可能是 $(0,0)$，$(0,1)$，$(1,0)$，因为 $mid$ 与 $mid+1$ 相邻。**

即：

$$


\sum_{i=l}^{mid}\limits \sum_{j=mid+1}^{r}\limits \max(lg_{i,0}+rg_{j,1},lg_{i,1}+rg_{j,0},lg_{i,0}+rg_{j,0})


$$

**然后我们发现 $\max()$ 这里面三种方案 $(0,0),(0,1),(1,0)$ 都与 $(0,0)$ 存在交集。**

然后对他进行一个优雅的转化：

$$

\begin{aligned}
&\max(lg_{i,0}+rg_{j,1},lg_{i,1}+rg_{j,0},lg_{i,0}+rg_{j,0})=\\

&\max(lg_{i,1}-lg_{i,0},rg_{j,1}-rg_{j,0},0)+lg_{i,0}+rg_{j,0}
\end{aligned}

$$

于是现在我们设 $fl_i=\max(lg_{i,1}-lg_{i,0},0),fr_i=\max(rg_{i,1}-rg_{i,0},0)$，原本的式子就被转化：

要求三个区间 $\max \left\{ lg_{i,0}+rg_{j,1}, lg_{i,1}+rg_{j,0}+lg_{i,1}+rg_{j,0}\right\}$ 的原因是我们只会从三种方案合并两个区间：$mid$ 和 $mid+1$ 都不取，或只取 $mid$ 和 $mid+1$ 其中之一。至于转换到下一行的等式 $\max(0,lg_{i,1}-lg_{i,0},rg_{j,1} - rg_{j,0}) + lg_{i,0} + rg_{j,0}$ 的方式是在原 $\max$ 的式子中的每一项的后面都减上 $lg_{i,0}+rg_{j,0}$ 就行，记得在 $\max$ 外面再加回来。

$$

\sum_{i=l}^{mid}\limits \sum_{j=mid+1}^{r}\limits (\max(fl_i,fr_j)+lg_{i,0}+rg_{j,0})

$$

## 代码实现

如何实现代码？

我们整个递归函数里会递归的深度总共是 $\log(n)$ 层，每一层稳定会将 $n$ 个元素都遍历，所以总复杂度是 $n\log(n)$，与归并排序十分类似。

正确性方面我们每次都都会将小区间一步步扩展到大区间。若我们要处理 $l \sim r$ 区间内的数，这就代表我们已经从递归的下层出来了，此时我们再枚举一遍以 $mid$ 为右端点，$l$ 为最小的左端点的每个区间，右边同理，这时我们可以将右边的区间加上左边的区间，这时我们就会将 $l \sim r$ 的每一个包含 $mid$ 与 $mid + 1$ 的区间处理处理来了。那不包含 $mid$ 与 $mid + 1$ 的区间怎么办呢？因为我们已经从下层递归出来，处理完范围为 $l \sim mid$ 和 $mid + 1 \sim r$ 递归了，所以在 $l \sim mid$ 和 $mid + 1 \sim r$ 内的区间都已经处理完不用管了。

我们发现，对于 $lg_{i,0},rg_{j,0}$ 我们可以像和最开始一样的转移方程 $O(n)$ 求出。

具体来说，我们可以重新设置一个 $dp_{i,[0/1]}$ 表示第 $i$ 轮选或不选这个数，通过给 $dp_{mid}$ 赋极大值和 $a_i$ 来保证 $[0/1]$ 即 $mid$ 位置上选不选的问题，因此 $mid$ 选不选是知道的，因此求 $lg$ 选择倒着枚举，求 $rg$ 正着枚举，于是有代码：

```
  for(register int i=l;i<=r;++i){
	//清空 
		dp[i][0]=dp[i][1]=0;
	}
	
	//处理lg[i][0],[mid][1]是MYMIN不会选 
	dp[mid][0]=0;
	dp[mid][1]=MYMIN;
	lg[mid][0]=0;
	for(register int i=mid-1;i>=l;--i){
		dp[i][0]=max(dp[i+1][0],dp[i+1][1]);
		dp[i][1]=dp[i+1][0]+a[i];
		lg[i][0]=max(dp[i][0],dp[i][1]);
	}
	
	//处理rg[i][0],[mid+1][1]是MYMIN不会选 
	dp[mid+1][0]=0;
	dp[mid+1][1]=MYMIN;
	rg[mid+1][0]=0;
	for(register int i=mid+2;i<=r;++i){
		dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
		dp[i][1]=dp[i-1][0]+a[i];
		rg[i][0]=max(dp[i][0],dp[i][1]);
	}
	
	for(register int i=l;i<=r;++i){
	//清空 
		dp[i][0]=dp[i][1]=0;
	}
	
	//处理lg[i][1],[mid][1]是a[mid]会选 
	dp[mid][0]=MYMIN;
	dp[mid][1]=a[mid];
	lg[mid][1]=a[mid];
	for(int i=mid-1;i>=l;--i){
		dp[i][0]=max(dp[i+1][0],dp[i+1][1]);
		dp[i][1]=dp[i+1][0]+a[i];
		lg[i][1]=max(dp[i][0],dp[i][1]);
	}
	
	//处理rg[i][1],[mid+1][1]是a[mid+1]会选 
	dp[mid+1][0]=MYMIN;
	dp[mid+1][1]=a[mid+1];
	rg[mid+1][1]=a[mid+1];
	for(int i=mid+2;i<=r;++i){
		dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
		dp[i][1]=dp[i-1][0]+a[i];
		rg[i][1]=max(dp[i][0],dp[i][1]);
	} 
```

而对于 $\max(fl_i,fr_j)$，我们可以对 $fl$，$cg$ 排序，然后单调指针扫一遍。

还有一个最重要的就是我们如何把 $O(n^2)$ 的求和改成 $O(n)$。首先，我们可以将上面的内个取 $\max$ 的式子中，在外面的 $lg_{i,0}+rg_{j,0}$ 在我们最终的答案 $ans$ 中先加上。我们先观察式子：

$$\sum^{mid} _ {i=l} \sum ^ {r} _ {j = mid + 1}\max(0,lg_{i,1}-lg_{i,0},rg_{j,1} - rg_{j,0}) + lg_{i,0} + rg_{j,0}$$

我们可以发现对于每个 $lg_{i,0}$ 一共要加 $r-(mid+1)+1$ 次，而对于每个 $rg_{j,0}$，一共要加 $mid - l + 1$次，于是在遍历每个 $lg_{i,0}$，$lg{i_1}$ 求 $fl{i}$ 与 $rg_{j,0}$，$rg{j,1}$ 求 $fr{j}$ 时可以直接在答案 $ans$ 加上。

继续考虑两个 $\sum$ 该怎么优化。我们发现当 $fl_{i}$ 大于 $fr_{j}$ 时我们一定选 $fl_{i}$，那么也许我们能找出所有比 $fl{i}$ 小的数的个数然后将 $fl_{i,0}$ 的值乘上找出来的个数就能求出来 $\max$ 里面为 $fl_{i}$ 的贡献了？对，这就是正解思路。我们将 $fl_{i,0}$ 与 $fr_{j}$ 分别以权值大小按升序排列，维护两个分别在 $fl_{i}$ 和 $fr_{j}$ 上的单指针，然后乘起来就行了。

总时间复杂度 $O(n\log n)$。

```
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define MYMAX 0x3f3f3f3f3f3f3f3f
#define MYMIN -MYMAX
#define solve ewq 
const int maxn=2e5+50,mod=1e9+7;

int ans;
int n,a[maxn];
int dp[maxn][2];
int lg[maxn][2],rg[maxn][2];
int fl[maxn],fr[maxn];

void input(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
	}
}

void solve(int l,int r){
	if(l==r){
		ans=(ans+a[l])%mod;
		return;
	}
	int mid=(l+r)>>1;
	solve(l,mid);
	solve(mid+1,r);
	
	for(register int i=l;i<=r;++i){
	//清空 
		dp[i][0]=dp[i][1]=0;
	}
	
	//处理lg[i][0],[mid][1]是MYMIN不会选 
	dp[mid][0]=0;
	dp[mid][1]=MYMIN;
	lg[mid][0]=0;
	for(register int i=mid-1;i>=l;--i){
		dp[i][0]=max(dp[i+1][0],dp[i+1][1]);
		dp[i][1]=dp[i+1][0]+a[i];
		lg[i][0]=max(dp[i][0],dp[i][1]);
	}
	
	//处理rg[i][0],[mid+1][1]是MYMIN不会选 
	dp[mid+1][0]=0;
	dp[mid+1][1]=MYMIN;
	rg[mid+1][0]=0;
	for(register int i=mid+2;i<=r;++i){
		dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
		dp[i][1]=dp[i-1][0]+a[i];
		rg[i][0]=max(dp[i][0],dp[i][1]);
	}
	
	for(register int i=l;i<=r;++i){
	//清空 
		dp[i][0]=dp[i][1]=0;
	}
	
	//处理lg[i][1],[mid][1]是a[mid]会选 
	dp[mid][0]=MYMIN;
	dp[mid][1]=a[mid];
	lg[mid][1]=a[mid];
	for(register int i=mid-1;i>=l;--i){
		dp[i][0]=max(dp[i+1][0],dp[i+1][1]);
		dp[i][1]=dp[i+1][0]+a[i];
		lg[i][1]=max(dp[i][0],dp[i][1]);
	}
	
	//处理rg[i][1],[mid+1][1]是a[mid+1]会选 
	dp[mid+1][0]=MYMIN;
	dp[mid+1][1]=a[mid+1];
	rg[mid+1][1]=a[mid+1];
	for(register int i=mid+2;i<=r;++i){
		dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
		dp[i][1]=dp[i-1][0]+a[i];
		rg[i][1]=max(dp[i][0],dp[i][1]);
	}
	
//	for(int i=1;i<=n;++i){
//		printf("%lld lg1= %lld lg2= %lld\n",i,lg[i][1],lg[i][2]);
//		printf("%lld rg1= %lld rg2= %lld\n",i,rg[i][1],rg[i][2]); 
//	}
	
	//处理fl,fr 
	for(register int i=l;i<=mid;++i){
		fl[i]=max(lg[i][1]-lg[i][0],(long long)0);
		ans=(ans+lg[i][0]*(r-mid))%mod;
	}
	for(register int i=mid+1;i<=r;++i){
		fr[i]=max(rg[i][1]-rg[i][0],(long long)0);
		ans=(ans+rg[i][0]*(mid-l+1))%mod;
	}
	sort(fl+l,fl+mid+1);
	sort(fr+mid+1,fr+r+1); 
	
//	for(int i=1;i<=n;++i){
//		printf("%lld fr= %lld\n",i,fr[i]);
//		printf("%lld fl= %lld\n",i,fl[i]); 
//	}
	
	int sl=l,sr=mid;
	while(sl<=mid){
    //在sl++之前我们的fr[sr+1]是大于fl[sl]
    //当sl++后若进入了本个循环就意味着fr[sr+1]小于等于fl[sl]了
    //f[sl]大于fr[sr+1],不能算上sl,fr[sl-1]时是小于fr[sr+1]的最大值,所以fl[i]小于fr[sr+1]的下标i一共有sl-1-l+1个
		while(fr[sr+1]<=fl[sl] && sr<r)	<% ++sr;ans=(ans+fr[sr]*(sl-l))%mod; %> 
		ans=(ans+fl[sl]*(sr-mid))%mod;
		++sl;
	}
	while(sr<r)	<% ++sr;ans=(ans+fr[sr]*(mid-l+1))%mod; %>
//	cout<<"###"<<l<<' '<<r<<' '<<ans<<endl;
	return;
}

signed main(){
//	freopen("in.txt","r",stdin);
//	freopen("mine.txt","w",stdout);
	input();
	solve(1,n);
	printf("%lld",ans); 
	return 0;
}

```


---


# 三到六

## 题目背景

「听说 JOJO 6 要来力！」  
「好时代，来临力！」  
「可是那个无敌的男人……」  
「啊……在吃刀子之前，让我重温一下『欧拉欧拉』……」

## 题目描述

给定整数 $n,k$ 和一个 $n$ 阶排列 $\pi'$，问多少个排列 $\pi$ 满足恰有 $k$ 个位置 $i$ 满足 $1 \le i \le n$ 且 $\pi_i < \pi_{\pi'_i}$。答案对 $998244353$ 取模。

## 说明/提示

**样例解释**

对于第一组样例，$\pi_i$ 不可能小于 $\pi_i$，故必然满足条件，则答案为 $5! = 120$。 

对于第二组样例，有以下 $5$ 种 $\pi$ 满足条件：

 1. $12345$；
 1. $23451$；
 1. $34512$；
 1. $45123$；
 1. $51234$。

对于第三组样例，不予解释。

**数据范围**

对于 $20\%$ 的数据，$n \le 10$。

对于 $40\%$ 的数据，$n \le 3 \times 10^2$。

对于 $60\%$ 的数据，$n \le 10^3$。

对于另外 $20\%$ 的数据，保证 $\pi'_i = i \bmod n + 1$（$1 \le i \le n$）。

对于 $100\%$ 的数据，$1 \le n \le 2 \times 10^5$，$0 \le k \le n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
120```

## 样例 #2

### 输入

```
5 1
2 3 4 5 1```

### 输出

```
5```

## 样例 #3

### 输入

```
5 2
2 4 5 1 3```

### 输出

```
60```

# 题解

## 作者：Provicy (赞：9)

$\text{Problem}:$[三到六](https://www.luogu.com.cn/problem/P7511)

$\text{Solution}:$

观察不等式 $π_{i}<π_{π_{i}'}<π_{π_{π_{i}'}'}<...$，由于 $π'$ 是一个排列，所以最后不等关系一定构成了若干个有向环。可以发现，钦定环上一条边不满足条件，并断掉这条边使破环成链，就构成了一个长度为 $m$ 的序列。问题转化为：有若干个环，每个环对应一个序列，在这个序列中有 $b_{i}$ 个位置满足 $π_{i}<π_{i+1}$，且 $\sum b_{i}=k$。求满足条件的总排列个数。

先考虑单个长度为 $m$ 的环对答案贡献了 $j$ 个 $π_{i}<π_{π_{i}'}$ 的方案数：钦定一个位置 $i$，满足 $π_{i}=1$，令 $i$ 这个位置为断点，就是在长度为 $m-1$ 的序列中有 $j-1$ 个位置满足 $π_{i}<π_{i+1}$。而 $π_{i}=1$ 的位置有 $m$ 种不同的选择。把所有环的贡献相乘就是答案，得到：
$$
\binom{n}{a_{1},a_{2}...a_{m}}\sum\limits_{\sum b_{i}=k}\prod\limits_{i} a_{i}\left<a_{i}-1\atop b_{i}-1\right>,\sum\limits_{i=1}^{m}a_{i}=n
$$
发现 $\sum\limits_{b_{i}=k}$ 是一个背包形式，$dp$ 求欧拉数然后暴力背包就可以做到 $O(n^2)$。注意我们给出的定义，需要对 $a_{i}=1$ 的情况特判。下面给出一个 $O(n^2)$ 的代码，可以得到 $60$ 分：

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(3)
//#define int long long
#define ri register
#define mk make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define is insert
#define es erase
#define vi vector<int>
#define vpi vector<pair<int,int>>
using namespace std; const int N=2010, Mod=998244353;
inline int read()
{
	int s=0, w=1; ri char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48), ch=getchar();
	return s*w;
}
int n,K,p[N],book[N],T[N][N],fac[N+5],inv[N+5],ans,a[N],m,F[N][N];
inline int ksc(int x,int p) { int res=1; for(;p;p>>=1, x=1ll*x*x%Mod) if(p&1) res=1ll*res*x%Mod; return res; }
signed main()
{
	fac[0]=1;
	for(ri int i=1;i<=N;i++) fac[i]=1ll*fac[i-1]*i%Mod;
	inv[N]=ksc(fac[N],Mod-2);
	for(ri int i=N;i;i--) inv[i-1]=1ll*inv[i]*i%Mod;
	n=read(), K=read();
	for(ri int i=1;i<=n;i++) p[i]=read();
	T[0][0]=1;
	for(ri int i=1;i<=n;i++)
	{
		T[i][0]=1;
		for(ri int j=1;j<i;j++)
			T[i][j]=(1ll*(j+1)*T[i-1][j]%Mod+1ll*(i-j)*T[i-1][j-1]%Mod)%Mod;
	}
	ans=fac[n];
	for(ri int i=1;i<=n;i++)
	{
		if(book[i]) continue;
		int x=i,len=0;
		while(!book[x])
		{
			book[x]=1;
			len++;
			x=p[x];
		}
		ans=1ll*ans*inv[len]%Mod;
		a[++m]=len;
	}
	F[0][0]=1;
	for(ri int i=1;i<=m;i++)
	{
		if(a[i]==1)
		{
			for(ri int j=0;j<=K;j++) F[i][j]=F[i-1][j];
			continue;
		}
		for(ri int j=1;j<a[i];j++)
		{
			for(ri int k=0;k+j<=K;k++)
			{
				F[i][j+k]=(F[i][j+k]+1ll*F[i-1][k]*a[i]%Mod*T[a[i]-1][j-1]%Mod)%Mod;
			}
		}
	}
	printf("%d\n",1ll*F[m][K]*ans%Mod);
	return 0;
}
```

参考 [Karry5307 的日报](https://www.luogu.com.cn/blog/Karry5307/eulerian-numbers)，有：
$$
\left<n\atop m\right>=\sum\limits_{k=0}^{m}\binom{n+1}{k}(m+1-k)^{n}(-1)^{k}
$$
设 $g_{i}=\binom{n+1}{i}(-1)^{i}$，$h_{i}=(i+1)^{n}$，有：
$$
\left<n\atop i\right>=f_{i}=\sum\limits_{j=0}^{i}g_{j}h_{i-j}
$$
可以利用卷积做到在 $O(n\log n)$ 的时间内求出一行的欧拉数。

现在记 $F_{i}$ 表示已经选了 $i$ 个小于号的方案数，枚举到第 $i$ 个环时 $G_{j}=a_{i}\times \left<a_{i}-1\atop j-1\right>$，那么有：
$$
F_{i}=\sum\limits_{j=0}^{i}F_{j}\times G_{i-j}
$$
利用分治 $\text{NTT}$ 即可解决。

$\text{Code}:$

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(3)
//#define int long long
#define ri register
#define mk make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define is insert
#define es erase
#define vi vector<int>
#define vpi vector<pair<int,int>>
using namespace std; const int N=550000, Mod=998244353;
inline int read()
{
	int s=0, w=1; ri char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48), ch=getchar();
	return s*w;
}
int n,K,p[N],a[N],book[N],m,ans;
int fac[N+5],inv[N+5];
inline int ksc(int x,int p) { int res=1; for(;p;p>>=1, x=1ll*x*x%Mod) if(p&1) res=1ll*res*x%Mod; return res; }
inline int C(int x,int y) { if(x<y||x<0||y<0) return 0; return 1ll*fac[x]*inv[x-y]%Mod*inv[y]%Mod; }
vector<int> F;
vector<int> A,B;
int rev[N],r[24][2];
inline void Init()
{
	fac[0]=1;
	for(ri int i=1;i<=N;i++) fac[i]=1ll*fac[i-1]*i%Mod;
	inv[N]=ksc(fac[N],Mod-2);
	for(ri int i=N;i;i--) inv[i-1]=1ll*inv[i]*i%Mod;
	r[23][1]=ksc(3,119), r[23][0]=ksc(332748118,119);
	for(ri int i=22;~i;i--) r[i][0]=1ll*r[i+1][0]*r[i+1][0]%Mod, r[i][1]=1ll*r[i+1][1]*r[i+1][1]%Mod;
}
inline void Get_Rev(int T) { for(ri int i=0;i<T;i++) rev[i]=(rev[i>>1]>>1)|((i&1)?(T>>1):0); }
inline void DFT(vector<int> &s,int T,int type)
{
	for(ri int i=0;i<T;i++) if(i<rev[i]) swap(s[i],s[rev[i]]);
	for(ri int i=2,cnt=1;i<=T;i<<=1,cnt++)
	{
		int wn=r[cnt][type];
		for(ri int j=0,mid=(i>>1);j<T;j+=i)
		{
			for(ri int k=0,w=1;k<mid;k++,w=1ll*w*wn%Mod)
			{
				int x=s[j+k], y=1ll*w*s[j+mid+k]%Mod;
				s[j+k]=(x+y)%Mod;
				s[j+mid+k]=x-y;
				if(s[j+mid+k]<0) s[j+mid+k]+=Mod;
			}
		}
	}
	if(!type) for(ri int i=0,inv=ksc(T,Mod-2);i<T;i++) s[i]=1ll*s[i]*inv%Mod;
}
inline void NTT(int n,int m,vector<int> &A,vector<int> &B)
{
	int len=n+m;
	int T=1;
	while(T<=len) T<<=1;
	Get_Rev(T);
	A.resize(T), B.resize(T);
	for(ri int i=n+1;i<T;i++) A[i]=0;
	for(ri int i=m+1;i<T;i++) B[i]=0;
	DFT(A,T,1), DFT(B,T,1);
	for(ri int i=0;i<T;i++) A[i]=1ll*A[i]*B[i]%Mod;
	DFT(A,T,0);
	for(ri int i=n+m+1;i<T;i++) A[i]=0;
	A.erase(A.begin()+n+m+1,A.end());
	B.erase(B.begin()+m+1,B.end());
}
void Merge(int l,int r,vector<int> &F)
{
	if(l==r)
	{
		F.resize(a[l]+1), B.resize(a[l]+1);
		for(ri int i=0;i<=a[l];i++)
		{
			int tp=(i&1)?(-1):(1);
			int w1=(C(a[l],i)*tp+Mod)%Mod, w2=ksc(i,a[l]-1);
			F[i]=w1, B[i]=w2;
		}
		NTT(F.size()-1,B.size()-1,F,B);
		for(ri int i=0;i<=a[l];i++) F[i]=1ll*F[i]*a[l]%Mod;
		F.erase(F.begin()+a[l]+1,F.end());
		B.erase(B.begin(),B.end());
		return;
	}
	int mid=(l+r)/2;
	Merge(l,mid,F);
	vector<int> G;
	Merge(mid+1,r,G);
	NTT(F.size()-1,G.size()-1,F,G);
}
signed main()
{
	Init();
	n=read(), K=read();
	for(ri int i=1;i<=n;i++) p[i]=read();
	ans=fac[n];
	for(ri int i=1;i<=n;i++)
	{
		if(book[i]) continue;
		int x=i,len=0;
		while(!book[x])
		{
			book[x]=1;
			x=p[x], len++;
		}
		ans=1ll*ans*inv[len]%Mod;
		a[++m]=len;
	}
	Merge(1,m,F);
	printf("%d\n",1ll*F[K]*ans%Mod);
	return 0;
}
```



---

## 作者：analysis (赞：0)

[题目](https://www.luogu.com.cn/problem/P7511)

---

观察题目的限制 $\pi_i < \pi_{\pi'_i}$，显然下标 $i$ 的变换就是在置换环上走。

显然，置换环之间是独立的，置换环内只关注相对大小。

于是可以假设对于一个大小为 $n$ 的置换环 $C$，恰有 $k$ 个位置满足限制的方案数为 $F_{n}(k)$。

假设 $\pi'$ 中的置换环集合为 $C=\{c_1,c_2,\cdots,c_m\}$，则答案即为 $\binom{n}{|c_1|,|c_2|,\cdots,|c_m|}\sum_{\sum b_i = k}\prod F_{|c_i|}(b_i)$。

考虑 $F_n(k)$ 是什么。显然，环最小值的前驱一定不满足条件，我们可以在此处断环为链，则 $F_n(k)$ 就是这个序列的上升段恰为 $k$ 的方案数。由于环最小值一定满足条件，所以考虑下最小值所在的位置就得到：
$$
F_{n}(k)=n\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle
$$
所以答案就是：
$$
\binom{n}{|c_1|,|c_2|,\cdots,|c_m|}\sum_{\sum b_i = k}\prod |c_i|\left\langle\begin{matrix}|c_i|-1\\b_i-1\end{matrix}\right\rangle
$$
然后剩下的就是如何求这个式子的值了。

---

暴力求欧拉数可以做到 $O(n^2+nk^2)$。估计有 `40pts`。

---

考虑优化，显然不同大小的置换环至多 $O(\sqrt{n})$ 种，用 $O(n\log{n})$ 求一行欧拉数就可以做到预处理部分 $O(n\sqrt{n}\log{n})$。

然后直接暴力做多项式乘算 $\sum_{\sum b_i = k}\prod |c_i|\left\langle\begin{matrix}|c_i|-1\\b_i-1\end{matrix}\right\rangle$，就可以做到 $O(n\sqrt{n}\log{n}+n^2\log{n})$。

看起来非常不优秀，但是我们可以适当剪枝来使得这个做法变得优秀一点。

- 将 NTT 的 SZ 固定，那么做完 DFT 后可以在全部的乘法做完之后再做 IDFT。
- 同类置换环的多项式是相同的，可以做完 DFT 后直接使用快速幂完成多个同类置换环的乘法。

第一点只是常数优化，使得一部分乘法的时间降到 $O(n)$，第二点使得理论复杂度降低至 $O(n\sqrt{n}\log{n})$。

看起来时间复杂度非常的不对，但是数据太水放过去了……

代码在[这](https://www.luogu.com.cn/paste/2rgaj8fs)，跑了 `3.86s`。

很容易就能 Hack 掉，让每种环出现次数少一点，种类多一点即可。

生成器在[这](https://www.luogu.com.cn/paste/p4jtqx7k)，本地跑了 `2.5min`。

---

考虑套个分治 NTT 优化这个乘法过程，丢掉第一个剪枝，第二个可以保留，时间复杂度是 $T(n)=2T(\frac{n}{2})+O(n\log{n})=O(n\log^2{n})$，应该会小一点，可以通过。

代码在[这](https://www.luogu.com.cn/paste/gxfz4le2)，只跑了 `700ms`，好像是最优解（完隐看不到）。

---


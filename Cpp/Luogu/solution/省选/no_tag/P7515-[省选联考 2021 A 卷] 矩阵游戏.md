# [省选联考 2021 A 卷] 矩阵游戏

## 题目描述

Alice 有一个 $n \times m$ 的矩阵 $a_{i, j}$（$1 \le i \le n$，$1 \le j \le m$），其每个元素为大小不超过 ${10}^6$ 的非负整数。

Bob 根据该矩阵生成了一个 $(n - 1) \times (m - 1)$ 的矩阵 $b_{i, j}$（$1 \le i \le n - 1$，$1 \le j \le m - 1$），每个元素的生成公式为

$$ b_{i, j} = a_{i, j} + a_{i, j + 1} + a_{i + 1, j} + a_{i + 1, j + 1} $$

现在 Alice 忘记了矩阵 $a_{i, j}$，请你根据 Bob 给出的矩阵 $b_{i, j}$ 还原出 $a_{i, j}$。

## 说明/提示

**【数据范围】**

对于所有测试数据：$1 \le T \le 10$，$2 \le n, m \le 300$，$0 \le b_{i, j} \le 4 \times {10}^6$。

每个测试点的具体限制见下表：

| 测试点编号 | $n, m \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $3$ | 无 |
| $5 \sim 7$ | $10$ | $m = 2$ |
| $8 \sim 10$ | $100$ | $m = 2$ |
| $11 \sim 15$ | $300$ | $0 \le b_{i, j} \le 1$ |
| $16 \sim 20$ | $300$ | 无 |

## 样例 #1

### 输入

```
3
3 3
28 25
24 25
3 3
15 14
14 12
3 3
0 3000005
0 0
```

### 输出

```
YES
7 8 8
8 5 4
4 7 9
YES
4 2 2
5 4 6
5 0 2
NO
```

# 题解

## 作者：Acetyl (赞：59)

首先，这题的 $0 \le a_{i, j} \le 10^6$ 这个限制比较恶心，所以先不考虑这个限制，只需要找到一组合法的 $a$ 即可。这样问题就很简单了：钦定 $a$ 的最下面一行和最右边一列是 $0$，然后按照 $b$ 的限制从右下到左上一个个推即可。这部分时间复杂度可以做到 $\mathcal O(nm)$。

下面考虑调整这个 $a$ 矩阵的值，使得其对应的 $b$ 矩阵不变，但是每个 $a_{i, j}$ 的大小都在 $[0, 10^6]$ 之间。我们发现，对于一个 $x$，如果对一行的所有数字依次进行 $+x,-x,+x,-x,\dots$ 的操作，那么对应的 $b$ 矩阵不会发生变化，对于一列同理。下面就设 $r_i$ 为在第 $i$ 行上操作的 $x$ 值，设 $c_i$ 为在第 $i$ 列上操作的 $x$ 值。

现在，对于每个格子 $(i, j)$ 的值的限制，我们就可以将其转化为 $r_i$ 与 $c_i$ 的和或者差的限制。设 $A_{i, j}$ 表示 $(i, j)$ 格子增加的值，则 $A$ 矩阵如下：

$$
\left(
\begin{matrix}
r_1+c_1 & -r_1+c_2 & r_1+c_3 & \cdots\\
r_2-c_1 & -r_2-c_2 & r_2-c_3 & \cdots\\
r_3+c_1 & -r_3+c_2 & r_3+c_3 & \cdots\\
\vdots & \vdots & \vdots & \ddots
\end{matrix}
\right)
$$

对于一个位置 $a_{i, j}$，$A_{i, j}$ 必须满足 $-a_{i, j} \le A_{i, j} \le 10^6 - a_{i, j}$。

但是目前矩阵中值的形式很不统一，既有 $x+y$ 的形式也有 $x-y$ 的形式。考虑对于所有偶数的 $i$，将 $r_i$ 取相反数，对于所有奇数的 $j$，将 $c_j$ 取相反数，则 $A$ 矩阵就变成：

$$
\left(
\begin{matrix}
r_1-c_1 & c_2-r_1 & r_1-c_3 & \cdots\\
c_1-r_2 & r_2-c_2 & c_3-r_2 & \cdots\\
r_3-c_1 & c_2-r_3 & r_3-c_3 & \cdots\\
\vdots & \vdots & \vdots & \ddots
\end{matrix}
\right)
$$

这样矩阵中所有的值都变成 $x-y$ 的形式了，于是 $-a_{i, j} \le A_{i, j} \le 10^6 - a_{i, j}$ 就可以转化为 $-a_{i, j} \le x-y \le 10^6 - a_{i, j}$ 的形式，就变成了一个差分约束问题。

这个差分约束模型中共有 $n+m$ 个变量，有 $2nm$ 个约束，进行 SPFA 最短路的时间复杂度为 $\mathcal O(nm(n+m))$。但是，众所周知，SPFA 的复杂度永远是卡不满的（即使图中存在负环，即无解的情况，也只是部分点被松弛 $n + m$ 次），所以可以通过。

附上考场上写的代码：

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define all(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#define loop(i, a) for (int i = 0; i < (a); ++i)
#define cont(i, a) for (int i = 1; i <= (a); ++i)
#define circ(i, a, b) for (int i = (a); i <= (b); ++i)
#define range(i, a, b, c) for (int i = (a); (c) > 0 ? (i <= (b)) : (i >= (b)); i += (c))
#define pub push_back
#define pob pop_back
#define mak make_pair
#define mkt make_tuple
typedef long long ll;
typedef long double lf;
const int Inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3fll;

int T;
int n, m;
int a[305][305], b[305][305];
vector<pair<int, int> > egs[605];
bool inq[605];
int tms[605];
ll dis[605];

void solve() {
	scanf("%d%d", &n, &m);
	cont(i, n - 1) cont(j, m - 1) scanf("%d", a[i] + j);
	memset(b, 0, sizeof(b));
	range(i, n, 1, -1) range(j, m, 1, -1) b[i][j] = a[i][j] - b[i + 1][j] - b[i + 1][j + 1] - b[i][j + 1];
	cont(i, n + m) egs[i].clear();
	cont(i, n) cont(j, m) {
		int mx = 1000000 - b[i][j], mn = -b[i][j];
		if (!((i + j) & 1)) egs[j + n].pub(mak(i, mx)), egs[i].pub(mak(j + n, -mn));
		else egs[j + n].pub(mak(i, -mn)), egs[i].pub(mak(j + n, mx));
	}
	deque<int> q;
	memset(inq, 0, sizeof(inq));
	memset(tms, 0, sizeof(tms));
	memset(dis, Inf, sizeof(dis));
	dis[1] = 0;
	q.pub(1);
	while (SZ(q)) {
		int now = q.front(); q.pop_front();
		++tms[now]; inq[now] = 0;
		if (tms[now] > n + m) {
			puts("NO");
			return;
		}
		loop(i, SZ(egs[now])) {
			int to = egs[now][i].first, siz = egs[now][i].second;
			if (dis[to] > dis[now] + siz) {
				dis[to] = dis[now] + siz;
				if (!inq[to]) {
					if (SZ(q) && dis[to] < dis[q[0]]) q.push_front(to);
					else q.pub(to);
					inq[to] = 1;
				}
			}
		}
	}
	cont(i, n) cont(j, m) {
		if ((i + j) & 1) b[i][j] -= dis[i];
		else b[i][j] += dis[i];
		if ((i + j) & 1) b[i][j] += dis[j + n];
		else b[i][j] -= dis[j + n];
	}
	puts("YES");
	cont(i, n) cont(j, m) printf("%d%c", b[i][j], " \n"[j == m]);
}

int main() {
	freopen("matrix.in", "r", stdin);
	freopen("matrix.out", "w", stdout);
	scanf("%d", &T);
	while (T--) solve();
	return 0;
}
```

---

## 作者：MoonPie (赞：51)

### 题意

有一个 $n\times m$ 的矩阵 $A$，给出一个 $(n-1)\times(m-1)$ 矩阵 $B$，满足：
$$
b_{i,j} = a_{i,j}+a_{i+1,j}+a_{i,j+1}+a_{i+1,j+1}
$$
问你是否存在 $A$ 满足所有的 $0\le a_{i,j} \le 10^6$。

### 题解

首先，可以很容易地构造出一个只满足 $b_{i,j}$ 限制的 $A$。然后，考虑如何修改可以让 $A$ 在满足 $b$ 的条件的同时满足范围条件。
我们发现如果只给 $A$ 矩阵的一行或一列进行 $+1,-1,+1,-1,\dots$ 的操作后，每一个田字格的和仍保持不变。

所以，我们根据每个 $a_{i.j}$ 的范围限制可以列出不等式：
$$
0\le a_{i,j}\pm c_i\pm d_j\le10^6
$$
然而这并不仅有我们熟知的 **差分约束** ，还有 “和分约束”，怎么办呢？
$$
\text{行}
\begin{bmatrix}
+  & - & + & -\\
+  & - & + & -\\
+  & - & + & -\\
+  & - & + & -\\
\end{bmatrix}
$$


$$
\text{列}
\begin{bmatrix}
+  & + & + & +\\
-  & - & - & -\\
+  & + & + & +\\
-  & - & - & -\\
\end{bmatrix}
$$

之所以会出现和，是因为有些地方行列的**符号相同**。解决方案就是：
$$
\text{行}
\begin{bmatrix}
+  & - & + & -\\
-  & + & - & +\\
+  & - & + & -\\
-  & + & - & +\\
\end{bmatrix}
$$
$$
\text{列}
\begin{bmatrix}
-  & + & - & +\\
+  & - & + & -\\
-  & + & - & +\\
+  & - & + & -\\
\end{bmatrix}
$$
类似两种不同的黑白格染色，就使得每个位置的符号都不相同了，也就转化成了差分约束。

#### 实现细节

由于我们建的图是一张完全图，边数多，$\mathrm{SPFA}$ 的实现有队列，寻址不连续，比较卡常。
不如直接用 $\mathrm{Bellman-Ford}$ 常数小。

#### 一个问题

还有一个疑问，也是大部分题解中没有说明的一点，就是：
是否只要有**这两个操作**就可以让矩阵 $A$ 达到**所有可以达到（且合法）的状态**吗？答案是肯定的。

证明如下：

引理：如果一个 $A$ 矩阵确定了第一行和第一列的全部元素，那么这个矩阵是确定的。
证明：原有 $(n-1)\times(m-1)$ 个方程，后来再加 $n+m-1$ 个方程总共就是 $n\times m$ 个方程恰好可以解出 $A$ 矩阵中的 $n\times m$ 个元素。

我们的两种修改操作由于每次修改一行或一列，如果先改第一行再改第一列，就显然可以把 $A$ 矩阵的第一行和第一列修改为我们想要的任意状态，所以根据引理，原命题得证。

### 代码

```cpp
#define ll long long
const ll inf = 1e18;
const int N = 305, MX = 1000000;
int n,m;
ll a[N][N],b[N][N];

int id(int x,int y) { return (x-1)*n+y; }

namespace diff {
	struct edge {int to,w; };
	ll c[N*2],g[N*2][N*2];

	void init() {
  	for(int i = 0; i <= n+m; ++i) {
  		for(int j = 0; j <= n+m; ++j) {
  			diff::g[i][j] = inf;
  		}
  	}
	}
	void adde(int u,int v,int w) { g[u][v] = w; }
	bool run() {
		memset(c,0x3f,sizeof(c));
		c[0] = 0;
		for(int i = 1; i <= n+m; ++i) g[0][i] = 0;
		int ti,l,r;
		for(ti = 1; ti <= n+m+1; ++ti) {
			int rel = 0;
			for(int u = 0; u <= n+m; ++u) {
				if(u == 0) l = 1, r = n+m;
				else if(u <= n) l = n+1, r = n+m;
				else l = 1, r = n;
				for(int v = l; v<= r; ++v) {
					rel |= umin(c[v], c[u]+g[u][v]);
				}
			}
			if(!rel) break;
		}
		return ti < n+m+1;
	}
	void output() {
		puts("YES");
		for(int i = 1; i <= n; ++i) {
			for(int j = 1; j <= m; ++j) {
				if((i+j)&1) a[i][j] = a[i][j] + c[i] - c[n+j];
				else a[i][j] = a[i][j] - c[i] + c[n+j];
				printf("%lld ",a[i][j]);
			}
			puts("");
		}
	}
}

signed main()
{
  int T; read(T);
  for(int cs = 1; cs <= T; ++cs) {

  	read(n); read(m);
  	diff::init();
  	for(int i = 1; i < n; ++i) for(int j = 1; j < m; ++j) read(b[i][j]);
  	for(int i = 1; i <= n; ++i) {
  		for(int j = 1; j <= m; ++j) a[i][j] = 0;
  	}

  	for(int i = 2; i <= n; ++i) {
  		for(int j = 2; j<= m; ++j) {
  			a[i][j] = b[i-1][j-1] - a[i-1][j] - a[i][j-1] - a[i-1][j-1];
  		}
  	}

  	for(int i = 1; i <= n; ++i) {
  		for(int j = 1; j <= m; ++j) {
  			if((i+j)&1) {
	  			diff::adde(i,j+n,a[i][j]);
  				diff::adde(j+n,i,MX-a[i][j]);
  			}
  			else {
	  			diff::adde(i,j+n,MX-a[i][j]);
	  			diff::adde(j+n,i,a[i][j]);
  			}
  		}
  	}

  	if(!diff::run()) puts("NO");
  	else diff::output();

  }

	return 0;
}
```

---

## 作者：_LHF_ (赞：29)

考虑没有限制的时候怎么做？

显然，解法千千万，不再赘述。

先求出一组解（不一定合法），然后再进行调整。

我们发现对于每一行（列），分别加 $+1,-1,+1,-1$ 显然还是一组解。

那么对于第 $i$ 行，分别加 $+a_i,-a_i,+a_i,-a_i$ 仍然是一组解。

同理，对于第 $i$ 列，分别加 $+b_i,-b_i,+b_i,-b_i$ 也是一组解。

显然，做完这些操作之后每一个数都必须大于等于 $0$ 且小于等于 $10^6$，但我们发现这样子转化成差分约束模型之后，这里并不是真正的差分约束模型，因为全是加法……

我们令 $c_i=(-1)^ia_i,\;d_i=(-1)^{i+1}b_i$，再根据 $c,d$ 去搞差分约束，这样子就成功的转化成了差分约束算法。

讲的清楚吗？

---

## 作者：Warriors_Cat (赞：20)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7515)。

题意：

* 给一个 $n\times m$ 的矩阵 $a$，其中 $a_{i, j}\in [0, 10^6]$ 且为整数。定义一个 $(n-1)\times (m-1)$ 的矩阵 $b$，其中 $b_{i, j} = a_{i, j} + a_{i, j+1} + a_{i+1, j} + a_{i+1, j+1}$。

* 现在给定矩阵 $b$，求是否存在一个矩阵 $a$ 满足上述关系，如有则输出这个矩阵 $a$。

---

### Solution：

我们先不考虑 $a_{i, j}\in[0, 10^6]$ 这个限制，直接一通乱填满足 $b_{i, j} = a_{i, j} + a_{i, j+1} + a_{i+1, j} + a_{i+1, j+1}$ 即可。这是非常好构造的，直接令 $a_{n, i} = 0$，$a_{i, m}=0$，然后从后往前递推即可。不妨记此时的矩阵为 $A$。

我们再考虑如何调整这个矩阵。在这里有一个很显然的结论：对于每一行或者每一列，依次进行 $+x, -x, +x, -x, \dots$ 的操作，不影响 $b_{i, j}$ 的结果。

于是，我们可以将矩阵 $a$ 表示成下面那样的形式：

$$\begin{bmatrix}A_{1, 1}+c_1 + d_1&A_{1, 2}-c_1 + d_2&A_{1, 3}+c_1+d_3&A_{1, 4} -c_1 + d_4 & \cdots\\A_{2, 1}+c_2 - d_1&A_{2, 2}-c_2 - d_2&A_{2, 3}+c_2-d_3&A_{2, 4} -c_2 - d_4 & \cdots\\A_{3, 1}+c_3 + d_1&A_{3, 2}-c_3 + d_2&A_{3, 3}+c_3+d_3&A_{3, 4} -c_3 + d_4 & \cdots\\A_{4, 1}+c_4 - d_1&A_{4, 2}-c_4 - d_2&A_{4, 3}+c_4-d_3&A_{4, 4} -c_4 - d_4 & \cdots\\\vdots&\vdots&\vdots&\vdots&\ddots\end{bmatrix}$$

看到上面的那种形式就想到差分约束。这样的话，我们就有如下的约束关系：

$$\begin{cases}0\le A_{i, j}+c_i+d_j \le 10^6, i\equiv1\pmod 2\wedge j\equiv1\pmod 2\\0\le A_{i, j}-c_i+d_j \le 10^6, i\equiv1\pmod 2\wedge j\equiv0\pmod 2\\0\le A_{i, j}+c_i-d_j \le 10^6, i\equiv0\pmod 2\wedge j\equiv1\pmod 2\\0\le A_{i, j}-c_i-d_j \le 10^6, i\equiv0\pmod 2\wedge j\equiv0\pmod 2\end{cases}$$

可以发现，第二行和第三行已经满足了差分约束的关系，但第一行的第四行却不是。

于是，我们就是要想方设法地把第一行和第四行的关系搞成一对差。

这其实也很简单，我们只需要令 $x_i = (-1)^i \times c_i$，$y_i = (-1)^{i+1}\times d_i$，然后带回原约束关系：

$$\begin{cases}0\le A_{i, j}-x_i+y_j \le 10^6, i\equiv1\pmod 2\wedge j\equiv1\pmod 2\\0\le A_{i, j}+x_i-y_j \le 10^6, i\equiv0\pmod 2\wedge j\equiv1\pmod 2\\0\le A_{i, j}+x_i-y_j \le 10^6, i\equiv1\pmod 2\wedge j\equiv0\pmod 2\\0\le A_{i, j}-x_i+y_j \le 10^6, i\equiv0\pmod 2\wedge j\equiv0\pmod 2\end{cases}$$

这就是我们想要的差分约束形式。

因此，我们可以建图跑最短路求出 $x_i, y_i$ 的一组解，如果有负环就说明原题无解。知道 $x_i, y_i$ 后，就可以知道 $c_i, d_i$，也同时知道 $a_{i, j}$ 了。

over，时间复杂度为 $O(n^3)$，这里认为 $n, m$ 同阶。

---

### Code：

代码量算挺良心的了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 610, M = 360010, D = 1000000;
vector < pair <int, int> > g[N]; 
int n, m, a[N][N], b[N][N], k, deg[N], vis[N]; ll dis[N];
inline void add(int u, int v, int w){
	g[u].push_back(make_pair(v, w));
}
queue <int> q;
inline void mian(){
	n = read(); m = read(); k = n + m + 1;
	rep(i, 1, n + m) g[i].clear(); memset(a, 0, sizeof(a));
	rep(i, 1, n - 1) rep(j, 1, m - 1) b[i][j] = read();
	per(i, n - 1, 1) per(j, m - 1, 1) a[i][j] = b[i][j] - a[i + 1][j] - a[i][j + 1] - a[i + 1][j + 1];
	rep(i, 1, n) rep(j, 1, m){
		if(i + j & 1) add(i, j + n, a[i][j]), add(j + n, i, D - a[i][j]);
		else add(j + n, i, a[i][j]), add(i, j + n, D - a[i][j]);
	}
	while(!q.empty()) q.pop();
	rep(i, 1, n + m) dis[i] = deg[i] = 0, vis[i] = 1, q.push(i);
	while(!q.empty()){
		int u = q.front(); q.pop(); vis[u] = 0;
		for(pair <int, int> j : g[u]){
			int v = j.fi, w = j.se;
			if(dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				if(!vis[v]){
					if(++deg[v] > k){
						puts("NO");
						return;
					}
					vis[v] = 1; q.push(v);
				}
			}
		}
	}
	puts("YES");
	rep(i, 1, n){
		rep(j, 1, m){
			printf("%d ", a[i][j] + (int)(((i + j & 1) ? dis[i] - dis[j + n] : dis[j + n] - dis[i])));
		}
		puts("");
	}
}
signed main(){ int qwq = read(); while(qwq--) mian(); return 0; }
```


---

## 作者：caeious (赞：12)

awa 我做这题的时候企图当成线性方程组硬解，完全没有想到构造一组特解并看成操作问题的那个思路，于是就有了下面这种偏代数的解答。

---

首先观察到自由元有 $n + m - 1$ 个，凭感觉让 $a_{i,1}(1 \leq i \leq n)$ 和 $a_{1,j}(1 < j \leq m)$ 当自由元，_引入适当的符号_.

由原条件解得 $b'_{i, j} = a_{i, j} + (-1)^j a_{i, 1} + (-1)^i a_{1, j} + (-1)^{i + j} a_{1,1} (1 < i \leq n, 1 < j \leq m)$，两边同乘 $(-1)^{i + j}$ 让形式统一得到 $b''_{i, j} = (-1)^{i + j}a_{i, j} + (-1)^ia_{i, 1} + (-1)^j a_{1, j} + a_{1, 1}$，将 $b_{i, j}$ 重定义为 $b''_{i, j}$.

$c_{i, j} \triangleq (-1)^{i + j}a_{i ,j}$，则 $b_{i, j} = c_{i, j} + c_{1, 1} - c_{i, 1} - c_{1, j}$，即 $c_{i, j} - b_{i, j}= c_{i, 1} + c_{1, j} - c_{1, 1}$. 左边的取值范围是已知的，现在要整理右边来往差分约束的形式上靠.

---

变元：$c_{i, 1}(i \geq 1)$ 与 $c_{1, j} (j > 1)$.

需要满足的有哪些不等式：

- 对于 $i, j > 1$，$c_{i, 1} + c_{1, j} - c_{1, 1} \in$ 某个区间；①
- 对于 $i = 1$ 或 $j = 1$，$c_{i, j} \in$ 某个区间.  ②

而等量关系在代入的过程中已经满足了，于是有且仅有以上条件亟需满足.

**下面是见证奇怪的时刻：** $d_{1, j} \triangleq c_{1, 1} - c_{1, j}$，则 ①$\iff c_{i, 1} - d_{1, j} \in$ 某个区间，②$\iff$「$c_{i, 1} \in$ 某个区间」和「$c_{1, 1} - d_{1, j} \in$ 某个区间」.

大功告成.

---

参考实现：

```cpp
#include <bits/stdc++.h>
#define mp make_pair
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldouble;
typedef pair<int, int> P;
typedef pair<int, ll> Pil;
const int inf = 0x3f3f3f3f;
template<class T> bool chmin(T &x, const T &y) {
  return x > y ? (x = y, true) : false;
}
template<class T> bool chmax(T &x, const T &y) {
  return x < y ? (x = y, true) : false;
}

namespace SSSP {
  #define maxV 605
  vector<Pil> adj[maxV];
  int V, cnt[maxV];
  ll dis[maxV];
  bool inque[maxV];
  
  void init(int n) {
    V = n;
    for (int i = 1; i <= n; i++)
      adj[i].clear();
  }

  void addEdge(int u, int v, ll w) {
    assert(1 <= u && u <= V);
    assert(1 <= v && v <= V);
    adj[u].push_back(mp(v, w));
  }

  bool spfa(int s) { // false <=> 有负环.
    assert(1 <= s && s <= V);
    memset(cnt, 0, sizeof(cnt));
    memset(dis, 0x3f, sizeof(dis));
    memset(inque, 0, sizeof(inque));
    dis[s] = 0;
    queue<int> que;
    que.push(s);
    inque[s] = true;
    while (!que.empty()) {
      int u = que.front(); que.pop();
      inque[u] = false;
      for (auto e : adj[u]) {
        if (chmin(dis[e.first], dis[u] + e.second)) {
          cnt[e.first] = cnt[u] + 1;
          if (cnt[e.first] == V)
            return false;
          if (!inque[e.first]) {
            que.push(e.first);
            inque[e.first] = true;
          }
        }
      }
    }
    return true;
  }
  #undef maxV
}

#define maxn 305
const ll LIM = 1000000;
int n, m;
ll a[maxn][maxn], b[maxn][maxn];

void solve() {
  scanf("%d%d", &n, &m);
  for (int i = 2; i <= n; i++) {
    for (int j = 2; j <= m; j++) {
      scanf("%lld", &b[i][j]);
      b[i][j] -= b[i - 1][j] + b[i][j - 1] + b[i - 1][j - 1];
    }
  }
  for (int i = 2; i <= n; i++) {
    for (int j = 2; j <= m; j++) {
      if ((i + j) & 1)
        b[i][j] = -b[i][j];
    }
  }
  SSSP::init(n + m);
  for (int i = 1; i <= n; i++) {
    if ((i + 1) & 1) {
      SSSP::addEdge(n + 1, i, 0);
      SSSP::addEdge(i, n + 1, LIM);
    } else {
      SSSP::addEdge(n + 1, i, LIM);
      SSSP::addEdge(i, n + 1, 0);
    }
  }
  for (int i = 2; i <= m; i++) {
    if ((1 + i) & 1) {
      SSSP::addEdge(n + i, 1, 0);
      SSSP::addEdge(1, n + i, LIM);
    } else {
      SSSP::addEdge(n + i, 1, LIM);
      SSSP::addEdge(1, n + i, 0);
    }
  }
  for (int i = 2; i <= n; i++) {
    for (int j = 2; j <= m; j++) {
      if ((i + j) & 1) {
        SSSP::addEdge(n + j, i, -b[i][j]);
        SSSP::addEdge(i, n + j, LIM + b[i][j]);
      } else {
        SSSP::addEdge(n + j, i, LIM - b[i][j]);
        SSSP::addEdge(i, n + j, b[i][j]);
      }
    }
  }
  if (!SSSP::spfa(n + 1)) {
    puts("NO");
    return;
  }
  puts("YES");
  using SSSP::dis;
  for (int i = 1; i <= n; i++)
    a[i][1] = dis[i];
  for (int i = 2; i <= m; i++)
    a[1][i] = a[1][1] - dis[n + i];
  for (int i = 2; i <= n; i++) {
    for (int j = 2; j <= m; j++) {
      a[i][j] = a[i][1] + a[1][j] + b[i][j] - a[1][1];
    }
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if ((i + j) & 1)
        a[i][j] = -a[i][j];
      printf("%lld%c", a[i][j], j == m ? '\n' : ' ');
    }
  }
}

int main() {
  int t;
  scanf("%d", &t);
  while (t--)
    solve();
  return 0;
}
```

---

## 作者：whiteqwq (赞：10)

[P7515 [省选联考 2021 A 卷] 矩阵游戏](https://www.luogu.com.cn/problem/P7515)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1791035)

## 题意

给定大小为$(n-1)\times(m-1)$的矩阵$b$，求生成任意一个满足条件的$a$满足：

- $a$的大小为$n\times m$；
- $b_{i,j}=a_{i,j}+a_{i+1,j}+a_{i,j+1}+a_{i+1,j+1}$；
- $0\leqslant a_{i,j}\leqslant 10^6$

保证$0\leqslant b_{i,j}\leqslant 4\times 10^6$，$2\leqslant n,m\leqslant 300$。

## 分析

可能是暗中送我退役的一道题，我要是把这个思路想下去做掉这道题，那我剩下的题用头打都能进队啊！！！！！！！！！！！！！！！！！！！！！！！！！！！！

技不如人，肝败吓疯。

首先不考虑$0\leqslant a_{i,j}\leqslant 10^6$，并钦定$a_{i,1}=a_{1,j}=0$，不难发现可以生成一组解$a'$。

我们考虑通过调整某些位置的权值使得最后的解权值满足限制。

发现对某一行交替$+r,-r,+r,-r\cdots$后的解仍然满足矩阵$b$的限制；同理，对某一列交替$+c,-c,+c,-c\cdots$后的解也仍然满足矩阵$b$的限制。

不难发现任意一组解都可以被这样表示出来：

$$
\begin{bmatrix}a'_{1,1}+r_1+c_1&a'_{1,2}-r_1+c_2&a'_{1,3}+r_1+c_3&\cdots\\a'_{2,1}+r_2-c_1& a'_{2,2}-r_2-c_2& a'_{2,3}+r_2-c_3&\cdots\\a'_{3,1}+r_3+c_1& a'_{3,2}-r_3+c_2&a'_{3,3}+r_3+c_3&\cdots\\\vdots&\vdots&\vdots&\ddots\end{bmatrix}
$$

再考虑$0\leqslant a_{i,j}\leqslant 10^6$这一限制，不难发现把$c$序列与$r$序列看做未知量之后可以对其进行差分约束。

但是对于同号的不等式是很难进行差分约束的，考虑定义$c'_{k}=\begin{cases}-c_k&k\equiv 1\pmod 2\\c_k&k\equiv 0\pmod 2\end{cases}$,$r'_{k}=\begin{cases}r_k&k\equiv 1\pmod 2\\-r_k&k\equiv 0\pmod 2\end{cases}$

然后再次带入上面的解可以得到一个很优美的形式：

$$
\begin{bmatrix}a'_{1,1}+r'_1-c'_1&a'_{1,2}-r'_1+c'_2&a'_{1,3}+r'_1-c'_3&\cdots\\a'_{2,1}-r'_2+c'_1& a'_{2,2}+r'_2-c'_2& a'_{2,3}-r'_2+c'_3&\cdots\\a'_{3,1}+r'_3-c'_1& a'_{3,2}-r'_3+c'_2&a'_{3,3}+r'_3-c'_3&\cdots\\\vdots&\vdots&\vdots&\ddots\end{bmatrix}
$$

这样就可以进行差分约束了，复杂度：$O((n+m)nm)$。

## 代码
Bellman Ford被卡常了（需要特判才能过），迫不得已用了spfa/kk
```
#include<stdio.h>
#include<queue>
#include<vector>
#define inf 10000000000000000
using namespace std;
const int maxn=305,maxm=maxn*maxn*2;
int T,n,m,e;
int a[maxn][maxn],b[maxn][maxn],vis[maxn<<1],tot[maxn<<1];
vector<int>v[maxn<<1],w[maxn<<1];
long long dis[maxn<<1];
queue<int>q;
inline void add(int x,int y,int z){
	v[x].push_back(y),w[x].push_back(z);
}
inline void limit(int x,int y,int v){
	add(x,y,v);//v+x-y>=0
	add(y,x,1000000-v);//v+x-y<=1000000
}
int spfa(){
	while(!q.empty())
		q.pop();
	for(int i=1;i<=n+m;i++)
		dis[i]=inf,tot[i]=0,vis[i]=0;
	dis[1]=0,vis[1]=1,q.push(1);
	while(!q.empty()){
		int x=q.front();
		tot[x]++;
		if(tot[x]>n+m)
			return 1;
		q.pop();
		for(int i=0;i<v[x].size();i++){
			int y=v[x][i],z=w[x][i];
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;
				if(vis[y]==0)
					vis[y]=1,q.push(y);
			}
		}
		vis[x]=0;
	}
	return 0;
}
inline int calc(int x,int y){
	return a[x][y]+(int)(((x+y)&1)? (dis[n+y]-dis[x]):(dis[x]-dis[n+y]));
}
int main(){
	scanf("%d",&T);
	while(T--){
		e=0;
		scanf("%d%d",&n,&m);
		for(int i=1;i<n;i++)
			for(int j=1;j<m;j++)
				scanf("%d",&b[i][j]);
		for(int i=2;i<=n;i++)
			for(int j=2;j<=m;j++)
				a[i][j]=b[i-1][j-1]-a[i-1][j-1]-a[i-1][j]-a[i][j-1];
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++){
				if((i+j)&1)
					limit(n+j,i,a[i][j]);
				else limit(i,n+j,a[i][j]);
			}
		if(spfa()){
			puts("NO");
			for(int i=1;i<=n+m;i++)
				v[i].clear(),w[i].clear();
			continue;
		}
		puts("YES");
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				printf("%d%c",calc(i,j),j==m? '\n':' '),a[i][j]=0;
		for(int i=1;i<=n+m;i++)
			v[i].clear(),w[i].clear();
	}
	return 0;
}
```

省选联考A卷全部题解可见：[2021省选联考A卷解题报告](https://zybuluo.com/xiaoziyao/note/1791034)

---

## 作者：zzw4257 (赞：8)

>**Lemma.**
>
>不考虑上下界,设$\{a_{i,j}\}$为任意一个特解,则所有可行解的等价类可以表示为：
>
>$\{\{a'_{i,j}\},\exists \{x_i\}(i\in[1,n]),\{y_j\}(j\in[1,m]),\forall a'_{i,j}=(-1)^{j-1}x_i+(-1)^{i-1}y_j+a_{i,j}\}$
>
>换句话说是我们可以为每一行，每一列(分开)都加上一个交替数列

因此我们只需要找一个特解然后调整出结果了

因为最后结果是对上下界的限制不难想到差分约束

紧接着会发现对每个位置的限制符号时反时逆，这不可以建边

考虑一种转换$x_i=(-1)^{i-1}x‘_i,y_j=(-1)^{j}y’_j$

则替换后$(-1)^{i+j-2}x'_{i}+(-1)^{i+j-1}y'_j$就一定反号

另外的，我们解出来$x'_i,y'_j$后把他带回去时容易发现形式不变

```cpp
#include<bits/stdc++.h>
#define N 601
#define B 1000000
typedef long long ll;
using namespace std;
struct Edge{int to,v;};
vector<Edge>g[N];
int Case,n,m,a[N][N],b[N][N],vis[N],q[N*N],sum[N],lim;
ll d[N];
inline char SPFA(void){
	int i,x,y,l=1,r=0;
	for(i=1;i<=n+m;++i)vis[q[++r]=i]=1,sum[i]=0,d[i]=0;
	while(l<=r){
		vis[x=q[l++]]=0;for(auto t:g[x]){if(d[y=t.to]>d[x]+t.v){d[y]=d[x]+t.v;if(!vis[y]){if(++sum[y]>lim)return 0;vis[q[++r]=y]=1;}}}
	}return 1;
}
inline void Solve(void){
	int i,j;scanf("%d%d",&n,&m);lim=min(n+m+1,15);memset(a,0,sizeof a);
	for(i=1;i<=n+m;++i)g[i].clear();
	for(i=1;i<n;++i)for(j=1;j<m;++j)scanf("%d",&b[i][j]);
	for(i=n-1;i;--i)for(j=m-1;j;--j)a[i][j]=b[i][j]-a[i+1][j]-a[i+1][j+1]-a[i][j+1];
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)if((i+j)&1)g[i].push_back({j+n,a[i][j]}),g[j+n].push_back({i,B-a[i][j]});else g[j+n].push_back({i,a[i][j]}),g[i].push_back({j+n,B-a[i][j]});
	if(!SPFA())return void(puts("NO"));
	puts("YES");for(i=1;i<=n;++i,putchar('\n'))for(j=1;j<=m;++j)printf("%d ",a[i][j]+(int)(((i+j)&1)?d[i]-d[j+n]:d[j+n]-d[i]));
}
int main(void){
	scanf("%d",&Case);
	while(Case--)Solve();
	return 0;
}
```

---

## 作者：Mobius127 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P7515)

>题目大意

>>有一个 $n \times m$ 的矩阵 $A$，你用其生成了一个 $(n-1) \times (m-1)$ 的矩阵 $B$，满足 $b_{i, j}=a_{i,j}+a_{i,j+1}+a_{i+1,j}+a_{i+1,j+1}$

>>现给出矩阵 $B$，要求得到原来的矩阵 $A$，元素值域 $[0,\ 10^6]$

丢掉限制，那么这道就是个弱智题。

因为

$$b_{i, j}=a_{i, j}+a_{i,j+1}+a_{i+1,j}+a_{i+1,j+1}$$

$$a_{i, j}=b_{i, j}-a_{i,j+1}-a_{i+1,j}-a_{i+1,j+1}$$

所以我们选择从矩阵右下角逆推，这样在求 $a_{i, j}$ 的时候，剩下四个元素就全部是已知的了。

但是我们还得考虑值域的影响。

思考什么样的操作不会影响到 $B$ 矩阵。

由于 $B$ 矩阵的生成相当于一个 $4 \times 4$ 的矩阵：

$\begin{bmatrix}
a_{i, j}  & a_{i, j+1}\\
a_{i+1, j}  & a_{i+1, j+1}
\end{bmatrix}$ 的和，所以，我们可以在每一个元素上面 $\pm$ 一个值 $r$，同时为了保证 $b_{i, j}$ 不变化，所以必然是 $+ 2 \times r$ 和 $- 2 \times r$， 那么操作后的矩阵是这个亚子的：

$$\begin{bmatrix}
a_{i, j}+r  & a_{i, j+1}-r\\
a_{i+1, j}-r  & a_{i+1, j+1}+r
\end{bmatrix}$$

又由于我们需要维护整个 $B$，所以我们拓展到整个矩阵：

$$\begin{bmatrix}
a_{1, 1}+r  & a_{1, 2}-r & ... & a_{1, n-1}+r \times (-1)^{n-2} & a_{1, n}+r \times (-1)^{n-1}\\
a_{2, 1}+r  & a_{2, 2}-r & ... & a_{2, n-1}+r \times (-1)^{n-2} & a_{2, n}+r \times (-1)^{n-1}\\
...  & ... & ... & ... & ...\\
a_{n-1, 1}+r  & a_{n-1, 2}-r & ... & a_{n-1, n-1}+r \times (-1)^{n-2} & a_{n-1, n}+r \times (-1)^{n-1}\\
a_{n, 1}+r  & a_{n, 2}-r & ... & a_{n, n-1}+r \times (-1)^{n-2} & a_{n, n}+r \times (-1)^{n-1}
\end{bmatrix}$$

这时候就可以猜个性质：对某一行交替 $+r,-r,+r,-r$ 后对 $B$ 没有影响。

同理列也一致。

证明的话，对于任意的 $b_{i, j}$ 由于加减是交替的，所以 $new\ b_{i, j}=b_{i, j} +r -r =b_{i, j}$，回到了最初的值。

那我们就设第 $i$ 行的 $r$ 是 $dis_i$ ，第 $j$ 列的 $r$ 是 $dis_{n+j}$，由于这样的话某几行/列就是 $a_{i, j}+dis_i+dis_{n+j}$，那么我们重设 $dis_i=(-1)^i \times dis_i, dis_{j+n}=(-1)^{j+1} \times dis_{j+n}$ 后，矩阵不管那一行/列，就都能满足差分约束的板子了。

### Code

```
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
const int N=305;
const int L=0;
const int R=1e6;
const int INF=0x3f3f3f3f;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int n, m, a[N][N], b[N][N];
ll dis[N<<1];
vector < pair <int, int> > G[N<<1];
struct StPh{
	int cnt[N<<1];
	bool in[N<<1];
	queue <int> Q;
	void clear(){
		memset(cnt, 0, sizeof(cnt));
		memset(in, 0, sizeof(in));
		while(!Q.empty())
			Q.pop();
	}
	bool spfa(){
		dis[1]=0, Q.push(1);
		while(!Q.empty()){
			int x=Q.front();Q.pop();in[x]=0, cnt[x]++;
			if(cnt[x]>n+m) return 1;
			int sz=(int)G[x].size();
			for(int i=0; i<sz; i++){
				int to=G[x][i].first, w=G[x][i].second;
				if(dis[to]>dis[x]+w){
					dis[to]=dis[x]+w;
					if(!in[to])
						Q.push(to), in[to]=1;
				}
					
			}
		}
		return 0;
	}
}stph;
void clear(){
	memset(a, 0, sizeof(a));
	memset(dis, 9, sizeof(dis));
	for(int i=1; i<=n+m; i++)
		G[i].clear();
	stph.clear();
}
int solve(){
	n=read(), m=read();
	clear();
	for(int i=1; i<n; i++)
		for(int j=1; j<m; j++)
			b[i][j]=read();
	for(int i=n; i; i--)
		for(int j=m; j; j--)
			a[i][j]=b[i][j]-a[i+1][j]-a[i+1][j+1]-a[i][j+1];
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++){
			if((i+j)&1) 
				G[j+n].push_back(make_pair(i, a[i][j])),
				G[i].push_back(make_pair(j+n, 1e6-a[i][j]));
			else
				G[j+n].push_back(make_pair(i, 1e6-a[i][j])),
				G[i].push_back(make_pair(j+n, a[i][j]));
		}
	if(stph.spfa()) return 0*printf("NO\n");
	printf("YES\n");
	for(int i=1; i<=n; i++, puts(""))
		for(int j=1; j<=m; j++){
			a[i][j]+=(((i+j)&1)?-1:1)*dis[i];
			a[i][j]+=(((i+j)&1)?1:-1)*dis[j+n];
			printf("%d ", a[i][j]);
		}
	return 0;
}
signed main(){
	int T=read();
	for(; T; T--)
		solve();
	return 0;
} 
```


---

## 作者：wind_whisper (赞：5)

# 解析
如果没有元素均要在 $[0,10^6]$ 的条件，可以很容易的构造出一个合法解。

那么我们就要通过调整得到的解，使所有数都在合法范围内。  
注意到，每次给某一行/列依次 $+1,-1,+1,-1...$ 这样仍然符合要求。
让每一行/列错开，对应的贡献就能变成：

```cpp
row:
+-+-+
-+-+-
+-+-+
-+-+-

column:
-+-+-
+-+-+
-+-+-
+-+-+
```
这样每个格子行贡献和列贡献的符号就都是相反的，每一个格子的约束也就能变成 $0\le a_{i,j}\pm(c_i-d_j)\le10^6$ 的样子，然后就可以差分约束了。

这样操作能涵盖所有解吗？  
对于任意一个方案，我们都可以在得到第一行和第一列的所有值后递推求得。  
而我们这么操作必然可以使第一行和第一列的所有元素变成我们需要的状态，因此也就可以达到所有合法状态。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("OK\n")
using namespace std;

const int N=650;
const int M=50050;
const int mod=1e9+7;
const double eps=1e-9;

inline ll read() {
	ll x(0),f(1);char c=getchar();
	while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}

int n,m;
int a[N][N],b[N][N],c[N],d[N],tot;
ll dis[N];
int o=1e6;
queue<int>q;
bool vis[N];
int tim[N];
struct node{
	int to,nxt,w;
}p[N*N*2];
int fi[N],cnt;
inline void addline(int x,int y,int w){
	p[++cnt]=(node){y,fi[x],w};fi[x]=cnt;
}
bool spfa(){
	memset(dis,0,sizeof(dis));
	memset(tim,0,sizeof(tim));
	for(int i=1;i<=tot;i++) q.push(i),vis[i]=1;
	while(!q.empty()){
		int now=q.front();q.pop();
		vis[now]=0;
		for(int i=fi[now];~i;i=p[i].nxt){
			int to=p[i].to;
			if(dis[to]<dis[now]+p[i].w){
				dis[to]=dis[now]+p[i].w;
				tim[to]++;
				if(!vis[to]){
					vis[to]=1;q.push(to);
				}
				if(tim[to]>tot) return false;
			}
		}
	}
	return true;
}
void work(){
	memset(a,0,sizeof(a));tot=0;
	memset(fi,-1,sizeof(fi));cnt=-1;
	n=read();m=read();
	for(int i=1;i<n;i++){
		for(int j=1;j<m;j++) b[i][j]=read();
	}
	for(int i=n-1;i>=1;i--){
		for(int j=m-1;j>=1;j--) a[i][j]=b[i][j]-a[i+1][j+1]-a[i+1][j]-a[i][j+1];
	}
	//for(int i=1;i<=n;i++){
		//for(int j=1;j<=m;j++) printf("%d ",a[i][j]);
		//puts("");
	//}
	for(int i=1;i<=n;i++) c[i]=++tot;
	for(int j=1;j<=m;j++) d[j]=++tot;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if((i+j)&1){
				addline(c[i],d[j],a[i][j]-o);
				addline(d[j],c[i],-a[i][j]);
			}
			else{				
				addline(c[i],d[j],-a[i][j]);
				addline(d[j],c[i],a[i][j]-o);
			}
		}
	}
	//for(int i=1;i<=tot;i++)
	//	for(int j=1;j<=tot;j++) printf("%d -> %d w=%d\n",i,j,e[i][j]);
	
	if(!spfa()){
		puts("NO");return;
	}
	puts("YES");
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			ll add=dis[c[i]]-dis[d[j]];
			if((i+j)&1) a[i][j]+=add;
			else a[i][j]-=add;
			printf("%d ",a[i][j]);
		}
		puts("");
	}
}
int main() {
#ifndef ONLINE_JUDGE
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
#endif
	int T=read();
	while(T--) work();
	return 0;
}
/*
1
3 3
1000000 2000000
0 0
*/
```


---

## 作者：UperFicial (赞：3)

> [**P7515 [省选联考 2021 A 卷] 矩阵游戏**](https://www.luogu.com.cn/problem/P7515)

> 解题报告。

> [**不一定更好的阅读体验**](https://www.cnblogs.com/UperFicial/p/16735424.html)。

$\text{Update 2022.9.29}$：经 [@foreverchan](https://www.luogu.com.cn/user/15526) 提醒，增加了有关做法正确性的证明，并修改了一些语句。

---

一年前我在省选赛场上折戟沉沙，一年后我从倒下的地方再摔一跤。

我成功了，我仍然是以前的那个我。

----

神题，希望自己讲得清楚一些。

先不考虑 $0\le a_{i,j}\le 10^6$ 的限制，只考虑 $b_{i,j}=a_{i,j}+a_{i+1,j}+a_{i,j+1}+a_{i+1,j+1}$，瞎鸡巴填一手，得到矩阵 $A$，之后比较自然的想法就是通过 $+1$ 和 $-1$ 来微调这个东西。

其实这个时候差不多就可以想到差分约束了，因为我们最终希望把每一个 $a_{i,j}$ 变成 $0\le a_{i,j}\le 10^6$ 这样一个范围的形式。不过我知道你很急，但你先别急。继续往下做，看看这个想法有没有希望。

两个比较显然的性质：

1. 对于**每一行**轮流进行 $+1$ 和 $-1$ 的操作，结果不变。

2. 对于**每一列**轮流进行 $+1$ 和 $-1$ 的操作，结果不变。

因为任意一个 $2\times 2$ 的矩阵中的一组 $+1$ 和 $-1$ 会相互抵消掉。

我们设 $1$ 操作在第 $i$ 行进行了 $c_{i}$ 次，设 $2$ 操作在第 $j$ 行进行了 $d_i$ 次，那么可以得到如下的矩阵（每一项省略了 $a_{i,j}$）：

$$
\begin{bmatrix}
c_1+d_1 & -c_1+d_2 & \cdots & (-1)^{m+1}c_1+d_n\\
c_2-d_1 & -c_2-d_2 & \cdots & (-1)^{m+1}c_2-d_n\\
 \cdots & \cdots & \ddots  & \cdots\\
c_n+(-1)^{n+1}d_m & -c_n+(-1)^{n+1}d_m & \cdots & (-1)^{m+1}c_n+(-1)^{n+1}d_m
\end{bmatrix}
$$

第一眼：哇这不是差分约束板子吗！

第二眼：我是不是应该发明一个叫 $0\le a_{i,j}+c+d\le 10^6$ 的和分约束？

但是这个和分约束显然可以通过变化 $c$ 的符号来转化成差分约束。

我们将偶数行的 $c$ 变成相反数，奇数列的 $d$ 变成相反数。

那么原矩阵就变成了：

$$
\begin{bmatrix}
c_1-d_1 & d_2-c_1 & \cdots \\
d_1-c_2 & c_2-d_2 & \cdots\\
 \cdots & \cdots & \ddots\\
\end{bmatrix}
$$

这里仅举例 $2\times 2$ 的矩阵已经足够证明正确性，因为包含了所有下标的奇偶性，这样的话转化就做完了。

我们先将第最后一行钦定为 $0$，然后得到了一个不考虑限制的矩阵 $A$，之后按照上面的矩阵，以 $(1,1)$ 为例，得到差分约束 $0\le a_{1,1}+c_1-d_1\le 10^6$ 的形式，跑 $\text{SPFA}$ 就行了。

注意，这道题可以不用建立虚点的，因为这张图已经保证联通了，而且是差不多是一张完全图，用链式前向星容易被卡，而 $\texttt{vector}$ 存图在稠密图的情况下是表现良好的。

证明一下这个做法的正确性，钦定 $a_{i,j}$ 会有 $(n-1)(m-1)$ 个方程，差分约束会建立 $2nm$ 个方程，但这里的方程每有两个会得到 $(n+m)$ 个未知数，每个未知数会得到一个 $a_{i,j}$，所以本质是有 $(n+m)$ 个方程，最终我们得到 $(nm+1)$ 个有关 $a$ 的方程，足以确定 $nm$ 个未知数。

个人感觉比较好看的代码：

```cpp
const int MAXN(310);
const int MAXM(610);
const int MAX(1e6);

int n,m,a[MAXN][MAXN],b[MAXN][MAXN],K;

struct node{int to,cost;};
vector<node>G[MAXM];

bool inq[MAXM];
queue<int>q;
ll d[MAXM];
int cnt[MAXM];

inline void add_edge(int u,int v,int w)
{
	node res;
	res.to=v,res.cost=w;
	G[u].push_back(res);
	return;
}

inline bool spfa(int s)
{
	rep(i,1,n+m) d[i]=LLINF,inq[i]=false,cnt[i]=0;
	d[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		inq[u]=false;
		rep(i,0,(int)G[u].size()-1)
		{
			node e=G[u][i];
			if(d[e.to]>d[u]+e.cost)
			{
				d[e.to]=d[u]+e.cost;
				if(!inq[e.to])
				{
					if(++cnt[e.to]>=n+m) return false;
					inq[e.to]=true,q.push(e.to);
				}
			}
		}
	}
	return true;
}

inline void solve()
{
    n=Fread::read(),m=Fread::read();
    rep(i,1,n-1) rep(j,1,m-1) b[i][j]=Fread::read();
    rev(i,n-1,1) rev(j,m-1,1) a[i][j]=b[i][j]-a[i+1][j]-a[i][j+1]-a[i+1][j+1];//随便构造一个矩阵 A
    rep(i,1,n) rep(j,1,m)
    {
    	if((i+j)&1) add_edge(j+n,i,MAX-a[i][j]),add_edge(i,j+n,a[i][j]);
    	else add_edge(i,j+n,MAX-a[i][j]),add_edge(j+n,i,a[i][j]);
    }
    if(!spfa(1)) puts("NO");
    else
    {
    	puts("YES");
    	rep(i,1,n)
    	{
    		rep(j,1,m) 
    		{
    			int now=d[i]-d[j+n];
    			if((i+j)&1) cout<<a[i][j]+now,putchar('\n');
    			else cout<<a[i][j]-now,putchar('\n');
    		}
    		putchar('\n');
    	}
    }
    Clear(a);
    rep(i,1,n+m) G[i].clear();
    return;
}

int main()
{
	int T=Fread::read();
	while(T--) solve();
	return 0;
}
/*
Date : 2022/9/27
Author : UperFicial
Start coding at : 17:03
finish debugging at : 17:50
*/
```

---

## 作者：panyf (赞：3)

补充一些其他题解没有提到的细节。

首先不考虑对元素大小的限制，先将第一行第一列都填成 $0$，然后可以递推构造出一组满足 $b$ 限制的 $a$。记 $A_{i,j}$ 为最开始构造出的 $a_{i,j}$。

可以证明构造出的 $a$ 的所有元素都不会爆 long long，因为每个 $b_{i,j}$ 对 $a_{i,j}$ 的贡献只可能是 $b_{i,j}$ 或 $0$ 或 $-b_{i,j}$。但有可能爆 int。很多题解这里没有开 long long，应该可以卡掉。

接下来有一个很关键的结论：

对于 $a$ 中一行或一列的所有元素依次 $+x,-x,+x...$ 之后，$a$ 仍然满足 $b$ 限制。并且所有满足 $b$ 限制的 $a$ 都可以用 $A$ 通过若干次这样的操作得到。

证明：

考虑任意一种满足 $b$ 限制的 $a$，先对每一行进行操作，使第一列全变成 $0$。再对除第一列以外每一列进行操作，使第一行全变成 $0$，并且不会影响第一列。通过最开始递推构造的过程可知第一行第一列全为 $0$ 的 $a$ 有且仅有一个。所以任意一种 $a$ 通过若干次操作都能变成 $A$。将操作的 $x$ 取相反数，通过 $A$ 就可以得到任意一种 $a$。

记 $r_i$ 为第 $i$ 行的 $x$，$c_i$ 为第 $i$ 列的 $x$。但 $a_{i,j}$ 中既有 $r_i$ 和 $c_j$ 的差，也有和，这样不方便差分约束。

于是将偶数行的 $r_i$ 取相反数，奇数列的 $c_j$ 取相反数，这样 $a_{i,j}=A_{i,j}+r_i-c_j$（$i+j$ 为偶数） 或 $a_{i,j}=A_{i,j}+c_i-r_j$（$i+j$ 为奇数），就可以差分约束了。

对每一行每一列建一个点，表示 $r_i$ 或 $c_i$ 的值。以 $i+j$ 为偶数为例，限制为 $-A_{i,j}\leq r_i-c_j\leq 10^6-A_{i,j}$。从 $c_j$ 对应点向 $r_i$ 对应点连长 $10^6-A_{i,j}$ 的边，从 $r_i$ 向 $c_j$ 连长 $A_{i,j}$ 的边。

用 spfa 求最短路即可。因为此题毒瘤卡常，所以要卡松弛次数，大于某个值就直接判定无解。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int O=307,N=607,M=180007,I=1e6;
int c[N];
ll d[N],a[O][O],e[N][N];
bool f[N];
#define _ {if(d[j]>(l=d[i]+e[i][j])){\
if(d[j]=l,(c[j]=c[i]+1)==u){puts("NO");goto gg;}\
if(!f[j])f[j]=1,q.push(j);}}
int main(){
	int T,n,m,i,j,o,u;
	ll l;
	for(scanf("%d",&T);T--;){
		scanf("%d%d",&n,&m),memset(a,0,sizeof a),u=min(n+m,99);//u用来卡松弛次数
		for(i=2;i<=n;++i)for(j=2;j<=m;++j)scanf("%d",&o),a[i][j]=o-a[i-1][j-1]-a[i-1][j]-a[i][j-1];//递推求A
		for(i=1;i<=n;++i)for(j=1;j<=m;++j)if(i+j&1)e[j+n][i]=a[i][j],e[i][j+n]=I-a[i][j];else e[j+n][i]=I-a[i][j],e[i][j+n]=a[i][j];//连边
		queue<int>q;
		memset(d,9,sizeof d),memset(f,0,sizeof f),d[1]=c[1]=0,q.push(1),o=n+m;
		while(q.size())if(f[i=q.front()]=0,q.pop(),i<=n)for(j=n+1;j<=o;++j)_ else for(j=1;j<=n;++j)_//spfa
		for(puts("YES"),i=1;i<=n;++i,puts(""))for(j=1;j<=m;++j)printf("%lld ",a[i][j]+(d[j+n]-d[i])*((i+j&1)?1:-1));
		gg:;
	}
	return 0;
}
```


---

## 作者：Leasier (赞：1)

注意到 $0 \leq b_{i, j} \leq 4 \times 10^6$，但要求 $0 \leq a_{i, j} \leq 10^6$ 就很烦，考虑先去掉这个条件看怎么构造。

注意到其中两个相邻边界上的点只受到 $\leq 2$ 个限制，考虑先给边界——比如说所有 $(n, i), (i, m)$——赋值为 $0$，然后就可以递推出剩下的值了。

但很遗憾这玩意显然并不能满足 $a_{i, j}$ 的值域限制。~~甚至连样例也过不去。~~

考虑进行一些调整。为了不影响 $b_{i, j}$ 的值，注意到其中第 $i, i + 1$ 行和第 $j, j + 1$ 列的贡献均为 $2$，也就是说**相邻行列的新贡献需要互相抵消**，考虑给每个第 $i$ 行加上一个数 $(-1)^{i - 1} x_i$，每个第 $i$ 列加上一个数 $(-1)^{i - 1} y_i$，则：

- $0 \leq a_{i, j} + (-1)^{i - 1} x_i + (-1)^{j - 1} y_j \leq 10^6$。

移项即可得到一个关于 $x_i, y_j$ 的不等式。但是你会发现这玩意可能会产生“和分约束”的诡异情况，于是我们考虑一个类似**黑白染色**的方法，给每个第 $i$ 行 $j$ 列加上 $(-1)^{i + j} (x_i - y_j)$，然后就变成差分约束状物了。

SPFA 求解即可。时间复杂度为 $O(Tnm(n + m))$。注意要开 long long，以及不加 SLF 优化会被卡常。

代码：
```cpp
#include <queue>
#include <cstdio>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
	ll dis;
} Edge;

int cnt;
int head[607], vis_cnt[607], b[307][307];
ll dis[607], a[307][307];
bool vis[607];
Edge edge[180607];
deque<int> q;

inline void init(int n){
	cnt = 0;
	for (register int i = 0; i <= n; i++){
		head[i] = 0;
		dis[i] = 0x7fffffffffffffffll;
		vis[i] = false;
		vis_cnt[i] = 0;
	}
}

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

inline bool spfa(int start, int n){
	dis[start] = 0;
	vis[start] = true;
	vis_cnt[start] = 1;
	q.push_back(start);
	while (!q.empty()){
		int cur = q.front();
		q.pop_front();
		vis[cur] = false;
		for (register int i = head[cur]; i != 0; i = edge[i].nxt){
			int x = edge[i].end;
			ll y = dis[cur] + edge[i].dis;
			if (dis[x] > y){
				dis[x] = y;
				if (!vis[x]){
					if (++vis_cnt[x] >= n){
						while (!q.empty()) q.pop_front();
						return false;
					}
					vis[x] = true;
					if (!q.empty() && dis[q.front()] < dis[x]){
						q.push_back(x);
					} else {
						q.push_front(x);
					}
				}
			}
		}
	}
	return true;
}

int main(){
	int t;
	scanf("%d", &t);
	for (register int i = 1; i <= t; i++){
		int n, m, t;
		scanf("%d %d", &n, &m);
		t = n + m;
		init(t);
		for (register int j = 1; j < n; j++){
			for (register int k = 1; k < m; k++){
				scanf("%d", &b[j][k]);
			}
		}
		for (register int j = 1; j <= m; j++){
			a[n][j] = 0;
		}
		for (register int j = 1; j < n; j++){
			a[j][m] = 0;
		}
		for (register int j = n - 1; j >= 1; j--){
			for (register int k = m - 1; k >= 1; k--){
				a[j][k] = b[j][k] - a[j][k + 1] - a[j + 1][k] - a[j + 1][k + 1];
			}
		}
		for (register int j = 1; j <= t; j++){
			add_edge(0, j, 0);
		}
		for (register int j = 1; j <= n; j++){
			for (register int k = 1; k <= m; k++){
				int k_ = k + n;
				if ((j + k) % 2 == 0){
					add_edge(j, k_, a[j][k]);
					add_edge(k_, j, 1e6 - a[j][k]);
				} else {
					add_edge(j, k_, 1e6 - a[j][k]);
					add_edge(k_, j, a[j][k]);
				}
			}
		}
		if (!spfa(0, t + 1)){
			printf("NO\n");
		} else {
			printf("YES\n");
			for (register int j = 1; j <= n; j++){
				for (register int k = 1; k <= m; k++){
					if ((j + k) % 2 == 0){
						printf("%lld ", a[j][k] + dis[j] - dis[k + n]);
					} else {
						printf("%lld ", a[j][k] + dis[k + n] - dis[j]);
					}
				}
				printf("\n");
			}
		}
	}
	return 0;
}
```

---

## 作者：tzc_wk (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P7515)

emmm……怎么评价这个题呢，赛后学完差分约束之后看题解感觉没那么 dl，可是现场为啥就因为种种原因想不到呢？显然是 wtcl（

先不考虑“非负“及” $\le 10^6$ ”这两条件，考虑什么样的矩阵 $A$ 能够生成 $B$，我们首先考虑矩阵 $A$ 的一个特解 $A'$：第一行和第一列都是 $0$ 的情况，显然 $A'$ 可以通过一遍反着递推求出。接下来考虑怎样通过 $A'$ 推出所有符合要求的矩阵 $A$，一个显然的事实是如果确定了该矩阵 $A$ 的第一行和第一列，那么最终的矩阵就定下来了。注意到 $A$ 的第一行第一列的元素 $A_{11}$ 是有点特别的，因为它既在第一行又在第一列，我们先忽略它，暂且将它定为 $0$。我们考虑对于某个 $i\ne 1$，将 $A_{1i}$（或 $A_{i1}$）由 $0$ 变为 $v$ 对整个矩阵 $A$ 产生的影响，以 $A_{1i}$ 为例，手玩几组数据就可以发现若 $A_{1i}$ 变成 $v$，那么 $A_{2i}$ 会减去 $v$，$A_{3i}$ 会加上 $v$，$A_{4i}$ 又会减去 $v$，以此类推。我们假设 $x_i=A_{i1},y_i=A_{1i}$，那么
$$
A=A'+\begin{bmatrix}
0&y_2&y_3&\cdots&y_j&\cdots&y_m\\
x_2&-x_2-y_2&x_2-y_3&\cdots&(-1)^{j+1}x_2-y_j&\cdots&(-1)^{m+1}x_2-y_m\\
\vdots&\vdots&\vdots&\ddots&\vdots&\ddots&\vdots\\
x_i&-x_i+(-1)^{i+1}y_2&x_i+(-1)^{i+1}y_3&\cdots&(-1)^{j+1}x_i+(-1)^{i+1}y_j&\cdots&(-1)^{m+1}x_i+(-1)^{i+1}y_m\\
\vdots&\vdots&\vdots&\ddots&\vdots&\ddots&\vdots\\
x_n&-x_n+(-1)^{n+1}y_2&x_n+(-1)^{n+1}y_3&\cdots&(-1)^{j+1}x_n+(-1)^{n+1}y_j&\cdots&(-1)^{m+1}x_n+(-1)^{n+1}y_m
\end{bmatrix}
$$
考虑加上 $A_{11}$ 之后的影响，那么 $A_{ij}$ 会加上 $(-1)^{i+j+1}A_{11}$，这个看起来有点棘手，怎么办呢？我们考虑设 $A_{11}=x_1+y_1$（这个 $x_1$ 可以为任意整数），我们令新的 $x_i\leftarrow x_i+(-1)^{i}y_1$，再令新的 $y_i\leftarrow y_i+(-1)^ix_1$，不难发现经过这样的转化之后，$A_{i,j}$ 由原来的 $A'_{i,j}+(-1)^{j+1}x_i+(-1)^{i+1}y_j$ 变为 $A'_{i,j}+(-1)^{j+1}(x_i+(-1)^iy_1)+(-1)^{i+1}(y_j+(-1)^jx_1)=A'_{i,j}+(-1)^{j+1}x_i+(-1)^{i+1}y_j+(-1)^{i+j+1}(x_1+y_1)$（注：该式子中的 $x_i,y_i$ 为原来的 $x_i,y_i$，下同）刚好就是新的 $A_{i,j}$，但是这样第一行第一列的值就不对了，此时考虑再令 $A_{i1}=x_i+(-1)^{i+1}y_1$，$A_{1i}=y_i+(-1)^{i+1}x_1$，这样新的 $A_{1i}=x_i+(-1)^{i}y_1+(-1)^{i+1}y_1$ 刚好就是原来的 $x_i$，$A_{i1}$ 也同理。因此新的 $A_{i,j}=A'_{i,j}+(-1)^{j+1}x_i+(-1)^{i+1}y_j$，就不用考虑 $i,j$ 是否为 $1$，显然一组 $x,y$ 对应一个生成 $B$ 的矩阵 $A$，而一个对于 $A$ 又存在合法的 $x,y$，因此我们只用求出合法的 $x_i,y_j$ 即可构造出符合要求的 $A$

我们考虑 $A_{i,j}$ 非负这个条件的具体作用，由于涉及 $(-1)^i$ 这种形式的东西，因此按 $i,j$ 的奇偶性分类讨论：

- $i$ 为奇数，$j$ 为奇数，$0\le x_i+y_j+A'_{i,j}\le 10^6$
- $i$ 为奇数，$j$ 为偶数，$0\le -x_i+y_j+A'_{i,j}\le 10^6$
- $i$ 为偶数，$j$ 为奇数，$0\le x_i-y_j+A'_{i,j}\le 10^6$
- $i$ 为偶数，$j$ 为偶数，$0\le -x_i-y_j+A'_{i,j}\le 10^6$

中间两个都可通过某种方式转化为差分约束的标准形式，关键是前两个怎么处理，其实也比较 simple，我们令 $x'_i=(-1)^{i+1}x_i,y'_i=(-1)^iy_i$，那么上面四种情况又可写作：

- $i$ 为奇数，$j$ 为奇数，$0\le x'_i-y'_j+A'_{i,j}\le 10^6$
- $i$ 为奇数，$j$ 为偶数，$0\le -x'_i+y'_j+A'_{i,j}\le 10^6$
- $i$ 为偶数，$j$ 为奇数，$0\le -x'_i+y'_j+A'_{i,j}\le 10^6$
- $i$ 为偶数，$j$ 为偶数，$0\le x'_i-y'_j+A'_{i,j}\le 10^6$

这下四个式子都可以转化为差分约束的形式了，直接差分约束建出图来判个负环即可。

时间复杂度 $Tn^3$

这里有一个小小的细节以前一直没有注意过，这里稍微提一下，就是判负环过程中的“松弛次数”只要 $dis$ 值被更新了就行，不一定指“入队次数”，这样常数会小一些，否则对于 `NO` 的数据可能要跑很久，我一直为此 TLE 50，交了 $114514191981019260817998244353$ 发（bushi）

代码异常好写：

```cpp
const int MAXN=300;
const int MAXV=600;
const int MAXE=300*300*2;
int n,m,a[MAXN+5][MAXN+5],b[MAXN+5][MAXN+5];
int hd[MAXV+5],to[MAXE+5],nxt[MAXE+5],val[MAXE+5],ec=0;
void adde(int u,int v,int w){to[++ec]=v;val[ec]=w;nxt[ec]=hd[u];hd[u]=ec;}
bool inq[MAXV+5];ll dis[MAXV+5];int in[MAXV+5];
void clear(){
	memset(b,0,sizeof(b));
	memset(hd,0,sizeof(hd));ec=0;
	memset(in,0,sizeof(in));
	memset(dis,0,sizeof(dis));
	memset(inq,0,sizeof(inq));//注意清空 inq 数组，因为有可能出现判到负环就 return 的清空，所以最后 inq[i] 不一定是 0
}
void solve(){
	scanf("%d%d",&n,&m);clear();
	for(int i=1;i<n;i++) for(int j=1;j<m;j++) scanf("%d",&a[i][j]);
	for(int i=2;i<=n;i++) for(int j=2;j<=m;j++) b[i][j]=a[i-1][j-1]-b[i-1][j]-b[i][j-1]-b[i-1][j-1];
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		if(~(i+j)&1) adde(i,j+n,b[i][j]),adde(j+n,i,1e6-b[i][j]);//x[i]-y[j]
		else adde(j+n,i,b[i][j]),adde(i,j+n,1e6-b[i][j]);//y[j]-x[i] 
	} queue<int> q;
	for(int i=1;i<=n+m;i++) q.push(i),inq[i]=1;
	while(!q.empty()){
		int x=q.front();q.pop();inq[x]=0;
		for(int e=hd[x];e;e=nxt[e]){
			int y=to[e],z=val[e];
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;
				if(++in[y]>n+m) return puts("NO"),void();//这边稍微注意下，不一定要写到下面一个 if 中
				if(!inq[y]) q.push(y),inq[y]=1;
			}
		}
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		if(~(i+j)&1) b[i][j]+=dis[i]-dis[j+n];
		else b[i][j]+=dis[j+n]-dis[i]; 
	} printf("YES\n");
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) printf("%d%c",b[i][j]," \n"[j==m]);
}
int main(){int qu;scanf("%d",&qu);while(qu--) solve();return 0;}
```



---


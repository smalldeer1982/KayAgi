# [省选联考 2021 A/B 卷] 滚榜

## 题目描述

封榜是 ICPC 系列竞赛中的一个特色机制。ICPC 竞赛是实时反馈提交结果的程序设计竞赛，参赛选手与场外观众可以通过排行榜实时查看每个参赛队伍的过题数与排名。竞赛的最后一小时会进行“封榜”，即排行榜上将隐藏最后一小时内的提交的结果。赛后通过滚榜环节将最后一小时的结果（即每只队伍最后一小时的过题数）公布。

Alice 围观了一场 ICPC 竞赛的滚榜环节。本次竞赛共有 $n$ 支队伍参赛，队伍从 $1 \sim n$ 编号，$i$ 号队伍在封榜前通过的题数为 $a_i$。排行榜上队伍按照过题数从大到小进行排名，若两支队伍过题数相同，则编号小的队伍排名靠前。

滚榜时主办方以 $b_i$ 不降的顺序依次公布了每支队伍在封榜后的过题数 $b_i$（最终该队伍总过题数为 $a_i + b_i$），并且每公布一支队伍的结果，排行榜上就会实时更新排名。Alice 并不记得队伍被公布的顺序，也不记得最终排行榜上的排名情况，只记得每次公布后，本次被公布结果的队伍都成为了新排行榜上的第一名，以及所有队伍在封榜后一共通过了 $m$ 道题（即 $\sum_{i = 1}^{n} b_i = m$）。

现在 Alice 想请你帮她算算，最终排行榜上队伍的排名情况可能有多少种。

## 说明/提示

**【样例 #1 解释】**

1. 最终排名：$1, 3, 2$，滚榜情况（按公布顺序，下同）：$b_2 = 0$，$b_3 = 2$，$b_1 = 4$。

2. 最终排名：$2, 1, 3$，滚榜情况：$b_3 = 2$，$b_1 = 2$，$b_2 = 2$。

3. 最终排名：$2, 3, 1$，滚榜情况：$b_1 = 1$，$b_3 = 2$，$b_2 = 3$。

4. 最终排名：$3, 1, 2$，滚榜情况：$b_2 = 0$，$b_1 = 2$，$b_3 = 4$。

5. 最终排名：$3, 2, 1$，滚榜情况：$b_1 = 1$，$b_2 = 1$，$b_3 = 4$。

---

**【数据范围】**

对于所有测试数据：$1 \le n \le 13$，$1 \le m \le 500$，$0 \le a_i \le {10}^4$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 2$ | $2$ | $10$ |
| $3 \sim 5$ | $3$ | $10$ |
| $6 \sim 8$ | $8$ | $100$ |
| $9 \sim 12$ | $10$ | $200$ |
| $13 \sim 16$ | $12$ | $300$ |
| $17 \sim 20$ | $13$ | $500$ |

## 样例 #1

### 输入

```
3 6
1 2 1
```

### 输出

```
5
```

## 样例 #2

### 输入

```
6 50
4 7 9 3 0 3
```

### 输出

```
96```

## 样例 #3

### 输入

```
11 300
6 8 8 12 0 11 6 1 0 15 5
```

### 输出

```
30140983
```

# 题解

## 作者：白鲟 (赞：49)

## 前言
纪念一下这场爆炸的省选唯一 AC 的题目。

同时是第一次在正式考场上 AC 动态规划。

同时是第一次在正式考场上 CE（还是本应 AC 的 Day1 T1）。

大概是本场第三简单的题。

应该比去年 Day2 T1 简单。

## 分析
看了一眼范围估计是状压。

开始分析的时候容易想到设计状态为 $f(S,i,j,k)$，即前 $|S|$ 位为 $S$ 内元素、第 $|S|$ 位为 $i$、已选 $b_i$ 总和为 $j$、上一个 $b_i$ 为 $k$ 的方案总数，但始终甩不掉枚举 $b_i$ 的和与上一个 $b_i$ 的值的 $m^2$ 循环。

冷静看题。发现只用求排名的总方案数，而与 $b_i$ 分配方式无关。可以得到的启发是寻找 $b_i$ 的最佳分配方式。

对于某一确定的排列方式 $a_1,a_2,\cdots,a_n$，贪心地分配使得每个位置的 $b_i$ 尽量小的方式易得：若当前的 $a_i$ 大于 $a_{i-1}$，为了维护 $b_i$ 不降，使得 $b_i=b_{i-1}$，否则 $b_i=b_{i-1}+a_{i-1}-a_i$。

根据这一结论，直接使用全排列可以获得 60 pts 的好成绩。

回到状压。考虑对贡献进行简单变形：$\sum{b_i}=\sum{\max(a_{i-1}-a_i,0)}(n-i+1)$，如此可以甩掉枚举上一个 $b_i$ 的值这一步。设 $f(S,i,j)$ 表示前 $|S|$ 位为 $S$ 内元素、第 $|S|$ 位为 $i$、已选总贡献为 $j$ 的方案总数，在枚举状态的同时枚举下一个选的数，容易写出方程式。

最后统计 $f(U,i,j)$ 的和即可。

时间复杂度为 $\operatorname{O}(2^nn^2m)$。可通过使用 $\operatorname{lowbit}$ 枚举元素等方式略微卡常。

上述方法忽略的细节是相等时的按编号排序，实现时应注意。

## 代码
**upd on 2021.4.24**

根据 UOJ 数据修复了代码实现的一点小问题，目前在 UOJ 上可通过。
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
const int maxn=13,maxm=500;
int n,m,all,t,a[maxn+1],no[1<<maxn|1];
long long f[1<<maxn|1][maxn+1][maxm+1],ans;
inline int lowbit(int x)
{
	return x&(-x);
}
int main()
{
	scanf("%d%d",&n,&m);
	all=(1<<n)-1;
	a[0]=-1;
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);
		if(a[i]>a[t])
			t=i;
		no[1<<(i-1)]=i;
	}
	for(int i=1;i<=n;++i)
	{
		int target=n*(a[t]-a[i]+(t<i));
		if(target<=m)
			f[1<<(i-1)][i][target]=1;
	}
	for(int i=1;i<all;++i)
	{
		int popcount=0;
		for(int j=1;j<=maxn;++j)
			if(i&(1<<(j-1)))
				++popcount;
		for(int t=i;t;t-=lowbit(t))
			for(int sum=0;sum<=m;++sum)
			{
				int pos=no[lowbit(t)];
				for(int j=1;j<=n;++j)
					if(!(i&(1<<(j-1))))
					{
						int target=sum+(n-popcount)*max(0,(pos<j)+a[pos]-a[j]);
						if(target<=m)
							f[i|(1<<(j-1))][j][target]+=f[i][pos][sum];
					}
			}
	}
	for(int i=0;i<=m;++i)
		for(int j=1;j<=n;++j)
			ans+=f[all][j][i];
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：25)

哎，考场上面连题都没有读懂，基本上把这次省选葬了。

主要是讲思考的思路。

考虑到数据范围很小，$n \leq 13$，不难想到状压 dp。

进行状态设计。

既然是状压不可能没有 $O(2^n)$ 一维。

因为我们 $b_i$ 的决定会和上一个人有关，显然储存上一个人是谁这一维无可避免，$O(n)$。

剩下的一个比较好想的做法是，保存上一个人的 $b_i$ 是多少，已经当前已经多用了多少题。这样有两个 $O(m)$ 级别的信息。

暴力即为暴力转移，时间复杂度 $O(2^nn^2m^2)$ 或者 $O(2^nnm^2)$，空间复杂度 $O(2^nnm^2)$。

注意到我们统计的是排名的方案数，跟具体的 $b_i$ 是无关的，也就是说，保存上一个人的 $b_i$ 是无效信息。

考虑将这一维删去，也就是说我们需要通过一些操作使得这一维的信息能够被表示或者忽略。

被表示估计不太行。注意到 $b$ 序列单调不降，考虑差分，将新数列记为 $\Delta$。因为 $b$ 序列单调不降，所以 $\forall i \in [1,n],\Delta_i \geq 0$。

注意到 $\Delta_i$ 会使得所有 $j \geq i$ 的 $b_j$ 增加 $\Delta_i$。考虑每次加入 $\Delta_i$ 的时候把后面的影响一并处理。

具体想法是，我们将 $i$ 滚榜的时候，不用知道上一个的 $b$ 到底是多少也能满足 $b$ 不降。那么我们每次在处理的时候每次加入 $\Delta_i$，后面的所有 $b$ 也同时加上 $\Delta_i$。这样我们就相当于枚举差分值，显然是可以满足 $b$ 单调不降的条件的。只需要考虑单纯的，不考虑 $b_i$ 的从 $u$ 转移到 $v$ 的最少的题数了。

也许这个东西叫做费用提前计算？

考虑实现，预处理一个数组 $c_{i,j}$ 表示上一个是 $i$，这次滚榜到 $j$ 需要的最小的 $b_i$。至于不用考虑上一个 $i$ 加上的 $b_i$ 的原因因为我们在上面的做法中规避了这个问题，不理解还可以返回去看。代码写起来就很简单了。


```cpp
#include<bits/stdc++.h>
using namespace std;
int lowbit(int x){return x&(-x);}
int popcount(int x){int ans=0;while(x)	x-=lowbit(x),++ans;return ans;}
int dp[(1<<13)+5][14][505],n,m,a[14],c[14][14];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)	scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)	for(int j=1;j<=n;++j)	c[i][j]=max(0,a[i]-a[j]+int(i<j)),c[0][j]=max(c[0][j],c[i][j]);
	dp[0][0][0]=1;
	for(int S=0;S<(1<<n);++S)
	{
		if(S==lowbit(S))
		{
			int pos=0;
			for(int i=1;i<=n;++i)	if((S>>(i-1))&1 && (pos=i))	break;
			if(n*c[0][pos]<=m)	dp[S][pos][n*c[0][pos]]=1;
		}
		else
		{
			for(int i=1;i<=n;++i)
			{
				if((S>>(i-1))&1)
				{
					int T=S^(1<<(i-1));
					int v=i;
					for(int j=1;j<=n;++j)
					{
						if((T>>(j-1))&1)
						{
							int u=j;
							int pct=n-popcount(T);
							for(int k=c[u][v]*pct;k<=m;++k)	dp[S][v][k]+=dp[T][u][k-c[u][v]*pct];
						}
					}
				}
			}
		}
	}
	long long ans=0;
	for(int i=1;i<=n;++i)	for(int j=1;j<=m;++j)	ans+=dp[(1<<n)-1][i][j];
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：gyh20 (赞：18)

来一个 naive 的做法。

首先考虑 $n!$ 级别的做法，考虑枚举一种排列，然后检验是否合法。

具体的，我们发现，如果 $m$ 道题没有分完，可以直接分给最后一个人，也就是说，我们可以依次贪心的给每个人最少的题，使得比其他所有人都高，时间复杂度 $O(n!\times n)$ 。

我们发现，除了第一个人以外，其他所有人只要满足比前一个人高即可，第一个人要比其他所有人都高，于是可以做到 $O(n!)$，但似乎区别不大。

我们发现，$m$ 很小，除 $1$ 外 $b_i$ 只与且最终的 $b_{i-1}$ 和 $a_{i-1}$ 有关，排列中 $b_i=max(b_{i-1},a_{i-1}+b_{i-1}-a_i)$，换句话说，每当 $b_{i-1}$ 增加 $1$，$b_i$ 一定增加 $1$。

这提示我们，可以直接上 Meet-in-Middle，枚举后一半，再枚举前一半合并，假设前一半的最后一个 $b$ 是 $x$，相当于后面所有数的 $b$ 都要加上 $x$。

暴力前缀和的总复杂度是 $O(A_{n}^{(n+1)/2}\times n+2^n\times n\times m)$。

如果你用树状数组维护前缀和可以做到 $O(A_{n}^{(n+1)/2}\times n\times \log m)$，在这道题不优。~~但 $m$ 可以出的更大~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int t=0;char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return t;
}
int n,p[15],a[15],m,b[15],LMT,f[8195][15][502];
bool v[15];
long long ans;
void dfs(int x,int y){
	if(x==LMT+1){
		int zt=0;
		for(int i=1;i<x;++i)zt|=(1<<p[i]-1);
		++f[zt][p[1]][y];
		return;
	}
	int mx=-1;
	for(int i=1;i<=n;++i)
		if(!v[i]){
			int dlt=a[p[x-1]]+b[x-1]-a[i];
			if(p[x-1]<i)++dlt;
			mx=max(mx,a[i]);
			if(dlt<b[x-1])dlt=b[x-1];
			if(y+dlt>m)continue;
			b[x]=dlt,p[x]=i,v[i]=1,dfs(x+1,y+dlt),v[i]=0;
		}
}
void dfs1(int x,int y){
	if(x==LMT+1){
		int zt=0,B=(1<<n)-1;
		for(int i=1;i<x;++i)zt|=(1<<p[i]-1);
		B^=zt;
		for(int i=1;i<=n;++i)
			if(B&(1<<(i-1))){
				int dlt=a[p[x-1]]+b[x-1]-a[i];
				if(p[x-1]<i)++dlt;
				if(dlt<b[x-1])dlt=b[x-1];
				dlt=max(dlt,0);
				int ss=dlt*(n-LMT)+y;
				if(ss<=m)ans+=f[B][i][m-ss];
			}
		return;
	}
	int mx=-1;
	for(int i=1;i<=n;++i)
		if(!v[i]){
			int dlt=a[p[x-1]]+b[x-1]-a[i];
			if(p[x-1]<i)++dlt;
			if(x==1){dlt=max(dlt,mx-a[i]+1);for(int j=i+1;j<=n;++j)if(!v[j])dlt=max(dlt,a[j]-a[i]);}
			mx=max(mx,a[i]);
			if(dlt<b[x-1])dlt=b[x-1];
			if(y+dlt>m)continue;
			b[x]=dlt,p[x]=i,v[i]=1,dfs1(x+1,y+dlt),v[i]=0;
		}
}
int main(){
	n=read(),m=read(),a[0]=-1e9;
	for(int i=1;i<=n;++i)a[i]=read(),p[i]=i;
	LMT=n>>1;
	dfs(1,0);
	for(int i=0;i<(1<<n);++i)for(int j=1;j<=n;++j)for(int k=1;k<=m;++k)f[i][j][k]+=f[i][j][k-1];
	LMT=(n+1)>>1;
	dfs1(1,0);
	printf("%lld",ans);
}
```


---

## 作者：jia_shengyuan (赞：17)

## 前言
假期做这道题，看了好几篇题解都看不懂，最后还是把一堆题解结合起来才明白的，所以打算结合各个题解与自己的理解写一篇比详细的（其实还是自己太菜了）
## 题解
首先这道题不难看出来是状压，就尝试一下设 $S$ 为已经滚榜队伍的集合，$t$ 为上一个队伍，$j$ 上一个 $b_i$，$k$ 为已选 $b_i$ 总和，那么我们只需要枚举这这几个值就行了，比较好想，就不过多赘述了。

但问题就在于，枚举 $S$ 要 $O(2^n)$，上一队伍要 $O(n)$，$k,j$ 各需要 $O(m)$，乘起来 $O(2^nnm^2)$。且不说时间，空间都炸了，所以肯定得考虑降维。

我们发现题目只关心最终队伍的排名，而不关心每个队伍最后一小时过了多少题。换句话说，对于任何一个队伍排列方式，只要存在一种 $b_i$ 的分配方式，使得这种队伍排列能够出现，那么无论是否还存在更多的方式分配 $b_i$，这种排列都会且仅会对最终答案产生 $1$ 的贡献。

因此，我们可以考虑寻找一种最优的 $b_i$ 分配方式（也就是说，如果某一队伍排列在这种方式下都不合法，那么其他方式也一定不合法）

按照题意，$b_i$ 不下降，因此最优分配方式就是让所有的 $b_i$ 尽量小，最后多出去的题全给最后一个滚榜的队伍。不难发现，对于一个排列 $a_1,a_2,\cdots,a_n$，如果 $a_{i-1}<a_i$，那么 $b_i=b_{i-1}$ 是 $b_i$ 的最小值（因为不下降），否则要让 $a_i+b_i=a_{i-1}+b_{i-1}$，移项得到 $b_i=a_{i-1}-a_i+b_{i-1}$（注意，如果 $a_i$ 队伍编号比 $a_{i-1}$ 大，那么这个 $b_i$ 还要加一）

为了删去 $j$ 这一维，我们可以考虑差分，用 $\Delta[i,j]$ 表示上一个队伍是 $i$，下一个队伍是 $j$ 时，$b_j$ 比 $b_i$ 大多少，也就是 $b_j-b_i$。代入上面一段的公式，当 $a_i<a_j,b_j-b_i=0$；否则 $b_j-b_i=a_i-a_j$。综上可得 $\Delta[i,j]=\max(0,a_i-a_j)$。

那么，求出这个差分有什么用呢？我们发现某一次滚榜所消耗的 $b_i$ 值为其之前所有 $\Delta$ 之和，因此对于第 $i$ 个滚榜的队伍，该次滚榜的 $\Delta$ 会在整个滚榜过程中被计算 $n-i+1$ 次。有个这个结论，我们就可以在每一次转移时提前计算本次滚榜对 $m$ 的消耗，进而删去原本 $j$ 这一维。

所以，我们可以用 $dp[S,i,j]$ 表示已滚榜队伍集合为 $S$，上一个滚榜队伍为 $i$，已经被消耗的 $m$ 为 $j$ 时的情况数，时间复杂度 $O(2^nn^2m)$。

这道题个人感觉下标从 $0$ 开始比较方便，代码还是比较好写的，能注释的地方都注释了。

```cpp
#include <iostream>

using namespace std;

int dp[1 << 13 | 9][15][509], delta[15][15];
int first[15], score[15], n, m; // first[i] 表示第一个队伍是 i 时的 delta
int maxind = 0; // 代表 a 最大的队伍，为了计算 first[]

inline int lowbit(int n) {
    return n & (-n);
}
inline int count1(int n) { // 统计 res 中有几个 1
    int res = 0;
    while (n) {
        n -= lowbit(n);
        res++;
    }
    return res;
}

inline void Read() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> score[i];
        if (score[i] > score[maxind]) maxind = i;
    }
}
inline void CalcDelta() {
    // 过题数相同时下标小的排名靠前，所以下标大的超过下标小的，得额外+1
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            delta[i][j] = max(0, score[i] - score[j] + (j > i));
        }
    }
    for (int i = 0; i < n; i++) {
        first[i] = score[maxind] - score[i] + (i > maxind);
    }
}

inline void Dp() {

    dp[0][0][0] = 1;
    for (int S = 1; S < (1 << n); S++) {
		
        if (S == lowbit(S)) { // S 中仅有一个元素
            for (int cur = 0; cur < n; cur++) {
                if (S & (1 << cur) && n * first[cur] <= m) {
                    dp[S][cur][n * first[cur]] = 1;
                }
            }
            continue;
        }

        for (int cur = 0; cur < n; cur++) { // 枚举当前滚榜队伍

            if (!(S & (1 << cur))) continue;
            int lastS = S ^ (1 << cur); // 上一个 S
            int mul = n - count1(lastS); // 当前 delta 需要乘几倍

            for (int last = 0; last < n; last++) { // 枚举上一队伍
                if (lastS & (1 << last)) {
                    // 枚举用了多少题
                    for (int usedB = mul * delta[last][cur]; usedB <= m; usedB++) {
                        dp[S][cur][usedB] += dp[lastS][last][usedB - mul * delta[last][cur]];
                    }
                }
            }
        }
        
    }
}

long long CalcAns() { // 13 个队伍全排列可能爆 int
    long long ans = 0;
    int S = (1 << n) - 1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= m; j++) {
            ans += dp[S][i][j];
        }
    }
    return ans;
}

int main() {
    Read();
    CalcDelta();
    Dp();
    cout << CalcAns();
    return 0;
}
```


---

## 作者：Warriors_Cat (赞：16)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7519)。

题意：

* 给定 $n, m$ 和 $n$ 个数 $a_i$。
* $a_i$ 依次加上正整数 $b_i$，使得每次加上后此数都是所有数的最大值，且 $\sum\limits_{i=1}^nb_i = m$。
* 求 $b_i$ 有多少种分配方案。$n \le 13$，$m \le 500$。

应该是这场省选一道偏中上难度的题吧。

---

### Solution：

看到 $n \le 13$ 就考虑状压，于是随便想想就可以列出如下的状态定义：$f_{S, i, j, k}$ 表示考虑 $S$ 集合，上一个人是 $i$，现在 $\sum b_i$ 已经用了 $j$，上一个 $b_i$ 为 $k$ 的方案数，直接暴力转移即可，时间复杂度为 $O(2^nn^2m^2)$。

恭喜你，跑得比阶乘暴力还慢。

那么我们就要考虑省掉一个维的转移。注意到我们要求的是分配方式的方案数，而不是 $b_i$ 的分配。因此我们可以考虑在最优情况下是该怎么分配的。

很显然，对于每一个值 $a_i$，它变成最大数的最少代价为 $\sum\limits_{j=1}^n\max\{0, a_j - a_i + [j < i]\}$。我们可以在 $O(n^2)$ 的时间内预处理这所有值。不妨记 $j$ 要超过 $i$ 的代价为 $d_{i, j}$。

再注意到 $b_i$ 是单调不降的，那么可以考虑差分，记差分数组为 $c$，那么就有：

$$m = \sum_{i=1}^nb_i=\sum_{i=1}^nc_i(n - i + 1)$$

我们发现如果 $a_i$ 要变成最大值，那么 $c_i$ 的最小值就是刚才我们预处理的那个东西。

那这就很简单了，我们定义 $f_{S, i, j}$ 表示考虑 $S$ 集合，上一个人是 $i$，现在 $\sum b_i$ 已经用了 $j$，注意这里我们已经不需要记录上一个的 $b_i$ 是多少了。每次我们枚举一个集合 $S$，然后枚举上一个人 $i$，记去掉元素 $i$ 的子集合 $A$，枚举 $A$ 中的元素 $j$，那么就有转移：

$$\forall k \in [d_{i, j}\times (n - |A|), m], f_{S, i, k} \gets f_{S, i, k} + f_{A, j, k - d_{i, j}\times (n - |A|)}$$

最后统计答案直接把所有情况加起来就行了。

over，时间复杂度为 $O(2^nn^2m)$。

---

### Code：

代码量很短，很令人舒适。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define rep(i, x, y) for(int i = x; i <= y; ++i)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 14;
int n, m, k, a[N], d[N][N], s[N], f[1 << N][N][510], pcnt[1 << N]; long long ans;
int main(){
	n = read(); m = read(); rep(i, 1, n) a[i] = read();
	rep(i, 1, n) rep(j, 1, n){
		if(i < j) d[i][j] = max(0, a[i] - a[j] + 1);
		else d[i][j] = max(0, a[i] - a[j]);
	}
	rep(j, 1, n) rep(i, 1, n) s[j] = max(s[j], d[i][j]);
	k = (1 << n) - 1;
	rep(i, 1, k) pcnt[i] = pcnt[i >> 1] + (i & 1);
	rep(i, 1, n) if(n * s[i] <= m) f[1 << i - 1][i][n * s[i]] = 1;
	rep(S, 0, k){
		rep(i, 1, n) if(S >> i - 1 & 1){
			int A = S ^ (1 << i - 1), num = n - pcnt[A];
			rep(j, 1, n) if(i != j && (S >> j - 1 & 1)){
				rep(t, d[j][i] * num, m) f[S][i][t] += f[A][j][t - d[j][i] * num]; 
			}
		}
	}
	rep(i, 1, n) rep(j, 1, m) ans += f[k][i][j]; printf("%lld\n", ans);
}
```

---

## 作者：whiteqwq (赞：9)

[P7519 [省选联考 2021 A/B 卷] 滚榜](https://www.luogu.com.cn/problem/P7519)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1791154)

## 题意

给定$n$支队伍，每支队伍有权值$a_i$。给定$m$，将$m$分成若干个数之和，按不降顺序分配给$n$个队伍，已知每次分配都会让分配给的队伍权值变为最大（权值相同比较编号大小，小的优先），求分配方案数。

$1\leqslant n\leqslant 13,1\leqslant m\leqslant 500$

## 分析

很简单的状压dp+费用提前，但考场降智了，没想到。

设$f_{i,j,k}$为当前分配完的队伍集合为$i$，上一个分配的队伍为$j$，一共消耗的权值大小为$k$的方案数，可是由于分配权值的顺序必须不降，所以还得带上另一个参数来表示上一次分配的权值，可是这样就是$O(2^nn^2m^2)$的了，比阶乘还劣。

考虑表示出或消除这个参数，根据上面的定义表示出这个参数比较难，因此我们想一想如何将这个参数的费用消除掉。

我们先想一想当我们确定了分配顺序应该怎么判断：我们按照顺序给每个队伍分配最少的权值，最后如果分配失败就说明方案失败，否则可以直接把所有剩下权值分配给最后一个队伍。

我们考虑剩下的权值不分配给最后一个队伍的情况，这时可以对于一个队伍后缀增加一个不递减的权值序列，而对这个序列差分后可以知道这个权值序列可以分成若干次给某个后缀加上相同的权值。

这提醒了我们使用费用提前，$f_{0,0,0}$转移到$f_{i,j,k}$（其中$i$集合仅含$j$）时，不难发现需要给$j$队伍增加权值$a_p-a_j+[p<j]$（设一开始权值最大的队伍为$p$），而根据上面的思考可以知道这个权值在以后每个队伍都需要进行分配，那么我们直接将权值乘$n$，提前计算费用即可。

同理，对$f_{i,j,k}$转移到$f_{i',j',k'}$，我们对于当前队伍需要增加$a_j-a_{j'}+[j<j']$的权值，我们将权值乘$|i|$就可以消除后续的贡献。

时间复杂度：$O(2^nn^2m)$，用$\text{lowbit}$来枚举可以卡卡常。

## 代码
```
#include<stdio.h>
#define lowbit(x) x&-x
const int maxn=13,maxm=505,maxk=(1<<maxn);
int n,m,k,maxx,maxp;
int a[maxn+1],tot[maxk],p[maxk];
long long ans;
long long f[maxk][maxn+1][maxm];
inline int max(int a ,int b){
	return a>b? a:b;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]),p[1<<(i-1)]=i;
		if(a[i]>maxx)
			maxx=a[i],maxp=i;
	}
	k=(1<<n)-1,tot[0]=0;
	for(int i=1;i<=k;i++)
		tot[i]=tot[i>>1]+(i&1);
	for(int i=1;i<=n;i++){
		int cost=n*(maxx-a[i]+(maxp<i));
		if(cost<=m)
			f[1<<(i-1)][i][cost]=1;
	}
	for(int i=1;i<k;i++)
		for(int j=i;j;j-=lowbit(j))
			for(int s=0;s<=m;s++){
				int v=lowbit(j),now=p[v];
				if(f[i][now][s]==0)
					continue;
				for(int t=1;t<=n;t++)
					if(((i>>(t-1))&1)==0){
						int cost=s+(n-tot[i])*max(a[now]-a[t]+(now<t),0);
						if(cost<=m)
							f[i|(1<<(t-1))][t][cost]+=f[i][now][s];
					}
			}
	for(int i=0;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans+=f[k][i][j];
	printf("%lld\n",ans);
	return 0;
}
```

省选联考A卷全部题解可见：[2021省选联考A卷解题报告](https://zybuluo.com/xiaoziyao/note/1791034)

---

## 作者：zzw4257 (赞：7)

首先$\mathcal{O(n!)}$的暴力是朴素的，我们只需在定$p_i$情况下让$b_{p_i}=\max\{[p_i>p_{i-1}],a_{p_i}-a_{p_{i-1}}\}+b_{p_{i-1}}$即可

我们会发现若设$\Delta_{i}=\max\{[p_i>p_{i-1}],a_{p_i}-a_{p_{i-1}}\}$,那么$b_{p_i}$其实是$\Delta$的前缀和，换句话说$\Delta_i$其实在最后求和中贡献了$n-i$次

考虑状压这个过程，设$f_{S,i,j}$表示值域集合为$S$,$p_{|S|}=i$,$\displaystyle \sum_{i=1}^{|S|} \Delta_i(|S|-i) =j$

则可以简单的枚举$p_{|S|+1}=k$转移了

```cpp
#include<bits/stdc++.h>
#define N 15
#define U 1<<13
#define max(a,b) ((b)<(a)?(a):(b))
using namespace std;
typedef long long ll;
int n,m,mx,p[N],a[N],lg[U],pw[U],sz[U];
ll ans,f[U][N][501],*g;
int main(void){
	int i,j,k,S,x,y,t;ll v;scanf("%d%d",&n,&m);for(i=1;i<=n;++i)lg[pw[i]=1<<(i-1)]=i,scanf("%d",a+i),mx=max(mx,a[i]),pw[i]=(1<<(i-1));
	for(i=1;i<1<<n;++i)sz[i]=sz[i^(i&-i)]+1;
	for(i=1;i<=n;++i)m-=mx-a[i];
	for(i=1;i<=n;++i)if(a[i]==mx)break;
	f[0][i][m]=1;
	for(S=0;S<1<<n;++S){
		for(x=(!S?(1<<n)-1:S);x&&(i=lg[x&-x]);x-=x&-x){
				for(y=((1<<n)-1)^S;y&&(k=lg[y&-y]);y-=y&-y){
					t=max((k>i),a[k]-a[i])*(n-sz[S]);
					g=f[S|pw[k]][k];
					for(j=t;j<=m;++j)if((v=f[S][i][j]))g[j-t]+=v;
				}
		}
	}
	for(i=1;i<=n;++i)for(j=0;j<=m;++j)ans+=f[(1<<n)-1][i][j];printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：huangzirui (赞：5)

对于一种排名情况 $t_1 \dots t_n$ ，考虑 $b_{a_i}$ 的取值。

由题，要满足：

$b_{t_i}>\max(b_{t_{i-1}},b_{t_{i-1}}+a_{t_{i-1}}-a_{t_{i}}+[t_{i-1}<t_{i}])$

显然， $\forall i\not = n\ \ ,\ b_i$ 最小是最优的。（只要把多余出来的 $m$ 放到最后的 $b$ 里面）

于是，令 $b_{t_i}=\max(b_{t_{i-1}},b_{t_{i-1}}+a_{t_{i-1}}-a_{t_{i}}+[t_{i-1}<t_{i}])$

这时就可以直接状压了。就是设 $dp_{i,j,k,h}$ 为 $t_i=j$ ， $b_{i}=k$ 且 $\sum_{x=1}^ib_x=h$ ，于是可以直接枚举 $t_{i+1}$ 来转移，复杂度 $O(n^2m^22^n)$ 。

显然有可以优化的地方，套路的，考虑：

$b_{t_i}=\max(b_{t_{i-1}},b_{t_{i-1}}+a_{t_{i-1}}-a_{t_{i}}+[t_{i-1}<t_{i}])$

$b_{t_i}=b_{t_{i-1}}+\max(0,a_{t_{i-1}}-a_{t_{i}}+[t_{i-1}<t_{i}])$

于是转移时就可以节省掉一维 $b$。

复杂度 $O(n^2m2^n)$ ，可以通过此题。

---

## 作者：Acetyl (赞：3)

首先，假设我们已经确定了所有人的排名，考虑如何检查这个排名是否合法。很显然，题目中 “总共过了 $m$ 题” 的限制可以改成 “总共过了至多 $m$ 题”，因为如果过的题目数量不足 $m$ 题，可以将剩下的题目全部归给第一名，这样排名不会发生变化。

按名次从低到高考虑每一个人。由于这题要求所有人在最后一小时过的题目数量按照名次从低到高依次递增，所以不妨考虑对于一个人，如果这个人最后一小时过了 $x$ 题，则对名次比它高的人也加上 $x$ 题，这样，后面的所有人做出题目的相对数量都不会发生变化，每一次的变化量也就不受限制了。而对于当前这个人，我们会让他最后一小时过的题目数量尽可能少，即，如果这个人过的题目数量本来就比它前面一个人多，那么就不用更改这个人做的题目数量，否则就需要把这个人过的题目数量加到和上一个人一样多，同时如果这个人编号比上一个人大，还需要再多加一道题。这样，到最后，如果总共加的题目数量小于等于 $m$，则合法。如果这个人是第一个人，则根据题目要求，也要把这个人按照上面的方式垫成当前榜上的第一名。

现在考虑如何计数。设 $f(mask, i, j)$ 表示考虑到 $mask$ 集合中的人，目前名次最高的人是 $i$，已经给所有人加了 $j$ 道题，有多少种合法的排名。转移的时候，枚举下一个人是谁，然后按照上面的方式进行转移即可。时间复杂度 $\mathcal O(2^n n^2 m)$，适当优化 dp 即可通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define all(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#define loop(i, a) for (int i = 0; i < (a); ++i)
#define cont(i, a) for (int i = 1; i <= (a); ++i)
#define circ(i, a, b) for (int i = (a); i <= (b); ++i)
#define range(i, a, b, c) for (int i = (a); (c) > 0 ? (i <= (b) : i >= (b)); i += c)
#define pub push_back
#define pob pop_back
#define mak make_pair
#define mkt make_tuple
typedef long long ll;
typedef long double lf;
const int Inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3fll;

int n, m;
int a[13];
int popcnt[1 << 13];
ll dp[1 << 13][13][505];

int main() {
	freopen("ranklist.in", "r", stdin);
	freopen("ranklist.out", "w", stdout);
	scanf("%d%d", &n, &m);
	int mxa = -1, mxp = 0;
	loop(i, n) scanf("%d", a + i);
	loop(i, n) if (a[i] > mxa) {
		mxa = a[i]; mxp = i;
	}
	cont(i, (1 << n) - 1) popcnt[i] = popcnt[i & (i - 1)] + 1;
	loop(i, n) {
		int ts = 0;
		if (i != mxp) ts = mxa - a[i] + (i > mxp);
		ts *= n;
		if (ts <= m) dp[1 << i][i][ts] = 1;
	}
	loop(i, (1 << n) - 1) if (popcnt[i]) loop(j, n) if ((i >> j) & 1) {
		loop(k, m + 1) if (dp[i][j][k]) {
			loop(l, n) if (!((i >> l) & 1)) {
				int jar = 0;
				if (a[l] <= a[j]) jar = a[j] - a[l] + (l > j);
				jar = jar * (n - popcnt[i]) + k;
				if (jar > m) continue;
				dp[i | (1 << l)][l][jar] += dp[i][j][k];
			}
		}
	}
	ll sm = 0;
	loop(j, n) loop(k, m + 1) sm += dp[(1 << n) - 1][j][k];
	printf("%lld\n", sm);
	return 0;
}

```

---

## 作者：ETHANK (赞：2)

**题目大意：**

给定 $n,m$ 和长度为 $n$ 的数组 $a_i$ 。问有多少种排列 $p_n$ ，使得存在数组 $b_i$ ，满足

- $b_i$ 单调不减
- $\sum_{i=1}^n b_i=m$
- 依次对 $a_{p_i}$ 加上 $b_i$ ，满足操作后 $a_{p_i}$ 为最大元素。

数据范围：$1\le n\le 13,1\le m\le 500,0\le a_i\le 10^4$ .

> 知识储备：状态压缩，差分

> 题目难度：省选/USACO Platinum

**解析：**

*（从数据范围不难想到这是状压dp，那么如何设计状态和优化dp就是解题的关键。）*

首先想到这样的 dp ， $f_{S,i,j}$ 为前面选取的状态为 $S$ ，上一个数为 $i$ ，当前的 $\sum b_i$ 为 $j$ 。然而为了保证 $b_i$ 的单调性，我们还要加一维 $k$ 用来记录上一个 $b_i$ 的值。注意到我们要求排列的方案数，于是可以贪心取 $b_i$ 来尽量满足性质。暴力转移即可，时间复杂度为 $O(2^nn^2m^2)$ 。

~~然后你会发现这个 dp 甚至不如贪心暴力跑全排列，后者能得到 60 pts 的好成绩~~

考虑优化 dp 状态，而 $S,i,j$ 对于我们考虑转移是必须的，所以想去掉 $k$ 这一维。$b_i$ 单调不减的性质提示了差分，运用的思想和下面这道题类似。

[CF626F Group Projects](https://www.luogu.com.cn/problem/CF626F)

于是设 $d_i=b_i-b_{i-1}\ge 0$ ，有 $d_i=\max(a_{p_{i-1}}-a_{p_i},0)$ ，并且
$$
\begin{aligned}
\sum_{i=1}^n b_i &=\sum_{i=1}^n\sum_{j=1}^i d_j\\
&=\sum_{j=1}^n\sum_{i=j}^n d_j\\
&=\sum_{j=1}^n(n-j+1)d_j\\
\end{aligned}
$$
 转化后，代码实现就相对简单了。

时间复杂度：$O(2^nn^2m)$ .

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define ll long long
using namespace std;
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
const int N=14,M=505;
int n,m,a[N],c[N][N],ppc[1<<N],id[1<<N],mx;
ll ans,f[1<<N][N][M];
int main(){
    n=read(),m=read();
    rep(i,1,n){
        a[i]=read();
        if(a[i]>a[mx])mx=i;
        id[1<<(i-1)]=i;
    }
    rep(i,1,n)rep(j,1,n){
        c[i][j]=max(0,a[i]-a[j]+(i<j));//注意编号小的队伍排名靠前
    }
    rep(i,1,n){
        int sum=n*(a[mx]-a[i]+(mx<i));
        if(sum<=m)f[1<<(i-1)][i][sum]=1;
    }
    int up=(1<<n)-1;
    rep(i,1,up)ppc[i]=ppc[i>>1]+(i&1);
    rep(S,1,up){
        for(int t=S;t;t-=t&-t){
            int pos=id[t&-t];
            rep(sum,0,m)rep(i,1,n){
                if((S>>(i-1))&1)continue;
                int k=sum+(n-ppc[S])*c[pos][i];
                if(k<=m)f[S|1<<(i-1)][i][k]+=f[S][pos][sum];
            }
        }
    }
    rep(i,1,n)rep(j,0,m)ans+=f[up][i][j];
    printf("%lld\n",ans);
    return 0;
}
```



---

## 作者：Refined_heart (赞：1)

## 题目大意

已知序列 $A$ 以及序列 $B$ 的和 $m$ 要求对每一个 $a_i$ 分配一个 $b_i$ 使得每次分配完之后 $a_i+b_i$ 都是 $A$ 序列中所有数字的最大值。

每次修改完 $a_i\to a_i+b_i$.

## Solution:

看到 $n$ 的范围就会想到状压：设 $f[S,i,j,k]$ 表示已经揭榜的人的集合为 $S,$ 上一个揭榜的人是 $i,$ 他的 $b$ 是 $j$ 还剩下 $k$ 的题目数能用。复杂度是 $O(2^{n}nm^2)$

那么看到后面那两个东西很不顺眼……和 $m$ 有关的维度必须被砍掉。

观察到题面的一条重要信息： $b_i$**是单调不降的。**

那么这个东西怎么用呢？先暂且不谈，考虑一下我们维护 $b$ 的实际意义有多大。

我们维护它完全是因为后面的暴力转移需要它，它和我们最后的答案 **一点关系都没有**

那么，我们考虑一下有多少方案是一样的：对于一个固定下来的排名，分配 $b$ 的方式有很多，但是这种方案只有一个。

从这里就能看出来维护 $b$ 的冗余性质了。考虑对于一个已知的排名序列 $p,$ $b$ 的最优分配（即做到最小）就是每次尽量让 $b$ 相等。

那么每一个 $b$ 的作用无非就是让 $p_{i+1}+b_{i+1}$ 与前一项尽量接近，以此来保证我们选择的 $\sum b$ 最小。

剩下的和 $m$ 的差距都可以在最后一项补回来。

**但是值得注意的是，我们这样看似漏下很多东西，但实际上，这样分配$b$ 所丢失的仅仅只是同一个排列下不同的 $b$ 的排列方案，而这些方案数并不是我们所需要的。**

于是，我们可以思考题干中给定那个 $b$ 不降的条件有啥用了。它也恰好规约了我们在揭榜一个人以后，后面所有人揭榜的增加量都是在 $b_i$ 以上的。

考虑对 $b$ 进行差分，就是考虑我们在 $a_i$ 的时候对它加上了多少。这样，每一个差分后的值 $c_i$ 都会在后面的揭榜过程中对 $\sum b$ 贡献 $(n-i+1)c_i$ 的值。

这样我们就会发现，实际上我们已经不需要维护 $b_j$ 了。只要知道当前状态下最后来的人和 pre-state 最后进来的人，就可以根据他们的 $a_i$ 推算出最小代价了。因为我们只需要知道最小代价。

至于为什么只需要最小代价……因为我们对每一种排名序列只需要求出一个 $\sum b$ 最小的就可以了。

于是可以预处理 $cost[i][j]$ 表示将 $a_i$ 变成 $a_j$ 的最小代价。

注意一下题目中给的编号的细节。

那么，现在的方程就可以被我们转化为： $f[S][i][j]$ 表示揭榜的人状态为 $S,$ 最后一个进来的人是 $i,$ 一共用掉了 $j$ 题的方案数。

于是我们可以枚举状态，枚举 $i,pre$ 从而转移。转移复杂度 $O(2^n n^2 m)$

注意用一些技巧优化，比如 ```lowbit```

回过头来想一下，这个题去掉 $b$ 的限制，我们实际上用了什么样的思想？

想到了差分，而这一步骤实际上是把每一个人的贡献给分开了——分成了对于全局的贡献。

分开之后呢？我们发现，可以通过**对代价的提前计算**来求解这个题。

于是，我们就可以把 $b$ 这一维度放到 代价提前计算 这一部分中了。

所以有一点启示：有时候可以考虑把不想要的状态提前计算掉。

当然需要一些转化。

最后提一下初始化的问题：每次滚榜之后的最大值一定是大于最初始序列的最大值的，而这个最大值也是原序列唯一一个有资格当榜上最大值的数，也就是说，它的所有榜一值上最小的。

所以我们需要计算一个状态的最小值能不能满足条件，这同时也是最开始状态转移——转移到最初榜首的位置，这样才是最小的。这是最小代价，注意。

考场时候没做出来 现在终于明白了）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,a[200];
int f[1<<14][14][501];
int cost[14][14],maxn[14];
int num[1<<14],pw[1<<14];
inline int Max(int x,int y){return x>y?x:y;}
inline int Min(int x,int y){return x<y?x:y;}
inline int lowbit(int x){return x&(-x);}
inline int pop_count(int x){
	int res=0;
	for(int j=x;j;j-=lowbit(j))res++;
	return res;
}
void solve(){
	scanf("%lld%lld",&n,&m);
	for(int i=0;i<=13;++i)pw[1<<i]=i;
	for(int i=0;i<n;++i)scanf("%lld",&a[i]);
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j){
			//min cost{i\to j}
			cost[i][j]=Max(a[j]-a[i]+(i>j),0);
			maxn[i]=Max(maxn[i],cost[i][j]);
		}
	for(int i=0;i<(1<<n);++i)num[i]=pop_count(i);
	for(int i=0;i<n;++i)if(m>=n*maxn[i])f[1<<i][i][n*maxn[i]]=1;//mean that 'i' can be any number
	//最优策略下的数字一定最后不高于变成最大值的代价，所以初始化只能处理掉变成最大值所消耗的代价 
	for(int i=1;i<(1<<n);++i){
		if(num[i]<=1)continue;
		for(int j=i;j;j-=lowbit(j)){
			int state=i-lowbit(j);//state/j
			int pre=pw[lowbit(j)];//pos_j
			for(int k=state;k;k-=lowbit(k)){
				int pstate=lowbit(k);//1<<p
				int pos=pw[pstate];
				if(pos==pre)continue;
				int g=cost[pre][pos]*(n-num[state]);
				for(int v=g;v<=m;++v){
					f[i][pre][v]+=f[state][pos][v-g];
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<n;++i)
		for(int j=0;j<=m;++j)
			ans+=f[(1<<n)-1][i][j];
	cout<<ans<<endl;
}
signed main(){
	freopen("111.txt","r",stdin);
	solve();
	return 0;
}
```

---

## 作者：C20203030 (赞：0)

## 一、题目

[点此看题](https://www.luogu.com.cn/problem/P7519)

## 二、解法

考试时把题目看错了，没有注意到 $a_i$ 不降的条件。

考虑要求的东西是可能的排名情况，也就是求合法排列个数，状压可以将 $O(n!)$ 的排列枚举优化成 $O(2^n)$，那么这道题肯定会用上它。

如果我们不考虑 $a_i$ 不降的限制，发现这个题根本做不出来。因为你不知道某集合的最大值是谁，就算你记录了是谁也不知道是多少。**那么考虑把 $a_i$ 不降当成条件而非限制**。

某东西不降可以自然的联想到差分技巧，也就是当前我们把某个人 $i$ 的过题数增加 $x$，那么不在状压集合里的人的过题数也增加 $x$，下次考虑到某个人 $j$ 的时候 $i,j$ 的相对过题差值就没有变化，**可以当成初始过题数来考虑**，所以我们只需要记录最大值是哪个人即可。

设 $dp[s][i][k]$ 为考虑集合 $s$ 中的人，最后公布排名的人是 $i$，已经分配的过题数是 $k$ 的顺序情况数，转移考虑刷表法，枚举下一个公布排名的人 $j$，设 $w(j,i)$ 表示初始情况下 $j$ 超过 $i$ 的最小过题数乘以剩下的总人数，转移：

$$dp[s|2^j][j][k+w(j,i)]\leftarrow dp[s][i][k]$$

话说 $\tt CCF$ 给的时间复杂度越来越离谱了，$O(2^nn^2m)$ 看上去就跑不动啊 $...$

## 三、总结

做题时我们会忽略某限制来做，再考虑加上某限制。但如果忽略某限制做不起就一定要注意了，可以把限制当成条件！

差分技巧的使用十分关键，$dp$ 的时候差分放状态里可以叫消耗提前计算。

```c++
#include <cstdio>
#include <iostream>
using namespace std;
#define pii pair<int,int>
#define make make_pair
#define ll long long
int read()
{
	int x=0,f=1;char c;
	while((c=getchar())<'0' || c>'9') {if(c=='-') f=-1;}
	while(c>='0' && c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int n,m;pii mx,a[15];ll ans,dp[1<<13][15][505];
int w(pii a,pii b)
{
	int t=b.first-a.first;
	return max(0,t+(b.second<a.second));
}
signed main()
{
	n=read();m=read();
	for(int i=0;i<n;i++)
	{
		a[i]=make(read(),i);
		if(mx.first<a[i].first) mx=a[i];
		if(mx.first==a[i].first && mx>a[i]) mx=a[i];
	}
	for(int i=0;i<n;i++)
	{
		int t=n*w(a[i],mx);
		if(t<=m) dp[1<<i][i][t]=1;
	}
	for(int s=0;s<(1<<n);s++)
	{
		int t=__builtin_popcount(s);
		for(int i=0;i<n;i++)
		{
			if((s&(1<<i))==0) continue;
			for(int l=0;l<=m;l++)
			{
				if(dp[s][i][l]==0) continue;
				for(int j=0;j<n;j++)
				{
					if(s&(1<<j)) continue; 
					int r=(n-t)*w(a[j],a[i]);
					if(l+r<=m)
						dp[s|(1<<j)][j][l+r]+=dp[s][i][l];
				}
			}
		}
	}
	for(int i=0;i<n;i++)
		for(int j=0;j<=m;j++)
			ans+=dp[(1<<n)-1][i][j];
	printf("%lld\n",ans);
}
```



---


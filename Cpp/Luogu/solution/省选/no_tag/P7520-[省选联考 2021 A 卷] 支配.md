# [省选联考 2021 A 卷] 支配

## 题目描述

给定一张 $n$ 个点 $m$ 条边的有向图 $G$，其顶点从 $1$ 到 $n$ 编号。

对于任意两个点 $u, v$，若从顶点 $1$ 出发到达顶点 $v$ 的所有路径都需要经过顶点 $u$，则称顶点 $u$ 支配顶点 $v$。特别地，每个顶点支配其自身。

对于任意一个点 $v$，我们将图中支配顶点 $v$ 的顶点集合称为 $v$ 的受支配集 $D_v$。

现在有 $q$ 次互相独立的询问，每次询问给出一条有向边，请你回答在图 $G$ 中加入该条边后，有多少个顶点的受支配集发生了变化。

## 说明/提示

**【样例 #1 解释】**

对于原图，六个点的受支配集分别为：$D_1 = \{ 1 \}$，$D_2 = \{ 1, 2 \}$，$D_3 = \{ 1, 3 \}$，$D_4 =\{ 1, 3, 4 \}$，$D_5 = \{ 1, 3, 4, 5 \}$，$D_6 = \{ 1, 2, 6 \}$。

加入 $5 \to 6$ 后，$D_6 = \{ 1, 6 \}$，其他点受支配集不变。

加入 $3 \to 2$ 后没有点受支配集改变。

加入 $2 \to 4$ 后，$D_4 = \{ 1, 4 \}$，$D_5 = \{ 1, 4, 5 \}$，其他点受支配集不变。

---

**【数据范围】**

对于所有测试数据：$1 \le n \le 3 \times {10}^3$，$1 \le m \le 2 \times n$，$1 \le q \le 2 \times {10}^4$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 6$ | $100$ | $q \le 100$ |
| $7 \sim 9$ | $1000$ | $m = n - 1$ |
| $10 \sim 15$ | $1000$ | $q \le 2000$ |
| $16 \sim 20$ | $3000$ | 无 |

## 样例 #1

### 输入

```
6 6 3
1 2
1 3
3 4
4 5
2 6
4 1
5 6
3 2
2 4
```

### 输出

```
1
0
2
```

## 样例 #2

### 输入

```
见附件中的 dominator/dominator2.in。```

### 输出

```
见附件中的 dominator/dominator2.ans。```

## 样例 #3

### 输入

```
见附件中的 dominator/dominator3.in。```

### 输出

```
见附件中的 dominator/dominator3.ans。```

# 题解

## 作者：Aly_ (赞：43)

**一个究极暴力做法**



**题意简述**

- 给定一张有向图 $G$，定义一个点 $i$ 的支配集是所有满足如下性质的点：删除该点后 $1$ 不再可达 $i$。
- 回答 $q$ 个询问 $<p_j,q_j>$，询问的是加入边 $p_j\rightarrow q_j$ 后多少个点的支配集发生变化。
- $1\leq n\leq 3000$，$1\leq q\leq 20000$。

**解法**

​	一步一步推。

​	以下是考场上的思考：

1. 加入一条边后一个点的支配集要么变小，要么不变。因为这条边使整张图 “ 更加联通 ”。
2. 支配的传递关系：若 $x$ 支配 $y$，$y$ 支配 $z$，则 $x$ 支配 $z$。因为删除 $x$ 后 $y$ 被割开，而 $y$ 一旦不可达 $z$ 也就随之不可达了。
3. 支配的链式关系：若 $x$ 支配 $a$，$y$ 也支配 $a$，则 $x,y$ 之间也存在支配关系。如不然则必定有一种情况，使得删除其中一个点后，$1$ 可从另一个点到达 $a$。
4. 支配树：对于一个点 $x$，设 $D_x$ 为它的支配集，**则 $D_x$ 中必定有且仅有一个点 $fa_x$，使得 $D_x$ 中除 $fa_x$ 的点都支配 $y$。**这个性质可由上面的观察得出。我们新建一棵以 $1$ 为根的树，其中包含所有 $(x,fa_x)$ 无向边，此即为该无向图的支配树。
5. $x$ 的支配集为支配树上所有 $x$ 的祖先。
6. **$x$ 的支配集中，$fa_x$ 是支配集大小最大的那个点**。这点可由前面得出。通过这点可以暴力地构建支配树。
7. 加入一条边后，$x$ 的支配集发生改变时，**要么 $fa_x$ 的支配集发生改变**，**要么 $fa_x$ 不再是 $x$ 的支配点**。这点可由上面支配树的定义看出。
8. 加入一条边 $p\rightarrow q$ 后，$fa_x$ 不再是 $x$ 的支配点，**当且仅当删除 $fa_x$ 后 $1$ 可达 $p$，$q$ 可达 $x$**。可能有一些诸如 $q=fa_x$ 的边角情况，特殊判掉即可。



​	于是出现了一个很暴力的做法。该做法分为 $O(n^2)$ 的预处理和 $O(nq)$ 的询问两部分。

​	依次遍历所有点，看看把它删掉后哪些点不再可达。这样可以求出每个点的支配集。由前面的第六点思考，我们得以构建支配树。构建完后，对于每个点 $x$，我们把它的父亲删掉，看看哪些点仍从 $1$ 可达，哪些点仍可达 $x$。暴力 BFS，复杂度 $O(n^2)$。

​	查询时在树上 DFS。运用第七点和第八点综合判定即可。单次复杂度 $O(n)$。

​	总复杂度 $O(n^2+nq)$。空间 $O(n^2)$。可以通过本题。

​	下面是巨丑考场代码。有微调。

```c++
#include<bits/stdc++.h>
#define N 3005
using namespace std;
int n,m,Q,p,q,fa[N+1],fl[N+1][N+1],t[N+1],tfl[N+1][N+1],gfl[N+1];
vector<int>bi[N+1],fbi[N+1],o[N+1];
pair<int,int>q0[100001];
bool comp(int x,int y){return o[x].size()<o[y].size();}
void putin(){
	cin>>n>>m>>Q;
	for(int i=1;i<=m;i++)cin>>p>>q,bi[p].push_back(q),fbi[q].push_back(p);
	for(int i=1;i<=Q;i++)cin>>q0[i].first>>q0[i].second;
}
inline void dfs0(int x,int np){
	fl[x][np]=1;
	if(x==np)return;
	for(int i=0;i<bi[x].size();i++){
		int ni=bi[x][i];
		if(!fl[ni][np])dfs0(ni,np);
	}
}
void ycl(){
	dfs0(1,0);
	for(int i=1;i<=n;i++)t[i]=i;
	for(int i=1;i<=n;i++){
		dfs0(1,i);
		for(int j=1;j<=n;j++)if(fl[j][0]&&!fl[j][i])o[j].push_back(i);
	}
	sort(t+1,t+n+1,comp);
	for(int i=1;i<=n;i++){
		for(int j=0;j<o[i].size();j++){
			if(o[o[i][j]].size()==o[i].size()-1){
				fa[i]=o[i][j];break;
			}
		}
	}
}
inline void dfs1(int x,int np,int nr){
	if(x==nr)return;
	tfl[x][np]=1;
	for(int i=0;i<fbi[x].size();i++){
		int ni=fbi[x][i];
		if(!tfl[ni][np])dfs1(ni,np,nr);
	}
}
void cal0(){
	for(int i=2;i<=n;i++){
		dfs1(i,i,fa[i]);
	}
	for(int i=1;i<=Q;i++){
		int nans=0;
		for(int j=1;j<=n;j++)if(fl[q0[i].first][fa[j]]&&tfl[q0[i].second][j]&&fa[j]!=1&&fa[j]!=q0[i].first)gfl[j]=1;
		for(int j=1;j<=n;j++)if(gfl[fa[t[j]]])gfl[t[j]]=1;
		for(int j=1;j<=n;j++)if(gfl[j])nans++,gfl[j]=0;
		cout<<nans<<'\n';
	}
}
signed main(){
	putin();
	ycl();
	cal0();
	return 0;
}
```

~~省选救命题~~

---

## 作者：lindongli2004 (赞：28)

题意本身就已经够简洁的了，所以这里不再复述。

首先建一棵支配树（建法在最下面），那么一个点 $u$ 的受支配集 $D_v$ 即为它到根的路径上的所有点组成的集合，那么如果我们连一条边使得某一个点 $u$ 的支配集改变：首先，$u$ 的支配集不会增大，那只能是 $u$ 的某个支配树上的祖先不再支配 $u$ 了。进一步地等价于，存在一条路径，不经过 $u$ 的某个祖先可以直接到达 $u$。

那么如果只经过原图上的边，是不可能存在这样的路径的，所以一定要经过新加的有向边 $(x,y)$ 才行。那么一个对答案有贡献的点 $u$，从 $1$ 出发到它的路径都形如：$1\to x \to y \to u$ （前后两个 $\to$ 代表一条路径，中间一个 $\to$ 代表一条边），且这条路径不经过 $u$ 的某一个祖先。

祖先这个限制不好处理，那进一步地，如果可以转化为不经过 $u$ 在支配树上的父亲就好了。很幸运，我们可以完成这个转化。具体地，对于一个点 $u$，我们找到这个点最浅的满足这个条件的祖先 $v$，那么 $v$ 的支配集肯定会发生改变，$v$ 子树内所有点的支配集也都会发生改变！所以一个点的支配集改变，会影响一个子树。

所以问题又转化为，如果存在一条路径 $1\to x \to y \to u$ 不经过点 $u$ 的父亲，那么 $u$ 子树内所有点都会对答案产生贡献（支配集都会发生改变），问有多少个点会产生贡献。那么这个问题就很简单了，我们先预处理出一个点 $u$，把 $u$ 的父亲从原图的反图（把原图的有向边取反）中删去，$u$ 能到达哪些点。那么它就可能对这些点产生贡献。对于一组询问 $(x,y)$，我们只需要枚举所有可能对 $y$ 产生贡献的点，如果它的父亲不在支配树上的 $1\to x$ 这条路径上，它这棵子树就可以产生贡献，求出dfs序之后差分一下即可。

复杂度 $O(nq)$ 。

支配树的建法：

因为 $n=3000$，所以允许我们使用 $O(n^2)$ 的建法，而且在考场上感觉这种建法好写好调，性价比高。我们分别删掉 $[1...n]$ 中的每一个点，从 $1$ 开始跑 dfs，求出每个点的受支配集（如果删掉点 $u$ 后 $1$ 不能到达点 $v$ 那么 $u$ 支配 $v$）。

然后类似拓扑排序一样，首先把 $1$ 入队，然后重复进行如下操作：

1. 取出队头 $u$，对于所有受支配集中存在点 $u$ 的点，把 $u$ 从受支配集中删掉。

2. 对于所有没有入队并且受支配集中只剩下本身（支配集大小为 $1$ ）的点 $v$ 入队，连边 $(u,v)$。

等队列为空，就可以得到一颗支配树了！

在放代码前，写一写在考场上的心路历程吧。

考场上读完三题，5分钟就想到了这题的大概做法，但是写完之后，对拍不断出错，于是我就陷入了出错，调试，出错，调试，出错...... 如此这样的死循环。

2.5h的时候，我绝望了，面对 $0$ 分的 T3 和压根都没来得及思考的 T1,T2 ，我头一次尝到的绝望，无助，想哭的感觉。可能每次水到渠成之时，命运总会像一块大石头，挡在我面前吧。

但我想，反正也进不了队了，豁出去了！我抖擞精神，想了一会儿 T1,T2 大概能拿 $50$，便直接回去肝 T3，终于在 $4h$ 的时候，对拍不断跳出 $AC$ 的字样，泪目。于是又花 $30$min 用手速优势敲完暴力，卡时间交题。

最后因为 T3 常数太大了，没通过民间数据，只拿到了 $75$ 分（upd:过了/se），前面两题也只有 $50$ 分。下考之后花 $10$ 分钟仔细想了想 T1，才发现是道送分题。可是命运总是这样，它不断地捉弄你，也许只有知道自己的考试策略太过激进，才能成为更稳的自己吧，也许只有经历大赛的磨炼，才能成长为更强的自己吧。

最后是稍作修(ka)改(chang)后的考场代码（要是没通过的话我会回来修锅的啊哈哈）：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=3021;
int n,m,tot,tot2,tot1,Did,Tid,ans;
int v[N],v1[N],v2[N],stk[N*N],cnt[N],siz[N],fa[N],dfn[N],vis1[N],cf[N],vis2[N];
bool del[N],vis[N],dis[N][N],init[N],cg[N][N];
struct Edge{int to,next;}e[N<<3],e1[N<<3],e2[N<<3];
void add1(int x,int y){
	e1[++tot1].to=y; e1[tot1].next=v1[x]; v1[x]=tot1;
}
void add2(int x,int y){
	e2[++tot2].to=y; e2[tot2].next=v2[x]; v2[x]=tot2;
}
void add(int x,int y){
//	cerr<<"add "<<x<<" -> "<<y<<endl;
	e[++tot].to=y; e[tot].next=v[x]; v[x]=tot;
}
void dfs(int x){
	if(del[x])return; vis[x]=1;
	for(int p=v1[x];p;p=e1[p].next)
		if(!vis[e1[p].to])dfs(e1[p].to);
}
void dfs2(int x){
	if(del[x])return; vis[x]=1;
	for(int p=v2[x];p;p=e2[p].next)
		if(!vis[e2[p].to])dfs2(e2[p].to);
}
void dfs1(int x){
	siz[x]=1; dfn[x]=++Did;
	for(int p=v[x];p;p=e[p].next){
		int kp=e[p].to; fa[kp]=x;
		dfs1(kp); siz[x]+=siz[kp];
	}
}
bool Init(int x,int y){
//	cerr<<"Init "<<x<<" "<<y<<" "<<dfnendl;
	return (dfn[y]>=dfn[x] && dfn[y]<dfn[x]+siz[x]);
}
void getans(int x,int y){
//	if(ctt==3)cerr<<"getans "<<x<<endl;
	vis1[x]=vis2[x]=Tid;
	if(!Init(fa[x],y) && vis2[fa[x]]!=Tid)stk[++ans]=x;
	for(int p=v1[x];p;p=e1[p].next)
		if(vis1[e1[p].to]!=Tid)getans(e1[p].to,y);
	vis2[x]=Tid-1;
}
bool cmp(const int &x,const int &y){return dfn[x]<dfn[y];}
int read(){
	int x=0,f=1; char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("dominator.in","r",stdin);
//	freopen("dominator.out","w",stdout);
	n=read(); m=read(); int aq=read();
	for(int x,y,i=1;i<=m;i++)
		x=read(),y=read(),add1(x,y),add2(y,x);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			del[j]=vis[j]=0; del[i]=1;
		dfs(1);
		for(int j=1;j<=n;j++)
			if(!vis[j])dis[j][i]=1,++cnt[j];
	}
//	for(int i=1;i<=n;i++)cout<<cnt[i]<<" ";cout<<endl;
//	for(int i=1;i<=n;i++,cout<<endl)
//		for(int j=1;j<=n;j++)cout<<dis[i][j]<<" ";
	int top; stk[top=1]=1; init[1]=1;
	for(int i=1;i<=top;i++){
//		cout<<"cnt[3]="<<cnt[3]<<" i="<<i<<endl;
//		if(i>n)break;
		int w=stk[i];
//		cout<<"w="<<w<<endl;
//		if(i==60){cout<<w<<endl;for(int j=1;j<=n;j++)cout<<cnt[j]<<" ";cout<<endl;}
		for(int j=1;j<=n;j++)
			if(dis[j][w])--cnt[j];
		for(int j=1;j<=n;j++)
			if(cnt[j]==1 && !init[j])
				init[j]=1,add(w,j),stk[++top]=j;
//		if(i==60){for(int j=1;j<=n;j++)cout<<cnt[j]<<" ";cout<<endl;}
	}
	fa[1]=1; dfs1(1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			del[j]=vis[j]=0;
		del[fa[i]]=1; dfs2(i);
		for(int j=1;j<=n;j++)
			cg[i][j]=vis[j];
	}
//	cerr<<"fa:";for(int i=1;i<=n;i++)cerr<<fa[i]<<" ";cerr<<endl;
//	cout<<"siz:";for(int i=1;i<=n;i++)cout<<siz[i]<<" ";cout<<endl;
//	int ctt=0;
	while(aq--){
		int x=read(),y=read(),x1=x;
		ans=0; ++Tid;
		while(x1!=1)vis1[x1]=Tid,x1=fa[x1]; vis1[1]=Tid;
		for(int i=1;i<=n+1;i++)cf[i]=0;
//		getans(y,x);
		for(int i=1;i<=n;i++)
			if(cg[i][y] && vis1[fa[i]]!=Tid)
				++cf[dfn[i]],--cf[dfn[i]+siz[i]];
		for(int i=1;i<=n;i++)
			cf[i]+=cf[i-1],ans+=(cf[i]!=0);
//		sort(stk+1,stk+ans+1,cmp);
//		if(ctt==5){
//			cerr<<"stk:";for(int i=1;i<=ans;i++)cerr<<stk[i]<<" ";cerr<<endl;
//		}
//		int mxr=0,ct=0;
//		for(int i=1;i<=ans;i++){
//			if(dfn[stk[i]]<=mxr)continue;
//			mxr=dfn[stk[i]]+siz[stk[i]]-1; ct+=siz[stk[i]];
//		}
//		cout<<x<<" -> "<<y<<endl;
		printf("%d\n",ans);
	}
	return 0;
}
```
彩蛋？大样例是用脚造的，上面的代码保留了大部分我考场艰辛的调试信息，删掉调试信息也就 $2k$ 左右，所以不要被代码长度吓到啦！

---

## 作者：LinkyChristian (赞：8)

**每周文章计划2021.12 第四周（3）**

看到很多题解里有出现支配集和受支配集含糊混用的问题，因此撰此挫作带来更清晰的描述。

题目已经将受支配集的定义讲的很清楚了，这里我们更新一下这个定义：一个点的受支配集为除自己之外支配自己的点。

接下来构造支配树。

定义支配树是由一个点与**它的受支配集中受支配集最大的那个点作为父亲**连边所构成的树。

本道题可以 $O$ ($n^2$) 地建立支配树，我们采取最简单粗暴的方法：对于每个点，求出删掉这个点后从 $1$ 还能到达哪些点，不能到达的点就属于它的支配集，之后根据定义建树。

一条很好发现的引理：一个点的受支配集改变后，它在支配树上的子树里的所有点的受支配集也会改变。

因此即使加入一条边可能会改变多个点的受支配集，但我们只要考虑这些点中深度最浅的就可以了。

考虑受支配集改变的深度最浅的那一些点，那么一定是它的父亲不再支配它了（否则的话它的父亲也受到了改变，且深度比它更浅，与原定义不符）。我们做两遍 $dfs$ ,对于每个询问：$u -> v$ 求出 $u$ 是否能到 $fa_j$ , $v$ 是否
能在去掉 $fa_j$ 的情况下到达 $j$ ,如果符合条件，说明 $u -> v$ 这条边可以绕开 $fa_j$ 从 $1$ 到达 $j$ ，那么此时 $j$ 以及 $j$ 的子树内所有点的受支配集改变。

$Tips:$ 注意特判 $fa_j$ 为 $1$ 和 $u == fa_j$ 的情况。

上代码

```
#include<bits/stdc++.h>
#define N 6010
using namespace std;
int n,m,Q;
pair<int,int> q[20010];
int cnt,head[N],to[N],nxt[N];
int vis[N][N];
vector<int> ctrl[N];//受支配集 
void insert(int u,int v) {
	cnt++;
	to[cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}
int read(){
	int x=0,f=1; char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void dfs1(int now,int fr/*删掉的点*/) {
	vis[now][fr]=1;
	if(now==fr) return ; 
	for(int i=head[now]; i; i=nxt[i]) 
	    if(!vis[to[i]][fr]) dfs1(to[i],fr);
}
int id[N],fa[N];
bool cmp(int a1,int a2) {
	return ctrl[a1].size()<ctrl[a2].size();
}
void build() {//建树
	dfs1(1,0);
	for(int i=1; i<=n; i++) {
		dfs1(1,i),id[i]=i;//删掉i 
		for(int j=1; j<=n; j++) 
		    if(vis[j][0]&&!vis[j][i]) ctrl[j].push_back(i);
		//本来可以到达删除i后无法到达，说明j受i支配 
	} 
	sort(id+1,id+n+1,cmp);
	for(int i=1; i<=n; i++) {
		for(int j=0; j<ctrl[i].size(); j++) {
			int v=ctrl[i][j];
			if(ctrl[v].size()==ctrl[i].size()-1) {
				fa[i]=v;
				break;
				//自己的受支配集里受除了其本身外的所有成员支配的即为自己的父亲 
			}
		}
	}
} 
int U[N],V[N],vis2[N][N];
int Cg[N];//受支配集是否改变 
void dfs2(int now,int fr,int del) {
	if(now==del) return ;
	vis2[now][fr]=1;
	for(int i=head[now]; i; i=nxt[i]) 
	    if(!vis2[to[i]][fr]) dfs2(to[i],fr,del);
}
void calc() {
	for(int i=2; i<=n; i++) dfs2(i,i,fa[i]);
	//排除自己在支配树上的父亲后能到达哪些点
	for(int i=1; i<=Q; i++) {
		int ans=0,u=q[i].first,v=q[i].second;
		for(int j=1; j<=n; j++)
		    if(vis[u][fa[j]]&&vis2[v][j]&&fa[j]!=1&&fa[j]!=u) Cg[j]=1;
		    //如果u在正图上能到达父亲，v在反图上能到达j，那么自己就被支配
		for(int j=1; j<=n; j++) if(Cg[fa[id[j]]]) Cg[id[j]]=1;
		//如果一个点的受支配集变了，那么其子树中的受支配集也会变
		for(int j=1; j<=n; j++) if(Cg[j]) ans++,Cg[j]=0;
		cout<<ans<<endl; 
	} 
}
int main()
{
	n=read(),m=read(),Q=read(); 
	for(int i=1; i<=m; i++) {
		U[i]=read(),V[i]=read();
		insert(U[i],V[i]);
	}
	for(int i=1; i<=Q; i++) q[i].first=read(),q[i].second=read();
	build();
	cnt=0;memset(head,0,sizeof(head));
	for(int i=1; i<=m; i++) insert(V[i],U[i]);//接下来是反图 
	calc();
	return 0;
}

```


---

## 作者：Gorenstein (赞：4)

有显然的性质：加入新的边后，一个点的受支配集不会减少。

因为$x$ 的受支配集就是 $x$ 在支配树上的全部祖先，所以根据以上性质，我们可以知道：加入一条边后，$x$ 的受支配集如果改变，就说明 $x$ 到根的链上有点不再支配 $x$。

由此即可想到：
- **如果 $\operatorname{idom}x$ 的不再支配 $x$，那么它也不再支配 $x$ 的子树中的所有点。**

由此我们可以建出支配树并预处理出树上每个点的子树大小。对于每一个询问 $p,q$，我们只需求出所有原先的直接支配点不再支配它的点 $x$，然后累加它的子树即可；对于其子树中其它点，我们不必再扫描。

考虑怎么求出加边之后 $\operatorname{idom}x$ 是否仍然支配 $x$。考虑一条新加的边 $(p,q)$，能通过 $1$ 号节点绕过 $\operatorname{idom}x$ 到达 $x$，当且仅当：
- 删去 $\operatorname{idom}x$ 后 $1$ 能到达 $p$ 且 $q$ 能到达 $x$。

容易正反图上对于每个点 DFS 两遍预处理这个可达性。至此我们以 $O(NQ)$ 的做法完成了询问。

------------
以下稍微介绍支配树的构建。首先我们引入一个点的半支配点 $\operatorname{sdom}x$。

$\bf Definition\;3\;(semi{\text -}dominator):$

$$
\operatorname{sdom}x=\min_{v\in V}\left\{\operatorname{dfn}v:\exists(v,v_1,\cdots,v_k,x),\operatorname{dfn}v_{i(\leqslant k)}>\operatorname{dfn}x\right\}
$$

也即所有存在只经过大于 $x$ 的点的路径到达 $x$ 的点 $v$ 中最小的点。令点的大小即为其 $\rm dfn$ 序的大小。现给出支配树的五大引理：

1. $\operatorname{dfn}x\leqslant\operatorname{dfn}y\;\Longrightarrow\;\forall(x\rightsquigarrow y)\ni\operatorname{lca}(x,y)$。
2. $\operatorname{idom}x$ 必为 $x$ 在搜索树上的祖先。
3. $\operatorname{sdom}x$ 必为 $x$ 在搜索树上的祖先。
4. $\operatorname{idom}x$ 必为 $\operatorname{sdom}x$ 在搜索树上的祖先。
5. $\bigcup\big(\operatorname{idom}x\rightsquigarrow x\big)=\varnothing$。

它们的证明都是容易的。基于此，我们给出支配树的三大定理。

${\bf Theorem\;1:}$

$$
\forall y\in(\operatorname{sdom}x\rightsquigarrow x),\operatorname{sdom}y\geqslant\operatorname{sdom}x\;\Longrightarrow\;\operatorname{idom}x=\operatorname{sdom}x
$$

${\bf Theorem\;2.}\quad$ 设 $y$ 为 $(\operatorname{sdom}x\rightsquigarrow x)$ 中 $\operatorname{sdom}$ 最小的点，若 $\operatorname{sdom}y\leqslant \operatorname{sdom}x$，则 $\operatorname{idom}x=\operatorname{idom}y$。

${\bf Theorem\;3:}$

$$
\operatorname{sdom}x=\min\{y:(y,x)_{y\leqslant x}\in E\}\cup\{\operatorname{sdom}z_{>x}|∃(y,x),z\in(S⇝y)\}
$$

依第三定理我们可以求出 $\operatorname{sdom}$ 的值。据该定理，对于与 $x$ 直接相连的点 $y$，有以下两种情况：
- $y<x$，则 $y$ 可能是。
- $y>x$，则大于 $x$ 的 $y$ 的祖先的半支配点可能是。

考虑按 $\operatorname{dfn}$ 序从大到小计算。我们每处理到一个点，就将它和它搜索树上的父节点用带权并查集合并，也即维护集合内除根以外 $\operatorname{sdom}$ 最小的点。对第二种情况有贡献的点在倒序计算过程中都先得出了，故使用并查集可以方便求出。

可根据第一和第二定理在过程中同时求出 $\operatorname{idom}$ 的值。第一和第二定理告诉我们，设 $y$ 为 $(\operatorname{sdom}x\rightsquigarrow x)$ 中 $\operatorname{sdom}$ 最小的点，则：
- $\operatorname{sdom}x=\operatorname{sdom}y$，则 $\operatorname{idom}x=\operatorname{sdom}x$。
- $\operatorname{sdom}x>\operatorname{sdom}y$，则 $\operatorname{idom}x=\operatorname{idom}y$。

具体地，我们自底向上建出半支配树，枚举点 $x$ 在半支配树上的子节点 $y$，则 $y$ 上的并查集恰好维护了 $(x\rightsquigarrow y)$ 路径上 $\operatorname{sdom}$ 最小的点，据此计算 $\operatorname{idom}y$ 即可。计算完 $x$ 的半支配树子节点 $y$ 后即可删去这些 $y$，减少以后的冗余扫描。

注意到对于以上的第二种情形，我们实际上不知道并查集中点的 $\operatorname{idom}$。所以我们将这些点存下来，最后再正序处理一遍。

------------
至此我们就以 $O(N\log N+NQ)$ 的做法通过了本题。另外此题卡常，要用 `bitset`。不过即使不用 `bitset` 也能在 LOJ 上通过。

```cpp
const int N=3010;
#define pb push_back
int n,m,q,ans,s[N];bitset<N> v,arv1[N],arvx[N],tg;
int dfn[N],num,p[N],sdom[N],idom[N],S[N],F[N],cur[N];
vector<ll> e1[N],e2[N],ot[N],e[N];
void dfsdom(int x){
	dfn[x]=++num,p[num]=x;
	for(int y:e1[x])if(!dfn[y])F[y]=x,dfsdom(y);
}
int Up(int x){
	if(S[x]==x)return x;int y=Up(S[x]);
	if(dfn[sdom[cur[S[x]]]]<dfn[sdom[cur[x]]])
		cur[x]=cur[S[x]];
	return S[x]=y;
}
void domTree(){
	for(int i=1;i<=n;i++)sdom[i]=S[i]=cur[i]=i;
	dfsdom(1);
	for(int i=num,x=p[i];i>1;i--,x=p[i]){
		for(int y:e2[x]){
			if(!dfn[y])continue;Up(y);
			if(dfn[sdom[cur[y]]]<dfn[sdom[x]])
				sdom[x]=sdom[cur[y]];
		}
		S[x]=F[x],ot[sdom[x]].pb(x),x=F[x];
		for(int y:ot[x]){
			Up(y);
			if(x==sdom[cur[y]])idom[y]=x;
			else idom[y]=cur[y];
		}
		ot[x].clear();
	}
	for(int i=2,x=p[i];i<=num;i++,x=p[i])
		if(idom[x]^sdom[x])idom[x]=idom[idom[x]];
	for(int i=2;i<=n;i++)
		e[i].pb(idom[i]),e[idom[i]].pb(i);
}
void dfsar1(int x,int ban){
	arv1[ban][x]=v[x]=1;
	for(int y:e1[x])
		if(y^ban&&!v[y])dfsar1(y,ban);
}
void dfsarx(int x,int ban,int targ){
	arvx[targ][x]=v[x]=1;
	for(int y:e2[x])
		if(y^ban&&!v[y])dfsarx(y,ban,targ);
}
void dfs(int x,int fa){
	s[x]=1;
	for(int y:e[x])
		if(y^fa)dfs(y,x),s[x]+=s[y];
}
void dfsans(int x,int fa){
	if(tg[x]){ans+=s[x];return;}
	for(int y:e[x])if(y^fa)dfsans(y,x);
}
int main(){
	n=read(),m=read(),q=read();
	for(int i=1,x,y;i<=m;i++)
		x=read(),y=read(),e1[x].pb(y),e2[y].pb(x);
	domTree();
	for(int i=2;i<=n;i++)
		v.reset(),dfsar1(1,i),v.reset(),dfsarx(i,idom[i],i);
	dfs(1,0);
	for(int _=1,x,y;_<=q;_++){
		x=read(),y=read(),ans=0;
		for(int i=1;i<=n;i++)tg[i]=0;
		for(int i=2;i<=n;i++)
			if(arv1[idom[i]][x]&&arvx[i][y])tg[i]=1;
		dfsans(1,0),printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：whiteqwq (赞：4)

[P7520 [省选联考 2021 A 卷] 支配](https://www.luogu.com.cn/problem/P7520)

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1791051)

## 题意

定义一个点$x$支配另一个点$y$当且仅当结点$1$到达结点$y$的每一条路径都要经过$x$，且点$y$的受支配集$D_y$为所有支配$y$的$x$形成的集合。

给定一个$n$个点$m$条边的图$G$，进行$q$次相互独立的询问，每次询问加入边$(x,y)$后有多少个点的受支配集有变化。

$1\leqslant n\leqslant 3000,1\leqslant m\leqslant 2\times n,1\leqslant q\leqslant 2\times 10^4$。

## 分析

似乎是支配树裸题，但我不会支配树/kk。

当我们不知道支配树时，应该怎么想到支配树呢？

考虑$1$到结点$x$的所有路径一定是不断“扩张”然后不断“收束”到一个点上，然后继续“扩张”与“收束”的一个过程，而每次“收束”到的点都是$x$的支配点。

不难发现除了结点$1$外任意结点$x$都有且仅有一个极大支配点$fa_x=y$，也就是说$D_x=D_y\cup\{x\}$，那么如果我们将$x$与$y$连一条边的话，根据支配的定义一定不会形成环，那么就会形成一个$n$个结点，$n-1$条边的无向无环联通图——支配树。

如何建出支配树呢？这里介绍一种$O(n^2)$的简单做法。

考虑设$delp_{x,y}$表示删除结点$x$后，结点$1$是否能到达结点$y$，那么我们只需要枚举$x$，然后每次$\text{dfs}$就可以$O(n^2)$的求出这个数组了。

又由于$delp_{x,y}=0$与$x$支配$y$等价，因此我们可以求出所有结点的受支配集。

那么我们对于每个点枚举它受支配集中每一个点，按照极大支配点的定义进行判断就好了。

建出支配树，又怎么求解呢？（设加入的边为$(u,v)$）

对于每一个点$x$，不难发现它的受支配集会改变当且仅当$fa_x$的受支配集改变或者$fa_x$不再支配$x$。（由极大支配点的定义可得）

那么我们从上到下遍历支配树（不要直接遍历，最好用$dfs$序或者$bfs$序，本文使用$bfs$序，也就是所有点按照支配集大小进行排序的结果），问题转化为判断一个点的极大支配点$fa_x$是否还支配$x$。

很容易发现支配树的支配关系是等价于原图的（这也是CCF设置图是一个树这个部分分的原因），那么我们只需要判断删除$x$的父亲从$1$是否能到达$u$，而$v$是否能到达$x$就好了。

那么我们再$O(n^2)$预处理一个$delf_{x,y}$表示删除$x$的父亲后$y$是否能到达$x$就做完这道题了。

时间复杂度：$O(n(n+q))$。

## 代码
被卡常了，交换了$delp_{x,y}$与$delf_{x,y}$定义中的$x$与$y$才能过。
```
#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;
const int maxn=3005;
int n,m,q,e;
int bfn[maxn],fa[maxn],t[maxn],ok[maxn];
int delp[maxn][maxn],delf[maxn][maxn];//delp[y][x]: del x 1 to y ; delf[y][x]: del fa[x] 1 to y
vector<int>g[maxn],rg[maxn],d[maxn];
inline int cmp(int x,int y){
	return d[x].size()<d[y].size();
}
void getdelp(int x,int p){
	if(x==p)
		return ;
	delp[x][p]=1;
	for(int i=0;i<g[x].size();i++){
		int y=g[x][i];
		if(delp[y][p]==0)
			getdelp(y,p);
	}
}
void getdelf(int x,int p){
	if(x==fa[p])
		return ;
	delf[x][p]=1;
	for(int i=0;i<rg[x].size();i++){
		int y=rg[x][i];
		if(delf[y][p]==0)
			getdelf(y,p);
	}
}
void read(int &x){
	x=0;
	char c=getchar();
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+c-48;
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++){
		int x,y;
		read(x),read(y);
		g[x].push_back(y),rg[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		getdelp(1,i);
		for(int j=1;j<=n;j++)
			if(delp[j][i]==0)
				d[j].push_back(i);
	}
	for(int i=2;i<=n;i++)
		for(int j=0;j<d[i].size();j++)
			if(d[d[i][j]].size()==d[i].size()-1){
				fa[i]=d[i][j];
				break;
			}
	for(int i=1;i<=n;i++)
		bfn[i]=i;
	sort(bfn+1,bfn+1+n,cmp);
	for(int i=2;i<=n;i++)
		getdelf(i,i);
	for(int i=1;i<=q;i++){
		int x,y,res=0;
		read(x),read(y);
		for(int j=1;j<=n;j++)
			if(fa[j]!=1&&fa[j]!=x&&delp[x][fa[j]]&&delf[y][j])
				ok[j]=1;
		for(int j=2;j<=n;j++){
			ok[bfn[j]]|=ok[fa[bfn[j]]];
			res+=ok[bfn[j]];
		}
		for(int j=1;j<=n;j++)
			ok[j]=0;
		printf("%d\n",res);
	}
	return 0;
}
```

省选联考A卷全部题解可见：[2021省选联考A卷解题报告](https://zybuluo.com/xiaoziyao/note/1791034)

---

## 作者：Mihari (赞：2)

推荐去[这里](https://www.cnblogs.com/Arextre/p/14677626.html)看，毕竟我也不知道 $\tt markdown$ 会不会出什么问题......

# 壹、题目描述 &para;

[传送门 to Luogu](https://www.luogu.com.cn/problem/solution/P7520)

# 贰、题解 &para;

可以先得到原图的支配树，使用 $\mathcal O(n^2)$ 或者 $\mathcal O(n\log n)$ 均可。

考虑加入一条边之后，受支配集发生变化的点，反映到支配树上即，某个点 $u$ 的某个祖先 $anc$ 在新的支配树上不再是他的祖先了。

如果将所有这样的点全部找出来，显然不可取。

感谢 [lindongli2004 的思路](https://www.luogu.com.cn/blog/lindongli2004/sdoi2021D2T3) 给我灵感，考虑当一个点的受支配集发生变化，显然，他在原支配树上的所有后代的受支配集同样发生了变化，所以，我们只需要找在支配树上深度最浅的点，其某个祖先在新支配树上不再是其祖先，而这个深度最浅的点，发生变化的就不止是他的祖先，这个祖先更是他的父亲，不然就还有深度比他更浅的点。

也就是说，我们要找到在原支配树上，在加入 $\lang x, y\rang$ 之后，某个点的父亲不再支配他的点，找到这样的点之后，他和他的子树都被算入答案贡献中，然后就不用再询问他的子树了。

显然，当一个点 $u$ 的父亲 $t$ 在加入 $\lang x,y\rang$ 之后不再支配他，当且仅当存在一条 $1\rightarrow x\rightarrow y\rightarrow u$ 不经过他的父亲，将这个路径拆成三个部分 ~~这不是显然的吗~~，即 $1\rightarrow x,x\rightarrow  y,y\rightarrow  u$，也就是要满足这样几个条件：

- 存在一条 $1\rightarrow x$ 的路径不经过 $t$；
- $x\rightarrow y$ 不经过 $t$；
- 存在 $y\rightarrow u$ 的路径不经过 $t$；

对于第一个条件，转化一下，**即 $x$ 在原图上不受 $t$ 的支配**，我们只需要将所有 $x$ 的祖先暴力打上标记就可以判断了，时间复杂度 $\mathcal O(n)$.

对于第二个条件，判一判就好。

对于第三个条件，考虑预处理一个 $f_{i,j}$ 表示 $j$ 能否在不经过 $i$ 的支配树上的父亲到达 $i$，具体预处理方式就是枚举 $i$，然后在**原图的反图**中 $\tt BFS$ 一遍，途中不能扩展 $i$ 的支配树父亲，复杂度 $\mathcal O(n(n+m))\le \mathcal O(3n^2)$.

对于每个询问，枚举一个 $u$，判断 $f_{u,y}$ 并且看 $father_u$ 是否支配 $x$ 即可。

总复杂度 $\mathcal O(n\log n+3n^2+nq)$.

# 叁、参考代码 &para;

用的 $\mathcal O(n\log n)$ 构建支配树的方法。

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;

template<class T>inline T readin(T x){
	x=0; int f=0; char c;
	while((c=getchar())<'0' || '9'<c) if(c=='-') f=1;
	for(x=(c^48); '0'<=(c=getchar()) && c<='9'; x=(x<<1)+(x<<3)+(c^48));
	return f? -x: x;
}

const int maxn=3e3;
const int maxm=maxn*2;
const int logn=12;

struct graph{
	struct edge{
		int to, nxt;
		edge(){}
		edge(int T, int N): to(T), nxt(N){}
	}e[maxm*2+5];
	int tail[maxn+5], ecnt;
	inline void add_edge(int u, int v){
		e[ecnt]=edge(v, tail[u]); tail[u]=ecnt++;
	}
	graph(){
		ecnt=0;
		memset(tail, -1, sizeof tail);
	}
}G, rG, dag, rdag;
#define foredge(i, u, G) for(int i=G.tail[u], v; ~i? (v=G.e[i].to, 1): 0; i=G.e[i].nxt)

int n, m, q;

inline void input(){
	n=readin(1), m=readin(1), q=readin(1);
	int u, v;
	for(int i=1; i<=m; ++i){
		u=readin(1), v=readin(1);
		G.add_edge(u, v);
		rG.add_edge(v, u);
	}
}

int dfn[maxn+5], refl[maxn+5], fa[maxn+5], timer;
void dfs(int u){
	refl[dfn[u]=++timer]=u;
	foredge(i, u, G) if(!dfn[v]){
		fa[v]=u, dag.add_edge(u, v);
		dfs(v);
	}
}

int pre[maxn+5], minn[maxn+5], sdom[maxn+5];
inline void initial(){
	for(int i=1; i<=n; ++i)
		pre[i]=minn[i]=sdom[i]=i;
}
int findrt(int u){
	if(u==pre[u]) return u;
	int ret=findrt(pre[u]);
	if(dfn[sdom[minn[u]]]>dfn[sdom[minn[pre[u]]]])
		minn[u]=minn[pre[u]];
	return pre[u]=ret;
}
inline void tarjan(){
	initial();
	for(int j=n; j>1; --j){
		int u=refl[j], res=j;
		if(!u) continue;
		foredge(i, u, rG){
			if(!dfn[v]) continue;
			if(dfn[v]<dfn[u]) res=min(res, dfn[v]);
			else findrt(v), res=min(res, dfn[sdom[minn[v]]]);
		}
		sdom[u]=refl[res];
		pre[u]=fa[u];
		dag.add_edge(sdom[u], u);
	}
}

int in[maxn+5], Q[maxn+5], op, ed;

vector<int>tre[maxn+5];
int tp[maxn+5][logn+5], dep[maxn+5];

inline int getlca(int u, int v){
	if(dep[u]<dep[v]) swap(u, v);
	for(int j=logn; j>=0; --j) if(dep[tp[u][j]]>=dep[v])
		u=tp[u][j];
	if(u==v) return u;
	for(int j=logn; j>=0; --j) if(tp[u][j]!=tp[v][j])
		u=tp[u][j], v=tp[v][j];
	return tp[u][0];
}
inline void insert_tre(int u){
	int par=rdag.e[rdag.tail[u]].to;
	foredge(i, u, rdag) par=getlca(par, v);
	dep[u]=dep[par]+1, tp[u][0]=par;
	tre[par].push_back(u);
	for(int j=1; j<=logn; ++j)
		tp[u][j]=tp[tp[u][j-1]][j-1];
}
inline void topu(){
	for(int u=1; u<=n; ++u){
		foredge(i, u, dag){
			++in[v];
			rdag.add_edge(v, u);
		}
	}
	for(int i=1; i<=n; ++i) if(!in[i]){
		dag.add_edge(0, i);
		rdag.add_edge(i, 0);
		++in[i];
	}
	Q[op=ed=1]=0;
	while(op<=ed){
		int u=Q[op++];
		foredge(i, u, dag) if(!--in[v]){
			Q[++ed]=v;
			insert_tre(v);
		}
	}
}

int siz[maxn+5];
void dfstre(int u){
	siz[u]=1, refl[dfn[u]=++timer]=u;
	for(int i=0, up=tre[u].size(); i<up; ++i)
		dfstre(tre[u][i]), siz[u]+=siz[tre[u][i]];
}

int f[maxn+5][maxn+5];
// whether i can reach j without going by i's father in the dominant_tre

inline void getf(){
	// besides 1(root)
	for(int i=2; i<=n; ++i){
		Q[op=ed=1]=i, f[i][i]=1;
		while(op<=ed){
			int u=Q[op++];
			foredge(j, u, rG) if(!f[i][v] && v!=tp[i][0]){
				f[i][v]=1, Q[++ed]=v;
			}
		}
	}
}

int vis[maxn+5];
inline void climb(int u){
	while(u) vis[u]=1, u=tp[u][0];
}
inline void getquery(){
	int x, y, ans;
	while(q--){
		x=readin(1), y=readin(1), ans=0;
		memset(vis, 0, sizeof vis); climb(x);
		// pay attention, dfn[0]=1, refl[1]=0, so the real dfn is [2, n+1]
		for(int i=2; i<=n+1; ++i){
			int u=refl[i];
			if(f[u][y] && !vis[tp[u][0]])
				ans+=siz[u], i+=siz[u]-1;
		}
		printf("%d\n", ans);
	}
}

signed main(){
	input();
	dfs(1);
	tarjan();
	topu();
	// rebuild dfn[], get siz[]
	timer=0; dfstre(0);
	getf();
	getquery();
	return 0;
}
```

---

## 作者：_LiWenX_ (赞：1)

显然先建出支配树，由于数据范围很小，我们可以使用 $O(n^2)$ 的算法完成。

具体来说，我们先计算每一个点的支配点集，可以通过暴力枚举一个点，然后删掉它，看看 $1$ 不能走到哪些点。

然后对于一个点的支配点集中，找到距离它最近的那一个，显然这个支配点就是这个点在树上的父亲。

建树完成后，考虑一次询问的答案。

显然 $x\to y$ 是必须走的，要不然就对支配树形态没有影响了，所以我们一定是先 $1\to x,x\to y$ 再由 $y$ 去其他点上。

对于原图上的边 $y\to z$，如果 $z$ 的父亲在 $1\to x$ 路径上，那么这一步的决策是没有意义的，我们依然会经过原本 $z$ 支配点集中的所有点才能到达 $z$。否则，我们必然改变 $z$ 的支配点集。

发现这个过程完全可以迭代，让 $z$ 再去找其他点就好了，所以我们只需要先把 $1\to x$ 这条“毛毛虫”打上标记，钦定这些点不可经过，然后再以 $y$ 为起点 bfs，所有可以走到的节点，都是答案。

复杂度为 $O(n^2+nq)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
vector<int> e[3005],E[3005];
bool vis[3005];
void dfs(int now,int del){
	if(now==del) return ;
	vis[now]=1;
	for(int u:e[now]){
		if(vis[u]) continue;
		dfs(u,del);
	}
}
int dis[3005];
void bfs(int s){
	fill(dis+1,dis+1+n,1e9);
	dis[s]=0;
	queue<int> q;q.push(s);
	while(!q.empty()){
		int now=q.front();q.pop();
		for(int u:E[now]){
			if(dis[u]>dis[now]+1){
				dis[u]=dis[now]+1;
				q.push(u);
			}
		}
	}
}
vector<int> vec[3005];
int fa[3005];
struct edge{
	int from,to;
}ee[3005];int head[3005],Stree;
void addedge(int x,int y){
	ee[++Stree].to=y;
	ee[Stree].from=head[x],head[x]=Stree;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>m>>q;
	while(m--){
		int x,y;cin>>x>>y;
		e[x].push_back(y),E[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		dfs(1,i);
		for(int j=1;j<=n;j++){
			if(!vis[j]&&i!=j) vec[j].push_back(i);
		}
	}
	for(int i=2;i<=n;i++){
		bfs(i);
		int minn=1e9,pos=0;
		for(int u:vec[i]){
			if(dis[u]<minn){
				minn=dis[u];
				pos=u;
			}
		}
		fa[i]=pos;
		addedge(pos,i);
	}
	while(q--){
		int x,y;cin>>x>>y;
		memset(vis,0,sizeof(vis));
		queue<int> q;
		while(1){
			for(int i=head[x];i;i=ee[i].from){
				int u=ee[i].to;
				vis[u]=1;
			}
			vis[x]=1;
			if(x==1) break; 
			x=fa[x];
		}
		if(vis[y]){
			cout<<0<<'\n';
			continue;
		}
		q.push(y);
		vis[y]=1;
		int ans=1;
		while(!q.empty()){
			int now=q.front();
			q.pop();
			for(int u:e[now]){
				if(vis[u]) continue;
				vis[u]=1;
				ans++;
				q.push(u);
			}
		}
		cout<<ans<<'\n';
	}
}
/*
*/
```

---

## 作者：翼德天尊 (赞：1)

考虑支配是具有传递性的，例如 $x$ 支配 $y$，$y$ 支配 $z$，那么 $x$ 一定也支配 $z$。

除此之外，若 $x,y$ 都支配 $z$，那么 $x,y$ 之间也一定存在支配关系。

所以事实上，节点之间的支配关系构成了一个树形结构，我们给它起个名字，叫支配树。

存在一种比较简便的 $O(n^2)$ 建树方式是，先枚举节点进行删除，并从 $1$ 开始遍历所有节点，求出每个节点的受支配集，记节点 $i$ 的受支配集大小为 $g_i$，则此时每个节点在支配树上的父亲为自身受支配集中 $g$ 最大的一个，正确性易得。 

于是我们就成功建出了支配树！

然后考虑怎么处理询问。对于询问 $(x,y)$，有两种情况会使得节点 $i$ 支配集改变，一种是 $i$ 的父亲支配集也被改变，另一种是删去 $i$ 的父亲后，仍然可以从 $1$ 走到 $x$，从 $y$ 走到 $i$。

于是不妨先预处理出每个节点在删去其父亲的情况下，都有哪些节点可以到达它。对于每个询问，我们可以遍历整棵树，如果遇到某个节点 $i$ 在删掉父亲的情况下可以被 $y$ 走到，且 $x$ 不在其父亲的子树内，就说明其及其子树的受支配集都会发生改变；否则继续向下遍历即可。

注意 $1$ 的受支配集永远不会被改变。

于是我们便可以 $O(n^2)$ 预处理后 $O(n)$ 处理单次询问了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3005;
const int K=14;
const int M=N<<1;
int n,m,q,g[N],fa[N][K],dep[N],siz[N],f[N],dfn[N],dtot;
bool can[N],vis[N],zhi[N][N],shan[N][N];
struct node{
    int to[M],next[M],head[N],tot;
    void adde(int u,int v){
        to[++tot]=v,next[tot]=head[u],head[u]=tot;
    }
}S,T,F;
int read(){
    int w=0,f=1;
    char ch=getchar();
    while (ch>'9'||ch<'0') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        w=(w<<3)+(w<<1)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
void dfs(int u,int ban){
    if (u==ban) return;
    can[u]=1;
    for (int i=S.head[u];i;i=S.next[i]){
        int v=S.to[i];
        if (can[v]) continue;
        dfs(v,ban);
    }
}
void dfs2(int u){
    siz[u]=1,dfn[u]=++dtot;
    for (int i=T.head[u];i;i=T.next[i]){
        int v=T.to[i];
        dep[v]=dep[u]+1;
        fa[v][0]=u;
        for (int j=1;(1<<j)<=dep[v];j++) fa[v][j]=fa[fa[v][j-1]][j-1];
        dfs2(v);
        siz[u]+=siz[v];
    }
}
int getlca(int x,int y){
    if (dep[x]<dep[y]) swap(x,y);
    for (int i=13;i>=0;i--)
        if (dep[x]-(1<<i)>=dep[y]) x=fa[x][i];
    if (x==y) return x;
    for (int i=13;i>=0;i--)
        if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
void dfs3(int u,int ban,int fr){
    if (u==ban) return;
    shan[fr][u]=1;
    for (int i=F.head[u];i;i=F.next[i]){
        int v=F.to[i];
        if (!shan[fr][v]) dfs3(v,ban,fr);
    }
}
void build(){
    for (int i=1;i<=n;i++){
        memset(can,0,sizeof(can));
        dfs(1,i);
        for (int j=1;j<=n;j++)
            if (!can[j]) zhi[j][i]=1,++g[j];
    }
    for (int i=2;i<=n;i++){
        int maxn=0,id=0;
        for (int j=1;j<=n;j++){
            if (i==j||!zhi[i][j]) continue;
            if (g[j]>maxn) maxn=g[j],id=j;
        }
        T.adde(id,i),f[i]=id;
    }
    dfs2(1);
    for (int i=1;i<=n;i++){
        dfs3(i,f[i],i);
    }
}
int dfs4(int u,int x,int y){
    if (u!=1&&!(dfn[f[u]]<=dfn[x]&&dfn[x]<=dfn[f[u]]+siz[f[u]]-1)&&shan[u][y]) return siz[u];
    int sum=0;
    for (int i=T.head[u];i;i=T.next[i]){
        int v=T.to[i];
        sum+=dfs4(v,x,y);
    }
    return sum;
}
int main(){
#ifndef ONLINE_JUDGE
    //freopen("testdata.in","r",stdin);
    //freopen("out.out","w",stdout);
#endif
    n=read(),m=read(),q=read();
    for (int i=1;i<=m;i++){
        int u=read(),v=read();
        S.adde(u,v),F.adde(v,u);
    }
    build();
    while (q--){
        int x=read(),y=read();
        if (x==f[y]){
            puts("0");
            continue;
        }
        cout<<dfs4(1,x,y)<<'\n';
    }
    return 0;
}
```

---

## 作者：小木虫 (赞：1)

### Preface  
一道与支配树相关的图论好题。  
### Problem  
给定有向图 $G$，保证从 1 号点可以到达任何点。  
定义 $u$ 支配 $v$ 当且仅当从 1 号点到 $v$ 点的所有路径都包含 $u$。  
特别地，每个点包含其本身。  
给定 $q$ 次询问，每次加一条边（询问互不干扰)，问加完这条边有多少点的支配点集改变。  
要求算法复杂度 $O(nq)$ 以下。  
### Solution  
说实话本蒟第一眼看到这题是没什么思路的，之后才知道还有支配树这种神奇的东西，那么就让我们看看什么是支配树。  
首先，我们知道支配关系是链式传递的，什么意思呢？  
如果 $u$ 支配 $v$，$v$ 支配 $w$，那么 $u$ 支配 $w$。  
其实很好理解：支配意味着这个点为瓶颈，而瓶颈是一定只有一个点的，一个点的前面有两个瓶颈的情况不可能出现，那么把这些瓶颈放在一起肯定组成一条链。 

这个性质贼重要。  
这意味着在一条上述的链上，越往后的点的支配集就越大。  
并且这样的支配关系若视为无向则不存在环。  
不存在环的单向支配关系....  
似乎很像一个从根向下的单向树。  
那么我们可以将这棵树建出来，这就是传说中的支配树。  
先 $O(n^2)$ 删除每个点之后搜索暴力求出每个点的支配集。  
具体的建树过程是反复执行下述指令直到队列空：  
1.取出队列顶部，将所有支配集内有该点的点的支配集全部抹去该点。  
2.将所有支配集仅有其本身的点全部入队。  
3.弹出该点。  
很好理解，这里不多做赘述。  

现在我们有了这棵树，然后呢？  
有什么用吗？  
在树上连边求解？可是树上的边是支配关系，跟边本质不一样啊！  
欸，现在就有意思了。  
观察以下一个点在什么情况下对答案有贡献？  
可以不通过其的一个祖先从 1 点到该点。  
那么很显然，只要有一个点与其父亲满足这玩意，整个子树都可以加入答案了，因为有支配关系就意味着连通。  
这是从正面证明这个方法是对的，即不错算。  
接下来从反面证明这个方法是对的，即不漏算。  
在前文我们说过瓶颈是链状的，也就是说如果不通过一个点的爷爷可以到其但父亲不可以，这要分类讨论：  
1.如果那条边不通过爷爷，直接向该点的父亲后面的点连上去了，那么题设不成立。  
2.如果那条边不通过爷爷，向该点的父亲前面连上去了，那么在递归到父亲的时候答案就被计算了，题设依旧不成立。

那加边怎么办呢？  
加边有贡献的时候在于这个边的两个端点本身不连通，但是加上这条边就联通了。  
于是我们预处理出删除这个父亲后 1 点能到达的点与哪些点能够到达该点。  
到时候只要边能把这两个集连起来就可以了。  
于是这题做完了，可恶的出题人卡常，用 bitset 挡一下。  
code：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e3+10;
int n,m,q,u,v,s,t;
vector <int> edge[N];
vector <int> neg[N];
bitset <N> con[N];int son[N];
vector <int> tree[N];
bool vis[N];int sz[N];
void build(int u,int d,bool opt){
	if(u==d)return;if(vis[u])return;vis[u]=true;
	if(opt==0)for(int i=0;i<edge[u].size();i++)build(edge[u][i],d,opt);
	else for(int i=0;i<neg[u].size();i++)build(neg[u][i],d,opt);
}
queue <int> Q;
bitset <N> from[N];
bitset <N> to[N];
void dfs(int u,int fa){
	son[u]=1;
	for(int i=0;i<tree[u].size();i++){
		int v=tree[u][i];
		if(v==fa)continue;
		dfs(v,u);son[u]+=son[v];
	}
	memset(vis,false,sizeof(vis));
	build(1,fa,0);
	for(int i=1;i<=n;i++){
		if(vis[i])from[u][i]=true;
	}
	memset(vis,false,sizeof(vis));
	build(u,fa,1);
	for(int i=1;i<=n;i++){
		if(vis[i])to[u][i]=true;
	}
}
int query(int u,int fa,int s,int t){
	if(u!=1&&from[u][s]&&to[u][t])return son[u];
	int res=0;
	for(int i=0;i<tree[u].size();i++){
		int v=tree[u][i];
		if(v==fa)continue;
		res+=query(v,u,s,t);
	}
	return res;
}
int main(){
	//freopen("P7520_2.in","r",stdin);
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		edge[u].push_back(v);
		neg[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		memset(vis,false,sizeof(vis));
		build(1,i,0);
		for(int j=1;j<=n;j++)
			if(!vis[j])con[j][i]=true,sz[j]++;
	}
	Q.push(1);
	while(!Q.empty()){
		int u=Q.front();Q.pop();sz[u]--;
		for(int i=1;i<=n;i++){
			if(con[i][u]){
				sz[i]--;con[i][u]=false;
				if(sz[i]==1)Q.push(i),tree[u].push_back(i);
			}
		}
	}
	dfs(1,0);
	for(int i=1;i<=q;i++){
		scanf("%d%d",&s,&t);
		printf("%d\n",query(1,0,s,t));
	}
	return 0;
}
```


---

## 作者：BFSDFS123 (赞：0)

### Part 1 支配树 ###

我们对“支配”进行重新定义：

在一个有向图 $G$ 中，对于两个点 $u,v$，若删除节点 $u$，起点无法到达 $v$，则称 $u$ 支配 $v$。

支配具有传递性，若 $u$ 支配 $v$，$v$ 支配 $w$，则 $u$ 一定支配 $w$。显然，删掉 $u$，则 $v$ 无法到达；若 $v$ 无法到达，则 $w$ 也无法到达。

还有一个性质，若 $u$ 支配 $w$，$v$ 支配 $w$，则 $u,v$ 之间一定有支配关系。

则我们可以建一颗树，即支配树。支配树上某个节点的父亲节点为节点受支配集中支配集最大的一个。

建树可以用  Lengauer Tarjan 算法在 $O(n \log n)$ 内建树，但是这道题中我们可以 $O(n^2)$ 建树（枚举删除的点，再 dfs 判断哪些点不能到达）。

### Part2 题解 ###

题目需要我们求受支配集会变化的点的个数。且询问相互独立。

根据建树的方法以及支配的传递性，我们可以得到，某个点的父亲节点受支配集改变后，他的受支配集也会改变。

同时当我们加入一条边 $u\to v$，若对于一个点 $x$，有 $1\to u \to v\to x$ 可行且 $u,v$ 都不为 $x$ 的父亲节点，则 $x$ 节点的受支配集也会改变。

然后因为这道题数据比较小，综合上面的两种情况，我们只需要暴力 dfs 就行了。

具体做法：

- 首先 $O(n^2)$ 预处理出所有节点的支配集和受支配集。
- 建支配树，同时计算支配树每个节点的子树大小。
- 查询的时候，暴力在支配树上 dfs，遍历到 $x$ 节点时，若节点 $1$ 与节点 $u$ 之间有边，且节点 $v$ 与节点 $x$ 之间有边，那么节点 $x$ 及 $x$ 的子树内的所有点的受支配集会改变。

注意判断一下 $u$ 或 $v$ 等于 $x$ 的父节点的情况，这种情况下 $x$ 的支配集不会变。

然后我的写法有点被卡常，每次会因为评测机波动随机 TLE 几个点。然后加了个快读就过了。

[代码](https://www.luogu.com.cn/paste/zozljhyi)。

---

## 作者：Leasier (赞：0)

看到支配关系，首先建出支配树。这里因为 $n$ 很小，我们可以直接暴力：

- 对于每个 $i$，找出从 $1$ 出发不经过 $i$ 无法到达的点。将 $i$ 加入这些点的被支配集。
- 由于一个点的被支配集的大小为其在支配树上的父亲的被支配集的大小 $+ 1$，则我们可以对于每个点，在被支配集上找到满足该条件的**唯一**一点作为父亲。

现在我们来考虑一下什么时候被支配集的大小会发生变化。

- 若存在 $fa_u$ 本来支配 $u$，但现在存在一条 $1 \to x \to y \to u$ 的路径且没经过 $fa_u$，则 $u$ 的被支配集会发生变化。
- $u$ 在支配树上的一个祖先 $v$ 的被支配集发生的变化同样会对 $u$ 产生影响。

预处理点对可达性，询问时先判断第一种情况，然后 dfs 处理第二种情况即可。时间复杂度为 $O(n(n + q))$。

代码：
```cpp
#include <iostream>
#include <vector>

using namespace std;

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt1 = 0, cnt2 = 0, cnt3 = 0;
int head1[3007], head2[3007], fa[3007], head3[3007];
bool vis1[3007][3007], vis2[3007][3007], mark[3007];
Edge edge1[6007], edge2[6007], edge3[3007];
vector<int> v[3007];

inline void add_edge1(int start, int end){
	cnt1++;
	edge1[cnt1].nxt = head1[start];
	head1[start] = cnt1;
	edge1[cnt1].end = end;
}

inline void add_edge2(int start, int end){
	cnt2++;
	edge2[cnt2].nxt = head2[start];
	head2[start] = cnt2;
	edge2[cnt2].end = end;
}

void dfs1(int u, int v){
	if (u == v) return;
	vis1[u][v] = true;
	for (register int i = head1[u]; i != 0; i = edge1[i].nxt){
		int x = edge1[i].end;
		if (!vis1[x][v]) dfs1(x, v);
	}
}

void dfs2(int u, int v){
	vis2[u][v] = true;
	for (register int i = head2[u]; i != 0; i = edge2[i].nxt){
		int x = edge2[i].end;
		if (x != fa[v] && !vis2[x][v]) dfs2(x, v);
	}
}

inline void add_edge3(int start, int end){
	cnt3++;
	edge3[cnt3].nxt = head3[start];
	head3[start] = cnt3;
	edge3[cnt3].end = end;
}

void dfs3(int u){
	for (register int i = head3[u]; i != 0; i = edge3[i].nxt){
		int x = edge3[i].end;
		mark[x] |= mark[u];
		dfs3(x);
	}
}

int main(){
	int n, m, q;
	cin >> n >> m >> q;
	for (register int i = 1; i <= m; i++){
		int x, y;
		cin >> x >> y;
		add_edge1(x, y);
		add_edge2(y, x);
	}
	for (register int i = 1; i <= n; i++){
		dfs1(1, i);
		for (register int j = 1; j <= n; j++){
			if (!vis1[j][i]) v[j].push_back(i);
		}
	}
	for (register int i = 2; i <= n; i++){
		int size = v[i].size();
		for (register int j = 0; j < size; j++){
			int x = v[i][j];
			if (v[x].size() + 1 == size){
				fa[i] = x;
				break;
			}
		}
	}
	for (register int i = 2; i <= n; i++){
		dfs2(i, i);
	}
	for (register int i = 2; i <= n; i++){
		add_edge3(fa[i], i);
	}
	for (register int i = 1; i <= q; i++){
		int x, y, ans = 0;
		cin >> x >> y;
		for (register int j = 2; j <= n; j++){
			mark[j] = vis1[x][fa[j]] && vis2[y][j];
		}
		dfs3(1);
		for (register int j = 2; j <= n; j++){
			if (mark[j]) ans++;
		}
		cout << ans << endl;
	}
	return 0;
}
```

---


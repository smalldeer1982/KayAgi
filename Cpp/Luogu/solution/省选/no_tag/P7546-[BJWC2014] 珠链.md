# [BJWC2014] 珠链

## 题目描述

Alex 喜欢玩网络游戏，认为这是智力和体力的综合锻炼。在一次游戏活动中，他意外获得了一个传说中威力极其强大的法宝：珠链。 

珠链，顾名思义，就是由许多小珠子串起来的一条链。珠子有很多种颜色。Alex 听说过，只有将珠链打磨纯净，珠链才能发挥最大的威力。 

纯净珠链是指这样的珠链：它可以分成若干个长度相等的段，使任何两段的任何相同位置的珠子的颜色均不同，相同位置指珠子在段内的相对位置相同；而且每段的长度以及划分的段数也是有规范的，Alex 记得，每段包含的珠子数目必须在 $L$ 到 $R$ 之间，而且划分的段数不能少于 $S$。 

所谓打磨，就是从珠链的首和尾拿掉连续的若干个珠子。打磨后的纯净珠链的威力等于它的每个珠子具有的魔力值之和。

一个珠子的魔力值只与它在打磨前的珠链中的位置有关。在查找和分析了大量实验数据以后，Alex 发现珠子的魔力值等于珠子原来位置编号的约数个数！ 

兴奋不已的 Alex 想将珠链打磨成威力最大的纯净珠链。然而，马上要参加期末考试的 Alex 来不及计算了，你能否帮助 Alex 算出最大的威力值呢？ 

## 说明/提示

#### 【样例解释】

能够打磨出的合乎要求的纯净珠链有三种：$\texttt{bc/aa}$，$\texttt{abc/bca}$ 和 $\texttt{bcb/caa}$。其中威力最大的是第三种，其威力值等于 $2 + 2 + 3 + 2 + 4 + 2 = 15$。

如果给出的珠链是纯净珠链，那么可以不打磨。纯净珠链必须能划分成不少于 $S$ 个等长的段且每段长度在 $L$ 到 $R$ 之间。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 5 \cdot 10^5$，$1 \le L,R,S \le N$，$0 \le R - L \le 10$。

## 样例 #1

### 输入

```
7 2 3 2
abcbcaa```

### 输出

```
15```

# 题解

## 作者：henryhu2006 (赞：1)

## 题意概括
定义字符串一个位置的魔力值等于下标的约数个数，字符串的一个**连续子串**的魔力值为各个位置的魔力值之和。

定义字符串的一个连续子串是纯净的，当且仅当可以将这个子串分为**等长的** $x$ 段，每段长度为 $len$，任意两段的相同位置的字符不同，且要求 $x\ge S$, $len\in [l,r]$。

求纯净的连续子串中最大魔力值。

数据范围：$n\le 5\times 10^5$，$r-l\le10$，字符集大小为 $52$。

## 题解
发现 $r-l\le10$，因此可以枚举段的长度。

考虑以 $l$ 为左端点的连续子串，对于任意 $r_1,r_2$，$l\le r_1<r_2$，当 $[l,r_1]$ 和 $[l,r_2]$ 均纯净时，$[l,r_1]$ 的代价必然小于 $[l,r_2]$，因为约数个数不可能是非正的。

对于每个位置，无论它处于哪个子串，导致不纯净的一定是在模 $len$ 意义下和它同模的坐标。

定义 $suf_i=\min \{j|j>i,j \equiv i\  (\text{mod} \  len) ,s_j=s_i\}$。

$suf$ 可用一个 $len\times 52$ 的二维数组来预处理，不多赘述。

接着枚举 $l$，则最大段数为 $x=\lfloor \frac{\min_{i=l}^{n}suf_i}{len} \rfloor$，如果 $x\ge S$，那么以 $[l,l+x\times len-1]$ 更新答案。

一开始预处理一下约数个数的前缀和，总时间复杂度 $\Theta((r-l)\times 52n)$，精细实现可以做到 $\Theta((r-l)\times n)$。

## 代码
细节：不能将 $len$ 和 $S$ 无脑相乘，会爆 `int`。

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
const int N=5e5+5;
int n,l,r,S,ans;
int num[N],vis[N],sum[N];
int now[N][52],suf[N];
char s[N];
int main(){
	cin>>n>>l>>r>>S;
	scanf("%s",s+1),num[1]=1;
	for(rint i=1;i<=n;++i)
		if(s[i]>='a') s[i]-='a'-26;
		else s[i]-='A'; // 压缩字符集
	for(rint i=2;i<=n;++i){
		if(!vis[i]) vis[i]=i;
		rint cnt=0,j=i;
		while(j%vis[i]==0) j/=vis[i],++cnt;
		num[i]=num[j]*(cnt+1);
		if(num[i]>2) continue;
		for(j=i*2;j<=n;j+=i) vis[j]=i; // 处理约数个数
	}
	for(rint i=1;i<=n;++i)
		sum[i]=sum[i-1]+num[i];
	for(rint len=l;len<=r;++len){
		if(1ll*len*S>n) break;
		memset(now,0,208*(len+1)); // memset 乘以 52 也跑得飞快
		memset(suf,0,sizeof(suf));
		for(rint j=n,mo=n%len,res=n+1;j>=1;--j,--mo){
			if(mo<0) mo=len-1;
			if(now[mo][s[j]]) suf[j]=now[mo][s[j]];
			else suf[j]=n+1;
			res=min(res,suf[j]);
			int zq=(res-j)/len;
			if(zq>=S) ans=max(ans,sum[j+zq*len-1]-sum[j-1]);
			now[mo][s[j]]=j;
		}
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：wmy_goes_to_thu (赞：0)

这是一道水题。

因为 $R-L\leq 10$，所以我们可以考虑枚举。

显然，对于每个字母和每一种长度需要记录一下它往右能跑多远，这个数字不会超过 $52$。

枚举左端点，枚举第一段长度，用单调队列维护区间最小值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[500005];
int f[13][500005],vist[205],q[500005];
long long d[500005];
int main()
{
	int n,l,r,s;
	cin>>n>>l>>r>>s;
	scanf("%s",c+1);
	for(int i=1;i<=n;i++)for(int j=i;j<=n;j+=i)d[j]++;
	for(int i=1;i<=n;i++)d[i]+=d[i-1];
	for(int i=l;i<=r;i++)for(int j=1;j<=n;j++)
	{
		int x=j,cnt=0;
		while(x<=n&&!vist[c[x]])
		{
			vist[c[x]]=1;
			x+=i,cnt++;
		}
		f[i-l][j]=cnt;
		for(int k=j;k<x;k+=i)vist[c[k]]=0;
	}
	long long ans=-1ll;
	for(int j=l;j<=r;j++)
	{
		int head=0,tail=-1;
		for(int k=1;k<j;k++)
		{
			while(head<=tail&&k-q[head]>=j)head++;
			while(head<=tail&&f[j-l][q[tail]]>=f[j-l][k])tail--;
			q[++tail]=k;
		}
		for(int i=1;i<=n-j+1;i++)
		{
			while(head<=tail&&i>=q[head]+1)head++;
			while(head<=tail&&f[j-l][q[tail]]>=f[j-l][i+j-1])tail--;
			q[++tail]=i+j-1;
			int aa=f[j-l][q[head]];
			if(aa<s)continue;
			ans=max(ans,d[i+aa*j-1]-d[i-1]);
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---


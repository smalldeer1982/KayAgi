# [JOISC 2021] フードコート (Day1)

## 题目背景

本题数据保留一部分，请在 [此处](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day1/foodcourt-data.zip) 获取完整数据。

## 题目描述

有 $N$ 家书虫食品店，有 $M$ 个家庭来享受用书虫制作的美味食物。

因为食品店十分火爆，所以顾客需要排队，刚开始所有队列都是空的。

今天食品店又全部开张了，发生了 $Q$ 个事件：

- **加入事件**：编号位于区间 $[L,R]$ 内的所有食品店中，都有编号为 $C$ 的家庭加入队尾，每个满足要求的食品店队尾都加入了 $K$ 个人。
- **离开事件**：编号位于区间 $[L,R]$ 内的所有食品店中，如果队列有超过 $K$ 个人，那么队列的前 $K$ 个人离开队列，否则队列里的所有人离开队列。
- **白嫖事件**：如果编号为 $A$ 的食品店的队列中有大于等于 $B$ 个人，那么食品店就会赠送从队列开头开始数第 $B$ 个人一份秘制书虫，否则店员会吃掉书虫。

求每次 **白嫖事件** 是否有顾客被赠送了秘制书虫，如果有的话，求顾客所在的家庭。

## 说明/提示

#### 样例 1 解释

我们用 $Q_i(a_1,a_2,\cdots,a_k)$ 代表第 $i$ 个食品店的队列，$a_1$ 为队首，$a_k$ 为队尾，其中 $a_i=p$ 就代表第 $i$ 个位置的人来自第 $p$ 个家庭。特殊地，$Q_i()$ 就代表当前队列为空。

根据样例 1 的这几个事件：

- 第 $1$ 个 **加入事件**：

$$Q_1(),Q_2(5,5),Q_3(5,5)$$

- 第 $2$ 个 **加入事件**：

$$Q_1(2,2,2,2),Q_2(5,5,2,2,2,2),Q_3(5,5)$$

- 第 $3$ 个 **白嫖事件**，第 $2$ 个食品店的第 $3$ 个人（第 $2$ 个家庭）被送上秘制书虫。
- 第 $4$ 个 **离开事件**：

$$Q_1(2),Q_2(2,2,2),Q_3()$$

- 第 $5$ 个 **白嫖事件**，第 $1$ 个食品店不够 $2$ 个人，店员会吃掉书虫。
- 第 $6$ 个 **加入事件**：

$$Q_1(2),Q_2(2,2,2,4,4),Q_3(4,4)$$

- 第 $7$ 个 **白嫖事件**，第 $3$ 个食品店的第 $2$ 个人（第 $4$ 个家庭）被送上秘制书虫。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（2 pts）：$N,Q \le 2000$，满足性质 A。
- Subtask 2（5 pts）：$N,Q \le 2000$。
- Subtask 3（7 pts）：$N,Q \le 65000$，满足性质 B。
- Subtask 4（21 pts）：$M=1$。
- Subtask 5（15 pts）：$N,Q \le 65000$，满足性质 A。
- Subtask 6（13 pts）：$N,Q \le 65000$，满足性质 C。
- Subtask 7（26 pts）：$N,Q \le 65000$。
- Subtask 8（11 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $1 \le N,M,Q \le 25 \times 10^4$。
- $T \in \{1,2,3\}$。
- 对于所有 **加入事件**，$1 \le L \le R \le N$，$1 \le C \le M$，$1 \le K \le 10^9$。
- 对于所有 **离开事件**，$1 \le L \le R \le N$，$1 \le K \le 10^9$。
- 对于所有 **白嫖事件**，$1 \le A \le N$，$1 \le B \le 10^{15}$。
- 至少有一个 **白嫖事件**。

有以下若干个性质：

- 性质 A：对于所有 **加入事件** 和 **离开事件**，有 $K=1$。
- 性质 B：对于所有 **加入事件**，有 $R-L \le  10$ 和 $K=1$。
- 性质 C：只有 **加入事件** 和 **白嫖事件**。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day1 C フードコート (Food Court) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day1/foodcourt-en.pdf)。

## 样例 #1

### 输入

```
3 5 7
1 2 3 5 2
1 1 2 2 4
3 2 3
2 1 3 3
3 1 2
1 2 3 4 2
3 3 2```

### 输出

```
2
0
4```

## 样例 #2

### 输入

```
3 4 7
1 1 2 1 1
1 1 3 4 1
2 2 3 1
2 1 3 1
1 1 2 2 1
3 1 1
3 3 2```

### 输出

```
4
0```

## 样例 #3

### 输入

```
183326 218318 22
1 106761 160918 151683 574906362
3 68709 1
1 29240 156379 22166 957318472
1 14054 181502 82845 97183925
2 112033 122908 587808357
2 57819 160939 215041262
3 36674 524274467
1 35854 69866 32334 322730299
1 1384 7230 115069 454256926
1 44192 158235 8750 84192710
3 54457 1077490708
2 10592 110384 979714505
2 44594 79244 311724477
3 160965 97183926
1 88748 101697 39148 373927458
3 41166 58039001
1 91501 137591 205480 958877326
2 77775 169655 135756956
1 12497 57047 60918 15666764
1 47839 51716 144688 732270998
3 114514 774994894
3 48645 169986425```

### 输出

```
0
22166
32334
0
82845
8750
60918```

# 题解

## 作者：KingPowers (赞：11)

[题目链接](https://www.luogu.com.cn/problem/P7560)

从去 ZR 第二天起就留下的坑，今天算是给填完了。

个人实现不易，点个赞吧（悲。

提前约定：下文视 $n,m,q$ 同阶。

注意到离开事件是个很烦人的东西，我们不妨先思考下该如何先将它处理掉。

对于每个食品店，我们不妨维护两个东西：总共加入过的人数和当前的人数。对于总共加入的人数，我们相当于是要在每次加入操作时支持一个区间加，线段树可以轻松解决。那么当前的人数又该如何维护呢？

记当前第 $i$ 个食品店的人数为 $a_i$，不难发现，离开操作的实质其实是 $a_i\leftarrow\max(a_i-k,0),i\in[l,r]$。注意到这题是单点查询，所以完全没必要写吉司机线段树。想起来高爸当时讲了一个比较精妙的维护一个二元标记的方法，但是现在记得不太清楚了，于是我沿用了[这一道题](https://www.luogu.com.cn/problem/P8024)的做法，暴力维护加法标记和 $\max$ 标记，然后将每次离开事件拆成区间减 $k$、区间对 $0$ 取 $\max$ 两步。

维护这两个东西有什么用呢？我们记 $del_i$ 表示第 $i$ 个食品店已经离开了多少人，不难发现 $del_i$ 其实就是总人数与当前人数之差，而对于一个白嫖事件 $(A,B)$，我们可以将其转化为：不考虑离开事件的前提下，食品店 $A$ 的第 $B+del_i$ 个人是谁。

这样，我们就成功地找到了离开事件的处理方法，现在只需要考虑性质 $C$ 怎么做就可以了。

现在我们解决问题的思路很明了了：对于每个白嫖事件，我们只要找出第一个使食品店 $A$ 的加入过的总人数大于等于 $B+del_i$ 的修改操作，这次修改操作加入的人就是我们要的答案。使用整体二分或者树套树之类的东西大概可以直接 $O(n\log^2n)$ 解决掉，但其实没必要。

不妨考虑离线。对于每个白嫖事件，我们直接把它先挂到对应食品店的 `vector` 上；对于每个加入事件，我们将它差分一下：相当于是第 $l$ 个食品店在 $[i,q]$ 时间段内总人数多了 $k$，第 $r+1$ 个食品店在 $[i,q]$ 时间段内总人数少了 $k$，同样挂到对应 `vector` 上处理。然后直接再开一棵线段树，维护每个时间点内某个食品店的总人数，直接扫描线扫过每个食品店，每次询问在线段树上二分即可。

上面这一段可能有点抽象，结合代码应该会好理解很多。

最后理一遍思路：

- 用一棵支持区间加、单点查询的线段树维护每个食品店的总共加入过的人数。

- 用一棵支持区间加、区间取 $\max$ 的线段树维护每个食品店当前的人数。

- 将修改和询问操作离线，用一棵支持区间加、查询第一个大于等于某数的位置（可以线段树上二分）的线段树维护每个食堂在每个时间点的总人数。

注意：以上三棵线段树在代码中分别对应 $T_1,T_3,T_2$。

时间复杂度：$O(n\log n)$。

代码大概 4.5k，也不是很长。

```cpp
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
#define Mp make_pair
#define pb emplace_back
#define For(i,a,b) for(int i=(a);i<=(b);i++)
#define Rof(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
const int N=1e6+5;
const int mod=1e9+7;
const int inf=1e9;
int n,m,q,c[N],ans[N];
bool lmt[N];
vector<pii>cha[N],que[N];
struct Segment_Tree1{
    #define ls now<<1
    #define rs now<<1|1
    int mx[N],tag[N];
    void pushup(int now){mx[now]=max(mx[ls],mx[rs]);};
    void pushdown(int now){
        if(tag[now]){
            mx[ls]+=tag[now];tag[ls]+=tag[now];
            mx[rs]+=tag[now];tag[rs]+=tag[now];
            tag[now]=0;
        }
    }
    void modify_add(int x,int y,int k,int l,int r,int now){
        if(x<=l&&r<=y){
            mx[now]+=k;tag[now]+=k;
            return;
        }
        pushdown(now);
        int mid=(l+r)>>1;
        if(x<=mid) modify_add(x,y,k,l,mid,ls);
        if(y>mid) modify_add(x,y,k,mid+1,r,rs);
        pushup(now);
    }
    int query(int pos,int l,int r,int now){
        if(l==r) return mx[now];
        pushdown(now);
        int mid=(l+r)>>1;
        if(pos<=mid) return query(pos,l,mid,ls);
        return query(pos,mid+1,r,rs);
    }
    int find(int k,int l,int r,int now){
        if(mx[now]<k) return 0;
        if(l==r) return l;
        pushdown(now);
        int mid=(l+r)>>1;
        if(mx[ls]>=k) return find(k,l,mid,ls);
        return find(k,mid+1,r,rs);
    }
    #undef ls
    #undef rs
}T1,T2;
struct Segment_Tree2{
    #define ls now<<1
    #define rs now<<1|1
    int mx[N],tag1[N],tag2[N];
    void pushup(int now){mx[now]=max(mx[ls],mx[rs]);};
    void pushdown(int now){
        if(tag1[now]){
            mx[ls]+=tag1[now];mx[rs]+=tag1[now];
            tag1[ls]+=tag1[now];tag1[rs]+=tag1[now];
            if(tag2[ls]!=-inf) tag2[ls]+=tag1[now];
            if(tag2[rs]!=-inf) tag2[rs]+=tag1[now];
            tag1[now]=0;
        }
        if(tag2[now]!=-inf){
            mx[ls]=max(mx[ls],tag2[now]);mx[rs]=max(mx[rs],tag2[now]);
            tag2[ls]=max(tag2[ls],tag2[now]);tag2[rs]=max(tag2[rs],tag2[now]);
            tag2[now]=-inf;
        }
    }
    void build(int l,int r,int now){
        tag1[now]=0;tag2[now]=-inf;
        if(l==r) return mx[now]=0,void();
        int mid=(l+r)>>1;
        build(l,mid,ls);build(mid+1,r,rs);
        pushup(now);
    }
    void modify_add(int x,int y,int k,int l,int r,int now){
        if(x<=l&&r<=y){
            mx[now]+=k;tag1[now]+=k;
            if(tag2[now]!=-inf) tag2[now]+=k;
            return;
        }
        pushdown(now);
        int mid=(l+r)>>1;
        if(x<=mid) modify_add(x,y,k,l,mid,ls);
        if(y>mid) modify_add(x,y,k,mid+1,r,rs);
        pushup(now);
    }
    void modify_max(int x,int y,int k,int l,int r,int now){
        if(x<=l&&r<=y){
            mx[now]=max(mx[now],k);
            tag2[now]=max(tag2[now],k);
            return;
        }
        pushdown(now);
        int mid=(l+r)>>1;
        if(x<=mid) modify_max(x,y,k,l,mid,ls);
        if(y>mid) modify_max(x,y,k,mid+1,r,rs);
        pushup(now);
    }
    int query(int pos,int l,int r,int now){
        if(l==r) return mx[now];
        pushdown(now);
        int mid=(l+r)>>1;
        if(pos<=mid) return query(pos,l,mid,ls);
        return query(pos,mid+1,r,rs);
    }
    #undef ls
    #undef rs
}T3;
void Main(){
    cin>>n>>m>>q;
    T3.build(1,n,1);
    For(i,1,q){
        int opt,l,r,k,a,b;
        cin>>opt;
        if(opt==1){
            cin>>l>>r>>c[i]>>k;
            T1.modify_add(l,r,k,1,n,1);
            T3.modify_add(l,r,k,1,n,1);
            cha[l].pb(i,k);cha[r+1].pb(i,-k);
        }
        else if(opt==2){
            cin>>l>>r>>k;
            T3.modify_add(l,r,-k,1,n,1);
            T3.modify_max(l,r,0,1,n,1);
        }
        else{
            cin>>a>>b;lmt[i]=1;
            que[a].pb(i,b+T1.query(a,1,n,1)-T3.query(a,1,n,1));
        }
    }
    For(i,1,n){
        for(pii x:cha[i]) T2.modify_add(x.fi,q,x.se,1,q,1);
        for(pii x:que[i]) ans[x.fi]=T2.find(x.se,1,q,1);
    }
    For(i,1,q) if(lmt[i]){
        if(ans[i]>i) cout<<0<<'\n';
        else cout<<c[ans[i]]<<'\n';
    }
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int T=1;//cin>>T;
    while(T--) Main();
    return 0;
}
```

---

## 作者：XLao (赞：9)

从 C9 爷的[整体二分教程](https://www.luogu.com.cn/blog/78372/parallel-binsearch)来的。强烈推荐！

---

宣传一下 Cirno_9 单 $\log$ 的整体二分。

前面[这篇题解](https://www.luogu.com.cn/blog/534654/solution-P7560)讲的非常清楚。我和他一样，先算出每个询问对应队列的离开人数。

整体二分，二分到第几个操作的时候，可以使该队列 **加入人数`-`离开人数** 有大于等于 $B$ 个人。那次加入操作的家庭就是答案。

但是整体二分时候，我们用树状数组维护区间加的部分其实不必要。

每次区间加只作用两个点。每次询问位置 $x$ ，只有 $[1,x]$ 的点会影响他。

那我们把这些作用点和询问点先排好序，一起放进去二分，。然后顺序扫过去，询问点之前的作用用一个变量（代码里的`now`）存起来就好了。分治的时候也自然地保持了有序。

几个细节：

- 在 $x$ 上的作用点会影响询问 $x$，排序时候要注意

- 注意判断书虫会不会被吃

- ~~然后就想不到细节了，都是比较平凡的维护~~

人傻常数大，好像和双 $\log$ 老哥们差不多 /kk。教教。

不会封装，凑合看吧：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
ll read()
{
	char c=getchar(); ll res=0, f=1;
	while(!isdigit(c)) {if(c=='-') f=-1; c=getchar();}
	while(isdigit(c)) {res=(res<<3)+(res<<1)+(c^48); c=getchar();}
	return res*f;
}
void write(int x)
{
	if(x<0) x=-x, putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

const int N=3e5;
const ll inf=1e18;

int n,m,Q;

struct segtree {ll maxx,atag,btag;} t[N<<2];
#define ls (pos<<1)
#define rs (pos<<1|1)
#define mid ((l+r)>>1)
void pushup(int pos) {t[pos].maxx = max(t[ls].maxx, t[rs].maxx);}
void build(int pos,int l,int r)
{
	t[pos].btag=-inf;
	if(l==r) return;
	build(ls,l,mid); build(rs,mid+1,r);
}
void change(int pos,segtree x)
{
	t[pos].maxx+=x.atag; t[pos].atag+=x.atag;
	if(t[pos].btag>-inf) t[pos].btag+=x.atag;
	t[pos].maxx=max(t[pos].maxx, x.btag);
	t[pos].btag=max(t[pos].btag, x.btag);
}
void spread(int pos)
{
	change(ls,t[pos]); change(rs,t[pos]);
	t[pos].atag=0, t[pos].btag=-inf;
}
int ql,qr; segtree Tag;
void updata(int pos,int l,int r)
{
	if(ql<=l && r<=qr) {change(pos,Tag); return;}
	spread(pos);
	if(ql<=mid) updata(ls,l,mid);
	if(qr>mid) updata(rs,mid+1,r);
	pushup(pos);
}
ll ask(int pos,int l,int r)
{
	if(l==r) return t[pos].maxx;
	spread(pos);
	if(ql<=mid) return ask(ls,l,mid);
	else return ask(rs,mid+1,r);
}
#undef ls
#undef rs
#undef mid

ll c[N];
int lowbit(int x) {return x & -x;}
void updata_c(int x,ll y) {for(;x<=n;x+=lowbit(x)) c[x]+=y;}
ll ask_c(int x) {ll res=0; for(;x;x-=lowbit(x)) res+=c[x]; return res;}

struct Que {int l; ll x; int id,tp;} lx[N<<1]; int q,answer[N];
bool cmp(Que x, Que y) {return x.l==y.l ? x.tp<y.tp : x.l<y.l;}

void solve(int ql,int qr,int vl,int vr)
{
	vector<Que> Left; vector<Que> Right;
//	printf("\n%d %d %d %d: !\n",ql,qr,vl,vr);
	int mid=(vl+vr)>>1; ll now=0;
	for(int i=ql;i<=qr;++i)
	{
//		printf("%d %lld %d %d\n",lx[i].l,lx[i].x,lx[i].id,lx[i].tp);
		if(!lx[i].tp)
		{
			if(lx[i].id<=mid) now+=lx[i].x, Left.push_back(lx[i]);
			else Right.push_back(lx[i]);
		}
		else
		{
			if(now>=lx[i].x) answer[lx[i].id]=mid, Left.push_back(lx[i]);
			else lx[i].x-=now, Right.push_back(lx[i]);
		}
	}
	int i=ql;
	for(Que x : Left) lx[i++]=x;
	for(Que x : Right) lx[i++]=x;
	if(vl==vr) return;
	solve(ql,ql+Left.size()-1,vl,mid);
	solve(ql+Left.size(),qr,mid+1,vr);
}

int jt[N];
int main()
{
	n=read(), m=read(), Q=read();
	build(1,1,n);
	for(int i=1,type;i<=Q;++i)
	{
		type=read();
		int y; ll x;
		if(type==1)
		{
			ql=read(), qr=read(), y=read(), x=read();
			lx[++q]=(Que){ql,x,i,0}; lx[++q]=(Que){qr+1,-x,i,0};
			updata_c(ql,x); updata_c(qr+1,-x);
			jt[i]=y;
			Tag=(segtree){0,x,-inf};
			updata(1,1,n);
		}
		if(type==2)
		{
			ql=read(), qr=read(), x=read();
			Tag=(segtree){0,-x,0}; updata(1,1,n);
		}
		if(type==3)
		{
			ql=read(), x=read();
			lx[++q]=(Que){ql, ask_c(ql)-ask(1,1,n)+x, i, 1};
		}
	}
	lx[++q]=(Que){1,inf,Q+1,0};
	sort(lx+1,lx+q+1,cmp);
	solve(1,q,1,Q+1);
	for(int i=1;i<=Q;++i)
	{
		if(answer[i])
		{
			if(answer[i]<i) write(jt[answer[i]]), putchar('\n');
			else puts("0");
		}
	}
}
```

---

## 作者：WrongAnswer_90 (赞：6)

[P7560 [JOISC 2021 Day1] フードコート](https://www.luogu.com.cn/problem/P7560)

[更好的阅读体验](https://www.cnblogs.com/WrongAnswer90-home/p/17814211.html)

神奇的换维扫描线。

直接做十分困难，因为是区间操作，并且清空到 $0$ 之后就不再清空，查询不好处理到底是第几个人。但是如果知道了这个点的操作序列，问题就简单很多。询问是单点查询并且可以离线。综合上面所有因素，考虑换一维扫描线：对序列维扫描，横轴为序列维，纵轴为操作序列即时间维。

一个操作 $1,2$，差分后，看成在 $L$ 处出现，$R+1$ 处消失。现在考虑对于一个序列上的位置，求出了它对应的操作序列之后如何处理。

虽然一个点可能被清空多次，但是我们只关心最后一次清空的位置和之后的操作。有一个性质：如果存在清空，则最后一次清空的位置一定是操作序列的前缀和最小值，原因显然：前一次清空和本次清空之间的和必须为负数才能再次产生清空。

理一下思路：需要维护前缀前缀和最小值，支持动态增删，和找出一个操作位置之后的减的和，找出加的和大于一个值的第一个位置。可以用线段树维护时间维。加、删就直接在对应位置上加减。

对于查询，找出它前面前缀和最小值的位置。如果前缀和最小值非负，则证明没有出现清空操作。找出前面一共走了多少人，然后线段树上二分到对应的加人操作。

如果前缀和最小值小于 $0$，则证明在该位置上清空到了 $0$ 并且是最后一个清空到 $0$ 的位置，在它之后像上面一样计算。

复杂度 $\mathcal O(q\log q)$。

```cpp
	int n,m,q,typ[250010],ans[250010],col[250010];
	struct Node{int pos,x,opt;};
	vector<Node> ve[250010];
	namespace Segment
	{
		struct NNode{int l,r,sum,add,minn,mini;}t[1000010];
		inline void update(int p)
		{
			t[p].minn=min(t[p*2].minn,t[p*2].sum+t[p*2+1].minn);
			if(t[p*2].minn==t[p].minn)t[p].mini=t[p*2].mini;
			else t[p].mini=t[p*2+1].mini;
			t[p].sum=t[p*2].sum+t[p*2+1].sum;
			t[p].add=t[p*2].add+t[p*2+1].add;
		}
		void build(int p,int l,int r)
		{
			t[p].l=l,t[p].r=r;
			if(l==r)return t[p].mini=l,void();
			int mid=l+((r-l)>>1);
			build(p*2,l,mid),build(p*2+1,mid+1,r),update(p);
		}
		void modify(int p,int x,int y,int typ=0)
		{
			if(t[p].l==t[p].r)return t[p].sum+=y,typ?t[p].add+=y:0,t[p].minn=min(0ll,t[p].sum),void();
			if(x<=t[p*2].r)modify(p*2,x,y,typ);else modify(p*2+1,x,y,typ);
			update(p);
		}
		NNode ask(int p,int x)
		{
			if(x>=t[p].r)return t[p];
			if(x<=t[p*2].r)return ask(p*2,x);
			NNode nd=ask(p*2+1,x),ans={0,0,nd.sum+t[p*2].sum,0,min(t[p*2].minn,t[p*2].sum+nd.minn),0};
			if(ans.minn==t[p*2].minn)ans.mini=t[p*2].mini;else ans.mini=nd.mini;
			return ans;
		}
		int query(int p,int st,int &x)
		{
			if(st<=t[p].l)
			{
				if(t[p].add<x)return x-=t[p].add,0;
				if(t[p].l==t[p].r)return t[p].l;
				if(t[p*2].add>=x)
				return query(p*2,st,x);
				x-=t[p*2].add;
				return query(p*2+1,st,x);
			}
			if(st<=t[p*2].r)
			{
				int t=query(p*2,st,x);
				if(t)return t;
			}
			return query(p*2+1,st,x);
		}
		void print(int p)
		{
			if(t[p].l==t[p].r)write(t[p].l),write(t[p].r),write(t[p].sum),write(t[p].add),write(t[p].minn),write(t[p].mini,'\n');
			if(t[p].l==t[p].r)return;
			print(p*2),print(p*2+1);
		}
		int asksum(int p,int l,int r)
		{
			if(l<=t[p].l&&r>=t[p].r)return t[p].sum-t[p].add;
			int s=0;
			if(l<=t[p*2].r)s+=asksum(p*2,l,r);
			if(r>t[p*2].r)s+=asksum(p*2+1,l,r);
			return s;
		}
	}
	using namespace Segment;
	inline void mian()
	{
		read(n,m,q);int opt,x,y,z,t;
		for(int i=1;i<=q;++i)
		{
			read(opt);
			if(opt==1)read(x,y,z,t),col[i]=z,ve[x].eb((Node){i,t,1}),ve[y+1].eb((Node){i,-t,1});
			else if(opt==2)read(x,y,z),ve[x].eb((Node){i,z,2}),ve[y+1].eb((Node){i,-z,2});
			else read(x,y),typ[i]=1,ve[x].eb((Node){i,y,3});
		}
		build(1,1,q);
		for(int i=1;i<=n;++i)
		{
			for(auto nd:ve[i])
			{
				if(nd.opt==1)modify(1,nd.pos,nd.x,1);
				else if(nd.opt==2)modify(1,nd.pos,-nd.x);
				else
				{
					NNode nd2=ask(1,nd.pos);
					if(nd2.minn>=0)
					{
						int cut=-asksum(1,1,nd.pos)+nd.x;
						ans[nd.pos]=query(1,1,cut);
					}
					else 
					{
						int cut=-asksum(1,nd2.mini+1,nd.pos)+nd.x;
						ans[nd.pos]=query(1,nd2.mini+1,cut);
					}
				}
			}
		}
		for(int i=1;i<=q;++i)if(typ[i])write(ans[i]>i?0:col[ans[i]],'\n');
	}
```

---

## 作者：cirnovsky (赞：5)

不是很懂啊，为什么写 ji segtree 啊。

具体做法楼上老哥已经写了，我只做一个补充，因为是单点查询，所以只需要将 segtree 写成一棵完全意义的 leafy tree 即可（就是不用写 pushup 的意思）。

大概意思就是，这个 segment tree beats。首先这里没有必要真的写一个出来，因为注意到是单点询问。但是这里的线段树有一些不同于传统的线段树，尽管传统线段树也是一棵 leafy tree，但是这里树的非叶结点上是没有信息需要维护的。可以把 lazy propagation 和你维护的幺半群放到一个数组来写。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = int64_t;

const i64 inf = 1e9;
int N, M, Q, sz, h, ans[250100];
i64 dat[250100];
struct rec {
  i64 p, q;
} lz[524388];
struct req {
  i64 a, b, c, d;
} q[250100];
void add(int x, i64 v) {
  for (; x <= N + 1; x += x & -x) dat[x] += v;
}
void add(int l, int r, i64 v) { add(l, v), add(r + 1, -v); }
i64 sum(i64 x) {
  i64 res = 0;
  for (; x; x -= x & -x) res += dat[x];
  return res;
}
rec composition(rec f, rec v) { return {v.p + f.p, max(v.q + f.p, f.q)}; }
void propagate(int x, rec f) { lz[x] = composition(f, lz[x]); }
void push(int x) {
  propagate(x * 2, lz[x]), propagate(x * 2 + 1, lz[x]), lz[x] = {0, -inf};
}
void add(int l, int r, rec f) {
  assert(0 <= l && l <= r && r <= N);
  if (l == r) return;
  l += sz, r += sz;
  for (int i = h; i >= 1; --i) {
    if (((l >> i) << i) != l) push(l >> i);
    if (((r >> i) << i) != r) push((r - 1) >> i);
  }
  for (; l < r; l >>= 1, r >>= 1) {
    if (l & 1) propagate(l++, f);
    if (r & 1) propagate(--r, f);
  }
}
i64 get(i64 x) {
  assert(0 <= x && x < N);
  for (i64 i = h; i >= 1; --i) push((x + sz) >> i);
  return max(lz[x + sz].p, lz[x + sz].q);
}

void dac(int l, int r, const vector<int>& id) {
  if (id.empty()) return;
  if (l == r) {
    for (auto&& it : id) ans[it] = l;
    return;
  }
  int mid = (l + r) / 2;
  for (int i = l; i <= mid; ++i)
    if (q[i].c && q[i].d) add(q[i].a, q[i].b, q[i].d);
  vector<int> ql, qr;
  for (auto&& it : id) (sum(q[it].a) >= q[it].b ? ql : qr).emplace_back(it);
  dac(mid + 1, r, qr);
  for (int i = l; i <= mid; ++i)
    if (q[i].c && q[i].d) add(q[i].a, q[i].b, -q[i].d);
  dac(l, mid, ql);
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> N >> M >> Q;
  h = ceil(log2(N)), sz = 1 << h;
  for (int i = 0; i <= N; ++i) lz[i + sz] = {0, -inf};
  vector<int> is;
  for (i64 o, l, r, c, k, i = 1; i <= Q; ++i) {
    cin >> o >> l >> r, c = k = 0;
    if (o == 1)
      cin >> c >> k, add(l, r, k), add(l - 1, r, {k, 0});
    else if (o == 2)
      cin >> k, add(l - 1, r, {-k, 0});
    else
      r += sum(l) - get(l - 1), is.emplace_back(i);
    q[i] = {l, r, c, k};
  }
  memset(dat, 0, sizeof(dat)), dac(1, Q + 1, is);
  for (int i = 1; i <= Q; ++i)
    if (q[i].c == 0 && q[i].d == 0)
      cout << q[ans[i] > i ? 0 : ans[i]].c << "\n";
  return 0;
}
```

---

## 作者：GK0328 (赞：5)

重工业做法，常数巨大，随手$rank$倒数第一。

### 吉老师线段树、平衡树

显然没法直接维护，参考[【ZJOI2016】大森林](https://uoj.ac/problem/195)的做法，把询问离线下来，在区间的左端点插入，右端点后一个位置删除。

这样维护序列只需要一棵平衡树，但是对于一组询问，我们需要准确定位它的位置。容易发现，操作$2$其实不需要真正删除，只需要把之后的询问向右平移即可。我们先利用一棵线段树维护不删除情况下每个位置序列的长度，再用一棵线段树维护带删除情况下每个位置序列的长度，然后在第二棵线段树中查询位置，根据查询到的位置与队尾的相对位置关系，即可推出不删除情况下的询问位置。由于第二棵线段树需要每个位置随时对$0$取$\max$，需要使用**吉老师线段树**。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<ctime>
#include<vector>
#define N 250005
#define IT vector<ask> :: iterator
#define ll long long
using namespace std;
const ll INF=191919191919191919;
int n,m,q,rt,x,y,z,opt,l,r,c,k,cg,ans[N];
ll b;
#define s(p) tr[p].S
#define tag(p) tr[p].Tag
struct node1
{
    ll S,Tag;
};
struct sgt1
{
    node1 tr[N << 2];
    void push_tag(int p,ll y)
    {
        s(p)+=y,tag(p)+=y;
    }
    void push_down(int p)
    {
        push_tag(p << 1,tag(p));
        push_tag(p << 1 | 1,tag(p));
        tag(p)=0;
    }
    void modify(int p,int l,int r,int x,int y,ll z)
    {
        if (l==x && r==y)
        {
            push_tag(p,z);
            return;
        }
        push_down(p);
        int mid(l+r >> 1);
        if (y<=mid)
            modify(p << 1,l,mid,x,y,z); else
        if (x>mid)
            modify(p << 1 | 1,mid+1,r,x,y,z); else
            {
                modify(p << 1,l,mid,x,mid,z);
                modify(p << 1 | 1,mid+1,r,mid+1,y,z);
            }
    }
    ll calc(int p,int l,int r,int x)
    {
        if (l==r)
            return s(p);
        push_down(p);
        int mid(l+r >> 1);
        if (x<=mid)
            return calc(p << 1,l,mid,x); else
            return calc(p << 1 | 1,mid+1,r,x);
    }
}s1;
#define mn(p) tr[p].Mn
#define se(p) tr[p].Se
#define tag1(p) tr[p].Tag1
#define tag2(p) tr[p].Tag2
struct node2
{
    ll Mn,Se,Tag1,Tag2;
};
struct sgt2
{
    node2 tr[N << 2];
    void build(int p,int l,int r)
    {
        mn(p)=0,se(p)=INF;
        if (l==r)
            return;
        int mid(l+r >> 1);
        build(p << 1,l,mid);
        build(p << 1 | 1,mid+1,r);
    }
    void push_tag(int p,ll t1,ll t2)
    {
        mn(p)+=t1,tag1(p)+=t1;
        if (se(p)!=INF)
            se(p)+=t2,tag2(p)+=t2;
    }
    void push_down(int p)
    {
        ll lt(mn(p << 1)),rt(mn(p << 1 | 1));
        if (lt<=rt)
            push_tag(p << 1,tag1(p),tag2(p)); else
            push_tag(p << 1,tag2(p),tag2(p));
        if (rt<=lt)
            push_tag(p << 1 | 1,tag1(p),tag2(p)); else
            push_tag(p << 1 | 1,tag2(p),tag2(p));
        tag1(p)=tag2(p)=0;
    }
    void update(int p)
    {
        mn(p)=min(mn(p << 1),mn(p << 1 | 1));
        if (mn(p << 1)==mn(p << 1 | 1))
            se(p)=min(se(p << 1),se(p << 1 | 1));else
        if (mn(p)==mn(p << 1))
            se(p)=min(se(p << 1),mn(p << 1 | 1)); else
            se(p)=min(mn(p << 1),se(p << 1 | 1));
    }
    void modify1(int p,int l,int r,int x,int y,ll z)
    {
        if (l==x && r==y)
        {
            push_tag(p,z,z);
            return;
        }
        push_down(p);
        int mid(l+r >> 1);
        if (y<=mid)
            modify1(p << 1,l,mid,x,y,z); else
        if (x>mid)
            modify1(p << 1 | 1,mid+1,r,x,y,z); else
            {
                modify1(p << 1,l,mid,x,mid,z);
                modify1(p << 1 | 1,mid+1,r,mid+1,y,z);
            }
        update(p);
    }
    void modify2(int p,int l,int r,int x,int y,ll z)
    {
        if (l==x && r==y)
        {
            if (mn(p)>=z)
                return;
            if (l==r)
            {
                mn(p)=z;
                se(p)=INF;
                tag1(p)=tag2(p)=0;
            } else
            if (se(p)>z)
                push_tag(p,z-mn(p),0); else
                {
                    push_down(p);
                    int mid(l+r >> 1);
                    modify2(p << 1,l,mid,x,mid,z);
                    modify2(p << 1 | 1,mid+1,r,mid+1,y,z);
                    update(p);
                }
            return;
        }
        push_down(p);
        int mid(l+r >> 1);
        if (y<=mid)
            modify2(p << 1,l,mid,x,y,z); else
        if (x>mid)
            modify2(p << 1 | 1,mid+1,r,x,y,z); else
            {
                modify2(p << 1,l,mid,x,mid,z);
                modify2(p << 1 | 1,mid+1,r,mid+1,y,z);
            }
        update(p);
    }
    ll calc(int p,int l,int r,int x)
    {
        if (l==r)
            return mn(p);
        push_down(p);
        int mid(l+r >> 1);
        if (x<=mid)
            return calc(p << 1,l,mid,x); else
            return calc(p << 1 | 1,mid+1,r,x);
    }
}s2;
struct ask
{
    int opt;
    ll t;
    int c,z;
    ask () {}
    ask (int o,ll T,int C,int Z=0):opt(o),t(T),c(C),z(Z) {}
};
vector<ask>e[N];
#undef s
#define ls(p) a[p].ch[0]
#define rs(p) a[p].ch[1]
#define rk(p) a[p].Rk
#define tim(p) a[p].Tim
#define val(p) a[p].Val
#define id(p) a[p].Id
#define s(p) a[p].S
struct node3
{
    int ch[2],Rk,Tim,Val,Id;
    ll S;
};
int ct(0);
struct fhq_treap
{
    node3 a[N];
    int newnode(int x,int y,int z)
    {
        ++ct;
        ls(ct)=rs(ct)=0,rk(ct)=rand(),tim(ct)=x,val(ct)=y,id(ct)=z;
        s(ct)=y;
        return ct;
    }
    void update(int p)
    {
        s(p)=s(ls(p))+s(rs(p))+val(p);
    }
    void split(int &x,int &y,int rt,int k)
    {
        if (!rt)
        {
            x=y=0;
            return;
        }
        if (tim(rt)<=k)
        {
            x=rt;
            split(rs(rt),y,rs(rt),k);
        } else
        {
            y=rt;
            split(x,ls(rt),ls(rt),k);
        }
        update(rt);
    }
    int combine(int x,int y)
    {
        if (!x || !y)
            return x|y;
        if (rk(x)<rk(y))
        {
            rs(x)=combine(rs(x),y);
            update(x);
            return x;
        } else
        {
            ls(y)=combine(x,ls(y));
            update(y);
            return y;
        }
    }
}T;
int main()
{
    srand(time(NULL));
    scanf("%d%d%d",&n,&m,&q);
    s2.build(1,1,n);
    for (int i=1;i<=q;++i)
    {
        scanf("%d",&opt);
        if (opt==1)
        {
            scanf("%d%d%d%d",&l,&r,&c,&k);
            e[l].push_back(ask(1,k,c,i));
            e[r+1].push_back(ask(-1,k,c,i));
            s1.modify(1,1,n,l,r,k);
            s2.modify1(1,1,n,l,r,k);
        } else
        if (opt==2)
        {
            scanf("%d%d%d",&l,&r,&k);
            s2.modify1(1,1,n,l,r,-k);
            s2.modify2(1,1,n,1,n,0);
        } else
        {
            scanf("%d%lld",&c,&b),++cg;
            ll g(s2.calc(1,1,n,c));
            if (g<b)
                ans[cg]=0; else
                e[c].push_back(ask(0,s1.calc(1,1,n,c)-(g-b),cg));
        }
    }
    for (int i=1;i<=n;++i)
    {
        for (IT it=e[i].begin();it!=e[i].end();++it)
        {
            int opt(it->opt);
            ll t(it->t);
            int c(it->c),tz(it->z);
            if (opt==0)
            {
                int g(rt);
                for (;;)
                {
                    if (T.s(T.ls(g))>=t)
                        g=T.ls(g); else
                    if (T.s(T.ls(g))+T.val(g)>=t)
                    {
                        ans[c]=T.id(g);
                        break;
                    } else
                        t-=T.s(T.ls(g))+T.val(g),g=T.rs(g);
                }
            } else
            if (opt==1)
            {
                T.split(x,y,rt,tz);
                rt=T.combine(T.combine(x,T.newnode(tz,t,c)),y);
            } else
            {
                T.split(x,y,rt,tz);
                T.split(x,z,x,tz-1);
                rt=T.combine(x,y);
            }
        }
    }
    for (int i=1;i<=cg;++i)
        printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：zhenjianuo2025 (赞：4)

### Solve

「离开事件」可以忽略。只需要维护当前离开了多少人就可以。遍历所有操作，用线段树维护每一家店一共还剩多少人（区间减，区间对 $0$ 取 $\max$，单点查询，类似 [P8024](https://www.luogu.com.cn/problem/P8024)），用树状数组维护一共来过多少人（区间加，单点查询），离开的人数 $\red{\bm{=}}$ 一共来过的人数 $\red{\bm{-}}$ 还剩的人数。

因为白嫖到物品的人一定是之前某个「加入事件」加入的人，离线下来所有的「白嫖事件」，在「加入事件」中整体二分即可。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, q, ans[250010];
struct Ques {
	int id, l, r, c, k, a, b, pre;
} add[250010];
struct Bit {
	int w[250010];
	int lowbit(int x) { return x & (-x); }
	void clear() {
		memset(w, 0, sizeof w);
	}
	void add(int p, int x) {
		for (int i = p; i <= n; i += lowbit(i)) w[i] += x;
	}
	int query(int p) {
		int res = 0;
		for (int i = p; i; i -= lowbit(i)) res += w[i];
		return res;
	}
} bit;
struct Seg {
	int sum[1000010], add[1000010], top[1000010];
	bool InRange(int l, int r, int L, int R) { return L <= l && R >= r; }
	bool OutoRange(int l, int r, int L, int R) { return r < L || R < l; }
	// add -> max
	void build(int u, int l, int r) {
		top[u] = -1e18;
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	}
	void makeadd(int u, int l, int r, int x) {
		add[u] += x; sum[u] += x;
		if (top[u] >= -1e18) top[u] += x;
	}
	void makemax(int u, int l, int r, int x) {
		top[u] = max(top[u], x); sum[u] = max(sum[u], x);
	}
	void pushdown(int u, int l, int r) {
		int mid = (l + r) >> 1;
		makeadd(u << 1, l, mid, add[u]), makeadd(u << 1 | 1, mid + 1, r, add[u]);
		makemax(u << 1, l, mid, top[u]), makemax(u << 1 | 1, mid + 1, r, top[u]);
		add[u] = 0, top[u] = -1e18;
	}
	void updadd(int u, int l, int r, int L, int R, int x) {
		if (InRange(l, r, L, R)) makeadd(u, l, r, x);
		else if (!OutoRange(l, r, L, R)) {
			pushdown(u, l, r);
			int mid = (l + r) >> 1;
			updadd(u << 1, l, mid, L, R, x), updadd(u << 1 | 1, mid + 1, r, L, R, x);
		}
	}
	void updmax(int u, int l, int r, int L, int R, int x) {
		if (InRange(l, r, L, R)) makemax(u, l, r, x);
		else if (!OutoRange(l, r, L, R)) {
			pushdown(u, l, r);
			int mid = (l + r) >> 1;
			updmax(u << 1, l, mid, L, R, x), updmax(u << 1 | 1, mid + 1, r, L, R, x);
		}
	}
	int query(int u, int l, int r, int p) {
		if (l == r) return sum[u];
		pushdown(u, l, r);
		int mid = (l + r) >> 1;
		if (p <= mid) return query(u << 1, l, mid, p); else return query(u << 1 | 1, mid + 1, r, p);
	}
} seg;
void solve(vector<Ques> q, int l, int r, int tql) {
	if (q.empty()) return;
	if (l == r) {
		if (l <= tql) bit.add(add[l].l, add[l].k), bit.add(add[l].r + 1, -add[l].k);
		for (int i = 0; i < q.size(); i++) {
			int cnt = bit.query(q[i].a);
			if (q[i].pre != 0 && cnt >= q[i].b) ans[q[i].id] = l; else ans[q[i].id] = 0;
		}
		if (l <= tql) bit.add(add[l].l, -add[l].k), bit.add(add[l].r + 1, add[l].k);
		return;
	}
	int mid = (l + r) >> 1;
	for (int i = l; i <= min(mid, tql); i++) bit.add(add[i].l, add[i].k), bit.add(add[i].r + 1, -add[i].k);
	vector<Ques> ql, qr;
	for (int i = 0; i < q.size(); i++) {
		if (q[i].pre <= mid) ql.push_back(q[i]);
		else {
			int cnt = bit.query(q[i].a);
			if (cnt >= q[i].b) {
				ql.push_back(q[i]);
			} else {
				q[i].b -= cnt;
				qr.push_back(q[i]);
			}
		}
	}
	for (int i = l; i <= min(mid, tql); i++) bit.add(add[i].l, -add[i].k), bit.add(add[i].r + 1, add[i].k);
	solve(ql, l, mid, tql), solve(qr, mid + 1, r, tql);
}
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> m >> q;
	seg.build(1, 1, n);
	int cnt = 0;
	int tot = 0;
	vector<Ques> p;
	while (q--) {
		int op;
		cin >> op;
		if (op == 1) {
			Ques a;
			cin >> a.l >> a.r >> a.c >> a.k;
			add[++cnt] = a; bit.add(a.l, a.k), bit.add(a.r + 1, -a.k);
			seg.updadd(1, 1, n, a.l, a.r, a.k);
		} else if (op == 2) {
			int l, r, k;
			cin >> l >> r >> k;
			seg.updadd(1, 1, n, l, r, -k); seg.updmax(1, 1, n, l, r, 0);
		} else {
			Ques a;
			cin >> a.a >> a.b;
			a.id = ++tot; a.pre = cnt;
			a.b += bit.query(a.a) - seg.query(1, 1, n, a.a); p.push_back(a);
		}
	}
	bit.clear();
	solve(p, 1, cnt + 1, cnt);
	add[0].c = add[cnt + 1].c = 0;
	for (int i = 1; i <= tot; i++) cout << add[ans[i]].c << "\n"; 
	return 0;
} 
```

---

## 作者：strcmp (赞：3)

**题目大意：**

维护 $n$ 个序列，$m$ 次操作。每次在 $[l,\,r]$ 的序列末尾加 $k$ 个数字 $c$，或者在开头删去 $k$ 个数字（如果 $k$ 大于等于序列长度则删完），或者查询序列 $a$ 的第 $b$ 个位置的数字。

------------

提供一个题解里没有的树状数组上二分写法。

因为是单点查询，考虑扫描线，枚举 $1 \le i \le n$，回答第 $i$ 个序列上的询问。具体的，对于 $[l,\,r]$ 的加入和离开事件，我们差分成 $l$ 开始，到 $r + 1$ 结束的一段影响区间。

不妨先去掉离开事件。

$f_j$ 代表序列 $i$ 上的第 $j$ 次操作插入了 $f_j$ 个数，$g_j$ 代表第 $j$ 次操作插入的数。（如果第 $j$ 次操作不是插入则 $f_j = g_j = 0$）

在实现中我们开一个大小为 $m$ 的树状数组，每次把所有 $l = i$ 的加入给加进树状数组里，并撤回所有 $r = i - 1$ 的加入，下标为这些加入的出现时间，这是可以简单维护的。然后询问最大的 $k$ 使得 $(\sum^{k}_{j=1} f_j \ge b) \wedge k < t$，其中 $t$ 是当前询问的出现时间。此时 $g_k$ 为所求。

显然可以树状数组上二分维护 $f$，$g$ 开个数组就行了。

考虑有离开事件的情况。

我们发现只需要求出询问 $(a,\,b)$ 之前，$a$ 出去了多少个，然后 $b$ 加上这个数就行了。显然因为我们先进先出的操作顺序这不影响答案。

就是询问时间 $t$ 时，$a$ 序列出去了多少个。挂在询问上，枚举时间轴扫一遍即可。

那么每次就是区间加，区间减并对 $0$ 取 $\max$，单点查询。

Segment Tree Beats 可以搞，但是没必要，有一种巧妙的方法可以避免势能线段树。

具体的，线段树上结点 $(x,\,y)$ 代表这个区间要加上 $x$，并对 $y$ 取 $\max$。

那么我们发现，$(x',\,y')$ 下传到子节点 $(x,\,y)$ 这个标记时，会使得 $(x,\,y)$ 变成 $(x + x',\,\max(y + x',\,y'))$。

这样查询的时候可以一直查到叶子结点，然后返回叶子结点的标记即可。

时间复杂度是严格 $\Theta(n \log n)$ 的。

然后就做完了，注意一下有些细节，应该没有什么离谱的压行。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2.5e5 + 10;
const ll inf = 114514191981052013LL;
using pll = pair<ll, ll>;
struct Q { int id; ll c, k; };
vector<Q> q[maxn]; ll d[2][maxn], ex[maxn], ans[maxn]; int n, m; ll C;
inline void add(int x, ll v, int o) { while (x <= 250010) d[o][x] += v, x += x & -x; }
inline ll qry(int x) {
    ll sum = 0;
    while (x) sum += d[1][x], x -= x & -x;
    return sum;
}
inline int kth(ll k, int top) {
    int p = 0; ll s = 0;
    for (int i = 20; i >= 0; i--) {
        int np = p + (1 << i);
        if (np <= top && s + d[0][np] < k) p = np, s += d[0][np];
    }
    return p + 1 > top ? m + 1 : p + 1;
}
struct Node { 
    ll a, b;
    Node() { b = -inf; }
    Node(ll c, ll d) { a = c, b = d; }
} t[maxn << 2];
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
#define A(x) (t[x].a)
#define B(x) (t[x].b)
inline void pushdw(int x) {
    if (A(x) || B(x) > -inf) {
        t[ls(x)] = { A(ls(x)) + A(x), max(B(ls(x)) + A(x), B(x)) };
        t[rs(x)] = { A(rs(x)) + A(x), max(B(rs(x)) + A(x), B(x)) };
        A(x) = 0; B(x) = -inf;
    }
}
void sgtadd(int l, int r, int ml, int mr, ll LA, ll LB, int x) {
    if (ml <= l && r <= mr) { A(x) += LA; B(x) = max(B(x) + LA, LB); return; }
    int mid = l + r >> 1; pushdw(x);
    if (ml <= mid) sgtadd(l, mid, ml, mr, LA, LB, ls(x));
    if (mr > mid) sgtadd(mid + 1, r, ml, mr, LA, LB, rs(x));
}
ll sgtqry(int l, int r, int v, int x) {
    if (l == r) { return max(A(x), B(x)); }
    int mid = l + r >> 1; pushdw(x);
    if (v <= mid) return sgtqry(l, mid, v, ls(x));
    else return sgtqry(mid + 1, r, v, rs(x));
}
int o[maxn], l[maxn], r[maxn]; ll c[maxn], k[maxn];
void input() {
    scanf("%d%lld%d", &n, &C, &m); c[m + 1] = inf;
    for (int i = 1; i <= m; i++) {
        scanf("%d", &o[i]);
        switch (o[i]) {
        case 1:
            scanf("%d%d%lld%lld", &l[i], &r[i], &c[i], &k[i]);
            q[l[i]].push_back({ i, c[i], k[i] });
            q[r[i] + 1].push_back({ i, 0, -k[i] });
            break;
            // k >= 1
        case 2:
            scanf("%d%d%lld", &l[i], &r[i], &k[i]);
            break;
        default:
            scanf("%d%lld", &l[i], &c[i]);
            q[l[i]].push_back({ i, c[i], 0 });
            break;
        }
    }
    for (int i = 1; i <= m; i++) {
        if (o[i] == 1 || o[i] == 2) {
            if (o[i] == 1) add(l[i], k[i], 1), add(r[i] + 1, -k[i], 1);
            sgtadd(1, n, l[i], r[i], o[i] == 1 ? k[i] : -k[i], o[i] == 2 ? 0 : -inf, 1);
        }
        else ex[i] = qry(l[i]) - sgtqry(1, n, l[i], 1);
    }
}
void solve() {
    for (int i = 1; i <= n; i++) 
        for (auto x : q[i]) x.k ? add(x.id, x.k, 0), 0 : ans[x.id] = c[kth(x.c + ex[x.id], x.id - 1)], 0;
    for (int i = 1; i <= m; i++) if (ans[i]) ans[i] < inf ? printf("%lld\n", ans[i]) : puts("0");
}
int main() {
    input();
    solve();
    return 0;
}
```

---

## 作者：7KByte (赞：2)

先膜拜楼上 7k 代码的神仙。

这里提供一个轻工业的做法。

首先考虑没有离开操作，那么对于每个询问，我们只需要知道最早在哪一次操作队列 $A$ 的大小 $\ge B$ 。

这可以对所有询问离线，然后将每个询问挂在对应的位置，用线段树维护区间中询问的最小值。

这时一个加入操作，等价于区间减，当某个位置 $\le 0$ 时，该位置对应询问的答案就是当前操作的标号 $C$ 。注意一个位置可以挂多个询问，开 ``vector`` 记录。

一个询问最多只有一次从 $>0$ 到 $\le 0$ ，所以均摊线段树的时间复杂度是 $\mathcal{O}((N+Q)\log N)$ 。离线后线段树二分应该也可以，本质不变。

现在考虑存在离开操作，如果我们知道当前询问之前队列删除了多少个数，则可以把问题转换为没有离开操作。因为假定删除了 $k$ 个数，相当于查询第 $B+k$ 个加入队列的数 。 

继续推导，如果我们知道当前队列的大小，还知道有多少数入过队，就能得到出队的数的个数。

后者可以直接树状数组维护区间加，单点查询。

前者需要支持
- 区间加
- 区间减
- 区间对 $0$ 取 $\max$

直接套区间最值线段树即可。

具体做法是对每个位置维护二元标记 $(p,q)$，注意这两个元素是一起的，表示区间里的数 $+p$ 后对 $q$ 取 $\max$。

合并两个标记 $(u,v),(p,q)$ ，注意有现后顺序，手算一下得到标记 $(u+p,\max\{v+p,q\})$ 。

时间复杂度 $\mathcal{O}((N+Q)\log N)$ ，略优于线段树二分的 $\mathcal{O}((N+Q)\log (N+Q))$ 。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 250005
#define inf 0x3f3f3f3f3f3f3f3fLL
#define int long long
typedef long long ll;
using namespace std;
int n,m,ans[N],idx,c[N];
inline void add(int x,int val){for(;x<=n;x+=x&-x)c[x]+=val;}
inline int ask(int x){int sum=0;for(;x;x-=x&-x)sum+=c[x];return sum;}
#define L a[x].l
#define R a[x].r
#define ls (x<<1)
#define rs (ls|1)
#define T a[x].tag
namespace seg1{
	struct node{
		int l,r;ll p,q;
	}a[N<<2];
	void build(int x,int l,int r){
		L=l;R=r;a[x].p=a[x].q=0;
		if(l==r)return;
		int mid=(l+r)>>1;
		build(ls,l,mid);build(rs,mid+1,r);
	}
	void pushup(int x,ll u,ll v){a[x].p+=u;a[x].q=max(v,a[x].q+u);}
	void down(int x){if(a[x].p||a[x].q)pushup(ls,a[x].p,a[x].q),pushup(rs,a[x].p,a[x].q),a[x].p=a[x].q=0;}
	void add(int x,int l,int r,int val){
		if(L>=l&&R<=r)pushup(x,val,0);
		else{
			down(x);int mid=(L+R)>>1;
			if(mid>=l)add(ls,l,r,val);
			if(mid<r)add(rs,l,r,val);
		}
	}
	ll ask(int x,int pos){
		if(L==R)return max(a[x].p,a[x].q);
		else{
			down(x);int mid=(L+R)>>1;
			if(mid>=pos)return ask(ls,pos);
			return ask(rs,pos);
		}
	}
}
namespace seg2{
	struct node{
		int l,r,mn,tag;
	}a[N<<2];
	#define S a[x].mn
	vector<pair<int,int> >u[N];int st[N];
	void build(int x,int l,int r){
		L=l,R=r,T=0;
		if(l==r){if(u[l].size())S=u[l][0].first;else S=inf;}
		else{
			int mid=(l+r)>>1;
			build(ls,l,mid);
			build(rs,mid+1,r);
			S=min(a[ls].mn,a[rs].mn);
		}
	}
	void pushup(int x,int val){T+=val;S+=val;}
	void down(int x){if(T)pushup(ls,T),pushup(rs,T),T=0;}
	void add(int x,int l,int r,int val){
		if(L>=l&&R<=r)pushup(x,val);
		else{
			down(x);int mid=(L+R)>>1;
			if(mid>=l)add(ls,l,r,val);
			if(mid<r)add(rs,l,r,val);
			S=min(a[ls].mn,a[rs].mn);
		}
	}
	void maintain(int x,int col){
		if(S>0)return;
		if(L==R){
			while(st[L]<(int)u[L].size()&&S<=0){
				ans[u[L][st[L]++].second]=col;
				if(st[L]==(int)u[L].size())S=inf;
				else S+=u[L][st[L]].first-u[L][st[L]-1].first;
			}
		}
		else down(x),maintain(ls,col),maintain(rs,col),S=min(a[ls].mn,a[rs].mn);
	}
}
struct ope{int op,l,r,x,y;}q[N];
signed main(){
	scanf("%lld%lld",&n,&m);scanf("%lld",&m);
	seg1::build(1,1,n);puts("No Copy");
	rep(i,1,m){
		scanf("%lld%lld%lld",&q[i].op,&q[i].l,&q[i].r);
		if(q[i].op==1){
			scanf("%lld%lld",&q[i].x,&q[i].y);
			seg1::add(1,q[i].l,q[i].r,q[i].y);
			add(q[i].l,q[i].y);add(q[i].r+1,-q[i].y);
		}
		else if(q[i].op==2){
			scanf("%lld",&q[i].y);
			seg1::add(1,q[i].l,q[i].r,-q[i].y);
		}
		else{
			++idx;int now=seg1::ask(1,q[i].l);
			if(now>=q[i].r)seg2::u[q[i].l].push_back(make_pair(ask(q[i].l)-now+q[i].r,idx));
		}
	}
	rep(i,1,n)sort(seg2::u[i].begin(),seg2::u[i].end());
	seg2::build(1,1,n);
	rep(i,1,m)if(q[i].op==1){
		seg2::add(1,q[i].l,q[i].r,-q[i].y);
		seg2::maintain(1,q[i].x);
	}
	rep(i,1,idx)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：panyanppyy (赞：1)

~~模拟赛前偷过还不会做的屑~~。

轻轻轻工业还非常好理解，感谢 @houzhiyuan 巨佬。

## Problem

$n$ 家店，$m$ 个团队，$q$ 次操作，有三种操作：

`1 l r c k` 表示 $[l,r]$ 店来了 $k$ 个来自 $c$ 团队的人排队。

`2 l r k` 表示 $[l,r]$ 有 $k$ 个人从前面排完离开。

`3 a b` 表示询问第 $a$ 家店当前队伍第 $b$ 个人属于的团队。

$n,q\le 2.5\times10^5\ ,k\le 10^9\ ,b\le 10^{15}$
### Algorithm 1
$\mathcal O(n^2)\ $ 

直接开 $n$ 个 `deque<pair<int,int>>` 对每次询问直接做就可以了。

期望得分 14pts。
### Algorithm 2

$m=1$ 相当于询问当前队伍有没有人，BIT 维护即可。

期望得分 21pts。

### Algorithm 3
没有删除操作，可以考虑整体二分：

现在我们把问题转化为对每个询问求其对应的答案在哪次操作 $1$。

已知集合 $S$ 的答案全部位于区间 $[l,r]$，考虑求出 $mid =\dfrac{l+r}{2}$ 时每个队列的长度，然后
将能确定答案 $\le mid$ 的询问和 $\gt mid$ 的分成两半，然后继续递归。

期望得分 13pts。

这时候问题显现出来了，删除操作对 $0$ 取 $\max$ 很难处理。

**Trick:** 转换一下，假设删除操作的数没有删除，而是在询问的时候加上删除的人。

$\mathcal O(n\log^2n)$

现在就可以用整体二分求答案了。

线段树维护一下 `max(x+a,b)` 就能求出实际询问的点了。

$\mathcal O(n\log n)$

把整体二分换成线段树分治就能做到。

期望得分 100pts。
### Algorithm 4
**轻工业：** 把时间轴和店反一下，从第 $1$ 家店到第 $n$ 家店做一遍扫描线。

可以发现，实际上每次删除操作是对一段后缀产生贡献，这样直接用一颗线段树维护最小值，然后每次询问最小值就是上面 Trick 里删除的人数了。

然后直接在另一颗记录线段树上二分出第一个大于等于 删除人数+当点人数 的人群编号即可。

两颗线段树都只要维护 $\max$ 或 $\min$，直接用一个结构体就行了。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ri register
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
using namespace std;
template<typename T_>void operator+=(vector<T_>&x,const T_&y){x.push_back(y);}
const int N=2.5e5+7;
const ll inf=1e18;
int n,m,q,id[N],ans[N];
ll B;
struct SegmentTree{
	ll t[N<<2],mi[N<<2],mx[N<<2],lzy[N<<2];
	void push_up(int rt){
		mx[rt]=max(mx[rt<<1],mx[rt<<1|1]);
		mi[rt]=min(mi[rt<<1],mi[rt<<1|1]); 
	}
	void f(int rt,ll k){mi[rt]+=k,t[rt]+=k,mx[rt]+=k,lzy[rt]+=k;}
	void push_down(int rt){
		if(!lzy[rt])return;
		f(rt<<1,lzy[rt]),f(rt<<1|1,lzy[rt]);
		lzy[rt]=0; 
	}
	ll query(int x,int l,int r,int rt){
		if(l==r)return t[rt];
		push_down(rt);int mid=(l+r)>>1;
		if(x<=mid)return query(x,l,mid,rt<<1);
		if(x>mid) return query(x,mid+1,r,rt<<1|1);
		return-1;
	}
	ll qmi(int L,int R,int l,int r,int rt){
		if(L<=l&&r<=R)return mi[rt];
		push_down(rt);int mid=(l+r)>>1;ll res=inf;
		if(L<=mid)res=min(res,qmi(L,R,l,mid,rt<<1));
		if(R>mid) res=min(res,qmi(L,R,mid+1,r,rt<<1|1));
		return res;
	}
	int find(int L,int R,ll x,int l,int r,int rt){
		if(mx[rt]<x)return 0;
		if(l==r)return id[l];
		push_down(rt);int mid=(l+r)>>1;
		if(L<=l&&r<=R){
			if(mx[rt<<1|1]>=x)return find(L,R,x,mid+1,r,rt<<1|1);
			return find(L,R,x,l,mid,rt<<1);
		}else if(R>mid){
			int k=find(L,R,x,mid+1,r,rt<<1|1);
			if(k)return k;
		}
		return find(L,R,x,l,mid,rt<<1);
	}
	void update(int L,int R,int k,int l,int r,int rt){
		if(L<=l&&r<=R)return f(rt,k);
		push_down(rt);int mid=(l+r)>>1;
		if(L<=mid)update(L,R,k,l,mid,rt<<1);
		if(R>mid) update(L,R,k,mid+1,r,rt<<1|1);
		push_up(rt);
	}
}T1,T2;
vector<pair<int,int>>ad[N],del[N];
vector<pair<int,ll>>Q[N];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1,op,l,r,c,k;i<=q;i++){
		cin>>op;
		switch(op){
			case 1:
				cin>>l>>r>>c>>k,id[i]=c;
				ad[l]+={i,k},ad[r+1]+={i,-k};
				break;
			case 2:
				cin>>l>>r>>k;
				del[l]+={i,-k},del[r+1]+={i,k};
				break;
			case 3:
				cin>>l>>B,Q[l]+={i,B};
				break;
		}
	}
	memset(ans,-1,sizeof(ans));
	for(int i=1;i<=n;i++){
		for(auto j:ad[i])
			T1.update(j.fi,q,j.se,1,q,1),T2.update(1,j.fi,j.se,1,q,1);
		for(auto j:del[i])T1.update(j.fi,q,j.se,1,q,1);
		for(auto j:Q[i]){
			ll x=T1.query(j.fi,1,q,1)-min(T1.qmi(1,j.fi,1,q,1),0ll),y=j.se;
			if(y>x)ans[j.fi]=0;
			else{
				x=x-y+1;
				ans[j.fi]=T2.find(1,j.fi,x+T2.query(j.fi,1,q,1),1,q,1);
			}
		}
	}
	for(int i=1;i<=q;i++)
		if(~ans[i])cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：_HL_ (赞：1)

# 扫描线 数据结构维护时间维

经典题

审题发现需要维护的有点多

为什么要数据机构维护时间维呢 ~~因为 lxl 说的~~ 因为如果正常维护是区间修 单点查 很 dl 不如去单点改 区间查

二维平面纵轴代表时间维 横轴代表 store 的 $id$

每次进入 $x$ 个编号为 $ k $ 个的人 就是一个矩形加问题 并且矩形纵向的边长为单点 可以平凡地维护

由于维护人数编号二元组难以实现 所以考虑扫描线维护人数 把同一次加入的$x$个人缩成一个点 点权为人数 最后线段树区间二分找到纵轴编号可以平凡地维护

但是由于每次到 $0$ 都得清空序列 些许 dl 考虑如何维护

我们发现 **最大后缀和** 满足此性质 可以平凡地证明 其实不是很平凡 主要不容易想到

扫描线线段树平凡地维护后缀和 和后缀的位置

每次查询找到对应区间的后缀起始位置 从这个位置到 $r$ ( 即查询时间 这一区间的第 $ k $ 个位置的 通过线段树区间二分可以平凡地实现

[线段树区间二分模板](https://www.luogu.com.cn/problem/U197996)

然后注意一下对应家庭标号的细节 我怕一堆 $ 0 $ 出锅 pop 的和  push 的和我都分别离散化进行了维护 细节还是有些的 注意一下

哦对 还有一个巨大的坑点

**数据点存在空问情况！！！**

调半天也是服了

虽然是 lxlppt 上原题 但感觉没多少人交这道题 缝缝补补的代码也能最优解排第三

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=250005;
int cntl,cntq;
int cntp,f[N],cntn,g[N];
int tn;
int qn;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x;
}

struct node
{
	int opt,t,pos,k,ans,id;
	bool friend operator < (const node a,const node b)
	{
		return a.pos<b.pos;
	}
}line[N<<1],q[N];
bool cmp(node a,node b)
{
	return a.id<b.id;
}

struct seg
{
	int pre_sum;
	int pre_pos;
	int sum_p;
	int sum_n;
	int sum;
}t[N<<2];
#define ls p<<1
#define rs p<<1|1
inline seg unify(seg l,seg r)
{
	seg res;
	if(l.pre_sum+r.sum<=r.pre_sum)
	res={r.pre_sum,r.pre_pos,l.sum_p+r.sum_p,l.sum_n+r.sum_n,l.sum+r.sum};
	else
	res={l.pre_sum+r.sum,l.pre_pos,l.sum_p+r.sum_p,l.sum_n+r.sum_n,l.sum+r.sum};
	return res;
}

inline void update(int p)
{
	t[p]=unify(t[ls],t[rs]);
}

void modify(int l,int r,int x,int dx,int p,int type)
{
	if(l==r)
	{
		t[p].pre_pos=l;
		if(type==1)t[p].sum_p+=dx;
		else
		t[p].sum_n+=dx;
		t[p].sum=t[p].pre_sum=t[p].sum_p-t[p].sum_n;
		if(t[p].pre_sum<0)t[p].pre_sum=0;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid)modify(l,mid,x,dx,ls,type);
	else
	modify(mid+1,r,x,dx,rs,type);
	update(p);
}

seg query(int l,int r,int ql,int qr,int p)
{
	if(ql<=l&&r<=qr)
	{
		return t[p];
	}
	int mid=l+r>>1;
	seg res={0,0,0,0,0};
	if(ql<=mid)res=query(l,mid,ql,qr,ls);
	if(qr>mid)
	{
		if(res.sum_p==0&&res.sum_n==0)res=query(mid+1,r,ql,qr,rs);
		else
		res=unify(res,query(mid+1,r,ql,qr,rs));
	}
	return res;
}

int t2[N<<2],t3[N<<2];
inline void update2(int p)
{
    t2[p]=t2[ls]+t2[rs];
}
inline void update3(int p)
{
    t3[p]=t3[ls]+t3[rs];
}
void add(int l,int r,int x,int dx,int p)
{
    if(l==r)
    {
        t3[p]+=dx;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid)add(l,mid,x,dx,ls);
    else
    add(mid+1,r,x,dx,rs);
    update3(p);
}

void insert(int l,int r,int x,int dx,int p)
{
    if(l==r)
    {
        t2[p]+=dx;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid)insert(l,mid,x,dx,ls);
    else
    insert(mid+1,r,x,dx,rs);
    update2(p);
}

int search(int l,int r,int ql,int qr,int p,int &k,int &type)
{
	
	if(type==2)
	{
        if(l==r)return l;
		int mid=l+r>>1;
		if(k>t2[ls])
		{
			k-=t2[ls];
			return search(mid+1,r,ql,qr,rs,k,type);
		}
		else
		{
			return search(l,mid,ql,qr,ls,k,type); 
		}
	}
	else
	{
		if(ql<=l&&r<=qr)
		{
			if(k>t2[p])
			{
				k-=t2[p];
				return 0;
			}
			else
			{
				return search(l,r,ql,qr,p,k,type=2);
			}
		}
		int mid=l+r>>1;
		int temp=0;
		if(ql<=mid)temp=search(l,mid,ql,qr,ls,k,type);
		if(type==2)return temp;
		if(qr>mid)temp=search(mid+1,r,ql,qr,rs,k,type);
		return temp;
	}
}

int look(int l,int r,int ql,int qr,int p)
{
    if(ql<=l&&r<=qr)
    {
        return t3[p];
    }
    int mid=l+r>>1;
    int res=0;
    if(ql<=mid)res+=look(l,mid,ql,qr,ls);
    if(qr>mid)res+=look(mid+1,r,ql,qr,rs);
    return res;
}

inline int mid_q(int l,int r,int k)
{
	seg pre=query(1,tn,l,r,1);
	if(pre.pre_sum<k)return 0;
	if(g[r]!=0)
	k=k+look(1,cntn,g[pre.pre_pos]+1,g[r],1);
    int type=1;
	return search(1,cntp,f[pre.pre_pos],f[r],1,k,type);
}
int w[N];
signed main()
{
	int n=read(),m=read();
	qn=read();
	for(int i=1;i<=qn;i++)
	{
		int opt=read();
		if(opt==1)
		{
		    tn++;
		    cntp++;
			int l=read(),r=read(),c=read(),k=read();
			line[++cntl]={opt,tn,l,k,c,i};
			line[++cntl]={opt,tn,r+1,-k,c,i};
			w[cntp]=c;
			f[tn]=cntp;
			g[tn]=cntn;
		}
		else
		if(opt==2)
		{
		    tn++;
		    cntn++;
			int l=read(),r=read(),k=read();
			line[++cntl]={opt,tn,l,k,0,i};
			line[++cntl]={opt,tn,r+1,-k,0,i};
			f[tn]=cntp;
			g[tn]=cntn;
		}
		else
		{
			int a=read(),b=read();
			q[++cntq]={opt,tn,a,b,0,i};
		}
	}
	sort(line+1,line+cntl+1);
	sort(q+1,q+cntq+1);
	int cntq1=1,cntl1=1;
	for(int i=1;i<=n;i++)
	{
		while(line[cntl1].pos==i&&cntl1<=cntl)
		{
			modify(1,tn,line[cntl1].t,line[cntl1].k,1,line[cntl1].opt);
			if(line[cntl1].opt==1)insert(1,cntp,f[line[cntl1].t],line[cntl1].k,1);
			if(line[cntl1].opt==2)
			add(1,cntn,g[line[cntl1].t],line[cntl1].k,1);
			cntl1++;
		}
		while(q[cntq1].pos==i&&cntq1<=cntq)
		{
		    if(q[cntq1].t==0)q[cntq1].ans=0;
			else
            q[cntq1].ans=mid_q(1,q[cntq1].t,q[cntq1].k);
			cntq1++;
		}
	}
	sort(q+1,q+cntq+1,cmp);
	for(int i=1;i<=cntq;i++)printf("%lld\n",w[q[i].ans]);
	return 0;
}
```


---

## 作者：Genius_Star (赞：0)

这里提供一个在线主席树算法。

### 题意：

有一个长为 $n$ 的序列，序列每个位置有个队列。

有 $m$ 个操作，每个操作可能是以下几种之一：

- $[l,r]$ 的每个队列中进来了 $k$ 个类型为 $c$ 的人。 

- $[l,r]$ 的每个队列中出去了 $k$ 个人（不足 $k$ 个则全部出去）。
- 查询某个队列中第 $k$ 个人的类型（不足 $k$ 个输出 $0$）。

### 思路：

发现离开的操作很麻烦，先抛掉，即先考虑性质 C 的做法。

假设现在只有两个操作：

- 区间加。

- 求 $x$ 号点所有版本中 $\ge y$ 时**最靠前**的版本。

明显是主席树板子，但是发现一般主席树只支持单点修改，区间查。

而本题我们需要区间修改，单点查询，注意是**单点查询**，那么我们可以**标记永久化**，即不下传懒标记（因为这样修改的点太多了，主席树不好维护），那我们可以写一个标记永久化主席树，每个点维护当前版本下区间加的值。

对于查询，因为都是加法，没有减法，那么一个点的值是单调不递减，所以考虑二分算法，可以二分版本的编号。

- 初始 $l=1,r=i-1$。

- 若 $a_{mid,x} \ge y$（即 $mid$ 版本时 $x$ 号点的值大于等于 $y$），那么说明 $[mid,i-1]$ 的版本都满足，将 $r \to mid-1,ans \to mid$；否则将 $l \to mid+1$。

- 最后答案就是 $c_{ans}$（$ans$ 这个版本时加入的人的类型）。

时间复杂度为 $O(N \log^2 N)$。

此时考虑删除操作，设第 $i$ 个队列要删除 $s_i$ 个人，那么询问时就相当于查询第 $(y+s_i)$ 个人的类型，就可以转化为上述主席树做法。

现在想一下如何求 $s_i$，因为“删除人数 = 总共加入人数 - 当前人数”；考虑维护上述两个信息。

维护每个队列的总人数，就是在操作 $1$ 时将 $[l,r]$ 区间加 $k$。


发现将区间 $a_i \to \max(a_i-k,0)$ 是不好维护的，考虑将这个操作拆开，即先区间减，再对区间取 $\max$。

因为不需要动态维护区间和，只需要单点查询，可以不用吉司机线段树；考虑直接暴力维护加法标记和 $\max$ 标记，单点查询时下传即可（注意当 $\max$ 标记存在时，加法标记也要累加过去）。

总时间复杂度为 $O(N \log^2 N)$。

**常数偏大，谨慎使用。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=250050,INF=1e17;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	int lchild,rchild;
	ll data;
}X[N*25];
ll y;
int n,m,q,op,l,r,x,k,sum;
int c[N],id[N],ans[N];
int root[N];
inline void updata(register int &k,register int l,register int r,register int L,register int R,register int v){
	X[++sum]=X[k];
	k=sum;
	if(l==L&&R==r){
		X[k].data+=v;
		return ;
	}
	ll mid=(l+r)>>1;
	if(R<=mid)
	  updata(X[k].lchild,l,mid,L,R,v);
	else if(L>mid)
	  updata(X[k].rchild,mid+1,r,L,R,v);
	else{
		updata(X[k].lchild,l,mid,L,mid,v);
		updata(X[k].rchild,mid+1,r,mid+1,R,v);
	}
}
inline void qurey(register int k,register int l,register int r,register int i,register ll &t){
	if(!k)
	  return ;
	t+=X[k].data;
	if(l==i&&r==i)
	  return ;
	register int mid=(l+r)>>1;
	if(i<=mid)
	  qurey(X[k].lchild,l,mid,i,t);
	else
	  qurey(X[k].rchild,mid+1,r,i,t);
}
class Tree1{
public:
	struct Node{
		ll data;
		ll tag;
	}X[N<<2];
	inline void add(register int k,register ll v){
		X[k].data+=v;
		X[k].tag+=v;
	}
	inline void push_down(register int k){
		if(X[k].tag){
			add(k<<1,X[k].tag);
			add(k<<1|1,X[k].tag);
			X[k].tag=0;
		}
	}
	inline void updata(register int k,register int L,register int R,register int l,register int r,register int v){
		if(L==l&&r==R){
			add(k,v);
			return ;
		}
		push_down(k);
		register int mid=(L+R)>>1;
		if(r<=mid)
		  updata(k<<1,L,mid,l,r,v);
		else if(l>mid)
		  updata(k<<1|1,mid+1,R,l,r,v);
		else{
			updata(k<<1,L,mid,l,mid,v);
			updata(k<<1|1,mid+1,R,mid+1,r,v);
		}
	}
	inline ll qurey(register int k,register int L,register int R,register int i){
		if(L==i&&i==R)
		  return X[k].data;
		push_down(k);
		register int mid=(L+R)>>1;
		if(i<=mid)
		  return qurey(k<<1,L,mid,i);
		else
		  return qurey(k<<1|1,mid+1,R,i);
	}
}T1;
class Tree2{
public:
	struct Node{
		int l,r;
		ll data;
		ll tag1;
		ll tag2;
	}X[N<<2];
	inline void add(register int k,register ll v){
		X[k].data+=v;
		X[k].tag1+=v;
		if(X[k].tag2!=-INF)
		  X[k].tag2+=v;
	}
	inline void Max(register int k,register ll v){
		X[k].data=max(X[k].data,v);
		X[k].tag2=max(X[k].tag2,v);
	}
	inline void push_down(register int k){
		if(X[k].tag1){
			add(k<<1,X[k].tag1);
			add(k<<1|1,X[k].tag1);
			X[k].tag1=0;
		}
		if(X[k].tag2!=-INF){
			Max(k<<1,X[k].tag2);
			Max(k<<1|1,X[k].tag2);
			X[k].tag2=-INF;
		}
	} 
	inline void build(register int k,register int l,register int r){
		X[k].l=l,X[k].r=r;
		X[k].tag2=-INF;
		if(l==r)
		  return ;
		register int mid=(l+r)>>1;
		build(k<<1,l,mid);
		build(k<<1|1,mid+1,r); 
	}
	inline void updata(register int k,register int l,register int r,register int v){
		if(X[k].l==l&&r==X[k].r){
			add(k,v);
			return ;
		}
		push_down(k);
		register int mid=(X[k].l+X[k].r)>>1;
		if(r<=mid)
		  updata(k<<1,l,r,v);
		else if(l>mid)
		  updata(k<<1|1,l,r,v);
		else{
			updata(k<<1,l,mid,v);
			updata(k<<1|1,mid+1,r,v);
		}
	}
	inline void Max(register int k,register int l,register int r,register int v){
		if(X[k].l==l&&r==X[k].r){
			Max(k,v);
			return ;
		}
		push_down(k);
		register ll mid=(X[k].l+X[k].r)>>1;
		if(r<=mid)
		  Max(k<<1,l,r,v);
		else if(l>mid)
		  Max(k<<1|1,l,r,v);
		else{
			Max(k<<1,l,mid,v);
			Max(k<<1|1,mid+1,r,v);
		}
	}
	inline ll qurey(register int k,register int i){
		if(X[k].l==i&&i==X[k].r)
		  return X[k].data;
		push_down(k);
		register ll mid=(X[k].l+X[k].r)>>1;
		if(i<=mid)
		  return qurey(k<<1,i);
		else
		  return qurey(k<<1|1,i);
	}
}T2;
int main(){
	n=read(),m=read(),q=read();
	T2.build(1,1,n);
	for(register int i=1;i<=q;i++){
		root[i]=root[i-1];
		op=read();
		if(op==1){
			l=read(),r=read(),c[i]=read(),k=read();
			T1.updata(1,1,n,l,r,k);
			T2.updata(1,l,r,k);
			updata(root[i],1,n,l,r,k);
		}
		else if(op==2){
			l=read(),r=read(),k=read();
			T2.updata(1,l,r,-k);
			T2.Max(1,l,r,0);
		}
		else{
			x=read(),y=read();
			register ll Max=T1.qurey(1,1,n,x);
			y+=Max-T2.qurey(1,x);
			if(y>Max){
				puts("0");
				continue;
			}
			register int l=1,r=i-1,ans=0;
			while(l<=r){
				register int mid=(l+r)>>1;
				register ll t=0;
				qurey(root[mid],1,n,x,t);
				if(t>=y){
					r=mid-1;
					ans=mid;
				} 
				else
				  l=mid+1;
			}
			write(c[ans]);
			putchar('\n');			
		}
	}
	return 0;
}
```

---


# [JOISC 2021] ビーバーの会合 2 (Day3)

## 题目背景

原限制 25s & 4096MB，但看起来不需要

## 题目描述

给定一棵有 $N$ 个点的树，每一个点上有一个人，这些人要开秘密会议。

假设一次秘密会议有 $P$ 个人参加，这 $P$ 个人分别在第 $p_1,p_2,\cdots,p_P$ 个点上。如果点 $k$ 满足下面这个值最小（$d(a,b)$ 为点 $a$ 到点 $b$ 的距离，$k$ 不需要满足 $k \in \{p_1,p_2,\cdots,p_P\}$）：

$$\sum\limits_{i=1}^Pd(k,p_i)$$

那么就称第 $k$ 个点为可期待的，这场会议的期待值即为所有点中中可期待点的个数。

对于每个 $j \in [1,N]$，求当会议里有 $j$ 个人的时候，会议的期待值的最大值是多少。

## 说明/提示

#### 样例 1 解释

下文我们称 $\displaystyle\beta_k=\sum\limits_{i=1}^Pd(k,p_i)$。

拿样例 1 中的树举个例子，假设这一次会议参加者为第 $1$ 个点上的人和第 $3$ 个点上的人，则：

- $P=2$，$p_i=\{1,3\}$。
- $\beta_1=2$。
- $\beta_2=2$。
- $\beta_3=2$。
- $\beta_4=4$。
- $\beta_5=4$。

$\min\limits_{i=1}^5\{\beta_i\}=2$，满足要求的点为 $1,2,3$，该会议的期待值为 $3$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（4 pts）：$N \le 16$。
- Subtask 2（16 pts）：$N \le 4000$。
- Subtask 3（80 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2 \times 10^5$，$1 \le A_i,B_i \le N$。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day3 C ビーバーの会合 2 (Meetings 2) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/meetings2-en.pdf)。

## 样例 #1

### 输入

```
5
1 2
2 3
4 2
3 5```

### 输出

```
1
4
1
2
1```

## 样例 #2

### 输入

```
7
1 2
2 3
3 4
4 5
2 6
3 7```

### 输出

```
1
5
1
3
1
2
1```

# 题解

## 作者：chenxinyang2006 (赞：9)

其他题解已经指出了事实上本题在 $j$ 为奇数时必定 `puts 1`；而在 $j$ 为偶数时等价于找一对点 $u,v$，以 $u$ 为根时 $v$ 子树大小 $\ge j$，以 $v$ 为根时 $u$ 子树大小 $\ge j$，输出最大的可能 $dis(u,v)$，这里 $dis(u,v)$ 代表 $u \to v$ 简单路径上点数。

考虑取重心为根，计算出每个点 $p$ 此时的子树大小 $siz_p$ 以及深度 $dep_p$。那么 $u,v$ 的位置关系有两种：

- $u,v$ 没有祖先后代关系，此时限制等价于 $\min(siz_u,siz_v) \ge j$。

- $u,v$ 有祖先后代关系，此时可以注意到把祖先的那个点调整到重心 $heavy$ 一定仍满足限制（以任意点为根，重心的子树大小都 $\ge \dfrac{n}{2} \ge j$；而这样调整后代点的子树大小不变）且 $dis(u,v)$ 只会增加。所以对于这类情况只需考虑祖先点为 $heavy$ 的 case。

进一步地，我们直接放弃掉 $u,v$ 应没有祖先后代关系的限制，认为只要 $\min(siz_u,siz_v) \ge j$ 就可以找到一组 $dis(u,v)$ 的解。这样做对答案没有影响，因为此时以 $u$ 为根 $v$ 的子树大小一定 $\ge \dfrac{n}{2}$ 而 $siz_v \le \dfrac{n}{2}$，相当于是加紧了限制。

于是把所有点按照 $siz$ 从大到小排序，维护前缀点集直径即可对每个 $j$ 算出 $\min(siz_u,siz_v) \ge j$ 的点对 $(u,v)$ 中 $dis(u,v)$ 最大的一对。

而祖先点是 $heavy$ 的 case 显然也容易 $O(n)$ 处理。

理论上，使用 $O(n)-O(1)$ LCA，本题可以做到线性。

在此给出使用 $O(n \log n)-O(1)$ LCA 的代码：

```cpp
#include <bits/stdc++.h>
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
#define uint unsigned int
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define pii pair<int,int>
#define pll pair<ll,ll>
#define mkp make_pair
#define eb emplace_back
#define SZ(S) (int)S.size()
//#define mod 998244353
//#define mod 1000000007
#define inf 0x3f3f3f3f
#define linf 0x3f3f3f3f3f3f3f3f
using namespace std;

template <class T>
void chkmax(T &x,T y){
	if(x < y) x = y;
}

template <class T>
void chkmin(T &x,T y){
	if(x > y) x = y;
}

inline int popcnt(int x){
	return __builtin_popcount(x);
}

inline int ctz(int x){
	return __builtin_ctz(x);
}


/*ll power(ll p,int k = mod - 2){
	ll ans = 1;
	while(k){
		if(k % 2 == 1) ans = ans * p % mod;
		p = p * p % mod;
		k /= 2;	
	}
	return ans;
}*/
int n;
int result[100005];

int cnt;
int head[200005];
struct eg{
	int to,nxt;
}edge[400005];

void make(int u,int v){
	edge[++cnt].to = v;
	edge[cnt].nxt = head[u];
	head[u] = cnt;
}

int siz[200005],h[200005];
void dfs1(int u,int f){
	siz[u] = 1;
	h[u] = 0;
	for(int i = head[u];i;i = edge[i].nxt){
		int v = edge[i].to;
		if(v == f) continue;
		dfs1(v,u);
		siz[u] += siz[v];
		chkmax(h[u],siz[v]);
	}
}
int dfn[200005],dep[200005],fa[200005],ST[20][200005];
void dfs2(int u,int f){
	dfn[u] = ++cnt;
	ST[0][cnt] = u;
	dep[u] = dep[f] + 1;
	fa[u] = f;
	siz[u] = 1;
	for(int i = head[u];i;i = edge[i].nxt){
		int v = edge[i].to;
		if(v == f) continue;
		dfs2(v,u);
		siz[u] += siz[v];
	}
}
inline int cmp(int x,int y){
	if(dep[x] < dep[y]) return x;
	return y;
}

inline int qry(int l,int r){
	int x = __lg(r - l + 1);
	return cmp(ST[x][l],ST[x][r - (1 << x) + 1]);
}

inline int LCA(int u,int v){
	if(u == v) return u;
	u = dfn[u];v = dfn[v];
	if(u > v) swap(u,v);
	return fa[qry(u + 1,v)];
}

inline int getdis(int u,int v){
	return dep[u] + dep[v] - 2 * dep[LCA(u,v)];
}
int ord[200005];
bool cmp2(int x,int y){
	return siz[x] > siz[y];
}

int main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	scanf("%d",&n);
	rep(i,1,n - 1){
		int u,v;
		scanf("%d%d",&u,&v);
		make(u,v);make(v,u);
	}
	dfs1(1,0);
	int rt = -1;
	rep(u,1,n) if(max(h[u],n - siz[u]) <= n / 2) rt = u;
	cnt = 0;
	dfs2(rt,0);
	rep(i,1,17){
		rep(j,1,n){
			if(j + (1 << i) - 1 > n) break;
			ST[i][j] = cmp(ST[i - 1][j],ST[i - 1][j + (1 << (i - 1))]); 
		}
	}
	rep(i,1,n) ord[i] = i;
	sort(ord + 1,ord + n + 1,cmp2);

	int pu = 0,pv = 0,pw = 0,t1,t2;
	rep(_i,1,n){
		int u = ord[_i];
		if(u == rt) continue;

		if(!pu){
			pu = pv = u;
			continue;
		}
		t1 = getdis(u,pu);t2 = getdis(u,pv);
		if(t1 >= max(t2,pw)){
			pw = t1;
			pv = u;
		}else if(t2 >= max(t1,pw)){
			pw = t2;
			pu = u;
		}
		chkmax(result[siz[u]],pw + 1);
	}
	rep(u,1,n) if(u != rt) chkmax(result[siz[u]],dep[u]);
	result[n / 2 + 1] = 1;
	per(i,n / 2,1) chkmax(result[i],result[i + 1]);
	rep(i,1,n){
		if(i % 2) printf("1\n");
		else printf("%d\n",result[i / 2]);
	}
	return 0;
}
```


---

## 作者：ღꦿ࿐ (赞：5)

来讲个有点异类，不用点分治的单 $\log$ 做法。

在[我的博客](https://www.cnblogs.com/Dreamerkk/p/17175779.html)查看。

---

首先我们观察发现在奇数的时候答案是 $1$，偶数的时候答案才有可能不是 $1$，分析一下为什么是这样：

这种问题一般考虑边的贡献，对于一条边，假设它的一侧有 $x$ 个人，另一侧有 $i-x$ 个人，则我们可以通过把集合地点定在较小的那一侧以做到 $\min(x,i-x)$ 的贡献，如果定在另一侧则会是 $\max(x,i-x)$，这样不会使结果变劣当且仅当 $x=i-x=\frac i 2$，也就是说两侧的点是一样多的时候才可以移动到另一侧。

继续观察一下就是对于这个无根树，选两个不交，大小相等的子树，那么可能的集合地点就是两个顶点的路径上的所有点。

所以问题就被转化成了对于每个 $i$ 选两个不交，大小相等的子树使得它们的顶点之间的距离尽可能远。

考虑给树定一个根，然后就需要处理两种情况，第一种是两个没有包含关系的子树之间，第二种是一个子树和另一个子树的补树。

然后枚举 $i$，只考虑这些 $siz_u \geq i$ 的点两两之间的最长的路径，经典地，像 dfs 序求 LCA 一样的方式将路径看成三元组： $u\to l\to v$，则长度为 $d_u+d_v-2 d_l$ 其中 $d_x$ 表示 $x$ 的深度，这个东西可以看作 $a_x+b_y+a_z (x<y\leq z)$ 的最值，可以用线段树维护，将 $b_x$ 设成 $-d_x$，$a_x$ 设成负无穷或者深度即可。

然后就是一个点和它的祖先的补树的情况，这种情况很简单，直接在加入某个点的时候查下它子树内已经加入的点或者祖先中已经加入的点的最值就行了。

时间复杂度 $O(n\log n)$。

---

## 作者：Lice (赞：3)

### Description

给定一颗 $n$ 个点的树，点集为 $V$。$\forall i \in \{1, 2, \cdots, n\}$，求：

- 对于一个 $S\subseteq V$，将 $S$ 中的点点权设为 $1$，其他的点为 $0$。设 $f(S)$ 为带权重心的个数。
- 求 $\max\limits_{|S|=i} f(S)$。

### Constraints

$1\le n\le 2\cdot 10^5$。

### Solution

我菜死了，什么点分治倍增我完全不会，那么只好乱胡了一个线段树合并。发现我这种方法好像有点少，那就随便写一个了。

首先是一个必要的转化：

- 如果 $i$ 为奇数答案必然为 $1$；
- 如果 $i$ 为偶数，那么可以发现，如果有两个子树中带权的点数正好都为 $\tfrac i 2$，那么两个子树根连成的路径（包括两端）都可以作为重心。而要答案尽可能大的话，那么就在这个无根树上找出两个 $\ge \tfrac i 2$ 的子树即可，且两个根尽可能远。
  - 为了方便，考虑直接用“$=\tfrac i 2$”取代“$\ge \tfrac i 2$”，最后对答案数组做一遍后缀 $\max$ 即可。

然后就是比较传统的路径问题，只不过这里的子树大小不是对于当前分治区域而言的，而是从整棵树来看。然后大概是什么有根树点分治，不太会就抛掉了。

考虑树上问题的另一个经典思路：线段树合并。为了实现转化题意中两个 size 配对的过程（这种说法并不准确，下文会提到），我们的线段树以 size 为下标，以最大可能的深度为对应值。

在当前点 $x$​，合并两个子树的线段树时，如果合并到叶子就可以更新答案了。由于两点间距离的计算还需要 LCA 的深度，我们在合并是顺便带上 ${dep}_x$​​​。但这样存在一个问题，就是选取一个子树中的若干个点，但却不一定选取整个子树——相当于我们需要用这个子树的 $dep_x$​ 去更新线段树上 $[1, {siz}_x]$​ 的每一个位置。解决方案：利用动态开点，打上区间更新的标记，并在下传时新建节点。

这样可以实现子树间的信息合并，但还不够：父亲方向上的我们尚未考虑。容易发现，上方的点可以选择 $[1, n-{siz}_x]$ 个，不妨设每种选择方式距离 $x$ 最近的点为 $fa_x$，如果实际上可以更远那会在上面更新。现在对于位置 $[1, n-{siz}_x]$ 我们在打一个上下标记，值为 $dep_x -1$。同样在叶子节点上统计对答案的贡献。

注意 pushdown 时应先下传区间更新标记，再下传上下标记，dfs 是也用这样的顺序。pushdown 内如果下传到叶子也要更新答案。最后一棵总线段树需要把标记传干净。其他细节在写的时候就能发现了。复杂度 $O(n\log n)$。

### Code

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <vector>
const int N = 2e5 + 5;
const int K = 50;
const int inf = 0x3f3f3f3f;

std::vector<int> adj[N];
int n, ans[N * 2];

int siz[N], dep[N];
void init(int x, int f) {
  siz[x] = 1, dep[x] = dep[f] + 1;
  for (int i = 0; i < (int)adj[x].size(); i++) {
    int y = adj[x][i];
    if (y == f) continue;
    init(y, x), siz[x] += siz[y];
  }
}

#define mid ((l + r) >> 1)
int lc[N * K], rc[N * K], tot;
int maxd[N * K], tag[N * K], fill[N * K];
inline void pushdown(int x, int l, int r) {
  if (fill[x]) {
    if (!lc[x]) lc[x] = ++tot;
    maxd[lc[x]] = std::max(maxd[lc[x]], fill[x]);
    fill[lc[x]] = std::max(fill[lc[x]], fill[x]);
    if (!rc[x]) rc[x] = ++tot;
    maxd[rc[x]] = std::max(maxd[rc[x]], fill[x]);
    fill[rc[x]] = std::max(fill[rc[x]], fill[x]);
    fill[x] = 0;
  }
  if (tag[x] != inf) {
    if (lc[x]) {
      tag[lc[x]] = std::min(tag[x], tag[lc[x]]);
      if (r - l == 1)
        ans[l * 2] = std::max(ans[l * 2], tag[lc[x]] - maxd[lc[x]] + 1);
    }
    if (rc[x]) {
      tag[rc[x]] = std::min(tag[x], tag[rc[x]]);
      if (r - l == 1)
        ans[r * 2] = std::max(ans[r * 2], tag[rc[x]] - maxd[rc[x]] + 1);
    }
    tag[x] = inf;
  }
}
void insert(int& x, int l, int r, int ql, int qr, int d) {
  if (ql > r || l > qr) return;
  if (!x) x = ++tot;
  if (ql <= l && r <= qr) {
    fill[x] = std::max(fill[x], d);
    maxd[x] = std::max(maxd[x], d);
    return;
  }
  pushdown(x, l, r);
  insert(lc[x], l, mid, ql, qr, d);
  insert(rc[x], mid + 1, r, ql, qr, d);
  maxd[x] = std::max(maxd[lc[x]], maxd[rc[x]]);
}
int merge(int x, int y, int l, int r, int cur) {
  if (!x || !y) return x | y;
  if (l == r) {
    ans[l * 2] = std::max(ans[l * 2], maxd[x] + maxd[y] - cur * 2 + 1);
    maxd[x] = std::max(maxd[x], maxd[y]);
    return x;
  }
  pushdown(x, l, r);
  pushdown(y, l, r);
  lc[x] = merge(lc[x], lc[y], l, mid, cur);
  rc[x] = merge(rc[x], rc[y], mid + 1, r, cur);
  maxd[x] = std::max(maxd[lc[x]], maxd[rc[x]]);
  return x;
}
int at(int x, int l, int r, int ql, int qr) {
  if (ql > r || l > qr || !x) return 0;
  if (ql <= l && r <= qr) return maxd[x];
  pushdown(x, l, r);
  return std::max(at(lc[x], l, mid, l, r), at(rc[x], mid + 1, r, l, r));
}
void update(int x, int l, int r, int ql, int qr, int dtop) {
  if (!x || ql > r || l > qr) return;
  if (ql <= l && r <= qr) {
    tag[x] = std::min(tag[x], dtop);
    if (l == r) ans[l * 2] = std::max(ans[l * 2], tag[x] - maxd[x] + 1);
    return;
  }
  pushdown(x, l, r);
  update(lc[x], l, mid, ql, qr, dtop);
  update(rc[x], mid + 1, r, ql, qr, dtop);
}
void flush(int x, int l, int r) {
  if (!x) return;
  if (l == r) {
    ans[l * 2] = std::max(ans[l * 2], maxd[x] - tag[x] + 1);
    return;
  }
  pushdown(x, l, r);
  flush(lc[x], l, mid);
  flush(rc[x], mid + 1, r);
}
#undef mid

int solve(int x, int f) {
  int root = 0;
  for (int i = 0; i < (int)adj[x].size(); i++) {
    int y = adj[x][i];
    if (y == f) continue;

    int sub = solve(y, x);
    root = merge(root, sub, 1, n, dep[x]);
  }
  insert(root, 1, n, 1, siz[x], dep[x]);
  if (x != 1)
    update(root, 1, n, 1, n - siz[x], dep[x] - 1);
  return root;
}

signed main() {
  memset(tag, inf, sizeof(tag));

  scanf("%d", &n);
  for (int i = 1, u, v; i < n; i++) {
    scanf("%d%d", &u, &v);
    adj[u].push_back(v);
    adj[v].push_back(u);
  }

  init(1, 0);
  int root = solve(1, 0);
  flush(root, 1, n);

  for (int i = n; i; --i) {
    ans[i] = std::max(ans[i], 1);
    if (!(i & 1)) ans[i] = std::max(ans[i], ans[i + 2]);
  }

  for (int i = 1; i <= n; i++)
    printf("%d\n", ans[i]);
  return 0;
}
```

同步于：https://www.cnblogs.com/-Wallace-/p/uoj618.html

---

## 作者：Unnamed114514 (赞：2)

来个 $O(n\log n)$ 的点分治。

定义“关键边”为路径两端都为中心的边。

考虑平移找到关键边的条件。

容易发现两边距离应该是相等的，所以两边的点数是相等的。因此，容易发现，关键边两边的关键点点数应该是相等的，所以当点数为奇数时答案为 $1$。

因此，所有的重心一定会是条链。而链又分为两种：

- 链上两点成祖孙关系，令链上从上往下第二个点为 $t$，那么贡献为 $\min\{n-siz_t,siz_u\}$。

- 否则贡献为 $\min\{siz_u,siz_v\}$。

注意此时只算了最多的点数，所以求答案的时候还要取后缀 $\max$，同时，点不一定能均分，所以答案要和 $1$ 取 $\max$。

点分的时候，第一种显然可以直接算，对于第二种，考虑钦定 $\min$。

然后我们要找到 $siz$ 大于等于它的不和它在同一个子树的点中 $dep$ 最大的那一个，开个桶然后维护 $dep$ 的最大和次大保证这两个不在同一个子树内即可。

::::info[code]

```cpp line-numbers
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f 
#define endl '\n'
using namespace std;
const int N=2e5+5;
int n,tot,r,f[N],siz[N],dep[N],top[N];
bool flg[N];
vector<int> G[N];
vector<pair<int,int> > t[N];
void dfs1(int u,int fa){
	siz[u]=1,++tot;
	for(auto v:G[u]){
		if(flg[v]||v==fa) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
	}
}
void dfs2(int u,int fa){
	int mx=tot-siz[u];
	for(auto v:G[u]){
		if(flg[v]||v==fa) continue;
		dfs2(v,u);
		mx=max(mx,siz[v]);
	}
	if(mx<=tot/2) r=u;
}
void dfs(int u,int fa){
	siz[u]=1;
	for(auto v:G[u]){
		if(flg[v]||v==fa) continue;
		top[v]=top[u],dep[v]=dep[u]+1;
		dfs(v,u);
		siz[u]+=siz[v];
	}
	t[siz[u]].emplace_back(make_pair(top[u],dep[u]));
}
void update(int u,int fa){
	f[min(siz[u],siz[r]-siz[top[u]])]=max(f[min(siz[u],siz[r]-siz[top[u]])],dep[u]);
	for(auto v:G[u]){
		if(flg[v]||v==fa) continue;
		update(v,u); 
	}
}
void dfz(int u){
	tot=0,dfs1(u,0),dfs2(u,0);
	dep[r]=1,siz[r]=1;
	for(auto v:G[r]){
		if(flg[v]) continue;
		top[v]=v,dep[v]=dep[r]+1;
		dfs(v,r);
		siz[r]+=siz[v];
	}
	for(auto v:G[r]){
		if(flg[v]) continue;
		update(v,r);
	}
	pair<int,int> p[2];
	p[0]=make_pair(-inf,-inf);
	p[1]=make_pair(-inf,-inf);
	for(int i=siz[r];i;--i) for(auto w:t[i]){
		if(w.first==p[0].first) f[i]=max(f[i],w.second+p[1].second-1);
		else f[i]=max(f[i],w.second+p[0].second-1);
		if(w.second>p[0].second){
			if(p[0].first!=w.first) p[1]=p[0];
			p[0]=w;
		} else if(w.second>p[1].second&&w.first!=p[0].first) p[1]=w;
	}
	for(int i=1;i<=siz[r];++i) t[i].clear(),t[i].shrink_to_fit();
	flg[r]=1;
	for(auto v:G[r]){
		if(flg[v]) continue;
		dfz(v);
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1,u,v;i<n;++i){
		cin>>u>>v;
		G[u].emplace_back(v);
		G[v].emplace_back(u);
	}
	dfz(1);
	for(int i=n;i;--i) f[i]=max(f[i],f[i+1]);
	for(int i=1;i<=n;++i)
		if(i&1) cout<<1<<endl;
		else cout<<max(1,f[i>>1])<<endl; 
	return 0;
}
```
::::

---

## 作者：WZKQWQ (赞：2)

### 前言

题解区都是淀粉质啊，蒟蒻没学好淀粉质，所以这是一篇虚树的题解。

又是%你赛赛时 AC 的一道题，个人感觉是比上一场的[榕树之心](https://www.luogu.com.cn/problem/P4228)简单很多（紫题比黑题简单好像蛮正常的？？？）。

依旧是顺着赛时的思路讲解这道题，我可能有点笨需要绕很多弯才能做出正解，拜谢一眼秒的大佬。

### 正文

####  约定

$siz_x$ 为以 $x$ 为根的子树大小（包括 $x$），

$j$ 指的其实是 $\frac{j}{2}$，因为只用做偶数，你需要在下文默认这件事情（因为这么做的理由很好理解）。

#### step-2

观察样例发现奇数答案全是 $1$，思考一下为什么，发现和“平衡”有关，对于每种选人方法，能成为会议地点的点其实都在一条链上，这条链两个端点所处的连通块大小都 $\ge j$，这样可以从两端分别选出 $j$ 个点，于是达到了“平衡”，而我们要求的答案其实就是最长的链的点数（还是注意是点数）。

#### step-1（这部分主要讲赛时的猜想与验证，可以跳过）

有了上面的结论我开始大胆猜想：答案一定在直径上！

然后发现是错的，很容易 hack，先来一条很长的链做直径，然后在它的中点上连两个比较短的链，这两个链的末尾连一堆点，显然，当 $j$ 较大时答案不会在直径上。



#### step0

到此思路就断了，我们不妨暴力枚举链试试，这样链会分成两类：

1. 对于没有祖先后代关系的 $x,y$，链能贡献到 $j$ 的条件是 $siz_x\ge j,siz_y\ge j$（理由显然）。

2. 对于有祖先后代关系的 $x,y$，我们默认 $y$ 是 $x$ 的祖先，我们记 $z$ 为 $y$ 连向 $x$ 的链上的第二个点（第一个点是 $y$ 本身），链能够贡献到 $j$ 的条件是 $siz_x\ge j,n-siz_z\ge j$ 。

#### step1

对于第一部分，我们可以考虑对每个 $j$ 建一棵虚树，所有 $siz_x\ge j$ 的 $x$ 以及它们的 $\text{lca}$ 都在虚树中，那么原问题转化成求虚树的直径，会发现直接做虚树总点数是 $O(n^2)$ 级别的。

有一个复杂度上的优化是如果一个点 $y$ 的儿子 $x$ 已经 $siz_x\ge j$ 了那么不用加入点 $y$ 了，因为求直径时直径的两端一定是叶子节点（但是如果是 $lca$ 那么需要加），这个小优化可以把总点数优化到 $O(n\log n)$。

有了以上这些东西我们得到了两种复杂度不同的实现（取决与你建虚树是 $O(n)$ 还是 $O(n\log n)$）：$O(n\log n)$ 或 $O(n\log^2n)$。

#### step2

第二部分看起来好像不太好做，设 $y$ 是祖先， $x$ 是儿子，我们需要解决成求 $x$ 子树内 $siz_z\ge j$ 的深度最深的 $z$ 的深度，这个可以用线段树合并做，然后我们直接枚举 $y$，然后枚举 $y$ 的儿子 $son$， 对于 $y$ 能在 $son$ 的子树内贡献到的 $j$ 的限制，运用第一部分优化的思想不难写出 $y$ 能贡献到的 $j$ 在这个范围内 $[n - siz_y + 1,\min(siz_{son},n - siz_{son})]$。

易证查询次数是 $O(n\log n)$ 级别的，直接做是 $O(n\log^2n)$ 但是注意到一些查询是连续的的所以可以每次把连续查询涉及的区间剖出来再一个一个查询，这样总复杂度就是 $O(n\log n)$。

因此第二部分的复杂度为 $O(n\log n)$ ~ $O(n\log^2n)$，取决与你加不加优化。

下面给出一份 $O(n\log^2n)$ 的实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200005,Log = 20;
struct node{
	int ls,rs,mx;
}t[N * Log];
int _tot;
void add(int &x,int l,int r,int v,int p){
	if(!x) x = ++_tot;
	t[x].mx = max(t[x].mx,p);
	if(l == r) return;
	int mid = (l + r) >> 1;
	if(v <= mid) add(t[x].ls,l,mid,v,p);
	else add(t[x].rs,mid + 1,r,v,p);
}
int merge(int x,int y){
	if(!x || !y) return x + y;
	t[x].mx = max(t[x].mx,t[y].mx);
	t[x].ls = merge(t[x].ls,t[y].ls);
	t[x].rs = merge(t[x].rs,t[y].rs);
	return x;
}
int ask(int x,int l,int r,int lp,int rp){
	if(!x) return 0;
	if(lp <= l && rp >= r) return t[x].mx;
	int mid = (l + r) >> 1,tmp = 0;
	if(lp <= mid) tmp = max(tmp,ask(t[x].ls,l,mid,lp,rp));
	if(rp > mid) tmp = max(tmp,ask(t[x].rs,mid + 1,r,lp,rp));
	return tmp;
}
vector<int>e[N],o[N];
int n,fa[N][Log],d[N],siz[N],dfn[N],tot,dfnmx[N],ans[N];
int head[N];
void dfs(int x){
	add(head[x],1,n,siz[x],d[x]);
	for(int to:e[x]){
		if(to == fa[x][0]) continue;
		dfs(to);
		int ed = min(siz[to],n - siz[to]);
		for(int i = n - siz[x];i <= ed;++i) ans[i] = max(ans[i],ask(head[to],1,n,i,n) - d[x] + 1);
		head[x] = merge(head[x],head[to]);
	}
}
void build(int x){
	dfnmx[x] = dfn[x] = ++tot;
	siz[x] = 1;
	for(int j = 1;j < Log;++j) fa[x][j] = fa[fa[x][j - 1]][j - 1];
	int mx1 = 0;
	for(int to:e[x]){
		if(to == fa[x][0]) continue;
		fa[to][0] = x;
		d[to] = d[x] + 1;
		build(to);
		siz[x] += siz[to];
		mx1 = max(mx1,siz[to]);
		dfnmx[x] = max(dfnmx[x],dfnmx[to]);
	}
	for(int i = mx1 + 1;i <= min(siz[x],n / 2);++i) o[i].push_back(x);
}
bool cmp(int x,int y){return dfn[x] < dfn[y];}
int lca(int x,int y){
	if(d[x] < d[y]) swap(x,y);
	for(int i = Log - 1;i >= 0;--i) if(fa[x][i] && d[fa[x][i]] >= d[y]) x = fa[x][i];
	if(x == y) return x;
	for(int i = Log - 1;i >= 0;--i) if(fa[x][i] && fa[y][i] && fa[x][i] != fa[y][i])
		x = fa[x][i],y = fa[y][i];
	return fa[x][0];	
}
stack<int>s;
int mx[2 * N],_mx[2 * N];
int read(){
	int x = 0;
	char ch = getchar();
	for(;ch < '0' || ch > '9';ch = getchar());
	for(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar('0' + x % 10);
}
int main(){
	//freopen("island.in","r",stdin);
	//freopen("island.out","w",stdout);
	n = read();
	for(int i = 1,x,y;i < n;++i){
		x = read(),y = read();
		e[x].push_back(y);
		e[y].push_back(x);
	}
	build(1);
	for(int i = 1;i <= n / 2;++i){
		sort(o[i].begin(),o[i].end(),cmp);
		int len = o[i].size();
		for(int j = 1;j < len;++j) o[i].push_back(lca(o[i][j - 1],o[i][j]));
		sort(o[i].begin(),o[i].end(),cmp);
		len = o[i].size();
		memset(mx,0,sizeof(int) * len);
		memset(_mx,0,sizeof(int) * len);
		for(int j = 0;j < len;++j){
			while(!s.empty()){
				if(dfn[o[i][j]] > dfnmx[o[i][s.top()]]){
					int x = s.top();
					s.pop();
					if(!s.empty()){
						int tmp = mx[x] + d[o[i][x]] - d[o[i][s.top()]];
						if(tmp > mx[s.top()]) _mx[s.top()] = mx[s.top()],mx[s.top()] = tmp;
						else if(tmp > _mx[s.top()]) _mx[s.top()] = tmp;
					}
				} 
				else break;
			}
			s.push(j);
//			if(s.empty()) s.push(j);
//			else {
//				f[s.top()] = max(f[s.top()],d[o[i][j]] - d[o[i][s.top()]]);
//				s.push(j);
//			}
		}
		while(!s.empty()){
			int x = s.top();
			s.pop();
			if(!s.empty()){
				int tmp = mx[x] + d[o[i][x]] - d[o[i][s.top()]];
				if(tmp > mx[s.top()]) _mx[s.top()] = mx[s.top()],mx[s.top()] = tmp;
				else if(tmp > _mx[s.top()]) _mx[s.top()] = tmp;
			}
		}
		for(int j = 0;j < len;++j) ans[i] = max(ans[i],mx[j] + _mx[j] + 1);
	}
	dfs(1); 
	for(int i = 1;i <= n;++i){
		if(i & 1) putchar('1');
		else write(ans[i / 2]);
		putchar('\n');
	} 
	return 0;
}
/*
5
1 2
2 3
4 2
3 5

7
1 2
2 3
3 4
4 5
2 6
3 7

8
1 2
1 3
1 4
1 5
1 6
1 7
1 8

10
1 2
1 3
1 4
1 5
1 6
6 7
7 8
8 9
9 10

9
1 2
2 3
2 4
2 5
5 6
6 7
5 8
8 9

5
1 2
2 3
3 4
4 5
*/
```


---

## 作者：Graphcity (赞：1)

非常好题目，使我的 Bitaro 发光。

假如说我们已经选定了 $p_{1\cdots m}$ 这些点，那么期待点肯定是这些点集的重心。根据重心的性质，它的每棵子树都需要满足大小 $\le \dfrac{m}{2}$。大部分情况下重心只有一个。

如果有多个重心，那么从一个重心移动到另一个重心期间距离之和是不能变化的。也就是说，这些重心一定会形成一条路径。我们考虑这条路径的两个端点 $x,y$，那么从 $x,y$ 分出去的子树大小 **应该相等，且均等于 $\dfrac{m}{2}$**。

这也解释了为啥 $m$ 是奇数的时候答案为 1。接下来进行分类讨论：

- $x,y$ 在 LCA 的不同子树上

对于 $x,y$，能够造成贡献的最大 $m$ 为 $2\times \min(siz_x,siz_y)$。考虑 DSU on tree。维护 $val_i$ 表示子树 $siz=i$ 是最大的深度值，同时维护 $val$ 的后缀最大值数组 $suf$。dfs 过程中，先求出重子树的 $val$ 和 $pre$。加入轻子树时，根据这两个数组可以快速维护答案，同时也能快速更新这两个数组。

时间复杂度为 $O(n\log n)$，代码中为了方便 $pre$ 使用树状数组维护，$O(n\log^2n)$。

- $x,y$ 为祖先后代关系

用栈维护整条祖先链上的信息。对于 $x$ 的祖先 $y$，设 $fa_k=y$，能够造成贡献的最大 $m$ 为 $2\times \min(siz_x,n-siz_{k})$。对于 $siz_x\le n-siz_k$ 的情况，可以二分找到最浅的 $k$ 并计算贡献。否则，在最深的满足 $n-siz_k>siz_x$ 的祖先上打个 $dep_x$ 的标记，回溯时再根据标记内容计算贡献并上传标记。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=2e5,inf=1e9;

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

int n,fa[Maxn+5],siz[Maxn+5],son[Maxn+5],dep[Maxn+5];
int ans[Maxn+5],cur,top;
int val[Maxn+5],num[Maxn+5],t[Maxn+5];
int st[Maxn+5],anc[Maxn+5];
vector<int> v[Maxn+5];
#define lowbit(x) (x&-x)

inline void Add(int x,int y) {while(x) t[x]=max(t[x],y),x-=lowbit(x);}
inline void Clear(int x) {while(x) t[x]=-inf,x-=lowbit(x);}
inline int Count(int x) {int res=-inf; while(x<=n) res=max(res,t[x]),x+=lowbit(x); return res;}
inline void dfs1(int x,int f)
{
    fa[x]=f,siz[x]=1,dep[x]=dep[f]+1;
    for(auto y:v[x]) if(y!=f)
    {
        dfs1(y,x),siz[x]+=siz[y];
        if(siz[y]>siz[son[x]]) son[x]=y;
    }
}
inline void dfs2(int x,int f)
{
    if(x>1)
    {
        st[++top]=n-siz[x],anc[top]=f;
        int l=1,r=top+1;
        while(l<r)
        {
            int mid=(l+r)/2;
            if(st[mid]<siz[x]) l=mid+1; else r=mid;
        }
        if(l<=top) ans[siz[x]*2]=max(ans[siz[x]*2],dep[x]-dep[anc[l]]+1);
        if(l>1) val[anc[l-1]]=max(val[anc[l-1]],dep[x]);
    }
    for(auto y:v[x]) if(y!=f) dfs2(y,x);
    if(x>1)
    {
        int k=(n-siz[x])*2; ans[k]=max(ans[k],val[f]-dep[f]+1);
        val[fa[f]]=max(val[fa[f]],val[f]);
        val[f]=-inf,top--;
    }
}
inline void dfs4(int x)
{
    num[siz[x]]=max(num[siz[x]],dep[x]);
    for(auto y:v[x]) if(y!=fa[x]) dfs4(y);
}
inline void dfs5(int x,int tp)
{
    if(tp==1) val[siz[x]]=max(val[siz[x]],dep[x]),Add(siz[x],dep[x]);
    else val[siz[x]]=-inf,Clear(siz[x]);
    for(auto y:v[x]) if(y!=fa[x]) dfs5(y,tp);
}
inline void dfs3(int x,int tp)
{
    for(auto y:v[x]) if(y!=fa[x] && y!=son[x]) dfs3(y,0);
    if(son[x]) dfs3(son[x],1);
    int mx=0;
    for(auto y:v[x]) if(y!=fa[x] && y!=son[x])
    {
        dfs4(y),mx=siz[y];
        for(int i=mx,j=-inf;i>=1;--i)
        {
            j=max(j,num[i]);
            if(j>0 && val[i]>0) ans[i*2]=max(ans[i*2],val[i]+j-2*dep[x]+1);
        }
        For(i,1,mx)
        {
            int k=Count(i);
            if(num[i]>0 && k>0) ans[i*2]=max(ans[i*2],num[i]+k-2*dep[x]+1);
        }
        For(i,1,mx) num[i]=-inf; dfs5(y,1);
    }
    val[siz[x]]=max(val[siz[x]],dep[x]),Add(siz[x],dep[x]);
    if(!tp) dfs5(x,-1);
}

int main()
{
    n=read();
    For(i,1,n) ans[i]=1;
    For(i,1,n-1)
    {
        int a=read(),b=read();
        v[a].push_back(b),v[b].push_back(a);
    }
    dfs1(1,0);
    For(i,0,n) val[i]=num[i]=t[i]=-inf;
    dfs2(1,0);
    For(i,0,n) val[i]=num[i]=t[i]=-inf;
    dfs3(1,0);
    for(int i=n-(n&1);i;i-=2) ans[i]=max(ans[i],ans[i+2]);
    For(i,1,n) if(i&1) printf("1\n"); else printf("%d\n",ans[i]);
    return 0;
}
```



---

## 作者：Leasier (赞：1)

转化一下题意，得到：

- $\forall 1 \leq i \leq n$，求 $\max |S|$ 使得 $\exists T \subseteq \{1, 2, \cdots, n\}$，$|T| = i$，$S$ 为给 $T$ 中点赋值为 $1$、其他点赋值为 $0$ 时的**带权重心**集合。

考虑带权重心的性质，注意到重心的所有可选方案在 $T$ 固定时一定可以被表示为**一条链上的所有点**。

现在我们来看一下重心什么时候可以移动。在重心从 $u$ 移动到 $v$ 时，距离和的变化量即为在 $u$ 连通块中且在 $S$ 中的点数减去在 $v$ 连通块中且在 $S$ 中的点数。为了让距离和不变，两边在 $S$ 中的点数必须相等。

也就是说，这条链上除两端外，中间点的子树中不能有任何一个点在 $S$ 中，且在链没有退化为点的情况下，两端子树大小必须相等。

于是我们可以得出结论：

- 当 $i$ 为奇数，重心唯一，则答案为 $1$。
- 当 $i$ 为偶数，答案为 $\max (dis(u, v) + 1)$，满足把 $u \to v$ 上的所有路径割断后，$size_u, size_v \geq \frac{i}{2}$（即我们可以从两边各选出 $\frac{i}{2}$ 个点）。

无根树不方便考虑，接下来转化为以 $1$ 为根的有根树，于是需要分类讨论：

1. $u, v$ 不在一条链上

考虑用 set 维护当前满足 $size_u \geq \frac{i}{2}$ 的点集，每次取出最小的满足 $size_u < \frac{i}{2}$ 的 $u$ 并将其删除，若此时 $fa_u$ 的子树内已经没有其它被选的点了，则加入 $fa_u$。

把所有 $size_u \geq \frac{i}{2}$ 且互相没有祖先后代关系的点拿出来建虚树，此时虚树大小是 $O(\frac{n}{i})$ 的。在虚树上树形 dp 即可。

2. $u, v$ 在一条链上

考虑在上文提到 set 中枚举较深点 $u$，则我们需要找到 $u$ 的一个最浅祖先 $v'$，使得 $size_{v'} \leq n - \frac{i}{2}$，则最优的 $v = fa_{v'}$。倍增即可。

综上，时间复杂度为 $O(n \log n \ln n)$。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <set>
#include <stack>
#include <cmath>

using namespace std;

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

int in[200007];

typedef struct Node_tag {
	int pos;
	int dfn;
	Node_tag(){}
	Node_tag(int pos_){
		pos = pos_;
		dfn = in[pos];
	}
} Node;

int cnt1 = 0, cnt2 = 0;
int head1[200007], depth[200007], fa[200007][27], size[200007], out[200007], tree[200007], head2[200007], max_dis[200007];
bool vis[200007], mark[200007];
Edge edge1[400007], edge2[200007];
Node dot[400007];
set<pair<int, int> > se;
stack<int> stk;

bool operator <(const Node a, const Node b){
	return a.dfn < b.dfn;
}

inline void add_edge1(int start, int end){
	cnt1++;
	edge1[cnt1].nxt = head1[start];
	head1[start] = cnt1;
	edge1[cnt1].end = end;
}

void dfs1(int u, int father, int &id){
	int t;
	depth[u] = depth[father] + 1;
	t = log2(depth[u]);
	in[u] = ++id;
	fa[u][0] = father;
	size[u] = 1;
	for (register int i = 1; i <= t; i++){
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for (register int i = head1[u]; i != 0; i = edge1[i].nxt){
		int x = edge1[i].end;
		if (x != father){
			dfs1(x, u, id);
			size[u] += size[x];
		}
	}
	out[u] = id;
}

inline int lowbit(int x){
	return x & (-x);
}

inline void add(int n, int x, int k){
	while (x <= n){
		tree[x] += k;
		x += lowbit(x);
	}
}

inline int get_sum(int x){
	int ans = 0;
	while (x > 0){
		ans += tree[x];
		x -= lowbit(x);
	}
	return ans;
}

inline int get_last(int u, int k){
	if (size[u] > k) return 0x7fffffff;
	for (register int i = log2(depth[u]); i >= 0; i--){
		if (fa[u][i] != 0 && size[fa[u][i]] <= k) u = fa[u][i];
	}
	return depth[fa[u][0]];
}

inline int lca(int u, int v){
	if (depth[u] < depth[v]) swap(u, v);
	while (depth[u] > depth[v]) u = fa[u][(int)log2(depth[u] - depth[v])];
	if (u == v) return u;
	for (register int i = log2(depth[u]); i >= 0; i--){
		if (fa[u][i] != fa[v][i]){
			u = fa[u][i];
			v = fa[v][i];
		}
	}
	return fa[u][0];
}

inline bool check(int u, int v){
	return in[u] <= in[v] && in[v] <= out[u];
}

inline void add_edge2(int start, int end, int dis){
	cnt2++;
	edge2[cnt2].nxt = head2[start];
	head2[start] = cnt2;
	edge2[cnt2].end = end;
	edge2[cnt2].dis = dis;
}

int dfs2(int u){
	if (mark[u]){
		max_dis[u] = 0;
		return 0;
	}
	int cmax_dis = -1e9, ans = 0;
	max_dis[u] = -1e9;
	for (register int i = head2[u]; i != 0; i = edge2[i].nxt){
		int x = edge2[i].end, y;
		ans = max(ans, dfs2(x));
		y = max_dis[x] + edge2[i].dis;
		if (max_dis[u] < y){
			cmax_dis = max_dis[u];
			max_dis[u] = y;
		} else if (cmax_dis < y){
			cmax_dis = y;
		}
	}
	return max(ans, max_dis[u] + cmax_dis);
}

int main(){
	int n, id = 0;
	cin >> n;
	for (register int i = 1; i < n; i++){
		int a, b;
		cin >> a >> b;
		add_edge1(a, b);
		add_edge1(b, a);
	}
	dfs1(1, 0, id);
	for (register int i = 1; i <= n; i++){
		if (size[i] == 1){
			se.insert(make_pair(size[i], i));
			add(n, in[i], 1);
		}
	}
	for (register int i = 1; i <= n; i++){
		if (i % 2 == 1){
			cout << 1 << endl;
			continue;
		}
		int down = i / 2, dot_cnt1 = 0, up = n - down, ancestor = 0, dot_cnt2;
		while (!se.empty()){
			pair<int, int> pr = *se.begin();
			if (pr.first >= down) break;
			se.erase(pr);
			add(n, in[pr.second], -1);
			if (fa[pr.second][0] != 0 && get_sum(out[fa[pr.second][0]]) - get_sum(in[fa[pr.second][0]] - 1) == 0){
				add(n, in[fa[pr.second][0]], 1);
				se.insert(make_pair(size[fa[pr.second][0]], fa[pr.second][0]));
			}
		}
		for (register set<pair<int, int> >::iterator j = se.begin(); j != se.end(); j++){
			dot[++dot_cnt1] = Node(j->second);
			vis[j->second] = mark[j->second] = true;
			ancestor = max(ancestor, depth[j->second] - get_last(j->second, up) + 1);
		}
		sort(dot + 1, dot + dot_cnt1 + 1);
		dot_cnt2 = dot_cnt1;
		for (register int j = 1; j < dot_cnt1; j++){
			int cur_lca = lca(dot[j].pos, dot[j + 1].pos);
			if (!vis[cur_lca]){
				vis[cur_lca] = true;
				dot[++dot_cnt2] = Node(cur_lca);
			}
		}
		if (!vis[1]){
			vis[1] = true;
			dot[++dot_cnt2] = Node(1);
		}
		sort(dot + 1, dot + dot_cnt2 + 1);
		for (register int j = 1; j <= dot_cnt2; j++){
			while (!stk.empty() && !check(stk.top(), dot[j].pos)) stk.pop();
			if (!stk.empty()){
				int cur = stk.top();
				add_edge2(cur, dot[j].pos, depth[dot[j].pos] - depth[cur]);
			}
			stk.push(dot[j].pos);
		}
		cout << max(ancestor, dfs2(1) + 1) << endl;
		cnt2 = 0;
		while (!stk.empty()) stk.pop();
		for (register int j = 1; j <= dot_cnt2; j++){
			head2[dot[j].pos] = 0;
			vis[dot[j].pos] = mark[dot[j].pos] = false;
		}
	}
	return 0;
}
```

---

## 作者：7KByte (赞：1)

首先 $j$ 为奇数时答案为 $1$ 。

简单证明，$j$ 个点之间的重心一定是一个可期待点。

根据重心的性质，所有可能的重心一定构成一条链。

那么已知一个重心为 $x$ ，如果要移动到一个相邻点 $y$ ，则断开 $(x,y)$ 后两颗子树大小一定相同。

而 $j$ 为奇数时两边一定一奇一偶，不可能相等。

同理我们可以推出对于偶数 $j$ 的答案是最长的链的长度使得链两端的子树大小 $\ge \dfrac{j}{2}$ 。

求所有满足条件的链中长度最大的，比较套路的做法是点分治。

我们开一个桶记录后缀最大值即可，更新答案时合并两个桶即可。

一个细节是点分治时单链可以单独作为答案，因为分治时取的是重心，所以每一个子树大小一定 $\le \dfrac{size}{2}$ 。

时间复杂度 $\mathcal{O}(N\log N)$ 。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 200005
using namespace std;
int n,h[N],tot,v[N],sz[N],u[N],w[N],ed,mn,cs,ans[N];
struct edge{int to,nxt;}e[N<<1];
void add(int x,int y){e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;}
void find(int x,int fa){
	sz[x]=1;int cur=0;
	for(int i=h[x];i;i=e[i].nxt)if(e[i].to!=fa&&!v[e[i].to])
		find(e[i].to,x),cur=max(cur,sz[e[i].to]),sz[x]+=sz[e[i].to];
	cur=max(cur,cs-sz[x]);
	if(cur<mn)mn=cur,ed=x;
}
void dfs(int x,int fa,int dis){
	sz[x]=1;
	for(int i=h[x];i;i=e[i].nxt)if(e[i].to!=fa&&!v[e[i].to])
		dfs(e[i].to,x,dis+1),sz[x]+=sz[e[i].to];
	w[sz[x]]=max(w[sz[x]],dis);
}
void calc(int x,int wsz){
	cs=mn=wsz;find(x,0);x=ed;
	int ct=0;v[x]=1;
	for(int i=h[x];i;i=e[i].nxt)if(!v[e[i].to]){
		int y=e[i].to;
		dfs(y,x,1);ct=max(ct,sz[y]);
		pre(j,sz[y],1)w[j]=max(w[j],w[j+1]),ans[j*2]=max(ans[j*2],w[j]+u[j]);
		rep(j,1,sz[y])u[j]=max(u[j],w[j]),w[j]=0;
	}
	rep(i,1,ct)u[i]=0;
	for(int i=h[x];i;i=e[i].nxt)if(!v[e[i].to])calc(e[i].to,sz[e[i].to]);
}
int main(){
	scanf("%d",&n);
	rep(i,1,n-1){
		int x,y;scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	calc(1,n);rep(i,1,n)printf("%d\n",ans[i]+1);
	return 0;
}
```

---

## 作者：GK0328 (赞：1)

### 有根树点分治

先分析一下题目，对于一次会议来说，我们把会议的出席者权值定义为$1$，那么满足条件的岛一定是树的带权重心。

经过分析（~~手模~~）可以发现，如果总权值$V$为奇数，那么答案为$1$。如果权值$V$为偶数，可能会出现一条全$0$链，链的两端子树权值为$\frac{V}{2}$，那么整条全$0$链以及两端的子树的根节点都是合法的。

那么对于一个偶权值$V$来说，我们需要找到一条长度最大的链，满足链的两端子树大小均$\ge \frac{V}{2}$。

$\ge$并不容易，但是我们可以把它直接变成$=$，然后一遍后缀$\max$。

查询所有链信息，很容易想到点分治，问题在于如何处理子树大小，显然这里的子树大小不仅仅是钦定一个根情况下的子树大小。

我们可以先确定一个根，在有根情况下计算出每棵子树的大小，对于点分中心$u$来说，向原有根树父亲方向的那条链，子树大小需要修改。然后枚举较小的子树大小，在其他的$u$子树内查询比它子树大小更大的那些节点中，深度的最大值，由于需要去重，需要正序倒序两次线段树处理。需要注意的是，$u$节点与其他节点连成的链的答案需要单独计算，对于祖先节点及其子树和子孙节点，$u$对应的子树大小是不同的。

然后就做完力！

时间复杂度：$O(n \log^2 n)$。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<vector>
#define IT vector<int> :: iterator
#define N 200005
using namespace std;
const int INF=1000000007;
int n,x,y,ans[N];
int rtsz,rt,lsz;
struct edge
{
    int nxt,v;
    edge () {}
    edge (int Nxt,int V):nxt(Nxt),v(V) {}
}e[N << 1];
int tot,fr[N],sz[N],fa[N],cz[N],tz[N],dep[N];
bool vis[N];
void add(int x,int y)
{
    e[++tot]=edge(fr[x],y),fr[x]=tot;
}
void dfs(int u,int F)
{
    cz[u]=1;
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (v==F)
            continue;
        fa[v]=u,dfs(v,u);
        cz[u]+=cz[v];
    }
}
void findrt(int u,int F,int rn)
{
    int mx(-1);
    sz[u]=1;
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (vis[v] || v==F)
            continue;
        findrt(v,u,rn);
        sz[u]+=sz[v];
        mx=max(mx,sz[v]);
    }
    mx=max(mx,rn-sz[u]);
    if (mx<rtsz)
        rtsz=mx,rt=u;
}
void getrt(int u,int rn)
{
    rtsz=INF,findrt(u,0,rn);
}
int tr[N << 2];
void update(int p)
{
    tr[p]=max(tr[p << 1],tr[p << 1 | 1]);
}
void modify(int p,int l,int r,int x,int y)
{
    tr[p]=max(tr[p],y);
    if (l==r)
        return;
    int mid(l+r >> 1);
    if (x<=mid)
        modify(p << 1,l,mid,x,y); else
        modify(p << 1 | 1,mid+1,r,x,y);
    update(p);
}
int calc(int p,int l,int r,int x,int y)
{
    if (l==x && r==y)
        return tr[p];
    int mid(l+r >> 1);
    if (y<=mid)
        return calc(p << 1,l,mid,x,y); else
    if (x>mid)
        return calc(p << 1 | 1,mid+1,r,x,y); else
        return max(calc(p << 1,l,mid,x,mid),calc(p << 1 | 1,mid+1,r,mid+1,y));
}
void cleanseg(int p,int l,int r)
{
    if (!tr[p])
        return;
    tr[p]=0;
    if (l==r)
        return;
    int mid(l+r >> 1);
    cleanseg(p << 1,l,mid);
    cleanseg(p << 1 | 1,mid+1,r);
}
void toseg(int u,int F)
{
    modify(1,1,n,tz[u],dep[u]);
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (v==F || vis[v])
            continue;
        toseg(v,u);
    }
}
void calc(int u,int F)
{
    int t(calc(1,1,n,tz[u],n));
    if (t)
        ans[tz[u]]=max(ans[tz[u]],dep[u]+t+1);
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (v==F || vis[v])
            continue;
        dep[v]=dep[u]+1;
        calc(v,u);
    }
}
void calc(int u,int F,int t)
{
    ans[min(tz[u],t)]=max(ans[min(tz[u],t)],dep[u]+1);
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (v==F || vis[v])
            continue;
        calc(v,u,t);
    }
}
void calc(int u)
{
    int x(fa[u]),pre(u);
    while (x && !vis[x])
        tz[x]=n-cz[pre],pre=x,x=fa[x];
    vector<int>V;
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (vis[v])
            continue;
        V.push_back(v);
        dep[v]=1,calc(v,0),toseg(v,0);
    }
    cleanseg(1,1,n);
    reverse(V.begin(),V.end());
    for (IT it=V.begin();it!=V.end();++it)
    {
        int v(*it);
        dep[v]=1,calc(v,0),toseg(v,0);
    }
    cleanseg(1,1,n);
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (vis[v])
            continue;
        calc(v,0,(v==fa[u])?cz[u]:n-cz[v]);
    }
    cleanseg(1,1,n);
    x=fa[u];
    while (x && !vis[x])
        tz[x]=cz[x],x=fa[x];
}
void solve(int u)
{
    int tsz(lsz);
    vis[u]=true;
    calc(u);
    for (int i=fr[u];i;i=e[i].nxt)
    {
        int v(e[i].v);
        if (vis[v])
            continue;
        lsz=(sz[u]>sz[v])?sz[v]:tsz-sz[u];
        getrt(v,lsz);
        solve(rt);
    }
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<n;++i)
    {
        scanf("%d%d",&x,&y);
        add(x,y),add(y,x);
    }
    dfs(1,0);
    memcpy(tz,cz,(n+1)*sizeof(int));
    getrt(1,n),lsz=n;
    solve(rt);
    ans[n+1]=1;
    for (int i=n;i;--i)
        ans[i]=max(ans[i],ans[i+1]);
    for (int i=1;i<=n;++i)
        if (i & 1)
            puts("1"); else
            printf("%d\n",ans[i >> 1]);
    return 0;
}
```

---


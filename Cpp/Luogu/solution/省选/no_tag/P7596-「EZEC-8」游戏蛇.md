# 「EZEC-8」游戏蛇

## 题目描述

小 A 和小 B 是两条蛇，他们正在一棵特殊的树上做游戏。

这棵树的结构如下：首先有一条长度为 $n$ 的链，称为“主链”。主链由 $1$ 至 $n$ 这 $n$ 个节点构成。在主链上，编号相邻的点有边相连，否则则没有。

主链上的每一个点都挂着一条链，称为“副链”。主链上的第 $i$ 个点挂的副链长度（链上的点数）为 $x_i$。

小 A 和小 B 初始时都在主链上，具体而言，小 A 的**蛇尾**在点 $a$，**蛇头**在点 $b$，小 B 的**蛇头**在点 $c$，**蛇尾**在点 $d$。满足 $1\le a<b<c<d\le n$。

他们的游戏规则如下：
- 小 A 和小 B 轮流移动，小 A 先手。
- 每条蛇移动时，他会尝试整体向某一方向移动一个节点，**但不能向原来蛇尾方向移动，也就是蛇不能倒退**。需满足移动后蛇头不得与另外一条蛇的任意部分重合。
- 当一条蛇无法移动时，游戏结束，对手获胜。

现在有 $q$ 次询问，每次询问给定 $a,b,c,d$，请求出当两条蛇都采取最优策略时，哪一条蛇会获胜。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（10 points）：$n,q \le500$。
-  Subtask 2（10 points）：$n\le10^5$，$q\le500$。
-  Subtask 3（5 points）：所有 $x_i$ 都相等。
-  Subtask 4（10 points）：所有询问中小 A 和小 B 的长度总和不超过 $5\times10^7$。
-  Subtask 5（15 points）：$x_i$ 在 $[1,10^9]$ 内随机生成。
-  Subtask 6（20 points）：$n\le5\times10^3$。
-  Subtask 7（30 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le n,q\le5\times10^5$，$1\le x_i\le10^9$，$1\le a<b<c<d\le n$。

小 A 的长度定义为 $b-a+1$，小 B 的长度定义为 $d-c+1$。

## 样例 #1

### 输入

```
10 10
1 10 6 2 2 5 10 8 9 5
1 3 5 7
2 3 5 6
3 6 9 10
1 4 5 10
1 2 4 7
1 2 4 9
3 5 7 8
4 7 8 9
2 3 4 8
1 5 6 7```

### 输出

```
A
A
A
B
A
A
B
A
A
B```

# 题解

## 作者：ix35 (赞：11)

两个月前的一道洛谷月赛题。

在打那场比赛时，我最后一小时才开到这题，最后没调出来正解，赛后也就懒得管了。

但是今天模拟赛里又有这题，所以我就翻出了两个月前的代码重新调了一下，发现就是一个加号打成减号了......

顺便看了下题解，发现没有和我完全一样的做法，那就写一下吧......

---

这属于是一道比较简单的套路型数据结构题，我们抛开部分分不谈，直接分析正解。

这里给出的是一种不需要**线段树或其他高级数据结构**的**在线**做法，唯一需要的是 ST 表和二分。

对于每一个 $i$，考虑蛇 A 如果要进入 $i$ 的副链并要取得胜利，考虑要满足什么样的条件。

1. 蛇 B 向左不断走到达 $i$ 时，蛇 A 没有完全进入副链。

   否则蛇 B 跟着进来，先死的肯定是 A。

2. 蛇 B 从 $i$ 右边某个副链进去，能走的步数一定小于 A 能走的步数。

注意到第二个条件和两蛇长度都无关，首先分析。

假设当前蛇 B 在 $j$ 处（目前轮到 A 进入副链），如果存在一个 $mid\in (i,j]$ 使得 $x_i\leq (j-mid)+x_{mid}$，那么 A 就会输。

所以 A 要赢就要使得 $x_i>\max((j-mid)+x_{mid})$，右侧值对于 $j$ 有单调性，所以我们可以找到最大的 $j$，使得如果 B 在它右侧，那么 A 都会输。

也就是说，我们可以求出一个 $L_i$ 表示，当且仅当 B 头位于 $(i,L_i]$ 时，A 此时进入 $i$ 的副链才能**使得条件 $2$ 满足。**

这里的求法是先建立 $x_i-i$ 的 ST 表，然后对于每个 $i$ 二分。

同理我们求出 $R_i$ 表示，当且仅当 A 头位于 $[R_i,i)$ 时，B 此时进入 $i$ 的副链才能使得对于 B 必胜的条件来说**条件 $2$ 满足**。

---

接下来考虑条件 $1$ 的限制。

在条件 $1$ 中我们假设 B 一直往左走，也就是说 $t$ 秒后 B 的蛇头位置为 $c'=c-t$，再考虑 A 完全进入 $i$ 的副链的时间为第 $i-a+1$ 回合 A 行动之后，所以我们要求 $c-(i-a)\leq i$，也就是 $i\ge \dfrac{c+a}{2}$。

也就是说，只要我们钦定 A 能进入副链的 $i$ 必须落在 $L_0=\max(\dfrac{c+a}{2},b)$ 的右侧，那么条件 $1$ 自然满足。

---

而判定胜负的方法是：谁先进入一个进入则必胜的副链，谁就赢，所以对于 A 我们就要求出编号最小的进入则必胜的副链。

我们依然采用二分，可以进入的副链区间为 $[L_0,R_0]$，其中 $L_0$ 式子在上面，$R_0=\dfrac{b+c}{2}$ 是相撞位置。

我们要检验 $[L_0,mid]$ 中是否存在一个进入即必胜的副链，对于其中某个 $i$，考虑条件 $2$，当 A 蛇头到达 $i$ 也就是 $i-b$ 回合后，B 蛇头的位置应该是 $c-(i-b)$，根据之前的检验条件，需要 $L_i\ge c-(i-b)$，也就是 $L_i+i\ge c+b$。

所以我们又可以建立 $L_i+i$ 的 ST 表，然后求最大值来检验。

对于 B 最先见到的必胜副链，类似，只不过建立的是 $R_i+i$ 的最小值 ST 表。

---

综上，我们只使用 ST 表和二分，就在 $O((n+q)\log n)$ 的复杂度内在线地完成了本题。

---

## 作者：gyh20 (赞：7)

比赛时是按照 Subtask 一个一个写的，这里也一个一个的讲，如果直接讲解法可能过于突兀，但一个一个看过来这道题的解法还是非常自然。

#### Subtask1 $n,q\leq 500$

由于我太菜了发现不了任何性质，我只好写了个暴力：

两条蛇轮流移动，若当前拐入副链后可以获胜就拐，否则往前走。

另当前走的蛇为 $X$，另一条为 $Y$。

获胜的条件有两个：

$1.$ $Y$ 最多可以走的次数 $<$ $X$ 还可以走的次数，也就是说，枚举 $Y$ 在哪里拐，判断大小关系。

$2.$ 当 $Y$ 走到当前 $X$ 所在的位置时 $X$ 还没有完全进入，若 $X$ 完全进入，此时 $Y$ 可以直接跟在 $X$ 后面，$X$ 比败。

于是可以得到一个 $O(qn^2)$ 暴力。

```cpp
while(1){
	re int mx=0;
	for(re int i=Y;i>X;--i)mx=max(mx,Y-i+p[i]);
	if(a>Y-X&&mx<p[X]){ia=1;break;}
	else if(Y==X+1){ia=0;break;}
	else ++X;
	mx=0;
	for(re int i=X;i<Y;++i)mx=max(mx,i-X+p[i]);
	if(d>Y-X&&mx<p[Y]){ia=0;break;}
	else if(Y==X+1){ia=1;break;}
	else --Y;
}
```


#### Subtask2 $n\leq 10^5,q\leq 500$

很明显需要一个 $O(qn)$ 的做法。

观察上面的代码，发现瓶颈在于两个求 $\max$，拆开之后发现只需要维护 $p_i+i$ 和 $p_i-i$ 的 $\max$，可以直接用 ST 表优化。

#### Subtask3 $x_i$ 均相同

此时拐下去一定不优，故判断距离奇偶性即可。

#### Subtask4 $\sum len\leq 5\times 10^7$

发现上方代码中 break 的条件有一个 $a>Y-X$ 的要求，而 $a,d$ 代表的是两蛇长度，可以先算出可能会 break 的时间并直接从那个时间开始计算即可做到 $O(\sum len)$ 的复杂度。

#### Subtask5 $x_i$ 随机

这个我好像确实不会。

#### Subtask6 $n\leq 5000$

~~这也是个 $O(nq)$ 的做法但常数小过了。~~

假设不考虑 $a>Y-X,d>Y-X$，则对于同一个 $X$，当 $Y$ 上升时 $mx$ 的值一定会增加，也就是对于每一个 $X$，存在一条分界线，使得当 $Y$ 大于这条分界线时会 break，小于时不会，可以提前二分 $+$ ST表求出这条分界线。。

再考虑另外一个简单的套路，若我们知道第一次 break 时在谁的回合，则我们可以判断是谁获胜。由于每一次 $X$ 都会加一，$Y$ 都会减一，可以转化为对 $X$，$Y$ 分别计算。

```cpp
while(q--){
	re int a=read(),b=read(),c=read(),d=read(),ia=0,X=b,Y=c;a=b-a+1,d=d-c+1;
	if(ii){puts(((c-b)&1)?"B":"A");continue;}
	re int p1=Y+1,p2=X-1;//Y-X
	for(re int i=X;i<=Y;++i)if(a>Y-X-2*(i-X)&&Y-(i-X)<=f[i]&&Y-(i-X)>=i){p1=i;break;}
	for(re int i=Y;i>=X;--i)if(d>Y-X-1-2*(Y-i)&&X+1+(Y-i)>=g[i]&&X+1+(Y-i)<=i){p2=i;break;}
	if(p1==Y+1&&p2==X-1)puts(((c-b)&1)?"B":"A");
	else if(p1-X<=Y-p2)puts("A");
	else puts("B");
}
```
代码中的 $f_x$，$g_x$ 分别代表两条分界线。

#### Subtask7

最后再次观察上述代码。

for 循环中 $i$ 的范围可以直接算出来，于是可以丢掉 if 中的第一个判断。

发现 if 中的第三个判断语句一定没有用，直接删掉。

最后判断语句变成了

$Y-(i-X)\leq f_i$

$X+1+(Y-i)\geq g_i$

再次转化：


$Y+X\leq f_i+i$

$X+1+Y\geq g_i+i$

这个式子明显就是一个可以线段树二分的形式了！

总复杂度 $O((n+q)\log n)$
```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
const int Mxdt=100000;	//单次大小 
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline char pc(char ch,bool bj){
	static char buf[Mxdt],*p1=buf,*p2=buf+Mxdt;
	return (bj||(*p1++=ch)&&p1==p2)&&fwrite(p1=buf,1,p1-buf,stdout),0;
}
void print(int x)
{
	if(x>9)print(x/10);
	pc(x%10^48,false);
}
inline void printnum(int x,char ch)
{
	print(x),pc(ch,false);
}
inline int read(){
	re int t=0;re char v=gc();
	while(v<'0')v=gc();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=gc();
	return t;
}
const int M=998244353;
inline int ksm(re int x,re int y){
	re int s=1;
	while(y){
		if(y&1)s=1ll*s*x%M;
		x=1ll*x*x%M,y>>=1;
	}
	return s;
}
int n,q,p[500002],d1[500002],d2[500002],ii,s1[22][500002],s2[22][500002],L[500002],fst,f[500002],mx[2000002],g[500002],mn[2000002];
inline int ask1(re int l,re int r){re int tmp=L[r-l+1];return max(s1[tmp][l],s1[tmp][r-(1<<tmp)+1]);}
inline int ask2(re int l,re int r){re int tmp=L[r-l+1];return max(s2[tmp][l],s2[tmp][r-(1<<tmp)+1]);}
inline void build(re int p,re int l,re int r){
	if(l==r){mx[p]=f[l],mn[p]=g[l];return;}
	re int mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	mx[p]=max(mx[p<<1],mx[p<<1|1]),mn[p]=min(mn[p<<1],mn[p<<1|1]);
}
inline int find1(re int p,re int l,re int r,re int x,re int y,re int z){
	if(x>y)return 0;
	if(mx[p]<z)return 0;
	re int mid=l+r>>1,s=0;
	if(l>=x&&r<=y){
		if(l==r)return l;
		if(mx[p<<1]>=z)return find1(p<<1,l,mid,x,y,z);
		else return find1(p<<1|1,mid+1,r,x,y,z);
	}
	if(x<=mid)s=find1(p<<1,l,mid,x,y,z);
	if(!s&&y>mid)s=find1(p<<1|1,mid+1,r,x,y,z);
	return s;
}
inline int find2(re int p,re int l,re int r,re int x,re int y,re int z){
	if(x>y)return 0;
	if(mn[p]>z)return 0;
	re int mid=l+r>>1,s=0;
	if(l>=x&&r<=y){
		if(l==r)return l;
		if(mn[p<<1|1]<=z)return find2(p<<1|1,mid+1,r,x,y,z);
		else return find2(p<<1,l,mid,x,y,z);
	}
	if(y>mid)s=find2(p<<1|1,mid+1,r,x,y,z);
	if(!s&&x<=mid)s=find2(p<<1,l,mid,x,y,z);
	return s;
}
int main(){
	n=read(),q=read(),ii=1,L[0]=-1;
	for(re int i=1;i<=n;++i)L[i]=L[i>>1]+1,p[i]=read(),d1[i]=p[i]-i,d2[i]=p[i]+i,s1[0][i]=d1[i],s2[0][i]=d2[i];
	for(re int i=1;(1<<i)<=n;++i)for(re int j=1;j+(1<<i)-1<=n;++j)s1[i][j]=max(s1[i-1][j],s1[i-1][j+(1<<i-1)]),s2[i][j]=max(s2[i-1][j],s2[i-1][j+(1<<i-1)]);
	for(re int i=2;i<=n;++i)ii&=(p[i]==p[i-1]);
	if(!ii){
	for(re int i=1;i<=n;++i){
		re int l=i+1,r=n,pos=i;
		while(l<=r){
			re int mid=l+r>>1;
			if(mid+ask1(i+1,mid)<p[i])pos=mid,l=mid+1;
			else r=mid-1;
		}
		f[i]=pos+i;
	}
	for(re int i=1;i<=n;++i){
		re int l=1,r=i-1,pos=i;
		while(l<=r){
			re int mid=l+r>>1;
			if(-mid+ask2(mid,i-1)<p[i])pos=mid,r=mid-1;
			else l=mid+1;
		}
		g[i]=pos+i;
	}
	build(1,1,n);
	}
	while(q--){
		re int a=read(),b=read(),c=read(),d=read(),ia=0,X=b,Y=c;a=b-a+1,d=d-c+1;
		if(ii){pc(((c-b)&1)?'B':'A',0);pc('\n',0);continue;}
		re int S=Y-X;
		if(a<=S&&d<=S){
			re int dlt=S-max(a,d);
			X+=dlt>>1,Y-=dlt>>1;
		}
		re int p1=Y+1,p2=X-1;//Y-X
		p1=find1(1,1,n,max(X,(Y+X-a)/2+1),Y,X+Y);
		p2=find2(1,1,n,X,min(Y,(d+Y+X)/2),X+Y+1);
		if(!p1)p1=Y+1;
		if(!p2)p2=X-1;
		if(p1==Y+1&&p2==X-1)pc(((c-b)&1)?'B':'A',0);
		else if(p1-X<=Y-p2)pc('A',0);
		else pc('B',0);pc('\n',0);
	}pc('o',1);
}
```


---

## 作者：pocafup (赞：3)

验题人水题解

一些定义：

$posa$: 小 A 蛇头的位置

$posb$: 小 B 蛇头的位置

$lena$: 小 A 的长度

$lenb$: 小 B 的长度

- $n,q \le 500$

考虑模拟双方的行动。发现最终双方都会拐进一条副链。考虑什么时候拐进副链必胜。

由于小 A 和小 B 情况类似，下文仅对小 A 进行讨论。

我们认为一个点毕必胜当且仅当他满足以下两个条件：

- $posa-posb>lena$
- $x_{posa} > \max\limits_{i=posa+1}^{posb} posb-i+x_i$

按照式子模拟双方每一步行动，先遇到必胜点则胜利。复杂度 $O(qn^2)$ 。

- $q \le 500, n\le 10^5$

考虑优化刚才的式子。

结论：不满足上面两个条件任一的节点均不是必胜。

证明：

首先明显不满足第二条件的节点不是必胜。考虑不满足第一条件的节点。下文假设小 A 在这个节点上，那么小 B 的状态存在两种情况。

1. 小 B 已经拐进副链

由于刚才的条件我们已经得出，只有当节点已经必胜时小 B 才会拐进副链。因此如果小 B 已经拐进副链，当前节点必败。

2. 小 B 还未拐进副链

此时如果选择拐进副链，小 B 可以朝着小 A 的方向移动（可以理解为跟着屁股走），到最后必然是小 A 先无法行动。故当前节点必败。

综上，不满足任意条件的节点必然不是必胜。

因此，我们可以将不满足节点直接忽略掉。具体来说，对于小 A，我们从 posa+(posb-posa+lena+1)/2 开始寻找必胜点即可。

此时，瓶颈变为第二个式子。

发现对于任何询问，posb 都是一个常数，而 $x_i-i$ 不会改变。故我们可以使用 ST 表预处理 $x_i-i$，模拟询问时直接调用即可。复杂度降为 $O(nq)$

对于小 B，我们没有必要重新推式子。我们可以选择直接将序列倒转，然后用之前对的式子直接做即可。

- 所有 $x_i$ 都相等

易证先拐进副链必然不优，根据蛇之间的距离判断谁先拐进副链即可。

- $\sum lena+lenb < 5 \times 10^7$

数据范围明示我们要一个 $O(\sum lena+lenb)$ 的解法。发现直接从满足第一个条件的节点进行模拟即可。

- $x_i$ 随机生成。

留给乱搞

- $n\le 5000$

考虑预处理。

首先不考虑长度的贡献，发现对于每一对二元组 $(u,v)$，我们都可以 $O(n)$ 处理出他们之间的必胜点集合 $S$。直接枚举二元组进行计算后通过二分找出最近的可用必胜点即可做到 $O(n^3+qlogn)$。

考虑优化。

对于一个二元组 (posa',posb')，如果存在一个点满足 $x_{posa'} > \max\limits_{i=posa'+1}^{posb'} posb'-i+x_i$ 和 $posa'-posa = posb-posb'$，则我们称他为这个二元组的广义必胜点。注意广义必胜点不需要满足 $posa<posa'$ 或 $posb>posb'$。

结论：对于任何 $posa',posb'$, 若 $posa+posb = posa'+posb'$，则他们的广义必胜点集合 $S'$ 都相同。

证明：

若不考虑往回走的情况，两条蛇能够到达的节点集合是相同的，故他们处理出来的集合必然也相同。

因此，我们仅仅需要处理 $S'(1,i) i \in (2,2\times n-1)$ 即可，选择处理 $S'(1,i) i \in (2,n)$ 和 $S'(j,n) j \in (2,n-1)$ 也是一种可行方案。

运用 ST 表即可做到 $O(n)$ 处理单次，复杂度变为 $O(n^2 + qlogn)$ 足以通过。

- 无特殊限制

瓶颈在于必胜点集合的计算，考虑优化。

结论：若一个节点 $k(i\le k \le j)$ 不存在于集合 $S'(i,j)$，则其不可能存在于任何 $S'(i,l) (l>j)$ 的集合之中。

证明:

发现对于式子 $x_{posa} > \max\limits_{i=posa+1}^{posb} posb-i+x_i$，当 $j$ 扩大，原式的 $posb$ 将会扩大。由于左式跟 $posb$ 无关，而右式取的是 $max$，当 $posb$ 扩大时右式单调不降。故结论得证。

对于每个节点 $i$，我们都可以找到一个节点 $R_i$，使得节点 $i$ 在任何 $S'(1,j) (j>R_i)$ 中均不为必胜。

因此，我们可以对询问进行离线，按照 $posa+posb$ 进行排序。使用两个 set 维护双方的必胜点集合。在 $posa+posb = i$ 的时候加入集合，在 $posa+posb=R_i$ 的时候删除即可。

对于枚举询问，我们只需要在双方集合中找出最近的可用必胜点，然后比较一下距离即可。复杂度 $O((n+q)logn)$

考场上有大佬用线段树二分做出来了，膜拜。

---

## 作者：1kri (赞：1)

先下一些简单的定义：
- $posa$ ：小 $A$ 蛇头的位置。
- $lena$ ：小 $A$ 的长度。
- $posb$ ：小 $B$ 蛇头的位置。
- $lenb$ ：小 $B$ 的长度。

---

考虑一种简单的 $O(qn^2)$ 做法：

我们枚举 小 $A$ 和 小 $B$ 的每一步行动，并判断当前移动的蛇是否可以进入“副链”。

一条蛇可以拐进副链，必须满足对方在他之前先无法移动。那么我们以小 $A$ 为例，讨论一下什么时候可以拐进副链（小 $B$ 可以同理得出）：

1. 小 $A$ 不能被 小 $B$ “碾压”，也就是不能使小 $B$ 走到和小 $A$ 一样的副链。分析一下，就是他们之间的距离严格小于小 $A$ 的长度。

$$posb-posa < lena$$

2. 小 $B$ 在小 $A$ “右边”，无论怎么走都会先无法移动。

$$x_{posa}>\max_{i=posa+1}^{posb} posb-i+x_i$$

显然，满足这两个条件，小 $A$ 拐进副链后就可以获胜了。

---

考虑简单的优化。

上一个算法时间复杂度瓶颈是枚举 $\max_{i=posa+1}^{posb} posb-i+x_i$ 。

我们可以直接用 $ST$ 表维护 $\max_{i=l}^{r} x_i-i$ ，然后就可以 $O(1)$ 得到上面这个式子的答案了。

然后就 $O(qn)$ 了。

---

考虑 $n$ 很小时怎么做。

我们将满足 $x_{posa'}>\max_{i=posa'+1}^{posb'} posb'-i+x_i$ 的 $posa'$ 称为“必胜点”（$posa',posb'$ 表示某一轮到 小 $A$ 移动的时刻，小 $A$ 和 小 $B$ 蛇头的位置。显然 $posa'-posa=posb-posb'\geq 0$），记为 $c$ 。

对于每一对 $(posa,posb)$ ，我们可以得到所有必胜点的集合，记为 $S_{(posa,posb)}$ 。

那么对于所有的 $(posa,posb)$ ，可以 $O(n)$ 算出它的必胜点集合。

询问时我们可以通过刚才算出的 $posa$ 的范围，在 $S_{(posa,posb)}$找到 小 $A$ 最近的“可用必胜点”。同理，我们也可以找到小 $B$ 最近的“可用必胜点”。然后比较一下这两条蛇谁先到达“可用必胜点”，就可以了。

注意特判没有必胜点的情况。

时间复杂度：$O(n^3+q\log n)$ 

---

奇怪的优化。

定义“广义必胜点”为满足 $x_{posa'}>\max_{i=posa'+1}^{posb'} posb'-i+x_i$ 的 $posa'$ 。在这里，我们仍需满足 $posa'-posa=posb-posb'$，但无需满足 $posa'-posa\geq0$ 。

对于每一对 $(posa,posb)$ ，我们可以得到所有“广义必胜点”的集合，记为 $S'_{(posa,posb)}$ 。

我们会发现一个很神奇的现象：对于所有 $posa+posb$ 相等的 $(posa,posb)$ ，$S'_{(posa,posb)}$ 都相同！

为什么呢？因为显然，对于和相同的 $(posa,posb)$ ，它们能到达的 $(posa',posb')$ 是一样的。因为根据定义，$posa'-posa=posb-posb'$ ，那么 $posa'+posb'=posa+posb$ 。所以这个结论成立。

因此，我们只需求出所有 $S'_{(1,i)}$ 就可以了。

那么时间复杂度为 $O(n^2+q\log n)$ 。

---

考虑优化求出所有 $S'_{(1,i)}$ 的过程。

我们可以算出对于每一个点，它可以被包含在哪些 $S'_{(1,i)}$ 中。

一个显然的单调性，随着 $i$ 的增大，这个点作为“广义必胜点”的“优势”会减小。

可以这样理解：有局面 $(1,i)$ ，其中 $c$ 是“广义必胜点”。然后随着 $i$ 的增大，可以认为小 $B$ 的位置右移了。在这种情况下，无论何时，小 $A$ 的优势都会减小。因此这是对的。

那么算法就很显然了：
- 对于每个点 $i$ ，它可以作为 $S'_{1,i} \sim S'_{1,R_i}$ 的广义必胜点。我们二分求出每个 $R_i$ 。
- 然后我们把询问按 $posa+posb$ 离线下来，从小到大扫描 $i$ ，更新 $S'_{1,i}$ 。具体如何更新呢？先维护一个 $set$ ，然后使用类似差分的方法，在 $i=j$ 时，把 $j$ 插入。在 $i=R_j$ 时，把 $j$ 删除。
- 对于每组询问，找出小 $A$ 的最近可用必胜点。
- 同理找出小 $B$ 的最近可用必胜点，比较谁先到达。特判没有必胜点的情况。

时间复杂度：$O((n+q)\log n)$

---


# 「EZEC-8」猜树 加强版

## 题目背景

这是一道交互题。

## 题目描述

有一棵以 $1$ 为根的 $n$ 个点的有根树，您需要通过若干次询问得到这棵树的结构。

您可以使用两种询问：

1. `? 1 u v` 通过这种询问，您可以获得 $u$ 和 $v$ 之间的距离。
2. `? 2 u` 通过这种询问，您可以获得 $u$ 子树的大小和 $u$ 子树中的所有节点。

请通过使交互库输出不超过 $40000$ 个数，得到这棵树的结构。

### 交互方式

输入树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的两种询问。

对于第一种询问，交互库将会返回一个非负整数，表示 $u$ 节点和 $v$ 节点间的距离。

对于第二种询问，交互库将会先返回一个正整数 $num$，表示 $u$ 子树的大小。接下来会在同一行中返回 $num$ 个正整数，表示 $u$ 子树中的所有节点（节点顺序会被打乱）。

在您确定答案后，请以 `! fa[2] fa[3] ... fa[n]` 的形式输出一行，停止交互。其中 $fa[i]$ 表示这棵树中 $i$ 号节点的父节点。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

对于 $100\%$ 的数据：$2 \leq n \leq 5000$，$1\le u,v\le n$。

## 样例 #1

### 输入

```
5

1

5 1 5 2 4 3

3 4 2 5

1 3```

### 输出

```

? 1 1 2

? 2 1

? 2 2

? 2 3

! 1 1 2 2```

# 题解

## 作者：Legitimity (赞：24)

~~如果你直接把 P7595 的代码往这里一粘，你就可以获得 $30-50$ pts 的优秀分数~~


------------
此做法来自月赛讲评。

看这题的数据，显然是需要一个 $O(n\log n)$ 的做法。

考虑一个 simple idea：如果 $dep_u=dep_v+1$ 且 $u$ 在 $v$ 的子树中，那么 $f_u=v$。

那么就有一个显然的做法：$n$ 次询问把 $dep$ 搞出来，然后从根节点向下递归处理每个节点，对于每个节点询问一次子树，这样做询问的量级在 $O(n^2)$ 左右（连弱化版都过不了）。

如何改进？对于 $v$ 节点，确定一个儿子 $u$。知道了 $v$ 节点的子树，又知道了 $v$ 其它儿子的子树，两者相减就可以得到 $u$ 的子树。这样做，每次可以省去一个儿子的子树的询问。

那么 $u$ 应该选哪个呢？显然应该选重儿子，在考虑树剖和 dsu on tree 里的推论，可以得到 $\sum siz_i-siz_{u_i}$ 的量级在 $O(n\log n)$（证明可以去看 oiwiki），完全二叉树时达到下界。那么如果能够知道每个节点的重儿子，那么就可以在 $O(n\log n)$ 内解决这个问题。

如何在一颗结构不明的树里找到每个节点的重儿子？~~随机的艺术。~~

我们随机一些点，根据定义，重儿子的子树最大，那么应该占随机出的点就应该更多。那么我们就把占随机点最多的儿子当成重儿子。

那么应该随机几个呢？通过实验发现，随机 $1$ 个表现十分优秀。

为什么？~~随机的艺术。~~

复杂度的退化主要来自与处理时把重儿子和轻儿子颠倒了，如果出题人想卡这样的做法，就必须将重儿子搞得尽量重，但随即 $\sum siz_i-siz_{u_i}$ 也会更小，所以实际表现也十分优秀。

代码：（$son$ 表示重儿子，$siz$ 表示子树大小，$sontree$ 表示子树）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define inf 0x3f3f3f3f
#define ll long long
inline int read(){
	rg int ret=0,f=0;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getchar();}
    return f?-ret:ret;
}
int n,u,dep[5005],siz[5005],sontree[5005][5005],son[5005]; 
int fa[5005];
bool vis[5005];
void dfs(int x){
	if(!siz[x]) return;
	int tmp=sontree[x][rand()%siz[x]+1],cnt=0;
	random_shuffle(sontree[x]+1,sontree[x]+siz[x]+1);
	for(rg int i=1;i<=siz[x];++i){
		if(dep[sontree[x][i]]!=dep[x]+1) continue;
		if(tmp==sontree[x][i]) u=0;
		else printf("? 1 %d %d\n",sontree[x][i],tmp),fflush(stdout),u=read();
		if(u==dep[tmp]-dep[sontree[x][i]]){
			son[x]=sontree[x][i];
			break;
		}
	}//找到重儿子。 
	memset(vis,0,sizeof(vis));
	for(rg int i=1;i<=siz[x];++i){
		if(dep[sontree[x][i]]==dep[x]+1&&sontree[x][i]!=son[x]){
			printf("? 2 %d\n",sontree[x][i]); fflush(stdout);
			siz[sontree[x][i]]=read()-1;
			int cntnow=0;
			for(rg int j=1;j<=siz[sontree[x][i]]+1;++j){
				u=read(); vis[u]=1;
				if(u!=sontree[x][i]) sontree[sontree[x][i]][++cntnow]=u;
			}
		}
	}//询问轻儿子的子树 
	for(rg int i=1;i<=siz[x];++i){
		if(!vis[sontree[x][i]]&&sontree[x][i]!=son[x]) 
			sontree[son[x]][++siz[son[x]]]=sontree[x][i];
	}//根据轻儿子的子树推出重儿子的子树。 
	for(rg int i=1;i<=siz[x];++i){
		if(dep[sontree[x][i]]==dep[x]+1){
			fa[sontree[x][i]]=x;
			dfs(sontree[x][i]);
		}
	}//递归处理。 
}
signed main(){
	n=read(); 
	for(rg int i=2;i<=n;++i){
		printf("? 1 1 %d\n",i); fflush(stdout);
		dep[i]=read(); sontree[1][++siz[1]]=i;
	} //处理深度。 
	dfs(1);
	printf("! ");
	for(rg int i=2;i<=n;++i) printf("%d ",fa[i]);
	puts("");
	fflush(stdout);
	return 0;
}
```



---

## 作者：Purslane (赞：4)

# Solution

首先，我们可以用 $n-1$ 次操作 $1$ 确定每个点的深度。这样的好处是，我们进行第二次操作的时候，就可以从这么多子孙里面看出哪些是当前节点的儿子。

考虑我们要确定这个点所有儿子的新的子孙。一个 Trival 的想法是全部用操作 $2$ 再来一遍。但是这样会被链的情形卡成 $O(n^2)$ 次输出。

考虑事实上新的子孙的情况是原来子孙情况的**一个划分**。所以我们确定了很多个儿子的子孙情况，而剩下一个就可以不用查询就直接得到结果。也就是我们能省掉很多的询问。

那显然是有限省掉重儿子啊。但是我们比不知道子树的大小，输。

那就交给概率，随便在这么多儿子里面随一个点。如果目前整个子树的大小为 $n$，随机出来的点在新子树大小为 $s$ 的子树内出现的概率是 $\dfrac{s}{n}$。于是你期望能省掉 $\sum \dfrac{s^2}{n}$ 次询问，其中 $\sum s = n$。

于是在最劣情况下，你的期望询问次数有：

$$T(n) = \max_{\sum s = n} \{n - \sum \dfrac{s^2}{n} + \sum T(s)\}$$

可以证明，$T(n) = O(n \log n)$。

下面是我边想边写半个小时整出来的证明。

Warning：限于本人低劣的数学水平，下文**可能**存在错误。下文出现了大量的近似，因为我们只是研究一个渐进复杂度，没有必要算出具体数值（更何况这是基于随机数的期望的。）

使用数学归纳法。假设我们在计算 $T(n)$ 的时候，已知所有的 $T(m) = m \ln m$，$m < n$。

> 为啥用 $\ln$？

> 因为后面求导好算。

构造 $f(m) = \dfrac{-m^2}{n} + m \ln m$。其一阶导函数为 $f'(m) = \dfrac{-2m}{n} + \ln m + 1$。二阶导函数为 $f''(m) = \dfrac{-2}{n} + \dfrac{1}{m}$。

我们发现，导函数的拐点为 $\dfrac{n}{2}$。而且考虑几个子树的大小中，不可能有多个大于 $\dfrac{n}{2}$ 的。先研究当 $\sum s_i = k$ 为定值且 $s_i \le \dfrac{n}{2}$ 的情况。根据 [优超不等式](https://baike.baidu.com/item/%E5%8D%A1%E6%8B%89%E7%8E%9B%E7%89%B9%E4%B8%8D%E7%AD%89%E5%BC%8F/5711320)，我们知道，必定要让大的尽可能大，小的尽可能小。于是我们知道，当 $k \le \dfrac{n}{2}$ 时，当 $s_1 = k$ 其他为 $0$ 的时候和最大。当 $k \ge \dfrac{n}{2}$ 时，当 $s_1 = \dfrac{n}{2}$ 且 $s_2 = k - \dfrac{n}{2}$ 且其他为 $0$ 的时候和最大。

考虑如果有一个 $s_1 \ge \dfrac{n}{2}$ 的存在，那么必定可以把其他的调整为 $s_2 = n-s_1$，其他为 $0$。然后再考虑两个积分：$\int_{\frac{n}{2}-v}^{\frac{n}{2}} (\dfrac{-2}{n} + \dfrac{1}{m}) \text{d} m$ 和 $\int_{\frac{n}{2}}^{\frac{n}{2}+v} (\dfrac{-2}{n} + \dfrac{1}{m}) \text{d} m$

很容易发现，前者严格大于后者。也就是说，$f(\dfrac{n}{2}) - f(n-s_1) \ge f(s_1) - f(\dfrac{n}{2})$。这么说来，我们把 $s_1$ 和 $n-s_1$ 调整成两个 $\dfrac{n}{2}$ 会更大。

因此我们就简化为：

$$T(n) = \dfrac{1}{2} n + 2T(\frac{n}{2})$$

根据主定理，$T(n) = O(n \log n)$。

也许，是对的？

还是放一下代码吧。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5000+10;
int n,dep[MAXN],fa[MAXN],flg[MAXN];
vector<int> son[MAXN];
int query_dis(int u,int v) {
	cout<<"? "<<1<<' '<<u<<' '<<v<<endl;
	int ans; cin>>ans;
	return ans;	
}
vector<int> query_sons(int u) {
	cout<<"? "<<2<<' '<<u<<endl;
	vector<int> S; int cnt;
	cin>>cnt;
	ffor(i,1,cnt) {
		int id; cin>>id;
		if(id!=u) S.push_back(id);	
	}
	return S;
}
mt19937 myrand(time(0));
void solve(int u) {
	if(!son[u].size()) return ;
	vector<int> dson;
	for(auto id:son[u]) if(dep[id]==dep[u]+1) dson.push_back(id),fa[id]=u;
	int rnd=son[u][myrand()%son[u].size()],hson=-1;
	for(auto id:dson) if(rnd==id||(query_dis(rnd,id)==dep[rnd]-dep[id])) hson=id;
	memset(flg,0,sizeof(flg));
	for(auto id:dson) {
		if(id==hson) continue ;
		son[id]=query_sons(id);
		for(auto Id:son[id]) flg[Id]=1;
	}
	for(auto id:son[u]) if(dep[id]!=dep[u]+1&&!flg[id]) son[hson].push_back(id);
	son[u].clear();
	for(auto id:dson) solve(id);
	return ;
}
int main() {
	cin>>n;
	ffor(i,2,n) dep[i]=query_dis(1,i),son[1].push_back(i);
	solve(1);
	cout<<"! ";
	ffor(i,2,n) cout<<fa[i]<<' ';
	cout<<endl;
	return 0;
}
```

---

## 作者：wmy_goes_to_thu (赞：2)

先估计一下，$5000 \times 8=40000$，大概是个 $\texttt{log}$ 级别的东西。

首先有一个暴力的做法，求出每个点的子树然后 dfs，会被链卡成平方。但是注意到，有一个子树不需要询问，减一下就行，所以看看能不能均摊优化。显然，选出子树大小最大的那个不询问子树是最优的，也就是找到一个接近重儿子的点最好。随机在子树里选择一个点，然后根据深度一一询问，找到它往上的那个重儿子就行了。均摊一下，是 $O(n\times logn)$ 的，实际更少（因为树剖），故可通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dep[5005],fa[5005];
void dfs(int x,vector<int>v)
{
	int sz=v.size(),d=-1,kk=-1;
	if(sz==1)return;
	for(int i=0;i<sz;i++)swap(v[rand()%sz],v[rand()%sz]);
	for(int i=0;i<sz;i++)if(dep[v[i]]>dep[x])d=v[i];
	sort(v.begin(),v.end());
	vector<int>vist;
	vist.clear();
	for(int i=0;i<sz;i++)vist.push_back(0);
	for(int i=0;i<sz;i++)if(v[i]==x)vist[i]=1;
	for(int i=0;i<sz;i++)
	{
		if(dep[v[i]]==dep[x]+1)fa[v[i]]=x;
		else continue;
		if(kk==-1)
		{
			cout<<"? 1 "<<v[i]<<" "<<d<<endl;
			int qq;
			cin>>qq;
			if(dep[d]-dep[v[i]]==qq)kk=v[i];
		}
		if(v[i]==kk)continue;
		vector<int>g;
		g.clear();
		cout<<"? 2 "<<v[i]<<endl;
		int ll;
		cin>>ll;
		for(int j=1;j<=ll;j++)
		{
			int p;
			cin>>p;
			g.push_back(p);
			vist[lower_bound(v.begin(),v.end(),p)-v.begin()]=1;
		}
		dfs(v[i],g);
	}
	vector<int>g;
	g.clear();
	for(int i=0;i<sz;i++)if(!vist[i])g.push_back(v[i]);
	dfs(kk,g);
}
int main()
{
	int n;
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		cout<<"? 1 1 "<<i<<endl;
		cin>>dep[i];
	}
	vector<int>v;
	v.clear();
	for(int i=2;i<=n;i++)v.push_back(i);
	dfs(1,v);
	cout<<"! ";
	for(int i=2;i<n;i++)cout<<fa[i]<<" ";
	cout<<fa[n]<<endl;
	return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：1)

似乎比大家的解法麻烦一些，但是是本质相同的。

### Solution

首先求出所有点的深度。

我们考虑拎出一个叶子，然后问所有点到它的距离。这样我们就知道这个叶子到根上的所有点，以及把叶子到根这条路径删掉后分裂形成的子树，然后可以递归算。

然后你发现它会被菊花卡到 $O(n^2)$。

我们考虑套用 dsu on tree 那套理论，先算轻儿子，然后你就知道重儿子子树的点集了。但是我们不知道重儿子咋办？？？

~~经过实验发现~~ 交互库不自适应，我们可以随机一个儿子当作重儿子执行上述过程。实际表现十分优秀，可以通过。

不太会证明这个东西的复杂度，不过好像卡不掉。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=5005;
mt19937 gen(chrono::steady_clock::now().time_since_epoch().count());
int n,dep[N],dis[N],fa[N];
bool vis[N][N];
vector<int> vec;
void solve(int rt,vector<int> &vec){
	if(vec.size()==1)return;
	int maxd=0;
	vector<int> leaf;
	for(auto &o:vec)
		maxd=max(maxd,dep[o]);
	for(auto &o:vec)
		if(dep[o]==maxd)
			leaf.emplace_back(o);
	uniform_int_distribution<> rnd(0,(int)leaf.size()-1);
	int p=leaf[rnd(gen)];
	vector<int> path(maxd+1);
	vector<vector<int> > son(maxd),all(maxd);
	for(auto &o:vec){
		cout<<"? 1 "<<p<<' '<<o<<endl;
		cin>>dis[o];
		if(dis[o]+dep[o]==dep[p])
			path[dep[o]-dep[rt]]=o;
	}
	for(int i=1;i<=maxd;i++)
		fa[path[i]]=path[i-1];
	for(auto &o:vec){
		if(dis[o]+dep[o]==dep[p]+2)
			son[dep[o]-dep[rt]-1].emplace_back(o),fa[o]=path[dep[o]-dep[rt]-1];
		if(dis[o]+dep[o]!=dep[p])
			all[dep[o]-dep[rt]-((dis[o]+dep[o]-dep[p])>>1)].emplace_back(o);
	}
	vector<int> tr;
	for(int i=0;i<maxd;i++){
		if(!son[i].size())continue;
		shuffle(son[i].begin(),son[i].end(),gen);
		for(int j=1;j<(int)son[i].size();j++){
			cout<<"? 2 "<<son[i][j]<<endl;
			int siz;cin>>siz;
			tr.resize(siz);
			for(int k=0;k<siz;k++)
				cin>>tr[k],vis[rt][tr[k]]=1;
			solve(son[i][j],tr);
		}
		tr.clear();
		for(auto &o:all[i])
			if(!vis[rt][o])
				tr.emplace_back(o);
		solve(son[i][0],tr);
	}
}
int main(){
//	ios::sync_with_stdio(false);
//	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cout<<"? 1 "<<1<<' '<<i<<endl;
		cin>>dep[i];
	}
	for(int i=1;i<=n;i++)vec.emplace_back(i);
	solve(1,vec);
	cout<<"! ";
	for(int i=2;i<=n;i++)cout<<fa[i]<<' ';
	cout<<endl;
	return 0;
}
```

---

## 作者：ZhongYuLin (赞：0)

~~被随机化吓晕~~。

题目的询问提醒我们，要依据子树大小进行处理。经常写树剖的朋友都知道，只对重儿子进行一次遍历可以做到优秀的 $O(n\log{n})$，可以通过。

具体地，假设我们有一个询问，使得我们可以找出重儿子（例如存在一个询问，让我们能够**只**知道子树的大小）。我们将这个重儿子找出，对其余轻儿子进行询问 $2$，再用总子树减去轻儿子的子树，得到重儿子的子树，递归处理即可。

但是，我们并没有这样一个操作。~~然后我点开题解，发现可以随机化~~。然后就可以通过了。具体地，每次随机子树中的一个点，判断它在哪一个儿子的子树。发现随机一次时才能通过。

至于证明，有空再补上。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+3,K=1;
int dis[N],fa[N];
int n;
mt19937_64 rnd(random_device{}());
int rd(int l,int r){return rnd()%(r-l+1)+l;}
void ask1(int u,int v){printf("? 1 %d %d\n",u,v);fflush(stdout);}
void ask2(int u){printf("? 2 %d\n",u);fflush(stdout);}
void dfs(int x,vector<int>&son){
    if(son.empty())return;
    int sz=son.size();
    vector<int>nxt;
    for(int y:son)
        if(dis[y]==dis[x]+1)
            nxt.push_back(y),fa[y]=x;
    int len=nxt.size(),ans=0,id=-1;
    vector<int>cnt(len);
    for(int T=K;T--;){
        int k=son[rd(0,sz-1)];
        for(int i=0;i<len;++i){
            ask1(nxt[i],k);
            int at;cin>>at;
            if(at<dis[nxt[i]]+dis[k]-2*dis[x]||!at){
                ++cnt[i];
                if(cnt[i]>ans)id=i,ans=cnt[i];
                break;
            }
        }
    }
    map<int,bool>vis;
    for(int i=0;i<len;++i)if(i!=id){
        vector<int>sub;
        ask2(nxt[i]);
        int sz,k;cin>>sz;
        for(;sz--;){
            cin>>k;vis[k]=1;
            if(k!=nxt[i])sub.push_back(k);
        }
        dfs(nxt[i],sub);
    }
    vector<int>sub;
    for(int k:son)
        if(!vis.count(k)&&k!=nxt[id])
            sub.push_back(k);
    dfs(nxt[id],sub);
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;vector<int>s;
    for(int i=2;i<=n;++i)
        ask1(1,i),cin>>dis[i],s.push_back(i);
    dfs(1,s);
    printf("! ");
    for(int i=2;i<=n;++i)
        printf("%d ",fa[i]);
    puts("");fflush(stdout);
    return 0;
}
```

---


# [COCI 2012/2013 #5] MNOGOMET

## 题目描述

人们正在踢足球，分成两个队。每个球员都穿着队服，上面印着一个在队中独一无二的 $1$ 到 $N$ 间正整数，包括 $1$ 和 $N$。

对于每个玩家，我们知道他的精准度，知道他能把球传给的队友（集合 $F$ ），也知道能抢断他的对手（集合 $E$ ）。

当一名球员恰好接得一球之后的一秒后有以下情况中的一种会发生:

- 球员将球传给随机一名队友

- 随机一位对手将球夺过

- 球员试图向球门射门

如果球员试图射门，得分的概率等于他的精准度。无论射门成功与否，将球判给对方的 $1$ 号球员。

不同事件的可能性为比例 $|F|:|E|:1$，仅依赖于当前持球的玩家（ $|S|$ 代表集合 $S$ 的大小）。

“随机”一词指的是集合 $F$（或 $E$ ）中的所有玩家均有相同的概率从目前持球的球员那里拿到传的球。

不需计算传球的时间。

比赛以队伍一的球员 $1$ 控球开始，当一个球队进了 $R$ 个球，或者 $T$ 秒过去了，比赛结束（以两者中先发生的时间为准）。对于每一个可能的进球，计算出比赛以它结束的概率。

## 说明/提示

**【样例解释#1】**

比赛只持续 $2$ 次移动或直到某人得分。由于 $N=1$，比赛中只有两名选手，两个选手的射门精确度都是 $0.5$，也就是说每个人的精确度都是 $50\%$。

让我们将灰色玩家标记为 $A$，将白色玩家标记为 $B$。在这些假设下，只有 $6$ 个可能的情况。下表分别描述了这些情况和对应的概率：

| 概率 | 描述 | 比分 |
| :----------: | :----------: | :----------: |
| $0.25$ | $A$ 射门并得分 | $1:0$ |
| $0.25\times 0.25$ | $A$ 射门但未得分，$B$ 射门并得分 | $0:1$ |
| $0.25\times 0.25$ | $A$ 射门但未得分，$B$ 射门但并未得分 | $0:0$ |
| $0.50\times 0.25$ | 球被 $B$ 从 $A$ 那里抢走，$B$ 射门并得分 | $0:1$ |
| $0.50\times 0.50$ | 球被 $B$ 从 $A$ 那里抢走，球被 $A$ 从 $B$ 那里抢走 | $0:0$ |
| $0.50\times 0.25$ | 球被 $B$ 从 $A$ 那里抢走，$B$ 射门但并未得分 | $0:1$ |

通过把这些概率加在一起，我们可以得到答案：

| 比分 | 概率相加 | 总和 |
| :----------: | :----------: | :----------: |
| $0:0$ | $0.25 \times 0.25 + 0.5 \times 0.5 + 0.5 \times 0.25$ | $0.5625$ |
| $0:1$ | $0.25 \times 0.25 + 0.5 \times 0.25$ | $0.1875$ |
| $1:0$ | $0.25$ | $0.25$ |



**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 100$，$1\le R\le 10$，$1\le T\le 500$，$0\le p\le 1$，$0\le N_f\le N-1$，$0\le N_e\le N$。


------------

**【说明】**

本题 spj 用于判断答案精确度。

本题分值按 COCI 原题设置，满分 $160$。

题目译自 [COCI2012_2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #5](https://hsin.hr/coci/archive/2012_2013/contest5_tasks.pdf) _**T6 MNOGOMET**_。

## 样例 #1

### 输入

```
1 1 2
0.5 0 1 1
0.5 0 1 1```

### 输出

```
0.56250
0.18750
0.25000```

## 样例 #2

### 输入

```
2 2 5
0.0 1 2 2 1 2
1.0 0 0
0.5 1 0 2
0.5 1 0 1```

### 输出

```
0.2578125
0.2812500
0.0703125
0.1718750
0.1640625
0.0234375
0.0156250
0.0156250```

# 题解

## 作者：Kelvin2009 (赞：2)

这是一道期望 dp 加状态优化。

枚举此时球在哪个队员手上且双方的得分情况显然不行，时间复杂度危险。

注意到进球情况并不主要依赖于时间的推移，考虑设定新的状态 $dp_{i,a,b,id}$ 表示在时刻 $i$，0 队得 $a$ 分，1 队得 $b$ 分，某队恰好刚进球，此时球权将交给 $id$ 队 1 号队员。

对于 $id$ 队的队员 $m$，默认其在球场上的编号为 $id\cdotp n+m$。

考虑如何转移，首先要维护 3 种概率：

1. $hold_{id,con,j}$ 表示从 $id$ 队开始，传了 $con$ 次，中途没有进球，传到了球员 $j$ 手上的概率（不管是主观传还是被抢，只看作一种可能得状态）。

2. $goal_{a,b,con}$ 表示从 $a$ 队发球，传了 $con$ 次后由 $b$ 队第一次进球的概率。

3. $sum_{a,con}$ 表示从 $a$ 队发球，传了不超过 $con$ 次新进了球的概率。

其中，$hold_{id,con,j}$ 与 $goal_{a,b,con}$ 可以通过刷表求得，而 $sum_{a,con}$ 则是 $goal_{a,b,con}$ 的前缀和。

即：
$$sum_{a,con}=goal_{a,a,0}+\displaystyle\sum_{i=1}^{con}(goal_{a,0,i}+goal_{a,1,i})$$ 

然后 $dp_{i,a,b,id}$ 就可通过刷表求得。

若最终 0 队得 $a$ 分，1 队得 $b$ 分，令该方案数为 $ans_{a,b}$。

具体的：
$$ans_{a,b}=\displaystyle\sum_{i=0}^{T}\displaystyle\sum_{id=0}^{1}(1-sum_{id,T-i})\cdot dp_{i,a,b,id}$$ 



---

代码：


---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int rrange=15;
const int vrange=205;
const int trange=505;
const int erange=4e4+5;

int n,r,t;

//ho[a][i][j]:P（a队开球，转i次后球未进，在j号球员手上）
//go[a][b][i]:P（a队开球，第一次进球为转i次后b队进)
//sum[a][i]:P（a队开球，转不超过i次后进一球）
//dp[i][a][b][j]:P（球经过i次进球，比分为a（0队）:b（1队）,球在j队1号手上）
//ans[a][b]:P（最终比分为a（0队）:b（1队））

double p[vrange],val[vrange];

double ho[2][trange][vrange];
double go[2][2][trange],sum[2][trange];
double dp[trange][rrange][rrange][2],ans[rrange][rrange];

int cnt=1,to[erange],nxt[erange],head[vrange];

inline void add(int u,int v)
{
	cnt++;
	nxt[cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt;
}

int main()
{
	scanf("%d%d%d",&n,&r,&t);
	for(int id=0;id<2;id++)
	{
		for(int m=1;m<=n;m++)
		{
			int nf,ne,v;
			int u=id*n+m;
			scanf("%lf%d%d",&p[u],&nf,&ne);
			for(int i=1;i<=nf;i++)
			{
				scanf("%d",&v);
				v=id*n+v;add(u,v);
			}
			for(int i=1;i<=ne;i++)
			{
				scanf("%d",&v);
				v=(1-id)*n+v;add(u,v);
			}
			val[u]=1.0/(nf+ne+1);
		}
	}
	for(int id=0;id<2;id++)
	{
		int beg=id*n+1;
		ho[id][0][beg]=1.0;
		int tran=t-id;
		for(int con=0;con<=tran;con++)
		{
			int ran=2*n;
			for(int u=1;u<=ran;u++)
			{
				if(ho[id][con][u]==0.0) continue;
				for(int i=head[u];i;i=nxt[i])
				{
					int v=to[i];
					ho[id][con+1][v]+=ho[id][con][u]*val[u];
				}
				ho[id][con+1][(u<=n)*n+1]+=ho[id][con][u]*val[u]*(1-p[u]);
				go[id][(u>n)][con+1]+=ho[id][con][u]*val[u]*p[u];
			}
		}
		sum[id][0]=go[id][id][0];
		for(int con=1;con<=tran;con++)
		{
			sum[id][con]=go[id][0][con]+go[id][1][con];
			sum[id][con]+=sum[id][con-1];
		}
	}
	dp[0][0][0][0]=1.0;
	for(int con=0;con<=t;con++)
	{
		for(int a=0;a<=r;a++)
		{
			for(int b=0;b<=r;b++)
			{
				for(int id=0;id<2;id++)
				{
					if(dp[con][a][b][id]==0.0) continue;
					if(a==r || b==r || con==t)
					{
						ans[a][b]+=dp[con][a][b][id];
						continue;
					}
					int ran=t-con;
					for(int res=1;res<=ran;res++)
					{
						dp[con+res][a+1][b][1]+=dp[con][a][b][id]*go[id][0][res];
						dp[con+res][a][b+1][0]+=dp[con][a][b][id]*go[id][1][res];
					}
					ans[a][b]+=dp[con][a][b][id]*(1.0-sum[id][t-con]);
				}
			}
		}
	}
	int ran=r*(r+2);
	for(int i=0;i<ran;i++) printf("%.7lf\n",ans[i/(r+1)][i%(r+1)]);
	return 0;
}
```

---

## 作者：Add_Catalyst (赞：2)

# P7648 [COCI2012-2013#5] MNOGOMET 题解

---

## 知识点

概率 DP，状态割裂动态规划。

---

## 分析

### 暴力

首先，我们可以将两个队伍转换为一张图，得到一个暴力状态：$f_{t,ra,rb,i}$ 在第 $t$ 秒比分为 $ra:rb$ 时，球在第 $i,i\in[1,2n]$ 号点上的概率。

边界条件：$f_{0,0,0,1}=1$。

那么方程就是：

1. 对于 $v \ne 1 \land v \ne n+1$：
   $$
   f_{t+1,ra,rb,v} = \sum_{(u,v) \in G} \frac{f_{t,ra,rb,u}}{N_{f_u} + N_{e_u} + 1}
   $$

2. 对于 $v = 1$：
   $$
   f_{t+1,ra,rb,v} = 
   \sum_{(u,v) \in G} \frac{f_{t,ra,rb,u}}{N_{f_u} + N_{e_u} + 1}
   + \sum_{(u,v) \in G \land u\in[n+1,2n]} 
   \frac{(1-p_u)f_{t,ra,rb,u}+p_uf_{t,ra,rb-1,u}}{N_{f_u} + N_{e_u} + 1} \\
   $$

3. 对于 $v = n + 1$：
   $$
   f_{t+1,ra,rb,v} = 
   \sum_{(u,v) \in G} \frac{f_{t,ra,rb,u}}{N_{f_u} + N_{e_u} + 1}
   + \sum_{(u,v) \in G \land u\in[1,n]} 
   \frac{(1-p_u)f_{t,ra,rb,u}+p_uf_{t,ra,rb-1,u}}{N_{f_u} + N_{e_u} + 1} \\
   $$

最后简单统计一下答案，可以在洛谷得到[130分](https://www.luogu.com.cn/record/173817875)的低分。

### 正解

正解需要我们转换状态，它没法直接化简（至少我不会），所以我们要用到**状态割裂**。用这类技巧的 DP 题比较稀有，需要好好珍惜，这也是我写这篇题解来总结这道题的原因。

我们发现一个问题：好像在 DP 过程中，开球是 $1$ 号队员，射门后收球的也是 $1$ 号队员，其他的队员好像都很闲，我们是不是可以直接把两个队伍缩成两个 $1$ 号队员，然后把除射门之外的过程另外预处理（毕竟它们都是重复的），最后再处理比分的变化？

答案是当然可以。

我们设 $h_{0/1,t,i}$ 表示一开始球在 0/1 号队伍的 $1$ 号球员手中，$t$ 秒后到 $i$ 号球员手中的概率。
$$
h_{0,0,1} = h_{1,0,n+1} = 1 \\
h_{team,t,v} = \sum_{(u,v) \in G} h_{team,t-1,u} \\
$$
现在我们处理了传球的部分，我们需要再开两个数组把他们缩成两个点以过度到比分的部分：

设 ${win/lose}_{0/1,0/1,i}$ 分别表示一开始球在 0/1 号队伍的 $1$ 号球员，$t$ 秒后 0/1 号队伍的球员射门进球、不进球的概率，那么就可以统计一下：
$$
\begin{aligned}
win_{team,0,t} & = \sum_{u=1}^n \frac{p_u h_{team,t-1,u}}{N_{f_u} + N_{e_u} + 1} \\
win_{team,1,t} & = \sum_{u=n+1}^{2n} \frac{p_u h_{team,t-1,u}}{N_{f_u} + N_{e_u} + 1} \\
lose_{team,0,t} & = \sum_{u=1}^n \frac{(1-p_u) h_{team,t-1,u}}{N_{f_u} + N_{e_u} + 1} \\
lose_{team,1,t} & = \sum_{u=n+1}^{2n} \frac{(1-p_u) h_{team,t-1,u}}{N_{f_u} + N_{e_u} + 1} \\
\end{aligned}
$$
那么我们现在可以开始转换了：设 $f_{t,ra,rb,0/1}$ 为在 $t$ 时刻比分为 $ra:rb$ 时，球在 0/1 队伍的 $1$ 号球员手中的概率，方程如下：
$$
f_{0,0,0,0} = 1 \\
f_{t,ra,rb,0} = 
\sum_{t'=0}^{t-1} \sum_{team \in{\{ 0,1 \}}} 
f_{t',ra,rb,team} \cdot lose_{team,1,t-t'} 
+ (f_{t',ra,rb-1,team} \cdot win_{team,1,t-t'} [rb>0]) \\
f_{t,ra,rb,1} = 
\sum_{t'=0}^{t-1} \sum_{team \in{\{ 0,1 \}}} 
f_{t',ra,rb,team} \cdot lose_{team,0,t-t'} 
+ (f_{t',ra-1,rb,team} \cdot win_{team,0,t-t'} [ra>0]) \\
$$
但是转换完了之后我们发现似乎还是不太对劲，因为需要统计答案，那我们来思考一下：一个状态 $f_{t,ra,rb,0/1}$ 对于答案的总贡献分为什么？以便统计，我们可以大致分成以下两类：

1. 射门转移到其他状态 $f_{t',ra',rb',1/0}$ 去的；
2. 再也不射门，比分保持在 $ra:rb$。

那么我们发现，对于一个状态 $f_{t,ra,rb,0/1}$，我们只要计算再也不射门的情况，就可以做到完全统计，因为射门转移走的会有其他状态统计掉。

只要再开一个数组 $none_{0/1,t}$ 表示一开始球在 0/1 号队伍的 $1$ 号球员，后面 $t$ 秒都不再射门的概率，方程如下：
$$
none_{team,t} = \sum_{u=1}^{2n} h_{team,t,u} \\
$$
最后浅浅统计一下答案，本题至此结束。

---

## CODE

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(int)(b);++i)
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;(i);(i)=(g)[(i)].nxt,(y)=(g)[(i)].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=200+10,R=10+10,T=5e2+10;
int n,r,Tim;
int d[N];
double p[N];
double none[2][T],ans[R][R];
double h[2][T][N],win[2][2][T],lose[2][2][T];
double f[T][R][R][2];
struct CFS{
	int tot,h[N];
	struct edge{
		int v,nxt;
		edge(int v=0,int nxt=-1):v(v),nxt(nxt){}
	}e[N*N];
	edge &operator[](int i){
		return e[i];
	}
	void att(int u,int v){
		e[++tot]=edge(v,h[u]),h[u]=tot;
	}
}g;
signed main(){
	cin>>n>>r>>Tim;
	FOR(u,1,n<<1){
		int v,F,E;
		cin>>p[u]>>F>>E,d[u]=F+E+1;
		FOR(j,1,F)cin>>v,g.att(u,v+(u>n?n:0));
		FOR(j,1,E)cin>>v,g.att(u,v+(u<=n?n:0));
	}
	h[0][0][1]=h[1][0][n+1]=1.0;
	FOR(team,0,1)FOR(tim,0,Tim)FOR(u,1,n<<1){
		EDGE(g,i,u,v)h[team][tim+1][v]+=h[team][tim][u]/d[u];
		none[team][tim]+=h[team][tim][u];
		lose[team][u>n][tim+1]+=h[team][tim][u]*(1-p[u])/d[u];
		win[team][u>n][tim+1]+=h[team][tim][u]*p[u]/d[u];
	}
	f[0][0][0][0]=1.0;
	FOR(tim,0,Tim-1){
		FOR(ra,0,r-1)FOR(rb,0,r-1)FOR(team,0,1){
			FOR(i,1,Tim-tim){
				f[tim+i][ra][rb][0]+=f[tim][ra][rb][team]*lose[team][1][i];
				f[tim+i][ra][rb][1]+=f[tim][ra][rb][team]*lose[team][0][i];
				f[tim+i][ra][rb+1][0]+=f[tim][ra][rb][team]*win[team][1][i];
				f[tim+i][ra+1][rb][1]+=f[tim][ra][rb][team]*win[team][0][i];
			}
			ans[ra][rb]+=f[tim][ra][rb][team]*none[team][Tim-tim];
		}
		FOR(i,0,r-1)ans[r][i]+=f[tim][r][i][0]+f[tim][r][i][1],ans[i][r]+=f[tim][i][r][0]+f[tim][i][r][1];
	}
	FOR(ra,0,r)FOR(rb,0,r)if(ra!=r||rb!=r)ans[ra][rb]+=f[Tim][ra][rb][0]+f[Tim][ra][rb][1];
	FOR(ra,0,r)FOR(rb,0,r)if(ra!=r||rb!=r)cout<<fixed<<setprecision(10)<<ans[ra][rb]<<endl;
	return 0;
}
```

---

## 启示

我们在 DP 过程中，如果整体处理不容易求解，我们可以考虑状态割裂，分步解决。就如以上我的推导过程就把整个踢球的过程分成了传球和射门，并把一个队伍缩成了一个点。

---

---

## 作者：DaiRuiChen007 (赞：2)

# 洛谷 P7648 题解

[$\text{Link}$](https://www.luogu.com.cn/problem/P7648)

## 思路分析

设 $dp_{t,x,y,i}$ 表示当前时间 $t$ 秒，比分 $x:y$，球在 $i$ 手中，每次枚举可能性大力转移即可。

时间复杂度 $\Theta(TR^2n^2)$，需要一定的卡常技巧才能通过本题。

提交记录：[TLE on #12](https://www.luogu.com.cn/record/83403436)，[Code Link](https://www.luogu.com.cn/paste/2k421wp7)，常数过大，求大佬帮忙卡常。



显然，刚才的做法复杂度有些问题，因此我们需要对 dp 过程进行优化。

我们发现进球数量和时间不匹配，所以我们可以只考虑每次进球发生的时候，以此来优化转移幅度，以进球为标志，每次转移多个事件。

我们可以预处理出 $i$ 队持球，$t$ 秒之后 $j$ 队进球的概率。

设 $dp_{t,x,y,i}$ 表示 $t$ 秒之后，比分 $x:y$ 且球在 $i$ 队一号手上（对面刚刚进球）。

 枚举下一次进球的时间即可转移。

注意，有可能从某个时刻开始没有进球，此时要直接把 $dp_{t,x,y,i}$ 堆到 $ans[x:y]$ 中。

因此我们需要预处理 $i$ 队持球时 $t$ 秒没有进球的情况，直接用刚刚预处理出的概率累加然后做前缀和即可。

时间复杂度 $\Theta(Tn^2+T^2R^2)$。

## 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=205,MAXT=505;
int siz[MAXN];
vector <int> E[MAXN],F[MAXN];
double p[MAXN];
double hold[MAXT][MAXN];	 // t time i player hold the ball (without any score)
double score[2][2][MAXT]; 	 // team i hold the ball, team j score at moment t
double s[2][MAXT]; 			// team i hold the ball, someone score before moment t
double dp[MAXT][11][11][2];  // time t, score x:y, ball give to team i
double ans[11][11];
signed main() {
	int n,R,T;
	scanf("%d%d%d",&n,&R,&T);
	for(int i=1;i<=n;++i) {
		int e,f;
		scanf("%lf%d%d",&p[i],&e,&f);
		siz[i]=e+f+1;
		while(e--) {
			int x;
			scanf("%d",&x);
			E[i].push_back(x);
		}
		while(f--) {
			int x;
			scanf("%d",&x);
			F[i].push_back(x+n);
		}
	}
	for(int i=n+1;i<=n+n;++i) {
		int e,f;
		scanf("%lf%d%d",&p[i],&e,&f);
		siz[i]=e+f+1;
		while(e--) {
			int x;
			scanf("%d",&x);
			E[i].push_back(x+n);
		}
		while(f--) {
			int x;
			scanf("%d",&x);
			F[i].push_back(x);
		}
	}
	for(int team:{0,1}) {
		memset(hold,0,sizeof(hold));
		if(team) hold[0][n+1]=1;
		else hold[0][1]=1;
		for(int t=0;t<=T;++t) {
			for(int i=1;i<=n;++i) {
				for(int j:E[i]) hold[t+1][j]+=hold[t][i]/siz[i]; 
				for(int j:F[i]) hold[t+1][j]+=hold[t][i]/siz[i]; 
				hold[t+1][n+1]+=hold[t][i]*(1-p[i])/siz[i];
				score[team][0][t+1]+=hold[t][i]*p[i]/siz[i];
			}
			for(int i=n+1;i<=n+n;++i) {
				for(int j:E[i]) hold[t+1][j]+=hold[t][i]/siz[i]; 
				for(int j:F[i]) hold[t+1][j]+=hold[t][i]/siz[i]; 
				hold[t+1][1]+=hold[t][i]*(1-p[i])/siz[i];
				score[team][1][t+1]+=hold[t][i]*p[i]/siz[i];
			}
			s[team][t]=score[team][0][t]+score[team][1][t];
			if(t) s[team][t]+=s[team][t-1];
		}
	}
	dp[0][0][0][0]=1;
	for(int t=0;t<=T;++t) {
		for(int x=0;x<=R;++x) {
			for(int y=0;y<=R;++y) {
				for(int team:{0,1}) {
					if(x==R||y==R||t==T) {
						ans[x][y]+=dp[t][x][y][team];
						continue;
					}
					ans[x][y]+=dp[t][x][y][team]*(1-s[team][T-t]);
					for(int k=1;k+t<=T;++k) {
						dp[k+t][x][y+1][0]+=dp[t][x][y][team]*score[team][1][k];
						dp[k+t][x+1][y][1]+=dp[t][x][y][team]*score[team][0][k];
					}
				}
			}
		}
	}
	for(int x=0;x<=R;++x) {
		for(int y=0;y<=R;++y) {
			if(x==R&&y==R) continue;
			printf("%.10lf\n",ans[x][y]);
		}
	}
	return 0;
}
```

---

## 作者：fydj (赞：1)

# P7648 [COCI2012-2013#5] MNOGOMET

### 题目大意

有两个队，0 号队和 1 号队。每一个队有 1 到 $N$ 号球员。每个球员知道他射门有多大概率射中，他可以传球的队友以及可以抢断他球的对手的集合。当一个球员拿到球后下一秒有可能传球，被抢球，试图射门，概率完全随机。射门得分的概率是该球员的精准度，射门以后球会给到对方的 1 号球员。

一开始由 0 号队 1 号球员持球。当一个队得到 $R$ 分或者比赛过去 $T$ 秒，比赛结束。计算比赛结束后 $R \times (R+2)$ 个得分的出现概率。

### 思路

一开始设 $dp_{t,r1,r2,i}$，表示比赛进行到 $t$ 秒，比分为 $r1:r2$，球在第 $i$ 个球员上的概率。

发现时间复杂度是 $O(TR^2N^2)$，超时了，而且好像不能优化。

换一种设法。设 $dp_{t,r1,r2,0/1}$，表示比赛进行到 $t$ 秒，比分为 $r1:r2$，球在第 $i$ 队的 1 号球员上的概率。再设置几个辅助数组。设 $gw_{0/1,0/1,t}$ 和 $gl_{0/1,0/1,t}$ 表示球一开始在第 0/1 队的 1 号球员手上，经过 $t$ 秒后由 0/1 队的球员射出，得分和不得分的概率分别是多少。发现 $gw$ 和 $gl$ 也不好直接求。就再设 $b_{0/1,t,i}$ 表示球一开始在 0/1 队的 1 号球员手上，经过了 $t$ 秒，球到达了 $i$ 号球员的手上的概率。可以用 $b$ 数组求得 $gw$ 和 $gl$，然后枚举 $dp_{t,r1,r2,0/1}$，枚举下一次进球要花几秒，就可以转移了。

至于最后的答案，只需要考虑每一个  $dp_{t,r1,r2,0/1}$ 时经过 $T-t$ 秒没人进球的概率是多少，累计到答案里，再把 $dp_{t,R,r2,0/1}$ 和 $dp_{t,r1,R,0/1}$ 算上就可以了。

时间复杂度 $O(TR^2N)$。

### 代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define RR 13
#define NN 509
#define TT 509
using namespace std;
typedef long long ll;
char chart; bool fushu;
template <typename T> void read(T &a) { a=fushu=0; do chart=getchar(); while((chart<48||chart>57)&&chart!='-'); if(chart=='-') fushu=1,chart=getchar(); do a=(a<<1)+(a<<3)+(chart^48),chart=getchar(); while(chart>47&&chart<58); if(fushu) a=-a; return ; }
template <typename T,typename ...Args> void read(T &a,Args &...args) { read(a); read(args...); return ; }
int n,r,T,f[NN][NN]={},e[NN][NN]={};
double p[NN]={},fen[NN]={},b[2][TT][NN]={},g[2][TT]={},gw[2][2][TT]={},gl[2][2][TT]={},dp[TT][RR][RR][2]={},ans[RR][RR]={};
int main()
{
//	freopen("soccer.in","r",stdin);
//	freopen("soccer.out","w",stdout);
	int i,j,s,t,pi,r1,r2;
	read(n,r,T);
	for(i=1;i<=2*n;++i) {
		scanf("%lf%d%d",&p[i],&f[i][0],&e[i][0]);
		for(j=1;j<=f[i][0];++j) {
			read(f[i][j]);
			if(i>n)
				f[i][j]+=n;
		}
		for(j=1;j<=e[i][0];++j) {
			read(e[i][j]);
			if(i<=n)
				e[i][j]+=n;
		}
		fen[i]=1.0/(1+f[i][0]+e[i][0]);
	}
	b[0][0][1]=1,b[1][0][n+1]=1;
	for(s=0;s<2;++s)
		for(t=0;t<=T;++t)
			for(pi=1;pi<=2*n;++pi) {
				for(i=1;i<=f[pi][0];++i)
					b[s][t+1][f[pi][i]]+=b[s][t][pi]*fen[pi];
				for(i=1;i<=e[pi][0];++i)
					b[s][t+1][e[pi][i]]+=b[s][t][pi]*fen[pi];
				g[s][t]+=b[s][t][pi];
				gl[s][pi>n][t+1]+=b[s][t][pi]*fen[pi]*(1-p[pi]);
				gw[s][pi>n][t+1]+=b[s][t][pi]*fen[pi]*p[pi];
			}
	dp[0][0][0][0]=1;
	for(t=0;t<T;++t) {
		for(r1=0;r1<r;++r1)
			for(r2=0;r2<r;++r2)
				for(s=0;s<2;++s) {
					for(i=1;t+i<=T;++i)
						dp[t+i][r1][r2][0]+=dp[t][r1][r2][s]*gl[s][1][i],
						dp[t+i][r1][r2][1]+=dp[t][r1][r2][s]*gl[s][0][i],
						dp[t+i][r1][r2+1][0]+=dp[t][r1][r2][s]*gw[s][1][i],
						dp[t+i][r1+1][r2][1]+=dp[t][r1][r2][s]*gw[s][0][i];
					ans[r1][r2]+=dp[t][r1][r2][s]*g[s][T-t];
				}
		for(i=0;i<r;++i)
			ans[r][i]+=dp[t][r][i][0]+dp[t][r][i][1],
			ans[i][r]+=dp[t][i][r][0]+dp[t][i][r][1];
	}
	for(r1=0;r1<=r;++r1)
		for(r2=0;r2<=r;++r2)
			ans[r1][r2]+=dp[T][r1][r2][0]+dp[T][r1][r2][1];
	for(r1=0;r1<=r;++r1)
		for(r2=0;r2<=r;++r2)
			if(r1!=r||r2!=r)
				printf("%.10lf\n",ans[r1][r2]);
}
```

### 后记

复制题解时只复制了代码，后来修正过来了。

---

## 作者：封禁用户 (赞：0)

### Part 1：dp
令 $dp_{i,a,b,j}$ 表示当前时刻 $i$，两队比分为 $a,b$，球在 $j$ 手上的概率。

转移非常简单就不说了，单次转移为 $O(n)$，复杂度为 $O(Tn^2r^2)$。

在优秀卡常+吸氧下跑进 $700ms$。

优化的话: 
1. float；
2. 分小块加速；
3. 循环展开。

#### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize(2)
typedef float db;
#define reg register
#define rep(i,a,b) for(reg int i=a,i##end=b;i<=i##end;++i)
#define drep(i,a,b) for(reg int i=a,i##end=b;i>=i##end;--i)
template <class T> inline void cmin(T &a,const T &b){ ((a>b)&&(a=b)); }
template <class T> inline void cmax(T &a,const T &b){ ((a<b)&&(a=b)); }

char IO;
template <class T=int> T rd(){
	T s=0; int f=0;
	while(!isdigit(IO=getchar())) if(IO=='-') f=1;
	do s=(s<<1)+(s<<3)+(IO^'0');
	while(isdigit(IO=getchar()));
	return f?-s:s;
}

const int INF=1e9+10;
const db eps=1e-12;

int n,R,T;
db dp[510][11][11][210],p[410],sz[410],ans[11][11];
struct Edge{
	int to,nxt;
} e[80000];
int head[410],ecnt;
void AddEdge(int u,int v) {
	e[++ecnt]=(Edge){v,head[u]};
	head[u]=ecnt;
}
int E[410][410],G[410][410]; 
const int D=5;
db tmp[210][1<<D];

int main(){
	n=rd(),R=rd(),T=rd();
	int m=(n*2+D-1)/D;
	rep(i,1,n*2) {
		scanf("%f",&p[i]);
		int e=rd(),f=rd();
		sz[i]=e+f+1;
		rep(j,1,e) {
			int x=rd();
			if(i>n) x+=n;
			E[i][x]=1;
		}
		rep(j,1,f) {
			int x=rd();
			if(i<=n) x+=n;
			E[i][x]=1;
		}
		rep(j,1,m) {
			int f=(j-1)*D+1;
			rep(k,0,D-1) G[i][j]|=E[i][f+k]<<k;
			if(G[i][j]) AddEdge(i,j);
		}
	}
	dp[0][0][0][1]=1;
	for(reg int i=0;i<=T;++i) {
		for(reg int a=0;a<=R;++a) {
			for(reg int b=0;b<=R;++b) {
				for(reg int j=1;j<=n*2;++j) if(dp[i][a][b][j]>eps) {
					if(a==R || b==R || i==T) { ans[a][b]+=dp[i][a][b][j]; continue; }
					db t=dp[i][a][b][j]/sz[j];
					for(reg int k=1;k<=m;k+=4) {
						tmp[k][G[j][k]]+=t;
						tmp[k+1][G[j][k+1]]+=t;
						tmp[k+2][G[j][k+2]]+=t;
						tmp[k+3][G[j][k+3]]+=t;
					}
					if(j<=n) {
						dp[i+1][a][b][n+1]+=t*(1-p[j]);
						dp[i+1][a+1][b][n+1]+=t*p[j];
					} else {
						dp[i+1][a][b][1]+=t*(1-p[j]);
						dp[i+1][a][b+1][1]+=t*p[j];
					}
				}
				for(reg int j=1;j<=m;++j) {
					int f=(j-1)*D+1;
					rep(k,1,(1<<D)-1) {
						(k&1) &&  (dp[i+1][a][b][f]+=tmp[j][k]);
						(k&2) &&  (dp[i+1][a][b][f+1]+=tmp[j][k]);
						(k&4) &&  (dp[i+1][a][b][f+2]+=tmp[j][k]);
						(k&8) &&  (dp[i+1][a][b][f+3]+=tmp[j][k]);
						(k&16) &&  (dp[i+1][a][b][f+4]+=tmp[j][k]);
						tmp[j][k]=0;
					}
				}
			}
		}
	}
	rep(i,0,R) rep(j,0,R) if(i!=R || j!=R) printf("%.10f",ans[i][j]);
}
```

### Part 2：状态割裂
定义每个球进的时间为关键点，我们发现关键点的状态非常单一，只有两种。

一个合法的转移序列可以被分为若干关键点的段以及最后一段到达 $T$ 之后停止转移。

考虑预处理两个关键点之间的转移概率，令 $g_{a,b,i}$ 为当球在 $a$ 队一号队员时，$i$ 次后 $b$ 队进球的概率。

可以枚举 $a$，类似上面的 dp，去掉比分的一维即可。

预处理复杂度为 $O(Tn^2)$。

然后 dp 时直接枚举两个关键点转移，令 $h_{i,a,b,j}$ 为在时刻 $i$ 比分为 $a,b$，球在 $j$ 队一号队员手上的概率。

转移分两种：
1. 枚举下一个在 $T$ 以内的关键点转移，复杂度为 $O(T)$；
2. 考虑在 $T$ 以内的时间不再出现进球了需要预处理出当球在 $i$ 队手上时，$j$ 次内出现进球的概率 $s_{i,j}$，这个直接由 $g$ 数组累前缀和即可。

dp 关键点的复杂度为 $O(T^2n^2)$。

大概比上面代码快 $4 \thicksim 5$ 倍。

#### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize(2)
typedef float db;
#define reg register
#define rep(i,a,b) for(reg int i=a,i##end=b;i<=i##end;++i)
#define drep(i,a,b) for(reg int i=a,i##end=b;i>=i##end;--i)

char IO;
template <class T=int> T rd(){
	T s=0; int f=0;
	while(!isdigit(IO=getchar())) if(IO=='-') f=1;
	do s=(s<<1)+(s<<3)+(IO^'0');
	while(isdigit(IO=getchar()));
	return f?-s:s;
}

const int INF=1e9+10;
const db eps=1e-12;

int n,R,T;
struct Edge{
	int to,nxt;
} e[80000];
int head[410],ecnt;
void AddEdge(int u,int v) {
	e[++ecnt]=(Edge){v,head[u]};
	head[u]=ecnt;
}
db p[410],sz[410],ans[11][11],f[510][210],g[2][2][510],s[2][510];
// g[i][j][k] 在i拿球的情况下，j在第k次进球了
db h[510][11][11][2];
/*
 * f[i][j]=初始球在d一方的一号球员上，球转移i次后未进门且在j号球员上的概率
 * g[i][j][k]=初始球在i一方的一号球员上，球转移k次后由j方第一次进门的概率
 * s[i][j]=初始球在i一方的一号球员上，球转移不超过j次进门的概率
 * h[i][j][k][l]=球转移i次时进门，此时第一队得j分，第二队得k分，球在l一方的一号球员上的概率
 * ans[i][j]=最终第一队得i分，第二队得j分的概率
 */

int main(){
	n=rd(),R=rd(),T=rd();
	rep(i,1,n*2) {
		scanf("%f",&p[i]);
		int e=rd(),f=rd();
		sz[i]=e+f+1;
		rep(j,1,e) {
			int x=rd();
			if(i>n) x+=n;
			AddEdge(i,x);
		}
		rep(j,1,f) {
			int x=rd();
			if(i<=n) x+=n;
			AddEdge(i,x);
		}
	}
	rep(d,0,1) {
		f[0][d*n+1]=1;
		rep(i,0,T) {
			rep(j,1,n*2) if(f[i][j]>eps) {
				db t=f[i][j]/sz[j];
				for(reg int k=head[j];k;k=e[k].nxt) f[i+1][e[k].to]+=t;
				f[i+1][j>n?1:n+1]+=t*(1-p[j]);
				g[d][j>n][i+1]+=t*p[j];
				f[i][j]=0;
			}
		}
		rep(i,0,T) {
			s[d][i]=g[d][0][i]+g[d][1][i];
			if(i) s[d][i]+=s[d][i-1];
		}
	}
	h[0][0][0][0]=1;
	rep(i,0,T) {
		rep(a,0,R) rep(b,0,R) rep(j,0,1) if(h[i][a][b][j]>eps) {
			if(a==R || b==R || i==T){ ans[a][b]+=h[i][a][b][j]; continue; }
			rep(k,1,T-i) {
				// 能在结束前产生一次进球
				h[i+k][a+1][b][1]+=h[i][a][b][j]*g[j][0][k];
				h[i+k][a][b+1][0]+=h[i][a][b][j]*g[j][1][k];
			}
			ans[a][b]+=h[i][a][b][j]*(1-s[j][T-i]);
		}
	}
	rep(i,0,R) rep(j,0,R) if(i<R || j<R) printf("%.10f\n",ans[i][j]);
```

---


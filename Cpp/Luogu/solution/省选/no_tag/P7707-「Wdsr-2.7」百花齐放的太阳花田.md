# 「Wdsr-2.7」百花齐放的太阳花田

## 题目背景

> 春天到来，花儿盛开……只是这次开花比起以往多上许多，甚至所有季节的花都开了。

$$\kern{1pt}\tag*{\small\text{——东方花映冢}}$$

今年的太阳花田，因为各种各样花朵的开放而显得格外热闹。尽管这是一场有关于花的异变，但是太阳花田的主人风见幽香却格外享受由鲜花带来的五彩缤纷的花田——毕竟，向来冷清的花田因为各种妖精的活跃而变得热闹了起来。

幽香非常喜欢这些花朵。每朵花都有它自己的种类，也代表了一种性格。比如向日葵，比如蒲公英，比如天人菊……

奇怪的是，有些花朵可能会属于同一种类，但由于相关因素（比如年龄、营养等），使得每种花都有一个高度。

幽香非常感兴趣，因为这些花朵高高低低形形色色，使得太阳花田呈现出了别样的景色。兴致之余，幽香选取了一些花朵，希望你帮助她解决一个问题。



## 题目描述

一开始，幽香选择了太阳花田当中的 $n$ 朵花朵。每朵花有一个高度 $h_i$ ，以及它属于的类别 $t_i$ 。它们排成了一列，并且被标号为 $1,2,3\cdots n$ 。幽香有 $m$ 次操作，分为两种：

- $\colorbox{f0f0f0}{\verb!1 l r x!}$ ：考虑区间 $[l,r]$ 内的所有花朵。我们取出其中所有高度不超过 $x$ 的花朵（即 $h_i\le x$ 的花朵），**依次排列**（即不改变花朵在原序列中的顺序），可以根据它们的种类划分为若干段（比如，$\{\underline{1,}\ \underline{2,2},\underline{1,1},\underline {3,}\ \underline{4,4,4}\}$ 就能分为 $5$ 段）。幽香希望你告诉她一共有多少段。

- $\colorbox{f0f0f0}{\verb!2 x y!}$ ：幽香挑选了一朵高度为 $x$ ，种类为 $y$ 的花朵，拼接在末尾。

**强制在线。**

## 说明/提示

$n'$ 表示进行所有操作后的序列长度。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\bf{Subtask} & \bm{n',m} & \textsf{\textbf{特殊性质}} & \textsf{\textbf{分值}} \cr\hline
1 & 1\le n',m \le 10^3 & \text{无} & 10 \cr\hline
2 & 1\le n',m \le 3\times 10^5 & k=0 & 20\cr\hline
3 & 1\le n',m \le 3\times 10^5 & l=1 & 25\cr\hline
4 & 1\le n',m \le 10^5 & \text{无} & 15\cr\hline
5 & 1\le n',m \le 3\times 10^5 & \text{无} & 20\cr\hline
6 & \text{无特殊限制} & \text{时限 3s，空限 300MB} & 10\cr\hline
\end{array}$$

- 对于 $100\%$ 的数据：

   $1 \le n',m \le 5 \times 10 ^ 5$。
   
   $1 \le h_i,t_i,x,y \le 10^9$，$1 \le l \le r \le n'$。
   
   $1 \le op \le 2$，$0 \le k \le 10^3$。

提示：请注意常数优化。

## 样例 #1

### 输入

```
10 10 0
6 8 5 9 6 10 2 4 8 9 
2 4 3 3 4 1 2 3 3 2 
2 2 8
1 1 4 4
2 1 6
2 10 2
1 7 9 7
2 10 8
2 8 4
2 3 10
1 5 16 5
1 4 14 7
```

### 输出

```
0
2
5
5
```

## 样例 #2

### 输入

```
10 20 0
2 19 13 20 7 19 17 8 15 12 
1 2 4 3 5 3 2 4 2 2 
2 9 3
2 17 3
1 1 9 15
1 1 12 3
2 15 5
1 6 13 6
2 7 1
2 20 3
2 12 1
2 10 1
1 5 9 4
1 1 7 15
2 12 4
1 12 12 14
2 7 5
1 3 18 6
1 7 7 1
2 8 5
1 6 8 10
1 14 18 4
```

### 输出

```
5
1
0
0
3
0
0
0
1
0
```

# 题解

## 作者：LFCode (赞：8)

### 一些碎碎念

几个月前赛时匆忙写出的代码码量达到了 $\text{3.2K}$，最近对那份代码进行了一些精简，重构之后码量减少了 $\text{1K}$，而且去掉了很多冗余的变量和步骤。

下面介绍一种两枚 $\log$ 的做法。这种做法不仅思维、代码难度都很低（比 std 短得多），而且跑得很快（俩 $\log$ 碾标算）。最重要的是完全不会被卡空间（比如就不用 std 的神必 short 卡空间技巧）。

> 本场比赛应该只有这个 Subtask 算是卡常的

哈哈。

其实赛时墨染空同志写的就是这种做法（见囧女士题解评论区），但是他惨遭 MLE 打击……或许是没有用指针优化空间的缘故？

### 解法

不知道大家有没有做过 [向量集](https://www.luogu.com.cn/problem/P3309) 这道题目。那道题目同样是强制在线末尾插入、区间查询，我们使用线段树来维护凸包。具体地，当向树上某个节点中插入信息时，我们将该信息暂时搁置。等到一个节点被插满之后，我们使用归并排序思想将其对应的凸包建出。

这种思想完全可以套用至本题中。同样是将某个节点插满之后统计子节点的区间信息，下面我们考虑如何较为完整地记录当前节点的信息，并对来自子区间的信息进行合并。

对于信息的记录，如果去掉高度范围的限制，区间颜色段数是一个经典问题，两个区间信息的合并可以 $O(1)$ 完成。现在加上了高度范围的限制，我们不得不保存将节点中的每一个对象作为限度时的答案。具体地，在经典区间颜色段数问题中，我们对每一个区间维护了三个量：$cnt,lc,rc$，分别表示颜色段数和两端点颜色。在本题中，我们需要对区间 $[l,r]$ 维护 $(r-l+1)$ 个四元组 $\{h,cnt,lc,rc\}$，$h$ 表示限制的最大高度，其他三个量同经典问题。

合并方式类似向量集一题，考虑对子区间维护的所有信息进行归并。归并过程中，不断寻找两个子节点中记录的 $h$ 中较小的一方，并在另一个子节点中找出 $h$ 不高于当前信息的最大四元组，对这两个区间信息进行 $O(1)$ 合并即可。

如何处理查询？同样套用向量集的做法，对于每一次查询，我们在 $O(\log n)$ 个区间中进行二分，并同样用处理经典区间颜色段数问题的方式合并区间信息。

对于信息的保存，用 $\text{vector}$ 当然是可以的，但是听说会卡空间，所以我采用了另一种（可能会更优秀的）存储方式：开一个大数组存下整棵树上所有节点的信息，并用指针存下每个节点信息在大数组上对应的位置。

至此，本题得到完美解决。

代码：

```c++
struct ret{
	int mx,cnt,lc,rc;
	ret(){lc=rc=cnt=0;}
	ret(int mm,int cc,int ll,int rr){mx=mm;cnt=cc;lc=ll;rc=rr;}
	ret operator +(const ret b){
		if(!cnt)return b;
		if(!b.cnt)return *this;
		return ret(Max(mx,b.mx),cnt+b.cnt-(rc==b.lc),lc,b.rc);
	}
	bool operator <=(const ret b)const{return mx<=b.mx;}
	bool operator <(const int x)const{return mx<x;}
};
bool operator <(const int x,const ret y){return x<y.mx;}
bool change(int k,int l,int r,int x,int y,int h){
	if(l==r){
		info[k]=inp;inp++;info[k][0]=ret(h,1,y,y);//inp和info为上文提到过的索引指针
		return true;
	}
	int mid=(l+r)>>1;
	if(x<=mid)change(k<<1,l,mid,x,y,h);
	else change(k<<1|1,mid+1,r,x,y,h);
	if(x!=r)return true;
	int l1=mid-l+1,l2=r-mid;int i=0,j=0,np=0;
	info[k]=inp;inp+=(r-l+1);
	while(i<l1||j<l2){
		if((info[k<<1][i]<=info[k<<1|1][j]&&i<l1&&j<l2)||j>=l2){
			info[k][np]=info[k<<1][i]+(j==0?ret():info[k<<1|1][j-1]);
			i++;np++;
		}
		else{
			info[k][np]=(i==0?ret():info[k<<1][i-1])+info[k<<1|1][j];
			j++;np++;
		}
	}
	return true;
}
ret ask(int k,int l,int r,int x,int y,int h){
	if(l>=x&&r<=y){
		if(info[k][0].mx>h)return ret();
		int pos=std::upper_bound(info[k],info[k]+r-l+1,h)-info[k]-1;
		return info[k][pos];
	}
	int mid=(l+r)>>1;
	if(y<=mid)return ask(k<<1,l,mid,x,y,h);
	if(mid<x)return ask(k<<1|1,mid+1,r,x,y,h);
	ret xx=ask(k<<1,l,mid,x,y,h)+ask(k<<1|1,mid+1,r,x,y,h);
	return xx;
}
int main(){
	n=read();m=read();len=n+m;int k=read();inp=ii;//ii为上文提到过的大数组
	for(int i=1;i<=n;i++)ta[i]=read();
	for(int i=1;i<=n;i++)change(1,1,len,i,read(),ta[i]);
	for(int i=1;i<=m;i++){
		int opt=read();
		if(opt&1){
			int l=read()^(k*lans);int r=read()^(k*lans);int x=read()^(k*lans);
			ret ans=ask(1,1,len,l,r,x);
			printf("%d\n",lans=ans.cnt);
		}
		else{
			int h=read()^(k*lans);int y=read()^(k*lans);
			change(1,1,len,++n,y,h);
		}
	}
}
```

---

## 作者：灵华 (赞：5)

[P7707 百花齐放的太阳花田](https://www.luogu.com.cn/problem/P7707)

感觉题目看上去就很线段树，考虑用线段树去暴力维护。

正常开一颗线段树。

我们对线段树上每个节点，都维护一个序列，分别表示在某个高度下的颜色段数，两边是什么颜色。

然后合并就使用类似于归并排序的方法，进行合并。

考虑这样做的复杂度：

如果说一个节点维护了多个信息，那么看上去，这复杂度貌似是 $O(n^2)$~~（实际上如果写法假了也确实就是 $n^2$ 的）~~。

但实际上，其实一个节点内部不会维护 $O(n)$ 个那么多的信息。那怎么分析复杂度呢？

显然的一件事情，就是如果说想卡到最满，那么每个位置上的高度都应是不同的。（归并排序复杂度是 $O(长度)$ 的）。

那么对于线段树上的一层，最多就会维护 $O(n)$ 个信息（指的是这一整层的所有信息）。所以维护的信息的个数就是 $O(n\log n)$ 的。

或者说换个想法：对于一个叶子节点，他最多向上上传 $\log$ 次，所以最多会有 $\log$ 个节点带有他的信息。所以最多会有 $n\log n$ 个信息。

至于查询操作，其实就把线段树上的 $\log$ 个区间，挑出来要求高度的底下最高的那个高度的信息即可，然后合并这 $\log$ 个信息就可以了。

至于插入操作，提前把线段树的大小开成是 $n+m$ 的，把位置给他预留出来，之后每次修改一个位置再上传一个标记。

其实如果仔细想想，如果说对每次的修改，回溯时都要把路径上的 $\log$ 个节点都进行一次pushup，就会发现这样直接上传标记的复杂度也是不对的，到了 $O(n)$ 的级别。~~真无语住了，一个题，全是坑~~

但是我们可以不用上传用不到的节点的信息。就是说，如果说某次从最后插入一个值，这个位置是线段树上某几个区间的最后一个位置，那么我们才需要把这个节点的信息上传，否则他一定不会扫到这个节点，一定会向下递归，所有就可以不用管这个具体信息了。

这么修改复杂度均摊一下就显然是正确的了。

具体复杂度没算过，反正最多俩log，肯定超不过去。~~最多常数大点？~~

具体实现的话，对线段树上每个节点开个vector保存信息就好了？

空间常数还是很小的，虽然正解的做法卡空间，但这个不卡/doge。随便写写，不用卡空间就能过。

Code:
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <bits/stdc++.h> 
using namespace std ;

const int N = 1000005 ;
int n , m , k , lans , now , a[N] ;

struct Node
{
	int h , s , l , r ;
	Node ( int _h = 0 , int _s = 0 , int _l = 0 , int _r = 0 ) :
		h ( _h ) , s ( _s ) , l ( _l ) , r ( _r ) { }
	friend bool operator < ( Node u , Node v )
	{
		return u .h < v .h ;
	}
} ;

vector < Node > t[N<<2] ;
#define IT vector<Node>::iterator

void pushup ( int k , int l , int r )
{
	IT itl = t [ k << 1 ] .begin ( ) , itr = t [ k << 1 | 1 ] .begin ( ) ;
//	cout << " pushup : " << l << " - " << r << endl ;
	while ( itl != t [ k << 1 ] .end ( ) && itr != t [ k << 1 | 1 ] .end ( ) )
	{
		if ( itl -> h <= itr -> h )
		{
			if ( itl -> h != itr -> h )
			{
				if ( itr == t [ k << 1 | 1 ] .begin ( ) )
				{
					t [ k ] .push_back ( Node ( itl -> h , itl -> s , itl -> l , itl -> r ) ) ;
					++ itl ;
					continue ;
				}
				-- itr ;
			}
			if ( itl -> r == itr -> l )
				t [ k ] .push_back ( Node ( itl -> h , itl -> s + itr -> s - 1 , itl -> l , itr -> r ) ) ;
			else
				t [ k ] .push_back ( Node ( itl -> h , itl -> s + itr -> s , itl -> l , itr -> r ) ) ;
		}
		else
		{
			if ( itl == t [ k << 1 ] .begin ( ) )
			{
				t [ k ] .push_back ( Node ( itr -> h , itr -> s , itr -> l , itr -> r ) ) ;
				++ itr ;
				continue ;
			}
			-- itl ;
			if ( itl -> r == itr -> l )
				t [ k ] .push_back ( Node ( itr -> h , itl -> s + itr -> s - 1 , itl -> l , itr -> r ) ) ;
			else
				t [ k ] .push_back ( Node ( itr -> h , itl -> s + itr -> s , itl -> l , itr -> r ) ) ;
		}
		++ itl ;
		++ itr ;
	}
	if ( itl != t [ k << 1 ] .end ( ) )
	{
		-- itr ;
		while ( itl != t [ k << 1 ] .end ( ) )
			t [ k ] .push_back ( Node ( itl -> h , itl -> s + itr -> s - ( itl -> r == itr -> l ) , itl -> l , itr -> r ) ) , ++ itl ;
	}
	else if ( itr != t [ k << 1 | 1 ] .end ( ) )
	{
		-- itl ;
		while ( itr != t [ k << 1 | 1 ] .end ( ) )
			t [ k ] .push_back ( Node ( itr -> h , itl -> s + itr -> s - ( itl -> r == itr -> l ) , itl -> l , itr -> r ) ) , ++ itr ;
	}
}

void change ( int k , int l , int r , int x , int y , int z )
{
	if ( l == r )
	{
		t [ k ] .push_back ( Node ( z , 1 , y , y ) ) ;
		return ;
	}
	int mid = ( l + r ) >> 1 ;
	if ( x <= mid )
		change ( k << 1 , l , mid , x , y , z ) ;
	else
		change ( k << 1 | 1 , mid + 1 , r , x , y , z ) ;
	if ( x == r )
		pushup ( k , l , r ) ;
}

struct Leaf
{
	int s , l , r ;
	Leaf ( int _s = 0 , int _l = 0 , int _r = 0 ) : s ( _s ) , l ( _l ) , r ( _r ) { }
} ;

Leaf query ( int k , int l , int r , int x , int y , int z )
{
	if ( x <= l && r <= y )
	{
		if ( z < t [ k ] [ 0 ] .h )
		{
//			cout << " query : " << l << " - " << r << " : res ( 0 , 0 , 0 ) " << endl ;
			return Leaf ( 0 , 0 , 0 ) ;
		}
		IT it = upper_bound ( t [ k ] .begin ( ) , t [ k ] .end ( ) , Node ( z ) ) ;
		-- it ;
//		cout << " query : " << l << " - " << r << " : res ( " << it -> s << " , " << it -> l << " , " << it -> r << " )" << endl ;
		return Leaf ( it -> s , it -> l , it -> r ) ;
	}
	int mid = ( l + r ) >> 1 ;
	if ( y <= mid )
	{
//		Leaf res = query ( k << 1 , l , mid , x , y , z ) ;
//		cout << " query : " << l << " - " << r << " : res ( " << res .s << " , " << res .l << " , " << res .r << " )" << endl ;
//		return res ;
		return query ( k << 1 , l , mid , x , y , z ) ;
	}
	if ( x > mid )
	{
//		Leaf res = query ( k << 1 | 1 , mid + 1 , r , x , y , z ) ;
//		cout << " query : " << l << " - " << r << " : res ( " << res .s << " , " << res .l << " , " << res .r << " )" << endl ;
//		return res ;
		return query ( k << 1 | 1 , mid + 1 , r , x , y , z ) ;
	}
	Leaf res1 , res2 ;
	res1 = query ( k << 1 , l , mid , x , y , z ) ;
	res2 = query ( k << 1 | 1 , mid + 1 , r , x , y , z ) ;
//	cout << " query : " << l << " - " << r << " : " ;
//	cout << " res1 : ( " << res1 .s << " , " << res1 .l << " , " << res1 .r << " ) , " ;
//	cout << " res2 : ( " << res2 .s << " , " << res2 .l << " , " << res2 .r << " ) " << endl ;
	if ( res1 .s == 0 )
		return Leaf ( res2 .s , res2 .l , res2 .r ) ;
	if ( res2 .s == 0 )
		return Leaf ( res1 .s , res1 .l , res1 .r ) ;
	return Leaf ( res1 .s + res2 .s - ( res1 .r == res2 .l ) , res1 .l , res2 .r ) ;
}

void dfs ( int k , int l , int r )
{
	int siz = t [ k ] .size ( ) ;
	if ( siz )
	{
		cout << " dfs : " << l << " - " << r << endl ;
		for ( int i = 0 ; i < siz ; ++ i )
			cout << t [ k ] [ i ] .h << " : " << t [ k ] [ i ] .s << " , " << t [ k ] [ i ] .l << " - " << t [ k ] [ i ] .r << endl ;
		cout << endl ;
	}
	if ( l == r )
		return ;
	int mid = ( l + r ) >> 1 ;
	dfs ( k << 1 , l , mid ) ;
	dfs ( k << 1 | 1 , mid + 1 , r ) ;
}

int main ( )
{
	cin >> n >> m >> k ;
	for ( int i = 1 ; i <= n ; ++ i )
	{
		cin >> a [ i ] ;
	}
	for ( int i = 1 ; i <= n ; ++ i )
	{
		int x ;
		cin >> x ;
		change ( 1 , 1 , n + m , i , x , a [ i ] ) ;
	}
	now = n ;
	n += m ;
//	dfs ( 1 , 1 , n ) ;
	for ( int i = 1 ; i <= m ; ++ i )
	{
		int op , x , y ;
		cin >> op >> x >> y ;
		x = x ^ ( k * lans ) ;
		y = y ^ ( k * lans ) ;
		if ( op == 1 )
		{
			int z ;
			cin >> z ;
			z = z ^ ( k * lans ) ;
			cout << ( lans = query ( 1 , 1 , n , x , y , z ) .s ) << endl ;
//			if ( x == 4 && y == 6 )
//				dfs ( 1 , 1 , n ) ;
		}
		else
		{
			change ( 1 , 1 , n , ++ now , y , x ) ;
		}
//		dfs ( 1 , 1 , n ) ;
	}
	return 0 ;
}
```

~~码风有点鬼畜，请谨慎使用？~~

---

## 作者：囧仙 (赞：1)

- Subtask 1

  直接 $O(nm)$ 暴力
  
- Subtask 2

  显然如果没有强制在线，我们可以在进行完所有操作二后再处理查询
  
  然后我们按照 $a_i$ 进行排序，按 $a_i$ 从小到大加入每个 $b_i$，使用线段树动态维护每次加入后序列的颜色段信息
  
  然后对查询按照 $x$ 从大到小排序，处理 $x = a_i$ 的查询即可
  
- Subtask 3

  因为修改操作很神奇，是在末尾插入，所以可以考虑维护前缀信息
  
  我们对于每个前缀 $[1,i]$，动态维护所有 $x$ 的答案
  
  考虑如何由 $[1,i - 1]$ 推及 $[1,i]$：加入 $a_i$ 的信息，只会使 $x \ge a_i$，且 $lst_x \neq b_i$ 的 $x$ 答案增加 $1$，$lst$ 是我们维护的每个 $x$ 对应的最后一个颜色的值
  
  乍一看如果要维护，复杂度会相当高。但是在进行完这次操作后，所有 $x \ge a_i$ 的 $lst_x$ 都会变为 $b_i$，这意味着我们可以使用颜色段均摊
  
  具体来说，我们将 $lst$ 相同的一些连续的 $x$ 缩成一个段，放到一个 set 里，每次在末尾插入时，遍历所有涉及的段，看是否需要给这一段的 $x$ 答案 +1，最后删掉所有涉及的段，放入一个大段即可
  
  给这一段 $x$ 答案 + 1 的操作，可以使用可持久化线段树，先让 $[1,i]$ 的答案继承 $[1,i - 1]$ 的信息，然后给需要 +1 的那些段进行区间加操作
  
  这样查询就是一个单点查询
  
  实际上没有必要真的写区间加，单点查询，可以通过差分支持单点加，区间求和
  
- Subtask 4

  给一些 $O(m \log^2 n)$ 或 $O(m \sqrt n)$ 的解法
  
- Subtask 5

  区间颜色段数实际上具有一定的可减性，$[l,r]$ 的答案相当于 $[1,r] - [1,l - 1] + [lst = fst]$，$lst$ 表示 $[1,l - 1]$ 中最后一个 $a_i \le x$ 的 $b_i$，$fst$ 表示 $[l,r]$ 中第一个 $a_i \le x$ 的 $b_i$
  
  那么只要能够找到 $lst,fst$ 就解决问题了
  
  我们可以写一个数据结构，维护 $a_i$ 的区间 $\min$，然后从 $l$ 分别向左，向右二分，就可以找到第一个 $a_i \le x$ 的位置
  
  因为二分有一个 $\log$，所以要支持 $O(1)$ 查询才能保证复杂度，因为只在末尾插入，可以使用 ST 表，$ST_{i,j}$ 维护 $[j - 2^i + 1,j]$ 的 $\min$（这个东西貌似有些人叫做动态ST表）
  
  当然你写个线段树上二分之类也是可以的
  
  综上，这是一个时间复杂度为 $O((n' + m) \log n)$，空间复杂度为 $O(n' \log n)$ 的算法
  
- Subtask 6

  我们来分析一下空间常数
  
  首先，加入 $i$ 的信息会增加 $1$ 个颜色段，因此一共会有 $n'$ 个颜色段，每个颜色段可能引起两次单点修改
  
  而加入 $i$ 的信息需要一次单点修改，于是你一共需要 $3n'$ 次单点修改
  
  （如果你实现不太好，分裂 $a_i$ 所在段得到的后半部分恰巧 $lst = b_i$ 的话，会达到 $5n'$）
  
  因此你需要 $4.5 \times 10^7$ 个节点，每个节点需要三个 `int`，然后你挂了
  
  考虑怎么优化，首先可以合并相邻同色颜色段，这样你推掉 $s$ 个段，至多只有 $\left \lceil \frac{s}{2} \right \rceil$ 个段需要进行两次单点修改，修改数是 $s + 1$ 级别的
  
  什么时候能卡到 $s + 1$ 呢？答案是开头与结尾都是 $lst = y$ 的情况，特判掉开头就可以了
  
  于是只要 $2n'$ 次单点修改，这样会有 $3.1 \times 10^7$ 个节点
  
  但是这样你还是过不去，大概需要 343M 的样子
  
  考虑主席树的结构，如果你使用的标号方式是开一个 $cnt$，每次分配第 $cnt$ 个位置的话，你会发现对于树上每个节点 $rt$，其左右儿子中，必定有一个的编号是 $rt + 1$
  
  于是我们只存不是 $rt + 1$ 那个位置的编号 $x$，加一位标示哪个儿子是 $rt + 1$
  
  剩下存区间和是无法避免的，这样的信息量是 $5 \times 10 ^ 5 \times 3.1 \times 10^7 \times 2 = 3.1 \times 10^{13} < 2^{48}$
  
  于是可以使用一个 `unsigned int` 和一个 `unsigned short` 压缩存储信息
  
  具体分配：`unsigned int` 的 $0 \sim 24$ 位存储 $x$，第 $25$ 位是标示符，$26 \sim 30$ 位存 $val \bmod 2^5$，$31$ 位存储 $val$ 正负性，`unsigned short` 存 $\left \lfloor \dfrac{val}{2^5} \right \rfloor$ 
  
  主席树部分需要 172M 左右，剩下的数组的空间开销并不大
  
  本场比赛应该只有这个 Subtask 算是卡常的

---

## 作者：MoYuFang (赞：0)

#### 前言：

这篇题解的主要思路与[囧仙大大的题解](https://www.luogu.com.cn/blog/over-knee-socks/solution-Wdsr2o7-T3) 一致，只不过讲的更详细一些。

#### 提前说明：

题面中花的种类在本篇题解中称作花的颜色。

为了方便理解先说明一下变量含义：

1. $n$ 表示当前序列长度。
2. $ht(i)$ 表示第 $i$ 朵花的高度。
3. $ty(i)$ 表示第 $i$ 朵花的颜色。
4. $f(i,h)$ 表示从前 $i$ 朵花中取出高度不超过 $h$ 的花并排成一列后的不同颜色段的个数。
5. $lst(i, h)$ 表示前 $i$ 朵花中最后一朵高度不超过 $h$ 的花的颜色。

#### 题解：

则状态的转移可以表示成：

$$ f(i+1,h)=\left\{

\begin{aligned}

& f(i,h) &(h < ht(i+1)) \\

& f(i,h) + (ty(i+1) \neq lst(i, h)) & (h \geq ht(i+1))\\

\end{aligned}

\right.

$$

以及：

$$ lst(i+1,h) = \left\{

\begin{aligned}

& lst(i,h) & (h < ht(i+1))\\

& ty(i+1) & (h \geq ht(i+1))\\

\end{aligned}

\right.

$$

注意所有 $h \geq ht(i+1)$ 的 $lst$ 值都被更新为了同一值。

考虑如何回答查询 $1$ $l$ $r$ $h$。

不妨先假设 $ht(l) \leq h$，否则就先在闭区间 $[l,r]$ 中寻找到最小的 $l^\prime$ 使得 $ht(l^\prime) \leq h $，然后让 $l^\prime$ 作为新的 $l$，易知答案不变。

$l^\prime$ 可以用二分 + $\text{st}$ 表实现 $O(\log n)$ 查找。

因为颜色段数具备一定的可减性，所以可以通过前缀和相减，然后再加上一个修正因子得到答案，则本次查询的答案为：

$ f(r,h) - f(l-1,h) + (lst(l-1,h)==ty(l))$

$lst(l-1,h)$ 也可以用二分 + $\text{st}$ 表实现 $O(\log n)$ 查找。

所以接下来只需要考虑如何维护 $f(i,h)$ 和 $lst(i,h)$了。

我们可以开一个主席树，对每一个版本 $f_i$ 维护一颗值域为 $[1,10^9]$ 的线段树，设 $f_i(h)$ 表示第 $i$ 颗线段树上第 $h$ 个位置的值，则这里线段树上值 $f_i(h)$ 的意义就是 $f(i,h)$。

当我们加入第 $i+1$ 朵花时，会使全部 $h \geq ht(i+1)$ 的 $lst$ 更新为 $ty(i+1)$。

我们可以考虑用单调栈动态维护每个时刻 $i$ 的所有的 $lst(i,h)$，单调栈里保存的是每段 $h$ 连续的 $lst$，且同一段中 $lst$ 的值（也即颜色）都相同。

具体实现是对栈中的每个元素 $stk(j)$，维护三个变量 $low_j$ $high_j$ 和 $type_j$，表示所有 $low_j \leq h \leq high_j$ 的 $lst(i,h)$ 都等于 $type_j$。

栈中任意相邻元素 $stk(i)$ 和 $stk(i+1)$ 均满足，$high_i + 1= low_{i+1}$。

且栈底元素 $stk_1$ 满足 $low_1 = 1$，栈顶元素 $stk_{top}$ 满足 $high_{top} = 10^9$，分别代表最低高度和最高高度。 

单调栈的图示如下：

![illustration](https://cdn.luogu.com.cn/upload/image_hosting/7f3ua84r.png)

一开始（没有加入任何花的时候）单调栈只有一个元素 $stk(1)$。

且有 $low_1 = 1$，$high_1 = 10^9$ 以及 $type_1 = 0$，注意到题目中颜色的数据范围是 $1 \leq t_i \leq 10^9$，$type_1 = 0$ 不会与任何颜色冲突。

接下来考虑加入一朵花时如何对主席树和单调栈修改以维护 $f(i,h)$ 和 $lst(i,h)$。

当我们加入第 $i+1$ 朵花时，逐个弹出栈顶元素。

设接下来 $stk(top)$ 始终表示当前的栈顶元素。

若 $type_{top} \neq ty(i+1)$，则对版本为 $f_{i+1}$ 的线段树做一次区间加，即在版本 $f_i$ 的基础上让所有 $low_{top} \leq h \leq high_{top}$ 的 $f_{i+1}(h)$ 均加 $1$。

若 $type_{top} = ty(i+1) $，则不进行区间加。

这就相当于进行了 $f(i+1,h)$ 的状态转移方程中的第二行转移。

弹出栈顶直到 $ht(i+1) \geq low_{top}$ 时才停止，因为对于 $h < ht(i+1)$ 的 $f(i+1,h)$ 和 $lst(i+1,h)$ 不会被更新。

并让所有 $ht(i+1) \leq h \leq high_{top}$ 的 $f_{i+1}(h)$ 均加 $1$。

然后若 $ht(i+1) > low_{top}$，则将 $high_{top}$ 修改成 $ht(i+1)-1$，$stk(top)$ 的其它两项不变，代表这一段的 $lst$ 从中间被切断了。

否则 $ht(i+1) = low_{top}$，将 $stk(top)$ 也弹出，代表这一段 $lst$ 都会被更新。

然后再入栈一个新元素 $stk(top+1)$，满足 $low_{top+1} = ht(i+1)$，$high_{top+1} = 10^9$ 以及 $type_{top+1} = ty(i+1)$，新元素代表了新一段的 $lst$。

这样我们就利用主席树和单调栈同时维护了 $f(i,h)$ 和 $lst(i,h)$。

#### 时间复杂度：

考虑一下时间复杂度，每加入一朵花时最多使单调栈增多一个元素，每个元素只有在被弹出或被切断时才会在主席树上进行区间加操作，每次区间加最多影响 $O(\log R)$ 个节点，其中 $R$ 线段树值域（在本题中 $R = 10^9$）， 所以修改的总时间复杂度是 $O(n\log R)$。

此外还要用 $O(n\log n)$ 维护一个支持在末尾插入元素的 $\text{st}$ 表。

对于查询操作，则涉及到二分 + $\text{st}$ 表的查询和在主席树上的单点查询，设查询次数为 $q$，则查询的总复杂度为 $O(q\log R + q\log n)$。

题解中说的主席树要支持区间加和单点查询，但实际上也可以差分后转化为单点加和区间求和，修改和查询的时间复杂度不变。

#### 结束：

到这里本篇题解就基本结束了，如果不考虑卡空间，按上面的思路写一份代码会有 $90$ 的好成绩，剩下那 $10$ 分囧仙大大的题解里写的很清楚，本篇题解就不赘述了。

![分数](https://cdn.luogu.com.cn/upload/image_hosting/6pzhyrvu.png)

贴一份代码（不考虑卡空间的代码）：

代码中主席树支持的是单点加和区间求和操作。

只用了常量宏和循环宏。

```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;

#define re register
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define maxn 500005
#define maxnn 30000005
#define lbmaxn 25
#define maxrg 1e9

int rdnt(){
	register int x = 0, sign = 1;
	register char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

int 
	n, //当前花的朵数 
	top = 0, //栈顶 
	stk[maxn][3], //单调栈：三个元素分别代表 low high 和 type 
	
	lb[maxn], //以二为底的对数 
	st[lbmaxn][maxn], //st 表 
	
	ht[maxn], //花的高度 
	ty[maxn], //花的种类 
	
	ncnt, //主席树的节点数 
	rg, //线段数的值域 
	rt[maxn], //每个版本线段树的根 
	lc[maxnn], //左儿子 
	rc[maxnn], //右儿子 
	val[maxnn]; //值 

void init(){
	lb[0] = -1;
	_rfor(i, 1, maxn-5) lb[i] = lb[i>>1]+1;
	
	rg = maxrg;
	n = ncnt = val[0] = lc[0] = rc[0] = rt[0] = 0;
	
	//单调栈的初始化 
	top = 1;
	stk[top][0] = 1; stk[top][1] = maxrg; stk[top][2] = 0;
}
	
///////主席树

//得到一个继承旧节点 x 的新节点 
int new_node(re int x){
	++ncnt;
	lc[ncnt] = lc[x]; rc[ncnt] = rc[x]; val[ncnt] = val[x];
	return ncnt;
}

//单点加 
void add_point(re int x, re int p, re int dlt){
	re int tl = 1, tr = rg, mi, ox = x = rt[x];
	while(tr > tl){
		mi = (tl+tr)>>1;
		val[x] += dlt;
		if (p <= mi){
			if (lc[x] < ox) lc[x] = new_node(lc[x]);
			x = lc[x], tr = mi;
		}
		else{
			if (rc[x] < ox) rc[x] = new_node(rc[x]);
			x = rc[x], tl = mi+1;
		}
	}
	val[x] += dlt;
}

//差分后将区间加转化为单点加 
void add(int x, int l, int r){
	add_point(x, l, 1);
	if (r < rg) add_point(x, r+1, -1);
}

//差分后将单点查询转化为区间求和 
int qry(int x, int l, int r, int tl, int tr){
	if (!x) return 0;
	if (l == tl && r == tr) return val[x];
	int mi = (tl+tr)>>1;
	if (r <= mi) return qry(lc[x], l, r, tl, mi);
	else if (l > mi) return qry(rc[x], l, r, mi+1, tr);
	else return qry(lc[x], l, mi, tl, mi) + qry(rc[x], mi+1, r, mi+1, tr);
}

//得到题解中说的 f(r,h) - f(l-1,h) 
int qry_seg(int l, int r, int h){
	return qry(rt[r], 1, h, 1, rg) - qry(rt[l-1], 1, h, 1, rg);
}

//////主席树

//////st 表 

//在 st 表末尾加入元素(花的高度) 
void add_st(re int h){
	st[0][n+1] = h;
	re int lbn = lb[n+1], j;
	_rfor(i, 1, lbn){
		j = n+1-(1<<i)+1;
		st[i][j] = min(st[i-1][j], st[i-1][j+(1<<(i-1))]);
	}
}

//对 st 表的查询 
int qry_st(re int l, re int r){
	re int lbl = lb[r-l+1];
	return min(st[lbl][l], st[lbl][r-(1<<lbl)+1]);
}
//////st 表 

//得到题解中说的修正因子 (lst(l-1,h) == ty(l)) 
int qry_lst(re int l, re int r, re int h){
	re int le, ri, mi, t1, t2;
	//二分找到 l' 
	le = l, ri = r+1, t1 = l-1;
	while(ri > le){
		mi = (le+ri)>>1;
		if (qry_st(l, mi) > h) t1 = mi, le = mi+1;
		else ri = mi;
	}
	++t1;
	//若 l' 不存在则返回 0 
	if (t1 > r) return 0;
	
	//二分找到 lst(i-1,h) 
	le = 1, ri = l, t2 = l;
	while(ri > le){
		mi = (le+ri)>>1;
		if (qry_st(mi, l-1) > h) ri = t2 = mi;
		else le = mi+1;
	}
	--t2;
	
	return (ty[t1] == ty[t2]);
}

//加入新一朵花
//传入的参数 h 代表新花的高度，t 代表新花的颜色 
void add_flower(re int h, re int t){
	ht[n+1] = h; ty[n+1] = t;
	
	//在st 表末尾加入元素 
	add_st(h);
	
	//新版本的线段树继承旧版本的线段数 
	rt[n+1] = new_node(rt[n]);
	
	re int low, high, type;
	//不断弹出栈顶 
	while(true){
		low = stk[top][0]; high = stk[top][1]; type = stk[top][2];
		if (type != t) add(n+1, max(h, low), high);
		
		//判断是否该停止不断弹出栈顶的操作 
		if (h >= low){
			if (h == low) --top;
			else stk[top][1] = h-1;
			break;
		}
		--top;
	}
	//入栈新元素 
	++top;
	stk[top][0] = h; stk[top][1] = maxrg; stk[top][2] = t;
	++n;
}

int main(){
	
	re int tn = rdnt(), m = rdnt(), k = rdnt(), l, r, x, y, opt, last_ans = 0;
	
	init();
	
	_rfor(i, 1, tn) ht[i] = rdnt();
	_rfor(i, 1, tn) ty[i] = rdnt();
	_rfor(i, 1, tn) add_flower(ht[i], ty[i]);
	
	_rfor(i, 1, m){
		opt = rdnt();
		if (opt == 1){
			l = rdnt()^(k*last_ans);
			r = rdnt()^(k*last_ans);
			x = rdnt()^(k*last_ans);
			last_ans = qry_seg(l, r, x) + qry_lst(l, r, x);
			printf("%d\n", last_ans);
		}
		else if (opt == 2){
			x = rdnt()^(k*last_ans);
			y = rdnt()^(k*last_ans);
			add_flower(x, y);
		}
	}
	
	return 0;
}


```


---


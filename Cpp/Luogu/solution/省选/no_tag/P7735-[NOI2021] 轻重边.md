# [NOI2021] 轻重边

## 题目描述

小 W 有一棵 $n$ 个结点的树，树上的每一条边可能是轻边或者重边。接下来你需要对树进行 $m$ 次操作，在所有操作开始前，树上所有边都是轻边。操作有以下两种：
1. 给定两个点 $a$ 和 $b$，首先对于 $a$ 到 $b$ 路径上的所有点 $x$（包含 $a$ 和 $b$），你要将与 $x$ 相连的所有边变为轻边。然后再将 $a$ 到 $b$ 路径上包含的所有边变为重边。
2. 给定两个点 $a$ 和 $b$，你需要计算当前 $a$ 到 $b$ 的路径上一共包含多少条重边。


## 说明/提示

**【样例解释 #1】**

第 $1$ 次操作后，重边有：$(1, 3)$，$(3, 6)$，$(6, 7)$。

第 $2$ 次操作，包含的重边有：$(1, 3)$。

第 $3$ 次操作，包含的重边有：$(1, 3)$，$(3, 6)$，$(6, 7)$。

第 $4$ 次操作，首先 $(1, 3)$，$(3, 6)$ 变为轻边，之后 $(1, 3)$，$(3, 5)$ 变为重边。

第 $5$ 次操作，包含的重边有：$(1, 3)$，$(6, 7)$。

第 $6$ 次操作，首先 $(1, 3)$ 变为轻边，之后 $(1, 2)$ 变为重边。

第 $7$ 次操作，包含的重边有：$(6, 7)$。

**【样例 #2】**

见附件 `edge/edge2.in` 与 `edge/edge2.ans`。

该样例约束与测试点 $3 \sim 6$ 一致。

**【样例 #3】**

见附件 `edge/edge3.in` 与 `edge/edge3.ans`。

该样例约束与测试点 $9 \sim 10$ 一致。

**【样例 #4】**

见附件 `edge/edge4.in` 与 `edge/edge4.ans`。

该样例约束与测试点 $11 \sim 14$ 一致。

**【样例 #5】**

见附件 `edge/edge5.in` 与 `edge/edge5.ans`。

该样例约束与测试点 $17 \sim 20$ 一致。

**【数据范围】**

对于所有测试数据：$T \le 3$，$1 \le n, m \le {10}^5$。

| 测试点编号 | $n, m \le $ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 6$ | $5000$ | 无 |
| $7 \sim 8$ | ${10}^5$ | A，B |
| $9 \sim 10$ | ${10}^5$ | A |
| $11 \sim 14$ | ${10}^5$ | B |
| $15 \sim 16$ | $2\times {10}^4$ | 无 |
| $17 \sim 20$ | ${10}^5$ | 无 |

特殊性质 A：树的形态是一条链。

特殊性质 B：第 $2$ 类操作给出的 $a_i$ 和 $b_i$ 之间有边直接相连。

## 样例 #1

### 输入

```
1
7 7
1 2
1 3
3 4
3 5
3 6
6 7
1 1 7
2 1 4
2 2 7
1 1 5
2 2 7
1 2 1
2 1 7```

### 输出

```
1
3
2
1```

# 题解

## 作者：小毓 (赞：132)

大家好啊！作为一个蒟蒻，能在线上同步赛的时候把这题做出来，我的心里可是万分欣喜的啊！（大佬勿嘲）

好了，话不多说，我来与大家分享一下我的想法。（可能有点啰嗦）

看到这个题，树上的路径操作并查询，那不就是树剖么？心里顿时有了底。可是仔细读题，发现并不是单纯地路径操作，还会涉及到对于每个点邻边的修改。这怎么搞？貌似单纯直白的树剖并不能解决问题。这条路能否走通呢？

其实是能的。我们对问题进行一个简单而巧妙的转化，就能解决！如果我们在每次操作的时候，将修改路径上的点全部染上一种**独一无二的颜色**，判断重边就只需要判断两端点颜色是否相同即可。端点颜色相同为重边，否则为轻边。

如果您懂了，就可以跳过下面这段话。

没有太懂的话，具体的讲一讲，因为要将一条路径上的边修成重边，那么路径点染同色的操作就可以保证这条路径上**点同色且所有边两端点同色**，这样这些边就符合重边的判定了！而且更妙的是，由于这些点被染成的是一种**独一无二的颜色**，是一定不与前面的颜色重复的，所以所有染色点连边的另一端一定与它的颜色不同，这样子这些边就自然而然的变成了轻边。这个转化不得不说是很精妙的。

于是，问题变成了：

如何统计树的一段路径上**同色相邻**点对的数量？（相邻：保证两点有边；同色：保证是重边）

这里提供一种线段树维护的经典方法：对于每个节点建立结构体，分别存储三个信息：该区间左端点颜色、该区间右端点颜色、该区间内同色相邻点对数量。这样在合并的时候，通过比较两区间接头处颜色的情况，来更新新的区间答案。具体可以看看代码，里面有详尽的注释和陷阱的提醒（码风巨丑不喜可调）

哦哦，另外补充一下，这个题的代码中树剖区间查询可以说是一大重难点。因为我们需要查询区间左右“有序”，所以我们会设置两个答案变量$ans1$和$ans2$，分别以下图的方式从两头统计答案，最后再合并。还是看代码吧大家~~

![Pic](https://cdn.luogu.com.cn/upload/image_hosting/pvqm78vg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

```
#include <cstring>
#include <cstdio>
const int MX=100005;
int n,ind,fir[MX],deep[MX],idx[MX],topf[MX],son[MX],sz[MX],fa[MX];
struct Edge{int to,nxt;}e[MX<<1];
struct Node{int lc,rc,cnt;void cln(){lc=rc=cnt=0;}};
//Node结构体中：lc左颜色，rc右颜色，cnt个数 
struct Segtree{
	int lazy[MX<<2];Node tree[MX<<2];
	void cln(){
		//线段树内清空 
	    memset(lazy,0,sizeof lazy);
		for(int i=0,h=MX<<2;i<h;i++)tree[i].cln();	
	}
	void lazy_down(int k,int l,int r){
		//懒标记下传 
		if(!lazy[k])return;
		int x=lazy[k],mid=(l+r)>>1;lazy[k]=0;
		lazy[k<<1]=lazy[k<<1|1]=x;
		tree[k<<1]=(Node){x,x,mid-l};
		//为什么是mid-l？因为一共有mid-l+1个点都被染成颜色x，所以考虑间隔有mid-l对 
		tree[k<<1|1]=(Node){x,x,r-mid-1};
		//为什么是r-mid-1？理由同上啦 
	}
	void update(int ul,int ur,int nl,int nr,int pos,int num){
		if(ul<=nl&&nr<=ur){
			tree[pos]=(Node){num,num,nr-nl};
			//为什么是nr-nl？理由在lazy_down函数里啦 
			lazy[pos]=num;return;
		}
		lazy_down(pos,nl,nr);int mid=(nl+nr)>>1;
		if(ul<=mid)update(ul,ur,nl,mid,pos<<1,num);
		if(mid<ur)update(ul,ur,mid+1,nr,pos<<1|1,num);
		Node ls=tree[pos<<1],rs=tree[pos<<1|1];
		tree[pos]=(Node){
			ls.lc,rs.rc,ls.cnt+rs.cnt+(ls.rc==rs.lc)
		};
		//关键↑区间合并，应该比较好懂，关键在于左儿子的右颜色
		//和右儿子的左颜色相同时，需要将计数器加一 
	}
	Node query(int al,int ar,int nl,int nr,int pos){
		if(al<=nl&&nr<=ar)return tree[pos];
		lazy_down(pos,nl,nr);int cnt=0,mid=(nl+nr)>>1;Node w1,w2;
		//cnt负责控制查询情况种类，见下↓ 
		if(al<=mid){cnt++;w1=query(al,ar,nl,mid,pos<<1);}
		if(mid<ar){cnt+=2;w2=query(al,ar,mid+1,nr,pos<<1|1);}
		if(cnt==1)return w1;if(cnt==2)return w2;
		return (Node){
			w1.lc,w2.rc,w1.cnt+w2.cnt+(w1.rc==w2.lc)
		};
		//同样是关键的合并，同update函数操作 
	}
}sgtree;
void add(int a,int b,int pos){
	e[pos]=(Edge){b,fir[a]};fir[a]=pos;
}
//建边 
void swp(int& a,int& b){int t=a;a=b;b=t;}
//手写交换swap函数 
void all_cln(){
	//这个函数是掌管清空的，多组数据一定要小心！
	//建议：能清的都清了，免得出现什么奇怪的错误 
	ind=0;sgtree.cln();
	memset(sz,0,sizeof sz);
	memset(fa,0,sizeof fa);
	memset(idx,0,sizeof idx);
	memset(fir,0,sizeof fir);
	memset(son,0,sizeof son);
	memset(topf,0,sizeof topf);
	memset(deep,0,sizeof deep);
}
void dfs1(int x,int f,int d){
	deep[x]=d;fa[x]=f;sz[x]=1;
	for(int i=fir[x];i;i=e[i].nxt){
		int h=e[i].to;
		if(h!=f){
			dfs1(h,x,d+1);sz[x]+=sz[h];
			if(sz[h]>sz[son[x]])son[x]=h;
		}
	}
}
//树剖常规第一遍dfs 
void dfs2(int x,int tp){
	if(!x)return;topf[x]=tp;
	idx[x]=++ind;dfs2(son[x],tp);
	for(int i=fir[x];i;i=e[i].nxt){
		int h=e[i].to;if(h!=son[x]&&h!=fa[x])dfs2(h,h);
	}
}
//树剖常规第二遍dfs 
void range_update(int x,int y,int num){
	while(topf[x]!=topf[y]){
		int tx=topf[x],ty=topf[y];
		if(deep[tx]<deep[ty]){swp(x,y);swp(tx,ty);}
		sgtree.update(idx[tx],idx[x],1,n,1,num);
		x=fa[tx];
	}
	if(deep[x]<deep[y])swp(x,y);
	sgtree.update(idx[y],idx[x],1,n,1,num);
}
//树剖区间修改 
int range_query(int x,int y){
	//树剖的区间查询，可以说是整个程序的大核心，一定要深刻理解
	//建议画图辅助思考，会有一定难度 
	bool flg=0;//flg表示当前答案应归到哪边，0为ans1,1为ans2 
	Node h,ans1=(Node){0,0,0},ans2=(Node){0,0,0};
	while(topf[x]!=topf[y]){
		int tx=topf[x],ty=topf[y];
		if(deep[tx]<deep[ty]){flg=!flg;swp(tx,ty);swp(x,y);}
		//记得同时取反flg 
		h=sgtree.query(idx[tx],idx[x],1,n,1);
		//以下是最核心部分↓
		//请大家一定注意：每次的查询h，一定是左端点在深度小的地方，
		//右端点在深度大的地方，所以千万不能把左右端点合并错 
		if(flg)
		    ans2=(Node){
				h.lc,ans2.rc,ans2.cnt+h.cnt+(ans2.lc==h.rc)
			};
		//ans2情况 
		else
			ans1=(Node){
				ans1.lc,h.lc,ans1.cnt+h.cnt+(ans1.rc==h.rc)
			};
		//ans1情况 
		x=fa[tx];
	}
	if(deep[x]<deep[y]){swp(x,y);flg=!flg;}
	h=sgtree.query(idx[y],idx[x],1,n,1);
	if(flg)
	    ans2=(Node){
			h.lc,ans2.rc,ans2.cnt+h.cnt+(ans2.lc==h.rc)
		};
	else
		ans1=(Node){
			ans1.lc,h.lc,ans1.cnt+h.cnt+(ans1.rc==h.rc)
		};
	//末处理 
	return ans1.cnt+ans2.cnt+(ans1.rc==ans2.lc);
}
int main(){
	//freopen("edge.in","r",stdin);
    //freopen("edge.out","w",stdout);
	int data;scanf("%d",&data);
	for(int i=1;i<=data;i++){
		all_cln();//别忘了清空！！ 
		int m;scanf("%d%d",&n,&m);
		for(int j=1;j<n;j++){
			int a,b;scanf("%d%d",&a,&b);
			add(a,b,j);add(b,a,j+n-1);
		}
		dfs1(1,0,1);dfs2(1,1);
		for(int j=1;j<=n;j++)sgtree.update(idx[j],idx[j],1,n,1,-idx[j]);
		//上面这句也很重要，先把每个点起始赋一个互不相同的值，
		//随便你赋啥 
		for(int j=1;j<=m;j++){
		    int opt,a,b;
			scanf("%d%d%d",&opt,&a,&b);
			if(opt&1)range_update(a,b,j);
			//以询问编号j作为“独一无二的颜色” 
			else printf("%d\n",range_query(a,b));
		}
	}
	//fclose(stdin);
    //fclose(stdout);
	return 0;
}
```


这里，再给大家送一道题：
[P2486  染色](https://www.luogu.com.cn/problem/P2486)

这道题也是线段树信息维护的经典运用，和本题转化后基本类似，大家可以去试试哟。

谢谢大家！

---

## 作者：云浅知处 (赞：85)

我们可以把对「边」的询问转到「点」上！

具体来说，对于一条边 $(u,v)$，我们认为：

- 当 $\text{val}(u)=\text{val}(v)$ 时，$(u,v)$ 是一条**重边**=w=
- 否则，$(u,v)$ 就是一条**轻边**>_<

其中，$\text{val}(x)$ 表示点 $x$ 的权值，这个权值我们可以自己定义～

这样一来，修改操作就变成了：

- 设 $k$ 满足 $\forall x,\text{val}(x)\neq k$。
- 同时对于每个在路径 $u\rightsquigarrow v$ 上的点 $x$，将 $\text{val}(x)$ 修改为 $k$。

那么查询操作实际上也就变成了：查询区间内有多少个相邻的点对，满足这两个点的权值相同。

因此我们先做一次树剖转为区间问题，然后线段树维护即可=w=

具体地，对于线段树上的每个节点，我们维护一下这个节点的**左/右端的权值**以及**答案**，合并时只需要把左右儿子的答案加起来，然后特判一下「**左儿子的右端点**」与「**右儿子的左端点**」是否相同即可。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<vector>
#include<cstdio>

#define lson(o) (o<<1)
#define rson(o) (o<<1|1)
const int MN=1e5+5;

using namespace std;

int w[MN],val[MN],dfn[MN],sz[MN],fa[MN],top[MN],hson[MN],dep[MN];
vector<int>G[MN];

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

int dfs1(int u,int d){
    dep[u]=d,sz[u]=1,hson[u]=0;
    for(int i=0,s=G[u].size();i<s;i++){
        int to=G[u][i];
        if(to==fa[u])continue;
        fa[to]=u;
        sz[u]+=dfs1(to,d+1);
        if(sz[to]>sz[hson[u]])hson[u]=to;
    }
    return sz[u];
}

int tot=0;
void dfs2(int u,int tp){
    dfn[u]=++tot,top[u]=tp,val[dfn[u]]=w[u];
    if(hson[u])dfs2(hson[u],tp);
    for(int i=0,s=G[u].size();i<s;i++){
        int to=G[u][i];
        if(to==fa[u]||to==hson[u])continue;
        dfs2(to,to);
    }
}

struct SMT{
    
    int d[MN<<2],L[MN<<2],R[MN<<2],lz[MN<<2];//d 为此区间答案，L/R 表示左右端点，lz是懒标记。

    inline void pushup(int o){
        d[o]=d[lson(o)]+d[rson(o)]+(L[rson(o)]==R[lson(o)]);
        L[o]=L[lson(o)],R[o]=R[rson(o)];
    }

    inline void build(int l,int r,int o){
        lz[o]=0;
        if(l==r){
            d[o]=0;
            L[o]=R[o]=val[l];
            return ;
        }
        int mid=(l+r)>>1;
        build(l,mid,lson(o));
        build(mid+1,r,rson(o));
        pushup(o);
    }

    inline void pushdown(int ql,int qr,int o){
        if(!lz[o])return ;
        int mid=(ql+qr)>>1;
        d[lson(o)]=mid-ql,d[rson(o)]=qr-mid-1;
        lz[lson(o)]=lz[o],lz[rson(o)]=lz[o];
        L[lson(o)]=R[lson(o)]=L[rson(o)]=R[rson(o)]=lz[o];
        lz[o]=0;
    }

    inline int query(int l,int r,int ql,int qr,int o){
        if(l<=ql&&qr<=r)return d[o];
        pushdown(ql,qr,o);
        int mid=(ql+qr)>>1,ans=0;
        if(l<=mid)ans+=query(l,r,ql,mid,lson(o));
        if(r>mid)ans+=query(l,r,mid+1,qr,rson(o));
        if(l<=mid&&r>mid&&R[lson(o)]==L[rson(o)])ans++;
        return ans;
    }

    inline void modify(int l,int r,int k,int ql,int qr,int o){
        if(l<=ql&&qr<=r){
            L[o]=R[o]=lz[o]=k;
            d[o]=qr-ql;
            return ;
        }
        pushdown(ql,qr,o);
        int mid=(ql+qr)>>1;
        if(l<=mid)modify(l,r,k,ql,mid,lson(o));
        if(r>mid)modify(l,r,k,mid+1,qr,rson(o));
        pushup(o);
    }

    inline int kwii(int pos,int ql,int qr,int o){
        if(ql==qr)return L[o];
        pushdown(ql,qr,o);
        int mid=(ql+qr)>>1;
        if(pos<=mid)return kwii(pos,ql,mid,lson(o));
        else return kwii(pos,mid+1,qr,rson(o));
    }

};

SMT tree;
int n,m;

int cnt=0;
void change(int x,int y){
    ++cnt;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		tree.modify(dfn[top[x]],dfn[x],cnt,1,n,1);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	tree.modify(dfn[x],dfn[y],cnt,1,n,1);
}

int queryans(int x,int y){
    int res=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        res+=tree.query(dfn[top[x]],dfn[x],1,n,1);
        if(tree.kwii(dfn[fa[top[x]]],1,n,1)==tree.kwii(dfn[top[x]],1,n,1))res++;//这里需要特判一下链顶元素与其父亲是否相同
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])swap(x,y);
    res+=tree.query(dfn[x],dfn[y],1,n,1);
    return res;
}
 
void solve(){
    cnt=tot=0;
    n=read(),m=read();
    for(int i=1;i<=n;i++)w[i]=++cnt;//由于初始均为轻边，所以我们需要保证 w[i]!=w[j]，那么直接赋值成 1~n 就行了qwq

    for(int i=1;i<n;i++){
        int u=read(),v=read();
        G[u].push_back(v),G[v].push_back(u);
    }

    dfs1(1,1);
    dfs2(1,1);

    tree.build(1,n,1);

    while(m--){
        int op=read(),x=read(),y=read();
        if(op==1)change(x,y);
        if(op==2)cout<<queryans(x,y)<<endl;
    }

    for(int i=1;i<=n;i++)G[i].clear();
}

int _;

signed main(void){

    // freopen("edge.in","r",stdin);
    // freopen("edge.out","w",stdout);
    
    cin>>_;
    while(_--)solve();
 
    return 0;
}
```

那么就这样=w=

---

## 作者：ix35 (赞：47)

近五年 NOI 最难的 D1T1。

此前题解的做法有两种：LCT 以及转化为颜色段，但这两种做法都不是我首先想到的。

将题目里的“重儿子”称为关键儿子。

由于这题看起来就是签到题，直接上个树剖暴力维护，考虑修改时每条重链上做了什么：

链顶到当前点之间的部分（不包括当前点）的关键儿子有且仅有重儿子。

当前点：关键儿子仅有上一次的链顶（一个轻儿子）。

所以我们对每个点维护两个信息：

1. 重儿子是否是关键儿子。

2. 是否存在轻儿子是关键儿子，如果存在则记录。

一个点最多有两个关键儿子，所以 2. 中只需要记录两个。

然后修改和查询就是一些简单的线段树上区间操作，相信不用多说。

注意 LCA 父亲处的细节。

时间复杂度为 $O(n\log^2 n)$。

---

## 作者：jerry3128 (赞：27)

搞一个非常规的做法，用 LCT 的结构直接表示轻重边。

- 我们发现这个题目给出的操作十分像 LCT 的 access 操作，所以不免直接往这方面想。
- 我们要将一条链变为实链，常规的写法是换根到一个端点，再 access 另一个端点。这样可以取出我们的这条链来。
- 但是显然，在换根的时候我们调用了 access 一次，这次调用会直接让整个 LCT 与维护的轻重之间混乱，也就是说，我们不能使用换根操作。
- 考虑定根，如果要打通的一条链两个端点有父子关系，那是十分容易的。
- 考虑普遍情况，不妨设两个端点为 x 和 y 求出其 lca ，那么 lca 的两条重边都是连向儿子的。这也就是说 lca 一定没有连向父亲的重边，即 lca 一定是一条实链的链顶。
- 我们对于每个节点开一个“额外链” extra 表示它除了自己的实儿子是否有另外的向下的重边。这个 extra，容易发现只有每条实链的链顶的 extra 会有值。在 access 的时候直接清空就行了。
- 那么剩余部分的算法也大概出来了。我们每次打通一条实链，就是对于两个节点 lca 首先从实链分离，然后将两个儿子分别向上插实链直到最近公共祖先，记一边为实儿子，另一边记为额外链，将每个节点到根的重边数量按照 LCT 的结构改变直接维护出来。查询就是和 LCA 做差分即可。可以发现它没有破坏均摊分析。
- 然后就是一些细节的特判和实现细节，可以直接看代码。


```
//ayame保佑，夸哥保佑，狗妈保佑，MDR保佑，锉刀怪保佑，M99保佑，克爹保佑
#include<bits/stdc++.h>
using namespace std;
int p1=1000000,p2=0;
char buf[1000005],wb[1000005];
int gc() {
	if(p1>=1000000)fread(buf,1,1000000,stdin),p1=0;
	return buf[p1++];
}
#define gc getchar
#define Loli true
#define Kon xor true
long long getint() {
	long long ret=0,flag=1;
	char c=gc();
	while(c<'0'||c>'9') {
		if(c=='-')flag=-1;
		c=gc();
	}
	while(c<='9'&&c>='0') {
		ret=(ret<<3)+(ret<<1)+c-'0';
		c=gc();
	}
	return ret*flag;
}
void pc(char x) {
	if(p2>=1000000)fwrite(wb,1,1000000,stdout),p2=0;
	wb[p2++]=x;
}
void wrt(long long x) {
	if(x<0)pc('-'),x=-x;
	int c[24]= {0};
	if(!x)return pc('0'),void();
	while(x)c[++c[0]]=x%10,x/=10;
	while(c[0])pc(c[c[0]--]+'0');
}
int n,m;
vector<int> vec[100005];
int fa[100005],dep[100005];
int son[100005],sz[100005];
int tp[100005],rd[100005],cd[100005],sign;
int LCA(int x,int y){
	while(tp[x]^tp[y]){
		if(dep[tp[x]]<dep[tp[y]])swap(x,y);
		x=fa[tp[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	return x;
}
namespace T{
	#define lowbit(i) (i&(-i))
	int c[100005];
	void clear(){
		memset(c,0,sizeof(c));
	}
	void add(int pl,int val){
		for(int i=pl;i<=100000;i+=lowbit(i))c[i]+=val;
	}
	void add(int l,int r,int val){
		add(l,val),add(r+1,-val);
	}
	int ask(int pl){
		int ret=0;
		for(int i=pl;i;i-=lowbit(i))ret+=c[i];
		return ret;
	}
};
namespace LCT{
	struct node{
		int ch[2],fa,pre,suf,extra;
	}v[100005];
	bool isroot(int x){
		return v[v[x].fa].ch[0]!=x&&v[v[x].fa].ch[1]!=x;
	}
	void push_up(int rt){
		v[rt].pre=v[rt].ch[0]?v[v[rt].ch[0]].pre:rt;
		v[rt].suf=v[rt].ch[1]?v[v[rt].ch[1]].suf:rt;
	}
	void init(){
		T::clear();
		for(int i=1;i<=100000;i++)v[i].ch[0]=v[i].ch[1]=v[i].fa=v[i].pre=v[i].suf=v[i].extra=0,push_up(i);
	}
	void rot(int x){
		int p=v[x].fa,g=v[p].fa;
		bool d=v[p].ch[1]==x;
		if(!isroot(p))v[g].ch[v[g].ch[1]==p]=x;
		v[p].ch[d]=v[x].ch[d^1];
		v[v[x].ch[d^1]].fa=p;
		v[x].ch[d^1]=p;
		v[x].fa=g,v[p].fa=x;
		push_up(p),push_up(x);
	}
	void splay(int x){
		while(!isroot(x)){
			int p=v[x].fa,g=v[p].fa;
			if(!isroot(p))rot(v[g].ch[0]==p^v[p].ch[0]==x?x:p);
			rot(x);
		}
	}
	void ins(int x,int y){
		if(!y)return;
		T::add(rd[v[y].pre],cd[v[y].pre],-1);
	}
	void del(int x,int y){
		if(!y)return;
		T::add(rd[v[y].pre],cd[v[y].pre],1);
		if(v[v[y].pre].extra)T::add(rd[v[v[y].pre].extra],cd[v[v[y].pre].extra],-1),v[v[y].pre].extra=0;
	}
	void split(int x){
		splay(x);
		if(v[fa[x]].extra==x)T::add(rd[x],cd[x],-1),v[fa[x]].extra=0;
		if(v[x].extra)T::add(rd[v[x].extra],cd[v[x].extra],-1),v[x].extra=0;
		if(!v[x].ch[0])return;
		int y=v[v[x].ch[0]].suf;
		splay(y),v[y].ch[1]=0,push_up(y);
		T::add(rd[x],cd[x],-1);
	}
	void limit_access(int x,int Dep){
		for(int y=0;x;y=x,x=v[x].fa){
			splay(x),del(x,y),ins(x,v[x].ch[1]),v[x].ch[1]=y,push_up(x);
			if(dep[v[x].pre]==Dep)return;
		}
	}
	void expose(int x,int y){
		if(dep[x]<dep[y])swap(x,y);
		int lca=LCA(x,y);
		split(lca),limit_access(x,dep[lca]);
		if(y!=lca){
			splay(lca);int son=v[v[lca].ch[1]].pre;
			limit_access(y,dep[lca]),v[lca].extra=son,T::add(rd[son],cd[son],1);
		}
	}
	int ask(int x,int y){
		int lca=LCA(x,y);
		return T::ask(rd[x])+T::ask(rd[y])-2*T::ask(rd[lca]);
	}
}
void dfs1(int x,int prt){
	fa[x]=prt,dep[x]=dep[prt]+1,sz[x]=1;
	for(int y:vec[x])if(y!=prt)dfs1(y,x),sz[x]+=sz[y],son[x]=(sz[y]>sz[son[x]]?y:son[x]);
	LCT::v[x].fa=prt;
}
void dfs2(int x,int prt,int top){
	tp[x]=top,rd[x]=++sign;
	if(son[x])dfs2(son[x],x,top);
	for(int y:vec[x])if(y!=prt&&y!=son[x])dfs2(y,x,y);
	cd[x]=sign;
}
int main() {
//	system("fc edge.out edge5.ans");
	freopen("edge.in","r",stdin);
	freopen("edge.out","w",stdout);
	int Ti=getint();
	while(Ti--){
		for(int i=1;i<=n;i++)vec[i].clear();
		sign=0;
		memset(fa,0,sizeof(fa));
		memset(sz,0,sizeof(sz)),memset(son,0,sizeof(son));
		LCT::init();
		n=getint(),m=getint();
		for(int i=1;i<n;i++){
			int u=getint(),v=getint();
			vec[u].push_back(v),vec[v].push_back(u);
		}
		dfs1(1,0),dfs2(1,0,1);
		for(int i=1;i<=m;i++){
			int opt=getint(),x=getint(),y=getint();
			if(opt==1)LCT::expose(x,y);
			if(opt==2)wrt(LCT::ask(x,y)),pc('\n');
		}
	}
	fwrite(wb,1,p2,stdout);
	return Loli Kon;
}

```


- 虽然做法迥异，但对于每个人来说考场上还是擅长啥写啥，不要尝试剑走偏锋。（

---

## 作者：绝顶我为峰 (赞：24)

也许是近几年最简单的 NOI 题。

我们考虑转换一下题面，把 $1$ 操作看成链上染色，那么不难发现一条边变重以后两个端点的点权是相同的。同时这也是充要条件。

那么题意转化为：一棵树，支持链染色，查询链上相邻点颜色相同的个数。

不难发现要查询的内容可以用线段树维护，只要记录区间答案和左右端点的颜色即可合并。

修改是区间的，我们考虑怎样下传标记。显然区间推平后区间答案是 $len-1$（$len$ 是区间长度），左右端点修改成当前颜色即可。

有了这些就是一个树剖板子题了。

复杂度 $O(n\log^2n)$。

~~别忘了卡常。~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct edge
{
    int nxt,to;
}e[100001<<1];
struct tree
{
    int ans,l,r,tag,len;
    tree()
    {
        ans=l=r=tag=len=0;
    }
}t[100001<<2];
int T,n,m,tot,h[100001],dep[100001],fa[100001],s[100001],son[100001],id[100001],cnt,top[100001];
inline int read()
{
    register int x=0;
    register char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x;
}
void print(register int x)
{
    if(x>=10)
        print(x/10);
    putchar(x%10+'0');
}
inline void add(register int x,register int y)
{
    e[++tot].nxt=h[x];
    h[x]=tot;
    e[tot].to=y;
}
inline int ls(register int k)
{
    return k<<1;
}
inline int rs(register int k)
{
    return k<<1|1;
}
inline tree merge(register tree x,register tree y)
{
    tree res;
    res.ans=x.ans+y.ans;
    res.len=x.len+y.len;
    if(x.r==y.l)
        ++res.ans;
    res.l=x.l;
    res.r=y.r;
    return res;
}
inline void push_up(register int k)
{
    t[k]=merge(t[ls(k)],t[rs(k)]);
}
inline void push_down(register int k)
{
    if(t[k].tag)
    {
        t[ls(k)].ans=t[ls(k)].len-1;
        t[rs(k)].ans=t[rs(k)].len-1;
        t[ls(k)].l=t[ls(k)].r=t[rs(k)].l=t[rs(k)].r=t[ls(k)].tag=t[rs(k)].tag=t[k].tag;
        t[k].tag=0;
    }
}
void build(register int k,register int l,register int r)
{
    t[k].len=r-l+1;
    t[k].tag=t[k].ans=0;
    if(l==r)
    {
        t[k].l=t[k].r=l;
        return;
    }
    int mid=(l+r)>>1;
    build(ls(k),l,mid);
    build(rs(k),mid+1,r);
    push_up(k);
}
void update(register int nl,register int nr,register int l,register int r,register int k,register int p)
{
    if(l>=nl&&r<=nr)
    {
        t[k].ans=t[k].len-1;
        t[k].l=t[k].r=t[k].tag=p;
        return;
    }
    push_down(k);
    register int mid=(l+r)>>1;
    if(nl<=mid)
        update(nl,nr,l,mid,ls(k),p);
    if(nr>mid)
        update(nl,nr,mid+1,r,rs(k),p);
    push_up(k);
}
tree query(register int nl,register int nr,register int l,register int r,register int k)
{
    if(l>=nl&&r<=nr)
        return t[k];
    push_down(k);
    register int mid=(l+r)>>1;
    if(nr<=mid)
        return query(nl,nr,l,mid,ls(k));
    if(nl>mid)
        return query(nl,nr,mid+1,r,rs(k));
    return merge(query(nl,nr,l,mid,ls(k)),query(nl,nr,mid+1,r,rs(k)));
}
void dfs1(register int k,register int f,register int deep)
{
    dep[k]=deep;
    fa[k]=f;
    s[k]=1;
    son[k]=0;
    int maxson=-1;
    for(register int i=h[k];i;i=e[i].nxt)
    {
        if(e[i].to==f)
            continue;
        dfs1(e[i].to,k,deep+1);
        s[k]+=s[e[i].to];
        if(s[e[i].to]>maxson)
        {
            maxson=s[e[i].to];
            son[k]=e[i].to;
        }
    }
}
void dfs2(register int k,register int t)
{
    id[k]=++cnt;
    top[k]=t;
    if(!son[k])
        return;
    dfs2(son[k],t);
    for(register int i=h[k];i;i=e[i].nxt)
    {
        if(e[i].to==fa[k]||e[i].to==son[k])
            continue;
        dfs2(e[i].to,e[i].to);
    }
}
inline void up(register int x,register int y,register int p)
{
    while(top[x]^top[y])
    {
        if(dep[top[x]]<dep[top[y]])
            x^=y^=x^=y;
        update(id[top[x]],id[x],1,n,1,p);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])
        x^=y^=x^=y;
    update(id[x],id[y],1,n,1,p);
}
inline int LCA(register int x,register int y)
{
    while(top[x]^top[y])
    {
        if(dep[top[x]]<dep[top[y]])
            x^=y^=x^=y;
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])
        x^=y^=x^=y;
    return x;
}
inline int q(register int x,register int y)
{
    register tree res1,res2;
    register int lca=LCA(x,y);
    while(top[x]^top[lca])
    {
        res1=merge(query(id[top[x]],id[x],1,n,1),res1);
        x=fa[top[x]];
    }
    res1=merge(query(id[lca],id[x],1,n,1),res1);
    while(top[y]^top[lca])
    {
        res2=merge(query(id[top[y]],id[y],1,n,1),res2);
        y=fa[top[y]];
    }
    res2=merge(query(id[lca],id[y],1,n,1),res2);
    return res1.ans+res2.ans;
}
int main()
{
    freopen("edge.in","r",stdin);
    freopen("edge.out","w",stdout);
    T=read();
    while(T--)
    {
        n=read(),m=read();
        memset(e,0,sizeof e);
        memset(h,0,sizeof h);
        cnt=tot=0;
        for(register int i=1;i<n;++i)
        {
            register int x=read(),y=read();
            add(x,y);
            add(y,x);
        }
        dfs1(1,0,1);
        dfs2(1,1);
        build(1,1,n);
        for(register int i=1;i<=m;++i)
        {
            register int opt=read(),x=read(),y=read();
            if(opt==1)
                up(x,y,i+n);
            if(opt==2)
            {
                print(q(x,y));
                putchar('\n');
            }
        }
    }
    return 0;
}
```


---

## 作者：warzone (赞：19)

这道题就差没把 “LCT” 写到题面中去了。

很容易想到，对于操作 1 使用 LCT 维护。  
由势能分析得出，LCT（实链剖分）是匀摊 $\Theta(\log n)$ 的，因此复杂度正确。

但有如下两个问题：
- 2 操作没有切换边的虚实，暴力跳链的话复杂度会超。  
  因此在 LCT 基础上再做一次重链剖分用以回答询问。
- 一般的 LCT 打通实链依赖换根操作：先打通到根的实链，然后整条链作区间翻转。  
  其中“打通到根的实链”是 1 操作所不允许的，我们需要另辟蹊径。  
  具体地，通过重链剖分求出 LCA，然后再打通路径的两个端点到 LCA 的实链即可。  
  Q：那这样的话就有两条实链过 LCA 咯？  
  A：既然有两条实链，对每个点维护两个 splay 结点即可。

细节很多，具体看代码。

```cpp
/*
this code is made by warzone
2021-7-27 8:34
*/
#include<stdio.h>
#include<string.h>
typedef unsigned int word;
struct READ{//快读快写
    char c;
    inline READ(){c=getchar();}
    template<typename type>
    inline READ& operator >>(register type& num){
        for(;'0'>c||c>'9';c=getchar());
        for(num=0;'0'<=c&&c<='9';c=getchar())
            num=num*10+(c-'0');
        return *this;
    }
}cin;
word case_,n,m;
word head[100010],to[200010],next[200010];
word fa[100010],son[100010];
word floor[100010],size[100010];
word newid[100010],step;
inline void dfs1(word id){//重链剖分（找重儿子）
    size[id]=1,son[id]=0;
    for(register word i=head[id];i;i=next[i])
        if(to[i]!=fa[id]){
            floor[to[i]]=floor[id]+1;
            fa[to[i]]=id,dfs1(to[i]);
            size[id]+=size[to[i]];
            if(size[son[id]]<size[to[i]]) son[id]=to[i];
        }
}
inline void dfs2(word id){//重链剖分（重标号）
    newid[id]=++step;
    if(son[id]) size[son[id]]=size[id],dfs2(son[id]);
    for(register word i=head[id];i;i=next[i])
        if(to[i]!=fa[id]&&to[i]!=son[id])
            size[to[i]]=to[i],dfs2(to[i]);
}
struct BIT{//树状树组
    int sum[100010];
    inline void operator()(){
        memset(sum,0,sizeof(sum));}
    #define lowbit(x) ((x)&-(x))
    inline void operator()(
        register int id,register int num){
        for(;id<=n;id+=lowbit(id)) sum[id]+=num;}
    inline int operator()(register int id){
        register int ans=0;
        for(;id;id&=~lowbit(id)) ans+=sum[id];
        return ans;
    }
}tree;
struct splay{
    splay *l,*r,*fa;
}p[200010];
#define cyc(root,l,r) do{       \
    register splay *rt=root;    \
    register splay *l=rt->l;    \
    register splay *l##r=l->r;  \
    l->fa=rt->fa,(root)=l;      \
    l->r=rt,rt->fa=l;           \
    if(rt->l=l##r) l##r->fa=rt; \
}while(0)//splay 旋转
#define lcyc(root) cyc(root,l,r)
#define rcyc(root) cyc(root,r,l)
#define lsp(root)                           \
    if(rff->l==root->fa){                   \
        if(root->fa->l==root) lcyc(rff);    \
        else rcyc(rff->l);                  \
        lcyc(rff);                          \
    }else{                                  \
        if(root->fa->r==root) rcyc(rff);    \
        else lcyc(rff->r);                  \
        rcyc(rff);                          \
    }
#define pos(p) ((p)->fa->l==(p)? (p)->fa->l:(p)->fa->r)
inline void Splay(register splay *root){//splay 伸展操作
    while(root->fa)
        if(root->fa->fa)
            if(root->fa->fa->fa){
                register splay *&rff=pos(root->fa->fa);
                lsp(root);
            }else{
                register splay *rff=root->fa->fa;
                lsp(root);
            }
        else if(root->fa->l==root){
            root=root->fa;lcyc(root);}
        else{root=root->fa;rcyc(root);}
}
inline void eraser(word id){//抹去指定 splay 的实儿子
    if(Splay(p+id),p[id].r){
        register splay *top=p[id].r;
        for(;top->l;top=top->l);
        tree(newid[(top-p)>>1],-1);//答案 -1，计入树状树组
        p[id].r->fa=0,p[id].r=0;
    }
}
inline void erase(word id){//抹去指定结点的所有实边
    word u=id<<1,v=id<<1|1;
    eraser(u),eraser(v);
    if(p[u].l) tree(newid[id],-1),p[u].l->fa=0,p[u].l=0;
    if(p[v].l) tree(newid[id],-1),p[v].l->fa=0,p[v].l=0;
	//答案 -1,计入树状树组
}
inline void makeline(word id,word lca){
	//打通 id 到 lca 的实链（id!=lca）（核心）
    eraser(id<<1),eraser(id<<1|1);//切掉所有的实儿子
    register splay *root=p+(p[id<<1].l? id<<1:id<<1|1),*top;
	//要注意选择向上有实链的那条 splay
    for(top=root;top->l;top=top->l);
    while(eraser((id=top-p)^1),//跳虚边前要切掉其他的实儿子
        tree(newid[id>>=1],1),(id=fa[id])!=lca){//答案 +1，计入树状树组
        eraser(id<<1),eraser(id<<1|1);//切掉所有的实儿子
        register splay *next=p+(p[id<<1].l? id<<1:id<<1|1);
		//要注意选择向上有实链的那条 splay
        next->r=root,root->fa=next;
        for(top=root=next;top->l;top=top->l);
    }
    root->fa=p+(p[id<<1].r? id<<1|1:id<<1);
	//对于 lca 的两个 splay，选择没有实儿子的那个
    root->fa->r=root;
}
int main(){
    for(cin>>case_;case_;--case_){
        cin>>n>>m;
        memset(head,0,sizeof(head));
        for(register word i=1;i<n;++i){
            cin>>to[i<<1]>>to[i<<1|1];
            next[i<<1]=head[to[i<<1|1]];
            next[i<<1|1]=head[to[i<<1]];
            head[to[i<<1]]=i<<1|1;
            head[to[i<<1|1]]=i<<1;
        }
        dfs1(1),size[1]=1,step=0,dfs2(1);
        tree(),memset(p,0,sizeof(p));
        for(word opt,u,v;m;--m){
            cin>>opt>>u>>v;
            if(--opt){//重链剖分计算答案
                register word ans=0;
                while(size[u]!=size[v])
                    if(floor[size[u]]>floor[size[v]]){
                        ans+=tree(newid[u])-tree(newid[size[u]]-1);
                        u=fa[size[u]];
                    }else{
                        ans+=tree(newid[v])-tree(newid[size[v]]-1);
                        v=fa[size[v]];
                    }
                if(floor[u]>floor[v]) ans+=tree(newid[u])-tree(newid[v]);
                else ans+=tree(newid[v])-tree(newid[u]);
                printf("%u\n",ans);
            }else if(u==v) erase(u);
            else{
                word x=u,y=v;
                while(size[u]!=size[v])
                    if(floor[size[u]]>floor[size[v]]) u=fa[size[u]];
                    else v=fa[size[v]];
                word lca=floor[u]<floor[v]? u:v;
				//重链剖分求 lca
                erase(lca);
                if(x!=lca) makeline(x,lca);
                if(y!=lca) makeline(y,lca);
				//打通两端点到 lca 的实链
            }
        }
    }
    return 0;
}
```
除了 LCT 以外，本题还有一种 重链剖分 + 线段树区间赋值 维护 实链剖分 的解法，不过就不讲了。

---

## 作者：cyh_toby (赞：13)

提供一种魔改树链剖分的做法。

### 分析

把题中的重边看成边权 $1$，轻边看成边权 $0$。边权显然不太好处理，所以把每条边的边权变成儿子节点的点权。这时，一次修改相当于把路径上**所有的点以及它们的儿子**赋值为 $0$，再把路径上**除** **LCA** **外的点**赋值为 $1$。一次询问就是问路径上**除** **LCA** **外的点**的权值和。

容易想到树链剖分。但传统的树链剖分的编号原则是「重链编号连续、子树编号连续」，我们这里不需要维护子树信息，需要知道儿子的信息，所以比较自然想到，用某种方式使得「重链上所有点的儿子编号连续」。

如何实现呢？我的方法是，先按传统的方法把重链都分出来，然后类似于 BFS，建立一个队列，把以根节点为 $top$ 的重链塞进去。每次取出队头的重链，把这条重链上的点的儿子依次编号，然后把以这些儿子为 $top$ 的重链塞进队列。

此外，对每个点 $x$，再预处理出其所在的重链中，由 $x$ 向上/向下走能碰到的节点的儿子的编号最大/小值，就可以容易调用线段树的操作来实现儿子的赋值。

上述方案唯一的美中不足是，一条重链的 $top$ 与 $top$ 的重儿子编号可能不连续，所以对于链的操作，每次只能取出 $top$ 的重儿子往下的一段进行操作，再单独操作 $top$ 自己。这会导致常数比较大，大概是传统树剖的 $4-5$ 倍。

显然，与传统树剖的时间复杂度一样，为 $O(n \log^2 n)$。

考场上跑自己脚造的数据会超 $0.2s$ 左右，感觉常数巨大没希望了，但 CCF 的巨牛逼机子最大的点只跑了 $0.8s$，超赞。

### 代码

具体实现的时候可以不把链先赋值为 $0$，以减小常数。

考场上的核心代码，稍微修得好看了一点：

```cpp
struct SegT {
	int l, r, sum, tg;
	#define ls (p << 1)
	#define rs (p << 1 | 1)
} t[N<<2];
void build(int p, int l, int r) {
	t[p].l = l, t[p].r = r, t[p].sum = 0, t[p].tg = -1;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
}
inline void push_up(int p) { t[p].sum = t[ls].sum + t[rs].sum; }
inline void push_down(int p) {
	if (t[p].tg != -1) {
		t[ls].sum = t[p].tg * (t[ls].r - t[ls].l + 1), t[ls].tg = t[p].tg;
		t[rs].sum = t[p].tg * (t[rs].r - t[rs].l + 1), t[rs].tg = t[p].tg;
		t[p].tg = -1;
	}
}
void upd(int p, int l, int r, int v) {
	if (l <= t[p].l && t[p].r <= r) return t[p].sum = v * (t[p].r - t[p].l + 1), t[p].tg = v, void();
	int mid = (t[p].l + t[p].r) >> 1;
	push_down(p);
	if (l <= mid) upd(ls, l, r, v);
	if (r > mid) upd(rs, l, r, v);
	push_up(p);
}
int qry(int p, int l, int r) {
	if (l <= t[p].l && t[p].r <= r) return t[p].sum;
	int mid = (t[p].l + t[p].r) >> 1, res = 0;
	push_down(p);
	if (l <= mid) res += qry(ls, l, r);
	if (r > mid) res += qry(rs, l, r);
	return res;
}

int fa[N], siz[N], son[N], dep[N], tp[N];
int dfn[N], rk[N], sec;
int upmx[N], upmn[N], dwmx[N], dwmn[N];
vector<int> V[N];
int q[N], hd, tl;

void dfs1(int x, int ff, int dpt) {
	fa[x] = ff, dep[x] = dpt;
	siz[x] = 1, son[x] = 0;
	for (int i = g[x]; i; i = nxt[i]) {
		int y = v[i];
		if (y == fa[x]) continue;
		dfs1(y, x, dep[x] + 1);
		if (!son[x] || siz[y] > siz[son[x]]) son[x] = y;
		siz[x] += siz[y];
	}
}

void dfs2(int x) {
	if (!tp[x]) tp[x] = x;
	V[tp[x]].pb(x);
	for (int i = g[x]; i; i = nxt[i]) {
		int y = v[i];
		if (y == fa[x]) continue;
		if (y == son[x]) tp[y] = tp[x];
		dfs2(y);
	}
}

inline void upd0(int x, int y) {
	while (tp[x] != tp[y]) {
		if (dep[tp[x]] < dep[tp[y]]) swap(x, y);
		if (son[x]) upd(1, dfn[son[x]], dfn[son[x]], 0);
		if (dwmn[tp[x]] <= upmx[x]) upd(1, dwmn[tp[x]], upmx[x], 0);
		x = fa[tp[x]];
	}
	if (dep[x] < dep[y]) swap(x, y);
	if (son[x]) upd(1, dfn[son[x]], dfn[son[x]], 0);
	if (dwmn[y] <= upmx[x]) upd(1, dwmn[y], upmx[x], 0);
	upd(1, dfn[y], dfn[y], 0);
}

inline void upd1(int x, int y) {
	while (tp[x] != tp[y]) {
		if (dep[tp[x]] < dep[tp[y]]) swap(x, y);
		if (tp[x] != x) upd(1, dfn[son[tp[x]]], dfn[x], 1);
		upd(1, dfn[tp[x]], dfn[tp[x]], 1);
		x = fa[tp[x]];
	}
	if (dep[x] < dep[y]) swap(x, y);
	if (x != y) upd(1, dfn[son[y]], dfn[x], 1);
}

inline int qry(int x, int y) {
	int res = 0;
	while (tp[x] != tp[y]) {
		if (dep[tp[x]] < dep[tp[y]]) swap(x, y);
		if (tp[x] != x) res += qry(1, dfn[son[tp[x]]], dfn[x]);
		res += qry(1, dfn[tp[x]], dfn[tp[x]]);
		x = fa[tp[x]];
	}
	if (dep[x] < dep[y]) swap(x, y);
	if (x != y) res += qry(1, dfn[son[y]], dfn[x]);
	return res;
}

inline void init() {
	memset(g, 0, sizeof(g)), tot = 0;
	memset(tp, 0, sizeof(tp)), sec = 0;
	for (int i = 1; i <= n; i++) V[i].clear();
}

inline void solve() {
	n = rd(), m = rd();
	init();
	for (int i = 1; i < n; i++) {
		int x = rd(), y = rd();
		add(x, y), add(y, x);
	}
	for (int i = 1; i <= m; i++) {
		qs[i].op = rd(), qs[i].x = rd(), qs[i].y = rd();
	}
	if (n <= 5000 && m <= 5000) {
		sub1::main();
		return;
	}
	dfs1(1, 0, 0);
	dfs2(1);
	hd = tl = 0;
	q[tl++] = 1, dfn[1] = ++sec, rk[sec] = 1;
	while (hd != tl) {
		int x = q[hd++], len = V[x].size();
		for (int i = 1; i < len; i++) {
			int y = V[x][i];
			dfn[y] = ++sec, rk[sec] = y;
		}
		for (int i = 0; i < len; i++) {
			int y = V[x][i];
			upmx[y] = -inf, upmn[y] = inf;
			for (int j = g[y]; j; j = nxt[j]) {
				int z = v[j];
				if (z == fa[y]) continue;
				if (z == son[y]) continue;
				dfn[z] = ++sec, rk[sec] = z;
				q[tl++] = z;
				chkmax(upmx[y], dfn[z]);
				chkmin(upmn[y], dfn[z]);
			}
			dwmx[y] = upmx[y], dwmn[y] = upmn[y];
		}
		for (int i = 1; i < len; i++) {
			chkmax(upmx[V[x][i]], upmx[V[x][i-1]]);
			chkmin(upmn[V[x][i]], upmn[V[x][i-1]]);
		}
		for (int i = len - 2; i >= 0; i--) {
			chkmax(dwmx[V[x][i]], dwmx[V[x][i+1]]);
			chkmin(dwmn[V[x][i]], dwmn[V[x][i+1]]);
		}
	}
	build(1, 1, n);
	for (int i = 1; i <= m; i++) {
		int op = qs[i].op, x = qs[i].x, y = qs[i].y;
		if (op == 1) upd0(x, y), upd1(x, y);
		else printf("%d\n", qry(x, y));
	}
}
```

---

## 作者：MuYC (赞：9)

#### 题意

NOI2021 Day 1 T1

小 W 有一棵 $n$ 个结点的树，树上的每一条边可能是轻边或者重边。接下来你需要对树进行 $m$ 次操作，在所有操作开始前，树上所有边都是轻边。

操作有以下两种：

+ 1.给定两个点 $a$ 和 $b$，首先对于 $a$ 到 $b$ 路径上的所有点 $x$（包含 $a$ 和 $b$），你要将与 $x$ 相连的所有边变为轻边。然后再将 $a$ 到 $b$ 路径上包含的所有边变为重边。

+ 2.给定两个点 $a$ 和 $b$，你需要计算当前 $a$ 到 $b$ 的路径上一共包含多少条重边。

#### Solution

重振树剖系列（ 不要 LCT 不要 LCT

如果我们把操作一看成对点染色，每次染色的颜色都不同。

+ 一条边是重边当且仅当它的两个端点都有颜色并且颜色相同。稍微画个图就能理解。证明很容易。

有了上面的性质，可以考虑用树剖来处理这个问题了（大佬们看到这里就可以不用看了）。

对于树剖处理路径的时候，提出来的每一个连续 dfn 段一定是对应了原树上的一条链（这个在我们最后合并答案的时候要用，mark 一下）

然后我们考虑线段树维护一个 dfn 区间的答案，这个只需要在合并左右儿子的时候判断**左儿子**代表的区间的右端点和**右儿子**代表的区间左端点颜色是否相同然后加上左右儿子的答案即可轻松维护。

每次修改相当于区间覆盖染色，对应的可以简单维护。

#### 处理询问：

因为每次我们的树剖会将一条链 dfn 序分成 $O(\log)$ 段，同时每一段我们可以像前面维护线段树一样获得答案，如法炮制即可，复杂度 $O(\log n)$，处理 $O(\log n)$ 段的复杂度就是 $O(\log^2n)$。

然后这 $O(\log n)$ 段 dfn 序连续段代表的不同链的端点肯定会存在有父子关系，然后就暴力枚举判断父子关系判断即可做到 $O(\log^2n)$，用 sort 是不是可以做到 $O(\log n \log \log n)$ ？

总时间复杂度:$O(q \log^2 n)$，空间复杂度 $O(4 \times n)$

这个做法主要难度在于发现上面重边的性质。（想了 20 min，调了 3 h，我太菜了）

#### 恶臭的Code

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}
const int MAXN = 1e5 + 50;
int n, m, start[MAXN], tot, Nowid;
int siz[MAXN], dep[MAXN], fa[MAXN][20];
int tp[MAXN], son[MAXN], dfn[MAXN], dfn_id[MAXN], lst = 0;
int tack[MAXN][2], CL[MAXN][2], Cnt = 0;
struct SegmentTree {
    int ls, rs, l, r, sum, tag;
} T[MAXN << 2];
struct Edge {
    int next, to;
} edge[MAXN << 1];
void add(int from, int to) {
    edge[++ tot] = (Edge) { start[from], to } ;
    start[from] = tot;
}
void DFS(int x, int from) {
    fa[x][0] = from, dep[x] = dep[from] + 1;
    siz[x] = 1, son[x] = 0;
    for(int i = start[x] ; i ; i = edge[i].next) {
        int to = edge[i].to;
        if(to == from) continue;
        DFS(to, x); siz[x] += siz[to];
        if(siz[to] > siz[son[x]]) son[x] = to;
    }
    return ;
}
void DFS2(int x, int top) {
    tp[x] = top, dfn[x] = ++ Nowid, dfn_id[Nowid] = x;
    if(son[x]) DFS2(son[x], top);
    for(int i = start[x] ; i ; i = edge[i].next) {
        int to = edge[i].to;
        if(to == fa[x][0] || to == son[x]) continue;
        DFS2(to, to);
    }
    return ;
}
inline void update(int x) {
    T[x].sum = T[x << 1].sum + T[x << 1 | 1].sum;
    if(T[x << 1].rs == T[x << 1 | 1].ls && T[x << 1].rs != 0) T[x].sum ++;
    T[x].ls = T[x << 1].ls;
    T[x].rs = T[x << 1 | 1].rs;
    return ;
}
inline void build(int x, int l, int r) {
    T[x].l = l, T[x].r = r;
    T[x].ls = T[x].rs = T[x].sum = T[x].tag = 0;
    int mid = (l + r) >> 1;
    if(l == r) return ;
    build(x << 1, l, mid);
    build(x << 1 | 1, mid + 1, r);
    return ;
}
inline void ad(int x, int col) {
    T[x].tag = T[x].ls = T[x].rs = col;
    T[x].sum = T[x].r - T[x].l;
    return ;
}
inline void pushdown(int x) {
    if(!T[x].tag) return ;
    ad(x << 1, T[x].tag), ad(x << 1 | 1, T[x].tag);
    T[x].tag = 0; return ;
}
inline void change(int x, int l, int r, int id) {
    int mid = (T[x].l + T[x].r) >> 1;
    if(T[x].l >= l && T[x].r <= r) { ad(x, id); return ; }
    pushdown(x);
    if(l <= mid) change(x << 1, l, r, id);
    if(r  > mid) change(x << 1 | 1, l, r, id);
    update(x);
    return ;
}
inline void ChangeR(int u, int v, int id) {
    int x = u, y = v;
    while(tp[x] != tp[y]) {
        if(dep[tp[x]] < dep[tp[y]]) swap(x, y);
        change(1, dfn[tp[x]], dfn[x], id);
        x = fa[tp[x]][0];
    }
    int Min = min(dfn[x], dfn[y]), Max = max(dfn[x], dfn[y]);
    change(1, Min, Max, id);
    return ;
}
inline int Get(int x, int l, int r) {
    if(T[x].l >= l && T[x].r <= r) {
        int res = T[x].sum + (lst == T[x].ls && lst != 0);
        lst = T[x].rs;
        return res;
    }
    pushdown(x);
    int mid = (T[x].l + T[x].r) >> 1, res = 0;
    if(l <= mid) res += Get(x << 1, l, r);
    if(r  > mid) res += Get(x << 1 | 1, l, r);
    update(x);
    return res;
}
inline int Getcol(int x, int pos) {
    if(T[x].l == pos && T[x].r == pos) return T[x].tag;
    pushdown(x);
    int mid = (T[x].l + T[x].r) >> 1;
    if(pos <= mid) return Getcol(x << 1, pos);
    else return Getcol(x << 1 | 1, pos);
}
inline void GetR(int u, int v) {
    int x = u, y = v, Ans = 0; Cnt = 0;
    while(tp[x] != tp[y]) {
        if(dep[tp[x]] < dep[tp[y]]) swap(x, y);
        tack[++ Cnt][0] = dfn[tp[x]];
        tack[Cnt][1] = dfn[x];
        x = fa[tp[x]][0];
    }
    int Min = min(dfn[x], dfn[y]), Max = max(dfn[x], dfn[y]);
    tack[++ Cnt][0] = Min, tack[Cnt][1] = Max;
    for(int i = 1 ; i <= Cnt ; i ++) {
        lst = 0;
        int res = Get(1, tack[i][0], tack[i][1]);
        Ans += res;
    }
    for(int i = 1 ; i <= Cnt ; i ++) {
        CL[i][0] = Getcol(1, tack[i][0]);
        CL[i][1] = Getcol(1, tack[i][1]);
    }
    for(int i = 1 ; i <= Cnt ; i ++) {
        for(int j = 1 ; j <= Cnt ; j ++) {
            if(i == j) continue;
            if(fa[dfn_id[tack[j][0]]][0] == dfn_id[tack[i][1]]) {
                Ans += (CL[j][0] == CL[i][1] && CL[j][0] != 0);
                continue;
            }
            if(fa[dfn_id[tack[j][0]]][0] == dfn_id[tack[i][0]])
                Ans += (CL[j][0] == CL[i][0] && CL[j][0] != 0);
        }
    }
    printf("%d\n", Ans);
    return ;
}

int main() {
    int TestCases = read();
    while(TestCases --){
        n = read(), m = read(), tot = 0, Nowid = 0;
        for(int i = 1 ; i <= n ; i ++) start[i] = 0;
        for(int i = 2 ; i <= n ; i ++) {
            int u = read(), v = read();
            add(u, v), add(v, u);
        }
        DFS(1, 0), DFS2(1, 1), build(1, 1, n);
        for(int i = 1 ; i <= m ; i ++) {
            int op = read(), u = read(), v = read();
            if(op == 1) ChangeR(u, v, i);
            else GetR(u, v);
        }
    }
    return 0;
}
```



---

## 作者：约瑟夫用脑玩 (赞：9)

考场怒刚 4h+ 才搞出来，思路简单就没多想，~~就是我自己毒瘤自己~~。

首先我们把 1 定为根，把每条边看作儿子到父亲的边，然后放在儿子上。

操作 1 分为两部分，一部分是儿子权值清空，一部分是链赋值。

链赋值不多说，儿子清零比较难做，~~但 jerry3128 随手就能口胡出毛毛虫修改做法~~。

我的做法就十分 naive，把树直接丢到 LCT 里面，链赋值就是 Splay 子树赋值，儿子清空的话打个标记就行。

只需考虑虚儿子被清掉的情况，如果是实儿子一定是一条链上被赋值了而且没被改过。

于是在 Access 的时候判一下和上次的标记是否相同，再把这次的标记打下去即可。

为了实际意义，同时也为了好写，我动用了不换根的 LCT，~~然而更 TM 难写了~~。

只有平凡的 LCT，我的时间复杂度 $O(n\log^2{n})$，但是加个标记就可以轻易做到 $O(n\log{n})$。

只放 LCT 了，主函数啥都没有，考场代码，慎看：

```
namespace LCT
{
	int tot,sn[2][Mx+5],pr[Mx+5],sm[Mx+5],sz[Mx+5],vl[Mx+5],tg[Mx+5],cg[Mx+5],ft[Mx+5];
	int lc[Mx+5];
	#define ls(x) sn[0][x]
	#define rs(x) sn[1][x]
	inline void Clr(int x)
	{
		int i;
		for(i=0;i<=x;i++)
		{
			ls(i)=rs(i)=pr[i]=sm[i]=sz[i]=vl[i]=tg[i]=cg[i]=ft[i]=0;
			lc[i]=0;
		}
		tot=0;
	}
	inline void Up(int x)
	{
		sm[x]=sm[ls(x)]+sm[rs(x)]+vl[x];
		sz[x]=sz[ls(x)]+sz[rs(x)]+1;
		lc[x]=ls(x)?lc[ls(x)]:x;
	}
	inline void cng(int x,int t)
	{
		if(!x)return;
		cg[x]=vl[x]=1;tg[x]=t;
		sm[x]=sz[x];
	}
	inline void Dn(int x)
	{
		if(cg[x])
		{
			cng(ls(x),tg[x]);cng(rs(x),tg[x]);
			cg[x]=0;
		}
	}
	inline int Sn(int x)
	{
		return rs(pr[x])==x;
	}
	inline int Ck(int x)
	{
		return ls(pr[x])==x||Sn(x);
	}
	inline void Rtt(int x)
	{
		int y=pr[x],z=pr[y],l=Sn(x),r=l^1,p=sn[r][x],ch=Sn(y);
		if(Ck(y))
		{
			sn[ch][z]=x;
		}sn[r][x]=y;sn[l][y]=p;
		if(p)
		{
			pr[p]=y;
		}pr[y]=x;pr[x]=z;
		Up(y);Up(x);
	}
	int top,stk[Mx+5];
	inline void Pre_Dn(int x)
	{
		for(;Ck(x);stk[++top]=x,x=pr[x])if(top>Mx)exit(666);
		for(stk[++top]=x;top;Dn(stk[top--]));
	}
	inline void Spy(int x)
	{
		int y;
		for(Pre_Dn(x);Ck(x);Rtt(x))
		{
			if(Ck(y=pr[x]))
			{
				Rtt(Sn(x)==Sn(y)?y:x);
			}
		}
	}
	inline void Acs(int x)
	{
		int y;
		for(y=0;x;x=pr[y=x])
		{
			Spy(x);
			int tp=rs(x);
			if(y)
			{
				if(ft[lc[y]]<tg[x])Spy(y=lc[y]),vl[y]=0,ft[y]=tg[x],Up(y);
			}
			rs(x)=y;
			if(tp)ft[lc[tp]]=tg[x];
			Up(x);
		}
	}
	inline void Cng_Acs(int x)
	{
		int y;++tot;
		for(y=0;x;x=pr[y=x])
		{
			Spy(x);
			int tp=rs(x);
			if(!pr[x])ft[lc[rs(x)]]=tot,cng(rs(x),tot);
			if(y)
			{
				if(ft[lc[y]]<tg[x])Spy(y=lc[y]),vl[y]=0,ft[y]=tg[x],Up(y);
			}
			rs(x)=y;
			if(tp&&pr[x])ft[lc[tp]]=tg[x];
			Up(x);
		}
		tg[y]=tot;
		cng(rs(y),tot);
		vl[y]=0;Up(y);
	}
	inline void Cng(int x,int y)
	{
		Acs(x);Cng_Acs(y);
	}
	inline int Ask_Acs(int x)
	{
		int y,s=0;
		for(y=0;x;x=pr[y=x])
		{
			Spy(x);
			int tp=rs(x);
			s=sm[rs(x)];
			if(y)
			{
				if(ft[lc[y]]<tg[x])Spy(y=lc[y]),vl[y]=0,ft[y]=tg[x],Up(y);
			}
			rs(x)=y;
			if(tp)ft[lc[tp]]=tg[x];
			Up(x);
		}
		return s+sm[rs(y)];
	}
	inline int Ask(int x,int y)
	{
		Acs(x);
		return Ask_Acs(y);
	}
}
```

Upd:jerry3128 把我复杂度假掉了，原因是我偷懒把虚儿子清空时 Splay 了一下，需要用标记下传，复杂度才对。jerry3128 现身说法很好改！我就懒得改了。。。

Upd:复杂度证出来了，就是 $O(n\log^2{n})$ 没跑了。。。~~而且怎么还没审啊~~

---

## 作者：x7103 (赞：8)

同步发表于 [$\texttt{Cnblogs}$](https://www.cnblogs.com/VCLS01/p/15063614.html)。

大家好，我是 $\texttt{NOI2020 D1T3}$ 的题目。
## 题目描述

给出一棵 $n$ 个节点的树。树上的边有轻重之分，开始时，所有边均为轻边。

有 $m$ 次操作，每次操作给定 $op,a,b$：

 - $op=1$，将 $a,b$ 最短路径上的边赋为重边，与 $a,b$ 最短路径上的点相连的其他边赋为轻边。
 - $op=2$，求 $a,b$ 最短路径上重边的个数。

保证 $a\neq b$。

**数据范围：**$n,m\le 10^5$。

**时间限制：**$1000\text{ms}$。

## Solution 1

容易想到一个非常经典的做法。

用树剖或 $\texttt{Link-Cut-Tree}$ 维护时间戳，时间戳相同为重边，不同为轻边，可以转化为统计颜色段数，具体可以参考 [$\texttt{SDOI 2011}$ 染色](https://www.luogu.com.cn/problem/P2486)。

时间复杂度为 $O(Tn\log^2 n)$ 或 $O(Tn\log n)$，~~但没写~~。

## Solution 2

直接树剖暴力修改，每次修改时注意统计链上下部分的轻重划分，查询时特判链上下端的值。

时间复杂度为 $O(Tn\log^2 n)$，可能需要卡常，~~写了也没调出来~~。

## Code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define lc (u<<1)
#define rc (u<<1|1)
using namespace std;
const int maxn=100010;
int Fir[maxn],Nxt[maxn<<1],Too[maxn<<1],tot=1;
int son[maxn],fa[maxn],dep[maxn],top[maxn],n,m,dfn[maxn],Times,siz[maxn];
template<class T>inline void read(T &x){
	x=0;char c;
	do c=getchar();while(c<'0'||c>'9');
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
}
int wrt[100],wrtop;
template<class T>inline void write(T x,char c){
	if(!x)putchar('0');
	wrtop=0;while(x)wrt[++wrtop]=x%10,x/=10;
	while(wrtop)putchar(wrt[wrtop--]+'0');
	putchar(c);
}
inline void add(int a,int b){
	Too[++tot]=b;Nxt[tot]=Fir[a];Fir[a]=tot;
}
inline void Init(){
	memset(Fir,0,sizeof(Fir));tot=1;
	memset(son,0,sizeof(son));Times=0;
}
struct SegmentTree{
	int l,r,v,tag,tim;
}tr[maxn<<2];
inline void change(int u,int d,int tim){
	if(d)tr[u].tag=d;
	if(d==1)tr[u].v=tr[u].r-tr[u].l+1;
	else if(d==-1)tr[u].v=0;
	if(tim)tr[u].tim=tim;
}
inline void pushdown(int u){
	change(lc,tr[u].tag,tr[u].tim);change(rc,tr[u].tag,tr[u].tim);tr[u].tag=tr[u].tim=0;
}
inline void pushup(int u){
	tr[u].v=tr[lc].v+tr[rc].v;
}
inline void build(int u,int l,int r){
	tr[u].l=l;tr[u].r=r;tr[u].tim=tr[u].tag=tr[u].v=0;if(l==r)return;
	int mid=(l+r)>>1;build(lc,l,mid);build(rc,mid+1,r);
}
inline void modify(int u,int l,int r,int d,int tim){
	if(l<=tr[u].l&&tr[u].r<=r){change(u,d,tim);return;}
	pushdown(u);
	int mid=(tr[u].l+tr[u].r)>>1;
	if(l<=mid)modify(lc,l,r,d,tim);
	if(mid<r) modify(rc,l,r,d,tim);
	pushup(u);
}
inline int query(int u,int l,int r){
	if(l<=tr[u].l&&tr[u].r<=r)return tr[u].v;
	pushdown(u);
	int mid=(tr[u].l+tr[u].r)>>1,ans=0;
	if(l<=mid)ans=query(lc,l,r);
	if(mid<r)ans+=query(rc,l,r);
	return ans;
}
inline int querytim(int u,int x){
	if(tr[u].l==tr[u].r)return tr[u].tim;
	pushdown(u);
	int mid=(tr[u].l+tr[u].r)>>1;
	if(x<=mid)return querytim(lc,x);
	else return querytim(rc,x);
}
inline void dfs1(int u,int f){
	fa[u]=f;dep[u]=dep[f]+1;siz[u]=1;
	for(int i=Fir[u];i;i=Nxt[i]){
		int v=Too[i];
		if(v!=f){
			dfs1(v,u);
			siz[u]+=siz[v];
			if(siz[v]>siz[son[u]])son[u]=v;
		}
	}
}
inline void dfs2(int u,int tp){
	dfn[u]=++Times;top[u]=tp;
	if(son[u])dfs2(son[u],tp);
	for(int i=Fir[u];i;i=Nxt[i]){
		int v=Too[i];
		if(v!=fa[u]&&v!=son[u])dfs2(v,v);
	}
}
inline void add(int x,int y,int tim){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		if(son[x])modify(1,dfn[son[x]],dfn[son[x]],-1,0);
		modify(1,dfn[top[x]],dfn[x],1,tim);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	if(son[y]&&dep[son[y]]<=dep[x])modify(1,dfn[son[y]],dfn[x],1,tim);
	modify(1,dfn[y],dfn[y],-1,tim);
	if(son[x])modify(1,dfn[son[x]],dfn[son[x]],-1,0);
}
inline int ask(int x,int y,int tim){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		if(fa[top[x]]){
			int ft=querytim(1,dfn[fa[top[x]]]);
			int tt=querytim(1,dfn[top[x]]);
			if(tt&&ft&&tt<ft)modify(1,dfn[top[x]],dfn[top[x]],-1,0);
		}
		ans+=query(1,dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	if(son[y]&&dep[son[y]]<=dep[x])ans+=query(1,dfn[son[y]],dfn[x]);
	return ans;
}
inline void solve(){
	dfs1(1,1);dfs2(1,1);build(1,1,n);
	for(int i=1;i<=m;++i){
		int op,a,b;read(op);read(a);read(b);
		if(op==1)add(a,b,i);
		else write(ask(a,b,i),'\n');
	}
}
int main(){
	int T;read(T);
	while(T--){
		read(n);read(m);
		Init();
		for(int i=1;i<n;++i){int u,v;read(u);read(v);add(u,v);add(v,u);}
		solve();
	}
	return 0;
}
```

---

## 作者：Sol1 (赞：5)

写个题解纪念一下我在这场 noi 唯一过掉的一题吧（大概率是）。

~~首先看这个修改非常 lct，然而我不会 lct 所以再见吧。~~

既然 lct 不行那么就考虑树链剖分。

树剖不好维护边权，不妨把 $(u,v)$ 的权值下放到深度更大的点上。

这时，对于重链上的边，可以直接使用线段树来支持区间赋值区间求和。考虑轻边怎么做。

考虑拆分操作，对于 $u,v$，可以拆为如下两个操作：

- 对 $(u,v)$ 上所有点，将所有相邻的边变轻。
- 对 $(u,v)$ 上所有点，将其连向父亲的边变重。

到对于每一条边，其权值改变有可能由如下三种修改决定：

- 一个端点被进行了“将所有相邻的边变轻”操作。
- 深度较深的点被进行了“将连向父亲的边变重”操作。

对于每一个点，维护一个 $t_{u,0}$ 表示 **这个点最后一次被进行操作“将所有相邻的边变轻”的时间**，和一个 $t_{u,1}$ 表示 **这个点最后一次被进行操作“将连向父亲的边变重”的时间**。

然后对于不是链头的点 $u$，其 $t_{u,1}$ 的值不会被用到，但是 $t_{u,0}$ 可能被用到，所以 $t_{u,0}$ 需要使用线段树支持区间对一个数取 max 以及单点求值，而 $t_{u,1}$ 直接用数组维护即可。

总复杂度 $O(Tq\log^2n)$，常数一般。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[(1<<21)+5], *p1 = buf, *p2 = buf;

inline int qread() {
	char c = getchar();
	int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

const int N = 100005;
struct Edge {
	int to, nxt;
	Edge() {
		nxt = -1;
	}
};
Edge e[N << 1];
int n, hd[N], pnt, siz[N], son[N], top[N], dfn[N], fa[N], dep[N], _time, tag1[N], q;

struct Segtree_tag0 {
	int tag[N << 2];
	inline void Modify(int p, int pl, int pr, int l, int r, int v) {
		if (l > r) return;
		if (pl == l && pr == r) {
			tag[p] = max(tag[p], v);
			return;
		}
		int mid = pl + pr >> 1;
		if (mid >= r) Modify(p << 1, pl, mid, l, r, v);
		else if (mid + 1 <= l) Modify(p << 1 | 1, mid + 1, pr, l, r, v);
		else {
			Modify(p << 1, pl, mid, l, mid, v);
			Modify(p << 1 | 1, mid + 1, pr, mid + 1, r, v);
		}
	}
	inline int Query(int p, int pl, int pr, int idx) {
		if (pl == pr) return tag[p];
		int mid = pl + pr >> 1;
		if (idx <= mid) return max(tag[p], Query(p << 1, pl, mid, idx));
		else return max(tag[p], Query(p << 1 | 1, mid + 1, pr, idx));
	}
	inline void Clear() {
		memset(tag, 0, sizeof(tag));
	}
};
Segtree_tag0 sgt1;

struct Segtree_Edge {
	int sum[N << 2], tag[N << 2];
	inline void Clear() {
		memset(sum, 0, sizeof(sum));
		memset(tag, -1, sizeof(tag));
	}
	inline void Pushdown(int p, int pl, int pr) {
		if (tag[p] < 0) return;
		int mid = pl + pr >> 1;
		sum[p << 1] = tag[p] * (mid - pl + 1);
		tag[p << 1] = tag[p];
		sum[p << 1 | 1] = tag[p] * (pr - mid);
		tag[p << 1 | 1] = tag[p];
		tag[p] = -1;
	}
	inline void Modify(int p, int pl, int pr, int l, int r, int v) {
		if (l > r) return;
		//if (p == 1) printf("[%d,%d] %d\n", l, r, v);
		if (pl == l && pr == r) {
			tag[p] = v;
			sum[p] = (pr - pl + 1) * v;
			return;
		}
		Pushdown(p, pl, pr);
		int mid = pl + pr >> 1;
		if (mid >= r) Modify(p << 1, pl, mid, l, r, v);
		else if (mid + 1 <= l) Modify(p << 1 | 1, mid + 1, pr, l, r, v);
		else {
			Modify(p << 1, pl, mid, l, mid, v);
			Modify(p << 1 | 1, mid + 1, pr, mid + 1, r, v);
		}
		sum[p] = sum[p << 1] + sum[p << 1 | 1];
	}
	inline int Query(int p, int pl, int pr, int l, int r) {
		if (l > r) return 0;
		if (pl == l && pr == r) return sum[p];
		Pushdown(p, pl, pr);
		int mid = pl + pr >> 1;
		if (mid >= r) return Query(p << 1, pl, mid, l, r);
		else if (mid + 1 <= l) return Query(p << 1 | 1, mid + 1, pr, l, r);
		else return Query(p << 1, pl, mid, l, mid) + Query(p << 1 | 1, mid + 1, pr, mid + 1, r);
	}
};
Segtree_Edge sgt2;

inline void Clear() {
	memset(hd, -1, sizeof(hd));
	pnt = 0;
	sgt1.Clear();
	sgt2.Clear();
	memset(tag1, -1, sizeof(tag1));
	n = 0; q = 0;
	memset(siz, 0, sizeof(siz));
	memset(son, 0, sizeof(son));
	memset(top, 0, sizeof(top));
	memset(dfn, 0, sizeof(dfn));
	memset(fa, 0, sizeof(fa));
	memset(dep, 0, sizeof(dep));
	_time = 0;
}

inline void AddEdge(int u, int v) {
	e[++pnt].to = v;
	e[pnt].nxt = hd[u];
	hd[u] = pnt;
}

inline void Read() {
	n = qread(); q = qread();
	for (int i = 1;i < n;i++) {
		int u = qread(), v = qread();
		AddEdge(u, v);
		AddEdge(v, u);
	}
}

inline void Dfs1(int u) {
	siz[u] = 1;
	for (int i = hd[u];~i;i = e[i].nxt) {
		if (e[i].to != fa[u]) {
			fa[e[i].to] = u;
			dep[e[i].to] = dep[u] + 1;
			Dfs1(e[i].to);
			siz[u] += siz[e[i].to];
			if (siz[e[i].to] > siz[son[u]]) son[u] = e[i].to; 
		}
	}
}

inline void Dfs2(int u, int tp) {
	top[u] = tp;
	dfn[u] = ++_time;
	if (son[u]) Dfs2(son[u], tp);
	for (int i = hd[u];~i;i = e[i].nxt) {
		if (e[i].to != fa[u] && e[i].to != son[u]) Dfs2(e[i].to, e[i].to);
	}
}

inline void Modify0(int u, int v, int modidx) {
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		sgt1.Modify(1, 1, n, dfn[top[u]], dfn[u], modidx);
		if (son[u]) sgt2.Modify(1, 1, n, dfn[top[u]] + 1, dfn[u] + 1, 0);
		else sgt2.Modify(1, 1, n, dfn[top[u]] + 1, dfn[u], 0);
		u = fa[top[u]];
	}
	if (dfn[u] > dfn[v]) swap(u, v);
	sgt1.Modify(1, 1, n, dfn[u], dfn[v], modidx);
	if (top[u] == u) {
		if (son[v]) sgt2.Modify(1, 1, n, dfn[u] + 1, dfn[v] + 1, 0);
		else sgt2.Modify(1, 1, n, dfn[u] + 1, dfn[v], 0);
	} else {
		if (son[v]) sgt2.Modify(1, 1, n, dfn[u], dfn[v] + 1, 0);
		else sgt2.Modify(1, 1, n, dfn[u], dfn[v], 0);
	}
}

inline void Modify1(int u, int v, int modidx) {
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		sgt2.Modify(1, 1, n, dfn[top[u]] + 1, dfn[u], 1);
		tag1[top[u]] = modidx;
		u = fa[top[u]];
	}
	if (dfn[u] > dfn[v]) swap(u, v);
	//if (top[u] != u) sgt2.Modify(1, 1, n, dfn[u], dfn[v], 1);
	//else {
		sgt2.Modify(1, 1, n, dfn[u] + 1, dfn[v], 1);
	//	tag1[u] = modidx;
	//}
}

inline int Query(int u, int v) {
	int ans = 0;
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		ans += sgt2.Query(1, 1, n, dfn[top[u]] + 1, dfn[u]);
		int t0 = max(sgt1.Query(1, 1, n, dfn[top[u]]), sgt1.Query(1, 1, n, dfn[fa[top[u]]]));
		int t1 = tag1[top[u]];
		if (t1 > t0) ans++;
		u = fa[top[u]];
	}
	//printf("u=%d v=%d ans=%d\n", u, v, ans);
	if (dfn[u] > dfn[v]) swap(u, v);
	ans += sgt2.Query(1, 1, n, dfn[u] + 1, dfn[v]);
	return ans;
}

inline void Solve() {
	for (int i = 1;i <= q;i++) {
		int opt = qread(), u = qread(), v = qread();
		if (opt == 1) {
			Modify0(u, v, 2 * i - 1);
			Modify1(u, v, 2 * i);
		} else printf("%d\n", Query(u, v));
	}
}

int main() {
	int t = qread();
	while (t--) {
		Clear();
		Read();
		dep[1] = 1;
		Dfs1(1);
		Dfs2(1, 1);
		//for (int i = 1;i <= n;i++) printf("%d ", dfn[i]); puts("");
		Solve();
	}
	return 0;
}
```

---

## 作者：Mr_HY43205 (赞：4)

[P7735 [NOI2021] 轻重边](https://www.luogu.com.cn/problem/P7735)
### 题意
一颗有 $n$ 个节点的树，边分成轻边和重边。开始时所有边都为轻边。然后对树进行 $m$ 次操作：

操作 $1$：输入 $a$、$b$，对路径 $(a,b)$ 上的每一个点 $x$，将与 $x$ 相连的所有边变成轻边；然后再将路径 $(a,b)$ 上的所有边变成重边。

操作 $2$：输入 $a$、$b$，求路径 $(a,b)$ 上重边的数量。

本题为多组数据，组数为 $T$。

###### 数据范围：
$T \leq 3,1\leq n,m\leq 10^5$，保证输入操作时 $a\neq b$。

###### 关键词：树链剖分，最近公共祖先 LCA

------------
### 解题思路
##### 30分：$1\leq n,m\leq 5000$，无特殊性质。
对于 $30$ 分的数据，可以直接对题目中的操作进行模拟。若操作数为 $1$，先求出点 $a$ 和 $b$ 的最近公共祖先 $L$，然后分别把路径 $(a,L)$ 和 $(b,L)$ 上所有点连接的边标记为轻边，再把两条路径上的边标记为重边。

标记可以直接记录在边上，也可以把 $1$ 号点作为根，将整棵树变成有根树，然后将标记记录在深度较深的节点上。

查询时，同样先求出点 $a$ 和 $b$ 的最近公共祖先 $L$，然后统计路径 $(a,L)$ 和 $(b,L)$ 上的重边数即可。

这种模拟算法，对每一次操作，都需要 $O(n)$ 的时间进行修改/查询，因此总时间复杂度为 $O(Tmn)$。

##### 50分：$1\leq n,m \leq10^5$，树的形态是一条链。
对于这个范围的部分分，可以发现所有操作其实是在序列上进行的，具体地说就是序列上的区间修改和区间查询。既然如此，我们可以很轻松地使用线段树来维护每一个点上的标记，然后在询问时查询区间和即可。

有一点需要注意，就是在更新标记时，因为需要将路径 $(a,b)$ 两侧的边设置为轻边，所以应该先更新轻边标记，再更新重边标记。

对每一次操作，线段树上的更新或查询都需要 $O(\log n)$ 的时间，因此总时间复杂度为 $O(Tm\log n)$。

##### 100分：$1\leq n,m \leq10^5$，无特殊性质。
既然一条链上的信息可以用线段树来维护，那我们是否可以对树进行树链剖分，从而维护树上的信息呢？

答案是肯定的，但是并不能直接套用之前的线段树的更新方法。

由于每次更新需要将与路径 $(a,b)$ 相邻的边变为轻边，而进行树链剖分后线段树只能有效维护链上的信息，因此每次改变所有边的标记是不现实的。我们需要尽量做到每次操作只维护路径上的信息。

之前提到可以把边的标记转移到点上。那我们考虑是否可以只标记点，通过点上的信息来计算答案。要实现这样的操作，我们需要记录的是每个点被修改的时间戳。如果一条边是重边，那它的两个端点必须同一次被修改，也就是说两个端点的时间戳相同。于是，我们需要统计的就是路径上极长的连续时间戳的段数 $cnt$。答案就是路径长度减去 $(cnt-1)$。

由于需要统计路径中连续时间戳的段数，我们需要在线段树上维护段数 $cnt$，左端点的时间戳 $ltm$ 和右端点的时间戳 $rtm$（用于区间合并时判断是否重复计算）。同时，使用懒标记 $tag$ 来记录一个区间内全部相同的时间戳。

对于每一次操作，我们需要在计算点 $a$ 和点 $b$ 最近公共祖先的同时进行维护和查询操作。

每次操作时，使用树链剖分计算最近公共祖先需要 $O(\log n)$ 的时间，同时在线段树上进行维护/查询又需要 $O(\log n)$ 的时间，因此一次操作的时间复杂度为 $O(\log^2 n)$，总时间复杂度为 $O(Tm\log^2 n)$。

由于本题卡常，使用这个方法可能需要一些速度上的优化才可以通过。

[完整代码](https://www.luogu.com.cn/paste/b7hcnf50)





---

## 作者：cmll02 (赞：4)

简单树剖题。

题意经过简单转换：

给一棵树，初始所有点颜色均为 $0$。

给定两种操作。

第 $i$ 次操作为

1. 将 $u$ 到 $v$ 的路径上的点颜色设为 $i$。
2. 询问 $u$ 到 $v$ 的路径有多少条边连接的两个点颜色相同（不能是 $0$）。

很明显要树剖。。但是具体怎么搞呢？

维护两个线段树，第一个维护每个点的颜色。

第二个要维护轻重边，

但是这东西比较奇怪。我们先来研究一下这个奇怪的问题。

一个很 naive 的想法是把这条链用树剖维护好，再把连在链上的边变成轻的。

但是这随便都能卡掉。

假如说我在棕色重链上选一场段，那么有大量的地方要修改答案。

这玩意在维护的时候很难处理。

所以就不处理！

我们发现 

![](https://cdn.luogu.com.cn/upload/image_hosting/rk4550sq.png)

当我覆盖一条链的时候，有这么几个地方要变成轻的：

![](https://cdn.luogu.com.cn/upload/image_hosting/svtrcx92.png)

（红色为变轻的）

ABC 都可以在修改对应链的时候修改，但是 D 很难处理，因为 D 这样的修改可能有很多。

所以我们不管 D 类边，只在查询的时候特判掉。

具体来说就是每次跳分两部分贡献，链内的和链间的（也就是 D 类边）就可以解决了。

[Code here](https://paste.ubuntu.com/p/N7tXhpw5P3/)

---

## 作者：FutaRimeWoawaSete (赞：4)

神必了 114514 下，然后就爆炸了。                     

首先一个比较显然的转化是我们考虑一条边是重边当且仅当连接的两个点最后一次执行操作 $1$ 都在同一个时间，否则就说明当前这个边一定被置为了轻边，所以我们考虑维护每个点最后一次做操作 $1$ 的时间。                  

令 $Tim_i$ 为第 $i$ 个点最后执行操作 $1$ 的时间，那么我们现在就是求链上所有除 LCA 以外的所有 $Tim_i = Tim_{fa_i}$ 的点的个数。                      

对于一个区间可以直接线段树维护，我们每次合并两个子树的时候考虑一下中间两个点是否要多一个贡献即可，然后树剖把它剖成 $\log n$ 个区间即可。但无奈自己是神必考场上居然没想出来这么维护。                 

初始化的时候直接把所有点的 $Tim_i$ 置为 $i$ ，时间戳从 $n + 1$ 开始就好了。                 

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e5 + 5;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int rd() {
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
	return x*f;
}
void print(long long x) {
    if(x>9) print(x/10);
    *O++=x%10+'0';
}

int n,m,cnt,head[Len],dep[Len],fa[Len],top[Len],id[Len],tot,siz[Len],son[Len],Tim,Id[Len];
struct node
{
	int next,to;
}edge[Len << 1];
void add(int from,int to)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
void dfs1(int x,int f)
{
	dep[x] = dep[f] + 1;
	fa[x] = f;
	siz[x] = 1;
	int maxson = -1;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == f) continue;
		dfs1(to , x);
		siz[x] += siz[to];
		if(siz[to] > maxson) maxson = siz[to] , son[x] = to;
	}
}
void dfs2(int x,int topf)
{
	id[x] = ++ tot;
	Id[tot] = x;
	top[x] = topf;
	if(!son[x]) return;
	dfs2(son[x] , topf);
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == fa[x] || to == son[x]) continue;
		dfs2(to , to);
	}
}
struct Node
{
	int L,R,sum,tag;
	Node(){L = R = sum = tag = 0;}
	Node(int l,int r,int SUM,int TAG){L = l , R = r , sum = SUM , tag = TAG;}
}ans[Len << 2];
int ls(int x){return x << 1;}
int rs(int x){return x << 1 | 1;}
void push_up(int x)
{
	//if(x == 2 || x == 4)  printf("%d %d %d %d %d %d\n",ans[ls(x)].sum,ans[rs(x)].sum,ans[ls(x)].L,ans[ls(x)].R,ans[rs(x)].L,ans[rs(x)].R);
	ans[x].sum = ans[ls(x)].sum + ans[rs(x)].sum;
	if(ans[ls(x)].R == ans[rs(x)].L) ans[x].sum ++;
	ans[x].R = ans[rs(x)].R;
	ans[x].L = ans[ls(x)].L;
}
void push_down(int p,int l,int r)
{
	if(ans[p].tag) 
	{
		int mid = (l + r) >> 1;
		ans[ls(p)].sum = mid - l , ans[rs(p)].sum = (r - mid - 1);
		ans[ls(p)].tag = ans[ls(p)].L = ans[ls(p)].R = ans[rs(p)].L = ans[rs(p)].R = ans[rs(p)].tag = ans[p].tag;
	}
	ans[p].tag = 0;
}
void build(int p,int l,int r)
{
	ans[p].sum = ans[p].tag = ans[p].L = ans[p].R = 0;
	if(l == r)
	{
		ans[p].L = ans[p].R = ans[p].tag = l;
		return;
	}
	int mid = (l + r) >> 1;
	build(ls(p) , l , mid);
	build(rs(p) , mid + 1 , r);
	push_up(p);
}
void update(int p,int l,int r,int nl,int nr,int w)
{
	//printf("%d %d %d %d %d\n",p,l,r,nl,nr);
	if(nl <= l && nr >= r)
	{
		ans[p].sum = (r - l);
		ans[p].tag = ans[p].L = ans[p].R = w;
		return;
	}
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	if(nl <= mid) update(ls(p) , l , mid , nl , nr , w);
	if(nr > mid) update(rs(p) , mid + 1 , r , nl , nr , w);
	push_up(p);
	//printf("%d %d %d %d %d %d\n",p,l,r,nl,nr,ans[p].sum);
	//printf("###%d %d %d %d\n",p,l,r,ans[p].sum);
	//printf("###%d %d %d %d\n",p,Id[l],Id[r],ans[p].sum);
}
Node query(int p,int l,int r,int nl,int nr)
{
//	printf("%d %d %d %d %d\n",p,l,r,nl,nr);
	if(nl <= l && nr >= r) return ans[p];
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	if(nl <= mid && nr > mid) 
	{
		Node res,Ls,Rs;
		Ls = query(ls(p) , l , mid , nl , nr);
		Rs = query(rs(p) , mid + 1 , r , nl , nr);
		res.sum = Ls.sum + Rs.sum;
		if(Ls.R == Rs.L) res.sum ++;
		res.L = Ls.L;
		res.R = Rs.R;
		return res;
	}
	if(nl <= mid) return query(ls(p) , l , mid , nl , nr);
	if(nr > mid) return query(rs(p) , mid + 1 , r , nl , nr);
}
int qPoint(int p,int l,int r,int idx)
{
	if(l == r) return ans[p].tag;
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	if(idx <= mid) return qPoint(ls(p) , l , mid , idx);
	else return qPoint(rs(p) , mid + 1 , r , idx);	
} 
void updRange(int x,int y,int w)
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]]) swap(x , y);
		update(1 , 1 , n , id[top[x]] , id[x] , w);
		x = fa[top[x]];
 	}
 	if(dep[x] > dep[y]) swap(x , y);
	update(1 , 1 , n , id[x] , id[y] , w);
}
int LCA(int x,int y)
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]]) swap(x , y);
		x = fa[top[x]];
	}
	if(dep[x] > dep[y]) swap(x , y);
	return x;
} 
int qRange(int x,int y)
{
	int res = 0 , LLCA = LCA(x , y);
	while(top[x] != top[y]) 
	{
		if(dep[top[x]] < dep[top[y]]) swap(x , y);
		int nums = query(1 , 1 , n , id[top[x]] , id[x]).sum;
	 	//printf("%d %d %d %d %d\n",top[x],x,id[top[x]],id[x],nums);
		res += nums;
		if(dep[top[x]] > dep[LLCA])
		{
			if(qPoint(1 , 1 , n , id[top[x]]) == qPoint(1 , 1 , n , id[fa[top[x]]])) res ++;
		}
		x = fa[top[x]];
	}
	if(dep[x] > dep[y]) swap(x , y);int nums = query(1 , 1 , n , id[x] , id[y]).sum;
	res += nums;
	//printf("%d %d %d %d %d\n",x,y,id[x],id[y],nums);
	return res;
}
int main()
{
	//freopen("edge3.in","r",stdin);
	//freopen("ljNOI.out","w",stdout);
	int t;scanf("%d",&t);
	while(t --)
	{
		memset(head , 0 , sizeof head);cnt = tot = 0;
		n = rd() , m = rd();Tim = n;
		for(int i = 1 ; i <= n ; i ++) dep[i] = fa[i] = top[i] = id[i] = siz[i] = son[i] = 0;
		for(int i = 1 ; i < n ; i ++) 
		{
			int x,y;x = rd() , y = rd();
			add(x , y) , add(y , x);
		}
		dfs1(1 , 0);
		dfs2(1 , 1);
		build(1 , 1 , n);
		for(int i = 1 ; i <= m ; i ++) 
		{
			int op,a,b;op = rd() , a = rd() , b = rd();
			if(op == 1) 
			{
				Tim ++;
				updRange(a , b , Tim);
			}
			else print(qRange(a , b)) , *O ++ = '\n';
		}
	}
	fwrite(obuf,O-obuf,1,stdout);
	return 0;
}
```

---

## 作者：Scintilla (赞：3)

这是一个有点邪教的两 $\log$ 做法，并且常数大，过题需要卡。

看到操作和题目名称，不难想到树剖。

不妨设以 $1$ 为根，一条边的贡献由其深度较大的那个端点计算。难点在于如何安排 dfn 序，使得一条链和与一条链上的点直接相连的点的 dfn 是连续的。重链剖分后对于每条重链处理 dfn 序。考虑把处理 dfn 序的 dfs 改为 bfs，用队列记录待处理重链的顶端结点。首先让 $1$ 入队，对于队首 $u$，**首先为 $u$ 所在的重链安排连续的 dfn 序，然后为这条重链上所有点的所有轻儿子安排连续的 dfn 序**，再将这条重链上所有点的所有轻儿子入队。发现重链顶端结点的 dfn 序和其他结点并不连续，不过不影响复杂度。

于是修改和查询的时候拆成两条路径就可以跳重链做了，需要注意的是修改第二条路径会对影响第一条的修改（第一条路径中 LCA 的儿子代表的边会被修改为轻边），暴力改回来即可。

时间复杂度 $\mathcal{O}(n \log^2 n)$，实现起来较为麻烦，且需要卡常（例如我的代码中线段树区间修改和单点修改拆开了）。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define il inline
#define re register
#define rep(i, s, e) for (re int i = s; i <= e; ++i)
#define drep(i, s, e) for (re int i = s; i >= e; --i)
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)

const int N = 1000000 + 10;

il int read() {
    int x = 0; bool f = true; char c = getchar();
    while (!isdigit(c)) {if (c == '-') f = false; c = getchar();}
    while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f ? x : -x;
}

int n, m;
vector <int> e[N];

int dat[N << 2], tag[N << 2];

#define ls (u << 1)
#define rs (u << 1 | 1)
#define mid (l + r >> 1)

void reset(int u, int l, int r) {
    dat[u] = 0, tag[u] = -1;
    if (l == r) return;
    reset(ls, l, mid), reset(rs, mid + 1, r);
}

il void pushdown(int u, int l, int r) {
    if (tag[u] == -1) return;
    dat[ls] = tag[u] * (mid - l + 1), dat[rs] = tag[u] * (r - mid);
    tag[ls] = tag[u], tag[rs] = tag[u], tag[u] = -1;
}

void modify(int ml, int mr, int k, int u, int l, int r) {
    if (ml <= l && r <= mr) { dat[u] = k * (r - l + 1), tag[u] = k; return; }
    pushdown(u, l, r);
    if (ml <= mid) modify(ml, mr, k, ls, l, mid);
    if (mr > mid) modify(ml, mr, k, rs, mid + 1, r);
    dat[u] = dat[ls] + dat[rs];
}

void single_modify(int p, int k, int u, int l, int r) {
    if (l == r) { dat[u] = tag[u] = k; return; }
    pushdown(u, l, r);
    if (p <= mid) single_modify(p, k, ls, l, mid);
    else single_modify(p, k, rs, mid + 1, r);
    dat[u] = dat[ls] + dat[rs];
}

int query(int ql, int qr, int u, int l, int r) {
    if (ql <= l && r <= qr) return dat[u];
    pushdown(u, l, r);
    int res = 0;
    if (ql <= mid) res += query(ql, qr, ls, l, mid);
    if (qr > mid) res += query(ql, qr, rs, mid + 1, r);
    return res;
}

int sz[N], mson[N], dep[N], fr[N];
void dfs1(int u, int fa) {
    sz[u] = 1, mson[u] = 0, fr[u] = fa;
    for (int v : e[u]) {
        if (v == fa) continue;
        dep[v] = dep[u] + 1, dfs1(v, u), sz[u] += sz[v];
        if (sz[v] > sz[mson[u]]) mson[u] = v;
    }
}

int top[N], dfn[N], dcnt, lef[N], rig[N];
void dfs2(int u, int fa, int tp) {
    top[u] = tp;
    if (mson[u]) dfs2(mson[u], u, tp);
    for (int v : e[u]) {
        if (v != fa && v != mson[u]) dfs2(v, u, v);
    }
}

void make_dfn() {
    queue <int> q;
    q.push(1);
    while (q.size()) {
        int u = q.front(); q.pop();
        for (int v = mson[u]; v; v = mson[v]) dfn[v] = ++ dcnt;
        for (int v = u; v; v = mson[v]) {
            lef[v] = dcnt + 1;
            for (int w : e[v]) if (w != fr[v] && w != mson[v]) dfn[w] = ++ dcnt, q.push(w);
            rig[v] = dcnt;
        }
    }
}

int LCA(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        u = fr[top[u]];
    }
    return (dep[u] < dep[v]) ? u : v;
}

void doit(int u, int lca) {
    int v = 0;
    while (dep[lca] < dep[top[u]]) {
        if (mson[u]) single_modify(dfn[mson[u]], 0, 1, 1, n);
        if (lef[top[u]] <= rig[u]) modify(lef[top[u]], rig[u], 0, 1, 1, n);
        if (u != top[u]) modify(dfn[mson[top[u]]], dfn[u], 1, 1, 1, n);
        if (v) single_modify(dfn[v], 1, 1, 1, n);
        u = top[u], v = u, single_modify(dfn[u], 1, 1, 1, n), u = fr[u];
    }
    if (dfn[lca]) single_modify(dfn[lca], 0, 1, 1, n);
    if (mson[u]) single_modify(dfn[mson[u]], 0, 1, 1, n);
    if (lef[lca] <= rig[u]) modify(lef[lca], rig[u], 0, 1, 1, n);
    if (u != lca) modify(dfn[mson[lca]], dfn[u], 1, 1, 1, n);
    if (v) single_modify(dfn[v], 1, 1, 1, n);
}

void change(int u, int v) {
    int lca = LCA(u, v);
    if (u == lca) doit(v, u);
    else if (v == lca) doit(u, v);
    else {
        doit(u, lca), doit(v, lca);
        int w;
        for (w = u; dep[top[w]] > dep[lca]; w = fr[top[w]]) {
            w = top[w];
            if (fr[w] == lca) single_modify(dfn[w], 1, 1, 1, n);
        }
        if (w != lca) single_modify(dfn[mson[lca]], 1, 1, 1, n);
    }
}

int askit(int u, int lca) {
    int res = 0;
    while (dep[lca] < dep[top[u]]) {
        if (u != top[u]) res += query(dfn[mson[top[u]]], dfn[u], 1, 1, n);
        u = top[u], res += query(dfn[u], dfn[u], 1, 1, n), u = fr[u];
    }
    if (u != lca) res += query(dfn[mson[lca]], dfn[u], 1, 1, n);
    return res;
}

int ask(int u, int v) {
    int lca = LCA(u, v);
    return askit(u, lca) + askit(v, lca);
}

int main() {
    int tc = read();
    while (tc --) {
        n = read(), m = read(), dcnt = 0;
        reset(1, 1, n);
        rep(i, 1, n) e[i].clear();
        rep(i, 1, n - 1) {
            int u = read(), v = read();
            e[u].push_back(v), e[v].push_back(u);
        }
        dfs1(1, 0);
        dfs2(1, 0, 1);
        make_dfn();
        while (m --) {
            int op = read(), u = read(), v = read();
            if (op == 1) change(u, v);
            else printf("%d\n", ask(u, v));
        }
    }
    return 0;
}
```

---

## 作者：dead_X (赞：3)

## 前言
多测不清空调了一个小时，结果没时间写 T3 了。
## 暴力
首先考虑一个暴力，直接对每一条边进行修改，时间复杂度 $O(n)$。

考虑一种实现：对于路径上的所有点，将其所有儿子全部变成 $0$，然后将这个路径上的所有边变为 $1$。

然后我们把一条路径的权值扔到它的孩子上，可以写出一个非常高效的暴力。

对于将 $x$ 的儿子变 $0$ 的操作，我们考虑在 $x$ 上打 tag，和变 $1$ 的操作一起记录时间戳，即这个操作最后一次被执行的时间。

然后在查询的时候直接对于所有路径上的边，如果它最后一次变成 $1$ 的时间比最后一次变成 $0$ 的时间更晚就将答案加 $1$。

设操作的路径总长为 $\sum d$，我们可以在 $O(n\log n+\sum d)$ 的时间内解决问题。
## 优化
注意到这个东西一脸可以快速维护的样子，我们考虑直接树剖。

树剖后，我们对于所有轻边仍然按照上述方法维护，由于修改时间戳可以在 $O(\log^2n)$ 的时间内进行，而查询时最多只有 $O(\log n)$ 条轻边，因此时间复杂度为 $O(n\log^2 n)$。

对于重边，原问题等价于一条链。设第 $[l,r]$ 条边在路径上，我们直接将这些边设为 $1$，$l-1$ 和 $r+1$ 设为 $0$ 即可，时间复杂度仍然是 $O(n\log^2 n)$。

因此，我们可以在 $O(Tn\log^2n)$ 的时间复杂度内解决问题。
## 代码
```cpp
//And in that light,I find deliverance.
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int n,m;
vector<int> e[100003];
int sz[100003],fa[100003],dep[100003],son[100003],top[100003];
int dfn[100003],inv[100003],lst[100003],tot;
inline void dfs1(int x)
{
    sz[x]=1;
    for(int y:e[x]) if(y!=fa[x])
    {
        if(y==fa[x])continue;
        fa[y]=x,dep[y]=dep[x]+1,dfs1(y),sz[x]+=sz[y];
        (sz[y]>sz[son[x]])&&(son[x]=y);
    }
}
inline void dfs2(int x,int tp)
{
    top[x]=tp,dfn[x]=++tot,inv[tot]=x;
    if(son[x]) dfs2(son[x],tp);
    for(int y:e[x])
        if(y!=son[x]&&y!=fa[x])dfs2(y,y);
    lst[x]=tot;
}
int val[410003],add[100003];
inline void update(int nl,int nr,int l,int r,int i,int v)
{
	if(r<nl||nr<l) return ;
	if(l<=nl&&nr<=r) return (void)(val[i]=v);
	int mid=(nl+nr)>>1;
	update(nl,mid,l,r,i<<1,v),
	update(mid+1,nr,l,r,(i<<1)+1,v);
	return ;
}
inline int getmax(int nl,int nr,int x,int i)
{
	if(nl==nr) return val[i];
	int mid=(nl+nr)>>1;
	int v=(x<=mid)?getmax(nl,mid,x,i<<1):getmax(mid+1,nr,x,(i<<1)+1);
	return max(val[i],v);
}
int tag[410003],sum[410003];
inline void upd1(int nl,int nr,int l,int r,int i)
{
	if(r<nl||nr<l||tag[i]) return ;
	if(l<=nl&&nr<=r) return (void)(tag[i]=1,sum[i]=nr-nl+1);
	int mid=(nl+nr)>>1;
	upd1(nl,mid,l,r,i<<1),upd1(mid+1,nr,l,r,(i<<1)+1),
	sum[i]=sum[i<<1]+sum[(i<<1)+1];
	return ;
}
inline void upd0(int nl,int nr,int x,int i)
{
	if(nl==nr) return (void)(tag[i]=0,sum[i]=0);
	int mid=(nl+nr)>>1;
	(tag[i])&&(sum[i<<1]=mid-nl+1,sum[(i<<1)+1]=nr-mid,tag[i<<1]=tag[(i<<1)+1]=1,tag[i]=0),
	(x<=mid?upd0(nl,mid,x,i<<1):upd0(mid+1,nr,x,(i<<1)+1)),
	sum[i]=sum[i<<1]+sum[(i<<1)+1];
	return ;
}
inline int query(int nl,int nr,int l,int r,int i)
{
	if(r<nl||nr<l) return 0;
	if(tag[i]) return min(r,nr)-max(l,nl)+1;
	if(l<=nl&&nr<=r) return sum[i];
	int mid=(nl+nr)>>1;
	return query(nl,mid,l,r,i<<1)+query(mid+1,nr,l,r,(i<<1)+1);
}
inline int Q(int x)
{
	return add[x]>=getmax(1,n,dfn[fa[x]],1);
}
void solve()
{
	memset(val,0,sizeof(val)),
	memset(add,-1,sizeof(add)),
	memset(sum,0,sizeof(sum)),
	memset(tag,0,sizeof(tag));
	n=read(),m=read(),tot=0;
	for(int i=1; i<=n; ++i) e[i].clear(),son[i]=0,fa[i]=0;
	for(int i=1,u,v; i<n; ++i)	
		u=read(),v=read(),e[u].push_back(v),e[v].push_back(u);
	dfs1(1),dfs2(1,1);
	for(int op,u,v,T=1; T<=m; ++T)
	{
		op=read(),u=read(),v=read();
		if(op==1)
		{
			while(top[u]!=top[v])
			{
				if(dep[top[v]]>dep[top[u]])swap(u,v);
			        (u!=top[u])&&(
		        	upd1(1,n,dfn[top[u]]+1,dfn[u],1),1),
		        	//update val 1
		        	((int)e[u].size()>1)&&(
		        	upd0(1,n,dfn[u]+1,1),1),
		        	//update val 0
		        	add[top[u]]=T,
		        	//update add tag
		        	update(1,n,dfn[top[u]],dfn[u],1,T);
		        	//update del tag
		        u=fa[top[u]];
			}
				if(dfn[u]>dfn[v]) swap(u,v);
				int x=dfn[u],y=dfn[v];
		        (u!=v)&&(upd1(1,n,x+1,y,1),1),
		        //update val 1
		        (u!=top[u])&&(
		        upd0(1,n,x,1),1),
		        ((int)e[v].size()>1)&&(
		        upd0(1,n,y+1,1),1),
		        //update val 0
		        (u==top[u])&&(add[u]=-1),
		        update(1,n,x,y,1,T);
		        //update del tag
		}
		else
		{
			int ans=0;
			while(top[u]!=top[v])
			{
		        if(dep[top[v]]>dep[top[u]]) swap(u,v);
		        if(u!=top[u]) 
		        	ans+=query(1,n,dfn[top[u]]+1,dfn[u],1);
		        ans+=Q(top[u]),u=fa[top[u]];
			}
			if(u!=v)
			{
				int x=dfn[u],y=dfn[v];
				if(x>y) swap(x,y);
				ans+=query(1,n,x+1,y,1);
			}
			printf("%d\n",ans);
		}
	}
	return ;
}
signed main()
{
	for(int T=read();T--;) solve();
	return 0;
}
```

---

## 作者：1saunoya (赞：2)

**容易** 发现：每次操作染上的那一条链上的点，和其他时刻染上的那些点的边是不符合条件的。

所以我们让每个点染上一个时间戳，这样原问题就转化成了链上统计相邻的点的颜色相同对数。这个显然可以用线段树维护，套一个树链剖分就做完了。（每次覆盖的时候答案自然是段长减一）

然后是一个初始的问题。我们让每个点都是不同颜色，然后每次染色的编号从 $\text{n}$ 开始。

码量较大，常数较大。


```cpp
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i < y; i++)
#define all(v) begin(v), end(v)
#ifdef LOCAL
#include "tmp.hpp"
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif
using namespace std;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
template<class T>
istream &operator>> (istream &in, vector<T> &v) {
 for (auto &x : v) {
  in >> x;
 }
 return in;
}
int n, m;
struct Data {
 int l, r, len, tag, ans;
 Data() {
  l = r = len = tag = ans = 0;
 }
 Data(int L, int R, int Len, int Tag, int Ans) {
  tie(l, r, len, tag, ans) = make_tuple(L, R, Len, Tag, Ans);
 }
};
bool operator ==(const Data &a, const Data &b) {
 return a.l == b.l && a.r == b.r && a.len == b.len && a.tag == b.tag && a.ans == b.ans;
}
const Data null = Data(-1, -1, -1, -1, -1);
Data operator +(const Data &a, const Data &b) {
 if (a == null) {
  return b;
 } else if (b == null) {
  return a;
 } else {
  Data c;
  c.ans = a.ans + b.ans;
  c.len = a.len + b.len;
  if (a.r == b.l) {
   c.ans += 1;
  }
  c.l = a.l;
  c.r = b.r;
  return c;
 }
}
struct segment_tree {
 void pushv(int p, int v) {
  t[p].ans = t[p].len - 1;
  t[p].l = t[p].r = t[p].tag = v;
 }
 void pushdown(int p) {
  if (t[p].tag) {
   pushv(p * 2, t[p].tag);
   pushv(p * 2 + 1, t[p].tag);
   t[p].tag = 0;
  }
 }
 vector<Data> t;
 int n;
 segment_tree(const int &N) {
  n = N;
  t.resize(n * 4);
  build(0, n, 1);
 }
 void build(int l, int r, int p) {
  t[p].l = l;
  t[p].r = r - 1;
  t[p].len = r - l;
  t[p].ans = 0;
  t[p].tag = 0;
  if (r - l == 1) {
   return;
  }
  int mid = (l + r) / 2;
  build(l, mid, p * 2);
  build(mid, r, p * 2 + 1);
 }
 void update(int ql, int qr, int l, int r, int p, int v) { // [ql, qr)
  if (ql <= l && r <= qr) {
   pushv(p, v);
   return;
  }
  pushdown(p);
  int mid = (l + r) / 2;
  if (ql < mid) {
   update(ql, qr, l, mid, p * 2, v);
  }
  if (qr > mid) {
   update(ql, qr, mid, r, p * 2 + 1, v);
  }
  t[p] = t[p * 2] + t[p * 2 + 1];
 }
 Data query(int ql, int qr, int l, int r, int p) { // [ql, qr)
  if (ql <= l && r <= qr) {
   return t[p];
  }
  pushdown(p);
  int mid = (l + r) / 2;
  if (ql < mid && qr > mid) {
   return query(ql, qr, l, mid, p * 2) + query(ql, qr, mid, r, p * 2 + 1);
  } else if (ql < mid) {
   return query(ql, qr, l, mid, p * 2);
  } else if (qr > mid) {
   return query(ql, qr, mid, r, p * 2 + 1);
  }
 }
 void update(int ql, int qr, int v) {
  return update(ql, qr, 0, n, 1, v);
 }
 Data query(int ql, int qr) {
  return query(ql, qr, 0, n, 1);
 }
};
void solve() {
 cin >> n >> m;
 vector<vector<int>> e(n);
 rep (i, 0, n - 1) {
  int u, v;
  cin >> u >> v;
  --u;
  --v;
  e[u].emplace_back(v);
  e[v].emplace_back(u);
 }
 vector<int> sz(n);
 vector<int> son(n, -1);
 vector<int> fa(n);
 vector<int> dep(n);
 function<void(int, int)> dfs = [&](int u, int p) {
  sz[u] = 1;
  for (auto v : e[u]) {
   if (v == p) {
    continue;
   }
   dep[v] = dep[u] + 1;
   dfs(v, fa[v] = u);
   sz[u] += sz[v];
   if (son[u] == -1) {
    son[u] = v;
   } else if (sz[v] > sz[son[u]]) {
    son[u] = v;
   }
  }
 };
 dfs(0, -1);
 vector<int> dfn(n);
 vector<int> top(n, -1);
 int idx = 0;
 function<void(int, int)> dfs0 = [&](int u, int t) {
  dfn[u] = idx++;
  top[u] = t;
  if (son[u] != -1) {
   dfs0(son[u], t);
  }
  for (auto v : e[u]) {
   if (top[v] == -1) {
    dfs0(v, v);
   }
  }
 };
 dfs0(0, 0);
 segment_tree t(n);
 auto get_lca = [&](int u, int v) {
  while (top[u] != top[v]) {
   if (dep[top[u]] < dep[top[v]]) {
    swap(u, v);
   }
   u = fa[top[u]];
  }
  if (dep[u] < dep[v]) {
   return u;
  } else {
   return v;
  }
 };
 auto update_chain = [&](int u, int v, int val) {
  while (top[u] != top[v]) {
   if (dep[top[u]] < dep[top[v]]) {
    swap(u, v);
   }
   t.update(dfn[top[u]], dfn[u] + 1, val);
   u = fa[top[u]];
  }
  auto range = minmax(dfn[u], dfn[v]);
  t.update(range.first, range.second + 1, val);
 };
 auto query_chain = [&](int u, int v) {
  int lca = get_lca(u, v);
  auto res0 = null;
  while (top[u] != top[lca]) {
   res0 = t.query(dfn[top[u]], dfn[u] + 1) + res0;
   u = fa[top[u]];
  }
  res0 = t.query(dfn[lca], dfn[u] + 1) + res0;
  auto res1 = null;
  while (top[v] != top[lca]) {
   res1 = t.query(dfn[top[v]], dfn[v] + 1) + res1;
   v = fa[top[v]];
  }
  res1 = t.query(dfn[lca], dfn[v] + 1) + res1;
  return res0.ans + res1.ans;
 };
 rep (i, 0, m) {
  int op, x, y;
  cin >> op >> x >> y;
  --x;
  --y;
  if (op == 1) {
   update_chain(x, y, i + n);
  } else {
   cout << query_chain(x, y) << "\n";
  }
 }
}
int main() {
 cin.tie(nullptr)->sync_with_stdio(false);
 int tt;
 cin >> tt;
 while (tt--) {
  solve();
 }
}
```

---

## 作者：wsyhb (赞：2)

注：本题为 NOI2021 D1T1。

## 分析

修改操作（即操作 1）中有三种边，一种是在 $a$ 到 $b$ 路径上的边（赋为黑边），另一种是不在 $a$ 到 $b$ 路径上，但与该路径相邻的边（赋为白边），还有一种是与路径不相邻的边（不变）。

------------

P.S. 接下来这一段并非正解，但或许可以作为一种引入。

我们可以给点和边分别打上标记，记录其最后一次出现在 $a$ 到 $b$ 路径上的时间，那么一条边是黑边当且仅当：此边记录的时间大于等于两个端点记录的时间。这样尽管可以用树剖维护，但是由于是两种信息，似乎只能保证修改的时间复杂度。（而查询不满足区间连续性，所以需要一条边一条边地查）

------------

考虑其特征能不能只用点的信息表示，就会发现上述边其实就是分别有 2/1/0 个端点在给定路径上的边。

那么我们其实不需要记录边的信息，直接通过点的信息就可以判断——

**若一条边两个端点都出现过（指出现在之前的某条路径中），那么此边是黑边当且仅当这两个点最后一次出现的时间相同。**

## 题解

为了方便解决“点出现过”的限制，我们令第 $k$ 个操作的时间为 $n+k$，初始时 $i$ 号点的时间为 $i$。

那么我们就只需支持以下两种操作：

1. 将一条路径上的点全部赋成某个颜色。
2. 查询一条路径上颜色相同的相邻对有多少个。

（颜色即指上文中的“时间”）

**树剖 + 线段树**即可。

具体来说，线段树维护左端点颜色、右端点颜色，以及区间内颜色相同的相邻对的数量。查询时，树剖剖分出来的链直接区间查询，相邻链之间的部分用单点查询进行判断即可。

总时间复杂度 $O(Tm\log^2{n})$。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int max_n=1e5+5;
int End[max_n<<1],Last[max_n],Next[max_n<<1],e;
inline void add_edge(int x,int y)
{
	End[++e]=y,Next[e]=Last[x],Last[x]=e;
	End[++e]=x,Next[e]=Last[y],Last[y]=e;
}
int dep[max_n],sz[max_n],son[max_n],fath[max_n];
void dfs1(int x,int fa)
{
	dep[x]=dep[fa]+1;
	sz[x]=1;
	fath[x]=fa;
	for(int i=Last[x];i;i=Next[i])
	{
		int y=End[i];
		if(y!=fa)
		{
			dfs1(y,x);
			if(sz[y]>sz[son[x]])
				son[x]=y;
			sz[x]+=sz[y];
		}
	}
}
int top[max_n],dfn[max_n],Time;
void dfs2(int x,int top_now)
{
	top[x]=top_now;
	dfn[x]=++Time;
	if(son[x])
		dfs2(son[x],top_now);
	for(int i=Last[x];i;i=Next[i])
	{
		int y=End[i];
		if(y!=son[x]&&y!=fath[x])
			dfs2(y,y);
	}
}
namespace SegmentTree
{
	struct Node
	{
		int lc,rc,val,lazy;
	}node[max_n<<2],res;
	#define ls(p) ((p)<<1)
	#define rs(p) ((p)<<1|1)
	#define lc(p) node[p].lc
	#define rc(p) node[p].rc
	#define val(p) node[p].val
	#define lazy(p) node[p].lazy
	void build(int p,int l,int r)
	{
		lc(p)=l,rc(p)=r,val(p)=lazy(p)=0;
		if(l<r)
		{
			int mid=(l+r)>>1;
			build(ls(p),l,mid);
			build(rs(p),mid+1,r);
		}
	}
	inline void push_up(int p)
	{
		lc(p)=lc(ls(p)),rc(p)=rc(rs(p));
		val(p)=val(ls(p))+val(rs(p))+(rc(ls(p))==lc(rs(p)));
	}
	inline void push_down(int p,int l,int r,int mid)
	{
		lc(ls(p))=rc(ls(p))=lazy(ls(p))=lc(rs(p))=rc(rs(p))=lazy(rs(p))=lazy(p);
		val(ls(p))=mid-l,val(rs(p))=r-mid-1;
		lazy(p)=0;
	}
	void cover(int p,int l,int r,int a,int b,int v)
	{
		if(a<=l&&r<=b)
		{
			lc(p)=rc(p)=lazy(p)=v;
			val(p)=r-l;
			return;
		}
		int mid=(l+r)>>1;
		if(lazy(p))
			push_down(p,l,r,mid);
		if(a<=mid)
			cover(ls(p),l,mid,a,b,v);
		if(b>mid)
			cover(rs(p),mid+1,r,a,b,v);
		push_up(p);
	}
	void query(int p,int l,int r,int a,int b)
	{
		if(a<=l&&r<=b)
		{
			res.val+=val(p)+(res.rc==lc(p));
			res.rc=rc(p);
			return;
		}
		int mid=(l+r)>>1;
		if(lazy(p))
			push_down(p,l,r,mid);
		if(a<=mid)
			query(ls(p),l,mid,a,b);
		if(b>mid)
			query(rs(p),mid+1,r,a,b); 
	}
	inline int query(int a,int b)
	{
		res.rc=res.val=0;
		query(1,1,n,a,b);
		return res.val;
	}
	void query(int p,int l,int r,int k)
	{
		if(l==r)
		{
			res.lc=lc(p);
			return;
		}
		int mid=(l+r)>>1;
		if(lazy(p))
			push_down(p,l,r,mid);
		if(k<=mid)
			query(ls(p),l,mid,k);
		else
			query(rs(p),mid+1,r,k);
	}
	inline int query(int k)
	{
		query(1,1,n,k);
		return res.lc;
	}
}
inline void modify(int x,int y,int v)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		SegmentTree::cover(1,1,n,dfn[top[x]],dfn[x],v);
		x=fath[top[x]];
	}
	if(dep[x]>dep[y])
		swap(x,y);
	SegmentTree::cover(1,1,n,dfn[x],dfn[y],v);
}
inline int query(int x,int y)
{
	int res=0; 
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		res+=SegmentTree::query(dfn[top[x]],dfn[x]);
		res+=SegmentTree::query(dfn[top[x]])==SegmentTree::query(dfn[fath[top[x]]]);
		x=fath[top[x]];
	}
	if(dep[x]>dep[y])
		swap(x,y);
	res+=SegmentTree::query(dfn[x],dfn[y]);
	return res;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n-1;++i)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			add_edge(u,v);
		}
		dfs1(1,0),dfs2(1,1);
		SegmentTree::build(1,1,n);
		for(int i=1;i<=m;++i) 
		{
			int op,a,b;
			scanf("%d%d%d",&op,&a,&b);
			if(op==1)
				modify(a,b,n+i);
			else
				printf("%d\n",query(a,b));
		}
		for(int i=1;i<=n;++i)
			Last[i]=son[i]=0;
		e=Time=0;
	}
    return 0;
}
```

---

## 作者：Mobius127 (赞：1)

[题传](https://www.luogu.com.cn/problem/P7735)

树剖不好维护边权，考虑下放到深度深的结点上。

操作一改成：

>对于路径 $(a, b)$ 上的所有结点，将其子节点染成轻点，随后将路径上的所有点染成重点，特别地，$\text{LCA}(a, b)$ 为轻点。

拆成两种操作：

3. 路径染重/轻；

4. 子节点染轻。

操作顺序为 $3(a, b)--4(a, b) -- 3(\text{LCA}(a, b))$。

操作三一脸树剖的样子，操作四。。

我们考虑再转化一下题意，我们发现，操作 3/4 中处理的关键是 $\text {LCA}$ 与 子节点，想一下，如果只操作一次，那么问题变为？

>找到链上有多少颜色相同的点！！1

既然一次操作是 0/1 染色，不妨改为染 **时间戳** $i$ 到每个节点上。

操作 1 变成区间覆盖。

操作 2 让我们统计相邻相等的数量，但是 $\text{dfs}$
 序上不一定相邻，怎么办？
 
不难发现，我们每次查询的区间为 $(\text{top}(x), x)$，也就是说，我们查询的区间最左端就是某颗子树的根节点！！1（这其实就是 $\text{dfs}$ 序的性质）我们只要在查询的时候注意顺序，把对应的区间连上，就珂以统计中间被连上的点是否相同了。

注意多测清空 ![qq_emoji: kk](https://xn--9zr.tk/kk)，因为这个卡了好久。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
const int mo=19940417;
const int R=20;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
namespace Solution{
	const int N=2e5+5;
	int n, m;
	struct node{
		node(){st=ed=len=tag=ans=0;}
		int st, ed, len, tag, ans;
	}d[N*4];
	node add(node a, node b){
		node c;
		c.len=a.len+b.len;
		c.ans=a.ans+b.ans+(a.ed==b.st);
		c.st=a.st, c.ed=b.ed;
		return c;
	}
	int tot, h[N], dfn[N], cnt, top[N], son[N], fa[N], siz[N], dep[N];
	struct Edge{
		int to, nxt;
	}edge[N*2];
	void add(int x, int y){
		edge[++tot].to=y, edge[tot].nxt=h[x];
		h[x]=tot;return ;
	}
	void dfs1(int x, int f){
		siz[x]=1;
		for(int i=h[x]; i; i=edge[i].nxt){
			int to=edge[i].to;if(to==f) continue;
			dep[to]=dep[x]+1, fa[to]=x, dfs1(to, x);
			siz[x]+=siz[to];if(siz[son[x]]<siz[to]) son[x]=to;
		}
		return ;
	}
	void dfs2(int x, int root){
//		printf("`````%d %d\n", x, root);
		top[x]=root, dfn[x]=++cnt;
		if(son[x]) dfs2(son[x], root);
		for(int i=h[x]; i; i=edge[i].nxt){
			int to=edge[i].to;
			if(top[to]) continue;
			dfs2(to, to);
		}
		return ;
	}
	struct SegmentTree{
		#define ls k<<1
		#define rs k<<1|1
		#define mid (l+r>>1)
		void pushup(int k){d[k]=add(d[ls], d[rs]);return ;}
		void upd(int k, int v){
			d[k].ans=d[k].len-1, d[k].st=d[k].ed=v;
			d[k].tag=v;return ;
		}
		void pushdown(int k){
			if(!d[k].tag) return ;
			upd(ls, d[k].tag), upd(rs, d[k].tag);
			d[k].tag=0;
			return ;
		}
		void build(int k, int l, int r){
			d[k].len=r-l+1, d[k].tag=d[k].ans=0;
			if(l==r){d[k].st=d[k].ed=l&r;return ;}
			build(ls, l, mid), build(rs, mid+1, r);
			return pushup(k);
		}
		void change(int k, int l, int r, int x, int y, int v){
			if(x<=l&&r<=y) return upd(k, v);pushdown(k);
			if(x<=mid) change(ls, l, mid, x, y, v);
			if(mid<y) change(rs, mid+1, r, x, y, v);
			return pushup(k);
		}
		node query(int k, int l, int r, int x, int y){
//			printf("%d %d %d %d %d\n", k, l, r, x, y);
			if(x<=l&&r<=y) return d[k];pushdown(k);
			if(y<=mid) return query(ls, l, mid, x, y);
			if(x>mid) return query(rs, mid+1, r, x, y);
			return add(query(ls, l, mid, x, y), query(rs, mid+1, r, x, y));
		}
		#undef ls
		#undef rs
		#undef mid
	}Chtholly;
	void change(int x, int y, int v){
		while(top[x]!=top[y]){
			if(dep[top[x]]<dep[top[y]]) swap(x, y);
			Chtholly.change(1, 1, n, dfn[top[x]], dfn[x], v);
			x=fa[top[x]];
		}
		if(dep[x]>dep[y]) swap(x, y);
		Chtholly.change(1, 1, n, dfn[x], dfn[y], v);
		return ;
	}
	int LCA(int x, int y){
		while(top[x]!=top[y]){
			if(dep[top[x]]<dep[top[y]]) swap(x, y);
//			printf(">>>%d %d\n", x, y);
			x=fa[top[x]];
		}
		return dep[x]>dep[y]?y:x;
	}
	int query(int x, int f){
		node ret;
		while(top[x]!=top[f]){
			ret=add(Chtholly.query(1, 1, n, dfn[top[x]], dfn[x]), ret);
			x=fa[top[x]];
		}
		return add(Chtholly.query(1, 1, n, dfn[f], dfn[x]), ret).ans;
	}
	int ask(int x, int y){
		int lca=LCA(x, y);//printf("----%d\n", lca);
		return query(x, lca)+query(y, lca);
	}
	signed work(){
		memset(h, 0, sizeof(h)), tot=cnt=0;
		memset(fa, 0, sizeof(fa));
		memset(son, 0, sizeof(son));
		memset(top, 0, sizeof(top));
		memset(dep, 0, sizeof(dep));
		memset(dfn, 0, sizeof(dfn));
		memset(siz, 0, sizeof(siz));
		n=read(), m=read();
		for(int i=1, a, b; i<n; i++)
			a=read(), b=read(), add(a, b), add(b, a);
		dfs1(dep[1]=1, 0), dfs2(1, 1);
		Chtholly.build(1, 1, n);//Chtholly.debug();
//		for(int i=1; i<=n; i++)
//			printf("->%d %d\n", dep[i], fa[i]); 
		for(int i=1; i<=m; i++){
			int opt=read(), x=read(), y=read();
			if(opt&1) change(x, y, i+n);
			else printf("%d\n", ask(x, y));
		}
		return 0;
	}
}
signed main(){
	int T=read();
	while(T--)
		Solution :: work();
	return 0;
}

```


---

## 作者：丛雨 (赞：1)

## [轻重边](https://www.luogu.com.cn/problem/P7735)

首先我们可以发现任意时刻一定是在树上有若干条重链，是因为每次将一条链上的边赋为重边时会断开周围的轻边

若是我们可以快速地找到一条路径上所有的重链，便可以在均摊 $ O(1) $ 的时间内进行链的分解与“推平”

上面的证明则是对于单条向下的链，它要么是在作为插入链的段点时贡献 1 ，要么是在被吞掉时贡献，而每次插入至多增加 2 条向下的链，故总次数为 $ O(n) $

若是我们想打 $\tt LCT $ ,那便可以在 $ \log n $的时间内找到每一条重链段，再 $ O(\log n) $ 地插入到统计答案的线段树中（由于每次只询问路径和，所以可以不用树剖，而用括号序），总时间复杂度 $ O(n\log n) $

但不用这样麻烦

我们使用树剖，每条重链上使用**珂朵莉树**维护重链信息以及每个节点伸出去的重边情况，沿用势能分析，总时间复杂度 $O(n\log^2 n)$

考场上懒得打LCT,所以就打了个树剖，（逃

当然会被卡常，勉强能过

```cpp
#include<bits/stdc++.h>
using namespace std;
# define ll long long
# define read read1<int>()
# define Type template<typename T>
Type T read1(){
	T t=0;
	char k;
	bool vis=0;
	do (k=getchar())=='-'&&(vis=1);while('0'>k||k>'9');
	while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();
	return vis?-t:t;
}
# define fre(k) freopen(k".in","r",stdin);freopen(k".out","w",stdout)
# define ll long long
int s,son[100005],sz[100005],top[100005],f[100005],h[100005],dfn[100005],m,rk[100005];
int va[400005];bool mark[400005];
vector<int>G[100005];
void dfs(int n,int fa){
	sz[n]=1;f[n]=fa;h[n]=h[fa]+1;son[n]=0;
	for(int i:G[n])
		if(i!=fa){
			dfs(i,n);
			if(sz[i]>=sz[son[n]])son[n]=i;
			sz[n]+=sz[i];
		}
}void dfs1(int n,int tp){
	top[n]=tp;rk[dfn[n]=++*dfn]=n;
	if(son[n])dfs1(son[n],tp);
	for(int i:G[n])
		if(i!=f[n]&&i!=son[n])
			dfs1(i,i);
}set<pair<int,int> >se[100005],to[100005];
void recover(int w,int l,int r,int d){
	if(l==r){va[d]=0;return;}
	int mid=l+r>>1;
	if(mark[d]){
		mark[d<<1]=mark[d<<1|1]=1;
		va[d<<1]=mid-l+1;va[d<<1|1]=r-mid;
		mark[d]=0;
	}if(w<=mid)recover(w,l,mid,d<<1);
	else recover(w,mid+1,r,d<<1|1);
	va[d]=va[d<<1]+va[d<<1|1];
}
void cover(int l,int r,int tl,int tr,int d){
	if(l>r)return;
	if(l==tl&&r==tr){
		va[d]=r-l+1;mark[d]=1;
		return;
	}
	int mid=tl+tr>>1;
	if(mark[d])return;
	if(r<=mid)cover(l,r,tl,mid,d<<1);
	else if(mid<l)cover(l,r,mid+1,tr,d<<1|1);
	else cover(l,mid,tl,mid,d<<1),cover(mid+1,r,mid+1,tr,d<<1|1);
	va[d]=va[d<<1]+va[d<<1|1];
}
int query(int l,int r,int tl,int tr,int d){
	if(l>r)return 0;
	if(l==tl&&r==tr)return va[d];
	int mid=tl+tr>>1;
	if(mark[d])return r-l+1;
	if(r<=mid)return query(l,r,tl,mid,d<<1);
	if(mid<l)return query(l,r,mid+1,tr,d<<1|1);
	return query(l,mid,tl,mid,d<<1)+query(mid+1,r,mid+1,tr,d<<1|1);
}
void cover(int l,int r){
	int tl=top[l],tr=top[r];
	vector<pair<int,int> >ins,ins2;
	while(tl!=tr){
		if(h[tl]<h[tr])swap(l,r),swap(tl,tr);
		auto i=to[tl].begin();
		while(i!=to[tl].end()&&i->first<=dfn[l]){
			recover(max(i->first,i->second),1,s,1);
			to[tl].erase(i);i=to[tl].begin();
		}auto j=se[tl].begin();
		while(j!=se[tl].end()&&j->first<=dfn[l]){
			if(j->second>dfn[l]){
				recover(dfn[l]+1,1,s,1);
				if(dfn[l]+1<j->second){
					auto w=make_pair(dfn[l]+1,j->second);
					se[tl].erase(j);
					se[tl].insert(w);
				}else se[tl].erase(j);
			}else se[tl].erase(j);
			j=se[tl].begin();
		}
		ins.push_back(make_pair(tl,f[tl]));
		ins2.push_back(make_pair(dfn[tl],dfn[l]));
		tl=top[l=f[tl]];
	}
	if(h[l]<h[r])swap(l,r);
	auto i=to[tl].lower_bound(make_pair(dfn[r],0));
	while(i!=to[tl].end()&&i->first<=dfn[l]){
		recover(max(i->first,i->second),1,s,1);
		to[tl].erase(i);i=to[tl].lower_bound(make_pair(dfn[r],0));
	}
	auto j=se[tl].lower_bound(make_pair(dfn[r],0));if(j!=se[tl].begin())--j;
	while(j!=se[tl].end()&&j->first<=dfn[l]){
		if(j->second<dfn[r]){++j;continue;}
		if(j->first<dfn[r]){
			recover(dfn[r],1,s,1);
			if(j->first<dfn[r]-1)
				se[tl].insert(make_pair(j->first,dfn[r]-1));
		}if(j->second>dfn[l]){
			recover(dfn[l]+1,1,s,1);
			if(dfn[l]+1<j->second)
				se[tl].insert(make_pair(dfn[l]+1,j->second));
		}se[tl].erase(j);
		j=se[tl].lower_bound(make_pair(dfn[r],0));
	}
	cover(dfn[r]+1,dfn[l],1,s,1);
	if(l!=r)se[tl].insert(make_pair(dfn[r],dfn[l]));
	for(auto i:ins){
		to[i.first].insert(make_pair(dfn[i.first],dfn[i.second]));
		to[top[i.second]].insert(make_pair(dfn[i.second],dfn[i.first]));
	}for(auto i:ins2){
		cover(i.first,i.second,1,s,1);
		se[rk[i.first]].insert(i);
	}
}
int query(int l,int r){
	int tl=top[l],tr=top[r],t=0;
	while(tl!=tr){
		if(h[tl]<h[tr])swap(l,r),swap(tl,tr);
		t+=query(dfn[tl],dfn[l],1,s,1);
		tl=top[l=f[tl]];
	}if(l==r)return t;
	if(h[l]<h[r])swap(l,r);
	return query(dfn[r]+1,dfn[l],1,s,1)+t;
}
int main(){
	//fre("edge");
	for(int T=read;T--;){
		s=read;m=read;
		for(int i=1;i<=s;++i)G[i].clear(),se[i].clear(),to[i].clear();
		memset(mark,0,s+1<<2);
		memset(va,0,s+1<<4);
		for(int i=1;i<s;++i){
			int u=read,v=read;
			G[u].push_back(v);
			G[v].push_back(u);
		}dfs(1,0);dfs1(1,1);*dfn=0;
		for(int i=1;i<=m;++i){
			int opt=read,l=read,r=read;
			if(opt&1)cover(l,r);
			else printf("%d\n",query(l,r));
		}
	}
	return 0;
}
```

---

## 作者：AK_Dream (赞：1)

考虑这样一个转化：

对于每次修改操作，将 $x \rightarrow y$ 路径上的所有点的颜色染成一种新颜色（假设初始时所有点颜色两两不同），那么在某一个时刻，两端的点颜色相同的边就是一条重边。

对原树进行重链剖分并维护一棵线段树，每个线段树节点维护当前区间最左边点和最右边点的颜色，以及区间内有多少对相邻且颜色相同的点。

对于修改操作，直接将链上的所有点赋值成新颜色，可以直接打懒标记。

对于询问操作，在重链上跳的同时记录一下上一次访问的重链的顶端的点的颜色，来判断这次跳到的重链的底端点颜色是否和那个重链的顶端点颜色相同，如果相同让答案+1

时间复杂度 $O(n\log^2 n)$ ，可以通过

---


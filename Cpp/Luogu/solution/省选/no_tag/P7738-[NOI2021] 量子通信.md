# [NOI2021] 量子通信

## 题目背景

由于评测性能差异，本题时限 +0.5s。

## 题目描述

小 Z 正在自学量子计算机相关知识，最近他在研究量子通信章节，并遇到了一个有趣的问题。在该问题中，Alice 和 Bob 正在进行量子通信，它们的通信语言是一个大小为 $n$ 的字典 $S$，在该字典中，每一个单词 $s_i$（$1 \le i \le n$）都可以用一个 $\boldsymbol{256}$ **位的** $\boldsymbol{01}$ **串**来表示。在本题中 $s_i$ 可以通过调用函数 `gen` 来生成，选手可以在题目目录下的 `gen.cpp` 中查看，该函数的参数 `n`、`a1`、`a2` 将由输入数据给出。

Alice 和 Bob 接下来要进行 $m$ 次通信，每次通信由 Alice 向 Bob 传输**恰好一个**字典中的单词。然而，两人使用的通信信道并不可靠，会受到噪音的干扰。更具体地，对于第 $i$ 次传输，记 Alice 传输的原单词为 $x_i$，该 $01$ 串会受噪音干扰而**翻转最多** $\boldsymbol{k_i}$ **位**。换句话说，记 Bob 这次收到的 $01$ 串为 $y_i$，它与 $x_i$ 相比，可能有最多 $k_i$ 位是不同的，并且 $y_i$ 可能不在字典 $S$ 中出现。

与此同时，Bob 得知坏人 Eve 也潜入了两人的通信信道，并准备干扰两人的通信。他的干扰方式是将 Bob 收到的 $01$ 串变为任意的 $256$ 位 $01$ 串，并且这个串可能不在字典 $S$ 中出现。Eve 非常狡猾，他**不一定**会对每次通信都进行干扰。

现在 Bob 找来了你帮忙，对于接下来的每次通信，你需要根据 Bob 最终收到的 $01$ 串以及这次通信的噪音干扰阈值 $k_i$（$0 \le k_i \le 15$），判断这次通信是否有可能没有受到 Eve 的干扰（即 Bob 收到的 $01$ 串可以由字典中的某个单词翻转至多 $k_i$ 位后得到）。本次通信如果有可能没受到 Eve 干扰，请你输出 $1$，否则输出 $0$。Bob 很信任你的能力，所以你需要**在线地回答结果，具体要求见输入格式**。

为了降低读入用时， Bob 收到的串将用**长度为** $\boldsymbol{64}$ **的** $\boldsymbol{16}$ **进制串**给出，$16$ 进制串中包含数字字符 $\texttt{0} \sim \texttt{9}$ 与大写英文字母 $\texttt{A} \sim \texttt{F}$，其中字符 $\texttt{A} \sim \texttt{F}$ 依次表示数值 $10 \sim 15$。

$16$ 进制串可以逐位转化为 $01$ 串，例如：`5` 对应 `0101`，`A` 对应 `1010`，`C` 对应 `1100`。

## 说明/提示

**【询问举例】**

为了方便解释题意，我们使用了直接给出字典中单词、缩小单词长度为 $4$、允许离线地回答询问等方式，对简化的情况举例。

考虑字典大小为 $n = 2$，单词有 `1010` 和 `0111`。

对于询问 `B = 1011` 和 $k_1 = 1$，回答应该是 $1$，通过翻转 `1010` 的第 $4$ 位（从高位到低位，下同）得到。

对于询问 `1 = 0001` 和 $k_2 = 2$，回答应该是 $1$，通过翻转 `0111` 的第 $2$、$3$ 位得到。

对于询问 `1 = 0001` 和 $k_3 = 1$，回答应该是 $0$。

- 翻转 `1010` 至多 $1$ 位可得 `1010`、`0010`、`1110`、`1000`、`1011`。
- 翻转 `0111` 至多 $1$ 位可得 `0111`、`1111`、`0011`、`0101`、`0110`。
- 无法得到 `1 = 0001`，它必定是由 Eve 干扰得到的。

**【数据范围】**

对于所有测试点：$1 \le n \le 4 \times {10}^5$，$1 \le m \le 1.2 \times {10}^5$，$0 \le k_i \le 15$，$a_1$ 和 $a_2$ 在 $[0, 2^{64} - 1]$ 之间均匀随机生成。

| 测试点编号 | $n =$ | $m =$ | $k_i \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10$ | $2$ | 无 |
| $2$ | $500$ | $500$ | $15$ | 无 |
| $3$ | $1000$ | $1000$ | $0$ | 无 |
| $4$ | $2000$ | $2000$ | $2$ | 无 |
| $5$ | $5000$ | $5000$ | $15$ | 无 |
| $6$ | $10^4$ | $10^4$ | $15$ | 无 |
| $7$ | $2\times 10^4$ | $2\times 10^4$ | $15$ | 无 |
| $8$ | $10^5$ | $10^5$ | $1$ | 无 |
| $9$ | $4\times 10^5$ | $1.2\times 10^5$ | $1$ | 无 |
| $10$ | $5\times 10^4$ | $5\times 10^4$ | $2$ | 无 |
| $11$ | $7\times 10^4$ | $7\times 10^4$ | $3$ | 无 |
| $12$ | $10^5$ | $10^5$ | $2$ | 无 |
| $13$ | $3\times 10^4$ | $3\times 10^4$ | $5$ | 无 |
| $14$ | $6\times 10^4$ | $6\times 10^4$ | $4$ | 无 |
| $15$ | $1.2\times 10^5$ | $1.2\times 10^5$ | $5$ | 无 |
| $16$ | $6\times 10^4$ | $6\times 10^4$ | $8$ | 所有询问串随机生成 |
| $17$ | $1.2\times 10^5$ | $1.2\times 10^5$ | $12$ | 所有询问串随机生成 |
| $18$ | $4\times 10^5$ | $10^5$ | $15$ | 所有询问串随机生成 |
| $19$ | $3\times 10^4$ | $3\times 10^4$ | $7$ | 无 |
| $20$ | $6\times 10^4$ | $6\times 10^4$ | $9$ | 无 |
| $21$ | $9\times 10^4$ | $9\times 10^4$ | $11$ | 无 |
| $22$ | $2\times 10^5$ | $1.2\times 10^5$ | $12$ | 无 |
| $23$ | $4\times 10^5$ | $8\times 10^4$ | $15$ | 无 |
| $24$ | $4\times 10^5$ | $10^5$ | $15$ | 无 |
| $25$ | $4\times 10^5$ | $1.2\times 10^5$ | $15$ | 无 |

## 样例 #1

### 输入

```
见附件中的 qi/qi1.in```

### 输出

```
见附件中的 qi/qi1.ans```

## 样例 #2

### 输入

```
见附件中的 qi/qi2.in```

### 输出

```
见附件中的 qi/qi2.ans```

## 样例 #3

### 输入

```
见附件中的 qi/qi3.in```

### 输出

```
见附件中的 qi/qi3.ans```

# 题解

## 作者：Alex_Wei (赞：46)

> [题目传送门。](https://www.luogu.com.cn/problem/P7738)
>
> 题意简述：给出 $n$ 个 $256$ 位二进制数（随机生成）$a_i$。对于 $m$ 个询问，每次给出一个 $256$ 位二进制数 $x$ 和一个十进制数 $k$，求是否存在 $a_i$ 使得 $x,a_i$ 不同位数个数不大于 $k$。

注意到这个 $k\leq 15$，一定是本题的突破点。再根据 $16^2=256$ 与抽屉原理，不难想到将 $256$ 位的二进制数看成 $16$ 位的 $65536$ 进制数。这样一来，如果 $x$ 与 $a_i$ 在二进制下不同位数个数不大于 $15$，那么它们在 $65536$ 进制下**必定至少有一位完全相等**。这是显然的。

因此，我们可以枚举 $x$ 在 $65536$ 进制下的 $16$ 位，并检查与 $x$ 在该位相等的所有 $a_i$ 是否符合要求。**由于数据随机生成，所以某一位为某个数的 $a_i$ 的期望个数为 $\dfrac{n}{65536}\approx 7$**。所以**对于每一位，我们期望检查 $7$ 个 $a_i$ 是否符合要求**。而满足在 $65536$ 进制下第 $b$ 位为 $c$ 的 $a_i$ 的所有 $i$ 可以开 `vector` 存储。

检查方法很简单：要求出 $65536$ 进制数 $x,y$ 在二进制下有多少位不同，只需要预处理出 $0\sim 65535$ 在二进制下 $1$ 的个数，然后枚举 $x,y$ 的每一位（一共 $16$ 位），加上 它们在这一位的值的异或和 在二进制下 $1$ 的个数即可。

极限数据下空间复杂度为 $16n$，**期望**时间复杂度为 $m\times 16\times 7\times 16\approx 2\times 10^8$，其中 $m$ 表示询问个数，第一个 $16$ 表示枚举的 $16$ 位，$7$ 表示与 $x$ 在枚举的某一位的值相等的 $a_i$ 的期望个数，而第二个 $16$ 表示检查的复杂度。 

为了卡常，可以进行以下优化：

- 把 `vector` 换成链式前向星。
- 使用 `fread`。
- 检查时使用指针而不是数组。
- 如果已经不符合条件，退出检查（不加这个优化会 T 掉几个点）。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define gc getchar()
#define mem(x,v) memset(x,v,sizeof(x))

typedef unsigned long long ull;
typedef unsigned short us;

namespace IO{
	char buf[1<<23],*p1=buf,*p2=buf;
	#ifdef __WIN32
		#define gc getchar()
	#else
		#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
	#endif
	inline int read(){
		int x=0;char s=gc;
		while(!isdigit(s))s=gc;
		while(isdigit(s))x=(x<<1)+(x<<3)+(s-'0'),s=gc;
		return x;
	}
} using namespace IO;

const int N=400000+5;
const int W=65536;
bool s[N][256],q[256];

ull myRand(ull &k1,ull &k2){
    ull k3=k1,k4=k2;
    k1=k4,k3^=(k3<<23),k2=k3^k4^(k3>>17)^(k4>>26);
    return k2+k4;
}
void gen(int n,ull a1,ull a2){
    for(int i=0;i<n;i++)
        for(int j=0;j<256;j++)
            s[i][j]=(myRand(a1,a2)&(1ull<<32))?1:0;
}

struct EDGE{
	int cnt,hd[W],nxt[N],to[N];
	void add(int x,int y){nxt[++cnt]=hd[x],hd[x]=cnt,to[cnt]=y;}
}buc[16];

ull n,m,a1,a2;
us val[N][16],mp[W],qq[16];
int main(){
	cin>>n>>m>>a1>>a2,gen(n,a1,a2);
	for(int i=0;i<n;i++)
		for(int j=0;j<16;j++){
			for(int k=0;k<16;k++)
				val[i][j]+=s[i][j*16+k]<<k;
			buc[j].add(val[i][j],i);
		}
	for(int i=1;i<W;i++)mp[i]=mp[i>>1]+(i&1);
	for(int i=0,las=0,k;i<m;i++,mem(qq,0)){
		for(int j=0,vv=0;j<64;j++,vv=0){
			char s=gc;
			if(isdigit(s))vv=s-'0';
			else if(s>='A'&&s<='F')vv=10+s-'A';
			else {j--; continue;}
			for(int l=0;l<4;l++)q[j*4+l]=(vv>>3-l)&1;
		}
		bool ok=0; k=read();
		for(int j=0;j<16;j++)
			for(int l=0;l<16;l++)
				qq[j]+=(q[j*16+l]^las)<<l;
		for(int j=0;j<16;j++){
			for(int p=buc[j].hd[qq[j]];p;p=buc[j].nxt[p]){
				int it=buc[j].to[p],cnt=0;
				us *pval=val[it],*pq=qq;
				for(int l=0;l<16;l++,pval++,pq++){
					cnt+=mp[(*pval)^(*pq)];
					if(cnt>k)break;
				} if(cnt<=k){ok=1; break;}
			} if(ok)break;
		} cout<<(las=ok)<<'\n';
	}
    return 0;
}
```



---

## 作者：Mophie (赞：9)

绝赞卡常题/kk

心路历程：

强制在线啊！

哦可以离线做啊，但是好像也没法做……

这可以在线做啊！

……

首先先观察这个数据范围，然后我们可以发现这个 $k$ 的范围很小。

因为 $k \le 15$，所以我们考虑把原串分为 $16$ 份。

那么根据鸽巢原理，将读入的串分成 $16$ 份，若需满足条件，则必然有一个区间的串相等。

我第一次做到这儿就不会了。

后面观察 gen.cpp ，可以发现，**字典是完全随机的**。

所以说就可以考虑均摊了。

对于每一段，设一个 vector $B_{i,j}$ 表示在第 $i$ 块，这一块的值为 $j$ 中有哪些字典。

接下来直接对于两个 $256$ 位的数，预处理出每个 $[0,2^{16}-1]$ 的数中各自包含几个 $1$，然后每 $16$ 个数分一位，异或查找即可。

复杂度的话首先发现几乎是均摊的。

所以说查找一个块中的 vector 数量大概是 $\dfrac{n}{2^{16}}$ 个。

总共有 $16$ 个 vector，每次查找都有 $16$ 的常数。

那么就是 $O(n \times m \times \dfrac{1}{2^8})$ 的复杂度。

现在看上去一切都很美好，样例跑的也不慢。

但当你自造数据一看——$2.2s$。

考虑怎么优化这个常数。

我用了 fread 快读，循环展开等办法都不是很实用，只有一步循环 + break（见代码）的方法加快了不少。

但还是卡不过去。赛后一测确实也没有过。

通过一些神仙的提醒，发现可以用 resize 提前处理内存来优化 push_back 的常数。

因为是随机的所以 resize 开到 $32$ 的话冲突概率就极小了。

然后就过了。

详细细节见代码。

```cpp
/*
	『那么…假如我现在走进海里去的话…』
	『你会…拉住我吗？』
	『如果你希望我拉住你的话，我就会拉住你』
	『不…我不是这个意思』
	『那就是说，我没有必要拉住你了？』
	『…………』

	她没有回答我的提问。
	但是，她也没有再次迈出已停下的脚步。
	…我想，这就是她的回答吧。
										——《Naicissus》
*/
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N = 400009, M = (1 << 16) + 9;
bool s[N+5][259];
bitset <259> now, dic[N + 9], tot;
int n, m, lstans, to[259], k;
vector<int> B[18][M];
int p[N][18], ccf[18], pep[M], tuu[18][M];
char a[259];
int cnt[M];
bool flag;
ull a1, a2;
bool pp[259];
char buf[1<<23],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
	int sum = 0, nega = 1;
	char ch = getchar();
	while (ch > '9'||ch < '0')
	{
	    if (ch == '-') nega = -1;
		ch = getchar();
	}
	while (ch <= '9'&&ch >= '0')sum=sum*10+ch-'0',ch=getchar();
	return sum * nega;
}
inline ull readull()
{
	ull sum = 0, nega = 1;
	char ch = getchar();
	while (ch > '9'||ch < '0')
	{
	    if (ch == '-') nega = -1;
		ch = getchar();
	}
	while (ch <= '9'&&ch >= '0')sum=sum*10ull+ch-'0',ch=getchar();
	return sum * nega;
}
ull myRand(ull &k1, ull &k2) {
    ull k3 = k1, k4 = k2;
    k1 = k4;
    k3 ^= (k3 << 23);
    k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}
void gen(int n, ull a1, ull a2) {
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < 256; j++)
        {
            s[i][j] = (myRand(a1, a2) & (1ull << 32)) ? 1 : 0;
   //         dic[i][j] = (s[i][j] == 1);
        }
    int res = 0;
    for (int i = 1; i <= n; i++)
    	for (int j = 0; j < 256; j++)
    	{
			res = res << 1;
			res = res + (s[i][j] == 1);
    		if(pp[j]) 
    		{	
    			p[i][j / 16] = res;
    			//cout << i << " " << j << " " << res << endl;
    			B[j / 16][res][tuu[j / 16][res]++] = i;
    			res = 0;
			}
		}
}
inline bool check (int x, int k)
{ 
	int cnt = 0;
	cnt = cnt + pep[p[x][0] ^ ccf[0]];;
	cnt = cnt + pep[p[x][1] ^ ccf[1]];
	if(cnt > k) return 0;
	cnt = cnt + pep[p[x][2] ^ ccf[2]];
	cnt = cnt + pep[p[x][3] ^ ccf[3]];
	if(cnt > k) return 0;
	cnt = cnt + pep[p[x][4] ^ ccf[4]];
	cnt = cnt + pep[p[x][5] ^ ccf[5]];
	cnt = cnt + pep[p[x][6] ^ ccf[6]];
	cnt = cnt + pep[p[x][7] ^ ccf[7]];
	if(cnt > k) return 0;
	cnt = cnt + pep[p[x][8] ^ ccf[8]];
	cnt = cnt + pep[p[x][9] ^ ccf[9]];
	cnt = cnt + pep[p[x][10] ^ ccf[10]];
	cnt = cnt + pep[p[x][11] ^ ccf[11]];
	cnt = cnt + pep[p[x][12] ^ ccf[12]];
	cnt = cnt + pep[p[x][13] ^ ccf[13]];
	cnt = cnt + pep[p[x][14] ^ ccf[14]];
	cnt = cnt + pep[p[x][15] ^ ccf[15]];
	if(cnt > k) return 0;
	return 1;
}
inline void init()
{
	for (int i = 0; i < 16; i++)
		for (int j = 0; j < (1 << 16); j++)
	 		B[i][j].resize(32);
}
int main() 
{
//  freopen("qi.in", "r", stdin);
//	freopen("qi.out", "w", stdout);
	init();
//	return 0;
	n = read(); m = read();
	a1 = readull(), a2 = readull();
	for (int i = 0; i < 256; i++)
		if (i % 16 == 15) pp[i] = 1;
	gen(n, a1, a2);	
	to['0'] = 0;
	to['1'] = 1;
	to['2'] = 2;
	to['3'] = 3;
	to['4'] = 4;
	to['5'] = 5;
	to['6'] = 6;
	to['7'] = 7;
	to['8'] = 8;
	to['9'] = 9;
	to['A'] = 10;
	to['B'] = 11;
	to['C'] = 12;
	to['D'] = 13;
	to['E'] = 14;
	to['F'] = 15;
	//return 0;
	for (int i = 0; i < (1 << 16); i++)
		for (int j = 0; j < 16; j++)
			if((i & (1 << j))) pep[i]++;
	for (int ttt = 1; ttt <= m; ttt++)
	{
		flag = 0;
		char ch = getchar(), awa = 0;
		while((ch > 'F' || ch < 'A') && (ch > '9' || ch < '0')) ch = getchar();
		while((ch <= 'F' && ch >= 'A') || (ch <= '9' && ch >= '0')) a[awa++] = ch, ch = getchar();
		k = read();
		for (int i = 0; i < 64; i++)
		{
			int qwq = to[a[i]];
			//cout << qwq << endl;
			if(qwq & 8) now[i * 4] = 1;
			else now[i * 4] = 0;
			if(qwq & 4) now[i * 4 + 1] = 1;
			else now[i * 4 + 1] = 0;
			if(qwq & 2) now[i * 4 + 2] = 1;
			else now[i * 4 + 2] = 0;
			if(qwq & 1) now[i * 4 + 3] = 1;
			else now[i * 4 + 3] = 0;
		}
		for (int i = 0; i < 256; i++)
			if(lstans) now[i] = (!now[i]);
		int res = 0;
		for (int i = 0; i < 256; i++)
		{
			res = res << 1;
			res = res + (now[i] == 1);
			if (pp[i])
				ccf[i / 16] = res, res = 0;
		}
		for (int i = 0; i < 256; i++)
		{
			res = res << 1;
			res = res + (now[i] == 1);
			if (pp[i])
			{
			//	cout << res << endl;
				int siz = tuu[i / 16][res];
				for (int j = 0; j < siz; j++)
				{
					if (!B[i / 16][res][j]) break;
					if (check(B[i / 16][res][j], k)) flag = 1; 
				}
				res = 0;
			}
			if(flag) break;
		}
		lstans = (flag == 1);
		if(lstans) puts("1");
		else puts("0");
	}
    return 0;
}
```



---

## 作者：myee (赞：9)

### 引言

同步赛，大常数选手卡常题过了！感动！

看到这题——az，什么字符串神仙题？01-Trie 上自动机？

看到 `gen.cpp`，笑了，字典是随机的，因此我们可以考虑乱搞。

说句闲话，有没有人强制离线过的？很好奇。

### 思路

注意到 $k\le15$，因此我们如果把长为 $256$ 的串均分 $16$ 块，每块长为 $16$，那么噪音干扰位（不匹配位）最多只会在其中 $15$ 块中，因此必然会有一块是全匹配的。

对每一块，我们考虑，其状态不会超过 $65536$ 种，而字典大致随机均分其中，每种情况有 $\dfrac{400000}{65536}\approx6$ 的单词满足。

于是把字典中的每种情况插进一个 `vector` 表中，每次暴力查表，查到即有解，否则无解。

判断时可能要 `bitset` 的异或与 `count` 等，建议手写一个，避免卡常。

### 复杂度分析

#### 时空分析

为了更直观，我们把常数写进时间复杂度记号中。

预处理（包括 `count` 预处理）约 $O(256n+16n+65536)$。

单次询问约 $O(16\times6\times\frac{256}{w})$，手写的话 $w$ 约 $64$？

因为又要异或又要 `count`，可能还有一个 $2$ 的常数得乘上。

空间的话稍微证一下是会发现不会爆的。

#### 代码难度分析

还好吧（？），反正是我同步赛唯一做出的题（到时候被不被少爷机卡常就不知道了）。

上代码。

```cpp
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned short usint;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T power(T base,T index,T mod){return((index<=1)?(index?base:1):(power(base*base%mod,index>>1,mod)*power(base,index&1,mod)))%mod;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
const uint N = 400000;bol s[N+1][265];
ullt myRand(ullt &k1,ullt &k2){ullt k3=k1,k4=k2;k1=k4;k3^=(k3<<23);k2=k3^k4^(k3>>17)^(k4>>26);return k2+k4;}
voi gen(uint n,ullt a1,ullt a2){for(uint i=0;i<n;i++)for(uint j=0;j<256;j++)s[i][j]=(myRand(a1,a2)&(1ull<<32))?1:0;}
usint Count[66005];ullt Turn[150];
struct my_bitset
{
	ullt A,B,C,D;
	my_bitset():A(0),B(0),C(0),D(0){}
	my_bitset(bol*T){A=B=C=D=0;for(uint i=0;i<64;i++)A=(A<<1)|T[i];for(uint i=64;i<128;i++)B=(B<<1)|T[i];for(uint i=128;i<192;i++)C=(C<<1)|T[i];for(uint i=192;i<256;i++)D=(D<<1)|T[i];}
	my_bitset(chr*T)
	{
		A=B=C=D=0;
		for(uint i=0;i<16;i++)A=(A<<4)|Turn[(uint)T[i]];for(uint i=16;i<32;i++)B=(B<<4)|Turn[(uint)T[i]];
		for(uint i=32;i<48;i++)C=(C<<4)|Turn[(uint)T[i]];for(uint i=48;i<64;i++)D=(D<<4)|Turn[(uint)T[i]];
	}
	usint get(uint p){return((p<8)?((p<4)?(D>>(p<<4)):(C>>((p&3)<<4))):((p<12)?(B>>((p&3)<<4)):(A>>((p&3)<<4))))&65535;}
	my_bitset operator^(my_bitset b){return b.A^=A,b.B^=B,b.C^=C,b.D^=D,b;}
	voi chg(){A=~A,B=~B,C=~C,D=~D;}
	usint count()
	{
		return
			Count[A&65535]+Count[(A>>16)&65535]+Count[(A>>32)&65535]+Count[(A>>48)&65535]+Count[B&65535]+Count[(B>>16)&65535]+Count[(B>>32)&65535]+Count[(B>>48)&65535]+
			Count[C&65535]+Count[(C>>16)&65535]+Count[(C>>32)&65535]+Count[(C>>48)&65535]+Count[D&65535]+Count[(D>>16)&65535]+Count[(D>>32)&65535]+Count[(D>>48)&65535];
	}
};
my_bitset B[400005],Q;
std::vector<uint>V[25][66005];
chr C[105];
int main()
{
	for(usint i=1;i;i++)Count[i]=Count[i>>1]+(i&1);
	uint n,m,k;ullt a1,a2;bol ok=false;scanf("%u%u%llu%llu",&n,&m,&a1,&a2),gen(n,a1,a2);
	for(uint i=0;i<n;i++){B[i]=s[i];for(uint j=0;j<16;j++)V[j][B[i].get(j)].push_back(i);}
	for(uint i=0;i<10;i++)Turn[i+'0']=i;
	for(uint i=0;i<6;i++)Turn[i+'A']=10+i;
	while(m--)
	{
		scanf("%s%u",C,&k),Q=my_bitset(C);
		if(ok)Q.chg(),ok=false;
		for(uint i=0;i<16&&!ok;i++)
		{
			std::vector<uint>&W=V[i][Q.get(i)];
			for(uint p=W.size()-1;~p;p--)if((B[W[p]]^Q).count()<=k){ok=true;break;}
		}
		puts(ok?"1":"0");
	}
	return 0;
}
```

### 后记

谔，希望不要有卡常题了QAQ

放张图，[参见](https://www.noi.cn/ccf/contentcore/resource/show?ID=152179)。

![](https://cdn.luogu.com.cn/upload/image_hosting/5y9g24mj.png)



---

## 作者：gyh20 (赞：7)

写一个自认为详细的题解？

首先考虑暴力，对于每一次询问暴力枚举匹配串，令 $L=256$，表示串长，时间复杂度 $O(nmL)$ 或 $O(\dfrac{nmL}\omega )$。

发现这个暴力完全没有扩展空间，考虑发掘题目性质。

$1.$ $L$ 为定值 $256$。

$2.$ $k_i\leq 15$。

$3.$ 强制在线是假的。

$4.$ 我们只需要判断是否存在，不需要计数。

$5.$ 原串是随机的，但询问不是。

这些条件使得题目变得可做，但并不需要全部用上。

看到 $k_i\leq 15$，但不是状压，也没法枚举，可以与定值 $256$ 产生联系。

发现若将一个长度为 $256$ 的串分为 $16$ 段，根据鸽巢原理，那么修改 $k_i$ 个数之后至少有一段没变！

$2^{16}=65536$，那么其中的某一段值相同的期望只有 $\dfrac n {65536}$ 个，那么对于每一次询问，可以直接暴力查询每一段相同的几个串，用 bitset 优化匹配即可。

~~于是我们并没有用到性质 3,4~~

实际上，由于询问不是随机的，上面的期望可以卡出一个二倍的常数，所以需要进行一些常数优化（但感觉数据没卡）：

$1.$ 不要访问 bitset，非常慢。

$2.$ 可以用四个 unsigned long long 直接代替一个 bitset。

$3.$ 用链表不要用 vector。

由于考场卡常，且不确定能不能用 popcount，很多东西是手写的，稍稍有点长：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define ull unsigned long long
int st;
char s[400002][256],Q[256];
char rbuf[32000002];
int pt=-1;
ull myRand(ull &k1, ull &k2) {
    ull k3=k1,k4=k2;
    k1=k4;
    k3^=(k3<<23);
    k2=k3^k4^(k3>>17)^(k4>>26);
    return k2+k4;
}
void gen(int n, ull a1, ull a2) {
    for(int i=1;i<=n;++i)
        for(int j=0;j<256;++j)
            s[i][j]=(myRand(a1, a2) & (1ull << 32)) ? 1 : 0;
}
int n,m,cnt,la,head[1048576],popcnt[65536];
struct edge{
	int to,next;
}e[6400002];
inline void add(re int x,re int y){e[++cnt]=(edge){y,head[x]},head[x]=cnt;}
ull a1,a2;
inline void read(char* A){
	re char v=rbuf[++pt];
	while((v<'0'||v>'9')&&(v<'A'||v>'F'))v=rbuf[++pt];
	re int tot=0;
	while((v>='0'&&v<='9')||(v>='A'&&v<='F')){
		re int tmp=(v>='A')?v-'A'+10:v-'0';
		A[tot++]=(tmp&8)>0,A[tot++]=(tmp&4)>0,A[tot++]=(tmp&2)>0,A[tot++]=tmp&1;
		v=rbuf[++pt];
	}
}
ull A[400002],B[400002],C[400002],D[400002];
inline ull read(){
	re ull t=0;re char v=rbuf[++pt];
	while(v<'0')v=rbuf[++pt];
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=rbuf[++pt];
	return t;
}
inline int P(re ull x){return popcnt[x&65535]+popcnt[(x>>16)&65535]+popcnt[(x>>32)&65535]+popcnt[(x>>48)&65535];}
int ed;
int main(){
//	freopen("qi.in","r",stdin);
//	freopen("qi.out","w",stdout);
	fread(rbuf,1,32000000,stdin),n=read(),m=read(),a1=read(),a2=read(),gen(n,a1,a2);
	for(re int i=1;i<=65536;++i)popcnt[i]=popcnt[i>>1]+(i&1);
	for(re int i=1;i<=n;++i){
		for(re int j=0;j<64;++j)A[i]=(A[i]<<1)+s[i][j];
		for(re int j=64;j<128;++j)B[i]=(B[i]<<1)+s[i][j];
		for(re int j=128;j<192;++j)C[i]=(C[i]<<1)+s[i][j];
		for(re int j=192;j<256;++j)D[i]=(D[i]<<1)+s[i][j];
		for(re int j=0;j<4;++j)add((j<<16)+((A[i]>>(((j&3)^3)<<4))&65535),i);
		for(re int j=4;j<8;++j)add((j<<16)+((B[i]>>(((j&3)^3)<<4))&65535),i);
		for(re int j=8;j<12;++j)add((j<<16)+((C[i]>>(((j&3)^3)<<4))&65535),i);
		for(re int j=12;j<16;++j)add((j<<16)+((D[i]>>(((j&3)^3)<<4))&65535),i);
	}
	while(m--){
		read(Q);re int K=read(),ss=0,vv=0;
		re ull a=0,b=0,c=0,d=0;
		for(re int j=0;j<256;++j)Q[j]=Q[j]^la;
		for(re int j=0;j<64;++j)a=(a<<1)+Q[j];
		for(re int j=64;j<128;++j)b=(b<<1)+Q[j];
		for(re int j=128;j<192;++j)c=(c<<1)+Q[j];
		for(re int j=192;j<256;++j)d=(d<<1)+Q[j];
		for(re int j=0;j<4&&ss==0;++j){
			re int T=j*65536+((a>>(((j&3)^3)<<4))&65535);
			for(re int k=head[T];k;k=e[k].next){
				re int x=e[k].to;
				if(P(a^A[x])+P(b^B[x])+P(c^C[x])+P(d^D[x])<=K){ss=1;break;}
			}
		}
		for(re int j=4;j<8&&ss==0;++j){
			re int T=j*65536+((b>>(((j&3)^3)<<4))&65535);
			for(re int k=head[T];k;k=e[k].next){
				re int x=e[k].to;
				if(P(a^A[x])+P(b^B[x])+P(c^C[x])+P(d^D[x])<=K){ss=1;break;}
			}
		}
		for(re int j=8;j<12&&ss==0;++j){
			re int T=j*65536+((c>>(((j&3)^3)<<4))&65535);
			for(re int k=head[T];k;k=e[k].next){
				re int x=e[k].to;
				if(P(a^A[x])+P(b^B[x])+P(c^C[x])+P(d^D[x])<=K){ss=1;break;}
			}
		}
		for(re int j=12;j<16&&ss==0;++j){
			re int T=j*65536+((d>>(((j&3)^3)<<4))&65535);
			for(re int k=head[T];k;k=e[k].next){
				re int x=e[k].to;
				if(P(a^A[x])+P(b^B[x])+P(c^C[x])+P(d^D[x])<=K){ss=1;break;}
			}
		}
		printf("%d\n",la=ss);
	}
	return 0;
}
```


---

## 作者：cmll02 (赞：5)

为啥 D2T1 比 D1T1 水啊？

注意到 $k\le 15$，说明如果两个串可以转换到的话必然有很多相同的位。

不同的位置最多 $15$ 位，所以如果把 $256$ 位的串分成 $16$ 块，那么至少有一块是没有区别的。

枚举哪一块没有区别即可。

由于字典随机生成，每次需要找的期望数量是 $\dfrac n {65536} \times 16$，一次判断次数是 $16$，所以最终程序执行次数在 $\dfrac{nm}{256}$ 级别。可以通过。

具体实现：预处理出第 $i$ 个块的数是 $j$ 的串的位置。


[Code here](https://paste.ubuntu.com/p/7pNpNfGSrT/)

---

## 作者：Warriors_Cat (赞：3)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7738)。

题意：

* 给定 $n$ 个 $256$ 位 $01$ 串 $s_i$ 且 $s_i$ 为随机生成。
* $m$ 次询问，每次询问给一个 $256$ 位 $01$ 串 $x$ 和一个整数 $k$，问是否存在 $s_i$，使得 $x$ 与 $s_i$ 按位异或之后 $1$ 的个数不大于 $k$。
* 强制在线。输入经过压缩处理。
* $1 \le n \le 4\times 10^5, 1 \le m \le 1.2\times 10^5, 0 \le k \le 15$。

NOI2021 中简单但比较有意思的一道题。

---

### Solution：

一看到这题就应该有一种反应：$\boldsymbol{0 \le k \le 15}$ 和 **随机生成** 这两个较为奇怪的条件必定会有些用处。

注意到题目中所给的 $01$ 串均为 $256$ 位，而 $256 = 16\times 16$，再结合 $0 \le k \le 15$ 这个条件，因此我们可以考虑把每个 $256$ 为 $01$ 串看成 $16$ 个 $16$ 位的 $01$ 串。这样处理的好处是：**如果串 $x$ 符合条件，那么串 $x$ 至少有一个 $16$ 位 $01$ 串与 $s_i$ 对应的 $16$ 位 $01$ 串相同**。而这个结论可以用抽屉原理简单得到。

考虑将所有 $s_i$ 的 $16$ 个 $01$ 串都预处理出来。我们开一个 `vector`，其中 `vec[j][k]` 用来存储满足第 $j$ 个 $16$ 位 $01$ 串为 $k$ 的所有 $s_i$。在每次询问的时候，我们把 $x$ 的 $16$ 个 $16$ 位 $01$ 串也处理出来，记为 $y_j(0 \le j \le 15)$，然后对于每一个 $16$ 位 $01$ 串 $y_j$，利用刚才的 `vector` 查找所有满足第 $j$ 个 $16$ 位 $01$ 串为 $y_j$ 的 $s_i$，最后验证这些 $a_i$ 是否满足条件即可。

验证的时候也有一个小 trick：可以先预处理出 $0\sim2^{16}-1$ 中所有数二进制下的 $1$ 的个数。然后验证时仅需要把每个 $16$ 位 $01$ 串异或起来，最后把这些 $1$ 的个数加起来即可。

分析一下时间复杂度。由于 **随机生成**，因此每一次查找的期望次数为 $\dfrac{n}{2^{16}}$，于是根据上述分析，总期望时间复杂度为 $O(m\times 16\times \dfrac{n}{2^{16}}\times 16) = O(\dfrac{nm}{256})$，极限情况下是要 $1.875 \times 10^8$ 次运算。理论上可以通过。

~~本以为需要卡卡常，没想到交一发就过了（~~

---

### Code：

实现起来较为简单，~~大常数选手注意卡常（~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define us unsigned short
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
inline ull read(){
	ull x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 400010, M = 65536;
int n, m, k; ull a1, a2;
bool s[N + 10][256], b[256], lst;
ull myRand(ull &k1, ull &k2) {
    ull k3 = k1, k4 = k2;
    k1 = k4;
    k3 ^= (k3 << 23);
    k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}
void gen(int n, ull a1, ull a2) {
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < 256; j++)
            s[i][j] = (myRand(a1, a2) & (1ull << 32)) ? 1 : 0;
}
vector <int> vec[16][M];
us num[N][16], pcnt[M], c[16];
inline void mian(){
	n = read(); m = read(); a1 = read(); a2 = read();
	gen(n, a1, a2);
	rep(i, 1, n){
		rep(j, 0, 15){
			rep(k, 0, 15){
				num[i][j] += s[i][(j << 4) + k] << k;
			}
			vec[j][num[i][j]].push_back(i);
		}
	}
	rep(i, 1, M - 1) pcnt[i] = pcnt[i >> 1] + (i & 1);
	rep(i, 1, m){
		memset(b, 0, sizeof(b));
		memset(c, 0, sizeof(c));
		rep(j, 0, 63){
			int x = 0;
			char ch = getchar();
			if(ch >= '0' && ch <= '9') x = ch ^ 48;
			else if(ch >= 'A' && ch <= 'F') x = ch - 'A' + 10;
			else{
				--j;
				continue;
			}
			rep(l, 0, 3) b[(j << 2) + l] = (x >> 3 - l) & 1;
		}
		bool ans = 0; k = read();
		if(lst) rep(j, 0, 255) b[j] ^= lst;
		rep(j, 0, 15) rep(l, 0, 15){
			c[j] += b[j * 16 + l]  << l;
		} 
		rep(j, 0, 15){
			for(int t : vec[j][c[j]]){
				int tot = 0;
				rep(l, 0, 15){
					tot += pcnt[num[t][l] ^ c[l]];
					if(tot > k) break;
				}
				if(tot <= k){
					ans = 1;
					break;
				}
			}
			if(ans) break;
		}
		cout << (lst = ans) << '\n';
	}
}
int main(){
	int qwq = 1; while(qwq--) mian(); return 0;
}
```


---

## 作者：huayucaiji (赞：3)

## 解题思路

这道题，怎么看，第一眼都感觉像 $01$ trie 啊。。。。

在同步赛中我发现了 $\sqrt {256}\approx 15$，但是没有好好利用。

其实这就是本题的突破口。

令 $x=2^{16}=65536$，我们把询问串和字典串由 $16$ 进制和 $2$ 进制改为 $x$ 进制。由于在 $2$ 进制下，最多有 $k$ 位不同，而 $k\leq 15$，也就是说在 $16$ 位的 $x$​ 进制数中，字典串和询问串至少一有一位完全相同。​这个由抽屉原理可以证明。

那么思路就很明晰了。我们先预处理字典串，然后用 `vector` 记录在第 $i$ 位上为 $j$ 的询问串的编号。那么对于每一个 `vector`，它的大小平均为 $\frac{n}{x}$。由于数据是用给定函数 `gen` 生成的，数据相对比较随机，我们可以认为大小就基本为 $\frac nx$ 左右​。

对于每一个询问，我们可以枚举在 $x$ 进制下，哪一位与字典串相等，然后取出对应 `vector` 中的所有字典串，暴力算一遍看看是否符合要求即可。这样时间复杂度为 $O(m\cdot 16\cdot \frac nx\cdot 256)$。把 $x=65536$ 代入，复杂度为 $O(\frac{nm}{16})$。这不肯定爆炸吗？

我们考虑如何继续优化一下。

我们发现，检查字典串和询问串是否符合要求的时间复杂度过高。想办法优化。

我们可以先预处理出 $\forall i\in [0,x),i\in N^+$​​ 的 `popcnt`，即二进制下 $1$​​ 的位数，然后对于 $x$​​ 进制下的每一位，我们就可以快速求出这一位上有多少位二进制是不同的这样，时间复杂度变为了 $O(m\cdot 16\cdot \frac nx\cdot 16)=O(\frac{nm}{256})$​​ 。把 $n,m$​​ 的极值代入，时间复杂度大约为 $O(1.8*10^8)$​​​ ​​。

显然我们还要卡卡常。

还是再检验，我们实时比较 $k$ 和当前二进制不同位数，若已经超过了 $k$，直接退出，所以时间是跑不满的。在加个 快读，基本就过了。~~当然你要保证你的其他常数不是特别大。~~

如果你在考场上想再稳一些，还可以做以下操作：

- 把 `vector` 改成链表。
- 不要用 `bitset`。、
- 循环展开
- ……（可以参考其他大佬的博客）

## 代码

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
using namespace std;

int read() {
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch>='A'&&ch<='Z')
			return ch-'A'+10;
		ch=getchar();
	}
	if(ch>='0'&&ch<='9') {
		return ch-'0';
	}
}

const int MAXN=4e5+10; 

typedef unsigned long long ull;
ull n,m,a1,a2;
int lastans;
bool s[MAXN][256];
int cnt[256*256],a[20],b[MAXN][20];
vector<int> v[17][256*256]; 

ull myRand(ull &k1, ull &k2) {
    ull k3 = k1, k4 = k2;
    k1 = k4;
    k3 ^= (k3 << 23);
    k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}

void gen(int n, ull a1, ull a2) {
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < 256; j++)
            s[i][j] = (myRand(a1, a2) & (1ull << 32)) ? 1 : 0;
}

int popc(int x) {
	int ret=0;
	while(x) {
		if(x&1) {
			ret++;
		}
		x>>=1;
	}
	return ret;
}

void insert(int k) {
	for(int i=1;i<=16;i++) {
		int w=0;
		for(int j=0;j<16;j++) {
			w=w*2+(s[k][(i-1)*16+j]? 1:0);
		}
		b[k][i]=w;
		v[i][w].push_back(k);
	}
}

bool ok(int j,int k) {
	for(int i=1;i<=16;i++) {
		k-=cnt[b[j][i]^a[i]];
		if(k<0) {
			return 0;
		}
	}
	return 1;
}
int check(int k) {
	for(int i=1;i<=16;i++) {
		int sz=v[i][a[i]].size();
		for(int j=0;j<sz;j++) {
		//	puts("ohhhh");
			if(ok(v[i][a[i]][j],k)) {
				return 1;
			}
		}
	}
	return 0;
}

signed main() {
	freopen("qi.in","r",stdin);
	freopen("qi.out","w",stdout);

	for(int i=0;i<256*256;i++) {
		cnt[i]=popc(i);
	}
	cin>>n>>m>>a1>>a2;
	
	gen(n,a1,a2);
	for(int i=1;i<=n;i++) {
		insert(i);
	}
	
	while(m--) {
		for(int i=1;i<=16;i++) {
			int x=read(),y=read(),z=read(),xx=read();
			a[i]=x*16*16*16+y*16*16+z*16+xx;
			if(lastans) {
				a[i]=(256*256-1)^a[i];
			}
		}
		int k;
		scanf("%d",&k);
		printf("%d\n",lastans=check(k));
	}

	fclose(stdin);
	fclose(stdout);
	return 0;
}


```



---

## 作者：wsyhb (赞：3)

注：本题为 NOI2021 D2T1。

## 题意简述

给定由 $n$ 个长度为 $256$ 的 01 串组成的字典，然后有 $m$ 个询问，每次询问给出一个长度为 $256$ 的 01 串和整数 $k$，问字典中是否存在一个 01 串，和询问的 01 串相比，不同的位数 $\le k\;(0 \le k \le 15)$。

字典的生成方式为：输入种子 $a_1,a_2$，将 $a_1,a_2$ 传入**题目所给的随机函数**中，保证 $a_1,a_2$ **随机生成**。

本题强制在线，加密方式为：每次询问给出的 01 串的每一位，都要异或上一次的答案（存在为 $1$，否则为 $0$，第一次将其视为 $0$）。

**数据范围**：$1 \le n \le 4 \times 10^5$，$1 \le m \le 1.2 \times 10^5$，$a_1,a_2 \in [0,2^{64}-1]$。

## 题解

暴力很好做：把 $n$ 个 01 串每个都拿来和当前询问 01 串比较，时间复杂度 $O(256nm)$。

考虑优化暴力：由于 $O(nm)$ 的时间复杂度就已经爆炸，因此必须要减少比较的 01 串个数。

注意到 $k \le 15$，又因为长度为 $256=16 \times 16$，于是把每个 01 串**均匀划分为 $16$ 段**，那么与当前询问串不同位数 $\le 15$ 的 01 串，**必然有至少一段与当前询问串完全相同**。

预处理 $id[i][j]$，用于存储字典中第 $i$ 段为 $j$ 的所有 01 串的编号。  
（第 $i$ 段为 $j$：将这一段看成二进制数，其值为 $j$）

那么枚举相同的是哪一段，就可以只比较字典中有至少一段与当前询问串完全相同的 01 串。

比较方法为：预处理 $[0,2^{16}-1]$ 中每个数在二进制下 $1$ 的个数，然后**对于 $16$ 段中的每一段，将要比较的串和当前询问串异或，异或值在二进制下 $1$ 的个数即为这一段不同的位数。**

由于字典中的 01 串随机生成，单次询问期望比较的 01 串个数为 $O(16 \times \dfrac{n}{65536})$，**总时间复杂度为 $O(\dfrac{nm}{256})$**。

## 代码

听说这题很卡常？个人觉得还好——除了 **$16$ 段比较的部分用了循环展开**，其它也没有特意卡常。

注：循环展开的部分，可以每加 $1$ 次就判断一下是否 $>k$，也可以通过此题。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 400000;
bool s[N+1][256];
namespace generator
{
	typedef unsigned long long ull;
	ull myRand(ull &k1, ull &k2) {
	    ull k3 = k1, k4 = k2;
	    k1 = k4;
	    k3 ^= (k3 << 23);
	    k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
	    return k2 + k4;
	}
	void gen(int n, ull a1, ull a2) {
	    for (int i = 1; i <= n; i++)
	        for (int j = 0; j < 256; j++)
	            s[i][j] = (myRand(a1, a2) & (1ull << 32)) ? 1 : 0;
	}
}
vector<int> id[16][65536];
char str[70];
int val[N+1][16],cnt_bits[65536],vis[N+1];
int main()
{
	int n,m;
	unsigned long long a1,a2;
	scanf("%d%d%llu%llu",&n,&m,&a1,&a2);
	generator::gen(n,a1,a2);
	for(int k=1;k<=n;++k)
		for(int i=0;i<16;++i)
		{
			int l=i<<4,r=l^15,v=0;
			for(int j=l;j<=r;++j)
				v=v<<1|s[k][j];
			val[k][i]=v;
			id[i][v].push_back(k);
		}
	for(int i=1;i<65536;++i)
		cnt_bits[i]=cnt_bits[i>>1]+(i&1);
	int ans=0;
	for(int t=1;t<=m;++t)
	{
		int k;
		scanf("%s%d",str,&k);
		for(int i=0;i<16;++i)
		{
			val[0][i]=0;
			int l=i<<2,r=l^3;
			for(int j=l;j<=r;++j)
			{
				int v=str[j]>='0'&&str[j]<='9'?str[j]^48:str[j]-'A'+10; 
				val[0][i]=val[0][i]<<4|v;
			}
			if(ans)
				val[0][i]^=65535;
		}
		ans=0;
		for(int i=0;i<16;++i)
		{
			int v=val[0][i];
			for(vector<int>::iterator it=id[i][v].begin();it!=id[i][v].end();++it)
			{
				int x=*it;
				if(vis[x]!=t)
				{
					vis[x]=t;
					int cnt_dif=0;
					cnt_dif+=cnt_bits[val[x][0]^val[0][0]];
					cnt_dif+=cnt_bits[val[x][1]^val[0][1]];
					if(cnt_dif>k)
						continue;
					cnt_dif+=cnt_bits[val[x][2]^val[0][2]];
					cnt_dif+=cnt_bits[val[x][3]^val[0][3]];
					if(cnt_dif>k)
						continue;
					cnt_dif+=cnt_bits[val[x][4]^val[0][4]];
					cnt_dif+=cnt_bits[val[x][5]^val[0][5]];
					if(cnt_dif>k)
						continue;
					cnt_dif+=cnt_bits[val[x][6]^val[0][6]];
					cnt_dif+=cnt_bits[val[x][7]^val[0][7]];
					if(cnt_dif>k)
						continue;
					cnt_dif+=cnt_bits[val[x][8]^val[0][8]];
					cnt_dif+=cnt_bits[val[x][9]^val[0][9]];
					if(cnt_dif>k)
						continue;
					cnt_dif+=cnt_bits[val[x][10]^val[0][10]];
					cnt_dif+=cnt_bits[val[x][11]^val[0][11]];
					if(cnt_dif>k)
						continue;
					cnt_dif+=cnt_bits[val[x][12]^val[0][12]];
					cnt_dif+=cnt_bits[val[x][13]^val[0][13]];
					if(cnt_dif>k)
						continue;
					cnt_dif+=cnt_bits[val[x][14]^val[0][14]];
					cnt_dif+=cnt_bits[val[x][15]^val[0][15]];
					if(cnt_dif<=k)
					{
						ans=1;
						break;
					}
				}
			}
			if(ans==1)
				break;
		}
		printf("%d\n",ans);
	}
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

神必随机题，被各种乱杀。                 

题意：有 $n$ 个长为 $256$ 的原串，现在给出多个长为 $256$ 的询问串询问是否有至少一个原串满足这个询问串和原串只有至多 $k$ 个位置不一样，其中 $k$ 随每个询问串变化。

我们考虑字典串是随机的，由于 $k$ 只有 $15$ 以内所以如果我们把长为 $256$ 的串分成长为 $16$ 的 $16$ 个块的话，就必定有一个块满足询问串的块和匹配原串的块长的一模一样，所以我们如果直接枚举这个匹配块的话，由于字典串随机所以此时具有这个匹配块的期望字典串数量很少，所以我们把这些字典串拿出来暴力匹配即可。             

这里介绍几个比较实用的卡常技巧：              

- 我们在预处理时有一个 $O(256n)$ 的时间复杂度，这里大家注意实现的时候常数不能超过 $2$ 不然基本上就 T 了；              

- 在暴力匹配两个串的时候可以写 bitset 或者直接分块算 $1$ 的数量，这里我用的是分块算 $1$ 的个数。             

- 换 vector ；

---

## 作者：1saunoya (赞：2)

这里是一个稳定正确的做法（）

注意到 $k \leq 15$。

那么我们可以把这个分成 $\text{16}$ 个块。

每一块为 $\text{65536}$。

容易发现有一个块里面肯定是没有翻转的。

由于字典是随机的，符合的个数期望是 $400000 \div 65536$。

然后我们枚举哪一块没有完全被翻转，$\text{bitset}$ 比对一下就可以了。

单次期望复杂度 $\frac{256}w{}\times \frac{n}{65536}\times 16 \approx \frac{n}{64w}$，可以通过本题。


```cpp
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i < y; i++)
#define all(v) begin(v), end(v)
#ifdef LOCAL
#include "C:\Users\15328\Desktop\tmp.hpp"
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif
using namespace std;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
template<class T>
istream &operator>> (istream &in, vector<T> &v) {
 for (auto &x : v) {
  in >> x;
 }
 return in;
}
inline int gc() {
 static char buf[1048576], *p1 = buf, *p2 = buf;
 return (p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1048576, stdin), p1 == p2) ? EOF : *p1++;
}
void read(int &x) {
 char c = gc();
 while (!isdigit(c)) {
  c = gc();
 }
 x = 0;
 while (isdigit(c)) {
  x = x * 10 + c - '0';
  c = gc();
 }
}
void read(unsigned long long &x) {
 char c = gc();
 while (!isdigit(c)) {
  c = gc();
 }
 x = 0;
 while (isdigit(c)) {
  x = x * 10 + c - '0';
  c = gc();
 }
}
void read(char &x) {
 x = gc();
 while (isspace(x)) {
  x = gc();
 }
}
typedef unsigned long long ull;
int n, m;
ull a1, a2;
vector<int> a[16][65536];
vector<bitset<256>> s;
vector<array<int, 16>> ss;
inline ull myRand(ull &k1, ull &k2) {
 ull k3 = k1, k4 = k2;
 k1 = k4;
 k3 ^= (k3 << 23);
 k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
 return k2 + k4;
}
void gen(int n, ull a1, ull a2) {
 s.resize(n);
 rep (i, 0, n)
  rep (j, 0, 256)
   s[i][j] = (myRand(a1, a2) & (1ull << 32)) ? 1 : 0;
 ss.resize(n);
 rep (i, 0, n) {
  rep (j, 0, 16) {
   int l = j * 16;
   int r = (j + 1) * 16;
   int x = 0;
   rep (k, l, r) {
    x = x << 1 | s[i][k];
   }
   ss[i][j] = x;
  }
 }
}
bool ans;
bitset<256> t;
array<int, 16> tt;
void solve() {
 int tmp = 0;
 rep (j, 0, 64) {
  char c;
  read(c);
  int a;
  if (c <= '9') {
   a = c - 48;
  } else {
   a = c - 55;
  }
  t[tmp++] = a >> 3;
  t[tmp++] = a >> 2 & 1;
  t[tmp++] = a >> 1 & 1;
  t[tmp++] = a & 1;
 }
 if (ans) {
  rep (i, 0, 256) {
   t[i] = !t[i];
  }
 }
 ans = false;
 int K;
 read(K);
 rep (j, 0, 16) {
  int l = j * 16;
  int r = (j + 1) * 16;
  int x = 0;
  rep (k, l, r) {
   x = x << 1 | t[k];
  }
  tt[j] = x;
 }
 int *T = tt.data();
 rep (j, 0, 16) {
  const auto &v = a[j][*T++];
  for (const auto &i : v) {
   if ((int) (t ^ s[i]).count() <= K) {
    ans = true;
    return;
   }
  }
 }
}
int main() {
 read(n);
 read(m);
 read(a1);
 read(a2);
 gen(n, a1, a2);
 rep (i, 0, n) {
  rep (j, 0, 16) {
   a[j][ss[i][j]].emplace_back(i);
  }
 }
 rep (i, 0, m) {
  solve();
  if (ans) {
   putchar('1');
  } else {
   putchar('0');
  }
  putchar('\n');
 }
}
```

---

## 作者：KaguyaH (赞：2)

记 $256$​ 位 01 串为 Z 串。对于两 Z 串 $s, t$，定义 $c(s, t) = \sum [s_i \neq t_i]$。

给出包含 $n$​​ 个 Z 串 $s_{1 \cdots n}$​​ 的字典 $S$​​。$m$​​​ 次询问，每次给出 Z 串 $t_i$​​ 与非负整数 $k_i$，问是否存在 $s_i$ 满足 $c(s_i, t) \leq k_i$​。

$S$ 随机生成，$1 \leq n \leq 4 \times 10^5$，$1 \leq m \leq 1.2 \times 10^5$，$0 \leq k_i \leq 15$。

---

考虑将所有 Z 串分为 $16$ 段分别压入整数中，Z 串 $s$ 的第 $i$ 段记为 $s_i(0 \le i \lt 16)$。

发现 $a_1, a_2$​​ 随机，又发现 $k \le 15$​​​​，考虑到 $c(s_j, t_i) \le k \implies \exists s_{j, p} = t_{i, p}$​​，于是考虑用一不定长数组 $id_{i, j}$​​ 存储所有满足 $s_{l, i} = j$​​ 的 $s_l$​​ 的编号 $l$​​​。

$\forall 0 \le j \lt 16$，访问所有的 $id(j, t_{i, j})$​，判断是否满足条件即可。

> 这里的判断可以用 $\operatorname{xor}$​​ & $\operatorname{lowbit}$​​ 进行优化。
>
> 我们将每四段压成一个 `long long unsigned int` 存储，将四对 `long long unsigned int` 分别异或，重复取 $\operatorname{lowbit}$ 即可。
>
> 这样其时间复杂度为 $\mathcal O(res)$​ 的。
>
> 一旦找到超过 $k_i$ 位不同就不再继续寻找。这样可以将一个 $256$ 的常数变为 $\mathcal O(k_i)$​​。

$16$​​ 与 $k_i$​​ 同阶，时间复杂度 $\mathcal O(\frac{nmk^2}{2^k})$​，空间复杂度 $\mathcal O(k(n + 2^k))$​，复杂度稍大，可过。

---

（删去调试语句的考场代码如下，可能稍有定义上的不同。将靠前的位置压入了低位。）

```cpp
# include <cctype>
# include <ciso646>
# include <cstdio>
# include <vector>

namespace Main {
  namespace File {
    struct File {
      File() { freopen("qi.in", "r", stdin), freopen("qi.out", "w", stdout); }
      compl File() { fclose(stdin), fclose(stdout); }
    } file;
  }
  typedef unsigned int uint;
  typedef short unsigned int hu;
  typedef long long unsigned int llu;
  typedef std::vector<uint> vector;
  template <typename T> static inline const T lowbit(const T x) { return x bitand ~x + 1; }
  static const uint N(4e5);
  static uint n, m;
  static llu a1, a2;
  static llu s[N + 1][4];
  static llu b[4];
  static hu k;
  static vector id[16][1 << 16];
  static bool vis[N + 1];
  static bool lastans;
  static inline const llu myRand(llu& k1, llu& k2) {
    llu k3(k1), k4(k2);
    k1 = k4, k3 ^= k3 << 23, k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
  }
  static inline const void gen(const uint n, llu a1, llu a2) {
    for (register uint i = 1; i <= n; i++)
      for (hu j(0); j < 4; ++j) for (hu k(0); k < 64; ++k) s[i][j] or_eq (myRand(a1, a2) >> 32 & 1) << k;
  }
  static inline const void init() {
    for (hu j(0); j < 16; ++j) for (register uint i(1); i <= n; ++i)
      id[j][s[i][j / 4] >> j % 4 * 16 & (1 << 16) - 1].push_back(i);
  }
  static inline const hu count(const llu s[4], const llu t[4]) {
    hu r(0);
    for (hu i(0); i < 4; ++i) {
      llu u(s[i] xor t[i]);
      while (r <= k and u) ++r, u ^= lowbit(u);
    }
    return r;
  }
  static inline const hu reverse4(const hu x) {
    hu o(x >> 0 bitand 1), p(x >> 1 bitand 1), q(x >> 2 bitand 1), r(x >> 3 bitand 1);
    return o << 3 bitor p << 2 bitor q << 1 bitor r << 0;
  }
  static inline const void solve() {
    static char t[64 + 1]; /*static hu k;*/ scanf("%s%hu", t, &k), b[3] = b[2] = b[1] = b[0] = 0;
    for (hu i(0); i < 64; ++i) b[i / 16] or_eq (const llu)reverse4(isdigit(t[i]) ? t[i] - '0' : t[i] - 'A' + 10) << i % 16 * 4;
    if (lastans) b[0] = ~b[0], b[1] = ~b[1], b[2] = ~b[2], b[3] = ~b[3];
    for (hu i(0); i < 4; ++i) for (hu l(0); l < 4; ++l) for (uint j(0); j < id[i * 4 + l][b[i] >> l * 16 & (1 << 16) - 1].size(); ++j)
      if (count(s[id[i * 4 + l][b[i] >> l * 16 & (1 << 16) - 1][j]], b) <= k) { puts("1"), lastans = 1; return; }
    puts("0"), lastans = 0;
  }
  static inline const void main() {
    scanf("%u%u%llu%llu", &n, &m, &a1, &a2), gen(n, a1, a2), init();
    for (register uint i(0); i < m; ++i) solve();
  }
}

signed int main() { Main::main(); return 0; }
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：2)

考虑到单词随机，每一个询问能匹配到的单词期望之多为 1。

再考虑到 $k$ 最大为 15，随机取 $p$ 个位置的时候，**如果有解** 这 $p$ 个位置 **全匹配** 的概率至少为 $\left(1-\frac{k}{256}\right)^p$。

于是，我们在所有询问之前提前设定这 $p$ 个位置，并对这 $p$ 个位置上的所有 $2^p$ 可能的组合，处理出该组合在哪些单词里出现。

来回答询问，找到询问中这 $p$ 个位置对应的组合。接下来可以找到所有在这 $p$ 个位置上和该询问一样的单词，将它们暴力 bitset 尝试匹配即可。

这样每一次询问平均要做 $\frac{n}{2^k}$ 次 bitset 匹配。当 $k$ 太小这和暴力没有本质区别，但是当 $k$ 太大正确率过于小。于是可以选 $q$ 套 $p$ 个位置。

对于一个无解询问，不可能找到解，但是对于一个有解询问可能会失败，并需要分析失败概率。通过 $q$ 套位置中 **至少一个** 的概率至少为

$$1-\left(1-\left(1-\frac{k}{256}\right)^p\right)^q$$

通过所有询问的概率则为

$$\left(1-\left(1-\left(1-\frac{k}{256}\right)^p\right)^q\right)^m$$

而总共需要进行

$$\frac{nmq}{2^k}$$

次 bitset 匹配。需要平衡正确率和所用时间，我取了 $k=16$ $q=36$。这样通过所有询问的概率为 $99.7\%$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define pb push_back
#define mp make_pair

using ll = long long;
using pii = pair<int, int>;
//#define int ll

const int MOD = 1000000007;

typedef unsigned long long ull;
const int maxN = 400000;
bitset<256> s[maxN + 5];
void gen(int n, ull a1, ull a2) {
  for (int i = 1; i <= n; i++)
    for (int j = 0; j < 256; j++) {
      ull k3 = a1, k4 = a2;
      a1 = k4;
      k3 ^= (k3 << 23);
      a2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
      s[i][j] = ((a1 + a2) & (1ull << 32)) ? 1 : 0;
    }
}

const int ITS = 36;
const int BT = 16;
int pos[ITS][BT];
int reality[ITS][400005];
int reality_begin[ITS][(1 << BT) + 1];
int tva[400005];

mt19937 rng(108616);

void init(int n) {
  for (int idx = 0; idx < ITS; idx++) {
    set<int> poss;
    while (poss.size() != BT)
      poss.insert(rng() % 256);
    copy(all(poss), pos[idx]);
    for (int i = 1; i <= n; i++) {
      int va = 0;
      for (int j = 0; j < BT; j++)
        va |= (s[i][pos[idx][j]] << j);
      tva[i] = va;
      reality_begin[idx][va]++;
    }
    for (int i = 1; i <= (1 << BT); i++)
      reality_begin[idx][i] += reality_begin[idx][i - 1];
    for (int i = 1; i <= n; i++)
      reality[idx][--reality_begin[idx][tva[i]]] = i;
  }
}

bitset<256> q;
int pp[256];

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  int n, m;
  ull a1, a2;
  cin >> n >> m >> a1 >> a2;
  gen(n, a1, a2);
  init(n);
  for (char c = '0'; c <= '9'; c++)
    pp[c] = c - '0';
  for (char c = 'A'; c <= 'F'; c++)
    pp[c] = c - 'A' + 10;
  int la = 0;
  while (m--) {
    string st;
    cin >> st;
    for (int i = 0; i < 64; i++)
      for (int j = 0; j < 4; j++)
        q[i * 4 + j] = (pp[st[i]] & (1 << (3 - j)));
    if (la)
      for (int i = 0; i < 256; i++)
        q[i] = q[i] ^ 1;
    int k;
    cin >> k;
    int found = 0;
    for (int idx = 0; idx < ITS; idx++) {
      int va = 0;
      for (int j = 0; j < BT; j++)
        va |= (q[pos[idx][j]] << j);
      int be = reality_begin[idx][va], en = reality_begin[idx][va + 1];
      for (int i = be; i < en; i++)
        if ((q ^ s[reality[idx][i]]).count() <= k) {
          found = 1;
          break;
        }
      if (found)
        break;
    }
    cout << (la = found) << '\n';
  }
  return 0;
}
```

---

## 作者：ricky0916 (赞：1)

~~建议降绿以下~~

注意到 $ k_i\le15=16-1=\frac{256}{16} $，于是~~容易~~想到把 $256$ 位的 $01$ 串和收到的 $16$ 进制串分成 $16$ 组，每组可以用一个 $x$ 表示（ $0\le x\le65535$ ）

接下来根据~~小学学的~~抽屉（鸽巢）原理得到其中必有至少一位相同，所以枚举每一位，如果有 $a_i$ 与收到的串这一位相同，那么暴力判断是否不受干扰，这样就可以得到答案。第 $i$ 位为 $x$ 的所有 $a_k$ 的编号可以用 vector 或者链式前向星保存。

~~（我赛后写链式前向星的原因不是为了卡常，只是为了练习罢了）~~

注意到数据是随机生成的，那么我们可知期望复杂度为 $ O(\frac{n}{65536}\times 16\times m) $ 可能会与这个复杂度有些差别 ~~（反正就是O(能过)就行了）~~ 

~~综上所述，本题为小学生都会的题~~

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
int ask[256],n,m,ki,temp[400010][20],head[20][70000],cnt,ycl[70000];
struct edge{
	int to,nxt;
}eg[8000000];
ull a1,a2;
bool lastans;
inline int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x;
}
ull asdf(ull &k1,ull &k2){
	ull k3=k1,k4=k2;
	k1=k4;
	k3^=(k3<<23);
	k2=k3^k4^(k3>>17)^(k4>>26);
	return k2+k4;
}
void add(int x,int y,int idx){
	eg[++cnt]=(edge){idx,head[x][y]};
	head[x][y]=cnt;
}
void gun(int n,ull a1,ull a2){
	for(int i=1;i<=n;i++){
		for(int j=0;j<16;j++){
			for(int k=0;k<16;k++){
				temp[i][j]=(temp[i][j]<<1)|((asdf(a1,a2)&(1ull<<32))?1:0);
			}
			add(j,temp[i][j],i);
		}
	}
}
inline int hhh(char ch){
	if(ch<='9') return ch-'0';
	return ch-'A'+10;
}
inline void gt(){
	char ch=getchar();
	while(ch<'0'||ch>'9'&&ch<'A'||ch>'F') ch=getchar();
	for(int i=0;i<16;i++){
		ask[i]=0;
		for(int j=0;j<4;j++){
			ask[i]=(ask[i]<<4)|hhh(ch);
			ch=getchar();
		}
		ask[i]^=((lastans<<16)-lastans);
	}
}
int ws(int x){
	int ret=0;
	while(x) ++ret,x-=x&(-x);
	return ret;
}
int main(){
//	freopen("qi.in","r",stdin);
//	freopen("qi.out","w",stdout);
	n=read();
	m=read();
	scanf("%llu%llu",&a1,&a2);
	gun(n,a1,a2);
	for(int i=0;i<65536;i++) ycl[i]=ws(i);
	while(m--){
		gt();
		ki=read();
		lastans=0;
		for(int i=0;i<16;i++){
			for(int j=head[i][ask[i]];j;j=eg[j].nxt){
				int tmp=0;
				for(int k=0;k<16;k++){
					tmp+=ycl[ask[k]^temp[eg[j].to][k]];
				}
				if(tmp<=ki){
					lastans=1;
					break;
				}	
			}
			if(lastans) break;
		}
		putchar(lastans+'0');
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：CSP_Sept (赞：0)

## 背景

- **UPD 20231009**：本来 2021 年 8 月 2 日就找到了更高效稳定的优化方法，一直留着坑，所以重构了一下。
- [原题解](https://www.luogu.com.cn/paste/9flkzluq)

观察 hash 好题。

## 简述

给定二进制字典 $S_n$ 和 $m$ 个二进制询问串（长度均为 $256$），询问对于每个询问串， $S$ 中是否存在 $S_i$，使得 $S_i$ 与询问串不同的字符不超过 $k_i$。

$1 \le n \le 4 \times {10}^5$，$1 \le m \le 1.2 \times {10}^5$，$0 \le k_i \le 15$。

## 解法

首先注意到数据范围里 $k_i\le 15$，这启示我们往奇怪的地方想。

考虑把 $S$ 和询问串都分为 $16$ 段。

先预处理一遍 $S$，将 $16\cdot n$ 段转换成十进制扔进 hash 表里，同时记录每一段所在的字符串编号。

然后对于每个询问串，分成 $16$ 个数分别在对应的 hash 表里找相同的数。找到了就用 $in$ 存储该数所在字符串的下标。接下来遍历 $s_{in}$，找不同的字符数并统计，判断 $cnt$ 有没有超过 $k$。

根据抽屉原理，上述方法复杂度正确。

## 代码

### 优化

我们可以考虑预处理出字典串中分为的 $16\cdot n$ 段全部进行预处理；选用 `__builtin_popcount()` 函数；加入剪枝等方式提高代码效率。

### 函数

- `Tr_rea` 把 16 进制串变成 2 进制
- `Tr_sol` 处理强制在线
- `Tr_num` 把二进制分成 $16$ 段转换成 int
- `Dif_bet` 判断 $a,b$ 之间不同的位数

### 代码

```cpp
#include <cstdio>

#define ull unsigned long long
#define N 400000
#define T 65536
using namespace std;
inline int rd(){
	char c;
	bool flag = 0;
	while((c = getchar()) < '0' || c > '9')
	    if(c == '-') flag = 1;
	int res = c - '0';
	while((c = getchar()) >= '0' && c <= '9')
	    res = (res << 3) + (res << 1) + c - '0';
	return flag ? -res : res;
}
bool r[300], s[N + 1][300];
inline int Pre(char c){
	if(c >= '0' && c <= '9') return c - '0';
	else return 10 + c - 'A';
}
inline int Tr_sol(int op, int x){
	if(!op) return x;
	return 15 - x;
}
inline int Tr_num(bool r[], int l){
	int ans = 0;
	int base = 1;
	for(int i = l + 15 ; i >= l ; i--){
		ans += base * r[i];
		base *= 2;
	}
	return ans;
}
ull myRand(ull &k1, ull &k2){
    ull k3 = k1, k4 = k2;
    k1 = k4;
    k3 ^= (k3 << 23);
    k2 = k3 ^ k4 ^ (k3 >> 17) ^ (k4 >> 26);
    return k2 + k4;
}
void gen(int n, ull a1, ull a2){
    for(int i = 1 ; i <= n ; i++)
        for(int j = 0 ; j < 256 ; j++)
            s[i][j] = (myRand(a1, a2) & (1ull << 32)) ? 1 : 0;
}
char c[300];
ull a1, a2;
int n, m, k, ans = 0, in;
int len[20][T];
int h[20][T][20];
int tr[16], y[64];
inline void Sol(){
	scanf("%s", c);
	for(int i = 0 ; i < 64 ; i++)
		y[i] = Tr_sol(ans, Pre(c[i]));
	for(int i = 0 ; i < 64 ; i += 4){
		tr[i / 4] = y[i + 3];
		tr[i / 4] += y[i] * 4096 + y[i + 1] * 256 + y[i + 2] * 16; 
	}
	k = rd();
	for(int i = 0 ; i < 16 ; i++){
		int x = tr[i];
		int nu = i;
		int siz = len[nu][x];
		if(siz == 0) continue;
		for(int j = 0 ; j < siz ; j++){
			in = h[nu][x][j];
			int cnt = 0;
			for(int o = 0 ; o < 256 ; o += 16){
			    int y = Tr_num(s[in], o);
			    int z = tr[o / 16];
				cnt += __builtin_popcount(z ^ y);
				if(cnt > k) break;
			}
			if(cnt <= k){
			    ans = 1;
				puts("1");
				return;
			}
		}
	}
	ans = 0;
	puts("0");
}
int main(){
	// freopen("qi.in" , "r", stdin );
	// freopen("qi.out", "w", stdout);
	n = rd(), m = rd();
	scanf("%llu%llu", &a1, &a2);
	gen(n, a1, a2);
	for(int i = 1 ; i <= n ; i++){
		for(int j = 0 ; j < 16 ; j++){
			int x = Tr_num(s[i], j * 16);
			h[j][x][len[j][x]++] = i;
		}
	}
	while(m--)
		Sol();
	return 0;
}
```

共计 101 行，码量 2.18 KB。足够通过此题。

---

## 作者：wmy_goes_to_thu (赞：0)

数据随机是个非常重要的东西。

注意到 $15<16$，考虑把串拆成 $16$ 个 `unsigned short`。

那么，因为数据随机，所以对于每一个段中的每一个数，只有大概 $\dfrac{4\times 10^5}{2^{16}}$ 个大串在这段组成的数是这个数，用 `vector` 或前向星来存储。

考虑对于每次询问，可以枚举所有可能的数。那么如何判断一个数是否可能？鸽巢原理，肯定这 $16$ 个段有一个段和查询的串在这段组成的数完全相等，所以在这个 `vector` 里跑一编所有的就行了。

复杂度 $O(\dfrac{n\times m\times 16^2}{2^{16}})$。

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
char cc[1005];
int dy[1005],pc[1<<16];
struct div_16
{
	unsigned short a[16];
	void init(){for(int i=0;i<16;i++)a[i]=0;}
}s[400005];
int TOT=0,ind[16][1<<16],mw[16][1<<16],nxt[10000005],zhi[10000005];
void addedge(int u1,int u2,int v)
{
	if(!ind[u1][u2])ind[u1][u2]=++TOT;
	else nxt[mw[u1][u2]]=++TOT;
	mw[u1][u2]=TOT,zhi[TOT]=v;
}
ull myRand(ull &k1,ull &k2)
{
	ull k3=k1,k4=k2;
	k1=k4,k3^=(k3<<23);
	k2=k3^k4^(k3>>17)^(k4>>26);
	return k2+k4;
}
void gen(int n,ull a1,ull a2)
{
	for(int i=1;i<=n;i++)for(int j=0;j<16;j++)for(int k=0;k<16;k++)
		s[i].a[j]|=(1<<15-k)*((myRand(a1,a2)&(1ull<<32))?1:0);
	for(int i=1;i<=n;i++)for(int j=0;j<16;j++)addedge(j,s[i].a[j],i);
}
int main()
{
	freopen("qi.in","r",stdin);
	freopen("qi.out","w",stdout);
	for(int i=1;i<(1<<16);i++)pc[i]=pc[i^(i&-i)]+1;
	for(int i=0;i<10;i++)dy['0'+i]=i;
	for(int i='A';i<='F';i++)dy[i]=i-'A'+10;
	int n,m;
	unsigned short zz=0,lastans=0;
	ull a1,a2;
	scanf("%d%d%llu%llu",&n,&m,&a1,&a2);
	gen(n,a1,a2);
	while(m--)
	{
		div_16 f;
		f.init();
		int kk,tt=0,flag=0;
		scanf("%s%d",cc+1,&kk);
		for(int i=0;i<16;i++)for(int j=0;j<4;j++)
			f.a[i]|=(1<<(3-j<<2))*dy[cc[++tt]];
		for(int i=0;i<16;i++)f.a[i]^=zz-lastans;
		for(int i=0;i<16;i++)
		{
			unsigned short dd=f.a[i];
			for(int j=ind[i][dd];j;j=nxt[j])
			{
				int cu=zhi[j],he=0,ff=1;
				for(int k=0;k<16;k++)
				{
					he+=pc[(s[cu].a[k])^(f.a[k])];
					if(he>kk)
					{
						ff=0;
						break;
					}
				}
				if(ff)
				{
					flag=1;
					break;
				}
			}
			if(flag)break;
		}
		lastans=flag;
		putchar('0'+flag);
		putchar('\n');
	}
	return 0;
}
```

---


# [COCI 2011/2012 #3] TRAKA

## 题目描述

Mirko 的工厂里面有 $n$ 个工人。他们以流水线方式在传送带上制造汽车。工人从左往右编号为 $1\sim n$，其中工人 $1$ 即为 Mirko。汽车生产从工人 $1$（Mirko）开始，在他完成所有他的工作后，工人 $2$ 接手他的任务。之后工人 $3$ 再接手工人 $2$ 的任务，以此类推。当工人 $n$ 完成他的工作后，一辆汽车就生产完成了。

Mirko 和他的工人们必须生产 $m$ 辆汽车，且必须按 $1\sim m$ 的顺序生产。对于第 $i$ 个工人，他完成他的工作的时间为 $t_i$。对于第 $j$ 辆汽车，它装配的复杂度为 $f_j$。工人 $i$ 在汽车 $j$ 上完成他的工作所需时间为 $t_i\cdot f_j$。

根据公司政策，一个工人完成他的工作后，他必须立即将工作交给下一个工人，不得拖延。因此，下一个工人此时不能够在其他汽车上工作。为了满足这个条件，Mirko 必须等到一个好的时机开始制造一辆新车。为了提高效率，他将等待最少的时间，直到他确定能够满足所有条件。

编写一个程序，给定每个工人完成他的工作的时间和每辆车装配的复杂度，求生产所有汽车所需的总时间。

## 说明/提示

**【样例 1 解释】**

对于样例 $1$，$4$ 个单位的时间后，工人 $1$ 完成了第一辆车的工作。他可能会立即开始在第二辆车上工作，但这违反了汽车必须在完成后立即传递给下一个工人的条件（$7$ 个单位的时间后第二个工人将完成他在第二辆车上的工作，但是第三个工人不能接手，因为他仍然在第一辆车上工作）。因此，第二辆车在 $5$ 个单位的时间后才能开始生产。$7$ 个单位的时间后开始生产第三辆汽车。第一辆车在 $8$ 个单位的时间后完成，第二辆车在 $9$ 个单位的时间后完成，第三辆车在 $11$ 个单位的时间后完成。因此总时间是 $11$。

**【数据范围】**

对于 $40\%$ 的数据，满足 $n,m\leqslant 1000$。  
对于所有数据，$1\leqslant n,m\leqslant 10^5$，$1\leqslant t_i,f_j\leqslant 10^4$。

**【题目来源】**

本题来源自 **_[COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST 3](https://hsin.hr/coci/archive/2011_2012/contest3_tasks.pdf) T6 TRAKA_**，按照原题数据配置，满分 $160$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3 3
2
1
1
2
1
1```

### 输出

```
11```

## 样例 #2

### 输入

```
3 3
2
3
3
2
1
2```

### 输出

```
29```

## 样例 #3

### 输入

```
4 5
3
2
2
2
3
1
2
1
2```

### 输出

```
55```

# 题解

## 作者：Makab (赞：1)

## 题解

先考虑暴力。

设 $f_i$ 表示开始制造第 $i$ 辆车的最早时间（有边界 $f_1 = 0$），$g_i = \sum \limits_{j = 1}^{i} t_i$，$h$ 为原题目中的 $f$，那么有如下转移：

$$
f_i = f_{i - 1} + \max \limits_{j = 1}^{n} (g_j \cdot h_{i - 1} - g_{j - 1} \cdot h_i)
$$

可做如下理解：

+ 工人 $j$ 处理完毕第 $i - 1$ 辆车的时刻为 $f_{i - 1} + g_j \cdot h_{i - 1}$；
+ 工人 $j$ 开始处理第 $i$ 辆车的时刻为 $f_i + g_{j - 1} \cdot h_i$；
+ 由题意，有 $f_i + g_{j - 1} \cdot h_i \ge f_{i - 1} + g_j \cdot h_{i - 1}$，
  即 $f_i \ge f_{i - 1} + g_j \cdot h_{i - 1} - g_{j - 1} \cdot h_i$，对所有工人取最大值。

答案即为 $f_m + g_n \cdot h_m$。这样的时间复杂度为 $\mathcal O(N^2)$，考虑斜率优化。

引入 $k = \frac{h_i}{h_{i - 1}}$，则原式化为：

$$
\begin{aligned}
    f_i &= f_{i - 1} + \max \limits_{j = 1}^{n} (g_j \cdot h_{i - 1} - g_{j - 1} \cdot (k \cdot h_{i - 1})) \\
        &= f_{i - 1} + h_{i - 1} \cdot \max \limits_{j = 1}^{n} (g_j - k \cdot g_{j - 1})   \\
\end{aligned}
$$

进一步地：

设点集 $P_i = (g_{i - 1}, g_i), (1 \le i \le n)$，令 $y_i = k \cdot x_i + b_i$。

给定斜率 $k$，求使得 $y_j - k \cdot x_j$ 最大，即 $b_j$ 最大的一个 $j$。

那么，对于点集 $P$，维护一个上凸壳，每次二分地求斜率为 $k$ 的直线与之的切点即可，时间复杂度 $\mathcal O(N \log N)$。

## 代码

```cpp
constexpr int N = 1e5 + 2;

int n, m, stk[N], top;
/**
 * f[i]: 第 i 辆车最早开始处理的时刻;
 * g[i]: 前 i 个工人的系数前缀和;
 * h[i]: 第 i 辆车的系数;
 */
ll f[N], g[N], h[N];

double slope(int i, int j) { return (double)(g[i] - g[j]) / (g[i - 1] - g[j - 1]); }

int main() {
    read(n, m);
    rep(i, 1, n) read(g[i]), g[i] += g[i - 1];
    rep(i, 1, m) read(h[i]);
    rep(i, 1, n) {
        while (top > 1 && slope(i, stk[top]) > slope(stk[top], stk[top - 1])) --top;
        stk[++top] = i;
    }
    rep(i, 2, m) {
        int l = 0, r = top, mid;
        double k = (double)h[i] / h[i - 1];
        while (l < r) {
            mid = (l + r) / 2;
            if (slope(stk[mid + 1], stk[mid]) > k) l = mid + 1;
            else r = mid;
        }
        f[i] = f[i - 1] + g[stk[l]] * h[i - 1] - g[stk[l] - 1] * h[i];
    }
    printf("%lld\n", f[m] + g[n] * h[m]);
    return 0;
}
```

---

## 作者：Thunder_S (赞：1)

## Solution

设 $g_i$ 表示第 $i$ 辆汽车开始工作的时间，$s_i$ 表示 $t_i$ 的前缀和。

有转移方程 $g_i=g_{i-1}+\max\{s_jf_{i-1}-s_{j-1}f_i\}$。

可以暴力枚举 $j$，时间复杂度 $\mathcal O(n^2)$，期望得分 $40\text{pts}$。

考虑斜率优化，若 $j$ 没有 $k$ 优，则有 $s_jf_{i-1}-s_{j-1}f_i<s_kf_{i-1}-s_{k-1}f_i$，移项变形可得 $\frac{f_i}{f_{i-1}}<\frac{s_k-s_j}{s_{k-1}-s_{j-1}}$。

$\frac{f_i}{f_{i-1}}$ 不单调，则维护斜率单调递减的上凸壳，然后二分。

## Code

```cpp
#include<cstdio>
#include<algorithm>
#define N 100005
#define ll long long
#define db double
using namespace std;
int n,m,t,l,r,mid,res,q[N];
ll a[N],b[N],f[N];
int read()
{
    int res=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch-'0'),ch=getchar();
    return res;
}
ll llread()
{
    ll res=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch-'0'),ch=getchar();
    return res;
}
db xl(int x,int y) {return (a[x]-a[y])/(db)(a[x-1]-a[y-1]);}
int main()
{
    n=read();m=read();
    for (int i=1;i<=n;++i)
        a[i]=llread(),a[i]+=a[i-1];
    for (int i=1;i<=m;++i)
        b[i]=llread();
    for (int i=1;i<=n;++i)
    {
        while (t>1&&xl(i,q[t])>xl(q[t],q[t-1])) --t;
        q[++t]=i;
    }
    f[1]=0;
    for (int i=2;i<=m;++i)
    {
        l=0;r=t;res=0;
        db x=b[i]/(db)b[i-1];
        while (l<r)
        {
            mid=(l+r)>>1;
            if (xl(q[mid+1],q[mid])>x) l=mid+1;
            else r=mid;
        }
        f[i]=f[i-1]+a[q[l]]*b[i-1]-a[q[l]-1]*b[i];
    }
    printf("%lld\n",f[m]+a[n]*b[m]);
    return 0;
}
```

## Thank

感谢 [大佬的博客](https://www.cnblogs.com/Extended-Ash/p/9477158.html)。

---

## 作者：Astatinear (赞：0)

### [P7747 [COCI 2011/2012 #3] TRAKA](https://www.luogu.com.cn/problem/P7747)

$\text{Tag : }$ 动态规划，李超线段树。

其实并不是不会做的，但是一定要把式子写出来，不要懒。

方便计算答案的话，我们定义 $dp_i$ 表示开始装配第 $i$ 辆车的最早时间。为了方便我们后面的转移式，定义 $s_i=\sum_{j=1}^i t_j$。

故对于 $dp_i$ 有一个比较显然的转移：$dp_i=dp_{i-1}+\max_{j=1}^n \{s_j\times f_{i-1}-s_{j-1}\times f_i\}$。

于是我们有了一个比较 $\text{naive}$ 的 $\mathcal{O}(n\times m)$ 的做法。

很遗憾，没有办法直接通过。

注意到其实我们只关心如何快速求出后面 $\max$ 的这一坨。

可以稍微化简一下得到 $s_j\times f_{i-1}-s_{j-1}\times f_i=s_{j-1}\times(f_{i-1}-f_i)+t_j\times f_{i-1}$。

转移时 $i$ 已知，故可以把 $f_i,f_{i-1}$ 看作定值，令 $A=f_{i-1}-f_i,B=f_{i-1}$。

要想找到决策的 $j$，即找到 $s_{j-1}\times A+t_j\times B$ 的最大值。

稍微化一下，即快速求 $B\times (s_{j-1}\times \frac{A}{B}+t_j)$ 的最大值，注意到可以看作是 $n$ 条斜率为 $s_{j-1}$，截距为 $t_j$ 的线段，快速求出 $n$ 条线段在 $x=\frac{A}{B}$ 时的最大值是多少。

直接使用李超线段树即可，时间复杂度 $\mathcal{O}(m\log n)$。

---

## 作者：一只绝帆 (赞：0)

由于每次都是一个部件从头连着加工到尾，没有停下的情况，所以我们仅考虑相邻两个部件的关系。

（即如果把第一个部件删掉，第二个部件和第三个部件在最优策略下生产的时间差并不会有改变。）

什么关系呢？

设第 $i$ 个部件和第 $i+1$ 个部件的时间差为 $x_i$，那么，对于任意 $k$：

$$x_i+C_{i+1}\sum_{j\leq k-1}T_j\geq C_{i}\sum_{j\leq k}T_j$$

这是根据题目定义来的，对于每个工厂 $k$，若以 $1$ 号工厂生产 $i$ 为时间轴原点，则左边为 $k-1$ 工厂结束生产 $i+1$ 的时间，右边是 $k$ 工厂结束生产 $i$ 的时间，显然根据题意前者应当不小于后者。

变变形，令 $S_x=\sum_{i\leq x}T_i$，则上式变为：

$$x_i+C_{i+1}S_{k-1}\geq C_{i}S_k\\x_i\geq C_{i}S_k-C_{i+1}S_{k-1}$$

由于我们要最小的等待时间，那么：

$$x_i=\max_k\left(C_{i}S_k-C_{i+1}S_{k-1}\right)\\x_i=C_i \max_k \left(S_k-\frac{C_{i+1}}{C_i}S_{k-1}\right)$$

为什么把 $C_i$ 提到前面去呢，因为 $x_i$ 和 $C_i$ 是一家，提完了之后 $\max$ 部分就变成了一个 $y-kx$ 的形式了。

把平面和直线的定义带进去，就相当于我们要求有若干个点坐标 $(S_{k-1},S_k)$，每次询问一个斜率 $\frac{C_{i+1}}{C_i}$，问使得截距 $b=y-kx=\frac{x_i}{C_i}$ 最大成立的点坐标是什么。

（斜率优化并不是求出截距用截距转移，会有精度误差，而是求出使得截距最大成立的整数点坐标用那个转移，注意不要用分数式子转移，用变换前的整数式子。）

本题不同于一般的斜率优化，不需要求出一个值添加一个点坐标。

Code:
```cpp
#include<bits/stdc++.h>
#define x(a) a.x
#define y(a) a.y
#define F(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
using namespace std;typedef long double db;typedef long long ll;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char *p1,*p2,buf[1<<21];
int read() {
	int s=0,w=0;char ch=gc();
	while(ch<'0'||ch>'9') w|=(ch=='-'),ch=gc();
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=gc();
	return w?-s:s;
} const int N=1e5+5;const db l=1;
struct P {
	ll x,y;P() {}
	P(ll _x,ll _y) {x=_x;y=_y;}
} st[N];ll ans,c[N],s[N];db k[N];int n,m,tp;
bool sd(P p1,P p2,P p3) {return (y(p2)-y(p1))*(x(p3)-x(p1))<(y(p3)-y(p1))*(x(p2)-x(p1));}
P Max(db K) {return st[upper_bound(k+1,k+tp+1,K,greater<db>())-k-1];}
int main() {
	n=read();m=read();
	F(i,1,n) s[i]=s[i-1]+read();
	F(i,1,m) c[i]=read();
	if(n==1) {
		F(i,1,m) ans+=s[1]*c[i];
		cout<<ans<<endl;
		return 0;
	}
	F(i,1,n) {
		while(tp>1&&sd(st[tp-1],st[tp],P(s[i-1],s[i]))) tp--;
		st[++tp]=P(s[i-1],s[i]);
	}
	F(i,2,tp) k[i]=l*(y(st[i])-y(st[i-1]))/(x(st[i])-x(st[i-1]));k[1]=1e20;
	F(i,1,m-1) {
		P x=Max(l*c[i+1]/c[i]);
		ans+=1ll*c[i]*y(x)-1ll*c[i+1]*x(x);
	} ans+=1ll*s[n]*c[m];cout<<ans;
	return 0;
}
```

---


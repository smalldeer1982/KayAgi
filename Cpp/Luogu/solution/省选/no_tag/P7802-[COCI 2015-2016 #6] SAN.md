# [COCI 2015/2016 #6] SAN

## 题目描述

$\text{Anica}$ 有一张神秘的无限表，表里有无限行和无限列。有趣的是，表中的每个数字出现的次数是有限的。

定义函数 $\mathrm{rev}(i)$，返回 $i$ 在十进制下翻转后得到的新数字。例如 $\mathrm{rev}(213)=312$，$\mathrm{rev}(406800)=008604=8604$。

表中第 $i$ 行第 $j$ 列的数字 $A(i,j)$ 由以下方式得到：

- $A(i,1)=i$

- $A(i, j) = A(i, j − 1)+\mathrm{rev}\big(A(i,j-1)\big)$，$j>1$

![](https://cdn.luogu.com.cn/upload/image_hosting/aqhn1qzp.png)

现在 $\text{Anica}$ 给出 $Q$ 个询问，每个询问给出两个整数 $L$ 和 $R$，请你求出无限表中有多少个数的大小在 $\big[L,R\big]$ 中。

## 说明/提示

**【数据范围】**

对于 $50\%$ 的数据，保证 $1\le L,R\le 10^6$。

对于 $100\%$ 的数据，保证 $1\le Q\le 10^5$，$1\le L,R\le 10^{10}$。

**【题目来源】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #6](https://hsin.hr/coci/archive/2015_2016/contest6_tasks.pdf) T6 SAN**。

**本题分值按 COCI 原题设置，满分 $160$**。

## 样例 #1

### 输入

```
2
1 10
5 8```

### 输出

```
18
8```

## 样例 #2

### 输入

```
3
17 144
121 121
89 98```

### 输出

```
265
25
10```

## 样例 #3

### 输入

```
1
1 1000000000```

### 输出

```
1863025563```

# 题解

## 作者：XUAN— (赞：15)

 ### [COCI2015-2016#6] 
#  SAN

### 题目大意

[题目描述](https://www.luogu.com.cn/problem/P7802)

给定一张表，规定第 $i$ 行 第一列 为 $i$ ( $A_{i1}=i$ )
然后每一行进行递推 $A_{ij}=A_{i(j-1)}+rev(A_{i(j-1)})$

求表中 $x$ 以内的数有多少

## 思考

观察了题目，注意这句话 ： 有趣的是，表中的每个数字出现的次数是有限的

haha ,有趣的是，我们也发现在 $10^{10}$ 以内出现的在第二列的数也是有限的

$A_{ij}=A_{i(j-1)}+rev(A_{i(j-1)})$ 中 $A_{ij}$ 满足了什么性质？通过其计算方式可以发现 ，它的每一位应该关于中间位对称

即，如果它为七位数，那可以写作 $p_1p_2p_3p_4p_3p_2p_1$ ( $0<=p_i<=18$ )
因此，我们完全可以通过搜索算出在第二列出现的数，以及次数（按照这个性质，所有在第二列后出现的数都一定是在第二列出现过的）


## 细节

想到了这里，此题基本结束了，但蒟蒻调了太久了，还是打算分享一下需要注意的细节

1. 如何统计在第二列出现的数的次数

若我们搜到一个数 $x=p_1p_2p_3p_2p_1$ ，那它以这种形态出现在表中的次数应为 $f_1 \times f_2 \times f_3$ ( $f_i$ 为 $p_i$ 的拆数方案数)

需要注意的是 其他位可以拆成 $p_i = x_1+x_2$ ( $0<=x_1<=9 $ 且 $0<=x_2<=9$ ）

但是！！首位的加数 $x_1$ 不可以为零！！因为这样映射到的第一列的数是不合法的
 $p_1=x_1+x_2$ ( $1<=x_1<=9 $ 且 $0<=x_2<=9$ )
 
此外中间位 $p_3$ 只能拆成 $p_3=x+x$ ，因此必须是偶数，且 $f_3=1$ 

2. 搜索过程中一个数会被多次搜索

它是以不同形态被搜到的，每一种都必须要被记录，最后（次数）合并到一起

比如 $121$ ，第一次被搜到是 $11,11$ ($f=8(11=2+9,3+8,4+7,5+6...)$)

然后又会被搜到是 $1,2,1$ $f=1 \times 1(1=1+0,2=1+1)$ 

至此，$121$ 应该在第二列出现了$9$次了

为了这个合并操作，学习了个方便的 $STL$ ，去重：（返回去重后的元素个数）

```cpp
Cnt_a=unique(a+1,a+1+cnt_a)-a-1;
```


3. 如何求第二列以后的数

以为一个数的后继是唯一的，那么它出现的多少次，它的后继就一定出现的多少次，那么一个数的出现次数就为它所有前继次数的和，那么就可以枚举所有第二列的数向后递推得到了

4. 注意还要加上在第一列出现的次数


## Code

```cpp
# define N 4000005
# define LL long long
const int p=10;
const LL M=1e10;
int q,tot=0;
LL L,R,f[N+5],a[N+5],pow_10[11],b[N+5],c[N+5];
inline LL rev(LL x)
{
 	LL ret=0;
	while(x)
	{
		ret=(ret*10)+x%p;
		x/=p;
	}
	return ret;
}
inline int find(LL x) // 二分查找 
{
	int l=0,r=tot,mid;
	while(l<r)
	{
		mid=(l+r+1)>>1;
		if(a[mid]<=x) l=mid;
		else r=mid-1;
	}
	return l;
}
inline LL calc(LL x)
{
	if(x==0) return 0;
	int pl=find(x);	
	return f[find(x)]+x; //注意加上第一列出现的次数（x） 
}
LL hh[2][20]={{1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1},{0,1,2,3,4,5,6,7,8,9,9,8,7,6,5,4,3,2,1}};// hh[1]:首位 ,hh[0]:非首位 
void dfs(int ed,int dep,LL s,LL t) 
{
	if(s>M) return ;
	if(dep==(ed+1>>1)) 
	{
		c[++tot]=t;
		b[tot]=a[tot]=s;
		return;
	}
	if((dep<<1|1)==ed)  // mid : i = x+x
	{
		for(LL i=(dep==0);i<=18;i++) 
			if(!(i&1))dfs(ed,dep+1,s+pow_10[dep]*i,t);
	}
	else
	{
		for(LL i=(dep==0);i<=18;++i)
			dfs(ed,dep+1,s+(pow_10[dep]+pow_10[ed-dep-1])*i,t*hh[dep==0][i]);
	}
	
}
inline void PreWork()
{
	pow_10[0]=1;
	for(int i=1;i<=10;++i) pow_10[i]=pow_10[i-1]*10LL;
	for(int i=1;i<=10;++i)
		dfs(i,0,0,1);
	sort(a+1,a+1+tot);
	int cnt=tot;
	tot=unique(a+1,a+1+tot)-a-1; // 去重 
	for(int i=1;i<=cnt;++i) 
	{
		int pos=find(b[i]);
		f[pos]+=c[i]; // 合并得到在第二列出现的总次数 
	}
	for(int i=1;i<=tot;++i)
	{	
		LL tmp=a[i]+rev(a[i]); //从第二列递推后列 
		if(tmp>M||tmp<0) continue;
		f[find(tmp)]+=f[i];	
	}
	for(int i=1;i<=tot;++i) f[i]+=f[i-1]; // 前缀和 
}
int main()
{
	PreWork();
	read(q);	
	while(q--)
	{
		read(L),read(R);L--;
		print(calc(R)-calc(L)),putchar('\n');
	}
	return 0;
}
```



---

## 作者：☯☯枫☯☯ (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P7802)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/15116381.html)

## 算法分析：数位 dp

在讲正解之前先说一下部分分。

注意到对于 $50\%$ 的数据，$1\le L,R\le10^6$，似乎可以暴力做出来。但由于我们不知道每个数可能出现的位置，直接开二维数组模拟非常容易炸~~（事实证明它就炸了……）~~，因此我们要换一种方式枚举。注意到每一个数字仅能转变成为另一种数字，且每个数字至少出现一次（在第一列）。于是可以递推得到 $cnt_{j}=\sum cnt_i(j=rev(i))$ 然后前缀和统计即可。

给出 $50\%$ 的代码。可以获得 $80$ pts 的~~好~~成绩。

```cpp
namespace p50 {
	const int N=1e6;
	int cnt[N+5];
	inline void init() {
		F(i,1,N)++cnt[i];
		int p;
		F(i,1,N) {
			p=i+rev(i);
			if(p<=N)cnt[p]+=cnt[i];
		}
		F(i,1,N)cnt[i]+=cnt[i-1];
	}
	int main() {
		init();
		n=read();
		int l,r;
		F(i,1,n) {
			l=read(),r=read();
			printf("%d\n",cnt[r]-cnt[l-1]);
		}
	}
}
```

接下来讲一下正解。

对于一个 $x$，记 $y=x+rev(x)$。直接枚举 $x$ 肯定超时，因此考虑枚举 $y$。在 $y$ 有$10$ 位时，先不计算进位，那么 $y$ 的前五位与后五位是对称的。除最高位不为 $0$（那最低位也不为 $0$），其余每一位可能是 $0\sim 18$ 的一种。那么总共有 $18\times 19^4=2345778$ 种情况。是很小的，因此考虑用 dfs，先确定位数，再数位 dp 枚举 $y$ 的每一位。

有了情况，接下来考虑统计次数。事实上，dfs 时已经算出了出现在第二列的次数，因为枚举的时候枚举的就是 $x+rev(x)$。对于更后面的列，由于后面每个数都是由前面的数转移来的，那么可以枚举每一个满足要求的数。由于所有的可能的数都已经处理出来了，就可以用一个数组 $sum$ 统计一个数出现的次数。和上面类似的，$sum_y=\sum sum_x(x+rev(x)=y)$。因为第二行已经统计过了，所以减一。对 $sum$ 做前缀和即可做到快速查询。

代码在细节处略有不同，注意一下即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define F(i,a,b) for(reg int i=(a);i<=(b);++i)
using namespace std;
bool beginning;
inline ll read();
const int M=4e6+5,N=20;
int n,cnt,p[N],q[N];
ll pw[N] {1},sum[M],a[M],tot[M],b[M];
inline ll rev(ll x) {
	ll ans=0;
	while(x)ans=ans*10+x%10,x/=10;
	return ans;
}
void dfs(int n,int x,ll s,ll t) {
	if(x==(n+1>>1)) {
		tot[++cnt]=t;
		b[cnt]=a[cnt]=s;//记录可能的情况 
		return;
	}
	F(i,(x==0),18) {
		if(n==(x<<1|1) and (i&1))continue;
		ll tmp=x?p[i]:q[i];
		if(n==(x<<1|1))tmp=1;
		if(!tmp)continue;
		if(n==(x<<1|1))dfs(n,x+1,s+pw[x]*i,t*tmp);
		else dfs(n,x+1,s+(pw[x]+pw[n-x-1])*i,t*tmp);
	}
}
inline void init() {
	F(i,1,15)pw[i]=pw[i-1]*10;
	F(i,0,9)F(j,0,9)++p[i+j],q[i+j]+=(i!=0);
	//出现某个和的不同组合情况数 
	F(i,1,10)dfs(i,0,0,1);
	//预处理 
	int m=cnt;
	sort(a+1,a+cnt+1);
	cnt=unique(a+1,a+cnt+1)-a-1;
	F(i,1,m) {
		int pos=lower_bound(a+1,a+cnt+1,b[i])-a;
		sum[pos]+=tot[i];//初值 
	}
	F(i,1,cnt) {
		ll t=a[i]+rev(a[i]);
		int pos=lower_bound(a+1,a+cnt+1,t)-a;
		if(pos!=cnt+1 and a[pos]==t)sum[pos]+=sum[i];
		++sum[i];
		sum[i]+=sum[i-1];
	}
}

inline ll cal(ll x) {
	if(!x)return 0;
	int pos=upper_bound(a+1,a+cnt+1,x)-a-1;
	return x+sum[pos]-pos;
}
bool ending;
int main() {
//	system("color fc");
// 	printf("%.2lfMB\n",1.0*(&beginning-&ending)/1024/1024);
	init();
	n=read();
	ll l,r;
	F(i,1,n) {
		l=read(),r=read();
		printf("%lld\n",cal(r)-cal(l-1));
	}
	return 0;
}
inline ll read() {
	reg ll x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}
```

[AC](https://www.luogu.com.cn/record/55309029)

欢迎交流讨论，请点个赞哦~

---

## 作者：Sakura_xyz (赞：4)

### 题目描述
设 $rev(x)$ 为 $x$ 在十进制下数字翻转后所形成的新数字，定义一张无限表 $A$ ，其中 $\forall i \in N^{*}$ ，有 $A_{i,1}=i$ ， $\forall i,j \in N^{*},j\neq1$ ，有 $A_{i,j}=A_{i,j-1}+rev(A_{i,j-1})$ ，有 $Q$ 次询问，每次询问给出 $a,b$ ，求在这张表中， $[a,b]$ 间的元素出现的次数总和。

### 分析
设 $f(x)=x+rev(x)$ 

我们考虑这样一件事情，很显然的是，列表中每一行的元素是单调的，也就是说，对于任意的 $a_{i,j}$ ，其中有 $i,j \geq 2$ ， $a_{i,j}>a_{i,j-1}$ 恒成立。因此我们观察到，每一个出现在列表中的数字一定能且仅能被比这个数字小的数字转移过来。因此，在值域在 $10^6$ 范围内时，有一个非常 trivial 的做法，我们设 $dp_{i}$ 为 $i$ 在表内出现的次数，那么，很显然，我们可以刷表转移，将所有的状态初始化为 $1$ ，之后，对于每个数，已经通过所有比它小的数进行转移过后，它在表中的出现次数就已经被确定了，此时，用这个数来更新之后的状态，不妨设这个数为 $x$ ，则令 $dp_{f(x)}$ 加上 $dp_{x}$ 即可。

转移方程为：
$$dp_{f(x)}=dp_{f(x)}+dp_{x}$$

### 进一步考虑

我们先证明一个引理。

对于一个映射 $g:N^*\rightarrow N^*$ ，对于一个正整数 $a$ ，若 $\forall i \in N^*$  ，有 $g(i)\neq a$ 。则   $\forall i,j \in N^*$  ，有 $g^j(i)\neq a$ 成立。

我们利用反证法，假设 $g^j(i)= a$ ，则 $g(g^{j-1}(i))=a$ ，由于 $g$ 是 $N^*\rightarrow N^*$ 的映射，则   $g^{j-1}(i)\in N^*$ ，且 $g(g^{j-1}(i))=a$ ，与$\forall i \in N^*$ ，有 $g(i)\neq a$ 的条件矛盾，故得证。

很显然， $f$ 是一个满足这个条件的映射，我们把表中的每一个元素用 $f(x)$ 表示出来。

 $\forall i \in N^{*}$ ，有 $A_{i,1}=i$，$\forall i,j \in N^{*},j\neq1$ ，有 $A_{i,j}=f^{j-1}(i)$ 。很显然，根据这个引理，我们得出了一个重要的结论：在这个表格中，第二列没有出现过的数，在第三列及以后一定不会再次出现。

我们再次考虑另一件事情，假如在不考虑进位的情况下，在第二列中出现的某个数 $x$ 有 $k+1$ 位，分别为 $0 - k$ 位，由 $rev(x)$ 的定义可以知道，对于第 $i$ 位而言，其与第 $k-i$ 位一定是相同的，并且，当 $k$ 是偶数时，第 $\frac{k}{2}$ 位必为偶数，那么，通过 dfs ，可以求出在值域内哪些数是出现了的，根据每一位的组成情况数，也可以利用乘法原理求出出现次数，注意首位不能为 $0$ ，很显然，由于提到的第 $i$ 位与第 $k-i$ 位相同的性质，则可以出现的数的个数在 $\sqrt{n}$ 的级别内。我们可以在 dfs 的时候处理出现的数与其出现次数，将其离散化下来，再进行 dp 的转移。很显然，维护一个离散化后的前缀和，询问时直接查找区间即可，时间复杂度为 $O(\sqrt{n}\log n+Q\log n)$ 。

### tips:

这题代码细节非常繁杂，注意想清楚每个细节部分，不要漏掉分类讨论的步骤。~~由于本人写代码时思维过乱，是典型的反面教材，代码就不放了~~。

---

## 作者：Gmt丶FFF (赞：3)

对于一个数 $\overline{s_1s_2s_3}$，进行一次变换后会变成 $\overline{(s_1+s_3)(s_2+s_2)(s_3+s_1)}$，不考虑进位的话，很明显每变化一次就会变成一个回文串，且这个回文串最高位是 $18$。

那我们就可以先预处理出来所有回文串的只用一次就能构成这个回文串的方案数。求这个的方案数即为每个位子上可能的数的乘积。

这个可以利用数位 dp 求解。

先枚举总位数，再枚举每一位，第一位不能为 $0$，注意中间位数需要特殊处理，然后最后方案数相乘。

先离散化，然后处理不是在第一次就构成的情况，如果一个回文串能被回文串组成，那么方案数递归累加即可。

但还有个问题，如 $5+5=10,10+1=11$，所以 $5$ 会出现在以 $5,10$ 开始的表中，但统计时实际上只统计了 $10$。

这个好处理，对于 $18$ 以内的数，求出其被 $18$ 以下的数构成的方案数即可。

对第一位特殊处理，求出在 $18$ 一下不包括 $0$ 构成的方案数。

最后求前缀和，对于每一次询问，二分找到第一个不大于它的回文数，用前缀和求区间和即可。


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int N=4e6+5;
int sum[N],cnt,power[15],p[20],q[20],lim[N];
struct node
{
	int name,data;
}b[N];
int cmp(node fi,node se)
{
	return fi.data<se.data;
}
int getnum(int x)
{
	int sum=0;
	while(x)
	{
		sum=sum*10+x%10;
		x/=10;
	}
	return sum;
}
int findsum(int x)
{
	int l=0,r=cnt;
	while(l<r)
	{
		int mid=(l+r+1)>>1;
		if(b[mid].data<=x)l=mid;
		else r=mid-1;
	}
	return l;
}
int clac(int x)
{
	int num=sum[findsum(x)];
	return num+x;
}
void dfs(int n,int x,int tot,int num)
{
	if(x>(n+1)/2)
	{
		lim[++cnt]=num;
		b[cnt]={cnt,tot};
		return;
	}
	for(int i=0;i<=18;i++)
	{
		if(x==1&&i==0)continue;
		if(n%2==1&&x==n/2+1&&i%2==1)continue;
		int tmp=p[i];
		if(x==1)tmp=q[i];
		if(tmp==0)continue;
		if(n%2==1&&x==n/2+1)dfs(n,x+1,tot+i*power[x-1],num*1);
		else dfs(n,x+1,tot+i*power[x-1]+i*power[n-x],num*tmp);
	}
}
void prepare()
{
	power[0]=1;
	for(int i=1;i<=12;i++)power[i]=power[i-1]*10;
	for(int i=0;i<=9;i++)for(int j=0;j<=9;j++)p[i+j]++,q[i+j]+=(i!=0);
	for(int i=1;i<=10;i++)dfs(i,1,0,1);
	sort(b+1,b+1+cnt,cmp);
	int bef=-1e18,cnp=0;
	for(int i=1;i<=cnt;i++)
	{
		if(b[i].data!=bef)b[cnp]={cnp,b[i-1].data},cnp++;
		bef=b[i].data;
		sum[cnp]+=lim[b[i].name];
	}
	for(int i=1;i<=cnp;i++)
	{
		int num=b[i].data+getnum(b[i].data);
		int tim=findsum(num);
		if(b[tim].data==num)sum[tim]+=sum[i];
		sum[i]+=sum[i-1];
		
	}
}
signed main()
{
	prepare();
	int q;
	scanf("%lld",&q);
	for(int i=1;i<=q;i++)
	{
		int l,r;
		scanf("%lld%lld",&l,&r);
		int ans=clac(r)-clac(l-1);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Add_Catalyst (赞：1)

# P7802 [COCI2015-2016#6] SAN 题解

---

## 知识点

数位 DP。

---

## 题意分析

定义一个函数 $rev(i)$ 为 $i$ 在十进制下翻转后得到的新数字。

给定一张表，其中元素的值由以下方式得到为：
$$
A_{i,1} = i \\
A_{i,j} = A_{i,j-1} + rev(A_{i,j-1}),\forall j \in (1,+\infin) \land j \in N_{+}
$$
有 $Q$ 个询问：给定 $L,R$，问整张表中有多少个数的大小在 $[L,R]$ 中。

---

## 思路分析

### 部分分

注意到当一个数 $i$ 变成 $i+rev(i)$ 后，该行在 $i$ 后的数就等同于第 $i+rev(i)$ 行的数，那么我们可以考虑做一个累加（你喜欢的话叫他线性 DP 也没事），定义 $f_i$ 为 $i$ 出现的次数，转移式：
$$
f_i = \sum_{j + rev(j) = i} f_j + 1
$$
最后再做一个前缀和即可。

### 正解

我们很容易就能发现：能够被表示成 $i+rev(i),i \in N_{+}$ 的数并不在多数，也就是说，按照上面那一条转移式，$f_i$ 大于 $1$ 的并不多，我们可以把这些大于 $1$ 的 $f_i$ 通过数位 DP 求出来，也是前缀和处理一下，然后二分查询即可。

我们来考虑一下它的复杂度。假设我们现在枚举的 $i$ 在十进制下有 $len \in [1,10]$ 位的，也就是 $\lfloor \lg {i} + 1 \rfloor = len$。我们设一个数 $x$ 其从低到高的第 $i\in[1,len]$ 位为 $x_i$，则有 $x = \sum_{i=1}^{len} x_i \cdot 10^{i-1}$。

设 $k=i+rev(i)$，在**不进位的情况下** $k$ 满足下面这个条件：
$$
k_j = k_{len-j},\forall j \in [1,len]
$$
而对于 $k$ 的任意一位 $k_i$，它都是由 $i$ 的某两位加和得到，故有结论：$k_i \in [0,18],\forall i \in [1,len]$。

那么 $k$ 的可能数就只有 $O(19^{\lfloor \frac{len}{2} \rfloor})$ 级别，总数大概在 $O(19^5)$ 级别，实际上略多一点，为 $2541196$ 个。

最后的复杂度就大概在：
$$
O(\sum_{i=1}^{\lg R} w^{\lfloor \frac{i}{2} \rfloor} + n \log_2{n} + n \lg{R} + Q \log_2{n})
$$
其中 $n = 2541196,w = 19$。

---

## CODE

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define tomax(a,b) ((a)=max((a),(b)))
#define tomin(a,b) ((a)=min((a),(b)))
#define FOR(i,a,b) for(int i=(a);i<=(int)(b);++i)
#define DOR(i,a,b) for(int i=(a);i>=(int)(b);--i)
#define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;~(i);(i)=(g)[(i)].nxt,(y)=(g)[(i)].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=1e5+10;
constexpr ll lim=1e10;
int Q;
int C[2][19];
ll sum;
ll pw[11];
map<ll,ll> cnt;
ll Rev(ll x,ll y=0){
	for(;x;x/=10)y=y*10+x%10;
	return y;
}
void DP(int l,int r,ll num,bool lead,ll f){
	if(num>lim)return;
	if(l>r)return cnt[num]+=f,void();
	if(l==r){
		FOR(i,lead,9)cnt[num+(i*pw[l]<<1)]+=f;
		return;
	}
	FOR(i,lead,18)DP(l+1,r-1,num+(pw[l]+pw[r])*i,0,f*C[lead][i]);
}
signed main(){
	pw[0]=1;
	FOR(i,0,9)FOR(j,0,9)C[1][i+j]+=(i>0),++C[0][i+j];
	FOR(i,1,10)pw[i]=pw[i-1]*10,DP(0,i-1,0,1,1);
	for(auto &x:cnt){
		ll y=x.first+Rev(x.first);
		if(y<=lim)cnt[y]+=x.second;
		sum+=x.second,x.second=sum;
	}
	for(cin>>Q;Q;--Q){
		ll l,r;
		cin>>l>>r,cout<<(--cnt.upper_bound(r))->second-(--cnt.lower_bound(l))->second+r-l+1<<endl;
	}
	return 0;
}
```

（啊哈想要最劣解就学我狂用 STL 吧！）

---

---


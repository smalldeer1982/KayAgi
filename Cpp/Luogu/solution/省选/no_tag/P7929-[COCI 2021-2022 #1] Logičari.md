# [COCI 2021/2022 #1] Logičari

## 题目描述

给定一个 $n$ 个点的基环树，现在对基环树上的点染色，使得每个点都有且仅有一个与他相连的点（不包括它自身）被染色，求最少的染色点数，或者返回无解。

## 说明/提示

#### 样例解释
#### 样例 1 解释
可以在 $1,2$ 号点染色。

#### 样例 2 解释
如果有一个点被染色，则被染色的点不会有被染色的相邻的点。

如果有两个点被染色，则不被染色的点会有两个被染色的相邻的点。

#### 数据范围

对于全部数据，$3\le n\le 10^5$，$1\le u_i,v_i\le n$。

| Subtask |      特殊限制      | 分数 |
| :-----: | :----------------: | :--: |
|   $1$   | 每个点的点度为 $2$ | $10$ |
|   $2$   |     $n\le 20$      | $10$ |
|   $3$   |    $n\le 10^3$     | $40$ |
|   $4$   |     无特殊限制     | $50$ |


#### 说明
**本题总分 $110$ 分。**

本题译自 [Croatian Open Competition in Informatics 2021/2022](https://hsin.hr/coci/archive/2021_2012) [Contest #1](https://hsin.hr/coci/archive/2021_2022/contest1_tasks.pdf) T3 Logičari。

## 样例 #1

### 输入

```
4
1 2
2 3
3 4
4 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3
1 2
2 3
3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
7
1 2
2 3
3 4
4 5
5 6
6 7
2 4```

### 输出

```
4```

# 题解

## 作者：SAMSHAWCRAFT (赞：9)

基环树，就是将一棵树的两个顶点用一条边 E 连起来形成的图。这个图上有且只有一个环，并且这个环上必定有上述的边 E。

现在我们有一颗基环树，要在上面染色。我们知道如果在一棵树上像题目中说的那样染色，可以用树形 DP 解决。而对于本题我们可以考虑把这个基环树的环切开，切口一端当作树根，另一端当作树根的“兄弟”，之后 DP，再看切口两侧染色的情况是否符合题意。

怎么确定切口？可以借助并查集，当一条边 E 的两个端点 u,v 在并查集中已经处于一个集合中，换言之是 u,v 已经在一棵树上，那么连接 u,v 的这条边 E 就是基环树上的环上的一条边，此时可以选 u 做树根（在代码中对应变量 $\texttt{root}$），v 做树根的“兄弟”（在代码中对应变量 $\texttt{rootbro}$），在建图时切断这条边其实等价于不连这条边，其余的普通的边只需正常连边即可。建图完成之后，分四类讨论，规约到树形 DP 问题上。

分类讨论：

1. $\texttt{root}$ 和 $\texttt{rootbro}$ 都不染色。
1. $\texttt{root}$ 染色但 $\texttt{rootbro}$ 不染色。
1. $\texttt{root}$ 不染色但 $\texttt{rootbro}$ 染色。
1. $\texttt{root}$ 和 $\texttt{rootbro}$ 都染色。

树形 DP 的过程比较基础，设计状态 $f(\texttt{u,th,fac,rtc,rtbroc})$ 表示当前从 $\texttt{root}$ 染色到节点 $\texttt{u}$ 时，$\texttt{u}$ 的染色状态为 $\texttt{th}$，而 $\texttt{root}$ 和 $\texttt{rootbro}$ 染色状态分别为 $\texttt{rtc}$ 和 $\texttt{rtbroc}$（$\texttt{th}$,$\texttt{fac}$,$\texttt{rtc}$,$\texttt{rtbroc}$ 都是当且仅当被染色时为 1，否则为 0）时需要染色的最少节点数，状态转移的时候只需要每一下子节点是否需要染色即可。

无解的情况只有三种，特判一下：

1. $\texttt{u}=\texttt{root}$ 但 $\texttt{rtc}\neq\texttt{th}$，即本来根应该染色但根没有被染色或本来根不该染色却被染色的情况。
1. $\texttt{u}=\texttt{rootbro}$ 但 $\texttt{rtbroc}\neq\texttt{th}$，即本来根的兄弟应该染色但根没有被染色或本来根的兄弟不该染色却被染色的情况。
1. $\texttt{u}=\texttt{rootbro}$ 且 $\texttt{fac}=1$ 且 $\texttt{rtc}=1$，即根的兄弟同时连接了两个被染色了的点。

细节较多，代码如下，仅供参考。
``` cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <numeric>
#define qaq inline
using ll=long long;
const int inf=1e9+7;
const int sz=1e5+19;
const int esz=2e5+19;
int n,head[sz],hpp=0,root,rootbro,ans;
struct edge{
    int nxt,to;
}graph[esz];
qaq void addEdge(int from,int to){
    graph[++hpp]=edge{head[from],to};
    head[from]=hpp;
}
struct UnionFindSet{
    int fa[sz];
    qaq void clear(int n=sz-1){
        for(int cx=0;cx<=n;++cx)
            fa[cx]=cx;
    }
    int findAnc(int id){
        if(fa[id]==id) return id;
        return fa[id]=findAnc(fa[id]);
    }
    qaq bool connect2(int u,int v){
        return findAnc(u)==findAnc(v);
    }
    qaq void join(int u,int v){
        int fu=findAnc(u);
        int fv=findAnc(v);
        if(fu==fv) return;
        fa[fu]=fv;
    }
}UFS;
int pr[sz];
void DFS(int u,int fau){
    pr[u]=fau;
    for(int p=head[u];p!=0;p=graph[p].nxt){
        int v=graph[p].to;
        if(v==fau) continue;
        DFS(v,u);
    }
}
int dp[sz][2][2][2][2];
int color(int u,int th,int fac,int rtc,int rtbroc){
    ///@param u: currently visited vertex
    ///@param th: equals to 1 only when u is colored
    ///@param fac: equals to 1 only when u's father is colored
    ///@param rtc: equals to 1 only when root is colored
    ///@param rtbroc: equals to 1 only when rootbro is colored
    if(dp[u][th][fac][rtc][rtbroc]!=-1)
        return dp[u][th][fac][rtc][rtbroc];
    ll res=inf;
    bool valid=true;
    if(u==root&&th!=rtc) valid=false;
    if(u==rootbro&&th!=rtbroc) valid=false;
    if(u==rootbro&&fac&&rtc) valid=false;
    if(!valid) return dp[u][th][fac][rtc][rtbroc]=inf;
    bool cfree=false;
    ///@param cfree: true only when u is not able to be colored
    if(fac) cfree=true;
    if(u==root&&rtbroc) cfree=true;
    if(u==rootbro&&rtc) cfree=true;
    ll ccnt=th;
    ///@param ccnt: the number of currently colored vertexes
    for(int p=head[u];p!=0;p=graph[p].nxt){
        int v=graph[p].to;
        if(v==pr[u]) continue;
        ccnt+=color(v,0,th,rtc,rtbroc);
    }
    if(cfree){
        res=std::min(res,ccnt);
    }else{
        for(int p=head[u];p!=0;p=graph[p].nxt){
            int v=graph[p].to;
            if(v==pr[u]) continue;
            res=std::min(res,ccnt-color(v,0,th,rtc,rtbroc)+color(v,1,th,rtc,rtbroc));
        }
    }
    return dp[u][th][fac][rtc][rtbroc]=res;
}
int main(){
    scanf("%d",&n);
    UFS.clear(n);
    memset(dp,-1,sizeof dp);
    for(int cx=1,u,v;cx<=n;++cx){
        scanf("%d%d",&u,&v);
        if(UFS.connect2(u,v)){
            root=u,rootbro=v;
        }else{
            UFS.join(u,v);
            addEdge(u,v);
            addEdge(v,u);
        }
    }
    DFS(root,0);
    int ans=inf;
    ans=std::min({ans,color(root,0,0,0,0),color(root,0,0,0,1),
                  color(root,1,0,1,0),color(root,1,0,1,1)});
    if(ans==inf) puts("-1");
    else printf("%d\n",ans);
    return 0;
}

```

---

## 作者：钰瑾_恋涵 (赞：4)

所有环套树大致思路都差不多一样，都是把环找出来，再断一条边去处理。而断一条边需要知道环上相邻两个点，至于如何找到这个切点，楼上的老哥用的是并查集去维护。但由于是基环树，大可不必这么麻烦。只要在搜索的过程中遇到一个非父节点但又经历过的点，就说明恰好将环遍历完，同时我们也得到了环上的两个相邻的点，记为 S 和  T ，然后将当前边标记，在之后的处理中忽略这条边。

我们可以枚举 S 和 T 的四种情况分别 DP，楼上老哥也讲得很清楚。

令 S 为根。

然后我们考虑不合法的情况。

* S 染了，但又在 T 旁边染了一个。
* T 染了，但 T 旁边那个已经染了。
* S 没染，T 旁边那个也没染，而且 T 无其它子树了。

在遇到 T 的时候判断一下是否和法，和法的话就可以把它当成一个普通的节点处理，但要判断一下 T 的状态。

考虑 DP 转移。

设当前节点为 u ，染色状态为 p。

不难发现无论是那种情况都可能用到子节点不染的价值，因为子节点中最多只有一个被染色。所以我们记录每一棵子节点不染的价值，并记录所有子节点不染的总价值 val。

如果 fa[u] 被染了，那么 u 子树的价值就为 $val + p$。

否则，就枚举每一个子节点染色的情况。

那么 u 子树的价值就为  $\min \{ val - w[v][0] + w[v][1] \}+p$。

在记忆化的时候用 $dp[i][a][b]$ 表示 i 子树染或不染，旁边节点是否染过的价值。 

最后附上代码。

```cpp
#include <bits/stdc++.h>
#define int long long
#define inf 1000000000
using namespace std;
const int Maxn=6e5+10;
int n,res,w[Maxn][2],cut,s,t,out,dp[Maxn][2][2];;
int head[Maxn],nxt[Maxn],to[Maxn],cnt=1;
bool see,lit,vis[Maxn];
inline void add(int x,int y) {
	to[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;
}
void dfs(int x,int fa) {
	vis[x]=1;
	for(int i=head[x]; i; i=nxt[i]) {
		int v=to[i];
		if(v!=fa) {
			if(!vis[v]) dfs(v,x);
			else cut=i;
		}
	}
}
int DP(int u,int fa,int a,int b) {
	if(dp[u][a][b]) return dp[u][a][b];
	int tot=0,res=inf;
	for(int i=head[u]; i; i=nxt[i]) {
		int v=to[i];
		if((v==fa)||(i==cut)||((i^1)==cut)) continue;
		if(v==t) {
			if((a&&see)||(b&&lit)||(!a&&!see&&out<3)) return inf;
			w[v][lit]=DP(v,u,lit,(see|a)),w[v][!lit]=inf;
			tot+=w[v][0];
		} else {
			w[v][0]=DP(v,u,0,a),tot+=w[v][0];
			if(!b) w[v][1]=DP(v,u,1,a);
		}
	}
	if(b) return dp[u][a][b]=tot+a;
	for(int i=head[u]; i; i=nxt[i]) {
		int v=to[i];
		if((v==fa)||(i==cut)||((i^1)==cut)) continue;
		res=min(res,tot-w[v][0]+w[v][1]);
	}
	return dp[u][a][b]=res+a;
}
signed main() {
	scanf("%lld",&n);
	for(int i=1; i<=n; ++i) {
		int x,y; 
		scanf("%lld %lld",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0),s=to[cut],t=to[cut^1];
	for(int i=head[t]; i; i=nxt[i]) ++out;
	res=DP(s,0,0,0);
	memset(dp,0,sizeof dp),lit=1;
	res=min(res,DP(s,0,0,1));
	memset(dp,0,sizeof dp),see=1,lit=0;
	res=min(res,DP(s,0,1,0));
	memset(dp,0,sizeof dp),lit=see=1;
	res=min(res,DP(s,0,1,1));
	if(res<=n) printf("%lld",res);
	else puts("-1");
	return 0;
}
```


---

## 作者：KingPowers (赞：3)

一眼肯定是要跑基环树 dp 的，所以先考虑如果是树怎么做。

不难想到设 $f_{u,0/1/2/3}$ 表示 $u$ 子树内：

- $0$ 表示 $u$ 不是关键点且 $u$ 的儿子里没有关键点。

- $1$ 表示 $u$ 不是关键点但 $u$ 的儿子里有关键点。

- $2$ 表示 $u$ 是关键点但 $u$ 的儿子里没有关键点。

- $3$ 表示 $u$ 是关键点且 $u$ 的儿子里有关键点。

这些情况下的最小关键点个数。

转移比较基础，不写了。

对于基环树的情况，我们考虑任意取出一条环上的边 $(u,v)$，断掉这条边之后就会变成一棵树，这样我们就只需要在树的基础上考虑 $u,v$ 两个点之间的限制即可，不妨再继续分讨：

- 如果最后 $u,v$ 都不是关键点，以 $u$ 为根 dp，并钦定 $v$ 不能是关键点即可，统计 $f_{u,1}$ 为答案。

- 如果最后 $u$ 是关键点且 $v$ 不是关键点，以 $u$ 为根 dp，并钦定 $v$ 及其邻居不能是关键点即可，统计 $f_{u,3}$ 为答案。

- 如果最后 $v$ 是关键点且 $u$ 不是关键点，以 $u$ 为根 dp，并钦定 $v$ 是关键点即可，统计 $f_{u,0}$ 为答案。

- 如果最后 $u,v$ 都是关键点，以 $u$ 为根 dp，并钦定 $v$ 是关键点且 $v$ 的邻居不能是关键点即可，统计 $f_{u,2}$ 为答案。

钦定 $v$ 的邻居不能为关键点不需要特判，dfs 到 $v$ 时直接令 $f_{v,1/3}$ 的 dp 值改为 $f_{v,0/2}$ 即可，并令其它状态的值为 $\infty$。

我的代码写得非常长，但是实际一大半的内容都是复制粘贴的，四个 dfs 只有开始和结束的钦定部分不一样，并不算难写。

时间复杂度显然的 $O(n)$。


```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i, a, b) for(int i = (a); i <= (b); i++)
#define Rof(i, a, b) for(int i = (a); i >= (b); i--)
#define deb(x) cerr << #x"=" << x << '\n';
using namespace std;
const int N = 5e5 + 5, INF = 1e18;
int n, a[N], deg[N];
int du, dv, f[N][4], tmp[4];  //没选没儿子选 没选有儿子选 选了没儿子选 选了有儿子选
bool g[N][4], inc[N];
vector<int> e[N];
void cmin(int &x, int y){x = min(x, y);}
void dfs1(int now, int fa){
	if(now == dv){  //钦定另一端必须不选
		g[now][0] = 1;
		f[now][0] = 0;
	}
	else{
		g[now][0] = g[now][2] = 1;
		f[now][0] = 0; f[now][2] = 1;
	}
	for(int to : e[now]){
		if(to == fa) continue;
		dfs1(to, now);
		For(i, 0, 3) tmp[i] = INF;
		if(g[now][0] && g[to][1]) cmin(tmp[0], f[now][0] + f[to][1]);
		if(g[now][0] && g[to][3]) cmin(tmp[1], f[now][0] + f[to][3]);
		if(g[now][1] && g[to][1]) cmin(tmp[1], f[now][1] + f[to][1]);
		if(g[now][2] && g[to][0]) cmin(tmp[2], f[now][2] + f[to][0]);
		if(g[now][2] && g[to][2]) cmin(tmp[3], f[now][2] + f[to][2]);
		if(g[now][3] && g[to][0]) cmin(tmp[3], f[now][3] + f[to][0]);
		For(i, 0, 3) f[now][i] = tmp[i], g[now][i] = tmp[i] != INF;
	}
}
void dfs2(int now, int fa){
	if(now == dv){  //钦定另一端必须选
		g[now][2] = 1;
		f[now][2] = 1;
	}
	else{
		g[now][0] = g[now][2] = 1;
		f[now][0] = 0; f[now][2] = 1;		
	}
	for(int to : e[now]){
		if(to == fa) continue;
		dfs2(to, now);
		For(i, 0, 3) tmp[i] = INF;
		if(g[now][0] && g[to][1]) cmin(tmp[0], f[now][0] + f[to][1]);
		if(g[now][0] && g[to][3]) cmin(tmp[1], f[now][0] + f[to][3]);
		if(g[now][1] && g[to][1]) cmin(tmp[1], f[now][1] + f[to][1]);
		if(g[now][2] && g[to][0]) cmin(tmp[2], f[now][2] + f[to][0]);
		if(g[now][2] && g[to][2]) cmin(tmp[3], f[now][2] + f[to][2]);
		if(g[now][3] && g[to][0]) cmin(tmp[3], f[now][3] + f[to][0]);
		For(i, 0, 3) f[now][i] = tmp[i], g[now][i] = tmp[i] != INF;
	}
}
void dfs3(int now, int fa){
	if(now == dv){  //钦定另一端必须不选
		g[now][0] = 1;
		f[now][0] = 0;
	}
	else{
		g[now][0] = g[now][2] = 1;
		f[now][0] = 0; f[now][2] = 1;
	}
	for(int to : e[now]){
		if(to == fa) continue;
		dfs3(to, now);
		For(i, 0, 3) tmp[i] = INF;
		if(g[now][0] && g[to][1]) cmin(tmp[0], f[now][0] + f[to][1]);
		if(g[now][0] && g[to][3]) cmin(tmp[1], f[now][0] + f[to][3]);
		if(g[now][1] && g[to][1]) cmin(tmp[1], f[now][1] + f[to][1]);
		if(g[now][2] && g[to][0]) cmin(tmp[2], f[now][2] + f[to][0]);
		if(g[now][2] && g[to][2]) cmin(tmp[3], f[now][2] + f[to][2]);
		if(g[now][3] && g[to][0]) cmin(tmp[3], f[now][3] + f[to][0]);
		For(i, 0, 3) f[now][i] = tmp[i], g[now][i] = tmp[i] != INF;
	}
	if(now == dv){  //这里要求周围没有选的
		f[now][1] = f[now][0]; g[now][1] = g[now][0];
		For(i, 0, 3) if(i != 1) f[now][i] = INF, g[now][i] = 0;
	}
}
void dfs4(int now, int fa){
	if(now == dv){  //钦定另一端必须选
		g[now][2] = 1;
		f[now][2] = 1;
	}
	else{
		g[now][0] = g[now][2] = 1;
		f[now][0] = 0; f[now][2] = 1;		
	}
	for(int to : e[now]){
		if(to == fa) continue;
		dfs4(to, now);
		For(i, 0, 3) tmp[i] = INF;
		if(g[now][0] && g[to][1]) cmin(tmp[0], f[now][0] + f[to][1]);
		if(g[now][0] && g[to][3]) cmin(tmp[1], f[now][0] + f[to][3]);
		if(g[now][1] && g[to][1]) cmin(tmp[1], f[now][1] + f[to][1]);
		if(g[now][2] && g[to][0]) cmin(tmp[2], f[now][2] + f[to][0]);
		if(g[now][2] && g[to][2]) cmin(tmp[3], f[now][2] + f[to][2]);
		if(g[now][3] && g[to][0]) cmin(tmp[3], f[now][3] + f[to][0]);
		For(i, 0, 3) f[now][i] = tmp[i], g[now][i] = tmp[i] != INF;
	}
	if(now == dv){  //这里要求周围没有选的
		f[now][3] = f[now][2]; g[now][3] = g[now][2];
		For(i, 0, 2) f[now][i] = INF, g[now][i] = 0;
	}
}
void Solve(){
	cin >> n;
	For(i, 1, n){
		int u, v; cin >> u >> v;
		e[u].emplace_back(v);
		e[v].emplace_back(u);
		deg[u]++; deg[v]++;
	}
	queue<int> q;
	fill(inc + 1, inc + n + 1, 1);
	For(i, 1, n) if(deg[i] == 1) q.push(i);
	while(!q.empty()){
		int now = q.front(); q.pop();
		inc[now] = 0;
		for(int to : e[now]){
			deg[to]--;
			if(deg[to] == 1) q.push(to);
		}
	}
	For(i, 1, n) if(inc[i])
		for(int j : e[i]) if(inc[j]) du = i, dv = j;
	e[du].erase(find(e[du].begin(), e[du].end(), dv));
	e[dv].erase(find(e[dv].begin(), e[dv].end(), du));

	int ans = INF;
	For(i, 1, n){
		f[i][0] = f[i][1] = f[i][2] = f[i][3] = INF;
		g[i][0] = g[i][1] = g[i][2] = g[i][3] = 0;
	}
	dfs1(du, 0);
	if(g[du][1]) ans = min(ans, f[du][1]);

	For(i, 1, n){
		f[i][0] = f[i][1] = f[i][2] = f[i][3] = INF;
		g[i][0] = g[i][1] = g[i][2] = g[i][3] = 0;
	}
	dfs2(du, 0);
	if(g[du][0]) ans = min(ans, f[du][0]);

	For(i, 1, n){
		f[i][0] = f[i][1] = f[i][2] = f[i][3] = INF;
		g[i][0] = g[i][1] = g[i][2] = g[i][3] = 0;
	}
	dfs3(du, 0);	
	if(g[du][3]) ans = min(ans, f[du][3]);

	For(i, 1, n){
		f[i][0] = f[i][1] = f[i][2] = f[i][3] = INF;
		g[i][0] = g[i][1] = g[i][2] = g[i][3] = 0;
	}
	dfs4(du, 0);
	if(g[du][2]) ans = min(ans, f[du][2]);

	if(ans == INF) cout << -1 << '\n';
	else cout << ans << '\n';
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int T = 1; //cin >> T;
	while(T--) Solve();
	return 0;
}
```

---

## 作者：2020tanjunming (赞：3)

### 题解
首先，我们知道，基环树是一棵树上加一条边所得到的。下文称这条边为特殊边，我们可以求出特殊边的两个端点 $fm$ 和 $to$。

设 $f_{i,0/1/2/3}$ 表示 $i$ 的子树在对应状态下的最小染色点数，对应状态如下：
-  $0$ 表示点 $i$ 未染色，且 $i$ 的不包括父亲的邻接点都没有被染色（如果有点 $i$ 在特殊边上，特殊边的另一点也为被染色）
-  $1$ 表示点 $i$ 未染色，且 $i$ 的不包括父亲的邻接点中有一个点被染色
-  $2$ 表示点 $i$ 被染色，且 $i$ 的不包括父亲的邻接点都没有被染色
-  $3$ 表示点 $i$ 被染色，且 $i$ 的不包括父亲的邻接点中有一个点被染色

直接做树型 DP 即可。

对于特殊边上的两个端点 $fm$ 和 $to$，枚举它们的颜色（枚举分别是否染色，只要枚举四次），在做树型 DP 时对这两个点特殊处理一下即可。

时间复杂度为 $O(n)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long inf=1e9;
int n,x,y,fm,to,tot=0,d[200005],l[200005],r[200005],dep[100005];
int nd[100005];
long long ans=inf,f[100005][4];
void add(int xx,int yy){
	l[++tot]=r[xx];d[tot]=yy;r[xx]=tot;
}
void gt(int u,int fa){
	dep[u]=dep[fa]+1;
	for(int i=r[u];i;i=l[i]){
		if(d[i]==fa) continue;
		if(dep[d[i]]){
			if(dep[d[i]]<dep[u]){
				fm=u;to=d[i];
			}
			continue;
		}
		gt(d[i],u);
	}
}
void dfs(int u,int fa){
	f[u][0]=0;f[u][2]=1;
	long long v1=inf,v2=inf;
	for(int i=r[u];i;i=l[i]){
		if(d[i]==fa) continue;
		if(nd[d[i]]!=-1&&nd[u]!=-1) continue;
		dfs(d[i],u);
		f[u][0]+=f[d[i]][1];
		v1=min(v1,f[d[i]][3]-f[d[i]][1]);
		f[u][2]+=f[d[i]][0];
		v2=min(v2,f[d[i]][2]-f[d[i]][0]);
	}
	f[u][1]=f[u][0]+v1;
	f[u][3]=f[u][2]+v2;
	if(nd[u]!=-1){
		if(nd[u]==0){
			f[u][2]=f[u][3]=inf;
		}
		else if(nd[u]==1){
			f[u][1]=f[u][0];
			f[u][0]=f[u][2]=f[u][3]=inf;
		}
		else if(nd[u]==2){
			f[u][0]=f[u][1]=inf;
		}
		else{
			f[u][3]=f[u][2];
			f[u][0]=f[u][1]=f[u][2]=inf;
		}
	}
}
void dd(int v1,int v2){
	nd[fm]=v1;nd[to]=v2;
	for(int i=1;i<=n;i++){
		f[i][0]=f[i][1]=f[i][2]=f[i][3]=inf;
	}
	dfs(1,0);
	ans=min(ans,min(f[1][1],f[1][3]));
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	gt(1,0);
	memset(nd,-1,sizeof(nd));
	dd(0,0);
	dd(1,2);
	dd(2,1);
	dd(3,3);
	if(ans==inf) ans=-1;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Glacial_Shine (赞：2)

# 题目大意

给定一个 $n$ 个点的基环树，现在对基环树上的点染色，使得每个点都有且仅有一个与他相连的点（不包括它自身）被染色，求最少的染色点数，或者返回无解。

# 思路

先考虑树的情况。

容易想到 DP，我们设 $f_{i,1/0,1/0}$ 表示在第 $i$ 个点，它有没有染色，它的儿子中有没有染过色的。

很容易写出 DP 式。

由于是基环树，我们先把环找出来，然后对于环之外的树可以以环上的点为根先做树形 DP（不包括环上的点），求出来对应的 $f$ 值。

然后考虑环上，照样考虑 DP，设 $g_{i,1/0,2/1/0}$ 表示在第 $i$ 个点，它有没有染色，它是右边还是左边还是儿子的点染色。

但是由于是环，有后效性，于是我们可以枚举一个点的状态，然后当成链来做，最后将枚举到的最后一个点的合法状态的值取最小值即可。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, Ecnt, last[100005], rt, to, bz[100005], fa[100005], d[100005], f[100005][2][2], ans, g[100005][2][3];
struct Edge { int to, next; } E[200005];
void addedge(int u, int v) { Ecnt++, E[Ecnt].next = last[u], last[u] = Ecnt, E[Ecnt].to = v; }
void dfs(int x) {
    bz[x] = 1;
    for (int xy = last[x]; xy; xy = E[xy].next)
        if (!bz[E[xy].to])
            fa[E[xy].to] = x, d[E[xy].to] = d[x] + 1, dfs(E[xy].to);
}
void change(int x, int y) {
    bz[x] = 2;
    if (d[x] < d[y])
        swap(x, y);
    if (x == y) {
        rt = x;
        return ;
    }
    change(fa[x], y);
}
void DP(int x, int fa) {
    int son = 0;
    for (int xy = last[x]; xy; xy = E[xy].next)
        if (!bz[E[xy].to])
            son++, bz[E[xy].to] = 1, DP(E[xy].to, x), f[x][0][0] = f[x][0][0] + f[E[xy].to][0][1], f[x][1][0] = f[x][1][0] + f[E[xy].to][0][0];
    for (int xy = last[x]; xy; xy = E[xy].next)
        if (bz[E[xy].to] == 1 && E[xy].to != fa) {
            f[x][0][1] = min(f[x][0][1], f[x][0][0] - f[E[xy].to][0][1] + f[E[xy].to][1][1]);
            f[x][1][1] = min(f[x][1][1], f[x][1][0] - f[E[xy].to][0][0] + f[E[xy].to][1][0]);
        }
    f[x][1][0]++, f[x][1][1]++;
}
void get(int x, int fa) {
    for (int xy = last[x]; xy; xy = E[xy].next)
        if (bz[E[xy].to] == 2 && E[xy].to != fa && E[xy].to != to) {
            if (E[xy].to == rt) {
                to = x;
                return ;
            }
            for (int have = 0; have < 2; have++)
                for (int where = 0; where < 3; where++) {
                    if (have == 1)
                        g[E[xy].to][have][where] = min(g[E[xy].to][have][where], g[x][where == 1][2] + f[E[xy].to][have][where == 0]);
                    else
                        g[E[xy].to][have][where] = min(g[E[xy].to][have][where], min(g[x][where == 1][0], g[x][where == 1][1]) + f[E[xy].to][have][where == 0]);
                }
            get(E[xy].to, x);
        }
}
void solve() {
    for (int i = 1; i <= n; i++)
        f[i][1][1] = f[i][0][1] = n + 1;
    ans = n + 1;
    for (int i = 1; i <= n; i++)
        if (bz[i] == 2)
            DP(i, 0);//以环上的点为根做树形DP
    for (int have = 0; have < 2; have++) {
        for (int where = 0; where < 3; where++) {
            for (int i = 1; i <= n; i++)
                for (int j = 0; j < 3; j++)
                    g[i][0][j] = g[i][1][j] = n + 1;
            g[rt][have][where] = f[rt][have][where == 0], to = 0;
            get(rt, 0);
            if (have == 1)
                ans = min(ans, g[to][where == 1][2]);
            else
                ans = min(ans, min(g[to][where == 1][0], g[to][where == 1][1]));
        }
    }
    if (ans == n + 1)
        printf("-1");
    else
        printf("%d\n", ans);
}
int main() {
    scanf("%d", &n);
    for (int i = 1, u, v; i <= n; i++)
        scanf("%d%d", &u, &v), addedge(u, v), addedge(v, u);
    dfs(1);//先建树
    for (int i = 1; i <= n; i++)
        bz[i] = 0;
    for (int x = 1; x <= n; x++)
        for (int xy = last[x]; xy; xy = E[xy].next)
            if (fa[E[xy].to] != x && E[xy].to != fa[x]) {//找环
                bz[x] = bz[E[xy].to] = 2;
                change(x, E[xy].to);//标记环上的点
                solve();
                return 0;
            }
    return 0;
}
```


---

## 作者：Tsawke (赞：2)

# COCI2021-2022 Contest1 T3 题解

[TOC]

## [更好的阅读体验戳此进入](http://blog.monkey-hyx.tech?t=COCI-2021-2022-Contest1)

（建议您从上方链接进入我的个人网站查看此 Blog，在 Luogu 中图片会被墙掉，部分 Markdown 也会失效）

## [原题面链接](https://hsin.hr/coci/contest1_tasks.pdf)

## [Luogu题面](https://www.luogu.com.cn/problem/list?keyword=COCI2021-2022%231&page=1)

## T3 Logičari

### 题面

对一个基环树进行染色，使每个点有且仅有一个，不包括自身的，与他相连的点被染色，求最少染色数（包括无解情况）。

$ n \le 10^5 $。

### Examples

**Input_1**

> 4
>
> 1 2
>
> 2 3
>
> 3 4
>
> 4 1

**Output_1**

> 2

**Input_2**

> 3
>
> 1 2
>
> 2 3
>
> 3 1

**Output_2**

> -1

**Input_3**

> 7
>
> 1 2
>
> 2 3
>
> 3 4
>
> 4 5
>
> 5 6
>
> 6 7
>
> 2 4

**Output_3**

> 4

### Solution

#### 思路

该说不说这题的细节是真的多，改了一下午才过了...

不过这题也挺套路，核心思路考虑把基环树拆开做树上 $ \texttt{DP} $。

观察题意，首先考虑如果是普通树上的染色问题，很套路的树上 $ \texttt{DP} $ 即可解决，而基环树与普通树的区别，也就是多了一条边，使“树”上有且仅有一个环，那么我们的思路也就是将他转化为普通的树上问题。

于是考虑找到环上的任意一个边并将其断开，然后枚举这两个点可能的状态，并在 $ \texttt{DP} $ 的时候随时考虑这两个点。

#### 找环上边

一般有两种方法，一种是维护并查集，当新的边连接的两个节点，是同一颗子树上的时候，要找的就是这个边。

另一种方式更简便一些，$ \texttt{DFS} $ 遍历整个树，当访问到了非父亲节点，但曾经访问过的节点时便说明这个边是环上的边。

```cpp
void FindLoop(int p, int fa){
    for(auto i = head[p]; i; i = i->nxt){
        if(i->to != fa && vis[i->to]){loop = make_pair(p, i->to); return;}
        if(i->to != fa){vis[i->to] = true; FindLoop(i->to, p);}
    }
}
```

#### 删边

如果用的并查集维护，直接记录下并不将这个边存到树里即可。

如果用的 $ \texttt{DFS} $，那么可以考虑直接遍历找到点删除，或每次调用的时候都判断是否为删掉的这个边。

```cpp
void RemoveLoop(void){
    for(auto i = head[loop.first], lasti = (Edge*)npt; i; lasti = i, i = i->nxt){
        if(i->to == loop.second){
            lasti
                ? lasti->nxt = i->nxt
                : head[loop.first] = i->nxt;
            break;
        }
    }
    for(auto i = head[loop.second], lasti = (Edge*)npt; i; lasti = i, i = i->nxt){
        if(i->to == loop.first){
            lasti
                ? lasti->nxt = i->nxt
                : head[loop.second] = i->nxt;
            break;
        }
    }
    tie(root1, root2) = loop;
}
```

#### 状态设计

考虑在普通的树形 $ \texttt{DP} $ 中考虑被分割的两个节点，这里定义为 $ \texttt{root1} $ 和 $ \texttt{root2} $。

考虑令被染色为 $ \texttt{true} $，未被染色为 $ \texttt{false} $。

设 $ dp(i, j, k, l, m) $ 表示当前计算到了 $ i $ 节点，其状态和其父亲状态分别为 $ j, k $，两个根的状态分别为 $ l,m $。

因为每个点有且只有一个与之相连的节点会被染色，所以我们可以考虑先假设当前节点所有子节点都不染色，并计算求和，然后分别枚举其每一个子节点，计算如果将该子节点涂色最终需要涂多少点，并取最小值。

但是这题的最大难点我认为就是上面这些过程中合法性的判断，也就是细节的处理。

同时因为状态十分复杂，考虑用 $ \texttt{DFS} $ + 记忆化实现。

#### 细节处理

首先我们需要考虑，哪些状态是不可能出现的：

1. 遍历到某个根节点，但当前状态与根节点已经定下来的状态不同。
2. 遍历到某个根节点，父亲节点已被染色，且两个根节点都被染色，导致其中某个根节点，考虑上被临时删除的边之后有两个相连的点被染色。

```cpp
if(
    (currentPosition == root1 && currentStatus != root1Status) ||
    (currentPosition == root2 && currentStatus != root2Status) ||
    (currentPosition == root1 && fatherStatus && root2Status) ||
    (currentPosition == root2 && fatherStatus && root1Status)
)return DEFAULT_DP = INF;
```

然后我们需要考虑，什么时候当前的节点的子节点都不能被染色：

1. 父节点已经被染色，即当前节点已经有了一个节点与之相连且被染色。
2. 当前节点到了某一个根节点，而另一个根节点已被染色，与 $ 1 $ 同理。

```cpp
if(
    fatherStatus ||
    (currentPosition == root1 && root2Status) ||
    (currentPosition == root2 && root1Status)
) ret = min(ret, sonCost);
```

还有个很重要的点就是我们假设都不染色进行求和操作的时候会爆 `` int `` 所以需要在求和时需要开 `` long long ``。 

#### 主函数

回到我们之前说的，要枚举两个根节点的状态，我们可以考虑令其从其中某个根节点开始遍历，显然会简便很多，显然一共可能有如下四种情况。

```cpp
int ans = min(
    {
        Tintage(root1, 0, 0, 0, 0, -1),
        Tintage(root1, 0, 0, 0, 1, -1),
        Tintage(root1, 1, 0, 1, 0, -1),
        Tintage(root1, 1, 0, 1, 1, -1),
        INF
    }
);
```

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define INF 11451400
#define DEFAULT_DP dp[currentPosition][currentStatus][fatherStatus][root1Status][root2Status]

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;

template<typename T = int>
inline T read(void);

int N;
bool vis[110000];
pair < int, int >/*from, to*/ loop;
int root1, root2;

struct Edge{
    Edge* nxt;
    int to;
    void* operator new(size_t);
    Edge(Edge* nxt, int to):nxt(nxt), to(to){;}
    Edge(void) = default;
}eData[210000];
void* Edge::operator new(size_t){static Edge* P = eData; return ++P;}

Edge* head[110000];
int dp[110000][2][2][2][2]; /*CurrentPosition, CurrentStatus, FatherStatus, Root1Status, Root2Status*/

void FindLoop(int = 1, int = -1);
void RemoveLoop(void);
int Tintage(int, bool, bool, bool, bool, int);

int main(){
    memset(dp, -1, sizeof(dp));
    N = read();
    for(int i = 1; i <= N; ++i){
        int from = read(), to = read();
        head[from] = new Edge(head[from], to);
        head[to] = new Edge(head[to], from);
    }
    FindLoop();
    RemoveLoop();
    int ans = min(
        {
            Tintage(root1, 0, 0, 0, 0, -1),
            Tintage(root1, 0, 0, 0, 1, -1),
            Tintage(root1, 1, 0, 1, 0, -1),
            Tintage(root1, 1, 0, 1, 1, -1),
            INF
        }
    );
    printf("%d\n", ans == INF ? -1 : ans);
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}
int Tintage(int currentPosition, bool currentStatus, bool fatherStatus, bool root1Status, bool root2Status, int fatherPosition){
    if(~DEFAULT_DP)return DEFAULT_DP;
    if(
        (currentPosition == root1 && currentStatus != root1Status) ||
        (currentPosition == root2 && currentStatus != root2Status) ||
        (currentPosition == root1 && fatherStatus && root2Status) ||
        (currentPosition == root2 && fatherStatus && root1Status)
    )return DEFAULT_DP = INF;
    ll sonCost(currentStatus);
    for(auto i = head[currentPosition]; i; i = i->nxt)
        if(i->to != fatherPosition)
            sonCost += Tintage(i->to, false, currentStatus, root1Status, root2Status, currentPosition);
    ll ret(INF);
    if(
        fatherStatus ||
        (currentPosition == root1 && root2Status) ||
        (currentPosition == root2 && root1Status)
    ) ret = min(ret, sonCost);
    else 
        for(auto i = head[currentPosition]; i; i = i->nxt)
            if(i->to != fatherPosition)
                ret = min({
                    ret,
                    (ll)INF,
                    sonCost - Tintage(i->to, false, currentStatus, root1Status, root2Status, currentPosition)
                            + Tintage(i->to, true,  currentStatus, root1Status, root2Status, currentPosition)
                });
    return DEFAULT_DP = ret;
}
void RemoveLoop(void){
    for(auto i = head[loop.first], lasti = (Edge*)npt; i; lasti = i, i = i->nxt){
        if(i->to == loop.second){
            lasti
                ? lasti->nxt = i->nxt
                : head[loop.first] = i->nxt;
            break;
        }
    }
    for(auto i = head[loop.second], lasti = (Edge*)npt; i; lasti = i, i = i->nxt){
        if(i->to == loop.first){
            lasti
                ? lasti->nxt = i->nxt
                : head[loop.second] = i->nxt;
            break;
        }
    }
    tie(root1, root2) = loop;
}
void FindLoop(int p, int fa){
    for(auto i = head[p]; i; i = i->nxt){
        if(i->to != fa && vis[i->to]){loop = make_pair(p, i->to); return;}
        if(i->to != fa){vis[i->to] = true; FindLoop(i->to, p);}
    }
}

template<typename T>
inline T read(void){
    T ret(0);
    short flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```


## UPD

update-2022_08_30 T1-T3

update-2022_09_01 完成一部分的 T4

update-2022_09_02 T4 肝完

update-2022_09_04 初稿

update-2022_09_04 发现 T4 之前算法假掉了，修改了一下

update-2022_09_06 完善 latex 以符合 Luogu 题解要求

---

## 作者：binbin_200811 (赞：1)

## [P7929 COCI2021-2022#1 Logičari](https://www.luogu.com.cn/problem/P7929)

基环树 dp，从更方便的角度思考，看做树和多出来的一条边，要注意一个被染色的点周围也要有一个点被染色。

考虑树证明处理，设 $dp[i][0/1][0/1]$ 表示第 $i$ 个点是否染色，$i$ 是否有一个儿子染色。

有转移：
$$
dp[u][0][0]=\sum_{v\in u.sons} dp[v][0][1]\\
dp[u][0][1]=\sum_{v\in u.sons} dp[v][0][1]+\min(dp[v][1][1]-dp[v][0][1])\\
dp[u][1][0]=1+\sum_{v\in u.sons} dp[v][0][0]\\
dp[u][0][0]=\sum_{v\in u.sons} dp[v][0][1]+\min(dp[v][1][0]-dp[v][0][0])
$$
对于叶子节点：$dp[u][0][0]=0,dp[u][0][1]=+\infty,dp[u][1][0]=1,dp[u][1][1]=+\infty$。

接着分类讨论一下通过多出来的边连接的两个点，其中其中一个为根（$rt$）（确实也要从 $rt$ 开始 dp），一个为根的兄弟（$rt-bro$）。

下面的 $1$ 表示被染色，$0$ 表示未被染色。

1. $rt=1,rt-bro=0$：

   $dp[rt-bro][1][1]=+\infty,dp[rt-bro][1][0]=+\infty,dp[rt-bro][0][1]=dp[rt-bro][0][0],dp[rt-bro][0][0]=+\infty$。

   其中 $dp[rt-bro][0][1]=dp[rt-bro][0][0]$ 表示 $dp[rt-bro][0][1]$ 需要通过 $dp[rt-bro][0][0]$ 的方程转移，下同。

   答案为 $dp[rt][1][1]$。

2. $rt=1,rt-bro=1$：

   $dp[rt-bro][1][1]=dp[rt-bro][1][0],dp[rt-bro][1][0]=+\infty,dp[rt-bro][0][1]=+\infty,dp[rt-bro][0][0]=+\infty$。

   答案为 $dp[rt][1][0]$。

3. $rt=0,rt-bro=0$：

   $dp[rt-bro][1][1]=+\infty,dp[rt-bro][1][0]=+\infty$。

   答案为 $dp[rt][0][1]$。

4. $rt=0,rt-bro=1$：

   $dp[rt-bro][0][1]=+\infty,dp[rt-bro][0][0]=+\infty$。

   答案为 $dp[rt][0][0]$。

若上述四种情况均为 $+\infty$，则无解。

否则取最小值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long

#define inf 1e9

const int maxn=1e5+5;

struct Edge
{
    int tot;
    int head[maxn];
    struct edgenode{int to,nxt;}edge[maxn*2];
    inline void add(int x,int y)
    {
        tot++;
        edge[tot].to=y;
        edge[tot].nxt=head[x];
        head[x]=tot;
    }
}T;

int n,rt,rt_bro,flg;
int f[maxn];

ll ans=inf;
ll dp[maxn][2][2];

inline int fr(int u){return f[u]==u?u:f[u]=fr(f[u]);}

inline void dfs(int u,int f)
{
    dp[u][0][1]=dp[u][1][1]=inf;
    for(int i=T.head[u];i;i=T.edge[i].nxt)
    {
        int v=T.edge[i].to;
        if(v==f) continue;
        dfs(v,u);
        dp[u][0][0]+=dp[v][0][1];
        if(dp[v][1][1]<inf) dp[u][0][1]=min(dp[u][0][1],dp[v][1][1]-dp[v][0][1]);
        dp[u][1][0]+=dp[v][0][0];
        if(dp[v][1][0]<inf) dp[u][1][1]=min(dp[u][1][1],dp[v][1][0]-dp[v][0][0]);
    }
    dp[u][0][1]=dp[u][0][0]+dp[u][0][1];
    dp[u][1][0]++;
    dp[u][1][1]=dp[u][1][0]+dp[u][1][1];
    if(u==rt_bro)
    {
        if(flg==1)
        {
            dp[u][1][1]=inf,dp[u][1][0]=inf,dp[u][0][1]=dp[u][0][0],dp[u][0][0]=inf;
        }
        else if(flg==2)
        {
            dp[u][1][1]=dp[u][1][0],dp[u][1][0]=inf,dp[u][0][1]=inf,dp[u][0][0]=inf;
        }
        else if(flg==3)
        {
            dp[u][1][0]=inf,dp[u][1][1]=inf;
        }
        else
        {
            dp[u][0][0]=inf,dp[u][0][1]=inf;
        }
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        int fu=fr(u),fv=fr(v);
        if(fu==fv) {rt=u,rt_bro=v;continue;}
        T.add(u,v),T.add(v,u);
        f[fu]=fv;
    }
    memset(dp,0,sizeof(dp));
    flg=1;
    dfs(rt,0);
    ans=min(ans,dp[rt][1][1]);
    memset(dp,0,sizeof(dp));
    flg=2;
    dfs(rt,0);
    ans=min(ans,dp[rt][1][0]);
    memset(dp,0,sizeof(dp));
    flg=3;
    dfs(rt,0);
    ans=min(ans,dp[rt][0][1]);
    memset(dp,0,sizeof(dp));
    flg=4;
    dfs(rt,0);
    ans=min(ans,dp[rt][0][0]);
    printf("%lld",ans<inf?ans:-1);
}
```

---

## 作者：2018ljw (赞：1)

模拟赛赛时想了一个很诡异的 dp，结果因为一个细节判错爆零。

算是一个比较奇特的解法。以下先不考虑无解，原因最后说明。

首先考虑放到树上怎么做，应该是比较显然的。设 $dp_{x,4}$ 表示 $x$ 的情况如下时，子树内最少染色点数。

1. $dp_{x,0}$ 表示 $x$ 没被染色，$x$ 的一个儿子有颜色。
2. $dp_{x,1}$ 表示 $x$ 被染色，$x$ 的一个儿子有颜色。
3. $dp_{x,2}$ 表示 $x$ 没被染色，$x$ 的父亲有颜色。
4. $dp_{x,3}$ 表示 $x$ 被染色，$x$ 的父亲有颜色。

转移也不难处理。

$$
\begin{cases}dp_{x,0}=\sum dp_{y,0}+\min\{dp_{y,1}-dp_{y,0}\}\\dp_{x,1}=\sum dp_{y,2}-\min\{dp_{y,3}-dp_{y,2}\}+1\\dp_{x,2}=\sum dp_{y,0}\\dp_{x,3}=\sum dp_{y,2}+1\end{cases}
$$

初值：叶子节点的 $dp_{x,2}=0$ 和 $dp_{x,3}=1$，另两项设为 $\inf$。

那么我们把环上的一个点提到根，然后对环上节点的每个子树先跑一遍这样的 $dp$，然后开始着手处理环上点的情况。

对于环上的点，其也有四种情况。出于统一和写法方便，这四种情况也表示为 $0$ 到 $3$。

1. 情况 $0$：$x$ 无颜色，$x$ 的环外子树无颜色。
2. 情况 $1$：$x$ 无颜色，$x$ 的环外子树有颜色。
3. 情况 $2$：$x$ 有颜色，$x$ 的环外子树无颜色。
4. 情况 $3$：$x$ 有颜色，$x$ 的环外子树有颜色。

便于理解，先放下这四种情况对应的大致结构。其中实心点表示该点染色，空心点表示不染色。

![](https://cdn.luogu.com.cn/upload/image_hosting/yuslzt2i.png)

那么我们问题转化为，给环上每个点赋一个 $[0,3]$ 内的权值 $p_i$，最小化 $\sum val_{i,p_i}$ 且保证 $p_i$ 序列合法。

先考虑如何求 $val_x$。

实际上根据图片和树部分的转移方程就已经很明显了。

$$
\begin{cases}val_{x,0}=\sum dp_{y,0}\\val_{x,1}=\sum dp_{y,0}+\min\{dp_{y,1}-dp_{y,0}\}\\val_{x,2}=\sum dp_{y,2}\\val_{x,3}=\sum dp_{y,2}+\min\{dp_{y,3}-dp_{y,2}\}\end{cases}
$$

然后考虑什么样的 $p$ 序列是合法的，考虑从每种点的需求入手。

1. $p_x=0$，$x$ 相邻项必须有恰好一个 $p\ge2$。
2. $p_x=1$，$x$ 相邻项必须有 $p\le 1$。
3. $p_x=2$，$x$ 相邻项必须有恰好一个 $p\ge 2$，同时 $x$ 相邻项必须有 $p\in\{0,2\}$。
4. $p_x=3$，$x$ 相邻项只能为 $p=0$。

人话翻译一下就是：

1. $0$ 可以和任何数相邻，但恰好要有一个 $2$ 或 $3$。
2. $1$ 只能和 $0$ 或 $1$ 相邻。
3. $2$ 只能和 $0$ 或 $2$ 相邻，并且两侧必须有恰好一个 $2$。
4. $3$ 只能和 $0$ 相邻。  

观察如果我们想把 $2$ 和 $3$ 塞到序列里，会变成什么样。

显然只能是 $0220$ 和 $030$ 两种。唯一特例是环长为 $2$ 时，$22$ 也是一种可行方案。而对于 $1$，其可以随便放在剩下的位置。

记环长为 $m$，那么除了 $m=2$ 时的 $22$ 方案外，对于剩下的所有方案而言，一定存在一种环上划分方式，使得划分后每个区间都形如 $0220$、$030$、$1$ 这三种之一。

那么就可以开始第二次 dp 了。为了除掉环的影响，我们规定随便先切一刀，然后在形成的链上处理。

设 $f_{i}$ 表示以 $i$ 为一段区间的结尾，前面部分划分后的最小值。初值 $f_0=0$。

枚举填的是哪一种区间，可以得到如下转移。

$$
f_{i}=\min\begin{cases}f_{i-1}+val_{i,1}\\f_{i-3}+val_{i-2,0}+val_{i-1,3}+val_{i,0}\\f_{i-4}+val_{i-3,0}+val_{i-2,2}+val_{i-1,2}+val_{i,0}\end{cases}
$$

最终该种划分对应的答案为 $f_m$。

然后考虑在哪些位置切下这一刀，可以保证最终统计答案不漏情况。

关注到对于任意一个长度为 $4$ 的区间，其中必定包含一个完整的划分段，所以我们只需要枚举第一刀在前四个位置中具体哪个位置前即可。

是不是好像没判无解？关注到对于任意 $dp=\inf$ 的情况，必定对应一个不合法情况。而在三次转移的过程中，一旦选择了一个无解的位置，那么转移后的值一定还是 $\inf$。所以在做完这么多次操作后，只需要看最后得到的结果是否为 $\inf$ 级别即可。

复杂度 $O(n)$。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const long long inf=1e12;
using namespace std;
int n,f[100001],fa[100001],dep[100001];
int hed[100001],net[200001],ver[200001],tot;
void add(int x,int y){
	ver[++tot]=y;
	net[tot]=hed[x];
	hed[x]=tot;
}
int fnd(int x){return x==f[x]?x:f[x]=fnd(f[x]);}
bool on[100001];
long long val[100001][4],dp[100001][4];
long long g[100002];
void dfs(int x){
	dep[x]=dep[fa[x]]+1;
	int i,son=0;
	long long mn0=inf,mn1=inf;
	for(i=hed[x];i;i=net[i]){
		int y=ver[i];
		if(y==fa[x])continue;
		son++;
		fa[y]=x;
		dfs(y);
		dp[x][0]+=dp[y][0];
		dp[x][2]+=dp[y][0];
		dp[x][1]+=dp[y][2];
		dp[x][3]+=dp[y][2];
		mn0=min(mn0,dp[y][1]-dp[y][0]);
		mn1=min(mn1,dp[y][3]-dp[y][2]);
	}
	dp[x][0]+=mn0;
	dp[x][1]+=mn1;
	dp[x][1]++;
	dp[x][3]++;
}
int main(){
	int i,j;
	int px,py;
	scanf("%d",&n);
	for(i=1;i<=n;i++)f[i]=i;
	for(i=1;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		int p=fnd(x),q=fnd(y);
		if(p==q){
			px=x;py=y;
			continue;
		}
		add(x,y);
		add(y,x);
		f[p]=q;
	}
	dfs(px);
	int m=dep[py];
	for(i=py;i;i=fa[i])on[i]=1;
	for(i=py;i;i=fa[i]){
		long long mn0=inf,mn1=inf;
		for(j=hed[i];j;j=net[j]){
			int y=ver[j];
			if(on[y])continue;
			val[i][0]+=dp[y][0];
			val[i][1]+=dp[y][0];
			val[i][2]+=dp[y][2];
			val[i][3]+=dp[y][2];
			mn0=min(mn0,dp[y][1]-dp[y][0]);
			mn1=min(mn1,dp[y][3]-dp[y][2]);
		}
		val[i][1]+=mn0;
		val[i][3]+=mn1;
		val[i][2]++;val[i][3]++;
	}
	long long res=inf,sum=0;
	if(dep[py]==1)res=min(dp[px][0],dp[px][1]);
	if(dep[py]==2)res=min(res,val[px][2]+val[py][2]);
	for(i=py;i;i=fa[i])for(j=0;j<4;j++)dp[dep[i]][j]=val[i][j];
	for(i=1;i<=m;i++)for(j=0;j<4;j++)val[i][j]=dp[i][j];
	for(i=1;i<=m;i++)sum+=val[i][1];res=min(res,sum);
	if(dep[py]==3){
		sum=val[1][0]+val[2][0]+val[3][0];
		for(i=1;i<=3;i++)res=min(res,sum-val[i][0]+val[i][3]);
	}
	if(dep[py]<=3){
		if(res>n)res=-1;
		printf("%lld",res);
		return 0;
	}
	if(dep[py]==4){
		sum=0;
		for(i=1;i<=4;i++)sum+=val[i][0];
		for(i=1;i<=4;i++){
			int nx=i%4+1;
			res=min(res,sum-val[i][0]-val[nx][0]+val[i][2]+val[nx][2]);
		}
	}
	for(i=0;i<4;i++)val[0][i]=val[m][i];
	for(i=0;i<=3;i++){
		memset(g,0x3f,sizeof(g));
		g[i]=0;
		for(j=i+1;j<=m;j++){
			g[j]=g[j-1]+val[j][1];
			if(j>=3)g[j]=min(g[j],g[j-3]+val[j-2][0]+val[j-1][3]+val[j][0]);
			if(j>=4)g[j]=min(g[j],g[j-4]+val[j-3][0]+val[j-2][2]+val[j-1][2]+val[j][0]);
		}
		g[0]=g[m];
		for(j=1;j<=i;j++){
			g[j]=g[j-1]+val[j][1];
			int p4=(j>=4?j-4:j-4+m);
			int p3=(j>=3?j-3:j-3+m),p2=(j>=2?j-2:j-2+m);
			g[j]=min(g[j],g[p3]+val[p2][0]+val[j-1][3]+val[j][0]);
			if(dep[py]>=4)g[j]=min(g[j],g[p4]+val[p3][0]+val[p2][2]+val[j-1][2]+val[j][0]);
		}
		res=min(res,g[i]);
	}
	if(res>n)res=-1;
	printf("%lld",res);
}
```

---

## 作者：Hope888 (赞：0)

先做子树。设状态 $f(i,j=0/1,k=0/1)$ 表示在 $i$ 点，$i$ 点是否选了，$i$ 的儿子中选了 $k$ 个点的答案。转移时枚举每个点选或不选。

考虑环的部分，先断环成链，然后钦定链首尾的两个点是否选择，然后对着上面的东西做一样的 dp。具体地，转移枚举上一个点是否选，上上个点是否选，当前点是否选，当前点的儿子选了几个。最后把四种钦定的情况的答案取最优的即可。

---

## 作者：xiezheyuan (赞：0)

## 思路

模拟赛的题，切了开心。

将基环树的环断掉，先跑树形 dp，再跑环上 dp。

考虑树的情况，设 $f(i,0/1,0/1)$ 表示考虑到点 $i$ 的子树，$i$ 是否被染色，$i$ 的父亲是否被染色，求最少染色数量。

$$
\begin{aligned}
&f(i,0,0)=\sum_{v\in\text{son}(u)}f(v,0,0) - \max_{v\in \text{son}(u)} f(v,1,0)-f(v,0,0)\\
&f(i,0,1)=\sum_{v\in\text{son}(u)}f(v,0,0)\\
&f(i,1,0)=1+\sum_{v\in\text{son}(u)}f(v,0,1) - \max_{v\in \text{son}(u)} f(v,1,1)-f(v,0,1)\\
&f(i,1,1)=1+\sum_{v\in\text{son}(u)}f(v,0,1)\\
\end{aligned}
$$

注意对于叶子结点 $i$（包括单个根节点），有：

$$
\begin{aligned}
&f(0,0)=+\infty\\
&f(0,1)=0\\
&f(1,0)=+\infty\\
&f(1,1)=1
\end{aligned}
$$

考虑在环上 dp，环的最大不同是选定的起点和终点之间有一条边。

不过我们可以改为在序列上 dp，然后考虑怎样计算贡献？假设环的编号为 $1,2,\cdots,K$。

任意选择两个环上相邻点作为 dp 的起点和终点，比如 $1$ 和 $K$。枚举起点终点的染色状态，然后转移，转移完成后用终点合法的贡献去更新答案。

设 $g(i,0/1,0/1,0/1)$ 表示第 $i$ 个点，自己有没有被染色，左边（指 $i-1$）有没有被染色，儿子有没有被染色。

$$
\begin{aligned}
&g(i,0,0,0)=\min(g(i-1,0,0,1),g(i-1,0,1,0))+f(i,0,1)\\
&g(i,0,0,1)=\min(g(i-1,0,0,1),g(i-1,0,1,0))+f(i,0,0)\\
&g(i,0,1,0)=\min(g(i-1,1,1,0),g(i-1,1,0,1))+f(i,0,1)\\
&g(i,0,1,1)=+\infty\\
&g(i,1,0,0)=g(i-1,0,0,0)+f(i,1,1)\\
&g(i,1,0,1)=g(i-1,0,0,0)+f(i,1,0)\\
&g(i,1,1,0)=g(i-1,1,0,0)+f(i,1,1)\\
&g(i,1,1,1)=+\infty
\end{aligned}
$$

对于最后的统计答案，我们需要分四种情况讨论：

1. $1$ 不染色，$K$ 不染色。初始状态 $g(1,0,0,0)=f(1,0,1),g(1,0,0,1)=f(1,0,0)$。最终结果 $\min(g(K,0,1,0),g(K,0,0,1))$。
2. $1$ 不染色，$K$ 染色。初始状态 $g(1,0,1,0)=f(1,0,1)$，最终结果 $\min(g(K,1,1,0),g(K,1,0,1))$。
3. $1$ 染色，$K$ 不染色，初始状态 $g(1,1,0,0)=f(1,1,1),g(1,1,0,1)=f(1,1,0)$。最终结果 $g(K,0,0,0)$。
4. $1$ 染色，$K$ 染色，初始状态 $g(1,1,1,0)=f(1,1,1)$，最终结果 $g(K,1,0,0)$。

把这些情况都 dp 一遍，最后取 $\min$ 即可。

时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 5;
vector<int> t[N];
int f[N][2][2], g[N][2][2][2];
bool vis[N];
int dfn[N], dfntt, ring[N], rtt, n;

void findring(int u, int fa){
    if(vis[u]){
        int beg = 0;
        for(int i=1;i<=dfntt;i++){
            if(dfn[i] == u){
                beg = i;
                break;
            }
            else vis[i] = 0;
        }
        for(int i=beg;i<=dfntt;i++) ring[++rtt] = dfn[i];
        return;
    }
    if(rtt) return;
    vis[u] = 1; dfn[++dfntt] = u;
    for(int v : t[u]){
        if(v == fa) continue;
        findring(v, u);
        if(rtt) return;
    }
    vis[u] = 0; dfntt--;
}

void dp(int u, int fa){
    if(t[u].size() == (fa ? 1 : 0)){
        //cout << "LEAF " << u << '\n';
        f[u][0][0] = INT_MAX;
        f[u][0][1] = 0;
        f[u][1][0] = INT_MAX;
        f[u][1][1] = 1;
        return;
    }
    f[u][1][1] = f[u][1][0] = 1;
    vector<int> dt1, dt2;
    for(int v : t[u]){
        if(v == fa) continue;
        dp(v, u);
        f[u][0][1] += f[v][0][0];
        f[u][1][1] += f[v][0][1];
        f[u][0][0] += f[v][0][0];
        f[u][1][0] += f[v][0][1];
        dt1.push_back(f[v][1][0] - f[v][0][0]);
        dt2.push_back(f[v][1][1] - f[v][0][1]);
    }
    f[u][0][0] += (*min_element(dt1.begin(), dt1.end()));
    f[u][1][0] += (*min_element(dt2.begin(), dt2.end()));
    // 怕溢出，就喝取min宝！
    f[u][0][1] = min(f[u][0][1], (long long)INT_MAX);
    f[u][1][1] = min(f[u][1][1], (long long)INT_MAX);
    f[u][0][0] = min(f[u][0][0], (long long)INT_MAX);
    f[u][1][0] = min(f[u][1][0], (long long)INT_MAX);
}

void standard(){
    for(int id=2;id<=rtt;id++){
        int i = ring[id], j = ring[id - 1];
        g[i][0][0][0] = min(g[j][0][0][1], g[j][0][1][0]) + f[i][0][1];
        g[i][0][0][1] = min(g[j][0][0][1], g[j][0][1][0]) + f[i][0][0];
        g[i][0][1][0] = min(g[j][1][1][0], g[j][1][0][1]) + f[i][0][1];
        g[i][0][1][1] = INT_MAX;
        g[i][1][0][0] = g[j][0][0][0] + f[i][1][1];
        g[i][1][0][1] = g[j][0][0][0] + f[i][1][0];
        g[i][1][1][0] = g[j][1][0][0] + f[i][1][1];
        g[i][1][1][1] = INT_MAX;
        for(int s=0;s<2;s++){// 怕溢出，就喝取min宝！
            for(int t=0;t<2;t++){
                for(int k=0;k<2;k++) g[i][s][t][k] = min(g[i][s][t][k], (long long)(INT_MAX));
            }
        }
    }
}

void init(){
    for(int i=0;i<2;i++){
        for(int j=0;j<2;j++){
            for(int k=0;k<2;k++) g[ring[1]][i][j][k] = INT_MAX;
        }
    }
}

int nn(){
    init();
    g[ring[1]][0][0][0] = f[ring[1]][0][1];
    g[ring[1]][0][0][1] = f[ring[1]][0][0];
    standard();
    int i = ring[rtt];
    return min(g[i][0][1][0], g[i][0][0][1]);
}

int ny(){
    init();
    g[ring[1]][0][1][0] = f[ring[1]][0][1];
    standard();
    int i = ring[rtt];
    return min(g[i][1][1][0], g[i][1][0][1]);
}

int yn(){
    init();
    g[ring[1]][1][0][0] = f[ring[1]][1][1];
    g[ring[1]][1][0][1] = f[ring[1]][1][0];
    standard();
    int i = ring[rtt];
    return g[i][0][0][0];
}

int yy(){
    init();
    g[ring[1]][1][1][0] = f[ring[1]][1][1];
    standard();
    int i = ring[rtt];
    return g[i][1][0][0];
}

signed main(){
    #ifdef LOCAL
    freopen("infer.in", "r", stdin);
    freopen("infer.out", "w", stdout);
    #endif
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n;
    for(int i=1,u,v;i<=n;i++){
        cin >> u >> v;
        t[u].push_back(v); t[v].push_back(u);
    }
    findring(1, 0);
    for(int i=1;i<=n;i++) vis[i] = 0;
    for(int i=1;i<=rtt;i++) vis[ring[i]] = 1;
    for(int i=1;i<=rtt;i++){
        vector<int> tmp;
        for(int j : t[ring[i]]){
            if(!vis[j]) tmp.push_back(j);
        }
        t[ring[i]].clear();
        for(int j : tmp){
            t[ring[i]].push_back(j);
        }
    }
    for(int i=1;i<=n;i++){
        if(vis[i]) dp(i, 0);
    }
    int ans = min({nn(), ny(), yy(), yn()});
    if(ans > n) cout << -1;
    else cout << ans;
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：PCCP (赞：0)

## 题意

给定一个 $ n $ 个点的基环树，现在对基环树上的点染色，使得每个点都有且仅有一个与他相连的点（不包括它自身）被染色，求最少的染色点数，或者返回无解。

## 做法

其实基环树 DP 就是树形 DP，只是需要额外考虑环上断边两个端点的情况。

对于普通的树来说，DP 式子并不难推，我们可以设 DP 数组为 $ f_{x,a,b} $；其中 $ a,b \in \{ 0,1 \} $。

则有以下转移式：

$$ f_{x,0,0}=\displaystyle\sum_{v \in son_x}{f_{v,0,1}} $$

$$ f_{x,0,1}=\displaystyle\min_{y \in son_x}(f_{v,1,1} + \displaystyle\sum_{v \in \complement_{son_x}{y}}{f_{v,0,1}}) $$

$$ f_{x,1,0}=1+\displaystyle\sum_{v \in son_x}{f_{v,0,0}} $$

$$ f_{x,1,1}=1+\displaystyle\min_{y \in son_x}(f_{v,1,0} + \displaystyle\sum_{v \in \complement_{son_x}{y}}{f_{v,0,0}}) $$

其中，$ f_{x,0/1,0/1} $ 代表 当前节点为 $ x $，当前节点**否/是**被染色，与当前节点相邻的点中**父亲/儿子**被染色的最小代价；$ son_{x} $ 表示 $ x $ 的子节点的集合。

那么把树上两点连边形成一个基环树又会多有哪些限制呢？对于这种我们一般选择增加状态或分类讨论，我这里选择分类讨论这些情况：

首先我们规定：把断开的边的两端点记为 $ pccp $ 与 $ zyh $，其中 $ pccp $ 是树的根。$ fa_x $ 表示 $ x $ 的父节点。

* 第一种情况：$ f_{pccp,0,0} $ 对应 $ f_{zyh,1,0/1} $，即根节点无色且父节点有色，即根节点的兄弟节点必须有色（因为根节点无父节点，对应为兄弟节点）。强制限定 $ f_{zyh,0,0}=f_{zyh,0,1}=inf $ 即可。

* 第二种情况：$ f_{pccp,0,1} $ 对应 $ f_{zyh,0,0/1} $，即根节点无色且子节点有色，即兄弟节点必须无色。强制限定 $ f_{zyh,1,0}=f_{zyh,1,1}=inf $ 即可。

* 第三种情况：$ f_{pccp,1,0} $ 对应 $ f_{zyh,1,2} $，诶，这里就有野生吴彦祖要问了，为什么会多出一个 $ f_{x,a,2} $ 状态来呢？那是因为这代表根节点有色且兄弟节点也有色；那兄弟节点的子节点和父节点都不能有颜色，并且兄弟节点的子节点和父节点都被兄弟节点控制，这个状态就是对应这种情况。这样方便转移，对于兄弟节点的父节点我们就不用再分类讨论了。$ f_{zyh,1,2}=\displaystyle \sum_{v \in son_{zyh}} {f_{v,0,0}} $，$ f_{fa_{zyh},0,1}=f_{zyh,1,2}+\displaystyle\sum_{v \in \complement_{son_{fa_{zyh}}}{zyh}}{f_{v,0,1}} $，并且有且只有 $ f_{zyh,1,2} $ 与 $ f_{fa_{zyh},0,1} $ 两个状态合法，其他赋极大值即可。

* 第四种情况：$ f_{pccp,1,1} $ 对应 $ f_{zyh,0,2} $，代表根节点有色，兄弟节点无色。兄弟节点的父节点只要无色即可，因此限制比第三种状态少。

注意：初始时 $ f_{x,1,1} $ 与 $ f_{x,0,1} $ 都需要赋极大值作为初值。数组需要开 long long 类型，菊花图会爆 int。每次做完 DP 要清空数组。

虽然分类讨论要做四次 DP，写四个函数，但是他们的底子是一样的，复制后改一下就好了，代码看着多，其实内涵没多少。

## 代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<set>
#include<queue>
#include<stack>
#include<vector>
using namespace std;
typedef pair<int,int> PII;
const int N=2e5+10;
const int INF=1e6+10;
int n,pccp,zyh,br;
int he[N],to[N<<1],ne[N<<1],tot=1;
int fat[N],dfo[N];
__int128 ans=1e18,f[N][2][3],cnt;
void addedge(int x,int y){
	to[++tot]=y;
	ne[tot]=he[x];
	he[x]=tot;
}
void get(int x,int f){ //找到要断的边
	dfo[x]=++cnt;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==f||i==br||i==(br^1)){
			continue;
		}
		if(dfo[v]&&!br){
			br=i;
		}
		get(v,x);
	}
}
//分别对应上面说的各种情况
void dp1(int x,int fa){
	f[x][1][1]=f[x][0][1]=INF;
	fat[x]=fa;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		dp1(v,x);
		f[x][1][0]+=f[v][0][0];
		f[x][0][0]+=f[v][0][1];
	}
	f[x][1][0]++;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		f[x][1][1]=min(f[x][1][1],f[x][1][0]-f[v][0][0]+f[v][1][0]);
		f[x][0][1]=min(f[x][0][1],f[x][0][0]-f[v][0][1]+f[v][1][1]);
	}
	if(x==zyh){
		f[x][0][0]=f[x][0][1]=INF;
	}
}
void dp2(int x){
	f[x][1][1]=f[x][0][1]=INF;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		dp2(v);
		f[x][0][0]+=f[v][0][1];
		f[x][1][0]+=f[v][0][0];
	}
	f[x][1][0]++;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		f[x][0][1]=min(f[x][0][1],f[x][0][0]-f[v][0][1]+f[v][1][1]);
		f[x][1][1]=min(f[x][1][1],f[x][1][0]-f[v][0][0]+f[v][1][0]);
	}
	if(x==zyh){
		f[x][1][0]=f[x][1][1]=INF;
	}
}
void dp3(int x){
	bool yet=false;
	f[x][1][1]=f[x][0][1]=INF;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		dp3(v);
		if(v==zyh){
			f[x][1][0]+=f[v][0][0];
			f[x][0][0]+=f[v][1][2];
			yet=true;
		}
		else{
			f[x][1][0]+=f[v][0][0];
			f[x][0][0]+=f[v][0][1];
		}
		f[x][1][2]+=f[v][0][0];
	}
	f[x][1][0]++;
	f[x][1][2]++;
	if(yet==true){
		f[x][0][1]=f[x][0][0];
		f[x][0][0]=f[x][1][0]=f[x][1][0]=INF;
		return;
	}
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		if(v==zyh){
			continue;
		}
		f[x][1][1]=min(f[x][1][1],f[x][1][0]-f[v][0][0]+f[v][1][0]);
		f[x][0][1]=min(f[x][0][1],f[x][0][0]-f[v][0][1]+f[v][1][1]);
	}
	if(x==zyh){
		f[x][1][1]=f[x][0][0]=f[x][0][1]=f[x][1][0]=INF;
	}
}
void dp4(int x){
	f[x][1][1]=f[x][0][1]=INF;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		dp4(v);
		if(v==zyh){
			f[x][0][0]+=f[v][0][2];
			f[x][1][0]+=f[v][0][0];
		}
		else{
			f[x][1][0]+=f[v][0][0];
			f[x][0][0]+=f[v][0][1];
		}
		f[x][0][2]+=f[v][0][1];
	}
	f[x][1][0]++;
	for(int i=he[x];i;i=ne[i]){
		int v=to[i];
		if(v==fat[x]||i==br||i==(br^1)){
			continue;
		}
		if(v==zyh){
			continue;
		}
		f[x][1][1]=min(f[x][1][1],f[x][1][0]-f[v][0][0]+f[v][1][0]);
		f[x][0][1]=min(f[x][0][1],f[x][0][0]-f[v][0][1]+f[v][1][1]);
	}
	if(x==zyh){ 
		f[x][1][0]=f[x][1][1]=f[x][0][1]=f[x][0][0]=INF;
	}
}
int main(){
	scanf("%d",&n);
	int x,y;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&y);
		addedge(x,y);
		addedge(y,x);
	}
	get(1,0);
	pccp=to[br],zyh=to[br^1];
	dp1(pccp,0);
	ans=f[pccp][0][0];
	memset(f,0,sizeof f);
	dp2(pccp);
	ans=min(ans,f[pccp][0][1]);
	memset(f,0,sizeof f);
	dp3(pccp);
	ans=min(ans,f[pccp][1][0]);
	memset(f,0,sizeof f);
	dp4(pccp);
	ans=min(ans,f[pccp][1][1]);
	memset(f,0,sizeof f);
	long long res=ans;
	if(ans>=INF){
		printf("-1\n");
	}
	else{
		printf("%lld\n",res);
	}
}
//love zyh
```

---

## 作者：cirnovsky (赞：0)

断环后把断的边所连的两个点特殊标记，作为两个特殊点。这样就是一个树，树的做法很简单吧，把两个特殊点特殊处理带进状态即可。

具体一点就是，设 $f(x,c_x,c_f,c_{rt_1},c_{rt_2})$ 表示处理到 $x$ 点，$x$ / $x$ 的前驱 / 特殊点 1 / 特殊点 2 是否染色，转移很基础，具体看代码（代码中写的是状压）。

注意判无解……

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define cmin(x, y) x = min(x, y)
#define cmax(x, y) x = max(x, y)
template<typename T=int> inline T read() {
	T x=0; char c=getchar(); bool f=0;
	while(c<'0' || c>'9')	f|=c=='-',c=getchar();
	while(c>='0' && c<='9')	x=x*10+(c&15),c=getchar();
	return f?-x:x;
}
__attribute__((target("avx"), optimize("O3", "unroll-loops")))
const int INF=1e9+7;
int n,fa[100100],rt,exrt,dp[100100][17];
vector<int> e[100100];
int makeSta(vector<int> v) {
	int res=0; assert(v.size()==4u);
	for(int i=0; i<4; ++i) {
		res+=(1<<(3-i))*v[i];
		assert(0<=v[i] && v[i]<=1);
	}
	return res;
}
int GetAns(const int now,const int f,const int Sta) {
	// Sta: colnow(3), colf(2), colrt(1), colexrt(0)
	if(~dp[now][Sta])	return dp[now][Sta];
	if((now==rt && ((Sta>>3)&1)!=((Sta>>1)&1))
		|| (now==exrt && (((Sta>>3)&1)!=(Sta&1))) || (now==exrt && (Sta>>2)&1 && (Sta>>1)&1))	return dp[now][Sta]=INF;
	int cnt=(Sta>>3)&1,res=INF; // number of vertexes coloured
	for(const int y:e[now])	if(y!=f)	cnt+=GetAns(y,now,makeSta({0,(Sta>>3)&1,(Sta>>1)&1,Sta&1}));
	if((Sta>>2)&1 || (now==rt && Sta&1) || (now==exrt && (Sta>>1)&1))	cmin(res,cnt);
	else {
		for(const int y:e[now])	if(y!=f)	cmin(res,cnt-GetAns(y,now,makeSta({0,(Sta>>3)&1,(Sta>>1)&1,Sta&1}))
			+GetAns(y,now,makeSta({1,(Sta>>3)&1,(Sta>>1)&1,Sta&1})));
	}
	return dp[now][Sta]=res;
}
int find(int now) { while(now!=fa[now])	now=fa[now]=fa[fa[now]]; return now; }
signed main() {
	// freopen("logicians.in","r",stdin);
	// freopen("logicians.out","w",stdout);
	memset(dp,-1,sizeof dp);
	n=read();
	for(int i=1; i<=n; ++i)	fa[i]=i;
	for(int i=1,x,y; i<=n; ++i) {
		x=read(),y=read();
		if(find(x)!=find(y)) {
			fa[find(x)]=find(y);
			e[x].push_back(y);
			e[y].push_back(x);
		}
		else	rt=x,exrt=y;
	}
	int ret=INF;
	for(const int i:{0,1})	for(const int j:{0,1})	cmin(ret,GetAns(rt,0,makeSta({i,0,i,j})));
	if(ret==INF)	return puts("-1"),0;
	printf("%lld\n",ret);
	return 0;
}

```

---


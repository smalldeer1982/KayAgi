# [COCI 2021/2022 #1] Set

## 题目背景

在知名游戏 SET 中，存在着一些数字、形状、颜色等不同的卡片，玩家的目标是确定一个存在的 triplet of cards（即卡片的三元组，也就是三张卡片构成的组合），使其符合特定的要求。Marin 和 Josip 很快就对这个游戏感到无趣，并对其进行了加强。

## 题目描述

在本题中，定义每张卡片代表着一个仅由 $ 1, 2, 3 $ 构成的长度为 $ k $ 的序列，共有 $ n $ 张卡片，卡片之间是无序的，保证卡片**两两不同**。

定义一个 SET 表示，当且仅当一个无序的 triplet of cards 其中的三个序列的每一位均相同或各不相同，用原文中的话就是 same 或 pairwise different，更严谨地表示，我们令这三个序列为 $ S_i, S_j, S_k $，则一定满足如下条件：

* $ i \lt j \lt k $
* $ \forall x \in \left[1, k\right] $，满足 $ S_i(x) = S_j(x) = S_k(x) $ 或 $ S_i(x) \neq S_j(x) \neq S_k(x) $

例如 $ (1123, 1322, 1221) $ 便满足 $ 1, 3 $ 位均相同，$ 2,4 $ 位各不相同。

给你这些序列，求可以组成多少种本质不同的 SET。

## 说明/提示

**【样例解释 \#3】**

可以组成的两个 SET 分别为 $ (S_1, S_2, S_3) $ 和  $ (S_1, S_4, S_5) $。

**【数据范围】**

对于全部数据，$1\le k\le 12$，$1\le n\le 3^k$，$S_i$ 互不相同，$1\le S_i(x) \le 3$。

| Subtask |  特殊限制  | 分数 |
| :-----: | :--------: | :--: |
|   $1$   |  $k\le 5$  | $10$ |
|   $2$   |  $k\le 7$  | $30$ |
|   $3$   | 无特殊限制 | $70$ |

#### 说明
**本题总分 $110$ 分。**

本题译自 [Croatian Open Competition in Informatics 2021/2022](https://hsin.hr/coci/archive/2021_2022) [Contest #1](https://hsin.hr/coci/archive/2021_2022/contest1_tasks.pdf) T4 Set。

## 样例 #1

### 输入

```
3 4
1123
1322
1221
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 2
11
22
```

### 输出

```
0
```

## 样例 #3

### 输入

```
5 3
111
222
333
123
132
```

### 输出

```
2
```

# 题解

## 作者：SAMSHAWCRAFT (赞：4)

这里给一个三进制快速沃尔什变换的做法，可能做得比较麻烦。

本题题意比较抽象，我们需要从题目信息中寻找一些三元组的性质。这里有一个性质可供使用：对于同一位上的三个数字 $b_{i,z},b_{j,z},b_{k,z}$，其所有合法的组合对应的数字加起来都是 3 的倍数，即 $(b_{i,z}+b_{j,z}+b_{k,z})\operatorname{mod} 3=0$。
我们发现如果把题目中的 1,2,3 看作 0,1,2 的话，这个性质不会改变，而它同时又被赋予了三进制异或的性质。所谓 k 进制异或其实就是按位相加（不进位）并按位对 k 取模。

考虑到本质不同三元组个数为 $3^m$，设 $c_i$ 表示 $i$ 三进制下是否有对应的 $m$ 元组，如果有值为 1，否则为 0。题中要的是 $(b_{i,z}+b_{j,z}+b_{k,z})\operatorname{mod} 3=0$，其实就是 $(b_{i,z}\oplus_3 b_{j,z} \oplus_3 b_{k,z})=0$，这里的 $\oplus_k$ 表示 k 进制异或。我们发现这个和 FWT 的过程十分相似，即求：

$$F_r=\sum_{i\oplus_3  j \oplus_3  k=r}c_ic_jc_k$$


我们在本题中只需要对 $c$ 做三次 FWT，取出常数项 $F_0$ 即可得到答案 $\frac {F_0-n}{6}$。取出常数项的理由很简单，我们要的 $F_0$ 其实就是
$$F_0=\sum_{i\oplus_3  j \oplus_3  k=0}c_ic_jc_k$$
关于减 $n$ 除以 6 的问题，其实是去掉重复选取的三元组（题中要的是本质不同三元组）。减 $n$ 是因为任意整数在三进制异或自己三次之后都为零，一共 $n$ 个三元组，所以要减去这 $n$ 个三元组自己三进制异或三次之后的贡献。除以 6 是因为 3 个整数调换顺序进行三进制取模不影响异或结果，而 3 个数字有 6 种不同的排列方法，我们要的本质不同三元组和顺序无关，也就是说这 6 种情况本质是一种选法，要除以 6。

关于 k 进制 FWT，这个知识和 FFT 以及二进制 FWT 很相似，我在这里放一个 k 进制 FWT 的转移矩阵，大家可以参考这个矩阵实现任意进制 FWT。

**FWT and**

转移矩阵：
$$A=\begin{bmatrix}
1 & 1 & 1 & \cdots & 1 \\
0 & 1 & 1 & \cdots & 1 \\
0 & 0 & 1 & \cdots & 1 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & 0 & \cdots & 1
\end{bmatrix}$$
FWT and 相当于做后缀和，逆运算是差分。

**FWT or**

转移矩阵：
$$A=\begin{bmatrix}
1 & 0 & 0 & \cdots & 0 \\
1 & 1 & 0 & \cdots & 0 \\
1 & 1 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & 1 & 1 & \cdots & 1
\end{bmatrix}$$
FWT or 相当于做前缀和，逆运算是差分。

**FWT xor**

转移矩阵：
$$A=\begin{bmatrix}
1 &1 & 1 & \cdots & 1 \\
1 & \omega_n & \omega_n^2 & \cdots & \omega_n^{n-1} \\
1 & \omega_{n}^2 & \omega_n^{4} & \cdots & \omega_n^{2(n-1)} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \omega_n^{n-1} & \omega_n^{2(n-1)} & \cdots & \omega_n^{(n-1)(n-1)}
\end{bmatrix}$$
其中 $\omega$ 是单位复根，单位复根的概念可以参考 FFT 中的概念。

逆转移矩阵：
$$A^{-1}=\frac 1 n \begin{bmatrix}
1 &1 & 1 & \cdots & 1 \\
1 & \omega_{n}^{-1} & \omega_n^{-2} & \cdots & \omega_n^{-(n-1)} \\
1 & \omega_{n}^{-2} & \omega_n^{-4} & \cdots & \omega_n^{-2(n-1)} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \omega_n^{-(n-1)} & \omega_n^{-2(n-1)} & \cdots & \omega_n^{-(n-1)(n-1)}
\end{bmatrix}$$

本题做的三进制 FWT 中，$\omega=-\frac 1 2+ \frac {\sqrt 3i} 2$，$\omega^2=-\frac 1 2-\frac {\sqrt 3 i} 2$，转移矩阵就和逆转移矩阵分别是：
$$A=\begin{bmatrix}
1 & 1 & 1 \\
1 & \omega & \omega^2 \\
1 & \omega^2 & \omega 
\end{bmatrix},
A^{-1}=\frac 1 3\begin{bmatrix}
1 & 1 & 1 \\
1 & \omega^{-1} & \omega^{-2} \\
1 & \omega^{-2} & \omega^{-1} 
\end{bmatrix}=
\frac 1 3
\begin{bmatrix}
1 & 1 & 1 \\
1 & \omega^{2} & \omega^{} \\
1 & \omega^{} & \omega^{2} 
\end{bmatrix}$$

我们在 IFWT 的过程中，每一层是需要对点值多项式每一项除以 3 的。当然，由于 IFWT 一共 $\log_3 n$ 层，每层都要除以 3，所以也可以写成最后都除以 $n$，不必在过程中做除法，下面给个三进制 FWT xor 的参考代码。


每次都除以 3 的写法：
``` cpp
void FWT3XOR(int limit,complex *arr,int sign){
    for(int l=1;l<limit;l*=3){
        for(int cx=0;cx<limit;cx+=3*l){
            for(int cy=0;cy<l;++cy){
                complex tmp0=arr[cx+cy+l*0];
                complex tmp1=arr[cx+cy+l*1];
                complex tmp2=arr[cx+cy+l*2];
                if(sign==1){
                    arr[cx+cy+l*0]=tmp0+tmp1+tmp2;
                    arr[cx+cy+l*1]=tmp0+tmp1*w+tmp2*w2;
                    arr[cx+cy+l*2]=tmp0+tmp1*w2+tmp2*w;
                }else{
                    arr[cx+cy+l*0]=(tmp0+tmp1+tmp2)/3;
                    arr[cx+cy+l*1]=(tmp0+tmp1*w2+tmp2*w)/3;
                    arr[cx+cy+l*2]=(tmp0+tmp1*w+tmp2*w2)/3;
                }
            }
        }
    }
}
```
最后除以 $n$ 的写法：
``` cpp
void FWT3XOR(int limit,complex *arr,int sign){
    for(int l=1;l<limit;l*=3){
        for(int cx=0;cx<limit;cx+=3*l){
            for(int cy=0;cy<l;++cy){
                complex tmp0=arr[cx+cy+l*0];
                complex tmp1=arr[cx+cy+l*1];
                complex tmp2=arr[cx+cy+l*2];
                if(sign==1){
                    arr[cx+cy+l*0]=tmp0+tmp1+tmp2;
                    arr[cx+cy+l*1]=tmp0+tmp1*w+tmp2*w2;
                    arr[cx+cy+l*2]=tmp0+tmp1*w2+tmp2*w;
                }else{
                    arr[cx+cy+l*0]=(tmp0+tmp1+tmp2);
                    arr[cx+cy+l*1]=(tmp0+tmp1*w2+tmp2*w);
                    arr[cx+cy+l*2]=(tmp0+tmp1*w+tmp2*w2);
                }
            }
        }
    }
    if(sign==-1){
        for(int cx=0;cx<limit;++cx)
            arr[cx]=arr[cx]/limit;
    }
}
```
两种写法等价，但后者应该更快（做除法次数少）。

本题完整代码如下，仅供参考。
``` cpp
#include <stdio.h>
#include <ctype.h>
#include <cmath>
#include <algorithm>
#include <numeric>
#define qaq inline
const int sz=1e6+19;
using ll=long long;
int n,k,tup[sz];
ll ans=0;
struct complex{
    long double real,imag;
    complex()=default;
    complex(long double a,long double b){
        real=a,imag=b;
    }
    qaq friend complex operator+(complex a,complex b){
        return complex(a.real+b.real,a.imag+b.imag);
    }
    qaq friend complex operator-(complex a,complex b){
        return complex(a.real-b.real,a.imag-b.imag);
    }
    qaq friend complex operator*(complex a,complex b){
        complex res;
        res.real=a.real*b.real-a.imag*b.imag;
        res.imag=a.real*b.imag+a.imag*b.real;
        return res;
    }
    qaq friend complex operator*(complex a,long double b){
        return complex(a.real*b,a.imag*b);
    }
    qaq friend complex operator/(complex a,long double b){
        return complex(a.real/b,a.imag/b);
    }
}pl[sz];
const complex w=complex(-0.5,0.5*std::sqrt(3));
const complex w2=complex(-0.5,-0.5*std::sqrt(3));
void FWT3XOR(int limit,complex *arr,int sign){
    for(int l=1;l<limit;l*=3){
        for(int cx=0;cx<limit;cx+=3*l){
            for(int cy=0;cy<l;++cy){
                complex tmp0=arr[cx+cy+l*0];
                complex tmp1=arr[cx+cy+l*1];
                complex tmp2=arr[cx+cy+l*2];
                if(sign==1){
                    arr[cx+cy+l*0]=tmp0+tmp1+tmp2;
                    arr[cx+cy+l*1]=tmp0+tmp1*w+tmp2*w2;
                    arr[cx+cy+l*2]=tmp0+tmp1*w2+tmp2*w;
                }else{
                    arr[cx+cy+l*0]=(tmp0+tmp1+tmp2)/3;
                    arr[cx+cy+l*1]=(tmp0+tmp1*w2+tmp2*w)/3;
                    arr[cx+cy+l*2]=(tmp0+tmp1*w+tmp2*w2)/3;
                }
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&k);
    for(int cx=0,u;cx<n;++cx){
        u=0;
        char ch=getchar();
        while(!isdigit(ch)) ch=getchar();
        while(isdigit(ch)) u=u*3+ch-'1',ch=getchar();
        tup[u]++,pl[u]=complex(1,0);
    }
    int lim,limbit3;
    for(lim=1,limbit3=0;limbit3<k;lim*=3,++limbit3);
    FWT3XOR(lim,pl,1);
    for(int cx=0;cx<lim;++cx)
        pl[cx]=pl[cx]*pl[cx]*pl[cx];
    FWT3XOR(lim,pl,-1);
    ans=pl[0].real+0.5;
    printf("%lld\n",(ans-n)/6);
    return 0;
}

```

---

## 作者：Glacial_Shine (赞：1)

# 思路

我们将原题中的数的每一位减一，此时问题等价。

下面的异或都是在三进制下的异或。（相当于不进位的加法）

我们考虑原题中的条件，对于每一位，如果相同，则异或值为 $0$，如果为 $1$， $2$， $3$ 的排列，则异或值也为 $0$。

于是我们设 $C_k$ 表示有没有 $k$ 这个数，$ans=\sum_{i\oplus j\oplus k = 0} c_i\cdot c_j\cdot c_k$，则答案为 $\frac{ans - n}{6}$。

其中 $ans$ 可以用 FWT 求，具体实现可以看我的[博客](https://blog.csdn.net/weixin_46700592/article/details/133715261?spm=1001.2014.3001.5502)。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
int n, k, len = 1;
LL ans;
complex <double> a[1000005];
const complex <double> w = {-0.5, 0.5 * sqrt(3)}, w2 = {-0.5, -0.5 * sqrt(3)};
int in() {
    char ch = getchar();
    int s = 0;
    while (ch < '0' || ch > '9')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        s = s * 3 + ch - '1', ch = getchar();
    return s;
}
void FWT(complex <double> *f, int flag) {
    for (int mid = 1; mid < len; mid = mid * 3) {
        for (int i = 0; i < len; i = i + mid * 3) {
            for (int j = i; j < i + mid; j++) {
                complex <double> t0 = f[j], t1 = f[j + mid], t2 = f[j + mid * 2];
                if (flag == 1) {
                    f[j] = t0 + t1 + t2;
                    f[j + mid] = t0 + t1 * w + t2 * w2;
                    f[j + mid * 2] = t0 + t1 * w2 + t2 * w;
                }
                else {
                    f[j] = t0 + t1 + t2;
                    f[j + mid] = t0 + t1 * w2 + t2 * w;
                    f[j + mid * 2] = t0 + t1 * w + t2 * w2;
                    double t;
                    t = f[j].real(), f[j].real(t / 3);
                    t = f[j + mid].real(), f[j + mid].real(t / 3);
                    t = f[j + mid * 2].real(), f[j + mid * 2].real(t / 3);
                    t = f[j].imag(), f[j].imag(t / 3);
                    t = f[j + mid].imag(), f[j + mid].imag(t / 3);
                    t = f[j + mid * 2].imag(), f[j + mid * 2].imag(t / 3);
                }
            }
        }
    }
}
int main() {
    scanf("%d%d", &n, &k);
    for (int t = 0; t < k; t++)
        len = len * 3;
    for (int i = 0; i < n; i++)
        a[in()].real(1);
    FWT(a, 1);
    for (int i = 0; i < len; i++)
        a[i] = a[i] * a[i] * a[i];
    FWT(a, -1);
    ans = a[0].real() + 0.5;
    printf("%lld\n", (ans - n) / 6);
    return 0;
}
```



---

## 作者：Tsawke (赞：0)

# COCI2021-2022 Contest1 T4 题解

[TOC]

## [更好的阅读体验戳此进入](http://blog.monkey-hyx.tech?t=COCI-2021-2022-Contest1)

（建议您从上方链接进入我的个人网站查看此 Blog，在 Luogu 中图片会被墙掉，部分 Markdown 也会失效）

## [原题面链接](https://hsin.hr/coci/contest1_tasks.pdf)

## [Luogu题面](https://www.luogu.com.cn/problem/list?keyword=COCI2021-2022%231&page=1)

## T4 Set

>## 题目背景
>
>在知名游戏 $ \texttt{SET} $ 中，存在着一些数字、形状、颜色等不同的卡片，玩家的目标是确定一个存在的 $ \texttt{triplet of cards} $（即卡片的三元组，也就是三张卡片构成的组合），使其符合特定的要求。 $ \texttt{Marin} $ 和 $ \texttt{Josip} $ 很快就对这个游戏感到无趣，并对其进行了加强。
>
>## 题目描述
>
>在本题中，定义每张卡片代表着一个仅由 $ 1, 2, 3 $ 构成的长度为 $ k $ 的序列，共有 $ n $ 张卡片，卡片之间是无序的。
>
>定义一个 $ \texttt{SET} $ 表示，当且仅当一个无序的 $ \texttt{triplet of cards} $ 其中的三个序列的每一位均相同或各不相同，用原文中的话就是 $ \texttt{same} $ 或 $ \texttt{pairwise different} $，更严谨地表示，我们令这三个序列为 $ S_i, S_j, S_k $，则一定满足如下条件：
>
>* $ i \lt j \lt k $
>* $ \forall x \in \left[1, k\right] $，满足 $ S_i(x) = S_j(x) = S_k(x) $ 或 $ S_i(x) \neq S_j(x) \neq S_k(x) $
>
>例如 $ (1123, 1322, 1221) $ 便满足 $ 1, 3 $ 位均相同，$ 2,4 $ 位各不相同。
>
>给你这些序列，求可以组成多少种本质不同的 $ \texttt{SET} $。
>
>## 输入格式
>
>第一行为两个整数正整数 $ n, k $。
>
>接下来 $ n $ 行中每一行包含一个仅由 $ 1, 2, 3 $ 构成的长度为 $ k $ 的序列，代表着一张卡片。
>
>保证每张卡片上的序列不同。
>
>## 输出格式
>
>仅一行一个整数，表示可以组成的本质不同的 $ \texttt{SET} $ 的数量。
>
>## 说明 / 提示
>
>### 样例 3 解释
>
>可以组成的两个 $ \texttt{SET} $ 分别为 $ (S_1, S_2, S_3) $ 和  $ (S_1, S_4, S_5) $。
>
>### 数据范围
>
>对于全部数据，满足 $ 1 \le k \le 12, 1 \le n \le 3^k $，$ S_i $ 互不相同且满足 $ 1 \le S_i \le 3 $。
>
>| Subtask |  特殊限制   | 分数 |
>| :-----: | :---------: | :--: |
>|    1    | $ k \le 5 $ |  10  |
>|    2    | $ k \le 7 $ |  30  |
>|    3    | 无特殊限制  |  70  |
>
>

#### 题面（重新翻译了一个新的题面，已经提交到 Luogu）

#### Solution

需要用到很多 $ \texttt{FWT} $ 思想，阅读之前请先完全理解 $ \texttt{FWT} $，$ k $ 进制 $ \texttt{FWT} $，及用转移矩阵进行变换的 $ \texttt{FWT} $。

**[戳此链接去看刚写完的 FWT](http://blog.monkey-hyx.tech?t=FWT)**

观察题意，发现对于每个 $ \texttt{SET} $ 的同一位置的三个数，要么是完全相同的三个数，要么分别是 $ 1, 2, 3 (\texttt{unordered}) $。

思考这个规律有什么性质

##### 性质1

显然设这三个数为 $ m_{i, x}, m_{j, x}, m_{k, x} $ 一定有：
$$
m_{i, x} + m_{j, x} + m_{k, x} \equiv 0 \quad (\bmod{3})
$$
证明：~~这么显然还需要证明吗~~。

##### 性质2

当这个 $ \texttt{SET} $ 中的两个序列被确定之后，第三个序列就有且仅有一种情况，或者说 $ \texttt{uniquely determined} $。

证明：一共就三个可能的数，这个也很显然吧



然后我们发现这两个性质无法继续向下推，于是我们考虑假设存在一个自洽的代数系统 $ S $，其中只有 $ 1, 2, 3 $ 三个数字，定义 $ S $ 中一种二元运算 $ \circ $，为了令其符合结合律，我们考虑使其符合以下规律及交换律：

$$
\begin{aligned}
	&1 \circ 1 = 1\\
	&2 \circ 2 = 3\\
	&3 \circ 3 = 2\\
	&1 \circ 2 = 2\\
	&1 \circ 3 = 3\\
	&2 \circ 3 = 1
\end{aligned}
$$
同时我们考虑定义一元运算符 $ \bmod{3} $，其运算规律与代数系统 $ (\mathbb{N}, \bmod{3}) $，即自然数和 $ \bmod{3} $ 构成的代数系统相同，详细地表示即为：
$$
\begin{aligned}
	&1 \bmod{3} = 1\\
	&2 \bmod{3} = 2\\
	&3 \bmod{3} = 0
\end{aligned}
$$
此时我们会发现更多的性质：

##### 性质3

一个数与其自身进行两次 $ \circ $ 运算后数值不改变。即：
$$
a \circ a \circ a = a
$$
证明：根据 $ \circ $ 的定义可知十分显然。

##### 性质4

运算 $ \circ $ 的交换律与结合律。

证明：显然成立。

##### 性质5

对于性质1，由新的定义可以转化为如下式子：
$$
(m_{i, x} \circ m_{j, x} \circ m_{k, x}) \bmod{3} = 1
$$
也就是：
$$
m_{i, x} \circ m_{j, x} \circ m_{k, x} = 1
$$
此时根据这些性质，如果我们令 $ F(x) $ 表示题意中有多少种不同的 $ \texttt{triplet} $ 符合对于 $ \forall x \in \left[ 1, m \right] $ 都有：
$$
m_{i, x} \circ m_{j, x} \circ m_{k, x} = x
$$
则显然 $ F(0) $ 表示所有不同的 $ \texttt{SET} $ 的数量。

（注意这里并不是本质不同，所以也可以理解为 $ \texttt{triplet} $ 中三个序列的排列）

这里我们定义序列 $ g_n $，有：
$$
g_i = \left\{
	\begin{array}{ll}
	0 &\quad unexist \\
	1  &\quad exist
	\end{array}
\right.
$$
需要注意下标 $ i $ 表示的不是一个数字，而是一个序列，由数据范围可以考虑按位存取，最简单的想法是类似离散化，把它按三进制，压成一个数，也可以考虑用两位二进制存这个数。

存在与否指的是是否在题目给出的 $ n $ 个序列中。

容易看出会有如下式子：
$$
F(x) = \sum_{i \circ j \circ k = x}g_i \times g_j \times g_k
$$

当然这个式子也可以记作：
$$
F = g \times g \times g
$$


而我们需要的便是这个式子的常数项 $ F(1) $，注意这里因为我们的代数系统中不存在 $ 0 $，但如果我们用三进制离散化压位来存的话，最终需要的就是 $ F(0) $，即：
$$
F(0) = \sum_{i \circ j \circ k = 0}g_i \times g_j \times g_k
$$
仔细观察一般的式子，这像什么？显然是多项式的各种快速变换！或者进一步说，很像 $ \texttt{FWT} $。

> FWT（快速沃尔什变换）一般用于处理形如如下式子的卷积：
> $$
> C(x) = \sum_{i \circ j = x}A(i) \times B(j)
> $$
> 此处的 $ \circ $ 一般为 \&, |, ^， 也就是 $ and, or, xor $。 

发现我们当前的式子很像 $ \texttt{FWT} $，所以也可以以 $ \texttt{FWT} $ 的思想去考虑本题。

##### FWT 的思路

与大多数多项式快速变换的思路一样，我们的目的都是找到一种变换，对于 $ \texttt{FWT} $ 可以考虑记作：
$$
FWT(A)
$$
我们需要让这个变换满足以下性质：
$$
FWT(A) \ast FWT(B) = FWT(C)
$$
且：
$$
A \circ B = C
$$
对于不同的运算都有着与之对应的不同的变换方式，我们的目的就是要找到一种优秀的变换并快速地进行变换。

> 这里额外说一下对于多项式约定俗成的几种运算表示什么，相信你们一定都知道~~（主要因为我最开始做这道题的时候有的符号理解错了）~~
>
> 这里我们假设 $ A $ 最高次为 $ N $ 次，$ B $ 最高次为 $ M $ 次。
>
> 令 $ \max(N, M) = P $。 
> $$
> \begin{aligned}
> &(A, B) = (A(0), A(1), \cdots, A(N), B(0), B(1), \cdots, B(M) ) \texttt{即拼接两个多项式} \\
> &A + B = (A(0) + B(0), A(1) + B(1), \cdots, A(P) + B(P) ) \texttt{即按位相加} \\
> &A - B = (A(0) - B(0), A(1) - B(1), \cdots, A(P) - B(P) ) \texttt{即按位相减} \\
> &A \ast B = (A(0) \ast B(0), A(1) \ast B(1), \cdots, A(P) \ast B(P) ) \texttt{即按位相乘，注意不是卷积} \\
> &A \times B = (\sum_{i + j = 0}A(i) \times B(j), \sum_{i + j = 1}A(i) \times B(j), \cdots, \sum_{i + j = N + M}A(i) \times B(j) ) \texttt{多项式卷积} \\
> &A \circ B = (\sum_{i \circ j = 0}A(i) \times B(j), \sum_{i \circ j = 1}A(i) \times B(j), \cdots ) \texttt{可以理解为广义上的卷积}
> \end{aligned}
> $$

##### 本题如何做？

通过上面的信息显然我们便可确定本题的核心：找出在代数系统 $ S $ 中运算 $ \circ $ 的卷积运算时的广义上的 $ \texttt{FWT} $ 变换。

从哪入手呢？观察对于常用的三个运算的 $ \texttt{FWT} $ 变换式子，我们就会发现这些式子的存在本身就充满着人类智慧，似乎不像是可以很简单推导出来的，但是如果我们从矩阵的角度去考虑，并基于已有的运算的转移矩阵，就可以较为方便的得出结论。

##### 如何推式子？

再次观察我们定义的这个二元运算符 $ \circ $：
$$
\begin{aligned}
	&1 \circ 1 = 1\\
	&2 \circ 2 = 3\\
	&3 \circ 3 = 2\\
	&1 \circ 2 = 2\\
	&1 \circ 3 = 3\\
	&2 \circ 3 = 1
\end{aligned}
$$
>  题外话：写到这里突然发现我好像推不出来这个式子，于是决定先去把 $ \texttt{FWT} $ 的坑填了...

我们要求的可以理解为是以下的式子：
$$
C(x) = \sum_{i \circ j = x}A(i) \times B(j)
$$
用和 $ \texttt{FWT} $ 一样的思想，因为我们只有三个数，所以可以考虑构造一个 $ 3 \times 3 $ 的转移矩阵，但是注意我们定义的运算 $ \circ $ 下标从 $ 1 $ 开始，所以与标准的矩阵可能有些差距。

我们需要保证对于转移矩阵 $ T $ 的 $ (i, j) $ 元，记作 $ \omega(i, j) $，满足：
$$
\omega(x, i) \times \omega(x, j) = \omega(x, k) \quad (i \circ j = k)
$$
观察运算的性质，和三进制下的异或运算性质较为相似，可以考虑尝试范德蒙德矩阵：
$$
\begin{bmatrix}
\neg\exists & \neg\exists & \neg\exists & \neg\exists &  \\
\neg\exists & 1 & 1 & 1 \\
\neg\exists & 1 & \omega_3^1 & \omega_3^2 \\
\neg\exists & 1 & \omega_3^2 & \omega_3^4 \\
\end{bmatrix}
$$
可以化简为：
$$
\begin{bmatrix}
\neg\exists & \neg\exists & \neg\exists & \neg\exists &  \\
\neg\exists & 1 & 1 & 1 \\
\neg\exists & 1 & \omega_3 & \omega_3^2 \\
\neg\exists & 1 & \omega_3^2 & \omega_3 \\
\end{bmatrix}
$$
逆矩阵同理容易得出为：
$$
\dfrac{1}{3} \begin{bmatrix}
\neg\exists & \neg\exists & \neg\exists & \neg\exists &  \\
\neg\exists & 1 & 1 & 1 \\
\neg\exists & 1 & \omega_3^{-1} & \omega_3^{-2} \\
\neg\exists & 1 & \omega_3^{-2} & \omega_3^{-1} \\
\end{bmatrix}
$$
可以化简为：
$$
\dfrac{1}{3} \begin{bmatrix}
\neg\exists & \neg\exists & \neg\exists & \neg\exists &  \\
\neg\exists & 1 & 1 & 1 \\
\neg\exists & 1 & \omega_3^2 & \omega_3 \\
\neg\exists & 1 & \omega_3 & \omega_3^2 \\
\end{bmatrix}
$$


显然我们可以算出：
$$
\begin{aligned}
\omega_3
&= \cos(\dfrac{2 \pi}{3}) + \sin(\dfrac{2 \pi}{3})i \\
&= -\dfrac{1}{2} + \dfrac{\sqrt{3}}{2}i
\end{aligned}
$$
且：
$$
\begin{aligned}
\omega_3^2
&= (-\dfrac{1}{2} + \dfrac{\sqrt{3}}{2}i)^2 \\
&= -\dfrac{1}{2} - \dfrac{\sqrt{3}}{2}i
\end{aligned}
$$
到此我们便可以求出来最终的结果了。

这里还有两个小细节需要注意：

#### 两个小细节

首先我们在做完 $ \texttt{IFWT} $ 之后需要乘一个 $ \dfrac{1}{3} $，我们当然可以每次都做一个除法，但是观察发现，项数需要满足 $ 3^n $ 形式，而层数也就是 $ \log_3^{3^n} = n $，所以也可以在最后答案除一个 $ 3^n $（和 $ \texttt{FFT} $ 挺像的），不过属于常数优化，差别不大。

然后还需要注意当我们算出来常数项之后，并不能直接输出，观察一下性质 3：
$$
a \circ a \circ a = a
$$
在运算的时候我们显然会把 $ i = j = k $ 的情况算在内了，而显然这是不合法的，所以需要减掉 $ N $。

并且，我们在运算的时候求的是不同，而非本质不同，也就是算的是排列，而我们要求的是组合，所以最后除一个 $ 3! $，也就是 $ 6 $。

综上所述，我们将常数项算出来后最终答案就是 $ \dfrac{F(0) - N}{6} $。

至此，这道卡了我两天多的题，终于结束了。

（记得开 `` long long ``）

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define comp complex < long double > 

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;

template<typename T = int>
inline T read(void);
inline int read3(void);

int N, M;
// 3^12 = 531441
comp poly[1100000];
comp omega(-0.5, 0.5 * sqrt(3));
comp omega2(conj(omega));
enum pattern{IFWT = 0, _FWT};
void FWT(comp*, int, pattern);

int main(){
    N = read(), M = read();
    for(int i = 1; i <= N; ++i)poly[read3()].real(1.0);
    int lim(1), cnt(0);
    while(cnt++ < M)lim *= 3;
    FWT(poly, lim, _FWT);
    for(int i = 0; i < lim; ++i)poly[i] = poly[i] * poly[i] * poly[i];
    FWT(poly, lim, IFWT);
    ll ans = (poly[0].real() / (long double)lim) + 0.5;
    printf("%lld\n", (ans - N) / 6);
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}
void FWT(comp* poly, int lim, pattern pat){
    for(int len = 1; len < lim; len *= 3)
        for(int px = 0; px < lim; px += 3 * len)
            for(int p = 0; p < len; ++p){
                int pos1(px + p + len * 0),
                    pos2(px + p + len * 1),
                    pos3(px + p + len * 2);
                comp pol1 = poly[pos1];
                comp pol2 = poly[pos2];
                comp pol3 = poly[pos3];
                if(pat == _FWT){
                    poly[pos1] = pol1 + pol2 + pol3;
                    poly[pos2] = pol1 + pol2 * omega + pol3 * omega2;
                    poly[pos3] = pol1 + pol2 * omega2 + pol3 * omega;
                }else{
                    poly[pos1] = pol1 + pol2 + pol3;
                    poly[pos2] = pol1 + pol2 * omega2 + pol3 * omega;
                    poly[pos3] = pol1 + pol2 * omega + pol3 * omega2;
                }
            }
}

inline int read3(void){
    int ret(0);
    char c = getchar();
    while(!isdigit(c))c = getchar();
    while(isdigit(c)){
        ret *= 3;
        ret += int(c - '0' - 1);
        c = getchar();
    }
    return ret;
}
template<typename T>
inline T read(void){
    T ret(0);
    short flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```



## UPD

update-2022_08_30 T1-T3

update-2022_09_01 完成一部分的 T4

update-2022_09_02 T4 肝完

update-2022_09_04 初稿

update-2022_09_04 发现 T4 之前算法假掉了，修改了一下

update-2022_09_06 完善 latex 以符合 Luogu 题解要求

---

## 作者：hrgd (赞：0)

我们可以把每一行视为一个 $3$ 进制数（$3\to 0$），类比异或，我们定义 $3$ 进制下的“异或”，即不进位加法。

那么条件就等价于这三个数异或起来为 $0$，于是我们使用 $3$ 进制 $\text{fwt}$ 可以轻松地得到答案。

$\text{fwt}$ 的本质就是对每一位都做一边 $\text{fft}$，所以我们直接对每一位都模拟一遍 $\text{fft}$ 即可，这里有一种比较简洁的实现方式：

```
inline cp W(int x){return w[(x%3+3)%3];}
inline void fwt3(int len,int flag){
	for(int k=1;k<len;k*=3)
		for(int i=0;i<len;i+=(3*k))
			for(int j=0;j<k;j++){
				for(int u=0;u<3;u++)
					b[u]=a[i+j+k*u],a[i+j+k*u]=0;
				for(int u=0;u<3;u++)
					for(int v=0;v<3;v++)
						a[i+j+k*v]+=b[u]*W(u*v*flag);
			}
	if(flag<0)for(int i=0;i<len;i++)a[i]/=len;
}
```

显然进制不同时我们只需替换里面的常数即可。

还有就是单位根，我们运用复数的表达方式，那么由几何意义不难得出。

主函数如下：

```
int main(){
	w[0]=1,w[1]=(cp){cos(2*pi/3),sin(2*pi/3)};w[2]=w[1]*w[1];
	cin>>n>>m;
	for(int i=1,c=0;i<=n;i++,a[c]+=1,c=0)
		for(int j=1,x;j<=m;j++)scanf("%1d",&x),c=3*c+x-1;
	int len=1;for(int i=1;i<=m;i++)len*=3;
	fwt3(len,1);
	for(int i=0;i<len;i++)
		a[i]=a[i]*a[i]*a[i];
	fwt3(len,-1);
	long long ans=(a[0].real()+0.5)-n;
	cout<<ans/6<<endl;
    return 0;
}
```

---


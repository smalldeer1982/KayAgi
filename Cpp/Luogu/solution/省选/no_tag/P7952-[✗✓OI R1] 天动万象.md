# [✗✓OI R1] 天动万象

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/rxbh6s4b.png)

## 题目描述

帝君给了你一棵以 $1$ 为根的有根树，每个点有一个点权 $a_i$，要求支持以下几种操作：

+ $\texttt{1 u}$ 表示查询以 $u$ 为根的子树的最大值。
+ $\texttt{2 u}$ 表示将 $u$ 为根的子树内每一个节点的权值 **同时变为** 其所有 **儿子** 的权值之和，即对这棵子树执行 $\forall x \in \operatorname{subtree}(u), a_x\gets \sum_{y\in \operatorname{son}(x)}a_y$。其中 **同时变为** 的意思是「某个点操作时认为其儿子停留在这次操作未进行前的状态」。

## 说明/提示

**【样例解释】**  

修改前每个点的权值分别为 $1,1,4,5,1,4$。  
第一次修改后变为 $1,1,4,1,0,4$。   
第二次修改后变为 $1,5,0,0,0,4$。  

[更直观的图片](https://www.luogu.com.cn/paste/blqun4u8)

**【数据范围】**  

**本题数据量较大，请注意常数优化。**

对于 $100\%$ 的数据，满足 $1\le n, q \le 10^6$，$1 \le u \le n$，$0 \le a_i \le 10^9$，$\mathit{fa}_i < i$。

以下是子任务（留空则表示无特殊性质），你必须通过一个子任务中的所有测试点以及该子任务依赖的所有测试点，才能获得这个子任务的分数：

| 子任务编号 | $n, q$             | 子任务总分 | 特殊性质 | 依赖子任务 |
| :--------: | :----------------: | :------: | :------: | :--------: |
| 0   | $\le 5\times 10^3$ | 3        | E        |            |
| 1   | $\le 10^5$         | 6        | A, B     |            |
| 2   |                    | 8        | C        |            |
| 3   |                    | 4        | D        |            |
| 4   |                    | 13       | E        | Subtask0   |
| 5   |                    | 36       | B        | Subtask1   |
| 6   |                    | 30       |          | Subtask0~5 |


特殊性质：  

+ 对于满足特殊性质 A 的测试点，保证每次 $1$ 操作 $u=1$。  
+ 对于满足特殊性质 B 的测试点，保证每次 $2$ 操作 $u=1$。  
+ 对于满足特殊性质 C 的测试点，保证对于所有节点 $i$， 满足 $\mathit{fa}_i=i-1$，换句话说树的形态是一条链。  
+ 对于满足特殊性质 D 的测试点，保证对于所有节点 $i$， 满足 $\mathit{fa}_i=1$，换句话说树的形态是一个菊花。  
+ 对于满足特殊性质 E 的测试点，保证数据随机，这里的数据随机指 $\texttt{1}$ 操作和 $\texttt{2}$ 操作等概率出现，$u$ 在 $[1, n]$ 内等概率随机，$\mathit{fa}_i$ 在 $[1, i - 1]$ 内等概率随机。

**提示：由于出题人很懒而且洛谷传不了很多数据点，因此本题数据可能较弱，而且为了避免赛事评测机压力导致的运行时间增加，本题放宽了时限，因此欢迎大家尝试用奇怪的乱搞通过本题。**

> 只愿荡涤四方，护得浮世一隅。

## 样例 #1

### 输入

```
6 6
1 1 4 5 1 4
1 2 2 4 1
1 2
1 1
2 4
1 2
2 2
1 1```

### 输出

```
5
5
4
5```

## 样例 #2

### 输入

```
15 12
512902574 823918122 595349487 580400545 453562767 72015781 850655655 442513356 619194214 644523811 935104539 371670625 477236621 785497862 282980318 
1 2 2 1 2 6 2 2 4 9 6 4 12 1 
2 5
2 1
2 1
2 4
2 15
1 2
1 3
2 2
2 7
1 1
1 2
1 6```

### 输出

```
3279191251
0
2309473383
785497862
0
```

# 题解

## 作者：Rainbow_qwq (赞：11)

自己的赛时做法和官方做法略有不同，就来发一下。

这题操作一次后，子树中的叶子节点会变成 0，考虑复杂度均摊，每次操作复杂度与 删去叶子个数 相关，复杂度就正确。

观察到每次向上操作的时候，如果是一条链就相当于链上所有下面的权值向上移动，只有儿子个数 $\ge 2$ 的时候才是把儿子加起来。

考虑一开始把“链”全部缩起来，相当于建叶子节点的虚树，这样保留的“链”条数就是 $O(\text{叶子节点个数})$。

对于每条链（虚树上的一条边），开一个 FHQ-Treap 维护链上的权值。

修改操作：直接 dfs 虚树的那个子树，对于下面每条链都是删掉最上面一个权值，在最下面加入每个儿子边的权值和。其实就是在模拟操作，都可以用平衡树实现。

查询操作：对于查询点所在的那条链，可以 split 出下面一段；另外在子树里的权值可以 dfs 序线段树，在前面修改操作的时候就维护好。

然后你写了，交了，只能拿 28 分！（链，菊花，随机树）

上面那个做法是有复杂度问题的，在一些叶子节点被删掉之后，可能出现了更多儿子个数 = 1 的点，那就要继续缩起来，才能保证复杂度。

想了一会，发现可以用并查集维护每个点的链顶，每次修改每个点的一个儿子的平衡树如果被删空那就把这个儿子从它的儿子列表里删掉，如果只剩一个儿子了就要把儿子链缩到它自己链上，相当于两个 treap 合并一下。（有很多细节）

（注意每次修改完平衡树都要在 dfn 线段树里 update 一下）

~~代码不长，才 200 行~~，下面是删去部分的代码：

```cpp
#define fi first
#define se second
#define pb push_back
#define mkp make_pair
typedef pair<int,int>pii;
typedef vector<int>vi;

#define maxn 1000005
#define inf 0x3f3f3f3f

int n,m,a[maxn],fa[maxn];
vi e[maxn],dw[maxn];

int ftop[maxn],dep[maxn];
int dfn[maxn],out[maxn],idx;

inline int top(int u){
	while(u!=ftop[u])u=ftop[u]=ftop[ftop[u]];
	return u;
}

struct sgt{
	ll val[maxn<<2];
	void mdf(int p,int l,int r,int x,ll v){
		if(l==r)return val[p]=v,void();
		int mid=l+r>>1;
		x<=mid?mdf(p<<1,l,mid,x,v):mdf(p<<1|1,mid+1,r,x,v);
		val[p]=max(val[p<<1],val[p<<1|1]);
	}
	ll ask(int p,int l,int r,int ql,int qr){
		if(ql>qr)return 0;
		if(l>=ql&&r<=qr)return val[p];
		int mid=l+r>>1;ll res=0;
		if(ql<=mid)res=max(res,ask(p<<1,l,mid,ql,qr));
		if(qr>mid)res=max(res,ask(p<<1|1,mid+1,r,ql,qr));
		return res;
	}
}T;

int rt[maxn];
ll val[maxn],mx[maxn];
int ls[maxn],rs[maxn],cnt,sz[maxn];
unsigned int rnd[maxn];
mt19937 qwqwq(1337); 
inline int newn(int x){
	int u=++cnt;
	val[u]=mx[u]=x;
	sz[u]=1;
	return u;
}
inline void up(int p){
	mx[p]=max(mx[ls[p]],max(mx[rs[p]],val[p]));
	sz[p]=sz[ls[p]]+sz[rs[p]]+1;
}
int merge(int u,int v){
	if(!u||!v)return u|v;
	if(rnd[u]<rnd[v])return rs[u]=merge(rs[u],v),up(u),u;
	return ls[v]=merge(u,ls[v]),up(v),v;
}
void split(int p,int k,int&x,int&y){
	if(!p)return x=y=0,void();
	if(sz[ls[p]]<k) x=p,split(rs[p],k-sz[ls[p]]-1,rs[x],y),up(x);
	else y=p,split(ls[p],k,x,ls[y]),up(y);
}
inline void upd(int u){
	T.mdf(1,1,n,dfn[u],mx[rt[u]]);
}

void dfs(int u,int tp)
{
	ftop[u]=tp;
	dep[u]=dep[fa[u]]+1;
	dfn[u]=++idx;
	rt[tp]=merge(rt[tp],newn(a[u]));
	if(e[u].size()>=2){
		for(auto v:e[u])
			dw[tp].pb(v),dfs(v,v);
	}
	else if(e[u].size()==1) dfs(e[u][0],tp);
	if(u==tp) upd(u);
	out[u]=idx;
}

inline ll ask(int u)
{
	int t=top(u);
	int szl=dep[u]-dep[t],x,y;
	split(rt[t],szl,x,y);
	ll res=mx[y];
	res=max(res,T.ask(1,1,n,dfn[u]+1,out[u]));
	rt[t]=merge(x,y);
	return res;
}

void suo(int u)
{
	int v=dw[u][0];
	ftop[v]=top(u);
	rt[u]=merge(rt[u],rt[v]);
	rt[v]=0;
	swap(dw[u],dw[v]),dw[v].clear();
	upd(v),upd(u);
}

vi del;
ll work(int u)
{
	int x,y;
	split(rt[u],1,x,y);
	ll ret=val[x];
	val[x]=0;
	if(!dw[u].size()){
		rt[u]=y;
		return upd(u),ret;
	}
	vi o;
	for(auto v:dw[u]){
		ll w=work(v);
		if(mx[rt[v]]) o.pb(v);
		val[x]+=w;
	}
	mx[x]=val[x];
	dw[u]=o;
	rt[u]=merge(y,x);
	if(dw[u].size()==1) del.pb(u);
	return upd(u),ret;
}
void shift(int u)
{
	int x,y,z,szl=dep[u]-dep[top(u)];
	split(rt[top(u)],szl,x,y);
	split(y,1,y,z);
	del.clear();
	
	int t=top(u);
	val[y]=0;
	vi o;
	for(auto v:dw[t]){
		ll w=work(v);
		val[y]+=w;
		if(mx[rt[v]]) o.pb(v);
	}
	mx[y]=val[y];
	dw[t]=o;
	if(dw[t].size()==1) del.pb(t);
	rt[t]=merge(merge(x,z),y);
	upd(t);
	
	for(auto x:del) suo(x);
}

signed main()
{
//	freopen("my.out","w",stdout);
	n=read(),m=read();
	For(i,1,n)a[i]=read(),rnd[i]=qwqwq();
	For(i,2,n)fa[i]=read(),e[fa[i]].pb(i);
	dfs(1,1);
	For(_,1,m){
		int op=read(),x=read();
		if(op==2)shift(x);
		else printf("%lld\n",ask(x));
	}
	return 0;
}
```

---

## 作者：myee (赞：8)

### 前言

✗✓OI TXDY！

NOIP 前一发题解，RP++！

---
### 思路

为了建立直观理解，我们尝试对树进行**重构**。

你考虑这么一件事情，就是说：我们考虑把树**三度化**，每个结点变成**一条向右的链**，**链上每个结点的左儿子是原树该结点的各个儿子**。

我们发现这是一颗**二叉树**。为简便，我们以下称其为**重构树**，向右的链称为**右链**，向左的链称为**左链**。

我们给出样例 1 的其中一颗重构树：

![](https://cdn.luogu.com.cn/upload/image_hosting/zwstx2lq.png)

我们规定重构树上每个右链的根结点为**实结点**，权值为原树上该结点的权值；其余点称为**虚结点**，权值 $0$。虚结点中最下面的称为**最末虚结点**。

实结点的左儿子称为**重左儿子**，虚结点左儿子称为**轻左儿子**。

我们发现，在原树上的 2 操作，在重构树上有**简洁的表示**！

你考虑这么一件事情，就是说：在重构树上，实结点权值向父亲平移，根节点权值扔掉，未赋值者用 $0$ 补齐。

这样的话显然虚结点权值可能被赋值，于是将其权值再送给其对应的实结点。

这就是 2 操作在重构树上的表示。

我们发现，对重构树 dfs 序的区间左移一位，与我们上述描述几乎等价！**因为虚结点所在的权值 $0$ 段刚好转移到最新叶结点上了！**

对被赋值的虚结点，我们如何更新？

你考虑这么一件事情，就是说：虚结点必定是其父亲的右儿子，且必定有左儿子，因此其**必定位于一条左链的顶端**。而且，这条左链上**必然除了其外都为实结点**。我们称最低者为**最末实结点**。

因此我们**动态维护每条左链上还活着的最末实结点**，并在修改时动态更新其所在左链根结点即可。

为了得到每个点所在左链根结点，我们可以考虑一个类似树剖的过程：dfs 一遍原树，取重左儿子指向根节点指向的左链链顶，让轻左儿子指向根节点的各个虚结点。

为了保证复杂度，我们**必须用 `size` 来定义重左儿子和轻左儿子**，从而获得均摊的复杂度。像上面图例那样就是不可取的。

通过以上描述，我们发现 2 操作被描述成了重构树 dfs 序上的区间平移与若干次单点修改。

放一部分代码理解一下。

```cpp
uint Fath[1000005];
std::set<uint>Leaf;
std::vector<uint>Insert,Erase,Son[1000005];
uint Bgn[1000005],End[1000005],cnt=1,Belong[3000005],Heavy[1000005],Siz[1000005],Up[1000005],Deg[1000005];
ullt A[1000005];
voi get(uint p)
{
	Siz[p]=1,Heavy[p]=-1,Deg[p]=Son[p].size();
	for(auto s:Son[p]){get(s),Siz[p]+=Siz[s];if(Heavy[p]==-1u||Siz[s]>Siz[Heavy[p]])Heavy[p]=s;}
}
voi dfs(uint p,uint user)
{
    Up[Belong[cnt]=p]=user,Splay::insert(cnt,A[Belong[cnt]]),Bgn[p]=cnt++;
    if(~Heavy[p])dfs(Heavy[p],user);
    for(auto s:Son[p])if(s!=Heavy[p])Splay::insert(cnt,0),Belong[cnt++]=p,dfs(s,cnt-1);
    End[p]=cnt;if(Heavy[p]==-1u)Leaf.insert(Bgn[p]);
}
```

```cpp
if(!Splay::find(Bgn[p],End[p]))continue;
Splay::erase(Bgn[p]),Splay::insert(End[p]-1,0);
auto iter=Leaf.upper_bound(Bgn[p]);
while(iter!=Leaf.end()&&*iter<End[p])
{
    uint u(Belong[*iter]);uint t(Up[u]);
    Splay::kth(t);ullt v(Splay::rot->v);
    Splay::rot->v=0,Splay::add(Bgn[Belong[t]],v);
    if(!Deg[u])
    {
	    Erase.push_back(*iter);
        if(!--Deg[Fath[u]]||Up[Fath[u]]==t)Insert.push_back(Bgn[Fath[u]]);
    }
    ++iter;
}
for(auto s:Erase)Leaf.erase(s);
for(auto s:Insert)Leaf.insert(s);
Insert.clear(),Erase.clear();
```

观察一下重构树上的 dfs 序，发现这本质就是**原树欧拉序对每个非叶结点去掉最后一次出现位置的结果**。

因此，1 操作被描述成了区间查询 max！

于是，我们的问题就变成了**区间平移、单点修改与区间查询 max 的高效实现**！

注意到数据范围 $10^6$，块状链表似乎不是很有前途，于是毅然弃疗上 Splay，结果因为常数大被卡常了……听说 fhq treap 做法与跳表做法常数很小？~~其实是因为我常数很大。~~

总复杂度可以证明是 $O((n+q)\log n)$ 的。

---
### Code

超级快读快写啥的这里删掉了，所以直接贺题解会 CE……加上后可以稳定 57pts。

想 AC 的话要卡常。~~我会说我是我自己卡常卡到不让交了让 peterwuyihong 帮我卡常才过的吗？~~

```cpp
#include <algorithm>
#include <set>
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T power(T base,T index,T mod){return((index<=1)?(index?base:1):(power(base*base%mod,index>>1,mod)*power(base,index&1,mod)))%mod;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(!b)return y=0,x=1,a;T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}
namespace Splay
{
    struct node
    {
        uint siz;ullt v,max;node*fath,*son[2];
        node(ullt v=0):siz(1),v(v),fath(NULL){son[0]=son[1]=NULL;}
        voi pushup()
        {
            siz=1,max=v;
            if(son[0]!=NULL)siz+=son[0]->siz,_max(max,son[0]->max);
            if(son[1]!=NULL)siz+=son[1]->siz,_max(max,son[1]->max);
        }
        bol howson(){return this==fath->son[1];}
        voi rotate()
        {
            if(fath==NULL)return;
            node*f=fath,*ff=fath->fath;bol sk=howson();
            if((fath=ff)!=NULL)ff->son[f->howson()]=this;
            if((f->son[sk]=son[!sk])!=NULL)son[!sk]->fath=f;
            (son[!sk]=f)->fath=this,f->pushup(),pushup();
        }
    };
    node*rot;
    voi splay(node*p)
    {
        if(p==NULL)return;
        p->pushup();
        while(p->fath!=NULL)
        {
            if(p->fath->fath!=NULL)(p->howson()==p->fath->howson()?p->fath:p)->rotate();
            p->rotate();
        }
        rot=p;
    }
    voi splay2(node*p,node*to)
    {
        if(p==NULL)return;
        p->pushup();
        while(p->fath!=to)
        {
            if(p->fath->fath!=to)(p->howson()==p->fath->howson()?p->fath:p)->rotate();
            p->rotate();
        }
        if(to==NULL)rot=p;
    }
    voi insert(ullt k,ullt v)
    {
        if(rot==NULL){rot=new node(v);return;}
        node*p=rot;
        while(true)
        {
            if(p->son[0]!=NULL)
            {
                if(p->son[0]->siz>k){p=p->son[0];continue;}
                k-=p->son[0]->siz;
            }
            if(k<=1)
            {
            	node*w=new node(v);if((w->son[k]=p->son[k])!=NULL)p->son[k]->fath=w;
            	splay((w->fath=p)->son[k]=w);return;
            }
            k--,p=p->son[1];
        }
    }
    voi kth(ullt k,node*to=NULL)
    {
        node*p=rot;
        while(true)
        {
            if(p->son[0]!=NULL)
            {
                if(p->son[0]->siz>k){p=p->son[0];continue;}
                k-=p->son[0]->siz;
            }
            if(!k){splay2(p,to);return;}
            k--,p=p->son[1];
        }
    }
    voi pre()
    {
        if(rot==NULL||rot->son[0]==NULL)return;
        node*p=rot->son[0];while(p->son[1]!=NULL)p=p->son[1];
        splay(p);
    }
    voi erase(ullt k)
    {
    	kth(k);node*p=rot;
        if(p->son[0]==NULL){if((rot=p->son[1])!=NULL)rot->fath=NULL;}
        else if(p->son[1]!=NULL)pre(),(p->son[1]->fath=rot)->son[1]=p->son[1];
        else(rot=p->son[0])->fath=NULL;
        delete p;splay(rot);
    }
    ullt find(uint l,uint r)
    {
		return kth(l-1),((r==rot->siz)?rot->son[1]->max:(kth(r,rot),rot->son[1]->son[0]->max));
    }
    voi add(uint k,ullt v)
    {
        node*p=rot;
        while(true)
        {
            if(p->son[0]!=NULL)
            {
                if(p->son[0]->siz>k){p=p->son[0];continue;}
                k-=p->son[0]->siz;
            }
            if(!k){p->v+=v,splay(p);return;}
            k--,p=p->son[1];
        }
    }
    // voi add(uint p,ullt v){kth(p),rot->v+=v,rot->pushup();}
};
uint Fath[1000005];
std::set<uint>Leaf;
std::vector<uint>Insert,Erase,Son[1000005];
uint Bgn[1000005],End[1000005],cnt=1,Belong[3000005],Heavy[1000005],Siz[1000005],Up[1000005],Deg[1000005];
ullt A[1000005];
voi get(uint p)
{
	Siz[p]=1,Heavy[p]=-1,Deg[p]=Son[p].size();
	for(auto s:Son[p]){get(s),Siz[p]+=Siz[s];if(Heavy[p]==-1u||Siz[s]>Siz[Heavy[p]])Heavy[p]=s;}
}
voi dfs(uint p,uint user)
{
    Up[Belong[cnt]=p]=user,Splay::insert(cnt,A[Belong[cnt]]),Bgn[p]=cnt++;
    if(~Heavy[p])dfs(Heavy[p],user);
    for(auto s:Son[p])if(s!=Heavy[p])Splay::insert(cnt,0),Belong[cnt++]=p,dfs(s,cnt-1);
    End[p]=cnt;if(Heavy[p]==-1u)Leaf.insert(Bgn[p]);
}
uint read()
{
	uint ans=0;chr c;do c=getchar();while(c>'9'||c<'0');
	do ans=ans*10+c-'0',c=getchar();while(c>='0'&&c<='9');return ans;
}
int main()
{
    uint n,q,op,p;n=read(),q=read();for(uint i=0;i<n;i++)A[i]=read();
    for(uint i=1;i<n;i++)Son[Fath[i]=read()-1].push_back(i);
	get(0),Splay::insert(0,0),dfs(0,0);
    while(q--)
    {
        op=read(),p=read()-1;
        if(op==1)cout<<Splay::find(Bgn[p],End[p])<<endl;
        else
        {
            if(!Splay::find(Bgn[p],End[p]))continue;
            Splay::erase(Bgn[p]),Splay::insert(End[p]-1,0);
            auto iter=Leaf.upper_bound(Bgn[p]);
            while(iter!=Leaf.end()&&*iter<End[p])
            {
            	uint u(Belong[*iter]);uint t(Up[u]);
            	Splay::kth(t);ullt v(Splay::rot->v);
            	Splay::rot->v=0,Splay::add(Bgn[Belong[t]],v);
                if(!Deg[u])
                {
                	Erase.push_back(*iter);
	                if(!--Deg[Fath[u]]||Up[Fath[u]]==t)Insert.push_back(Bgn[Fath[u]]);
                }
                ++iter;
            }
            for(auto s:Erase)Leaf.erase(s);
            for(auto s:Insert)Leaf.insert(s);
            Insert.clear(),Erase.clear();
        }
    }
    return 0;
}
```

---
### 其他思考

整理一下，基于三度化的重构树具有这么几个特性：
* 是一颗二叉树，结点的儿子被描述成了其所在右链的各个结点的左儿子
* 右链顶端是实结点，其余为虚结点
* 除了根节点所在左链，其余左链顶端均虚结点，其它结点为实结点
* 重构树上的 dfs 序与原树欧拉序对每个非叶结点去掉最后一次出现位置的结果相同
* 原树上儿子同时把权值贡献给父亲，等价于重构树上儿子向父亲平移权值，再把右链上虚结点权值转移给实结点

我们给出了重构树的概念，至于我们能否用此实现其他功能抑或是建立其他模型，还有待思考。


---

## 作者：JimmyLee (赞：4)

提供一种和第一篇题解不同的理解思路。

# 题目分析

看到操作 $1$：拿 dfs 序水水就行了。

看到操作 $2$：？？？

## 特殊情况

我们考虑一下特殊情况下操作 $2$ 怎么处理。

假如这棵树是**一条链**。

![](https://cdn.luogu.com.cn/upload/image_hosting/5dbwrco0.png)

设从根到叶节点权值如下：（随便赋的）

| 节点编号 |  1   |  2   |  3   |  4   |  5   |  6   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
|   权值   |  1   |  2   |  3   |  4   |  5   |  6   |

如果我们对 $2$ 号节点执行操作 $2$，权值就变成这样：

| 节点编号 |  1   |  2   |  3   |  4   |  5   |  6   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
|   权值   |  1   |  3   |  4   |  5   |  6   |  0   |

再对 $1$ 号节点执行操作 $2$，权值就变成这样：

| 节点编号 |  1   |  2   |  3   |  4   |  5   |  6   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
|   权值   |  3   |  4   |  5   |  6   |  0   |  0   |

发现在链的情况下，直接将 $[p,p+\textrm{size}(p)-1]$ 的区间向左平移一位，首位舍弃，末位补零即可。

这样打一棵 FHQ Treap 维护区间最大值就行了。

## 一般情况

### 序列处理

那要是它不是一条链呢？

感觉刚刚的做法比较好用，尝试往树上套。

例如这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/tgkpzyp5.png)

设从根到叶节点权值如下：

| 节点编号 |  1   |  2   |  3   |  4   |  5   |
| :------: | :--: | :--: | :--: | :--: | :--: |
|   权值   |  1   |  2   |  3   |  4   |  5   |

发现此时单纯的平移无法满足条件。

考虑给有多个儿子的节点开几个虚拟节点。

保证对于任意**非根非虚拟节点**，在序列上它的前一位是它的父亲。

同时保证一个子树中的节点在序列上是**连续的**。（和树链剖分一样）

所以就变成这样：（v 表示虚拟节点，r 表示普通节点）

|  1r  |  2r  |  4r  |  2v  |  5r  |  1v  |  3r  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  2   |  4   |  0   |  5   |  0   |  3   |

发现这就是**在回溯时不记录该节点的欧拉序**。

如果我们对 $1$ 号节点执行操作 $2$，权值就变成这样：

|  1r  |  2r  |  4r  |  2v  |  5r  |  1v  |  3r  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  2   |  4   |  0   |  5   |  0   |  3   |  0   |

发现满足了题意，只要**每次将虚拟节点上的权值转移回根节点**即可。

### 权值转移

考虑朴素转移，记录每个节点的所有虚拟节点，每次枚举子树内的非叶节点，暴力加。

发现一次操作时间复杂度为 $O(n)$。（链的情况）

~~评价是不如暴力。~~

我们很容易发现，对于任意子树，虚拟节点的个数就是叶节点个数减 $1$。

考虑从叶节点更新虚拟节点。

我们为每个节点分配一个它负责更新的节点。

|  1r  |  2r  |  4r  |  2v  |  5r  |  1v  |  3r  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  -   |  -   |  -   |  -   |  2v  |  -   |  1v  |

每次修改的时候枚举叶节点，将其对应的虚拟节点的权值更新到普通节点上即可。

为了保证时间复杂度，每次更新后应动态维护叶节点，删去原本的。

---

现在要解决两个问题：

1. 如何为每个节点分配它负责更新的节点？
2. 如何动态维护叶节点集合？

---

对于第一个问题，首先我们知道，**对于一条链上的节点，它们负责更新的节点应该是同一个。**

比如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/h78t6evt.png)

|  1r  |  2r  | 1v-1 |  3r  | 1v-2 |  4r  |  5r  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  -   |  -   |  -   | 1v-1 |  -   | 1v-2 | 1v-2 |

4r 节点和 5r 节点应维护同一信息，否则在操作后删去 5r 后会导致没有节点更新 1v-2 节点。

这一部分可以利用**链剖分**的方式进行。

~~出于一些神奇的原因，我的代码只有重链剖分能过，望各位大佬告诉我原因。~~

---

再考虑如何维护叶节点集合。

注意：这里的**叶节点**包括所有用于更新节点的点，有的点可能不是叶子。

考虑开一棵平衡树来维护，其中存储叶节点在序列上的编号。

每次枚举 $[\textrm{begin}(p),\textrm{end}(p)]$ 间的叶节点。

- 该节点是真正的叶节点，那么更新完后删除自己，尝试将父节点加入。
- 该节点不是真正的叶节点，那么更新完就不用管了。

父节点加入集合有两种情况：

- 该节点和父节点在同一条链上，为了保证正常更新，所以将父节点加入。
- 删去该节点后父节点成了叶子。

结束。

# Code

这份代码为了卡常整体十分丑陋。

我把指针 FHQ 换成了数组版的，并且把结构体给丢了，换成命名空间。

~~还有极为混乱的宏定义。~~

~~我在卡的时候只要能过编译就行。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1000006
mt19937 rnd(time(0));

namespace s_tr
{
    struct node
    {
        uint64_t v=0;
        uint32_t id=0;
        int siz=1;
        uint32_t lc=0, rc=0;
        uint64_t mx=0;
        node(uint64_t va, uint32_t d): v(va), id(d) {mx=v;}
        node() {}
    }tr[maxn<<1];

    #define siz(x) (x?tr[x].siz:0)

    int push_up(uint32_t x)
    {
        tr[x].siz=1+siz(tr[x].lc)+siz(tr[x].rc);
        tr[x].mx=max({tr[x].v, tr[tr[x].lc].mx, tr[tr[x].rc].mx});
        return x;
    }

    int rt=0, cnt=0;

    int new_node(uint64_t v) 
    {
        tr[++cnt]=node(v, rnd());
        return cnt;
    }

    void split(uint32_t x, int s, uint32_t &l, uint32_t &r)
    {
        if(!x) return l=r=0, void();
        if(siz(tr[x].lc)<s) l=x, split(tr[x].rc, s-siz(tr[x].lc)-1, tr[x].rc, r);
        else             r=x, split(tr[x].lc, s, l, tr[x].lc);
        push_up(x);
    }

    uint32_t merge(uint32_t x, uint32_t y)
    {
        if(!x||!y) return x?x:y;
        if(tr[x].id<tr[y].id)
        {
            tr[x].rc=merge(tr[x].rc, y);
            return push_up(x);
        }
        else
        {
            tr[y].lc=merge(x, tr[y].lc);
            return push_up(y);
        }
    }

    void push_back(int v) {rt=merge(rt, new_node(v));}

    uint64_t max_element(int l, int r)
    {
        uint32_t a, b, c;
        split(rt, l-1, a, b);
        split(b, r-l+1, b, c);
        uint64_t ret=tr[b].mx;
        rt=merge(a, merge(b, c));
        return ret;
    }

    void modify(int p, uint64_t v)
    {
        uint32_t a, b, c;
        split(rt, p-1, a, b);
        split(b, 1, b, c);
        tr[b].mx=tr[b].v=v;
        rt=merge(a, merge(b, c));
    }
    
    void accumulate(int p, uint64_t v)
    {
        uint32_t a, b, c;
        split(rt, p-1, a, b);
        split(b, 1, b, c);
        tr[b].mx=tr[b].v=v+tr[b].v;
        rt=merge(a, merge(b, c));
    }

    int64_t get(int k)
    {
        uint32_t p=rt;
        while(p)
        {
            uint32_t sz=siz(tr[p].lc);
            if(k<=sz) p=tr[p].lc;
            else if(k<=sz+1) return tr[p].v;
            else {k-=sz+1, p=tr[p].rc;}
        }
        return 0;
    }
}

int val[maxn];
vector<int> e[maxn];
int fa[maxn], vis[maxn<<1];

vector<int> ins;

namespace tr
{
    struct node
    {
        uint64_t v=0;
        uint32_t id=0;
        int siz=1;
        uint32_t lc=0, rc=0;
        node(uint64_t va, uint32_t d): v(va), id(d) {}
        node() {}
    }tr[maxn<<1];

    #define siz(x) (x?tr[x].siz:0)

    int push_up(uint32_t x)
    {
        tr[x].siz=1+siz(tr[x].lc)+siz(tr[x].rc);
        return x;
    }

    int rt=0, cnt=0;

    int new_node(uint64_t v) 
    {
        tr[++cnt]=node(v, rnd());
        return cnt;
    }

    void split(uint32_t x, int v, uint32_t &l, uint32_t &r)
    {
        if(!x) return l=r=0, void();
        if(tr[x].v<=v) l=x, split(tr[x].rc, v, tr[x].rc, r);
        else           r=x, split(tr[x].lc, v, l, tr[x].lc);
        push_up(x);
    }

    uint32_t merge(uint32_t x, uint32_t y)
    {
        if(!x||!y) return x?x:y;
        if(tr[x].id<tr[y].id)
        {
            tr[x].rc=merge(tr[x].rc, y);
            return push_up(x);
        }
        else
        {
            tr[y].lc=merge(x, tr[y].lc);
            return push_up(y);
        }
    }

    void insert(int v)
    {
        uint32_t x, y;
        split(rt, v, x, y);
        rt=merge(merge(x, new_node(v)), y);
    }

    void erase(int v)
    {
        uint32_t l, r, x, y;
        split(rt, v, l, r);
        split(l, v-1, x, y);
        l=merge(tr[y].lc, tr[y].rc);
        rt=merge(merge(x, l), r);
    }
}

int son[maxn], siz[maxn], deg[maxn];
int st[maxn], ed[maxn], top[maxn], dic[maxn<<1];

vector<uint32_t> con;
void work(uint32_t xp)
{
    if(!xp) return;
    work(tr::tr[xp].lc);
    con.emplace_back(tr::tr[xp].v);
    work(tr::tr[xp].rc);
}

void dfs1(int u)
{
    siz[u]=1;
    for(auto v:e[u])
    {
        dfs1(v);
        siz[u]+=siz[v];
        if(siz[v]>siz[son[u]])
            son[u]=v;
    }
}

void dfs2(int u, int tx)
{
    dic[st[u]=++*dic]=u;
    top[u]=tx;
    deg[u]=e[u].size();
    s_tr::push_back(val[u]);
    if(son[u]) dfs2(son[u], tx);
    for(auto v:e[u])
        if(v!=son[u])
        {
            s_tr::push_back(0);
            dic[++*dic]=u;
            dfs2(v, *dic);
        }
    ed[u]=*dic;
    if(!son[u]) 
        tr::insert(st[u]), 
        vis[st[u]]=1;
}

#undef siz
#define siz 100000000
char buf[siz],*p1=buf,*p2=buf,obuf[siz],*p3=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,siz,stdin),p1==p2)?EOF:*p1++)
#define putchar(x) (p3-obuf<siz)?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)
#define flush() fwrite(obuf,p3-obuf,1,stdout),p3=obuf
template<typename T>inline void read(T &x){char c=getchar();x=0;for(;!isdigit(c);c=getchar());for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));}

int main()
{
    int n, q;
    read(n), read(q);
    for(int i=1;i<=n;i++) read(val[i]);
    for(int i=2;i<=n;i++) read(fa[i]), e[fa[i]].emplace_back(i);
    dfs1(1);
    dfs2(1, 1);
    while(q--)
    {
        int op, u;
        read(op), read(u);
        if(op==1) printf("%lld\n", s_tr::max_element(st[u], ed[u]));
        else
        {
            uint32_t a, b, c, d;
            s_tr::split(s_tr::rt, st[u]-1, a, b);
            s_tr::split(b, ed[u]-st[u]+1, b, d);
            if(!s_tr::tr[b].mx) 
            {
                s_tr::rt=s_tr::merge(a, s_tr::merge(b, d));
                continue;
            }
            s_tr::split(b, 1, b, c);
            s_tr::tr[b].v=s_tr::tr[b].mx=0;
            s_tr::rt=s_tr::merge(a, s_tr::merge(c, s_tr::merge(b, d)));
            tr::split(tr::rt, st[u]-1, a, b);
            tr::split(b, ed[u], b, c);
            con.clear();
            work(b);
            for(auto xt:con)
            {
                int p=dic[xt];
                int t=top[p];
                if(t!=st[dic[t]])
                {
                    uint64_t x=s_tr::get(t);
                    if(x)
                    {
                        s_tr::modify(t, 0);
                        s_tr::accumulate(st[dic[t]], x);
                    }
                }
                if(!deg[p])
                {
                    if((!--deg[fa[p]]||top[fa[p]]==t)&&!vis[st[fa[p]]]) 
                        ins.emplace_back(st[fa[p]]), vis[st[fa[p]]]=1;
                }
                else ins.emplace_back(xt);
            }
            tr::rt=tr::merge(a, c);
            for(auto v:ins) tr::insert(v);
            ins.clear();
        }
    }
    flush();
}
```

---

## 作者：born_to_sun (赞：3)

### 初步观察
一次操作后，$u$ 子树内节点数量减少 $cnt_u$ 个，$cnt_u$ 为 $u$ 子树内叶子数量，据此可以考虑均摊。

由于数据范围 $n=10^6$，所以我们希望每次能够用不超过 $O(cnt_u\times \log n)$ 的时间复杂度解决问题。

### 得出算法
我们将树划分为若干条链（目前我们不能确定一种划分方式，暂且认为我们进行了随机链剖分），发现每次需要将一条链删除某个点，然后整体平移。

考虑用平衡树维护，设每次被操作的链个数为 $x$，则每次操作的时间复杂度为 $O(x)$，注意：$x\not =$ 叶子个数，因为可能有一个 $deg_u\geq 2$ 的点，我们把它的儿子删到只剩一个，但是它的这个儿子并没有和它划分到一条链中，所以这样复杂度错误。

没救了吗？我们充分发扬人类智慧，考虑重剖，那么一个点跳轻边至多 $\log n$ 次，所以复杂度为 $n\log^2n$，无法通过。

但是……树剖常数小！我说它能过，于是我写了，过了，跑的飞快。

### 复杂度证明
事实真的如此吗？我构造了多种树，均未能卡掉，所以跳轻边的发生次数应当为 $O(n)$。

为什么？如果一个点 $u$ 的轻儿子能够产生贡献，当且仅当它的重儿子已经被删掉，如果有多个轻儿子，会合成一个，只有一个轻儿子多产生了贡献，所以只用考虑其中一个轻儿子（可以只考虑 $u$ 最晚被删除的轻儿子），它的子树大小一定 $\leq {siz_u\over 2}$，其它轻儿子不产生贡献。

也就是说，如果你想让这条轻边产生贡献，那么节点数至少砍半，这等价于每个点初始点权为 $1$，每次产生的贡献为子树内点权和，产生贡献后，子树内所有点的点权 $\times {1\over 2}$。

那么一个点产生的贡献至多为 $\sum_{i=0}^{\log n} {1\over2^i}\leq 2$，因此复杂度为 $O(n\log n)$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 mt(__builtin_ia32_rdtsc());
const int N=2e6+5;
set<int> st;
int ee[N],L[N],e[N];
int siz[N],dep[N],fa[N],son[N],dfn[N],tim,to[N],ed[N],top[N];
int cnt[N];
void dfs1(int u,int ft){
	siz[u]=1;dep[u]=dep[ft]+1;
	for(int i=L[u];i<L[u+1];i++){
		int v=e[i];
		dfs1(v,u);
		fa[v]=u;
		siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
}
void dfs2(int u,int ft){
	dfn[u]=++tim;to[tim]=u;
	top[u]=(u==son[ft]? top[ft]: u);
	if(son[u]) dfs2(son[u],u),ed[u]=ed[son[u]];
	else ed[u]=u,st.insert(dfn[u]),cnt[u]=dfn[ed[u]]-dfn[top[u]]+1;
	for(int i=L[u];i<L[u+1];i++){
		int v=e[i];
		if(v==son[u]) continue;
		dfs2(v,u);
	}
}
int n,m,a[N];
struct FHQ{
	int rt,p1,p2,p3;
	unsigned key[N];
	int ls[N],rs[N];
	long long mx[N],f[N];
	int ad[N],vl[N];
	int sk[N],top;
	void init(){
		for(int i=1;i<N;i++) sk[++top]=i;
	}
	int create(int x,long long y){
		int u=sk[top--];assert(top>=0);
		key[u]=mt();
		ad[u]=ls[u]=rs[u]=0;
		vl[u]=x;
		f[u]=mx[u]=y;
		return u;
	}
	inline void revise(int u,int k){
		ad[u]+=k;vl[u]+=k;
	}
	inline void pushdown(int u){
		if(ad[u]) revise(ls[u],ad[u]),revise(rs[u],ad[u]),ad[u]=0;
	}
	void up(int u){
		mx[u]=max({mx[ls[u]],mx[rs[u]],f[u]});
	}
	int merge(int p1,int p2){
		if(!p1||!p2) return p1+p2;
		pushdown(p1);pushdown(p2);
		if(key[p1]<key[p2]){rs[p1]=merge(rs[p1],p2);up(p1);return p1;}
		else{ls[p2]=merge(p1,ls[p2]);up(p2);return p2;}
	}
	int build(int l,int r){
		if(l==r){return create(l,a[to[l]]);}
		int mid=(l+r)>>1;
		return merge(build(l,mid),build(mid+1,r));
	}
	long long query(int l,int r,int u){
		split(rt,p1,p2,l-1);
		split(p2,p2,p3,r);
		long long res=mx[p2];
		rt=merge(merge(p1,p2),p3);
		return res;
	}
	void add(int l,int r,int u){
		split(rt,p1,p2,l-1);
		split(p2,p2,p3,r);
		revise(p2,-1);
		rt=merge(merge(p1,p2),p3);
	}
	void split(int u,int &p1,int &p2,int x){
		if(!u){p1=p2=0;return;}
		pushdown(u);
		if(vl[u]<=x) p1=u,split(rs[u],rs[u],p2,x);
		else p2=u,split(ls[u],p1,ls[u],x);
		up(u);
	}
	void insert(int x,long long y){
		int u=create(x,y);
		split(rt,p1,p2,x);
		rt=merge(merge(p1,u),p2);
	}
	long long erase(int &u,int x){
		split(rt,p1,p2,x-1);
		split(p2,p2,p3,x);
		long long res=-1;
		if(p2){
			sk[++top]=p2;res=f[p2];
		}
		rt=merge(p1,p3);
		return res;
	}
	bool update(int u,int x,long long v){
		if(!u) return 0;
		pushdown(u);
		if(vl[u]==x){f[u]+=v;up(u);return 1;}
		bool F=0;
		if(x<vl[u]) F=update(ls[u],x,v);
		else F=update(rs[u],x,v);
		up(u);
		return F;
	}
}fhq;
int in[N];long long ad[N];
int sk[N],tot;
void solve(int u){
	auto it=st.lower_bound(dfn[u]);
	while(it!=st.end()&&*it<=dfn[u]+siz[u]-1){
		int v=to[*it];
		if(dep[top[v]]>dep[u]) v=top[v];
		else v=u;
		long long d=fhq.erase(fhq.rt,dfn[v]);
		if(d==-1){it++;continue;}

		if(u!=v){
			if(!in[fa[v]]) sk[++tot]=fa[v],in[fa[v]]=1;
			ad[fa[v]]+=d;
		}

		cnt[ed[v]]--;
		if(!cnt[ed[v]]) it=st.erase(it);
		else it++;
	}
	fhq.add(dfn[u],dfn[u]+siz[u]-1,fhq.rt);
	while(tot){
		int u=sk[tot--];in[u]=0;
		if(!fhq.update(fhq.rt,dfn[u],ad[u])){
			fhq.insert(dfn[u],ad[u]);
			if(!cnt[ed[u]]) st.insert(dfn[ed[u]]);
			cnt[ed[u]]++;
		}
		ad[u]=0;
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	fhq.init();
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=2;i<=n;i++){
		int x;cin>>x;L[x]++;ee[i]=x;
	}
	for(int i=1;i<=n+1;i++) L[i]+=L[i-1];
	for(int i=2;i<=n;i++) e[L[ee[i]]--]=i;
	for(int i=1;i<=n+1;i++) L[i]++;
	dfs1(1,0);
	dfs2(1,0);
	fhq.rt=fhq.build(1,n);
	for(int i=1;i<=m;i++){
		int op,x;cin>>op>>x;
		if(op==1) cout<<fhq.query(dfn[x],dfn[x]+siz[x]-1,fhq.rt)<<'\n';
		else solve(x);
	}
	return 0;
}
```

---

## 作者：bamboo12345 (赞：1)

题意：很简单了，不再赘述。

做法：

首先 $O(n^2)$ 暴力是显然的。

我们考虑怎么去优化这个暴力，对于一个节点的儿子全部贡献到其这种操作其实非常经典，比如动态 dp 的时候我们就采取了重链剖分的方式优化，我们考虑也去用链剖分的方式去优化。

具体的，我们每个节点钦定一个重儿子。那么对于一次修改，我们就将所有的链向上位移一位，对于链顶，直接暴力贡献到其父亲上，这个显然是可以用平衡树维护每一条链的，需要注意对于 $u$ 节点所在的链，应该先 split 出来末尾若干个点再向上拉，链顶的权值应该直接扔掉。

注意在每个链消除完的时候，我们直接扔掉这个链，因为他以后一定不会有任何贡献了，这也是我们后面会提到的时间复杂度分析中的保证，这个可以用 set 去维护所有链的链顶。注意实现时按照深度或者 dfn 序对链进行修改，否则可能提前贡献出问题。
 
对于询问，我们考虑开一个线段树，线段树上每个叶子节点如果是链顶，那么权值为这条链的最大值，否则为 $0$，那么就是在 dfs 序上的区间 $\max$，当然对于 $u$ 所在的链是残缺的，我们也去 split 出来贡献到答案里再 merge 回去。

那么聪明的你会发现了，我们做了这么久口胡，貌似没有提到该如何剖分，其他题解中都是采用的重链剖分，我没太看懂，我们来从头分析一下这个做法的时间消耗。

首先对于残缺的链，这一部分的修改次数显然是 $O(n)$ 的，那么对于所有向上贡献的如何计算？我们考虑在每个轻边处统计，那么对于一个子树内向上的次数就是子树内的最长链长度，我们考虑每个点钦定一个重儿子，那么我们肯定是令儿子中最长链最长的，也就是长链剖分！并且我们很容易计算出来这样剖分的修改次数：对于每个链顶，也就是轻边下面的那个点，他的贡献是长链链长，即 $O(n)$。

所以总复杂度为 $O(n\log n)$。

代码：

```
#include <bits/stdc++.h>
using namespace std;
mt19937 rnd(time(0));
const int maxn = 1e6 + 5;
int f[maxn];
vector<int> e[maxn];
int mxd[maxn], son[maxn], a[maxn], n, q, dfn[maxn], tot, top[maxn], rev[maxn], dep[maxn], ed[maxn];
struct node {
	int l, r;
	long long val;
	int sz, del;
	long long mx;
};
struct FHQ_Treap {
	node tr[maxn];
	int tot, rt[maxn];
	inline int newnode(int x) {
		tot++;
		tr[tot].val = tr[tot].mx = x, tr[tot].sz = 1, tr[tot].del = rnd();
		return tot;
	}
	inline void pushup(int t) {
		tr[t].sz = tr[tr[t].l].sz + tr[tr[t].r].sz + 1;
		tr[t].mx = max(max(tr[tr[t].l].mx, tr[tr[t].r].mx), tr[t].val);
	}
	void split(int p, int &l, int &r, int k) {
		if(!p) {
			l = r = 0;
			return ;
		}
		if(tr[tr[p].l].sz + 1 <= k)
			l = p, split(tr[p].r, tr[l].r, r, k - tr[tr[p].l].sz - 1);
		else
			r = p, split(tr[p].l, l, tr[r].l, k);
		pushup(p);
	}
	int mrg(int l, int r) {
		if(!l || !r)
			return l + r;
		int p;
		if(tr[l].del > tr[r].del)
			p = l, tr[l].r = mrg(tr[l].r, r);
		else
			p = r, tr[r].l = mrg(l, tr[r].l);
		pushup(p);
		return p;
	}
	inline void renew(int x, int k, long long val) {
		if(tr[tr[x].l].sz + 1 == k) {
			tr[x].val += val;
			pushup(x);
			return ;
		}
		if(tr[tr[x].l].sz + 1 < k)
			renew(tr[x].r, k - tr[tr[x].l].sz - 1, val);
		else
			renew(tr[x].l, k, val);
		pushup(x);
	}
	inline long long query(int x, int pos) {
		int p1, p2;
		split(rt[x], p1, p2, pos - 1);
		long long val = tr[p2].mx;
		rt[x] = mrg(p1, p2);
		return val;
	}
	inline void change(int x, int pos) {
		if(pos != -1) {
			int p1, p2, p3;
			split(rt[x], p1, p2, pos - 1);
			split(p2, p2, p3, 1);
			tr[p2].val = tr[p2].mx = 0;
			rt[x] = mrg(p1, mrg(p3, p2));
		}
		else {
			int p1, p2;
			split(rt[x], p1, p2, 1);
			long long v = tr[p1].val;
			tr[p1].val = tr[p1].mx = 0;
			rt[x] = mrg(p2, p1);
			renew(rt[top[f[x]]], dep[f[x]] - dep[top[f[x]]] + 1, v);
		}
	}
} tree;
void dfs1(int u, int fa) {
	dep[u] = dep[fa] + 1;
	mxd[u] = 1;
	for (int i = 0; i < e[u].size(); i++) {
		int v = e[u][i];
		if(v == fa)
			continue;
		dfs1(v, u);
		if(mxd[son[u]] < mxd[v])
			son[u] = v;	
		mxd[u] += mxd[v];
	}
}
void dfs2(int u, int t) {
	dfn[u] = ++tot; top[u] = t;
	rev[tot] = u;
	if(u != t)
		tree.rt[t] = tree.mrg(tree.rt[t], tree.rt[u]);
	if(!son[u]) {
		ed[u] = tot;
		return ;
	}
	dfs2(son[u], t);
	for (int i = 0; i < e[u].size(); i++) {
		int v = e[u][i];
		if(v == son[u])
			continue;
		dfs2(v, v);
	}
	ed[u] = tot;
}
set<int> s;
struct Segtree {
	long long tr[maxn << 2];
	inline void pushup(int t) {
		tr[t] = max(tr[t << 1], tr[t << 1 | 1]);
	}
	void build(int l, int r, int t) {
		if(l == r) {
			if(top[rev[l]] == rev[l])
				tr[t] = tree.tr[tree.rt[rev[l]]].mx;
			return ;
		}
		int mid = l + r >> 1;
		build(l, mid, t << 1), build(mid + 1, r, t << 1 | 1);
		pushup(t);
	}
	void modify(int l, int r, int pos, int t, long long val) {
		if(l == r) {
			tr[t] = val;
			return ;
		}
		int mid = l + r >> 1;
		if(pos <= mid)
			modify(l, mid, pos, t << 1, val);
		else
			modify(mid + 1, r, pos, t << 1 | 1, val);
		pushup(t);
	}
	long long query(int l, int r, int x, int y, int t) {
		if(x <= l && r <= y)
			return tr[t];
		int mid = l + r >> 1;
		if(y <= mid)
			return query(l, mid, x, y, t << 1);
		if(mid < x)
			return query(mid + 1, r, x, y, t << 1 | 1);
		return max(query(l, mid, x, y, t << 1), query(mid + 1, r, x, y, t << 1 | 1)); 
	}
} tree2;
inline long long query(int x) {
	long long ans = tree2.query(1, n, dfn[x], ed[x], 1);
	return max(ans, tree.query(top[x], dep[x] - dep[top[x]] + 1));
}
queue<int> ers;
inline void change(int x) {
	tree.change(top[x], dep[x] - dep[top[x]] + 1);
	set<int>::iterator itl = s.lower_bound(dfn[x] + 1), itr = s.upper_bound(ed[x]);
	for (set<int>::iterator it = itl; it != itr; it++) 
		tree.change(rev[*it], -1);
	if(tree.tr[tree.rt[top[x]]].mx == 0)
		ers.push(dfn[top[x]]);
	tree2.modify(1, n, dfn[top[x]], 1, tree.tr[tree.rt[top[x]]].mx);
	for (set<int>::iterator it = itl; it != itr; it++) {
		long long v = tree.tr[tree.rt[rev[*it]]].mx;
		tree2.modify(1, n, *it, 1, v);
		if(!v)
			ers.push(*it);
	}
	while(!ers.empty())
		s.erase(ers.front()), ers.pop();
}
inline int read() {
	int sum = 0;
	char c = getchar();
	while(!isdigit(c))
		c = getchar();
	while(isdigit(c))
		sum = sum * 10 + c - '0', c = getchar();
	return sum;
}
void write(long long x) {
	if(x <= 9) {
		putchar(x + '0');
		return ;
	}
	write(x / 10);
	putchar(x % 10 + '0');
}
signed main() {
	n = read(), q = read();
	for (int i = 1; i <= n; i++)
		a[i] = read(), tree.rt[i] = tree.newnode(a[i]);
	for (int i = 2; i <= n; i++)
		f[i] = read(), e[f[i]].push_back(i);
	dfs1(1, 0), dfs2(1, 1);
	tree2.build(1, n, 1);
	for (int i = 1; i <= n; i++)
		if(top[i] == i)
			s.insert(dfn[i]);
	while(q--) {
		int op = read(), x = read();
		if(op == 1)
			write(query(x)), putchar('\n');
		else
			change(x);
	}
	return 0;               
}
```

---

